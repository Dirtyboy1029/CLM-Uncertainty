{"code": "static u16 swf_get_16(SWFReader *read)\n{\n\tu16 val, res;\n\tval = swf_read_int(read, 16);\n\tres = (val&0xFF);\n\tres <<=8;\n\tres |= ((val>>8)&0xFF);\n\treturn res;\n}", "target": 1}
{"code": "static size_t copy_page_to_iter_pipe(struct page *page, size_t offset, size_t bytes,\n\t\t\t struct iov_iter *i)\n{\n\tstruct pipe_inode_info *pipe = i->pipe;\n\tstruct pipe_buffer *buf;\n\tunsigned int p_tail = pipe->tail;\n\tunsigned int p_mask = pipe->ring_size - 1;\n\tunsigned int i_head = i->head;\n\tsize_t off;\n\tif (unlikely(bytes > i->count))\n\t\tbytes = i->count;\n\tif (unlikely(!bytes))\n\t\treturn 0;\n\tif (!sanity(i))\n\t\treturn 0;\n\toff = i->iov_offset;\n\tbuf = &pipe->bufs[i_head & p_mask];\n\tif (off) {\n\t\tif (offset == off && buf->page == page) {\n\t\t\tbuf->len += bytes;\n\t\t\ti->iov_offset += bytes;\n\t\t\tgoto out;\n\t\t}\n\t\ti_head++;\n\t\tbuf = &pipe->bufs[i_head & p_mask];\n\t}\n\tif (pipe_full(i_head, p_tail, pipe->max_usage))\n\t\treturn 0;\n\tbuf->ops = &page_cache_pipe_buf_ops;\n\tget_page(page);\n\tbuf->page = page;\n\tbuf->offset = offset;\n\tbuf->len = bytes;\n\tpipe->head = i_head + 1;\n\ti->iov_offset = offset + bytes;\n\ti->head = i_head;\nout:\n\ti->count -= bytes;\n\treturn bytes;\n}", "target": 1}
{"code": "void SimpleModule::runPull()\n{\n\tpull(m_outChunk->frameCount);\n\trun(*m_inChunk, *m_outChunk);\n}", "target": 1}
{"code": "    uint32_t SonyMnHeader::ifdOffset() const\n    {\n        return start_;\n    }", "target": 0}
{"code": "static void vcpu_scan_ioapic(struct kvm_vcpu *vcpu)\n{\n\tif (!kvm_apic_hw_enabled(vcpu->arch.apic))\n\t\treturn;\n\tbitmap_zero(vcpu->arch.ioapic_handled_vectors, 256);\n\tif (irqchip_split(vcpu->kvm))\n\t\tkvm_scan_ioapic_routes(vcpu, vcpu->arch.ioapic_handled_vectors);\n\telse {\n\t\tif (vcpu->arch.apicv_active)\n\t\t\tkvm_x86_ops->sync_pir_to_irr(vcpu);\n\t\tkvm_ioapic_scan_entry(vcpu, vcpu->arch.ioapic_handled_vectors);\n\t}\n\tif (is_guest_mode(vcpu))\n\t\tvcpu->arch.load_eoi_exitmap_pending = true;\n\telse\n\t\tkvm_make_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu);\n}", "target": 1}
{"code": "static void sp_setup(struct net_device *dev)\n{\n\tdev->netdev_ops\t\t= &sp_netdev_ops;\n\tdev->needs_free_netdev\t= true;\n\tdev->mtu\t\t= SIXP_MTU;\n\tdev->hard_header_len\t= AX25_MAX_HEADER_LEN;\n\tdev->header_ops \t= &ax25_header_ops;\n\tdev->addr_len\t\t= AX25_ADDR_LEN;\n\tdev->type\t\t= ARPHRD_AX25;\n\tdev->tx_queue_len\t= 10;\n\tmemcpy(dev->broadcast, &ax25_bcast, AX25_ADDR_LEN);\n\tdev_addr_set(dev, (u8 *)&ax25_defaddr);\n\tdev->flags\t\t= 0;\n}", "target": 1}
{"code": "void cgit_snapshot_link(const char *name, const char *title, const char *class,\n\t\t\tconst char *head, const char *rev,\n\t\t\tconst char *archivename)\n{\n\treporevlink(\"snapshot\", name, title, class, head, rev, archivename);\n}", "target": 0}
{"code": "void recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h, *g;\n\tunsigned int i;\n\tvmcb_mark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\tc = &svm->vmcb->control;\n\th = &svm->vmcb01.ptr->control;\n\tg = &svm->nested.ctl;\n\tfor (i = 0; i < MAX_INTERCEPT; i++)\n\t\tc->intercepts[i] = h->intercepts[i];\n\tif (g->int_ctl & V_INTR_MASKING_MASK) {\n\t\tvmcb_clr_intercept(c, INTERCEPT_CR8_READ);\n\t\tvmcb_clr_intercept(c, INTERCEPT_CR8_WRITE);\n\t\tvmcb_clr_intercept(c, INTERCEPT_VINTR);\n\t}\n\tvmcb_clr_intercept(c, INTERCEPT_VMMCALL);\n\tfor (i = 0; i < MAX_INTERCEPT; i++)\n\t\tc->intercepts[i] |= g->intercepts[i];\n\tif (!intercept_smi)\n\t\tvmcb_clr_intercept(c, INTERCEPT_SMI);\n\tvmcb_set_intercept(c, INTERCEPT_VMLOAD);\n\tvmcb_set_intercept(c, INTERCEPT_VMSAVE);\n}", "target": 0}
{"code": "GetNumWrongData(const byte * curPtr, const int maxnum)\n{\n    int count = 0;\n    if (1 == maxnum) {\n        return (1);\n    }\n    while (*(curPtr + count) != *(curPtr + count + 1) && maxnum > count) {\n        count++;\n    }\n    return (count);\n}", "target": 1}
{"code": "static void put_prev_entity(struct cfs_rq *cfs_rq, struct sched_entity *prev)\n{\n\tif (prev->on_rq)\n\t\tupdate_curr(cfs_rq);\n\tcheck_spread(cfs_rq, prev);\n\tif (prev->on_rq) {\n\t\tupdate_stats_wait_start(cfs_rq, prev);\n\t\t__enqueue_entity(cfs_rq, prev);\n\t}\n\tcfs_rq->curr = NULL;\n}", "target": 0}
{"code": "int fpm_unix_resolve_socket_premissions(struct fpm_worker_pool_s *wp) \n{\n\tstruct fpm_worker_pool_config_s *c = wp->config;\n\twp->socket_uid = -1;\n\twp->socket_gid = -1;\n\twp->socket_mode = 0666;\n\tif (!c) {\n\t\treturn 0;\n\t}\n\tif (c->listen_owner && *c->listen_owner) {\n\t\tstruct passwd *pwd;\n\t\tpwd = getpwnam(c->listen_owner);\n\t\tif (!pwd) {\n\t\t\tzlog(ZLOG_SYSERROR, \"[pool %s] cannot get uid for user '%s'\", wp->config->name, c->listen_owner);\n\t\t\treturn -1;\n\t\t}\n\t\twp->socket_uid = pwd->pw_uid;\n\t\twp->socket_gid = pwd->pw_gid;\n\t}\n\tif (c->listen_group && *c->listen_group) {\n\t\tstruct group *grp;\n\t\tgrp = getgrnam(c->listen_group);\n\t\tif (!grp) {\n\t\t\tzlog(ZLOG_SYSERROR, \"[pool %s] cannot get gid for group '%s'\", wp->config->name, c->listen_group);\n\t\t\treturn -1;\n\t\t}\n\t\twp->socket_gid = grp->gr_gid;\n\t}\n\tif (c->listen_mode && *c->listen_mode) {\n\t\twp->socket_mode = strtoul(c->listen_mode, 0, 8);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "  bool IsInitialized() { return state_ == INITIALIZED; }", "target": 0}
{"code": "void MultiplySum(const size_t xsize,\n                 const pixel_type* const JXL_RESTRICT row_in,\n                 const pixel_type* const JXL_RESTRICT row_in_Y,\n                 const float factor, float* const JXL_RESTRICT row_out) {\n  const HWY_FULL(float) df;\n  const Rebind<pixel_type, HWY_FULL(float)> di;  \n  const auto factor_v = Set(df, factor);\n  for (size_t x = 0; x < xsize; x += Lanes(di)) {\n    const auto in = Load(di, row_in + x) + Load(di, row_in_Y + x);\n    const auto out = ConvertTo(df, in) * factor_v;\n    Store(out, df, row_out + x);\n  }\n}", "target": 0}
{"code": "void __qdisc_run(struct net_device *dev)\n{\n\tdo {\n\t\tif (!qdisc_restart(dev))\n\t\t\tbreak;\n\t} while (!netif_queue_stopped(dev));\n\tclear_bit(__LINK_STATE_QDISC_RUNNING, &dev->state);\n}", "target": 1}
{"code": "rndset(unsigned long v)\n{\n\tregister uint32_t h;\n#if defined(arc4random_pushb_fast) || defined(MKSH_A4PB)\n\tregister uint32_t t;\n#endif\n\tstruct {\n\t\tstruct timeval tv;\n\t\tvoid *sp;\n\t\tuint32_t qh;\n\t\tpid_t pp;\n\t\tshort r;\n\t} z;\n#ifdef DEBUG\n\tmemset(&z, 0, sizeof(z));\n#endif\n\th = lcg_state;\n\tBAFHFinish_reg(h);\n\tBAFHUpdateMem_reg(h, &v, sizeof(v));\n\tmksh_TIME(z.tv);\n\tz.sp = &lcg_state;\n\tz.pp = procpid;\n\tz.r = (short)rndget();\n#if defined(arc4random_pushb_fast) || defined(MKSH_A4PB)\n\tt = qh_state;\n\tBAFHFinish_reg(t);\n\tz.qh = (t & 0xFFFF8000) | rndget();\n\tlcg_state = (t << 15) | rndget();\n\tt = h;\n\tBAFHUpdateMem_reg(t, &lcg_state, sizeof(lcg_state));\n\tBAFHFinish_reg(t);\n\tlcg_state = t;\n#if defined(arc4random_pushb_fast)\n\tarc4random_pushb_fast(&lcg_state, sizeof(lcg_state));\n\tlcg_state = arc4random();\n#else\n\tlcg_state = arc4random_pushb(&lcg_state, sizeof(lcg_state));\n#endif\n\tBAFHUpdateMem_reg(h, &lcg_state, sizeof(lcg_state));\n#else\n\tz.qh = qh_state;\n#endif\n\tBAFHUpdateMem_reg(h, &z, sizeof(z));\n\tBAFHFinish_reg(h);\n\tlcg_state = h;\n}", "target": 0}
{"code": "static int ftp_send_command(struct connectdata *conn, const char *message, ...)\n{\n  int ftp_code;\n  ssize_t nread = 0;\n  va_list args;\n  char print_buffer[50];\n  va_start(args, message);\n  mvsnprintf(print_buffer, sizeof(print_buffer), message, args);\n  va_end(args);\n  if(Curl_ftpsend(conn, print_buffer)) {\n    ftp_code = -1;\n  }\n  else {\n    if(Curl_GetFTPResponse(&nread, conn, &ftp_code))\n      ftp_code = -1;\n  }\n  (void)nread; \n  return ftp_code;\n}", "target": 0}
{"code": "int ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d,\n                                 int n)\n{\n    int al = -1;\n    unsigned char *ptmp = *p;\n    if (ssl_scan_clienthello_tlsext(s, p, d, n, &al) <= 0) {\n        ssl3_send_alert(s, SSL3_AL_FATAL, al);\n        return 0;\n    }\n    if (ssl_check_clienthello_tlsext_early(s) <= 0) {\n        SSLerr(SSL_F_SSL_PARSE_CLIENTHELLO_TLSEXT, SSL_R_CLIENTHELLO_TLSEXT);\n        return 0;\n    }\n    custom_ext_init(&s->cert->srv_ext);\n    if (ssl_scan_clienthello_custom_tlsext(s, ptmp, d + n, &al) <= 0) {\n        ssl3_send_alert(s, SSL3_AL_FATAL, al);\n        return 0;\n    }\n    return 1;\n}", "target": 0}
{"code": "String Document::cookie(ExceptionState& exception_state) const {\n  if (GetSettings() && !GetSettings()->GetCookieEnabled())\n    return String();\n  UseCounter::Count(*this, WebFeature::kCookieGet);\n  if (!GetSecurityOrigin()->CanAccessCookies()) {\n    if (IsSandboxed(kSandboxOrigin))\n      exception_state.ThrowSecurityError(\n          \"The document is sandboxed and lacks the 'allow-same-origin' flag.\");\n    else if (Url().ProtocolIs(\"data\"))\n      exception_state.ThrowSecurityError(\n          \"Cookies are disabled inside 'data:' URLs.\");\n    else\n      exception_state.ThrowSecurityError(\"Access is denied for this document.\");\n    return String();\n  }\n  if (GetSecurityOrigin()->HasSuborigin() &&\n      !GetSecurityOrigin()->GetSuborigin()->PolicyContains(\n          Suborigin::SuboriginPolicyOptions::kUnsafeCookies))\n    return String();\n  KURL cookie_url = CookieURL();\n  if (cookie_url.IsEmpty())\n    return String();\n  return Cookies(this, cookie_url);\n}", "target": 0}
{"code": "int sldns_str2wire_eui48_buf(const char* str, uint8_t* rd, size_t* len)\n{\n\tunsigned int a, b, c, d, e, f;\n\tint l;\n\tif(*len < 6)\n\t\treturn LDNS_WIREPARSE_ERR_BUFFER_TOO_SMALL;\n\tif (sscanf(str, \"%2x-%2x-%2x-%2x-%2x-%2x%n\",\n\t\t\t&a, &b, &c, &d, &e, &f, &l) != 6 ||\n\t\t\tl != (int)strlen(str))\n\t\treturn LDNS_WIREPARSE_ERR_SYNTAX_EUI48;\n\trd[0] = a;\n\trd[1] = b;\n\trd[2] = c;\n\trd[3] = d;\n\trd[4] = e;\n\trd[5] = f;\n\t*len = 6;\n\treturn LDNS_WIREPARSE_ERR_OK;\n}", "target": 0}
{"code": "PHP_FUNCTION(grapheme_strlen)\n{\n\tunsigned char* string;\n\tint string_len;\n\tUChar* ustring = NULL;\n\tint ustring_len = 0;\n\tint ret_len;\n\tUErrorCode status;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", (char **)&string, &string_len) == FAILURE) {\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t \"grapheme_strlen: unable to parse input param\", 0 TSRMLS_CC );\n\t\tRETURN_FALSE;\n\t}\n\tret_len = grapheme_ascii_check(string, string_len);\n\tif ( ret_len >= 0 )\n\t\tRETURN_LONG(ret_len);\n\tstatus = U_ZERO_ERROR;\n\tintl_convert_utf8_to_utf16(&ustring, &ustring_len, (char*) string, string_len, &status );\n\tif ( U_FAILURE( status ) ) {\n\t\tintl_error_set_code( NULL, status TSRMLS_CC );\n\t\tintl_error_set_custom_msg( NULL, \"Error converting input string to UTF-16\", 0 TSRMLS_CC );\n\t\tif (ustring) {\n\t\t\tefree( ustring );\n\t\t}\n\t\tRETURN_NULL();\n\t}\n\tret_len = grapheme_split_string(ustring, ustring_len, NULL, 0 TSRMLS_CC );\n\tif (ustring) {\n\t\tefree( ustring );\n\t}\n\tif (ret_len >= 0) {\n\t\tRETVAL_LONG(ret_len);\n\t} else {\n\t\tRETVAL_FALSE;\n\t}\n}", "target": 0}
{"code": " cdf_file_summary_info(struct magic_set *ms, const cdf_header_t *h,\n    const cdf_stream_t *sst, const cdf_directory_t *root_storage)\n {\n         cdf_summary_info_header_t si;\n         cdf_property_info_t *info;\n        size_t count;\n        int m;\n        if (cdf_unpack_summary_info(sst, h, &si, &info, &count) == -1)\n                return -1;\n        if (NOTMIME(ms)) {\n\t\tconst char *str;\n                if (file_printf(ms, \"Composite Document File V2 Document\")\n\t\t    == -1)\n                        return -1;\n                if (file_printf(ms, \", %s Endian\",\n                    si.si_byte_order == 0xfffe ?  \"Little\" : \"Big\") == -1)\n                        return -2;\n                switch (si.si_os) {\n                case 2:\n                        if (file_printf(ms, \", Os: Windows, Version %d.%d\",\n                            si.si_os_version & 0xff,\n                            (uint32_t)si.si_os_version >> 8) == -1)\n                                return -2;\n                        break;\n                case 1:\n                        if (file_printf(ms, \", Os: MacOS, Version %d.%d\",\n                            (uint32_t)si.si_os_version >> 8,\n                            si.si_os_version & 0xff) == -1)\n                                return -2;\n                        break;\n                default:\n                        if (file_printf(ms, \", Os %d, Version: %d.%d\", si.si_os,\n                            si.si_os_version & 0xff,\n                            (uint32_t)si.si_os_version >> 8) == -1)\n                                 return -2;\n                         break;\n                 }\n\t\tif (root_storage) {\n\t\t\tstr = cdf_clsid_to_mime(root_storage->d_storage_uuid, clsid2desc);\n\t\t\tif (str)\n\t\t\t\tif (file_printf(ms, \", %s\", str) == -1)\n\t\t\t\t\treturn -2;\n\t\t\t}\n\t\t}\n        m = cdf_file_property_info(ms, info, count, root_storage);\n         free(info);\n         return m == -1 ? -2 : m;\n}", "target": 0}
{"code": "socks_request_free(socks_request_t *req)\n{\n  if (!req)\n    return;\n  if (req->username) {\n    memwipe(req->username, 0x10, req->usernamelen);\n    tor_free(req->username);\n  }\n  if (req->password) {\n    memwipe(req->password, 0x04, req->passwordlen);\n    tor_free(req->password);\n  }\n  memwipe(req, 0xCC, sizeof(socks_request_t));\n  tor_free(req);\n}", "target": 0}
{"code": "void LibRaw::convert_to_rgb_loop(float out_cam[3][4]) {}", "target": 0}
{"code": "static int update_frag_index(MOVContext *c, int64_t offset)\n{\n    int index, i;\n    MOVFragmentIndexItem * item;\n    MOVFragmentStreamInfo * frag_stream_info;\n    index = search_frag_moof_offset(&c->frag_index, offset);\n    if (index < c->frag_index.nb_items &&\n        c->frag_index.item[index].moof_offset == offset)\n        return index;\n    item = av_fast_realloc(c->frag_index.item,\n                           &c->frag_index.allocated_size,\n                           (c->frag_index.nb_items + 1) *\n                           sizeof(*c->frag_index.item));\n    if (!item)\n        return -1;\n    c->frag_index.item = item;\n    frag_stream_info = av_realloc_array(NULL, c->fc->nb_streams,\n                                        sizeof(*item->stream_info));\n    if (!frag_stream_info)\n        return -1;\n    for (i = 0; i < c->fc->nb_streams; i++) {\n        if (c->fc->streams[i]->id < 0) {\n            av_free(frag_stream_info);\n            return AVERROR_INVALIDDATA;\n        }\n        frag_stream_info[i].id = c->fc->streams[i]->id;\n        frag_stream_info[i].sidx_pts = AV_NOPTS_VALUE;\n        frag_stream_info[i].tfdt_dts = AV_NOPTS_VALUE;\n        frag_stream_info[i].next_trun_dts = AV_NOPTS_VALUE;\n        frag_stream_info[i].first_tfra_pts = AV_NOPTS_VALUE;\n        frag_stream_info[i].index_base = -1;\n        frag_stream_info[i].index_entry = -1;\n        frag_stream_info[i].encryption_index = NULL;\n    }\n    if (index < c->frag_index.nb_items)\n        memmove(c->frag_index.item + index + 1, c->frag_index.item + index,\n                (c->frag_index.nb_items - index) * sizeof(*c->frag_index.item));\n    item = &c->frag_index.item[index];\n    item->headers_read = 0;\n    item->current = 0;\n    item->nb_stream_info = c->fc->nb_streams;\n    item->moof_offset = offset;\n    item->stream_info = frag_stream_info;\n    c->frag_index.nb_items++;\n    return index;\n}", "target": 0}
{"code": "static int check_is_mount_child(void *p)\n{\n\tconst char **a = p;\n\tconst char *last = a[0];\n\tconst char *mnt = a[1];\n\tint res;\n\tconst char *procmounts = \"/proc/mounts\";\n\tint found;\n\tFILE *fp;\n\tstruct mntent *entp;\n\tint count;\n\tres = mount(\"\", \"/\", \"\", MS_PRIVATE | MS_REC, NULL);\n\tif (res == -1) {\n\t\tfprintf(stderr, \"%s: failed to mark mounts private: %s\\n\",\n\t\t\tprogname, strerror(errno));\n\t\treturn 1;\n\t}\n\tfp = setmntent(procmounts, \"r\");\n\tif (fp == NULL) {\n\t\tfprintf(stderr, \"%s: failed to open %s: %s\\n\", progname,\n\t\t\tprocmounts, strerror(errno));\n\t\treturn 1;\n\t}\n\tcount = 0;\n\twhile (getmntent(fp) != NULL)\n\t\tcount++;\n\tendmntent(fp);\n\tfp = setmntent(procmounts, \"r\");\n\tif (fp == NULL) {\n\t\tfprintf(stderr, \"%s: failed to open %s: %s\\n\", progname,\n\t\t\tprocmounts, strerror(errno));\n\t\treturn 1;\n\t}\n\tres = mount(\".\", \"/\", \"\", MS_BIND | MS_REC, NULL);\n\tif (res == -1) {\n\t\tfprintf(stderr, \"%s: failed to bind parent to /: %s\\n\",\n\t\t\tprogname, strerror(errno));\n\t\treturn 1;\n\t}\n\tfound = 0;\n\twhile ((entp = getmntent(fp)) != NULL) {\n\t\tif (count > 0) {\n\t\t\tcount--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (entp->mnt_dir[0] == '/' &&\n\t\t    strcmp(entp->mnt_dir + 1, last) == 0) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tendmntent(fp);\n\tif (!found) {\n\t\tfprintf(stderr, \"%s: %s not mounted\\n\", progname, mnt);\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "smb3_receive_transform(struct TCP_Server_Info *server,\n\t\t       struct mid_q_entry **mids, char **bufs, int *num_mids)\n{\n\tchar *buf = server->smallbuf;\n\tunsigned int pdu_length = server->pdu_size;\n\tstruct smb2_transform_hdr *tr_hdr = (struct smb2_transform_hdr *)buf;\n\tunsigned int orig_len = le32_to_cpu(tr_hdr->OriginalMessageSize);\n\tif (pdu_length < sizeof(struct smb2_transform_hdr) +\n\t\t\t\t\t\tsizeof(struct smb2_hdr)) {\n\t\tcifs_server_dbg(VFS, \"Transform message is too small (%u)\\n\",\n\t\t\t pdu_length);\n\t\tcifs_reconnect(server, true);\n\t\treturn -ECONNABORTED;\n\t}\n\tif (pdu_length < orig_len + sizeof(struct smb2_transform_hdr)) {\n\t\tcifs_server_dbg(VFS, \"Transform message is broken\\n\");\n\t\tcifs_reconnect(server, true);\n\t\treturn -ECONNABORTED;\n\t}\n\tif (pdu_length > CIFSMaxBufSize + MAX_HEADER_SIZE(server)) {\n\t\treturn receive_encrypted_read(server, &mids[0], num_mids);\n\t}\n\treturn receive_encrypted_standard(server, mids, bufs, num_mids);\n}", "target": 0}
{"code": "    ByteOrder TiffParser::decode(\n              ExifData& exifData,\n              IptcData& iptcData,\n              XmpData&  xmpData,\n        const byte*     pData,\n              uint32_t  size\n    )\n    {\n        return TiffParserWorker::decode(exifData,\n                                        iptcData,\n                                        xmpData,\n                                        pData,\n                                        size,\n                                        Tag::root,\n                                        TiffMapping::findDecoder);\n    } ", "target": 0}
{"code": "comics_document_finalize (GObject *object)\n{\n\tComicsDocument *comics_document = COMICS_DOCUMENT (object);\n\tif (comics_document->decompress_tmp) {\n\t\tif (comics_remove_dir (comics_document->dir) == -1)\n\t\t\tg_warning (_(\"There was an error deleting “%s”.\"),\n\t\t\t\t   comics_document->dir);\n\t\tg_free (comics_document->dir);\n\t}\n\tif (comics_document->page_names) {\n                g_ptr_array_foreach (comics_document->page_names, (GFunc) g_free, NULL);\n                g_ptr_array_free (comics_document->page_names, TRUE);\n\t}\n\tg_free (comics_document->archive);\n\tg_free (comics_document->selected_command);\n\tg_free (comics_document->alternative_command);\n\tg_free (comics_document->extract_command);\n\tg_free (comics_document->list_command);\n\tG_OBJECT_CLASS (comics_document_parent_class)->finalize (object);\n}", "target": 1}
{"code": "static int sched_read_attr(struct sched_attr __user *uattr,\n\t\t\t   struct sched_attr *attr,\n\t\t\t   unsigned int usize)\n{\n\tint ret;\n\tif (!access_ok(VERIFY_WRITE, uattr, usize))\n\t\treturn -EFAULT;\n\tif (usize < sizeof(*attr)) {\n\t\tunsigned char *addr;\n\t\tunsigned char *end;\n\t\taddr = (void *)attr + usize;\n\t\tend  = (void *)attr + sizeof(*attr);\n\t\tfor (; addr < end; addr++) {\n\t\t\tif (*addr)\n\t\t\t\tgoto err_size;\n\t\t}\n\t\tattr->size = usize;\n\t}\n\tret = copy_to_user(uattr, attr, usize);\n\tif (ret)\n\t\treturn -EFAULT;\nout:\n\treturn ret;\nerr_size:\n\tret = -E2BIG;\n\tgoto out;\n}", "target": 1}
{"code": "lexer_compare_identifier_to_current (parser_context_t *context_p,        \n                                     const lexer_lit_location_t *right)  \n{\n  lexer_lit_location_t *left = &context_p->token.lit_location;\n  const uint8_t *left_p;\n  const uint8_t *right_p;\n  size_t count;\n  JERRY_ASSERT (left->length > 0 && right->length > 0);\n  if (left->length != right->length)\n  {\n    return 0;\n  }\n  if (!left->has_escape && !right->has_escape)\n  {\n    return memcmp (left->char_p, right->char_p, left->length) == 0;\n  }\n  left_p = left->char_p;\n  right_p = right->char_p;\n  count = left->length;\n  do\n  {\n    uint8_t utf8_buf[3];\n    size_t utf8_len, offset;\n    if (*left_p != LIT_CHAR_BACKSLASH && *right_p != LIT_CHAR_BACKSLASH)\n    {\n      if (*left_p++ != *right_p++)\n      {\n        return false;\n      }\n      count--;\n      continue;\n    }\n    if (*left_p == LIT_CHAR_BACKSLASH && *right_p == LIT_CHAR_BACKSLASH)\n    {\n      uint16_t left_chr = lexer_hex_to_character (context_p, left_p, 6);\n      if (left_chr != lexer_hex_to_character (context_p, right_p, 6))\n      {\n        return false;\n      }\n      left_p += 6;\n      right_p += 6;\n      count += lit_char_get_utf8_length (left_chr);\n      continue;\n    }\n    if (*right_p == LIT_CHAR_BACKSLASH)\n    {\n      const uint8_t *swap_p = left_p;\n      left_p = right_p;\n      right_p = swap_p;\n    }\n    utf8_len = lit_char_to_utf8_bytes (utf8_buf, lexer_hex_to_character (context_p, left_p, 6));\n    JERRY_ASSERT (utf8_len > 0);\n    count -= utf8_len;\n    offset = 0;\n    do\n    {\n      if (utf8_buf[offset] != *right_p++)\n      {\n        return false;\n      }\n      offset++;\n    }\n    while (offset < utf8_len);\n    left_p += 6;\n  }\n  while (count > 0);\n  return true;\n} ", "target": 0}
{"code": "GF_Err gf_isom_avc_config_new(GF_ISOFile *the_file, u32 trackNumber, GF_AVCConfig *cfg, const char *URLname, const char *URNname, u32 *outDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_SampleDescriptionBox *stsd;\n\tu32 dataRefIndex;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !cfg) return GF_BAD_PARAM;\n\te = Media_FindDataRef(trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\tif (e) return e;\n\tif (!dataRefIndex) {\n\t\te = Media_CreateDataRef(the_file, trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\t\tif (e) return e;\n\t}\n\tif (!the_file->keep_utc && !gf_sys_is_test_mode() )\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tentry = (GF_MPEGVisualSampleEntryBox *) gf_isom_box_new_parent(&stsd->child_boxes, GF_ISOM_BOX_TYPE_AVC1);\n\tif (!entry) return GF_OUT_OF_MEM;\n\t*outDescriptionIndex = gf_list_count(stsd->child_boxes);\n\tentry->avc_config = (GF_AVCConfigurationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_AVCC);\n\tif (!entry->avc_config) return GF_OUT_OF_MEM;\n\tentry->avc_config->config = AVC_DuplicateConfig(cfg);\n\tif (!entry->avc_config->config) return GF_OUT_OF_MEM;\n\tentry->dataReferenceIndex = dataRefIndex;\n\tAVC_RewriteESDescriptor(entry);\n\treturn e;\n}", "target": 0}
{"code": "void set_device_ro(struct block_device *bdev, int flag)\n{\n\tbdev->bd_part->policy = flag;\n}", "target": 0}
{"code": "ssh_packet_set_compress_state(struct ssh *ssh, struct sshbuf *m)\n{\n\tstruct session_state *state = ssh->state;\n\tstruct sshbuf *b = NULL;\n\tint r;\n\tconst u_char *inblob, *outblob;\n\tsize_t inl, outl;\n\tif ((r = sshbuf_froms(m, &b)) != 0)\n\t\tgoto out;\n\tif ((r = sshbuf_get_string_direct(b, &inblob, &inl)) != 0 ||\n\t    (r = sshbuf_get_string_direct(b, &outblob, &outl)) != 0)\n\t\tgoto out;\n\tif (inl == 0)\n\t\tstate->compression_in_started = 0;\n\telse if (inl != sizeof(state->compression_in_stream)) {\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t} else {\n\t\tstate->compression_in_started = 1;\n\t\tmemcpy(&state->compression_in_stream, inblob, inl);\n\t}\n\tif (outl == 0)\n\t\tstate->compression_out_started = 0;\n\telse if (outl != sizeof(state->compression_out_stream)) {\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t} else {\n\t\tstate->compression_out_started = 1;\n\t\tmemcpy(&state->compression_out_stream, outblob, outl);\n\t}\n\tr = 0;\n out:\n\tsshbuf_free(b);\n\treturn r;\n}", "target": 1}
{"code": "bool red_stream_write_all(RedStream *stream, const void *in_buf, size_t n)\n{\n    const uint8_t *buf = (uint8_t *)in_buf;\n    while (n) {\n        int now = red_stream_write(stream, buf, n);\n        if (now <= 0) {\n            if (now == -1 && (errno == EINTR || errno == EAGAIN)) {\n                continue;\n            }\n            return false;\n        }\n        n -= now;\n        buf += now;\n    }\n    return true;\n}", "target": 0}
{"code": "my_decimal *Item_string::val_decimal(my_decimal *decimal_value)\n{\n  return val_decimal_from_string(decimal_value);\n}", "target": 0}
{"code": "static void OneLineTransp(struct ico_progressive_state *context)\n{\n\tgint X;\n\tguchar *Pixels;\n\tif (context->Header.depth == 32)\n\t\treturn;\n\tX = 0;\n\tif (context->Header.Negative == 0)\n\t\tPixels = (context->pixbuf->pixels +\n\t\t\t  (gsize) context->pixbuf->rowstride *\n\t\t\t  (2*context->Header.height - context->Lines - 1));\n\telse\n\t\tPixels = (context->pixbuf->pixels +\n\t\t\t  (gsize) context->pixbuf->rowstride *\n\t\t\t  (context->Lines-context->Header.height));\n\twhile (X < context->Header.width) {\n\t\tint Bit;\n\t\tBit = (context->LineBuf[X / 8]) >> (7 - (X & 7));\n\t\tBit = Bit & 1;\n\t\tPixels[X * 4 + 3] = 255-Bit*255;\n#if 0\n\t\tif (Bit){\n\t\t  Pixels[X*4+0] = 255;\n\t\t  Pixels[X*4+1] = 255;\n\t\t} else {\n\t\t  Pixels[X*4+0] = 0;\n\t\t  Pixels[X*4+1] = 0;\n\t\t}\n#endif\t\t\n\t\tX++;\n\t}\n}", "target": 0}
{"code": "key_ref_t search_process_keyrings(struct key_type *type,\n\t\t\t\t  const void *description,\n\t\t\t\t  key_match_func_t match,\n\t\t\t\t  const struct cred *cred)\n{\n\tstruct request_key_auth *rka;\n\tkey_ref_t key_ref, ret = ERR_PTR(-EACCES), err;\n\tmight_sleep();\n\tkey_ref = search_my_process_keyrings(type, description, match,\n\t\t\t\t\t     false, cred);\n\tif (!IS_ERR(key_ref))\n\t\tgoto found;\n\terr = key_ref;\n\tif (cred->request_key_auth &&\n\t    cred == current_cred() &&\n\t    type != &key_type_request_key_auth\n\t    ) {\n\t\tdown_read(&cred->request_key_auth->sem);\n\t\tif (key_validate(cred->request_key_auth) == 0) {\n\t\t\trka = cred->request_key_auth->payload.data;\n\t\t\tkey_ref = search_process_keyrings(type, description,\n\t\t\t\t\t\t\t  match, rka->cred);\n\t\t\tup_read(&cred->request_key_auth->sem);\n\t\t\tif (!IS_ERR(key_ref))\n\t\t\t\tgoto found;\n\t\t\tret = key_ref;\n\t\t} else {\n\t\t\tup_read(&cred->request_key_auth->sem);\n\t\t}\n\t}\n\tif (err == ERR_PTR(-ENOKEY) || ret == ERR_PTR(-ENOKEY))\n\t\tkey_ref = ERR_PTR(-ENOKEY);\n\telse if (err == ERR_PTR(-EACCES))\n\t\tkey_ref = ret;\n\telse\n\t\tkey_ref = err;\nfound:\n\treturn key_ref;\n}", "target": 0}
{"code": "void luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v) {\n  global_State *g = G(L);\n  lua_assert(isblack(o) && iswhite(v) && !isdead(g, v) && !isdead(g, o));\n  if (keepinvariant(g)) {  \n    reallymarkobject(g, v);  \n    if (isold(o)) {\n      lua_assert(!isold(v));  \n      setage(v, G_OLD0);  \n    }\n  }\n  else {  \n    lua_assert(issweepphase(g));\n    makewhite(g, o);  \n  }\n}", "target": 1}
{"code": "ppp_receive_frame(struct ppp *ppp, struct sk_buff *skb, struct channel *pch)\n{\n\tif (pskb_may_pull(skb, 2)) {\n#ifdef CONFIG_PPP_MULTILINK\n\t\tif (PPP_PROTO(skb) == PPP_MP)\n\t\t\tppp_receive_mp_frame(ppp, skb, pch);\n\t\telse\n#endif \n\t\t\tppp_receive_nonmp_frame(ppp, skb);\n\t\treturn;\n\t}\n\tif (skb->len > 0)\n\t\t++ppp->dev->stats.rx_length_errors;\n\tkfree_skb(skb);\n\tppp_receive_error(ppp);\n}", "target": 0}
{"code": "static int mp_get_count(struct sb_uart_state *state, struct serial_icounter_struct *icnt)\n{\n\tstruct serial_icounter_struct icount;\n\tstruct sb_uart_icount cnow;\n\tstruct sb_uart_port *port = state->port;\n\tspin_lock_irq(&port->lock);\n\tmemcpy(&cnow, &port->icount, sizeof(struct sb_uart_icount));\n\tspin_unlock_irq(&port->lock);\n\ticount.cts         = cnow.cts;\n\ticount.dsr         = cnow.dsr;\n\ticount.rng         = cnow.rng;\n\ticount.dcd         = cnow.dcd;\n\ticount.rx          = cnow.rx;\n\ticount.tx          = cnow.tx;\n\ticount.frame       = cnow.frame;\n\ticount.overrun     = cnow.overrun;\n\ticount.parity      = cnow.parity;\n\ticount.brk         = cnow.brk;\n\ticount.buf_overrun = cnow.buf_overrun;\n\treturn copy_to_user(icnt, &icount, sizeof(icount)) ? -EFAULT : 0;\n}", "target": 1}
{"code": "static int tc_fill_tclass(struct sk_buff *skb, struct Qdisc *q,\n\t\t\t  unsigned long cl,\n\t\t\t  u32 pid, u32 seq, u16 flags, int event)\n{\n\tstruct tcmsg *tcm;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct gnet_dump d;\n\tconst struct Qdisc_class_ops *cl_ops = q->ops->cl_ops;\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*tcm), flags);\n\ttcm = NLMSG_DATA(nlh);\n\ttcm->tcm_family = AF_UNSPEC;\n\ttcm->tcm_ifindex = qdisc_dev(q)->ifindex;\n\ttcm->tcm_parent = q->handle;\n\ttcm->tcm_handle = q->handle;\n\ttcm->tcm_info = 0;\n\tNLA_PUT_STRING(skb, TCA_KIND, q->ops->id);\n\tif (cl_ops->dump && cl_ops->dump(q, cl, skb, tcm) < 0)\n\t\tgoto nla_put_failure;\n\tif (gnet_stats_start_copy_compat(skb, TCA_STATS2, TCA_STATS, TCA_XSTATS,\n\t\t\t\t\t qdisc_root_sleeping_lock(q), &d) < 0)\n\t\tgoto nla_put_failure;\n\tif (cl_ops->dump_stats && cl_ops->dump_stats(q, cl, &d) < 0)\n\t\tgoto nla_put_failure;\n\tif (gnet_stats_finish_copy(&d) < 0)\n\t\tgoto nla_put_failure;\n\tnlh->nlmsg_len = skb_tail_pointer(skb) - b;\n\treturn skb->len;\nnlmsg_failure:\nnla_put_failure:\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}", "target": 1}
{"code": "int phar_tar_setmetadata(zval *metadata, phar_entry_info *entry, char **error TSRMLS_DC) \n{\n\tphp_serialize_data_t metadata_hash;\n\tif (entry->metadata_str.c) {\n\t\tsmart_str_free(&entry->metadata_str);\n\t}\n\tentry->metadata_str.c = 0;\n\tentry->metadata_str.len = 0;\n\tPHP_VAR_SERIALIZE_INIT(metadata_hash);\n\tphp_var_serialize(&entry->metadata_str, &metadata, &metadata_hash TSRMLS_CC);\n\tPHP_VAR_SERIALIZE_DESTROY(metadata_hash);\n\tentry->uncompressed_filesize = entry->compressed_filesize = entry->metadata_str.len;\n\tif (entry->fp && entry->fp_type == PHAR_MOD) {\n\t\tphp_stream_close(entry->fp);\n\t}\n\tentry->fp_type = PHAR_MOD;\n\tentry->is_modified = 1;\n\tentry->fp = php_stream_fopen_tmpfile();\n\tentry->offset = entry->offset_abs = 0;\n\tif (entry->fp == NULL) {\n\t\tspprintf(error, 0, \"phar error: unable to create temporary file\");\n\t\treturn -1;\n\t}\n\tif (entry->metadata_str.len != php_stream_write(entry->fp, entry->metadata_str.c, entry->metadata_str.len)) {\n\t\tspprintf(error, 0, \"phar tar error: unable to write metadata to magic metadata file \\\"%s\\\"\", entry->filename);\n\t\tzend_hash_del(&(entry->phar->manifest), entry->filename, entry->filename_len);\n\t\treturn ZEND_HASH_APPLY_STOP;\n\t}\n\treturn ZEND_HASH_APPLY_KEEP;\n}", "target": 0}
{"code": "exit_cifs_idmap(void)\n{\n\tkey_revoke(root_cred->thread_keyring);\n\tunregister_key_type(&cifs_idmap_key_type);\n\tput_cred(root_cred);\n\tcifs_dbg(FYI, \"Unregistered %s key type\\n\", cifs_idmap_key_type.name);\n}", "target": 0}
{"code": "static size_t exif_convert_any_to_int(void *value, int format, int motorola_intel)\n{\n\tint \t\ts_den;\n\tunsigned \tu_den;\n\tswitch(format) {\n\t\tcase TAG_FMT_SBYTE:     return *(signed char *)value;\n\t\tcase TAG_FMT_BYTE:      return *(uchar *)value;\n\t\tcase TAG_FMT_USHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_ULONG:     return php_ifd_get32u(value, motorola_intel);\n\t\tcase TAG_FMT_URATIONAL:\n\t\t\tu_den = php_ifd_get32u(4+(char *)value, motorola_intel);\n\t\t\tif (u_den == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn php_ifd_get32u(value, motorola_intel) / u_den;\n\t\t\t}\n\t\tcase TAG_FMT_SRATIONAL:\n\t\t\ts_den = php_ifd_get32s(4+(char *)value, motorola_intel);\n\t\t\tif (s_den == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn (size_t)((double)php_ifd_get32s(value, motorola_intel) / s_den);\n\t\t\t}\n\t\tcase TAG_FMT_SSHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_SLONG:     return php_ifd_get32s(value, motorola_intel);\n\t\tcase TAG_FMT_SINGLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL, E_NOTICE, \"Found value of type single\");\n#endif\n\t\t\treturn (size_t)*(float *)value;\n\t\tcase TAG_FMT_DOUBLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL, E_NOTICE, \"Found value of type double\");\n#endif\n\t\t\treturn (size_t)*(double *)value;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "convert_protocol_address(struct sockaddr* saddr, unsigned int saddrlen)\n{\n    PyObject *res_obj = NULL;\n    switch (saddr->sa_family)\n    {\n    case AF_INET:\n        {\n            struct sockaddr_in* sin = (struct sockaddr_in*)saddr;\n            char *addr_str = (char *)PyMem_Malloc(INET_ADDRSTRLEN);\n            if (addr_str == NULL) {\n                PyErr_SetString(ErrorObject, \"Out of memory\");\n                goto error;\n            }\n            if (inet_ntop(saddr->sa_family, &sin->sin_addr, addr_str, INET_ADDRSTRLEN) == NULL) {\n                PyErr_SetFromErrno(ErrorObject);\n                PyMem_Free(addr_str);\n                goto error;\n            }\n            res_obj = Py_BuildValue(\"(si)\", addr_str, ntohs(sin->sin_port));\n            PyMem_Free(addr_str);\n       }\n        break;\n    case AF_INET6:\n        {\n            struct sockaddr_in6* sin6 = (struct sockaddr_in6*)saddr;\n            char *addr_str = (char *)PyMem_Malloc(INET6_ADDRSTRLEN);\n            if (addr_str == NULL) {\n                PyErr_SetString(ErrorObject, \"Out of memory\");\n                goto error;\n            }\n            if (inet_ntop(saddr->sa_family, &sin6->sin6_addr, addr_str, INET6_ADDRSTRLEN) == NULL) {\n                PyErr_SetFromErrno(ErrorObject);\n                PyMem_Free(addr_str);\n                goto error;\n            }\n            res_obj = Py_BuildValue(\"(si)\", addr_str, ntohs(sin6->sin6_port));\n            PyMem_Free(addr_str);\n        }\n        break;\n    default:\n        PyErr_SetString(ErrorObject, \"Unsupported address family.\");\n    }\nerror:\n    return res_obj;\n}", "target": 0}
{"code": "static inline void skb_set_network_header(struct sk_buff *skb, const int offset)\n{\n\tskb->network_header = skb->data + offset;\n}", "target": 0}
{"code": "static inline int ccid_hc_tx_getsockopt(struct ccid *ccid, struct sock *sk,\n\t\t\t\t\tconst int optname, int len,\n\t\t\t\t\tu32 __user *optval, int __user *optlen)\n{\n\tint rc = -ENOPROTOOPT;\n\tif (ccid->ccid_ops->ccid_hc_tx_getsockopt != NULL)\n\t\trc = ccid->ccid_ops->ccid_hc_tx_getsockopt(sk, optname, len,\n\t\t\t\t\t\t optval, optlen);\n\treturn rc;\n}", "target": 1}
{"code": "static int udp_push_pending_frames(struct sock *sk)\n{\n\tstruct udp_sock  *up = udp_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct flowi4 *fl4 = &inet->cork.fl.u.ip4;\n\tstruct sk_buff *skb;\n\tint err = 0;\n\tskb = ip_finish_skb(sk, fl4);\n\tif (!skb)\n\t\tgoto out;\n\terr = udp_send_skb(skb, fl4);\nout:\n\tup->len = 0;\n\tup->pending = 0;\n\treturn err;\n}", "target": 1}
{"code": "static void ext4_end_io_work(struct work_struct *work)\n{\n\text4_io_end_t *io  = container_of(work, ext4_io_end_t, work);\n\tstruct inode *inode = io->inode;\n\tint ret = 0;\n\tmutex_lock(&inode->i_mutex);\n\tret = ext4_end_io_nolock(io);\n\tif (ret >= 0) {\n\t\tif (!list_empty(&io->list))\n\t\t\tlist_del_init(&io->list);\n\t\text4_free_io_end(io);\n\t}\n\tmutex_unlock(&inode->i_mutex);\n}", "target": 1}
{"code": "int bnx2x_set_int_mode(struct bnx2x *bp)\n{\n\tint rc = 0;\n\tif (IS_VF(bp) && int_mode != BNX2X_INT_MODE_MSIX) {\n\t\tBNX2X_ERR(\"VF not loaded since interrupt mode not msix\\n\");\n\t\treturn -EINVAL;\n\t}\n\tswitch (int_mode) {\n\tcase BNX2X_INT_MODE_MSIX:\n\t\trc = bnx2x_enable_msix(bp);\n\t\tif (!rc)\n\t\t\treturn 0;\n\t\tif (rc && IS_VF(bp))\n\t\t\treturn rc;\n\t\tBNX2X_DEV_INFO(\"Failed to enable multiple MSI-X (%d), set number of queues to %d\\n\",\n\t\t\t       bp->num_queues,\n\t\t\t       1 + bp->num_cnic_queues);\n\tcase BNX2X_INT_MODE_MSI:\n\t\tbnx2x_enable_msi(bp);\n\tcase BNX2X_INT_MODE_INTX:\n\t\tbp->num_ethernet_queues = 1;\n\t\tbp->num_queues = bp->num_ethernet_queues + bp->num_cnic_queues;\n\t\tBNX2X_DEV_INFO(\"set number of queues to 1\\n\");\n\t\tbreak;\n\tdefault:\n\t\tBNX2X_DEV_INFO(\"unknown value in int_mode module parameter\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static void free_nested(struct vcpu_vmx *vmx)\n{\n\tif (!vmx->nested.vmxon)\n\t\treturn;\n\tvmx->nested.vmxon = false;\n\tfree_vpid(vmx->nested.vpid02);\n\tnested_release_vmcs12(vmx);\n\tif (enable_shadow_vmcs)\n\t\tfree_vmcs(vmx->nested.current_shadow_vmcs);\n\tif (vmx->nested.apic_access_page) {\n\t\tnested_release_page(vmx->nested.apic_access_page);\n\t\tvmx->nested.apic_access_page = NULL;\n\t}\n\tif (vmx->nested.virtual_apic_page) {\n\t\tnested_release_page(vmx->nested.virtual_apic_page);\n\t\tvmx->nested.virtual_apic_page = NULL;\n\t}\n\tif (vmx->nested.pi_desc_page) {\n\t\tkunmap(vmx->nested.pi_desc_page);\n\t\tnested_release_page(vmx->nested.pi_desc_page);\n\t\tvmx->nested.pi_desc_page = NULL;\n\t\tvmx->nested.pi_desc = NULL;\n\t}\n\tnested_free_all_saved_vmcss(vmx);\n}", "target": 0}
{"code": "static void *proc_pid_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error = -EACCES;\n\tpath_put(&nd->path);\n\tif (!proc_fd_access_allowed(inode))\n\t\tgoto out;\n\terror = PROC_I(inode)->op.proc_get_link(inode, &nd->path);\n\tnd->last_type = LAST_BIND;\nout:\n\treturn ERR_PTR(error);\n}", "target": 1}
{"code": "int btrfs_get_dev_stats(struct btrfs_fs_info *fs_info,\n\t\t\tstruct btrfs_ioctl_get_dev_stats *stats)\n{\n\tstruct btrfs_device *dev;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tint i;\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(fs_info->fs_devices, stats->devid, NULL, NULL);\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\tif (!dev) {\n\t\tbtrfs_warn(fs_info, \"get dev_stats failed, device not found\");\n\t\treturn -ENODEV;\n\t} else if (!dev->dev_stats_valid) {\n\t\tbtrfs_warn(fs_info, \"get dev_stats failed, not yet valid\");\n\t\treturn -ENODEV;\n\t} else if (stats->flags & BTRFS_DEV_STATS_RESET) {\n\t\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++) {\n\t\t\tif (stats->nr_items > i)\n\t\t\t\tstats->values[i] =\n\t\t\t\t\tbtrfs_dev_stat_read_and_reset(dev, i);\n\t\t\telse\n\t\t\t\tbtrfs_dev_stat_reset(dev, i);\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++)\n\t\t\tif (stats->nr_items > i)\n\t\t\t\tstats->values[i] = btrfs_dev_stat_read(dev, i);\n\t}\n\tif (stats->nr_items > BTRFS_DEV_STAT_VALUES_MAX)\n\t\tstats->nr_items = BTRFS_DEV_STAT_VALUES_MAX;\n\treturn 0;\n}", "target": 1}
{"code": "static void nfs4_return_incompatible_delegation(struct inode *inode, mode_t open_flags)\n{\n\tstruct nfs_delegation *delegation;\n\trcu_read_lock();\n\tdelegation = rcu_dereference(NFS_I(inode)->delegation);\n\tif (delegation == NULL || (delegation->type & open_flags) == open_flags) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\trcu_read_unlock();\n\tnfs_inode_return_delegation(inode);\n}", "target": 1}
{"code": "void set_task_comm(struct task_struct *tsk, char *buf)\n{\n\ttask_lock(tsk);\n\tstrlcpy(tsk->comm, buf, sizeof(tsk->comm));\n\ttask_unlock(tsk);\n}", "target": 0}
{"code": "Pl_Count::write(unsigned char* buf, size_t len)\n{\n    if (len)\n    {\n\tthis->m->count += QIntC::to_offset(len);\n\tgetNext()->write(buf, len);\n\tthis->m->last_char = buf[len - 1];\n    }\n}", "target": 1}
{"code": "static struct socket *get_raw_socket(int fd)\n{\n\tstruct {\n\t\tstruct sockaddr_ll sa;\n\t\tchar  buf[MAX_ADDR_LEN];\n\t} uaddr;\n\tint r;\n\tstruct socket *sock = sockfd_lookup(fd, &r);\n\tif (!sock)\n\t\treturn ERR_PTR(-ENOTSOCK);\n\tif (sock->sk->sk_type != SOCK_RAW) {\n\t\tr = -ESOCKTNOSUPPORT;\n\t\tgoto err;\n\t}\n\tr = sock->ops->getname(sock, (struct sockaddr *)&uaddr.sa, 0);\n\tif (r < 0)\n\t\tgoto err;\n\tif (uaddr.sa.sll_family != AF_PACKET) {\n\t\tr = -EPFNOSUPPORT;\n\t\tgoto err;\n\t}\n\treturn sock;\nerr:\n\tsockfd_put(sock);\n\treturn ERR_PTR(r);\n}", "target": 1}
{"code": "static void vhost_vdpa_config_put(struct vhost_vdpa *v)\n{\n\tif (v->config_ctx)\n\t\teventfd_ctx_put(v->config_ctx);\n}", "target": 1}
{"code": "int vp9_alloc_context_buffers(VP9_COMMON *cm, int width, int height) {\n  int new_mi_size;\n  vp9_set_mb_mi(cm, width, height);\n  new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);\n  if (cm->mi_alloc_size < new_mi_size) {\n    cm->free_mi(cm);\n    if (cm->alloc_mi(cm, new_mi_size)) goto fail;\n  }\n  if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {\n    free_seg_map(cm);\n    if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols)) goto fail;\n  }\n  if (cm->above_context_alloc_cols < cm->mi_cols) {\n    vpx_free(cm->above_context);\n    cm->above_context = (ENTROPY_CONTEXT *)vpx_calloc(\n        2 * mi_cols_aligned_to_sb(cm->mi_cols) * MAX_MB_PLANE,\n        sizeof(*cm->above_context));\n    if (!cm->above_context) goto fail;\n    vpx_free(cm->above_seg_context);\n    cm->above_seg_context = (PARTITION_CONTEXT *)vpx_calloc(\n        mi_cols_aligned_to_sb(cm->mi_cols), sizeof(*cm->above_seg_context));\n    if (!cm->above_seg_context) goto fail;\n    cm->above_context_alloc_cols = cm->mi_cols;\n  }\n  if (vp9_alloc_loop_filter(cm)) goto fail;\n  return 0;\nfail:\n  vp9_set_mb_mi(cm, 0, 0);\n  vp9_free_context_buffers(cm);\n  return 1;\n}", "target": 1}
{"code": "validate_event(struct pmu_hw_events *hw_events,\n\t       struct perf_event *event)\n{\n\tstruct arm_pmu *armpmu = to_arm_pmu(event->pmu);\n\tstruct hw_perf_event fake_event = event->hw;\n\tstruct pmu *leader_pmu = event->group_leader->pmu;\n\tif (is_software_event(event))\n\t\treturn 1;\n\tif (event->pmu != leader_pmu || event->state < PERF_EVENT_STATE_OFF)\n\t\treturn 1;\n\tif (event->state == PERF_EVENT_STATE_OFF && !event->attr.enable_on_exec)\n\t\treturn 1;\n\treturn armpmu->get_event_idx(hw_events, &fake_event) >= 0;\n}", "target": 1}
{"code": "static void cleanup_async_copy(struct nfsd4_copy *copy)\n{\n\tnfs4_free_cp_state(copy);\n\tfput(copy->file_dst);\n\tfput(copy->file_src);\n\tspin_lock(&copy->cp_clp->async_lock);\n\tlist_del(&copy->copies);\n\tspin_unlock(&copy->cp_clp->async_lock);\n\tnfs4_put_copy(copy);\n}", "target": 0}
{"code": "void ZlibInStream::deinit()\n{\n  assert(zs != NULL);\n  removeUnderlying();\n  inflateEnd(zs);\n  delete zs;\n  zs = NULL;\n}", "target": 1}
{"code": "static bool msr_mtrr_valid(unsigned msr)\n{\n\tswitch (msr) {\n\tcase 0x200 ... 0x200 + 2 * KVM_NR_VAR_MTRR - 1:\n\tcase MSR_MTRRfix64K_00000:\n\tcase MSR_MTRRfix16K_80000:\n\tcase MSR_MTRRfix16K_A0000:\n\tcase MSR_MTRRfix4K_C0000:\n\tcase MSR_MTRRfix4K_C8000:\n\tcase MSR_MTRRfix4K_D0000:\n\tcase MSR_MTRRfix4K_D8000:\n\tcase MSR_MTRRfix4K_E0000:\n\tcase MSR_MTRRfix4K_E8000:\n\tcase MSR_MTRRfix4K_F0000:\n\tcase MSR_MTRRfix4K_F8000:\n\tcase MSR_MTRRdefType:\n\tcase MSR_IA32_CR_PAT:\n\t\treturn true;\n\tcase 0x2f8:\n\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "my_pipe_sig_handler(int sig __attribute__((unused)))\n{\n  DBUG_PRINT(\"info\",(\"Hit by signal %d\",sig));\n#ifdef SIGNAL_HANDLER_RESET_ON_DELIVERY\n  (void) signal(SIGPIPE, my_pipe_sig_handler);\n#endif\n}", "target": 0}
{"code": "lys_restr_dup(struct lys_module *mod, struct lys_restr *old, int size, int shallow, struct unres_schema *unres)\n{\n    struct lys_restr *result;\n    int i;\n    if (!size) {\n        return NULL;\n    }\n    result = calloc(size, sizeof *result);\n    LY_CHECK_ERR_RETURN(!result, LOGMEM(mod->ctx), NULL);\n    for (i = 0; i < size; i++) {\n        result[i].ext_size = old[i].ext_size;\n        lys_ext_dup(mod->ctx, mod, old[i].ext, old[i].ext_size, &result[i], LYEXT_PAR_RESTR, &result[i].ext, shallow, unres);\n        result[i].expr = lydict_insert(mod->ctx, old[i].expr, 0);\n        result[i].dsc = lydict_insert(mod->ctx, old[i].dsc, 0);\n        result[i].ref = lydict_insert(mod->ctx, old[i].ref, 0);\n        result[i].eapptag = lydict_insert(mod->ctx, old[i].eapptag, 0);\n        result[i].emsg = lydict_insert(mod->ctx, old[i].emsg, 0);\n    }\n    return result;\n}", "target": 1}
{"code": "process_mic(OM_uint32 *minor_status, gss_buffer_t mic_in,\n\t    spnego_gss_ctx_id_t sc, gss_buffer_t *mic_out,\n\t    OM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 ret, tmpmin;\n\tgss_qop_t qop_state;\n\tgss_buffer_desc tmpmic = GSS_C_EMPTY_BUFFER;\n\tret = GSS_S_FAILURE;\n\tif (mic_in != GSS_C_NO_BUFFER) {\n\t\tret = gss_verify_mic(minor_status, sc->ctx_handle,\n\t\t\t\t     &sc->DER_mechTypes,\n\t\t\t\t     mic_in, &qop_state);\n\t\tif (ret != GSS_S_COMPLETE) {\n\t\t\t*negState = REJECT;\n\t\t\t*tokflag = ERROR_TOKEN_SEND;\n\t\t\treturn ret;\n\t\t}\n\t\tsc->mic_reqd = 1;\n\t\tsc->mic_rcvd = 1;\n\t}\n\tif (sc->mic_reqd && !sc->mic_sent) {\n\t\tret = gss_get_mic(minor_status, sc->ctx_handle,\n\t\t\t\t  GSS_C_QOP_DEFAULT,\n\t\t\t\t  &sc->DER_mechTypes,\n\t\t\t\t  &tmpmic);\n\t\tif (ret != GSS_S_COMPLETE) {\n\t\t\tgss_release_buffer(&tmpmin, &tmpmic);\n\t\t\t*tokflag = NO_TOKEN_SEND;\n\t\t\treturn ret;\n\t\t}\n\t\t*mic_out = malloc(sizeof(gss_buffer_desc));\n\t\tif (*mic_out == GSS_C_NO_BUFFER) {\n\t\t\tgss_release_buffer(&tmpmin, &tmpmic);\n\t\t\t*tokflag = NO_TOKEN_SEND;\n\t\t\treturn GSS_S_FAILURE;\n\t\t}\n\t\t**mic_out = tmpmic;\n\t\tsc->mic_sent = 1;\n\t}\n\treturn GSS_S_COMPLETE;\n}", "target": 0}
{"code": "fbCombineAtopC (CARD32 *dest, CARD32 *src, CARD32 *mask, int width)\n{\n    int i;\n    for (i = 0; i < width; ++i) {\n        CARD32 d = READ(dest + i);\n        CARD32 s = READ(src + i);\n        CARD32 m = READ(mask + i);\n        CARD32 ad;\n        CARD16 as = d >> 24;\n\tfbCombineMaskC (&s, &m);\n        ad = ~m;\n        FbByteAddMulC(d, ad, s, as);\n        WRITE(dest + i, d);\n    }\n}", "target": 0}
{"code": "static void disk_del_events(struct gendisk *disk)\n{\n\tif (!disk->ev)\n\t\treturn;\n\tdisk_block_events(disk);\n\tmutex_lock(&disk_events_mutex);\n\tlist_del_init(&disk->ev->node);\n\tmutex_unlock(&disk_events_mutex);\n\tsysfs_remove_files(&disk_to_dev(disk)->kobj, disk_events_attrs);\n}", "target": 0}
{"code": "    FailedProvisionalLoadInfo()\n    : error(net::OK) {}", "target": 0}
{"code": "static void freeary(struct ipc_namespace *ns, struct kern_ipc_perm *ipcp)\n{\n\tstruct sem_undo *un, *tu;\n\tstruct sem_queue *q, *tq;\n\tstruct sem_array *sma = container_of(ipcp, struct sem_array, sem_perm);\n\tstruct list_head tasks;\n\tint i;\n\tassert_spin_locked(&sma->sem_perm.lock);\n\tlist_for_each_entry_safe(un, tu, &sma->list_id, list_id) {\n\t\tlist_del(&un->list_id);\n\t\tspin_lock(&un->ulp->lock);\n\t\tun->semid = -1;\n\t\tlist_del_rcu(&un->list_proc);\n\t\tspin_unlock(&un->ulp->lock);\n\t\tkfree_rcu(un, rcu);\n\t}\n\tINIT_LIST_HEAD(&tasks);\n\tlist_for_each_entry_safe(q, tq, &sma->sem_pending, list) {\n\t\tunlink_queue(sma, q);\n\t\twake_up_sem_queue_prepare(&tasks, q, -EIDRM);\n\t}\n\tfor (i = 0; i < sma->sem_nsems; i++) {\n\t\tstruct sem *sem = sma->sem_base + i;\n\t\tlist_for_each_entry_safe(q, tq, &sem->sem_pending, list) {\n\t\t\tunlink_queue(sma, q);\n\t\t\twake_up_sem_queue_prepare(&tasks, q, -EIDRM);\n\t\t}\n\t}\n\tsem_rmid(ns, sma);\n\tsem_unlock(sma);\n\twake_up_sem_queue_do(&tasks);\n\tns->used_sems -= sma->sem_nsems;\n\tsecurity_sem_free(sma);\n\tipc_rcu_putref(sma);\n}", "target": 1}
{"code": "date_s__iso8601(int argc, VALUE *argv, VALUE klass)\n{\n    VALUE str, opt;\n    rb_scan_args(argc, argv, \"1:\", &str, &opt);\n    check_limit(str, opt);\n    return date__iso8601(str);\n}", "target": 0}
{"code": "void __init shm_init(void)\n{\n\tipc_init_proc_interface(\"sysvipc/shm\",\n#if BITS_PER_LONG <= 32\n\t\t\t\t\"       key      shmid perms       size  cpid  lpid nattch   uid   gid  cuid  cgid      atime      dtime      ctime        rss       swap\\n\",\n#else\n\t\t\t\t\"       key      shmid perms                  size  cpid  lpid nattch   uid   gid  cuid  cgid      atime      dtime      ctime                   rss                  swap\\n\",\n#endif\n\t\t\t\tIPC_SHM_IDS, sysvipc_shm_proc_show);\n}", "target": 0}
{"code": "njs_vmcode_typeof(njs_vm_t *vm, njs_value_t *value, njs_value_t *invld)\n{\n    static const njs_value_t  *types[NJS_VALUE_TYPE_MAX] = {\n        &njs_string_object,\n        &njs_string_undefined,\n        &njs_string_boolean,\n        &njs_string_number,\n        &njs_string_symbol,\n        &njs_string_string,\n        &njs_string_data,\n        &njs_string_external,\n        &njs_string_invalid,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_function,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n    };\n    vm->retval = *types[value->type];\n    return sizeof(njs_vmcode_2addr_t);\n}", "target": 1}
{"code": "TEST(MultiplyAndCheckOverflow, Validate) {\n  size_t res = 0;\n  EXPECT_TRUE(MultiplyAndCheckOverflow(1, 2, &res) == kTfLiteOk);\n  EXPECT_FALSE(MultiplyAndCheckOverflow(static_cast<size_t>(123456789023),\n                                        1223423425, &res) == kTfLiteOk);\n}", "target": 0}
{"code": "void DelegatedFrameHost::ResetCompositorFrameSinkSupport() {\n  if (!support_)\n    return;\n  if (compositor_)\n    compositor_->RemoveFrameSink(frame_sink_id_);\n  support_.reset();\n}", "target": 0}
{"code": "static inline int nla_put_u32(struct sk_buff *skb, int attrtype, u32 value)\n{\n\treturn nla_put(skb, attrtype, sizeof(u32), &value);\n}", "target": 0}
{"code": "static bool is_maintenance_mode_cmd(struct kernel_ipmi_msg *msg)\n{\n\treturn (((msg->netfn == IPMI_NETFN_APP_REQUEST)\n\t\t && ((msg->cmd == IPMI_COLD_RESET_CMD)\n\t\t     || (msg->cmd == IPMI_WARM_RESET_CMD)))\n\t\t|| (msg->netfn == IPMI_NETFN_FIRMWARE_REQUEST));\n}", "target": 0}
{"code": "static int decode_trns_chunk(AVCodecContext *avctx, PNGDecContext *s,\n                             uint32_t length)\n{\n    int v, i;\n    if (s->color_type == PNG_COLOR_TYPE_PALETTE) {\n        if (length > 256 || !(s->state & PNG_PLTE))\n            return AVERROR_INVALIDDATA;\n        for (i = 0; i < length; i++) {\n            v = bytestream2_get_byte(&s->gb);\n            s->palette[i] = (s->palette[i] & 0x00ffffff) | (v << 24);\n        }\n    } else if (s->color_type == PNG_COLOR_TYPE_GRAY || s->color_type == PNG_COLOR_TYPE_RGB) {\n        if ((s->color_type == PNG_COLOR_TYPE_GRAY && length != 2) ||\n            (s->color_type == PNG_COLOR_TYPE_RGB && length != 6))\n            return AVERROR_INVALIDDATA;\n        for (i = 0; i < length / 2; i++) {\n            v = av_mod_uintp2(bytestream2_get_be16(&s->gb), s->bit_depth);\n            if (s->bit_depth > 8)\n                AV_WB16(&s->transparent_color_be[2 * i], v);\n            else\n                s->transparent_color_be[i] = v;\n        }\n    } else {\n        return AVERROR_INVALIDDATA;\n    }\n    bytestream2_skip(&s->gb, 4); \n    s->has_trns = 1;\n    return 0;\n}", "target": 1}
{"code": "static unsigned int tun_chr_poll(struct file *file, poll_table * wait)\n{\n\tstruct tun_file *tfile = file->private_data;\n\tstruct tun_struct *tun = __tun_get(tfile);\n\tstruct sock *sk = tun->sk;\n\tunsigned int mask = 0;\n\tif (!tun)\n\t\treturn POLLERR;\n\tDBG(KERN_INFO \"%s: tun_chr_poll\\n\", tun->dev->name);\n\tpoll_wait(file, &tun->socket.wait, wait);\n\tif (!skb_queue_empty(&tun->readq))\n\t\tmask |= POLLIN | POLLRDNORM;\n\tif (sock_writeable(sk) ||\n\t    (!test_and_set_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags) &&\n\t     sock_writeable(sk)))\n\t\tmask |= POLLOUT | POLLWRNORM;\n\tif (tun->dev->reg_state != NETREG_REGISTERED)\n\t\tmask = POLLERR;\n\ttun_put(tun);\n\treturn mask;\n}", "target": 1}
{"code": "static void read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)\n{\n    int i, j, v;\n    if (get_bits1(gb)) {\n        for (i = 0; i < 64; i++) {\n            v = get_bits(gb, 8);\n            j = s->idsp.idct_permutation[ff_zigzag_direct[i]];\n            s->intra_matrix[j]        = v;\n            s->chroma_intra_matrix[j] = v;\n        }\n    }\n    if (get_bits1(gb)) {\n        for (i = 0; i < 64; i++) {\n            get_bits(gb, 8);\n        }\n    }\n    if (get_bits1(gb)) {\n        for (i = 0; i < 64; i++) {\n            v = get_bits(gb, 8);\n            j = s->idsp.idct_permutation[ff_zigzag_direct[i]];\n            s->chroma_intra_matrix[j] = v;\n        }\n    }\n    if (get_bits1(gb)) {\n        for (i = 0; i < 64; i++) {\n            get_bits(gb, 8);\n        }\n    }\n    next_start_code_studio(gb);\n}", "target": 1}
{"code": "ffi_prep_closure_loc (ffi_closure *closure,\n                      ffi_cif* cif,\n                      void (*fun)(ffi_cif*,void*,void**,void*),\n                      void *user_data,\n                      void *codeloc)\n{\n  if (cif->abi != FFI_SYSV)\n    return FFI_BAD_ABI;\n  void (*start)(void);\n  if (cif->flags & AARCH64_FLAG_ARG_V)\n    start = ffi_closure_SYSV_V;\n  else\n    start = ffi_closure_SYSV;\n#if FFI_EXEC_TRAMPOLINE_TABLE\n#ifdef __MACH__\n  void **config = (void **)((uint8_t *)codeloc - PAGE_MAX_SIZE);\n  config[0] = closure;\n  config[1] = start;\n#endif\n#else\n  static const unsigned char trampoline[16] = {\n    0x90, 0x00, 0x00, 0x58,\t\n    0xf1, 0xff, 0xff, 0x10,\t\n    0x00, 0x02, 0x1f, 0xd6\t\n  };\n  char *tramp = closure->tramp;\n  memcpy (tramp, trampoline, sizeof(trampoline));\n  *(UINT64 *)(tramp + 16) = (uintptr_t)start;\n  ffi_clear_cache(tramp, tramp + FFI_TRAMPOLINE_SIZE);\n#endif\n  closure->cif = cif;\n  closure->fun = fun;\n  closure->user_data = user_data;\n  return FFI_OK;\n}", "target": 1}
{"code": "static inline int rtnetlink_fill_iwinfo(struct sk_buff *\tskb,\n\t\t\t\t\tstruct net_device *\tdev,\n\t\t\t\t\tint\t\t\ttype,\n\t\t\t\t\tchar *\t\t\tevent,\n\t\t\t\t\tint\t\t\tevent_len)\n{\n\tstruct ifinfomsg *r;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char\t *b = skb->tail;\n\tnlh = NLMSG_PUT(skb, 0, 0, type, sizeof(*r));\n\tr = NLMSG_DATA(nlh);\n\tr->ifi_family = AF_UNSPEC;\n\tr->ifi_type = dev->type;\n\tr->ifi_index = dev->ifindex;\n\tr->ifi_flags = dev->flags;\n\tr->ifi_change = 0;\t\n\tRTA_PUT(skb, IFLA_WIRELESS,\n\t\tevent_len, event);\n\tnlh->nlmsg_len = skb->tail - b;\n\treturn skb->len;\nnlmsg_failure:\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}", "target": 1}
{"code": "static void sunkbd_reinit(struct work_struct *work)\n{\n\tstruct sunkbd *sunkbd = container_of(work, struct sunkbd, tq);\n\twait_event_interruptible_timeout(sunkbd->wait, sunkbd->reset >= 0, HZ);\n\tserio_write(sunkbd->serio, SUNKBD_CMD_SETLED);\n\tserio_write(sunkbd->serio,\n\t\t(!!test_bit(LED_CAPSL,   sunkbd->dev->led) << 3) |\n\t\t(!!test_bit(LED_SCROLLL, sunkbd->dev->led) << 2) |\n\t\t(!!test_bit(LED_COMPOSE, sunkbd->dev->led) << 1) |\n\t\t !!test_bit(LED_NUML,    sunkbd->dev->led));\n\tserio_write(sunkbd->serio,\n\t\tSUNKBD_CMD_NOCLICK - !!test_bit(SND_CLICK, sunkbd->dev->snd));\n\tserio_write(sunkbd->serio,\n\t\tSUNKBD_CMD_BELLOFF - !!test_bit(SND_BELL, sunkbd->dev->snd));\n}", "target": 1}
{"code": "PHP_FUNCTION(xml_parse_into_struct)\n{\n\txml_parser *parser;\n\tzval *pind, **xdata, **info = NULL;\n\tchar *data;\n\tint data_len, ret;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rsZ|Z\", &pind, &data, &data_len, &xdata, &info) == FAILURE) {\n\t\treturn;\n\t}\n\tif (info) {\n\t\tzval_dtor(*info);\n\t\tarray_init(*info);\n\t}\n\tZEND_FETCH_RESOURCE(parser,xml_parser *, &pind, -1, \"XML Parser\", le_xml_parser);\n\tzval_dtor(*xdata);\n\tarray_init(*xdata);\n\tparser->data = *xdata;\n\tif (info) {\n\t\tparser->info = *info;\n\t}\n\tparser->level = 0;\n\tparser->ltags = safe_emalloc(XML_MAXLEVEL, sizeof(char *), 0);\n\tXML_SetDefaultHandler(parser->parser, _xml_defaultHandler);\n\tXML_SetElementHandler(parser->parser, _xml_startElementHandler, _xml_endElementHandler);\n\tXML_SetCharacterDataHandler(parser->parser, _xml_characterDataHandler);\n\tparser->isparsing = 1;\n\tret = XML_Parse(parser->parser, data, data_len, 1);\n\tparser->isparsing = 0;\n\tRETVAL_LONG(ret);\n}", "target": 0}
{"code": "static void xcopy_pt_undepend_remotedev(struct xcopy_op *xop)\n{\n\tstruct se_device *remote_dev;\n\tif (xop->op_origin == XCOL_SOURCE_RECV_OP)\n\t\tremote_dev = xop->dst_dev;\n\telse\n\t\tremote_dev = xop->src_dev;\n\tpr_debug(\"Calling configfs_undepend_item for\"\n\t\t  \" remote_dev: %p remote_dev->dev_group: %p\\n\",\n\t\t  remote_dev, &remote_dev->dev_group.cg_item);\n\ttarget_undepend_item(&remote_dev->dev_group.cg_item);\n}", "target": 1}
{"code": "        int    ReadDoubleArray(unsigned char *sString, int nLen, double (&pArray)[nMax])\n        {\n            int nStart = 0;\n            while( sString[nStart] != '[' )\n            {\n                nStart++;\n                if ( nStart >= nLen )\n                    return 0;\n            }\n            int nEnd = ++nStart;\n            while ( sString[nEnd] != ']' )\n            {\n                nEnd++;\n                if ( nEnd >= nLen )\n                    return 0;\n            }\n            sString = sString + nStart;\n            nLen    = nEnd - nStart;\n            int nCount = 0;\n            const int c_nNumLimit = 32;\n            unsigned char sBuffer[c_nNumLimit];\n            int nBufPos = 0;\n            bool bNewItem = true;\n            for ( int nIndex = 0; nIndex < nLen; ++nIndex )\n            {\n                unsigned char unChar = sString[nIndex];\n                if ( ' ' == unChar )\n                {\n                    if ( !bNewItem )\n                        bNewItem = true;\n                    continue;\n                }\n                if ( bNewItem )\n                {\n                    if ( nCount >= nMax )\n                        break;\n                    if ( nCount > 0 )\n                        pArray[nCount - 1] = Utils::GetDouble( (const char *)sBuffer );\n                    memset( sBuffer, 0x00, c_nNumLimit );\n                    nBufPos = 0;\n                    bNewItem = false;\n                    nCount++;\n                }\n                sBuffer[nBufPos++] = unChar;\n                if (nBufPos >= c_nNumLimit)\n                    break;\n            }\n            if ( 0 != sBuffer[0] && nCount > 0 )\n                pArray[nCount - 1] = Utils::GetDouble( (const char *)sBuffer );\n            return nCount;\n        }", "target": 0}
{"code": "static int changedline (const Proto *p, int oldpc, int newpc) {\n  while (oldpc++ < newpc) {\n    if (p->lineinfo[oldpc] != 0)\n      return (luaG_getfuncline(p, oldpc - 1) != luaG_getfuncline(p, newpc));\n  }\n  return 0;  \n}", "target": 1}
{"code": "void Context::onDone() {\n  if (wasm_->onDone_) {\n    wasm_->onDone_(this, id_);\n  }\n}", "target": 1}
{"code": "case_map(OnigCaseFoldType* flagP, const OnigUChar** pp,\n\t const OnigUChar* end, OnigUChar* to, OnigUChar* to_end,\n\t const struct OnigEncodingTypeST* enc)\n{\n  OnigCodePoint code;\n  OnigUChar *to_start = to;\n  OnigCaseFoldType flags = *flagP;\n  while (*pp < end && to < to_end) {\n    code = *(*pp)++;\n    if (code == SHARP_s) {\n      if (flags & ONIGENC_CASE_UPCASE) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\t*to++ = 'S';\n\tcode = (flags & ONIGENC_CASE_TITLECASE) ? 's' : 'S';\n      }\n      else if (flags & ONIGENC_CASE_FOLD) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\t*to++ = 's';\n\tcode = 's';\n      }\n    }\n    else if (code == 0xB5)\n      ;\n    else if ((EncCP1252_CtypeTable[code] & BIT_CTYPE_UPPER)\n\t     && (flags & (ONIGENC_CASE_DOWNCASE | ONIGENC_CASE_FOLD))) {\n      flags |= ONIGENC_CASE_MODIFIED;\n      if (code == 'I')\n\tcode = flags & ONIGENC_CASE_FOLD_TURKISH_AZERI ? DOTLESS_i : 'i';\n      else\n\tcode = ENC_CP1252_TO_LOWER_CASE(code);\n    }\n    else if ((EncCP1252_CtypeTable[code]&BIT_CTYPE_LOWER)\n\t     && (flags & ONIGENC_CASE_UPCASE)) {\n      flags |= ONIGENC_CASE_MODIFIED;\n      if (code == 'i')\n\tcode = flags & ONIGENC_CASE_FOLD_TURKISH_AZERI ? I_WITH_DOT_ABOVE : 'I';\n      else if (code == DOTLESS_i)\n\tcode = 'I';\n      else if (code >= 0xB0 && code <= 0xBF)\n\tcode -= 0x10;\n      else\n\tcode -= 0x20;\n    }\n    *to++ = code;\n    if (flags & ONIGENC_CASE_TITLECASE)  \n      flags ^= (ONIGENC_CASE_UPCASE | ONIGENC_CASE_DOWNCASE | ONIGENC_CASE_TITLECASE);\n  }\n  *flagP = flags;\n  return (int )(to - to_start);\n}", "target": 0}
{"code": "void shm_exit_ns(struct ipc_namespace *ns)\n{\n\tfree_ipcs(ns, &shm_ids(ns), do_shm_rmid);\n\tidr_destroy(&ns->ids[IPC_SHM_IDS].ipcs_idr);\n}", "target": 0}
{"code": "void ntlm_print_negotiate_flags(UINT32 flags)\n{\n\tint i;\n\tconst char* str;\n\tWLog_INFO(TAG, \"negotiateFlags \\\"0x%08\"PRIX32\"\\\"\", flags);\n\tfor (i = 31; i >= 0; i--)\n\t{\n\t\tif ((flags >> i) & 1)\n\t\t{\n\t\t\tstr = NTLM_NEGOTIATE_STRINGS[(31 - i)];\n\t\t\tWLog_INFO(TAG, \"\\t%s (%d),\", str, (31 - i));\n\t\t}\n\t}\n}", "target": 1}
{"code": "static unsigned int count_acl_entries(connection_struct *conn, SMB_ACL_T posix_acl)\n{\n\tunsigned int ace_count = 0;\n\tint entry_id = SMB_ACL_FIRST_ENTRY;\n\tSMB_ACL_ENTRY_T entry;\n\twhile ( posix_acl && (sys_acl_get_entry(posix_acl, entry_id, &entry) == 1)) {\n\t\tif (entry_id == SMB_ACL_FIRST_ENTRY) {\n\t\t\tentry_id = SMB_ACL_NEXT_ENTRY;\n\t\t}\n\t\tace_count++;\n\t}\n\treturn ace_count;\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, BasicSkipNoIndex) {\n    addIndex(BSON(\"a\" << 1));\n    runQuerySkipNToReturn(BSON(\"x\" << 5), 3, 0);\n    ASSERT_EQUALS(getNumSolutions(), 1U);\n    assertSolutionExists(\"{skip: {n: 3, node: {cscan: {dir: 1, filter: {x: 5}}}}}\");\n}", "target": 0}
{"code": "_mibindex_add( const char *dirname, int i )\n{\n    const int old_mibindex_max = _mibindex_max;\n    DEBUGMSGTL((\"mibindex\", \"add: %s (%d)\\n\", dirname, i ));\n    if ( i == -1 )\n        i = _mibindex++;\n    if ( i >= _mibindex_max ) {\n        _mibindex_max = i + 10;\n        _mibindexes = realloc(_mibindexes,\n                              _mibindex_max * sizeof(_mibindexes[0]));\n        netsnmp_assert(_mibindexes);\n        memset(_mibindexes + old_mibindex_max, 0,\n               (_mibindex_max - old_mibindex_max) * sizeof(_mibindexes[0]));\n    }\n    _mibindexes[ i ] = strdup( dirname );\n    if ( i >= _mibindex )\n        _mibindex = i+1;\n    DEBUGMSGTL((\"mibindex\", \"add: %d/%d/%d\\n\", i, _mibindex, _mibindex_max ));\n    return i;\n}", "target": 1}
{"code": "authDigestNonceLink(digest_nonce_h * nonce)\n{\n    assert(nonce != NULL);\n    ++nonce->references;\n    assert(nonce->references != 0); \n    debugs(29, 9, \"nonce '\" << nonce << \"' now at '\" << nonce->references << \"'.\");\n}", "target": 0}
{"code": "static void coroutine_fn v9fs_mknod(void *opaque)\n{\n    int mode;\n    gid_t gid;\n    int32_t fid;\n    V9fsQID qid;\n    int err = 0;\n    int major, minor;\n    size_t offset = 7;\n    V9fsString name;\n    struct stat stbuf;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dsdddd\", &fid, &name, &mode,\n                        &major, &minor, &gid);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_mknod(pdu->tag, pdu->id, fid, mode, major, minor);\n    if (name_is_illegal(name.data)) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    if (!strcmp(\".\", name.data) || !strcmp(\"..\", name.data)) {\n        err = -EEXIST;\n        goto out_nofid;\n    }\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    err = v9fs_co_mknod(pdu, fidp, &name, fidp->uid, gid,\n                        makedev(major, minor), mode, &stbuf);\n    if (err < 0) {\n        goto out;\n    }\n    err = stat_to_qid(pdu, &stbuf, &qid);\n    if (err < 0) {\n        goto out;\n    }\n    err = pdu_marshal(pdu, offset, \"Q\", &qid);\n    if (err < 0) {\n        goto out;\n    }\n    err += offset;\n    trace_v9fs_mknod_return(pdu->tag, pdu->id,\n                            qid.type, qid.version, qid.path);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&name);\n}", "target": 0}
{"code": "uid_t from_kuid(struct user_namespace *targ, kuid_t kuid)\n{\n\treturn map_id_up(&targ->uid_map, __kuid_val(kuid));\n}", "target": 0}
{"code": "String UTF16BEDecoder::to_utf8(const StringView& input)\n{\n    StringBuilder builder(input.length() / 2);\n    for (size_t i = 0; i < input.length(); i += 2) {\n        u16 code_point = (input[i] << 8) | input[i + 1];\n        builder.append_code_point(code_point);\n    }\n    return builder.to_string();\n}", "target": 1}
{"code": "Status ValidateInputs(const Tensor *a_indices, const Tensor *a_values,\n                      const Tensor *a_shape, const Tensor *b) {\n  if (!TensorShapeUtils::IsMatrix(a_indices->shape())) {\n    return errors::InvalidArgument(\n        \"Input a_indices should be a matrix but received shape: \",\n        a_indices->shape().DebugString());\n  }\n  if (!TensorShapeUtils::IsVector(a_values->shape()) ||\n      !TensorShapeUtils::IsVector(a_shape->shape())) {\n    return errors::InvalidArgument(\n        \"Inputs a_values and a_shape should be vectors \"\n        \"but received shapes: \",\n        a_values->shape().DebugString(), \" and \",\n        a_shape->shape().DebugString());\n  }\n  int64_t nnz = a_indices->dim_size(0);\n  int64_t ndims = a_indices->dim_size(1);\n  if (a_values->dim_size(0) != nnz) {\n    return errors::InvalidArgument(\"Dimensions \", nnz, \" and \",\n                                   a_values->dim_size(0),\n                                   \" are not compatible\");\n  }\n  if (a_shape->dim_size(0) != ndims) {\n    return errors::InvalidArgument(\"Dimensions \", ndims, \" and \",\n                                   a_shape->dim_size(0), \" are not compatible\");\n  }\n  if (a_shape->NumElements() != b->dims()) {\n    return errors::InvalidArgument(\n        \"Two operands have different ranks; received: \", a_shape->NumElements(),\n        \" and \", b->dims());\n  }\n  const auto a_shape_flat = a_shape->flat<Index>();\n  for (int i = 0; i < b->dims(); ++i) {\n    if (a_shape_flat(i) != b->dim_size(i)) {\n      return errors::InvalidArgument(\n          \"Dimension \", i,\n          \" does not equal (no broadcasting is supported): sparse side \",\n          a_shape_flat(i), \" vs dense side \", b->dim_size(i));\n    }\n  }\n  const auto a_indices_mat = a_indices->flat_inner_dims<Index>();\n  for (int64_t zidx = 0; zidx < nnz; ++zidx) {\n    for (int64_t didx = 0; didx < ndims; ++didx) {\n      const Index idx = a_indices_mat(zidx, didx);\n      if (idx < 0 || idx >= a_shape_flat(didx)) {\n        return errors::InvalidArgument(\n            \"Sparse tensor has an invalid index on dimension \", didx,\n            \": \"\n            \"a_indices(\",\n            zidx, \",\", didx, \") = \", idx,\n            \", dense tensor shape: \", a_shape_flat);\n      }\n    }\n  }\n  return Status::OK();\n}", "target": 0}
{"code": "input_parse(struct window_pane *wp)\n{\n\tstruct input_ctx\t\t*ictx = wp->ictx;\n\tconst struct input_transition\t*itr;\n\tstruct evbuffer\t\t\t*evb = wp->event->input;\n\tu_char\t\t\t\t*buf;\n\tsize_t\t\t\t\t len, off;\n\tif (EVBUFFER_LENGTH(evb) == 0)\n\t\treturn;\n\twp->window->flags |= WINDOW_ACTIVITY;\n\twp->window->flags &= ~WINDOW_SILENCE;\n\tif (gettimeofday(&wp->window->activity_time, NULL) != 0)\n\t\tfatal(\"gettimeofday failed\");\n\tif (wp->mode == NULL)\n\t\tscreen_write_start(&ictx->ctx, wp, &wp->base);\n\telse\n\t\tscreen_write_start(&ictx->ctx, NULL, &wp->base);\n\tictx->wp = wp;\n\tbuf = EVBUFFER_DATA(evb);\n\tlen = EVBUFFER_LENGTH(evb);\n\tnotify_input(wp, evb);\n\toff = 0;\n\twhile (off < len) {\n\t\tictx->ch = buf[off++];\n\t\tlog_debug(\"%s: '%c' %s\", __func__, ictx->ch, ictx->state->name);\n\t\titr = ictx->state->transitions;\n\t\twhile (itr->first != -1 && itr->last != -1) {\n\t\t\tif (ictx->ch >= itr->first && ictx->ch <= itr->last)\n\t\t\t\tbreak;\n\t\t\titr++;\n\t\t}\n\t\tif (itr->first == -1 || itr->last == -1) {\n\t\t\tfatalx(\"No transition from state!\");\n\t\t}\n\t\tif (itr->handler != NULL && itr->handler(ictx) != 0)\n\t\t\tcontinue;\n\t\tif (itr->state != NULL)\n\t\t\tinput_set_state(wp, itr);\n\t\tif (ictx->state != &input_state_ground)\n\t\t\tevbuffer_add(ictx->since_ground, &ictx->ch, 1);\n\t}\n\tscreen_write_stop(&ictx->ctx);\n\tevbuffer_drain(evb, len);\n}", "target": 0}
{"code": "static int ipip6_rcv(struct sk_buff *skb)\n{\n\tstruct iphdr *iph;\n\tstruct ip_tunnel *tunnel;\n\tif (!pskb_may_pull(skb, sizeof(struct ipv6hdr)))\n\t\tgoto out;\n\tiph = ip_hdr(skb);\n\tread_lock(&ipip6_lock);\n\tif ((tunnel = ipip6_tunnel_lookup(dev_net(skb->dev),\n\t\t\t\t\tiph->saddr, iph->daddr)) != NULL) {\n\t\tsecpath_reset(skb);\n\t\tskb->mac_header = skb->network_header;\n\t\tskb_reset_network_header(skb);\n\t\tIPCB(skb)->flags = 0;\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\tskb->pkt_type = PACKET_HOST;\n\t\tif ((tunnel->dev->priv_flags & IFF_ISATAP) &&\n\t\t    !isatap_chksrc(skb, iph, tunnel)) {\n\t\t\ttunnel->stat.rx_errors++;\n\t\t\tread_unlock(&ipip6_lock);\n\t\t\tkfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\t\ttunnel->stat.rx_packets++;\n\t\ttunnel->stat.rx_bytes += skb->len;\n\t\tskb->dev = tunnel->dev;\n\t\tdst_release(skb->dst);\n\t\tskb->dst = NULL;\n\t\tnf_reset(skb);\n\t\tipip6_ecn_decapsulate(iph, skb);\n\t\tnetif_rx(skb);\n\t\tread_unlock(&ipip6_lock);\n\t\treturn 0;\n\t}\n\ticmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, 0);\n\tkfree_skb(skb);\n\tread_unlock(&ipip6_lock);\nout:\n\treturn 0;\n}", "target": 1}
{"code": "static int pfkey_broadcast(struct sk_buff *skb, gfp_t allocation,\n\t\t\t   int broadcast_flags, struct sock *one_sk,\n\t\t\t   struct net *net)\n{\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\tstruct sock *sk;\n\tstruct hlist_node *node;\n\tstruct sk_buff *skb2 = NULL;\n\tint err = -ESRCH;\n\tif (!skb)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tsk_for_each_rcu(sk, node, &net_pfkey->table) {\n\t\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\t\tint err2;\n\t\tif (pfk->promisc)\n\t\t\tpfkey_broadcast_one(skb, &skb2, allocation, sk);\n\t\tif (sk == one_sk)\n\t\t\tcontinue;\n\t\tif (broadcast_flags != BROADCAST_ALL) {\n\t\t\tif (broadcast_flags & BROADCAST_PROMISC_ONLY)\n\t\t\t\tcontinue;\n\t\t\tif ((broadcast_flags & BROADCAST_REGISTERED) &&\n\t\t\t    !pfk->registered)\n\t\t\t\tcontinue;\n\t\t\tif (broadcast_flags & BROADCAST_ONE)\n\t\t\t\tcontinue;\n\t\t}\n\t\terr2 = pfkey_broadcast_one(skb, &skb2, allocation, sk);\n\t\tif ((broadcast_flags & BROADCAST_REGISTERED) && err)\n\t\t\terr = err2;\n\t}\n\trcu_read_unlock();\n\tif (one_sk != NULL)\n\t\terr = pfkey_broadcast_one(skb, &skb2, allocation, one_sk);\n\tkfree_skb(skb2);\n\tkfree_skb(skb);\n\treturn err;\n}", "target": 0}
{"code": "int32_t CxImage::GetSize()\n{\n\treturn head.biSize + head.biSizeImage + GetPaletteSize();\n}", "target": 1}
{"code": "static inline void nft_reg_store64(u32 *dreg, u64 val)\n{\n\tput_unaligned(val, (u64 *)dreg);\n}", "target": 1}
{"code": "sread(int fd, void *buf, size_t n, int canbepipe)\n{\n\tssize_t rv;\n#ifdef FIONREAD\n\tint t = 0;\n#endif\n\tsize_t rn = n;\n\tif (fd == STDIN_FILENO)\n\t\tgoto nocheck;\n#ifdef FIONREAD\n\tif (canbepipe && (ioctl(fd, FIONREAD, &t) == -1 || t == 0)) {\n#ifdef FD_ZERO\n\t\tssize_t cnt;\n\t\tfor (cnt = 0;; cnt++) {\n\t\t\tfd_set check;\n\t\t\tstruct timeval tout = {0, 100 * 1000};\n\t\t\tint selrv;\n\t\t\tFD_ZERO(&check);\n\t\t\tFD_SET(fd, &check);\n\t\t\tselrv = select(fd + 1, &check, NULL, NULL, &tout);\n\t\t\tif (selrv == -1) {\n\t\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\t\tcontinue;\n\t\t\t} else if (selrv == 0 && cnt >= 5) {\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n#endif\n\t\t(void)ioctl(fd, FIONREAD, &t);\n\t}\n\tif (t > 0 && (size_t)t < n) {\n\t\tn = t;\n\t\trn = n;\n\t}\n#endif\nnocheck:\n\tdo\n\t\tswitch ((rv = FINFO_READ_FUNC(fd, buf, n))) {\n\t\tcase -1:\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\treturn -1;\n\t\tcase 0:\n\t\t\treturn rn - n;\n\t\tdefault:\n\t\t\tn -= rv;\n\t\t\tbuf = ((char *)buf) + rv;\n\t\t\tbreak;\n\t\t}\n\twhile (n > 0);\n\treturn rn;\n}", "target": 0}
{"code": "SPL_METHOD(SplDoublyLinkedList, unserialize)\n{\n\tspl_dllist_object     *intern   = (spl_dllist_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tzval                  *flags, *elem;\n\tchar *buf;\n\tint buf_len;\n\tconst unsigned char *p, *s;\n\tphp_unserialize_data_t var_hash;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &buf, &buf_len) == FAILURE) {\n\t\treturn;\n\t}\n\tif (buf_len == 0) {\n\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Serialized string cannot be empty\");\n\t\treturn;\n\t}\n\ts = p = (const unsigned char*)buf;\n\tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n\tALLOC_INIT_ZVAL(flags);\n\tif (!php_var_unserialize(&flags, &p, s + buf_len, &var_hash TSRMLS_CC) || Z_TYPE_P(flags) != IS_LONG) {\n\t\tzval_ptr_dtor(&flags);\n\t\tgoto error;\n\t}\n\tintern->flags = Z_LVAL_P(flags);\n\tzval_ptr_dtor(&flags);\n\twhile(*p == ':') {\n\t\t++p;\n\t\tALLOC_INIT_ZVAL(elem);\n\t\tif (!php_var_unserialize(&elem, &p, s + buf_len, &var_hash TSRMLS_CC)) {\n\t\t\tzval_ptr_dtor(&elem);\n\t\t\tgoto error;\n\t\t}\n\t\tspl_ptr_llist_push(intern->llist, elem TSRMLS_CC);\n\t}\n\tif (*p != '\\0') {\n\t\tgoto error;\n\t}\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\treturn;\nerror:\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Error at offset %ld of %d bytes\", (long)((char*)p - buf), buf_len);\n\treturn;\n} ", "target": 1}
{"code": "static ZIPARCHIVE_METHOD(addFromString)\n{\n\tstruct zip *intern;\n\tzval *this = getThis();\n\tchar *buffer, *name;\n\tint buffer_len, name_len;\n\tze_zip_object *ze_obj;\n\tstruct zip_source *zs;\n\tint pos = 0;\n\tint cur_idx;\n\tif (!this) {\n\t\tRETURN_FALSE;\n\t}\n\tZIP_FROM_OBJECT(intern, this);\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ss\",\n\t\t\t&name, &name_len, &buffer, &buffer_len) == FAILURE) {\n\t\treturn;\n\t}\n\tze_obj = (ze_zip_object*) zend_object_store_get_object(this TSRMLS_CC);\n\tif (ze_obj->buffers_cnt) {\n\t\tze_obj->buffers = (char **)erealloc(ze_obj->buffers, sizeof(char *) * (ze_obj->buffers_cnt+1));\n\t\tpos = ze_obj->buffers_cnt++;\n\t} else {\n\t\tze_obj->buffers = (char **)emalloc(sizeof(char *));\n\t\tze_obj->buffers_cnt++;\n\t\tpos = 0;\n\t}\n\tze_obj->buffers[pos] = (char *)emalloc(buffer_len + 1);\n\tmemcpy(ze_obj->buffers[pos], buffer, buffer_len + 1);\n\tzs = zip_source_buffer(intern, ze_obj->buffers[pos], buffer_len, 0);\n\tif (zs == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tcur_idx = zip_name_locate(intern, (const char *)name, 0);\n\tif (cur_idx >= 0) {\n\t\tif (zip_delete(intern, cur_idx) == -1) {\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (zip_add(intern, name, zs) != -1) {\n\t\tRETURN_TRUE;\n\t}\nfail:\n\tzip_source_free(zs);\n\tRETURN_FALSE;\n}", "target": 0}
{"code": "int sc_file_set_sec_attr(sc_file_t *file, const u8 *sec_attr,\n\t\t\t size_t sec_attr_len)\n{\n\tu8 *tmp;\n\tif (!sc_file_valid(file)) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\tif (sec_attr == NULL || sec_attr_len) {\n\t\tif (file->sec_attr != NULL)\n\t\t\tfree(file->sec_attr);\n\t\tfile->sec_attr = NULL;\n\t\tfile->sec_attr_len = 0;\n\t\treturn 0;\n\t }\n\ttmp = (u8 *) realloc(file->sec_attr, sec_attr_len);\n\tif (!tmp) {\n\t\tif (file->sec_attr)\n\t\t\tfree(file->sec_attr);\n\t\tfile->sec_attr     = NULL;\n\t\tfile->sec_attr_len = 0;\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t}\n\tfile->sec_attr = tmp;\n\tmemcpy(file->sec_attr, sec_attr, sec_attr_len);\n\tfile->sec_attr_len = sec_attr_len;\n\treturn 0;\n}", "target": 0}
{"code": "void nf_tables_activate_set(const struct nft_ctx *ctx, struct nft_set *set)\n{\n\tif (nft_set_is_anonymous(set))\n\t\tnft_clear(ctx->net, set);\n\tset->use++;\n}", "target": 0}
{"code": "static bool has_locked_children(struct mount *mnt, struct dentry *dentry)\n{\n\tstruct mount *child;\n\tlist_for_each_entry(child, &mnt->mnt_mounts, mnt_child) {\n\t\tif (!is_subdir(child->mnt_mountpoint, dentry))\n\t\t\tcontinue;\n\t\tif (child->mnt.mnt_flags & MNT_LOCKED)\n\t\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "static ssize_t ib_ucm_write(struct file *filp, const char __user *buf,\n\t\t\t    size_t len, loff_t *pos)\n{\n\tstruct ib_ucm_file *file = filp->private_data;\n\tstruct ib_ucm_cmd_hdr hdr;\n\tssize_t result;\n\tif (WARN_ON_ONCE(!ib_safe_file_access(filp)))\n\t\treturn -EACCES;\n\tif (len < sizeof(hdr))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&hdr, buf, sizeof(hdr)))\n\t\treturn -EFAULT;\n\tif (hdr.cmd >= ARRAY_SIZE(ucm_cmd_table))\n\t\treturn -EINVAL;\n\tif (hdr.in + sizeof(hdr) > len)\n\t\treturn -EINVAL;\n\tresult = ucm_cmd_table[hdr.cmd](file, buf + sizeof(hdr),\n\t\t\t\t\thdr.in, hdr.out);\n\tif (!result)\n\t\tresult = len;\n\treturn result;\n}", "target": 0}
{"code": "int sas_ex_revalidate_domain(struct domain_device *port_dev)\n{\n\tint res;\n\tstruct domain_device *dev = NULL;\n\tres = sas_find_bcast_dev(port_dev, &dev);\n\twhile (res == 0 && dev) {\n\t\tstruct expander_device *ex = &dev->ex_dev;\n\t\tint i = 0, phy_id;\n\t\tdo {\n\t\t\tphy_id = -1;\n\t\t\tres = sas_find_bcast_phy(dev, &phy_id, i, true);\n\t\t\tif (phy_id == -1)\n\t\t\t\tbreak;\n\t\t\tres = sas_rediscover(dev, phy_id);\n\t\t\ti = phy_id + 1;\n\t\t} while (i < ex->num_phys);\n\t\tdev = NULL;\n\t\tres = sas_find_bcast_dev(port_dev, &dev);\n\t}\n\treturn res;\n}", "target": 1}
{"code": "isdn_ppp_poll(struct file *file, poll_table *wait)\n{\n\tu_int mask;\n\tstruct ippp_buf_queue *bf, *bl;\n\tu_long flags;\n\tstruct ippp_struct *is;\n\tis = file->private_data;\n\tif (is->debug & 0x2)\n\t\tprintk(KERN_DEBUG \"isdn_ppp_poll: minor: %d\\n\",\n\t\t       iminor(file_inode(file)));\n\tpoll_wait(file, &is->wq, wait);\n\tif (!(is->state & IPPP_OPEN)) {\n\t\tif (is->state == IPPP_CLOSEWAIT)\n\t\t\treturn POLLHUP;\n\t\tprintk(KERN_DEBUG \"isdn_ppp: device not open\\n\");\n\t\treturn POLLERR;\n\t}\n\tmask = POLLOUT | POLLWRNORM;\n\tspin_lock_irqsave(&is->buflock, flags);\n\tbl = is->last;\n\tbf = is->first;\n\tif (bf->next != bl || (is->state & IPPP_NOBLOCK)) {\n\t\tis->state &= ~IPPP_NOBLOCK;\n\t\tmask |= POLLIN | POLLRDNORM;\n\t}\n\tspin_unlock_irqrestore(&is->buflock, flags);\n\treturn mask;\n}", "target": 0}
{"code": "GetIoStats(Mgr::IoActionData& stats)\n{\n    int i;\n    stats.http_reads = IOStats.Http.reads;\n    for (i = 0; i < IoStats::histSize; ++i) {\n        stats.http_read_hist[i] = IOStats.Http.read_hist[i];\n    }\n    stats.ftp_reads = IOStats.Ftp.reads;\n    for (i = 0; i < IoStats::histSize; ++i) {\n        stats.ftp_read_hist[i] = IOStats.Ftp.read_hist[i];\n    }\n    stats.gopher_reads = IOStats.Gopher.reads;\n    for (i = 0; i < IoStats::histSize; ++i) {\n        stats.gopher_read_hist[i] = IOStats.Gopher.read_hist[i];\n    }\n}", "target": 1}
{"code": "static int xfrm_dump_policy(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];\n\tstruct xfrm_dump_info info;\n\tBUILD_BUG_ON(sizeof(struct xfrm_policy_walk) >\n\t\t     sizeof(cb->args) - sizeof(cb->args[0]));\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\tif (!cb->args[0]) {\n\t\tcb->args[0] = 1;\n\t\txfrm_policy_walk_init(walk, XFRM_POLICY_TYPE_ANY);\n\t}\n\t(void) xfrm_policy_walk(net, walk, dump_one_policy, &info);\n\treturn skb->len;\n}", "target": 1}
{"code": "file_check_mem(struct magic_set *ms, unsigned int level)\n{\n\tsize_t len;\n\tif (level >= ms->c.len) {\n\t\tlen = (ms->c.len += 20) * sizeof(*ms->c.li);\n\t\tms->c.li = CAST(struct level_info *, (ms->c.li == NULL) ?\n\t\t    malloc(len) :\n\t\t    realloc(ms->c.li, len));\n\t\tif (ms->c.li == NULL) {\n\t\t\tfile_oomem(ms, len);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tms->c.li[level].got_match = 0;\n#ifdef ENABLE_CONDITIONALS\n\tms->c.li[level].last_match = 0;\n\tms->c.li[level].last_cond = COND_NONE;\n#endif \n\treturn 0;\n}", "target": 1}
{"code": "k5_asn1_full_decode(const krb5_data *code, const struct atype_info *a,\n                    void **retrep)\n{\n    krb5_error_code ret;\n    const uint8_t *contents, *remainder;\n    size_t clen, rlen;\n    taginfo t;\n    *retrep = NULL;\n    ret = get_tag((uint8_t *)code->data, code->length, &t, &contents,\n                  &clen, &remainder, &rlen);\n    if (ret)\n        return ret;\n    if (!check_atype_tag(a, &t))\n        return ASN1_BAD_ID;\n    return decode_atype_to_ptr(&t, contents, clen, a, retrep);\n}", "target": 1}
{"code": "static void bfq_idle_slice_timer_body(struct bfq_queue *bfqq)\n{\n\tstruct bfq_data *bfqd = bfqq->bfqd;\n\tenum bfqq_expiration reason;\n\tunsigned long flags;\n\tspin_lock_irqsave(&bfqd->lock, flags);\n\tbfq_clear_bfqq_wait_request(bfqq);\n\tif (bfqq != bfqd->in_service_queue) {\n\t\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\t\treturn;\n\t}\n\tif (bfq_bfqq_budget_timeout(bfqq))\n\t\treason = BFQQE_BUDGET_TIMEOUT;\n\telse if (bfqq->queued[0] == 0 && bfqq->queued[1] == 0)\n\t\treason = BFQQE_TOO_IDLE;\n\telse\n\t\tgoto schedule_dispatch;\n\tbfq_bfqq_expire(bfqd, bfqq, true, reason);\nschedule_dispatch:\n\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\tbfq_schedule_dispatch(bfqd);", "target": 1}
{"code": "mrb_obj_clone(mrb_state *mrb, mrb_value self)\n{\n  struct RObject *p;\n  mrb_value clone;\n  if (mrb_immediate_p(self)) {\n    mrb_raisef(mrb, E_TYPE_ERROR, \"can't clone %S\", self);\n  }\n  if (mrb_type(self) == MRB_TT_SCLASS) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't clone singleton class\");\n  }\n  p = (struct RObject*)mrb_obj_alloc(mrb, mrb_type(self), mrb_obj_class(mrb, self));\n  p->c = mrb_singleton_class_clone(mrb, self);\n  mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)p->c);\n  clone = mrb_obj_value(p);\n  init_copy(mrb, clone, self);\n  p->flags = mrb_obj_ptr(self)->flags;\n  return clone;\n}", "target": 1}
{"code": "static int atalk_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t int *uaddr_len, int peer)\n{\n\tstruct sockaddr_at sat;\n\tstruct sock *sk = sock->sk;\n\tstruct atalk_sock *at = at_sk(sk);\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tif (atalk_autobind(sk) < 0)\n\t\t\treturn -ENOBUFS;\n\t*uaddr_len = sizeof(struct sockaddr_at);\n\tif (peer) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\t\tsat.sat_addr.s_net  = at->dest_net;\n\t\tsat.sat_addr.s_node = at->dest_node;\n\t\tsat.sat_port\t    = at->dest_port;\n\t} else {\n\t\tsat.sat_addr.s_net  = at->src_net;\n\t\tsat.sat_addr.s_node = at->src_node;\n\t\tsat.sat_port\t    = at->src_port;\n\t}\n\tsat.sat_family = AF_APPLETALK;\n\tmemcpy(uaddr, &sat, sizeof(sat));\n\treturn 0;\n}", "target": 1}
{"code": "static void __net_random_once_deferred(struct work_struct *w)\n{\n\tstruct __net_random_once_work *work =\n\t\tcontainer_of(w, struct __net_random_once_work, work);\n\tif (!static_key_enabled(work->key))\n\t\tstatic_key_slow_inc(work->key);\n\tkfree(work);\n}", "target": 1}
{"code": "static void vvc_parse_general_timing_hrd_parameters(GF_BitStream *bs, VVC_SPS *sps, VVC_VPS *vps, Bool *general_nal_hrd_params_present_flag, Bool *general_vcl_hrd_params_present_flag, Bool *general_du_hrd_params_present_flag, u32 *hrd_cpb_cnt_minus1)\n{\n\tsps->has_timing_info = 1;\n\tsps->num_units_in_tick = gf_bs_read_int_log(bs, 32, \"num_units_in_tick\");\n\tsps->time_scale = gf_bs_read_int_log(bs, 32, \"timescale\");\n\t*general_du_hrd_params_present_flag = GF_FALSE;\n\t*general_nal_hrd_params_present_flag = gf_bs_read_int_log(bs, 1, \"general_nal_hrd_params_present_flag\");\n\t*general_vcl_hrd_params_present_flag = gf_bs_read_int_log(bs, 1, \"general_vcl_hrd_params_present_flag\");\n\tif (*general_nal_hrd_params_present_flag || *general_vcl_hrd_params_present_flag) {\n\t\tgf_bs_read_int_log(bs, 1, \"general_same_pic_timing_in_all_ols_flag\");\n\t\t*general_du_hrd_params_present_flag = gf_bs_read_int_log(bs, 1, \"general_du_hrd_params_present_flag\");\n\t\tif (*general_du_hrd_params_present_flag)\n\t\t\tgf_bs_read_int_log(bs, 8, \"tick_divisor_minus2\");\n\t\tgf_bs_read_int_log(bs, 4, \"bit_rate_scale\");\n\t\tgf_bs_read_int_log(bs, 4, \"cpb_size_scale\");\n\t\tif (*general_du_hrd_params_present_flag)\n\t\t\tgf_bs_read_int_log(bs, 4, \"cpb_size_du_scale\");\n\t\t*hrd_cpb_cnt_minus1 = gf_bs_read_ue_log(bs, \"hrd_cpb_cnt_minus1\");\n\t}\n}", "target": 0}
{"code": "bool IsIdentityConsumingSwitch(const MutableGraphView& graph,\n                               const NodeDef& node) {\n  if ((IsIdentity(node) || IsIdentityNSingleInput(node)) &&\n      node.input_size() > 0) {\n    TensorId tensor_id = ParseTensorName(node.input(0));\n    if (IsTensorIdControlling(tensor_id)) {\n      return false;\n    }\n    NodeDef* input_node = graph.GetNode(tensor_id.node());\n    return IsSwitch(*input_node);\n  }\n  return false;\n}", "target": 1}
{"code": "PHP_FUNCTION(pg_field_name)\n{\n\tphp_pgsql_get_field_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_FIELD_NAME);\n}", "target": 0}
{"code": "static ssize_t stream_ssl_write_cb(RedStream *s, const void *buf, size_t size)\n{\n    int return_code;\n    return_code = SSL_write(s->priv->ssl, buf, size);\n    if (return_code < 0) {\n        return stream_ssl_error(s, return_code);\n    }\n    return return_code;\n}", "target": 0}
{"code": "static void ifb_setup(struct net_device *dev)\n{\n\tdev->destructor = free_netdev;\n\tdev->netdev_ops = &ifb_netdev_ops;\n\tether_setup(dev);\n\tdev->tx_queue_len = TX_Q_LIMIT;\n\tdev->features |= IFB_FEATURES;\n\tdev->vlan_features |= IFB_FEATURES;\n\tdev->flags |= IFF_NOARP;\n\tdev->flags &= ~IFF_MULTICAST;\n\tdev->priv_flags &= ~IFF_XMIT_DST_RELEASE;\n\trandom_ether_addr(dev->dev_addr);\n}", "target": 1}
{"code": "static bool freelist_state_initialize(union freelist_init_state *state,\n\t\t\t\tstruct kmem_cache *cachep,\n\t\t\t\tunsigned int count)\n{\n\tbool ret;\n\tunsigned int rand;\n\trand = get_random_int();\n\tif (!cachep->random_seq) {\n\t\tprandom_seed_state(&state->rnd_state, rand);\n\t\tret = false;\n\t} else {\n\t\tstate->list = cachep->random_seq;\n\t\tstate->count = count;\n\t\tstate->pos = 0;\n\t\tstate->rand = rand;\n\t\tret = true;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static void close_all_connections(struct Curl_multi *multi)\n{\n  struct connectdata *conn;\n  conn = Curl_conncache_find_first_connection(&multi->conn_cache);\n  while(conn) {\n    SIGPIPE_VARIABLE(pipe_st);\n    conn->data = multi->closure_handle;\n    sigpipe_ignore(conn->data, &pipe_st);\n    (void)Curl_disconnect(conn, FALSE);\n    sigpipe_restore(&pipe_st);\n    conn = Curl_conncache_find_first_connection(&multi->conn_cache);\n  }\n}", "target": 1}
{"code": "SYSCALL_DEFINE5(waitid, int, which, pid_t, upid, struct siginfo __user *,\n\t\tinfop, int, options, struct rusage __user *, ru)\n{\n\tstruct rusage r;\n\tstruct waitid_info info = {.status = 0};\n\tlong err = kernel_waitid(which, upid, &info, options, ru ? &r : NULL);\n\tint signo = 0;\n\tif (err > 0) {\n\t\tsigno = SIGCHLD;\n\t\terr = 0;\n\t}\n\tif (!err) {\n\t\tif (ru && copy_to_user(ru, &r, sizeof(struct rusage)))\n\t\t\treturn -EFAULT;\n\t}\n\tif (!infop)\n\t\treturn err;\n\tuser_access_begin();\n\tunsafe_put_user(signo, &infop->si_signo, Efault);\n\tunsafe_put_user(0, &infop->si_errno, Efault);\n\tunsafe_put_user(info.cause, &infop->si_code, Efault);\n\tunsafe_put_user(info.pid, &infop->si_pid, Efault);\n\tunsafe_put_user(info.uid, &infop->si_uid, Efault);\n\tunsafe_put_user(info.status, &infop->si_status, Efault);\n\tuser_access_end();\n\treturn err;\nEfault:\n\tuser_access_end();\n\treturn -EFAULT;\n}", "target": 1}
{"code": "mld6_print(netdissect_options *ndo, const u_char *bp)\n{\n\tconst struct mld6_hdr *mp = (const struct mld6_hdr *)bp;\n\tconst u_char *ep;\n\tep = ndo->ndo_snapend;\n\tif ((const u_char *)mp + sizeof(*mp) > ep)\n\t\treturn;\n\tND_PRINT((ndo,\"max resp delay: %d \", EXTRACT_16BITS(&mp->mld6_maxdelay)));\n\tND_PRINT((ndo,\"addr: %s\", ip6addr_string(ndo, &mp->mld6_addr)));\n}", "target": 0}
{"code": "static locale_t AcquireCLocale(void)\n{\n#if defined(MAGICKCORE_HAVE_NEWLOCALE)\n  if (c_locale == (locale_t) NULL)\n    c_locale=newlocale(LC_ALL_MASK,\"C\",(locale_t) 0);\n#elif defined(MAGICKCORE_WINDOWS_SUPPORT) && !defined(__MINGW32__)\n  if (c_locale == (locale_t) NULL)\n    c_locale=_create_locale(LC_ALL,\"C\");\n#endif\n  return(c_locale);\n}", "target": 0}
{"code": "static int vhost_worker(void *data)\n{\n\tstruct vhost_dev *dev = data;\n\tstruct vhost_work *work = NULL;\n\tunsigned uninitialized_var(seq);\n\tmm_segment_t oldfs = get_fs();\n\tset_fs(USER_DS);\n\tuse_mm(dev->mm);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tspin_lock_irq(&dev->work_lock);\n\t\tif (work) {\n\t\t\twork->done_seq = seq;\n\t\t\tif (work->flushing)\n\t\t\t\twake_up_all(&work->done);\n\t\t}\n\t\tif (kthread_should_stop()) {\n\t\t\tspin_unlock_irq(&dev->work_lock);\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t\tbreak;\n\t\t}\n\t\tif (!list_empty(&dev->work_list)) {\n\t\t\twork = list_first_entry(&dev->work_list,\n\t\t\t\t\t\tstruct vhost_work, node);\n\t\t\tlist_del_init(&work->node);\n\t\t\tseq = work->queue_seq;\n\t\t} else\n\t\t\twork = NULL;\n\t\tspin_unlock_irq(&dev->work_lock);\n\t\tif (work) {\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t\twork->fn(work);\n\t\t\tif (need_resched())\n\t\t\t\tschedule();\n\t\t} else\n\t\t\tschedule();\n\t}\n\tunuse_mm(dev->mm);\n\tset_fs(oldfs);\n\treturn 0;\n}", "target": 0}
{"code": "storageStateInitialize(bool privileged,\n                       const char *root,\n                       virStateInhibitCallback callback G_GNUC_UNUSED,\n                       void *opaque G_GNUC_UNUSED)\n{\n    g_autofree char *configdir = NULL;\n    g_autofree char *rundir = NULL;\n    bool autostart = true;\n    if (root != NULL) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Driver does not support embedded mode\"));\n        return -1;\n    }\n    driver = g_new0(virStorageDriverState, 1);\n    driver->lockFD = -1;\n    if (virMutexInit(&driver->lock) < 0) {\n        VIR_FREE(driver);\n        return VIR_DRV_STATE_INIT_ERROR;\n    }\n    storageDriverLock();\n    if (!(driver->pools = virStoragePoolObjListNew()))\n        goto error;\n    if (privileged) {\n        driver->configDir = g_strdup(SYSCONFDIR \"/libvirt/storage\");\n        driver->autostartDir = g_strdup(SYSCONFDIR \"/libvirt/storage/autostart\");\n        driver->stateDir = g_strdup(RUNSTATEDIR \"/libvirt/storage\");\n    } else {\n        configdir = virGetUserConfigDirectory();\n        rundir = virGetUserRuntimeDirectory();\n        driver->configDir = g_strdup_printf(\"%s/storage\", configdir);\n        driver->autostartDir = g_strdup_printf(\"%s/storage/autostart\", configdir);\n        driver->stateDir = g_strdup_printf(\"%s/storage/run\", rundir);\n    }\n    driver->privileged = privileged;\n    if (g_mkdir_with_parents(driver->stateDir, 0777) < 0) {\n        virReportError(errno,\n                       _(\"cannot create directory %s\"),\n                       driver->stateDir);\n        goto error;\n    }\n    if ((driver->lockFD =\n         virPidFileAcquire(driver->stateDir, \"driver\",\n                           false, getpid())) < 0)\n        goto error;\n    if (virStoragePoolObjLoadAllState(driver->pools,\n                                      driver->stateDir) < 0)\n        goto error;\n    if (virStoragePoolObjLoadAllConfigs(driver->pools,\n                                        driver->configDir,\n                                        driver->autostartDir) < 0)\n        goto error;\n    storagePoolUpdateAllState();\n    if (virDriverShouldAutostart(driver->stateDir, &autostart) < 0)\n        goto error;\n    if (autostart)\n        storageDriverAutostart();\n    driver->storageEventState = virObjectEventStateNew();\n    if (!(driver->caps = virStorageBackendGetCapabilities()))\n        goto error;\n    storageDriverUnlock();\n    return VIR_DRV_STATE_INIT_COMPLETE;\n error:\n    storageDriverUnlock();\n    storageStateCleanup();\n    return VIR_DRV_STATE_INIT_ERROR;\n}", "target": 0}
{"code": "static int cenc_scheme_decrypt(MOVContext *c, MOVStreamContext *sc, AVEncryptionInfo *sample, uint8_t *input, int size)\n{\n    int i, ret;\n    int bytes_of_protected_data;\n    if (!sc->cenc.aes_ctr) {\n        sc->cenc.aes_ctr = av_aes_ctr_alloc();\n        if (!sc->cenc.aes_ctr) {\n            return AVERROR(ENOMEM);\n        }\n        ret = av_aes_ctr_init(sc->cenc.aes_ctr, c->decryption_key);\n        if (ret < 0) {\n            return ret;\n        }\n    }\n    av_aes_ctr_set_full_iv(sc->cenc.aes_ctr, sample->iv);\n    if (!sample->subsample_count) {\n        av_aes_ctr_crypt(sc->cenc.aes_ctr, input, input, size);\n        return 0;\n    }\n    for (i = 0; i < sample->subsample_count; i++) {\n        if (sample->subsamples[i].bytes_of_clear_data + sample->subsamples[i].bytes_of_protected_data > size) {\n            av_log(c->fc, AV_LOG_ERROR, \"subsample size exceeds the packet size left\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        input += sample->subsamples[i].bytes_of_clear_data;\n        size -= sample->subsamples[i].bytes_of_clear_data;\n        bytes_of_protected_data = sample->subsamples[i].bytes_of_protected_data;\n        av_aes_ctr_crypt(sc->cenc.aes_ctr, input, input, bytes_of_protected_data);\n        input += bytes_of_protected_data;\n        size -= bytes_of_protected_data;\n    }\n    if (size > 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"leftover packet bytes after subsample processing\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    return 0;\n}", "target": 0}
{"code": "void ntlm_populate_message_header(NTLM_MESSAGE_HEADER* header, UINT32 MessageType)\n{\n\tCopyMemory(header->Signature, NTLM_SIGNATURE, sizeof(NTLM_SIGNATURE));\n\theader->MessageType = MessageType;\n}", "target": 1}
{"code": "Status ValidatePaddingValues(absl::Span<const int64_t> input_dimensions,\n                             absl::Span<const int64_t> window_dimensions,\n                             absl::Span<const int64_t> window_strides) {\n  bool ok = input_dimensions.size() == window_dimensions.size() &&\n            input_dimensions.size() == window_strides.size();\n  if (!ok) {\n    return InvalidArgument(\n        \"Want input dimensions size %u = window dimensions size %u = window \"\n        \"strides size %u\",\n        input_dimensions.size(), window_dimensions.size(),\n        window_strides.size());\n  }\n  for (size_t i = 0; i < input_dimensions.size(); ++i) {\n    if (window_dimensions[i] <= 0) {\n      return InvalidArgument(\"Window dimension %u has non-positive size %d\", i,\n                             window_dimensions[i]);\n    }\n    if (window_strides[i] <= 0) {\n      return InvalidArgument(\"Window dimension %u has non-positive stride %d\",\n                             i, window_strides[i]);\n    }\n  }\n  return OkStatus();\n}", "target": 0}
{"code": "PHPAPI char *php_get_current_user(void)\n{\n\tzend_stat_t *pstat;\n\tif (SG(request_info).current_user) {\n\t\treturn SG(request_info).current_user;\n\t}\n\tpstat = sapi_get_stat();\n\tif (!pstat) {\n\t\treturn \"\";\n\t} else {\n#ifdef PHP_WIN32\n\t\tchar name[256];\n\t\tDWORD len = sizeof(name)-1;\n\t\tif (!GetUserName(name, &len)) {\n\t\t\treturn \"\";\n\t\t}\n\t\tname[len] = '\\0';\n\t\tSG(request_info).current_user_length = len;\n\t\tSG(request_info).current_user = estrndup(name, len);\n\t\treturn SG(request_info).current_user;\n#else\n\t\tstruct passwd *pwd;\n#if defined(ZTS) && defined(HAVE_GETPWUID_R) && defined(_SC_GETPW_R_SIZE_MAX)\n\t\tstruct passwd _pw;\n\t\tstruct passwd *retpwptr = NULL;\n\t\tint pwbuflen = sysconf(_SC_GETPW_R_SIZE_MAX);\n\t\tchar *pwbuf;\n\t\tif (pwbuflen < 1) {\n\t\t\treturn \"\";\n\t\t}\n\t\tpwbuf = emalloc(pwbuflen);\n\t\tif (getpwuid_r(pstat->st_uid, &_pw, pwbuf, pwbuflen, &retpwptr) != 0) {\n\t\t\tefree(pwbuf);\n\t\t\treturn \"\";\n\t\t}\n\t\tif (retpwptr == NULL) {\n\t\t\tefree(pwbuf);\n\t\t\treturn \"\";\n\t\t}\n\t\tpwd = &_pw;\n#else\n\t\tif ((pwd=getpwuid(pstat->st_uid))==NULL) {\n\t\t\treturn \"\";\n\t\t}\n#endif\n\t\tSG(request_info).current_user_length = strlen(pwd->pw_name);\n\t\tSG(request_info).current_user = estrndup(pwd->pw_name, SG(request_info).current_user_length);\n#if defined(ZTS) && defined(HAVE_GETPWUID_R) && defined(_SC_GETPW_R_SIZE_MAX)\n\t\tefree(pwbuf);\n#endif\n\t\treturn SG(request_info).current_user;\n#endif\n\t}\n}", "target": 0}
{"code": "void CLASS panasonic_load_raw()\n{\n  int row, col, i, j, sh = 0, pred[2], nonz[2];\n  pana_bits(0);\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < raw_width; col++)\n    {\n      if ((i = col % 14) == 0)\n        pred[0] = pred[1] = nonz[0] = nonz[1] = 0;\n      if (i % 3 == 2)\n        sh = 4 >> (3 - pana_bits(2));\n      if (nonz[i & 1])\n      {\n        if ((j = pana_bits(8)))\n        {\n          if ((pred[i & 1] -= 0x80 << sh) < 0 || sh == 4)\n            pred[i & 1] &= ~((~0u) << sh);\n          pred[i & 1] += j << sh;\n        }\n      }\n      else if ((nonz[i & 1] = pana_bits(8)) || i > 11)\n        pred[i & 1] = nonz[i & 1] << 4 | pana_bits(4);\n      if ((RAW(row, col) = pred[col & 1]) > 4098 && col < width)\n        derror();\n    }\n  }\n}", "target": 1}
{"code": "ospf_upd_list_clean (struct list *lsas)\n{\n  struct listnode *node, *nnode;\n  struct ospf_lsa *lsa;\n  for (ALL_LIST_ELEMENTS (lsas, node, nnode, lsa))\n    ospf_lsa_discard (lsa);\n  list_delete (lsas);\n}", "target": 0}
{"code": "Status ArrayFromMemory(int dim_size, npy_intp* dims, void* data, DataType dtype,\n                       std::function<void()> destructor, PyObject** result) {\n  if (dtype == DT_STRING || dtype == DT_RESOURCE) {\n    return errors::FailedPrecondition(\n        \"Cannot convert string or resource Tensors.\");\n  }\n  int type_num = -1;\n  Status s =\n      TF_DataType_to_PyArray_TYPE(static_cast<TF_DataType>(dtype), &type_num);\n  if (!s.ok()) {\n    return s;\n  }\n  if (dim_size > NPY_MAXDIMS) {\n    return errors::InvalidArgument(\n        \"Cannot convert tensor with \", dim_size,\n        \" dimensions to NumPy array. NumPy arrays can have at most \",\n        NPY_MAXDIMS, \" dimensions\");\n  }\n  auto* np_array = reinterpret_cast<PyArrayObject*>(\n      PyArray_SimpleNewFromData(dim_size, dims, type_num, data));\n  if (np_array == nullptr) {\n    string shape_str = absl::StrJoin(\n        absl::Span<npy_intp>{dims, static_cast<size_t>(dim_size)}, \", \");\n    if (PyErr_Occurred()) {\n      string exception_str = PyExceptionFetch();\n      PyErr_Clear();\n      return errors::InvalidArgument(\n          \"Failed to create numpy array from tensor of shape [\", shape_str,\n          \"]. Numpy error: \", exception_str);\n    }\n    return errors::Internal(\n        \"Failed to create numpy array from tensor of shape [\", shape_str, \"]\");\n  }\n  PyArray_CLEARFLAGS(np_array, NPY_ARRAY_OWNDATA);\n  if (PyType_Ready(&TensorReleaserType) == -1) {\n    return errors::Unknown(\"Python type initialization failed.\");\n  }\n  auto* releaser = reinterpret_cast<TensorReleaser*>(\n      TensorReleaserType.tp_alloc(&TensorReleaserType, 0));\n  releaser->destructor = new std::function<void()>(std::move(destructor));\n  if (PyArray_SetBaseObject(np_array, reinterpret_cast<PyObject*>(releaser)) ==\n      -1) {\n    Py_DECREF(releaser);\n    return errors::Unknown(\"Python array refused to use memory.\");\n  }\n  *result = reinterpret_cast<PyObject*>(np_array);\n  return OkStatus();\n}", "target": 0}
{"code": "static int komeda_wb_connector_add(struct komeda_kms_dev *kms,\n\t\t\t\t   struct komeda_crtc *kcrtc)\n{\n\tstruct komeda_dev *mdev = kms->base.dev_private;\n\tstruct komeda_wb_connector *kwb_conn;\n\tstruct drm_writeback_connector *wb_conn;\n\tu32 *formats, n_formats = 0;\n\tint err;\n\tif (!kcrtc->master->wb_layer)\n\t\treturn 0;\n\tkwb_conn = kzalloc(sizeof(*kwb_conn), GFP_KERNEL);\n\tif (!kwb_conn)\n\t\treturn -ENOMEM;\n\tkwb_conn->wb_layer = kcrtc->master->wb_layer;\n\twb_conn = &kwb_conn->base;\n\twb_conn->encoder.possible_crtcs = BIT(drm_crtc_index(&kcrtc->base));\n\tformats = komeda_get_layer_fourcc_list(&mdev->fmt_tbl,\n\t\t\t\t\t       kwb_conn->wb_layer->layer_type,\n\t\t\t\t\t       &n_formats);\n\terr = drm_writeback_connector_init(&kms->base, wb_conn,\n\t\t\t\t\t   &komeda_wb_connector_funcs,\n\t\t\t\t\t   &komeda_wb_encoder_helper_funcs,\n\t\t\t\t\t   formats, n_formats);\n\tkomeda_put_fourcc_list(formats);\n\tif (err)\n\t\treturn err;\n\tdrm_connector_helper_add(&wb_conn->base, &komeda_wb_conn_helper_funcs);\n\tkcrtc->wb_conn = kwb_conn;\n\treturn 0;\n}", "target": 1}
{"code": "\t__releases(&keyring_serialise_link_sem)\n{\n\tBUG_ON(index_key->type == NULL);\n\tkenter(\"%d,%s,\", keyring->serial, index_key->type->name);\n\tif (index_key->type == &key_type_keyring)\n\t\tup_write(&keyring_serialise_link_sem);\n\tif (edit && !edit->dead_leaf) {\n\t\tkey_payload_reserve(keyring,\n\t\t\t\t    keyring->datalen - KEYQUOTA_LINK_BYTES);\n\t\tassoc_array_cancel_edit(edit);\n\t}\n\tup_write(&keyring->sem);\n}", "target": 1}
{"code": "FILE *mingw_fopen (const char *filename, const char *otype)\n{\n\tint hide = needs_hiding(filename);\n\tFILE *file;\n\twchar_t wfilename[MAX_PATH], wotype[4];\n\tif (filename && !strcmp(filename, \"/dev/null\"))\n\t\tfilename = \"nul\";\n\tif (xutftowcs_path(wfilename, filename) < 0 ||\n\t\txutftowcs(wotype, otype, ARRAY_SIZE(wotype)) < 0)\n\t\treturn NULL;\n\tif (hide && !access(filename, F_OK) && set_hidden_flag(wfilename, 0)) {\n\t\terror(\"could not unhide %s\", filename);\n\t\treturn NULL;\n\t}\n\tfile = _wfopen(wfilename, wotype);\n\tif (!file && GetLastError() == ERROR_INVALID_NAME)\n\t\terrno = ENOENT;\n\tif (file && hide && set_hidden_flag(wfilename, 1))\n\t\twarning(\"could not mark '%s' as hidden.\", filename);\n\treturn file;\n}", "target": 0}
{"code": "bool PDFDoc::setup(const GooString *ownerPassword, const GooString *userPassword) {\n  pdfdocLocker();\n  if (str->getLength() <= 0)\n  {\n    error(errSyntaxError, -1, \"Document stream is empty\");\n    return false;\n  }\n  str->setPos(0, -1);\n  if (str->getPos() < 0)\n  {\n    error(errSyntaxError, -1, \"Document base stream is not seekable\");\n    return false;\n  }\n  str->reset();\n  checkHeader();\n  bool wasReconstructed = false;\n  xref = new XRef(str, getStartXRef(), getMainXRefEntriesOffset(), &wasReconstructed);\n  if (!xref->isOk()) {\n    if (wasReconstructed) {\n      delete xref;\n      startXRefPos = -1;\n      xref = new XRef(str, getStartXRef(true), getMainXRefEntriesOffset(true), &wasReconstructed);\n    }\n    if (!xref->isOk()) {\n      error(errSyntaxError, -1, \"Couldn't read xref table\");\n      errCode = xref->getErrorCode();\n      return false;\n    }\n  }\n  if (!checkEncryption(ownerPassword, userPassword)) {\n    errCode = errEncrypted;\n    return false;\n  }\n  catalog = new Catalog(this);\n  if (catalog && !catalog->isOk()) {\n    if (!wasReconstructed)\n    {\n      delete catalog;\n      delete xref;\n      xref = new XRef(str, 0, 0, nullptr, true);\n      catalog = new Catalog(this);\n    }\n    if (catalog && !catalog->isOk()) {\n      error(errSyntaxError, -1, \"Couldn't read page catalog\");\n      errCode = errBadCatalog;\n      return false;\n    }\n  }\n  extractPDFSubtype();\n  return xref->isOk();\n}", "target": 1}
{"code": "Map1to1(SDL_Palette * src, SDL_Palette * dst, int *identical)\n{\n    Uint8 *map;\n    int i;\n    if (identical) {\n        if (src->ncolors <= dst->ncolors) {\n            if (src == dst\n                ||\n                (SDL_memcmp\n                 (src->colors, dst->colors,\n                  src->ncolors * sizeof(SDL_Color)) == 0)) {\n                *identical = 1;\n                return (NULL);\n            }\n        }\n        *identical = 0;\n    }\n    map = (Uint8 *) SDL_malloc(src->ncolors);\n    if (map == NULL) {\n        SDL_OutOfMemory();\n        return (NULL);\n    }\n    for (i = 0; i < src->ncolors; ++i) {\n        map[i] = SDL_FindColor(dst,\n                               src->colors[i].r, src->colors[i].g,\n                               src->colors[i].b, src->colors[i].a);\n    }\n    return (map);\n}", "target": 1}
{"code": "    virtual AP4_Result WritePartial(const void* buffer,\n                                    AP4_Size    bytes_to_write, \n                                    AP4_Size&   bytes_written) {\n        AP4_UI08* out = new AP4_UI08[bytes_to_write+16];\n        AP4_Size  out_size = bytes_to_write+16;\n        AP4_Result result = m_StreamCipher->ProcessBuffer((const AP4_UI08*)buffer,\n                                                          bytes_to_write,\n                                                          out,\n                                                          &out_size);\n        if (AP4_SUCCEEDED(result)) {\n            result = m_Output->Write(out, out_size);\n            bytes_written = bytes_to_write;\n            m_Size       += bytes_to_write;\n        } else {\n            bytes_written = 0;\n        }\n        delete[] out;\n        return result;\n    }", "target": 0}
{"code": "int NETSCAPE_SPKI_print(BIO *out, NETSCAPE_SPKI *spki)\n{\n    EVP_PKEY *pkey;\n    ASN1_IA5STRING *chal;\n    ASN1_OBJECT *spkioid;\n    int i, n;\n    char *s;\n    BIO_printf(out, \"Netscape SPKI:\\n\");\n    X509_PUBKEY_get0_param(&spkioid, NULL, NULL, NULL, spki->spkac->pubkey);\n    i = OBJ_obj2nid(spkioid);\n    BIO_printf(out, \"  Public Key Algorithm: %s\\n\",\n               (i == NID_undef) ? \"UNKNOWN\" : OBJ_nid2ln(i));\n    pkey = X509_PUBKEY_get(spki->spkac->pubkey);\n    if (!pkey)\n        BIO_printf(out, \"  Unable to load public key\\n\");\n    else {\n        EVP_PKEY_print_public(out, pkey, 4, NULL);\n        EVP_PKEY_free(pkey);\n    }\n    chal = spki->spkac->challenge;\n    if (chal->length)\n        BIO_printf(out, \"  Challenge String: %s\\n\", chal->data);\n    i = OBJ_obj2nid(spki->sig_algor.algorithm);\n    BIO_printf(out, \"  Signature Algorithm: %s\",\n               (i == NID_undef) ? \"UNKNOWN\" : OBJ_nid2ln(i));\n    n = spki->signature->length;\n    s = (char *)spki->signature->data;\n    for (i = 0; i < n; i++) {\n        if ((i % 18) == 0)\n            BIO_write(out, \"\\n      \", 7);\n        BIO_printf(out, \"%02x%s\", (unsigned char)s[i],\n                   ((i + 1) == n) ? \"\" : \":\");\n    }\n    BIO_write(out, \"\\n\", 1);\n    return 1;\n}", "target": 1}
{"code": "static JSON_INLINE size_t num_buckets(hashtable_t *hashtable)\n{\n    return primes[hashtable->num_buckets];\n}", "target": 1}
{"code": "init_ctx_new(OM_uint32 *minor_status,\n\t     spnego_gss_cred_id_t spcred,\n\t     gss_ctx_id_t *ctx,\n\t     send_token_flag *tokflag)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = NULL;\n\tsc = create_spnego_ctx();\n\tif (sc == NULL)\n\t\treturn GSS_S_FAILURE;\n\tret = get_negotiable_mechs(minor_status, spcred, GSS_C_INITIATE,\n\t\t\t\t   &sc->mech_set);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\tsc->internal_mech = &sc->mech_set->elements[0];\n\tif (put_mech_set(sc->mech_set, &sc->DER_mechTypes) < 0) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tsc->ctx_handle = GSS_C_NO_CONTEXT;\n\t*ctx = (gss_ctx_id_t)sc;\n\tsc = NULL;\n\t*tokflag = INIT_TOKEN_SEND;\n\tret = GSS_S_CONTINUE_NEEDED;\ncleanup:\n\trelease_spnego_ctx(&sc);\n\treturn ret;\n}", "target": 1}
{"code": "static ssize_t ppp_read(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct ppp_file *pf = file->private_data;\n\tDECLARE_WAITQUEUE(wait, current);\n\tssize_t ret;\n\tstruct sk_buff *skb = NULL;\n\tstruct iovec iov;\n\tstruct iov_iter to;\n\tret = count;\n\tif (!pf)\n\t\treturn -ENXIO;\n\tadd_wait_queue(&pf->rwait, &wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tskb = skb_dequeue(&pf->rq);\n\t\tif (skb)\n\t\t\tbreak;\n\t\tret = 0;\n\t\tif (pf->dead)\n\t\t\tbreak;\n\t\tif (pf->kind == INTERFACE) {\n\t\t\tstruct ppp *ppp = PF_TO_PPP(pf);\n\t\t\tif (ppp->n_channels == 0 &&\n\t\t\t    (ppp->flags & SC_LOOP_TRAFFIC) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = -EAGAIN;\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\tbreak;\n\t\tret = -ERESTARTSYS;\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\tschedule();\n\t}\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(&pf->rwait, &wait);\n\tif (!skb)\n\t\tgoto out;\n\tret = -EOVERFLOW;\n\tif (skb->len > count)\n\t\tgoto outf;\n\tret = -EFAULT;\n\tiov.iov_base = buf;\n\tiov.iov_len = count;\n\tiov_iter_init(&to, READ, &iov, 1, count);\n\tif (skb_copy_datagram_iter(skb, 0, &to, skb->len))\n\t\tgoto outf;\n\tret = skb->len;\n outf:\n\tkfree_skb(skb);\n out:\n\treturn ret;\n}", "target": 0}
{"code": "cmnd_matches_all(const struct sudoers_parse_tree *parse_tree,\n    const struct member *m, const char *runchroot, struct cmnd_info *info)\n{\n    const bool negated = m->negated;\n    struct sudo_command *c;\n    int matched = UNSPEC;\n    struct alias *a;\n    debug_decl(cmnd_matches_all, SUDOERS_DEBUG_MATCH);\n    switch (m->type) {\n\tcase ALL:\n\t    c = (struct sudo_command *)m->name;\n\t    if (command_matches(parse_tree->ctx, c->cmnd, c->args, runchroot,\n\t\t    info, &c->digests))\n\t\tmatched = negated ? DENY : ALLOW;\n\t    break;\n\tcase ALIAS:\n\t    a = alias_get(parse_tree, m->name, CMNDALIAS);\n\t    if (a != NULL) {\n\t\tTAILQ_FOREACH_REVERSE(m, &a->members, member_list, entries) {\n\t\t    matched = cmnd_matches_all(parse_tree, m, runchroot, info);\n\t\t    if (matched != UNSPEC) {\n\t\t\tif (negated)\n\t\t\t    matched = matched == ALLOW ? DENY : ALLOW;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\talias_put(a);\n\t    }\n\t    break;\n    }\n    debug_return_int(matched);\n}", "target": 1}
{"code": "static void cirrus_invalidate_region(CirrusVGAState * s, int off_begin,\n\t\t\t\t     int off_pitch, int bytesperline,\n\t\t\t\t     int lines)\n{\n    int y;\n    int off_cur;\n    int off_cur_end;\n    for (y = 0; y < lines; y++) {\n\toff_cur = off_begin;\n\toff_cur_end = off_cur + bytesperline;\n\toff_cur &= TARGET_PAGE_MASK;\n\twhile (off_cur < off_cur_end) {\n\t    cpu_physical_memory_set_dirty(s->vram_offset + off_cur);\n\t    off_cur += TARGET_PAGE_SIZE;\n\t}\n\toff_begin += off_pitch;\n    }\n}", "target": 1}
{"code": "int hfsplus_find_cat(struct super_block *sb, u32 cnid,\n\t\t     struct hfs_find_data *fd)\n{\n\thfsplus_cat_entry tmp;\n\tint err;\n\tu16 type;\n\thfsplus_cat_build_key(sb, fd->search_key, cnid, NULL);\n\terr = hfs_brec_read(fd, &tmp, sizeof(hfsplus_cat_entry));\n\tif (err)\n\t\treturn err;\n\ttype = be16_to_cpu(tmp.type);\n\tif (type != HFSPLUS_FOLDER_THREAD && type != HFSPLUS_FILE_THREAD) {\n\t\tprintk(KERN_ERR \"hfs: found bad thread record in catalog\\n\");\n\t\treturn -EIO;\n\t}\n\thfsplus_cat_build_key_uni(fd->search_key, be32_to_cpu(tmp.thread.parentID),\n\t\t\t\t &tmp.thread.nodeName);\n\treturn hfs_brec_find(fd);\n}", "target": 1}
{"code": "cdf_unpack_header(cdf_header_t *h, char *buf)\n{\n\tsize_t i;\n\tsize_t len = 0;\n\tCDF_UNPACK(h->h_magic);\n\tCDF_UNPACKA(h->h_uuid);\n\tCDF_UNPACK(h->h_revision);\n\tCDF_UNPACK(h->h_version);\n\tCDF_UNPACK(h->h_byte_order);\n\tCDF_UNPACK(h->h_sec_size_p2);\n\tCDF_UNPACK(h->h_short_sec_size_p2);\n\tCDF_UNPACKA(h->h_unused0);\n\tCDF_UNPACK(h->h_num_sectors_in_sat);\n\tCDF_UNPACK(h->h_secid_first_directory);\n\tCDF_UNPACKA(h->h_unused1);\n\tCDF_UNPACK(h->h_min_size_standard_stream);\n\tCDF_UNPACK(h->h_secid_first_sector_in_short_sat);\n\tCDF_UNPACK(h->h_num_sectors_in_short_sat);\n\tCDF_UNPACK(h->h_secid_first_sector_in_master_sat);\n\tCDF_UNPACK(h->h_num_sectors_in_master_sat);\n\tfor (i = 0; i < __arraycount(h->h_master_sat); i++)\n\t\tCDF_UNPACK(h->h_master_sat[i]);\n}", "target": 0}
{"code": "struct request *blk_mq_tag_to_rq(struct blk_mq_tags *tags, unsigned int tag)\n{\n\tstruct request *rq = tags->rqs[tag];\n\tstruct blk_flush_queue *fq = blk_get_flush_queue(rq->q, rq->mq_ctx);\n\tif (!is_flush_request(rq, fq, tag))\n\t\treturn rq;\n\treturn fq->flush_rq;\n}", "target": 1}
{"code": "static void setup_DMA(void)\n{\n\tunsigned long f;\n\tif (raw_cmd->length == 0) {\n\t\tint i;\n\t\tpr_info(\"zero dma transfer size:\");\n\t\tfor (i = 0; i < raw_cmd->cmd_count; i++)\n\t\t\tpr_cont(\"%x,\", raw_cmd->cmd[i]);\n\t\tpr_cont(\"\\n\");\n\t\tcont->done(0);\n\t\tFDCS->reset = 1;\n\t\treturn;\n\t}\n\tif (((unsigned long)raw_cmd->kernel_data) % 512) {\n\t\tpr_info(\"non aligned address: %p\\n\", raw_cmd->kernel_data);\n\t\tcont->done(0);\n\t\tFDCS->reset = 1;\n\t\treturn;\n\t}\n\tf = claim_dma_lock();\n\tfd_disable_dma();\n#ifdef fd_dma_setup\n\tif (fd_dma_setup(raw_cmd->kernel_data, raw_cmd->length,\n\t\t\t (raw_cmd->flags & FD_RAW_READ) ?\n\t\t\t DMA_MODE_READ : DMA_MODE_WRITE, FDCS->address) < 0) {\n\t\trelease_dma_lock(f);\n\t\tcont->done(0);\n\t\tFDCS->reset = 1;\n\t\treturn;\n\t}\n\trelease_dma_lock(f);\n#else\n\tfd_clear_dma_ff();\n\tfd_cacheflush(raw_cmd->kernel_data, raw_cmd->length);\n\tfd_set_dma_mode((raw_cmd->flags & FD_RAW_READ) ?\n\t\t\tDMA_MODE_READ : DMA_MODE_WRITE);\n\tfd_set_dma_addr(raw_cmd->kernel_data);\n\tfd_set_dma_count(raw_cmd->length);\n\tvirtual_dma_port = FDCS->address;\n\tfd_enable_dma();\n\trelease_dma_lock(f);\n#endif\n}", "target": 0}
{"code": "static inline bool spectre_v2_in_ibrs_mode(enum spectre_v2_mitigation mode)\n{\n\treturn mode == SPECTRE_V2_IBRS ||\n\t       mode == SPECTRE_V2_EIBRS ||\n\t       mode == SPECTRE_V2_EIBRS_RETPOLINE ||\n\t       mode == SPECTRE_V2_EIBRS_LFENCE;\n}", "target": 1}
{"code": "static void __spin_time_accum(u64 delta, u32 *array)\n{\n\tunsigned index;\n\tindex = ilog2(delta);\n\tcheck_zero();\n\tif (index < HISTO_BUCKETS)\n\t\tarray[index]++;\n\telse\n\t\tarray[HISTO_BUCKETS]++;\n}", "target": 0}
{"code": "static u32 rd_release_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,\n\t\t\t\t u32 sg_table_count)\n{\n\tstruct page *pg;\n\tstruct scatterlist *sg;\n\tu32 i, j, page_count = 0, sg_per_table;\n\tfor (i = 0; i < sg_table_count; i++) {\n\t\tsg = sg_table[i].sg_table;\n\t\tsg_per_table = sg_table[i].rd_sg_count;\n\t\tfor (j = 0; j < sg_per_table; j++) {\n\t\t\tpg = sg_page(&sg[j]);\n\t\t\tif (pg) {\n\t\t\t\t__free_page(pg);\n\t\t\t\tpage_count++;\n\t\t\t}\n\t\t}\n\t\tkfree(sg);\n\t}\n\tkfree(sg_table);\n\treturn page_count;\n}", "target": 0}
{"code": "int st21nfca_connectivity_event_received(struct nfc_hci_dev *hdev, u8 host,\n\t\t\t\tu8 event, struct sk_buff *skb)\n{\n\tint r = 0;\n\tstruct device *dev = &hdev->ndev->dev;\n\tstruct nfc_evt_transaction *transaction;\n\tpr_debug(\"connectivity gate event: %x\\n\", event);\n\tswitch (event) {\n\tcase ST21NFCA_EVT_CONNECTIVITY:\n\t\tr = nfc_se_connectivity(hdev->ndev, host);\n\tbreak;\n\tcase ST21NFCA_EVT_TRANSACTION:\n\t\tif (skb->len < NFC_MIN_AID_LENGTH + 2 &&\n\t\t    skb->data[0] != NFC_EVT_TRANSACTION_AID_TAG)\n\t\t\treturn -EPROTO;\n\t\ttransaction = devm_kzalloc(dev, skb->len - 2, GFP_KERNEL);\n\t\tif (!transaction)\n\t\t\treturn -ENOMEM;\n\t\ttransaction->aid_len = skb->data[1];\n\t\tif (transaction->aid_len > sizeof(transaction->aid))\n\t\t\treturn -EINVAL;\n\t\tmemcpy(transaction->aid, &skb->data[2],\n\t\t       transaction->aid_len);\n\t\tif (skb->data[transaction->aid_len + 2] !=\n\t\t    NFC_EVT_TRANSACTION_PARAMS_TAG)\n\t\t\treturn -EPROTO;\n\t\ttransaction->params_len = skb->data[transaction->aid_len + 3];\n\t\tif (transaction->params_len > ((skb->len - 2) - sizeof(struct nfc_evt_transaction)))\n\t\t\treturn -EINVAL;\n\t\tmemcpy(transaction->params, skb->data +\n\t\t       transaction->aid_len + 4, transaction->params_len);\n\t\tr = nfc_se_transaction(hdev->ndev, host, transaction);\n\tbreak;\n\tdefault:\n\t\tnfc_err(&hdev->ndev->dev, \"Unexpected event on connectivity gate\\n\");\n\t\treturn 1;\n\t}\n\tkfree_skb(skb);\n\treturn r;\n}", "target": 0}
{"code": "static void ldapsrv_process_call_trigger(struct tevent_req *req,\n\t\t\t\t\t void *private_data)\n{\n\tstruct ldapsrv_process_call_state *state =\n\t\ttevent_req_data(req,\n\t\tstruct ldapsrv_process_call_state);\n\tstruct ldapsrv_connection *conn = state->call->conn;\n\tNTSTATUS status;\n\tif (conn->deferred_expire_disconnect != NULL) {\n\t\ttevent_req_done(req);\n\t\treturn;\n\t}\n\tstatus = ldapsrv_do_call(state->call);\n\tif (NT_STATUS_EQUAL(status, NT_STATUS_NETWORK_SESSION_EXPIRED)) {\n\t\tint defer_msec = lpcfg_parm_int(\n\t\t\tconn->lp_ctx,\n\t\t\tNULL,\n\t\t\t\"ldap_server\",\n\t\t\t\"delay_expire_disconnect\",\n\t\t\t0);\n\t\tconn->deferred_expire_disconnect = tevent_wakeup_send(\n\t\t\tconn,\n\t\t\tconn->connection->event.ctx,\n\t\t\ttimeval_current_ofs_msec(defer_msec));\n\t\tif (tevent_req_nomem(conn->deferred_expire_disconnect, req)) {\n\t\t\treturn;\n\t\t}\n\t\ttevent_req_set_callback(\n\t\t\tconn->deferred_expire_disconnect,\n\t\t\tldapsrv_disconnect_ticket_expired,\n\t\t\tconn);\n\t\ttevent_req_done(req);\n\t\treturn;\n\t}\n\tif (!NT_STATUS_IS_OK(status)) {\n\t\ttevent_req_nterror(req, status);\n\t\treturn;\n\t}\n\ttevent_req_done(req);\n}", "target": 0}
{"code": "static int idr_get_empty_slot(struct idr *idp, int starting_id,\n\t\t\t      struct idr_layer **pa)\n{\n\tstruct idr_layer *p, *new;\n\tint layers, v, id;\n\tunsigned long flags;\n\tid = starting_id;\nbuild_up:\n\tp = idp->top;\n\tlayers = idp->layers;\n\tif (unlikely(!p)) {\n\t\tif (!(p = get_from_free_list(idp)))\n\t\t\treturn -1;\n\t\tp->layer = 0;\n\t\tlayers = 1;\n\t}\n\twhile ((layers < (MAX_LEVEL - 1)) && (id >= (1 << (layers*IDR_BITS)))) {\n\t\tlayers++;\n\t\tif (!p->count) {\n\t\t\tp->layer++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!(new = get_from_free_list(idp))) {\n\t\t\tspin_lock_irqsave(&idp->lock, flags);\n\t\t\tfor (new = p; p && p != idp->top; new = p) {\n\t\t\t\tp = p->ary[0];\n\t\t\t\tnew->ary[0] = NULL;\n\t\t\t\tnew->bitmap = new->count = 0;\n\t\t\t\t__move_to_free_list(idp, new);\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&idp->lock, flags);\n\t\t\treturn -1;\n\t\t}\n\t\tnew->ary[0] = p;\n\t\tnew->count = 1;\n\t\tnew->layer = layers-1;\n\t\tif (p->bitmap == IDR_FULL)\n\t\t\t__set_bit(0, &new->bitmap);\n\t\tp = new;\n\t}\n\trcu_assign_pointer(idp->top, p);\n\tidp->layers = layers;\n\tv = sub_alloc(idp, &id, pa);\n\tif (v == IDR_NEED_TO_GROW)\n\t\tgoto build_up;\n\treturn(v);\n}", "target": 0}
{"code": "static inline s16 fixp_mult(s16 a, s16 b)\n{\n\ta = ((s32)a * 0x100) / 0x7fff;\n\treturn ((s32)(a * b)) >> FRAC_N;\n}", "target": 0}
{"code": "static CURLcode transfer_per_config(struct GlobalConfig *global,\n                                    struct OperationConfig *config,\n                                    CURLSH *share,\n                                    bool *added)\n{\n  CURLcode result = CURLE_OK;\n  bool capath_from_env;\n  *added = FALSE;\n  if(!config->url_list || !config->url_list->url) {\n    helpf(global->errors, \"no URL specified!\\n\");\n    return CURLE_FAILED_INIT;\n  }\n  capath_from_env = false;\n  if(!config->cacert &&\n     !config->capath &&\n     (!config->insecure_ok || (config->doh_url && !config->doh_insecure_ok))) {\n    CURL *curltls = curl_easy_init();\n    struct curl_tlssessioninfo *tls_backend_info = NULL;\n    result = curl_easy_getinfo(curltls, CURLINFO_TLS_SSL_PTR,\n                               &tls_backend_info);\n    if(result)\n      return result;\n    if(tls_backend_info->backend != CURLSSLBACKEND_SCHANNEL) {\n      char *env;\n      env = curlx_getenv(\"CURL_CA_BUNDLE\");\n      if(env) {\n        config->cacert = strdup(env);\n        if(!config->cacert) {\n          curl_free(env);\n          errorf(global, \"out of memory\\n\");\n          return CURLE_OUT_OF_MEMORY;\n        }\n      }\n      else {\n        env = curlx_getenv(\"SSL_CERT_DIR\");\n        if(env) {\n          config->capath = strdup(env);\n          if(!config->capath) {\n            curl_free(env);\n            helpf(global->errors, \"out of memory\\n\");\n            return CURLE_OUT_OF_MEMORY;\n          }\n          capath_from_env = true;\n        }\n        else {\n          env = curlx_getenv(\"SSL_CERT_FILE\");\n          if(env) {\n            config->cacert = strdup(env);\n            if(!config->cacert) {\n              curl_free(env);\n              errorf(global, \"out of memory\\n\");\n              return CURLE_OUT_OF_MEMORY;\n            }\n          }\n        }\n      }\n      if(env)\n        curl_free(env);\n#ifdef WIN32\n      else {\n        result = FindWin32CACert(config, tls_backend_info->backend,\n                                 TEXT(\"curl-ca-bundle.crt\"));\n      }\n#endif\n    }\n    curl_easy_cleanup(curltls);\n  }\n  if(!result)\n    result = single_transfer(global, config, share, capath_from_env, added);\n  return result;\n}", "target": 0}
{"code": "void ipv4_pktinfo_prepare(const struct sock *sk, struct sk_buff *skb)\n{\n\tstruct in_pktinfo *pktinfo = PKTINFO_SKB_CB(skb);\n\tbool prepare = (inet_sk(sk)->cmsg_flags & IP_CMSG_PKTINFO) ||\n\t\t       ipv6_sk_rxinfo(sk);\n\tif (prepare && skb_rtable(skb)) {\n\t\tif (pktinfo->ipi_ifindex == LOOPBACK_IFINDEX)\n\t\t\tpktinfo->ipi_ifindex = inet_iif(skb);\n\t\tpktinfo->ipi_spec_dst.s_addr = fib_compute_spec_dst(skb);\n\t} else {\n\t\tpktinfo->ipi_ifindex = 0;\n\t\tpktinfo->ipi_spec_dst.s_addr = 0;\n\t}\n\tskb_dst_drop(skb);\n}", "target": 1}
{"code": "isdn_net_force_hangup(char *name)\n{\n\tisdn_net_dev *p = isdn_net_findif(name);\n\tstruct net_device *q;\n\tif (p) {\n\t\tif (p->local->isdn_device < 0)\n\t\t\treturn 1;\n\t\tq = p->local->slave;\n\t\twhile (q) {\n\t\t\tisdn_net_hangup(q);\n\t\t\tq = MASTER_TO_SLAVE(q);\n\t\t}\n\t\tisdn_net_hangup(p->dev);\n\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}", "target": 0}
{"code": "static void unix_release_sock(struct sock *sk, int embrion)\n{\n\tstruct unix_sock *u = unix_sk(sk);\n\tstruct path path;\n\tstruct sock *skpair;\n\tstruct sk_buff *skb;\n\tint state;\n\tunix_remove_socket(sk);\n\tunix_state_lock(sk);\n\tsock_orphan(sk);\n\tsk->sk_shutdown = SHUTDOWN_MASK;\n\tpath\t     = u->path;\n\tu->path.dentry = NULL;\n\tu->path.mnt = NULL;\n\tstate = sk->sk_state;\n\tsk->sk_state = TCP_CLOSE;\n\tunix_state_unlock(sk);\n\twake_up_interruptible_all(&u->peer_wait);\n\tskpair = unix_peer(sk);\n\tif (skpair != NULL) {\n\t\tif (sk->sk_type == SOCK_STREAM || sk->sk_type == SOCK_SEQPACKET) {\n\t\t\tunix_state_lock(skpair);\n\t\t\tskpair->sk_shutdown = SHUTDOWN_MASK;\n\t\t\tif (!skb_queue_empty(&sk->sk_receive_queue) || embrion)\n\t\t\t\tskpair->sk_err = ECONNRESET;\n\t\t\tunix_state_unlock(skpair);\n\t\t\tskpair->sk_state_change(skpair);\n\t\t\tsk_wake_async(skpair, SOCK_WAKE_WAITD, POLL_HUP);\n\t\t}\n\t\tunix_dgram_peer_wake_disconnect(sk, skpair);\n\t\tsock_put(skpair); \n\t\tunix_peer(sk) = NULL;\n\t}\n\twhile ((skb = skb_dequeue(&sk->sk_receive_queue)) != NULL) {\n\t\tif (state == TCP_LISTEN)\n\t\t\tunix_release_sock(skb->sk, 1);\n\t\tUNIXCB(skb).consumed = skb->len;\n\t\tkfree_skb(skb);\n\t}\n\tif (path.dentry)\n\t\tpath_put(&path);\n\tsock_put(sk);\n\tif (unix_tot_inflight)\n\t\tunix_gc();\t\t\n}", "target": 0}
{"code": "static int decode_font(ASS_Track *track)\n{\n    unsigned char *p;\n    unsigned char *q;\n    size_t i;\n    size_t size;                   \n    size_t dsize;                  \n    unsigned char *buf = 0;\n    ass_msg(track->library, MSGL_V, \"Font: %d bytes encoded data\",\n            track->parser_priv->fontdata_used);\n    size = track->parser_priv->fontdata_used;\n    if (size % 4 == 1) {\n        ass_msg(track->library, MSGL_ERR, \"Bad encoded data size\");\n        goto error_decode_font;\n    }\n    buf = malloc(size / 4 * 3 + FFMAX(size % 4 - 1, 0));\n    if (!buf)\n        goto error_decode_font;\n    q = buf;\n    for (i = 0, p = (unsigned char *) track->parser_priv->fontdata;\n         i < size / 4; i++, p += 4) {\n        q = decode_chars(p, q, 4);\n    }\n    if (size % 4 == 2) {\n        q = decode_chars(p, q, 2);\n    } else if (size % 4 == 3) {\n        q = decode_chars(p, q, 3);\n    }\n    dsize = q - buf;\n    assert(dsize == size / 4 * 3 + FFMAX(size % 4 - 1, 0));\n    if (track->library->extract_fonts) {\n        ass_add_font(track->library, track->parser_priv->fontname,\n                     (char *) buf, dsize);\n    }\nerror_decode_font:\n    free(buf);\n    reset_embedded_font_parsing(track->parser_priv);\n    return 0;\n}", "target": 1}
{"code": "static ssize_t aio_setup_vectored_rw(struct kiocb *kiocb,\n\t\t\t\t     int rw, char __user *buf,\n\t\t\t\t     unsigned long *nr_segs,\n\t\t\t\t     size_t *len,\n\t\t\t\t     struct iovec **iovec,\n\t\t\t\t     bool compat)\n{\n\tssize_t ret;\n\t*nr_segs = *len;\n#ifdef CONFIG_COMPAT\n\tif (compat)\n\t\tret = compat_rw_copy_check_uvector(rw,\n\t\t\t\t(struct compat_iovec __user *)buf,\n\t\t\t\t*nr_segs, UIO_FASTIOV, *iovec, iovec);\n\telse\n#endif\n\t\tret = rw_copy_check_uvector(rw,\n\t\t\t\t(struct iovec __user *)buf,\n\t\t\t\t*nr_segs, UIO_FASTIOV, *iovec, iovec);\n\tif (ret < 0)\n\t\treturn ret;\n\t*len = ret;\n\treturn 0;\n}", "target": 1}
{"code": "FramebufferModel::~FramebufferModel()\n{\n    delete[] m_pixelBuffer;\n}", "target": 1}
{"code": "    OVS_REQUIRES(ofproto_mutex)\n{\n    const struct rule_actions *actions = rule_get_actions(rule);\n    ovs_assert(rule->state == RULE_INITIALIZED);\n    if (rule->hard_timeout || rule->idle_timeout) {\n        ovs_list_insert(&ofproto->expirable, &rule->expirable);\n    }\n    cookies_insert(ofproto, rule);\n    eviction_group_add_rule(rule);\n    if (actions->has_meter) {\n        meter_insert_rule(rule);\n    }\n    if (actions->has_groups) {\n        const struct ofpact_group *a;\n        OFPACT_FOR_EACH_TYPE_FLATTENED (a, GROUP, actions->ofpacts,\n                                        actions->ofpacts_len) {\n            struct ofgroup *group;\n            group = ofproto_group_lookup(ofproto, a->group_id, OVS_VERSION_MAX,\n                                         false);\n            ovs_assert(group != NULL);\n            group_add_rule(group, rule);\n        }\n    }\n    rule->state = RULE_INSERTED;\n}", "target": 1}
{"code": "jas_iccprof_t *jas_iccprof_createfrombuf(uchar *buf, int len)\n{\n\tjas_stream_t *in;\n\tjas_iccprof_t *prof;\n\tif (!(in = jas_stream_memopen(JAS_CAST(char *, buf), len)))\n\t\tgoto error;\n\tif (!(prof = jas_iccprof_load(in)))\n\t\tgoto error;\n\tjas_stream_close(in);\n\treturn prof;\nerror:\n\treturn 0;\n}", "target": 1}
{"code": "static int check_cert(X509_STORE_CTX *ctx)\n{\n    X509_CRL *crl = NULL, *dcrl = NULL;\n    X509 *x = NULL;\n    int ok = 0, cnum = 0;\n    unsigned int last_reasons = 0;\n    cnum = ctx->error_depth;\n    x = sk_X509_value(ctx->chain, cnum);\n    ctx->current_cert = x;\n    ctx->current_issuer = NULL;\n    ctx->current_crl_score = 0;\n    ctx->current_reasons = 0;\n    while (ctx->current_reasons != CRLDP_ALL_REASONS) {\n        last_reasons = ctx->current_reasons;\n        if (ctx->get_crl)\n            ok = ctx->get_crl(ctx, &crl, x);\n        else\n            ok = get_crl_delta(ctx, &crl, &dcrl, x);\n        if (!ok) {\n            ctx->error = X509_V_ERR_UNABLE_TO_GET_CRL;\n            ok = ctx->verify_cb(0, ctx);\n            goto err;\n        }\n        ctx->current_crl = crl;\n        ok = ctx->check_crl(ctx, crl);\n        if (!ok)\n            goto err;\n        if (dcrl) {\n            ok = ctx->check_crl(ctx, dcrl);\n            if (!ok)\n                goto err;\n            ok = ctx->cert_crl(ctx, dcrl, x);\n            if (!ok)\n                goto err;\n        } else\n            ok = 1;\n        if (ok != 2) {\n            ok = ctx->cert_crl(ctx, crl, x);\n            if (!ok)\n                goto err;\n        }\n        X509_CRL_free(crl);\n        X509_CRL_free(dcrl);\n        crl = NULL;\n        dcrl = NULL;\n        if (last_reasons == ctx->current_reasons) {\n            ctx->error = X509_V_ERR_UNABLE_TO_GET_CRL;\n            ok = ctx->verify_cb(0, ctx);\n            goto err;\n        }\n    }\n err:\n    X509_CRL_free(crl);\n    X509_CRL_free(dcrl);\n    ctx->current_crl = NULL;\n    return ok;\n}", "target": 0}
{"code": "jiffies_to_timespec(const unsigned long jiffies, struct timespec *value)\n{\n\tu64 nsec = (u64)jiffies * TICK_NSEC;\n\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &value->tv_nsec);\n}", "target": 1}
{"code": "static int ip_setup_cork(struct sock *sk, struct inet_cork *cork,\n\t\t\t struct ipcm_cookie *ipc, struct rtable **rtp)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_options *opt;\n\tstruct rtable *rt;\n\topt = ipc->opt;\n\tif (opt) {\n\t\tif (cork->opt == NULL) {\n\t\t\tcork->opt = kmalloc(sizeof(struct ip_options) + 40,\n\t\t\t\t\t    sk->sk_allocation);\n\t\t\tif (unlikely(cork->opt == NULL))\n\t\t\t\treturn -ENOBUFS;\n\t\t}\n\t\tmemcpy(cork->opt, opt, sizeof(struct ip_options) + opt->optlen);\n\t\tcork->flags |= IPCORK_OPT;\n\t\tcork->addr = ipc->addr;\n\t}\n\trt = *rtp;\n\tif (unlikely(!rt))\n\t\treturn -EFAULT;\n\t*rtp = NULL;\n\tcork->fragsize = inet->pmtudisc == IP_PMTUDISC_PROBE ?\n\t\t\t rt->dst.dev->mtu : dst_mtu(rt->dst.path);\n\tcork->dst = &rt->dst;\n\tcork->length = 0;\n\tcork->tx_flags = ipc->tx_flags;\n\tcork->page = NULL;\n\tcork->off = 0;\n\treturn 0;\n}", "target": 1}
{"code": "static void domain_exit(struct dmar_domain *domain)\n{\n\tstruct page *freelist = NULL;\n\tif (!domain)\n\t\treturn;\n\trcu_read_lock();\n\tdomain_remove_dev_info(domain);\n\trcu_read_unlock();\n\tput_iova_domain(&domain->iovad);\n\tfreelist = domain_unmap(domain, 0, DOMAIN_MAX_PFN(domain->gaw));\n\tdma_free_pagelist(freelist);\n\tfree_domain_mem(domain);\n}", "target": 0}
{"code": "int compat_ipv6_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t   char __user *optval, int __user *optlen)\n{\n\tint err;\n\tif (level == SOL_IP && sk->sk_type != SOCK_RAW) {\n\t\tif (udp_prot.compat_getsockopt != NULL)\n\t\t\treturn udp_prot.compat_getsockopt(sk, level, optname,\n\t\t\t\t\t\t\t  optval, optlen);\n\t\treturn udp_prot.getsockopt(sk, level, optname, optval, optlen);\n\t}\n\tif (level != SOL_IPV6)\n\t\treturn -ENOPROTOOPT;\n\tif (optname == MCAST_MSFILTER)\n\t\treturn compat_mc_getsockopt(sk, level, optname, optval, optlen,\n\t\t\tipv6_getsockopt);\n\terr = do_ipv6_getsockopt(sk, level, optname, optval, optlen,\n\t\t\t\t MSG_CMSG_COMPAT);\n#ifdef CONFIG_NETFILTER\n\tif (err == -ENOPROTOOPT && optname != IPV6_2292PKTOPTIONS) {\n\t\tint len;\n\t\tif (get_user(len, optlen))\n\t\t\treturn -EFAULT;\n\t\terr = compat_nf_getsockopt(sk, PF_INET6, optname, optval, &len);\n\t\tif (err >= 0)\n\t\t\terr = put_user(len, optlen);\n\t}\n#endif\n\treturn err;\n}", "target": 0}
{"code": "  PutOperationParams() {}", "target": 0}
{"code": "  CookieHashMethod(const std::string& key, const std::string& path,\n                   const absl::optional<std::chrono::seconds>& ttl, bool terminal,\n                   const CookieAttributeRefVector attributes)\n      : HashMethodImplBase(terminal), key_(key), path_(path), ttl_(ttl), attributes_(attributes) {}", "target": 1}
{"code": "static struct snd_kcontrol *snd_ctl_new(struct snd_kcontrol *control,\n\t\t\t\t\tunsigned int access)\n{\n\tstruct snd_kcontrol *kctl;\n\tunsigned int idx;\n\tif (snd_BUG_ON(!control || !control->count))\n\t\treturn NULL;\n\tif (control->count > MAX_CONTROL_COUNT)\n\t\treturn NULL;\n\tkctl = kzalloc(sizeof(*kctl) + sizeof(struct snd_kcontrol_volatile) * control->count, GFP_KERNEL);\n\tif (kctl == NULL) {\n\t\tpr_err(\"ALSA: Cannot allocate control instance\\n\");\n\t\treturn NULL;\n\t}\n\t*kctl = *control;\n\tfor (idx = 0; idx < kctl->count; idx++)\n\t\tkctl->vd[idx].access = access;\n\treturn kctl;\n}", "target": 0}
{"code": "bool PackLinuxElf32::calls_crt1(Elf32_Rel const *rel, int sz)\n{\n    if (!dynsym || !dynstr) {\n        return false;\n    }\n    for (unsigned relnum= 0; 0 < sz; (sz -= sizeof(Elf32_Rel)), ++rel, ++relnum) {\n        unsigned const symnum = get_te32(&rel->r_info) >> 8;\n        char const *const symnam = get_dynsym_name(symnum, relnum);\n        if (0==strcmp(symnam, \"__libc_start_main\")  \n        ||  0==strcmp(symnam, \"__libc_init\")  \n        ||  0==strcmp(symnam, \"__uClibc_main\")\n        ||  0==strcmp(symnam, \"__uClibc_start_main\"))\n            return true;\n    }\n    return false;\n}", "target": 1}
{"code": "DNSRequest::DNSRequest(DNS* dns, int rid, const std::string &original) : dnsobj(dns)\n{\n\tres = new unsigned char[sizeof(DNSHeader) * 2];\n\t*res = 0;\n\torig = original;\n\tRequestTimeout* RT = new RequestTimeout(ServerInstance->Config->dns_timeout ? ServerInstance->Config->dns_timeout : 5, this, rid);\n\tServerInstance->Timers->AddTimer(RT); \n}", "target": 0}
{"code": "unsigned long ossl_lh_strcasehash(const char *c)\n{\n    unsigned long ret = 0;\n    long n;\n    unsigned long v;\n    int r;\n    if (c == NULL || *c == '\\0')\n        return ret;\n    for (n = 0x100; *c != '\\0'; n += 0x100) {\n        v = n | ossl_tolower(*c);\n        r = (int)((v >> 2) ^ v) & 0x0f;\n        ret = (ret << r) | (unsigned long)((uint64_t)ret >> (32 - r));\n        ret &= 0xFFFFFFFFL;\n        ret ^= v * v;\n        c++;\n    }\n    return (ret >> 16) ^ ret;\n}", "target": 0}
{"code": "static int may_create_in_sticky(struct dentry * const dir,\n\t\t\t\tstruct inode * const inode)\n{\n\tif ((!sysctl_protected_fifos && S_ISFIFO(inode->i_mode)) ||\n\t    (!sysctl_protected_regular && S_ISREG(inode->i_mode)) ||\n\t    likely(!(dir->d_inode->i_mode & S_ISVTX)) ||\n\t    uid_eq(inode->i_uid, dir->d_inode->i_uid) ||\n\t    uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn 0;\n\tif (likely(dir->d_inode->i_mode & 0002) ||\n\t    (dir->d_inode->i_mode & 0020 &&\n\t     ((sysctl_protected_fifos >= 2 && S_ISFIFO(inode->i_mode)) ||\n\t      (sysctl_protected_regular >= 2 && S_ISREG(inode->i_mode))))) {\n\t\tconst char *operation = S_ISFIFO(inode->i_mode) ?\n\t\t\t\t\t\"sticky_create_fifo\" :\n\t\t\t\t\t\"sticky_create_regular\";\n\t\taudit_log_path_denied(AUDIT_ANOM_CREAT, operation);\n\t\treturn -EACCES;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "SPL_METHOD(SplHeap, key)\n{\n\tspl_heap_object *intern = (spl_heap_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\t\t\n\tRETURN_LONG(intern->heap->count - 1);\n}", "target": 0}
{"code": "find_entry_only(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n\tback_txn *txn\n)\n{\n\treturn( find_entry_internal( pb, be, addr, 0, txn, FE_REALLY_INTERNAL ) );\n}", "target": 1}
{"code": "void __refill_cfs_bandwidth_runtime(struct cfs_bandwidth *cfs_b)\n{\n\tu64 now;\n\tif (cfs_b->quota == RUNTIME_INF)\n\t\treturn;\n\tnow = sched_clock_cpu(smp_processor_id());\n\tcfs_b->runtime = cfs_b->quota;\n\tcfs_b->runtime_expires = now + ktime_to_ns(cfs_b->period);\n\tcfs_b->expires_seq++;\n}", "target": 1}
{"code": "write_VD_terminator(struct archive_write *a)\n{\n\tunsigned char *bp;\n\tbp = wb_buffptr(a) -1;\n\tset_VD_bp(bp, VDT_TERMINATOR, 1);\n\tset_unused_field_bp(bp, 8, LOGICAL_BLOCK_SIZE);\n\treturn (wb_consume(a, LOGICAL_BLOCK_SIZE));\n}", "target": 0}
{"code": "static ssize_t ext4_direct_IO(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tsize_t count = iov_iter_count(iter);\n\tloff_t offset = iocb->ki_pos;\n\tssize_t ret;\n#ifdef CONFIG_EXT4_FS_ENCRYPTION\n\tif (ext4_encrypted_inode(inode) && S_ISREG(inode->i_mode))\n\t\treturn 0;\n#endif\n\tif (ext4_should_journal_data(inode))\n\t\treturn 0;\n\tif (ext4_has_inline_data(inode))\n\t\treturn 0;\n\tif (WARN_ON_ONCE(IS_DAX(inode)))\n\t\treturn 0;\n\ttrace_ext4_direct_IO_enter(inode, offset, count, iov_iter_rw(iter));\n\tif (iov_iter_rw(iter) == READ)\n\t\tret = ext4_direct_IO_read(iocb, iter);\n\telse\n\t\tret = ext4_direct_IO_write(iocb, iter);\n\ttrace_ext4_direct_IO_exit(inode, offset, count, iov_iter_rw(iter), ret);\n\treturn ret;\n}", "target": 0}
{"code": "int do_remount_sb(struct super_block *sb, int flags, void *data, int force)\n{\n\tint retval;\n\tint remount_ro;\n\tif (sb->s_writers.frozen != SB_UNFROZEN)\n\t\treturn -EBUSY;\n#ifdef CONFIG_BLOCK\n\tif (!(flags & MS_RDONLY) && bdev_read_only(sb->s_bdev))\n\t\treturn -EACCES;\n#endif\n\tif (flags & MS_RDONLY)\n\t\tacct_auto_close(sb);\n\tshrink_dcache_sb(sb);\n\tsync_filesystem(sb);\n\tremount_ro = (flags & MS_RDONLY) && !(sb->s_flags & MS_RDONLY);\n\tif (remount_ro) {\n\t\tif (force) {\n\t\t\tmark_files_ro(sb);\n\t\t} else {\n\t\t\tretval = sb_prepare_remount_readonly(sb);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t}\n\t}\n\tif (sb->s_op->remount_fs) {\n\t\tretval = sb->s_op->remount_fs(sb, &flags, data);\n\t\tif (retval) {\n\t\t\tif (!force)\n\t\t\t\tgoto cancel_readonly;\n\t\t\tWARN(1, \"forced remount of a %s fs returned %i\\n\",\n\t\t\t     sb->s_type->name, retval);\n\t\t}\n\t}\n\tsb->s_flags = (sb->s_flags & ~MS_RMT_MASK) | (flags & MS_RMT_MASK);\n\tsmp_wmb();\n\tsb->s_readonly_remount = 0;\n\tif (remount_ro && sb->s_bdev)\n\t\tinvalidate_bdev(sb->s_bdev);\n\treturn 0;\ncancel_readonly:\n\tsb->s_readonly_remount = 0;\n\treturn retval;\n}", "target": 1}
{"code": "ieee80211_rx_h_check(struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)rx->skb->data;\n\tif (ieee80211_vif_is_mesh(&rx->sdata->vif))\n\t\treturn ieee80211_rx_mesh_check(rx);\n\tif (unlikely((ieee80211_is_data(hdr->frame_control) ||\n\t\t      ieee80211_is_pspoll(hdr->frame_control)) &&\n\t\t     rx->sdata->vif.type != NL80211_IFTYPE_ADHOC &&\n\t\t     rx->sdata->vif.type != NL80211_IFTYPE_WDS &&\n\t\t     rx->sdata->vif.type != NL80211_IFTYPE_OCB &&\n\t\t     (!rx->sta || !test_sta_flag(rx->sta, WLAN_STA_ASSOC)))) {\n\t\tif (rx->sta && rx->sdata->vif.type == NL80211_IFTYPE_STATION &&\n\t\t    ieee80211_is_data_present(hdr->frame_control)) {\n\t\t\tunsigned int hdrlen;\n\t\t\t__be16 ethertype;\n\t\t\thdrlen = ieee80211_hdrlen(hdr->frame_control);\n\t\t\tif (rx->skb->len < hdrlen + 8)\n\t\t\t\treturn RX_DROP_MONITOR;\n\t\t\tskb_copy_bits(rx->skb, hdrlen + 6, &ethertype, 2);\n\t\t\tif (ethertype == rx->sdata->control_port_protocol)\n\t\t\t\treturn RX_CONTINUE;\n\t\t}\n\t\tif (rx->sdata->vif.type == NL80211_IFTYPE_AP &&\n\t\t    cfg80211_rx_spurious_frame(rx->sdata->dev,\n\t\t\t\t\t       hdr->addr2,\n\t\t\t\t\t       GFP_ATOMIC))\n\t\t\treturn RX_DROP_UNUSABLE;\n\t\treturn RX_DROP_MONITOR;\n\t}\n\treturn RX_CONTINUE;\n}", "target": 0}
{"code": "  static Config::DecodedResourcesWrapper decodeResources(\n      const Protobuf::RepeatedPtrField<envoy::service::discovery::v3::Resource>& resources,\n      const std::string& name_field = \"name\") {\n    Config::DecodedResourcesWrapper decoded_resources;\n    TestOpaqueResourceDecoderImpl<MessageType> resource_decoder(name_field);\n    for (const auto& resource : resources) {\n      decoded_resources.owned_resources_.emplace_back(\n          new Config::DecodedResourceImpl(resource_decoder, resource));\n      decoded_resources.refvec_.emplace_back(*decoded_resources.owned_resources_.back());\n    }\n    return decoded_resources;\n  }", "target": 0}
{"code": "static int virtio_net_tx_waiting_pre_load(void *opaque)\n{\n    struct VirtIONetMigTmp *tmp = opaque;\n    virtio_net_tx_waiting_pre_save(opaque);\n    if (tmp->parent->curr_queues > tmp->parent->max_queues) {\n        error_report(\"virtio-net: curr_queues %x > max_queues %x\",\n            tmp->parent->curr_queues, tmp->parent->max_queues);\n        return -EINVAL;\n    }\n    return 0; \n}", "target": 0}
{"code": "static int dnxhd_write_header(AVCodecContext *avctx, uint8_t *buf)\n{\n    DNXHDEncContext *ctx = avctx->priv_data;\n    static const uint8_t header_prefix[5] = { 0x00,0x00,0x02,0x80,0x01 };\n    memset(buf, 0, 640);\n    memcpy(buf, header_prefix, 5);\n    buf[5] = ctx->interlaced ? ctx->cur_field+2 : 0x01;\n    buf[6] = 0x80; \n    buf[7] = 0xa0; \n    AV_WB16(buf + 0x18, avctx->height>>ctx->interlaced); \n    AV_WB16(buf + 0x1a, avctx->width);  \n    AV_WB16(buf + 0x1d, avctx->height>>ctx->interlaced); \n    buf[0x21] = ctx->cid_table->bit_depth == 10 ? 0x58 : 0x38;\n    buf[0x22] = 0x88 + (ctx->interlaced<<2);\n    AV_WB32(buf + 0x28, ctx->cid); \n    buf[0x2c] = ctx->interlaced ? 0 : 0x80;\n    buf[0x5f] = 0x01; \n    buf[0x167] = 0x02; \n    AV_WB16(buf + 0x16a, ctx->m.mb_height * 4 + 4); \n    buf[0x16d] = ctx->m.mb_height; \n    buf[0x16f] = 0x10; \n    ctx->msip = buf + 0x170;\n    return 0;\n}", "target": 0}
{"code": "    void CiffDirectory::readDirectory(const byte* pData,\n                                      uint32_t    size,\n                                      ByteOrder   byteOrder)\n    {\n        if (size < 4)\n            throw Error(kerCorruptedMetadata);\n        uint32_t o = getULong(pData + size - 4, byteOrder);\n        if ( o+2 > size )\n            throw Error(kerCorruptedMetadata);\n        uint16_t count = getUShort(pData + o, byteOrder);\n#ifdef DEBUG\n        std::cout << \"Directory at offset \" << std::dec << o\n                  <<\", \" << count << \" entries \\n\";\n#endif\n        o += 2;\n        if ( (o + (count * 10)) > size )\n            throw Error(kerCorruptedMetadata);\n        for (uint16_t i = 0; i < count; ++i) {\n            uint16_t tag = getUShort(pData + o, byteOrder);\n            CiffComponent::AutoPtr m;\n            switch (CiffComponent::typeId(tag)) {\n            case directory: m = CiffComponent::AutoPtr(new CiffDirectory); break;\n            default: m = CiffComponent::AutoPtr(new CiffEntry); break;\n            }\n            m->setDir(this->tag());\n            m->read(pData, size, o, byteOrder);\n            add(m);\n            o += 10;\n        }\n    }  ", "target": 1}
{"code": "static int crypto_rng_init_tfm(struct crypto_tfm *tfm)\n{\n\tstruct crypto_rng *rng = __crypto_rng_cast(tfm);\n\tstruct rng_alg *alg = crypto_rng_alg(rng);\n\tstruct old_rng_alg *oalg = crypto_old_rng_alg(rng);\n\tif (oalg->rng_make_random) {\n\t\trng->generate = generate;\n\t\trng->seed = rngapi_reset;\n\t\trng->seedsize = oalg->seedsize;\n\t\treturn 0;\n\t}\n\trng->generate = alg->generate;\n\trng->seed = alg->seed;\n\trng->seedsize = alg->seedsize;\n\treturn 0;\n}", "target": 1}
{"code": "util_write_callback(int flags, char *ptr, size_t size, size_t nmemb, void *stream)\n{\n    CurlObject *self;\n    PyObject *arglist;\n    PyObject *result = NULL;\n    size_t ret = 0;     \n    PyObject *cb;\n    int total_size;\n    PYCURL_DECLARE_THREAD_STATE;\n    self = (CurlObject *)stream;\n    if (!PYCURL_ACQUIRE_THREAD())\n        return ret;\n    cb = flags ? self->h_cb : self->w_cb;\n    if (cb == NULL)\n        goto silent_error;\n    if (size <= 0 || nmemb <= 0)\n        goto done;\n    total_size = (int)(size * nmemb);\n    if (total_size < 0 || (size_t)total_size / size != nmemb) {\n        PyErr_SetString(ErrorObject, \"integer overflow in write callback\");\n        goto verbose_error;\n    }\n#if PY_MAJOR_VERSION >= 3\n    arglist = Py_BuildValue(\"(y#)\", ptr, total_size);\n#else\n    arglist = Py_BuildValue(\"(s#)\", ptr, total_size);\n#endif\n    if (arglist == NULL)\n        goto verbose_error;\n    result = PyEval_CallObject(cb, arglist);\n    Py_DECREF(arglist);\n    if (result == NULL)\n        goto verbose_error;\n    if (result == Py_None) {\n        ret = total_size;           \n    }\n    else if (PyInt_Check(result) || PyLong_Check(result)) {\n        ret = (size_t) PyLong_AsLong(result);\n    }\n    else {\n        PyErr_SetString(ErrorObject, \"write callback must return int or None\");\n        goto verbose_error;\n    }\ndone:\nsilent_error:\n    Py_XDECREF(result);\n    PYCURL_RELEASE_THREAD();\n    return ret;\nverbose_error:\n    PyErr_Print();\n    goto silent_error;\n}", "target": 0}
{"code": "BufferedRandomDevice::BufferedRandomDevice(size_t bufferSize)\n  : bufferSize_(bufferSize),\n    buffer_(new unsigned char[bufferSize]),\n    ptr_(buffer_.get() + bufferSize) {  \n}", "target": 1}
{"code": "static int dsa_pub_decode(EVP_PKEY *pkey, X509_PUBKEY *pubkey)\n{\n    const unsigned char *p, *pm;\n    int pklen, pmlen;\n    int ptype;\n    void *pval;\n    ASN1_STRING *pstr;\n    X509_ALGOR *palg;\n    ASN1_INTEGER *public_key = NULL;\n    DSA *dsa = NULL;\n    if (!X509_PUBKEY_get0_param(NULL, &p, &pklen, &palg, pubkey))\n        return 0;\n    X509_ALGOR_get0(NULL, &ptype, &pval, palg);\n    if (ptype == V_ASN1_SEQUENCE) {\n        pstr = pval;\n        pm = pstr->data;\n        pmlen = pstr->length;\n        if (!(dsa = d2i_DSAparams(NULL, &pm, pmlen))) {\n            DSAerr(DSA_F_DSA_PUB_DECODE, DSA_R_DECODE_ERROR);\n            goto err;\n        }\n    } else if ((ptype == V_ASN1_NULL) || (ptype == V_ASN1_UNDEF)) {\n        if (!(dsa = DSA_new())) {\n            DSAerr(DSA_F_DSA_PUB_DECODE, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n    } else {\n        DSAerr(DSA_F_DSA_PUB_DECODE, DSA_R_PARAMETER_ENCODING_ERROR);\n        goto err;\n    }\n    if (!(public_key = d2i_ASN1_INTEGER(NULL, &p, pklen))) {\n        DSAerr(DSA_F_DSA_PUB_DECODE, DSA_R_DECODE_ERROR);\n        goto err;\n    }\n    if (!(dsa->pub_key = ASN1_INTEGER_to_BN(public_key, NULL))) {\n        DSAerr(DSA_F_DSA_PUB_DECODE, DSA_R_BN_DECODE_ERROR);\n        goto err;\n    }\n    ASN1_INTEGER_free(public_key);\n    EVP_PKEY_assign_DSA(pkey, dsa);\n    return 1;\n err:\n    if (public_key)\n        ASN1_INTEGER_free(public_key);\n    if (dsa)\n        DSA_free(dsa);\n    return 0;\n}", "target": 0}
{"code": "void free_pgtables(struct mmu_gather **tlb, struct vm_area_struct *vma,\n\t\tunsigned long floor, unsigned long ceiling)\n{\n\twhile (vma) {\n\t\tstruct vm_area_struct *next = vma->vm_next;\n\t\tunsigned long addr = vma->vm_start;\n\t\tanon_vma_unlink(vma);\n\t\tunlink_file_vma(vma);\n\t\tif (is_vm_hugetlb_page(vma)) {\n\t\t\thugetlb_free_pgd_range(tlb, addr, vma->vm_end,\n\t\t\t\tfloor, next? next->vm_start: ceiling);\n\t\t} else {\n\t\t\twhile (next && next->vm_start <= vma->vm_end + PMD_SIZE\n\t\t\t       && !is_vm_hugetlb_page(next)) {\n\t\t\t\tvma = next;\n\t\t\t\tnext = vma->vm_next;\n\t\t\t\tanon_vma_unlink(vma);\n\t\t\t\tunlink_file_vma(vma);\n\t\t\t}\n\t\t\tfree_pgd_range(tlb, addr, vma->vm_end,\n\t\t\t\tfloor, next? next->vm_start: ceiling);\n\t\t}\n\t\tvma = next;\n\t}\n}", "target": 0}
{"code": "static int em_jmp_far(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tunsigned short sel, old_sel;\n\tstruct desc_struct old_desc, new_desc;\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tu8 cpl = ctxt->ops->cpl(ctxt);\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tops->get_segment(ctxt, &old_sel, &old_desc, NULL,\n\t\t\t\t VCPU_SREG_CS);\n\tmemcpy(&sel, ctxt->src.valptr + ctxt->op_bytes, 2);\n\trc = __load_segment_descriptor(ctxt, sel, VCPU_SREG_CS, cpl,\n\t\t\t\t       X86_TRANSFER_CALL_JMP,\n\t\t\t\t       &new_desc);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = assign_eip_far(ctxt, ctxt->src.val, &new_desc);\n\tif (rc != X86EMUL_CONTINUE) {\n\t\tWARN_ON(ctxt->mode != X86EMUL_MODE_PROT64);\n\t\tops->set_segment(ctxt, old_sel, &old_desc, 0, VCPU_SREG_CS);\n\t\treturn rc;\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "void fz_cmm_init_profile(fz_context *ctx, fz_iccprofile *profile)\n{\n\tif (ctx && ctx->colorspace && ctx->colorspace->cmm && ctx->cmm_instance)\n\t\tctx->colorspace->cmm->init_profile(ctx->cmm_instance, profile);\n}", "target": 0}
{"code": "check_SET_IP_TTL(const struct ofpact_ip_ttl *a OVS_UNUSED,\n                 struct ofpact_check_params *cp)\n{\n    return check_set_ip(cp);\n}", "target": 0}
{"code": "find_entry2modify_only_ext(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n    int flags,\n    back_txn *txn\n)\n{\n\treturn( find_entry_internal( pb, be, addr, 1, txn, \n\t\t                         FE_REALLY_INTERNAL | flags ));\n}", "target": 1}
{"code": "mountpoint_last(struct nameidata *nd, struct path *path)\n{\n\tint error = 0;\n\tstruct dentry *dentry;\n\tstruct dentry *dir = nd->path.dentry;\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tif (unlazy_walk(nd, NULL)) {\n\t\t\terror = -ECHILD;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tnd->flags &= ~LOOKUP_PARENT;\n\tif (unlikely(nd->last_type != LAST_NORM)) {\n\t\terror = handle_dots(nd, nd->last_type);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tdentry = dget(nd->path.dentry);\n\t\tgoto done;\n\t}\n\tmutex_lock(&dir->d_inode->i_mutex);\n\tdentry = d_lookup(dir, &nd->last);\n\tif (!dentry) {\n\t\tdentry = d_alloc(dir, &nd->last);\n\t\tif (!dentry) {\n\t\t\terror = -ENOMEM;\n\t\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\t\tgoto out;\n\t\t}\n\t\tdentry = lookup_real(dir->d_inode, dentry, nd->flags);\n\t\terror = PTR_ERR(dentry);\n\t\tif (IS_ERR(dentry)) {\n\t\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmutex_unlock(&dir->d_inode->i_mutex);\ndone:\n\tif (!dentry->d_inode || d_is_negative(dentry)) {\n\t\terror = -ENOENT;\n\t\tdput(dentry);\n\t\tgoto out;\n\t}\n\tpath->dentry = dentry;\n\tpath->mnt = mntget(nd->path.mnt);\n\tif (should_follow_link(dentry, nd->flags & LOOKUP_FOLLOW))\n\t\treturn 1;\n\tfollow_mount(path);\n\terror = 0;\nout:\n\tterminate_walk(nd);\n\treturn error;\n}", "target": 1}
{"code": "static void fts3ReversePoslist(char *pStart, char **ppPoslist){\n  char *p = &(*ppPoslist)[-2];\n  char c = 0;\n  while( p>pStart && (c=*p--)==0 );\n  while( p>pStart && (*p & 0x80) | c ){ \n    c = *p--; \n  }\n  if( p>pStart ){ p = &p[2]; }\n  while( *p++&0x80 );\n  *ppPoslist = p;\n}", "target": 0}
{"code": "get_manuf_name(const guint8 *addr)\n{\n    hashmanuf_t *manuf_value;\n    manuf_value = manuf_name_lookup(addr);\n    if (gbl_resolv_flags.mac_name && manuf_value->status != HASHETHER_STATUS_UNRESOLVED)\n        return manuf_value->resolved_name;\n    return manuf_value->hexaddr;\n} ", "target": 1}
{"code": "resolve_list_keys(struct lys_node_list *list, const char *keys_str)\n{\n    int i, len, rc;\n    const char *value;\n    char *s = NULL;\n    struct ly_ctx *ctx = list->module->ctx;\n    for (i = 0; i < list->keys_size; ++i) {\n        assert(keys_str);\n        if (!list->child) {\n            LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_LYS, list, \"list keys\", keys_str);\n            return EXIT_FAILURE;\n        }\n        if ((value = strpbrk(keys_str, \" \\t\\n\"))) {\n            len = value - keys_str;\n            while (isspace(value[0])) {\n                value++;\n            }\n        } else {\n            len = strlen(keys_str);\n        }\n        rc = lys_getnext_data(lys_node_module((struct lys_node *)list), (struct lys_node *)list, keys_str, len, LYS_LEAF,\n                              (const struct lys_node **)&list->keys[i]);\n        if (rc) {\n            LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_LYS, list, \"list key\", keys_str);\n            return EXIT_FAILURE;\n        }\n        if (check_key(list, i, keys_str, len)) {\n            return -1;\n        }\n        if (lyp_check_status(list->flags, list->module, list->name,\n                             list->keys[i]->flags, list->keys[i]->module, list->keys[i]->name,\n                             (struct lys_node *)list->keys[i])) {\n            return -1;\n        }\n        if (list->keys[i]->dflt) {\n            assert(log_opt == ILO_STORE);\n            log_opt = ILO_LOG;\n            LOGWRN(ctx, \"Default value \\\"%s\\\" in the list key \\\"%s\\\" is ignored. (%s)\", list->keys[i]->dflt,\n                   list->keys[i]->name, s = lys_path((struct lys_node*)list, LYS_PATH_FIRST_PREFIX));\n            log_opt = ILO_STORE;\n            free(s);\n        }\n        while (value && isspace(value[0])) {\n            value++;\n        }\n        keys_str = value;\n    }\n    return EXIT_SUCCESS;\n}", "target": 1}
{"code": "int LibarchivePlugin::extractionFlags() const\n{\n    int result = ARCHIVE_EXTRACT_TIME;\n    result |= ARCHIVE_EXTRACT_SECURE_NODOTDOT;\n    return result;\n}", "target": 1}
{"code": "static int update_write_order_info(rdpContext* context, wStream* s, ORDER_INFO* orderInfo,\n                                   size_t offset)\n{\n\tsize_t position;\n\tWINPR_UNUSED(context);\n\tposition = Stream_GetPosition(s);\n\tStream_SetPosition(s, offset);\n\tStream_Write_UINT8(s, orderInfo->controlFlags); \n\tif (orderInfo->controlFlags & ORDER_TYPE_CHANGE)\n\t\tStream_Write_UINT8(s, orderInfo->orderType); \n\tupdate_write_field_flags(s, orderInfo->fieldFlags, orderInfo->controlFlags,\n\t                         PRIMARY_DRAWING_ORDER_FIELD_BYTES[orderInfo->orderType]);\n\tupdate_write_bounds(s, orderInfo);\n\tStream_SetPosition(s, position);\n\treturn 0;\n}", "target": 1}
{"code": "int sc_compare_oid(const struct sc_object_id *oid1, const struct sc_object_id *oid2)\n{\n\tint i;\n\tif (oid1 == NULL || oid2 == NULL) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\tfor (i = 0; i < SC_MAX_OBJECT_ID_OCTETS; i++)   {\n\t\tif (oid1->value[i] != oid2->value[i])\n\t\t\treturn 0;\n\t\tif (oid1->value[i] == -1)\n\t\t\tbreak;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "static long btrfs_ioctl_scrub_progress(struct btrfs_fs_info *fs_info,\n\t\t\t\t       void __user *arg)\n{\n\tstruct btrfs_ioctl_scrub_args *sa;\n\tint ret;\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tsa = memdup_user(arg, sizeof(*sa));\n\tif (IS_ERR(sa))\n\t\treturn PTR_ERR(sa);\n\tret = btrfs_scrub_progress(fs_info, sa->devid, &sa->progress);\n\tif (ret == 0 && copy_to_user(arg, sa, sizeof(*sa)))\n\t\tret = -EFAULT;\n\tkfree(sa);\n\treturn ret;\n}", "target": 0}
{"code": "handle_fn_f7 (GsdXrandrManager *mgr, guint32 timestamp)\n{\n        GsdXrandrManagerPrivate *priv = mgr->priv;\n        GnomeRRScreen *screen = priv->rw_screen;\n        GnomeRRConfig *current;\n        GError *error;\n        g_debug (\"Handling fn-f7\");\n        error = NULL;\n        if (!gnome_rr_screen_refresh (screen, &error) && error) {\n                char *str;\n                str = g_strdup_printf (_(\"Could not refresh the screen information: %s\"), error->message);\n                g_error_free (error);\n                error_message (mgr, str, NULL, _(\"Trying to switch the monitor configuration anyway.\"));\n                g_free (str);\n        }\n        if (!priv->fn_f7_configs)\n                generate_fn_f7_configs (mgr);\n        current = gnome_rr_config_new_current (screen);\n        if (priv->fn_f7_configs &&\n            (!gnome_rr_config_match (current, priv->fn_f7_configs[0]) ||\n             !gnome_rr_config_equal (current, priv->fn_f7_configs[mgr->priv->current_fn_f7_config]))) {\n                    generate_fn_f7_configs (mgr);\n            }\n        gnome_rr_config_free (current);\n        if (priv->fn_f7_configs) {\n                mgr->priv->current_fn_f7_config++;\n                if (priv->fn_f7_configs[mgr->priv->current_fn_f7_config] == NULL)\n                        mgr->priv->current_fn_f7_config = 0;\n                g_debug (\"cycling to next configuration (%d)\", mgr->priv->current_fn_f7_config);\n                print_configuration (priv->fn_f7_configs[mgr->priv->current_fn_f7_config], \"new config\");\n                g_debug (\"applying\");\n                error = NULL;\n                if (!gnome_rr_config_apply_with_time (priv->fn_f7_configs[mgr->priv->current_fn_f7_config], screen, timestamp, &error)) {\n                        error_message (mgr, _(\"Could not switch the monitor configuration\"), error, NULL);\n                        g_error_free (error);\n                }\n        }\n        else {\n                g_debug (\"no configurations generated\");\n        }\n        g_debug (\"done handling fn-f7\");\n}", "target": 0}
{"code": "nvkm_vmm_put_region(struct nvkm_vmm *vmm, struct nvkm_vma *vma)\n{\n\tstruct nvkm_vma *prev, *next;\n\tif ((prev = node(vma, prev)) && !prev->used) {\n\t\trb_erase(&prev->tree, &vmm->free);\n\t\tlist_del(&prev->head);\n\t\tvma->addr  = prev->addr;\n\t\tvma->size += prev->size;\n\t\tkfree(prev);\n\t}\n\tif ((next = node(vma, next)) && !next->used) {\n\t\trb_erase(&next->tree, &vmm->free);\n\t\tlist_del(&next->head);\n\t\tvma->size += next->size;\n\t\tkfree(next);\n\t}\n\tnvkm_vmm_free_insert(vmm, vma);\n}", "target": 1}
{"code": "unsigned int vcc_poll(struct file *file, struct socket *sock, poll_table *wait)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct atm_vcc *vcc;\n\tunsigned int mask;\n\tsock_poll_wait(file, sk_sleep(sk), wait);\n\tmask = 0;\n\tvcc = ATM_SD(sock);\n\tif (sk->sk_err)\n\t\tmask = POLLERR;\n\tif (test_bit(ATM_VF_RELEASED, &vcc->flags) ||\n\t    test_bit(ATM_VF_CLOSE, &vcc->flags))\n\t\tmask |= POLLHUP;\n\tif (!skb_queue_empty(&sk->sk_receive_queue))\n\t\tmask |= POLLIN | POLLRDNORM;\n\tif (sock->state == SS_CONNECTING &&\n\t    test_bit(ATM_VF_WAITING, &vcc->flags))\n\t\treturn mask;\n\tif (vcc->qos.txtp.traffic_class != ATM_NONE &&\n\t    vcc_writable(sk))\n\t\tmask |= POLLOUT | POLLWRNORM | POLLWRBAND;\n\treturn mask;\n}", "target": 0}
{"code": "static const char *fault_name(unsigned int esr)\n{\n\tconst struct fault_info *inf = fault_info + (esr & 63);\n\treturn inf->name;\n}", "target": 0}
{"code": "atoi_err(const char *nptr, int *val)\n{\n\tconst char *errstr = NULL;\n\tlong long num;\n\tif (nptr == NULL || *nptr == '\\0')\n\t\treturn \"missing\";\n\tnum = strtonum(nptr, 0, INT_MAX, &errstr);\n\tif (errstr == NULL)\n\t\t*val = (int)num;\n\treturn errstr;\n}", "target": 0}
{"code": "nfsd4_layout_verify(struct svc_export *exp, unsigned int layout_type)\n{\n\tif (!exp->ex_layout_types) {\n\t\tdprintk(\"%s: export does not support pNFS\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tif (!(exp->ex_layout_types & (1 << layout_type))) {\n\t\tdprintk(\"%s: layout type %d not supported\\n\",\n\t\t\t__func__, layout_type);\n\t\treturn NULL;\n\t}\n\treturn nfsd4_layout_ops[layout_type];\n}", "target": 1}
{"code": "fmtint(int64 value, char type, int forcesign, int leftjust,\n\t   int minlen, int zpad, int precision, int pointflag,\n\t   PrintfTarget *target)\n{\n\tuint64\t\tbase;\n\tint\t\t\tdosign;\n\tconst char *cvt = \"0123456789abcdef\";\n\tint\t\t\tsignvalue = 0;\n\tchar\t\tconvert[64];\n\tint\t\t\tvallen = 0;\n\tint\t\t\tpadlen = 0;\t\t\n\tint\t\t\tzeropad;\t\t\n\tswitch (type)\n\t{\n\t\tcase 'd':\n\t\tcase 'i':\n\t\t\tbase = 10;\n\t\t\tdosign = 1;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tbase = 8;\n\t\t\tdosign = 0;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tbase = 10;\n\t\t\tdosign = 0;\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\tbase = 16;\n\t\t\tdosign = 0;\n\t\t\tbreak;\n\t\tcase 'X':\n\t\t\tcvt = \"0123456789ABCDEF\";\n\t\t\tbase = 16;\n\t\t\tdosign = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\t\t\t\t\n\t}\n\tif (dosign && adjust_sign((value < 0), forcesign, &signvalue))\n\t\tvalue = -value;\n\tif (value == 0 && pointflag && precision == 0)\n\t\tvallen = 0;\n\telse\n\t{\n\t\tuint64\t\tuvalue = (uint64) value;\n\t\tdo\n\t\t{\n\t\t\tconvert[vallen++] = cvt[uvalue % base];\n\t\t\tuvalue = uvalue / base;\n\t\t} while (uvalue);\n\t}\n\tzeropad = Max(0, precision - vallen);\n\tadjust_padlen(minlen, vallen + zeropad, leftjust, &padlen);\n\tleading_pad(zpad, &signvalue, &padlen, target);\n\twhile (zeropad-- > 0)\n\t\tdopr_outch('0', target);\n\twhile (vallen > 0)\n\t\tdopr_outch(convert[--vallen], target);\n\ttrailing_pad(&padlen, target);\n}", "target": 0}
{"code": "static xmlParserInputPtr _php_libxml_pre_ext_ent_loader(const char *URL,\n\t\tconst char *ID, xmlParserCtxtPtr context)\n{\n\tTSRMLS_FETCH();\n\tif (xmlGenericError == php_libxml_error_handler && PG(modules_activated)) {\n\t\treturn _php_libxml_external_entity_loader(URL, ID, context);\n\t} else {\n\t\treturn _php_libxml_default_entity_loader(URL, ID, context);\n\t}\n}", "target": 0}
{"code": "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur)\n{\n\tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t\t(cur->addr.sin_port == sin->sin_port)) {\n\t\tif ((cur->peercallno == callno) ||\n\t\t\t((dcallno == cur->callno) && !cur->peercallno)) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t    (cur->transfer.sin_port == sin->sin_port) && (cur->transferring)) {\n\t\tif ((dcallno == cur->callno) || (cur->transferring == TRANSFER_MEDIAPASS && cur->transfercallno == callno))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void luaD_callnoyield (lua_State *L, StkId func, int nResults) {\n  incXCcalls(L);\n  if (getCcalls(L) <= CSTACKERR)  \n    luaE_freeCI(L);\n  luaD_call(L, func, nResults);\n  decXCcalls(L);\n}", "target": 1}
{"code": "GF_Err ohdr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu16 cid_len, ri_len;\n\tGF_OMADRMCommonHeaderBox *ptr = (GF_OMADRMCommonHeaderBox*)s;\n\tISOM_DECREASE_SIZE(ptr, (1+1+8+2+2+2) );\n\tptr->EncryptionMethod = gf_bs_read_u8(bs);\n\tptr->PaddingScheme = gf_bs_read_u8(bs);\n\tptr->PlaintextLength = gf_bs_read_u64(bs);\n\tcid_len = gf_bs_read_u16(bs);\n\tri_len = gf_bs_read_u16(bs);\n\tptr->TextualHeadersLen = gf_bs_read_u16(bs);\n\tif (ptr->size<cid_len+ri_len+ptr->TextualHeadersLen) return GF_ISOM_INVALID_FILE;\n\tif (cid_len) {\n\t\tptr->ContentID = (char *)gf_malloc(sizeof(char)*(cid_len+1));\n\t\tif (!ptr->ContentID) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->ContentID, cid_len);\n\t\tptr->ContentID[cid_len]=0;\n\t}\n\tif (ri_len) {\n\t\tptr->RightsIssuerURL = (char *)gf_malloc(sizeof(char)*(ri_len+1));\n\t\tif (!ptr->RightsIssuerURL) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->RightsIssuerURL, ri_len);\n\t\tptr->RightsIssuerURL[ri_len]=0;\n\t}\n\tif (ptr->TextualHeadersLen) {\n\t\tptr->TextualHeaders = (char *)gf_malloc(sizeof(char)*(ptr->TextualHeadersLen+1));\n\t\tif (!ptr->TextualHeaders) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->TextualHeaders, ptr->TextualHeadersLen);\n\t\tptr->TextualHeaders[ptr->TextualHeadersLen] = 0;\n\t}\n\tISOM_DECREASE_SIZE(ptr, (cid_len+ri_len+ptr->TextualHeadersLen) );\n\treturn gf_isom_box_array_read(s, bs);\n}", "target": 0}
{"code": "static int perf_fasync(int fd, struct file *filp, int on)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct perf_event *event = filp->private_data;\n\tint retval;\n\tmutex_lock(&inode->i_mutex);\n\tretval = fasync_helper(fd, filp, on, &event->fasync);\n\tmutex_unlock(&inode->i_mutex);\n\tif (retval < 0)\n\t\treturn retval;\n\treturn 0;\n}", "target": 0}
{"code": "static int raw_cmd_copyin(int cmd, void __user *param,\n\t\t\t\t struct floppy_raw_cmd **rcmd)\n{\n\tstruct floppy_raw_cmd *ptr;\n\tint ret;\n\tint i;\n\t*rcmd = NULL;\nloop:\n\tptr = kmalloc(sizeof(struct floppy_raw_cmd), GFP_USER);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\t*rcmd = ptr;\n\tret = copy_from_user(ptr, param, sizeof(*ptr));\n\tif (ret)\n\t\treturn -EFAULT;\n\tptr->next = NULL;\n\tptr->buffer_length = 0;\n\tparam += sizeof(struct floppy_raw_cmd);\n\tif (ptr->cmd_count > 33)\n\t\treturn -EINVAL;\n\tfor (i = 0; i < 16; i++)\n\t\tptr->reply[i] = 0;\n\tptr->resultcode = 0;\n\tptr->kernel_data = NULL;\n\tif (ptr->flags & (FD_RAW_READ | FD_RAW_WRITE)) {\n\t\tif (ptr->length <= 0)\n\t\t\treturn -EINVAL;\n\t\tptr->kernel_data = (char *)fd_dma_mem_alloc(ptr->length);\n\t\tfallback_on_nodma_alloc(&ptr->kernel_data, ptr->length);\n\t\tif (!ptr->kernel_data)\n\t\t\treturn -ENOMEM;\n\t\tptr->buffer_length = ptr->length;\n\t}\n\tif (ptr->flags & FD_RAW_WRITE) {\n\t\tret = fd_copyin(ptr->data, ptr->kernel_data, ptr->length);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (ptr->flags & FD_RAW_MORE) {\n\t\trcmd = &(ptr->next);\n\t\tptr->rate &= 0x43;\n\t\tgoto loop;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int ebt_size_mwt(struct compat_ebt_entry_mwt *match32,\n\t\t\tunsigned int size_left, enum compat_mwt type,\n\t\t\tstruct ebt_entries_buf_state *state, const void *base)\n{\n\tint growth = 0;\n\tchar *buf;\n\tif (size_left == 0)\n\t\treturn 0;\n\tbuf = (char *) match32;\n\twhile (size_left >= sizeof(*match32)) {\n\t\tstruct ebt_entry_match *match_kern;\n\t\tint ret;\n\t\tmatch_kern = (struct ebt_entry_match *) state->buf_kern_start;\n\t\tif (match_kern) {\n\t\t\tchar *tmp;\n\t\t\ttmp = state->buf_kern_start + state->buf_kern_offset;\n\t\t\tmatch_kern = (struct ebt_entry_match *) tmp;\n\t\t}\n\t\tret = ebt_buf_add(state, buf, sizeof(*match32));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tsize_left -= sizeof(*match32);\n\t\tret = ebt_buf_add_pad(state, ebt_compat_entry_padsize());\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (match32->match_size > size_left)\n\t\t\treturn -EINVAL;\n\t\tsize_left -= match32->match_size;\n\t\tret = compat_mtw_from_user(match32, type, state, base);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (WARN_ON(ret < match32->match_size))\n\t\t\treturn -EINVAL;\n\t\tgrowth += ret - match32->match_size;\n\t\tgrowth += ebt_compat_entry_padsize();\n\t\tbuf += sizeof(*match32);\n\t\tbuf += match32->match_size;\n\t\tif (match_kern)\n\t\t\tmatch_kern->match_size = ret;\n\t\tWARN_ON(type == EBT_COMPAT_TARGET && size_left);\n\t\tmatch32 = (struct compat_ebt_entry_mwt *) buf;\n\t}\n\treturn growth;\n}", "target": 1}
{"code": "void kvm_lapic_set_vapic_addr(struct kvm_vcpu *vcpu, gpa_t vapic_addr)\n{\n\tvcpu->arch.apic->vapic_addr = vapic_addr;\n\tif (vapic_addr)\n\t\t__set_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n\telse\n\t\t__clear_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n}", "target": 1}
{"code": "deltas_head_values_set(struct deltas_head *deltas)\n{\n\treturn deltas->len == deltas->capacity;\n}", "target": 1}
{"code": "char* Elf_(r_bin_elf_get_file_type)(ELFOBJ *bin) {\n\tut32 e_type;\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\te_type = (ut32)bin->ehdr.e_type; \n\tswitch (e_type) {\n\tcase ET_NONE: return strdup (\"NONE (None)\");\n\tcase ET_REL:  return strdup (\"REL (Relocatable file)\");\n\tcase ET_EXEC: return strdup (\"EXEC (Executable file)\");\n\tcase ET_DYN:  return strdup (\"DYN (Shared object file)\");\n\tcase ET_CORE: return strdup (\"CORE (Core file)\");\n\t}\n\tif ((e_type >= ET_LOPROC) && (e_type <= ET_HIPROC)) {\n\t\treturn r_str_newf (\"Processor Specific: %x\", e_type);\n\t}\n\tif ((e_type >= ET_LOOS) && (e_type <= ET_HIOS)) {\n\t\treturn r_str_newf (\"OS Specific: %x\", e_type);\n\t}\n\treturn r_str_newf (\"<unknown>: %x\", e_type);\n}", "target": 0}
{"code": "int blkid_probe_enable_partitions(blkid_probe pr, int enable)\n{\n\tpr->chains[BLKID_CHAIN_PARTS].enabled = enable;\n\treturn 0;\n}", "target": 0}
{"code": "static void xen_free_irq(unsigned irq)\n{\n\tstruct irq_info *info = info_for_irq(irq);\n\tunsigned long flags;\n\tif (WARN_ON(!info))\n\t\treturn;\n\twrite_lock_irqsave(&evtchn_rwlock, flags);\n\tif (!list_empty(&info->eoi_list))\n\t\tlateeoi_list_del(info);\n\tlist_del(&info->list);\n\tset_info_for_irq(irq, NULL);\n\tWARN_ON(info->refcnt > 0);\n\twrite_unlock_irqrestore(&evtchn_rwlock, flags);\n\tkfree(info);\n\tif (irq < nr_legacy_irqs())\n\t\treturn;\n\tirq_free_desc(irq);\n}", "target": 0}
{"code": "TEST_P(ResizeRealtimeTest, DISABLED_TestExternalResizeSmallerWidthBiggerSize) {\n  ResizingVideoSource video;\n  video.flag_codec_ = true;\n  video.smaller_width_larger_size_ = true;\n  DefaultConfig();\n  cfg_.rc_resize_allowed = 0;\n  change_bitrate_ = false;\n  mismatch_psnr_ = 0.0;\n  mismatch_nframes_ = 0;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  for (std::vector<FrameInfo>::const_iterator info = frame_info_list_.begin();\n       info != frame_info_list_.end(); ++info) {\n    const unsigned int frame = static_cast<unsigned>(info->pts);\n    unsigned int expected_w;\n    unsigned int expected_h;\n    ScaleForFrameNumber(frame, kInitialWidth, kInitialHeight, &expected_w,\n                        &expected_h, video.flag_codec_,\n                        video.smaller_width_larger_size_);\n    EXPECT_EQ(expected_w, info->w)\n        << \"Frame \" << frame << \" had unexpected width\";\n    EXPECT_EQ(expected_h, info->h)\n        << \"Frame \" << frame << \" had unexpected height\";\n    EXPECT_EQ(static_cast<unsigned int>(0), GetMismatchFrames());\n  }\n}", "target": 1}
{"code": "void PingStats::init() {\n\tboost::array<double, 3> probs = {{0.75, 0.80, 0.95 }};\n\tasQuantile = new asQuantileType(boost::accumulators::tag::extended_p_square::probabilities = probs);\n\tdPing = 0.0;\n\tuiPing = 0;\n\tuiPingSort = 0;\n\tuiUsers = 0;\n\tuiMaxUsers = 0;\n\tuiBandwidth = 0;\n\tuiSent = 0;\n\tuiRecv = 0;\n\tuiVersion = 0;\n}", "target": 0}
{"code": "qemuProcessHandleMonitorEOF(qemuMonitorPtr mon,\n                            virDomainObjPtr vm,\n                            void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    qemuDomainObjPrivatePtr priv;\n    struct qemuProcessEvent *processEvent;\n    virObjectLock(vm);\n    VIR_DEBUG(\"Received EOF on %p '%s'\", vm, vm->def->name);\n    priv = vm->privateData;\n    if (priv->beingDestroyed) {\n        VIR_DEBUG(\"Domain is being destroyed, EOF is expected\");\n        goto cleanup;\n    }\n    processEvent = g_new0(struct qemuProcessEvent, 1);\n    processEvent->eventType = QEMU_PROCESS_EVENT_MONITOR_EOF;\n    processEvent->vm = virObjectRef(vm);\n    if (virThreadPoolSendJob(driver->workerPool, 0, processEvent) < 0) {\n        virObjectUnref(vm);\n        qemuProcessEventFree(processEvent);\n        goto cleanup;\n    }\n    qemuMonitorUnregister(mon);\n    qemuDomainDestroyNamespace(driver, vm);\n cleanup:\n    virObjectUnlock(vm);\n}", "target": 1}
{"code": "static int32_t gcd(int a, int b)\n{\n  if (a == 0 && b == 0) {\n    return 1;\n  }\n  if (a == 0) return b;\n  if (b == 0) return a;\n  int32_t h;\n  do {\n    h = a % b;\n    a = b;\n    b = h;\n  } while (b != 0);\n  return a;\n}", "target": 1}
{"code": "static int llc_ui_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t     char __user *optval, int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tint rc = -EINVAL, opt;\n\tlock_sock(sk);\n\tif (unlikely(level != SOL_LLC || optlen != sizeof(int)))\n\t\tgoto out;\n\trc = get_user(opt, (int __user *)optval);\n\tif (rc)\n\t\tgoto out;\n\trc = -EINVAL;\n\tswitch (optname) {\n\tcase LLC_OPT_RETRY:\n\t\tif (opt > LLC_OPT_MAX_RETRY)\n\t\t\tgoto out;\n\t\tllc->n2 = opt;\n\t\tbreak;\n\tcase LLC_OPT_SIZE:\n\t\tif (opt > LLC_OPT_MAX_SIZE)\n\t\t\tgoto out;\n\t\tllc->n1 = opt;\n\t\tbreak;\n\tcase LLC_OPT_ACK_TMR_EXP:\n\t\tif (opt > LLC_OPT_MAX_ACK_TMR_EXP)\n\t\t\tgoto out;\n\t\tllc->ack_timer.expire = opt * HZ;\n\t\tbreak;\n\tcase LLC_OPT_P_TMR_EXP:\n\t\tif (opt > LLC_OPT_MAX_P_TMR_EXP)\n\t\t\tgoto out;\n\t\tllc->pf_cycle_timer.expire = opt * HZ;\n\t\tbreak;\n\tcase LLC_OPT_REJ_TMR_EXP:\n\t\tif (opt > LLC_OPT_MAX_REJ_TMR_EXP)\n\t\t\tgoto out;\n\t\tllc->rej_sent_timer.expire = opt * HZ;\n\t\tbreak;\n\tcase LLC_OPT_BUSY_TMR_EXP:\n\t\tif (opt > LLC_OPT_MAX_BUSY_TMR_EXP)\n\t\t\tgoto out;\n\t\tllc->busy_state_timer.expire = opt * HZ;\n\t\tbreak;\n\tcase LLC_OPT_TX_WIN:\n\t\tif (opt > LLC_OPT_MAX_WIN)\n\t\t\tgoto out;\n\t\tllc->k = opt;\n\t\tbreak;\n\tcase LLC_OPT_RX_WIN:\n\t\tif (opt > LLC_OPT_MAX_WIN)\n\t\t\tgoto out;\n\t\tllc->rw = opt;\n\t\tbreak;\n\tdefault:\n\t\trc = -ENOPROTOOPT;\n\t\tgoto out;\n\t}\n\trc = 0;\nout:\n\trelease_sock(sk);\n\treturn rc;\n}", "target": 0}
{"code": "rfbSetClientColourMapBGR233(rfbClientPtr cl)\n{\n    char buf[sz_rfbSetColourMapEntriesMsg + 256 * 3 * 2];\n    rfbSetColourMapEntriesMsg *scme = (rfbSetColourMapEntriesMsg *)buf;\n    uint16_t *rgb = (uint16_t *)(&buf[sz_rfbSetColourMapEntriesMsg]);\n    int i, len;\n    int r, g, b;\n    if (cl->format.bitsPerPixel != 8 ) {\n        rfbErr(\"%s: client not 8 bits per pixel\\n\",\n                \"rfbSetClientColourMapBGR233\");\n        rfbCloseClient(cl);\n        return FALSE;\n    }\n    scme->type = rfbSetColourMapEntries;\n    scme->firstColour = Swap16IfLE(0);\n    scme->nColours = Swap16IfLE(256);\n    len = sz_rfbSetColourMapEntriesMsg;\n    i = 0;\n    for (b = 0; b < 4; b++) {\n        for (g = 0; g < 8; g++) {\n            for (r = 0; r < 8; r++) {\n                rgb[i++] = Swap16IfLE(r * 65535 / 7);\n                rgb[i++] = Swap16IfLE(g * 65535 / 7);\n                rgb[i++] = Swap16IfLE(b * 65535 / 3);\n            }\n        }\n    }\n    len += 256 * 3 * 2;\n    if (rfbWriteExact(cl, buf, len) < 0) {\n        rfbLogPerror(\"rfbSetClientColourMapBGR233: write\");\n        rfbCloseClient(cl);\n        return FALSE;\n    }\n    return TRUE;\n}", "target": 1}
{"code": "TIFFOpenW(const wchar_t* name, const char* mode)\n{\n\tstatic const char module[] = \"TIFFOpenW\";\n\tthandle_t fd;\n\tint m;\n\tDWORD dwMode;\n\tint mbsize;\n\tchar *mbname;\n\tTIFF *tif;\n\tm = _TIFFgetMode(mode, module);\n\tswitch(m) {\n\t\tcase O_RDONLY:\t\t\tdwMode = OPEN_EXISTING; break;\n\t\tcase O_RDWR:\t\t\tdwMode = OPEN_ALWAYS;   break;\n\t\tcase O_RDWR|O_CREAT:\t\tdwMode = OPEN_ALWAYS;   break;\n\t\tcase O_RDWR|O_TRUNC:\t\tdwMode = CREATE_ALWAYS; break;\n\t\tcase O_RDWR|O_CREAT|O_TRUNC:\tdwMode = CREATE_ALWAYS; break;\n\t\tdefault:\t\t\treturn ((TIFF*)0);\n\t}\n\tfd = (thandle_t)CreateFileW(name,\n\t\t(m == O_RDONLY)?GENERIC_READ:(GENERIC_READ|GENERIC_WRITE),\n\t\tFILE_SHARE_READ | FILE_SHARE_WRITE, NULL, dwMode,\n\t\t(m == O_RDONLY)?FILE_ATTRIBUTE_READONLY:FILE_ATTRIBUTE_NORMAL,\n\t\tNULL);\n\tif (fd == INVALID_HANDLE_VALUE) {\n\t\tTIFFErrorExt(0, module, \"%S: Cannot open\", name);\n\t\treturn ((TIFF *)0);\n\t}\n\tmbname = NULL;\n\tmbsize = WideCharToMultiByte(CP_ACP, 0, name, -1, NULL, 0, NULL, NULL);\n\tif (mbsize > 0) {\n\t\tmbname = (char *)_TIFFmalloc(mbsize);\n\t\tif (!mbname) {\n\t\t\tTIFFErrorExt(0, module,\n\t\t\t\"Can't allocate space for filename conversion buffer\");\n\t\t\treturn ((TIFF*)0);\n\t\t}\n\t\tWideCharToMultiByte(CP_ACP, 0, name, -1, mbname, mbsize,\n\t\t\t\t    NULL, NULL);\n\t}\n\ttif = TIFFFdOpen((int)fd,    \n\t\t\t (mbname != NULL) ? mbname : \"<unknown>\", mode);\n\tif(!tif)\n\t\tCloseHandle(fd);\n\t_TIFFfree(mbname);\n\treturn tif;\n}", "target": 0}
{"code": "lexer_scan_identifier (parser_context_t *context_p, \n                       bool propety_name) \n{\n  skip_spaces (context_p);\n  context_p->token.line = context_p->line;\n  context_p->token.column = context_p->column;\n  if (context_p->source_p < context_p->source_end_p\n      && (lit_char_is_identifier_start (context_p->source_p) || context_p->source_p[0] == LIT_CHAR_BACKSLASH))\n  {\n    lexer_parse_identifier (context_p, false);\n    if (propety_name && context_p->token.lit_location.length == 3)\n    {\n      skip_spaces (context_p);\n      if (context_p->source_p < context_p->source_end_p\n          && context_p->source_p[0] != LIT_CHAR_COLON)\n      {\n        if (lexer_compare_identifier_to_current (context_p, &lexer_get_literal))\n        {\n          context_p->token.type = LEXER_PROPERTY_GETTER;\n        }\n        else if (lexer_compare_identifier_to_current (context_p, &lexer_set_literal))\n        {\n          context_p->token.type = LEXER_PROPERTY_SETTER;\n        }\n      }\n    }\n    return;\n  }\n  if (propety_name)\n  {\n    lexer_next_token (context_p);\n    if (context_p->token.type == LEXER_LITERAL\n        || context_p->token.type == LEXER_RIGHT_BRACE)\n    {\n      return;\n    }\n  }\n  parser_raise_error (context_p, PARSER_ERR_IDENTIFIER_EXPECTED);\n} ", "target": 0}
{"code": "static int fsmReadLink(const char *path,\n\t\t       char *buf, size_t bufsize, size_t *linklen)\n{\n    ssize_t llen = readlink(path, buf, bufsize - 1);\n    int rc = RPMERR_READLINK_FAILED;\n    if (_fsm_debug) {\n        rpmlog(RPMLOG_DEBUG, \" %8s (%s, buf, %d) %s\\n\",\n\t       __func__,\n               path, (int)(bufsize -1), (llen < 0 ? strerror(errno) : \"\"));\n    }\n    if (llen >= 0) {\n\tbuf[llen] = '\\0';\n\trc = 0;\n\t*linklen = llen;\n    }\n    return rc;\n}", "target": 0}
{"code": "njs_json_pop_parse_state(njs_vm_t *vm, njs_json_parse_t *parse)\n{\n    njs_json_state_t  *state;\n    state = &parse->states[parse->depth - 1];\n    njs_array_destroy(vm, state->keys);\n    state->keys = NULL;\n    if (parse->depth > 1) {\n        parse->depth--;\n        return &parse->states[parse->depth - 1];\n    }\n    return NULL;\n}", "target": 1}
{"code": "static struct ip_options *ip_options_get_alloc(const int optlen)\n{\n\treturn kzalloc(sizeof(struct ip_options) + ((optlen + 3) & ~3),\n\t\t       GFP_KERNEL);\n}", "target": 1}
{"code": "void js_throw(js_State *J)\n{\n\tif (J->trytop > 0) {\n\t\tjs_Value v = *stackidx(J, -1);\n\t\t--J->trytop;\n\t\tJ->E = J->trybuf[J->trytop].E;\n\t\tJ->envtop = J->trybuf[J->trytop].envtop;\n\t\tJ->tracetop = J->trybuf[J->trytop].tracetop;\n\t\tJ->top = J->trybuf[J->trytop].top;\n\t\tJ->bot = J->trybuf[J->trytop].bot;\n\t\tjs_pushvalue(J, v);\n\t\tlongjmp(J->trybuf[J->trytop].buf, 1);\n\t}\n\tif (J->panic)\n\t\tJ->panic(J);\n\tabort();\n}", "target": 0}
{"code": "static void xfrm6_tunnel_spi_fini(void)\n{\n\tkmem_cache_destroy(xfrm6_tunnel_spi_kmem);\n}", "target": 1}
{"code": "static void logi_dj_recv_queue_notification(struct dj_receiver_dev *djrcv_dev,\n\t\t\t\t\t   struct dj_report *dj_report)\n{\n\tkfifo_in(&djrcv_dev->notif_fifo, dj_report, sizeof(struct dj_report));\n\tif (schedule_work(&djrcv_dev->work) == 0) {\n\t\tdbg_hid(\"%s: did not schedule the work item, was already \"\n\t\t\t\"queued\\n\", __func__);\n\t}\n}", "target": 0}
{"code": "struct lib_t* MACH0_(get_libs)(struct MACH0_(obj_t)* bin) {\n\tstruct lib_t *libs;\n\tint i;\n\tif (!bin->nlibs)\n\t\treturn NULL;\n\tif (!(libs = calloc ((bin->nlibs + 1), sizeof(struct lib_t))))\n\t\treturn NULL;\n\tfor (i = 0; i < bin->nlibs; i++) {\n\t\tstrncpy (libs[i].name, bin->libs[i], R_BIN_MACH0_STRING_LENGTH);\n\t\tlibs[i].name[R_BIN_MACH0_STRING_LENGTH-1] = '\\0';\n\t\tlibs[i].last = 0;\n\t}\n\tlibs[i].last = 1;\n\treturn libs;\n}", "target": 1}
{"code": "static void nfs_set_open_stateid_locked(struct nfs4_state *state, nfs4_stateid *stateid, int open_flags)\n{\n\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) == 0)\n\t\tmemcpy(state->stateid.data, stateid->data, sizeof(state->stateid.data));\n\tmemcpy(state->open_stateid.data, stateid->data, sizeof(state->open_stateid.data));\n\tswitch (open_flags) {\n\t\tcase FMODE_READ:\n\t\t\tset_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tset_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tset_bit(NFS_O_RDWR_STATE, &state->flags);\n\t}\n}", "target": 1}
{"code": "static void iwl_sta_ucode_activate(struct iwl_priv *priv, u8 sta_id)\n{\n\tif (!(priv->stations[sta_id].used & IWL_STA_DRIVER_ACTIVE))\n\t\tIWL_ERR(priv, \"ACTIVATE a non DRIVER active station id %u \"\n\t\t\t\"addr %pM\\n\",\n\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\tif (priv->stations[sta_id].used & IWL_STA_UCODE_ACTIVE) {\n\t\tIWL_DEBUG_ASSOC(priv,\n\t\t\t\t\"STA id %u addr %pM already present in uCode \"\n\t\t\t\t\"(according to driver)\\n\",\n\t\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\t} else {\n\t\tpriv->stations[sta_id].used |= IWL_STA_UCODE_ACTIVE;\n\t\tIWL_DEBUG_ASSOC(priv, \"Added STA id %u addr %pM to uCode\\n\",\n\t\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\t}\n}", "target": 1}
{"code": "acl_fetch_proto_http(struct proxy *px, struct session *s, void *l7, int dir,\n\t\t     struct acl_expr *expr, struct acl_test *test)\n{\n\tstruct buffer *req = s->req;\n\tstruct http_txn *txn = &s->txn;\n\tstruct http_msg *msg = &txn->req;\n\tif (!s || !req)\n\t\treturn 0;\n\tif (unlikely(msg->msg_state >= HTTP_MSG_BODY)) {\n\t\ttest->flags |= ACL_TEST_F_SET_RES_PASS;\n\t\treturn 1;\n\t}\n\tif (unlikely(req->lr > req->data &&\n\t    (req->r < req->lr || req->r > req->data + req->size - global.tune.maxrewrite)) &&\n\t    (req->l <= req->size - global.tune.maxrewrite))\n\t\thttp_buffer_heavy_realign(req, msg);\n\tif (likely(req->lr < req->r))\n\t\thttp_msg_analyzer(req, msg, &txn->hdr_idx);\n\tif (unlikely(msg->msg_state < HTTP_MSG_BODY)) {\n\t\tif ((msg->msg_state == HTTP_MSG_ERROR) || (req->flags & BF_FULL)) {\n\t\t\ttest->flags |= ACL_TEST_F_SET_RES_FAIL;\n\t\t\treturn 1;\n\t\t}\n\t\ttest->flags |= ACL_TEST_F_MAY_CHANGE;\n\t\treturn 0;\n\t}\n\tif (unlikely(req->lr > req->data &&\n\t    (req->r < req->lr || req->l > req->size - global.tune.maxrewrite ||\n\t     req->r > req->data + req->size - global.tune.maxrewrite))) {\n\t\tmsg->msg_state = HTTP_MSG_ERROR;\n\t\ttest->flags |= ACL_TEST_F_SET_RES_PASS;\n\t\treturn 1;\n\t}\n\ttxn->meth = find_http_meth(msg->sol, msg->sl.rq.m_l);\n\tif (txn->meth == HTTP_METH_GET || txn->meth == HTTP_METH_HEAD)\n\t\ts->flags |= SN_REDIRECTABLE;\n\tif (unlikely(msg->sl.rq.v_l == 0) && !http_upgrade_v09_to_v10(req, msg, txn)) {\n\t\ttest->flags |= ACL_TEST_F_SET_RES_FAIL;\n\t\treturn 1;\n\t}\n\ttest->flags |= ACL_TEST_F_SET_RES_PASS;\n\treturn 1;\n}", "target": 0}
{"code": "static int srpt_rx_mgmt_fn_tag(struct srpt_send_ioctx *ioctx, u64 tag)\n{\n\tstruct srpt_device *sdev;\n\tstruct srpt_rdma_ch *ch;\n\tstruct srpt_send_ioctx *target;\n\tint ret, i;\n\tret = -EINVAL;\n\tch = ioctx->ch;\n\tBUG_ON(!ch);\n\tBUG_ON(!ch->sport);\n\tsdev = ch->sport->sdev;\n\tBUG_ON(!sdev);\n\tspin_lock_irq(&sdev->spinlock);\n\tfor (i = 0; i < ch->rq_size; ++i) {\n\t\ttarget = ch->ioctx_ring[i];\n\t\tif (target->cmd.se_lun == ioctx->cmd.se_lun &&\n\t\t    target->cmd.tag == tag &&\n\t\t    srpt_get_cmd_state(target) != SRPT_STATE_DONE) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irq(&sdev->spinlock);\n\treturn ret;\n}", "target": 1}
{"code": "irc_ctcp_dcc_filename_without_quotes (const char *filename)\n{\n    int length;\n    length = strlen (filename);\n    if (length > 0)\n    {\n        if ((filename[0] == '\\\"') && (filename[length - 1] == '\\\"'))\n            return weechat_strndup (filename + 1, length - 2);\n    }\n    return strdup (filename);\n}", "target": 1}
{"code": "std::map<string, AttrValue> GetSetAttrs(const FunctionDef& fdef) {\n  std::map<string, AttrValue> set_attrs;\n  for (const auto& pair : fdef.attr()) {\n    if (pair.second.value_case() != AttrValue::VALUE_NOT_SET) {\n      set_attrs[pair.first] = pair.second;\n    }\n  }\n  return set_attrs;\n}", "target": 0}
{"code": "static int firm_set_rts(struct usb_serial_port *port, __u8 onoff)\n{\n\tstruct whiteheat_set_rdb rts_command;\n\trts_command.port = port->port_number + 1;\n\trts_command.state = onoff;\n\treturn firm_send_command(port, WHITEHEAT_SET_RTS,\n\t\t\t(__u8 *)&rts_command, sizeof(rts_command));\n}", "target": 0}
{"code": "static void __init mp_override_legacy_irq(u8 bus_irq, u8 polarity, u8 trigger,\n\t\t\t\t\t  u32 gsi)\n{\n\tint ioapic;\n\tint pin;\n\tstruct mpc_intsrc mp_irq;\n\tioapic = mp_find_ioapic(gsi);\n\tif (ioapic < 0)\n\t\treturn;\n\tpin = mp_find_ioapic_pin(ioapic, gsi);\n\tif ((bus_irq == 0) && (trigger == 3))\n\t\ttrigger = 1;\n\tmp_irq.type = MP_INTSRC;\n\tmp_irq.irqtype = mp_INT;\n\tmp_irq.irqflag = (trigger << 2) | polarity;\n\tmp_irq.srcbus = MP_ISA_BUS;\n\tmp_irq.srcbusirq = bus_irq;\t\n\tmp_irq.dstapic = mpc_ioapic_id(ioapic); \n\tmp_irq.dstirq = pin;\t\n\tmp_save_irq(&mp_irq);\n\tif (gsi < nr_legacy_irqs() && isa_irq_to_gsi[gsi] == gsi)\n\t\tisa_irq_to_gsi[gsi] = ACPI_INVALID_GSI;\n\tisa_irq_to_gsi[bus_irq] = gsi;\n}", "target": 1}
{"code": "static FILE * pw_tmpfile(int lockfd)\n{\n\tFILE *fd;\n\tchar *tmpname = NULL;\n\tchar *dir = \"/etc\";\n\tif ((fd = xfmkstemp(&tmpname, dir)) == NULL) {\n\t\tulckpwdf();\n\t\terr(EXIT_FAILURE, _(\"can't open temporary file\"));\n\t}\n\tcopyfile(lockfd, fileno(fd));\n\ttmp_file = tmpname;\n\treturn fd;\n}", "target": 1}
{"code": "void usb_serial_console_disconnect(struct usb_serial *serial)\n{\n\tif (serial->port[0] == usbcons_info.port) {\n\t\tusb_serial_console_exit();\n\t\tusb_serial_put(serial);\n\t}\n}", "target": 1}
{"code": "static void do_busid_cmd(ESPState *s, uint8_t busid)\n{\n    uint32_t cmdlen;\n    int32_t datalen;\n    int lun;\n    SCSIDevice *current_lun;\n    uint8_t buf[ESP_CMDFIFO_SZ];\n    trace_esp_do_busid_cmd(busid);\n    lun = busid & 7;\n    cmdlen = fifo8_num_used(&s->cmdfifo);\n    esp_fifo_pop_buf(&s->cmdfifo, buf, cmdlen);\n    current_lun = scsi_device_find(&s->bus, 0, s->current_dev->id, lun);\n    s->current_req = scsi_req_new(current_lun, 0, lun, buf, s);\n    datalen = scsi_req_enqueue(s->current_req);\n    s->ti_size = datalen;\n    fifo8_reset(&s->cmdfifo);\n    if (datalen != 0) {\n        s->rregs[ESP_RSTAT] = STAT_TC;\n        s->rregs[ESP_RSEQ] = SEQ_CD;\n        s->ti_cmd = 0;\n        esp_set_tc(s, 0);\n        if (datalen > 0) {\n            s->data_in_ready = false;\n            s->rregs[ESP_RSTAT] |= STAT_DI;\n        } else {\n            s->rregs[ESP_RSTAT] |= STAT_DO;\n            s->rregs[ESP_RINTR] |= INTR_BS | INTR_FC;\n            esp_raise_irq(s);\n            esp_lower_drq(s);\n        }\n        scsi_req_continue(s->current_req);\n        return;\n    }\n}", "target": 1}
{"code": "static inline void pmd_free(struct mm_struct *mm, pmd_t *pmd)\n{\n\tpgtable_pmd_page_dtor(virt_to_page(pmd));\n\tcrst_table_free(mm, (unsigned long *) pmd);\n}", "target": 0}
{"code": "static void cac_free_private_data(cac_private_data_t *priv)\n{\n\tfree(priv->cac_id);\n\tfree(priv->cache_buf);\n\tfree(priv->aca_path);\n\tlist_destroy(&priv->pki_list);\n\tlist_destroy(&priv->general_list);\n\tfree(priv);\n\treturn;\n}", "target": 0}
{"code": "void oz_hcd_get_desc_cnf(void *hport, u8 req_id, int status, const u8 *desc,\n\t\t\tint length, int offset, int total_size)\n{\n\tstruct oz_port *port = hport;\n\tstruct urb *urb;\n\tint err = 0;\n\toz_dbg(ON, \"oz_hcd_get_desc_cnf length = %d offs = %d tot_size = %d\\n\",\n\t       length, offset, total_size);\n\turb = oz_find_urb_by_id(port, 0, req_id);\n\tif (!urb)\n\t\treturn;\n\tif (status == 0) {\n\t\tint copy_len;\n\t\tint required_size = urb->transfer_buffer_length;\n\t\tif (required_size > total_size)\n\t\t\trequired_size = total_size;\n\t\tcopy_len = required_size-offset;\n\t\tif (length <= copy_len)\n\t\t\tcopy_len = length;\n\t\tmemcpy(urb->transfer_buffer+offset, desc, copy_len);\n\t\toffset += copy_len;\n\t\tif (offset < required_size) {\n\t\t\tstruct usb_ctrlrequest *setup =\n\t\t\t\t(struct usb_ctrlrequest *)urb->setup_packet;\n\t\t\tunsigned wvalue = le16_to_cpu(setup->wValue);\n\t\t\tif (oz_enqueue_ep_urb(port, 0, 0, urb, req_id))\n\t\t\t\terr = -ENOMEM;\n\t\t\telse if (oz_usb_get_desc_req(port->hpd, req_id,\n\t\t\t\t\tsetup->bRequestType, (u8)(wvalue>>8),\n\t\t\t\t\t(u8)wvalue, setup->wIndex, offset,\n\t\t\t\t\trequired_size-offset)) {\n\t\t\t\toz_dequeue_ep_urb(port, 0, 0, urb);\n\t\t\t\terr = -ENOMEM;\n\t\t\t}\n\t\t\tif (err == 0)\n\t\t\t\treturn;\n\t\t}\n\t}\n\turb->actual_length = total_size;\n\toz_complete_urb(port->ozhcd->hcd, urb, 0);\n}", "target": 1}
{"code": "static int crypto_report_acomp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_acomp racomp;\n\tstrlcpy(racomp.type, \"acomp\", sizeof(racomp.type));\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_ACOMP,\n\t\t    sizeof(struct crypto_report_acomp), &racomp))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "yang_free_import(struct ly_ctx *ctx, struct lys_import *imp, uint8_t start, uint8_t size)\n{\n    uint8_t i;\n    for (i = start; i < size; ++i){\n        free((char *)imp[i].module);\n        lydict_remove(ctx, imp[i].prefix);\n        lydict_remove(ctx, imp[i].dsc);\n        lydict_remove(ctx, imp[i].ref);\n        lys_extension_instances_free(ctx, imp[i].ext, imp[i].ext_size, NULL);\n    }\n}", "target": 0}
{"code": "static int orinoco_ioctl_getessid(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  struct iw_point *erq,\n\t\t\t\t  char *essidbuf)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint active;\n\tint err = 0;\n\tunsigned long flags;\n\tif (netif_running(dev)) {\n\t\terr = orinoco_hw_get_essid(priv, &active, essidbuf);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terq->length = err;\n\t} else {\n\t\tif (orinoco_lock(priv, &flags) != 0)\n\t\t\treturn -EBUSY;\n\t\tmemcpy(essidbuf, priv->desired_essid, IW_ESSID_MAX_SIZE);\n\t\terq->length = strlen(priv->desired_essid);\n\t\torinoco_unlock(priv, &flags);\n\t}\n\terq->flags = 1;\n\treturn 0;\n}", "target": 0}
{"code": "static void *__alloc_from_pool(size_t size, struct page **ret_page, gfp_t flags)\n{\n\tunsigned long val;\n\tvoid *ptr = NULL;\n\tif (!atomic_pool) {\n\t\tWARN(1, \"coherent pool not initialised!\\n\");\n\t\treturn NULL;\n\t}\n\tval = gen_pool_alloc(atomic_pool, size);\n\tif (val) {\n\t\tphys_addr_t phys = gen_pool_virt_to_phys(atomic_pool, val);\n\t\t*ret_page = phys_to_page(phys);\n\t\tptr = (void *)val;\n\t\tif (flags & __GFP_ZERO)\n\t\t\tmemset(ptr, 0, size);\n\t}\n\treturn ptr;\n}", "target": 1}
{"code": "static void alterCurrentValue(PlatformUIElement element, int factor)\n{\n    if (!element || !ATK_IS_VALUE(element))\n        return;\n    GValue currentValue = G_VALUE_INIT;\n    atk_value_get_current_value(ATK_VALUE(element), &currentValue);\n    GValue increment = G_VALUE_INIT;\n    atk_value_get_minimum_increment(ATK_VALUE(element), &increment);\n    GValue newValue = G_VALUE_INIT;\n    g_value_init(&newValue, G_TYPE_DOUBLE);\n    g_value_set_float(&newValue, g_value_get_float(&currentValue) + factor * g_value_get_float(&increment));\n    atk_value_set_current_value(ATK_VALUE(element), &newValue);\n    g_value_unset(&newValue);\n    g_value_unset(&increment);\n     g_value_unset(&currentValue);\n }", "target": 0}
{"code": "void cred_to_ucred(struct pid *pid, const struct cred *cred,\n\t\t   struct ucred *ucred)\n{\n\tucred->pid = pid_vnr(pid);\n\tucred->uid = ucred->gid = -1;\n\tif (cred) {\n\t\tstruct user_namespace *current_ns = current_user_ns();\n\t\tucred->uid = from_kuid(current_ns, cred->euid);\n\t\tucred->gid = from_kgid(current_ns, cred->egid);\n\t}\n}", "target": 0}
{"code": "krb5_gss_process_context_token(minor_status, context_handle,\n                               token_buffer)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    gss_buffer_t token_buffer;\n{\n    krb5_gss_ctx_id_rec *ctx;\n    OM_uint32 majerr;\n    ctx = (krb5_gss_ctx_id_t) context_handle;\n    if (! ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n    if (GSS_ERROR(majerr = kg_unseal(minor_status, context_handle,\n                                     token_buffer,\n                                     GSS_C_NO_BUFFER, NULL, NULL,\n                                     KG_TOK_DEL_CTX)))\n        return(majerr);\n    return(krb5_gss_delete_sec_context(minor_status, &context_handle,\n                                       GSS_C_NO_BUFFER));\n}", "target": 1}
{"code": "static void drive_file_fix_path(WCHAR* path)\n{\n\tsize_t i;\n\tsize_t length = _wcslen(path);\n\tfor (i = 0; i < length; i++)\n\t{\n\t\tif (path[i] == L'\\\\')\n\t\t\tpath[i] = L'/';\n\t}\n#ifdef WIN32\n\tif ((length == 3) && (path[1] == L':') && (path[2] == L'/'))\n\t\treturn;\n#else\n\tif ((length == 1) && (path[0] == L'/'))\n\t\treturn;\n#endif\n\tif ((length > 0) && (path[length - 1] == L'/'))\n\t\tpath[length - 1] = L'\\0';\n}", "target": 1}
{"code": "_pam_parse (const pam_handle_t *pamh, int argc, const char **argv,\n\t    const char **conffile, const char **envfile, int *readenv,\n\t    const char **user_envfile, int *user_readenv)\n{\n    int ctrl=0;\n    *user_envfile = DEFAULT_USER_ENVFILE;\n    *envfile = DEFAULT_ETC_ENVFILE;\n    *readenv = DEFAULT_READ_ENVFILE;\n    *user_readenv = DEFAULT_USER_READ_ENVFILE;\n    *conffile = DEFAULT_CONF_FILE;\n    for (; argc-- > 0; ++argv) {\n\tif (!strcmp(*argv,\"debug\"))\n\t    ctrl |= PAM_DEBUG_ARG;\n\telse if (!strncmp(*argv,\"conffile=\",9)) {\n\t  if ((*argv)[9] == '\\0') {\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"conffile= specification missing argument - ignored\");\n\t  } else {\n\t    *conffile = 9+*argv;\n\t    D((\"new Configuration File: %s\", *conffile));\n\t  }\n\t} else if (!strncmp(*argv,\"envfile=\",8)) {\n\t  if ((*argv)[8] == '\\0') {\n\t    pam_syslog (pamh, LOG_ERR,\n\t\t\t\"envfile= specification missing argument - ignored\");\n\t  } else {\n\t    *envfile = 8+*argv;\n\t    D((\"new Env File: %s\", *envfile));\n\t  }\n\t} else if (!strncmp(*argv,\"user_envfile=\",13)) {\n\t  if ((*argv)[13] == '\\0') {\n\t    pam_syslog (pamh, LOG_ERR,\n\t\t\t\"user_envfile= specification missing argument - ignored\");\n\t  } else {\n\t    *user_envfile = 13+*argv;\n\t    D((\"new User Env File: %s\", *user_envfile));\n\t  }\n\t} else if (!strncmp(*argv,\"readenv=\",8))\n\t  *readenv = atoi(8+*argv);\n\telse if (!strncmp(*argv,\"user_readenv=\",13))\n\t  *user_readenv = atoi(13+*argv);\n\telse\n\t  pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n    }\n    return ctrl;\n}", "target": 0}
{"code": "    TypeId TypeInfo::typeId(const std::string& typeName)\n    {\n        const TypeInfoTable* tit = find(typeInfoTable, typeName);\n        if (!tit) return invalidTypeId;\n        return tit->typeId_;\n    }", "target": 0}
{"code": "static void mark_commit(struct commit *c, void *data)\n{\n\tmark_object(&c->object, NULL, NULL, data);\n}", "target": 1}
{"code": "MagickExport MagickBooleanType DrawClipPath(Image *image,\n  const DrawInfo *draw_info,const char *name,ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n  Image\n    *clip_mask;\n  const char\n    *value;\n  DrawInfo\n    *clone_info;\n  MagickStatusType\n    status;\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(draw_info != (const DrawInfo *) NULL);\n  (void) FormatLocaleString(filename,MagickPathExtent,\"%s\",name);\n  value=GetImageArtifact(image,filename);\n  if (value == (const char *) NULL)\n    return(MagickFalse);\n  clip_mask=CloneImage(image,image->columns,image->rows,MagickTrue,exception);\n  if (clip_mask == (Image *) NULL)\n    return(MagickFalse);\n  (void) QueryColorCompliance(\"#0000\",AllCompliance,\n    &clip_mask->background_color,exception);\n  clip_mask->background_color.alpha=(Quantum) TransparentAlpha;\n  (void) SetImageBackgroundColor(clip_mask,exception);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"\\nbegin clip-path %s\",\n      draw_info->clip_mask);\n  clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  (void) CloneString(&clone_info->primitive,value);\n  (void) QueryColorCompliance(\"#ffffff\",AllCompliance,&clone_info->fill,\n    exception);\n  clone_info->clip_mask=(char *) NULL;\n  status=NegateImage(clip_mask,MagickFalse,exception);\n  (void) SetImageMask(image,ReadPixelMask,clip_mask,exception);\n  clip_mask=DestroyImage(clip_mask);\n  status&=DrawImage(image,clone_info,exception);\n  clone_info=DestroyDrawInfo(clone_info);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"end clip-path\");\n  return(status != 0 ? MagickTrue : MagickFalse);\n}", "target": 1}
{"code": "static MagickBooleanType WriteMSLImage(const ImageInfo *image_info,Image *image)\n{\n  Image\n    *msl_image;\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  msl_image=CloneImage(image,0,0,MagickTrue,&image->exception);\n  return(ProcessMSLScript(image_info,&msl_image,&image->exception));\n}", "target": 1}
{"code": "static int find_length(struct pdf_struct *pdf,\n\t\t       struct pdf_obj *obj,\n\t\t       const char *start, off_t len)\n{\n    int length;\n    const char *q;\n    q = cli_memstr(start, len, \"/Length\", 7);\n    if (!q)\n\treturn 0;\n    q++;\n    len -= q - start;\n    start = pdf_nextobject(q, len);\n    if (!start)\n\treturn 0;\n    q = start;\n    length = atoi(q);\n    while (isdigit(*q)) q++;\n    if (*q == ' ') {\n\tint genid;\n\tq++;\n\tgenid = atoi(q);\n\twhile(isdigit(*q)) q++;\n\tif (q[0] == ' ' && q[1] == 'R') {\n\t    cli_dbgmsg(\"cli_pdf: length is in indirect object %u %u\\n\", length, genid);\n\t    obj = find_obj(pdf, obj, (length << 8) | (genid&0xff));\n\t    if (!obj) {\n\t\tcli_dbgmsg(\"cli_pdf: indirect object not found\\n\");\n\t\treturn 0;\n\t    }\n\t    q = pdf_nextobject(pdf->map+obj->start, pdf->size - obj->start);\n\t    length = atoi(q);\n\t}\n    }\n    if (start - pdf->map + length+5 > pdf->size) {\n\tlength = pdf->size - (start - pdf->map)-5;\n    }\n    return length;\n}", "target": 0}
{"code": "static void __exit ipgre_fini(void)\n{\n\trtnl_link_unregister(&ipgre_tap_ops);\n\trtnl_link_unregister(&ipgre_link_ops);\n\tunregister_pernet_device(&ipgre_net_ops);\n\tif (inet_del_protocol(&ipgre_protocol, IPPROTO_GRE) < 0)\n\t\tprintk(KERN_INFO \"ipgre close: can't remove protocol\\n\");\n}", "target": 1}
{"code": "mark_op_resolved (FlatpakTransactionOperation *op,\n                  const char                  *commit,\n                  GFile                       *sideload_path,\n                  GBytes                      *metadata,\n                  GBytes                      *old_metadata)\n{\n  g_debug (\"marking op %s:%s resolved to %s\", kind_to_str (op->kind), flatpak_decomposed_get_ref (op->ref), commit ? commit : \"-\");\n  g_assert (op != NULL);\n  g_assert (commit != NULL);\n  op->resolved = TRUE;\n  if (op->resolved_commit != commit)\n    {\n      g_free (op->resolved_commit); \n      op->resolved_commit = g_strdup (commit);\n    }\n  if (sideload_path)\n    op->resolved_sideload_path = g_object_ref (sideload_path);\n  if (metadata)\n    {\n      g_autoptr(GKeyFile) metakey = g_key_file_new ();\n      if (g_key_file_load_from_bytes (metakey, metadata, G_KEY_FILE_NONE, NULL))\n        {\n          op->resolved_metadata = g_bytes_ref (metadata);\n          op->resolved_metakey = g_steal_pointer (&metakey);\n        }\n      else\n        g_message (\"Warning: Failed to parse metadata for %s\\n\", flatpak_decomposed_get_ref (op->ref));\n    }\n  if (old_metadata)\n    {\n      g_autoptr(GKeyFile) metakey = g_key_file_new ();\n      if (g_key_file_load_from_bytes (metakey, old_metadata, G_KEY_FILE_NONE, NULL))\n        {\n          op->resolved_old_metadata = g_bytes_ref (old_metadata);\n          op->resolved_old_metakey = g_steal_pointer (&metakey);\n        }\n      else\n        g_message (\"Warning: Failed to parse old metadata for %s\\n\", flatpak_decomposed_get_ref (op->ref));\n    }\n}", "target": 1}
{"code": "static int file_modsqrt(STANZA *s)\n{\n    BIGNUM *a = NULL, *p = NULL, *mod_sqrt = NULL, *ret = NULL, *ret2 = NULL;\n    int st = 0;\n    if (!TEST_ptr(a = getBN(s, \"A\"))\n            || !TEST_ptr(p = getBN(s, \"P\"))\n            || !TEST_ptr(mod_sqrt = getBN(s, \"ModSqrt\"))\n            || !TEST_ptr(ret = BN_new())\n            || !TEST_ptr(ret2 = BN_new()))\n        goto err;\n    if (!TEST_true(BN_mod_sqrt(ret, a, p, ctx))\n            || !TEST_true(BN_sub(ret2, p, ret)))\n        goto err;\n    if (BN_cmp(ret2, mod_sqrt) != 0\n            && !equalBN(\"sqrt(A) (mod P)\", mod_sqrt, ret))\n        goto err;\n    st = 1;\n err:\n    BN_free(a);\n    BN_free(p);\n    BN_free(mod_sqrt);\n    BN_free(ret);\n    BN_free(ret2);\n    return st;\n}", "target": 0}
{"code": "void RenderView::CaptureText(WebFrame* frame, string16* contents) {\n  contents->clear();\n  if (!frame)\n    return;\n#ifdef TIME_TEXT_RETRIEVAL\n  double begin = time_util::GetHighResolutionTimeNow();\n#endif\n  *contents = frame->contentAsText(kMaxIndexChars);\n#ifdef TIME_TEXT_RETRIEVAL\n  double end = time_util::GetHighResolutionTimeNow();\n  char buf[128];\n  sprintf_s(buf, \"%d chars retrieved for indexing in %gms\\n\",\n            contents.size(), (end - begin)*1000);\n  OutputDebugStringA(buf);\n#endif\n  if (contents->size() == kMaxIndexChars) {\n    size_t last_space_index = contents->find_last_of(kWhitespaceUTF16);\n    if (last_space_index == std::wstring::npos)\n      return;  \n    contents->resize(last_space_index);\n  }\n}", "target": 0}
{"code": "spnego_gss_unwrap_iov(OM_uint32 *minor_status,\n\t\t      gss_ctx_id_t context_handle,\n\t\t      int *conf_state,\n\t\t      gss_qop_t *qop_state,\n\t\t      gss_iov_buffer_desc *iov,\n\t\t      int iov_count)\n{\n\tOM_uint32 ret;\n\tret = gss_unwrap_iov(minor_status,\n\t\t\t     context_handle,\n\t\t\t     conf_state,\n\t\t\t     qop_state,\n\t\t\t     iov,\n\t\t\t     iov_count);\n\treturn (ret);\n}", "target": 0}
{"code": "void fput(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tfile_sb_list_del(file);\n\t\tif (likely(!in_interrupt() && !(task->flags & PF_KTHREAD))) {\n\t\t\tinit_task_work(&file->f_u.fu_rcuhead, ____fput);\n\t\t\tif (!task_work_add(task, &file->f_u.fu_rcuhead, true))\n\t\t\t\treturn;\n\t\t}\n\t\tif (llist_add(&file->f_u.fu_llist, &delayed_fput_list))\n\t\t\tschedule_work(&delayed_fput_work);\n\t}\n}", "target": 1}
{"code": "static int tcos_decipher(sc_card_t *card, const u8 * crgram, size_t crgram_len, u8 * out, size_t outlen)\n{\n\tsc_context_t *ctx;\n\tsc_apdu_t apdu;\n\tu8 rbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tu8 sbuf[SC_MAX_APDU_BUFFER_SIZE];\n\ttcos_data *data;\n\tint tcos3, r;\n\tassert(card != NULL && crgram != NULL && out != NULL);\n\tctx = card->ctx;\n\ttcos3=(card->type==SC_CARD_TYPE_TCOS_V3);\n\tdata=(tcos_data *)card->drv_data;\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx,\n\t\t\"TCOS3:%d PKCS1:%d\\n\",tcos3,\n\t\t!!(data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1));\n\tsc_format_apdu(card, &apdu, crgram_len>255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT, 0x2A, 0x80, 0x86);\n\tapdu.resp = rbuf;\n\tapdu.resplen = sizeof(rbuf);\n\tapdu.le = crgram_len;\n\tapdu.data = sbuf;\n\tapdu.lc = apdu.datalen = crgram_len+1;\n\tsbuf[0] = tcos3 ? 0x00 : ((data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1) ? 0x81 : 0x02);\n\tmemcpy(sbuf+1, crgram, crgram_len);\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\tif (apdu.sw1==0x90 && apdu.sw2==0x00) {\n\t\tsize_t len= (apdu.resplen>outlen) ? outlen : apdu.resplen;\n\t\tunsigned int offset=0;\n\t\tif(tcos3 && (data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1) && apdu.resp[0]==0 && apdu.resp[1]==2) {\n\t\t\toffset=2; while(offset<len && apdu.resp[offset]!=0) ++offset;\n\t\t\toffset=(offset<len-1) ? offset+1 : 0;\n\t\t}\n\t\tmemcpy(out, apdu.resp+offset, len-offset);\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, len-offset);\n\t}\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, sc_check_sw(card, apdu.sw1, apdu.sw2));\n}", "target": 1}
{"code": "static inline bool hackAroundLibXMLEntityBug(void* closure)\n{\n#if LIBXML_VERSION >= 20627\n    UNUSED_PARAM(closure);\n    return false;\n#else\n    return static_cast<xmlParserCtxtPtr>(closure)->node;\n#endif\n}", "target": 0}
{"code": "void kvm_mmu_invpcid_gva(struct kvm_vcpu *vcpu, gva_t gva, unsigned long pcid)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.mmu;\n\tbool tlb_flush = false;\n\tuint i;\n\tif (pcid == kvm_get_active_pcid(vcpu)) {\n\t\tmmu->invlpg(vcpu, gva, mmu->root.hpa);\n\t\ttlb_flush = true;\n\t}\n\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++) {\n\t\tif (VALID_PAGE(mmu->prev_roots[i].hpa) &&\n\t\t    pcid == kvm_get_pcid(vcpu, mmu->prev_roots[i].pgd)) {\n\t\t\tmmu->invlpg(vcpu, gva, mmu->prev_roots[i].hpa);\n\t\t\ttlb_flush = true;\n\t\t}\n\t}\n\tif (tlb_flush)\n\t\tstatic_call(kvm_x86_flush_tlb_gva)(vcpu, gva);\n\t++vcpu->stat.invlpg;\n}", "target": 1}
{"code": "ncp_read_kernel(struct ncp_server *server, const char *file_id,\n\t     __u32 offset, __u16 to_read, char *target, int *bytes_read)\n{\n\tconst char *source;\n\tint result;\n\tncp_init_request(server);\n\tncp_add_byte(server, 0);\n\tncp_add_mem(server, file_id, 6);\n\tncp_add_be32(server, offset);\n\tncp_add_be16(server, to_read);\n\tif ((result = ncp_request(server, 72)) != 0) {\n\t\tgoto out;\n\t}\n\t*bytes_read = ncp_reply_be16(server, 0);\n\tsource = ncp_reply_data(server, 2 + (offset & 1));\n\tmemcpy(target, source, *bytes_read);\nout:\n\tncp_unlock_server(server);\n\treturn result;\n}", "target": 1}
{"code": "int ping_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct inet_sock *isk = inet_sk(sk);\n\tunsigned short snum;\n\tint err;\n\tint dif = sk->sk_bound_dev_if;\n\terr = ping_check_bind_addr(sk, isk, uaddr, addr_len);\n\tif (err)\n\t\treturn err;\n\tlock_sock(sk);\n\terr = -EINVAL;\n\tif (isk->inet_num != 0)\n\t\tgoto out;\n\terr = -EADDRINUSE;\n\tping_set_saddr(sk, uaddr);\n\tsnum = ntohs(((struct sockaddr_in *)uaddr)->sin_port);\n\tif (ping_get_port(sk, snum) != 0) {\n\t\tping_clear_saddr(sk, dif);\n\t\tgoto out;\n\t}\n\tpr_debug(\"after bind(): num = %hu, dif = %d\\n\",\n\t\t isk->inet_num,\n\t\t sk->sk_bound_dev_if);\n\terr = 0;\n\tif (sk->sk_family == AF_INET && isk->inet_rcv_saddr)\n\t\tsk->sk_userlocks |= SOCK_BINDADDR_LOCK;\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (sk->sk_family == AF_INET6 && !ipv6_addr_any(&sk->sk_v6_rcv_saddr))\n\t\tsk->sk_userlocks |= SOCK_BINDADDR_LOCK;\n#endif\n\tif (snum)\n\t\tsk->sk_userlocks |= SOCK_BINDPORT_LOCK;\n\tisk->inet_sport = htons(isk->inet_num);\n\tisk->inet_daddr = 0;\n\tisk->inet_dport = 0;\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (sk->sk_family == AF_INET6)\n\t\tmemset(&sk->sk_v6_daddr, 0, sizeof(sk->sk_v6_daddr));\n#endif\n\tsk_dst_reset(sk);\nout:\n\trelease_sock(sk);\n\tpr_debug(\"ping_v4_bind -> %d\\n\", err);\n\treturn err;\n}", "target": 0}
{"code": "int rad_packet_add_ipv6prefix(struct rad_packet_t *pack, const char *vendor_name, const char *name, struct in6_addr *prefix, int len)\n{\n\tstruct rad_attr_t *ra;\n\tstruct rad_dict_attr_t *attr;\n\tstruct rad_dict_vendor_t *vendor;\n\tif (pack->len + (vendor_name ? 8 : 2) + 18 >= REQ_LENGTH_MAX)\n\t\treturn -1;\n\tif (vendor_name) {\n\t\tvendor = rad_dict_find_vendor_name(vendor_name);\n\t\tif (!vendor)\n\t\t\treturn -1;\n\t\tattr = rad_dict_find_vendor_attr(vendor, name);\n\t} else {\n\t\tvendor = NULL;\n\t\tattr = rad_dict_find_attr(name);\n\t}\n\tif (!attr)\n\t\treturn -1;\n\tra = mempool_alloc(attr_pool);\n\tif (!ra)\n\t\treturn -1;\n\tmemset(ra, 0, sizeof(*ra));\n\tra->vendor = vendor;\n\tra->attr = attr;\n\tra->len = 18;\n\tra->val.ipv6prefix.len = len;\n\tra->val.ipv6prefix.prefix = *prefix;\n\tra->raw = &ra->val;\n\tlist_add_tail(&ra->entry, &pack->attrs);\n\tpack->len += (vendor_name ? 8 : 2) + 18;\n\treturn 0;\n}", "target": 0}
{"code": "void in6_dev_finish_destroy(struct inet6_dev *idev)\n{\n\tstruct net_device *dev = idev->dev;\n\tWARN_ON(!list_empty(&idev->addr_list));\n\tWARN_ON(idev->mc_list != NULL);\n\tWARN_ON(timer_pending(&idev->rs_timer));\n#ifdef NET_REFCNT_DEBUG\n\tpr_debug(\"%s: %s\\n\", __func__, dev ? dev->name : \"NIL\");\n#endif\n\tdev_put(dev);\n\tif (!idev->dead) {\n\t\tpr_warn(\"Freeing alive inet6 device %p\\n\", idev);\n\t\treturn;\n\t}\n\tsnmp6_free_dev(idev);\n\tkfree_rcu(idev, rcu);\n}", "target": 0}
{"code": "int server_supports_v2(const char *c, int die_on_error)\n{\n\tint i;\n\tfor (i = 0; i < server_capabilities_v2.argc; i++) {\n\t\tconst char *out;\n\t\tif (skip_prefix(server_capabilities_v2.argv[i], c, &out) &&\n\t\t    (!*out || *out == '='))\n\t\t\treturn 1;\n\t}\n\tif (die_on_error)\n\t\tdie(_(\"server doesn't support '%s'\"), c);\n\treturn 0;\n}", "target": 0}
{"code": "validate_commit_metadata (GVariant   *commit_data,\n                          const char *ref,\n                          const char *required_metadata,\n                          gsize       required_metadata_size,\n                          GError   **error)\n{\n  g_autoptr(GVariant) commit_metadata = NULL;\n  g_autoptr(GVariant) xa_metadata_v = NULL;\n  const char *xa_metadata = NULL;\n  gsize xa_metadata_size = 0;\n  commit_metadata = g_variant_get_child_value (commit_data, 0);\n  if (commit_metadata != NULL)\n    {\n      xa_metadata_v = g_variant_lookup_value (commit_metadata,\n                                              \"xa.metadata\",\n                                              G_VARIANT_TYPE_STRING);\n      if (xa_metadata_v)\n        xa_metadata = g_variant_get_string (xa_metadata_v, &xa_metadata_size);\n    }\n  if (xa_metadata == NULL ||\n      xa_metadata_size != required_metadata_size ||\n      memcmp (xa_metadata, required_metadata, xa_metadata_size) != 0)\n    {\n      g_set_error (error, G_IO_ERROR, G_IO_ERROR_PERMISSION_DENIED,\n                   _(\"Commit metadata for %s not matching expected metadata\"), ref);\n      return FALSE;\n    }\n  return TRUE;\n}", "target": 0}
{"code": "bool RenderWidgetHostViewAura::CanFocus() {\n  return popup_type_ == blink::WebPopupTypeNone;\n}", "target": 0}
{"code": "static handler_t mod_wstunnel_check_extension(request_st * const r, void *p_d) {\n    plugin_data *p = p_d;\n    handler_t rc;\n    if (NULL != r->handler_module)\n        return HANDLER_GO_ON;\n  if (r->http_version > HTTP_VERSION_1_1) {\n    if (!r->h2_connect_ext)\n        return HANDLER_GO_ON;\n  }\n  else {\n    if (r->http_method != HTTP_METHOD_GET)\n        return HANDLER_GO_ON;\n    if (r->http_version != HTTP_VERSION_1_1)\n        return HANDLER_GO_ON;\n    const buffer *vb;\n    vb = http_header_request_get(r, HTTP_HEADER_UPGRADE, CONST_STR_LEN(\"Upgrade\"));\n    if (NULL == vb\n        || !http_header_str_contains_token(BUF_PTR_LEN(vb), CONST_STR_LEN(\"websocket\")))\n        return HANDLER_GO_ON;\n    vb = http_header_request_get(r, HTTP_HEADER_CONNECTION, CONST_STR_LEN(\"Connection\"));\n    if (NULL == vb\n        || !http_header_str_contains_token(BUF_PTR_LEN(vb), CONST_STR_LEN(\"upgrade\")))\n        return HANDLER_GO_ON;\n  }\n    mod_wstunnel_patch_config(r, p);\n    if (NULL == p->conf.gw.exts) return HANDLER_GO_ON;\n    rc = gw_check_extension(r, (gw_plugin_data *)p, 1, sizeof(handler_ctx));\n    return (HANDLER_GO_ON == rc && r->handler_module == p->self)\n      ? wstunnel_handler_setup(r, p)\n      : rc;\n}", "target": 0}
{"code": "static inline int l2cap_config_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)\n{\n\tstruct l2cap_conf_rsp *rsp = (struct l2cap_conf_rsp *)data;\n\tu16 scid, flags, result;\n\tstruct sock *sk;\n\tscid   = __le16_to_cpu(rsp->scid);\n\tflags  = __le16_to_cpu(rsp->flags);\n\tresult = __le16_to_cpu(rsp->result);\n\tBT_DBG(\"scid 0x%4.4x flags 0x%2.2x result 0x%2.2x\",\n\t\t\tscid, flags, result);\n\tsk = l2cap_get_chan_by_scid(&conn->chan_list, scid);\n\tif (!sk)\n\t\treturn 0;\n\tswitch (result) {\n\tcase L2CAP_CONF_SUCCESS:\n\t\tbreak;\n\tcase L2CAP_CONF_UNACCEPT:\n\t\tif (++l2cap_pi(sk)->conf_retry < L2CAP_CONF_MAX_RETRIES) {\n\t\t\tchar req[128];\n\t\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\n\t\t\t\t\t\tl2cap_build_conf_req(sk, req), req);\n\t\t\tgoto done;\n\t\t}\n\tdefault:\n\t\tsk->sk_state = BT_DISCONN;\n\t\tsk->sk_err = ECONNRESET;\n\t\tl2cap_sock_set_timer(sk, HZ * 5);\n\t\t{\n\t\t\tstruct l2cap_disconn_req req;\n\t\t\treq.dcid = cpu_to_le16(l2cap_pi(sk)->dcid);\n\t\t\treq.scid = cpu_to_le16(l2cap_pi(sk)->scid);\n\t\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn),\n\t\t\t\t\tL2CAP_DISCONN_REQ, sizeof(req), &req);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (flags & 0x01)\n\t\tgoto done;\n\tl2cap_pi(sk)->conf_state |= L2CAP_CONF_INPUT_DONE;\n\tif (l2cap_pi(sk)->conf_state & L2CAP_CONF_OUTPUT_DONE) {\n\t\tsk->sk_state = BT_CONNECTED;\n\t\tl2cap_chan_ready(sk);\n\t}\ndone:\n\tbh_unlock_sock(sk);\n\treturn 0;\n}", "target": 1}
{"code": "int __split_vma(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long addr, int new_below)\n{\n\tstruct vm_area_struct *new;\n\tint err;\n\tif (is_vm_hugetlb_page(vma) && (addr &\n\t\t\t\t\t~(huge_page_mask(hstate_vma(vma)))))\n\t\treturn -EINVAL;\n\tnew = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL);\n\tif (!new)\n\t\treturn -ENOMEM;\n\t*new = *vma;\n\tINIT_LIST_HEAD(&new->anon_vma_chain);\n\tif (new_below)\n\t\tnew->vm_end = addr;\n\telse {\n\t\tnew->vm_start = addr;\n\t\tnew->vm_pgoff += ((addr - vma->vm_start) >> PAGE_SHIFT);\n\t}\n\terr = vma_dup_policy(vma, new);\n\tif (err)\n\t\tgoto out_free_vma;\n\terr = anon_vma_clone(new, vma);\n\tif (err)\n\t\tgoto out_free_mpol;\n\tif (new->vm_file)\n\t\tget_file(new->vm_file);\n\tif (new->vm_ops && new->vm_ops->open)\n\t\tnew->vm_ops->open(new);\n\tif (new_below)\n\t\terr = vma_adjust(vma, addr, vma->vm_end, vma->vm_pgoff +\n\t\t\t((addr - new->vm_start) >> PAGE_SHIFT), new);\n\telse\n\t\terr = vma_adjust(vma, vma->vm_start, addr, vma->vm_pgoff, new);\n\tif (!err)\n\t\treturn 0;\n\tif (new->vm_ops && new->vm_ops->close)\n\t\tnew->vm_ops->close(new);\n\tif (new->vm_file)\n\t\tfput(new->vm_file);\n\tunlink_anon_vmas(new);\n out_free_mpol:\n\tmpol_put(vma_policy(new));\n out_free_vma:\n\tkmem_cache_free(vm_area_cachep, new);\n\treturn err;\n}", "target": 0}
{"code": "nfssvc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_writeargs *args)\n{\n\tunsigned int len, hdr, dlen;\n\tstruct kvec *head = rqstp->rq_arg.head;\n\tint v;\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp++;\t\t\t\t\n\targs->offset = ntohl(*p++);\t\n\tp++;\t\t\t\t\n\tlen = args->len = ntohl(*p++);\n\tif (len > NFSSVC_MAXBLKSIZE_V2)\n\t\treturn 0;\n\thdr = (void*)p - head->iov_base;\n\tif (hdr > head->iov_len)\n\t\treturn 0;\n\tdlen = head->iov_len + rqstp->rq_arg.page_len - hdr;\n\tif (dlen < XDR_QUADLEN(len)*4)\n\t\treturn 0;\n\trqstp->rq_vec[0].iov_base = (void*)p;\n\trqstp->rq_vec[0].iov_len = head->iov_len - hdr;\n\tv = 0;\n\twhile (len > rqstp->rq_vec[v].iov_len) {\n\t\tlen -= rqstp->rq_vec[v].iov_len;\n\t\tv++;\n\t\trqstp->rq_vec[v].iov_base = page_address(rqstp->rq_pages[v]);\n\t\trqstp->rq_vec[v].iov_len = PAGE_SIZE;\n\t}\n\trqstp->rq_vec[v].iov_len = len;\n\targs->vlen = v + 1;\n\treturn 1;\n}", "target": 0}
{"code": "const EVP_MD *tls12_get_hash(unsigned char hash_alg)\n{\n    switch (hash_alg) {\n# ifndef OPENSSL_NO_MD5\n    case TLSEXT_hash_md5:\n#  ifdef OPENSSL_FIPS\n        if (FIPS_mode())\n            return NULL;\n#  endif\n        return EVP_md5();\n# endif\n# ifndef OPENSSL_NO_SHA\n    case TLSEXT_hash_sha1:\n        return EVP_sha1();\n# endif\n# ifndef OPENSSL_NO_SHA256\n    case TLSEXT_hash_sha224:\n        return EVP_sha224();\n    case TLSEXT_hash_sha256:\n        return EVP_sha256();\n# endif\n# ifndef OPENSSL_NO_SHA512\n    case TLSEXT_hash_sha384:\n        return EVP_sha384();\n    case TLSEXT_hash_sha512:\n        return EVP_sha512();\n# endif\n    default:\n        return NULL;\n    }\n}", "target": 0}
{"code": "static unsigned char ttyio_in(int timeout)\n{\n\tstruct spk_ldisc_data *ldisc_data = speakup_tty->disc_data;\n\tchar rv;\n\tif (wait_for_completion_timeout(&ldisc_data->completion,\n\t\t\t\t\tusecs_to_jiffies(timeout)) == 0) {\n\t\tif (timeout)\n\t\t\tpr_warn(\"spk_ttyio: timeout (%d)  while waiting for input\\n\",\n\t\t\t\ttimeout);\n\t\treturn 0xff;\n\t}\n\trv = ldisc_data->buf;\n\tmb();\n\tldisc_data->buf_free = true;\n\ttty_schedule_flip(speakup_tty->port);\n\treturn rv;\n}", "target": 0}
{"code": "void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n\t{\n\tBN_ULONG t1,t2;\n\tBN_ULONG c1,c2,c3;\n\tc1=0;\n\tc2=0;\n\tc3=0;\n\tmul_add_c(a[0],b[0],c1,c2,c3);\n\tr[0]=c1;\n\tc1=0;\n\tmul_add_c(a[0],b[1],c2,c3,c1);\n\tmul_add_c(a[1],b[0],c2,c3,c1);\n\tr[1]=c2;\n\tc2=0;\n\tmul_add_c(a[2],b[0],c3,c1,c2);\n\tmul_add_c(a[1],b[1],c3,c1,c2);\n\tmul_add_c(a[0],b[2],c3,c1,c2);\n\tr[2]=c3;\n\tc3=0;\n\tmul_add_c(a[0],b[3],c1,c2,c3);\n\tmul_add_c(a[1],b[2],c1,c2,c3);\n\tmul_add_c(a[2],b[1],c1,c2,c3);\n\tmul_add_c(a[3],b[0],c1,c2,c3);\n\tr[3]=c1;\n\tc1=0;\n\tmul_add_c(a[3],b[1],c2,c3,c1);\n\tmul_add_c(a[2],b[2],c2,c3,c1);\n\tmul_add_c(a[1],b[3],c2,c3,c1);\n\tr[4]=c2;\n\tc2=0;\n\tmul_add_c(a[2],b[3],c3,c1,c2);\n\tmul_add_c(a[3],b[2],c3,c1,c2);\n\tr[5]=c3;\n\tc3=0;\n\tmul_add_c(a[3],b[3],c1,c2,c3);\n\tr[6]=c1;\n\tr[7]=c2;\n\t}", "target": 1}
{"code": "static int burl_normalize_2F_to_slash_fix (buffer *b, int qs, int i)\n{\n    char * const s = b->ptr;\n    const int blen = (int)buffer_string_length(b);\n    const int used = qs < 0 ? blen : qs;\n    int j = i;\n    for (; i < used; ++i, ++j) {\n        s[j] = s[i];\n        if (s[i] == '%' && s[i+1] == '2' && s[i+2] == 'F') {\n            s[j] = '/';\n            i+=2;\n        }\n    }\n    if (qs >= 0) {\n        memmove(s+j, s+qs, blen - qs);\n        j += blen - qs;\n    }\n    buffer_string_set_length(b, j);\n    return qs;\n}", "target": 1}
{"code": "int av_hwframe_ctx_init(AVBufferRef *ref)\n{\n    AVHWFramesContext *ctx = (AVHWFramesContext*)ref->data;\n    const enum AVPixelFormat *pix_fmt;\n    int ret;\n    if (ctx->internal->source_frames) {\n        return 0;\n    }\n    for (pix_fmt = ctx->internal->hw_type->pix_fmts; *pix_fmt != AV_PIX_FMT_NONE; pix_fmt++) {\n        if (*pix_fmt == ctx->format)\n            break;\n    }\n    if (*pix_fmt == AV_PIX_FMT_NONE) {\n        av_log(ctx, AV_LOG_ERROR,\n               \"The hardware pixel format '%s' is not supported by the device type '%s'\\n\",\n               av_get_pix_fmt_name(ctx->format), ctx->internal->hw_type->name);\n        return AVERROR(ENOSYS);\n    }\n    ret = av_image_check_size(ctx->width, ctx->height, 0, ctx);\n    if (ret < 0)\n        return ret;\n    if (ctx->internal->hw_type->frames_init) {\n        ret = ctx->internal->hw_type->frames_init(ctx);\n        if (ret < 0)\n            goto fail;\n    }\n    if (ctx->internal->pool_internal && !ctx->pool)\n        ctx->pool = ctx->internal->pool_internal;\n    if (ctx->initial_pool_size > 0) {\n        ret = hwframe_pool_prealloc(ref);\n        if (ret < 0)\n            goto fail;\n    }\n    return 0;\nfail:\n    if (ctx->internal->hw_type->frames_uninit)\n        ctx->internal->hw_type->frames_uninit(ctx);\n    return ret;\n}", "target": 1}
{"code": "static const char *findvararg (CallInfo *ci, int n, StkId *pos) {\n  if (clLvalue(s2v(ci->func))->p->is_vararg) {\n    int nextra = ci->u.l.nextraargs;\n    if (n <= nextra) {\n      *pos = ci->func - nextra + (n - 1);\n      return \"(vararg)\";  \n    }\n  }\n  return NULL;  \n}", "target": 1}
{"code": "static int setup_dev_console(const struct lxc_rootfs *rootfs,\n\t\t\t const struct lxc_console *console)\n{\n\tchar path[MAXPATHLEN];\n\tstruct stat s;\n\tint ret;\n\tret = snprintf(path, sizeof(path), \"%s/dev/console\", rootfs->mount);\n\tif (ret >= sizeof(path)) {\n\t\tERROR(\"console path too long\");\n\t\treturn -1;\n\t}\n\tif (access(path, F_OK)) {\n\t\tWARN(\"rootfs specified but no console found at '%s'\", path);\n\t\treturn 0;\n\t}\n\tif (console->master < 0) {\n\t\tINFO(\"no console\");\n\t\treturn 0;\n\t}\n\tif (stat(path, &s)) {\n\t\tSYSERROR(\"failed to stat '%s'\", path);\n\t\treturn -1;\n\t}\n\tif (chmod(console->name, s.st_mode)) {\n\t\tSYSERROR(\"failed to set mode '0%o' to '%s'\",\n\t\t\t s.st_mode, console->name);\n\t\treturn -1;\n\t}\n\tif (mount(console->name, path, \"none\", MS_BIND, 0)) {\n\t\tERROR(\"failed to mount '%s' on '%s'\", console->name, path);\n\t\treturn -1;\n\t}\n\tINFO(\"console has been setup\");\n\treturn 0;\n}", "target": 1}
{"code": "void *HtpGetTxForH2(void *alstate)\n{\n    HtpState *http_state = (HtpState *)alstate;\n    if (http_state != NULL && http_state->conn != NULL) {\n        size_t txid = htp_list_array_size(http_state->conn->transactions);\n        if (txid > 0) {\n            return htp_list_get(http_state->conn->transactions, txid - 1);\n        }\n    }\n    return NULL;\n}", "target": 1}
{"code": "static int IntensityCompare(const void *x,const void *y)\n{\n  double\n    intensity;\n  PixelInfo\n    *color_1,\n    *color_2;\n  color_1=(PixelInfo *) x;\n  color_2=(PixelInfo *) y;\n  intensity=GetPixelInfoIntensity((const Image *) NULL,color_1)-\n    GetPixelInfoIntensity((const Image *) NULL,color_2);\n  return((int) intensity);\n}", "target": 1}
{"code": "static int ax25_getname(struct socket *sock, struct sockaddr *uaddr,\n\tint *uaddr_len, int peer)\n{\n\tstruct full_sockaddr_ax25 *fsa = (struct full_sockaddr_ax25 *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tunsigned char ndigi, i;\n\tax25_cb *ax25;\n\tint err = 0;\n\tmemset(fsa, 0, sizeof(*fsa));\n\tlock_sock(sk);\n\tax25 = ax25_sk(sk);\n\tif (peer != 0) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tgoto out;\n\t\t}\n\t\tfsa->fsa_ax25.sax25_family = AF_AX25;\n\t\tfsa->fsa_ax25.sax25_call   = ax25->dest_addr;\n\t\tif (ax25->digipeat != NULL) {\n\t\t\tndigi = ax25->digipeat->ndigi;\n\t\t\tfsa->fsa_ax25.sax25_ndigis = ndigi;\n\t\t\tfor (i = 0; i < ndigi; i++)\n\t\t\t\tfsa->fsa_digipeater[i] =\n\t\t\t\t\t\tax25->digipeat->calls[i];\n\t\t}\n\t} else {\n\t\tfsa->fsa_ax25.sax25_family = AF_AX25;\n\t\tfsa->fsa_ax25.sax25_call   = ax25->source_addr;\n\t\tfsa->fsa_ax25.sax25_ndigis = 1;\n\t\tif (ax25->ax25_dev != NULL) {\n\t\t\tmemcpy(&fsa->fsa_digipeater[0],\n\t\t\t       ax25->ax25_dev->dev->dev_addr, AX25_ADDR_LEN);\n\t\t} else {\n\t\t\tfsa->fsa_digipeater[0] = null_ax25_address;\n\t\t}\n\t}\n\t*uaddr_len = sizeof (struct full_sockaddr_ax25);\nout:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "con_insert_unipair(struct uni_pagedir *p, u_short unicode, u_short fontpos)\n{\n\tint i, n;\n\tu16 **p1, *p2;\n\tp1 = p->uni_pgdir[n = unicode >> 11];\n\tif (!p1) {\n\t\tp1 = p->uni_pgdir[n] = kmalloc_array(32, sizeof(u16 *),\n\t\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!p1) return -ENOMEM;\n\t\tfor (i = 0; i < 32; i++)\n\t\t\tp1[i] = NULL;\n\t}\n\tp2 = p1[n = (unicode >> 6) & 0x1f];\n\tif (!p2) {\n\t\tp2 = p1[n] = kmalloc_array(64, sizeof(u16), GFP_KERNEL);\n\t\tif (!p2) return -ENOMEM;\n\t\tmemset(p2, 0xff, 64*sizeof(u16)); \n\t}\n\tp2[unicode & 0x3f] = fontpos;\n\tp->sum += (fontpos << 20) + unicode;\n\treturn 0;\n}", "target": 1}
{"code": "RenderViewImpl* RenderViewImpl::Create(\n    int32 opener_id,\n    const RendererPreferences& renderer_prefs,\n    const WebPreferences& webkit_prefs,\n    SharedRenderViewCounter* counter,\n    int32 routing_id,\n    int32 surface_id,\n    int64 session_storage_namespace_id,\n    const string16& frame_name,\n    bool is_renderer_created,\n    bool swapped_out,\n    int32 next_page_id,\n    const WebKit::WebScreenInfo& screen_info,\n    AccessibilityMode accessibility_mode) {\n  DCHECK(routing_id != MSG_ROUTING_NONE);\n  RenderViewImplParams params(\n      opener_id,\n      renderer_prefs,\n      webkit_prefs,\n      counter,\n      routing_id,\n      surface_id,\n      session_storage_namespace_id,\n      frame_name,\n      is_renderer_created,\n      swapped_out,\n      next_page_id,\n      screen_info,\n      accessibility_mode);\n  if (g_create_render_view_impl)\n    return g_create_render_view_impl(&params);\n  return new RenderViewImpl(&params);\n}", "target": 0}
{"code": "mm_request_send(int socket, enum monitor_reqtype type, Buffer *m)\n{\n\tu_int mlen = buffer_len(m);\n\tu_char buf[5];\n\tdebug3(\"%s entering: type %d\", __func__, type);\n\tPUT_32BIT(buf, mlen + 1);\n\tbuf[4] = (u_char) type;\t\t\n\tif (atomicio(write, socket, buf, sizeof(buf)) != sizeof(buf))\n\t\tfatal(\"%s: write\", __func__);\n\tif (atomicio(write, socket, buffer_ptr(m), mlen) != mlen)\n\t\tfatal(\"%s: write\", __func__);\n}", "target": 0}
{"code": "int lxc_switch_uid_gid(uid_t uid, gid_t gid)\n{\n\tif (setgid(gid) < 0) {\n\t\tSYSERROR(\"Failed to switch to gid %d.\", gid);\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Switched to gid %d.\", gid);\n\tif (setuid(uid) < 0) {\n\t\tSYSERROR(\"Failed to switch to uid %d.\", uid);\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Switched to uid %d.\", uid);\n\treturn 0;\n}", "target": 0}
{"code": "ospf6_print_lshdr(netdissect_options *ndo,\n                  register const struct lsa6_hdr *lshp, const u_char *dataend)\n{\n\tif ((const u_char *)(lshp + 1) > dataend)\n\t\tgoto trunc;\n\tND_TCHECK(lshp->ls_type);\n\tND_TCHECK(lshp->ls_seq);\n\tND_PRINT((ndo, \"\\n\\t  Advertising Router %s, seq 0x%08x, age %us, length %u\",\n               ipaddr_string(ndo, &lshp->ls_router),\n               EXTRACT_32BITS(&lshp->ls_seq),\n               EXTRACT_16BITS(&lshp->ls_age),\n               EXTRACT_16BITS(&lshp->ls_length)-(u_int)sizeof(struct lsa6_hdr)));\n\tospf6_print_ls_type(ndo, EXTRACT_16BITS(&lshp->ls_type), &lshp->ls_stateid);\n\treturn (0);\ntrunc:\n\treturn (1);\n}", "target": 1}
{"code": "static void drop_user_return_notifiers(void)\n{\n\tunsigned int cpu = smp_processor_id();\n\tstruct kvm_shared_msrs *smsr = per_cpu_ptr(shared_msrs, cpu);\n\tif (smsr->registered)\n\t\tkvm_on_user_return(&smsr->urn);\n}", "target": 0}
{"code": "static int search_old_relocation(struct reloc_struct_t *reloc_table, ut32 addr_to_patch, int n_reloc) {\n\tint i;\n\tfor (i = 0; i < n_reloc; i++) {\n\t\tif (addr_to_patch == reloc_table[i].data_offset) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}", "target": 1}
{"code": "static ssize_t read_kmem(struct file *file, char __user *buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tunsigned long p = *ppos;\n\tssize_t low_count, read, sz;\n\tchar *kbuf; \n\tint err = 0;\n\tread = 0;\n\tif (p < (unsigned long) high_memory) {\n\t\tlow_count = count;\n\t\tif (count > (unsigned long)high_memory - p)\n\t\t\tlow_count = (unsigned long)high_memory - p;\n#ifdef __ARCH_HAS_NO_PAGE_ZERO_MAPPED\n\t\tif (p < PAGE_SIZE && low_count > 0) {\n\t\t\tsz = size_inside_page(p, low_count);\n\t\t\tif (clear_user(buf, sz))\n\t\t\t\treturn -EFAULT;\n\t\t\tbuf += sz;\n\t\t\tp += sz;\n\t\t\tread += sz;\n\t\t\tlow_count -= sz;\n\t\t\tcount -= sz;\n\t\t}\n#endif\n\t\twhile (low_count > 0) {\n\t\t\tsz = size_inside_page(p, low_count);\n\t\t\tkbuf = xlate_dev_kmem_ptr((void *)p);\n\t\t\tif (!virt_addr_valid(kbuf))\n\t\t\t\treturn -ENXIO;\n\t\t\tif (copy_to_user(buf, kbuf, sz))\n\t\t\t\treturn -EFAULT;\n\t\t\tbuf += sz;\n\t\t\tp += sz;\n\t\t\tread += sz;\n\t\t\tlow_count -= sz;\n\t\t\tcount -= sz;\n\t\t}\n\t}\n\tif (count > 0) {\n\t\tkbuf = (char *)__get_free_page(GFP_KERNEL);\n\t\tif (!kbuf)\n\t\t\treturn -ENOMEM;\n\t\twhile (count > 0) {\n\t\t\tsz = size_inside_page(p, count);\n\t\t\tif (!is_vmalloc_or_module_addr((void *)p)) {\n\t\t\t\terr = -ENXIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsz = vread(kbuf, (char *)p, sz);\n\t\t\tif (!sz)\n\t\t\t\tbreak;\n\t\t\tif (copy_to_user(buf, kbuf, sz)) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount -= sz;\n\t\t\tbuf += sz;\n\t\t\tread += sz;\n\t\t\tp += sz;\n\t\t}\n\t\tfree_page((unsigned long)kbuf);\n\t}\n\t*ppos = p;\n\treturn read ? read : err;\n}", "target": 0}
{"code": "static int pfkey_register(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\tstruct sk_buff *supp_skb;\n\tif (hdr->sadb_msg_satype > SADB_SATYPE_MAX)\n\t\treturn -EINVAL;\n\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC) {\n\t\tif (pfk->registered&(1<<hdr->sadb_msg_satype))\n\t\t\treturn -EEXIST;\n\t\tpfk->registered |= (1<<hdr->sadb_msg_satype);\n\t}\n\txfrm_probe_algs();\n\tsupp_skb = compose_sadb_supported(hdr, GFP_KERNEL | __GFP_ZERO);\n\tif (!supp_skb) {\n\t\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC)\n\t\t\tpfk->registered &= ~(1<<hdr->sadb_msg_satype);\n\t\treturn -ENOBUFS;\n\t}\n\tpfkey_broadcast(supp_skb, GFP_KERNEL, BROADCAST_REGISTERED, sk,\n\t\t\tsock_net(sk));\n\treturn 0;\n}", "target": 1}
{"code": "int lxc_pclose(struct lxc_popen_FILE *fp)\n{\n\tpid_t wait_pid;\n\tint wstatus = 0;\n\tif (!fp)\n\t\treturn -1;\n\tdo {\n\t\twait_pid = waitpid(fp->child_pid, &wstatus, 0);\n\t} while (wait_pid < 0 && errno == EINTR);\n\tfclose(fp->f);\n\tfree(fp);\n\tif (wait_pid < 0)\n\t\treturn -1;\n\treturn wstatus;\n}", "target": 0}
{"code": "unescape_single_char (char *str, char chr)\n{\n  const char c1 = XNUM_TO_DIGIT (chr >> 4);\n  const char c2 = XNUM_TO_DIGIT (chr & 0xf);\n  char *h = str;                \n  char *t = str;                \n  for (; *h; h++, t++)\n    {\n      if (h[0] == '%' && h[1] == c1 && h[2] == c2)\n        {\n          *t = chr;\n          h += 2;\n        }\n      else\n        *t = *h;\n    }\n  *t = '\\0';\n}", "target": 0}
{"code": "static void jsR_setproperty(js_State *J, js_Object *obj, const char *name)\n{\n\tjs_Value *value = stackidx(J, -1);\n\tjs_Property *ref;\n\tint k;\n\tint own;\n\tif (obj->type == JS_CARRAY) {\n\t\tif (!strcmp(name, \"length\")) {\n\t\t\tdouble rawlen = jsV_tonumber(J, value);\n\t\t\tint newlen = jsV_numbertointeger(rawlen);\n\t\t\tif (newlen != rawlen)\n\t\t\t\tjs_rangeerror(J, \"array length\");\n\t\t\tjsV_resizearray(J, obj, newlen);\n\t\t\treturn;\n\t\t}\n\t\tif (js_isarrayindex(J, name, &k))\n\t\t\tif (k >= obj->u.a.length)\n\t\t\t\tobj->u.a.length = k + 1;\n\t}\n\telse if (obj->type == JS_CSTRING) {\n\t\tif (!strcmp(name, \"length\"))\n\t\t\tgoto readonly;\n\t\tif (js_isarrayindex(J, name, &k))\n\t\t\tif (js_runeat(J, obj->u.s.string, k))\n\t\t\t\tgoto readonly;\n\t}\n\telse if (obj->type == JS_CREGEXP) {\n\t\tif (!strcmp(name, \"source\")) goto readonly;\n\t\tif (!strcmp(name, \"global\")) goto readonly;\n\t\tif (!strcmp(name, \"ignoreCase\")) goto readonly;\n\t\tif (!strcmp(name, \"multiline\")) goto readonly;\n\t\tif (!strcmp(name, \"lastIndex\")) {\n\t\t\tobj->u.r.last = jsV_tointeger(J, value);\n\t\t\treturn;\n\t\t}\n\t}\n\telse if (obj->type == JS_CUSERDATA) {\n\t\tif (obj->u.user.put && obj->u.user.put(J, obj->u.user.data, name))\n\t\t\treturn;\n\t}\n\tref = jsV_getpropertyx(J, obj, name, &own);\n\tif (ref && ref->setter) {\n\t\tjs_pushobject(J, ref->setter);\n\t\tjs_pushobject(J, obj);\n\t\tjs_pushvalue(J, *value);\n\t\tjs_call(J, 1);\n\t\tjs_pop(J, 1);\n\t\treturn;\n\t}\n\tif (!ref || !own)\n\t\tref = jsV_setproperty(J, obj, name);\n\tif (ref) {\n\t\tif (!(ref->atts & JS_READONLY))\n\t\t\tref->value = *value;\n\t\telse\n\t\t\tgoto readonly;\n\t}\n\treturn;\nreadonly:\n\tif (J->strict)\n\t\tjs_typeerror(J, \"'%s' is read-only\", name);\n}", "target": 0}
{"code": "PrintWebViewHelper::PrintPreviewContext::metafile() const {\n  DCHECK(IsRendering());\n  return metafile_.get();\n}", "target": 0}
{"code": "LuaSettings::LuaSettings(const std::string &filename, bool write_allowed) :\n\tm_filename(filename),\n\tm_is_own_settings(true),\n\tm_write_allowed(write_allowed)\n{\n\tm_settings = new Settings();\n\tm_settings->readConfigFile(filename.c_str());\n}", "target": 0}
{"code": "static void nfs4_open_confirm_release(void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\tstruct nfs4_state *state = NULL;\n\tif (data->cancelled == 0)\n\t\tgoto out_free;\n\tif (!data->rpc_done)\n\t\tgoto out_free;\n\tstate = nfs4_opendata_to_nfs4_state(data);\n\tif (!IS_ERR(state))\n\t\tnfs4_close_state(&data->path, state, data->o_arg.open_flags);\nout_free:\n\tnfs4_opendata_put(data);\n}", "target": 1}
{"code": "static int __get_data_block(struct inode *inode, sector_t iblock,\n\t\t\tstruct buffer_head *bh, int create, int flag,\n\t\t\tpgoff_t *next_pgofs)\n{\n\tstruct f2fs_map_blocks map;\n\tint err;\n\tmap.m_lblk = iblock;\n\tmap.m_len = bh->b_size >> inode->i_blkbits;\n\tmap.m_next_pgofs = next_pgofs;\n\terr = f2fs_map_blocks(inode, &map, create, flag);\n\tif (!err) {\n\t\tmap_bh(bh, inode->i_sb, map.m_pblk);\n\t\tbh->b_state = (bh->b_state & ~F2FS_MAP_FLAGS) | map.m_flags;\n\t\tbh->b_size = map.m_len << inode->i_blkbits;\n\t}\n\treturn err;\n}", "target": 1}
{"code": "int vfs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tint error = may_delete(dir, dentry, 0);\n\tif (error)\n\t\treturn error;\n\tif (!dir->i_op->unlink)\n\t\treturn -EPERM;\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\tif (d_mountpoint(dentry))\n\t\terror = -EBUSY;\n\telse {\n\t\terror = security_inode_unlink(dir, dentry);\n\t\tif (!error) {\n\t\t\terror = dir->i_op->unlink(dir, dentry);\n\t\t\tif (!error)\n\t\t\t\tdont_mount(dentry);\n\t\t}\n\t}\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\tif (!error && !(dentry->d_flags & DCACHE_NFSFS_RENAMED)) {\n\t\tfsnotify_link_count(dentry->d_inode);\n\t\td_delete(dentry);\n\t}\n\treturn error;\n}", "target": 0}
{"code": "bool SPIFFEValidator::matchSubjectAltName(X509& leaf_cert) {\n  bssl::UniquePtr<GENERAL_NAMES> san_names(static_cast<GENERAL_NAMES*>(\n      X509_get_ext_d2i(&leaf_cert, NID_subject_alt_name, nullptr, nullptr)));\n  ASSERT(san_names != nullptr,\n         \"san_names should have at least one name after SPIFFE cert validation\");\n  for (const GENERAL_NAME* general_name : san_names.get()) {\n    if (general_name->type == GEN_URI) {\n      const std::string san = Utility::generalNameAsString(general_name);\n      for (const auto& config_san_matcher : subject_alt_name_matchers_) {\n        if (config_san_matcher.match(san)) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}", "target": 1}
{"code": "void close_cached_dir(struct cached_fid *cfid)\n{\n\tmutex_lock(&cfid->fid_mutex);\n\tkref_put(&cfid->refcount, smb2_close_cached_fid);\n\tmutex_unlock(&cfid->fid_mutex);\n}", "target": 0}
{"code": "static size_t push_pipe(struct iov_iter *i, size_t size,\n\t\t\tint *iter_headp, size_t *offp)\n{\n\tstruct pipe_inode_info *pipe = i->pipe;\n\tunsigned int p_tail = pipe->tail;\n\tunsigned int p_mask = pipe->ring_size - 1;\n\tunsigned int iter_head;\n\tsize_t off;\n\tssize_t left;\n\tif (unlikely(size > i->count))\n\t\tsize = i->count;\n\tif (unlikely(!size))\n\t\treturn 0;\n\tleft = size;\n\tdata_start(i, &iter_head, &off);\n\t*iter_headp = iter_head;\n\t*offp = off;\n\tif (off) {\n\t\tleft -= PAGE_SIZE - off;\n\t\tif (left <= 0) {\n\t\t\tpipe->bufs[iter_head & p_mask].len += size;\n\t\t\treturn size;\n\t\t}\n\t\tpipe->bufs[iter_head & p_mask].len = PAGE_SIZE;\n\t\titer_head++;\n\t}\n\twhile (!pipe_full(iter_head, p_tail, pipe->max_usage)) {\n\t\tstruct pipe_buffer *buf = &pipe->bufs[iter_head & p_mask];\n\t\tstruct page *page = alloc_page(GFP_USER);\n\t\tif (!page)\n\t\t\tbreak;\n\t\tbuf->ops = &default_pipe_buf_ops;\n\t\tbuf->page = page;\n\t\tbuf->offset = 0;\n\t\tbuf->len = min_t(ssize_t, left, PAGE_SIZE);\n\t\tleft -= buf->len;\n\t\titer_head++;\n\t\tpipe->head = iter_head;\n\t\tif (left == 0)\n\t\t\treturn size;\n\t}\n\treturn size - left;\n}", "target": 1}
{"code": "static void mkiss_put(struct mkiss *ax)\n{\n\tif (refcount_dec_and_test(&ax->refcnt))\n\t\tcomplete(&ax->dead);\n}", "target": 0}
{"code": "SMB2_auth_kerberos(struct SMB2_sess_data *sess_data)\n{\n\tint rc;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct cifs_spnego_msg *msg;\n\tstruct key *spnego_key = NULL;\n\tstruct smb2_sess_setup_rsp *rsp = NULL;\n\trc = SMB2_sess_alloc_buffer(sess_data);\n\tif (rc)\n\t\tgoto out;\n\tspnego_key = cifs_get_spnego_key(ses);\n\tif (IS_ERR(spnego_key)) {\n\t\trc = PTR_ERR(spnego_key);\n\t\tspnego_key = NULL;\n\t\tgoto out;\n\t}\n\tmsg = spnego_key->payload.data[0];\n\tif (msg->version != CIFS_SPNEGO_UPCALL_VERSION) {\n\t\tcifs_dbg(VFS,\n\t\t\t  \"bad cifs.upcall version. Expected %d got %d\",\n\t\t\t  CIFS_SPNEGO_UPCALL_VERSION, msg->version);\n\t\trc = -EKEYREJECTED;\n\t\tgoto out_put_spnego_key;\n\t}\n\tses->auth_key.response = kmemdup(msg->data, msg->sesskey_len,\n\t\t\t\t\t GFP_KERNEL);\n\tif (!ses->auth_key.response) {\n\t\tcifs_dbg(VFS,\n\t\t\t\"Kerberos can't allocate (%u bytes) memory\",\n\t\t\tmsg->sesskey_len);\n\t\trc = -ENOMEM;\n\t\tgoto out_put_spnego_key;\n\t}\n\tses->auth_key.len = msg->sesskey_len;\n\tsess_data->iov[1].iov_base = msg->data + msg->sesskey_len;\n\tsess_data->iov[1].iov_len = msg->secblob_len;\n\trc = SMB2_sess_sendreceive(sess_data);\n\tif (rc)\n\t\tgoto out_put_spnego_key;\n\trsp = (struct smb2_sess_setup_rsp *)sess_data->iov[0].iov_base;\n\tses->Suid = rsp->sync_hdr.SessionId;\n\tses->session_flags = le16_to_cpu(rsp->SessionFlags);\n\trc = SMB2_sess_establish_session(sess_data);\nout_put_spnego_key:\n\tkey_invalidate(spnego_key);\n\tkey_put(spnego_key);\nout:\n\tsess_data->result = rc;\n\tsess_data->func = NULL;\n\tSMB2_sess_free_buffer(sess_data);\n}", "target": 0}
{"code": "CellularNetwork::CellularNetwork(const ServiceInfo* service)\n    : WirelessNetwork(service) {\n  service_name_ = SafeString(service->name);\n  activation_state_ = service->activation_state;\n  network_technology_ = service->network_technology;\n  roaming_state_ = service->roaming_state;\n  restricted_pool_ = service->restricted_pool;\n  if (service->carrier_info) {\n    operator_name_ = SafeString(service->carrier_info->operator_name);\n    operator_code_ = SafeString(service->carrier_info->operator_code);\n    payment_url_ = SafeString(service->carrier_info->payment_url);\n  }\n  if (service->device_info) {\n    meid_ = SafeString(service->device_info->MEID);\n    imei_ = SafeString(service->device_info->IMEI);\n    imsi_ = SafeString(service->device_info->IMSI);\n    esn_ = SafeString(service->device_info->ESN);\n    mdn_ = SafeString(service->device_info->MDN);\n    min_ = SafeString(service->device_info->MIN);\n    model_id_ = SafeString(service->device_info->model_id);\n    manufacturer_ = SafeString(service->device_info->manufacturer);\n    firmware_revision_ = SafeString(service->device_info->firmware_revision);\n    hardware_revision_ = SafeString(service->device_info->hardware_revision);\n    last_update_ = SafeString(service->device_info->last_update);\n    prl_version_ = service->device_info->PRL_version;\n  }\n  type_ = TYPE_CELLULAR;\n}", "target": 0}
{"code": "list_table_status(MYSQL *mysql,const char *db,const char *wild)\n{\n  char query[1024],*end;\n  MYSQL_RES *result;\n  MYSQL_ROW row;\n  end=strxmov(query,\"show table status from `\",db,\"`\",NullS);\n  if (wild && wild[0])\n    strxmov(end,\" like '\",wild,\"'\",NullS);\n  if (mysql_query(mysql,query) || !(result=mysql_store_result(mysql)))\n  {\n    fprintf(stderr,\"%s: Cannot get status for db: %s, table: %s: %s\\n\",\n\t    my_progname,db,wild ? wild : \"\",mysql_error(mysql));\n    if (mysql_errno(mysql) == ER_PARSE_ERROR)\n      fprintf(stderr,\"This error probably means that your MySQL server doesn't support the\\n\\'show table status' command.\\n\");\n    return 1;\n  }\n  printf(\"Database: %s\",db);\n  if (wild)\n    printf(\"  Wildcard: %s\",wild);\n  putchar('\\n');\n  print_res_header(result);\n  while ((row=mysql_fetch_row(result)))\n    print_res_row(result,row);\n  print_res_top(result);\n  mysql_free_result(result);\n  return 0;\n}", "target": 1}
{"code": "static struct k_itimer *__posix_timers_find(struct hlist_head *head,\n\t\t\t\t\t    struct signal_struct *sig,\n\t\t\t\t\t    timer_t id)\n{\n\tstruct k_itimer *timer;\n\thlist_for_each_entry_rcu(timer, head, t_hash) {\n\t\tif ((timer->it_signal == sig) && (timer->it_id == id))\n\t\t\treturn timer;\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "gdImagePtr gdImageScaleTwoPass(const gdImagePtr src, const unsigned int src_width, const unsigned int src_height, const unsigned int new_width, const unsigned int new_height)\n{\n\tgdImagePtr tmp_im;\n\tgdImagePtr dst;\n\tif (!src->trueColor) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\ttmp_im = gdImageCreateTrueColor(new_width, src_height);\n\tif (tmp_im == NULL) {\n\t\treturn NULL;\n\t}\n\tgdImageSetInterpolationMethod(tmp_im, src->interpolation_id);\n\t_gdScaleHoriz(src, src_width, src_height, tmp_im, new_width, src_height);\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (dst == NULL) {\n\t\tgdFree(tmp_im);\n\t\treturn NULL;\n\t}\n\tgdImageSetInterpolationMethod(dst, src->interpolation_id);\n\t_gdScaleVert(tmp_im, new_width, src_height, dst, new_width, new_height);\n\tgdFree(tmp_im);\n\treturn dst;\n}", "target": 1}
{"code": "static struct kvm_vcpu_hv_synic *synic_get(struct kvm *kvm, u32 vpidx)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vcpu_hv_synic *synic;\n\tvcpu = get_vcpu_by_vpidx(kvm, vpidx);\n\tif (!vcpu)\n\t\treturn NULL;\n\tsynic = to_hv_synic(vcpu);\n\treturn (synic->active) ? synic : NULL;\n}", "target": 1}
{"code": "void AsfVideo::fileProperties() {\n  DataBuf FileIddBuf = io_->read(GUID);\n  xmpData()[\"Xmp.video.FileID\"] = GUIDTag(FileIddBuf.data()).to_string();\n  xmpData()[\"Xmp.video.FileLength\"] = readQWORDTag(io_);\n  xmpData()[\"Xmp.video.CreationDate\"] = readQWORDTag(io_);\n  xmpData()[\"Xmp.video.DataPackets\"] = readQWORDTag(io_);\n  xmpData()[\"Xmp.video.duration\"] = readQWORDTag(io_);\n  xmpData()[\"Xmp.video.SendDuration\"] = readQWORDTag(io_);\n  xmpData()[\"Xmp.video.Preroll\"] = readQWORDTag(io_);\n  io_->seek(io_->tell() + DWORD + DWORD + DWORD,\n            BasicIo::beg);  \n  xmpData()[\"Xmp.video.MaxBitRate\"] = readDWORDTag(io_);\n}  ", "target": 1}
{"code": "vips_foreign_load_gif_scan_image( VipsForeignLoadGif *gif ) \n{\n\tVipsObjectClass *class = VIPS_OBJECT_GET_CLASS( gif );\n\tGifFileType *file = gif->file;\n\tColorMapObject *map = file->Image.ColorMap ?\n\t\tfile->Image.ColorMap : file->SColorMap;\n\tGifByteType *extension;\n\tif( DGifGetImageDesc( gif->file ) == GIF_ERROR ) {\n\t\tvips_foreign_load_gif_error( gif ); \n\t\treturn( -1 );\n\t}\n\tif( file->Image.Left < 0 ||\n\t\tfile->Image.Width < 1 ||\n\t\tfile->Image.Width > 10000 ||\n\t\tfile->Image.Left + file->Image.Width > file->SWidth ||\n\t\tfile->Image.Top < 0 ||\n\t\tfile->Image.Height < 1 ||\n\t\tfile->Image.Height > 10000 ||\n\t\tfile->Image.Top + file->Image.Height > file->SHeight ) {\n\t\tvips_error( class->nickname, \"%s\", _( \"bad frame size\" ) ); \n\t\treturn( -1 ); \n\t}\n\tif( !gif->has_colour &&\n\t\tmap ) {\n\t\tint i;\n\t\tfor( i = 0; i < map->ColorCount; i++ ) \n\t\t\tif( map->Colors[i].Red != map->Colors[i].Green ||\n\t\t\t\tmap->Colors[i].Green != map->Colors[i].Blue ) {\n\t\t\t\tgif->has_colour = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\tdo {\n\t\tif( vips_foreign_load_gif_code_next( gif, &extension ) ) \n\t\t\treturn( -1 );\n\t} while( extension != NULL );\n\treturn( 0 );\n}", "target": 1}
{"code": "update_notification_create(struct update_notification **file)\n{\n\tstruct update_notification *tmp;\n\tstruct deltas_head *list;\n\tint error;\n\ttmp = malloc(sizeof(struct update_notification));\n\tif (tmp == NULL)\n\t\treturn pr_enomem();\n\tlist = NULL;\n\terror = deltas_head_create(&list);\n\tif (error) {\n\t\tfree(tmp);\n\t\treturn error;\n\t}\n\ttmp->deltas_list = list;\n\ttmp->uri = NULL;\n\tglobal_data_init(&tmp->global_data);\n\tdoc_data_init(&tmp->snapshot);\n\t*file = tmp;\n\treturn 0;\n}", "target": 1}
{"code": "static void setup_test_dir(char *tmp_dir, const char *files, ...) {\n        va_list ap;\n        assert_se(mkdtemp(tmp_dir) != NULL);\n        va_start(ap, files);\n        while (files != NULL) {\n                _cleanup_free_ char *path = strappend(tmp_dir, files);\n                assert_se(touch_file(path, true, USEC_INFINITY, UID_INVALID, GID_INVALID, 0) == 0);\n                files = va_arg(ap, const char *);\n        }\n        va_end(ap);\n}", "target": 1}
{"code": "MagickExport void DestroyImageProperties(Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->properties != (void *) NULL)\n    image->properties=(void *) DestroySplayTree((SplayTreeInfo *)\n      image->properties);\n}", "target": 0}
{"code": "int mb2_cache_entry_create(struct mb2_cache *cache, gfp_t mask, u32 key,\n\t\t\t   sector_t block)\n{\n\tstruct mb2_cache_entry *entry, *dup;\n\tstruct hlist_bl_node *dup_node;\n\tstruct hlist_bl_head *head;\n\tentry = kmem_cache_alloc(mb2_entry_cache, mask);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\tINIT_LIST_HEAD(&entry->e_lru_list);\n\tatomic_set(&entry->e_refcnt, 1);\n\tentry->e_key = key;\n\tentry->e_block = block;\n\thead = &cache->c_hash[hash_32(key, cache->c_bucket_bits)];\n\tentry->e_hash_list_head = head;\n\thlist_bl_lock(head);\n\thlist_bl_for_each_entry(dup, dup_node, head, e_hash_list) {\n\t\tif (dup->e_key == key && dup->e_block == block) {\n\t\t\thlist_bl_unlock(head);\n\t\t\tkmem_cache_free(mb2_entry_cache, entry);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\thlist_bl_add_head(&entry->e_hash_list, head);\n\thlist_bl_unlock(head);\n\tspin_lock(&cache->c_lru_list_lock);\n\tlist_add_tail(&entry->e_lru_list, &cache->c_lru_list);\n\tatomic_inc(&entry->e_refcnt);\n\tcache->c_entry_count++;\n\tspin_unlock(&cache->c_lru_list_lock);\n\treturn 0;\n}", "target": 0}
{"code": "Bool gf_filter_send_gf_event(GF_Filter *filter, GF_Event *evt)\n{\n\treturn gf_filter_forward_gf_event(filter, evt, GF_FALSE, GF_FALSE);\n}", "target": 0}
{"code": "  void operator()(const CPUDevice& d,\n                  typename TTypes<T, 3>::ConstTensor gradient,\n                  typename TTypes<T, 3>::ConstTensor input,\n                  const Tensor* input_min_tensor,\n                  const Tensor* input_max_tensor,\n                  typename TTypes<T, 3>::Tensor input_backprop,\n                  typename TTypes<T>::Flat input_min_backprop,\n                  typename TTypes<T>::Flat input_max_backprop) {\n    QuantizeAndDequantizePerChannelGradientImpl<CPUDevice, T>::Compute(\n        d, gradient, input, input_min_tensor, input_max_tensor, input_backprop,\n        input_min_backprop, input_max_backprop);\n  }", "target": 1}
{"code": "static struct nfc_dev *__get_device_from_cb(struct netlink_callback *cb)\n{\n\tconst struct genl_dumpit_info *info = genl_dumpit_info(cb);\n\tstruct nfc_dev *dev;\n\tu32 idx;\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n\t\treturn ERR_PTR(-EINVAL);\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENODEV);\n\treturn dev;\n}", "target": 0}
{"code": "static int ntlm_decode_u16l_str_hdr(struct ntlm_ctx *ctx,\n                                    struct wire_field_hdr *str_hdr,\n                                    struct ntlm_buffer *buffer,\n                                    size_t payload_offs, char **str)\n{\n    char *in, *out = NULL;\n    uint16_t str_len;\n    uint32_t str_offs;\n    size_t outlen;\n    int ret = 0;\n    str_len = le16toh(str_hdr->len);\n    if (str_len == 0) goto done;\n    str_offs = le32toh(str_hdr->offset);\n    if ((str_offs < payload_offs) ||\n        (str_offs > buffer->length) ||\n        (UINT32_MAX - str_offs < str_len) ||\n        (str_offs + str_len > buffer->length)) {\n        return ERR_DECODE;\n    }\n    in = (char *)&buffer->data[str_offs];\n    out = malloc(str_len * 2 + 1);\n    if (!out) return ENOMEM;\n    ret = ntlm_str_convert(ctx->to_oem, in, out, str_len, &outlen);\n    out[outlen] = '\\0';\ndone:\n    if (ret) {\n        safefree(out);\n    }\n    *str = out;\n    return ret;\n}", "target": 0}
{"code": "vq_endchains(struct virtio_vq_info *vq, int used_all_avail)\n{\n\tstruct virtio_base *base;\n\tuint16_t event_idx, new_idx, old_idx;\n\tint intr;\n\tatomic_thread_fence();\n\tbase = vq->base;\n\told_idx = vq->save_used;\n\tvq->save_used = new_idx = vq->used->idx;\n\tif (used_all_avail &&\n\t    (base->negotiated_caps & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)))\n\t\tintr = 1;\n\telse if (base->negotiated_caps & (1 << VIRTIO_RING_F_EVENT_IDX)) {\n\t\tevent_idx = VQ_USED_EVENT_IDX(vq);\n\t\tintr = (uint16_t)(new_idx - event_idx - 1) <\n\t\t\t(uint16_t)(new_idx - old_idx);\n\t} else {\n\t\tintr = new_idx != old_idx &&\n\t\t    !(vq->avail->flags & VRING_AVAIL_F_NO_INTERRUPT);\n\t}\n\tif (intr)\n\t\tvq_interrupt(base, vq);\n}", "target": 1}
{"code": "MONGO_EXPORT void __mongo_set_error( mongo *conn, mongo_error_t err, const char *str,\n                                     int errcode ) {\n    int errstr_size, str_size;\n    conn->err = err;\n    conn->errcode = errcode;\n    if( str ) {\n        str_size = strlen( str ) + 1;\n        errstr_size = str_size > MONGO_ERR_LEN ? MONGO_ERR_LEN : str_size;\n        memcpy( conn->errstr, str, errstr_size );\n        conn->errstr[errstr_size-1] = '\\0';\n    }\n}", "target": 1}
{"code": "static int pcan_usb_pro_drv_loaded(struct peak_usb_device *dev, int loaded)\n{\n\tu8 *buffer;\n\tint err;\n\tbuffer = kmalloc(PCAN_USBPRO_FCT_DRVLD_REQ_LEN, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\tbuffer[0] = 0;\n\tbuffer[1] = !!loaded;\n\terr = pcan_usb_pro_send_req(dev, PCAN_USBPRO_REQ_FCT,\n\t\t\t\t    PCAN_USBPRO_FCT_DRVLD, buffer,\n\t\t\t\t    PCAN_USBPRO_FCT_DRVLD_REQ_LEN);\n\tkfree(buffer);\n\treturn err;\n}", "target": 1}
{"code": "static NTSTATUS ldapsrv_DelRequest(struct ldapsrv_call *call)\n{\n\tstruct ldap_DelRequest *req = &call->request->r.DelRequest;\n\tstruct ldap_Result *del_result;\n\tstruct ldapsrv_reply *del_reply;\n\tTALLOC_CTX *local_ctx;\n\tstruct ldb_context *samdb = call->conn->ldb;\n\tstruct ldb_dn *dn;\n\tconst char *errstr = NULL;\n\tint result = LDAP_SUCCESS;\n\tint ldb_ret;\n\tstruct ldb_result *res = NULL;\n\tDEBUG(10, (\"DelRequest\"));\n\tDEBUGADD(10, (\" dn: %s\\n\", req->dn));\n\tlocal_ctx = talloc_named(call, 0, \"DelRequest local memory context\");\n\tNT_STATUS_HAVE_NO_MEMORY(local_ctx);\n\tdn = ldb_dn_new(local_ctx, samdb, req->dn);\n\tNT_STATUS_HAVE_NO_MEMORY(dn);\n\tDEBUG(10, (\"DelRequest: dn: [%s]\\n\", req->dn));\n\tdel_reply = ldapsrv_init_reply(call, LDAP_TAG_DelResponse);\n\tNT_STATUS_HAVE_NO_MEMORY(del_reply);\n\tif (result == LDAP_SUCCESS) {\n\t\tres = talloc_zero(local_ctx, struct ldb_result);\n\t\tNT_STATUS_HAVE_NO_MEMORY(res);\n\t\tldb_ret = ldapsrv_del_with_controls(call, dn, call->request->controls, res);\n\t\tresult = map_ldb_error(local_ctx, ldb_ret, ldb_errstring(samdb),\n\t\t\t\t       &errstr);\n\t}\n\tdel_result = &del_reply->msg->r.DelResponse;\n\tdel_result->dn = NULL;\n\tif ((res != NULL) && (res->refs != NULL)) {\n\t\tdel_result->resultcode = map_ldb_error(local_ctx,\n\t\t\t\t\t\t       LDB_ERR_REFERRAL, NULL,\n\t\t\t\t\t\t       &errstr);\n\t\tdel_result->errormessage = (errstr?talloc_strdup(del_reply,errstr):NULL);\n\t\tdel_result->referral = talloc_strdup(call, *res->refs);\n\t} else {\n\t\tdel_result->resultcode = result;\n\t\tdel_result->errormessage = (errstr?talloc_strdup(del_reply,errstr):NULL);\n\t\tdel_result->referral = NULL;\n\t}\n\ttalloc_free(local_ctx);\n\treturn ldapsrv_queue_reply(call, del_reply);\n}", "target": 0}
{"code": "read_password(FILE *in, FILE *out, char *buf, size_t bufsz)\n{\n\tint infd = fileno(in);\n\tstruct termios tio;\n\tchar *ret;\n\tret = fgets(buf, bufsz, in);\n\tif (isatty(infd)) {\n\t\tfprintf(out, \"\\n\");\n\t\tfflush(out);\n\t\ttcgetattr(infd, &tio);\n\t\ttio.c_lflag |= ECHO;\n\t\ttcsetattr(infd, TCSAFLUSH, &tio);\n\t}\n\tif (ret == NULL)\n\t\treturn -1;\n\tbuf[strlen(buf)-1] = '\\0';\n\treturn 0;\n}", "target": 0}
{"code": "cql_server::unadvertise_connection(shared_ptr<generic_server::connection> raw_conn) {\n    --_stats.connections;\n    if (auto conn = dynamic_pointer_cast<connection>(raw_conn)) {\n        const auto ip = conn->get_client_state().get_client_address().addr();\n        const auto port = conn->get_client_state().get_client_port();\n        clogger.trace(\"Advertising disconnection of CQL client {}:{}\", ip, port);\n    }\n    return make_ready_future<>();\n}", "target": 0}
{"code": "static int fsmVerify(const char *path, rpmfi fi)\n{\n    int rc;\n    int saveerrno = errno;\n    struct stat dsb;\n    mode_t mode = rpmfiFMode(fi);\n    rc = fsmStat(path, 1, &dsb);\n    if (rc)\n\treturn rc;\n    if (S_ISREG(mode)) {\n\tchar *rmpath = rstrscat(NULL, path, \"-RPMDELETE\", NULL);\n\trc = fsmRename(path, rmpath);\n\tif (!rc)\n\t    (void) fsmUnlink(rmpath);\n\telse\n\t    rc = RPMERR_UNLINK_FAILED;\n\tfree(rmpath);\n        return (rc ? rc : RPMERR_ENOENT);\t\n    } else if (S_ISDIR(mode)) {\n        if (S_ISDIR(dsb.st_mode)) return 0;\n        if (S_ISLNK(dsb.st_mode)) {\n            rc = fsmStat(path, 0, &dsb);\n            if (rc == RPMERR_ENOENT) rc = 0;\n            if (rc) return rc;\n            errno = saveerrno;\n            if (S_ISDIR(dsb.st_mode)) return 0;\n        }\n    } else if (S_ISLNK(mode)) {\n        if (S_ISLNK(dsb.st_mode)) {\n            char buf[8 * BUFSIZ];\n            size_t len;\n            rc = fsmReadLink(path, buf, 8 * BUFSIZ, &len);\n            errno = saveerrno;\n            if (rc) return rc;\n            if (rstreq(rpmfiFLink(fi), buf)) return 0;\n        }\n    } else if (S_ISFIFO(mode)) {\n        if (S_ISFIFO(dsb.st_mode)) return 0;\n    } else if (S_ISCHR(mode) || S_ISBLK(mode)) {\n        if ((S_ISCHR(dsb.st_mode) || S_ISBLK(dsb.st_mode)) &&\n            (dsb.st_rdev == rpmfiFRdev(fi))) return 0;\n    } else if (S_ISSOCK(mode)) {\n        if (S_ISSOCK(dsb.st_mode)) return 0;\n    }\n    rc = fsmUnlink(path);\n    if (rc == 0)\trc = RPMERR_ENOENT;\n    return (rc ? rc : RPMERR_ENOENT);\t\n}", "target": 1}
{"code": "vhost_user_check_and_alloc_queue_pair(struct virtio_net *dev,\n\t\t\tstruct vhu_msg_context *ctx)\n{\n\tuint32_t vring_idx;\n\tswitch (ctx->msg.request.master) {\n\tcase VHOST_USER_SET_VRING_KICK:\n\tcase VHOST_USER_SET_VRING_CALL:\n\tcase VHOST_USER_SET_VRING_ERR:\n\t\tvring_idx = ctx->msg.payload.u64 & VHOST_USER_VRING_IDX_MASK;\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_NUM:\n\tcase VHOST_USER_SET_VRING_BASE:\n\tcase VHOST_USER_GET_VRING_BASE:\n\tcase VHOST_USER_SET_VRING_ENABLE:\n\t\tvring_idx = ctx->msg.payload.state.index;\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_ADDR:\n\t\tvring_idx = ctx->msg.payload.addr.index;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tif (vring_idx >= VHOST_MAX_VRING) {\n\t\tVHOST_LOG_CONFIG(ERR, \"(%s) invalid vring index: %u\\n\", dev->ifname, vring_idx);\n\t\treturn -1;\n\t}\n\tif (dev->virtqueue[vring_idx])\n\t\treturn 0;\n\treturn alloc_vring_queue(dev, vring_idx);\n}", "target": 1}
{"code": "void GfxSeparationColorSpace::getDeviceN(const GfxColor *color, GfxColor *deviceN) const\n{\n    clearGfxColor(deviceN);\n    if (mapping == nullptr || mapping[0] == -1) {\n        GfxCMYK cmyk;\n        getCMYK(color, &cmyk);\n        deviceN->c[0] = cmyk.c;\n        deviceN->c[1] = cmyk.m;\n        deviceN->c[2] = cmyk.y;\n        deviceN->c[3] = cmyk.k;\n    } else {\n        deviceN->c[mapping[0]] = color->c[0];\n    }\n}", "target": 0}
{"code": "static int nft_flush_table(struct nft_ctx *ctx)\n{\n\tint err;\n\tstruct nft_chain *chain, *nc;\n\tstruct nft_set *set, *ns;\n\tlist_for_each_entry_safe(chain, nc, &ctx->table->chains, list) {\n\t\tctx->chain = chain;\n\t\terr = nft_delrule_by_chain(ctx);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\terr = nft_delchain(ctx);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\tlist_for_each_entry_safe(set, ns, &ctx->table->sets, list) {\n\t\tif (set->flags & NFT_SET_ANONYMOUS &&\n\t\t    !list_empty(&set->bindings))\n\t\t\tcontinue;\n\t\terr = nft_delset(ctx, set);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\terr = nft_deltable(ctx);\nout:\n\treturn err;\n}", "target": 1}
{"code": "static uint64_t unpack_timestamp(const struct efi_time *timestamp)\n{\n\tuint64_t val = 0;\n\tuint16_t year = le32_to_cpu(timestamp->year);\n\tval |= ((uint64_t) timestamp->pad1 & 0xFF) << 0;\n\tval |= ((uint64_t) timestamp->second & 0xFF) << (1*8);\n\tval |= ((uint64_t) timestamp->minute & 0xFF) << (2*8);\n\tval |= ((uint64_t) timestamp->hour & 0xFF) << (3*8);\n\tval |= ((uint64_t) timestamp->day & 0xFF) << (4*8);\n\tval |= ((uint64_t) timestamp->month & 0xFF) << (5*8);\n\tval |= ((uint64_t) year) << (6*8);\n\treturn val;\n}", "target": 1}
{"code": "static void vnc_display_close(VncDisplay *vd)\n{\n    if (!vd) {\n        return;\n    }\n    vd->is_unix = false;\n    if (vd->listener) {\n        qio_net_listener_disconnect(vd->listener);\n        object_unref(OBJECT(vd->listener));\n    }\n    vd->listener = NULL;\n    if (vd->wslistener) {\n        qio_net_listener_disconnect(vd->wslistener);\n        object_unref(OBJECT(vd->wslistener));\n    }\n    vd->wslistener = NULL;\n    vd->auth = VNC_AUTH_INVALID;\n    vd->subauth = VNC_AUTH_INVALID;\n    if (vd->tlscreds) {\n        object_unparent(OBJECT(vd->tlscreds));\n        vd->tlscreds = NULL;\n    }\n    if (vd->tlsauthz) {\n        object_unparent(OBJECT(vd->tlsauthz));\n        vd->tlsauthz = NULL;\n    }\n    g_free(vd->tlsauthzid);\n    vd->tlsauthzid = NULL;\n    if (vd->lock_key_sync) {\n        qemu_remove_led_event_handler(vd->led);\n        vd->led = NULL;\n    }\n#ifdef CONFIG_VNC_SASL\n    if (vd->sasl.authz) {\n        object_unparent(OBJECT(vd->sasl.authz));\n        vd->sasl.authz = NULL;\n    }\n    g_free(vd->sasl.authzid);\n    vd->sasl.authzid = NULL;\n#endif\n}", "target": 0}
{"code": "static bool fib6_rule_suppress(struct fib_rule *rule, struct fib_lookup_arg *arg)\n{\n\tstruct fib6_result *res = arg->result;\n\tstruct rt6_info *rt = res->rt6;\n\tstruct net_device *dev = NULL;\n\tif (!rt)\n\t\treturn false;\n\tif (rt->rt6i_idev)\n\t\tdev = rt->rt6i_idev->dev;\n\tif (rt->rt6i_dst.plen <= rule->suppress_prefixlen)\n\t\tgoto suppress_route;\n\tif (rule->suppress_ifgroup != -1 && dev && dev->group == rule->suppress_ifgroup)\n\t\tgoto suppress_route;\n\treturn false;\nsuppress_route:\n\tip6_rt_put(rt);\n\treturn true;\n}", "target": 1}
{"code": "lyd_new_output_anydata(struct lyd_node *parent, const struct lys_module *module, const char *name,\n                       void *value, LYD_ANYDATA_VALUETYPE value_type)\n{\n    const struct lys_node *siblings, *snode;\n    if ((!parent && !module) || !name) {\n        LOGARG;\n        return NULL;\n    }\n    siblings = lyd_new_find_schema(parent, module, 1);\n    if (!siblings) {\n        LOGARG;\n        return NULL;\n    }\n    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_ANYDATA, &snode) || !snode) {\n        LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",\n               name, lys_node_module(siblings)->name, siblings->name);\n        return NULL;\n    }\n    return lyd_create_anydata(parent, snode, value, value_type);\n}", "target": 1}
{"code": "int phar_is_tar(char *buf, char *fname) \n{\n\ttar_header *header = (tar_header *) buf;\n\tphp_uint32 checksum = phar_tar_number(header->checksum, sizeof(header->checksum));\n\tphp_uint32 ret;\n\tchar save[sizeof(header->checksum)], *bname;\n\tif (!strncmp(buf, \"<?php\", sizeof(\"<?php\")-1)) {\n\t\treturn 0;\n\t}\n\tmemcpy(save, header->checksum, sizeof(header->checksum));\n\tmemset(header->checksum, ' ', sizeof(header->checksum));\n\tret = (checksum == phar_tar_checksum(buf, 512));\n\tmemcpy(header->checksum, save, sizeof(header->checksum));\n\tif ((bname = strrchr(fname, PHP_DIR_SEPARATOR))) {\n\t\tfname = bname;\n\t}\n\tif (!ret && (bname = strstr(fname, \".tar\")) && (bname[4] == '\\0' || bname[4] == '.')) {\n\t\treturn 1;\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "\t__releases(rq->lock)\n{\n\tstruct rq *rq = this_rq();\n\tstruct mm_struct *mm = rq->prev_mm;\n\tlong prev_state;\n\tif (WARN_ONCE(preempt_count() != 2*PREEMPT_DISABLE_OFFSET,\n\t\t      \"corrupted preempt_count: %s/%d/0x%x\\n\",\n\t\t      current->comm, current->pid, preempt_count()))\n\t\tpreempt_count_set(FORK_PREEMPT_COUNT);\n\trq->prev_mm = NULL;\n\tprev_state = prev->state;\n\tvtime_task_switch(prev);\n\tperf_event_task_sched_in(prev, current);\n\tfinish_lock_switch(rq, prev);\n\tfinish_arch_post_lock_switch();\n\tfire_sched_in_preempt_notifiers(current);\n\tif (mm)\n\t\tmmdrop(mm);\n\tif (unlikely(prev_state == TASK_DEAD)) {\n\t\tif (prev->sched_class->task_dead)\n\t\t\tprev->sched_class->task_dead(prev);\n\t\tkprobe_flush_task(prev);\n\t\tput_task_struct(prev);\n\t}\n\ttick_nohz_task_switch();\n\treturn rq;\n}", "target": 0}
{"code": "unsigned char *cipso_v4_optptr(const struct sk_buff *skb)\n{\n\tconst struct iphdr *iph = ip_hdr(skb);\n\tunsigned char *optptr = (unsigned char *)&(ip_hdr(skb)[1]);\n\tint optlen;\n\tint taglen;\n\tfor (optlen = iph->ihl*4 - sizeof(struct iphdr); optlen > 0; ) {\n\t\tif (optptr[0] == IPOPT_CIPSO)\n\t\t\treturn optptr;\n\t\ttaglen = optptr[1];\n\t\toptlen -= taglen;\n\t\toptptr += taglen;\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "ieee80211_tx_h_check_assoc(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)tx->skb->data;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tbool assoc = false;\n\tif (unlikely(info->flags & IEEE80211_TX_CTL_INJECTED))\n\t\treturn TX_CONTINUE;\n\tif (unlikely(test_bit(SCAN_SW_SCANNING, &tx->local->scanning)) &&\n\t    test_bit(SDATA_STATE_OFFCHANNEL, &tx->sdata->state) &&\n\t    !ieee80211_is_probe_req(hdr->frame_control) &&\n\t    !ieee80211_is_nullfunc(hdr->frame_control))\n\t\treturn TX_DROP;\n\tif (tx->sdata->vif.type == NL80211_IFTYPE_WDS)\n\t\treturn TX_CONTINUE;\n\tif (tx->sdata->vif.type == NL80211_IFTYPE_MESH_POINT)\n\t\treturn TX_CONTINUE;\n\tif (tx->flags & IEEE80211_TX_PS_BUFFERED)\n\t\treturn TX_CONTINUE;\n\tif (tx->sta)\n\t\tassoc = test_sta_flag(tx->sta, WLAN_STA_ASSOC);\n\tif (likely(tx->flags & IEEE80211_TX_UNICAST)) {\n\t\tif (unlikely(!assoc &&\n\t\t\t     ieee80211_is_data(hdr->frame_control))) {\n#ifdef CONFIG_MAC80211_VERBOSE_DEBUG\n\t\t\tsdata_info(tx->sdata,\n\t\t\t\t   \"dropped data frame to not associated station %pM\\n\",\n\t\t\t\t   hdr->addr1);\n#endif\n\t\t\tI802_DEBUG_INC(tx->local->tx_handlers_drop_not_assoc);\n\t\t\treturn TX_DROP;\n\t\t}\n\t} else if (unlikely(tx->sdata->vif.type == NL80211_IFTYPE_AP &&\n\t\t\t    ieee80211_is_data(hdr->frame_control) &&\n\t\t\t    !atomic_read(&tx->sdata->u.ap.num_mcast_sta))) {\n\t\treturn TX_DROP;\n\t}\n\treturn TX_CONTINUE;\n}", "target": 0}
{"code": "static int old_dsa_priv_encode(const EVP_PKEY *pkey, unsigned char **pder)\n{\n    return i2d_DSAPrivateKey(pkey->pkey.dsa, pder);\n}", "target": 0}
{"code": "SampleEncrypter::EncryptAudioSample(AP4_DataBuffer& sample, AP4_SampleDescription* sample_description)\n{\n    if (sample.GetDataSize() <= 16) {\n        return AP4_SUCCESS;\n    }\n    if (sample_description->GetFormat() == AP4_SAMPLE_FORMAT_EC_3) {\n        AP4_UI08*    data      = sample.UseData();\n        unsigned int data_size = sample.GetDataSize();\n        while (data_size > 4) {\n            unsigned int syncword = (data[0]<<8) | data[1];\n            if (syncword != 0x0b77) {\n                return AP4_ERROR_INVALID_FORMAT; \n            }\n            unsigned int frmsiz = 1+(((data[2]<<8)|(data[3]))&0x7FF);\n            unsigned int frame_size = 2*frmsiz;\n            if (data_size < frame_size) {\n                return AP4_ERROR_INVALID_FORMAT; \n            }\n            if (frame_size > 16) {\n                unsigned int encrypted_block_count = (frame_size-16)/16;\n                AP4_Size encrypted_size = encrypted_block_count*16;\n                m_StreamCipher->SetIV(m_IV);\n                m_StreamCipher->ProcessBuffer(data+16, encrypted_size, data+16, &encrypted_size);\n            }\n            data      += frame_size;\n            data_size -= frame_size;\n        }\n    } else {\n        unsigned int encrypted_block_count = (sample.GetDataSize()-16)/16;\n        AP4_Size encrypted_size = encrypted_block_count*16;\n        m_StreamCipher->SetIV(m_IV);\n        m_StreamCipher->ProcessBuffer(sample.UseData()+16, encrypted_size, sample.UseData()+16, &encrypted_size);\n    }\n    return AP4_SUCCESS;\n}", "target": 0}
{"code": "void RequestContext::SetApiKeyHeader() {\n  request_->AddHeaderToBackend(kDefaultApiKeyHeaderName, api_key_);\n}", "target": 1}
{"code": "int get_netnsid_from_name(const char *name)\n{\n\tstruct {\n\t\tstruct nlmsghdr n;\n\t\tstruct rtgenmsg g;\n\t\tchar            buf[1024];\n\t} req = {\n\t\t.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct rtgenmsg)),\n\t\t.n.nlmsg_flags = NLM_F_REQUEST,\n\t\t.n.nlmsg_type = RTM_GETNSID,\n\t\t.g.rtgen_family = AF_UNSPEC,\n\t};\n\tstruct nlmsghdr *answer;\n\tstruct rtattr *tb[NETNSA_MAX + 1];\n\tstruct rtgenmsg *rthdr;\n\tint len, fd;\n\tnetns_nsid_socket_init();\n\tfd = netns_get_fd(name);\n\tif (fd < 0)\n\t\treturn fd;\n\taddattr32(&req.n, 1024, NETNSA_FD, fd);\n\tif (rtnl_talk(&rtnsh, &req.n, &answer) < 0) {\n\t\tclose(fd);\n\t\treturn -2;\n\t}\n\tclose(fd);\n\tif (answer->nlmsg_type == NLMSG_ERROR)\n\t\tgoto err_out;\n\trthdr = NLMSG_DATA(answer);\n\tlen = answer->nlmsg_len - NLMSG_SPACE(sizeof(*rthdr));\n\tif (len < 0)\n\t\tgoto err_out;\n\tparse_rtattr(tb, NETNSA_MAX, NETNS_RTA(rthdr), len);\n\tif (tb[NETNSA_NSID]) {\n\t\tfree(answer);\n\t\treturn rta_getattr_u32(tb[NETNSA_NSID]);\n\t}\nerr_out:\n\tfree(answer);\n\treturn -1;\n}", "target": 1}
{"code": "static void dup_xol_work(struct callback_head *work)\n{\n\tif (current->flags & PF_EXITING)\n\t\treturn;\n\tif (!__create_xol_area(current->utask->dup_xol_addr) &&\n\t\t\t!fatal_signal_pending(current))\n\t\tuprobe_warn(current, \"dup xol area\");\n}", "target": 0}
{"code": "xfs_iunlink_init(\n\tstruct xfs_perag\t*pag)\n{\n\treturn rhashtable_init(&pag->pagi_unlinked_hash,\n\t\t\t&xfs_iunlink_hash_params);\n}", "target": 0}
{"code": "static pfn_t kvm_pin_pages(struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t   unsigned long size)\n{\n\tgfn_t end_gfn;\n\tpfn_t pfn;\n\tpfn     = gfn_to_pfn_memslot(slot, gfn);\n\tend_gfn = gfn + (size >> PAGE_SHIFT);\n\tgfn    += 1;\n\tif (is_error_noslot_pfn(pfn))\n\t\treturn pfn;\n\twhile (gfn < end_gfn)\n\t\tgfn_to_pfn_memslot(slot, gfn++);\n\treturn pfn;\n}", "target": 1}
{"code": "soup_client_context_new (SoupServer *server, SoupSocket *sock)\n{\n\tSoupClientContext *client = g_slice_new0 (SoupClientContext);\n\tclient->server = server;\n\tclient->sock = sock;\n\tclient->ref_count = 1;\n\treturn client;\n}", "target": 0}
{"code": "set_tagstack(win_T *wp, dict_T *d, int action)\n{\n    dictitem_T\t*di;\n    list_T\t*l = NULL;\n#ifdef FEAT_EVAL\n    if (tfu_in_use)\n    {\n\temsg(_(e_cannot_modify_tag_stack_within_tagfunc));\n\treturn FAIL;\n    }\n#endif\n    if ((di = dict_find(d, (char_u *)\"items\", -1)) != NULL)\n    {\n\tif (di->di_tv.v_type != VAR_LIST)\n\t{\n\t    emsg(_(e_list_required));\n\t    return FAIL;\n\t}\n\tl = di->di_tv.vval.v_list;\n    }\n    if ((di = dict_find(d, (char_u *)\"curidx\", -1)) != NULL)\n\ttagstack_set_curidx(wp, (int)tv_get_number(&di->di_tv) - 1);\n    if (action == 't')\t\t    \n    {\n\ttaggy_T\t*tagstack = wp->w_tagstack;\n\tint\ttagstackidx = wp->w_tagstackidx;\n\tint\ttagstacklen = wp->w_tagstacklen;\n\twhile (tagstackidx < tagstacklen)\n\t    tagstack_clear_entry(&tagstack[--tagstacklen]);\n\twp->w_tagstacklen = tagstacklen;\n    }\n    if (l != NULL)\n    {\n\tif (action == 'r')\t\t\n\t    tagstack_clear(wp);\n\ttagstack_push_items(wp, l);\n\twp->w_tagstackidx = wp->w_tagstacklen;\n    }\n    return OK;\n}", "target": 0}
{"code": "test_save_copy (const char *origname)\n{\n  char buf[TESTBUFSIZE];\n  int ret;\n  snprintf_func (buf, TESTBUFSIZE, \"cp -f %s %s\", origname, TEST_COPY_FILE);\n  if ((ret = system (buf)) != 0)\n    {\n      return XD3_INTERNAL;\n    }\n  return 0;\n}", "target": 1}
{"code": "snmp_mib_find_next(uint32_t *oid)\n{\n  snmp_mib_resource_t *resource;\n  resource = NULL;\n  for(resource = list_head(snmp_mib);\n      resource; resource = resource->next) {\n    if(snmp_oid_cmp_oid(resource->oid, oid) > 0) {\n      return resource;\n    }\n  }\n  return NULL;\n}", "target": 1}
{"code": "static void bnx2x_free_mcast_macs_list(struct list_head *mcast_group_list)\n{\n\tstruct bnx2x_mcast_list_elem_group *current_mcast_group;\n\twhile (!list_empty(mcast_group_list)) {\n\t\tcurrent_mcast_group = list_first_entry(mcast_group_list,\n\t\t\t\t      struct bnx2x_mcast_list_elem_group,\n\t\t\t\t      mcast_group_link);\n\t\tlist_del(&current_mcast_group->mcast_group_link);\n\t\tfree_page((unsigned long)current_mcast_group);\n\t}\n}", "target": 0}
{"code": "static int mov_read_dfla(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    int last, type, size, ret;\n    uint8_t buf[4];\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    if ((uint64_t)atom.size > (1<<30) || atom.size < 42)\n        return AVERROR_INVALIDDATA;\n    if (avio_r8(pb) != 0)\n        return AVERROR_INVALIDDATA;\n    avio_rb24(pb); \n    if (avio_read(pb, buf, sizeof(buf)) != sizeof(buf)) {\n        av_log(c->fc, AV_LOG_ERROR, \"failed to read FLAC metadata block header\\n\");\n        return pb->error < 0 ? pb->error : AVERROR_INVALIDDATA;\n    }\n    flac_parse_block_header(buf, &last, &type, &size);\n    if (type != FLAC_METADATA_TYPE_STREAMINFO || size != FLAC_STREAMINFO_SIZE) {\n        av_log(c->fc, AV_LOG_ERROR, \"STREAMINFO must be first FLACMetadataBlock\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    ret = ff_get_extradata(c->fc, st->codecpar, pb, size);\n    if (ret < 0)\n        return ret;\n    if (!last)\n        av_log(c->fc, AV_LOG_WARNING, \"non-STREAMINFO FLACMetadataBlock(s) ignored\\n\");\n    return 0;\n}", "target": 0}
{"code": "    size_t MemIo::write(BasicIo& src)\n    {\n        if (static_cast<BasicIo*>(this) == &src) return 0;\n        if (!src.isopen()) return 0;\n        byte buf[4096];\n        size_t readCount = 0;\n        size_t writeTotal = 0;\n        while ((readCount = src.read(buf, sizeof(buf)))) {\n            write(buf, readCount);\n            writeTotal += readCount;\n        }\n        return writeTotal;\n    }", "target": 0}
{"code": "SQLWCHAR* _single_string_alloc_and_expand( LPCSTR in )\n{\n    SQLWCHAR *chr;\n    int len = 0;\n    if ( !in )\n    {\n        return in;\n    }\n    while ( in[ len ] != 0 )\n    {\n        len ++;\n    }\n    chr = malloc( sizeof( SQLWCHAR ) * ( len + 1 ));\n    len = 0;\n    while ( in[ len ] != 0 )\n    {\n        chr[ len ] = in[ len ];\n        len ++;\n    }\n    chr[ len ++ ] = 0;\n    return chr;\n}", "target": 1}
{"code": "void kvm_arch_vcpu_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\tif (need_emulate_wbinvd(vcpu)) {\n\t\tif (kvm_x86_ops->has_wbinvd_exit())\n\t\t\tcpumask_set_cpu(cpu, vcpu->arch.wbinvd_dirty_mask);\n\t\telse if (vcpu->cpu != -1 && vcpu->cpu != cpu)\n\t\t\tsmp_call_function_single(vcpu->cpu,\n\t\t\t\t\twbinvd_ipi, NULL, 1);\n\t}\n\tkvm_x86_ops->vcpu_load(vcpu, cpu);\n\tif (unlikely(vcpu->arch.tsc_offset_adjustment)) {\n\t\tadjust_tsc_offset_host(vcpu, vcpu->arch.tsc_offset_adjustment);\n\t\tvcpu->arch.tsc_offset_adjustment = 0;\n\t\tset_bit(KVM_REQ_CLOCK_UPDATE, &vcpu->requests);\n\t}\n\tif (unlikely(vcpu->cpu != cpu) || check_tsc_unstable()) {\n\t\ts64 tsc_delta = !vcpu->arch.last_host_tsc ? 0 :\n\t\t\t\tnative_read_tsc() - vcpu->arch.last_host_tsc;\n\t\tif (tsc_delta < 0)\n\t\t\tmark_tsc_unstable(\"KVM discovered backwards TSC\");\n\t\tif (check_tsc_unstable()) {\n\t\t\tu64 offset = kvm_x86_ops->compute_tsc_offset(vcpu,\n\t\t\t\t\t\tvcpu->arch.last_guest_tsc);\n\t\t\tkvm_x86_ops->write_tsc_offset(vcpu, offset);\n\t\t\tvcpu->arch.tsc_catchup = 1;\n\t\t}\n\t\tif (!vcpu->kvm->arch.use_master_clock || vcpu->cpu == -1)\n\t\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\t\tif (vcpu->cpu != cpu)\n\t\t\tkvm_migrate_timers(vcpu);\n\t\tvcpu->cpu = cpu;\n\t}\n\taccumulate_steal_time(vcpu);\n\tkvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);\n}", "target": 0}
{"code": "cdf_read_sector(const cdf_info_t *info, void *buf, size_t offs, size_t len,\n    const cdf_header_t *h, cdf_secid_t id)\n{\n\tassert((size_t)CDF_SEC_SIZE(h) == len);\n\treturn cdf_read(info, (off_t)CDF_SEC_POS(h, id),\n\t    ((char *)buf) + offs, len);\n}", "target": 1}
{"code": "const char* NavigatorServiceWorker::supplementName()\n{\n     return \"NavigatorServiceWorker\";\n }", "target": 0}
{"code": "static void agent_connect(UdscsConnection *conn)\n{\n    struct agent_data *agent_data;\n    agent_data = g_new0(struct agent_data, 1);\n    GError *err = NULL;\n    if (session_info) {\n        PidUid pid_uid = vdagent_connection_get_peer_pid_uid(VDAGENT_CONNECTION(conn), &err);\n        if (err || pid_uid.pid <= 0) {\n            static const char msg[] = \"Could not get peer PID, disconnecting new client\";\n            if (err) {\n                syslog(LOG_ERR, \"%s: %s\", msg, err->message);\n                g_error_free(err);\n            } else {\n                syslog(LOG_ERR, \"%s\", msg);\n            }\n            agent_data_destroy(agent_data);\n            udscs_server_destroy_connection(server, conn);\n            return;\n        }\n        agent_data->session = session_info_session_for_pid(session_info, pid_uid.pid);\n        if (!check_uid_of_pid(pid_uid.pid, pid_uid.uid)) {\n            agent_data_destroy(agent_data);\n            udscs_server_destroy_connection(server, conn);\n            return;\n        }\n    }\n    g_object_set_data_full(G_OBJECT(conn), \"agent_data\", agent_data,\n                           (GDestroyNotify) agent_data_destroy);\n    udscs_write(conn, VDAGENTD_VERSION, 0, 0,\n                (uint8_t *)VERSION, strlen(VERSION) + 1);\n    update_active_session_connection(conn);\n    if (device_info) {\n        forward_data_to_session_agent(VDAGENTD_GRAPHICS_DEVICE_INFO,\n                                      (uint8_t *) device_info, device_info_size);\n    }\n}", "target": 1}
{"code": "static void vcc_sock_destruct(struct sock *sk)\n{\n\tif (atomic_read(&sk->sk_rmem_alloc))\n\t\tprintk(KERN_DEBUG \"%s: rmem leakage (%d bytes) detected.\\n\",\n\t\t       __func__, atomic_read(&sk->sk_rmem_alloc));\n\tif (atomic_read(&sk->sk_wmem_alloc))\n\t\tprintk(KERN_DEBUG \"%s: wmem leakage (%d bytes) detected.\\n\",\n\t\t       __func__, atomic_read(&sk->sk_wmem_alloc));\n}", "target": 0}
{"code": "static ssize_t _nfsd_copy_file_range(struct nfsd4_copy *copy)\n{\n\tssize_t bytes_copied = 0;\n\tsize_t bytes_total = copy->cp_count;\n\tu64 src_pos = copy->cp_src_pos;\n\tu64 dst_pos = copy->cp_dst_pos;\n\tdo {\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\t\tbytes_copied = nfsd_copy_file_range(copy->file_src, src_pos,\n\t\t\t\tcopy->file_dst, dst_pos, bytes_total);\n\t\tif (bytes_copied <= 0)\n\t\t\tbreak;\n\t\tbytes_total -= bytes_copied;\n\t\tcopy->cp_res.wr_bytes_written += bytes_copied;\n\t\tsrc_pos += bytes_copied;\n\t\tdst_pos += bytes_copied;\n\t} while (bytes_total > 0 && !copy->cp_synchronous);\n\treturn bytes_copied;\n}", "target": 0}
{"code": "GF_Err diST_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tchar str[1024];\n\tGF_DIMSScriptTypesBox *p = (GF_DIMSScriptTypesBox *)s;\n\ti=0;\n\tstr[0]=0;\n\twhile (1) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tif (!str[i]) break;\n\t\ti++;\n\t}\n\tISOM_DECREASE_SIZE(p, i);\n\tp->content_script_types = gf_strdup(str);\n\treturn GF_OK;\n}", "target": 1}
{"code": "struct net *get_net_ns_by_id(struct net *net, int id)\n{\n\tstruct net *peer;\n\tif (id < 0)\n\t\treturn NULL;\n\trcu_read_lock();\n\tspin_lock_bh(&net->nsid_lock);\n\tpeer = idr_find(&net->netns_ids, id);\n\tif (peer)\n\t\tget_net(peer);\n\tspin_unlock_bh(&net->nsid_lock);\n\trcu_read_unlock();\n\treturn peer;\n}", "target": 1}
{"code": "void CefLayeredWindowUpdaterOSR::OnAllocatedSharedMemory(\n    const gfx::Size& pixel_size,\n    base::UnsafeSharedMemoryRegion region) {\n  size_t expected_bytes;\n  bool size_result = viz::ResourceSizes::MaybeSizeInBytes(\n      pixel_size, viz::SinglePlaneFormat::kRGBA_8888, &expected_bytes);\n  if (!size_result) {\n    return;\n  }\n  pixel_size_ = pixel_size;\n  shared_memory_ = region.Map();\n  DCHECK(shared_memory_.IsValid());\n}", "target": 1}
{"code": "static void build_probe_list(struct inode *inode,\n\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\tunsigned long start, unsigned long end,\n\t\t\t\tstruct list_head *head)\n{\n\tloff_t min, max;\n\tstruct rb_node *n, *t;\n\tstruct uprobe *u;\n\tINIT_LIST_HEAD(head);\n\tmin = vaddr_to_offset(vma, start);\n\tmax = min + (end - start) - 1;\n\tspin_lock(&uprobes_treelock);\n\tn = find_node_in_range(inode, min, max);\n\tif (n) {\n\t\tfor (t = n; t; t = rb_prev(t)) {\n\t\t\tu = rb_entry(t, struct uprobe, rb_node);\n\t\t\tif (u->inode != inode || u->offset < min)\n\t\t\t\tbreak;\n\t\t\tlist_add(&u->pending_list, head);\n\t\t\tget_uprobe(u);\n\t\t}\n\t\tfor (t = n; (t = rb_next(t)); ) {\n\t\t\tu = rb_entry(t, struct uprobe, rb_node);\n\t\t\tif (u->inode != inode || u->offset > max)\n\t\t\t\tbreak;\n\t\t\tlist_add(&u->pending_list, head);\n\t\t\tget_uprobe(u);\n\t\t}\n\t}\n\tspin_unlock(&uprobes_treelock);\n}", "target": 0}
{"code": "int Archive::Read(void *Data,size_t Size)\n{\n  size_t Result;\n  if (QOpen.Read(Data,Size,Result))\n    return (int)Result;\n  return File::Read(Data,Size);\n}", "target": 1}
{"code": "static int target_xcopy_locate_se_dev_e4(const unsigned char *dev_wwn,\n\t\t\t\t\tstruct se_device **found_dev)\n{\n\tstruct xcopy_dev_search_info info;\n\tint ret;\n\tmemset(&info, 0, sizeof(info));\n\tinfo.dev_wwn = dev_wwn;\n\tret = target_for_each_device(target_xcopy_locate_se_dev_e4_iter, &info);\n\tif (ret == 1) {\n\t\t*found_dev = info.found_dev;\n\t\treturn 0;\n\t} else {\n\t\tpr_debug_ratelimited(\"Unable to locate 0xe4 descriptor for EXTENDED_COPY\\n\");\n\t\treturn -EINVAL;\n\t}\n}", "target": 1}
{"code": "  inline Eigen::IndexList<Eigen::type2index<1>, int> OneByM(int m) {\n    Eigen::IndexList<Eigen::type2index<1>, int> ret;\n    ret.set(1, m);\n    return ret;\n  }", "target": 1}
{"code": "static void blk_mq_queue_reinit(struct request_queue *q)\n{\n\tWARN_ON_ONCE(!atomic_read(&q->mq_freeze_depth));\n\tblk_mq_sysfs_unregister(q);\n\tblk_mq_update_queue_map(q->mq_map, q->nr_hw_queues);\n\tblk_mq_map_swqueue(q);\n\tblk_mq_sysfs_register(q);\n}", "target": 0}
{"code": "static void move_msr_up(struct vcpu_vmx *vmx, int from, int to)\n{\n\tstruct shared_msr_entry tmp;\n\ttmp = vmx->guest_msrs[to];\n\tvmx->guest_msrs[to] = vmx->guest_msrs[from];\n\tvmx->guest_msrs[from] = tmp;\n}", "target": 0}
{"code": "void setup_work_tree(void)\n{\n\tconst char *work_tree, *git_dir;\n\tstatic int initialized = 0;\n\tif (initialized)\n\t\treturn;\n\twork_tree = get_git_work_tree();\n\tgit_dir = get_git_dir();\n\tif (!is_absolute_path(git_dir))\n\t\tset_git_dir(make_absolute_path(git_dir));\n\tif (!work_tree || chdir(work_tree))\n\t\tdie(\"This operation must be run in a work tree\");\n\tinitialized = 1;\n}", "target": 0}
{"code": "ZEND_API void zend_objects_store_del_ref_by_handle_ex(zend_object_handle handle, const zend_object_handlers *handlers TSRMLS_DC) \n{\n\tstruct _store_object *obj;\n\tint failure = 0;\n\tif (!EG(objects_store).object_buckets) {\n\t\treturn;\n\t}\n\tobj = &EG(objects_store).object_buckets[handle].bucket.obj;\n\tif (EG(objects_store).object_buckets[handle].valid) {\n\t\tif (obj->refcount == 1) {\n\t\t\tif (!EG(objects_store).object_buckets[handle].destructor_called) {\n\t\t\t\tEG(objects_store).object_buckets[handle].destructor_called = 1;\n\t\t\t\tif (obj->dtor) {\n\t\t\t\t\tif (handlers && !obj->handlers) {\n\t\t\t\t\t\tobj->handlers = handlers;\n\t\t\t\t\t}\n\t\t\t\t\tzend_try {\n\t\t\t\t\t\tobj->dtor(obj->object, handle TSRMLS_CC);\n\t\t\t\t\t} zend_catch {\n\t\t\t\t\t\tfailure = 1;\n\t\t\t\t\t} zend_end_try();\n\t\t\t\t}\n\t\t\t}\n\t\t\tobj = &EG(objects_store).object_buckets[handle].bucket.obj;\n\t\t\tif (obj->refcount == 1) {\n\t\t\t\tGC_REMOVE_ZOBJ_FROM_BUFFER(obj);\n\t\t\t\tif (obj->free_storage) {\n\t\t\t\t\tzend_try {\n\t\t\t\t\t\tobj->free_storage(obj->object TSRMLS_CC);\n\t\t\t\t\t} zend_catch {\n\t\t\t\t\t\tfailure = 1;\n\t\t\t\t\t} zend_end_try();\n\t\t\t\t}\n\t\t\t\tZEND_OBJECTS_STORE_ADD_TO_FREE_LIST();\n\t\t\t}\n\t\t}\n\t}\n\tobj->refcount--;\n#if ZEND_DEBUG_OBJECTS\n\tif (obj->refcount == 0) {\n\t\tfprintf(stderr, \"Deallocated object id #%d\\n\", handle);\n\t} else {\n\t\tfprintf(stderr, \"Decreased refcount of object id #%d\\n\", handle);\n\t}\n#endif\n\tif (failure) {\n\t\tzend_bailout();\n\t}\n}", "target": 1}
{"code": "static void ram_block_add(struct uc_struct *uc, RAMBlock *new_block)\n{\n    RAMBlock *block;\n    RAMBlock *last_block = NULL;\n    new_block->offset = find_ram_offset(uc, new_block->max_length);\n    if (!new_block->host) {\n        new_block->host = phys_mem_alloc(uc, new_block->max_length,\n                &new_block->mr->align);\n        if (!new_block->host) {\n            return;\n        }\n    }\n    RAMBLOCK_FOREACH(block) {\n        last_block = block;\n        if (block->max_length < new_block->max_length) {\n            break;\n        }\n    }\n    if (block) {\n        QLIST_INSERT_BEFORE(block, new_block, next);\n    } else if (last_block) {\n        QLIST_INSERT_AFTER(last_block, new_block, next);\n    } else { \n        QLIST_INSERT_HEAD(&uc->ram_list.blocks, new_block, next);\n    }\n    uc->ram_list.mru_block = NULL;\n    cpu_physical_memory_set_dirty_range(new_block->offset,\n                                        new_block->used_length,\n                                        DIRTY_CLIENTS_ALL);\n}", "target": 1}
{"code": "address_space_translate_for_iotlb(CPUState *cpu, int asidx, hwaddr addr,\n                                  hwaddr *xlat, hwaddr *plen,\n                                  MemTxAttrs attrs, int *prot)\n{\n    MemoryRegionSection *section;\n    IOMMUMemoryRegion *iommu_mr;\n    IOMMUMemoryRegionClass *imrc;\n    IOMMUTLBEntry iotlb;\n    int iommu_idx;\n    AddressSpaceDispatch *d =\n        qatomic_rcu_read(&cpu->cpu_ases[asidx].memory_dispatch);\n    for (;;) {\n        section = address_space_translate_internal(d, addr, &addr, plen, false);\n        iommu_mr = memory_region_get_iommu(section->mr);\n        if (!iommu_mr) {\n            break;\n        }\n        imrc = memory_region_get_iommu_class_nocheck(iommu_mr);\n        iommu_idx = imrc->attrs_to_index(iommu_mr, attrs);\n        tcg_register_iommu_notifier(cpu, iommu_mr, iommu_idx);\n        iotlb = imrc->translate(iommu_mr, addr, IOMMU_NONE, iommu_idx);\n        addr = ((iotlb.translated_addr & ~iotlb.addr_mask)\n                | (addr & iotlb.addr_mask));\n        if (!(iotlb.perm & IOMMU_RO)) {\n            *prot &= ~(PAGE_READ | PAGE_EXEC);\n        }\n        if (!(iotlb.perm & IOMMU_WO)) {\n            *prot &= ~PAGE_WRITE;\n        }\n        if (!*prot) {\n            goto translate_fail;\n        }\n        d = flatview_to_dispatch(address_space_to_flatview(iotlb.target_as));\n    }\n    assert(!memory_region_is_iommu(section->mr));\n    *xlat = addr;\n    return section;\ntranslate_fail:\n    return &d->map.sections[PHYS_SECTION_UNASSIGNED];\n}", "target": 1}
{"code": "static dma_addr_t __intel_map_single(struct device *dev, phys_addr_t paddr,\n\t\t\t\t     size_t size, int dir, u64 dma_mask)\n{\n\tstruct dmar_domain *domain;\n\tphys_addr_t start_paddr;\n\tunsigned long iova_pfn;\n\tint prot = 0;\n\tint ret;\n\tstruct intel_iommu *iommu;\n\tunsigned long paddr_pfn = paddr >> PAGE_SHIFT;\n\tBUG_ON(dir == DMA_NONE);\n\tif (iommu_no_mapping(dev))\n\t\treturn paddr;\n\tdomain = get_valid_domain_for_dev(dev);\n\tif (!domain)\n\t\treturn DMA_MAPPING_ERROR;\n\tiommu = domain_get_iommu(domain);\n\tsize = aligned_nrpages(paddr, size);\n\tiova_pfn = intel_alloc_iova(dev, domain, dma_to_mm_pfn(size), dma_mask);\n\tif (!iova_pfn)\n\t\tgoto error;\n\tif (dir == DMA_TO_DEVICE || dir == DMA_BIDIRECTIONAL || \\\n\t\t\t!cap_zlr(iommu->cap))\n\t\tprot |= DMA_PTE_READ;\n\tif (dir == DMA_FROM_DEVICE || dir == DMA_BIDIRECTIONAL)\n\t\tprot |= DMA_PTE_WRITE;\n\tret = domain_pfn_mapping(domain, mm_to_dma_pfn(iova_pfn),\n\t\t\t\t mm_to_dma_pfn(paddr_pfn), size, prot);\n\tif (ret)\n\t\tgoto error;\n\tstart_paddr = (phys_addr_t)iova_pfn << PAGE_SHIFT;\n\tstart_paddr += paddr & ~PAGE_MASK;\n\treturn start_paddr;\nerror:\n\tif (iova_pfn)\n\t\tfree_iova_fast(&domain->iovad, iova_pfn, dma_to_mm_pfn(size));\n\tdev_err(dev, \"Device request: %zx@%llx dir %d --- failed\\n\",\n\t\tsize, (unsigned long long)paddr, dir);\n\treturn DMA_MAPPING_ERROR;\n}", "target": 0}
{"code": "static int init_nss_hash(struct crypto_instance *instance)\n{\n\tPK11SlotInfo*\thash_slot = NULL;\n\tSECItem\t\thash_param;\n\tif (!hash_to_nss[instance->crypto_hash_type]) {\n\t\treturn 0;\n\t}\n\thash_param.type = siBuffer;\n\thash_param.data = 0;\n\thash_param.len = 0;\n\thash_slot = PK11_GetBestSlot(hash_to_nss[instance->crypto_hash_type], NULL);\n\tif (hash_slot == NULL) {\n\t\tlog_printf(instance->log_level_security, \"Unable to find security slot (err %d)\",\n\t\t\t   PR_GetError());\n\t\treturn -1;\n\t}\n\tinstance->nss_sym_key_sign = PK11_ImportSymKey(hash_slot,\n\t\t\t\t\t\t       hash_to_nss[instance->crypto_hash_type],\n\t\t\t\t\t\t       PK11_OriginUnwrap, CKA_SIGN,\n\t\t\t\t\t\t       &hash_param, NULL);\n\tif (instance->nss_sym_key_sign == NULL) {\n\t\tlog_printf(instance->log_level_security, \"Failure to import key into NSS (err %d)\",\n\t\t\t   PR_GetError());\n\t\treturn -1;\n\t}\n\tPK11_FreeSlot(hash_slot);\n\treturn 0;\n}", "target": 1}
{"code": "static inline pgd_t *pgd_alloc(struct mm_struct *mm)\n{\n\tspin_lock_init(&mm->context.list_lock);\n\tINIT_LIST_HEAD(&mm->context.pgtable_list);\n\tINIT_LIST_HEAD(&mm->context.gmap_list);\n\treturn (pgd_t *) crst_table_alloc(mm);\n}", "target": 1}
{"code": "int main(int argc, char **argv)\n{\n    int fd;\n    int ret;\n    fd = mkstemp(test_image);\n    g_assert(fd >= 0);\n    ret = ftruncate(fd, TEST_IMAGE_SIZE);\n    g_assert(ret == 0);\n    close(fd);\n    g_test_init(&argc, &argv, NULL);\n    qtest_start(\"-machine pc -device floppy,id=floppy0\");\n    qtest_irq_intercept_in(global_qtest, \"ioapic\");\n    qtest_add_func(\"/fdc/cmos\", test_cmos);\n    qtest_add_func(\"/fdc/no_media_on_start\", test_no_media_on_start);\n    qtest_add_func(\"/fdc/read_without_media\", test_read_without_media);\n    qtest_add_func(\"/fdc/media_change\", test_media_change);\n    qtest_add_func(\"/fdc/sense_interrupt\", test_sense_interrupt);\n    qtest_add_func(\"/fdc/relative_seek\", test_relative_seek);\n    qtest_add_func(\"/fdc/read_id\", test_read_id);\n    qtest_add_func(\"/fdc/verify\", test_verify);\n    qtest_add_func(\"/fdc/media_insert\", test_media_insert);\n    qtest_add_func(\"/fdc/read_no_dma_1\", test_read_no_dma_1);\n    qtest_add_func(\"/fdc/read_no_dma_18\", test_read_no_dma_18);\n    qtest_add_func(\"/fdc/read_no_dma_19\", test_read_no_dma_19);\n    qtest_add_func(\"/fdc/fuzz-registers\", fuzz_registers);\n    qtest_add_func(\"/fdc/fuzz/cve_2021_20196\", test_cve_2021_20196);\n    ret = g_test_run();\n    qtest_end();\n    unlink(test_image);\n    return ret;\n}", "target": 1}
{"code": "static void nlmclnt_unlock_callback(struct rpc_task *task, void *data)\n{\n\tstruct nlm_rqst\t*req = data;\n\tu32 status = ntohl(req->a_res.status);\n\tif (RPC_ASSASSINATED(task))\n\t\tgoto die;\n\tif (task->tk_status < 0) {\n\t\tdprintk(\"lockd: unlock failed (err = %d)\\n\", -task->tk_status);\n\t\tgoto retry_rebind;\n\t}\n\tif (status == NLM_LCK_DENIED_GRACE_PERIOD) {\n\t\trpc_delay(task, NLMCLNT_GRACE_WAIT);\n\t\tgoto retry_unlock;\n\t}\n\tif (status != NLM_LCK_GRANTED)\n\t\tprintk(KERN_WARNING \"lockd: unexpected unlock status: %d\\n\", status);\ndie:\n\treturn;\n retry_rebind:\n\tnlm_rebind_host(req->a_host);\n retry_unlock:\n\trpc_restart_call(task);\n}", "target": 1}
{"code": "static int decode_secinfo_common(struct xdr_stream *xdr, struct nfs4_secinfo_res *res)\n{\n\tstruct nfs4_secinfo_flavor *sec_flavor;\n\tint status;\n\t__be32 *p;\n\tint i, num_flavors;\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\tgoto out_overflow;\n\tres->flavors->num_flavors = 0;\n\tnum_flavors = be32_to_cpup(p);\n\tfor (i = 0; i < num_flavors; i++) {\n\t\tsec_flavor = &res->flavors->flavors[i];\n\t\tif ((char *)&sec_flavor[1] - (char *)res->flavors > PAGE_SIZE)\n\t\t\tbreak;\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\tgoto out_overflow;\n\t\tsec_flavor->flavor = be32_to_cpup(p);\n\t\tif (sec_flavor->flavor == RPC_AUTH_GSS) {\n\t\t\tstatus = decode_secinfo_gss(xdr, sec_flavor);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t}\n\t\tres->flavors->num_flavors++;\n\t}\n\tstatus = 0;\nout:\n\treturn status;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}", "target": 0}
{"code": "init_ctx_reselect(OM_uint32 *minor_status, spnego_gss_ctx_id_t sc,\n\t\t  OM_uint32 acc_negState, gss_OID supportedMech,\n\t\t  gss_buffer_t *responseToken, gss_buffer_t *mechListMIC,\n\t\t  OM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 tmpmin;\n\tsize_t i;\n\tgeneric_gss_release_oid(&tmpmin, &sc->internal_mech);\n\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n\t\t\t       GSS_C_NO_BUFFER);\n\tfor (i = 0; i < sc->mech_set->count; i++) {\n\t\tif (g_OID_equal(supportedMech, &sc->mech_set->elements[i]))\n\t\t\tbreak;\n\t}\n\tif (i == sc->mech_set->count)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tsc->internal_mech = &sc->mech_set->elements[i];\n\tif (acc_negState != REQUEST_MIC)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tsc->mech_complete = 0;\n\tsc->mic_reqd = 1;\n\t*negState = REQUEST_MIC;\n\t*tokflag = CONT_TOKEN_SEND;\n\treturn GSS_S_CONTINUE_NEEDED;\n}", "target": 1}
{"code": "key_ref_t keyring_search(key_ref_t keyring,\n\t\t\t struct key_type *type,\n\t\t\t const char *description)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= type,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= type->match,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tkey_ref_t key;\n\tint ret;\n\tif (!ctx.match_data.cmp)\n\t\treturn ERR_PTR(-ENOKEY);\n\tif (type->match_preparse) {\n\t\tret = type->match_preparse(&ctx.match_data);\n\t\tif (ret < 0)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\tkey = keyring_search_aux(keyring, &ctx);\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\n\treturn key;\n}", "target": 1}
{"code": "static apr_byte_t oidc_validate_post_logout_url(request_rec *r, const char *url,\n\t\tchar **err_str, char **err_desc) {\n\tapr_uri_t uri;\n\tconst char *c_host = NULL;\n\tif (apr_uri_parse(r->pool, url, &uri) != APR_SUCCESS) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Malformed URL\");\n\t\t*err_desc = apr_psprintf(r->pool, \"Logout URL malformed: %s\", url);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t}\n\tc_host = oidc_get_current_url_host(r);\n\tif ((uri.hostname != NULL)\n\t\t\t&& ((strstr(c_host, uri.hostname) == NULL)\n\t\t\t\t\t|| (strstr(uri.hostname, c_host) == NULL))) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Invalid Request\");\n\t\t*err_desc =\n\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"logout value \\\"%s\\\" does not match the hostname of the current request \\\"%s\\\"\",\n\t\t\t\t\t\tapr_uri_unparse(r->pool, &uri, 0), c_host);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t} else if (strstr(url, \"/\") != url) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Malformed URL\");\n\t\t*err_desc =\n\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"No hostname was parsed and it does not seem to be relative, i.e starting with '/': %s\",\n\t\t\t\t\t\turl);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t}\n\tif (((strstr(url, \"\\n\") != NULL) || strstr(url, \"\\r\") != NULL)) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Invalid Request\");\n\t\t*err_desc =\n\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"logout value \\\"%s\\\" contains illegal \\\"\\n\\\" or \\\"\\r\\\" character(s)\",\n\t\t\t\t\t\turl);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "static UINT rdpei_recv_pdu(RDPEI_CHANNEL_CALLBACK* callback, wStream* s)\n{\n\tUINT16 eventId;\n\tUINT32 pduLength;\n\tUINT error;\n\tStream_Read_UINT16(s, eventId);   \n\tStream_Read_UINT32(s, pduLength); \n#ifdef WITH_DEBUG_RDPEI\n\tWLog_DBG(TAG, \"rdpei_recv_pdu: eventId: %\" PRIu16 \" (%s) length: %\" PRIu32 \"\", eventId,\n\t         rdpei_eventid_string(eventId), pduLength);\n#endif\n\tswitch (eventId)\n\t{\n\t\tcase EVENTID_SC_READY:\n\t\t\tif ((error = rdpei_recv_sc_ready_pdu(callback, s)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_recv_sc_ready_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tif ((error = rdpei_send_cs_ready_pdu(callback)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_send_cs_ready_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EVENTID_SUSPEND_TOUCH:\n\t\t\tif ((error = rdpei_recv_suspend_touch_pdu(callback, s)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_recv_suspend_touch_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EVENTID_RESUME_TOUCH:\n\t\t\tif ((error = rdpei_recv_resume_touch_pdu(callback, s)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_recv_resume_touch_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn CHANNEL_RC_OK;\n}", "target": 1}
{"code": "static void move_huge_pte(struct vm_area_struct *vma, unsigned long old_addr,\n\t\t\t  unsigned long new_addr, pte_t *src_pte)\n{\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpte_t *dst_pte, pte;\n\tspinlock_t *src_ptl, *dst_ptl;\n\tdst_pte = huge_pte_offset(mm, new_addr, huge_page_size(h));\n\tdst_ptl = huge_pte_lock(h, mm, dst_pte);\n\tsrc_ptl = huge_pte_lockptr(h, mm, src_pte);\n\tif (src_ptl != dst_ptl)\n\t\tspin_lock_nested(src_ptl, SINGLE_DEPTH_NESTING);\n\tpte = huge_ptep_get_and_clear(mm, old_addr, src_pte);\n\tset_huge_pte_at(mm, new_addr, dst_pte, pte);\n\tif (src_ptl != dst_ptl)\n\t\tspin_unlock(src_ptl);\n\tspin_unlock(dst_ptl);\n}", "target": 0}
{"code": "int regset_tls_set(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count,\n\t\t   const void *kbuf, const void __user *ubuf)\n{\n\tstruct user_desc infobuf[GDT_ENTRY_TLS_ENTRIES];\n\tconst struct user_desc *info;\n\tint i;\n\tif (pos >= GDT_ENTRY_TLS_ENTRIES * sizeof(struct user_desc) ||\n\t    (pos % sizeof(struct user_desc)) != 0 ||\n\t    (count % sizeof(struct user_desc)) != 0)\n\t\treturn -EINVAL;\n\tif (kbuf)\n\t\tinfo = kbuf;\n\telse if (__copy_from_user(infobuf, ubuf, count))\n\t\treturn -EFAULT;\n\telse\n\t\tinfo = infobuf;\n\tfor (i = 0; i < count / sizeof(struct user_desc); i++)\n\t\tif (!tls_desc_okay(info + i))\n\t\t\treturn -EINVAL;\n\tset_tls_desc(target,\n\t\t     GDT_ENTRY_TLS_MIN + (pos / sizeof(struct user_desc)),\n\t\t     info, count / sizeof(struct user_desc));\n\treturn 0;\n}", "target": 0}
{"code": "int crxFreeImageData(CrxImage *img)\n{\n  CrxTile *tile = img->tiles;\n  int nTiles = img->tileRows * img->tileCols;\n  if (img->tiles)\n  {\n    for (int32_t curTile = 0; curTile < nTiles; curTile++, tile++)\n      if (tile[curTile].comps)\n        for (int32_t curPlane = 0; curPlane < img->nPlanes; curPlane++)\n          crxFreeSubbandData(img, tile[curTile].comps + curPlane);\n    free(img->tiles);\n    img->tiles = 0;\n  }\n  if (img->planeBuf)\n  {\n    free(img->planeBuf);\n    img->planeBuf = 0;\n  }\n  return 0;\n}", "target": 1}
{"code": "void test_checkout_nasty__git_tilde1(void)\n{\n#ifdef GIT_WIN32\n\ttest_checkout_fails(\"refs/heads/git_tilde1\", \".git/foobar\");\n#endif\n}", "target": 1}
{"code": "PHP_FUNCTION(pg_result_error)\n{\n\tzval *result;\n\tPGresult *pgsql_result;\n\tpgsql_result_handle *pg_result;\n\tchar *err = NULL;\n\tif (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, ZEND_NUM_ARGS(), \"r\",\n\t\t\t\t\t\t\t\t &result) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tZEND_FETCH_RESOURCE(pg_result, pgsql_result_handle *, result, -1, \"PostgreSQL result\", le_result);\n\tpgsql_result = pg_result->result;\n\tif (!pgsql_result) {\n\t\tRETURN_FALSE;\n\t}\n\terr = (char *)PQresultErrorMessage(pgsql_result);\n\tRETURN_STRING(err);\n}", "target": 0}
{"code": "static int handle_rdmsr(struct kvm_vcpu *vcpu)\n{\n\tu32 ecx = vcpu->arch.regs[VCPU_REGS_RCX];\n\tu64 data;\n\tif (vmx_get_msr(vcpu, ecx, &data)) {\n\t\ttrace_kvm_msr_read_ex(ecx);\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\ttrace_kvm_msr_read(ecx, data);\n\tvcpu->arch.regs[VCPU_REGS_RAX] = data & -1u;\n\tvcpu->arch.regs[VCPU_REGS_RDX] = (data >> 32) & -1u;\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}", "target": 0}
{"code": "skipString(const xmlChar *cur, int end) {\n    xmlChar limit;\n    if ((cur == NULL) || (end < 0)) return(-1);\n    if ((cur[end] == '\\'') || (cur[end] == '\"')) limit = cur[end];\n    else return(end);\n    end++;\n    while (cur[end] != 0) {\n        if (cur[end] == limit)\n\t    return(end + 1);\n\tend++;\n    }\n    return(-1);\n}", "target": 0}
{"code": "int GamutSampler(register const cmsUInt16Number In[], register cmsUInt16Number Out[], register void* Cargo)\n{\n    GAMUTCHAIN*  t = (GAMUTCHAIN* ) Cargo;\n    cmsCIELab LabIn1, LabOut1;\n    cmsCIELab LabIn2, LabOut2;\n    cmsUInt16Number Proof[cmsMAXCHANNELS], Proof2[cmsMAXCHANNELS];\n    cmsFloat64Number dE1, dE2, ErrorRatio;\n    ErrorRatio = 1.0;\n    cmsDoTransform(t -> hInput, In, &LabIn1, 1);\n    cmsDoTransform(t -> hForward, &LabIn1, Proof, 1);\n    cmsDoTransform(t -> hReverse, Proof, &LabOut1, 1);\n    memmove(&LabIn2, &LabOut1, sizeof(cmsCIELab));\n    cmsDoTransform(t -> hForward, &LabOut1, Proof2, 1);\n    cmsDoTransform(t -> hReverse, Proof2, &LabOut2, 1);\n    dE1 = cmsDeltaE(&LabIn1, &LabOut1);\n    dE2 = cmsDeltaE(&LabIn2, &LabOut2);\n    if (dE1 < t->Thereshold && dE2 < t->Thereshold)\n        Out[0] = 0;\n    else {\n        if (dE1 < t->Thereshold && dE2 > t->Thereshold)\n            Out[0] = 0;\n        else\n            if (dE1 > t->Thereshold && dE2 < t->Thereshold)\n                Out[0] = (cmsUInt16Number) _cmsQuickFloor((dE1 - t->Thereshold) + .5);\n            else  {\n                if (dE2 == 0.0)\n                    ErrorRatio = dE1;\n                else\n                    ErrorRatio = dE1 / dE2;\n                if (ErrorRatio > t->Thereshold)\n                    Out[0] = (cmsUInt16Number)  _cmsQuickFloor((ErrorRatio - t->Thereshold) + .5);\n                else\n                    Out[0] = 0;\n            }\n    }\n    return TRUE;\n}", "target": 0}
{"code": "static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo){\n  Vdbe *v = pParse->pVdbe;\n  int i;\n  struct AggInfo_func *pFunc;\n  int nReg = pAggInfo->nFunc + pAggInfo->nColumn;\n  if( nReg==0 ) return;\n#ifdef SQLITE_DEBUG\n  assert( nReg==pAggInfo->mxReg-pAggInfo->mnReg+1 );\n  for(i=0; i<pAggInfo->nColumn; i++){\n    assert( pAggInfo->aCol[i].iMem>=pAggInfo->mnReg\n         && pAggInfo->aCol[i].iMem<=pAggInfo->mxReg );\n  }\n  for(i=0; i<pAggInfo->nFunc; i++){\n    assert( pAggInfo->aFunc[i].iMem>=pAggInfo->mnReg\n         && pAggInfo->aFunc[i].iMem<=pAggInfo->mxReg );\n  }\n#endif\n  sqlite3VdbeAddOp3(v, OP_Null, 0, pAggInfo->mnReg, pAggInfo->mxReg);\n  for(pFunc=pAggInfo->aFunc, i=0; i<pAggInfo->nFunc; i++, pFunc++){\n    if( pFunc->iDistinct>=0 ){\n      Expr *pE = pFunc->pExpr;\n      assert( !ExprHasProperty(pE, EP_xIsSelect) );\n      if( pE->x.pList==0 || pE->x.pList->nExpr!=1 ){\n        sqlite3ErrorMsg(pParse, \"DISTINCT aggregates must have exactly one \"\n           \"argument\");\n        pFunc->iDistinct = -1;\n      }else{\n        KeyInfo *pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pE->x.pList,0,0);\n        sqlite3VdbeAddOp4(v, OP_OpenEphemeral, pFunc->iDistinct, 0, 0,\n                          (char*)pKeyInfo, P4_KEYINFO);\n      }\n    }\n  }\n}", "target": 0}
{"code": "static int rose_getname(struct socket *sock, struct sockaddr *uaddr,\n\tint *uaddr_len, int peer)\n{\n\tstruct full_sockaddr_rose *srose = (struct full_sockaddr_rose *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tint n;\n\tif (peer != 0) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\t\tsrose->srose_family = AF_ROSE;\n\t\tsrose->srose_addr   = rose->dest_addr;\n\t\tsrose->srose_call   = rose->dest_call;\n\t\tsrose->srose_ndigis = rose->dest_ndigis;\n\t\tfor (n = 0; n < rose->dest_ndigis; n++)\n\t\t\tsrose->srose_digis[n] = rose->dest_digis[n];\n\t} else {\n\t\tsrose->srose_family = AF_ROSE;\n\t\tsrose->srose_addr   = rose->source_addr;\n\t\tsrose->srose_call   = rose->source_call;\n\t\tsrose->srose_ndigis = rose->source_ndigis;\n\t\tfor (n = 0; n < rose->source_ndigis; n++)\n\t\t\tsrose->srose_digis[n] = rose->source_digis[n];\n\t}\n\t*uaddr_len = sizeof(struct full_sockaddr_rose);\n\treturn 0;\n}", "target": 1}
{"code": "handle_keywordonly_args(struct compiling *c, const node *n, int start,\n                        asdl_seq *kwonlyargs, asdl_seq *kwdefaults)\n{\n    PyObject *argname;\n    node *ch;\n    expr_ty expression, annotation;\n    arg_ty arg;\n    int i = start;\n    int j = 0; \n    if (kwonlyargs == NULL) {\n        ast_error(c, CHILD(n, start), \"named arguments must follow bare *\");\n        return -1;\n    }\n    assert(kwdefaults != NULL);\n    while (i < NCH(n)) {\n        ch = CHILD(n, i);\n        switch (TYPE(ch)) {\n            case vfpdef:\n            case tfpdef:\n                if (i + 1 < NCH(n) && TYPE(CHILD(n, i + 1)) == EQUAL) {\n                    expression = ast_for_expr(c, CHILD(n, i + 2));\n                    if (!expression)\n                        goto error;\n                    asdl_seq_SET(kwdefaults, j, expression);\n                    i += 2; \n                }\n                else { \n                    asdl_seq_SET(kwdefaults, j, NULL);\n                }\n                if (NCH(ch) == 3) {\n                    annotation = ast_for_expr(c, CHILD(ch, 2));\n                    if (!annotation)\n                        goto error;\n                }\n                else {\n                    annotation = NULL;\n                }\n                ch = CHILD(ch, 0);\n                argname = NEW_IDENTIFIER(ch);\n                if (!argname)\n                    goto error;\n                if (forbidden_name(c, argname, ch, 0))\n                    goto error;\n                arg = arg(argname, annotation, LINENO(ch), ch->n_col_offset,\n                          ch->n_end_lineno, ch->n_end_col_offset,\n                          c->c_arena);\n                if (!arg)\n                    goto error;\n                asdl_seq_SET(kwonlyargs, j++, arg);\n                i += 2; \n                break;\n            case DOUBLESTAR:\n                return i;\n            default:\n                ast_error(c, ch, \"unexpected node\");\n                goto error;\n        }\n    }\n    return i;\n error:\n    return -1;\n}", "target": 1}
{"code": "Opal::Call::Call (OpalManager& _manager,\n\t\t  Ekiga::ServiceCore& _core,\n\t\t  const std::string& uri)\n  : OpalCall (_manager), Ekiga::Call (), core (_core), remote_uri (uri),\n    call_setup(false), jitter(0), outgoing(false)\n{\n  notification_core = core.get<Ekiga::NotificationCore> (\"notification-core\");\n  re_a_bytes = tr_a_bytes = re_v_bytes = tr_v_bytes = 0.0;\n  last_v_tick = last_a_tick = PTime ();\n  total_a =\n    total_v =\n    lost_a =\n    too_late_a =\n    out_of_order_a =\n    lost_v =\n    too_late_v =\n    out_of_order_v = 0;\n  lost_packets = late_packets = out_of_order_packets = 0.0;\n  re_a_bw = tr_a_bw = re_v_bw = tr_v_bw = 0.0;\n  NoAnswerTimer.SetNotifier (PCREATE_NOTIFIER (OnNoAnswerTimeout));\n}", "target": 0}
{"code": "windows_icon_typefind (GstTypeFind * find, gpointer user_data)\n{\n  const guint8 *data;\n  gint64 datalen;\n  guint16 type, nimages;\n  gint32 size, offset;\n  datalen = gst_type_find_get_length (find);\n  if ((data = gst_type_find_peek (find, 0, 6)) == NULL)\n    return;\n  if (GST_READ_UINT16_LE (data) != 0)\n    return;\n  type = GST_READ_UINT16_LE (data + 2);\n  if (type != 1 && type != 2)\n    return;\n  nimages = GST_READ_UINT16_LE (data + 4);\n  if (nimages == 0)             \n    return;\n  if (data[6 + 3] != 0)\n    return;\n  if (type == 1) {\n    guint16 planes = GST_READ_UINT16_LE (data + 6 + 4);\n    if (planes > 1)\n      return;\n  }\n  size = GST_READ_UINT32_LE (data + 6 + 8);\n  offset = GST_READ_UINT32_LE (data + 6 + 12);\n  if (offset < 0 || size <= 0 || size >= datalen || offset >= datalen\n      || size + offset > datalen)\n    return;\n  gst_type_find_suggest_simple (find, GST_TYPE_FIND_NEARLY_CERTAIN,\n      \"image/x-icon\", NULL);\n}", "target": 1}
{"code": "Value ExpressionDateToString::evaluate(const Document& root, Variables* variables) const {\n    const Value date = _date->evaluate(root, variables);\n    Value formatValue;\n    if (_format) {\n        formatValue = _format->evaluate(root, variables);\n        if (!formatValue.nullish()) {\n            uassert(18533,\n                    str::stream() << \"$dateToString requires that 'format' be a string, found: \"\n                                  << typeName(formatValue.getType()) << \" with value \"\n                                  << formatValue.toString(),\n                    formatValue.getType() == BSONType::String);\n            TimeZone::validateToStringFormat(formatValue.getStringData());\n        }\n    }\n    auto timeZone =\n        makeTimeZone(getExpressionContext()->timeZoneDatabase, root, _timeZone.get(), variables);\n    if (date.nullish()) {\n        return _onNull ? _onNull->evaluate(root, variables) : Value(BSONNULL);\n    }\n    if (!timeZone) {\n        return Value(BSONNULL);\n    }\n    if (_format) {\n        if (formatValue.nullish()) {\n            return Value(BSONNULL);\n        }\n        return Value(uassertStatusOK(\n            timeZone->formatDate(formatValue.getStringData(), date.coerceToDate())));\n    }\n    return Value(\n        uassertStatusOK(timeZone->formatDate(Value::kISOFormatString, date.coerceToDate())));\n}", "target": 0}
{"code": "static avifBool avifParseImageGridBox(avifImageGrid * grid, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n    uint8_t version, flags;\n    CHECK(avifROStreamRead(&s, &version, 1)); \n    if (version != 0) {\n        return AVIF_FALSE;\n    }\n    CHECK(avifROStreamRead(&s, &flags, 1));         \n    CHECK(avifROStreamRead(&s, &grid->rows, 1));    \n    CHECK(avifROStreamRead(&s, &grid->columns, 1)); \n    ++grid->rows;\n    ++grid->columns;\n    uint32_t fieldLength = ((flags & 1) + 1) * 16;\n    if (fieldLength == 16) {\n        uint16_t outputWidth16, outputHeight16;\n        CHECK(avifROStreamReadU16(&s, &outputWidth16));  \n        CHECK(avifROStreamReadU16(&s, &outputHeight16)); \n        grid->outputWidth = outputWidth16;\n        grid->outputHeight = outputHeight16;\n    } else {\n        if (fieldLength != 32) {\n            return AVIF_FALSE;\n        }\n        CHECK(avifROStreamReadU32(&s, &grid->outputWidth));  \n        CHECK(avifROStreamReadU32(&s, &grid->outputHeight)); \n    }\n    return AVIF_TRUE;\n}", "target": 1}
{"code": "process_open(u_int32_t id)\n{\n\tu_int32_t pflags;\n\tAttrib a;\n\tchar *name;\n\tint r, handle, fd, flags, mode, status = SSH2_FX_FAILURE;\n\tif ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(iqueue, &pflags)) != 0 || \n\t    (r = decode_attrib(iqueue, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tdebug3(\"request %u: open flags %d\", id, pflags);\n\tflags = flags_from_portable(pflags);\n\tmode = (a.flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ? a.perm : 0666;\n\tlogit(\"open \\\"%s\\\" flags %s mode 0%o\",\n\t    name, string_from_portable(pflags), mode);\n\tif (readonly &&\n\t    ((flags & O_ACCMODE) == O_WRONLY ||\n\t    (flags & O_ACCMODE) == O_RDWR)) {\n\t\tverbose(\"Refusing open request in read-only mode\");\n\t\tstatus = SSH2_FX_PERMISSION_DENIED;\n\t} else {\n\t\tfd = open(name, flags, mode);\n\t\tif (fd < 0) {\n\t\t\tstatus = errno_to_portable(errno);\n\t\t} else {\n\t\t\thandle = handle_new(HANDLE_FILE, name, fd, flags, NULL);\n\t\t\tif (handle < 0) {\n\t\t\t\tclose(fd);\n\t\t\t} else {\n\t\t\t\tsend_handle(id, handle);\n\t\t\t\tstatus = SSH2_FX_OK;\n\t\t\t}\n\t\t}\n\t}\n\tif (status != SSH2_FX_OK)\n\t\tsend_status(id, status);\n\tfree(name);\n}", "target": 1}
{"code": "GF_Err hdlr_dump(GF_Box *a, FILE * trace)\n{\n\tGF_HandlerBox *p = (GF_HandlerBox *)a;\n\tgf_isom_box_dump_start(a, \"HandlerBox\", trace);\n\tif (p->nameUTF8 && (u32) p->nameUTF8[0] == strlen(p->nameUTF8+1)) {\n\t\tfprintf(trace, \"hdlrType=\\\"%s\\\" Name=\\\"%s\\\" \", gf_4cc_to_str(p->handlerType), p->nameUTF8+1);\n\t} else {\n\t\tfprintf(trace, \"hdlrType=\\\"%s\\\" Name=\\\"%s\\\" \", gf_4cc_to_str(p->handlerType), p->nameUTF8);\n\t}\n\tfprintf(trace, \"reserved1=\\\"%d\\\" reserved2=\\\"\", p->reserved1);\n\tdump_data(trace, (char *) p->reserved2, 12);\n\tfprintf(trace, \"\\\"\");\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"HandlerBox\", a, trace);\n\treturn GF_OK;\n}", "target": 1}
{"code": "static void calc_timer_values(struct perf_event *event,\n\t\t\t\tu64 *now,\n\t\t\t\tu64 *enabled,\n\t\t\t\tu64 *running)\n{\n\tu64 ctx_time;\n\t*now = perf_clock();\n\tctx_time = event->shadow_ctx_time + *now;\n\t*enabled = ctx_time - event->tstamp_enabled;\n\t*running = ctx_time - event->tstamp_running;\n}", "target": 0}
{"code": "gdk_pixbuf__tiff_image_load (FILE *f, GError **error)\n{\n        TIFF *tiff;\n        int fd;\n        GdkPixbuf *pixbuf;\n        g_return_val_if_fail (f != NULL, NULL);\n        tiff_set_handlers ();\n        fd = fileno (f);\n        lseek (fd, 0, SEEK_SET);\n        tiff = TIFFFdOpen (fd, \"libpixbuf-tiff\", \"r\");\n        if (!tiff) {\n                g_set_error_literal (error,\n                                     GDK_PIXBUF_ERROR,\n                                     GDK_PIXBUF_ERROR_CORRUPT_IMAGE,\n                                     _(\"Failed to open TIFF image\"));\n                return NULL;\n        }\n        pixbuf = tiff_image_parse (tiff, NULL, error);\n        TIFFClose (tiff);\n        return pixbuf;\n}", "target": 0}
{"code": "static bool tailmatch(const char *cooke_domain, const char *hostname)\n{\n  size_t cookie_domain_len = strlen(cooke_domain);\n  size_t hostname_len = strlen(hostname);\n  if(hostname_len < cookie_domain_len)\n    return FALSE;\n  if(!strcasecompare(cooke_domain, hostname + hostname_len-cookie_domain_len))\n    return FALSE;\n  if(hostname_len == cookie_domain_len)\n    return TRUE;\n  if('.' == *(hostname + hostname_len - cookie_domain_len - 1))\n    return TRUE;\n  return FALSE;\n}", "target": 0}
{"code": "static struct sock *rfcomm_sock_alloc(struct net *net, struct socket *sock, int proto, gfp_t prio)\n{\n\tstruct rfcomm_dlc *d;\n\tstruct sock *sk;\n\tsk = sk_alloc(net, PF_BLUETOOTH, prio, &rfcomm_proto);\n\tif (!sk)\n\t\treturn NULL;\n\tsock_init_data(sock, sk);\n\tINIT_LIST_HEAD(&bt_sk(sk)->accept_q);\n\td = rfcomm_dlc_alloc(prio);\n\tif (!d) {\n\t\tsk_free(sk);\n\t\treturn NULL;\n\t}\n\td->data_ready   = rfcomm_sk_data_ready;\n\td->state_change = rfcomm_sk_state_change;\n\trfcomm_pi(sk)->dlc = d;\n\td->owner = sk;\n\tsk->sk_destruct = rfcomm_sock_destruct;\n\tsk->sk_sndtimeo = RFCOMM_CONN_TIMEOUT;\n\tsk->sk_sndbuf = RFCOMM_MAX_CREDITS * RFCOMM_DEFAULT_MTU * 10;\n\tsk->sk_rcvbuf = RFCOMM_MAX_CREDITS * RFCOMM_DEFAULT_MTU * 10;\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\tsk->sk_protocol = proto;\n\tsk->sk_state    = BT_OPEN;\n\tbt_sock_link(&rfcomm_sk_list, sk);\n\tBT_DBG(\"sk %p\", sk);\n\treturn sk;\n}", "target": 0}
{"code": "static int xen_net_read_mac(struct xenbus_device *dev, u8 mac[])\n{\n\tchar *s, *e, *macstr;\n\tint i;\n\tmacstr = s = xenbus_read(XBT_NIL, dev->nodename, \"mac\", NULL);\n\tif (IS_ERR(macstr))\n\t\treturn PTR_ERR(macstr);\n\tfor (i = 0; i < ETH_ALEN; i++) {\n\t\tmac[i] = simple_strtoul(s, &e, 16);\n\t\tif ((s == e) || (*e != ((i == ETH_ALEN-1) ? '\\0' : ':'))) {\n\t\t\tkfree(macstr);\n\t\t\treturn -ENOENT;\n\t\t}\n\t\ts = e+1;\n\t}\n\tkfree(macstr);\n\treturn 0;\n}", "target": 0}
{"code": "static void kvm_sched_in(struct preempt_notifier *pn, int cpu)\n{\n\tstruct kvm_vcpu *vcpu = preempt_notifier_to_vcpu(pn);\n\tkvm_arch_vcpu_load(vcpu, cpu);\n}", "target": 0}
{"code": "    static void _distance_scan(const unsigned int len,\n                               const longT *const g,\n                               longT (*const sep)(const longT, const longT, const longT *const),\n                               longT (*const f)(const longT, const longT, const longT *const),\n                               longT *const s,\n                               longT *const t,\n                               longT *const dt) {\n      longT q = s[0] = t[0] = 0;\n      for (int u = 1; u<(int)len; ++u) { \n        while ((q>=0) && f(t[q],s[q],g)>f(t[q],u,g)) { --q; }\n        if (q<0) { q = 0; s[0] = u; }\n        else { const longT w = 1 + sep(s[q], u, g); if (w<(longT)len) { ++q; s[q] = u; t[q] = w; }}\n      }\n      for (int u = (int)len - 1; u>=0; --u) { dt[u] = f(u,s[q],g); if (u==t[q]) --q; } ", "target": 0}
{"code": "static int mem_cgroup_charge_common(struct page *page, struct mm_struct *mm,\n\t\t\t\tgfp_t gfp_mask, enum charge_type ctype)\n{\n\tstruct mem_cgroup *memcg = NULL;\n\tunsigned int nr_pages = 1;\n\tstruct page_cgroup *pc;\n\tbool oom = true;\n\tint ret;\n\tif (PageTransHuge(page)) {\n\t\tnr_pages <<= compound_order(page);\n\t\tVM_BUG_ON(!PageTransHuge(page));\n\t\toom = false;\n\t}\n\tpc = lookup_page_cgroup(page);\n\tret = __mem_cgroup_try_charge(mm, gfp_mask, nr_pages, &memcg, oom);\n\tif (ret == -ENOMEM)\n\t\treturn ret;\n\t__mem_cgroup_commit_charge(memcg, page, nr_pages, pc, ctype);\n\treturn 0;\n}", "target": 0}
{"code": "struct sctp_chunk *sctp_make_strreset_req(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\t__u16 stream_num, __be16 *stream_list,\n\t\t\t\t\tbool out, bool in)\n{\n\t__u16 stream_len = stream_num * sizeof(__u16);\n\tstruct sctp_strreset_outreq outreq;\n\tstruct sctp_strreset_inreq inreq;\n\tstruct sctp_chunk *retval;\n\t__u16 outlen, inlen;\n\toutlen = (sizeof(outreq) + stream_len) * out;\n\tinlen = (sizeof(inreq) + stream_len) * in;\n\tretval = sctp_make_reconf(asoc, outlen + inlen);\n\tif (!retval)\n\t\treturn NULL;\n\tif (outlen) {\n\t\toutreq.param_hdr.type = SCTP_PARAM_RESET_OUT_REQUEST;\n\t\toutreq.param_hdr.length = htons(outlen);\n\t\toutreq.request_seq = htonl(asoc->strreset_outseq);\n\t\toutreq.response_seq = htonl(asoc->strreset_inseq - 1);\n\t\toutreq.send_reset_at_tsn = htonl(asoc->next_tsn - 1);\n\t\tsctp_addto_chunk(retval, sizeof(outreq), &outreq);\n\t\tif (stream_len)\n\t\t\tsctp_addto_chunk(retval, stream_len, stream_list);\n\t}\n\tif (inlen) {\n\t\tinreq.param_hdr.type = SCTP_PARAM_RESET_IN_REQUEST;\n\t\tinreq.param_hdr.length = htons(inlen);\n\t\tinreq.request_seq = htonl(asoc->strreset_outseq + out);\n\t\tsctp_addto_chunk(retval, sizeof(inreq), &inreq);\n\t\tif (stream_len)\n\t\t\tsctp_addto_chunk(retval, stream_len, stream_list);\n\t}\n\treturn retval;\n}", "target": 1}
{"code": "flatpak_context_merge (FlatpakContext *context,\n                       FlatpakContext *other)\n{\n  GHashTableIter iter;\n  gpointer key, value;\n  context->shares &= ~other->shares_valid;\n  context->shares |= other->shares;\n  context->shares_valid |= other->shares_valid;\n  context->sockets &= ~other->sockets_valid;\n  context->sockets |= other->sockets;\n  context->sockets_valid |= other->sockets_valid;\n  context->devices &= ~other->devices_valid;\n  context->devices |= other->devices;\n  context->devices_valid |= other->devices_valid;\n  context->features &= ~other->features_valid;\n  context->features |= other->features;\n  context->features_valid |= other->features_valid;\n  g_hash_table_iter_init (&iter, other->env_vars);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->env_vars, g_strdup (key), g_strdup (value));\n  g_hash_table_iter_init (&iter, other->persistent);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->persistent, g_strdup (key), value);\n  g_hash_table_iter_init (&iter, other->filesystems);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->filesystems, g_strdup (key), value);\n  g_hash_table_iter_init (&iter, other->session_bus_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->session_bus_policy, g_strdup (key), value);\n  g_hash_table_iter_init (&iter, other->system_bus_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->system_bus_policy, g_strdup (key), value);\n  g_hash_table_iter_init (&iter, other->system_bus_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->system_bus_policy, g_strdup (key), value);\n  g_hash_table_iter_init (&iter, other->generic_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    {\n      const char **policy_values = (const char **) value;\n      int i;\n      for (i = 0; policy_values[i] != NULL; i++)\n        flatpak_context_apply_generic_policy (context, (char *) key, policy_values[i]);\n    }\n}", "target": 1}
{"code": "TEST(PercentEncoding, ShouldCloseConnection) {\n  EXPECT_TRUE(HeaderUtility::shouldCloseConnection(Protocol::Http10,\n                                                   TestRequestHeaderMapImpl{{\"foo\", \"bar\"}}));\n  EXPECT_FALSE(HeaderUtility::shouldCloseConnection(\n      Protocol::Http10, TestRequestHeaderMapImpl{{\"connection\", \"keep-alive\"}}));\n  EXPECT_FALSE(HeaderUtility::shouldCloseConnection(\n      Protocol::Http10, TestRequestHeaderMapImpl{{\"connection\", \"foo, keep-alive\"}}));\n  EXPECT_FALSE(HeaderUtility::shouldCloseConnection(Protocol::Http11,\n                                                    TestRequestHeaderMapImpl{{\"foo\", \"bar\"}}));\n  EXPECT_TRUE(HeaderUtility::shouldCloseConnection(\n      Protocol::Http11, TestRequestHeaderMapImpl{{\"connection\", \"close\"}}));\n  EXPECT_TRUE(HeaderUtility::shouldCloseConnection(\n      Protocol::Http11, TestRequestHeaderMapImpl{{\"connection\", \"te,close\"}}));\n  EXPECT_TRUE(HeaderUtility::shouldCloseConnection(\n      Protocol::Http11, TestRequestHeaderMapImpl{{\"proxy-connection\", \"close\"}}));\n  EXPECT_TRUE(HeaderUtility::shouldCloseConnection(\n      Protocol::Http11, TestRequestHeaderMapImpl{{\"proxy-connection\", \"foo,close\"}}));\n}", "target": 0}
{"code": "getlogin_r (name, name_len)\n     char *name;\n     size_t name_len;\n{\n  char tty_pathname[2 + 2 * NAME_MAX];\n  char *real_tty_path = tty_pathname;\n  int result = 0;\n  struct utmp *ut, line, buffer;\n  {\n    int d = __open (\"/dev/tty\", 0);\n    if (d < 0)\n      return errno;\n    result = __ttyname_r (d, real_tty_path, sizeof (tty_pathname));\n    (void) __close (d);\n    if (result != 0)\n      {\n\t__set_errno (result);\n\treturn result;\n      }\n  }\n  real_tty_path += 5;\t\t\n  __setutent ();\n  strncpy (line.ut_line, real_tty_path, sizeof line.ut_line);\n  if (__getutline_r (&line, &buffer, &ut) < 0)\n    {\n      if (errno == ESRCH)\n\tresult = ENOENT;\n      else\n\tresult = errno;\n    }\n  else\n    {\n      size_t needed = strlen (ut->ut_line) + 1;\n      if (needed < name_len)\n\t{\n\t  __set_errno (ERANGE);\n\t  result = ERANGE;\n\t}\n      else\n\t{\n\t  memcpy (name, ut->ut_line, needed);\n\t  result = 0;\n\t}\n    }\n  __endutent ();\n  return result;\n}", "target": 1}
{"code": "void mnt_set_mountpoint(struct mount *mnt,\n\t\t\tstruct mountpoint *mp,\n\t\t\tstruct mount *child_mnt)\n{\n\tmp->m_count++;\n\tmnt_add_count(mnt, 1);\t\n\tchild_mnt->mnt_mountpoint = dget(mp->m_dentry);\n\tchild_mnt->mnt_parent = mnt;\n\tchild_mnt->mnt_mp = mp;\n}", "target": 0}
{"code": "join_path_from_pattern(struct glob_pattern **beg)\n{\n    struct glob_pattern *p;\n    char *path = NULL;\n    size_t path_len = 0;\n    for (p = *beg; p; p = p->next) {\n\tconst char *str;\n\tswitch (p->type) {\n\t  case RECURSIVE:\n\t    str = \"**\";\n\t    break;\n\t  case MATCH_DIR:\n\t    str = \"\";\n\t    break;\n\t  default:\n\t    str = p->str;\n\t    if (!str) continue;\n\t}\n\tif (!path) {\n\t    path_len = strlen(str);\n\t    path = GLOB_ALLOC_N(char, path_len + 1);\n\t    memcpy(path, str, path_len);\n\t    path[path_len] = '\\0';\n        }\n        else {\n\t    size_t len = strlen(str);\n\t    char *tmp;\n\t    tmp = GLOB_REALLOC(path, path_len + len + 2);\n\t    if (tmp) {\n\t\tpath = tmp;\n\t\tpath[path_len++] = '/';\n\t\tmemcpy(path + path_len, str, len);\n\t\tpath_len += len;\n\t\tpath[path_len] = '\\0';\n\t    }\n\t}\n    }\n    return path;\n}", "target": 0}
{"code": "int Http2Stream::DoWrite(WriteWrap* req_wrap,\n                         uv_buf_t* bufs,\n                         size_t nbufs,\n                         uv_stream_t* send_handle) {\n  CHECK_NULL(send_handle);\n  Http2Scope h2scope(this);\n  if (!IsWritable() || IsDestroyed()) {\n    req_wrap->Done(UV_EOF);\n    return 0;\n  }\n  Debug(this, \"queuing %d buffers to send\", id_, nbufs);\n  for (size_t i = 0; i < nbufs; ++i) {\n    queue_.emplace(nghttp2_stream_write {\n      i == nbufs - 1 ? req_wrap : nullptr,\n      bufs[i]\n    });\n    IncrementAvailableOutboundLength(bufs[i].len);\n  }\n  CHECK_NE(nghttp2_session_resume_data(**session_, id_), NGHTTP2_ERR_NOMEM);\n  return 0;\n}", "target": 1}
{"code": "void git_tree_entry_free(git_tree_entry *entry)\n{\n\tif (entry == NULL)\n\t\treturn;\n\tgit__free(entry);\n}", "target": 0}
{"code": "static inline struct futex_hash_bucket *queue_lock(struct futex_q *q)\n{\n\tstruct futex_hash_bucket *hb;\n\tget_futex_key_refs(&q->key);\n\thb = hash_futex(&q->key);\n\tq->lock_ptr = &hb->lock;\n\tspin_lock(&hb->lock);\n\treturn hb;\n}", "target": 1}
{"code": "int snd_card_register(struct snd_card *card)\n{\n\tint err;\n\tif (snd_BUG_ON(!card))\n\t\treturn -EINVAL;\n\tif (!card->registered) {\n\t\terr = device_add(&card->card_dev);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tcard->registered = true;\n\t}\n\tif ((err = snd_device_register_all(card)) < 0)\n\t\treturn err;\n\tmutex_lock(&snd_card_mutex);\n\tif (snd_cards[card->number]) {\n\t\tmutex_unlock(&snd_card_mutex);\n\t\treturn 0;\n\t}\n\tif (*card->id) {\n\t\tchar tmpid[sizeof(card->id)];\n\t\tmemcpy(tmpid, card->id, sizeof(card->id));\n\t\tsnd_card_set_id_no_lock(card, tmpid, tmpid);\n\t} else {\n\t\tconst char *src;\n\t\tsrc = *card->shortname ? card->shortname : card->longname;\n\t\tsnd_card_set_id_no_lock(card, src,\n\t\t\t\t\tretrieve_id_from_card_name(src));\n\t}\n\tsnd_cards[card->number] = card;\n\tmutex_unlock(&snd_card_mutex);\n\tinit_info_for_card(card);\n#if IS_ENABLED(CONFIG_SND_MIXER_OSS)\n\tif (snd_mixer_oss_notify_callback)\n\t\tsnd_mixer_oss_notify_callback(card, SND_MIXER_OSS_NOTIFY_REGISTER);\n#endif\n\treturn 0;\n}", "target": 0}
{"code": "static int __init redirect_tg_init(void)\n{\n\treturn xt_register_targets(redirect_tg_reg,\n\t\t\t\t   ARRAY_SIZE(redirect_tg_reg));\n}", "target": 0}
{"code": "\tMode mode() const { return m_mode; }", "target": 0}
{"code": "void setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !inode_capable(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}", "target": 1}
{"code": "static void rds_tcp_kill_sock(struct net *net)\n{\n\tstruct rds_tcp_connection *tc, *_tc;\n\tLIST_HEAD(tmp_list);\n\tstruct rds_tcp_net *rtn = net_generic(net, rds_tcp_netid);\n\tstruct socket *lsock = rtn->rds_tcp_listen_sock;\n\trtn->rds_tcp_listen_sock = NULL;\n\trds_tcp_listen_stop(lsock, &rtn->rds_tcp_accept_w);\n\tspin_lock_irq(&rds_tcp_conn_lock);\n\tlist_for_each_entry_safe(tc, _tc, &rds_tcp_conn_list, t_tcp_node) {\n\t\tstruct net *c_net = read_pnet(&tc->t_cpath->cp_conn->c_net);\n\t\tif (net != c_net || !tc->t_sock)\n\t\t\tcontinue;\n\t\tif (!list_has_conn(&tmp_list, tc->t_cpath->cp_conn)) {\n\t\t\tlist_move_tail(&tc->t_tcp_node, &tmp_list);\n\t\t} else {\n\t\t\tlist_del(&tc->t_tcp_node);\n\t\t\ttc->t_tcp_node_detached = true;\n\t\t}\n\t}\n\tspin_unlock_irq(&rds_tcp_conn_lock);\n\tlist_for_each_entry_safe(tc, _tc, &tmp_list, t_tcp_node)\n\t\trds_conn_destroy(tc->t_cpath->cp_conn);\n}", "target": 1}
{"code": "ssh_packet_get_compress_state(struct sshbuf *m, struct ssh *ssh)\n{\n\tstruct session_state *state = ssh->state;\n\tstruct sshbuf *b;\n\tint r;\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (state->compression_in_started) {\n\t\tif ((r = sshbuf_put_string(b, &state->compression_in_stream,\n\t\t    sizeof(state->compression_in_stream))) != 0)\n\t\t\tgoto out;\n\t} else if ((r = sshbuf_put_string(b, NULL, 0)) != 0)\n\t\tgoto out;\n\tif (state->compression_out_started) {\n\t\tif ((r = sshbuf_put_string(b, &state->compression_out_stream,\n\t\t    sizeof(state->compression_out_stream))) != 0)\n\t\t\tgoto out;\n\t} else if ((r = sshbuf_put_string(b, NULL, 0)) != 0)\n\t\tgoto out;\n\tr = sshbuf_put_stringb(m, b);\n out:\n\tsshbuf_free(b);\n\treturn r;\n}", "target": 1}
{"code": "void ves_icall_System_Threading_InternalThread_Thread_free_internal (MonoInternalThread *this, HANDLE thread)\n{\n\tMONO_ARCH_SAVE_REGS;\n\tTHREAD_DEBUG (g_message (\"%s: Closing thread %p, handle %p\", __func__, this, thread));\n\tif (thread)\n\t\tCloseHandle (thread);\n\tif (this->synch_cs) {\n\t\tDeleteCriticalSection (this->synch_cs);\n\t\tg_free (this->synch_cs);\n\t\tthis->synch_cs = NULL;\n\t}\n\tg_free (this->name);\n}", "target": 1}
{"code": "bool WebContentsImpl::IsActiveEntry(int32 page_id) {\n  NavigationEntryImpl* active_entry =\n      NavigationEntryImpl::FromNavigationEntry(controller_.GetActiveEntry());\n  return (active_entry != NULL &&\n          active_entry->site_instance() == GetSiteInstance() &&\n          active_entry->GetPageID() == page_id);\n}", "target": 0}
{"code": "void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tunsigned long flags;\n\tif (PCM_RUNTIME_CHECK(substream))\n\t\treturn;\n\truntime = substream->runtime;\n\tsnd_pcm_stream_lock_irqsave(substream, flags);\n\tif (!snd_pcm_running(substream) ||\n\t    snd_pcm_update_hw_ptr0(substream, 1) < 0)\n\t\tgoto _end;\n#ifdef CONFIG_SND_PCM_TIMER\n\tif (substream->timer_running)\n\t\tsnd_timer_interrupt(substream->timer, 1);\n#endif\n _end:\n\tsnd_pcm_stream_unlock_irqrestore(substream, flags);\n\tkill_fasync(&runtime->fasync, SIGIO, POLL_IN);\n}", "target": 1}
{"code": "static netdev_tx_t veth_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct net_device *rcv = NULL;\n\tstruct veth_priv *priv, *rcv_priv;\n\tstruct veth_net_stats *stats, *rcv_stats;\n\tint length;\n\tpriv = netdev_priv(dev);\n\trcv = priv->peer;\n\trcv_priv = netdev_priv(rcv);\n\tstats = this_cpu_ptr(priv->stats);\n\trcv_stats = this_cpu_ptr(rcv_priv->stats);\n\tif (!(rcv->flags & IFF_UP))\n\t\tgoto tx_drop;\n\tif (dev->features & NETIF_F_NO_CSUM)\n\t\tskb->ip_summed = rcv_priv->ip_summed;\n\tlength = skb->len + ETH_HLEN;\n\tif (dev_forward_skb(rcv, skb) != NET_RX_SUCCESS)\n\t\tgoto rx_drop;\n\tstats->tx_bytes += length;\n\tstats->tx_packets++;\n\trcv_stats->rx_bytes += length;\n\trcv_stats->rx_packets++;\n\treturn NETDEV_TX_OK;\ntx_drop:\n\tkfree_skb(skb);\n\tstats->tx_dropped++;\n\treturn NETDEV_TX_OK;\nrx_drop:\n\tkfree_skb(skb);\n\trcv_stats->rx_dropped++;\n\treturn NETDEV_TX_OK;\n}", "target": 1}
{"code": "GF_Err url_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s;\n\tif (ptr->size) {\n\t\tptr->location = (char*)gf_malloc((u32) ptr->size);\n\t\tif (! ptr->location) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->location, (u32)ptr->size);\n\t\tif (ptr->location[ptr->size-1]) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] url box location is not 0-terminated\\n\" ));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "vhost_user_set_vring_addr(struct virtio_net **pdev, struct VhostUserMsg *msg,\n\t\t\tint main_fd __rte_unused)\n{\n\tstruct virtio_net *dev = *pdev;\n\tstruct vhost_virtqueue *vq;\n\tstruct vhost_vring_addr *addr = &msg->payload.addr;\n\tbool access_ok;\n\tif (validate_msg_fds(msg, 0) != 0)\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\tif (dev->mem == NULL)\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\tvq = dev->virtqueue[msg->payload.addr.index];\n\taccess_ok = vq->access_ok;\n\tmemcpy(&vq->ring_addrs, addr, sizeof(*addr));\n\tvring_invalidate(dev, vq);\n\tif ((vq->enabled && (dev->features &\n\t\t\t\t(1ULL << VHOST_USER_F_PROTOCOL_FEATURES))) ||\n\t\t\taccess_ok) {\n\t\tdev = translate_ring_addresses(dev, msg->payload.addr.index);\n\t\tif (!dev)\n\t\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t\t*pdev = dev;\n\t}\n\treturn RTE_VHOST_MSG_RESULT_OK;\n}", "target": 0}
{"code": "int quicklistPushHead(quicklist *quicklist, void *value, size_t sz) {\n    quicklistNode *orig_head = quicklist->head;\n    assert(sz < UINT32_MAX); \n    if (likely(\n            _quicklistNodeAllowInsert(quicklist->head, quicklist->fill, sz))) {\n        quicklist->head->zl =\n            ziplistPush(quicklist->head->zl, value, sz, ZIPLIST_HEAD);\n        quicklistNodeUpdateSz(quicklist->head);\n    } else {\n        quicklistNode *node = quicklistCreateNode();\n        node->zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);\n        quicklistNodeUpdateSz(node);\n        _quicklistInsertNodeBefore(quicklist, quicklist->head, node);\n    }\n    quicklist->count++;\n    quicklist->head->count++;\n    return (orig_head != quicklist->head);\n}", "target": 0}
{"code": "PHP_NAMED_FUNCTION(zif_locale_set_default)\n{\n\tchar* locale_name = NULL;\n\tint   len=0;\t\n\tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC,  \"s\",\n\t\t&locale_name ,&len ) == FAILURE)\n\t{\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t \t\"locale_set_default: unable to parse input params\", 0 TSRMLS_CC );\n\t\tRETURN_FALSE;\n\t}\n\tif(len == 0) {\n\t\tlocale_name =  (char *)uloc_getDefault() ;\n\t\tlen = strlen(locale_name);\n\t}\n\tzend_alter_ini_entry(LOCALE_INI_NAME, sizeof(LOCALE_INI_NAME), locale_name, len, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);\t\n\tRETURN_TRUE;\n}", "target": 1}
{"code": "bool PrintWebViewHelper::CopyAndPrint(WebKit::WebFrame* web_frame) {\n  WebPreferences prefs = render_view()->GetWebkitPreferences();\n  prefs.javascript_enabled = false;\n  prefs.java_enabled = false;\n  print_web_view_ = WebView::create(this);\n  prefs.Apply(print_web_view_);\n  print_web_view_->initializeMainFrame(this);\n  print_pages_params_->pages.clear();  \n  std::string html = web_frame->selectionAsMarkup().utf8();\n  std::string url_str = \"data:text/html;charset=utf-8,\";\n  url_str.append(html);\n  GURL url(url_str);\n  print_web_view_->mainFrame()->loadRequest(WebURLRequest(url));\n  return true;\n}", "target": 0}
{"code": "httpd_compress(isc_httpd_t *httpd) {\n\tz_stream zstr;\n\tisc_region_t r;\n\tint ret;\n\tint inputlen;\n\tinputlen = isc_buffer_usedlength(&httpd->bodybuffer);\n\talloc_compspace(httpd, inputlen);\n\tisc_buffer_region(&httpd->compbuffer, &r);\n\tmemset(&zstr, 0, sizeof(zstr));\n\tzstr.total_in = zstr.avail_in = zstr.total_out = zstr.avail_out =\n\t\tinputlen;\n\tzstr.next_in = isc_buffer_base(&httpd->bodybuffer);\n\tzstr.next_out = r.base;\n\tret = deflateInit(&zstr, Z_DEFAULT_COMPRESSION);\n\tif (ret == Z_OK) {\n\t\tret = deflate(&zstr, Z_FINISH);\n\t}\n\tdeflateEnd(&zstr);\n\tif (ret == Z_STREAM_END) {\n\t\tisc_buffer_add(&httpd->compbuffer, inputlen - zstr.avail_out);\n\t\treturn (ISC_R_SUCCESS);\n\t} else {\n\t\treturn (ISC_R_FAILURE);\n\t}\n}", "target": 0}
{"code": "static int pull_client_data (struct conn_s *connptr, long int length, int iehack)\n{\n        char *buffer;\n        ssize_t len;\n        int ret;\n        buffer =\n            (char *) safemalloc (min (MAXBUFFSIZE, (unsigned long int) length));\n        if (!buffer)\n                return -1;\n        do {\n                len = safe_read (connptr->client_fd, buffer,\n                                 min (MAXBUFFSIZE, (unsigned long int) length));\n                if (len <= 0)\n                        goto ERROR_EXIT;\n                if (!connptr->error_variables) {\n                        if (safe_write (connptr->server_fd, buffer, len) < 0)\n                                goto ERROR_EXIT;\n                }\n                length -= len;\n        } while (length > 0);\n        if (iehack) {\n                ret = socket_nonblocking (connptr->client_fd);\n                if (ret != 0) {\n                        log_message(LOG_ERR, \"Failed to set the client socket \"\n                                    \"to non-blocking: %s\", strerror(errno));\n                        goto ERROR_EXIT;\n                }\n                len = recv (connptr->client_fd, buffer, 2, MSG_PEEK);\n                ret = socket_blocking (connptr->client_fd);\n                if (ret != 0) {\n                        log_message(LOG_ERR, \"Failed to set the client socket \"\n                                    \"to blocking: %s\", strerror(errno));\n                        goto ERROR_EXIT;\n                }\n                if (len < 0 && errno != EAGAIN)\n                        goto ERROR_EXIT;\n                if ((len == 2) && CHECK_CRLF (buffer, len)) {\n                        ssize_t bytes_read;\n                        bytes_read = read (connptr->client_fd, buffer, 2);\n                        if (bytes_read == -1) {\n                                log_message\n                                        (LOG_WARNING,\n                                         \"Could not read two bytes from POST message\");\n                        }\n                }\n        }\n        safefree (buffer);\n        return 0;\nERROR_EXIT:\n        safefree (buffer);\n        return -1;\n}", "target": 0}
{"code": "find_matching_ref (GHashTable  *refs,\n                   const char  *name,\n                   const char  *opt_branch,\n                   const char  *opt_default_branch,\n                   const char  *opt_arch,\n                   FlatpakKinds kinds,\n                   GError     **error)\n{\n  const char **arches = flatpak_get_arches ();\n  const char *opt_arches[] = {opt_arch, NULL};\n  int i;\n  if (opt_arch != NULL)\n    arches = opt_arches;\n  for (i = 0; arches[i] != NULL; i++)\n    {\n      g_autoptr(GPtrArray) matched_refs = NULL;\n      int j;\n      matched_refs = find_matching_refs (refs,\n                                         name,\n                                         opt_branch,\n                                         opt_default_branch,\n                                         arches[i],\n                                         NULL,\n                                         kinds,\n                                         FIND_MATCHING_REFS_FLAGS_NONE,\n                                         error);\n      if (matched_refs == NULL)\n        return NULL;\n      if (matched_refs->len == 0)\n        continue;\n      if (matched_refs->len == 1)\n        return flatpak_decomposed_ref (g_ptr_array_index (matched_refs, 0));\n      g_autoptr(GString) err = g_string_new (\"\");\n      g_string_printf (err, _(\"Multiple branches available for %s, you must specify one of: \"), name);\n      g_ptr_array_sort (matched_refs, flatpak_strcmp0_ptr);\n      for (j = 0; j < matched_refs->len; j++)\n        {\n          FlatpakDecomposed *ref = g_ptr_array_index (matched_refs, j);\n          if (j != 0)\n            g_string_append (err, \", \");\n          const char *branch = flatpak_decomposed_get_branch (ref);\n          g_string_append (err,\n                           g_strdup_printf (\"%s/%s/%s\",\n                                            name,\n                                            opt_arch ? opt_arch : \"\",\n                                            branch));\n        }\n      flatpak_fail (error, \"%s\", err->str);\n      return NULL;\n    }\n  g_set_error (error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND,\n               _(\"Nothing matches %s\"), name);\n  return NULL;\n}", "target": 0}
{"code": "static int inotify_release(struct inode *ignored, struct file *file)\n{\n\tstruct fsnotify_group *group = file->private_data;\n\tstruct user_struct *user = group->inotify_data.user;\n\tpr_debug(\"%s: group=%p\\n\", __func__, group);\n\tfsnotify_clear_marks_by_group(group);\n\tfsnotify_put_group(group);\n\tatomic_dec(&user->inotify_devs);\n\treturn 0;\n}", "target": 1}
{"code": "lsof_parse (const char *stdout,\n            GPtrArray *processes)\n{\n  int n;\n  char **tokens;\n  tokens = g_strsplit (stdout, \"\\n\", 0);\n  for (n = 0; tokens[n] != NULL; n++)\n    {\n      pid_t pid;\n      uid_t uid;\n      char *command_line;\n      GValue elem =\n        { 0 };\n      if (strlen (tokens[n]) == 0)\n        continue;\n      pid = strtol (tokens[n], NULL, 0);\n      uid = get_uid_for_pid (pid);\n      command_line = get_command_line_for_pid (pid);\n      g_value_init (&elem, LSOF_DATA_STRUCT_TYPE);\n      g_value_take_boxed (&elem, dbus_g_type_specialized_construct (LSOF_DATA_STRUCT_TYPE));\n      dbus_g_type_struct_set (&elem, 0, pid, 1, uid, 2, command_line != NULL ? command_line : \"\", G_MAXUINT);\n      g_ptr_array_add (processes, g_value_get_boxed (&elem));\n      g_free (command_line);\n    }\n  g_strfreev (tokens);\n}", "target": 0}
{"code": "void rose_start_heartbeat(struct sock *sk)\n{\n\tdel_timer(&sk->sk_timer);\n\tsk->sk_timer.function = rose_heartbeat_expiry;\n\tsk->sk_timer.expires  = jiffies + 5 * HZ;\n\tadd_timer(&sk->sk_timer);\n}", "target": 1}
{"code": "static int wrap_nettle_hash_fast(gnutls_digest_algorithm_t algo,\n\t\t\t\t const void *text, size_t text_size,\n\t\t\t\t void *digest)\n{\n\tstruct nettle_hash_ctx ctx;\n\tint ret;\n\tret = _ctx_init(algo, &ctx);\n\tif (ret < 0)\n\t\treturn gnutls_assert_val(ret);\n\tctx.update(&ctx, text_size, text);\n\tctx.digest(&ctx, ctx.length, digest);\n\treturn 0;\n}", "target": 1}
{"code": "static int fsck_tag(struct tag *tag, const char *data,\n\tunsigned long size, struct fsck_options *options)\n{\n\tstruct object *tagged = tag->tagged;\n\tif (!tagged)\n\t\treturn report(options, &tag->object, FSCK_MSG_BAD_TAG_OBJECT, \"could not load tagged object\");\n\treturn fsck_tag_buffer(tag, data, size, options);\n}", "target": 0}
{"code": "void decode_prediction_unit(base_context* ctx,\n                            const slice_segment_header* shdr,\n                            de265_image* img,\n                            const PBMotionCoding& motion,\n                            int xC,int yC, int xB,int yB, int nCS, int nPbW,int nPbH, int partIdx)\n{\n  logtrace(LogMotion,\"decode_prediction_unit POC=%d %d;%d %dx%d\\n\",\n           img->PicOrderCntVal, xC+xB,yC+yB, nPbW,nPbH);\n  PBMotion vi;\n  motion_vectors_and_ref_indices(ctx, shdr, img, motion,\n                                 xC,yC, xB,yB, nCS, nPbW,nPbH, partIdx, &vi);\n  generate_inter_prediction_samples(ctx,shdr, img, xC,yC, xB,yB, nCS, nPbW,nPbH, &vi);\n  img->set_mv_info(xC+xB,yC+yB,nPbW,nPbH, vi);\n}", "target": 0}
{"code": "static int hardware_enable(void)\n{\n\tint cpu = raw_smp_processor_id();\n\tu64 phys_addr = __pa(per_cpu(vmxarea, cpu));\n\tu64 old, test_bits;\n\tif (read_cr4() & X86_CR4_VMXE)\n\t\treturn -EBUSY;\n\tINIT_LIST_HEAD(&per_cpu(loaded_vmcss_on_cpu, cpu));\n\tcrash_enable_local_vmclear(cpu);\n\trdmsrl(MSR_IA32_FEATURE_CONTROL, old);\n\ttest_bits = FEATURE_CONTROL_LOCKED;\n\ttest_bits |= FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX;\n\tif (tboot_enabled())\n\t\ttest_bits |= FEATURE_CONTROL_VMXON_ENABLED_INSIDE_SMX;\n\tif ((old & test_bits) != test_bits) {\n\t\twrmsrl(MSR_IA32_FEATURE_CONTROL, old | test_bits);\n\t}\n\twrite_cr4(read_cr4() | X86_CR4_VMXE); \n\tif (vmm_exclusive) {\n\t\tkvm_cpu_vmxon(phys_addr);\n\t\tept_sync_global();\n\t}\n\tnative_store_gdt(this_cpu_ptr(&host_gdt));\n\treturn 0;\n}", "target": 0}
{"code": "static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)\n{\n\tgit_pkt *pkt;\n\tconst char *line, *line_end = NULL;\n\tsize_t line_len;\n\tint error;\n\tint reading_from_buf = data_pkt_buf->size > 0;\n\tif (reading_from_buf) {\n\t\tgit_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);\n\t\tline = data_pkt_buf->ptr;\n\t\tline_len = data_pkt_buf->size;\n\t}\n\telse {\n\t\tline = data_pkt->data;\n\t\tline_len = data_pkt->len;\n\t}\n\twhile (line_len > 0) {\n\t\terror = git_pkt_parse_line(&pkt, line, &line_end, line_len);\n\t\tif (error == GIT_EBUFS) {\n\t\t\tif (!reading_from_buf)\n\t\t\t\tgit_buf_put(data_pkt_buf, line, line_len);\n\t\t\terror = 0;\n\t\t\tgoto done;\n\t\t}\n\t\telse if (error < 0)\n\t\t\tgoto done;\n\t\tline_len -= (line_end - line);\n\t\tline = line_end;\n\t\tif (pkt == NULL)\n\t\t\tcontinue;\n\t\terror = add_push_report_pkt(push, pkt);\n\t\tgit_pkt_free(pkt);\n\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\tgoto done;\n\t}\n\terror = 0;\ndone:\n\tif (reading_from_buf)\n\t\tgit_buf_consume(data_pkt_buf, line_end);\n\treturn error;\n}", "target": 1}
{"code": "static void WritePackbitsLength(const PSDInfo *psd_info,\n  const ImageInfo *image_info,Image *image,Image *next_image,\n  unsigned char *compact_pixels,const QuantumType quantum_type,\n  ExceptionInfo *exception)\n{\n  QuantumInfo\n    *quantum_info;\n  register const Quantum\n    *p;\n  size_t\n    length,\n    packet_size;\n  ssize_t\n    y;\n  unsigned char\n    *pixels;\n  if (next_image->depth > 8)\n    next_image->depth=16;\n  packet_size=next_image->depth > 8UL ? 2UL : 1UL;\n  (void) packet_size;\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n  for (y=0; y < (ssize_t) next_image->rows; y++)\n  {\n    p=GetVirtualPixels(next_image,0,y,next_image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    length=ExportQuantumPixels(next_image,(CacheView *) NULL,quantum_info,\n      quantum_type,pixels,exception);\n    length=PSDPackbitsEncodeImage(image,length,pixels,compact_pixels,\n      exception);\n    (void) SetPSDOffset(psd_info,image,length);\n  }\n  quantum_info=DestroyQuantumInfo(quantum_info);\n}", "target": 0}
{"code": "void kvm_lapic_sync_to_vapic(struct kvm_vcpu *vcpu)\n{\n\tu32 data, tpr;\n\tint max_irr, max_isr;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tvoid *vapic;\n\tapic_sync_pv_eoi_to_guest(vcpu, apic);\n\tif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\n\t\treturn;\n\ttpr = kvm_apic_get_reg(apic, APIC_TASKPRI) & 0xff;\n\tmax_irr = apic_find_highest_irr(apic);\n\tif (max_irr < 0)\n\t\tmax_irr = 0;\n\tmax_isr = apic_find_highest_isr(apic);\n\tif (max_isr < 0)\n\t\tmax_isr = 0;\n\tdata = (tpr & 0xff) | ((max_isr & 0xf0) << 8) | (max_irr << 24);\n\tvapic = kmap_atomic(vcpu->arch.apic->vapic_page);\n\t*(u32 *)(vapic + offset_in_page(vcpu->arch.apic->vapic_addr)) = data;\n\tkunmap_atomic(vapic);\n}", "target": 1}
{"code": "static inline void switch_to_bitmap(unsigned long tifp)\n{\n\tif (tifp & _TIF_IO_BITMAP)\n\t\ttss_invalidate_io_bitmap(this_cpu_ptr(&cpu_tss_rw));\n}", "target": 1}
{"code": "void http_capture_bad_message(struct error_snapshot *es, struct session *s,\n                              struct buffer *buf, struct http_msg *msg,\n\t\t\t      int state, struct proxy *other_end)\n{\n\tif (buf->r <= (buf->data + msg->som)) { \n\t\tint len1 = buf->size - msg->som;\n\t\tes->len = buf->r - (buf->data + msg->som) + buf->size;\n\t\tmemcpy(es->buf, buf->data + msg->som, MIN(len1, sizeof(es->buf)));\n\t\tif (es->len > len1 && len1 < sizeof(es->buf))\n\t\t\tmemcpy(es->buf + len1, buf->data, MIN(es->len, sizeof(es->buf)) - len1);\n\t}\n\telse {\n\t\tes->len = buf->r - (buf->data + msg->som);\n\t\tmemcpy(es->buf, buf->data + msg->som, MIN(es->len, sizeof(es->buf)));\n\t}\n\tif (msg->err_pos >= 0)\n\t\tes->pos  = msg->err_pos - msg->som;\n\telse if (buf->lr >= (buf->data + msg->som))\n\t\tes->pos  = buf->lr - (buf->data + msg->som);\n\telse\n\t\tes->pos  = buf->lr - (buf->data + msg->som) + buf->size;\n\tes->when = date; \n\tes->sid  = s->uniq_id;\n\tes->srv  = s->srv;\n\tes->oe   = other_end;\n\tes->src  = s->cli_addr;\n\tes->state = state;\n\tes->flags = buf->flags;\n\tes->ev_id = error_snapshot_id++;\n}", "target": 0}
{"code": "sort_page_names (gconstpointer a,\n                 gconstpointer b)\n{\n\tconst char *name_1, *name_2;\n\tgchar *key_1, *key_2;\n\tgboolean sort_last_1, sort_last_2;\n\tint compare;\n\tname_1 = * (const char **) a;\n\tname_2 = * (const char **) b;\n\t#define SORT_LAST_CHAR1 '.'\n\t#define SORT_LAST_CHAR2 '#'\n\tsort_last_1 = name_1[0] == SORT_LAST_CHAR1 || name_1[0] == SORT_LAST_CHAR2;\n\tsort_last_2 = name_2[0] == SORT_LAST_CHAR1 || name_2[0] == SORT_LAST_CHAR2;\n\t#undef SORT_LAST_CHAR1\n\t#undef SORT_LAST_CHAR2\n\tif (sort_last_1 && !sort_last_2)\n\t{\n\t\tcompare = +1;\n\t}\n\telse if (!sort_last_1 && sort_last_2)\n\t{\n\t\tcompare = -1;\n\t} \n\telse\n\t{\n\t\tkey_1 = g_utf8_collate_key_for_filename (name_1, -1);\n\t\tkey_2 = g_utf8_collate_key_for_filename (name_2, -1);\n\t\tcompare = strcmp (key_1, key_2);\n\t\tg_free (key_1);\n\t\tg_free (key_2);\n\t}\n\treturn compare;\n}", "target": 0}
{"code": "static int is_branch32_taken(struct bpf_reg_state *reg, u32 val, u8 opcode)\n{\n\tstruct tnum subreg = tnum_subreg(reg->var_off);\n\ts32 sval = (s32)val;\n\tswitch (opcode) {\n\tcase BPF_JEQ:\n\t\tif (tnum_is_const(subreg))\n\t\t\treturn !!tnum_equals_const(subreg, val);\n\t\tbreak;\n\tcase BPF_JNE:\n\t\tif (tnum_is_const(subreg))\n\t\t\treturn !tnum_equals_const(subreg, val);\n\t\tbreak;\n\tcase BPF_JSET:\n\t\tif ((~subreg.mask & subreg.value) & val)\n\t\t\treturn 1;\n\t\tif (!((subreg.mask | subreg.value) & val))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JGT:\n\t\tif (reg->u32_min_value > val)\n\t\t\treturn 1;\n\t\telse if (reg->u32_max_value <= val)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JSGT:\n\t\tif (reg->s32_min_value > sval)\n\t\t\treturn 1;\n\t\telse if (reg->s32_max_value <= sval)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JLT:\n\t\tif (reg->u32_max_value < val)\n\t\t\treturn 1;\n\t\telse if (reg->u32_min_value >= val)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JSLT:\n\t\tif (reg->s32_max_value < sval)\n\t\t\treturn 1;\n\t\telse if (reg->s32_min_value >= sval)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JGE:\n\t\tif (reg->u32_min_value >= val)\n\t\t\treturn 1;\n\t\telse if (reg->u32_max_value < val)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JSGE:\n\t\tif (reg->s32_min_value >= sval)\n\t\t\treturn 1;\n\t\telse if (reg->s32_max_value < sval)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JLE:\n\t\tif (reg->u32_max_value <= val)\n\t\t\treturn 1;\n\t\telse if (reg->u32_min_value > val)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JSLE:\n\t\tif (reg->s32_max_value <= sval)\n\t\t\treturn 1;\n\t\telse if (reg->s32_min_value > sval)\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\treturn -1;\n}", "target": 0}
{"code": "int ImagingLibTiffEncodeInit(ImagingCodecState state, char *filename, int fp) {\n    TIFFSTATE *clientstate = (TIFFSTATE *)state->context;\n    int bufsize = 64*1024;\n    char *mode = \"w\";\n    TRACE((\"initing libtiff\\n\"));\n    TRACE((\"Filename %s, filepointer: %d \\n\", filename,  fp));\n    TRACE((\"State: count %d, state %d, x %d, y %d, ystep %d\\n\", state->count, state->state,\n           state->x, state->y, state->ystep));\n    TRACE((\"State: xsize %d, ysize %d, xoff %d, yoff %d \\n\", state->xsize, state->ysize,\n           state->xoff, state->yoff));\n    TRACE((\"State: bits %d, bytes %d \\n\", state->bits, state->bytes));\n    TRACE((\"State: context %p \\n\", state->context));\n    clientstate->loc = 0;\n    clientstate->size = 0;\n    clientstate->eof =0;\n    clientstate->data = 0;\n    clientstate->flrealloc = 0;\n    clientstate->fp = fp;\n    state->state = 0;\n    if (fp) {\n        TRACE((\"Opening using fd: %d for writing \\n\",clientstate->fp));\n        clientstate->tiff = TIFFFdOpen(clientstate->fp, filename, mode);\n    } else {\n        TRACE((\"Opening a buffer for writing \\n\"));\n        clientstate->data = malloc(bufsize);\n        clientstate->size = bufsize;\n        clientstate->flrealloc=1;\n        if (!clientstate->data) {\n            TRACE((\"Error, couldn't allocate a buffer of size %d\\n\", bufsize));\n            return 0;\n        }\n        clientstate->tiff = TIFFClientOpen(filename, mode,\n                                           (thandle_t) clientstate,\n                                           _tiffReadProc, _tiffWriteProc,\n                                           _tiffSeekProc, _tiffCloseProc, _tiffSizeProc,\n                                           _tiffNullMapProc, _tiffUnmapProc); \n    }\n    if (!clientstate->tiff) {\n        TRACE((\"Error, couldn't open tiff file\\n\"));\n        return 0;\n    }\n    return 1;\n}", "target": 0}
{"code": "static const char* getenv_harder(pam_handle_t *handle, const char *key, const char *fallback) {\n        const char *v;\n        assert(handle);\n        assert(key);\n        v = pam_getenv(handle, key);\n        if (!isempty(v))\n                return v;\n        v = getenv(key);\n        if (!isempty(v))\n                return v;\n        return fallback;\n}", "target": 1}
{"code": "static int selinux_key_permission(key_ref_t key_ref,\n\t\t\t\t  const struct cred *cred,\n\t\t\t\t  unsigned perm)\n{\n\tstruct key *key;\n\tstruct key_security_struct *ksec;\n\tu32 sid;\n\tif (perm == 0)\n\t\treturn 0;\n\tsid = cred_sid(cred);\n\tkey = key_ref_to_ptr(key_ref);\n\tksec = key->security;\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    sid, ksec->sid, SECCLASS_KEY, perm, NULL);\n}", "target": 0}
{"code": "static inline void jmp_rel(struct x86_emulate_ctxt *ctxt, int rel)\n{\n\tassign_eip_near(ctxt, ctxt->_eip + rel);\n}", "target": 1}
{"code": "static void ufs_mtk_init_va09_pwr_ctrl(struct ufs_hba *hba)\n{\n\tstruct ufs_mtk_host *host = ufshcd_get_variant(hba);\n\thost->reg_va09 = regulator_get(hba->dev, \"va09\");\n\tif (!host->reg_va09)\n\t\tdev_info(hba->dev, \"failed to get va09\");\n\telse\n\t\thost->caps |= UFS_MTK_CAP_VA09_PWR_CTRL;\n}", "target": 1}
{"code": "static void unix_detach_fds(struct scm_cookie *scm, struct sk_buff *skb)\n{\n\tint i;\n\tscm->fp = UNIXCB(skb).fp;\n\tUNIXCB(skb).fp = NULL;\n\tfor (i = scm->fp->count-1; i >= 0; i--)\n\t\tunix_notinflight(scm->fp->fp[i]);\n}", "target": 1}
{"code": "njs_string_prototype_char_at(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    size_t             length;\n    int64_t            start;\n    njs_int_t          ret;\n    njs_slice_prop_t   slice;\n    njs_string_prop_t  string;\n    ret = njs_string_object_validate(vm, njs_argument(args, 0));\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    slice.string_length = njs_string_prop(&string, njs_argument(args, 0));\n    ret = njs_value_to_integer(vm, njs_arg(args, nargs, 1), &start);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    length = 1;\n    if (start < 0 || start >= (int64_t) slice.string_length) {\n        start = 0;\n        length = 0;\n    }\n    slice.start = start;\n    slice.length = length;\n    return njs_string_slice(vm, &vm->retval, &string, &slice);\n}", "target": 0}
{"code": "int ip6_dst_hoplimit(struct dst_entry *dst)\n{\n\tint hoplimit = dst_metric_raw(dst, RTAX_HOPLIMIT);\n\tif (hoplimit == 0) {\n\t\tstruct net_device *dev = dst->dev;\n\t\tstruct inet6_dev *idev;\n\t\trcu_read_lock();\n\t\tidev = __in6_dev_get(dev);\n\t\tif (idev)\n\t\t\thoplimit = idev->cnf.hop_limit;\n\t\telse\n\t\t\thoplimit = dev_net(dev)->ipv6.devconf_all->hop_limit;\n\t\trcu_read_unlock();\n\t}\n\treturn hoplimit;\n}", "target": 0}
{"code": "static int install_permanent_handler(int num_cpus, uintptr_t smbase,\n\t\t\t\t\tsize_t smsize, size_t save_state_size)\n{\n\tstruct smm_loader_params smm_params = {\n\t\t.per_cpu_stack_size = CONFIG_SMM_MODULE_STACK_SIZE,\n\t\t.num_concurrent_stacks = num_cpus,\n\t\t.per_cpu_save_state_size = save_state_size,\n\t\t.num_concurrent_save_states = num_cpus,\n\t};\n\tif (mp_state.ops.adjust_smm_params != NULL)\n\t\tmp_state.ops.adjust_smm_params(&smm_params, 1);\n\tprintk(BIOS_DEBUG, \"Installing SMM handler to 0x%08lx\\n\", smbase);\n\tif (smm_load_module((void *)smbase, smsize, &smm_params))\n\t\treturn -1;\n\tadjust_smm_apic_id_map(&smm_params);\n\treturn 0;\n}", "target": 1}
{"code": "static int __dwc3_gadget_kick_transfer(struct dwc3_ep *dep)\n{\n\tstruct dwc3_gadget_ep_cmd_params params;\n\tstruct dwc3_request\t\t*req;\n\tint\t\t\t\tstarting;\n\tint\t\t\t\tret;\n\tu32\t\t\t\tcmd;\n\tif (!dwc3_calc_trbs_left(dep))\n\t\treturn 0;\n\tstarting = !(dep->flags & DWC3_EP_BUSY);\n\tdwc3_prepare_trbs(dep);\n\treq = next_request(&dep->started_list);\n\tif (!req) {\n\t\tdep->flags |= DWC3_EP_PENDING_REQUEST;\n\t\treturn 0;\n\t}\n\tmemset(&params, 0, sizeof(params));\n\tif (starting) {\n\t\tparams.param0 = upper_32_bits(req->trb_dma);\n\t\tparams.param1 = lower_32_bits(req->trb_dma);\n\t\tcmd = DWC3_DEPCMD_STARTTRANSFER;\n\t\tif (usb_endpoint_xfer_isoc(dep->endpoint.desc))\n\t\t\tcmd |= DWC3_DEPCMD_PARAM(dep->frame_number);\n\t} else {\n\t\tcmd = DWC3_DEPCMD_UPDATETRANSFER |\n\t\t\tDWC3_DEPCMD_PARAM(dep->resource_index);\n\t}\n\tret = dwc3_send_gadget_ep_cmd(dep, cmd, &params);\n\tif (ret < 0) {\n\t\tif (req->trb)\n\t\t\tmemset(req->trb, 0, sizeof(struct dwc3_trb));\n\t\tdep->queued_requests--;\n\t\tdwc3_gadget_giveback(dep, req, ret);\n\t\treturn ret;\n\t}\n\tdep->flags |= DWC3_EP_BUSY;\n\tif (starting) {\n\t\tdep->resource_index = dwc3_gadget_ep_get_transfer_index(dep);\n\t\tWARN_ON_ONCE(!dep->resource_index);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "hb_ot_layout_build_glyph_classes (hb_face_t      *face,\n\t\t\t\t  uint16_t        num_total_glyphs,\n\t\t\t\t  hb_codepoint_t *glyphs,\n\t\t\t\t  unsigned char  *klasses,\n\t\t\t\t  uint16_t        count)\n{\n  if (HB_OBJECT_IS_INERT (face))\n    return;\n  hb_ot_layout_t *layout = &face->ot_layout;\n  if (HB_UNLIKELY (!count || !glyphs || !klasses))\n    return;\n  if (layout->new_gdef.len == 0) {\n    layout->new_gdef.klasses = (unsigned char *) calloc (num_total_glyphs, sizeof (unsigned char));\n    layout->new_gdef.len = count;\n  }\n  for (unsigned int i = 0; i < count; i++)\n    _hb_ot_layout_set_glyph_class (face, glyphs[i], (hb_ot_layout_glyph_class_t) klasses[i]);\n}", "target": 1}
{"code": "static inline int fpregs_state_valid(struct fpu *fpu, unsigned int cpu)\n{\n\treturn fpu == this_cpu_read_stable(fpu_fpregs_owner_ctx) && cpu == fpu->last_cpu;\n}", "target": 1}
{"code": "static int gup_huge_pgd(pgd_t orig, pgd_t *pgdp, unsigned long addr,\n\t\t\tunsigned long end, int write,\n\t\t\tstruct page **pages, int *nr)\n{\n\tint refs;\n\tstruct page *head, *page;\n\tif (!pgd_access_permitted(orig, write))\n\t\treturn 0;\n\tBUILD_BUG_ON(pgd_devmap(orig));\n\trefs = 0;\n\tpage = pgd_page(orig) + ((addr & ~PGDIR_MASK) >> PAGE_SHIFT);\n\tdo {\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\t\tpage++;\n\t\trefs++;\n\t} while (addr += PAGE_SIZE, addr != end);\n\thead = compound_head(pgd_page(orig));\n\tif (!page_cache_add_speculative(head, refs)) {\n\t\t*nr -= refs;\n\t\treturn 0;\n\t}\n\tif (unlikely(pgd_val(orig) != pgd_val(*pgdp))) {\n\t\t*nr -= refs;\n\t\twhile (refs--)\n\t\t\tput_page(head);\n\t\treturn 0;\n\t}\n\tSetPageReferenced(head);\n\treturn 1;\n}", "target": 1}
{"code": "resp_new (const char *head)\n{\n  const char *hdr;\n  int count, size;\n  struct response *resp = xnew0 (struct response);\n  resp->data = head;\n  if (*head == '\\0')\n    {\n      return resp;\n    }\n  size = count = 0;\n  hdr = head;\n  while (1)\n    {\n      DO_REALLOC (resp->headers, size, count + 1, const char *);\n      resp->headers[count++] = hdr;\n      if (!hdr[0] || (hdr[0] == '\\r' && hdr[1] == '\\n') || hdr[0] == '\\n')\n        break;\n      do\n        {\n          const char *end = strchr (hdr, '\\n');\n          if (end)\n            hdr = end + 1;\n          else\n            hdr += strlen (hdr);\n        }\n      while (*hdr == ' ' || *hdr == '\\t');\n    }\n  DO_REALLOC (resp->headers, size, count + 1, const char *);\n  resp->headers[count] = NULL;\n  return resp;\n}", "target": 1}
{"code": "SYSCALL_DEFINE3(sched_setattr, pid_t, pid, struct sched_attr __user *, uattr,\n\t\t\t       unsigned int, flags)\n{\n\tstruct sched_attr attr;\n\tstruct task_struct *p;\n\tint retval;\n\tif (!uattr || pid < 0 || flags)\n\t\treturn -EINVAL;\n\tretval = sched_copy_attr(uattr, &attr);\n\tif (retval)\n\t\treturn retval;\n\tif ((int)attr.sched_policy < 0)\n\t\treturn -EINVAL;\n\trcu_read_lock();\n\tretval = -ESRCH;\n\tp = find_process_by_pid(pid);\n\tif (p != NULL)\n\t\tretval = sched_setattr(p, &attr);\n\trcu_read_unlock();\n\treturn retval;\n}", "target": 0}
{"code": "static void drop_sysctl_table(struct ctl_table_header *header)\n{\n\tstruct ctl_dir *parent = header->parent;\n\tif (--header->nreg)\n\t\treturn;\n\tif (parent)\n\t\tput_links(header);\n\tstart_unregistering(header);\n\tif (!--header->count)\n\t\tkfree_rcu(header, rcu);\n\tif (parent)\n\t\tdrop_sysctl_table(&parent->header);\n}", "target": 1}
{"code": "int jvp_number_cmp(jv a, jv b) {\n  assert(JVP_HAS_KIND(a, JV_KIND_NUMBER));\n  assert(JVP_HAS_KIND(b, JV_KIND_NUMBER));\n#ifdef USE_DECNUM\n  if (JVP_HAS_FLAGS(a, JVP_FLAGS_NUMBER_LITERAL) && JVP_HAS_FLAGS(b, JVP_FLAGS_NUMBER_LITERAL)) {\n    decNumber res;\n    decNumberCompare(&res,\n                     jvp_dec_number_ptr(a),\n                     jvp_dec_number_ptr(b),\n                     DEC_CONTEXT()\n                     );\n    if (decNumberIsZero(&res)) {\n      return 0;\n    } else if (decNumberIsNegative(&res)) {\n      return -1;\n    } else {\n      return 1;\n    }\n  }\n#endif\n  double da = jv_number_value(a), db = jv_number_value(b);\n  if (da < db) {\n    return -1;\n  } else if (da == db) {\n    return 0;\n  } else {\n    return 1;\n  }\n}", "target": 1}
{"code": "void RenderView::OnPepperPluginDestroy(\n    WebPluginDelegatePepper* pepper_plugin) {\n  std::set<WebPluginDelegatePepper*>::iterator found_pepper =\n      current_oldstyle_pepper_plugins_.find(pepper_plugin);\n  if (found_pepper == current_oldstyle_pepper_plugins_.end()) {\n    NOTREACHED();\n    return;\n  }\n  current_oldstyle_pepper_plugins_.erase(found_pepper);\n  for (std::deque< linked_ptr<PendingFileChooser> >::iterator i =\n           file_chooser_completions_.begin();\n       i != file_chooser_completions_.end(); ) {\n    if ((*i)->completion == pepper_plugin) {\n      if (i == file_chooser_completions_.begin())\n        (*i)->completion = NULL;\n      else\n        i = file_chooser_completions_.erase(i);\n    } else {\n      ++i;\n    }\n  }\n}", "target": 0}
{"code": "static ssize_t show_rxbuf(struct device *dev,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%lu\\n\", NET_RX_RING_SIZE);\n}", "target": 0}
{"code": "    template<typename t1, typename t2>\n    CImg<intT> get_patchmatch(const CImg<T>& patch_image,\n                              const unsigned int patch_width,\n                              const unsigned int patch_height,\n                              const unsigned int patch_depth,\n                              const unsigned int nb_iterations,\n                              const unsigned int nb_randoms,\n                              const CImg<t1> &guide,\n                              CImg<t2> &matching_score) const {\n      return _patchmatch(patch_image,patch_width,patch_height,patch_depth,\n                         nb_iterations,nb_randoms,\n                         guide,true,matching_score);", "target": 0}
{"code": "context_parse_args (FlatpakContext *context,\n                    ...)\n{\n  g_autoptr(GError) local_error = NULL;\n  g_autoptr(GOptionContext) oc = NULL;\n  g_autoptr(GOptionGroup) group = NULL;\n  g_autoptr(GPtrArray) args = g_ptr_array_new_with_free_func (g_free);\n  g_auto(GStrv) argv = NULL;\n  const char *arg;\n  va_list ap;\n  g_ptr_array_add (args, g_strdup (\"argv[0]\"));\n  va_start (ap, context);\n  while ((arg = va_arg (ap, const char *)) != NULL)\n    g_ptr_array_add (args, g_strdup (arg));\n  va_end (ap);\n  g_ptr_array_add (args, NULL);\n  argv = (GStrv) g_ptr_array_free (g_steal_pointer (&args), FALSE);\n  oc = g_option_context_new (\"\");\n  group = flatpak_context_get_options (context);\n  g_option_context_add_group (oc, group);\n  g_option_context_parse_strv (oc, &argv, &local_error);\n  g_assert_no_error (local_error);\n}", "target": 1}
{"code": "void hashTypeTryConversion(robj *o, robj **argv, int start, int end) {\n    int i;\n    if (o->encoding != OBJ_ENCODING_ZIPLIST) return;\n    for (i = start; i <= end; i++) {\n        if (sdsEncodedObject(argv[i]) &&\n            sdslen(argv[i]->ptr) > server.hash_max_ziplist_value)\n        {\n            hashTypeConvert(o, OBJ_ENCODING_HT);\n            break;\n        }\n    }\n}", "target": 1}
{"code": "static int read_private_key(RSA *rsa)\n{\n\tint r;\n\tsc_path_t path;\n\tsc_file_t *file;\n\tconst sc_acl_entry_t *e;\n\tu8 buf[2048], *p = buf;\n\tsize_t bufsize, keysize;\n\tr = select_app_df();\n\tif (r)\n\t\treturn 1;\n\tsc_format_path(\"I0012\", &path);\n\tr = sc_select_file(card, &path, &file);\n\tif (r) {\n\t\tfprintf(stderr, \"Unable to select private key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\te = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n\tif (e == NULL || e->method == SC_AC_NEVER)\n\t\treturn 10;\n\tbufsize = MIN(file->size, sizeof buf);\n\tsc_file_free(file);\n\tr = sc_read_binary(card, 0, buf, bufsize, 0);\n\tif (r < 0) {\n\t\tfprintf(stderr, \"Unable to read private key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\tbufsize = r;\n\tdo {\n\t\tif (bufsize < 4)\n\t\t\treturn 3;\n\t\tkeysize = (p[0] << 8) | p[1];\n\t\tif (keysize == 0)\n\t\t\tbreak;\n\t\tif (keysize < 3)\n\t\t\treturn 3;\n\t\tif (p[2] == opt_key_num)\n\t\t\tbreak;\n\t\tp += keysize;\n\t\tbufsize -= keysize;\n\t} while (1);\n\tif (keysize == 0) {\n\t\tprintf(\"Key number %d not found.\\n\", opt_key_num);\n\t\treturn 2;\n\t}\n\treturn parse_private_key(p, keysize, rsa);\n}", "target": 0}
{"code": "static inline unsigned char *__skb_put(struct sk_buff *skb, unsigned int len)\n{\n\tunsigned char *tmp = skb_tail_pointer(skb);\n\tSKB_LINEAR_ASSERT(skb);\n\tskb->tail += len;\n\tskb->len  += len;\n\treturn tmp;\n}", "target": 0}
{"code": "static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_comp rcomp;\n\tsnprintf(rcomp.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"compression\");\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n\t\t    sizeof(struct crypto_report_comp), &rcomp))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "static int alarm_timer_nsleep(const clockid_t which_clock, int flags,\n\t\t\t      const struct timespec64 *tsreq)\n{\n\tenum  alarmtimer_type type = clock2alarm(which_clock);\n\tstruct restart_block *restart = &current->restart_block;\n\tstruct alarm alarm;\n\tktime_t exp;\n\tint ret = 0;\n\tif (!alarmtimer_get_rtcdev())\n\t\treturn -ENOTSUPP;\n\tif (flags & ~TIMER_ABSTIME)\n\t\treturn -EINVAL;\n\tif (!capable(CAP_WAKE_ALARM))\n\t\treturn -EPERM;\n\talarm_init_on_stack(&alarm, type, alarmtimer_nsleep_wakeup);\n\texp = timespec64_to_ktime(*tsreq);\n\tif (flags != TIMER_ABSTIME) {\n\t\tktime_t now = alarm_bases[type].gettime();\n\t\texp = ktime_add(now, exp);\n\t}\n\tret = alarmtimer_do_nsleep(&alarm, exp, type);\n\tif (ret != -ERESTART_RESTARTBLOCK)\n\t\treturn ret;\n\tif (flags == TIMER_ABSTIME)\n\t\treturn -ERESTARTNOHAND;\n\trestart->fn = alarm_timer_nsleep_restart;\n\trestart->nanosleep.clockid = type;\n\trestart->nanosleep.expires = exp;\n\treturn ret;\n}", "target": 1}
{"code": "struct nfs_open_context *nfs_find_open_context(struct inode *inode, struct rpc_cred *cred, int mode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_open_context *pos, *ctx = NULL;\n\tspin_lock(&inode->i_lock);\n\tlist_for_each_entry(pos, &nfsi->open_files, list) {\n\t\tif (cred != NULL && pos->cred != cred)\n\t\t\tcontinue;\n\t\tif ((pos->mode & mode) == mode) {\n\t\t\tctx = get_nfs_open_context(pos);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn ctx;\n}", "target": 1}
{"code": "_gcry_ecc_eddsa_compute_h_d (unsigned char **r_digest,\n                             gcry_mpi_t d, mpi_ec_t ec)\n{\n  gpg_err_code_t rc;\n  unsigned char *rawmpi = NULL;\n  unsigned int rawmpilen;\n  unsigned char *digest;\n  gcry_buffer_t hvec[2];\n  int hashalgo, b;\n  *r_digest = NULL;\n  hashalgo = GCRY_MD_SHA512;\n  if (hashalgo != GCRY_MD_SHA512)\n    return GPG_ERR_DIGEST_ALGO;\n  b = (ec->nbits+7)/8;\n  if (b != 256/8)\n    return GPG_ERR_INTERNAL; \n  digest = xtrycalloc_secure (2, b);\n  if (!digest)\n    return gpg_err_code_from_syserror ();\n  memset (hvec, 0, sizeof hvec);\n  rawmpi = _gcry_mpi_get_buffer (d, 0, &rawmpilen, NULL);\n  if (!rawmpi)\n    {\n      xfree (digest);\n      return gpg_err_code_from_syserror ();\n    }\n  hvec[0].data = digest;\n  hvec[0].off = 0;\n  hvec[0].len = b > rawmpilen? b - rawmpilen : 0;\n  hvec[1].data = rawmpi;\n  hvec[1].off = 0;\n  hvec[1].len = rawmpilen;\n  rc = _gcry_md_hash_buffers (hashalgo, 0, digest, hvec, 2);\n  xfree (rawmpi);\n  if (rc)\n    {\n      xfree (digest);\n      return rc;\n    }\n  reverse_buffer (digest, 32);  \n  digest[0]   = (digest[0] & 0x7f) | 0x40;\n  digest[31] &= 0xf8;\n  *r_digest = digest;\n  return 0;\n}", "target": 0}
{"code": "jpeg_getc (j_decompress_ptr cinfo)\n{\n  struct jpeg_source_mgr *datasrc = cinfo->src;\n  if (datasrc->bytes_in_buffer == 0) {\n    if (! (*datasrc->fill_input_buffer) (cinfo))\n      ERREXIT(cinfo, JERR_CANT_SUSPEND);\n  }\n  datasrc->bytes_in_buffer--;\n  return GETJOCTET(*datasrc->next_input_byte++);\n}", "target": 0}
{"code": "static void timerfd_setup_cancel(struct timerfd_ctx *ctx, int flags)\n{\n\tif ((ctx->clockid == CLOCK_REALTIME ||\n\t     ctx->clockid == CLOCK_REALTIME_ALARM) &&\n\t    (flags & TFD_TIMER_ABSTIME) && (flags & TFD_TIMER_CANCEL_ON_SET)) {\n\t\tif (!ctx->might_cancel) {\n\t\t\tctx->might_cancel = true;\n\t\t\tspin_lock(&cancel_lock);\n\t\t\tlist_add_rcu(&ctx->clist, &cancel_list);\n\t\t\tspin_unlock(&cancel_lock);\n\t\t}\n\t} else if (ctx->might_cancel) {\n\t\ttimerfd_remove_cancel(ctx);\n\t}\n}", "target": 1}
{"code": "x509_verify_ctx_add_chain(struct x509_verify_ctx *ctx,\n    struct x509_verify_chain *chain, char *name)\n{\n\tsize_t depth;\n\tX509 *last = x509_verify_chain_last(chain);\n\tX509 *leaf = x509_verify_chain_leaf(chain);\n\tdepth = sk_X509_num(chain->certs);\n\tif (depth > 0)\n\t\tdepth--;\n\tif (ctx->chains_count >= ctx->max_chains)\n\t\treturn x509_verify_cert_error(ctx, last, depth,\n\t\t    X509_V_ERR_CERT_CHAIN_TOO_LONG, 0);\n\tif (chain->cert_errors[depth] ==\n\t    X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY)\n\t\tchain->cert_errors[depth] = X509_V_OK;\n\tif (!x509_verify_ctx_validate_legacy_chain(ctx, chain, depth))\n\t\treturn 0;\n\tif ((ctx->chains[ctx->chains_count] = x509_verify_chain_dup(chain)) ==\n\t    NULL) {\n\t\treturn x509_verify_cert_error(ctx, last, depth,\n\t\t    X509_V_ERR_OUT_OF_MEM, 0);\n\t}\n\tif (!x509_verify_cert_valid(ctx, leaf, NULL))\n\t\treturn 0;\n\tif (!x509_verify_cert_hostname(ctx, leaf, name))\n\t\treturn 0;\n\tctx->chains_count++;\n\tctx->error = X509_V_OK;\n\tctx->error_depth = depth;\n\treturn 1;\n}", "target": 1}
{"code": "int OutputValueSampler(CMSREGISTER const cmsUInt16Number In[], CMSREGISTER cmsUInt16Number Out[], CMSREGISTER void* Cargo)\n{\n    cmsPsSamplerCargo* sc = (cmsPsSamplerCargo*) Cargo;\n    cmsUInt32Number i;\n    if (sc -> FixWhite) {\n        if (In[0] == 0xFFFF) {  \n            if ((In[1] >= 0x7800 && In[1] <= 0x8800) &&\n                (In[2] >= 0x7800 && In[2] <= 0x8800)) {\n                cmsUInt16Number* Black;\n                cmsUInt16Number* White;\n                cmsUInt32Number nOutputs;\n                if (!_cmsEndPointsBySpace(sc ->ColorSpace, &White, &Black, &nOutputs))\n                        return 0;\n                for (i=0; i < nOutputs; i++)\n                        Out[i] = White[i];\n            }\n        }\n    }\n    if (In[0] != sc ->FirstComponent) {\n            if (sc ->FirstComponent != -1) {\n                    _cmsIOPrintf(sc ->m, sc ->PostMin);\n                    sc ->SecondComponent = -1;\n                    _cmsIOPrintf(sc ->m, sc ->PostMaj);\n            }\n            _cmsPSActualColumn = 0;\n            _cmsIOPrintf(sc ->m, sc ->PreMaj);\n            sc ->FirstComponent = In[0];\n    }\n      if (In[1] != sc ->SecondComponent) {\n            if (sc ->SecondComponent != -1) {\n                    _cmsIOPrintf(sc ->m, sc ->PostMin);\n            }\n            _cmsIOPrintf(sc ->m, sc ->PreMin);\n            sc ->SecondComponent = In[1];\n    }\n      for (i=0; i < sc -> Pipeline ->Params->nOutputs; i++) {\n          cmsUInt16Number wWordOut = Out[i];\n          cmsUInt8Number wByteOut;           \n          wByteOut = Word2Byte(wWordOut);\n          WriteByte(sc -> m, wByteOut);\n      }\n      return 1;\n}", "target": 0}
{"code": "static PHP_GINIT_FUNCTION(libxml)\n{\n        libxml_globals->stream_context = NULL;\n        libxml_globals->error_buffer.c = NULL;\n        libxml_globals->error_list = NULL;\n }", "target": 1}
{"code": "static inline u32 dma_low(dma_addr_t addr)\n{\n\treturn (u32)addr;\n}", "target": 1}
{"code": "static bool blk_kick_flush(struct request_queue *q, struct blk_flush_queue *fq)\n{\n\tstruct list_head *pending = &fq->flush_queue[fq->flush_pending_idx];\n\tstruct request *first_rq =\n\t\tlist_first_entry(pending, struct request, flush.list);\n\tstruct request *flush_rq = fq->flush_rq;\n\tif (fq->flush_pending_idx != fq->flush_running_idx || list_empty(pending))\n\t\treturn false;\n\tif (!list_empty(&fq->flush_data_in_flight) &&\n\t    time_before(jiffies,\n\t\t\tfq->flush_pending_since + FLUSH_PENDING_TIMEOUT))\n\t\treturn false;\n\tfq->flush_pending_idx ^= 1;\n\tblk_rq_init(q, flush_rq);\n\tif (q->mq_ops) {\n\t\tflush_rq->mq_ctx = first_rq->mq_ctx;\n\t\tflush_rq->tag = first_rq->tag;\n\t}\n\tflush_rq->cmd_type = REQ_TYPE_FS;\n\tflush_rq->cmd_flags = WRITE_FLUSH | REQ_FLUSH_SEQ;\n\tflush_rq->rq_disk = first_rq->rq_disk;\n\tflush_rq->end_io = flush_end_io;\n\treturn blk_flush_queue_rq(flush_rq, false);\n}", "target": 1}
{"code": " */\nstatic xmlNodePtr\nxmlXPathNextPrecedingInternal(xmlXPathParserContextPtr ctxt,\n                              xmlNodePtr cur)\n{\n    if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);\n    if (cur == NULL) {\n        cur = ctxt->context->node;\n        if (cur == NULL)\n            return (NULL);\n        if (cur->type == XML_NAMESPACE_DECL)\n            return (NULL);\n        ctxt->ancestor = cur->parent;\n    }\n    if (cur->type == XML_NAMESPACE_DECL)\n        return(NULL);\n    if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE))\n\tcur = cur->prev;\n    while (cur->prev == NULL) {\n        cur = cur->parent;\n        if (cur == NULL)\n            return (NULL);\n        if (cur == ctxt->context->doc->children)\n            return (NULL);\n        if (cur != ctxt->ancestor)\n            return (cur);\n        ctxt->ancestor = cur->parent;\n    }\n    cur = cur->prev;\n    while (cur->last != NULL)\n        cur = cur->last;", "target": 0}
{"code": "Server::clientWriteDone(const CommIoCbParams &io)\n{\n    debugs(33,5, io.conn);\n    Must(writer != nullptr);\n    writer = nullptr;\n    if (io.flag == Comm::ERR_CLOSING || !Comm::IsConnOpen(clientConnection)) {\n        debugs(33,5, io.conn << \" closing Bailout.\");\n        return;\n    }\n    Must(io.conn->fd == clientConnection->fd);\n    if (io.flag && pipeline.front())\n        pipeline.front()->initiateClose(\"write failure\");\n    afterClientWrite(io.size); \n    writeSomeData(); \n}", "target": 1}
{"code": "uint64_t HeaderMapImpl::byteSize() const {\n  uint64_t byte_size = 0;\n  for (const HeaderEntryImpl& header : headers_) {\n    byte_size += header.key().size();\n    byte_size += header.value().size();\n  }\n  return byte_size;\n}", "target": 1}
{"code": "sysObjectID_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  OID(sysObjectID_oid, 1, 3, 6, 1, 4, 1, 54352);\n  snmp_api_set_oid(varbind, oid, sysObjectID_oid);\n}", "target": 1}
{"code": "AirPDcapRsnaPwd2PskStep(\n    const guint8 *ppBytes,\n    const guint ppLength,\n    const CHAR *ssid,\n    const size_t ssidLength,\n    const INT iterations,\n    const INT count,\n    UCHAR *output)\n{\n    UCHAR digest[MAX_SSID_LENGTH+4];  \n    UCHAR digest1[SHA1_DIGEST_LEN];\n    INT i, j;\n    if (ssidLength > MAX_SSID_LENGTH) {\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n    memset(digest, 0, sizeof digest);\n    memset(digest1, 0, sizeof digest1);\n    memcpy(digest, ssid, ssidLength);\n    digest[ssidLength] = (UCHAR)((count>>24) & 0xff);\n    digest[ssidLength+1] = (UCHAR)((count>>16) & 0xff);\n    digest[ssidLength+2] = (UCHAR)((count>>8) & 0xff);\n    digest[ssidLength+3] = (UCHAR)(count & 0xff);\n    sha1_hmac(ppBytes, ppLength, digest, (guint32) ssidLength+4, digest1);\n    memcpy(output, digest1, SHA1_DIGEST_LEN);\n    for (i = 1; i < iterations; i++) {\n        sha1_hmac(ppBytes, ppLength, digest1, SHA1_DIGEST_LEN, digest);\n        memcpy(digest1, digest, SHA1_DIGEST_LEN);\n        for (j = 0; j < SHA1_DIGEST_LEN; j++) {\n            output[j] ^= digest[j];\n        }\n    }\n    return AIRPDCAP_RET_SUCCESS;\n}", "target": 0}
{"code": "bgp_auth_parse (struct peer *peer, u_char *pnt, size_t length)\n{\n  bgp_notify_send (peer, \n\t\t   BGP_NOTIFY_OPEN_ERR, \n\t\t   BGP_NOTIFY_OPEN_AUTH_FAILURE); \n  return -1;\n}", "target": 1}
{"code": "static void ip6_dst_ifdown(struct dst_entry *dst, struct net_device *dev,\n\t\t\t   int how)\n{\n\tstruct rt6_info *rt = (struct rt6_info *)dst;\n\tstruct inet6_dev *idev = rt->rt6i_idev;\n\tstruct net_device *loopback_dev =\n\t\tdev_net(dev)->loopback_dev;\n\tif (dev != loopback_dev) {\n\t\tif (idev && idev->dev == dev) {\n\t\t\tstruct inet6_dev *loopback_idev =\n\t\t\t\tin6_dev_get(loopback_dev);\n\t\t\tif (loopback_idev) {\n\t\t\t\trt->rt6i_idev = loopback_idev;\n\t\t\t\tin6_dev_put(idev);\n\t\t\t}\n\t\t}\n\t\tif (rt->n && rt->n->dev == dev) {\n\t\t\trt->n->dev = loopback_dev;\n\t\t\tdev_hold(loopback_dev);\n\t\t\tdev_put(dev);\n\t\t}\n\t}\n}", "target": 0}
{"code": "static void umd_cleanup(struct subprocess_info *info)\n{\n\tstruct umd_info *umd_info = info->data;\n\tif (info->retval) {\n\t\tfput(umd_info->pipe_to_umh);\n\t\tfput(umd_info->pipe_from_umh);\n\t\tput_pid(umd_info->tgid);\n\t\tumd_info->tgid = NULL;\n\t}\n}", "target": 1}
{"code": "alloc_handle( void *ctx_arg, int is_server )\n{\n\ttls_ctx\t*ctx;\n\ttls_session\t*ssl;\n\tif ( ctx_arg ) {\n\t\tctx = ctx_arg;\n\t} else {\n\t\tstruct ldapoptions *lo = LDAP_INT_GLOBAL_OPT();   \n\t\tif ( ldap_pvt_tls_init_def_ctx( is_server ) < 0 ) return NULL;\n\t\tctx = lo->ldo_tls_ctx;\n\t}\n\tssl = tls_imp->ti_session_new( ctx, is_server );\n\tif ( ssl == NULL ) {\n\t\tDebug( LDAP_DEBUG_ANY,\"TLS: can't create ssl handle.\\n\",0,0,0);\n\t\treturn NULL;\n\t}\n\treturn ssl;\n}", "target": 0}
{"code": "static void wait_for_child_to_die(void *ctx)\n{\n\tREQUEST *request = ctx;\n\trad_assert(request->magic == REQUEST_MAGIC);\n\tif ((request->child_state == REQUEST_QUEUED) ||\n\t    ((request->child_state == REQUEST_RUNNING) &&\n\t     (pthread_equal(request->child_pid, NO_SUCH_CHILD_PID) == 0))) {\n\t\tif (request->delay < (USEC * 60 * 5)) {\n\t\t\trequest->delay += (request->delay >> 1);\n\t\t\tradlog(L_INFO, \"WARNING: Child is hung for request %u in component %s module %s.\",\n\t\t\t       request->number, request->component, request->module);\n\t\t} else {\n\t\t\tRDEBUG2(\"Child is still stuck for request %u\",\n\t\t\t\trequest->number);\n\t\t}\n\t\ttv_add(&request->when, request->delay);\n\t\tINSERT_EVENT(wait_for_child_to_die, request);\n\t\treturn;\n\t}\n\tRDEBUG2(\"Child is finally responsive for request %u\", request->number);\n\tremove_from_request_hash(request);\n#ifdef WITH_PROXY\n\tif (request->proxy) {\n\t\twait_for_proxy_id_to_expire(request);\n\t\treturn;\n\t}\n#endif\n\tev_request_free(&request);\n}", "target": 1}
{"code": "xsltProcessingInstructionComp(xsltStylesheetPtr style, xmlNodePtr inst) {\n#ifdef XSLT_REFACTORED\n    xsltStyleItemPIPtr comp;\n#else\n    xsltStylePreCompPtr comp;\n#endif\n    if ((style == NULL) || (inst == NULL) || (inst->type != XML_ELEMENT_NODE))\n\treturn;\n#ifdef XSLT_REFACTORED\n    comp = (xsltStyleItemPIPtr) xsltNewStylePreComp(style, XSLT_FUNC_PI);\n#else\n    comp = xsltNewStylePreComp(style, XSLT_FUNC_PI);\n#endif\n    if (comp == NULL)\n\treturn;\n    inst->psvi = comp;\n    comp->inst = inst;\n    comp->name = xsltEvalStaticAttrValueTemplate(style, inst,\n\t\t\t\t (const xmlChar *)\"name\",\n\t\t\t\t XSLT_NAMESPACE, &comp->has_name);\n}", "target": 0}
{"code": "bool task_blocks_signal(pid_t pid, int signal)\n{\n\tint ret;\n\tchar status[__PROC_STATUS_LEN];\n\tFILE *f;\n\tuint64_t sigblk = 0, one = 1;\n\tsize_t n = 0;\n\tbool bret = false;\n\tchar *line = NULL;\n\tret = snprintf(status, __PROC_STATUS_LEN, \"/proc/%d/status\", pid);\n\tif (ret < 0 || ret >= __PROC_STATUS_LEN)\n\t\treturn bret;\n\tf = fopen(status, \"r\");\n\tif (!f)\n\t\treturn bret;\n\twhile (getline(&line, &n, f) != -1) {\n\t\tchar *numstr;\n\t\tif (strncmp(line, \"SigBlk:\", 7))\n\t\t\tcontinue;\n\t\tnumstr = lxc_trim_whitespace_in_place(line + 7);\n\t\tret = lxc_safe_uint64(numstr, &sigblk, 16);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tif (sigblk & (one << (signal - 1)))\n\t\tbret = true;\nout:\n\tfree(line);\n\tfclose(f);\n\treturn bret;\n}", "target": 0}
{"code": "dump_threads(void)\n{\n\tFILE *fp;\n\tchar time_buf[26];\n\telement e;\n\tvrrp_t *vrrp;\n\tchar *file_name;\n\tfile_name = make_file_name(\"/tmp/thread_dump.dat\",\n\t\t\t\t\t\"vrrp\",\n#if HAVE_DECL_CLONE_NEWNET\n\t\t\t\t\tglobal_data->network_namespace,\n#else\n\t\t\t\t\tNULL,\n#endif\n\t\t\t\t\tglobal_data->instance_name);\n\tfp = fopen(file_name, \"a\");\n\tFREE(file_name);\n\tset_time_now();\n\tctime_r(&time_now.tv_sec, time_buf);\n\tfprintf(fp, \"\\n%.19s.%6.6ld: Thread dump\\n\", time_buf, time_now.tv_usec);\n\tdump_thread_data(master, fp);\n\tfprintf(fp, \"alloc = %lu\\n\", master->alloc);\n\tfprintf(fp, \"\\n\");\n\tLIST_FOREACH(vrrp_data->vrrp, vrrp, e) {\n\t\tctime_r(&vrrp->sands.tv_sec, time_buf);\n\t\tfprintf(fp, \"VRRP instance %s, sands %.19s.%6.6lu, status %s\\n\", vrrp->iname, time_buf, vrrp->sands.tv_usec,\n\t\t\t\tvrrp->state == VRRP_STATE_INIT ? \"INIT\" :\n\t\t\t\tvrrp->state == VRRP_STATE_BACK ? \"BACKUP\" :\n\t\t\t\tvrrp->state == VRRP_STATE_MAST ? \"MASTER\" :\n\t\t\t\tvrrp->state == VRRP_STATE_FAULT ? \"FAULT\" :\n\t\t\t\tvrrp->state == VRRP_STATE_STOP ? \"STOP\" :\n\t\t\t\tvrrp->state == VRRP_DISPATCHER ? \"DISPATCHER\" : \"unknown\");\n\t}\n\tfclose(fp);\n}", "target": 1}
{"code": "void ext4_xattr_destroy_cache(struct mb_cache *cache)\n{\n\tif (cache)\n\t\tmb_cache_destroy(cache);\n}", "target": 1}
{"code": "void OverlayWindowViews::OnGestureEvent(ui::GestureEvent* event) {\n  if (event->type() != ui::ET_GESTURE_TAP)\n    return;\n  hide_controls_timer_.Reset();\n  if (!GetControlsScrimLayer()->visible()) {\n    UpdateControlsVisibility(true);\n    return;\n  }\n  if (GetCloseControlsBounds().Contains(event->location())) {\n    controller_->Close(true ,\n                       true );\n    event->SetHandled();\n  } else if (GetPlayPauseControlsBounds().Contains(event->location())) {\n     TogglePlayPause();\n     event->SetHandled();\n   }\n }", "target": 0}
{"code": "void InterstitialPage::InterstitialPageRVHViewDelegate::CreateNewWindow(\n    int route_id) {\n  NOTREACHED() << \"InterstitialPage does not support showing popups yet.\";\n}", "target": 0}
{"code": "static int ext4_iomap_end(struct inode *inode, loff_t offset, loff_t length,\n\t\t\t  ssize_t written, unsigned flags, struct iomap *iomap)\n{\n\tint ret = 0;\n\thandle_t *handle;\n\tint blkbits = inode->i_blkbits;\n\tbool truncate = false;\n\tif (!(flags & IOMAP_WRITE) || (flags & IOMAP_FAULT))\n\t\treturn 0;\n\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 2);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto orphan_del;\n\t}\n\tif (ext4_update_inode_size(inode, offset + written))\n\t\text4_mark_inode_dirty(handle, inode);\n\tif (iomap->offset + iomap->length > \n\t    ALIGN(inode->i_size, 1 << blkbits)) {\n\t\text4_lblk_t written_blk, end_blk;\n\t\twritten_blk = (offset + written) >> blkbits;\n\t\tend_blk = (offset + length) >> blkbits;\n\t\tif (written_blk < end_blk && ext4_can_truncate(inode))\n\t\t\ttruncate = true;\n\t}\n\tif (!truncate && inode->i_nlink &&\n\t    !list_empty(&EXT4_I(inode)->i_orphan))\n\t\text4_orphan_del(handle, inode);\n\text4_journal_stop(handle);\n\tif (truncate) {\n\t\text4_truncate_failed_write(inode);\norphan_del:\n\t\tif (inode->i_nlink)\n\t\t\text4_orphan_del(NULL, inode);\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "static int nf_tables_set_notify(const struct nft_ctx *ctx,\n\t\t\t\tconst struct nft_set *set,\n\t\t\t\tint event, gfp_t gfp_flags)\n{\n\tstruct sk_buff *skb;\n\tu32 portid = ctx->portid;\n\tint err;\n\tif (!ctx->report &&\n\t    !nfnetlink_has_listeners(ctx->net, NFNLGRP_NFTABLES))\n\t\treturn 0;\n\terr = -ENOBUFS;\n\tskb = nlmsg_new(NLMSG_GOODSIZE, gfp_flags);\n\tif (skb == NULL)\n\t\tgoto err;\n\terr = nf_tables_fill_set(skb, ctx, set, event, 0);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto err;\n\t}\n\terr = nfnetlink_send(skb, ctx->net, portid, NFNLGRP_NFTABLES,\n\t\t\t     ctx->report, gfp_flags);\nerr:\n\tif (err < 0)\n\t\tnfnetlink_set_err(ctx->net, portid, NFNLGRP_NFTABLES, err);\n\treturn err;\n}", "target": 0}
{"code": "static int __init ip6_tunnel_init(void)\n{\n\tint  err;\n\tif (xfrm6_tunnel_register(&ip4ip6_handler, AF_INET)) {\n\t\tprintk(KERN_ERR \"ip6_tunnel init: can't register ip4ip6\\n\");\n\t\terr = -EAGAIN;\n\t\tgoto out;\n\t}\n\tif (xfrm6_tunnel_register(&ip6ip6_handler, AF_INET6)) {\n\t\tprintk(KERN_ERR \"ip6_tunnel init: can't register ip6ip6\\n\");\n\t\terr = -EAGAIN;\n\t\tgoto unreg_ip4ip6;\n\t}\n\terr = register_pernet_device(&ip6_tnl_net_ops);\n\tif (err < 0)\n\t\tgoto err_pernet;\n\treturn 0;\nerr_pernet:\n\txfrm6_tunnel_deregister(&ip6ip6_handler, AF_INET6);\nunreg_ip4ip6:\n\txfrm6_tunnel_deregister(&ip4ip6_handler, AF_INET);\nout:\n\treturn err;\n}", "target": 1}
{"code": "void ttm_unmap_and_unpopulate_pages(struct device *dev, struct ttm_dma_tt *tt)\n{\n\tunsigned i, j;\n\tfor (i = 0; i < tt->ttm.num_pages;) {\n\t\tstruct page *p = tt->ttm.pages[i];\n\t\tsize_t num_pages = 1;\n\t\tif (!tt->dma_address[i] || !tt->ttm.pages[i]) {\n\t\t\t++i;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j = i + 1; j < tt->ttm.num_pages; ++j) {\n\t\t\tif (++p != tt->ttm.pages[j])\n\t\t\t\tbreak;\n\t\t\t++num_pages;\n\t\t}\n\t\tdma_unmap_page(dev, tt->dma_address[i], num_pages * PAGE_SIZE,\n\t\t\t       DMA_BIDIRECTIONAL);\n\t\ti += num_pages;\n\t}\n\tttm_pool_unpopulate(&tt->ttm);\n}", "target": 0}
{"code": "static void reset_buffer_flags(struct n_tty_data *ldata)\n{\n\tldata->read_head = ldata->canon_head = ldata->read_tail = 0;\n\tldata->echo_head = ldata->echo_tail = ldata->echo_commit = 0;\n\tldata->echo_mark = 0;\n\tldata->line_start = 0;\n\tldata->erasing = 0;\n\tbitmap_zero(ldata->read_flags, N_TTY_BUF_SIZE);\n\tldata->push = 0;\n}", "target": 0}
{"code": "int git_treebuilder_insert(\n\tconst git_tree_entry **entry_out,\n\tgit_treebuilder *bld,\n\tconst char *filename,\n\tconst git_oid *id,\n\tgit_filemode_t filemode)\n{\n\tgit_tree_entry *entry;\n\tsize_t pos;\n\tassert(bld && id && filename);\n\tif (!valid_filemode(filemode))\n\t\treturn tree_error(\"Failed to insert entry. Invalid filemode for file\", filename);\n\tif (!valid_entry_name(filename))\n\t\treturn tree_error(\"Failed to insert entry. Invalid name for a tree entry\", filename);\n\tif (!tree_key_search(&pos, &bld->entries, filename, strlen(filename))) {\n\t\tentry = git_vector_get(&bld->entries, pos);\n\t\tif (entry->removed) {\n\t\t\tentry->removed = 0;\n\t\t\tbld->entrycount++;\n\t\t}\n\t\tentry->attr = filemode;\n\t\tgit_oid_cpy(&entry->oid, id);\n\t} else {\n\t\tentry = alloc_entry(filename);\n\t\tGITERR_CHECK_ALLOC(entry);\n\t\tentry->attr = filemode;\n\t\tgit_oid_cpy(&entry->oid, id);\n\t\tif (git_vector_insert_sorted(&bld->entries, entry, NULL) < 0) {\n\t\t\tgit__free(entry);\n\t\t\treturn -1;\n\t\t}\n\t\tbld->entrycount++;\n\t}\n\tif (entry_out)\n\t\t*entry_out = entry;\n\treturn 0;\n}", "target": 0}
{"code": "static int su3000_frontend_attach(struct dvb_usb_adapter *d)\n{\n\tu8 obuf[3] = { 0xe, 0x80, 0 };\n\tu8 ibuf[] = { 0 };\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x02;\n\tobuf[2] = 1;\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tmsleep(300);\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x83;\n\tobuf[2] = 0;\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x83;\n\tobuf[2] = 1;\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tobuf[0] = 0x51;\n\tif (dvb_usb_generic_rw(d->dev, obuf, 1, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x51 transfer failed.\");\n\td->fe_adap[0].fe = dvb_attach(ds3000_attach, &su3000_ds3000_config,\n\t\t\t\t\t&d->dev->i2c_adap);\n\tif (d->fe_adap[0].fe == NULL)\n\t\treturn -EIO;\n\tif (dvb_attach(ts2020_attach, d->fe_adap[0].fe,\n\t\t\t\t&dw2104_ts2020_config,\n\t\t\t\t&d->dev->i2c_adap)) {\n\t\tinfo(\"Attached DS3000/TS2020!\");\n\t\treturn 0;\n\t}\n\tinfo(\"Failed to attach DS3000/TS2020!\");\n\treturn -EIO;\n}", "target": 1}
{"code": "static void whiteheat_break_ctl(struct tty_struct *tty, int break_state)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tfirm_set_break(port, break_state);\n}", "target": 0}
{"code": "spnego_gss_inquire_cred(\n\t\t\tOM_uint32 *minor_status,\n\t\t\tgss_cred_id_t cred_handle,\n\t\t\tgss_name_t *name,\n\t\t\tOM_uint32 *lifetime,\n\t\t\tint *cred_usage,\n\t\t\tgss_OID_set *mechanisms)\n{\n\tOM_uint32 status;\n\tspnego_gss_cred_id_t spcred = NULL;\n\tgss_cred_id_t creds = GSS_C_NO_CREDENTIAL;\n\tOM_uint32 tmp_minor_status;\n\tOM_uint32 initiator_lifetime, acceptor_lifetime;\n\tdsyslog(\"Entering inquire_cred\\n\");\n\tspcred = (spnego_gss_cred_id_t)cred_handle;\n\tif (spcred == NULL) {\n\t\tstatus = get_available_mechs(minor_status,\n\t\t\tGSS_C_NO_NAME,\n\t\t\tGSS_C_BOTH,\n\t\t\tGSS_C_NO_CRED_STORE,\n\t\t\t&creds,\n\t\t\tmechanisms);\n\t\tif (status != GSS_S_COMPLETE) {\n\t\t\tdsyslog(\"Leaving inquire_cred\\n\");\n\t\t\treturn (status);\n\t\t}\n\t\tif ((*mechanisms)->count == 0) {\n\t\t\tgss_release_cred(&tmp_minor_status, &creds);\n\t\t\tgss_release_oid_set(&tmp_minor_status, mechanisms);\n\t\t\tdsyslog(\"Leaving inquire_cred\\n\");\n\t\t\treturn (GSS_S_DEFECTIVE_CREDENTIAL);\n\t\t}\n\t\tassert((*mechanisms)->elements != NULL);\n\t\tstatus = gss_inquire_cred_by_mech(minor_status,\n\t\t\tcreds,\n\t\t\t&(*mechanisms)->elements[0],\n\t\t\tname,\n\t\t\t&initiator_lifetime,\n\t\t\t&acceptor_lifetime,\n\t\t\tcred_usage);\n\t\tif (status != GSS_S_COMPLETE) {\n\t\t\tgss_release_cred(&tmp_minor_status, &creds);\n\t\t\tdsyslog(\"Leaving inquire_cred\\n\");\n\t\t\treturn (status);\n\t\t}\n\t\tif (lifetime != NULL)\n\t\t\t*lifetime = (*cred_usage == GSS_C_ACCEPT) ?\n\t\t\t\tacceptor_lifetime : initiator_lifetime;\n\t\tgss_release_cred(&tmp_minor_status, &creds);\n\t} else {\n\t\tstatus = gss_inquire_cred(minor_status, spcred->mcred,\n\t\t\t\t\t  name, lifetime,\n\t\t\t\t\t  cred_usage, mechanisms);\n\t}\n\tdsyslog(\"Leaving inquire_cred\\n\");\n\treturn (status);\n}", "target": 0}
{"code": "spnego_gss_set_sec_context_option(\n\t\tOM_uint32 *minor_status,\n\t\tgss_ctx_id_t *context_handle,\n\t\tconst gss_OID desired_object,\n\t\tconst gss_buffer_t value)\n{\n\tOM_uint32 ret;\n\tret = gss_set_sec_context_option(minor_status,\n\t\t\t    context_handle,\n\t\t\t    desired_object,\n\t\t\t    value);\n\treturn (ret);\n}", "target": 1}
{"code": "int nfc_dep_link_down(struct nfc_dev *dev)\n{\n\tint rc = 0;\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\tif (!dev->ops->dep_link_down)\n\t\treturn -EOPNOTSUPP;\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->dep_link_up == false) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\trc = dev->ops->dep_link_down(dev);\n\tif (!rc) {\n\t\tdev->dep_link_up = false;\n\t\tdev->active_target = NULL;\n\t\tdev->rf_mode = NFC_RF_NONE;\n\t\tnfc_llcp_mac_is_down(dev);\n\t\tnfc_genl_dep_link_down_event(dev);\n\t}\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "static int f2fs_set_data_page_dirty(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode = mapping->host;\n\ttrace_f2fs_set_page_dirty(page, DATA);\n\tif (!PageUptodate(page))\n\t\tSetPageUptodate(page);\n\tif (f2fs_is_atomic_file(inode) && !f2fs_is_commit_atomic_write(inode)) {\n\t\tif (!IS_ATOMIC_WRITTEN_PAGE(page)) {\n\t\t\tf2fs_register_inmem_page(inode, page);\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (!PageDirty(page)) {\n\t\t__set_page_dirty_nobuffers(page);\n\t\tf2fs_update_dirty_page(inode, page);\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static void __slab_free(struct kmem_cache *s, struct page *page,\n\t\t\t\tvoid *x, void *addr, unsigned int offset)\n{\n\tvoid *prior;\n\tvoid **object = (void *)x;\n\tstruct kmem_cache_cpu *c;\n\tc = get_cpu_slab(s, raw_smp_processor_id());\n\tstat(c, FREE_SLOWPATH);\n\tslab_lock(page);\n\tif (unlikely(SlabDebug(page)))\n\t\tgoto debug;\nchecks_ok:\n\tprior = object[offset] = page->freelist;\n\tpage->freelist = object;\n\tpage->inuse--;\n\tif (unlikely(SlabFrozen(page))) {\n\t\tstat(c, FREE_FROZEN);\n\t\tgoto out_unlock;\n\t}\n\tif (unlikely(!page->inuse))\n\t\tgoto slab_empty;\n\tif (unlikely(!prior)) {\n\t\tadd_partial(get_node(s, page_to_nid(page)), page, 1);\n\t\tstat(c, FREE_ADD_PARTIAL);\n\t}\nout_unlock:\n\tslab_unlock(page);\n\treturn;\nslab_empty:\n\tif (prior) {\n\t\tremove_partial(s, page);\n\t\tstat(c, FREE_REMOVE_PARTIAL);\n\t}\n\tslab_unlock(page);\n\tstat(c, FREE_SLAB);\n\tdiscard_slab(s, page);\n\treturn;\ndebug:\n\tif (!free_debug_processing(s, page, x, addr))\n\t\tgoto out_unlock;\n\tgoto checks_ok;\n}", "target": 0}
{"code": "GF_Err gf_isom_get_handler_name(GF_ISOFile *the_file, u32 trackNumber, const char **outName)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !outName) return GF_BAD_PARAM;\n\t*outName = trak->Media->handler->nameUTF8;\n\treturn GF_OK;\n}", "target": 0}
{"code": "test_compressed_stream_overflow (xd3_stream *stream, int ignore)\n{\n  int ret;\n  int i;\n  uint8_t *buf;\n  if ((buf = (uint8_t*) malloc (TWO_MEGS_AND_DELTA)) == NULL) { return ENOMEM; }\n  memset (buf, 0, TWO_MEGS_AND_DELTA);\n  for (i = 0; i < (2 << 20); i += 256) \n    {\n      int j;\n      int off = mt_random(& static_mtrand) % 10;\n      for (j = 0; j < 256; j++) \n\t{\n\t  buf[i + j] = j + off;\n\t}\n    }\n  if (SIZEOF_XOFF_T == 4)\n    {\n      ret = test_streaming (stream, buf, buf + (1 << 20), buf + (2 << 20), (1 << 12) + 1);\n      if (ret == XD3_INVALID_INPUT && MSG_IS (\"decoder file offset overflow\"))\n\t{\n\t  ret = 0;\n\t}\n      else\n\t{\n          XPR(NT XD3_LIB_ERRMSG (stream, ret));\n\t  stream->msg = \"expected overflow condition\";\n\t  ret = XD3_INTERNAL;\n\t  goto fail;\n\t}\n    }\n  if ((ret = test_streaming (stream, \n\t\t\t     buf, \n\t\t\t     buf + (1 << 20), \n\t\t\t     buf + (2 << 20), \n\t\t\t     1 << 12))) \n    {\n      goto fail;\n    }\n fail:\n  free (buf);\n  return ret;\n}", "target": 1}
{"code": "static int hashtable_do_rehash(hashtable_t *hashtable)\n{\n    list_t *list, *next;\n    pair_t *pair;\n    size_t i, index, new_size;\n    jsonp_free(hashtable->buckets);\n    hashtable->num_buckets++;\n    new_size = num_buckets(hashtable);\n    hashtable->buckets = jsonp_malloc(new_size * sizeof(bucket_t));\n    if(!hashtable->buckets)\n        return -1;\n    for(i = 0; i < num_buckets(hashtable); i++)\n    {\n        hashtable->buckets[i].first = hashtable->buckets[i].last =\n            &hashtable->list;\n    }\n    list = hashtable->list.next;\n    list_init(&hashtable->list);\n    for(; list != &hashtable->list; list = next) {\n        next = list->next;\n        pair = list_to_pair(list);\n        index = pair->hash % new_size;\n        insert_to_bucket(hashtable, &hashtable->buckets[index], &pair->list);\n    }\n    return 0;\n}", "target": 1}
{"code": "int ossl_dsa_check_priv_key(const DSA *dsa, const BIGNUM *priv_key, int *ret)\n{\n    *ret = 0;\n    return (dsa->params.q != NULL\n            && ossl_ffc_validate_private_key(dsa->params.q, priv_key, ret));\n}", "target": 1}
{"code": "  explicit BoostedTreesMakeStatsSummaryOp(OpKernelConstruction* const context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"max_splits\", &max_splits_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_buckets\", &num_buckets_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_features\", &num_features_));\n  }", "target": 0}
{"code": "void Browser::NavigationStateChanged(WebContents* source,\n                                     content::InvalidateTypes changed_flags) {\n  tracked_objects::ScopedTracker tracking_profile1(\n      FROM_HERE_WITH_EXPLICIT_FUNCTION(\n          \"466285 Browser::NavigationStateChanged::ScheduleUIUpdate\"));\n  if (changed_flags)\n    ScheduleUIUpdate(source, changed_flags);\n  tracked_objects::ScopedTracker tracking_profile2(\n      FROM_HERE_WITH_EXPLICIT_FUNCTION(\n          \"466285 Browser::NavigationStateChanged::TabStateChanged\"));\n  if (changed_flags & (content::INVALIDATE_TYPE_URL |\n                       content::INVALIDATE_TYPE_LOAD |\n                       content::INVALIDATE_TYPE_TAB))\n    command_controller_->TabStateChanged();\n  if (hosted_app_controller_)\n    hosted_app_controller_->UpdateLocationBarVisibility(true);\n}", "target": 0}
{"code": "static ssize_t aio_setup_single_vector(struct kiocb *kiocb,\n\t\t\t\t       int rw, char __user *buf,\n\t\t\t\t       unsigned long *nr_segs,\n\t\t\t\t       size_t len,\n\t\t\t\t       struct iovec *iovec)\n{\n\tif (unlikely(!access_ok(!rw, buf, len)))\n\t\treturn -EFAULT;\n\tiovec->iov_base = buf;\n\tiovec->iov_len = len;\n\t*nr_segs = 1;\n\treturn 0;\n}", "target": 1}
{"code": "void uwbd_start(struct uwb_rc *rc)\n{\n\trc->uwbd.task = kthread_run(uwbd, rc, \"uwbd\");\n\tif (rc->uwbd.task == NULL)\n\t\tprintk(KERN_ERR \"UWB: Cannot start management daemon; \"\n\t\t       \"UWB won't work\\n\");\n\telse\n\t\trc->uwbd.pid = rc->uwbd.task->pid;\n}", "target": 1}
{"code": "int __nla_validate(const struct nlattr *head, int len, int maxtype,\n\t\t   const struct nla_policy *policy, unsigned int validate,\n\t\t   struct netlink_ext_ack *extack)\n{\n\treturn __nla_validate_parse(head, len, maxtype, policy, validate,\n\t\t\t\t    extack, NULL);\n}", "target": 1}
{"code": "Array HHVM_FUNCTION(mcrypt_list_modes,\n                    const String& lib_dir ) {\n  String dir = lib_dir.empty() ? String(MCG(modes_dir)) : lib_dir;\n  int count = 0;\n  char **modules = mcrypt_list_modes((char*)dir.data(), &count);\n  if (count == 0) {\n    raise_warning(\"No modes found in module dir\");\n  }\n  Array ret = Array::Create();\n  for (int i = 0; i < count; i++) {\n    ret.append(String(modules[i], CopyString));\n  }\n  mcrypt_free_p(modules, count);\n  return ret;\n}", "target": 0}
{"code": "static void emit(JF, int value)\n{\n\temitraw(J, F, value);\n}", "target": 0}
{"code": "blkxor(void * dest, void * src, size_t len)\n{\n  __m128i * D = (__m128i *) dest;\n  __m128i * S = (__m128i *) src;\n  size_t L = len / 16;\n  size_t i;\n  for (i = 0; i < L; i++)\n    D[i] = _mm_xor_si128(D[i], S[i]);\n}", "target": 1}
{"code": "bool timerqueue_add(struct timerqueue_head *head, struct timerqueue_node *node)\n{\n\tstruct rb_node **p = &head->head.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct timerqueue_node  *ptr;\n\tWARN_ON_ONCE(!RB_EMPTY_NODE(&node->node));\n\twhile (*p) {\n\t\tparent = *p;\n\t\tptr = rb_entry(parent, struct timerqueue_node, node);\n\t\tif (node->expires < ptr->expires)\n\t\t\tp = &(*p)->rb_left;\n\t\telse\n\t\t\tp = &(*p)->rb_right;\n\t}\n\trb_link_node(&node->node, parent, p);\n\trb_insert_color(&node->node, &head->head);\n\tif (!head->next || node->expires < head->next->expires) {\n\t\thead->next = node;\n\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "static bool tr_valid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment tr;\n\tvmx_get_segment(vcpu, &tr, VCPU_SREG_TR);\n\tif (tr.unusable)\n\t\treturn false;\n\tif (tr.selector & SELECTOR_TI_MASK)\t\n\t\treturn false;\n\tif (tr.type != 3 && tr.type != 11) \n\t\treturn false;\n\tif (!tr.present)\n\t\treturn false;\n\treturn true;\n}", "target": 0}
{"code": "static int vidioc_try_fmt_out(struct file *file, void *priv, struct v4l2_format *fmt)\n{\n\tstruct v4l2_loopback_device *dev;\n\tMARK();\n\tdev = v4l2loopback_getdevice(file);\n\tif (dev->ready_for_capture) {\n\t\tfmt->fmt.pix = dev->pix_format;\n\t} else {\n\t\t__u32 w = fmt->fmt.pix.width;\n\t\t__u32 h = fmt->fmt.pix.height;\n\t\t__u32 pixfmt = fmt->fmt.pix.pixelformat;\n\t\tconst struct v4l2l_format *format = format_by_fourcc(pixfmt);\n\t\tif (w > max_width)\n\t\t\tw = max_width;\n\t\tif (h > max_height)\n\t\t\th = max_height;\n\t\tdprintk(\"trying image %dx%d\\n\", w, h);\n\t\tif (w < 1)\n\t\t\tw = V4L2LOOPBACK_SIZE_DEFAULT_WIDTH;\n\t\tif (h < 1)\n\t\t\th = V4L2LOOPBACK_SIZE_DEFAULT_HEIGHT;\n\t\tif (NULL == format)\n\t\t\tformat = &formats[0];\n\t\tpix_format_set_size(&fmt->fmt.pix, format, w, h);\n\t\tfmt->fmt.pix.pixelformat = format->fourcc;\n\t\tfmt->fmt.pix.colorspace = V4L2_COLORSPACE_SRGB;\n\t\tif (V4L2_FIELD_ANY == fmt->fmt.pix.field)\n\t\t\tfmt->fmt.pix.field = V4L2_FIELD_NONE;\n\t\tdev->pix_format = fmt->fmt.pix;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "METHODDEF(JDIMENSION)\nget_32bit_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  bmp_source_ptr source = (bmp_source_ptr)sinfo;\n  JSAMPARRAY image_ptr;\n  register JSAMPROW inptr, outptr;\n  register JDIMENSION col;\n  if (source->use_inversion_array) {\n    source->source_row--;\n    image_ptr = (*cinfo->mem->access_virt_sarray)\n      ((j_common_ptr)cinfo, source->whole_image,\n       source->source_row, (JDIMENSION)1, FALSE);\n    inptr = image_ptr[0];\n  } else {\n    if (!ReadOK(source->pub.input_file, source->iobuffer, source->row_width))\n      ERREXIT(cinfo, JERR_INPUT_EOF);\n    inptr = source->iobuffer;\n  }\n  outptr = source->pub.buffer[0];\n  if (cinfo->in_color_space == JCS_EXT_BGRX ||\n      cinfo->in_color_space == JCS_EXT_BGRA) {\n    MEMCOPY(outptr, inptr, source->row_width);\n  } else if (cinfo->in_color_space == JCS_CMYK) {\n    for (col = cinfo->image_width; col > 0; col--) {\n      JSAMPLE b = *inptr++, g = *inptr++, r = *inptr++;\n      rgb_to_cmyk(r, g, b, outptr, outptr + 1, outptr + 2, outptr + 3);\n      inptr++;                          \n      outptr += 4;\n    }\n  } else {\n    register int rindex = rgb_red[cinfo->in_color_space];\n    register int gindex = rgb_green[cinfo->in_color_space];\n    register int bindex = rgb_blue[cinfo->in_color_space];\n    register int aindex = alpha_index[cinfo->in_color_space];\n    register int ps = rgb_pixelsize[cinfo->in_color_space];\n    if (aindex >= 0) {\n      for (col = cinfo->image_width; col > 0; col--) {\n        outptr[bindex] = *inptr++;      \n        outptr[gindex] = *inptr++;\n        outptr[rindex] = *inptr++;\n        outptr[aindex] = *inptr++;\n        outptr += ps;\n      }\n    } else {\n      for (col = cinfo->image_width; col > 0; col--) {\n        outptr[bindex] = *inptr++;      \n        outptr[gindex] = *inptr++;\n        outptr[rindex] = *inptr++;\n        inptr++;                        \n        outptr += ps;\n      }\n    }\n  }\n  return 1;\n}", "target": 0}
{"code": "void AddRegisterComDllWorkItems(const FilePath& dll_folder,\n                                const std::vector<FilePath>& dll_list,\n                                bool system_level,\n                                bool do_register,\n                                bool ignore_failures,\n                                WorkItemList* work_item_list) {\n  DCHECK(work_item_list);\n  if (dll_list.empty()) {\n    VLOG(1) << \"No COM DLLs to register\";\n  } else {\n    std::vector<FilePath>::const_iterator dll_iter(dll_list.begin());\n    for (; dll_iter != dll_list.end(); ++dll_iter) {\n      FilePath dll_path = dll_folder.Append(*dll_iter);\n      WorkItem* work_item = work_item_list->AddSelfRegWorkItem(\n          dll_path.value(), do_register, !system_level);\n      DCHECK(work_item);\n      work_item->set_ignore_failure(ignore_failures);\n    }\n  }\n}", "target": 0}
{"code": "static u8 vgacon_build_attr(struct vc_data *c, u8 color,\n\t\t\t    enum vc_intensity intensity,\n\t\t\t    bool blink, bool underline, bool reverse,\n\t\t\t    bool italic)\n{\n\tu8 attr = color;\n\tif (vga_can_do_color) {\n\t\tif (italic)\n\t\t\tattr = (attr & 0xF0) | c->vc_itcolor;\n\t\telse if (underline)\n\t\t\tattr = (attr & 0xf0) | c->vc_ulcolor;\n\t\telse if (intensity == VCI_HALF_BRIGHT)\n\t\t\tattr = (attr & 0xf0) | c->vc_halfcolor;\n\t}\n\tif (reverse)\n\t\tattr =\n\t\t    ((attr) & 0x88) | ((((attr) >> 4) | ((attr) << 4)) &\n\t\t\t\t       0x77);\n\tif (blink)\n\t\tattr ^= 0x80;\n\tif (intensity == VCI_BOLD)\n\t\tattr ^= 0x08;\n\tif (!vga_can_do_color) {\n\t\tif (italic)\n\t\t\tattr = (attr & 0xF8) | 0x02;\n\t\telse if (underline)\n\t\t\tattr = (attr & 0xf8) | 0x01;\n\t\telse if (intensity == VCI_HALF_BRIGHT)\n\t\t\tattr = (attr & 0xf0) | 0x08;\n\t}\n\treturn attr;\n}", "target": 0}
{"code": "static uint_fast32_t jpc_abstorelstepsize(jpc_fix_t absdelta, int scaleexpn)\n{\n\tint p;\n\tuint_fast32_t mant;\n\tuint_fast32_t expn;\n\tint n;\n\tif (absdelta < 0) {\n\t\tabort();\n\t}\n\tp = jpc_fix_firstone(absdelta) - JPC_FIX_FRACBITS;\n\tn = 11 - jpc_fix_firstone(absdelta);\n\tmant = ((n < 0) ? (absdelta >> (-n)) : (absdelta << n)) & 0x7ff;\n\texpn = scaleexpn - p;\n\tif (scaleexpn < p) {\n\t\tabort();\n\t}\n\treturn JPC_QCX_EXPN(expn) | JPC_QCX_MANT(mant);\n}", "target": 1}
{"code": "elg_encrypt (int algo, gcry_mpi_t *resarr,\n             gcry_mpi_t data, gcry_mpi_t *pkey, int flags)\n{\n  gcry_err_code_t err = GPG_ERR_NO_ERROR;\n  ELG_public_key pk;\n  (void)algo;\n  (void)flags;\n  if ((! data) || (! pkey[0]) || (! pkey[1]) || (! pkey[2]))\n    err = GPG_ERR_BAD_MPI;\n  else\n    {\n      pk.p = pkey[0];\n      pk.g = pkey[1];\n      pk.y = pkey[2];\n      resarr[0] = mpi_alloc (mpi_get_nlimbs (pk.p));\n      resarr[1] = mpi_alloc (mpi_get_nlimbs (pk.p));\n      do_encrypt (resarr[0], resarr[1], data, &pk);\n    }\n  return err;\n}", "target": 0}
{"code": "smtp_mailaddr(struct mailaddr *maddr, char *line, int mailfrom, char **args,\n    const char *domain)\n{\n\tchar   *p, *e;\n\tif (line == NULL)\n\t\treturn (0);\n\tif (*line != '<')\n\t\treturn (0);\n\te = strchr(line, '>');\n\tif (e == NULL)\n\t\treturn (0);\n\t*e++ = '\\0';\n\twhile (*e == ' ')\n\t\te++;\n\t*args = e;\n\tif (!text_to_mailaddr(maddr, line + 1))\n\t\treturn (0);\n\tp = strchr(maddr->user, ':');\n\tif (p != NULL) {\n\t\tp++;\n\t\tmemmove(maddr->user, p, strlen(p) + 1);\n\t}\n\tif (!valid_localpart(maddr->user) ||\n\t    !valid_domainpart(maddr->domain)) {\n\t\tif (mailfrom && maddr->user[0] == '\\0' && maddr->domain[0] == '\\0')\n\t\t\treturn (1);\n\t\tif (maddr->user[0] == '\\0')\n\t\t\treturn (0);\n\t\tif (maddr->domain[0] == '\\0') {\n\t\t\t(void)strlcpy(maddr->domain, domain,\n\t\t\t    sizeof(maddr->domain));\n\t\t\treturn (1);\n\t\t}\n\t\treturn (0);\n\t}\n\treturn (1);\n}", "target": 1}
{"code": "static void free_partial(struct kmem_cache *s, struct kmem_cache_node *n)\n{\n\tunsigned long flags;\n\tstruct page *page, *h;\n\tspin_lock_irqsave(&n->list_lock, flags);\n\tlist_for_each_entry_safe(page, h, &n->partial, lru) {\n\t\tif (!page->inuse) {\n\t\t\tlist_del(&page->lru);\n\t\t\tdiscard_slab(s, page);\n\t\t\tn->nr_partial--;\n\t\t} else {\n\t\t\tlist_slab_objects(s, page,\n\t\t\t\t\"Objects remaining on kmem_cache_close()\");\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&n->list_lock, flags);\n}", "target": 0}
{"code": "void kvm_arch_vcpu_uninit(struct kvm_vcpu *vcpu)\n{\n\tint idx;\n\tkvm_pmu_destroy(vcpu);\n\tkfree(vcpu->arch.mce_banks);\n\tkvm_free_lapic(vcpu);\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tkvm_mmu_destroy(vcpu);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\tfree_page((unsigned long)vcpu->arch.pio_data);\n\tif (!irqchip_in_kernel(vcpu->kvm))\n\t\tstatic_key_slow_dec(&kvm_no_apic_vcpu);\n}", "target": 0}
{"code": "eval_lambda(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\tverbose)\t\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    typval_T\tbase = *rettv;\n    int\t\tret;\n    rettv->v_type = VAR_UNKNOWN;\n    if (**arg == '{')\n    {\n\tret = get_lambda_tv(arg, rettv, FALSE, evalarg);\n    }\n    else\n    {\n\t++*arg;\n\tret = eval1(arg, rettv, evalarg);\n\t*arg = skipwhite_and_linebreak(*arg, evalarg);\n\tif (**arg == ')')\n\t{\n\t    ++*arg;\n\t}\n\telse\n\t{\n\t    emsg(_(e_missing_closing_paren));\n\t    ret = FAIL;\n\t}\n    }\n    if (ret != OK)\n\treturn FAIL;\n    else if (**arg != '(')\n    {\n\tif (verbose)\n\t{\n\t    if (*skipwhite(*arg) == '(')\n\t\temsg(_(e_no_white_space_allowed_before_parenthesis));\n\t    else\n\t\tsemsg(_(e_missing_parenthesis_str), \"lambda\");\n\t}\n\tclear_tv(rettv);\n\tret = FAIL;\n    }\n    else\n\tret = call_func_rettv(arg, evalarg, rettv, evaluate, NULL, &base);\n    if (evaluate)\n\tclear_tv(&base);\n    return ret;\n}", "target": 1}
{"code": " void PrintWebViewHelper::OnPrintingDone(bool success) {\n  CHECK_LE(ipc_nesting_level_, 1);\n   notify_browser_of_print_failure_ = false;\n   if (!success)\n     LOG(ERROR) << \"Failure in OnPrintingDone\";\n  DidFinishPrinting(success ? OK : FAIL_PRINT);\n}", "target": 0}
{"code": "RestAuthHandler::RestAuthHandler(application_features::ApplicationServer& server,\n                                 GeneralRequest* request, GeneralResponse* response)\n    : RestVocbaseBaseHandler(server, request, response),\n      _validFor(60 * 60 * 24 * 30) {}", "target": 1}
{"code": "prologProcessor(XML_Parser parser, const char *s, const char *end,\n                const char **nextPtr) {\n  const char *next = s;\n  int tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                  (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_TRUE,\n                  XML_ACCOUNT_DIRECT);\n}", "target": 0}
{"code": "static void floppy_shutdown(struct work_struct *arg)\n{\n\tunsigned long flags;\n\tif (initialized)\n\t\tshow_floppy();\n\tcancel_activity();\n\tflags = claim_dma_lock();\n\tfd_disable_dma();\n\trelease_dma_lock(flags);\n\tif (initialized)\n\t\tDPRINT(\"floppy timeout called\\n\");\n\tFDCS->reset = 1;\n\tif (cont) {\n\t\tcont->done(0);\n\t\tcont->redo();\t\n\t} else {\n\t\tpr_info(\"no cont in shutdown!\\n\");\n\t\tprocess_fd_request();\n\t}\n\tis_alive(__func__, \"\");\n}", "target": 0}
{"code": "void Polygon::Insert( sal_uInt16 nPos, const Point& rPt )\n{\n    ImplMakeUnique();\n    if( nPos >= mpImplPolygon->mnPoints )\n        nPos = mpImplPolygon->mnPoints;\n    mpImplPolygon->ImplSplit( nPos, 1 );\n    mpImplPolygon->mpPointAry[ nPos ] = rPt;\n}", "target": 1}
{"code": "MONGO_EXPORT int bson_iterator_int( const bson_iterator *i ) {\n    switch ( bson_iterator_type( i ) ) {\n    case BSON_INT:\n        return bson_iterator_int_raw( i );\n    case BSON_LONG:\n        return bson_iterator_long_raw( i );\n    case BSON_DOUBLE:\n        return bson_iterator_double_raw( i );\n    default:\n        return 0;\n    }\n}", "target": 1}
{"code": "START_TEST(test_tm_adopt_ispidowner)\n  {\n  fail_unless(TRUE == ispidowner(getpid()));\n  fail_unless(FALSE == ispidowner(1));\n  }", "target": 1}
{"code": "  void ComputeAsyncImpl(OpKernelContext* c, CollectiveExecutor* col_exec,\n                        DoneCallback done) override {\n    auto output_shape = c->input(0).shape();\n    OP_REQUIRES_ASYNC(c, output_shape.dims() > 0,\n                      errors::InvalidArgument(\"input should have rank > 0, \",\n                                              \"recieved \", output_shape.dims()),\n                      done);\n    output_shape.set_dim(\n        0, output_shape.dim_size(0) * col_params_->group.group_size);\n    col_params_->instance.shape = output_shape;\n    if (c->mutable_output(0) == nullptr) {\n      Tensor* output = nullptr;\n      OP_REQUIRES_OK_ASYNC(\n          c, c->allocate_output(0, col_params_->instance.shape, &output), done);\n    }\n    if (!CanProceedWithCompute(c, col_exec, done)) return;\n    auto actual_done = [c, col_params = col_params_, done](const Status& s) {\n      VLOG(1) << \"CollectiveGatherOpKernel ExecuteAsync done for collective \"\n              << c->op_kernel().name() << \" device \" << c->device()->name()\n              << \" group \" << col_params->group.group_key << \" instance \"\n              << col_params->instance.instance_key << \" status \" << s;\n      col_params->Unref();\n      OP_REQUIRES_OK_ASYNC(c, s, done);\n      done();\n    };\n    VLOG(1) << \"CollectiveGatherOpKernel ExecuteAsync start for collective \"\n            << col_params_->name << \" device \" << c->device()->name()\n            << \" group \" << col_params_->group.group_key << \" instance \"\n            << col_params_->instance.instance_key;\n    col_params_->Ref();\n    col_exec->ExecuteAsync(c, col_params_, GetCollectiveKey(c), actual_done);\n  }", "target": 0}
{"code": "struct file *get_empty_filp(void)\n{\n\tconst struct cred *cred = current_cred();\n\tstatic long old_max;\n\tstruct file *f;\n\tint error;\n\tif (get_nr_files() >= files_stat.max_files && !capable(CAP_SYS_ADMIN)) {\n\t\tif (percpu_counter_sum_positive(&nr_files) >= files_stat.max_files)\n\t\t\tgoto over;\n\t}\n\tf = kmem_cache_zalloc(filp_cachep, GFP_KERNEL);\n\tif (unlikely(!f))\n\t\treturn ERR_PTR(-ENOMEM);\n\tpercpu_counter_inc(&nr_files);\n\tf->f_cred = get_cred(cred);\n\terror = security_file_alloc(f);\n\tif (unlikely(error)) {\n\t\tfile_free(f);\n\t\treturn ERR_PTR(error);\n\t}\n\tINIT_LIST_HEAD(&f->f_u.fu_list);\n\tatomic_long_set(&f->f_count, 1);\n\trwlock_init(&f->f_owner.lock);\n\tspin_lock_init(&f->f_lock);\n\teventpoll_init_file(f);\n\treturn f;\nover:\n\tif (get_nr_files() > old_max) {\n\t\tpr_info(\"VFS: file-max limit %lu reached\\n\", get_max_files());\n\t\told_max = get_nr_files();\n\t}\n\treturn ERR_PTR(-ENFILE);\n}", "target": 1}
{"code": "void HTMLSelectElement::dispatchFocusEvent(Element* oldFocusedElement, FocusDirection direction)\n{\n    if (usesMenuList())\n        saveLastSelection();\n    HTMLFormControlElementWithState::dispatchFocusEvent(oldFocusedElement, direction);\n}", "target": 0}
{"code": "newVar5(char *var,char *var2, char *var3,char *var4,char *var5)\n{\n\tstruct SWF_ACTIONPUSHPARAM *v;\n\tv=malloc(sizeof(struct SWF_ACTIONPUSHPARAM));\n\tv->Type = PUSH_VARIABLE; \n\tv->p.String = malloc(strlen(var)+strlen(var2)+strlen(var3)+strlen(var4)+strlen(var5)+1);\n\tstrcpy(v->p.String,var);\n\tstrcat(v->p.String,var2);\n\tstrcat(v->p.String,var3);\n\tstrcat(v->p.String,var4);\n\tstrcat(v->p.String,var5);\n\treturn v;\n}", "target": 0}
{"code": "local block_state deflate_huff(s, flush)\n    deflate_state *s;\n    int flush;\n{\n    int bflush;             \n    for (;;) {\n        if (s->lookahead == 0) {\n            fill_window(s);\n            if (s->lookahead == 0) {\n                if (flush == Z_NO_FLUSH)\n                    return need_more;\n                break;      \n            }\n        }\n        s->match_length = 0;\n        Tracevv((stderr,\"%c\", s->window[s->strstart]));\n        _tr_tally_lit (s, s->window[s->strstart], bflush);\n        s->lookahead--;\n        s->strstart++;\n        if (bflush) FLUSH_BLOCK(s, 0);\n    }\n    s->insert = 0;\n    if (flush == Z_FINISH) {\n        FLUSH_BLOCK(s, 1);\n        return finish_done;\n    }\n    if (s->last_lit)\n        FLUSH_BLOCK(s, 0);\n    return block_done;\n}", "target": 1}
{"code": "static struct rpmsg_device *rpmsg_virtio_add_ctrl_dev(struct virtio_device *vdev)\n{\n\tstruct virtproc_info *vrp = vdev->priv;\n\tstruct virtio_rpmsg_channel *vch;\n\tstruct rpmsg_device *rpdev_ctrl;\n\tint err = 0;\n\tvch = kzalloc(sizeof(*vch), GFP_KERNEL);\n\tif (!vch)\n\t\treturn ERR_PTR(-ENOMEM);\n\tvch->vrp = vrp;\n\trpdev_ctrl = &vch->rpdev;\n\trpdev_ctrl->ops = &virtio_rpmsg_ops;\n\trpdev_ctrl->dev.parent = &vrp->vdev->dev;\n\trpdev_ctrl->dev.release = virtio_rpmsg_release_device;\n\trpdev_ctrl->little_endian = virtio_is_little_endian(vrp->vdev);\n\terr = rpmsg_ctrldev_register_device(rpdev_ctrl);\n\tif (err) {\n\t\tkfree(vch);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn rpdev_ctrl;\n}", "target": 1}
{"code": "  template <Type type> static const RegistrationMap& headers() {\n    ASSERT(mutableFinalized<type>());\n    return mutableRegistrationMap<type>();\n  }", "target": 0}
{"code": "dodynamic(struct magic_set *ms, void *vbuf, size_t offset, size_t size,\n    int clazz, int swap)\n{\n\tElf32_Dyn dh32;\n\tElf64_Dyn dh64;\n\tunsigned char *dbuf = CAST(unsigned char *, vbuf);\n\tif (xdh_sizeof + offset > size) {\n\t\treturn xdh_sizeof + offset;\n\t}\n\tmemcpy(xdh_addr, &dbuf[offset], xdh_sizeof);\n\toffset += xdh_sizeof;\n\tswitch (xdh_tag) {\n\tcase DT_FLAGS_1:\n\t\tif (xdh_val & DF_1_PIE)\n\t\t\tms->mode |= 0111;\n\t\telse\n\t\t\tms->mode &= ~0111;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn offset;\n}", "target": 0}
{"code": "static int ssl_verify_server_cert(Vio *vio, const char* server_hostname, const char **errptr)\n{\n  SSL *ssl;\n  X509 *server_cert;\n  char *cp1, *cp2;\n  char *buf;\n  DBUG_ENTER(\"ssl_verify_server_cert\");\n  DBUG_PRINT(\"enter\", (\"server_hostname: %s\", server_hostname));\n  if (!(ssl= (SSL*)vio->ssl_arg))\n  {\n    *errptr= \"No SSL pointer found\";\n    DBUG_RETURN(1);\n  }\n  if (!server_hostname)\n  {\n    *errptr= \"No server hostname supplied\";\n    DBUG_RETURN(1);\n  }\n  if (!(server_cert= SSL_get_peer_certificate(ssl)))\n  {\n    *errptr= \"Could not get server certificate\";\n    DBUG_RETURN(1);\n  }\n  if (X509_V_OK != SSL_get_verify_result(ssl))\n  {\n    *errptr= \"Failed to verify the server certificate\";\n    X509_free(server_cert);\n    DBUG_RETURN(1);\n  }\n  buf= X509_NAME_oneline(X509_get_subject_name(server_cert), 0, 0);\n  X509_free (server_cert);\n  if (!buf)\n  {\n    *errptr= \"Out of memory\";\n    DBUG_RETURN(1);\n  }\n  DBUG_PRINT(\"info\", (\"hostname in cert: %s\", buf));\n  cp1= strstr(buf, \"/CN=\");\n  if (cp1)\n  {\n    cp1+= 4; \n    cp2= strchr(cp1, '/');\n    if (cp2)\n      *cp2= '\\0';\n    DBUG_PRINT(\"info\", (\"Server hostname in cert: %s\", cp1));\n    if (!strcmp(cp1, server_hostname))\n    {\n      free(buf);\n      DBUG_RETURN(0);\n    }\n  }\n  *errptr= \"SSL certificate validation failure\";\n  free(buf);\n  DBUG_RETURN(1);\n}", "target": 1}
{"code": "PGTYPESinterval_from_asc(char *str, char **endptr)\n{\n\tinterval   *result = NULL;\n\tfsec_t\t\tfsec;\n\tstruct tm\ttt,\n\t\t\t   *tm = &tt;\n\tint\t\t\tdtype;\n\tint\t\t\tnf;\n\tchar\t   *field[MAXDATEFIELDS];\n\tint\t\t\tftype[MAXDATEFIELDS];\n\tchar\t\tlowstr[MAXDATELEN + MAXDATEFIELDS];\n\tchar\t   *realptr;\n\tchar\t  **ptr = (endptr != NULL) ? endptr : &realptr;\n\ttm->tm_year = 0;\n\ttm->tm_mon = 0;\n\ttm->tm_mday = 0;\n\ttm->tm_hour = 0;\n\ttm->tm_min = 0;\n\ttm->tm_sec = 0;\n\tfsec = 0;\n\tif (strlen(str) >= sizeof(lowstr))\n\t{\n\t\terrno = PGTYPES_INTVL_BAD_INTERVAL;\n\t\treturn NULL;\n\t}\n\tif (ParseDateTime(str, lowstr, field, ftype, &nf, ptr) != 0 ||\n\t\t(DecodeInterval(field, ftype, nf, &dtype, tm, &fsec) != 0 &&\n\t\t DecodeISO8601Interval(str, &dtype, tm, &fsec) != 0))\n\t{\n\t\terrno = PGTYPES_INTVL_BAD_INTERVAL;\n\t\treturn NULL;\n\t}\n\tresult = (interval *) pgtypes_alloc(sizeof(interval));\n\tif (!result)\n\t\treturn NULL;\n\tif (dtype != DTK_DELTA)\n\t{\n\t\terrno = PGTYPES_INTVL_BAD_INTERVAL;\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\tif (tm2interval(tm, fsec, result) != 0)\n\t{\n\t\terrno = PGTYPES_INTVL_BAD_INTERVAL;\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\terrno = 0;\n\treturn result;\n}", "target": 1}
{"code": "static void k_ascii(struct vc_data *vc, unsigned char value, char up_flag)\n{\n\tint base;\n\tif (up_flag)\n\t\treturn;\n\tif (value < 10) {\n\t\tbase = 10;\n\t} else {\n\t\tvalue -= 10;\n\t\tbase = 16;\n\t}\n\tif (npadch == -1)\n\t\tnpadch = value;\n\telse\n\t\tnpadch = npadch * base + value;\n}", "target": 1}
{"code": "static int filter_frame(AVFilterLink *inlink, AVFrame *in)\n{\n    AVFilterContext *ctx = inlink->dst;\n    LutContext *s = ctx->priv;\n    AVFilterLink *outlink = ctx->outputs[0];\n    AVFrame *out;\n    uint8_t *inrow, *outrow, *inrow0, *outrow0;\n    int i, j, plane, direct = 0;\n    if (av_frame_is_writable(in)) {\n        direct = 1;\n        out = in;\n    } else {\n        out = ff_get_video_buffer(outlink, outlink->w, outlink->h);\n        if (!out) {\n            av_frame_free(&in);\n            return AVERROR(ENOMEM);\n        }\n        av_frame_copy_props(out, in);\n    }\n    if (s->is_rgb) {\n        inrow0  = in ->data[0];\n        outrow0 = out->data[0];\n        for (i = 0; i < in->height; i ++) {\n            int w = inlink->w;\n            const uint8_t (*tab)[256] = (const uint8_t (*)[256])s->lut;\n            inrow  = inrow0;\n            outrow = outrow0;\n            for (j = 0; j < w; j++) {\n                switch (s->step) {\n                case 4:  outrow[3] = tab[3][inrow[3]]; \n                case 3:  outrow[2] = tab[2][inrow[2]]; \n                case 2:  outrow[1] = tab[1][inrow[1]]; \n                default: outrow[0] = tab[0][inrow[0]];\n                }\n                outrow += s->step;\n                inrow  += s->step;\n            }\n            inrow0  += in ->linesize[0];\n            outrow0 += out->linesize[0];\n        }\n    } else {\n        for (plane = 0; plane < 4 && in->data[plane]; plane++) {\n            int vsub = plane == 1 || plane == 2 ? s->vsub : 0;\n            int hsub = plane == 1 || plane == 2 ? s->hsub : 0;\n            int h = FF_CEIL_RSHIFT(inlink->h, vsub);\n            int w = FF_CEIL_RSHIFT(inlink->w, hsub);\n            inrow  = in ->data[plane];\n            outrow = out->data[plane];\n            for (i = 0; i < h; i++) {\n                const uint8_t *tab = s->lut[plane];\n                for (j = 0; j < w; j++)\n                    outrow[j] = tab[inrow[j]];\n                inrow  += in ->linesize[plane];\n                outrow += out->linesize[plane];\n            }\n        }\n    }\n    if (!direct)\n        av_frame_free(&in);\n    return ff_filter_frame(outlink, out);\n}", "target": 1}
{"code": "set_range(bitstr_t *bits, int low, int high, int start, int stop, int step) {\n\tDebug(DPARS|DEXT, (\"set_range(?,%d,%d,%d,%d,%d)\\n\",\n\t\t\t   low, high, start, stop, step))\n\tif (start < low || stop > high)\n\t\treturn (EOF);\n\tstart -= low;\n\tstop -= low;\n\tif (step == 1) {\n\t\tbit_nset(bits, start, stop);\n\t} else {\n\t\tfor (int i = start; i <= stop; i += step)\n\t\t\tbit_set(bits, i);\n\t}\n\treturn (OK);\n}", "target": 1}
{"code": "bool AccessibilityUIElement::isAttributeSupported(JSStringRef attribute)\n{\n    return false;\n}", "target": 0}
{"code": "void altivec_unavailable_exception(struct pt_regs *regs)\n{\n#if !defined(CONFIG_ALTIVEC)\n\tif (user_mode(regs)) {\n\t\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n\t\treturn;\n\t}\n#endif\n\tprintk(KERN_EMERG \"Unrecoverable VMX/Altivec Unavailable Exception \"\n\t\t\t\"%lx at %lx\\n\", regs->trap, regs->nip);\n\tdie(\"Unrecoverable VMX/Altivec Unavailable Exception\", regs, SIGABRT);\n}", "target": 1}
{"code": "bool Sampler::operator==(const Sampler &other) const {\n  return this->extensions == other.extensions && this->extras == other.extras &&\n         this->magFilter == other.magFilter &&\n         this->minFilter == other.minFilter && this->name == other.name &&\n         this->wrapS == other.wrapS &&\n         this->wrapT == other.wrapT;\n}", "target": 1}
{"code": "crm_send_remote_msg(void *session, xmlNode * msg, gboolean encrypted)\n{\n    if (encrypted) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        cib_send_tls(session, msg);\n#else\n        CRM_ASSERT(encrypted == FALSE);\n#endif\n    } else {\n        cib_send_plaintext(GPOINTER_TO_INT(session), msg);\n    }\n}", "target": 1}
{"code": "Bool Ppmd8_Alloc(CPpmd8 *p, UInt32 size)\n{\n  if (p->Base == 0 || p->Size != size)\n  {\n    Ppmd8_Free(p);\n    p->AlignOffset =\n      #ifdef PPMD_32BIT\n        (4 - size) & 3;\n      #else\n        4 - (size & 3);\n      #endif\n    if ((p->Base = (Byte *)malloc(p->AlignOffset + size)) == 0)\n      return False;\n    p->Size = size;\n  }\n  return True;\n}", "target": 0}
{"code": "parse_notification(struct rpki_uri *uri, struct update_notification **file)\n{\n\tstruct rdr_notification_ctx ctx;\n\tstruct update_notification *tmp;\n\tchar *dup;\n\tint error;\n\tdup = strdup(uri_get_global(uri));\n\tif (dup == NULL)\n\t\treturn pr_enomem();\n\terror = update_notification_create(&tmp);\n\tif (error)\n\t\treturn error;\n\ttmp->uri = dup;\n\tctx.notification = tmp;\n\terror = relax_ng_parse(uri_get_local(uri), xml_read_notification,\n\t    &ctx);\n\tif (error) {\n\t\tupdate_notification_destroy(tmp);\n\t\treturn error;\n\t}\n\t*file = tmp;\n\treturn 0;\n}", "target": 1}
{"code": "int anon_vma_fork(struct vm_area_struct *vma, struct vm_area_struct *pvma)\n{\n\tstruct anon_vma_chain *avc;\n\tstruct anon_vma *anon_vma;\n\tint error;\n\tif (!pvma->anon_vma)\n\t\treturn 0;\n\tvma->anon_vma = NULL;\n\terror = anon_vma_clone(vma, pvma);\n\tif (error)\n\t\treturn error;\n\tif (vma->anon_vma)\n\t\treturn 0;\n\tanon_vma = anon_vma_alloc();\n\tif (!anon_vma)\n\t\tgoto out_error;\n\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\tif (!avc)\n\t\tgoto out_error_free_anon_vma;\n\tanon_vma->root = pvma->anon_vma->root;\n\tanon_vma->parent = pvma->anon_vma;\n\tget_anon_vma(anon_vma->root);\n\tvma->anon_vma = anon_vma;\n\tanon_vma_lock_write(anon_vma);\n\tanon_vma_chain_link(vma, avc, anon_vma);\n\tanon_vma->parent->degree++;\n\tanon_vma_unlock_write(anon_vma);\n\treturn 0;\n out_error_free_anon_vma:\n\tput_anon_vma(anon_vma);\n out_error:\n\tunlink_anon_vmas(vma);\n\treturn -ENOMEM;\n}", "target": 1}
{"code": "static inline int http_parse_chunk_size(struct http_msg *msg)\n{\n\tconst struct buffer *buf = msg->chn->buf;\n\tconst char *ptr = b_ptr(buf, msg->next);\n\tconst char *ptr_old = ptr;\n\tconst char *end = buf->data + buf->size;\n\tconst char *stop = bi_end(buf);\n\tunsigned int chunk = 0;\n\twhile (1) {\n\t\tint c;\n\t\tif (ptr == stop)\n\t\t\treturn 0;\n\t\tc = hex2i(*ptr);\n\t\tif (c < 0) \n\t\t\tbreak;\n\t\tif (unlikely(++ptr >= end))\n\t\t\tptr = buf->data;\n\t\tif (chunk & 0xF8000000) \n\t\t\tgoto error;\n\t\tchunk = (chunk << 4) + c;\n\t}\n\tif (unlikely(ptr == ptr_old))\n\t\tgoto error;\n\twhile (http_is_spht[(unsigned char)*ptr]) {\n\t\tif (++ptr >= end)\n\t\t\tptr = buf->data;\n\t\tif (unlikely(ptr == stop))\n\t\t\treturn 0;\n\t}\n\twhile (1) {\n\t\tif (likely(HTTP_IS_CRLF(*ptr))) {\n\t\t\tif (likely(*ptr == '\\r')) {\n\t\t\t\tif (++ptr >= end)\n\t\t\t\t\tptr = buf->data;\n\t\t\t\tif (ptr == stop)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (*ptr != '\\n')\n\t\t\t\tgoto error;\n\t\t\tif (++ptr >= end)\n\t\t\t\tptr = buf->data;\n\t\t\tbreak;\n\t\t}\n\t\telse if (*ptr == ';') {\n\t\t\tif (++ptr >= end)\n\t\t\t\tptr = buf->data;\n\t\t\tif (ptr == stop)\n\t\t\t\treturn 0;\n\t\t\twhile (!HTTP_IS_CRLF(*ptr)) {\n\t\t\t\tif (++ptr >= end)\n\t\t\t\t\tptr = buf->data;\n\t\t\t\tif (ptr == stop)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\telse\n\t\t\tgoto error;\n\t}\n\tif (unlikely(ptr < ptr_old))\n\t\tmsg->sov += buf->size;\n\tmsg->sov += ptr - ptr_old;\n\tmsg->next = buffer_count(buf, buf->p, ptr);\n\tmsg->chunk_len = chunk;\n\tmsg->body_len += chunk;\n\tmsg->msg_state = chunk ? HTTP_MSG_DATA : HTTP_MSG_TRAILERS;\n\treturn 1;\n error:\n\tmsg->err_pos = buffer_count(buf, buf->p, ptr);\n\treturn -1;\n}", "target": 0}
{"code": "static void destroy_pit_timer(struct kvm_pit *pit)\n{\n\thrtimer_cancel(&pit->pit_state.timer);\n\tflush_kthread_work(&pit->expired);\n}", "target": 0}
{"code": "static void CopyRectangleFromRectangle(rfbClient* client, int src_x, int src_y, int w, int h, int dest_x, int dest_y) {\n  int i,j;\n#define COPY_RECT_FROM_RECT(BPP) \\\n  { \\\n    uint##BPP##_t* _buffer=((uint##BPP##_t*)client->frameBuffer)+(src_y-dest_y)*client->width+src_x-dest_x; \\\n    if (dest_y < src_y) { \\\n      for(j = dest_y*client->width; j < (dest_y+h)*client->width; j += client->width) { \\\n        if (dest_x < src_x) { \\\n          for(i = dest_x; i < dest_x+w; i++) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } else { \\\n          for(i = dest_x+w-1; i >= dest_x; i--) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } \\\n      } \\\n    } else { \\\n      for(j = (dest_y+h-1)*client->width; j >= dest_y*client->width; j-=client->width) { \\\n        if (dest_x < src_x) { \\\n          for(i = dest_x; i < dest_x+w; i++) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } else { \\\n          for(i = dest_x+w-1; i >= dest_x; i--) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } \\\n      } \\\n    } \\\n  }\n  switch(client->format.bitsPerPixel) {\n  case  8: COPY_RECT_FROM_RECT(8);  break;\n  case 16: COPY_RECT_FROM_RECT(16); break;\n  case 32: COPY_RECT_FROM_RECT(32); break;\n  default:\n    rfbClientLog(\"Unsupported bitsPerPixel: %d\\n\",client->format.bitsPerPixel);\n  }\n}", "target": 0}
{"code": "static cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)\n{\n    cJSON *current_element = NULL;\n    if ((object == NULL) || (name == NULL))\n    {\n        return NULL;\n    }\n    current_element = object->child;\n    if (case_sensitive)\n    {\n        while ((current_element != NULL) && (strcmp(name, current_element->string) != 0))\n        {\n            current_element = current_element->next;\n        }\n    }\n    else\n    {\n        while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))\n        {\n            current_element = current_element->next;\n        }\n    }\n    return current_element;\n}", "target": 1}
{"code": "int jpc_ppxstab_insert(jpc_ppxstab_t *tab, jpc_ppxstabent_t *ent)\n{\n\tint inspt;\n\tint i;\n\tfor (i = 0; i < tab->numents; ++i) {\n\t\tif (tab->ents[i]->ind > ent->ind) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tinspt = i;\n\tif (tab->numents >= tab->maxents) {\n\t\tif (jpc_ppxstab_grow(tab, tab->maxents + 128)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tfor (i = tab->numents; i > inspt; --i) {\n\t\ttab->ents[i] = tab->ents[i - 1];\n\t}\n\ttab->ents[i] = ent;\n\t++tab->numents;\n\treturn 0;\n}", "target": 1}
{"code": "SPL_METHOD(Array, setFlags)\n{\n\tzval *object = getThis();\n\tspl_array_object *intern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);\n\tlong ar_flags = 0;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &ar_flags) == FAILURE) {\n\t\treturn;\n\t}\n\tintern->ar_flags = (intern->ar_flags & SPL_ARRAY_INT_MASK) | (ar_flags & ~SPL_ARRAY_INT_MASK);\n}", "target": 0}
{"code": "static void mspack_fmap_free(void *mem)\n{\n\tfree(mem);\n}", "target": 1}
{"code": "SPL_METHOD(SplDoublyLinkedList, offsetSet)\n{\n\tzval                  *zindex, *value;\n\tspl_dllist_object     *intern;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"zz\", &zindex, &value) == FAILURE) {\n\t\treturn;\n\t}\n\tintern = Z_SPLDLLIST_P(getThis());\n\tif (Z_TYPE_P(zindex) == IS_NULL) {\n\t\tspl_ptr_llist_push(intern->llist, value);\n\t} else {\n\t\tzend_long                   index;\n\t\tspl_ptr_llist_element *element;\n\t\tindex = spl_offset_convert_to_long(zindex);\n\t\tif (index < 0 || index >= intern->llist->count) {\n\t\t\tzval_ptr_dtor(value);\n\t\t\tzend_throw_exception(spl_ce_OutOfRangeException, \"Offset invalid or out of range\", 0);\n\t\t\treturn;\n\t\t}\n\t\telement = spl_ptr_llist_offset(intern->llist, index, intern->flags & SPL_DLLIST_IT_LIFO);\n\t\tif (element != NULL) {\n\t\t\tif (intern->llist->dtor) {\n\t\t\t\tintern->llist->dtor(element);\n\t\t\t}\n\t\t\tzval_ptr_dtor(&element->data);\n\t\t\tZVAL_COPY_VALUE(&element->data, value);\n\t\t\tif (intern->llist->ctor) {\n\t\t\t\tintern->llist->ctor(element);\n\t\t\t}\n\t\t} else {\n\t\t\tzval_ptr_dtor(value);\n\t\t\tzend_throw_exception(spl_ce_OutOfRangeException, \"Offset invalid\", 0);\n\t\t\treturn;\n\t\t}\n\t}\n} ", "target": 1}
{"code": "int is_subdir(struct dentry *new_dentry, struct dentry *old_dentry)\n{\n\tint result;\n\tunsigned seq;\n\tif (new_dentry == old_dentry)\n\t\treturn 1;\n\tdo {\n\t\tseq = read_seqbegin(&rename_lock);\n\t\trcu_read_lock();\n\t\tif (d_ancestor(old_dentry, new_dentry))\n\t\t\tresult = 1;\n\t\telse\n\t\t\tresult = 0;\n\t\trcu_read_unlock();\n\t} while (read_seqretry(&rename_lock, seq));\n\treturn result;\n}", "target": 0}
{"code": "static void php_snmp_session_destructor(zend_resource *rsrc) \n{\n\tphp_snmp_session *session = (php_snmp_session *)rsrc->ptr;\n\tnetsnmp_session_free(&session);\n}", "target": 0}
{"code": "mldv2_report_print(netdissect_options *ndo, const u_char *bp, u_int len)\n{\n    const struct icmp6_hdr *icp = (const struct icmp6_hdr *) bp;\n    u_int group, nsrcs, ngroups;\n    u_int i, j;\n    if (len < 8) {\n            ND_PRINT((ndo,\" [invalid len %d]\", len));\n            return;\n    }\n    ND_TCHECK(icp->icmp6_data16[1]);\n    ngroups = EXTRACT_16BITS(&icp->icmp6_data16[1]);\n    ND_PRINT((ndo,\", %d group record(s)\", ngroups));\n    if (ndo->ndo_vflag > 0) {\n\tgroup = 8;\n        for (i = 0; i < ngroups; i++) {\n\t    if (len < group + 20) {\n                    ND_PRINT((ndo,\" [invalid number of groups]\"));\n                    return;\n\t    }\n            ND_TCHECK2(bp[group + 4], sizeof(struct in6_addr));\n            ND_PRINT((ndo,\" [gaddr %s\", ip6addr_string(ndo, &bp[group + 4])));\n\t    ND_PRINT((ndo,\" %s\", tok2str(mldv2report2str, \" [v2-report-#%d]\",\n                                         bp[group])));\n            nsrcs = (bp[group + 2] << 8) + bp[group + 3];\n\t    if (len < group + 20 + (nsrcs * sizeof(struct in6_addr))) {\n                    ND_PRINT((ndo,\" [invalid number of sources %d]\", nsrcs));\n                    return;\n\t    }\n            if (ndo->ndo_vflag == 1)\n                    ND_PRINT((ndo,\", %d source(s)\", nsrcs));\n            else {\n                    ND_PRINT((ndo,\" {\"));\n                for (j = 0; j < nsrcs; j++) {\n                    ND_TCHECK2(bp[group + 20 + j * sizeof(struct in6_addr)],\n                            sizeof(struct in6_addr));\n\t\t    ND_PRINT((ndo,\" %s\", ip6addr_string(ndo, &bp[group + 20 + j * sizeof(struct in6_addr)])));\n\t\t}\n                ND_PRINT((ndo,\" }\"));\n            }\n            group += 20 + nsrcs * sizeof(struct in6_addr);\n\t    ND_PRINT((ndo,\"]\"));\n        }\n    }\n    return;\ntrunc:\n    ND_PRINT((ndo,\"[|icmp6]\"));\n    return;\n}", "target": 1}
{"code": "static int kvm_ioctl_create_device(struct kvm *kvm,\n\t\t\t\t   struct kvm_create_device *cd)\n{\n\tstruct kvm_device_ops *ops = NULL;\n\tstruct kvm_device *dev;\n\tbool test = cd->flags & KVM_CREATE_DEVICE_TEST;\n\tint ret;\n\tif (cd->type >= ARRAY_SIZE(kvm_device_ops_table))\n\t\treturn -ENODEV;\n\tops = kvm_device_ops_table[cd->type];\n\tif (ops == NULL)\n\t\treturn -ENODEV;\n\tif (test)\n\t\treturn 0;\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tdev->ops = ops;\n\tdev->kvm = kvm;\n\tmutex_lock(&kvm->lock);\n\tret = ops->create(dev, cd->type);\n\tif (ret < 0) {\n\t\tmutex_unlock(&kvm->lock);\n\t\tkfree(dev);\n\t\treturn ret;\n\t}\n\tlist_add(&dev->vm_node, &kvm->devices);\n\tmutex_unlock(&kvm->lock);\n\tif (ops->init)\n\t\tops->init(dev);\n\tret = anon_inode_getfd(ops->name, &kvm_device_fops, dev, O_RDWR | O_CLOEXEC);\n\tif (ret < 0) {\n\t\tops->destroy(dev);\n\t\tmutex_lock(&kvm->lock);\n\t\tlist_del(&dev->vm_node);\n\t\tmutex_unlock(&kvm->lock);\n\t\treturn ret;\n\t}\n\tkvm_get_kvm(kvm);\n\tcd->fd = ret;\n\treturn 0;\n}", "target": 1}
{"code": "PluginInfoMessageFilter::~PluginInfoMessageFilter() {}", "target": 0}
{"code": "int TS_OBJ_print_bio(BIO *bio, const ASN1_OBJECT *obj)\n{\n    char obj_txt[128];\n    int len = OBJ_obj2txt(obj_txt, sizeof(obj_txt), obj, 0);\n    BIO_write(bio, obj_txt, len);\n    BIO_write(bio, \"\\n\", 1);\n    return 1;\n}", "target": 1}
{"code": "entityValueInitProcessor(XML_Parser parser, const char *s, const char *end,\n                         const char **nextPtr) {\n  int tok;\n  const char *start = s;\n  const char *next = start;\n  parser->m_eventPtr = start;\n  for (;;) {\n    tok = XmlPrologTok(parser->m_encoding, start, end, &next);\n    parser->m_eventEndPtr = next;\n    if (tok <= 0) {\n      if (! parser->m_parsingStatus.finalBuffer && tok != XML_TOK_INVALID) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      switch (tok) {\n      case XML_TOK_INVALID:\n        return XML_ERROR_INVALID_TOKEN;\n      case XML_TOK_PARTIAL:\n        return XML_ERROR_UNCLOSED_TOKEN;\n      case XML_TOK_PARTIAL_CHAR:\n        return XML_ERROR_PARTIAL_CHAR;\n      case XML_TOK_NONE: \n      default:\n        break;\n      }\n      return storeEntityValue(parser, parser->m_encoding, s, end,\n                              XML_ACCOUNT_DIRECT);\n    } else if (tok == XML_TOK_XML_DECL) {\n      enum XML_Error result;\n      result = processXmlDecl(parser, 0, start, next);\n      if (result != XML_ERROR_NONE)\n        return result;\n      if (parser->m_parsingStatus.parsing == XML_FINISHED)\n        return XML_ERROR_ABORTED;\n      *nextPtr = next;\n      parser->m_processor = entityValueProcessor;\n      return entityValueProcessor(parser, next, end, nextPtr);\n    }\n    else if (tok == XML_TOK_BOM) {\n#  ifdef XML_DTD\n      if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                    XML_ACCOUNT_DIRECT)) {\n        accountingOnAbort(parser);\n        return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n      }\n#  endif\n      *nextPtr = next;\n      s = next;\n    }\n    else if (tok == XML_TOK_INSTANCE_START) {\n      *nextPtr = next;\n      return XML_ERROR_SYNTAX;\n    }\n    start = next;\n    parser->m_eventPtr = start;\n  }\n}", "target": 1}
{"code": "struct bio *bio_map_kern(struct request_queue *q, void *data, unsigned int len,\n\t\t\t gfp_t gfp_mask)\n{\n\tunsigned long kaddr = (unsigned long)data;\n\tunsigned long end = (kaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tunsigned long start = kaddr >> PAGE_SHIFT;\n\tconst int nr_pages = end - start;\n\tint offset, i;\n\tstruct bio *bio;\n\tbio = bio_kmalloc(gfp_mask, nr_pages);\n\tif (!bio)\n\t\treturn ERR_PTR(-ENOMEM);\n\toffset = offset_in_page(kaddr);\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tunsigned int bytes = PAGE_SIZE - offset;\n\t\tif (len <= 0)\n\t\t\tbreak;\n\t\tif (bytes > len)\n\t\t\tbytes = len;\n\t\tif (bio_add_pc_page(q, bio, virt_to_page(data), bytes,\n\t\t\t\t    offset) < bytes) {\n\t\t\tbio_put(bio);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tdata += bytes;\n\t\tlen -= bytes;\n\t\toffset = 0;\n\t}\n\tbio->bi_end_io = bio_map_kern_endio;\n\treturn bio;\n}", "target": 0}
{"code": "static int __init pf_init(void)\n{\t\t\t\t\n\tstruct pf_unit *pf;\n\tint unit;\n\tif (disable)\n\t\treturn -EINVAL;\n\tpf_init_units();\n\tif (pf_detect())\n\t\treturn -ENODEV;\n\tpf_busy = 0;\n\tif (register_blkdev(major, name)) {\n\t\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++)\n\t\t\tput_disk(pf->disk);\n\t\treturn -EBUSY;\n\t}\n\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n\t\tstruct gendisk *disk = pf->disk;\n\t\tif (!pf->present)\n\t\t\tcontinue;\n\t\tdisk->private_data = pf;\n\t\tadd_disk(disk);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "cdf_read_header(const cdf_info_t *info, cdf_header_t *h)\n{\n\tchar buf[512];\n\t(void)memcpy(cdf_bo.s, \"\\01\\02\\03\\04\", 4);\n\tif (cdf_read(info, (off_t)0, buf, sizeof(buf)) == -1)\n\t\treturn -1;\n\tcdf_unpack_header(h, buf);\n\tcdf_swap_header(h);\n\tif (h->h_magic != CDF_MAGIC) {\n\t\tDPRINTF((\"Bad magic 0x%\" INT64_T_FORMAT \"x != 0x%\"\n\t\t    INT64_T_FORMAT \"x\\n\",\n\t\t    (unsigned long long)h->h_magic,\n\t\t    (unsigned long long)CDF_MAGIC));\n\t\tgoto out;\n\t}\n\tif (h->h_sec_size_p2 > 20) {\n\t\tDPRINTF((\"Bad sector size 0x%u\\n\", h->h_sec_size_p2));\n\t\tgoto out;\n\t}\n\tif (h->h_short_sec_size_p2 > 20) {\n\t\tDPRINTF((\"Bad short sector size 0x%u\\n\",\n\t\t    h->h_short_sec_size_p2));\n\t\tgoto out;\n\t}\n\treturn 0;\nout:\n\terrno = EFTYPE;\n\treturn -1;\n}", "target": 0}
{"code": "static int read_file(const char *path, char *buf, size_t size,\n\t\t     struct file_info *d)\n{\n\tsize_t linelen = 0, total_len = 0, rv = 0;\n\tchar *line = NULL;\n\tchar *cache = d->buf;\n\tsize_t cache_size = d->buflen;\n\tFILE *f = fopen(path, \"r\");\n\tif (!f)\n\t\treturn 0;\n\twhile (getline(&line, &linelen, f) != -1) {\n\t\tsize_t l = snprintf(cache, cache_size, \"%s\", line);\n\t\tif (l < 0) {\n\t\t\tperror(\"Error writing to cache\");\n\t\t\trv = 0;\n\t\t\tgoto err;\n\t\t}\n\t\tif (l >= cache_size) {\n\t\t\tfprintf(stderr, \"Internal error: truncated write to cache\\n\");\n\t\t\trv = 0;\n\t\t\tgoto err;\n\t\t}\n\t\tif (l < cache_size) {\n\t\t\tcache += l;\n\t\t\tcache_size -= l;\n\t\t\ttotal_len += l;\n\t\t} else {\n\t\t\tcache += cache_size;\n\t\t\ttotal_len += cache_size;\n\t\t\tcache_size = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\td->size = total_len;\n\tif (total_len > size ) total_len = size;\n\tmemcpy(buf, d->buf, total_len);\n\trv = total_len;\n  err:\n\tfclose(f);\n\tfree(line);\n\treturn rv;\n}", "target": 0}
{"code": "struct key *find_keyring_by_name(const char *name, bool skip_perm_check)\n{\n\tstruct key *keyring;\n\tint bucket;\n\tif (!name)\n\t\treturn ERR_PTR(-EINVAL);\n\tbucket = keyring_hash(name);\n\tread_lock(&keyring_name_lock);\n\tif (keyring_name_hash[bucket].next) {\n\t\tlist_for_each_entry(keyring,\n\t\t\t\t    &keyring_name_hash[bucket],\n\t\t\t\t    name_link\n\t\t\t\t    ) {\n\t\t\tif (!kuid_has_mapping(current_user_ns(), keyring->user->uid))\n\t\t\t\tcontinue;\n\t\t\tif (test_bit(KEY_FLAG_REVOKED, &keyring->flags))\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(keyring->description, name) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (!skip_perm_check &&\n\t\t\t    key_permission(make_key_ref(keyring, 0),\n\t\t\t\t\t   KEY_NEED_SEARCH) < 0)\n\t\t\t\tcontinue;\n\t\t\tif (!refcount_inc_not_zero(&keyring->usage))\n\t\t\t\tcontinue;\n\t\t\tkeyring->last_used_at = current_kernel_time().tv_sec;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tkeyring = ERR_PTR(-ENOKEY);\nout:\n\tread_unlock(&keyring_name_lock);\n\treturn keyring;\n}", "target": 1}
{"code": "static int adpt_system_info(void __user *buffer)\n{\n\tsysInfo_S si;\n\tmemset(&si, 0, sizeof(si));\n\tsi.osType = OS_LINUX;\n\tsi.osMajorVersion = 0;\n\tsi.osMinorVersion = 0;\n\tsi.osRevision = 0;\n\tsi.busType = SI_PCI_BUS;\n\tsi.processorFamily = DPTI_sig.dsProcessorFamily;\n#if defined __i386__\n\tadpt_i386_info(&si);\n#elif defined (__ia64__)\n\tadpt_ia64_info(&si);\n#elif defined(__sparc__)\n\tadpt_sparc_info(&si);\n#elif defined (__alpha__)\n\tadpt_alpha_info(&si);\n#else\n\tsi.processorType = 0xff ;\n#endif\n\tif (copy_to_user(buffer, &si, sizeof(si))){\n\t\tprintk(KERN_WARNING\"dpti: Could not copy buffer TO user\\n\");\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "IW_IMPL(unsigned int) iw_get_ui32le(const iw_byte *b)\n{\n\treturn b[0] | (b[1]<<8) | (b[2]<<16) | (b[3]<<24);\n}", "target": 1}
{"code": "static struct task_struct *find_process_by_pid(pid_t pid)\n{\n\treturn pid ? find_task_by_vpid(pid) : current;\n}", "target": 0}
{"code": "int io_msg_ring(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_msg *msg = io_kiocb_to_cmd(req, struct io_msg);\n\tint ret;\n\tret = -EBADFD;\n\tif (!io_is_uring_fops(req->file))\n\t\tgoto done;\n\tswitch (msg->cmd) {\n\tcase IORING_MSG_DATA:\n\t\tret = io_msg_ring_data(req);\n\t\tbreak;\n\tcase IORING_MSG_SEND_FD:\n\t\tret = io_msg_send_fd(req, issue_flags);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\ndone:\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\tio_req_set_res(req, ret, 0);\n\tio_put_file(req->file);\n\treq->file = NULL;\n\treturn IOU_OK;\n}", "target": 1}
{"code": "static struct page *hugetlbfs_pagecache_page(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long address)\n{\n\tstruct address_space *mapping;\n\tpgoff_t idx;\n\tmapping = vma->vm_file->f_mapping;\n\tidx = vma_hugecache_offset(h, vma, address);\n\treturn find_lock_page(mapping, idx);\n}", "target": 0}
{"code": "unsigned get_next_char(ASS_Renderer *render_priv, char **str)\n{\n    char *p = *str;\n    unsigned chr;\n    if (*p == '\\t') {\n        ++p;\n        *str = p;\n        return ' ';\n    }\n    if (*p == '\\\\') {\n        if ((p[1] == 'N') || ((p[1] == 'n') &&\n                              (render_priv->state.wrap_style == 2))) {\n            p += 2;\n            *str = p;\n            return '\\n';\n        } else if (p[1] == 'n') {\n            p += 2;\n            *str = p;\n            return ' ';\n        } else if (p[1] == 'h') {\n            p += 2;\n            *str = p;\n            return NBSP;\n        } else if (p[1] == '{') {\n            p += 2;\n            *str = p;\n            return '{';\n        } else if (p[1] == '}') {\n            p += 2;\n            *str = p;\n            return '}';\n        }\n    }\n    chr = ass_utf8_get_char((char **) &p);\n    *str = p;\n    return chr;\n}", "target": 0}
{"code": "   Read the full structure of a message */\nPHP_FUNCTION(imap_fetchstructure)\n{\n\tzval *streamind;\n\tzend_long msgno, flags = 0;\n\tpils *imap_le_struct;\n\tBODY *body;\n\tint msgindex, argc = ZEND_NUM_ARGS();\n\tif (zend_parse_parameters(argc, \"rl|l\", &streamind, &msgno, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\tif (flags && ((flags & ~FT_UID) != 0)) {\n\t\tphp_error_docref(NULL, E_WARNING, \"invalid value for the options parameter\");\n\t\tRETURN_FALSE;\n\t}\n\tif ((imap_le_struct = (pils *)zend_fetch_resource(Z_RES_P(streamind), \"imap\", le_imap)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tif (msgno < 1) {\n\t\tRETURN_FALSE;\n\t}\n\tobject_init(return_value);\n\tif ((argc == 3) && (flags & FT_UID)) {\n\t\tmsgindex = mail_msgno(imap_le_struct->imap_stream, msgno);\n\t} else {\n\t\tmsgindex = msgno;\n\t}\n\tPHP_IMAP_CHECK_MSGNO(msgindex);\n\tmail_fetchstructure_full(imap_le_struct->imap_stream, msgno, &body , (argc == 3 ? flags : NIL));\n\tif (!body) {\n\t\tphp_error_docref(NULL, E_WARNING, \"No body information available\");\n\t\tRETURN_FALSE;\n\t}\n\t_php_imap_add_body(return_value, body);", "target": 0}
{"code": "inline int32_t byteswap(int32_t value) { return _af_byteswap_int32(value); }", "target": 0}
{"code": "free_tabpage(tabpage_T *tp)\n{\n    int idx;\n# ifdef FEAT_DIFF\n    diff_clear(tp);\n# endif\n# ifdef FEAT_TEXT_PROP\n    while (tp->tp_first_popupwin != NULL)\n\tpopup_close_tabpage(tp, tp->tp_first_popupwin->w_id);\n#endif\n    for (idx = 0; idx < SNAP_COUNT; ++idx)\n\tclear_snapshot(tp, idx);\n#ifdef FEAT_EVAL\n    vars_clear(&tp->tp_vars->dv_hashtab);\t\n    hash_init(&tp->tp_vars->dv_hashtab);\n    unref_var_dict(tp->tp_vars);\n#endif\n    vim_free(tp->tp_localdir);\n#ifdef FEAT_PYTHON\n    python_tabpage_free(tp);\n#endif\n#ifdef FEAT_PYTHON3\n    python3_tabpage_free(tp);\n#endif\n    vim_free(tp);\n}", "target": 0}
{"code": "static int create_srq_ring(PCIDevice *pci_dev, PvrdmaRing **ring,\n                           uint64_t pdir_dma, uint32_t max_wr,\n                           uint32_t max_sge, uint32_t nchunks)\n{\n    uint64_t *dir = NULL, *tbl = NULL;\n    PvrdmaRing *r;\n    int rc = -EINVAL;\n    char ring_name[MAX_RING_NAME_SZ];\n    uint32_t wqe_sz;\n    if (!nchunks || nchunks > PVRDMA_MAX_FAST_REG_PAGES) {\n        rdma_error_report(\"Got invalid page count for SRQ ring: %d\",\n                          nchunks);\n        return rc;\n    }\n    dir = rdma_pci_dma_map(pci_dev, pdir_dma, TARGET_PAGE_SIZE);\n    if (!dir) {\n        rdma_error_report(\"Failed to map to SRQ page directory\");\n        goto out;\n    }\n    tbl = rdma_pci_dma_map(pci_dev, dir[0], TARGET_PAGE_SIZE);\n    if (!tbl) {\n        rdma_error_report(\"Failed to map to SRQ page table\");\n        goto out;\n    }\n    r = g_malloc(sizeof(*r));\n    *ring = r;\n    r->ring_state = (PvrdmaRingState *)\n            rdma_pci_dma_map(pci_dev, tbl[0], TARGET_PAGE_SIZE);\n    if (!r->ring_state) {\n        rdma_error_report(\"Failed to map tp SRQ ring state\");\n        goto out_free_ring_mem;\n    }\n    wqe_sz = pow2ceil(sizeof(struct pvrdma_rq_wqe_hdr) +\n                      sizeof(struct pvrdma_sge) * max_sge - 1);\n    sprintf(ring_name, \"srq_ring_%\" PRIx64, pdir_dma);\n    rc = pvrdma_ring_init(r, ring_name, pci_dev, &r->ring_state[1], max_wr,\n                          wqe_sz, (dma_addr_t *)&tbl[1], nchunks - 1);\n    if (rc) {\n        goto out_unmap_ring_state;\n    }\n    goto out;\nout_unmap_ring_state:\n    rdma_pci_dma_unmap(pci_dev, r->ring_state, TARGET_PAGE_SIZE);\nout_free_ring_mem:\n    g_free(r);\nout:\n    rdma_pci_dma_unmap(pci_dev, tbl, TARGET_PAGE_SIZE);\n    rdma_pci_dma_unmap(pci_dev, dir, TARGET_PAGE_SIZE);\n    return rc;\n}", "target": 0}
{"code": "static int cma_netdev_change(struct net_device *ndev, struct rdma_id_private *id_priv)\n{\n\tstruct rdma_dev_addr *dev_addr;\n\tstruct cma_work *work;\n\tdev_addr = &id_priv->id.route.addr.dev_addr;\n\tif ((dev_addr->bound_dev_if == ndev->ifindex) &&\n\t    (net_eq(dev_net(ndev), dev_addr->net)) &&\n\t    memcmp(dev_addr->src_dev_addr, ndev->dev_addr, ndev->addr_len)) {\n\t\tpr_info(\"RDMA CM addr change for ndev %s used by id %p\\n\",\n\t\t\tndev->name, &id_priv->id);\n\t\twork = kzalloc(sizeof *work, GFP_KERNEL);\n\t\tif (!work)\n\t\t\treturn -ENOMEM;\n\t\tINIT_WORK(&work->work, cma_work_handler);\n\t\twork->id = id_priv;\n\t\twork->event.event = RDMA_CM_EVENT_ADDR_CHANGE;\n\t\tcma_id_get(id_priv);\n\t\tqueue_work(cma_wq, &work->work);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int svm_cpu_init(int cpu)\n{\n\tstruct svm_cpu_data *sd;\n\tint r;\n\tsd = kzalloc(sizeof(struct svm_cpu_data), GFP_KERNEL);\n\tif (!sd)\n\t\treturn -ENOMEM;\n\tsd->cpu = cpu;\n\tr = -ENOMEM;\n\tsd->save_area = alloc_page(GFP_KERNEL);\n\tif (!sd->save_area)\n\t\tgoto err_1;\n\tif (svm_sev_enabled()) {\n\t\tr = -ENOMEM;\n\t\tsd->sev_vmcbs = kmalloc_array(max_sev_asid + 1,\n\t\t\t\t\t      sizeof(void *),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!sd->sev_vmcbs)\n\t\t\tgoto err_1;\n\t}\n\tper_cpu(svm_data, cpu) = sd;\n\treturn 0;\nerr_1:\n\tkfree(sd);\n\treturn r;\n}", "target": 1}
{"code": "nfs4_open_revalidate(struct inode *dir, struct dentry *dentry, int openflags, struct nameidata *nd)\n{\n\tstruct path path = {\n\t\t.mnt = nd->path.mnt,\n\t\t.dentry = dentry,\n\t};\n\tstruct rpc_cred *cred;\n\tstruct nfs4_state *state;\n\tcred = rpc_lookup_cred();\n\tif (IS_ERR(cred))\n\t\treturn PTR_ERR(cred);\n\tstate = nfs4_do_open(dir, &path, openflags, NULL, cred);\n\tput_rpccred(cred);\n\tif (IS_ERR(state)) {\n\t\tswitch (PTR_ERR(state)) {\n\t\t\tcase -EPERM:\n\t\t\tcase -EACCES:\n\t\t\tcase -EDQUOT:\n\t\t\tcase -ENOSPC:\n\t\t\tcase -EROFS:\n\t\t\t\tlookup_instantiate_filp(nd, (struct dentry *)state, NULL);\n\t\t\t\treturn 1;\n\t\t\tdefault:\n\t\t\t\tgoto out_drop;\n\t\t}\n\t}\n\tif (state->inode == dentry->d_inode) {\n\t\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\t\tnfs4_intent_set_file(nd, &path, state);\n\t\treturn 1;\n\t}\n\tnfs4_close_sync(&path, state, openflags);\nout_drop:\n\td_drop(dentry);\n\treturn 0;\n}", "target": 1}
{"code": "static int perf_swevent_add(struct perf_event *event, int flags)\n{\n\tstruct swevent_htable *swhash = this_cpu_ptr(&swevent_htable);\n\tstruct hw_perf_event *hwc = &event->hw;\n\tstruct hlist_head *head;\n\tif (is_sampling_event(event)) {\n\t\thwc->last_period = hwc->sample_period;\n\t\tperf_swevent_set_period(event);\n\t}\n\thwc->state = !(flags & PERF_EF_START);\n\thead = find_swevent_head(swhash, event);\n\tif (!head) {\n\t\tWARN_ON_ONCE(swhash->online);\n\t\treturn -EINVAL;\n\t}\n\thlist_add_head_rcu(&event->hlist_entry, head);\n\tperf_event_update_userpage(event);\n\treturn 0;\n}", "target": 1}
{"code": " */\nstatic int wddx_stack_destroy(wddx_stack *stack)\n{\n\tregister int i;\n\tif (stack->elements) {\n\t\tfor (i = 0; i < stack->top; i++) {\n\t\t\tif (((st_entry *)stack->elements[i])->data)\t{\n\t\t\t\tzval_ptr_dtor(&((st_entry *)stack->elements[i])->data);\n\t\t\t}\n\t\t\tif (((st_entry *)stack->elements[i])->varname) {\n\t\t\t\tefree(((st_entry *)stack->elements[i])->varname);\n\t\t\t}\n\t\t\tefree(stack->elements[i]);\n\t\t}\n\t\tefree(stack->elements);\n\t}\n\treturn SUCCESS;", "target": 1}
{"code": "  bool isReference() const { return type() == Type::Reference; }", "target": 0}
{"code": "static int coolkey_read_object(sc_card_t *card, unsigned long object_id, size_t offset,\n\t\t\tu8 *out_buf, size_t out_len, u8 *nonce, size_t nonce_size)\n{\n\tcoolkey_read_object_param_t params;\n\tu8 *out_ptr;\n\tsize_t left = 0;\n\tsize_t len;\n\tint r;\n\tulong2bebytes(&params.object_id[0], object_id);\n\tout_ptr = out_buf;\n\tleft = out_len;\n\tdo {\n\t\tulong2bebytes(&params.offset[0], offset);\n\t\tparams.length = MIN(left, COOLKEY_MAX_CHUNK_SIZE);\n\t\tlen = left;\n\t\tr = coolkey_apdu_io(card, COOLKEY_CLASS, COOLKEY_INS_READ_OBJECT, 0, 0,\n\t\t\t(u8 *)&params, sizeof(params), &out_ptr, &len, nonce, nonce_size);\n\t\tif (r < 0) {\n\t\t\tgoto fail;\n\t\t}\n\t\tif ((left < len) || (len == 0)) {\n\t\t\tr = SC_ERROR_INTERNAL;\n\t\t\tgoto fail;\n\t\t}\n\t\tout_ptr += len;\n\t\toffset += len;\n\t\tleft -= len;\n\t} while (left != 0);\n\treturn out_len;\nfail:\n\treturn r;\n}", "target": 0}
{"code": "find_sig8_target_as_global_offset(Dwarf_Attribute attr,\n    Dwarf_Sig8  *sig8,\n    Dwarf_Bool  *is_info,\n    Dwarf_Off   *targoffset,\n    Dwarf_Error *error)\n{\n    Dwarf_Die  targdie = 0;\n    Dwarf_Bool targ_is_info = 0;\n    Dwarf_Off  localoff = 0;\n    int res = 0;\n    targ_is_info = attr->ar_cu_context->cc_is_info;\n    memcpy(sig8,attr->ar_debug_ptr,sizeof(*sig8));\n    res = dwarf_find_die_given_sig8(attr->ar_dbg,\n        sig8,&targdie,&targ_is_info,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    res = dwarf_die_offsets(targdie,targoffset,&localoff,error);\n    if (res != DW_DLV_OK) {\n        dwarf_dealloc_die(targdie);\n        return res;\n    }\n    *is_info = targdie->di_cu_context->cc_is_info;\n    dwarf_dealloc_die(targdie);\n    return DW_DLV_OK;\n}", "target": 1}
{"code": "static int __init disable_acpi_irq(struct dmi_system_id *d)\n{\n\tif (!acpi_force) {\n\t\tprintk(KERN_NOTICE \"%s detected: force use of acpi=noirq\\n\",\n\t\t       d->ident);\n\t\tacpi_noirq_set();\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "ftrace_regex_lseek(struct file *file, loff_t offset, int whence)\n{\n\tloff_t ret;\n\tif (file->f_mode & FMODE_READ)\n\t\tret = seq_lseek(file, offset, whence);\n\telse\n\t\tfile->f_pos = ret = 1;\n\treturn ret;\n}", "target": 1}
{"code": "bool ChildThread::OnMessageReceived(const IPC::Message& msg) {\n  if (mojo_application_->OnMessageReceived(msg))\n    return true;\n  if (resource_dispatcher_->OnMessageReceived(msg))\n    return true;\n  if (socket_stream_dispatcher_->OnMessageReceived(msg))\n    return true;\n  if (websocket_dispatcher_->OnMessageReceived(msg))\n    return true;\n  if (file_system_dispatcher_->OnMessageReceived(msg))\n    return true;\n  bool handled = true;\n  IPC_BEGIN_MESSAGE_MAP(ChildThread, msg)\n    IPC_MESSAGE_HANDLER(ChildProcessMsg_Shutdown, OnShutdown)\n#if defined(IPC_MESSAGE_LOG_ENABLED)\n    IPC_MESSAGE_HANDLER(ChildProcessMsg_SetIPCLoggingEnabled,\n                        OnSetIPCLoggingEnabled)\n#endif\n    IPC_MESSAGE_HANDLER(ChildProcessMsg_SetProfilerStatus,\n                        OnSetProfilerStatus)\n    IPC_MESSAGE_HANDLER(ChildProcessMsg_GetChildProfilerData,\n                        OnGetChildProfilerData)\n    IPC_MESSAGE_HANDLER(ChildProcessMsg_DumpHandles, OnDumpHandles)\n#if defined(USE_TCMALLOC)\n    IPC_MESSAGE_HANDLER(ChildProcessMsg_GetTcmallocStats, OnGetTcmallocStats)\n#endif\n    IPC_MESSAGE_UNHANDLED(handled = false)\n  IPC_END_MESSAGE_MAP()\n  if (handled)\n    return true;\n  if (msg.routing_id() == MSG_ROUTING_CONTROL)\n    return OnControlMessageReceived(msg);\n  return router_.OnMessageReceived(msg);\n}", "target": 0}
{"code": "template <class T> void testFeatTable(const T & table, const char * testName)\n{\n    FeatureMap testFeatureMap;\n    dummyFace.replace_table(TtfUtil::Tag::Feat, &table, sizeof(T));\n    gr_face * face = gr_make_face_with_ops(&dummyFace, &face_handle::ops, gr_face_dumbRendering);\n    if (!face) throw std::runtime_error(\"failed to load font\");\n    bool readStatus = testFeatureMap.readFeats(*face);\n    testAssert(\"readFeats\", readStatus);\n    fprintf(stderr, testName, NULL);\n    testAssertEqual(\"test num features %hu,%hu\\n\", testFeatureMap.numFeats(), table.m_header.m_numFeat);\n    for (size_t i = 0; i < sizeof(table.m_defs) / sizeof(FeatDefn); i++)\n    {\n        const FeatureRef * ref = testFeatureMap.findFeatureRef(table.m_defs[i].m_featId);\n        testAssert(\"test feat\\n\", ref);\n        testAssertEqual(\"test feat settings %hu %hu\\n\", ref->getNumSettings(), table.m_defs[i].m_numFeatSettings);\n        testAssertEqual(\"test feat label %hu %hu\\n\", ref->getNameId(), table.m_defs[i].m_label);\n        size_t settingsIndex = (table.m_defs[i].m_settingsOffset - sizeof(FeatHeader)\n            - (sizeof(FeatDefn) * table.m_header.m_numFeat)) / sizeof(FeatSetting);\n        for (size_t j = 0; j < table.m_defs[i].m_numFeatSettings; j++)\n        {\n            testAssertEqual(\"setting label %hu %hu\\n\", ref->getSettingName(j),\n                       table.m_settings[settingsIndex+j].m_label);\n        }\n    }\n    gr_face_destroy(face);\n}", "target": 1}
{"code": "static inline int pmd_large(pmd_t pte)\n{\n\treturn (pmd_flags(pte) & (_PAGE_PSE | _PAGE_PRESENT)) ==\n\t\t(_PAGE_PSE | _PAGE_PRESENT);\n}", "target": 1}
{"code": "static void exif_process_APP12(image_info_type *ImageInfo,\n                               char *buffer, size_t length) {\n  size_t l1, l2=0;\n  if ((l1 = php_strnlen(buffer+2, length-2)) > 0) {\n    exif_iif_add_tag(ImageInfo, SECTION_APP12, \"Company\",\n                     TAG_NONE, TAG_FMT_STRING, l1, buffer+2);\n    if (length > 2+l1+1) {\n      l2 = php_strnlen(buffer+2+l1+1, length-2-l1+1);\n      exif_iif_add_tag(ImageInfo, SECTION_APP12, \"Info\",\n                       TAG_NONE, TAG_FMT_STRING, l2, buffer+2+l1+1);\n    }\n  }\n}", "target": 1}
{"code": "void OutOfMem(size_t size)\n{\n    FatalError(\"Out of memory on allocating %d bytes.\", size);\n}", "target": 0}
{"code": "static int f2fs_mpage_readpages(struct address_space *mapping,\n\t\t\tstruct list_head *pages, struct page *page,\n\t\t\tunsigned nr_pages, bool is_readahead)\n{\n\tstruct bio *bio = NULL;\n\tsector_t last_block_in_bio = 0;\n\tstruct inode *inode = mapping->host;\n\tstruct f2fs_map_blocks map;\n\tint ret = 0;\n\tmap.m_pblk = 0;\n\tmap.m_lblk = 0;\n\tmap.m_len = 0;\n\tmap.m_flags = 0;\n\tmap.m_next_pgofs = NULL;\n\tmap.m_next_extent = NULL;\n\tmap.m_seg_type = NO_CHECK_TYPE;\n\tmap.m_may_create = false;\n\tfor (; nr_pages; nr_pages--) {\n\t\tif (pages) {\n\t\t\tpage = list_last_entry(pages, struct page, lru);\n\t\t\tprefetchw(&page->flags);\n\t\t\tlist_del(&page->lru);\n\t\t\tif (add_to_page_cache_lru(page, mapping,\n\t\t\t\t\t\t  page->index,\n\t\t\t\t\t\t  readahead_gfp_mask(mapping)))\n\t\t\t\tgoto next_page;\n\t\t}\n\t\tret = f2fs_read_single_page(inode, page, nr_pages, &map, &bio,\n\t\t\t\t\t&last_block_in_bio, is_readahead);\n\t\tif (ret) {\n\t\t\tSetPageError(page);\n\t\t\tzero_user_segment(page, 0, PAGE_SIZE);\n\t\t\tunlock_page(page);\n\t\t}\nnext_page:\n\t\tif (pages)\n\t\t\tput_page(page);\n\t}\n\tBUG_ON(pages && !list_empty(pages));\n\tif (bio)\n\t\t__submit_bio(F2FS_I_SB(inode), bio, DATA);\n\treturn pages ? 0 : ret;\n}", "target": 1}
{"code": "void _WM_do_control_channel_sound_off(struct _mdi *mdi,\n                                      struct _event_data *data) {\n    struct _note *note_data = mdi->note;\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n    if (note_data) {\n        do {\n            if ((note_data->noteid >> 8) == ch) {\n                note_data->active = 0;\n                if (note_data->replay) {\n                    note_data->replay = NULL;\n                }\n            }\n            note_data = note_data->next;\n        } while (note_data);\n    }\n}", "target": 0}
{"code": "vhost_user_check_and_alloc_queue_pair(struct virtio_net *dev, VhostUserMsg *msg)\n{\n\tuint16_t vring_idx;\n\tswitch (msg->request.master) {\n\tcase VHOST_USER_SET_VRING_KICK:\n\tcase VHOST_USER_SET_VRING_CALL:\n\tcase VHOST_USER_SET_VRING_ERR:\n\t\tvring_idx = msg->payload.u64 & VHOST_USER_VRING_IDX_MASK;\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_NUM:\n\tcase VHOST_USER_SET_VRING_BASE:\n\tcase VHOST_USER_SET_VRING_ENABLE:\n\t\tvring_idx = msg->payload.state.index;\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_ADDR:\n\t\tvring_idx = msg->payload.addr.index;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tif (vring_idx >= VHOST_MAX_VRING) {\n\t\tRTE_LOG(ERR, VHOST_CONFIG,\n\t\t\t\"invalid vring index: %u\\n\", vring_idx);\n\t\treturn -1;\n\t}\n\tif (dev->virtqueue[vring_idx])\n\t\treturn 0;\n\treturn alloc_vring_queue(dev, vring_idx);\n}", "target": 0}
{"code": "sctp_disposition_t sctp_sf_cookie_wait_icmp_abort(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\treturn sctp_stop_t1_and_abort(net, commands, SCTP_ERROR_NO_ERROR,\n\t\t\t\t      ENOPROTOOPT, asoc,\n\t\t\t\t      (struct sctp_transport *)arg);\n}", "target": 0}
{"code": "njs_function_frame_save(njs_vm_t *vm, njs_frame_t *frame, u_char *pc)\n{\n    size_t              value_count, n;\n    njs_value_t         *start, *end, *p, **new, *value, **local;\n    njs_function_t      *function;\n    njs_native_frame_t  *active, *native;\n    *frame = *vm->active_frame;\n    frame->previous_active_frame = NULL;\n    native = &frame->native;\n    native->size = 0;\n    native->free = NULL;\n    native->free_size = 0;\n    active = &vm->active_frame->native;\n    value_count = njs_function_frame_value_count(active);\n    function = active->function;\n    new = (njs_value_t **) ((u_char *) native + NJS_FRAME_SIZE);\n    value = (njs_value_t *) (new + value_count\n                             + function->u.lambda->temp);\n    native->arguments = value;\n    native->arguments_offset = value + (function->args_offset - 1);\n    native->local = new + njs_function_frame_args_count(active);\n    native->temp = new + value_count;\n    native->pc = pc;\n    start = njs_function_frame_values(active, &end);\n    p = native->arguments;\n    while (start < end) {\n        *p = *start++;\n        *new++ = p++;\n    }\n    p = native->arguments;\n    local = native->local + function->args_offset;\n    for (n = 0; n < function->args_count; n++) {\n        if (!njs_is_valid(p)) {\n            njs_set_undefined(p);\n        }\n        *local++ = p++;\n    }\n    return NJS_OK;\n}", "target": 0}
{"code": "static int pppol2tp_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t len,\n\t\t\t    int flags)\n{\n\tint err;\n\tstruct sk_buff *skb;\n\tstruct sock *sk = sock->sk;\n\terr = -EIO;\n\tif (sk->sk_state & PPPOX_BOUND)\n\t\tgoto end;\n\tmsg->msg_namelen = 0;\n\terr = 0;\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\tgoto end;\n\tif (len > skb->len)\n\t\tlen = skb->len;\n\telse if (len < skb->len)\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, len);\n\tif (likely(err == 0))\n\t\terr = len;\n\tkfree_skb(skb);\nend:\n\treturn err;\n}", "target": 1}
{"code": "static int orinoco_ioctl_setwap(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tstruct sockaddr *ap_addr,\n\t\t\t\tchar *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint err = -EINPROGRESS;\t\t\n\tunsigned long flags;\n\tstatic const u8 off_addr[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\n\tstatic const u8 any_addr[] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\tif (memcmp(&ap_addr->sa_data, off_addr, ETH_ALEN) == 0 ||\n\t    memcmp(&ap_addr->sa_data, any_addr, ETH_ALEN) == 0) {\n\t\tpriv->bssid_fixed = 0;\n\t\tmemset(priv->desired_bssid, 0, ETH_ALEN);\n\t\tif (ap_addr->sa_data[0] == 0) {\n\t\t\t__orinoco_hw_set_wap(priv);\n\t\t\terr = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\tif (priv->firmware_type == FIRMWARE_TYPE_AGERE) {\n\t\tprintk(KERN_WARNING \"%s: Lucent/Agere firmware doesn't \"\n\t\t       \"support manual roaming\\n\",\n\t\t       dev->name);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tif (priv->iw_mode != NL80211_IFTYPE_STATION) {\n\t\tprintk(KERN_WARNING \"%s: Manual roaming supported only in \"\n\t\t       \"managed mode\\n\", dev->name);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tif (priv->firmware_type == FIRMWARE_TYPE_INTERSIL &&\n\t    strlen(priv->desired_essid) == 0) {\n\t\tprintk(KERN_WARNING \"%s: Desired ESSID must be set for \"\n\t\t       \"manual roaming\\n\", dev->name);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tpriv->bssid_fixed = 1;\n\tmemcpy(priv->desired_bssid, &ap_addr->sa_data, ETH_ALEN);\n out:\n\torinoco_unlock(priv, &flags);\n\treturn err;\n}", "target": 0}
{"code": "int fpm_unix_resolve_socket_premissions(struct fpm_worker_pool_s *wp) \n{\n\tstruct fpm_worker_pool_config_s *c = wp->config;\n\twp->socket_uid = -1;\n\twp->socket_gid = -1;\n\twp->socket_mode = 0666;\n\tif (!c) {\n\t\treturn 0;\n\t}\n\tif (c->listen_owner && *c->listen_owner) {\n\t\tstruct passwd *pwd;\n\t\tpwd = getpwnam(c->listen_owner);\n\t\tif (!pwd) {\n\t\t\tzlog(ZLOG_SYSERROR, \"[pool %s] cannot get uid for user '%s'\", wp->config->name, c->listen_owner);\n\t\t\treturn -1;\n\t\t}\n\t\twp->socket_uid = pwd->pw_uid;\n\t\twp->socket_gid = pwd->pw_gid;\n\t}\n\tif (c->listen_group && *c->listen_group) {\n\t\tstruct group *grp;\n\t\tgrp = getgrnam(c->listen_group);\n\t\tif (!grp) {\n\t\t\tzlog(ZLOG_SYSERROR, \"[pool %s] cannot get gid for group '%s'\", wp->config->name, c->listen_group);\n\t\t\treturn -1;\n\t\t}\n\t\twp->socket_gid = grp->gr_gid;\n\t}\n\tif (c->listen_mode && *c->listen_mode) {\n\t\twp->socket_mode = strtoul(c->listen_mode, 0, 8);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "gen_hash(codegen_scope *s, node *tree, int val, int limit)\n{\n  int slimit = GEN_VAL_STACK_MAX;\n  if (cursp() >= GEN_LIT_ARY_MAX) slimit = INT16_MAX;\n  int len = 0;\n  mrb_bool update = FALSE;\n  while (tree) {\n    if (nint(tree->car->car->car) == NODE_KW_REST_ARGS) {\n      if (len > 0) {\n        pop_n(len*2);\n        if (!update) {\n          genop_2(s, OP_HASH, cursp(), len);\n        }\n        else {\n          pop();\n          genop_2(s, OP_HASHADD, cursp(), len);\n        }\n        push();\n      }\n      codegen(s, tree->car->cdr, val);\n      if (len > 0 || update) {\n        pop(); pop();\n        genop_1(s, OP_HASHCAT, cursp());\n        push();\n      }\n      update = TRUE;\n      len = 0;\n    }\n    else {\n      codegen(s, tree->car->car, val);\n      codegen(s, tree->car->cdr, val);\n      len++;\n    }\n    tree = tree->cdr;\n    if (val && cursp() >= slimit) {\n      pop_n(len*2);\n      if (!update) {\n        genop_2(s, OP_HASH, cursp(), len);\n      }\n      else {\n        pop();\n        genop_2(s, OP_HASHADD, cursp(), len);\n      }\n      push();\n      update = TRUE;\n      len = 0;\n    }\n  }\n  if (update) {\n    if (val && len > 0) {\n      pop_n(len*2+1);\n      genop_2(s, OP_HASHADD, cursp(), len);\n      push();\n    }\n    return -1;                  \n  }\n  return len;\n}", "target": 1}
{"code": "check_offset(char *memory, int total_size, char *name, void *offset, int size)\n{\n\tint need_size = (int) ((char *) offset - memory + size);\n\tif (need_size < 0 || need_size > total_size) {\n\t\twarn(_(\"%s: premature end\"), name);\n\t\treturn false;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "static unsigned int xdr_set_page_base(struct xdr_stream *xdr,\n\t\t\t\t      unsigned int base, unsigned int len)\n{\n\tunsigned int pgnr;\n\tunsigned int maxlen;\n\tunsigned int pgoff;\n\tunsigned int pgend;\n\tvoid *kaddr;\n\tmaxlen = xdr->buf->page_len;\n\tif (base >= maxlen) {\n\t\tbase = maxlen;\n\t\tmaxlen = 0;\n\t} else\n\t\tmaxlen -= base;\n\tif (len > maxlen)\n\t\tlen = maxlen;\n\txdr_stream_page_set_pos(xdr, base);\n\tbase += xdr->buf->page_base;\n\tpgnr = base >> PAGE_SHIFT;\n\txdr->page_ptr = &xdr->buf->pages[pgnr];\n\tkaddr = page_address(*xdr->page_ptr);\n\tpgoff = base & ~PAGE_MASK;\n\txdr->p = (__be32*)(kaddr + pgoff);\n\tpgend = pgoff + len;\n\tif (pgend > PAGE_SIZE)\n\t\tpgend = PAGE_SIZE;\n\txdr->end = (__be32*)(kaddr + pgend);\n\txdr->iov = NULL;\n\treturn len;\n}", "target": 1}
{"code": "elg_get_nbits (gcry_sexp_t parms)\n{\n  gcry_sexp_t l1;\n  gcry_mpi_t p;\n  unsigned int nbits;\n  l1 = sexp_find_token (parms, \"p\", 1);\n  if (!l1)\n    return 0; \n  p= sexp_nth_mpi (l1, 1, GCRYMPI_FMT_USG);\n  sexp_release (l1);\n  nbits = p? mpi_get_nbits (p) : 0;\n  _gcry_mpi_release (p);\n  return nbits;\n}", "target": 0}
{"code": "asmlinkage long sys_oabi_semtimedop(int semid,\n\t\t\t\t    struct oabi_sembuf __user *tsops,\n\t\t\t\t    unsigned nsops,\n\t\t\t\t    const struct timespec __user *timeout)\n{\n\tstruct sembuf *sops;\n\tstruct timespec local_timeout;\n\tlong err;\n\tint i;\n\tif (nsops < 1)\n\t\treturn -EINVAL;\n\tsops = kmalloc(sizeof(*sops) * nsops, GFP_KERNEL);\n\tif (!sops)\n\t\treturn -ENOMEM;\n\terr = 0;\n\tfor (i = 0; i < nsops; i++) {\n\t\t__get_user_error(sops[i].sem_num, &tsops->sem_num, err);\n\t\t__get_user_error(sops[i].sem_op,  &tsops->sem_op,  err);\n\t\t__get_user_error(sops[i].sem_flg, &tsops->sem_flg, err);\n\t\ttsops++;\n\t}\n\tif (timeout) {\n\t\terr |= copy_from_user(&local_timeout, timeout, sizeof(*timeout));\n\t\ttimeout = &local_timeout;\n\t}\n\tif (err) {\n\t\terr = -EFAULT;\n\t} else {\n\t\tmm_segment_t fs = get_fs();\n\t\tset_fs(KERNEL_DS);\n\t\terr = sys_semtimedop(semid, sops, nsops, timeout);\n\t\tset_fs(fs);\n\t}\n\tkfree(sops);\n\treturn err;\n}", "target": 1}
{"code": "void prefetch_table(const void *tab, size_t len)\n{\n  const volatile byte *vtab = tab;\n  size_t i;\n  for (i = 0; i < len; i += 8 * 32)\n    {\n      (void)vtab[i + 0 * 32];\n      (void)vtab[i + 1 * 32];\n      (void)vtab[i + 2 * 32];\n      (void)vtab[i + 3 * 32];\n      (void)vtab[i + 4 * 32];\n      (void)vtab[i + 5 * 32];\n      (void)vtab[i + 6 * 32];\n      (void)vtab[i + 7 * 32];\n    }\n  (void)vtab[len - 1];\n}", "target": 1}
{"code": "static int _nfs4_do_open_reclaim(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs_delegation *delegation;\n\tstruct nfs4_opendata *opendata;\n\tint delegation_type = 0;\n\tint status;\n\topendata = nfs4_open_recoverdata_alloc(ctx, state);\n\tif (IS_ERR(opendata))\n\t\treturn PTR_ERR(opendata);\n\topendata->o_arg.claim = NFS4_OPEN_CLAIM_PREVIOUS;\n\topendata->o_arg.fh = NFS_FH(state->inode);\n\trcu_read_lock();\n\tdelegation = rcu_dereference(NFS_I(state->inode)->delegation);\n\tif (delegation != NULL && test_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags) != 0)\n\t\tdelegation_type = delegation->type;\n\trcu_read_unlock();\n\topendata->o_arg.u.delegation_type = delegation_type;\n\tstatus = nfs4_open_recover(opendata, state);\n\tnfs4_opendata_put(opendata);\n\treturn status;\n}", "target": 1}
{"code": "SSL_SESSION *SSL_SESSION_dup(const SSL_SESSION *src)\n{\n    return ssl_session_dup(src, 1);\n}", "target": 1}
{"code": "static int do_devinfo_ioctl(struct comedi_device *dev,\n\t\t\t    struct comedi_devinfo __user *arg,\n\t\t\t    struct file *file)\n{\n\tstruct comedi_devinfo devinfo;\n\tconst unsigned minor = iminor(file->f_dentry->d_inode);\n\tstruct comedi_device_file_info *dev_file_info =\n\t    comedi_get_device_file_info(minor);\n\tstruct comedi_subdevice *read_subdev =\n\t    comedi_get_read_subdevice(dev_file_info);\n\tstruct comedi_subdevice *write_subdev =\n\t    comedi_get_write_subdevice(dev_file_info);\n\tmemset(&devinfo, 0, sizeof(devinfo));\n\tdevinfo.version_code = COMEDI_VERSION_CODE;\n\tdevinfo.n_subdevs = dev->n_subdevices;\n\tmemcpy(devinfo.driver_name, dev->driver->driver_name, COMEDI_NAMELEN);\n\tmemcpy(devinfo.board_name, dev->board_name, COMEDI_NAMELEN);\n\tif (read_subdev)\n\t\tdevinfo.read_subdevice = read_subdev - dev->subdevices;\n\telse\n\t\tdevinfo.read_subdevice = -1;\n\tif (write_subdev)\n\t\tdevinfo.write_subdevice = write_subdev - dev->subdevices;\n\telse\n\t\tdevinfo.write_subdevice = -1;\n\tif (copy_to_user(arg, &devinfo, sizeof(struct comedi_devinfo)))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1}
{"code": "void preempt_notifier_dec(void)\n{\n\tstatic_key_slow_dec(&preempt_notifier_key);\n}", "target": 0}
{"code": "  bool operator!=(const LowerCaseString& rhs) const { return string_ != rhs.string_; }", "target": 0}
{"code": "RecordCloseDown(ExtensionEntry * extEntry)\n{\n    DeleteCallback(&ClientStateCallback, RecordAClientStateChange, NULL);\n}                               ", "target": 0}
{"code": "ppp_input(struct ppp_channel *chan, struct sk_buff *skb)\n{\n\tstruct channel *pch = chan->ppp;\n\tint proto;\n\tif (!pch || skb->len == 0) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\tproto = PPP_PROTO(skb);\n\tread_lock_bh(&pch->upl);\n\tif (!pch->ppp || proto >= 0xc000 || proto == PPP_CCPFRAG) {\n\t\tskb_queue_tail(&pch->file.rq, skb);\n\t\twhile (pch->file.rq.qlen > PPP_MAX_RQLEN\n\t\t       && (skb = skb_dequeue(&pch->file.rq)))\n\t\t\tkfree_skb(skb);\n\t\twake_up_interruptible(&pch->file.rwait);\n\t} else {\n\t\tppp_do_recv(pch->ppp, skb, pch);\n\t}\n\tread_unlock_bh(&pch->upl);\n}", "target": 0}
{"code": "int FrameLoader::numPendingOrLoadingRequests(bool recurse) const\n{\n    if (!recurse)\n        return m_frame->document()->fetcher()->requestCount();\n    int count = 0;\n    for (Frame* frame = m_frame; frame; frame = frame->tree()->traverseNext(m_frame))\n        count += frame->document()->fetcher()->requestCount();\n    return count;\n}", "target": 0}
{"code": "static int emulator_intercept(struct x86_emulate_ctxt *ctxt,\n\t\t\t      struct x86_instruction_info *info,\n\t\t\t      enum x86_intercept_stage stage)\n{\n\treturn kvm_x86_ops->check_intercept(emul_to_vcpu(ctxt), info, stage);\n}", "target": 0}
{"code": "void sock_init_data(struct socket *sock, struct sock *sk)\n{\n\tskb_queue_head_init(&sk->sk_receive_queue);\n\tskb_queue_head_init(&sk->sk_write_queue);\n\tskb_queue_head_init(&sk->sk_error_queue);\n#ifdef CONFIG_NET_DMA\n\tskb_queue_head_init(&sk->sk_async_wait_queue);\n#endif\n\tsk->sk_send_head\t=\tNULL;\n\tinit_timer(&sk->sk_timer);\n\tsk->sk_allocation\t=\tGFP_KERNEL;\n\tsk->sk_rcvbuf\t\t=\tsysctl_rmem_default;\n\tsk->sk_sndbuf\t\t=\tsysctl_wmem_default;\n\tsk->sk_state\t\t=\tTCP_CLOSE;\n\tsk_set_socket(sk, sock);\n\tsock_set_flag(sk, SOCK_ZAPPED);\n\tif (sock) {\n\t\tsk->sk_type\t=\tsock->type;\n\t\tsk->sk_wq\t=\tsock->wq;\n\t\tsock->sk\t=\tsk;\n\t} else\n\t\tsk->sk_wq\t=\tNULL;\n\tspin_lock_init(&sk->sk_dst_lock);\n\trwlock_init(&sk->sk_callback_lock);\n\tlockdep_set_class_and_name(&sk->sk_callback_lock,\n\t\t\taf_callback_keys + sk->sk_family,\n\t\t\taf_family_clock_key_strings[sk->sk_family]);\n\tsk->sk_state_change\t=\tsock_def_wakeup;\n\tsk->sk_data_ready\t=\tsock_def_readable;\n\tsk->sk_write_space\t=\tsock_def_write_space;\n\tsk->sk_error_report\t=\tsock_def_error_report;\n\tsk->sk_destruct\t\t=\tsock_def_destruct;\n\tsk->sk_sndmsg_page\t=\tNULL;\n\tsk->sk_sndmsg_off\t=\t0;\n\tsk->sk_peek_off\t\t=\t-1;\n\tsk->sk_peer_pid \t=\tNULL;\n\tsk->sk_peer_cred\t=\tNULL;\n\tsk->sk_write_pending\t=\t0;\n\tsk->sk_rcvlowat\t\t=\t1;\n\tsk->sk_rcvtimeo\t\t=\tMAX_SCHEDULE_TIMEOUT;\n\tsk->sk_sndtimeo\t\t=\tMAX_SCHEDULE_TIMEOUT;\n\tsk->sk_stamp = ktime_set(-1L, 0);\n\tsmp_wmb();\n\tatomic_set(&sk->sk_refcnt, 1);\n\tatomic_set(&sk->sk_drops, 0);\n}", "target": 0}
{"code": "static struct nft_stats __percpu *nft_stats_alloc(const struct nlattr *attr)\n{\n\tstruct nlattr *tb[NFTA_COUNTER_MAX+1];\n\tstruct nft_stats __percpu *newstats;\n\tstruct nft_stats *stats;\n\tint err;\n\terr = nla_parse_nested(tb, NFTA_COUNTER_MAX, attr, nft_counter_policy);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\tif (!tb[NFTA_COUNTER_BYTES] || !tb[NFTA_COUNTER_PACKETS])\n\t\treturn ERR_PTR(-EINVAL);\n\tnewstats = netdev_alloc_pcpu_stats(struct nft_stats);\n\tif (newstats == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tstats = this_cpu_ptr(newstats);\n\tstats->bytes = be64_to_cpu(nla_get_be64(tb[NFTA_COUNTER_BYTES]));\n\tstats->pkts = be64_to_cpu(nla_get_be64(tb[NFTA_COUNTER_PACKETS]));\n\treturn newstats;\n}", "target": 0}
{"code": "static void vrend_renderer_init_blit_ctx(struct vrend_blitter_ctx *blit_ctx)\n{\n   struct virgl_gl_ctx_param ctx_params;\n   int i;\n   if (blit_ctx->initialised) {\n      vrend_clicbs->make_current(0, blit_ctx->gl_context);\n      return;\n   }\n   ctx_params.shared = true;\n   ctx_params.major_ver = VREND_GL_VER_MAJOR;\n   ctx_params.minor_ver = VREND_GL_VER_MINOR;\n   blit_ctx->gl_context = vrend_clicbs->create_gl_context(0, &ctx_params);\n   vrend_clicbs->make_current(0, blit_ctx->gl_context);\n   glGenVertexArrays(1, &blit_ctx->vaoid);\n   glGenFramebuffers(1, &blit_ctx->fb_id);\n   glGenBuffers(1, &blit_ctx->vbo_id);\n   blit_build_vs_passthrough(blit_ctx);\n   for (i = 0; i < 4; i++)\n      blit_ctx->vertices[i][0][3] = 1; \n   glBindVertexArray(blit_ctx->vaoid);\n   glBindBuffer(GL_ARRAY_BUFFER, blit_ctx->vbo_id);\n}", "target": 1}
{"code": "GF_Box *mp4s_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGSampleEntryBox, GF_ISOM_BOX_TYPE_MP4S);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\ttmp->internal_type = GF_ISOM_SAMPLE_ENTRY_MP4S;\n\treturn (GF_Box *)tmp;\n}", "target": 1}
{"code": "ikev1_nonce_print(netdissect_options *ndo, u_char tpay _U_,\n\t\t  const struct isakmp_gen *ext,\n\t\t  u_int item_len _U_,\n\t\t  const u_char *ep,\n\t\t  uint32_t phase _U_, uint32_t doi _U_,\n\t\t  uint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_NONCE)));\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" n len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t} else if (1 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!ike_show_somedata(ndo, (const u_char *)(const uint8_t *)(ext + 1), ep))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_NONCE)));\n\treturn NULL;\n}", "target": 1}
{"code": "static void *HttpMultiBufHeaderThreadDataInit(void *data)\n{\n    HttpMultiBufHeaderThreadData *td = SCCalloc(1, sizeof(*td));\n    return td;\n}", "target": 0}
{"code": "u32 h264bsdInitDpb(\n dpbStorage_t *dpb,\n  u32 picSizeInMbs,\n  u32 dpbSize,\n  u32 maxRefFrames,\n  u32 maxFrameNum,\n  u32 noReordering)\n{\n    u32 i;\n    ASSERT(picSizeInMbs);\n    ASSERT(maxRefFrames <= MAX_NUM_REF_PICS);\n    ASSERT(maxRefFrames <= dpbSize);\n     ASSERT(maxFrameNum);\n     ASSERT(dpbSize);\n     dpb->maxLongTermFrameIdx = NO_LONG_TERM_FRAME_INDICES;\n     dpb->maxRefFrames        = MAX(maxRefFrames, 1);\n     if (noReordering)\n        dpb->dpbSize         = dpb->maxRefFrames;\n else\n        dpb->dpbSize         = dpbSize;\n    dpb->maxFrameNum         = maxFrameNum;\n    dpb->noReordering        = noReordering;\n    dpb->fullness            = 0;\n    dpb->numRefFrames        = 0;\n    dpb->prevRefFrameNum     = 0;\n    ALLOCATE(dpb->buffer, MAX_NUM_REF_IDX_L0_ACTIVE + 1, dpbPicture_t);\n if (dpb->buffer == NULL)\n return(MEMORY_ALLOCATION_ERROR);\n    H264SwDecMemset(dpb->buffer, 0,\n (MAX_NUM_REF_IDX_L0_ACTIVE + 1)*sizeof(dpbPicture_t));\n for (i = 0; i < dpb->dpbSize + 1; i++)\n {\n        ALLOCATE(dpb->buffer[i].pAllocatedData, (picSizeInMbs*384 + 32+15), u8);\n if (dpb->buffer[i].pAllocatedData == NULL)\n return(MEMORY_ALLOCATION_ERROR);\n        dpb->buffer[i].data = ALIGN(dpb->buffer[i].pAllocatedData, 16);\n }\n    ALLOCATE(dpb->list, MAX_NUM_REF_IDX_L0_ACTIVE + 1, dpbPicture_t*);\n    ALLOCATE(dpb->outBuf, dpb->dpbSize+1, dpbOutPicture_t);\n if (dpb->list == NULL || dpb->outBuf == NULL)\n return(MEMORY_ALLOCATION_ERROR);\n    H264SwDecMemset(dpb->list, 0,\n ((MAX_NUM_REF_IDX_L0_ACTIVE + 1) * sizeof(dpbPicture_t*)) );\n    dpb->numOut = dpb->outIndex = 0;\n return(HANTRO_OK);\n}", "target": 1}
{"code": "snmp_engine_get(snmp_header_t *header, snmp_varbind_t *varbinds, uint32_t varbinds_length)\n{\n  snmp_mib_resource_t *resource;\n  uint32_t i;\n  for(i = 0; i < varbinds_length; i++) {\n    resource = snmp_mib_find(varbinds[i].oid);\n    if(!resource) {\n      switch(header->version) {\n      case SNMP_VERSION_1:\n        header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n        header->error_index_max_repetitions.error_index = i + 1;\n        break;\n      case SNMP_VERSION_2C:\n        (&varbinds[i])->value_type = SNMP_DATA_TYPE_NO_SUCH_INSTANCE;\n        break;\n      default:\n        header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n        header->error_index_max_repetitions.error_index = 0;\n      }\n    } else {\n      resource->handler(&varbinds[i], resource->oid);\n    }\n  }\n  return 0;\n}", "target": 1}
{"code": "static void virtqueue_map_desc(unsigned int *p_num_sg, hwaddr *addr, struct iovec *iov,\n                               unsigned int max_num_sg, bool is_write,\n                               hwaddr pa, size_t sz)\n{\n    unsigned num_sg = *p_num_sg;\n    assert(num_sg <= max_num_sg);\n    while (sz) {\n        hwaddr len = sz;\n        if (num_sg == max_num_sg) {\n            error_report(\"virtio: too many write descriptors in indirect table\");\n            exit(1);\n        }\n        iov[num_sg].iov_base = cpu_physical_memory_map(pa, &len, is_write);\n        iov[num_sg].iov_len = len;\n        addr[num_sg] = pa;\n        sz -= len;\n        pa += len;\n        num_sg++;\n    }\n    *p_num_sg = num_sg;\n}", "target": 1}
{"code": "static Variant HHVM_FUNCTION(simplexml_import_dom,\n  const Object& node,\n  const String& class_name ) {\n  auto domnode = Native::data<DOMNode>(node);\n  xmlNodePtr nodep = domnode->nodep();\n  if (nodep) {\n    if (nodep->doc == nullptr) {\n      raise_warning(\"Imported Node must have associated Document\");\n      return init_null();\n    }\n    if (nodep->type == XML_DOCUMENT_NODE ||\n        nodep->type == XML_HTML_DOCUMENT_NODE) {\n      nodep = xmlDocGetRootElement((xmlDocPtr) nodep);\n    }\n  }\n  if (nodep && nodep->type == XML_ELEMENT_NODE) {\n    auto cls = class_from_name(class_name, \"simplexml_import_dom\");\n    if (!cls) {\n      return init_null();\n    }\n    Object obj = create_object(cls->nameStr(), Array(), false);\n    auto sxe = Native::data<SimpleXMLElement>(obj.get());\n    sxe->node = libxml_register_node(nodep);\n    return obj;\n  } else {\n    raise_warning(\"Invalid Nodetype to import\");\n    return init_null();\n  }\n  return false;\n}", "target": 1}
{"code": "EntropyParser::EntropyParser(class Frame *frame,class Scan *scan)\n  : JKeeper(scan->EnvironOf()), m_pScan(scan), m_pFrame(frame)\n{\n  m_ucCount = scan->ComponentsInScan();\n  for(volatile UBYTE i = 0;i < m_ucCount && i < 4;i++) {\n    JPG_TRY {\n      m_pComponent[i] = scan->ComponentOf(i);\n    } JPG_CATCH {\n      m_pComponent[i] = NULL;\n    } JPG_ENDTRY;\n  }\n  m_ulRestartInterval   = m_pFrame->TablesOf()->RestartIntervalOf();\n  m_usNextRestartMarker = 0xffd0;\n  m_ulMCUsToGo          = m_ulRestartInterval;\n  m_bSegmentIsValid     = true;\n  m_bScanForDNL         = (m_pFrame->HeightOf() == 0)?true:false;\n  m_bDNLFound           = false;\n}", "target": 1}
{"code": "static inline struct sk_buff *__skb_dequeue(struct sk_buff_head *list)\n{\n\tstruct sk_buff *skb = skb_peek(list);\n\tif (skb)\n\t\t__skb_unlink(skb, list);\n\treturn skb;\n}", "target": 0}
{"code": "  bool AddCallback(GetUsageAndQuotaCallback* callback, bool unlimited) {\n    if (unlimited)\n      unlimited_callbacks_.push_back(callback);\n    else\n      callbacks_.push_back(callback);\n    return (callbacks_.size() + unlimited_callbacks_.size() == 1);\n  }", "target": 0}
{"code": "void unregister_blkdev(unsigned int major, const char *name)\n{\n\tstruct blk_major_name **n;\n\tstruct blk_major_name *p = NULL;\n\tint index = major_to_index(major);\n\tmutex_lock(&block_class_lock);\n\tfor (n = &major_names[index]; *n; n = &(*n)->next)\n\t\tif ((*n)->major == major)\n\t\t\tbreak;\n\tif (!*n || strcmp((*n)->name, name)) {\n\t\tWARN_ON(1);\n\t} else {\n\t\tp = *n;\n\t\t*n = p->next;\n\t}\n\tmutex_unlock(&block_class_lock);\n\tkfree(p);\n}", "target": 0}
{"code": "create_tls_session(int csock, int type  )\n{\n    int rc = 0;\n    gnutls_session *session = gnutls_malloc(sizeof(gnutls_session));\n    gnutls_init(session, type);\n#  ifdef HAVE_GNUTLS_PRIORITY_SET_DIRECT\n    gnutls_priority_set_direct(*session, \"NORMAL:+ANON-DH\", NULL);\n#  else\n    gnutls_set_default_priority(*session);\n    gnutls_kx_set_priority(*session, tls_kx_order);\n#  endif\n    gnutls_transport_set_ptr(*session, (gnutls_transport_ptr) GINT_TO_POINTER(csock));\n    switch (type) {\n        case GNUTLS_SERVER:\n            gnutls_credentials_set(*session, GNUTLS_CRD_ANON, anon_cred_s);\n            break;\n        case GNUTLS_CLIENT:\n            gnutls_credentials_set(*session, GNUTLS_CRD_ANON, anon_cred_c);\n            break;\n    }\n    do {\n        rc = gnutls_handshake(*session);\n    } while (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN);\n    if (rc < 0) {\n        crm_err(\"Handshake failed: %s\", gnutls_strerror(rc));\n        gnutls_deinit(*session);\n        gnutls_free(session);\n        return NULL;\n    }\n    return session;\n}", "target": 1}
{"code": "setup_connection (GsmXSMPClient *client)\n{\n        GIOChannel    *channel;\n        int            fd;\n        g_debug (\"GsmXSMPClient: Setting up new connection\");\n        fd = IceConnectionNumber (client->priv->ice_connection);\n        fcntl (fd, F_SETFD, fcntl (fd, F_GETFD, 0) | FD_CLOEXEC);\n        channel = g_io_channel_unix_new (fd);\n        client->priv->watch_id = g_io_add_watch (channel,\n                                                 G_IO_IN | G_IO_ERR,\n                                                 (GIOFunc)client_iochannel_watch,\n                                                 client);\n        g_io_channel_unref (channel);\n        client->priv->protocol_timeout = g_timeout_add_seconds (5,\n                                                                (GSourceFunc)_client_protocol_timeout,\n                                                                client);\n        set_description (client);\n        g_debug (\"GsmXSMPClient: New client '%s'\", client->priv->description);\n}", "target": 1}
{"code": "static int stimer_set_count(struct kvm_vcpu_hv_stimer *stimer, u64 count,\n\t\t\t    bool host)\n{\n\tstruct kvm_vcpu *vcpu = hv_stimer_to_vcpu(stimer);\n\tstruct kvm_vcpu_hv_synic *synic = to_hv_synic(vcpu);\n\tif (!synic->active && !host)\n\t\treturn 1;\n\ttrace_kvm_hv_stimer_set_count(hv_stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t      stimer->index, count, host);\n\tstimer_cleanup(stimer);\n\tstimer->count = count;\n\tif (stimer->count == 0)\n\t\tstimer->config.enable = 0;\n\telse if (stimer->config.auto_enable)\n\t\tstimer->config.enable = 1;\n\tif (stimer->config.enable)\n\t\tstimer_mark_pending(stimer, false);\n\treturn 0;\n}", "target": 1}
{"code": "static void expire_cfs_rq_runtime(struct cfs_rq *cfs_rq)\n{\n\tstruct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(cfs_rq->tg);\n\tif (likely((s64)(rq_clock(rq_of(cfs_rq)) - cfs_rq->runtime_expires) < 0))\n\t\treturn;\n\tif (cfs_rq->runtime_remaining < 0)\n\t\treturn;\n\tif (cfs_rq->expires_seq == cfs_b->expires_seq) {\n\t\tcfs_rq->runtime_expires += TICK_NSEC;\n\t} else {\n\t\tcfs_rq->runtime_remaining = 0;\n\t}\n}", "target": 1}
{"code": "spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n\t\t       int iov_count)\n{\n    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,\n\t\t\t   iov_count);\n}", "target": 1}
{"code": "void RemoteFsDevice::saveProperties(const DeviceOptions &newOpts, const Details &nd)\n{\n    bool connected=isConnected();\n    if (configured && (!connected || opts==newOpts) && (connected || details==nd)) {\n        return;\n    }\n    bool isLocal=details.isLocalFile();\n    if (connected) {\n        if (!configured) {\n            details.configured=configured=true;\n            details.save();\n        }\n        if (opts.useCache!=newOpts.useCache) {\n            if (opts.useCache) {\n                saveCache();\n            } else if (opts.useCache && !newOpts.useCache) {\n                removeCache();\n            }\n        }\n        opts=newOpts;\n        writeOpts(settingsFileName(), opts, true);\n    }\n    if (!connected || isLocal) {\n        Details newDetails=nd;\n        Details oldDetails=details;\n        bool newName=!oldDetails.name.isEmpty() && oldDetails.name!=newDetails.name;\n        bool newDir=oldDetails.url.path()!=newDetails.url.path();\n        if (isLocal && newDir && opts.useCache) {\n            removeCache();\n        }\n        details=newDetails;\n        details.configured=configured=true;\n        details.save();\n        if (newName) {\n            if (!details.isLocalFile()) {\n                QString oldMount=mountPoint(oldDetails, false);\n                if (!oldMount.isEmpty() && QDir(oldMount).exists()) {\n                    ::rmdir(QFile::encodeName(oldMount).constData());\n                }\n            }\n            setData(details.name);\n            renamed(oldDetails.name, details.name);\n            deviceId=createUdi(details.name);\n            emit udiChanged();\n            m_itemData=details.name;\n            setStatusMessage(QString());\n        }\n        if (isLocal && newDir && scanned) {\n            rescan(true);\n        }\n    }\n    emit configurationChanged();\n}", "target": 0}
{"code": "sort_page_names (gconstpointer a,\n                 gconstpointer b)\n{\n\tconst char *name_1, *name_2;\n\tgchar *key_1, *key_2;\n\tgboolean sort_last_1, sort_last_2;\n\tint compare;\n\tname_1 = * (const char **) a;\n\tname_2 = * (const char **) b;\n\t#define SORT_LAST_CHAR1 '.'\n\t#define SORT_LAST_CHAR2 '#'\n\tsort_last_1 = name_1[0] == SORT_LAST_CHAR1 || name_1[0] == SORT_LAST_CHAR2;\n\tsort_last_2 = name_2[0] == SORT_LAST_CHAR1 || name_2[0] == SORT_LAST_CHAR2;\n\t#undef SORT_LAST_CHAR1\n\t#undef SORT_LAST_CHAR2\n\tif (sort_last_1 && !sort_last_2)\n\t{\n\t\tcompare = +1;\n\t}\n\telse if (!sort_last_1 && sort_last_2)\n\t{\n\t\tcompare = -1;\n\t}\n\telse\n\t{\n\t\tkey_1 = g_utf8_collate_key_for_filename (name_1, -1);\n\t\tkey_2 = g_utf8_collate_key_for_filename (name_2, -1);\n\t\tcompare = strcmp (key_1, key_2);\n\t\tg_free (key_1);\n\t\tg_free (key_2);\n\t}\n\treturn compare;\n}", "target": 1}
{"code": "static enum count_type __read_io_type(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tif (mapping) {\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\t\tif (inode->i_ino == F2FS_META_INO(sbi))\n\t\t\treturn F2FS_RD_META;\n\t\tif (inode->i_ino == F2FS_NODE_INO(sbi))\n\t\t\treturn F2FS_RD_NODE;\n\t}\n\treturn F2FS_RD_DATA;\n}", "target": 1}
{"code": "perf_event_set_output(struct perf_event *event, struct perf_event *output_event)\n{\n\tstruct ring_buffer *rb = NULL, *old_rb = NULL;\n\tint ret = -EINVAL;\n\tif (!output_event)\n\t\tgoto set;\n\tif (event == output_event)\n\t\tgoto out;\n\tif (output_event->cpu != event->cpu)\n\t\tgoto out;\n\tif (output_event->cpu == -1 && output_event->ctx != event->ctx)\n\t\tgoto out;\nset:\n\tmutex_lock(&event->mmap_mutex);\n\tif (atomic_read(&event->mmap_count))\n\t\tgoto unlock;\n\tif (output_event) {\n\t\trb = ring_buffer_get(output_event);\n\t\tif (!rb)\n\t\t\tgoto unlock;\n\t}\n\told_rb = event->rb;\n\trcu_assign_pointer(event->rb, rb);\n\tif (old_rb)\n\t\tring_buffer_detach(event, old_rb);\n\tret = 0;\nunlock:\n\tmutex_unlock(&event->mmap_mutex);\n\tif (old_rb)\n\t\tring_buffer_put(old_rb);\nout:\n\treturn ret;\n}", "target": 0}
{"code": "scrypt_SHA256_Final(unsigned char digest[32], struct SHA256_CTX * ctx)\n{\n  SHA256_Pad(ctx);\n  be32enc_vect(digest, ctx->state, 32);\n  memset((void *)ctx, 0, sizeof(*ctx));\n}", "target": 1}
{"code": "_gnutls_x509_encode_and_copy_PKI_params(ASN1_TYPE dst,\n\t\t\t\t\tconst char *dst_name,\n\t\t\t\t\tgnutls_pk_algorithm_t\n\t\t\t\t\tpk_algorithm,\n\t\t\t\t\tgnutls_pk_params_st * params)\n{\n\tconst char *pk;\n\tgnutls_datum_t der = { NULL, 0 };\n\tint result;\n\tchar name[128];\n\tpk = _gnutls_x509_pk_to_oid(pk_algorithm);\n\tif (pk == NULL) {\n\t\tgnutls_assert();\n\t\treturn GNUTLS_E_UNKNOWN_PK_ALGORITHM;\n\t}\n\t_asnstr_append_name(name, sizeof(name), dst_name,\n\t\t\t    \".algorithm.algorithm\");\n\tresult = asn1_write_value(dst, name, pk, 1);\n\tif (result != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\treturn _gnutls_asn2err(result);\n\t}\n\tresult =\n\t    _gnutls_x509_write_pubkey_params(pk_algorithm, params, &der);\n\tif (result < 0) {\n\t\tgnutls_assert();\n\t\treturn result;\n\t}\n\t_asnstr_append_name(name, sizeof(name), dst_name,\n\t\t\t    \".algorithm.parameters\");\n\tresult = asn1_write_value(dst, name, der.data, der.size);\n\t_gnutls_free_datum(&der);\n\tif (result != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\treturn _gnutls_asn2err(result);\n\t}\n\tresult = _gnutls_x509_write_pubkey(pk_algorithm, params, &der);\n\tif (result < 0) {\n\t\tgnutls_assert();\n\t\treturn result;\n\t}\n\t_asnstr_append_name(name, sizeof(name), dst_name,\n\t\t\t    \".subjectPublicKey\");\n\tresult = asn1_write_value(dst, name, der.data, der.size * 8);\n\t_gnutls_free_datum(&der);\n\tif (result != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\treturn _gnutls_asn2err(result);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void device_init()\n{\n    hw_init(LOW_FREQUENCY);\n    if (! tsc_sensor_exists())\n    {\n        _NFC_status = nfc_init();\n    }\n    if (_NFC_status == NFC_IS_ACTIVE)\n    {\n        printf1(TAG_NFC, \"Have NFC\\r\\n\");\n        isLowFreq = 1;\n        IS_BUTTON_PRESSED = is_physical_button_pressed;\n    }\n    else\n    {\n        printf1(TAG_NFC, \"Have NO NFC\\r\\n\");\n        hw_init(HIGH_FREQUENCY);\n        isLowFreq = 0;\n        device_init_button();\n    }\n    usbhid_init();\n    ctaphid_init();\n    ctap_init();\n    device_migrate();\n#if BOOT_TO_DFU\n    flash_option_bytes_init(1);\n#else\n    flash_option_bytes_init(0);\n#endif\n}", "target": 1}
{"code": "unsigned long perf_instruction_pointer(struct pt_regs *regs)\n{\n\tbool use_siar = regs_use_siar(regs);\n\tunsigned long siar = mfspr(SPRN_SIAR);\n\tif (ppmu->flags & PPMU_P10_DD1) {\n\t\tif (siar)\n\t\t\treturn siar;\n\t\telse\n\t\t\treturn regs->nip;\n\t} else if (use_siar && siar_valid(regs))\n\t\treturn mfspr(SPRN_SIAR) + perf_ip_adjust(regs);\n\telse if (use_siar)\n\t\treturn 0;\t\t\n\telse\n\t\treturn regs->nip;\n}", "target": 1}
{"code": "static double util_pointsize( wmfAPI* API, wmfFont* font, char* str, double font_height, ExceptionInfo *exception)\n{\n  wmf_magick_t\n    *ddata = WMF_MAGICK_GetData(API);\n  Image\n    *image = ddata->image;\n  TypeMetric\n    metrics;\n  DrawInfo\n    *draw_info;\n  double\n    pointsize = 0;\n  draw_info=ddata->draw_info;\n  if (draw_info == (const DrawInfo *) NULL)\n    return 0;\n  draw_info->font=WMF_FONT_PSNAME(font);\n  draw_info->pointsize=font_height;\n  draw_info->text=str;\n  if (GetTypeMetrics(image, draw_info, &metrics, exception) != MagickFalse)\n    {\n      if (strlen(str) == 1)\n        {\n          pointsize = (font_height *\n                       ( font_height / (metrics.ascent + fabs(metrics.descent))));\n          draw_info->pointsize = pointsize;\n          if (GetTypeMetrics(image, draw_info, &metrics, exception) != MagickFalse)\n            pointsize *= (font_height / ( metrics.ascent + fabs(metrics.descent)));\n        }\n      else\n        {\n          pointsize = (font_height * (font_height / (metrics.height)));\n          draw_info->pointsize = pointsize;\n          if (GetTypeMetrics(image, draw_info, &metrics, exception) != MagickFalse)\n            pointsize *= (font_height / metrics.height);\n        }\n#if 0\n      draw_info.pointsize = pointsize;\n      if (GetTypeMetrics(image, &draw_info, &metrics, exception) != MagickFalse)\n        pointsize *= (font_height / (metrics.ascent + fabs(metrics.descent)));\n      pointsize *= 1.114286; \n#endif\n    }\n  draw_info->font=NULL;\n  draw_info->text=NULL;\n#if 0\n  printf(\"String    = %s\\n\", str);\n  printf(\"Font      = %s\\n\", WMF_FONT_PSNAME(font));\n  printf(\"lfHeight  = %g\\n\", font_height);\n  printf(\"bounds    = %g,%g %g,%g\\n\", metrics.bounds.x1, metrics.bounds.y1,\n         metrics.bounds.x2,metrics.bounds.y2);\n  printf(\"ascent    = %g\\n\", metrics.ascent);\n  printf(\"descent   = %g\\n\", metrics.descent);\n  printf(\"height    = %g\\n\", metrics.height);\n  printf(\"Pointsize = %g\\n\", pointsize);\n#endif\n  return floor(pointsize);\n}", "target": 0}
{"code": "char * gf_get_default_cache_directory() {\n\tchar szPath[GF_MAX_PATH];\n\tchar* root_tmp;\n\tsize_t len;\n#ifdef _WIN32_WCE\n\tstrcpy(szPath, \"\\\\windows\\\\temp\" );\n#elif defined(WIN32)\n\tGetTempPath(GF_MAX_PATH, szPath);\n#else\n\tstrcpy(szPath, \"/tmp\");\n#endif\n\troot_tmp = gf_strdup(szPath);\n\tlen = strlen(szPath);\n\tif (szPath[len-1] != GF_PATH_SEPARATOR) {\n\t\tszPath[len] = GF_PATH_SEPARATOR;\n\t\tszPath[len+1] = 0;\n\t}\n\tstrcat(szPath, \"gpac_cache\");\n\tif ( !gf_dir_exists(szPath) && gf_mkdir(szPath)!=GF_OK ) {\n\t\treturn root_tmp;\n\t}\n\tgf_free(root_tmp);\n\treturn gf_strdup(szPath);\n}", "target": 0}
{"code": "uint8_t* sldns_str2wire_dname(const char* str, size_t* len)\n{\n\tuint8_t dname[LDNS_MAX_DOMAINLEN+1];\n\t*len = sizeof(dname);\n\tif(sldns_str2wire_dname_buf(str, dname, len) == 0) {\n\t\tuint8_t* r;\n\t\tif(*len > sizeof(dname)) return NULL;\n\t\tr = (uint8_t*)malloc(*len);\n\t\tif(r) return memcpy(r, dname, *len);\n\t}\n\t*len = 0;\n\treturn NULL;\n}", "target": 0}
{"code": "static int proc_parse_options(char *options, struct pid_namespace *pid)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tif (!options)\n\t\treturn 1;\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\targs[0].to = args[0].from = NULL;\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tpid->pid_gid = make_kgid(current_user_ns(), option);\n\t\t\tbreak;\n\t\tcase Opt_hidepid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tif (option < 0 || option > 2) {\n\t\t\t\tpr_err(\"proc: hidepid value must be between 0 and 2.\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpid->hide_pid = option;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"proc: unrecognized mount option \\\"%s\\\" \"\n\t\t\t       \"or missing value\\n\", p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "mt76_add_fragment(struct mt76_dev *dev, struct mt76_queue *q, void *data,\n\t\t  int len, bool more)\n{\n\tstruct page *page = virt_to_head_page(data);\n\tint offset = data - page_address(page);\n\tstruct sk_buff *skb = q->rx_head;\n\toffset += q->buf_offset;\n\tskb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags, page, offset, len,\n\t\t\tq->buf_size);\n\tif (more)\n\t\treturn;\n\tq->rx_head = NULL;\n\tdev->drv->rx_skb(dev, q - dev->q_rx, skb);\n}", "target": 1}
{"code": "bool RootWindow::DispatchKeyEvent(KeyEvent* event) {\n  DispatchHeldMouseMove();\n  KeyEvent translated_event(*event);\n  if (translated_event.key_code() == ui::VKEY_UNKNOWN)\n    return false;\n  client::EventClient* client = client::GetEventClient(GetRootWindow());\n  if (client && !client->CanProcessEventsWithinSubtree(focused_window_)) {\n    SetFocusedWindow(NULL, NULL);\n    return false;\n  }\n  return ProcessKeyEvent(focused_window_, &translated_event);\n}", "target": 0}
{"code": "certstack_create(struct cert_stack **result)\n{\n\tstruct cert_stack *stack;\n\tstack = malloc(sizeof(struct cert_stack));\n\tif (stack == NULL)\n\t\treturn pr_enomem();\n\tstack->x509s = sk_X509_new_null();\n\tif (stack->x509s == NULL) {\n\t\tfree(stack);\n\t\treturn val_crypto_err(\"sk_X509_new_null() returned NULL\");\n\t}\n\tSLIST_INIT(&stack->defers);\n\tSLIST_INIT(&stack->metas);\n\tSLIST_INIT(&stack->levels);\n\t*result = stack;\n\treturn 0;\n}", "target": 1}
{"code": "JANET_CORE_FN(cfun_array_new_filled,\n              \"(array/new-filled count &opt value)\",\n              \"Creates a new array of `count` elements, all set to `value`, which defaults to nil. Returns the new array.\") {\n    janet_arity(argc, 1, 2);\n    int32_t count = janet_getinteger(argv, 0);\n    if (count < 0) janet_panic(\"expected positive integer\");\n    Janet x = (argc == 2) ? argv[1] : janet_wrap_nil();\n    JanetArray *array = janet_array(count);\n    for (int32_t i = 0; i < count; i++) {\n        array->data[i] = x;\n    }\n    array->count = count;\n    return janet_wrap_array(array);\n}", "target": 0}
{"code": "int av_lockmgr_register(int (*cb)(void **mutex, enum AVLockOp op))\n{\n    if (lockmgr_cb) {\n        if (lockmgr_cb(&codec_mutex, AV_LOCK_DESTROY))\n            return -1;\n        if (lockmgr_cb(&avformat_mutex, AV_LOCK_DESTROY))\n            return -1;\n    }\n    lockmgr_cb = cb;\n    if (lockmgr_cb) {\n        if (lockmgr_cb(&codec_mutex, AV_LOCK_CREATE))\n            return -1;\n        if (lockmgr_cb(&avformat_mutex, AV_LOCK_CREATE))\n            return -1;\n    }\n    return 0;\n}", "target": 0}
{"code": "int ff_init_buffer_info(AVCodecContext *avctx, AVFrame *frame)\n{\n    if (avctx->internal->pkt) {\n        frame->pkt_pts = avctx->internal->pkt->pts;\n        av_frame_set_pkt_pos     (frame, avctx->internal->pkt->pos);\n        av_frame_set_pkt_duration(frame, avctx->internal->pkt->duration);\n        av_frame_set_pkt_size    (frame, avctx->internal->pkt->size);\n    } else {\n        frame->pkt_pts = AV_NOPTS_VALUE;\n        av_frame_set_pkt_pos     (frame, -1);\n        av_frame_set_pkt_duration(frame, 0);\n        av_frame_set_pkt_size    (frame, -1);\n    }\n    frame->reordered_opaque = avctx->reordered_opaque;\n    switch (avctx->codec->type) {\n    case AVMEDIA_TYPE_VIDEO:\n        frame->format              = avctx->pix_fmt;\n        if (!frame->sample_aspect_ratio.num)\n            frame->sample_aspect_ratio = avctx->sample_aspect_ratio;\n        if (av_frame_get_colorspace(frame) == AVCOL_SPC_UNSPECIFIED)\n            av_frame_set_colorspace(frame, avctx->colorspace);\n        if (av_frame_get_color_range(frame) == AVCOL_RANGE_UNSPECIFIED)\n            av_frame_set_color_range(frame, avctx->color_range);\n        break;\n    case AVMEDIA_TYPE_AUDIO:\n        if (!frame->sample_rate)\n            frame->sample_rate    = avctx->sample_rate;\n        if (frame->format < 0)\n            frame->format         = avctx->sample_fmt;\n        if (!frame->channel_layout) {\n            if (avctx->channel_layout) {\n                 if (av_get_channel_layout_nb_channels(avctx->channel_layout) !=\n                     avctx->channels) {\n                     av_log(avctx, AV_LOG_ERROR, \"Inconsistent channel \"\n                            \"configuration.\\n\");\n                     return AVERROR(EINVAL);\n                 }\n                frame->channel_layout = avctx->channel_layout;\n            } else {\n                if (avctx->channels > FF_SANE_NB_CHANNELS) {\n                    av_log(avctx, AV_LOG_ERROR, \"Too many channels: %d.\\n\",\n                           avctx->channels);\n                    return AVERROR(ENOSYS);\n                }\n            }\n        }\n        av_frame_set_channels(frame, avctx->channels);\n        break;\n    }\n    return 0;\n}", "target": 0}
{"code": "static GF_Err BM_ParseGlobalQuantizer(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tGF_Node *node;\n\tGF_Command *com;\n\tGF_CommandField *inf;\n\tnode = gf_bifs_dec_node(codec, bs, NDT_SFWorldNode);\n\tif (!node) return GF_NON_COMPLIANT_BITSTREAM;\n\tif (codec->scenegraph->global_qp) {\n\t\tgf_node_unregister(codec->scenegraph->global_qp, NULL);\n\t}\n\tcodec->ActiveQP = NULL;\n\tcodec->scenegraph->global_qp = NULL;\n\tif (gf_node_get_tag(node) != TAG_MPEG4_QuantizationParameter) {\n\t\tgf_node_unregister(node, NULL);\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tcodec->ActiveQP = (M_QuantizationParameter *) node;\n\tcodec->ActiveQP->isLocal = 0;\n\tcodec->scenegraph->global_qp = node;\n\tnode->sgprivate->num_instances = 2;\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_GLOBAL_QUANTIZER);\n\tinf = gf_sg_command_field_new(com);\n\tinf->new_node = node;\n\tinf->field_ptr = &inf->new_node;\n\tinf->fieldType = GF_SG_VRML_SFNODE;\n\tgf_list_add(com_list, com);\n\treturn GF_OK;\n}", "target": 1}
{"code": "static void show_object(struct object *object, struct strbuf *path,\n\t\t\tconst char *last, void *data)\n{\n\tstruct bitmap *base = data;\n\tbitmap_set(base, find_object_pos(object->oid.hash));\n\tmark_as_seen(object);\n}", "target": 1}
{"code": "static int ssl_get_remaining_space_in_datagram( mbedtls_ssl_context const *ssl )\n{\n    size_t const bytes_written = ssl->out_left;\n    size_t const mtu           = ssl_get_maximum_datagram_size( ssl );\n    if( bytes_written > mtu )\n    {\n        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n    }\n    return( (int) ( mtu - bytes_written ) );\n}", "target": 0}
{"code": "sysUpTime_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  snmp_api_set_time_ticks(varbind, oid, clock_seconds() * 100);\n}", "target": 1}
{"code": "void qemu_ram_free(struct uc_struct *uc, RAMBlock *block)\n{\n    if (!block) {\n        return;\n    }\n    QLIST_REMOVE(block, next);\n    uc->ram_list.mru_block = NULL;\n    reclaim_ramblock(uc, block);\n}", "target": 1}
{"code": "int af_alg_release(struct socket *sock)\n{\n\tif (sock->sk)\n\t\tsock_put(sock->sk);\n\treturn 0;\n}", "target": 1}
{"code": "void RestAuthHandler::shutdownExecute(bool isFinalized) noexcept {\n  try {\n    if (_isValid) {\n      events::LoggedIn(*_request, _username);\n    } else {\n      events::CredentialsBad(*_request, _username);\n    }\n  } catch (...) {\n  }\n  RestVocbaseBaseHandler::shutdownExecute(isFinalized);\n}", "target": 1}
{"code": "renderCoTable(struct table *tbl, int maxlimit)\n{\n    struct readbuffer obuf;\n    struct html_feed_environ h_env;\n    struct environment envs[MAX_ENV_LEVEL];\n    struct table *t;\n    int i, col, row;\n    int indent, maxwidth;\n    for (i = 0; i < tbl->ntable; i++) {\n\tt = tbl->tables[i].ptr;\n\tcol = tbl->tables[i].col;\n\trow = tbl->tables[i].row;\n\tindent = tbl->tables[i].indent;\n\tinit_henv(&h_env, &obuf, envs, MAX_ENV_LEVEL, tbl->tables[i].buf,\n\t\t  get_spec_cell_width(tbl, row, col), indent);\n\tcheck_row(tbl, row);\n\tif (h_env.limit > maxlimit)\n\t    h_env.limit = maxlimit;\n\tif (t->total_width == 0)\n\t    maxwidth = h_env.limit - indent;\n\telse if (t->total_width > 0)\n\t    maxwidth = t->total_width;\n\telse\n\t    maxwidth = t->total_width = -t->total_width * h_env.limit / 100;\n\trenderTable(t, maxwidth, &h_env);\n    }\n}", "target": 1}
{"code": "gdk_pixbuf__bmp_image_begin_load(GdkPixbufModuleSizeFunc size_func,\n                                 GdkPixbufModulePreparedFunc prepared_func,\n\t\t\t\t GdkPixbufModuleUpdatedFunc updated_func,\n                                 gpointer user_data,\n                                 GError **error)\n{\n\tstruct bmp_progressive_state *context;\n\tcontext = g_new0(struct bmp_progressive_state, 1);\n\tcontext->size_func = size_func;\n\tcontext->prepared_func = prepared_func;\n\tcontext->updated_func = updated_func;\n\tcontext->user_data = user_data;\n\tcontext->read_state = READ_STATE_HEADERS;\n\tcontext->BufferSize = 26;\n\tcontext->BufferPadding = 0;\n\tcontext->buff = g_malloc(26);\n\tcontext->BufferDone = 0;\n\tcontext->Colormap = NULL;\n\tcontext->Lines = 0;\n\tcontext->Type = 0;\n\tmemset(&context->Header, 0, sizeof(struct headerpair));\n\tmemset(&context->compr, 0, sizeof(struct bmp_compression_state));\n\tcontext->pixbuf = NULL;\n\treturn (gpointer) context;\n}", "target": 0}
{"code": "BOOL license_read_product_info(wStream* s, PRODUCT_INFO* productInfo)\n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\tStream_Read_UINT32(s, productInfo->dwVersion); \n\tStream_Read_UINT32(s, productInfo->cbCompanyName); \n\tif (Stream_GetRemainingLength(s) < productInfo->cbCompanyName + 4)\n\t\treturn FALSE;\n\tproductInfo->pbCompanyName = (BYTE*) malloc(productInfo->cbCompanyName);\n\tStream_Read(s, productInfo->pbCompanyName, productInfo->cbCompanyName);\n\tStream_Read_UINT32(s, productInfo->cbProductId); \n\tif (Stream_GetRemainingLength(s) < productInfo->cbProductId)\n\t{\n\t\tfree(productInfo->pbCompanyName);\n\t\tproductInfo->pbCompanyName = NULL;\n\t\treturn FALSE;\n\t}\n\tproductInfo->pbProductId = (BYTE*) malloc(productInfo->cbProductId);\n\tStream_Read(s, productInfo->pbProductId, productInfo->cbProductId);\n\treturn TRUE;\n}", "target": 0}
{"code": "static void asmlinkage smm_do_relocation(void *arg)\n{\n\tconst struct smm_module_params *p;\n\tconst struct smm_runtime *runtime;\n\tint cpu;\n\tuintptr_t curr_smbase;\n\tuintptr_t perm_smbase;\n\tp = arg;\n\truntime = p->runtime;\n\tcpu = p->cpu;\n\tcurr_smbase = runtime->smbase;\n\tif (cpu >= CONFIG_MAX_CPUS) {\n\t\tprintk(BIOS_CRIT,\n\t\t       \"Invalid CPU number assigned in SMM stub: %d\\n\", cpu);\n\t\treturn;\n\t}\n\tperm_smbase = mp_state.perm_smbase;\n\tperm_smbase -= cpu * runtime->save_state_size;\n\tprintk(BIOS_DEBUG, \"New SMBASE 0x%08lx\\n\", perm_smbase);\n\tmp_state.ops.relocation_handler(cpu, curr_smbase, perm_smbase);\n\tif (CONFIG(STM)) {\n\t\tuintptr_t mseg;\n\t\tmseg = mp_state.perm_smbase +\n\t\t\t(mp_state.perm_smsize - CONFIG_MSEG_SIZE);\n\t\tstm_setup(mseg, p->cpu,\n\t\t\t\tperm_smbase,\n\t\t\t\tmp_state.perm_smbase,\n\t\t\t\truntime->start32_offset);\n\t}\n}", "target": 1}
{"code": "static int metachar(char c)\n{\n\treturn (strchr(metachars(), c) != NULL);\n}", "target": 1}
{"code": "SSLNetVConnection::select_next_protocol(SSL *ssl, const unsigned char **out, unsigned char *outlen,\n                                        const unsigned char *in ATS_UNUSED, unsigned inlen ATS_UNUSED, void *)\n{\n  SSLNetVConnection *netvc = SSLNetVCAccess(ssl);\n  const unsigned char *npn = nullptr;\n  unsigned npnsz           = 0;\n  ink_release_assert(netvc != nullptr);\n  if (netvc->npnSet && netvc->npnSet->advertiseProtocols(&npn, &npnsz)) {\n#if HAVE_SSL_SELECT_NEXT_PROTO\n    if (SSL_select_next_proto((unsigned char **)out, outlen, npn, npnsz, in, inlen) == OPENSSL_NPN_NEGOTIATED) {\n      Debug(\"ssl\", \"selected ALPN protocol %.*s\", (int)(*outlen), *out);\n      return SSL_TLSEXT_ERR_OK;\n    }\n#endif \n  }\n  *out    = nullptr;\n  *outlen = 0;\n  return SSL_TLSEXT_ERR_NOACK;\n}", "target": 0}
{"code": "void file_sb_list_del(struct file *file)\n{\n\tif (!list_empty(&file->f_u.fu_list)) {\n\t\tlg_local_lock_cpu(&files_lglock, file_list_cpu(file));\n\t\tlist_del_init(&file->f_u.fu_list);\n\t\tlg_local_unlock_cpu(&files_lglock, file_list_cpu(file));\n\t}\n}", "target": 1}
{"code": "GF_Err iKMS_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ISMAKMSBox *ptr = (GF_ISMAKMSBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n    if (ptr->URI)\n        gf_bs_write_data(bs, ptr->URI, (u32) strlen(ptr->URI));\n    gf_bs_write_u8(bs, 0);\n\treturn GF_OK;\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, SkipEvaluatesBeforeFetchForIndexedOr) {\n    addIndex(fromjson(\"{a: 1}\"));\n    runQuerySkipNToReturn(fromjson(\"{$or: [{a: 5}, {a: 7}]}\"), 8, 0);\n    ASSERT_EQUALS(getNumSolutions(), 2U);\n    assertSolutionExists(\n        \"{skip: {n: 8, node: \"\n        \"{cscan: {dir: 1, filter: {$or: [{a: 5}, {a: 7}]}}}}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: null, node: {skip: {n: 8, node: \"\n        \"{ixscan: {filter: null, pattern: {a: 1}}}}}}}\");\n}", "target": 0}
{"code": "static __inline __int64_t php_date_llabs( __int64_t i ) { return i >= 0 ? i : -i; }", "target": 0}
{"code": "static INLINE UINT16 ntlm_av_pair_get_id(const NTLM_AV_PAIR* pAvPair)\n{\n\tUINT16 AvId;\n\tData_Read_UINT16(&pAvPair->AvId, AvId);\n\treturn AvId;\n}", "target": 1}
{"code": "static char *str_dup_safe_fixed(const ut8 *b, const ut8 *str, ut64 len, const ut8 *end) {\n\tif (str >= b && str + len < end) {\n\t\tchar *result = calloc (1, len + 1);\n\t\tif (result) {\n\t\t\tr_str_ncpy (result, (const char *)str, len);\n\t\t\treturn result;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "static int xfrm_dump_policy_start(struct netlink_callback *cb)\n{\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb->args;\n\tBUILD_BUG_ON(sizeof(*walk) > sizeof(cb->args));\n\txfrm_policy_walk_init(walk, XFRM_POLICY_TYPE_ANY);\n\treturn 0;\n}", "target": 0}
{"code": "static MagickBooleanType IsWEBPImageLossless(const unsigned char *stream,\n  const size_t length)\n{\n#define VP8_CHUNK_INDEX  15\n#define LOSSLESS_FLAG  'L'\n#define EXTENDED_HEADER  'X'\n#define VP8_CHUNK_HEADER  \"VP8\"\n#define VP8_CHUNK_HEADER_SIZE  3\n#define RIFF_HEADER_SIZE  12\n#define VP8X_CHUNK_SIZE  10\n#define TAG_SIZE  4\n#define CHUNK_SIZE_BYTES  4\n#define CHUNK_HEADER_SIZE  8\n#define MAX_CHUNK_PAYLOAD  (~0U-CHUNK_HEADER_SIZE-1)\n  ssize_t\n    offset;\n  if (stream[VP8_CHUNK_INDEX] != EXTENDED_HEADER)\n    return(stream[VP8_CHUNK_INDEX] == LOSSLESS_FLAG ? MagickTrue : MagickFalse);\n  offset=RIFF_HEADER_SIZE+TAG_SIZE+CHUNK_SIZE_BYTES+VP8X_CHUNK_SIZE;\n  while (offset <= (ssize_t) (length-TAG_SIZE))\n  {\n    uint32_t\n      chunk_size,\n      chunk_size_pad;\n    chunk_size=ReadWebPLSBWord(stream+offset+TAG_SIZE);\n    if (chunk_size > MAX_CHUNK_PAYLOAD)\n      break;\n    chunk_size_pad=(CHUNK_HEADER_SIZE+chunk_size+1) & ~1;\n    if (memcmp(stream+offset,VP8_CHUNK_HEADER,VP8_CHUNK_HEADER_SIZE) == 0)\n      return(*(stream+offset+VP8_CHUNK_HEADER_SIZE) == LOSSLESS_FLAG ?\n        MagickTrue : MagickFalse);\n    offset+=chunk_size_pad;\n  }\n  return(MagickFalse);\n}", "target": 1}
{"code": "mono_get_method (MonoImage *image, guint32 token, MonoClass *klass)\n{\n\treturn mono_get_method_full (image, token, klass, NULL);\n}", "target": 0}
{"code": "static int collect_syscall(struct task_struct *target, struct syscall_info *info)\n{\n\tstruct pt_regs *regs;\n\tif (!try_get_task_stack(target)) {\n\t\tmemset(info, 0, sizeof(*info));\n\t\tinfo->data.nr = -1;\n\t\treturn 0;\n\t}\n\tregs = task_pt_regs(target);\n\tif (unlikely(!regs)) {\n\t\tput_task_stack(target);\n\t\treturn -EAGAIN;\n\t}\n\tinfo->sp = user_stack_pointer(regs);\n\tinfo->data.instruction_pointer = instruction_pointer(regs);\n\tinfo->data.nr = syscall_get_nr(target, regs);\n\tif (info->data.nr != -1L)\n\t\tsyscall_get_arguments(target, regs,\n\t\t\t\t      (unsigned long *)&info->data.args[0]);\n\tput_task_stack(target);\n\treturn 0;\n}", "target": 1}
{"code": "static int get_pipe(struct stub_device *sdev, int epnum, int dir)\n{\n\tstruct usb_device *udev = sdev->udev;\n\tstruct usb_host_endpoint *ep;\n\tstruct usb_endpoint_descriptor *epd = NULL;\n\tif (dir == USBIP_DIR_IN)\n\t\tep = udev->ep_in[epnum & 0x7f];\n\telse\n\t\tep = udev->ep_out[epnum & 0x7f];\n\tif (!ep) {\n\t\tdev_err(&sdev->udev->dev, \"no such endpoint?, %d\\n\",\n\t\t\tepnum);\n\t\tBUG();\n\t}\n\tepd = &ep->desc;\n\tif (usb_endpoint_xfer_control(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndctrlpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvctrlpipe(udev, epnum);\n\t}\n\tif (usb_endpoint_xfer_bulk(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndbulkpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvbulkpipe(udev, epnum);\n\t}\n\tif (usb_endpoint_xfer_int(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndintpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvintpipe(udev, epnum);\n\t}\n\tif (usb_endpoint_xfer_isoc(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndisocpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvisocpipe(udev, epnum);\n\t}\n\tdev_err(&sdev->udev->dev, \"get pipe, epnum %d\\n\", epnum);\n\treturn 0;\n}", "target": 1}
{"code": "static int get_iovec_page_array(const struct iovec __user *iov,\n\t\t\t\tunsigned int nr_vecs, struct page **pages,\n\t\t\t\tstruct partial_page *partial, int aligned)\n{\n\tint buffers = 0, error = 0;\n\tdown_read(&current->mm->mmap_sem);\n\twhile (nr_vecs) {\n\t\tunsigned long off, npages;\n\t\tstruct iovec entry;\n\t\tvoid __user *base;\n\t\tsize_t len;\n\t\tint i;\n\t\terror = -EFAULT;\n\t\tif (copy_from_user_mmap_sem(&entry, iov, sizeof(entry)))\n\t\t\tbreak;\n\t\tbase = entry.iov_base;\n\t\tlen = entry.iov_len;\n\t\terror = 0;\n\t\tif (unlikely(!len))\n\t\t\tbreak;\n\t\terror = -EFAULT;\n\t\tif (unlikely(!base))\n\t\t\tbreak;\n\t\toff = (unsigned long) base & ~PAGE_MASK;\n\t\terror = -EINVAL;\n\t\tif (aligned && (off || len & ~PAGE_MASK))\n\t\t\tbreak;\n\t\tnpages = (off + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\tif (npages > PIPE_BUFFERS - buffers)\n\t\t\tnpages = PIPE_BUFFERS - buffers;\n\t\terror = get_user_pages(current, current->mm,\n\t\t\t\t       (unsigned long) base, npages, 0, 0,\n\t\t\t\t       &pages[buffers], NULL);\n\t\tif (unlikely(error <= 0))\n\t\t\tbreak;\n\t\tfor (i = 0; i < error; i++) {\n\t\t\tconst int plen = min_t(size_t, len, PAGE_SIZE - off);\n\t\t\tpartial[buffers].offset = off;\n\t\t\tpartial[buffers].len = plen;\n\t\t\toff = 0;\n\t\t\tlen -= plen;\n\t\t\tbuffers++;\n\t\t}\n\t\tif (len)\n\t\t\tbreak;\n\t\tif (error < npages || buffers == PIPE_BUFFERS)\n\t\t\tbreak;\n\t\tnr_vecs--;\n\t\tiov++;\n\t}\n\tup_read(&current->mm->mmap_sem);\n\tif (buffers)\n\t\treturn buffers;\n\treturn error;\n}", "target": 1}
{"code": "zisofs_free(struct archive_write *a)\n{\n\tstruct iso9660 *iso9660 = a->format_data;\n\tint ret = ARCHIVE_OK;\n\tfree(iso9660->zisofs.block_pointers);\n\tif (iso9660->zisofs.stream_valid &&\n\t    deflateEnd(&(iso9660->zisofs.stream)) != Z_OK) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"Failed to clean up compressor\");\n\t\tret = ARCHIVE_FATAL;\n\t}\n\tiso9660->zisofs.block_pointers = NULL;\n\tiso9660->zisofs.stream_valid = 0;\n\treturn (ret);\n}", "target": 0}
{"code": "gss_wrap_iov (minor_status,\n              context_handle,\n              conf_req_flag,\n              qop_req,\n              conf_state,\n              iov,\n              iov_count)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\nint\t\t\tconf_req_flag;\ngss_qop_t\t\tqop_req;\nint *\t\t\tconf_state;\ngss_iov_buffer_desc  *\tiov;\nint\t\t\tiov_count;\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n    status = val_wrap_iov_args(minor_status, context_handle,\n\t\t\t       conf_req_flag, qop_req,\n\t\t\t       conf_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (mech) {\n\tif (mech->gss_wrap_iov) {\n\t    status = mech->gss_wrap_iov(\n\t\t\t\t\tminor_status,\n\t\t\t\t\tctx->internal_ctx_id,\n\t\t\t\t\tconf_req_flag,\n\t\t\t\t\tqop_req,\n\t\t\t\t\tconf_state,\n\t\t\t\t\tiov,\n\t\t\t\t\tiov_count);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\treturn(status);\n    }\n    return (GSS_S_BAD_MECH);\n}", "target": 0}
{"code": "static void make_response(struct xen_blkif_ring *ring, u64 id,\n\t\t\t  unsigned short op, int st)\n{\n\tstruct blkif_response  resp;\n\tunsigned long     flags;\n\tunion blkif_back_rings *blk_rings;\n\tint notify;\n\tresp.id        = id;\n\tresp.operation = op;\n\tresp.status    = st;\n\tspin_lock_irqsave(&ring->blk_ring_lock, flags);\n\tblk_rings = &ring->blk_rings;\n\tswitch (ring->blkif->blk_protocol) {\n\tcase BLKIF_PROTOCOL_NATIVE:\n\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->native, blk_rings->native.rsp_prod_pvt),\n\t\t       &resp, sizeof(resp));\n\t\tbreak;\n\tcase BLKIF_PROTOCOL_X86_32:\n\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->x86_32, blk_rings->x86_32.rsp_prod_pvt),\n\t\t       &resp, sizeof(resp));\n\t\tbreak;\n\tcase BLKIF_PROTOCOL_X86_64:\n\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->x86_64, blk_rings->x86_64.rsp_prod_pvt),\n\t\t       &resp, sizeof(resp));\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tblk_rings->common.rsp_prod_pvt++;\n\tRING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&blk_rings->common, notify);\n\tspin_unlock_irqrestore(&ring->blk_ring_lock, flags);\n\tif (notify)\n\t\tnotify_remote_via_irq(ring->irq);\n}", "target": 1}
{"code": "static int check_vmentry_postreqs(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12,\n\t\t\t\t  u32 *exit_qual)\n{\n\tbool ia32e;\n\t*exit_qual = ENTRY_FAIL_DEFAULT;\n\tif (!nested_guest_cr0_valid(vcpu, vmcs12->guest_cr0) ||\n\t    !nested_guest_cr4_valid(vcpu, vmcs12->guest_cr4))\n\t\treturn 1;\n\tif (!nested_cpu_has2(vmcs12, SECONDARY_EXEC_SHADOW_VMCS) &&\n\t    vmcs12->vmcs_link_pointer != -1ull) {\n\t\t*exit_qual = ENTRY_FAIL_VMCS_LINK_PTR;\n\t\treturn 1;\n\t}\n\tif (to_vmx(vcpu)->nested.nested_run_pending &&\n\t    (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_IA32_EFER)) {\n\t\tia32e = (vmcs12->vm_entry_controls & VM_ENTRY_IA32E_MODE) != 0;\n\t\tif (!kvm_valid_efer(vcpu, vmcs12->guest_ia32_efer) ||\n\t\t    ia32e != !!(vmcs12->guest_ia32_efer & EFER_LMA) ||\n\t\t    ((vmcs12->guest_cr0 & X86_CR0_PG) &&\n\t\t     ia32e != !!(vmcs12->guest_ia32_efer & EFER_LME)))\n\t\t\treturn 1;\n\t}\n\tif (vmcs12->vm_exit_controls & VM_EXIT_LOAD_IA32_EFER) {\n\t\tia32e = (vmcs12->vm_exit_controls &\n\t\t\t VM_EXIT_HOST_ADDR_SPACE_SIZE) != 0;\n\t\tif (!kvm_valid_efer(vcpu, vmcs12->host_ia32_efer) ||\n\t\t    ia32e != !!(vmcs12->host_ia32_efer & EFER_LMA) ||\n\t\t    ia32e != !!(vmcs12->host_ia32_efer & EFER_LME))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int io_wqe_worker(void *data)\n{\n\tstruct io_worker *worker = data;\n\tstruct io_wqe_acct *acct = io_wqe_get_acct(worker);\n\tstruct io_wqe *wqe = worker->wqe;\n\tstruct io_wq *wq = wqe->wq;\n\tbool last_timeout = false;\n\tchar buf[TASK_COMM_LEN];\n\tworker->flags |= (IO_WORKER_F_UP | IO_WORKER_F_RUNNING);\n\tsnprintf(buf, sizeof(buf), \"iou-wrk-%d\", wq->task->pid);\n\tset_task_comm(current, buf);\n\twhile (!test_bit(IO_WQ_BIT_EXIT, &wq->state)) {\n\t\tlong ret;\n\t\tset_current_state(TASK_INTERRUPTIBLE);\nloop:\n\t\traw_spin_lock(&wqe->lock);\n\t\tif (io_acct_run_queue(acct)) {\n\t\t\tio_worker_handle_work(worker);\n\t\t\tgoto loop;\n\t\t}\n\t\tif (last_timeout && acct->nr_workers > 1) {\n\t\t\traw_spin_unlock(&wqe->lock);\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t\tbreak;\n\t\t}\n\t\tlast_timeout = false;\n\t\t__io_worker_idle(wqe, worker);\n\t\traw_spin_unlock(&wqe->lock);\n\t\tif (io_flush_signals())\n\t\t\tcontinue;\n\t\tret = schedule_timeout(WORKER_IDLE_TIMEOUT);\n\t\tif (signal_pending(current)) {\n\t\t\tstruct ksignal ksig;\n\t\t\tif (!get_signal(&ksig))\n\t\t\t\tcontinue;\n\t\t\tif (fatal_signal_pending(current))\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tlast_timeout = !ret;\n\t}\n\tif (test_bit(IO_WQ_BIT_EXIT, &wq->state)) {\n\t\traw_spin_lock(&wqe->lock);\n\t\tio_worker_handle_work(worker);\n\t}\n\tio_worker_exit(worker);\n\treturn 0;\n}", "target": 0}
{"code": "sigterm_handler(int sig)\t\t\n{\n  (void)sig;\n  fprintf(stderr,\n\t  \"DEBUG: beh: Job canceled.\\n\");\n  if (job_canceled)\n    _exit(CUPS_BACKEND_OK);\n  else\n    job_canceled = 1;\n}", "target": 1}
{"code": "static void update_blocked_averages(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct cfs_rq *cfs_rq, *pos;\n\tconst struct sched_class *curr_class;\n\tstruct rq_flags rf;\n\tbool done = true;\n\trq_lock_irqsave(rq, &rf);\n\tupdate_rq_clock(rq);\n\tfor_each_leaf_cfs_rq_safe(rq, cfs_rq, pos) {\n\t\tstruct sched_entity *se;\n\t\tif (throttled_hierarchy(cfs_rq))\n\t\t\tcontinue;\n\t\tif (update_cfs_rq_load_avg(cfs_rq_clock_task(cfs_rq), cfs_rq))\n\t\t\tupdate_tg_load_avg(cfs_rq, 0);\n\t\tse = cfs_rq->tg->se[cpu];\n\t\tif (se && !skip_blocked_update(se))\n\t\t\tupdate_load_avg(cfs_rq_of(se), se, 0);\n\t\tif (cfs_rq_is_decayed(cfs_rq))\n\t\t\tlist_del_leaf_cfs_rq(cfs_rq);\n\t\tif (cfs_rq_has_blocked(cfs_rq))\n\t\t\tdone = false;\n\t}\n\tcurr_class = rq->curr->sched_class;\n\tupdate_rt_rq_load_avg(rq_clock_task(rq), rq, curr_class == &rt_sched_class);\n\tupdate_dl_rq_load_avg(rq_clock_task(rq), rq, curr_class == &dl_sched_class);\n\tupdate_irq_load_avg(rq, 0);\n\tif (others_have_blocked(rq))\n\t\tdone = false;\n#ifdef CONFIG_NO_HZ_COMMON\n\trq->last_blocked_load_update_tick = jiffies;\n\tif (done)\n\t\trq->has_blocked_load = 0;\n#endif\n\trq_unlock_irqrestore(rq, &rf);\n}", "target": 1}
{"code": "struct sock *ax25_get_socket(ax25_address *my_addr, ax25_address *dest_addr,\n\tint type)\n{\n\tstruct sock *sk = NULL;\n\tax25_cb *s;\n\tspin_lock(&ax25_list_lock);\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->sk && !ax25cmp(&s->source_addr, my_addr) &&\n\t\t    !ax25cmp(&s->dest_addr, dest_addr) &&\n\t\t    s->sk->sk_type == type) {\n\t\t\tsk = s->sk;\n\t\t\tsock_hold(sk);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&ax25_list_lock);\n\treturn sk;\n}", "target": 0}
{"code": "static int netsnmp_session_gen_sec_key(struct snmp_session *s, char *pass)\n{\n\tint snmp_errno;\n\ts->securityPrivKeyLen = USM_PRIV_KU_LEN;\n\tif ((snmp_errno = generate_Ku(s->securityAuthProto, s->securityAuthProtoLen,\n\t\t\t(u_char *)pass, strlen(pass),\n\t\t\ts->securityPrivKey, &(s->securityPrivKeyLen)))) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Error generating a key for privacy pass phrase '%s': %s\", pass, snmp_api_errstring(snmp_errno));\n\t\treturn (-2);\n\t}\n\treturn (0);\n}", "target": 0}
{"code": "unsigned int inet6_hash_frag(__be32 id, const struct in6_addr *saddr,\n\t\t\t     const struct in6_addr *daddr, u32 rnd)\n{\n\tu32 a, b, c;\n\ta = (__force u32)saddr->s6_addr32[0];\n\tb = (__force u32)saddr->s6_addr32[1];\n\tc = (__force u32)saddr->s6_addr32[2];\n\ta += JHASH_GOLDEN_RATIO;\n\tb += JHASH_GOLDEN_RATIO;\n\tc += rnd;\n\t__jhash_mix(a, b, c);\n\ta += (__force u32)saddr->s6_addr32[3];\n\tb += (__force u32)daddr->s6_addr32[0];\n\tc += (__force u32)daddr->s6_addr32[1];\n\t__jhash_mix(a, b, c);\n\ta += (__force u32)daddr->s6_addr32[2];\n\tb += (__force u32)daddr->s6_addr32[3];\n\tc += (__force u32)id;\n\t__jhash_mix(a, b, c);\n\treturn c & (INETFRAGS_HASHSZ - 1);\n}", "target": 0}
{"code": "SAPI_API void sapi_shutdown(void)\n{\n#ifdef ZTS\n\tts_free_id(sapi_globals_id);\n#else\n\tsapi_globals_dtor(&sapi_globals);\n#endif\n\treentrancy_shutdown();\n\tvirtual_cwd_shutdown();\n#ifdef PHP_WIN32\n\ttsrm_win32_shutdown();\n#endif\n}", "target": 0}
{"code": "static void vc_uniscr_putc(struct vc_data *vc, char32_t uc)\n{\n\tstruct uni_screen *uniscr = get_vc_uniscr(vc);\n\tif (uniscr)\n\t\tuniscr->lines[vc->vc_y][vc->vc_x] = uc;\n}", "target": 0}
{"code": "static inline int qdisc_restart(struct net_device *dev)\n{\n\tstruct Qdisc *q = dev->qdisc;\n\tstruct sk_buff *skb;\n\tint ret = NETDEV_TX_BUSY;\n\tif (unlikely((skb = dev_dequeue_skb(dev, q)) == NULL))\n\t\treturn 0;\n\tspin_unlock(&dev->queue_lock);\n\tHARD_TX_LOCK(dev, smp_processor_id());\n\tif (!netif_subqueue_stopped(dev, skb))\n\t\tret = dev_hard_start_xmit(skb, dev);\n\tHARD_TX_UNLOCK(dev);\n\tspin_lock(&dev->queue_lock);\n\tq = dev->qdisc;\n\tswitch (ret) {\n\tcase NETDEV_TX_OK:\n\t\tret = qdisc_qlen(q);\n\t\tbreak;\n\tcase NETDEV_TX_LOCKED:\n\t\tret = handle_dev_cpu_collision(skb, dev, q);\n\t\tbreak;\n\tdefault:\n\t\tif (unlikely (ret != NETDEV_TX_BUSY && net_ratelimit()))\n\t\t\tprintk(KERN_WARNING \"BUG %s code %d qlen %d\\n\",\n\t\t\t       dev->name, ret, q->q.qlen);\n\t\tret = dev_requeue_skb(skb, dev, q);\n\t\tbreak;\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "void PpapiPluginProcessHost::OnProcessLaunched() {\n   host_impl_->set_plugin_process_handle(process_->GetHandle());\n }", "target": 0}
{"code": "trad_enc_update_keys(struct trad_enc_ctx *ctx, uint8_t c)\n{\n\tuint8_t t;\n#define CRC32(c, b) (crc32(c ^ 0xffffffffUL, &b, 1) ^ 0xffffffffUL)\n\tctx->keys[0] = CRC32(ctx->keys[0], c);\n\tctx->keys[1] = (ctx->keys[1] + (ctx->keys[0] & 0xff)) * 134775813L + 1;\n\tt = (ctx->keys[1] >> 24) & 0xff;\n\tctx->keys[2] = CRC32(ctx->keys[2], t);\n#undef CRC32\n}", "target": 0}
{"code": "_dbus_printf_string_upper_bound (const char *format,\n                                 va_list     args)\n{\n  char static_buf[1024];\n  int bufsize = sizeof (static_buf);\n  int len;\n  len = vsnprintf (static_buf, bufsize, format, args);\n  if (len == bufsize)\n    {\n      if (vsnprintf (static_buf, 1, format, args) == 1)\n        len = -1;\n    }\n  while (len < 0)\n    {\n      char *buf;\n      bufsize *= 2;\n      buf = dbus_malloc (bufsize);\n      if (buf == NULL)\n        return -1;\n      len = vsnprintf (buf, bufsize, format, args);\n      dbus_free (buf);\n      if (len == bufsize)\n        len = -1;\n    }\n  return len;\n}", "target": 1}
{"code": "void FIFOSampleBuffer::setChannels(int numChannels)\n{\n    uint usedBytes;\n    assert(numChannels > 0);\n    usedBytes = channels * samplesInBuffer;\n    channels = (uint)numChannels;\n    samplesInBuffer = usedBytes / channels;\n}", "target": 1}
{"code": "void print_2fun(FILE* outfile, LibRaw& MyCoolRawProcessor, std::string& fn)\n{\n\tfprintf(outfile, \"\n\tif (C.cam_mul[0] > 0)\n\t{\n\t\tfprintf(outfile, \"\\n'As shot' WB:\");\n\t\tfor (int c = 0; c < 4; c++)\n\t\t\tfprintf(outfile, \" %.3f\", C.cam_mul[c]);\n\t}\n\tif (C.WB_Coeffs[LIBRAW_WBI_Auto][0] > 0)\n\t{\n\t\tfprintf(outfile, \"\\n'Camera Auto' WB:\");\n\t\tfor (int c = 0; c < 4; c++)\n\t\t\tfprintf(outfile, \" %d\", C.WB_Coeffs[LIBRAW_WBI_Auto][c]);\n\t}\n\tif (C.WB_Coeffs[LIBRAW_WBI_Measured][0] > 0)\n\t{\n\t\tfprintf(outfile, \"\\n'Camera Measured' WB:\");\n\t\tfor (int c = 0; c < 4; c++)\n\t\t\tfprintf(outfile, \" %d\", C.WB_Coeffs[LIBRAW_WBI_Measured][c]);\n\t}\n\tfprintf(outfile, \"\\n\\n\");\n}", "target": 0}
{"code": "static int ntlm_decode_field(struct wire_field_hdr *hdr,\n                             struct ntlm_buffer *buffer,\n                             size_t payload_offs,\n                             struct ntlm_buffer *field)\n{\n    struct ntlm_buffer b = { NULL, 0 };\n    uint32_t offs;\n    uint16_t len;\n    len = le16toh(hdr->len);\n    if (len == 0) goto done;\n    offs = le32toh(hdr->offset);\n    if ((offs < payload_offs) ||\n        (offs > buffer->length) ||\n        (UINT32_MAX - offs < len) ||\n        (offs + len > buffer->length)) {\n        return ERR_DECODE;\n    }\n    b.data = malloc(len);\n    if (!b.data) return ENOMEM;\n    b.length = len;\n    memcpy(b.data, &buffer->data[offs], b.length);\ndone:\n    *field = b;\n    return 0;\n}", "target": 0}
{"code": "static void ucvector_cleanup(void* p)\n{\n  ((ucvector*)p)->size = ((ucvector*)p)->allocsize = 0;\n  free(((ucvector*)p)->data);\n  ((ucvector*)p)->data = NULL;\n}", "target": 0}
{"code": "void sctp_generate_heartbeat_event(unsigned long data)\n{\n\tint error = 0;\n\tstruct sctp_transport *transport = (struct sctp_transport *) data;\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct net *net = sock_net(asoc->base.sk);\n\tbh_lock_sock(asoc->base.sk);\n\tif (sock_owned_by_user(asoc->base.sk)) {\n\t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n\t\tif (!mod_timer(&transport->hb_timer, jiffies + (HZ/20)))\n\t\t\tsctp_transport_hold(transport);\n\t\tgoto out_unlock;\n\t}\n\tif (transport->dead)\n\t\tgoto out_unlock;\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(SCTP_EVENT_TIMEOUT_HEARTBEAT),\n\t\t\t   asoc->state, asoc->ep, asoc,\n\t\t\t   transport, GFP_ATOMIC);\n\tif (error)\n\t\tasoc->base.sk->sk_err = -error;\nout_unlock:\n\tbh_unlock_sock(asoc->base.sk);\n\tsctp_transport_put(transport);\n}", "target": 1}
{"code": "fz_new_cmm_context(fz_context *ctx)\n{\n\tctx->cmm_instance = fz_cmm_new_instance(ctx);\n}", "target": 0}
{"code": "  char *strndup(const char *str, size_t size)\n  {\n    char *copy;\n    size_t len = strlen(str);\n    if (len > size)\n      len = size;\n    copy = (char *)REDIRECT_MALLOC(len + 1);\n    if (copy == NULL) {\n      errno = ENOMEM;\n      return NULL;\n    }\n    BCOPY(str, copy, len);\n    copy[len] = '\\0';\n    return copy;\n  }", "target": 0}
{"code": "struct vfsmount *lookup_mnt(struct path *path)\n{\n\tstruct mount *child_mnt;\n\tstruct vfsmount *m;\n\tunsigned seq;\n\trcu_read_lock();\n\tdo {\n\t\tseq = read_seqbegin(&mount_lock);\n\t\tchild_mnt = __lookup_mnt(path->mnt, path->dentry);\n\t\tm = child_mnt ? &child_mnt->mnt : NULL;\n\t} while (!legitimize_mnt(m, seq));\n\trcu_read_unlock();\n\treturn m;\n}", "target": 0}
{"code": "static int br_parse_ip_options(struct sk_buff *skb)\n{\n\tstruct ip_options *opt;\n\tstruct iphdr *iph;\n\tstruct net_device *dev = skb->dev;\n\tu32 len;\n\tiph = ip_hdr(skb);\n\topt = &(IPCB(skb)->opt);\n\tif (iph->ihl < 5 || iph->version != 4)\n\t\tgoto inhdr_error;\n\tif (!pskb_may_pull(skb, iph->ihl*4))\n\t\tgoto inhdr_error;\n\tiph = ip_hdr(skb);\n\tif (unlikely(ip_fast_csum((u8 *)iph, iph->ihl)))\n\t\tgoto inhdr_error;\n\tlen = ntohs(iph->tot_len);\n\tif (skb->len < len) {\n\t\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INTRUNCATEDPKTS);\n\t\tgoto drop;\n\t} else if (len < (iph->ihl*4))\n\t\tgoto inhdr_error;\n\tif (pskb_trim_rcsum(skb, len)) {\n\t\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INDISCARDS);\n\t\tgoto drop;\n\t}\n\tif (iph->ihl == 5) {\n\t\tmemset(IPCB(skb), 0, sizeof(struct inet_skb_parm));\n\t\treturn 0;\n\t}\n\topt->optlen = iph->ihl*4 - sizeof(struct iphdr);\n\tif (ip_options_compile(dev_net(dev), opt, skb))\n\t\tgoto inhdr_error;\n\tif (unlikely(opt->srr)) {\n\t\tstruct in_device *in_dev = __in_dev_get_rcu(dev);\n\t\tif (in_dev && !IN_DEV_SOURCE_ROUTE(in_dev))\n\t\t\tgoto drop;\n\t\tif (ip_options_rcv_srr(skb))\n\t\t\tgoto drop;\n\t}\n\treturn 0;\ninhdr_error:\n\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INHDRERRORS);\ndrop:\n\treturn -1;\n}", "target": 1}
{"code": "static __init int vdso_do_find_sections(struct lib32_elfinfo *v32,\n\t\t\t\t\tstruct lib64_elfinfo *v64)\n{\n\tvoid *sect;\n\tv32->dynsym = find_section32(v32->hdr, \".dynsym\", &v32->dynsymsize);\n\tv32->dynstr = find_section32(v32->hdr, \".dynstr\", NULL);\n\tif (v32->dynsym == NULL || v32->dynstr == NULL) {\n\t\tprintk(KERN_ERR \"vDSO32: required symbol section not found\\n\");\n\t\treturn -1;\n\t}\n\tsect = find_section32(v32->hdr, \".text\", NULL);\n\tif (sect == NULL) {\n\t\tprintk(KERN_ERR \"vDSO32: the .text section was not found\\n\");\n\t\treturn -1;\n\t}\n\tv32->text = sect - vdso32_kbase;\n#ifdef CONFIG_PPC64\n\tv64->dynsym = find_section64(v64->hdr, \".dynsym\", &v64->dynsymsize);\n\tv64->dynstr = find_section64(v64->hdr, \".dynstr\", NULL);\n\tif (v64->dynsym == NULL || v64->dynstr == NULL) {\n\t\tprintk(KERN_ERR \"vDSO64: required symbol section not found\\n\");\n\t\treturn -1;\n\t}\n\tsect = find_section64(v64->hdr, \".text\", NULL);\n\tif (sect == NULL) {\n\t\tprintk(KERN_ERR \"vDSO64: the .text section was not found\\n\");\n\t\treturn -1;\n\t}\n\tv64->text = sect - vdso64_kbase;\n#endif \n\treturn 0;\n}", "target": 0}
{"code": "    uint32_t PsdImage::writeExifData(const ExifData& exifData, BasicIo& out)\n    {\n        uint32_t resLength = 0;\n        byte buf[8];\n        if (exifData.count() > 0) {\n            Blob blob;\n            ByteOrder bo = byteOrder();\n            if (bo == invalidByteOrder) {\n                bo = littleEndian;\n                setByteOrder(bo);\n            }\n            ExifParser::encode(blob, bo, exifData);\n            if (blob.size() > 0) {\n#ifdef DEBUG\n                std::cerr << std::hex << \"write: resourceId: \" << kPhotoshopResourceID_ExifInfo << \"\\n\";\n                std::cerr << std::dec << \"Writing ExifInfo: size: \" << blob.size() << \"\\n\";\n#endif\n                if (out.write(reinterpret_cast<const byte*>(Photoshop::irbId_[0]), 4) != 4) throw Error(kerImageWriteFailed);\n                us2Data(buf, kPhotoshopResourceID_ExifInfo, bigEndian);\n                if (out.write(buf, 2) != 2) throw Error(kerImageWriteFailed);\n                us2Data(buf, 0, bigEndian);                      \n                if (out.write(buf, 2) != 2) throw Error(kerImageWriteFailed);\n                ul2Data(buf, static_cast<uint32_t>(blob.size()), bigEndian);\n                if (out.write(buf, 4) != 4) throw Error(kerImageWriteFailed);\n                if (out.write(&blob[0], static_cast<long>(blob.size())) != static_cast<long>(blob.size())) throw Error(kerImageWriteFailed);\n                resLength += static_cast<long>(blob.size()) + 12;\n                if (blob.size() & 1)    \n                {\n                    buf[0] = 0;\n                    if (out.write(buf, 1) != 1) throw Error(kerImageWriteFailed);\n                    resLength++;\n                }\n            }\n        }\n        return resLength;\n    } ", "target": 0}
{"code": "int av_reallocp_array(void *ptr, size_t nmemb, size_t size)\n{\n    void **ptrptr = ptr;\n    *ptrptr = av_realloc_f(*ptrptr, nmemb, size);\n    if (!*ptrptr && !(nmemb && size))\n        return AVERROR(ENOMEM);\n    return 0;\n}", "target": 1}
{"code": "static Image *DrawCompositeMask(Image *image,const DrawInfo *draw_info,\n  const char *id,const char *mask_path,ExceptionInfo *exception)\n{\n  Image\n    *composite_mask;\n  DrawInfo\n    *clone_info;\n  MagickStatusType\n    status;\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(draw_info != (const DrawInfo *) NULL);\n  composite_mask=AcquireImage((const ImageInfo *) NULL);\n  status=SetImageExtent(composite_mask,image->columns,image->rows);\n  if (status == MagickFalse)\n    return(DestroyImage(composite_mask));\n  status=SetImageMask(image,(Image *) NULL);\n  status=QueryColorCompliance(\"#0000\",AllCompliance,\n    &composite_mask->background_color,exception);\n  composite_mask->background_color.opacity=(Quantum) TransparentOpacity;\n  (void) SetImageBackgroundColor(composite_mask);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"\\nbegin mask-path %s\",\n      id);\n  clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  (void) CloneString(&clone_info->primitive,mask_path);\n  status=QueryColorCompliance(\"#ffffff\",AllCompliance,&clone_info->fill,\n    exception);\n  status=QueryColorCompliance(\"#00000000\",AllCompliance,&clone_info->stroke,\n    exception);\n  clone_info->stroke_width=0.0;\n  clone_info->opacity=OpaqueOpacity;\n  status=RenderMVGContent(composite_mask,clone_info,0);\n  clone_info=DestroyDrawInfo(clone_info);\n  status&=SeparateImageChannel(composite_mask,TrueAlphaChannel);\n  status&=NegateImage(composite_mask,MagickFalse);\n  if (status == MagickFalse)\n    composite_mask=DestroyImage(composite_mask);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"end mask-path\");\n  return(composite_mask);\n}", "target": 0}
{"code": "void RenderView::printPage(WebFrame* frame) {\n  DCHECK(frame);\n  Print(frame, true);\n}", "target": 0}
{"code": "static u32 __ipv6_select_ident(struct net *net, u32 hashrnd,\n\t\t\t       const struct in6_addr *dst,\n\t\t\t       const struct in6_addr *src)\n{\n\tu32 hash, id;\n\thash = __ipv6_addr_jhash(dst, hashrnd);\n\thash = __ipv6_addr_jhash(src, hash);\n\thash ^= net_hash_mix(net);\n\tid = ip_idents_reserve(hash, 1);\n\tif (unlikely(!id))\n\t\tid = 1 << 31;\n\treturn id;\n}", "target": 1}
{"code": "AP_DECLARE(void) ap_increment_counts(ap_sb_handle_t *sb, request_rec *r)\n{\n    worker_score *ws;\n    apr_off_t bytes;\n    if (!sb)\n        return;\n    ws = &ap_scoreboard_image->servers[sb->child_num][sb->thread_num];\n    if (pfn_ap_logio_get_last_bytes != NULL) {\n        bytes = pfn_ap_logio_get_last_bytes(r->connection);\n    }\n    else if (r->method_number == M_GET && r->method[0] == 'H') {\n        bytes = 0;\n    }\n    else {\n        bytes = r->bytes_sent;\n    }\n#ifdef HAVE_TIMES\n    times(&ws->times);\n#endif\n    ws->access_count++;\n    ws->my_access_count++;\n    ws->conn_count++;\n    ws->bytes_served += bytes;\n    ws->my_bytes_served += bytes;\n    ws->conn_bytes += bytes;\n}", "target": 1}
{"code": "static inline void *freelist_dereference(const struct kmem_cache *s,\n\t\t\t\t\t void *ptr_addr)\n{\n\treturn freelist_ptr(s, (void *)*(unsigned long *)(ptr_addr),\n\t\t\t    (unsigned long)ptr_addr);\n}", "target": 0}
{"code": "mrb_remove_method(mrb_state *mrb, struct RClass *c, mrb_sym mid)\n{\n  mt_tbl *h;\n  MRB_CLASS_ORIGIN(c);\n  h = c->mt;\n  if (h && mt_del(mrb, h, mid)) return;\n  mrb_name_error(mrb, mid, \"method '%n' not defined in %C\", mid, c);\n}", "target": 1}
{"code": "ext4_xattr_block_list(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct buffer_head *bh = NULL;\n\tint error;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\tea_idebug(inode, \"buffer=%p, buffer_size=%ld\",\n\t\t  buffer, (long)buffer_size);\n\terror = 0;\n\tif (!EXT4_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tea_idebug(inode, \"reading block %llu\",\n\t\t  (unsigned long long)EXT4_I(inode)->i_file_acl);\n\tbh = sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl);\n\terror = -EIO;\n\tif (!bh)\n\t\tgoto cleanup;\n\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\tatomic_read(&(bh->b_count)), le32_to_cpu(BHDR(bh)->h_refcount));\n\tif (ext4_xattr_check_block(inode, bh)) {\n\t\tEXT4_ERROR_INODE(inode, \"bad block %llu\",\n\t\t\t\t EXT4_I(inode)->i_file_acl);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto cleanup;\n\t}\n\text4_xattr_cache_insert(ext4_mb_cache, bh);\n\terror = ext4_xattr_list_entries(dentry, BFIRST(bh), buffer, buffer_size);\ncleanup:\n\tbrelse(bh);\n\treturn error;\n}", "target": 1}
{"code": "const unsigned char* lodepng_chunk_next_const(const unsigned char* chunk)\n{\n  unsigned total_chunk_length = lodepng_chunk_length(chunk) + 12;\n  return &chunk[total_chunk_length];\n}", "target": 0}
{"code": "void sw_crypto_acipher_free_rsa_public_key(struct rsa_public_key *s)\n{\n\tif (!s)\n\t\treturn;\n\tcrypto_bignum_free(s->n);\n\tcrypto_bignum_free(s->e);\n}", "target": 1}
{"code": "static ssize_t stream_writev_cb(RedStream *s, const struct iovec *iov, int iovcnt)\n{\n    ssize_t ret = 0;\n    do {\n        int tosend;\n        ssize_t n, expected = 0;\n        int i;\n#ifdef IOV_MAX\n        tosend = MIN(iovcnt, IOV_MAX);\n#else\n        tosend = iovcnt;\n#endif\n        for (i = 0; i < tosend; i++) {\n            expected += iov[i].iov_len;\n        }\n        n = socket_writev(s->socket, iov, tosend);\n        if (n <= expected) {\n            if (n > 0)\n                ret += n;\n            return ret == 0 ? n : ret;\n        }\n        ret += n;\n        iov += tosend;\n        iovcnt -= tosend;\n    } while(iovcnt > 0);\n    return ret;\n}", "target": 0}
{"code": "void opj_j2k_dump_MH_info(opj_j2k_t* p_j2k, FILE* out_stream)\n{\n        fprintf(out_stream, \"Codestream info from main header: {\\n\");\n        fprintf(out_stream, \"\\t tx0=%d, ty0=%d\\n\", p_j2k->m_cp.tx0, p_j2k->m_cp.ty0);\n        fprintf(out_stream, \"\\t tdx=%d, tdy=%d\\n\", p_j2k->m_cp.tdx, p_j2k->m_cp.tdy);\n        fprintf(out_stream, \"\\t tw=%d, th=%d\\n\", p_j2k->m_cp.tw, p_j2k->m_cp.th);\n        opj_j2k_dump_tile_info(p_j2k->m_specific_param.m_decoder.m_default_tcp,(OPJ_INT32)p_j2k->m_private_image->numcomps, out_stream);\n        fprintf(out_stream, \"}\\n\");\n}", "target": 0}
{"code": "static int tight_compress_data(VncState *vs, int stream_id, size_t bytes,\n                               int level, int strategy)\n{\n    z_streamp zstream = &vs->tight->stream[stream_id];\n    int previous_out;\n    if (bytes < VNC_TIGHT_MIN_TO_COMPRESS) {\n        vnc_write(vs, vs->tight->tight.buffer, vs->tight->tight.offset);\n        return bytes;\n    }\n    if (tight_init_stream(vs, stream_id, level, strategy)) {\n        return -1;\n    }\n    buffer_reserve(&vs->tight->zlib, bytes + 64);\n    zstream->next_in = vs->tight->tight.buffer;\n    zstream->avail_in = vs->tight->tight.offset;\n    zstream->next_out = vs->tight->zlib.buffer + vs->tight->zlib.offset;\n    zstream->avail_out = vs->tight->zlib.capacity - vs->tight->zlib.offset;\n    previous_out = zstream->avail_out;\n    zstream->data_type = Z_BINARY;\n    if (deflate(zstream, Z_SYNC_FLUSH) != Z_OK) {\n        fprintf(stderr, \"VNC: error during tight compression\\n\");\n        return -1;\n    }\n    vs->tight->zlib.offset = vs->tight->zlib.capacity - zstream->avail_out;\n    bytes = previous_out - zstream->avail_out;\n    tight_send_compact_size(vs, bytes);\n    vnc_write(vs, vs->tight->zlib.buffer, bytes);\n    buffer_reset(&vs->tight->zlib);\n    return bytes;\n}", "target": 0}
{"code": "ikev2_ke_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len _U_, const u_char *ep _U_,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct ikev2_ke ke;\n\tconst struct ikev2_ke *k;\n\tk = (const struct ikev2_ke *)ext;\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&ke, ext, sizeof(ke));\n\tikev2_pay_print(ndo, NPSTR(tpay), ke.h.critical);\n\tND_PRINT((ndo,\" len=%u group=%s\", ntohs(ke.h.len) - 8,\n\t\t  STR_OR_ID(ntohs(ke.ke_group), dh_p_map)));\n\tif (2 < ndo->ndo_vflag && 8 < ntohs(ke.h.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(k + 1), ntohs(ke.h.len) - 8))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(ke.h.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}", "target": 1}
{"code": "static void sev_es_sync_from_ghcb(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tstruct kvm_vcpu *vcpu = &svm->vcpu;\n\tstruct ghcb *ghcb = svm->ghcb;\n\tu64 exit_code;\n\tmemset(vcpu->arch.regs, 0, sizeof(vcpu->arch.regs));\n\tvcpu->arch.regs[VCPU_REGS_RAX] = ghcb_get_rax_if_valid(ghcb);\n\tvcpu->arch.regs[VCPU_REGS_RBX] = ghcb_get_rbx_if_valid(ghcb);\n\tvcpu->arch.regs[VCPU_REGS_RCX] = ghcb_get_rcx_if_valid(ghcb);\n\tvcpu->arch.regs[VCPU_REGS_RDX] = ghcb_get_rdx_if_valid(ghcb);\n\tvcpu->arch.regs[VCPU_REGS_RSI] = ghcb_get_rsi_if_valid(ghcb);\n\tsvm->vmcb->save.cpl = ghcb_get_cpl_if_valid(ghcb);\n\tif (ghcb_xcr0_is_valid(ghcb)) {\n\t\tvcpu->arch.xcr0 = ghcb_get_xcr0(ghcb);\n\t\tkvm_update_cpuid_runtime(vcpu);\n\t}\n\texit_code = ghcb_get_sw_exit_code(ghcb);\n\tcontrol->exit_code = lower_32_bits(exit_code);\n\tcontrol->exit_code_hi = upper_32_bits(exit_code);\n\tcontrol->exit_info_1 = ghcb_get_sw_exit_info_1(ghcb);\n\tcontrol->exit_info_2 = ghcb_get_sw_exit_info_2(ghcb);\n\tmemset(ghcb->save.valid_bitmap, 0, sizeof(ghcb->save.valid_bitmap));\n}", "target": 0}
{"code": "static pid_t get_task_reaper_pid(pid_t task)\n{\n\tint sock[2];\n\tpid_t pid;\n\tpid_t ret = -1;\n\tchar v = '0';\n\tstruct ucred cred;\n\tif (socketpair(AF_UNIX, SOCK_DGRAM, 0, sock) < 0) {\n\t\tperror(\"socketpair\");\n\t\treturn -1;\n\t}\n\tpid = fork();\n\tif (pid < 0)\n\t\tgoto out;\n\tif (!pid) {\n\t\tclose(sock[1]);\n\t\twrite_task_init_pid_exit(sock[0], task);\n\t}\n\tif (!recv_creds(sock[1], &cred, &v))\n\t\tgoto out;\n\tret = cred.pid;\nout:\n\tclose(sock[0]);\n\tclose(sock[1]);\n\treturn ret;\n}", "target": 0}
{"code": "static inline int checkSettingSecurity(lua_State* L, const std::string &name)\n{\n\tif (ScriptApiSecurity::isSecure(L) && name.compare(0, 7, \"secure.\") == 0)\n\t\tthrow LuaError(\"Attempted to set secure setting.\");\n\tbool is_mainmenu = false;\n#ifndef SERVER\n\tis_mainmenu = ModApiBase::getGuiEngine(L) != nullptr;\n#endif\n\tif (!is_mainmenu && (name == \"mg_name\" || name == \"mg_flags\")) {\n\t\terrorstream << \"Tried to set global setting \" << name << \", ignoring. \"\n\t\t\t\"minetest.set_mapgen_setting() should be used instead.\" << std::endl;\n\t\tinfostream << script_get_backtrace(L) << std::endl;\n\t\treturn -1;\n\t}\n\tconst char *disallowed[] = {\n\t\t\"main_menu_script\", \"shader_path\", \"texture_path\", \"screenshot_path\",\n\t\t\"serverlist_file\", \"serverlist_url\", \"map-dir\", \"contentdb_url\",\n\t};\n\tif (!is_mainmenu) {\n\t\tfor (const char *name2 : disallowed) {\n\t\t\tif (name == name2)\n\t\t\t\tthrow LuaError(\"Attempted to set disallowed setting.\");\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "const char *cgit_rooturl(void)\n{\n\tif (ctx.cfg.virtual_root)\n\t\treturn ctx.cfg.virtual_root;\n\telse\n\t\treturn ctx.cfg.script_name;\n}", "target": 0}
{"code": "static char sctp_tietags_compare(struct sctp_association *new_asoc,\n\t\t\t\t const struct sctp_association *asoc)\n{\n\tif ((asoc->c.my_vtag != new_asoc->c.my_vtag) &&\n\t    (asoc->c.peer_vtag != new_asoc->c.peer_vtag) &&\n\t    (asoc->c.my_vtag == new_asoc->c.my_ttag) &&\n\t    (asoc->c.peer_vtag == new_asoc->c.peer_ttag))\n\t\treturn 'A';\n\tif ((asoc->c.my_vtag == new_asoc->c.my_vtag) &&\n\t    ((asoc->c.peer_vtag != new_asoc->c.peer_vtag) ||\n\t     (0 == asoc->c.peer_vtag))) {\n\t\treturn 'B';\n\t}\n\tif ((asoc->c.my_vtag == new_asoc->c.my_vtag) &&\n\t    (asoc->c.peer_vtag == new_asoc->c.peer_vtag))\n\t\treturn 'D';\n\tif ((asoc->c.my_vtag != new_asoc->c.my_vtag) &&\n\t    (asoc->c.peer_vtag == new_asoc->c.peer_vtag) &&\n\t    (0 == new_asoc->c.my_ttag) &&\n\t    (0 == new_asoc->c.peer_ttag))\n\t\treturn 'C';\n\treturn 'E';\n}", "target": 0}
{"code": "Adaptation::Ecap::FirstLineRep::protocol() const\n{\n    switch (theMessage.http_ver.protocol) {\n    case AnyP::PROTO_HTTP:\n        return libecap::protocolHttp;\n    case AnyP::PROTO_HTTPS:\n        return libecap::protocolHttps;\n    case AnyP::PROTO_FTP:\n        return libecap::protocolFtp;\n    case AnyP::PROTO_GOPHER:\n        return libecap::protocolGopher;\n    case AnyP::PROTO_WAIS:\n        return libecap::protocolWais;\n    case AnyP::PROTO_WHOIS:\n        return libecap::protocolWhois;\n    case AnyP::PROTO_URN:\n        return libecap::protocolUrn;\n    case AnyP::PROTO_ICP:\n        return protocolIcp;\n#if USE_HTCP\n    case AnyP::PROTO_HTCP:\n        return protocolHtcp;\n#endif\n    case AnyP::PROTO_CACHE_OBJECT:\n        return protocolCacheObj;\n    case AnyP::PROTO_ICY:\n        return protocolIcy;\n    case AnyP::PROTO_COAP:\n    case AnyP::PROTO_COAPS: \n    case AnyP::PROTO_AUTHORITY_FORM:\n    case AnyP::PROTO_SSL:\n    case AnyP::PROTO_TLS:\n    case AnyP::PROTO_UNKNOWN:\n        return protocolUnknown; \n    case AnyP::PROTO_NONE:\n        return Name();\n    case AnyP::PROTO_MAX:\n        break; \n    }\n    Must(false); \n    return Name();\n}", "target": 1}
{"code": "static int result(void)\n{\n\tint i;\n\tint status = 0;\n\tfor (i = 0; i < MAX_REPLIES; i++) {\n\t\tstatus = wait_til_ready();\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus &= STATUS_DIR | STATUS_READY | STATUS_BUSY | STATUS_DMA;\n\t\tif ((status & ~STATUS_BUSY) == STATUS_READY) {\n\t\t\tresultjiffies = jiffies;\n\t\t\tresultsize = i;\n\t\t\treturn i;\n\t\t}\n\t\tif (status == (STATUS_DIR | STATUS_READY | STATUS_BUSY))\n\t\t\treply_buffer[i] = fd_inb(FD_DATA);\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (initialized) {\n\t\tDPRINT(\"get result error. Fdc=%d Last status=%x Read bytes=%d\\n\",\n\t\t       fdc, status, i);\n\t\tshow_floppy();\n\t}\n\tFDCS->reset = 1;\n\treturn -1;\n}", "target": 0}
{"code": "int emulate_int_real(struct x86_emulate_ctxt *ctxt, int irq)\n{\n\tstruct x86_emulate_ops *ops = ctxt->ops;\n\tint rc;\n\tstruct desc_ptr dt;\n\tgva_t cs_addr;\n\tgva_t eip_addr;\n\tu16 cs, eip;\n\tctxt->src.val = ctxt->eflags;\n\trc = em_push(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tctxt->eflags &= ~(EFLG_IF | EFLG_TF | EFLG_AC);\n\tctxt->src.val = get_segment_selector(ctxt, VCPU_SREG_CS);\n\trc = em_push(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tctxt->src.val = ctxt->_eip;\n\trc = em_push(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tops->get_idt(ctxt, &dt);\n\teip_addr = dt.address + (irq << 2);\n\tcs_addr = dt.address + (irq << 2) + 2;\n\trc = ops->read_std(ctxt, cs_addr, &cs, 2, &ctxt->exception);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = ops->read_std(ctxt, eip_addr, &eip, 2, &ctxt->exception);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = load_segment_descriptor(ctxt, cs, VCPU_SREG_CS);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tctxt->_eip = eip;\n\treturn rc;\n}", "target": 0}
{"code": "static void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)\n{\n\tconst struct sched_class *class;\n\tif (p->sched_class == rq->curr->sched_class) {\n\t\trq->curr->sched_class->check_preempt_curr(rq, p, flags);\n\t} else {\n\t\tfor_each_class(class) {\n\t\t\tif (class == rq->curr->sched_class)\n\t\t\t\tbreak;\n\t\t\tif (class == p->sched_class) {\n\t\t\t\tresched_task(rq->curr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (test_tsk_need_resched(rq->curr))\n\t\trq->skip_clock_update = 1;\n}", "target": 1}
{"code": "buf_pos_init(const buf_t *buf, buf_pos_t *out)\n{\n  out->chunk = buf->head;\n  out->pos = 0;\n  out->chunk_pos = 0;\n}", "target": 0}
{"code": "_XcursorAddPathElt (char *path, const char *elt, int len)\n{\n    size_t    pathlen = strlen (path);\n    if (path[0] == '\\0' || path[pathlen - 1] != '/')\n    {\n\tstrcat (path, \"/\");\n\tpathlen++;\n    }\n    if (len == -1)\n\tlen = strlen (elt);\n    while (len && elt[0] == '/')\n    {\n\telt++;\n\tlen--;\n    }\n    strncpy (path + pathlen, elt, len);\n    path[pathlen + len] = '\\0';\n}", "target": 0}
{"code": "format_versions_list(config_line_t *ln)\n{\n  smartlist_t *versions;\n  char *result;\n  versions = smartlist_new();\n  for ( ; ln; ln = ln->next) {\n    smartlist_split_string(versions, ln->value, \",\",\n                           SPLIT_SKIP_SPACE|SPLIT_IGNORE_BLANK, 0);\n  }\n  sort_version_list(versions, 1);\n  result = smartlist_join_strings(versions,\",\",0,NULL);\n  SMARTLIST_FOREACH(versions,char *,s,tor_free(s));\n  smartlist_free(versions);\n  return result;\n}", "target": 0}
{"code": "static void show_object(struct object *object, struct strbuf *path,\n\t\t\tconst char *last, void *data)\n{\n\tstruct bitmap *base = data;\n\tint bitmap_pos;\n\tbitmap_pos = bitmap_position(object->oid.hash);\n\tif (bitmap_pos < 0) {\n\t\tchar *name = path_name(path, last);\n\t\tbitmap_pos = ext_index_add_object(object, name);\n\t\tfree(name);\n\t}\n\tbitmap_set(base, bitmap_pos);\n}", "target": 1}
{"code": "static boolean str_fill_input_buffer(j_decompress_ptr cinfo)\n{\n    int c;\n    struct str_src_mgr *src = (struct str_src_mgr *)cinfo->src;\n    if (src->index == 0) {\n        c = 0xFF;\n        src->index++;\n    } else if (src->index == 1) {\n        c = 0xD8;\n        src->index++;\n    } else\n        c = src->str->getChar();\n    if (c != EOF) {\n        src->buffer = c;\n        src->pub.next_input_byte = &src->buffer;\n        src->pub.bytes_in_buffer = 1;\n        return TRUE;\n    } else\n        return FALSE;\n}", "target": 0}
{"code": "static ssize_t cgroup_release_agent_write(struct kernfs_open_file *of,\n\t\t\t\t\t  char *buf, size_t nbytes, loff_t off)\n{\n\tstruct cgroup *cgrp;\n\tBUILD_BUG_ON(sizeof(cgrp->root->release_agent_path) < PATH_MAX);\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENODEV;\n\tspin_lock(&release_agent_path_lock);\n\tstrlcpy(cgrp->root->release_agent_path, strstrip(buf),\n\t\tsizeof(cgrp->root->release_agent_path));\n\tspin_unlock(&release_agent_path_lock);\n\tcgroup_kn_unlock(of->kn);\n\treturn nbytes;\n}", "target": 1}
{"code": "int gnutls_x509_ext_import_subject_alt_names(const gnutls_datum_t * ext,\n\t\t\t\t\t  gnutls_subject_alt_names_t sans,\n\t\t\t\t\t  unsigned int flags)\n{\n\tASN1_TYPE c2 = ASN1_TYPE_EMPTY;\n\tint result, ret;\n\tunsigned int i;\n\tgnutls_datum_t san, othername_oid;\n\tunsigned type;\n\tresult =\n\t    asn1_create_element(_gnutls_get_pkix(), \"PKIX1.GeneralNames\", &c2);\n\tif (result != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\treturn _gnutls_asn2err(result);\n\t}\n\tresult = asn1_der_decoding(&c2, ext->data, ext->size, NULL);\n\tif (result != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\tret = _gnutls_asn2err(result);\n\t\tgoto cleanup;\n\t}\n\ti = 0;\n\tdo {\n\t\tsan.data = NULL;\n\t\tsan.size = 0;\n\t\tothername_oid.data = NULL;\n\t\tret = _gnutls_parse_general_name2(c2, \"\", i, &san, &type, 0);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (type == GNUTLS_SAN_OTHERNAME) {\n\t\t\tret =\n\t\t\t    _gnutls_parse_general_name2(c2, \"\", i,\n\t\t\t\t\t\t\t&othername_oid,\n\t\t\t\t\t\t\tNULL, 1);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t} else if (san.size == 0 || san.data == NULL) {\n\t\t\tret = gnutls_assert_val(GNUTLS_E_X509_UNKNOWN_SAN);\n\t\t\tbreak;\n\t\t}\n\t\tret = subject_alt_names_set(&sans->names, &sans->size,\n\t\t\t\t\t    type, &san,\n\t\t\t\t\t    (char *)othername_oid.data);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\ti++;\n\t} while (ret >= 0);\n\tsans->size = i;\n\tif (ret < 0 && ret != GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE) {\n\t\tgnutls_free(san.data);\n\t\tgnutls_free(othername_oid.data);\n\t\tgnutls_assert();\n\t\tgoto cleanup;\n\t}\n\tret = 0;\n cleanup:\n\tasn1_delete_structure(&c2);\n\treturn ret;\n}", "target": 0}
{"code": "    CImg<T>& RGBtoHSV() {\n      if (_spectrum!=3)\n        throw CImgInstanceException(_cimg_instance\n                                    \"RGBtoHSV(): Instance is not a RGB image.\",\n                                    cimg_instance);\n      T *p1 = data(0,0,0,0), *p2 = data(0,0,0,1), *p3 = data(0,0,0,2);\n      const ulongT whd = (ulongT)_width*_height*_depth;\n      cimg_pragma_openmp(parallel for cimg_openmp_if(whd>=256))\n      for (ulongT N = 0; N<whd; ++N) {\n        const Tfloat\n          R = (Tfloat)p1[N],\n          G = (Tfloat)p2[N],\n          B = (Tfloat)p3[N],\n          m = cimg::min(R,G,B),\n          M = cimg::max(R,G,B);\n        Tfloat H = 0, S = 0;\n        if (M!=m) {\n          const Tfloat\n            f = R==m?G - B:G==m?B - R:R - G,\n            i = R==m?3:G==m?5:1;\n          H = i - f/(M - m);\n          if (H>=6) H-=6;\n          H*=60;\n          S = (M - m)/M;\n        }\n        p1[N] = (T)cimg::cut(H,0,360);\n        p2[N] = (T)cimg::cut(S,0,1);\n        p3[N] = (T)cimg::cut(M/255,0,1);\n      }\n      return *this;", "target": 0}
{"code": "static int unload_module(void)\n{\n\tast_cli_unregister_multiple(cli_identify, ARRAY_LEN(cli_identify));\n\tast_sip_unregister_cli_formatter(cli_formatter);\n\tast_sip_unregister_endpoint_formatter(&endpoint_identify_formatter);\n\tast_sip_unregister_endpoint_identifier(&header_identifier);\n\tast_sip_unregister_endpoint_identifier(&request_identifier);\n\tast_sip_unregister_endpoint_identifier(&ip_identifier);\n\tast_sip_unregister_endpoint_identifier(&transport_identifier);\n\treturn 0;\n}", "target": 1}
{"code": "static void flush_busy_ctxs(struct blk_mq_hw_ctx *hctx, struct list_head *list)\n{\n\tstruct blk_mq_ctx *ctx;\n\tint i;\n\tfor (i = 0; i < hctx->ctx_map.size; i++) {\n\t\tstruct blk_align_bitmap *bm = &hctx->ctx_map.map[i];\n\t\tunsigned int off, bit;\n\t\tif (!bm->word)\n\t\t\tcontinue;\n\t\tbit = 0;\n\t\toff = i * hctx->ctx_map.bits_per_word;\n\t\tdo {\n\t\t\tbit = find_next_bit(&bm->word, bm->depth, bit);\n\t\t\tif (bit >= bm->depth)\n\t\t\t\tbreak;\n\t\t\tctx = hctx->ctxs[bit + off];\n\t\t\tclear_bit(bit, &bm->word);\n\t\t\tspin_lock(&ctx->lock);\n\t\t\tlist_splice_tail_init(&ctx->rq_list, list);\n\t\t\tspin_unlock(&ctx->lock);\n\t\t\tbit++;\n\t\t} while (1);\n\t}\n}", "target": 0}
{"code": "int git_pkt_buffer_wants(\n\tconst git_remote_head * const *refs,\n\tsize_t count,\n\ttransport_smart_caps *caps,\n\tgit_buf *buf)\n{\n\tsize_t i = 0;\n\tconst git_remote_head *head;\n\tif (caps->common) {\n\t\tfor (; i < count; ++i) {\n\t\t\thead = refs[i];\n\t\t\tif (!head->local)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (buffer_want_with_caps(refs[i], caps, buf) < 0)\n\t\t\treturn -1;\n\t\ti++;\n\t}\n\tfor (; i < count; ++i) {\n\t\tchar oid[GIT_OID_HEXSZ];\n\t\thead = refs[i];\n\t\tif (head->local)\n\t\t\tcontinue;\n\t\tgit_oid_fmt(oid, &head->oid);\n\t\tgit_buf_put(buf, pkt_want_prefix, strlen(pkt_want_prefix));\n\t\tgit_buf_put(buf, oid, GIT_OID_HEXSZ);\n\t\tgit_buf_putc(buf, '\\n');\n\t\tif (git_buf_oom(buf))\n\t\t\treturn -1;\n\t}\n\treturn git_pkt_buffer_flush(buf);\n}", "target": 0}
{"code": "int sas_discover_end_dev(struct domain_device *dev)\n{\n\tint res;\n\tres = sas_notify_lldd_dev_found(dev);\n\tif (res)\n\t\treturn res;\n\tsas_discover_event(dev->port, DISCE_PROBE);\n\treturn 0;\n}", "target": 1}
{"code": "            bool isValid() const\n            {\n                return version_ != -1;\n            }", "target": 0}
{"code": "static int do_insn_fetch(struct x86_emulate_ctxt *ctxt,\n\t\t\t struct x86_emulate_ops *ops,\n\t\t\t unsigned long eip, void *dest, unsigned size)\n{\n\tint rc = 0;\n\teip += ctxt->cs_base;\n\twhile (size--) {\n\t\trc = do_fetch_insn_byte(ctxt, ops, eip++, dest++);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "sync_path (struct url *u)\n{\n  char *newpath, *efile, *edir;\n  xfree (u->path);\n  edir = url_escape_dir (u->dir);\n  efile = url_escape_1 (u->file, urlchr_unsafe | urlchr_reserved, 1);\n  if (!*edir)\n    newpath = xstrdup (efile);\n  else\n    {\n      int dirlen = strlen (edir);\n      int filelen = strlen (efile);\n      char *p = newpath = xmalloc (dirlen + 1 + filelen + 1);\n      memcpy (p, edir, dirlen);\n      p += dirlen;\n      *p++ = '/';\n      memcpy (p, efile, filelen);\n      p += filelen;\n      *p = '\\0';\n    }\n  u->path = newpath;\n  if (edir != u->dir)\n    xfree (edir);\n  if (efile != u->file)\n    xfree (efile);\n  xfree (u->url);\n  u->url = url_string (u, URL_AUTH_SHOW);\n}", "target": 0}
{"code": "static void nfs_idmap_quit_keyring(void)\n{\n\tkey_revoke(id_resolver_cache->thread_keyring);\n\tunregister_key_type(&key_type_id_resolver);\n\tunregister_key_type(&key_type_id_resolver_legacy);\n\tput_cred(id_resolver_cache);\n}", "target": 0}
{"code": "de265_error decoder_context::decode(int* more)\n{\n  decoder_context* ctx = this;\n  if (ctx->nal_parser.get_NAL_queue_length() == 0 &&\n      (ctx->nal_parser.is_end_of_stream() || ctx->nal_parser.is_end_of_frame()) &&\n      ctx->image_units.empty()) {\n    ctx->dpb.flush_reorder_buffer();\n    if (more) { *more = ctx->dpb.num_pictures_in_output_queue(); }\n    return DE265_OK;\n  }\n  if (ctx->nal_parser.is_end_of_stream() == false &&\n      ctx->nal_parser.is_end_of_frame() == false &&\n      ctx->nal_parser.get_NAL_queue_length() == 0) {\n    if (more) { *more=1; }\n    return DE265_ERROR_WAITING_FOR_INPUT_DATA;\n  }\n  if (!ctx->dpb.has_free_dpb_picture(false)) {\n    if (more) *more = 1;\n    return DE265_ERROR_IMAGE_BUFFER_FULL;\n  }\n  de265_error err = DE265_OK;\n  bool did_work = false;\n  if (ctx->nal_parser.get_NAL_queue_length()) { \n    NAL_unit* nal = ctx->nal_parser.pop_from_NAL_queue();\n    assert(nal);\n    err = ctx->decode_NAL(nal);\n    did_work=true;\n  }\n  else if (ctx->nal_parser.is_end_of_frame() == true &&\n      ctx->image_units.empty()) {\n    if (more) { *more=1; }\n    return DE265_ERROR_WAITING_FOR_INPUT_DATA;\n  }\n  else {\n    err = decode_some(&did_work);\n  }\n  if (more) {\n    *more = (err==DE265_OK && did_work);\n  }\n  return err;\n}", "target": 0}
{"code": "systemd_unit_name_escape (const gchar *in)\n{\n  GString * const str = g_string_sized_new (strlen (in));\n  for (; *in; in++)\n    {\n      if (g_ascii_isalnum (*in) || *in == ':' || *in == '_' || *in == '.')\n        g_string_append_c (str, *in);\n      else\n        g_string_append_printf (str, \"\\\\x%02x\", *in);\n    }\n  return g_string_free (str, FALSE);\n}", "target": 0}
{"code": "print_arrays_for(char *set)\n{\n  FILE *f;\n  sprintf(buf, \"%s.conf\", set);\n  if ((f = fopen(buf, \"r\")) == NULL) {\n    fprintf(stderr, \"%s: can't read conf file for charset %s\\n\", prog, set);\n    exit(EXIT_FAILURE);\n  }\n  printf(\"\\\n\\n\\n\",\n\t set, prog);\n  print_array(f, set, \"ctype\",      CTYPE_TABLE_SIZE);\n  print_array(f, set, \"to_lower\",   TO_LOWER_TABLE_SIZE);\n  print_array(f, set, \"to_upper\",   TO_UPPER_TABLE_SIZE);\n  print_array(f, set, \"sort_order\", SORT_ORDER_TABLE_SIZE);\n  printf(\"\\n\");\n  fclose(f);\n  return;\n}", "target": 1}
{"code": "static void vmx_set_msr_bitmap(struct kvm_vcpu *vcpu)\n{\n\tunsigned long *msr_bitmap;\n\tif (is_guest_mode(vcpu))\n\t\tmsr_bitmap = vmx_msr_bitmap_nested;\n\telse if (vcpu->arch.apic_base & X2APIC_ENABLE) {\n\t\tif (is_long_mode(vcpu))\n\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode_x2apic;\n\t\telse\n\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy_x2apic;\n\t} else {\n\t\tif (is_long_mode(vcpu))\n\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode;\n\t\telse\n\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy;\n\t}\n\tvmcs_write64(MSR_BITMAP, __pa(msr_bitmap));\n}", "target": 1}
{"code": "static void edge_tty_recv(struct usb_serial_port *port, unsigned char *data,\n\t\tint length)\n{\n\tint queued;\n\tqueued = tty_insert_flip_string(&port->port, data, length);\n\tif (queued < length)\n\t\tdev_err(&port->dev, \"%s - dropping data, %d bytes lost\\n\",\n\t\t\t__func__, length - queued);\n\ttty_flip_buffer_push(&port->port);\n}", "target": 0}
{"code": "ssh_packet_set_postauth(struct ssh *ssh)\n{\n\tstruct sshcomp *comp;\n\tint r, mode;\n\tdebug(\"%s: called\", __func__);\n\tssh->state->after_authentication = 1;\n\tssh->state->rekeying = 0;\n\tfor (mode = 0; mode < MODE_MAX; mode++) {\n\t\tif (ssh->state->newkeys[mode] == NULL)\n\t\t\tcontinue;\n\t\tcomp = &ssh->state->newkeys[mode]->comp;\n\t\tif (comp && comp->enabled &&\n\t\t    (r = ssh_packet_init_compression(ssh)) != 0)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static inline int ff_fast_malloc(void *ptr, unsigned int *size, size_t min_size, int zero_realloc)\n{\n    void **p = ptr;\n    if (min_size < *size)\n        return 0;\n    min_size = FFMAX(17 * min_size / 16 + 32, min_size);\n    av_free(*p);\n    *p = zero_realloc ? av_mallocz(min_size) : av_malloc(min_size);\n    if (!*p)\n        min_size = 0;\n    *size = min_size;\n    return 1;\n}", "target": 0}
{"code": "hash_link_ref(const uint8_t *link_ref, size_t length)\n{\n\tsize_t i;\n\tunsigned int hash = 0;\n\tfor (i = 0; i < length; ++i)\n\t\thash = tolower(link_ref[i]) + (hash << 6) + (hash << 16) - hash;\n\treturn hash;\n}", "target": 1}
{"code": "_parse_config_file(pam_handle_t *pamh, int ctrl, const char *file)\n{\n    int retval;\n    char buffer[BUF_SIZE];\n    FILE *conf;\n    VAR Var, *var=&Var;\n    D((\"Called.\"));\n    var->name=NULL; var->defval=NULL; var->override=NULL;\n    D((\"Config file name is: %s\", file));\n    if ((conf = fopen(file,\"r\")) == NULL) {\n      pam_syslog(pamh, LOG_ERR, \"Unable to open config file: %s: %m\", file);\n      return PAM_IGNORE;\n    }\n    while (( retval = _assemble_line(conf, buffer, BUF_SIZE)) > 0) {\n      D((\"Read line: %s\", buffer));\n      if ((retval = _parse_line(pamh, buffer, var)) == GOOD_LINE) {\n\tretval = _check_var(pamh, var);\n\tif (DEFINE_VAR == retval) {\n\t  retval = _define_var(pamh, ctrl, var);\n\t} else if (UNDEFINE_VAR == retval) {\n\t  retval = _undefine_var(pamh, ctrl, var);\n\t}\n      }\n      if (PAM_SUCCESS != retval && ILLEGAL_VAR != retval\n\t  && BAD_LINE != retval && PAM_BAD_ITEM != retval) break;\n      _clean_var(var);\n    }  \n    (void) fclose(conf);\n    _clean_var(var);        \n    D((\"Exit.\"));\n    return (retval != 0 ? PAM_ABORT : PAM_SUCCESS);\n}", "target": 0}
{"code": "  void *realloc(void *ptr, size_t newsz)\n  {\n    void *ret = ::realloc(ptr, newsz + extra_bytes);\n    forget_ptr(ptr);\n    mem_ptr(ret);\n    return ret;\n  }", "target": 0}
{"code": "static void rtc_irq_eoi_tracking_reset(struct kvm_ioapic *ioapic)\n{\n\tioapic->rtc_status.pending_eoi = 0;\n\tbitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPUS);\n}", "target": 1}
{"code": "static void record_recent_object(struct object *obj,\n\t\t\t\t struct strbuf *path,\n\t\t\t\t const char *last,\n\t\t\t\t void *data)\n{\n\tsha1_array_append(&recent_objects, obj->oid.hash);\n}", "target": 1}
{"code": "void SSH_Access::LogSSHMessage()\n{\n   const char *b;\n   int s;\n   pty_recv_buf->Get(&b,&s);\n   const char *eol=find_char(b,s,'\\n');\n   if(!eol)\n   {\n      if(pty_recv_buf->Eof())\n      {\n\t if(s>0)\n\t    LogRecv(4,b);\n\t LogError(0,_(\"Peer closed connection\"));\n      }\n      if(pty_recv_buf->Error())\n\t LogError(4,\"pty read: %s\",pty_recv_buf->ErrorText());\n      if(pty_recv_buf->Eof() || pty_recv_buf->Error()) {\n\t if(last_ssh_message && time_t(now)-last_ssh_message_time<4)\n\t    LogError(0,\"%s\",last_ssh_message.get());\n\t Disconnect(last_ssh_message);\n      }\n      return;\n   }\n   s=eol-b+1;\n   int chomp_cr=(s>=2 && b[s-2]=='\\r');\n   last_ssh_message.nset(b,s-1-chomp_cr);\n   last_ssh_message_time=now;\n   pty_recv_buf->Skip(s);\n   LogRecv(4,last_ssh_message);\n   if(last_ssh_message.begins_with(\"ssh: \"))\n      last_ssh_message.set(last_ssh_message+5);\n   if(!received_greeting && last_ssh_message.eq(greeting))\n      received_greeting=true;\n}", "target": 0}
{"code": "static void _ltc_ecc_free_public_key(struct ecc_public_key *s)\n{\n\tif (!s)\n\t\treturn;\n\tcrypto_bignum_free(s->x);\n\tcrypto_bignum_free(s->y);\n}", "target": 1}
{"code": "static inline unsigned long copy_shmid_to_user(void __user *buf, struct shmid64_ds *in, int version)\n{\n\tswitch (version) {\n\tcase IPC_64:\n\t\treturn copy_to_user(buf, in, sizeof(*in));\n\tcase IPC_OLD:\n\t    {\n\t\tstruct shmid_ds out;\n\t\tmemset(&out, 0, sizeof(out));\n\t\tipc64_perm_to_ipc_perm(&in->shm_perm, &out.shm_perm);\n\t\tout.shm_segsz\t= in->shm_segsz;\n\t\tout.shm_atime\t= in->shm_atime;\n\t\tout.shm_dtime\t= in->shm_dtime;\n\t\tout.shm_ctime\t= in->shm_ctime;\n\t\tout.shm_cpid\t= in->shm_cpid;\n\t\tout.shm_lpid\t= in->shm_lpid;\n\t\tout.shm_nattch\t= in->shm_nattch;\n\t\treturn copy_to_user(buf, &out, sizeof(out));\n\t    }\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}", "target": 0}
{"code": "static void execlists_destroy(struct intel_engine_cs *engine)\n{\n\tintel_engine_cleanup_common(engine);\n\tlrc_destroy_wa_ctx(engine);\n\tkfree(engine);\n}", "target": 0}
{"code": "void decompTest(tjhandle handle, unsigned char *jpegBuf,\n\tunsigned long jpegSize, int w, int h, int pf, char *basename, int subsamp,\n\tint flags)\n{\n\tint i, n=0;\n\ttjscalingfactor *sf=tjGetScalingFactors(&n);\n\tif(!sf || !n) _throwtj();\n\tfor(i=0; i<n; i++)\n\t{\n\t\tif(subsamp==TJSAMP_444 || subsamp==TJSAMP_GRAY ||\n\t\t\t(subsamp==TJSAMP_411 && sf[i].num==1 &&\n\t\t\t\t(sf[i].denom==2 || sf[i].denom==1)) ||\n\t\t\t(subsamp!=TJSAMP_411 && sf[i].num==1 &&\n\t\t\t\t(sf[i].denom==4 || sf[i].denom==2 || sf[i].denom==1)))\n\t\t\t_decompTest(handle, jpegBuf, jpegSize, w, h, pf, basename, subsamp,\n\t\t\t\tflags, sf[i]);\n\t}\n\tbailout:\n\treturn;\n}", "target": 0}
{"code": "static int getid(char ch) {\n\tconst char *keys = \"[]<>+-,.\";\n\tconst char *cidx = strchr (keys, ch);\n\treturn cidx? cidx - keys + 1: 0;\n}", "target": 1}
{"code": "dirvote_get_vote(const char *fp, int flags)\n{\n  int by_id = flags & DGV_BY_ID;\n  const int include_pending = flags & DGV_INCLUDE_PENDING;\n  const int include_previous = flags & DGV_INCLUDE_PREVIOUS;\n  if (!pending_vote_list && !previous_vote_list)\n    return NULL;\n  if (fp == NULL) {\n    authority_cert_t *c = get_my_v3_authority_cert();\n    if (c) {\n      fp = c->cache_info.identity_digest;\n      by_id = 1;\n    } else\n      return NULL;\n  }\n  if (by_id) {\n    if (pending_vote_list && include_pending) {\n      SMARTLIST_FOREACH(pending_vote_list, pending_vote_t *, pv,\n        if (fast_memeq(get_voter(pv->vote)->identity_digest, fp, DIGEST_LEN))\n          return pv->vote_body);\n    }\n    if (previous_vote_list && include_previous) {\n      SMARTLIST_FOREACH(previous_vote_list, pending_vote_t *, pv,\n        if (fast_memeq(get_voter(pv->vote)->identity_digest, fp, DIGEST_LEN))\n          return pv->vote_body);\n    }\n  } else {\n    if (pending_vote_list && include_pending) {\n      SMARTLIST_FOREACH(pending_vote_list, pending_vote_t *, pv,\n        if (fast_memeq(pv->vote->digests.d[DIGEST_SHA1], fp, DIGEST_LEN))\n          return pv->vote_body);\n    }\n    if (previous_vote_list && include_previous) {\n      SMARTLIST_FOREACH(previous_vote_list, pending_vote_t *, pv,\n        if (fast_memeq(pv->vote->digests.d[DIGEST_SHA1], fp, DIGEST_LEN))\n          return pv->vote_body);\n    }\n  }\n  return NULL;\n}", "target": 0}
{"code": "int bio_uncopy_user(struct bio *bio)\n{\n\tstruct bio_map_data *bmd = bio->bi_private;\n\tint ret = 0;\n\tif (!bio_flagged(bio, BIO_NULL_MAPPED)) {\n\t\tif (!current->mm)\n\t\t\tret = -EINTR;\n\t\telse if (bio_data_dir(bio) == READ)\n\t\t\tret = bio_copy_to_iter(bio, bmd->iter);\n\t\tif (bmd->is_our_pages)\n\t\t\tbio_free_pages(bio);\n\t}\n\tkfree(bmd);\n\tbio_put(bio);\n\treturn ret;\n}", "target": 0}
{"code": "Status FunctionLibraryDefinition::AddGradientDef(const GradientDef& grad) {\n  mutex_lock l(mu_);\n  bool added;\n  return AddGradientDefHelper(grad, &added);\n}", "target": 0}
{"code": "static int rds_recv_track_latency(struct rds_sock *rs, char __user *optval,\n\t\t\t\t  int optlen)\n{\n\tstruct rds_rx_trace_so trace;\n\tint i;\n\tif (optlen != sizeof(struct rds_rx_trace_so))\n\t\treturn -EFAULT;\n\tif (copy_from_user(&trace, optval, sizeof(trace)))\n\t\treturn -EFAULT;\n\trs->rs_rx_traces = trace.rx_traces;\n\tfor (i = 0; i < rs->rs_rx_traces; i++) {\n\t\tif (trace.rx_trace_pos[i] > RDS_MSG_RX_DGRAM_TRACE_MAX) {\n\t\t\trs->rs_rx_traces = 0;\n\t\t\treturn -EFAULT;\n\t\t}\n\t\trs->rs_rx_trace[i] = trace.rx_trace_pos[i];\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void mk_request_free(struct session_request *sr)\n{\n    if (sr->fd_file > 0) {\n        mk_vhost_close(sr);\n    }\n    if (sr->headers.location) {\n        mk_mem_free(sr->headers.location);\n    }\n    if (sr->uri_processed.data != sr->uri.data) {\n        mk_ptr_free(&sr->uri_processed);\n    }\n    if (sr->real_path.data != sr->real_path_static) {\n        mk_ptr_free(&sr->real_path);\n    }\n}", "target": 1}
{"code": "checked_xmalloc (size_t size)\n{\n    alloc_limit_assert (\"checked_xmalloc\", size);\n    return xmalloc (size);\n}", "target": 1}
{"code": "void posix_cpu_timer_get(struct k_itimer *timer, struct itimerspec *itp)\n{\n\tunion cpu_time_count now;\n\tstruct task_struct *p = timer->it.cpu.task;\n\tint clear_dead;\n\tsample_to_timespec(timer->it_clock,\n\t\t\t   timer->it.cpu.incr, &itp->it_interval);\n\tif (timer->it.cpu.expires.sched == 0) {\t\n\t\titp->it_value.tv_sec = itp->it_value.tv_nsec = 0;\n\t\treturn;\n\t}\n\tif (unlikely(p == NULL)) {\n\tdead:\n\t\tsample_to_timespec(timer->it_clock, timer->it.cpu.expires,\n\t\t\t\t   &itp->it_value);\n\t\treturn;\n\t}\n\tif (CPUCLOCK_PERTHREAD(timer->it_clock)) {\n\t\tcpu_clock_sample(timer->it_clock, p, &now);\n\t\tclear_dead = p->exit_state;\n\t} else {\n\t\tread_lock(&tasklist_lock);\n\t\tif (unlikely(p->signal == NULL)) {\n\t\t\tput_task_struct(p);\n\t\t\ttimer->it.cpu.task = NULL;\n\t\t\ttimer->it.cpu.expires.sched = 0;\n\t\t\tread_unlock(&tasklist_lock);\n\t\t\tgoto dead;\n\t\t} else {\n\t\t\tcpu_clock_sample_group(timer->it_clock, p, &now);\n\t\t\tclear_dead = (unlikely(p->exit_state) &&\n\t\t\t\t      thread_group_empty(p));\n\t\t}\n\t\tread_unlock(&tasklist_lock);\n\t}\n\tif ((timer->it_sigev_notify & ~SIGEV_THREAD_ID) == SIGEV_NONE) {\n\t\tif (timer->it.cpu.incr.sched == 0 &&\n\t\t    cpu_time_before(timer->it_clock,\n\t\t\t\t    timer->it.cpu.expires, now)) {\n\t\t\ttimer->it.cpu.expires.sched = 0;\n\t\t\titp->it_value.tv_sec = itp->it_value.tv_nsec = 0;\n\t\t\treturn;\n\t\t}\n\t\tbump_cpu_timer(timer, now);\n\t}\n\tif (unlikely(clear_dead)) {\n\t\tclear_dead_task(timer, now);\n\t\tgoto dead;\n\t}\n\tif (cpu_time_before(timer->it_clock, now, timer->it.cpu.expires)) {\n\t\tsample_to_timespec(timer->it_clock,\n\t\t\t\t   cpu_time_sub(timer->it_clock,\n\t\t\t\t\t\ttimer->it.cpu.expires, now),\n\t\t\t\t   &itp->it_value);\n\t} else {\n\t\titp->it_value.tv_nsec = 1;\n\t\titp->it_value.tv_sec = 0;\n\t}\n}", "target": 0}
{"code": "cdf_dump_catalog(const cdf_header_t *h, const cdf_stream_t *sst)\n{\n\tcdf_catalog_t *cat;\n\tcdf_unpack_catalog(h, sst, &cat);\n\tconst cdf_catalog_entry_t *ce = cat->cat_e;\n\tstruct timespec ts;\n\tchar tbuf[64], sbuf[256];\n\tsize_t i;\n\tprintf(\"Catalog:\\n\");\n\tfor (i = 0; i < cat->cat_num; i++) {\n\t\tcdf_timestamp_to_timespec(&ts, ce[i].ce_timestamp);\n\t\tprintf(\"\\t%d %s %s\", ce[i].ce_num,\n\t\t    cdf_u16tos8(sbuf, ce[i].ce_namlen, ce[i].ce_name),\n\t\t    cdf_ctime(&ts.tv_sec, tbuf));\n\t}\n\tfree(cat);\n}", "target": 0}
{"code": "static UInt32 GetUsedMemory(const CPpmd8 *p)\n{\n  UInt32 v = 0;\n  unsigned i;\n  for (i = 0; i < PPMD_NUM_INDEXES; i++)\n    v += p->Stamps[i] * I2U(i);\n  return p->Size - (UInt32)(p->HiUnit - p->LoUnit) - (UInt32)(p->UnitsStart - p->Text) - U2B(v);\n}", "target": 0}
{"code": "void gf_isom_check_position(GF_Box *s, GF_Box *child, u32 *pos)\n{\n\tif (!s || !s->child_boxes || !child || !pos) return;\n\tif (s->internal_flags & GF_ISOM_ORDER_FREEZE)\n\t\treturn;\n\ts32 cur_pos = gf_list_find(s->child_boxes, child);\n\tif (cur_pos < 0) return;\n\tif (cur_pos != (s32) *pos) {\n\t\tgf_list_del_item(s->child_boxes, child);\n\t\tgf_list_insert(s->child_boxes, child, *pos);\n\t}\n\t(*pos)++;", "target": 1}
{"code": "static int emulator_pio_in_out(struct kvm_vcpu *vcpu, int size,\n\t\t\t       unsigned short port, void *val,\n\t\t\t       unsigned int count, bool in)\n{\n\tvcpu->arch.pio.port = port;\n\tvcpu->arch.pio.in = in;\n\tvcpu->arch.pio.count  = count;\n\tvcpu->arch.pio.size = size;\n\tif (!kernel_pio(vcpu, vcpu->arch.pio_data)) {\n\t\tvcpu->arch.pio.count = 0;\n\t\treturn 1;\n\t}\n\tvcpu->run->exit_reason = KVM_EXIT_IO;\n\tvcpu->run->io.direction = in ? KVM_EXIT_IO_IN : KVM_EXIT_IO_OUT;\n\tvcpu->run->io.size = size;\n\tvcpu->run->io.data_offset = KVM_PIO_PAGE_OFFSET * PAGE_SIZE;\n\tvcpu->run->io.count = count;\n\tvcpu->run->io.port = port;\n\treturn 0;\n}", "target": 0}
{"code": "ppp_create_interface(struct net *net, int unit, int *retp)\n{\n\tstruct ppp *ppp;\n\tstruct ppp_net *pn;\n\tstruct net_device *dev = NULL;\n\tint ret = -ENOMEM;\n\tint i;\n\tdev = alloc_netdev(sizeof(struct ppp), \"\", ppp_setup);\n\tif (!dev)\n\t\tgoto out1;\n\tpn = ppp_pernet(net);\n\tppp = netdev_priv(dev);\n\tppp->dev = dev;\n\tppp->mru = PPP_MRU;\n\tinit_ppp_file(&ppp->file, INTERFACE);\n\tppp->file.hdrlen = PPP_HDRLEN - 2;\t\n\tfor (i = 0; i < NUM_NP; ++i)\n\t\tppp->npmode[i] = NPMODE_PASS;\n\tINIT_LIST_HEAD(&ppp->channels);\n\tspin_lock_init(&ppp->rlock);\n\tspin_lock_init(&ppp->wlock);\n#ifdef CONFIG_PPP_MULTILINK\n\tppp->minseq = -1;\n\tskb_queue_head_init(&ppp->mrq);\n#endif \n\tdev_net_set(dev, net);\n\tret = -EEXIST;\n\tmutex_lock(&pn->all_ppp_mutex);\n\tif (unit < 0) {\n\t\tunit = unit_get(&pn->units_idr, ppp);\n\t\tif (unit < 0) {\n\t\t\t*retp = unit;\n\t\t\tgoto out2;\n\t\t}\n\t} else {\n\t\tif (unit_find(&pn->units_idr, unit))\n\t\t\tgoto out2; \n\t\tunit = unit_set(&pn->units_idr, ppp, unit);\n\t\tif (unit < 0)\n\t\t\tgoto out2;\n\t}\n\tppp->file.index = unit;\n\tsprintf(dev->name, \"ppp%d\", unit);\n\tret = register_netdev(dev);\n\tif (ret != 0) {\n\t\tunit_put(&pn->units_idr, unit);\n\t\tprintk(KERN_ERR \"PPP: couldn't register device %s (%d)\\n\",\n\t\t       dev->name, ret);\n\t\tgoto out2;\n\t}\n\tppp->ppp_net = net;\n\tatomic_inc(&ppp_unit_count);\n\tmutex_unlock(&pn->all_ppp_mutex);\n\t*retp = 0;\n\treturn ppp;\nout2:\n\tmutex_unlock(&pn->all_ppp_mutex);\n\tfree_netdev(dev);\nout1:\n\t*retp = ret;\n\treturn NULL;\n}", "target": 0}
{"code": "static inline __u32 secure_dccpv6_sequence_number(__be32 *saddr, __be32 *daddr,\n\t\t\t\t\t\t  __be16 sport, __be16 dport   )\n{\n\treturn secure_tcpv6_sequence_number(saddr, daddr, sport, dport);\n}", "target": 1}
{"code": "static void tcp_send_challenge_ack(struct sock *sk, const struct sk_buff *skb)\n{\n\tstatic u32 challenge_timestamp;\n\tstatic unsigned int challenge_count;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 count, now;\n\tif (tcp_oow_rate_limited(sock_net(sk), skb,\n\t\t\t\t LINUX_MIB_TCPACKSKIPPEDCHALLENGE,\n\t\t\t\t &tp->last_oow_ack_time))\n\t\treturn;\n\tnow = jiffies / HZ;\n\tif (now != challenge_timestamp) {\n\t\tu32 half = (sysctl_tcp_challenge_ack_limit + 1) >> 1;\n\t\tchallenge_timestamp = now;\n\t\tWRITE_ONCE(challenge_count, half +\n\t\t\t   prandom_u32_max(sysctl_tcp_challenge_ack_limit));\n\t}\n\tcount = READ_ONCE(challenge_count);\n\tif (count > 0) {\n\t\tWRITE_ONCE(challenge_count, count - 1);\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPCHALLENGEACK);\n\t\ttcp_send_ack(sk);\n\t}\n}", "target": 0}
{"code": "TEST_F(EncryptedRecordTest, TestAllPaddingHandshake) {\n  addToQueue(\"17030100050123456789\");\n  EXPECT_CALL(*readAead_, _decrypt(_, _, 0))\n      .WillOnce(Invoke([](std::unique_ptr<IOBuf>& buf, const IOBuf*, uint64_t) {\n        expectSame(buf, \"0123456789\");\n        return getBuf(\"16000000\");\n      }));\n  EXPECT_NO_THROW(read_.read(queue_));\n}", "target": 1}
{"code": "comics_document_document_thumbnails_iface_init (EvDocumentThumbnailsInterface *iface)\n{\n\tiface->get_thumbnail = comics_document_thumbnails_get_thumbnail;\n\tiface->get_dimensions = comics_document_thumbnails_get_dimensions;\n}", "target": 1}
{"code": "static void kvm_get_wallclock(struct timespec *now)\n{\n\tstruct pvclock_vcpu_time_info *vcpu_time;\n\tint low, high;\n\tint cpu;\n\tlow = (int)__pa_symbol(&wall_clock);\n\thigh = ((u64)__pa_symbol(&wall_clock) >> 32);\n\tnative_write_msr(msr_kvm_wall_clock, low, high);\n\tcpu = get_cpu();\n\tvcpu_time = &hv_clock[cpu].pvti;\n\tpvclock_read_wallclock(&wall_clock, vcpu_time, now);\n\tput_cpu();\n}", "target": 0}
{"code": "static void copy_fields(const FieldMatchContext *fm, AVFrame *dst,\n                        const AVFrame *src, int field)\n{\n    int plane;\n    for (plane = 0; plane < 4 && src->data[plane]; plane++)\n        av_image_copy_plane(dst->data[plane] + field*dst->linesize[plane], dst->linesize[plane] << 1,\n                            src->data[plane] + field*src->linesize[plane], src->linesize[plane] << 1,\n                            get_width(fm, src, plane), get_height(fm, src, plane) / 2);\n}", "target": 1}
{"code": "vrrp_tfile_end_handler(void)\n{\n\tvrrp_tracked_file_t *tfile = LIST_TAIL_DATA(vrrp_data->vrrp_track_files);\n\tstruct stat statb;\n\tFILE *tf;\n\tint ret;\n\tif (!tfile->file_path) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"No file set for track_file %s - removing\", tfile->fname);\n\t\tfree_list_element(vrrp_data->vrrp_track_files, vrrp_data->vrrp_track_files->tail);\n\t\treturn;\n\t}\n\tif (track_file_init == TRACK_FILE_NO_INIT)\n\t\treturn;\n\tret = stat(tfile->file_path, &statb);\n\tif (!ret) {\n\t\tif (track_file_init == TRACK_FILE_CREATE) {\n\t\t\treturn;\n\t\t}\n\t\tif ((statb.st_mode & S_IFMT) != S_IFREG) {\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Cannot initialise track file %s - it is not a regular file\", tfile->fname);\n\t\t\treturn;\n\t\t}\n\t\tif (reload)\n\t\t\treturn;\n\t}\n\tif (!__test_bit(CONFIG_TEST_BIT, &debug)) {\n\t\tif ((tf = fopen(tfile->file_path, \"w\"))) {\n\t\t\tfprintf(tf, \"%d\\n\", track_file_init_value);\n\t\t\tfclose(tf);\n\t\t}\n\t\telse\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Unable to initialise track file %s\", tfile->fname);\n\t}\n}", "target": 1}
{"code": "status _af_set_sample_format (_AudioFormat *f, int sampleFormat, int sampleWidth)\n{\n\tswitch (sampleFormat)\n\t{\n\t\tcase AF_SAMPFMT_UNSIGNED:\n\t\tcase AF_SAMPFMT_TWOSCOMP:\n\t\tif (sampleWidth < 1 || sampleWidth > 32)\n\t\t{\n\t\t\t_af_error(AF_BAD_SAMPFMT,\n\t\t\t\t\"illegal sample width %d for integer data\",\n\t\t\t\tsampleWidth);\n\t\t\treturn AF_FAIL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint bytes;\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = sampleWidth;\n\t\t\tbytes = _af_format_sample_size_uncompressed(f, false);\n\t\t\tif (sampleFormat == AF_SAMPFMT_TWOSCOMP)\n\t\t\t\tf->pcm = _af_default_signed_integer_pcm_mappings[bytes];\n\t\t\telse\n\t\t\t\tf->pcm = _af_default_unsigned_integer_pcm_mappings[bytes];\n\t\t}\n\t\tbreak;\n\t\tcase AF_SAMPFMT_FLOAT:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 32;\n\t\t\tf->pcm = _af_default_float_pcm_mapping;\n\t\t\tbreak;\n\t\tcase AF_SAMPFMT_DOUBLE:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 64;      \n\t\t\tf->pcm = _af_default_double_pcm_mapping;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t_af_error(AF_BAD_SAMPFMT, \"unknown sample format %d\",\n\t\t\t\tsampleFormat);\n\t\t\treturn AF_FAIL;\n\t}\n\treturn AF_SUCCEED;\n}", "target": 0}
{"code": "static int raw_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t       int *len, int peer)\n{\n\tstruct sockaddr_can *addr = (struct sockaddr_can *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct raw_sock *ro = raw_sk(sk);\n\tif (peer)\n\t\treturn -EOPNOTSUPP;\n\taddr->can_family  = AF_CAN;\n\taddr->can_ifindex = ro->ifindex;\n\t*len = sizeof(*addr);\n\treturn 0;\n}", "target": 1}
{"code": "int git_treebuilder_write(git_oid *oid, git_repository *repo, git_treebuilder *bld)\n{\n\tint error = 0;\n\tsize_t i;\n\tgit_buf tree = GIT_BUF_INIT;\n\tgit_odb *odb;\n\tassert(bld);\n\tgit_vector_sort(&bld->entries);\n\terror = git_buf_grow(&tree, bld->entries.length * 72);\n\tfor (i = 0; i < bld->entries.length && !error; ++i) {\n\t\tgit_tree_entry *entry = git_vector_get(&bld->entries, i);\n\t\tif (entry->removed)\n\t\t\tcontinue;\n\t\tgit_buf_printf(&tree, \"%o \", entry->attr);\n\t\tgit_buf_put(&tree, entry->filename, entry->filename_len + 1);\n\t\tgit_buf_put(&tree, (char *)entry->oid.id, GIT_OID_RAWSZ);\n\t\tif (git_buf_oom(&tree))\n\t\t\terror = -1;\n\t}\n\tif (!error &&\n\t\t!(error = git_repository_odb__weakptr(&odb, repo)))\n\t\terror = git_odb_write(oid, odb, tree.ptr, tree.size, GIT_OBJ_TREE);\n\tgit_buf_free(&tree);\n\treturn error;\n}", "target": 0}
{"code": "static struct ast_sip_endpoint *ip_identify(pjsip_rx_data *rdata)\n{\n\tstruct ast_sockaddr_with_tp addr_with_tp = { { { 0, } }, };\n\tpj_ansi_strxcpy(addr_with_tp.tp, rdata->tp_info.transport->type_name, sizeof(addr_with_tp.tp));\n\tast_sockaddr_parse(&addr_with_tp.addr, rdata->pkt_info.src_name, PARSE_PORT_FORBID);\n\tast_sockaddr_set_port(&addr_with_tp.addr, rdata->pkt_info.src_port);\n\treturn common_identify(ip_identify_match_check, &addr_with_tp);\n}", "target": 1}
{"code": "static int rxrpc_preparse_s(struct key_preparsed_payload *prep)\n{\n\tstruct crypto_blkcipher *ci;\n\t_enter(\"%zu\", prep->datalen);\n\tif (prep->datalen != 8)\n\t\treturn -EINVAL;\n\tmemcpy(&prep->type_data, prep->data, 8);\n\tci = crypto_alloc_blkcipher(\"pcbc(des)\", 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(ci)) {\n\t\t_leave(\" = %ld\", PTR_ERR(ci));\n\t\treturn PTR_ERR(ci);\n\t}\n\tif (crypto_blkcipher_setkey(ci, prep->data, 8) < 0)\n\t\tBUG();\n\tprep->payload[0] = ci;\n\t_leave(\" = 0\");\n\treturn 0;\n}", "target": 0}
{"code": "njs_string_prototype_match(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    njs_str_t             string;\n    njs_int_t             ret;\n    njs_value_t           arguments[2];\n    njs_regexp_pattern_t  *pattern;\n    ret = njs_string_object_validate(vm, njs_argument(args, 0));\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    arguments[1] = args[0];\n    string.start = NULL;\n    string.length = 0;\n    if (nargs > 1) {\n        if (njs_is_regexp(&args[1])) {\n            pattern = njs_regexp_pattern(&args[1]);\n            if (pattern->global) {\n                return njs_string_match_multiple(vm, args, pattern);\n            }\n            arguments[0] = args[1];\n            goto match;\n        }\n        if (!njs_is_string(&args[1])) {\n            if (!njs_is_undefined(&args[1])) {\n                ret = njs_value_to_string(vm, &args[1], &args[1]);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    return ret;\n                }\n                njs_string_get(&args[1], &string);\n            }\n        } else {\n            njs_string_get(&args[1], &string);\n        }\n    }\n    ret = njs_regexp_create(vm, &arguments[0], string.start, string.length, 0);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\nmatch:\n    return njs_regexp_prototype_exec(vm, arguments, nargs, unused);\n}", "target": 0}
{"code": "mm_skey_query(void *ctx, char **name, char **infotxt,\n   u_int *numprompts, char ***prompts, u_int **echo_on)\n{\n\tBuffer m;\n\tint len;\n\tu_int success;\n\tchar *p, *challenge;\n\tdebug3(\"%s: entering\", __func__);\n\tbuffer_init(&m);\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_SKEYQUERY, &m);\n\tmm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_SKEYQUERY,\n\t    &m);\n\tsuccess = buffer_get_int(&m);\n\tif (success == 0) {\n\t\tdebug3(\"%s: no challenge\", __func__);\n\t\tbuffer_free(&m);\n\t\treturn (-1);\n\t}\n\tchallenge  = buffer_get_string(&m, NULL);\n\tbuffer_free(&m);\n\tdebug3(\"%s: received challenge: %s\", __func__, challenge);\n\tmm_chall_setup(name, infotxt, numprompts, prompts, echo_on);\n\tlen = strlen(challenge) + strlen(SKEY_PROMPT) + 1;\n\tp = xmalloc(len);\n\tstrlcpy(p, challenge, len);\n\tstrlcat(p, SKEY_PROMPT, len);\n\t(*prompts)[0] = p;\n\txfree(challenge);\n\treturn (0);\n}", "target": 0}
{"code": "static void override_ssh_variant(enum ssh_variant *ssh_variant)\n{\n\tconst char *variant = getenv(\"GIT_SSH_VARIANT\");\n\tif (!variant && git_config_get_string_const(\"ssh.variant\", &variant))\n\t\treturn;\n\tif (!strcmp(variant, \"auto\"))\n\t\t*ssh_variant = VARIANT_AUTO;\n\telse if (!strcmp(variant, \"plink\"))\n\t\t*ssh_variant = VARIANT_PLINK;\n\telse if (!strcmp(variant, \"putty\"))\n\t\t*ssh_variant = VARIANT_PUTTY;\n\telse if (!strcmp(variant, \"tortoiseplink\"))\n\t\t*ssh_variant = VARIANT_TORTOISEPLINK;\n\telse if (!strcmp(variant, \"simple\"))\n\t\t*ssh_variant = VARIANT_SIMPLE;\n\telse\n\t\t*ssh_variant = VARIANT_SSH;\n}", "target": 0}
{"code": "inline Result ClientImpl::Delete(const std::string &path,\n                                 const Headers &headers, const char *body,\n                                 size_t content_length,\n                                 const std::string &content_type) {\n  Request req;\n  req.method = \"DELETE\";\n  req.headers = headers;\n  req.path = path;\n  if (!content_type.empty()) {\n    req.headers.emplace(\"Content-Type\", content_type);\n  }\n  req.body.assign(body, content_length);\n  return send_(std::move(req));\n}", "target": 1}
{"code": "errno_t sss_filter_sanitize(TALLOC_CTX *mem_ctx,\n                            const char *input,\n                            char **sanitized)\n{\n    return sss_filter_sanitize_ex(mem_ctx, input, sanitized, NULL);\n}", "target": 1}
{"code": "static int cdc_ncm_bind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tint ret;\n\tif (cdc_ncm_select_altsetting(intf) != CDC_NCM_COMM_ALTSETTING_NCM)\n\t\treturn -ENODEV;\n\tret = cdc_ncm_bind_common(dev, intf, CDC_NCM_DATA_ALTSETTING_NCM, 0);\n\tusbnet_link_change(dev, 0, 0);\n\treturn ret;\n}", "target": 1}
{"code": "ospf_header_dump (struct ospf_header *ospfh)\n{\n  char buf[9];\n  u_int16_t auth_type = ntohs (ospfh->auth_type);\n  zlog_debug (\"Header\");\n  zlog_debug (\"  Version %d\", ospfh->version);\n  zlog_debug (\"  Type %d (%s)\", ospfh->type,\n\t     LOOKUP (ospf_packet_type_str, ospfh->type));\n  zlog_debug (\"  Packet Len %d\", ntohs (ospfh->length));\n  zlog_debug (\"  Router ID %s\", inet_ntoa (ospfh->router_id));\n  zlog_debug (\"  Area ID %s\", inet_ntoa (ospfh->area_id));\n  zlog_debug (\"  Checksum 0x%x\", ntohs (ospfh->checksum));\n  zlog_debug (\"  AuType %s\", LOOKUP (ospf_auth_type_str, auth_type));\n  switch (auth_type)\n    {\n    case OSPF_AUTH_NULL:\n      break;\n    case OSPF_AUTH_SIMPLE:\n      memset (buf, 0, 9);\n      strncpy (buf, (char *) ospfh->u.auth_data, 8);\n      zlog_debug (\"  Simple Password %s\", buf);\n      break;\n    case OSPF_AUTH_CRYPTOGRAPHIC:\n      zlog_debug (\"  Cryptographic Authentication\");\n      zlog_debug (\"  Key ID %d\", ospfh->u.crypt.key_id);\n      zlog_debug (\"  Auth Data Len %d\", ospfh->u.crypt.auth_data_len);\n      zlog_debug (\"  Sequence number %ld\",\n\t\t (u_long)ntohl (ospfh->u.crypt.crypt_seqnum));\n      break;\n    default:\n      zlog_debug (\"* This is not supported authentication type\");\n      break;\n    }\n}", "target": 0}
{"code": "SMB2_sess_establish_session(struct SMB2_sess_data *sess_data)\n{\n\tint rc = 0;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tmutex_lock(&ses->server->srv_mutex);\n\tif (ses->server->sign && ses->server->ops->generate_signingkey) {\n\t\trc = ses->server->ops->generate_signingkey(ses);\n\t\tkfree(ses->auth_key.response);\n\t\tses->auth_key.response = NULL;\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI,\n\t\t\t\t\"SMB3 session key generation failed\\n\");\n\t\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t\tgoto keygen_exit;\n\t\t}\n\t}\n\tif (!ses->server->session_estab) {\n\t\tses->server->sequence_number = 0x2;\n\t\tses->server->session_estab = true;\n\t}\n\tmutex_unlock(&ses->server->srv_mutex);\n\tcifs_dbg(FYI, \"SMB2/3 session established successfully\\n\");\n\tspin_lock(&GlobalMid_Lock);\n\tses->status = CifsGood;\n\tses->need_reconnect = false;\n\tspin_unlock(&GlobalMid_Lock);\nkeygen_exit:\n\tif (!ses->server->sign) {\n\t\tkfree(ses->auth_key.response);\n\t\tses->auth_key.response = NULL;\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "gb18030_code_to_mbclen(OnigCodePoint code)\n{\n       if ((code & 0xff000000) != 0) return 4;\n  else if ((code &   0xff0000) != 0) return ONIGERR_INVALID_CODE_POINT_VALUE;\n  else if ((code &     0xff00) != 0) return 2;\n  else {\n    if (GB18030_MAP[(int )(code & 0xff)] == CM)\n      return ONIGERR_INVALID_CODE_POINT_VALUE;\n    return 1;\n  }\n}", "target": 0}
{"code": "static void gdCtxPrintf(gdIOCtx * out, const char *format, ...)\n{\n\tchar buf[4096];\n\tint len;\n\tva_list args;\n\tva_start(args, format);\n\tlen = vsnprintf(buf, sizeof(buf)-1, format, args);\n\tva_end(args);\n\tout->putBuf(out, buf, len);\n}", "target": 1}
{"code": "ipf_extract_frags_from_batch(struct ipf *ipf, struct dp_packet_batch *pb,\n                             ovs_be16 dl_type, uint16_t zone, long long now,\n                             uint32_t hash_basis)\n{\n    const size_t pb_cnt = dp_packet_batch_size(pb);\n    int pb_idx; \n    struct dp_packet *pkt;\n    DP_PACKET_BATCH_REFILL_FOR_EACH (pb_idx, pb_cnt, pkt, pb) {\n        if (OVS_UNLIKELY((dl_type == htons(ETH_TYPE_IP) &&\n                          ipf_is_valid_v4_frag(ipf, pkt))\n                          ||\n                          (dl_type == htons(ETH_TYPE_IPV6) &&\n                          ipf_is_valid_v6_frag(ipf, pkt)))) {\n            ovs_mutex_lock(&ipf->ipf_lock);\n            if (!ipf_handle_frag(ipf, pkt, dl_type, zone, now, hash_basis)) {\n                dp_packet_batch_refill(pb, pkt, pb_idx);\n            }\n            ovs_mutex_unlock(&ipf->ipf_lock);\n        } else {\n            dp_packet_batch_refill(pb, pkt, pb_idx);\n        }\n    }\n}", "target": 1}
{"code": "callbacks_revert_activate (GtkMenuItem *menuitem, gpointer user_data)\n{\n\tgerbv_revert_all_files (mainProject);\n\tselection_clear (&screen.selectionInfo);\n\tupdate_selected_object_message (FALSE);\n\trender_refresh_rendered_image_on_screen ();\n\tcallbacks_update_layer_tree ();\n}", "target": 0}
{"code": "static void clear_evtchn_to_irq_row(unsigned row)\n{\n\tunsigned col;\n\tfor (col = 0; col < EVTCHN_PER_ROW; col++)\n\t\tevtchn_to_irq[row][col] = -1;\n}", "target": 1}
{"code": "static int ReadHuffmanCode(int alphabet_size, VP8LDecoder* const dec,\n                           int* const code_lengths, HuffmanCode* const table) {\n  int ok = 0;\n  int size = 0;\n  VP8LBitReader* const br = &dec->br_;\n  const int simple_code = VP8LReadBits(br, 1);\n  memset(code_lengths, 0, alphabet_size * sizeof(*code_lengths));\n  if (simple_code) {  \n    const int num_symbols = VP8LReadBits(br, 1) + 1;\n    const int first_symbol_len_code = VP8LReadBits(br, 1);\n    int symbol = VP8LReadBits(br, (first_symbol_len_code == 0) ? 1 : 8);\n    code_lengths[symbol] = 1;\n    if (num_symbols == 2) {\n      symbol = VP8LReadBits(br, 8);\n      code_lengths[symbol] = 1;\n    }\n    ok = 1;\n  } else {  \n    int i;\n    int code_length_code_lengths[NUM_CODE_LENGTH_CODES] = { 0 };\n    const int num_codes = VP8LReadBits(br, 4) + 4;\n    assert(num_codes <= NUM_CODE_LENGTH_CODES);\n    for (i = 0; i < num_codes; ++i) {\n      code_length_code_lengths[kCodeLengthCodeOrder[i]] = VP8LReadBits(br, 3);\n    }\n    ok = ReadHuffmanCodeLengths(dec, code_length_code_lengths, alphabet_size,\n                                code_lengths);\n  }\n  ok = ok && !br->eos_;\n  if (ok) {\n    size = VP8LBuildHuffmanTable(table, HUFFMAN_TABLE_BITS,\n                                 code_lengths, alphabet_size);\n  }\n  if (!ok || size == 0) {\n    return VP8LSetError(dec, VP8_STATUS_BITSTREAM_ERROR);\n  }\n  return size;\n}", "target": 1}
{"code": "void bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)\n\t{\n\tBN_ULONG t1,t2;\n\tBN_ULONG c1,c2,c3;\n\tc1=0;\n\tc2=0;\n\tc3=0;\n\tsqr_add_c(a,0,c1,c2,c3);\n\tr[0]=c1;\n\tc1=0;\n\tsqr_add_c2(a,1,0,c2,c3,c1);\n\tr[1]=c2;\n\tc2=0;\n\tsqr_add_c(a,1,c3,c1,c2);\n\tsqr_add_c2(a,2,0,c3,c1,c2);\n\tr[2]=c3;\n\tc3=0;\n\tsqr_add_c2(a,3,0,c1,c2,c3);\n\tsqr_add_c2(a,2,1,c1,c2,c3);\n\tr[3]=c1;\n\tc1=0;\n\tsqr_add_c(a,2,c2,c3,c1);\n\tsqr_add_c2(a,3,1,c2,c3,c1);\n\tr[4]=c2;\n\tc2=0;\n\tsqr_add_c2(a,3,2,c3,c1,c2);\n\tr[5]=c3;\n\tc3=0;\n\tsqr_add_c(a,3,c1,c2,c3);\n\tr[6]=c1;\n\tr[7]=c2;\n\t}", "target": 1}
{"code": "process_button(struct parsed_tag *tag)\n{\n    Str tmp = NULL;\n    char *p, *q, *r, *qq = \"\";\n    int qlen, v;\n    if (cur_form_id < 0) {\n       char *s = \"<form_int method=internal action=none>\";\n       tmp = process_form(parse_tag(&s, TRUE));\n    }\n    if (tmp == NULL)\n       tmp = Strnew();\n    p = \"submit\";\n    parsedtag_get_value(tag, ATTR_TYPE, &p);\n    q = NULL;\n    parsedtag_get_value(tag, ATTR_VALUE, &q);\n    r = \"\";\n    parsedtag_get_value(tag, ATTR_NAME, &r);\n    v = formtype(p);\n    if (v == FORM_UNKNOWN)\n       return NULL;\n    if (!q) {\n       switch (v) {\n       case FORM_INPUT_SUBMIT:\n       case FORM_INPUT_BUTTON:\n           q = \"SUBMIT\";\n           break;\n       case FORM_INPUT_RESET:\n           q = \"RESET\";\n           break;\n       }\n    }\n    if (q) {\n       qq = html_quote(q);\n       qlen = strlen(q);\n    }\n    Strcat(tmp, Sprintf(\"<input_alt hseq=\\\"%d\\\" fid=\\\"%d\\\" type=\\\"%s\\\" \"\n                       \"name=\\\"%s\\\" value=\\\"%s\\\">\",\n                       cur_hseq++, cur_form_id, html_quote(p),\n                       html_quote(r), qq));\n    return tmp;\n}", "target": 1}
{"code": "static int rm_sync(AVFormatContext *s, int64_t *timestamp, int *flags, int *stream_index, int64_t *pos){\n    RMDemuxContext *rm = s->priv_data;\n    AVIOContext *pb = s->pb;\n    AVStream *st;\n    uint32_t state=0xFFFFFFFF;\n    while(!avio_feof(pb)){\n        int len, num, i;\n        int mlti_id;\n        *pos= avio_tell(pb) - 3;\n        if(rm->remaining_len > 0){\n            num= rm->current_stream;\n            mlti_id = 0;\n            len= rm->remaining_len;\n            *timestamp = AV_NOPTS_VALUE;\n            *flags= 0;\n        }else{\n            state= (state<<8) + avio_r8(pb);\n            if(state == MKBETAG('I', 'N', 'D', 'X')){\n                int n_pkts, expected_len;\n                len = avio_rb32(pb);\n                avio_skip(pb, 2);\n                n_pkts = avio_rb32(pb);\n                expected_len = 20 + n_pkts * 14;\n                if (len == 20)\n                    len = expected_len;\n                else if (len != expected_len)\n                    av_log(s, AV_LOG_WARNING,\n                           \"Index size %d (%d pkts) is wrong, should be %d.\\n\",\n                           len, n_pkts, expected_len);\n                len -= 14; \n                if(len<0)\n                    continue;\n                goto skip;\n            } else if (state == MKBETAG('D','A','T','A')) {\n                av_log(s, AV_LOG_WARNING,\n                       \"DATA tag in middle of chunk, file may be broken.\\n\");\n            }\n            if(state > (unsigned)0xFFFF || state <= 12)\n                continue;\n            len=state - 12;\n            state= 0xFFFFFFFF;\n            num = avio_rb16(pb);\n            *timestamp = avio_rb32(pb);\n            mlti_id = (avio_r8(pb)>>1)-1<<16;\n            mlti_id = FFMAX(mlti_id, 0);\n            *flags = avio_r8(pb); \n        }\n        for(i=0;i<s->nb_streams;i++) {\n            st = s->streams[i];\n            if (mlti_id + num == st->id)\n                break;\n        }\n        if (i == s->nb_streams) {\nskip:\n            avio_skip(pb, len);\n            rm->remaining_len = 0;\n            continue;\n        }\n        *stream_index= i;\n        return len;\n    }\n    return -1;\n}", "target": 0}
{"code": "usm_malloc_usmStateReference(void)\n{\n    struct usmStateReference *retval = (struct usmStateReference *)\n        calloc(1, sizeof(struct usmStateReference));\n    return retval;\n}                               ", "target": 1}
{"code": "Status SpectrogramShapeFn(InferenceContext* c) {\n  ShapeHandle input;\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &input));\n  int32_t window_size;\n  TF_RETURN_IF_ERROR(c->GetAttr(\"window_size\", &window_size));\n  if (window_size <= 1) {\n    return errors::InvalidArgument(\"window size must be > 1, got \",\n                                   window_size);\n  }\n  int32_t stride;\n  TF_RETURN_IF_ERROR(c->GetAttr(\"stride\", &stride));\n  if (stride <= 0) {\n    return errors::InvalidArgument(\"stride must be strictly positive, got \",\n                                   stride);\n  }\n  DimensionHandle input_length = c->Dim(input, 0);\n  DimensionHandle input_channels = c->Dim(input, 1);\n  DimensionHandle output_length;\n  if (!c->ValueKnown(input_length)) {\n    output_length = c->UnknownDim();\n  } else {\n    const int64_t input_length_value = c->Value(input_length);\n    const int64_t length_minus_window = (input_length_value - window_size);\n    int64_t output_length_value;\n    if (length_minus_window < 0) {\n      output_length_value = 0;\n    } else {\n      output_length_value = 1 + (length_minus_window / stride);\n    }\n    output_length = c->MakeDim(output_length_value);\n  }\n  DimensionHandle output_channels =\n      c->MakeDim(1 + NextPowerOfTwo(window_size) / 2);\n  c->set_output(0,\n                c->MakeShape({input_channels, output_length, output_channels}));\n  return OkStatus();\n}", "target": 0}
{"code": "static int persist__subs_save_all(FILE *db_fptr)\n{\n\tstruct mosquitto__subhier *subhier, *subhier_tmp;\n\tHASH_ITER(hh, db.subs, subhier, subhier_tmp){\n\t\tif(subhier->children){\n\t\t\tpersist__subs_save(db_fptr, subhier->children, \"\", 0);\n\t\t}\n\t}\n\treturn MOSQ_ERR_SUCCESS;\n}", "target": 1}
{"code": "void DHT::illustrate_dirs()\n{\n#if defined(LIBRAW_USE_OPENMP)\n#pragma omp parallel for schedule(guided)\n#endif\n  for (int i = 0; i < libraw.imgdata.sizes.iheight; ++i)\n  {\n    illustrate_dline(i);\n  }\n}", "target": 0}
{"code": "static uint64_t pit_ioport_read(void *opaque, hwaddr addr,\n                                unsigned size)\n{\n    PITCommonState *pit = opaque;\n    int ret, count;\n    PITChannelState *s;\n    addr &= 3;\n    s = &pit->channels[addr];\n    if (s->status_latched) {\n        s->status_latched = 0;\n        ret = s->status;\n    } else if (s->count_latched) {\n        switch(s->count_latched) {\n        default:\n        case RW_STATE_LSB:\n            ret = s->latched_count & 0xff;\n            s->count_latched = 0;\n            break;\n        case RW_STATE_MSB:\n            ret = s->latched_count >> 8;\n            s->count_latched = 0;\n            break;\n        case RW_STATE_WORD0:\n            ret = s->latched_count & 0xff;\n            s->count_latched = RW_STATE_MSB;\n            break;\n        }\n    } else {\n        switch(s->read_state) {\n        default:\n        case RW_STATE_LSB:\n            count = pit_get_count(s);\n            ret = count & 0xff;\n            break;\n        case RW_STATE_MSB:\n            count = pit_get_count(s);\n            ret = (count >> 8) & 0xff;\n            break;\n        case RW_STATE_WORD0:\n            count = pit_get_count(s);\n            ret = count & 0xff;\n            s->read_state = RW_STATE_WORD1;\n            break;\n        case RW_STATE_WORD1:\n            count = pit_get_count(s);\n            ret = (count >> 8) & 0xff;\n            s->read_state = RW_STATE_WORD0;\n            break;\n        }\n    }\n    return ret;\n}", "target": 1}
{"code": "static void io_async_task_func(struct callback_head *cb)\n{\n\tstruct io_kiocb *req = container_of(cb, struct io_kiocb, task_work);\n\tstruct async_poll *apoll = req->apoll;\n\tstruct io_ring_ctx *ctx = req->ctx;\n\ttrace_io_uring_task_run(req->ctx, req->opcode, req->user_data);\n\tif (io_poll_rewait(req, &apoll->poll)) {\n\t\tspin_unlock_irq(&ctx->completion_lock);\n\t\treturn;\n\t}\n\tif (hash_hashed(&req->hash_node))\n\t\thash_del(&req->hash_node);\n\tio_poll_remove_double(req, apoll->double_poll);\n\tspin_unlock_irq(&ctx->completion_lock);\n\tif (!READ_ONCE(apoll->poll.canceled))\n\t\t__io_req_task_submit(req);\n\telse\n\t\t__io_req_task_cancel(req, -ECANCELED);\n\tkfree(apoll->double_poll);\n\tkfree(apoll);\n}", "target": 1}
{"code": "int sctp_ulpq_tail_data(struct sctp_ulpq *ulpq, struct sctp_chunk *chunk,\n\t\t\tgfp_t gfp)\n{\n\tstruct sk_buff_head temp;\n\tsctp_data_chunk_t *hdr;\n\tstruct sctp_ulpevent *event;\n\thdr = (sctp_data_chunk_t *) chunk->chunk_hdr;\n\tevent = sctp_ulpevent_make_rcvmsg(chunk->asoc, chunk, gfp);\n\tif (!event)\n\t\treturn -ENOMEM;\n\tevent = sctp_ulpq_reasm(ulpq, event);\n\tif ((event) && (event->msg_flags & MSG_EOR)){\n\t\tskb_queue_head_init(&temp);\n\t\t__skb_queue_tail(&temp, sctp_event2skb(event));\n\t\tevent = sctp_ulpq_order(ulpq, event);\n\t}\n\tif (event)\n\t\tsctp_ulpq_tail_event(ulpq, event);\n\treturn 0;\n}", "target": 0}
{"code": "int pid_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct task_struct *task;\n\tconst struct cred *cred;\n\tstruct pid_namespace *pid = dentry->d_sb->s_fs_info;\n\tgeneric_fillattr(inode, stat);\n\trcu_read_lock();\n\tstat->uid = 0;\n\tstat->gid = 0;\n\ttask = pid_task(proc_pid(inode), PIDTYPE_PID);\n\tif (task) {\n\t\tif (!has_pid_permissions(pid, task, 2)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tif ((inode->i_mode == (S_IFDIR|S_IRUGO|S_IXUGO)) ||\n\t\t    task_dumpable(task)) {\n\t\t\tcred = __task_cred(task);\n\t\t\tstat->uid = cred->euid;\n\t\t\tstat->gid = cred->egid;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}", "target": 0}
{"code": "        std::string PngChunk::makeUtf8TxtChunk(const std::string& keyword, const std::string& text, bool compress)\n        {\n            std::string chunkData = keyword;\n            if (compress) {\n                static const char flags[] = {0x00, 0x01, 0x00, 0x00, 0x00};\n                chunkData += std::string(flags, 5) + zlibCompress(text);\n            } else {\n                static const char flags[] = {0x00, 0x00, 0x00, 0x00, 0x00};\n                chunkData += std::string(flags, 5) + text;\n            }\n            byte length[4];\n            ul2Data(length, static_cast<uint32_t>(chunkData.size()), bigEndian);\n            std::string chunkType = \"iTXt\";\n            std::string crcData = chunkType + chunkData;\n            uLong tmp = crc32(0L, Z_NULL, 0);\n            tmp = crc32(tmp, (const Bytef*)crcData.data(), static_cast<uInt>(crcData.size()));\n            byte crc[4];\n            ul2Data(crc, tmp, bigEndian);\n            return std::string((const char*)length, 4) + chunkType + chunkData + std::string((const char*)crc, 4);\n        }  ", "target": 0}
{"code": "static int sip_endpoint_identifier_str2type(const char *str)\n{\n\tint method;\n\tif (!strcasecmp(str, \"username\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_USERNAME;\n\t} else if (!strcasecmp(str, \"auth_username\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_AUTH_USERNAME;\n\t} else if (!strcasecmp(str, \"ip\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_IP;\n\t} else if (!strcasecmp(str, \"header\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_HEADER;\n\t} else if (!strcasecmp(str, \"request_uri\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_REQUEST_URI;\n\t} else if (!strcasecmp(str, \"transport\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_TRANSPORT;\n\t} else {\n\t\tmethod = -1;\n\t}\n\treturn method;\n}", "target": 1}
{"code": "static int kvp_get_value(int pool, __u8 *key, int key_size, __u8 *value,\n\t\t\tint value_size)\n{\n\tint i;\n\tint num_records;\n\tstruct kvp_record *record;\n\tif ((key_size > HV_KVP_EXCHANGE_MAX_KEY_SIZE) ||\n\t\t(value_size > HV_KVP_EXCHANGE_MAX_VALUE_SIZE))\n\t\treturn 1;\n\tkvp_update_mem_state(pool);\n\tnum_records = kvp_file_info[pool].num_records;\n\trecord = kvp_file_info[pool].records;\n\tfor (i = 0; i < num_records; i++) {\n\t\tif (memcmp(key, record[i].key, key_size))\n\t\t\tcontinue;\n\t\tmemcpy(value, record[i].value, value_size);\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "int send_sigqueue(struct sigqueue *q, struct task_struct *t, int group)\n{\n\tint sig = q->info.si_signo;\n\tstruct sigpending *pending;\n\tunsigned long flags;\n\tint ret;\n\tBUG_ON(!(q->flags & SIGQUEUE_PREALLOC));\n\tret = -1;\n\tif (!likely(lock_task_sighand(t, &flags)))\n\t\tgoto ret;\n\tret = 1; \n\tif (!prepare_signal(sig, t, 0))\n\t\tgoto out;\n\tret = 0;\n\tif (unlikely(!list_empty(&q->list))) {\n\t\tBUG_ON(q->info.si_code != SI_TIMER);\n\t\tq->info.si_overrun++;\n\t\tgoto out;\n\t}\n\tq->info.si_overrun = 0;\n\tsignalfd_notify(t, sig);\n\tpending = group ? &t->signal->shared_pending : &t->pending;\n\tlist_add_tail(&q->list, &pending->list);\n\tsigaddset(&pending->signal, sig);\n\tcomplete_signal(sig, t, group);\nout:\n\tunlock_task_sighand(t, &flags);\nret:\n\treturn ret;\n}", "target": 0}
{"code": "bool __zone_watermark_ok(struct zone *z, unsigned int order, unsigned long mark,\n\t\t\t int classzone_idx, unsigned int alloc_flags,\n\t\t\t long free_pages)\n{\n\tlong min = mark;\n\tint o;\n\tconst bool alloc_harder = (alloc_flags & (ALLOC_HARDER|ALLOC_OOM));\n\tfree_pages -= (1 << order) - 1;\n\tif (alloc_flags & ALLOC_HIGH)\n\t\tmin -= min / 2;\n\tif (likely(!alloc_harder)) {\n\t\tfree_pages -= z->nr_reserved_highatomic;\n\t} else {\n\t\tif (alloc_flags & ALLOC_OOM)\n\t\t\tmin -= min / 2;\n\t\telse\n\t\t\tmin -= min / 4;\n\t}\n#ifdef CONFIG_CMA\n\tif (!(alloc_flags & ALLOC_CMA))\n\t\tfree_pages -= zone_page_state(z, NR_FREE_CMA_PAGES);\n#endif\n\tif (free_pages <= min + z->lowmem_reserve[classzone_idx])\n\t\treturn false;\n\tif (!order)\n\t\treturn true;\n\tfor (o = order; o < MAX_ORDER; o++) {\n\t\tstruct free_area *area = &z->free_area[o];\n\t\tint mt;\n\t\tif (!area->nr_free)\n\t\t\tcontinue;\n\t\tfor (mt = 0; mt < MIGRATE_PCPTYPES; mt++) {\n\t\t\tif (!list_empty(&area->free_list[mt]))\n\t\t\t\treturn true;\n\t\t}\n#ifdef CONFIG_CMA\n\t\tif ((alloc_flags & ALLOC_CMA) &&\n\t\t    !list_empty(&area->free_list[MIGRATE_CMA])) {\n\t\t\treturn true;\n\t\t}\n#endif\n\t\tif (alloc_harder &&\n\t\t\t!list_empty(&area->free_list[MIGRATE_HIGHATOMIC]))\n\t\t\treturn true;\n\t}\n\treturn false;\n}", "target": 0}
{"code": "void HTMLSelectElement::dispatchBlurEvent(Element* newFocusedElement)\n{\n    if (usesMenuList())\n        dispatchChangeEventForMenuList();\n    HTMLFormControlElementWithState::dispatchBlurEvent(newFocusedElement);\n}", "target": 0}
{"code": "static int wrmsr_interception(struct vcpu_svm *svm)\n{\n\tstruct msr_data msr;\n\tu32 ecx = svm->vcpu.arch.regs[VCPU_REGS_RCX];\n\tu64 data = (svm->vcpu.arch.regs[VCPU_REGS_RAX] & -1u)\n\t\t| ((u64)(svm->vcpu.arch.regs[VCPU_REGS_RDX] & -1u) << 32);\n\tmsr.data = data;\n\tmsr.index = ecx;\n\tmsr.host_initiated = false;\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 2;\n\tif (svm_set_msr(&svm->vcpu, &msr)) {\n\t\ttrace_kvm_msr_write_ex(ecx, data);\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t} else {\n\t\ttrace_kvm_msr_write(ecx, data);\n\t\tskip_emulated_instruction(&svm->vcpu);\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "static inline long put_compat_itimerval(struct compat_itimerval __user *o,\n\t\tstruct itimerval *i)\n{\n\treturn (!access_ok(VERIFY_WRITE, o, sizeof(*o)) ||\n\t\t(__put_user(i->it_interval.tv_sec, &o->it_interval.tv_sec) |\n\t\t __put_user(i->it_interval.tv_usec, &o->it_interval.tv_usec) |\n\t\t __put_user(i->it_value.tv_sec, &o->it_value.tv_sec) |\n\t\t __put_user(i->it_value.tv_usec, &o->it_value.tv_usec)));\n}", "target": 0}
{"code": "static void get_info_from_frame (mpeg2ps_stream_t *sptr,\n                                 u8 *buffer,\n                                 u32 buflen)\n{\n\tif (sptr->is_video) {\n\t\tif (MPEG12_ParseSeqHdr(buffer, buflen,\n\t\t                       &sptr->have_mpeg2,\n\t\t                       &sptr->h,\n\t\t                       &sptr->w,\n\t\t                       &sptr->frame_rate,\n\t\t                       &sptr->bit_rate,\n\t\t                       &sptr->par) < 0) {\n\t\t\tsptr->m_stream_id = 0;\n\t\t\tsptr->m_fd = FDNULL;\n\t\t\treturn;\n\t\t}\n\t\tsptr->ticks_per_frame = (u64)(90000.0 / sptr->frame_rate);\n\t\treturn;\n\t}\n\tif (sptr->m_stream_id >= 0xc0) {\n\t\tu32 hdr = GF_4CC((u32)buffer[0],buffer[1],buffer[2],buffer[3]);\n\t\tsptr->channels = gf_mp3_num_channels(hdr);\n\t\tsptr->freq = gf_mp3_sampling_rate(hdr);\n\t\tsptr->samples_per_frame = gf_mp3_window_size(hdr);\n\t\tsptr->bitrate = gf_mp3_bit_rate(hdr) * 1000; \n\t\tsptr->layer = gf_mp3_layer(hdr);\n\t} else if (sptr->m_stream_id == 0xbd) {\n\t\tif (sptr->m_substream_id >= 0xa0) {\n\t\t} else if (sptr->m_substream_id >= 0x80) {\n\t\t\tu32 pos;\n\t\t\tGF_AC3Config hdr;\n\t\t\tmemset(&hdr, 0, sizeof(GF_AC3Config));\n\t\t\tgf_ac3_parser(buffer, buflen, &pos, &hdr, 0);\n\t\t\tsptr->bitrate = gf_ac3_get_bitrate(hdr.brcode);\n\t\t\tsptr->freq = hdr.sample_rate;\n\t\t\tsptr->channels = hdr.streams[0].channels;\n\t\t\tsptr->samples_per_frame = 256 * 6;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\treturn;\n\t}\n}", "target": 0}
{"code": "static int parse_public_key(const u8 *key, size_t keysize, RSA *rsa)\n{\n\tconst u8 *p = key;\n\tBIGNUM *n, *e;\n\tint base;\n\tbase = (keysize - 7) / 5;\n\tif (base != 32 && base != 48 && base != 64 && base != 128) {\n\t\tfprintf(stderr, \"Invalid public key.\\n\");\n\t\treturn -1;\n\t}\n\tp += 3;\n\tn = BN_new();\n\tif (n == NULL)\n\t\treturn -1;\n\tcf2bn(p, 2 * base, n);\n\tp += 2 * base;\n\tp += base;\n\tp += 2 * base;\n\te = BN_new();\n\tif (e == NULL)\n\t\treturn -1;\n\tcf2bn(p, 4, e);\n\tif (RSA_set0_key(rsa, n, e, NULL) != 1)\n\t    return -1;\n\treturn 0;\n}", "target": 0}
{"code": "static void copy_sec_desc(const struct cifs_ntsd *pntsd,\n\t\t\t\tstruct cifs_ntsd *pnntsd, __u32 sidsoffset)\n{\n\tstruct cifs_sid *owner_sid_ptr, *group_sid_ptr;\n\tstruct cifs_sid *nowner_sid_ptr, *ngroup_sid_ptr;\n\tpnntsd->revision = pntsd->revision;\n\tpnntsd->type = pntsd->type;\n\tpnntsd->dacloffset = cpu_to_le32(sizeof(struct cifs_ntsd));\n\tpnntsd->sacloffset = 0;\n\tpnntsd->osidoffset = cpu_to_le32(sidsoffset);\n\tpnntsd->gsidoffset = cpu_to_le32(sidsoffset + sizeof(struct cifs_sid));\n\towner_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->osidoffset));\n\tnowner_sid_ptr = (struct cifs_sid *)((char *)pnntsd + sidsoffset);\n\tcifs_copy_sid(nowner_sid_ptr, owner_sid_ptr);\n\tgroup_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->gsidoffset));\n\tngroup_sid_ptr = (struct cifs_sid *)((char *)pnntsd + sidsoffset +\n\t\t\t\t\tsizeof(struct cifs_sid));\n\tcifs_copy_sid(ngroup_sid_ptr, group_sid_ptr);\n\treturn;\n}", "target": 0}
{"code": "void nfs4_close_state(struct path *path, struct nfs4_state *state, mode_t mode)\n{\n\t__nfs4_close(path, state, mode, 0);\n}", "target": 1}
{"code": "seamless_line_handler(const char *line, void *data)\n{\n\tif (!seamless_process_line(line, data))\n\t{\n\t\twarning(\"SeamlessRDP: Invalid request:%s\\n\", line);\n\t}\n\treturn True;\n}", "target": 0}
{"code": "RSAES_PKCS1v1_5Encode(\n\t\t      TPM2B       *padded,        \n\t\t      TPM2B       *message,       \n\t\t      RAND_STATE  *rand\n\t\t      )\n{\n    UINT32      ps = padded->size - message->size - 3;\n    if(message->size > padded->size - 11)\n\treturn TPM_RC_VALUE;\n    memcpy(&padded->buffer[padded->size - message->size], message->buffer,\n\t   message->size);\n    padded->buffer[0] = 0;\n    padded->buffer[1] = 2;\n    DRBG_Generate(rand, &padded->buffer[2], (UINT16)ps);\n    padded->buffer[2 + ps] = 0;\n    for(ps++; ps > 1; ps--)\n\t{\n\t    if(padded->buffer[ps] == 0)\n\t\tpadded->buffer[ps] = 0x55;  \n\t}\n    return TPM_RC_SUCCESS;\n}", "target": 0}
{"code": "append_wild(char *to, char *end, const char *wild)\n{\n  end-=5;\t\t\t\t\t\n  if (wild && wild[0])\n  {\n    to=strmov(to,\" like '\");\n    while (*wild && to < end)\n    {\n      if (*wild == '\\\\' || *wild == '\\'')\n\t*to++='\\\\';\n      *to++= *wild++;\n    }\n    if (*wild)\t\t\t\t\t\n      *to++='%';\t\t\t\t\n    to[0]='\\'';\n    to[1]=0;\n  }\n}", "target": 0}
{"code": "static int jpc_dec_process_eoc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tint tileno;\n\tjpc_dec_tile_t *tile;\n\tms = 0;\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,\n\t  ++tile) {\n\t\tif (tile->state == JPC_TILE_ACTIVE) {\n\t\t\tif (jpc_dec_tiledecode(dec, tile)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (tile->state != JPC_TILE_DONE) {\n\t\t\tjpc_dec_tilefini(dec, tile);\n\t\t}\n\t}\n\tdec->state = JPC_MT;\n\treturn 1;\n}", "target": 0}
{"code": "static int shmem_remount_fs(struct super_block *sb, int *flags, char *data)\n{\n\tstruct shmem_sb_info *sbinfo = SHMEM_SB(sb);\n\tstruct shmem_sb_info config = *sbinfo;\n\tunsigned long inodes;\n\tint error = -EINVAL;\n\tif (shmem_parse_options(data, &config, true))\n\t\treturn error;\n\tspin_lock(&sbinfo->stat_lock);\n\tinodes = sbinfo->max_inodes - sbinfo->free_inodes;\n\tif (percpu_counter_compare(&sbinfo->used_blocks, config.max_blocks) > 0)\n\t\tgoto out;\n\tif (config.max_inodes < inodes)\n\t\tgoto out;\n\tif (config.max_blocks && !sbinfo->max_blocks)\n\t\tgoto out;\n\tif (config.max_inodes && !sbinfo->max_inodes)\n\t\tgoto out;\n\terror = 0;\n\tsbinfo->max_blocks  = config.max_blocks;\n\tsbinfo->max_inodes  = config.max_inodes;\n\tsbinfo->free_inodes = config.max_inodes - inodes;\n\tmpol_put(sbinfo->mpol);\n\tsbinfo->mpol        = config.mpol;\t\nout:\n\tspin_unlock(&sbinfo->stat_lock);\n\treturn error;\n}", "target": 1}
{"code": "std::pair<Function *, Function *> ESTreeIRGen::doLazyFunction(\n    hbc::LazyCompilationData *lazyData) {\n  Function *topLevel = Builder.createTopLevelFunction(lazyData->strictMode, {});\n  FunctionContext topLevelFunctionContext{this, topLevel, nullptr};\n  llvh::SaveAndRestore<FunctionContext *> saveTopLevelContext(\n      topLevelContext, &topLevelFunctionContext);\n  auto *node = cast<ESTree::FunctionLikeNode>(Root);\n  lexicalScopeChain = lazyData->parentScope;\n  materializeScopesInChain(\n      topLevel, lexicalScopeChain, getDepth(lexicalScopeChain) - 1);\n  Variable *parentVar = nullptr;\n  if (lazyData->closureAlias.isValid()) {\n    assert(lazyData->originalName.isValid() && \"Original name invalid\");\n    assert(\n        lazyData->originalName != lazyData->closureAlias &&\n        \"Original name must be different from the alias\");\n    parentVar = cast<Variable>(nameTable_.lookup(lazyData->closureAlias));\n    nameTable_.insert(lazyData->originalName, parentVar);\n  }\n  assert(\n      !llvh::isa<ESTree::ArrowFunctionExpressionNode>(node) &&\n      \"lazy compilation not supported for arrow functions\");\n  auto *func = genES5Function(lazyData->originalName, parentVar, node);\n  addLexicalDebugInfo(func, topLevel, lexicalScopeChain);\n  return {func, topLevel};\n}", "target": 1}
{"code": "    void operator=(GetResult&& rhs) noexcept { result_ = std::move(rhs.result_); }", "target": 0}
{"code": "xmlCtxtReadMemory(xmlParserCtxtPtr ctxt, const char *buffer, int size,\n                  const char *URL, const char *encoding, int options)\n{\n    xmlParserInputBufferPtr input;\n    xmlParserInputPtr stream;\n    if (ctxt == NULL)\n        return (NULL);\n    if (buffer == NULL)\n        return (NULL);\n    xmlInitParser();\n    xmlCtxtReset(ctxt);\n    input = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);\n    if (input == NULL) {\n\treturn(NULL);\n    }\n    stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);\n    if (stream == NULL) {\n\txmlFreeParserInputBuffer(input);\n\treturn(NULL);\n    }\n    inputPush(ctxt, stream);\n    return (xmlDoRead(ctxt, URL, encoding, options, 1));\n}", "target": 0}
{"code": "void AOClient::pktEditEvidence(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    if (!checkEvidenceAccess(area))\n        return;\n    bool is_int = false;\n    int idx = argv[0].toInt(&is_int);\n    AreaData::Evidence evi = {argv[1], argv[2], argv[3]};\n    if (is_int && idx <= area->evidence().size() && idx >= 0) {\n        area->replaceEvidence(idx, evi);\n    }\n    sendEvidenceList(area);\n}", "target": 1}
{"code": "static int decode_attr_security_label(struct xdr_stream *xdr, uint32_t *bitmap,\n\t\t\t\t\tstruct nfs4_label *label)\n{\n\tuint32_t pi = 0;\n\tuint32_t lfs = 0;\n\t__u32 len;\n\t__be32 *p;\n\tint status = 0;\n\tif (unlikely(bitmap[2] & (FATTR4_WORD2_SECURITY_LABEL - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[2] & FATTR4_WORD2_SECURITY_LABEL)) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tlfs = be32_to_cpup(p++);\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tpi = be32_to_cpup(p++);\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tlen = be32_to_cpup(p++);\n\t\tp = xdr_inline_decode(xdr, len);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tif (len < NFS4_MAXLABELLEN) {\n\t\t\tif (label) {\n\t\t\t\tmemcpy(label->label, p, len);\n\t\t\t\tlabel->len = len;\n\t\t\t\tlabel->pi = pi;\n\t\t\t\tlabel->lfs = lfs;\n\t\t\t\tstatus = NFS_ATTR_FATTR_V4_SECURITY_LABEL;\n\t\t\t}\n\t\t\tbitmap[2] &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t\t} else\n\t\t\tprintk(KERN_WARNING \"%s: label too long (%u)!\\n\",\n\t\t\t\t\t__func__, len);\n\t}\n\tif (label && label->label)\n\t\tdprintk(\"%s: label=%s, len=%d, PI=%d, LFS=%d\\n\", __func__,\n\t\t\t(char *)label->label, label->len, label->pi, label->lfs);\n\treturn status;\n}", "target": 1}
{"code": "static bool parse_namemap(RBuffer *b, ut64 bound, RIDStorage *map, ut32 *count) {\n\tsize_t i;\n\tif (!consume_u32_r (b, bound, count)) {\n\t\treturn false;\n\t}\n\tfor (i = 0; i < *count; i++) {\n\t\tut32 idx;\n\t\tif (!consume_u32_r (b, bound, &idx)) {\n\t\t\treturn false;\n\t\t}\n\t\tchar *name = NULL;\n\t\tif (!consume_encoded_name_new (b, bound, NULL, &name)) {\n\t\t\tR_FREE (name);\n\t\t\treturn false;\n\t\t}\n\t\tif (!r_id_storage_add (map, name, &idx)) {\n\t\t\tR_FREE (name);\n\t\t\treturn false;\n\t\t};\n\t}\n\treturn true;\n}", "target": 0}
{"code": "    setSanMatchers(std::vector<envoy::type::matcher::v3::StringMatcher> san_matchers) {\n      san_matchers_ = san_matchers;\n      return *this;\n    }", "target": 1}
{"code": "kg_seal_iov(OM_uint32 *minor_status,\n            gss_ctx_id_t context_handle,\n            int conf_req_flag,\n            gss_qop_t qop_req,\n            int *conf_state,\n            gss_iov_buffer_desc *iov,\n            int iov_count,\n            int toktype)\n{\n    krb5_gss_ctx_id_rec *ctx;\n    krb5_error_code code;\n    krb5_context context;\n    if (qop_req != 0) {\n        *minor_status = (OM_uint32)G_UNKNOWN_QOP;\n        return GSS_S_FAILURE;\n    }\n    ctx = (krb5_gss_ctx_id_rec *)context_handle;\n    if (!ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return GSS_S_NO_CONTEXT;\n    }\n    if (conf_req_flag && kg_integ_only_iov(iov, iov_count)) {\n        conf_req_flag = FALSE;\n    }\n    context = ctx->k5_context;\n    switch (ctx->proto) {\n    case 0:\n        code = make_seal_token_v1_iov(context, ctx, conf_req_flag,\n                                      conf_state, iov, iov_count, toktype);\n        break;\n    case 1:\n        code = gss_krb5int_make_seal_token_v3_iov(context, ctx, conf_req_flag,\n                                                  conf_state, iov, iov_count, toktype);\n        break;\n    default:\n        code = G_UNKNOWN_QOP;\n        break;\n    }\n    if (code != 0) {\n        *minor_status = code;\n        save_error_info(*minor_status, context);\n        return GSS_S_FAILURE;\n    }\n    *minor_status = 0;\n    return GSS_S_COMPLETE;\n}", "target": 1}
{"code": "int PpapiPluginMain(const content::MainFunctionParams& parameters) {\n  const CommandLine& command_line = parameters.command_line;\n#if defined(OS_WIN)\n  g_target_services = parameters.sandbox_info->target_services;\n#endif\n  if (command_line.HasSwitch(switches::kPpapiStartupDialog)) {\n    if (g_target_services)\n      base::debug::WaitForDebugger(2*60, false);\n    else\n       ChildProcess::WaitForDebugger(\"Ppapi\");\n   }\n  if (command_line.HasSwitch(switches::kLang)) {\n    std::string locale = command_line.GetSwitchValueASCII(switches::kLang);\n    base::i18n::SetICUDefaultLocale(locale);\n  }\n   MessageLoop main_message_loop;\n   base::PlatformThread::SetName(\"CrPPAPIMain\");\n#if defined(OS_LINUX)\n  content::InitializeSandbox();\n#endif\n  ChildProcess ppapi_process;\n  ppapi_process.set_main_thread(\n      new PpapiThread(parameters.command_line, false));  \n  main_message_loop.Run();\n  return 0;\n}", "target": 0}
{"code": "CLOSE_BRACKET_WITHOUT_ESC_WARN(ScanEnv* env, UChar* c)\n{\n  if (onig_warn == onig_null_warn) return ;\n  if (IS_SYNTAX_BV((env)->syntax, ONIG_SYN_WARN_CC_OP_NOT_ESCAPED)) {\n      onig_syntax_warn(env, \"regular expression has '%s' without escape\", c);\n  }\n}", "target": 0}
{"code": "void dev_init_scheduler(struct net_device *dev)\n{\n\tqdisc_lock_tree(dev);\n\tdev->qdisc = &noop_qdisc;\n\tdev->qdisc_sleeping = &noop_qdisc;\n\tINIT_LIST_HEAD(&dev->qdisc_list);\n\tqdisc_unlock_tree(dev);\n\tsetup_timer(&dev->watchdog_timer, dev_watchdog, (unsigned long)dev);\n}", "target": 0}
{"code": "  DeletionConfirmationDlg(QWidget *parent, const int &size, const QString &name, bool defaultDeleteFiles): QDialog(parent) {\n    setupUi(this);\n    if (size == 1)\n      label->setText(tr(\"Are you sure you want to delete '%1' from the transfer list?\", \"Are you sure you want to delete 'ubuntu-linux-iso' from the transfer list?\").arg(name));\n    else\n      label->setText(tr(\"Are you sure you want to delete these %1 torrents from the transfer list?\", \"Are you sure you want to delete these 5 torrents from the transfer list?\").arg(QString::number(size)));\n    lbl_warn->setPixmap(GuiIconProvider::instance()->getIcon(\"dialog-warning\").pixmap(lbl_warn->height()));\n    lbl_warn->setFixedWidth(lbl_warn->height());\n    rememberBtn->setIcon(GuiIconProvider::instance()->getIcon(\"object-locked\"));\n    move(Utils::Misc::screenCenter(this));\n    checkPermDelete->setChecked(defaultDeleteFiles || Preferences::instance()->deleteTorrentFilesAsDefault());\n    connect(checkPermDelete, SIGNAL(clicked()), this, SLOT(updateRememberButtonState()));\n    buttonBox->button(QDialogButtonBox::Cancel)->setFocus();\n  }", "target": 1}
{"code": "virSecuritySELinuxRestoreInputLabel(virSecurityManager *mgr,\n                                    virDomainDef *def,\n                                    virDomainInputDef *input)\n{\n    int rc = 0;\n    virSecurityLabelDef *seclabel;\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (seclabel == NULL)\n        return 0;\n    switch ((virDomainInputType)input->type) {\n    case VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH:\n    case VIR_DOMAIN_INPUT_TYPE_EVDEV:\n        rc = virSecuritySELinuxRestoreFileLabel(mgr, input->source.evdev, true);\n        break;\n    case VIR_DOMAIN_INPUT_TYPE_MOUSE:\n    case VIR_DOMAIN_INPUT_TYPE_TABLET:\n    case VIR_DOMAIN_INPUT_TYPE_KBD:\n    case VIR_DOMAIN_INPUT_TYPE_LAST:\n        break;\n    }\n    return rc;\n}", "target": 0}
{"code": "static inline void RelinquishDCMMemory(DCMInfo *info,DCMMap *map,\n  DCMStreamInfo *stream_info,LinkedListInfo *stack,unsigned char *data)\n{\n  if (info->scale != (Quantum *) NULL)\n    info->scale=(Quantum *) RelinquishMagickMemory(info->scale);\n  if (map->gray != (int *) NULL)\n    map->gray=(int *) RelinquishMagickMemory(map->gray);\n  if (map->blue != (int *) NULL)\n    map->blue=(int *) RelinquishMagickMemory(map->blue);\n  if (map->green != (int *) NULL)\n    map->green=(int *) RelinquishMagickMemory(map->green);\n  if (map->red != (int *) NULL)\n    map->red=(int *) RelinquishMagickMemory(map->red);\n  if (stream_info->offsets != (ssize_t *) NULL)\n    stream_info->offsets=(ssize_t *) RelinquishMagickMemory(\n      stream_info->offsets);\n  if (stream_info != (DCMStreamInfo *) NULL)\n    stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info);\n  if (stack != (LinkedListInfo *) NULL)\n    stack=DestroyLinkedList(stack,RelinquishDCMInfo);\n  if (data != (unsigned char *) NULL)\n    data=(unsigned char *) RelinquishMagickMemory(data);\n}", "target": 0}
{"code": "_dbus_close_all (void)\n{\n  int maxfds, i;\n#ifdef __linux__\n  DIR *d;\n  d = opendir (\"/proc/self/fd\");\n  if (d)\n    {\n      for (;;)\n        {\n          struct dirent buf, *de;\n          int k, fd;\n          long l;\n          char *e = NULL;\n          k = readdir_r (d, &buf, &de);\n          if (k != 0 || !de)\n            break;\n          if (de->d_name[0] == '.')\n            continue;\n          errno = 0;\n          l = strtol (de->d_name, &e, 10);\n          if (errno != 0 || e == NULL || *e != '\\0')\n            continue;\n          fd = (int) l;\n          if (fd < 3)\n            continue;\n          if (fd == dirfd (d))\n            continue;\n          close (fd);\n        }\n      closedir (d);\n      return;\n    }\n#endif\n  maxfds = sysconf (_SC_OPEN_MAX);\n  if (maxfds < 0)\n    maxfds = 1024;\n  for (i = 3; i < maxfds; i++)\n    close (i);\n}", "target": 0}
{"code": "void __do_SAK(struct tty_struct *tty)\n{\n#ifdef TTY_SOFT_SAK\n\ttty_hangup(tty);\n#else\n\tstruct task_struct *g, *p;\n\tstruct pid *session;\n\tint\t\ti;\n\tif (!tty)\n\t\treturn;\n\tsession = tty->session;\n\ttty_ldisc_flush(tty);\n\ttty_driver_flush_buffer(tty);\n\tread_lock(&tasklist_lock);\n\tdo_each_pid_task(session, PIDTYPE_SID, p) {\n\t\ttty_notice(tty, \"SAK: killed process %d (%s): by session\\n\",\n\t\t\t   task_pid_nr(p), p->comm);\n\t\tgroup_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_SID);\n\t} while_each_pid_task(session, PIDTYPE_SID, p);\n\tdo_each_thread(g, p) {\n\t\tif (p->signal->tty == tty) {\n\t\t\ttty_notice(tty, \"SAK: killed process %d (%s): by controlling tty\\n\",\n\t\t\t\t   task_pid_nr(p), p->comm);\n\t\t\tgroup_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_SID);\n\t\t\tcontinue;\n\t\t}\n\t\ttask_lock(p);\n\t\ti = iterate_fd(p->files, 0, this_tty, tty);\n\t\tif (i != 0) {\n\t\t\ttty_notice(tty, \"SAK: killed process %d (%s): by fd#%d\\n\",\n\t\t\t\t   task_pid_nr(p), p->comm, i - 1);\n\t\t\tgroup_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_SID);\n\t\t}\n\t\ttask_unlock(p);\n\t} while_each_thread(g, p);\n\tread_unlock(&tasklist_lock);\n#endif\n}", "target": 1}
{"code": "mm_destroy(struct mm_master *mm)\n{\n\tmm_freelist(mm->mmalloc, &mm->rb_free);\n\tmm_freelist(mm->mmalloc, &mm->rb_allocated);\n\tif (munmap(mm->address, mm->size) == -1)\n\t\tfatal(\"munmap(%p, %zu): %s\", mm->address, mm->size,\n\t\t    strerror(errno));\n\tif (mm->mmalloc == NULL)\n\t\tfree(mm);\n\telse\n\t\tmm_free(mm->mmalloc, mm);\n}", "target": 1}
{"code": "static void bluetooth_client_finalize(GObject *object)\n{\n\tBluetoothClient *client = BLUETOOTH_CLIENT (object);\n\tBluetoothClientPrivate *priv = BLUETOOTH_CLIENT_GET_PRIVATE (client);\n\tif (priv->cancellable != NULL) {\n\t\tg_cancellable_cancel (priv->cancellable);\n\t\tg_clear_object (&priv->cancellable);\n\t}\n\tg_clear_object (&priv->manager);\n\tg_object_unref (priv->store);\n\tg_clear_pointer (&priv->default_adapter, gtk_tree_row_reference_free);\n\tG_OBJECT_CLASS(bluetooth_client_parent_class)->finalize (object);\n}", "target": 0}
{"code": "options_transports(void)\n{\nstruct transport_info * ti;\nuschar buf[64];\noptions_from_list(optionlist_transports, nelem(optionlist_transports), US\"TRANSPORTS\", NULL);\nfor (ti = transports_available; ti->driver_name[0]; ti++)\n  {\n  spf(buf, sizeof(buf), US\"_DRIVER_TRANSPORT_%T\", ti->driver_name);\n  builtin_macro_create(buf);\n  options_from_list(ti->options, (unsigned)*ti->options_count, US\"TRANSPORT\", ti->driver_name);\n  }\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, EqCanUseHashedIndexWithRegex) {\n    addIndex(BSON(\"a\"\n                  << \"hashed\"));\n    runQuery(fromjson(\"{a: {$eq: /abc/}}\"));\n    ASSERT_EQUALS(getNumSolutions(), 2U);\n}", "target": 0}
{"code": "init_device (u2fh_devs * devs, struct u2fdevice *dev)\n{\n  unsigned char resp[1024];\n  unsigned char nonce[8];\n  if (obtain_nonce(nonce) != 0)\n    {\n      return U2FH_TRANSPORT_ERROR;\n    }\n  size_t resplen = sizeof (resp);\n  dev->cid = CID_BROADCAST;\n  if (u2fh_sendrecv\n      (devs, dev->id, U2FHID_INIT, nonce, sizeof (nonce), resp,\n       &resplen) == U2FH_OK)\n    {\n      U2FHID_INIT_RESP initresp;\n      if (resplen > sizeof (initresp))\n\t{\n\t  return U2FH_MEMORY_ERROR;\n\t}\n      memcpy (&initresp, resp, resplen);\n      dev->cid = initresp.cid;\n      dev->versionInterface = initresp.versionInterface;\n      dev->versionMajor = initresp.versionMajor;\n      dev->versionMinor = initresp.versionMinor;\n      dev->capFlags = initresp.capFlags;\n    }\n  else\n    {\n      return U2FH_TRANSPORT_ERROR;\n    }\n  return U2FH_OK;\n}", "target": 1}
{"code": "MONGO_EXPORT int bson_finish( bson *b ) {\n    int i;\n    if( b->err & BSON_NOT_UTF8 )\n        return BSON_ERROR;\n    if ( ! b->finished ) {\n        if ( bson_ensure_space( b, 1 ) == BSON_ERROR ) return BSON_ERROR;\n        bson_append_byte( b, 0 );\n        i = b->cur - b->data;\n        bson_little_endian32( b->data, &i );\n        b->finished = 1;\n    }\n    return BSON_OK;\n}", "target": 1}
{"code": "static int check_submodule_url(const char *url)\n{\n\tconst char *curl_url;\n\tif (looks_like_command_line_option(url))\n\t\treturn -1;\n\tif (submodule_url_is_relative(url)) {\n\t\tchar *decoded = url_decode(url);\n\t\tint has_nl = !!strchr(decoded, '\\n');\n\t\tfree(decoded);\n\t\tif (has_nl)\n\t\t\treturn -1;\n\t}\n\telse if (url_to_curl_url(url, &curl_url)) {\n\t\tstruct credential c = CREDENTIAL_INIT;\n\t\tint ret = credential_from_url_gently(&c, curl_url, 1);\n\t\tcredential_clear(&c);\n\t\treturn ret;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "AP_CORE_DECLARE(void) ap_parse_uri(request_rec *r, const char *uri)\n{\n    int status = HTTP_OK;\n    r->unparsed_uri = apr_pstrdup(r->pool, uri);\n    while ((uri[0] == '/') && (uri[1] == '/')) {\n        ++uri ;\n    }\n    if (r->method_number == M_CONNECT) {\n        status = apr_uri_parse_hostinfo(r->pool, uri, &r->parsed_uri);\n    }\n    else {\n        status = apr_uri_parse(r->pool, uri, &r->parsed_uri);\n    }\n    if (status == APR_SUCCESS) {\n        if (r->parsed_uri.scheme\n            && !ap_cstr_casecmp(r->parsed_uri.scheme, ap_http_scheme(r))) {\n            r->hostname = r->parsed_uri.hostname;\n        }\n        else if (r->method_number == M_CONNECT) {\n            r->hostname = r->parsed_uri.hostname;\n        }\n        r->args = r->parsed_uri.query;\n        r->uri = r->parsed_uri.path ? r->parsed_uri.path\n                 : apr_pstrdup(r->pool, \"/\");\n#if defined(OS2) || defined(WIN32)\n        {\n            char *x;\n            for (x = r->uri; (x = strchr(x, '\\\\')) != NULL; )\n                *x = '/';\n        }\n#endif \n    }\n    else {\n        r->args = NULL;\n        r->hostname = NULL;\n        r->status = HTTP_BAD_REQUEST;             \n        r->uri = apr_pstrdup(r->pool, uri);\n    }\n}", "target": 1}
{"code": "void __drm_atomic_state_free(struct kref *ref)\n{\n\tstruct drm_atomic_state *state = container_of(ref, typeof(*state), ref);\n\tstruct drm_mode_config *config = &state->dev->mode_config;\n\tdrm_atomic_state_clear(state);\n\tdrm_dbg_atomic(state->dev, \"Freeing atomic state %p\\n\", state);\n\tif (config->funcs->atomic_state_free) {\n\t\tconfig->funcs->atomic_state_free(state);\n\t} else {\n\t\tdrm_atomic_state_default_release(state);\n\t\tkfree(state);\n\t}\n}", "target": 1}
{"code": "static void outbound_phy_packet_callback(struct fw_packet *packet,\n\t\t\t\t\t struct fw_card *card, int status)\n{\n\tstruct outbound_phy_packet_event *e =\n\t\tcontainer_of(packet, struct outbound_phy_packet_event, p);\n\tswitch (status) {\n\tcase ACK_COMPLETE:\te->phy_packet.rcode = RCODE_COMPLETE;\tbreak;\n\tcase ACK_PENDING:\te->phy_packet.rcode = RCODE_COMPLETE;\tbreak;\n\tcase ACK_BUSY_X:\n\tcase ACK_BUSY_A:\n\tcase ACK_BUSY_B:\te->phy_packet.rcode = RCODE_BUSY;\tbreak;\n\tcase ACK_DATA_ERROR:\te->phy_packet.rcode = RCODE_DATA_ERROR;\tbreak;\n\tcase ACK_TYPE_ERROR:\te->phy_packet.rcode = RCODE_TYPE_ERROR;\tbreak;\n\tdefault:\t\te->phy_packet.rcode = status;\t\tbreak;\n\t}\n\te->phy_packet.data[0] = packet->timestamp;\n\tqueue_event(e->client, &e->event, &e->phy_packet,\n\t\t    sizeof(e->phy_packet) + e->phy_packet.length, NULL, 0);\n\tclient_put(e->client);\n}", "target": 1}
{"code": "static void _cmd_window_show_opt(const char *data, int right)\n{\n\tMAIN_WINDOW_REC *parent;\n\tWINDOW_REC *window;\n\tif (*data == '\\0') cmd_return_error(CMDERR_NOT_ENOUGH_PARAMS);\n\tif (is_numeric(data, '\\0')) {\n\t\twindow = window_find_refnum(atoi(data));\n\t\tif (window == NULL) {\n\t\t\tprintformat_window(active_win, MSGLEVEL_CLIENTERROR,\n\t\t\t\t\t   TXT_REFNUM_NOT_FOUND, data);\n\t\t}\n\t} else {\n\t\twindow = window_find_item(active_win->active_server, data);\n\t}\n\tif (window == NULL || is_window_visible(window))\n\t\treturn;\n\tif (WINDOW_GUI(window)->sticky) {\n\t\tif (!settings_get_bool(\"autounstick_windows\")) {\n\t\t\tprintformat_window(active_win, MSGLEVEL_CLIENTERROR,\n\t\t\t\t\t   TXT_CANT_SHOW_STICKY_WINDOWS);\n\t\t\treturn;\n\t\t}\n\t}\n\tparent = mainwindow_create(right);\n\tparent->active = window;\n\tgui_window_reparent(window, parent);\n\tif (settings_get_bool(\"autostick_split_windows\"))\n\t\tgui_window_set_sticky(window);\n\tactive_mainwin = NULL;\n\twindow_set_active(window);\n}", "target": 1}
{"code": "uid_t session_info_uid_for_session(struct session_info *si, const char *session)\n{\n    uid_t ret = -1;\n    if (sd_session_get_uid(session, &ret) < 0) {\n        return -1;\n    }\n    return ret;\n}", "target": 0}
{"code": "void ap_lua_rstack_dump(lua_State *L, request_rec *r, const char *msg)\n{\n    int i;\n    int top = lua_gettop(L);\n    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(01484) \"Lua Stack Dump: [%s]\", msg);\n    for (i = 1; i <= top; i++) {\n        int t = lua_type(L, i);\n        switch (t) {\n        case LUA_TSTRING:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                              \"%d:  '%s'\", i, lua_tostring(L, i));\n                break;\n            }\n        case LUA_TUSERDATA:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, \"%d:  userdata\",\n                              i);\n                break;\n            }\n        case LUA_TLIGHTUSERDATA:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                              \"%d:  lightuserdata\", i);\n                break;\n            }\n        case LUA_TNIL:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, \"%d:  NIL\", i);\n                break;\n            }\n        case LUA_TNONE:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, \"%d:  None\", i);\n                break;\n            }\n        case LUA_TBOOLEAN:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                              \"%d:  %s\", i, lua_toboolean(L,\n                                                          i) ? \"true\" :\n                              \"false\");\n                break;\n            }\n        case LUA_TNUMBER:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                              \"%d:  %g\", i, lua_tonumber(L, i));\n                break;\n            }\n        case LUA_TTABLE:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                              \"%d:  <table>\", i);\n                break;\n            }\n        case LUA_TFUNCTION:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                              \"%d:  <function>\", i);\n                break;\n            }\n        default:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                              \"%d:  unknown: -[%s]-\", i, lua_typename(L, i));\n                break;\n            }\n        }\n    }\n}", "target": 0}
{"code": "char *BN_bn2dec(const BIGNUM *a)\n{\n    int i = 0, num, ok = 0;\n    char *buf = NULL;\n    char *p;\n    BIGNUM *t = NULL;\n    BN_ULONG *bn_data = NULL, *lp;\n    i = BN_num_bits(a) * 3;\n    num = (i / 10 + i / 1000 + 1) + 1;\n    bn_data = OPENSSL_malloc((num / BN_DEC_NUM + 1) * sizeof(BN_ULONG));\n    buf = OPENSSL_malloc(num + 3);\n    if ((buf == NULL) || (bn_data == NULL)) {\n        BNerr(BN_F_BN_BN2DEC, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    if ((t = BN_dup(a)) == NULL)\n        goto err;\n#define BUF_REMAIN (num+3 - (size_t)(p - buf))\n    p = buf;\n    lp = bn_data;\n    if (BN_is_zero(t)) {\n        *(p++) = '0';\n        *(p++) = '\\0';\n    } else {\n        if (BN_is_negative(t))\n            *p++ = '-';\n        i = 0;\n        while (!BN_is_zero(t)) {\n            *lp = BN_div_word(t, BN_DEC_CONV);\n            lp++;\n        }\n        lp--;\n        BIO_snprintf(p, BUF_REMAIN, BN_DEC_FMT1, *lp);\n        while (*p)\n            p++;\n        while (lp != bn_data) {\n            lp--;\n            BIO_snprintf(p, BUF_REMAIN, BN_DEC_FMT2, *lp);\n            while (*p)\n                p++;\n        }\n    }\n    ok = 1;\n err:\n    OPENSSL_free(bn_data);\n    BN_free(t);\n    if (ok)\n        return buf;\n    OPENSSL_free(buf);\n    return NULL;\n}", "target": 1}
{"code": "void av_fast_padded_mallocz(void *ptr, unsigned int *size, size_t min_size)\n{\n    uint8_t **p = ptr;\n    if (min_size > SIZE_MAX - FF_INPUT_BUFFER_PADDING_SIZE) {\n        av_freep(p);\n        *size = 0;\n        return;\n    }\n    if (!ff_fast_malloc(p, size, min_size + FF_INPUT_BUFFER_PADDING_SIZE, 1))\n        memset(*p, 0, min_size + FF_INPUT_BUFFER_PADDING_SIZE);\n}", "target": 0}
{"code": "int wait_for_key_construction(struct key *key, bool intr)\n{\n\tint ret;\n\tret = wait_on_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT,\n\t\t\t  intr ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE);\n\tif (ret)\n\t\treturn -ERESTARTSYS;\n\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags)) {\n\t\tsmp_rmb();\n\t\treturn key->reject_error;\n\t}\n\treturn key_validate(key);\n}", "target": 1}
{"code": "static int update_discovery_filter(struct btd_adapter *adapter)\n{\n\tstruct mgmt_cp_start_service_discovery *sd_cp;\n\tGSList *l;\n\tDBG(\"\");\n\tif (discovery_filter_to_mgmt_cp(adapter, &sd_cp)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"discovery_filter_to_mgmt_cp returned error\");\n\t\treturn -ENOMEM;\n\t}\n\tfor (l = adapter->discovery_list; l; l = g_slist_next(l)) {\n\t\tstruct discovery_client *client = l->data;\n\t\tif (!client->discovery_filter)\n\t\t\tcontinue;\n\t\tif (client->discovery_filter->discoverable)\n\t\t\tbreak;\n\t}\n\tset_discovery_discoverable(adapter, l ? true : false);\n\tif (filters_equal(adapter->current_discovery_filter, sd_cp) &&\n\t    adapter->discovering != 0) {\n\t\tDBG(\"filters were equal, deciding to not restart the scan.\");\n\t\tg_free(sd_cp);\n\t\treturn 0;\n\t}\n\tg_free(adapter->current_discovery_filter);\n\tadapter->current_discovery_filter = sd_cp;\n\ttrigger_start_discovery(adapter, 0);\n\treturn -EINPROGRESS;\n}", "target": 1}
{"code": "static int tcf_fill_node(struct sk_buff *skb, struct tcf_proto *tp,\n\t\t\t unsigned long fh, u32 pid, u32 seq, u16 flags, int event)\n{\n\tstruct tcmsg *tcm;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char *b = skb_tail_pointer(skb);\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*tcm), flags);\n\ttcm = NLMSG_DATA(nlh);\n\ttcm->tcm_family = AF_UNSPEC;\n\ttcm->tcm__pad1 = 0;\n\ttcm->tcm__pad1 = 0;\n\ttcm->tcm_ifindex = qdisc_dev(tp->q)->ifindex;\n\ttcm->tcm_parent = tp->classid;\n\ttcm->tcm_info = TC_H_MAKE(tp->prio, tp->protocol);\n\tNLA_PUT_STRING(skb, TCA_KIND, tp->ops->kind);\n\ttcm->tcm_handle = fh;\n\tif (RTM_DELTFILTER != event) {\n\t\ttcm->tcm_handle = 0;\n\t\tif (tp->ops->dump && tp->ops->dump(tp, fh, skb, tcm) < 0)\n\t\t\tgoto nla_put_failure;\n\t}\n\tnlh->nlmsg_len = skb_tail_pointer(skb) - b;\n\treturn skb->len;\nnlmsg_failure:\nnla_put_failure:\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}", "target": 1}
{"code": "static int decode_sequence(struct xdr_stream *xdr,\n\t\t\t   struct nfs4_sequence_res *res,\n\t\t\t   struct rpc_rqst *rqstp)\n{\n#if defined(CONFIG_NFS_V4_1)\n\tstruct nfs4_sessionid id;\n\tu32 dummy;\n\tint status;\n\t__be32 *p;\n\tif (!res->sr_session)\n\t\treturn 0;\n\tstatus = decode_op_hdr(xdr, OP_SEQUENCE);\n\tif (!status)\n\t\tstatus = decode_sessionid(xdr, &id);\n\tif (unlikely(status))\n\t\tgoto out_err;\n\tstatus = -EREMOTEIO;\n\tif (memcmp(id.data, res->sr_session->sess_id.data,\n\t\t   NFS4_MAX_SESSIONID_LEN)) {\n\t\tdprintk(\"%s Invalid session id\\n\", __func__);\n\t\tgoto out_err;\n\t}\n\tp = xdr_inline_decode(xdr, 20);\n\tif (unlikely(!p))\n\t\tgoto out_overflow;\n\tdummy = be32_to_cpup(p++);\n\tif (dummy != res->sr_slot->seq_nr) {\n\t\tdprintk(\"%s Invalid sequence number\\n\", __func__);\n\t\tgoto out_err;\n\t}\n\tdummy = be32_to_cpup(p++);\n\tif (dummy != res->sr_slot - res->sr_session->fc_slot_table.slots) {\n\t\tdprintk(\"%s Invalid slot id\\n\", __func__);\n\t\tgoto out_err;\n\t}\n\tdummy = be32_to_cpup(p++);\n\tdummy = be32_to_cpup(p++);\n\tres->sr_status_flags = be32_to_cpup(p);\n\tstatus = 0;\nout_err:\n\tres->sr_status = status;\n\treturn status;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\tstatus = -EIO;\n\tgoto out_err;\n#else  \n\treturn 0;\n#endif \n}", "target": 0}
{"code": "static int __btrfs_set_acl(struct btrfs_trans_handle *trans,\n\t\t\t struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint ret, size = 0;\n\tconst char *name;\n\tchar *value = NULL;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tret = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (ret == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EINVAL : 0;\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_KERNEL);\n\t\tif (!value) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tret = __btrfs_setxattr(trans, inode, name, value, size, 0);\nout:\n\tkfree(value);\n\tif (!ret)\n\t\tset_cached_acl(inode, type, acl);\n\treturn ret;\n}", "target": 1}
{"code": "int crxParamInit(CrxBandParam **param, uint64_t subbandMdatOffset,\n                 uint64_t subbandDataSize, uint32_t subbandWidth,\n                 uint32_t subbandHeight, int32_t supportsPartial,\n                 uint32_t roundedBitsMask, LibRaw_abstract_datastream *input)\n{\n  int32_t progrDataSize = supportsPartial ? 0 : sizeof(int32_t) * subbandWidth;\n  int32_t paramLength = 2 * subbandWidth + 4;\n  uint8_t *paramBuf = (uint8_t *)calloc(\n      1, sizeof(CrxBandParam) + sizeof(int32_t) * paramLength + progrDataSize);\n  if (!paramBuf)\n    return -1;\n  *param = (CrxBandParam *)paramBuf;\n  paramBuf += sizeof(CrxBandParam);\n  (*param)->paramData = (int32_t *)paramBuf;\n  (*param)->nonProgrData =\n      progrDataSize ? (*param)->paramData + paramLength : 0;\n  (*param)->subbandWidth = subbandWidth;\n  (*param)->subbandHeight = subbandHeight;\n  (*param)->roundedBits = 0;\n  (*param)->curLine = 0;\n  (*param)->roundedBitsMask = roundedBitsMask;\n  (*param)->supportsPartial = supportsPartial;\n  (*param)->bitStream.bitData = 0;\n  (*param)->bitStream.bitsLeft = 0;\n  (*param)->bitStream.mdatSize = subbandDataSize;\n  (*param)->bitStream.curPos = 0;\n  (*param)->bitStream.curBufSize = 0;\n  (*param)->bitStream.curBufOffset = subbandMdatOffset;\n  (*param)->bitStream.input = input;\n  crxFillBuffer(&(*param)->bitStream);\n  return 0;\n}", "target": 1}
{"code": "  bool const_item() const { return used_tables() == 0; }", "target": 1}
{"code": "passAddName (CharsString * name, int var)\n{\n  int k;\n  struct PassName *curname;\n  CharsString augmentedName;\n  for (augmentedName.length = 0;\n       augmentedName.length < name->length; augmentedName.length++)\n    augmentedName.\n      chars[augmentedName.length] = name->chars[augmentedName.length];\n  augmentedName.chars[augmentedName.length++] = passOpcode;\n  if (!\n      (curname =\n       malloc (sizeof (*curname) + CHARSIZE * (augmentedName.length - 1))))\n    {\n      outOfMemory ();\n    }\n  memset (curname, 0, sizeof (*curname));\n  for (k = 0; k < augmentedName.length; k++)\n    {\n      curname->name[k] = augmentedName.chars[k];\n    }\n  curname->length = augmentedName.length;\n  curname->varnum = var;\n  curname->next = passNames;\n  passNames = curname;\n  return 1;\n}", "target": 0}
{"code": "static void *createArrayObject(const redisReadTask *task, size_t elements) {\n    redisReply *r, *parent;\n    r = createReplyObject(task->type);\n    if (r == NULL)\n        return NULL;\n    if (elements > 0) {\n        if (SIZE_MAX / sizeof(redisReply*) < elements) return NULL;  \n        r->element = hi_calloc(elements,sizeof(redisReply*));\n        if (r->element == NULL) {\n            freeReplyObject(r);\n            return NULL;\n        }\n    }\n    r->elements = elements;\n    if (task->parent) {\n        parent = task->parent->obj;\n        assert(parent->type == REDIS_REPLY_ARRAY ||\n               parent->type == REDIS_REPLY_MAP ||\n               parent->type == REDIS_REPLY_SET ||\n               parent->type == REDIS_REPLY_PUSH);\n        parent->element[task->idx] = r;\n    }\n    return r;\n}", "target": 0}
{"code": "int ssh_scp_close(ssh_scp scp)\n{\n    char buffer[128] = {0};\n    int rc;\n    if (scp == NULL) {\n        return SSH_ERROR;\n    }\n    if (scp->channel != NULL) {\n        if (ssh_channel_send_eof(scp->channel) == SSH_ERROR) {\n            scp->state = SSH_SCP_ERROR;\n            return SSH_ERROR;\n        }\n        while (!ssh_channel_is_eof(scp->channel)) {\n            rc = ssh_channel_read(scp->channel, buffer, sizeof(buffer), 0);\n            if (rc == SSH_ERROR || rc == 0) {\n                break;\n            }\n        }\n        if (ssh_channel_close(scp->channel) == SSH_ERROR) {\n            scp->state = SSH_SCP_ERROR;\n            return SSH_ERROR;\n        }\n        ssh_channel_free(scp->channel);\n        scp->channel = NULL;\n    }\n    scp->state = SSH_SCP_NEW;\n    return SSH_OK;\n}", "target": 0}
{"code": "static void virtio_net_vhost_status(VirtIONet *n, uint8_t status)\n{\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n    NetClientState *nc = qemu_get_queue(n->nic);\n    int queue_pairs = n->multiqueue ? n->max_queue_pairs : 1;\n    int cvq = n->max_ncs - n->max_queue_pairs;\n    if (!get_vhost_net(nc->peer)) {\n        return;\n    }\n    if ((virtio_net_started(n, status) && !nc->peer->link_down) ==\n        !!n->vhost_started) {\n        return;\n    }\n    if (!n->vhost_started) {\n        int r, i;\n        if (n->needs_vnet_hdr_swap) {\n            error_report(\"backend does not support %s vnet headers; \"\n                         \"falling back on userspace virtio\",\n                         virtio_is_big_endian(vdev) ? \"BE\" : \"LE\");\n            return;\n        }\n        for (i = 0;  i < queue_pairs; i++) {\n            NetClientState *qnc = qemu_get_subqueue(n->nic, i);\n            qemu_net_queue_purge(qnc->peer->incoming_queue, qnc);\n            qemu_net_queue_purge(qnc->incoming_queue, qnc->peer);\n        }\n        if (virtio_has_feature(vdev->guest_features, VIRTIO_NET_F_MTU)) {\n            r = vhost_net_set_mtu(get_vhost_net(nc->peer), n->net_conf.mtu);\n            if (r < 0) {\n                error_report(\"%uBytes MTU not supported by the backend\",\n                             n->net_conf.mtu);\n                return;\n            }\n        }\n        n->vhost_started = 1;\n        r = vhost_net_start(vdev, n->nic->ncs, queue_pairs, cvq);\n        if (r < 0) {\n            error_report(\"unable to start vhost net: %d: \"\n                         \"falling back on userspace virtio\", -r);\n            n->vhost_started = 0;\n        }\n    } else {\n        vhost_net_stop(vdev, n->nic->ncs, queue_pairs, cvq);\n        n->vhost_started = 0;\n    }\n}", "target": 0}
{"code": "static struct nft_chain *nf_tables_chain_lookup(const struct nft_table *table,\n\t\t\t\t\t\tconst struct nlattr *nla)\n{\n\tstruct nft_chain *chain;\n\tif (nla == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\tlist_for_each_entry(chain, &table->chains, list) {\n\t\tif (!nla_strcmp(nla, chain->name))\n\t\t\treturn chain;\n\t}\n\treturn ERR_PTR(-ENOENT);\n}", "target": 0}
{"code": "merged_2v_upsample(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n                   JDIMENSION *in_row_group_ctr,\n                   JDIMENSION in_row_groups_avail, JSAMPARRAY output_buf,\n                   JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)\n{\n  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n  JSAMPROW work_ptrs[2];\n  JDIMENSION num_rows;          \n  if (upsample->spare_full) {\n    JDIMENSION size = upsample->out_row_width;\n    if (cinfo->out_color_space == JCS_RGB565)\n      size = cinfo->output_width * 2;\n    jcopy_sample_rows(&upsample->spare_row, 0, output_buf + *out_row_ctr, 0, 1,\n                      size);\n    num_rows = 1;\n    upsample->spare_full = FALSE;\n  } else {\n    num_rows = 2;\n    if (num_rows > upsample->rows_to_go)\n      num_rows = upsample->rows_to_go;\n    out_rows_avail -= *out_row_ctr;\n    if (num_rows > out_rows_avail)\n      num_rows = out_rows_avail;\n    work_ptrs[0] = output_buf[*out_row_ctr];\n    if (num_rows > 1) {\n      work_ptrs[1] = output_buf[*out_row_ctr + 1];\n    } else {\n      work_ptrs[1] = upsample->spare_row;\n      upsample->spare_full = TRUE;\n    }\n    (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr, work_ptrs);\n  }\n  *out_row_ctr += num_rows;\n  upsample->rows_to_go -= num_rows;\n  if (!upsample->spare_full)\n    (*in_row_group_ctr)++;\n}", "target": 1}
{"code": "static size_t vnc_client_read_plain(VncState *vs)\n{\n    size_t ret;\n    VNC_DEBUG(\"Read plain %p size %zd offset %zd\\n\",\n              vs->input.buffer, vs->input.capacity, vs->input.offset);\n    buffer_reserve(&vs->input, 4096);\n    ret = vnc_client_read_buf(vs, buffer_end(&vs->input), 4096);\n    if (!ret)\n        return 0;\n    vs->input.offset += ret;\n    return ret;\n}", "target": 0}
{"code": "Eina_Bool ewk_view_history_enable_set(Evas_Object* ewkView, Eina_Bool enable)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv, false);\n    static_cast<WebCore::BackForwardListImpl*>(priv->page->backForwardList())->setEnabled(enable);\n    return true;\n}", "target": 0}
{"code": "dissect_header_lens_v2_large(tvbuff_t *tvb, wtap_syscall_header* syscall_header, int offset, proto_tree *tree, int encoding)\n{\n    guint32 param_count;\n    proto_item *ti;\n    proto_tree *len_tree;\n    ti = proto_tree_add_item(tree, hf_se_param_lens, tvb, offset, syscall_header->nparams * SYSDIG_PARAM_SIZE_V2_LARGE, ENC_NA);\n    len_tree = proto_item_add_subtree(ti, ett_sysdig_parm_lens);\n    for (param_count = 0; param_count < syscall_header->nparams; param_count++) {\n        proto_tree_add_item(len_tree, hf_se_param_len, tvb, offset + (param_count * SYSDIG_PARAM_SIZE_V2_LARGE), SYSDIG_PARAM_SIZE_V2_LARGE, encoding);\n    }\n    proto_item_set_len(ti, syscall_header->nparams * SYSDIG_PARAM_SIZE_V2_LARGE);\n    return syscall_header->nparams * SYSDIG_PARAM_SIZE_V2_LARGE;\n}", "target": 0}
{"code": "static inline void native_set_ldt(const void *addr, unsigned int entries)\n{\n\tif (likely(entries == 0))\n\t\tasm volatile(\"lldt %w0\"::\"q\" (0));\n\telse {\n\t\tunsigned cpu = smp_processor_id();\n\t\tldt_desc ldt;\n\t\tset_tssldt_descriptor(&ldt, (unsigned long)addr,\n\t\t\t\t      DESC_LDT, entries * sizeof(ldt) - 1);\n\t\twrite_gdt_entry(get_cpu_gdt_table(cpu), GDT_ENTRY_LDT,\n\t\t\t\t&ldt, DESC_LDT);\n\t\tasm volatile(\"lldt %w0\"::\"q\" (GDT_ENTRY_LDT*8));\n\t}\n}", "target": 1}
{"code": "void fill_luma_motion_vector_predictors(base_context* ctx,\n                                        const slice_segment_header* shdr,\n                                        de265_image* img,\n                                        int xC,int yC,int nCS,int xP,int yP,\n                                        int nPbW,int nPbH, int l,\n                                        int refIdx, int partIdx,\n                                        MotionVector out_mvpList[2])\n{\n  uint8_t availableFlagLXN[2];\n  MotionVector mvLXN[2];\n  derive_spatial_luma_vector_prediction(ctx, img, shdr, xC,yC, nCS, xP,yP,\n                                        nPbW,nPbH, l, refIdx, partIdx,\n                                        availableFlagLXN, mvLXN);\n  uint8_t availableFlagLXCol;\n  MotionVector mvLXCol;\n  if (availableFlagLXN[0] &&\n      availableFlagLXN[1] &&\n      (mvLXN[0].x != mvLXN[1].x || mvLXN[0].y != mvLXN[1].y)) {\n    availableFlagLXCol = 0;\n  }\n  else {\n    derive_temporal_luma_vector_prediction(ctx, img, shdr,\n                                           xP,yP, nPbW,nPbH, refIdx,l,\n                                           &mvLXCol, &availableFlagLXCol);\n  }\n  int numMVPCandLX=0;\n  if (availableFlagLXN[0])\n    {\n      out_mvpList[numMVPCandLX++] = mvLXN[0];\n    }\n  if (availableFlagLXN[1] &&\n      (!availableFlagLXN[0] || \n       (mvLXN[0].x != mvLXN[1].x || mvLXN[0].y != mvLXN[1].y)))\n    {\n      out_mvpList[numMVPCandLX++] = mvLXN[1];\n    }\n  if (availableFlagLXCol)\n    {\n      out_mvpList[numMVPCandLX++] = mvLXCol;\n    }\n  while (numMVPCandLX<2) {\n    out_mvpList[numMVPCandLX].x = 0;\n    out_mvpList[numMVPCandLX].y = 0;\n    numMVPCandLX++;\n  }\n  assert(numMVPCandLX==2);\n}", "target": 0}
{"code": "static void *bpf_any_get(void *raw, enum bpf_type type)\n{\n\tswitch (type) {\n\tcase BPF_TYPE_PROG:\n\t\tatomic_inc(&((struct bpf_prog *)raw)->aux->refcnt);\n\t\tbreak;\n\tcase BPF_TYPE_MAP:\n\t\tbpf_map_inc(raw, true);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\treturn raw;\n}", "target": 1}
{"code": "static void do_free_publickey(struct rsa_public_key *key)\n{\n\tcrypto_bignum_free(key->e);\n\tcrypto_bignum_free(key->n);\n}", "target": 1}
{"code": "  ClickModifierTest() {\n  }", "target": 0}
{"code": "  void dumpState(std::ostream& os, int indent_level = 0) const override {\n    header_map_->dumpState(os, indent_level);\n  }", "target": 0}
{"code": "static int su3000_power_ctrl(struct dvb_usb_device *d, int i)\n{\n\tstruct dw2102_state *state = (struct dw2102_state *)d->priv;\n\tu8 obuf[] = {0xde, 0};\n\tinfo(\"%s: %d, initialized %d\", __func__, i, state->initialized);\n\tif (i && !state->initialized) {\n\t\tstate->initialized = 1;\n\t\treturn dvb_usb_generic_rw(d, obuf, 2, NULL, 0, 0);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "int hci_req_sync(struct hci_dev *hdev, int (*req)(struct hci_request *req,\n\t\t\t\t\t\t  unsigned long opt),\n\t\t unsigned long opt, u32 timeout, u8 *hci_status)\n{\n\tint ret;\n\tif (!test_bit(HCI_UP, &hdev->flags))\n\t\treturn -ENETDOWN;\n\thci_req_sync_lock(hdev);\n\tret = __hci_req_sync(hdev, req, opt, timeout, hci_status);\n\thci_req_sync_unlock(hdev);\n\treturn ret;\n}", "target": 1}
{"code": "n_start_visual_mode(int c)\n{\n#ifdef FEAT_CONCEAL\n    int cursor_line_was_concealed = curwin->w_p_cole > 0\n\t\t\t\t\t\t&& conceal_cursor_line(curwin);\n#endif\n    VIsual_mode = c;\n    VIsual_active = TRUE;\n    VIsual_reselect = TRUE;\n    trigger_modechanged();\n    if (c == Ctrl_V && (get_ve_flags() & VE_BLOCK) && gchar_cursor() == TAB)\n    {\n\tvalidate_virtcol();\n\tcoladvance(curwin->w_virtcol);\n    }\n    VIsual = curwin->w_cursor;\n#ifdef FEAT_FOLDING\n    foldAdjustVisual();\n#endif\n    setmouse();\n#ifdef FEAT_CONCEAL\n    conceal_check_cursor_line(cursor_line_was_concealed);\n#endif\n    if (p_smd && msg_silent == 0)\n\tredraw_cmdline = TRUE;\t\n#ifdef FEAT_CLIPBOARD\n    clip_star.vmode = NUL;\n#endif\n    if (curwin->w_redr_type < INVERTED)\n    {\n\tcurwin->w_old_cursor_lnum = curwin->w_cursor.lnum;\n\tcurwin->w_old_visual_lnum = curwin->w_cursor.lnum;\n    }\n}", "target": 1}
{"code": "int DH_set0_pqg(DH *dh, BIGNUM *p, BIGNUM *q, BIGNUM *g) {\n    if(!p || !g) \n        return 0;\n    BN_free(dh->p);\n    BN_free(dh->q);\n    BN_free(dh->g);\n    dh->p = p;\n    dh->q = q;\n    dh->g = g;\n    if(q)\n        dh->length = BN_num_bits(q);\n    return 1;\n}", "target": 1}
{"code": "static int ext4_write_begin(struct file *file, struct address_space *mapping,\n\t\t\t    loff_t pos, unsigned len, unsigned flags,\n\t\t\t    struct page **pagep, void **fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tint ret, needed_blocks;\n\thandle_t *handle;\n\tint retries = 0;\n\tstruct page *page;\n\tpgoff_t index;\n\tunsigned from, to;\n\ttrace_ext4_write_begin(inode, pos, len, flags);\n\tneeded_blocks = ext4_writepage_trans_blocks(inode) + 1;\n\tindex = pos >> PAGE_CACHE_SHIFT;\n\tfrom = pos & (PAGE_CACHE_SIZE - 1);\n\tto = from + len;\nretry:\n\thandle = ext4_journal_start(inode, needed_blocks);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto out;\n\t}\n\tflags |= AOP_FLAG_NOFS;\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page) {\n\t\text4_journal_stop(handle);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\t*pagep = page;\n\tret = block_write_begin(file, mapping, pos, len, flags, pagep, fsdata,\n\t\t\t\text4_get_block);\n\tif (!ret && ext4_should_journal_data(inode)) {\n\t\tret = walk_page_buffers(handle, page_buffers(page),\n\t\t\t\tfrom, to, NULL, do_journal_get_write_access);\n\t}\n\tif (ret) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tif (pos + len > inode->i_size && ext4_can_truncate(inode))\n\t\t\text4_orphan_add(handle, inode);\n\t\text4_journal_stop(handle);\n\t\tif (pos + len > inode->i_size) {\n\t\t\text4_truncate_failed_write(inode);\n\t\t\tif (inode->i_nlink)\n\t\t\t\text4_orphan_del(NULL, inode);\n\t\t}\n\t}\n\tif (ret == -ENOSPC && ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\tgoto retry;\nout:\n\treturn ret;\n}", "target": 1}
{"code": "static struct desc_struct *get_desc(unsigned short sel)\n{\n\tstruct desc_ptr gdt_desc = {0, 0};\n\tunsigned long desc_base;\n#ifdef CONFIG_MODIFY_LDT_SYSCALL\n\tif ((sel & SEGMENT_TI_MASK) == SEGMENT_LDT) {\n\t\tstruct desc_struct *desc = NULL;\n\t\tstruct ldt_struct *ldt;\n\t\tsel >>= 3;\n\t\tmutex_lock(&current->active_mm->context.lock);\n\t\tldt = current->active_mm->context.ldt;\n\t\tif (ldt && sel < ldt->nr_entries)\n\t\t\tdesc = &ldt->entries[sel];\n\t\tmutex_unlock(&current->active_mm->context.lock);\n\t\treturn desc;\n\t}\n#endif\n\tnative_store_gdt(&gdt_desc);\n\tdesc_base = sel & ~(SEGMENT_RPL_MASK | SEGMENT_TI_MASK);\n\tif (desc_base > gdt_desc.size)\n\t\treturn NULL;\n\treturn (struct desc_struct *)(gdt_desc.address + desc_base);\n}", "target": 1}
{"code": "static void logi_dj_recv_destroy_djhid_device(struct dj_receiver_dev *djrcv_dev,\n\t\t\t\t\t\tstruct dj_report *dj_report)\n{\n\tstruct dj_device *dj_dev;\n\tunsigned long flags;\n\tspin_lock_irqsave(&djrcv_dev->lock, flags);\n\tdj_dev = djrcv_dev->paired_dj_devices[dj_report->device_index];\n\tdjrcv_dev->paired_dj_devices[dj_report->device_index] = NULL;\n\tspin_unlock_irqrestore(&djrcv_dev->lock, flags);\n\tif (dj_dev != NULL) {\n\t\thid_destroy_device(dj_dev->hdev);\n\t\tkfree(dj_dev);\n\t} else {\n\t\tdev_err(&djrcv_dev->hdev->dev, \"%s: can't destroy a NULL device\\n\",\n\t\t\t__func__);\n\t}\n}", "target": 0}
{"code": "compat_cipher_proposal(struct ssh *ssh, char *cipher_prop)\n{\n\tif (!(ssh->compat & SSH_BUG_BIGENDIANAES))\n\t\treturn cipher_prop;\n\tdebug2_f(\"original cipher proposal: %s\", cipher_prop);\n\tif ((cipher_prop = match_filter_denylist(cipher_prop, \"aes*\")) == NULL)\n\t\tfatal(\"match_filter_denylist failed\");\n\tdebug2_f(\"compat cipher proposal: %s\", cipher_prop);\n\tif (*cipher_prop == '\\0')\n\t\tfatal(\"No supported ciphers found\");\n\treturn cipher_prop;\n}", "target": 1}
{"code": "int BN_is_odd(const BIGNUM *a)\n{\n    return (a->top > 0) && (a->d[0] & 1);\n}", "target": 0}
{"code": "void HTMLInputElement::setRangeText(const String& replacement, unsigned start, unsigned end, const String& selectionMode, ExceptionState& exceptionState)\n{\n    if (!m_inputType->supportsSelectionAPI()) {\n        exceptionState.throwDOMException(InvalidStateError, \"The input element's type ('\" + m_inputType->formControlType() + \"') does not support selection.\");\n        return;\n    }\n    HTMLTextFormControlElement::setRangeText(replacement, start, end, selectionMode, exceptionState);\n}", "target": 0}
{"code": "ldns_fget_keyword_data(FILE *f, const char *keyword, const char *k_del, char *data,\n               const char *d_del, size_t data_limit)\n{\n       return ldns_fget_keyword_data_l(f, keyword, k_del, data, d_del,\n\t\t       data_limit, NULL);\n}", "target": 0}
{"code": "deltas_head_init(struct deltas_head *list)\n{\n\tlist->array = NULL;\n\tlist->len = 0;\n\tlist->capacity = 0;\n}", "target": 1}
{"code": "static int core_upgrade_handler(request_rec *r)\n{\n    conn_rec *c = r->connection;\n    const char *upgrade;\n    if (c->master) {\n        return DECLINED;\n    }\n    upgrade = apr_table_get(r->headers_in, \"Upgrade\");\n    if (upgrade && *upgrade) {\n        const char *conn = apr_table_get(r->headers_in, \"Connection\");\n        if (ap_find_token(r->pool, conn, \"upgrade\")) {\n            apr_array_header_t *offers = NULL;\n            const char *err;\n            err = ap_parse_token_list_strict(r->pool, upgrade, &offers, 0);\n            if (err) {\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02910)\n                              \"parsing Upgrade header: %s\", err);\n                return DECLINED;\n            }\n            if (offers && offers->nelts > 0) {\n                const char *protocol = ap_select_protocol(c, r, NULL, offers);\n                if (protocol && strcmp(protocol, ap_get_protocol(c))) {\n                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02909)\n                                  \"Upgrade selects '%s'\", protocol);\n                    apr_table_clear(r->headers_out);\n                    apr_table_setn(r->headers_out, \"Upgrade\", protocol);\n                    apr_table_setn(r->headers_out, \"Connection\", \"Upgrade\");\n                    r->status = HTTP_SWITCHING_PROTOCOLS;\n                    r->status_line = ap_get_status_line(r->status);\n                    ap_send_interim_response(r, 1);\n                    ap_switch_protocol(c, r, r->server, protocol);\n                    c->keepalive = AP_CONN_CLOSE;\n                    return DONE;\n                }\n            }\n        }\n    }\n    else if (!c->keepalives) {\n        const apr_array_header_t *upgrades;\n        ap_get_protocol_upgrades(c, r, NULL, 0, &upgrades);\n        if (upgrades && upgrades->nelts > 0) {\n            char *protocols = apr_array_pstrcat(r->pool, upgrades, ',');\n            apr_table_setn(r->headers_out, \"Upgrade\", protocols);\n            apr_table_setn(r->headers_out, \"Connection\", \"Upgrade\");\n        }\n    }\n    return DECLINED;\n}", "target": 0}
{"code": "bool DependencyOptimizer::SafeToRemoveIdentity(const NodeDef& node) const {\n  if (!IsIdentity(node) && !IsIdentityN(node)) {\n    return true;\n  }\n  if (nodes_to_preserve_.find(node.name()) != nodes_to_preserve_.end()) {\n    return false;\n  }\n  if (!fetch_nodes_known_) {\n    return false;\n  }\n  if (node.input_size() < 1) {\n    return false;\n  }\n  const NodeDef* input = node_map_->GetNode(NodeName(node.input(0)));\n  if (input == nullptr) {\n    VLOG(1) << \"node = \" << node.name() << \" input = \" << node.input(0);\n    return false;\n  }\n  if (IsVariable(*input) || IsRecv(*input)) {\n    return false;\n  }\n  for (const auto& consumer : node_map_->GetOutputs(node.name())) {\n    if (node.input_size() > 1 && (IsRetval(*consumer) || IsMerge(*consumer))) {\n      return false;\n    }\n    if (IsSwitch(*input)) {\n      for (const string& consumer_input : consumer->input()) {\n        if (consumer_input == AsControlDependency(node.name())) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}", "target": 0}
{"code": "static void uc_invalidate_tb(struct uc_struct *uc, uint64_t start_addr, size_t len) \n{\n    tb_page_addr_t start, end;\n    start = get_page_addr_code(uc->cpu->env_ptr, start_addr) & (target_ulong)(-1);\n    end = (start + len) & (target_ulong)(-1);\n    if (start > end) {\n        return;\n    }\n    tb_invalidate_phys_range(uc, start, end);\n}", "target": 1}
{"code": "get_parent_resource(const dav_resource *resource,\n                    dav_resource **parent_resource)\n{\n  dav_resource *parent;\n  dav_resource_private *parentinfo;\n  svn_stringbuf_t *path = resource->info->uri_path;\n  *parent_resource = NULL;\n  if (path->len == 1 && *path->data == '/')\n    return NULL;\n  switch (resource->type)\n    {\n    case DAV_RESOURCE_TYPE_REGULAR:\n      parent = apr_pcalloc(resource->pool, sizeof(*parent));\n      parentinfo  = apr_pcalloc(resource->pool, sizeof(*parentinfo));\n      parent->type = DAV_RESOURCE_TYPE_REGULAR;\n      parent->exists = 1;\n      parent->collection = 1;\n      parent->versioned = 1;\n      parent->hooks = resource->hooks;\n      parent->pool = resource->pool;\n      parent->uri = get_parent_path(svn_urlpath__canonicalize(resource->uri,\n                                                              resource->pool),\n                                    TRUE, resource->pool);\n      parent->info = parentinfo;\n      parentinfo->uri_path =\n        svn_stringbuf_create(get_parent_path(resource->info->uri_path->data,\n                                             TRUE, resource->pool),\n                             resource->pool);\n      parentinfo->repos = resource->info->repos;\n      parentinfo->root = resource->info->root;\n      parentinfo->r = resource->info->r;\n      parentinfo->svn_client_options = resource->info->svn_client_options;\n      parentinfo->repos_path = get_parent_path(resource->info->repos_path,\n                                               FALSE, resource->pool);\n      *parent_resource = parent;\n      break;\n    case DAV_RESOURCE_TYPE_WORKING:\n      *parent_resource =\n        create_private_resource(resource, DAV_SVN_RESTYPE_WRK_COLLECTION);\n      break;\n    case DAV_RESOURCE_TYPE_ACTIVITY:\n      *parent_resource =\n        create_private_resource(resource, DAV_SVN_RESTYPE_ACT_COLLECTION);\n      break;\n    case DAV_RESOURCE_TYPE_PRIVATE:\n      if ((resource->info->restype == DAV_SVN_RESTYPE_TXN_COLLECTION)\n          || (resource->info->restype == DAV_SVN_RESTYPE_REV_COLLECTION))\n        *parent_resource =\n          create_private_resource(resource, resource->info->restype);\n      break;\n    default:\n      break;\n    }\n  if (! *parent_resource)\n    return dav_svn__new_error(resource->pool, HTTP_INTERNAL_SERVER_ERROR, 0,\n                              apr_psprintf(resource->pool,\n                                           \"get_parent_resource was called for \"\n                                           \"%s (type %d)\",\n                                           resource->uri, resource->type));\n  return NULL;\n}", "target": 1}
{"code": "static void show_netdevs(void)\n{\n    int idx;\n    const char *available_netdevs[] = {\n        \"socket\",\n        \"hubport\",\n        \"tap\",\n#ifdef CONFIG_SLIRP\n        \"user\",\n#endif\n#ifdef CONFIG_L2TPV3\n        \"l2tpv3\",\n#endif\n#ifdef CONFIG_VDE\n        \"vde\",\n#endif\n#ifdef CONFIG_NET_BRIDGE\n        \"bridge\",\n#endif\n#ifdef CONFIG_NETMAP\n        \"netmap\",\n#endif\n#ifdef CONFIG_POSIX\n        \"vhost-user\",\n#endif\n    };\n    printf(\"Available netdev backend types:\\n\");\n    for (idx = 0; idx < ARRAY_SIZE(available_netdevs); idx++) {\n        puts(available_netdevs[idx]);\n    }\n}", "target": 0}
{"code": "void zend_accel_shared_protect(int mode)\n{\n#ifdef HAVE_MPROTECT\n\tint i;\n\tif (mode) {\n\t\tmode = PROT_READ;\n\t} else {\n\t\tmode = PROT_READ|PROT_WRITE;\n\t}\n\tfor (i = 0; i < ZSMMG(shared_segments_count); i++) {\n\t\tmprotect(ZSMMG(shared_segments)[i]->p, ZSMMG(shared_segments)[i]->size, mode);\n\t}\n#endif\n}", "target": 0}
{"code": "SWFInput_file_getChar(SWFInput input)\n{\n\tint c = fgetc((FILE *)input->data);\n\tif ( c == EOF )\n\t\tinput->length = input->offset;\n\telse\n\t\t++input->offset;\n\treturn c;\n}", "target": 0}
{"code": "static int get_lower_vlan_dev_tc(struct net_device *dev,\n\t\t\t\t struct netdev_nested_priv *priv)\n{\n\tstruct iboe_prio_tc_map *map = (struct iboe_prio_tc_map *)priv->data;\n\tif (is_vlan_dev(dev))\n\t\tmap->output_tc = get_vlan_ndev_tc(dev, map->input_prio);\n\telse if (dev->num_tc)\n\t\tmap->output_tc = netdev_get_prio_tc_map(dev, map->input_prio);\n\telse\n\t\tmap->output_tc = 0;\n\tmap->found = true;\n\treturn 1;\n}", "target": 0}
{"code": "static inline long div_long_long_rem_signed(const long long dividend,\n\t\t\t\t\t    const long divisor, long *remainder)\n{\n\tlong res;\n\tif (unlikely(dividend < 0)) {\n\t\tres = -div_long_long_rem(-dividend, divisor, remainder);\n\t\t*remainder = -(*remainder);\n\t} else\n\t\tres = div_long_long_rem(dividend, divisor, remainder);\n\treturn res;\n}", "target": 1}
{"code": "hash_findi_add(struct hash_table *hash, const char *str)\n{\n    struct hash_insert hi;\n    void **r;\n    char *strx;\n    size_t l = strlen(str) + 1;\n    r = hash_findib(hash, str, l, &hi);\n    if (r)\n        return r;\n    strx = nasm_malloc(l);  \n    memcpy(strx, str, l);\n    return hash_add(&hi, strx, NULL);\n}", "target": 0}
{"code": "cmndlist_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct member_list *list, const char *runchroot,\n    struct cmnd_info *info)\n{\n    struct member *m;\n    int matched = UNSPEC;\n    debug_decl(cmndlist_matches, SUDOERS_DEBUG_MATCH);\n    TAILQ_FOREACH_REVERSE(m, list, member_list, entries) {\n\tmatched = cmnd_matches(parse_tree, m, runchroot, info);\n\tif (matched != UNSPEC)\n\t    break;\n    }\n    debug_return_int(matched);\n}", "target": 1}
{"code": "pci_lintr_deassert(struct pci_vdev *dev)\n{\n\tassert(dev->lintr.pin > 0);\n\tpthread_mutex_lock(&dev->lintr.lock);\n\tif (dev->lintr.state == ASSERTED) {\n\t\tdev->lintr.state = IDLE;\n\t\tpci_irq_deassert(dev);\n\t} else if (dev->lintr.state == PENDING)\n\t\tdev->lintr.state = IDLE;\n\tpthread_mutex_unlock(&dev->lintr.lock);\n}", "target": 1}
{"code": "int setup_tests(void)\n{\n    ADD_ALL_TESTS(call_run_cert, OSSL_NELEM(name_fns));\n    return 1;\n}", "target": 1}
{"code": "void free_cache_bitmap_order(rdpContext* context, CACHE_BITMAP_ORDER* order)\n{\n\tif (order)\n\t\tfree(order->bitmapDataStream);\n\tfree(order);\n}", "target": 0}
{"code": "static void nvme_dsm_cb(void *opaque, int ret)\n{\n    NvmeDSMAIOCB *iocb = opaque;\n    NvmeRequest *req = iocb->req;\n    NvmeCtrl *n = nvme_ctrl(req);\n    NvmeNamespace *ns = req->ns;\n    NvmeDsmRange *range;\n    uint64_t slba;\n    uint32_t nlb;\n    if (ret < 0) {\n        iocb->ret = ret;\n        goto done;\n    }\nnext:\n    if (iocb->idx == iocb->nr) {\n        goto done;\n    }\n    range = &iocb->range[iocb->idx++];\n    slba = le64_to_cpu(range->slba);\n    nlb = le32_to_cpu(range->nlb);\n    trace_pci_nvme_dsm_deallocate(slba, nlb);\n    if (nlb > n->dmrsl) {\n        trace_pci_nvme_dsm_single_range_limit_exceeded(nlb, n->dmrsl);\n        goto next;\n    }\n    if (nvme_check_bounds(ns, slba, nlb)) {\n        trace_pci_nvme_err_invalid_lba_range(slba, nlb,\n                                             ns->id_ns.nsze);\n        goto next;\n    }\n    iocb->aiocb = blk_aio_pdiscard(ns->blkconf.blk, nvme_l2b(ns, slba),\n                                   nvme_l2b(ns, nlb),\n                                   nvme_dsm_md_cb, iocb);\n    return;\ndone:\n    iocb->aiocb = NULL;\n    qemu_bh_schedule(iocb->bh);\n}", "target": 0}
{"code": "  static void launch(OpKernelContext* context, const PoolParameters& params,\n                     const Tensor& grad_in, const Tensor& argmax,\n                     Tensor* grad_out, const bool include_batch_in_index) {\n    const DeviceBase::CpuWorkerThreads& worker_threads =\n        *(context->device()->tensorflow_cpu_worker_threads());\n    auto shard = [&grad_in, &argmax, &grad_out, include_batch_in_index](\n                     int64 start, int64 limit) {\n      const int64 batch_size =\n          GetTensorDim(grad_out->shape(), FORMAT_NHWC, 'N');\n      const int64 output_size_per_batch = grad_out->NumElements() / batch_size;\n      const int64 input_size_per_batch = grad_in.NumElements() / batch_size;\n      {\n        auto grad_out_flat = grad_out->flat<T>();\n        auto argmax_flat = argmax.flat<int64>();\n        auto grad_in_flat = grad_in.flat<T>();\n        const int64 output_start = start * output_size_per_batch;\n        const int64 output_end = limit * output_size_per_batch;\n        EigenMatrixMap inputShard(grad_out_flat.data() + output_start, 1,\n                                  output_end - output_start);\n        inputShard.setConstant(T(0));\n        const int input_start = start * input_size_per_batch;\n        const int input_end = limit * input_size_per_batch;\n        for (int64 index = input_start; index < input_end; index++) {\n          if (index >= argmax.NumElements()) {\n            break;\n          }\n          int64 grad_out_index = argmax_flat(index);\n          if (!include_batch_in_index) {\n            const int64 cur_batch = index / input_size_per_batch;\n            grad_out_index += cur_batch * output_size_per_batch;\n          }\n          CHECK(grad_out_index >= output_start && grad_out_index < output_end)\n              << \"Invalid output gradient index: \" << grad_out_index << \", \"\n              << output_start << \", \" << output_end;\n          grad_out_flat(grad_out_index) += grad_in_flat(index);\n        }\n      }\n    };\n    const int64 batch_size = GetTensorDim(grad_out->shape(), FORMAT_NHWC, 'N');\n    const int64 shard_cost = grad_out->NumElements() / batch_size;\n    Shard(worker_threads.num_threads, worker_threads.workers, batch_size,\n          shard_cost, shard);\n  }", "target": 0}
{"code": "int ConnectionImpl::saveHeader(const nghttp2_frame* frame, HeaderString&& name,\n                               HeaderString&& value) {\n  StreamImpl* stream = getStream(frame->hd.stream_id);\n  if (!stream) {\n    stats_.headers_cb_no_stream_.inc();\n    return 0;\n  }\n  stream->saveHeader(std::move(name), std::move(value));\n  if (stream->headers_->byteSize() > max_request_headers_kb_ * 1024) {\n    stats_.header_overflow_.inc();\n    return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;\n  } else {\n    return 0;\n  }\n}", "target": 1}
{"code": "static int g2m_init_buffers(G2MContext *c)\n{\n    int aligned_height;\n    if (!c->framebuf || c->old_width < c->width || c->old_height < c->height) {\n        c->framebuf_stride = FFALIGN(c->width * 3, 16);\n        aligned_height     = FFALIGN(c->height,    16);\n        av_free(c->framebuf);\n        c->framebuf = av_mallocz(c->framebuf_stride * aligned_height);\n        if (!c->framebuf)\n            return AVERROR(ENOMEM);\n    }\n    if (!c->synth_tile || !c->jpeg_tile ||\n        c->old_tile_w < c->tile_width ||\n        c->old_tile_h < c->tile_height) {\n        c->tile_stride = FFALIGN(c->tile_width * 3, 16);\n        aligned_height = FFALIGN(c->tile_height,    16);\n        av_free(c->synth_tile);\n        av_free(c->jpeg_tile);\n        av_free(c->kempf_buf);\n        av_free(c->kempf_flags);\n        c->synth_tile  = av_mallocz(c->tile_stride      * aligned_height);\n        c->jpeg_tile   = av_mallocz(c->tile_stride      * aligned_height);\n        c->kempf_buf   = av_mallocz((c->tile_width + 1) * aligned_height\n                                    + FF_INPUT_BUFFER_PADDING_SIZE);\n        c->kempf_flags = av_mallocz( c->tile_width      * aligned_height);\n        if (!c->synth_tile || !c->jpeg_tile ||\n            !c->kempf_buf || !c->kempf_flags)\n            return AVERROR(ENOMEM);\n    }\n    return 0;\n}", "target": 1}
{"code": "    std::string& attrf(int ncid, int varId, const char * attrName, std::string& alloc)\n    {\n        alloc = \"\";\n        size_t len = 0;\n        nc_inq_attlen(ncid, varId, attrName, &len);\n        if(len < 1)\n        {\n            return alloc;\n        }\n        char attr_vals[NC_MAX_NAME + 1];\n        memset(attr_vals, 0, NC_MAX_NAME + 1);\n        if(nc_get_att_text(ncid, varId, attrName, attr_vals) != NC_NOERR)\n        {\n            return alloc;\n        }\n        alloc = std::string(attr_vals);\n        return alloc;\n    }", "target": 1}
{"code": "exif_data_save_data_entry (ExifData *data, ExifEntry *e,\n\t\t\t   unsigned char **d, unsigned int *ds,\n\t\t\t   unsigned int offset)\n{\n\tunsigned int doff, s;\n\tunsigned int ts;\n\tif (!data || !data->priv) \n\t\treturn;\n\texif_set_short (*d + 6 + offset + 0,\n\t\t\tdata->priv->order, (ExifShort) e->tag);\n\texif_set_short (*d + 6 + offset + 2,\n\t\t\tdata->priv->order, (ExifShort) e->format);\n\tif (!(data->priv->options & EXIF_DATA_OPTION_DONT_CHANGE_MAKER_NOTE)) {\n\t\tif ((e->tag == EXIF_TAG_MAKER_NOTE) && data->priv->md) {\n\t\t\texif_mem_free (data->priv->mem, e->data);\n\t\t\te->data = NULL;\n\t\t\te->size = 0;\n\t\t\texif_mnote_data_set_offset (data->priv->md, *ds - 6);\n\t\t\texif_mnote_data_save (data->priv->md, &e->data, &e->size);\n\t\t\te->components = e->size;\n\t\t\tif (exif_format_get_size (e->format) != 1) {\n\t\t\t\te->format = EXIF_FORMAT_UNDEFINED;\n\t\t\t}\n\t\t}\n\t}\n\texif_set_long  (*d + 6 + offset + 4,\n\t\t\tdata->priv->order, e->components);\n\ts = exif_format_get_size (e->format) * e->components;\n\tif (s > 4) {\n\t\tunsigned char *t;\n\t\tdoff = *ds - 6;\n\t\tts = *ds + s;\n\t\tif (s & 1)\n\t\t\tts++;\n\t\tt = exif_mem_realloc (data->priv->mem, *d, ts);\n\t\tif (!t) {\n\t\t\tEXIF_LOG_NO_MEMORY (data->priv->log, \"ExifData\", ts);\n\t\t  \treturn;\n\t\t}\n\t\t*d = t;\n\t\t*ds = ts;\n\t\texif_set_long (*d + 6 + offset + 8, data->priv->order, doff);\n\t\tif (s & 1) \n\t\t\t*(*d + *ds - 1) = '\\0';\n\t} else\n\t\tdoff = offset + 8;\n\tif (e->data) {\n\t\tmemcpy (*d + 6 + doff, e->data, s);\n\t} else {\n\t\tmemset (*d + 6 + doff, 0, s);\n\t}\n\tif (s < 4) \n\t\tmemset (*d + 6 + doff + s, 0, (4 - s));\n}", "target": 1}
{"code": "static void http1_on_ready(intptr_t uuid, fio_protocol_s *protocol) {\n  http1pr_s *p = (http1pr_s *)protocol;\n  if ((p->stop & 4)) {\n    p->stop ^= 4;\n    fio_force_event(uuid, FIO_EVENT_ON_DATA);\n  }\n  (void)protocol;\n}", "target": 1}
{"code": "int key_update(key_ref_t key_ref, const void *payload, size_t plen)\n{\n\tstruct key_preparsed_payload prep;\n\tstruct key *key = key_ref_to_ptr(key_ref);\n\tint ret;\n\tkey_check(key);\n\tret = key_permission(key_ref, KEY_NEED_WRITE);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!key->type->update)\n\t\treturn -EOPNOTSUPP;\n\tmemset(&prep, 0, sizeof(prep));\n\tprep.data = payload;\n\tprep.datalen = plen;\n\tprep.quotalen = key->type->def_datalen;\n\tprep.expiry = TIME_T_MAX;\n\tif (key->type->preparse) {\n\t\tret = key->type->preparse(&prep);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\tdown_write(&key->sem);\n\tret = key->type->update(key, &prep);\n\tif (ret == 0)\n\t\tclear_bit(KEY_FLAG_NEGATIVE, &key->flags);\n\tup_write(&key->sem);\nerror:\n\tif (key->type->preparse)\n\t\tkey->type->free_preparse(&prep);\n\treturn ret;\n}", "target": 1}
{"code": "usm_free_usmStateReference(void *old)\n{\n    struct usmStateReference *old_ref = (struct usmStateReference *) old;\n    if (old_ref) {\n        if (old_ref->usr_name_length)\n            SNMP_FREE(old_ref->usr_name);\n        if (old_ref->usr_engine_id_length)\n            SNMP_FREE(old_ref->usr_engine_id);\n        if (old_ref->usr_auth_protocol_length)\n            SNMP_FREE(old_ref->usr_auth_protocol);\n        if (old_ref->usr_priv_protocol_length)\n            SNMP_FREE(old_ref->usr_priv_protocol);\n        if (old_ref->usr_auth_key_length && old_ref->usr_auth_key) {\n            SNMP_ZERO(old_ref->usr_auth_key, old_ref->usr_auth_key_length);\n            SNMP_FREE(old_ref->usr_auth_key);\n        }\n        if (old_ref->usr_priv_key_length && old_ref->usr_priv_key) {\n            SNMP_ZERO(old_ref->usr_priv_key, old_ref->usr_priv_key_length);\n            SNMP_FREE(old_ref->usr_priv_key);\n        }\n        SNMP_ZERO(old_ref, sizeof(*old_ref));\n        SNMP_FREE(old_ref);\n    }\n}                               ", "target": 1}
{"code": "struct timespec ns_to_timespec(const s64 nsec)\n{\n\tstruct timespec ts;\n\tif (!nsec)\n\t\treturn (struct timespec) {0, 0};\n\tts.tv_sec = div_long_long_rem_signed(nsec, NSEC_PER_SEC, &ts.tv_nsec);\n\tif (unlikely(nsec < 0))\n\t\tset_normalized_timespec(&ts, ts.tv_sec, ts.tv_nsec);\n\treturn ts;\n}", "target": 1}
{"code": "static int rt6_bind_neighbour(struct rt6_info *rt, struct net_device *dev)\n{\n\tstruct neighbour *n = __ipv6_neigh_lookup(&nd_tbl, dev, &rt->rt6i_gateway);\n\tif (!n) {\n\t\tn = neigh_create(&nd_tbl, &rt->rt6i_gateway, dev);\n\t\tif (IS_ERR(n))\n\t\t\treturn PTR_ERR(n);\n\t}\n\trt->n = n;\n\treturn 0;\n}", "target": 0}
{"code": "node_str_cat_codepoint(Node* node, OnigEncoding enc, OnigCodePoint c)\n{\n  UChar buf[ONIGENC_CODE_TO_MBC_MAXLEN];\n  int num = ONIGENC_CODE_TO_MBC(enc, c, buf);\n  if (num < 0) return num;\n  return onig_node_str_cat(node, buf, buf + num);\n}", "target": 0}
{"code": "static void update_open_stateflags(struct nfs4_state *state, mode_t open_flags)\n{\n\tswitch (open_flags) {\n\t\tcase FMODE_WRITE:\n\t\t\tstate->n_wronly++;\n\t\t\tbreak;\n\t\tcase FMODE_READ:\n\t\t\tstate->n_rdonly++;\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tstate->n_rdwr++;\n\t}\n\tnfs4_state_set_mode_locked(state, state->state | open_flags);\n}", "target": 1}
{"code": "void FAST_FUNC udhcp_add_binary_option(struct dhcp_packet *packet, uint8_t *addopt)\n{\n\tunsigned len;\n\tuint8_t *optionptr = packet->options;\n\tunsigned end = udhcp_end_option(optionptr);\n\tlen = OPT_DATA + addopt[OPT_LEN];\n\tif (end + len + 1 >= DHCP_OPTIONS_BUFSIZE) {\n\t\tbb_error_msg(\"option 0x%02x did not fit into the packet\",\n\t\t\t\taddopt[OPT_CODE]);\n\t\treturn;\n\t}\n\tlog_option(\"Adding option\", addopt);\n\tmemcpy(optionptr + end, addopt, len);\n\toptionptr[end + len] = DHCP_END;\n}", "target": 0}
{"code": "  virtual void requestInit() {\n    m_use_error = false;\n    m_errors.reset();\n    xmlParserInputBufferCreateFilenameDefault(nullptr);\n  }", "target": 1}
{"code": "static void bnx2x_oem_event(struct bnx2x *bp, u32 event)\n{\n\tu32 cmd_ok, cmd_fail;\n\tif (event & DRV_STATUS_DCC_EVENT_MASK &&\n\t    event & DRV_STATUS_OEM_EVENT_MASK) {\n\t\tBNX2X_ERR(\"Received simultaneous events %08x\\n\", event);\n\t\treturn;\n\t}\n\tif (event & DRV_STATUS_DCC_EVENT_MASK) {\n\t\tcmd_fail = DRV_MSG_CODE_DCC_FAILURE;\n\t\tcmd_ok = DRV_MSG_CODE_DCC_OK;\n\t} else  {\n\t\tcmd_fail = DRV_MSG_CODE_OEM_FAILURE;\n\t\tcmd_ok = DRV_MSG_CODE_OEM_OK;\n\t}\n\tDP(BNX2X_MSG_MCP, \"oem_event 0x%x\\n\", event);\n\tif (event & (DRV_STATUS_DCC_DISABLE_ENABLE_PF |\n\t\t     DRV_STATUS_OEM_DISABLE_ENABLE_PF)) {\n\t\tif (bp->mf_config[BP_VN(bp)] & FUNC_MF_CFG_FUNC_DISABLED) {\n\t\t\tDP(BNX2X_MSG_MCP, \"mf_cfg function disabled\\n\");\n\t\t\tbp->flags |= MF_FUNC_DIS;\n\t\t\tbnx2x_e1h_disable(bp);\n\t\t} else {\n\t\t\tDP(BNX2X_MSG_MCP, \"mf_cfg function enabled\\n\");\n\t\t\tbp->flags &= ~MF_FUNC_DIS;\n\t\t\tbnx2x_e1h_enable(bp);\n\t\t}\n\t\tevent &= ~(DRV_STATUS_DCC_DISABLE_ENABLE_PF |\n\t\t\t   DRV_STATUS_OEM_DISABLE_ENABLE_PF);\n\t}\n\tif (event & (DRV_STATUS_DCC_BANDWIDTH_ALLOCATION |\n\t\t     DRV_STATUS_OEM_BANDWIDTH_ALLOCATION)) {\n\t\tbnx2x_config_mf_bw(bp);\n\t\tevent &= ~(DRV_STATUS_DCC_BANDWIDTH_ALLOCATION |\n\t\t\t   DRV_STATUS_OEM_BANDWIDTH_ALLOCATION);\n\t}\n\tif (event)\n\t\tbnx2x_fw_command(bp, cmd_fail, 0);\n\telse\n\t\tbnx2x_fw_command(bp, cmd_ok, 0);\n}", "target": 0}
{"code": "static NTSTATUS smb_unix_read_symlink(connection_struct *conn,\n\t\t\t\tstruct smb_request *req,\n\t\t\t\tstruct smb_filename *smb_fname,\n\t\t\t\tchar *pdata,\n\t\t\t\tunsigned int data_size_in,\n\t\t\t\tunsigned int *pdata_size_out)\n{\n\tNTSTATUS status;\n\tsize_t len = 0;\n\tint link_len = 0;\n\tstruct smb_filename *parent_fname = NULL;\n\tstruct smb_filename *base_name = NULL;\n\tchar *buffer = talloc_array(talloc_tos(), char, PATH_MAX+1);\n\tif (!buffer) {\n\t\treturn NT_STATUS_NO_MEMORY;\n\t}\n\tDBG_DEBUG(\"SMB_QUERY_FILE_UNIX_LINK for file %s\\n\",\n\t\tsmb_fname_str_dbg(smb_fname));\n\tif(!S_ISLNK(smb_fname->st.st_ex_mode)) {\n\t\tTALLOC_FREE(buffer);\n\t\treturn NT_STATUS_DOS(ERRSRV, ERRbadlink);\n\t}\n\tstatus = parent_pathref(talloc_tos(),\n\t\t\t\tconn->cwd_fsp,\n\t\t\t\tsmb_fname,\n\t\t\t\t&parent_fname,\n\t\t\t\t&base_name);\n\tif (!NT_STATUS_IS_OK(status)) {\n\t\tTALLOC_FREE(buffer);\n\t\treturn status;\n\t}\n\tlink_len = SMB_VFS_READLINKAT(conn,\n\t\t\t\tparent_fname->fsp,\n\t\t\t\tbase_name,\n\t\t\t\tbuffer,\n\t\t\t\tPATH_MAX);\n\tTALLOC_FREE(parent_fname);\n\tif (link_len == -1) {\n\t\tTALLOC_FREE(buffer);\n\t\treturn map_nt_error_from_unix(errno);\n\t}\n\tbuffer[link_len] = 0;\n\tstatus = srvstr_push(pdata,\n\t\t\treq->flags2,\n\t\t\tpdata,\n\t\t\tbuffer,\n\t\t\tdata_size_in,\n\t\t\tSTR_TERMINATE,\n\t\t\t&len);\n\tTALLOC_FREE(buffer);\n\tif (!NT_STATUS_IS_OK(status)) {\n\t\treturn status;\n\t}\n\t*pdata_size_out = len;\n\treturn NT_STATUS_OK;\n}", "target": 0}
{"code": "writefile(const char *name, struct string *s)\n{\n\tFILE *f;\n\tint ret;\n\tf = fopen(name, \"w\");\n\tif (!f) {\n\t\twarn(\"open %s:\", name);\n\t\treturn -1;\n\t}\n\tret = 0;\n\tif (fwrite(s->s, 1, s->n, f) != s->n || fflush(f) != 0) {\n\t\twarn(\"write %s:\", name);\n\t\tret = -1;\n\t}\n\tfclose(f);\n\treturn ret;\n}", "target": 1}
{"code": "decode_labeled_vpn_clnp_prefix(netdissect_options *ndo,\n                               const u_char *pptr, char *buf, u_int buflen)\n{\n        uint8_t addr[19];\n\tu_int plen;\n\tND_TCHECK(pptr[0]);\n\tplen = pptr[0];   \n\tif ((24+64) > plen)\n\t\treturn -1;\n        plen-=(24+64); \n\tif (152 < plen)\n\t\treturn -1;\n\tmemset(&addr, 0, sizeof(addr));\n\tND_TCHECK2(pptr[12], (plen + 7) / 8);\n\tmemcpy(&addr, &pptr[12], (plen + 7) / 8);\n\tif (plen % 8) {\n\t\taddr[(plen + 7) / 8 - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n\tsnprintf(buf, buflen, \"RD: %s, %s/%d, label:%u %s\",\n                 bgp_vpn_rd_print(ndo, pptr+4),\n                 isonsap_string(ndo, addr,(plen + 7) / 8),\n                 plen,\n                 EXTRACT_24BITS(pptr+1)>>4,\n                 ((pptr[3]&1)==0) ? \"(BOGUS: Bottom of Stack NOT set!)\" : \"(bottom)\" );\n\treturn 12 + (plen + 7) / 8;\ntrunc:\n\treturn -2;\n}", "target": 0}
{"code": "void Context::onStart(absl::string_view root_id, absl::string_view vm_configuration) {\n  if (wasm_->onStart_) {\n    auto root_id_addr = wasm_->copyString(root_id);\n    auto config_addr = wasm_->copyString(vm_configuration);\n    wasm_->onStart_(this, id_, root_id_addr, root_id.size(), config_addr, vm_configuration.size());\n  }\n  in_vm_context_created_ = true;\n}", "target": 0}
{"code": "readpw(PK11SlotInfo *slot UNUSED,\n       PRBool retry UNUSED,\n       void *arg UNUSED)\n{\n\tstruct termios sio, tio;\n\tchar line[LINE_MAX], *p;\n\tchar *ret;\n\tingress();\n\tmemset(line, '\\0', sizeof (line));\n\tif (tcgetattr(fileno(stdin), &sio) < 0) {\n\t\twarnx(\"Could not read password from standard input.\");\n\t\treturn NULL;\n\t}\n\ttio = sio;\n\ttio.c_lflag &= ~ECHO;\n\tif (tcsetattr(fileno(stdin), 0, &tio) < 0) {\n\t\twarnx(\"Could not read password from standard input.\");\n\t\treturn NULL;\n\t}\n\tfprintf(stdout, \"Enter passphrase for private key: \");\n\tfflush(stdout);\n\tret = fgets(line, sizeof(line), stdin);\n\tset_errno_guard();\n\ttcsetattr(fileno(stdin), 0, &sio);\n\tfprintf(stdout, \"\\n\");\n\tfflush(stdout);\n\tif (ret == NULL)\n\t\treturn NULL;\n\tp = line + strcspn(line, \"\\r\\n\");\n\tif (p == NULL)\n\t\tp = line + strcspn(line, \"\\n\");\n\tif (p != NULL)\n\t\t*p = '\\0';\n\tret = strdup(line);\n\tmemset(line, '\\0', sizeof (line));\n\tif (!ret) {\n\t\twarnx(\"Could not read passphrase.\");\n\t\treturn NULL;\n\t}\n\tegress();\n\treturn ret;\n}", "target": 0}
{"code": "build_cert_bag (unsigned char *buffer, size_t buflen, char *salt,\n                size_t *r_length)\n{\n  size_t len[9], needed;\n  unsigned char *p, *certbag;\n  size_t certbaglen;\n  needed = compute_tag_length (buflen);\n  needed += buflen;\n  needed += DIM (data_rc2iter2048);\n  needed += 2 + DIM (oid_data);\n  len[5] = needed;\n  needed += compute_tag_length ( needed);\n  needed += 3;\n  len[3] = needed;\n  needed += compute_tag_length (needed);\n  len[2] = needed;\n  needed += compute_tag_length (needed);\n  needed += 2 + DIM (oid_encryptedData);\n  len[0] = needed;\n  needed += compute_tag_length (needed);\n  p = certbag = gcry_malloc (needed);\n  if (!certbag)\n    {\n      log_error (\"error allocating buffer\\n\");\n      return NULL;\n    }\n  p = store_tag_length (p, TAG_SEQUENCE, len[0]);\n  p = store_tag_length (p, TAG_OBJECT_ID, DIM (oid_encryptedData));\n  memcpy (p, oid_encryptedData, DIM (oid_encryptedData));\n  p += DIM (oid_encryptedData);\n  p = store_tag_length (p, 0xa0, len[2]);\n  p = store_tag_length (p, TAG_SEQUENCE, len[3]);\n  *p++ = TAG_INTEGER;\n  *p++ = 1;\n  *p++ = 0;\n  p = store_tag_length (p, TAG_SEQUENCE, len[5]);\n  p = store_tag_length (p, TAG_OBJECT_ID, DIM (oid_data));\n  memcpy (p, oid_data, DIM (oid_data));\n  p += DIM (oid_data);\n  memcpy (p, data_rc2iter2048, DIM (data_rc2iter2048));\n  memcpy (p + DATA_RC2ITER2048_SALT_OFF, salt, 8);\n  p += DIM (data_rc2iter2048);\n  p = store_tag_length (p, 0x80, buflen);\n  memcpy (p, buffer, buflen);\n  p += buflen;\n  certbaglen = p - certbag;\n  if (needed != certbaglen)\n    log_debug (\"length mismatch: %lu, %lu\\n\",\n               (unsigned long)needed, (unsigned long)certbaglen);\n  *r_length = certbaglen;\n  return certbag;\n}", "target": 0}
{"code": "BIGNUM *BN_dup(const BIGNUM *a)\n{\n    BIGNUM *t;\n    if (a == NULL)\n        return NULL;\n    bn_check_top(a);\n    t = BN_get_flags(a, BN_FLG_SECURE) ? BN_secure_new() : BN_new();\n    if (t == NULL)\n        return NULL;\n    if (!BN_copy(t, a)) {\n        BN_free(t);\n        return NULL;\n    }\n    bn_check_top(t);\n    return t;\n}", "target": 0}
{"code": "static int check_line_charstring(void)\n{\n  char *p = line;\n  while (isspace(*p))\n    p++;\n  return (*p == '/' || (p[0] == 'd' && p[1] == 'u' && p[2] == 'p'));\n}", "target": 1}
{"code": "static inline int get_len(LZOContext *c, int x, int mask)\n{\n    int cnt = x & mask;\n    if (!cnt) {\n        while (!(x = get_byte(c)))\n            cnt += 255;\n        cnt += mask + x;\n    }\n    return cnt;\n}", "target": 1}
{"code": "static BOOL autodetect_recv_bandwidth_measure_results(rdpRdp* rdp, wStream* s,\n                                                      AUTODETECT_RSP_PDU* autodetectRspPdu)\n{\n\tBOOL success = TRUE;\n\tif (autodetectRspPdu->headerLength != 0x0E)\n\t\treturn FALSE;\n\tWLog_VRB(AUTODETECT_TAG, \"received Bandwidth Measure Results PDU\");\n\tStream_Read_UINT32(s, rdp->autodetect->bandwidthMeasureTimeDelta); \n\tStream_Read_UINT32(s, rdp->autodetect->bandwidthMeasureByteCount); \n\tif (rdp->autodetect->bandwidthMeasureTimeDelta > 0)\n\t\trdp->autodetect->netCharBandwidth = rdp->autodetect->bandwidthMeasureByteCount * 8 /\n\t\t                                    rdp->autodetect->bandwidthMeasureTimeDelta;\n\telse\n\t\trdp->autodetect->netCharBandwidth = 0;\n\tIFCALLRET(rdp->autodetect->BandwidthMeasureResults, success, rdp->context,\n\t          autodetectRspPdu->sequenceNumber);\n\treturn success;\n}", "target": 1}
{"code": "    Image::UniquePtr ImageFactory::create(ImageType type,\n                                        const std::wstring& wpath)\n    {\n        std::unique_ptr<FileIo> fileIo(new FileIo(wpath));\n        if (fileIo->open(\"w+b\") != 0) {\n            throw WError(kerFileOpenFailed, wpath, \"w+b\", strError().c_str());\n        }\n        fileIo->close();\n        BasicIo::UniquePtr io(std::move(fileIo));\n        Image::UniquePtr image = create(type, std::move(io));\n        if (image.get() == 0) throw Error(kerUnsupportedImageType, static_cast<int>(type));\n        return image;\n    }", "target": 0}
{"code": "static int ext4_commit_super(struct super_block *sb, int sync)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tstruct buffer_head *sbh = EXT4_SB(sb)->s_sbh;\n\tint error = 0;\n\tif (!sbh || block_device_ejected(sb))\n\t\treturn error;\n\tif (buffer_write_io_error(sbh)) {\n\t\text4_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tif (sb->s_bdev->bd_part)\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written +\n\t\t\t    ((part_stat_read(sb->s_bdev->bd_part, sectors[1]) -\n\t\t\t      EXT4_SB(sb)->s_sectors_written_start) >> 1));\n\telse\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written);\n\text4_free_blocks_count_set(es,\n\t\t\tEXT4_C2B(EXT4_SB(sb), percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeclusters_counter)));\n\tes->s_free_inodes_count =\n\t\tcpu_to_le32(percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeinodes_counter));\n\tsb->s_dirt = 0;\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\text4_superblock_csum_set(sb, es);\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = buffer_write_io_error(sbh);\n\t\tif (error) {\n\t\t\text4_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}", "target": 0}
{"code": "int unit_name_build(const char *prefix, const char *instance, const char *suffix, char **ret) {\n        UnitType type;\n        assert(prefix);\n        assert(suffix);\n        assert(ret);\n        if (suffix[0] != '.')\n                return -EINVAL;\n        type = unit_type_from_string(suffix + 1);\n        if (type < 0)\n                return -EINVAL;\n        return unit_name_build_from_type(prefix, instance, type, ret);\n}", "target": 0}
{"code": "char *_q_makeword(char *str, char stop)\n{\n    char *word;\n    int  len, i;\n    for (len = 0; ((str[len] != stop) && (str[len])); len++);\n    word = (char *)malloc(sizeof(char) * (len + 1));\n    for (i = 0; i < len; i++) word[i] = str[i];\n    word[i] = '\\0';\n    if (str[len])len++;\n    for (i = len; str[i]; i++) str[i - len] = str[i];\n    str[i - len] = '\\0';\n    return word;\n}", "target": 0}
{"code": "static int check_stack_boundary(struct bpf_verifier_env *env, int regno,\n\t\t\t\tint access_size, bool zero_size_allowed,\n\t\t\t\tstruct bpf_call_arg_meta *meta)\n{\n\tstruct bpf_verifier_state *state = env->cur_state;\n\tstruct bpf_reg_state *regs = state->regs;\n\tint off, i, slot, spi;\n\tif (regs[regno].type != PTR_TO_STACK) {\n\t\tif (zero_size_allowed && access_size == 0 &&\n\t\t    register_is_null(regs[regno]))\n\t\t\treturn 0;\n\t\tverbose(env, \"R%d type=%s expected=%s\\n\", regno,\n\t\t\treg_type_str[regs[regno].type],\n\t\t\treg_type_str[PTR_TO_STACK]);\n\t\treturn -EACCES;\n\t}\n\tif (!tnum_is_const(regs[regno].var_off)) {\n\t\tchar tn_buf[48];\n \t\ttnum_strn(tn_buf, sizeof(tn_buf), regs[regno].var_off);\n \t\tverbose(env, \"invalid variable stack read R%d var_off=%s\\n\",\n \t\t\tregno, tn_buf);\n \t}\n \toff = regs[regno].off + regs[regno].var_off.value;\n \tif (off >= 0 || off < -MAX_BPF_STACK || off + access_size > 0 ||\n\t    access_size < 0 || (access_size == 0 && !zero_size_allowed)) {\n\t\tverbose(env, \"invalid stack type R%d off=%d access_size=%d\\n\",\n\t\t\tregno, off, access_size);\n\t\treturn -EACCES;\n\t}\n\tif (env->prog->aux->stack_depth < -off)\n\t\tenv->prog->aux->stack_depth = -off;\n\tif (meta && meta->raw_mode) {\n\t\tmeta->access_size = access_size;\n\t\tmeta->regno = regno;\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < access_size; i++) {\n\t\tslot = -(off + i) - 1;\n\t\tspi = slot / BPF_REG_SIZE;\n\t\tif (state->allocated_stack <= slot ||\n\t\t    state->stack[spi].slot_type[slot % BPF_REG_SIZE] !=\n\t\t\tSTACK_MISC) {\n\t\t\tverbose(env, \"invalid indirect read from stack off %d+%d size %d\\n\",\n\t\t\t\toff, i, access_size);\n\t\t\treturn -EACCES;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "get_word_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    register unsigned int temp;\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    *ptr++ = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    *ptr++ = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    *ptr++ = rescale[temp];\n  }\n  return 1;\n}", "target": 1}
{"code": "static int nf_tables_table_notify(const struct nft_ctx *ctx, int event)\n{\n\tstruct sk_buff *skb;\n\tint err;\n\tif (!ctx->report &&\n\t    !nfnetlink_has_listeners(ctx->net, NFNLGRP_NFTABLES))\n\t\treturn 0;\n\terr = -ENOBUFS;\n\tskb = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (skb == NULL)\n\t\tgoto err;\n\terr = nf_tables_fill_table_info(skb, ctx->net, ctx->portid, ctx->seq,\n\t\t\t\t\tevent, 0, ctx->afi->family, ctx->table);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto err;\n\t}\n\terr = nfnetlink_send(skb, ctx->net, ctx->portid, NFNLGRP_NFTABLES,\n\t\t\t     ctx->report, GFP_KERNEL);\nerr:\n\tif (err < 0) {\n\t\tnfnetlink_set_err(ctx->net, ctx->portid, NFNLGRP_NFTABLES,\n\t\t\t\t  err);\n\t}\n\treturn err;\n}", "target": 0}
{"code": "static inline struct sctp_ulpevent *sctp_ulpq_retrieve_partial(struct sctp_ulpq *ulpq)\n{\n\tstruct sk_buff *pos, *last_frag, *first_frag;\n\tstruct sctp_ulpevent *cevent;\n\t__u32 ctsn, next_tsn;\n\tint is_last;\n\tstruct sctp_ulpevent *retval;\n\tif (skb_queue_empty(&ulpq->reasm))\n\t\treturn NULL;\n\tlast_frag = first_frag = NULL;\n\tretval = NULL;\n\tnext_tsn = 0;\n\tis_last = 0;\n\tskb_queue_walk(&ulpq->reasm, pos) {\n\t\tcevent = sctp_skb2event(pos);\n\t\tctsn = cevent->tsn;\n\t\tswitch (cevent->msg_flags & SCTP_DATA_FRAG_MASK) {\n\t\tcase SCTP_DATA_MIDDLE_FRAG:\n\t\t\tif (!first_frag) {\n\t\t\t\tfirst_frag = pos;\n\t\t\t\tnext_tsn = ctsn + 1;\n\t\t\t\tlast_frag = pos;\n\t\t\t} else if (next_tsn == ctsn)\n\t\t\t\tnext_tsn++;\n\t\t\telse\n\t\t\t\tgoto done;\n\t\t\tbreak;\n\t\tcase SCTP_DATA_LAST_FRAG:\n\t\t\tif (!first_frag)\n\t\t\t\tfirst_frag = pos;\n\t\t\telse if (ctsn != next_tsn)\n\t\t\t\tgoto done;\n\t\t\tlast_frag = pos;\n\t\t\tis_last = 1;\n\t\t\tgoto done;\n\t\tdefault:\n\t\t\treturn NULL;\n\t\t};\n\t}\ndone:\n\tretval = sctp_make_reassembled_event(&ulpq->reasm, first_frag, last_frag);\n\tif (retval && is_last)\n\t\tretval->msg_flags |= MSG_EOR;\n\treturn retval;\n}", "target": 0}
{"code": "aiff_read_chanmap (SF_PRIVATE * psf, unsigned dword)\n{\tconst AIFF_CAF_CHANNEL_MAP * map_info ;\n\tunsigned channel_bitmap, channel_decriptions, bytesread ;\n\tint layout_tag ;\n\tbytesread = psf_binheader_readf (psf, \"444\", &layout_tag, &channel_bitmap, &channel_decriptions) ;\n\tif ((map_info = aiff_caf_of_channel_layout_tag (layout_tag)) == NULL)\n\t\treturn 0 ;\n\tpsf_log_printf (psf, \"  Tag    : %x\\n\", layout_tag) ;\n\tif (map_info)\n\t\tpsf_log_printf (psf, \"  Layout : %s\\n\", map_info->name) ;\n\tif (bytesread < dword)\n\t\tpsf_binheader_readf (psf, \"j\", dword - bytesread) ;\n\tif (map_info->channel_map != NULL)\n\t{\tsize_t chanmap_size = psf->sf.channels * sizeof (psf->channel_map [0]) ;\n\t\tfree (psf->channel_map) ;\n\t\tif ((psf->channel_map = malloc (chanmap_size)) == NULL)\n\t\t\treturn SFE_MALLOC_FAILED ;\n\t\tmemcpy (psf->channel_map, map_info->channel_map, chanmap_size) ;\n\t\t} ;\n\treturn 0 ;\n} ", "target": 1}
{"code": "static int get_tp_trap(struct pt_regs *regs, unsigned int instr)\n{\n\tint reg = (instr >> 12) & 15;\n\tif (reg == 15)\n\t\treturn 1;\n\tregs->uregs[reg] = current_thread_info()->tp_value;\n\tregs->ARM_pc += 4;\n\treturn 0;\n}", "target": 1}
{"code": "static void update_db_bp_intercept(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tclr_exception_intercept(svm, DB_VECTOR);\n\tclr_exception_intercept(svm, BP_VECTOR);\n\tif (svm->nmi_singlestep)\n\t\tset_exception_intercept(svm, DB_VECTOR);\n\tif (vcpu->guest_debug & KVM_GUESTDBG_ENABLE) {\n\t\tif (vcpu->guest_debug &\n\t\t    (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))\n\t\t\tset_exception_intercept(svm, DB_VECTOR);\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)\n\t\t\tset_exception_intercept(svm, BP_VECTOR);\n\t} else\n\t\tvcpu->guest_debug = 0;\n}", "target": 1}
{"code": "void hincrbyfloatCommand(client *c) {\n    long double value, incr;\n    long long ll;\n    robj *o;\n    sds new;\n    unsigned char *vstr;\n    unsigned int vlen;\n    if (getLongDoubleFromObjectOrReply(c,c->argv[3],&incr,NULL) != C_OK) return;\n    if (isnan(incr) || isinf(incr)) {\n        addReplyError(c,\"value is NaN or Infinity\");\n        return;\n    }\n    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;\n    if (hashTypeGetValue(o,c->argv[2]->ptr,&vstr,&vlen,&ll) == C_OK) {\n        if (vstr) {\n            if (string2ld((char*)vstr,vlen,&value) == 0) {\n                addReplyError(c,\"hash value is not a float\");\n                return;\n            }\n        } else {\n            value = (long double)ll;\n        }\n    } else {\n        value = 0;\n    }\n    value += incr;\n    if (isnan(value) || isinf(value)) {\n        addReplyError(c,\"increment would produce NaN or Infinity\");\n        return;\n    }\n    char buf[MAX_LONG_DOUBLE_CHARS];\n    int len = ld2string(buf,sizeof(buf),value,LD_STR_HUMAN);\n    new = sdsnewlen(buf,len);\n    hashTypeSet(o,c->argv[2]->ptr,new,HASH_SET_TAKE_VALUE);\n    addReplyBulkCBuffer(c,buf,len);\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_HASH,\"hincrbyfloat\",c->argv[1],c->db->id);\n    server.dirty++;\n    robj *newobj;\n    newobj = createRawStringObject(buf,len);\n    rewriteClientCommandArgument(c,0,shared.hset);\n    rewriteClientCommandArgument(c,3,newobj);\n    decrRefCount(newobj);\n}", "target": 0}
{"code": "option_handler (assuan_context_t ctx, const char *key, const char *value)\n{\n  ctrl_t ctrl = assuan_get_pointer (ctx);\n  if (!strcmp (key, \"event-signal\"))\n    {\n#ifdef HAVE_W32_SYSTEM\n      if (!*value)\n        return gpg_error (GPG_ERR_ASS_PARAMETER);\n      ctrl->server_local->event_signal = strtoul (value, NULL, 16);\n#else\n      int i = *value? atoi (value) : -1;\n      if (i < 0)\n        return gpg_error (GPG_ERR_ASS_PARAMETER);\n      ctrl->server_local->event_signal = i;\n#endif\n    }\n return 0;\n}", "target": 0}
{"code": "static void oidc_authz_get_claims_and_idtoken(request_rec *r, json_t **claims,\n\t\tjson_t **id_token) {\n\tconst char *s_claims = oidc_request_state_get(r,\n\t\t\tOIDC_REQUEST_STATE_KEY_CLAIMS);\n\tif (s_claims != NULL)\n\t\toidc_util_decode_json_object(r, s_claims, claims);\n\tconst char *s_id_token = oidc_request_state_get(r,\n\t\t\tOIDC_REQUEST_STATE_KEY_IDTOKEN);\n\tif (s_id_token != NULL)\n\t\toidc_util_decode_json_object(r, s_id_token, id_token);\n}", "target": 0}
{"code": "int message_add_body_amqp_sequence(MESSAGE_HANDLE message, AMQP_VALUE sequence_list)\n{\n    int result;\n    if ((message == NULL) ||\n        (sequence_list == NULL))\n    {\n        LogError(\"Bad arguments: message = %p, sequence_list = %p\",\n            message, sequence_list);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        MESSAGE_BODY_TYPE body_type = internal_get_body_type(message);\n        if ((body_type == MESSAGE_BODY_TYPE_DATA) ||\n            (body_type == MESSAGE_BODY_TYPE_VALUE))\n        {\n            LogError(\"Body is already set to another body type\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            AMQP_VALUE* new_body_amqp_sequence_items = (AMQP_VALUE*)realloc(message->body_amqp_sequence_items, sizeof(AMQP_VALUE) * (message->body_amqp_sequence_count + 1));\n            if (new_body_amqp_sequence_items == NULL)\n            {\n                LogError(\"Cannot allocate enough memory for sequence items\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                message->body_amqp_sequence_items = new_body_amqp_sequence_items;\n                message->body_amqp_sequence_items[message->body_amqp_sequence_count] = amqpvalue_clone(sequence_list);\n                if (message->body_amqp_sequence_items[message->body_amqp_sequence_count] == NULL)\n                {\n                    LogError(\"Cloning sequence failed\");\n                    result = MU_FAILURE;\n                }\n                else\n                {\n                    message->body_amqp_sequence_count++;\n                    result = 0;\n                }\n            }\n        }\n    }\n    return result;\n}", "target": 1}
{"code": "static ssize_t ext4_direct_IO_read(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct address_space *mapping = iocb->ki_filp->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tsize_t count = iov_iter_count(iter);\n\tssize_t ret;\n\tinode_lock_shared(inode);\n\tret = filemap_write_and_wait_range(mapping, iocb->ki_pos,\n\t\t\t\t\t   iocb->ki_pos + count - 1);\n\tif (ret)\n\t\tgoto out_unlock;\n\tret = __blockdev_direct_IO(iocb, inode, inode->i_sb->s_bdev,\n\t\t\t\t   iter, ext4_dio_get_block, NULL, NULL, 0);\nout_unlock:\n\tinode_unlock_shared(inode);\n\treturn ret;\n}", "target": 0}
{"code": "void PCM::runPull()\n{\n\tAFframecount framesToRead = m_outChunk->frameCount;\n\tif (m_track->totalfframes != -1 &&\n\t\tm_track->nextfframe + framesToRead > m_track->totalfframes)\n\t{\n\t\tframesToRead = m_track->totalfframes - m_track->nextfframe;\n\t}\n\tssize_t bytesRead = read(m_outChunk->buffer, m_bytesPerFrame * framesToRead);\n\tAFframecount framesRead = bytesRead >= 0 ? bytesRead / m_bytesPerFrame : 0;\n\tCHNK(printf(\"reading %\" AF_FRAMECOUNT_PRINT_FMT \" frames from pcm file \"\n\t\t\"(got %\" AF_FRAMECOUNT_PRINT_FMT \")\\n\",\n\t\tframesToRead, framesRead));\n\tm_track->nextfframe += framesRead;\n\tm_track->fpos_next_frame += (framesRead>0) ? framesRead * m_bytesPerFrame : 0;\n\tassert(!canSeek() || (tell() == m_track->fpos_next_frame));\n\tif (framesRead != framesToRead && m_track->totalfframes != -1)\n\t{\n\t\tif (m_track->filemodhappy)\n\t\t{\n\t\t\t_af_error(AF_BAD_READ,\n\t\t\t\t\"file missing data -- read %d frames, \"\n\t\t\t\t\"should be %d\",\n\t\t\t\tm_track->nextfframe,\n\t\t\t\tm_track->totalfframes);\n\t\t\tm_track->filemodhappy = false;\n\t\t}\n\t}\n\tm_outChunk->frameCount = framesRead;\n}", "target": 0}
{"code": "copy_ciphersuites(gnutls_session_t session,\n\t\t  gnutls_buffer_st * cdata, int add_scsv)\n{\n\tint ret;\n\tuint8_t cipher_suites[MAX_CIPHERSUITE_SIZE + 2]; \n\tint cipher_suites_size;\n\tsize_t init_length = cdata->length;\n\tret =\n\t    _gnutls_supported_ciphersuites(session, cipher_suites,\n\t\t\t\t\t   sizeof(cipher_suites) - 2);\n\tif (ret < 0)\n\t\treturn gnutls_assert_val(ret);\n\tret =\n\t    _gnutls_remove_unwanted_ciphersuites(session, cipher_suites,\n\t\t\t\t\t\t ret, NULL, 0);\n\tif (ret < 0)\n\t\treturn gnutls_assert_val(ret);\n\tif (ret == 0)\n\t\treturn\n\t\t    gnutls_assert_val(GNUTLS_E_INSUFFICIENT_CREDENTIALS);\n\tcipher_suites_size = ret;\n\tif (add_scsv) {\n\t\tcipher_suites[cipher_suites_size] = 0x00;\n\t\tcipher_suites[cipher_suites_size + 1] = 0xff;\n\t\tcipher_suites_size += 2;\n\t\tret = _gnutls_ext_sr_send_cs(session);\n\t\tif (ret < 0)\n\t\t\treturn gnutls_assert_val(ret);\n\t}\n\tret =\n\t    _gnutls_buffer_append_data_prefix(cdata, 16, cipher_suites,\n\t\t\t\t\t      cipher_suites_size);\n\tif (ret < 0)\n\t\treturn gnutls_assert_val(ret);\n\tret = cdata->length - init_length;\n\treturn ret;\n}", "target": 1}
{"code": "ImagingNew(const char* mode, int xsize, int ysize)\n{\n    int bytes;\n    Imaging im;\n    if (strlen(mode) == 1) {\n        if (mode[0] == 'F' || mode[0] == 'I')\n            bytes = 4;\n        else\n            bytes = 1;\n    } else\n        bytes = strlen(mode); \n    if ((int64_t) xsize * (int64_t) ysize <= THRESHOLD / bytes) {\n        im = ImagingNewBlock(mode, xsize, ysize);\n        if (im)\n            return im;\n        ImagingError_Clear();\n    }\n    return ImagingNewArray(mode, xsize, ysize);\n}", "target": 1}
{"code": "g_opendir(Char *str, glob_t *pglob)\n{\n    char buf[PATH_MAX];\n    if (!*str) {\n        buf[0] = '.';\n        buf[1] = 0;\n    } else {\n        if (g_Ctoc(str, buf, sizeof(buf))) {\n            return NULL;\n        }\n    }\n    if (pglob->gl_flags & GLOB_ALTDIRFUNC) {\n        return (*pglob->gl_opendir)(buf);\n    }\n    return opendir(buf);\n}", "target": 0}
{"code": "static void carray(JF, js_Ast *list)\n{\n\tint i = 0;\n\twhile (list) {\n\t\tif (list->a->type != EXP_UNDEF) {\n\t\t\temitnumber(J, F, i++);\n\t\t\tcexp(J, F, list->a);\n\t\t\temit(J, F, OP_INITPROP);\n\t\t} else {\n\t\t\t++i;\n\t\t}\n\t\tlist = list->b;\n\t}\n}", "target": 0}
{"code": "  explicit UnravelIndexOp(OpKernelConstruction* ctx) : OpKernel(ctx) {}", "target": 1}
{"code": "static void test_simple()\n{\n    json_set_alloc_funcs(my_malloc, my_free);\n    create_and_free_complex_object();\n    if(malloc_called != 20 || free_called != 20)\n        fail(\"Custom allocation failed\");\n}", "target": 1}
{"code": "long keyctl_join_session_keyring(const char __user *_name)\n{\n\tchar *name;\n\tlong ret;\n\tname = NULL;\n\tif (_name) {\n\t\tname = strndup_user(_name, PAGE_SIZE);\n\t\tif (IS_ERR(name)) {\n\t\t\tret = PTR_ERR(name);\n\t\t\tgoto error;\n\t\t}\n\t}\n\tret = join_session_keyring(name);\n error:\n\treturn ret;\n} ", "target": 1}
{"code": "static char *failover_find_primary_device_id(VirtIONet *n)\n{\n    Error *err = NULL;\n    FailoverId fid;\n    fid.n = n;\n    if (!qemu_opts_foreach(qemu_find_opts(\"device\"),\n                           failover_set_primary, &fid, &err)) {\n        return NULL;\n    }\n    return fid.id;\n}", "target": 0}
{"code": "int snd_card_disconnect(struct snd_card *card)\n{\n\tstruct snd_monitor_file *mfile;\n\tif (!card)\n\t\treturn -EINVAL;\n\tspin_lock(&card->files_lock);\n\tif (card->shutdown) {\n\t\tspin_unlock(&card->files_lock);\n\t\treturn 0;\n\t}\n\tcard->shutdown = 1;\n\tspin_unlock(&card->files_lock);\n\tmutex_lock(&snd_card_mutex);\n\tsnd_cards[card->number] = NULL;\n\tclear_bit(card->number, snd_cards_lock);\n\tmutex_unlock(&snd_card_mutex);\n\tspin_lock(&card->files_lock);\n\tlist_for_each_entry(mfile, &card->files_list, list) {\n\t\tmfile->disconnected_f_op = mfile->file->f_op;\n\t\tspin_lock(&shutdown_lock);\n\t\tlist_add(&mfile->shutdown_list, &shutdown_files);\n\t\tspin_unlock(&shutdown_lock);\n\t\tmfile->file->f_op = &snd_shutdown_f_ops;\n\t\tfops_get(mfile->file->f_op);\n\t}\n\tspin_unlock(&card->files_lock);\t\n#if IS_ENABLED(CONFIG_SND_MIXER_OSS)\n\tif (snd_mixer_oss_notify_callback)\n\t\tsnd_mixer_oss_notify_callback(card, SND_MIXER_OSS_NOTIFY_DISCONNECT);\n#endif\n\tsnd_device_disconnect_all(card);\n\tsnd_info_card_disconnect(card);\n\tif (card->registered) {\n\t\tdevice_del(&card->card_dev);\n\t\tcard->registered = false;\n\t}\n#ifdef CONFIG_PM\n\twake_up(&card->power_sleep);\n#endif\n\treturn 0;\t\n}", "target": 1}
{"code": "unserialize_uep(bufinfo_T *bi, int *error, char_u *file_name)\n{\n    int\t\ti;\n    u_entry_T\t*uep;\n    char_u\t**array;\n    char_u\t*line;\n    int\t\tline_len;\n    uep = (u_entry_T *)U_ALLOC_LINE(sizeof(u_entry_T));\n    if (uep == NULL)\n\treturn NULL;\n    vim_memset(uep, 0, sizeof(u_entry_T));\n#ifdef U_DEBUG\n    uep->ue_magic = UE_MAGIC;\n#endif\n    uep->ue_top = undo_read_4c(bi);\n    uep->ue_bot = undo_read_4c(bi);\n    uep->ue_lcount = undo_read_4c(bi);\n    uep->ue_size = undo_read_4c(bi);\n    if (uep->ue_size > 0)\n    {\n\tarray = (char_u **)U_ALLOC_LINE(sizeof(char_u *) * uep->ue_size);\n\tif (array == NULL)\n\t{\n\t    *error = TRUE;\n\t    return uep;\n\t}\n\tvim_memset(array, 0, sizeof(char_u *) * uep->ue_size);\n    }\n    else\n\tarray = NULL;\n    uep->ue_array = array;\n    for (i = 0; i < uep->ue_size; ++i)\n    {\n\tline_len = undo_read_4c(bi);\n\tif (line_len >= 0)\n\t    line = read_string_decrypt(bi, line_len);\n\telse\n\t{\n\t    line = NULL;\n\t    corruption_error(\"line length\", file_name);\n\t}\n\tif (line == NULL)\n\t{\n\t    *error = TRUE;\n\t    return uep;\n\t}\n\tarray[i] = line;\n    }\n    return uep;\n}", "target": 1}
{"code": "print_address_information(address_item *addr, FILE *f, uschar *si, uschar *sc,\n  uschar *se)\n{\nBOOL yield = TRUE;\nuschar *printed = US\"\";\naddress_item *ancestor = addr;\nwhile (ancestor->parent) ancestor = ancestor->parent;\nfprintf(f, \"%s\", CS si);\nif (addr->parent && testflag(addr, af_hide_child))\n  {\n  printed = US\"an undisclosed address\";\n  yield = FALSE;\n  }\nelse if (!testflag(addr, af_pfr) || !addr->parent)\n  printed = addr->address;\nelse\n  {\n  uschar *s = addr->address;\n  uschar *ss;\n  if (addr->address[0] == '>') { ss = US\"mail\"; s++; }\n  else if (addr->address[0] == '|') ss = US\"pipe\";\n  else ss = US\"save\";\n  fprintf(f, \"%s to %s%sgenerated by \", ss, s, sc);\n  printed = addr->parent->address;\n  }\nfprintf(f, \"%s\", CS string_printing(printed));\nif (ancestor != addr)\n  {\n  uschar *original = ancestor->onetime_parent;\n  if (!original) original= ancestor->address;\n  if (strcmpic(original, printed) != 0)\n    fprintf(f, \"%s(%sgenerated from %s)\", sc,\n      ancestor != addr->parent ? \"ultimately \" : \"\",\n      string_printing(original));\n  }\nif (addr->host_used)\n  fprintf(f, \"\\n    host %s [%s]\",\n\t  addr->host_used->name, addr->host_used->address);\nfprintf(f, \"%s\", CS se);\nreturn yield;\n}", "target": 0}
{"code": "static void ax25_kill_by_device(struct net_device *dev)\n{\n\tax25_dev *ax25_dev;\n\tax25_cb *s;\n\tstruct sock *sk;\n\tif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\n\t\treturn;\n\tspin_lock_bh(&ax25_list_lock);\nagain:\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->ax25_dev == ax25_dev) {\n\t\t\tsk = s->sk;\n\t\t\tsock_hold(sk);\n\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\tlock_sock(sk);\n\t\t\ts->ax25_dev = NULL;\n\t\t\tax25_dev_put(ax25_dev);\n\t\t\trelease_sock(sk);\n\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\tspin_lock_bh(&ax25_list_lock);\n\t\t\tsock_put(sk);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock_bh(&ax25_list_lock);\n}", "target": 1}
{"code": "int qemu_can_send_packet(NetClientState *sender)\n{\n    int vm_running = runstate_is_running();\n    if (!vm_running) {\n        return 0;\n    }\n    if (!sender->peer) {\n        return 1;\n    }\n    if (sender->peer->receive_disabled) {\n        return 0;\n    } else if (sender->peer->info->can_receive &&\n               !sender->peer->info->can_receive(sender->peer)) {\n        return 0;\n    }\n    return 1;\n}", "target": 1}
{"code": "static void xen_netbk_idx_release(struct xen_netbk *netbk, u16 pending_idx)\n{\n\tstruct xenvif *vif;\n\tstruct pending_tx_info *pending_tx_info;\n\tpending_ring_idx_t index;\n\tif (netbk->mmap_pages[pending_idx] == NULL)\n\t\treturn;\n\tpending_tx_info = &netbk->pending_tx_info[pending_idx];\n\tvif = pending_tx_info->vif;\n\tmake_tx_response(vif, &pending_tx_info->req, XEN_NETIF_RSP_OKAY);\n\tindex = pending_index(netbk->pending_prod++);\n\tnetbk->pending_ring[index] = pending_idx;\n\txenvif_put(vif);\n\tnetbk->mmap_pages[pending_idx]->mapping = 0;\n\tput_page(netbk->mmap_pages[pending_idx]);\n\tnetbk->mmap_pages[pending_idx] = NULL;\n}", "target": 1}
{"code": "get_clone_size (GnomeRRScreen *screen, int *width, int *height)\n{\n        GnomeRRMode **modes = gnome_rr_screen_list_clone_modes (screen);\n        int best_w, best_h;\n        int i;\n        best_w = 0;\n        best_h = 0;\n        for (i = 0; modes[i] != NULL; ++i) {\n                GnomeRRMode *mode = modes[i];\n                int w, h;\n                w = gnome_rr_mode_get_width (mode);\n                h = gnome_rr_mode_get_height (mode);\n                if (w * h > best_w * best_h) {\n                        best_w = w;\n                        best_h = h;\n                }\n        }\n        if (best_w > 0 && best_h > 0) {\n                if (width)\n                        *width = best_w;\n                if (height)\n                        *height = best_h;\n                return TRUE;\n        }\n        return FALSE;\n}", "target": 0}
{"code": "static void ikev2_parent_inR1outI2_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t    struct pluto_crypto_req *r,\n\t\t\t\t\t    err_t ugh)\n{\n\tstruct dh_continuation *dh = (struct dh_continuation *)pcrc;\n\tstruct msg_digest *md = dh->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\"ikev2 parent inR1outI2: calculating g^{xy}, sending I2\"));\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \"%s: Request was disconnected from state\",\n\t\t       __FUNCTION__);\n\t\tif (dh->md)\n\t\t\trelease_md(dh->md);\n\t\treturn;\n\t}\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\tpassert(st->st_suspended_md == dh->md);\n\tset_suspended(st, NULL); \n\tset_cur_state(st);\n\tst->st_calculating = FALSE;\n\te = ikev2_parent_inR1outI2_tail(pcrc, r);\n\tif (dh->md != NULL) {\n\t\tcomplete_v2_state_transition(&dh->md, e);\n\t\tif (dh->md)\n\t\t\trelease_md(dh->md);\n\t}\n\treset_globals();\n\tpassert(GLOBALS_ARE_RESET());\n}", "target": 1}
{"code": "static void *skcipher_bind(const char *name, u32 type, u32 mask)\n{\n\treturn crypto_alloc_skcipher(name, type, mask);\n}", "target": 1}
{"code": "x509stack_pop(struct cert_stack *stack)\n{\n\tX509 *cert;\n\tstruct metadata_node *meta;\n\tstruct repo_level_node *repo;\n\tcert = sk_X509_pop(stack->x509s);\n\tif (cert == NULL)\n\t\tpr_crit(\"Attempted to pop empty X509 stack\");\n\tX509_free(cert);\n\tmeta = SLIST_FIRST(&stack->metas);\n\tif (meta == NULL)\n\t\tpr_crit(\"Attempted to pop empty metadata stack\");\n\tSLIST_REMOVE_HEAD(&stack->metas, next);\n\tmeta_destroy(meta);\n\trepo = SLIST_FIRST(&stack->levels);\n\tif (repo == NULL)\n\t\tpr_crit(\"Attempted to pop empty repo level stack\");\n\tSLIST_REMOVE_HEAD(&stack->levels, next);\n\tfree(repo);\n}", "target": 1}
{"code": "static void *proc_pid_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error = -EACCES;\n\tpath_put(&nd->path);\n\tif (!proc_fd_access_allowed(inode))\n\t\tgoto out;\n\terror = PROC_I(inode)->op.proc_get_link(dentry, &nd->path);\nout:\n\treturn ERR_PTR(error);\n}", "target": 0}
{"code": "static enum AVPixelFormat h263_get_format(AVCodecContext *avctx)\n{\n    if (avctx->bits_per_raw_sample > 8) {\n        av_assert1(avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);\n        return avctx->pix_fmt;\n    }\n    if (avctx->codec->id == AV_CODEC_ID_MSS2)\n        return AV_PIX_FMT_YUV420P;\n    if (CONFIG_GRAY && (avctx->flags & AV_CODEC_FLAG_GRAY)) {\n        if (avctx->color_range == AVCOL_RANGE_UNSPECIFIED)\n            avctx->color_range = AVCOL_RANGE_MPEG;\n        return AV_PIX_FMT_GRAY8;\n    }\n    return avctx->pix_fmt = ff_get_format(avctx, avctx->codec->pix_fmts);\n}", "target": 1}
{"code": "void ArcMemory::Load(const byte *Data,size_t Size)\n{\n  ArcData.Alloc(Size);\n  memcpy(&ArcData[0],Data,Size);\n  Loaded=true;\n  SeekPos=0;\n}", "target": 0}
{"code": "int kvm_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3)\n{\n\tif (cr3 == kvm_read_cr3(vcpu) && !pdptrs_changed(vcpu)) {\n\t\tkvm_mmu_sync_roots(vcpu);\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\treturn 0;\n\t}\n\tif (is_long_mode(vcpu)) {\n\t\tif (cr3 & CR3_L_MODE_RESERVED_BITS)\n\t\t\treturn 1;\n\t} else if (is_pae(vcpu) && is_paging(vcpu) &&\n\t\t   !load_pdptrs(vcpu, vcpu->arch.walk_mmu, cr3))\n\t\treturn 1;\n\tvcpu->arch.cr3 = cr3;\n\t__set_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail);\n\tkvm_mmu_new_cr3(vcpu);\n\treturn 0;\n}", "target": 0}
{"code": "static __inline__ int cbq_dump_ovl(struct sk_buff *skb, struct cbq_class *cl)\n{\n\tunsigned char\t *b = skb->tail;\n\tstruct tc_cbq_ovl opt;\n\topt.strategy = cl->ovl_strategy;\n\topt.priority2 = cl->priority2+1;\n\topt.penalty = (cl->penalty*1000)/HZ;\n\tRTA_PUT(skb, TCA_CBQ_OVL_STRATEGY, sizeof(opt), &opt);\n\treturn skb->len;\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}", "target": 1}
{"code": "ebt_basic_match(const struct ebt_entry *e, const struct sk_buff *skb,\n                const struct net_device *in, const struct net_device *out)\n{\n\tconst struct ethhdr *h = eth_hdr(skb);\n\tconst struct net_bridge_port *p;\n\t__be16 ethproto;\n\tint verdict, i;\n\tif (vlan_tx_tag_present(skb))\n\t\tethproto = htons(ETH_P_8021Q);\n\telse\n\t\tethproto = h->h_proto;\n\tif (e->bitmask & EBT_802_3) {\n\t\tif (FWINV2(ntohs(ethproto) >= 1536, EBT_IPROTO))\n\t\t\treturn 1;\n\t} else if (!(e->bitmask & EBT_NOPROTO) &&\n\t   FWINV2(e->ethproto != ethproto, EBT_IPROTO))\n\t\treturn 1;\n\tif (FWINV2(ebt_dev_check(e->in, in), EBT_IIN))\n\t\treturn 1;\n\tif (FWINV2(ebt_dev_check(e->out, out), EBT_IOUT))\n\t\treturn 1;\n\tif (in && (p = br_port_get_rcu(in)) != NULL &&\n\t    FWINV2(ebt_dev_check(e->logical_in, p->br->dev), EBT_ILOGICALIN))\n\t\treturn 1;\n\tif (out && (p = br_port_get_rcu(out)) != NULL &&\n\t    FWINV2(ebt_dev_check(e->logical_out, p->br->dev), EBT_ILOGICALOUT))\n\t\treturn 1;\n\tif (e->bitmask & EBT_SOURCEMAC) {\n\t\tverdict = 0;\n\t\tfor (i = 0; i < 6; i++)\n\t\t\tverdict |= (h->h_source[i] ^ e->sourcemac[i]) &\n\t\t\t   e->sourcemsk[i];\n\t\tif (FWINV2(verdict != 0, EBT_ISOURCE) )\n\t\t\treturn 1;\n\t}\n\tif (e->bitmask & EBT_DESTMAC) {\n\t\tverdict = 0;\n\t\tfor (i = 0; i < 6; i++)\n\t\t\tverdict |= (h->h_dest[i] ^ e->destmac[i]) &\n\t\t\t   e->destmsk[i];\n\t\tif (FWINV2(verdict != 0, EBT_IDEST) )\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "libxlDomainCreateChannelPTY(virDomainDef *def, libxl_ctx *ctx)\n{\n    libxl_device_channel *x_channels;\n    virDomainChrDef *chr;\n    size_t i;\n    int nchannels;\n    x_channels = libxl_device_channel_list(ctx, def->id, &nchannels);\n    if (!x_channels)\n        return;\n    for (i = 0; i < def->nchannels; i++) {\n        libxl_channelinfo channelinfo;\n        int ret;\n        chr = def->channels[i];\n        if (chr->source->type != VIR_DOMAIN_CHR_TYPE_PTY)\n            continue;\n        ret = libxl_device_channel_getinfo(ctx, def->id, &x_channels[i],\n                                           &channelinfo);\n        if (!ret && channelinfo.u.pty.path &&\n            *channelinfo.u.pty.path != '\\0') {\n                VIR_FREE(chr->source->data.file.path);\n                chr->source->data.file.path = g_strdup(channelinfo.u.pty.path);\n            }\n    }\n    for (i = 0; i < nchannels; i++)\n        libxl_device_channel_dispose(&x_channels[i]);\n}", "target": 0}
{"code": "static void kick_siblings(struct i915_request *rq, struct intel_context *ce)\n{\n\tstruct virtual_engine *ve = container_of(ce, typeof(*ve), context);\n\tstruct i915_request *next = READ_ONCE(ve->request);\n\tif (next && next->execution_mask & ~rq->execution_mask)\n\t\ttasklet_schedule(&ve->base.execlists.tasklet);\n}", "target": 0}
{"code": "folly::Optional<TLSMessage> EncryptedReadRecordLayer::read(\n    folly::IOBufQueue& buf) {\n  auto decryptedBuf = getDecryptedBuf(buf);\n  if (!decryptedBuf) {\n    return folly::none;\n  }\n  TLSMessage msg{};\n  auto currentBuf = decryptedBuf->get();\n  bool nonZeroFound = false;\n  do {\n    currentBuf = currentBuf->prev();\n    size_t i = currentBuf->length();\n    while (i > 0 && !nonZeroFound) {\n      nonZeroFound = (currentBuf->data()[i - 1] != 0);\n      i--;\n    }\n    if (nonZeroFound) {\n      msg.type = static_cast<ContentType>(currentBuf->data()[i]);\n    }\n    currentBuf->trimEnd(currentBuf->length() - i);\n  } while (!nonZeroFound && currentBuf != decryptedBuf->get());\n  if (!nonZeroFound) {\n    throw std::runtime_error(\"No content type found\");\n  }\n  msg.fragment = std::move(*decryptedBuf);\n  switch (msg.type) {\n    case ContentType::handshake:\n    case ContentType::alert:\n    case ContentType::application_data:\n      break;\n    default:\n      throw std::runtime_error(folly::to<std::string>(\n          \"received encrypted content type \",\n          static_cast<ContentTypeType>(msg.type)));\n  }\n  if (!msg.fragment || msg.fragment->empty()) {\n    if (msg.type == ContentType::application_data) {\n      msg.fragment = folly::IOBuf::create(0);\n    } else {\n      throw std::runtime_error(\"received empty fragment\");\n    }\n  }\n  return msg;\n}", "target": 0}
{"code": "void mark_mounts_for_expiry(struct list_head *mounts)\n{\n\tstruct mount *mnt, *next;\n\tLIST_HEAD(graveyard);\n\tif (list_empty(mounts))\n\t\treturn;\n\tnamespace_lock();\n\tlock_mount_hash();\n\tlist_for_each_entry_safe(mnt, next, mounts, mnt_expire) {\n\t\tif (!xchg(&mnt->mnt_expiry_mark, 1) ||\n\t\t\tpropagate_mount_busy(mnt, 1))\n\t\t\tcontinue;\n\t\tlist_move(&mnt->mnt_expire, &graveyard);\n\t}\n\twhile (!list_empty(&graveyard)) {\n\t\tmnt = list_first_entry(&graveyard, struct mount, mnt_expire);\n\t\ttouch_mnt_namespace(mnt->mnt_ns);\n\t\tumount_tree(mnt, 1);\n\t}\n\tunlock_mount_hash();\n\tnamespace_unlock();\n}", "target": 0}
{"code": "static int16_t findOffset(const char* const* list, const char* key)\n{\n\tconst char* const* anchor = list;\n\twhile (*list != NULL) {\n\t\tif (strcmp(key, *list) == 0) {\n\t\t\treturn (int16_t)(list - anchor);\n\t\t}\n\t\tlist++;\n\t}\n\treturn -1;\n}", "target": 0}
{"code": "static void *intel_alloc_coherent(struct device *dev, size_t size,\n\t\t\t\t  dma_addr_t *dma_handle, gfp_t flags,\n\t\t\t\t  unsigned long attrs)\n{\n\tstruct page *page = NULL;\n\tint order;\n\tsize = PAGE_ALIGN(size);\n\torder = get_order(size);\n\tif (!iommu_no_mapping(dev))\n\t\tflags &= ~(GFP_DMA | GFP_DMA32);\n\telse if (dev->coherent_dma_mask < dma_get_required_mask(dev)) {\n\t\tif (dev->coherent_dma_mask < DMA_BIT_MASK(32))\n\t\t\tflags |= GFP_DMA;\n\t\telse\n\t\t\tflags |= GFP_DMA32;\n\t}\n\tif (gfpflags_allow_blocking(flags)) {\n\t\tunsigned int count = size >> PAGE_SHIFT;\n\t\tpage = dma_alloc_from_contiguous(dev, count, order,\n\t\t\t\t\t\t flags & __GFP_NOWARN);\n\t\tif (page && iommu_no_mapping(dev) &&\n\t\t    page_to_phys(page) + size > dev->coherent_dma_mask) {\n\t\t\tdma_release_from_contiguous(dev, page, count);\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\tif (!page)\n\t\tpage = alloc_pages(flags, order);\n\tif (!page)\n\t\treturn NULL;\n\tmemset(page_address(page), 0, size);\n\t*dma_handle = __intel_map_single(dev, page_to_phys(page), size,\n\t\t\t\t\t DMA_BIDIRECTIONAL,\n\t\t\t\t\t dev->coherent_dma_mask);\n\tif (*dma_handle)\n\t\treturn page_address(page);\n\tif (!dma_release_from_contiguous(dev, page, size >> PAGE_SHIFT))\n\t\t__free_pages(page, order);\n\treturn NULL;\n}", "target": 0}
{"code": "FileSpec::FileSpec(const Object *fileSpecA)\n{\n  ok = true;\n  fileName = nullptr;\n  platformFileName = nullptr;\n  embFile = nullptr;\n  desc = nullptr;\n  fileSpec = fileSpecA->copy();\n  Object obj1 = getFileSpecName(fileSpecA);\n  if (!obj1.isString()) {\n    ok = false;\n    error(errSyntaxError, -1, \"Invalid FileSpec\");\n    return;\n  }\n  fileName = obj1.getString()->copy();\n  if (fileSpec.isDict()) {\n    obj1 = fileSpec.dictLookup(\"EF\");\n    if (obj1.isDict()) {\n      fileStream = obj1.dictLookupNF(\"F\");\n      if (!fileStream.isRef()) {\n        ok = false;\n        fileStream.setToNull();\n        error(errSyntaxError, -1, \"Invalid FileSpec: Embedded file stream is not an indirect reference\");\n        return;\n      }\n    }\n  }\n  obj1 = fileSpec.dictLookup(\"Desc\");\n  if (obj1.isString())\n    desc = obj1.getString()->copy();\n}", "target": 1}
{"code": "static __be16 sctp_get_asconf_response(struct sctp_chunk *asconf_ack,\n\t\t\t\t      sctp_addip_param_t *asconf_param,\n\t\t\t\t      int no_err)\n{\n\tsctp_addip_param_t\t*asconf_ack_param;\n\tsctp_errhdr_t\t\t*err_param;\n\tint\t\t\tlength;\n\tint\t\t\tasconf_ack_len;\n\t__be16\t\t\terr_code;\n\tif (no_err)\n\t\terr_code = SCTP_ERROR_NO_ERROR;\n\telse\n\t\terr_code = SCTP_ERROR_REQ_REFUSED;\n\tasconf_ack_len = ntohs(asconf_ack->chunk_hdr->length) -\n\t\t\t     sizeof(sctp_chunkhdr_t);\n\tlength = sizeof(sctp_addiphdr_t);\n\tasconf_ack_param = (sctp_addip_param_t *)(asconf_ack->skb->data +\n\t\t\t\t\t\t  length);\n\tasconf_ack_len -= length;\n\twhile (asconf_ack_len > 0) {\n\t\tif (asconf_ack_param->crr_id == asconf_param->crr_id) {\n\t\t\tswitch (asconf_ack_param->param_hdr.type) {\n\t\t\tcase SCTP_PARAM_SUCCESS_REPORT:\n\t\t\t\treturn SCTP_ERROR_NO_ERROR;\n\t\t\tcase SCTP_PARAM_ERR_CAUSE:\n\t\t\t\tlength = sizeof(sctp_addip_param_t);\n\t\t\t\terr_param = (void *)asconf_ack_param + length;\n\t\t\t\tasconf_ack_len -= length;\n\t\t\t\tif (asconf_ack_len > 0)\n\t\t\t\t\treturn err_param->cause;\n\t\t\t\telse\n\t\t\t\t\treturn SCTP_ERROR_INV_PARAM;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn SCTP_ERROR_INV_PARAM;\n\t\t\t}\n\t\t}\n\t\tlength = ntohs(asconf_ack_param->param_hdr.length);\n\t\tasconf_ack_param = (void *)asconf_ack_param + length;\n\t\tasconf_ack_len -= length;\n\t}\n\treturn err_code;\n}", "target": 0}
{"code": "static int route4_init(struct tcf_proto *tp)\n{\n\tstruct route4_head *head;\n\thead = kzalloc(sizeof(struct route4_head), GFP_KERNEL);\n\tif (head == NULL)\n\t\treturn -ENOBUFS;\n\trcu_assign_pointer(tp->root, head);\n\treturn 0;\n}", "target": 0}
{"code": "static void nf_tables_commit_release(struct nft_trans *trans)\n{\n\tswitch (trans->msg_type) {\n\tcase NFT_MSG_DELTABLE:\n\t\tnf_tables_table_destroy(&trans->ctx);\n\t\tbreak;\n\tcase NFT_MSG_DELCHAIN:\n\t\tnf_tables_chain_destroy(trans->ctx.chain);\n\t\tbreak;\n\tcase NFT_MSG_DELRULE:\n\t\tnf_tables_rule_destroy(&trans->ctx, nft_trans_rule(trans));\n\t\tbreak;\n\tcase NFT_MSG_DELSET:\n\t\tnft_set_destroy(nft_trans_set(trans));\n\t\tbreak;\n\t}\n\tkfree(trans);\n}", "target": 0}
{"code": "void QuotaManager::RegisterClient(QuotaClient* client) {\n  DCHECK(io_thread_->BelongsToCurrentThread());\n  DCHECK(!database_.get());\n  clients_.push_back(client);\n}", "target": 0}
{"code": "void fib6_run_gc(unsigned long expires, struct net *net)\n{\n\tif (expires != ~0UL) {\n\t\tspin_lock_bh(&fib6_gc_lock);\n\t\tgc_args.timeout = expires ? (int)expires :\n\t\t\tnet->ipv6.sysctl.ip6_rt_gc_interval;\n\t} else {\n\t\tif (!spin_trylock_bh(&fib6_gc_lock)) {\n\t\t\tmod_timer(&net->ipv6.ip6_fib_timer, jiffies + HZ);\n\t\t\treturn;\n\t\t}\n\t\tgc_args.timeout = net->ipv6.sysctl.ip6_rt_gc_interval;\n\t}\n\tgc_args.more = icmp6_dst_gc();\n\tfib6_clean_all(net, fib6_age, 0, NULL);\n\tif (gc_args.more)\n\t\tmod_timer(&net->ipv6.ip6_fib_timer,\n\t\t\t  round_jiffies(jiffies\n\t\t\t\t\t+ net->ipv6.sysctl.ip6_rt_gc_interval));\n\telse\n\t\tdel_timer(&net->ipv6.ip6_fib_timer);\n\tspin_unlock_bh(&fib6_gc_lock);\n}", "target": 0}
{"code": "integerify(void * B, size_t r)\n{\n  uint32_t * X = (uint32_t *)((uintptr_t)(B) + (2 * r - 1) * 64);\n  return (((uint64_t)(X[13]) << 32) + X[0]);\n}", "target": 1}
{"code": "cib_remote_auth(xmlNode *login)\n{\n    const char *user = NULL;\n    const char *pass = NULL;\n    const char *tmp = NULL;\n    crm_log_xml_info(login, \"Login: \");\n    if (login == NULL) {\n        return FALSE;\n    }\n    tmp = crm_element_name(login);\n    if (safe_str_neq(tmp, \"cib_command\")) {\n        crm_err(\"Wrong tag: %s\", tmp);\n        return FALSE;\n    }\n    tmp = crm_element_value(login, \"op\");\n    if (safe_str_neq(tmp, \"authenticate\")) {\n        crm_err(\"Wrong operation: %s\", tmp);\n        return FALSE;\n    }\n    user = crm_element_value(login, \"user\");\n    pass = crm_element_value(login, \"password\");\n    if (!user || !pass) {\n        crm_err(\"missing auth credentials\");\n        return FALSE;\n    }\n    if (check_group_membership(user, CRM_DAEMON_GROUP) == FALSE) {\n        crm_err(\"User is not a member of the required group\");\n        return FALSE;\n    } else if (authenticate_user(user, pass) == FALSE) {\n        crm_err(\"PAM auth failed\");\n        return FALSE;\n    }\n    return TRUE;\n}", "target": 0}
{"code": "GF_Err trak_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_TrackBox *ptr = (GF_TrackBox *)s;\n\tif (ptr->sample_encryption && ptr->sample_encryption->load_needed) {\n\t\tif (!ptr->moov || !!ptr->moov->mov || !ptr->moov->mov->movieFileMap)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tGF_Err e = senc_Parse(ptr->moov->mov->movieFileMap->bs, ptr, NULL, ptr->sample_encryption);\n\t\tif (e) return e;\n\t}\n\tgf_isom_check_position(s, (GF_Box *)ptr->Header, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->Aperture, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->References, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->editBox, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->Media, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->meta, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->groups, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->udta, &pos);\n\treturn GF_OK;", "target": 0}
{"code": "struct rdma_cm_id *rdma_res_to_id(struct rdma_restrack_entry *res)\n{\n\tstruct rdma_id_private *id_priv =\n\t\tcontainer_of(res, struct rdma_id_private, res);\n\treturn &id_priv->id;\n}", "target": 0}
{"code": "static inline void tlb_end_vma(struct mmu_gather *tlb, struct vm_area_struct *vma)\n{\n\tif (tlb->fullmm || IS_ENABLED(CONFIG_MMU_GATHER_MERGE_VMAS))\n\t\treturn;\n\ttlb_flush_mmu_tlbonly(tlb);\n}", "target": 1}
{"code": "defbackend_bind( Slapi_PBlock *pb )\n{\n    int\t\t\trc;\n    ber_tag_t\t\tmethod;\n    struct berval\t*cred;\n    LDAPDebug( LDAP_DEBUG_TRACE, \"defbackend_bind\\n\", 0, 0, 0 );\n    slapi_pblock_get( pb, SLAPI_BIND_METHOD, &method );\n    slapi_pblock_get( pb, SLAPI_BIND_CREDENTIALS, &cred );\n    if ( method == LDAP_AUTH_SIMPLE && cred->bv_len == 0 ) {\n\tslapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsAnonymousBinds);\n\trc = SLAPI_BIND_ANONYMOUS;\n    } else {\n\tsend_nobackend_ldap_result( pb );\n\trc = SLAPI_BIND_FAIL;\n    }\n    return( rc );\n}", "target": 1}
{"code": "static int count_fuse_fs(void)\n{\n\tstruct mntent *entp;\n\tint count = 0;\n\tconst char *mtab = _PATH_MOUNTED;\n\tFILE *fp = setmntent(mtab, \"r\");\n\tif (fp == NULL) {\n\t\tfprintf(stderr, \"%s: failed to open %s: %s\\n\", progname, mtab,\n\t\t\tstrerror(errno));\n\t\treturn -1;\n\t}\n\twhile ((entp = getmntent(fp)) != NULL) {\n\t\tif (strcmp(entp->mnt_type, \"fuse\") == 0 ||\n\t\t    strncmp(entp->mnt_type, \"fuse.\", 5) == 0)\n\t\t\tcount ++;\n\t}\n\tendmntent(fp);\n\treturn count;\n}", "target": 0}
{"code": "static bool ok_inflater_compressed_block(ok_inflater *inflater) {\n    const bool is_fixed = inflater->state == OK_INFLATER_STATE_READING_FIXED_COMPRESSED_BLOCK;\n    const ok_inflater_huffman_tree *literal_tree =\n        (is_fixed ? inflater->fixed_literal_huffman : inflater->literal_huffman);\n    const ok_inflater_huffman_tree *distance_tree =\n        (is_fixed ? inflater->fixed_distance_huffman : inflater->distance_huffman);\n    size_t max_write = ok_inflater_can_write_total(inflater);\n    const uint16_t *tree_lookup_table = literal_tree->lookup_table;\n    const unsigned int tree_bits = literal_tree->bits;\n    while (max_write > 0) {\n        int value = ok_inflater_decode_literal(inflater, tree_lookup_table, tree_bits);\n        if (value < 0) {\n            return false;\n        } else if (value < 256) {\n            ok_inflater_write_byte(inflater, (uint8_t)value);\n            max_write--;\n        } else if (value == 256) {\n            inflater->state = OK_INFLATER_STATE_READY_FOR_NEXT_BLOCK;\n            return true;\n        } else if (value < 286) {\n            inflater->huffman_code = value - 257;\n            inflater->state_count = -1;\n            inflater->state_distance = -1;\n            if (ok_inflater_distance_with_tree(inflater, distance_tree)) {\n                max_write = ok_inflater_can_write_total(inflater);\n            } else {\n                if (is_fixed) {\n                    inflater->state = OK_INFLATER_STATE_READING_FIXED_DISTANCE;\n                } else {\n                    inflater->state = OK_INFLATER_STATE_READING_DYNAMIC_DISTANCE;\n                }\n                return false;\n            }\n        } else {\n            ok_inflater_error(inflater, \"Invalid inflater literal\");\n            return false;\n        }\n    }\n    return false;\n}", "target": 0}
{"code": "virNodeDeviceGetMdevTypesCaps(const char *sysfspath,\n                              virMediatedDeviceTypePtr **mdev_types,\n                              size_t *nmdev_types)\n{\n    virMediatedDeviceTypePtr *types = NULL;\n    size_t ntypes = 0;\n    size_t i;\n    for (i = 0; i < *nmdev_types; i++)\n       virMediatedDeviceTypeFree(*mdev_types[i]);\n    VIR_FREE(*mdev_types);\n    *nmdev_types = 0;\n    if (virMediatedDeviceGetMdevTypes(sysfspath, &types, &ntypes) < 0)\n        return -1;\n    *mdev_types = g_steal_pointer(&types);\n    *nmdev_types = ntypes;\n    return 0;\n}", "target": 1}
{"code": "mm_answer_sign(int socket, Buffer *m)\n{\n\tKey *key;\n\tu_char *p;\n\tu_char *signature;\n\tu_int siglen, datlen;\n\tint keyid;\n\tdebug3(\"%s\", __func__);\n\tkeyid = buffer_get_int(m);\n\tp = buffer_get_string(m, &datlen);\n\tif (datlen != 20)\n\t\tfatal(\"%s: data length incorrect: %u\", __func__, datlen);\n\tif (session_id2_len == 0) {\n\t\tsession_id2_len = datlen;\n\t\tsession_id2 = xmalloc(session_id2_len);\n\t\tmemcpy(session_id2, p, session_id2_len);\n\t}\n\tif ((key = get_hostkey_by_index(keyid)) == NULL)\n\t\tfatal(\"%s: no hostkey from index %d\", __func__, keyid);\n\tif (key_sign(key, &signature, &siglen, p, datlen) < 0)\n\t\tfatal(\"%s: key_sign failed\", __func__);\n\tdebug3(\"%s: signature %p(%u)\", __func__, signature, siglen);\n\tbuffer_clear(m);\n\tbuffer_put_string(m, signature, siglen);\n\txfree(p);\n\txfree(signature);\n\tmm_request_send(socket, MONITOR_ANS_SIGN, m);\n\tmonitor_permit(mon_dispatch, MONITOR_REQ_PWNAM, 1);\n\treturn (0);\n}", "target": 0}
{"code": "static int vhost_vdpa_map(struct vhost_vdpa *v, u64 iova,\n\t\t\t  u64 size, u64 pa, u32 perm, void *opaque)\n{\n\tstruct vhost_dev *dev = &v->vdev;\n\tstruct vdpa_device *vdpa = v->vdpa;\n\tconst struct vdpa_config_ops *ops = vdpa->config;\n\tint r = 0;\n\tr = vhost_iotlb_add_range_ctx(dev->iotlb, iova, iova + size - 1,\n\t\t\t\t      pa, perm, opaque);\n\tif (r)\n\t\treturn r;\n\tif (ops->dma_map) {\n\t\tr = ops->dma_map(vdpa, iova, size, pa, perm, opaque);\n\t} else if (ops->set_map) {\n\t\tif (!v->in_batch)\n\t\t\tr = ops->set_map(vdpa, dev->iotlb);\n\t} else {\n\t\tr = iommu_map(v->domain, iova, pa, size,\n\t\t\t      perm_to_iommu_flags(perm));\n\t}\n\tif (r) {\n\t\tvhost_iotlb_del_range(dev->iotlb, iova, iova + size - 1);\n\t\treturn r;\n\t}\n\tif (!vdpa->use_va)\n\t\tatomic64_add(PFN_DOWN(size), &dev->mm->pinned_vm);\n\treturn 0;\n}", "target": 0}
{"code": "comics_document_thumbnails_get_dimensions (EvDocumentThumbnails *document,\n\t\t\t\t\t   EvRenderContext      *rc,\n\t\t\t\t\t   gint                 *width,\n\t\t\t\t\t   gint                 *height)\n{\n\tgdouble page_width, page_height;\n\tcomics_document_get_page_size (EV_DOCUMENT (document), rc->page,\n\t\t\t\t       &page_width, &page_height);\n\tif (rc->rotation == 90 || rc->rotation == 270) {\n\t\t*width = (gint) (page_height * rc->scale);\n\t\t*height = (gint) (page_width * rc->scale);\n\t} else {\n\t\t*width = (gint) (page_width * rc->scale);\n\t\t*height = (gint) (page_height * rc->scale);\n\t}\n}", "target": 1}
{"code": "static int __init acpi_custom_method_init(void)\n{\n\tif (!acpi_debugfs_dir)\n\t\treturn -ENOENT;\n\tcm_dentry = debugfs_create_file(\"custom_method\", S_IWUSR,\n\t\t\t\t\tacpi_debugfs_dir, NULL, &cm_fops);\n\tif (!cm_dentry)\n\t\treturn -ENODEV;\n\treturn 0;\n}", "target": 1}
{"code": "static int _gnutls_verify_crl2(gnutls_x509_crl_t crl,\n\t\t\t       const gnutls_x509_crt_t * trusted_cas,\n\t\t\t       int tcas_size, unsigned int flags,\n\t\t\t       unsigned int *output)\n{\n    gnutls_datum_t crl_signed_data = { NULL, 0 };\n    gnutls_datum_t crl_signature = { NULL, 0 };\n    gnutls_x509_crt_t issuer;\n    int ret, result;\n    if (output)\n\t*output = 0;\n    if (tcas_size >= 1)\n\tissuer = find_crl_issuer(crl, trusted_cas, tcas_size);\n    else {\n\tgnutls_assert();\n\tif (output)\n\t    *output |= GNUTLS_CERT_SIGNER_NOT_FOUND | GNUTLS_CERT_INVALID;\n\treturn 0;\n    }\n    if (issuer == NULL) {\n\tgnutls_assert();\n\tif (output)\n\t    *output |= GNUTLS_CERT_SIGNER_NOT_FOUND | GNUTLS_CERT_INVALID;\n\treturn 0;\n    }\n    if (!(flags & GNUTLS_VERIFY_DISABLE_CA_SIGN)) {\n\tif (gnutls_x509_crt_get_ca_status(issuer, NULL) != 1) {\n\t    gnutls_assert();\n\t    if (output)\n\t\t*output |= GNUTLS_CERT_SIGNER_NOT_CA | GNUTLS_CERT_INVALID;\n\t    return 0;\n\t}\n    }\n    result =\n\t_gnutls_x509_get_signed_data(crl->crl, \"tbsCertList\",\n\t\t\t\t     &crl_signed_data);\n    if (result < 0) {\n\tgnutls_assert();\n\tgoto cleanup;\n    }\n    result =\n\t_gnutls_x509_get_signature(crl->crl, \"signature\", &crl_signature);\n    if (result < 0) {\n\tgnutls_assert();\n\tgoto cleanup;\n    }\n    ret =\n\t_gnutls_x509_verify_signature(&crl_signed_data, &crl_signature,\n\t\t\t\t      issuer);\n    if (ret < 0) {\n\tgnutls_assert();\n    } else if (ret == 0) {\n\tgnutls_assert();\n\tif (output)\n\t    *output |= GNUTLS_CERT_INVALID;\n\tret = 0;\n    }\n    result = ret;\n  cleanup:\n    _gnutls_free_datum(&crl_signed_data);\n    _gnutls_free_datum(&crl_signature);\n    return result;\n}", "target": 0}
{"code": "static void virtio_blk_handle_read(VirtIOBlockReq *req)\n{\n    BlockDriverAIOCB *acb;\n    uint64_t sector;\n    sector = ldq_p(&req->out->sector);\n    if (sector & req->dev->sector_mask) {\n        virtio_blk_rw_complete(req, -EIO);\n        return;\n    }\n    acb = bdrv_aio_readv(req->dev->bs, sector, &req->qiov,\n                         req->qiov.size / BDRV_SECTOR_SIZE,\n                         virtio_blk_rw_complete, req);\n    if (!acb) {\n        virtio_blk_rw_complete(req, -EIO);\n    }\n}", "target": 1}
{"code": "long keyctl_describe_key(key_serial_t keyid,\n\t\t\t char __user *buffer,\n\t\t\t size_t buflen)\n{\n\tstruct key *key, *instkey;\n\tkey_ref_t key_ref;\n\tchar *infobuf;\n\tlong ret;\n\tint desclen, infolen;\n\tkey_ref = lookup_user_key(keyid, KEY_LOOKUP_PARTIAL, KEY_NEED_VIEW);\n\tif (IS_ERR(key_ref)) {\n\t\tif (PTR_ERR(key_ref) == -EACCES) {\n\t\t\tinstkey = key_get_instantiation_authkey(keyid);\n\t\t\tif (!IS_ERR(instkey)) {\n\t\t\t\tkey_put(instkey);\n\t\t\t\tkey_ref = lookup_user_key(keyid,\n\t\t\t\t\t\t\t  KEY_LOOKUP_PARTIAL,\n\t\t\t\t\t\t\t  0);\n\t\t\t\tif (!IS_ERR(key_ref))\n\t\t\t\t\tgoto okay;\n\t\t\t}\n\t\t}\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\nokay:\n\tkey = key_ref_to_ptr(key_ref);\n\tdesclen = strlen(key->description);\n\tret = -ENOMEM;\n\tinfobuf = kasprintf(GFP_KERNEL,\n\t\t\t    \"%s;%d;%d;%08x;\",\n\t\t\t    key->type->name,\n\t\t\t    from_kuid_munged(current_user_ns(), key->uid),\n\t\t\t    from_kgid_munged(current_user_ns(), key->gid),\n\t\t\t    key->perm);\n\tif (!infobuf)\n\t\tgoto error2;\n\tinfolen = strlen(infobuf);\n\tret = infolen + desclen + 1;\n\tif (buffer && buflen >= ret) {\n\t\tif (copy_to_user(buffer, infobuf, infolen) != 0 ||\n\t\t    copy_to_user(buffer + infolen, key->description,\n\t\t\t\t desclen + 1) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tkfree(infobuf);\nerror2:\n\tkey_ref_put(key_ref);\nerror:\n\treturn ret;\n}", "target": 0}
{"code": "void gdImagePaletteCopy (gdImagePtr to, gdImagePtr from)\n{\n\tint i;\n\tint x, y, p;\n\tint xlate[256];\n\tif (to->trueColor || from->trueColor) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < 256; i++) {\n\t\txlate[i] = -1;\n\t}\n\tfor (y = 0; y < to->sy; y++) {\n\t\tfor (x = 0; x < to->sx; x++) {\n\t\t\tp = gdImageGetPixel(to, x, y);\n\t\t\tif (xlate[p] == -1) {\n\t\t\t\txlate[p] = gdImageColorClosestAlpha (from, to->red[p], to->green[p], to->blue[p], to->alpha[p]);\n\t\t\t}\n\t\t\tgdImageSetPixel(to, x, y, xlate[p]);\n\t\t}\n\t}\n\tfor (i = 0; i < from->colorsTotal; i++) {\n\t\tto->red[i] = from->red[i];\n\t\tto->blue[i] = from->blue[i];\n\t\tto->green[i] = from->green[i];\n\t\tto->alpha[i] = from->alpha[i];\n\t\tto->open[i] = 0;\n\t}\n\tfor (i = from->colorsTotal; i < to->colorsTotal; i++) {\n\t\tto->open[i] = 1;\n\t}\n\tto->colorsTotal = from->colorsTotal;\n}", "target": 0}
{"code": "rtadv_read (struct thread *thread)\n{\n  int sock;\n  int len;\n  u_char buf[RTADV_MSG_SIZE];\n  struct sockaddr_in6 from;\n  ifindex_t ifindex = 0;\n  int hoplimit = -1;\n  struct zebra_vrf *zvrf = THREAD_ARG (thread);\n  sock = THREAD_FD (thread);\n  zvrf->rtadv.ra_read = NULL;\n  rtadv_event (zvrf, RTADV_READ, sock);\n  len = rtadv_recv_packet (sock, buf, BUFSIZ, &from, &ifindex, &hoplimit);\n  if (len < 0) \n    {\n      zlog_warn (\"router solicitation recv failed: %s.\", safe_strerror (errno));\n      return len;\n    }\n  rtadv_process_packet (buf, (unsigned)len, ifindex, hoplimit, zvrf->vrf_id);\n  return 0;\n}", "target": 1}
{"code": "void print_cfs_stats(struct seq_file *m, int cpu)\n{\n\tstruct cfs_rq *cfs_rq, *pos;\n\trcu_read_lock();\n\tfor_each_leaf_cfs_rq_safe(cpu_rq(cpu), cfs_rq, pos)\n\t\tprint_cfs_rq(m, cpu, cfs_rq);\n\trcu_read_unlock();\n}", "target": 1}
{"code": "\tSilenceMessage(const std::string& mask, const std::string& flags)\n\t\t: ClientProtocol::Message(\"SILENCE\")\n\t{\n\t\tPushParam(mask);\n\t\tPushParamRef(flags);\n\t}", "target": 1}
{"code": "  Status CalculateOutputIndex(OpKernelContext* context, int dimension,\n                              const vector<INDEX_TYPE>& parent_output_index,\n                              INDEX_TYPE output_index_multiplier,\n                              INDEX_TYPE output_size,\n                              vector<INDEX_TYPE>* result) {\n    const RowPartitionTensor row_partition_tensor =\n        GetRowPartitionTensor(context, dimension);\n    auto partition_type = GetRowPartitionTypeByDimension(dimension);\n    switch (partition_type) {\n      case RowPartitionType::VALUE_ROWIDS:\n        return CalculateOutputIndexValueRowID(\n            row_partition_tensor, parent_output_index, output_index_multiplier,\n            output_size, result);\n      case RowPartitionType::ROW_SPLITS:\n        if (row_partition_tensor.size() - 1 > parent_output_index.size()) {\n          return errors::InvalidArgument(\n              \"Row partition size is greater than output size: \",\n              row_partition_tensor.size() - 1, \" > \",\n              parent_output_index.size());\n        }\n        return CalculateOutputIndexRowSplit(\n            row_partition_tensor, parent_output_index, output_index_multiplier,\n            output_size, result);\n      default:\n        return errors::InvalidArgument(\n            \"Unsupported partition type:\",\n            RowPartitionTypeToString(partition_type));\n    }\n  }", "target": 0}
{"code": "void nego_process_negotiation_request(rdpNego* nego, wStream* s)\n{\n\tBYTE flags;\n\tUINT16 length;\n\tStream_Read_UINT8(s, flags);\n\tStream_Read_UINT16(s, length);\n\tStream_Read_UINT32(s, nego->RequestedProtocols);\n\tWLog_DBG(TAG, \"RDP_NEG_REQ: RequestedProtocol: 0x%08\" PRIX32 \"\", nego->RequestedProtocols);\n\tnego->state = NEGO_STATE_FINAL;\n}", "target": 1}
{"code": "static __init int efivar_ssdt_iter(efi_char16_t *name, efi_guid_t vendor,\n\t\t\t\t   unsigned long name_size, void *data)\n{\n\tstruct efivar_entry *entry;\n\tstruct list_head *list = data;\n\tchar utf8_name[EFIVAR_SSDT_NAME_MAX];\n\tint limit = min_t(unsigned long, EFIVAR_SSDT_NAME_MAX, name_size);\n\tucs2_as_utf8(utf8_name, name, limit - 1);\n\tif (strncmp(utf8_name, efivar_ssdt, limit) != 0)\n\t\treturn 0;\n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn 0;\n\tmemcpy(entry->var.VariableName, name, name_size);\n\tmemcpy(&entry->var.VendorGuid, &vendor, sizeof(efi_guid_t));\n\tefivar_entry_add(entry, list);\n\treturn 0;\n}", "target": 0}
{"code": "stl_update_connects_remove_1(stl_file *stl, int facet_num) {\n  int j;\n  if (stl->error) return;\n  j = ((stl->neighbors_start[facet_num].neighbor[0] == -1) +\n       (stl->neighbors_start[facet_num].neighbor[1] == -1) +\n       (stl->neighbors_start[facet_num].neighbor[2] == -1));\n  if(j == 0) {\t\t       \n    stl->stats.connected_facets_3_edge -= 1;\n  } else if(j == 1) {\t     \n    stl->stats.connected_facets_2_edge -= 1;\n  } else if(j == 2) {\t     \n    stl->stats.connected_facets_1_edge -= 1;\n  }\n}", "target": 1}
{"code": "static int snd_ctl_elem_info_user(struct snd_ctl_file *ctl,\n\t\t\t\t  struct snd_ctl_elem_info __user *_info)\n{\n\tstruct snd_ctl_elem_info info;\n\tint result;\n\tif (copy_from_user(&info, _info, sizeof(info)))\n\t\treturn -EFAULT;\n\tsnd_power_lock(ctl->card);\n\tresult = snd_power_wait(ctl->card, SNDRV_CTL_POWER_D0);\n\tif (result >= 0)\n\t\tresult = snd_ctl_elem_info(ctl, &info);\n\tsnd_power_unlock(ctl->card);\n\tif (result >= 0)\n\t\tif (copy_to_user(_info, &info, sizeof(info)))\n\t\t\treturn -EFAULT;\n\treturn result;\n}", "target": 0}
{"code": "_XimEncodeSavedPreeditValue(\n    Xic\t\t\t  ic,\n    XIMResourceList\t  res,\n    XPointer\t\t  value)\n{\n    int\t\t\t  list_ret;\n    XFontStruct\t\t**struct_list;\n    char\t\t**name_list;\n    char\t\t *tmp;\n    int\t\t\t  len;\n    register int\t  i;\n    if (res->xrm_name == XrmStringToQuark(XNFontSet)) {\n\tif (!value)\n\t    return False;\n\tif (ic->private.proto.preedit_font)\n\t    Xfree(ic->private.proto.preedit_font);\n\tlist_ret = XFontsOfFontSet((XFontSet)value,\n\t\t\t\t\t\t&struct_list, &name_list);\n\tfor(i = 0, len = 0; i < list_ret; i++) {\n\t    len += (strlen(name_list[i]) + sizeof(char));\n\t}\n\tif(!(tmp = Xmalloc(len + 1))) {\n\t    ic->private.proto.preedit_font = NULL;\n\t    return False;\n\t}\n\ttmp[0] = '\\0';\n\tfor(i = 0; i < list_ret; i++) {\n\t    strcat(tmp, name_list[i]);\n\t    strcat(tmp, \",\");\n\t}\n\ttmp[len - 1] = 0;\n\tic->private.proto.preedit_font        = tmp;\n\tic->private.proto.preedit_font_length = len - 1;\n    }\n    return True;\n}", "target": 0}
{"code": "xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) {\n    int len = 0, l;\n    int c;\n    int count = 0;\n    const xmlChar *end; \n#ifdef DEBUG\n    nbParseNCNameComplex++;\n#endif\n    GROW;\n    end = ctxt->input->cur;\n    c = CUR_CHAR(l);\n    if ((c == ' ') || (c == '>') || (c == '/') || \n\t(!xmlIsNameStartChar(ctxt, c) || (c == ':'))) {\n\treturn(NULL);\n    }\n    while ((c != ' ') && (c != '>') && (c != '/') && \n\t   (xmlIsNameChar(ctxt, c) && (c != ':'))) {\n\tif (count++ > XML_PARSER_CHUNK_SIZE) {\n            if ((len > XML_MAX_NAME_LENGTH) &&\n                ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n                xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, \"NCName\");\n                return(NULL);\n            }\n\t    count = 0;\n\t    GROW;\n            if (ctxt->instate == XML_PARSER_EOF)\n                return(NULL);\n\t}\n\tlen += l;\n\tNEXTL(l);\n\tend = ctxt->input->cur;\n\tc = CUR_CHAR(l);\n\tif (c == 0) {\n\t    count = 0;\n\t    ctxt->input->cur -= l;\n\t    GROW;\n\t    ctxt->input->cur += l;\n            if (ctxt->instate == XML_PARSER_EOF)\n                return(NULL);\n\t    end = ctxt->input->cur;\n\t    c = CUR_CHAR(l);\n\t}\n    }\n    if ((len > XML_MAX_NAME_LENGTH) &&\n        ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n        xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, \"NCName\");\n        return(NULL);\n    }\n    return(xmlDictLookup(ctxt->dict, end - len, len));\n}", "target": 1}
{"code": "make_valid_utf8 (string & str)\n{\n  const char *pos;\n  if (!g_utf8_validate (str.c_str(), -1, &pos)) {\n    PTRACE (4, \"Ekiga\\tTrimming invalid UTF-8 string: \" << str.c_str());\n    str = str.substr (0, pos - str.c_str()).append (\"...\");\n  }\n}", "target": 0}
{"code": "yang_check_choice(struct lys_module *module, struct lys_node_choice *choice, struct lys_node **child,\n                  int options, struct unres_schema *unres)\n{\n    char *value;\n    if (yang_check_iffeatures(module, NULL, choice, CHOICE_KEYWORD, unres)) {\n        free(choice->dflt);\n        choice->dflt = NULL;\n        goto error;\n    }\n    if (yang_check_nodes(module, (struct lys_node *)choice, *child, options, unres)) {\n        *child = NULL;\n        free(choice->dflt);\n        choice->dflt = NULL;\n        goto error;\n    }\n    *child = NULL;\n    if (choice->dflt) {\n        value = (char *)choice->dflt;\n        choice->dflt = NULL;\n        if (unres_schema_add_str(module, unres, choice, UNRES_CHOICE_DFLT, value) == -1) {\n            free(value);\n            goto error;\n        }\n        free(value);\n    }\n    if (choice->when && yang_check_ext_instance(module, &choice->when->ext, choice->when->ext_size, choice->when, unres)) {\n        goto error;\n    }\n    if (!(module->ctx->models.flags & LY_CTX_TRUSTED) && choice->when) {\n        if (options & LYS_PARSE_OPT_INGRP) {\n            if (lyxp_node_check_syntax((struct lys_node *)choice)) {\n                goto error;\n            }\n        } else {\n            if (unres_schema_add_node(module, unres, choice, UNRES_XPATH, NULL) == -1) {\n                goto error;\n            }\n        }\n    }\n    return EXIT_SUCCESS;\nerror:\n    return EXIT_FAILURE;\n}", "target": 0}
{"code": "static int complete_emulated_mmio(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *run = vcpu->run;\n\tstruct kvm_mmio_fragment *frag;\n\tunsigned len;\n\tBUG_ON(!vcpu->mmio_needed);\n\tfrag = &vcpu->mmio_fragments[vcpu->mmio_cur_fragment];\n\tlen = min(8u, frag->len);\n\tif (!vcpu->mmio_is_write)\n\t\tmemcpy(frag->data, run->mmio.data, len);\n\tif (frag->len <= 8) {\n\t\tfrag++;\n\t\tvcpu->mmio_cur_fragment++;\n\t} else {\n\t\tfrag->data += len;\n\t\tfrag->gpa += len;\n\t\tfrag->len -= len;\n\t}\n\tif (vcpu->mmio_cur_fragment == vcpu->mmio_nr_fragments) {\n\t\tvcpu->mmio_needed = 0;\n\t\tif (vcpu->mmio_is_write)\n\t\t\treturn 1;\n\t\tvcpu->mmio_read_completed = 1;\n\t\treturn complete_emulated_io(vcpu);\n\t}\n\trun->exit_reason = KVM_EXIT_MMIO;\n\trun->mmio.phys_addr = frag->gpa;\n\tif (vcpu->mmio_is_write)\n\t\tmemcpy(run->mmio.data, frag->data, min(8u, frag->len));\n\trun->mmio.len = min(8u, frag->len);\n\trun->mmio.is_write = vcpu->mmio_is_write;\n\tvcpu->arch.complete_userspace_io = complete_emulated_mmio;\n\treturn 0;\n}", "target": 0}
{"code": "bool inode_capable(const struct inode *inode, int cap)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\treturn ns_capable(ns, cap) && kuid_has_mapping(ns, inode->i_uid);\n}", "target": 1}
{"code": "__nlmsg_put(struct sk_buff *skb, u32 pid, u32 seq, int type, int len, int flags)\n{\n\tstruct nlmsghdr *nlh;\n\tint size = NLMSG_LENGTH(len);\n\tnlh = (struct nlmsghdr*)skb_put(skb, NLMSG_ALIGN(size));\n\tnlh->nlmsg_type = type;\n\tnlh->nlmsg_len = size;\n\tnlh->nlmsg_flags = flags;\n\tnlh->nlmsg_pid = pid;\n\tnlh->nlmsg_seq = seq;\n\treturn nlh;\n}", "target": 1}
{"code": "_gnutls_ecc_ansi_x963_export (gnutls_ecc_curve_t curve, bigint_t x, bigint_t y,\n                              gnutls_datum_t * out)\n{\n  int numlen = gnutls_ecc_curve_get_size (curve);\n  int byte_size, ret;\n  size_t size;\n  if (numlen == 0)\n    return gnutls_assert_val (GNUTLS_E_INVALID_REQUEST);\n  out->size = 1 + 2 * numlen;\n  out->data = gnutls_malloc (out->size);\n  if (out->data == NULL)\n    return gnutls_assert_val (GNUTLS_E_MEMORY_ERROR);\n  memset (out->data, 0, out->size);\n  out->data[0] = 0x04;\n  byte_size = (_gnutls_mpi_get_nbits (x) + 7) / 8;\n  size = out->size - (1 + (numlen - byte_size));\n  ret = _gnutls_mpi_print (x, &out->data[1 + (numlen - byte_size)], &size);\n  if (ret < 0)\n    return gnutls_assert_val (ret);\n  byte_size = (_gnutls_mpi_get_nbits (y) + 7) / 8;\n  size = out->size - (1 + (numlen + numlen - byte_size));\n  ret =\n    _gnutls_mpi_print (y, &out->data[1 + numlen + numlen - byte_size], &size);\n  if (ret < 0)\n    return gnutls_assert_val (ret);\n  return 0;\n}", "target": 1}
{"code": "static int vmx_vm_has_apicv(struct kvm *kvm)\n{\n\treturn enable_apicv && irqchip_in_kernel(kvm);\n}", "target": 0}
{"code": "static void openssl_thread_setup(void)\n{\n    int i;\n    if (CRYPTO_get_locking_callback() != NULL) {\n        red_dump_openssl_errors();\n        return;\n    }\n    lock_cs = (pthread_mutex_t*) OPENSSL_malloc(CRYPTO_num_locks() * sizeof(pthread_mutex_t));\n    for (i = 0; i < CRYPTO_num_locks(); i++) {\n        pthread_mutex_init(&(lock_cs[i]), NULL);\n    }\n    CRYPTO_THREADID_set_callback(pthreads_thread_id);\n    CRYPTO_set_locking_callback(pthreads_locking_callback);\n}", "target": 0}
{"code": "int iwch_cxgb3_ofld_send(struct t3cdev *tdev, struct sk_buff *skb)\n{\n\tint\terror = 0;\n\tstruct cxio_rdev *rdev;\n\trdev = (struct cxio_rdev *)tdev->ulp;\n\tif (cxio_fatal_error(rdev)) {\n\t\tkfree_skb(skb);\n\t\treturn -EIO;\n\t}\n\terror = cxgb3_ofld_send(tdev, skb);\n\tif (error < 0)\n\t\tkfree_skb(skb);\n\treturn error;\n}", "target": 1}
{"code": "static int ims_pcu_parse_cdc_data(struct usb_interface *intf, struct ims_pcu *pcu)\n{\n\tconst struct usb_cdc_union_desc *union_desc;\n\tstruct usb_host_interface *alt;\n\tunion_desc = ims_pcu_get_cdc_union_desc(intf);\n\tif (!union_desc)\n\t\treturn -EINVAL;\n\tpcu->ctrl_intf = usb_ifnum_to_if(pcu->udev,\n\t\t\t\t\t union_desc->bMasterInterface0);\n\tif (!pcu->ctrl_intf)\n\t\treturn -EINVAL;\n\talt = pcu->ctrl_intf->cur_altsetting;\n\tpcu->ep_ctrl = &alt->endpoint[0].desc;\n\tpcu->max_ctrl_size = usb_endpoint_maxp(pcu->ep_ctrl);\n\tpcu->data_intf = usb_ifnum_to_if(pcu->udev,\n\t\t\t\t\t union_desc->bSlaveInterface0);\n\tif (!pcu->data_intf)\n\t\treturn -EINVAL;\n\talt = pcu->data_intf->cur_altsetting;\n\tif (alt->desc.bNumEndpoints != 2) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Incorrect number of endpoints on data interface (%d)\\n\",\n\t\t\talt->desc.bNumEndpoints);\n\t\treturn -EINVAL;\n\t}\n\tpcu->ep_out = &alt->endpoint[0].desc;\n\tif (!usb_endpoint_is_bulk_out(pcu->ep_out)) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"First endpoint on data interface is not BULK OUT\\n\");\n\t\treturn -EINVAL;\n\t}\n\tpcu->max_out_size = usb_endpoint_maxp(pcu->ep_out);\n\tif (pcu->max_out_size < 8) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Max OUT packet size is too small (%zd)\\n\",\n\t\t\tpcu->max_out_size);\n\t\treturn -EINVAL;\n\t}\n\tpcu->ep_in = &alt->endpoint[1].desc;\n\tif (!usb_endpoint_is_bulk_in(pcu->ep_in)) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Second endpoint on data interface is not BULK IN\\n\");\n\t\treturn -EINVAL;\n\t}\n\tpcu->max_in_size = usb_endpoint_maxp(pcu->ep_in);\n\tif (pcu->max_in_size < 8) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Max IN packet size is too small (%zd)\\n\",\n\t\t\tpcu->max_in_size);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;", "target": 0}
{"code": "static int ep_loop_check_proc(void *priv, void *cookie, int call_nests)\n{\n\tint error = 0;\n\tstruct file *file = priv;\n\tstruct eventpoll *ep = file->private_data;\n\tstruct eventpoll *ep_tovisit;\n\tstruct rb_node *rbp;\n\tstruct epitem *epi;\n\tmutex_lock_nested(&ep->mtx, call_nests + 1);\n\tep->visited = 1;\n\tlist_add(&ep->visited_list_link, &visited_list);\n\tfor (rbp = rb_first_cached(&ep->rbr); rbp; rbp = rb_next(rbp)) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\t\tif (unlikely(is_file_epoll(epi->ffd.file))) {\n\t\t\tep_tovisit = epi->ffd.file->private_data;\n\t\t\tif (ep_tovisit->visited)\n\t\t\t\tcontinue;\n\t\t\terror = ep_call_nested(&poll_loop_ncalls,\n\t\t\t\t\tep_loop_check_proc, epi->ffd.file,\n\t\t\t\t\tep_tovisit, current);\n\t\t\tif (error != 0)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (list_empty(&epi->ffd.file->f_tfile_llink))\n\t\t\t\tlist_add(&epi->ffd.file->f_tfile_llink,\n\t\t\t\t\t &tfile_check_list);\n\t\t}\n\t}\n\tmutex_unlock(&ep->mtx);\n\treturn error;\n}", "target": 1}
{"code": "static int ext4_fill_flex_info(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_group_desc *gdp = NULL;\n\text4_group_t flex_group_count;\n\text4_group_t flex_group;\n\tint groups_per_flex = 0;\n\tsize_t size;\n\tint i;\n\tsbi->s_log_groups_per_flex = sbi->s_es->s_log_groups_per_flex;\n\tgroups_per_flex = 1 << sbi->s_log_groups_per_flex;\n\tif (groups_per_flex < 2) {\n\t\tsbi->s_log_groups_per_flex = 0;\n\t\treturn 1;\n\t}\n\tflex_group_count = ((sbi->s_groups_count + groups_per_flex - 1) +\n\t\t\t((le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) + 1) <<\n\t\t\t      EXT4_DESC_PER_BLOCK_BITS(sb))) / groups_per_flex;\n\tsize = flex_group_count * sizeof(struct flex_groups);\n\tsbi->s_flex_groups = ext4_kvzalloc(size, GFP_KERNEL);\n\tif (sbi->s_flex_groups == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory for %u flex groups\",\n\t\t\t flex_group_count);\n\t\tgoto failed;\n\t}\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\t\tflex_group = ext4_flex_group(sbi, i);\n\t\tatomic_add(ext4_free_inodes_count(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].free_inodes);\n\t\tatomic_add(ext4_free_group_clusters(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].free_clusters);\n\t\tatomic_add(ext4_used_dirs_count(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].used_dirs);\n\t}\n\treturn 1;\nfailed:\n\treturn 0;\n}", "target": 1}
{"code": "display_debug_links (struct dwarf_section *  section,\n\t\t     void *                  file ATTRIBUTE_UNUSED)\n{\n  const unsigned char * filename;\n  unsigned int          filelen;\n  introduce (section, false);\n  filename =  section->start;\n  filelen = strnlen ((const char *) filename, section->size);\n  if (filelen == section->size)\n    {\n      warn (_(\"The debuglink filename is corrupt/missing\\n\"));\n      return 0;\n    }\n  printf (_(\"  Separate debug info file: %s\\n\"), filename);\n  if (startswith (section->name, \".gnu_debuglink\"))\n    {\n      unsigned int          crc32;\n      unsigned int          crc_offset;\n      crc_offset = filelen + 1;\n      crc_offset = (crc_offset + 3) & ~3;\n      if (crc_offset + 4 > section->size)\n\t{\n\t  warn (_(\"CRC offset missing/truncated\\n\"));\n\t  return 0;\n\t}\n      crc32 = byte_get (filename + crc_offset, 4);\n      printf (_(\"  CRC value: %#x\\n\"), crc32);\n      if (crc_offset + 4 < section->size)\n\t{\n\t  warn (_(\"There are %#lx extraneous bytes at the end of the section\\n\"),\n\t\t(long)(section->size - (crc_offset + 4)));\n\t  return 0;\n\t}\n    }\n  else \n    {\n      const unsigned char * build_id = section->start + filelen + 1;\n      bfd_size_type         build_id_len = section->size - (filelen + 1);\n      bfd_size_type         printed;\n      if (build_id_len < 0x14)\n\t{\n\t  warn (_(\"Build-ID is too short (%#lx bytes)\\n\"), (long) build_id_len);\n\t  return 0;\n\t}\n      printed = printf (_(\"  Build-ID (%#lx bytes):\"), (long) build_id_len);\n      display_data (printed, build_id, build_id_len);\n      putchar ('\\n');\n    }\n  putchar ('\\n');\n  return 1;\n}", "target": 0}
{"code": "static int em_loop(struct x86_emulate_ctxt *ctxt)\n{\n\tregister_address_increment(ctxt, reg_rmw(ctxt, VCPU_REGS_RCX), -1);\n\tif ((address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) != 0) &&\n\t    (ctxt->b == 0xe2 || test_cc(ctxt->b ^ 0x5, ctxt->eflags)))\n\t\tjmp_rel(ctxt, ctxt->src.val);\n\treturn X86EMUL_CONTINUE;\n}", "target": 1}
{"code": "static int do_new_mount(struct path *path, const char *fstype, int flags,\n\t\t\tint mnt_flags, const char *name, void *data)\n{\n\tstruct file_system_type *type;\n\tstruct user_namespace *user_ns = current->nsproxy->mnt_ns->user_ns;\n\tstruct vfsmount *mnt;\n\tint err;\n\tif (!fstype)\n\t\treturn -EINVAL;\n\ttype = get_fs_type(fstype);\n\tif (!type)\n\t\treturn -ENODEV;\n\tif (user_ns != &init_user_ns) {\n\t\tif (!(type->fs_flags & FS_USERNS_MOUNT)) {\n\t\t\tput_filesystem(type);\n\t\t\treturn -EPERM;\n\t\t}\n\t\tif (!(type->fs_flags & FS_USERNS_DEV_MOUNT)) {\n\t\t\tflags |= MS_NODEV;\n\t\t\tmnt_flags |= MNT_NODEV;\n\t\t}\n\t}\n\tmnt = vfs_kern_mount(type, flags, name, data);\n\tif (!IS_ERR(mnt) && (type->fs_flags & FS_HAS_SUBTYPE) &&\n\t    !mnt->mnt_sb->s_subtype)\n\t\tmnt = fs_set_subtype(mnt, fstype);\n\tput_filesystem(type);\n\tif (IS_ERR(mnt))\n\t\treturn PTR_ERR(mnt);\n\terr = do_add_mount(real_mount(mnt), path, mnt_flags);\n\tif (err)\n\t\tmntput(mnt);\n\treturn err;\n}", "target": 1}
{"code": "static int vt_disallocate(unsigned int vc_num)\n{\n\tstruct vc_data *vc = NULL;\n\tint ret = 0;\n\tconsole_lock();\n\tif (vt_busy(vc_num))\n\t\tret = -EBUSY;\n\telse if (vc_num)\n\t\tvc = vc_deallocate(vc_num);\n\tconsole_unlock();\n\tif (vc && vc_num >= MIN_NR_CONSOLES) {\n\t\ttty_port_destroy(&vc->port);\n\t\tkfree(vc);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "nvkm_vmm_put_locked(struct nvkm_vmm *vmm, struct nvkm_vma *vma)\n{\n\tconst struct nvkm_vmm_page *page = vmm->func->page;\n\tstruct nvkm_vma *next = vma;\n\tBUG_ON(vma->part);\n\tif (vma->mapref || !vma->sparse) {\n\t\tdo {\n\t\t\tconst bool map = next->memory != NULL;\n\t\t\tconst u8  refd = next->refd;\n\t\t\tconst u64 addr = next->addr;\n\t\t\tu64 size = next->size;\n\t\t\twhile ((next = node(next, next)) && next->part &&\n\t\t\t       (next->memory != NULL) == map &&\n\t\t\t       (next->refd == refd))\n\t\t\t\tsize += next->size;\n\t\t\tif (map) {\n\t\t\t\tnvkm_vmm_ptes_unmap_put(vmm, &page[refd], addr,\n\t\t\t\t\t\t\tsize, vma->sparse);\n\t\t\t} else\n\t\t\tif (refd != NVKM_VMA_PAGE_NONE) {\n\t\t\t\tnvkm_vmm_ptes_put(vmm, &page[refd], addr, size);\n\t\t\t}\n\t\t} while (next && next->part);\n\t}\n\tnext = vma;\n\tdo {\n\t\tif (next->memory)\n\t\t\tnvkm_vmm_unmap_region(vmm, next);\n\t} while ((next = node(vma, next)) && next->part);\n\tif (vma->sparse && !vma->mapref) {\n\t\tnvkm_vmm_ptes_sparse_put(vmm, &page[vma->refd], vma->addr, vma->size);\n\t} else\n\tif (vma->sparse) {\n\t\tnvkm_vmm_ptes_sparse(vmm, vma->addr, vma->size, false);\n\t}\n\trb_erase(&vma->tree, &vmm->root);\n\tvma->page = NVKM_VMA_PAGE_NONE;\n\tvma->refd = NVKM_VMA_PAGE_NONE;\n\tvma->used = false;\n\tvma->user = false;\n\tnvkm_vmm_put_region(vmm, vma);\n}", "target": 1}
{"code": "lldpd_alloc_mgmt(int family, void *addrptr, size_t addrsize, u_int32_t iface)\n{\n\tstruct lldpd_mgmt *mgmt;\n\tlog_debug(\"alloc\", \"allocate a new management address (family: %d)\", family);\n\tif (family <= LLDPD_AF_UNSPEC || family >= LLDPD_AF_LAST) {\n\t\terrno = EAFNOSUPPORT;\n\t\treturn NULL;\n\t}\n\tif (addrsize > LLDPD_MGMT_MAXADDRSIZE) {\n\t\terrno = EOVERFLOW;\n\t\treturn NULL;\n\t}\n\tmgmt = calloc(1, sizeof(struct lldpd_mgmt));\n\tif (mgmt == NULL) {\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\tmgmt->m_family = family;\n\tassert(addrsize <= LLDPD_MGMT_MAXADDRSIZE);\n\tmemcpy(&mgmt->m_addr, addrptr, addrsize);\n\tmgmt->m_addrsize = addrsize;\n\tmgmt->m_iface = iface;\n\treturn mgmt;\n}", "target": 1}
{"code": "gopherHTMLFooter(StoreEntry * e)\n{\n    storeAppendPrintf(e, \"<HR noshade size=\\\"1px\\\">\\n\");\n    storeAppendPrintf(e, \"<ADDRESS>\\n\");\n    storeAppendPrintf(e, \"Generated %s by %s (%s)\\n\",\n                      Time::FormatRfc1123(squid_curtime),\n                      getMyHostname(),\n                      visible_appname_string);\n    storeAppendPrintf(e, \"</ADDRESS></BODY></HTML>\\n\");\n}", "target": 1}
{"code": "static int packet_snd_vnet_gso(struct sk_buff *skb,\n\t\t\t       struct virtio_net_hdr *vnet_hdr)\n{\n\tif (vnet_hdr->flags & VIRTIO_NET_HDR_F_NEEDS_CSUM) {\n\t\tu16 s = __virtio16_to_cpu(vio_le(), vnet_hdr->csum_start);\n\t\tu16 o = __virtio16_to_cpu(vio_le(), vnet_hdr->csum_offset);\n\t\tif (!skb_partial_csum_set(skb, s, o))\n\t\t\treturn -EINVAL;\n\t}\n\tskb_shinfo(skb)->gso_size =\n\t\t__virtio16_to_cpu(vio_le(), vnet_hdr->gso_size);\n\tskb_shinfo(skb)->gso_type = vnet_hdr->gso_type;\n\tskb_shinfo(skb)->gso_type |= SKB_GSO_DODGY;\n\tskb_shinfo(skb)->gso_segs = 0;\n\treturn 0;\n}", "target": 0}
{"code": "static __init int efivar_ssdt_load(void)\n{\n\tLIST_HEAD(entries);\n\tstruct efivar_entry *entry, *aux;\n\tunsigned long size;\n\tvoid *data;\n\tint ret;\n\tret = efivar_init(efivar_ssdt_iter, &entries, true, &entries);\n\tlist_for_each_entry_safe(entry, aux, &entries, list) {\n\t\tpr_info(\"loading SSDT from variable %s-%pUl\\n\", efivar_ssdt,\n\t\t\t&entry->var.VendorGuid);\n\t\tlist_del(&entry->list);\n\t\tret = efivar_entry_size(entry, &size);\n\t\tif (ret) {\n\t\t\tpr_err(\"failed to get var size\\n\");\n\t\t\tgoto free_entry;\n\t\t}\n\t\tdata = kmalloc(size, GFP_KERNEL);\n\t\tif (!data) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_entry;\n\t\t}\n\t\tret = efivar_entry_get(entry, NULL, &size, data);\n\t\tif (ret) {\n\t\t\tpr_err(\"failed to get var data\\n\");\n\t\t\tgoto free_data;\n\t\t}\n\t\tret = acpi_load_table(data);\n\t\tif (ret) {\n\t\t\tpr_err(\"failed to load table: %d\\n\", ret);\n\t\t\tgoto free_data;\n\t\t}\n\t\tgoto free_entry;\nfree_data:\n\t\tkfree(data);\nfree_entry:\n\t\tkfree(entry);\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "static void do_viewlog(HttpRequest req, HttpResponse res) {\n        if (is_readonly(req)) {\n                send_error(req, res, SC_FORBIDDEN, \"You do not have sufficient privileges to access this page\");\n                return;\n        }\n        do_head(res, \"_viewlog\", \"View log\", 100);\n        if ((Run.flags & Run_Log) && ! (Run.flags & Run_UseSyslog)) {\n                FILE *f = fopen(Run.files.log, \"r\");\n                if (f) {\n                        size_t n;\n                        char buf[512];\n                        StringBuffer_append(res->outputbuffer, \"<br><p><form><textarea cols=120 rows=30 readonly>\");\n                        while ((n = fread(buf, sizeof(char), sizeof(buf) - 1, f)) > 0) {\n                                buf[n] = 0;\n                                StringBuffer_append(res->outputbuffer, \"%s\", buf);\n                        }\n                        fclose(f);\n                        StringBuffer_append(res->outputbuffer, \"</textarea></form>\");\n                } else {\n                        StringBuffer_append(res->outputbuffer, \"Error opening logfile: %s\", STRERROR);\n                }\n        } else {\n                StringBuffer_append(res->outputbuffer,\n                                    \"<b>Cannot view logfile:</b><br>\");\n                if (! (Run.flags & Run_Log))\n                        StringBuffer_append(res->outputbuffer, \"Monit was started without logging\");\n                else\n                        StringBuffer_append(res->outputbuffer, \"Monit uses syslog\");\n        }\n        do_foot(res);\n}", "target": 1}
{"code": "void *address_space_map(AddressSpace *as,\n                        hwaddr addr,\n                        hwaddr *plen,\n                        bool is_write)\n{\n    hwaddr len = *plen;\n    hwaddr done = 0;\n    hwaddr l, xlat, base;\n    MemoryRegion *mr, *this_mr;\n    ram_addr_t raddr;\n    if (len == 0) {\n        return NULL;\n    }\n    l = len;\n    rcu_read_lock();\n    mr = address_space_translate(as, addr, &xlat, &l, is_write);\n    if (!memory_access_is_direct(mr, is_write)) {\n        if (atomic_xchg(&bounce.in_use, true)) {\n            rcu_read_unlock();\n            return NULL;\n        }\n        l = MIN(l, TARGET_PAGE_SIZE);\n        bounce.buffer = qemu_memalign(TARGET_PAGE_SIZE, l);\n        bounce.addr = addr;\n        bounce.len = l;\n        memory_region_ref(mr);\n        bounce.mr = mr;\n        if (!is_write) {\n            address_space_read(as, addr, MEMTXATTRS_UNSPECIFIED,\n                               bounce.buffer, l);\n        }\n        rcu_read_unlock();\n        *plen = l;\n        return bounce.buffer;\n    }\n    base = xlat;\n    raddr = memory_region_get_ram_addr(mr);\n    for (;;) {\n        len -= l;\n        addr += l;\n        done += l;\n        if (len == 0) {\n            break;\n        }\n        l = len;\n        this_mr = address_space_translate(as, addr, &xlat, &l, is_write);\n        if (this_mr != mr || xlat != base + done) {\n            break;\n        }\n    }\n    memory_region_ref(mr);\n    rcu_read_unlock();\n    *plen = done;\n    return qemu_ram_ptr_length(raddr + base, plen);\n}", "target": 0}
{"code": "TEST(EqOp, Equality1) {\n    BSONObj operand = BSON(\"a\" << 5 << \"b\" << 5 << \"c\" << 4);\n    EqualityMatchExpression eq1(\"a\", operand[\"a\"]);\n    EqualityMatchExpression eq2(\"a\", operand[\"b\"]);\n    EqualityMatchExpression eq3(\"c\", operand[\"c\"]);\n    ASSERT(eq1.equivalent(&eq1));\n    ASSERT(eq1.equivalent(&eq2));\n    ASSERT(!eq1.equivalent(&eq3));\n}", "target": 0}
{"code": "void ImageWriteJPEG(\n      Image const& image,\n      String const& filename,\n      dip::uint jpegLevel\n) {\n   DIP_THROW_IF( !image.IsForged(), E::IMAGE_NOT_FORGED );\n   DIP_THROW_IF( image.Dimensionality() != 2, E::DIMENSIONALITY_NOT_SUPPORTED );\n   jpegLevel = clamp< dip::uint >( jpegLevel, 1, 100 );\n   JpegOutput jpeg( filename );\n   int nchan = static_cast< int >( image.TensorElements() );\n   jpeg.cinfo().image_width = static_cast< JDIMENSION >( image.Size( 0 ));\n   jpeg.cinfo().image_height = static_cast< JDIMENSION >( image.Size( 1 ));\n   jpeg.cinfo().input_components = nchan;\n   jpeg.cinfo().in_color_space = nchan > 1 ? JCS_RGB : JCS_GRAYSCALE;\n   jpeg_set_defaults( jpeg.cinfoptr() );\n   jpeg_set_quality( jpeg.cinfoptr(), static_cast< int >( jpegLevel ), FALSE );\n   jpeg.cinfo().density_unit = 2; \n   jpeg.cinfo().X_density = static_cast< UINT16 >( 0.01 / image.PixelSize( 0 ).RemovePrefix().magnitude ); \n   jpeg.cinfo().Y_density = static_cast< UINT16 >( 0.01 / image.PixelSize( 1 ).RemovePrefix().magnitude );\n   Image image_u8 = image.QuickCopy();\n   image_u8.Convert( DT_UINT8 );\n   jpeg_start_compress( jpeg.cinfoptr(), TRUE );\n   std::vector< JSAMPLE > buffer( image.Size( 0 ) * static_cast< dip::uint >( nchan ));\n   dip::uint8* imagedata = static_cast< dip::uint8* >( image_u8.Origin() );\n   auto stride = image_u8.Strides();\n   auto tStride = image_u8.TensorStride();\n   for( dip::uint ii = 0; ii < image.Size( 1 ); ++ii ) {\n      JSAMPLE* outdata = buffer.data();\n      dip::uint8* indata = imagedata;\n      for( dip::uint jj = 0; jj < image.Size( 0 ); ++jj ) {\n         for( int kk = 0; kk < nchan; ++kk ) {\n            *outdata = *( indata + kk * tStride );\n            ++outdata;\n         }\n         indata += stride[ 0 ];\n      }\n      outdata = buffer.data();\n      jpeg_write_scanlines( jpeg.cinfoptr(), &outdata, 1 );\n      imagedata += stride[ 1 ];\n   }\n   jpeg_finish_compress( jpeg.cinfoptr());\n}", "target": 1}
{"code": "MagickExport ChannelPerceptualHash *GetImagePerceptualHash(const Image *image,\n  ExceptionInfo *exception)\n{\n  ChannelPerceptualHash\n    *perceptual_hash;\n  char\n    *colorspaces,\n    *p,\n    *q;\n  const char\n    *artifact;\n  MagickBooleanType\n    status;\n  ssize_t\n    i;\n  perceptual_hash=(ChannelPerceptualHash *) AcquireQuantumMemory(\n    MaxPixelChannels+1UL,sizeof(*perceptual_hash));\n  if (perceptual_hash == (ChannelPerceptualHash *) NULL)\n    return((ChannelPerceptualHash *) NULL);\n  artifact=GetImageArtifact(image,\"phash:colorspaces\");\n  if (artifact != NULL)\n    colorspaces=AcquireString(artifact);\n  else\n    colorspaces=AcquireString(\"sRGB,HCLp\");\n  perceptual_hash[0].number_colorspaces=0;\n  perceptual_hash[0].number_channels=0;\n  q=colorspaces;\n  for (i=0; (p=StringToken(\",\",&q)) != (char *) NULL; i++)\n  {\n    ChannelMoments\n      *moments;\n    Image\n      *hash_image;\n    size_t\n      j;\n    ssize_t\n      channel,\n      colorspace;\n    if (i >= MaximumNumberOfPerceptualColorspaces)\n      break;\n    colorspace=ParseCommandOption(MagickColorspaceOptions,MagickFalse,p);\n    if (colorspace < 0)\n      break;\n    perceptual_hash[0].colorspace[i]=(ColorspaceType) colorspace;\n    hash_image=BlurImage(image,0.0,1.0,exception);\n    if (hash_image == (Image *) NULL)\n      break;\n    hash_image->depth=8;\n    status=TransformImageColorspace(hash_image,(ColorspaceType) colorspace,\n      exception);\n    if (status == MagickFalse)\n      break;\n    moments=GetImageMoments(hash_image,exception);\n    perceptual_hash[0].number_colorspaces++;\n    perceptual_hash[0].number_channels+=GetImageChannels(hash_image);\n    hash_image=DestroyImage(hash_image);\n    if (moments == (ChannelMoments *) NULL)\n      break;\n    for (channel=0; channel <= MaxPixelChannels; channel++)\n      for (j=0; j < MaximumNumberOfImageMoments; j++)\n        perceptual_hash[channel].phash[i][j]=\n          (-MagickLog10(moments[channel].invariant[j]));\n    moments=(ChannelMoments *) RelinquishMagickMemory(moments);\n  }\n  colorspaces=DestroyString(colorspaces);\n  return(perceptual_hash);\n}", "target": 0}
{"code": "isdn_net_newslave(char *parm)\n{\n\tchar *p = strchr(parm, ',');\n\tisdn_net_dev *n;\n\tchar newname[10];\n\tif (p) {\n\t\tif (!strlen(p + 1))\n\t\t\treturn NULL;\n\t\tstrcpy(newname, p + 1);\n\t\t*p = 0;\n\t\tif (!(n = isdn_net_findif(parm)))\n\t\t\treturn NULL;\n\t\tif (n->local->master)\n\t\t\treturn NULL;\n\t\tif (isdn_net_device_started(n)) \n\t\t\treturn NULL;\n\t\treturn (isdn_net_new(newname, n->dev));\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "archive_write_disk_set_acls(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode)\n{\n\tint\t\tret = ARCHIVE_OK;\n\t(void)mode;\t\n\tif ((archive_acl_types(abstract_acl)\n\t    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {\n\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_POSIX1E, \"posix1e\");\n\t\treturn (ret);\n\t}\n#if ARCHIVE_ACL_SUNOS_NFS4\n\telse if ((archive_acl_types(abstract_acl) &\n\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {\n\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4, \"nfs4\");\n\t}\n#endif\n\treturn (ret);\n}", "target": 1}
{"code": "xfs_file_splice_write(\n\tstruct pipe_inode_info\t*pipe,\n\tstruct file\t\t*outfilp,\n\tloff_t\t\t\t*ppos,\n\tsize_t\t\t\tcount,\n\tunsigned int\t\tflags)\n{\n\tstruct inode\t\t*inode = outfilp->f_mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tint\t\t\tioflags = 0;\n\tssize_t\t\t\tret;\n\tXFS_STATS_INC(xs_write_calls);\n\tif (outfilp->f_mode & FMODE_NOCMTIME)\n\t\tioflags |= IO_INVIS;\n\tif (XFS_FORCED_SHUTDOWN(ip->i_mount))\n\t\treturn -EIO;\n\txfs_ilock(ip, XFS_IOLOCK_EXCL);\n\ttrace_xfs_file_splice_write(ip, count, *ppos, ioflags);\n\tret = generic_file_splice_write(pipe, outfilp, ppos, count, flags);\n\tif (ret > 0)\n\t\tXFS_STATS_ADD(xs_write_bytes, ret);\n\txfs_iunlock(ip, XFS_IOLOCK_EXCL);\n\treturn ret;\n}", "target": 1}
{"code": "static s16 swf_get_s16(SWFReader *read)\n{\n\ts16 val;\n\tu8 v1;\n\tv1 = swf_read_int(read, 8);\n\tval = swf_read_sint(read, 8);\n\tval = (val<<8)&0xFF00;\n\tval |= (v1&0xFF);\n\treturn val;\n}", "target": 1}
{"code": "static inline key_ref_t __key_update(key_ref_t key_ref,\n\t\t\t\t     struct key_preparsed_payload *prep)\n{\n\tstruct key *key = key_ref_to_ptr(key_ref);\n\tint ret;\n\tret = key_permission(key_ref, KEY_NEED_WRITE);\n\tif (ret < 0)\n\t\tgoto error;\n\tret = -EEXIST;\n\tif (!key->type->update)\n\t\tgoto error;\n\tdown_write(&key->sem);\n\tret = key->type->update(key, prep);\n\tif (ret == 0)\n\t\tclear_bit(KEY_FLAG_NEGATIVE, &key->flags);\n\tup_write(&key->sem);\n\tif (ret < 0)\n\t\tgoto error;\nout:\n\treturn key_ref;\nerror:\n\tkey_put(key);\n\tkey_ref = ERR_PTR(ret);\n\tgoto out;\n}", "target": 1}
{"code": "void dtls1_stop_timer(SSL *s)\n{\n    memset(&(s->d1->timeout), 0, sizeof(struct dtls1_timeout_st));\n    memset(&(s->d1->next_timeout), 0, sizeof(struct timeval));\n    s->d1->timeout_duration = 1;\n    BIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT, 0,\n             &(s->d1->next_timeout));\n    dtls1_clear_record_buffer(s);\n}", "target": 0}
{"code": "int snd_usb_pipe_sanity_check(struct usb_device *dev, unsigned int pipe)\n{\n\tstatic const int pipetypes[4] = {\n\t\tPIPE_CONTROL, PIPE_ISOCHRONOUS, PIPE_BULK, PIPE_INTERRUPT\n\t};\n\tstruct usb_host_endpoint *ep;\n\tep = usb_pipe_endpoint(dev, pipe);\n\tif (usb_pipetype(pipe) != pipetypes[usb_endpoint_type(&ep->desc)])\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 1}
{"code": "int jpc_tsfb_synthesize(jpc_tsfb_t *tsfb, jas_seq2d_t *a)\n{\n\treturn (tsfb->numlvls > 0) ? jpc_tsfb_synthesize2(tsfb,\n\t  jas_seq2d_getref(a, jas_seq2d_xstart(a), jas_seq2d_ystart(a)),\n\t  jas_seq2d_xstart(a), jas_seq2d_ystart(a), jas_seq2d_width(a),\n\t  jas_seq2d_height(a), jas_seq2d_rowstep(a), tsfb->numlvls - 1) : 0;\n}", "target": 1}
{"code": "int bad_format(\n    char *fmt)\n{\n    char     *ptr;\n    int       n = 0;\n    ptr = fmt;\n    while (*ptr != '\\0')\n        if (*ptr++ == '%') {\n            if (*ptr == '\\0')\n                return 1;\n            if (*ptr == 's' || *ptr == 'S' || *ptr == '%')\n                ptr++;\n            else if (*ptr == 'c') {\n                ptr++;\n                n = 1;\n            }\n            else {\n                if (*ptr == ' ' || *ptr == '+' || *ptr == '-')\n                    ptr++;\n                while (*ptr >= '0' && *ptr <= '9')\n                    ptr++;\n                if (*ptr == '.')\n                    ptr++;\n                while (*ptr >= '0' && *ptr <= '9')\n                    ptr++;\n                if (*ptr++ != 'l')\n                    return 1;\n                if (*ptr == 'e' || *ptr == 'f' || *ptr == 'g')\n                    ptr++;\n                else\n                    return 1;\n                n++;\n            }\n        }\n    return (n != 1);\n}", "target": 1}
{"code": "static int em_jcxz(struct x86_emulate_ctxt *ctxt)\n{\n\tif (address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) == 0)\n\t\tjmp_rel(ctxt, ctxt->src.val);\n\treturn X86EMUL_CONTINUE;\n}", "target": 1}
{"code": "static int hns_xgmac_get_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn ARRAY_SIZE(g_xgmac_stats_string);\n\treturn 0;\n}", "target": 1}
{"code": "newVar_N2(char *var,char *var2, char *var3,char *var4,int pop_counter,char *final)\n{\n\tstruct SWF_ACTIONPUSHPARAM *v;\n\tint psize=PARAM_STRSIZE;\n\tint i;\n\tint slen=strlen(var)+strlen(var2)+strlen(var3)+strlen(var4)+strlen(final);\n\tv=malloc(sizeof(struct SWF_ACTIONPUSHPARAM));\n\tv->p.String = malloc(psize + slen);\n\tv->Type = PUSH_VARIABLE; \n\tstrcpy(v->p.String,var);\n\tstrcat(v->p.String,var2);\n\tstrcat(v->p.String,var3);\n\tstrcat(v->p.String,var4);\n\tfor(i=0;i<pop_counter;i++) \n\t{\n\t\tchar *pops1=getString(pop());\n\t\tchar *pops2=getName  (pop());\n\t\twhile ( strlen(v->p.String)+ 3 + strlen(pops1)+ strlen(pops2) +slen >= psize)\n\t\t{\n\t\t\tpsize += PARAM_STRSIZE;\n\t\t\tv->p.String = realloc( v->p.String, psize);\n\t\t}\n\t\tstrcat(v->p.String,pops2);\n\t\tstrcat(v->p.String,\":\");\n\t\tstrcat(v->p.String,pops1);\n\t\tif( i < pop_counter-1 ) \n\t\t\tstrcat(v->p.String,\",\");\n\t}\n\tstrcat(v->p.String,final);\n\treturn v;\n}", "target": 0}
{"code": "static void mark_object(struct object *obj, struct strbuf *path,\n\t\t\tconst char *name, void *data)\n{\n\tupdate_progress(data);\n}", "target": 1}
{"code": "void smp_process_local_nonce(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n  SMP_TRACE_DEBUG(\"%s\", __func__);\n switch (p_cb->selected_association_model) {\n case SMP_MODEL_SEC_CONN_JUSTWORKS:\n case SMP_MODEL_SEC_CONN_NUM_COMP:\n if (p_cb->role == HCI_ROLE_SLAVE) {\n        smp_calculate_local_commitment(p_cb);\n        smp_send_commitment(p_cb, NULL);\n        smp_set_state(SMP_STATE_WAIT_NONCE);\n } else \n {\n if (p_cb->flags & SMP_PAIR_FLAG_HAVE_PEER_COMM) {\n          SMP_TRACE_DEBUG(\n \"master in assoc mode = %d \"\n \"already rcvd slave commitment - race condition\",\n              p_cb->selected_association_model);\n          p_cb->flags &= ~SMP_PAIR_FLAG_HAVE_PEER_COMM;\n          smp_send_rand(p_cb, NULL);\n          smp_set_state(SMP_STATE_WAIT_NONCE);\n }\n }\n break;\n case SMP_MODEL_SEC_CONN_PASSKEY_ENT:\n case SMP_MODEL_SEC_CONN_PASSKEY_DISP:\n      smp_calculate_local_commitment(p_cb);\n if (p_cb->role == HCI_ROLE_MASTER) {\n        smp_send_commitment(p_cb, NULL);\n } else \n {\n if (p_cb->flags & SMP_PAIR_FLAG_HAVE_PEER_COMM) {\n          smp_send_commitment(p_cb, NULL);\n          smp_set_state(SMP_STATE_WAIT_NONCE);\n }\n }\n break;\n case SMP_MODEL_SEC_CONN_OOB:\n if (p_cb->role == HCI_ROLE_MASTER) {\n        smp_send_rand(p_cb, NULL);\n }\n      smp_set_state(SMP_STATE_WAIT_NONCE);\n break;\n default:\n      SMP_TRACE_ERROR(\"Association Model = %d is not used in LE SC\",\n                      p_cb->selected_association_model);\n break;\n }\n}", "target": 0}
{"code": "static int em_ret_far(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tunsigned long eip, cs;\n\tu16 old_cs;\n\tint cpl = ctxt->ops->cpl(ctxt);\n\tstruct desc_struct old_desc, new_desc;\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tops->get_segment(ctxt, &old_cs, &old_desc, NULL,\n\t\t\t\t VCPU_SREG_CS);\n\trc = emulate_pop(ctxt, &eip, ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = emulate_pop(ctxt, &cs, ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tif (ctxt->mode >= X86EMUL_MODE_PROT16 && (cs & 3) > cpl)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\trc = __load_segment_descriptor(ctxt, (u16)cs, VCPU_SREG_CS, cpl,\n\t\t\t\t       X86_TRANSFER_RET,\n\t\t\t\t       &new_desc);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = assign_eip_far(ctxt, eip, &new_desc);\n\tif (rc != X86EMUL_CONTINUE) {\n\t\tWARN_ON(ctxt->mode != X86EMUL_MODE_PROT64);\n\t\tops->set_segment(ctxt, old_cs, &old_desc, 0, VCPU_SREG_CS);\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "int fit_image_verify(const void *fit, int image_noffset)\n{\n\tconst void\t*data;\n\tsize_t\t\tsize;\n\tint\t\tnoffset = 0;\n\tchar\t\t*err_msg = \"\";\n\tif (fit_image_get_data_and_size(fit, image_noffset, &data, &size)) {\n\t\terr_msg = \"Can't get image data/size\";\n\t\tprintf(\"error!\\n%s for '%s' hash node in '%s' image node\\n\",\n\t\t       err_msg, fit_get_name(fit, noffset, NULL),\n\t\t       fit_get_name(fit, image_noffset, NULL));\n\t\treturn 0;\n\t}\n\treturn fit_image_verify_with_data(fit, image_noffset, data, size);\n}", "target": 1}
{"code": "  bool List::operator== (const Expression& rhs) const\n  {\n    if (List_Ptr_Const r = Cast<List>(&rhs)) {\n      if (length() != r->length()) return false;\n      if (separator() != r->separator()) return false;\n      for (size_t i = 0, L = length(); i < L; ++i) {\n        Expression_Obj rv = r->at(i);\n        Expression_Obj lv = this->at(i);\n        if (!lv || !rv) return false;\n        if (!(*lv == *rv)) return false;\n      }\n      return true;\n    }\n    return false;\n  }", "target": 0}
{"code": "static bool disconnect_cb(struct io *io, void *user_data)\n{\n\tstruct bt_att_chan *chan = user_data;\n\tstruct bt_att *att = chan->att;\n\tint err;\n\tsocklen_t len;\n\tlen = sizeof(err);\n\tif (getsockopt(chan->fd, SOL_SOCKET, SO_ERROR, &err, &len) < 0) {\n\t\tutil_debug(chan->att->debug_callback, chan->att->debug_data,\n\t\t\t\t\t\"(chan %p) Failed to obtain disconnect\"\n\t\t\t\t\t\" error: %s\", chan, strerror(errno));\n\t\terr = 0;\n\t}\n\tutil_debug(chan->att->debug_callback, chan->att->debug_data,\n\t\t\t\t\t\"Channel %p disconnected: %s\",\n\t\t\t\t\tchan, strerror(err));\n\tqueue_remove(att->chans, chan);\n\tqueue_remove_all(att->req_queue, NULL, NULL, disc_att_send_op);\n\tqueue_remove_all(att->ind_queue, NULL, NULL, disc_att_send_op);\n\tqueue_remove_all(att->write_queue, NULL, NULL, disc_att_send_op);\n\tif (chan->pending_req) {\n\t\tdisc_att_send_op(chan->pending_req);\n\t\tchan->pending_req = NULL;\n\t}\n\tif (chan->pending_ind) {\n\t\tdisc_att_send_op(chan->pending_ind);\n\t\tchan->pending_ind = NULL;\n\t}\n\tbt_att_chan_free(chan);\n\tif (!queue_isempty(att->chans))\n\t\treturn false;\n\tbt_att_ref(att);\n\tqueue_foreach(att->disconn_list, disconn_handler, INT_TO_PTR(err));\n\tbt_att_unregister_all(att);\n\tbt_att_unref(att);\n\treturn false;\n}", "target": 1}
{"code": "void ewk_view_mixed_content_run_set(Evas_Object* ewkView, bool hasRun)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData);\n    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv);\n    priv->flags.hasRunMixedContent = hasRun;\n    if (hasRun)\n        evas_object_smart_callback_call(ewkView, \"mixedcontent,run\", 0);\n}", "target": 0}
{"code": "static void init_skiplist(struct fsck_options *options, const char *path)\n{\n\tstatic struct oid_array skiplist = OID_ARRAY_INIT;\n\tint sorted, fd;\n\tchar buffer[GIT_MAX_HEXSZ + 1];\n\tstruct object_id oid;\n\tif (options->skiplist)\n\t\tsorted = options->skiplist->sorted;\n\telse {\n\t\tsorted = 1;\n\t\toptions->skiplist = &skiplist;\n\t}\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0)\n\t\tdie(\"Could not open skip list: %s\", path);\n\tfor (;;) {\n\t\tconst char *p;\n\t\tint result = read_in_full(fd, buffer, sizeof(buffer));\n\t\tif (result < 0)\n\t\t\tdie_errno(\"Could not read '%s'\", path);\n\t\tif (!result)\n\t\t\tbreak;\n\t\tif (parse_oid_hex(buffer, &oid, &p) || *p != '\\n')\n\t\t\tdie(\"Invalid SHA-1: %s\", buffer);\n\t\toid_array_append(&skiplist, &oid);\n\t\tif (sorted && skiplist.nr > 1 &&\n\t\t\t\toidcmp(&skiplist.oid[skiplist.nr - 2],\n\t\t\t\t       &oid) > 0)\n\t\t\tsorted = 0;\n\t}\n\tclose(fd);\n\tif (sorted)\n\t\tskiplist.sorted = 1;\n}", "target": 0}
{"code": "unix_listener(const char *path, int backlog, int unlink_first)\n{\n\tstruct sockaddr_un sunaddr;\n\tint saved_errno, sock;\n\tmemset(&sunaddr, 0, sizeof(sunaddr));\n\tsunaddr.sun_family = AF_UNIX;\n\tif (strlcpy(sunaddr.sun_path, path,\n\t    sizeof(sunaddr.sun_path)) >= sizeof(sunaddr.sun_path)) {\n\t\terror_f(\"path \\\"%s\\\" too long for Unix domain socket\", path);\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\tsock = socket(PF_UNIX, SOCK_STREAM, 0);\n\tif (sock == -1) {\n\t\tsaved_errno = errno;\n\t\terror_f(\"socket: %.100s\", strerror(errno));\n\t\terrno = saved_errno;\n\t\treturn -1;\n\t}\n\tif (unlink_first == 1) {\n\t\tif (unlink(path) != 0 && errno != ENOENT)\n\t\t\terror(\"unlink(%s): %.100s\", path, strerror(errno));\n\t}\n\tif (bind(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) == -1) {\n\t\tsaved_errno = errno;\n\t\terror_f(\"cannot bind to path %s: %s\", path, strerror(errno));\n\t\tclose(sock);\n\t\terrno = saved_errno;\n\t\treturn -1;\n\t}\n\tif (listen(sock, backlog) == -1) {\n\t\tsaved_errno = errno;\n\t\terror_f(\"cannot listen on path %s: %s\", path, strerror(errno));\n\t\tclose(sock);\n\t\tunlink(path);\n\t\terrno = saved_errno;\n\t\treturn -1;\n\t}\n\treturn sock;\n}", "target": 0}
{"code": "hb_set_set (hb_set_t       *set,\n\t    const hb_set_t *other)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n  set->set (*other);\n}", "target": 1}
{"code": "static struct ion_handle *ion_handle_get_by_id(struct ion_client *client,\n\t\t\t\t\t\tint id)\n{\n\tstruct ion_handle *handle;\n\tmutex_lock(&client->lock);\n\thandle = idr_find(&client->idr, id);\n\tif (handle)\n\t\tion_handle_get(handle);\n\tmutex_unlock(&client->lock);\n\treturn handle ? handle : ERR_PTR(-EINVAL);\n}", "target": 1}
{"code": "static bool kvm_vcpu_check_breakpoint(struct kvm_vcpu *vcpu, int *r)\n{\n\tstruct kvm_run *kvm_run = vcpu->run;\n\tunsigned long eip = vcpu->arch.emulate_ctxt.eip;\n\tu32 dr6 = 0;\n\tif (unlikely(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) &&\n\t    (vcpu->arch.guest_debug_dr7 & DR7_BP_EN_MASK)) {\n\t\tdr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.guest_debug_dr7,\n\t\t\t\t\t   vcpu->arch.eff_db);\n\t\tif (dr6 != 0) {\n\t\t\tkvm_run->debug.arch.dr6 = dr6 | DR6_FIXED_1 | DR6_RTM;\n\t\t\tkvm_run->debug.arch.pc = kvm_rip_read(vcpu) +\n\t\t\t\tget_segment_base(vcpu, VCPU_SREG_CS);\n\t\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\t\t*r = EMULATE_USER_EXIT;\n\t\t\treturn true;\n\t\t}\n\t}\n\tif (unlikely(vcpu->arch.dr7 & DR7_BP_EN_MASK) &&\n\t    !(kvm_get_rflags(vcpu) & X86_EFLAGS_RF)) {\n\t\tdr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.dr7,\n\t\t\t\t\t   vcpu->arch.db);\n\t\tif (dr6 != 0) {\n\t\t\tvcpu->arch.dr6 &= ~15;\n\t\t\tvcpu->arch.dr6 |= dr6 | DR6_RTM;\n\t\t\tkvm_queue_exception(vcpu, DB_VECTOR);\n\t\t\t*r = EMULATE_DONE;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "target": 0}
{"code": "void\nPerl_reg_numbered_buff_store(pTHX_ REGEXP * const rx, const I32 paren,\n\t\t\t\t\t\t\t SV const * const value)\n{\n    PERL_ARGS_ASSERT_REG_NUMBERED_BUFF_STORE;\n    PERL_UNUSED_ARG(rx);\n    PERL_UNUSED_ARG(paren);\n    PERL_UNUSED_ARG(value);\n    if (!PL_localizing)\n        Perl_croak_no_modify();", "target": 0}
{"code": "  static bool TryParse(const char* inp, int length,\n                       TypedValue* buf, Variant& out,\n                       JSONContainerType container_type, bool is_tsimplejson) {\n    SimpleParser parser(inp, length, buf, container_type, is_tsimplejson);\n    bool ok = parser.parseValue();\n    parser.skipSpace();\n    if (!ok || parser.p != inp + length) {\n      tvDecRefRange(buf, parser.top);\n      return false;\n    }\n    out = Variant::attach(*--parser.top);\n    return true;\n  }", "target": 1}
{"code": "xmlCreateMemoryParserCtxt(const char *buffer, int size) {\n    xmlParserCtxtPtr ctxt;\n    xmlParserInputPtr input;\n    xmlParserInputBufferPtr buf;\n    if (buffer == NULL)\n\treturn(NULL);\n    if (size <= 0)\n\treturn(NULL);\n    ctxt = xmlNewParserCtxt();\n    if (ctxt == NULL)\n\treturn(NULL);\n    buf = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);\n    if (buf == NULL) {\n\txmlFreeParserCtxt(ctxt);\n\treturn(NULL);\n    }\n    input = xmlNewInputStream(ctxt);\n    if (input == NULL) {\n\txmlFreeParserInputBuffer(buf);\n\txmlFreeParserCtxt(ctxt);\n\treturn(NULL);\n    }\n    input->filename = NULL;\n    input->buf = buf;\n    xmlBufResetInput(input->buf->buffer, input);\n    inputPush(ctxt, input);\n    return(ctxt);\n}", "target": 0}
{"code": "static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)\n{\n  unsigned result = 0;\n  size_t i;\n  for(i = nbits - 1; i < nbits; i--)\n  {\n    result += (unsigned)readBitFromReversedStream(bitpointer, bitstream) << i;\n  }\n  return result;\n}", "target": 0}
{"code": "static int nfs_can_extend_write(struct file *file, struct page *page, struct inode *inode)\n{\n\tif (file->f_flags & O_DSYNC)\n\t\treturn 0;\n\tif (NFS_PROTO(inode)->have_delegation(inode, FMODE_WRITE))\n\t\treturn 1;\n\tif (nfs_write_pageuptodate(page, inode) && (inode->i_flock == NULL ||\n\t\t\t(inode->i_flock->fl_start == 0 &&\n\t\t\tinode->i_flock->fl_end == OFFSET_MAX &&\n\t\t\tinode->i_flock->fl_type != F_RDLCK)))\n\t\treturn 1;\n\treturn 0;\n}", "target": 1}
{"code": "static u32 adpt_ioctl_to_context(adpt_hba * pHba, void *reply)\n{\n#if BITS_PER_LONG == 32\n\treturn (u32)(unsigned long)reply;\n#else\n\tulong flags = 0;\n\tu32 nr, i;\n\tspin_lock_irqsave(pHba->host->host_lock, flags);\n\tnr = ARRAY_SIZE(pHba->ioctl_reply_context);\n\tfor (i = 0; i < nr; i++) {\n\t\tif (pHba->ioctl_reply_context[i] == NULL) {\n\t\t\tpHba->ioctl_reply_context[i] = reply;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(pHba->host->host_lock, flags);\n\tif (i >= nr) {\n\t\tprintk(KERN_WARNING\"%s: Too many outstanding \"\n\t\t\t\t\"ioctl commands\\n\", pHba->name);\n\t\treturn (u32)-1;\n\t}\n\treturn i;\n#endif\n}", "target": 1}
{"code": "void sctp_generate_t3_rtx_event(unsigned long peer)\n{\n\tint error;\n\tstruct sctp_transport *transport = (struct sctp_transport *) peer;\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct net *net = sock_net(asoc->base.sk);\n\tbh_lock_sock(asoc->base.sk);\n\tif (sock_owned_by_user(asoc->base.sk)) {\n\t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n\t\tif (!mod_timer(&transport->T3_rtx_timer, jiffies + (HZ/20)))\n\t\t\tsctp_transport_hold(transport);\n\t\tgoto out_unlock;\n\t}\n\tif (transport->dead)\n\t\tgoto out_unlock;\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(SCTP_EVENT_TIMEOUT_T3_RTX),\n\t\t\t   asoc->state,\n\t\t\t   asoc->ep, asoc,\n\t\t\t   transport, GFP_ATOMIC);\n\tif (error)\n\t\tasoc->base.sk->sk_err = -error;\nout_unlock:\n\tbh_unlock_sock(asoc->base.sk);\n\tsctp_transport_put(transport);\n}", "target": 1}
{"code": "GF_Err gf_isom_wma_enum_tag(GF_ISOFile *mov, u32 idx, char **out_tag, const u8 **data, u32 *data_len, u32 *version, u32 *data_type)\n{\n\tGF_XtraBox *xtra;\n\tGF_XtraTag *tag;\n\t*out_tag = NULL;\n\t*data = NULL;\n\t*data_len = 0;\n\t*version = 0;\n\t*data_type = 0;\n\txtra = (GF_XtraBox *) gf_isom_get_meta_extensions(mov, GF_TRUE);\n\tif (!xtra) return GF_URL_ERROR;\n\ttag = gf_list_get(xtra->tags, idx);\n\tif (!tag) return GF_NOT_FOUND;\n\t*out_tag = tag->name;\n\t*data_len = tag->prop_size;\n\t*data = tag->prop_value;\n\t*version = tag->flags;\n\t*data_type = tag->prop_type;\n\treturn GF_OK;\n}", "target": 0}
{"code": "compat_kex_proposal(struct ssh *ssh, char *p)\n{\n\tif ((ssh->compat & (SSH_BUG_CURVE25519PAD|SSH_OLD_DHGEX)) == 0)\n\t\treturn p;\n\tdebug2_f(\"original KEX proposal: %s\", p);\n\tif ((ssh->compat & SSH_BUG_CURVE25519PAD) != 0)\n\t\tif ((p = match_filter_denylist(p,\n\t\t    \"curve25519-sha256@libssh.org\")) == NULL)\n\t\t\tfatal(\"match_filter_denylist failed\");\n\tif ((ssh->compat & SSH_OLD_DHGEX) != 0) {\n\t\tif ((p = match_filter_denylist(p,\n\t\t    \"diffie-hellman-group-exchange-sha256,\"\n\t\t    \"diffie-hellman-group-exchange-sha1\")) == NULL)\n\t\t\tfatal(\"match_filter_denylist failed\");\n\t}\n\tdebug2_f(\"compat KEX proposal: %s\", p);\n\tif (*p == '\\0')\n\t\tfatal(\"No supported key exchange algorithms found\");\n\treturn p;\n}", "target": 1}
{"code": "MONGO_EXPORT int bson_append_symbol_n( bson *b, const char *name, const char *value, int len ) {\n    return bson_append_string_base( b, name, value, len, BSON_SYMBOL );\n}", "target": 1}
{"code": "static int db_dict_iter_lookup_key_values(struct db_dict_value_iter *iter)\n{\n\tstruct db_dict_iter_key *key;\n\tstring_t *path;\n\tconst char *error;\n\tint ret;\n\tarray_sort(&iter->keys, db_dict_iter_key_cmp);\n\tpath = t_str_new(128);\n\tstr_append(path, DICT_PATH_SHARED);\n\tarray_foreach_modifiable(&iter->keys, key) {\n\t\tif (!key->used)\n\t\t\tcontinue;\n\t\tstr_truncate(path, strlen(DICT_PATH_SHARED));\n\t\tret = var_expand(path, key->key->key, iter->var_expand_table, &error);\n\t\tif (ret <= 0) {\n\t\t\tauth_request_log_error(iter->auth_request, AUTH_SUBSYS_DB,\n\t\t\t\t\"Failed to expand key %s: %s\", key->key->key, error);\n\t\t\treturn -1;\n\t\t}\n\t\tret = dict_lookup(iter->conn->dict, iter->pool,\n\t\t\t\t  str_c(path), &key->value, &error);\n\t\tif (ret > 0) {\n\t\t\tauth_request_log_debug(iter->auth_request, AUTH_SUBSYS_DB,\n\t\t\t\t\t       \"Lookup: %s = %s\", str_c(path),\n\t\t\t\t\t       key->value);\n\t\t} else if (ret < 0) {\n\t\t\tauth_request_log_error(iter->auth_request, AUTH_SUBSYS_DB,\n\t\t\t\t\"Failed to lookup key %s: %s\", str_c(path), error);\n\t\t\treturn -1;\n\t\t} else if (key->key->default_value != NULL) {\n\t\t\tauth_request_log_debug(iter->auth_request, AUTH_SUBSYS_DB,\n\t\t\t\t\"Lookup: %s not found, using default value %s\",\n\t\t\t\tstr_c(path), key->key->default_value);\n\t\t\tkey->value = key->key->default_value;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "bool CModules::GetModInfo(CModInfo& ModInfo, const CString& sModule,\n                          CString& sRetMsg) {\n    if (!ValidateModuleName(sModule, sRetMsg)) {\n        return false;\n    }\n    CString sModPath, sTmp;\n    bool bSuccess;\n    bool bHandled = false;\n    GLOBALMODULECALL(OnGetModInfo(ModInfo, sModule, bSuccess, sRetMsg),\n                     &bHandled);\n    if (bHandled) return bSuccess;\n    if (!FindModPath(sModule, sModPath, sTmp)) {\n        sRetMsg = t_f(\"Unable to find module {1}.\")(sModule);\n        return false;\n    }\n    return GetModPathInfo(ModInfo, sModule, sModPath, sRetMsg);\n}", "target": 0}
{"code": "    const std::unordered_map<std::string, std::string> &headers() const override\n    {\n        return headers_;\n    }", "target": 1}
{"code": "void InferenceContext::PreInputInit(\n    const OpDef& op_def, const std::vector<const Tensor*>& input_tensors,\n    const std::vector<ShapeHandle>& input_tensors_as_shapes) {\n  const auto ret = full_type::SpecializeType(attrs_, op_def);\n  DCHECK(ret.status().ok()) << \"while instantiating types: \" << ret.status();\n  ret_types_ = ret.ValueOrDie();\n  input_tensors_ = input_tensors;\n  input_tensors_as_shapes_ = input_tensors_as_shapes;\n  construction_status_ =\n      NameRangesForNode(attrs_, op_def, &input_name_map_, &output_name_map_);\n  if (!construction_status_.ok()) return;\n  int num_outputs = 0;\n  for (const auto& e : output_name_map_) {\n    num_outputs = std::max(num_outputs, e.second.second);\n  }\n  outputs_.assign(num_outputs, nullptr);\n  output_handle_shapes_and_types_.resize(num_outputs);\n}", "target": 1}
{"code": "void mce_setup(struct mce *m)\n{\n\tmemset(m, 0, sizeof(struct mce));\n\tm->cpu = m->extcpu = smp_processor_id();\n\tm->time = get_seconds();\n\tm->cpuvendor = boot_cpu_data.x86_vendor;\n\tm->cpuid = cpuid_eax(1);\n\tm->socketid = cpu_data(m->extcpu).phys_proc_id;\n\tm->apicid = cpu_data(m->extcpu).initial_apicid;\n\trdmsrl(MSR_IA32_MCG_CAP, m->mcgcap);\n\tif (this_cpu_has(X86_FEATURE_INTEL_PPIN))\n\t\trdmsrl(MSR_PPIN, m->ppin);\n\tm->microcode = boot_cpu_data.microcode;\n}", "target": 0}
{"code": "static void record_init(node_t * n)\n{\n    field_t *info;\n    pointf ul, sz;\n    int flip, len;\n    char *textbuf;\t\t\n    int sides = BOTTOM | RIGHT | TOP | LEFT;\n    flip = NOT(GD_realflip(agraphof(n)));\n    reclblp = ND_label(n)->text;\n    len = strlen(reclblp);\n    len = MAX(len, 1);\n    textbuf = N_NEW(len + 1, char);\n    if (!(info = parse_reclbl(n, flip, TRUE, textbuf))) {\n\tagerr(AGERR, \"bad label format %s\\n\", ND_label(n)->text);\n\treclblp = \"\\\\N\";\n\tinfo = parse_reclbl(n, flip, TRUE, textbuf);\n    }\n    free(textbuf);\n    size_reclbl(n, info);\n    sz.x = POINTS(ND_width(n));\n    sz.y = POINTS(ND_height(n));\n    if (mapbool(late_string(n, N_fixed, \"false\"))) {\n\tif ((sz.x < info->size.x) || (sz.y < info->size.y)) {\n\t}\n    } else {\n\tsz.x = MAX(info->size.x, sz.x);\n\tsz.y = MAX(info->size.y, sz.y);\n    }\n    resize_reclbl(info, sz, mapbool(late_string(n, N_nojustify, \"false\")));\n    ul = pointfof(-sz.x / 2., sz.y / 2.);\t\n    pos_reclbl(info, ul, sides);\n    ND_width(n) = PS2INCH(info->size.x);\n    ND_height(n) = PS2INCH(info->size.y + 1);\t\n    ND_shape_info(n) = (void *) info;\n}", "target": 1}
{"code": "void Http2Stream::SubmitRstStream(const uint32_t code) {\n  CHECK(!this->is_destroyed());\n  code_ = code;\n  if (session_->is_in_scope() &&\n      !is_writable() && is_reading()) {\n    session_->AddPendingRstStream(id_);\n    return;\n  }\n  if (session_->SendPendingData() != 0) {\n    session_->AddPendingRstStream(id_);\n    return;\n  }\n  FlushRstStream();\n}", "target": 1}
{"code": "elf_core_copy_task_xfpregs(struct task_struct *t, elf_fpxregset_t *xfpu)\n{\n\tstruct pt_regs *regs = task_pt_regs(t);\n\tif (!tsk_used_math(t))\n\t\treturn 0;\n\tif (t == current)\n\t\tunlazy_fpu(t); \n\tmemcpy(xfpu, &t->thread.i387.fxsave, sizeof(elf_fpxregset_t));\n\txfpu->fcs = regs->cs; \n\txfpu->fos = t->thread.ds;  \n\treturn 1;\n}", "target": 0}
{"code": "static struct nfs4_opendata *nfs4_open_recoverdata_alloc(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs4_opendata *opendata;\n\topendata = nfs4_opendata_alloc(&ctx->path, state->owner, 0, NULL);\n\tif (opendata == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\topendata->state = state;\n\tatomic_inc(&state->count);\n\treturn opendata;\n}", "target": 1}
{"code": "TfLiteStatus CalculateOpData(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteDepthToSpaceParams*>(node->builtin_data);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4);\n  auto data_type = output->type;\n  TF_LITE_ENSURE(context,\n                 data_type == kTfLiteFloat32 || data_type == kTfLiteInt8);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  const int block_size = params->block_size;\n  TF_LITE_ENSURE(context, block_size > 0);\n  const int input_height = input->dims->data[kHeightRank];\n  const int input_width = input->dims->data[kWidthRank];\n  const int input_channels = input->dims->data[kDepthRank];\n  int output_height = input_height * block_size;\n  int output_width = input_width * block_size;\n  int output_channels = input_channels / block_size / block_size;\n  TF_LITE_ENSURE_EQ(context, input_height, output_height / block_size);\n  TF_LITE_ENSURE_EQ(context, input_width, output_width / block_size);\n  TF_LITE_ENSURE_EQ(context, input_channels,\n                    output_channels * block_size * block_size);\n  TfLiteEvalTensor* output_eval =\n      tflite::micro::GetEvalOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE_OK(context, tflite::micro::CreateWritableTensorDimsWithCopy(\n                                 context, output, output_eval));\n  output->dims->data[kBatchRank] = input->dims->data[kBatchRank];\n  output->dims->data[kHeightRank] = output_height;\n  output->dims->data[kWidthRank] = output_width;\n  output->dims->data[kDepthRank] = output_channels;\n  return kTfLiteOk;\n}", "target": 0}
{"code": "dtls1_process_buffered_records(SSL *s)\n    {\n    pitem *item;\n    item = pqueue_peek(s->d1->unprocessed_rcds.q);\n    if (item)\n        {\n        if (s->d1->unprocessed_rcds.epoch != s->d1->r_epoch)\n            return(1);  \n        while (pqueue_peek(s->d1->unprocessed_rcds.q))\n            {\n            dtls1_get_unprocessed_record(s);\n            if ( ! dtls1_process_record(s))\n                return(0);\n            dtls1_buffer_record(s, &(s->d1->processed_rcds), \n                s->s3->rrec.seq_num);\n            }\n        }\n    s->d1->processed_rcds.epoch = s->d1->r_epoch;\n    s->d1->unprocessed_rcds.epoch = s->d1->r_epoch + 1;\n    return(1);\n    }", "target": 1}
{"code": "static void ip6_append_data_mtu(int *mtu,\n\t\t\t\tint *maxfraglen,\n\t\t\t\tunsigned int fragheaderlen,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tstruct rt6_info *rt)\n{\n\tif (!(rt->dst.flags & DST_XFRM_TUNNEL)) {\n\t\tif (skb == NULL) {\n\t\t\t*mtu = *mtu - rt->dst.header_len;\n\t\t} else {\n\t\t\t*mtu = dst_mtu(rt->dst.path);\n\t\t}\n\t\t*maxfraglen = ((*mtu - fragheaderlen) & ~7)\n\t\t\t      + fragheaderlen - sizeof(struct frag_hdr);\n\t}\n}", "target": 1}
{"code": "static void __exit vmx_exit(void)\n{\n#ifdef CONFIG_KEXEC_CORE\n\tRCU_INIT_POINTER(crash_vmclear_loaded_vmcss, NULL);\n\tsynchronize_rcu();\n#endif\n\tkvm_exit();\n}", "target": 0}
{"code": "write_os2_header (j_decompress_ptr cinfo, bmp_dest_ptr dest)\n{\n  char bmpfileheader[14];\n  char bmpcoreheader[12];\n  long headersize, bfSize;\n  int bits_per_pixel, cmap_entries;\n  if (cinfo->out_color_space == JCS_RGB ||\n      (cinfo->out_color_space >= JCS_EXT_RGB &&\n       cinfo->out_color_space <= JCS_EXT_ARGB)) {\n    if (cinfo->quantize_colors) {\n      bits_per_pixel = 8;\n      cmap_entries = 256;\n    } else {\n      bits_per_pixel = 24;\n      cmap_entries = 0;\n    }\n  } else if (cinfo->out_color_space == JCS_RGB565 ||\n             cinfo->out_color_space == JCS_CMYK) {\n    bits_per_pixel = 24;\n    cmap_entries   = 0;\n  } else {\n    bits_per_pixel = 8;\n    cmap_entries = 256;\n  }\n  headersize = 14 + 12 + cmap_entries * 3; \n  bfSize = headersize + (long) dest->row_width * (long) cinfo->output_height;\n  MEMZERO(bmpfileheader, sizeof(bmpfileheader));\n  MEMZERO(bmpcoreheader, sizeof(bmpcoreheader));\n  bmpfileheader[0] = 0x42;      \n  bmpfileheader[1] = 0x4D;\n  PUT_4B(bmpfileheader, 2, bfSize); \n  PUT_4B(bmpfileheader, 10, headersize); \n  PUT_2B(bmpcoreheader, 0, 12); \n  PUT_2B(bmpcoreheader, 4, cinfo->output_width); \n  PUT_2B(bmpcoreheader, 6, cinfo->output_height); \n  PUT_2B(bmpcoreheader, 8, 1);  \n  PUT_2B(bmpcoreheader, 10, bits_per_pixel); \n  if (JFWRITE(dest->pub.output_file, bmpfileheader, 14) != (size_t) 14)\n    ERREXIT(cinfo, JERR_FILE_WRITE);\n  if (JFWRITE(dest->pub.output_file, bmpcoreheader, 12) != (size_t) 12)\n    ERREXIT(cinfo, JERR_FILE_WRITE);\n  if (cmap_entries > 0)\n    write_colormap(cinfo, dest, cmap_entries, 3);\n}", "target": 0}
{"code": "normalizeLines(XML_Char *s)\n{\n  XML_Char *p;\n  for (;; s++) {\n    if (*s == XML_T('\\0'))\n      return;\n    if (*s == 0xD)\n      break;\n  }\n  p = s;\n  do {\n    if (*s == 0xD) {\n      *p++ = 0xA;\n      if (*++s == 0xA)\n        s++;\n    }\n    else\n      *p++ = *s++;\n  } while (*s);\n  *p = XML_T('\\0');\n}", "target": 0}
{"code": "void OmniboxViewWin::SetUserText(const string16& text,\n                                 const string16& display_text,\n                                 bool update_popup) {\n  ScopedFreeze freeze(this, GetTextObjectModel());\n  model_->SetUserText(text);\n  saved_selection_for_focus_change_.cpMin = -1;\n  SetWindowTextAndCaretPos(display_text, display_text.length());\n  if (update_popup)\n    UpdatePopup();\n  TextChanged();\n}", "target": 0}
{"code": "bool RenderMenuList::multiple()\n {\n     return toHTMLSelectElement(node())->multiple();\n }", "target": 1}
{"code": "  void Inspect::operator()(Complex_Selector_Ptr c)\n  {\n    Compound_Selector_Obj      head = c->head();\n    Complex_Selector_Obj            tail = c->tail();\n    Complex_Selector::Combinator comb = c->combinator();\n    if (comb == Complex_Selector::ANCESTOR_OF && (!head || head->empty())) {\n      if (tail) tail->perform(this);\n      return;\n    }\n    if (c->has_line_feed()) {\n      if (!(c->has_parent_ref())) {\n        append_optional_linefeed();\n        append_indentation();\n      }\n    }\n    if (head && head->length() != 0) head->perform(this);\n    bool is_empty = !head || head->length() == 0 || head->is_empty_reference();\n    bool is_tail = head && !head->is_empty_reference() && tail;\n    if (output_style() == COMPRESSED && comb != Complex_Selector::ANCESTOR_OF) scheduled_space = 0;\n    switch (comb) {\n      case Complex_Selector::ANCESTOR_OF:\n        if (is_tail) append_mandatory_space();\n      break;\n      case Complex_Selector::PARENT_OF:\n        append_optional_space();\n        append_string(\">\");\n        append_optional_space();\n      break;\n      case Complex_Selector::ADJACENT_TO:\n        append_optional_space();\n        append_string(\"+\");\n        append_optional_space();\n      break;\n      case Complex_Selector::REFERENCE:\n        append_mandatory_space();\n        append_string(\"/\");\n        c->reference()->perform(this);\n        append_string(\"/\");\n        append_mandatory_space();\n      break;\n      case Complex_Selector::PRECEDES:\n        if (is_empty) append_optional_space();\n        else append_mandatory_space();\n        append_string(\"~\");\n        if (tail) append_mandatory_space();\n        else append_optional_space();\n      break;\n      default: break;\n    }\n    if (tail && comb != Complex_Selector::ANCESTOR_OF) {\n      if (c->has_line_break()) append_optional_linefeed();\n    }\n    if (tail) tail->perform(this);\n    if (!tail && c->has_line_break()) {\n      if (output_style() == COMPACT) {\n        append_mandatory_space();\n      }\n    }\n  }", "target": 1}
{"code": "   Get status info from a mailbox */\nPHP_FUNCTION(imap_status)\n{\n\tzval *streamind;\n\tzend_string *mbx;\n\tzend_long flags;\n\tpils *imap_le_struct;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"rSl\", &streamind, &mbx, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\tif ((imap_le_struct = (pils *)zend_fetch_resource(Z_RES_P(streamind), \"imap\", le_imap)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tobject_init(return_value);\n\tif (mail_status(imap_le_struct->imap_stream, ZSTR_VAL(mbx), flags)) {\n\t\tadd_property_long(return_value, \"flags\", IMAPG(status_flags));\n\t\tif (IMAPG(status_flags) & SA_MESSAGES) {\n\t\t\tadd_property_long(return_value, \"messages\", IMAPG(status_messages));\n\t\t}\n\t\tif (IMAPG(status_flags) & SA_RECENT) {\n\t\t\tadd_property_long(return_value, \"recent\", IMAPG(status_recent));\n\t\t}\n\t\tif (IMAPG(status_flags) & SA_UNSEEN) {\n\t\t\tadd_property_long(return_value, \"unseen\", IMAPG(status_unseen));\n\t\t}\n\t\tif (IMAPG(status_flags) & SA_UIDNEXT) {\n\t\t\tadd_property_long(return_value, \"uidnext\", IMAPG(status_uidnext));\n\t\t}\n\t\tif (IMAPG(status_flags) & SA_UIDVALIDITY) {\n\t\t\tadd_property_long(return_value, \"uidvalidity\", IMAPG(status_uidvalidity));\n\t\t}\n\t} else {\n\t\tRETURN_FALSE;\n\t}", "target": 0}
{"code": "psf_d2i_clip_array (const double *src, int *dest, int count, int normalize)\n{\tdouble\t\t\tnormfact, scaled_value ;\n\tnormfact = normalize ? (8.0 * 0x10000000) : 1.0 ;\n\twhile (--count >= 0)\n\t{\tscaled_value = src [count] * normfact ;\n\t\tif (CPU_CLIPS_POSITIVE == 0 && scaled_value >= (1.0 * 0x7FFFFFFF))\n\t\t{\tdest [count] = 0x7FFFFFFF ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\t\tif (CPU_CLIPS_NEGATIVE == 0 && scaled_value <= (-8.0 * 0x10000000))\n\t\t{\tdest [count] = 0x80000000 ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\t\tdest [count] = lrint (scaled_value) ;\n\t\t} ;\n\treturn ;\n} ", "target": 0}
{"code": "static struct xol_area *__create_xol_area(unsigned long vaddr)\n{\n\tstruct mm_struct *mm = current->mm;\n\tuprobe_opcode_t insn = UPROBE_SWBP_INSN;\n\tstruct xol_area *area;\n\tarea = kmalloc(sizeof(*area), GFP_KERNEL);\n\tif (unlikely(!area))\n\t\tgoto out;\n\tarea->bitmap = kzalloc(BITS_TO_LONGS(UINSNS_PER_PAGE) * sizeof(long), GFP_KERNEL);\n\tif (!area->bitmap)\n\t\tgoto free_area;\n\tarea->xol_mapping.name = \"[uprobes]\";\n\tarea->xol_mapping.fault = NULL;\n\tarea->xol_mapping.pages = area->pages;\n\tarea->pages[0] = alloc_page(GFP_HIGHUSER);\n\tif (!area->pages[0])\n\t\tgoto free_bitmap;\n\tarea->pages[1] = NULL;\n\tarea->vaddr = vaddr;\n\tinit_waitqueue_head(&area->wq);\n\tset_bit(0, area->bitmap);\n\tatomic_set(&area->slot_count, 1);\n\tarch_uprobe_copy_ixol(area->pages[0], 0, &insn, UPROBE_SWBP_INSN_SIZE);\n\tif (!xol_add_vma(mm, area))\n\t\treturn area;\n\t__free_page(area->pages[0]);\n free_bitmap:\n\tkfree(area->bitmap);\n free_area:\n\tkfree(area);\n out:\n\treturn NULL;\n}", "target": 0}
{"code": "NAN_METHOD(TxnWrap::ctor) {\n    Nan::HandleScope scope;\n    EnvWrap *ew = Nan::ObjectWrap::Unwrap<EnvWrap>(Local<Object>::Cast(info[0]));\n    int flags = 0;\n    if (info[1]->IsObject()) {\n        Local<Object> options = Local<Object>::Cast(info[1]);\n        setFlagFromValue(&flags, MDB_RDONLY, \"readOnly\", false, options);\n    }\n    if (0 == (flags & MDB_RDONLY) && ew->currentWriteTxn != nullptr) {\n        return Nan::ThrowError(\"You have already opened a write transaction in the current process, can't open a second one.\");\n    }\n    MDB_txn *txn;\n    int rc = mdb_txn_begin(ew->env, nullptr, flags, &txn);\n    if (rc != 0) {\n        if (rc == EINVAL) {\n            return Nan::ThrowError(\"Invalid parameter, which on MacOS is often due to more transactions than available robust locked semaphors (see node-lmdb docs for more info)\");\n        }\n        return throwLmdbError(rc);\n    }\n    TxnWrap* tw = new TxnWrap(ew->env, txn);\n    tw->flags = flags;\n    tw->ew = ew;\n    tw->ew->Ref();\n    tw->Wrap(info.This());\n    if (0 == (flags & MDB_RDONLY)) {\n        ew->currentWriteTxn = tw;\n    }\n    else {\n        ew->readTxns.push_back(tw);\n    }\n    return info.GetReturnValue().Set(info.This());\n}", "target": 0}
{"code": "int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)\n{\n\tunsigned int offset = sizeof(struct ipv6hdr);\n\tunsigned int packet_len = skb_tail_pointer(skb) -\n\t\tskb_network_header(skb);\n\tint found_rhdr = 0;\n\t*nexthdr = &ipv6_hdr(skb)->nexthdr;\n\twhile (offset <= packet_len) {\n\t\tstruct ipv6_opt_hdr *exthdr;\n\t\tunsigned int len;\n\t\tswitch (**nexthdr) {\n\t\tcase NEXTHDR_HOP:\n\t\t\tbreak;\n\t\tcase NEXTHDR_ROUTING:\n\t\t\tfound_rhdr = 1;\n\t\t\tbreak;\n\t\tcase NEXTHDR_DEST:\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\t\tif (ipv6_find_tlv(skb, offset, IPV6_TLV_HAO) >= 0)\n\t\t\t\tbreak;\n#endif\n\t\t\tif (found_rhdr)\n\t\t\t\treturn offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn offset;\n\t\t}\n\t\tif (offset + sizeof(struct ipv6_opt_hdr) > packet_len)\n\t\t\treturn -EINVAL;\n\t\texthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +\n\t\t\t\t\t\t offset);\n\t\tlen = ipv6_optlen(exthdr);\n\t\tif (len + offset >= IPV6_MAXPLEN)\n\t\t\treturn -EINVAL;\n\t\toffset += len;\n\t\t*nexthdr = &exthdr->nexthdr;\n\t}\n\treturn -EINVAL;\n}", "target": 0}
{"code": "static inline void DetectRunPrefilterPkt(\n    ThreadVars *tv,\n    DetectEngineCtx *de_ctx,\n    DetectEngineThreadCtx *det_ctx,\n    Packet *p,\n    DetectRunScratchpad *scratch\n)\n{\n    DetectPrefilterSetNonPrefilterList(p, det_ctx, scratch);\n    PacketCreateMask(p, &scratch->pkt_mask, scratch->alproto, scratch->app_decoder_events);\n    PACKET_PROFILING_DETECT_START(p, PROF_DETECT_NONMPMLIST);\n    det_ctx->non_pf_id_cnt = 0;\n    if (likely(det_ctx->non_pf_store_cnt > 0)) {\n        DetectPrefilterBuildNonPrefilterList(det_ctx, scratch->pkt_mask, scratch->alproto);\n    }\n    PACKET_PROFILING_DETECT_END(p, PROF_DETECT_NONMPMLIST);\n    Prefilter(det_ctx, scratch->sgh, p, scratch->flow_flags);\n    if (det_ctx->non_pf_store_cnt || det_ctx->pmq.rule_id_array_cnt) {\n        PACKET_PROFILING_DETECT_START(p, PROF_DETECT_PF_SORT2);\n        DetectPrefilterMergeSort(de_ctx, det_ctx);\n        PACKET_PROFILING_DETECT_END(p, PROF_DETECT_PF_SORT2);\n    }\n#ifdef PROFILING\n    if (tv) {\n        StatsAddUI64(tv, det_ctx->counter_mpm_list,\n                             (uint64_t)det_ctx->pmq.rule_id_array_cnt);\n        StatsAddUI64(tv, det_ctx->counter_nonmpm_list,\n                             (uint64_t)det_ctx->non_pf_store_cnt);\n        StatsAddUI64(tv, det_ctx->counter_fnonmpm_list,\n                             (uint64_t)det_ctx->non_pf_id_cnt);\n    }\n#endif\n}", "target": 0}
{"code": "static void coroutine_fn mirror_wait_on_conflicts(MirrorOp *self,\n                                                  MirrorBlockJob *s,\n                                                  uint64_t offset,\n                                                  uint64_t bytes)\n{\n    uint64_t self_start_chunk = offset / s->granularity;\n    uint64_t self_end_chunk = DIV_ROUND_UP(offset + bytes, s->granularity);\n    uint64_t self_nb_chunks = self_end_chunk - self_start_chunk;\n    while (find_next_bit(s->in_flight_bitmap, self_end_chunk,\n                         self_start_chunk) < self_end_chunk &&\n           s->ret >= 0)\n    {\n        MirrorOp *op;\n        QTAILQ_FOREACH(op, &s->ops_in_flight, next) {\n            uint64_t op_start_chunk = op->offset / s->granularity;\n            uint64_t op_nb_chunks = DIV_ROUND_UP(op->offset + op->bytes,\n                                                 s->granularity) -\n                                    op_start_chunk;\n            if (op == self) {\n                continue;\n            }\n            if (ranges_overlap(self_start_chunk, self_nb_chunks,\n                               op_start_chunk, op_nb_chunks))\n            {\n                qemu_co_queue_wait(&op->waiting_requests, NULL);\n                break;\n            }\n        }\n    }\n}", "target": 1}
{"code": "PixarLogClose(TIFF* tif)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\ttd->td_bitspersample = 8;\n\ttd->td_sampleformat = SAMPLEFORMAT_UINT;\n}", "target": 1}
{"code": "static int ipv4ll_recv_arp_packet(GDHCPClient *dhcp_client)\n{\n\tint bytes;\n\tstruct ether_arp arp;\n\tuint32_t ip_requested;\n\tint source_conflict;\n\tint target_conflict;\n\tguint timeout_ms;\n\tmemset(&arp, 0, sizeof(arp));\n\tbytes = read(dhcp_client->listener_sockfd, &arp, sizeof(arp));\n\tif (bytes < 0)\n\t\treturn bytes;\n\tif (arp.arp_op != htons(ARPOP_REPLY) &&\n\t\t\tarp.arp_op != htons(ARPOP_REQUEST))\n\t\treturn -EINVAL;\n\tif (memcmp(arp.arp_sha, dhcp_client->mac_address, ETH_ALEN) == 0)\n\t\treturn 0;\n\tip_requested = htonl(dhcp_client->requested_ip);\n\tsource_conflict = !memcmp(arp.arp_spa, &ip_requested,\n\t\t\t\t\t\tsizeof(ip_requested));\n\ttarget_conflict = !memcmp(arp.arp_tpa, &ip_requested,\n\t\t\t\tsizeof(ip_requested));\n\tif (!source_conflict && !target_conflict)\n\t\treturn 0;\n\tdhcp_client->conflicts++;\n\tdebug(dhcp_client, \"IPV4LL conflict detected\");\n\tif (dhcp_client->state == IPV4LL_MONITOR) {\n\t\tif (!source_conflict)\n\t\t\treturn 0;\n\t\tdhcp_client->state = IPV4LL_DEFEND;\n\t\tdebug(dhcp_client, \"DEFEND mode conflicts : %d\",\n\t\t\tdhcp_client->conflicts);\n\t\tsend_announce_packet(dhcp_client);\n\t\treturn 0;\n\t}\n\tif (dhcp_client->state == IPV4LL_DEFEND) {\n\t\tif (!source_conflict)\n\t\t\treturn 0;\n\t\telse if (dhcp_client->ipv4ll_lost_cb)\n\t\t\tdhcp_client->ipv4ll_lost_cb(dhcp_client,\n\t\t\t\t\t\tdhcp_client->ipv4ll_lost_data);\n\t}\n\tipv4ll_stop(dhcp_client);\n\tif (dhcp_client->conflicts < MAX_CONFLICTS)\n\t\ttimeout_ms = __connman_util_random_delay_ms(PROBE_WAIT);\n\telse\n\t\ttimeout_ms = RATE_LIMIT_INTERVAL * 1000;\n\tdhcp_client->retry_times++;\n\tdhcp_client->timeout =\n\t\tg_timeout_add_full(G_PRIORITY_HIGH,\n\t\t\t\ttimeout_ms,\n\t\t\t\tsend_probe_packet,\n\t\t\t\tdhcp_client,\n\t\t\t\tNULL);\n\treturn 0;\n}", "target": 0}
{"code": "TEST(RegexMatchExpression, MatchesElementExtendedOn) {\n    BSONObj match = BSON(\"x\"\n                         << \"ab\");\n    BSONObj notMatch = BSON(\"x\"\n                            << \"a b\");\n    RegexMatchExpression regex(\"\", \"a b\", \"x\");\n    ASSERT(regex.matchesSingleElement(match.firstElement()));\n    ASSERT(!regex.matchesSingleElement(notMatch.firstElement()));\n}", "target": 0}
{"code": "static void setup_private_mount(const char *snap_name)\n{\n\tuid_t uid = getuid();\n\tgid_t gid = getgid();\n\tchar tmpdir[MAX_BUF] = { 0 };\n\tsc_must_snprintf(tmpdir, sizeof(tmpdir), \"/tmp/snap.%s_XXXXXX\", snap_name);\n\tif (mkdtemp(tmpdir) == NULL) {\n\t\tdie(\"cannot create temporary directory essential for private /tmp\");\n\t}\n\tmode_t old_mask = umask(0);\n\tchar *d = sc_strdup(tmpdir);\n\tsc_must_snprintf(tmpdir, sizeof(tmpdir), \"%s/tmp\", d);\n\tfree(d);\n\tif (mkdir(tmpdir, 01777) != 0) {\n\t\tdie(\"cannot create temporary directory for private /tmp\");\n\t}\n\tumask(old_mask);\n\tchar *pwd = get_current_dir_name();\n\tif (pwd == NULL)\n\t\tdie(\"cannot get current working directory\");\n\tif (chdir(\"/\") != 0)\n\t\tdie(\"cannot change directory to '/'\");\n\tsc_do_mount(tmpdir, \"/tmp\", NULL, MS_BIND, NULL);\n\tsc_do_mount(\"none\", \"/tmp\", NULL, MS_PRIVATE, NULL);\n\tif (chown(\"/tmp/\", uid, gid) < 0) {\n\t\tdie(\"cannot change ownership of /tmp\");\n\t}\n\tif (chdir(pwd) != 0)\n\t\tdie(\"cannot change current working directory to the original directory\");\n\tfree(pwd);\n}", "target": 1}
{"code": "vhost_user_set_features(struct virtio_net *dev, uint64_t features)\n{\n\tuint64_t vhost_features = 0;\n\trte_vhost_driver_get_features(dev->ifname, &vhost_features);\n\tif (features & ~vhost_features) {\n\t\tRTE_LOG(ERR, VHOST_CONFIG,\n\t\t\t\"(%d) received invalid negotiated features.\\n\",\n\t\t\tdev->vid);\n\t\treturn -1;\n\t}\n\tif (dev->flags & VIRTIO_DEV_RUNNING) {\n\t\tif (dev->features == features)\n\t\t\treturn 0;\n\t\tif ((dev->features ^ features) & ~(1ULL << VHOST_F_LOG_ALL)) {\n\t\t\tRTE_LOG(ERR, VHOST_CONFIG,\n\t\t\t\t\"(%d) features changed while device is running.\\n\",\n\t\t\t\tdev->vid);\n\t\t\treturn -1;\n\t\t}\n\t\tif (dev->notify_ops->features_changed)\n\t\t\tdev->notify_ops->features_changed(dev->vid, features);\n\t}\n\tdev->features = features;\n\tif (dev->features &\n\t\t((1 << VIRTIO_NET_F_MRG_RXBUF) | (1ULL << VIRTIO_F_VERSION_1))) {\n\t\tdev->vhost_hlen = sizeof(struct virtio_net_hdr_mrg_rxbuf);\n\t} else {\n\t\tdev->vhost_hlen = sizeof(struct virtio_net_hdr);\n\t}\n\tLOG_DEBUG(VHOST_CONFIG,\n\t\t\"(%d) mergeable RX buffers %s, virtio 1 %s\\n\",\n\t\tdev->vid,\n\t\t(dev->features & (1 << VIRTIO_NET_F_MRG_RXBUF)) ? \"on\" : \"off\",\n\t\t(dev->features & (1ULL << VIRTIO_F_VERSION_1)) ? \"on\" : \"off\");\n\tif ((dev->flags & VIRTIO_DEV_BUILTIN_VIRTIO_NET) &&\n\t    !(dev->features & (1ULL << VIRTIO_NET_F_MQ))) {\n\t\twhile (dev->nr_vring > 2) {\n\t\t\tstruct vhost_virtqueue *vq;\n\t\t\tvq = dev->virtqueue[--dev->nr_vring];\n\t\t\tif (!vq)\n\t\t\t\tcontinue;\n\t\t\tdev->virtqueue[dev->nr_vring] = NULL;\n\t\t\tcleanup_vq(vq, 1);\n\t\t\tfree_vq(vq);\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void ConnectDialogEdit::on_qbFill_clicked() {\n\tQ_ASSERT(m_si);\n\tqwInlineNotice->hide();\n\tadjustSize();\n\tqleName->setText(m_si->qsName);\n\tqleServer->setText(m_si->qsHostname);\n\tqleUsername->setText(m_si->qsUsername);\n\tqlePort->setText(QString::number(m_si->usPort));\n\tqlePassword->setText(m_si->qsPassword);\n\tdelete m_si;\n\tm_si = NULL;\n}", "target": 0}
{"code": "bgp_capability_mp (struct peer *peer, struct capability *cap)\n{\n  if (ntohs (cap->mpc.afi) == AFI_IP)\n    {\n      if (cap->mpc.safi == SAFI_UNICAST)\n\t{\n\t  peer->afc_recv[AFI_IP][SAFI_UNICAST] = 1;\n\t  if (peer->afc[AFI_IP][SAFI_UNICAST])\n\t    peer->afc_nego[AFI_IP][SAFI_UNICAST] = 1;\n\t  else\n\t    return -1;\n\t}\n      else if (cap->mpc.safi == SAFI_MULTICAST) \n\t{\n\t  peer->afc_recv[AFI_IP][SAFI_MULTICAST] = 1;\n\t  if (peer->afc[AFI_IP][SAFI_MULTICAST])\n\t    peer->afc_nego[AFI_IP][SAFI_MULTICAST] = 1;\n\t  else\n\t    return -1;\n\t}\n      else if (cap->mpc.safi == BGP_SAFI_VPNV4)\n\t{\n\t  peer->afc_recv[AFI_IP][SAFI_MPLS_VPN] = 1;\n\t  if (peer->afc[AFI_IP][SAFI_MPLS_VPN])\n\t    peer->afc_nego[AFI_IP][SAFI_MPLS_VPN] = 1;\n\t  else\n\t    return -1;\n\t}\n      else\n\treturn -1;\n    }\n#ifdef HAVE_IPV6\n  else if (ntohs (cap->mpc.afi) == AFI_IP6)\n    {\n      if (cap->mpc.safi == SAFI_UNICAST)\n\t{\n\t  peer->afc_recv[AFI_IP6][SAFI_UNICAST] = 1;\n\t  if (peer->afc[AFI_IP6][SAFI_UNICAST])\n\t    peer->afc_nego[AFI_IP6][SAFI_UNICAST] = 1;\n\t  else\n\t    return -1;\n\t}\n      else if (cap->mpc.safi == SAFI_MULTICAST)\n\t{\n\t  peer->afc_recv[AFI_IP6][SAFI_MULTICAST] = 1;\n\t  if (peer->afc[AFI_IP6][SAFI_MULTICAST])\n\t    peer->afc_nego[AFI_IP6][SAFI_MULTICAST] = 1;\n\t  else\n\t    return -1;\n\t}\n      else\n\treturn -1;\n    }\n#endif \n  else\n    {\n      return -1;\n    }\n  return 0;\n}", "target": 1}
{"code": "read_response_line(smtp_inblock *inblock, uschar *buffer, int size, int timeout)\n{\nuschar *p = buffer;\nuschar *ptr = inblock->ptr;\nuschar *ptrend = inblock->ptrend;\nclient_conn_ctx * cctx = inblock->cctx;\nfor (;;)\n  {\n  int rc;\n  while (ptr < ptrend)\n    {\n    int c = *ptr++;\n    if (c == '\\n')\n      {\n      while (p > buffer && isspace(p[-1])) p--;\n      *p = 0;\n      inblock->ptr = ptr;\n      return p - buffer;\n      }\n    *p++ = c;\n    if (--size < 4)\n      {\n      *p = 0;                     \n      errno = ERRNO_SMTPFORMAT;\n      return -1;\n      }\n    }\n  if((rc = ip_recv(cctx, inblock->buffer, inblock->buffersize, timeout)) <= 0)\n    {\n    DEBUG(D_deliver|D_transport|D_acl)\n      debug_printf_indent(errno ? \"  SMTP(%s)<<\\n\" : \"  SMTP(closed)<<\\n\",\n\tstrerror(errno));\n    break;\n    }\n  ptrend = inblock->ptrend = inblock->buffer + rc;\n  ptr = inblock->buffer;\n  DEBUG(D_transport|D_acl) debug_printf_indent(\"read response data: size=%d\\n\", rc);\n  }\n*buffer = 0;\nreturn -1;\n}", "target": 0}
{"code": "static bool php_mb_parse_encoding(const Variant& encoding,\n                                  mbfl_encoding ***return_list,\n                                  int *return_size, bool persistent) {\n  bool ret;\n  if (encoding.isArray()) {\n    ret = php_mb_parse_encoding_array(encoding.toArray(),\n                                      return_list, return_size,\n                                      persistent ? 1 : 0);\n  } else {\n    String enc = encoding.toString();\n    ret = php_mb_parse_encoding_list(enc.data(), enc.size(),\n                                     return_list, return_size,\n                                     persistent ? 1 : 0);\n  }\n  if (!ret) {\n    if (return_list && *return_list) {\n      free(*return_list);\n      *return_list = nullptr;\n    }\n    return_size = 0;\n  }\n  return ret;\n}", "target": 1}
{"code": "void RenderLayerCompositor::frameViewDidScroll()\n{\n    FrameView* frameView = m_renderView->frameView();\n    IntPoint scrollPosition = frameView->scrollPosition();\n    if (!m_scrollLayer)\n        return;\n    bool scrollingCoordinatorHandlesOffset = false;\n    if (ScrollingCoordinator* scrollingCoordinator = this->scrollingCoordinator()) {\n        if (Settings* settings = m_renderView->document().settings()) {\n            if (isMainFrame() || settings->compositedScrollingForFramesEnabled())\n                scrollingCoordinatorHandlesOffset = scrollingCoordinator->scrollableAreaScrollLayerDidChange(frameView);\n        }\n    }\n    if (scrollingCoordinatorHandlesOffset)\n        m_scrollLayer->setPosition(-frameView->minimumScrollPosition());\n    else\n        m_scrollLayer->setPosition(-scrollPosition);\n    blink::Platform::current()->histogramEnumeration(\"Renderer.AcceleratedFixedRootBackground\",\n        ScrolledMainFrameBucket,\n        AcceleratedFixedRootBackgroundHistogramMax);\n     if (!m_renderView->rootBackgroundIsEntirelyFixed())\n         return;\n     blink::Platform::current()->histogramEnumeration(\"Renderer.AcceleratedFixedRootBackground\",\n         !!fixedRootBackgroundLayer()\n             ? ScrolledMainFrameWithAcceleratedFixedRootBackground\n            : ScrolledMainFrameWithUnacceleratedFixedRootBackground,\n        AcceleratedFixedRootBackgroundHistogramMax);\n}", "target": 1}
{"code": "static int get_dev_to_use(struct spk_synth *synth, dev_t *dev_no)\n{\n\tif (strcmp(synth->dev_name, SYNTH_DEFAULT_DEV) ||\n\t    synth->ser == SYNTH_DEFAULT_SER)\n\t\treturn tty_dev_name_to_number(synth->dev_name, dev_no);\n\treturn ser_to_dev(synth->ser, dev_no);\n}", "target": 0}
{"code": "xmlPushInput(xmlParserCtxtPtr ctxt, xmlParserInputPtr input) {\n    int ret;\n    if (input == NULL) return(-1);\n    if (xmlParserDebugEntities) {\n\tif ((ctxt->input != NULL) && (ctxt->input->filename))\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"%s(%d): \", ctxt->input->filename,\n\t\t    ctxt->input->line);\n\txmlGenericError(xmlGenericErrorContext,\n\t\t\"Pushing input %d : %.30s\\n\", ctxt->inputNr+1, input->cur);\n    }\n    ret = inputPush(ctxt, input);\n    if (ctxt->instate == XML_PARSER_EOF)\n        return(-1);\n    GROW;\n    return(ret);\n}", "target": 0}
{"code": "GF_Box *sgpd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleGroupDescriptionBox, GF_ISOM_BOX_TYPE_SGPD);\n\ttmp->version = 1;\n\ttmp->group_descriptions = gf_list_new();\n\treturn (GF_Box *)tmp;\n}", "target": 0}
{"code": "CLua::~CLua()\n{\n    const vector<lua_shutdown_listener*> slisteners = shutdown_listeners;\n    for (lua_shutdown_listener *listener : slisteners)\n        listener->shutdown(*this);\n    shutting_down = true;\n    if (_state)\n        lua_close(_state);\n}", "target": 0}
{"code": "    void TimeValue::setTime( const Time& src )\n    {\n        std::memcpy(&time_, &src, sizeof(time_));\n    }", "target": 0}
{"code": "static inline Quantum GetPixelChannel(const Image *magick_restrict image,\n  const PixelChannel channel,const Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[channel].traits == UndefinedPixelTrait)\n    return((Quantum) 0);\n  return(pixel[image->channel_map[channel].offset]);\n}", "target": 1}
{"code": "bool UnbufferedAsioTlsStream::IsVerifyOK() const\n{\n\treturn m_VerifyOK;\n}", "target": 1}
{"code": "static CPINLINE zend_class_entry* swoole_try_get_ce(zend_string *class_name)\n{\n    zend_class_entry *ce = zend_lookup_class(class_name);\n    if (ce)\n    {\n        return ce;\n    }\n    zval user_func, args[1], retval;\n    if ((PG(unserialize_callback_func) == NULL) || (PG(unserialize_callback_func)[0] == '\\0'))\n    {\n        zend_throw_exception_ex(NULL, 0, \"can not find class %s\", class_name->val TSRMLS_CC);\n        return NULL;\n    }\n    zend_string *fname = swoole_string_init(ZEND_STRL(PG(unserialize_callback_func)));\n    Z_STR(user_func) = fname;\n    Z_TYPE_INFO(user_func) = IS_STRING_EX;\n    ZVAL_STR(&args[0], class_name);\n    call_user_function_ex(CG(function_table), NULL, &user_func, &retval, 1, args, 0, NULL);\n    swoole_string_release(fname);\n    ce = zend_lookup_class(class_name);\n    if (!ce)\n    {\n        zend_throw_exception_ex(NULL, 0, \"can not find class %s\", class_name->val TSRMLS_CC);\n        return NULL;\n    }\n    else\n    {\n        return ce;\n    }\n}", "target": 1}
{"code": "static void vmci_transport_peer_attach_cb(u32 sub_id,\n\t\t\t\t\t  const struct vmci_event_data *e_data,\n\t\t\t\t\t  void *client_data)\n{\n\tstruct sock *sk = client_data;\n\tconst struct vmci_event_payload_qp *e_payload;\n\tstruct vsock_sock *vsk;\n\te_payload = vmci_event_data_const_payload(e_data);\n\tvsk = vsock_sk(sk);\n\tlocal_bh_disable();\n\tbh_lock_sock(sk);\n\tif (vmci_handle_is_equal(vmci_trans(vsk)->qp_handle,\n\t\t\t\t e_payload->handle)) {\n\t\tgoto out;\n\t}\nout:\n\tbh_unlock_sock(sk);\n\tlocal_bh_enable();\n}", "target": 0}
{"code": "static int file_cb(\n\tconst git_diff_delta *delta,\n\tfloat progress,\n\tvoid *payload)\n{\n\tstruct diff_data *diff_data = payload;\n\tGIT_UNUSED(progress);\n\tif (delta->old_file.path)\n\t\tdiff_data->old_path = git__strdup(delta->old_file.path);\n\tif (delta->new_file.path)\n\t\tdiff_data->new_path = git__strdup(delta->new_file.path);\n\tgit_oid_cpy(&diff_data->old_id, &delta->old_file.id);\n\tgit_oid_cpy(&diff_data->new_id, &delta->new_file.id);\n\treturn 0;\n}", "target": 0}
{"code": "static int kvp_process_ip_address(void *addrp,\n\t\t\t\tint family, char *buffer,\n\t\t\t\tint length,  int *offset)\n{\n\tstruct sockaddr_in *addr;\n\tstruct sockaddr_in6 *addr6;\n\tint addr_length;\n\tchar tmp[50];\n\tconst char *str;\n\tif (family == AF_INET) {\n\t\taddr = (struct sockaddr_in *)addrp;\n\t\tstr = inet_ntop(family, &addr->sin_addr, tmp, 50);\n\t\taddr_length = INET_ADDRSTRLEN;\n\t} else {\n\t\taddr6 = (struct sockaddr_in6 *)addrp;\n\t\tstr = inet_ntop(family, &addr6->sin6_addr.s6_addr, tmp, 50);\n\t\taddr_length = INET6_ADDRSTRLEN;\n\t}\n\tif ((length - *offset) < addr_length + 2)\n\t\treturn HV_E_FAIL;\n\tif (str == NULL) {\n\t\tstrcpy(buffer, \"inet_ntop failed\\n\");\n\t\treturn HV_E_FAIL;\n\t}\n\tif (*offset == 0)\n\t\tstrcpy(buffer, tmp);\n\telse {\n\t\tstrcat(buffer, \";\");\n\t\tstrcat(buffer, tmp);\n\t}\n\t*offset += strlen(str) + 1;\n\treturn 0;\n}", "target": 0}
{"code": "static __init int vdso_fixup_datapage(struct lib32_elfinfo *v32,\n\t\t\t\t       struct lib64_elfinfo *v64)\n{\n\tElf32_Sym *sym32;\n#ifdef CONFIG_PPC64\n\tElf64_Sym *sym64;\n       \tsym64 = find_symbol64(v64, \"__kernel_datapage_offset\");\n\tif (sym64 == NULL) {\n\t\tprintk(KERN_ERR \"vDSO64: Can't find symbol \"\n\t\t       \"__kernel_datapage_offset !\\n\");\n\t\treturn -1;\n\t}\n\t*((int *)(vdso64_kbase + sym64->st_value - VDSO64_LBASE)) =\n\t\t(vdso64_pages << PAGE_SHIFT) -\n\t\t(sym64->st_value - VDSO64_LBASE);\n#endif \n\tsym32 = find_symbol32(v32, \"__kernel_datapage_offset\");\n\tif (sym32 == NULL) {\n\t\tprintk(KERN_ERR \"vDSO32: Can't find symbol \"\n\t\t       \"__kernel_datapage_offset !\\n\");\n\t\treturn -1;\n\t}\n\t*((int *)(vdso32_kbase + (sym32->st_value - VDSO32_LBASE))) =\n\t\t(vdso32_pages << PAGE_SHIFT) -\n\t\t(sym32->st_value - VDSO32_LBASE);\n\treturn 0;\n}", "target": 0}
{"code": "static int digi_startup(struct usb_serial *serial)\n{\n\tstruct device *dev = &serial->interface->dev;\n\tstruct digi_serial *serial_priv;\n\tint ret;\n\tint i;\n\tif (serial->num_port_pointers < serial->type->num_ports + 1) {\n\t\tdev_err(dev, \"OOB endpoints missing\\n\");\n\t\treturn -ENODEV;\n\t}\n\tfor (i = 0; i < serial->type->num_ports + 1 ; i++) {\n\t\tif (!serial->port[i]->read_urb) {\n\t\t\tdev_err(dev, \"bulk-in endpoint missing\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tif (!serial->port[i]->write_urb) {\n\t\t\tdev_err(dev, \"bulk-out endpoint missing\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\tserial_priv = kzalloc(sizeof(*serial_priv), GFP_KERNEL);\n\tif (!serial_priv)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&serial_priv->ds_serial_lock);\n\tserial_priv->ds_oob_port_num = serial->type->num_ports;\n\tserial_priv->ds_oob_port = serial->port[serial_priv->ds_oob_port_num];\n\tret = digi_port_init(serial_priv->ds_oob_port,\n\t\t\t\t\t\tserial_priv->ds_oob_port_num);\n\tif (ret) {\n\t\tkfree(serial_priv);\n\t\treturn ret;\n\t}\n\tusb_set_serial_data(serial, serial_priv);\n\treturn 0;\n}", "target": 0}
{"code": "make_month(const char *s)\n{\n    int i;\n    char month[3];\n    month[0] = xtoupper(*s);\n    if (!month[0])\n        return -1; \n    month[1] = xtolower(*(s + 1));\n    if (!month[1])\n        return -1; \n    month[2] = xtolower(*(s + 2));\n    for (i = 0; i < 12; i++)\n        if (!strncmp(month_names[i], month, 3))\n            return i;\n    return -1;\n}", "target": 0}
{"code": "zend_object_iterator *spl_filesystem_tree_get_iterator(zend_class_entry *ce, zval *object, int by_ref TSRMLS_DC)\n{\n\tspl_filesystem_iterator *iterator;\n\tspl_filesystem_object *dir_object;\n\tif (by_ref) {\n\t\tzend_error(E_ERROR, \"An iterator cannot be used with foreach by reference\");\n\t}\n\tdir_object = (spl_filesystem_object*)zend_object_store_get_object(object TSRMLS_CC);\n\titerator   = spl_filesystem_object_to_iterator(dir_object);\n\tif (iterator->intern.data == NULL) {\n\t\titerator->intern.data = object;\n\t\titerator->intern.funcs = &spl_filesystem_tree_it_funcs;\n\t}\n\tzval_add_ref(&object);\n\treturn (zend_object_iterator*)iterator;\n}", "target": 0}
{"code": "static int dns_stream_complete(DnsStream *s, int error) {\n        assert(s);\n#if ENABLE_DNS_OVER_TLS\n        if (s->encrypted) {\n                int r;\n                r = dnstls_stream_shutdown(s, error);\n                if (r != -EAGAIN)\n                        dns_stream_stop(s);\n        } else\n#endif\n                dns_stream_stop(s);\n        if (s->complete)\n                s->complete(s, error);\n        else \n                dns_stream_unref(s);\n        return 0;\n}", "target": 1}
{"code": "static struct btrfs_device *find_device(struct btrfs_fs_devices *fs_devices,\n\t\tu64 devid, const u8 *uuid)\n{\n\tstruct btrfs_device *dev;\n\tlist_for_each_entry(dev, &fs_devices->devices, dev_list) {\n\t\tif (dev->devid == devid &&\n\t\t    (!uuid || !memcmp(dev->uuid, uuid, BTRFS_UUID_SIZE))) {\n\t\t\treturn dev;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "ns_client_isself(dns_view_t *myview, dns_tsigkey_t *mykey,\n\t\t isc_sockaddr_t *srcaddr, isc_sockaddr_t *dstaddr,\n\t\t dns_rdataclass_t rdclass, void *arg)\n{\n\tdns_view_t *view;\n\tdns_tsigkey_t *key = NULL;\n\tdns_name_t *tsig = NULL;\n\tisc_netaddr_t netsrc;\n\tisc_netaddr_t netdst;\n\tUNUSED(arg);\n\tif (ns_g_server->interfacemgr == NULL)\n\t\treturn (true);\n\tif (!ns_interfacemgr_listeningon(ns_g_server->interfacemgr, dstaddr))\n\t\treturn (false);\n\tisc_netaddr_fromsockaddr(&netsrc, srcaddr);\n\tisc_netaddr_fromsockaddr(&netdst, dstaddr);\n\tfor (view = ISC_LIST_HEAD(ns_g_server->viewlist);\n\t     view != NULL;\n\t     view = ISC_LIST_NEXT(view, link)) {\n\t\tif (view->matchrecursiveonly)\n\t\t\tcontinue;\n\t\tif (rdclass != view->rdclass)\n\t\t\tcontinue;\n\t\tif (mykey != NULL) {\n\t\t\tbool match;\n\t\t\tisc_result_t result;\n\t\t\tresult = dns_view_gettsig(view, &mykey->name, &key);\n\t\t\tif (result != ISC_R_SUCCESS)\n\t\t\t\tcontinue;\n\t\t\tmatch = dst_key_compare(mykey->key, key->key);\n\t\t\tdns_tsigkey_detach(&key);\n\t\t\tif (!match)\n\t\t\t\tcontinue;\n\t\t\ttsig = dns_tsigkey_identity(mykey);\n\t\t}\n\t\tif (allowed(&netsrc, tsig, NULL, 0, NULL,\n\t\t\t    view->matchclients) &&\n\t\t    allowed(&netdst, tsig, NULL, 0, NULL,\n\t\t\t    view->matchdestinations))\n\t\t\tbreak;\n\t}\n\treturn (view == myview);\n}", "target": 0}
{"code": "static int encode_open_downgrade(struct xdr_stream *xdr, const struct nfs_closeargs *arg)\n{\n\t__be32 *p;\n\tRESERVE_SPACE(4+NFS4_STATEID_SIZE+4);\n\tWRITE32(OP_OPEN_DOWNGRADE);\n\tWRITEMEM(arg->stateid->data, NFS4_STATEID_SIZE);\n\tWRITE32(arg->seqid->sequence->counter);\n\tencode_share_access(xdr, arg->open_flags);\n\treturn 0;\n}", "target": 1}
{"code": "MagickExport void *AcquireQuantumMemory(const size_t count,const size_t quantum)\n{\n  size_t\n    extent;\n  if (CheckMemoryOverflow(count,quantum) != MagickFalse)\n    return((void *) NULL);\n  extent=count*quantum;\n  return(AcquireMagickMemory(extent));\n}", "target": 1}
{"code": "MagickPrivate size_t GetOptimalKernelWidth2D(const double radius,\n  const double sigma)\n{\n  double\n    alpha,\n    beta,\n    gamma,\n    normalize,\n    value;\n  size_t\n    width;\n  ssize_t\n    j,\n    u,\n    v;\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  if (radius > MagickEpsilon)\n    return((size_t) (2.0*ceil(radius)+1.0));\n  gamma=fabs(sigma);\n  if (gamma <= MagickEpsilon)\n    return(3UL);\n  alpha=PerceptibleReciprocal(2.0*gamma*gamma);\n  beta=(double) PerceptibleReciprocal((double) Magick2PI*gamma*gamma);\n  for (width=5; ; )\n  {\n    normalize=0.0;\n    j=(ssize_t) (width-1)/2;\n    for (v=(-j); v <= j; v++)\n      for (u=(-j); u <= j; u++)\n        normalize+=exp(-((double) (u*u+v*v))*alpha)*beta;\n    value=exp(-((double) (j*j))*alpha)*beta/normalize;\n    if ((value < QuantumScale) || (value < MagickEpsilon))\n      break;\n    width+=2;\n  }\n  return((size_t) (width-2));\n}", "target": 0}
{"code": "static struct key *request_user_key(const char *master_desc, const u8 **master_key,\n\t\t\t\t    size_t *master_keylen)\n{\n\tconst struct user_key_payload *upayload;\n\tstruct key *ukey;\n\tukey = request_key(&key_type_user, master_desc, NULL);\n\tif (IS_ERR(ukey))\n\t\tgoto error;\n\tdown_read(&ukey->sem);\n\tupayload = user_key_payload_locked(ukey);\n\t*master_key = upayload->data;\n\t*master_keylen = upayload->datalen;\nerror:\n\treturn ukey;\n}", "target": 0}
{"code": "mm_append_debug(Buffer *m)\n{\n\tif (auth_debug_init && buffer_len(&auth_debug)) {\n\t\tdebug3(\"%s: Appending debug messages for child\", __func__);\n\t\tbuffer_append(m, buffer_ptr(&auth_debug),\n\t\t    buffer_len(&auth_debug));\n\t\tbuffer_clear(&auth_debug);\n\t}\n}", "target": 0}
{"code": "static int connection_handle_write(request_st * const r, connection * const con) {\n\tif (con->is_writable <= 0) return CON_STATE_WRITE;\n\tint rc = connection_write_chunkqueue(con, con->write_queue, MAX_WRITE_LIMIT);\n\tswitch (rc) {\n\tcase 0:\n\t\tif (r->resp_body_finished) {\n\t\t\tconnection_set_state(r, CON_STATE_RESPONSE_END);\n\t\t\treturn CON_STATE_RESPONSE_END;\n\t\t}\n\t\tbreak;\n\tcase -1: \n\t\tlog_error(r->conf.errh, __FILE__, __LINE__,\n\t\t  \"connection closed: write failed on fd %d\", con->fd);\n\t\tconnection_set_state_error(r, CON_STATE_ERROR);\n\t\treturn CON_STATE_ERROR;\n\tcase -2: \n\t\tconnection_set_state_error(r, CON_STATE_ERROR);\n\t\treturn CON_STATE_ERROR;\n\tcase 1:\n\t\tif (con->write_queue->bytes_out)\n\t\t\tcon->is_writable = 0;\n\t\tbreak;\n\t}\n\treturn CON_STATE_WRITE; \n}", "target": 0}
{"code": "  inline Eigen::IndexList<int, Eigen::type2index<1>> NByOne(int n) {\n    Eigen::IndexList<int, Eigen::type2index<1>> ret;\n    ret.set(0, n);\n    return ret;\n  }", "target": 1}
{"code": "ConnStateData::checkLogging()\n{\n    if (bodyPipe)\n        return;\n    if (!pipeline.empty() && pipeline.back()->mayUseConnection())\n        return;\n    if (pipeline.nrequests && inBuf.isEmpty())\n        return;\n    ClientHttpRequest http(this);\n    http.req_sz = inBuf.length();\n    http.setErrorUri(\"error:transaction-end-before-headers\");\n}", "target": 0}
{"code": "NTSTATUS get_ea_value_fsp(TALLOC_CTX *mem_ctx,\n\t\t\t  files_struct *fsp,\n\t\t\t  const char *ea_name,\n\t\t\t  struct ea_struct *pea)\n{\n\tsize_t attr_size = 256;\n\tchar *val = NULL;\n\tssize_t sizeret;\n\tsize_t max_xattr_size = 0;\n\tif (fsp == NULL) {\n\t\treturn NT_STATUS_INVALID_HANDLE;\n\t}\n\tmax_xattr_size = lp_smbd_max_xattr_size(SNUM(fsp->conn));\n again:\n\tval = talloc_realloc(mem_ctx, val, char, attr_size);\n\tif (!val) {\n\t\treturn NT_STATUS_NO_MEMORY;\n\t}\n\tsizeret = SMB_VFS_FGETXATTR(fsp, ea_name, val, attr_size);\n\tif (sizeret == -1 && errno == ERANGE && attr_size < max_xattr_size) {\n\t\tattr_size = max_xattr_size;\n\t\tgoto again;\n\t}\n\tif (sizeret == -1) {\n\t\treturn map_nt_error_from_unix(errno);\n\t}\n\tDEBUG(10,(\"get_ea_value: EA %s is of length %u\\n\", ea_name, (unsigned int)sizeret));\n\tdump_data(10, (uint8_t *)val, sizeret);\n\tpea->flags = 0;\n\tif (strnequal(ea_name, \"user.\", 5)) {\n\t\tpea->name = talloc_strdup(mem_ctx, &ea_name[5]);\n\t} else {\n\t\tpea->name = talloc_strdup(mem_ctx, ea_name);\n\t}\n\tif (pea->name == NULL) {\n\t\tTALLOC_FREE(val);\n\t\treturn NT_STATUS_NO_MEMORY;\n\t}\n\tpea->value.data = (unsigned char *)val;\n\tpea->value.length = (size_t)sizeret;\n\treturn NT_STATUS_OK;\n}", "target": 0}
{"code": "struct key *rxrpc_get_null_key(const char *keyname)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct key *key;\n\tint ret;\n\tkey = key_alloc(&key_type_rxrpc, keyname,\n\t\t\tGLOBAL_ROOT_UID, GLOBAL_ROOT_GID, cred,\n\t\t\tKEY_POS_SEARCH, KEY_ALLOC_NOT_IN_QUOTA);\n\tif (IS_ERR(key))\n\t\treturn key;\n\tret = key_instantiate_and_link(key, NULL, 0, NULL, NULL);\n\tif (ret < 0) {\n\t\tkey_revoke(key);\n\t\tkey_put(key);\n\t\treturn ERR_PTR(ret);\n\t}\n\treturn key;\n}", "target": 0}
{"code": "rx_cache_find(const struct rx_header *rxh, const struct ip *ip, int sport,\n\t      int32_t *opcode)\n{\n\tint i;\n\tstruct rx_cache_entry *rxent;\n\tuint32_t clip;\n\tuint32_t sip;\n\tUNALIGNED_MEMCPY(&clip, &ip->ip_dst, sizeof(uint32_t));\n\tUNALIGNED_MEMCPY(&sip, &ip->ip_src, sizeof(uint32_t));\n\ti = rx_cache_hint;\n\tdo {\n\t\trxent = &rx_cache[i];\n\t\tif (rxent->callnum == EXTRACT_32BITS(&rxh->callNumber) &&\n\t\t    rxent->client.s_addr == clip &&\n\t\t    rxent->server.s_addr == sip &&\n\t\t    rxent->serviceId == EXTRACT_32BITS(&rxh->serviceId) &&\n\t\t    rxent->dport == sport) {\n\t\t\trx_cache_hint = i;\n\t\t\t*opcode = rxent->opcode;\n\t\t\treturn(1);\n\t\t}\n\t\tif (++i >= RX_CACHE_SIZE)\n\t\t\ti = 0;\n\t} while (i != rx_cache_hint);\n\treturn(0);\n}", "target": 1}
{"code": "static int snd_usb_cm6206_boot_quirk(struct usb_device *dev)\n{\n\tint err  = 0, reg;\n\tint val[] = {0x2004, 0x3000, 0xf800, 0x143f, 0x0000, 0x3000};\n\tfor (reg = 0; reg < ARRAY_SIZE(val); reg++) {\n\t\terr = snd_usb_cm106_write_int_reg(dev, reg, val[reg]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn err;\n}", "target": 0}
{"code": "void vnc_zlib_clear(VncState *vs)\n{\n    if (vs->zlib.stream.opaque) {\n        deflateEnd(&vs->zlib.stream);\n    }\n    buffer_free(&vs->zlib.zlib);\n}", "target": 0}
{"code": "static struct nfs4_ff_layout_mirror *ff_layout_alloc_mirror(gfp_t gfp_flags)\n{\n\tstruct nfs4_ff_layout_mirror *mirror;\n\tmirror = kzalloc(sizeof(*mirror), gfp_flags);\n\tif (mirror != NULL) {\n\t\tspin_lock_init(&mirror->lock);\n\t\trefcount_set(&mirror->ref, 1);\n\t\tINIT_LIST_HEAD(&mirror->mirrors);\n\t}\n\treturn mirror;\n}", "target": 0}
{"code": "addCharacterClass (FileInfo * nested, const widechar * name, int length)\n{\n  struct CharacterClass *class;\n  if (characterClassAttribute)\n    {\n      if (!(class = malloc (sizeof (*class) + CHARSIZE * (length - 1))))\n\toutOfMemory ();\n      else\n\t{\n\t  memset (class, 0, sizeof (*class));\n\t  memcpy (class->name, name, CHARSIZE * (class->length = length));\n\t  class->attribute = characterClassAttribute;\n\t  characterClassAttribute <<= 1;\n\t  class->next = characterClasses;\n\t  characterClasses = class;\n\t  return class;\n\t}\n    }\n  compileError (nested, \"character class table overflow.\");\n  return NULL;\n}", "target": 0}
{"code": "static int ext4_writepage(struct page *page,\n\t\t\t  struct writeback_control *wbc)\n{\n\tint ret = 0;\n\tloff_t size;\n\tunsigned int len;\n\tstruct buffer_head *page_bufs;\n\tstruct inode *inode = page->mapping->host;\n\ttrace_ext4_writepage(inode, page);\n\tsize = i_size_read(inode);\n\tif (page->index == size >> PAGE_CACHE_SHIFT)\n\t\tlen = size & ~PAGE_CACHE_MASK;\n\telse\n\t\tlen = PAGE_CACHE_SIZE;\n\tif (page_has_buffers(page)) {\n\t\tpage_bufs = page_buffers(page);\n\t\tif (walk_page_buffers(NULL, page_bufs, 0, len, NULL,\n\t\t\t\t\text4_bh_delay_or_unwritten)) {\n\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\tunlock_page(page);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tret = block_prepare_write(page, 0, len,\n\t\t\t\t\t  noalloc_get_block_write);\n\t\tif (!ret) {\n\t\t\tpage_bufs = page_buffers(page);\n\t\t\tif (walk_page_buffers(NULL, page_bufs, 0, len, NULL,\n\t\t\t\t\t\text4_bh_delay_or_unwritten)) {\n\t\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\t\tunlock_page(page);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else {\n\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\tunlock_page(page);\n\t\t\treturn 0;\n\t\t}\n\t\tblock_commit_write(page, 0, len);\n\t}\n\tif (PageChecked(page) && ext4_should_journal_data(inode)) {\n\t\tClearPageChecked(page);\n\t\treturn __ext4_journalled_writepage(page, len);\n\t}\n\tif (test_opt(inode->i_sb, NOBH) && ext4_should_writeback_data(inode))\n\t\tret = nobh_writepage(page, noalloc_get_block_write, wbc);\n\telse\n\t\tret = block_write_full_page(page, noalloc_get_block_write,\n\t\t\t\t\t    wbc);\n\treturn ret;\n}", "target": 1}
{"code": "static int nl80211_parse_key_new(struct nlattr *key, struct key_parse *k)\n{\n\tstruct nlattr *tb[NL80211_KEY_MAX + 1];\n\tint err = nla_parse_nested(tb, NL80211_KEY_MAX, key,\n\t\t\t\t   nl80211_key_policy);\n\tif (err)\n\t\treturn err;\n\tk->def = !!tb[NL80211_KEY_DEFAULT];\n\tk->defmgmt = !!tb[NL80211_KEY_DEFAULT_MGMT];\n\tif (k->def) {\n\t\tk->def_uni = true;\n\t\tk->def_multi = true;\n\t}\n\tif (k->defmgmt)\n\t\tk->def_multi = true;\n\tif (tb[NL80211_KEY_IDX])\n\t\tk->idx = nla_get_u8(tb[NL80211_KEY_IDX]);\n\tif (tb[NL80211_KEY_DATA]) {\n\t\tk->p.key = nla_data(tb[NL80211_KEY_DATA]);\n\t\tk->p.key_len = nla_len(tb[NL80211_KEY_DATA]);\n\t}\n\tif (tb[NL80211_KEY_SEQ]) {\n\t\tk->p.seq = nla_data(tb[NL80211_KEY_SEQ]);\n\t\tk->p.seq_len = nla_len(tb[NL80211_KEY_SEQ]);\n\t}\n\tif (tb[NL80211_KEY_CIPHER])\n\t\tk->p.cipher = nla_get_u32(tb[NL80211_KEY_CIPHER]);\n\tif (tb[NL80211_KEY_TYPE]) {\n\t\tk->type = nla_get_u32(tb[NL80211_KEY_TYPE]);\n\t\tif (k->type < 0 || k->type >= NUM_NL80211_KEYTYPES)\n\t\t\treturn -EINVAL;\n\t}\n\tif (tb[NL80211_KEY_DEFAULT_TYPES]) {\n\t\tstruct nlattr *kdt[NUM_NL80211_KEY_DEFAULT_TYPES];\n\t\terr = nla_parse_nested(kdt, NUM_NL80211_KEY_DEFAULT_TYPES - 1,\n\t\t\t\t       tb[NL80211_KEY_DEFAULT_TYPES],\n\t\t\t\t       nl80211_key_default_policy);\n\t\tif (err)\n\t\t\treturn err;\n\t\tk->def_uni = kdt[NL80211_KEY_DEFAULT_TYPE_UNICAST];\n\t\tk->def_multi = kdt[NL80211_KEY_DEFAULT_TYPE_MULTICAST];\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static void csi_X(struct vc_data *vc, int vpar) \n{\t\t\t\t\t  \n\tint count;\n\tif (!vpar)\n\t\tvpar++;\n\tcount = (vpar > vc->vc_cols - vc->vc_x) ? (vc->vc_cols - vc->vc_x) : vpar;\n\tvc_uniscr_clear_line(vc, vc->vc_x, count);\n\tscr_memsetw((unsigned short *)vc->vc_pos, vc->vc_video_erase_char, 2 * count);\n\tif (con_should_update(vc))\n\t\tvc->vc_sw->con_clear(vc, vc->vc_y, vc->vc_x, 1, count);\n\tvc->vc_need_wrap = 0;\n}", "target": 0}
{"code": "    int MemIo::seek(int64 offset, Position pos )\n    {\n        int64 newIdx = 0;\n        switch (pos) {\n            case BasicIo::cur:\n                newIdx = p_->idx_ + offset;\n                break;\n            case BasicIo::beg:\n                newIdx = offset;\n                break;\n            case BasicIo::end:\n                newIdx = p_->size_ + offset;\n                break;\n        }\n        if (newIdx < 0)\n            return 1;\n        p_->idx_ = static_cast<long>(newIdx);   \n        p_->eof_ = false;\n        return 0;\n    }", "target": 1}
{"code": "void _WM_do_control_channel_pan(struct _mdi *mdi, struct _event_data *data) {\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n    mdi->channel[ch].pan = data->data.value;\n    _WM_AdjustChannelVolumes(mdi, ch);\n}", "target": 0}
{"code": "static void increment_offset(int64_t delta)\n{\n    if (unlikely(delta == 0))\n        return;\n    location.offset += delta;\n    set_curr_offs(location.offset);\n}", "target": 0}
{"code": "static struct phy *serdes_simple_xlate(struct device *dev,\n\t\t\t\t       struct of_phandle_args *args)\n{\n\tstruct serdes_ctrl *ctrl = dev_get_drvdata(dev);\n\tunsigned int port, idx, i;\n\tif (args->args_count != 2)\n\t\treturn ERR_PTR(-EINVAL);\n\tport = args->args[0];\n\tidx = args->args[1];\n\tfor (i = 0; i <= SERDES_MAX; i++) {\n\t\tstruct serdes_macro *macro = phy_get_drvdata(ctrl->phys[i]);\n\t\tif (idx != macro->idx)\n\t\t\tcontinue;\n\t\tif (idx != SERDES6G(0) && macro->port >= 0)\n\t\t\treturn ERR_PTR(-EBUSY);\n\t\tmacro->port = port;\n\t\treturn ctrl->phys[i];\n\t}\n\treturn ERR_PTR(-ENODEV);\n}", "target": 1}
{"code": "sync_create_state_control(Slapi_Entry *e, LDAPControl **ctrlp, int type, Sync_Cookie *cookie)\n{\n    int rc;\n    BerElement *ber;\n    struct berval *bvp;\n    char *uuid;\n    Slapi_Attr *attr;\n    Slapi_Value *val;\n    if (type == LDAP_SYNC_NONE || ctrlp == NULL || (ber = der_alloc()) == NULL) {\n        return (LDAP_OPERATIONS_ERROR);\n    }\n    *ctrlp = NULL;\n    slapi_entry_attr_find(e, SLAPI_ATTR_UNIQUEID, &attr);\n    slapi_attr_first_value(attr, &val);\n    uuid = sync_nsuniqueid2uuid(slapi_value_get_string(val));\n    if ((rc = ber_printf(ber, \"{eo\", type, uuid, 16)) != -1) {\n        if (cookie) {\n            char *cookiestr = sync_cookie2str(cookie);\n            rc = ber_printf(ber, \"s}\", cookiestr);\n            slapi_ch_free((void **)&cookiestr);\n        } else {\n            rc = ber_printf(ber, \"}\");\n        }\n    }\n    if (rc != -1) {\n        rc = ber_flatten(ber, &bvp);\n    }\n    ber_free(ber, 1);\n    slapi_ch_free((void **)&uuid);\n    if (rc == -1) {\n        return (LDAP_OPERATIONS_ERROR);\n    }\n    *ctrlp = (LDAPControl *)slapi_ch_malloc(sizeof(LDAPControl));\n    (*ctrlp)->ldctl_iscritical = 0;\n    (*ctrlp)->ldctl_oid = slapi_ch_strdup(LDAP_CONTROL_SYNC_STATE);\n    (*ctrlp)->ldctl_value = *bvp; \n    bvp->bv_val = NULL;\n    ber_bvfree(bvp);\n    return (LDAP_SUCCESS);\n}", "target": 1}
{"code": "LUA_API void lua_upvaluejoin (lua_State *L, int fidx1, int n1,\n                                            int fidx2, int n2) {\n  LClosure *f1;\n  UpVal **up1 = getupvalref(L, fidx1, n1, &f1);\n  UpVal **up2 = getupvalref(L, fidx2, n2, NULL);\n  luaC_upvdeccount(L, *up1);\n  *up1 = *up2;\n  (*up1)->refcount++;\n  if (upisopen(*up1)) (*up1)->u.open.touched = 1;\n  luaC_upvalbarrier(L, *up1);\n}", "target": 1}
{"code": "int ipmi_validate_addr(struct ipmi_addr *addr, int len)\n{\n\tif (len < sizeof(struct ipmi_system_interface_addr))\n\t\treturn -EINVAL;\n\tif (addr->addr_type == IPMI_SYSTEM_INTERFACE_ADDR_TYPE) {\n\t\tif (addr->channel != IPMI_BMC_CHANNEL)\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\tif ((addr->channel == IPMI_BMC_CHANNEL)\n\t    || (addr->channel >= IPMI_MAX_CHANNELS)\n\t    || (addr->channel < 0))\n\t\treturn -EINVAL;\n\tif (is_ipmb_addr(addr) || is_ipmb_bcast_addr(addr)) {\n\t\tif (len < sizeof(struct ipmi_ipmb_addr))\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\tif (is_lan_addr(addr)) {\n\t\tif (len < sizeof(struct ipmi_lan_addr))\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}", "target": 0}
{"code": "static int mxf_read_sync(AVIOContext *pb, const uint8_t *key, unsigned size)\n{\n    int i, b;\n    for (i = 0; i < size && !avio_feof(pb); i++) {\n        b = avio_r8(pb);\n        if (b == key[0])\n            i = 0;\n        else if (b != key[i])\n            i = -1;\n    }\n    return i == size;\n}", "target": 0}
{"code": "static int verify_newpolicy_info(struct xfrm_userpolicy_info *p)\n{\n\tint ret;\n\tswitch (p->share) {\n\tcase XFRM_SHARE_ANY:\n\tcase XFRM_SHARE_SESSION:\n\tcase XFRM_SHARE_USER:\n\tcase XFRM_SHARE_UNIQUE:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tswitch (p->action) {\n\tcase XFRM_POLICY_ALLOW:\n\tcase XFRM_POLICY_BLOCK:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tswitch (p->sel.family) {\n\tcase AF_INET:\n\t\tif (p->sel.prefixlen_d > 32 || p->sel.prefixlen_s > 32)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AF_INET6:\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tif (p->sel.prefixlen_d > 128 || p->sel.prefixlen_s > 128)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n#else\n\t\treturn  -EAFNOSUPPORT;\n#endif\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tret = verify_policy_dir(p->dir);\n\tif (ret)\n\t\treturn ret;\n\tif (p->index && ((p->index & XFRM_POLICY_MAX) != p->dir))\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 1}
{"code": "void CLASS panasonic_load_raw()\n{\n  int row, col, i, j, sh = 0, pred[2], nonz[2];\n  pana_bits(0);\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < raw_width; col++)\n    {\n      if ((i = col % 14) == 0)\n        pred[0] = pred[1] = nonz[0] = nonz[1] = 0;\n      if (i % 3 == 2)\n        sh = 4 >> (3 - pana_bits(2));\n      if (nonz[i & 1])\n      {\n        if ((j = pana_bits(8)))\n        {\n          if ((pred[i & 1] -= 0x80 << sh) < 0 || sh == 4)\n            pred[i & 1] &= ~((~0u) << sh);\n          pred[i & 1] += j << sh;\n        }\n      }\n      else if ((nonz[i & 1] = pana_bits(8)) || i > 11)\n        pred[i & 1] = nonz[i & 1] << 4 | pana_bits(4);\n      if ((RAW(row, col) = pred[col & 1]) > 4098 && col < width)\n        derror();\n    }\n  }\n}", "target": 1}
{"code": "void IndexedDBDatabase::RenameIndex(IndexedDBTransaction* transaction,\n                                    int64_t object_store_id,\n                                    int64_t index_id,\n                                    const base::string16& new_name) {\n  DCHECK(transaction);\n  IDB_TRACE1(\"IndexedDBDatabase::RenameIndex\", \"txn.id\", transaction->id());\n  DCHECK_EQ(transaction->mode(),\n            blink::mojom::IDBTransactionMode::VersionChange);\n  if (!ValidateObjectStoreIdAndIndexId(object_store_id, index_id))\n    return;\n  IndexedDBIndexMetadata& index_metadata =\n      metadata_.object_stores[object_store_id].indexes[index_id];\n  base::string16 old_name;\n  Status s = metadata_coding_->RenameIndex(\n      transaction->BackingStoreTransaction()->transaction(),\n      transaction->database()->id(), object_store_id, new_name, &old_name,\n      &index_metadata);\n  if (!s.ok()) {\n    ReportErrorWithDetails(s, \"Internal error renaming index.\");\n    return;\n  }\n  DCHECK_EQ(index_metadata.name, new_name);\n  transaction->ScheduleAbortTask(\n      base::BindOnce(&IndexedDBDatabase::RenameIndexAbortOperation, this,\n                     object_store_id, index_id, std::move(old_name)));\n}", "target": 0}
{"code": "void FrameLoader::frameLoadCompleted()\n{\n    m_client->frameLoadCompleted();\n    history()->updateForFrameLoadCompleted();\n    if (m_documentLoader)\n        m_firstLayoutDone = true;\n}", "target": 0}
{"code": "void bootp_input(struct mbuf *m)\n{\n    struct bootp_t *bp = mtod_check(m, sizeof(struct bootp_t));\n    if (bp && bp->bp_op == BOOTP_REQUEST) {\n        bootp_reply(m->slirp, bp, m_end(m));\n    }\n}", "target": 0}
{"code": "struct bpf_map *bpf_map_get_with_uref(u32 ufd)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_map *map;\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn map;\n\tbpf_map_inc(map, true);\n\tfdput(f);\n\treturn map;\n}", "target": 1}
{"code": "accountingReportStats(XML_Parser originParser, const char *epilog) {\n  const XML_Parser rootParser = getRootParserOf(originParser, NULL);\n  assert(! rootParser->m_parentParser);\n  if (rootParser->m_accounting.debugLevel < 1) {\n    return;\n  }\n  const float amplificationFactor\n      = accountingGetCurrentAmplification(rootParser);\n  fprintf(stderr,\n          \"expat: Accounting(%p): Direct \" EXPAT_FMT_ULL(\n              \"10\") \", indirect \" EXPAT_FMT_ULL(\"10\") \", amplification %8.2f%s\",\n          (void *)rootParser, rootParser->m_accounting.countBytesDirect,\n          rootParser->m_accounting.countBytesIndirect,\n          (double)amplificationFactor, epilog);\n}", "target": 0}
{"code": "static inline int ccid_hc_rx_getsockopt(struct ccid *ccid, struct sock *sk,\n\t\t\t\t\tconst int optname, int len,\n\t\t\t\t\tu32 __user *optval, int __user *optlen)\n{\n\tint rc = -ENOPROTOOPT;\n\tif (ccid->ccid_ops->ccid_hc_rx_getsockopt != NULL)\n\t\trc = ccid->ccid_ops->ccid_hc_rx_getsockopt(sk, optname, len,\n\t\t\t\t\t\t optval, optlen);\n\treturn rc;\n}", "target": 1}
{"code": "isdn_statstr(void)\n{\n\tstatic char istatbuf[2048];\n\tchar *p;\n\tint i;\n\tsprintf(istatbuf, \"idmap:\\t\");\n\tp = istatbuf + strlen(istatbuf);\n\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\tsprintf(p, \"%s \", (dev->drvmap[i] < 0) ? \"-\" : dev->drvid[dev->drvmap[i]]);\n\t\tp = istatbuf + strlen(istatbuf);\n\t}\n\tsprintf(p, \"\\nchmap:\\t\");\n\tp = istatbuf + strlen(istatbuf);\n\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\tsprintf(p, \"%d \", dev->chanmap[i]);\n\t\tp = istatbuf + strlen(istatbuf);\n\t}\n\tsprintf(p, \"\\ndrmap:\\t\");\n\tp = istatbuf + strlen(istatbuf);\n\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\tsprintf(p, \"%d \", dev->drvmap[i]);\n\t\tp = istatbuf + strlen(istatbuf);\n\t}\n\tsprintf(p, \"\\nusage:\\t\");\n\tp = istatbuf + strlen(istatbuf);\n\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\tsprintf(p, \"%d \", dev->usage[i]);\n\t\tp = istatbuf + strlen(istatbuf);\n\t}\n\tsprintf(p, \"\\nflags:\\t\");\n\tp = istatbuf + strlen(istatbuf);\n\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++) {\n\t\tif (dev->drv[i]) {\n\t\t\tsprintf(p, \"%ld \", dev->drv[i]->online);\n\t\t\tp = istatbuf + strlen(istatbuf);\n\t\t} else {\n\t\t\tsprintf(p, \"? \");\n\t\t\tp = istatbuf + strlen(istatbuf);\n\t\t}\n\t}\n\tsprintf(p, \"\\nphone:\\t\");\n\tp = istatbuf + strlen(istatbuf);\n\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\tsprintf(p, \"%s \", dev->num[i]);\n\t\tp = istatbuf + strlen(istatbuf);\n\t}\n\tsprintf(p, \"\\n\");\n\treturn istatbuf;\n}", "target": 0}
{"code": "bool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, int *r, struct dest_map *dest_map)\n{\n\tstruct kvm_apic_map *map;\n\tunsigned long bitmap;\n\tstruct kvm_lapic **dst = NULL;\n\tint i;\n\tbool ret;\n\t*r = -1;\n\tif (irq->shorthand == APIC_DEST_SELF) {\n\t\t*r = kvm_apic_set_irq(src->vcpu, irq, dest_map);\n\t\treturn true;\n\t}\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\tret = kvm_apic_map_get_dest_lapic(kvm, &src, irq, map, &dst, &bitmap);\n\tif (ret) {\n\t\t*r = 0;\n\t\tfor_each_set_bit(i, &bitmap, 16) {\n\t\t\tif (!dst[i])\n\t\t\t\tcontinue;\n\t\t\t*r += kvm_apic_set_irq(dst[i]->vcpu, irq, dest_map);\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}", "target": 1}
{"code": "static int setup_config(int type)\n{\n\tint rv;\n\trv = read_config(cl.configfile, type);\n\tif (rv < 0)\n\t\tgoto out;\n\tif (is_auth_req()) {\n\t\trv = read_authkey();\n\t\tif (rv < 0)\n\t\t\tgoto out;\n#if HAVE_LIBGCRYPT\n\t\tif (!gcry_check_version(NULL)) {\n\t\t\tlog_error(\"gcry_check_version\");\n\t\t\trv = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tgcry_control(GCRYCTL_DISABLE_SECMEM, 0);\n\t\tgcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0);\n#endif\n\t}\n\tif (cl.type == DAEMON && cl.site[0]) {\n\t\tif (!find_site_by_name(cl.site, &local, 1)) {\n\t\t\tlog_error(\"Cannot find \\\"%s\\\" in the configuration.\",\n\t\t\t\t\tcl.site);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlocal->local = 1;\n\t} else\n\t\tfind_myself(NULL, type == CLIENT || type == GEOSTORE);\n\trv = check_config(type);\n\tif (rv < 0)\n\t\tgoto out;\n\tif (!cl.lockfile[0]) {\n\t\tsnprintf(cl.lockfile, sizeof(cl.lockfile)-1,\n\t\t\t\t\"%s/%s.pid\", BOOTH_RUN_DIR, booth_conf->name);\n\t}\nout:\n\treturn rv;\n}", "target": 1}
{"code": "static void bnx2x_hw_enable_status(struct bnx2x *bp)\n{\n\tu32 val;\n\tval = REG_RD(bp, CFC_REG_WEAK_ENABLE_PF);\n\tDP(BNX2X_MSG_SP, \"CFC_REG_WEAK_ENABLE_PF is 0x%x\\n\", val);\n\tval = REG_RD(bp, PBF_REG_DISABLE_PF);\n\tDP(BNX2X_MSG_SP, \"PBF_REG_DISABLE_PF is 0x%x\\n\", val);\n\tval = REG_RD(bp, IGU_REG_PCI_PF_MSI_EN);\n\tDP(BNX2X_MSG_SP, \"IGU_REG_PCI_PF_MSI_EN is 0x%x\\n\", val);\n\tval = REG_RD(bp, IGU_REG_PCI_PF_MSIX_EN);\n\tDP(BNX2X_MSG_SP, \"IGU_REG_PCI_PF_MSIX_EN is 0x%x\\n\", val);\n\tval = REG_RD(bp, IGU_REG_PCI_PF_MSIX_FUNC_MASK);\n\tDP(BNX2X_MSG_SP, \"IGU_REG_PCI_PF_MSIX_FUNC_MASK is 0x%x\\n\", val);\n\tval = REG_RD(bp, PGLUE_B_REG_SHADOW_BME_PF_7_0_CLR);\n\tDP(BNX2X_MSG_SP, \"PGLUE_B_REG_SHADOW_BME_PF_7_0_CLR is 0x%x\\n\", val);\n\tval = REG_RD(bp, PGLUE_B_REG_FLR_REQUEST_PF_7_0_CLR);\n\tDP(BNX2X_MSG_SP, \"PGLUE_B_REG_FLR_REQUEST_PF_7_0_CLR is 0x%x\\n\", val);\n\tval = REG_RD(bp, PGLUE_B_REG_INTERNAL_PFID_ENABLE_MASTER);\n\tDP(BNX2X_MSG_SP, \"PGLUE_B_REG_INTERNAL_PFID_ENABLE_MASTER is 0x%x\\n\",\n\t   val);\n}", "target": 0}
{"code": "static void array_cleanup( char* arr[] , int arr_size)\n{\n\tint i=0;\n\tfor( i=0; i< arr_size; i++ ){\n\t\tif( arr[i*2] ){\n\t\t\tefree( arr[i*2]);\n\t\t}\n\t}\n\tefree(arr);\n}", "target": 0}
{"code": "static void lsr_read_extend_class(GF_LASeRCodec *lsr, char **out_data, u32 *out_len, const char *name)\n{\n\tu32 len;\n\tGF_LSR_READ_INT(lsr, len, lsr->info->cfg.extensionIDBits, \"reserved\");\n\tlen = lsr_read_vluimsbf5(lsr, \"len\");\n\tgf_bs_read_long_int(lsr->bs, len);\n\tif (out_data) *out_data = NULL;\n\tif (out_len) *out_len = 0;\n}", "target": 1}
{"code": "void ConnectDialog::accept() {\n\tServerItem *si = static_cast<ServerItem *>(qtwServers->currentItem());\n\tif (! si || (bAllowHostLookup && si->qlAddresses.isEmpty()) || si->qsHostname.isEmpty()) {\n\t\tqWarning() << \"Invalid server\";\n\t\treturn;\n\t}\n\tqsPassword = si->qsPassword;\n\tqsServer = si->qsHostname;\n\tusPort = si->usPort;\n\tif (si->qsUsername.isEmpty()) {\n\t\tbool ok;\n\t\tQString defUserName = QInputDialog::getText(this, tr(\"Connecting to %1\").arg(si->qsName), tr(\"Enter username\"), QLineEdit::Normal, g.s.qsUsername, &ok).trimmed();\n\t\tif (! ok)\n\t\t\treturn;\n\t\tg.s.qsUsername = si->qsUsername = defUserName;\n\t}\n\tqsUsername = si->qsUsername;\n\tg.s.qsLastServer = si->qsName;\n\tQDialog::accept();\n}", "target": 0}
{"code": "static int get_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)\n{\n\tint ret;\n\tret = usb_control_msg(pegasus->usb, usb_rcvctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_GET_REGS, PEGASUS_REQT_READ, 0,\n\t\t\t      indx, data, size, 1000);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\treturn ret;\n}", "target": 1}
{"code": "Status InferenceContext::Multiply(DimensionHandle first,\n                                  DimensionOrConstant second,\n                                  DimensionHandle* out) {\n  const int64_t first_value = Value(first);\n  const int64_t second_value = Value(second);\n  if (first_value == 0) {\n    *out = first;\n  } else if (second_value == 0) {\n    *out = MakeDim(second);\n  } else if (first_value == 1) {\n    *out = MakeDim(second);\n  } else if (second_value == 1) {\n    *out = first;\n  } else if (first_value == kUnknownDim || second_value == kUnknownDim) {\n    *out = UnknownDim();\n  } else {\n    const int64_t product = first_value * second_value;\n    if (product < 0) {\n      return errors::InvalidArgument(\n          \"Negative dimension size caused by overflow when multiplying \",\n          first_value, \" and \", second_value);\n    }\n    *out = MakeDim(product);\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "static unsigned rb_calculate_event_length(unsigned length)\n{\n\tstruct ring_buffer_event event; \n\tif (!length)\n\t\tlength++;\n\tif (length > RB_MAX_SMALL_DATA || RB_FORCE_8BYTE_ALIGNMENT)\n\t\tlength += sizeof(event.array[0]);\n\tlength += RB_EVNT_HDR_SIZE;\n\tlength = ALIGN(length, RB_ARCH_ALIGNMENT);\n\tif (length == RB_LEN_TIME_EXTEND + RB_ALIGNMENT)\n\t\tlength += RB_ALIGNMENT;\n\treturn length;\n}", "target": 0}
{"code": "void color_cmyk_to_rgb(opj_image_t *image)\n{\n\tfloat C, M, Y, K;\n\tfloat sC, sM, sY, sK;\n\tunsigned int w, h, max, i;\n \tw = image->comps[0].w;\n \th = image->comps[0].h;\n\tif(image->numcomps < 4) return;\n \tmax = w * h;\n\tsC = 1.0F / (float)((1 << image->comps[0].prec) - 1);\n\tsM = 1.0F / (float)((1 << image->comps[1].prec) - 1);\n\tsY = 1.0F / (float)((1 << image->comps[2].prec) - 1);\n\tsK = 1.0F / (float)((1 << image->comps[3].prec) - 1);\n\tfor(i = 0; i < max; ++i)\n\t{\n\t\tC = (float)(image->comps[0].data[i]) * sC;\n\t\tM = (float)(image->comps[1].data[i]) * sM;\n\t\tY = (float)(image->comps[2].data[i]) * sY;\n\t\tK = (float)(image->comps[3].data[i]) * sK;\n\t\tC = 1.0F - C;\n\t\tM = 1.0F - M;\n\t\tY = 1.0F - Y;\n\t\tK = 1.0F - K;\n\t\timage->comps[0].data[i] = (int)(255.0F * C * K); \n\t\timage->comps[1].data[i] = (int)(255.0F * M * K); \n\t\timage->comps[2].data[i] = (int)(255.0F * Y * K); \n\t}\n\tfree(image->comps[3].data); image->comps[3].data = NULL;\n\timage->comps[0].prec = 8;\n\timage->comps[1].prec = 8;\n\timage->comps[2].prec = 8;\n\timage->numcomps -= 1;\n\timage->color_space = OPJ_CLRSPC_SRGB;\n\tfor (i = 3; i < image->numcomps; ++i) {\n\t\tmemcpy(&(image->comps[i]), &(image->comps[i+1]), sizeof(image->comps[i]));\n\t}\n}", "target": 1}
{"code": "static int copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb)\n{\n\tstruct xfrm_algo *algo;\n\tstruct nlattr *nla;\n\tnla = nla_reserve(skb, XFRMA_ALG_AUTH,\n\t\t\t  sizeof(*algo) + (auth->alg_key_len + 7) / 8);\n\tif (!nla)\n\t\treturn -EMSGSIZE;\n\talgo = nla_data(nla);\n\tstrcpy(algo->alg_name, auth->alg_name);\n\tmemcpy(algo->alg_key, auth->alg_key, (auth->alg_key_len + 7) / 8);\n\talgo->alg_key_len = auth->alg_key_len;\n\treturn 0;\n}", "target": 1}
{"code": "void Opal::Call::set_no_answer_forward (unsigned delay, const std::string & uri)\n{\n  forward_uri = uri;\n  NoAnswerTimer.SetInterval (0, PMIN (delay, 60));\n}", "target": 0}
{"code": "static void vnc_client_cache_addr(VncState *client)\n{\n    Error *err = NULL;\n    client->info = g_malloc0(sizeof(*client->info));\n    vnc_init_basic_info_from_remote_addr(client->sioc,\n                                         qapi_VncClientInfo_base(client->info),\n                                         &err);\n    client->info->websocket = client->websocket;\n    if (err) {\n        qapi_free_VncClientInfo(client->info);\n        client->info = NULL;\n        error_free(err);\n    }\n}", "target": 0}
{"code": "nfsd4_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tstruct nfs4_acl *acl)\n{\n\t__be32 error;\n\tint host_error;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tstruct posix_acl *pacl = NULL, *dpacl = NULL;\n\tunsigned int flags = 0;\n\terror = fh_verify(rqstp, fhp, 0, NFSD_MAY_SATTR);\n\tif (error)\n\t\treturn error;\n\tdentry = fhp->fh_dentry;\n\tinode = d_inode(dentry);\n\tif (!inode->i_op->set_acl || !IS_POSIXACL(inode))\n\t\treturn nfserr_attrnotsupp;\n\tif (S_ISDIR(inode->i_mode))\n\t\tflags = NFS4_ACL_DIR;\n\thost_error = nfs4_acl_nfsv4_to_posix(acl, &pacl, &dpacl, flags);\n\tif (host_error == -EINVAL)\n\t\treturn nfserr_attrnotsupp;\n\tif (host_error < 0)\n\t\tgoto out_nfserr;\n\thost_error = inode->i_op->set_acl(inode, pacl, ACL_TYPE_ACCESS);\n\tif (host_error < 0)\n\t\tgoto out_release;\n\tif (S_ISDIR(inode->i_mode)) {\n\t\thost_error = inode->i_op->set_acl(inode, dpacl,\n\t\t\t\t\t\t  ACL_TYPE_DEFAULT);\n\t}\nout_release:\n\tposix_acl_release(pacl);\n\tposix_acl_release(dpacl);\nout_nfserr:\n\tif (host_error == -EOPNOTSUPP)\n\t\treturn nfserr_attrnotsupp;\n\telse\n\t\treturn nfserrno(host_error);\n}", "target": 1}
{"code": "convert(\n    Imaging imOut, Imaging imIn, const char *mode, ImagingPalette palette, int dither) {\n    ImagingSectionCookie cookie;\n    ImagingShuffler convert;\n    int y;\n    if (!imIn) {\n        return (Imaging)ImagingError_ModeError();\n    }\n    if (!mode) {\n        if (!imIn->palette) {\n            return (Imaging)ImagingError_ModeError();\n        }\n        mode = imIn->palette->mode;\n    } else {\n        if (!strcmp(imIn->mode, mode)) {\n            return ImagingCopy2(imOut, imIn);\n        }\n    }\n    if (strcmp(imIn->mode, \"P\") == 0 || strcmp(imIn->mode, \"PA\") == 0) {\n        return frompalette(imOut, imIn, mode);\n    }\n    if (strcmp(mode, \"P\") == 0 || strcmp(mode, \"PA\") == 0) {\n        return topalette(imOut, imIn, mode, palette, dither);\n    }\n    if (dither && strcmp(mode, \"1\") == 0) {\n        return tobilevel(imOut, imIn, dither);\n    }\n    convert = NULL;\n    for (y = 0; converters[y].from; y++) {\n        if (!strcmp(imIn->mode, converters[y].from) &&\n            !strcmp(mode, converters[y].to)) {\n            convert = converters[y].convert;\n            break;\n        }\n    }\n    if (!convert) {\n#ifdef notdef\n        return (Imaging)ImagingError_ValueError(\"conversion not supported\");\n#else\n        static char buf[256];\n        sprintf(buf, \"conversion from %s to %s not supported\", imIn->mode, mode);\n        return (Imaging)ImagingError_ValueError(buf);\n#endif\n    }\n    imOut = ImagingNew2Dirty(mode, imOut, imIn);\n    if (!imOut) {\n        return NULL;\n    }\n    ImagingSectionEnter(&cookie);\n    for (y = 0; y < imIn->ysize; y++) {\n        (*convert)((UINT8 *)imOut->image[y], (UINT8 *)imIn->image[y], imIn->xsize);\n    }\n    ImagingSectionLeave(&cookie);\n    return imOut;\n}", "target": 1}
{"code": "static char *get_pid_cgroup(pid_t pid, const char *contrl)\n{\n\tchar fnam[PROCLEN];\n\tFILE *f;\n\tchar *answer = NULL;\n\tchar *line = NULL;\n\tsize_t len = 0;\n\tint ret;\n\tconst char *h = find_mounted_controller(contrl);\n\tif (!h)\n\t\treturn NULL;\n\tret = snprintf(fnam, PROCLEN, \"/proc/%d/cgroup\", pid);\n\tif (ret < 0 || ret >= PROCLEN)\n\t\treturn NULL;\n\tif (!(f = fopen(fnam, \"r\")))\n\t\treturn NULL;\n\twhile (getline(&line, &len, f) != -1) {\n\t\tchar *c1, *c2;\n\t\tif (!line[0])\n\t\t\tcontinue;\n\t\tc1 = strchr(line, ':');\n\t\tif (!c1)\n\t\t\tgoto out;\n\t\tc1++;\n\t\tc2 = strchr(c1, ':');\n\t\tif (!c2)\n\t\t\tgoto out;\n\t\t*c2 = '\\0';\n\t\tif (strcmp(c1, h) != 0)\n\t\t\tcontinue;\n\t\tc2++;\n\t\tstripnewline(c2);\n\t\tdo {\n\t\t\tanswer = strdup(c2);\n\t\t} while (!answer);\n\t\tbreak;\n\t}\nout:\n\tfclose(f);\n\tfree(line);\n\treturn answer;\n}", "target": 0}
{"code": "static RBinSection *bin_section_from_segment(RCoreSymCacheElementSegment *seg) {\n\tif (!seg->name) {\n\t\treturn NULL;\n\t}\n\tRBinSection *s = R_NEW0 (RBinSection);\n\tif (!s) {\n\t\treturn NULL;\n\t}\n\ts->name = r_str_ndup (seg->name, 16);\n\ts->size = seg->size;\n\ts->vsize = seg->vsize;\n\ts->paddr = seg->paddr;\n\ts->vaddr = seg->vaddr;\n\ts->add = true;\n\ts->perm = strstr (s->name, \"TEXT\") ? 5 : 4;\n\ts->is_segment = true;\n\treturn s;\n}", "target": 0}
{"code": "nfsd4_verify(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     union nfsd4_op_u *u)\n{\n\t__be32 status;\n\tstatus = _nfsd4_verify(rqstp, cstate, &u->nverify);\n\treturn status == nfserr_same ? nfs_ok : status;\n}", "target": 0}
{"code": "ext4_xattr_create_cache(char *name)\n{\n\treturn mb_cache_create(name, HASH_BUCKET_BITS);\n}", "target": 1}
{"code": "static void dump_thread32(struct pt_regs * regs, struct user32 * dump)\n{\n\tu32 fs,gs;\n\tdump->magic = CMAGIC;\n\tdump->start_code = 0;\n\tdump->start_stack = regs->rsp & ~(PAGE_SIZE - 1);\n\tdump->u_tsize = ((unsigned long) current->mm->end_code) >> PAGE_SHIFT;\n\tdump->u_dsize = ((unsigned long) (current->mm->brk + (PAGE_SIZE-1))) >> PAGE_SHIFT;\n\tdump->u_dsize -= dump->u_tsize;\n\tdump->u_ssize = 0;\n\tdump->u_debugreg[0] = current->thread.debugreg0;  \n\tdump->u_debugreg[1] = current->thread.debugreg1;  \n\tdump->u_debugreg[2] = current->thread.debugreg2;  \n\tdump->u_debugreg[3] = current->thread.debugreg3;  \n\tdump->u_debugreg[4] = 0;  \n\tdump->u_debugreg[5] = 0;  \n\tdump->u_debugreg[6] = current->thread.debugreg6;  \n\tdump->u_debugreg[7] = current->thread.debugreg7;  \n\tif (dump->start_stack < 0xc0000000)\n\t\tdump->u_ssize = ((unsigned long) (0xc0000000 - dump->start_stack)) >> PAGE_SHIFT;\n\tdump->regs.ebx = regs->rbx;\n\tdump->regs.ecx = regs->rcx;\n\tdump->regs.edx = regs->rdx;\n\tdump->regs.esi = regs->rsi;\n\tdump->regs.edi = regs->rdi;\n\tdump->regs.ebp = regs->rbp;\n\tdump->regs.eax = regs->rax;\n\tdump->regs.ds = current->thread.ds;\n\tdump->regs.es = current->thread.es;\n\tasm(\"movl %%fs,%0\" : \"=r\" (fs)); dump->regs.fs = fs;\n\tasm(\"movl %%gs,%0\" : \"=r\" (gs)); dump->regs.gs = gs; \n\tdump->regs.orig_eax = regs->orig_rax;\n\tdump->regs.eip = regs->rip;\n\tdump->regs.cs = regs->cs;\n\tdump->regs.eflags = regs->eflags;\n\tdump->regs.esp = regs->rsp;\n\tdump->regs.ss = regs->ss;\n#if 1 \n\tdump->u_fpvalid = 0;\n#else\n\tdump->u_fpvalid = dump_fpu (regs, &dump->i387);\n#endif\n}", "target": 0}
{"code": "static struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)\n{\n\tstruct hlist_head *hashent = ucounts_hashentry(ns, uid);\n\tstruct ucounts *ucounts, *new;\n\tspin_lock_irq(&ucounts_lock);\n\tucounts = find_ucounts(ns, uid, hashent);\n\tif (!ucounts) {\n\t\tspin_unlock_irq(&ucounts_lock);\n\t\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\t\tif (!new)\n\t\t\treturn NULL;\n\t\tnew->ns = ns;\n\t\tnew->uid = uid;\n\t\tatomic_set(&new->count, 0);\n\t\tspin_lock_irq(&ucounts_lock);\n\t\tucounts = find_ucounts(ns, uid, hashent);\n\t\tif (ucounts) {\n\t\t\tkfree(new);\n\t\t} else {\n\t\t\thlist_add_head(&new->node, hashent);\n\t\t\tucounts = new;\n\t\t}\n\t}\n\tif (!atomic_add_unless(&ucounts->count, 1, INT_MAX))\n\t\tucounts = NULL;\n\tspin_unlock_irq(&ucounts_lock);\n\treturn ucounts;\n}", "target": 1}
{"code": "static int nsim_bpf_verifier_prep(struct bpf_prog *prog)\n{\n\tstruct nsim_dev *nsim_dev =\n\t\t\tbpf_offload_dev_priv(prog->aux->offload->offdev);\n\tif (!nsim_dev->bpf_bind_accept)\n\t\treturn -EOPNOTSUPP;\n\treturn nsim_bpf_create_prog(nsim_dev, prog);\n}", "target": 0}
{"code": "static int x25_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_x25 *addr = (struct sockaddr_x25 *)uaddr;\n\tint len, i, rc = 0;\n\tif (addr_len != sizeof(struct sockaddr_x25) ||\n\t    addr->sx25_family != AF_X25 ||\n\t    strnlen(addr->sx25_addr.x25_addr, X25_ADDR_LEN) == X25_ADDR_LEN) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (strcmp(addr->sx25_addr.x25_addr, null_x25_address.x25_addr)) {\n\t\tlen = strlen(addr->sx25_addr.x25_addr);\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!isdigit(addr->sx25_addr.x25_addr[i])) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\tlock_sock(sk);\n\tif (sock_flag(sk, SOCK_ZAPPED)) {\n\t\tx25_sk(sk)->source_addr = addr->sx25_addr;\n\t\tx25_insert_socket(sk);\n\t\tsock_reset_flag(sk, SOCK_ZAPPED);\n\t} else {\n\t\trc = -EINVAL;\n\t}\n\trelease_sock(sk);\n\tSOCK_DEBUG(sk, \"x25_bind: socket is bound\\n\");\nout:\n\treturn rc;\n}", "target": 0}
{"code": "void PacketReader::copyRecord(unsigned char* dest, uint16_t len)\n{\n  if(d_pos + len > d_content.size())\n    throw std::out_of_range(\"Attempt to copy outside of packet\");\n  memcpy(dest, &d_content.at(d_pos), len);\n  d_pos+=len;\n}", "target": 0}
{"code": "static unsigned int floppy_check_events(struct gendisk *disk,\n\t\t\t\t\tunsigned int clearing)\n{\n\tint drive = (long)disk->private_data;\n\tif (test_bit(FD_DISK_CHANGED_BIT, &UDRS->flags) ||\n\t    test_bit(FD_VERIFY_BIT, &UDRS->flags))\n\t\treturn DISK_EVENT_MEDIA_CHANGE;\n\tif (time_after(jiffies, UDRS->last_checked + UDP->checkfreq)) {\n\t\tif (lock_fdc(drive))\n\t\t\treturn 0;\n\t\tpoll_drive(false, 0);\n\t\tprocess_fd_request();\n\t}\n\tif (test_bit(FD_DISK_CHANGED_BIT, &UDRS->flags) ||\n\t    test_bit(FD_VERIFY_BIT, &UDRS->flags) ||\n\t    test_bit(drive, &fake_change) ||\n\t    drive_no_geom(drive))\n\t\treturn DISK_EVENT_MEDIA_CHANGE;\n\treturn 0;\n}", "target": 0}
{"code": "void luaC_fix (lua_State *L, GCObject *o) {\n  global_State *g = G(L);\n  lua_assert(g->allgc == o);  \n  white2gray(o);  \n  setage(o, G_OLD);  \n  g->allgc = o->next;  \n  o->next = g->fixedgc;  \n  g->fixedgc = o;\n}", "target": 0}
{"code": "njs_string_to_number(const njs_value_t *value, njs_bool_t parse_float)\n{\n    double             num;\n    njs_bool_t         minus;\n    const u_char       *p, *start, *end;\n    njs_string_prop_t  string;\n    const size_t  infinity = njs_length(\"Infinity\");\n    (void) njs_string_trim(value, &string, NJS_TRIM_START);\n    p = string.start;\n    end = p + string.size;\n    if (p == end) {\n        return parse_float ? NAN : 0.0;\n    }\n    minus = 0;\n    if (*p == '+') {\n        p++;\n    } else if (*p == '-') {\n        p++;\n        minus = 1;\n    }\n    if (p == end) {\n        return NAN;\n    }\n    if (!parse_float\n        && p + 2 < end && p[0] == '0' && (p[1] == 'x' || p[1] == 'X'))\n    {\n        p += 2;\n        num = njs_number_hex_parse(&p, end, 0);\n    } else {\n        start = p;\n        num = njs_number_dec_parse(&p, end, 0);\n        if (p == start) {\n            if (p + infinity > end || memcmp(p, \"Infinity\", infinity) != 0) {\n                return NAN;\n            }\n            num = INFINITY;\n            p += infinity;\n        }\n    }\n    if (!parse_float) {\n        while (p < end) {\n            if (*p != ' ' && *p != '\\t') {\n                return NAN;\n            }\n            p++;\n        }\n    }\n    return minus ? -num : num;\n}", "target": 0}
{"code": "bool ItemStackMetadata::setString(const std::string &name, const std::string &var)\n{\n\tbool result = Metadata::setString(name, var);\n\tif (name == TOOLCAP_KEY)\n\t\tupdateToolCapabilities();\n\treturn result;\n}", "target": 1}
{"code": "get_one_option(int optid, const struct my_option *opt,\n               char *argument)\n{\n  my_bool add_option= TRUE;\n  switch (optid) {\n  case '?':\n    printf(\"%s  Ver %s Distrib %s, for %s (%s)\\n\",\n           my_progname, VER, MYSQL_SERVER_VERSION, SYSTEM_TYPE, MACHINE_TYPE);\n    puts(ORACLE_WELCOME_COPYRIGHT_NOTICE(\"2000\"));\n    puts(\"MySQL utility for upgrading databases to new MySQL versions.\\n\");\n    my_print_help(my_long_options);\n    exit(0);\n    break;\n  case '#':\n    DBUG_PUSH(argument ? argument : default_dbug_option);\n    add_option= FALSE;\n    debug_check_flag= 1;\n    break;\n  case 'p':\n    if (argument == disabled_my_option)\n      argument= (char*) \"\";\t\t\t\n    tty_password= 1;\n    add_option= FALSE;\n    if (argument)\n    {\n      add_one_option(&ds_args, opt, argument);\n      while (*argument)\n        *argument++= 'x';                       \n      tty_password= 0;\n    }\n    break;\n  case 't':\n    my_stpnmov(opt_tmpdir, argument, sizeof(opt_tmpdir));\n    add_option= FALSE;\n    break;\n  case 'k':                                     \n  case 'v': \n  case 'f': \n  case 's':                                     \n  case OPT_WRITE_BINLOG:                        \n    add_option= FALSE;\n    break;\n  case 'h': \n  case 'W': \n  case 'P': \n  case 'S': \n  case OPT_MYSQL_PROTOCOL: \n  case OPT_SHARED_MEMORY_BASE_NAME: \n  case OPT_PLUGIN_DIR:                          \n  case OPT_DEFAULT_AUTH:                        \n    add_one_option(&conn_args, opt, argument);\n    break;\n  }\n  if (add_option)\n  {\n    add_one_option(&ds_args, opt, argument);\n  }\n  return 0;\n}", "target": 1}
{"code": "static int rds_loop_xmit(struct rds_connection *conn, struct rds_message *rm,\n\t\t\t unsigned int hdr_off, unsigned int sg,\n\t\t\t unsigned int off)\n{\n\tif (rm->m_inc.i_hdr.h_flags & RDS_FLAG_CONG_BITMAP) {\n\t\trds_cong_map_updated(conn->c_fcong, ~(u64) 0);\n\t\treturn sizeof(struct rds_header) + RDS_CONG_MAP_BYTES;\n\t}\n\tBUG_ON(hdr_off || sg || off);\n\trds_inc_init(&rm->m_inc, conn, conn->c_laddr);\n\trds_message_addref(rm);\n\trds_recv_incoming(conn, conn->c_laddr, conn->c_faddr, &rm->m_inc,\n\t\t\t  GFP_KERNEL, KM_USER0);\n\trds_send_drop_acked(conn, be64_to_cpu(rm->m_inc.i_hdr.h_sequence),\n\t\t\t    NULL);\n\trds_inc_put(&rm->m_inc);\n\treturn sizeof(struct rds_header) + be32_to_cpu(rm->m_inc.i_hdr.h_len);\n}", "target": 1}
{"code": "struct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6,\n\t\t\t\t   const struct sk_buff *skb,\n\t\t\t\t   int flags, pol_lookup_t lookup)\n{\n\tstruct rt6_info *rt;\n\trt = lookup(net, net->ipv6.fib6_main_tbl, fl6, skb, flags);\n\tif (rt->dst.error == -EAGAIN) {\n\t\tip6_rt_put_flags(rt, flags);\n\t\trt = net->ipv6.ip6_null_entry;\n\t\tif (!(flags | RT6_LOOKUP_F_DST_NOREF))\n\t\t\tdst_hold(&rt->dst);\n\t}\n\treturn &rt->dst;\n}", "target": 1}
{"code": "static void smp_task_timedout(struct timer_list *t)\n{\n\tstruct sas_task_slow *slow = from_timer(slow, t, timer);\n\tstruct sas_task *task = slow->task;\n\tunsigned long flags;\n\tspin_lock_irqsave(&task->task_state_lock, flags);\n\tif (!(task->task_state_flags & SAS_TASK_STATE_DONE))\n\t\ttask->task_state_flags |= SAS_TASK_STATE_ABORTED;\n\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\tcomplete(&task->slow_task->completion);\n}", "target": 1}
{"code": "static GF_SampleGroupDescriptionBox *get_sgdp(GF_SampleTableBox *stbl, void *traf, u32 grouping_type, Bool *is_traf_sgdp)\n#endif \n{\n\tGF_List *groupList=NULL;\n\tGF_List **parent=NULL;\n\tGF_SampleGroupDescriptionBox *sgdesc=NULL;\n\tu32 count, i;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (!stbl && traf && traf->trex->track->Media->information->sampleTable)\n\t\tstbl = traf->trex->track->Media->information->sampleTable;\n#endif\n\tif (stbl) {\n\t\tif (!stbl->sampleGroupsDescription && !traf)\n\t\t\tstbl->sampleGroupsDescription = gf_list_new();\n\t\tgroupList = stbl->sampleGroupsDescription;\n\t\tif (is_traf_sgdp) *is_traf_sgdp = GF_FALSE;\n\t\tparent = &stbl->child_boxes;\n\t\tcount = gf_list_count(groupList);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(groupList, i);\n\t\t\tif (sgdesc->grouping_type==grouping_type) break;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t}\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (!sgdesc && traf) {\n\t\tif (!traf->sampleGroupsDescription)\n\t\t\ttraf->sampleGroupsDescription = gf_list_new();\n\t\tgroupList = traf->sampleGroupsDescription;\n\t\tparent = &traf->child_boxes;\n\t\tif (is_traf_sgdp) *is_traf_sgdp = GF_TRUE;\n\t\tcount = gf_list_count(groupList);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(groupList, i);\n\t\t\tif (sgdesc->grouping_type==grouping_type) break;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t}\n#endif\n\tif (!sgdesc) {\n\t\tsgdesc = (GF_SampleGroupDescriptionBox *) gf_isom_box_new_parent(parent, GF_ISOM_BOX_TYPE_SGPD);\n\t\tif (!sgdesc) return NULL;\n\t\tsgdesc->grouping_type = grouping_type;\n\t\tassert(groupList);\n\t\tgf_list_add(groupList, sgdesc);\n\t}\n\treturn sgdesc;\n}", "target": 1}
{"code": "ResolveStateAndPredicate(ExprDef *expr, enum xkb_match_operation *pred_rtrn,\n                         xkb_mod_mask_t *mods_rtrn, CompatInfo *info)\n{\n    if (expr == NULL) {\n        *pred_rtrn = MATCH_ANY_OR_NONE;\n        *mods_rtrn = MOD_REAL_MASK_ALL;\n        return true;\n    }\n    *pred_rtrn = MATCH_EXACTLY;\n    if (expr->expr.op == EXPR_ACTION_DECL) {\n        const char *pred_txt = xkb_atom_text(info->ctx, expr->action.name);\n        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn)) {\n            log_err(info->ctx,\n                    \"Illegal modifier predicate \\\"%s\\\"; Ignored\\n\", pred_txt);\n            return false;\n        }\n        expr = expr->action.args;\n    }\n    else if (expr->expr.op == EXPR_IDENT) {\n        const char *pred_txt = xkb_atom_text(info->ctx, expr->ident.ident);\n        if (pred_txt && istreq(pred_txt, \"any\")) {\n            *pred_rtrn = MATCH_ANY;\n            *mods_rtrn = MOD_REAL_MASK_ALL;\n            return true;\n        }\n    }\n    return ExprResolveModMask(info->ctx, expr, MOD_REAL, &info->mods,\n                              mods_rtrn);\n}", "target": 1}
{"code": "static int cypress_generic_port_probe(struct usb_serial_port *port)\n{\n\tstruct usb_serial *serial = port->serial;\n\tstruct cypress_private *priv;\n\tif (!port->interrupt_out_urb || !port->interrupt_in_urb) {\n\t\tdev_err(&port->dev, \"required endpoint is missing\\n\");\n\t\treturn -ENODEV;\n\t}\n\tpriv = kzalloc(sizeof(struct cypress_private), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tpriv->comm_is_ok = !0;\n\tspin_lock_init(&priv->lock);\n\tif (kfifo_alloc(&priv->write_fifo, CYPRESS_BUF_SIZE, GFP_KERNEL)) {\n\t\tkfree(priv);\n\t\treturn -ENOMEM;\n\t}\n\tif (!is_frwd(serial->dev))\n\t\tusb_reset_configuration(serial->dev);\n\tpriv->cmd_ctrl = 0;\n\tpriv->line_control = 0;\n\tpriv->termios_initialized = 0;\n\tpriv->rx_flags = 0;\n\tif (port->interrupt_out_size > 9)\n\t\tpriv->pkt_fmt = packet_format_1;\n\telse\n\t\tpriv->pkt_fmt = packet_format_2;\n\tif (interval > 0) {\n\t\tpriv->write_urb_interval = interval;\n\t\tpriv->read_urb_interval = interval;\n\t\tdev_dbg(&port->dev, \"%s - read & write intervals forced to %d\\n\",\n\t\t\t__func__, interval);\n\t} else {\n\t\tpriv->write_urb_interval = port->interrupt_out_urb->interval;\n\t\tpriv->read_urb_interval = port->interrupt_in_urb->interval;\n\t\tdev_dbg(&port->dev, \"%s - intervals: read=%d write=%d\\n\",\n\t\t\t__func__, priv->read_urb_interval,\n\t\t\tpriv->write_urb_interval);\n\t}\n\tusb_set_serial_port_data(port, priv);\n\tport->port.drain_delay = 256;\n\treturn 0;\n}", "target": 0}
{"code": "static int nfs4_open_recover_helper(struct nfs4_opendata *opendata, mode_t openflags, struct nfs4_state **res)\n{\n\tstruct nfs4_state *newstate;\n\tint ret;\n\topendata->o_arg.open_flags = openflags;\n\tmemset(&opendata->o_res, 0, sizeof(opendata->o_res));\n\tmemset(&opendata->c_res, 0, sizeof(opendata->c_res));\n\tnfs4_init_opendata_res(opendata);\n\tret = _nfs4_proc_open(opendata);\n\tif (ret != 0)\n\t\treturn ret; \n\tnewstate = nfs4_opendata_to_nfs4_state(opendata);\n\tif (IS_ERR(newstate))\n\t\treturn PTR_ERR(newstate);\n\tnfs4_close_state(&opendata->path, newstate, openflags);\n\t*res = newstate;\n\treturn 0;\n}", "target": 1}
{"code": "static int nft_delrule(struct nft_ctx *ctx, struct nft_rule *rule)\n{\n\tstruct nft_trans *trans;\n\tint err;\n\ttrans = nft_trans_rule_add(ctx, NFT_MSG_DELRULE, rule);\n\tif (trans == NULL)\n\t\treturn -ENOMEM;\n\terr = nf_tables_delrule_deactivate(ctx, rule);\n\tif (err < 0) {\n\t\tnft_trans_destroy(trans);\n\t\treturn err;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int xar_hash_check(int hash, const void * result, const void * expected)\n{\n    int len;\n    if (!result || !expected)\n        return 1;\n    switch (hash) {\n    case XAR_CKSUM_SHA1:\n        len = SHA1_HASH_SIZE;\n        break;\n    case XAR_CKSUM_MD5:\n        len = CLI_HASH_MD5;\n        break;\n    case XAR_CKSUM_OTHER:\n    case XAR_CKSUM_NONE:\n    default:\n        return 1;\n    }\n    return memcmp(result, expected, len);\n}", "target": 1}
{"code": "static void __init check_tylersburg_isoch(void)\n{\n\tstruct pci_dev *pdev;\n\tuint32_t vtisochctrl;\n\tpdev = pci_get_device(PCI_VENDOR_ID_INTEL, 0x3a3e, NULL);\n\tif (!pdev)\n\t\treturn;\n\tpci_dev_put(pdev);\n\tpdev = pci_get_device(PCI_VENDOR_ID_INTEL, 0x342e, NULL);\n\tif (!pdev)\n\t\treturn;\n\tif (pci_read_config_dword(pdev, 0x188, &vtisochctrl)) {\n\t\tpci_dev_put(pdev);\n\t\treturn;\n\t}\n\tpci_dev_put(pdev);\n\tif (vtisochctrl & 1)\n\t\treturn;\n\tvtisochctrl &= 0x1c;\n\tif (vtisochctrl == 0x10)\n\t\treturn;\n\tif (!vtisochctrl) {\n\t\tWARN(1, \"Your BIOS is broken; DMA routed to ISOCH DMAR unit but no TLB space.\\n\"\n\t\t     \"BIOS vendor: %s; Ver: %s; Product Version: %s\\n\",\n\t\t     dmi_get_system_info(DMI_BIOS_VENDOR),\n\t\t     dmi_get_system_info(DMI_BIOS_VERSION),\n\t\t     dmi_get_system_info(DMI_PRODUCT_VERSION));\n\t\tiommu_identity_mapping |= IDENTMAP_AZALIA;\n\t\treturn;\n\t}\n\tpr_warn(\"Recommended TLB entries for ISOCH unit is 16; your BIOS set %d\\n\",\n\t       vtisochctrl);\n}", "target": 0}
{"code": "getFileTypeNoFollowSymlinks(const StaticString &filename) {\n\tstruct stat buf;\n\tint ret;\n\tret = lstat(filename.c_str(), &buf);\n\tif (ret == 0) {\n\t\tif (S_ISREG(buf.st_mode)) {\n\t\t\treturn FT_REGULAR;\n\t\t} else if (S_ISDIR(buf.st_mode)) {\n\t\t\treturn FT_DIRECTORY;\n\t\t} else if (S_ISLNK(buf.st_mode)) {\n\t\t\treturn FT_SYMLINK;\n\t\t} else {\n\t\t\treturn FT_OTHER;\n\t\t}\n\t} else {\n\t\tif (errno == ENOENT) {\n\t\t\treturn FT_NONEXISTANT;\n\t\t} else {\n\t\t\tint e = errno;\n\t\t\tstring message(\"Cannot lstat '\");\n\t\t\tmessage.append(filename);\n\t\t\tmessage.append(\"'\");\n\t\t\tthrow FileSystemException(message, e, filename);\n\t\t}\n\t}\n}", "target": 1}
{"code": "gpg_ctx_add_recipient (struct _GpgCtx *gpg,\n                       const gchar *keyid)\n{\n\tif (gpg->mode != GPG_CTX_MODE_ENCRYPT && gpg->mode != GPG_CTX_MODE_EXPORT)\n\t\treturn;\n\tif (!gpg->recipients)\n\t\tgpg->recipients = g_ptr_array_new ();\n\tg_ptr_array_add (gpg->recipients, g_strdup (keyid));\n}", "target": 1}
{"code": "sg_finish_rem_req(Sg_request *srp)\n{\n\tint ret = 0;\n\tSg_fd *sfp = srp->parentfp;\n\tSg_scatter_hold *req_schp = &srp->data;\n\tSCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t\t      \"sg_finish_rem_req: res_used=%d\\n\",\n\t\t\t\t      (int) srp->res_used));\n\tif (srp->bio)\n\t\tret = blk_rq_unmap_user(srp->bio);\n\tif (srp->rq) {\n\t\tscsi_req_free_cmd(scsi_req(srp->rq));\n\t\tblk_put_request(srp->rq);\n\t}\n\tif (srp->res_used)\n\t\tsg_unlink_reserve(sfp, srp);\n\telse\n\t\tsg_remove_scat(sfp, req_schp);\n\treturn ret;\n}", "target": 0}
{"code": "static struct fsnotify_group *inotify_new_group(struct user_struct *user, unsigned int max_events)\n{\n\tstruct fsnotify_group *group;\n\tgroup = fsnotify_alloc_group(&inotify_fsnotify_ops);\n\tif (IS_ERR(group))\n\t\treturn group;\n\tgroup->max_events = max_events;\n\tspin_lock_init(&group->inotify_data.idr_lock);\n\tidr_init(&group->inotify_data.idr);\n\tgroup->inotify_data.last_wd = 0;\n\tgroup->inotify_data.user = user;\n\tgroup->inotify_data.fa = NULL;\n\treturn group;\n}", "target": 1}
{"code": "vg_get_config(VuDev *dev, uint8_t *config, uint32_t len)\n{\n    VuGpu *g = container_of(dev, VuGpu, dev.parent);\n    if (len > sizeof(struct virtio_gpu_config)) {\n        return -1;\n    }\n    if (opt_virgl) {\n        g->virtio_config.num_capsets = vg_virgl_get_num_capsets();\n    }\n    memcpy(config, &g->virtio_config, len);\n    return 0;\n}", "target": 0}
{"code": "int db__close(void)\n{\n\tsubhier_clean(&db.subs);\n\tretain__clean(&db.retains);\n\tdb__msg_store_clean();\n\treturn MOSQ_ERR_SUCCESS;\n}", "target": 1}
{"code": "static int __init lp_setup (char *str)\n{\n\tstatic int parport_ptr;\n\tint x;\n\tif (get_option(&str, &x)) {\n\t\tif (x == 0) {\n\t\t\tparport_nr[0] = LP_PARPORT_OFF;\n\t\t} else {\n\t\t\tprintk(KERN_WARNING \"warning: 'lp=0x%x' is deprecated, ignored\\n\", x);\n\t\t\treturn 0;\n\t\t}\n\t} else if (!strncmp(str, \"parport\", 7)) {\n\t\tint n = simple_strtoul(str+7, NULL, 10);\n\t\tif (parport_ptr < LP_NO)\n\t\t\tparport_nr[parport_ptr++] = n;\n\t\telse\n\t\t\tprintk(KERN_INFO \"lp: too many ports, %s ignored.\\n\",\n\t\t\t       str);\n\t} else if (!strcmp(str, \"auto\")) {\n\t\tparport_nr[0] = LP_PARPORT_AUTO;\n\t} else if (!strcmp(str, \"none\")) {\n\t\tparport_nr[parport_ptr++] = LP_PARPORT_NONE;\n\t} else if (!strcmp(str, \"reset\")) {\n\t\treset = 1;\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "bool TextAutosizer::processSubtree(RenderObject* layoutRoot)\n{\n    if (!m_document->settings() || !m_document->settings()->textAutosizingEnabled() || layoutRoot->view()->printing() || !m_document->page())\n        return false;\n    Frame* mainFrame = m_document->page()->mainFrame();\n    TextAutosizingWindowInfo windowInfo;\n     windowInfo.windowSize = m_document->settings()->textAutosizingWindowSizeOverride();\n     if (windowInfo.windowSize.isEmpty()) {\n         bool includeScrollbars = !InspectorInstrumentation::shouldApplyScreenWidthOverride(mainFrame);\n        windowInfo.windowSize = mainFrame->view()->visibleContentRect(includeScrollbars).size(); \n     }\n    windowInfo.minLayoutSize = mainFrame->view()->layoutSize();\n    for (Frame* frame = m_document->frame(); frame; frame = frame->tree()->parent()) {\n        if (!frame->view()->isInChildFrameWithFrameFlattening())\n            windowInfo.minLayoutSize = windowInfo.minLayoutSize.shrunkTo(frame->view()->layoutSize());\n    }\n    RenderBlock* container = layoutRoot->isRenderBlock() ? toRenderBlock(layoutRoot) : layoutRoot->containingBlock();\n    while (container && !isAutosizingContainer(container))\n        container = container->containingBlock();\n    RenderBlock* cluster = container;\n    while (cluster && (!isAutosizingContainer(cluster) || !isAutosizingCluster(cluster)))\n        cluster = cluster->containingBlock();\n    processCluster(cluster, container, layoutRoot, windowInfo);\n    return true;\n}", "target": 1}
{"code": "SSLNetVConnection::advertise_next_protocol(SSL *ssl, const unsigned char **out, unsigned int *outlen, void * )\n{\n  SSLNetVConnection *netvc = SSLNetVCAccess(ssl);\n  ink_release_assert(netvc != nullptr);\n  if (netvc->npnSet && netvc->npnSet->advertiseProtocols(out, outlen)) {\n    return SSL_TLSEXT_ERR_OK;\n  }\n  return SSL_TLSEXT_ERR_NOACK;\n}", "target": 0}
{"code": "pci_get_vdev_info(int slot)\n{\n\tstruct businfo *bi;\n\tstruct slotinfo *si;\n\tstruct pci_vdev *dev = NULL;\n\tbi = pci_businfo[0];\n\tassert(bi != NULL);\n\tsi = &bi->slotinfo[slot];\n\tif (si != NULL)\n\t\tdev = si->si_funcs[0].fi_devi;\n\telse\n\t\tfprintf(stderr, \"slot=%d is empty!\\n\", slot);\n\treturn dev;\n}", "target": 1}
{"code": "UnicodeString DecimalQuantity::toScientificString() const {\n    U_ASSERT(!isApproximate);\n    UnicodeString result;\n    if (isNegative()) {\n        result.append(u'-');\n    }\n    if (precision == 0) {\n        result.append(u\"0E+0\", -1);\n        return result;\n    }\n    int32_t upperPos = std::min(precision + scale, lOptPos) - scale - 1;\n    int32_t lowerPos = std::max(scale, rOptPos) - scale;\n    int32_t p = upperPos;\n    result.append(u'0' + getDigitPos(p));\n    if ((--p) >= lowerPos) {\n        result.append(u'.');\n        for (; p >= lowerPos; p--) {\n            result.append(u'0' + getDigitPos(p));\n        }\n    }\n    result.append(u'E');\n    int32_t _scale = upperPos + scale;\n    if (_scale < 0) {\n        _scale *= -1;\n        result.append(u'-');\n    } else {\n        result.append(u'+');\n    }\n    if (_scale == 0) {\n        result.append(u'0');\n    }\n    int32_t insertIndex = result.length();\n    while (_scale > 0) {\n        std::div_t res = std::div(_scale, 10);\n        result.insert(insertIndex, u'0' + res.rem);\n        _scale = res.quot;\n    }\n    return result;\n}", "target": 1}
{"code": "    void CrwMap::decodeArray(const CiffComponent& ciffComponent,\n                             const CrwMapping*    pCrwMapping,\n                                   Image&         image,\n                                   ByteOrder      byteOrder)\n    {\n        if (ciffComponent.typeId() != unsignedShort) {\n            return decodeBasic(ciffComponent, pCrwMapping, image, byteOrder);\n        }\n        long aperture = 0;\n        long shutterSpeed = 0;\n        IfdId ifdId = ifdIdNotSet;\n        switch (pCrwMapping->tag_) {\n        case 0x0001: ifdId = canonCsId; break;\n        case 0x0004: ifdId = canonSiId; break;\n        case 0x000f: ifdId = canonCfId; break;\n        case 0x0012: ifdId = canonPiId; break;\n        }\n        assert(ifdId != ifdIdNotSet);\n        std::string groupName(Internal::groupName(ifdId));\n        uint16_t c = 1;\n        while (uint32_t(c)*2 < ciffComponent.size()) {\n            uint16_t n = 1;\n            ExifKey key(c, groupName);\n            UShortValue value;\n            if (ifdId == canonCsId && c == 23 && ciffComponent.size() > 50) n = 3;\n            value.read(ciffComponent.pData() + c*2, n*2, byteOrder);\n            image.exifData().add(key, &value);\n            if (ifdId == canonSiId && c == 21) aperture = value.toLong();\n            if (ifdId == canonSiId && c == 22) shutterSpeed = value.toLong();\n            c += n;\n        }\n        if (ifdId == canonSiId) {\n            float f = fnumber(canonEv(aperture));\n            Rational r = floatToRationalCast(f);\n            URational ur(r.first, r.second);\n            URationalValue fn;\n            fn.value_.push_back(ur);\n            image.exifData().add(ExifKey(\"Exif.Photo.FNumber\"), &fn);\n            ur = exposureTime(canonEv(shutterSpeed));\n            URationalValue et;\n            et.value_.push_back(ur);\n            image.exifData().add(ExifKey(\"Exif.Photo.ExposureTime\"), &et);\n        }\n    } ", "target": 0}
{"code": "int gdImageColorClosest (gdImagePtr im, int r, int g, int b)\n{\n\treturn gdImageColorClosestAlpha (im, r, g, b, gdAlphaOpaque);\n}", "target": 0}
{"code": "int ldb_msg_add_string(struct ldb_message *msg,\n\t\t       const char *attr_name, const char *str)\n{\n\treturn ldb_msg_add_string_flags(msg, attr_name, str, 0);\n}", "target": 0}
{"code": "static TEE_Result do_alloc_keypair(struct rsa_keypair *s,\n\t\t\t\t   size_t key_size_bits __unused)\n{\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->e))\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tif (!bn_alloc_max(&s->d))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->n))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->p))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->q))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->qp))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->dp))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->dq))\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(s->e);\n\tcrypto_bignum_free(s->d);\n\tcrypto_bignum_free(s->n);\n\tcrypto_bignum_free(s->p);\n\tcrypto_bignum_free(s->q);\n\tcrypto_bignum_free(s->qp);\n\tcrypto_bignum_free(s->dp);\n\tcrypto_bignum_free(s->dq);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "zend_op_array *compile_string(zval *source_string, char *filename TSRMLS_DC)\n{\n\tzend_lex_state original_lex_state;\n\tzend_op_array *op_array = (zend_op_array *) emalloc(sizeof(zend_op_array));\n\tzend_op_array *original_active_op_array = CG(active_op_array);\n\tzend_op_array *retval;\n\tzval tmp;\n\tint compiler_result;\n\tzend_bool original_in_compilation = CG(in_compilation);\n\tif (source_string->value.str.len==0) {\n\t\tefree(op_array);\n\t\treturn NULL;\n\t}\n\tCG(in_compilation) = 1;\n\ttmp = *source_string;\n\tzval_copy_ctor(&tmp);\n\tconvert_to_string(&tmp);\n\tsource_string = &tmp;\n\tzend_save_lexical_state(&original_lex_state TSRMLS_CC);\n\tif (zend_prepare_string_for_scanning(source_string, filename TSRMLS_CC)==FAILURE) {\n\t\tefree(op_array);\n\t\tretval = NULL;\n\t} else {\n\t\tzend_bool orig_interactive = CG(interactive);\n\t\tCG(interactive) = 0;\n\t\tinit_op_array(op_array, ZEND_EVAL_CODE, INITIAL_OP_ARRAY_SIZE TSRMLS_CC);\n\t\tCG(interactive) = orig_interactive;\n\t\tCG(active_op_array) = op_array;\n\t\tzend_stack_push(&CG(context_stack), (void *) &CG(context), sizeof(CG(context)));\n\t\tzend_init_compiler_context(TSRMLS_C);\n\t\tBEGIN(ST_IN_SCRIPTING);\n\t\tcompiler_result = zendparse(TSRMLS_C);\n\t\tif (SCNG(script_filtered)) {\n\t\t\tefree(SCNG(script_filtered));\n\t\t\tSCNG(script_filtered) = NULL;\n\t\t}\n\t\tif (compiler_result==1) {\n\t\t\tCG(active_op_array) = original_active_op_array;\n\t\t\tCG(unclean_shutdown)=1;\n\t\t\tdestroy_op_array(op_array TSRMLS_CC);\n\t\t\tefree(op_array);\n\t\t\tretval = NULL;\n\t\t} else {\n\t\t\tzend_do_return(NULL, 0 TSRMLS_CC);\n\t\t\tCG(active_op_array) = original_active_op_array;\n\t\t\tpass_two(op_array TSRMLS_CC);\n\t\t\tzend_release_labels(0 TSRMLS_CC);\n\t\t\tretval = op_array;\n\t\t}\n\t}\n\tzend_restore_lexical_state(&original_lex_state TSRMLS_CC);\n\tzval_dtor(&tmp);\n\tCG(in_compilation) = original_in_compilation;\n\treturn retval;\n}", "target": 1}
{"code": "static void __exit exit_ext2_fs(void)\n{\n\tunregister_filesystem(&ext2_fs_type);\n\tdestroy_inodecache();\n\texit_ext2_xattr();\n}", "target": 1}
{"code": "delta_head_destroy(struct delta_head *delta_head)\n{\n\tif (delta_head) {\n\t\tdoc_data_cleanup(&delta_head->doc_data);\n\t\tfree(delta_head);\n\t}\n}", "target": 1}
{"code": "GF_Err gf_isom_use_compact_size(GF_ISOFile *movie, u32 trackNumber, Bool CompactionOn)\n{\n\tGF_TrackBox *trak;\n\tu32 i, size;\n\tGF_SampleSizeBox *stsz;\n\tGF_Err e;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media || !trak->Media->information\n\t        || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleSize)\n\t\treturn GF_ISOM_INVALID_FILE;\n\tstsz = trak->Media->information->sampleTable->SampleSize;\n\tif (!CompactionOn) {\n\t\tif (stsz->type == GF_ISOM_BOX_TYPE_STSZ) return GF_OK;\n\t\tstsz->type = GF_ISOM_BOX_TYPE_STSZ;\n\t\tstsz->sampleSize = 0;\n\t\tif (!stsz->sampleCount) return GF_OK;\n\t\tif (!stsz->sizes) return GF_OK;\n\t\tsize = stsz->sizes[0];\n\t\tfor (i=1; i<stsz->sampleCount; i++) {\n\t\t\tif (size != stsz->sizes[i]) {\n\t\t\t\tsize = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (size) {\n\t\t\tgf_free(stsz->sizes);\n\t\t\tstsz->sizes = NULL;\n\t\t\tstsz->sampleSize = size;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (stsz->type == GF_ISOM_BOX_TYPE_STZ2) return GF_OK;\n\tif (stsz->sampleSize) {\n\t\tif (stsz->sizes) gf_free(stsz->sizes);\n\t\tstsz->sizes = (u32*) gf_malloc(sizeof(u32)*stsz->sampleCount);\n\t\tif (!stsz->sizes) return GF_OUT_OF_MEM;\n\t\tmemset(stsz->sizes, stsz->sampleSize, sizeof(u32));\n\t}\n\tstsz->sampleSize = 0;\n\tstsz->type = GF_ISOM_BOX_TYPE_STZ2;\n\treturn GF_OK;\n}", "target": 1}
{"code": "gif_read_image(FILE       *fp,\t\t\n\t       image_t    *img,\t\t\n\t       gif_cmap_t cmap,\t\t\n\t       int        interlace,\t\n\t       int        transparent)\t\n{\n  uchar\t\tcode_size,\t\t\n\t\t*temp;\t\t\t\n  int\t\txpos,\t\t\t\n\t\typos,\t\t\t\n\t\tpass;\t\t\t\n  int\t\tpixel;\t\t\t\n  static int\txpasses[4] = { 8, 8, 4, 2 },\n\t\typasses[5] = { 0, 4, 2, 1, 999999 };\n  xpos      = 0;\n  ypos      = 0;\n  pass      = 0;\n  code_size = (uchar)getc(fp);\n  if (code_size > 12)\n  {\n    progress_error(HD_ERROR_READ_ERROR, \"Bad GIF file \\\"%s\\\" - invalid code size %d.\", img->filename, code_size);\n    return (-1);\n  }\n  if (gif_read_lzw(fp, 1, code_size) < 0)\n    return (-1);\n  temp = img->pixels;\n  while ((pixel = gif_read_lzw(fp, 0, code_size)) >= 0 && pixel < 256)\n  {\n    temp[0] = cmap[pixel][0];\n    if (img->depth > 1)\n    {\n      temp[1] = cmap[pixel][1];\n      temp[2] = cmap[pixel][2];\n    }\n    if (pixel == transparent)\n      image_set_mask(img, xpos, ypos);\n    xpos ++;\n    temp += img->depth;\n    if (xpos == img->width)\n    {\n      xpos = 0;\n      if (interlace)\n      {\n        ypos += xpasses[pass];\n        temp += (xpasses[pass] - 1) * img->width * img->depth;\n        if (ypos >= img->height)\n\t{\n\t  pass ++;\n          ypos = ypasses[pass];\n          temp = img->pixels + ypos * img->width * img->depth;\n\t}\n      }\n      else\n\typos ++;\n    }\n    if (ypos >= img->height)\n      break;\n  }\n  return (0);\n}", "target": 0}
{"code": "void tcp_rcv_space_adjust(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint time;\n\tint space;\n\tif (tp->rcvq_space.time == 0)\n\t\tgoto new_measure;\n\ttime = tcp_time_stamp - tp->rcvq_space.time;\n\tif (time < (tp->rcv_rtt_est.rtt >> 3) || tp->rcv_rtt_est.rtt == 0)\n\t\treturn;\n\tspace = 2 * (tp->copied_seq - tp->rcvq_space.seq);\n\tspace = max(tp->rcvq_space.space, space);\n\tif (tp->rcvq_space.space != space) {\n\t\tint rcvmem;\n\t\ttp->rcvq_space.space = space;\n\t\tif (sysctl_tcp_moderate_rcvbuf &&\n\t\t    !(sk->sk_userlocks & SOCK_RCVBUF_LOCK)) {\n\t\t\tint new_clamp = space;\n\t\t\tspace /= tp->advmss;\n\t\t\tif (!space)\n\t\t\t\tspace = 1;\n\t\t\trcvmem = SKB_TRUESIZE(tp->advmss + MAX_TCP_HEADER);\n\t\t\twhile (tcp_win_from_space(rcvmem) < tp->advmss)\n\t\t\t\trcvmem += 128;\n\t\t\tspace *= rcvmem;\n\t\t\tspace = min(space, sysctl_tcp_rmem[2]);\n\t\t\tif (space > sk->sk_rcvbuf) {\n\t\t\t\tsk->sk_rcvbuf = space;\n\t\t\t\ttp->window_clamp = new_clamp;\n\t\t\t}\n\t\t}\n\t}\nnew_measure:\n\ttp->rcvq_space.seq = tp->copied_seq;\n\ttp->rcvq_space.time = tcp_time_stamp;\n}", "target": 0}
{"code": "IW_IMPL(unsigned int) iw_get_ui16le(const iw_byte *b)\n{\n\treturn b[0] | (b[1]<<8);\n}", "target": 1}
{"code": "static int selinux_sb_alloc_security(struct super_block *sb)\n{\n\tstruct superblock_security_struct *sbsec;\n\tsbsec = kzalloc(sizeof(struct superblock_security_struct), GFP_KERNEL);\n\tif (!sbsec)\n\t\treturn -ENOMEM;\n\tmutex_init(&sbsec->lock);\n\tINIT_LIST_HEAD(&sbsec->isec_head);\n\tspin_lock_init(&sbsec->isec_lock);\n\tsbsec->sb = sb;\n\tsbsec->sid = SECINITSID_UNLABELED;\n\tsbsec->def_sid = SECINITSID_FILE;\n\tsbsec->mntpoint_sid = SECINITSID_UNLABELED;\n\tsb->s_security = sbsec;\n\treturn 0;\n}", "target": 0}
{"code": "SampleEncrypter::Create(const AP4_UI08* key, const AP4_UI08* iv, SampleEncrypter*& encrypter) {\n    encrypter = NULL;\n    AP4_BlockCipher* block_cipher = NULL;\n    AP4_Result result = AP4_DefaultBlockCipherFactory::Instance.CreateCipher(AP4_BlockCipher::AES_128,\n                                                                             AP4_BlockCipher::ENCRYPT,\n                                                                             AP4_BlockCipher::CBC,\n                                                                             NULL,\n                                                                             key,\n                                                                             16,\n                                                                             block_cipher);\n    if (AP4_FAILED(result)) return result;\n    AP4_CbcStreamCipher* stream_cipher = new AP4_CbcStreamCipher(block_cipher);\n    encrypter = new SampleEncrypter(stream_cipher, iv);\n    return AP4_SUCCESS;\n}", "target": 0}
{"code": "agoo_http_init() {\n    const char\t**kp = header_keys;\n    memset(&key_cache, 0, sizeof(struct _cache));\n    for (; NULL != *kp; kp++) {\n\tkey_set(*kp);\n    }\n}", "target": 1}
{"code": "search_impl(i_ctx_t *i_ctx_p, bool forward)\n{\n    os_ptr op = osp;\n    os_ptr op1 = op - 1;\n    uint size = r_size(op);\n    uint count;\n    byte *pat;\n    byte *ptr;\n    byte ch;\n    int incr = forward ? 1 : -1;\n    check_read_type(*op1, t_string);\n    check_read_type(*op, t_string);\n    if (size > r_size(op1)) {\t\n        make_false(op);\n        return 0;\n    }\n    count = r_size(op1) - size;\n    ptr = op1->value.bytes;\n    if (size == 0)\n        goto found;\n    if (!forward)\n        ptr += count;\n    pat = op->value.bytes;\n    ch = pat[0];\n    do {\n        if (*ptr == ch && (size == 1 || !memcmp(ptr, pat, size)))\n            goto found;\n        ptr += incr;\n    }\n    while (count--);\n    make_false(op);\n    return 0;\nfound:\n    op->tas.type_attrs = op1->tas.type_attrs;\n    op->value.bytes = ptr;\n    r_set_size(op, size);\n    push(2);\n    op[-1] = *op1;\n    r_set_size(op - 1, ptr - op[-1].value.bytes);\n    op1->value.bytes = ptr + size;\n    r_set_size(op1, count + (!forward ? (size - 1) : 0));\n    make_true(op);\n    return 0;\n}", "target": 1}
{"code": "void V8Window::namedPropertyGetterCustom(v8::Local<v8::Name> name, const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    if (!name->IsString())\n        return;\n    auto nameString = name.As<v8::String>();\n    LocalDOMWindow* window = toLocalDOMWindow(V8Window::toImpl(info.Holder()));\n    if (!window)\n        return;\n    LocalFrame* frame = window->frame();\n    if (!frame)\n        return;\n    AtomicString propName = toCoreAtomicString(nameString);\n    Frame* child = frame->tree().scopedChild(propName);\n    if (child) {\n        v8SetReturnValueFast(info, child->domWindow(), window);\n        return;\n    }\n     if (!info.Holder()->GetRealNamedProperty(nameString).IsEmpty())\n         return;\n    frame = window->frame();\n    if (!frame)\n        return;\n     Document* doc = frame->document();\n    if (doc && doc->isHTMLDocument()) {\n        if (toHTMLDocument(doc)->hasNamedItem(propName) || doc->hasElementWithId(propName)) {\n            RefPtrWillBeRawPtr<HTMLCollection> items = doc->windowNamedItems(propName);\n            if (!items->isEmpty()) {\n                if (items->hasExactlyOneItem()) {\n                    v8SetReturnValueFast(info, items->item(0), window);\n                    return;\n                }\n                v8SetReturnValueFast(info, items.release(), window);\n                return;\n            }\n        }\n    }\n}", "target": 0}
{"code": "DumpIoStats(Mgr::IoActionData& stats, StoreEntry* sentry)\n{\n    int i;\n    storeAppendPrintf(sentry, \"HTTP I/O\\n\");\n    storeAppendPrintf(sentry, \"number of reads: %.0f\\n\", stats.http_reads);\n    storeAppendPrintf(sentry, \"Read Histogram:\\n\");\n    for (i = 0; i < IoStats::histSize; ++i) {\n        storeAppendPrintf(sentry, \"%5d-%5d: %9.0f %2.0f%%\\n\",\n                          i ? (1 << (i - 1)) + 1 : 1,\n                          1 << i,\n                          stats.http_read_hist[i],\n                          Math::doublePercent(stats.http_read_hist[i], stats.http_reads));\n    }\n    storeAppendPrintf(sentry, \"\\n\");\n    storeAppendPrintf(sentry, \"FTP I/O\\n\");\n    storeAppendPrintf(sentry, \"number of reads: %.0f\\n\", stats.ftp_reads);\n    storeAppendPrintf(sentry, \"Read Histogram:\\n\");\n    for (i = 0; i < IoStats::histSize; ++i) {\n        storeAppendPrintf(sentry, \"%5d-%5d: %9.0f %2.0f%%\\n\",\n                          i ? (1 << (i - 1)) + 1 : 1,\n                          1 << i,\n                          stats.ftp_read_hist[i],\n                          Math::doublePercent(stats.ftp_read_hist[i], stats.ftp_reads));\n    }\n    storeAppendPrintf(sentry, \"\\n\");\n    storeAppendPrintf(sentry, \"Gopher I/O\\n\");\n    storeAppendPrintf(sentry, \"number of reads: %.0f\\n\", stats.gopher_reads);\n    storeAppendPrintf(sentry, \"Read Histogram:\\n\");\n    for (i = 0; i < IoStats::histSize; ++i) {\n        storeAppendPrintf(sentry, \"%5d-%5d: %9.0f %2.0f%%\\n\",\n                          i ? (1 << (i - 1)) + 1 : 1,\n                          1 << i,\n                          stats.gopher_read_hist[i],\n                          Math::doublePercent(stats.gopher_read_hist[i], stats.gopher_reads));\n    }\n    storeAppendPrintf(sentry, \"\\n\");\n}", "target": 1}
{"code": "writefile(const char *name, struct string *s)\n{\n\tFILE *f;\n\tint ret;\n\tf = fopen(name, \"w\");\n\tif (!f) {\n\t\twarn(\"open %s:\", name);\n\t\treturn -1;\n\t}\n\tret = 0;\n\tif (fwrite(s->s, 1, s->n, f) != s->n || fflush(f) != 0) {\n\t\twarn(\"write %s:\", name);\n\t\tret = -1;\n\t}\n\tfclose(f);\n\treturn ret;\n}", "target": 1}
{"code": "static struct fdtable *close_files(struct files_struct * files)\n{\n\tstruct fdtable *fdt = rcu_dereference_raw(files->fdt);\n\tunsigned int i, j = 0;\n\tfor (;;) {\n\t\tunsigned long set;\n\t\ti = j * BITS_PER_LONG;\n\t\tif (i >= fdt->max_fds)\n\t\t\tbreak;\n\t\tset = fdt->open_fds[j++];\n\t\twhile (set) {\n\t\t\tif (set & 1) {\n\t\t\t\tstruct file * file = xchg(&fdt->fd[i], NULL);\n\t\t\t\tif (file) {\n\t\t\t\t\tfilp_close(file, files);\n\t\t\t\t\tcond_resched();\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t\tset >>= 1;\n\t\t}\n\t}\n\treturn fdt;\n}", "target": 0}
{"code": "  bool matches(const Http::RequestHeaderMap& headers) const override {\n    if (BaseMatcherImpl::matchRoute(headers)) {\n      if (headers.Path() == nullptr) {\n        return false;\n      }\n      const Http::HeaderString& path = headers.Path()->value();\n      const absl::string_view query_string = Http::Utility::findQueryStringStart(path);\n      absl::string_view path_view = path.getStringView();\n      path_view.remove_suffix(query_string.length());\n      if (path_matcher_->match(path_view)) {\n        ENVOY_LOG(debug, \"Regex requirement '{}' matched.\", regex_str_);\n        return true;\n      }\n    }\n    return false;\n  }", "target": 0}
{"code": "decode_sequence(const uint8_t *asn1, size_t len, const struct seq_info *seq,\n                void *val)\n{\n    krb5_error_code ret;\n    const uint8_t *contents;\n    size_t i, j, clen;\n    taginfo t;\n    assert(seq->n_fields > 0);\n    for (i = 0; i < seq->n_fields; i++) {\n        if (len == 0)\n            break;\n        ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len);\n        if (ret)\n            goto error;\n        for (; i < seq->n_fields; i++) {\n            if (check_atype_tag(seq->fields[i], &t))\n                break;\n            ret = omit_atype(seq->fields[i], val);\n            if (ret)\n                goto error;\n        }\n        if (i == seq->n_fields)\n            break;\n        ret = decode_atype(&t, contents, clen, seq->fields[i], val);\n        if (ret)\n            goto error;\n    }\n    for (; i < seq->n_fields; i++) {\n        ret = omit_atype(seq->fields[i], val);\n        if (ret)\n            goto error;\n    }\n    return 0;\nerror:\n    for (j = 0; j < i; j++)\n        free_atype(seq->fields[j], val);\n    for (j = 0; j < i; j++)\n        free_atype_ptr(seq->fields[j], val);\n    return ret;\n}", "target": 1}
{"code": "ErrorCode HTTP2Codec::checkNewStream(uint32_t streamId, bool trailersAllowed) {\n  if (streamId == 0) {\n    goawayErrorMessage_ = folly::to<string>(\n        \"GOAWAY error: received streamID=\", streamId,\n        \" as invalid new stream for lastStreamID_=\", lastStreamID_);\n    VLOG(4) << goawayErrorMessage_;\n    return ErrorCode::PROTOCOL_ERROR;\n  }\n  parsingDownstreamTrailers_ = trailersAllowed && (streamId <= lastStreamID_);\n  if (parsingDownstreamTrailers_) {\n    VLOG(4) << \"Parsing downstream trailers streamId=\" << streamId;\n  }\n  if (sessionClosing_ != ClosingState::CLOSED) {\n    lastStreamID_ = streamId;\n  }\n  if (isInitiatedStream(streamId)) {\n    goawayErrorMessage_ = folly::to<string>(\n        \"GOAWAY error: invalid new stream received with streamID=\", streamId);\n    VLOG(4) << goawayErrorMessage_;\n    return ErrorCode::PROTOCOL_ERROR;\n  } else {\n    return ErrorCode::NO_ERROR;\n  }\n}", "target": 1}
{"code": "pci_get_cfgdata16(struct pci_vdev *dev, int offset)\n{\n\tassert(offset <= (PCI_REGMAX - 1) && (offset & 1) == 0);\n\treturn (*(uint16_t *)(dev->cfgdata + offset));\n}", "target": 1}
{"code": "static int ep_scan_ready_list(struct eventpoll *ep,\n\t\t\t      int (*sproc)(struct eventpoll *,\n\t\t\t\t\t   struct list_head *, void *),\n\t\t\t      void *priv,\n\t\t\t      int depth)\n{\n\tint error, pwake = 0;\n\tunsigned long flags;\n\tstruct epitem *epi, *nepi;\n\tLIST_HEAD(txlist);\n\tmutex_lock_nested(&ep->mtx, depth);\n\tspin_lock_irqsave(&ep->lock, flags);\n\tlist_splice_init(&ep->rdllist, &txlist);\n\tep->ovflist = NULL;\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\terror = (*sproc)(ep, &txlist, priv);\n\tspin_lock_irqsave(&ep->lock, flags);\n\tfor (nepi = ep->ovflist; (epi = nepi) != NULL;\n\t     nepi = epi->next, epi->next = EP_UNACTIVE_PTR) {\n\t\tif (!ep_is_linked(&epi->rdllink))\n\t\t\tlist_add_tail(&epi->rdllink, &ep->rdllist);\n\t}\n\tep->ovflist = EP_UNACTIVE_PTR;\n\tlist_splice(&txlist, &ep->rdllist);\n\tif (!list_empty(&ep->rdllist)) {\n\t\tif (waitqueue_active(&ep->wq))\n\t\t\twake_up_locked(&ep->wq);\n\t\tif (waitqueue_active(&ep->poll_wait))\n\t\t\tpwake++;\n\t}\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\tmutex_unlock(&ep->mtx);\n\tif (pwake)\n\t\tep_poll_safewake(&ep->poll_wait);\n\treturn error;\n}", "target": 0}
{"code": "_SSL_match_hostname (const char *cert_hostname, const char *hostname)\n{\n\tconst char *cert_domain, *domain, *next_dot;\n\tif (g_ascii_strcasecmp (cert_hostname, hostname) == 0)\n\t\treturn 0;\n\tif (cert_hostname[0] == '*')\n\t{\n\t\tcert_domain = &cert_hostname[1];\n\t\tif (cert_domain[0] == '\\0')\n\t\t\treturn -1;\n\t\tif (cert_domain[0] != '.')\n\t\t\treturn -1;\n\t\tif (cert_domain[1] == '.')\n\t\t\treturn -1;\n\t\tnext_dot = strchr (&cert_domain[1], '.');\n\t\tif (next_dot == NULL)\n\t\t\treturn -1;\n\t\tif (next_dot[1] == '.')\n\t\t\treturn -1;\n\t\tdomain = strchr (hostname, '.');\n\t\tif (domain == NULL || strlen(domain) == 1)\n\t\t\treturn -1;\n\t\tif (g_ascii_strcasecmp (cert_domain, domain) == 0)\n\t\t\treturn 0;\n\t}\n\treturn -1;\n}", "target": 0}
{"code": "unquoted_glob_pattern_p (string)\n     register char *string;\n{\n  register int c;\n  char *send;\n  int open, bsquote;\n  DECLARE_MBSTATE;\n  open = bsquote = 0;\n  send = string + strlen (string);\n  while (c = *string++)\n    {\n      switch (c)\n\t{\n\tcase '?':\n\tcase '*':\n\t  return (1);\n\tcase '[':\n\t  open++;\n\t  continue;\n\tcase ']':\n\t  if (open)\n\t    return (1);\n\t  continue;\n\tcase '+':\n\tcase '@':\n\tcase '!':\n\t  if (*string == '(')\t\n\t    return (1);\n\t  continue;\n\tcase '\\\\':\n\t  if (*string != '\\0' && *string != '/')\n\t    {\n\t      bsquote = 1;\n\t      string++;\n\t      continue;\n\t    }\n\t  else if (*string == 0)\n\t    return (0);\n\tcase CTLESC:\n\t  if (*string++ == '\\0')\n\t    return (0);\n\t}\n#ifdef HANDLE_MULTIBYTE\n      string--;\n      ADVANCE_CHAR_P (string, send - string);\n      string++;\n#else\n      ADVANCE_CHAR_P (string, send - string);\n#endif\n    }\n  return ((bsquote && posix_glob_backslash) ? 2 : 0);\n}", "target": 1}
{"code": "GF_Err diST_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tchar str[1024];\n\tGF_DIMSScriptTypesBox *p = (GF_DIMSScriptTypesBox *)s;\n\ti=0;\n\tstr[0]=0;\n\twhile (1) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tif (!str[i]) break;\n\t\ti++;\n\t}\n\tISOM_DECREASE_SIZE(p, i);\n\tp->content_script_types = gf_strdup(str);\n\treturn GF_OK;\n}", "target": 1}
{"code": "error::Error GLES2DecoderImpl::HandleGetActiveAttrib(\n    uint32 immediate_data_size, const gles2::GetActiveAttrib& c) {\n  GLuint program = c.program;\n  GLuint index = c.index;\n  uint32 name_bucket_id = c.name_bucket_id;\n  typedef gles2::GetActiveAttrib::Result Result;\n  Result* result = GetSharedMemoryAs<Result*>(\n      c.result_shm_id, c.result_shm_offset, sizeof(*result));\n  if (!result) {\n    return error::kOutOfBounds;\n  }\n  if (result->success != 0) {\n    return error::kInvalidArguments;\n  }\n  ProgramManager::ProgramInfo* info = GetProgramInfoNotShader(\n      program, \"glGetActiveAttrib\");\n  if (!info) {\n    return error::kNoError;\n  }\n  const ProgramManager::ProgramInfo::VertexAttribInfo* attrib_info =\n      info->GetAttribInfo(index);\n  if (!attrib_info) {\n    SetGLError(GL_INVALID_VALUE, \"glGetActiveAttrib: index out of range\");\n    return error::kNoError;\n  }\n  result->success = 1;  \n  result->size = attrib_info->size;\n  result->type = attrib_info->type;\n  Bucket* bucket = CreateBucket(name_bucket_id);\n  bucket->SetFromString(attrib_info->name);\n  return error::kNoError;\n}", "target": 0}
{"code": "static int seed_from_urandom(uint32_t *seed) {\n    char data[sizeof(uint32_t)];\n    int ok;\n#if defined(HAVE_OPEN) && defined(HAVE_CLOSE) && defined(HAVE_READ)\n    int urandom;\n    urandom = open(\"/dev/urandom\", O_RDONLY);\n    if (urandom == -1)\n        return 1;\n    ok = read(urandom, data, sizeof(uint32_t)) == sizeof(uint32_t);\n    close(urandom);\n#else\n    FILE *urandom;\n    urandom = fopen(\"/dev/urandom\", \"rb\");\n    if (!urandom)\n        return 1;\n    ok = fread(data, 1, sizeof(uint32_t), urandom) == sizeof(uint32_t);\n    fclose(urandom);\n#endif\n    if (!ok)\n        return 1;\n    *seed = buf_to_uint32(data);\n    return 0;\n}", "target": 0}
{"code": "static int er_supported(ERContext *s)\n{\n    if(s->avctx->hwaccel && s->avctx->hwaccel->decode_slice           ||\n       !s->cur_pic.f                                                  ||\n       s->cur_pic.field_picture                                       ||\n       s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO\n    )\n        return 0;\n    return 1;\n}", "target": 1}
{"code": "static void prefetch_table(const volatile byte *tab, size_t len)\n{\n  size_t i;\n  for (i = 0; i < len; i += 8 * 32)\n    {\n      (void)tab[i + 0 * 32];\n      (void)tab[i + 1 * 32];\n      (void)tab[i + 2 * 32];\n      (void)tab[i + 3 * 32];\n      (void)tab[i + 4 * 32];\n      (void)tab[i + 5 * 32];\n      (void)tab[i + 6 * 32];\n      (void)tab[i + 7 * 32];\n    }\n  (void)tab[len - 1];\n}", "target": 1}
{"code": "  QInt32() {}", "target": 1}
{"code": "static int zipfileComparePath(const char *zA, const char *zB, int nB){\n  int nA = (int)strlen(zA);\n  if( zA[nA-1]=='/' ) nA--;\n  if( zB[nB-1]=='/' ) nB--;\n  if( nA==nB && memcmp(zA, zB, nA)==0 ) return 0;\n  return 1;\n}", "target": 0}
{"code": "asmlinkage void bad_mode(struct pt_regs *regs, int reason, unsigned int esr)\n{\n\tconsole_verbose();\n\tpr_crit(\"Bad mode in %s handler detected, code 0x%08x\\n\",\n\t\thandler[reason], esr);\n\tdie(\"Oops - bad mode\", regs, 0);\n\tlocal_irq_disable();\n\tpanic(\"bad mode\");\n}", "target": 1}
{"code": "static RBinWasmElementEntry *parse_element_entry(RBinWasmObj *bin, ut64 bound, ut32 index) {\n\tRBuffer *b = bin->buf;\n\tRBinWasmElementEntry *elem = R_NEW0 (RBinWasmElementEntry);\n\tif (elem) {\n\t\telem->sec_i = index;\n\t\telem->file_offset = r_buf_tell (b);\n\t\tif (!consume_u32_r (b, bound, &elem->index)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (!consume_init_expr_r (b, bound, R_BIN_WASM_END_OF_CODE, NULL)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (!consume_u32_r (b, bound, &elem->num_elem)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tut32 j = 0;\n\t\twhile (r_buf_tell (b) <= bound && j < elem->num_elem) {\n\t\t\tif (!consume_u32_r (b, bound, NULL)) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\t}\n\treturn elem;\nbeach:\n\tfree (elem);\n\treturn NULL;\n}", "target": 0}
{"code": "static int cma_addr_cmp(const struct sockaddr *src, const struct sockaddr *dst)\n{\n\tif (src->sa_family != dst->sa_family)\n\t\treturn -1;\n\tswitch (src->sa_family) {\n\tcase AF_INET:\n\t\treturn ((struct sockaddr_in *)src)->sin_addr.s_addr !=\n\t\t       ((struct sockaddr_in *)dst)->sin_addr.s_addr;\n\tcase AF_INET6: {\n\t\tstruct sockaddr_in6 *src_addr6 = (struct sockaddr_in6 *)src;\n\t\tstruct sockaddr_in6 *dst_addr6 = (struct sockaddr_in6 *)dst;\n\t\tbool link_local;\n\t\tif (ipv6_addr_cmp(&src_addr6->sin6_addr,\n\t\t\t\t\t  &dst_addr6->sin6_addr))\n\t\t\treturn 1;\n\t\tlink_local = ipv6_addr_type(&dst_addr6->sin6_addr) &\n\t\t\t     IPV6_ADDR_LINKLOCAL;\n\t\treturn link_local ? (src_addr6->sin6_scope_id !=\n\t\t\t\t     dst_addr6->sin6_scope_id) :\n\t\t\t\t    0;\n\t}\n\tdefault:\n\t\treturn ib_addr_cmp(&((struct sockaddr_ib *) src)->sib_addr,\n\t\t\t\t   &((struct sockaddr_ib *) dst)->sib_addr);\n\t}\n}", "target": 0}
{"code": "mysql_set_local_infile_handler(MYSQL *mysql,\n                               int (*local_infile_init)(void **, const char *,\n                               void *),\n                               int (*local_infile_read)(void *, char *, uint),\n                               void (*local_infile_end)(void *),\n                               int (*local_infile_error)(void *, char *, uint),\n                               void *userdata)\n{\n  mysql->options.local_infile_init=  local_infile_init;\n  mysql->options.local_infile_read=  local_infile_read;\n  mysql->options.local_infile_end=   local_infile_end;\n  mysql->options.local_infile_error= local_infile_error;\n  mysql->options.local_infile_userdata = userdata;\n}", "target": 0}
{"code": "ExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)\n{\n    unsigned nSyms = darray_size(expr->keysym_list.syms);\n    unsigned numEntries = darray_size(append->keysym_list.syms);\n    darray_append(expr->keysym_list.symsMapIndex, nSyms);\n    darray_append(expr->keysym_list.symsNumEntries, numEntries);\n    darray_concat(expr->keysym_list.syms, append->keysym_list.syms);\n    FreeStmt((ParseCommon *) &append);\n    return expr;\n}", "target": 1}
{"code": "ext4_xattr_release_block(handle_t *handle, struct inode *inode,\n\t\t\t struct buffer_head *bh)\n{\n\tstruct mb_cache_entry *ce = NULL;\n\tint error = 0;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\tce = mb_cache_entry_get(ext4_mb_cache, bh->b_bdev, bh->b_blocknr);\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terror = ext4_journal_get_write_access(handle, bh);\n\tif (error)\n\t\tgoto out;\n\tlock_buffer(bh);\n\tif (BHDR(bh)->h_refcount == cpu_to_le32(1)) {\n\t\tea_bdebug(bh, \"refcount now=0; freeing\");\n\t\tif (ce)\n\t\t\tmb_cache_entry_free(ce);\n\t\tget_bh(bh);\n\t\tunlock_buffer(bh);\n\t\text4_free_blocks(handle, inode, bh, 0, 1,\n\t\t\t\t EXT4_FREE_BLOCKS_METADATA |\n\t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\t} else {\n\t\tle32_add_cpu(&BHDR(bh)->h_refcount, -1);\n\t\tif (ce)\n\t\t\tmb_cache_entry_release(ce);\n\t\tif (ext4_handle_valid(handle))\n\t\t\terror = ext4_handle_dirty_xattr_block(handle, inode,\n\t\t\t\t\t\t\t      bh);\n\t\tunlock_buffer(bh);\n\t\tif (!ext4_handle_valid(handle))\n\t\t\terror = ext4_handle_dirty_xattr_block(handle, inode,\n\t\t\t\t\t\t\t      bh);\n\t\tif (IS_SYNC(inode))\n\t\t\text4_handle_sync(handle);\n\t\tdquot_free_block(inode, EXT4_C2B(EXT4_SB(inode->i_sb), 1));\n\t\tea_bdebug(bh, \"refcount now=%d; releasing\",\n\t\t\t  le32_to_cpu(BHDR(bh)->h_refcount));\n\t}\nout:\n\text4_std_error(inode->i_sb, error);\n\treturn;\n}", "target": 1}
{"code": "static uint16_t nvme_get_feature_timestamp(NvmeCtrl *n, NvmeRequest *req)\n{\n    uint64_t timestamp = nvme_get_timestamp(n);\n    return nvme_c2h(n, (uint8_t *)&timestamp, sizeof(timestamp), req);\n}", "target": 0}
{"code": "RawTile KakaduImage::getRegion( int seq, int ang, unsigned int res, int layers, int x, int y, unsigned int w, unsigned int h )\n{\n  unsigned int obpc = bpc;\n  if( bpc <= 16 && bpc > 8 ) obpc = 16;\n  else if( bpc <= 8 ) obpc = 8;\n#ifdef DEBUG\n  Timer timer;\n  timer.start();\n#endif\n  RawTile rawtile( 0, res, seq, ang, w, h, channels, obpc );\n  if( obpc == 16 ) rawtile.data = new unsigned short[w*h*channels];\n  else if( obpc == 8 ) rawtile.data = new unsigned char[w*h*channels];\n  else throw file_error( \"Kakadu :: Unsupported number of bits\" );\n  rawtile.dataLength = w*h*channels*(obpc/8);\n  rawtile.filename = getImagePath();\n  rawtile.timestamp = timestamp;\n  process( res, layers, x, y, w, h, rawtile.data );\n#ifdef DEBUG\n  logfile << \"Kakadu :: getRegion() :: \" << timer.getTime() << \" microseconds\" << endl;\n#endif\n  return rawtile;\n}", "target": 1}
{"code": "vte_sequence_handler_scroll_up (VteTerminal *terminal, GValueArray *params)\n{\n\tlong val = 1;\n\tGValue *value;\n\tif ((params != NULL) && (params->n_values > 0)) {\n\t\tvalue = g_value_array_get_nth(params, 0);\n\t\tif (G_VALUE_HOLDS_LONG(value)) {\n\t\t\tval = g_value_get_long(value);\n\t\t\tval = MAX(val, 1);\n\t\t}\n\t}\n\t_vte_terminal_scroll_text (terminal, -val);\n}", "target": 0}
{"code": "createFile(const string &filename, const StaticString &contents, mode_t permissions, uid_t owner,\n\tgid_t group, bool overwrite)\n{\n\tFileDescriptor fd;\n\tint ret, e, options;\n\toptions = O_WRONLY | O_CREAT | O_TRUNC;\n\tif (!overwrite) {\n\t\toptions |= O_EXCL;\n\t}\n\tdo {\n\t\tfd = open(filename.c_str(), options, permissions);\n\t} while (fd == -1 && errno == EINTR);\n\tif (fd != -1) {\n\t\tFileGuard guard(filename);\n\t\tdo {\n\t\t\tret = fchmod(fd, permissions);\n\t\t} while (ret == -1 && errno == EINTR);\n\t\tif (ret == -1) {\n\t\t\te = errno;\n\t\t\tthrow FileSystemException(\"Cannot set permissions on \" + filename,\n\t\t\t\te, filename);\n\t\t}\n\t\tif (owner != USER_NOT_GIVEN && group != GROUP_NOT_GIVEN) {\n\t\t\tif (owner == USER_NOT_GIVEN) {\n\t\t\t\towner = (uid_t) -1; \n\t\t\t}\n\t\t\tif (group == GROUP_NOT_GIVEN) {\n\t\t\t\tgroup = (gid_t) -1; \n\t\t\t}\n\t\t\tdo {\n\t\t\t\tret = fchown(fd, owner, group);\n\t\t\t} while (ret == -1 && errno == EINTR);\n\t\t\tif (ret == -1) {\n\t\t\t\te = errno;\n\t\t\t\tthrow FileSystemException(\"Cannot set ownership for \" + filename,\n\t\t\t\t\te, filename);\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\twriteExact(fd, contents);\n\t\t\tfd.close();\n\t\t} catch (const SystemException &e) {\n\t\t\tthrow FileSystemException(\"Cannot write to file \" + filename,\n\t\t\t\te.code(), filename);\n\t\t}\n\t\tguard.commit();\n\t} else {\n\t\te = errno;\n\t\tif (overwrite || e != EEXIST) {\n\t\t\tthrow FileSystemException(\"Cannot create file \" + filename,\n\t\t\t\te, filename);\n\t\t}\n\t}\n}", "target": 0}
{"code": "void hrandfieldCommand(client *c) {\n    long l;\n    int withvalues = 0;\n    robj *hash;\n    listpackEntry ele;\n    if (c->argc >= 3) {\n        if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;\n        if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"withvalues\"))) {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return;\n        } else if (c->argc == 4)\n            withvalues = 1;\n        hrandfieldWithCountCommand(c, l, withvalues);\n        return;\n    }\n    if ((hash = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp]))== NULL ||\n        checkType(c,hash,OBJ_HASH)) {\n        return;\n    }\n    hashTypeRandomElement(hash,hashTypeLength(hash),&ele,NULL);\n    hashReplyFromListpackEntry(c, &ele);\n}", "target": 1}
{"code": "yy_symbol_print (FILE *yyo,\n                 yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep, YYLTYPE const * const yylocationp, void *parm)\n{\n  YYFPRINTF (yyo, \"%s %s (\",\n             yykind < YYNTOKENS ? \"token\" : \"nterm\", yysymbol_name (yykind));\n  YY_LOCATION_PRINT (yyo, *yylocationp);\n  YYFPRINTF (yyo, \": \");\n  yy_symbol_value_print (yyo, yykind, yyvaluep, yylocationp, parm);\n  YYFPRINTF (yyo, \")\");\n}", "target": 1}
{"code": "bool ContentSettingsObserver::AllowScript(bool enabled_per_settings) {\n  if (!enabled_per_settings)\n    return false;\n  if (IsScriptDisabledForPreview(render_frame()))\n    return false;\n  if (is_interstitial_page_)\n    return true;\n  blink::WebLocalFrame* frame = render_frame()->GetWebFrame();\n  const auto it = cached_script_permissions_.find(frame);\n  if (it != cached_script_permissions_.end())\n    return it->second;\n  bool allow = true;\n  if (content_setting_rules_) {\n    ContentSetting setting = GetContentSettingFromRules(\n        content_setting_rules_->script_rules, frame,\n        url::Origin(frame->GetDocument().GetSecurityOrigin()).GetURL());\n    allow = setting != CONTENT_SETTING_BLOCK;\n  }\n  allow = allow || IsWhitelistedForContentSettings();\n  cached_script_permissions_[frame] = allow;\n  return allow;\n}", "target": 1}
{"code": "    bool read(ReadonlyBytes buffer)\n    {\n        auto fields_size = sizeof(EndOfCentralDirectory) - sizeof(u8*);\n        if (buffer.size() < fields_size)\n            return false;\n        if (memcmp(buffer.data(), end_of_central_directory_signature, sizeof(end_of_central_directory_signature)) != 0)\n            return false;\n        memcpy(reinterpret_cast<void*>(&disk_number), buffer.data() + sizeof(end_of_central_directory_signature), fields_size);\n        comment = buffer.data() + sizeof(end_of_central_directory_signature) + fields_size;\n        return true;\n    }", "target": 1}
{"code": "static pj_status_t STATUS_FROM_SSL_ERR(char *action, pj_ssl_sock_t *ssock,\n\t\t\t\t       unsigned long err)\n{\n    int level = 0;\n    int len = 0; \n    ERROR_LOG(\"STATUS_FROM_SSL_ERR\", err, ssock);\n    level++;\n    if (err == SSL_ERROR_SSL) {\n\terr = ERR_get_error();\n\tERROR_LOG(\"STATUS_FROM_SSL_ERR\", err, ssock);\n    }\n    ssock->last_err = err;\n    return GET_STATUS_FROM_SSL_ERR(err);\n}", "target": 1}
{"code": "gopherSendComplete(const Comm::ConnectionPointer &conn, char *, size_t size, Comm::Flag errflag, int xerrno, void *data)\n{\n    GopherStateData *gopherState = (GopherStateData *) data;\n    StoreEntry *entry = gopherState->entry;\n    debugs(10, 5, conn << \" size: \" << size << \" errflag: \" << errflag);\n    if (size > 0) {\n        fd_bytes(conn->fd, size, FD_WRITE);\n        statCounter.server.all.kbytes_out += size;\n        statCounter.server.other.kbytes_out += size;\n    }\n    if (!entry->isAccepting()) {\n        debugs(10, 3, \"terminating due to bad \" << *entry);\n        gopherState->serverConn->close();\n        return;\n    }\n    if (errflag) {\n        const auto err = new ErrorState(ERR_WRITE_ERROR, Http::scServiceUnavailable, gopherState->fwd->request, gopherState->fwd->al);\n        err->xerrno = xerrno;\n        err->port = gopherState->fwd->request->url.port();\n        err->url = xstrdup(entry->url());\n        gopherState->fwd->fail(err);\n        gopherState->serverConn->close();\n        return;\n    }\n    entry->buffer();\n    gopherMimeCreate(gopherState);\n    switch (gopherState->type_id) {\n    case GOPHER_DIRECTORY:\n        gopherState->conversion = GopherStateData::HTML_DIR;\n        gopherState->HTML_header_added = 0;\n        break;\n    case GOPHER_INDEX:\n        gopherState->conversion = GopherStateData::HTML_INDEX_RESULT;\n        gopherState->HTML_header_added = 0;\n        break;\n    case GOPHER_CSO:\n        gopherState->conversion = GopherStateData::HTML_CSO_RESULT;\n        gopherState->cso_recno = 0;\n        gopherState->HTML_header_added = 0;\n        break;\n    default:\n        gopherState->conversion = GopherStateData::NORMAL;\n        entry->flush();\n    }\n    GopherStateData::DelayAwareRead(gopherState);\n}", "target": 1}
{"code": "void trep_box_del(GF_Box *s)\n{\n\tGF_TrackExtensionPropertiesBox *ptr = (GF_TrackExtensionPropertiesBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}", "target": 0}
{"code": "rfbSendServerCutText(rfbScreenInfoPtr rfbScreen,char *str, int len)\n{\n    rfbClientPtr cl;\n    rfbServerCutTextMsg sct;\n    rfbClientIteratorPtr iterator;\n    iterator = rfbGetClientIterator(rfbScreen);\n    while ((cl = rfbClientIteratorNext(iterator)) != NULL) {\n        sct.type = rfbServerCutText;\n        sct.length = Swap32IfLE(len);\n        if (WriteExact(cl, (char *)&sct,\n                       sz_rfbServerCutTextMsg) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n            continue;\n        }\n        if (WriteExact(cl, str, len) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n        }\n    }\n    rfbReleaseClientIterator(iterator);\n}", "target": 1}
{"code": "static void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t      struct userfaultfd_wait_queue *ewq)\n{\n\tif (WARN_ON_ONCE(current->flags & PF_EXITING))\n\t\tgoto out;\n\tewq->ctx = ctx;\n\tinit_waitqueue_entry(&ewq->wq, current);\n\tspin_lock(&ctx->event_wqh.lock);\n\t__add_wait_queue(&ctx->event_wqh, &ewq->wq);\n\tfor (;;) {\n\t\tset_current_state(TASK_KILLABLE);\n\t\tif (ewq->msg.event == 0)\n\t\t\tbreak;\n\t\tif (READ_ONCE(ctx->released) ||\n\t\t    fatal_signal_pending(current)) {\n\t\t\t__remove_wait_queue(&ctx->event_wqh, &ewq->wq);\n\t\t\tif (ewq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tstruct userfaultfd_ctx *new;\n\t\t\t\tnew = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tewq->msg.arg.reserved.reserved1;\n\t\t\t\tuserfaultfd_ctx_put(new);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\t\twake_up_poll(&ctx->fd_wqh, POLLIN);\n\t\tschedule();\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->event_wqh.lock);\nout:\n\tuserfaultfd_ctx_put(ctx);\n}", "target": 1}
{"code": "static int hci_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t len, int flags)\n{\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint copied, err;\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\tif (flags & (MSG_OOB))\n\t\treturn -EOPNOTSUPP;\n\tif (sk->sk_state == BT_CLOSED)\n\t\treturn 0;\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\treturn err;\n\tmsg->msg_namelen = 0;\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tswitch (hci_pi(sk)->channel) {\n\tcase HCI_CHANNEL_RAW:\n\t\thci_sock_cmsg(sk, msg, skb);\n\t\tbreak;\n\tcase HCI_CHANNEL_USER:\n\tcase HCI_CHANNEL_CONTROL:\n\tcase HCI_CHANNEL_MONITOR:\n\t\tsock_recv_timestamp(msg, sk, skb);\n\t\tbreak;\n\t}\n\tskb_free_datagram(sk, skb);\n\treturn err ? : copied;\n}", "target": 1}
{"code": "static inline loff_t ext4_isize(struct ext4_inode *raw_inode)\n{\n\treturn ((loff_t)le32_to_cpu(raw_inode->i_size_high) << 32) |\n\t\tle32_to_cpu(raw_inode->i_size_lo);", "target": 1}
{"code": "static int _nfs4_proc_readdir(struct dentry *dentry, struct rpc_cred *cred,\n\t\tu64 cookie, struct page **pages, unsigned int count, int plus)\n{\n\tstruct inode\t\t*dir = dentry->d_inode;\n\tstruct nfs4_readdir_arg args = {\n\t\t.fh = NFS_FH(dir),\n\t\t.pages = pages,\n\t\t.pgbase = 0,\n\t\t.count = count,\n\t\t.bitmask = NFS_SERVER(dentry->d_inode)->attr_bitmask,\n\t\t.plus = plus,\n\t};\n\tstruct nfs4_readdir_res res;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_READDIR],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t\t.rpc_cred = cred,\n\t};\n\tint\t\t\tstatus;\n\tdprintk(\"%s: dentry = %s/%s, cookie = %Lu\\n\", __func__,\n\t\t\tdentry->d_parent->d_name.name,\n\t\t\tdentry->d_name.name,\n\t\t\t(unsigned long long)cookie);\n\tnfs4_setup_readdir(cookie, NFS_I(dir)->cookieverf, dentry, &args);\n\tres.pgbase = args.pgbase;\n\tstatus = nfs4_call_sync(NFS_SERVER(dir)->client, NFS_SERVER(dir), &msg, &args.seq_args, &res.seq_res, 0);\n\tif (status >= 0) {\n\t\tmemcpy(NFS_I(dir)->cookieverf, res.verifier.data, NFS4_VERIFIER_SIZE);\n\t\tstatus += args.pgbase;\n\t}\n\tnfs_invalidate_atime(dir);\n\tdprintk(\"%s: returns %d\\n\", __func__, status);\n\treturn status;\n}", "target": 0}
{"code": "static int bson_string_is_db_ref( const unsigned char *string, const int length ) {\n    int result = 0;\n    if( length >= 4 ) {\n        if( string[1] == 'r' && string[2] == 'e' && string[3] == 'f' )\n            result = 1;\n    }\n    else if( length >= 3 ) {\n        if( string[1] == 'i' && string[2] == 'd' )\n            result = 1;\n        else if( string[1] == 'd' && string[2] == 'b' )\n            result = 1;\n    }\n    return result;\n}", "target": 1}
{"code": "void __init acpi_debugfs_init(void)\n{\n\tacpi_debugfs_dir = debugfs_create_dir(\"acpi\", NULL);\n\tacpi_custom_method_init();\n}", "target": 1}
{"code": "  Compound_Selector_Obj Parser::parse_compound_selector()\n  {\n    Compound_Selector_Obj seq = SASS_MEMORY_NEW(Compound_Selector, pstate);\n    seq->media_block(last_media_block);\n    lex< css_whitespace >();\n    while (true)\n    {\n      lex< delimited_by< slash_star, star_slash, false > >(false);\n      if (match < re_pseudo_selector >())\n      {\n        seq->append(parse_simple_selector());\n      }\n      else if (lex< exactly<'&'> >(false))\n      {\n        if (!allow_parent) error(\"Parent selectors aren't allowed here.\");\n        seq->has_parent_reference(true);\n        seq->append(SASS_MEMORY_NEW(Parent_Selector, pstate));\n        if (seq->length() > 1) {\n          ParserState state(pstate);\n          Simple_Selector_Obj cur = (*seq)[seq->length()-1];\n          Simple_Selector_Obj prev = (*seq)[seq->length()-2];\n          std::string sel(prev->to_string({ NESTED, 5 }));\n          std::string found(cur->to_string({ NESTED, 5 }));\n          if (lex < identifier >()) { found += std::string(lexed); }\n          error(\"Invalid CSS after \\\"\" + sel + \"\\\": expected \\\"{\\\", was \\\"\" + found + \"\\\"\\n\\n\"\n            \"\\\"\" + found + \"\\\" may only be used at the beginning of a compound selector.\", state);\n        }\n      }\n      else if (lex< re_type_selector >(false))\n      {\n        seq->append(SASS_MEMORY_NEW(Type_Selector, pstate, lexed));\n      }\n      else if (peek< spaces >()) break;\n      else if (peek< end_of_file >()) { break; }\n      else if (peek_css < class_char < selector_combinator_ops > >()) break;\n      else if (peek_css < class_char < complex_selector_delims > >()) break;\n      else {\n        Simple_Selector_Obj sel = parse_simple_selector();\n        if (!sel) return {};\n        seq->append(sel);\n      }\n    }\n    if (seq && !peek_css<alternatives<end_of_file,exactly<'{'>>>()) {\n      seq->has_line_break(peek_newline());\n    }\n    return seq;\n  }", "target": 0}
{"code": "            Status readCString( StringData* out ) {\n                const void* x = memchr( _buffer + _position, 0, _maxLength - _position );\n                if ( !x )\n                    return makeError(\"no end of c-string\", _idElem);\n                uint64_t len = static_cast<uint64_t>( static_cast<const char*>(x) - ( _buffer + _position ) );\n                StringData data( _buffer + _position, len );\n                _position += len + 1;\n                if ( out ) {\n                    *out = data;\n                }\n                return Status::OK();\n            }", "target": 0}
{"code": "HttpStateData::getMoreRequestBody(MemBuf &buf)\n{\n    if (!flags.chunked_request)\n        return Client::getMoreRequestBody(buf);\n    MemBuf raw;\n    Must(requestBodySource != NULL);\n    if (!requestBodySource->getMoreData(raw))\n        return false; \n    const mb_size_t rawDataSize = raw.contentSize();\n    buf.init(16 + 2 + rawDataSize + 2 + 5, raw.max_capacity);\n    buf.appendf(\"%x\\r\\n\", static_cast<unsigned int>(rawDataSize));\n    buf.append(raw.content(), rawDataSize);\n    buf.append(\"\\r\\n\", 2);\n    Must(rawDataSize > 0); \n    if (receivedWholeRequestBody) {\n        Must(!flags.sentLastChunk);\n        flags.sentLastChunk = true;\n        buf.append(\"0\\r\\n\\r\\n\", 5);\n    }\n    return true;\n}", "target": 0}
{"code": "tiff12_print_page(gx_device_printer * pdev, gp_file * file)\n{\n    gx_device_tiff *const tfdev = (gx_device_tiff *)pdev;\n    int code;\n    if (gdev_prn_file_is_new(pdev)) {\n        tfdev->tif = tiff_from_filep(pdev, pdev->dname, file, tfdev->BigEndian, tfdev->UseBigTIFF);\n        if (!tfdev->tif)\n            return_error(gs_error_invalidfileaccess);\n    }\n    code = gdev_tiff_begin_page(tfdev, file);\n    if (code < 0)\n        return code;\n    TIFFSetField(tfdev->tif, TIFFTAG_BITSPERSAMPLE, 4);\n    tiff_set_rgb_fields(tfdev);\n    TIFFCheckpointDirectory(tfdev->tif);\n    {\n        int y;\n        int size = gdev_prn_raster(pdev);\n        byte *data = gs_alloc_bytes(pdev->memory, size, \"tiff12_print_page\");\n        if (data == 0)\n            return_error(gs_error_VMerror);\n        memset(data, 0, size);\n        for (y = 0; y < pdev->height; ++y) {\n            const byte *src;\n            byte *dest;\n            int x;\n            code = gdev_prn_copy_scan_lines(pdev, y, data, size);\n            if (code < 0)\n                break;\n            for (src = data, dest = data, x = 0; x < size;\n                 src += 6, dest += 3, x += 6\n                ) {\n                dest[0] = (src[0] & 0xf0) | (src[1] >> 4);\n                dest[1] = (src[2] & 0xf0) | (src[3] >> 4);\n                dest[2] = (src[4] & 0xf0) | (src[5] >> 4);\n            }\n            TIFFWriteScanline(tfdev->tif, data, y, 0);\n        }\n        gs_free_object(pdev->memory, data, \"tiff12_print_page\");\n        TIFFWriteDirectory(tfdev->tif);\n    }\n    return code;\n}", "target": 1}
{"code": "mm_zalloc(struct mm_master *mm, u_int ncount, u_int size)\n{\n\tif (size == 0 || ncount == 0 || ncount > SIZE_MAX / size)\n\t\tfatal(\"%s: mm_zalloc(%u, %u)\", __func__, ncount, size);\n\treturn mm_malloc(mm, size * ncount);\n}", "target": 1}
{"code": "void rfc_send_rls(tRFC_MCB* p_mcb, uint8_t dlci, bool is_command,\n uint8_t status) {\n uint8_t* p_data;\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(RFCOMM_CMD_BUF_SIZE);\n  p_buf->offset = L2CAP_MIN_OFFSET + RFCOMM_CTRL_FRAME_LEN;\n  p_data = (uint8_t*)(p_buf + 1) + p_buf->offset;\n *p_data++ = RFCOMM_EA | RFCOMM_I_CR(is_command) | RFCOMM_MX_RLS;\n *p_data++ = RFCOMM_EA | (RFCOMM_MX_RLS_LEN << 1);\n *p_data++ = RFCOMM_EA | RFCOMM_CR_MASK | (dlci << RFCOMM_SHIFT_DLCI);\n *p_data++ = RFCOMM_RLS_ERROR | status;\n  p_buf->len = RFCOMM_MX_RLS_LEN + 2;\n  rfc_send_buf_uih(p_mcb, RFCOMM_MX_DLCI, p_buf);\n}", "target": 0}
{"code": "static void save_text_if_changed(const char *name, const char *new_value)\n{\n    if (!g_hash_table_lookup(g_loaded_texts, name))\n        return;\n    const char *old_value = g_cd ? problem_data_get_content_or_NULL(g_cd, name) : \"\";\n    if (!old_value)\n        old_value = \"\";\n    if (strcmp(new_value, old_value) != 0)\n    {\n        struct dump_dir *dd = wizard_open_directory_for_writing(g_dump_dir_name);\n        if (dd)\n            dd_save_text(dd, name, new_value);\n        dd_close(dd);\n        problem_data_reload_from_dump_dir();\n        update_gui_state_from_problem_data( 0);\n    }\n}", "target": 1}
{"code": "static unsigned long __init init_range_memory_mapping(\n\t\t\t\t\t   unsigned long r_start,\n\t\t\t\t\t   unsigned long r_end)\n{\n\tunsigned long start_pfn, end_pfn;\n\tunsigned long mapped_ram_size = 0;\n\tint i;\n\tfor_each_mem_pfn_range(i, MAX_NUMNODES, &start_pfn, &end_pfn, NULL) {\n\t\tu64 start = clamp_val(PFN_PHYS(start_pfn), r_start, r_end);\n\t\tu64 end = clamp_val(PFN_PHYS(end_pfn), r_start, r_end);\n\t\tif (start >= end)\n\t\t\tcontinue;\n\t\tcan_use_brk_pgt = max(start, (u64)pgt_buf_end<<PAGE_SHIFT) >=\n\t\t\t\t    min(end, (u64)pgt_buf_top<<PAGE_SHIFT);\n\t\tinit_memory_mapping(start, end);\n\t\tmapped_ram_size += end - start;\n\t\tcan_use_brk_pgt = true;\n\t}\n\treturn mapped_ram_size;\n}", "target": 0}
{"code": "std::string Utf16ToUtf8(const std::wstring& utf16_string) {\n  return WC2MB(utf16_string, CP_UTF8);\n}", "target": 1}
{"code": "device_drive_poll_media_authorized_cb (Daemon *daemon,\n                                       Device *device,\n                                       DBusGMethodInvocation *context,\n                                       const gchar *action_id,\n                                       guint num_user_data,\n                                       gpointer *user_data_elements)\n{\n  int n;\n  char *argv[16];\n  n = 0;\n  argv[n++] = \"udisks-helper-drive-poll\";\n  argv[n++] = device->priv->device_file;\n  argv[n++] = NULL;\n  if (!job_new (context, \"DrivePollMedia\", FALSE, device, argv, NULL, drive_poll_media_completed_cb, FALSE, NULL, NULL))\n    {\n      goto out;\n    }\n out:\n  ;\n}", "target": 0}
{"code": "create_worker_threads(uint n)\n{\n\tcomp_thread_ctxt_t\t*threads;\n\tuint \t\t\ti;\n\tthreads = (comp_thread_ctxt_t *)\n\t\tmy_malloc(sizeof(comp_thread_ctxt_t) * n, MYF(MY_FAE));\n\tfor (i = 0; i < n; i++) {\n\t\tcomp_thread_ctxt_t *thd = threads + i;\n\t\tthd->num = i + 1;\n\t\tthd->started = FALSE;\n\t\tthd->cancelled = FALSE;\n\t\tthd->data_avail = FALSE;\n\t\tthd->to = (char *) my_malloc(COMPRESS_CHUNK_SIZE +\n\t\t\t\t\t\t   MY_QLZ_COMPRESS_OVERHEAD,\n\t\t\t\t\t\t   MYF(MY_FAE));\n\t\tif (pthread_mutex_init(&thd->ctrl_mutex, NULL) ||\n\t\t    pthread_cond_init(&thd->ctrl_cond, NULL)) {\n\t\t\tgoto err;\n\t\t}\n\t\tif (pthread_mutex_init(&thd->data_mutex, NULL) ||\n\t\t    pthread_cond_init(&thd->data_cond, NULL)) {\n\t\t\tgoto err;\n\t\t}\n\t\tpthread_mutex_lock(&thd->ctrl_mutex);\n\t\tif (pthread_create(&thd->id, NULL, compress_worker_thread_func,\n\t\t\t\t   thd)) {\n\t\t\tmsg(\"compress: pthread_create() failed: \"\n\t\t\t    \"errno = %d\", errno);\n\t\t\tgoto err;\n\t\t}\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tcomp_thread_ctxt_t *thd = threads + i;\n\t\twhile (thd->started == FALSE)\n\t\t\tpthread_cond_wait(&thd->ctrl_cond, &thd->ctrl_mutex);\n\t\tpthread_mutex_unlock(&thd->ctrl_mutex);\n\t}\n\treturn threads;\nerr:\n\tmy_free(threads);\n\treturn NULL;\n}", "target": 1}
{"code": "bool RenderView::runFileChooser(\n    const WebKit::WebFileChooserParams& params,\n    WebFileChooserCompletion* chooser_completion) {\n  ViewHostMsg_RunFileChooser_Params ipc_params;\n  ipc_params.mode = params.multiSelect ?\n      ViewHostMsg_RunFileChooser_Params::OpenMultiple :\n      ViewHostMsg_RunFileChooser_Params::Open;\n  ipc_params.title = params.title;\n  ipc_params.default_file_name =\n      webkit_glue::WebStringToFilePath(params.initialValue);\n  return ScheduleFileChooser(ipc_params, chooser_completion);\n}", "target": 0}
{"code": "static int ioapic_service(struct kvm_ioapic *ioapic, int irq, bool line_status)\n{\n\tunion kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];\n\tstruct kvm_lapic_irq irqe;\n\tint ret;\n\tif (entry->fields.mask)\n\t\treturn -1;\n\tioapic_debug(\"dest=%x dest_mode=%x delivery_mode=%x \"\n\t\t     \"vector=%x trig_mode=%x\\n\",\n\t\t     entry->fields.dest_id, entry->fields.dest_mode,\n\t\t     entry->fields.delivery_mode, entry->fields.vector,\n\t\t     entry->fields.trig_mode);\n\tirqe.dest_id = entry->fields.dest_id;\n\tirqe.vector = entry->fields.vector;\n\tirqe.dest_mode = entry->fields.dest_mode;\n\tirqe.trig_mode = entry->fields.trig_mode;\n\tirqe.delivery_mode = entry->fields.delivery_mode << 8;\n\tirqe.level = 1;\n\tirqe.shorthand = 0;\n\tif (irqe.trig_mode == IOAPIC_EDGE_TRIG)\n\t\tioapic->irr &= ~(1 << irq);\n\tif (irq == RTC_GSI && line_status) {\n\t\tBUG_ON(ioapic->rtc_status.pending_eoi != 0);\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe,\n\t\t\t\tioapic->rtc_status.dest_map);\n\t\tioapic->rtc_status.pending_eoi = ret;\n\t} else\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe, NULL);\n\tif (ret && irqe.trig_mode == IOAPIC_LEVEL_TRIG)\n\t\tentry->fields.remote_irr = 1;\n\treturn ret;\n}", "target": 1}
{"code": "static void php_mb_regex_free_cache(php_mb_regex_t **pre) \n{\n\tonig_free(*pre);\n}", "target": 1}
{"code": "static int hash(struct signal_struct *sig, unsigned int nr)\n{\n\treturn hash_32(hash32_ptr(sig) ^ nr, HASH_BITS(posix_timers_hashtable));\n}", "target": 0}
{"code": "FileSystemOperation* FileSystemOperation::AsFileSystemOperation() {\n  return this;\n}", "target": 0}
{"code": "static void *bpf_obj_do_get(const struct filename *pathname,\n\t\t\t    enum bpf_type *type)\n{\n\tstruct inode *inode;\n\tstruct path path;\n\tvoid *raw;\n\tint ret;\n\tret = kern_path(pathname->name, LOOKUP_FOLLOW, &path);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\tinode = d_backing_inode(path.dentry);\n\tret = inode_permission(inode, MAY_WRITE);\n\tif (ret)\n\t\tgoto out;\n\tret = bpf_inode_type(inode, type);\n\tif (ret)\n\t\tgoto out;\n\traw = bpf_any_get(inode->i_private, *type);\n\ttouch_atime(&path);\n\tpath_put(&path);\n\treturn raw;\nout:\n\tpath_put(&path);\n\treturn ERR_PTR(ret);\n}", "target": 1}
{"code": "static int prealloc_elems_and_freelist(struct bpf_stack_map *smap)\n{\n\tu32 elem_size = sizeof(struct stack_map_bucket) + smap->map.value_size;\n\tint err;\n\tsmap->elems = bpf_map_area_alloc(elem_size * smap->map.max_entries,\n\t\t\t\t\t smap->map.numa_node);\n\tif (!smap->elems)\n\t\treturn -ENOMEM;\n\terr = pcpu_freelist_init(&smap->freelist);\n\tif (err)\n\t\tgoto free_elems;\n\tpcpu_freelist_populate(&smap->freelist, smap->elems, elem_size,\n\t\t\t       smap->map.max_entries);\n\treturn 0;\nfree_elems:\n\tbpf_map_area_free(smap->elems);\n\treturn err;\n}", "target": 1}
{"code": "int rm_rf_child(int fd, const char *name, RemoveFlags flags) {\n        if (fd < 0)\n                return -EBADF;\n        if (!filename_is_valid(name))\n                return -EINVAL;\n        if ((flags & (REMOVE_ROOT|REMOVE_MISSING_OK)) != 0) \n                return -EINVAL;\n        if (FLAGS_SET(flags, REMOVE_ONLY_DIRECTORIES|REMOVE_SUBVOLUME))\n                return -EINVAL;\n        return rm_rf_children_inner(fd, name, -1, flags, NULL);\n}", "target": 1}
{"code": "unsigned int X509v3_addr_get_afi(const IPAddressFamily *f)\n{\n    return ((f != NULL &&\n             f->addressFamily != NULL && f->addressFamily->data != NULL)\n            ? ((f->addressFamily->data[0] << 8) | (f->addressFamily->data[1]))\n            : 0);\n}", "target": 1}
{"code": "int detach_capi_ctr(struct capi_ctr *ctr)\n{\n\tint err = 0;\n\tmutex_lock(&capi_controller_lock);\n\tctr_down(ctr, CAPI_CTR_DETACHED);\n\tif (capi_controller[ctr->cnr - 1] != ctr) {\n\t\terr = -EINVAL;\n\t\tgoto unlock_out;\n\t}\n\tcapi_controller[ctr->cnr - 1] = NULL;\n\tncontrollers--;\n\tif (ctr->procent)\n\t\tremove_proc_entry(ctr->procfn, NULL);\n\tprintk(KERN_NOTICE \"kcapi: controller [%03d]: %s unregistered\\n\",\n\t       ctr->cnr, ctr->name);\nunlock_out:\n\tmutex_unlock(&capi_controller_lock);\n\treturn err;\n}", "target": 1}
{"code": "static int get_gate_page(struct mm_struct *mm, unsigned long address,\n\t\tunsigned int gup_flags, struct vm_area_struct **vma,\n\t\tstruct page **page)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *pte;\n\tint ret = -EFAULT;\n\tif (gup_flags & FOLL_WRITE)\n\t\treturn -EFAULT;\n\tif (address > TASK_SIZE)\n\t\tpgd = pgd_offset_k(address);\n\telse\n\t\tpgd = pgd_offset_gate(mm, address);\n\tBUG_ON(pgd_none(*pgd));\n\tp4d = p4d_offset(pgd, address);\n\tBUG_ON(p4d_none(*p4d));\n\tpud = pud_offset(p4d, address);\n\tBUG_ON(pud_none(*pud));\n\tpmd = pmd_offset(pud, address);\n\tif (!pmd_present(*pmd))\n\t\treturn -EFAULT;\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\tpte = pte_offset_map(pmd, address);\n\tif (pte_none(*pte))\n\t\tgoto unmap;\n\t*vma = get_gate_vma(mm);\n\tif (!page)\n\t\tgoto out;\n\t*page = vm_normal_page(*vma, address, *pte);\n\tif (!*page) {\n\t\tif ((gup_flags & FOLL_DUMP) || !is_zero_pfn(pte_pfn(*pte)))\n\t\t\tgoto unmap;\n\t\t*page = pte_page(*pte);\n\t\tif (is_device_public_page(*page))\n\t\t\tgoto unmap;\n\t}\n\tget_page(*page);\nout:\n\tret = 0;\nunmap:\n\tpte_unmap(pte);\n\treturn ret;\n}", "target": 1}
{"code": "selaGetCombName(SELA    *sela,\n                l_int32  size,\n                l_int32  direction)\n{\nchar    *selname;\nchar     combname[L_BUF_SIZE];\nl_int32  i, nsels, sx, sy, found;\nSEL     *sel;\n    PROCNAME(\"selaGetCombName\");\n    if (!sela)\n        return (char *)ERROR_PTR(\"sela not defined\", procName, NULL);\n    if (direction != L_HORIZ && direction != L_VERT)\n        return (char *)ERROR_PTR(\"invalid direction\", procName, NULL);\n    if (direction == L_HORIZ)\n        snprintf(combname, L_BUF_SIZE, \"sel_comb_%dh\", size);\n    else  \n        snprintf(combname, L_BUF_SIZE, \"sel_comb_%dv\", size);\n    found = FALSE;\n    nsels = selaGetCount(sela);\n    for (i = 0; i < nsels; i++) {\n        sel = selaGetSel(sela, i);\n        selGetParameters(sel, &sy, &sx, NULL, NULL);\n        if (sy != 1 && sx != 1)  \n            continue;\n        selname = selGetName(sel);\n        if (!strcmp(selname, combname)) {\n            found = TRUE;\n            break;\n        }\n    }\n    if (found)\n        return stringNew(selname);\n    else\n        return (char *)ERROR_PTR(\"sel not found\", procName, NULL);\n}", "target": 1}
{"code": "static void smp_task_done(struct sas_task *task)\n{\n\tif (!del_timer(&task->slow_task->timer))\n\t\treturn;\n\tcomplete(&task->slow_task->completion);\n}", "target": 1}
{"code": "new_msg_lsa_change_notify (u_char msgtype,\n\t\t\t   u_int32_t seqnum,\n\t\t\t   struct in_addr ifaddr,\n\t\t\t   struct in_addr area_id,\n\t\t\t   u_char is_self_originated, struct lsa_header *data)\n{\n  u_char buf[OSPF_API_MAX_MSG_SIZE];\n  struct msg_lsa_change_notify *nmsg;\n  int len;\n  assert (data);\n  nmsg = (struct msg_lsa_change_notify *) buf;\n  len = ntohs (data->length) + sizeof (struct msg_lsa_change_notify)\n    - sizeof (struct lsa_header);\n  nmsg->ifaddr = ifaddr;\n  nmsg->area_id = area_id;\n  nmsg->is_self_originated = is_self_originated;\n  memset (&nmsg->pad, 0, sizeof (nmsg->pad));\n  memcpy (&nmsg->data, data, ntohs (data->length));\n  return msg_new (msgtype, nmsg, seqnum, len);\n}", "target": 1}
{"code": "static int cbs_av1_read_uvlc(CodedBitstreamContext *ctx, GetBitContext *gbc,\n                             const char *name, uint32_t *write_to,\n                             uint32_t range_min, uint32_t range_max)\n{\n    uint32_t value;\n    int position, zeroes, i, j;\n    char bits[65];\n    if (ctx->trace_enable)\n        position = get_bits_count(gbc);\n    zeroes = i = 0;\n    while (1) {\n        if (get_bits_left(gbc) < zeroes + 1) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid uvlc code at \"\n                   \"%s: bitstream ended.\\n\", name);\n            return AVERROR_INVALIDDATA;\n        }\n        if (get_bits1(gbc)) {\n            bits[i++] = '1';\n            break;\n        } else {\n            bits[i++] = '0';\n            ++zeroes;\n        }\n    }\n    if (zeroes >= 32) {\n        value = MAX_UINT_BITS(32);\n    } else {\n        value = get_bits_long(gbc, zeroes);\n        for (j = 0; j < zeroes; j++)\n            bits[i++] = (value >> (zeroes - j - 1) & 1) ? '1' : '0';\n        value += (1 << zeroes) - 1;\n    }\n    if (ctx->trace_enable) {\n        bits[i] = 0;\n        ff_cbs_trace_syntax_element(ctx, position, name, NULL,\n                                    bits, value);\n    }\n    if (value < range_min || value > range_max) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"%s out of range: \"\n               \"%\"PRIu32\", but must be in [%\"PRIu32\",%\"PRIu32\"].\\n\",\n               name, value, range_min, range_max);\n        return AVERROR_INVALIDDATA;\n    }\n    *write_to = value;\n    return 0;\n}", "target": 1}
{"code": "static TPM_RESULT SWTPM_NVRAM_GetFilenameForName(char *filename,        \n                                                 size_t bufsize,\n                                                 uint32_t tpm_number,\n                                                 const char *name,      \n                                                 bool is_tempfile)      \n{\n    TPM_RESULT res = TPM_SUCCESS;\n    int n;\n    const char *suffix = \"\";\n    TPM_DEBUG(\" SWTPM_NVRAM_GetFilenameForName: For name %s\\n\", name);\n    switch (tpmversion) {\n    case TPMLIB_TPM_VERSION_1_2:\n        break;\n    case TPMLIB_TPM_VERSION_2:\n        suffix = \"2\";\n        break;\n    }\n    if (is_tempfile) {\n        n = snprintf(filename, bufsize, \"%s/TMP%s-%02lx.%s\",\n                     state_directory, suffix, (unsigned long)tpm_number, name);\n    } else {\n        n = snprintf(filename, bufsize, \"%s/tpm%s-%02lx.%s\",\n                     state_directory, suffix, (unsigned long)tpm_number, name);\n    }\n    if ((size_t)n > bufsize) {\n        res = TPM_FAIL;\n    }\n    TPM_DEBUG(\"  SWTPM_NVRAM_GetFilenameForName: File name %s\\n\", filename);\n    return res;\n}", "target": 0}
{"code": "static uint16_t nvme_tx(NvmeCtrl *n, NvmeSg *sg, uint8_t *ptr, uint32_t len,\n                        NvmeTxDirection dir)\n{\n    assert(sg->flags & NVME_SG_ALLOC);\n    if (sg->flags & NVME_SG_DMA) {\n        const MemTxAttrs attrs = MEMTXATTRS_UNSPECIFIED;\n        dma_addr_t residual;\n        if (dir == NVME_TX_DIRECTION_TO_DEVICE) {\n            dma_buf_write(ptr, len, &residual, &sg->qsg, attrs);\n        } else {\n            dma_buf_read(ptr, len, &residual, &sg->qsg, attrs);\n        }\n        if (unlikely(residual)) {\n            trace_pci_nvme_err_invalid_dma();\n            return NVME_INVALID_FIELD | NVME_DNR;\n        }\n    } else {\n        size_t bytes;\n        if (dir == NVME_TX_DIRECTION_TO_DEVICE) {\n            bytes = qemu_iovec_to_buf(&sg->iov, 0, ptr, len);\n        } else {\n            bytes = qemu_iovec_from_buf(&sg->iov, 0, ptr, len);\n        }\n        if (unlikely(bytes != len)) {\n            trace_pci_nvme_err_invalid_dma();\n            return NVME_INVALID_FIELD | NVME_DNR;\n        }\n    }\n    return NVME_SUCCESS;\n}", "target": 0}
{"code": "sg_new_read(Sg_fd * sfp, char __user *buf, size_t count, Sg_request * srp)\n{\n\tsg_io_hdr_t *hp = &srp->header;\n\tint err = 0, err2;\n\tint len;\n\tif (in_compat_syscall()) {\n\t\tif (count < sizeof(struct compat_sg_io_hdr)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\t} else if (count < SZ_SG_IO_HDR) {\n\t\terr = -EINVAL;\n\t\tgoto err_out;\n\t}\n\thp->sb_len_wr = 0;\n\tif ((hp->mx_sb_len > 0) && hp->sbp) {\n\t\tif ((CHECK_CONDITION & hp->masked_status) ||\n\t\t    (DRIVER_SENSE & hp->driver_status)) {\n\t\t\tint sb_len = SCSI_SENSE_BUFFERSIZE;\n\t\t\tsb_len = (hp->mx_sb_len > sb_len) ? sb_len : hp->mx_sb_len;\n\t\t\tlen = 8 + (int) srp->sense_b[7];\t\n\t\t\tlen = (len > sb_len) ? sb_len : len;\n\t\t\tif (copy_to_user(hp->sbp, srp->sense_b, len)) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\thp->sb_len_wr = len;\n\t\t}\n\t}\n\tif (hp->masked_status || hp->host_status || hp->driver_status)\n\t\thp->info |= SG_INFO_CHECK;\n\terr = put_sg_io_hdr(hp, buf);\nerr_out:\n\terr2 = sg_finish_rem_req(srp);\n\tsg_remove_request(sfp, srp);\n\treturn err ? : err2 ? : count;\n}", "target": 0}
{"code": "spnego_gss_complete_auth_token(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tgss_buffer_t input_message_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_complete_auth_token(minor_status,\n\t\t\t\t      context_handle,\n\t\t\t\t      input_message_buffer);\n\treturn (ret);\n}", "target": 0}
{"code": "static void bnx2x_set_reset_done(struct bnx2x *bp)\n{\n\tu32 val;\n\tu32 bit = BP_PATH(bp) ?\n\t\tBNX2X_PATH1_RST_IN_PROG_BIT : BNX2X_PATH0_RST_IN_PROG_BIT;\n\tbnx2x_acquire_hw_lock(bp, HW_LOCK_RESOURCE_RECOVERY_REG);\n\tval = REG_RD(bp, BNX2X_RECOVERY_GLOB_REG);\n\tval &= ~bit;\n\tREG_WR(bp, BNX2X_RECOVERY_GLOB_REG, val);\n\tbnx2x_release_hw_lock(bp, HW_LOCK_RESOURCE_RECOVERY_REG);\n}", "target": 0}
{"code": "static void __mcheck_cpu_init_timer(void)\n{\n\tstruct timer_list *t = this_cpu_ptr(&mce_timer);\n\ttimer_setup(t, mce_timer_fn, TIMER_PINNED);\n\tmce_start_timer(t);\n}", "target": 0}
{"code": "static inline void SMTPTransactionComplete(SMTPState *state)\n{\n    DEBUG_VALIDATE_BUG_ON(state->curr_tx == NULL);\n    if (state->curr_tx)\n        state->curr_tx->done = 1;\n}", "target": 1}
{"code": "int options_parse(CONF_TYPE type) {\n    SERVICE_OPTIONS *section;\n    options_defaults();\n    section=&new_service_options;\n    if(options_file(configuration_file, type, &section))\n        return 1;\n    if(init_section(1, &section))\n        return 1;\n    s_log(LOG_NOTICE, \"Configuration successful\");\n    return 0;\n}", "target": 1}
{"code": "unsigned short bebytes2ushort(const u8 *buf)\n{\n\tif (buf == NULL)\n\t\treturn 0U;\n\treturn (unsigned short) (buf[0] << 8 | buf[1]);\n}", "target": 0}
{"code": "static int udf_symlink_filler(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct buffer_head *bh = NULL;\n\tunsigned char *symlink;\n\tint err = -EIO;\n\tunsigned char *p = kmap(page);\n\tstruct udf_inode_info *iinfo;\n\tuint32_t pos;\n\tiinfo = UDF_I(inode);\n\tpos = udf_block_map(inode, 0);\n\tdown_read(&iinfo->i_data_sem);\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\tsymlink = iinfo->i_ext.i_data + iinfo->i_lenEAttr;\n\t} else {\n\t\tbh = sb_bread(inode->i_sb, pos);\n\t\tif (!bh)\n\t\t\tgoto out;\n\t\tsymlink = bh->b_data;\n\t}\n\tudf_pc_to_char(inode->i_sb, symlink, inode->i_size, p);\n\tbrelse(bh);\n\tup_read(&iinfo->i_data_sem);\n\tSetPageUptodate(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn 0;\nout:\n\tup_read(&iinfo->i_data_sem);\n\tSetPageError(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn err;\n}", "target": 1}
{"code": "bool allow_svhandler_flash_range(size_t start, size_t end) {\n  if (start > end) return false;\n  if (start < FLASH_ORIGIN || end > FLASH_END) return false;\n  bool startAllowed = false;\n  bool endAllowed = false;\n  for (const FlashSector* s = flash_sector_map; s->use != FLASH_INVALID; s++) {\n    if (allow_svhandler_flash_sector(s)) {\n      if (!startAllowed &&\n          start + 1 > start &&\n          do_memory_ranges_overlap(start, start + 1, s->start, s->start + s->len)) {\n        startAllowed = true;\n      }\n      if (!endAllowed &&\n          end - 1 < end &&\n          do_memory_ranges_overlap(end - 1, end, s->start, s->start + s->len)) {\n        endAllowed = true;\n      }\n    } else {\n      if (do_memory_ranges_overlap(start, end, s->start, s->start + s->len)) return false;\n    }\n  }\n  if (!startAllowed || !endAllowed) return false;\n  return true;\n}", "target": 0}
{"code": "d_lite_inspect_raw(VALUE self)\n{\n    get_d1(self);\n    return mk_inspect_raw(dat, rb_obj_class(self));\n}", "target": 0}
{"code": "setContext(XML_Parser parser, const XML_Char *context) {\n  DTD *const dtd = parser->m_dtd; \n  const XML_Char *s = context;\n  while (*context != XML_T('\\0')) {\n    if (*s == CONTEXT_SEP || *s == XML_T('\\0')) {\n      ENTITY *e;\n      if (! poolAppendChar(&parser->m_tempPool, XML_T('\\0')))\n        return XML_FALSE;\n      e = (ENTITY *)lookup(parser, &dtd->generalEntities,\n                           poolStart(&parser->m_tempPool), 0);\n      if (e)\n        e->open = XML_TRUE;\n      if (*s != XML_T('\\0'))\n        s++;\n      context = s;\n      poolDiscard(&parser->m_tempPool);\n    } else if (*s == XML_T(ASCII_EQUALS)) {\n      PREFIX *prefix;\n      if (poolLength(&parser->m_tempPool) == 0)\n        prefix = &dtd->defaultPrefix;\n      else {\n        if (! poolAppendChar(&parser->m_tempPool, XML_T('\\0')))\n          return XML_FALSE;\n        prefix\n            = (PREFIX *)lookup(parser, &dtd->prefixes,\n                               poolStart(&parser->m_tempPool), sizeof(PREFIX));\n        if (! prefix)\n          return XML_FALSE;\n        if (prefix->name == poolStart(&parser->m_tempPool)) {\n          prefix->name = poolCopyString(&dtd->pool, prefix->name);\n          if (! prefix->name)\n            return XML_FALSE;\n        }\n        poolDiscard(&parser->m_tempPool);\n      }\n      for (context = s + 1; *context != CONTEXT_SEP && *context != XML_T('\\0');\n           context++)\n        if (! poolAppendChar(&parser->m_tempPool, *context))\n          return XML_FALSE;\n      if (! poolAppendChar(&parser->m_tempPool, XML_T('\\0')))\n        return XML_FALSE;\n      if (addBinding(parser, prefix, NULL, poolStart(&parser->m_tempPool),\n                     &parser->m_inheritedBindings)\n          != XML_ERROR_NONE)\n        return XML_FALSE;\n      poolDiscard(&parser->m_tempPool);\n      if (*context != XML_T('\\0'))\n        ++context;\n      s = context;\n    } else {\n      if (! poolAppendChar(&parser->m_tempPool, *s))\n        return XML_FALSE;\n      s++;\n    }\n  }\n  return XML_TRUE;\n}", "target": 0}
{"code": "static void print_value(int output, int num, const char *devname,\n\t\t\tconst char *value, const char *name, size_t valsz)\n{\n\tif (output & OUTPUT_VALUE_ONLY) {\n\t\tfputs(value, stdout);\n\t\tfputc('\\n', stdout);\n\t} else if (output & OUTPUT_UDEV_LIST) {\n\t\tprint_udev_format(name, value);\n\t} else if (output & OUTPUT_EXPORT_LIST) {\n\t\tif (num == 1 && devname)\n\t\t\tprintf(\"DEVNAME=%s\\n\", devname);\n\t\tfputs(name, stdout);\n\t\tfputs(\"=\", stdout);\n\t\tsafe_print(value, valsz, NULL);\n\t\tfputs(\"\\n\", stdout);\n\t} else {\n\t\tif (num == 1 && devname)\n\t\t\tprintf(\"%s:\", devname);\n\t\tfputs(\" \", stdout);\n\t\tfputs(name, stdout);\n\t\tfputs(\"=\\\"\", stdout);\n\t\tsafe_print(value, valsz, \"\\\"\");\n\t\tfputs(\"\\\"\", stdout);\n\t}\n}", "target": 1}
{"code": "TEST_F(QueryPlannerTest, AndWithNestedNE) {\n    addIndex(BSON(\"a\" << 1));\n    runQuery(fromjson(\"{a: {$gt: -1, $lt: 1, $ne: 0}}\"));\n    assertNumSolutions(2U);\n    assertSolutionExists(\"{cscan: {dir: 1}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: null, node: {ixscan: {pattern: {a:1}, \"\n        \"bounds: {a: [[-1,0,false,false], \"\n        \"[0,1,false,false]]}}}}}\");\n}", "target": 0}
{"code": "flatpak_run_add_cups_args (FlatpakBwrap *bwrap)\n{\n  g_autofree char * sandbox_server_name = g_strdup (\"/var/run/cups/cups.sock\");\n  g_autofree char * cups_server_name = flatpak_run_get_cups_server_name ();\n  if (!g_file_test (cups_server_name, G_FILE_TEST_EXISTS))\n    {\n      g_debug (\"Could not find CUPS server\");\n      return;\n    }\n  flatpak_bwrap_add_args (bwrap,\n                          \"--ro-bind\", cups_server_name, sandbox_server_name,\n                          NULL);\n}", "target": 0}
{"code": "static int ssi_sd_load(QEMUFile *f, void *opaque, int version_id)\n{\n    SSISlave *ss = SSI_SLAVE(opaque);\n    ssi_sd_state *s = (ssi_sd_state *)opaque;\n    int i;\n    if (version_id != 1)\n        return -EINVAL;\n    s->mode = qemu_get_be32(f);\n    s->cmd = qemu_get_be32(f);\n    for (i = 0; i < 4; i++)\n        s->cmdarg[i] = qemu_get_be32(f);\n    for (i = 0; i < 5; i++)\n        s->response[i] = qemu_get_be32(f);\n    s->arglen = qemu_get_be32(f);\n    s->response_pos = qemu_get_be32(f);\n    s->stopping = qemu_get_be32(f);\n    ss->cs = qemu_get_be32(f);\n    return 0;\n}", "target": 1}
{"code": "static void rfc2231_decode_one (char *dest, char *src)\n{\n  char *d;\n  for (d = dest; *src; src++)\n  {\n    if (*src == '%' &&\n        isxdigit ((unsigned char) *(src + 1)) &&\n        isxdigit ((unsigned char) *(src + 2)))\n    {\n      *d++ = (hexval (*(src + 1)) << 4) | (hexval (*(src + 2)));\n      src += 2;\n    }\n    else\n      *d++ = *src;\n  }\n  *d = '\\0';\n}", "target": 0}
{"code": "static int regex_match_front(char *str, struct regex *r, int len)\n{\n\tif (len && len < r->len)\n\t\treturn 0;\n\treturn strncmp(str, r->pattern, r->len) == 0;\n}", "target": 0}
{"code": "STATIC int\nS_edit_distance(const UV* src,\n                const UV* tgt,\n                const STRLEN x,             \n                const STRLEN y,             \n                const SSize_t maxDistance\n)\n{\n    item *head = NULL;\n    UV swapCount, swapScore, targetCharCount, i, j;\n    UV *scores;\n    UV score_ceil = x + y;\n    PERL_ARGS_ASSERT_EDIT_DISTANCE;\n    Newx(scores, ( (x + 2) * (y + 2)), UV);\n    scores[0] = score_ceil;\n    scores[1 * (y + 2) + 0] = score_ceil;\n    scores[0 * (y + 2) + 1] = score_ceil;\n    scores[1 * (y + 2) + 1] = 0;\n    head = uniquePush(uniquePush(head, src[0]), tgt[0]);\n    for (i=1;i<=x;i++) {\n        if (i < x)\n            head = uniquePush(head, src[i]);\n        scores[(i+1) * (y + 2) + 1] = i;\n        scores[(i+1) * (y + 2) + 0] = score_ceil;\n        swapCount = 0;\n        for (j=1;j<=y;j++) {\n            if (i == 1) {\n                if(j < y)\n                head = uniquePush(head, tgt[j]);\n                scores[1 * (y + 2) + (j + 1)] = j;\n                scores[0 * (y + 2) + (j + 1)] = score_ceil;\n            }\n            targetCharCount = find(head, tgt[j-1])->value;\n            swapScore = scores[targetCharCount * (y + 2) + swapCount] + i - targetCharCount - 1 + j - swapCount;\n            if (src[i-1] != tgt[j-1]){\n                scores[(i+1) * (y + 2) + (j + 1)] = MIN(swapScore,(MIN(scores[i * (y + 2) + j], MIN(scores[(i+1) * (y + 2) + j], scores[i * (y + 2) + (j + 1)])) + 1));\n            }\n            else {\n                swapCount = j;\n                scores[(i+1) * (y + 2) + (j + 1)] = MIN(scores[i * (y + 2) + j], swapScore);\n            }\n        }\n        find(head, src[i-1])->value = i;\n    }\n    {\n        IV score = scores[(x+1) * (y + 2) + (y + 1)];\n        dict_free(head);\n        Safefree(scores);\n        return (maxDistance != 0 && maxDistance < score)?(-1):score;\n    }", "target": 0}
{"code": "tTcpIpPacketParsingResult ParaNdis_CheckSumVerifyFlat(\n                                                PVOID pBuffer,\n                                                ULONG ulDataLength,\n                                                ULONG flags,\n                                                LPCSTR caller)\n{\n    tCompletePhysicalAddress SGBuffer;\n    SGBuffer.Virtual = pBuffer;\n    SGBuffer.size = ulDataLength;\n    return ParaNdis_CheckSumVerify(&SGBuffer, ulDataLength, 0, flags, caller);\n}", "target": 1}
{"code": "mrb_proc_copy(mrb_state *mrb, struct RProc *a, struct RProc *b)\n{\n  if (a->body.irep) {\n    return;\n  }\n  a->flags = b->flags;\n  a->body = b->body;\n  a->upper = b->upper;\n  if (!MRB_PROC_CFUNC_P(a) && a->body.irep) {\n    mrb_irep_incref(mrb, (mrb_irep*)a->body.irep);\n  }\n  a->e.env = b->e.env;\n}", "target": 1}
{"code": "  void createDebugInfo() override {\n    llvm_unreachable(\"Accessing debug info from a lazy module\");\n  }", "target": 1}
{"code": "static QSvgNode *createPathNode(QSvgNode *parent,\n                                const QXmlStreamAttributes &attributes,\n                                QSvgHandler *)\n{\n    QStringRef data      = attributes.value(QLatin1String(\"d\"));\n    QPainterPath qpath;\n    qpath.setFillRule(Qt::WindingFill);\n    parsePathDataFast(data, qpath);\n    QSvgNode *path = new QSvgPath(parent, qpath);\n    return path;\n}", "target": 1}
{"code": "static noinline void key_gc_unused_keys(struct list_head *keys)\n{\n\twhile (!list_empty(keys)) {\n\t\tstruct key *key =\n\t\t\tlist_entry(keys->next, struct key, graveyard_link);\n\t\tlist_del(&key->graveyard_link);\n\t\tkdebug(\"- %u\", key->serial);\n\t\tkey_check(key);\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&\n\t\t    !test_bit(KEY_FLAG_NEGATIVE, &key->flags) &&\n\t\t    key->type->destroy)\n\t\t\tkey->type->destroy(key);\n\t\tsecurity_key_free(key);\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\t\tatomic_dec(&key->user->nkeys);\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))\n\t\t\tatomic_dec(&key->user->nikeys);\n\t\tkey_user_put(key->user);\n\t\tkfree(key->description);\n#ifdef KEY_DEBUGGING\n\t\tkey->magic = KEY_DEBUG_MAGIC_X;\n#endif\n\t\tkmem_cache_free(key_jar, key);\n\t}\n}", "target": 0}
{"code": "static int ssl_flight_append( mbedtls_ssl_context *ssl )\n{\n    mbedtls_ssl_flight_item *msg;\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> ssl_flight_append\" ) );\n    MBEDTLS_SSL_DEBUG_BUF( 4, \"message appended to flight\",\n                           ssl->out_msg, ssl->out_msglen );\n    if( ( msg = mbedtls_calloc( 1, sizeof(  mbedtls_ssl_flight_item ) ) ) == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"alloc %\" MBEDTLS_PRINTF_SIZET \" bytes failed\",\n                            sizeof( mbedtls_ssl_flight_item ) ) );\n        return( MBEDTLS_ERR_SSL_ALLOC_FAILED );\n    }\n    if( ( msg->p = mbedtls_calloc( 1, ssl->out_msglen ) ) == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"alloc %\" MBEDTLS_PRINTF_SIZET \" bytes failed\",\n                                    ssl->out_msglen ) );\n        mbedtls_free( msg );\n        return( MBEDTLS_ERR_SSL_ALLOC_FAILED );\n    }\n    memcpy( msg->p, ssl->out_msg, ssl->out_msglen );\n    msg->len = ssl->out_msglen;\n    msg->type = ssl->out_msgtype;\n    msg->next = NULL;\n    if( ssl->handshake->flight == NULL )\n        ssl->handshake->flight = msg;\n    else\n    {\n        mbedtls_ssl_flight_item *cur = ssl->handshake->flight;\n        while( cur->next != NULL )\n            cur = cur->next;\n        cur->next = msg;\n    }\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= ssl_flight_append\" ) );\n    return( 0 );\n}", "target": 0}
{"code": "vmod_append(VRT_CTX, VCL_HEADER hdr, VCL_STRANDS s)\n{\n\tstruct http *hp;\n\tstruct strands st[1];\n\tconst char *p[s->n + 2];\n\tconst char *b;\n\tCHECK_OBJ_NOTNULL(ctx, VRT_CTX_MAGIC);\n\tp[0] = hdr->what + 1;\n\tp[1] = \" \";\n\tAN(memcpy(p + 2, s->p, s->n * sizeof *s->p));\n\tst->n = s->n + 2;\n\tst->p = p;\n\tb = VRT_StrandsWS(ctx->ws, NULL, st);\n\thp = VRT_selecthttp(ctx, hdr->where);\n\thttp_SetHeader(hp, b);\n}", "target": 1}
{"code": "ciKlass* ciEnv::get_klass_by_index(const constantPoolHandle& cpool,\n                                   int index,\n                                   bool& is_accessible,\n                                   ciInstanceKlass* accessor) {\n  GUARDED_VM_ENTRY(return get_klass_by_index_impl(cpool, index, is_accessible, accessor);)\n}", "target": 0}
{"code": "void RequestContext::StartBackendSpanAndSetTraceContext() {\n  backend_span_.reset(CreateSpan(cloud_trace_.get(), \"Backend\"));\n  std::string trace_context_header = cloud_trace()->ToTraceContextHeader(\n      backend_span_->trace_span()->span_id());\n  Status status = request()->AddHeaderToBackend(\n      cloud_trace()->header_type() == HeaderType::CLOUD_TRACE_CONTEXT\n          ? kCloudTraceContextHeader\n          : kGRpcTraceContextHeader,\n      trace_context_header);\n  if (!status.ok()) {\n    service_context()->env()->LogError(\n        \"Failed to set trace context header to backend.\");\n  }\n}", "target": 1}
{"code": "static unsigned long get_seg_limit(struct pt_regs *regs, int seg_reg_idx)\n{\n\tstruct desc_struct *desc;\n\tunsigned long limit;\n\tshort sel;\n\tsel = get_segment_selector(regs, seg_reg_idx);\n\tif (sel < 0)\n\t\treturn 0;\n\tif (user_64bit_mode(regs) || v8086_mode(regs))\n\t\treturn -1L;\n\tif (!sel)\n\t\treturn 0;\n\tdesc = get_desc(sel);\n\tif (!desc)\n\t\treturn 0;\n\tlimit = get_desc_limit(desc);\n\tif (desc->g)\n\t\tlimit = (limit << 12) + 0xfff;\n\treturn limit;\n}", "target": 1}
{"code": "static int dsa_missing_parameters(const EVP_PKEY *pkey)\n{\n    DSA *dsa;\n    dsa = pkey->pkey.dsa;\n    if ((dsa->p == NULL) || (dsa->q == NULL) || (dsa->g == NULL))\n        return 1;\n    return 0;\n}", "target": 0}
{"code": "void ZlibInStream::removeUnderlying()\n{\n  ptr = end = start;\n  if (!underlying) return;\n  while (bytesIn > 0) {\n    decompress(true);\n    end = start; \n  }\n  underlying = 0;\n}", "target": 1}
{"code": "NOEXPORT int init_section(int eof, SERVICE_OPTIONS **section_ptr) {\n    char *errstr;\n#ifndef USE_WIN32\n    (*section_ptr)->option.log_stderr=new_global_options.option.log_stderr;\n#endif \n    if(*section_ptr==&new_service_options) {\n        errstr=parse_global_option(CMD_INITIALIZE, NULL, NULL);\n        if(errstr) {\n            s_log(LOG_ERR, \"Global options: %s\", errstr);\n            return 1;\n        }\n    }\n    if(*section_ptr!=&new_service_options || eof) {\n        if(*section_ptr==&new_service_options)\n            s_log(LOG_INFO, \"Initializing inetd mode configuration\");\n        else\n            s_log(LOG_INFO, \"Initializing service [%s]\",\n                (*section_ptr)->servname);\n        errstr=parse_service_option(CMD_INITIALIZE, section_ptr, NULL, NULL);\n        if(errstr) {\n            if(*section_ptr==&new_service_options)\n                s_log(LOG_ERR, \"Inetd mode: %s\", errstr);\n            else\n                s_log(LOG_ERR, \"Service [%s]: %s\",\n                    (*section_ptr)->servname, errstr);\n            return 1;\n        }\n    }\n    return 0;\n}", "target": 1}
{"code": "static void adjust_branches(struct bpf_prog *prog, int pos, int delta)\n{\n\tstruct bpf_insn *insn = prog->insnsi;\n\tint insn_cnt = prog->len;\n\tint i;\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (BPF_CLASS(insn->code) != BPF_JMP ||\n\t\t    BPF_OP(insn->code) == BPF_CALL ||\n\t\t    BPF_OP(insn->code) == BPF_EXIT)\n\t\t\tcontinue;\n\t\tif (i < pos && i + insn->off + 1 > pos)\n\t\t\tinsn->off += delta;\n\t\telse if (i > pos && i + insn->off + 1 < pos)\n\t\t\tinsn->off -= delta;\n\t}\n}", "target": 1}
{"code": "int flush_completed_IO(struct inode *inode)\n{\n\text4_io_end_t *io;\n\tint ret = 0;\n\tint ret2 = 0;\n\tif (list_empty(&EXT4_I(inode)->i_completed_io_list))\n\t\treturn ret;\n\tdump_completed_IO(inode);\n\twhile (!list_empty(&EXT4_I(inode)->i_completed_io_list)){\n\t\tio = list_entry(EXT4_I(inode)->i_completed_io_list.next,\n\t\t\t\text4_io_end_t, list);\n\t\tret = ext4_end_io_nolock(io);\n\t\tif (ret < 0)\n\t\t\tret2 = ret;\n\t\telse\n\t\t\tlist_del_init(&io->list);\n\t}\n\treturn (ret2 < 0) ? ret2 : 0;\n}", "target": 1}
{"code": "static void umocktypes_free_bool_ptr(bool** value)\n{\n    if (*value != NULL)\n    {\n        my_gballoc_free(*value);\n    }\n}", "target": 0}
{"code": "mm_sync_list(struct mmtree *oldtree, struct mmtree *newtree,\n    struct mm_master *mm, struct mm_master *mmold)\n{\n\tstruct mm_master *mmalloc = mm->mmalloc;\n\tstruct mm_share *mms, *new;\n\tRB_FOREACH(mms, mmtree, oldtree) {\n\t\tmm_memvalid(mmold, mms, sizeof(struct mm_share));\n\t\tmm_memvalid(mm, mms->address, mms->size);\n\t\tnew = mm_xmalloc(mmalloc, sizeof(struct mm_share));\n\t\tmemcpy(new, mms, sizeof(struct mm_share));\n\t\tRB_INSERT(mmtree, newtree, new);\n\t}\n}", "target": 1}
{"code": "static int wcd9335_probe(struct wcd9335_codec *wcd)\n{\n\tstruct device *dev = wcd->dev;\n\tmemcpy(wcd->rx_chs, wcd9335_rx_chs, sizeof(wcd9335_rx_chs));\n\tmemcpy(wcd->tx_chs, wcd9335_tx_chs, sizeof(wcd9335_tx_chs));\n\twcd->sido_input_src = SIDO_SOURCE_INTERNAL;\n\twcd->sido_voltage = SIDO_VOLTAGE_NOMINAL_MV;\n\treturn devm_snd_soc_register_component(dev, &wcd9335_component_drv,\n\t\t\t\t\t       wcd9335_slim_dais,\n\t\t\t\t\t       ARRAY_SIZE(wcd9335_slim_dais));\n}", "target": 0}
{"code": "MenuCache* menu_cache_lookup( const char* menu_name )\n{\n    MenuCache* cache;\n    MENU_CACHE_LOCK;\n#if !GLIB_CHECK_VERSION(2, 32, 0)\n    if(!sync_run_mutex)\n        sync_run_mutex = g_mutex_new();\n    if(!sync_run_cond)\n        sync_run_cond = g_cond_new();\n#endif\n    if( G_UNLIKELY( ! hash ) )\n        hash = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, NULL );\n    else\n    {\n        cache = (MenuCache*)g_hash_table_lookup(hash, menu_name);\n        if( cache )\n        {\n            menu_cache_ref(cache);\n            MENU_CACHE_UNLOCK;\n            return cache;\n        }\n    }\n    MENU_CACHE_UNLOCK;\n    cache = menu_cache_create(menu_name);\n    cache->cancellable = g_cancellable_new();\n#if GLIB_CHECK_VERSION(2, 32, 0)\n    cache->thr = g_thread_new(menu_name, menu_cache_loader_thread, cache);\n#else\n    cache->thr = g_thread_create(menu_cache_loader_thread, cache, TRUE, NULL);\n#endif\n    return cache;\n}", "target": 0}
{"code": "static void mce_start_timer(struct timer_list *t)\n{\n\tunsigned long iv = check_interval * HZ;\n\tif (mca_cfg.ignore_ce || !iv)\n\t\treturn;\n\tthis_cpu_write(mce_next_interval, iv);\n\t__start_timer(t, iv);\n}", "target": 0}
{"code": "update_ldap_mod_auth_ind(krb5_context context, krb5_db_entry *entry,\n                         LDAPMod ***mods)\n{\n    int i = 0;\n    krb5_error_code ret;\n    char *auth_ind = NULL;\n    char *strval[10] = {};\n    char *ai, *ai_save = NULL;\n    int sv_num = sizeof(strval) / sizeof(*strval);\n    ret = krb5_dbe_get_string(context, entry, KRB5_KDB_SK_REQUIRE_AUTH,\n                              &auth_ind);\n    if (ret || auth_ind == NULL)\n        goto cleanup;\n    ai = strtok_r(auth_ind, \" \", &ai_save);\n    while (ai != NULL && i < sv_num) {\n        strval[i++] = ai;\n        ai = strtok_r(NULL, \" \", &ai_save);\n    }\n    ret = krb5_add_str_mem_ldap_mod(mods, \"krbPrincipalAuthInd\",\n                                    LDAP_MOD_REPLACE, strval);\ncleanup:\n    krb5_dbe_free_string(context, auth_ind);\n    return ret;\n}", "target": 0}
{"code": "njs_json_push_parse_state(njs_vm_t *vm, njs_json_parse_t *parse,\n    njs_value_t *value)\n{\n    njs_json_state_t  *state;\n    if (njs_slow_path(parse->depth >= NJS_JSON_MAX_DEPTH)) {\n        njs_type_error(vm, \"Nested too deep or a cyclic structure\");\n        return NULL;\n    }\n    state = &parse->states[parse->depth++];\n    state->value = *value;\n    state->index = 0;\n    state->prop = NULL;\n    state->keys = njs_value_own_enumerate(vm, value, NJS_ENUM_KEYS,\n                                          NJS_ENUM_STRING, 0);\n    if (state->keys == NULL) {\n        return NULL;\n    }\n    return state;\n}", "target": 1}
{"code": "static struct sem_undo *find_alloc_undo(struct ipc_namespace *ns, int semid)\n{\n\tstruct sem_array *sma;\n\tstruct sem_undo_list *ulp;\n\tstruct sem_undo *un, *new;\n\tint nsems;\n\tint error;\n\terror = get_undo_list(&ulp);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\trcu_read_lock();\n\tspin_lock(&ulp->lock);\n\tun = lookup_undo(ulp, semid);\n\tspin_unlock(&ulp->lock);\n\tif (likely(un!=NULL))\n\t\tgoto out;\n\tsma = sem_obtain_object_check(ns, semid);\n\tif (IS_ERR(sma)) {\n\t\trcu_read_unlock();\n\t\treturn ERR_CAST(sma);\n\t}\n\tnsems = sma->sem_nsems;\n\tipc_rcu_getref(sma);\n\trcu_read_unlock();\n\tnew = kzalloc(sizeof(struct sem_undo) + sizeof(short)*nsems, GFP_KERNEL);\n\tif (!new) {\n\t\tsem_putref(sma);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tsem_lock_and_putref(sma);\n\tif (sma->sem_perm.deleted) {\n\t\tsem_unlock(sma);\n\t\tkfree(new);\n\t\tun = ERR_PTR(-EIDRM);\n\t\tgoto out;\n\t}\n\tspin_lock(&ulp->lock);\n\tun = lookup_undo(ulp, semid);\n\tif (un) {\n\t\tkfree(new);\n\t\tgoto success;\n\t}\n\tnew->semadj = (short *) &new[1];\n\tnew->ulp = ulp;\n\tnew->semid = semid;\n\tassert_spin_locked(&ulp->lock);\n\tlist_add_rcu(&new->list_proc, &ulp->list_proc);\n\tassert_spin_locked(&sma->sem_perm.lock);\n\tlist_add(&new->list_id, &sma->list_id);\n\tun = new;\nsuccess:\n\tspin_unlock(&ulp->lock);\n\trcu_read_lock();\n\tsem_unlock(sma);\nout:\n\treturn un;\n}", "target": 1}
{"code": "GF_EXPORT\nGF_Err gf_isom_box_write(GF_Box *a, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu64 pos = gf_bs_get_position(bs);\n\tif (!a) return GF_BAD_PARAM;\n\tif (!a->size) return GF_OK;\n\tif (a->registry->disabled) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box %s disabled registry, skip write\\n\", gf_4cc_to_str(a->type)));\n\t\treturn GF_OK;\n\t}\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box %s size %d write\\n\", gf_4cc_to_str(a->type), a->size));\n\te = gf_isom_box_write_listing(a, bs);\n\tif (e) return e;\n\tif (a->child_boxes) {\n\t\te = gf_isom_box_array_write(a, a->child_boxes, bs);\n\t}\n\tpos = gf_bs_get_position(bs) - pos;\n\tif (pos != a->size) {\n\t\tif (a->type != GF_ISOM_BOX_TYPE_MDAT) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box %s wrote \"LLU\" bytes but size is \"LLU\"\\n\", gf_4cc_to_str(a->type), pos, a->size ));\n\t\t}\n\t}\n\treturn e;", "target": 1}
{"code": "comics_decompress_temp_dir (const gchar *command_decompress_tmp,\n\t\t\t    const gchar *command, \n\t\t\t    GError      **error)\n{\n\tgboolean success;\n\tgchar *std_out, *basename;\n\tGError *err = NULL;\n\tgint retval;\n\tsuccess = g_spawn_command_line_sync (command_decompress_tmp, &std_out, \n\t\t\t\t\t     NULL, &retval, &err);\n\tbasename = g_path_get_basename (command);\n\tif (!success) {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR, \n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"Error launching the command “%s” in order to \"\n\t\t\t     \"decompress the comic book: %s\"),\n\t\t\t     basename,\n\t\t\t     err->message);\n\t\tg_error_free (err);\n\t} else if (WIFEXITED (retval)) {\n\t\tif (WEXITSTATUS (retval) == EXIT_SUCCESS) {\n\t\t\tg_free (std_out);\n\t\t\tg_free (basename);\n\t\t\treturn TRUE;\n\t\t} else {\n\t\t\tg_set_error (error,\n\t\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t\t     _(\"The command “%s” failed at \"\n\t\t\t\t     \"decompressing the comic book.\"),\n\t\t\t\t     basename);\n\t\t\tg_free (std_out);\n\t\t}\n\t} else {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"The command “%s” did not end normally.\"),\n\t\t\t     basename);\n\t\tg_free (std_out);\n\t}\n\tg_free (basename);\n\treturn FALSE;\n}", "target": 0}
{"code": "static cfg_opt_t *cfg_dupopt_array(cfg_opt_t *opts)\n{\n\tint i;\n\tcfg_opt_t *dupopts;\n\tint n = cfg_numopts(opts);\n\tdupopts = calloc(n + 1, sizeof(cfg_opt_t));\n\tif (!dupopts)\n\t\treturn NULL;\n\tmemcpy(dupopts, opts, n * sizeof(cfg_opt_t));\n\tfor (i = 0; i < n; i++) {\n\t\tdupopts[i].name = NULL;\n\t\tdupopts[i].subopts = NULL;\n\t\tdupopts[i].def.parsed = NULL;\n\t\tdupopts[i].def.string = NULL;\n\t\tdupopts[i].comment = NULL;\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tdupopts[i].name = strdup(opts[i].name);\n\t\tif (!dupopts[i].name)\n\t\t\tgoto err;\n\t\tif (opts[i].subopts) {\n\t\t\tdupopts[i].subopts = cfg_dupopt_array(opts[i].subopts);\n\t\t\tif (!dupopts[i].subopts)\n\t\t\t\tgoto err;\n\t\t}\n\t\tif (opts[i].def.parsed) {\n\t\t\tdupopts[i].def.parsed = strdup(opts[i].def.parsed);\n\t\t\tif (!dupopts[i].def.parsed)\n\t\t\t\tgoto err;\n\t\t}\n\t\tif (opts[i].def.string) {\n\t\t\tdupopts[i].def.string = strdup(opts[i].def.string);\n\t\t\tif (!dupopts[i].def.string)\n\t\t\t\tgoto err;\n\t\t}\n\t\tif (opts[i].comment) {\n\t\t\tdupopts[i].comment = strdup(opts[i].comment);\n\t\t\tif (!dupopts[i].comment)\n\t\t\t\tgoto err;\n\t\t}\n\t}\n\treturn dupopts;\nerr:\n\tcfg_free_opt_array(dupopts);\n\treturn NULL;\n}", "target": 0}
{"code": "static bool rbuf_switch_to_malloc(conn *c) {\n    size_t size = c->rsize * 2;\n    char *tmp = malloc(size);\n    if (!tmp)\n        return false;\n    do_cache_free(c->thread->rbuf_cache, c->rbuf);\n    memcpy(tmp, c->rcurr, c->rbytes);\n    c->rcurr = c->rbuf = tmp;\n    c->rsize = size;\n    c->rbuf_malloced = true;\n    return true;\n}", "target": 0}
{"code": "static int http1_on_request(http1_parser_s *parser) {\n  http1pr_s *p = parser2http(parser);\n  http_on_request_handler______internal(&http1_pr2handle(p), p->p.settings);\n  if (p->request.method && !p->stop)\n    http_finish(&p->request);\n  h1_reset(p);\n  return !p->close && fio_is_closed(p->p.uuid);\n}", "target": 1}
{"code": "ldbm_config_search_entry_callback(Slapi_PBlock *pb __attribute__((unused)),\n                                  Slapi_Entry *e,\n                                  Slapi_Entry *entryAfter __attribute__((unused)),\n                                  int *returncode,\n                                  char *returntext,\n                                  void *arg)\n{\n    char buf[BUFSIZ];\n    struct berval *vals[2];\n    struct berval val;\n    struct ldbminfo *li = (struct ldbminfo *)arg;\n    config_info *config;\n    int scope;\n    vals[0] = &val;\n    vals[1] = NULL;\n    returntext[0] = '\\0';\n    PR_Lock(li->li_config_mutex);\n    if (pb) {\n        slapi_pblock_get(pb, SLAPI_SEARCH_SCOPE, &scope);\n        if (scope == LDAP_SCOPE_BASE) {\n            char **attrs = NULL;\n            slapi_pblock_get(pb, SLAPI_SEARCH_ATTRS, &attrs);\n            if (attrs) {\n                for (size_t i = 0; attrs[i]; i++) {\n                    if (ldbm_config_moved_attr(attrs[i])) {\n                        slapi_pblock_set(pb, SLAPI_PB_RESULT_TEXT, \"at least one required attribute has been moved to the BDB scecific configuration entry\");\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    for (config = ldbm_config; config->config_name != NULL; config++) {\n        if (!(config->config_flags & (CONFIG_FLAG_ALWAYS_SHOW | CONFIG_FLAG_PREVIOUSLY_SET))) {\n            continue;\n        }\n        ldbm_config_get((void *)li, config, buf);\n        val.bv_val = buf;\n        val.bv_len = strlen(buf);\n        slapi_entry_attr_replace(e, config->config_name, vals);\n    }\n    PR_Unlock(li->li_config_mutex);\n    *returncode = LDAP_SUCCESS;\n    return SLAPI_DSE_CALLBACK_OK;\n}", "target": 1}
{"code": "static int fuse_get_user_pages(struct fuse_req *req, const char __user *buf,\n\t\t\t       size_t *nbytesp, int write)\n{\n\tsize_t nbytes = *nbytesp;\n\tunsigned long user_addr = (unsigned long) buf;\n\tunsigned offset = user_addr & ~PAGE_MASK;\n\tint npages;\n\tif (segment_eq(get_fs(), KERNEL_DS)) {\n\t\tif (write)\n\t\t\treq->in.args[1].value = (void *) user_addr;\n\t\telse\n\t\t\treq->out.args[0].value = (void *) user_addr;\n\t\treturn 0;\n\t}\n\tnbytes = min_t(size_t, nbytes, FUSE_MAX_PAGES_PER_REQ << PAGE_SHIFT);\n\tnpages = (nbytes + offset + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tnpages = clamp(npages, 1, FUSE_MAX_PAGES_PER_REQ);\n\tdown_read(&current->mm->mmap_sem);\n\tnpages = get_user_pages(current, current->mm, user_addr, npages, !write,\n\t\t\t\t0, req->pages, NULL);\n\tup_read(&current->mm->mmap_sem);\n\tif (npages < 0)\n\t\treturn npages;\n\treq->num_pages = npages;\n\treq->page_offset = offset;\n\tif (write)\n\t\treq->in.argpages = 1;\n\telse\n\t\treq->out.argpages = 1;\n\tnbytes = (req->num_pages << PAGE_SHIFT) - req->page_offset;\n\t*nbytesp = min(*nbytesp, nbytes);\n\treturn 0;\n}", "target": 0}
{"code": "sysServices_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  snmp_api_set_time_ticks(varbind, oid, clock_seconds() * 100);\n}", "target": 1}
{"code": "static void free_clt(struct rtrs_clt_sess *clt)\n{\n\tfree_permits(clt);\n\tfree_percpu(clt->pcpu_path);\n\tmutex_destroy(&clt->paths_ev_mutex);\n\tmutex_destroy(&clt->paths_mutex);\n\tdevice_unregister(&clt->dev);\n}", "target": 1}
{"code": "void SavePackage::ContinueGetSaveInfo(const FilePath& suggested_path,\n                                      bool can_save_as_complete) {\n  if (!web_contents() || !download_manager_->GetDelegate())\n    return;\n  FilePath::StringType default_extension;\n  if (can_save_as_complete)\n    default_extension = kDefaultHtmlExtension;\n  download_manager_->GetDelegate()->ChooseSavePath(\n      web_contents(),\n      suggested_path,\n      default_extension,\n      can_save_as_complete,\n      base::Bind(&SavePackage::OnPathPicked, AsWeakPtr()));\n}", "target": 0}
{"code": "static inline int process_nested_data(UNSERIALIZE_PARAMETER, HashTable *ht, long elements, int objprops)\n{\n\twhile (elements-- > 0) {\n\t\tzval *key, *data, **old_data;\n\t\tALLOC_INIT_ZVAL(key);\n\t\tif (!php_var_unserialize(&key, p, max, NULL TSRMLS_CC)) {\n\t\t\tzval_dtor(key);\n\t\t\tFREE_ZVAL(key);\n\t\t\treturn 0;\n\t\t}\n\t\tif (Z_TYPE_P(key) != IS_LONG && Z_TYPE_P(key) != IS_STRING) {\n\t\t\tzval_dtor(key);\n\t\t\tFREE_ZVAL(key);\n\t\t\treturn 0;\n\t\t}\n\t\tALLOC_INIT_ZVAL(data);\n\t\tif (!php_var_unserialize(&data, p, max, var_hash TSRMLS_CC)) {\n\t\t\tzval_dtor(key);\n\t\t\tFREE_ZVAL(key);\n\t\t\tzval_dtor(data);\n\t\t\tFREE_ZVAL(data);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!objprops) {\n\t\t\tswitch (Z_TYPE_P(key)) {\n\t\t\tcase IS_LONG:\n\t\t\t\tif (zend_hash_index_find(ht, Z_LVAL_P(key), (void **)&old_data)==SUCCESS) {\n\t\t\t\t\tvar_push_dtor(var_hash, old_data);\n\t\t\t\t}\n\t\t\t\tzend_hash_index_update(ht, Z_LVAL_P(key), &data, sizeof(data), NULL);\n\t\t\t\tbreak;\n\t\t\tcase IS_STRING:\n\t\t\t\tif (zend_symtable_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) {\n\t\t\t\t\tvar_push_dtor(var_hash, old_data);\n\t\t\t\t}\n\t\t\t\tzend_symtable_update(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, &data, sizeof(data), NULL);\n\t\t\t\tbreak;\n\t\t\t}\n                } else {\n                        convert_to_string(key);\n                       if (zend_symtable_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) {\n                               var_push_dtor(var_hash, old_data);\n                       }\n                        zend_hash_update(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, &data,\n                                        sizeof data, NULL);\n                }\n\t\tif (elements && *(*p-1) != ';' && *(*p-1) != '}') {\n\t\t\t(*p)--;\n\t\t\treturn 0;\n\t\t}\n\t}", "target": 0}
{"code": "exif_data_load_data_thumbnail (ExifData *data, const unsigned char *d,\n\t\t\t       unsigned int ds, ExifLong o, ExifLong s)\n{\n\tif (o >= ds) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\", \"Bogus thumbnail offset (%u).\", o);\n\t\treturn;\n\t}\n\tif (s > ds - o) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\", \"Bogus thumbnail size (%u), max would be %u.\", s, ds-o);\n\t\treturn;\n\t}\n\tif (data->data) \n\t\texif_mem_free (data->priv->mem, data->data);\n\tif (!(data->data = exif_data_alloc (data, s))) {\n\t\tEXIF_LOG_NO_MEMORY (data->priv->log, \"ExifData\", s);\n\t\tdata->size = 0;\n\t\treturn;\n\t}\n\tdata->size = s;\n\tmemcpy (data->data, d + o, s);\n}", "target": 1}
{"code": "isdn_net_getphones(isdn_net_ioctl_phone *phone, char __user *phones)\n{\n\tisdn_net_dev *p = isdn_net_findif(phone->name);\n\tint inout = phone->outgoing & 1;\n\tint more = 0;\n\tint count = 0;\n\tisdn_net_phone *n;\n\tif (!p)\n\t\treturn -ENODEV;\n\tinout &= 1;\n\tfor (n = p->local->phone[inout]; n; n = n->next) {\n\t\tif (more) {\n\t\t\tput_user(' ', phones++);\n\t\t\tcount++;\n\t\t}\n\t\tif (copy_to_user(phones, n->num, strlen(n->num) + 1)) {\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tphones += strlen(n->num);\n\t\tcount += strlen(n->num);\n\t\tmore = 1;\n\t}\n\tput_user(0, phones);\n\tcount++;\n\treturn count;\n}", "target": 0}
{"code": "bgp_attr_get_as_size(netdissect_options *ndo,\n                     uint8_t bgpa_type, const u_char *pptr, int len)\n{\n    const u_char *tptr = pptr;\n    if (bgpa_type == BGPTYPE_AS4_PATH) {\n        return 4;\n    }\n    while (tptr < pptr + len) {\n        ND_TCHECK(tptr[0]);\n        if (tptr[0] < BGP_AS_SEG_TYPE_MIN || tptr[0] > BGP_AS_SEG_TYPE_MAX) {\n            goto trunc;\n        }\n        ND_TCHECK(tptr[1]);\n        tptr += 2 + tptr[1] * 2;\n    }\n    if (tptr == pptr + len) {\n        return 2;\n    }\ntrunc:\n   return 4;\n}", "target": 0}
{"code": "cdf_read_short_sector_chain(const cdf_header_t *h,\n    const cdf_sat_t *ssat, const cdf_stream_t *sst,\n    cdf_secid_t sid, size_t len, cdf_stream_t *scn)\n{\n\tsize_t ss = CDF_SHORT_SEC_SIZE(h), i, j;\n\tscn->sst_tab = NULL;\n\tscn->sst_len = cdf_count_chain(ssat, sid, CDF_SEC_SIZE(h));\n\tscn->sst_dirlen = len;\n\tscn->sst_ss = ss;\n\tif (scn->sst_len == (size_t)-1)\n\t\tgoto out;\n\tscn->sst_tab = calloc(scn->sst_len, ss);\n\tif (scn->sst_tab == NULL)\n\t\treturn cdf_zero_stream(scn);\n\tfor (j = i = 0; sid >= 0; i++, j++) {\n\t\tif (j >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Read short sector chain loop limit\"));\n\t\t\tgoto out;\n\t\t}\n\t\tif (i >= scn->sst_len) {\n\t\t\tDPRINTF((\"Out of bounds reading short sector chain \"\n\t\t\t    \"%\" SIZE_T_FORMAT \"u > %\" SIZE_T_FORMAT \"u\\n\",\n\t\t\t    i, scn->sst_len));\n\t\t\tgoto out;\n\t\t}\n\t\tif (cdf_read_short_sector(sst, scn->sst_tab, i * ss, ss, h,\n\t\t    sid) != (ssize_t)ss) {\n\t\t\tDPRINTF((\"Reading short sector chain %d\", sid));\n\t\t\tgoto out;\n\t\t}\n\t\tsid = CDF_TOLE4((uint32_t)ssat->sat_tab[sid]);\n\t}\n\treturn 0;\nout:\n\terrno = EFTYPE;\n\treturn cdf_zero_stream(scn);\n}", "target": 0}
{"code": "Tss2_RC_Decode(TSS2_RC rc)\n{\n    static __thread char buf[TSS2_ERR_LAYER_NAME_MAX + TSS2_ERR_LAYER_ERROR_STR_MAX + 1];\n    clearbuf(buf);\n    UINT8 layer = tss2_rc_layer_number_get(rc);\n    TSS2_RC_HANDLER handler = layer_handler[layer].handler;\n    const char *lname = layer_handler[layer].name;\n    if (lname[0]) {\n        catbuf(buf, \"%s:\", lname);\n    } else {\n        catbuf(buf, \"%u:\", layer);\n    }\n    handler = !handler ? unknown_layer_handler : handler;\n    UINT16 err_bits = tpm2_error_get(rc);\n    const char *e = err_bits ? handler(err_bits) : \"success\";\n    if (e) {\n        catbuf(buf, \"%s\", e);\n    } else {\n        catbuf(buf, \"0x%X\", err_bits);\n    }\n    return buf;\n}", "target": 1}
{"code": "int LibRaw::subtract_black()\n{\n\tCHECK_ORDER_LOW(LIBRAW_PROGRESS_RAW2_IMAGE);\n\ttry {\n    if(!is_phaseone_compressed() && (C.cblack[0] || C.cblack[1] || C.cblack[2] || C.cblack[3]))\n        {\n#define BAYERC(row,col,c) imgdata.image[((row) >> IO.shrink)*S.iwidth + ((col) >> IO.shrink)][c] \n            int cblk[4],i;\n            for(i=0;i<4;i++)\n                cblk[i] = C.cblack[i];\n            int size = S.iheight * S.iwidth;\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n#define MAX(a,b) ((a) > (b) ? (a) : (b))\n#define LIM(x,min,max) MAX(min,MIN(x,max))\n#define CLIP(x) LIM(x,0,65535)\n            for(i=0; i< size*4; i++)\n              {\n                int val = imgdata.image[0][i];\n                val -= cblk[i & 3];\n                imgdata.image[0][i] = CLIP(val);\n                if(C.data_maximum < val) C.data_maximum = val;\n              }\n#undef MIN\n#undef MAX\n#undef LIM\n#undef CLIP\n            C.maximum -= C.black;\n            ZERO(C.cblack);\n            C.black = 0;\n#undef BAYERC\n        }\n    else\n        {\n          int idx;\n          ushort *p = (ushort*)imgdata.image;\n          C.data_maximum = 0;\n          for(idx=0;idx<S.iheight*S.iwidth*4;idx++)\n            if(C.data_maximum < p[idx]) C.data_maximum = p[idx];\n        }\n\t\treturn 0;\n\t}\n\tcatch ( LibRaw_exceptions err) {\n\t\tEXCEPTION_HANDLER(err);\n\t}\n}", "target": 1}
{"code": "static void handleOutputMode(void* data, struct wl_output* wl_output, uint32_t flags, int32_t width, int32_t height, int32_t refresh) {\n    const auto POUTPUT = (SOutput*)data;\n    POUTPUT->refreshRate = std::round(refresh / 1000.0);\n}", "target": 1}
{"code": "Map1toN(SDL_PixelFormat * src, Uint8 Rmod, Uint8 Gmod, Uint8 Bmod, Uint8 Amod,\n        SDL_PixelFormat * dst)\n{\n    Uint8 *map;\n    int i;\n    int bpp;\n    SDL_Palette *pal = src->palette;\n    bpp = ((dst->BytesPerPixel == 3) ? 4 : dst->BytesPerPixel);\n    map = (Uint8 *) SDL_malloc(pal->ncolors * bpp);\n    if (map == NULL) {\n        SDL_OutOfMemory();\n        return (NULL);\n    }\n    for (i = 0; i < pal->ncolors; ++i) {\n        Uint8 R = (Uint8) ((pal->colors[i].r * Rmod) / 255);\n        Uint8 G = (Uint8) ((pal->colors[i].g * Gmod) / 255);\n        Uint8 B = (Uint8) ((pal->colors[i].b * Bmod) / 255);\n        Uint8 A = (Uint8) ((pal->colors[i].a * Amod) / 255);\n        ASSEMBLE_RGBA(&map[i * bpp], dst->BytesPerPixel, dst, (Uint32)R, (Uint32)G, (Uint32)B, (Uint32)A);\n    }\n    return (map);\n}", "target": 1}
{"code": "static int keyring_detect_cycle_iterator(const void *object,\n\t\t\t\t\t void *iterator_data)\n{\n\tstruct keyring_search_context *ctx = iterator_data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\tkenter(\"{%d}\", key->serial);\n\tBUG_ON(key != ctx->match_data);\n\tctx->result = ERR_PTR(-EDEADLK);\n\treturn 1;\n}", "target": 1}
{"code": "cib_remote_dispatch(gpointer user_data)\n{\n    cib_t *cib = user_data;\n    cib_remote_opaque_t *private = cib->variant_opaque;\n    xmlNode *msg = NULL;\n    const char *type = NULL;\n    crm_info(\"Message on callback channel\");\n    msg = crm_recv_remote_msg(private->callback.session, private->callback.encrypted);\n    type = crm_element_value(msg, F_TYPE);\n    crm_trace(\"Activating %s callbacks...\", type);\n    if (safe_str_eq(type, T_CIB)) {\n        cib_native_callback(cib, msg, 0, 0);\n    } else if (safe_str_eq(type, T_CIB_NOTIFY)) {\n        g_list_foreach(cib->notify_list, cib_native_notify, msg);\n    } else {\n        crm_err(\"Unknown message type: %s\", type);\n    }\n    if (msg != NULL) {\n        free_xml(msg);\n        return 0;\n    }\n    return -1;\n}", "target": 1}
{"code": "_asn1_set_value (asn1_node node, const void *value, unsigned int len)\n{\n  if (node == NULL)\n    return node;\n  if (node->value)\n    {\n      if (node->value != node->small_value)\n\tfree (node->value);\n      node->value = NULL;\n      node->value_len = 0;\n    }\n  if (!len)\n    return node;\n  if (len < sizeof (node->small_value))\n    {\n      node->value = node->small_value;\n    }\n  else\n    {\n      node->value = malloc (len);\n      if (node->value == NULL)\n\treturn NULL;\n    }\n  node->value_len = len;\n  memcpy (node->value, value, len);\n  return node;\n}", "target": 0}
{"code": "int register_power_pmu(struct power_pmu *pmu)\n{\n\tif (ppmu)\n\t\treturn -EBUSY;\t\t\n\tppmu = pmu;\n\tpr_info(\"%s performance monitor hardware support registered\\n\",\n\t\tpmu->name);\n#ifdef MSR_HV\n\tif (mfmsr() & MSR_HV)\n\t\tfreeze_events_kernel = MMCR0_FCHV;\n#endif \n\tperf_pmu_register(&power_pmu, \"cpu\", PERF_TYPE_RAW);\n\tperf_cpu_notifier(power_pmu_notifier);\n\treturn 0;\n}", "target": 0}
{"code": "OE_INLINE void _handle_oret(\n    oe_sgx_td_t* td,\n    uint16_t func,\n    uint16_t result,\n    uint64_t arg)\n{\n    oe_callsite_t* callsite = td->callsites;\n    if (!callsite)\n        return;\n    td->oret_func = func;\n    td->oret_result = result;\n    td->oret_arg = arg;\n    asm volatile(\"pushq %[rflags] \\n\\t\" \n                 \"popfq \\n\\t\"\n                 \"fldcw %[fcw] \\n\\t\"     \n                 \"ldmxcsr %[mxcsr] \\n\\t\" \n                 : [mxcsr] \"=m\"(callsite->mxcsr),\n                   [fcw] \"=m\"(callsite->fcw),\n                   [rflags] \"=m\"(callsite->rflags)\n                 :\n                 : \"cc\");\n    oe_longjmp(&callsite->jmpbuf, 1);\n}", "target": 1}
{"code": "static struct key *request_master_key(struct encrypted_key_payload *epayload,\n\t\t\t\t      const u8 **master_key, size_t *master_keylen)\n{\n\tstruct key *mkey = ERR_PTR(-EINVAL);\n\tif (!strncmp(epayload->master_desc, KEY_TRUSTED_PREFIX,\n\t\t     KEY_TRUSTED_PREFIX_LEN)) {\n\t\tmkey = request_trusted_key(epayload->master_desc +\n\t\t\t\t\t   KEY_TRUSTED_PREFIX_LEN,\n\t\t\t\t\t   master_key, master_keylen);\n\t} else if (!strncmp(epayload->master_desc, KEY_USER_PREFIX,\n\t\t\t    KEY_USER_PREFIX_LEN)) {\n\t\tmkey = request_user_key(epayload->master_desc +\n\t\t\t\t\tKEY_USER_PREFIX_LEN,\n\t\t\t\t\tmaster_key, master_keylen);\n\t} else\n\t\tgoto out;\n\tif (IS_ERR(mkey)) {\n\t\tint ret = PTR_ERR(mkey);\n\t\tif (ret == -ENOTSUPP)\n\t\t\tpr_info(\"encrypted_key: key %s not supported\",\n\t\t\t\tepayload->master_desc);\n\t\telse\n\t\t\tpr_info(\"encrypted_key: key %s not found\",\n\t\t\t\tepayload->master_desc);\n\t\tgoto out;\n\t}\n\tdump_master_key(*master_key, *master_keylen);\nout:\n\treturn mkey;\n}", "target": 0}
{"code": "        bool         CheckRegion(int nPos, int nSize)\n        {\n            return (nPos >= 0 && nPos + nSize >= nPos && nPos + nSize <= m_nLen);\n        }", "target": 1}
{"code": "pf_remove_divert_state(struct pf_state_key *sk)\n{\n\tstruct pf_state_item\t*si;\n\tPF_ASSERT_UNLOCKED();\n\tPF_LOCK();\n\tPF_STATE_ENTER_WRITE();\n\tTAILQ_FOREACH(si, &sk->sk_states, si_entry) {\n\t\tstruct pf_state *sist = si->si_st;\n\t\tif (sk == sist->key[PF_SK_STACK] && sist->rule.ptr &&\n\t\t    (sist->rule.ptr->divert.type == PF_DIVERT_TO ||\n\t\t     sist->rule.ptr->divert.type == PF_DIVERT_REPLY)) {\n\t\t\tif (sist->key[PF_SK_STACK]->proto == IPPROTO_TCP &&\n\t\t\t    sist->key[PF_SK_WIRE] != sist->key[PF_SK_STACK]) {\n\t\t\t\tif (sist->src.state < TCPS_FIN_WAIT_2 ||\n\t\t\t\t    sist->dst.state < TCPS_FIN_WAIT_2) {\n\t\t\t\t\tpf_set_protostate(sist, PF_PEER_BOTH,\n\t\t\t\t\t    TCPS_TIME_WAIT);\n\t\t\t\t\tsist->timeout = PFTM_TCP_CLOSED;\n\t\t\t\t\tsist->expire = getuptime();\n\t\t\t\t}\n\t\t\t\tsist->state_flags |= PFSTATE_INP_UNLINKED;\n\t\t\t} else\n\t\t\t\tpf_remove_state(sist);\n\t\t\tbreak;\n\t\t}\n\t}\n\tPF_STATE_EXIT_WRITE();\n\tPF_UNLOCK();\n}", "target": 1}
{"code": "static int string_check(char *buf, const char *buf2)\n{\n  if(strcmp(buf, buf2)) {\n    printf(\"sprintf failed:\\nwe '%s'\\nsystem: '%s'\\n\",\n           buf, buf2);\n    return 1;\n  }\n  return 0;\n}", "target": 1}
{"code": "u32 cdk_pk_get_keyid(cdk_pubkey_t pk, u32 * keyid)\n{\n\tu32 lowbits = 0;\n\tbyte buf[24];\n\tif (pk && (!pk->keyid[0] || !pk->keyid[1])) {\n\t\tif (pk->version < 4 && is_RSA(pk->pubkey_algo)) {\n\t\t\tbyte p[MAX_MPI_BYTES];\n\t\t\tsize_t n;\n\t\t\tn = MAX_MPI_BYTES;\n\t\t\t_gnutls_mpi_print(pk->mpi[0], p, &n);\n\t\t\tpk->keyid[0] =\n\t\t\t    p[n - 8] << 24 | p[n - 7] << 16 | p[n -\n\t\t\t\t\t\t\t\t6] << 8 |\n\t\t\t    p[n - 5];\n\t\t\tpk->keyid[1] =\n\t\t\t    p[n - 4] << 24 | p[n - 3] << 16 | p[n -\n\t\t\t\t\t\t\t\t2] << 8 |\n\t\t\t    p[n - 1];\n\t\t} else if (pk->version == 4) {\n\t\t\tcdk_pk_get_fingerprint(pk, buf);\n\t\t\tpk->keyid[0] = _cdk_buftou32(buf + 12);\n\t\t\tpk->keyid[1] = _cdk_buftou32(buf + 16);\n\t\t}\n\t}\n\tlowbits = pk ? pk->keyid[1] : 0;\n\tif (keyid && pk) {\n\t\tkeyid[0] = pk->keyid[0];\n\t\tkeyid[1] = pk->keyid[1];\n\t}\n\treturn lowbits;\n}", "target": 1}
{"code": "rfbMpiToBytes(const gcry_mpi_t value, uint8_t *result, size_t size)\n{\n  gcry_error_t error;\n  size_t len;\n  int i;\n  error = gcry_mpi_print(GCRYMPI_FMT_USG, result, size, &len, value);\n  if (gcry_err_code(error) != GPG_ERR_NO_ERROR)\n  {\n    rfbClientLog(\"gcry_mpi_print error: %s\\n\", gcry_strerror(error));\n    return FALSE;\n  }\n  for (i=size-1;i>(int)size-1-(int)len;--i)\n    result[i] = result[i-size+len];\n  for (;i>=0;--i)\n    result[i] = 0;\n  return TRUE;\n}", "target": 0}
{"code": "static inline void get_page(struct page *page)\n{\n\tpage = compound_head(page);\n\tVM_BUG_ON_PAGE(page_ref_count(page) <= 0, page);\n\tpage_ref_inc(page);\n}", "target": 1}
{"code": "njs_string_decode_base64_core(njs_vm_t *vm, njs_value_t *value,\n    const njs_str_t *src, njs_bool_t url)\n{\n    size_t     length;\n    const u_char *basis;\n    njs_str_t  dst;\n    basis = (url) ? njs_basis64url : njs_basis64;\n    length = njs_decode_base64_length_core(src, basis, &dst.length);\n    if (njs_slow_path(dst.length == 0)) {\n        vm->retval = njs_string_empty;\n        return NJS_OK;\n    }\n    dst.start = njs_string_alloc(vm, value, dst.length, length);\n    if (njs_slow_path(dst.start == NULL)) {\n        return NJS_ERROR;\n    }\n    njs_decode_base64_core(&dst, src, basis);\n    return NJS_OK;\n}", "target": 0}
{"code": "read_pbm_integer(j_compress_ptr cinfo, FILE *infile, unsigned int maxval)\n{\n  register int ch;\n  register unsigned int val;\n  do {\n    ch = pbm_getc(infile);\n    if (ch == EOF)\n      ERREXIT(cinfo, JERR_INPUT_EOF);\n  } while (ch == ' ' || ch == '\\t' || ch == '\\n' || ch == '\\r');\n  if (ch < '0' || ch > '9')\n    ERREXIT(cinfo, JERR_PPM_NONNUMERIC);\n  val = ch - '0';\n  while ((ch = pbm_getc(infile)) >= '0' && ch <= '9') {\n    val *= 10;\n    val += ch - '0';\n  }\n  if (val > maxval)\n    ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n  return val;\n}", "target": 1}
{"code": "static int plug_ctx_cmp(void *priv, struct list_head *a, struct list_head *b)\n{\n\tstruct request *rqa = container_of(a, struct request, queuelist);\n\tstruct request *rqb = container_of(b, struct request, queuelist);\n\treturn !(rqa->mq_ctx < rqb->mq_ctx ||\n\t\t (rqa->mq_ctx == rqb->mq_ctx &&\n\t\t  blk_rq_pos(rqa) < blk_rq_pos(rqb)));\n}", "target": 0}
{"code": "int udp_sendpage(struct sock *sk, struct page *page, int offset,\n\t\t size_t size, int flags)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct udp_sock *up = udp_sk(sk);\n\tint ret;\n\tif (flags & MSG_SENDPAGE_NOTLAST)\n\t\tflags |= MSG_MORE;\n\tif (!up->pending) {\n\t\tstruct msghdr msg = {\t.msg_flags = flags|MSG_MORE };\n\t\tret = udp_sendmsg(sk, &msg, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tlock_sock(sk);\n\tif (unlikely(!up->pending)) {\n\t\trelease_sock(sk);\n\t\tnet_dbg_ratelimited(\"udp cork app bug 3\\n\");\n\t\treturn -EINVAL;\n\t}\n\tret = ip_append_page(sk, &inet->cork.fl.u.ip4,\n\t\t\t     page, offset, size, flags);\n\tif (ret == -EOPNOTSUPP) {\n\t\trelease_sock(sk);\n\t\treturn sock_no_sendpage(sk->sk_socket, page, offset,\n\t\t\t\t\tsize, flags);\n\t}\n\tif (ret < 0) {\n\t\tudp_flush_pending_frames(sk);\n\t\tgoto out;\n\t}\n\tup->len += size;\n\tif (!(up->corkflag || (flags&MSG_MORE)))\n\t\tret = udp_push_pending_frames(sk);\n\tif (!ret)\n\t\tret = size;\nout:\n\trelease_sock(sk);\n\treturn ret;\n}", "target": 0}
{"code": "int nft_expr_inner_parse(const struct nft_ctx *ctx, const struct nlattr *nla,\n\t\t\t struct nft_expr_info *info)\n{\n\tstruct nlattr *tb[NFTA_EXPR_MAX + 1];\n\tconst struct nft_expr_type *type;\n\tint err;\n\terr = nla_parse_nested_deprecated(tb, NFTA_EXPR_MAX, nla,\n\t\t\t\t\t  nft_expr_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\tif (!tb[NFTA_EXPR_DATA])\n\t\treturn -EINVAL;\n\ttype = __nft_expr_type_get(ctx->family, tb[NFTA_EXPR_NAME]);\n\tif (!type)\n\t\treturn -ENOENT;\n\tif (!type->inner_ops)\n\t\treturn -EOPNOTSUPP;\n\terr = nla_parse_nested_deprecated(info->tb, type->maxattr,\n\t\t\t\t\t  tb[NFTA_EXPR_DATA],\n\t\t\t\t\t  type->policy, NULL);\n\tif (err < 0)\n\t\tgoto err_nla_parse;\n\tinfo->attr = nla;\n\tinfo->ops = type->inner_ops;\n\treturn 0;\nerr_nla_parse:\n\treturn err;\n}", "target": 1}
{"code": "int mbedtls_x509_crt_parse_der( mbedtls_x509_crt *chain, const unsigned char *buf,\n                        size_t buflen )\n{\n    int ret;\n    mbedtls_x509_crt *crt = chain, *prev = NULL;\n    if( crt == NULL || buf == NULL )\n        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );\n    while( crt->version != 0 && crt->next != NULL )\n    {\n        prev = crt;\n        crt = crt->next;\n    }\n    if( crt->version != 0 && crt->next == NULL )\n    {\n        crt->next = mbedtls_calloc( 1, sizeof( mbedtls_x509_crt ) );\n        if( crt->next == NULL )\n            return( MBEDTLS_ERR_X509_ALLOC_FAILED );\n        prev = crt;\n        mbedtls_x509_crt_init( crt->next );\n        crt = crt->next;\n    }\n    if( ( ret = x509_crt_parse_der_core( crt, buf, buflen ) ) != 0 )\n    {\n        if( prev )\n            prev->next = NULL;\n        if( crt != chain )\n            mbedtls_free( crt );\n        return( ret );\n    }\n    return( 0 );\n}", "target": 0}
{"code": "mark_trusted_task_done (GObject      *source_object,\n                        GAsyncResult *res,\n                        gpointer      user_data)\n{\n    MarkTrustedJob *job = user_data;\n    g_object_unref (job->file);\n    if (job->done_callback)\n    {\n        job->done_callback (!job_aborted ((CommonJob *) job),\n                            job->done_callback_data);\n    }\n    finalize_common ((CommonJob *) job);\n}", "target": 1}
{"code": "static Status ValidateStrides(const T& strides) {\n  for (size_t i = 0; i < strides.size(); ++i) {\n    if (strides[i] <= 0) {\n      return errors::InvalidArgument(\n          \"Sliding window stride field for dimension \", i,\n          \" must be positive but is \", strides[i]);\n    }\n  }\n  return OkStatus();\n}", "target": 0}
{"code": "int ossl_dsa_check_pairwise(const DSA *dsa)\n{\n    int ret = 0;\n    BN_CTX *ctx = NULL;\n    BIGNUM *pub_key = NULL;\n    if (dsa->params.p == NULL\n        || dsa->params.g == NULL\n        || dsa->priv_key == NULL\n        || dsa->pub_key == NULL)\n        return 0;\n    ctx = BN_CTX_new_ex(dsa->libctx);\n    if (ctx == NULL)\n        goto err;\n    pub_key = BN_new();\n    if (pub_key == NULL)\n        goto err;\n    if (!ossl_dsa_generate_public_key(ctx, dsa, dsa->priv_key, pub_key))\n        goto err;\n    ret = BN_cmp(pub_key, dsa->pub_key) == 0;\nerr:\n    BN_free(pub_key);\n    BN_CTX_free(ctx);\n    return ret;\n}", "target": 1}
{"code": "aubio_filterbank_do (aubio_filterbank_t * f, const cvec_t * in, fvec_t * out)\n{\n  fvec_t tmp;\n  tmp.length = in->length;\n  tmp.data = in->norm;\n  if (f->power != 1.) fvec_pow(&tmp, f->power);\n  fmat_vecmul(f->filters, &tmp, out);\n  return;\n}", "target": 0}
{"code": "xmlParseElementEnd(xmlParserCtxtPtr ctxt) {\n    xmlParserNodeInfo node_info;\n    xmlNodePtr ret = ctxt->node;\n    if (ctxt->nameNr <= 0)\n        return;\n    if (ctxt->sax2) {\n        const xmlChar *prefix = ctxt->pushTab[ctxt->nameNr * 3 - 3];\n        const xmlChar *URI = ctxt->pushTab[ctxt->nameNr * 3 - 2];\n        int nsNr = (ptrdiff_t) ctxt->pushTab[ctxt->nameNr * 3 - 1];\n\txmlParseEndTag2(ctxt, prefix, URI, 0, nsNr, 0);\n\tnamePop(ctxt);\n    }\n#ifdef LIBXML_SAX1_ENABLED\n    else\n\txmlParseEndTag1(ctxt, 0);\n#endif \n    if ( ret != NULL && ctxt->record_info ) {\n       node_info.end_pos = ctxt->input->consumed +\n                          (CUR_PTR - ctxt->input->base);\n       node_info.end_line = ctxt->input->line;\n       node_info.node = ret;\n       xmlParserAddNodeInfo(ctxt, &node_info);\n    }\n}", "target": 0}
{"code": "void diff_change(struct diff_options *options,\n\t\t unsigned old_mode, unsigned new_mode,\n\t\t const unsigned char *old_sha1,\n\t\t const unsigned char *new_sha1,\n\t\t const char *base, const char *path)\n{\n\tchar concatpath[PATH_MAX];\n\tstruct diff_filespec *one, *two;\n\tif (DIFF_OPT_TST(options, IGNORE_SUBMODULES) && S_ISGITLINK(old_mode)\n\t\t\t&& S_ISGITLINK(new_mode))\n\t\treturn;\n\tif (DIFF_OPT_TST(options, REVERSE_DIFF)) {\n\t\tunsigned tmp;\n\t\tconst unsigned char *tmp_c;\n\t\ttmp = old_mode; old_mode = new_mode; new_mode = tmp;\n\t\ttmp_c = old_sha1; old_sha1 = new_sha1; new_sha1 = tmp_c;\n\t}\n\tif (!path) path = \"\";\n\tsprintf(concatpath, \"%s%s\", base, path);\n\tif (options->prefix &&\n\t    strncmp(concatpath, options->prefix, options->prefix_length))\n\t\treturn;\n\tone = alloc_filespec(concatpath);\n\ttwo = alloc_filespec(concatpath);\n\tfill_filespec(one, old_sha1, old_mode);\n\tfill_filespec(two, new_sha1, new_mode);\n\tdiff_queue(&diff_queued_diff, one, two);\n\tDIFF_OPT_SET(options, HAS_CHANGES);\n}", "target": 1}
{"code": "TEE_Result crypto_acipher_alloc_dsa_keypair(struct dsa_keypair *s,\n\t\t\t\t\t    size_t key_size_bits __unused)\n{\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->g))\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tif (!bn_alloc_max(&s->p))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->q))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->y))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->x))\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(s->g);\n\tcrypto_bignum_free(s->p);\n\tcrypto_bignum_free(s->q);\n\tcrypto_bignum_free(s->y);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "void set_cron_watched(int fd) {\n\tpid_t pid = getpid();\n\tint i;\n\tif (fd < 0) {\n\t\tinotify_enabled = 0;\n\t\treturn;\n\t}\n\tfor (i = 0; i < sizeof (wd) / sizeof (wd[0]); ++i) {\n\t\tint w;\n\t\tif (open(watchpaths[i], O_RDONLY | O_NONBLOCK, 0) != -1) {\n\t\t\tw = inotify_add_watch(fd, watchpaths[i],\n\t\t\t\tIN_CREATE | IN_CLOSE_WRITE | IN_ATTRIB | IN_MODIFY | IN_MOVED_TO |\n\t\t\t\tIN_MOVED_FROM | IN_MOVE_SELF | IN_DELETE | IN_DELETE_SELF);\n\t\t\tif (w < 0) {\n\t\t\t\tif (wd[i] != -1) {\n\t\t\t\t\tlog_it(\"CRON\", pid, \"This directory or file can't be watched\",\n\t\t\t\t\t\twatchpaths[i], errno);\n\t\t\t\t\tlog_it(\"CRON\", pid, \"INFO\", \"running without inotify support\", 0);\n\t\t\t\t}\n\t\t\t\tinotify_enabled = 0;\n\t\t\t\tset_cron_unwatched(fd);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\twd[i] = w;\n\t\t}\n\t}\n\tif (!inotify_enabled) {\n\t\tlog_it(\"CRON\", pid, \"INFO\", \"running with inotify support\", 0);\n\t}\n\tinotify_enabled = 1;\n}", "target": 1}
{"code": "\tFOR_EACH_MODULE_Type(CIRCNetwork* pNetwork) : CMuser(pNetwork ? pNetwork->GetUser()->GetModules() : CMtemp), CMnet(pNetwork ? pNetwork->GetModules() : CMtemp) {\n\t\twhere = AtGlobal;\n\t}", "target": 0}
{"code": "  String_Schema_Obj Parser::parse_css_variable_value(bool top_level)\n  {\n    String_Schema_Obj schema = SASS_MEMORY_NEW(String_Schema, pstate);\n    String_Schema_Obj tok;\n    if (!(tok = parse_css_variable_value_token(top_level))) {\n      return {};\n    }\n    schema->concat(tok);\n    while ((tok = parse_css_variable_value_token(top_level))) {\n      schema->concat(tok);\n    }\n    return schema.detach();\n  }", "target": 1}
{"code": "ieee80211_tx_h_dynamic_ps(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_local *local = tx->local;\n\tstruct ieee80211_if_managed *ifmgd;\n\tif (!(local->hw.flags & IEEE80211_HW_SUPPORTS_PS))\n\t\treturn TX_CONTINUE;\n\tif (local->hw.flags & IEEE80211_HW_SUPPORTS_DYNAMIC_PS)\n\t\treturn TX_CONTINUE;\n\tif (local->hw.conf.dynamic_ps_timeout <= 0)\n\t\treturn TX_CONTINUE;\n\tif (local->scanning)\n\t\treturn TX_CONTINUE;\n\tif (!local->ps_sdata)\n\t\treturn TX_CONTINUE;\n\tif (local->quiescing)\n\t\treturn TX_CONTINUE;\n\tif (tx->sdata->vif.type != NL80211_IFTYPE_STATION)\n\t\treturn TX_CONTINUE;\n\tifmgd = &tx->sdata->u.mgd;\n\tif ((ifmgd->flags & IEEE80211_STA_UAPSD_ENABLED) &&\n\t    (ifmgd->uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_VO) &&\n\t    skb_get_queue_mapping(tx->skb) == IEEE80211_AC_VO)\n\t\treturn TX_CONTINUE;\n\tif (local->hw.conf.flags & IEEE80211_CONF_PS) {\n\t\tieee80211_stop_queues_by_reason(&local->hw,\n\t\t\t\t\t\tIEEE80211_MAX_QUEUE_MAP,\n\t\t\t\t\t\tIEEE80211_QUEUE_STOP_REASON_PS);\n\t\tifmgd->flags &= ~IEEE80211_STA_NULLFUNC_ACKED;\n\t\tieee80211_queue_work(&local->hw,\n\t\t\t\t     &local->dynamic_ps_disable_work);\n\t}\n\tif (!ifmgd->associated)\n\t\treturn TX_CONTINUE;\n\tmod_timer(&local->dynamic_ps_timer, jiffies +\n\t\t  msecs_to_jiffies(local->hw.conf.dynamic_ps_timeout));\n\treturn TX_CONTINUE;\n}", "target": 0}
{"code": "void gnrc_sixlowpan_iphc_send(gnrc_pktsnip_t *pkt, void *ctx, unsigned page)\n{\n    gnrc_netif_hdr_t *netif_hdr = pkt->data;\n    gnrc_netif_t *netif = gnrc_netif_hdr_get_netif(netif_hdr);\n    gnrc_pktsnip_t *tmp;\n    size_t orig_datagram_size = gnrc_pkt_len(pkt->next);\n    ipv6_hdr_t *ipv6_hdr = pkt->next->data;\n    ipv6_addr_t dst;\n    if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD)) {\n        dst = ipv6_hdr->dst;    \n    }\n    if ((tmp = _iphc_encode(pkt, pkt->data, netif))) {\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD) && (ctx != NULL) &&\n            (gnrc_sixlowpan_frag_minfwd_frag_iphc(tmp, orig_datagram_size, &dst,\n                                                  ctx) == 0)) {\n            DEBUG(\"6lo iphc minfwd: putting slack in first fragment\\n\");\n            return;\n        }\n        gnrc_sixlowpan_multiplex_by_size(tmp, orig_datagram_size, netif, page);\n    }\n    else {\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD)) {\n            gnrc_sixlowpan_frag_fb_t *fb = ctx;\n            if (fb->pkt == pkt) {\n                fb->pkt = NULL;\n            }\n        }\n        gnrc_pktbuf_release(pkt);\n    }\n}", "target": 0}
{"code": "void jiffies_to_timeval(const unsigned long jiffies, struct timeval *value)\n{\n\tu64 nsec = (u64)jiffies * TICK_NSEC;\n\tlong tv_usec;\n\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &tv_usec);\n\ttv_usec /= NSEC_PER_USEC;\n\tvalue->tv_usec = tv_usec;\n}", "target": 1}
{"code": "int xt_compat_check_entry_offsets(const void *base,\n\t\t\t\t  unsigned int target_offset,\n\t\t\t\t  unsigned int next_offset)\n{\n\tconst struct compat_xt_entry_target *t;\n\tconst char *e = base;\n\tif (target_offset + sizeof(*t) > next_offset)\n\t\treturn -EINVAL;\n\tt = (void *)(e + target_offset);\n\tif (t->u.target_size < sizeof(*t))\n\t\treturn -EINVAL;\n\tif (target_offset + t->u.target_size > next_offset)\n\t\treturn -EINVAL;\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) == 0 &&\n\t    target_offset + sizeof(struct compat_xt_standard_target) != next_offset)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 1}
{"code": "void QuotaManagerProxy::NotifyOriginNoLongerInUse(\n    const GURL& origin) {\n  if (!io_thread_->BelongsToCurrentThread()) {\n    io_thread_->PostTask(FROM_HERE, NewRunnableMethod(\n        this, &QuotaManagerProxy::NotifyOriginNoLongerInUse, origin));\n    return;\n  }\n  if (manager_)\n    manager_->NotifyOriginNoLongerInUse(origin);\n}", "target": 0}
{"code": "GBool Splash::pathAllOutside(SplashPath *path) {\n  SplashCoord xMin1, yMin1, xMax1, yMax1;\n  SplashCoord xMin2, yMin2, xMax2, yMax2;\n  SplashCoord x, y;\n  int xMinI, yMinI, xMaxI, yMaxI;\n  int i;\n  xMin1 = xMax1 = path->pts[0].x;\n  yMin1 = yMax1 = path->pts[0].y;\n  for (i = 1; i < path->length; ++i) {\n    if (path->pts[i].x < xMin1) {\n      xMin1 = path->pts[i].x;\n    } else if (path->pts[i].x > xMax1) {\n      xMax1 = path->pts[i].x;\n    }\n    if (path->pts[i].y < yMin1) {\n      yMin1 = path->pts[i].y;\n    } else if (path->pts[i].y > yMax1) {\n      yMax1 = path->pts[i].y;\n    }\n  }\n  transform(state->matrix, xMin1, yMin1, &x, &y);\n  xMin2 = xMax2 = x;\n  yMin2 = yMax2 = y;\n  transform(state->matrix, xMin1, yMax1, &x, &y);\n  if (x < xMin2) {\n    xMin2 = x;\n  } else if (x > xMax2) {\n    xMax2 = x;\n  }\n  if (y < yMin2) {\n    yMin2 = y;\n  } else if (y > yMax2) {\n    yMax2 = y;\n  }\n  transform(state->matrix, xMax1, yMin1, &x, &y);\n  if (x < xMin2) {\n    xMin2 = x;\n  } else if (x > xMax2) {\n    xMax2 = x;\n  }\n  if (y < yMin2) {\n    yMin2 = y;\n  } else if (y > yMax2) {\n    yMax2 = y;\n  }\n  transform(state->matrix, xMax1, yMax1, &x, &y);\n  if (x < xMin2) {\n    xMin2 = x;\n  } else if (x > xMax2) {\n    xMax2 = x;\n  }\n  if (y < yMin2) {\n    yMin2 = y;\n  } else if (y > yMax2) {\n    yMax2 = y;\n  }\n  xMinI = splashFloor(xMin2);\n  yMinI = splashFloor(yMin2);\n  xMaxI = splashFloor(xMax2);\n  yMaxI = splashFloor(yMax2);\n  return state->clip->testRect(xMinI, yMinI, xMaxI, yMaxI) ==\n         splashClipAllOutside;\n}", "target": 0}
{"code": "static UINT ExtractRunLengthRegularFgBg(const BYTE* pbOrderHdr, const BYTE* pbEnd, UINT32* advance)\n{\n\tUINT runLength = 0;\n\tWINPR_ASSERT(pbOrderHdr);\n\tWINPR_ASSERT(pbEnd);\n\tWINPR_ASSERT(advance);\n\trunLength = (*pbOrderHdr) & g_MaskRegularRunLength;\n\tif (runLength == 0)\n\t{\n\t\tif (!buffer_within_range(pbOrderHdr, 1, pbEnd))\n\t\t{\n\t\t\t*advance = 0;\n\t\t\treturn 0;\n\t\t}\n\t\trunLength = *(pbOrderHdr + 1) + 1;\n\t\t(*advance)++;\n\t}\n\telse\n\t\trunLength = runLength * 8;\n\treturn runLength;\n}", "target": 1}
{"code": "int rtnl_send_check(struct rtnl_handle *rth, const void *buf, int len)\n{\n\tstruct nlmsghdr *h;\n\tint status;\n\tchar resp[1024];\n\tstatus = send(rth->fd, buf, len, 0);\n\tif (status < 0)\n\t\treturn status;\n\tstatus = recv(rth->fd, resp, sizeof(resp), MSG_DONTWAIT|MSG_PEEK);\n\tif (status < 0) {\n\t\tif (errno == EAGAIN)\n\t\t\treturn 0;\n\t\treturn -1;\n\t}\n\tfor (h = (struct nlmsghdr *)resp; NLMSG_OK(h, status);\n\t     h = NLMSG_NEXT(h, status)) {\n\t\tif (h->nlmsg_type == NLMSG_ERROR) {\n\t\t\tstruct nlmsgerr *err = (struct nlmsgerr *)NLMSG_DATA(h);\n\t\t\tif (h->nlmsg_len < NLMSG_LENGTH(sizeof(struct nlmsgerr)))\n\t\t\t\tfprintf(stderr, \"ERROR truncated\\n\");\n\t\t\telse\n\t\t\t\terrno = -err->error;\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "extract_one_file(EpubDocument* epub_document,GError ** error)\n{\n    GFile * outfile ;\n    gsize writesize = 0;\n    GString * gfilepath ;\n    unz_file_info64 info ;\n    gchar* directory;\n    GString* dir_create;\n    GFileOutputStream * outstream ;\n    if ( unzOpenCurrentFile(epub_document->epubDocument) != UNZ_OK )\n    {\n            return FALSE ;\n    }\n    gboolean result = TRUE;\n    gpointer currentfilename = g_malloc0(512);\n    unzGetCurrentFileInfo64(epub_document->epubDocument,&info,currentfilename,512,NULL,0,NULL,0) ;\n    directory = g_strrstr(currentfilename,\"/\") ;\n    if ( directory != NULL )\n        directory++;\n    gfilepath = g_string_new(epub_document->tmp_archive_dir) ;\n    g_string_append_printf(gfilepath,\"/%s\",(gchar*)currentfilename);\n    if (directory != NULL && *directory == '\\0')\n    {\n        g_mkdir(gfilepath->str,0777);\n        goto out;\n    }\n    else if (directory != NULL && *directory != '\\0' ) {\n        gchar* createdir = currentfilename;\n        gchar *createdirname = g_malloc0(strlen(currentfilename));\n        gchar *createdirnametemp = createdirname;\n        while ( createdir != directory ) {\n            (*createdirnametemp) = (*createdir);\n            createdirnametemp++;\n            createdir++;\n        }\n        (*createdirnametemp) = '\\0';\n        dir_create = g_string_new(epub_document->tmp_archive_dir);\n        g_string_append_printf(dir_create,\"/%s\",createdirname);\n        g_free(createdirname);\n        g_mkdir_with_parents(dir_create->str,0777);\n        g_string_free(dir_create,TRUE);\n    }\n    outfile = g_file_new_for_path(gfilepath->str);\n    outstream = g_file_create(outfile,G_FILE_CREATE_PRIVATE,NULL,error);\n    gpointer buffer = g_malloc0(512);\n    while ( (writesize = unzReadCurrentFile(epub_document->epubDocument,buffer,512) ) != 0 )\n    {\n        if ( g_output_stream_write((GOutputStream*)outstream,buffer,writesize,NULL,error) == -1 )\n        {\n            result = FALSE;\n            break;\n        }\n    }\n    g_free(buffer);\n    g_output_stream_close((GOutputStream*)outstream,NULL,error);\n    g_object_unref(outfile) ;\n    g_object_unref(outstream) ;\nout:\n    unzCloseCurrentFile (epub_document->epubDocument) ;\n    g_string_free(gfilepath,TRUE);\n    g_free(currentfilename);\n    return result;\n}", "target": 1}
{"code": "cdf_check_stream_offset(const cdf_stream_t *sst, const cdf_header_t *h,\n    const void *p, size_t tail, int line)\n{\n\tconst char *b = (const char *)sst->sst_tab;\n\tconst char *e = ((const char *)p) + tail;\n\tsize_t ss = sst->sst_dirlen < h->h_min_size_standard_stream ?\n\t    CDF_SHORT_SEC_SIZE(h) : CDF_SEC_SIZE(h);\n\t(void)&line;\n\tif (e >= b && (size_t)(e - b) <= ss * sst->sst_len)\n\t\treturn 0;\n\tDPRINTF((\"%d: offset begin %p < end %p || %\" SIZE_T_FORMAT \"u\"\n\t    \" > %\" SIZE_T_FORMAT \"u [%\" SIZE_T_FORMAT \"u %\"\n\t    SIZE_T_FORMAT \"u]\\n\", line, b, e, (size_t)(e - b),\n\t    ss * sst->sst_len, ss, sst->sst_len));\n\terrno = EFTYPE;\n\treturn -1;\n}", "target": 0}
{"code": "_polkit_subject_get_cmdline (PolkitSubject *subject, gint *pid, gint *uid)\n{\n  PolkitSubject *process;\n  gchar *ret;\n  gchar *filename;\n  gchar *contents;\n  gsize contents_len;\n  GError *error;\n  guint n;\n  g_return_val_if_fail (subject != NULL, NULL);\n  error = NULL;\n  ret = NULL;\n  process = NULL;\n  filename = NULL;\n  contents = NULL;\n  if (POLKIT_IS_UNIX_PROCESS (subject))\n   {\n      process = g_object_ref (subject);\n    }\n  else if (POLKIT_IS_SYSTEM_BUS_NAME (subject))\n    {\n      process = polkit_system_bus_name_get_process_sync (POLKIT_SYSTEM_BUS_NAME (subject),\n                                                         NULL,\n                                                         &error);\n      if (process == NULL)\n        {\n          g_warning (\"Error getting process for system bus name `%s': %s\",\n                     polkit_system_bus_name_get_name (POLKIT_SYSTEM_BUS_NAME (subject)),\n                     error->message);\n          g_error_free (error);\n          goto out;\n        }\n    }\n  else\n    {\n      g_warning (\"Unknown subject type passed to guess_program_name()\");\n      goto out;\n    }\n  *pid = polkit_unix_process_get_pid (POLKIT_UNIX_PROCESS (process));\n  *uid = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (process));\n  filename = g_strdup_printf (\"/proc/%d/cmdline\", *pid);\n  if (!g_file_get_contents (filename,\n                            &contents,\n                            &contents_len,\n                            &error))\n    {\n      g_warning (\"Error openeing `%s': %s\",\n                 filename,\n                 error->message);\n      g_error_free (error);\n      goto out;\n    }\n  for (n = 0; n < contents_len - 1; n++)\n    {\n      if (contents[n] == '\\0')\n        contents[n] = ' ';\n    }\n  ret = g_strdup (contents);\n  g_strstrip (ret);\n out:\n  g_free (filename);\n  g_free (contents);\n  if (process != NULL)\n    g_object_unref (process);\n  return ret;\n}", "target": 0}
{"code": "void ntlm_write_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (fields->MaxLen < 1)\n\t\tfields->MaxLen = fields->Len;\n\tStream_Write_UINT16(s, fields->Len); \n\tStream_Write_UINT16(s, fields->MaxLen); \n\tStream_Write_UINT32(s, fields->BufferOffset); \n}", "target": 1}
{"code": "GF_Err srpp_on_child_box(GF_Box *s, GF_Box *a)\n{\n\tGF_SRTPProcessBox *ptr = (GF_SRTPProcessBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_SCHI:\n\t\tif (ptr->info) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\tptr->info = (GF_SchemeInformationBox *)a;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SCHM:\n\t\tif (ptr->scheme_type) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\tptr->scheme_type = (GF_SchemeTypeBox *)a;\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "void SimpleSoftOMXComponent::onSendCommand(\n        OMX_COMMANDTYPE cmd, OMX_U32 param) {\n switch (cmd) {\n case OMX_CommandStateSet:\n {\n            onChangeState((OMX_STATETYPE)param);\n break;\n }\n case OMX_CommandPortEnable:\n case OMX_CommandPortDisable:\n {\n            onPortEnable(param, cmd == OMX_CommandPortEnable);\n break;\n }\n case OMX_CommandFlush:\n {\n            onPortFlush(param, true );\n break;\n }\n default:\n            TRESPASS();\n break;\n }\n}", "target": 0}
{"code": "Value ExpressionRandom::evaluate(const Document& root, Variables* variables) const {\n    return Value(getRandomValue());\n}", "target": 0}
{"code": "TIFFReadRGBAStrip(TIFF* tif, uint32 row, uint32 * raster )\n{\n    char \temsg[1024] = \"\";\n    TIFFRGBAImage img;\n    int \tok;\n    uint32\trowsperstrip, rows_to_read;\n    if( TIFFIsTiled( tif ) )\n    {\n\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif),\n                  \"Can't use TIFFReadRGBAStrip() with tiled file.\");\n\treturn (0);\n    }\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    if( (row % rowsperstrip) != 0 )\n    {\n\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif),\n\t\t\t\t\"Row passed to TIFFReadRGBAStrip() must be first in a strip.\");\n\t\treturn (0);\n    }\n    if (TIFFRGBAImageOK(tif, emsg) && TIFFRGBAImageBegin(&img, tif, 0, emsg)) {\n        img.row_offset = row;\n        img.col_offset = 0;\n        if( row + rowsperstrip > img.height )\n            rows_to_read = img.height - row;\n        else\n            rows_to_read = rowsperstrip;\n\tok = TIFFRGBAImageGet(&img, raster, img.width, rows_to_read );\n\tTIFFRGBAImageEnd(&img);\n    } else {\n\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"%s\", emsg);\n\t\tok = 0;\n    }\n    return (ok);\n}", "target": 0}
{"code": "    TestOpaqueResourceDecoderImpl(absl::string_view name_field)\n        : Config::OpaqueResourceDecoderImpl<Current>(ProtobufMessage::getStrictValidationVisitor(),\n                                                     name_field) {}", "target": 0}
{"code": "dump_keywords(vector_t *keydump, int level, FILE *fp)\n{\n\tunsigned int i;\n\tkeyword_t *keyword_vec;\n\tchar file_name[21];\n\tif (!level) {\n\t\tsnprintf(file_name, sizeof(file_name), \"/tmp/keywords.%d\", getpid());\n\t\tfp = fopen(file_name, \"w\");\n\t\tif (!fp)\n\t\t\treturn;\n\t}\n\tfor (i = 0; i < vector_size(keydump); i++) {\n\t\tkeyword_vec = vector_slot(keydump, i);\n\t\tfprintf(fp, \"%*sKeyword : %s (%s)\\n\", level * 2, \"\", keyword_vec->string, keyword_vec->active ? \"active\": \"disabled\");\n\t\tif (keyword_vec->sub)\n\t\t\tdump_keywords(keyword_vec->sub, level + 1, fp);\n\t}\n\tif (!level)\n\t\tfclose(fp);\n}", "target": 1}
{"code": "memcmp_constant_time (const void *a, const void *b, size_t size) {\n  const uint8_t * a1 = a;\n  const uint8_t * b1 = b;\n  int ret = 0;\n  size_t i;\n  for (i = 0; i < size; i++) {\n      ret |= *a1++ ^ *b1++;\n  }\n  return ret;\n}", "target": 0}
{"code": "bgp_capability_receive (struct peer *peer, bgp_size_t size)\n{\n  u_char *pnt;\n  int ret;\n  pnt = stream_pnt (peer->ibuf);\n  if (BGP_DEBUG (normal, NORMAL))\n    zlog_debug (\"%s rcv CAPABILITY\", peer->host);\n  if (! CHECK_FLAG (peer->cap, PEER_CAP_DYNAMIC_ADV))\n    {\n      plog_err (peer->log, \"%s [Error] BGP dynamic capability is not enabled\",\n\t\tpeer->host);\n      bgp_notify_send (peer,\n\t\t       BGP_NOTIFY_HEADER_ERR,\n\t\t       BGP_NOTIFY_HEADER_BAD_MESTYPE);\n      return;\n    }\n  if (peer->status != Established)\n    {\n      plog_err (peer->log,\n\t\t\"%s [Error] Dynamic capability packet received under status %s\", peer->host, LOOKUP (bgp_status_msg, peer->status));\n      bgp_notify_send (peer, BGP_NOTIFY_FSM_ERR, 0);\n      return;\n    }\n  ret = bgp_capability_msg_parse (peer, pnt, size);\n}", "target": 1}
{"code": "print_line_header(Dwarf_Debug dbg,\n    Dwarf_Bool is_single_tab,\n    Dwarf_Bool is_actuals_tab)\n{\nif (!is_single_tab) {\nif (is_actuals_tab) {\n_dwarf_printf(dbg,\"\\nActuals Table\\n\");\n_dwarf_printf(dbg,\n\"                                                         be\\n\"\n\"                                                         ls\\n\"\n\"                                                         ce\\n\"\n\" section    op                                           kq\\n\"\n\" offset     code                address/index    row isa ??\\n\");\n    return;\n} else {\n_dwarf_printf(dbg,\"\\nLogicals Table\\n\");\n_dwarf_printf(dbg,\n\"                                                                              s pe\\n\"\n\"                                                                              tirp\\n\"\n\"                                                                              msoi\\n\"\n\" section          op                                                          tall\\n\"\n\" offset      row  code                address/indx fil lne col disc cntx subp ????\\n\");\n    return;\n}\n}\n_dwarf_printf(dbg,\n\"                                                         s b e p e i d\\n\"\n\"                                                         t l s r p s i\\n\"\n\"                                                         m c e o i a s\\n\"\n\" section    op                                       col t k q l l   c\\n\"\n\" offset     code               address     file line umn ? ? ? ? ?\\n\");\n} ", "target": 1}
{"code": "static void n_tty_receive_break(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tif (I_IGNBRK(tty))\n\t\treturn;\n\tif (I_BRKINT(tty)) {\n\t\tisig(SIGINT, tty);\n\t\tif (!L_NOFLSH(tty)) {\n\t\t\tup_read(&tty->termios_rwsem);\n\t\t\tn_tty_flush_buffer(tty);\n\t\t\ttty_driver_flush_buffer(tty);\n\t\t\tdown_read(&tty->termios_rwsem);\n\t\t}\n\t\treturn;\n\t}\n\tif (I_PARMRK(tty)) {\n\t\tput_tty_queue('\\377', ldata);\n\t\tput_tty_queue('\\0', ldata);\n\t}\n\tput_tty_queue('\\0', ldata);\n\tif (waitqueue_active(&tty->read_wait))\n\t\twake_up_interruptible(&tty->read_wait);\n}", "target": 0}
{"code": "static int memory_access_ok(struct vhost_dev *d, struct vhost_memory *mem,\n\t\t\t    int log_all)\n{\n\tint i;\n\tfor (i = 0; i < d->nvqs; ++i) {\n\t\tint ok;\n\t\tmutex_lock(&d->vqs[i].mutex);\n\t\tif (d->vqs[i].private_data)\n\t\t\tok = vq_memory_access_ok(d->vqs[i].log_base, mem,\n\t\t\t\t\t\t log_all);\n\t\telse\n\t\t\tok = 1;\n\t\tmutex_unlock(&d->vqs[i].mutex);\n\t\tif (!ok)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "static void jsR_callfunction(js_State *J, int n, js_Function *F, js_Environment *scope)\n{\n\tjs_Value v;\n\tint i;\n\tscope = jsR_newenvironment(J, jsV_newobject(J, JS_COBJECT, NULL), scope);\n\tjsR_savescope(J, scope);\n\tif (F->arguments) {\n\t\tjs_newobject(J);\n\t\tif (!J->strict) {\n\t\t\tjs_currentfunction(J);\n\t\t\tjs_defproperty(J, -2, \"callee\", JS_DONTENUM);\n\t\t}\n\t\tjs_pushnumber(J, n);\n\t\tjs_defproperty(J, -2, \"length\", JS_DONTENUM);\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tjs_copy(J, i + 1);\n\t\t\tjs_setindex(J, -2, i);\n\t\t}\n\t\tjs_initvar(J, \"arguments\", -1);\n\t\tjs_pop(J, 1);\n\t}\n\tfor (i = 0; i < F->numparams; ++i) {\n\t\tif (i < n)\n\t\t\tjs_initvar(J, F->vartab[i], i + 1);\n\t\telse {\n\t\t\tjs_pushundefined(J);\n\t\t\tjs_initvar(J, F->vartab[i], -1);\n\t\t\tjs_pop(J, 1);\n\t\t}\n\t}\n\tjs_pop(J, n);\n\tjsR_run(J, F);\n\tv = *stackidx(J, -1);\n\tTOP = --BOT; \n\tjs_pushvalue(J, v);\n\tjsR_restorescope(J);\n}", "target": 0}
{"code": "void tcp_finish_connect(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\ttcp_set_state(sk, TCP_ESTABLISHED);\n\tif (skb) {\n\t\ticsk->icsk_af_ops->sk_rx_dst_set(sk, skb);\n\t\tsecurity_inet_conn_established(sk, skb);\n\t}\n\ticsk->icsk_af_ops->rebuild_header(sk);\n\ttcp_init_metrics(sk);\n\ttcp_init_congestion_control(sk);\n\ttp->lsndtime = tcp_time_stamp;\n\ttcp_init_buffer_space(sk);\n\tif (sock_flag(sk, SOCK_KEEPOPEN))\n\t\tinet_csk_reset_keepalive_timer(sk, keepalive_time_when(tp));\n\tif (!tp->rx_opt.snd_wscale)\n\t\t__tcp_fast_path_on(tp, tp->snd_wnd);\n\telse\n\t\ttp->pred_flags = 0;\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tsk->sk_state_change(sk);\n\t\tsk_wake_async(sk, SOCK_WAKE_IO, POLL_OUT);\n\t}\n}", "target": 0}
{"code": "static char *stibp_state(void)\n{\n\tif (spectre_v2_in_ibrs_mode(spectre_v2_enabled))\n\t\treturn \"\";\n\tswitch (spectre_v2_user_stibp) {\n\tcase SPECTRE_V2_USER_NONE:\n\t\treturn \", STIBP: disabled\";\n\tcase SPECTRE_V2_USER_STRICT:\n\t\treturn \", STIBP: forced\";\n\tcase SPECTRE_V2_USER_STRICT_PREFERRED:\n\t\treturn \", STIBP: always-on\";\n\tcase SPECTRE_V2_USER_PRCTL:\n\tcase SPECTRE_V2_USER_SECCOMP:\n\t\tif (static_key_enabled(&switch_to_cond_stibp))\n\t\t\treturn \", STIBP: conditional\";\n\t}\n\treturn \"\";\n}", "target": 1}
{"code": "png_crc_error(png_structp png_ptr)\n{\n   png_byte crc_bytes[4];\n   png_uint_32 crc;\n   int need_crc = 1;\n   if (png_ptr->chunk_name[0] & 0x20)                     \n   {\n      if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_MASK) ==\n          (PNG_FLAG_CRC_ANCILLARY_USE | PNG_FLAG_CRC_ANCILLARY_NOWARN))\n         need_crc = 0;\n   }\n   else                                                    \n   {\n      if (png_ptr->flags & PNG_FLAG_CRC_CRITICAL_IGNORE)\n         need_crc = 0;\n   }\n   png_read_data(png_ptr, crc_bytes, 4);\n   if (need_crc)\n   {\n      crc = png_get_uint_32(crc_bytes);\n      return ((int)(crc != png_ptr->crc));\n   }\n   else\n      return (0);\n}", "target": 0}
{"code": "static ImageLoader::BypassMainWorldBehavior shouldBypassMainWorldCSP(\n    ImageLoader* loader) {\n  DCHECK(loader);\n  DCHECK(loader->element());\n  if (loader->element()->document().frame() &&\n      loader->element()\n          ->document()\n          .frame()\n          ->script()\n          .shouldBypassMainWorldCSP())\n    return ImageLoader::BypassMainWorldCSP;\n  return ImageLoader::DoNotBypassMainWorldCSP;\n}", "target": 0}
{"code": "struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned int flags,\n\t\t\t\t    int *peeked, int *off, int *err)\n{\n\tstruct sk_buff *skb;\n\tlong timeo;\n\tint error = sock_error(sk);\n\tif (error)\n\t\tgoto no_packet;\n\ttimeo = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n\tdo {\n\t\tunsigned long cpu_flags;\n\t\tstruct sk_buff_head *queue = &sk->sk_receive_queue;\n\t\tspin_lock_irqsave(&queue->lock, cpu_flags);\n\t\tskb_queue_walk(queue, skb) {\n\t\t\t*peeked = skb->peeked;\n\t\t\tif (flags & MSG_PEEK) {\n\t\t\t\tif (*off >= skb->len) {\n\t\t\t\t\t*off -= skb->len;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tskb->peeked = 1;\n\t\t\t\tatomic_inc(&skb->users);\n\t\t\t} else\n\t\t\t\t__skb_unlink(skb, queue);\n\t\t\tspin_unlock_irqrestore(&queue->lock, cpu_flags);\n\t\t\treturn skb;\n\t\t}\n\t\tspin_unlock_irqrestore(&queue->lock, cpu_flags);\n\t\terror = -EAGAIN;\n\t\tif (!timeo)\n\t\t\tgoto no_packet;\n\t} while (!wait_for_packet(sk, err, &timeo));\n\treturn NULL;\nno_packet:\n\t*err = error;\n\treturn NULL;\n}", "target": 1}
{"code": "int ZlibInStream::overrun(int itemSize, int nItems, bool wait)\n{\n  if (itemSize > bufSize)\n    throw Exception(\"ZlibInStream overrun: max itemSize exceeded\");\n  if (!underlying)\n    throw Exception(\"ZlibInStream overrun: no underlying stream\");\n  if (end - ptr != 0)\n    memmove(start, ptr, end - ptr);\n  offset += ptr - start;\n  end -= ptr - start;\n  ptr = start;\n  while (end - ptr < itemSize) {\n    if (!decompress(wait))\n      return 0;\n  }\n  if (itemSize * nItems > end - ptr)\n    nItems = (end - ptr) / itemSize;\n  return nItems;\n}", "target": 1}
{"code": "acc_ctx_hints(OM_uint32 *minor_status,\n\t      gss_ctx_id_t *ctx,\n\t      spnego_gss_cred_id_t spcred,\n\t      gss_buffer_t *mechListMIC,\n\t      OM_uint32 *negState,\n\t      send_token_flag *return_token)\n{\n\tOM_uint32 tmpmin, ret;\n\tgss_OID_set supported_mechSet;\n\tspnego_gss_ctx_id_t sc = NULL;\n\t*mechListMIC = GSS_C_NO_BUFFER;\n\tsupported_mechSet = GSS_C_NO_OID_SET;\n\t*return_token = NO_TOKEN_SEND;\n\t*negState = REJECT;\n\t*minor_status = 0;\n\tif (*ctx != GSS_C_NO_CONTEXT)\n\t    return GSS_S_DEFECTIVE_TOKEN;\n\tret = get_negotiable_mechs(minor_status, spcred, GSS_C_ACCEPT,\n\t\t\t\t   &supported_mechSet);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\tret = make_NegHints(minor_status, mechListMIC);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\tsc = create_spnego_ctx();\n\tif (sc == NULL) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tif (put_mech_set(supported_mechSet, &sc->DER_mechTypes) < 0) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tsc->internal_mech = GSS_C_NO_OID;\n\t*negState = ACCEPT_INCOMPLETE;\n\t*return_token = INIT_TOKEN_SEND;\n\tsc->firstpass = 1;\n\t*ctx = (gss_ctx_id_t)sc;\n\tsc = NULL;\n\tret = GSS_S_COMPLETE;\ncleanup:\n\trelease_spnego_ctx(&sc);\n\tgss_release_oid_set(&tmpmin, &supported_mechSet);\n\treturn ret;\n}", "target": 1}
{"code": "static void virtio_blk_handle_write(VirtIOBlockReq *req, MultiReqBuffer *mrb)\n{\n    BlockRequest *blkreq;\n    uint64_t sector;\n    sector = ldq_p(&req->out->sector);\n    trace_virtio_blk_handle_write(req, sector, req->qiov.size / 512);\n    if (sector & req->dev->sector_mask) {\n        virtio_blk_rw_complete(req, -EIO);\n        return;\n    }\n    if (mrb->num_writes == 32) {\n        virtio_submit_multiwrite(req->dev->bs, mrb);\n    }\n    blkreq = &mrb->blkreq[mrb->num_writes];\n    blkreq->sector = sector;\n    blkreq->nb_sectors = req->qiov.size / BDRV_SECTOR_SIZE;\n    blkreq->qiov = &req->qiov;\n    blkreq->cb = virtio_blk_rw_complete;\n    blkreq->opaque = req;\n    blkreq->error = 0;\n    mrb->num_writes++;\n}", "target": 1}
{"code": "ssh_packet_set_compress_hooks(struct ssh *ssh, void *ctx,\n    void *(*allocfunc)(void *, u_int, u_int),\n    void (*freefunc)(void *, void *))\n{\n\tssh->state->compression_out_stream.zalloc = (alloc_func)allocfunc;\n\tssh->state->compression_out_stream.zfree = (free_func)freefunc;\n\tssh->state->compression_out_stream.opaque = ctx;\n\tssh->state->compression_in_stream.zalloc = (alloc_func)allocfunc;\n\tssh->state->compression_in_stream.zfree = (free_func)freefunc;\n\tssh->state->compression_in_stream.opaque = ctx;\n}", "target": 1}
{"code": "completion_glob_pattern (string)\n     char *string;\n{\n  register int c;\n  char *send;\n  int open;\n  DECLARE_MBSTATE;\n  open = 0;\n  send = string + strlen (string);\n  while (c = *string++)\n    {\n      switch (c)\n\t{\n\tcase '?':\n\tcase '*':\n\t  return (1);\n\tcase '[':\n\t  open++;\n\t  continue;\n\tcase ']':\n\t  if (open)\n\t    return (1);\n\t  continue;\n\tcase '+':\n\tcase '@':\n\tcase '!':\n\t  if (*string == '(')\t\n\t    return (1);\n\t  continue;\n\tcase '\\\\':\n\t  if (*string++ == 0)\n\t    return (0);\n\t}\n#ifdef HANDLE_MULTIBYTE\n      string--;\n      ADVANCE_CHAR_P (string, send - string);\n      string++;\n#else\n      ADVANCE_CHAR_P (string, send - string);\n#endif\n    }\n  return (0);\n}", "target": 1}
{"code": "fname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  \n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n    if (name != NULL)\n    {\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse\n\t{\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n    return match;\n}", "target": 1}
{"code": "htc_request_check_host_hdr(struct http *hp)\n{\n\tint u;\n\tint seen_host = 0;\n\tfor (u = HTTP_HDR_FIRST; u < hp->nhd; u++) {\n\t\tif (hp->hd[u].b == NULL)\n\t\t\tcontinue;\n\t\tAN(hp->hd[u].b);\n\t\tAN(hp->hd[u].e);\n\t\tif (http_IsHdr(&hp->hd[u], H_Host)) {\n\t\t\tif (seen_host) {\n\t\t\t\treturn (400);\n\t\t\t}\n\t\t\tseen_host = 1;\n\t\t}\n\t}\n\treturn (0);\n}", "target": 1}
{"code": "static bool ok_inflater_init_fixed_huffman(ok_inflater *inflater) {\n    if (!inflater->fixed_literal_huffman) {\n        ok_inflater_huffman_tree *tree = ok_alloc(inflater, sizeof(ok_inflater_huffman_tree));\n        if (tree) {\n            uint8_t code_length[288];\n            int i;\n            for (i = 0; i < 144; i++) {\n                code_length[i] = 8;\n            }\n            for (i = 144; i < 256; i++) {\n                code_length[i] = 9;\n            }\n            for (i = 256; i < 280; i++) {\n                code_length[i] = 7;\n            }\n            for (i = 280; i < 288; i++) {\n                code_length[i] = 8;\n            }\n            ok_inflater_make_huffman_tree_from_array(tree, code_length,\n                                                     sizeof(code_length) / sizeof(code_length[0]));\n            inflater->fixed_literal_huffman = tree;\n        }\n    }\n    if (!inflater->fixed_distance_huffman) {\n        ok_inflater_huffman_tree *tree = ok_alloc(inflater, sizeof(ok_inflater_huffman_tree));\n        if (tree) {\n            uint8_t distance_code_length[32];\n            for (int i = 0; i < 32; i++) {\n                distance_code_length[i] = 5;\n            }\n            ok_inflater_make_huffman_tree_from_array(tree, distance_code_length, 32);\n            inflater->fixed_distance_huffman = tree;\n        }\n    }\n    return inflater->fixed_literal_huffman && inflater->fixed_distance_huffman;\n}", "target": 0}
{"code": "int wvlan_set_station_nickname(struct net_device *dev,\n\t\t      struct iw_request_info *info,\n\t\t      union iwreq_data *wrqu,\n\t\t      char *extra)\n{\n\tstruct wl_private *lp = wl_priv(dev);\n\tunsigned long flags;\n\tint         ret = 0;\n\tDBG_FUNC(\"wvlan_set_station_nickname\");\n\tDBG_ENTER(DbgInfo);\n\twl_lock(lp, &flags);\n\tmemset(lp->StationName, 0, sizeof(lp->StationName));\n\tmemcpy(lp->StationName, extra, wrqu->data.length);\n\twl_apply(lp);\n\twl_unlock(lp, &flags);\n\tDBG_LEAVE(DbgInfo);\n\treturn ret;\n} ", "target": 1}
{"code": "static void put_crypt_info(struct fscrypt_info *ci)\n{\n\tif (!ci)\n\t\treturn;\n\tkey_put(ci->ci_keyring_key);\n\tcrypto_free_skcipher(ci->ci_ctfm);\n\tkmem_cache_free(fscrypt_info_cachep, ci);\n}", "target": 1}
{"code": "int anon_vma_clone(struct vm_area_struct *dst, struct vm_area_struct *src)\n{\n\tstruct anon_vma_chain *avc, *pavc;\n\tstruct anon_vma *root = NULL;\n\tlist_for_each_entry_reverse(pavc, &src->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma;\n\t\tavc = anon_vma_chain_alloc(GFP_NOWAIT | __GFP_NOWARN);\n\t\tif (unlikely(!avc)) {\n\t\t\tunlock_anon_vma_root(root);\n\t\t\troot = NULL;\n\t\t\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\t\t\tif (!avc)\n\t\t\t\tgoto enomem_failure;\n\t\t}\n\t\tanon_vma = pavc->anon_vma;\n\t\troot = lock_anon_vma_root(root, anon_vma);\n\t\tanon_vma_chain_link(dst, avc, anon_vma);\n\t\tif (!dst->anon_vma && src->anon_vma &&\n\t\t    anon_vma != src->anon_vma && anon_vma->degree < 2)\n\t\t\tdst->anon_vma = anon_vma;\n\t}\n\tif (dst->anon_vma)\n\t\tdst->anon_vma->degree++;\n\tunlock_anon_vma_root(root);\n\treturn 0;\n enomem_failure:\n\tdst->anon_vma = NULL;\n\tunlink_anon_vmas(dst);\n\treturn -ENOMEM;\n}", "target": 1}
{"code": "static void *adpt_ioctl_from_context(adpt_hba *pHba, u32 context)\n{\n#if BITS_PER_LONG == 32\n\treturn (void *)(unsigned long)context;\n#else\n\tvoid *p = pHba->ioctl_reply_context[context];\n\tpHba->ioctl_reply_context[context] = NULL;\n\treturn p;\n#endif\n}", "target": 1}
{"code": "find_extend_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma, *prev;\n\taddr &= PAGE_MASK;\n\tvma = find_vma_prev(mm, addr, &prev);\n\tif (vma && (vma->vm_start <= addr))\n\t\treturn vma;\n\tif (!prev || expand_stack(prev, addr))\n\t\treturn NULL;\n\tif (prev->vm_flags & VM_LOCKED)\n\t\tmake_pages_present(addr, prev->vm_end);\n\treturn prev;\n}", "target": 0}
{"code": "static void mysql_prune_stmt_list(MYSQL *mysql)\n{\n  LIST *element= mysql->stmts;\n  LIST *pruned_list= 0;\n  for (; element; element= element->next)\n  {\n    MYSQL_STMT *stmt= (MYSQL_STMT *) element->data;\n    if (stmt->state != MYSQL_STMT_INIT_DONE)\n    {\n      stmt->mysql= 0;\n      stmt->last_errno= CR_SERVER_LOST;\n      strmov(stmt->last_error, ER(CR_SERVER_LOST));\n      strmov(stmt->sqlstate, unknown_sqlstate);\n    }\n    else\n    {\n      pruned_list= list_add(pruned_list, element);\n    }\n  }\n  mysql->stmts= pruned_list;\n}", "target": 1}
{"code": "static size_t php_pgsql_fd_read(php_stream *stream, char *buf, size_t count) \n{\n\treturn 0;\n}", "target": 0}
{"code": "GopherStateData::~GopherStateData()\n{\n    if (entry)\n        entry->unlock(\"gopherState\");\n    if (buf)\n        memFree(buf, MEM_4K_BUF);\n}", "target": 1}
{"code": "static int inet6_fill_ifaddr(struct sk_buff *skb, struct inet6_ifaddr *ifa,\n\t\t\t     u32 portid, u32 seq, int event, unsigned int flags)\n{\n\tstruct nlmsghdr  *nlh;\n\tu32 preferred, valid;\n\tnlh = nlmsg_put(skb, portid, seq, event, sizeof(struct ifaddrmsg), flags);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\tput_ifaddrmsg(nlh, ifa->prefix_len, ifa->flags, rt_scope(ifa->scope),\n\t\t      ifa->idev->dev->ifindex);\n\tif (!(ifa->flags&IFA_F_PERMANENT)) {\n\t\tpreferred = ifa->prefered_lft;\n\t\tvalid = ifa->valid_lft;\n\t\tif (preferred != INFINITY_LIFE_TIME) {\n\t\t\tlong tval = (jiffies - ifa->tstamp)/HZ;\n\t\t\tif (preferred > tval)\n\t\t\t\tpreferred -= tval;\n\t\t\telse\n\t\t\t\tpreferred = 0;\n\t\t\tif (valid != INFINITY_LIFE_TIME) {\n\t\t\t\tif (valid > tval)\n\t\t\t\t\tvalid -= tval;\n\t\t\t\telse\n\t\t\t\t\tvalid = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tpreferred = INFINITY_LIFE_TIME;\n\t\tvalid = INFINITY_LIFE_TIME;\n\t}\n\tif (!ipv6_addr_any(&ifa->peer_addr)) {\n\t\tif (nla_put(skb, IFA_LOCAL, 16, &ifa->addr) < 0 ||\n\t\t    nla_put(skb, IFA_ADDRESS, 16, &ifa->peer_addr) < 0)\n\t\t\tgoto error;\n\t} else\n\t\tif (nla_put(skb, IFA_ADDRESS, 16, &ifa->addr) < 0)\n\t\t\tgoto error;\n\tif (put_cacheinfo(skb, ifa->cstamp, ifa->tstamp, preferred, valid) < 0)\n\t\tgoto error;\n\treturn nlmsg_end(skb, nlh);\nerror:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}", "target": 0}
{"code": "  explicit ThreadPoolHandleOp(OpKernelConstruction* ctx) : OpKernel(ctx) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"display_name\", &display_name_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"num_threads\", &num_threads_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"max_intra_op_parallelism\",\n                                     &max_intra_op_parallelism_));\n    OP_REQUIRES(\n        ctx, num_threads_ > 0,\n        errors::InvalidArgument(\"`num_threads` must be greater than zero.\"));\n  }", "target": 1}
{"code": "void inet_sock_destruct(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\t__skb_queue_purge(&sk->sk_receive_queue);\n\t__skb_queue_purge(&sk->sk_error_queue);\n\tsk_mem_reclaim(sk);\n\tif (sk->sk_type == SOCK_STREAM && sk->sk_state != TCP_CLOSE) {\n\t\tpr_err(\"Attempt to release TCP socket in state %d %p\\n\",\n\t\t       sk->sk_state, sk);\n\t\treturn;\n\t}\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tpr_err(\"Attempt to release alive inet socket %p\\n\", sk);\n\t\treturn;\n\t}\n\tWARN_ON(atomic_read(&sk->sk_rmem_alloc));\n\tWARN_ON(atomic_read(&sk->sk_wmem_alloc));\n\tWARN_ON(sk->sk_wmem_queued);\n\tWARN_ON(sk->sk_forward_alloc);\n\tkfree(inet->opt);\n\tdst_release(rcu_dereference_check(sk->sk_dst_cache, 1));\n\tsk_refcnt_debug_dec(sk);\n}", "target": 1}
{"code": "static GF_Err BM_ParseGlobalQuantizer(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tGF_Node *node;\n\tGF_Command *com;\n\tGF_CommandField *inf;\n\tnode = gf_bifs_dec_node(codec, bs, NDT_SFWorldNode);\n\tif (!node) return GF_NON_COMPLIANT_BITSTREAM;\n\tif (codec->scenegraph->global_qp) {\n\t\tgf_node_unregister(codec->scenegraph->global_qp, NULL);\n\t}\n\tcodec->ActiveQP = NULL;\n\tcodec->scenegraph->global_qp = NULL;\n\tif (gf_node_get_tag(node) != TAG_MPEG4_QuantizationParameter) {\n\t\tgf_node_unregister(node, NULL);\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tcodec->ActiveQP = (M_QuantizationParameter *) node;\n\tcodec->ActiveQP->isLocal = 0;\n\tcodec->scenegraph->global_qp = node;\n\tnode->sgprivate->num_instances = 2;\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_GLOBAL_QUANTIZER);\n\tinf = gf_sg_command_field_new(com);\n\tinf->new_node = node;\n\tinf->field_ptr = &inf->new_node;\n\tinf->fieldType = GF_SG_VRML_SFNODE;\n\tgf_list_add(com_list, com);\n\treturn GF_OK;\n}", "target": 1}
{"code": "push_spaces(struct readbuffer *obuf, int pre_mode, int width)\n{\n    int i;\n    if (width <= 0)\n\treturn;\n    check_breakpoint(obuf, pre_mode, \" \");\n    for (i = 0; i < width; i++)\n\tStrcat_char(obuf->line, ' ');\n    obuf->pos += width;\n    set_space_to_prevchar(obuf->prevchar);\n    obuf->flag |= RB_NFLUSHED;\n}", "target": 0}
{"code": "    const std::unordered_map<std::string, Cookie> &getCookies() const\n    {\n        return cookies();\n    }", "target": 1}
{"code": "  static bool TryLock(Isolate* isolate) {\n    return isolate->break_access_->TryLock();\n  }", "target": 0}
{"code": "static int ftrace_function_set_filter_pred(struct filter_pred *pred,\n\t\t\t\t\t   struct function_filter_data *data)\n{\n\tint ret;\n\tret = ftrace_function_check_pred(pred);\n\tif (ret)\n\t\treturn ret;\n\treturn __ftrace_function_set_filter(pred->op == OP_EQ,\n\t\t\t\t\t    pred->regex.pattern,\n\t\t\t\t\t    pred->regex.len,\n\t\t\t\t\t    data);\n}", "target": 0}
{"code": "GF_Err dac3_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DEC3;\n\te = gf_isom_box_write_header(s, bs);\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DAC3;\n\tif (e) return e;\n\te = gf_odf_ac3_cfg_write_bs(&ptr->cfg, bs);\n\tif (e) return e;\n\tif (ptr->cfg.atmos_ec3_ext || ptr->cfg.complexity_index_type) {\n\t\tgf_bs_write_int(bs, 0, 7);\n\t\tgf_bs_write_int(bs, ptr->cfg.atmos_ec3_ext, 1);\n\t\tgf_bs_write_u8(bs, ptr->cfg.complexity_index_type);\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "int jp2_box_put(jp2_box_t *box, jas_stream_t *out)\n{\n\tjas_stream_t *tmpstream;\n\tbool extlen;\n\tbool dataflag;\n\ttmpstream = 0;\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (box->ops->putdata) {\n\t\t\tif ((*box->ops->putdata)(box, tmpstream)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tbox->len = jas_stream_tell(tmpstream) + JP2_BOX_HDRLEN(false);\n\t\tjas_stream_rewind(tmpstream);\n\t}\n\textlen = (box->len >= (((uint_fast64_t)1) << 32)) != 0;\n\tif (jp2_putuint32(out, extlen ? 1 : box->len)) {\n\t\tgoto error;\n\t}\n\tif (jp2_putuint32(out, box->type)) {\n\t\tgoto error;\n\t}\n\tif (extlen) {\n\t\tif (jp2_putuint64(out, box->len)) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\tif (dataflag) {\n\t\tif (jas_stream_copy(out, tmpstream, box->len - JP2_BOX_HDRLEN(false))) {\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn 0;\nerror:\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn -1;\n}", "target": 1}
{"code": "static void prefetch_enc(void)\n{\n  prefetch_table((const void *)encT, sizeof(encT));\n}", "target": 1}
{"code": "static inline void snow_set_blocks(SnowContext *s, int level, int x, int y, int l, int cb, int cr, int mx, int my, int ref, int type){\n    const int w= s->b_width << s->block_max_depth;\n    const int rem_depth= s->block_max_depth - level;\n    const int index= (x + y*w) << rem_depth;\n    const int block_w= 1<<rem_depth;\n    BlockNode block;\n    int i,j;\n    block.color[0]= l;\n    block.color[1]= cb;\n    block.color[2]= cr;\n    block.mx= mx;\n    block.my= my;\n    block.ref= ref;\n    block.type= type;\n    block.level= level;\n    for(j=0; j<block_w; j++){\n        for(i=0; i<block_w; i++){\n            s->block[index + i + j*w]= block;\n        }\n    }\n}", "target": 0}
{"code": "MODULE_ENTRY (fill_vtable) (GdkPixbufModule *module)\n{\n\tmodule->begin_load = gdk_pixbuf__bmp_image_begin_load;\n\tmodule->stop_load = gdk_pixbuf__bmp_image_stop_load;\n\tmodule->load_increment = gdk_pixbuf__bmp_image_load_increment;\n\tmodule->save = gdk_pixbuf__bmp_image_save;\n\tmodule->save_to_callback = gdk_pixbuf__bmp_image_save_to_callback;\n}", "target": 0}
{"code": "print_timer(struct seq_file *m, struct hrtimer *taddr, struct hrtimer *timer,\n\t    int idx, u64 now)\n{\n#ifdef CONFIG_TIMER_STATS\n\tchar tmp[TASK_COMM_LEN + 1];\n#endif\n\tSEQ_printf(m, \" #%d: \", idx);\n\tprint_name_offset(m, taddr);\n\tSEQ_printf(m, \", \");\n\tprint_name_offset(m, timer->function);\n\tSEQ_printf(m, \", S:%02x\", timer->state);\n#ifdef CONFIG_TIMER_STATS\n\tSEQ_printf(m, \", \");\n\tprint_name_offset(m, timer->start_site);\n\tmemcpy(tmp, timer->start_comm, TASK_COMM_LEN);\n\ttmp[TASK_COMM_LEN] = 0;\n\tSEQ_printf(m, \", %s/%d\", tmp, timer->start_pid);\n#endif\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \" # expires at %Lu-%Lu nsecs [in %Ld to %Ld nsecs]\\n\",\n\t\t(unsigned long long)ktime_to_ns(hrtimer_get_softexpires(timer)),\n\t\t(unsigned long long)ktime_to_ns(hrtimer_get_expires(timer)),\n\t\t(long long)(ktime_to_ns(hrtimer_get_softexpires(timer)) - now),\n\t\t(long long)(ktime_to_ns(hrtimer_get_expires(timer)) - now));\n}", "target": 1}
{"code": "allocate_trace_buffer(struct trace_array *tr, struct trace_buffer *buf, int size)\n{\n\tenum ring_buffer_flags rb_flags;\n\trb_flags = tr->trace_flags & TRACE_ITER_OVERWRITE ? RB_FL_OVERWRITE : 0;\n\tbuf->tr = tr;\n\tbuf->buffer = ring_buffer_alloc(size, rb_flags);\n\tif (!buf->buffer)\n\t\treturn -ENOMEM;\n\tbuf->data = alloc_percpu(struct trace_array_cpu);\n\tif (!buf->data) {\n\t\tring_buffer_free(buf->buffer);\n\t\treturn -ENOMEM;\n\t}\n\tset_buffer_entries(&tr->trace_buffer,\n\t\t\t   ring_buffer_size(tr->trace_buffer.buffer, 0));\n\treturn 0;\n}", "target": 1}
{"code": "static void __return_cfs_rq_runtime(struct cfs_rq *cfs_rq)\n{\n\tstruct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(cfs_rq->tg);\n\ts64 slack_runtime = cfs_rq->runtime_remaining - min_cfs_rq_runtime;\n\tif (slack_runtime <= 0)\n\t\treturn;\n\traw_spin_lock(&cfs_b->lock);\n\tif (cfs_b->quota != RUNTIME_INF &&\n\t    cfs_rq->runtime_expires == cfs_b->runtime_expires) {\n\t\tcfs_b->runtime += slack_runtime;\n\t\tif (cfs_b->runtime > sched_cfs_bandwidth_slice() &&\n\t\t    !list_empty(&cfs_b->throttled_cfs_rq))\n\t\t\tstart_cfs_slack_bandwidth(cfs_b);\n\t}\n\traw_spin_unlock(&cfs_b->lock);\n\tcfs_rq->runtime_remaining -= slack_runtime;\n}", "target": 1}
{"code": "static void nfs4_xdr_enc_getacl(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\tstruct nfs_getaclargs *args)\n{\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\tuint32_t replen;\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\treplen = hdr.replen + op_decode_hdr_maxsz + 1;\n\tencode_getattr_two(xdr, FATTR4_WORD0_ACL, 0, &hdr);\n\txdr_inline_pages(&req->rq_rcv_buf, replen << 2,\n\t\targs->acl_pages, args->acl_pgbase, args->acl_len);\n\tencode_nops(&hdr);\n}", "target": 0}
{"code": "static int __init nf_tables_module_init(void)\n{\n\tint err;\n\tinfo = kmalloc(sizeof(struct nft_expr_info) * NFT_RULE_MAXEXPRS,\n\t\t       GFP_KERNEL);\n\tif (info == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto err1;\n\t}\n\terr = nf_tables_core_module_init();\n\tif (err < 0)\n\t\tgoto err2;\n\terr = nfnetlink_subsys_register(&nf_tables_subsys);\n\tif (err < 0)\n\t\tgoto err3;\n\tpr_info(\"nf_tables: (c) 2007-2009 Patrick McHardy <kaber@trash.net>\\n\");\n\treturn register_pernet_subsys(&nf_tables_net_ops);\nerr3:\n\tnf_tables_core_module_exit();\nerr2:\n\tkfree(info);\nerr1:\n\treturn err;\n}", "target": 0}
{"code": "static int tls12_sigalg_allowed(SSL *s, int op, const unsigned char *ptmp)\n\t{\n\tconst tls12_hash_info *hinf = tls12_get_hash_info(ptmp[0]);\n\tif (!hinf || !hinf->mfunc)\n\t\treturn 0;\n\tif (tls12_get_pkey_idx(ptmp[1]) == -1)\n\t\treturn 0;\n\treturn ssl_security(s, op, hinf->secbits, hinf->nid, (void *)ptmp);\n\t}", "target": 0}
{"code": "static int ax_close(struct net_device *dev)\n{\n\tstruct mkiss *ax = netdev_priv(dev);\n\tif (ax->tty)\n\t\tclear_bit(TTY_DO_WRITE_WAKEUP, &ax->tty->flags);\n\tnetif_stop_queue(dev);\n\treturn 0;\n}", "target": 0}
{"code": "rrdp_process_deltas(struct update_notification *parent,\n    unsigned long cur_serial, struct visited_uris *visited_uris,\n    bool log_operation)\n{\n\tstruct proc_upd_args args;\n\targs.parent = parent;\n\targs.visited_uris = visited_uris;\n\targs.log_operation = log_operation;\n\treturn deltas_head_for_each(parent->deltas_list,\n\t    parent->global_data.serial, cur_serial, process_delta, &args);\n}", "target": 1}
{"code": "static void decode_ltp(LongTermPrediction *ltp,\n                       GetBitContext *gb, uint8_t max_sfb)\n{\n    int sfb;\n    ltp->lag  = get_bits(gb, 11);\n    ltp->coef = ltp_coef[get_bits(gb, 3)];\n    for (sfb = 0; sfb < FFMIN(max_sfb, MAX_LTP_LONG_SFB); sfb++)\n        ltp->used[sfb] = get_bits1(gb);\n}", "target": 0}
{"code": "static void __exit pptp_exit_module(void)\n{\n\tunregister_pppox_proto(PX_PROTO_PPTP);\n\tproto_unregister(&pptp_sk_proto);\n\tgre_del_protocol(&gre_pptp_protocol, GREPROTO_PPTP);\n\tvfree(callid_sock);\n}", "target": 0}
{"code": "cache_user_id (KBNODE keyblock)\n{\n  user_id_db_t r;\n  const char *uid;\n  size_t uidlen;\n  keyid_list_t keyids = NULL;\n  KBNODE k;\n  for (k = keyblock; k; k = k->next)\n    {\n      if (k->pkt->pkttype == PKT_PUBLIC_KEY\n\t  || k->pkt->pkttype == PKT_PUBLIC_SUBKEY)\n\t{\n\t  keyid_list_t a = xmalloc_clear (sizeof *a);\n\t  keyid_from_pk (k->pkt->pkt.public_key, a->keyid);\n\t  for (r = user_id_db; r; r = r->next)\n\t    {\n\t      keyid_list_t b = r->keyids;\n\t      for (b = r->keyids; b; b = b->next)\n\t\t{\n\t\t  if (b->keyid[0] == a->keyid[0]\n\t\t      && b->keyid[1] == a->keyid[1])\n\t\t    {\n\t\t      if (DBG_CACHE)\n\t\t\tlog_debug (\"cache_user_id: already in cache\\n\");\n\t\t      release_keyid_list (keyids);\n\t\t      xfree (a);\n\t\t      return;\n\t\t    }\n\t\t}\n\t    }\n\t  a->next = keyids;\n\t  keyids = a;\n\t}\n    }\n  if (!keyids)\n    BUG (); \n  uid = get_primary_uid (keyblock, &uidlen);\n  if (uid_cache_entries >= MAX_UID_CACHE_ENTRIES)\n    {\n      r = user_id_db;\n      user_id_db = r->next;\n      release_keyid_list (r->keyids);\n      xfree (r);\n      uid_cache_entries--;\n    }\n  r = xmalloc (sizeof *r + uidlen - 1);\n  r->keyids = keyids;\n  r->len = uidlen;\n  memcpy (r->name, uid, r->len);\n  r->next = user_id_db;\n  user_id_db = r;\n  uid_cache_entries++;\n}", "target": 0}
{"code": "static int sg_proc_seq_show_int(struct seq_file *s, void *v)\n{\n\tseq_printf(s, \"%d\\n\", *((int *)s->private));\n\treturn 0;\n}", "target": 0}
{"code": "void wake_q_add(struct wake_q_head *head, struct task_struct *task)\n{\n\tstruct wake_q_node *node = &task->wake_q;\n\tif (cmpxchg(&node->next, NULL, WAKE_Q_TAIL))\n\t\treturn;\n\tget_task_struct(task);\n\t*head->lastp = node;\n\thead->lastp = &node->next;\n}", "target": 0}
{"code": "static int mxf_read_primer_pack(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFContext *mxf = arg;\n    int item_num = avio_rb32(pb);\n    int item_len = avio_rb32(pb);\n    if (item_len != 18) {\n        avpriv_request_sample(pb, \"Primer pack item length %d\", item_len);\n        return AVERROR_PATCHWELCOME;\n    }\n    if (item_num > 65536) {\n        av_log(mxf->fc, AV_LOG_ERROR, \"item_num %d is too large\\n\", item_num);\n        return AVERROR_INVALIDDATA;\n    }\n    if (mxf->local_tags)\n        av_log(mxf->fc, AV_LOG_VERBOSE, \"Multiple primer packs\\n\");\n    av_free(mxf->local_tags);\n    mxf->local_tags_count = 0;\n    mxf->local_tags = av_calloc(item_num, item_len);\n    if (!mxf->local_tags)\n        return AVERROR(ENOMEM);\n    mxf->local_tags_count = item_num;\n    avio_read(pb, mxf->local_tags, item_num*item_len);\n    return 0;\n}", "target": 1}
{"code": "void cql_server::response::write_string(std::string_view s)\n{\n    write_short(cast_if_fits<uint16_t>(s.size()));\n    _body.write(bytes_view(reinterpret_cast<const int8_t*>(s.data()), s.size()));\n}", "target": 0}
{"code": "static u32 swf_get_32(SWFReader *read)\n{\n\tu32 val, res;\n\tval = swf_read_int(read, 32);\n\tres = (val&0xFF);\n\tres <<=8;\n\tres |= ((val>>8)&0xFF);\n\tres<<=8;\n\tres |= ((val>>16)&0xFF);\n\tres<<=8;\n\tres|= ((val>>24)&0xFF);\n\treturn res;\n}", "target": 1}
{"code": "TEST(FloatPoolingOpTest, AveragePool) {\n  FloatPoolingOpModel m(BuiltinOperator_AVERAGE_POOL_2D,\n                        {TensorType_FLOAT32, {1, 2, 4, 1}},\n                        2, 2,\n                        {TensorType_FLOAT32, {}});\n  m.SetInput({\n      0, 6, 2, 4,   \n      3, 2, 10, 7,  \n  });\n  m.Invoke();\n  EXPECT_THAT(m.GetOutput(), ElementsAreArray({2.75, 5.75}));\n}", "target": 0}
{"code": "clientHierarchical(ClientHttpRequest * http)\n{\n    HttpRequest *request = http->request;\n    HttpRequestMethod method = request->method;\n    if (!request->flags.hostVerified && (request->flags.intercepted || request->flags.interceptTproxy))\n        return 0;\n    if (request->flags.ims && !neighbors_do_private_keys)\n        return 0;\n    if (request->flags.auth)\n        return 0;\n    if (method == Http::METHOD_TRACE)\n        return 1;\n    if (method != Http::METHOD_GET)\n        return 0;\n    if (request->flags.loopDetected)\n        return 0;\n    if (request->url.getScheme() == AnyP::PROTO_HTTP)\n        return method.respMaybeCacheable();\n    if (request->url.getScheme() == AnyP::PROTO_GOPHER)\n        return gopherCachable(request);\n    if (request->url.getScheme() == AnyP::PROTO_CACHE_OBJECT)\n        return 0;\n    return 1;\n}", "target": 1}
{"code": "static int iommu_init_domains(struct intel_iommu *iommu)\n{\n\tu32 ndomains, nlongs;\n\tsize_t size;\n\tndomains = cap_ndoms(iommu->cap);\n\tpr_debug(\"%s: Number of Domains supported <%d>\\n\",\n\t\t iommu->name, ndomains);\n\tnlongs = BITS_TO_LONGS(ndomains);\n\tspin_lock_init(&iommu->lock);\n\tiommu->domain_ids = kcalloc(nlongs, sizeof(unsigned long), GFP_KERNEL);\n\tif (!iommu->domain_ids) {\n\t\tpr_err(\"%s: Allocating domain id array failed\\n\",\n\t\t       iommu->name);\n\t\treturn -ENOMEM;\n\t}\n\tsize = (ALIGN(ndomains, 256) >> 8) * sizeof(struct dmar_domain **);\n\tiommu->domains = kzalloc(size, GFP_KERNEL);\n\tif (iommu->domains) {\n\t\tsize = 256 * sizeof(struct dmar_domain *);\n\t\tiommu->domains[0] = kzalloc(size, GFP_KERNEL);\n\t}\n\tif (!iommu->domains || !iommu->domains[0]) {\n\t\tpr_err(\"%s: Allocating domain array failed\\n\",\n\t\t       iommu->name);\n\t\tkfree(iommu->domain_ids);\n\t\tkfree(iommu->domains);\n\t\tiommu->domain_ids = NULL;\n\t\tiommu->domains    = NULL;\n\t\treturn -ENOMEM;\n\t}\n\tset_bit(0, iommu->domain_ids);\n\treturn 0;\n}", "target": 0}
{"code": "void blog_post(char post_path[]) {\n\tif(strlen(post_path) != 0 || post_path[0] == '.'\n\t\t\t|| strchr(post_path, '/') == NULL) {\n\t\tsend_header(\"Content-type\", \"text/plain\");\n\t\tterminate_headers();\n\t\tprintf(\"No, my dear h4xxx0r :)\\nYou won\\'t do that :p\\n\");\n\t\treturn;\n\t}\n\tif(file_exists(post_path) > 0) {\n\t\tstruct blogpost post = make_blogpost(post_path);\n\t\tsend_header(\"Content-type\", \"text/html\");\n\t\tterminate_headers();\n\t\ttemplate_header();\n\t\ttemplate_post_single_entry(post);\n\t} else {\n\t\tsend_header(\"Content-type\", \"text/html\");\n\t\tsend_header(\"Status\", \"404 Not Found\");\n\t\tterminate_headers();\n\t\ttemplate_header();\n\t\ttemplate_error_404();\n\t}\n\ttemplate_footer();\n}", "target": 0}
{"code": "make_outerjoin_info(JOIN *join)\n{\n  DBUG_ENTER(\"make_outerjoin_info\");\n  JOIN_TAB *tab;\n  for (tab= first_linear_tab(join, WITH_BUSH_ROOTS, WITHOUT_CONST_TABLES);\n       tab; \n       tab= next_linear_tab(join, tab, WITH_BUSH_ROOTS))\n  {\n    if (tab->bush_children)\n    {\n      if (setup_sj_materialization_part1(tab))\n        DBUG_RETURN(TRUE);\n      tab->table->reginfo.join_tab= tab;\n    }\n  }\n  for (tab= first_linear_tab(join, WITH_BUSH_ROOTS, WITHOUT_CONST_TABLES);\n       tab; \n       tab= next_linear_tab(join, tab, WITH_BUSH_ROOTS))\n  {\n    TABLE *table= tab->table;\n    TABLE_LIST *tbl= table->pos_in_table_list;\n    TABLE_LIST *embedding= tbl->embedding;\n    if (tbl->outer_join & (JOIN_TYPE_LEFT | JOIN_TYPE_RIGHT))\n    {\n      tab->last_inner= tab->first_inner= tab;\n      tab->on_expr_ref= &tbl->on_expr;\n      tab->cond_equal= tbl->cond_equal;\n      if (embedding && !embedding->is_active_sjm())\n        tab->first_upper= embedding->nested_join->first_nested;\n    }\n    else if (!embedding)\n      tab->table->reginfo.not_exists_optimize= 0;\n    for ( ; embedding ; embedding= embedding->embedding)\n    {\n      if (embedding->is_active_sjm())\n      {\n        break;\n      }\n      if (!(embedding->on_expr && embedding->outer_join))\n      {\n        tab->table->reginfo.not_exists_optimize= 0;\n        continue;\n      }\n      NESTED_JOIN *nested_join= embedding->nested_join;\n      if (!nested_join->counter)\n      {\n        nested_join->first_nested= tab;\n        tab->on_expr_ref= &embedding->on_expr;\n        tab->cond_equal= tbl->cond_equal;\n        if (embedding->embedding)\n          tab->first_upper= embedding->embedding->nested_join->first_nested;\n      }\n      if (!tab->first_inner)  \n        tab->first_inner= nested_join->first_nested;\n      if (++nested_join->counter < nested_join->n_tables)\n        break;\n      nested_join->first_nested->last_inner= tab;\n    }\n  }\n  DBUG_RETURN(FALSE);\n}", "target": 0}
{"code": "static void youngcollection (lua_State *L, global_State *g) {\n  GCObject **psurvival;  \n  lua_assert(g->gcstate == GCSpropagate);\n  markold(g, g->survival, g->reallyold);\n  markold(g, g->finobj, g->finobjrold);\n  atomic(L);\n  psurvival = sweepgen(L, g, &g->allgc, g->survival);\n  sweepgen(L, g, psurvival, g->reallyold);\n  g->reallyold = g->old;\n  g->old = *psurvival;  \n  g->survival = g->allgc;  \n  psurvival = sweepgen(L, g, &g->finobj, g->finobjsur);\n  sweepgen(L, g, psurvival, g->finobjrold);\n  g->finobjrold = g->finobjold;\n  g->finobjold = *psurvival;  \n  g->finobjsur = g->finobj;  \n  sweepgen(L, g, &g->tobefnz, NULL);\n  finishgencycle(L, g);\n}", "target": 1}
{"code": "static void buffer_pipe_buf_get(struct pipe_inode_info *pipe,\n\t\t\t\tstruct pipe_buffer *buf)\n{\n\tstruct buffer_ref *ref = (struct buffer_ref *)buf->private;\n\tref->ref++;\n}", "target": 1}
{"code": "bool SharedMemory::Create(const SharedMemoryCreateOptions& options) {\n  DCHECK_EQ(-1, mapped_file_);\n  if (options.size == 0) return false;\n  if (options.size > static_cast<size_t>(std::numeric_limits<int>::max()))\n    return false;\n  base::ThreadRestrictions::ScopedAllowIO allow_io;\n  FILE *fp;\n  bool fix_size = true;\n  FilePath path;\n  if (options.name == NULL || options.name->empty()) {\n    DCHECK(!options.open_existing);\n    fp = file_util::CreateAndOpenTemporaryShmemFile(&path, options.executable);\n    if (fp) {\n      if (unlink(path.value().c_str()))\n        PLOG(WARNING) << \"unlink\";\n    }\n  } else {\n     if (!FilePathForMemoryName(*options.name, &path))\n       return false;\n    fp = file_util::OpenFile(path, \"w+x\");\n    if (fp == NULL && options.open_existing) {\n      fp = file_util::OpenFile(path, \"a+\");\n       fix_size = false;\n     }\n   }\n   if (fp && fix_size) {\n    struct stat stat;\n    if (fstat(fileno(fp), &stat) != 0) {\n      file_util::CloseFile(fp);\n      return false;\n    }\n    const size_t current_size = stat.st_size;\n    if (current_size != options.size) {\n      if (HANDLE_EINTR(ftruncate(fileno(fp), options.size)) != 0) {\n        file_util::CloseFile(fp);\n        return false;\n      }\n    }\n    requested_size_ = options.size;\n  }\n  if (fp == NULL) {\n#if !defined(OS_MACOSX)\n    PLOG(ERROR) << \"Creating shared memory in \" << path.value() << \" failed\";\n    FilePath dir = path.DirName();\n    if (access(dir.value().c_str(), W_OK | X_OK) < 0) {\n      PLOG(ERROR) << \"Unable to access(W_OK|X_OK) \" << dir.value();\n      if (dir.value() == \"/dev/shm\") {\n        LOG(FATAL) << \"This is frequently caused by incorrect permissions on \"\n                   << \"/dev/shm.  Try 'sudo chmod 1777 /dev/shm' to fix.\";\n      }\n    }\n#else\n    PLOG(ERROR) << \"Creating shared memory in \" << path.value() << \" failed\";\n#endif\n    return false;\n  }\n  return PrepareMapFile(fp);\n}", "target": 1}
{"code": "XkbExtensionInit(void)\n{\n    ExtensionEntry *extEntry;\n    if ((extEntry = AddExtension(XkbName, XkbNumberEvents, XkbNumberErrors,\n\t\t\t\t ProcXkbDispatch, SProcXkbDispatch,\n\t\t\t\t NULL, StandardMinorOpcode))) {\n\tXkbReqCode = (unsigned char)extEntry->base;\n\tXkbEventBase = (unsigned char)extEntry->eventBase;\n\tXkbErrorBase = (unsigned char)extEntry->errorBase;\n\tXkbKeyboardErrorCode = XkbErrorBase+XkbKeyboard;\n\tRT_XKBCLIENT = CreateNewResourceType(XkbClientGone);\n    }\n    return;\n}", "target": 0}
{"code": "ZEND_API void zend_object_store_ctor_failed(zval *zobject TSRMLS_DC)\n{\n\tzend_object_handle handle = Z_OBJ_HANDLE_P(zobject);\n\tzend_object_store_bucket *obj_bucket = &EG(objects_store).object_buckets[handle];\n\tobj_bucket->bucket.obj.handlers = Z_OBJ_HT_P(zobject);;\n\tobj_bucket->destructor_called = 1;\n}", "target": 1}
{"code": "static ssize_t driver_override_show(struct device *_dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct amba_device *dev = to_amba_device(_dev);\n\treturn sprintf(buf, \"%s\\n\", dev->driver_override);\n}", "target": 1}
{"code": "static struct property *dlpar_parse_cc_property(struct cc_workarea *ccwa)\n{\n\tstruct property *prop;\n\tchar *name;\n\tchar *value;\n\tprop = kzalloc(sizeof(*prop), GFP_KERNEL);\n\tif (!prop)\n\t\treturn NULL;\n\tname = (char *)ccwa + be32_to_cpu(ccwa->name_offset);\n\tprop->name = kstrdup(name, GFP_KERNEL);\n\tprop->length = be32_to_cpu(ccwa->prop_length);\n\tvalue = (char *)ccwa + be32_to_cpu(ccwa->prop_offset);\n\tprop->value = kmemdup(value, prop->length, GFP_KERNEL);\n\tif (!prop->value) {\n\t\tdlpar_free_cc_property(prop);\n\t\treturn NULL;\n\t}\n\treturn prop;\n}", "target": 1}
{"code": "nwfilterConnectNumOfNWFilters(virConnectPtr conn)\n{\n    if (virConnectNumOfNWFiltersEnsureACL(conn) < 0)\n        return -1;\n    return virNWFilterObjListNumOfNWFilters(driver->nwfilters, conn,\n                                        virConnectNumOfNWFiltersCheckACL);\n}", "target": 1}
{"code": "static inline pgd_t *pgd_alloc(struct mm_struct *mm)\n{\n\tspin_lock_init(&mm->context.list_lock);\n\tINIT_LIST_HEAD(&mm->context.pgtable_list);\n\tINIT_LIST_HEAD(&mm->context.gmap_list);\n\treturn (pgd_t *) crst_table_alloc(mm);\n}", "target": 1}
{"code": "AP4_AvccAtom::AP4_AvccAtom(AP4_UI32 size, const AP4_UI08* payload) :\n    AP4_Atom(AP4_ATOM_TYPE_AVCC, size)\n{\n    unsigned int payload_size = size-AP4_ATOM_HEADER_SIZE;\n    m_RawBytes.SetData(payload, payload_size);\n    m_ConfigurationVersion = payload[0];\n    m_Profile              = payload[1];\n    m_ProfileCompatibility = payload[2];\n    m_Level                = payload[3];\n    m_NaluLengthSize       = 1+(payload[4]&3);\n    AP4_UI08 num_seq_params = payload[5]&31;\n    m_SequenceParameters.EnsureCapacity(num_seq_params);\n    unsigned int cursor = 6;\n    for (unsigned int i=0; i<num_seq_params; i++) {\n        m_SequenceParameters.Append(AP4_DataBuffer());\n        AP4_UI16 param_length = AP4_BytesToInt16BE(&payload[cursor]);\n        m_SequenceParameters[i].SetData(&payload[cursor]+2, param_length);\n        cursor += 2+param_length;\n    }\n    AP4_UI08 num_pic_params = payload[cursor++];\n    m_PictureParameters.EnsureCapacity(num_pic_params);\n    for (unsigned int i=0; i<num_pic_params; i++) {\n        m_PictureParameters.Append(AP4_DataBuffer());\n        AP4_UI16 param_length = AP4_BytesToInt16BE(&payload[cursor]);\n        m_PictureParameters[i].SetData(&payload[cursor]+2, param_length);\n        cursor += 2+param_length;\n    }\n}", "target": 1}
{"code": "translate_hex_string(char *s, char *saved_orphan)\n{\n  int c1 = *saved_orphan;\n  char *start = s;\n  char *t = s;\n  for (; *s; s++) {\n    if (isspace(*s))\n      continue;\n    if (c1) {\n      *t++ = (hexval(c1) << 4) + hexval(*s);\n      c1 = 0;\n    } else\n      c1 = *s;\n  }\n  *saved_orphan = c1;\n  return t - start;\n}", "target": 1}
{"code": "static uint8_t nvme_sq_empty(NvmeSQueue *sq)\n{\n    return sq->head == sq->tail;\n}", "target": 0}
{"code": "void flush_tlb_page(struct vm_area_struct *vma, unsigned long start)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpreempt_disable();\n\tif (current->active_mm == mm) {\n\t\tif (current->mm)\n\t\t\t__flush_tlb_one(start);\n\t\telse\n\t\t\tleave_mm(smp_processor_id());\n\t}\n\tif (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) < nr_cpu_ids)\n\t\tflush_tlb_others(mm_cpumask(mm), mm, start, 0UL);\n\tpreempt_enable();\n}", "target": 1}
{"code": "ZEND_API int zend_declare_property_double(zend_class_entry *ce, const char *name, int name_length, double value, int access_type TSRMLS_DC) \n{\n\tzval *property;\n\tif (ce->type & ZEND_INTERNAL_CLASS) {\n\t\tALLOC_PERMANENT_ZVAL(property);\n\t} else {\n\t\tALLOC_ZVAL(property);\n\t}\n\tINIT_PZVAL(property);\n\tZVAL_DOUBLE(property, value);\n\treturn zend_declare_property(ce, name, name_length, property, access_type TSRMLS_CC);\n}", "target": 0}
{"code": "static __init int seqgen_init(void)\n{\n\trekey_seq_generator(NULL);\n\treturn 0;\n}", "target": 1}
{"code": "static int vp8_lossy_decode_frame(AVCodecContext *avctx, AVFrame *p,\n                                  int *got_frame, uint8_t *data_start,\n                                  unsigned int data_size)\n{\n    WebPContext *s = avctx->priv_data;\n    AVPacket pkt;\n    int ret;\n    if (!s->initialized) {\n        ff_vp8_decode_init(avctx);\n        s->initialized = 1;\n        if (s->has_alpha)\n            avctx->pix_fmt = AV_PIX_FMT_YUVA420P;\n    }\n    s->lossless = 0;\n    if (data_size > INT_MAX) {\n        av_log(avctx, AV_LOG_ERROR, \"unsupported chunk size\\n\");\n        return AVERROR_PATCHWELCOME;\n    }\n    av_init_packet(&pkt);\n    pkt.data = data_start;\n    pkt.size = data_size;\n    ret = ff_vp8_decode_frame(avctx, p, got_frame, &pkt);\n    if (ret < 0)\n        return ret;\n    update_canvas_size(avctx, avctx->width, avctx->height);\n    if (s->has_alpha) {\n        ret = vp8_lossy_decode_alpha(avctx, p, s->alpha_data,\n                                     s->alpha_data_size);\n        if (ret < 0)\n            return ret;\n    }\n    return ret;\n}", "target": 1}
{"code": "xfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error = 0;\n\tif (!acl)\n\t\tgoto set_acl;\n\terror = -E2BIG;\n\tif (acl->a_count > XFS_ACL_MAX_ENTRIES(XFS_M(inode->i_sb)))\n\t\treturn error;\n\tif (type == ACL_TYPE_ACCESS) {\n\t\tumode_t mode = inode->i_mode;\n\t\terror = posix_acl_equiv_mode(acl, &mode);\n\t\tif (error <= 0) {\n\t\t\tacl = NULL;\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t}\n\t\terror = xfs_set_mode(inode, mode);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n set_acl:\n\treturn __xfs_set_acl(inode, type, acl);\n}", "target": 1}
{"code": "cib_notify_client(gpointer key, gpointer value, gpointer user_data)\n{\n    const char *type = NULL;\n    gboolean do_send = FALSE;\n    cib_client_t *client = value;\n    xmlNode *update_msg = user_data;\n    CRM_CHECK(client != NULL, return TRUE);\n    CRM_CHECK(update_msg != NULL, return TRUE);\n    if (client->ipc == NULL) {\n        crm_warn(\"Skipping client with NULL channel\");\n        return FALSE;\n    }\n    type = crm_element_value(update_msg, F_SUBTYPE);\n    CRM_LOG_ASSERT(type != NULL);\n    if (client->diffs && safe_str_eq(type, T_CIB_DIFF_NOTIFY)) {\n        do_send = TRUE;\n    } else if (client->replace && safe_str_eq(type, T_CIB_REPLACE_NOTIFY)) {\n        do_send = TRUE;\n    } else if (client->confirmations && safe_str_eq(type, T_CIB_UPDATE_CONFIRM)) {\n        do_send = TRUE;\n    } else if (client->pre_notify && safe_str_eq(type, T_CIB_PRE_NOTIFY)) {\n        do_send = TRUE;\n    } else if (client->post_notify && safe_str_eq(type, T_CIB_POST_NOTIFY)) {\n        do_send = TRUE;\n    }\n    if (do_send) {\n        if (client->ipc) {\n            if(crm_ipcs_send(client->ipc, 0, update_msg, TRUE) == FALSE) {\n                crm_warn(\"Notification of client %s/%s failed\", client->name, client->id);\n            }\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        } else if (client->session) {\n            crm_debug(\"Sent %s notification to client %s/%s\", type, client->name, client->id);\n            crm_send_remote_msg(client->session, update_msg, client->encrypted);\n#endif\n        } else {\n            crm_err(\"Unknown transport for %s\", client->name);\n        }\n    }\n    return FALSE;\n}", "target": 1}
{"code": "http_DissectRequest(struct sess *sp)\n{\n\tstruct http_conn *htc;\n\tstruct http *hp;\n\tuint16_t retval;\n\tCHECK_OBJ_NOTNULL(sp, SESS_MAGIC);\n\thtc = sp->htc;\n\tCHECK_OBJ_NOTNULL(htc, HTTP_CONN_MAGIC);\n\thp = sp->http;\n\tCHECK_OBJ_NOTNULL(hp, HTTP_MAGIC);\n\thp->logtag = HTTP_Rx;\n\tretval = http_splitline(sp->wrk, sp->fd, hp, htc,\n\t    HTTP_HDR_REQ, HTTP_HDR_URL, HTTP_HDR_PROTO);\n\tif (retval != 0) {\n\t\tWSPR(sp, SLT_HttpGarbage, htc->rxbuf);\n\t\treturn (retval);\n\t}\n\thttp_ProtoVer(hp);\n\tretval = htc_request_check_host_hdr(hp);\n\tif (retval != 0) {\n\t\tWSP(sp, SLT_Error, \"Duplicated Host header\");\n\t\treturn (retval);\n\t}\n\treturn (retval);\n}", "target": 1}
{"code": "static void __skb_complete_tx_timestamp(struct sk_buff *skb,\n\t\t\t\t\tstruct sock *sk,\n\t\t\t\t\tint tstype)\n{\n\tstruct sock_exterr_skb *serr;\n\tint err;\n\tserr = SKB_EXT_ERR(skb);\n\tmemset(serr, 0, sizeof(*serr));\n\tserr->ee.ee_errno = ENOMSG;\n\tserr->ee.ee_origin = SO_EE_ORIGIN_TIMESTAMPING;\n\tserr->ee.ee_info = tstype;\n\tif (sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID) {\n\t\tserr->ee.ee_data = skb_shinfo(skb)->tskey;\n\t\tif (sk->sk_protocol == IPPROTO_TCP &&\n\t\t    sk->sk_type == SOCK_STREAM)\n\t\t\tserr->ee.ee_data -= sk->sk_tskey;\n\t}\n\terr = sock_queue_err_skb(sk, skb);\n\tif (err)\n\t\tkfree_skb(skb);", "target": 1}
{"code": "static int handle_pte_fault(struct mm_struct *mm,\n\t\t     struct vm_area_struct *vma, unsigned long address,\n\t\t     pte_t *pte, pmd_t *pmd, unsigned int flags)\n{\n\tpte_t entry;\n\tspinlock_t *ptl;\n\tentry = *pte;\n\tbarrier();\n\tif (!pte_present(entry)) {\n\t\tif (pte_none(entry)) {\n\t\t\tif (vma->vm_ops) {\n\t\t\t\tif (likely(vma->vm_ops->fault))\n\t\t\t\t\treturn do_fault(mm, vma, address, pte,\n\t\t\t\t\t\t\tpmd, flags, entry);\n\t\t\t}\n\t\t\treturn do_anonymous_page(mm, vma, address,\n\t\t\t\t\t\t pte, pmd, flags);\n\t\t}\n\t\treturn do_swap_page(mm, vma, address,\n\t\t\t\t\tpte, pmd, flags, entry);\n\t}\n\tif (pte_protnone(entry))\n\t\treturn do_numa_page(mm, vma, address, entry, pte, pmd);\n\tptl = pte_lockptr(mm, pmd);\n\tspin_lock(ptl);\n\tif (unlikely(!pte_same(*pte, entry)))\n\t\tgoto unlock;\n\tif (flags & FAULT_FLAG_WRITE) {\n\t\tif (!pte_write(entry))\n\t\t\treturn do_wp_page(mm, vma, address,\n\t\t\t\t\tpte, pmd, ptl, entry);\n\t\tentry = pte_mkdirty(entry);\n\t}\n\tentry = pte_mkyoung(entry);\n\tif (ptep_set_access_flags(vma, address, pte, entry, flags & FAULT_FLAG_WRITE)) {\n\t\tupdate_mmu_cache(vma, address, pte);\n\t} else {\n\t\tif (flags & FAULT_FLAG_WRITE)\n\t\t\tflush_tlb_fix_spurious_fault(vma, address);\n\t}\nunlock:\n\tpte_unmap_unlock(pte, ptl);\n\treturn 0;\n}", "target": 1}
{"code": "parse_emph1(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size, uint8_t c)\n{\n\tsize_t i = 0, len;\n\tstruct buf *work = 0;\n\tint r;\n\tif (size > 1 && data[0] == c && data[1] == c) i = 1;\n\twhile (i < size) {\n\t\tlen = find_emph_char(data + i, size - i, c);\n\t\tif (!len) return 0;\n\t\ti += len;\n\t\tif (i >= size) return 0;\n\t\tif (data[i] == c && !_isspace(data[i - 1])) {\n\t\t\tif (rndr->ext_flags & MKDEXT_NO_INTRA_EMPHASIS) {\n\t\t\t\tif (i + i < size && _isalnum(data[i + 1]))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twork = rndr_newbuf(rndr, BUFFER_SPAN);\n\t\t\tparse_inline(work, rndr, data, i);\n\t\t\tif (rndr->ext_flags & MKDEXT_UNDERLINE && c == '_')\n\t\t\t\tr = rndr->cb.underline(ob, work, rndr->opaque);\n\t\t\telse\n\t\t\t\tr = rndr->cb.emphasis(ob, work, rndr->opaque);\n\t\t\trndr_popbuf(rndr, BUFFER_SPAN);\n\t\t\treturn r ? i + 1 : 0;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "snd_seq_oss_synth_make_info(struct seq_oss_devinfo *dp, int dev, struct synth_info *inf)\n{\n\tstruct seq_oss_synth *rec;\n\tif (dp->synths[dev].is_midi) {\n\t\tstruct midi_info minf;\n\t\tsnd_seq_oss_midi_make_info(dp, dp->synths[dev].midi_mapped, &minf);\n\t\tinf->synth_type = SYNTH_TYPE_MIDI;\n\t\tinf->synth_subtype = 0;\n\t\tinf->nr_voices = 16;\n\t\tinf->device = dev;\n\t\tstrlcpy(inf->name, minf.name, sizeof(inf->name));\n\t} else {\n\t\tif ((rec = get_synthdev(dp, dev)) == NULL)\n\t\t\treturn -ENXIO;\n\t\tinf->synth_type = rec->synth_type;\n\t\tinf->synth_subtype = rec->synth_subtype;\n\t\tinf->nr_voices = rec->nr_voices;\n\t\tinf->device = dev;\n\t\tstrlcpy(inf->name, rec->name, sizeof(inf->name));\n\t\tsnd_use_lock_free(&rec->use_lock);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int setup_config(int type)\n{\n\tint rv;\n\trv = read_config(cl.configfile, type);\n\tif (rv < 0)\n\t\tgoto out;\n\tif (is_auth_req()) {\n\t\trv = read_authkey();\n\t\tif (rv < 0)\n\t\t\tgoto out;\n#if HAVE_LIBGCRYPT\n\t\tif (!gcry_check_version(NULL)) {\n\t\t\tlog_error(\"gcry_check_version\");\n\t\t\trv = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tgcry_control(GCRYCTL_DISABLE_SECMEM, 0);\n\t\tgcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0);\n#endif\n\t}\n\tif (cl.type == DAEMON && cl.site[0]) {\n\t\tif (!find_site_by_name(cl.site, &local, 1)) {\n\t\t\tlog_error(\"Cannot find \\\"%s\\\" in the configuration.\",\n\t\t\t\t\tcl.site);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlocal->local = 1;\n\t} else\n\t\tfind_myself(NULL, type == CLIENT || type == GEOSTORE);\n\trv = check_config(type);\n\tif (rv < 0)\n\t\tgoto out;\n\tif (!cl.lockfile[0]) {\n\t\tsnprintf(cl.lockfile, sizeof(cl.lockfile)-1,\n\t\t\t\t\"%s/%s.pid\", BOOTH_RUN_DIR, booth_conf->name);\n\t}\nout:\n\treturn rv;\n}", "target": 1}
{"code": "void Cache::dumpLRULists(bool includeLive) const\n{\n    printf(\"LRU-SP lists in eviction order (Kilobytes decoded, Kilobytes encoded, Access count, Referenced):\\n\");\n    int size = m_allResources.size();\n    for (int i = size - 1; i >= 0; i--) {\n        printf(\"\\n\\nList %d: \", i);\n        CachedResource* current = m_allResources[i].m_tail;\n        while (current) {\n            CachedResource* prev = current->m_prevInAllResourcesList;\n            if (includeLive || !current->referenced())\n                printf(\"(%.1fK, %.1fK, %uA, %dR); \", current->decodedSize() / 1024.0f, current->encodedSize() / 1024.0f, current->accessCount(), current->referenced());\n            current = prev;\n        }\n    }\n}", "target": 0}
{"code": "static void cma_leave_mc_groups(struct rdma_id_private *id_priv)\n{\n\tstruct cma_multicast *mc;\n\twhile (!list_empty(&id_priv->mc_list)) {\n\t\tmc = list_first_entry(&id_priv->mc_list, struct cma_multicast,\n\t\t\t\t      list);\n\t\tlist_del(&mc->list);\n\t\tdestroy_mc(id_priv, mc);\n\t}\n}", "target": 0}
{"code": "call_qftf_func(qf_list_T *qfl, int qf_winid, long start_idx, long end_idx)\n{\n    callback_T\t*cb = &qftf_cb;\n    list_T\t*qftf_list = NULL;\n    if (qfl->qf_qftf_cb.cb_name != NULL)\n\tcb = &qfl->qf_qftf_cb;\n    if (cb->cb_name != NULL)\n    {\n\ttypval_T\targs[1];\n\tdict_T\t\t*d;\n\ttypval_T\trettv;\n\tif ((d = dict_alloc_lock(VAR_FIXED)) == NULL)\n\t    return NULL;\n\tdict_add_number(d, \"quickfix\", (long)IS_QF_LIST(qfl));\n\tdict_add_number(d, \"winid\", (long)qf_winid);\n\tdict_add_number(d, \"id\", (long)qfl->qf_id);\n\tdict_add_number(d, \"start_idx\", start_idx);\n\tdict_add_number(d, \"end_idx\", end_idx);\n\t++d->dv_refcount;\n\targs[0].v_type = VAR_DICT;\n\targs[0].vval.v_dict = d;\n\tqftf_list = NULL;\n\tif (call_callback(cb, 0, &rettv, 1, args) != FAIL)\n\t{\n\t    if (rettv.v_type == VAR_LIST)\n\t    {\n\t\tqftf_list = rettv.vval.v_list;\n\t\tqftf_list->lv_refcount++;\n\t    }\n\t    clear_tv(&rettv);\n\t}\n\tdict_unref(d);\n    }\n    return qftf_list;\n}", "target": 1}
{"code": "void pdu_submit(V9fsPDU *pdu, P9MsgHeader *hdr)\n{\n    Coroutine *co;\n    CoroutineEntry *handler;\n    V9fsState *s = pdu->s;\n    pdu->size = le32_to_cpu(hdr->size_le);\n    pdu->id = hdr->id;\n    pdu->tag = le16_to_cpu(hdr->tag_le);\n    if (pdu->id >= ARRAY_SIZE(pdu_co_handlers) ||\n        (pdu_co_handlers[pdu->id] == NULL)) {\n        handler = v9fs_op_not_supp;\n    } else if (is_ro_export(&s->ctx) && !is_read_only_op(pdu)) {\n        handler = v9fs_fs_ro;\n    } else {\n        handler = pdu_co_handlers[pdu->id];\n    }\n    qemu_co_queue_init(&pdu->complete);\n    co = qemu_coroutine_create(handler, pdu);\n    qemu_coroutine_enter(co);\n}", "target": 0}
{"code": "static int set_msr_mce(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tu64 mcg_cap = vcpu->arch.mcg_cap;\n\tunsigned bank_num = mcg_cap & 0xff;\n\tswitch (msr) {\n\tcase MSR_IA32_MCG_STATUS:\n\t\tvcpu->arch.mcg_status = data;\n\t\tbreak;\n\tcase MSR_IA32_MCG_CTL:\n\t\tif (!(mcg_cap & MCG_CTL_P))\n\t\t\treturn 1;\n\t\tif (data != 0 && data != ~(u64)0)\n\t\t\treturn -1;\n\t\tvcpu->arch.mcg_ctl = data;\n\t\tbreak;\n\tdefault:\n\t\tif (msr >= MSR_IA32_MC0_CTL &&\n\t\t    msr < MSR_IA32_MCx_CTL(bank_num)) {\n\t\t\tu32 offset = msr - MSR_IA32_MC0_CTL;\n\t\t\tif ((offset & 0x3) == 0 &&\n\t\t\t    data != 0 && (data | (1 << 10)) != ~(u64)0)\n\t\t\t\treturn -1;\n\t\t\tvcpu->arch.mce_banks[offset] = data;\n\t\t\tbreak;\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "ProcListFonts(ClientPtr client)\n{\n    REQUEST(xListFontsReq);\n    REQUEST_FIXED_SIZE(xListFontsReq, stuff->nbytes);\n    return ListFonts(client, (unsigned char *) &stuff[1], stuff->nbytes,\n                     stuff->maxNames);\n}", "target": 0}
{"code": "struct mapped_device *dm_get_from_kobject(struct kobject *kobj)\n{\n\tstruct mapped_device *md;\n\tmd = container_of(kobj, struct mapped_device, kobj_holder.kobj);\n\tif (test_bit(DMF_FREEING, &md->flags) ||\n\t    dm_deleting_md(md))\n\t\treturn NULL;\n\tdm_get(md);\n\treturn md;\n}", "target": 1}
{"code": "int perf_config(config_fn_t fn, void *data)\n{\n\tint ret = 0, found = 0;\n\tchar *repo_config = NULL;\n\tconst char *home = NULL;\n\tif (config_exclusive_filename)\n\t\treturn perf_config_from_file(fn, config_exclusive_filename, data);\n\tif (perf_config_system() && !access(perf_etc_perfconfig(), R_OK)) {\n\t\tret += perf_config_from_file(fn, perf_etc_perfconfig(),\n\t\t\t\t\t    data);\n\t\tfound += 1;\n\t}\n\thome = getenv(\"HOME\");\n\tif (perf_config_global() && home) {\n\t\tchar *user_config = strdup(mkpath(\"%s/.perfconfig\", home));\n\t\tif (!access(user_config, R_OK)) {\n\t\t\tret += perf_config_from_file(fn, user_config, data);\n\t\t\tfound += 1;\n\t\t}\n\t\tfree(user_config);\n\t}\n\trepo_config = perf_pathdup(\"config\");\n\tif (!access(repo_config, R_OK)) {\n\t\tret += perf_config_from_file(fn, repo_config, data);\n\t\tfound += 1;\n\t}\n\tfree(repo_config);\n\tif (found == 0)\n\t\treturn -1;\n\treturn ret;\n}", "target": 1}
{"code": "buflist_match(\n    regmatch_T\t*rmp,\n    buf_T\t*buf,\n    int\t\tignore_case)  \n{\n    char_u\t*match;\n    match = fname_match(rmp, buf->b_sfname, ignore_case);\n    if (match == NULL)\n\tmatch = fname_match(rmp, buf->b_ffname, ignore_case);\n    return match;\n}", "target": 1}
{"code": "    Image::UniquePtr ImageFactory::create(ImageType type)\n    {\n        BasicIo::UniquePtr io(new MemIo);\n        Image::UniquePtr image = create(type, std::move(io));\n        if (image.get() == 0) {\n            throw Error(kerUnsupportedImageType, static_cast<int>(type));\n        }\n        return image;\n    }", "target": 0}
{"code": "parse_string(xmlTextReaderPtr reader, char const *attr, char **result)\n{\n\txmlChar *xml_value;\n\tchar *tmp;\n\tif (attr == NULL)\n\t\txml_value = xmlTextReaderValue(reader);\n\telse\n\t\txml_value = xmlTextReaderGetAttribute(reader, BAD_CAST attr);\n\tif (xml_value == NULL)\n\t\treturn pr_val_err(\"RRDP file: Couldn't find %s from '%s'\",\n\t\t    (attr == NULL ? \"string content\" : \"xml attribute\"),\n\t\t    xmlTextReaderConstLocalName(reader));\n\ttmp = malloc(xmlStrlen(xml_value) + 1);\n\tif (tmp == NULL) {\n\t\txmlFree(xml_value);\n\t\treturn pr_enomem();\n\t}\n\tmemcpy(tmp, xml_value, xmlStrlen(xml_value));\n\ttmp[xmlStrlen(xml_value)] = '\\0';\n\txmlFree(xml_value);\n\t*result = tmp;\n\treturn 0;\n}", "target": 1}
{"code": "int jpc_pi_init(jpc_pi_t *pi)\n{\n\tint compno;\n\tint rlvlno;\n\tint prcno;\n\tjpc_picomp_t *picomp;\n\tjpc_pirlvl_t *pirlvl;\n\tint *prclyrno;\n\tpi->prgvolfirst = 0;\n\tpi->valid = 0;\n\tpi->pktno = -1;\n\tpi->pchgno = -1;\n\tpi->pchg = 0;\n\tfor (compno = 0, picomp = pi->picomps; compno < pi->numcomps;\n\t  ++compno, ++picomp) {\n\t\tfor (rlvlno = 0, pirlvl = picomp->pirlvls; rlvlno <\n\t\t  picomp->numrlvls; ++rlvlno, ++pirlvl) {\n\t\t\tfor (prcno = 0, prclyrno = pirlvl->prclyrnos;\n\t\t\t  prcno < pirlvl->numprcs; ++prcno, ++prclyrno) {\n\t\t\t\t*prclyrno = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static inline item* limited_get(char *key, size_t nkey, conn *c) {\n    item *it = item_get(key, nkey, c, DO_UPDATE);\n    if (it && it->refcount > IT_REFCOUNT_LIMIT) {\n        item_remove(it);\n        it = NULL;\n    }\n    return it;\n}", "target": 0}
{"code": "static int mb86a20s_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct mb86a20s_state *state = fe->demodulator_priv;\n\tint val;\n\t*status = 0;\n\tval = mb86a20s_readreg(state, 0x0a) & 0xf;\n\tif (val < 0)\n\t\treturn val;\n\tif (val >= 2)\n\t\t*status |= FE_HAS_SIGNAL;\n\tif (val >= 4)\n\t\t*status |= FE_HAS_CARRIER;\n\tif (val >= 5)\n\t\t*status |= FE_HAS_VITERBI;\n\tif (val >= 7)\n\t\t*status |= FE_HAS_SYNC;\n\tif (val >= 8)\t\t\t\t\n\t\t*status |= FE_HAS_LOCK;\n\tdev_dbg(&state->i2c->dev, \"%s: Status = 0x%02x (state = %d)\\n\",\n\t\t __func__, *status, val);\n\treturn val;\n}", "target": 1}
{"code": "l2tp_msgtype_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\tND_PRINT((ndo, \"%s\", tok2str(l2tp_msgtype2str, \"MSGTYPE-#%u\",\n\t    EXTRACT_16BITS(ptr))));\n}", "target": 1}
{"code": "static struct dentry *__d_obtain_alias(struct inode *inode, int disconnected)\n{\n\tstatic const struct qstr anonstring = QSTR_INIT(\"/\", 1);\n\tstruct dentry *tmp;\n\tstruct dentry *res;\n\tunsigned add_flags;\n\tif (!inode)\n\t\treturn ERR_PTR(-ESTALE);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\tres = d_find_any_alias(inode);\n\tif (res)\n\t\tgoto out_iput;\n\ttmp = __d_alloc(inode->i_sb, &anonstring);\n\tif (!tmp) {\n\t\tres = ERR_PTR(-ENOMEM);\n\t\tgoto out_iput;\n\t}\n\tspin_lock(&inode->i_lock);\n\tres = __d_find_any_alias(inode);\n\tif (res) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tdput(tmp);\n\t\tgoto out_iput;\n\t}\n\tadd_flags = d_flags_for_inode(inode);\n\tif (disconnected)\n\t\tadd_flags |= DCACHE_DISCONNECTED;\n\tspin_lock(&tmp->d_lock);\n\t__d_set_inode_and_type(tmp, inode, add_flags);\n\thlist_add_head(&tmp->d_u.d_alias, &inode->i_dentry);\n\thlist_bl_lock(&tmp->d_sb->s_anon);\n\thlist_bl_add_head(&tmp->d_hash, &tmp->d_sb->s_anon);\n\thlist_bl_unlock(&tmp->d_sb->s_anon);\n\tspin_unlock(&tmp->d_lock);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(tmp, inode);\n\treturn tmp;\n out_iput:\n\tif (res && !IS_ERR(res))\n\t\tsecurity_d_instantiate(res, inode);\n\tiput(inode);\n\treturn res;\n}", "target": 0}
{"code": "static int pppol2tp_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t       char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2tp_session *session;\n\tstruct l2tp_tunnel *tunnel;\n\tint val, len;\n\tint err;\n\tstruct pppol2tp_session *ps;\n\tif (level != SOL_PPPOL2TP)\n\t\treturn udp_prot.getsockopt(sk, level, optname, optval, optlen);\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tlen = min_t(unsigned int, len, sizeof(int));\n\tif (len < 0)\n\t\treturn -EINVAL;\n\terr = -ENOTCONN;\n\tif (sk->sk_user_data == NULL)\n\t\tgoto end;\n\terr = -EBADF;\n\tsession = pppol2tp_sock_to_session(sk);\n\tif (session == NULL)\n\t\tgoto end;\n\tps = l2tp_session_priv(session);\n\tif ((session->session_id == 0) &&\n\t    (session->peer_session_id == 0)) {\n\t\terr = -EBADF;\n\t\ttunnel = l2tp_sock_to_tunnel(ps->tunnel_sock);\n\t\tif (tunnel == NULL)\n\t\t\tgoto end_put_sess;\n\t\terr = pppol2tp_tunnel_getsockopt(sk, tunnel, optname, &val);\n\t\tsock_put(ps->tunnel_sock);\n\t} else\n\t\terr = pppol2tp_session_getsockopt(sk, session, optname, &val);\n\terr = -EFAULT;\n\tif (put_user(len, optlen))\n\t\tgoto end_put_sess;\n\tif (copy_to_user((void __user *) optval, &val, len))\n\t\tgoto end_put_sess;\n\terr = 0;\nend_put_sess:\n\tsock_put(sk);\nend:\n\treturn err;\n}", "target": 1}
{"code": "    void Encode(Key, const Value& value) {\n      AddToSummary(Key::key(), Key::Encode(value).size());\n    }", "target": 1}
{"code": "av_cold void ff_vc2enc_free_transforms(VC2TransformContext *s)\n{\n    av_freep(&s->buffer);\n}", "target": 1}
{"code": "static inline int unserialize_allowed_class(zend_string *class_name, HashTable *classes)\n{\n\tzend_string *lcname;\n\tint res;\n\tALLOCA_FLAG(use_heap)\n\tif(classes == NULL) {\n\t\treturn 1;\n\t}\n\tif(!zend_hash_num_elements(classes)) {\n\t\treturn 0;\n\t}\n\tSTR_ALLOCA_ALLOC(lcname, class_name->len, use_heap);\n\tzend_str_tolower_copy(lcname->val, class_name->val, class_name->len);\n\tres = zend_hash_exists(classes, lcname);\n\tSTR_ALLOCA_FREE(lcname, use_heap);\n\treturn res;\n}", "target": 0}
{"code": "char *BN_bn2dec(const BIGNUM *a)\n{\n    int i = 0, num, ok = 0;\n    char *buf = NULL;\n    char *p;\n    BIGNUM *t = NULL;\n    BN_ULONG *bn_data = NULL, *lp;\n    int bn_data_num;\n    i = BN_num_bits(a) * 3;\n    num = (i / 10 + i / 1000 + 1) + 1;\n    bn_data_num = num / BN_DEC_NUM + 1;\n    bn_data = OPENSSL_malloc(bn_data_num * sizeof(BN_ULONG));\n    buf = OPENSSL_malloc(num + 3);\n    if ((buf == NULL) || (bn_data == NULL)) {\n        BNerr(BN_F_BN_BN2DEC, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    if ((t = BN_dup(a)) == NULL)\n        goto err;\n#define BUF_REMAIN (num+3 - (size_t)(p - buf))\n    p = buf;\n    lp = bn_data;\n    if (BN_is_zero(t)) {\n        *(p++) = '0';\n        *(p++) = '\\0';\n    } else {\n        if (BN_is_negative(t))\n            *p++ = '-';\n        i = 0;\n        while (!BN_is_zero(t)) {\n            *lp = BN_div_word(t, BN_DEC_CONV);\n            if (*lp == (BN_ULONG)-1)\n                goto err;\n            lp++;\n            if (lp - bn_data >= bn_data_num)\n                goto err;\n        }\n        lp--;\n        BIO_snprintf(p, BUF_REMAIN, BN_DEC_FMT1, *lp);\n        while (*p)\n            p++;\n        while (lp != bn_data) {\n            lp--;\n            BIO_snprintf(p, BUF_REMAIN, BN_DEC_FMT2, *lp);\n            while (*p)\n                p++;\n        }\n    }\n    ok = 1;\n err:\n    if (bn_data != NULL)\n        OPENSSL_free(bn_data);\n    if (t != NULL)\n        BN_free(t);\n    if (!ok && buf) {\n        OPENSSL_free(buf);\n        buf = NULL;\n    }\n    return (buf);\n}", "target": 1}
{"code": "void reds_disable_mm_time(RedsState *reds)\n{\n    reds->mm_time_enabled = FALSE;\n}", "target": 0}
{"code": "int dccp_disconnect(struct sock *sk, int flags)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tint err = 0;\n\tconst int old_state = sk->sk_state;\n\tif (old_state != DCCP_CLOSED)\n\t\tdccp_set_state(sk, DCCP_CLOSED);\n\tif (old_state == DCCP_LISTEN) {\n\t\tinet_csk_listen_stop(sk);\n\t} else if (dccp_need_reset(old_state)) {\n\t\tdccp_send_reset(sk, DCCP_RESET_CODE_ABORTED);\n\t\tsk->sk_err = ECONNRESET;\n\t} else if (old_state == DCCP_REQUESTING)\n\t\tsk->sk_err = ECONNRESET;\n\tdccp_clear_xmit_timers(sk);\n\t__skb_queue_purge(&sk->sk_receive_queue);\n\t__skb_queue_purge(&sk->sk_write_queue);\n\tif (sk->sk_send_head != NULL) {\n\t\t__kfree_skb(sk->sk_send_head);\n\t\tsk->sk_send_head = NULL;\n\t}\n\tinet->inet_dport = 0;\n\tif (!(sk->sk_userlocks & SOCK_BINDADDR_LOCK))\n\t\tinet_reset_saddr(sk);\n\tsk->sk_shutdown = 0;\n\tsock_reset_flag(sk, SOCK_DONE);\n\ticsk->icsk_backoff = 0;\n\tinet_csk_delack_init(sk);\n\t__sk_dst_reset(sk);\n\tWARN_ON(inet->inet_num && !icsk->icsk_bind_hash);\n\tsk->sk_error_report(sk);\n\treturn err;\n}", "target": 1}
{"code": "static void HuffmanTree_cleanup(HuffmanTree* tree)\n{\n  free(tree->tree2d);\n  free(tree->tree1d);\n  free(tree->lengths);\n}", "target": 0}
{"code": "_g_file_remove_directory (GFile         *directory,\n\t\t\t  GCancellable  *cancellable,\n\t\t\t  GError       **error)\n{\n\tGFileEnumerator *enumerator;\n\tGFileInfo       *info;\n\tgboolean         error_occurred = FALSE;\n\tif (directory == NULL)\n\t\treturn TRUE;\n\tenumerator = g_file_enumerate_children (directory,\n\t\t\t\t\t        G_FILE_ATTRIBUTE_STANDARD_NAME \",\"\n\t\t\t\t\t        G_FILE_ATTRIBUTE_STANDARD_TYPE,\n\t\t\t\t\t        0,\n\t\t\t\t\t        cancellable,\n\t\t\t\t\t        error);\n\twhile (! error_occurred && (info = g_file_enumerator_next_file (enumerator, cancellable, error)) != NULL) {\n\t\tGFile *child;\n\t\tchild = g_file_get_child (directory, g_file_info_get_name (info));\n\t\tswitch (g_file_info_get_file_type (info)) {\n\t\tcase G_FILE_TYPE_DIRECTORY:\n\t\t\tif (! _g_file_remove_directory (child, cancellable, error))\n\t\t\t\terror_occurred = TRUE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (! g_file_delete (child, cancellable, error))\n\t\t\t\terror_occurred = TRUE;\n\t\t\tbreak;\n\t\t}\n\t\tg_object_unref (child);\n\t\tg_object_unref (info);\n\t}\n\tif (! error_occurred && ! g_file_delete (directory, cancellable, error))\n \t\terror_occurred = TRUE;\n\tg_object_unref (enumerator);\n\treturn ! error_occurred;\n}", "target": 1}
{"code": "static inline int sco_chan_add(struct sco_conn *conn, struct sock *sk, struct sock *parent)\n{\n\tint err = 0;\n\tsco_conn_lock(conn);\n\tif (conn->sk)\n\t\terr = -EBUSY;\n\telse\n\t\t__sco_chan_add(conn, sk, parent);\n\tsco_conn_unlock(conn);\n\treturn err;\n}", "target": 0}
{"code": "int read_record_hdr(int ifd, void *buffer, struct record_header *record_hdr,\n\t\t    struct file_header *file_hdr, int arch_64, int endian_mismatch,\n\t\t    int oneof, size_t b_size)\n{\n\tint rc;\n\tdo {\n\t\tif ((rc = sa_fread(ifd, buffer, (size_t) file_hdr->rec_size, SOFT_SIZE, oneof)) != 0)\n\t\t\treturn rc;\n\t\tif (remap_struct(rec_types_nr, file_hdr->rec_types_nr, buffer,\n\t\t\t\t file_hdr->rec_size, RECORD_HEADER_SIZE, b_size) < 0)\n\t\t\treturn 2;\n\t\tmemcpy(record_hdr, buffer, RECORD_HEADER_SIZE);\n\t\tif (endian_mismatch) {\n\t\t\tswap_struct(rec_types_nr, record_hdr, arch_64);\n\t\t}\n\t\tif ((record_hdr->record_type != R_COMMENT) && (record_hdr->record_type != R_RESTART) &&\n\t\t    record_hdr->extra_next && (skip_extra_struct(ifd, endian_mismatch, arch_64) < 0))\n\t\t\treturn 2;\n\t}\n\twhile (record_hdr->record_type == R_EXTRA);\n\treturn 0;\n}", "target": 0}
{"code": "static int xar_hash_check(int hash, const void * result, const void * expected)\n{\n    int len;\n    if (!result || !expected)\n        return 1;\n    switch (hash) {\n    case XAR_CKSUM_SHA1:\n        len = SHA1_HASH_SIZE;\n        break;\n    case XAR_CKSUM_MD5:\n        len = CLI_HASH_MD5;\n        break;\n    case XAR_CKSUM_OTHER:\n    case XAR_CKSUM_NONE:\n    default:\n        return 1;\n    }\n    return memcmp(result, expected, len);\n}", "target": 1}
{"code": "pidfile_write(const char *pid_file, int pid)\n{\n\tFILE *pidfile = NULL;\n\tint pidfd = creat(pid_file, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (pidfd != -1) pidfile = fdopen(pidfd, \"w\");\n\tif (!pidfile) {\n\t\tlog_message(LOG_INFO, \"pidfile_write : Cannot open %s pidfile\",\n\t\t       pid_file);\n\t\treturn 0;\n\t}\n\tfprintf(pidfile, \"%d\\n\", pid);\n\tfclose(pidfile);\n\treturn 1;\n}", "target": 1}
{"code": "MemoryRegion *memory_map(struct uc_struct *uc, hwaddr begin, size_t size, uint32_t perms)\n{\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n    memory_region_init_ram(uc, ram, size, perms);\n    if (ram->addr == -1) {\n        return NULL;\n    }\n    memory_region_add_subregion(uc->system_memory, begin, ram);\n    if (uc->cpu) {\n        tlb_flush(uc->cpu);\n    }\n    return ram;\n}", "target": 1}
{"code": "static ssize_t set_bank(struct device *s, struct device_attribute *attr,\n\t\t\tconst char *buf, size_t size)\n{\n\tu64 new;\n\tif (kstrtou64(buf, 0, &new) < 0)\n\t\treturn -EINVAL;\n\tattr_to_bank(attr)->ctl = new;\n\tmce_restart();\n\treturn size;\n}", "target": 0}
{"code": "int ext4_group_add(struct super_block *sb, struct ext4_new_group_data *input)\n{\n\tstruct ext4_new_flex_group_data flex_gd;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tint reserved_gdb = ext4_bg_has_super(sb, input->group) ?\n\t\tle16_to_cpu(es->s_reserved_gdt_blocks) : 0;\n\tstruct inode *inode = NULL;\n\tint gdb_off, gdb_num;\n\tint err;\n\t__u16 bg_flags = 0;\n\tgdb_num = input->group / EXT4_DESC_PER_BLOCK(sb);\n\tgdb_off = input->group % EXT4_DESC_PER_BLOCK(sb);\n\tif (gdb_off == 0 && !EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER)) {\n\t\text4_warning(sb, \"Can't resize non-sparse filesystem further\");\n\t\treturn -EPERM;\n\t}\n\tif (ext4_blocks_count(es) + input->blocks_count <\n\t    ext4_blocks_count(es)) {\n\t\text4_warning(sb, \"blocks_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\tif (le32_to_cpu(es->s_inodes_count) + EXT4_INODES_PER_GROUP(sb) <\n\t    le32_to_cpu(es->s_inodes_count)) {\n\t\text4_warning(sb, \"inodes_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\tif (reserved_gdb || gdb_off == 0) {\n\t\tif (!EXT4_HAS_COMPAT_FEATURE(sb,\n\t\t\t\t\t     EXT4_FEATURE_COMPAT_RESIZE_INODE)\n\t\t    || !le16_to_cpu(es->s_reserved_gdt_blocks)) {\n\t\t\text4_warning(sb,\n\t\t\t\t     \"No reserved GDT blocks, can't resize\");\n\t\t\treturn -EPERM;\n\t\t}\n\t\tinode = ext4_iget(sb, EXT4_RESIZE_INO);\n\t\tif (IS_ERR(inode)) {\n\t\t\text4_warning(sb, \"Error opening resize inode\");\n\t\t\treturn PTR_ERR(inode);\n\t\t}\n\t}\n\terr = verify_group_input(sb, input);\n\tif (err)\n\t\tgoto out;\n\tflex_gd.count = 1;\n\tflex_gd.groups = input;\n\tflex_gd.bg_flags = &bg_flags;\n\terr = ext4_flex_group_add(sb, inode, &flex_gd);\nout:\n\tiput(inode);\n\treturn err;\n} ", "target": 0}
{"code": "static void __init taa_select_mitigation(void)\n{\n\tu64 ia32_cap;\n\tif (!boot_cpu_has_bug(X86_BUG_TAA)) {\n\t\ttaa_mitigation = TAA_MITIGATION_OFF;\n\t\treturn;\n\t}\n\tif (!boot_cpu_has(X86_FEATURE_RTM)) {\n\t\ttaa_mitigation = TAA_MITIGATION_TSX_DISABLED;\n\t\tgoto out;\n\t}\n\tif (cpu_mitigations_off()) {\n\t\ttaa_mitigation = TAA_MITIGATION_OFF;\n\t\treturn;\n\t}\n\tif (taa_mitigation == TAA_MITIGATION_OFF &&\n\t    mds_mitigation == MDS_MITIGATION_OFF)\n\t\tgoto out;\n\tif (boot_cpu_has(X86_FEATURE_MD_CLEAR))\n\t\ttaa_mitigation = TAA_MITIGATION_VERW;\n\telse\n\t\ttaa_mitigation = TAA_MITIGATION_UCODE_NEEDED;\n\tia32_cap = x86_read_arch_cap_msr();\n\tif ( (ia32_cap & ARCH_CAP_MDS_NO) &&\n\t    !(ia32_cap & ARCH_CAP_TSX_CTRL_MSR))\n\t\ttaa_mitigation = TAA_MITIGATION_UCODE_NEEDED;\n\tstatic_branch_enable(&mds_user_clear);\n\tif (taa_nosmt || cpu_mitigations_auto_nosmt())\n\t\tcpu_smt_disable(false);\n\tif (mds_mitigation == MDS_MITIGATION_OFF &&\n\t    boot_cpu_has_bug(X86_BUG_MDS)) {\n\t\tmds_mitigation = MDS_MITIGATION_FULL;\n\t\tmds_select_mitigation();\n\t}\nout:\n\tpr_info(\"%s\\n\", taa_strings[taa_mitigation]);\n}", "target": 0}
{"code": "ctnetlink_parse_tuple_filter(const struct nlattr * const cda[],\n\t\t\t      struct nf_conntrack_tuple *tuple, u32 type,\n\t\t\t      u_int8_t l3num, struct nf_conntrack_zone *zone,\n\t\t\t      u_int32_t flags)\n{\n\tstruct nlattr *tb[CTA_TUPLE_MAX+1];\n\tint err;\n\tmemset(tuple, 0, sizeof(*tuple));\n\terr = nla_parse_nested_deprecated(tb, CTA_TUPLE_MAX, cda[type],\n\t\t\t\t\t  tuple_nla_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\ttuple->src.l3num = l3num;\n\tif (flags & CTA_FILTER_FLAG(CTA_IP_DST) ||\n\t    flags & CTA_FILTER_FLAG(CTA_IP_SRC)) {\n\t\tif (!tb[CTA_TUPLE_IP])\n\t\t\treturn -EINVAL;\n\t\terr = ctnetlink_parse_tuple_ip(tb[CTA_TUPLE_IP], tuple, flags);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (flags & CTA_FILTER_FLAG(CTA_PROTO_NUM)) {\n\t\tif (!tb[CTA_TUPLE_PROTO])\n\t\t\treturn -EINVAL;\n\t\terr = ctnetlink_parse_tuple_proto(tb[CTA_TUPLE_PROTO], tuple, flags);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else if (flags & CTA_FILTER_FLAG(ALL_CTA_PROTO)) {\n\t\treturn -EINVAL;\n\t}\n\tif ((flags & CTA_FILTER_FLAG(CTA_TUPLE_ZONE)) && tb[CTA_TUPLE_ZONE]) {\n\t\tif (!zone)\n\t\t\treturn -EINVAL;\n\t\terr = ctnetlink_parse_tuple_zone(tb[CTA_TUPLE_ZONE],\n\t\t\t\t\t\t type, zone);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (type == CTA_TUPLE_REPLY)\n\t\ttuple->dst.dir = IP_CT_DIR_REPLY;\n\telse\n\t\ttuple->dst.dir = IP_CT_DIR_ORIGINAL;\n\treturn 0;\n}", "target": 1}
{"code": "png_set_PLTE(png_structrp png_ptr, png_inforp info_ptr,\n    png_const_colorp palette, int num_palette)\n{\n   png_debug1(1, \"in %s storage function\", \"PLTE\");\n   if (png_ptr == NULL || info_ptr == NULL)\n      return;\n   if (num_palette < 0 || num_palette > PNG_MAX_PALETTE_LENGTH)\n   {\n      if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n         png_error(png_ptr, \"Invalid palette length\");\n      else\n      {\n         png_warning(png_ptr, \"Invalid palette length\");\n         return;\n      }\n   }\n   if ((num_palette > 0 && palette == NULL) ||\n      (num_palette == 0\n#        ifdef PNG_MNG_FEATURES_SUPPORTED\n            && (png_ptr->mng_features_permitted & PNG_FLAG_MNG_EMPTY_PLTE) == 0\n#        endif\n      ))\n   {\n      png_error(png_ptr, \"Invalid palette\");\n   }\n   png_free_data(png_ptr, info_ptr, PNG_FREE_PLTE, 0);\n   png_ptr->palette = png_voidcast(png_colorp, png_calloc(png_ptr,\n       PNG_MAX_PALETTE_LENGTH * (sizeof (png_color))));\n   if (num_palette > 0)\n      memcpy(png_ptr->palette, palette, num_palette * (sizeof (png_color)));\n   info_ptr->palette = png_ptr->palette;\n   info_ptr->num_palette = png_ptr->num_palette = (png_uint_16)num_palette;\n   info_ptr->free_me |= PNG_FREE_PLTE;\n   info_ptr->valid |= PNG_INFO_PLTE;\n}", "target": 1}
{"code": "void native_tss_update_io_bitmap(void)\n{\n\tstruct tss_struct *tss = this_cpu_ptr(&cpu_tss_rw);\n\tstruct thread_struct *t = &current->thread;\n\tu16 *base = &tss->x86_tss.io_bitmap_base;\n\tif (!test_thread_flag(TIF_IO_BITMAP)) {\n\t\ttss_invalidate_io_bitmap(tss);\n\t\treturn;\n\t}\n\tif (IS_ENABLED(CONFIG_X86_IOPL_IOPERM) && t->iopl_emul == 3) {\n\t\t*base = IO_BITMAP_OFFSET_VALID_ALL;\n\t} else {\n\t\tstruct io_bitmap *iobm = t->io_bitmap;\n\t\tif (tss->io_bitmap.prev_sequence != iobm->sequence)\n\t\t\ttss_copy_io_bitmap(tss, iobm);\n\t\t*base = IO_BITMAP_OFFSET_VALID_MAP;\n\t}\n\trefresh_tss_limit();\n}", "target": 1}
{"code": "AP_CORE_DECLARE_NONSTD(const char *) ap_limit_section(cmd_parms *cmd,\n                                                      void *dummy,\n                                                      const char *arg)\n{\n    const char *endp = ap_strrchr_c(arg, '>');\n    const char *limited_methods;\n    void *tog = cmd->cmd->cmd_data;\n    apr_int64_t limited = 0;\n    apr_int64_t old_limited = cmd->limited;\n    const char *errmsg;\n    if (endp == NULL) {\n        return unclosed_directive(cmd);\n    }\n    limited_methods = apr_pstrmemdup(cmd->temp_pool, arg, endp - arg);\n    if (!limited_methods[0]) {\n        return missing_container_arg(cmd);\n    }\n    while (limited_methods[0]) {\n        char *method = ap_getword_conf(cmd->temp_pool, &limited_methods);\n        int methnum;\n        methnum = ap_method_number_of(method);\n        if (methnum == M_TRACE && !tog) {\n            return \"TRACE cannot be controlled by <Limit>, see TraceEnable\";\n        }\n        else if (methnum == M_INVALID) {\n             methnum = ap_method_register(cmd->pool,\n                                          apr_pstrdup(cmd->pool, method));\n         }\n        limited |= (AP_METHOD_BIT << methnum);\n    }\n    limited = tog ? ~limited : limited;\n    if (!(old_limited & limited)) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive excludes all methods\", NULL);\n    }\n    else if ((old_limited & limited) == old_limited) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive specifies methods already excluded\",\n                           NULL);\n    }\n    cmd->limited &= limited;\n    errmsg = ap_walk_config(cmd->directive->first_child, cmd, cmd->context);\n    cmd->limited = old_limited;\n    return errmsg;\n}", "target": 1}
{"code": "    inline EndpointSecurityAttributesMask mask() const\n    {\n        EndpointSecurityAttributesMask rv = ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_VALID;\n        if (is_read_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_READ_PROTECTED;\n        if (is_write_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_WRITE_PROTECTED;\n        if (is_discovery_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_DISCOVERY_PROTECTED;\n        if (is_liveliness_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_LIVELINESS_PROTECTED;\n        if (is_submessage_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_SUBMESSAGE_PROTECTED;\n        if (is_payload_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_PAYLOAD_PROTECTED;\n        if (is_key_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_KEY_PROTECTED;\n        return rv;\n    }", "target": 1}
{"code": "DLLEXPORT int DLLCALL tjEncodeYUV3(tjhandle handle,\n\tconst unsigned char *srcBuf, int width, int pitch, int height,\n\tint pixelFormat, unsigned char *dstBuf, int pad, int subsamp, int flags)\n{\n\tunsigned char *dstPlanes[3];\n\tint pw0, ph0, strides[3], retval=-1;\n\tif(width<=0 || height<=0 || dstBuf==NULL || pad<0 || !isPow2(pad)\n\t\t|| subsamp<0 || subsamp>=NUMSUBOPT)\n\t\t_throw(\"tjEncodeYUV3(): Invalid argument\");\n\tpw0=tjPlaneWidth(0, width, subsamp);\n\tph0=tjPlaneHeight(0, height, subsamp);\n\tdstPlanes[0]=dstBuf;\n\tstrides[0]=PAD(pw0, pad);\n\tif(subsamp==TJSAMP_GRAY)\n\t{\n\t\tstrides[1]=strides[2]=0;\n\t\tdstPlanes[1]=dstPlanes[2]=NULL;\n\t}\n\telse\n\t{\n\t\tint pw1=tjPlaneWidth(1, width, subsamp);\n\t\tint ph1=tjPlaneHeight(1, height, subsamp);\n\t\tstrides[1]=strides[2]=PAD(pw1, pad);\n\t\tdstPlanes[1]=dstPlanes[0]+strides[0]*ph0;\n\t\tdstPlanes[2]=dstPlanes[1]+strides[1]*ph1;\n\t}\n\treturn tjEncodeYUVPlanes(handle, srcBuf, width, pitch, height, pixelFormat,\n\t\tdstPlanes, strides, subsamp, flags);\n\tbailout:\n\treturn retval;\n}", "target": 0}
{"code": "String UnbufferedAsioTlsStream::GetVerifyError() const\n{\n\treturn m_VerifyError;\n}", "target": 1}
{"code": "status_t MPEG4Extractor::parseAC3SpecificBox(\n off64_t offset, uint16_t sampleRate) {\n uint32_t size;\n const uint32_t kAC3SpecificBoxSize = 11;\n if (!mDataSource->getUInt32(offset, &size) || size < kAC3SpecificBoxSize) {\n        ALOGE(\"MPEG4Extractor: error while reading ac-3 block: cannot read specific box size\");\n return ERROR_MALFORMED;\n }\n    offset += 4;\n uint32_t type;\n if (!mDataSource->getUInt32(offset, &type) || type != FOURCC('d', 'a', 'c', '3')) {\n        ALOGE(\"MPEG4Extractor: error while reading ac-3 specific block: header not dac3\");\n return ERROR_MALFORMED;\n }\n    offset += 4;\n const uint32_t kAC3SpecificBoxPayloadSize = 3;\n uint8_t chunk[kAC3SpecificBoxPayloadSize];\n if (mDataSource->readAt(offset, chunk, sizeof(chunk)) != sizeof(chunk)) {\n        ALOGE(\"MPEG4Extractor: error while reading ac-3 specific block: bitstream fields\");\n return ERROR_MALFORMED;\n }\n ABitReader br(chunk, sizeof(chunk));\n static const unsigned channelCountTable[] = {2, 1, 2, 3, 3, 4, 4, 5};\n static const unsigned sampleRateTable[] = {48000, 44100, 32000};\n unsigned fscod = br.getBits(2);\n if (fscod == 3) {\n        ALOGE(\"Incorrect fscod (3) in AC3 header\");\n return ERROR_MALFORMED;\n }\n unsigned boxSampleRate = sampleRateTable[fscod];\n if (boxSampleRate != sampleRate) {\n        ALOGE(\"sample rate mismatch: boxSampleRate = %d, sampleRate = %d\",\n            boxSampleRate, sampleRate);\n return ERROR_MALFORMED;\n }\n unsigned bsid = br.getBits(5);\n if (bsid > 8) {\n        ALOGW(\"Incorrect bsid in AC3 header. Possibly E-AC-3?\");\n return ERROR_MALFORMED;\n }\n unsigned bsmod __unused = br.getBits(3);\n unsigned acmod = br.getBits(3);\n unsigned lfeon = br.getBits(1);\n unsigned channelCount = channelCountTable[acmod] + lfeon;\n if (mLastTrack == NULL) {\n return ERROR_MALFORMED;\n }\n    mLastTrack->meta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_AC3);\n    mLastTrack->meta->setInt32(kKeyChannelCount, channelCount);\n    mLastTrack->meta->setInt32(kKeySampleRate, sampleRate);\n return OK;\n}", "target": 0}
{"code": "static Bigint * Balloc(int k)\n{\n\tint x;\n\tBigint *rv;\n\t_THREAD_PRIVATE_MUTEX_LOCK(dtoa_mutex);\n\tif ((rv = freelist[k])) {\n\t\tfreelist[k] = rv->next;\n\t} else {\n\t\tx = 1 << k;\n\t\trv = (Bigint *)MALLOC(sizeof(Bigint) + (x-1)*sizeof(Long));\n\t\trv->k = k;\n\t\trv->maxwds = x;\n\t}\n\t_THREAD_PRIVATE_MUTEX_UNLOCK(dtoa_mutex);\n\trv->sign = rv->wds = 0;\n\treturn rv;\n}", "target": 1}
{"code": "static void ff_layout_put_mirror(struct nfs4_ff_layout_mirror *mirror)\n{\n\tif (mirror != NULL && refcount_dec_and_test(&mirror->ref))\n\t\tff_layout_free_mirror(mirror);\n}", "target": 0}
{"code": "static gboolean printable_str(const char *str)\n{\n    do {\n        if ((unsigned char)(*str) < ' ' || *str == 0x7f)\n            return FALSE;\n        str++;\n    } while (*str);\n    return TRUE;\n}", "target": 1}
{"code": "gen_hash(codegen_scope *s, node *tree, int val, int limit)\n{\n  int slimit = GEN_VAL_STACK_MAX;\n  if (cursp() >= GEN_LIT_ARY_MAX) slimit = INT16_MAX;\n  int len = 0;\n  mrb_bool update = FALSE;\n  while (tree) {\n    if (nint(tree->car->car->car) == NODE_KW_REST_ARGS) {\n      if (len > 0) {\n        pop_n(len*2);\n        if (!update) {\n          genop_2(s, OP_HASH, cursp(), len);\n        }\n        else {\n          pop();\n          genop_2(s, OP_HASHADD, cursp(), len);\n        }\n        push();\n      }\n      codegen(s, tree->car->cdr, val);\n      if (len > 0 || update) {\n        pop(); pop();\n        genop_1(s, OP_HASHCAT, cursp());\n        push();\n      }\n      update = TRUE;\n      len = 0;\n    }\n    else {\n      codegen(s, tree->car->car, val);\n      codegen(s, tree->car->cdr, val);\n      len++;\n    }\n    tree = tree->cdr;\n    if (val && cursp() >= slimit) {\n      pop_n(len*2);\n      if (!update) {\n        genop_2(s, OP_HASH, cursp(), len);\n      }\n      else {\n        pop();\n        genop_2(s, OP_HASHADD, cursp(), len);\n      }\n      push();\n      update = TRUE;\n      len = 0;\n    }\n  }\n  if (update) {\n    if (len > 0) {\n      pop_n(len*2+1);\n      genop_2(s, OP_HASHADD, cursp(), len);\n      push();\n    }\n    return -1;                  \n  }\n  if (update) return -1;\n  return len;\n}", "target": 1}
{"code": "oneright(void)\n{\n    char_u\t*ptr;\n    int\t\tl;\n    if (virtual_active())\n    {\n\tpos_T\tprevpos = curwin->w_cursor;\n\tptr = ml_get_cursor();\n\tcoladvance(getviscol() + ((*ptr != TAB\n\t\t\t\t\t  && vim_isprintc((*mb_ptr2char)(ptr)))\n\t\t    ? ptr2cells(ptr) : 1));\n\tcurwin->w_set_curswant = TRUE;\n\treturn (prevpos.col != curwin->w_cursor.col\n\t\t    || prevpos.coladd != curwin->w_cursor.coladd) ? OK : FAIL;\n    }\n    ptr = ml_get_cursor();\n    if (*ptr == NUL)\n\treturn FAIL;\t    \n    if (has_mbyte)\n\tl = (*mb_ptr2len)(ptr);\n    else\n\tl = 1;\n    if (ptr[l] == NUL && (ve_flags & VE_ONEMORE) == 0)\n\treturn FAIL;\n    curwin->w_cursor.col += l;\n    curwin->w_set_curswant = TRUE;\n    return OK;\n}", "target": 0}
{"code": "static struct ip_options *tcp_v4_save_options(struct sock *sk,\n\t\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct ip_options *opt = &(IPCB(skb)->opt);\n\tstruct ip_options *dopt = NULL;\n\tif (opt && opt->optlen) {\n\t\tint opt_size = optlength(opt);\n\t\tdopt = kmalloc(opt_size, GFP_ATOMIC);\n\t\tif (dopt) {\n\t\t\tif (ip_options_echo(dopt, skb)) {\n\t\t\t\tkfree(dopt);\n\t\t\t\tdopt = NULL;\n\t\t\t}\n\t\t}\n\t}\n\treturn dopt;\n}", "target": 1}
{"code": "void ax25_fillin_cb(ax25_cb *ax25, ax25_dev *ax25_dev)\n{\n\tax25->ax25_dev = ax25_dev;\n\tif (ax25->ax25_dev != NULL) {\n\t\tax25_fillin_cb_from_dev(ax25, ax25_dev);\n\t\treturn;\n\t}\n\tax25->rtt     = msecs_to_jiffies(AX25_DEF_T1) / 2;\n\tax25->t1      = msecs_to_jiffies(AX25_DEF_T1);\n\tax25->t2      = msecs_to_jiffies(AX25_DEF_T2);\n\tax25->t3      = msecs_to_jiffies(AX25_DEF_T3);\n\tax25->n2      = AX25_DEF_N2;\n\tax25->paclen  = AX25_DEF_PACLEN;\n\tax25->idle    = msecs_to_jiffies(AX25_DEF_IDLE);\n\tax25->backoff = AX25_DEF_BACKOFF;\n\tif (AX25_DEF_AXDEFMODE) {\n\t\tax25->modulus = AX25_EMODULUS;\n\t\tax25->window  = AX25_DEF_EWINDOW;\n\t} else {\n\t\tax25->modulus = AX25_MODULUS;\n\t\tax25->window  = AX25_DEF_WINDOW;\n\t}\n}", "target": 0}
{"code": "  virtual void SetUp() {\n    URLRequest::RegisterProtocolFactory(chrome::kChromeUIScheme,\n                                        &URLRequestTestJob::Factory);\n  }", "target": 0}
{"code": "int btrfs_grow_device(struct btrfs_trans_handle *trans,\n\t\t      struct btrfs_device *device, u64 new_size)\n{\n\tstruct btrfs_fs_info *fs_info = device->fs_info;\n\tstruct btrfs_super_block *super_copy = fs_info->super_copy;\n\tstruct btrfs_fs_devices *fs_devices;\n\tu64 old_total;\n\tu64 diff;\n\tif (!test_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state))\n\t\treturn -EACCES;\n\tnew_size = round_down(new_size, fs_info->sectorsize);\n\tmutex_lock(&fs_info->chunk_mutex);\n\told_total = btrfs_super_total_bytes(super_copy);\n\tdiff = round_down(new_size - device->total_bytes, fs_info->sectorsize);\n\tif (new_size <= device->total_bytes ||\n\t    test_bit(BTRFS_DEV_STATE_REPLACE_TGT, &device->dev_state)) {\n\t\tmutex_unlock(&fs_info->chunk_mutex);\n\t\treturn -EINVAL;\n\t}\n\tfs_devices = fs_info->fs_devices;\n\tbtrfs_set_super_total_bytes(super_copy,\n\t\t\tround_down(old_total + diff, fs_info->sectorsize));\n\tdevice->fs_devices->total_rw_bytes += diff;\n\tbtrfs_device_set_total_bytes(device, new_size);\n\tbtrfs_device_set_disk_total_bytes(device, new_size);\n\tbtrfs_clear_space_info_full(device->fs_info);\n\tif (list_empty(&device->resized_list))\n\t\tlist_add_tail(&device->resized_list,\n\t\t\t      &fs_devices->resized_devices);\n\tmutex_unlock(&fs_info->chunk_mutex);\n\treturn btrfs_update_device(trans, device);\n}", "target": 0}
{"code": "static inline void map_qs_metadata(struct req_state* s)\n{\n  const auto& params = const_cast<RGWHTTPArgs&>(s->info.args).get_params();\n  for (const auto& elt : params) {\n    std::string k = boost::algorithm::to_lower_copy(elt.first);\n    if (k.find(\"x-amz-meta-\") ==  0) {\n      add_amz_meta_header(s->info.x_meta_map, k, elt.second);\n    }\n  }\n}", "target": 0}
{"code": "void PDPServer::perform_builtin_endpoints_matching(\n        const ParticipantProxyData& pdata)\n{\n    if (mp_EDP != nullptr)\n    {\n        mp_EDP->assignRemoteEndpoints(pdata);\n    }\n    if (mp_builtin->mp_WLP != nullptr)\n    {\n        mp_builtin->mp_WLP->assignRemoteEndpoints(pdata);\n    }\n}", "target": 1}
{"code": "static void TIFFIgnoreTags(TIFF *tiff)\n{\n  char\n    *q;\n  const char\n    *p,\n    *tags;\n  Image\n   *image;\n  register ssize_t\n    i;\n  size_t\n    count;\n  TIFFFieldInfo\n    *ignore;\n  if (TIFFGetReadProc(tiff) != TIFFReadBlob)\n    return;\n  image=(Image *)TIFFClientdata(tiff);\n  tags=GetImageArtifact(image,\"tiff:ignore-tags\");\n  if (tags == (const char *) NULL)\n    return;\n  count=0;\n  p=tags;\n  while (*p != '\\0')\n  {\n    while ((isspace((int) ((unsigned char) *p)) != 0))\n      p++;\n    (void) strtol(p,&q,10);\n    if (p == q)\n      return;\n    p=q;\n    count++;\n    while ((isspace((int) ((unsigned char) *p)) != 0) || (*p == ','))\n      p++;\n  }\n  if (count == 0)\n    return;\n  i=0;\n  p=tags;\n  ignore=(TIFFFieldInfo *) AcquireQuantumMemory(count,sizeof(*ignore));\n  if (ignore == (TIFFFieldInfo *) NULL)\n    return;\n  memset(ignore,0,count*sizeof(*ignore));\n  while (*p != '\\0')\n  {\n    while ((isspace((int) ((unsigned char) *p)) != 0))\n      p++;\n    ignore[i].field_tag=(ttag_t) strtol(p,&q,10);\n    p=q;\n    i++;\n    while ((isspace((int) ((unsigned char) *p)) != 0) || (*p == ','))\n      p++;\n  }\n  (void) TIFFMergeFieldInfo(tiff,ignore,(uint32) count);\n  ignore=(TIFFFieldInfo *) RelinquishMagickMemory(ignore);\n}", "target": 0}
{"code": "static uint64_t HTPStateGetTxCnt(void *alstate)\n{\n    HtpState *http_state = (HtpState *)alstate;\n    if (http_state != NULL && http_state->conn != NULL) {\n        const int64_t size = (int64_t)htp_list_size(http_state->conn->transactions);\n        if (size < 0)\n            return 0ULL;\n        SCLogDebug(\"size %\"PRIu64, size);\n        return (uint64_t)size;\n    } else {\n        return 0ULL;\n    }\n}", "target": 1}
{"code": "void show_object_with_name(FILE *out, struct object *obj,\n\t\t\t   struct strbuf *path, const char *component)\n{\n\tchar *name = path_name(path, component);\n\tchar *p;\n\tfprintf(out, \"%s \", oid_to_hex(&obj->oid));\n\tfor (p = name; *p && *p != '\\n'; p++)\n\t\tfputc(*p, out);\n\tfputc('\\n', out);\n\tfree(name);\n}", "target": 1}
{"code": "int hfsplus_set_posix_acl(struct inode *inode, struct posix_acl *acl,\n\t\tint type)\n{\n\tint err;\n\tchar *xattr_name;\n\tsize_t size = 0;\n\tchar *value = NULL;\n\thfs_dbg(ACL_MOD, \"[%s]: ino %lu\\n\", __func__, inode->i_ino);\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\txattr_name = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terr = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\terr = 0;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\txattr_name = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tif (unlikely(size > HFSPLUS_MAX_INLINE_DATA_SIZE))\n\t\t\treturn -ENOMEM;\n\t\tvalue = (char *)hfsplus_alloc_attr_entry();\n\t\tif (unlikely(!value))\n\t\t\treturn -ENOMEM;\n\t\terr = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (unlikely(err < 0))\n\t\t\tgoto end_set_acl;\n\t}\n\terr = __hfsplus_setxattr(inode, xattr_name, value, size, 0);\nend_set_acl:\n\thfsplus_destroy_attr_entry((hfsplus_attr_entry *)value);\n\tif (!err)\n\t\tset_cached_acl(inode, type, acl);\n\treturn err;\n}", "target": 1}
{"code": "  Declaration_Obj Parser::parse_declaration() {\n    String_Obj prop;\n    bool is_custom_property = false;\n    if (lex< sequence< optional< exactly<'*'> >, identifier_schema > >()) {\n      const std::string property(lexed);\n      is_custom_property = property.compare(0, 2, \"--\") == 0;\n      prop = parse_identifier_schema();\n    }\n    else if (lex< sequence< optional< exactly<'*'> >, identifier, zero_plus< block_comment > > >()) {\n      const std::string property(lexed);\n      is_custom_property = property.compare(0, 2, \"--\") == 0;\n      prop = SASS_MEMORY_NEW(String_Constant, pstate, lexed);\n    }\n    else {\n      css_error(\"Invalid CSS\", \" after \", \": expected \\\"}\\\", was \");\n    }\n    bool is_indented = true;\n    const std::string property(lexed);\n    if (!lex_css< one_plus< exactly<':'> > >()) error(\"property \\\"\" + escape_string(property)  + \"\\\" must be followed by a ':'\");\n    if (!is_custom_property && match< sequence< optional_css_comments, exactly<';'> > >()) error(\"style declaration must contain a value\");\n    if (match< sequence< optional_css_comments, exactly<'{'> > >()) is_indented = false; \n    if (is_custom_property) {\n      return SASS_MEMORY_NEW(Declaration, prop->pstate(), prop, parse_css_variable_value(), false, true);\n    }\n    lex < css_comments >(false);\n    if (peek_css< static_value >()) {\n      return SASS_MEMORY_NEW(Declaration, prop->pstate(), prop, parse_static_value());\n    }\n    else {\n      Expression_Obj value;\n      Lookahead lookahead = lookahead_for_value(position);\n      if (lookahead.found) {\n        if (lookahead.has_interpolants) {\n          value = parse_value_schema(lookahead.found);\n        } else {\n          value = parse_list(DELAYED);\n        }\n      }\n      else {\n        value = parse_list(DELAYED);\n        if (List* list = Cast<List>(value)) {\n          if (!list->is_bracketed() && list->length() == 0 && !peek< exactly <'{'> >()) {\n            css_error(\"Invalid CSS\", \" after \", \": expected expression (e.g. 1px, bold), was \");\n          }\n        }\n      }\n      lex < css_comments >(false);\n      Declaration_Obj decl = SASS_MEMORY_NEW(Declaration, prop->pstate(), prop, value);\n      decl->is_indented(is_indented);\n      decl->update_pstate(pstate);\n      return decl;\n    }\n  }", "target": 0}
{"code": "static void unmask_payload(handler_ctx *hctx) {\n    buffer * const b = hctx->frame.payload;\n    for (size_t i = 0, used = buffer_clen(b); i < used; ++i) {\n        b->ptr[i] ^= hctx->frame.ctl.mask[hctx->frame.ctl.mask_cnt];\n        hctx->frame.ctl.mask_cnt = (hctx->frame.ctl.mask_cnt + 1) % 4;\n    }\n}", "target": 0}
{"code": "cmd_getinfo (assuan_context_t ctx, char *line)\n{\n  int rc = 0;\n  if (!strcmp (line, \"version\"))\n    {\n      const char *s = VERSION;\n      rc = assuan_send_data (ctx, s, strlen (s));\n    }\n  else if (!strcmp (line, \"pid\"))\n    {\n      char numbuf[50];\n      snprintf (numbuf, sizeof numbuf, \"%lu\", (unsigned long)getpid ());\n      rc = assuan_send_data (ctx, numbuf, strlen (numbuf));\n    }\n  else if (!strcmp (line, \"socket_name\"))\n    {\n      const char *s = scd_get_socket_name ();\n      if (s)\n        rc = assuan_send_data (ctx, s, strlen (s));\n      else\n        rc = gpg_error (GPG_ERR_NO_DATA);\n    }\n  else if (!strcmp (line, \"status\"))\n    {\n      ctrl_t ctrl = assuan_get_pointer (ctx);\n      int vrdr = ctrl->server_local->vreader_idx;\n      char flag = 'r';\n      if (!ctrl->server_local->card_removed && vrdr != -1)\n\t{\n\t  struct vreader_s *vr;\n\t  if (!(vrdr >= 0 && vrdr < DIM(vreader_table)))\n\t    BUG ();\n\t  vr = &vreader_table[vrdr];\n\t  if (vr->valid && vr->any && (vr->status & 1))\n\t    flag = 'u';\n\t}\n      rc = assuan_send_data (ctx, &flag, 1);\n    }\n  else if (!strcmp (line, \"reader_list\"))\n    {\n#ifdef HAVE_LIBUSB\n      char *s = ccid_get_reader_list ();\n#else\n      char *s = NULL;\n#endif\n      if (s)\n        rc = assuan_send_data (ctx, s, strlen (s));\n      else\n        rc = gpg_error (GPG_ERR_NO_DATA);\n      xfree (s);\n    }\n  else if (!strcmp (line, \"deny_admin\"))\n    rc = opt.allow_admin? gpg_error (GPG_ERR_GENERAL) : 0;\n  else if (!strcmp (line, \"app_list\"))\n    {\n      char *s = get_supported_applications ();\n      if (s)\n        rc = assuan_send_data (ctx, s, strlen (s));\n      else\n        rc = 0;\n      xfree (s);\n    }\n  else\n    rc = set_error (GPG_ERR_ASS_PARAMETER, \"unknown value for WHAT\");\n  return rc;\n}", "target": 0}
{"code": "void ConnectDialog::udpReply() {\n\tQUdpSocket *sock = qobject_cast<QUdpSocket *>(sender());\n\twhile (sock->hasPendingDatagrams()) {\n\t\tchar blob[64];\n\t\tQHostAddress host;\n\t\tunsigned short port;\n\t\tqint64 len = sock->readDatagram(blob+4, 24, &host, &port);\n\t\tif (len == 24) {\n\t\t\tif (host.scopeId() == QLatin1String(\"0\"))\n\t\t\t\thost.setScopeId(QLatin1String(\"\"));\n\t\t\tServerAddress address(HostAddress(host), port);\n\t\t\tif (qhPings.contains(address)) {\n\t\t\t\tquint32 *ping = reinterpret_cast<quint32 *>(blob+4);\n\t\t\t\tquint64 *ts = reinterpret_cast<quint64 *>(blob+8);\n\t\t\t\tquint64 elapsed = tPing.elapsed() - (*ts ^ qhPingRand.value(address));\n\t\t\t\tforeach(ServerItem *si, qhPings.value(address)) {\n\t\t\t\t\tsi->uiVersion = qFromBigEndian(ping[0]);\n\t\t\t\t\tquint32 users = qFromBigEndian(ping[3]);\n\t\t\t\t\tquint32 maxusers = qFromBigEndian(ping[4]);\n\t\t\t\t\tsi->uiBandwidth = qFromBigEndian(ping[5]);\n\t\t\t\t\tif (! si->uiPingSort)\n\t\t\t\t\t\tsi->uiPingSort = qmPingCache.value(UnresolvedServerAddress(si->qsHostname, si->usPort));\n\t\t\t\t\tsi->setDatas(static_cast<double>(elapsed), users, maxusers);\n\t\t\t\t\tsi->hideCheck();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "target": 0}
{"code": "parse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree, *branch = NULL;\n  tree = parse_branch (regexp, preg, token, syntax, nest, err);\n  if (BE (*err != REG_NOERROR && tree == NULL, 0))\n    return NULL;\n  while (token->type == OP_ALT)\n    {\n      fetch_token (token, regexp, syntax | RE_CARET_ANCHORS_HERE);\n      if (token->type != OP_ALT && token->type != END_OF_RE\n\t  && (nest == 0 || token->type != OP_CLOSE_SUBEXP))\n\t{\n\t  branch = parse_branch (regexp, preg, token, syntax, nest, err);\n\t  if (BE (*err != REG_NOERROR && branch == NULL, 0))\n\t    {\n\t      if (tree != NULL)\n\t\tpostorder (tree, free_tree, NULL);\n\t      return NULL;\n\t    }\n\t}\n      else\n\tbranch = NULL;\n      tree = create_tree (dfa, tree, branch, OP_ALT);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n    }\n  return tree;\n}", "target": 1}
{"code": "static int nci_extract_activation_params_iso_dep(struct nci_dev *ndev,\n\t\t\tstruct nci_rf_intf_activated_ntf *ntf, __u8 *data)\n{\n\tstruct activation_params_nfca_poll_iso_dep *nfca_poll;\n\tstruct activation_params_nfcb_poll_iso_dep *nfcb_poll;\n\tswitch (ntf->activation_rf_tech_and_mode) {\n\tcase NCI_NFC_A_PASSIVE_POLL_MODE:\n\t\tnfca_poll = &ntf->activation_params.nfca_poll_iso_dep;\n\t\tnfca_poll->rats_res_len = *data++;\n\t\tpr_debug(\"rats_res_len %d\\n\", nfca_poll->rats_res_len);\n\t\tif (nfca_poll->rats_res_len > 0) {\n\t\t\tmemcpy(nfca_poll->rats_res,\n\t\t\t       data, nfca_poll->rats_res_len);\n\t\t}\n\t\tbreak;\n\tcase NCI_NFC_B_PASSIVE_POLL_MODE:\n\t\tnfcb_poll = &ntf->activation_params.nfcb_poll_iso_dep;\n\t\tnfcb_poll->attrib_res_len = *data++;\n\t\tpr_debug(\"attrib_res_len %d\\n\", nfcb_poll->attrib_res_len);\n\t\tif (nfcb_poll->attrib_res_len > 0) {\n\t\t\tmemcpy(nfcb_poll->attrib_res,\n\t\t\t       data, nfcb_poll->attrib_res_len);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unsupported activation_rf_tech_and_mode 0x%x\\n\",\n\t\t       ntf->activation_rf_tech_and_mode);\n\t\treturn NCI_STATUS_RF_PROTOCOL_ERROR;\n\t}\n\treturn NCI_STATUS_OK;\n}", "target": 1}
{"code": "void ContainerNode::notifyNodeRemoved(Node& root)\n{\n    ScriptForbiddenScope forbidScript;\n    EventDispatchForbiddenScope assertNoEventDispatch;\n    for (Node& node : NodeTraversal::inclusiveDescendantsOf(root)) {\n        if (!node.isContainerNode() && !node.isInTreeScope())\n            continue;\n        node.removedFrom(this);\n        for (ShadowRoot* shadowRoot = node.youngestShadowRoot(); shadowRoot; shadowRoot = shadowRoot->olderShadowRoot())\n            notifyNodeRemoved(*shadowRoot);\n    }\n}", "target": 0}
{"code": "static int __init cmdline_parse_core(char *p, unsigned long *core)\n{\n\tunsigned long long coremem;\n\tif (!p)\n\t\treturn -EINVAL;\n\tcoremem = memparse(p, &p);\n\t*core = coremem >> PAGE_SHIFT;\n\tWARN_ON((coremem >> PAGE_SHIFT) > ULONG_MAX);\n\treturn 0;\n}", "target": 0}
{"code": "static void follow_dotdot(struct nameidata *nd)\n{\n\tif (!nd->root.mnt)\n\t\tset_root(nd);\n\twhile(1) {\n\t\tstruct dentry *old = nd->path.dentry;\n\t\tif (nd->path.dentry == nd->root.dentry &&\n\t\t    nd->path.mnt == nd->root.mnt) {\n\t\t\tbreak;\n\t\t}\n\t\tif (nd->path.dentry != nd->path.mnt->mnt_root) {\n\t\t\tnd->path.dentry = dget_parent(nd->path.dentry);\n\t\t\tdput(old);\n\t\t\tbreak;\n\t\t}\n\t\tif (!follow_up(&nd->path))\n\t\t\tbreak;\n\t}\n\tfollow_mount(&nd->path);\n\tnd->inode = nd->path.dentry->d_inode;\n}", "target": 1}
{"code": "lyxml_parse_mem(struct ly_ctx *ctx, const char *data, int options)\n{\n    FUN_IN;\n    const char *c = data;\n    unsigned int len;\n    struct lyxml_elem *root, *first = NULL, *next;\n    if (!ctx) {\n        LOGARG;\n        return NULL;\n    }\n    if (!data) {\n        return NULL;\n    }\nrepeat:\n    while (1) {\n        if (!*c) {\n            return first;\n        } else if (is_xmlws(*c)) {\n            ign_xmlws(c);\n        } else if (!strncmp(c, \"<?\", 2)) {\n            c += 2;\n            if (parse_ignore(ctx, c, \"?>\", &len)) {\n                goto error;\n            }\n            c += len;\n        } else if (!strncmp(c, \"<!--\", 4)) {\n            c += 2;\n            if (parse_ignore(ctx, c, \"-->\", &len)) {\n                goto error;\n            }\n            c += len;\n        } else if (!strncmp(c, \"<!\", 2)) {\n            LOGERR(ctx, LY_EINVAL, \"DOCTYPE not supported in XML documents.\");\n            goto error;\n        } else if (*c == '<') {\n            break;\n        } else {\n            LOGVAL(ctx, LYE_XML_INCHAR, LY_VLOG_NONE, NULL, c);\n            goto error;\n        }\n    }\n    root = lyxml_parse_elem(ctx, c, &len, NULL, options);\n    if (!root) {\n        goto error;\n    } else if (!first) {\n        first = root;\n    } else {\n        first->prev->next = root;\n        root->prev = first->prev;\n        first->prev = root;\n    }\n    c += len;\n    ign_xmlws(c);\n    if (*c) {\n        if (options & LYXML_PARSE_MULTIROOT) {\n            goto repeat;\n        } else {\n            LOGWRN(ctx, \"There are some not parsed data:\\n%s\", c);\n        }\n    }\n    return first;\nerror:\n    LY_TREE_FOR_SAFE(first, next, root) {\n        lyxml_free(ctx, root);\n    }\n    return NULL;\n}", "target": 1}
{"code": "mwifiex_ie_get_autoidx(struct mwifiex_private *priv, u16 subtype_mask,\n\t\t       struct mwifiex_ie *ie, u16 *index)\n{\n\tu16 mask, len, i;\n\tfor (i = 0; i < priv->adapter->max_mgmt_ie_index; i++) {\n\t\tmask = le16_to_cpu(priv->mgmt_ie[i].mgmt_subtype_mask);\n\t\tlen = le16_to_cpu(ie->ie_length);\n\t\tif (mask == MWIFIEX_AUTO_IDX_MASK)\n\t\t\tcontinue;\n\t\tif (mask == subtype_mask) {\n\t\t\tif (len > IEEE_MAX_IE_SIZE)\n\t\t\t\tcontinue;\n\t\t\t*index = i;\n\t\t\treturn 0;\n\t\t}\n\t\tif (!priv->mgmt_ie[i].ie_length) {\n\t\t\tif (mwifiex_ie_index_used_by_other_intf(priv, i))\n\t\t\t\tcontinue;\n\t\t\t*index = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -1;\n}", "target": 0}
{"code": "static int update_prepare_order_info(rdpContext* context, ORDER_INFO* orderInfo, UINT32 orderType)\n{\n\tint length = 1;\n\torderInfo->fieldFlags = 0;\n\torderInfo->orderType = orderType;\n\torderInfo->controlFlags = ORDER_STANDARD;\n\torderInfo->controlFlags |= ORDER_TYPE_CHANGE;\n\tlength += 1;\n\tlength += PRIMARY_DRAWING_ORDER_FIELD_BYTES[orderInfo->orderType];\n\tlength += update_prepare_bounds(context, orderInfo);\n\treturn length;\n}", "target": 1}
{"code": "epilogProcessor(XML_Parser parser, const char *s, const char *end,\n                const char **nextPtr) {\n  parser->m_processor = epilogProcessor;\n  parser->m_eventPtr = s;\n  for (;;) {\n    const char *next = NULL;\n    int tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n#ifdef XML_DTD\n    if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                  XML_ACCOUNT_DIRECT)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }\n#endif\n    parser->m_eventEndPtr = next;\n    switch (tok) {\n    case -XML_TOK_PROLOG_S:\n      if (parser->m_defaultHandler) {\n        reportDefault(parser, parser->m_encoding, s, next);\n        if (parser->m_parsingStatus.parsing == XML_FINISHED)\n          return XML_ERROR_ABORTED;\n      }\n      *nextPtr = next;\n      return XML_ERROR_NONE;\n    case XML_TOK_NONE:\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    case XML_TOK_PROLOG_S:\n      if (parser->m_defaultHandler)\n        reportDefault(parser, parser->m_encoding, s, next);\n      break;\n    case XML_TOK_PI:\n      if (! reportProcessingInstruction(parser, parser->m_encoding, s, next))\n        return XML_ERROR_NO_MEMORY;\n      break;\n    case XML_TOK_COMMENT:\n      if (! reportComment(parser, parser->m_encoding, s, next))\n        return XML_ERROR_NO_MEMORY;\n      break;\n    case XML_TOK_INVALID:\n      parser->m_eventPtr = next;\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL:\n      if (! parser->m_parsingStatus.finalBuffer) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_UNCLOSED_TOKEN;\n    case XML_TOK_PARTIAL_CHAR:\n      if (! parser->m_parsingStatus.finalBuffer) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_PARTIAL_CHAR;\n    default:\n      return XML_ERROR_JUNK_AFTER_DOC_ELEMENT;\n    }\n    parser->m_eventPtr = s = next;\n    switch (parser->m_parsingStatus.parsing) {\n    case XML_SUSPENDED:\n      *nextPtr = next;\n      return XML_ERROR_NONE;\n    case XML_FINISHED:\n      return XML_ERROR_ABORTED;\n    default:;\n    }\n  }\n}", "target": 1}
{"code": "void msetGenericCommand(client *c, int nx) {\n    int j;\n    int setkey_flags = 0;\n    if ((c->argc % 2) == 0) {\n        addReplyErrorArity(c);\n        return;\n    }\n    if (nx) {\n        for (j = 1; j < c->argc; j += 2) {\n            if (lookupKeyWrite(c->db,c->argv[j]) != NULL) {\n                addReply(c, shared.czero);\n                return;\n            }\n        }\n        setkey_flags |= SETKEY_DOESNT_EXIST;\n    }\n    for (j = 1; j < c->argc; j += 2) {\n        c->argv[j+1] = tryObjectEncoding(c->argv[j+1]);\n        setKey(c, c->db, c->argv[j], c->argv[j + 1], setkey_flags);\n        notifyKeyspaceEvent(NOTIFY_STRING,\"set\",c->argv[j],c->db->id);\n    }\n    server.dirty += (c->argc-1)/2;\n    addReply(c, nx ? shared.cone : shared.ok);\n}", "target": 1}
{"code": "        int          GetS8    (int nPos, bool *pbSuccess)\n        {\n            if ( nPos < 0 || nPos >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            int nRes = m_sFile[ nPos ];\n            if ( nRes & 0x80 )\n                nRes |= ~0xff;\n            return nRes;\n        }", "target": 1}
{"code": "static size_t exif_convert_any_to_int(void *value, int format, int motorola_intel TSRMLS_DC)\n{\n\tint \t\ts_den;\n\tunsigned \tu_den;\n\tswitch(format) {\n\t\tcase TAG_FMT_SBYTE:     return *(signed char *)value;\n\t\tcase TAG_FMT_BYTE:      return *(uchar *)value;\n\t\tcase TAG_FMT_USHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_ULONG:     return php_ifd_get32u(value, motorola_intel);\n\t\tcase TAG_FMT_URATIONAL:\n\t\t\tu_den = php_ifd_get32u(4+(char *)value, motorola_intel);\n\t\t\tif (u_den == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn php_ifd_get32u(value, motorola_intel) / u_den;\n\t\t\t}\n\t\tcase TAG_FMT_SRATIONAL:\n\t\t\ts_den = php_ifd_get32s(4+(char *)value, motorola_intel);\n\t\t\tif (s_den == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn php_ifd_get32s(value, motorola_intel) / s_den;\n\t\t\t}\n\t\tcase TAG_FMT_SSHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_SLONG:     return php_ifd_get32s(value, motorola_intel);\n\t\tcase TAG_FMT_SINGLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Found value of type single\");\n#endif\n\t\t\treturn (size_t)*(float *)value;\n\t\tcase TAG_FMT_DOUBLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Found value of type double\");\n#endif\n\t\t\treturn (size_t)*(double *)value;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "gopherStart(FwdState * fwd)\n{\n    GopherStateData *gopherState = new GopherStateData(fwd);\n    debugs(10, 3, gopherState->entry->url());\n    ++ statCounter.server.all.requests;\n    ++ statCounter.server.other.requests;\n    gopher_request_parse(fwd->request,\n                         &gopherState->type_id, gopherState->request);\n    comm_add_close_handler(fwd->serverConnection()->fd, gopherStateFree, gopherState);\n    if (((gopherState->type_id == GOPHER_INDEX) || (gopherState->type_id == GOPHER_CSO))\n            && (strchr(gopherState->request, '?') == nullptr)) {\n        gopherMimeCreate(gopherState);\n        if (gopherState->type_id == GOPHER_INDEX) {\n            gopherState->conversion = GopherStateData::HTML_INDEX_PAGE;\n        } else {\n            if (gopherState->type_id == GOPHER_CSO) {\n                gopherState->conversion = GopherStateData::HTML_CSO_PAGE;\n            } else {\n                gopherState->conversion = GopherStateData::HTML_INDEX_PAGE;\n            }\n        }\n        gopherToHTML(gopherState, (char *) nullptr, 0);\n        fwd->markStoredReplyAsWhole(\"gopher instant internal request satisfaction\");\n        fwd->complete();\n        return;\n    }\n    gopherState->serverConn = fwd->serverConnection();\n    gopherSendRequest(fwd->serverConnection()->fd, gopherState);\n    AsyncCall::Pointer timeoutCall = commCbCall(5, 4, \"gopherTimeout\",\n                                     CommTimeoutCbPtrFun(gopherTimeout, gopherState));\n    commSetConnTimeout(fwd->serverConnection(), Config.Timeout.read, timeoutCall);\n}", "target": 1}
{"code": "CURLcode Curl_urldecode(struct SessionHandle *data,\n                        const char *string, size_t length,\n                        char **ostring, size_t *olen,\n                        bool reject_ctrl)\n{\n  size_t alloc = (length?length:strlen(string))+1;\n  char *ns = malloc(alloc);\n  unsigned char in;\n  size_t strindex=0;\n  unsigned long hex;\n  CURLcode res;\n  if(!ns)\n    return CURLE_OUT_OF_MEMORY;\n  while(--alloc > 0) {\n    in = *string;\n    if(('%' == in) && (alloc > 2) &&\n       ISXDIGIT(string[1]) && ISXDIGIT(string[2])) {\n      char hexstr[3];\n      char *ptr;\n      hexstr[0] = string[1];\n      hexstr[1] = string[2];\n      hexstr[2] = 0;\n      hex = strtoul(hexstr, &ptr, 16);\n      in = curlx_ultouc(hex); \n      res = Curl_convert_from_network(data, &in, 1);\n      if(res) {\n        free(ns);\n        return res;\n      }\n      string+=2;\n      alloc-=2;\n    }\n    if(reject_ctrl && (in < 0x20)) {\n      free(ns);\n      return CURLE_URL_MALFORMAT;\n    }\n    ns[strindex++] = in;\n    string++;\n  }\n  ns[strindex]=0; \n  if(olen)\n    *olen = strindex;\n  if(ostring)\n    *ostring = ns;\n  return CURLE_OK;\n}", "target": 0}
{"code": "static Jsi_RC jsi_ArraySizeOfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    int i = Jsi_ObjGetLength(interp, _this->d.obj);\n    Jsi_ValueMakeNumber(interp, ret, i);\n    return JSI_OK;\n}", "target": 1}
{"code": "void LibRaw::fuji_compressed_load_raw()\n{\n  struct fuji_compressed_params common_info;\n  int cur_block;\n  unsigned line_size, *block_sizes;\n  INT64 raw_offset, *raw_block_offsets;\n  init_fuji_compr(&common_info);\n  line_size = sizeof(ushort) * (common_info.line_width + 2);\n  block_sizes = (unsigned *)malloc(\n      sizeof(unsigned) * libraw_internal_data.unpacker_data.fuji_total_blocks);\n  merror(block_sizes, \"fuji_compressed_load_raw()\");\n  raw_block_offsets = (INT64 *)malloc(\n      sizeof(INT64) * libraw_internal_data.unpacker_data.fuji_total_blocks);\n  merror(raw_block_offsets, \"fuji_compressed_load_raw()\");\n  raw_offset =\n      sizeof(unsigned) * libraw_internal_data.unpacker_data.fuji_total_blocks;\n  if (raw_offset & 0xC)\n    raw_offset += 0x10 - (raw_offset & 0xC);\n  raw_offset += libraw_internal_data.unpacker_data.data_offset;\n  libraw_internal_data.internal_data.input->seek(\n      libraw_internal_data.unpacker_data.data_offset, SEEK_SET);\n  libraw_internal_data.internal_data.input->read(\n      block_sizes, 1,\n      sizeof(unsigned) * libraw_internal_data.unpacker_data.fuji_total_blocks);\n  raw_block_offsets[0] = raw_offset;\n  for (cur_block = 0;\n       cur_block < libraw_internal_data.unpacker_data.fuji_total_blocks;\n       cur_block++)\n  {\n    unsigned bsize = sgetn(4, (uchar *)(block_sizes + cur_block));\n    block_sizes[cur_block] = bsize;\n  }\n  for (cur_block = 1;\n       cur_block < libraw_internal_data.unpacker_data.fuji_total_blocks;\n       cur_block++)\n    raw_block_offsets[cur_block] =\n        raw_block_offsets[cur_block - 1] + block_sizes[cur_block - 1];\n  fuji_decode_loop(&common_info,\n                   libraw_internal_data.unpacker_data.fuji_total_blocks,\n                   raw_block_offsets, block_sizes);\n  free(block_sizes);\n  free(raw_block_offsets);\n  free(common_info.q_table);\n}", "target": 0}
{"code": "rdpsnd_flush_record(void)\n{\n\tSTREAM s;\n\tunsigned int chunk_size;\n\tchar *data;\n\tif (record_buffer_size == 0)\n\t\treturn;\n\tassert(record_buffer_size <= sizeof(record_buffer));\n\tdata = record_buffer;\n\twhile (record_buffer_size)\n\t{\n\t\tif (record_buffer_size < 1596)\n\t\t\tchunk_size = record_buffer_size;\n\t\telse\n\t\t\tchunk_size = 1596;\n\t\ts = rdpsnd_init_packet(RDPSND_REC_DATA, chunk_size);\n\t\tout_uint8p(s, data, chunk_size);\n\t\ts_mark_end(s);\n\t\trdpsnd_send(s);\n\t\tdata = data + chunk_size;\n\t\trecord_buffer_size -= chunk_size;\n\t\tDEBUG_SOUND((\"RDPSND: -> RDPSND_REC_DATA(length: %u)\\n\", (unsigned) chunk_size));\n\t}\n\trecord_buffer_size = 0;\n}", "target": 0}
{"code": "is_empty(const uint8_t *data, size_t size)\n{\n\tsize_t i;\n\tfor (i = 0; i < size && data[i] != '\\n'; i++)\n\t\tif (data[i] != ' ')\n\t\t\treturn 0;\n\treturn i + 1;\n}", "target": 0}
{"code": "    inline bool match(const EndpointSecurityAttributesMask remoteMask,\n        const PluginEndpointSecurityAttributesMask remotePluginMask) const\n    {\n        return security_mask_matches(mask(), remoteMask) &&\n            security_mask_matches(plugin_endpoint_attributes, remotePluginMask);\n    }", "target": 1}
{"code": "static void zend_throw_or_error(int fetch_type, zend_class_entry *exception_ce, const char *format, ...) \n{\n\tva_list va;\n\tchar *message = NULL;\n\tva_start(va, format);\n\tzend_vspprintf(&message, 0, format, va);\n\tif (fetch_type & ZEND_FETCH_CLASS_EXCEPTION) {\n\t\tzend_throw_error(exception_ce, message);\n\t} else {\n\t\tzend_error(E_ERROR, \"%s\", message);\n\t}\n\tefree(message);\n\tva_end(va);\n}", "target": 1}
{"code": "static u32 *gen9_init_indirectctx_bb(struct intel_engine_cs *engine, u32 *batch)\n{\n\tstatic const struct lri lri[] = {\n\t\t{\n\t\t\tCOMMON_SLICE_CHICKEN2,\n\t\t\t__MASKED_FIELD(GEN9_DISABLE_GATHER_AT_SET_SHADER_COMMON_SLICE,\n\t\t\t\t       0),\n\t\t},\n\t\t{\n\t\t\tFF_SLICE_CHICKEN,\n\t\t\t__MASKED_FIELD(FF_SLICE_CHICKEN_CL_PROVOKING_VERTEX_FIX,\n\t\t\t\t       FF_SLICE_CHICKEN_CL_PROVOKING_VERTEX_FIX),\n\t\t},\n\t\t{\n\t\t\t_3D_CHICKEN3,\n\t\t\t__MASKED_FIELD(_3D_CHICKEN_SF_PROVOKING_VERTEX_FIX,\n\t\t\t\t       _3D_CHICKEN_SF_PROVOKING_VERTEX_FIX),\n\t\t}\n\t};\n\t*batch++ = MI_ARB_ON_OFF | MI_ARB_DISABLE;\n\tbatch = gen8_emit_flush_coherentl3_wa(engine, batch);\n\tbatch = gen8_emit_pipe_control(batch,\n\t\t\t\t       PIPE_CONTROL_FLUSH_L3 |\n\t\t\t\t       PIPE_CONTROL_STORE_DATA_INDEX |\n\t\t\t\t       PIPE_CONTROL_CS_STALL |\n\t\t\t\t       PIPE_CONTROL_QW_WRITE,\n\t\t\t\t       LRC_PPHWSP_SCRATCH_ADDR);\n\tbatch = emit_lri(batch, lri, ARRAY_SIZE(lri));\n\tif (HAS_POOLED_EU(engine->i915)) {\n\t\t*batch++ = GEN9_MEDIA_POOL_STATE;\n\t\t*batch++ = GEN9_MEDIA_POOL_ENABLE;\n\t\t*batch++ = 0x00777000;\n\t\t*batch++ = 0;\n\t\t*batch++ = 0;\n\t\t*batch++ = 0;\n\t}\n\t*batch++ = MI_ARB_ON_OFF | MI_ARB_ENABLE;\n\twhile ((unsigned long)batch % CACHELINE_BYTES)\n\t\t*batch++ = MI_NOOP;\n\treturn batch;\n}", "target": 0}
{"code": "cfm_network_addr_print(netdissect_options *ndo,\n                       register const u_char *tptr)\n{\n    u_int network_addr_type;\n    u_int hexdump =  FALSE;\n    network_addr_type = *tptr;\n    ND_PRINT((ndo, \"\\n\\t  Network Address Type %s (%u)\",\n           tok2str(af_values, \"Unknown\", network_addr_type),\n           network_addr_type));\n    switch(network_addr_type) {\n    case AFNUM_INET:\n        ND_PRINT((ndo, \", %s\", ipaddr_string(ndo, tptr + 1)));\n        break;\n    case AFNUM_INET6:\n        ND_PRINT((ndo, \", %s\", ip6addr_string(ndo, tptr + 1)));\n        break;\n    default:\n        hexdump = TRUE;\n        break;\n    }\n    return hexdump;\n}", "target": 1}
{"code": "static int propagateConstantExprRewrite(Walker *pWalker, Expr *pExpr){\n  int i;\n  WhereConst *pConst;\n  if( pExpr->op!=TK_COLUMN ) return WRC_Continue;\n  if( ExprHasProperty(pExpr, EP_FixedCol) ) return WRC_Continue;\n  pConst = pWalker->u.pConst;\n  for(i=0; i<pConst->nConst; i++){\n    Expr *pColumn = pConst->apExpr[i*2];\n    if( pColumn==pExpr ) continue;\n    if( pColumn->iTable!=pExpr->iTable ) continue;\n    if( pColumn->iColumn!=pExpr->iColumn ) continue;\n    pConst->nChng++;\n    ExprClearProperty(pExpr, EP_Leaf);\n    ExprSetProperty(pExpr, EP_FixedCol);\n    assert( pExpr->pLeft==0 );\n    pExpr->pLeft = sqlite3ExprDup(pConst->pParse->db, pConst->apExpr[i*2+1], 0);\n    break;\n  }\n  return WRC_Prune;\n}", "target": 1}
{"code": "static int ep_call_nested(struct nested_calls *ncalls, int max_nests,\n\t\t\t  int (*nproc)(void *, void *, int), void *priv,\n\t\t\t  void *cookie, void *ctx)\n{\n\tint error, call_nests = 0;\n\tunsigned long flags;\n\tstruct list_head *lsthead = &ncalls->tasks_call_list;\n\tstruct nested_call_node *tncur;\n\tstruct nested_call_node tnode;\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\tlist_for_each_entry(tncur, lsthead, llink) {\n\t\tif (tncur->ctx == ctx &&\n\t\t    (tncur->cookie == cookie || ++call_nests > max_nests)) {\n\t\t\terror = -1;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\ttnode.ctx = ctx;\n\ttnode.cookie = cookie;\n\tlist_add(&tnode.llink, lsthead);\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\terror = (*nproc)(priv, cookie, call_nests);\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\tlist_del(&tnode.llink);\nout_unlock:\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\treturn error;\n}", "target": 0}
{"code": "static int raw_cmd_copyout(int cmd, void __user *param,\n\t\t\t\t  struct floppy_raw_cmd *ptr)\n{\n\tint ret;\n\twhile (ptr) {\n\t\tstruct floppy_raw_cmd cmd = *ptr;\n\t\tcmd.next = NULL;\n\t\tcmd.kernel_data = NULL;\n\t\tret = copy_to_user(param, &cmd, sizeof(cmd));\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t\tparam += sizeof(struct floppy_raw_cmd);\n\t\tif ((ptr->flags & FD_RAW_READ) && ptr->buffer_length) {\n\t\t\tif (ptr->length >= 0 &&\n\t\t\t    ptr->length <= ptr->buffer_length) {\n\t\t\t\tlong length = ptr->buffer_length - ptr->length;\n\t\t\t\tret = fd_copyout(ptr->data, ptr->kernel_data,\n\t\t\t\t\t\t length);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "process_colour_pointer_common(STREAM s, int bpp)\n{\n\tuint16 width, height, cache_idx, masklen, datalen;\n\tuint16 x, y;\n\tuint8 *mask;\n\tuint8 *data;\n\tRD_HCURSOR cursor;\n\tin_uint16_le(s, cache_idx);\n\tin_uint16_le(s, x);\n\tin_uint16_le(s, y);\n\tin_uint16_le(s, width);\n\tin_uint16_le(s, height);\n\tin_uint16_le(s, masklen);\n\tin_uint16_le(s, datalen);\n\tin_uint8p(s, data, datalen);\n\tin_uint8p(s, mask, masklen);\n\tif ((width != 32) || (height != 32))\n\t{\n\t\twarning(\"process_colour_pointer_common: \" \"width %d height %d\\n\", width, height);\n\t}\n\tx = MIN(x, width - 1);\n\ty = MIN(y, height - 1);\n\tcursor = ui_create_cursor(x, y, width, height, mask, data, bpp);\n\tui_set_cursor(cursor);\n\tcache_put_cursor(cache_idx, cursor);\n}", "target": 0}
{"code": "bool V8DOMWindow::indexedSecurityCheckCustom(v8::Local<v8::Object> host, uint32_t index, v8::AccessType type, v8::Local<v8::Value>)\n{\n    v8::Isolate* isolate = v8::Isolate::GetCurrent();\n    v8::Handle<v8::Object> window = host->FindInstanceInPrototypeChain(V8DOMWindow::GetTemplate(isolate, worldTypeInMainThread(isolate)));\n    if (window.IsEmpty())\n        return false;\n    DOMWindow* targetWindow = V8DOMWindow::toNative(window);\n    ASSERT(targetWindow);\n    Frame* target = targetWindow->frame();\n    if (!target)\n        return false;\n    Frame* childFrame =  target->tree()->scopedChild(index);\n    if (target->loader()->stateMachine()->isDisplayingInitialEmptyDocument())\n        target->loader()->didAccessInitialDocument();\n    if (type == v8::ACCESS_HAS && childFrame)\n        return true;\n    if (type == v8::ACCESS_GET && childFrame && !host->HasRealIndexedProperty(index))\n        return true;\n    return BindingSecurity::shouldAllowAccessToFrame(target, DoNotReportSecurityError);\n}", "target": 0}
{"code": "static int test_x509_time(int idx)\n{\n    ASN1_TIME *t = NULL;\n    int result, rv = 0;\n    if (x509_format_tests[idx].set_string) {\n        t = ASN1_TIME_new();\n        if (t == NULL) {\n            TEST_info(\"test_x509_time(%d) failed: internal error\\n\", idx);\n            return 0;\n        }\n    }\n    result = ASN1_TIME_set_string_X509(t, x509_format_tests[idx].data);\n    if (!TEST_int_eq(result, x509_format_tests[idx].expected)) {\n        TEST_info(\"test_x509_time(%d) failed: expected %d, got %d\\n\",\n                idx, x509_format_tests[idx].expected, result);\n        goto out;\n    }\n    if (t != NULL && x509_format_tests[idx].expected_type != -1) {\n        if (!TEST_int_eq(t->type, x509_format_tests[idx].expected_type)) {\n            TEST_info(\"test_x509_time(%d) failed: expected_type %d, got %d\\n\",\n                    idx, x509_format_tests[idx].expected_type, t->type);\n            goto out;\n        }\n    }\n    if (t != NULL && x509_format_tests[idx].expected_string) {\n        if (!TEST_str_eq((const char *)t->data,\n                    x509_format_tests[idx].expected_string)) {\n            TEST_info(\"test_x509_time(%d) failed: expected_string %s, got %s\\n\",\n                    idx, x509_format_tests[idx].expected_string, t->data);\n            goto out;\n        }\n    }\n    rv = 1;\nout:\n    if (t != NULL)\n        ASN1_TIME_free(t);\n    return rv;\n}", "target": 1}
{"code": "service_info *FindServiceControlURLPath(\n\tservice_table *table, const char *controlURLPath)\n{\n\tservice_info *finger = NULL;\n\turi_type parsed_url;\n\turi_type parsed_url_in;\n\tif (table && parse_uri(controlURLPath,\n\t\t\t     strlen(controlURLPath),\n\t\t\t     &parsed_url_in) == HTTP_SUCCESS) {\n\t\tfinger = table->serviceList;\n\t\twhile (finger) {\n\t\t\tif (finger->controlURL) {\n\t\t\t\tif (parse_uri(finger->controlURL,\n\t\t\t\t\t    strlen(finger->controlURL),\n\t\t\t\t\t    &parsed_url) == HTTP_SUCCESS) {\n\t\t\t\t\tif (!token_cmp(&parsed_url.pathquery,\n\t\t\t\t\t\t    &parsed_url_in.pathquery)) {\n\t\t\t\t\t\treturn finger;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinger = finger->next;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "display_debug_macinfo (struct dwarf_section *section,\n\t\t       void *file ATTRIBUTE_UNUSED)\n{\n  unsigned char *start = section->start;\n  unsigned char *end = start + section->size;\n  unsigned char *curr = start;\n  enum dwarf_macinfo_record_type op;\n  introduce (section, false);\n  while (curr < end)\n    {\n      unsigned int lineno;\n      const unsigned char *string;\n      op = (enum dwarf_macinfo_record_type) *curr;\n      curr++;\n      switch (op)\n\t{\n\tcase DW_MACINFO_start_file:\n\t  {\n\t    unsigned int filenum;\n\t    READ_ULEB (lineno, curr, end);\n\t    READ_ULEB (filenum, curr, end);\n\t    printf (_(\" DW_MACINFO_start_file - lineno: %d filenum: %d\\n\"),\n\t\t    lineno, filenum);\n\t  }\n\t  break;\n\tcase DW_MACINFO_end_file:\n\t  printf (_(\" DW_MACINFO_end_file\\n\"));\n\t  break;\n\tcase DW_MACINFO_define:\n\t  READ_ULEB (lineno, curr, end);\n\t  string = curr;\n\t  curr += strnlen ((char *) string, end - string);\n\t  printf (_(\" DW_MACINFO_define - lineno : %d macro : %*s\\n\"),\n\t\t  lineno, (int) (curr - string), string);\n\t  if (curr < end)\n\t    curr++;\n\t  break;\n\tcase DW_MACINFO_undef:\n\t  READ_ULEB (lineno, curr, end);\n\t  string = curr;\n\t  curr += strnlen ((char *) string, end - string);\n\t  printf (_(\" DW_MACINFO_undef - lineno : %d macro : %*s\\n\"),\n\t\t  lineno, (int) (curr - string), string);\n\t  if (curr < end)\n\t    curr++;\n\t  break;\n\tcase DW_MACINFO_vendor_ext:\n\t  {\n\t    unsigned int constant;\n\t    READ_ULEB (constant, curr, end);\n\t    string = curr;\n\t    curr += strnlen ((char *) string, end - string);\n\t    printf (_(\" DW_MACINFO_vendor_ext - constant : %d string : %*s\\n\"),\n\t\t    constant, (int) (curr - string), string);\n\t    if (curr < end)\n\t      curr++;\n\t  }\n\t  break;\n\t}\n    }\n  return 1;\n}", "target": 0}
{"code": "xfs_attr_shortform_addname(xfs_da_args_t *args)\n{\n\tint newsize, forkoff, retval;\n\ttrace_xfs_attr_sf_addname(args);\n\tretval = xfs_attr_shortform_lookup(args);\n\tif ((args->flags & ATTR_REPLACE) && (retval == -ENOATTR)) {\n\t\treturn retval;\n\t} else if (retval == -EEXIST) {\n\t\tif (args->flags & ATTR_CREATE)\n\t\t\treturn retval;\n\t\tretval = xfs_attr_shortform_remove(args);\n\t\tASSERT(retval == 0);\n\t}\n\tif (args->namelen >= XFS_ATTR_SF_ENTSIZE_MAX ||\n\t    args->valuelen >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\treturn -ENOSPC;\n\tnewsize = XFS_ATTR_SF_TOTSIZE(args->dp);\n\tnewsize += XFS_ATTR_SF_ENTSIZE_BYNAME(args->namelen, args->valuelen);\n\tforkoff = xfs_attr_shortform_bytesfit(args->dp, newsize);\n\tif (!forkoff)\n\t\treturn -ENOSPC;\n\txfs_attr_shortform_add(args, forkoff);\n\treturn 0;\n}", "target": 1}
{"code": "static struct nfs4_state *nfs4_do_open(struct inode *dir, struct path *path, int flags, struct iattr *sattr, struct rpc_cred *cred)\n{\n\tstruct nfs4_exception exception = { };\n\tstruct nfs4_state *res;\n\tint status;\n\tdo {\n\t\tstatus = _nfs4_do_open(dir, path, flags, sattr, cred, &res);\n\t\tif (status == 0)\n\t\t\tbreak;\n\t\tif (status == -NFS4ERR_BAD_SEQID) {\n\t\t\tprintk(KERN_WARNING \"NFS: v4 server %s \"\n\t\t\t\t\t\" returned a bad sequence-id error!\\n\",\n\t\t\t\t\tNFS_SERVER(dir)->nfs_client->cl_hostname);\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (status == -NFS4ERR_BAD_STATEID) {\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (status == -EAGAIN) {\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tres = ERR_PTR(nfs4_handle_exception(NFS_SERVER(dir),\n\t\t\t\t\tstatus, &exception));\n\t} while (exception.retry);\n\treturn res;\n}", "target": 1}
{"code": "virStoragePoolObjBuildTempFilePath(virStoragePoolObj *obj,\n                                   virStorageVolDef *voldef)\n{\n    virStoragePoolDef *def = virStoragePoolObjGetDef(obj);\n    return g_strdup_printf(\"%s/%s.%s.secret.XXXXXX\", driver->stateDir,\n                           def->name, voldef->name);\n}", "target": 0}
{"code": "AsyncSocket::WriteResult AsyncSSLSocket::interpretSSLError(int rc, int error) {\n  if (error == SSL_ERROR_WANT_READ) {\n    LOG(ERROR) << \"AsyncSSLSocket(fd=\" << fd_ << \", state=\" << int(state_)\n               << \", sslState=\" << sslState_ << \", events=\" << eventFlags_\n               << \"): \"\n               << \"unsupported SSL renegotiation during write\";\n    return WriteResult(\n        WRITE_ERROR,\n        std::make_unique<SSLException>(SSLError::INVALID_RENEGOTIATION));\n  } else {\n    if (zero_return(error, rc, errno)) {\n      return WriteResult(0);\n    }\n    auto errError = ERR_get_error();\n    VLOG(3) << \"ERROR: AsyncSSLSocket(fd=\" << fd_ << \", state=\" << int(state_)\n            << \", sslState=\" << sslState_ << \", events=\" << eventFlags_ << \"): \"\n            << \"SSL error: \" << error << \", errno: \" << errno\n            << \", func: \" << ERR_func_error_string(errError)\n            << \", reason: \" << ERR_reason_error_string(errError);\n    return WriteResult(\n        WRITE_ERROR,\n        std::make_unique<SSLException>(error, errError, rc, errno));\n  }\n}", "target": 1}
{"code": "int create_user_ns(struct cred *new)\n{\n\tstruct user_namespace *ns, *parent_ns = new->user_ns;\n\tkuid_t owner = new->euid;\n\tkgid_t group = new->egid;\n\tint ret;\n\tif (current_chrooted())\n\t\treturn -EPERM;\n\tif (!kuid_has_mapping(parent_ns, owner) ||\n\t    !kgid_has_mapping(parent_ns, group))\n\t\treturn -EPERM;\n\tns = kmem_cache_zalloc(user_ns_cachep, GFP_KERNEL);\n\tif (!ns)\n\t\treturn -ENOMEM;\n\tret = proc_alloc_inum(&ns->proc_inum);\n\tif (ret) {\n\t\tkmem_cache_free(user_ns_cachep, ns);\n\t\treturn ret;\n\t}\n\tatomic_set(&ns->count, 1);\n\tns->parent = parent_ns;\n\tns->owner = owner;\n\tns->group = group;\n\tset_cred_user_ns(new, ns);\n\treturn 0;\n}", "target": 0}
{"code": "rend_service_intro_established(origin_circuit_t *circuit,\n                               const uint8_t *request,\n                               size_t request_len)\n{\n  rend_service_t *service;\n  rend_intro_point_t *intro;\n  char serviceid[REND_SERVICE_ID_LEN_BASE32+1];\n  (void) request;\n  (void) request_len;\n  tor_assert(circuit->rend_data);\n  const char *rend_pk_digest =\n    (char *) rend_data_get_pk_digest(circuit->rend_data, NULL);\n  if (circuit->base_.purpose != CIRCUIT_PURPOSE_S_ESTABLISH_INTRO) {\n    log_warn(LD_PROTOCOL,\n             \"received INTRO_ESTABLISHED cell on non-intro circuit.\");\n    goto err;\n  }\n  service = rend_service_get_by_pk_digest(rend_pk_digest);\n  if (!service) {\n    log_warn(LD_REND, \"Unknown service on introduction circuit %u.\",\n              (unsigned)circuit->base_.n_circ_id);\n     goto err;\n   }\n   intro = find_intro_point(circuit);\n  if (intro == NULL) {\n    log_warn(LD_REND,\n             \"Introduction circuit established without a rend_intro_point_t \"\n             \"object for service %s on circuit %u\",\n             safe_str_client(serviceid), (unsigned)circuit->base_.n_circ_id);\n    goto err;\n  }\n  intro->circuit_established = 1;\n   service->desc_is_dirty = time(NULL);\n   circuit_change_purpose(TO_CIRCUIT(circuit), CIRCUIT_PURPOSE_S_INTRO);\n  base32_encode(serviceid, REND_SERVICE_ID_LEN_BASE32 + 1,\n                rend_pk_digest, REND_SERVICE_ID_LEN);\n   log_info(LD_REND,\n            \"Received INTRO_ESTABLISHED cell on circuit %u for service %s\",\n            (unsigned)circuit->base_.n_circ_id, serviceid);\n  pathbias_mark_use_success(circuit);\n  return 0;\n err:\n  circuit_mark_for_close(TO_CIRCUIT(circuit), END_CIRC_REASON_TORPROTOCOL);\n  return -1;\n}", "target": 1}
{"code": "struct key *find_keyring_by_name(const char *name, bool skip_perm_check)\n{\n\tstruct key *keyring;\n\tint bucket;\n\tkeyring = ERR_PTR(-EINVAL);\n\tif (!name)\n\t\tgoto error;\n\tbucket = keyring_hash(name);\n\tread_lock(&keyring_name_lock);\n\tif (keyring_name_hash[bucket].next) {\n\t\tlist_for_each_entry(keyring,\n\t\t\t\t    &keyring_name_hash[bucket],\n\t\t\t\t    type_data.link\n\t\t\t\t    ) {\n\t\t\tif (keyring->user->user_ns != current_user_ns())\n\t\t\t\tcontinue;\n\t\t\tif (test_bit(KEY_FLAG_REVOKED, &keyring->flags))\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(keyring->description, name) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (!skip_perm_check &&\n\t\t\t    key_permission(make_key_ref(keyring, 0),\n\t\t\t\t\t   KEY_SEARCH) < 0)\n\t\t\t\tcontinue;\n\t\t\tatomic_inc(&keyring->usage);\n\t\t\tread_unlock(&keyring_name_lock);\n\t\t\tgoto error;\n\t\t}\n\t}\n\tread_unlock(&keyring_name_lock);\n\tkeyring = ERR_PTR(-ENOKEY);\n error:\n\treturn keyring;\n} ", "target": 1}
{"code": "void pushGenericCommand(client *c, int where) {\n    int j, pushed = 0;\n    for (j = 2; j < c->argc; j++) {\n        if (sdslen(c->argv[j]->ptr) > LIST_MAX_ITEM_SIZE) {\n            addReplyError(c, \"Element too large\");\n            return;\n        }\n    }\n    robj *lobj = lookupKeyWrite(c->db,c->argv[1]);\n    if (lobj && lobj->type != OBJ_LIST) {\n        addReply(c,shared.wrongtypeerr);\n        return;\n    }\n    for (j = 2; j < c->argc; j++) {\n        if (!lobj) {\n            lobj = createQuicklistObject();\n            quicklistSetOptions(lobj->ptr, server.list_max_ziplist_size,\n                                server.list_compress_depth);\n            dbAdd(c->db,c->argv[1],lobj);\n        }\n        listTypePush(lobj,c->argv[j],where);\n        pushed++;\n    }\n    addReplyLongLong(c, (lobj ? listTypeLength(lobj) : 0));\n    if (pushed) {\n        char *event = (where == LIST_HEAD) ? \"lpush\" : \"rpush\";\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_LIST,event,c->argv[1],c->db->id);\n    }\n    server.dirty += pushed;\n}", "target": 0}
{"code": "TEST(ArrayOpsTest, QuantizeAndDequantizeV2_ShapeFn) {\n  ShapeInferenceTestOp op(\"QuantizeAndDequantizeV2\");\n  op.input_tensors.resize(3);\n  TF_ASSERT_OK(NodeDefBuilder(\"test\", \"QuantizeAndDequantizeV2\")\n                   .Input(\"input\", 0, DT_FLOAT)\n                   .Input(\"input_min\", 1, DT_FLOAT)\n                   .Input(\"input_max\", 2, DT_FLOAT)\n                   .Attr(\"signed_input\", true)\n                   .Attr(\"num_bits\", 8)\n                   .Attr(\"range_given\", false)\n                   .Attr(\"narrow_range\", false)\n                   .Attr(\"axis\", -1)\n                   .Finalize(&op.node_def));\n  INFER_OK(op, \"?;?;?\", \"in0\");\n  INFER_OK(op, \"[];?;?\", \"in0\");\n  INFER_OK(op, \"[1,2,?,4,5];?;?\", \"in0\");\n  INFER_ERROR(\"Shape must be rank 0 but is rank 1\", op, \"[1,2,?,4,5];[1];[]\");\n  INFER_ERROR(\"Shapes must be equal rank, but are 1 and 0\", op,\n              \"[1,2,?,4,5];[];[1]\");\n  INFER_ERROR(\"Shape must be rank 0 but is rank 1\", op, \"[1,2,?,4,5];[1];[1]\");\n}", "target": 1}
{"code": "void Module::setSource(Module *module) { m_source = module; }", "target": 0}
{"code": "static void __init acpi_request_region (struct acpi_generic_address *gas,\n\tunsigned int length, char *desc)\n{\n\tu64 addr;\n\tmemcpy(&addr, &gas->address, sizeof(addr));\n\tif (!addr || !length)\n\t\treturn;\n\tif (gas->space_id == ACPI_ADR_SPACE_SYSTEM_IO)\n\t\trequest_region(addr, length, desc);\n\telse if (gas->space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY)\n\t\trequest_mem_region(addr, length, desc);\n}", "target": 0}
{"code": "static int checkout_verify_paths(\n\tgit_repository *repo,\n\tint action,\n\tgit_diff_delta *delta)\n{\n\tunsigned int flags = GIT_PATH_REJECT_WORKDIR_DEFAULTS;\n\tif (action & CHECKOUT_ACTION__REMOVE) {\n\t\tif (!git_path_isvalid(repo, delta->old_file.path, delta->old_file.mode, flags)) {\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"cannot remove invalid path '%s'\", delta->old_file.path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (action & ~CHECKOUT_ACTION__REMOVE) {\n\t\tif (!git_path_isvalid(repo, delta->new_file.path, delta->new_file.mode, flags)) {\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"cannot checkout to invalid path '%s'\", delta->new_file.path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static void sas_scsi_clear_queue_lu(struct list_head *error_q, struct scsi_cmnd *my_cmd)\n{\n\tstruct scsi_cmnd *cmd, *n;\n\tlist_for_each_entry_safe(cmd, n, error_q, eh_entry) {\n\t\tif (cmd->device->sdev_target == my_cmd->device->sdev_target &&\n\t\t    cmd->device->lun == my_cmd->device->lun)\n\t\t\tsas_eh_defer_cmd(cmd);\n\t}\n}", "target": 1}
{"code": "add_header (char *name, char *value, int mode)\n{\n  struct add_header *hp;\n  if (!add_header_list)\n    {\n      int rc = mu_list_create (&add_header_list);\n      if (rc)\n\t{\n\t  mu_error (_(\"Cannot create header list: %s\"), mu_strerror (rc));\n\t  exit (1);\n\t}\n    }\n  hp = mu_alloc (sizeof (*hp));\n  hp->mode = mode;\n  hp->name = name;\n  hp->value = value;\n  mu_list_append (add_header_list, hp);\n}", "target": 0}
{"code": "bool st_select_lex::setup_ref_array(THD *thd, uint order_group_num)\n{\n  if (!((options & SELECT_DISTINCT) && !group_list.elements))\n    hidden_bit_fields= 0;\n  order_group_num*= 2;\n  Query_arena *arena= thd->stmt_arena;\n  const uint n_elems= (n_sum_items +\n                       n_child_sum_items +\n                       item_list.elements +\n                       select_n_reserved +\n                       select_n_having_items +\n                       select_n_where_fields +\n                       order_group_num +\n                       hidden_bit_fields +\n                       fields_in_window_functions) * 5;\n  if (!ref_pointer_array.is_null())\n  {\n    if (ref_pointer_array.size() >= n_elems)\n      return false;\n   }\n  Item **array= static_cast<Item**>(arena->alloc(sizeof(Item*) * n_elems));\n  if (array != NULL)\n    ref_pointer_array= Ref_ptr_array(array, n_elems);\n  return array == NULL;\n}", "target": 1}
{"code": "find_extend_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma, *prev;\n\taddr &= PAGE_MASK;\n\tvma = find_vma_prev(mm, addr, &prev);\n\tif (vma && (vma->vm_start <= addr))\n\t\treturn vma;\n\tif (!prev || expand_stack(prev, addr))\n\t\treturn NULL;\n\tif (prev->vm_flags & VM_LOCKED)\n\t\tpopulate_vma_page_range(prev, addr, prev->vm_end, NULL);\n\treturn prev;\n}", "target": 1}
{"code": "static void sixpack_close(struct tty_struct *tty)\n{\n\tstruct sixpack *sp;\n\twrite_lock_irq(&disc_data_lock);\n\tsp = tty->disc_data;\n\ttty->disc_data = NULL;\n\twrite_unlock_irq(&disc_data_lock);\n\tif (!sp)\n\t\treturn;\n\tif (!refcount_dec_and_test(&sp->refcnt))\n\t\twait_for_completion(&sp->dead);\n\tnetif_stop_queue(sp->dev);\n\tdel_timer_sync(&sp->tx_t);\n\tdel_timer_sync(&sp->resync_t);\n\tunregister_netdev(sp->dev);\n\tkfree(sp->rbuff);\n\tkfree(sp->xbuff);\n\tfree_netdev(sp->dev);\n}", "target": 1}
{"code": "void SetColor(double c, double m, double y, double k,int par)\n{\n    if ( par == STROKING ) {\n        outpos += sprintf(outpos,\" %12.3f %12.3f %12.3f %12.3f K\",c,m,y,k);\n    }\n    else {\n        outpos += sprintf(outpos,\" %12.3f %12.3f %12.3f %12.3f k\",c,m,y,k);\n    }\n}", "target": 1}
{"code": "NAN_METHOD(DetectCharacterEncoding) {\n\tNan::HandleScope scope;\n\tv8::Local<v8::Object> inputBuffer = info[0]->ToObject();\n\tUCharsetDetector *charsetDetector;\n\tconst UCharsetMatch *charsetMatch;\n\tUErrorCode errorCode = U_ZERO_ERROR;\n\tcharsetDetector = ucsdet_open(&errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to open ICU charset detector.\");\n\t\treturn;\n\t}\n\tucsdet_setText(\n\t\tcharsetDetector,\n\t\tnode::Buffer::Data(inputBuffer),\n\t\tnode::Buffer::Length(inputBuffer),\n\t\t&errorCode\n\t);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to set ICU charset detector’s text.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tcharsetMatch = ucsdet_detect(charsetDetector, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to detect charset.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tconst char *charsetName = ucsdet_getName(charsetMatch, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get name from charset match.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tint32_t confidence = ucsdet_getConfidence(charsetMatch, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get confidence from charset match.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tv8::Local<v8::Object> obj = Nan::New<v8::Object>();\n\tobj->Set(Nan::New<v8::String>(\"encoding\").ToLocalChecked(), Nan::New<v8::String>(charsetName).ToLocalChecked());\n\tobj->Set(Nan::New<v8::String>(\"confidence\").ToLocalChecked(), Nan::New<v8::Number>(confidence));\n\tinfo.GetReturnValue().Set(obj);\n\tucsdet_close(charsetDetector);\n}", "target": 0}
{"code": "static int get_bitmap_file(struct mddev *mddev, void __user * arg)\n{\n\tmdu_bitmap_file_t *file = NULL; \n\tchar *ptr;\n\tint err;\n\tfile = kmalloc(sizeof(*file), GFP_NOIO);\n\tif (!file)\n\t\treturn -ENOMEM;\n\terr = 0;\n\tspin_lock(&mddev->lock);\n\tif (!mddev->bitmap_info.file)\n\t\tfile->pathname[0] = '\\0';\n\telse if ((ptr = file_path(mddev->bitmap_info.file,\n\t\t\t       file->pathname, sizeof(file->pathname))),\n\t\t IS_ERR(ptr))\n\t\terr = PTR_ERR(ptr);\n\telse\n\t\tmemmove(file->pathname, ptr,\n\t\t\tsizeof(file->pathname)-(ptr-file->pathname));\n\tspin_unlock(&mddev->lock);\n\tif (err == 0 &&\n\t    copy_to_user(arg, file, sizeof(*file)))\n\t\terr = -EFAULT;\n\tkfree(file);\n\treturn err;\n}", "target": 1}
{"code": "static int iscleared (global_State *g, const GCObject *o) {\n  if (o == NULL) return 0;  \n  else if (novariant(o->tt) == LUA_TSTRING) {\n    markobject(g, o);  \n    return 0;\n  }\n  else return iswhite(o);\n}", "target": 0}
{"code": "static int pfkey_get(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\t__u8 proto;\n\tstruct sk_buff *out_skb;\n\tstruct sadb_msg *out_hdr;\n\tstruct xfrm_state *x;\n\tif (!ext_hdrs[SADB_EXT_SA-1] ||\n\t    !present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC-1],\n\t\t\t\t     ext_hdrs[SADB_EXT_ADDRESS_DST-1]))\n\t\treturn -EINVAL;\n\tx = pfkey_xfrm_state_lookup(net, hdr, ext_hdrs);\n\tif (x == NULL)\n\t\treturn -ESRCH;\n\tout_skb = pfkey_xfrm_state2msg(x);\n\tproto = x->id.proto;\n\txfrm_state_put(x);\n\tif (IS_ERR(out_skb))\n\t\treturn  PTR_ERR(out_skb);\n\tout_hdr = (struct sadb_msg *) out_skb->data;\n\tout_hdr->sadb_msg_version = hdr->sadb_msg_version;\n\tout_hdr->sadb_msg_type = SADB_GET;\n\tout_hdr->sadb_msg_satype = pfkey_proto2satype(proto);\n\tout_hdr->sadb_msg_errno = 0;\n\tout_hdr->sadb_msg_reserved = 0;\n\tout_hdr->sadb_msg_seq = hdr->sadb_msg_seq;\n\tout_hdr->sadb_msg_pid = hdr->sadb_msg_pid;\n\tpfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_ONE, sk, sock_net(sk));\n\treturn 0;\n}", "target": 0}
{"code": "void IGDstartelt(void * d, const char * name, int l)\n{\n\tstruct IGDdatas * datas = (struct IGDdatas *)d;\n\tmemcpy( datas->cureltname, name, l);\n\tdatas->cureltname[l] = '\\0';\n\tdatas->level++;\n\tif( (l==7) && !memcmp(name, \"service\", l) ) {\n\t\tdatas->tmp.controlurl[0] = '\\0';\n\t\tdatas->tmp.eventsuburl[0] = '\\0';\n\t\tdatas->tmp.scpdurl[0] = '\\0';\n\t\tdatas->tmp.servicetype[0] = '\\0';\n\t}\n}", "target": 1}
{"code": "PerformanceNavigationTiming::PerformanceNavigationTiming(\n    LocalFrame* frame,\n     ResourceTimingInfo* info,\n     TimeTicks time_origin,\n     const WebVector<WebServerTimingInfo>& server_timing)\n    : PerformanceResourceTiming(info ? info->InitialURL().GetString() : \"\",\n                                \"navigation\",\n                                time_origin,\n                                server_timing),\n       ContextClient(frame),\n       resource_timing_info_(info) {\n   DCHECK(frame);\n  DCHECK(info);\n}", "target": 1}
{"code": "nfsd4_setattr(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t      union nfsd4_op_u *u)\n{\n\tstruct nfsd4_setattr *setattr = &u->setattr;\n\t__be32 status = nfs_ok;\n\tint err;\n\tif (setattr->sa_iattr.ia_valid & ATTR_SIZE) {\n\t\tstatus = nfs4_preprocess_stateid_op(rqstp, cstate,\n\t\t\t\t&cstate->current_fh, &setattr->sa_stateid,\n\t\t\t\tWR_STATE, NULL, NULL);\n\t\tif (status) {\n\t\t\tdprintk(\"NFSD: nfsd4_setattr: couldn't process stateid!\\n\");\n\t\t\treturn status;\n\t\t}\n\t}\n\terr = fh_want_write(&cstate->current_fh);\n\tif (err)\n\t\treturn nfserrno(err);\n\tstatus = nfs_ok;\n\tstatus = check_attr_support(rqstp, cstate, setattr->sa_bmval,\n\t\t\t\t    nfsd_attrmask);\n\tif (status)\n\t\tgoto out;\n\tif (setattr->sa_acl != NULL)\n\t\tstatus = nfsd4_set_nfs4_acl(rqstp, &cstate->current_fh,\n\t\t\t\t\t    setattr->sa_acl);\n\tif (status)\n\t\tgoto out;\n\tif (setattr->sa_label.len)\n\t\tstatus = nfsd4_set_nfs4_label(rqstp, &cstate->current_fh,\n\t\t\t\t&setattr->sa_label);\n\tif (status)\n\t\tgoto out;\n\tstatus = nfsd_setattr(rqstp, &cstate->current_fh, &setattr->sa_iattr,\n\t\t\t\t0, (time_t)0);\nout:\n\tfh_drop_write(&cstate->current_fh);\n\treturn status;\n}", "target": 0}
{"code": "static struct media_item *parse_media_folder(struct avrcp *session,\n\t\t\t\t\tuint8_t *operands, uint16_t len)\n{\n\tstruct avrcp_player *player = session->controller->player;\n\tstruct media_player *mp = player->user_data;\n\tstruct media_item *item;\n\tuint16_t namelen;\n\tchar name[255];\n\tuint64_t uid;\n\tuint8_t type;\n\tuint8_t playable;\n\tif (len < 12)\n\t\treturn NULL;\n\tuid = get_be64(&operands[0]);\n\ttype = operands[8];\n\tplayable = operands[9];\n\tnamelen = MIN(get_be16(&operands[12]), sizeof(name) - 1);\n\tif (namelen > 0) {\n\t\tmemcpy(name, &operands[14], namelen);\n\t\tname[namelen] = '\\0';\n\t}\n\titem = media_player_create_folder(mp, name, type, uid);\n\tif (!item)\n\t\treturn NULL;\n\tmedia_item_set_playable(item, playable & 0x01);\n\treturn item;\n}", "target": 0}
{"code": "WCHAR* VDir::MapPathW(const WCHAR *pInName)\n{   \n    WCHAR szBuffer[(MAX_PATH+1)*2];\n    WCHAR szlBuf[MAX_PATH+1];\n    int length = wcslen(pInName);\n    if (!length)\n\treturn (WCHAR*)pInName;\n    if (length > MAX_PATH) {\n\twcsncpy(szlBuf, pInName, MAX_PATH);\n\tif (IsPathSep(pInName[0]) && !IsPathSep(pInName[1])) {   \n\t    szlBuf[MAX_PATH-2] = '\\0';\n\t}\n\telse\n\t    szlBuf[MAX_PATH] = '\\0';\n\tpInName = szlBuf;\n    }\n    if (pInName[1] == ':') {\n\tif (IsPathSep(pInName[2])) {\n\t    DoGetFullPathNameW((WCHAR*)pInName, (sizeof(szLocalBufferW)/sizeof(WCHAR)), szLocalBufferW);\n\t}\n\telse {\n\t    wcscpy(szBuffer, GetDirW(DriveIndex((char)*pInName)));\n\t    wcscat(szBuffer, &pInName[2]);\n\t    if(wcslen(szBuffer) > MAX_PATH)\n\t\tszBuffer[MAX_PATH] = '\\0';\n\t    DoGetFullPathNameW(szBuffer, (sizeof(szLocalBufferW)/sizeof(WCHAR)), szLocalBufferW);\n\t}\n    }\n    else {\n\tif (IsPathSep(pInName[1]) && IsPathSep(pInName[0])) {\n\t    DoGetFullPathNameW((WCHAR*)pInName, (sizeof(szLocalBufferW)/sizeof(WCHAR)), szLocalBufferW);\n\t}\n\telse {\n\t    wcscpy(szBuffer, GetDefaultDirW());\n\t    if (IsPathSep(pInName[0])) {\n\t\twcscpy(&szBuffer[2], pInName);\n\t\tDoGetFullPathNameW(szBuffer, (sizeof(szLocalBufferW)/sizeof(WCHAR)), szLocalBufferW);\n\t    }\n\t    else {\n\t\tif (IsSpecialFileName(pInName)) {\n\t\t    return (WCHAR*)pInName;\n\t\t}\n\t\telse {\n\t\t    wcscat(szBuffer, pInName);\n\t\t    if (wcslen(szBuffer) > MAX_PATH)\n\t\t\tszBuffer[MAX_PATH] = '\\0';\n\t\t    DoGetFullPathNameW(szBuffer, (sizeof(szLocalBufferW)/sizeof(WCHAR)), szLocalBufferW);\n\t\t}\n\t    }\n\t}\n    }\n    return szLocalBufferW;\n}", "target": 1}
{"code": "int ext4_mark_iloc_dirty(handle_t *handle,\n\t\t\t struct inode *inode, struct ext4_iloc *iloc)\n{\n\tint err = 0;\n\tif (unlikely(ext4_forced_shutdown(EXT4_SB(inode->i_sb))))\n\t\treturn -EIO;\n\tif (IS_I_VERSION(inode))\n\t\tinode_inc_iversion(inode);\n\tget_bh(iloc->bh);\n\terr = ext4_do_update_inode(handle, inode, iloc);\n\tput_bh(iloc->bh);\n\treturn err;\n}", "target": 0}
{"code": "static unsigned short get_ushort(const unsigned char *data)\n{\n    unsigned short val = *(const unsigned short *)data;\n#ifdef OPJ_BIG_ENDIAN\n    val = ((val & 0xffU) << 8) | (val >> 8);\n#endif\n    return val;\n}", "target": 1}
{"code": "PHP_MINFO_FUNCTION(mcrypt) \n{\n\tchar **modules;\n\tchar mcrypt_api_no[16];\n\tint i, count;\n\tsmart_str tmp1 = {0};\n\tsmart_str tmp2 = {0};\n\tmodules = mcrypt_list_algorithms(MCG(algorithms_dir), &count);\n\tif (count == 0) {\n\t\tsmart_str_appends(&tmp1, \"none\");\n\t}\n\tfor (i = 0; i < count; i++) {\n\t\tsmart_str_appends(&tmp1, modules[i]);\n\t\tsmart_str_appendc(&tmp1, ' ');\n\t}\n\tsmart_str_0(&tmp1);\n\tmcrypt_free_p(modules, count);\n\tmodules = mcrypt_list_modes(MCG(modes_dir), &count);\n\tif (count == 0) {\n\t\tsmart_str_appends(&tmp2, \"none\");\n\t}\n\tfor (i = 0; i < count; i++) {\n\t\tsmart_str_appends(&tmp2, modules[i]);\n\t\tsmart_str_appendc(&tmp2, ' ');\n\t}\n\tsmart_str_0 (&tmp2);\n\tmcrypt_free_p (modules, count);\n\tsnprintf (mcrypt_api_no, 16, \"%d\", MCRYPT_API_VERSION);\n\tphp_info_print_table_start();\n\tphp_info_print_table_header(2, \"mcrypt support\", \"enabled\");\n\tphp_info_print_table_header(2, \"mcrypt_filter support\", \"enabled\");\n\tphp_info_print_table_row(2, \"Version\", LIBMCRYPT_VERSION);\n\tphp_info_print_table_row(2, \"Api No\", mcrypt_api_no);\n\tphp_info_print_table_row(2, \"Supported ciphers\", tmp1.c);\n\tphp_info_print_table_row(2, \"Supported modes\", tmp2.c);\n\tsmart_str_free(&tmp1);\n\tsmart_str_free(&tmp2);\n\tphp_info_print_table_end();\n\tDISPLAY_INI_ENTRIES();", "target": 1}
{"code": "void WebContentsImpl::SetIsCrashed(base::TerminationStatus status,\n                                   int error_code) {\n  if (status == crashed_status_)\n    return;\n  crashed_status_ = status;\n  crashed_error_code_ = error_code;\n  NotifyNavigationStateChanged(INVALIDATE_TYPE_TAB);\n}", "target": 0}
{"code": "usm_free_usmStateReference(void *old)\n{\n    struct usmStateReference *old_ref = (struct usmStateReference *) old;\n    if (old_ref) {\n        if (old_ref->usr_name_length)\n            SNMP_FREE(old_ref->usr_name);\n        if (old_ref->usr_engine_id_length)\n            SNMP_FREE(old_ref->usr_engine_id);\n        if (old_ref->usr_auth_protocol_length)\n            SNMP_FREE(old_ref->usr_auth_protocol);\n        if (old_ref->usr_priv_protocol_length)\n            SNMP_FREE(old_ref->usr_priv_protocol);\n        if (old_ref->usr_auth_key_length && old_ref->usr_auth_key) {\n            SNMP_ZERO(old_ref->usr_auth_key, old_ref->usr_auth_key_length);\n            SNMP_FREE(old_ref->usr_auth_key);\n        }\n        if (old_ref->usr_priv_key_length && old_ref->usr_priv_key) {\n            SNMP_ZERO(old_ref->usr_priv_key, old_ref->usr_priv_key_length);\n            SNMP_FREE(old_ref->usr_priv_key);\n        }\n        SNMP_ZERO(old_ref, sizeof(*old_ref));\n        SNMP_FREE(old_ref);\n    }\n}                               ", "target": 1}
{"code": "    void CiffComponent::doPrint(std::ostream&      os,\n                                ByteOrder          byteOrder,\n                                const std::string& prefix) const\n    {\n        os << prefix\n           << _(\"tag\") << \" = 0x\" << std::setw(4) << std::setfill('0')\n           << std::hex << std::right << tagId()\n           << \", \" << _(\"dir\") << \" = 0x\" << std::setw(4) << std::setfill('0')\n           << std::hex << std::right << dir()\n           << \", \" << _(\"type\") << \" = \" << TypeInfo::typeName(typeId())\n           << \", \" << _(\"size\") << \" = \" << std::dec << size_\n           << \", \" << _(\"offset\") << \" = \" << offset_ << \"\\n\";\n        Value::UniquePtr value;\n        if (typeId() != directory) {\n            value = Value::create(typeId());\n            value->read(pData_, size_, byteOrder);\n            if (value->size() < 100) {\n                os << prefix << *value << \"\\n\";\n            }\n        }\n    } ", "target": 0}
{"code": "static inline struct keydata *get_keyptr(void)\n{\n\tstruct keydata *keyptr = &ip_keydata[ip_cnt & 1];\n\tsmp_rmb();\n\treturn keyptr;\n}", "target": 1}
{"code": "static int rtnl_group_dellink(const struct net *net, int group)\n{\n\tstruct net_device *dev, *aux;\n\tLIST_HEAD(list_kill);\n\tbool found = false;\n\tif (!group)\n\t\treturn -EPERM;\n\tfor_each_netdev(net, dev) {\n\t\tif (dev->group == group) {\n\t\t\tconst struct rtnl_link_ops *ops;\n\t\t\tfound = true;\n\t\t\tops = dev->rtnl_link_ops;\n\t\t\tif (!ops || !ops->dellink)\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\tif (!found)\n\t\treturn -ENODEV;\n\tfor_each_netdev_safe(net, dev, aux) {\n\t\tif (dev->group == group) {\n\t\t\tconst struct rtnl_link_ops *ops;\n\t\t\tops = dev->rtnl_link_ops;\n\t\t\tops->dellink(dev, &list_kill);\n\t\t}\n\t}\n\tunregister_netdevice_many(&list_kill);\n\treturn 0;\n}", "target": 0}
{"code": "void nfs4_close_sync(struct path *path, struct nfs4_state *state, mode_t mode)\n{\n\t__nfs4_close(path, state, mode, 1);\n}", "target": 1}
{"code": "int devmem_is_allowed(unsigned long pagenr)\n{\n\tif (pagenr < 256)\n\t\treturn 1;\n\tif (iomem_is_exclusive(pagenr << PAGE_SHIFT))\n\t\treturn 0;\n\tif (!page_is_ram(pagenr))\n\t\treturn 1;\n\treturn 0;\n}", "target": 1}
{"code": "static void kvmclock_reset(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->arch.time_page) {\n\t\tkvm_release_page_dirty(vcpu->arch.time_page);\n\t\tvcpu->arch.time_page = NULL;\n\t}\n}", "target": 1}
{"code": "xmlCopyAttribute(xmlAttributePtr attr) {\n    xmlAttributePtr cur;\n    cur = (xmlAttributePtr) xmlMalloc(sizeof(xmlAttribute));\n    if (cur == NULL) {\n\txmlVErrMemory(NULL, \"malloc failed\");\n\treturn(NULL);\n    }\n    memset(cur, 0, sizeof(xmlAttribute));\n    cur->type = XML_ATTRIBUTE_DECL;\n    cur->atype = attr->atype;\n    cur->def = attr->def;\n    cur->tree = xmlCopyEnumeration(attr->tree);\n    if (attr->elem != NULL)\n\tcur->elem = xmlStrdup(attr->elem);\n    if (attr->name != NULL)\n\tcur->name = xmlStrdup(attr->name);\n    if (attr->prefix != NULL)\n\tcur->prefix = xmlStrdup(attr->prefix);\n    if (attr->defaultValue != NULL)\n\tcur->defaultValue = xmlStrdup(attr->defaultValue);\n    return(cur);\n}", "target": 0}
{"code": "GF_Err stbl_AppendTime(GF_SampleTableBox *stbl, u32 duration, u32 nb_pack)\n{\n\tGF_TimeToSampleBox *stts = stbl->TimeToSample;\n\tif (!nb_pack) nb_pack = 1;\n\tif (stts->nb_entries) {\n\t\tif (stts->entries[stts->nb_entries-1].sampleDelta == duration) {\n\t\t\tstts->entries[stts->nb_entries-1].sampleCount += nb_pack;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\tif (stts->nb_entries==stts->alloc_size) {\n\t\tALLOC_INC(stts->alloc_size);\n\t\tstts->entries = gf_realloc(stts->entries, sizeof(GF_SttsEntry)*stts->alloc_size);\n\t\tif (!stts->entries) return GF_OUT_OF_MEM;\n\t\tmemset(&stts->entries[stts->nb_entries], 0, sizeof(GF_SttsEntry)*(stts->alloc_size-stts->nb_entries) );\n\t}\n\tstts->entries[stts->nb_entries].sampleCount = nb_pack;\n\tstts->entries[stts->nb_entries].sampleDelta = duration;\n\tstts->nb_entries++;\n\tif (stts->max_ts_delta < duration ) stts->max_ts_delta = duration;\n\treturn GF_OK;\n}", "target": 1}
{"code": "minimask_equal(const struct minimask *a, const struct minimask *b)\n{\n    return !memcmp(a, b, sizeof *a\n                   + MINIFLOW_VALUES_SIZE(miniflow_n_values(&a->masks)));\n}", "target": 1}
{"code": "static pj_status_t decode_uint_attr(pj_pool_t *pool, \n                                    const pj_uint8_t *buf, \n                                    const pj_stun_msg_hdr *msghdr, \n                                    void **p_attr)\n{\n    pj_stun_uint_attr *attr;\n    PJ_UNUSED_ARG(msghdr);\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_uint_attr);\n    GETATTRHDR(buf, &attr->hdr);\n    attr->value = GETVAL32H(buf, 4);\n    if (attr->hdr.length != 4)\n        return PJNATH_ESTUNINATTRLEN;\n    *p_attr = attr;\n    return PJ_SUCCESS;\n}", "target": 1}
{"code": "static void HeaderMapImplGetByteSize(benchmark::State& state) {\n  HeaderMapImpl headers;\n  addDummyHeaders(headers, state.range(0));\n  uint64_t size = 0;\n  for (auto _ : state) {\n    size += headers.byteSize();\n  }\n  benchmark::DoNotOptimize(size);\n}", "target": 1}
{"code": "static int timer_start(Unit *u) {\n        Timer *t = TIMER(u);\n        TimerValue *v;\n        assert(t);\n        assert(t->state == TIMER_DEAD || t->state == TIMER_FAILED);\n        if (UNIT_TRIGGER(u)->load_state != UNIT_LOADED)\n                return -ENOENT;\n        t->last_trigger = DUAL_TIMESTAMP_NULL;\n        LIST_FOREACH(value, v, t->values)\n                if (v->base == TIMER_ACTIVE)\n                        v->disabled = false;\n        if (t->stamp_path) {\n                struct stat st;\n                if (stat(t->stamp_path, &st) >= 0)\n                        t->last_trigger.realtime = timespec_load(&st.st_atim);\n                else if (errno == ENOENT)\n                        touch_file(t->stamp_path, true, USEC_INFINITY, UID_INVALID, GID_INVALID, 0);\n        }\n        t->result = TIMER_SUCCESS;\n        timer_enter_waiting(t, true);\n        return 1;\n}", "target": 1}
{"code": "decode_labeled_prefix6(netdissect_options *ndo,\n                       const u_char *pptr, u_int itemlen, char *buf, u_int buflen)\n{\n\tstruct in6_addr addr;\n\tu_int plen, plenbytes;\n\tND_TCHECK2(pptr[0], 4);\n\tITEMCHECK(4);\n\tplen = pptr[0]; \n\tif (24 > plen)\n\t\treturn -1;\n        plen-=24; \n\tif (128 < plen)\n\t\treturn -1;\n\titemlen -= 4;\n\tmemset(&addr, 0, sizeof(addr));\n\tplenbytes = (plen + 7) / 8;\n\tND_TCHECK2(pptr[4], plenbytes);\n\tmemcpy(&addr, &pptr[4], plenbytes);\n\tif (plen % 8) {\n\t\taddr.s6_addr[plenbytes - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n\tsnprintf(buf, buflen, \"%s/%d, label:%u %s\",\n                 ip6addr_string(ndo, &addr),\n                 plen,\n                 EXTRACT_24BITS(pptr+1)>>4,\n                 ((pptr[3]&1)==0) ? \"(BOGUS: Bottom of Stack NOT set!)\" : \"(bottom)\" );\n\treturn 4 + plenbytes;\ntrunc:\n\treturn -2;\nbadtlv:\n\treturn -3;\n}", "target": 0}
{"code": "static size_t\nphp_mysqlnd_change_auth_response_write(MYSQLND_CONN_DATA * conn, void * _packet)\n{\n\tMYSQLND_PACKET_CHANGE_AUTH_RESPONSE *packet= (MYSQLND_PACKET_CHANGE_AUTH_RESPONSE *) _packet;\n\tMYSQLND_ERROR_INFO * error_info = conn->error_info;\n\tMYSQLND_PFC * pfc = conn->protocol_frame_codec;\n\tMYSQLND_VIO * vio = conn->vio;\n\tMYSQLND_STATS * stats = conn->stats;\n\tMYSQLND_CONNECTION_STATE * connection_state = &conn->state;\n\tzend_uchar * const buffer = pfc->cmd_buffer.length >= packet->auth_data_len? pfc->cmd_buffer.buffer : mnd_emalloc(packet->auth_data_len);\n\tzend_uchar * p = buffer + MYSQLND_HEADER_SIZE; \n\tDBG_ENTER(\"php_mysqlnd_change_auth_response_write\");\n\tif (packet->auth_data_len) {\n\t\tmemcpy(p, packet->auth_data, packet->auth_data_len);\n\t\tp+= packet->auth_data_len;\n\t}\n\t{\n\t\tconst size_t sent = pfc->data->m.send(pfc, vio, buffer, p - buffer - MYSQLND_HEADER_SIZE, stats, error_info);\n\t\tif (buffer != pfc->cmd_buffer.buffer) {\n\t\t\tmnd_efree(buffer);\n\t\t}\n\t\tif (!sent) {\n\t\t\tSET_CONNECTION_STATE(connection_state, CONN_QUIT_SENT);\n\t\t}\n\t\tDBG_RETURN(sent);\n\t}", "target": 1}
{"code": "void InstanceKlass::set_package(ClassLoaderData* loader_data, PackageEntry* pkg_entry, TRAPS) {\n  if (!is_shared()) {\n    check_prohibited_package(name(), loader_data, CHECK);\n  }\n  if (is_shared() && _package_entry != NULL) {\n    if (MetaspaceShared::use_full_module_graph() && _package_entry == pkg_entry) {\n      assert(MetaspaceShared::is_in_shared_metaspace(_package_entry), \"must be\");\n      return;\n    } else {\n      _package_entry = NULL;\n    }\n  }\n  TempNewSymbol from_class_name =\n      (pkg_entry != NULL) ? NULL : ClassLoader::package_from_class_name(name());\n  Symbol* pkg_name;\n  if (pkg_entry != NULL) {\n    pkg_name = pkg_entry->name();\n  } else {\n    pkg_name = from_class_name;\n  }\n  if (pkg_name != NULL && loader_data != NULL) {\n    _package_entry = pkg_entry != NULL ? pkg_entry : loader_data->packages()->lookup_only(pkg_name);\n    if (_package_entry == NULL) {\n      if (!ModuleEntryTable::javabase_defined()) {\n        assert(ModuleEntryTable::javabase_moduleEntry() != NULL, JAVA_BASE_NAME \" module is NULL\");\n        _package_entry = loader_data->packages()->lookup(pkg_name, ModuleEntryTable::javabase_moduleEntry());\n      } else {\n        assert(loader_data->unnamed_module() != NULL, \"unnamed module is NULL\");\n        _package_entry = loader_data->packages()->lookup(pkg_name,\n                                                         loader_data->unnamed_module());\n      }\n      DEBUG_ONLY(ResourceMark rm(THREAD));\n      assert(_package_entry != NULL, \"Package entry for class %s not found, loader %s\",\n             name()->as_C_string(), loader_data->loader_name_and_id());\n    }\n    if (log_is_enabled(Debug, module)) {\n      ResourceMark rm(THREAD);\n      ModuleEntry* m = _package_entry->module();\n      log_trace(module)(\"Setting package: class: %s, package: %s, loader: %s, module: %s\",\n                        external_name(),\n                        pkg_name->as_C_string(),\n                        loader_data->loader_name_and_id(),\n                        (m->is_named() ? m->name()->as_C_string() : UNNAMED_MODULE));\n    }\n  } else {\n    ResourceMark rm(THREAD);\n    log_trace(module)(\"Setting package: class: %s, package: unnamed, loader: %s, module: %s\",\n                      external_name(),\n                      (loader_data != NULL) ? loader_data->loader_name_and_id() : \"NULL\",\n                      UNNAMED_MODULE);\n  }\n}", "target": 0}
{"code": "z_jbig2decode(i_ctx_t * i_ctx_p)\n{\n    os_ptr op = osp;\n    ref *sop = NULL;\n    s_jbig2_global_data_t *gref;\n    stream_jbig2decode_state state;\n    s_jbig2decode_set_global_data((stream_state*)&state, NULL);\n    if (r_has_type(op, t_dictionary)) {\n        check_dict_read(*op);\n        if ( dict_find_string(op, \".jbig2globalctx\", &sop) > 0) {\n            gref = r_ptr(sop, s_jbig2_global_data_t);\n            s_jbig2decode_set_global_data((stream_state*)&state, gref);\n        }\n    }\n    return filter_read(i_ctx_p, 0, &s_jbig2decode_template,\n                       (stream_state *) & state, (sop ? r_space(sop) : 0));\n}", "target": 1}
{"code": "storageConnectStoragePoolEventDeregisterAny(virConnectPtr conn,\n                                            int callbackID)\n{\n    if (virConnectStoragePoolEventDeregisterAnyEnsureACL(conn) < 0)\n        return -1;\n    if (virObjectEventStateDeregisterID(conn,\n                                        driver->storageEventState,\n                                        callbackID, true) < 0)\n        return -1;\n    return 0;\n}", "target": 0}
{"code": "snmp_api_set_oid(snmp_varbind_t *varbind, uint32_t *oid, uint32_t *ret_oid)\n{\n  snmp_api_replace_oid(varbind, oid);\n  varbind->value_type = BER_DATA_TYPE_OID;\n  varbind->value.oid = ret_oid;\n}", "target": 1}
{"code": "st_lookup(st_table *table, register st_data_t key, st_data_t *value)\n{\n    st_index_t hash_val, bin_pos;\n    register st_table_entry *ptr;\n    if (table->entries_packed) {\n        st_index_t i;\n        for (i = 0; i < table->num_entries; i++) {\n            if ((st_data_t)table->bins[i*2] == key) {\n                if (value !=0) *value = (st_data_t)table->bins[i*2+1];\n                return 1;\n            }\n        }\n        return 0;\n    }\n    hash_val = do_hash(key, table);\n    FIND_ENTRY(table, ptr, hash_val, bin_pos);\n    if (ptr == 0) {\n\treturn 0;\n    }\n    else {\n\tif (value != 0)  *value = ptr->record;\n\treturn 1;\n    }\n}", "target": 0}
{"code": "read_line (FILE         *fp,\n           guchar       *row,\n           guchar       *buf,\n           tga_info     *info,\n           gint          bpp,\n           const guchar *convert_cmap)\n{\n  if (info->imageCompression == TGA_COMP_RLE)\n    {\n      rle_read (fp, buf, info);\n    }\n  else\n    {\n      fread (buf, info->bytes, info->width, fp);\n    }\n  if (info->flipHoriz)\n    {\n      flip_line (buf, info);\n    }\n  if (info->imageType == TGA_TYPE_COLOR)\n    {\n      if (info->bpp == 16 || info->bpp == 15)\n        {\n          upsample (row, buf, info->width, info->bytes, info->alphaBits);\n        }\n      else\n        {\n          bgr2rgb (row, buf, info->width, info->bytes, info->alphaBits);\n        }\n    }\n  else if (convert_cmap)\n    {\n      gboolean has_alpha = (info->alphaBits > 0);\n      apply_colormap (row, buf, info->width, convert_cmap, has_alpha,\n                      info->colorMapIndex);\n    }\n  else if (info->imageType == TGA_TYPE_MAPPED)\n    {\n      g_assert(bpp == 1);\n      apply_index (row, buf, info->width, info->colorMapIndex);\n    }\n  else\n    {\n      memcpy (row, buf, info->width * bpp);\n    }\n}", "target": 0}
{"code": "static Jsi_RC jsi_ArrayFlatSub(Jsi_Interp *interp, Jsi_Obj* nobj, Jsi_Value *arr, int depth) {\n    int i, n = 0, len = jsi_SizeOfArray(interp, arr->d.obj);\n    if (len <= 0) return JSI_OK;\n    Jsi_RC rc = JSI_OK;\n    int clen = jsi_SizeOfArray(interp, nobj);\n    for (i = 0; i < len && rc == JSI_OK; i++) {\n        Jsi_Value *t = Jsi_ValueArrayIndex(interp, arr, i);\n        if (t && depth>0 && Jsi_ValueIsArray(interp, t))\n            rc = jsi_ArrayFlatSub(interp, nobj, t , depth-1);\n        else if (!Jsi_ValueIsUndef(interp, t))\n            Jsi_ObjArrayAdd(interp, nobj, t);\n        if ((uint)(++n + clen)>interp->maxArrayList)\n            return Jsi_LogError(\"array size exceeded\");\n    }\n    return rc;\n}", "target": 0}
{"code": "static boolean jpeg_empty_output_buffer(j_compress_ptr cinfo)\n{\n    VncState *vs = cinfo->client_data;\n    Buffer *buffer = &vs->tight->jpeg;\n    buffer->offset = buffer->capacity;\n    buffer_reserve(buffer, 2048);\n    jpeg_init_destination(cinfo);\n    return TRUE;\n}", "target": 0}
{"code": "static void test_bug17309863()\n{\n  MYSQL *lmysql;\n  unsigned long thread_id;\n  char query[MAX_TEST_QUERY_LENGTH];\n  int rc;\n  myheader(\"test_bug17309863\");\n  if (!opt_silent)\n    fprintf(stdout, \"\\n Establishing a test connection ...\");\n  if (!(lmysql= mysql_client_init(NULL)))\n  {\n    myerror(\"mysql_client_init() failed\");\n    exit(1);\n  }\n  lmysql->reconnect= 1;\n  if (!(mysql_real_connect(lmysql, opt_host, opt_user,\n                           opt_password, current_db, opt_port,\n                           opt_unix_socket, 0)))\n  {\n    myerror(\"connection failed\");\n    exit(1);\n  }\n  if (!opt_silent)\n    fprintf(stdout, \"OK\");\n  thread_id= mysql_thread_id(lmysql);\n  sprintf(query, \"KILL %lu\", thread_id);\n  if (thread_query(query))\n    exit(1);\n  rc= mysql_query(lmysql, \"SELECT 'bug17309863'\");\n  myquery(rc);\n  mysql_close(lmysql);\n}", "target": 0}
{"code": "static int llcp_sock_create(struct net *net, struct socket *sock,\n\t\t\t    const struct nfc_protocol *nfc_proto, int kern)\n{\n\tstruct sock *sk;\n\tpr_debug(\"%p\\n\", sock);\n\tif (sock->type != SOCK_STREAM &&\n\t    sock->type != SOCK_DGRAM &&\n\t    sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\tif (sock->type == SOCK_RAW)\n\t\tsock->ops = &llcp_rawsock_ops;\n\telse\n\t\tsock->ops = &llcp_sock_ops;\n\tsk = nfc_llcp_sock_alloc(sock, sock->type, GFP_ATOMIC, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}", "target": 1}
{"code": "static php_mb_regex_t *php_mbregex_compile_pattern(const char *pattern, int patlen, OnigOptionType options, OnigEncoding enc, OnigSyntaxType *syntax TSRMLS_DC)\n{\n\tint err_code = 0;\n\tint found = 0;\n\tphp_mb_regex_t *retval = NULL, **rc = NULL;\n\tOnigErrorInfo err_info;\n\tOnigUChar err_str[ONIG_MAX_ERROR_MESSAGE_LEN];\n\tfound = zend_hash_find(&MBREX(ht_rc), (char *)pattern, patlen+1, (void **) &rc);\n\tif (found == FAILURE || (*rc)->options != options || (*rc)->enc != enc || (*rc)->syntax != syntax) {\n\t\tif ((err_code = onig_new(&retval, (OnigUChar *)pattern, (OnigUChar *)(pattern + patlen), options, enc, syntax, &err_info)) != ONIG_NORMAL) {\n\t\t\tonig_error_code_to_str(err_str, err_code, err_info);\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"mbregex compile err: %s\", err_str);\n\t\t\tretval = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tzend_hash_update(&MBREX(ht_rc), (char *) pattern, patlen + 1, (void *) &retval, sizeof(retval), NULL);\n\t} else if (found == SUCCESS) {\n\t\tretval = *rc;\n\t}\nout:\n\treturn retval; \n}", "target": 1}
{"code": "http_error_t::make_body (int n, const str &si, const str &aux)\n{\n  strbuf b;\n  str ldesc;\n  const str sdesc = http_status.get_desc (n, &ldesc);\n  b << \"<html>\\n\"\n    << \" <head>\\n\"\n    << \"  <title>\" << n << \" \" << sdesc << \"</title>\\n\"\n    << \" </head>\\n\"\n    << \" <body>\\n\"\n    << \" <h1>Error \" << n << \" \" << sdesc << \"</h1><br><br>\\n\"\n    ;\n  if (n == HTTP_NOT_FOUND && aux) {\n    b << \"The file <tt>\" << aux \n      << \"</tt> was not found on this server.<br><br>\\n\\n\";\n  }\n  b << \"  <hr>\\n\"\n    << \"  <i>\" << si << \"</i>\\n\"\n    << \" <br>\\n\"\n    << \" </body>\\n\"\n    << \"</html>\\n\"\n    ;\n  return b;\n}", "target": 1}
{"code": "yang_fill_include(struct lys_module *trg, char *value, struct lys_include *inc,\n                  struct unres_schema *unres)\n{\n    const char *str;\n    int rc;\n    int ret = 0;\n    str = lydict_insert_zc(trg->ctx, value);\n    rc = lyp_check_include(trg, str, inc, unres);\n    if (!rc) {\n        memcpy(&trg->inc[trg->inc_size], inc, sizeof *inc);\n        if (yang_check_ext_instance(trg, &trg->inc[trg->inc_size].ext, trg->inc[trg->inc_size].ext_size,\n                                    &trg->inc[trg->inc_size], unres)) {\n            ret = -1;\n        }\n        trg->inc_size++;\n    } else if (rc == -1) {\n        lys_extension_instances_free(trg->ctx, inc->ext, inc->ext_size, NULL);\n        ret = -1;\n    }\n    lydict_remove(trg->ctx, str);\n    return ret;\n}", "target": 0}
{"code": "gen_k( gcry_mpi_t p, int small_k )\n{\n  gcry_mpi_t k = mpi_alloc_secure( 0 );\n  gcry_mpi_t temp = mpi_alloc( mpi_get_nlimbs(p) );\n  gcry_mpi_t p_1 = mpi_copy(p);\n  unsigned int orig_nbits = mpi_get_nbits(p);\n  unsigned int nbits, nbytes;\n  char *rndbuf = NULL;\n  if (small_k)\n    {\n      nbits = wiener_map( orig_nbits ) * 3 / 2;\n      if( nbits >= orig_nbits )\n        BUG();\n    }\n  else\n    nbits = orig_nbits;\n  nbytes = (nbits+7)/8;\n  if( DBG_CIPHER )\n    log_debug(\"choosing a random k\\n\");\n  mpi_sub_ui( p_1, p, 1);\n  for(;;)\n    {\n      if( !rndbuf || nbits < 32 )\n        {\n          xfree(rndbuf);\n          rndbuf = _gcry_random_bytes_secure( nbytes, GCRY_STRONG_RANDOM );\n        }\n      else\n        {\n          char *pp = _gcry_random_bytes_secure( 4, GCRY_STRONG_RANDOM );\n          memcpy( rndbuf, pp, 4 );\n          xfree(pp);\n\t}\n      _gcry_mpi_set_buffer( k, rndbuf, nbytes, 0 );\n      for(;;)\n        {\n          if( !(mpi_cmp( k, p_1 ) < 0) )  \n            {\n              if( DBG_CIPHER )\n                progress('+');\n              break; \n            }\n          if( !(mpi_cmp_ui( k, 0 ) > 0) )  \n            {\n              if( DBG_CIPHER )\n                progress('-');\n              break; \n            }\n          if (mpi_gcd( temp, k, p_1 ))\n            goto found;  \n          mpi_add_ui( k, k, 1 );\n          if( DBG_CIPHER )\n            progress('.');\n\t}\n    }\n found:\n  xfree (rndbuf);\n  if( DBG_CIPHER )\n    progress('\\n');\n  mpi_free(p_1);\n  mpi_free(temp);\n  return k;\n}", "target": 0}
{"code": "bool CxImage::Transfer(CxImage &from, bool bTransferFrames )\n{\n\tif (!Destroy())\n\t\treturn false;\n\tmemcpy(&head,&from.head,sizeof(BITMAPINFOHEADER));\n\tmemcpy(&info,&from.info,sizeof(CXIMAGEINFO));\n\tpDib = from.pDib;\n\tpSelection = from.pSelection;\n\tpAlpha = from.pAlpha;\n\tppLayers = from.ppLayers;\n\tmemset(&from.head,0,sizeof(BITMAPINFOHEADER));\n\tmemset(&from.info,0,sizeof(CXIMAGEINFO));\n\tfrom.pDib = from.pSelection = from.pAlpha = NULL;\n\tfrom.ppLayers = NULL;\n\tif (bTransferFrames){\n\t\tDestroyFrames();\n\t\tppFrames = from.ppFrames;\n\t\tfrom.ppFrames = NULL;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "struct usbredirparser *usbredirparser_create(void)\n{\n    return calloc(1, sizeof(struct usbredirparser_priv));\n}", "target": 0}
{"code": "static void cil_reset_perm(struct cil_perm *perm)\n{\n\tcil_reset_classperms_list(perm->classperms);\n}", "target": 1}
{"code": "sudo_auth_end_session(void)\n{\n    sudo_auth *auth;\n    int status;\n    debug_decl(sudo_auth_end_session, SUDOERS_DEBUG_AUTH);\n    for (auth = auth_switch; auth->name; auth++) {\n\tif (auth->end_session && !IS_DISABLED(auth)) {\n\t    status = (auth->end_session)(auth);\n\t    if (status == AUTH_ERROR) {\n\t\tdebug_return_int(-1);\n\t    }\n\t}\n    }\n    debug_return_int(1);\n}", "target": 1}
{"code": "nfsd4_encode_layoutget(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\tstruct nfsd4_layoutget *lgp)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tconst struct nfsd4_layout_ops *ops =\n\t\tnfsd4_layout_ops[lgp->lg_layout_type];\n\t__be32 *p;\n\tdprintk(\"%s: err %d\\n\", __func__, nfserr);\n\tif (nfserr)\n\t\tgoto out;\n\tnfserr = nfserr_resource;\n\tp = xdr_reserve_space(xdr, 36 + sizeof(stateid_opaque_t));\n\tif (!p)\n\t\tgoto out;\n\t*p++ = cpu_to_be32(1);\t\n\t*p++ = cpu_to_be32(lgp->lg_sid.si_generation);\n\tp = xdr_encode_opaque_fixed(p, &lgp->lg_sid.si_opaque,\n\t\t\t\t    sizeof(stateid_opaque_t));\n\t*p++ = cpu_to_be32(1);\t\n\tp = xdr_encode_hyper(p, lgp->lg_seg.offset);\n\tp = xdr_encode_hyper(p, lgp->lg_seg.length);\n\t*p++ = cpu_to_be32(lgp->lg_seg.iomode);\n\t*p++ = cpu_to_be32(lgp->lg_layout_type);\n\tnfserr = ops->encode_layoutget(xdr, lgp);\nout:\n\tkfree(lgp->lg_content);\n\treturn nfserr;\n}", "target": 1}
{"code": "struct ipv6_txoptions *ipv6_update_options(struct sock *sk,\n\t\t\t\t\t   struct ipv6_txoptions *opt)\n{\n\tif (inet_sk(sk)->is_icsk) {\n\t\tif (opt &&\n\t\t    !((1 << sk->sk_state) & (TCPF_LISTEN | TCPF_CLOSE)) &&\n\t\t    inet_sk(sk)->inet_daddr != LOOPBACK4_IPV6) {\n\t\t\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\t\t\ticsk->icsk_ext_hdr_len = opt->opt_flen + opt->opt_nflen;\n\t\t\ticsk->icsk_sync_mss(sk, icsk->icsk_pmtu_cookie);\n\t\t}\n\t}\n\topt = xchg(&inet6_sk(sk)->opt, opt);\n\tsk_dst_reset(sk);\n\treturn opt;\n}", "target": 1}
{"code": "  CdsIntegrationTest()\n      : HttpIntegrationTest(Http::CodecType::HTTP2, ipVersion(),\n                            ConfigHelper::discoveredClustersBootstrap(\n                                sotwOrDelta() == Grpc::SotwOrDelta::Sotw ||\n                                        sotwOrDelta() == Grpc::SotwOrDelta::UnifiedSotw\n                                    ? \"GRPC\"\n                                    : \"DELTA_GRPC\")) {\n    if (sotwOrDelta() == Grpc::SotwOrDelta::UnifiedSotw ||\n        sotwOrDelta() == Grpc::SotwOrDelta::UnifiedDelta) {\n      config_helper_.addRuntimeOverride(\"envoy.reloadable_features.unified_mux\", \"true\");\n    }\n    use_lds_ = false;\n    sotw_or_delta_ = sotwOrDelta();\n  }", "target": 1}
{"code": "comics_regex_quote (const gchar *unquoted_string)\n{\n\tconst gchar *p;\n\tGString *dest;\n\tdest = g_string_new (\"'\");\n\tp = unquoted_string;\n\twhile (*p) {\n\t\tswitch (*p) {\n\t\t\tcase ('*'):\n\t\t\tcase ('?'):\n\t\t\tcase ('['):\n\t\t\t\tg_string_append (dest, \"[\");\n\t\t\t\tg_string_append_c (dest, *p);\n\t\t\t\tg_string_append (dest, \"]\");\n\t\t\t\tbreak;\n\t\t\tcase ('\\\\'):\n\t\t\t\tg_string_append (dest, \"[\\\\\\\\]\");\n\t\t\t\tbreak;\n\t\t\tcase ('\\''):\n\t\t\t\tg_string_append (dest, \"'\\\\''\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tg_string_append_c (dest, *p);\n\t\t\t\tbreak;\n\t\t}\n\t\t++p;\n\t}\n\tg_string_append_c (dest, '\\'');\n\treturn g_string_free (dest, FALSE);\n}", "target": 1}
{"code": "kadm5_ret_t kadm5_decrypt_key(void *server_handle,\n                              kadm5_principal_ent_t entry, krb5_int32\n                              ktype, krb5_int32 stype, krb5_int32\n                              kvno, krb5_keyblock *keyblock,\n                              krb5_keysalt *keysalt, int *kvnop)\n{\n    kadm5_server_handle_t handle = server_handle;\n    krb5_db_entry dbent;\n    krb5_key_data *key_data;\n    krb5_keyblock *mkey_ptr;\n    int ret;\n    CHECK_HANDLE(server_handle);\n    if (entry->n_key_data == 0 || entry->key_data == NULL)\n        return EINVAL;\n    dbent.n_key_data = entry->n_key_data;\n    dbent.key_data = entry->key_data;\n    if ((ret = krb5_dbe_find_enctype(handle->context, &dbent, ktype,\n                                     stype, kvno, &key_data)))\n        return ret;\n    dbent.tl_data = entry->tl_data;\n    if ((ret = krb5_dbe_find_mkey(handle->context, &dbent, &mkey_ptr))) {\n        if (krb5_db_fetch_mkey_list(handle->context, master_princ,\n                                    &master_keyblock) == 0) {\n            if ((ret = krb5_dbe_find_mkey(handle->context, &dbent,\n                                          &mkey_ptr))) {\n                return ret;\n            }\n        } else {\n            return ret;\n        }\n    }\n    if ((ret = krb5_dbe_decrypt_key_data(handle->context, NULL, key_data,\n                                         keyblock, keysalt)))\n        return ret;\n    if (ktype != -1)\n        keyblock->enctype = ktype;\n    if (kvnop)\n        *kvnop = key_data->key_data_kvno;\n    return KADM5_OK;\n}", "target": 0}
{"code": "static void decode_rgb_frame(FFV1Context *s, uint8_t *src[3], int w, int h, int stride[3])\n{\n    int x, y, p;\n    int16_t *sample[4][2];\n    int lbd    = s->avctx->bits_per_raw_sample <= 8;\n    int bits   = s->avctx->bits_per_raw_sample > 0 ? s->avctx->bits_per_raw_sample : 8;\n    int offset = 1 << bits;\n    for (x = 0; x < 4; x++) {\n        sample[x][0] = s->sample_buffer +  x * 2      * (w + 6) + 3;\n        sample[x][1] = s->sample_buffer + (x * 2 + 1) * (w + 6) + 3;\n    }\n    s->run_index = 0;\n    memset(s->sample_buffer, 0, 8 * (w + 6) * sizeof(*s->sample_buffer));\n    for (y = 0; y < h; y++) {\n        for (p = 0; p < 3 + s->transparency; p++) {\n            int16_t *temp = sample[p][0]; \n            sample[p][0] = sample[p][1];\n            sample[p][1] = temp;\n            sample[p][1][-1]= sample[p][0][0  ];\n            sample[p][0][ w]= sample[p][0][w-1];\n            if (lbd && s->slice_coding_mode == 0)\n                decode_line(s, w, sample[p], (p + 1)/2, 9);\n            else\n                decode_line(s, w, sample[p], (p + 1)/2, bits + (s->slice_coding_mode != 1));\n        }\n        for (x = 0; x < w; x++) {\n            int g = sample[0][1][x];\n            int b = sample[1][1][x];\n            int r = sample[2][1][x];\n            int a = sample[3][1][x];\n            if (s->slice_coding_mode != 1) {\n                b -= offset;\n                r -= offset;\n                g -= (b * s->slice_rct_by_coef + r * s->slice_rct_ry_coef) >> 2;\n                b += g;\n                r += g;\n            }\n            if (lbd)\n                *((uint32_t*)(src[0] + x*4 + stride[0]*y)) = b + (g<<8) + (r<<16) + (a<<24);\n            else {\n                *((uint16_t*)(src[0] + x*2 + stride[0]*y)) = b;\n                *((uint16_t*)(src[1] + x*2 + stride[1]*y)) = g;\n                *((uint16_t*)(src[2] + x*2 + stride[2]*y)) = r;\n            }\n        }\n    }\n}", "target": 0}
{"code": "void acpi_os_unmap_generic_address(struct acpi_generic_address *gas)\n{\n\tu64 addr;\n\tstruct acpi_ioremap *map;\n\tif (gas->space_id != ACPI_ADR_SPACE_SYSTEM_MEMORY)\n\t\treturn;\n\tmemcpy(&addr, &gas->address, sizeof(addr));\n\tif (!addr || !gas->bit_width)\n\t\treturn;\n\tmutex_lock(&acpi_ioremap_lock);\n\tmap = acpi_map_lookup(addr, gas->bit_width / 8);\n\tif (!map) {\n\t\tmutex_unlock(&acpi_ioremap_lock);\n\t\treturn;\n\t}\n\tacpi_os_drop_map_ref(map);\n\tmutex_unlock(&acpi_ioremap_lock);\n\tacpi_os_map_cleanup(map);\n}", "target": 0}
{"code": "struct vfsmount *collect_mounts(struct path *path)\n{\n\tstruct mount *tree;\n\tnamespace_lock();\n\ttree = copy_tree(real_mount(path->mnt), path->dentry,\n\t\t\t CL_COPY_ALL | CL_PRIVATE);\n\tnamespace_unlock();\n\tif (IS_ERR(tree))\n\t\treturn ERR_CAST(tree);\n\treturn &tree->mnt;\n}", "target": 1}
{"code": "poly_path(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *poly = PG_GETARG_POLYGON_P(0);\n\tPATH\t   *path;\n\tint\t\t\tsize;\n\tint\t\t\ti;\n\tsize = offsetof(PATH, p[0]) +sizeof(path->p[0]) * poly->npts;\n\tpath = (PATH *) palloc(size);\n\tSET_VARSIZE(path, size);\n\tpath->npts = poly->npts;\n\tpath->closed = TRUE;\n\tpath->dummy = 0;\n\tfor (i = 0; i < poly->npts; i++)\n\t{\n\t\tpath->p[i].x = poly->p[i].x;\n\t\tpath->p[i].y = poly->p[i].y;\n\t}\n\tPG_RETURN_PATH_P(path);\n}", "target": 0}
{"code": "getHostName() {\n\tlong hostNameMax = HOST_NAME_MAX;\n\tif (hostNameMax < 255) {\n\t\thostNameMax = 255;\n\t}\n\tstring buf(hostNameMax + 1, '\\0');\n\tif (gethostname(&buf[0], hostNameMax + 1) == 0) {\n\t\tbuf[hostNameMax] = '\\0';\n\t\treturn string(buf.c_str());\n\t} else {\n\t\tint e = errno;\n\t\tthrow SystemException(\"Unable to query the system's host name\", e);\n\t}\n}", "target": 0}
{"code": "int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf,\n                            size_t size)\n{\n    GetBitContext gb;\n    AC3HeaderInfo *hdr;\n    int err;\n    if (!*phdr)\n        *phdr = av_mallocz(sizeof(AC3HeaderInfo));\n    if (!*phdr)\n        return AVERROR(ENOMEM);\n    hdr = *phdr;\n    init_get_bits8(&gb, buf, size);\n    err = ff_ac3_parse_header(&gb, hdr);\n    if (err < 0)\n        return AVERROR_INVALIDDATA;\n    return get_bits_count(&gb);\n}", "target": 1}
{"code": "static struct rpmsg_device *rpmsg_virtio_add_ctrl_dev(struct virtio_device *vdev)\n{\n\tstruct virtproc_info *vrp = vdev->priv;\n\tstruct virtio_rpmsg_channel *vch;\n\tstruct rpmsg_device *rpdev_ctrl;\n\tint err = 0;\n\tvch = kzalloc(sizeof(*vch), GFP_KERNEL);\n\tif (!vch)\n\t\treturn ERR_PTR(-ENOMEM);\n\tvch->vrp = vrp;\n\trpdev_ctrl = &vch->rpdev;\n\trpdev_ctrl->ops = &virtio_rpmsg_ops;\n\trpdev_ctrl->dev.parent = &vrp->vdev->dev;\n\trpdev_ctrl->dev.release = virtio_rpmsg_release_device;\n\trpdev_ctrl->little_endian = virtio_is_little_endian(vrp->vdev);\n\terr = rpmsg_ctrldev_register_device(rpdev_ctrl);\n\tif (err) {\n\t\tkfree(vch);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn rpdev_ctrl;\n}", "target": 1}
{"code": "void ConnPoolImplBase::checkForIdleAndCloseIdleConnsIfDraining() {\n  if (is_draining_for_deletion_) {\n    closeIdleConnectionsForDrainingPool();\n  }\n  if (isIdleImpl()) {\n    ENVOY_LOG(debug, \"invoking idle callbacks - is_draining_for_deletion_={}\",\n              is_draining_for_deletion_);\n    for (const Instance::IdleCb& cb : idle_callbacks_) {\n      cb();\n    }\n  }\n}", "target": 1}
{"code": "static int sco_sock_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t    size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tvoid *buf;\n\tint err;\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\terr = sock_error(sk);\n\tif (err)\n\t\treturn err;\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\tbuf = kmalloc(len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tif (memcpy_from_msg(buf, msg, len)) {\n\t\tkfree(buf);\n\t\treturn -EFAULT;\n\t}\n\tlock_sock(sk);\n\tif (sk->sk_state == BT_CONNECTED)\n\t\terr = sco_send_frame(sk, buf, len, msg->msg_flags);\n\telse\n\t\terr = -ENOTCONN;\n\trelease_sock(sk);\n\tkfree(buf);\n\treturn err;\n}", "target": 1}
{"code": "void usbredirparser_caps_set_cap(uint32_t *caps, int cap)\n{\n    caps[cap / 32] |= 1 << (cap % 32);\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const auto splits = ctx->input(0).flat<int64_t>();\n    const auto values = ctx->input(1).flat<Tidx>();\n    const Tensor& size_t = ctx->input(2);\n    const auto weights = ctx->input(3).flat<T>();\n    const int64_t weights_size = weights.size();\n    OP_REQUIRES(ctx, size_t.dims() == 0,\n                errors::InvalidArgument(\"Shape must be rank 0 but is rank \",\n                                        size_t.dims()));\n    Tidx size = size_t.scalar<Tidx>()();\n    OP_REQUIRES(\n        ctx, size >= 0,\n        errors::InvalidArgument(\"size (\", size, \") must be non-negative\"));\n    int num_rows = splits.size() - 1;\n    int num_values = values.size();\n    int batch_idx = 0;\n    OP_REQUIRES(ctx, splits.size() > 0,\n                errors::InvalidArgument(\"Splits must be non-empty\"));\n    OP_REQUIRES(ctx, splits(0) == 0,\n                errors::InvalidArgument(\"Splits must start with 0, not with \",\n                                        splits(0)));\n    OP_REQUIRES(ctx, splits(num_rows) == num_values,\n                errors::InvalidArgument(\n                    \"Splits must end with the number of values, got \",\n                    splits(num_rows), \" instead of \", num_values));\n    Tensor* out_t;\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_output(0, TensorShape({num_rows, size}), &out_t));\n    functor::SetZeroFunctor<Device, T> fill;\n    fill(ctx->eigen_device<Device>(), out_t->flat<T>());\n    const auto out = out_t->matrix<T>();\n    for (int idx = 0; idx < num_values; ++idx) {\n      while (idx >= splits(batch_idx)) {\n        batch_idx++;\n      }\n      Tidx bin = values(idx);\n      OP_REQUIRES(ctx, bin >= 0,\n                  errors::InvalidArgument(\"Input must be non-negative\"));\n      if (bin < size) {\n        if (binary_output_) {\n          out(batch_idx - 1, bin) = T(1);\n        } else {\n          T value = (weights_size > 0) ? weights(idx) : T(1);\n          out(batch_idx - 1, bin) += value;\n        }\n      }\n    }\n  }", "target": 0}
{"code": "static unsigned char *AcquireCompactPixels(const Image *image,\n  ExceptionInfo *exception)\n{\n  size_t\n    packet_size;\n  unsigned char\n    *compact_pixels;\n  packet_size=image->depth > 8UL ? 2UL : 1UL;\n  compact_pixels=(unsigned char *) AcquireQuantumMemory((9*\n    image->columns)+1,packet_size*sizeof(*compact_pixels));\n  if (compact_pixels == (unsigned char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n        image->filename);\n    }\n  return(compact_pixels);\n}", "target": 1}
{"code": "static void virtio_net_announce(NetClientState *nc)\n{\n    VirtIONet *n = qemu_get_nic_opaque(nc);\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n    if (n->announce_timer.round) {\n        return;\n    }\n    if (virtio_vdev_has_feature(vdev, VIRTIO_NET_F_GUEST_ANNOUNCE) &&\n        virtio_vdev_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ)) {\n            virtio_net_announce_notify(n);\n    }\n}", "target": 0}
{"code": "chdlc_print(netdissect_options *ndo, register const u_char *p, u_int length)\n{\n\tu_int proto;\n\tconst u_char *bp = p;\n\tif (length < CHDLC_HDRLEN)\n\t\tgoto trunc;\n\tND_TCHECK2(*p, CHDLC_HDRLEN);\n\tproto = EXTRACT_16BITS(&p[2]);\n\tif (ndo->ndo_eflag) {\n                ND_PRINT((ndo, \"%s, ethertype %s (0x%04x), length %u: \",\n                       tok2str(chdlc_cast_values, \"0x%02x\", p[0]),\n                       tok2str(ethertype_values, \"Unknown\", proto),\n                       proto,\n                       length));\n\t}\n\tlength -= CHDLC_HDRLEN;\n\tp += CHDLC_HDRLEN;\n\tswitch (proto) {\n\tcase ETHERTYPE_IP:\n\t\tip_print(ndo, p, length);\n\t\tbreak;\n\tcase ETHERTYPE_IPV6:\n\t\tip6_print(ndo, p, length);\n\t\tbreak;\n\tcase CHDLC_TYPE_SLARP:\n\t\tchdlc_slarp_print(ndo, p, length);\n\t\tbreak;\n#if 0\n\tcase CHDLC_TYPE_CDP:\n\t\tchdlc_cdp_print(p, length);\n\t\tbreak;\n#endif\n        case ETHERTYPE_MPLS:\n        case ETHERTYPE_MPLS_MULTI:\n                mpls_print(ndo, p, length);\n\t\tbreak;\n        case ETHERTYPE_ISO:\n                if (length < 2)\n                    goto trunc;\n                ND_TCHECK_16BITS(p);\n                if (*(p+1) == 0x81 ||\n                    *(p+1) == 0x82 ||\n                    *(p+1) == 0x83)\n                    isoclns_print(ndo, p + 1, length - 1, ndo->ndo_snapend - p - 1);\n                else\n                    isoclns_print(ndo, p, length, ndo->ndo_snapend - p);\n                break;\n\tdefault:\n                if (!ndo->ndo_eflag)\n                        ND_PRINT((ndo, \"unknown CHDLC protocol (0x%04x)\", proto));\n                break;\n\t}\n\treturn (CHDLC_HDRLEN);\ntrunc:\n\tND_PRINT((ndo, \"[|chdlc]\"));\n\treturn ndo->ndo_snapend - bp;\n}", "target": 0}
{"code": "gif_main_loop (GifContext *context)\n{\n\tgint retval = 0;\n\tdo {\n\t\tswitch (context->state) {\n\t\tcase GIF_START:\n                        LOG(\"start\\n\");\n\t\t\tretval = gif_init (context);\n\t\t\tbreak;\n\t\tcase GIF_GET_COLORMAP:\n                        LOG(\"get_colormap\\n\");\n\t\t\tretval = gif_get_colormap (context);\n\t\t\tif (retval == 0)\n\t\t\t\tcontext->state = GIF_GET_NEXT_STEP;\n\t\t\tbreak;\n\t\tcase GIF_GET_NEXT_STEP:\n                        LOG(\"next_step\\n\");\n\t\t\tretval = gif_get_next_step (context);\n\t\t\tbreak;\n\t\tcase GIF_GET_FRAME_INFO:\n                        LOG(\"frame_info\\n\");\n\t\t\tretval = gif_get_frame_info (context);\n\t\t\tbreak;\n\t\tcase GIF_GET_EXTENSION:\n                        LOG(\"get_extension\\n\");\n\t\t\tretval = gif_get_extension (context);\n\t\t\tif (retval == 0)\n\t\t\t\tcontext->state = GIF_GET_NEXT_STEP;\n\t\t\tbreak;\n\t\tcase GIF_GET_COLORMAP2:\n                        LOG(\"get_colormap2\\n\");\n\t\t\tretval = gif_get_colormap2 (context);\n\t\t\tif (retval == 0)\n\t\t\t\tgif_set_prepare_lzw (context);\n\t\t\tbreak;\n\t\tcase GIF_PREPARE_LZW:\n                        LOG(\"prepare_lzw\\n\");\n\t\t\tretval = gif_prepare_lzw (context);\n\t\t\tbreak;\n\t\tcase GIF_LZW_FILL_BUFFER:\n                        LOG(\"fill_buffer\\n\");\n\t\t\tretval = gif_lzw_fill_buffer (context);\n\t\t\tbreak;\n\t\tcase GIF_LZW_CLEAR_CODE:\n                        LOG(\"clear_code\\n\");\n\t\t\tretval = gif_lzw_clear_code (context);\n\t\t\tbreak;\n\t\tcase GIF_GET_LZW:\n                        LOG(\"get_lzw\\n\");\n\t\t\tretval = gif_get_lzw (context);\n\t\t\tbreak;\n\t\tcase GIF_DONE:\n                        LOG(\"done\\n\");\n\t\tdefault:\n\t\t\tretval = 0;\n\t\t\tgoto done;\n\t\t};\n\t} while ((retval == 0) || (retval == -3));\n done:\n\treturn retval;\n}", "target": 0}
{"code": "static int spl_ptr_heap_cmp_cb_helper(zval *object, spl_heap_object *heap_object, zval *a, zval *b, long *result TSRMLS_DC) { \n\t\tzval *result_p = NULL;\n\t\tzend_call_method_with_2_params(&object, heap_object->std.ce, &heap_object->fptr_cmp, \"compare\", &result_p, a, b);\n\t\tif (EG(exception)) {\n\t\t\treturn FAILURE;\n\t\t}\n\t\tconvert_to_long(result_p);\n\t\t*result = Z_LVAL_P(result_p);\n\t\tzval_ptr_dtor(&result_p);\n\t\treturn SUCCESS;\n}", "target": 0}
{"code": "void ntlm_free_message_fields_buffer(NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (fields)\n\t{\n\t\tif (fields->Buffer)\n\t\t{\n\t\t\tfree(fields->Buffer);\n\t\t\tfields->Len = 0;\n\t\t\tfields->MaxLen = 0;\n\t\t\tfields->Buffer = NULL;\n\t\t\tfields->BufferOffset = 0;\n\t\t}\n\t}\n}", "target": 1}
{"code": "void sco_recv_scodata(struct hci_conn *hcon, struct sk_buff *skb)\n{\n\tstruct sco_conn *conn = hcon->sco_data;\n\tif (!conn)\n\t\tgoto drop;\n\tBT_DBG(\"conn %p len %u\", conn, skb->len);\n\tif (skb->len) {\n\t\tsco_recv_frame(conn, skb);\n\t\treturn;\n\t}\ndrop:\n\tkfree_skb(skb);\n}", "target": 0}
{"code": "static int acpi_smbus_hc_add(struct acpi_device *device)\n{\n\tint status;\n\tunsigned long long val;\n\tstruct acpi_smb_hc *hc;\n\tif (!device)\n\t\treturn -EINVAL;\n\tstatus = acpi_evaluate_integer(device->handle, \"_EC\", NULL, &val);\n\tif (ACPI_FAILURE(status)) {\n\t\tprintk(KERN_ERR PREFIX \"error obtaining _EC.\\n\");\n\t\treturn -EIO;\n\t}\n\tstrcpy(acpi_device_name(device), ACPI_SMB_HC_DEVICE_NAME);\n\tstrcpy(acpi_device_class(device), ACPI_SMB_HC_CLASS);\n\thc = kzalloc(sizeof(struct acpi_smb_hc), GFP_KERNEL);\n\tif (!hc)\n\t\treturn -ENOMEM;\n\tmutex_init(&hc->lock);\n\tinit_waitqueue_head(&hc->wait);\n\thc->ec = acpi_driver_data(device->parent);\n\thc->offset = (val >> 8) & 0xff;\n\thc->query_bit = val & 0xff;\n\tdevice->driver_data = hc;\n\tacpi_ec_add_query_handler(hc->ec, hc->query_bit, NULL, smbus_alarm, hc);\n\tprintk(KERN_INFO PREFIX \"SBS HC: EC = 0x%p, offset = 0x%0x, query_bit = 0x%0x\\n\",\n\t\thc->ec, hc->offset, hc->query_bit);\n\treturn 0;\n}", "target": 1}
{"code": "void smp_send_pair_rsp(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n  SMP_TRACE_DEBUG(\"%s\", __func__);\n  p_cb->local_i_key &= p_cb->peer_i_key;\n  p_cb->local_r_key &= p_cb->peer_r_key;\n if (smp_send_cmd(SMP_OPCODE_PAIRING_RSP, p_cb)) {\n if (p_cb->selected_association_model == SMP_MODEL_SEC_CONN_OOB)\n      smp_use_oob_private_key(p_cb, NULL);\n else\n      smp_decide_association_model(p_cb, NULL);\n }\n}", "target": 0}
{"code": "vg_resource_attach_backing(VuGpu *g,\n                           struct virtio_gpu_ctrl_command *cmd)\n{\n    struct virtio_gpu_simple_resource *res;\n    struct virtio_gpu_resource_attach_backing ab;\n    int ret;\n    VUGPU_FILL_CMD(ab);\n    virtio_gpu_bswap_32(&ab, sizeof(ab));\n    res = virtio_gpu_find_resource(g, ab.resource_id);\n    if (!res) {\n        g_critical(\"%s: illegal resource specified %d\",\n                   __func__, ab.resource_id);\n        cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID;\n        return;\n    }\n    if (res->iov) {\n        cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;\n        return;\n    }\n    ret = vg_create_mapping_iov(g, &ab, cmd, &res->iov);\n    if (ret != 0) {\n        cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;\n        return;\n    }\n    res->iov_cnt = ab.nr_entries;\n}", "target": 0}
{"code": "compile_lock_unlock(\n    lval_T  *lvp,\n    char_u  *name_end,\n    exarg_T *eap,\n    int\t    deep,\n    void    *coookie)\n{\n    cctx_T\t*cctx = coookie;\n    int\t\tcc = *name_end;\n    char_u\t*p = lvp->ll_name;\n    int\t\tret = OK;\n    size_t\tlen;\n    char_u\t*buf;\n    isntype_T\tisn = ISN_EXEC;\n    if (cctx->ctx_skip == SKIP_YES)\n\treturn OK;\n    if (p[1] != ':')\n    {\n\tchar_u *end = find_name_end(p, NULL, NULL, FNE_CHECK_START);\n\tif (lookup_local(p, end - p, NULL, cctx) == OK)\n\t{\n\t    char_u *s = p;\n\t    if (*end != '.' && *end != '[')\n\t    {\n\t\temsg(_(e_cannot_lock_unlock_local_variable));\n\t\treturn FAIL;\n\t    }\n\t    if (compile_load(&s, end, cctx, FALSE, FALSE) == FAIL)\n\t\treturn FAIL;\n\t    isn = ISN_LOCKUNLOCK;\n\t}\n    }\n    *name_end = NUL;\n    len = name_end - p + 20;\n    buf = alloc(len);\n    if (buf == NULL)\n\tret = FAIL;\n    else\n    {\n\tchar *cmd = eap->cmdidx == CMD_lockvar ? \"lockvar\" : \"unlockvar\";\n\tif (deep < 0)\n\t    vim_snprintf((char *)buf, len, \"%s! %s\", cmd, p);\n\telse\n\t    vim_snprintf((char *)buf, len, \"%s %d %s\", cmd, deep, p);\n\tret = generate_EXEC_copy(cctx, isn, buf);\n\tvim_free(buf);\n\t*name_end = cc;\n    }\n    return ret;\n}", "target": 1}
{"code": "TEST_P(RBACIntegrationTest, RouteOverride) {\n  config_helper_.addConfigModifier(\n      [](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n             cfg) {\n        envoy::extensions::filters::http::rbac::v3::RBACPerRoute per_route_config;\n        TestUtility::loadFromJson(\"{}\", per_route_config);\n        auto* config = cfg.mutable_route_config()\n                           ->mutable_virtual_hosts()\n                           ->Mutable(0)\n                           ->mutable_typed_per_filter_config();\n        (*config)[Extensions::HttpFilters::HttpFilterNames::get().Rbac].PackFrom(per_route_config);\n      });\n  config_helper_.addFilter(RBAC_CONFIG);\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response = codec_client_->makeRequestWithBody(\n      Http::TestRequestHeaderMapImpl{\n          {\":method\", \"POST\"},\n          {\":path\", \"/\"},\n          {\":scheme\", \"http\"},\n          {\":authority\", \"host\"},\n          {\"x-forwarded-for\", \"10.0.0.1\"},\n      },\n      1024);\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}}, true);\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().getStatusValue());\n}", "target": 0}
{"code": "extract_option(uschar **name, uschar **value)\n{\nuschar *n;\nuschar *v = smtp_cmd_data + Ustrlen(smtp_cmd_data) - 1;\nwhile (isspace(*v)) v--;\nv[1] = 0;\nwhile (v > smtp_cmd_data && *v != '=' && !isspace(*v))\n  {\n  if (*v == '\"') do v--; while (*v != '\"' && v > smtp_cmd_data+1);\n  v--;\n  }\nn = v;\nif (*v == '=')\n  {\n  while(isalpha(n[-1])) n--;\n  if (!isspace(n[-1])) return FALSE;\n  n[-1] = 0;\n  }\nelse\n  {\n  n++;\n  if (v == smtp_cmd_data) return FALSE;\n  }\n*v++ = 0;\n*name = n;\n*value = v;\nreturn TRUE;\n}", "target": 0}
{"code": "static int dnxhd_init_vlc(DNXHDContext *ctx, uint32_t cid, int bitdepth)\n{\n    if (cid != ctx->cid) {\n        const CIDEntry *cid_table = ff_dnxhd_get_cid_table(cid);\n        if (!cid_table) {\n            av_log(ctx->avctx, AV_LOG_ERROR, \"unsupported cid %\"PRIu32\"\\n\", cid);\n            return AVERROR(ENOSYS);\n        }\n        if (cid_table->bit_depth != bitdepth &&\n            cid_table->bit_depth != DNXHD_VARIABLE) {\n            av_log(ctx->avctx, AV_LOG_ERROR, \"bit depth mismatches %d %d\\n\",\n                   cid_table->bit_depth, bitdepth);\n            return AVERROR_INVALIDDATA;\n        }\n        ctx->cid_table = cid_table;\n        av_log(ctx->avctx, AV_LOG_VERBOSE, \"Profile cid %\"PRIu32\".\\n\", cid);\n        ff_free_vlc(&ctx->ac_vlc);\n        ff_free_vlc(&ctx->dc_vlc);\n        ff_free_vlc(&ctx->run_vlc);\n        init_vlc(&ctx->ac_vlc, DNXHD_VLC_BITS, 257,\n                 ctx->cid_table->ac_bits, 1, 1,\n                 ctx->cid_table->ac_codes, 2, 2, 0);\n        init_vlc(&ctx->dc_vlc, DNXHD_DC_VLC_BITS, bitdepth > 8 ? 14 : 12,\n                 ctx->cid_table->dc_bits, 1, 1,\n                 ctx->cid_table->dc_codes, 1, 1, 0);\n        init_vlc(&ctx->run_vlc, DNXHD_VLC_BITS, 62,\n                 ctx->cid_table->run_bits, 1, 1,\n                 ctx->cid_table->run_codes, 2, 2, 0);\n        ctx->cid = cid;\n    }\n    return 0;\n}", "target": 1}
{"code": "static inline Status ParseAndCheckBoxSizes(const Tensor& boxes,\n                                           const Tensor& box_index,\n                                           int* num_boxes) {\n  if (boxes.NumElements() == 0 && box_index.NumElements() == 0) {\n    *num_boxes = 0;\n    return Status::OK();\n  }\n  if (boxes.dims() != 2) {\n    return errors::InvalidArgument(\"boxes must be 2-D\",\n                                   boxes.shape().DebugString());\n  }\n  *num_boxes = boxes.dim_size(0);\n  if (boxes.dim_size(1) != 4) {\n    return errors::InvalidArgument(\"boxes must have 4 columns\");\n  }\n  if (box_index.dims() != 1) {\n    return errors::InvalidArgument(\"box_index must be 1-D\",\n                                   box_index.shape().DebugString());\n  }\n  if (box_index.dim_size(0) != *num_boxes) {\n    return errors::InvalidArgument(\"box_index has incompatible shape\");\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "xfs_queue_eofblocks(\n\tstruct xfs_mount *mp)\n{\n\trcu_read_lock();\n\tif (radix_tree_tagged(&mp->m_perag_tree, XFS_ICI_EOFBLOCKS_TAG))\n\t\tqueue_delayed_work(mp->m_eofblocks_workqueue,\n\t\t\t\t   &mp->m_eofblocks_work,\n\t\t\t\t   msecs_to_jiffies(xfs_eofb_secs * 1000));\n\trcu_read_unlock();\n}", "target": 0}
{"code": "inspect_evbuffer(struct evbuffer *buf, char **data_out, size_t n,\n                 int *free_out, struct evbuffer_ptr *pos)\n{\n  int n_vecs, i;\n  if (evbuffer_get_length(buf) < n)\n    n = evbuffer_get_length(buf);\n  if (n == 0)\n    return 0;\n  n_vecs = evbuffer_peek(buf, n, pos, NULL, 0);\n  tor_assert(n_vecs > 0);\n  if (n_vecs == 1) {\n    struct evbuffer_iovec v;\n    i = evbuffer_peek(buf, n, pos, &v, 1);\n    tor_assert(i == 1);\n    *data_out = v.iov_base;\n    *free_out = 0;\n    return v.iov_len;\n  } else {\n    ev_ssize_t copied;\n    *data_out = tor_malloc(n);\n    *free_out = 1;\n    copied = evbuffer_copyout(buf, *data_out, n);\n    tor_assert(copied >= 0 && (size_t)copied == n);\n    return copied;\n  }\n}", "target": 0}
{"code": "con_insert_unipair(struct uni_pagedir *p, u_short unicode, u_short fontpos)\n{\n\tint i, n;\n\tu16 **p1, *p2;\n\tp1 = p->uni_pgdir[n = unicode >> 11];\n\tif (!p1) {\n\t\tp1 = p->uni_pgdir[n] = kmalloc_array(32, sizeof(u16 *),\n\t\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!p1) return -ENOMEM;\n\t\tfor (i = 0; i < 32; i++)\n\t\t\tp1[i] = NULL;\n\t}\n\tp2 = p1[n = (unicode >> 6) & 0x1f];\n\tif (!p2) {\n\t\tp2 = p1[n] = kmalloc_array(64, sizeof(u16), GFP_KERNEL);\n\t\tif (!p2) {\n\t\t\tkfree(p1);\n\t\t\tp->uni_pgdir[n] = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemset(p2, 0xff, 64*sizeof(u16)); \n\t}\n\tp2[unicode & 0x3f] = fontpos;\n\tp->sum += (fontpos << 20) + unicode;\n\treturn 0;\n}", "target": 1}
{"code": "rdp_process_general_caps(STREAM s)\n{\n\tuint16 pad2octetsB;\t\n\tin_uint8s(s, 10);\n\tin_uint16_le(s, pad2octetsB);\n\tif (!pad2octetsB)\n\t\tg_rdp_version = RDP_V4;\n}", "target": 0}
{"code": "void Statement::Work_AfterPrepare(napi_env e, napi_status status, void* data) {\n    std::unique_ptr<PrepareBaton> baton(static_cast<PrepareBaton*>(data));\n    Statement* stmt = baton->stmt;\n    Napi::Env env = stmt->Env();\n    Napi::HandleScope scope(env);\n    if (stmt->status != SQLITE_OK) {\n        Error(baton.get());\n        stmt->Finalize_();\n    }\n    else {\n        stmt->prepared = true;\n        if (!baton->callback.IsEmpty() && baton->callback.Value().IsFunction()) {\n            Napi::Function cb = baton->callback.Value();\n            Napi::Value argv[] = { env.Null() };\n            TRY_CATCH_CALL(stmt->Value(), cb, 1, argv);\n        }\n    }\n    STATEMENT_END();\n}", "target": 0}
{"code": "static int sanity_check_raw_super(struct super_block *sb,\n\t\t\tstruct f2fs_super_block *raw_super)\n{\n\tunsigned int blocksize;\n\tif (F2FS_SUPER_MAGIC != le32_to_cpu(raw_super->magic)) {\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\"Magic Mismatch, valid(0x%x) - read(0x%x)\",\n\t\t\tF2FS_SUPER_MAGIC, le32_to_cpu(raw_super->magic));\n\t\treturn 1;\n\t}\n\tif (F2FS_BLKSIZE != PAGE_CACHE_SIZE) {\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\"Invalid page_cache_size (%lu), supports only 4KB\\n\",\n\t\t\tPAGE_CACHE_SIZE);\n\t\treturn 1;\n\t}\n\tblocksize = 1 << le32_to_cpu(raw_super->log_blocksize);\n\tif (blocksize != F2FS_BLKSIZE) {\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\"Invalid blocksize (%u), supports only 4KB\\n\",\n\t\t\tblocksize);\n\t\treturn 1;\n\t}\n\tif (le32_to_cpu(raw_super->log_sectorsize) >\n\t\t\t\tF2FS_MAX_LOG_SECTOR_SIZE ||\n\t\tle32_to_cpu(raw_super->log_sectorsize) <\n\t\t\t\tF2FS_MIN_LOG_SECTOR_SIZE) {\n\t\tf2fs_msg(sb, KERN_INFO, \"Invalid log sectorsize (%u)\",\n\t\t\tle32_to_cpu(raw_super->log_sectorsize));\n\t\treturn 1;\n\t}\n\tif (le32_to_cpu(raw_super->log_sectors_per_block) +\n\t\tle32_to_cpu(raw_super->log_sectorsize) !=\n\t\t\tF2FS_MAX_LOG_SECTOR_SIZE) {\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\"Invalid log sectors per block(%u) log sectorsize(%u)\",\n\t\t\tle32_to_cpu(raw_super->log_sectors_per_block),\n\t\t\tle32_to_cpu(raw_super->log_sectorsize));\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static bool tailmatch(const char *little, const char *bigone)\n{\n  size_t littlelen = strlen(little);\n  size_t biglen = strlen(bigone);\n  if(littlelen > biglen)\n    return FALSE;\n  return Curl_raw_equal(little, bigone+biglen-littlelen) ? TRUE : FALSE;\n}", "target": 1}
{"code": "static int snd_timer_stop1(struct snd_timer_instance *timeri, bool stop)\n{\n\tstruct snd_timer *timer;\n\tint result = 0;\n\tunsigned long flags;\n\ttimer = timeri->timer;\n\tif (!timer)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&timer->lock, flags);\n\tif (!(timeri->flags & (SNDRV_TIMER_IFLG_RUNNING |\n\t\t\t       SNDRV_TIMER_IFLG_START))) {\n\t\tresult = -EBUSY;\n\t\tgoto unlock;\n\t}\n\tlist_del_init(&timeri->ack_list);\n\tlist_del_init(&timeri->active_list);\n\tif (timer->card && timer->card->shutdown)\n\t\tgoto unlock;\n\tif (stop) {\n\t\ttimeri->cticks = timeri->ticks;\n\t\ttimeri->pticks = 0;\n\t}\n\tif ((timeri->flags & SNDRV_TIMER_IFLG_RUNNING) &&\n\t    !(--timer->running)) {\n\t\ttimer->hw.stop(timer);\n\t\tif (timer->flags & SNDRV_TIMER_FLG_RESCHED) {\n\t\t\ttimer->flags &= ~SNDRV_TIMER_FLG_RESCHED;\n\t\t\tsnd_timer_reschedule(timer, 0);\n\t\t\tif (timer->flags & SNDRV_TIMER_FLG_CHANGE) {\n\t\t\t\ttimer->flags &= ~SNDRV_TIMER_FLG_CHANGE;\n\t\t\t\ttimer->hw.start(timer);\n\t\t\t}\n\t\t}\n\t}\n\ttimeri->flags &= ~(SNDRV_TIMER_IFLG_RUNNING | SNDRV_TIMER_IFLG_START);\n\tsnd_timer_notify1(timeri, stop ? SNDRV_TIMER_EVENT_STOP :\n\t\t\t  SNDRV_TIMER_EVENT_CONTINUE);\n unlock:\n\tspin_unlock_irqrestore(&timer->lock, flags);\n\treturn result;\n}", "target": 0}
{"code": "JANET_CORE_FN(cfun_array_ensure,\n              \"(array/ensure arr capacity growth)\",\n              \"Ensures that the memory backing the array is large enough for `capacity` \"\n              \"items at the given rate of growth. `capacity` and `growth` must be integers. \"\n              \"If the backing capacity is already enough, then this function does nothing. \"\n              \"Otherwise, the backing memory will be reallocated so that there is enough space.\") {\n    janet_fixarity(argc, 3);\n    JanetArray *array = janet_getarray(argv, 0);\n    int32_t newcount = janet_getinteger(argv, 1);\n    int32_t growth = janet_getinteger(argv, 2);\n    if (newcount < 1) janet_panic(\"expected positive integer\");\n    janet_array_ensure(array, newcount, growth);\n    return argv[0];\n}", "target": 0}
{"code": "static inline const unsigned char *fsnotify_oldname_init(const unsigned char *name)\n{\n\treturn kstrdup(name, GFP_KERNEL);\n}", "target": 1}
{"code": "static int ExecuteHelp( SQLHDBC hDbc, char *szSQL, char cDelimiter, int bColumnNames, int bHTMLTable )\n{\n    char            szTable[250]                        = \"\";\n    SQLHSTMT        hStmt;\n    SQLTCHAR        szSepLine[32001];   \n    SQLLEN          nRows               = 0;\n    szSepLine[ 0 ] = 0;\n    if ( SQLAllocStmt( hDbc, &hStmt ) != SQL_SUCCESS )\n    {\n        if ( bVerbose ) DumpODBCLog( hEnv, hDbc, 0 );\n        fprintf( stderr, \"[ISQL]ERROR: Could not SQLAllocStmt\\n\" );\n        return 0;\n    }\n    if ( iniElement( szSQL, ' ', '\\0', 1, szTable, sizeof(szTable) ) == INI_SUCCESS )\n    {\n        SQLWCHAR tname[ 1024 ];\n        ansi_to_unicode( szTable, tname );\n        if ( SQLColumns( hStmt, NULL, 0, NULL, 0, tname, SQL_NTS, NULL, 0 ) != SQL_SUCCESS )\n        {\n            if ( bVerbose ) DumpODBCLog( hEnv, hDbc, hStmt );\n            fprintf( stderr, \"[ISQL]ERROR: Could not SQLColumns\\n\" );\n            SQLFreeStmt( hStmt, SQL_DROP );\n            return 0;\n        }\n    }\n    else\n    {\n        if ( SQLTables( hStmt, NULL, 0, NULL, 0, NULL, 0, NULL, 0 ) != SQL_SUCCESS )\n        {\n            if ( bVerbose ) DumpODBCLog( hEnv, hDbc, hStmt );\n            fprintf( stderr, \"[ISQL]ERROR: Could not SQLTables\\n\" );\n            SQLFreeStmt( hStmt, SQL_DROP );\n            return 0;\n        }\n    }\n    if ( bHTMLTable )\n        WriteHeaderHTMLTable( hStmt );\n    else if ( cDelimiter == 0 )\n        UWriteHeaderNormal( hStmt, szSepLine );\n    else if ( cDelimiter && bColumnNames )\n        WriteHeaderDelimited( hStmt, cDelimiter );\n    if ( bHTMLTable )\n        WriteBodyHTMLTable( hStmt );\n    else if ( cDelimiter == 0 )\n        nRows = WriteBodyNormal( hStmt );\n    else\n        WriteBodyDelimited( hStmt, cDelimiter );\n    if ( bHTMLTable )\n        WriteFooterHTMLTable( hStmt );\n    else if ( cDelimiter == 0 )\n        UWriteFooterNormal( hStmt, szSepLine, nRows );\n    SQLFreeStmt( hStmt, SQL_DROP );\n    return 1;\n}", "target": 0}
{"code": "static void nvme_aio_err(NvmeRequest *req, int ret)\n{\n    uint16_t status = NVME_SUCCESS;\n    Error *local_err = NULL;\n    switch (req->cmd.opcode) {\n    case NVME_CMD_READ:\n        status = NVME_UNRECOVERED_READ;\n        break;\n    case NVME_CMD_FLUSH:\n    case NVME_CMD_WRITE:\n    case NVME_CMD_WRITE_ZEROES:\n    case NVME_CMD_ZONE_APPEND:\n        status = NVME_WRITE_FAULT;\n        break;\n    default:\n        status = NVME_INTERNAL_DEV_ERROR;\n        break;\n    }\n    trace_pci_nvme_err_aio(nvme_cid(req), strerror(-ret), status);\n    error_setg_errno(&local_err, -ret, \"aio failed\");\n    error_report_err(local_err);\n    if (req->status && status != NVME_INTERNAL_DEV_ERROR) {\n        return;\n    }\n    req->status = status;\n}", "target": 0}
{"code": "spnego_gss_wrap_aead(OM_uint32 *minor_status,\n\t\t     gss_ctx_id_t context_handle,\n\t\t     int conf_req_flag,\n\t\t     gss_qop_t qop_req,\n\t\t     gss_buffer_t input_assoc_buffer,\n\t\t     gss_buffer_t input_payload_buffer,\n\t\t     int *conf_state,\n\t\t     gss_buffer_t output_message_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_aead(minor_status,\n\t\t\t    context_handle,\n\t\t\t    conf_req_flag,\n\t\t\t    qop_req,\n\t\t\t    input_assoc_buffer,\n\t\t\t    input_payload_buffer,\n\t\t\t    conf_state,\n\t\t\t    output_message_buffer);\n\treturn (ret);\n}", "target": 0}
{"code": "static int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_cdef_t *cdef = &box->data.cdef;\n\tjp2_cdefchan_t *chan;\n\tunsigned int channo;\n\tcdef->ents = 0;\n\tif (jp2_getuint16(in, &cdef->numchans)) {\n\t\treturn -1;\n\t}\n\tif (!(cdef->ents = jas_alloc2(cdef->numchans, sizeof(jp2_cdefchan_t)))) {\n\t\treturn -1;\n\t}\n\tfor (channo = 0; channo < cdef->numchans; ++channo) {\n\t\tchan = &cdef->ents[channo];\n\t\tif (jp2_getuint16(in, &chan->channo) || jp2_getuint16(in, &chan->type) ||\n\t\t  jp2_getuint16(in, &chan->assoc)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "lys_getnext_data(const struct lys_module *mod, const struct lys_node *parent, const char *name, int nam_len,\n                 LYS_NODE type, const struct lys_node **ret)\n{\n    const struct lys_node *node;\n    assert((mod || parent) && name);\n    assert(!(type & (LYS_AUGMENT | LYS_USES | LYS_GROUPING | LYS_CHOICE | LYS_CASE | LYS_INPUT | LYS_OUTPUT)));\n    if (!mod) {\n        mod = lys_node_module(parent);\n    }\n    node = NULL;\n    while ((node = lys_getnext(node, parent, mod, 0))) {\n        if (!type || (node->nodetype & type)) {\n            if (lys_node_module(node) != lys_main_module(mod)) {\n                continue;\n            }\n            if (!strncmp(node->name, name, nam_len) && !node->name[nam_len]) {\n                if (ret) {\n                    *ret = node;\n                }\n                return EXIT_SUCCESS;\n            }\n        }\n    }\n    return EXIT_FAILURE;\n}", "target": 1}
{"code": "xmlValidNormalizeAttributeValue(xmlDocPtr doc, xmlNodePtr elem,\n\t\t\t        const xmlChar *name, const xmlChar *value) {\n    xmlChar *ret, *dst;\n    const xmlChar *src;\n    xmlAttributePtr attrDecl = NULL;\n    if (doc == NULL) return(NULL);\n    if (elem == NULL) return(NULL);\n    if (name == NULL) return(NULL);\n    if (value == NULL) return(NULL);\n    if ((elem->ns != NULL) && (elem->ns->prefix != NULL)) {\n\txmlChar fn[50];\n\txmlChar *fullname;\n\tfullname = xmlBuildQName(elem->name, elem->ns->prefix, fn, 50);\n\tif (fullname == NULL)\n\t    return(NULL);\n\tif ((fullname != fn) && (fullname != elem->name))\n\t    xmlFree(fullname);\n    }\n    attrDecl = xmlGetDtdAttrDesc(doc->intSubset, elem->name, name);\n    if ((attrDecl == NULL) && (doc->extSubset != NULL))\n\tattrDecl = xmlGetDtdAttrDesc(doc->extSubset, elem->name, name);\n    if (attrDecl == NULL)\n\treturn(NULL);\n    if (attrDecl->atype == XML_ATTRIBUTE_CDATA)\n\treturn(NULL);\n    ret = xmlStrdup(value);\n    if (ret == NULL)\n\treturn(NULL);\n    src = value;\n    dst = ret;\n    while (*src == 0x20) src++;\n    while (*src != 0) {\n\tif (*src == 0x20) {\n\t    while (*src == 0x20) src++;\n\t    if (*src != 0)\n\t\t*dst++ = 0x20;\n\t} else {\n\t    *dst++ = *src++;\n\t}\n    }\n    *dst = 0;\n    return(ret);\n}", "target": 1}
{"code": "UnicodeString DecimalQuantity::toScientificString() const {\n    U_ASSERT(!isApproximate);\n    UnicodeString result;\n    if (isNegative()) {\n        result.append(u'-');\n    }\n    if (precision == 0) {\n        result.append(u\"0E+0\", -1);\n        return result;\n    }\n    int32_t upperPos = std::min(precision + scale, lOptPos) - scale - 1;\n    int32_t lowerPos = std::max(scale, rOptPos) - scale;\n    int32_t p = upperPos;\n    result.append(u'0' + getDigitPos(p));\n    if ((--p) >= lowerPos) {\n        result.append(u'.');\n        for (; p >= lowerPos; p--) {\n            result.append(u'0' + getDigitPos(p));\n        }\n    }\n    result.append(u'E');\n    int32_t _scale = upperPos + scale;\n    if (_scale < 0) {\n        _scale *= -1;\n        result.append(u'-');\n    } else {\n        result.append(u'+');\n    }\n    if (_scale == 0) {\n        result.append(u'0');\n    }\n    int32_t insertIndex = result.length();\n    while (_scale > 0) {\n        std::div_t res = std::div(_scale, 10);\n        result.insert(insertIndex, u'0' + res.rem);\n        _scale = res.quot;\n    }\n    return result;\n}", "target": 1}
{"code": "  explicit ReverseSequenceOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"batch_dim\", &batch_dim_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seq_dim\", &seq_dim_));\n  }", "target": 1}
{"code": "static GCObject **correctgraylist (GCObject **p) {\n  GCObject *curr;\n  while ((curr = *p) != NULL) {\n    switch (curr->tt) {\n      case LUA_VTABLE: case LUA_VUSERDATA: {\n        GCObject **next = getgclist(curr);\n        if (getage(curr) == G_TOUCHED1) {  \n          lua_assert(isgray(curr));\n          gray2black(curr);  \n          changeage(curr, G_TOUCHED1, G_TOUCHED2);\n          p = next;  \n        }\n        else {  \n          if (!iswhite(curr)) {  \n            lua_assert(isold(curr));\n            if (getage(curr) == G_TOUCHED2)  \n              changeage(curr, G_TOUCHED2, G_OLD);  \n            gray2black(curr);  \n          }\n          *p = *next;  \n        }\n        break;\n      }\n      case LUA_VTHREAD: {\n        lua_State *th = gco2th(curr);\n        lua_assert(!isblack(th));\n        if (iswhite(th))  \n          *p = th->gclist;  \n        else  \n          p = &th->gclist;  \n        break;\n      }\n      default: lua_assert(0);  \n    }\n  }\n  return p;\n}", "target": 1}
{"code": "void ogs_nas_5gs_mobile_identity_guti_to_nas_guti(\n        ogs_nas_5gs_mobile_identity_guti_t *mobile_identity_guti,\n        ogs_nas_5gs_guti_t *nas_guti)\n{\n    ogs_assert(mobile_identity_guti);\n    ogs_assert(nas_guti);\n    memset(nas_guti, 0, sizeof(*nas_guti));\n    memcpy(&nas_guti->nas_plmn_id,\n            &mobile_identity_guti->nas_plmn_id, OGS_PLMN_ID_LEN);\n    memcpy(&nas_guti->amf_id,\n            &mobile_identity_guti->amf_id, sizeof(ogs_amf_id_t));\n    nas_guti->m_tmsi = be32toh(mobile_identity_guti->m_tmsi);\n}", "target": 0}
{"code": "static inline int dpt_dma64(adpt_hba *pHba)\n{\n\treturn (sizeof(dma_addr_t) > 4 && (pHba)->dma64);\n}", "target": 1}
{"code": "static void cmv_decode_intra(CmvContext * s, AVFrame *frame,\n                             const uint8_t *buf, const uint8_t *buf_end)\n{\n    unsigned char *dst = frame->data[0];\n    int i;\n    for (i=0; i < s->avctx->height && buf_end - buf >= s->avctx->width; i++) {\n        memcpy(dst, buf, s->avctx->width);\n        dst += frame->linesize[0];\n        buf += s->avctx->width;\n    }\n}", "target": 0}
{"code": "die(uschar *s1, uschar *s2)\n{\nif (s1)\n  {\n  write_syslog(LOG_CRIT, s1);\n  if (debug_file) debug_printf(\"%s\\n\", s1);\n  if (log_stderr && log_stderr != debug_file)\n    fprintf(log_stderr, \"%s\\n\", s1);\n  }\nif (f.receive_call_bombout) receive_bomb_out(NULL, s2);  \nif (smtp_input) smtp_closedown(s2);\nexim_exit(EXIT_FAILURE, NULL);\n}", "target": 0}
{"code": "HttpRequest::maybeCacheable()\n{\n    if (!flags.hostVerified && (flags.intercepted || flags.interceptTproxy))\n        return false;\n    switch (url.getScheme()) {\n    case AnyP::PROTO_HTTP:\n    case AnyP::PROTO_HTTPS:\n        if (!method.respMaybeCacheable())\n            return false;\n        if (!flags.ignoreCc && cache_control && cache_control->hasNoStore())\n            return false;\n        break;\n    case AnyP::PROTO_GOPHER:\n        if (!gopherCachable(this))\n            return false;\n        break;\n    case AnyP::PROTO_CACHE_OBJECT:\n        return false;\n    default:\n        break;\n    }\n    return true;\n}", "target": 1}
{"code": "LayoutUnit RenderBox::availableLogicalHeightUsing(const Length& h) const\n{\n    if (h.isFixed())\n        return computeContentBoxLogicalHeight(h.value());\n    if (isRenderView())\n        return isHorizontalWritingMode() ? toRenderView(this)->frameView()->visibleHeight() : toRenderView(this)->frameView()->visibleWidth();\n     if (isTableCell() && (h.isAuto() || h.isPercent()))\n         return overrideHeight() - borderAndPaddingLogicalWidth();\n    if (h.isPercent())\n       return computeContentBoxLogicalHeight(h.calcValue(containingBlock()->availableLogicalHeight()));\n    if (isRenderBlock() && isPositioned() && style()->height().isAuto() && !(style()->top().isAuto() || style()->bottom().isAuto())) {\n        RenderBlock* block = const_cast<RenderBlock*>(toRenderBlock(this));\n        LayoutUnit oldHeight = block->logicalHeight();\n        block->computeLogicalHeight();\n        LayoutUnit newHeight = block->computeContentBoxLogicalHeight(block->contentLogicalHeight());\n        block->setLogicalHeight(oldHeight);\n        return computeContentBoxLogicalHeight(newHeight);\n    }\n    return containingBlock()->availableLogicalHeight();\n}", "target": 1}
{"code": "icc_conv_color(fz_context *ctx, fz_color_converter *cc, float *dstv, const float *srcv)\n{\n\tconst fz_colorspace *dsts = cc->ds;\n\tint src_n = cc->n;\n\tint dst_n = dsts->n;\n\tfz_icclink *link = (fz_icclink *)cc->link;\n\tint i;\n\tunsigned short dstv_s[FZ_MAX_COLORS];\n\tunsigned short srcv_s[FZ_MAX_COLORS];\n\tif (link == NULL)\n\t{\n\t\tdstv[0] = 0;\n\t\tdstv[1] = 0;\n\t\tdstv[2] = 0;\n\t\tdstv[3] = 1 - srcv[0];\n\t}\n\telse if (link->is_identity)\n\t{\n\t\tfor (i = 0; i < src_n; i++)\n\t\t\tdstv[i] = srcv[i];\n\t}\n\telse\n\t{\n\t\tfor (i = 0; i < src_n; i++)\n\t\t\tsrcv_s[i] = srcv[i] * 65535;\n\t\tfz_cmm_transform_color(ctx, link, dstv_s, srcv_s);\n\t\tfor (i = 0; i < dst_n; i++)\n\t\t\tdstv[i] = fz_clamp((float) dstv_s[i] / 65535.0f, 0, 1);\n\t}\n}", "target": 0}
{"code": "njs_typed_array_set_value(njs_vm_t *vm, njs_typed_array_t *array,\n    uint32_t index, njs_value_t *setval)\n{\n    double              num;\n    njs_int_t           ret;\n    njs_array_buffer_t  *buffer;\n    ret = njs_value_to_number(vm, setval, &num);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    buffer = njs_typed_array_writable(vm, array);\n    if (njs_slow_path(buffer == NULL)) {\n        return NJS_ERROR;\n    }\n    njs_typed_array_prop_set(vm, array, index, num);\n    njs_set_number(setval, num);\n    return NJS_OK;\n}", "target": 1}
{"code": "static void __init config_types(void)\n{\n\tbool has_drive = false;\n\tint drive;\n\tdrive = 0;\n\tif (!UDP->cmos)\n\t\tUDP->cmos = FLOPPY0_TYPE;\n\tdrive = 1;\n\tif (!UDP->cmos)\n\t\tUDP->cmos = FLOPPY1_TYPE;\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tunsigned int type = UDP->cmos;\n\t\tstruct floppy_drive_params *params;\n\t\tconst char *name = NULL;\n\t\tchar temparea[32];\n\t\tif (type < ARRAY_SIZE(default_drive_params)) {\n\t\t\tparams = &default_drive_params[type].params;\n\t\t\tif (type) {\n\t\t\t\tname = default_drive_params[type].name;\n\t\t\t\tallowed_drive_mask |= 1 << drive;\n\t\t\t} else\n\t\t\t\tallowed_drive_mask &= ~(1 << drive);\n\t\t} else {\n\t\t\tparams = &default_drive_params[0].params;\n\t\t\tsnprintf(temparea, sizeof(temparea),\n\t\t\t\t \"unknown type %d (usb?)\", type);\n\t\t\tname = temparea;\n\t\t}\n\t\tif (name) {\n\t\t\tconst char *prepend;\n\t\t\tif (!has_drive) {\n\t\t\t\tprepend = \"\";\n\t\t\t\thas_drive = true;\n\t\t\t\tpr_info(\"Floppy drive(s):\");\n\t\t\t} else {\n\t\t\t\tprepend = \",\";\n\t\t\t}\n\t\t\tpr_cont(\"%s fd%d is %s\", prepend, drive, name);\n\t\t}\n\t\t*UDP = *params;\n\t}\n\tif (has_drive)\n\t\tpr_cont(\"\\n\");\n}", "target": 0}
{"code": "int remove_file(struct augeas *aug, struct tree *tree) {\n    char *path = NULL;\n    const char *filename = NULL;\n    const char *err_status = NULL;\n    char *dyn_err_status = NULL;\n    char *augsave = NULL, *augorig = NULL, *augorig_canon = NULL;\n    int r;\n    path = path_of_tree(tree);\n    if (path == NULL) {\n        err_status = \"path_of_tree\";\n        goto error;\n    }\n    filename = path + strlen(AUGEAS_META_FILES);\n    if ((augorig = strappend(aug->root, filename + 1)) == NULL) {\n        err_status = \"root_file\";\n        goto error;\n    }\n    augorig_canon = canonicalize_file_name(augorig);\n    if (augorig_canon == NULL) {\n        if (errno == ENOENT) {\n            goto done;\n        } else {\n            err_status = \"canon_augorig\";\n            goto error;\n        }\n    }\n    r = file_saved_event(aug, path + strlen(AUGEAS_META_TREE));\n    if (r < 0) {\n        err_status = \"saved_event\";\n        goto error;\n    }\n    if (aug->flags & AUG_SAVE_NOOP)\n        goto done;\n    if (aug->flags & AUG_SAVE_BACKUP) {\n        r = asprintf(&augsave, \"%s\" EXT_AUGSAVE, augorig_canon);\n        if (r == -1) {\n            augsave = NULL;\n                goto error;\n        }\n        r = clone_file(augorig_canon, augsave, &err_status, 1, 1);\n        if (r != 0) {\n            dyn_err_status = strappend(err_status, \"_augsave\");\n            goto error;\n        }\n    } else {\n        r = unlink(augorig_canon);\n        if (r < 0) {\n            err_status = \"unlink_orig\";\n            goto error;\n        }\n    }\n    tree_unlink(tree);\n done:\n    free(path);\n    free(augorig);\n    free(augorig_canon);\n    free(augsave);\n    return 0;\n error:\n    {\n        const char *emsg =\n            dyn_err_status == NULL ? err_status : dyn_err_status;\n        store_error(aug, filename, path, emsg, errno, NULL, NULL);\n    }\n    free(path);\n    free(augorig);\n    free(augorig_canon);\n    free(augsave);\n    free(dyn_err_status);\n    return -1;\n}", "target": 0}
{"code": "static int llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t  int *uaddrlen, int peer)\n{\n\tstruct sockaddr_llc sllc;\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tint rc = 0;\n\tmemset(&sllc, 0, sizeof(sllc));\n\tlock_sock(sk);\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\t*uaddrlen = sizeof(sllc);\n\tmemset(uaddr, 0, *uaddrlen);\n\tif (peer) {\n\t\trc = -ENOTCONN;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\t\tif(llc->dev)\n\t\t\tsllc.sllc_arphrd = llc->dev->type;\n\t\tsllc.sllc_sap = llc->daddr.lsap;\n\t\tmemcpy(&sllc.sllc_mac, &llc->daddr.mac, IFHWADDRLEN);\n\t} else {\n\t\trc = -EINVAL;\n\t\tif (!llc->sap)\n\t\t\tgoto out;\n\t\tsllc.sllc_sap = llc->sap->laddr.lsap;\n\t\tif (llc->dev) {\n\t\t\tsllc.sllc_arphrd = llc->dev->type;\n\t\t\tmemcpy(&sllc.sllc_mac, llc->dev->dev_addr,\n\t\t\t       IFHWADDRLEN);\n\t\t}\n\t}\n\trc = 0;\n\tsllc.sllc_family = AF_LLC;\n\tmemcpy(uaddr, &sllc, sizeof(sllc));\nout:\n\trelease_sock(sk);\n\treturn rc;\n}", "target": 1}
{"code": "int32_t cli_bcapi_extract_new(struct cli_bc_ctx *ctx, int32_t id)\n{\n    cli_ctx *cctx;\n    int res = -1;\n    cli_event_count(EV, BCEV_EXTRACTED);\n    cli_dbgmsg(\"previous tempfile had %u bytes\\n\", ctx->written);\n    if (!ctx->written)\n\treturn 0;\n    if (ctx->ctx && cli_updatelimits(ctx->ctx, ctx->written))\n\treturn -1;\n    ctx->written = 0;\n    lseek(ctx->outfd, 0, SEEK_SET);\n    cli_dbgmsg(\"bytecode: scanning extracted file %s\\n\", ctx->tempfile);\n    cctx = (cli_ctx*)ctx->ctx;\n    if (cctx) {\n\tcli_file_t current = cctx->container_type;\n\tif (ctx->containertype != CL_TYPE_ANY)\n\t    cctx->container_type = ctx->containertype;\n\tres = cli_magic_scandesc(ctx->outfd, cctx);\n\tcctx->container_type = current;\n\tif (res == CL_VIRUS) {\n\t    if (cctx->virname)\n\t\tctx->virname = *cctx->virname;\n\t    ctx->found = 1;\n\t}\n    }\n    if ((cctx && cctx->engine->keeptmp) ||\n\t(ftruncate(ctx->outfd, 0) == -1)) {\n\tclose(ctx->outfd);\n\tif (!(cctx && cctx->engine->keeptmp) && ctx->tempfile)\n\t    cli_unlink(ctx->tempfile);\n\tfree(ctx->tempfile);\n\tctx->tempfile = NULL;\n\tctx->outfd = 0;\n    }\n    cli_dbgmsg(\"bytecode: extracting new file with id %u\\n\", id);\n    return res;\n}", "target": 1}
{"code": "static int open_fuse_device(char **devp)\n{\n\tint fd = try_open_fuse_device(devp);\n\tif (fd >= -1)\n\t\treturn fd;\n\tfprintf(stderr,\n\t\t\"%s: fuse device not found, try 'modprobe fuse' first\\n\",\n\t\tprogname);\n\treturn -1;\n}", "target": 0}
{"code": "static inline void x86_assign_hw_event(struct perf_event *event,\n\t\t\t\tstruct cpu_hw_events *cpuc, int i)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\thwc->idx = cpuc->assign[i];\n\thwc->last_cpu = smp_processor_id();\n\thwc->last_tag = ++cpuc->tags[i];\n\tif (hwc->idx == X86_PMC_IDX_FIXED_BTS) {\n\t\thwc->config_base = 0;\n\t\thwc->event_base\t= 0;\n\t} else if (hwc->idx >= X86_PMC_IDX_FIXED) {\n\t\thwc->config_base = MSR_ARCH_PERFMON_FIXED_CTR_CTRL;\n\t\thwc->event_base = MSR_ARCH_PERFMON_FIXED_CTR0;\n\t} else {\n\t\thwc->config_base = x86_pmu_config_addr(hwc->idx);\n\t\thwc->event_base  = x86_pmu_event_addr(hwc->idx);\n\t}\n}", "target": 1}
{"code": "asmlinkage long compat_sys_ptrace(compat_long_t request, compat_long_t pid,\n\t\t\t\t  compat_long_t addr, compat_long_t data)\n{\n\tstruct task_struct *child;\n\tlong ret;\n\tif (request == PTRACE_TRACEME) {\n\t\tret = ptrace_traceme();\n\t\tgoto out;\n\t}\n\tchild = ptrace_get_task_struct(pid);\n\tif (IS_ERR(child)) {\n\t\tret = PTR_ERR(child);\n\t\tgoto out;\n\t}\n\tif (request == PTRACE_ATTACH || request == PTRACE_SEIZE) {\n\t\tret = ptrace_attach(child, request, addr, data);\n\t\tif (!ret)\n\t\t\tarch_ptrace_attach(child);\n\t\tgoto out_put_task_struct;\n\t}\n\tret = ptrace_check_attach(child, request == PTRACE_KILL ||\n\t\t\t\t  request == PTRACE_INTERRUPT);\n\tif (!ret)\n\t\tret = compat_arch_ptrace(child, request, addr, data);\n out_put_task_struct:\n\tput_task_struct(child);\n out:\n\treturn ret;\n}", "target": 1}
{"code": "cleanup_bmc_device(struct kref *ref)\n{\n\tstruct bmc_device *bmc = container_of(ref, struct bmc_device, usecount);\n\tschedule_work(&bmc->remove_work);\n}", "target": 0}
{"code": "static void tcp_new_space(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tif (tcp_should_expand_sndbuf(sk)) {\n\t\ttcp_sndbuf_expand(sk);\n\t\ttp->snd_cwnd_stamp = tcp_time_stamp;\n\t}\n\tsk->sk_write_space(sk);\n}", "target": 0}
{"code": "static inline u32 net_hash_mix(const struct net *net)\n{\n#ifdef CONFIG_NET_NS\n\treturn (u32)(((unsigned long)net) >> ilog2(sizeof(*net)));\n#else\n\treturn 0;\n#endif\n}", "target": 1}
{"code": "static int nla_validate_array(const struct nlattr *head, int len, int maxtype,\n\t\t\t      const struct nla_policy *policy,\n\t\t\t      struct netlink_ext_ack *extack,\n\t\t\t      unsigned int validate)\n{\n\tconst struct nlattr *entry;\n\tint rem;\n\tnla_for_each_attr(entry, head, len, rem) {\n\t\tint ret;\n\t\tif (nla_len(entry) == 0)\n\t\t\tcontinue;\n\t\tif (nla_len(entry) < NLA_HDRLEN) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, entry,\n\t\t\t\t\t    \"Array element too short\");\n\t\t\treturn -ERANGE;\n\t\t}\n\t\tret = __nla_validate(nla_data(entry), nla_len(entry),\n\t\t\t\t     maxtype, policy, validate, extack);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void Archive::Seek(int64 Offset,int Method)\n{\n  if (!QOpen.Seek(Offset,Method))\n    File::Seek(Offset,Method);\n}", "target": 1}
{"code": "int re_yylex_init_extra(YY_EXTRA_TYPE yy_user_defined,yyscan_t* ptr_yy_globals )\n{\n    struct yyguts_t dummy_yyguts;\n    re_yyset_extra (yy_user_defined, &dummy_yyguts);\n    if (ptr_yy_globals == NULL){\n        errno = EINVAL;\n        return 1;\n    }\n    *ptr_yy_globals = (yyscan_t) re_yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );\n    if (*ptr_yy_globals == NULL){\n        errno = ENOMEM;\n        return 1;\n    }\n    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));\n    re_yyset_extra (yy_user_defined, *ptr_yy_globals);\n    return yy_init_globals ( *ptr_yy_globals );", "target": 1}
{"code": "static bool disconnect_cb(struct io *io, void *user_data)\n{\n\tstruct bt_att_chan *chan = user_data;\n\tstruct bt_att *att = chan->att;\n\tint err;\n\tsocklen_t len;\n\tlen = sizeof(err);\n\tif (getsockopt(chan->fd, SOL_SOCKET, SO_ERROR, &err, &len) < 0) {\n\t\tutil_debug(chan->att->debug_callback, chan->att->debug_data,\n\t\t\t\t\t\"(chan %p) Failed to obtain disconnect\"\n\t\t\t\t\t\" error: %s\", chan, strerror(errno));\n\t\terr = 0;\n\t}\n\tutil_debug(chan->att->debug_callback, chan->att->debug_data,\n\t\t\t\t\t\"Channel %p disconnected: %s\",\n\t\t\t\t\tchan, strerror(err));\n\tqueue_remove(att->chans, chan);\n\tqueue_remove_all(att->req_queue, NULL, NULL, disc_att_send_op);\n\tqueue_remove_all(att->ind_queue, NULL, NULL, disc_att_send_op);\n\tqueue_remove_all(att->write_queue, NULL, NULL, disc_att_send_op);\n\tif (chan->pending_req) {\n\t\tdisc_att_send_op(chan->pending_req);\n\t\tchan->pending_req = NULL;\n\t}\n\tif (chan->pending_ind) {\n\t\tdisc_att_send_op(chan->pending_ind);\n\t\tchan->pending_ind = NULL;\n\t}\n\tbt_att_chan_free(chan);\n\tif (!queue_isempty(att->chans))\n\t\treturn false;\n\tbt_att_ref(att);\n\tqueue_foreach(att->disconn_list, disconn_handler, INT_TO_PTR(err));\n\tbt_att_unregister_all(att);\n\tbt_att_unref(att);\n\treturn false;\n}", "target": 1}
{"code": "static int ref_pic_list_struct(GetBitContext *gb, RefPicListStruct *rpl)\n{\n    uint32_t delta_poc_st, strp_entry_sign_flag = 0;\n    rpl->ref_pic_num = get_ue_golomb_long(gb);\n    if (rpl->ref_pic_num > 0) {\n        delta_poc_st = get_ue_golomb_long(gb);\n        rpl->ref_pics[0] = delta_poc_st;\n        if (rpl->ref_pics[0] != 0) {\n            strp_entry_sign_flag = get_bits(gb, 1);\n            rpl->ref_pics[0] *= 1 - (strp_entry_sign_flag << 1);\n        }\n    }\n    for (int i = 1; i < rpl->ref_pic_num; ++i) {\n        delta_poc_st = get_ue_golomb_long(gb);\n        if (delta_poc_st != 0)\n            strp_entry_sign_flag = get_bits(gb, 1);\n        rpl->ref_pics[i] = rpl->ref_pics[i - 1] + delta_poc_st * (1 - (strp_entry_sign_flag << 1));\n    }\n    return 0;\n}", "target": 1}
{"code": "activate_desktop_file (ActivateParameters *parameters,\n                       NautilusFile       *file)\n{\n    ActivateParametersDesktop *parameters_desktop;\n    char *primary, *secondary, *display_name;\n    GtkWidget *dialog;\n    GdkScreen *screen;\n    char *uri;\n    screen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window));\n    if (!nautilus_file_is_trusted_link (file))\n    {\n        parameters_desktop = g_new0 (ActivateParametersDesktop, 1);\n        if (parameters->parent_window)\n        {\n            parameters_desktop->parent_window = parameters->parent_window;\n            g_object_add_weak_pointer (G_OBJECT (parameters_desktop->parent_window), (gpointer *) &parameters_desktop->parent_window);\n        }\n        parameters_desktop->file = nautilus_file_ref (file);\n        primary = _(\"Untrusted application launcher\");\n        display_name = nautilus_file_get_display_name (file);\n        secondary =\n            g_strdup_printf (_(\"The application launcher “%s” has not been marked as trusted. \"\n                               \"If you do not know the source of this file, launching it may be unsafe.\"\n                               ),\n                             display_name);\n        dialog = gtk_message_dialog_new (parameters->parent_window,\n                                         0,\n                                         GTK_MESSAGE_WARNING,\n                                         GTK_BUTTONS_NONE,\n                                         NULL);\n        g_object_set (dialog,\n                      \"text\", primary,\n                      \"secondary-text\", secondary,\n                      NULL);\n        gtk_dialog_add_button (GTK_DIALOG (dialog),\n                               _(\"_Launch Anyway\"), RESPONSE_RUN);\n        if (nautilus_file_can_set_permissions (file))\n        {\n            gtk_dialog_add_button (GTK_DIALOG (dialog),\n                                   _(\"Mark as _Trusted\"), RESPONSE_MARK_TRUSTED);\n        }\n        gtk_dialog_add_button (GTK_DIALOG (dialog),\n                               _(\"_Cancel\"), GTK_RESPONSE_CANCEL);\n        gtk_dialog_set_default_response (GTK_DIALOG (dialog), GTK_RESPONSE_CANCEL);\n        g_signal_connect (dialog, \"response\",\n                          G_CALLBACK (untrusted_launcher_response_callback),\n                          parameters_desktop);\n        gtk_widget_show (dialog);\n        g_free (display_name);\n        g_free (secondary);\n        return;\n    }\n    uri = nautilus_file_get_uri (file);\n    DEBUG (\"Launching trusted launcher %s\", uri);\n    nautilus_launch_desktop_file (screen, uri, NULL,\n                                  parameters->parent_window);\n    g_free (uri);\n}", "target": 1}
{"code": "static AVFrame *get_video_buffer(AVFilterLink *inlink, int w, int h)\n{\n    PadContext *s = inlink->dst->priv;\n    AVFrame *frame = ff_get_video_buffer(inlink->dst->outputs[0],\n                                         w + (s->w - s->in_w),\n                                         h + (s->h - s->in_h));\n    int plane;\n    if (!frame)\n        return NULL;\n    frame->width  = w;\n    frame->height = h;\n    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {\n        int hsub = s->draw.hsub[plane];\n        int vsub = s->draw.vsub[plane];\n        frame->data[plane] += (s->x >> hsub) * s->draw.pixelstep[plane] +\n                              (s->y >> vsub) * frame->linesize[plane];\n    }\n    return frame;\n}", "target": 1}
{"code": "void sk_setup_caps(struct sock *sk, struct dst_entry *dst)\n{\n\t__sk_dst_set(sk, dst);\n\tsk->sk_route_caps = dst->dev->features;\n\tif (sk->sk_route_caps & NETIF_F_GSO)\n\t\tsk->sk_route_caps |= NETIF_F_GSO_SOFTWARE;\n\tsk->sk_route_caps &= ~sk->sk_route_nocaps;\n\tif (sk_can_gso(sk)) {\n\t\tif (dst->header_len) {\n\t\t\tsk->sk_route_caps &= ~NETIF_F_GSO_MASK;\n\t\t} else {\n\t\t\tsk->sk_route_caps |= NETIF_F_SG | NETIF_F_HW_CSUM;\n\t\t\tsk->sk_gso_max_size = dst->dev->gso_max_size;\n\t\t}\n\t}\n}", "target": 0}
{"code": "is_link_trusted (NautilusFile *file,\n                 gboolean      is_launcher)\n{\n    GFile *location;\n    gboolean res;\n    if (!is_launcher)\n    {\n        return TRUE;\n    }\n    if (nautilus_file_can_execute (file))\n    {\n        return TRUE;\n    }\n    res = FALSE;\n    if (nautilus_file_is_local (file))\n    {\n        location = nautilus_file_get_location (file);\n        res = nautilus_is_in_system_dir (location);\n        g_object_unref (location);\n    }\n    return res;\n}", "target": 1}
{"code": "void nhml_get_bs(GF_BitStream **bs, char *data, u32 size, u32 mode)\n{\n\tif (*bs) gf_bs_reassign_buffer(*bs, data, size);\n\telse  (*bs) = gf_bs_new(data, size, mode);", "target": 0}
{"code": " Node::InsertionNotificationRequest HTMLBodyElement::insertedInto(ContainerNode* insertionPoint)\n {\n     HTMLElement::insertedInto(insertionPoint);\n    return InsertionShouldCallDidNotifySubtreeInsertions;\n}\nvoid HTMLBodyElement::didNotifySubtreeInsertionsToDocument()\n{\n    Element* ownerElement = document().ownerElement();\n    if (!isHTMLFrameElementBase(ownerElement))\n        return;\n    HTMLFrameElementBase& ownerFrameElement = toHTMLFrameElementBase(*ownerElement);\n    int marginWidth = ownerFrameElement.marginWidth();\n    int marginHeight = ownerFrameElement.marginHeight();\n    if (marginWidth != -1)\n        setIntegralAttribute(marginwidthAttr, marginWidth);\n    if (marginHeight != -1)\n        setIntegralAttribute(marginheightAttr, marginHeight);\n }", "target": 0}
{"code": "rb_remove_pages(struct ring_buffer_per_cpu *cpu_buffer, unsigned long nr_pages)\n{\n\tstruct list_head *tail_page, *to_remove, *next_page;\n\tstruct buffer_page *to_remove_page, *tmp_iter_page;\n\tstruct buffer_page *last_page, *first_page;\n\tunsigned long nr_removed;\n\tunsigned long head_bit;\n\tint page_entries;\n\thead_bit = 0;\n\traw_spin_lock_irq(&cpu_buffer->reader_lock);\n\tatomic_inc(&cpu_buffer->record_disabled);\n\ttail_page = &cpu_buffer->tail_page->list;\n\tif (cpu_buffer->tail_page == cpu_buffer->reader_page)\n\t\ttail_page = rb_list_head(tail_page->next);\n\tto_remove = tail_page;\n\tfirst_page = list_entry(rb_list_head(to_remove->next),\n\t\t\t\tstruct buffer_page, list);\n\tfor (nr_removed = 0; nr_removed < nr_pages; nr_removed++) {\n\t\tto_remove = rb_list_head(to_remove)->next;\n\t\thead_bit |= (unsigned long)to_remove & RB_PAGE_HEAD;\n\t}\n\tnext_page = rb_list_head(to_remove)->next;\n\ttail_page->next = (struct list_head *)((unsigned long)next_page |\n\t\t\t\t\t\thead_bit);\n\tnext_page = rb_list_head(next_page);\n\tnext_page->prev = tail_page;\n\tcpu_buffer->pages = next_page;\n\tif (head_bit)\n\t\tcpu_buffer->head_page = list_entry(next_page,\n\t\t\t\t\t\tstruct buffer_page, list);\n\tcpu_buffer->read = 0;\n\tatomic_dec(&cpu_buffer->record_disabled);\n\traw_spin_unlock_irq(&cpu_buffer->reader_lock);\n\tRB_WARN_ON(cpu_buffer, list_empty(cpu_buffer->pages));\n\tlast_page = list_entry(rb_list_head(to_remove), struct buffer_page,\n\t\t\t\tlist);\n\ttmp_iter_page = first_page;\n\tdo {\n\t\tto_remove_page = tmp_iter_page;\n\t\trb_inc_page(cpu_buffer, &tmp_iter_page);\n\t\tpage_entries = rb_page_entries(to_remove_page);\n\t\tif (page_entries) {\n\t\t\tlocal_add(page_entries, &cpu_buffer->overrun);\n\t\t\tlocal_sub(BUF_PAGE_SIZE, &cpu_buffer->entries_bytes);\n\t\t}\n\t\tfree_buffer_page(to_remove_page);\n\t\tnr_removed--;\n\t} while (to_remove_page != last_page);\n\tRB_WARN_ON(cpu_buffer, nr_removed);\n\treturn nr_removed == 0;\n}", "target": 0}
{"code": "static int proc_uptime_read(char *buf, size_t size, off_t offset,\n\t\tstruct fuse_file_info *fi)\n{\n\tstruct fuse_context *fc = fuse_get_context();\n\tstruct file_info *d = (struct file_info *)fi->fh;\n\tlong int reaperage = getreaperage(fc->pid);;\n\tunsigned long int busytime = get_reaper_busy(fc->pid), idletime;\n\tchar *cache = d->buf;\n\tsize_t total_len = 0;\n\tif (offset){\n\t\tif (offset > d->size)\n\t\t\treturn -EINVAL;\n\t\tif (!d->cached)\n\t\t\treturn 0;\n\t\tint left = d->size - offset;\n\t\ttotal_len = left > size ? size: left;\n\t\tmemcpy(buf, cache + offset, total_len);\n\t\treturn total_len;\n\t}\n\tidletime = reaperage - busytime;\n\tif (idletime > reaperage)\n\t\tidletime = reaperage;\n\ttotal_len = snprintf(d->buf, d->size, \"%ld.0 %lu.0\\n\", reaperage, idletime);\n\tif (total_len < 0){\n\t\tperror(\"Error writing to cache\");\n\t\treturn 0;\n\t}\n\td->size = (int)total_len;\n\td->cached = 1;\n\tif (total_len > size) total_len = size;\n\tmemcpy(buf, d->buf, total_len);\n\treturn total_len;\n}", "target": 0}
{"code": "static int ext4_dax_pmd_fault(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\t\t\tpmd_t *pmd, unsigned int flags)\n{\n\tint result;\n\thandle_t *handle = NULL;\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tstruct super_block *sb = inode->i_sb;\n\tbool write = flags & FAULT_FLAG_WRITE;\n\tif (write) {\n\t\tsb_start_pagefault(sb);\n\t\tfile_update_time(vma->vm_file);\n\t\thandle = ext4_journal_start_sb(sb, EXT4_HT_WRITE_PAGE,\n\t\t\t\text4_chunk_trans_blocks(inode,\n\t\t\t\t\t\t\tPMD_SIZE / PAGE_SIZE));\n\t}\n\tif (IS_ERR(handle))\n\t\tresult = VM_FAULT_SIGBUS;\n\telse\n\t\tresult = __dax_pmd_fault(vma, addr, pmd, flags,\n\t\t\t\text4_get_block_dax, ext4_end_io_unwritten);\n\tif (write) {\n\t\tif (!IS_ERR(handle))\n\t\t\text4_journal_stop(handle);\n\t\tsb_end_pagefault(sb);\n\t}\n\treturn result;\n}", "target": 1}
{"code": "AP_CORE_DECLARE(void) ap_parse_uri(request_rec *r, const char *uri)\n{\n    int status = HTTP_OK;\n    r->unparsed_uri = apr_pstrdup(r->pool, uri);\n    while ((uri[0] == '/') && (uri[1] == '/')) {\n        ++uri ;\n    }\n    if (r->method_number == M_CONNECT) {\n        status = apr_uri_parse_hostinfo(r->pool, uri, &r->parsed_uri);\n    }\n    else {\n        status = apr_uri_parse(r->pool, uri, &r->parsed_uri);\n    }\n    if (status == APR_SUCCESS) {\n        if (r->parsed_uri.scheme\n            && !strcasecmp(r->parsed_uri.scheme, ap_http_scheme(r))) {\n            r->hostname = r->parsed_uri.hostname;\n        }\n        else if (r->method_number == M_CONNECT) {\n            r->hostname = r->parsed_uri.hostname;\n        }\n        r->args = r->parsed_uri.query;\n        r->uri = r->parsed_uri.path ? r->parsed_uri.path\n                 : apr_pstrdup(r->pool, \"/\");\n#if defined(OS2) || defined(WIN32)\n        {\n            char *x;\n            for (x = r->uri; (x = strchr(x, '\\\\')) != NULL; )\n                *x = '/';\n        }\n#endif \n    }\n    else {\n        r->args = NULL;\n        r->hostname = NULL;\n        r->status = HTTP_BAD_REQUEST;             \n        r->uri = apr_pstrdup(r->pool, uri);\n    }\n}", "target": 0}
{"code": "static void handle_irq_for_port(evtchn_port_t port)\n{\n\tint irq;\n\tirq = get_evtchn_to_irq(port);\n\tif (irq != -1)\n\t\tgeneric_handle_irq(irq);\n}", "target": 1}
{"code": "static void send(node_t *node, node_t *child, byte *fout) {\n\tif (node->parent) {\n\t\tsend(node->parent, node, fout);\n\t}\n\tif (child) {\n\t\tif (node->right == child) {\n\t\t\tadd_bit(1, fout);\n\t\t} else {\n\t\t\tadd_bit(0, fout);\n\t\t}\n\t}\n}", "target": 1}
{"code": "rdp_enum_bmpcache2(void)\n{\n\tSTREAM s;\n\tHASH_KEY keylist[BMPCACHE2_NUM_PSTCELLS];\n\tuint32 num_keys, offset, count, flags;\n\toffset = 0;\n\tnum_keys = pstcache_enumerate(2, keylist);\n\twhile (offset < num_keys)\n\t{\n\t\tcount = MIN(num_keys - offset, 169);\n\t\ts = rdp_init_data(24 + count * sizeof(HASH_KEY));\n\t\tflags = 0;\n\t\tif (offset == 0)\n\t\t\tflags |= PDU_FLAG_FIRST;\n\t\tif (num_keys - offset <= 169)\n\t\t\tflags |= PDU_FLAG_LAST;\n\t\tout_uint32_le(s, 0);\n\t\tout_uint16_le(s, count);\n\t\tout_uint16_le(s, 0);\n\t\tout_uint16_le(s, 0);\n\t\tout_uint16_le(s, 0);\n\t\tout_uint16_le(s, 0);\n\t\tout_uint16_le(s, num_keys);\n\t\tout_uint32_le(s, 0);\n\t\tout_uint32_le(s, flags);\n\t\tout_uint8a(s, keylist[offset], count * sizeof(HASH_KEY));\n\t\ts_mark_end(s);\n\t\trdp_send_data(s, 0x2b);\n\t\toffset += 169;\n\t}\n}", "target": 0}
{"code": "static int cens_scheme_decrypt(MOVContext *c, MOVStreamContext *sc, AVEncryptionInfo *sample, uint8_t *input, int size)\n{\n    int i, ret, rem_bytes;\n    uint8_t *data;\n    if (!sc->cenc.aes_ctr) {\n        sc->cenc.aes_ctr = av_aes_ctr_alloc();\n        if (!sc->cenc.aes_ctr) {\n            return AVERROR(ENOMEM);\n        }\n        ret = av_aes_ctr_init(sc->cenc.aes_ctr, c->decryption_key);\n        if (ret < 0) {\n            return ret;\n        }\n    }\n    av_aes_ctr_set_full_iv(sc->cenc.aes_ctr, sample->iv);\n    if (!sample->subsample_count) {\n        av_aes_ctr_crypt(sc->cenc.aes_ctr, input, input, size);\n        return 0;\n    } else if (!sample->crypt_byte_block && !sample->skip_byte_block) {\n        av_log(c->fc, AV_LOG_ERROR, \"pattern encryption is not present in 'cens' scheme\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    for (i = 0; i < sample->subsample_count; i++) {\n        if (sample->subsamples[i].bytes_of_clear_data + sample->subsamples[i].bytes_of_protected_data > size) {\n            av_log(c->fc, AV_LOG_ERROR, \"subsample size exceeds the packet size left\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        input += sample->subsamples[i].bytes_of_clear_data;\n        size -= sample->subsamples[i].bytes_of_clear_data;\n        data = input;\n        rem_bytes = sample->subsamples[i].bytes_of_protected_data;\n        while (rem_bytes > 0) {\n            if (rem_bytes < 16*sample->crypt_byte_block) {\n                break;\n            }\n            av_aes_ctr_crypt(sc->cenc.aes_ctr, data, data, 16*sample->crypt_byte_block);\n            data += 16*sample->crypt_byte_block;\n            rem_bytes -= 16*sample->crypt_byte_block;\n            data += FFMIN(16*sample->skip_byte_block, rem_bytes);\n            rem_bytes -= FFMIN(16*sample->skip_byte_block, rem_bytes);\n        }\n        input += sample->subsamples[i].bytes_of_protected_data;\n        size -= sample->subsamples[i].bytes_of_protected_data;\n    }\n    if (size > 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"leftover packet bytes after subsample processing\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    return 0;\n}", "target": 0}
{"code": "static int find_high_bit(unsigned int x)\n{\n\tint i;\n\tfor(i=31;i>=0;i--) {\n\t\tif(x&(1<<i)) return i;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "    void Jp2Image::writeMetadata()\n    {\n        if (io_->open() != 0)\n        {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        BasicIo::UniquePtr tempIo(new MemIo);\n        assert (tempIo.get() != 0);\n        doWriteMetadata(*tempIo); \n        io_->close();\n        io_->transfer(*tempIo); \n    } ", "target": 0}
{"code": "static inline unsigned char unimap_bsearch(const uni_to_enc *table, unsigned code_key_a, size_t num)\n{\n\tconst uni_to_enc *l = table,\n\t\t\t\t\t *h = &table[num-1],\n\t\t\t\t\t *m;\n\tunsigned short code_key;\n\tif (code_key_a > 0xFFFFU)\n\t\treturn 0;\n\tcode_key = (unsigned short) code_key_a;\n\twhile (l <= h) {\n\t\tm = l + (h - l) / 2;\n\t\tif (code_key < m->un_code_point)\n\t\t\th = m - 1;\n\t\telse if (code_key > m->un_code_point)\n\t\t\tl = m + 1;\n\t\telse\n\t\t\treturn m->cs_code;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int override_release(char __user *release, int len)\n{\n\tint ret = 0;\n\tchar buf[65];\n\tif (current->personality & UNAME26) {\n\t\tchar *rest = UTS_RELEASE;\n\t\tint ndots = 0;\n\t\tunsigned v;\n\t\twhile (*rest) {\n\t\t\tif (*rest == '.' && ++ndots >= 3)\n\t\t\t\tbreak;\n\t\t\tif (!isdigit(*rest) && *rest != '.')\n\t\t\t\tbreak;\n\t\t\trest++;\n\t\t}\n\t\tv = ((LINUX_VERSION_CODE >> 8) & 0xff) + 40;\n\t\tsnprintf(buf, len, \"2.6.%u%s\", v, rest);\n\t\tret = copy_to_user(release, buf, len);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "  static const char* ConvertScalar(PyObject* v, Eigen::half* out) {\n    Safe_PyObjectPtr as_float = make_safe(PyNumber_Float(v));\n    double v_double = PyFloat_AS_DOUBLE(as_float.get());\n    *out = Eigen::half(v_double);\n    return nullptr;\n  }", "target": 1}
{"code": "do_encrypt (const RIJNDAEL_context *ctx,\n            unsigned char *bx, const unsigned char *ax)\n{\n#ifdef USE_AMD64_ASM\n  return _gcry_aes_amd64_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds,\n\t\t\t\t       encT);\n#elif defined(USE_ARM_ASM)\n  return _gcry_aes_arm_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds, encT);\n#else\n  return do_encrypt_fn (ctx, bx, ax);\n#endif \n}", "target": 1}
{"code": "static void ssl_write_renegotiation_ext( mbedtls_ssl_context *ssl,\n                                         unsigned char *buf,\n                                         size_t *olen )\n{\n    unsigned char *p = buf;\n    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;\n    *olen = 0;\n    if( ssl->renego_status != MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )\n        return;\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, adding renegotiation extension\" ) );\n    if( end < p || (size_t)( end - p ) < 5 + ssl->verify_data_len )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n        return;\n    }\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_RENEGOTIATION_INFO >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_RENEGOTIATION_INFO      ) & 0xFF );\n    *p++ = 0x00;\n    *p++ = ( ssl->verify_data_len + 1 ) & 0xFF;\n    *p++ = ssl->verify_data_len & 0xFF;\n    memcpy( p, ssl->own_verify_data, ssl->verify_data_len );\n    *olen = 5 + ssl->verify_data_len;\n}", "target": 0}
{"code": "static inline pmd_t pmd_read_atomic(pmd_t *pmdp)\n{\n\treturn *pmdp;\n}", "target": 0}
{"code": "static void iov_fault_in_pages_read(struct iovec *iov, unsigned long len)\n{\n\twhile (!iov->iov_len)\n\t\tiov++;\n\twhile (len > 0) {\n\t\tunsigned long this_len;\n\t\tthis_len = min_t(unsigned long, len, iov->iov_len);\n\t\tfault_in_pages_readable(iov->iov_base, this_len);\n\t\tlen -= this_len;\n\t\tiov++;\n\t}\n}", "target": 1}
{"code": "void TableLookUp::setTable(int ntable, const std::vector<ushort16>& table) {\n  assert(!table.empty());\n  const int nfilled = table.size();\n  if (ntable > ntables) {\n    ThrowRDE(\"Table lookup with number greater than number of tables.\");\n  }\n  ushort16* t = &tables[ntable * TABLE_SIZE];\n  if (!dither) {\n    for (int i = 0; i < 65536; i++) {\n      t[i] = (i < nfilled) ? table[i] : table[nfilled - 1];\n    }\n    return;\n  }\n  for (int i = 0; i < nfilled; i++) {\n    int center = table[i];\n    int lower = i > 0 ? table[i - 1] : center;\n    int upper = i < (nfilled - 1) ? table[i + 1] : center;\n    int delta = upper - lower;\n    t[i * 2] = center - ((upper - lower + 2) / 4);\n    t[i * 2 + 1] = delta;\n  }\n  for (int i = nfilled; i < 65536; i++) {\n    t[i * 2] = table[nfilled - 1];\n    t[i * 2 + 1] = 0;\n  }\n  t[0] = t[1];\n  t[TABLE_SIZE - 1] = t[TABLE_SIZE - 2];\n}", "target": 1}
{"code": "static inline unsigned int unix_hash_fold(__wsum n)\n{\n\tunsigned int hash = (__force unsigned int)csum_fold(n);\n\thash ^= hash>>8;\n\treturn hash&(UNIX_HASH_SIZE-1);\n}", "target": 0}
{"code": "fill_yin_revision(struct lys_module *module, struct lyxml_elem *yin, struct lys_revision *rev,\n                  struct unres_schema *unres)\n{\n    struct ly_ctx *ctx = module->ctx;\n    struct lyxml_elem *next, *child;\n    const char *value;\n    GETVAL(ctx, value, yin, \"date\");\n    if (lyp_check_date(ctx, value)) {\n        goto error;\n    }\n    memcpy(rev->date, value, LY_REV_SIZE - 1);\n    LY_TREE_FOR_SAFE(yin->child, next, child) {\n        if (!child->ns) {\n            continue;\n        } else if (strcmp(child->ns->value, LY_NSYIN)) {\n            if (lyp_yin_parse_subnode_ext(module, rev, LYEXT_PAR_REVISION,\n                                          child, LYEXT_SUBSTMT_SELF, 0, unres)) {\n                goto error;\n            }\n        } else if (!strcmp(child->name, \"description\")) {\n            if (rev->dsc) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, child->name, yin->name);\n                goto error;\n            }\n            if (lyp_yin_parse_subnode_ext(module, rev, LYEXT_PAR_REVISION,\n                                          child, LYEXT_SUBSTMT_DESCRIPTION, 0, unres)) {\n                goto error;\n            }\n            rev->dsc = read_yin_subnode(ctx, child, \"text\");\n            if (!rev->dsc) {\n                goto error;\n            }\n        } else if (!strcmp(child->name, \"reference\")) {\n            if (rev->ref) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, child->name, yin->name);\n                goto error;\n            }\n            if (lyp_yin_parse_subnode_ext(module, rev, LYEXT_PAR_REVISION,\n                                          child, LYEXT_SUBSTMT_REFERENCE, 0, unres)) {\n                goto error;\n            }\n            rev->ref = read_yin_subnode(ctx, child, \"text\");\n            if (!rev->ref) {\n                goto error;\n            }\n        } else {\n            LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, child->name);\n            goto error;\n        }\n    }\n    return EXIT_SUCCESS;\nerror:\n    return EXIT_FAILURE;\n}", "target": 0}
{"code": "check_packet_auth(NTP_Packet *pkt, int length, int *has_auth, uint32_t *key_id)\n{\n  int i, remainder, ext_length;\n  unsigned char *data;\n  uint32_t id;\n  i = NTP_NORMAL_PACKET_LENGTH;\n  data = (void *)pkt;\n  while (1) {\n    remainder = length - i;\n    if (remainder >= NTP_MIN_MAC_LENGTH && remainder <= NTP_MAX_MAC_LENGTH) {\n      id = ntohl(*(uint32_t *)(data + i));\n      if (KEY_CheckAuth(id, (void *)pkt, i, (void *)(data + i + 4),\n                        remainder - 4)) {\n        if (key_id)\n          *key_id = id;\n        if (has_auth)\n          *has_auth = 1;\n        return 1;\n      }\n    }\n    if (remainder >= NTP_MIN_EXTENSION_LENGTH) {\n      ext_length = ntohs(*(uint16_t *)(data + i + 2));\n      if (ext_length >= NTP_MIN_EXTENSION_LENGTH &&\n          ext_length <= remainder && ext_length % 4 == 0) {\n        i += ext_length;\n        continue;\n      }\n    }\n    break;\n  }\n  if (has_auth)\n    *has_auth = remainder >= NTP_MIN_MAC_LENGTH;\n  return 0;\n}", "target": 0}
{"code": "static void check_serverpath(request_rec *r)\n{\n    server_rec *s;\n    server_rec *last_s;\n    name_chain *src;\n    apr_port_t port;\n    port = r->connection->local_addr->port;\n    last_s = NULL;\n    for (src = r->connection->vhost_lookup_data; src; src = src->next) {\n        if (src->sar->host_port != 0 && port != src->sar->host_port) {\n            continue;\n        }\n        s = src->server;\n        if (s == last_s) {\n            continue;\n        }\n        last_s = s;\n        if (s->path && !strncmp(r->uri, s->path, s->pathlen) &&\n            (s->path[s->pathlen - 1] == '/' ||\n             r->uri[s->pathlen] == '/' ||\n             r->uri[s->pathlen] == '\\0')) {\n            r->server = s;\n            return;\n        }\n    }\n}", "target": 1}
{"code": "onig_new_deluxe(regex_t** reg, const UChar* pattern, const UChar* pattern_end,\n                OnigCompileInfo* ci, OnigErrorInfo* einfo)\n{\n  int r;\n  UChar *cpat, *cpat_end;\n  if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;\n  if (ci->pattern_enc != ci->target_enc) {\n    r = conv_encoding(ci->pattern_enc, ci->target_enc, pattern, pattern_end,\n                      &cpat, &cpat_end);\n    if (r != 0) return r;\n  }\n  else {\n    cpat     = (UChar* )pattern;\n    cpat_end = (UChar* )pattern_end;\n  }\n  *reg = (regex_t* )xmalloc(sizeof(regex_t));\n  if (IS_NULL(*reg)) {\n    r = ONIGERR_MEMORY;\n    goto err2;\n  }\n  r = onig_reg_init(*reg, ci->option, ci->case_fold_flag, ci->target_enc,\n                    ci->syntax);\n  if (r != 0) goto err;\n  r = onig_compile(*reg, cpat, cpat_end, einfo);\n  if (r != 0) {\n  err:\n    onig_free(*reg);\n    *reg = NULL;\n  }\n err2:\n  if (cpat != pattern) xfree(cpat);\n  return r;\n}", "target": 1}
{"code": "void PacketReader::getDnsrecordheader(struct dnsrecordheader &ah)\n{\n  unsigned int n;\n  unsigned char *p=reinterpret_cast<unsigned char*>(&ah);\n  for(n=0; n < sizeof(dnsrecordheader); ++n) \n    p[n]=d_content.at(d_pos++);\n  ah.d_type=ntohs(ah.d_type);\n  ah.d_class=ntohs(ah.d_class);\n  ah.d_clen=ntohs(ah.d_clen);\n  ah.d_ttl=ntohl(ah.d_ttl);\n  d_startrecordpos=d_pos; \n  d_recordlen=ah.d_clen;\n}", "target": 0}
{"code": "static void vgacon_flush_scrollback(struct vc_data *c)\n{\n\tsize_t size = CONFIG_VGACON_SOFT_SCROLLBACK_SIZE * 1024;\n\tvgacon_scrollback_reset(c->vc_num, size);\n}", "target": 1}
{"code": "sysName_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  snmp_api_set_string(varbind, oid, \"Contiki-NG - \"CONTIKI_TARGET_STRING);\n}", "target": 1}
{"code": "const char *who_am_i(void)\n{\n\tif (am_starting_up)\n\t\treturn am_server ? \"server\" : \"client\";\n\treturn am_sender ? \"sender\"\n\t     : am_generator ? \"generator\"\n\t     : am_receiver ? \"receiver\"\n\t     : \"Receiver\"; \n}", "target": 0}
{"code": "get_head_value_node(Node* node, int exact, regex_t* reg)\n{\n  Node* n = NULL_NODE;\n  switch (NTYPE(node)) {\n  case NT_BREF:\n  case NT_ALT:\n  case NT_CANY:\n#ifdef USE_SUBEXP_CALL\n  case NT_CALL:\n#endif\n    break;\n  case NT_CTYPE:\n  case NT_CCLASS:\n    if (exact == 0) {\n      n = node;\n    }\n    break;\n  case NT_LIST:\n    n = get_head_value_node(NCAR(node), exact, reg);\n    break;\n  case NT_STR:\n    {\n      StrNode* sn = NSTR(node);\n      if (sn->end <= sn->s)\n\tbreak;\n      if (exact != 0 &&\n\t  !NSTRING_IS_RAW(node) && IS_IGNORECASE(reg->options)) {\n      }\n      else {\n\tn = node;\n      }\n    }\n    break;\n  case NT_QTFR:\n    {\n      QtfrNode* qn = NQTFR(node);\n      if (qn->lower > 0) {\n#ifdef USE_OP_PUSH_OR_JUMP_EXACT\n\tif (IS_NOT_NULL(qn->head_exact))\n\t  n = qn->head_exact;\n\telse\n#endif\n\t  n = get_head_value_node(qn->target, exact, reg);\n      }\n    }\n    break;\n  case NT_ENCLOSE:\n    {\n      EncloseNode* en = NENCLOSE(node);\n      switch (en->type) {\n      case ENCLOSE_OPTION:\n\t{\n\t  OnigOptionType options = reg->options;\n\t  reg->options = NENCLOSE(node)->option;\n\t  n = get_head_value_node(NENCLOSE(node)->target, exact, reg);\n\t  reg->options = options;\n\t}\n\tbreak;\n      case ENCLOSE_MEMORY:\n      case ENCLOSE_STOP_BACKTRACK:\n      case ENCLOSE_CONDITION:\n\tn = get_head_value_node(en->target, exact, reg);\n\tbreak;\n      }\n    }\n    break;\n  case NT_ANCHOR:\n    if (NANCHOR(node)->type == ANCHOR_PREC_READ)\n      n = get_head_value_node(NANCHOR(node)->target, exact, reg);\n    break;\n  default:\n    break;\n  }\n  return n;\n}", "target": 0}
{"code": "char *path_name(struct strbuf *path, const char *name)\n{\n\tstruct strbuf ret = STRBUF_INIT;\n\tif (path)\n\t\tstrbuf_addbuf(&ret, path);\n\tstrbuf_addstr(&ret, name);\n\treturn strbuf_detach(&ret, NULL);\n}", "target": 1}
{"code": "int http_remove_header2(struct http_msg *msg, struct buffer *buf,\n\t\t\tstruct hdr_idx *idx, struct hdr_ctx *ctx)\n{\n\tint cur_idx = ctx->idx;\n\tchar *sol = ctx->line;\n\tstruct hdr_idx_elem *hdr;\n\tint delta, skip_comma;\n\tif (!cur_idx)\n\t\treturn 0;\n\thdr = &idx->v[cur_idx];\n\tif (sol[ctx->del] == ':' && ctx->val + ctx->vlen + ctx->tws == hdr->len) {\n\t\tdelta = buffer_replace2(buf, sol, sol + hdr->len + hdr->cr + 1, NULL, 0);\n\t\thttp_msg_move_end(msg, delta);\n\t\tidx->used--;\n\t\thdr->len = 0;   \n\t\tidx->v[ctx->prev].next = idx->v[ctx->idx].next;\n\t\tif (idx->tail == ctx->idx)\n\t\t\tidx->tail = ctx->prev;\n\t\tctx->idx = ctx->prev;    \n\t\tctx->line -= idx->v[ctx->idx].len + idx->v[cur_idx].cr + 1;\n\t\tctx->val = idx->v[ctx->idx].len; \n\t\tctx->tws = ctx->vlen = 0;\n\t\treturn ctx->idx;\n\t}\n\tskip_comma = (ctx->val + ctx->vlen + ctx->tws == hdr->len) ? 0 : 1;\n\tdelta = buffer_replace2(buf, sol + ctx->del + skip_comma,\n\t\t\t\tsol + ctx->val + ctx->vlen + ctx->tws + skip_comma,\n\t\t\t\tNULL, 0);\n\thdr->len += delta;\n\thttp_msg_move_end(msg, delta);\n\tctx->val = ctx->del;\n\tctx->tws = ctx->vlen = 0;\n\treturn ctx->idx;\n}", "target": 0}
{"code": "pch_normalize (enum diff format)\n{\n  lin old = 1;\n  lin new = p_ptrn_lines + 1;\n  while (p_Char[new] == '=' || p_Char[new] == '\\n')\n    new++;\n  if (format == UNI_DIFF)\n    {\n      for (; old <= p_ptrn_lines; old++)\n\tif (p_Char[old] == '!')\n\t  p_Char[old] = '-';\n      for (; new <= p_end; new++)\n\tif (p_Char[new] == '!')\n\t  p_Char[new] = '+';\n    }\n  else\n    {\n      while (old <= p_ptrn_lines)\n\t{\n\t  if (p_Char[old] == '-')\n\t    {\n\t      if (new <= p_end && p_Char[new] == '+')\n\t\t{\n\t\t  do\n\t\t    {\n\t\t      p_Char[old] = '!';\n\t\t      old++;\n\t\t    }\n\t\t  while (old <= p_ptrn_lines && p_Char[old] == '-');\n\t\t  do\n\t\t    {\n\t\t      p_Char[new] = '!';\n\t\t      new++;\n\t\t    }\n\t\t  while (new <= p_end && p_Char[new] == '+');\n\t\t}\n\t      else\n\t\t{\n\t\t  do\n\t\t    old++;\n\t\t  while (old <= p_ptrn_lines && p_Char[old] == '-');\n\t\t}\n\t    }\n\t  else if (new <= p_end && p_Char[new] == '+')\n\t    {\n\t      do\n\t\tnew++;\n\t      while (new <= p_end && p_Char[new] == '+');\n\t    }\n\t  else\n\t    {\n\t      old++;\n\t      new++;\n\t    }\n\t}\n    }\n}", "target": 0}
{"code": "static int cdrom_ioctl_select_disc(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_SELECT_DISC\\n\");\n\tif (!CDROM_CAN(CDC_SELECT_DISC))\n\t\treturn -ENOSYS;\n\tif (arg != CDSL_CURRENT && arg != CDSL_NONE) {\n\t\tif ((int)arg >= cdi->capacity)\n\t\t\treturn -EINVAL;\n\t}\n\tif (cdi->ops->select_disc)\n\t\treturn cdi->ops->select_disc(cdi, arg);\n\tcd_dbg(CD_CHANGER, \"Using generic cdrom_select_disc()\\n\");\n\treturn cdrom_select_disc(cdi, arg);\n}", "target": 1}
{"code": "op_format(\n    oparg_T\t*oap,\n    int\t\tkeep_cursor)\t\t\n{\n    long\told_line_count = curbuf->b_ml.ml_line_count;\n    curwin->w_cursor = oap->cursor_start;\n    if (u_save((linenr_T)(oap->start.lnum - 1),\n\t\t\t\t       (linenr_T)(oap->end.lnum + 1)) == FAIL)\n\treturn;\n    curwin->w_cursor = oap->start;\n    if (oap->is_VIsual)\n\tredraw_curbuf_later(INVERTED);\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\tcurbuf->b_op_start = oap->start;\n    if (keep_cursor)\n\tsaved_cursor = oap->cursor_start;\n    format_lines(oap->line_count, keep_cursor);\n    if (oap->end_adjusted && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t++curwin->w_cursor.lnum;\n    beginline(BL_WHITE | BL_FIX);\n    old_line_count = curbuf->b_ml.ml_line_count - old_line_count;\n    msgmore(old_line_count);\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\tcurbuf->b_op_end = curwin->w_cursor;\n    if (keep_cursor)\n    {\n\tcurwin->w_cursor = saved_cursor;\n\tsaved_cursor.lnum = 0;\n    }\n    if (oap->is_VIsual)\n    {\n\twin_T\t*wp;\n\tFOR_ALL_WINDOWS(wp)\n\t{\n\t    if (wp->w_old_cursor_lnum != 0)\n\t    {\n\t\tif (wp->w_old_cursor_lnum > wp->w_old_visual_lnum)\n\t\t    wp->w_old_cursor_lnum += old_line_count;\n\t\telse\n\t\t    wp->w_old_visual_lnum += old_line_count;\n\t    }\n\t}\n    }\n}", "target": 1}
{"code": "static int xfrm_dump_policy(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];\n\tstruct xfrm_dump_info info;\n\tBUILD_BUG_ON(sizeof(struct xfrm_policy_walk) >\n\t\t     sizeof(cb->args) - sizeof(cb->args[0]));\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\tif (!cb->args[0]) {\n\t\tcb->args[0] = 1;\n\t\txfrm_policy_walk_init(walk, XFRM_POLICY_TYPE_ANY);\n\t}\n\t(void) xfrm_policy_walk(net, walk, dump_one_policy, &info);\n\treturn skb->len;\n}", "target": 1}
{"code": "mark_context_stack(mrb_state *mrb, struct mrb_context *c)\n{\n  size_t i;\n  size_t e;\n  if (c->stack == NULL) return;\n  e = c->stack - c->stbase;\n  if (c->ci) e += c->ci->nregs;\n  if (c->stbase + e > c->stend) e = c->stend - c->stbase;\n  for (i=0; i<e; i++) {\n    mrb_value v = c->stbase[i];\n    if (!mrb_immediate_p(v)) {\n      if (mrb_basic_ptr(v)->tt == MRB_TT_FREE) {\n        c->stbase[i] = mrb_nil_value();\n      }\n      else {\n        mrb_gc_mark(mrb, mrb_basic_ptr(v));\n      }\n    }\n  }\n}", "target": 1}
{"code": "void sc_pkcs15emu_sc_hsm_free_cvc(sc_cvc_t *cvc)\n{\n\tif (cvc->signature) {\n\t\tfree(cvc->signature);\n\t\tcvc->signature = NULL;\n\t}\n\tif (cvc->primeOrModulus) {\n\t\tfree(cvc->primeOrModulus);\n\t\tcvc->primeOrModulus = NULL;\n\t}\n\tif (cvc->coefficientAorExponent) {\n\t\tfree(cvc->coefficientAorExponent);\n\t\tcvc->coefficientAorExponent = NULL;\n\t}\n\tif (cvc->coefficientB) {\n\t\tfree(cvc->coefficientB);\n\t\tcvc->coefficientB = NULL;\n\t}\n\tif (cvc->basePointG) {\n\t\tfree(cvc->basePointG);\n\t\tcvc->basePointG = NULL;\n\t}\n\tif (cvc->order) {\n\t\tfree(cvc->order);\n\t\tcvc->order = NULL;\n\t}\n\tif (cvc->publicPoint) {\n\t\tfree(cvc->publicPoint);\n\t\tcvc->publicPoint = NULL;\n\t}\n\tif (cvc->cofactor) {\n\t\tfree(cvc->cofactor);\n\t\tcvc->cofactor = NULL;\n\t}\n}", "target": 0}
{"code": "static int ogm_chapter(AVFormatContext *as, uint8_t *key, uint8_t *val)\n{\n    int i, cnum, h, m, s, ms, keylen = strlen(key);\n    AVChapter *chapter = NULL;\n    if (keylen < 9 || sscanf(key, \"CHAPTER%03d\", &cnum) != 1)\n        return 0;\n    if (keylen <= 10) {\n        if (sscanf(val, \"%02d:%02d:%02d.%03d\", &h, &m, &s, &ms) < 4)\n            return 0;\n        avpriv_new_chapter(as, cnum, (AVRational) { 1, 1000 },\n                           ms + 1000 * (s + 60 * (m + 60 * h)),\n                           AV_NOPTS_VALUE, NULL);\n        av_free(val);\n    } else if (!strcmp(key + keylen - 4, \"NAME\")) {\n        for (i = 0; i < as->nb_chapters; i++)\n            if (as->chapters[i]->id == cnum) {\n                chapter = as->chapters[i];\n                break;\n            }\n        if (!chapter)\n            return 0;\n        av_dict_set(&chapter->metadata, \"title\", val, AV_DICT_DONT_STRDUP_VAL);\n    } else\n        return 0;\n    av_free(key);\n    return 1;\n}", "target": 0}
{"code": "static void ndpi_reset_packet_line_info(struct ndpi_packet_struct *packet) {\n  packet->parsed_lines = 0, packet->empty_line_position_set = 0, packet->host_line.ptr = NULL,\n    packet->host_line.len = 0, packet->referer_line.ptr = NULL, packet->referer_line.len = 0,\n    packet->content_line.ptr = NULL, packet->content_line.len = 0, packet->accept_line.ptr = NULL,\n    packet->accept_line.len = 0, packet->user_agent_line.ptr = NULL, packet->user_agent_line.len = 0,\n    packet->http_url_name.ptr = NULL, packet->http_url_name.len = 0, packet->http_encoding.ptr = NULL,\n    packet->http_encoding.len = 0, packet->http_transfer_encoding.ptr = NULL, packet->http_transfer_encoding.len = 0,\n    packet->http_contentlen.ptr = NULL, packet->http_contentlen.len = 0, packet->http_cookie.ptr = NULL,\n    packet->http_cookie.len = 0, packet->http_origin.len = 0, packet->http_origin.ptr = NULL,\n    packet->http_x_session_type.ptr = NULL, packet->http_x_session_type.len = 0, packet->server_line.ptr = NULL,\n    packet->server_line.len = 0, packet->http_method.ptr = NULL, packet->http_method.len = 0,\n    packet->http_response.ptr = NULL, packet->http_response.len = 0, packet->http_num_headers = 0;\n}", "target": 1}
{"code": "swallow_until_crlf(int fd, uschar *base, int already, int capacity)\n{\nuschar *to = base + already;\nuschar *cr;\nint have = 0;\nint ret;\nint last = 0;\ncr = memchr(base, '\\r', already);\nif (cr != NULL)\n  {\n  if ((cr - base) < already - 1)\n    {\n    return 0;\n    }\n  last = 1;\n  }\nwhile (capacity > 0)\n  {\n  do { ret = recv(fd, to, 1, 0); } while (ret == -1 && errno == EINTR);\n  if (ret == -1)\n    return -1;\n  have++;\n  if (last)\n    return have;\n  if (*to == '\\r')\n    last = 1;\n  capacity--;\n  to++;\n  }\nerrno = EOVERFLOW;\nreturn -1;\n}", "target": 0}
{"code": "DECLAREcpFunc(cpDecodedStrips)\n{\n\ttsize_t stripsize  = TIFFStripSize(in);\n\ttdata_t buf = _TIFFmalloc(stripsize);\n\t(void) imagewidth; (void) spp;\n\tif (buf) {\n\t\ttstrip_t s, ns = TIFFNumberOfStrips(in);\n\t\tuint32 row = 0;\n\t\t_TIFFmemset(buf, 0, stripsize);\n\t\tfor (s = 0; s < ns; s++) {\n\t\t\ttsize_t cc = (row + rowsperstrip > imagelength) ?\n\t\t\t    TIFFVStripSize(in, imagelength - row) : stripsize;\n\t\t\tif (TIFFReadEncodedStrip(in, s, buf, cc) < 0\n\t\t\t    && !ignore) {\n\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t    \"Error, can't read strip %lu\",\n\t\t\t\t    (unsigned long) s);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFWriteEncodedStrip(out, s, buf, cc) < 0) {\n\t\t\t\tTIFFError(TIFFFileName(out),\n\t\t\t\t    \"Error, can't write strip %lu\",\n\t\t\t\t    (unsigned long) s);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\trow += rowsperstrip;\n\t\t}\n\t\t_TIFFfree(buf);\n\t\treturn 1;\n\t} else {\n\t\tTIFFError(TIFFFileName(in),\n\t\t    \"Error, can't allocate memory buffer of size %lu \"\n\t\t    \"to read strips\", (unsigned long) stripsize);\n\t\treturn 0;\n\t}\nbad:\n\t_TIFFfree(buf);\n\treturn 0;\n}", "target": 1}
{"code": "static void check_preempt_wakeup(struct rq *rq, struct task_struct *p)\n{\n\tstruct task_struct *curr = rq->curr;\n\tstruct cfs_rq *cfs_rq = task_cfs_rq(curr);\n\tstruct sched_entity *se = &curr->se, *pse = &p->se;\n\tunsigned long gran;\n\tif (unlikely(rt_prio(p->prio))) {\n\t\tupdate_rq_clock(rq);\n\t\tupdate_curr(cfs_rq);\n\t\tresched_task(curr);\n\t\treturn;\n\t}\n\tcfs_rq_of(pse)->next = pse;\n\tif (unlikely(p->policy == SCHED_BATCH))\n\t\treturn;\n\tif (!sched_feat(WAKEUP_PREEMPT))\n\t\treturn;\n\twhile (!is_same_group(se, pse)) {\n\t\tse = parent_entity(se);\n\t\tpse = parent_entity(pse);\n\t}\n\tgran = sysctl_sched_wakeup_granularity;\n\tif (unlikely(se->load.weight > NICE_0_LOAD))\n\t\tgran = calc_delta_fair(gran, &se->load);\n\tif (pse->vruntime + gran < se->vruntime)\n\t\tresched_task(curr);\n}", "target": 0}
{"code": "hyphenHashInsert (HyphenHashTab * hashTab, const CharsString * key, int val)\n{\n  int i, j;\n  HyphenHashEntry *e;\n  i = hyphenStringHash (key) % HYPHENHASHSIZE;\n  if (!(e = malloc (sizeof (HyphenHashEntry))))\n    outOfMemory ();\n  e->next = hashTab->entries[i];\n  e->key = malloc ((key->length + 1) * CHARSIZE);\n  if (!e->key)\n    outOfMemory ();\n  e->key->length = key->length;\n  for (j = 0; j < key->length; j++)\n    e->key->chars[j] = key->chars[j];\n  e->val = val;\n  hashTab->entries[i] = e;\n}", "target": 0}
{"code": "static int elf_dump_thread_status(long signr, struct elf_thread_status *t)\n{\n\tint sz = 0;\n\tstruct task_struct *p = t->thread;\n\tt->num_notes = 0;\n\tfill_prstatus(&t->prstatus, p, signr);\n\telf_core_copy_task_regs(p, &t->prstatus.pr_reg);\t\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS, sizeof(t->prstatus),\n\t\t  &(t->prstatus));\n\tt->num_notes++;\n\tsz += notesize(&t->notes[0]);\n\tif ((t->prstatus.pr_fpvalid = elf_core_copy_task_fpregs(p, NULL,\n\t\t\t\t\t\t\t\t&t->fpu))) {\n\t\tfill_note(&t->notes[1], \"CORE\", NT_PRFPREG, sizeof(t->fpu),\n\t\t\t  &(t->fpu));\n\t\tt->num_notes++;\n\t\tsz += notesize(&t->notes[1]);\n\t}\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(p, &t->xfpu)) {\n\t\tfill_note(&t->notes[2], \"LINUX\", NT_PRXFPREG, sizeof(t->xfpu),\n\t\t\t  &t->xfpu);\n\t\tt->num_notes++;\n\t\tsz += notesize(&t->notes[2]);\n\t}\n#endif\t\n\treturn sz;\n}", "target": 0}
{"code": "static int vm_stat_get_per_vm(void *data, u64 *val)\n{\n\tstruct kvm_stat_data *stat_data = (struct kvm_stat_data *)data;\n\t*val = *(ulong *)((void *)stat_data->kvm + stat_data->offset);\n\treturn 0;\n}", "target": 0}
{"code": "static void check_hostalias(request_rec *r)\n{\n    const char *host = r->hostname;\n    apr_port_t port;\n    server_rec *s;\n    server_rec *virthost_s;\n    server_rec *last_s;\n    name_chain *src;\n    virthost_s = NULL;\n    last_s = NULL;\n    port = r->connection->local_addr->port;\n    for (src = r->connection->vhost_lookup_data; src; src = src->next) {\n        server_addr_rec *sar;\n        sar = src->sar;\n        if (sar->host_port != 0 && port != sar->host_port) {\n            continue;\n        }\n        s = src->server;\n        if (s != last_s) {\n            if (matches_aliases(s, host)) {\n                goto found;\n            }\n        }\n        if (!strcasecmp(host, sar->virthost)) {\n            if (virthost_s == NULL) {\n                virthost_s = s;\n            }\n        }\n        last_s = s;\n    }\n    if (virthost_s) {\n        s = virthost_s;\n        goto found;\n    }\n    return;\nfound:\n    r->server = s;\n}", "target": 1}
{"code": "rb_remove_pages(struct ring_buffer_per_cpu *cpu_buffer, unsigned long nr_pages)\n{\n\tstruct list_head *tail_page, *to_remove, *next_page;\n\tstruct buffer_page *to_remove_page, *tmp_iter_page;\n\tstruct buffer_page *last_page, *first_page;\n\tunsigned long nr_removed;\n\tunsigned long head_bit;\n\tint page_entries;\n\thead_bit = 0;\n\traw_spin_lock_irq(&cpu_buffer->reader_lock);\n\tatomic_inc(&cpu_buffer->record_disabled);\n\ttail_page = &cpu_buffer->tail_page->list;\n\tif (cpu_buffer->tail_page == cpu_buffer->reader_page)\n\t\ttail_page = rb_list_head(tail_page->next);\n\tto_remove = tail_page;\n\tfirst_page = list_entry(rb_list_head(to_remove->next),\n\t\t\t\tstruct buffer_page, list);\n\tfor (nr_removed = 0; nr_removed < nr_pages; nr_removed++) {\n\t\tto_remove = rb_list_head(to_remove)->next;\n\t\thead_bit |= (unsigned long)to_remove & RB_PAGE_HEAD;\n\t}\n\tnext_page = rb_list_head(to_remove)->next;\n\ttail_page->next = (struct list_head *)((unsigned long)next_page |\n\t\t\t\t\t\thead_bit);\n\tnext_page = rb_list_head(next_page);\n\tnext_page->prev = tail_page;\n\tcpu_buffer->pages = next_page;\n\tif (head_bit)\n\t\tcpu_buffer->head_page = list_entry(next_page,\n\t\t\t\t\t\tstruct buffer_page, list);\n\tcpu_buffer->read = 0;\n\tatomic_dec(&cpu_buffer->record_disabled);\n\traw_spin_unlock_irq(&cpu_buffer->reader_lock);\n\tRB_WARN_ON(cpu_buffer, list_empty(cpu_buffer->pages));\n\tlast_page = list_entry(rb_list_head(to_remove), struct buffer_page,\n\t\t\t\tlist);\n\ttmp_iter_page = first_page;\n\tdo {\n\t\tcond_resched();\n\t\tto_remove_page = tmp_iter_page;\n\t\trb_inc_page(&tmp_iter_page);\n\t\tpage_entries = rb_page_entries(to_remove_page);\n\t\tif (page_entries) {\n\t\t\tlocal_add(page_entries, &cpu_buffer->overrun);\n\t\t\tlocal_sub(BUF_PAGE_SIZE, &cpu_buffer->entries_bytes);\n\t\t}\n\t\tfree_buffer_page(to_remove_page);\n\t\tnr_removed--;\n\t} while (to_remove_page != last_page);\n\tRB_WARN_ON(cpu_buffer, nr_removed);\n\treturn nr_removed == 0;\n}", "target": 0}
{"code": "__delta_head_destroy(struct delta_head **delta_head)\n{\n\tdelta_head_destroy(*delta_head);\n}", "target": 1}
{"code": "static int ext4_dax_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\treturn dax_mkwrite(vma, vmf, ext4_get_block_dax,\n\t\t\t\text4_end_io_unwritten);\n}", "target": 1}
{"code": "static int ptrace_setoptions(struct task_struct *child, unsigned long data)\n{\n\tunsigned flags;\n\tif (data & ~(unsigned long)PTRACE_O_MASK)\n\t\treturn -EINVAL;\n\tif (unlikely(data & PTRACE_O_SUSPEND_SECCOMP)) {\n\t\tif (!IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) ||\n\t\t    !IS_ENABLED(CONFIG_SECCOMP))\n\t\t\treturn -EINVAL;\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (seccomp_mode(&current->seccomp) != SECCOMP_MODE_DISABLED ||\n\t\t    current->ptrace & PT_SUSPEND_SECCOMP)\n\t\t\treturn -EPERM;\n\t}\n\tflags = child->ptrace;\n\tflags &= ~(PTRACE_O_MASK << PT_OPT_FLAG_SHIFT);\n\tflags |= (data << PT_OPT_FLAG_SHIFT);\n\tchild->ptrace = flags;\n\treturn 0;\n}", "target": 1}
{"code": "TfLiteStatus GatherStrings(TfLiteContext* context, const TfLiteTensor* input,\n                           const TfLiteTensor* positions,\n                           TfLiteTensor* output) {\n  DynamicBuffer buffer;\n  const PositionT* indexes = GetTensorData<PositionT>(positions);\n  bool indices_has_only_positive_elements = true;\n  const size_t num_indices = positions->bytes / sizeof(PositionT);\n  for (size_t i = 0; i < num_indices; i++) {\n    if (indexes[i] < 0) {\n      indices_has_only_positive_elements = false;\n      break;\n    }\n  }\n  TF_LITE_ENSURE(context, indices_has_only_positive_elements);\n  const PositionT num_strings = GetStringCount(input);\n  const int num_indexes = NumElements(positions);\n  for (int i = 0; i < num_indexes; ++i) {\n    const PositionT pos = indexes[i];\n    TF_LITE_ENSURE(context, pos < num_strings);\n    const auto string_ref = GetString(input, pos);\n    buffer.AddString(string_ref.str, string_ref.len);\n  }\n  buffer.WriteToTensor(output, nullptr);\n  return kTfLiteOk;\n}", "target": 0}
{"code": "static int truncate_inline_extent(struct inode *inode,\n\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t  struct btrfs_key *found_key,\n\t\t\t\t  const u64 item_end,\n\t\t\t\t  const u64 new_size)\n{\n\tstruct extent_buffer *leaf = path->nodes[0];\n\tint slot = path->slots[0];\n\tstruct btrfs_file_extent_item *fi;\n\tu32 size = (u32)(new_size - found_key->offset);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tfi = btrfs_item_ptr(leaf, slot, struct btrfs_file_extent_item);\n\tif (btrfs_file_extent_compression(leaf, fi) != BTRFS_COMPRESS_NONE) {\n\t\tloff_t offset = new_size;\n\t\tloff_t page_end = ALIGN(offset, PAGE_CACHE_SIZE);\n\t\tbtrfs_release_path(path);\n\t\treturn btrfs_truncate_page(inode, offset, page_end - offset, 0);\n\t}\n\tbtrfs_set_file_extent_ram_bytes(leaf, fi, size);\n\tsize = btrfs_file_extent_calc_inline_size(size);\n\tbtrfs_truncate_item(root, path, size, 1);\n\tif (test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\tinode_sub_bytes(inode, item_end + 1 - new_size);\n\treturn 0;\n}", "target": 0}
{"code": "TEST(NNOpsTest, FractionalPool_ShapeFn) {\n  for (const char* op_name : {\"FractionalAvgPool\", \"FractionalMaxPool\"}) {\n    ShapeInferenceTestOp op(op_name);\n    auto set_op = [&op, op_name](const std::vector<float>& pooling_ratio) {\n      TF_ASSERT_OK(NodeDefBuilder(\"test\", op_name)\n                       .Input(\"input\", 0, DT_FLOAT)\n                       .Attr(\"pooling_ratio\", pooling_ratio)\n                       .Finalize(&op.node_def));\n    };\n    set_op(std::vector<float>{2.0f, 1, 1 / 1.5f, 1 / 2.0f});\n    INFER_ERROR(\"must be rank 4\", op, \"[?,?,?]\");\n    INFER_OK(op, \"?\", \"[?,?,?,?];[?];[?]\");\n    INFER_OK(op, \"[?,?,?,?]\", \"[?,?,?,?];[?];[?]\");\n    INFER_OK(op, \"[10,20,30,40]\", \"[5,20,45,80];[20];[45]\");\n    INFER_OK(op, \"[?,20,30,40]\", \"[?,20,45,80];[20];[45]\");\n    INFER_OK(op, \"[10,?,30,40]\", \"[5,?,45,80];[?];[45]\");\n    INFER_OK(op, \"[10,20,?,40]\", \"[5,20,?,80];[20];[?]\");\n    INFER_OK(op, \"[10,20,30,?]\", \"[5,20,45,?];[20];[45]\");\n    set_op(std::vector<float>{.5, 1.0, 1.5});\n    INFER_ERROR(\"pooling_ratio field\", op, \"?\");\n    set_op(std::vector<float>{1, 2, 3, 4, 5});\n    INFER_ERROR(\"pooling_ratio field\", op, \"?\");\n    set_op(std::vector<float>{-1, 2, 3, 4});\n    INFER_ERROR(\"is negative\", op, \"[1,2,3,4]\");\n  }\n}", "target": 1}
{"code": "sraSpanInsertBefore(sraSpan *newspan, sraSpan *before) {\n  newspan->_next = before;\n  newspan->_prev = before->_prev;\n  before->_prev->_next = newspan;\n  before->_prev = newspan;\n}", "target": 1}
{"code": "GF_Err mvcg_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_MultiviewGroupBox *ptr = (GF_MultiviewGroupBox *) s;\n\tptr->size += 7;\n\tfor (i=0; i<ptr->num_entries; i++) {\n\t\tswitch (ptr->entries[i].entry_type) {\n\t\tcase 0:\n\t\t\tptr->size += 1 + 4;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tptr->size += 1 + 6;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tptr->size += 1 + 2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tptr->size += 1 + 4;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "static void jpc_undo_roi(jas_matrix_t *x, int roishift, int bgshift, int numbps)\n{\n\tint i;\n\tint j;\n\tint thresh;\n\tjpc_fix_t val;\n\tjpc_fix_t mag;\n\tbool warn;\n\tuint_fast32_t mask;\n\tif (roishift == 0 && bgshift == 0) {\n\t\treturn;\n\t}\n\tthresh = 1 << roishift;\n\twarn = false;\n\tfor (i = 0; i < jas_matrix_numrows(x); ++i) {\n\t\tfor (j = 0; j < jas_matrix_numcols(x); ++j) {\n\t\t\tval = jas_matrix_get(x, i, j);\n\t\t\tmag = JAS_ABS(val);\n\t\t\tif (mag >= thresh) {\n\t\t\t\tmag >>= roishift;\n\t\t\t\tval = (val < 0) ? (-mag) : mag;\n\t\t\t\tjas_matrix_set(x, i, j, val);\n\t\t\t} else {\n\t\t\t\tmag <<= bgshift;\n\t\t\t\tmask = (1 << numbps) - 1;\n\t\t\t\tif (mag & (~mask)) {\n\t\t\t\t\tif (!warn) {\n\t\t\t\t\t\tjas_eprintf(\"warning: possibly corrupt code stream\\n\");\n\t\t\t\t\t\twarn = true;\n\t\t\t\t\t}\n\t\t\t\t\tmag &= mask;\n\t\t\t\t}\n\t\t\t\tval = (val < 0) ? (-mag) : mag;\n\t\t\t\tjas_matrix_set(x, i, j, val);\n\t\t\t}\n\t\t}\n\t}\n}", "target": 0}
{"code": "static inline int crypto_rng_seedsize(struct crypto_rng *tfm)\n{\n\treturn tfm->seedsize;\n}", "target": 1}
{"code": "static inline void encode_openhdr(struct xdr_stream *xdr, const struct nfs_openargs *arg)\n{\n\t__be32 *p;\n\tRESERVE_SPACE(8);\n\tWRITE32(OP_OPEN);\n\tWRITE32(arg->seqid->sequence->counter);\n\tencode_share_access(xdr, arg->open_flags);\n\tRESERVE_SPACE(28);\n\tWRITE64(arg->clientid);\n\tWRITE32(16);\n\tWRITEMEM(\"open id:\", 8);\n\tWRITE64(arg->id);\n}", "target": 1}
{"code": "new_httpd(isc_httpdmgr_t *httpdmgr, isc_nmhandle_t *handle) {\n\tisc_httpd_t *httpd = NULL;\n\tchar *headerdata = NULL;\n\tREQUIRE(VALID_HTTPDMGR(httpdmgr));\n\thttpd = isc_nmhandle_getdata(handle);\n\tif (httpd == NULL) {\n\t\thttpd = isc_nmhandle_getextra(handle);\n\t\t*httpd = (isc_httpd_t){ .handle = NULL };\n\t\thttpdmgr_attach(httpdmgr, &httpd->mgr);\n\t}\n\tif (httpd->handle == NULL) {\n\t\tisc_nmhandle_setdata(handle, httpd, httpd_reset, httpd_put);\n\t\thttpd->handle = handle;\n\t} else {\n\t\tINSIST(httpd->handle == handle);\n\t}\n\theaderdata = isc_mem_get(httpdmgr->mctx, HTTP_SENDGROW);\n\tisc_buffer_init(&httpd->headerbuffer, headerdata, HTTP_SENDGROW);\n\tisc_buffer_clear(&httpd->headerbuffer);\n\tisc_buffer_initnull(&httpd->compbuffer);\n\tisc_buffer_clear(&httpd->compbuffer);\n\tisc_buffer_initnull(&httpd->bodybuffer);\n\tISC_LINK_INIT(httpd, link);\n\thttpd->magic = HTTPD_MAGIC;\n\thttpd->state = RECV;\n\tLOCK(&httpdmgr->lock);\n\tISC_LIST_APPEND(httpdmgr->running, httpd, link);\n\tUNLOCK(&httpdmgr->lock);\n\tisc_nmhandle_attach(httpd->handle, &httpd->readhandle);\n\tisc_nm_read(handle, httpd_request, httpdmgr);\n}", "target": 0}
{"code": "nfsd4_copy(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_copy *copy)\n{\n\tstruct file *src, *dst;\n\t__be32 status;\n\tssize_t bytes;\n\tstatus = nfsd4_verify_copy(rqstp, cstate, &copy->cp_src_stateid, &src,\n\t\t\t\t   &copy->cp_dst_stateid, &dst);\n\tif (status)\n\t\tgoto out;\n\tbytes = nfsd_copy_file_range(src, copy->cp_src_pos,\n\t\t\tdst, copy->cp_dst_pos, copy->cp_count);\n\tif (bytes < 0)\n\t\tstatus = nfserrno(bytes);\n\telse {\n\t\tcopy->cp_res.wr_bytes_written = bytes;\n\t\tcopy->cp_res.wr_stable_how = NFS_UNSTABLE;\n\t\tcopy->cp_consecutive = 1;\n\t\tcopy->cp_synchronous = 1;\n\t\tgen_boot_verifier(&copy->cp_res.wr_verifier, SVC_NET(rqstp));\n\t\tstatus = nfs_ok;\n\t}\n\tfput(src);\n\tfput(dst);\nout:\n\treturn status;\n}", "target": 0}
{"code": "static void mptsas_soft_reset(MPTSASState *s)\n{\n    uint32_t save_mask;\n    trace_mptsas_reset(s);\n    save_mask = s->intr_mask;\n    s->intr_mask = MPI_HIM_DIM | MPI_HIM_RIM;\n    mptsas_update_interrupt(s);\n    qbus_reset_all(BUS(&s->bus));\n    s->intr_status = 0;\n    s->intr_mask = save_mask;\n    s->reply_free_tail = 0;\n    s->reply_free_head = 0;\n    s->reply_post_tail = 0;\n    s->reply_post_head = 0;\n    s->request_post_tail = 0;\n    s->request_post_head = 0;\n    qemu_bh_cancel(s->request_bh);\n    s->state = MPI_IOC_STATE_READY;\n}", "target": 0}
{"code": "static ssize_t TIFFReadCustomStream(unsigned char *data,const size_t count,\n  void *user_data)\n{\n  PhotoshopProfile\n    *profile;\n  size_t\n    total;\n  ssize_t\n    remaining;\n  if (count == 0)\n    return(0);\n  profile=(PhotoshopProfile *) user_data;\n  remaining=(MagickOffsetType) profile->length-profile->offset;\n  if (remaining <= 0)\n    return(-1);\n  total=MagickMin(count, (size_t) remaining);\n  (void) memcpy(data,profile->data->datum+profile->offset,total);\n  profile->offset+=total;\n  return(total);\n}", "target": 0}
{"code": "void gdImageString (gdImagePtr im, gdFontPtr f, int x, int y, unsigned char *s, int color)\n{\n\tint i;\n\tint l;\n\tl = strlen ((char *) s);\n\tfor (i = 0; (i < l); i++) {\n\t\tgdImageChar(im, f, x, y, s[i], color);\n\t\tx += f->w;\n\t}\n}", "target": 0}
{"code": "int flush_old_exec(struct linux_binprm * bprm)\n{\n\tint retval;\n\tretval = de_thread(current);\n\tif (retval)\n\t\tgoto out;\n\tset_mm_exe_file(bprm->mm, bprm->file);\n\tacct_arg_size(bprm, 0);\n\tretval = exec_mmap(bprm->mm);\n\tif (retval)\n\t\tgoto out;\n\tbprm->mm = NULL;\n\tset_fs(USER_DS);\n\tcurrent->flags &= ~(PF_RANDOMIZE | PF_FORKNOEXEC | PF_KTHREAD |\n\t\t\t\t\tPF_NOFREEZE | PF_NO_SETAFFINITY);\n\tflush_thread();\n\tcurrent->personality &= ~bprm->per_clear;\n\tdo_close_on_exec(current->files);\n\treturn 0;\nout:\n\treturn retval;\n}", "target": 0}
{"code": "  virtual void ConnectToWifiNetwork(const WifiNetwork* network,\n                                    const std::string& password,\n                                    const std::string& identity,\n                                    const std::string& certpath) {}", "target": 0}
{"code": "xmlDictComputeFastQKey(const xmlChar *prefix, int plen,\n                       const xmlChar *name, int len, int seed)\n{\n    unsigned long value = (unsigned long) seed;\n    if (plen == 0)\n\tvalue += 30 * (unsigned long) ':';\n    else\n\tvalue += 30 * (*prefix);\n    if (len > 10) {\n        value += name[len - (plen + 1 + 1)];\n        len = 10;\n\tif (plen > 10)\n\t    plen = 10;\n    }\n    switch (plen) {\n        case 10: value += prefix[9];\n        case 9: value += prefix[8];\n        case 8: value += prefix[7];\n        case 7: value += prefix[6];\n        case 6: value += prefix[5];\n        case 5: value += prefix[4];\n        case 4: value += prefix[3];\n        case 3: value += prefix[2];\n        case 2: value += prefix[1];\n        case 1: value += prefix[0];\n        default: break;\n    }\n    len -= plen;\n    if (len > 0) {\n        value += (unsigned long) ':';\n\tlen--;\n    }\n    switch (len) {\n        case 10: value += name[9];\n        case 9: value += name[8];\n        case 8: value += name[7];\n        case 7: value += name[6];\n        case 6: value += name[5];\n        case 5: value += name[4];\n        case 4: value += name[3];\n        case 3: value += name[2];\n        case 2: value += name[1];\n        case 1: value += name[0];\n        default: break;\n    }\n    return(value);\n}", "target": 1}
{"code": "rdr_notification_ctx_init(struct rdr_notification_ctx *ctx)\n{\n\tdeltas_parsed_init(&ctx->deltas);\n\treturn 0;\n}", "target": 1}
{"code": "  const std::string& get_tenant() const {\n    ceph_assert(t != Wildcard);\n    return u.tenant;\n  }", "target": 1}
{"code": "static PHP_INI_MH(OnUpdateInternalEncoding)\n{\n\tif (new_value) {\n\t\tOnUpdateString(entry, new_value, mh_arg1, mh_arg2, mh_arg3, stage);\n\t}\n\treturn SUCCESS;\n}", "target": 0}
{"code": "static void vdbeVComment(Vdbe *p, const char *zFormat, va_list ap){\n  assert( p->nOp>0 || p->aOp==0 );\n  assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed );\n  if( p->nOp ){\n    assert( p->aOp );\n    sqlite3DbFree(p->db, p->aOp[p->nOp-1].zComment);\n    p->aOp[p->nOp-1].zComment = sqlite3VMPrintf(p->db, zFormat, ap);\n  }\n}", "target": 1}
{"code": "static inline int check_entry_size_and_hooks(struct arpt_entry *e,\n\t\t\t\t\t     struct xt_table_info *newinfo,\n\t\t\t\t\t     const unsigned char *base,\n\t\t\t\t\t     const unsigned char *limit,\n\t\t\t\t\t     const unsigned int *hook_entries,\n\t\t\t\t\t     const unsigned int *underflows,\n\t\t\t\t\t     unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct arpt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 0}
{"code": "dotraplinkage void notrace do_int3(struct pt_regs *regs, long error_code)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (unlikely(atomic_read(&modifying_ftrace_code)) &&\n\t    ftrace_int3_handler(regs))\n\t\treturn;\n#endif\n\tif (poke_int3_handler(regs))\n\t\treturn;\n\tist_enter(regs);\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(), \"entry code didn't wake RCU\");\n#ifdef CONFIG_KGDB_LOW_LEVEL_TRAP\n\tif (kgdb_ll_trap(DIE_INT3, \"int3\", regs, error_code, X86_TRAP_BP,\n\t\t\t\tSIGTRAP) == NOTIFY_STOP)\n\t\tgoto exit;\n#endif \n#ifdef CONFIG_KPROBES\n\tif (kprobe_int3_handler(regs))\n\t\tgoto exit;\n#endif\n\tif (notify_die(DIE_INT3, \"int3\", regs, error_code, X86_TRAP_BP,\n\t\t\tSIGTRAP) == NOTIFY_STOP)\n\t\tgoto exit;\n\tdebug_stack_usage_inc();\n\tcond_local_irq_enable(regs);\n\tdo_trap(X86_TRAP_BP, SIGTRAP, \"int3\", regs, error_code, NULL);\n\tcond_local_irq_disable(regs);\n\tdebug_stack_usage_dec();\nexit:\n\tist_exit(regs);\n}", "target": 1}
{"code": "update_bar_address(struct vmctx *ctx, struct pci_vdev *dev, uint64_t addr,\n\tint idx, int type, bool ignore_reg_unreg)\n{\n\tbool decode = false;\n\tuint64_t orig_addr = dev->bar[idx].addr;\n\tif (!ignore_reg_unreg) {\n\t\tif (dev->bar[idx].type == PCIBAR_IO)\n\t\t\tdecode = porten(dev);\n\t\telse\n\t\t\tdecode = memen(dev);\n\t}\n\tif (decode)\n\t\tunregister_bar(dev, idx);\n\tswitch (type) {\n\tcase PCIBAR_IO:\n\tcase PCIBAR_MEM32:\n\t\tdev->bar[idx].addr = addr;\n\t\tbreak;\n\tcase PCIBAR_MEM64:\n\t\tdev->bar[idx].addr &= ~0xffffffffUL;\n\t\tdev->bar[idx].addr |= addr;\n\t\tbreak;\n\tcase PCIBAR_MEMHI64:\n\t\tdev->bar[idx].addr &= 0xffffffff;\n\t\tdev->bar[idx].addr |= addr;\n\t\tbreak;\n\tdefault:\n\t\tassert(0);\n\t}\n\tif (decode)\n\t\tregister_bar(dev, idx);\n\tif (dev->dev_ops->vdev_update_bar_map && decode)\n\t\tdev->dev_ops->vdev_update_bar_map(ctx, dev, idx, orig_addr);\n}", "target": 1}
{"code": "static int __tail_onwire_len(int front_len, int middle_len, int data_len,\n\t\t\t     bool secure)\n{\n\tBUG_ON(front_len < 0 || front_len > CEPH_MSG_MAX_FRONT_LEN ||\n\t       middle_len < 0 || middle_len > CEPH_MSG_MAX_MIDDLE_LEN ||\n\t       data_len < 0 || data_len > CEPH_MSG_MAX_DATA_LEN);\n\tif (!front_len && !middle_len && !data_len)\n\t\treturn 0;\n\tif (!secure)\n\t\treturn front_len + middle_len + data_len +\n\t\t       CEPH_EPILOGUE_PLAIN_LEN;\n\treturn padded_len(front_len) + padded_len(middle_len) +\n\t       padded_len(data_len) + CEPH_EPILOGUE_SECURE_LEN;\n}", "target": 0}
{"code": "static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)\n{\n\tstruct snd_seq_port_info *info = arg;\n\tstruct snd_seq_client_port *port;\n\tstruct snd_seq_port_callback *callback;\n\tif (info->addr.client != client->number)\n\t\treturn -EPERM;\n\tport = snd_seq_create_port(client, (info->flags & SNDRV_SEQ_PORT_FLG_GIVEN_PORT) ? info->addr.port : -1);\n\tif (port == NULL)\n\t\treturn -ENOMEM;\n\tif (client->type == USER_CLIENT && info->kernel) {\n\t\tsnd_seq_delete_port(client, port->addr.port);\n\t\treturn -EINVAL;\n\t}\n\tif (client->type == KERNEL_CLIENT) {\n\t\tif ((callback = info->kernel) != NULL) {\n\t\t\tif (callback->owner)\n\t\t\t\tport->owner = callback->owner;\n\t\t\tport->private_data = callback->private_data;\n\t\t\tport->private_free = callback->private_free;\n\t\t\tport->event_input = callback->event_input;\n\t\t\tport->c_src.open = callback->subscribe;\n\t\t\tport->c_src.close = callback->unsubscribe;\n\t\t\tport->c_dest.open = callback->use;\n\t\t\tport->c_dest.close = callback->unuse;\n\t\t}\n\t}\n\tinfo->addr = port->addr;\n\tsnd_seq_set_port_info(port, info);\n\tsnd_seq_system_client_ev_port_start(port->addr.client, port->addr.port);\n\treturn 0;\n}", "target": 1}
{"code": "const void *gf_isom_get_tfrf(GF_ISOFile *movie, u32 trackNumber)\n{\n#ifdef GPAC_DISABLE_ISOM_FRAGMENTS\n\treturn NULL;\n#else\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return NULL;\n\treturn trak->tfrf;\n#endif\n}", "target": 0}
{"code": "static bool ok_jpg_decode_restart_if_needed(ok_jpg_decoder *decoder) {\n    if (decoder->restart_intervals_remaining > 0) {\n        decoder->restart_intervals_remaining--;\n        if (decoder->restart_intervals_remaining == 0) {\n            ok_jpg_dump_bits(decoder);\n            if (decoder->next_marker != 0) {\n                if (decoder->next_marker == 0xD0 + decoder->next_restart) {\n                    decoder->next_marker = 0;\n                } else {\n                    ok_jpg_error(decoder->jpg, OK_JPG_ERROR_INVALID, \"Invalid restart marker (1)\");\n                    return false;\n                }\n            } else {\n                uint8_t buffer[2];\n                if (!ok_read(decoder, buffer, 2)) {\n                    return false;\n                }\n                if (!(buffer[0] == 0xff && buffer[1] == 0xD0 + decoder->next_restart)) {\n                    ok_jpg_error(decoder->jpg, OK_JPG_ERROR_INVALID, \"Invalid restart marker (2)\");\n                    return false;\n                }\n            }\n            decoder->next_restart = (decoder->next_restart + 1) & 7;\n            ok_jpg_decode_restart(decoder);\n        }\n    }\n    return true;\n}", "target": 0}
{"code": "print_al(const gs_memory_t *mem, const char *label, const active_line * alp)\n{\n    if (gs_debug_c('F'))\n        print_active_line(mem, label, alp);\n}", "target": 0}
{"code": "static authz_status oidc_handle_unauthorized_user24(request_rec *r) {\n\toidc_debug(r, \"enter\");\n\toidc_cfg *c = ap_get_module_config(r->server->module_config, &auth_openidc_module);\n\tif (apr_strnatcasecmp((const char*) ap_auth_type(r),\n\t\t\t\t\t\t  OIDC_AUTH_TYPE_OPENID_OAUTH20) == 0) {\n\t\toidc_debug(r, \"setting environment variable %s to \\\"%s\\\" for usage in mod_headers\", OIDC_OAUTH_BEARER_SCOPE_ERROR, OIDC_OAUTH_BEARER_SCOPE_ERROR_VALUE);\n\t\tapr_table_set(r->subprocess_env, OIDC_OAUTH_BEARER_SCOPE_ERROR, OIDC_OAUTH_BEARER_SCOPE_ERROR_VALUE);\n\t\treturn AUTHZ_DENIED;\n\t}\n\tswitch (oidc_dir_cfg_unautz_action(r)) {\n\t\tcase OIDC_UNAUTZ_RETURN403:\n\t\tcase OIDC_UNAUTZ_RETURN401:\n\t\t\treturn AUTHZ_DENIED;\n\t\t\tbreak;\n\t\tcase OIDC_UNAUTZ_AUTHENTICATE:\n\t\t\tif (oidc_is_xml_http_request(r) == TRUE)\n\t\t\t\treturn AUTHZ_DENIED;\n\t\t\tbreak;\n\t}\n\toidc_authenticate_user(r, c, NULL, oidc_get_current_url(r), NULL,\n\t\t\tNULL, NULL, oidc_dir_cfg_path_auth_request_params(r), oidc_dir_cfg_path_scope(r));\n\tconst char *location = oidc_util_hdr_out_location_get(r);\n\tif (location != NULL) {\n\t\toidc_debug(r, \"send HTML refresh with authorization redirect: %s\", location);\n\t\tchar *html_head =\n\t\t\t\tapr_psprintf(r->pool, \"<meta http-equiv=\\\"refresh\\\" content=\\\"0; url=%s\\\">\", location);\n\t\toidc_util_html_send(r, \"Stepup Authentication\", html_head, NULL, NULL,\n\t\t\t\tHTTP_UNAUTHORIZED);\n\t\tr->header_only = 1;\n\t}\n\treturn AUTHZ_DENIED;\n}", "target": 0}
{"code": "static int atalk_create(struct net *net, struct socket *sock, int protocol,\n\t\t\tint kern)\n{\n\tstruct sock *sk;\n\tint rc = -ESOCKTNOSUPPORT;\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\tif (sock->type != SOCK_RAW && sock->type != SOCK_DGRAM)\n\t\tgoto out;\n\trc = -ENOMEM;\n\tsk = sk_alloc(net, PF_APPLETALK, GFP_KERNEL, &ddp_proto, kern);\n\tif (!sk)\n\t\tgoto out;\n\trc = 0;\n\tsock->ops = &atalk_dgram_ops;\n\tsock_init_data(sock, sk);\n\tsock_set_flag(sk, SOCK_ZAPPED);\nout:\n\treturn rc;\n}", "target": 1}
{"code": "void *TrustedPrimitives::UntrustedLocalMemcpy(void *dest, const void *src,\n                                              size_t size) noexcept {\n  return memcpy(dest, src, size);\n}", "target": 0}
{"code": "static int createFromTiffRgba(TIFF * tif, gdImagePtr im)\n{\n\tint a;\n\tint x, y;\n\tint alphaBlendingFlag = 0;\n\tint color;\n\tint width = im->sx;\n\tint height = im->sy;\n\tuint32 *buffer;\n\tuint32 rgba;\n\talphaBlendingFlag = im->alphaBlendingFlag;\n\tgdImageAlphaBlending(im, 0);\n\tbuffer = (uint32 *) gdCalloc(sizeof(uint32), width * height);\n\tif (!buffer) {\n\t\treturn GD_FAILURE;\n\t}\n\tTIFFReadRGBAImage(tif, width, height, buffer, 0);\n\tfor(y = 0; y < height; y++) {\n\t\tfor(x = 0; x < width; x++) {\n\t\t\trgba = buffer[(y * width + x)];\n\t\t\ta = (0xff - TIFFGetA(rgba)) / 2;\n\t\t\tcolor = gdTrueColorAlpha(TIFFGetR(rgba), TIFFGetG(rgba), TIFFGetB(rgba), a);\n\t\t\tgdImageSetPixel(im, x, height - y - 1, color);\n\t\t}\n\t}\n\tgdFree(buffer);\n\tgdImageAlphaBlending(im, alphaBlendingFlag);\n\treturn GD_SUCCESS;\n}", "target": 1}
{"code": "static int dump_seek(struct file *file, loff_t off)\n{\n\tif (file->f_op->llseek) {\n\t\tif (file->f_op->llseek(file, off, SEEK_SET) != off)\n\t\t\treturn 0;\n\t} else {\n\t\tfile->f_pos = off;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "try_flatedecode(unsigned char *buf, off_t real_len, off_t calculated_len, int fout, cli_ctx *ctx)\n{\n\tint ret = cli_checklimits(\"cli_pdf\", ctx, real_len, 0, 0);\n\tif (ret==CL_CLEAN && flatedecode(buf, real_len, fout, ctx) == CL_SUCCESS)\n\t\treturn CL_CLEAN;\n\tif(real_len == calculated_len) {\n\t\tcli_dbgmsg(\"cli_pdf: Bad compression in flate stream\\n\");\n\t\treturn CL_CLEAN;\n\t}\n\tif(cli_checklimits(\"cli_pdf\", ctx, calculated_len, 0, 0)!=CL_CLEAN)\n\t\treturn CL_CLEAN;\n\tret = flatedecode(buf, calculated_len, fout, ctx);\n\tif(ret == CL_CLEAN)\n\t\treturn CL_CLEAN;\n\tcli_dbgmsg(\"cli_pdf: Bad compressed block length in flate stream\\n\");\n\treturn ret;\n}", "target": 0}
{"code": "static void blk_mq_insert_requests(struct request_queue *q,\n\t\t\t\t     struct blk_mq_ctx *ctx,\n\t\t\t\t     struct list_head *list,\n\t\t\t\t     int depth,\n\t\t\t\t     bool from_schedule)\n{\n\tstruct blk_mq_hw_ctx *hctx;\n\tstruct blk_mq_ctx *current_ctx;\n\ttrace_block_unplug(q, depth, !from_schedule);\n\tcurrent_ctx = blk_mq_get_ctx(q);\n\tif (!cpu_online(ctx->cpu))\n\t\tctx = current_ctx;\n\thctx = q->mq_ops->map_queue(q, ctx->cpu);\n\tspin_lock(&ctx->lock);\n\twhile (!list_empty(list)) {\n\t\tstruct request *rq;\n\t\trq = list_first_entry(list, struct request, queuelist);\n\t\tlist_del_init(&rq->queuelist);\n\t\trq->mq_ctx = ctx;\n\t\t__blk_mq_insert_request(hctx, rq, false);\n\t}\n\tspin_unlock(&ctx->lock);\n\tblk_mq_run_hw_queue(hctx, from_schedule);\n\tblk_mq_put_ctx(current_ctx);\n}", "target": 0}
{"code": "void unbind_ports(void) {\n    SERVICE_OPTIONS *opt;\n    s_poll_init(fds, 1);\n    CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_SECTIONS]);\n    opt=service_options.next;\n    service_options.next=NULL;\n    service_free(&service_options);\n    while(opt) {\n        unsigned i;\n        s_log(LOG_DEBUG, \"Unbinding service [%s]\", opt->servname);\n        for(i=0; i<opt->local_addr.num; ++i)\n            unbind_port(opt, i);\n        if(opt->exec_name && opt->connect_addr.names) {\n            opt->option.retry=0;\n        }\n        if(opt->ctx)\n            SSL_CTX_flush_sessions(opt->ctx,\n                (long)time(NULL)+opt->session_timeout+1);\n        s_log(LOG_DEBUG, \"Service [%s] closed\", opt->servname);\n        {\n            SERVICE_OPTIONS *garbage=opt;\n            opt=opt->next;\n            garbage->next=NULL;\n            service_free(garbage);\n        }\n    }\n    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_SECTIONS]);\n}", "target": 1}
{"code": "static int get_vdev_port_node_info(struct mdesc_handle *md, u64 node,\n\t\t\t\t   union md_node_info *node_info)\n{\n\tconst u64 *parent_cfg_hdlp;\n\tconst char *name;\n\tconst u64 *idp;\n\tidp = mdesc_get_property(md, node, \"id\", NULL);\n\tname = mdesc_get_property(md, node, \"name\", NULL);\n\tparent_cfg_hdlp = parent_cfg_handle(md, node);\n\tif (!idp || !name || !parent_cfg_hdlp)\n\t\treturn -1;\n\tnode_info->vdev_port.id = *idp;\n\tnode_info->vdev_port.name = kstrdup_const(name, GFP_KERNEL);\n\tnode_info->vdev_port.parent_cfg_hdl = *parent_cfg_hdlp;\n\treturn 0;\n}", "target": 1}
{"code": "static noinline void key_gc_unused_keys(struct list_head *keys)\n{\n\twhile (!list_empty(keys)) {\n\t\tstruct key *key =\n\t\t\tlist_entry(keys->next, struct key, graveyard_link);\n\t\tlist_del(&key->graveyard_link);\n\t\tkdebug(\"- %u\", key->serial);\n\t\tkey_check(key);\n\t\tsecurity_key_free(key);\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\t\tatomic_dec(&key->user->nkeys);\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))\n\t\t\tatomic_dec(&key->user->nikeys);\n\t\tkey_user_put(key->user);\n\t\tif (key->type->destroy)\n\t\t\tkey->type->destroy(key);\n\t\tkfree(key->description);\n#ifdef KEY_DEBUGGING\n\t\tkey->magic = KEY_DEBUG_MAGIC_X;\n#endif\n\t\tkmem_cache_free(key_jar, key);\n\t}\n}", "target": 1}
{"code": "static int list_devices(struct file *filp, struct dm_ioctl *param, size_t param_size)\n{\n\tunsigned int i;\n\tstruct hash_cell *hc;\n\tsize_t len, needed = 0;\n\tstruct gendisk *disk;\n\tstruct dm_name_list *orig_nl, *nl, *old_nl = NULL;\n\tuint32_t *event_nr;\n\tdown_write(&_hash_lock);\n\tfor (i = 0; i < NUM_BUCKETS; i++) {\n\t\tlist_for_each_entry (hc, _name_buckets + i, name_list) {\n\t\t\tneeded += align_val(offsetof(struct dm_name_list, name) + strlen(hc->name) + 1);\n\t\t\tneeded += align_val(sizeof(uint32_t));\n\t\t}\n\t}\n\tnl = orig_nl = get_result_buffer(param, param_size, &len);\n\tif (len < needed) {\n\t\tparam->flags |= DM_BUFFER_FULL_FLAG;\n\t\tgoto out;\n\t}\n\tparam->data_size = param->data_start + needed;\n\tnl->dev = 0;\t\n\tfor (i = 0; i < NUM_BUCKETS; i++) {\n\t\tlist_for_each_entry (hc, _name_buckets + i, name_list) {\n\t\t\tif (old_nl)\n\t\t\t\told_nl->next = (uint32_t) ((void *) nl -\n\t\t\t\t\t\t\t   (void *) old_nl);\n\t\t\tdisk = dm_disk(hc->md);\n\t\t\tnl->dev = huge_encode_dev(disk_devt(disk));\n\t\t\tnl->next = 0;\n\t\t\tstrcpy(nl->name, hc->name);\n\t\t\told_nl = nl;\n\t\t\tevent_nr = align_ptr(nl->name + strlen(hc->name) + 1);\n\t\t\t*event_nr = dm_get_event_nr(hc->md);\n\t\t\tnl = align_ptr(event_nr + 1);\n\t\t}\n\t}\n\tBUG_ON((char *)nl - (char *)orig_nl != needed);\n out:\n\tup_write(&_hash_lock);\n\treturn 0;\n}", "target": 1}
{"code": "static int ptrace_signal(int signr, siginfo_t *info,\n\t\t\t struct pt_regs *regs, void *cookie)\n{\n\tif (!task_ptrace(current))\n\t\treturn signr;\n\tptrace_signal_deliver(regs, cookie);\n\tptrace_stop(signr, 0, info);\n\tsignr = current->exit_code;\n\tif (signr == 0)\n\t\treturn signr;\n\tcurrent->exit_code = 0;\n\tif (signr != info->si_signo) {\n\t\tinfo->si_signo = signr;\n\t\tinfo->si_errno = 0;\n\t\tinfo->si_code = SI_USER;\n\t\tinfo->si_pid = task_pid_vnr(current->parent);\n\t\tinfo->si_uid = task_uid(current->parent);\n\t}\n\tif (sigismember(&current->blocked, signr)) {\n\t\tspecific_send_sig_info(signr, info, current);\n\t\tsignr = 0;\n\t}\n\treturn signr;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input_indices_in = context->input(0);\n    const Tensor& input_shape_in = context->input(1);\n    OP_REQUIRES(context, TensorShapeUtils::IsMatrix(input_indices_in.shape()),\n                errors::InvalidArgument(\"Input must be a matrix.\"));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(input_shape_in.shape()),\n                errors::InvalidArgument(\"Input shape must be a vector.\"));\n    OP_REQUIRES(context,\n                input_indices_in.dim_size(1) == input_shape_in.dim_size(0),\n                errors::InvalidArgument(\n                    \"Input tensor rank must match input shape length.\"));\n    ReshapeSparseTensor<Device>(context, context->input(0), context->input(1),\n                                context->input(2), 0 ,\n                                1 );\n  }", "target": 0}
{"code": "Error ImageOverlay::parse(size_t num_images, const std::vector<uint8_t>& data)\n{\n  Error eofError(heif_error_Invalid_input,\n                 heif_suberror_Invalid_grid_data,\n                 \"Overlay image data incomplete\");\n  if (data.size() < 2 + 4 * 2) {\n    return eofError;\n  }\n  m_version = data[0];\n  m_flags = data[1];\n  if (m_version != 0) {\n    std::stringstream sstr;\n    sstr << \"Overlay image data version \" << ((int) m_version) << \" is not implemented yet\";\n    return Error(heif_error_Unsupported_feature,\n                 heif_suberror_Unsupported_data_version,\n                 sstr.str());\n  }\n  int field_len = ((m_flags & 1) ? 4 : 2);\n  int ptr = 2;\n  if (ptr + 4 * 2 + 2 * field_len + num_images * 2 * field_len > data.size()) {\n    return eofError;\n  }\n  for (int i = 0; i < 4; i++) {\n    uint16_t color = static_cast<uint16_t>(readvec(data, ptr, 2));\n    m_background_color[i] = color;\n  }\n  m_width = readvec(data, ptr, field_len);\n  m_height = readvec(data, ptr, field_len);\n  m_offsets.resize(num_images);\n  for (size_t i = 0; i < num_images; i++) {\n    m_offsets[i].x = readvec_signed(data, ptr, field_len);\n    m_offsets[i].y = readvec_signed(data, ptr, field_len);\n  }\n  return Error::Ok;\n}", "target": 1}
{"code": "static bool ParseSampler(Sampler *sampler, std::string *err, const json &o,\n                         bool store_original_json_for_extras_and_extensions) {\n  ParseStringProperty(&sampler->name, err, o, \"name\", false);\n  int minFilter = -1;\n  int magFilter = -1;\n  int wrapS = TINYGLTF_TEXTURE_WRAP_REPEAT;\n  int wrapT = TINYGLTF_TEXTURE_WRAP_REPEAT;\n  ParseIntegerProperty(&minFilter, err, o, \"minFilter\", false);\n  ParseIntegerProperty(&magFilter, err, o, \"magFilter\", false);\n  ParseIntegerProperty(&wrapS, err, o, \"wrapS\", false);\n  ParseIntegerProperty(&wrapT, err, o, \"wrapT\", false);\n  sampler->minFilter = minFilter;\n  sampler->magFilter = magFilter;\n  sampler->wrapS = wrapS;\n  sampler->wrapT = wrapT;\n  ParseExtensionsProperty(&(sampler->extensions), err, o);\n  ParseExtrasProperty(&(sampler->extras), o);\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        sampler->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        sampler->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n  return true;\n}", "target": 1}
{"code": "static void unqueue_me_pi(struct futex_q *q)\n{\n\tWARN_ON(plist_node_empty(&q->list));\n\tplist_del(&q->list, &q->list.plist);\n\tBUG_ON(!q->pi_state);\n\tfree_pi_state(q->pi_state);\n\tq->pi_state = NULL;\n\tspin_unlock(q->lock_ptr);\n\tdrop_futex_key_refs(&q->key);\n}", "target": 1}
{"code": "pad_compress_skb(struct ppp *ppp, struct sk_buff *skb)\n{\n\tstruct sk_buff *new_skb;\n\tint len;\n\tint new_skb_size = ppp->dev->mtu +\n\t\tppp->xcomp->comp_extra + ppp->dev->hard_header_len;\n\tint compressor_skb_size = ppp->dev->mtu +\n\t\tppp->xcomp->comp_extra + PPP_HDRLEN;\n\tnew_skb = alloc_skb(new_skb_size, GFP_ATOMIC);\n\tif (!new_skb) {\n\t\tif (net_ratelimit())\n\t\t\tprintk(KERN_ERR \"PPP: no memory (comp pkt)\\n\");\n\t\treturn NULL;\n\t}\n\tif (ppp->dev->hard_header_len > PPP_HDRLEN)\n\t\tskb_reserve(new_skb,\n\t\t\t    ppp->dev->hard_header_len - PPP_HDRLEN);\n\tlen = ppp->xcomp->compress(ppp->xc_state, skb->data - 2,\n\t\t\t\t   new_skb->data, skb->len + 2,\n\t\t\t\t   compressor_skb_size);\n\tif (len > 0 && (ppp->flags & SC_CCP_UP)) {\n\t\tkfree_skb(skb);\n\t\tskb = new_skb;\n\t\tskb_put(skb, len);\n\t\tskb_pull(skb, 2);\t\n\t} else if (len == 0) {\n\t\tkfree_skb(new_skb);\n\t\tnew_skb = skb;\n\t} else {\n\t\tif (net_ratelimit())\n\t\t\tprintk(KERN_ERR \"ppp: compressor dropped pkt\\n\");\n\t\tkfree_skb(skb);\n\t\tkfree_skb(new_skb);\n\t\tnew_skb = NULL;\n\t}\n\treturn new_skb;\n}", "target": 0}
{"code": "static int i8042_start(struct serio *serio)\n{\n\tstruct i8042_port *port = serio->port_data;\n\tport->exists = true;\n\tmb();\n\treturn 0;\n}", "target": 1}
{"code": "static gboolean udscs_server_accept_cb(GSocketService    *service,\n                                       GSocketConnection *socket_conn,\n                                       GObject           *source_object,\n                                       gpointer           user_data)\n{\n    struct udscs_server *server = user_data;\n    UdscsConnection *new_conn;\n    new_conn = g_object_new(UDSCS_TYPE_CONNECTION, NULL);\n    new_conn->debug = server->debug;\n    new_conn->read_callback = server->read_callback;\n    g_object_ref(socket_conn);\n    vdagent_connection_setup(VDAGENT_CONNECTION(new_conn),\n                             G_IO_STREAM(socket_conn),\n                             FALSE,\n                             sizeof(struct udscs_message_header),\n                             server->error_cb);\n    server->connections = g_list_prepend(server->connections, new_conn);\n    if (server->debug)\n        syslog(LOG_DEBUG, \"new client accepted: %p\", new_conn);\n    if (server->connect_callback)\n        server->connect_callback(new_conn);\n    return TRUE;\n}", "target": 1}
{"code": "de265_error decoder_context::read_pps_NAL(bitreader& reader)\n{\n  logdebug(LogHeaders,\"----> read PPS\\n\");\n  std::shared_ptr<pic_parameter_set> new_pps = std::make_shared<pic_parameter_set>();\n  bool success = new_pps->read(&reader,this);\n  if (param_pps_headers_fd>=0) {\n    new_pps->dump(param_pps_headers_fd);\n  }\n  if (success) {\n    pps[ (int)new_pps->pic_parameter_set_id ] = new_pps;\n  }\n  return success ? DE265_OK : DE265_WARNING_PPS_HEADER_INVALID;\n}", "target": 1}
{"code": "GF_Err proj_type_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ProjectionTypeBox *ptr = (GF_ProjectionTypeBox *)s;\n\tif (ptr->type==GF_ISOM_BOX_TYPE_CBMP) {\n\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\tptr->layout = gf_bs_read_u32(bs);\n\t\tptr->padding = gf_bs_read_u32(bs);\n\t}\n\telse if (ptr->type==GF_ISOM_BOX_TYPE_EQUI) {\n\t\tISOM_DECREASE_SIZE(ptr, 16)\n\t\tptr->bounds_top = gf_bs_read_u32(bs);\n\t\tptr->bounds_bottom = gf_bs_read_u32(bs);\n\t\tptr->bounds_left = gf_bs_read_u32(bs);\n\t\tptr->bounds_right = gf_bs_read_u32(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\tptr->crc = gf_bs_read_u32(bs);\n\t\tptr->encoding_4cc = gf_bs_read_u32(bs);\n\t}\n\treturn gf_isom_box_array_read(s, bs);\n}", "target": 0}
{"code": "static int install_thread_keyring(void)\n{\n\tstruct cred *new;\n\tint ret;\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\tBUG_ON(new->thread_keyring);\n\tret = install_thread_keyring_to_cred(new);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\treturn ret;\n\t}\n\treturn commit_creds(new);\n}", "target": 1}
{"code": "int seccomp_lock_personality(unsigned long personality) {\n        uint32_t arch;\n        int r;\n        if (personality >= PERSONALITY_INVALID)\n                return -EINVAL;\n        SECCOMP_FOREACH_LOCAL_ARCH(arch) {\n                _cleanup_(seccomp_releasep) scmp_filter_ctx seccomp = NULL;\n                r = seccomp_init_for_arch(&seccomp, arch, SCMP_ACT_ALLOW);\n                if (r < 0)\n                        return r;\n                r = seccomp_rule_add_exact(\n                                seccomp,\n                                SCMP_ACT_ERRNO(EPERM),\n                                SCMP_SYS(personality),\n                                1,\n                                SCMP_A0(SCMP_CMP_NE, personality));\n                if (r < 0) {\n                        log_debug_errno(r, \"Failed to add scheduler rule for architecture %s, skipping: %m\", seccomp_arch_to_string(arch));\n                        continue;\n                }\n                r = seccomp_load(seccomp);\n                if (IN_SET(r, -EPERM, -EACCES))\n                        return r;\n                if (r < 0)\n                        log_debug_errno(r, \"Failed to enable personality lock for architecture %s, skipping: %m\", seccomp_arch_to_string(arch));\n        }\n        return 0;\n}", "target": 0}
{"code": "static int snd_ctl_elem_user_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\t*uinfo = ue->info;\n\treturn 0;\n}", "target": 0}
{"code": "ExecuteSoapAction(struct upnphttp * h, const char * action, int n)\n{\n\tchar * p;\n\tchar * p2;\n\tint i, len, methodlen;\n\tchar namespace[256];\n\tp = strchr(action, '#');\n\tif(p && (p - action) < n) {\n\t\tfor(i = 0; i < ((int)sizeof(namespace) - 1) && (action + i) < p; i++)\n\t\t\tnamespace[i] = action[i];\n\t\tnamespace[i] = '\\0';\n\t\tp++;\n\t\tp2 = strchr(p, '\"');\n\t\tif(p2 && (p2 - action) <= n)\n\t\t\tmethodlen = p2 - p;\n\t\telse\n\t\t\tmethodlen = n - (p - action);\n\t\tfor(i = 0; soapMethods[i].methodName; i++) {\n\t\t\tlen = strlen(soapMethods[i].methodName);\n\t\t\tif((len == methodlen) && memcmp(p, soapMethods[i].methodName, len) == 0) {\n#ifdef DEBUG\n\t\t\t\tsyslog(LOG_DEBUG, \"Remote Call of SoapMethod '%s' %s\",\n\t\t\t\t       soapMethods[i].methodName, namespace);\n#endif \n\t\t\t\tsoapMethods[i].methodImpl(h, soapMethods[i].methodName, namespace);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tsyslog(LOG_NOTICE, \"SoapMethod: Unknown: %.*s %s\", methodlen, p, namespace);\n\t} else {\n\t\tsyslog(LOG_NOTICE, \"cannot parse SoapAction\");\n\t}\n\tSoapError(h, 401, \"Invalid Action\");\n}", "target": 0}
{"code": "static void __init clear_bss(void)\n{\n\tmemset(__bss_start, 0,\n\t       (unsigned long) __bss_stop - (unsigned long) __bss_start);\n}", "target": 1}
{"code": "SWFInput_readSBits(SWFInput input, int number)\n{\n\tint num = SWFInput_readBits(input, number);\n\tif ( num & (1<<(number-1)) )\n\t\treturn num - (1<<number);\n\telse\n\t\treturn num;\n}", "target": 1}
{"code": "static void wait_for_child_to_die(void *ctx)\n{\n\tREQUEST *request = ctx;\n\trad_assert(request->magic == REQUEST_MAGIC);\n\tif ((request->child_state == REQUEST_QUEUED) ||\n\t    ((request->child_state == REQUEST_RUNNING) &&\n\t     (pthread_equal(request->child_pid, NO_SUCH_CHILD_PID) == 0))) {\n\t\tif (request->delay < (USEC * 60 * 5)) {\n\t\t\trequest->delay += (request->delay >> 1);\n\t\t\tradlog(L_INFO, \"WARNING: Child is hung for request %u in component %s module %s.\",\n\t\t\t       request->number, request->component, request->module);\n\t\t} else {\n\t\t\tRDEBUG2(\"Child is still stuck for request %u\",\n\t\t\t\trequest->number);\n\t\t}\n\t\ttv_add(&request->when, request->delay);\n\t\tINSERT_EVENT(wait_for_child_to_die, request);\n\t\treturn;\n\t}\n\tRDEBUG2(\"Child is finally responsive for request %u\", request->number);\n\tremove_from_request_hash(request);\n#ifdef WITH_PROXY\n\tif (request->proxy) {\n\t\twait_for_proxy_id_to_expire(request);\n\t\treturn;\n\t}\n#endif\n\tev_request_free(&request);\n}", "target": 1}
{"code": "  UpdatePersistentHostQuotaTask(\n      QuotaManager* manager,\n      const std::string& host,\n      int new_quota,\n      HostQuotaCallback* callback)\n      : DatabaseTaskBase(manager),\n        host_(host),\n        new_quota_(new_quota),\n        callback_(callback) {\n    DCHECK_GE(new_quota_, 0);\n  }", "target": 0}
{"code": "int do_truncate(struct dentry *dentry, loff_t length, unsigned int time_attrs,\n\tstruct file *filp)\n{\n\tint err;\n\tstruct iattr newattrs;\n\tif (length < 0)\n\t\treturn -EINVAL;\n\tnewattrs.ia_size = length;\n\tnewattrs.ia_valid = ATTR_SIZE | time_attrs;\n\tif (filp) {\n\t\tnewattrs.ia_file = filp;\n\t\tnewattrs.ia_valid |= ATTR_FILE;\n\t}\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\terr = notify_change(dentry, &newattrs);\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\treturn err;\n}", "target": 1}
{"code": "static int is_printable(char p)\n{\n\tif ((p >= 'a' && p <= 'z') || (p >= 'A' && p <= 'Z') ||\n\t    (p >= '0' && p <= '9') || p == ' ' || p == '(' || p == ')' ||\n\t    p == '+' || p == ',' || p == '-' || p == '.' || p == '/' ||\n\t    p == ':' || p == '=' || p == '?')\n\t\treturn 1;\n\treturn 0;\n}", "target": 0}
{"code": "gdImagePtr gdImageCreateTrueColor (int sx, int sy)\n{\n\tint i;\n\tgdImagePtr im;\n\tif (overflow2(sx, sy)) {\n\t\treturn NULL;\n\t}\n\tif (overflow2(sizeof(unsigned char *), sy)) {\n\t\treturn NULL;\n\t}\n\tif (overflow2(sizeof(int), sx)) {\n\t\treturn NULL;\n\t}\n\tim = (gdImage *) gdMalloc(sizeof(gdImage));\n\tmemset(im, 0, sizeof(gdImage));\n\tim->tpixels = (int **) gdMalloc(sizeof(int *) * sy);\n\tim->AA_opacity = (unsigned char **) gdMalloc(sizeof(unsigned char *) * sy);\n\tim->polyInts = 0;\n\tim->polyAllocated = 0;\n\tim->brush = 0;\n\tim->tile = 0;\n\tim->style = 0;\n\tfor (i = 0; i < sy; i++) {\n\t\tim->tpixels[i] = (int *) gdCalloc(sx, sizeof(int));\n\t\tim->AA_opacity[i] = (unsigned char *) gdCalloc(sx, sizeof(unsigned char));\n\t}\n\tim->sx = sx;\n\tim->sy = sy;\n\tim->transparent = (-1);\n\tim->interlace = 0;\n\tim->trueColor = 1;\n\tim->saveAlphaFlag = 0;\n\tim->alphaBlendingFlag = 1;\n\tim->thick = 1;\n\tim->AA = 0;\n\tim->AA_polygon = 0;\n\tim->cx1 = 0;\n\tim->cy1 = 0;\n\tim->cx2 = im->sx - 1;\n\tim->cy2 = im->sy - 1;\n\tim->interpolation = NULL;\n\tim->interpolation_id = GD_BILINEAR_FIXED;\n\treturn im;\n}", "target": 0}
{"code": "compat_sys_writev(unsigned long fd, const struct compat_iovec __user *vec, unsigned long vlen)\n{\n\tstruct file *file;\n\tssize_t ret = -EBADF;\n\tfile = fget(fd);\n\tif (!file)\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\tgoto out;\n\tret = -EINVAL;\n\tif (!file->f_op || (!file->f_op->aio_write && !file->f_op->write))\n\t\tgoto out;\n\tret = compat_do_readv_writev(WRITE, file, vec, vlen, &file->f_pos);\nout:\n\tfput(file);\n\treturn ret;\n}", "target": 0}
{"code": "static void write_response(ESPState *s)\n{\n    uint32_t n;\n    trace_esp_write_response(s->status);\n    fifo8_reset(&s->fifo);\n    esp_fifo_push(s, s->status);\n    esp_fifo_push(s, 0);\n    if (s->dma) {\n        if (s->dma_memory_write) {\n            s->dma_memory_write(s->dma_opaque,\n                                (uint8_t *)fifo8_pop_buf(&s->fifo, 2, &n), 2);\n            s->rregs[ESP_RSTAT] = STAT_TC | STAT_ST;\n            s->rregs[ESP_RINTR] |= INTR_BS | INTR_FC;\n            s->rregs[ESP_RSEQ] = SEQ_CD;\n        } else {\n            s->pdma_cb = write_response_pdma_cb;\n            esp_raise_drq(s);\n            return;\n        }\n    } else {\n        s->ti_size = 2;\n        s->rregs[ESP_RFLAGS] = 2;\n    }\n    esp_raise_irq(s);\n}", "target": 1}
{"code": "cib_timeout_handler(gpointer data)\n{\n    struct timer_rec_s *timer = data;\n    timer_expired = TRUE;\n    crm_err(\"Call %d timed out after %ds\", timer->call_id, timer->timeout);\n    return TRUE;\n}", "target": 1}
{"code": "inline StreamWriteResult StreamBase::Write(\n    uv_buf_t* bufs,\n    size_t count,\n    uv_stream_t* send_handle,\n    v8::Local<v8::Object> req_wrap_obj) {\n  Environment* env = stream_env();\n  int err;\n  size_t total_bytes = 0;\n  for (size_t i = 0; i < count; ++i)\n    total_bytes += bufs[i].len;\n  bytes_written_ += total_bytes;\n  if (send_handle == nullptr) {\n    err = DoTryWrite(&bufs, &count);\n    if (err != 0 || count == 0) {\n      return StreamWriteResult { false, err, nullptr, total_bytes };\n    }\n  }\n  HandleScope handle_scope(env->isolate());\n  if (req_wrap_obj.IsEmpty()) {\n    req_wrap_obj =\n        env->write_wrap_template()\n            ->NewInstance(env->context()).ToLocalChecked();\n    StreamReq::ResetObject(req_wrap_obj);\n  }\n  AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(GetAsyncWrap());\n  WriteWrap* req_wrap = CreateWriteWrap(req_wrap_obj);\n  err = DoWrite(req_wrap, bufs, count, send_handle);\n  bool async = err == 0;\n  if (!async) {\n    req_wrap->Dispose();\n    req_wrap = nullptr;\n  }\n  const char* msg = Error();\n  if (msg != nullptr) {\n    req_wrap_obj->Set(env->error_string(), OneByteString(env->isolate(), msg));\n    ClearError();\n  }\n  return StreamWriteResult { async, err, req_wrap, total_bytes };\n}", "target": 1}
{"code": "static void parse_rtcp_bye(pjmedia_rtcp_session *sess,\n\t\t\t   const void *pkt,\n\t\t\t   pj_size_t size)\n{\n    pj_str_t reason = {\"-\", 1};\n    if (size > 8) {\n\treason.slen = PJ_MIN(sizeof(sess->stat.peer_sdes_buf_),\n                             *((pj_uint8_t*)pkt+8));\n\tpj_memcpy(sess->stat.peer_sdes_buf_, ((pj_uint8_t*)pkt+9),\n\t\t  reason.slen);\n\treason.ptr = sess->stat.peer_sdes_buf_;\n    }\n    PJ_LOG(5, (sess->name, \"Received RTCP BYE, reason: %.*s\",\n\t       reason.slen, reason.ptr));\n}", "target": 1}
{"code": "static struct dump_dir *open_directory_for_modification_of_element(\n    GDBusMethodInvocation *invocation,\n    uid_t caller_uid,\n    const char *problem_id,\n    const char *element)\n{\n    static const char *const protected_elements[] = {\n        FILENAME_TIME,\n        FILENAME_UID,\n        NULL,\n    };\n    for (const char *const *protected = protected_elements; *protected; ++protected)\n    {\n        if (strcmp(*protected, element) == 0)\n        {\n            log_notice(\"'%s' element of '%s' can't be modified\", element, problem_id);\n            char *error = xasprintf(_(\"'%s' element can't be modified\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                        \"org.freedesktop.problems.ProtectedElement\",\n                                        error);\n            free(error);\n            return NULL;\n        }\n    }\n    if (!dump_dir_accessible_by_uid(problem_id, caller_uid))\n    {\n        if (errno == ENOTDIR)\n        {\n            log_notice(\"'%s' is not a valid problem directory\", problem_id);\n            return_InvalidProblemDir_error(invocation, problem_id);\n        }\n        else\n        {\n            log_notice(\"UID(%d) is not Authorized to access '%s'\", caller_uid, problem_id);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                \"org.freedesktop.problems.AuthFailure\",\n                                _(\"Not Authorized\"));\n        }\n        return NULL;\n    }\n    struct dump_dir *dd = dd_opendir(problem_id,  0);\n    if (!dd)\n    {   \n        log_notice(\"Can't access the problem '%s' for modification\", problem_id);\n        g_dbus_method_invocation_return_dbus_error(invocation,\n                                \"org.freedesktop.problems.Failure\",\n                                _(\"Can't access the problem for modification\"));\n        return NULL;\n    }\n    return dd;\n}", "target": 1}
{"code": "static void ClearMetadata(VP8LMetadata* const hdr) {\n  assert(hdr != NULL);\n  WebPSafeFree(hdr->huffman_image_);\n  WebPSafeFree(hdr->huffman_tables_);\n  VP8LHtreeGroupsFree(hdr->htree_groups_);\n  VP8LColorCacheClear(&hdr->color_cache_);\n  VP8LColorCacheClear(&hdr->saved_color_cache_);\n  InitMetadata(hdr);\n}", "target": 1}
{"code": "static inline void fsnotify_oldname_free(const unsigned char *old_name)\n{\n\tkfree(old_name);\n}", "target": 1}
{"code": "void LinkInfo::print() {\n  ResourceMark rm;\n  tty->print_cr(\"Link resolved_klass=%s name=%s signature=%s current_klass=%s check_access=%s check_loader_constraints=%s\",\n                _resolved_klass->name()->as_C_string(),\n                _name->as_C_string(),\n                _signature->as_C_string(),\n                _current_klass == NULL ? \"(none)\" : _current_klass->name()->as_C_string(),\n                _check_access ? \"true\" : \"false\",\n                _check_loader_constraints ? \"true\" : \"false\");\n}", "target": 0}
{"code": "static int netbk_count_requests(struct xenvif *vif,\n\t\t\t\tstruct xen_netif_tx_request *first,\n\t\t\t\tstruct xen_netif_tx_request *txp,\n\t\t\t\tint work_to_do)\n{\n\tRING_IDX cons = vif->tx.req_cons;\n\tint frags = 0;\n\tif (!(first->flags & XEN_NETTXF_more_data))\n\t\treturn 0;\n\tdo {\n\t\tif (frags >= work_to_do) {\n\t\t\tnetdev_dbg(vif->dev, \"Need more frags\\n\");\n\t\t\treturn -frags;\n\t\t}\n\t\tif (unlikely(frags >= MAX_SKB_FRAGS)) {\n\t\t\tnetdev_dbg(vif->dev, \"Too many frags\\n\");\n\t\t\treturn -frags;\n\t\t}\n\t\tmemcpy(txp, RING_GET_REQUEST(&vif->tx, cons + frags),\n\t\t       sizeof(*txp));\n\t\tif (txp->size > first->size) {\n\t\t\tnetdev_dbg(vif->dev, \"Frags galore\\n\");\n\t\t\treturn -frags;\n\t\t}\n\t\tfirst->size -= txp->size;\n\t\tfrags++;\n\t\tif (unlikely((txp->offset + txp->size) > PAGE_SIZE)) {\n\t\t\tnetdev_dbg(vif->dev, \"txp->offset: %x, size: %u\\n\",\n\t\t\t\t txp->offset, txp->size);\n\t\t\treturn -frags;\n\t\t}\n\t} while ((txp++)->flags & XEN_NETTXF_more_data);\n\treturn frags;\n}", "target": 1}
{"code": "void WebURLLoaderImpl::Context::OnReceivedResponse(\n    const ResourceResponseInfo& info) {\n  if (!client_)\n    return;\n  WebURLResponse response;\n  response.initialize();\n  PopulateURLResponse(request_.url(), info, &response);\n  bool show_raw_listing = (GURL(request_.url()).query() == \"raw\");\n  if (info.mime_type == \"text/vnd.chromium.ftp-dir\") {\n    if (show_raw_listing) {\n      response.setMIMEType(\"text/plain\");\n    } else {\n      response.setMIMEType(\"text/html\");\n     }\n   }\n   client_->didReceiveResponse(loader_, response);\n  if (!client_)\n    return;\n  DCHECK(!ftp_listing_delegate_.get());\n  DCHECK(!multipart_delegate_.get());\n  if (info.headers && info.mime_type == \"multipart/x-mixed-replace\") {\n    std::string content_type;\n    info.headers->EnumerateHeader(NULL, \"content-type\", &content_type);\n    std::string mime_type;\n    std::string charset;\n    bool had_charset = false;\n    std::string boundary;\n    net::HttpUtil::ParseContentType(content_type, &mime_type, &charset,\n                                    &had_charset, &boundary);\n    TrimString(boundary, \" \\\"\", &boundary);\n    if (!boundary.empty()) {\n      multipart_delegate_.reset(\n          new MultipartResponseDelegate(client_, loader_, response, boundary));\n    }\n  } else if (info.mime_type == \"text/vnd.chromium.ftp-dir\" &&\n             !show_raw_listing) {\n    ftp_listing_delegate_.reset(\n        new FtpDirectoryListingResponseDelegate(client_, loader_, response));\n  }\n}", "target": 1}
{"code": "pci_emul_add_msicap(struct pci_vdev *dev, int msgnum)\n{\n\tstruct msicap msicap;\n\tpci_populate_msicap(&msicap, msgnum, 0);\n\treturn pci_emul_add_capability(dev, (u_char *)&msicap, sizeof(msicap));\n}", "target": 1}
{"code": "mm_zfree(struct mm_master *mm, void *address)\n{\n\tmm_free(mm, address);\n}", "target": 1}
{"code": "long pipe_fcntl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct pipe_inode_info *pipe;\n\tlong ret;\n\tpipe = get_pipe_info(file);\n\tif (!pipe)\n\t\treturn -EBADF;\n\t__pipe_lock(pipe);\n\tswitch (cmd) {\n\tcase F_SETPIPE_SZ: {\n\t\tunsigned int size, nr_pages;\n\t\tsize = round_pipe_size(arg);\n\t\tnr_pages = size >> PAGE_SHIFT;\n\t\tret = -EINVAL;\n\t\tif (!nr_pages)\n\t\t\tgoto out;\n\t\tif (!capable(CAP_SYS_RESOURCE) && size > pipe_max_size) {\n\t\t\tret = -EPERM;\n\t\t\tgoto out;\n\t\t} else if ((too_many_pipe_buffers_hard(pipe->user) ||\n\t\t\t    too_many_pipe_buffers_soft(pipe->user)) &&\n\t\t           !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = pipe_set_size(pipe, nr_pages);\n\t\tbreak;\n\t\t}\n\tcase F_GETPIPE_SZ:\n\t\tret = pipe->buffers * PAGE_SIZE;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\nout:\n\t__pipe_unlock(pipe);\n\treturn ret;\n}", "target": 0}
{"code": "    void RafImage::setIptcData(const IptcData& )\n    {\n        throw(Error(kerInvalidSettingForImage, \"IPTC metadata\", \"RAF\"));\n    }", "target": 0}
{"code": "int verify_compat_iovec(struct msghdr *kern_msg, struct iovec *kern_iov,\n\t\t   struct sockaddr_storage *kern_address, int mode)\n{\n\tint tot_len;\n\tif (kern_msg->msg_namelen) {\n\t\tif (mode == VERIFY_READ) {\n\t\t\tint err = move_addr_to_kernel(kern_msg->msg_name,\n\t\t\t\t\t\t      kern_msg->msg_namelen,\n\t\t\t\t\t\t      kern_address);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tkern_msg->msg_name = kern_address;\n\t} else\n\t\tkern_msg->msg_name = NULL;\n\ttot_len = iov_from_user_compat_to_kern(kern_iov,\n\t\t\t\t\t  (struct compat_iovec __user *)kern_msg->msg_iov,\n\t\t\t\t\t  kern_msg->msg_iovlen);\n\tif (tot_len >= 0)\n\t\tkern_msg->msg_iov = kern_iov;\n\treturn tot_len;\n}", "target": 1}
{"code": "static char *get_header(FILE *fp)\n{\n    long start;\n    char *header;\n    header = calloc(1, 1024);\n    start = ftell(fp);\n    fseek(fp, 0, SEEK_SET);\n    SAFE_E(fread(header, 1, 1023, fp), 1023, \"Failed to load PDF header.\\n\");\n    fseek(fp, start, SEEK_SET);\n    return header;\n}", "target": 1}
{"code": "static unsigned char mincore_page(struct address_space *mapping, pgoff_t pgoff)\n{\n\tunsigned char present = 0;\n\tstruct page *page;\n#ifdef CONFIG_SWAP\n\tif (shmem_mapping(mapping)) {\n\t\tpage = find_get_entry(mapping, pgoff);\n\t\tif (xa_is_value(page)) {\n\t\t\tswp_entry_t swp = radix_to_swp_entry(page);\n\t\t\tpage = find_get_page(swap_address_space(swp),\n\t\t\t\t\t     swp_offset(swp));\n\t\t}\n\t} else\n\t\tpage = find_get_page(mapping, pgoff);\n#else\n\tpage = find_get_page(mapping, pgoff);\n#endif\n\tif (page) {\n\t\tpresent = PageUptodate(page);\n\t\tput_page(page);\n\t}\n\treturn present;\n}", "target": 1}
{"code": "vhost_user_check_and_alloc_queue_pair(struct virtio_net *dev,\n\t\t\tstruct VhostUserMsg *msg)\n{\n\tuint16_t vring_idx;\n\tswitch (msg->request.master) {\n\tcase VHOST_USER_SET_VRING_KICK:\n\tcase VHOST_USER_SET_VRING_CALL:\n\tcase VHOST_USER_SET_VRING_ERR:\n\t\tvring_idx = msg->payload.u64 & VHOST_USER_VRING_IDX_MASK;\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_NUM:\n\tcase VHOST_USER_SET_VRING_BASE:\n\tcase VHOST_USER_SET_VRING_ENABLE:\n\t\tvring_idx = msg->payload.state.index;\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_ADDR:\n\t\tvring_idx = msg->payload.addr.index;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tif (vring_idx >= VHOST_MAX_VRING) {\n\t\tVHOST_LOG_CONFIG(ERR,\n\t\t\t\"invalid vring index: %u\\n\", vring_idx);\n\t\treturn -1;\n\t}\n\tif (dev->virtqueue[vring_idx])\n\t\treturn 0;\n\treturn alloc_vring_queue(dev, vring_idx);\n}", "target": 1}
{"code": "static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)\n{\n    long i;\n    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {\n        long a = *(long *)(src1 + i);\n        long b = *(long *)(src2 + i);\n        *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);\n    }\n    for (; i < w; i++)\n        dst[i] = src1[i] + src2[i];\n}", "target": 1}
{"code": "static int snd_timer_start1(struct snd_timer_instance *timeri,\n\t\t\t    bool start, unsigned long ticks)\n{\n\tstruct snd_timer *timer;\n\tint result;\n\tunsigned long flags;\n\ttimer = timeri->timer;\n\tif (!timer)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&timer->lock, flags);\n\tif (timer->card && timer->card->shutdown) {\n\t\tresult = -ENODEV;\n\t\tgoto unlock;\n\t}\n\tif (timeri->flags & (SNDRV_TIMER_IFLG_RUNNING |\n\t\t\t     SNDRV_TIMER_IFLG_START)) {\n\t\tresult = -EBUSY;\n\t\tgoto unlock;\n\t}\n\tif (start)\n\t\ttimeri->ticks = timeri->cticks = ticks;\n\telse if (!timeri->cticks)\n\t\ttimeri->cticks = 1;\n\ttimeri->pticks = 0;\n\tlist_move_tail(&timeri->active_list, &timer->active_list_head);\n\tif (timer->running) {\n\t\tif (timer->hw.flags & SNDRV_TIMER_HW_SLAVE)\n\t\t\tgoto __start_now;\n\t\ttimer->flags |= SNDRV_TIMER_FLG_RESCHED;\n\t\ttimeri->flags |= SNDRV_TIMER_IFLG_START;\n\t\tresult = 1; \n\t} else {\n\t\tif (start)\n\t\t\ttimer->sticks = ticks;\n\t\ttimer->hw.start(timer);\n\t      __start_now:\n\t\ttimer->running++;\n\t\ttimeri->flags |= SNDRV_TIMER_IFLG_RUNNING;\n\t\tresult = 0;\n\t}\n\tsnd_timer_notify1(timeri, start ? SNDRV_TIMER_EVENT_START :\n\t\t\t  SNDRV_TIMER_EVENT_CONTINUE);\n unlock:\n\tspin_unlock_irqrestore(&timer->lock, flags);\n\treturn result;\n}", "target": 0}
{"code": "static const char *typeString(ut32 n, int *bits) {\n\t*bits = 32;\n\tif (n == 12) { \n\t\treturn \"arm\";\n\t}\n\tif (n == 0x0100000c) { \n\t\t*bits = 64;\n\t\treturn \"arm\";\n\t}\n\tif (n == 0x0200000c) { \n\t\t*bits = 64;\n\t\treturn \"arm\";\n\t}\n\treturn \"x86\";\n}", "target": 0}
{"code": "static int xfrm6_tunnel_rcv(struct sk_buff *skb)\n{\n\tstruct ipv6hdr *iph = ipv6_hdr(skb);\n\t__be32 spi;\n\tspi = xfrm6_tunnel_spi_lookup((xfrm_address_t *)&iph->saddr);\n\treturn xfrm6_rcv_spi(skb, spi);\n}", "target": 1}
{"code": "MagickExport void RemoveDuplicateLayers(Image **images,\n     ExceptionInfo *exception)\n{\n  register Image\n    *curr,\n    *next;\n  RectangleInfo\n    bounds;\n  assert((*images) != (const Image *) NULL);\n  assert((*images)->signature == MagickCoreSignature);\n  if ((*images)->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",(*images)->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  curr=GetFirstImageInList(*images);\n  for (; (next=GetNextImageInList(curr)) != (Image *) NULL; curr=next)\n  {\n    if ( curr->columns != next->columns || curr->rows != next->rows\n         || curr->page.x != next->page.x || curr->page.y != next->page.y )\n      continue;\n    bounds=CompareImagesBounds(curr,next,CompareAnyLayer,exception);\n    if ( bounds.x < 0 ) {\n      size_t time;\n      time = curr->delay*1000/curr->ticks_per_second;\n      time += next->delay*1000/next->ticks_per_second;\n      next->ticks_per_second = 100L;\n      next->delay = time*curr->ticks_per_second/1000;\n      next->iterations = curr->iterations;\n      *images = curr;\n      (void) DeleteImageFromList(images);\n    }\n  }\n  *images = GetFirstImageInList(*images);\n}", "target": 1}
{"code": "int LibarchivePlugin::extractionFlags() const\n{\n    int result = ARCHIVE_EXTRACT_TIME;\n    result |= ARCHIVE_EXTRACT_SECURE_NODOTDOT;\n    return result;\n}", "target": 1}
{"code": "static int nft_set_desc_concat_parse(const struct nlattr *attr,\n\t\t\t\t     struct nft_set_desc *desc)\n{\n\tstruct nlattr *tb[NFTA_SET_FIELD_MAX + 1];\n\tu32 len;\n\tint err;\n\terr = nla_parse_nested_deprecated(tb, NFTA_SET_FIELD_MAX, attr,\n\t\t\t\t\t  nft_concat_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\tif (!tb[NFTA_SET_FIELD_LEN])\n\t\treturn -EINVAL;\n\tlen = ntohl(nla_get_be32(tb[NFTA_SET_FIELD_LEN]));\n\tif (len * BITS_PER_BYTE / 32 > NFT_REG32_COUNT)\n\t\treturn -E2BIG;\n\tdesc->field_len[desc->field_count++] = len;\n\treturn 0;\n}", "target": 1}
{"code": "NOEXPORT int parse_socket_error(CLI *c, const char *text) {\n    switch(get_last_socket_error()) {\n    case 0: \n#ifndef USE_WIN32\n    case EPIPE: \n#endif\n    case S_ECONNABORTED:\n        s_log(LOG_INFO, \"%s: Socket is closed\", text);\n        return 0;\n    case S_EINTR:\n        s_log(LOG_DEBUG, \"%s: Interrupted by a signal: retrying\", text);\n        return 1;\n    case S_EWOULDBLOCK:\n        s_log(LOG_NOTICE, \"%s: Would block: retrying\", text);\n        s_poll_sleep(1, 0); \n        return 1;\n#if S_EAGAIN!=S_EWOULDBLOCK\n    case S_EAGAIN:\n        s_log(LOG_DEBUG,\n            \"%s: Temporary lack of resources: retrying\", text);\n        return 1;\n#endif\n#ifdef USE_WIN32\n    case S_ECONNRESET:\n        if(c->opt->exec_name) {\n            s_log(LOG_INFO, \"%s: Socket is closed (exec)\", text);\n            return 0;\n        }\n#endif\n    default:\n        sockerror(text);\n        throw_exception(c, 1);\n        return -1; \n    }\n}", "target": 1}
{"code": "    bool IsOpened() {return hFile!=FILE_BAD_HANDLE;};", "target": 1}
{"code": "int rm_rf_children(\n                int fd,\n                RemoveFlags flags,\n                const struct stat *root_dev) {\n        _cleanup_closedir_ DIR *d = NULL;\n        int ret = 0, r;\n        assert(fd >= 0);\n        d = fdopendir(fd);\n        if (!d) {\n                safe_close(fd);\n                return -errno;\n        }\n        if (!(flags & REMOVE_PHYSICAL)) {\n                struct statfs sfs;\n                if (fstatfs(dirfd(d), &sfs) < 0)\n                        return -errno;\n                if (is_physical_fs(&sfs)) {\n                        _cleanup_free_ char *path = NULL;\n                        (void) fd_get_path(fd, &path);\n                        return log_error_errno(SYNTHETIC_ERRNO(EPERM),\n                                               \"Attempted to remove disk file system under \\\"%s\\\", and we can't allow that.\",\n                                               strna(path));\n                }\n        }\n        FOREACH_DIRENT_ALL(de, d, return -errno) {\n                int is_dir;\n                if (dot_or_dot_dot(de->d_name))\n                        continue;\n                is_dir =\n                        de->d_type == DT_UNKNOWN ? -1 :\n                        de->d_type == DT_DIR;\n                r = rm_rf_children_inner(dirfd(d), de->d_name, is_dir, flags, root_dev);\n                if (r < 0 && r != -ENOENT && ret == 0)\n                        ret = r;\n        }\n        if (FLAGS_SET(flags, REMOVE_SYNCFS) && syncfs(dirfd(d)) < 0 && ret >= 0)\n                ret = -errno;\n        return ret;\n}", "target": 1}
{"code": "static void ncq_err(NCQTransferState *ncq_tfs)\n{\n    IDEState *ide_state = &ncq_tfs->drive->port.ifs[0];\n     ide_state->error = ABRT_ERR;\n     ide_state->status = READY_STAT | ERR_STAT;\n     ncq_tfs->drive->port_regs.scr_err |= (1 << ncq_tfs->tag);\n    ncq_tfs->used = 0;\n }", "target": 0}
{"code": "process_request_identities(SocketEntry *e)\n{\n\tIdentity *id;\n\tstruct sshbuf *msg, *keys;\n\tint r;\n\tu_int nentries = 0;\n\tdebug2_f(\"entering\");\n\tif ((msg = sshbuf_new()) == NULL || (keys = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tTAILQ_FOREACH(id, &idtab->idlist, next) {\n\t\tif (identity_permitted(id, e, NULL, NULL, NULL) != 0)\n\t\t\tcontinue;\n\t\tif ((r = sshkey_puts_opts(id->key, keys,\n\t\t    SSHKEY_SERIALIZE_INFO)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(keys, id->comment)) != 0) {\n\t\t\terror_fr(r, \"compose key/comment\");\n\t\t\tcontinue;\n\t\t}\n\t\tnentries++;\n\t}\n\tdebug2_f(\"replying with %u allowed of %u available keys\",\n\t    nentries, idtab->nentries);\n\tif ((r = sshbuf_put_u8(msg, SSH2_AGENT_IDENTITIES_ANSWER)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, nentries)) != 0 ||\n\t    (r = sshbuf_putb(msg, keys)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\tif ((r = sshbuf_put_stringb(e->output, msg)) != 0)\n\t\tfatal_fr(r, \"enqueue\");\n\tsshbuf_free(msg);\n\tsshbuf_free(keys);\n}", "target": 1}
{"code": "void Context::onUpstreamConnectionClose(PeerType peer_type) {\n  if (wasm_->onUpstreamConnectionClose_) {\n    wasm_->onUpstreamConnectionClose_(this, id_, static_cast<uint32_t>(peer_type));\n  }\n}", "target": 1}
{"code": "int ping_init_sock(struct sock *sk)\n{\n\tstruct net *net = sock_net(sk);\n\tkgid_t group = current_egid();\n\tstruct group_info *group_info;\n\tint i, j, count;\n\tkgid_t low, high;\n\tint ret = 0;\n\tinet_get_ping_group_range_net(net, &low, &high);\n\tif (gid_lte(low, group) && gid_lte(group, high))\n\t\treturn 0;\n\tgroup_info = get_current_groups();\n\tcount = group_info->ngroups;\n\tfor (i = 0; i < group_info->nblocks; i++) {\n\t\tint cp_count = min_t(int, NGROUPS_PER_BLOCK, count);\n\t\tfor (j = 0; j < cp_count; j++) {\n\t\t\tkgid_t gid = group_info->blocks[i][j];\n\t\t\tif (gid_lte(low, gid) && gid_lte(gid, high))\n\t\t\t\tgoto out_release_group;\n\t\t}\n\t\tcount -= cp_count;\n\t}\n\tret = -EACCES;\nout_release_group:\n\tput_group_info(group_info);\n\treturn ret;\n}", "target": 0}
{"code": "static void n_tty_close(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tif (tty->link)\n\t\tn_tty_packet_mode_flush(tty);\n\tvfree(ldata);\n\ttty->disc_data = NULL;\n}", "target": 0}
{"code": "bool Monitor::ms_verify_authorizer(Connection *con, int peer_type,\n\t\t\t\t   int protocol, bufferlist& authorizer_data,\n\t\t\t\t   bufferlist& authorizer_reply,\n\t\t\t\t   bool& isvalid, CryptoKey& session_key)\n{\n  dout(10) << \"ms_verify_authorizer \" << con->get_peer_addr()\n\t   << \" \" << ceph_entity_type_name(peer_type)\n\t   << \" protocol \" << protocol << dendl;\n  if (is_shutdown())\n    return false;\n  if (peer_type == CEPH_ENTITY_TYPE_MON &&\n      auth_cluster_required.is_supported_auth(CEPH_AUTH_CEPHX)) {\n    isvalid = false;\n    if (protocol == CEPH_AUTH_CEPHX) {\n      bufferlist::iterator iter = authorizer_data.begin();\n      CephXServiceTicketInfo auth_ticket_info;\n      if (authorizer_data.length()) {\n\tbool ret = cephx_verify_authorizer(g_ceph_context, &keyring, iter,\n\t\t\t\t\t  auth_ticket_info, authorizer_reply);\n\tif (ret) {\n\t  session_key = auth_ticket_info.session_key;\n\t  isvalid = true;\n\t} else {\n\t  dout(0) << \"ms_verify_authorizer bad authorizer from mon \" << con->get_peer_addr() << dendl;\n        }\n      }\n    } else {\n      dout(0) << \"ms_verify_authorizer cephx enabled, but no authorizer (required for mon)\" << dendl;\n    }\n  } else {\n    isvalid = true;\n  }\n  return true;\n}", "target": 1}
{"code": "    GopherStateData(FwdState *aFwd) :\n        entry(aFwd->entry),\n        conversion(NORMAL),\n        HTML_header_added(0),\n        HTML_pre(0),\n        type_id(GOPHER_FILE ),\n        overflowed(false),\n        cso_recno(0),\n        len(0),\n        buf(nullptr),\n        fwd(aFwd)\n    {\n        *request = 0;\n        buf = (char *)memAllocate(MEM_4K_BUF);\n        entry->lock(\"gopherState\");\n        *replybuf = 0;\n    }", "target": 1}
{"code": "__acquires(bitlock)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tif (unlikely(ext4_forced_shutdown(EXT4_SB(sb))))\n\t\treturn;\n\ttrace_ext4_error(sb, function, line);\n\tes->s_last_error_ino = cpu_to_le32(ino);\n\tes->s_last_error_block = cpu_to_le64(block);\n\t__save_error_info(sb, function, line);\n\tif (ext4_error_ratelimit(sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: group %u, \",\n\t\t       sb->s_id, function, line, grp);\n\t\tif (ino)\n\t\t\tprintk(KERN_CONT \"inode %lu: \", ino);\n\t\tif (block)\n\t\t\tprintk(KERN_CONT \"block %llu:\",\n\t\t\t       (unsigned long long) block);\n\t\tprintk(KERN_CONT \"%pV\\n\", &vaf);\n\t\tva_end(args);\n\t}\n\tif (test_opt(sb, ERRORS_CONT)) {\n\t\text4_commit_super(sb, 0);\n\t\treturn;\n\t}\n\text4_unlock_group(sb, grp);\n\text4_commit_super(sb, 1);\n\text4_handle_error(sb);\n\text4_lock_group(sb, grp);\n\treturn;\n}", "target": 0}
{"code": "allocateSpaceInTable (FileInfo * nested, TranslationTableOffset * offset,\n\t\t      int count)\n{\n  int spaceNeeded = ((count + OFFSETSIZE - 1) / OFFSETSIZE) * OFFSETSIZE;\n  TranslationTableOffset size = tableUsed + spaceNeeded;\n  if (size > tableSize)\n    {\n      void *newTable;\n      size += (size / OFFSETSIZE);\n      newTable = realloc (table, size);\n      if (!newTable)\n\t{\n\t  compileError (nested, \"Not enough memory for translation table.\");\n\t  outOfMemory ();\n\t}\n      memset (((unsigned char *) newTable) + tableSize, 0, size - tableSize);\n      {\n\tChainEntry *entry;\n\tfor (entry = tableChain; entry != NULL; entry = entry->next)\n\t  if (entry->table == table)\n\t    entry->table = (TranslationTableHeader *) newTable;\n      }\n      table = (TranslationTableHeader *) newTable;\n      tableSize = size;\n    }\n  if (offset != NULL)\n    {\n      *offset = (tableUsed - sizeof (*table)) / OFFSETSIZE;\n      tableUsed += spaceNeeded;\n    }\n  return 1;\n}", "target": 0}
{"code": "static int __ptrace_may_access(struct task_struct *task, unsigned int mode)\n{\n\tconst struct cred *cred = current_cred(), *tcred;\n\tint dumpable = 0;\n\tif (same_thread_group(task, current))\n\t\treturn 0;\n\trcu_read_lock();\n\ttcred = __task_cred(task);\n\tif (uid_eq(cred->uid, tcred->euid) &&\n\t    uid_eq(cred->uid, tcred->suid) &&\n\t    uid_eq(cred->uid, tcred->uid)  &&\n\t    gid_eq(cred->gid, tcred->egid) &&\n\t    gid_eq(cred->gid, tcred->sgid) &&\n\t    gid_eq(cred->gid, tcred->gid))\n\t\tgoto ok;\n\tif (ptrace_has_cap(tcred->user_ns, mode))\n\t\tgoto ok;\n\trcu_read_unlock();\n\treturn -EPERM;\nok:\n\trcu_read_unlock();\n\tsmp_rmb();\n\tif (task->mm)\n\t\tdumpable = get_dumpable(task->mm);\n\trcu_read_lock();\n\tif (!dumpable && !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {\n\t\trcu_read_unlock();\n\t\treturn -EPERM;\n\t}\n\trcu_read_unlock();\n\treturn security_ptrace_access_check(task, mode);\n}", "target": 1}
{"code": "static inline void kvm_memslot_delete(struct kvm_memslots *slots,\n\t\t\t\t      struct kvm_memory_slot *memslot)\n{\n\tstruct kvm_memory_slot *mslots = slots->memslots;\n\tint i;\n\tif (WARN_ON(slots->id_to_index[memslot->id] == -1))\n\t\treturn;\n\tslots->used_slots--;\n\tfor (i = slots->id_to_index[memslot->id]; i < slots->used_slots; i++) {\n\t\tmslots[i] = mslots[i + 1];\n\t\tslots->id_to_index[mslots[i].id] = i;\n\t}\n\tmslots[i] = *memslot;\n\tslots->id_to_index[memslot->id] = -1;\n}", "target": 1}
{"code": "sysDescr_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  snmp_api_set_string(varbind, oid, CONTIKI_VERSION_STRING);\n}", "target": 1}
{"code": "static pj_status_t STATUS_FROM_SSL_ERR2(char *action, pj_ssl_sock_t *ssock,\n\t\t\t\t\tint ret, int err, int len)\n{\n    unsigned long ssl_err = err;\n    if (err == SSL_ERROR_SSL) {\n\tssl_err = ERR_peek_error();\n    }\n    SSLLogErrors(action, ret, err, len, ssock);\n    ssock->last_err = ssl_err;\n    return GET_STATUS_FROM_SSL_ERR(ssl_err);\n}", "target": 1}
{"code": "GF_Err dinf_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e = gf_isom_box_array_read(s, bs, dinf_AddBox);\n\tif (e) {\n\t\treturn e;\n\t}\n\tif (!((GF_DataInformationBox *)s)->dref) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing dref box in dinf\\n\"));\n\t\t((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "int kvm_read_guest_page(struct kvm *kvm, gfn_t gfn, void *data, int offset,\n\t\t\tint len)\n{\n\tint r;\n\tunsigned long addr;\n\taddr = gfn_to_hva(kvm, gfn);\n\tif (kvm_is_error_hva(addr))\n\t\treturn -EFAULT;\n\tr = copy_from_user(data, (void __user *)addr + offset, len);\n\tif (r)\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1}
{"code": "yang_read_length(struct ly_ctx *ctx, struct yang_type *stype, char *value, int is_ext_instance)\n{\n    struct lys_restr *length;\n    if (is_ext_instance) {\n        length = (struct lys_restr *)stype;\n    } else {\n        if (stype->base == 0 || stype->base == LY_TYPE_STRING) {\n            stype->base = LY_TYPE_STRING;\n        } else {\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Unexpected length statement.\");\n            goto error;\n        }\n        if (stype->type->info.str.length) {\n            LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"length\", \"type\");\n            goto error;\n        }\n        length = calloc(1, sizeof *length);\n        LY_CHECK_ERR_GOTO(!length, LOGMEM(ctx), error);\n        stype->type->info.str.length = length;\n    }\n    length->expr = lydict_insert_zc(ctx, value);\n    return length;\nerror:\n    free(value);\n    return NULL;\n}", "target": 0}
{"code": "static inline void map_to_unicode(unsigned code, const enc_to_uni *table, unsigned *res)\n{\n\t*res = table->inner[ENT_ENC_TO_UNI_STAGE1(code)]->uni_cp[ENT_ENC_TO_UNI_STAGE2(code)];\n}", "target": 0}
{"code": "void rose_start_t1timer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\tdel_timer(&rose->timer);\n\trose->timer.function = rose_timer_expiry;\n\trose->timer.expires  = jiffies + rose->t1;\n\tadd_timer(&rose->timer);\n}", "target": 1}
{"code": "cr_input_read_byte (CRInput * a_this, guchar * a_byte)\n{\n        g_return_val_if_fail (a_this && PRIVATE (a_this)\n                              && a_byte, CR_BAD_PARAM_ERROR);\n        g_return_val_if_fail (PRIVATE (a_this)->next_byte_index <=\n                              PRIVATE (a_this)->nb_bytes, CR_BAD_PARAM_ERROR);\n        if (PRIVATE (a_this)->end_of_input == TRUE)\n                return CR_END_OF_INPUT_ERROR;\n        *a_byte = PRIVATE (a_this)->in_buf[PRIVATE (a_this)->next_byte_index];\n        if (PRIVATE (a_this)->nb_bytes -\n            PRIVATE (a_this)->next_byte_index < 2) {\n                PRIVATE (a_this)->end_of_input = TRUE;\n        } else {\n                PRIVATE (a_this)->next_byte_index++;\n        }\n        return CR_OK;\n}", "target": 1}
{"code": "static int legacy_get_tree(struct fs_context *fc)\n{\n\tstruct legacy_fs_context *ctx = fc->fs_private;\n\tstruct super_block *sb;\n\tstruct dentry *root;\n\troot = fc->fs_type->mount(fc->fs_type, fc->sb_flags,\n\t\t\t\t      fc->source, ctx->legacy_data);\n\tif (IS_ERR(root))\n\t\treturn PTR_ERR(root);\n\tsb = root->d_sb;\n\tBUG_ON(!sb);\n\tfc->root = root;\n\treturn 0;\n}", "target": 0}
{"code": "ossl_cipher_update(int argc, VALUE *argv, VALUE self)\n{\n    EVP_CIPHER_CTX *ctx;\n    unsigned char *in;\n    long in_len, out_len;\n    VALUE data, str;\n    rb_scan_args(argc, argv, \"11\", &data, &str);\n    if (!RTEST(rb_attr_get(self, id_key_set)))\n\tossl_raise(eCipherError, \"key not set\");\n    StringValue(data);\n    in = (unsigned char *)RSTRING_PTR(data);\n    if ((in_len = RSTRING_LEN(data)) == 0)\n        ossl_raise(rb_eArgError, \"data must not be empty\");\n    GetCipher(self, ctx);\n    out_len = in_len+EVP_CIPHER_CTX_block_size(ctx);\n    if (out_len <= 0) {\n\tossl_raise(rb_eRangeError,\n\t\t   \"data too big to make output buffer: %ld bytes\", in_len);\n    }\n    if (NIL_P(str)) {\n        str = rb_str_new(0, out_len);\n    } else {\n        StringValue(str);\n        rb_str_resize(str, out_len);\n    }\n    if (!ossl_cipher_update_long(ctx, (unsigned char *)RSTRING_PTR(str), &out_len, in, in_len))\n\tossl_raise(eCipherError, NULL);\n    assert(out_len < RSTRING_LEN(str));\n    rb_str_set_len(str, out_len);\n    return str;\n}", "target": 0}
{"code": "void SetClipboardText(const char *text)\n{\n#if defined(PLATFORM_DESKTOP)\n    glfwSetClipboardString(CORE.Window.handle, text);\n#endif\n#if defined(PLATFORM_WEB)\n    emscripten_run_script(TextFormat(\"navigator.clipboard.writeText('%s')\", text));\n#endif\n}", "target": 1}
{"code": "void HeaderUtility::stripPortFromHost(RequestHeaderMap& headers, uint32_t listener_port) {\n  if (headers.getMethodValue() == Http::Headers::get().MethodValues.Connect) {\n    return;\n  }\n  const absl::string_view original_host = headers.getHostValue();\n  const absl::string_view::size_type port_start = original_host.rfind(':');\n  if (port_start == absl::string_view::npos) {\n    return;\n  }\n  const auto v6_end_index = original_host.rfind(\"]\");\n  if (v6_end_index == absl::string_view::npos || v6_end_index < port_start) {\n    if ((port_start + 1) > original_host.size()) {\n      return;\n    }\n    const absl::string_view port_str = original_host.substr(port_start + 1);\n    uint32_t port = 0;\n    if (!absl::SimpleAtoi(port_str, &port)) {\n      return;\n    }\n    if (port != listener_port) {\n      return;\n    }\n    const absl::string_view host = original_host.substr(0, port_start);\n    headers.setHost(host);\n  }\n}", "target": 0}
{"code": "static int mpeg4_update_thread_context(AVCodecContext *dst,\n                                       const AVCodecContext *src)\n{\n    Mpeg4DecContext *s = dst->priv_data;\n    const Mpeg4DecContext *s1 = src->priv_data;\n    int ret = ff_mpeg_update_thread_context(dst, src);\n    if (ret < 0)\n        return ret;\n    memcpy(((uint8_t*)s) + sizeof(MpegEncContext), ((uint8_t*)s1) + sizeof(MpegEncContext), sizeof(Mpeg4DecContext) - sizeof(MpegEncContext));\n    return 0;\n}", "target": 0}
{"code": "int recursive_destroy(char *dirname)\n{\n\tint ret;\n\tstruct dirent *direntp;\n\tDIR *dir;\n\tint r = 0;\n\tdir = opendir(dirname);\n\tif (!dir)\n\t\treturn -1;\n\twhile ((direntp = readdir(dir))) {\n\t\tchar *pathname;\n\t\tstruct stat mystat;\n\t\tif (!strcmp(direntp->d_name, \".\") ||\n\t\t    !strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\t\tpathname = must_make_path(dirname, direntp->d_name, NULL);\n\t\tret = lstat(pathname, &mystat);\n\t\tif (ret < 0) {\n\t\t\tif (!r)\n\t\t\t\tWARN(\"Failed to stat \\\"%s\\\"\", pathname);\n\t\t\tr = -1;\n\t\t\tgoto next;\n\t\t}\n\t\tif (!S_ISDIR(mystat.st_mode))\n\t\t\tgoto next;\n\t\tret = recursive_destroy(pathname);\n\t\tif (ret < 0)\n\t\t\tr = -1;\n\tnext:\n\t\tfree(pathname);\n\t}\n\tret = rmdir(dirname);\n\tif (ret < 0) {\n\t\tif (!r)\n\t\t\tSYSWARN(\"Failed to delete \\\"%s\\\"\", dirname);\n\t\tr = -1;\n\t}\n\tret = closedir(dir);\n\tif (ret < 0) {\n\t\tif (!r)\n\t\t\tSYSWARN(\"Failed to delete \\\"%s\\\"\", dirname);\n\t\tr = -1;\n\t}\n\treturn r;\n}", "target": 0}
{"code": "static inline void phar_set_inode(phar_entry_info *entry TSRMLS_DC) \n{\n\tchar tmp[MAXPATHLEN];\n\tint tmp_len;\n\ttmp_len = entry->filename_len + entry->phar->fname_len;\n\tmemcpy(tmp, entry->phar->fname, entry->phar->fname_len);\n\tmemcpy(tmp + entry->phar->fname_len, entry->filename, entry->filename_len);\n\tentry->inode = (unsigned short)zend_get_hash_value(tmp, tmp_len);\n}", "target": 1}
{"code": "vte_terminal_find_charcell (VteTerminal *terminal, glong col, glong row)\n{\n\tVteRowData *rowdata;\n\tVteCell *ret = NULL;\n\tVteScreen *screen;\n\tg_assert(VTE_IS_TERMINAL(terminal));\n\tscreen = terminal->pvt->screen;\n\tif (_vte_ring_contains (screen->row_data, row)) {\n\t\trowdata = _vte_ring_index_writable (screen->row_data, row);\n\t\tret = _vte_row_data_get_writable (rowdata, col);\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "open_log_file(const char *name, const char *prog, const char *namespace, const char *instance)\n{\n\tchar *file_name;\n\tif (log_file) {\n\t\tfclose(log_file);\n\t\tlog_file = NULL;\n\t}\n\tif (!name)\n\t\treturn;\n\tfile_name = make_file_name(name, prog, namespace, instance);\n\tlog_file = fopen(file_name, \"a\");\n\tif (log_file) {\n\t\tint n = fileno(log_file);\n\t\tfcntl(n, F_SETFD, FD_CLOEXEC | fcntl(n, F_GETFD));\n\t\tfcntl(n, F_SETFL, O_NONBLOCK | fcntl(n, F_GETFL));\n\t}\n\tFREE(file_name);\n}", "target": 1}
{"code": "static inline int xsave_state(struct xsave_struct *fx, u64 mask)\n{\n\tu32 lmask = mask;\n\tu32 hmask = mask >> 32;\n\tint err = 0;\n\talternative_input_2(\n\t\t\"1:\"XSAVE,\n\t\t\"1:\"XSAVEOPT,\n\t\tX86_FEATURE_XSAVEOPT,\n\t\t\"1:\"XSAVES,\n\t\tX86_FEATURE_XSAVES,\n\t\t[fx] \"D\" (fx), \"a\" (lmask), \"d\" (hmask) :\n\t\t\"memory\");\n\tasm volatile(\"2:\\n\\t\"\n\t\t     xstate_fault\n\t\t     : \"0\" (0)\n\t\t     : \"memory\");\n\treturn err;\n}", "target": 1}
{"code": "txid_snapshot_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tTxidSnapshot *snap;\n\ttxid\t\tlast = 0;\n\tint\t\t\tnxip;\n\tint\t\t\ti;\n\tint\t\t\tavail;\n\tint\t\t\texpect;\n\ttxid\t\txmin,\n\t\t\t\txmax;\n\tnxip = pq_getmsgint(buf, 4);\n\tavail = buf->len - buf->cursor;\n\texpect = 8 + 8 + nxip * 8;\n\tif (nxip < 0 || nxip > avail || expect > avail)\n\t\tgoto bad_format;\n\txmin = pq_getmsgint64(buf);\n\txmax = pq_getmsgint64(buf);\n\tif (xmin == 0 || xmax == 0 || xmin > xmax || xmax > MAX_TXID)\n\t\tgoto bad_format;\n\tsnap = palloc(TXID_SNAPSHOT_SIZE(nxip));\n\tsnap->xmin = xmin;\n\tsnap->xmax = xmax;\n\tsnap->nxip = nxip;\n\tSET_VARSIZE(snap, TXID_SNAPSHOT_SIZE(nxip));\n\tfor (i = 0; i < nxip; i++)\n\t{\n\t\ttxid\t\tcur = pq_getmsgint64(buf);\n\t\tif (cur <= last || cur < xmin || cur >= xmax)\n\t\t\tgoto bad_format;\n\t\tsnap->xip[i] = cur;\n\t\tlast = cur;\n\t}\n\tPG_RETURN_POINTER(snap);\nbad_format:\n\telog(ERROR, \"invalid snapshot data\");\n\treturn (Datum) NULL;\n}", "target": 1}
{"code": "get_chainname_rulenum(const struct ipt_entry *s, const struct ipt_entry *e,\n\t\t      const char *hookname, const char **chainname,\n\t\t      const char **comment, unsigned int *rulenum)\n{\n\tconst struct xt_standard_target *t = (void *)ipt_get_target_c(s);\n\tif (strcmp(t->target.u.kernel.target->name, XT_ERROR_TARGET) == 0) {\n\t\t*chainname = t->target.data;\n\t\t(*rulenum) = 0;\n\t} else if (s == e) {\n\t\t(*rulenum)++;\n\t\tif (s->target_offset == sizeof(struct ipt_entry) &&\n\t\t    strcmp(t->target.u.kernel.target->name,\n\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t   t->verdict < 0 &&\n\t\t   unconditional(&s->ip)) {\n\t\t\t*comment = *chainname == hookname\n\t\t\t\t? comments[NF_IP_TRACE_COMMENT_POLICY]\n\t\t\t\t: comments[NF_IP_TRACE_COMMENT_RETURN];\n\t\t}\n\t\treturn 1;\n\t} else\n\t\t(*rulenum)++;\n\treturn 0;\n}", "target": 1}
{"code": "status_t Parcel::write(const FlattenableHelperInterface& val)\n{\n status_t err;\n const size_t len = val.getFlattenedSize();\n const size_t fd_count = val.getFdCount();\n if ((len > INT32_MAX) || (fd_count > INT32_MAX)) {\n return BAD_VALUE;\n }\n    err = this->writeInt32(len);\n if (err) return err;\n    err = this->writeInt32(fd_count);\n if (err) return err;\n void* const buf = this->writeInplace(pad_size(len));\n if (buf == NULL)\n return BAD_VALUE;\n int* fds = NULL;\n if (fd_count) {\n        fds = new int[fd_count];\n }\n    err = val.flatten(buf, len, fds, fd_count);\n for (size_t i=0 ; i<fd_count && err==NO_ERROR ; i++) {\n        err = this->writeDupFileDescriptor( fds[i] );\n }\n if (fd_count) {\n delete [] fds;\n }\n return err;\n}", "target": 0}
{"code": "static int pfkey_process(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr)\n{\n\tvoid *ext_hdrs[SADB_EXT_MAX];\n\tint err;\n\tpfkey_broadcast(skb_clone(skb, GFP_KERNEL), GFP_KERNEL,\n\t\t\tBROADCAST_PROMISC_ONLY, NULL, sock_net(sk));\n\tmemset(ext_hdrs, 0, sizeof(ext_hdrs));\n\terr = parse_exthdrs(skb, hdr, ext_hdrs);\n\tif (!err) {\n\t\terr = -EOPNOTSUPP;\n\t\tif (pfkey_funcs[hdr->sadb_msg_type])\n\t\t\terr = pfkey_funcs[hdr->sadb_msg_type](sk, skb, hdr, ext_hdrs);\n\t}\n\treturn err;\n}", "target": 0}
{"code": "static int __feat_register_sp(struct list_head *fn, u8 feat, u8 is_local,\n\t\t\t      u8 mandatory, u8 const *sp_val, u8 sp_len)\n{\n\tdccp_feat_val fval;\n\tif (dccp_feat_type(feat) != FEAT_SP ||\n\t    !dccp_feat_sp_list_ok(feat, sp_val, sp_len))\n\t\treturn -EINVAL;\n\tif (feat == DCCPF_CCID && !ccid_support_check(sp_val, sp_len))\n\t\treturn -EOPNOTSUPP;\n\tif (dccp_feat_clone_sp_val(&fval, sp_val, sp_len))\n\t\treturn -ENOMEM;\n\treturn dccp_feat_push_change(fn, feat, is_local, mandatory, &fval);\n}", "target": 1}
{"code": "comics_document_init (ComicsDocument *comics_document)\n{\n\tcomics_document->archive = NULL;\n\tcomics_document->page_names = NULL;\n\tcomics_document->extract_command = NULL;\n}", "target": 1}
{"code": "static int multipart_buffer_headers(multipart_buffer *self, zend_llist *header TSRMLS_DC)\n{\n\tchar *line;\n\tmime_header_entry prev_entry = {0}, entry;\n\tint prev_len, cur_len;\n\tif (!find_boundary(self, self->boundary TSRMLS_CC)) {\n\t\treturn 0;\n\t}\n\twhile( (line = get_line(self TSRMLS_CC)) && strlen(line) > 0 )\n\t{\n\t\tchar *key = line;\n\t\tchar *value = NULL;\n\t\tif (php_rfc1867_encoding_translation(TSRMLS_C)) {\n\t\t\tself->input_encoding = zend_multibyte_encoding_detector(line, strlen(line), self->detect_order, self->detect_order_size TSRMLS_CC);\n\t\t}\n\t\tif (!isspace(line[0])) {\n\t\t\tvalue = strchr(line, ':');\n\t\t}\n\t\tif (value) {\n\t\t\t*value = 0;\n\t\t\tdo { value++; } while(isspace(*value));\n\t\t\tentry.value = estrdup(value);\n\t\t\tentry.key = estrdup(key);\n\t\t} else if (zend_llist_count(header)) { \n\t\t\tprev_len = strlen(prev_entry.value);\n\t\t\tcur_len = strlen(line);\n\t\t\tentry.value = emalloc(prev_len + cur_len + 1);\n\t\t\tmemcpy(entry.value, prev_entry.value, prev_len);\n\t\t\tmemcpy(entry.value + prev_len, line, cur_len);\n\t\t\tentry.value[cur_len + prev_len] = '\\0';\n\t\t\tentry.key = estrdup(prev_entry.key);\n\t\t\tzend_llist_remove_tail(header);\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\tzend_llist_add_element(header, &entry);\n\t\tprev_entry = entry;\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "zzip_dir_close(ZZIP_DIR * dir)\n{\n    dir->refcount &= ~0x10000000;       \n    return zzip_dir_free(dir);\n}", "target": 0}
{"code": "int http_skip_chunk_crlf(struct buffer *buf, struct http_msg *msg)\n{\n\tchar *ptr;\n\tint bytes;\n\tbytes = 1;\n\tptr = buf->lr;\n\tif (*ptr == '\\r') {\n\t\tbytes++;\n\t\tptr++;\n\t\tif (ptr >= buf->data + buf->size)\n\t\t\tptr = buf->data;\n\t}\n\tif (bytes > buf->l - buf->send_max)\n\t\treturn 0;\n\tif (*ptr != '\\n') {\n\t\tmsg->err_pos = ptr - buf->data;\n\t\treturn -1;\n\t}\n\tptr++;\n\tif (ptr >= buf->data + buf->size)\n\t\tptr = buf->data;\n\tbuf->lr = ptr;\n\tmsg->sov = ptr - buf->data;\n\tmsg->som = msg->sov - bytes;\n\tmsg->msg_state = HTTP_MSG_CHUNK_SIZE;\n\treturn 1;\n}", "target": 0}
{"code": "static int transmit_skb(struct sk_buff *skb, struct caifsock *cf_sk,\n\t\t\tint noblock, long timeo)\n{\n\tstruct cfpkt *pkt;\n\tpkt = cfpkt_fromnative(CAIF_DIR_OUT, skb);\n\tmemset(skb->cb, 0, sizeof(struct caif_payload_info));\n\tcfpkt_set_prio(pkt, cf_sk->sk.sk_priority);\n\tif (cf_sk->layer.dn == NULL) {\n\t\tkfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\treturn cf_sk->layer.dn->transmit(cf_sk->layer.dn, pkt);\n}", "target": 0}
{"code": "static inline struct sem_array *sem_lock_check(struct ipc_namespace *ns,\n\t\t\t\t\t\tint id)\n{\n\tstruct kern_ipc_perm *ipcp = ipc_lock_check(&sem_ids(ns), id);\n\tif (IS_ERR(ipcp))\n\t\treturn ERR_CAST(ipcp);\n\treturn container_of(ipcp, struct sem_array, sem_perm);\n}", "target": 1}
{"code": "static void stellaris_enet_unrealize(DeviceState *dev, Error **errp)\n{\n    stellaris_enet_state *s = STELLARIS_ENET(dev);\n    unregister_savevm(DEVICE(s), \"stellaris_enet\", s);\n    memory_region_destroy(&s->mmio);\n}", "target": 1}
{"code": "void  opj_j2k_write_float_to_float64 (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n        OPJ_BYTE * l_dest_data = (OPJ_BYTE *) p_dest_data;\n        OPJ_FLOAT32 * l_src_data = (OPJ_FLOAT32 *) p_src_data;\n        OPJ_UINT32 i;\n        OPJ_FLOAT64 l_temp;\n        for (i=0;i<p_nb_elem;++i) {\n                l_temp = (OPJ_FLOAT64) *(l_src_data++);\n                opj_write_double(l_dest_data,l_temp);\n                l_dest_data+=sizeof(OPJ_FLOAT64);\n        }\n}", "target": 0}
{"code": "comics_document_thumbnails_get_thumbnail (EvDocumentThumbnails *document,\n\t\t\t\t\t  EvRenderContext      *rc,\n\t\t\t\t\t  gboolean              border)\n{\n\tGdkPixbuf *thumbnail;\n\tthumbnail = comics_document_render_pixbuf (EV_DOCUMENT (document), rc);\n\tif (border) {\n\t      GdkPixbuf *tmp_pixbuf = thumbnail;\n\t      thumbnail = ev_document_misc_get_thumbnail_frame (-1, -1, tmp_pixbuf);\n\t      g_object_unref (tmp_pixbuf);\n\t}\n\treturn thumbnail;\n}", "target": 1}
{"code": "mwifiex_cmd_append_vsie_tlv(struct mwifiex_private *priv,\n\t\t\t    u16 vsie_mask, u8 **buffer)\n{\n\tint id, ret_len = 0;\n\tstruct mwifiex_ie_types_vendor_param_set *vs_param_set;\n\tif (!buffer)\n\t\treturn 0;\n\tif (!(*buffer))\n\t\treturn 0;\n\tfor (id = 0; id < MWIFIEX_MAX_VSIE_NUM; id++) {\n\t\tif (priv->vs_ie[id].mask & vsie_mask) {\n\t\t\tvs_param_set =\n\t\t\t\t(struct mwifiex_ie_types_vendor_param_set *)\n\t\t\t\t*buffer;\n\t\t\tvs_param_set->header.type =\n\t\t\t\tcpu_to_le16(TLV_TYPE_PASSTHROUGH);\n\t\t\tvs_param_set->header.len =\n\t\t\t\tcpu_to_le16((((u16) priv->vs_ie[id].ie[1])\n\t\t\t\t& 0x00FF) + 2);\n\t\t\tmemcpy(vs_param_set->ie, priv->vs_ie[id].ie,\n\t\t\t       le16_to_cpu(vs_param_set->header.len));\n\t\t\t*buffer += le16_to_cpu(vs_param_set->header.len) +\n\t\t\t\t   sizeof(struct mwifiex_ie_types_header);\n\t\t\tret_len += le16_to_cpu(vs_param_set->header.len) +\n\t\t\t\t   sizeof(struct mwifiex_ie_types_header);\n\t\t}\n\t}\n\treturn ret_len;\n}", "target": 1}
{"code": "int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint rc, xprefix;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\txprefix = JFFS2_XPREFIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tumode_t mode = inode->i_mode;\n\t\t\trc = posix_acl_equiv_mode(acl, &mode);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\t\t\tif (inode->i_mode != mode) {\n\t\t\t\tstruct iattr attr;\n\t\t\t\tattr.ia_valid = ATTR_MODE | ATTR_CTIME;\n\t\t\t\tattr.ia_mode = mode;\n\t\t\t\tattr.ia_ctime = CURRENT_TIME_SEC;\n\t\t\t\trc = jffs2_do_setattr(inode, &attr);\n\t\t\t\tif (rc < 0)\n\t\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tif (rc == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\txprefix = JFFS2_XPREFIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\trc = __jffs2_set_acl(inode, xprefix, acl);\n\tif (!rc)\n\t\tset_cached_acl(inode, type, acl);\n\treturn rc;\n}", "target": 1}
{"code": "static int fts3EvalPhraseNext(\n  Fts3Cursor *pCsr,               \n  Fts3Phrase *p,                  \n  u8 *pbEof                       \n){\n  int rc = SQLITE_OK;\n  Fts3Doclist *pDL = &p->doclist;\n  Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;\n  if( p->bIncr ){\n    rc = fts3EvalIncrPhraseNext(pCsr, p, pbEof);\n  }else if( pCsr->bDesc!=pTab->bDescIdx && pDL->nAll ){\n    sqlite3Fts3DoclistPrev(pTab->bDescIdx, pDL->aAll, pDL->nAll, \n        &pDL->pNextDocid, &pDL->iDocid, &pDL->nList, pbEof\n    );\n    pDL->pList = pDL->pNextDocid;\n  }else{\n    fts3EvalDlPhraseNext(pTab, pDL, pbEof);\n  }\n  return rc;\n}", "target": 0}
{"code": "static int __init ipip_init(void)\n{\n\tint err;\n\tprintk(banner);\n\tif (xfrm4_tunnel_register(&ipip_handler, AF_INET)) {\n\t\tprintk(KERN_INFO \"ipip init: can't register tunnel\\n\");\n\t\treturn -EAGAIN;\n\t}\n\terr = register_pernet_device(&ipip_net_ops);\n\tif (err)\n\t\txfrm4_tunnel_deregister(&ipip_handler, AF_INET);\n\treturn err;\n}", "target": 1}
{"code": "vips_foreign_load_start( VipsImage *out, void *a, void *b )\n{\n\tVipsForeignLoad *load = VIPS_FOREIGN_LOAD( b );\n\tVipsForeignLoadClass *class = VIPS_FOREIGN_LOAD_GET_CLASS( load );\n\tif( !load->real ) {\n\t\tif( !(load->real = vips_foreign_load_temp( load )) )\n\t\t\treturn( NULL );\n#ifdef DEBUG\n\t\tprintf( \"vips_foreign_load_start: triggering ->load()\\n\" );\n#endif \n\t\tload->real->progress_signal = load->out;\n\t\tg_object_set_qdata( G_OBJECT( load->real ), \n\t\t\tvips__foreign_load_operation, load ); \n\t\tif( class->load( load ) ||\n\t\t\tvips_image_pio_input( load->real ) ) \n\t\t\treturn( NULL );\n\t\tif( !vips_foreign_load_iscompat( load->real, out ) )\n\t\t\treturn( NULL );\n\t\tvips_image_pipelinev( load->out, load->out->dhint, \n\t\t\tload->real, NULL );\n\t}\n\treturn( vips_region_new( load->real ) );\n}", "target": 1}
{"code": "TEST_F(LoaderTest, PbtxtFormat) {\n  SavedModelBundle bundle;\n  SessionOptions session_options;\n  RunOptions run_options;\n  const string export_dir =\n      io::JoinPath(testing::TensorFlowSrcRoot(), kTestDataPbTxt);\n  TF_ASSERT_OK(LoadSavedModel(session_options, run_options, export_dir,\n                              {kSavedModelTagServe}, &bundle));\n  CheckSavedModelBundle(export_dir, bundle);\n}", "target": 0}
{"code": "static int iommu_no_mapping(struct device *dev)\n{\n\tint found;\n\tif (iommu_dummy(dev))\n\t\treturn 1;\n\tif (!iommu_identity_mapping)\n\t\treturn 0;\n\tfound = identity_mapping(dev);\n\tif (found) {\n\t\tif (iommu_should_identity_map(dev, 0))\n\t\t\treturn 1;\n\t\telse {\n\t\t\tdmar_remove_one_dev_info(si_domain, dev);\n\t\t\tpr_info(\"32bit %s uses non-identity mapping\\n\",\n\t\t\t\tdev_name(dev));\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (iommu_should_identity_map(dev, 0)) {\n\t\t\tint ret;\n\t\t\tret = domain_add_dev_info(si_domain, dev);\n\t\t\tif (!ret) {\n\t\t\t\tpr_info(\"64bit %s uses identity mapping\\n\",\n\t\t\t\t\tdev_name(dev));\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int _assemble_line(FILE *f, char *buffer, int buf_len)\n{\n    char *p = buffer;\n    char *s, *os;\n    int used = 0;\n    D((\"called.\"));\n    for (;;) {\n\tif (used >= buf_len) {\n\t    D((\"_assemble_line: overflow\"));\n\t    return -1;\n\t}\n\tif (fgets(p, buf_len - used, f) == NULL) {\n\t    if (used) {\n\t\treturn -1;\n\t    } else {\n\t\treturn 0;\n\t    }\n\t}\n\ts = p + strspn(p, \" \\n\\t\");\n\tif (*s && (*s != '#')) {\n\t    os = s;\n\t    while (*s && *s != '#')\n\t\t ++s;\n\t    if (*s == '#') {\n\t\t *s = '\\0';\n\t\t used += strlen(os);\n\t\t break;                \n\t    }\n\t    s = os;\n\t    s += strlen(s);\n\t    while (s > os && ((*--s == ' ') || (*s == '\\t')\n\t\t\t      || (*s == '\\n')));\n\t    if (*s == '\\\\') {\n\t\t*s = '\\0';              \n\t\tused += strlen(os);\n\t\tp = s;                  \n\t    } else {\n\t\tused += strlen(os);\n\t\tbreak;                  \n\t    }\n\t} else {\n\t}\n    }\n    return used;\n}", "target": 0}
{"code": "atol8(const char *p, size_t char_cnt)\n{\n\tint64_t l;\n\tint digit;\n\tl = 0;\n\twhile (char_cnt-- > 0) {\n\t\tif (*p >= '0' && *p <= '7')\n\t\t\tdigit = *p - '0';\n\t\telse\n\t\t\tbreak;\n\t\tp++;\n\t\tl <<= 3;\n\t\tl |= digit;\n\t}\n\treturn (l);\n}", "target": 1}
{"code": "hb_set_invert (hb_set_t *set)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n  set->invert ();\n}", "target": 1}
{"code": "SPL_METHOD(SplMinHeap, compare)\n{\n\tzval *a, *b;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"zz\", &a, &b) == FAILURE) {\n\t\treturn;\n\t}\n\tRETURN_LONG(spl_ptr_heap_zval_min_cmp(a, b, NULL TSRMLS_CC));\n} ", "target": 0}
{"code": "unsigned long insn_get_seg_base(struct pt_regs *regs, int seg_reg_idx)\n{\n\tstruct desc_struct *desc;\n\tshort sel;\n\tsel = get_segment_selector(regs, seg_reg_idx);\n\tif (sel < 0)\n\t\treturn -1L;\n\tif (v8086_mode(regs))\n\t\treturn (unsigned long)(sel << 4);\n\tif (user_64bit_mode(regs)) {\n\t\tunsigned long base;\n\t\tif (seg_reg_idx == INAT_SEG_REG_FS)\n\t\t\trdmsrl(MSR_FS_BASE, base);\n\t\telse if (seg_reg_idx == INAT_SEG_REG_GS)\n\t\t\trdmsrl(MSR_KERNEL_GS_BASE, base);\n\t\telse\n\t\t\tbase = 0;\n\t\treturn base;\n\t}\n\tif (!sel)\n\t\treturn -1L;\n\tdesc = get_desc(sel);\n\tif (!desc)\n\t\treturn -1L;\n\treturn get_desc_base(desc);\n}", "target": 1}
{"code": "_gnutls_x509_oid2mac_algorithm (const char *oid)\n{\n  gnutls_mac_algorithm_t ret = 0;\n  GNUTLS_HASH_LOOP (if (strcmp (oid, p->oid) == 0)\n\t\t    {\n\t\t    ret = p->id; break;}\n  );\n  if (ret == 0)\n    return GNUTLS_MAC_UNKNOWN;\n  return ret;\n}", "target": 1}
{"code": "static inline void __clear_open_fd(unsigned int fd, struct fdtable *fdt)\n{\n\t__clear_bit(fd, fdt->open_fds);\n\t__clear_bit(fd / BITS_PER_LONG, fdt->full_fds_bits);\n}", "target": 0}
{"code": "static int xfrm_dump_sa(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_state_walk *walk = (struct xfrm_state_walk *) &cb->args[1];\n\tstruct xfrm_dump_info info;\n\tBUILD_BUG_ON(sizeof(struct xfrm_state_walk) >\n\t\t     sizeof(cb->args) - sizeof(cb->args[0]));\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\tif (!cb->args[0]) {\n\t\tstruct nlattr *attrs[XFRMA_MAX+1];\n\t\tstruct xfrm_address_filter *filter = NULL;\n\t\tu8 proto = 0;\n\t\tint err;\n\t\tcb->args[0] = 1;\n\t\terr = nlmsg_parse(cb->nlh, 0, attrs, XFRMA_MAX,\n\t\t\t\t  xfrma_policy);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (attrs[XFRMA_ADDRESS_FILTER]) {\n\t\t\tfilter = kmemdup(nla_data(attrs[XFRMA_ADDRESS_FILTER]),\n\t\t\t\t\t sizeof(*filter), GFP_KERNEL);\n\t\t\tif (filter == NULL)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (attrs[XFRMA_PROTO])\n\t\t\tproto = nla_get_u8(attrs[XFRMA_PROTO]);\n\t\txfrm_state_walk_init(walk, proto, filter);\n\t}\n\t(void) xfrm_state_walk(net, walk, dump_one_state, &info);\n\treturn skb->len;\n}", "target": 1}
{"code": "plugin_init (Ekiga::KickStart& kickstart)\n{\n#ifdef DEBUG\n  gchar* path = g_build_path (G_DIR_SEPARATOR_S,\n\t\t\t      g_get_tmp_dir (), \"ekiga_debug_plugins\", NULL);\n  plugin_parse_directory (kickstart, path);\n  g_free (path);\n#else\n  plugin_parse_directory (kickstart,\n\t\t\t  EKIGA_PLUGIN_DIR);\n#endif\n}", "target": 1}
{"code": "PackLinuxElf32::elf_find_dynamic(unsigned int key) const\n{\n    Elf32_Dyn const *dynp= dynseg;\n    if (dynp)\n    for (; (unsigned)((char const *)dynp - (char const *)dynseg) < sz_dynseg\n            && Elf32_Dyn::DT_NULL!=dynp->d_tag; ++dynp) if (get_te32(&dynp->d_tag)==key) {\n        unsigned const t= elf_get_offset_from_address(get_te32(&dynp->d_val));\n        if (t) {\n            return t + file_image;\n        }\n        break;\n    }\n    return 0;\n}", "target": 1}
{"code": "static void gen8_logical_ring_enable_irq(struct intel_engine_cs *engine)\n{\n\tENGINE_WRITE(engine, RING_IMR,\n\t\t     ~(engine->irq_enable_mask | engine->irq_keep_mask));\n\tENGINE_POSTING_READ(engine, RING_IMR);\n}", "target": 0}
{"code": "void disk_part_iter_init(struct disk_part_iter *piter, struct gendisk *disk,\n\t\t\t  unsigned int flags)\n{\n\tstruct disk_part_tbl *ptbl;\n\trcu_read_lock();\n\tptbl = rcu_dereference(disk->part_tbl);\n\tpiter->disk = disk;\n\tpiter->part = NULL;\n\tif (flags & DISK_PITER_REVERSE)\n\t\tpiter->idx = ptbl->len - 1;\n\telse if (flags & (DISK_PITER_INCL_PART0 | DISK_PITER_INCL_EMPTY_PART0))\n\t\tpiter->idx = 0;\n\telse\n\t\tpiter->idx = 1;\n\tpiter->flags = flags;\n\trcu_read_unlock();\n}", "target": 0}
{"code": "static void settings_changed(struct btd_adapter *adapter, uint32_t settings)\n{\n\tuint32_t changed_mask;\n\tchanged_mask = adapter->current_settings ^ settings;\n\tadapter->current_settings = settings;\n\tadapter->pending_settings &= ~changed_mask;\n\tDBG(\"Changed settings: 0x%08x\", changed_mask);\n\tDBG(\"Pending settings: 0x%08x\", adapter->pending_settings);\n\tif (changed_mask & MGMT_SETTING_POWERED) {\n\t        g_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Powered\");\n\t\tif (adapter->current_settings & MGMT_SETTING_POWERED) {\n\t\t\tadapter_start(adapter);\n\t\t} else {\n\t\t\tadapter_stop(adapter);\n\t\t\tif (powering_down) {\n\t\t\t\tadapter_remaining--;\n\t\t\t\tif (!adapter_remaining)\n\t\t\t\t\tbtd_exit();\n\t\t\t}\n\t\t}\n\t}\n\tif ((changed_mask & MGMT_SETTING_LE) &&\n\t\t\t\tbtd_adapter_get_powered(adapter) &&\n\t\t\t\t(adapter->current_settings & MGMT_SETTING_LE))\n\t\ttrigger_passive_scanning(adapter);\n\tif (changed_mask & MGMT_SETTING_DISCOVERABLE) {\n\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Discoverable\");\n\t\tstore_adapter_info(adapter);\n\t\tbtd_adv_manager_refresh(adapter->adv_manager);\n\t}\n\tif (changed_mask & MGMT_SETTING_BONDABLE) {\n\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Pairable\");\n\t\ttrigger_pairable_timeout(adapter);\n\t}\n}", "target": 1}
{"code": "static int linear_ioctl(struct dm_target *ti, unsigned int cmd,\n\t\t\tunsigned long arg)\n{\n\tstruct linear_c *lc = (struct linear_c *) ti->private;\n\treturn __blkdev_driver_ioctl(lc->dev->bdev, lc->dev->mode, cmd, arg);\n}", "target": 1}
{"code": "_isBidi (const uint32_t *label, size_t llen)\n{\n  while (llen-- > 0) {\n    int bc = uc_bidi_category (*label++);\n    if (bc == UC_BIDI_R || bc == UC_BIDI_AL || bc == UC_BIDI_AN)\n      return 1;\n  }\n  return 0;\n}", "target": 1}
{"code": "static int checksum_setup(struct net_device *dev, struct sk_buff *skb)\n{\n\tbool recalculate_partial_csum = false;\n\tif (skb->ip_summed != CHECKSUM_PARTIAL && skb_is_gso(skb)) {\n\t\tstruct netfront_info *np = netdev_priv(dev);\n\t\tatomic_inc(&np->rx_gso_checksum_fixup);\n\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\trecalculate_partial_csum = true;\n\t}\n\tif (skb->ip_summed != CHECKSUM_PARTIAL)\n\t\treturn 0;\n\treturn skb_checksum_setup(skb, recalculate_partial_csum);\n}", "target": 0}
{"code": "mrb_remove_method(mrb_state *mrb, struct RClass *c, mrb_sym mid)\n{\n  mt_tbl *h;\n  MRB_CLASS_ORIGIN(c);\n  h = c->mt;\n  if (h && mt_del(mrb, h, mid)) return;\n  mrb_name_error(mrb, mid, \"method '%n' not defined in %C\", mid, c);\n}", "target": 1}
{"code": "int SSL_free_buffers(SSL *ssl)\n{\n    RECORD_LAYER *rl = &ssl->rlayer;\n    if (RECORD_LAYER_read_pending(rl) || RECORD_LAYER_write_pending(rl))\n        return 0;\n    if (RECORD_LAYER_data_present(rl))\n        return 0;\n    RECORD_LAYER_release(rl);\n    return 1;\n}", "target": 0}
{"code": "void options_free() {\n    parse_global_option(CMD_FREE, NULL, NULL);\n}", "target": 1}
{"code": "comics_decompress_temp_dir (const gchar *command_decompress_tmp,\n\t\t\t    const gchar *command,\n\t\t\t    GError      **error)\n{\n\tgboolean success;\n\tgchar *std_out, *basename;\n\tGError *err = NULL;\n\tgint retval;\n\tsuccess = g_spawn_command_line_sync (command_decompress_tmp, &std_out,\n\t\t\t\t\t     NULL, &retval, &err);\n\tbasename = g_path_get_basename (command);\n\tif (!success) {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"Error launching the command “%s” in order to \"\n\t\t\t     \"decompress the comic book: %s\"),\n\t\t\t     basename,\n\t\t\t     err->message);\n\t\tg_error_free (err);\n\t} else if (WIFEXITED (retval)) {\n\t\tif (WEXITSTATUS (retval) == EXIT_SUCCESS) {\n\t\t\tg_free (std_out);\n\t\t\tg_free (basename);\n\t\t\treturn TRUE;\n\t\t} else {\n\t\t\tg_set_error (error,\n\t\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t\t     _(\"The command “%s” failed at \"\n\t\t\t\t     \"decompressing the comic book.\"),\n\t\t\t\t     basename);\n\t\t\tg_free (std_out);\n\t\t}\n\t} else {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"The command “%s” did not end normally.\"),\n\t\t\t     basename);\n\t\tg_free (std_out);\n\t}\n\tg_free (basename);\n\treturn FALSE;\n}", "target": 1}
{"code": "prologProcessor(XML_Parser parser, const char *s, const char *end,\n                const char **nextPtr) {\n  const char *next = s;\n  int tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                  (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n}", "target": 1}
{"code": "void PdfXRefStreamParserObject::getIndices(vector<int64_t>& indices, int64_t size)\n{\n    auto indexObj = this->GetDictionary().GetKey(\"Index\");\n    if (indexObj == nullptr)\n    {\n        indices.push_back(static_cast<int64_t>(0));\n        indices.push_back(size);\n    }\n    else\n    {\n        const PdfArray* arr;\n        if (!indexObj->TryGetArray(arr))\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid XRef Stream /Index\");\n        for (auto index : *arr)\n            indices.push_back(index.GetNumber());\n    }\n    if (indices.size() % 2 != 0)\n        PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid XRef Stream /Index\");\n}", "target": 1}
{"code": "bool ChildProcessSecurityPolicy::CanReadRawCookies(int renderer_id) {\n  AutoLock lock(lock_);\n  SecurityStateMap::iterator state = security_state_.find(renderer_id);\n  if (state == security_state_.end())\n    return false;\n  return state->second->can_read_raw_cookies();\n}", "target": 0}
{"code": "sock_set_v6only(int s)\n{\n#if defined(IPV6_V6ONLY) && !defined(__OpenBSD__)\n\tint on = 1;\n\tdebug3(\"%s: set socket %d IPV6_V6ONLY\", __func__, s);\n\tif (setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY, &on, sizeof(on)) == -1)\n\t\terror(\"setsockopt IPV6_V6ONLY: %s\", strerror(errno));\n#endif\n}", "target": 0}
{"code": "void jsP_dumpsyntax(js_State *J, js_Ast *prog, int dominify)\n{\n\tminify = dominify;\n\tif (prog->type == AST_LIST)\n\t\tpstmlist(-1, prog);\n\telse {\n\t\tpstm(0, prog);\n\t\tnl();\n\t}\n\tif (minify > 1)\n\t\tputchar('\\n');\n}", "target": 1}
{"code": "static void perf_event_init_cpu(int cpu)\n{\n\tstruct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);\n\tmutex_lock(&swhash->hlist_mutex);\n\tswhash->online = true;\n\tif (swhash->hlist_refcount > 0) {\n\t\tstruct swevent_hlist *hlist;\n\t\thlist = kzalloc_node(sizeof(*hlist), GFP_KERNEL, cpu_to_node(cpu));\n\t\tWARN_ON(!hlist);\n\t\trcu_assign_pointer(swhash->swevent_hlist, hlist);\n\t}\n\tmutex_unlock(&swhash->hlist_mutex);\n}", "target": 1}
{"code": "static int aspeed_lpc_ctrl_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct aspeed_lpc_ctrl *lpc_ctrl = file_aspeed_lpc_ctrl(file);\n\tunsigned long vsize = vma->vm_end - vma->vm_start;\n\tpgprot_t prot = vma->vm_page_prot;\n\tif (vma->vm_pgoff + vma_pages(vma) > lpc_ctrl->mem_size >> PAGE_SHIFT)\n\t\treturn -EINVAL;\n\tprot = pgprot_noncached(prot);\n\tif (remap_pfn_range(vma, vma->vm_start,\n\t\t(lpc_ctrl->mem_base >> PAGE_SHIFT) + vma->vm_pgoff,\n\t\tvsize, prot))\n\t\treturn -EAGAIN;\n\treturn 0;\n}", "target": 0}
{"code": "void ipc_rcu_getref(void *ptr)\n{\n\tcontainer_of(ptr, struct ipc_rcu_hdr, data)->refcount++;\n}", "target": 1}
{"code": "static int sg_proc_seq_show_debug(struct seq_file *s, void *v)\n{\n\tstruct sg_proc_deviter * it = (struct sg_proc_deviter *) v;\n\tSg_device *sdp;\n\tunsigned long iflags;\n\tif (it && (0 == it->index))\n\t\tseq_printf(s, \"max_active_device=%d  def_reserved_size=%d\\n\",\n\t\t\t   (int)it->max, sg_big_buff);\n\tread_lock_irqsave(&sg_index_lock, iflags);\n\tsdp = it ? sg_lookup_dev(it->index) : NULL;\n\tif (NULL == sdp)\n\t\tgoto skip;\n\tread_lock(&sdp->sfd_lock);\n\tif (!list_empty(&sdp->sfds)) {\n\t\tseq_printf(s, \" >>> device=%s \", sdp->disk->disk_name);\n\t\tif (atomic_read(&sdp->detaching))\n\t\t\tseq_puts(s, \"detaching pending close \");\n\t\telse if (sdp->device) {\n\t\t\tstruct scsi_device *scsidp = sdp->device;\n\t\t\tseq_printf(s, \"%d:%d:%d:%llu   em=%d\",\n\t\t\t\t   scsidp->host->host_no,\n\t\t\t\t   scsidp->channel, scsidp->id,\n\t\t\t\t   scsidp->lun,\n\t\t\t\t   scsidp->host->hostt->emulated);\n\t\t}\n\t\tseq_printf(s, \" sg_tablesize=%d excl=%d open_cnt=%d\\n\",\n\t\t\t   sdp->sg_tablesize, sdp->exclude, sdp->open_cnt);\n\t\tsg_proc_debug_helper(s, sdp);\n\t}\n\tread_unlock(&sdp->sfd_lock);\nskip:\n\tread_unlock_irqrestore(&sg_index_lock, iflags);\n\treturn 0;\n}", "target": 0}
{"code": "int tcp_ctl(struct socket *so)\n{\n    Slirp *slirp = so->slirp;\n    struct sbuf *sb = &so->so_snd;\n    struct gfwd_list *ex_ptr;\n    DEBUG_CALL(\"tcp_ctl\");\n    DEBUG_ARG(\"so = %p\", so);\n    if (so->so_faddr.s_addr != slirp->vhost_addr.s_addr) {\n        for (ex_ptr = slirp->guestfwd_list; ex_ptr; ex_ptr = ex_ptr->ex_next) {\n            if (ex_ptr->ex_fport == so->so_fport &&\n                so->so_faddr.s_addr == ex_ptr->ex_addr.s_addr) {\n                if (ex_ptr->write_cb) {\n                    so->s = -1;\n                    so->guestfwd = ex_ptr;\n                    return 1;\n                }\n                DEBUG_MISC(\" executing %s\", ex_ptr->ex_exec);\n                if (ex_ptr->ex_unix)\n                    return open_unix(so, ex_ptr->ex_unix);\n                else\n                    return fork_exec(so, ex_ptr->ex_exec);\n            }\n        }\n    }\n    sb->sb_cc =\n        snprintf(sb->sb_wptr, sb->sb_datalen - (sb->sb_wptr - sb->sb_data),\n                 \"Error: No application configured.\\r\\n\");\n    sb->sb_wptr += sb->sb_cc;\n    return 0;\n}", "target": 0}
{"code": "static inline struct timespec ep_set_mstimeout(long ms)\n{\n\tstruct timespec now, ts = {\n\t\t.tv_sec = ms / MSEC_PER_SEC,\n\t\t.tv_nsec = NSEC_PER_MSEC * (ms % MSEC_PER_SEC),\n\t};\n\tktime_get_ts(&now);\n\treturn timespec_add_safe(now, ts);\n}", "target": 0}
{"code": "bit_write_UMC (Bit_Chain *dat, BITCODE_UMC val)\n{\n  int i, j;\n  int negative;\n  unsigned char byte[5];\n  BITCODE_UMC mask;\n  BITCODE_UMC value;\n  value = val;\n  mask = 0x0000007f;\n  for (i = 4, j = 0; i >= 0; i--, j += 7)\n    {\n      byte[i] = (unsigned char)((value & mask) >> j);\n      byte[i] |= 0x80;\n      mask = mask << 7;\n    }\n  for (i = 0; i < 4; i++)\n    if (byte[i] & 0x7f)\n      break;\n  if (byte[i] & 0x40)\n    i--;\n  byte[i] &= 0x7f;\n  for (j = 4; j >= i; j--)\n    bit_write_RC (dat, byte[j]);\n}", "target": 1}
{"code": "reallocWrapper (void *address, size_t size)\n{\n  if (!(address = realloc (address, size)) && size)\n    outOfMemory ();\n  return address;\n}", "target": 0}
{"code": "int get_evtchn_to_irq(evtchn_port_t evtchn)\n{\n\tif (evtchn >= xen_evtchn_max_channels())\n\t\treturn -1;\n\tif (evtchn_to_irq[EVTCHN_ROW(evtchn)] == NULL)\n\t\treturn -1;\n\treturn evtchn_to_irq[EVTCHN_ROW(evtchn)][EVTCHN_COL(evtchn)];\n}", "target": 1}
{"code": "static int _nfs4_proc_open(struct nfs4_opendata *data)\n{\n\tstruct inode *dir = data->dir->d_inode;\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs_openargs *o_arg = &data->o_arg;\n\tstruct nfs_openres *o_res = &data->o_res;\n\tint status;\n\tstatus = nfs4_run_open_task(data, 0);\n\tif (!data->rpc_done)\n\t\treturn status;\n\tif (status != 0) {\n\t\tif (status == -NFS4ERR_BADNAME &&\n\t\t\t\t!(o_arg->open_flags & O_CREAT))\n\t\t\treturn -ENOENT;\n\t\treturn status;\n\t}\n\tnfs_fattr_map_and_free_names(server, &data->f_attr);\n\tif (o_arg->open_flags & O_CREAT)\n\t\tupdate_changeattr(dir, &o_res->cinfo);\n\tif ((o_res->rflags & NFS4_OPEN_RESULT_LOCKTYPE_POSIX) == 0)\n\t\tserver->caps &= ~NFS_CAP_POSIX_LOCK;\n\tif(o_res->rflags & NFS4_OPEN_RESULT_CONFIRM) {\n\t\tstatus = _nfs4_proc_open_confirm(data);\n\t\tif (status != 0)\n\t\t\treturn status;\n\t}\n\tif (!(o_res->f_attr->valid & NFS_ATTR_FATTR))\n\t\t_nfs4_proc_getattr(server, &o_res->fh, o_res->f_attr);\n\treturn 0;\n}", "target": 0}
{"code": "authDigestNonceLinks(digest_nonce_h * nonce)\n{\n    if (!nonce)\n        return -1;\n    return nonce->references;\n}", "target": 1}
{"code": "fetch_indexed_string (dwarf_vma           idx,\n\t\t      struct cu_tu_set *  this_set,\n\t\t      dwarf_vma           offset_size,\n\t\t      bool                dwo,\n\t\t      dwarf_vma           str_offsets_base)\n{\n  enum dwarf_section_display_enum str_sec_idx = dwo ? str_dwo : str;\n  enum dwarf_section_display_enum idx_sec_idx = dwo ? str_index_dwo : str_index;\n  struct dwarf_section *index_section = &debug_displays [idx_sec_idx].section;\n  struct dwarf_section *str_section = &debug_displays [str_sec_idx].section;\n  dwarf_vma index_offset;\n  dwarf_vma str_offset;\n  const char * ret;\n  if (index_section->start == NULL)\n    return (dwo ? _(\"<no .debug_str_offsets.dwo section>\")\n\t\t: _(\"<no .debug_str_offsets section>\"));\n  if (str_section->start == NULL)\n    return (dwo ? _(\"<no .debug_str.dwo section>\")\n\t\t: _(\"<no .debug_str section>\"));\n  index_offset = idx * offset_size;\n  if (this_set != NULL)\n    index_offset += this_set->section_offsets [DW_SECT_STR_OFFSETS];\n  index_offset += str_offsets_base;\n  if (index_offset + offset_size > index_section->size)\n    {\n      warn (_(\"string index of %s converts to an offset of 0x%s which is too big for section %s\"),\n\t    dwarf_vmatoa (\"d\", idx),\n\t    dwarf_vmatoa (\"x\", index_offset),\n\t    str_section->name);\n      return _(\"<string index too big>\");\n    }\n  str_offset = byte_get (index_section->start + index_offset, offset_size);\n  str_offset -= str_section->address;\n  if (str_offset >= str_section->size)\n    {\n      warn (_(\"indirect offset too big: 0x%s\\n\"),\n\t    dwarf_vmatoa (\"x\", str_offset));\n      return _(\"<indirect index offset is too big>\");\n    }\n  ret = (const char *) str_section->start + str_offset;\n  if (strnlen (ret, str_section->size - str_offset)\n      == str_section->size - str_offset)\n    return _(\"<no NUL byte at end of section>\");\n  return ret;\n}", "target": 0}
{"code": "gfx::SwapResult GLSurfaceOzoneSurfaceless::PostSubBuffer(int x,\n                                                         int y,\n                                                         int width,\n                                                         int height) {\n  NOTREACHED();\n  return gfx::SwapResult::SWAP_FAILED;\n}", "target": 0}
{"code": "static int adpt_reset(struct scsi_cmnd* cmd)\n{\n\tint rc;\n\tspin_lock_irq(cmd->device->host->host_lock);\n\trc = __adpt_reset(cmd);\n\tspin_unlock_irq(cmd->device->host->host_lock);\n\treturn rc;\n}", "target": 1}
{"code": "void CE_WideToChar(unsigned short *w_str, char *str)\n{\n\tWideCharToMultiByte(CP_ACP, 0, w_str, -1, str, GF_MAX_PATH, NULL, NULL);\n}", "target": 0}
{"code": "size_t TensorSliceWriter::MaxBytesPerElement(DataType dt) {\n  switch (dt) {\n    case DT_FLOAT:\n      return 4;\n    case DT_DOUBLE:\n      return 8;\n    case DT_INT32:\n      return 10;\n    case DT_UINT8:\n      return 2;\n    case DT_INT16:\n      return 10;\n    case DT_INT8:\n      return 10;\n    case DT_COMPLEX64:\n      return 8;\n    case DT_INT64:\n      return 10;\n    case DT_BOOL:\n      return 1;\n    case DT_QINT8:\n      return 10;\n    case DT_QUINT8:\n      return 2;\n    case DT_QINT32:\n      return 10;\n    case DT_QINT16:\n      return 10;\n    case DT_QUINT16:\n      return 3;\n    case DT_UINT16:\n      return 3;\n    case DT_COMPLEX128:\n      return 16;\n    case DT_HALF:\n      return 3;\n    case DT_INVALID:\n    case DT_STRING:\n    case DT_BFLOAT16:\n    default:\n      LOG(FATAL) << \"MaxBytesPerElement not implemented for dtype: \" << dt;\n  }\n  return 0;\n}", "target": 1}
{"code": "bool FrameLoader::shouldUsePlugin(const KURL& url, const String& mimeType, bool hasFallback, bool& useFallback)\n{\n    if (m_client->shouldUsePluginDocument(mimeType)) {\n        useFallback = false;\n        return true;\n    }\n    if (m_frame->page() && (mimeType == \"image/tiff\" || mimeType == \"image/tif\" || mimeType == \"image/x-tiff\")) {\n        const PluginData* pluginData = m_frame->page()->pluginData();\n        String pluginName = pluginData ? pluginData->pluginNameForMimeType(mimeType) : String();\n        if (!pluginName.isEmpty() && !pluginName.contains(\"QuickTime\", false)) \n            return true;\n    }\n    ObjectContentType objectType = m_client->objectContentType(url, mimeType);\n    useFallback = objectType == ObjectContentNone && hasFallback;\n    return objectType == ObjectContentNone || objectType == ObjectContentNetscapePlugin || objectType == ObjectContentOtherPlugin;\n}", "target": 0}
{"code": "get_u32_le(const void *vp)\n{\n\tconst u_char *p = (const u_char *)vp;\n\tu_int32_t v;\n\tv  = (u_int32_t)p[0];\n\tv |= (u_int32_t)p[1] << 8;\n\tv |= (u_int32_t)p[2] << 16;\n\tv |= (u_int32_t)p[3] << 24;\n\treturn (v);\n}", "target": 0}
{"code": "void imap_munge_mbox_name(struct ImapData *idata, char *dest, size_t dlen, const char *src)\n{\n  char *buf = mutt_str_strdup(src);\n  imap_utf_encode(idata, &buf);\n  imap_quote_string(dest, dlen, buf);\n  FREE(&buf);\n}", "target": 1}
{"code": "static int br_multicast_add_group(struct net_bridge *br,\n\t\t\t\t  struct net_bridge_port *port,\n\t\t\t\t  struct br_ip *group)\n{\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tunsigned long now = jiffies;\n\tint err;\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) ||\n\t    (port && port->state == BR_STATE_DISABLED))\n\t\tgoto out;\n\tmp = br_multicast_new_group(br, port, group);\n\terr = PTR_ERR(mp);\n\tif (IS_ERR(mp))\n\t\tgoto err;\n\tif (!port) {\n\t\thlist_add_head(&mp->mglist, &br->mglist);\n\t\tmod_timer(&mp->timer, now + br->multicast_membership_interval);\n\t\tgoto out;\n\t}\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (p->port == port)\n\t\t\tgoto found;\n\t\tif ((unsigned long)p->port < (unsigned long)port)\n\t\t\tbreak;\n\t}\n\tp = kzalloc(sizeof(*p), GFP_ATOMIC);\n\terr = -ENOMEM;\n\tif (unlikely(!p))\n\t\tgoto err;\n\tp->addr = *group;\n\tp->port = port;\n\tp->next = *pp;\n\thlist_add_head(&p->mglist, &port->mglist);\n\tsetup_timer(&p->timer, br_multicast_port_group_expired,\n\t\t    (unsigned long)p);\n\tsetup_timer(&p->query_timer, br_multicast_port_group_query_expired,\n\t\t    (unsigned long)p);\n\trcu_assign_pointer(*pp, p);\nfound:\n\tmod_timer(&p->timer, now + br->multicast_membership_interval);\nout:\n\terr = 0;\nerr:\n\tspin_unlock(&br->multicast_lock);\n\treturn err;\n}", "target": 1}
{"code": "static bool vtable_is_value_in_text_section(RVTableContext *context, ut64 curAddress, ut64 *value) {\n\tut64 curAddressValue;\n\tif (!context->read_addr (context->anal, curAddress, &curAddressValue)) {\n\t\treturn false;\n\t}\n\tbool ret = vtable_addr_in_text_section (context, curAddressValue);\n\tif (value) {\n\t\t*value = curAddressValue;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static int crypto_report_akcipher(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_akcipher rakcipher;\n\tstrlcpy(rakcipher.type, \"akcipher\", sizeof(rakcipher.type));\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_AKCIPHER,\n\t\t    sizeof(struct crypto_report_akcipher), &rakcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "nfs_idmap_new(struct nfs_client *clp)\n{\n\tstruct idmap *idmap;\n\tstruct rpc_pipe *pipe;\n\tint error;\n\tidmap = kzalloc(sizeof(*idmap), GFP_KERNEL);\n\tif (idmap == NULL)\n\t\treturn -ENOMEM;\n\trpc_init_pipe_dir_object(&idmap->idmap_pdo,\n\t\t\t&nfs_idmap_pipe_dir_object_ops,\n\t\t\tidmap);\n\tpipe = rpc_mkpipe_data(&idmap_upcall_ops, 0);\n\tif (IS_ERR(pipe)) {\n\t\terror = PTR_ERR(pipe);\n\t\tgoto err;\n\t}\n\tidmap->idmap_pipe = pipe;\n\tmutex_init(&idmap->idmap_mutex);\n\terror = rpc_add_pipe_dir_object(clp->cl_net,\n\t\t\t&clp->cl_rpcclient->cl_pipedir_objects,\n\t\t\t&idmap->idmap_pdo);\n\tif (error)\n\t\tgoto err_destroy_pipe;\n\tclp->cl_idmap = idmap;\n\treturn 0;\nerr_destroy_pipe:\n\trpc_destroy_pipe_data(idmap->idmap_pipe);\nerr:\n\tkfree(idmap);\n\treturn error;\n}", "target": 0}
{"code": "TIFFNumberOfStrips(TIFF* tif)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint32 nstrips;\n    if( td->td_nstrips )\n        return td->td_nstrips;\n\tnstrips = (td->td_rowsperstrip == (uint32) -1 ? 1 :\n\t     TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip));\n\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE)\n\t\tnstrips = _TIFFMultiply32(tif, nstrips, (uint32)td->td_samplesperpixel,\n\t\t    \"TIFFNumberOfStrips\");\n\treturn (nstrips);\n}", "target": 1}
{"code": "static int changedline (const Proto *p, int oldpc, int newpc) {\n  while (oldpc++ < newpc) {\n    if (p->lineinfo[oldpc] != 0)\n      return (luaG_getfuncline(p, oldpc - 1) != luaG_getfuncline(p, newpc));\n  }\n  return 0;  \n}", "target": 1}
{"code": "void *memslot_get_virt(RedMemSlotInfo *info, QXLPHYSICAL addr, uint32_t add_size,\n                       int group_id)\n{\n    int slot_id;\n    int generation;\n    unsigned long h_virt;\n    MemSlot *slot;\n    if (group_id > info->num_memslots_groups) {\n        spice_critical(\"group_id too big\");\n        return NULL;\n    }\n    slot_id = memslot_get_id(info, addr);\n    if (slot_id > info->num_memslots) {\n        print_memslots(info);\n        spice_critical(\"slot_id %d too big, addr=%\" PRIx64, slot_id, addr);\n        return NULL;\n    }\n    slot = &info->mem_slots[group_id][slot_id];\n    generation = memslot_get_generation(info, addr);\n    if (generation != slot->generation) {\n        print_memslots(info);\n        spice_critical(\"address generation is not valid, group_id %d, slot_id %d, \"\n                       \"gen %d, slot_gen %d\",\n                       group_id, slot_id,\n                       generation, slot->generation);\n        return NULL;\n    }\n    h_virt = __get_clean_virt(info, addr);\n    h_virt += slot->address_delta;\n    if (!memslot_validate_virt(info, h_virt, slot_id, add_size, group_id)) {\n        return NULL;\n    }\n    return (void*)(uintptr_t)h_virt;\n}", "target": 1}
{"code": "gimp_channel_get_node (GimpFilter *filter)\n{\n  GimpDrawable *drawable = GIMP_DRAWABLE (filter);\n  GimpChannel  *channel  = GIMP_CHANNEL (filter);\n  GeglNode     *node;\n  GeglNode     *source;\n  GeglNode     *mode_node;\n  const Babl   *color_format;\n  node = GIMP_FILTER_CLASS (parent_class)->get_node (filter);\n  source = gimp_drawable_get_source_node (drawable);\n  gegl_node_add_child (node, source);\n  g_warn_if_fail (channel->color_node == NULL);\n  if (gimp_drawable_get_linear (drawable))\n    color_format = babl_format (\"RGBA float\");\n  else\n    color_format = babl_format (\"R'G'B'A float\");\n  channel->color_node = gegl_node_new_child (node,\n                                             \"operation\", \"gegl:color\",\n                                             \"format\",    color_format,\n                                             NULL);\n  gimp_gegl_node_set_color (channel->color_node,\n                            &channel->color);\n  g_warn_if_fail (channel->mask_node == NULL);\n  channel->mask_node = gegl_node_new_child (node,\n                                            \"operation\", \"gegl:opacity\",\n                                            NULL);\n  gegl_node_connect_to (channel->color_node, \"output\",\n                        channel->mask_node,  \"input\");\n  g_warn_if_fail (channel->invert_node == NULL);\n  channel->invert_node = gegl_node_new_child (node,\n                                              \"operation\", \"gegl:invert-linear\",\n                                              NULL);\n  if (channel->show_masked)\n    {\n      gegl_node_connect_to (source,               \"output\",\n                            channel->invert_node, \"input\");\n      gegl_node_connect_to (channel->invert_node, \"output\",\n                            channel->mask_node,   \"aux\");\n    }\n  else\n    {\n      gegl_node_connect_to (source,             \"output\",\n                            channel->mask_node, \"aux\");\n    }\n  mode_node = gimp_drawable_get_mode_node (drawable);\n  gegl_node_connect_to (channel->mask_node, \"output\",\n                        mode_node,          \"aux\");\n  return node;\n}", "target": 0}
{"code": "test_read_integer_error (xd3_stream *stream, usize_t trunto, const char *msg)\n{\n  uint64_t eval = 1ULL << 34;\n  uint32_t rval;\n  xd3_output *buf = NULL;\n  const uint8_t *max;\n  const uint8_t *inp;\n  int ret;\n  buf = xd3_alloc_output (stream, buf);\n  if ((ret = xd3_emit_uint64_t (stream, & buf, eval)))\n    {\n      goto fail;\n    }\n again:\n  inp = buf->base;\n  max = buf->base + buf->next - trunto;\n  if ((ret = xd3_read_uint32_t (stream, & inp, max, & rval)) != \n      XD3_INVALID_INPUT ||\n      !MSG_IS (msg))\n    {\n      ret = XD3_INTERNAL;\n    }\n  else if (trunto && trunto < buf->next)\n    {\n      trunto += 1;\n      goto again;\n    }\n  else\n    {\n      ret = 0;\n    }\n fail:\n  xd3_free_output (stream, buf);\n  return ret;\n}", "target": 1}
{"code": "static void cleanup_key_data(context, count, data)\n    krb5_context   context;\n    int                    count;\n    krb5_key_data        * data;\n{\n    int i, j;\n    for (i = 0; i < count; i++)\n        for (j = 0; j < data[i].key_data_ver; j++)\n            if (data[i].key_data_length[j])\n                krb5_db_free(context, data[i].key_data_contents[j]);\n    krb5_db_free(context, data);\n}", "target": 0}
{"code": "  template<typename T>\n  inline CImg<_cimg_Tfloat> tanh(const CImg<T>& instance) {\n    return instance.get_tanh();", "target": 0}
{"code": "BnGeneratePrimeForRSA(\n\t\t      bigNum          prime,\n\t\t      UINT32          bits,\n\t\t      UINT32          exponent,\n\t\t      RAND_STATE      *rand\n\t\t      )\n{\n    BOOL            found = FALSE;\n    pAssert(prime->allocated >= BITS_TO_CRYPT_WORDS(bits));\n    pAssert((bits % 32) == 0);\n    prime->size = BITS_TO_CRYPT_WORDS(bits);\n    while(!found)\n\t{\n\t    DRBG_Generate(rand, (BYTE *)prime->d, (UINT16)BITS_TO_BYTES(bits));\n\t    RsaAdjustPrimeCandidate(prime);\n\t    found = RsaCheckPrime(prime, exponent, rand) == TPM_RC_SUCCESS;\n\t}\n}", "target": 0}
{"code": "int blkcg_init_queue(struct request_queue *q)\n{\n\tstruct blkcg_gq *new_blkg, *blkg;\n\tbool preloaded;\n\tint ret;\n\tnew_blkg = blkg_alloc(&blkcg_root, q, GFP_KERNEL);\n\tif (!new_blkg)\n\t\treturn -ENOMEM;\n\tpreloaded = !radix_tree_preload(GFP_KERNEL);\n\trcu_read_lock();\n\tspin_lock_irq(q->queue_lock);\n\tblkg = blkg_create(&blkcg_root, q, new_blkg);\n\tspin_unlock_irq(q->queue_lock);\n\trcu_read_unlock();\n\tif (preloaded)\n\t\tradix_tree_preload_end();\n\tif (IS_ERR(blkg)) {\n\t\tblkg_free(new_blkg);\n\t\treturn PTR_ERR(blkg);\n\t}\n\tq->root_blkg = blkg;\n\tq->root_rl.blkg = blkg;\n\tret = blk_throtl_init(q);\n\tif (ret) {\n\t\tspin_lock_irq(q->queue_lock);\n\t\tblkg_destroy_all(q);\n\t\tspin_unlock_irq(q->queue_lock);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "xsltCompilerVarInfoFree(xsltCompilerCtxtPtr cctxt)\n{\n    xsltVarInfoPtr ivar = cctxt->ivars, ivartmp;    \n    while (ivar) {\n\tivartmp = ivar;\n\tivar = ivar->next;\n\txmlFree(ivartmp);\n    }\n}", "target": 0}
{"code": "void vmacache_flush_all(struct mm_struct *mm)\n{\n\tstruct task_struct *g, *p;\n\tcount_vm_vmacache_event(VMACACHE_FULL_FLUSHES);\n\tif (atomic_read(&mm->mm_users) == 1)\n\t\treturn;\n\trcu_read_lock();\n\tfor_each_process_thread(g, p) {\n\t\tif (mm == p->mm)\n\t\t\tvmacache_flush(p);\n\t}\n\trcu_read_unlock();\n}", "target": 1}
{"code": "zrenamefile(i_ctx_t *i_ctx_p)\n{\n    int code;\n    os_ptr op = osp;\n    gs_parsed_file_name_t pname1, pname2;\n    code = parse_real_file_name(op, &pname2, imemory, \"renamefile(to)\");\n    if (code < 0)\n        return code;\n    pname1.fname = 0;\n    code = parse_real_file_name(op - 1, &pname1, imemory, \"renamefile(from)\");\n    if (code >= 0) {\n        gx_io_device *iodev_dflt = iodev_default(imemory);\n        if (pname1.iodev != pname2.iodev ) {\n            if (pname1.iodev == iodev_dflt)\n                pname1.iodev = pname2.iodev;\n            if (pname2.iodev == iodev_dflt)\n                pname2.iodev = pname1.iodev;\n        }\n        if (pname1.iodev != pname2.iodev ||\n            (pname1.iodev == iodev_dflt &&\n              ((check_file_permissions(i_ctx_p, pname1.fname, pname1.len,\n                                        pname1.iodev, \"PermitFileControl\") < 0 &&\n                  !file_is_tempfile(i_ctx_p, op[-1].value.bytes, r_size(op - 1))) ||\n              (check_file_permissions(i_ctx_p, pname2.fname, pname2.len,\n                                        pname2.iodev, \"PermitFileControl\") < 0 ||\n              check_file_permissions(i_ctx_p, pname2.fname, pname2.len,\n                                        pname2.iodev, \"PermitFileWriting\") < 0 )))) {\n            code = gs_note_error(gs_error_invalidfileaccess);\n        } else {\n            code = (*pname1.iodev->procs.rename_file)(pname1.iodev,\n                            pname1.fname, pname2.fname);\n        }\n    }\n    gs_free_file_name(&pname2, \"renamefile(to)\");\n    gs_free_file_name(&pname1, \"renamefile(from)\");\n    if (code < 0)\n        return code;\n    pop(2);\n    return 0;\n}", "target": 0}
{"code": "int wmi_set_ie(struct wil6210_priv *wil, u8 type, u16 ie_len, const void *ie)\n{\n\tstatic const char *const names[] = {\n\t\t[WMI_FRAME_BEACON]\t= \"BEACON\",\n\t\t[WMI_FRAME_PROBE_REQ]\t= \"PROBE_REQ\",\n\t\t[WMI_FRAME_PROBE_RESP]\t= \"WMI_FRAME_PROBE_RESP\",\n\t\t[WMI_FRAME_ASSOC_REQ]\t= \"WMI_FRAME_ASSOC_REQ\",\n\t\t[WMI_FRAME_ASSOC_RESP]\t= \"WMI_FRAME_ASSOC_RESP\",\n\t};\n\tint rc;\n\tu16 len = sizeof(struct wmi_set_appie_cmd) + ie_len;\n\tstruct wmi_set_appie_cmd *cmd = kzalloc(len, GFP_KERNEL);\n\tif (!cmd) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tif (!ie)\n\t\tie_len = 0;\n\tcmd->mgmt_frm_type = type;\n\tcmd->ie_len = cpu_to_le16(ie_len);\n\tmemcpy(cmd->ie_info, ie, ie_len);\n\trc = wmi_send(wil, WMI_SET_APPIE_CMDID, cmd, len);\n\tkfree(cmd);\nout:\n\tif (rc) {\n\t\tconst char *name = type < ARRAY_SIZE(names) ?\n\t\t\t\t   names[type] : \"??\";\n\t\twil_err(wil, \"set_ie(%d %s) failed : %d\\n\", type, name, rc);\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "static u32 apic_get_tmcct(struct kvm_lapic *apic)\n{\n\tktime_t remaining;\n\ts64 ns;\n\tu32 tmcct;\n\tASSERT(apic != NULL);\n\tif (kvm_apic_get_reg(apic, APIC_TMICT) == 0)\n\t\treturn 0;\n\tremaining = hrtimer_get_remaining(&apic->lapic_timer.timer);\n\tif (ktime_to_ns(remaining) < 0)\n\t\tremaining = ktime_set(0, 0);\n\tns = mod_64(ktime_to_ns(remaining), apic->lapic_timer.period);\n\ttmcct = div64_u64(ns,\n\t\t\t (APIC_BUS_CYCLE_NS * apic->divide_count));\n\treturn tmcct;\n}", "target": 1}
{"code": "vhost_user_set_vring_kick(struct virtio_net **pdev, struct VhostUserMsg *pmsg)\n{\n\tstruct vhost_vring_file file;\n\tstruct vhost_virtqueue *vq;\n\tstruct virtio_net *dev = *pdev;\n\tfile.index = pmsg->payload.u64 & VHOST_USER_VRING_IDX_MASK;\n\tif (pmsg->payload.u64 & VHOST_USER_VRING_NOFD_MASK)\n\t\tfile.fd = VIRTIO_INVALID_EVENTFD;\n\telse\n\t\tfile.fd = pmsg->fds[0];\n\tRTE_LOG(INFO, VHOST_CONFIG,\n\t\t\"vring kick idx:%d file:%d\\n\", file.index, file.fd);\n\tdev = translate_ring_addresses(dev, file.index);\n\tif (!dev)\n\t\treturn;\n\t*pdev = dev;\n\tvq = dev->virtqueue[file.index];\n\tif (!(dev->features & (1ULL << VHOST_USER_F_PROTOCOL_FEATURES)))\n\t\tvq->enabled = 1;\n\tif (vq->kickfd >= 0)\n\t\tclose(vq->kickfd);\n\tvq->kickfd = file.fd;\n}", "target": 0}
{"code": "static int __execlists_context_alloc(struct intel_context *ce,\n\t\t\t\t     struct intel_engine_cs *engine)\n{\n\tstruct drm_i915_gem_object *ctx_obj;\n\tstruct intel_ring *ring;\n\tstruct i915_vma *vma;\n\tu32 context_size;\n\tint ret;\n\tGEM_BUG_ON(ce->state);\n\tcontext_size = round_up(engine->context_size, I915_GTT_PAGE_SIZE);\n\tif (IS_ENABLED(CONFIG_DRM_I915_DEBUG_GEM))\n\t\tcontext_size += I915_GTT_PAGE_SIZE; \n\tctx_obj = i915_gem_object_create_shmem(engine->i915, context_size);\n\tif (IS_ERR(ctx_obj))\n\t\treturn PTR_ERR(ctx_obj);\n\tvma = i915_vma_instance(ctx_obj, &engine->gt->ggtt->vm, NULL);\n\tif (IS_ERR(vma)) {\n\t\tret = PTR_ERR(vma);\n\t\tgoto error_deref_obj;\n\t}\n\tif (!ce->timeline) {\n\t\tstruct intel_timeline *tl;\n\t\ttl = intel_timeline_create(engine->gt, NULL);\n\t\tif (IS_ERR(tl)) {\n\t\t\tret = PTR_ERR(tl);\n\t\t\tgoto error_deref_obj;\n\t\t}\n\t\tce->timeline = tl;\n\t}\n\tring = intel_engine_create_ring(engine, (unsigned long)ce->ring);\n\tif (IS_ERR(ring)) {\n\t\tret = PTR_ERR(ring);\n\t\tgoto error_deref_obj;\n\t}\n\tret = populate_lr_context(ce, ctx_obj, engine, ring);\n\tif (ret) {\n\t\tDRM_DEBUG_DRIVER(\"Failed to populate LRC: %d\\n\", ret);\n\t\tgoto error_ring_free;\n\t}\n\tce->ring = ring;\n\tce->state = vma;\n\treturn 0;\nerror_ring_free:\n\tintel_ring_put(ring);\nerror_deref_obj:\n\ti915_gem_object_put(ctx_obj);\n\treturn ret;\n}", "target": 0}
{"code": "int bt_sock_recvmsg(struct socket *sock, struct msghdr *msg, size_t len,\n\t\t    int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tsize_t copied;\n\tsize_t skblen;\n\tint err;\n\tBT_DBG(\"sock %p sk %p len %zu\", sock, sk, len);\n\tif (flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\tskb = skb_recv_datagram(sk, flags, &err);\n\tif (!skb) {\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\tskblen = skb->len;\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (err == 0) {\n\t\tsock_recv_cmsgs(msg, sk, skb);\n\t\tif (msg->msg_name && bt_sk(sk)->skb_msg_name)\n\t\t\tbt_sk(sk)->skb_msg_name(skb, msg->msg_name,\n\t\t\t\t\t\t&msg->msg_namelen);\n\t\tif (test_bit(BT_SK_PKT_STATUS, &bt_sk(sk)->flags)) {\n\t\t\tu8 pkt_status = hci_skb_pkt_status(skb);\n\t\t\tput_cmsg(msg, SOL_BLUETOOTH, BT_SCM_PKT_STATUS,\n\t\t\t\t sizeof(pkt_status), &pkt_status);\n\t\t}\n\t}\n\tskb_free_datagram(sk, skb);\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skblen;\n\treturn err ? : copied;\n}", "target": 1}
{"code": "FILE *mingw_freopen (const char *filename, const char *otype, FILE *stream)\n{\n\tint hide = needs_hiding(filename);\n\tFILE *file;\n\twchar_t wfilename[MAX_PATH], wotype[4];\n\tif (filename && !strcmp(filename, \"/dev/null\"))\n\t\tfilename = \"nul\";\n\tif (xutftowcs_path(wfilename, filename) < 0 ||\n\t\txutftowcs(wotype, otype, ARRAY_SIZE(wotype)) < 0)\n\t\treturn NULL;\n\tif (hide && !access(filename, F_OK) && set_hidden_flag(wfilename, 0)) {\n\t\terror(\"could not unhide %s\", filename);\n\t\treturn NULL;\n\t}\n\tfile = _wfreopen(wfilename, wotype, stream);\n\tif (file && hide && set_hidden_flag(wfilename, 1))\n\t\twarning(\"could not mark '%s' as hidden.\", filename);\n\treturn file;\n}", "target": 0}
{"code": "split_der(asn1buf *buf, uint8_t *const *der, size_t len, taginfo *tag_out)\n{\n    krb5_error_code ret;\n    const uint8_t *contents, *remainder;\n    size_t clen, rlen;\n    ret = get_tag(*der, len, tag_out, &contents, &clen, &remainder, &rlen);\n    if (ret)\n        return ret;\n    if (rlen != 0)\n        return ASN1_BAD_LENGTH;\n    insert_bytes(buf, contents, clen);\n    return 0;\n}", "target": 1}
{"code": "comics_decompress_temp_dir (const gchar *command_decompress_tmp,\n\t\t\t    const gchar *command, \n\t\t\t    GError      **error)\n{\n\tgboolean success;\n\tgchar *std_out, *basename;\n\tGError *err = NULL;\n\tgint retval;\n\tsuccess = g_spawn_command_line_sync (command_decompress_tmp, &std_out, \n\t\t\t\t\t     NULL, &retval, &err);\n\tbasename = g_path_get_basename (command);\n\tif (!success) {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR, \n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"Error launching the command “%s” in order to \"\n\t\t\t     \"decompress the comic book: %s\"),\n\t\t\t     basename,\n\t\t\t     err->message);\n\t\tg_error_free (err);\n\t} else if (WIFEXITED (retval)) {\n\t\tif (WEXITSTATUS (retval) == EXIT_SUCCESS) {\n\t\t\tg_free (std_out);\n\t\t\tg_free (basename);\n\t\t\treturn TRUE;\n\t\t} else {\n\t\t\tg_set_error (error,\n\t\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t\t     _(\"The command “%s” failed at \"\n\t\t\t\t     \"decompressing the comic book.\"),\n\t\t\t\t     basename);\n\t\t\tg_free (std_out);\n\t\t}\n\t} else {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"The command “%s” did not end normally.\"),\n\t\t\t     basename);\n\t\tg_free (std_out);\n\t}\n\tg_free (basename);\n\treturn FALSE;\n}", "target": 1}
{"code": "static int mov_read_SA3D(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    int i, version, type;\n    int ambisonic_order, channel_order, normalization, channel_count;\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams - 1];\n    if (atom.size < 16) {\n        av_log(c->fc, AV_LOG_ERROR, \"SA3D audio box too small\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    version = avio_r8(pb);\n    if (version) {\n        av_log(c->fc, AV_LOG_WARNING, \"Unsupported SA3D box version %d\\n\", version);\n        return 0;\n    }\n    type = avio_r8(pb);\n    if (type) {\n        av_log(c->fc, AV_LOG_WARNING,\n               \"Unsupported ambisonic type %d\\n\", type);\n        return 0;\n    }\n    ambisonic_order = avio_rb32(pb);\n    channel_order = avio_r8(pb);\n    if (channel_order) {\n        av_log(c->fc, AV_LOG_WARNING,\n               \"Unsupported channel_order %d\\n\", channel_order);\n        return 0;\n    }\n    normalization = avio_r8(pb);\n    if (normalization) {\n        av_log(c->fc, AV_LOG_WARNING,\n               \"Unsupported normalization %d\\n\", normalization);\n        return 0;\n    }\n    channel_count = avio_rb32(pb);\n    if (ambisonic_order < 0 || channel_count != (ambisonic_order + 1LL) * (ambisonic_order + 1LL)) {\n        av_log(c->fc, AV_LOG_ERROR,\n               \"Invalid number of channels (%d / %d)\\n\",\n               channel_count, ambisonic_order);\n        return 0;\n    }\n    for (i = 0; i < channel_count; i++) {\n        if (i != avio_rb32(pb)) {\n            av_log(c->fc, AV_LOG_WARNING,\n                   \"Ambisonic channel reordering is not supported\\n\");\n            return 0;\n        }\n    }\n    av_channel_layout_uninit(&st->codecpar->ch_layout);\n    st->codecpar->ch_layout.order = AV_CHANNEL_ORDER_AMBISONIC;\n    st->codecpar->ch_layout.nb_channels = channel_count;\n    return 0;\n}", "target": 0}
{"code": "static RBinElfSymbol *Elf_(r_bin_elf_get_phdr_imports)(ELFOBJ *bin) {\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tif (bin->phdr_imports) {\n\t\treturn bin->phdr_imports;\n\t}\n\tbin->phdr_imports = get_symbols_from_phdr (bin, R_BIN_ELF_IMPORTS);\n\treturn bin->phdr_imports;\n}", "target": 0}
{"code": "devzvol_create(struct vnode *dvp, char *nm, struct vattr *vap, vcexcl_t excl,\n    int mode, struct vnode **vpp, struct cred *cred, int flag,\n    caller_context_t *ct, vsecattr_t *vsecp)\n{\n\tint error;\n\tstruct vnode *vp;\n\t*vpp = NULL;\n\terror = devzvol_lookup(dvp, nm, &vp, NULL, 0, NULL, cred, ct, NULL,\n\t    NULL);\n\tif (error == 0) {\n\t\tif (excl == EXCL)\n\t\t\terror = EEXIST;\n\t\telse if (vp->v_type == VDIR && (mode & VWRITE))\n\t\t\terror = EISDIR;\n\t\telse\n\t\t\terror = VOP_ACCESS(vp, mode, 0, cred, ct);\n\t\tif (error) {\n\t\t\tVN_RELE(vp);\n\t\t} else\n\t\t\t*vpp = vp;\n\t} else if (error == ENOENT) {\n\t\terror = EROFS;\n\t}\n\treturn (error);\n}", "target": 0}
{"code": "ex_put(exarg_T *eap)\n{\n    if (eap->line2 == 0)\n    {\n\teap->line2 = 1;\n\teap->forceit = TRUE;\n    }\n    curwin->w_cursor.lnum = eap->line2;\n    do_put(eap->regname, NULL, eap->forceit ? BACKWARD : FORWARD, 1L,\n\t\t\t\t\t\t       PUT_LINE|PUT_CURSLINE);\n}", "target": 1}
{"code": "void RGWDeleteLC_ObjStore_S3::send_response()\n{\n  if (op_ret == 0)\n      op_ret = STATUS_NO_CONTENT;\n  if (op_ret) {   \n    set_req_state_err(s, op_ret);\n  }\n  dump_errno(s);\n  end_header(s, this, \"application/xml\");\n  dump_start(s);\n}", "target": 0}
{"code": "void exit_io_context(void)\n{\n\tstruct io_context *ioc;\n\ttask_lock(current);\n\tioc = current->io_context;\n\tcurrent->io_context = NULL;\n\ttask_unlock(current);\n\tif (atomic_dec_and_test(&ioc->nr_tasks)) {\n\t\tif (ioc->aic && ioc->aic->exit)\n\t\t\tioc->aic->exit(ioc->aic);\n\t\tcfq_exit(ioc);\n\t\tput_io_context(ioc);\n\t}\n}", "target": 1}
{"code": "void init_xml_relax_ng()\n{\n  VALUE nokogiri = rb_define_module(\"Nokogiri\");\n  VALUE xml = rb_define_module_under(nokogiri, \"XML\");\n  VALUE klass = rb_define_class_under(xml, \"RelaxNG\", cNokogiriXmlSchema);\n  cNokogiriXmlRelaxNG = klass;\n  rb_define_singleton_method(klass, \"read_memory\", read_memory, 1);\n  rb_define_singleton_method(klass, \"from_document\", from_document, 1);\n  rb_define_private_method(klass, \"validate_document\", validate_document, 1);\n}", "target": 1}
{"code": "trigger_winclosed(win_T *win)\n{\n    static int\trecursive = FALSE;\n    char_u\twinid[NUMBUFLEN];\n    if (recursive)\n\treturn;\n    recursive = TRUE;\n    vim_snprintf((char *)winid, sizeof(winid), \"%i\", win->w_id);\n    apply_autocmds(EVENT_WINCLOSED, winid, winid, FALSE, win->w_buffer);\n    recursive = FALSE;\n}", "target": 0}
{"code": "resolve_superior_type_check(struct lys_type *type)\n{\n    uint32_t i;\n    if (type->base == LY_TYPE_DER) {\n        return EXIT_FAILURE;\n    } else if (type->base == LY_TYPE_UNION) {\n        for (i = 0; i < type->info.uni.count; ++i) {\n            if (resolve_superior_type_check(&type->info.uni.types[i])) {\n                return EXIT_FAILURE;\n            }\n        }\n    } else if (type->base == LY_TYPE_LEAFREF) {\n        while (!type->info.lref.path) {\n            assert(type->der);\n            type = &type->der->type;\n        }\n    }\n    return EXIT_SUCCESS;\n}", "target": 0}
{"code": "void out_string(conn *c, const char *str) {\n    size_t len;\n    mc_resp *resp = c->resp;\n    assert(c != NULL);\n    resp_reset(resp);\n    if (c->noreply) {\n        resp->skip = true;\n        if (settings.verbose > 1)\n            fprintf(stderr, \">%d NOREPLY %s\\n\", c->sfd, str);\n        conn_set_state(c, conn_new_cmd);\n        return;\n    }\n    if (settings.verbose > 1)\n        fprintf(stderr, \">%d %s\\n\", c->sfd, str);\n    len = strlen(str);\n    if ((len + 2) > WRITE_BUFFER_SIZE) {\n        str = \"SERVER_ERROR output line too long\";\n        len = strlen(str);\n    }\n    memcpy(resp->wbuf, str, len);\n    memcpy(resp->wbuf + len, \"\\r\\n\", 2);\n    resp_add_iov(resp, resp->wbuf, len + 2);\n    conn_set_state(c, conn_new_cmd);\n    return;\n}", "target": 1}
{"code": "mm_compare(struct mm_share *a, struct mm_share *b)\n{\n\tptrdiff_t diff = (char *)a->address - (char *)b->address;\n\tif (diff == 0)\n\t\treturn (0);\n\telse if (diff < 0)\n\t\treturn (-1);\n\telse\n\t\treturn (1);\n}", "target": 1}
{"code": "void streamGetEdgeID(stream *s, int first, int skip_tombstones, streamID *edge_id)\n{\n    streamIterator si;\n    int64_t numfields;\n    streamIteratorStart(&si,s,NULL,NULL,!first);\n    si.skip_tombstones = skip_tombstones;\n    int found = streamIteratorGetID(&si,edge_id,&numfields);\n    if (!found) {\n        streamID min_id = {0, 0}, max_id = {UINT64_MAX, UINT64_MAX};\n        *edge_id = first ? max_id : min_id;\n    }\n}", "target": 1}
{"code": "static void singlevar (LexState *ls, expdesc *var) {\n  TString *varname = str_checkname(ls);\n  FuncState *fs = ls->fs;\n  singlevaraux(fs, varname, var, 1);\n  if (var->k == VVOID) {  \n    expdesc key;\n    singlevaraux(fs, ls->envn, var, 1);  \n    lua_assert(var->k != VVOID);  \n    codestring(&key, varname);  \n    luaK_indexed(fs, var, &key);  \n  }\n}", "target": 1}
{"code": "static void FillRectangle(rfbClient* client, int x, int y, int w, int h, uint32_t colour) {\n  int i,j;\n#define FILL_RECT(BPP) \\\n    for(j=y*client->width;j<(y+h)*client->width;j+=client->width) \\\n      for(i=x;i<x+w;i++) \\\n\t((uint##BPP##_t*)client->frameBuffer)[j+i]=colour;\n  switch(client->format.bitsPerPixel) {\n  case  8: FILL_RECT(8);  break;\n  case 16: FILL_RECT(16); break;\n  case 32: FILL_RECT(32); break;\n  default:\n    rfbClientLog(\"Unsupported bitsPerPixel: %d\\n\",client->format.bitsPerPixel);\n  }\n}", "target": 0}
{"code": "static PHP_NAMED_FUNCTION(zif_zip_entry_read)\n{\n\tzval * zip_entry;\n\tzend_long len = 0;\n\tzip_read_rsrc * zr_rsrc;\n\tzend_string *buffer;\n\tint n = 0;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"r|l\", &zip_entry, &len) == FAILURE) {\n\t\treturn;\n\t}\n\tif ((zr_rsrc = (zip_read_rsrc *)zend_fetch_resource(Z_RES_P(zip_entry), le_zip_entry_name, le_zip_entry)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tif (len <= 0) {\n\t\tlen = 1024;\n\t}\n\tif (zr_rsrc->zf) {\n\t\tbuffer = zend_string_alloc(len, 0);\n\t\tn = zip_fread(zr_rsrc->zf, ZSTR_VAL(buffer), ZSTR_LEN(buffer));\n\t\tif (n > 0) {\n\t\t\tZSTR_VAL(buffer)[n] = '\\0';\n\t\t\tZSTR_LEN(buffer) = n;\n\t\t\tRETURN_NEW_STR(buffer);\n\t\t} else {\n\t\t\tzend_string_free(buffer);\n\t\t\tRETURN_EMPTY_STRING()\n\t\t}\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}", "target": 1}
{"code": "void Shell::OnAppTerminating() {\n  FOR_EACH_OBSERVER(ShellObserver, observers_, OnAppTerminating());\n}", "target": 0}
{"code": "op_reindent(oparg_T *oap, int (*how)(void))\n{\n    long\ti = 0;\n    char_u\t*l;\n    int\t\tamount;\n    linenr_T\tfirst_changed = 0;\n    linenr_T\tlast_changed = 0;\n    linenr_T\tstart_lnum = curwin->w_cursor.lnum;\n    if (!curbuf->b_p_ma)\n    {\n\temsg(_(e_cannot_make_changes_modifiable_is_off));\n\treturn;\n    }\n    if (u_savecommon(start_lnum - 1, start_lnum + oap->line_count,\n\t\t\t\t     start_lnum + oap->line_count, FALSE) == OK)\n\tfor (i = oap->line_count; --i >= 0 && !got_int; )\n\t{\n\t    if (i > 1\n\t\t    && (i % 50 == 0 || i == oap->line_count - 1)\n\t\t    && oap->line_count > p_report)\n\t\tsmsg(_(\"%ld lines to indent... \"), i);\n\t    if (i != oap->line_count - 1 || oap->line_count == 1\n\t\t\t\t\t\t     || how != get_lisp_indent)\n\t    {\n\t\tl = skipwhite(ml_get_curline());\n\t\tif (*l == NUL)\t\t    \n\t\t    amount = 0;\n\t\telse\n\t\t    amount = how();\t    \n\t\tif (amount >= 0 && set_indent(amount, 0))\n\t\t{\n\t\t    if (first_changed == 0)\n\t\t\tfirst_changed = curwin->w_cursor.lnum;\n\t\t    last_changed = curwin->w_cursor.lnum;\n\t\t}\n\t    }\n\t    ++curwin->w_cursor.lnum;\n\t    curwin->w_cursor.col = 0;  \n\t}\n    curwin->w_cursor.lnum = start_lnum;\n    beginline(BL_SOL | BL_FIX);\n    if (last_changed != 0)\n\tchanged_lines(first_changed, 0,\n\t\toap->is_VIsual ? start_lnum + oap->line_count :\n\t\tlast_changed + 1, 0L);\n    else if (oap->is_VIsual)\n\tredraw_curbuf_later(INVERTED);\n    if (oap->line_count > p_report)\n    {\n\ti = oap->line_count - (i + 1);\n\tsmsg(NGETTEXT(\"%ld line indented \",\n\t\t\t\t\t\t \"%ld lines indented \", i), i);\n    }\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\tcurbuf->b_op_start = oap->start;\n\tcurbuf->b_op_end = oap->end;\n    }\n}", "target": 0}
{"code": "struct nfc_llcp_local *nfc_llcp_find_local(struct nfc_dev *dev)\n{\n\tstruct nfc_llcp_local *local;\n\tlist_for_each_entry(local, &llcp_devices, list)\n\t\tif (local->dev == dev)\n\t\t\treturn local;\n\tpr_debug(\"No device found\\n\");\n\treturn NULL;\n}", "target": 1}
{"code": "string Print(const FunctionDef& fdef) {\n  string out;\n  const OpDef& sig = fdef.signature();\n  strings::StrAppend(&out, \"\\n\", sig.name());\n  if (sig.attr_size() > 0) {\n    strings::StrAppend(&out, \"[\");\n    for (int i = 0; i < sig.attr_size(); ++i) {\n      const auto& a = sig.attr(i);\n      if (i > 0) strings::StrAppend(&out, \", \");\n      if (a.type() == \"type\") {\n        strings::StrAppend(&out, a.name(), \":\", Print(a.allowed_values()));\n      } else {\n        strings::StrAppend(&out, a.name(), \":\", a.type());\n      }\n    }\n    strings::StrAppend(&out, \"]\");\n  }\n  strings::StrAppend(&out, \"(\");\n  for (int i = 0; i < sig.input_arg_size(); ++i) {\n    if (i > 0) strings::StrAppend(&out, \", \");\n    strings::StrAppend(&out, Print(sig.input_arg(i)));\n  }\n  strings::StrAppend(&out, \") -> (\");\n  for (int i = 0; i < sig.output_arg_size(); ++i) {\n    if (i > 0) strings::StrAppend(&out, \", \");\n    strings::StrAppend(&out, Print(sig.output_arg(i)));\n  }\n  strings::StrAppend(&out, \") {\\n\");\n  for (const auto& n : fdef.node_def()) {\n    strings::StrAppend(&out, \"  \", Print(n), \"\\n\");\n  }\n  for (const auto& cr : fdef.control_ret()) {\n    strings::StrAppend(&out, \"  @return \", cr.first, \" = \", cr.second, \"\\n\");\n  }\n  for (const auto& r : fdef.ret()) {\n    strings::StrAppend(&out, \"  return \", r.first, \" = \", r.second, \"\\n\");\n  }\n  strings::StrAppend(&out, \"}\\n\");\n  return out;\n}", "target": 0}
{"code": "static void compact(VarEnv* v, Array &ret, const Variant& var) {\n  if (var.isArray()) {\n    for (ArrayIter iter(var.getArrayData()); iter; ++iter) {\n      compact(v, ret, iter.second());\n    }\n  } else {\n    String varname = var.toString();\n    if (!varname.empty() && v->lookup(varname.get()) != NULL) {\n      ret.set(varname, *reinterpret_cast<Variant*>(v->lookup(varname.get())));\n    }\n  }\n}", "target": 1}
{"code": "static int hash_setkey(void *private, const u8 *key, unsigned int keylen)\n{\n\treturn crypto_ahash_setkey(private, key, keylen);\n}", "target": 0}
{"code": "static void ip_cmsg_recv_checksum(struct msghdr *msg, struct sk_buff *skb,\n\t\t\t\t  int tlen, int offset)\n{\n\t__wsum csum = skb->csum;\n\tif (skb->ip_summed != CHECKSUM_COMPLETE)\n\t\treturn;\n\tif (offset != 0)\n\t\tcsum = csum_sub(csum,\n\t\t\t\tcsum_partial(skb_transport_header(skb) + tlen,\n\t\t\t\t\t     offset, 0));\n\tput_cmsg(msg, SOL_IP, IP_CHECKSUM, sizeof(__wsum), &csum);\n}", "target": 1}
{"code": "void PDPSimple::notifyAboveRemoteEndpoints(\n        const ParticipantProxyData& pdata)\n{\n    if (mp_EDP != nullptr)\n    {\n        mp_EDP->assignRemoteEndpoints(pdata);\n    }\n    if (mp_builtin->mp_WLP != nullptr)\n    {\n        mp_builtin->mp_WLP->assignRemoteEndpoints(pdata);\n    }\n    if (mp_builtin->tlm_ != nullptr)\n    {\n        mp_builtin->tlm_->assign_remote_endpoints(pdata);\n    }\n}", "target": 1}
{"code": "ssh_scp ssh_scp_new(ssh_session session, int mode, const char *location)\n{\n    ssh_scp scp = NULL;\n    if (session == NULL) {\n        goto error;\n    }\n    scp = (ssh_scp)calloc(1, sizeof(struct ssh_scp_struct));\n    if (scp == NULL) {\n        ssh_set_error(session, SSH_FATAL,\n                      \"Error allocating memory for ssh_scp\");\n        goto error;\n    }\n    if ((mode & ~SSH_SCP_RECURSIVE) != SSH_SCP_WRITE &&\n        (mode & ~SSH_SCP_RECURSIVE) != SSH_SCP_READ)\n    {\n        ssh_set_error(session, SSH_FATAL,\n                      \"Invalid mode %d for ssh_scp_new()\", mode);\n        goto error;\n    }\n    scp->location = strdup(location);\n    if (scp->location == NULL) {\n        ssh_set_error(session, SSH_FATAL,\n                      \"Error allocating memory for ssh_scp\");\n        goto error;\n    }\n    scp->session = session;\n    scp->mode = mode & ~SSH_SCP_RECURSIVE;\n    scp->recursive = (mode & SSH_SCP_RECURSIVE) != 0;\n    scp->channel = NULL;\n    scp->state = SSH_SCP_NEW;\n    return scp;\nerror:\n    ssh_scp_free(scp);\n    return NULL;\n}", "target": 1}
{"code": "void ConnectDialog::lookedUp() {\n\tServerResolver *sr = qobject_cast<ServerResolver *>(QObject::sender());\n\tsr->deleteLater();\n\tQString hostname = sr->hostname().toLower();\n\tunsigned short port = sr->port();\n\tUnresolvedServerAddress unresolved(hostname, port);\n\tqsDNSActive.remove(unresolved);\n\tif (sr->records().size() == 0) {\n\t\treturn;\n\t}\n\tQSet<ServerAddress> qs;\n\tforeach (ServerResolverRecord record, sr->records()) {\n\t\tforeach(const HostAddress &ha, record.addresses()) {\n\t\t\tqs.insert(ServerAddress(ha, record.port()));\n\t\t}\n\t}\n\tQSet<ServerItem *> waiting = qhDNSWait[unresolved];\n\tforeach(ServerItem *si, waiting) {\n\t\tforeach (const ServerAddress &addr, qs) {\n\t\t\tqhPings[addr].insert(si);\n\t\t}\n\t\tsi->qlAddresses = qs.toList();\n\t}\n\tqlDNSLookup.removeAll(unresolved);\n\tqhDNSCache.insert(unresolved, qs.toList());\n\tqhDNSWait.remove(unresolved);\n\tforeach(ServerItem *si, waiting) {\n\t\tif (si == qtwServers->currentItem()) {\n\t\t\ton_qtwServers_currentItemChanged(si, si);\n\t\t\tif (si == siAutoConnect)\n\t\t\t\taccept();\n\t\t}\n\t}\n\tif (bAllowPing) {\n\t\tforeach(const ServerAddress &addr, qs) {\n\t\t\tsendPing(addr.host.toAddress(), addr.port);\n\t\t}\n\t}\n}", "target": 0}
{"code": "_gnutls_server_name_recv_params (gnutls_session_t session,\n\t\t\t\t const opaque * data, size_t _data_size)\n{\n  int i;\n  const unsigned char *p;\n  uint16_t len, type;\n  ssize_t data_size = _data_size;\n  int server_names = 0;\n  if (session->security_parameters.entity == GNUTLS_SERVER)\n    {\n      DECR_LENGTH_RET (data_size, 2, 0);\n      len = _gnutls_read_uint16 (data);\n      if (len != data_size)\n\t{\n\t  gnutls_assert ();\n\t  return 0;\n\t}\n      p = data + 2;\n      while (data_size > 0)\n\t{\n\t  DECR_LENGTH_RET (data_size, 1, 0);\n\t  p++;\n\t  DECR_LEN (data_size, 2);\n\t  len = _gnutls_read_uint16 (p);\n\t  p += 2;\n\t  DECR_LENGTH_RET (data_size, len, 0);\n\t  server_names++;\n\t  p += len;\n\t}\n      session->security_parameters.extensions.server_names_size =\n\tserver_names;\n      if (server_names == 0)\n\treturn 0;\t\t\n      if (server_names > MAX_SERVER_NAME_EXTENSIONS)\n\tserver_names = MAX_SERVER_NAME_EXTENSIONS;\n      p = data + 2;\n      for (i = 0; i < server_names; i++)\n\t{\n\t  type = *p;\n\t  p++;\n\t  len = _gnutls_read_uint16 (p);\n\t  p += 2;\n\t  switch (type)\n\t    {\n\t    case 0:\t\t\n\t      if (len <= MAX_SERVER_NAME_SIZE)\n\t\t{\n\t\t  memcpy (session->security_parameters.extensions.\n\t\t\t  server_names[i].name, p, len);\n\t\t  session->security_parameters.extensions.\n\t\t    server_names[i].name_length = len;\n\t\t  session->security_parameters.extensions.\n\t\t    server_names[i].type = GNUTLS_NAME_DNS;\n\t\t  break;\n\t\t}\n\t    }\n\t  p += len;\n\t}\n    }\n  return 0;\n}", "target": 1}
{"code": "int dns_HTTPS_add_ipv6hint(struct dns_rr_nested *svcparam, unsigned char addr[][DNS_RR_AAAA_LEN], int addr_num)\n{\n\tif (_dns_left_len(&svcparam->context) < 4 + addr_num * DNS_RR_AAAA_LEN) {\n\t\treturn -1;\n\t}\n\tunsigned short value = DNS_HTTPS_T_IPV6HINT;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\tvalue = addr_num * DNS_RR_AAAA_LEN;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\tfor (int i = 0; i < addr_num; i++) {\n\t\tdns_add_rr_nested_memcpy(svcparam, addr[i], DNS_RR_AAAA_LEN);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n{\n\tLIST_HEAD(tmp_list);\n\tstruct mount *p;\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_mount_unlock(mnt);\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tp->mnt.mnt_flags |= MNT_UMOUNT;\n\t\tlist_move(&p->mnt_list, &tmp_list);\n\t}\n\tlist_for_each_entry(p, &tmp_list, mnt_list) {\n\t\tlist_del_init(&p->mnt_child);\n\t}\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_umount(&tmp_list);\n\twhile (!list_empty(&tmp_list)) {\n\t\tbool disconnect;\n\t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n\t\tlist_del_init(&p->mnt_expire);\n\t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n\t\tif (how & UMOUNT_SYNC)\n\t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\t\tdisconnect = disconnect_mount(p, how);\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,\n\t\t\t\t disconnect ? &unmounted : NULL);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tif (!disconnect) {\n\t\t\t\tlist_add_tail(&p->mnt_child, &p->mnt_parent->mnt_mounts);\n\t\t\t} else {\n\t\t\t\tumount_mnt(p);\n\t\t\t}\n\t\t}\n\t\tchange_mnt_propagation(p, MS_PRIVATE);\n\t}\n}", "target": 1}
{"code": "static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next,\n\t\t\t     struct task_struct *tsk)\n{\n\tunsigned cpu = smp_processor_id();\n\tif (likely(prev != next)) {\n#ifdef CONFIG_SMP\n\t\tthis_cpu_write(cpu_tlbstate.state, TLBSTATE_OK);\n\t\tthis_cpu_write(cpu_tlbstate.active_mm, next);\n#endif\n\t\tcpumask_set_cpu(cpu, mm_cpumask(next));\n\t\tload_cr3(next->pgd);\n\t\ttrace_tlb_flush(TLB_FLUSH_ON_TASK_SWITCH, TLB_FLUSH_ALL);\n\t\tcpumask_clear_cpu(cpu, mm_cpumask(prev));\n\t\tload_mm_cr4(next);\n#ifdef CONFIG_MODIFY_LDT_SYSCALL\n\t\tif (unlikely(prev->context.ldt != next->context.ldt))\n\t\t\tload_mm_ldt(next);\n#endif\n\t}\n#ifdef CONFIG_SMP\n\t  else {\n\t\tthis_cpu_write(cpu_tlbstate.state, TLBSTATE_OK);\n\t\tBUG_ON(this_cpu_read(cpu_tlbstate.active_mm) != next);\n\t\tif (!cpumask_test_cpu(cpu, mm_cpumask(next))) {\n\t\t\tcpumask_set_cpu(cpu, mm_cpumask(next));\n\t\t\tload_cr3(next->pgd);\n\t\t\ttrace_tlb_flush(TLB_FLUSH_ON_TASK_SWITCH, TLB_FLUSH_ALL);\n\t\t\tload_mm_cr4(next);\n\t\t\tload_mm_ldt(next);\n\t\t}\n\t}\n#endif\n}", "target": 1}
{"code": "static inline bool cfs_rq_is_decayed(struct cfs_rq *cfs_rq)\n{\n\tif (cfs_rq->load.weight)\n\t\treturn false;\n\tif (cfs_rq->avg.load_sum)\n\t\treturn false;\n\tif (cfs_rq->avg.util_sum)\n\t\treturn false;\n\tif (cfs_rq->avg.runnable_load_sum)\n\t\treturn false;\n\treturn true;\n}", "target": 1}
{"code": "void *TrustedPrimitives::UntrustedLocalAlloc(size_t size) noexcept {\n  void *result;\n  CHECK_OCALL(\n      ocall_untrusted_local_alloc(&result, static_cast<uint64_t>(size)));\n  if (result && !IsOutsideEnclave(result, static_cast<uint64_t>(size))) {\n    TrustedPrimitives::BestEffortAbort(\n        \"Allocated memory not found to be outside the enclave.\");\n  }\n  if (!result) {\n    errno = ENOMEM;\n    TrustedPrimitives::DebugPuts(\"UntrustedLocalAlloc on SGX failed.\");\n  }\n  return result;\n}", "target": 0}
{"code": "xface2xpm(char *xface)\n{\n    Image image;\n    ImageCache *cache;\n    FILE *f;\n    struct stat st;\n    SKIP_BLANKS(xface);\n    image.url = xface;\n    image.ext = \".xpm\";\n    image.width = 48;\n    image.height = 48;\n    image.cache = NULL;\n    cache = getImage(&image, NULL, IMG_FLAG_AUTO);\n    if (cache->loaded & IMG_FLAG_LOADED && !stat(cache->file, &st))\n\treturn cache->file;\n    cache->loaded = IMG_FLAG_ERROR;\n    f = popen(Sprintf(\"%s > %s\", shell_quote(auxbinFile(XFACE2XPM)),\n\t\t      shell_quote(cache->file))->ptr, \"w\");\n    if (!f)\n\treturn NULL;\n    fputs(xface, f);\n    pclose(f);\n    if (stat(cache->file, &st) || !st.st_size)\n\treturn NULL;\n    cache->loaded = IMG_FLAG_LOADED | IMG_FLAG_DONT_REMOVE;\n    cache->index = 0;\n    return cache->file;\n}", "target": 0}
{"code": "int fcntl_dirnotify(int fd, struct file *filp, unsigned long arg)\n{\n\tstruct dnotify_struct *dn;\n\tstruct dnotify_struct *odn;\n\tstruct dnotify_struct **prev;\n\tstruct inode *inode;\n\tfl_owner_t id = current->files;\n\tint error = 0;\n\tif ((arg & ~DN_MULTISHOT) == 0) {\n\t\tdnotify_flush(filp, id);\n\t\treturn 0;\n\t}\n\tif (!dir_notify_enable)\n\t\treturn -EINVAL;\n\tinode = filp->f_path.dentry->d_inode;\n\tif (!S_ISDIR(inode->i_mode))\n\t\treturn -ENOTDIR;\n\tdn = kmem_cache_alloc(dn_cache, GFP_KERNEL);\n\tif (dn == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock(&inode->i_lock);\n\tprev = &inode->i_dnotify;\n\twhile ((odn = *prev) != NULL) {\n\t\tif ((odn->dn_owner == id) && (odn->dn_filp == filp)) {\n\t\t\todn->dn_fd = fd;\n\t\t\todn->dn_mask |= arg;\n\t\t\tinode->i_dnotify_mask |= arg & ~DN_MULTISHOT;\n\t\t\tgoto out_free;\n\t\t}\n\t\tprev = &odn->dn_next;\n\t}\n\terror = __f_setown(filp, task_pid(current), PIDTYPE_PID, 0);\n\tif (error)\n\t\tgoto out_free;\n\tdn->dn_mask = arg;\n\tdn->dn_fd = fd;\n\tdn->dn_filp = filp;\n\tdn->dn_owner = id;\n\tinode->i_dnotify_mask |= arg & ~DN_MULTISHOT;\n\tdn->dn_next = inode->i_dnotify;\n\tinode->i_dnotify = dn;\n\tspin_unlock(&inode->i_lock);\n\tif (filp->f_op && filp->f_op->dir_notify)\n\t\treturn filp->f_op->dir_notify(filp, arg);\n\treturn 0;\nout_free:\n\tspin_unlock(&inode->i_lock);\n\tkmem_cache_free(dn_cache, dn);\n\treturn error;\n}", "target": 1}
{"code": "gxps_images_guess_content_type (GXPSArchive *zip,\n\t\t\t\tconst gchar *image_uri)\n{\n\tGInputStream *stream;\n\tguchar        buffer[1024];\n\tgssize        bytes_read;\n\tgchar        *mime_type;\n\tstream = gxps_archive_open (zip, image_uri);\n\tif (!stream)\n\t\treturn NULL;\n\tbytes_read = g_input_stream_read (stream, buffer, 1024, NULL, NULL);\n\tmime_type = g_content_type_guess (NULL, buffer, bytes_read, NULL);\n\tg_object_unref (stream);\n\treturn mime_type;\n}", "target": 0}
{"code": "iasecc_init_amos_or_sagem(struct sc_card *card)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tunsigned int flags;\n\tint rv = 0;\n\tLOG_FUNC_CALLED(ctx);\n\tflags = IASECC_CARD_DEFAULT_FLAGS;\n\t_sc_card_add_rsa_alg(card, 1024, flags, 0x10001);\n\t_sc_card_add_rsa_alg(card, 2048, flags, 0x10001);\n\tcard->caps = IASECC_CARD_DEFAULT_CAPS;\n\tif (card->type == SC_CARD_TYPE_IASECC_MI)   {\n\t\trv = iasecc_mi_match(card);\n\t\tif (rv)\n\t\t\tcard->type = SC_CARD_TYPE_IASECC_MI2;\n\t\telse\n\t\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\t}\n\trv = iasecc_parse_ef_atr(card);\n\tif (rv == SC_ERROR_FILE_NOT_FOUND)   {\n\t\trv = iasecc_select_mf(card, NULL);\n\t\tLOG_TEST_RET(ctx, rv, \"MF selection error\");\n\t\trv = iasecc_parse_ef_atr(card);\n\t}\n\tLOG_TEST_RET(ctx, rv, \"IASECC: ATR parse failed\");\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}", "target": 0}
{"code": "void Hybrid_type_traits_decimal::set_zero(Hybrid_type *val) const\n{\n  my_decimal_set_zero(&val->dec_buf[0]);\n  val->used_dec_buf_no= 0;\n}", "target": 0}
{"code": "get_supported_image_extensions(void)\n{\n\tGSList *extensions = NULL;\n\tGSList *formats = gdk_pixbuf_get_formats ();\n\tGSList *l;\n\tfor (l = formats; l != NULL; l = l->next) {\n\t\tint i;\n\t\tgchar **ext = gdk_pixbuf_format_get_extensions (l->data);\n\t\tfor (i = 0; ext[i] != NULL; i++) {\n\t\t\textensions = g_slist_append (extensions,\n\t\t\t\t\t\t     g_strdup (ext[i]));\n\t\t}\n\t\tg_strfreev (ext);\n\t}\n\tg_slist_free (formats);\n\treturn extensions;\n}", "target": 1}
{"code": "static int skcipher_wait_for_wmem(struct sock *sk, unsigned flags)\n{\n\tlong timeout;\n\tDEFINE_WAIT(wait);\n\tint err = -ERESTARTSYS;\n\tif (flags & MSG_DONTWAIT)\n\t\treturn -EAGAIN;\n\tsk_set_bit(SOCKWQ_ASYNC_NOSPACE, sk);\n\tfor (;;) {\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\tprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\t\ttimeout = MAX_SCHEDULE_TIMEOUT;\n\t\tif (sk_wait_event(sk, &timeout, skcipher_writable(sk))) {\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfinish_wait(sk_sleep(sk), &wait);\n\treturn err;\n}", "target": 0}
{"code": "void ok_inflater_free(ok_inflater *inflater) {\n    if (inflater) {\n        ok_png_allocator allocator = inflater->allocator;\n        void *allocator_user_data = inflater->allocator_user_data;\n        allocator.free(allocator_user_data, inflater->buffer);\n        allocator.free(allocator_user_data, inflater->code_length_huffman);\n        allocator.free(allocator_user_data, inflater->literal_huffman);\n        allocator.free(allocator_user_data, inflater->distance_huffman);\n        allocator.free(allocator_user_data, inflater->fixed_literal_huffman);\n        allocator.free(allocator_user_data, inflater->fixed_distance_huffman);\n        allocator.free(allocator_user_data, inflater);\n    }\n}", "target": 0}
{"code": "exo_open_find_scheme (const gchar *string)\n{\n  gchar *current_dir;\n  gchar *uri;\n  gchar *path;\n  if (g_path_is_absolute (string))\n    return exo_open_get_path (string);\n  current_dir = g_get_current_dir ();\n  path = g_build_filename (current_dir, string, NULL);\n  g_free (current_dir);\n  if (g_file_test (path, G_FILE_TEST_EXISTS))\n    {\n       uri = exo_open_get_path (path);\n       g_free (path);\n       return uri;\n    }\n  g_free (path);\n  if (g_regex_match_simple (MATCH_PATTERN_EMAIL, string, G_REGEX_CASELESS, 0))\n    return g_strconcat (\"mailto:\", string, NULL);\n  if (g_regex_match_simple (MATCH_PATTERN_HTTP, string, G_REGEX_CASELESS, 0))\n    return g_strconcat (\"http:\n  return NULL;\n}", "target": 0}
{"code": "int fuse_fs_write(struct fuse_fs *fs, const char *path, const char *buf,\n                  size_t size, off_t off, struct fuse_file_info *fi)\n{\n    fuse_get_context()->private_data = fs->user_data;\n    if (fs->op.write)\n        return fs->op.write(path, buf, size, off, fi);\n    else\n        return -ENOSYS;\n}", "target": 0}
{"code": "static int __init cpia2_init(void)\n{\n\tLOG(\"%s v%s\\n\",\n\t    ABOUT, CPIA_VERSION);\n\tcheck_parameters();\n\tcpia2_usb_init();\n\treturn 0;\n}", "target": 1}
{"code": "server_request_direct_streamlocal(void)\n{\n\tChannel *c = NULL;\n\tchar *target, *originator;\n\tu_short originator_port;\n\ttarget = packet_get_string(NULL);\n\toriginator = packet_get_string(NULL);\n\toriginator_port = packet_get_int();\n\tpacket_check_eom();\n\tdebug(\"server_request_direct_streamlocal: originator %s port %d, target %s\",\n\t    originator, originator_port, target);\n\tif ((options.allow_streamlocal_forwarding & FORWARD_LOCAL) != 0 &&\n\t    !no_port_forwarding_flag && !options.disable_forwarding) {\n\t\tc = channel_connect_to_path(target,\n\t\t    \"direct-streamlocal@openssh.com\", \"direct-streamlocal\");\n\t} else {\n\t\tlogit(\"refused streamlocal port forward: \"\n\t\t    \"originator %s port %d, target %s\",\n\t\t    originator, originator_port, target);\n\t}\n\tfree(originator);\n\tfree(target);\n\treturn c;\n}", "target": 1}
{"code": "InlineBoxPosition AdjustInlineBoxPositionForTextDirection(\n    InlineBox* inline_box,\n    int caret_offset,\n    UnicodeBidi unicode_bidi,\n    TextDirection primary_direction) {\n  if (inline_box->Direction() == primary_direction)\n    return AdjustInlineBoxPositionForPrimaryDirection(inline_box, caret_offset);\n  const unsigned char level = inline_box->BidiLevel();\n  if (caret_offset == inline_box->CaretLeftmostOffset()) {\n    InlineBox* const prev_box = inline_box->PrevLeafChildIgnoringLineBreak();\n    if (!prev_box || prev_box->BidiLevel() < level) {\n      InlineBox* const result_box =\n          InlineBoxTraversal::FindRightBoundaryOfEntireBidiRunIgnoringLineBreak(\n              *inline_box, level);\n      return InlineBoxPosition(result_box, result_box->CaretRightmostOffset());\n    }\n    if (prev_box->BidiLevel() <= level)\n      return InlineBoxPosition(inline_box, caret_offset);\n    InlineBox* const result_box =\n        InlineBoxTraversal::FindLeftBoundaryOfBidiRunIgnoringLineBreak(\n            *inline_box, level);\n    return InlineBoxPosition(result_box, result_box->CaretLeftmostOffset());\n  }\n  if (unicode_bidi == UnicodeBidi::kPlaintext) {\n    if (inline_box->BidiLevel() < level)\n      return InlineBoxPosition(inline_box, inline_box->CaretLeftmostOffset());\n    return InlineBoxPosition(inline_box, inline_box->CaretRightmostOffset());\n  }\n  InlineBox* const next_box = inline_box->NextLeafChildIgnoringLineBreak();\n  if (!next_box || next_box->BidiLevel() < level) {\n    InlineBox* const result_box =\n        InlineBoxTraversal::FindLeftBoundaryOfEntireBidiRunIgnoringLineBreak(\n            *inline_box, level);\n    return InlineBoxPosition(result_box, result_box->CaretLeftmostOffset());\n  }\n  if (next_box->BidiLevel() <= level)\n    return InlineBoxPosition(inline_box, caret_offset);\n  InlineBox* const result_box =\n      InlineBoxTraversal::FindRightBoundaryOfBidiRunIgnoringLineBreak(\n          *inline_box, level);\n  return InlineBoxPosition(result_box, result_box->CaretRightmostOffset());\n}", "target": 0}
{"code": "static inline bool is_flush_request(struct request *rq,\n\t\tstruct blk_flush_queue *fq, unsigned int tag)\n{\n\treturn ((rq->cmd_flags & REQ_FLUSH_SEQ) &&\n\t\t\tfq->flush_rq->tag == tag);\n}", "target": 1}
{"code": "prefix_code(uint8_t *data, size_t size)\n{\n\tif (size > 3 && data[0] == ' ' && data[1] == ' '\n\t\t&& data[2] == ' ' && data[3] == ' ') return 4;\n\treturn 0;\n}", "target": 0}
{"code": "str2special(\n    char_u\t**sp,\n    int\t\tfrom)\t\n{\n    int\t\t\tc;\n    static char_u\tbuf[7];\n    char_u\t\t*str = *sp;\n    int\t\t\tmodifiers = 0;\n    int\t\t\tspecial = FALSE;\n    if (has_mbyte)\n    {\n\tchar_u\t*p;\n\tp = mb_unescape(sp);\n\tif (p != NULL)\n\t    return p;\n    }\n    c = *str;\n    if (c == K_SPECIAL && str[1] != NUL && str[2] != NUL)\n    {\n\tif (str[1] == KS_MODIFIER)\n\t{\n\t    modifiers = str[2];\n\t    str += 3;\n\t    c = *str;\n\t}\n\tif (c == K_SPECIAL && str[1] != NUL && str[2] != NUL)\n\t{\n\t    c = TO_SPECIAL(str[1], str[2]);\n\t    str += 2;\n\t}\n\tif (IS_SPECIAL(c) || modifiers)\t\n\t    special = TRUE;\n    }\n    if (has_mbyte && !IS_SPECIAL(c) && MB_BYTE2LEN(c) > 1)\n    {\n\tchar_u\t*p;\n\t*sp = str;\n\tp = mb_unescape(sp);\n\tif (p != NULL)\n\t    c = (*mb_ptr2char)(p);\n\telse\n\t    *sp = str + 1;\n    }\n    else\n\t*sp = str + 1;\n    if (special || c < ' ' || (from && c == ' '))\n\treturn get_special_key_name(c, modifiers);\n    buf[0] = c;\n    buf[1] = NUL;\n    return buf;\n}", "target": 1}
{"code": "static void ptirq_free_irte(const struct ptirq_remapping_info *entry)\n{\n\tstruct intr_source intr_src;\n\tif (entry->irte_idx < CONFIG_MAX_IR_ENTRIES) {\n\t\tif (entry->intr_type == PTDEV_INTR_MSI) {\n\t\t\tintr_src.is_msi = true;\n\t\t\tintr_src.src.msi.value = entry->phys_sid.msi_id.bdf;\n\t\t} else {\n\t\t\tintr_src.is_msi = false;\n\t\t\tintr_src.src.ioapic_id = ioapic_irq_to_ioapic_id(entry->allocated_pirq);\n\t\t}\n\t\tdmar_free_irte(&intr_src, entry->irte_idx);\n\t}\n}", "target": 1}
{"code": "static int allocDynamic(dynamicPtr *dp, int initialSize, void *data)\n{\n\tif(data == NULL) {\n\t\tdp->logicalSize = 0;\n\t\tdp->dataGood = FALSE;\n\t\tdp->data = gdMalloc(initialSize);\n\t} else {\n\t\tdp->logicalSize = initialSize;\n\t\tdp->dataGood = TRUE;\n\t\tdp->data = data;\n\t}\n\tif(dp->data != NULL) {\n\t\tdp->realSize = initialSize;\n\t\tdp->dataGood = TRUE;\n\t\tdp->pos = 0;\n\t\treturn TRUE;\n\t} else {\n\t\tdp->realSize = 0;\n\t\treturn FALSE;\n\t}\n}", "target": 0}
{"code": "static int snd_ctl_elem_write_user(struct snd_ctl_file *file,\n\t\t\t\t   struct snd_ctl_elem_value __user *_control)\n{\n\tstruct snd_ctl_elem_value *control;\n\tstruct snd_card *card;\n\tint result;\n\tcontrol = memdup_user(_control, sizeof(*control));\n\tif (IS_ERR(control))\n\t\treturn PTR_ERR(control);\n\tcard = file->card;\n\tsnd_power_lock(card);\n\tresult = snd_power_wait(card, SNDRV_CTL_POWER_D0);\n\tif (result >= 0)\n\t\tresult = snd_ctl_elem_write(card, file, control);\n\tsnd_power_unlock(card);\n\tif (result >= 0)\n\t\tif (copy_to_user(_control, control, sizeof(*control)))\n\t\t\tresult = -EFAULT;\n\tkfree(control);\n\treturn result;\n}", "target": 0}
{"code": "int agp_generic_insert_memory(struct agp_memory * mem, off_t pg_start, int type)\n{\n\tint num_entries;\n\tsize_t i;\n\toff_t j;\n\tvoid *temp;\n\tstruct agp_bridge_data *bridge;\n\tint mask_type;\n\tbridge = mem->bridge;\n\tif (!bridge)\n\t\treturn -EINVAL;\n\tif (mem->page_count == 0)\n\t\treturn 0;\n\ttemp = bridge->current_size;\n\tswitch (bridge->driver->size_type) {\n\tcase U8_APER_SIZE:\n\t\tnum_entries = A_SIZE_8(temp)->num_entries;\n\t\tbreak;\n\tcase U16_APER_SIZE:\n\t\tnum_entries = A_SIZE_16(temp)->num_entries;\n\t\tbreak;\n\tcase U32_APER_SIZE:\n\t\tnum_entries = A_SIZE_32(temp)->num_entries;\n\t\tbreak;\n\tcase FIXED_APER_SIZE:\n\t\tnum_entries = A_SIZE_FIX(temp)->num_entries;\n\t\tbreak;\n\tcase LVL2_APER_SIZE:\n\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tnum_entries = 0;\n\t\tbreak;\n\t}\n\tnum_entries -= agp_memory_reserved/PAGE_SIZE;\n\tif (num_entries < 0) num_entries = 0;\n\tif (type != mem->type)\n\t\treturn -EINVAL;\n\tmask_type = bridge->driver->agp_type_to_mask_type(bridge, type);\n\tif (mask_type != 0) {\n\t\treturn -EINVAL;\n\t}\n\tif ((pg_start + mem->page_count) > num_entries)\n\t\treturn -EINVAL;\n\tj = pg_start;\n\twhile (j < (pg_start + mem->page_count)) {\n\t\tif (!PGE_EMPTY(bridge, readl(bridge->gatt_table+j)))\n\t\t\treturn -EBUSY;\n\t\tj++;\n\t}\n\tif (!mem->is_flushed) {\n\t\tbridge->driver->cache_flush();\n\t\tmem->is_flushed = true;\n\t}\n\tfor (i = 0, j = pg_start; i < mem->page_count; i++, j++) {\n\t\twritel(bridge->driver->mask_memory(bridge,\n\t\t\t\t\t\t   page_to_phys(mem->pages[i]),\n\t\t\t\t\t\t   mask_type),\n\t\t       bridge->gatt_table+j);\n\t}\n\treadl(bridge->gatt_table+j-1);\t\n\tbridge->driver->tlb_flush(mem);\n\treturn 0;\n}", "target": 1}
{"code": "static inline int quic_token_validate(struct quic_rx_packet *pkt,\n                                      struct quic_dgram *dgram,\n                                      struct listener *l, struct quic_conn *qc,\n                                      struct quic_cid *odcid)\n{\n\tint ret = 0;\n\tTRACE_ENTER(QUIC_EV_CONN_LPKT, qc);\n\tswitch (*pkt->token) {\n\tcase QUIC_TOKEN_FMT_RETRY:\n\t\tret = quic_retry_token_check(pkt, dgram, l, qc, odcid);\n\t\tbreak;\n\tcase QUIC_TOKEN_FMT_NEW:\n\t\tret = quic_token_check(pkt, dgram, qc);\n\t\tif (!ret) {\n\t\t\tdgram->flags |= QUIC_DGRAM_FL_SEND_RETRY;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tTRACE_PROTO(\"Packet dropped\", QUIC_EV_CONN_LPKT, qc, NULL, NULL, pkt->version);\n\t\tbreak;\n\t}\n\tif (!ret)\n\t\tgoto err;\n\tret = 1;\n leave:\n\tTRACE_LEAVE(QUIC_EV_CONN_LPKT, qc);\n\treturn ret;\n err:\n\tTRACE_DEVEL(\"leaving in error\", QUIC_EV_CONN_LPKT, qc);\n\tgoto leave;\n}", "target": 0}
{"code": "populate_lr_context(struct intel_context *ce,\n\t\t    struct drm_i915_gem_object *ctx_obj,\n\t\t    struct intel_engine_cs *engine,\n\t\t    struct intel_ring *ring)\n{\n\tbool inhibit = true;\n\tvoid *vaddr;\n\tu32 *regs;\n\tint ret;\n\tvaddr = i915_gem_object_pin_map(ctx_obj, I915_MAP_WB);\n\tif (IS_ERR(vaddr)) {\n\t\tret = PTR_ERR(vaddr);\n\t\tDRM_DEBUG_DRIVER(\"Could not map object pages! (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tset_redzone(vaddr, engine);\n\tif (engine->default_state) {\n\t\tvoid *defaults;\n\t\tdefaults = i915_gem_object_pin_map(engine->default_state,\n\t\t\t\t\t\t   I915_MAP_WB);\n\t\tif (IS_ERR(defaults)) {\n\t\t\tret = PTR_ERR(defaults);\n\t\t\tgoto err_unpin_ctx;\n\t\t}\n\t\tmemcpy(vaddr, defaults, engine->context_size);\n\t\ti915_gem_object_unpin_map(engine->default_state);\n\t\tinhibit = false;\n\t}\n\tregs = vaddr + LRC_STATE_PN * PAGE_SIZE;\n\texeclists_init_reg_state(regs, ce, engine, ring, inhibit);\n\tif (inhibit)\n\t\tregs[CTX_CONTEXT_CONTROL] |=\n\t\t\t_MASKED_BIT_ENABLE(CTX_CTRL_ENGINE_CTX_RESTORE_INHIBIT);\n\tret = 0;\nerr_unpin_ctx:\n\t__i915_gem_object_flush_map(ctx_obj, 0, engine->context_size);\n\ti915_gem_object_unpin_map(ctx_obj);\n\treturn ret;\n}", "target": 0}
{"code": "xfs_ioctl_setattr_prepare_dax(\n\tstruct xfs_inode\t*ip,\n\tstruct fileattr\t\t*fa)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct inode            *inode = VFS_I(ip);\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn;\n\tif (xfs_has_dax_always(mp) || xfs_has_dax_never(mp))\n\t\treturn;\n\tif (((fa->fsx_xflags & FS_XFLAG_DAX) &&\n\t    !(ip->i_diflags2 & XFS_DIFLAG2_DAX)) ||\n\t    (!(fa->fsx_xflags & FS_XFLAG_DAX) &&\n\t     (ip->i_diflags2 & XFS_DIFLAG2_DAX)))\n\t\td_mark_dontcache(inode);\n}", "target": 0}
{"code": "static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p,\n\tstruct user_namespace *user_ns)\n{\n\tmm->mmap = NULL;\n\tmm->mm_rb = RB_ROOT;\n\tmm->vmacache_seqnum = 0;\n\tatomic_set(&mm->mm_users, 1);\n\tatomic_set(&mm->mm_count, 1);\n\tinit_rwsem(&mm->mmap_sem);\n\tINIT_LIST_HEAD(&mm->mmlist);\n\tmm->core_state = NULL;\n\tatomic_long_set(&mm->nr_ptes, 0);\n\tmm_nr_pmds_init(mm);\n\tmm->map_count = 0;\n\tmm->locked_vm = 0;\n\tmm->pinned_vm = 0;\n\tmemset(&mm->rss_stat, 0, sizeof(mm->rss_stat));\n\tspin_lock_init(&mm->page_table_lock);\n\tmm_init_cpumask(mm);\n\tmm_init_aio(mm);\n\tmm_init_owner(mm, p);\n\tRCU_INIT_POINTER(mm->exe_file, NULL);\n\tmmu_notifier_mm_init(mm);\n\tinit_tlb_flush_pending(mm);\n#if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS\n\tmm->pmd_huge_pte = NULL;\n#endif\n\tmm_init_uprobes_state(mm);\n\tif (current->mm) {\n\t\tmm->flags = current->mm->flags & MMF_INIT_MASK;\n\t\tmm->def_flags = current->mm->def_flags & VM_INIT_DEF_MASK;\n\t} else {\n\t\tmm->flags = default_dump_filter;\n\t\tmm->def_flags = 0;\n\t}\n\tif (mm_alloc_pgd(mm))\n\t\tgoto fail_nopgd;\n\tif (init_new_context(p, mm))\n\t\tgoto fail_nocontext;\n\tmm->user_ns = get_user_ns(user_ns);\n\treturn mm;\nfail_nocontext:\n\tmm_free_pgd(mm);\nfail_nopgd:\n\tfree_mm(mm);\n\treturn NULL;\n}", "target": 0}
{"code": "find_next_quote(\n    char_u\t*line,\n    int\t\tcol,\n    int\t\tquotechar,\n    char_u\t*escape)\t\n{\n    int\t\tc;\n    for (;;)\n    {\n\tc = line[col];\n\tif (c == NUL)\n\t    return -1;\n\telse if (escape != NULL && vim_strchr(escape, c))\n\t    ++col;\n\telse if (c == quotechar)\n\t    break;\n\tif (has_mbyte)\n\t    col += (*mb_ptr2len)(line + col);\n\telse\n\t    ++col;\n    }\n    return col;\n}", "target": 1}
{"code": "int tipc_node_get_mtu(struct net *net, u32 addr, u32 sel, bool connected)\n{\n\tstruct tipc_node *n;\n\tint bearer_id;\n\tunsigned int mtu = MAX_MSG_SIZE;\n\tn = tipc_node_find(net, addr);\n\tif (unlikely(!n))\n\t\treturn mtu;\n\tif (n->peer_net && connected) {\n\t\ttipc_node_put(n);\n\t\treturn mtu;\n\t}\n\tbearer_id = n->active_links[sel & 1];\n\tif (likely(bearer_id != INVALID_BEARER_ID))\n\t\tmtu = n->links[bearer_id].mtu;\n\ttipc_node_put(n);\n\treturn mtu;\n}", "target": 0}
{"code": "int sldns_str2wire_dname_buf_origin(const char* str, uint8_t* buf, size_t* len,\n\tuint8_t* origin, size_t origin_len)\n{\n\tsize_t dlen = *len;\n\tint rel = 0;\n\tint s = sldns_str2wire_dname_buf_rel(str, buf, &dlen, &rel);\n\tif(s) return s;\n\tif(rel && origin && dlen > 0) {\n\t\tif(dlen + origin_len - 1 > LDNS_MAX_DOMAINLEN)\n\t\t\treturn RET_ERR(LDNS_WIREPARSE_ERR_DOMAINNAME_OVERFLOW,\n\t\t\t\tLDNS_MAX_DOMAINLEN);\n\t\tif(dlen + origin_len - 1 > *len)\n\t\t\treturn RET_ERR(LDNS_WIREPARSE_ERR_BUFFER_TOO_SMALL,\n\t\t\t\t*len);\n\t\tmemmove(buf+dlen-1, origin, origin_len);\n\t\t*len = dlen + origin_len - 1;\n\t} else\n\t\t*len = dlen;\n\treturn LDNS_WIREPARSE_ERR_OK;\n}", "target": 1}
{"code": "DNS::DNS()\n{\n\tServerInstance->Logs->Log(\"RESOLVER\",DEBUG,\"DNS::DNS\");\n\tmemset(Classes,0,sizeof(Classes));\n\tmemset(requests,0,sizeof(requests));\n\tcurrid = 0;\n\tthis->cache = NULL;\n\tthis->SetFd(-1);\n\tthis->Rehash();\n\tthis->PruneTimer = new CacheTimer(this);\n\tServerInstance->Timers->AddTimer(this->PruneTimer);\n}", "target": 0}
{"code": "bool ping_rcv(struct sk_buff *skb)\n{\n\tstruct sock *sk;\n\tstruct net *net = dev_net(skb->dev);\n\tstruct icmphdr *icmph = icmp_hdr(skb);\n\tpr_debug(\"ping_rcv(skb=%p,id=%04x,seq=%04x)\\n\",\n\t\t skb, ntohs(icmph->un.echo.id), ntohs(icmph->un.echo.sequence));\n\tskb_push(skb, skb->data - (u8 *)icmph);\n\tsk = ping_lookup(net, skb, ntohs(icmph->un.echo.id));\n\tif (sk) {\n\t\tstruct sk_buff *skb2 = skb_clone(skb, GFP_ATOMIC);\n\t\tpr_debug(\"rcv on socket %p\\n\", sk);\n\t\tif (skb2)\n\t\t\tping_queue_rcv_skb(sk, skb2);\n\t\tsock_put(sk);\n\t\treturn true;\n\t}\n\tpr_debug(\"no socket, dropping\\n\");\n\treturn false;\n}", "target": 0}
{"code": "static int mov_read_rtmd_track(AVFormatContext *s, AVStream *st)\n{\n    MOVStreamContext *sc = st->priv_data;\n    FFStream *const sti = ffstream(st);\n    char buf[AV_TIMECODE_STR_SIZE];\n    int64_t cur_pos = avio_tell(sc->pb);\n    int hh, mm, ss, ff, drop;\n    if (!sti->nb_index_entries)\n        return -1;\n    avio_seek(sc->pb, sti->index_entries->pos, SEEK_SET);\n    avio_skip(s->pb, 13);\n    hh = avio_r8(s->pb);\n    mm = avio_r8(s->pb);\n    ss = avio_r8(s->pb);\n    drop = avio_r8(s->pb);\n    ff = avio_r8(s->pb);\n    snprintf(buf, AV_TIMECODE_STR_SIZE, \"%02d:%02d:%02d%c%02d\",\n             hh, mm, ss, drop ? ';' : ':', ff);\n    av_dict_set(&st->metadata, \"timecode\", buf, 0);\n    avio_seek(sc->pb, cur_pos, SEEK_SET);\n    return 0;\n}", "target": 0}
{"code": "static void build_group_mask(struct sched_domain *sd, struct sched_group *sg)\n{\n\tconst struct cpumask *span = sched_domain_span(sd);\n\tstruct sd_data *sdd = sd->private;\n\tstruct sched_domain *sibling;\n\tint i;\n\tfor_each_cpu(i, span) {\n\t\tsibling = *per_cpu_ptr(sdd->sd, i);\n\t\tif (!cpumask_test_cpu(i, sched_domain_span(sibling)))\n\t\t\tcontinue;\n\t\tcpumask_set_cpu(i, sched_group_mask(sg));\n\t}\n}", "target": 0}
{"code": "static int pit_get_out(struct kvm *kvm, int channel)\n{\n\tstruct kvm_kpit_channel_state *c =\n\t\t&kvm->arch.vpit->pit_state.channels[channel];\n\ts64 d, t;\n\tint out;\n\tWARN_ON(!mutex_is_locked(&kvm->arch.vpit->pit_state.lock));\n\tt = kpit_elapsed(kvm, c, channel);\n\td = muldiv64(t, KVM_PIT_FREQ, NSEC_PER_SEC);\n\tswitch (c->mode) {\n\tdefault:\n\tcase 0:\n\t\tout = (d >= c->count);\n\t\tbreak;\n\tcase 1:\n\t\tout = (d < c->count);\n\t\tbreak;\n\tcase 2:\n\t\tout = ((mod_64(d, c->count) == 0) && (d != 0));\n\t\tbreak;\n\tcase 3:\n\t\tout = (mod_64(d, c->count) < ((c->count + 1) >> 1));\n\t\tbreak;\n\tcase 4:\n\tcase 5:\n\t\tout = (d == c->count);\n\t\tbreak;\n\t}\n\treturn out;\n}", "target": 0}
{"code": "merged_1v_upsample(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n                   JDIMENSION *in_row_group_ctr,\n                   JDIMENSION in_row_groups_avail, JSAMPARRAY output_buf,\n                   JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)\n{\n  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n  (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr,\n                         output_buf + *out_row_ctr);\n  (*out_row_ctr)++;\n  (*in_row_group_ctr)++;\n}", "target": 1}
{"code": "imapx_server_info_changed_cb (CamelIMAPXSummary *summary,\n\t\t\t      CamelMessageInfo *info,\n\t\t\t      gpointer user_data)\n{\n\tGHashTable *changed_meanwhile = user_data;\n\tg_return_if_fail (info != NULL);\n\tg_return_if_fail (changed_meanwhile != NULL);\n\tif (camel_message_info_uid (info)) {\n\t\tg_hash_table_insert (changed_meanwhile,\n\t\t\t(gpointer) camel_pstring_strdup (camel_message_info_uid (info)),\n\t\t\tGINT_TO_POINTER (1));\n\t}\n}", "target": 0}
{"code": "mrb_class_real(struct RClass* cl)\n{\n  if (cl == 0)\n    return NULL;\n  while ((cl->tt == MRB_TT_SCLASS) || (cl->tt == MRB_TT_ICLASS)) {\n    cl = cl->super;\n  }\n  return cl;\n}", "target": 1}
{"code": "static struct dst_entry *ip6_route_input_lookup(struct net *net,\n\t\t\t\t\t\tstruct net_device *dev,\n\t\t\t\t\t\tstruct flowi6 *fl6, int flags)\n{\n\tif (rt6_need_strict(&fl6->daddr) && dev->type != ARPHRD_PIMREG)\n\t\tflags |= RT6_LOOKUP_F_IFACE;\n\treturn fib6_rule_lookup(net, fl6, flags, ip6_pol_route_input);\n}", "target": 0}
{"code": "static int proc_pid_limits(struct task_struct *task, char *buffer)\n{\n\tunsigned int i;\n\tint count = 0;\n\tunsigned long flags;\n\tchar *bufptr = buffer;\n\tstruct rlimit rlim[RLIM_NLIMITS];\n\trcu_read_lock();\n\tif (!lock_task_sighand(task,&flags)) {\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\tmemcpy(rlim, task->signal->rlim, sizeof(struct rlimit) * RLIM_NLIMITS);\n\tunlock_task_sighand(task, &flags);\n\trcu_read_unlock();\n\tcount += sprintf(&bufptr[count], \"%-25s %-20s %-20s %-10s\\n\",\n\t\t\t\"Limit\", \"Soft Limit\", \"Hard Limit\", \"Units\");\n\tfor (i = 0; i < RLIM_NLIMITS; i++) {\n\t\tif (rlim[i].rlim_cur == RLIM_INFINITY)\n\t\t\tcount += sprintf(&bufptr[count], \"%-25s %-20s \",\n\t\t\t\t\t lnames[i].name, \"unlimited\");\n\t\telse\n\t\t\tcount += sprintf(&bufptr[count], \"%-25s %-20lu \",\n\t\t\t\t\t lnames[i].name, rlim[i].rlim_cur);\n\t\tif (rlim[i].rlim_max == RLIM_INFINITY)\n\t\t\tcount += sprintf(&bufptr[count], \"%-20s \", \"unlimited\");\n\t\telse\n\t\t\tcount += sprintf(&bufptr[count], \"%-20lu \",\n\t\t\t\t\t rlim[i].rlim_max);\n\t\tif (lnames[i].unit)\n\t\t\tcount += sprintf(&bufptr[count], \"%-10s\\n\",\n\t\t\t\t\t lnames[i].unit);\n\t\telse\n\t\t\tcount += sprintf(&bufptr[count], \"\\n\");\n\t}\n\treturn count;\n}", "target": 0}
{"code": "static void vmx_complete_atomic_exit(struct vcpu_vmx *vmx)\n{\n\tu32 exit_intr_info;\n\tif (!(vmx->exit_reason == EXIT_REASON_MCE_DURING_VMENTRY\n\t      || vmx->exit_reason == EXIT_REASON_EXCEPTION_NMI))\n\t\treturn;\n\tvmx->exit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\texit_intr_info = vmx->exit_intr_info;\n\tif (is_machine_check(exit_intr_info))\n\t\tkvm_machine_check();\n\tif ((exit_intr_info & INTR_INFO_INTR_TYPE_MASK) == INTR_TYPE_NMI_INTR &&\n\t    (exit_intr_info & INTR_INFO_VALID_MASK)) {\n\t\tkvm_before_handle_nmi(&vmx->vcpu);\n\t\tasm(\"int $2\");\n\t\tkvm_after_handle_nmi(&vmx->vcpu);\n\t}\n}", "target": 1}
{"code": "static const char *tls_dns_name(const GENERAL_NAME * gn)\n{\n\tconst char *dnsname;\n\tif (ASN1_STRING_type(gn->d.ia5) != V_ASN1_IA5STRING) {\n\t\tg_warning(\"Invalid ASN1 value type in subjectAltName\");\n\t\treturn NULL;\n\t}\n\tdnsname = (char *) ASN1_STRING_data(gn->d.ia5);\n\tif (has_internal_nul(dnsname, ASN1_STRING_length(gn->d.ia5))) {\n\t\tg_warning(\"Internal NUL in subjectAltName\");\n\t\treturn NULL;\n\t}\n\treturn dnsname;\n}", "target": 0}
{"code": "decode_sequence_of(const uint8_t *asn1, size_t len,\n                   const struct atype_info *elemtype, void **seq_out,\n                   size_t *count_out)\n{\n    krb5_error_code ret;\n    void *seq = NULL, *elem, *newseq;\n    const uint8_t *contents;\n    size_t clen, count = 0;\n    taginfo t;\n    *seq_out = NULL;\n    *count_out = 0;\n    while (len > 0) {\n        ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len);\n        if (ret)\n            goto error;\n        if (!check_atype_tag(elemtype, &t)) {\n            ret = ASN1_BAD_ID;\n            goto error;\n        }\n        newseq = realloc(seq, (count + 1) * elemtype->size);\n        if (newseq == NULL) {\n            ret = ENOMEM;\n            goto error;\n        }\n        seq = newseq;\n        elem = (char *)seq + count * elemtype->size;\n        memset(elem, 0, elemtype->size);\n        ret = decode_atype(&t, contents, clen, elemtype, elem);\n        if (ret)\n            goto error;\n        count++;\n    }\n    *seq_out = seq;\n    *count_out = count;\n    return 0;\nerror:\n    free_sequence_of(elemtype, seq, count);\n    free(seq);\n    return ret;\n}", "target": 1}
{"code": "p11_rpc_buffer_get_byte_array (p11_buffer *buf,\n                               size_t *offset,\n                               const unsigned char **data,\n                               size_t *length)\n{\n\tsize_t off = *offset;\n\tuint32_t len;\n\tif (!p11_rpc_buffer_get_uint32 (buf, &off, &len))\n\t\treturn false;\n\tif (len == 0xffffffff) {\n\t\t*offset = off;\n\t\tif (data)\n\t\t\t*data = NULL;\n\t\tif (length)\n\t\t\t*length = 0;\n\t\treturn true;\n\t} else if (len >= 0x7fffffff) {\n\t\tp11_buffer_fail (buf);\n\t\treturn false;\n\t}\n\tif (buf->len < len || *offset > buf->len - len) {\n\t\tp11_buffer_fail (buf);\n\t\treturn false;\n\t}\n\tif (data)\n\t\t*data = (unsigned char *)buf->data + off;\n\tif (length)\n\t\t*length = len;\n\t*offset = off + len;\n\treturn true;\n}", "target": 1}
{"code": "static int trusted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct trusted_key_payload *p;\n\tstruct trusted_key_payload *new_p;\n\tstruct trusted_key_options *new_o;\n\tsize_t datalen = prep->datalen;\n\tchar *datablob;\n\tint ret = 0;\n\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n\t\treturn -ENOKEY;\n\tp = key->payload.data[0];\n\tif (!p->migratable)\n\t\treturn -EPERM;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\tdatablob = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!datablob)\n\t\treturn -ENOMEM;\n\tnew_o = trusted_options_alloc();\n\tif (!new_o) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tnew_p = trusted_payload_alloc(key);\n\tif (!new_p) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmemcpy(datablob, prep->data, datalen);\n\tdatablob[datalen] = '\\0';\n\tret = datablob_parse(datablob, new_p, new_o);\n\tif (ret != Opt_update) {\n\t\tret = -EINVAL;\n\t\tkzfree(new_p);\n\t\tgoto out;\n\t}\n\tif (!new_o->keyhandle) {\n\t\tret = -EINVAL;\n\t\tkzfree(new_p);\n\t\tgoto out;\n\t}\n\tnew_p->migratable = p->migratable;\n\tnew_p->key_len = p->key_len;\n\tmemcpy(new_p->key, p->key, p->key_len);\n\tdump_payload(p);\n\tdump_payload(new_p);\n\tret = key_seal(new_p, new_o);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: key_seal failed (%d)\\n\", ret);\n\t\tkzfree(new_p);\n\t\tgoto out;\n\t}\n\tif (new_o->pcrlock) {\n\t\tret = pcrlock(new_o->pcrlock);\n\t\tif (ret < 0) {\n\t\t\tpr_info(\"trusted_key: pcrlock failed (%d)\\n\", ret);\n\t\t\tkzfree(new_p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\trcu_assign_keypointer(key, new_p);\n\tcall_rcu(&p->rcu, trusted_rcu_free);\nout:\n\tkzfree(datablob);\n\tkzfree(new_o);\n\treturn ret;\n}", "target": 1}
{"code": "static int nft_delflowtable_hook(struct nft_ctx *ctx,\n\t\t\t\t struct nft_flowtable *flowtable)\n{\n\tconst struct nlattr * const *nla = ctx->nla;\n\tstruct nft_flowtable_hook flowtable_hook;\n\tLIST_HEAD(flowtable_del_list);\n\tstruct nft_hook *this, *hook;\n\tstruct nft_trans *trans;\n\tint err;\n\terr = nft_flowtable_parse_hook(ctx, nla[NFTA_FLOWTABLE_HOOK],\n\t\t\t\t       &flowtable_hook, flowtable, false);\n\tif (err < 0)\n\t\treturn err;\n\tlist_for_each_entry(this, &flowtable_hook.list, list) {\n\t\thook = nft_hook_list_find(&flowtable->hook_list, this);\n\t\tif (!hook) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto err_flowtable_del_hook;\n\t\t}\n\t\tlist_move(&hook->list, &flowtable_del_list);\n\t}\n\ttrans = nft_trans_alloc(ctx, NFT_MSG_DELFLOWTABLE,\n\t\t\t\tsizeof(struct nft_trans_flowtable));\n\tif (!trans) {\n\t\terr = -ENOMEM;\n\t\tgoto err_flowtable_del_hook;\n\t}\n\tnft_trans_flowtable(trans) = flowtable;\n\tnft_trans_flowtable_update(trans) = true;\n\tINIT_LIST_HEAD(&nft_trans_flowtable_hooks(trans));\n\tlist_splice(&flowtable_del_list, &nft_trans_flowtable_hooks(trans));\n\tnft_flowtable_hook_release(&flowtable_hook);\n\tnft_trans_commit_list_add_tail(ctx->net, trans);\n\treturn 0;\nerr_flowtable_del_hook:\n\tlist_splice(&flowtable_del_list, &flowtable->hook_list);\n\tnft_flowtable_hook_release(&flowtable_hook);\n\treturn err;\n}", "target": 0}
{"code": "struct l2tp_packet_t *l2tp_packet_alloc(int ver, int msg_type,\n\t\t\t\t\tconst struct sockaddr_in *addr, int H,\n\t\t\t\t\tconst char *secret, size_t secret_len)\n{\n\tstruct l2tp_packet_t *pack = mempool_alloc(pack_pool);\n\tif (!pack)\n\t\treturn NULL;\n\tmemset(pack, 0, sizeof(*pack));\n\tINIT_LIST_HEAD(&pack->attrs);\n\tpack->hdr.ver = ver;\n\tpack->hdr.T = 1;\n\tpack->hdr.L = 1;\n\tpack->hdr.S = 1;\n\tmemcpy(&pack->addr, addr, sizeof(*addr));\n\tpack->hide_avps = H;\n\tpack->secret = secret;\n\tpack->secret_len = secret_len;\n\tif (msg_type) {\n\t\tif (l2tp_packet_add_int16(pack, Message_Type, msg_type, 1)) {\n\t\t\tmempool_free(pack);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn pack;\n}", "target": 1}
{"code": "void rose_stop_idletimer(struct sock *sk)\n{\n\tdel_timer(&rose_sk(sk)->idletimer);\n}", "target": 1}
{"code": "xfs_inode_free_callback(\n\tstruct rcu_head\t\t*head)\n{\n\tstruct inode\t\t*inode = container_of(head, struct inode, i_rcu);\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tswitch (VFS_I(ip)->i_mode & S_IFMT) {\n\tcase S_IFREG:\n\tcase S_IFDIR:\n\tcase S_IFLNK:\n\t\txfs_idestroy_fork(ip, XFS_DATA_FORK);\n\t\tbreak;\n\t}\n\tif (ip->i_afp)\n\t\txfs_idestroy_fork(ip, XFS_ATTR_FORK);\n\tif (ip->i_cowfp)\n\t\txfs_idestroy_fork(ip, XFS_COW_FORK);\n\tif (ip->i_itemp) {\n\t\tASSERT(!(ip->i_itemp->ili_item.li_flags & XFS_LI_IN_AIL));\n\t\txfs_inode_item_destroy(ip);\n\t\tip->i_itemp = NULL;\n\t}\n\tkmem_zone_free(xfs_inode_zone, ip);\n}", "target": 0}
{"code": "static long vhost_net_ioctl(struct file *f, unsigned int ioctl,\n\t\t\t    unsigned long arg)\n{\n\tstruct vhost_net *n = f->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tu64 __user *featurep = argp;\n\tstruct vhost_vring_file backend;\n\tu64 features;\n\tint r;\n\tswitch (ioctl) {\n\tcase VHOST_NET_SET_BACKEND:\n\t\tif (copy_from_user(&backend, argp, sizeof backend))\n\t\t\treturn -EFAULT;\n\t\treturn vhost_net_set_backend(n, backend.index, backend.fd);\n\tcase VHOST_GET_FEATURES:\n\t\tfeatures = VHOST_NET_FEATURES;\n\t\tif (copy_to_user(featurep, &features, sizeof features))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase VHOST_SET_FEATURES:\n\t\tif (copy_from_user(&features, featurep, sizeof features))\n\t\t\treturn -EFAULT;\n\t\tif (features & ~VHOST_NET_FEATURES)\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn vhost_net_set_features(n, features);\n\tcase VHOST_RESET_OWNER:\n\t\treturn vhost_net_reset_owner(n);\n\tdefault:\n\t\tmutex_lock(&n->dev.mutex);\n\t\tr = vhost_dev_ioctl(&n->dev, ioctl, argp);\n\t\tif (r == -ENOIOCTLCMD)\n\t\t\tr = vhost_vring_ioctl(&n->dev, ioctl, argp);\n\t\telse\n\t\t\tvhost_net_flush(n);\n\t\tmutex_unlock(&n->dev.mutex);\n\t\treturn r;\n\t}\n}", "target": 0}
{"code": "FoFiTrueType::FoFiTrueType(char *fileA, int lenA, GBool freeFileDataA, int faceIndexA):\n  FoFiBase(fileA, lenA, freeFileDataA)\n{\n  tables = NULL;\n  nTables = 0;\n  cmaps = NULL;\n  nCmaps = 0;\n  nameToGID = NULL;\n  parsedOk = gFalse;\n  faceIndex = faceIndexA;\n  gsubFeatureTable = 0;\n  gsubLookupList = 0;\n  parse();\n}", "target": 0}
{"code": "int tipc_nl_node_dump_monitor_peer(struct sk_buff *skb,\n\t\t\t\t   struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tu32 prev_node = cb->args[1];\n\tu32 bearer_id = cb->args[2];\n\tint done = cb->args[0];\n\tstruct tipc_nl_msg msg;\n\tint err;\n\tif (!prev_node) {\n\t\tstruct nlattr **attrs = genl_dumpit_info(cb)->attrs;\n\t\tstruct nlattr *mon[TIPC_NLA_MON_MAX + 1];\n\t\tif (!attrs[TIPC_NLA_MON])\n\t\t\treturn -EINVAL;\n\t\terr = nla_parse_nested_deprecated(mon, TIPC_NLA_MON_MAX,\n\t\t\t\t\t\t  attrs[TIPC_NLA_MON],\n\t\t\t\t\t\t  tipc_nl_monitor_policy,\n\t\t\t\t\t\t  NULL);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (!mon[TIPC_NLA_MON_REF])\n\t\t\treturn -EINVAL;\n\t\tbearer_id = nla_get_u32(mon[TIPC_NLA_MON_REF]);\n\t\tif (bearer_id >= MAX_BEARERS)\n\t\t\treturn -EINVAL;\n\t}\n\tif (done)\n\t\treturn 0;\n\tmsg.skb = skb;\n\tmsg.portid = NETLINK_CB(cb->skb).portid;\n\tmsg.seq = cb->nlh->nlmsg_seq;\n\trtnl_lock();\n\terr = tipc_nl_add_monitor_peer(net, &msg, bearer_id, &prev_node);\n\tif (!err)\n\t\tdone = 1;\n\trtnl_unlock();\n\tcb->args[0] = done;\n\tcb->args[1] = prev_node;\n\tcb->args[2] = bearer_id;\n\treturn skb->len;\n}", "target": 0}
{"code": "DLLEXPORT unsigned long DLLCALL tjBufSize(int width, int height,\n\tint jpegSubsamp)\n{\n\tunsigned long retval=0;  int mcuw, mcuh, chromasf;\n\tif(width<1 || height<1 || jpegSubsamp<0 || jpegSubsamp>=NUMSUBOPT)\n\t\t_throwg(\"tjBufSize(): Invalid argument\");\n\tmcuw=tjMCUWidth[jpegSubsamp];\n\tmcuh=tjMCUHeight[jpegSubsamp];\n\tchromasf=jpegSubsamp==TJSAMP_GRAY? 0: 4*64/(mcuw*mcuh);\n\tretval=PAD(width, mcuw) * PAD(height, mcuh) * (2 + chromasf) + 2048;\n\tbailout:\n\treturn retval;\n}", "target": 0}
{"code": "comics_generate_command_lines (ComicsDocument *comics_document, \n\t\t\t       GError         **error)\n{\n\tgchar *quoted_file, *quoted_file_aux;\n\tgchar *quoted_command;\n\tComicBookDecompressType type;\n\ttype = comics_document->command_usage;\n\tcomics_document->regex_arg = command_usage_def[type].regex_arg;\n\tquoted_command = g_shell_quote (comics_document->selected_command);\n\tif (comics_document->regex_arg) {\n\t\tquoted_file = comics_regex_quote (comics_document->archive);\n\t\tquoted_file_aux = g_shell_quote (comics_document->archive);\n\t\tcomics_document->list_command =\n\t\t\t   g_strdup_printf (command_usage_def[type].list,\n\t\t\t                    comics_document->alternative_command,\n\t\t\t                    quoted_file_aux);\n\t\tg_free (quoted_file_aux);\n\t} else {\n\t\tquoted_file = g_shell_quote (comics_document->archive);\n\t\tcomics_document->list_command =\n\t\t\t\tg_strdup_printf (command_usage_def[type].list,\n\t\t\t\t                 quoted_command, quoted_file);\n\t}\n\tcomics_document->extract_command =\n\t\t\t    g_strdup_printf (command_usage_def[type].extract,\n\t\t\t\t             quoted_command);\n\tcomics_document->offset = command_usage_def[type].offset;\n\tif (command_usage_def[type].decompress_tmp) {\n\t\tcomics_document->dir = ev_mkdtemp (\"xreader-comics-XXXXXX\", error);\n                if (comics_document->dir == NULL)\n                        return FALSE;\n\t\tcomics_document->decompress_tmp =\n\t\t\tg_strdup_printf (command_usage_def[type].decompress_tmp, \n\t\t\t\t\t quoted_command, quoted_file,\n\t\t\t\t\t comics_document->dir);\n\t\tg_free (quoted_file);\n\t\tg_free (quoted_command);\n\t\tif (!comics_decompress_temp_dir (comics_document->decompress_tmp,\n\t\t    comics_document->selected_command, error))\n\t\t\treturn FALSE;\n\t\telse\n\t\t\treturn TRUE;\n\t} else {\n\t\tg_free (quoted_file);\n\t\tg_free (quoted_command);\n\t\treturn TRUE;\n\t}\n}", "target": 1}
{"code": "static int uas_find_uas_alt_setting(struct usb_interface *intf)\n{\n\tint i;\n\tfor (i = 0; i < intf->num_altsetting; i++) {\n\t\tstruct usb_host_interface *alt = &intf->altsetting[i];\n\t\tif (uas_is_interface(alt))\n\t\t\treturn alt->desc.bAlternateSetting;\n\t}\n\treturn -ENODEV;\n}", "target": 1}
{"code": "void TestJlCompress::extractDir_data()\n{\n    QTest::addColumn<QString>(\"zipName\");\n    QTest::addColumn<QStringList>(\"fileNames\");\n    QTest::newRow(\"simple\") << \"jlextdir.zip\" << (\n            QStringList() << \"test0.txt\" << \"testdir1/test1.txt\"\n            << \"testdir2/test2.txt\" << \"testdir2/subdir/test2sub.txt\");\n    QTest::newRow(\"separate dir\") << \"sepdir.zip\" << (\n            QStringList() << \"laj/\" << \"laj/lajfile.txt\");\n}", "target": 1}
{"code": "win_horz_neighbor(tabpage_T *tp, win_T *wp, int left, long count)\n{\n    frame_T\t*fr;\n    frame_T\t*nfr;\n    frame_T\t*foundfr;\n    foundfr = wp->w_frame;\n    while (count--)\n    {\n\tfr = foundfr;\n\tfor (;;)\n\t{\n\t    if (fr == tp->tp_topframe)\n\t\tgoto end;\n\t    if (left)\n\t\tnfr = fr->fr_prev;\n\t    else\n\t\tnfr = fr->fr_next;\n\t    if (fr->fr_parent->fr_layout == FR_ROW && nfr != NULL)\n\t\tbreak;\n\t    fr = fr->fr_parent;\n\t}\n\tfor (;;)\n\t{\n\t    if (nfr->fr_layout == FR_LEAF)\n\t    {\n\t\tfoundfr = nfr;\n\t\tbreak;\n\t    }\n\t    fr = nfr->fr_child;\n\t    if (nfr->fr_layout == FR_COL)\n\t    {\n\t\twhile (fr->fr_next != NULL\n\t\t\t&& frame2win(fr)->w_winrow + fr->fr_height\n\t\t\t\t\t <= wp->w_winrow + wp->w_wrow)\n\t\t    fr = fr->fr_next;\n\t    }\n\t    if (nfr->fr_layout == FR_ROW && left)\n\t\twhile (fr->fr_next != NULL)\n\t\t    fr = fr->fr_next;\n\t    nfr = fr;\n\t}\n    }\nend:\n    return foundfr != NULL ? foundfr->fr_win : NULL;\n}", "target": 0}
{"code": "BuildSendAndCloseSoapResp(struct upnphttp * h,\n                          const char * body, int bodylen)\n{\n\tstatic const char beforebody[] =\n\t\t\"<?xml version=\\\"1.0\\\"?>\\r\\n\"\n\t\t\"<s:Envelope xmlns:s=\\\"http:\n\t\t\"s:encodingStyle=\\\"http:\n\t\t\"<s:Body>\";\n\tstatic const char afterbody[] =\n\t\t\"</s:Body>\"\n\t\t\"</s:Envelope>\\r\\n\";\n\tint r = BuildHeader_upnphttp(h, 200, \"OK\",  sizeof(beforebody) - 1\n\t                             + sizeof(afterbody) - 1 + bodylen );\n\tif(r >= 0) {\n\t\tmemcpy(h->res_buf + h->res_buflen, beforebody, sizeof(beforebody) - 1);\n\t\th->res_buflen += sizeof(beforebody) - 1;\n\t\tmemcpy(h->res_buf + h->res_buflen, body, bodylen);\n\t\th->res_buflen += bodylen;\n\t\tmemcpy(h->res_buf + h->res_buflen, afterbody, sizeof(afterbody) - 1);\n\t\th->res_buflen += sizeof(afterbody) - 1;\n\t} else {\n\t\tBuildResp2_upnphttp(h, 500, \"Internal Server Error\", NULL, 0);\n\t}\n\tSendRespAndClose_upnphttp(h);\n}", "target": 0}
{"code": "TEST(GteOp, MatchesDotNotationNull) {\n    BSONObj operand = BSON(\"$gte\" << BSONNULL);\n    GTEMatchExpression gte(\"a.b\", operand[\"$gte\"]);\n    ASSERT(gte.matchesBSON(BSONObj(), NULL));\n    ASSERT(gte.matchesBSON(BSON(\"a\" << BSONNULL), NULL));\n    ASSERT(gte.matchesBSON(BSON(\"a\" << 4), NULL));\n    ASSERT(gte.matchesBSON(BSON(\"a\" << BSONObj()), NULL));\n    ASSERT(gte.matchesBSON(BSON(\"a\" << BSON_ARRAY(BSON(\"b\" << BSONNULL))), NULL));\n    ASSERT(gte.matchesBSON(BSON(\"a\" << BSON_ARRAY(BSON(\"a\" << 4) << BSON(\"b\" << 4))), NULL));\n    ASSERT(!gte.matchesBSON(BSON(\"a\" << BSON_ARRAY(4)), NULL));\n    ASSERT(!gte.matchesBSON(BSON(\"a\" << BSON_ARRAY(BSON(\"b\" << 4))), NULL));\n}", "target": 0}
{"code": "ikev1_sig_print(netdissect_options *ndo, u_char tpay _U_,\n\t\tconst struct isakmp_gen *ext, u_int item_len _U_,\n\t\tconst u_char *ep _U_, uint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_SIG)));\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_SIG)));\n\treturn NULL;\n}", "target": 0}
{"code": "static inline void tcp_check_send_head(struct sock *sk, struct sk_buff *skb_unlinked)\n{\n\tif (sk->sk_send_head == skb_unlinked)\n\t\tsk->sk_send_head = NULL;\n}", "target": 1}
{"code": "bytesPerDeepLineTable (const Header &header,\n                       int minY, int maxY,\n                       const char* base,\n                       int xStride,\n                       int yStride,\n                       vector<size_t> &bytesPerLine)\n{\n    const Box2i &dataWindow = header.dataWindow();\n    const ChannelList &channels = header.channels();\n    for (ChannelList::ConstIterator c = channels.begin();\n         c != channels.end();\n         ++c)\n    {\n        const int ySampling = abs(c.channel().ySampling);\n        const int xSampling = abs(c.channel().xSampling);\n        const int pixelSize = pixelTypeSize (c.channel().type);\n        const int sampleMinY = roundToNextMultiple(minY, ySampling);\n        const int sampleMaxY = roundToPrevMultiple(maxY, ySampling);\n        const int sampleMinX = roundToNextMultiple(dataWindow.min.x, xSampling);\n        const int sampleMaxX = roundToPrevMultiple(dataWindow.max.x, xSampling);\n        for (int y = sampleMinY; y <= sampleMaxY; y+=ySampling)\n        {\n            int nBytes = 0;\n            for (int x = sampleMinX; x <= sampleMaxX; x += xSampling)\n            {\n                nBytes += pixelSize *\n                          sampleCount(base, xStride, yStride, x, y);\n            }\n            bytesPerLine[y - dataWindow.min.y] += nBytes;\n        }\n    }\n    size_t maxBytesPerLine = 0;\n    for (int y = minY; y <= maxY; ++y)\n        if (maxBytesPerLine < bytesPerLine[y - dataWindow.min.y])\n            maxBytesPerLine = bytesPerLine[y - dataWindow.min.y];\n    return maxBytesPerLine;\n}", "target": 1}
{"code": "static int iscsi_add_notunderstood_response(\n\tchar *key,\n\tchar *value,\n\tstruct iscsi_param_list *param_list)\n{\n\tstruct iscsi_extra_response *extra_response;\n\tif (strlen(value) > VALUE_MAXLEN) {\n\t\tpr_err(\"Value for notunderstood key \\\"%s\\\" exceeds %d,\"\n\t\t\t\" protocol error.\\n\", key, VALUE_MAXLEN);\n\t\treturn -1;\n\t}\n\textra_response = kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);\n\tif (!extra_response) {\n\t\tpr_err(\"Unable to allocate memory for\"\n\t\t\t\" struct iscsi_extra_response.\\n\");\n\t\treturn -1;\n\t}\n\tINIT_LIST_HEAD(&extra_response->er_list);\n\tstrncpy(extra_response->key, key, strlen(key) + 1);\n\tstrncpy(extra_response->value, NOTUNDERSTOOD,\n\t\t\tstrlen(NOTUNDERSTOOD) + 1);\n\tlist_add_tail(&extra_response->er_list,\n\t\t\t&param_list->extra_response_list);\n\treturn 0;\n}", "target": 1}
{"code": "bool unit_suffix_is_valid(const char *s) {\n        if (isempty(s))\n                return false;\n        if (s[0] != '.')\n                return false;\n        if (unit_type_from_string(s + 1) < 0)\n                return false;\n        return true;\n}", "target": 0}
{"code": "LUA_API void *lua_upvalueid (lua_State *L, int fidx, int n) {\n  StkId fi = index2addr(L, fidx);\n  switch (ttype(fi)) {\n    case LUA_TLCL: {  \n      return *getupvalref(L, fidx, n, NULL);\n    }\n    case LUA_TCCL: {  \n      CClosure *f = clCvalue(fi);\n      api_check(L, 1 <= n && n <= f->nupvalues, \"invalid upvalue index\");\n      return &f->upvalue[n - 1];\n    }\n    default: {\n      api_check(L, 0, \"closure expected\");\n      return NULL;\n    }\n  }\n}", "target": 1}
{"code": "\tvirtual ~CxFile() { };", "target": 1}
{"code": "void ion_free(struct ion_client *client, struct ion_handle *handle)\n{\n\tbool valid_handle;\n\tBUG_ON(client != handle->client);\n\tmutex_lock(&client->lock);\n\tvalid_handle = ion_handle_validate(client, handle);\n\tif (!valid_handle) {\n\t\tWARN(1, \"%s: invalid handle passed to free.\\n\", __func__);\n\t\tmutex_unlock(&client->lock);\n\t\treturn;\n\t}\n\tmutex_unlock(&client->lock);\n\tion_handle_put(handle);\n}", "target": 1}
{"code": "static inline QuantumAny ScaleQuantumToAny(const Quantum quantum,\n  const QuantumAny range)\n{\n  return((QuantumAny) (((double) range*quantum)/QuantumRange+0.5));\n}", "target": 1}
{"code": "nm_wildcard_match_check(const char *str, const char *const *patterns, guint num_patterns)\n{\n    gboolean has_optional     = FALSE;\n    gboolean has_any_optional = FALSE;\n    guint    i;\n    for (i = 0; i < num_patterns; i++) {\n        gboolean    is_inverted;\n        gboolean    is_mandatory;\n        gboolean    match;\n        const char *p;\n        _pattern_parse(patterns[i], &p, &is_inverted, &is_mandatory);\n        match = (fnmatch(p, str, 0) == 0);\n        if (is_inverted)\n            match = !match;\n        if (is_mandatory) {\n            if (!match)\n                return FALSE;\n        } else {\n            has_any_optional = TRUE;\n            if (match)\n                has_optional = TRUE;\n        }\n    }\n    return has_optional || !has_any_optional;\n}", "target": 1}
{"code": "static bool malidp_check_pages_threshold(struct malidp_plane_state *ms,\n\t\t\t\t\t u32 pgsize)\n{\n\tint i;\n\tfor (i = 0; i < ms->n_planes; i++) {\n\t\tstruct drm_gem_object *obj;\n\t\tstruct drm_gem_cma_object *cma_obj;\n\t\tstruct sg_table *sgt;\n\t\tstruct scatterlist *sgl;\n\t\tobj = drm_gem_fb_get_obj(ms->base.fb, i);\n\t\tcma_obj = to_drm_gem_cma_obj(obj);\n\t\tif (cma_obj->sgt)\n\t\t\tsgt = cma_obj->sgt;\n\t\telse\n\t\t\tsgt = obj->funcs->get_sg_table(obj);\n\t\tif (!sgt)\n\t\t\treturn false;\n\t\tsgl = sgt->sgl;\n\t\twhile (sgl) {\n\t\t\tif (sgl->length < pgsize) {\n\t\t\t\tif (!cma_obj->sgt)\n\t\t\t\t\tkfree(sgt);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tsgl = sg_next(sgl);\n\t\t}\n\t\tif (!cma_obj->sgt)\n\t\t\tkfree(sgt);\n\t}\n\treturn true;\n}", "target": 1}
{"code": "int emulator_write_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t    unsigned long addr,\n\t\t\t    const void *val,\n\t\t\t    unsigned int bytes,\n\t\t\t    struct x86_exception *exception)\n{\n\treturn emulator_read_write(ctxt, addr, (void *)val, bytes,\n\t\t\t\t   exception, &write_emultor);\n}", "target": 0}
{"code": "StreamWriteResult StreamBase::Write(\n    uv_buf_t* bufs,\n    size_t count,\n    uv_stream_t* send_handle,\n    v8::Local<v8::Object> req_wrap_obj) {\n  Environment* env = stream_env();\n  int err;\n  size_t total_bytes = 0;\n  for (size_t i = 0; i < count; ++i)\n    total_bytes += bufs[i].len;\n  bytes_written_ += total_bytes;\n  if (send_handle == nullptr) {\n    err = DoTryWrite(&bufs, &count);\n    if (err != 0 || count == 0) {\n      return StreamWriteResult { false, err, nullptr, total_bytes };\n    }\n  }\n  v8::HandleScope handle_scope(env->isolate());\n  if (req_wrap_obj.IsEmpty()) {\n    if (!env->write_wrap_template()\n             ->NewInstance(env->context())\n             .ToLocal(&req_wrap_obj)) {\n      return StreamWriteResult { false, UV_EBUSY, nullptr, 0 };\n    }\n    StreamReq::ResetObject(req_wrap_obj);\n  }\n  AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(GetAsyncWrap());\n  WriteWrap* req_wrap = CreateWriteWrap(req_wrap_obj);\n  err = DoWrite(req_wrap, bufs, count, send_handle);\n  bool async = err == 0;\n  if (!async) {\n    req_wrap->Dispose();\n    req_wrap = nullptr;\n  }\n  const char* msg = Error();\n  if (msg != nullptr) {\n    req_wrap_obj->Set(env->context(),\n                      env->error_string(),\n                      OneByteString(env->isolate(), msg)).Check();\n    ClearError();\n  }\n  return StreamWriteResult { async, err, req_wrap, total_bytes };\n}", "target": 1}
{"code": "rb_reserve_next_event(struct ring_buffer *buffer,\n\t\t      struct ring_buffer_per_cpu *cpu_buffer,\n\t\t      unsigned long length)\n{\n\tstruct ring_buffer_event *event;\n\tstruct rb_event_info info;\n\tint nr_loops = 0;\n\tu64 diff;\n\trb_start_commit(cpu_buffer);\n#ifdef CONFIG_RING_BUFFER_ALLOW_SWAP\n\tbarrier();\n\tif (unlikely(ACCESS_ONCE(cpu_buffer->buffer) != buffer)) {\n\t\tlocal_dec(&cpu_buffer->committing);\n\t\tlocal_dec(&cpu_buffer->commits);\n\t\treturn NULL;\n\t}\n#endif\n\tinfo.length = rb_calculate_event_length(length);\n again:\n\tinfo.add_timestamp = 0;\n\tinfo.delta = 0;\n\tif (RB_WARN_ON(cpu_buffer, ++nr_loops > 1000))\n\t\tgoto out_fail;\n\tinfo.ts = rb_time_stamp(cpu_buffer->buffer);\n\tdiff = info.ts - cpu_buffer->write_stamp;\n\tbarrier();\n\tif (likely(info.ts >= cpu_buffer->write_stamp)) {\n\t\tinfo.delta = diff;\n\t\tif (unlikely(test_time_stamp(info.delta)))\n\t\t\trb_handle_timestamp(cpu_buffer, &info);\n\t}\n\tevent = __rb_reserve_next(cpu_buffer, &info);\n\tif (unlikely(PTR_ERR(event) == -EAGAIN)) {\n\t\tif (info.add_timestamp)\n\t\t\tinfo.length -= RB_LEN_TIME_EXTEND;\n\t\tgoto again;\n\t}\n\tif (!event)\n\t\tgoto out_fail;\n\treturn event;\n out_fail:\n\trb_end_commit(cpu_buffer);\n\treturn NULL;\n}", "target": 0}
{"code": "AWSEngine::authenticate(const req_state* const s) const\n{\n  const auto auth_data = ver_abstractor.get_auth_data(s);\n  if (auth_data.access_key_id.empty() || auth_data.client_signature.empty()) {\n    return result_t::deny(-EINVAL);\n  } else {\n    return authenticate(auth_data.access_key_id,\n\t\t        auth_data.client_signature,\n\t\t\tauth_data.string_to_sign,\n                        auth_data.signature_factory,\n\t\t\tauth_data.completer_factory,\n\t\t\ts);\n  }\n}", "target": 0}
{"code": "void RegisterInternalHandlers() {\n  if (!TrustedPrimitives::RegisterEntryHandler(kSelectorAsyloDonateThread,\n                                               EntryHandler{DonateThread})\n           .ok()) {\n    TrustedPrimitives::BestEffortAbort(\n        \"Could not register entry handler: DonateThread.\");\n  }\n  if (!TrustedPrimitives::RegisterEntryHandler(kSelectorAsyloFini,\n                                               EntryHandler{FinalizeEnclave})\n           .ok()) {\n    TrustedPrimitives::BestEffortAbort(\n        \"Could not register entry handler: FinalizeEnclave\");\n  }\n}", "target": 0}
{"code": "connection *connection_accept(server *srv, server_socket *srv_socket) {\n\tint cnt;\n\tsock_addr cnt_addr;\n\tsize_t cnt_len = sizeof(cnt_addr); \n\tif (srv->conns.used >= srv->max_conns) {\n\t\treturn NULL;\n\t}\n\tcnt = fdevent_accept_listenfd(srv_socket->fd, (struct sockaddr *) &cnt_addr, &cnt_len);\n\tif (-1 == cnt) {\n\t\tswitch (errno) {\n\t\tcase EAGAIN:\n#if EWOULDBLOCK != EAGAIN\n\t\tcase EWOULDBLOCK:\n#endif\n\t\tcase EINTR:\n\t\tcase ECONNABORTED: \n\t\t\tbreak;\n\t\tcase EMFILE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_perror(srv->errh, __FILE__, __LINE__, \"accept failed\");\n\t\t}\n\t\treturn NULL;\n\t} else {\n\t\tif (sock_addr_get_family(&cnt_addr) != AF_UNIX) {\n\t\t\tnetwork_accept_tcp_nagle_disable(cnt);\n\t\t}\n\t\treturn connection_accepted(srv, srv_socket, &cnt_addr, cnt);\n\t}\n}", "target": 0}
{"code": "struct bpf_prog *bpf_patch_insn_single(struct bpf_prog *prog, u32 off,\n\t\t\t\t       const struct bpf_insn *patch, u32 len)\n{\n\tu32 insn_adj_cnt, insn_rest, insn_delta = len - 1;\n\tstruct bpf_prog *prog_adj;\n\tif (insn_delta == 0) {\n\t\tmemcpy(prog->insnsi + off, patch, sizeof(*patch));\n\t\treturn prog;\n\t}\n\tinsn_adj_cnt = prog->len + insn_delta;\n\tprog_adj = bpf_prog_realloc(prog, bpf_prog_size(insn_adj_cnt),\n\t\t\t\t    GFP_USER);\n\tif (!prog_adj)\n\t\treturn NULL;\n\tprog_adj->len = insn_adj_cnt;\n\tinsn_rest = insn_adj_cnt - off - len;\n\tmemmove(prog_adj->insnsi + off + len, prog_adj->insnsi + off + 1,\n\t\tsizeof(*patch) * insn_rest);\n\tmemcpy(prog_adj->insnsi + off, patch, sizeof(*patch) * len);\n\tbpf_adj_branches(prog_adj, off, insn_delta);\n\treturn prog_adj;\n}", "target": 1}
{"code": "dcchkstr(int size)\n{\n\twhile( (strsize+size) > strmaxsize ) {\n\t\tdcstr=realloc(dcstr,strmaxsize+DCSTRSIZE);\n\t\tstrmaxsize+=DCSTRSIZE;\n\t\tdcptr=dcstr+strsize;\n\t}\n}", "target": 0}
{"code": "bgp_afi_safi_valid_indices (afi_t afi, safi_t *safi)\n{\n  if ((afi == AFI_IP6 && *safi == BGP_SAFI_VPNV4)\n      || (afi == AFI_IP && *safi == BGP_SAFI_VPNV6))\n    {\n      zlog_warn (\"Invalid afi/safi combination (%u/%u)\", afi, *safi);\n      return 0;\n    }\n  switch (afi)\n    {\n      case AFI_IP:\n#ifdef HAVE_IPV6\n      case AFI_IP6:\n#endif\n        switch (*safi)\n          {\n            case BGP_SAFI_VPNV4:\n            case BGP_SAFI_VPNV6:\n              *safi = SAFI_MPLS_VPN;\n            case SAFI_UNICAST:\n            case SAFI_MULTICAST:\n            case SAFI_MPLS_VPN:\n              return 1;\n          }\n    }\n  zlog_debug (\"unknown afi/safi (%u/%u)\", afi, *safi);\n  return 0;\n}", "target": 0}
{"code": "static int spk_ttyio_out(struct spk_synth *in_synth, const char ch)\n{\n\tmutex_lock(&speakup_tty_mutex);\n\tif (in_synth->alive && speakup_tty && speakup_tty->ops->write) {\n\t\tint ret = speakup_tty->ops->write(speakup_tty, &ch, 1);\n\t\tmutex_unlock(&speakup_tty_mutex);\n\t\tif (ret == 0)\n\t\t\treturn 0;\n\t\tif (ret < 0) {\n\t\t\tpr_warn(\"%s: I/O error, deactivating speakup\\n\",\n\t\t\t\tin_synth->long_name);\n\t\t\tin_synth->alive = 0;\n\t\t\tspeakup_start_ttys();\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\tmutex_unlock(&speakup_tty_mutex);\n\treturn 0;\n}", "target": 0}
{"code": "__be32 ipv6_proxy_select_ident(struct net *net, struct sk_buff *skb)\n{\n\tstatic u32 ip6_proxy_idents_hashrnd __read_mostly;\n\tstruct in6_addr buf[2];\n\tstruct in6_addr *addrs;\n\tu32 id;\n\taddrs = skb_header_pointer(skb,\n\t\t\t\t   skb_network_offset(skb) +\n\t\t\t\t   offsetof(struct ipv6hdr, saddr),\n\t\t\t\t   sizeof(buf), buf);\n\tif (!addrs)\n\t\treturn 0;\n\tnet_get_random_once(&ip6_proxy_idents_hashrnd,\n\t\t\t    sizeof(ip6_proxy_idents_hashrnd));\n\tid = __ipv6_select_ident(net, ip6_proxy_idents_hashrnd,\n\t\t\t\t &addrs[1], &addrs[0]);\n\treturn htonl(id);\n}", "target": 1}
{"code": "int x86_decode_emulated_instruction(struct kvm_vcpu *vcpu, int emulation_type,\n\t\t\t\t    void *insn, int insn_len)\n{\n\tint r = EMULATION_OK;\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\tinit_emulate_ctxt(vcpu);\n\tif (!(emulation_type & EMULTYPE_SKIP) &&\n\t    kvm_vcpu_check_breakpoint(vcpu, &r))\n\t\treturn r;\n\tr = x86_decode_insn(ctxt, insn, insn_len, emulation_type);\n\ttrace_kvm_emulate_insn_start(vcpu);\n\t++vcpu->stat.insn_emulation;\n\treturn r;\n}", "target": 1}
{"code": "static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof TSRMLS_DC)\n{\n\tchar *ksep, *vsep, *val;\n\tsize_t klen, vlen;\n\tunsigned int new_vlen;\n\tif (var->ptr >= var->end) {\n\t\treturn 0;\n\t}\n\tvsep = memchr(var->ptr, '&', var->end - var->ptr);\n\tif (!vsep) {\n\t\tif (!eof) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tvsep = var->end;\n\t\t}\n\t}\n\tksep = memchr(var->ptr, '=', vsep - var->ptr);\n\tif (ksep) {\n\t\t*ksep = '\\0';\n\t\tklen = ksep - var->ptr;\n\t\tvlen = vsep - ++ksep;\n\t} else {\n\t\tksep = \"\";\n\t\tklen = vsep - var->ptr;\n\t\tvlen = 0;\n\t}\n\tphp_url_decode(var->ptr, klen);\n\tval = estrndup(ksep, vlen);\n\tif (vlen) {\n\t\tvlen = php_url_decode(val, vlen);\n\t}\n\tif (sapi_module.input_filter(PARSE_POST, var->ptr, &val, vlen, &new_vlen TSRMLS_CC)) {\n\t\tphp_register_variable_safe(var->ptr, val, new_vlen, arr TSRMLS_CC);\n\t}\n\tefree(val);\n\tvar->ptr = vsep + (vsep != var->end);\n\treturn 1;\n}", "target": 1}
{"code": "lys_restr_dup(struct lys_module *mod, struct lys_restr *old, int size, int shallow, struct unres_schema *unres)\n{\n    struct lys_restr *result;\n    int i;\n    if (!size) {\n        return NULL;\n    }\n    result = calloc(size, sizeof *result);\n    LY_CHECK_ERR_RETURN(!result, LOGMEM(mod->ctx), NULL);\n    for (i = 0; i < size; i++) {\n        result[i].ext_size = old[i].ext_size;\n        lys_ext_dup(mod->ctx, mod, old[i].ext, old[i].ext_size, &result[i], LYEXT_PAR_RESTR, &result[i].ext, shallow, unres);\n        result[i].expr = lydict_insert(mod->ctx, old[i].expr, 0);\n        result[i].dsc = lydict_insert(mod->ctx, old[i].dsc, 0);\n        result[i].ref = lydict_insert(mod->ctx, old[i].ref, 0);\n        result[i].eapptag = lydict_insert(mod->ctx, old[i].eapptag, 0);\n        result[i].emsg = lydict_insert(mod->ctx, old[i].emsg, 0);\n    }\n    return result;\n}", "target": 1}
{"code": "selaComputeCompositeParameters(const char  *fileout)\n{\nchar    *str, *nameh1, *nameh2, *namev1, *namev2;\nchar     buf[L_BUF_SIZE];\nl_int32  size, size1, size2, len;\nSARRAY  *sa;\nSELA    *selabasic, *selacomb;\n    selabasic = selaAddBasic(NULL);\n    selacomb = selaAddDwaCombs(NULL);\n    sa = sarrayCreate(64);\n    for (size = 2; size < 64; size++) {\n        selectComposableSizes(size, &size1, &size2);\n        nameh1 = selaGetBrickName(selabasic, size1, 1);\n        namev1 = selaGetBrickName(selabasic, 1, size1);\n        if (size2 > 1) {\n            nameh2 = selaGetCombName(selacomb, size1 * size2, L_HORIZ);\n            namev2 = selaGetCombName(selacomb, size1 * size2, L_VERT);\n        } else {\n            nameh2 = stringNew(\"\");\n            namev2 = stringNew(\"\");\n        }\n        snprintf(buf, L_BUF_SIZE,\n                 \"      { %d, %d, %d, \\\"%s\\\", \\\"%s\\\", \\\"%s\\\", \\\"%s\\\" },\",\n                 size, size1, size2, nameh1, nameh2, namev1, namev2);\n        sarrayAddString(sa, buf, L_COPY);\n        LEPT_FREE(nameh1);\n        LEPT_FREE(nameh2);\n        LEPT_FREE(namev1);\n        LEPT_FREE(namev2);\n    }\n    str = sarrayToString(sa, 1);\n    len = strlen(str);\n    l_binaryWrite(fileout, \"w\", str, len + 1);\n    LEPT_FREE(str);\n    sarrayDestroy(&sa);\n    selaDestroy(&selabasic);\n    selaDestroy(&selacomb);\n    return;\n}", "target": 1}
{"code": "bool EmbFile::save2(FILE *f) {\n  int c;\n  m_objStr.streamReset();\n  while ((c = m_objStr.streamGetChar()) != EOF) {\n    fputc(c, f);\n  }\n  return true;\n}", "target": 1}
{"code": "concat_opt_exact_str(OptStr* to, UChar* s, UChar* end, OnigEncoding enc)\n{\n  int i, j, len;\n  UChar *p;\n  for (i = to->len, p = s; p < end && i < OPT_EXACT_MAXLEN; ) {\n    len = enclen(enc, p);\n    if (i + len > OPT_EXACT_MAXLEN) break;\n    for (j = 0; j < len && p < end; j++)\n      to->s[i++] = *p++;\n  }\n  to->len = i;\n  if (p >= end)\n    to->reach_end = 1;\n}", "target": 1}
{"code": "static void kvm_vcpu_destroy(struct kvm_vcpu *vcpu)\n{\n\tkvm_dirty_ring_free(&vcpu->dirty_ring);\n\tkvm_arch_vcpu_destroy(vcpu);\n\tput_pid(rcu_dereference_protected(vcpu->pid, 1));\n\tfree_page((unsigned long)vcpu->run);\n\tkmem_cache_free(kvm_vcpu_cache, vcpu);\n}", "target": 1}
{"code": "int vfs_open(const struct path *path, struct file *file,\n\t     const struct cred *cred)\n{\n\tstruct dentry *dentry = path->dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tfile->f_path = *path;\n\tif (dentry->d_flags & DCACHE_OP_SELECT_INODE) {\n\t\tinode = dentry->d_op->d_select_inode(dentry, file->f_flags);\n\t\tif (IS_ERR(inode))\n\t\t\treturn PTR_ERR(inode);\n\t}\n\treturn do_dentry_open(file, inode, NULL, cred);\n}", "target": 1}
{"code": "static int _strlen_check(int linenumber, char *buf, size_t len)\n{\n  size_t buflen = strlen(buf);\n  if(len != buflen) {\n    printf(\"sprintf strlen:%d failed:\\nwe '%d'\\nsystem: '%d'\\n\",\n           linenumber, buflen, len);\n    return 1;\n  }\n  return 0;\n}", "target": 0}
{"code": "ZEND_API void ZEND_FASTCALL convert_to_double(zval *op) \n{\n\tdouble tmp;\ntry_again:\n\tswitch (Z_TYPE_P(op)) {\n\t\tcase IS_NULL:\n\t\tcase IS_FALSE:\n\t\t\tZVAL_DOUBLE(op, 0.0);\n\t\t\tbreak;\n\t\tcase IS_TRUE:\n\t\t\tZVAL_DOUBLE(op, 1.0);\n\t\t\tbreak;\n\t\tcase IS_RESOURCE: {\n\t\t\t\tdouble d = (double) Z_RES_HANDLE_P(op);\n\t\t\t\tzval_ptr_dtor(op);\n\t\t\t\tZVAL_DOUBLE(op, d);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IS_LONG:\n\t\t\tZVAL_DOUBLE(op, (double) Z_LVAL_P(op));\n\t\t\tbreak;\n\t\tcase IS_DOUBLE:\n\t\t\tbreak;\n\t\tcase IS_STRING:\n\t\t\t{\n\t\t\t\tzend_string *str = Z_STR_P(op);\n\t\t\t\tZVAL_DOUBLE(op, zend_strtod(ZSTR_VAL(str), NULL));\n\t\t\t\tzend_string_release_ex(str, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IS_ARRAY:\n\t\t\ttmp = (zend_hash_num_elements(Z_ARRVAL_P(op))?1:0);\n\t\t\tzval_ptr_dtor(op);\n\t\t\tZVAL_DOUBLE(op, tmp);\n\t\t\tbreak;\n\t\tcase IS_OBJECT:\n\t\t\t{\n\t\t\t\tzval dst;\n\t\t\t\tconvert_object_to_type(op, &dst, IS_DOUBLE, convert_to_double);\n\t\t\t\tzval_ptr_dtor(op);\n\t\t\t\tif (Z_TYPE(dst) == IS_DOUBLE) {\n\t\t\t\t\tZVAL_DOUBLE(op, Z_DVAL(dst));\n\t\t\t\t} else {\n\t\t\t\t\tZVAL_DOUBLE(op, 1.0);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase IS_REFERENCE:\n\t\t\tzend_unwrap_reference(op);\n\t\t\tgoto try_again;\n\t\tEMPTY_SWITCH_DEFAULT_CASE()\n\t}\n}", "target": 0}
{"code": " OPJ_BOOL opj_j2k_write_rgn(opj_j2k_t *p_j2k,\n                            OPJ_UINT32 p_tile_no,\n                            OPJ_UINT32 p_comp_no,\n                            OPJ_UINT32 nb_comps,\n                            opj_stream_private_t *p_stream,\n                            opj_event_mgr_t * p_manager\n                            )\n{\n        OPJ_BYTE * l_current_data = 00;\n        OPJ_UINT32 l_rgn_size;\n        opj_cp_t *l_cp = 00;\n        opj_tcp_t *l_tcp = 00;\n        opj_tccp_t *l_tccp = 00;\n        OPJ_UINT32 l_comp_room;\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n        l_cp = &(p_j2k->m_cp);\n        l_tcp = &l_cp->tcps[p_tile_no];\n        l_tccp = &l_tcp->tccps[p_comp_no];\n        if (nb_comps <= 256) {\n                l_comp_room = 1;\n        }\n        else {\n                l_comp_room = 2;\n        }\n        l_rgn_size = 6 + l_comp_room;\n        l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n        opj_write_bytes(l_current_data,J2K_MS_RGN,2);                                   \n        l_current_data += 2;\n        opj_write_bytes(l_current_data,l_rgn_size-2,2);                                 \n        l_current_data += 2;\n        opj_write_bytes(l_current_data,p_comp_no,l_comp_room);                          \n        l_current_data+=l_comp_room;\n        opj_write_bytes(l_current_data, 0,1);                                           \n        ++l_current_data;\n        opj_write_bytes(l_current_data, (OPJ_UINT32)l_tccp->roishift,1);                            \n        ++l_current_data;\n        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_rgn_size,p_manager) != l_rgn_size) {\n                return OPJ_FALSE;\n        }\n        return OPJ_TRUE;\n}", "target": 0}
{"code": "init_syntax_once ()\n{\n   register int c;\n   static int done;\n   if (done)\n     return;\n   bzero (re_syntax_table, sizeof re_syntax_table);\n   for (c = 'a'; c <= 'z'; c++)\n     re_syntax_table[c] = Sword;\n   for (c = 'A'; c <= 'Z'; c++)\n     re_syntax_table[c] = Sword;\n   for (c = '0'; c <= '9'; c++)\n     re_syntax_table[c] = Sword;\n   re_syntax_table['_'] = Sword;\n   done = 1;\n}", "target": 1}
{"code": "static inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)\n{\n\treturn F2FS_M_SB(page->mapping);\n}", "target": 1}
{"code": "void ConnectDialog::on_qtwServers_customContextMenuRequested(const QPoint &mpos) {\n\tServerItem *si = static_cast<ServerItem *>(qtwServers->itemAt(mpos));\n\tqmPopup->clear();\n\tif (si != NULL && si->bParent) {\n\t\tsi = NULL;\n\t}\n\tif (si != NULL) {\n\t\tif (!g.s.disableConnectDialogEditing) {\n\t\t\tif (si->itType == ServerItem::FavoriteType) {\n\t\t\t\tqmPopup->addAction(qaFavoriteEdit);\n\t\t\t\tqmPopup->addAction(qaFavoriteRemove);\n\t\t\t} else {\n\t\t\t\tqmPopup->addAction(qaFavoriteAdd);\n\t\t\t}\n\t\t}\n\t\tif (!si->qsUrl.isEmpty()) {\n\t\t\tqmPopup->addAction(qaUrl);\n\t\t}\n\t}\n\tif (! qmPopup->isEmpty()) {\n\t\tqmPopup->addSeparator();\n\t}\n\tqmPopup->addMenu(qmFilters);\n\tqmPopup->popup(qtwServers->viewport()->mapToGlobal(mpos), NULL);\n}", "target": 0}
{"code": "  explicit SparseCrossOp(OpKernelConstruction* context) : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_buckets\", &num_buckets_));\n    int64 signed_hash_key_;\n    OP_REQUIRES_OK(context, context->GetAttr(\"hash_key\", &signed_hash_key_));\n    hash_key_ = static_cast<uint64>(signed_hash_key_);\n    OP_REQUIRES_OK(context, context->GetAttr(\"internal_type\", &internal_type_));\n  }", "target": 0}
{"code": "static inline bool is_exception(u32 intr_info)\n{\n\treturn (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VALID_MASK))\n\t\t== (INTR_TYPE_HARD_EXCEPTION | INTR_INFO_VALID_MASK);\n}", "target": 1}
{"code": "int git_treebuilder_create(git_treebuilder **builder_p, const git_tree *source)\n{\n\tgit_treebuilder *bld;\n\tsize_t i, source_entries = DEFAULT_TREE_SIZE;\n\tassert(builder_p);\n\tbld = git__calloc(1, sizeof(git_treebuilder));\n\tGITERR_CHECK_ALLOC(bld);\n\tif (source != NULL)\n\t\tsource_entries = source->entries.length;\n\tif (git_vector_init(&bld->entries, source_entries, entry_sort_cmp) < 0)\n\t\tgoto on_error;\n\tif (source != NULL) {\n\t\tgit_tree_entry *entry_src;\n\t\tgit_vector_foreach(&source->entries, i, entry_src) {\n\t\t\tif (append_entry(\n\t\t\t\tbld, entry_src->filename,\n\t\t\t\t&entry_src->oid,\n\t\t\t\tentry_src->attr) < 0)\n\t\t\t\tgoto on_error;\n\t\t}\n\t}\n\t*builder_p = bld;\n\treturn 0;\non_error:\n\tgit_treebuilder_free(bld);\n\treturn -1;\n}", "target": 0}
{"code": "static struct btrfs_dir_item *btrfs_match_dir_item_name(struct btrfs_root *root,\n\t\t\t      struct btrfs_path *path,\n\t\t\t      const char *name, int name_len)\n{\n\tstruct btrfs_dir_item *dir_item;\n\tunsigned long name_ptr;\n\tu32 total_len;\n\tu32 cur = 0;\n\tu32 this_len;\n\tstruct extent_buffer *leaf;\n\tleaf = path->nodes[0];\n\tdir_item = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_dir_item);\n\tif (verify_dir_item(root, leaf, dir_item))\n\t\treturn NULL;\n\ttotal_len = btrfs_item_size_nr(leaf, path->slots[0]);\n\twhile (cur < total_len) {\n\t\tthis_len = sizeof(*dir_item) +\n\t\t\tbtrfs_dir_name_len(leaf, dir_item) +\n\t\t\tbtrfs_dir_data_len(leaf, dir_item);\n\t\tname_ptr = (unsigned long)(dir_item + 1);\n\t\tif (btrfs_dir_name_len(leaf, dir_item) == name_len &&\n\t\t    memcmp_extent_buffer(leaf, name, name_ptr, name_len) == 0)\n\t\t\treturn dir_item;\n\t\tcur += this_len;\n\t\tdir_item = (struct btrfs_dir_item *)((char *)dir_item +\n\t\t\t\t\t\t     this_len);\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "int HTMLBodyElement::scrollLeft()\n{\n    Document& document = this->document();\n    document.updateLayoutIgnorePendingStylesheets();\n    if (RuntimeEnabledFeatures::scrollTopLeftInteropEnabled()) {\n        RenderBox* render = renderBox();\n        if (!render)\n            return 0;\n        if (render->hasOverflowClip())\n            return adjustForAbsoluteZoom(render->scrollLeft(), render);\n        if (!document.inQuirksMode())\n            return 0;\n    }\n    FrameView* view = document.view();\n    return view ? adjustForZoom(view->scrollX(), &document) : 0;\n}", "target": 0}
{"code": "webSocketsHasDataInBuffer(rfbClientPtr cl)\n{\n    ws_ctx_t *wsctx = (ws_ctx_t *)cl->wsctx;\n    if (wsctx && wsctx->readbuflen)\n      return TRUE;\n    return (cl->sslctx && rfbssl_pending(cl) > 0);\n}", "target": 1}
{"code": "void CtcpParser::packedReply(CoreNetwork *net, const QString &bufname, const QList<QByteArray> &replies) {\n  QList<QByteArray> params;\n  int answerSize = 0;\n  for(int i = 0; i < replies.count(); i++) {\n    answerSize += replies.at(i).size();\n  }\n  QByteArray quotedReply(answerSize, 0);\n  int nextPos = 0;\n  QByteArray &reply = quotedReply;\n  for(int i = 0; i < replies.count(); i++) {\n    reply = replies.at(i);\n    quotedReply.replace(nextPos, reply.size(), reply);\n    nextPos += reply.size();\n  }\n  params << net->serverEncode(bufname) << quotedReply;\n  net->putCmd(\"NOTICE\", params);\n}", "target": 1}
{"code": "static int update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_stateid, nfs4_stateid *delegation, int open_flags)\n{\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tstruct nfs_delegation *deleg_cur;\n\tint ret = 0;\n\topen_flags &= (FMODE_READ|FMODE_WRITE);\n\trcu_read_lock();\n\tdeleg_cur = rcu_dereference(nfsi->delegation);\n\tif (deleg_cur == NULL)\n\t\tgoto no_delegation;\n\tspin_lock(&deleg_cur->lock);\n\tif (nfsi->delegation != deleg_cur ||\n\t    (deleg_cur->type & open_flags) != open_flags)\n\t\tgoto no_delegation_unlock;\n\tif (delegation == NULL)\n\t\tdelegation = &deleg_cur->stateid;\n\telse if (memcmp(deleg_cur->stateid.data, delegation->data, NFS4_STATEID_SIZE) != 0)\n\t\tgoto no_delegation_unlock;\n\tnfs_mark_delegation_referenced(deleg_cur);\n\t__update_open_stateid(state, open_stateid, &deleg_cur->stateid, open_flags);\n\tret = 1;\nno_delegation_unlock:\n\tspin_unlock(&deleg_cur->lock);\nno_delegation:\n\trcu_read_unlock();\n\tif (!ret && open_stateid != NULL) {\n\t\t__update_open_stateid(state, open_stateid, NULL, open_flags);\n\t\tret = 1;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "  virtual void OnConnectionTypeChanged(\n      net::NetworkChangeNotifier::ConnectionType type) {\n    process_host_->Send(new PpapiMsg_SetNetworkState(\n        type != net::NetworkChangeNotifier::CONNECTION_NONE));\n  }", "target": 0}
{"code": "static void do_free_upto(BIO *f, BIO *upto)\n\t{\n\tif (upto)\n\t\t{\n\t\tBIO *tbio;\n\t\tdo \n\t\t\t{\n\t\t\ttbio = BIO_pop(f);\n\t\t\tBIO_free(f);\n\t\t\tf = tbio;\n\t\t\t}\n\t\twhile (f != upto);\n\t\t}\n\telse\n\t\tBIO_free_all(f);\n\t}", "target": 1}
{"code": "  explicit BoostedTreesAggregateStatsOp(OpKernelConstruction* const context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"max_splits\", &max_splits_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_buckets\", &num_buckets_));\n  }", "target": 0}
{"code": "long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\tkey_ref = lookup_user_key(keyid, 0, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n\tkey = key_ref_to_ptr(key_ref);\n\tret = key_permission(key_ref, KEY_NEED_READ);\n\tif (ret == 0)\n\t\tgoto can_read_key;\n\tif (ret != -EACCES)\n\t\tgoto error;\n\tif (!is_key_possessed(key_ref)) {\n\t\tret = -EACCES;\n\t\tgoto error2;\n\t}\ncan_read_key:\n\tret = key_validate(key);\n\tif (ret == 0) {\n\t\tret = -EOPNOTSUPP;\n\t\tif (key->type->read) {\n\t\t\tdown_read(&key->sem);\n\t\t\tret = key->type->read(key, buffer, buflen);\n\t\t\tup_read(&key->sem);\n\t\t}\n\t}\nerror2:\n\tkey_put(key);\nerror:\n\treturn ret;\n}", "target": 1}
{"code": "static int x509_get_basic_constraints( unsigned char **p,\n                                       const unsigned char *end,\n                                       int *ca_istrue,\n                                       int *max_pathlen )\n{\n    int ret;\n    size_t len;\n    *ca_istrue = 0; \n    *max_pathlen = 0; \n    if( ( ret = mbedtls_asn1_get_tag( p, end, &len,\n            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n    if( *p == end )\n        return( 0 );\n    if( ( ret = mbedtls_asn1_get_bool( p, end, ca_istrue ) ) != 0 )\n    {\n        if( ret == MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )\n            ret = mbedtls_asn1_get_int( p, end, ca_istrue );\n        if( ret != 0 )\n            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n        if( *ca_istrue != 0 )\n            *ca_istrue = 1;\n    }\n    if( *p == end )\n        return( 0 );\n    if( ( ret = mbedtls_asn1_get_int( p, end, max_pathlen ) ) != 0 )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n    if( *p != end )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +\n                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );\n    (*max_pathlen)++;\n    return( 0 );\n}", "target": 0}
{"code": "user_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct passwd *pw, const struct member *m)\n{\n    const struct sudoers_context *ctx = parse_tree->ctx;\n    const char *lhost = parse_tree->lhost ? parse_tree->lhost : ctx->runas.host;\n    const char *shost = parse_tree->shost ? parse_tree->shost : ctx->runas.shost;\n    int matched = UNSPEC;\n    struct alias *a;\n    debug_decl(user_matches, SUDOERS_DEBUG_MATCH);\n    switch (m->type) {\n\tcase ALL:\n\t    matched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase NETGROUP:\n\t    if (netgr_matches(parse_tree->nss, m->name,\n\t\tdef_netgroup_tuple ? lhost : NULL,\n\t\tdef_netgroup_tuple ? shost : NULL, pw->pw_name))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase USERGROUP:\n\t    if (usergr_matches(m->name, pw->pw_name, pw))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase ALIAS:\n\t    if ((a = alias_get(parse_tree, m->name, USERALIAS)) != NULL) {\n\t\tconst int rc = userlist_matches(parse_tree, pw, &a->members);\n\t\tif (rc != UNSPEC) {\n\t\t    if (m->negated) {\n\t\t\tmatched = rc == ALLOW ? DENY : ALLOW;\n\t\t    } else {\n\t\t\tmatched = rc;\n\t\t    }\n\t\t}\n\t\talias_put(a);\n\t\tbreak;\n\t    }\n\t    FALLTHROUGH;\n\tcase WORD:\n\t    if (userpw_matches(m->name, pw->pw_name, pw))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n    }\n    debug_return_int(matched);\n}", "target": 1}
{"code": "void CUser::SetClientEncoding(const CString& s) {\n    m_sClientEncoding = s;\n    for (CClient* pClient : GetAllClients()) {\n        pClient->SetEncoding(s);\n    }\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* const context) override {\n    core::RefCountPtr<BoostedTreesEnsembleResource> resource;\n    OP_REQUIRES_OK(context, LookupResource(context, HandleFromInput(context, 0),\n                                           &resource));\n    OpInputList bucketized_features_list;\n    OP_REQUIRES_OK(context, context->input_list(\"bucketized_features\",\n                                                &bucketized_features_list));\n    std::vector<tensorflow::TTypes<int32>::ConstMatrix> bucketized_features;\n    bucketized_features.reserve(bucketized_features_list.size());\n    ConvertVectorsToMatrices(bucketized_features_list, bucketized_features);\n    const int batch_size = bucketized_features[0].dimension(0);\n    Tensor* output_logits_t = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                \"logits\", {batch_size, logits_dimension_},\n                                &output_logits_t));\n    auto output_logits = output_logits_t->matrix<float>();\n    if (resource->num_trees() <= 0) {\n      output_logits.setZero();\n      return;\n    }\n    const int32 last_tree = resource->num_trees() - 1;\n    auto do_work = [&resource, &bucketized_features, &output_logits, last_tree,\n                    this](int32 start, int32 end) {\n      for (int32 i = start; i < end; ++i) {\n        std::vector<float> tree_logits(logits_dimension_, 0.0);\n        int32 tree_id = 0;\n        int32 node_id = 0;\n        while (true) {\n          if (resource->is_leaf(tree_id, node_id)) {\n            const float tree_weight = resource->GetTreeWeight(tree_id);\n            const auto& leaf_logits = resource->node_value(tree_id, node_id);\n            DCHECK_EQ(leaf_logits.size(), logits_dimension_);\n            for (int32 j = 0; j < logits_dimension_; ++j) {\n              tree_logits[j] += tree_weight * leaf_logits[j];\n            }\n            if (tree_id == last_tree) {\n              break;\n            }\n            ++tree_id;\n            node_id = 0;\n          } else {\n            node_id =\n                resource->next_node(tree_id, node_id, i, bucketized_features);\n          }\n        }\n        for (int32 j = 0; j < logits_dimension_; ++j) {\n          output_logits(i, j) = tree_logits[j];\n        }\n      }\n    };\n    const int64 cost = (last_tree + 1) * 10;\n    thread::ThreadPool* const worker_threads =\n        context->device()->tensorflow_cpu_worker_threads()->workers;\n    Shard(worker_threads->NumThreads(), worker_threads, batch_size,\n          cost, do_work);\n  }", "target": 1}
{"code": "onig_get_callout_data(regex_t* reg, OnigMatchParam* mp,\n                      int callout_num, int slot,\n                      OnigType* type, OnigValue* val)\n{\n  OnigType t;\n  CalloutData* d;\n  if (callout_num <= 0) return ONIGERR_INVALID_ARGUMENT;\n  d = CALLOUT_DATA_AT_NUM(mp, callout_num);\n  if (d->last_match_at_call_counter != mp->match_at_call_counter) {\n    xmemset(d, 0, sizeof(*d));\n    d->last_match_at_call_counter = mp->match_at_call_counter;\n  }\n  t = d->slot[slot].type;\n  if (IS_NOT_NULL(type)) *type = t;\n  if (IS_NOT_NULL(val))  *val  = d->slot[slot].val;\n  return (t == ONIG_TYPE_VOID ? 1 : ONIG_NORMAL);\n}", "target": 0}
{"code": "static void nfs_fattr_free_owner_name(struct nfs_fattr *fattr)\n{\n\tfattr->valid &= ~NFS_ATTR_FATTR_OWNER_NAME;\n\tkfree(fattr->owner_name->data);\n}", "target": 0}
{"code": "void ConnectDialog::on_qaUrl_triggered() {\n\tServerItem *si = static_cast<ServerItem *>(qtwServers->currentItem());\n\tif (! si || si->qsUrl.isEmpty())\n\t\treturn;\n\tQDesktopServices::openUrl(QUrl(si->qsUrl));\n}", "target": 1}
{"code": "PHP_FUNCTION(radius_get_vendor_attr)\n{\n\tint res;\n\tconst void *data;\n\tint len;\n\tu_int32_t vendor;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &data, &len) == FAILURE) {\n\t\treturn;\n\t}\n\tres = rad_get_vendor_attr(&vendor, &data, (size_t *) &len);\n\tif (res == -1) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tarray_init(return_value);\n\t\tadd_assoc_long(return_value, \"attr\", res);\n\t\tadd_assoc_long(return_value, \"vendor\", vendor);\n\t\tadd_assoc_stringl(return_value, \"data\", (char *) data, len, 1);\n\t\treturn;\n\t}\n}", "target": 1}
{"code": "static void nodeConstruct(struct SaveNode* node, tr_variant const* v, bool sort_dicts)\n{\n    node->isVisited = false;\n    node->childIndex = 0;\n    if (sort_dicts && tr_variantIsDict(v))\n    {\n        size_t const n = v->val.l.count;\n        struct KeyIndex* tmp = tr_new(struct KeyIndex, n);\n        for (size_t i = 0; i < n; i++)\n        {\n            tmp[i].val = v->val.l.vals + i;\n            tmp[i].keystr = tr_quark_get_string(tmp[i].val->key, NULL);\n        }\n        qsort(tmp, n, sizeof(struct KeyIndex), compareKeyIndex);\n        tr_variantInitDict(&node->sorted, n);\n        for (size_t i = 0; i < n; ++i)\n        {\n            node->sorted.val.l.vals[i] = *tmp[i].val;\n        }\n        node->sorted.val.l.count = n;\n        tr_free(tmp);\n        node->v = &node->sorted;\n    }\n    else\n    {\n        node->v = v;\n    }\n}", "target": 1}
{"code": "separate_nextcmd(exarg_T *eap, int keep_backslash)\n{\n    char_u\t*p;\n#ifdef FEAT_QUICKFIX\n    p = skip_grep_pat(eap);\n#else\n    p = eap->arg;\n#endif\n    for ( ; *p; MB_PTR_ADV(p))\n    {\n\tif (*p == Ctrl_V)\n\t{\n\t    if ((eap->argt & (EX_CTRLV | EX_XFILE)) || keep_backslash)\n\t\t++p;\t\t\n\t    else\n\t\tSTRMOVE(p, p + 1);\n\t    if (*p == NUL)\t\t\n\t\tbreak;\n\t}\n#ifdef FEAT_EVAL\n\telse if (p[0] == '`' && p[1] == '=' && (eap->argt & EX_XFILE))\n\t{\n\t    p += 2;\n\t    (void)skip_expr(&p, NULL);\n\t    if (*p == NUL)\t\t\n\t\tbreak;\n\t}\n#endif\n\telse if ((*p == '\"'\n#ifdef FEAT_EVAL\n\t\t    && !in_vim9script()\n#endif\n\t\t    && !(eap->argt & EX_NOTRLCOM)\n\t\t    && ((eap->cmdidx != CMD_at && eap->cmdidx != CMD_star)\n\t\t\t\t\t\t\t      || p != eap->arg)\n\t\t    && (eap->cmdidx != CMD_redir\n\t\t\t\t\t || p != eap->arg + 1 || p[-1] != '@'))\n#ifdef FEAT_EVAL\n\t\t|| (*p == '#'\n\t\t    && in_vim9script()\n\t\t    && !(eap->argt & EX_NOTRLCOM)\n\t\t    && p > eap->cmd && VIM_ISWHITE(p[-1]))\n#endif\n\t\t|| *p == '|' || *p == '\\n')\n\t{\n\t    if ((vim_strchr(p_cpo, CPO_BAR) == NULL\n\t\t\t      || !(eap->argt & EX_CTRLV)) && *(p - 1) == '\\\\')\n\t    {\n\t\tif (!keep_backslash)\n\t\t{\n\t\t    STRMOVE(p - 1, p);\t\n\t\t    --p;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\teap->nextcmd = check_nextcmd(p);\n\t\t*p = NUL;\n\t\tbreak;\n\t    }\n\t}\n    }\n    if (!(eap->argt & EX_NOTRLCOM))\t\n\tdel_trailing_spaces(eap->arg);\n}", "target": 0}
{"code": "static void update_exception_bitmap(struct kvm_vcpu *vcpu)\n{\n\tu32 eb;\n\teb = (1u << PF_VECTOR) | (1u << UD_VECTOR) | (1u << MC_VECTOR) |\n\t     (1u << NM_VECTOR) | (1u << DB_VECTOR);\n\tif ((vcpu->guest_debug &\n\t     (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP)) ==\n\t    (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP))\n\t\teb |= 1u << BP_VECTOR;\n\tif (to_vmx(vcpu)->rmode.vm86_active)\n\t\teb = ~0;\n\tif (enable_ept)\n\t\teb &= ~(1u << PF_VECTOR); \n\tif (vcpu->fpu_active)\n\t\teb &= ~(1u << NM_VECTOR);\n\tif (is_guest_mode(vcpu))\n\t\teb |= get_vmcs12(vcpu)->exception_bitmap;\n\tvmcs_write32(EXCEPTION_BITMAP, eb);\n}", "target": 1}
{"code": "void l2tp_packet_print(const struct l2tp_packet_t *pack,\n\t\t       void (*print)(const char *fmt, ...))\n{\n\tconst struct l2tp_attr_t *attr;\n\tconst struct l2tp_dict_value_t *val;\n\tif (pack->hdr.ver == 2) {\n\t\tprint(\"[L2TP tid=%u sid=%u\", ntohs(pack->hdr.tid), ntohs(pack->hdr.sid));\n\t\tlog_ppp_debug(\" Ns=%u Nr=%u\", ntohs(pack->hdr.Ns), ntohs(pack->hdr.Nr));\n\t} else {\n\t\tprint(\"[L2TP cid=%u\", pack->hdr.cid);\n\t\tlog_ppp_debug(\" Ns=%u Nr=%u\", ntohs(pack->hdr.Ns), ntohs(pack->hdr.Nr));\n\t}\n\tlist_for_each_entry(attr, &pack->attrs, entry) {\n\t\tprint(\" <%s\", attr->attr->name);\n\t\tval = l2tp_dict_find_value(attr->attr, attr->val);\n\t\tif (val)\n\t\t\tprint(\" %s\", val->name);\n\t\telse if (attr->H)\n\t\t\tprint(\" (hidden, %hu bytes)\", attr->length);\n\t\telse {\n\t\t\tswitch (attr->attr->type) {\n\t\t\t\tcase ATTR_TYPE_INT16:\n\t\t\t\t\tprint(\" %i\", attr->val.int16);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE_INT32:\n\t\t\t\t\tprint(\" %i\", attr->val.int32);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE_STRING:\n\t\t\t\t\tprint(\" %s\", attr->val.string);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprint(\">\");\n\t}\n\tprint(\"]\\n\");\n}", "target": 1}
{"code": "void exit_mmap(struct mm_struct *mm)\n{\n\tstruct mmu_gather tlb;\n\tstruct vm_area_struct *vma;\n\tunsigned long nr_accounted = 0;\n\tmmu_notifier_release(mm);\n\tif (mm->locked_vm) {\n\t\tvma = mm->mmap;\n\t\twhile (vma) {\n\t\t\tif (vma->vm_flags & VM_LOCKED)\n\t\t\t\tmunlock_vma_pages_all(vma);\n\t\t\tvma = vma->vm_next;\n\t\t}\n\t}\n\tarch_exit_mmap(mm);\n\tvma = mm->mmap;\n\tif (!vma)\t\n\t\treturn;\n\tlru_add_drain();\n\tflush_cache_mm(mm);\n\ttlb_gather_mmu(&tlb, mm, 0, -1);\n\tunmap_vmas(&tlb, vma, 0, -1);\n\tif (unlikely(mm_is_oom_victim(mm))) {\n\t\tset_bit(MMF_OOM_SKIP, &mm->flags);\n\t\tdown_write(&mm->mmap_sem);\n\t\tup_write(&mm->mmap_sem);\n\t}\n\tfree_pgtables(&tlb, vma, FIRST_USER_ADDRESS, USER_PGTABLES_CEILING);\n\ttlb_finish_mmu(&tlb, 0, -1);\n\twhile (vma) {\n\t\tif (vma->vm_flags & VM_ACCOUNT)\n\t\t\tnr_accounted += vma_pages(vma);\n\t\tvma = remove_vma(vma);\n\t}\n\tvm_unacct_memory(nr_accounted);\n}", "target": 1}
{"code": "set_cs_start(char *line)\n{\n  char *p, *q, *r;\n  if ((p = strstr(line, \"string currentfile\"))) {\n    if (!strstr(line, \"readstring\"))\n      return;\n    *p = '\\0';\t\t\t\t\t  \n    q = strrchr(line, '/');\n    if (q) {\n      r = cs_start;\n      ++q;\n      while (!isspace(*q) && *q != '{')\n\t*r++ = *q++;\n      *r = '\\0';\n    }\n    *p = 's';\t\t\t\t\t  \n  }\n}", "target": 1}
{"code": "static gboolean key_value_ok(gchar *key, gchar *value)\n{\n    char *i;\n    for (i = key; *i != 0; i++)\n    {\n        if (!isalpha(*i) && (*i != '-') && (*i != '_') && (*i != ' '))\n            return FALSE;\n    }\n    if (strcmp(key, \"basename\") == 0\n     || strcmp(key, FILENAME_TYPE) == 0\n    )\n    {\n        if (!is_correct_filename(value))\n        {\n            error_msg(\"Value of '%s' ('%s') is not a valid directory name\",\n                      key, value);\n            return FALSE;\n        }\n    }\n    return TRUE;\n}", "target": 1}
{"code": "irc_server_sasl_enabled (struct t_irc_server *server)\n{\n    int sasl_mechanism, rc;\n    char *sasl_username, *sasl_password;\n    const char *sasl_key;\n    sasl_mechanism = IRC_SERVER_OPTION_INTEGER(\n        server, IRC_SERVER_OPTION_SASL_MECHANISM);\n    sasl_username = irc_server_eval_expression (\n        server,\n        IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_SASL_USERNAME));\n    sasl_password = irc_server_eval_expression (\n        server,\n        IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_SASL_PASSWORD));\n    sasl_key = IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_SASL_KEY);\n    rc = ((sasl_mechanism == IRC_SASL_MECHANISM_EXTERNAL)\n          || ((sasl_mechanism == IRC_SASL_MECHANISM_ECDSA_NIST256P_CHALLENGE)\n              && sasl_username && sasl_username[0]\n              && sasl_key && sasl_key[0])\n          || (sasl_username && sasl_username[0]\n              && sasl_password && sasl_password[0])) ? 1 : 0;\n    if (sasl_username)\n        free (sasl_username);\n    if (sasl_password)\n        free (sasl_password);\n    return rc;\n}", "target": 0}
{"code": "snmp_ber_encode_length(unsigned char *out, uint32_t *out_len, uint8_t length)\n{\n  *out-- = length;\n  (*out_len)++;\n  return out;\n}", "target": 1}
{"code": "static int xfrm_expand_policies(const struct flowi *fl, u16 family,\n\t\t\t\tstruct xfrm_policy **pols,\n\t\t\t\tint *num_pols, int *num_xfrms)\n{\n\tint i;\n\tif (*num_pols == 0 || !pols[0]) {\n\t\t*num_pols = 0;\n\t\t*num_xfrms = 0;\n\t\treturn 0;\n\t}\n\tif (IS_ERR(pols[0]))\n\t\treturn PTR_ERR(pols[0]);\n\t*num_xfrms = pols[0]->xfrm_nr;\n#ifdef CONFIG_XFRM_SUB_POLICY\n\tif (pols[0]->action == XFRM_POLICY_ALLOW &&\n\t    pols[0]->type != XFRM_POLICY_TYPE_MAIN) {\n\t\tpols[1] = xfrm_policy_lookup_bytype(xp_net(pols[0]),\n\t\t\t\t\t\t    XFRM_POLICY_TYPE_MAIN,\n\t\t\t\t\t\t    fl, family,\n\t\t\t\t\t\t    XFRM_POLICY_OUT,\n\t\t\t\t\t\t    pols[0]->if_id);\n\t\tif (pols[1]) {\n\t\t\tif (IS_ERR(pols[1])) {\n\t\t\t\txfrm_pols_put(pols, *num_pols);\n\t\t\t\treturn PTR_ERR(pols[1]);\n\t\t\t}\n\t\t\t(*num_pols)++;\n\t\t\t(*num_xfrms) += pols[1]->xfrm_nr;\n\t\t}\n\t}\n#endif\n\tfor (i = 0; i < *num_pols; i++) {\n\t\tif (pols[i]->action != XFRM_POLICY_ALLOW) {\n\t\t\t*num_xfrms = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "resolve_op_from_commit (FlatpakTransaction *self,\n                        FlatpakTransactionOperation *op,\n                        const char *checksum,\n                        GFile *sideload_path,\n                        GVariant *commit_data,\n                        GError **error)\n{\n  g_autoptr(GBytes) metadata_bytes = NULL;\n  g_autoptr(GVariant) commit_metadata = NULL;\n  const char *xa_metadata = NULL;\n  guint64 download_size = 0;\n  guint64 installed_size = 0;\n  commit_metadata = g_variant_get_child_value (commit_data, 0);\n  g_variant_lookup (commit_metadata, \"xa.metadata\", \"&s\", &xa_metadata);\n  if (xa_metadata == NULL)\n    return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA,\n                               \"No xa.metadata in local commit %s ref %s\",\n                               checksum, flatpak_decomposed_get_ref (op->ref));\n  metadata_bytes = g_bytes_new (xa_metadata, strlen (xa_metadata));\n  if (g_variant_lookup (commit_metadata, \"xa.download-size\", \"t\", &download_size))\n    op->download_size = GUINT64_FROM_BE (download_size);\n  if (g_variant_lookup (commit_metadata, \"xa.installed-size\", \"t\", &installed_size))\n    op->installed_size = GUINT64_FROM_BE (installed_size);\n  g_variant_lookup (commit_metadata, OSTREE_COMMIT_META_KEY_ENDOFLIFE, \"s\", &op->eol);\n  g_variant_lookup (commit_metadata, OSTREE_COMMIT_META_KEY_ENDOFLIFE_REBASE, \"s\", &op->eol_rebase);\n  return resolve_op_end (self, op, checksum, sideload_path, metadata_bytes, error);\n}", "target": 0}
{"code": "absl::Status Ipv4Instance::validateProtocolSupported() {\n  static const bool supported = SocketInterfaceSingleton::get().ipFamilySupported(AF_INET);\n  if (supported) {\n    return absl::OkStatus();\n  }\n  return absl::FailedPreconditionError(\"IPv4 addresses are not supported on this machine\");\n}", "target": 1}
{"code": "static void m_stop(struct seq_file *m, void *v)\n{\n\tstruct proc_maps_private *priv = m->private;\n\tstruct vm_area_struct *vma = v;\n\tvma_stop(priv, vma);\n\tif (priv->task)\n\t\tput_task_struct(priv->task);\n}", "target": 1}
{"code": "int __ref online_pages(unsigned long pfn, unsigned long nr_pages)\n{\n\tunsigned long onlined_pages = 0;\n\tstruct zone *zone;\n\tint need_zonelists_rebuild = 0;\n\tint nid;\n\tint ret;\n\tstruct memory_notify arg;\n\tlock_memory_hotplug();\n\targ.start_pfn = pfn;\n\targ.nr_pages = nr_pages;\n\targ.status_change_nid = -1;\n\tnid = page_to_nid(pfn_to_page(pfn));\n\tif (node_present_pages(nid) == 0)\n\t\targ.status_change_nid = nid;\n\tret = memory_notify(MEM_GOING_ONLINE, &arg);\n\tret = notifier_to_errno(ret);\n\tif (ret) {\n\t\tmemory_notify(MEM_CANCEL_ONLINE, &arg);\n\t\tunlock_memory_hotplug();\n\t\treturn ret;\n\t}\n\tzone = page_zone(pfn_to_page(pfn));\n\tmutex_lock(&zonelists_mutex);\n\tif (!populated_zone(zone))\n\t\tneed_zonelists_rebuild = 1;\n\tret = walk_system_ram_range(pfn, nr_pages, &onlined_pages,\n\t\tonline_pages_range);\n\tif (ret) {\n\t\tmutex_unlock(&zonelists_mutex);\n\t\tprintk(KERN_DEBUG \"online_pages [mem %#010llx-%#010llx] failed\\n\",\n\t\t       (unsigned long long) pfn << PAGE_SHIFT,\n\t\t       (((unsigned long long) pfn + nr_pages)\n\t\t\t    << PAGE_SHIFT) - 1);\n\t\tmemory_notify(MEM_CANCEL_ONLINE, &arg);\n\t\tunlock_memory_hotplug();\n\t\treturn ret;\n\t}\n\tzone->present_pages += onlined_pages;\n\tzone->zone_pgdat->node_present_pages += onlined_pages;\n\tif (need_zonelists_rebuild)\n\t\tbuild_all_zonelists(NULL, zone);\n\telse\n\t\tzone_pcp_update(zone);\n\tmutex_unlock(&zonelists_mutex);\n\tinit_per_zone_wmark_min();\n\tif (onlined_pages) {\n\t\tkswapd_run(zone_to_nid(zone));\n\t\tnode_set_state(zone_to_nid(zone), N_HIGH_MEMORY);\n\t}\n\tvm_total_pages = nr_free_pagecache_pages();\n\twriteback_set_ratelimit();\n\tif (onlined_pages)\n\t\tmemory_notify(MEM_ONLINE, &arg);\n\tunlock_memory_hotplug();\n\treturn 0;\n}", "target": 1}
{"code": "static void cil_reset_classpermission(struct cil_classpermission *cp)\n{\n\tif (cp == NULL) {\n\t\treturn;\n\t}\n\tcil_reset_classperms_list(cp->classperms);\n}", "target": 1}
{"code": "static int load_file(struct augeas *aug, struct lens *lens,\n                     const char *lens_name, char *filename) {\n    char *text = NULL;\n    const char *err_status = NULL;\n    struct tree *tree = NULL;\n    char *path = NULL;\n    struct lns_error *err = NULL;\n    struct span *span = NULL;\n    int result = -1, r, text_len = 0;\n    path = file_name_path(aug, filename);\n    ERR_NOMEM(path == NULL, aug);\n    r = add_file_info(aug, path, lens, lens_name, filename, false);\n    if (r < 0)\n        goto done;\n    text = xread_file(filename);\n    if (text == NULL) {\n        err_status = \"read_failed\";\n        goto done;\n    }\n    text_len = strlen(text);\n    text = append_newline(text, text_len);\n    struct info *info;\n    make_ref(info);\n    make_ref(info->filename);\n    info->filename->str = strdup(filename);\n    info->error = aug->error;\n    info->flags = aug->flags;\n    info->first_line = 1;\n    if (aug->flags & AUG_ENABLE_SPAN) {\n        span = make_span(info);\n        ERR_NOMEM(span == NULL, info);\n    }\n    tree = lns_get(info, lens, text, &err);\n    unref(info, info);\n    if (err != NULL) {\n        err_status = \"parse_failed\";\n        goto done;\n    }\n    tree_replace(aug, path, tree);\n    if (span != NULL && tree != NULL) {\n        tree->parent->span = span;\n        tree->parent->span->span_start = 0;\n        tree->parent->span->span_end = text_len;\n    }\n    tree = NULL;\n    result = 0;\n done:\n    store_error(aug, filename + strlen(aug->root) - 1, path, err_status,\n                errno, err, text);\n error:\n    free_lns_error(err);\n    free(path);\n    free_tree(tree);\n    free(text);\n    return result;\n}", "target": 0}
{"code": "ServerSecurityFeature::ServerSecurityFeature(application_features::ApplicationServer& server)\n    : ApplicationFeature(server, \"ServerSecurity\"),\n      _enableFoxxApi(true),\n      _enableFoxxStore(true),\n      _hardenedRestApi(false) {\n  setOptional(false);\n  startsAfter<application_features::GreetingsFeaturePhase>();\n}", "target": 1}
{"code": "GF_AV1Config *gf_isom_av1_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tif (gf_isom_get_reference_count(the_file, trackNumber, GF_ISOM_REF_TBAS)) {\n\t\tu32 ref_track;\n\t\tGF_Err e = gf_isom_get_reference(the_file, trackNumber, GF_ISOM_REF_TBAS, 1, &ref_track);\n\t\tif (e == GF_OK) {\n\t\t\ttrackNumber = ref_track;\n\t\t}\n\t}\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex - 1);\n\tif (!entry || !entry->av1_config) return NULL;\n\treturn AV1_DuplicateConfig(entry->av1_config->config);\n}", "target": 1}
{"code": "    TaskFactory& TaskFactory::instance()\n    {\n        static TaskFactory ins;\n        return ins;\n    }", "target": 0}
{"code": "tvb_get_manuf_name_if_known(tvbuff_t *tvb, gint offset)\n{\n    return get_manuf_name_if_known(tvb_get_ptr(tvb, offset, 3));\n}", "target": 1}
{"code": "void ipmi_unregister_smi(struct ipmi_smi *intf)\n{\n\tstruct ipmi_smi_watcher *w;\n\tint intf_num = intf->intf_num, index;\n\tmutex_lock(&ipmi_interfaces_mutex);\n\tintf->intf_num = -1;\n\tintf->in_shutdown = true;\n\tlist_del_rcu(&intf->link);\n\tmutex_unlock(&ipmi_interfaces_mutex);\n\tsynchronize_srcu(&ipmi_interfaces_srcu);\n\tmutex_lock(&smi_watchers_mutex);\n\tlist_for_each_entry(w, &smi_watchers, link)\n\t\tw->smi_gone(intf_num);\n\tmutex_unlock(&smi_watchers_mutex);\n\tindex = srcu_read_lock(&intf->users_srcu);\n\twhile (!list_empty(&intf->users)) {\n\t\tstruct ipmi_user *user =\n\t\t\tcontainer_of(list_next_rcu(&intf->users),\n\t\t\t\t     struct ipmi_user, link);\n\t\t_ipmi_destroy_user(user);\n\t}\n\tsrcu_read_unlock(&intf->users_srcu, index);\n\tif (intf->handlers->shutdown)\n\t\tintf->handlers->shutdown(intf->send_info);\n\tcleanup_smi_msgs(intf);\n\tipmi_bmc_unregister(intf);\n\tcleanup_srcu_struct(&intf->users_srcu);\n\tkref_put(&intf->refcount, intf_free);\n}", "target": 0}
{"code": "static struct sock *x25_make_new(struct sock *osk)\n{\n\tstruct sock *sk = NULL;\n\tstruct x25_sock *x25, *ox25;\n\tif (osk->sk_type != SOCK_SEQPACKET)\n\t\tgoto out;\n\tif ((sk = x25_alloc_socket(sock_net(osk), 0)) == NULL)\n\t\tgoto out;\n\tx25 = x25_sk(sk);\n\tsk->sk_type        = osk->sk_type;\n\tsk->sk_priority    = osk->sk_priority;\n\tsk->sk_protocol    = osk->sk_protocol;\n\tsk->sk_rcvbuf      = osk->sk_rcvbuf;\n\tsk->sk_sndbuf      = osk->sk_sndbuf;\n\tsk->sk_state       = TCP_ESTABLISHED;\n\tsk->sk_backlog_rcv = osk->sk_backlog_rcv;\n\tsock_copy_flags(sk, osk);\n\tox25 = x25_sk(osk);\n\tx25->t21        = ox25->t21;\n\tx25->t22        = ox25->t22;\n\tx25->t23        = ox25->t23;\n\tx25->t2         = ox25->t2;\n\tx25->flags\t= ox25->flags;\n\tx25->facilities = ox25->facilities;\n\tx25->dte_facilities = ox25->dte_facilities;\n\tx25->cudmatchlength = ox25->cudmatchlength;\n\tclear_bit(X25_INTERRUPT_FLAG, &x25->flags);\n\tx25_init_timers(sk);\nout:\n\treturn sk;\n}", "target": 0}
{"code": "   Format a local time/date according to locale settings */\nPHP_FUNCTION(strftime)\n{\n\tphp_strftime(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);", "target": 0}
{"code": "static int sco_sock_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t       char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint len, err = 0;\n\tstruct bt_voice voice;\n\tu32 phys;\n\tint pkt_status;\n\tBT_DBG(\"sk %p\", sk);\n\tif (level == SOL_SCO)\n\t\treturn sco_sock_getsockopt_old(sock, optname, optval, optlen);\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tlock_sock(sk);\n\tswitch (optname) {\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (put_user(test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags),\n\t\t\t     (u32 __user *)optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase BT_VOICE:\n\t\tvoice.setting = sco_pi(sk)->setting;\n\t\tlen = min_t(unsigned int, len, sizeof(voice));\n\t\tif (copy_to_user(optval, (char *)&voice, len))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase BT_PHY:\n\t\tif (sk->sk_state != BT_CONNECTED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\t\tphys = hci_conn_get_phy(sco_pi(sk)->conn->hcon);\n\t\tif (put_user(phys, (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase BT_PKT_STATUS:\n\t\tpkt_status = (sco_pi(sk)->cmsg_mask & SCO_CMSG_PKT_STATUS);\n\t\tif (put_user(pkt_status, (int __user *)optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase BT_SNDMTU:\n\tcase BT_RCVMTU:\n\t\tif (sk->sk_state != BT_CONNECTED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\t\tif (put_user(sco_pi(sk)->conn->mtu, (u32 __user *)optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "static int jsR_delproperty(js_State *J, js_Object *obj, const char *name)\n{\n\tjs_Property *ref;\n\tint k;\n\tif (obj->type == JS_CARRAY) {\n\t\tif (!strcmp(name, \"length\"))\n\t\t\tgoto dontconf;\n\t}\n\telse if (obj->type == JS_CSTRING) {\n\t\tif (!strcmp(name, \"length\"))\n\t\t\tgoto dontconf;\n\t\tif (js_isarrayindex(J, name, &k))\n\t\t\tif (js_runeat(J, obj->u.s.string, k))\n\t\t\t\tgoto dontconf;\n\t}\n\telse if (obj->type == JS_CREGEXP) {\n\t\tif (!strcmp(name, \"source\")) goto dontconf;\n\t\tif (!strcmp(name, \"global\")) goto dontconf;\n\t\tif (!strcmp(name, \"ignoreCase\")) goto dontconf;\n\t\tif (!strcmp(name, \"multiline\")) goto dontconf;\n\t\tif (!strcmp(name, \"lastIndex\")) goto dontconf;\n\t}\n\telse if (obj->type == JS_CUSERDATA) {\n\t\tif (obj->u.user.delete && obj->u.user.delete(J, obj->u.user.data, name))\n\t\t\treturn 1;\n\t}\n\tref = jsV_getownproperty(J, obj, name);\n\tif (ref) {\n\t\tif (ref->atts & JS_DONTCONF)\n\t\t\tgoto dontconf;\n\t\tjsV_delproperty(J, obj, name);\n\t}\n\treturn 1;\ndontconf:\n\tif (J->strict)\n\t\tjs_typeerror(J, \"'%s' is non-configurable\", name);\n\treturn 0;\n}", "target": 0}
{"code": "\t__must_hold(wqe->lock)\n{\n\tstruct io_wqe_acct *acct = io_wqe_get_acct(worker);\n\tstruct io_wqe *wqe = worker->wqe;\n\tif (!(worker->flags & IO_WORKER_F_UP))\n\t\treturn;\n\tif (atomic_dec_and_test(&acct->nr_running) && io_acct_run_queue(acct)) {\n\t\tatomic_inc(&acct->nr_running);\n\t\tatomic_inc(&wqe->wq->worker_refs);\n\t\tio_queue_worker_create(worker, acct, create_worker_cb);\n\t}\n}", "target": 0}
{"code": "void *bson_realloc( void *ptr, int size ) {\n    void *p;\n    p = bson_realloc_func( ptr, size );\n    bson_fatal_msg( !!p, \"realloc() failed\" );\n    return p;\n}", "target": 1}
{"code": "static noinline_for_stack int ethtool_get_rxnfc(struct net_device *dev,\n\t\t\t\t\t\tvoid __user *useraddr)\n{\n\tstruct ethtool_rxnfc info;\n\tconst struct ethtool_ops *ops = dev->ethtool_ops;\n\tint ret;\n\tvoid *rule_buf = NULL;\n\tif (!ops->get_rxnfc)\n\t\treturn -EOPNOTSUPP;\n\tif (copy_from_user(&info, useraddr, sizeof(info)))\n\t\treturn -EFAULT;\n\tif (info.cmd == ETHTOOL_GRXCLSRLALL) {\n\t\tif (info.rule_cnt > 0) {\n\t\t\trule_buf = kmalloc(info.rule_cnt * sizeof(u32),\n\t\t\t\t\t   GFP_USER);\n\t\t\tif (!rule_buf)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tret = ops->get_rxnfc(dev, &info, rule_buf);\n\tif (ret < 0)\n\t\tgoto err_out;\n\tret = -EFAULT;\n\tif (copy_to_user(useraddr, &info, sizeof(info)))\n\t\tgoto err_out;\n\tif (rule_buf) {\n\t\tuseraddr += offsetof(struct ethtool_rxnfc, rule_locs);\n\t\tif (copy_to_user(useraddr, rule_buf,\n\t\t\t\t info.rule_cnt * sizeof(u32)))\n\t\t\tgoto err_out;\n\t}\n\tret = 0;\nerr_out:\n\tkfree(rule_buf);\n\treturn ret;\n}", "target": 1}
{"code": "static int chdir_to_parent(char *copy, const char **lastp)\n{\n\tchar *tmp;\n\tconst char *parent;\n\tchar buf[65536];\n\tint res;\n\ttmp = strrchr(copy, '/');\n\tif (tmp == NULL || tmp[1] == '\\0') {\n\t\tfprintf(stderr, \"%s: internal error: invalid abs path: <%s>\\n\",\n\t\t\tprogname, copy);\n\t\treturn -1;\n\t}\n\tif (tmp != copy) {\n\t\t*tmp = '\\0';\n\t\tparent = copy;\n\t\t*lastp = tmp + 1;\n\t} else if (tmp[1] != '\\0') {\n\t\t*lastp = tmp + 1;\n\t\tparent = \"/\";\n\t} else {\n\t\t*lastp = \".\";\n\t\tparent = \"/\";\n\t}\n\tres = chdir(parent);\n\tif (res == -1) {\n\t\tfprintf(stderr, \"%s: failed to chdir to %s: %s\\n\",\n\t\t\tprogname, parent, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (getcwd(buf, sizeof(buf)) == NULL) {\n\t\tfprintf(stderr, \"%s: failed to obtain current directory: %s\\n\",\n\t\t\tprogname, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (strcmp(buf, parent) != 0) {\n\t\tfprintf(stderr, \"%s: mountpoint moved (%s -> %s)\\n\", progname,\n\t\t\tparent, buf);\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "png_set_PLTE(png_structrp png_ptr, png_inforp info_ptr,\n    png_const_colorp palette, int num_palette)\n{\n   png_uint_32 max_palette_length;\n   png_debug1(1, \"in %s storage function\", \"PLTE\");\n   if (png_ptr == NULL || info_ptr == NULL)\n      return;\n   max_palette_length = (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE) ?\n      (1 << png_ptr->bit_depth) : PNG_MAX_PALETTE_LENGTH;\n   if (num_palette < 0 || num_palette > max_palette_length)\n   {\n      if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n         png_error(png_ptr, \"Invalid palette length\");\n      else\n      {\n         png_warning(png_ptr, \"Invalid palette length\");\n         return;\n      }\n   }\n   if ((num_palette > 0 && palette == NULL) ||\n      (num_palette == 0\n#        ifdef PNG_MNG_FEATURES_SUPPORTED\n            && (png_ptr->mng_features_permitted & PNG_FLAG_MNG_EMPTY_PLTE) == 0\n#        endif\n      ))\n   {\n      png_error(png_ptr, \"Invalid palette\");\n   }\n   png_free_data(png_ptr, info_ptr, PNG_FREE_PLTE, 0);\n   png_ptr->palette = png_voidcast(png_colorp, png_calloc(png_ptr,\n       PNG_MAX_PALETTE_LENGTH * (sizeof (png_color))));\n   if (num_palette > 0)\n      memcpy(png_ptr->palette, palette, num_palette * (sizeof (png_color)));\n   info_ptr->palette = png_ptr->palette;\n   info_ptr->num_palette = png_ptr->num_palette = (png_uint_16)num_palette;\n   info_ptr->free_me |= PNG_FREE_PLTE;\n   info_ptr->valid |= PNG_INFO_PLTE;\n}", "target": 1}
{"code": "static int gup_huge_pud(pud_t orig, pud_t *pudp, unsigned long addr,\n\t\tunsigned long end, int write, struct page **pages, int *nr)\n{\n\tstruct page *head, *page;\n\tint refs;\n\tif (!pud_access_permitted(orig, write))\n\t\treturn 0;\n\tif (pud_devmap(orig))\n\t\treturn __gup_device_huge_pud(orig, pudp, addr, end, pages, nr);\n\trefs = 0;\n\tpage = pud_page(orig) + ((addr & ~PUD_MASK) >> PAGE_SHIFT);\n\tdo {\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\t\tpage++;\n\t\trefs++;\n\t} while (addr += PAGE_SIZE, addr != end);\n\thead = compound_head(pud_page(orig));\n\tif (!page_cache_add_speculative(head, refs)) {\n\t\t*nr -= refs;\n\t\treturn 0;\n\t}\n\tif (unlikely(pud_val(orig) != pud_val(*pudp))) {\n\t\t*nr -= refs;\n\t\twhile (refs--)\n\t\t\tput_page(head);\n\t\treturn 0;\n\t}\n\tSetPageReferenced(head);\n\treturn 1;\n}", "target": 1}
{"code": "static int trusted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct trusted_key_payload *p = key->payload.data;\n\tstruct trusted_key_payload *new_p;\n\tstruct trusted_key_options *new_o;\n\tsize_t datalen = prep->datalen;\n\tchar *datablob;\n\tint ret = 0;\n\tif (!p->migratable)\n\t\treturn -EPERM;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\tdatablob = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!datablob)\n\t\treturn -ENOMEM;\n\tnew_o = trusted_options_alloc();\n\tif (!new_o) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tnew_p = trusted_payload_alloc(key);\n\tif (!new_p) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmemcpy(datablob, prep->data, datalen);\n\tdatablob[datalen] = '\\0';\n\tret = datablob_parse(datablob, new_p, new_o);\n\tif (ret != Opt_update) {\n\t\tret = -EINVAL;\n\t\tkfree(new_p);\n\t\tgoto out;\n\t}\n\tnew_p->migratable = p->migratable;\n\tnew_p->key_len = p->key_len;\n\tmemcpy(new_p->key, p->key, p->key_len);\n\tdump_payload(p);\n\tdump_payload(new_p);\n\tret = key_seal(new_p, new_o);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: key_seal failed (%d)\\n\", ret);\n\t\tkfree(new_p);\n\t\tgoto out;\n\t}\n\tif (new_o->pcrlock) {\n\t\tret = pcrlock(new_o->pcrlock);\n\t\tif (ret < 0) {\n\t\t\tpr_info(\"trusted_key: pcrlock failed (%d)\\n\", ret);\n\t\t\tkfree(new_p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\trcu_assign_keypointer(key, new_p);\n\tcall_rcu(&p->rcu, trusted_rcu_free);\nout:\n\tkfree(datablob);\n\tkfree(new_o);\n\treturn ret;\n}", "target": 0}
{"code": "static struct bio_map_data *bio_alloc_map_data(struct iov_iter *data,\n\t\t\t\t\t       gfp_t gfp_mask)\n{\n\tstruct bio_map_data *bmd;\n\tif (data->nr_segs > UIO_MAXIOV)\n\t\treturn NULL;\n\tbmd = kmalloc(struct_size(bmd, iov, data->nr_segs), gfp_mask);\n\tif (!bmd)\n\t\treturn NULL;\n\tmemcpy(bmd->iov, data->iov, sizeof(struct iovec) * data->nr_segs);\n\tbmd->iter = *data;\n\tbmd->iter.iov = bmd->iov;\n\treturn bmd;\n}", "target": 0}
{"code": "findNextBorderPixel(l_int32    w,\n                    l_int32    h,\n                    l_uint32  *data,\n                    l_int32    wpl,\n                    l_int32    px,\n                    l_int32    py,\n                    l_int32   *pqpos,\n                    l_int32   *pnpx,\n                    l_int32   *pnpy)\n{\nl_int32    qpos, i, pos, npx, npy, val;\nl_uint32  *line;\n    qpos = *pqpos;\n    for (i = 1; i < 8; i++) {\n        pos = (qpos + i) % 8;\n        npx = px + xpostab[pos];\n        npy = py + ypostab[pos];\n        line = data + npy * wpl;\n        val = GET_DATA_BIT(line, npx);\n        if (val) {\n            *pnpx = npx;\n            *pnpy = npy;\n            *pqpos = qpostab[pos];\n            return 0;\n        }\n    }\n    return 1;\n}", "target": 1}
{"code": "    JpegImage::JpegImage(BasicIo::AutoPtr io, bool create)\n        : JpegBase(ImageType::jpeg, io, create, blank_, sizeof(blank_))\n    {\n    }", "target": 0}
{"code": "find_help_tags(\n    char_u\t*arg,\n    int\t\t*num_matches,\n    char_u\t***matches,\n    int\t\tkeep_lang)\n{\n    char_u\t*s, *d;\n    int\t\ti;\n    static char *(except_tbl[][2]) = {\n\t{\"*\",\t\t\"star\"},\n\t{\"g*\",\t\t\"gstar\"},\n\t{\"[*\",\t\t\"[star\"},\n\t{\"]*\",\t\t\"]star\"},\n\t{\":*\",\t\t\":star\"},\n\t{\"", "target": 1}
{"code": "xmlAddID(xmlValidCtxtPtr ctxt, xmlDocPtr doc, const xmlChar *value,\n         xmlAttrPtr attr) {\n    xmlIDPtr ret;\n    xmlIDTablePtr table;\n    if (doc == NULL) {\n\treturn(NULL);\n    }\n    if (value == NULL) {\n\treturn(NULL);\n    }\n    if (attr == NULL) {\n\treturn(NULL);\n    }\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)  {\n        doc->ids = table = xmlHashCreateDict(0, doc->dict);\n    }\n    if (table == NULL) {\n\txmlVErrMemory(ctxt,\n\t\t\"xmlAddID: Table creation failed!\\n\");\n        return(NULL);\n    }\n    ret = (xmlIDPtr) xmlMalloc(sizeof(xmlID));\n    if (ret == NULL) {\n\txmlVErrMemory(ctxt, \"malloc failed\");\n\treturn(NULL);\n    }\n    ret->value = xmlStrdup(value);\n    ret->doc = doc;\n    if ((ctxt != NULL) && (ctxt->vstateNr != 0)) {\n\tif (doc->dict != NULL)\n\t    ret->name = xmlDictLookup(doc->dict, attr->name, -1);\n\telse\n\t    ret->name = xmlStrdup(attr->name);\n\tret->attr = NULL;\n    } else {\n\tret->attr = attr;\n\tret->name = NULL;\n    }\n    ret->lineno = xmlGetLineNo(attr->parent);\n    if (xmlHashAddEntry(table, value, ret) < 0) {\n#ifdef LIBXML_VALID_ENABLED\n\tif (ctxt != NULL) {\n\t    xmlErrValidNode(ctxt, attr->parent, XML_DTD_ID_REDEFINED,\n\t\t\t    \"ID %s already defined\\n\", value, NULL, NULL);\n\t}\n#endif \n\txmlFreeID(ret);\n\treturn(NULL);\n    }\n    if (attr != NULL)\n\tattr->atype = XML_ATTRIBUTE_ID;\n    return(ret);\n}", "target": 1}
{"code": "static int fts3DoclistCountDocids(char *aList, int nList){\n  int nDoc = 0;                   \n  if( aList ){\n    char *aEnd = &aList[nList];   \n    char *p = aList;              \n    while( p<aEnd ){\n      nDoc++;\n      while( (*p++)&0x80 );     \n      fts3PoslistCopy(0, &p);   \n    }\n  }\n  return nDoc;\n}", "target": 0}
{"code": "SPL_METHOD(SplObjectStorage, rewind)\n{\n\tspl_SplObjectStorage *intern = (spl_SplObjectStorage*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\tzend_hash_internal_pointer_reset_ex(&intern->storage, &intern->pos);\n\tintern->index = 0;\n} ", "target": 0}
{"code": "ldap_pvt_tls_get_peer_dn( void *s, struct berval *dn,\n\tLDAPDN_rewrite_dummy *func, unsigned flags )\n{\n\ttls_session *session = s;\n\tstruct berval bvdn;\n\tint rc;\n\trc = tls_imp->ti_session_peer_dn( session, &bvdn );\n\tif ( rc ) return rc;\n\trc = ldap_X509dn2bv( &bvdn, dn, \n\t\t\t    (LDAPDN_rewrite_func *)func, flags);\n\treturn rc;\n}", "target": 0}
{"code": "void sas_init_disc(struct sas_discovery *disc, struct asd_sas_port *port)\n{\n\tint i;\n\tstatic const work_func_t sas_event_fns[DISC_NUM_EVENTS] = {\n\t\t[DISCE_DISCOVER_DOMAIN] = sas_discover_domain,\n\t\t[DISCE_REVALIDATE_DOMAIN] = sas_revalidate_domain,\n\t\t[DISCE_PROBE] = sas_probe_devices,\n\t\t[DISCE_SUSPEND] = sas_suspend_devices,\n\t\t[DISCE_RESUME] = sas_resume_devices,\n\t\t[DISCE_DESTRUCT] = sas_destruct_devices,\n\t};\n\tdisc->pending = 0;\n\tfor (i = 0; i < DISC_NUM_EVENTS; i++) {\n\t\tINIT_SAS_WORK(&disc->disc_work[i].work, sas_event_fns[i]);\n\t\tdisc->disc_work[i].port = port;\n\t}\n}", "target": 1}
{"code": "static inline int pmd_present(pmd_t pmd)\n{\n\treturn pmd_flags(pmd) & _PAGE_PRESENT;\n}", "target": 1}
{"code": "static int is_fuse_usermount(struct libmnt_context *cxt, int *errsv)\n{\n\tstruct libmnt_ns *ns_old;\n\tconst char *type = mnt_fs_get_fstype(cxt->fs);\n\tconst char *optstr;\n\tchar *user_id = NULL;\n\tsize_t sz;\n\tuid_t uid;\n\tchar uidstr[sizeof(stringify_value(ULONG_MAX))];\n\t*errsv = 0;\n\tif (!type)\n\t\treturn 0;\n\tif (strcmp(type, \"fuse\") != 0 &&\n\t    strcmp(type, \"fuseblk\") != 0 &&\n\t    strncmp(type, \"fuse.\", 5) != 0 &&\n\t    strncmp(type, \"fuseblk.\", 8) != 0)\n\t\treturn 0;\n\toptstr = mnt_fs_get_fs_options(cxt->fs);\n\tif (!optstr)\n\t\treturn 0;\n\tif (mnt_optstr_get_option(optstr, \"user_id\", &user_id, &sz) != 0)\n\t\treturn 0;\n\tif (sz == 0 || user_id == NULL)\n\t\treturn 0;\n\tns_old = mnt_context_switch_origin_ns(cxt);\n\tif (!ns_old) {\n\t\t*errsv = -MNT_ERR_NAMESPACE;\n\t\treturn 0;\n\t}\n\tuid = getuid();\n\tif (!mnt_context_switch_ns(cxt, ns_old)) {\n\t\t*errsv = -MNT_ERR_NAMESPACE;\n\t\treturn 0;\n\t}\n\tsnprintf(uidstr, sizeof(uidstr), \"%lu\", (unsigned long) uid);\n\treturn strncmp(user_id, uidstr, sz) == 0;\n}", "target": 1}
{"code": " PPB_URLLoader_Impl::~PPB_URLLoader_Impl() {\n }", "target": 1}
{"code": "char* _multi_string_alloc_and_copy( LPCWSTR in )\n{\n    char *chr;\n    int len = 0;\n    if ( !in )\n    {\n        return NULL;\n    }\n    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )\n    {\n        len ++;\n    }\n    chr = malloc( len + 2 );\n    len = 0;\n    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )\n    {\n        chr[ len ] = 0xFF & in[ len ];\n        len ++;\n    }\n    chr[ len ++ ] = '\\0';\n    chr[ len ++ ] = '\\0';\n    return chr;\n}", "target": 0}
{"code": "static void enable_nmi_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tif ((svm->vcpu.arch.hflags & (HF_NMI_MASK | HF_IRET_MASK))\n\t    == HF_NMI_MASK)\n\t\treturn; \n\tsvm->nmi_singlestep = true;\n\tsvm->vmcb->save.rflags |= (X86_EFLAGS_TF | X86_EFLAGS_RF);\n\tupdate_db_bp_intercept(vcpu);\n}", "target": 1}
{"code": "be32enc_vect(unsigned char *dst, const uint32_t *src, size_t len)\n{\n  size_t i;\n  uint32_t *d;\n  for (i = 0; i < len / 4; i++) {\n    d = (uint32_t *) (dst + i * 4);\n    *d = folly::Endian::big32(src[i]);\n  }\n}", "target": 1}
{"code": "static void sixpack_close(struct tty_struct *tty)\n{\n\tstruct sixpack *sp;\n\twrite_lock_irq(&disc_data_lock);\n\tsp = tty->disc_data;\n\ttty->disc_data = NULL;\n\twrite_unlock_irq(&disc_data_lock);\n\tif (!sp)\n\t\treturn;\n\tif (!refcount_dec_and_test(&sp->refcnt))\n\t\twait_for_completion(&sp->dead);\n\tnetif_stop_queue(sp->dev);\n\tdel_timer_sync(&sp->tx_t);\n\tdel_timer_sync(&sp->resync_t);\n\tunregister_netdev(sp->dev);\n\tkfree(sp->rbuff);\n\tkfree(sp->xbuff);\n\tfree_netdev(sp->dev);\n}", "target": 1}
{"code": "virSecuritySELinuxMCSGetProcessRange(char **sens,\n                                     int *catMin,\n                                     int *catMax)\n{\n    char *ourSecContext = NULL;\n    context_t ourContext = NULL;\n    char *cat = NULL;\n    char *tmp;\n    const char *contextRange;\n    int ret = -1;\n    if (getcon_raw(&ourSecContext) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to get current process SELinux context\"));\n        goto cleanup;\n    }\n    if (!(ourContext = context_new(ourSecContext))) {\n        virReportSystemError(errno,\n                             _(\"Unable to parse current SELinux context '%s'\"),\n                             ourSecContext);\n        goto cleanup;\n    }\n    if (!(contextRange = context_range_get(ourContext)))\n        contextRange = \"s0\";\n    *sens = g_strdup(contextRange);\n    tmp = strchr(*sens, ':');\n    if (tmp) {\n        *tmp = '\\0';\n        cat = tmp + 1;\n    }\n    if ((tmp = strchr(*sens, '-')))\n        *tmp = '\\0';\n    if (!cat) {\n        *catMin = 0;\n        *catMax = 1023;\n        ret = 0;\n        goto cleanup;\n    }\n    tmp = cat;\n    if (tmp[0] != 'c') {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse category in %s\"),\n                       cat);\n        goto cleanup;\n    }\n    tmp++;\n    if (virStrToLong_i(tmp, &tmp, 10, catMin) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse category in %s\"),\n                       cat);\n        goto cleanup;\n    }\n    if (!tmp[0]) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"No category range available\"));\n        goto cleanup;\n    }\n    if (tmp[0] != '.') {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse category in %s\"),\n                       cat);\n        goto cleanup;\n    }\n    tmp++;\n    if (tmp[0] != 'c') {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse category in %s\"),\n                       cat);\n        goto cleanup;\n    }\n    tmp++;\n    if (virStrToLong_i(tmp, &tmp, 10, catMax) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse category in %s\"),\n                       cat);\n        goto cleanup;\n    }\n    ret = 0;\n cleanup:\n    if (ret < 0)\n        VIR_FREE(*sens);\n    freecon(ourSecContext);\n    context_free(ourContext);\n    return ret;\n}", "target": 0}
{"code": "static int sco_connect(struct sock *sk)\n{\n\tbdaddr_t *src = &bt_sk(sk)->src;\n\tbdaddr_t *dst = &bt_sk(sk)->dst;\n\tstruct sco_conn *conn;\n\tstruct hci_conn *hcon;\n\tstruct hci_dev  *hdev;\n\tint err, type;\n\tBT_DBG(\"%s -> %s\", batostr(src), batostr(dst));\n\thdev = hci_get_route(dst, src);\n\tif (!hdev)\n\t\treturn -EHOSTUNREACH;\n\thci_dev_lock_bh(hdev);\n\terr = -ENOMEM;\n\tif (lmp_esco_capable(hdev) && !disable_esco)\n\t\ttype = ESCO_LINK;\n\telse\n\t\ttype = SCO_LINK;\n\thcon = hci_connect(hdev, type, dst, BT_SECURITY_LOW, HCI_AT_NO_BONDING);\n\tif (!hcon)\n\t\tgoto done;\n\tconn = sco_conn_add(hcon, 0);\n\tif (!conn) {\n\t\thci_conn_put(hcon);\n\t\tgoto done;\n\t}\n\tbacpy(src, conn->src);\n\terr = sco_chan_add(conn, sk, NULL);\n\tif (err)\n\t\tgoto done;\n\tif (hcon->state == BT_CONNECTED) {\n\t\tsco_sock_clear_timer(sk);\n\t\tsk->sk_state = BT_CONNECTED;\n\t} else {\n\t\tsk->sk_state = BT_CONNECT;\n\t\tsco_sock_set_timer(sk, sk->sk_sndtimeo);\n\t}\ndone:\n\thci_dev_unlock_bh(hdev);\n\thci_dev_put(hdev);\n\treturn err;\n}", "target": 0}
{"code": "usage(void)\n{\n\tfprintf(stderr,\n\t    \"usage: ssh-agent [-c | -s] [-Dd] [-a bind_address] [-E fingerprint_hash]\\n\"\n\t    \"                 [-t life] [command [arg ...]]\\n\"\n\t    \"       ssh-agent [-c | -s] -k\\n\");\n\texit(1);\n}", "target": 1}
{"code": "static int present_and_same_family(const struct sadb_address *src,\n\t\t\t\t   const struct sadb_address *dst)\n{\n\tconst struct sockaddr *s_addr, *d_addr;\n\tif (!src || !dst)\n\t\treturn 0;\n\ts_addr = (const struct sockaddr *)(src + 1);\n\td_addr = (const struct sockaddr *)(dst + 1);\n\tif (s_addr->sa_family != d_addr->sa_family)\n\t\treturn 0;\n\tif (s_addr->sa_family != AF_INET\n#if IS_ENABLED(CONFIG_IPV6)\n\t    && s_addr->sa_family != AF_INET6\n#endif\n\t\t)\n\t\treturn 0;\n\treturn 1;\n}", "target": 0}
{"code": "static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof)\n{\n\tchar *ksep, *vsep, *val;\n\tsize_t klen, vlen;\n\tsize_t new_vlen;\n\tif (var->ptr >= var->end) {\n\t\treturn 0;\n\t}\n\tvsep = memchr(var->ptr, '&', var->end - var->ptr);\n\tif (!vsep) {\n\t\tif (!eof) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tvsep = var->end;\n\t\t}\n\t}\n\tksep = memchr(var->ptr, '=', vsep - var->ptr);\n\tif (ksep) {\n\t\t*ksep = '\\0';\n\t\tklen = ksep - var->ptr;\n\t\tvlen = vsep - ++ksep;\n\t} else {\n\t\tksep = \"\";\n\t\tklen = vsep - var->ptr;\n\t\tvlen = 0;\n\t}\n\tphp_url_decode(var->ptr, klen);\n\tval = estrndup(ksep, vlen);\n\tif (vlen) {\n\t\tvlen = php_url_decode(val, vlen);\n\t}\n\tif (sapi_module.input_filter(PARSE_POST, var->ptr, &val, vlen, &new_vlen)) {\n\t\tphp_register_variable_safe(var->ptr, val, new_vlen, arr);\n\t}\n\tefree(val);\n\tvar->ptr = vsep + (vsep != var->end);\n\treturn 1;\n}", "target": 1}
{"code": "int git_delta_read_header_fromstream(\n\tsize_t *base_sz, size_t *res_sz, git_packfile_stream *stream)\n{\n\tstatic const size_t buffer_len = DELTA_HEADER_BUFFER_LEN;\n\tunsigned char buffer[DELTA_HEADER_BUFFER_LEN];\n\tconst unsigned char *delta, *delta_end;\n\tsize_t len;\n\tssize_t read;\n\tlen = read = 0;\n\twhile (len < buffer_len) {\n\t\tread = git_packfile_stream_read(stream, &buffer[len], buffer_len - len);\n\t\tif (read == 0)\n\t\t\tbreak;\n\t\tif (read == GIT_EBUFS)\n\t\t\tcontinue;\n\t\tlen += read;\n\t}\n\tdelta = buffer;\n\tdelta_end = delta + len;\n\tif ((hdr_sz(base_sz, &delta, delta_end) < 0) ||\n\t\t(hdr_sz(res_sz, &delta, delta_end) < 0))\n\t\treturn -1;\n\treturn 0;\n}", "target": 0}
{"code": "static void bnx2x_after_function_update(struct bnx2x *bp)\n{\n\tint q, rc;\n\tstruct bnx2x_fastpath *fp;\n\tstruct bnx2x_queue_state_params queue_params = {NULL};\n\tstruct bnx2x_queue_update_params *q_update_params =\n\t\t&queue_params.params.update;\n\tqueue_params.cmd = BNX2X_Q_CMD_UPDATE;\n\t__set_bit(BNX2X_Q_UPDATE_SILENT_VLAN_REM_CHNG,\n\t\t  &q_update_params->update_flags);\n\t__set_bit(BNX2X_Q_UPDATE_SILENT_VLAN_REM,\n\t\t  &q_update_params->update_flags);\n\t__set_bit(RAMROD_COMP_WAIT, &queue_params.ramrod_flags);\n\tif (bp->afex_vlan_mode == FUNC_MF_CFG_AFEX_VLAN_ACCESS_MODE) {\n\t\tq_update_params->silent_removal_value = 0;\n\t\tq_update_params->silent_removal_mask = 0;\n\t} else {\n\t\tq_update_params->silent_removal_value =\n\t\t\t(bp->afex_def_vlan_tag & VLAN_VID_MASK);\n\t\tq_update_params->silent_removal_mask = VLAN_VID_MASK;\n\t}\n\tfor_each_eth_queue(bp, q) {\n\t\tfp = &bp->fp[q];\n\t\tqueue_params.q_obj = &bnx2x_sp_obj(bp, fp).q_obj;\n\t\trc = bnx2x_queue_state_change(bp, &queue_params);\n\t\tif (rc < 0)\n\t\t\tBNX2X_ERR(\"Failed to config silent vlan rem for Q %d\\n\",\n\t\t\t\t  q);\n\t}\n\tif (!NO_FCOE(bp) && CNIC_ENABLED(bp)) {\n\t\tfp = &bp->fp[FCOE_IDX(bp)];\n\t\tqueue_params.q_obj = &bnx2x_sp_obj(bp, fp).q_obj;\n\t\t__clear_bit(RAMROD_COMP_WAIT, &queue_params.ramrod_flags);\n\t\tsmp_mb__before_atomic();\n\t\tset_bit(BNX2X_AFEX_FCOE_Q_UPDATE_PENDING, &bp->sp_state);\n\t\tsmp_mb__after_atomic();\n\t\trc = bnx2x_queue_state_change(bp, &queue_params);\n\t\tif (rc < 0)\n\t\t\tBNX2X_ERR(\"Failed to config silent vlan rem for Q %d\\n\",\n\t\t\t\t  q);\n\t} else {\n\t\tbnx2x_link_report(bp);\n\t\tbnx2x_fw_command(bp, DRV_MSG_CODE_AFEX_VIFSET_ACK, 0);\n\t}\n}", "target": 0}
{"code": "ldap_start_tls_s ( LDAP *ld,\n\tLDAPControl **serverctrls,\n\tLDAPControl **clientctrls )\n{\n#ifndef HAVE_TLS\n\treturn LDAP_NOT_SUPPORTED;\n#else\n\tint rc;\n\tchar *rspoid = NULL;\n\tstruct berval *rspdata = NULL;\n\tif ( ldap_tls_inplace( ld ) ) {\n\t\treturn LDAP_LOCAL_ERROR;\n\t}\n\trc = ldap_extended_operation_s( ld, LDAP_EXOP_START_TLS,\n\t\tNULL, serverctrls, clientctrls, &rspoid, &rspdata );\n\tif ( rspoid != NULL ) {\n\t\tLDAP_FREE(rspoid);\n\t}\n\tif ( rspdata != NULL ) {\n\t\tber_bvfree( rspdata );\n\t}\n\tif ( rc == LDAP_SUCCESS ) {\n\t\trc = ldap_int_tls_start( ld, ld->ld_defconn, NULL );\n\t}\n\treturn rc;\n#endif\n}", "target": 0}
{"code": "_client_protocol_timeout (GsmXSMPClient *client)\n{\n        g_debug (\"GsmXSMPClient: client_protocol_timeout for client '%s' in ICE status %d\",\n                 client->priv->description,\n                 IceConnectionStatus (client->priv->ice_connection));\n        gsm_client_set_status (GSM_CLIENT (client), GSM_CLIENT_FAILED);\n        gsm_client_disconnected (GSM_CLIENT (client));\n        return FALSE;\n}", "target": 1}
{"code": "IntegrationStreamDecoderPtr HttpIntegrationTest::sendRequestAndWaitForResponse(\n    const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,\n    const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index) {\n  ASSERT(codec_client_ != nullptr);\n  IntegrationStreamDecoderPtr response;\n  if (request_body_size) {\n    response = codec_client_->makeRequestWithBody(request_headers, request_body_size);\n  } else {\n    response = codec_client_->makeHeaderOnlyRequest(request_headers);\n  }\n  waitForNextUpstreamRequest(upstream_index);\n  upstream_request_->encodeHeaders(response_headers, response_size == 0);\n  if (response_size) {\n    upstream_request_->encodeData(response_size, true);\n  }\n  response->waitForEndStream();\n  return response;\n}", "target": 1}
{"code": "static void manager_invoke_notify_message(Manager *m, Unit *u, pid_t pid, const char *buf, size_t n, FDSet *fds) {\n        _cleanup_strv_free_ char **tags = NULL;\n        assert(m);\n        assert(u);\n        assert(buf);\n        assert(n > 0);\n        tags = strv_split(buf, \"\\n\\r\");\n        if (!tags) {\n                log_oom();\n                return;\n        }\n        if (UNIT_VTABLE(u)->notify_message)\n                UNIT_VTABLE(u)->notify_message(u, pid, tags, fds);\n        else\n                log_unit_debug(u, \"Got notification message for unit. Ignoring.\");\n}", "target": 1}
{"code": "static int pfkey_do_dump(struct pfkey_sock *pfk)\n{\n\tstruct sadb_msg *hdr;\n\tint rc;\n\trc = pfk->dump.dump(pfk);\n\tif (rc == -ENOBUFS)\n\t\treturn 0;\n\tif (pfk->dump.skb) {\n\t\tif (!pfkey_can_dump(&pfk->sk))\n\t\t\treturn 0;\n\t\thdr = (struct sadb_msg *) pfk->dump.skb->data;\n\t\thdr->sadb_msg_seq = 0;\n\t\thdr->sadb_msg_errno = rc;\n\t\tpfkey_broadcast(pfk->dump.skb, GFP_ATOMIC, BROADCAST_ONE,\n\t\t\t\t&pfk->sk, sock_net(&pfk->sk));\n\t\tpfk->dump.skb = NULL;\n\t}\n\tpfkey_terminate_dump(pfk);\n\treturn rc;\n}", "target": 0}
{"code": "static bool r_bin_mdmp_init_directory(struct r_bin_mdmp_obj *obj) {\n\tint i;\n\tstruct minidump_directory entry;\n\tsdb_num_set (obj->kv, \"mdmp_directory.offset\",\n\t\t\tobj->hdr->stream_directory_rva, 0);\n\tsdb_set (obj->kv, \"mdmp_directory.format\", \"[4]E? \"\n\t\t\t\"(mdmp_stream_type)StreamType \"\n\t\t\t\"(mdmp_location_descriptor)Location\", 0);\n\tut64 rvadir = obj->hdr->stream_directory_rva;\n\tfor (i = 0; i < (int)obj->hdr->number_of_streams; i++) {\n\t\tut32 delta = i * sizeof (struct minidump_directory);\n\t\tint r = r_buf_read_at (obj->b, rvadir + delta, (ut8*) &entry, sizeof (struct minidump_directory));\n\t\tif (r) {\n\t\t\tr_bin_mdmp_init_directory_entry (obj, &entry);\n\t\t}\n\t}\n\treturn true;\n}", "target": 0}
{"code": "static void rtrs_clt_dev_release(struct device *dev)\n{\n\tstruct rtrs_clt_sess *clt = container_of(dev, struct rtrs_clt_sess,\n\t\t\t\t\t\t dev);\n\tmutex_destroy(&clt->paths_ev_mutex);\n\tmutex_destroy(&clt->paths_mutex);\n\tkfree(clt);\n}", "target": 0}
{"code": "int is_ntfs_dotgit(const char *name)\n{\n\tint len;\n\tfor (len = 0; ; len++)\n\t\tif (!name[len] || name[len] == '\\\\' || is_dir_sep(name[len])) {\n\t\t\tif (only_spaces_and_periods(name, len, 4) &&\n\t\t\t\t\t!strncasecmp(name, \".git\", 4))\n\t\t\t\treturn 1;\n\t\t\tif (only_spaces_and_periods(name, len, 5) &&\n\t\t\t\t\t!strncasecmp(name, \"git~1\", 5))\n\t\t\t\treturn 1;\n\t\t\tif (name[len] != '\\\\')\n\t\t\t\treturn 0;\n\t\t\tname += len + 1;\n\t\t\tlen = -1;\n\t\t}\n}", "target": 1}
{"code": "url_escape_1 (const char *s, unsigned char mask, bool allow_passthrough)\n{\n  const char *p1;\n  char *p2, *newstr;\n  int newlen;\n  int addition = 0;\n  for (p1 = s; *p1; p1++)\n    if (urlchr_test (*p1, mask))\n      addition += 2;            \n  if (!addition)\n    return allow_passthrough ? (char *)s : xstrdup (s);\n  newlen = (p1 - s) + addition;\n  newstr = xmalloc (newlen + 1);\n  p1 = s;\n  p2 = newstr;\n  while (*p1)\n    {\n      if (urlchr_test (*p1, mask))\n        {\n          unsigned char c = *p1++;\n          *p2++ = '%';\n          *p2++ = XNUM_TO_DIGIT (c >> 4);\n          *p2++ = XNUM_TO_DIGIT (c & 0xf);\n        }\n      else\n        *p2++ = *p1++;\n    }\n  assert (p2 - newstr == newlen);\n  *p2 = '\\0';\n  return newstr;\n}", "target": 0}
{"code": "static void iommu_enable_dev_iotlb(struct device_domain_info *info)\n{\n\tstruct pci_dev *pdev;\n\tassert_spin_locked(&device_domain_lock);\n\tif (!info || !dev_is_pci(info->dev))\n\t\treturn;\n\tpdev = to_pci_dev(info->dev);\n\tif (!ecap_dit(info->iommu->ecap))\n\t\tinfo->pfsid = 0;\n\telse {\n\t\tstruct pci_dev *pf_pdev;\n\t\tpf_pdev = pci_physfn(pdev);\n\t\tinfo->pfsid = PCI_DEVID(pf_pdev->bus->number, pf_pdev->devfn);\n\t}\n#ifdef CONFIG_INTEL_IOMMU_SVM\n\tif (info->pasid_supported && !pci_enable_pasid(pdev, info->pasid_supported & ~1))\n\t\tinfo->pasid_enabled = 1;\n\tif (info->pri_supported && !pci_reset_pri(pdev) && !pci_enable_pri(pdev, 32))\n\t\tinfo->pri_enabled = 1;\n#endif\n\tif (!pdev->untrusted && info->ats_supported &&\n\t    !pci_enable_ats(pdev, VTD_PAGE_SHIFT)) {\n\t\tinfo->ats_enabled = 1;\n\t\tdomain_update_iotlb(info->domain);\n\t\tinfo->ats_qdep = pci_ats_queue_depth(pdev);\n\t}\n}", "target": 0}
{"code": "static int __init ipgre_init(void)\n{\n\tint err;\n\tprintk(KERN_INFO \"GRE over IPv4 tunneling driver\\n\");\n\tif (inet_add_protocol(&ipgre_protocol, IPPROTO_GRE) < 0) {\n\t\tprintk(KERN_INFO \"ipgre init: can't add protocol\\n\");\n\t\treturn -EAGAIN;\n\t}\n\terr = register_pernet_device(&ipgre_net_ops);\n\tif (err < 0)\n\t\tgoto gen_device_failed;\n\terr = rtnl_link_register(&ipgre_link_ops);\n\tif (err < 0)\n\t\tgoto rtnl_link_failed;\n\terr = rtnl_link_register(&ipgre_tap_ops);\n\tif (err < 0)\n\t\tgoto tap_ops_failed;\nout:\n\treturn err;\ntap_ops_failed:\n\trtnl_link_unregister(&ipgre_link_ops);\nrtnl_link_failed:\n\tunregister_pernet_device(&ipgre_net_ops);\ngen_device_failed:\n\tinet_del_protocol(&ipgre_protocol, IPPROTO_GRE);\n\tgoto out;\n}", "target": 1}
{"code": "httpd_addheader(isc_httpd_t *httpd, const char *name, const char *val) {\n\tisc_result_t result;\n\tunsigned int needlen;\n\tREQUIRE(VALID_HTTPD(httpd));\n\tneedlen = strlen(name); \n\tif (val != NULL) {\n\t\tneedlen += 2 + strlen(val); \n\t}\n\tneedlen += 2; \n\twhile (isc_buffer_availablelength(&httpd->headerbuffer) < needlen) {\n\t\tresult = grow_headerspace(httpd);\n\t\tif (result != ISC_R_SUCCESS) {\n\t\t\treturn (result);\n\t\t}\n\t}\n\tif (val != NULL) {\n\t\treturn (isc_buffer_printf(&httpd->headerbuffer, \"%s: %s\\r\\n\",\n\t\t\t\t\t  name, val));\n\t} else {\n\t\treturn (isc_buffer_printf(&httpd->headerbuffer, \"%s\\r\\n\",\n\t\t\t\t\t  name));\n\t}\n}", "target": 0}
{"code": "static void do_free_publickey(struct rsa_public_key *s)\n{\n\tif (s) {\n\t\tcrypto_bignum_free(s->n);\n\t\tcrypto_bignum_free(s->e);\n\t}\n}", "target": 1}
{"code": "void rds_inc_init(struct rds_incoming *inc, struct rds_connection *conn,\n\t\t  __be32 saddr)\n{\n\tatomic_set(&inc->i_refcount, 1);\n\tINIT_LIST_HEAD(&inc->i_item);\n\tinc->i_conn = conn;\n\tinc->i_saddr = saddr;\n\tinc->i_rdma_cookie = 0;\n\tinc->i_rx_tstamp.tv_sec = 0;\n\tinc->i_rx_tstamp.tv_usec = 0;\n}", "target": 0}
{"code": "check_vim9_unlet(char_u *name)\n{\n    if (name[1] != ':' || vim_strchr((char_u *)\"gwtb\", *name) == NULL)\n    {\n\tif (*name == 's' && !script_is_vim9())\n\t    return OK;\n\tsemsg(_(e_cannot_unlet_str), name);\n\treturn FAIL;\n    }\n    return OK;\n}", "target": 1}
{"code": "static int is_integer(char *string)\n{\n  if (isdigit(string[0]) || string[0] == '-' || string[0] == '+') {\n    while (*++string && isdigit(*string))\n      ;                                           \n    if (!*string)\n      return 1;\n  }\n  return 0;\n}", "target": 1}
{"code": "static void flush_tmregs_to_thread(struct task_struct *tsk)\n{\n\tif (tsk != current)\n\t\treturn;\n\tif (MSR_TM_SUSPENDED(mfmsr())) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t} else {\n\t\ttm_enable();\n\t\ttm_save_sprs(&(tsk->thread));\n\t}\n}", "target": 1}
{"code": "hb_buffer_destroy (hb_buffer_t *buffer)\n{\n  HB_OBJECT_DO_DESTROY (buffer);\n  hb_unicode_funcs_destroy (buffer->unicode);\n  free (buffer->info);\n  free (buffer->pos);\n  free (buffer);\n}", "target": 0}
{"code": "get_req_flags(unsigned char **buff_in, OM_uint32 bodysize,\n\t      OM_uint32 *req_flags)\n{\n\tunsigned int len;\n\tif (**buff_in != (CONTEXT | 0x01))\n\t\treturn (0);\n\tif (g_get_tag_and_length(buff_in, (CONTEXT | 0x01),\n\t\t\t\tbodysize, &len) < 0)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tif (*(*buff_in)++ != BIT_STRING)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tif (*(*buff_in)++ != BIT_STRING_LENGTH)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tif (*(*buff_in)++ != BIT_STRING_PADDING)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t*req_flags = (OM_uint32) (*(*buff_in)++ >> 1);\n\treturn (0);\n}", "target": 0}
{"code": "void SetBackgroundColor(int par)\n{\n    if ( par == STROKING ) { outpos += sprintf(outpos,\" 0 0 0 0 K\"); }\n    else                   { outpos += sprintf(outpos,\" 0 0 0 0 k\"); }\n}", "target": 1}
{"code": "static void DecodeFPDelta(unsigned char *input, unsigned char *output, int cols,\n                          int channels, int bytesPerSample)\n{\n  DecodeDeltaBytes(input, cols * bytesPerSample, channels);\n  int32_t rowIncrement = cols * channels;\n  if (bytesPerSample == 2)\n  {\n#if LibRawBigEndian\n    const unsigned char *input0 = input;\n    const unsigned char *input1 = input + rowIncrement;\n#else\n    const unsigned char *input1 = input;\n    const unsigned char *input0 = input + rowIncrement;\n#endif\n    for (int col = 0; col < rowIncrement; ++col)\n    {\n      output[0] = input0[col];\n      output[1] = input1[col];\n      output += 2;\n    }\n  }\n  else if (bytesPerSample == 3)\n  {\n    const unsigned char *input0 = input;\n    const unsigned char *input1 = input + rowIncrement;\n    const unsigned char *input2 = input + rowIncrement * 2;\n    for (int col = 0; col < rowIncrement; ++col)\n    {\n      output[0] = input0[col];\n      output[1] = input1[col];\n      output[2] = input2[col];\n      output += 3;\n    }\n  }\n  else\n  {\n#if LibRawBigEndian\n    const unsigned char *input0 = input;\n    const unsigned char *input1 = input + rowIncrement;\n    const unsigned char *input2 = input + rowIncrement * 2;\n    const unsigned char *input3 = input + rowIncrement * 3;\n#else\n    const unsigned char *input3 = input;\n    const unsigned char *input2 = input + rowIncrement;\n    const unsigned char *input1 = input + rowIncrement * 2;\n    const unsigned char *input0 = input + rowIncrement * 3;\n#endif\n    for (int col = 0; col < rowIncrement; ++col)\n    {\n      output[0] = input0[col];\n      output[1] = input1[col];\n      output[2] = input2[col];\n      output[3] = input3[col];\n      output += 4;\n    }\n  }\n}", "target": 0}
{"code": "address_space_translate_for_iotlb(CPUState *cpu, int asidx, hwaddr addr,\n                                  hwaddr *xlat, hwaddr *plen,\n                                  MemTxAttrs attrs, int *prot)\n{\n    MemoryRegionSection *section;\n    IOMMUMemoryRegion *iommu_mr;\n    IOMMUMemoryRegionClass *imrc;\n    IOMMUTLBEntry iotlb;\n    int iommu_idx;\n    AddressSpaceDispatch *d =\n        qatomic_rcu_read(&cpu->cpu_ases[asidx].memory_dispatch);\n    for (;;) {\n        section = address_space_translate_internal(d, addr, &addr, plen, false);\n        iommu_mr = memory_region_get_iommu(section->mr);\n        if (!iommu_mr) {\n            break;\n        }\n        imrc = memory_region_get_iommu_class_nocheck(iommu_mr);\n        iommu_idx = imrc->attrs_to_index(iommu_mr, attrs);\n        tcg_register_iommu_notifier(cpu, iommu_mr, iommu_idx);\n        iotlb = imrc->translate(iommu_mr, addr, IOMMU_NONE, iommu_idx);\n        addr = ((iotlb.translated_addr & ~iotlb.addr_mask)\n                | (addr & iotlb.addr_mask));\n        if (!(iotlb.perm & IOMMU_RO)) {\n            *prot &= ~(PAGE_READ | PAGE_EXEC);\n        }\n        if (!(iotlb.perm & IOMMU_WO)) {\n            *prot &= ~PAGE_WRITE;\n        }\n        if (!*prot) {\n            goto translate_fail;\n        }\n        d = flatview_to_dispatch(address_space_to_flatview(iotlb.target_as));\n    }\n    assert(!memory_region_is_iommu(section->mr));\n    *xlat = addr;\n    return section;\ntranslate_fail:\n    return &d->map.sections[PHYS_SECTION_UNASSIGNED];\n}", "target": 1}
{"code": "const u8 *tcp_parse_md5sig_option(const struct tcphdr *th)\n{\n\tint length = (th->doff << 2) - sizeof(*th);\n\tconst u8 *ptr = (const u8 *)(th + 1);\n\tif (length < TCPOLEN_MD5SIG)\n\t\treturn NULL;\n\twhile (length > 0) {\n\t\tint opcode = *ptr++;\n\t\tint opsize;\n\t\tswitch (opcode) {\n\t\tcase TCPOPT_EOL:\n\t\t\treturn NULL;\n\t\tcase TCPOPT_NOP:\n\t\t\tlength--;\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\topsize = *ptr++;\n\t\t\tif (opsize < 2 || opsize > length)\n\t\t\t\treturn NULL;\n\t\t\tif (opcode == TCPOPT_MD5SIG)\n\t\t\t\treturn opsize == TCPOLEN_MD5SIG ? ptr : NULL;\n\t\t}\n\t\tptr += opsize - 2;\n\t\tlength -= opsize;\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "static int mount_entry_on_relative_rootfs(struct mntent *mntent,\n\t\t\t\t\t  const char *rootfs)\n{\n\tchar path[MAXPATHLEN];\n\tint ret;\n\tret = snprintf(path, sizeof(path), \"%s/%s\", rootfs, mntent->mnt_dir);\n\tif (ret >= sizeof(path)) {\n\t\tERROR(\"path name too long\");\n\t\treturn -1;\n\t}\n\treturn mount_entry_on_generic(mntent, path);\n}", "target": 1}
{"code": "void HTTPSession::onCertificate(uint16_t certId,\n                                std::unique_ptr<IOBuf> authenticator) {\n  DestructorGuard dg(this);\n  VLOG(4) << \"CERTIFICATE on\" << *this << \", certId=\" << certId;\n  if (!secondAuthManager_) {\n    return;\n  }\n  bool isValid = false;\n  auto fizzBase = getTransport()->getUnderlyingTransport<AsyncFizzBase>();\n  if (fizzBase) {\n    if (isUpstream()) {\n      isValid = secondAuthManager_->validateAuthenticator(\n          *fizzBase,\n          TransportDirection::UPSTREAM,\n          certId,\n          std::move(authenticator));\n    } else {\n      isValid = secondAuthManager_->validateAuthenticator(\n          *fizzBase,\n          TransportDirection::DOWNSTREAM,\n          certId,\n          std::move(authenticator));\n    }\n  } else {\n    VLOG(4) << \"Underlying transport does not support secondary \"\n               \"authentication.\";\n    return;\n  }\n  if (isValid) {\n    VLOG(4) << \"Successfully validated the authenticator provided by the peer.\";\n  } else {\n    VLOG(4) << \"Failed to validate the authenticator provided by the peer\";\n  }\n}", "target": 0}
{"code": "struct file *do_file_open_root(struct dentry *dentry, struct vfsmount *mnt,\n\t\tconst char *name, const struct open_flags *op)\n{\n\tstruct nameidata nd;\n\tstruct file *file;\n\tstruct filename filename = { .name = name };\n\tint flags = op->lookup_flags | LOOKUP_ROOT;\n\tnd.root.mnt = mnt;\n\tnd.root.dentry = dentry;\n\tif (dentry->d_inode->i_op->follow_link && op->intent & LOOKUP_OPEN)\n\t\treturn ERR_PTR(-ELOOP);\n\tfile = path_openat(-1, &filename, &nd, op, flags | LOOKUP_RCU);\n\tif (unlikely(file == ERR_PTR(-ECHILD)))\n\t\tfile = path_openat(-1, &filename, &nd, op, flags);\n\tif (unlikely(file == ERR_PTR(-ESTALE)))\n\t\tfile = path_openat(-1, &filename, &nd, op, flags | LOOKUP_REVAL);\n\treturn file;\n}", "target": 0}
{"code": "static ext4_io_end_t *ext4_init_io_end (struct inode *inode)\n{\n\text4_io_end_t *io = NULL;\n\tio = kmalloc(sizeof(*io), GFP_NOFS);\n\tif (io) {\n\t\tigrab(inode);\n\t\tio->inode = inode;\n\t\tio->flag = 0;\n\t\tio->offset = 0;\n\t\tio->size = 0;\n\t\tio->error = 0;\n\t\tINIT_WORK(&io->work, ext4_end_io_work);\n\t\tINIT_LIST_HEAD(&io->list);\n\t}\n\treturn io;\n}", "target": 1}
{"code": "static struct sock *unix_create1(struct net *net, struct socket *sock, int kern)\n{\n\tstruct sock *sk = NULL;\n\tstruct unix_sock *u;\n\tatomic_long_inc(&unix_nr_socks);\n\tif (atomic_long_read(&unix_nr_socks) > 2 * get_max_files())\n\t\tgoto out;\n\tsk = sk_alloc(net, PF_UNIX, GFP_KERNEL, &unix_proto, kern);\n\tif (!sk)\n\t\tgoto out;\n\tsock_init_data(sock, sk);\n\tlockdep_set_class(&sk->sk_receive_queue.lock,\n\t\t\t\t&af_unix_sk_receive_queue_lock_key);\n\tsk->sk_write_space\t= unix_write_space;\n\tsk->sk_max_ack_backlog\t= net->unx.sysctl_max_dgram_qlen;\n\tsk->sk_destruct\t\t= unix_sock_destructor;\n\tu\t  = unix_sk(sk);\n\tu->path.dentry = NULL;\n\tu->path.mnt = NULL;\n\tspin_lock_init(&u->lock);\n\tatomic_long_set(&u->inflight, 0);\n\tINIT_LIST_HEAD(&u->link);\n\tmutex_init(&u->readlock); \n\tinit_waitqueue_head(&u->peer_wait);\n\tinit_waitqueue_func_entry(&u->peer_wake, unix_dgram_peer_wake_relay);\n\tunix_insert_socket(unix_sockets_unbound(sk), sk);\nout:\n\tif (sk == NULL)\n\t\tatomic_long_dec(&unix_nr_socks);\n\telse {\n\t\tlocal_bh_disable();\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, 1);\n\t\tlocal_bh_enable();\n\t}\n\treturn sk;\n}", "target": 0}
{"code": "static int may_delete(struct inode *dir,struct dentry *victim,int isdir)\n{\n\tint error;\n\tif (!victim->d_inode)\n\t\treturn -ENOENT;\n\tBUG_ON(victim->d_parent->d_inode != dir);\n\taudit_inode_child(dir, victim, AUDIT_TYPE_CHILD_DELETE);\n\terror = inode_permission(dir, MAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\treturn error;\n\tif (IS_APPEND(dir))\n\t\treturn -EPERM;\n\tif (check_sticky(dir, victim->d_inode)||IS_APPEND(victim->d_inode)||\n\t    IS_IMMUTABLE(victim->d_inode) || IS_SWAPFILE(victim->d_inode))\n\t\treturn -EPERM;\n\tif (isdir) {\n\t\tif (!S_ISDIR(victim->d_inode->i_mode))\n\t\t\treturn -ENOTDIR;\n\t\tif (IS_ROOT(victim))\n\t\t\treturn -EBUSY;\n\t} else if (S_ISDIR(victim->d_inode->i_mode))\n\t\treturn -EISDIR;\n\tif (IS_DEADDIR(dir))\n\t\treturn -ENOENT;\n\tif (victim->d_flags & DCACHE_NFSFS_RENAMED)\n\t\treturn -EBUSY;\n\treturn 0;\n}", "target": 0}
{"code": "ex_copy(linenr_T line1, linenr_T line2, linenr_T n)\n{\n    linenr_T\tcount;\n    char_u\t*p;\n    count = line2 - line1 + 1;\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\tcurbuf->b_op_start.lnum = n + 1;\n\tcurbuf->b_op_end.lnum = n + count;\n\tcurbuf->b_op_start.col = curbuf->b_op_end.col = 0;\n    }\n    if (u_save(n, n + 1) == FAIL)\n\treturn;\n    curwin->w_cursor.lnum = n;\n    while (line1 <= line2)\n    {\n\tp = vim_strsave(ml_get(line1));\n\tif (p != NULL)\n\t{\n\t    ml_append(curwin->w_cursor.lnum, p, (colnr_T)0, FALSE);\n\t    vim_free(p);\n\t}\n\tif (line1 == n)\n\t    line1 = curwin->w_cursor.lnum;\n\t++line1;\n\tif (curwin->w_cursor.lnum < line1)\n\t    ++line1;\n\tif (curwin->w_cursor.lnum < line2)\n\t    ++line2;\n\t++curwin->w_cursor.lnum;\n    }\n    appended_lines_mark(n, count);\n    msgmore((long)count);\n}", "target": 1}
{"code": "static int atalk_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tint rc = -ENOIOCTLCMD;\n\tstruct sock *sk = sock->sk;\n\tvoid __user *argp = (void __user *)arg;\n\tswitch (cmd) {\n\tcase TIOCOUTQ: {\n\t\tlong amount = sk->sk_sndbuf - sk_wmem_alloc_get(sk);\n\t\tif (amount < 0)\n\t\t\tamount = 0;\n\t\trc = put_user(amount, (int __user *)argp);\n\t\tbreak;\n\t}\n\tcase TIOCINQ: {\n\t\tstruct sk_buff *skb = skb_peek(&sk->sk_receive_queue);\n\t\tlong amount = 0;\n\t\tif (skb)\n\t\t\tamount = skb->len - sizeof(struct ddpehdr);\n\t\trc = put_user(amount, (int __user *)argp);\n\t\tbreak;\n\t}\n\tcase SIOCADDRT:\n\tcase SIOCDELRT:\n\t\trc = -EPERM;\n\t\tif (capable(CAP_NET_ADMIN))\n\t\t\trc = atrtr_ioctl(cmd, argp);\n\t\tbreak;\n\tcase SIOCGIFADDR:\n\tcase SIOCSIFADDR:\n\tcase SIOCGIFBRDADDR:\n\tcase SIOCATALKDIFADDR:\n\tcase SIOCDIFADDR:\n\tcase SIOCSARP:\t\t\n\tcase SIOCDARP:\t\t\n\t\trtnl_lock();\n\t\trc = atif_ioctl(cmd, argp);\n\t\trtnl_unlock();\n\t\tbreak;\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "MagickExport void CatchException(ExceptionInfo *exception)\n{\n  register const ExceptionInfo\n    *p;\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (exception->exceptions  == (void *) NULL)\n    return;\n  LockSemaphoreInfo(exception->semaphore);\n  ResetLinkedListIterator((LinkedListInfo *) exception->exceptions);\n  p=(const ExceptionInfo *) GetNextValueInLinkedList((LinkedListInfo *)\n    exception->exceptions);\n  while (p != (const ExceptionInfo *) NULL)\n  {\n    if ((p->severity >= WarningException) && (p->severity < ErrorException))\n      MagickWarning(p->severity,p->reason,p->description);\n    if ((p->severity >= ErrorException) && (p->severity < FatalErrorException))\n      MagickError(p->severity,p->reason,p->description);\n    if (p->severity >= FatalErrorException)\n      MagickFatalError(p->severity,p->reason,p->description);\n    p=(const ExceptionInfo *) GetNextValueInLinkedList((LinkedListInfo *)\n      exception->exceptions);\n  }\n  UnlockSemaphoreInfo(exception->semaphore);\n  ClearMagickException(exception);\n}", "target": 1}
{"code": "static inline void sem_lock_and_putref(struct sem_array *sma)\n{\n\tipc_lock_by_ptr(&sma->sem_perm);\n\tipc_rcu_putref(sma);\n}", "target": 1}
{"code": "asmlinkage long compat_sys_epoll_pwait(int epfd,\n\t\t\tstruct compat_epoll_event __user *events,\n\t\t\tint maxevents, int timeout,\n\t\t\tconst compat_sigset_t __user *sigmask,\n\t\t\tcompat_size_t sigsetsize)\n{\n\tlong err;\n\tcompat_sigset_t csigmask;\n\tsigset_t ksigmask, sigsaved;\n\tif (sigmask) {\n\t\tif (sigsetsize != sizeof(compat_sigset_t))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&csigmask, sigmask, sizeof(csigmask)))\n\t\t\treturn -EFAULT;\n\t\tsigset_from_compat(&ksigmask, &csigmask);\n\t\tsigdelsetmask(&ksigmask, sigmask(SIGKILL) | sigmask(SIGSTOP));\n\t\tsigprocmask(SIG_SETMASK, &ksigmask, &sigsaved);\n\t}\n#ifdef CONFIG_HAS_COMPAT_EPOLL_EVENT\n\terr = compat_sys_epoll_wait(epfd, events, maxevents, timeout);\n#else\n\terr = sys_epoll_wait(epfd, events, maxevents, timeout);\n#endif\n\tif (sigmask) {\n\t\tif (err == -EINTR) {\n\t\t\tmemcpy(&current->saved_sigmask, &sigsaved,\n\t\t\t       sizeof(sigsaved));\n\t\t\tset_thread_flag(TIF_RESTORE_SIGMASK);\n\t\t} else\n\t\t\tsigprocmask(SIG_SETMASK, &sigsaved, NULL);\n\t}\n\treturn err;\n}", "target": 0}
{"code": "static void kiss_unesc(struct mkiss *ax, unsigned char s)\n{\n\tswitch (s) {\n\tcase END:\n\t\tif (test_bit(AXF_KEEPTEST, &ax->flags))\n\t\t\tclear_bit(AXF_KEEPTEST, &ax->flags);\n\t\tif (!test_and_clear_bit(AXF_ERROR, &ax->flags) && (ax->rcount > 2))\n\t\t\tax_bump(ax);\n\t\tclear_bit(AXF_ESCAPE, &ax->flags);\n\t\tax->rcount = 0;\n\t\treturn;\n\tcase ESC:\n\t\tset_bit(AXF_ESCAPE, &ax->flags);\n\t\treturn;\n\tcase ESC_ESC:\n\t\tif (test_and_clear_bit(AXF_ESCAPE, &ax->flags))\n\t\t\ts = ESC;\n\t\tbreak;\n\tcase ESC_END:\n\t\tif (test_and_clear_bit(AXF_ESCAPE, &ax->flags))\n\t\t\ts = END;\n\t\tbreak;\n\t}\n\tspin_lock_bh(&ax->buflock);\n\tif (!test_bit(AXF_ERROR, &ax->flags)) {\n\t\tif (ax->rcount < ax->buffsize) {\n\t\t\tax->rbuff[ax->rcount++] = s;\n\t\t\tspin_unlock_bh(&ax->buflock);\n\t\t\treturn;\n\t\t}\n\t\tax->dev->stats.rx_over_errors++;\n\t\tset_bit(AXF_ERROR, &ax->flags);\n\t}\n\tspin_unlock_bh(&ax->buflock);\n}", "target": 0}
{"code": "static spl_ptr_heap_element spl_ptr_heap_delete_top(spl_ptr_heap *heap, void *cmp_userdata TSRMLS_DC) { \n\tint i, j;\n\tconst int limit = (heap->count-1)/2;\n\tspl_ptr_heap_element top;\n\tspl_ptr_heap_element bottom;\n\tif (heap->count == 0) {\n\t\treturn NULL;\n\t}\n\ttop    = heap->elements[0];\n\tbottom = heap->elements[--heap->count];\n\tfor( i = 0; i < limit; i = j)\n\t{\n\t\tj = i*2+1;\n\t\tif(j != heap->count && heap->cmp(heap->elements[j+1], heap->elements[j], cmp_userdata TSRMLS_CC) > 0) {\n\t\t\tj++; \n\t\t}\n\t\tif(heap->cmp(bottom, heap->elements[j], cmp_userdata TSRMLS_CC) < 0) {\n\t\t\theap->elements[i] = heap->elements[j];\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (EG(exception)) {\n\t\theap->flags |= SPL_HEAP_CORRUPTED;\n\t}\n\theap->elements[i] = bottom;\n\theap->dtor(top TSRMLS_CC);\n\treturn top;\n}", "target": 0}
{"code": "void PDFiumEngine::Paint(const pp::Rect& rect,\n                         pp::ImageData* image_data,\n                         std::vector<pp::Rect>* ready,\n                         std::vector<pp::Rect>* pending) {\n  DCHECK(image_data);\n  DCHECK(ready);\n  DCHECK(pending);\n  pp::Rect leftover = rect;\n  for (size_t i = 0; i < visible_pages_.size(); ++i) {\n    int index = visible_pages_[i];\n    pp::Rect page_rect = pages_[index]->rect();\n    pp::Rect page_rect_in_screen = GetPageScreenRect(index);\n    pp::Rect dirty_in_screen = page_rect_in_screen.Intersect(leftover);\n    if (dirty_in_screen.IsEmpty())\n      continue;\n    if (i == 0) {\n      pp::Rect blank_space_in_screen = dirty_in_screen;\n      blank_space_in_screen.set_y(0);\n      blank_space_in_screen.set_height(dirty_in_screen.y());\n      leftover = leftover.Subtract(blank_space_in_screen);\n    }\n    leftover = leftover.Subtract(dirty_in_screen);\n    if (pages_[index]->available()) {\n      int progressive = GetProgressiveIndex(index);\n      if (progressive != -1) {\n        DCHECK_GE(progressive, 0);\n        DCHECK_LT(static_cast<size_t>(progressive), progressive_paints_.size());\n        if (progressive_paints_[progressive].rect != dirty_in_screen) {\n          pending->push_back(dirty_in_screen);\n          continue;\n        }\n      }\n      if (progressive == -1) {\n        progressive = StartPaint(index, dirty_in_screen);\n        progressive_paint_timeout_ = kMaxInitialProgressivePaintTimeMs;\n      } else {\n        progressive_paint_timeout_ = kMaxProgressivePaintTimeMs;\n      }\n      progressive_paints_[progressive].painted_ = true;\n      if (ContinuePaint(progressive, image_data)) {\n        FinishPaint(progressive, image_data);\n        ready->push_back(dirty_in_screen);\n      } else {\n        pending->push_back(dirty_in_screen);\n      }\n    } else {\n      PaintUnavailablePage(index, dirty_in_screen, image_data);\n      ready->push_back(dirty_in_screen);\n    }\n  }\n}", "target": 0}
{"code": "static int read_file_dentry_set(struct exfat_de_iter *iter,\n\t\t\t\tstruct exfat_inode **new_node, int *skip_dentries)\n{\n\tstruct exfat_dentry *file_de, *stream_de, *dentry;\n\tstruct exfat_inode *node = NULL;\n\tint i, ret;\n\tret = exfat_de_iter_get(iter, 0, &file_de);\n\tif (ret || file_de->type != EXFAT_FILE) {\n\t\texfat_debug(\"failed to get file dentry\\n\");\n\t\treturn -EINVAL;\n\t}\n\tret = exfat_de_iter_get(iter, 1, &stream_de);\n\tif (ret || stream_de->type != EXFAT_STREAM) {\n\t\texfat_debug(\"failed to get stream dentry\\n\");\n\t\t*skip_dentries = 2;\n\t\tgoto skip_dset;\n\t}\n\t*new_node = NULL;\n\tnode = exfat_alloc_inode(le16_to_cpu(file_de->file_attr));\n\tif (!node)\n\t\treturn -ENOMEM;\n\tfor (i = 2; i <= file_de->file_num_ext; i++) {\n\t\tret = exfat_de_iter_get(iter, i, &dentry);\n\t\tif (ret || dentry->type != EXFAT_NAME)\n\t\t\tbreak;\n\t\tmemcpy(node->name +\n\t\t       (i - 2) * ENTRY_NAME_MAX, dentry->name_unicode,\n\t\t       sizeof(dentry->name_unicode));\n\t}\n\tnode->first_clus = le32_to_cpu(stream_de->stream_start_clu);\n\tnode->is_contiguous =\n\t\t((stream_de->stream_flags & EXFAT_SF_CONTIGUOUS) != 0);\n\tnode->size = le64_to_cpu(stream_de->stream_size);\n\t*skip_dentries = i;\n\t*new_node = node;\n\treturn 0;\nskip_dset:\n\t*new_node = NULL;\n\texfat_free_inode(node);\n\treturn -EINVAL;\n}", "target": 1}
{"code": "static void keyring_describe(const struct key *keyring, struct seq_file *m)\n{\n\tif (keyring->description)\n\t\tseq_puts(m, keyring->description);\n\telse\n\t\tseq_puts(m, \"[anon]\");\n\tif (key_is_instantiated(keyring)) {\n\t\tif (keyring->keys.nr_leaves_on_tree != 0)\n\t\t\tseq_printf(m, \": %lu\", keyring->keys.nr_leaves_on_tree);\n\t\telse\n\t\t\tseq_puts(m, \": empty\");\n\t}\n}", "target": 1}
{"code": "int sc_path_set(sc_path_t *path, int type, const u8 *id, size_t id_len,\n\tint idx, int count)\n{\n\tif (path == NULL || id == NULL || id_len == 0 || id_len > SC_MAX_PATH_SIZE)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\tmemset(path, 0, sizeof(*path));\n\tmemcpy(path->value, id, id_len);\n\tpath->len   = id_len;\n\tpath->type  = type;\n\tpath->index = idx;\n\tpath->count = count;\n\treturn SC_SUCCESS;\n}", "target": 0}
{"code": "GF_HEVCConfig *gf_isom_hevc_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tif (gf_isom_get_reference_count(the_file, trackNumber, GF_ISOM_REF_TBAS)) {\n\t\tu32 ref_track;\n\t\tGF_Err e = gf_isom_get_reference(the_file, trackNumber, GF_ISOM_REF_TBAS, 1, &ref_track);\n\t\tif (e == GF_OK) {\n\t\t\ttrackNumber = ref_track;\n\t\t}\n\t}\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tif (gf_isom_get_hevc_lhvc_type(the_file, trackNumber, DescriptionIndex)==GF_ISOM_HEVCTYPE_NONE)\n\t\treturn NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\tif (!entry) return NULL;\n\tif (!entry->hevc_config) return NULL;\n\treturn HEVC_DuplicateConfig(entry->hevc_config->config);\n}", "target": 0}
{"code": "_dl_dst_count (const char *name, int is_path)\n{\n  size_t cnt = 0;\n  do\n    {\n      size_t len = 1;\n      if ((((!__libc_enable_secure\n\t     && strncmp (&name[1], \"ORIGIN\", 6) == 0 && (len = 7) != 0)\n\t    || (strncmp (&name[1], \"PLATFORM\", 8) == 0 && (len = 9) != 0))\n\t   && (name[len] == '\\0' || name[len] == '/'\n\t       || (is_path && name[len] == ':')))\n\t  || (name[1] == '{'\n\t      && ((!__libc_enable_secure\n\t\t   && strncmp (&name[2], \"ORIGIN}\", 7) == 0 && (len = 9) != 0)\n\t\t  || (strncmp (&name[2], \"PLATFORM}\", 9) == 0\n\t\t      && (len = 11) != 0))))\n\t++cnt;\n      name = strchr (name + len, '$');\n    }\n  while (name != NULL);\n  return cnt;\n}", "target": 1}
{"code": "IW_IMPL(unsigned int) iw_get_ui16be(const iw_byte *b)\n{\n\treturn (b[0]<<8) | b[1];\n}", "target": 1}
{"code": "__visible void kvm_lock_spinning(struct arch_spinlock *lock, __ticket_t want)\n{\n\tstruct kvm_lock_waiting *w;\n\tint cpu;\n\tu64 start;\n\tunsigned long flags;\n\tif (in_nmi())\n\t\treturn;\n\tw = this_cpu_ptr(&klock_waiting);\n\tcpu = smp_processor_id();\n\tstart = spin_time_start();\n\tlocal_irq_save(flags);\n\tw->lock = NULL;\n\tsmp_wmb();\n\tw->want = want;\n\tsmp_wmb();\n\tw->lock = lock;\n\tadd_stats(TAKEN_SLOW, 1);\n\tcpumask_set_cpu(cpu, &waiting_cpus);\n\tbarrier();\n\t__ticket_enter_slowpath(lock);\n\tif (ACCESS_ONCE(lock->tickets.head) == want) {\n\t\tadd_stats(TAKEN_SLOW_PICKUP, 1);\n\t\tgoto out;\n\t}\n\tif (arch_irqs_disabled_flags(flags))\n\t\thalt();\n\telse\n\t\tsafe_halt();\nout:\n\tcpumask_clear_cpu(cpu, &waiting_cpus);\n\tw->lock = NULL;\n\tlocal_irq_restore(flags);\n\tspin_time_accum_blocked(start);\n}", "target": 0}
{"code": "static inline pte_t pte_mknonnuma(pte_t pte)\n{\n\treturn pte;\n}", "target": 0}
{"code": "void set_cached_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tstruct posix_acl **p = acl_by_type(inode, type);\n\tstruct posix_acl *old;\n\told = xchg(p, posix_acl_dup(acl));\n\tif (!is_uncached_acl(old))\n\t\tposix_acl_release(old);\n}", "target": 0}
{"code": "auto ReferenceHandle::Get(Local<Value> key_handle, MaybeLocal<Object> maybe_options) -> Local<Value> {\n\treturn ThreePhaseTask::Run<async, GetRunner>(*isolate, *this, key_handle, maybe_options, inherit);\n}", "target": 1}
{"code": "__attribute__((__always_inline__)) static inline void create_v4_hdr(\n    struct iphdr* iph,\n    __u8 tos,\n    __u32 saddr,\n    __u32 daddr,\n    __u16 pkt_bytes,\n    __u8 proto) {\n  __u64 csum = 0;\n  iph->version = 4;\n  iph->ihl = 5;\n  iph->frag_off = 0;\n  iph->protocol = proto;\n  iph->check = 0;\n#ifdef COPY_INNER_PACKET_TOS\n  iph->tos = tos;\n#else\n  iph->tos = DEFAULT_TOS;\n#endif\n  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));\n  iph->id = 0;\n  iph->daddr = daddr;\n  iph->saddr = saddr;\n  iph->ttl = DEFAULT_TTL;\n  ipv4_csum_inline(iph, &csum);\n  iph->check = csum;\n}", "target": 0}
{"code": "der_to_ldap_BitString (struct berval *berValue,\n                                   struct berval *ldapValue)\n{\n\tber_len_t bitPadding=0;\n\tber_len_t bits, maxBits;\n\tchar *tmpStr;\n\tunsigned char byte;\n\tber_len_t bitLength;\n\tber_len_t valLen;\n\tunsigned char* valPtr;\n\tldapValue->bv_len=0;\n\tldapValue->bv_val=NULL;\n\tvalLen=berValue->bv_len;\n\tvalPtr=(unsigned char*)berValue->bv_val;\n\tif (valLen) {\n\t\tbitPadding=(ber_len_t)(valPtr[0]);\n\t\tvalLen--;\n\t\tvalPtr++;\n\t}\n\tif (bitPadding >= BITS_PER_BYTE) {\n\t\tif (valLen*BITS_PER_BYTE > bitPadding ) {\n\t\t\tvalLen-=(bitPadding/BITS_PER_BYTE);\n\t\t\tbitPadding%=BITS_PER_BYTE;\n\t\t} else {\n\t\t\tvalLen=0;\n\t\t\tbitPadding=0;\n\t\t}\n\t}\n\tif (valLen*BITS_PER_BYTE < bitPadding ) {\n\t\tbitPadding=0;\n\t\tvalLen=0;\n\t}\n\tbitLength=valLen*BITS_PER_BYTE-bitPadding;\n\ttmpStr=LDAP_MALLOC(bitLength + STR_OVERHEAD + 1);\n\tif (!tmpStr)\n\t\treturn LDAP_NO_MEMORY;\n\tldapValue->bv_val=tmpStr;\n\tldapValue->bv_len=bitLength + STR_OVERHEAD;\n\tmaxBits=BITS_PER_BYTE;\n\t*tmpStr++ ='\\'';\n\twhile(valLen) {\n\t\tbyte=*valPtr;\n\t\tif (valLen==1)\n\t\t\tmaxBits-=bitPadding;\n\t\tfor (bits=0; bits<maxBits; bits++) {\n\t\t\tif (0x80 & byte)\n\t\t\t\t*tmpStr='1';\n\t\t\telse\n\t\t\t\t*tmpStr='0';\n\t\t\ttmpStr++;\n\t\t\tbyte<<=1;\n\t\t}\n\t\tvalPtr++;\n\t\tvalLen--;\n\t}\n\t*tmpStr++ ='\\'';\n\t*tmpStr++ ='B';\n\t*tmpStr=0;\n\treturn LDAP_SUCCESS;\n}", "target": 0}
{"code": "static int er_supported(ERContext *s)\n{\n    if(s->avctx->hwaccel && s->avctx->hwaccel->decode_slice           ||\n       !s->cur_pic.f                                                  ||\n       s->cur_pic.field_picture                                       ||\n       s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO\n    )\n        return 0;\n    return 1;\n}", "target": 1}
{"code": "static MagickBooleanType CheckPrimitiveExtent(MVGInfo *mvg_info,\n  const double pad)\n{\n  double\n    extent;\n  size_t\n    quantum;\n  quantum=sizeof(**mvg_info->primitive_info);\n  extent=(double) mvg_info->offset+pad+PrimitiveExtentPad*quantum+1.0;\n  if (extent <= (double) *mvg_info->extent)\n    return(MagickTrue);\n  if (extent == (double) CastDoubleToLong(extent))\n    {\n      *mvg_info->primitive_info=(PrimitiveInfo *) ResizeQuantumMemory(\n        *mvg_info->primitive_info,(size_t) extent,quantum);\n      if (*mvg_info->primitive_info != (PrimitiveInfo *) NULL)\n        {\n          ssize_t\n            i;\n          *mvg_info->extent=(size_t) extent;\n          for (i=mvg_info->offset+1; i < (ssize_t) extent; i++)\n            (*mvg_info->primitive_info)[i].primitive=UndefinedPrimitive;\n          return(MagickTrue);\n        }\n    }\n  if (*mvg_info->primitive_info != (PrimitiveInfo *) NULL)\n    *mvg_info->primitive_info=(PrimitiveInfo *) RelinquishMagickMemory(\n      *mvg_info->primitive_info);\n  (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n    ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n  *mvg_info->primitive_info=(PrimitiveInfo *)  AcquireCriticalMemory(\n    (size_t) (PrimitiveExtentPad*quantum));\n  (void) memset(*mvg_info->primitive_info,0,(size_t)\n    (PrimitiveExtentPad*quantum));\n  *mvg_info->extent=1;\n  return(MagickFalse);\n}", "target": 0}
{"code": "static bool is_ptr_cast_function(enum bpf_func_id func_id)\n{\n\treturn func_id == BPF_FUNC_tcp_sock ||\n\t\tfunc_id == BPF_FUNC_sk_fullsock;\n}", "target": 0}
{"code": "static int __nla_validate_parse(const struct nlattr *head, int len, int maxtype,\n\t\t\t\tconst struct nla_policy *policy,\n\t\t\t\tunsigned int validate,\n\t\t\t\tstruct netlink_ext_ack *extack,\n\t\t\t\tstruct nlattr **tb)\n{\n\tconst struct nlattr *nla;\n\tint rem;\n\tif (tb)\n\t\tmemset(tb, 0, sizeof(struct nlattr *) * (maxtype + 1));\n\tnla_for_each_attr(nla, head, len, rem) {\n\t\tu16 type = nla_type(nla);\n\t\tif (type == 0 || type > maxtype) {\n\t\t\tif (validate & NL_VALIDATE_MAXTYPE) {\n\t\t\t\tNL_SET_ERR_MSG_ATTR(extack, nla,\n\t\t\t\t\t\t    \"Unknown attribute type\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (policy) {\n\t\t\tint err = validate_nla(nla, maxtype, policy,\n\t\t\t\t\t       validate, extack);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (tb)\n\t\t\ttb[type] = (struct nlattr *)nla;\n\t}\n\tif (unlikely(rem > 0)) {\n\t\tpr_warn_ratelimited(\"netlink: %d bytes leftover after parsing attributes in process `%s'.\\n\",\n\t\t\t\t    rem, current->comm);\n\t\tNL_SET_ERR_MSG(extack, \"bytes leftover after parsing attributes\");\n\t\tif (validate & NL_VALIDATE_TRAILING)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static bool set_reg_profile(RAnal *anal) {\n\tconst char *p =\n\t\t\"=PC\tpc\\n\"\n\t\t\"=SP\tr14\\n\" \n\t\t\"=BP\tsrp\\n\" \n\t\t\"=SN\tr0\\n\"\n\t\t\"=A0\tr0\\n\"\n\t\t\"=A1\tr1\\n\"\n\t\t\"=A2\tr2\\n\"\n\t\t\"=A3\tr3\\n\"\n\t\t\"gpr\tsp\t.32\t56\t0\\n\" \n\t\t\"gpr\tacr\t.32\t60\t0\\n\" \n\t\t\"gpr\tpc\t.32\t64\t0\\n\" \n\t\t\"gpr\tsrp\t.32\t68\t0\\n\" \n\t\t\"gpr\tr0\t.32\t0\t0\\n\"\n\t\t\"gpr\tr1\t.32\t4\t0\\n\"\n\t\t\"gpr\tr2\t.32\t8\t0\\n\"\n\t\t\"gpr\tr3\t.32\t12\t0\\n\"\n\t\t\"gpr\tr4\t.32\t16\t0\\n\"\n\t\t\"gpr\tr5\t.32\t20\t0\\n\"\n\t\t\"gpr\tr6\t.32\t24\t0\\n\"\n\t\t\"gpr\tr7\t.32\t28\t0\\n\"\n\t\t\"gpr\tr8\t.32\t32\t0\\n\"\n\t\t\"gpr\tr9\t.32\t36\t0\\n\"\n\t\t\"gpr\tr10\t.32\t40\t0\\n\"\n\t\t\"gpr\tr11\t.32\t44\t0\\n\"\n\t\t\"gpr\tr12\t.32\t48\t0\\n\"\n\t\t\"gpr\tr13\t.32\t52\t0\\n\"\n\t\t\"gpr\tr14\t.32\t56\t0\\n\"\n\t\t\"gpr\tr15\t.32\t60\t0\\n\"\n\t\t;\n\treturn r_reg_set_profile_string (anal->reg, p);\n}", "target": 0}
{"code": "void __detach_mounts(struct dentry *dentry)\n{\n\tstruct mountpoint *mp;\n\tstruct mount *mnt;\n\tnamespace_lock();\n\tmp = lookup_mountpoint(dentry);\n\tif (IS_ERR_OR_NULL(mp))\n\t\tgoto out_unlock;\n\tlock_mount_hash();\n\twhile (!hlist_empty(&mp->m_list)) {\n\t\tmnt = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list);\n\t\tif (mnt->mnt.mnt_flags & MNT_UMOUNT) {\n\t\t\tstruct mount *p, *tmp;\n\t\t\tlist_for_each_entry_safe(p, tmp, &mnt->mnt_mounts,  mnt_child) {\n\t\t\t\thlist_add_head(&p->mnt_umount.s_list, &unmounted);\n\t\t\t\tumount_mnt(p);\n\t\t\t}\n\t\t}\n\t\telse umount_tree(mnt, 0);\n\t}\n\tunlock_mount_hash();\n\tput_mountpoint(mp);\nout_unlock:\n\tnamespace_unlock();\n}", "target": 1}
{"code": "int PDFiumEngine::GetMostVisiblePage() {\n   if (in_flight_visible_page_)\n     return *in_flight_visible_page_;\n   CalculateVisiblePages();\n   return most_visible_page_;\n }", "target": 1}
{"code": "_gnutls_x509_read_value(ASN1_TYPE c, const char *root,\n\t\t\tgnutls_datum_t * ret)\n{\n\tint len = 0, result;\n\tuint8_t *tmp = NULL;\n\tunsigned int etype;\n\tresult = asn1_read_value_type(c, root, NULL, &len, &etype);\n\tif (result == 0 && len == 0) {\n\t\treturn gnutls_assert_val(GNUTLS_E_ASN1_DER_ERROR);\n\t}\n\tif (result != ASN1_MEM_ERROR) {\n\t\tgnutls_assert();\n\t\tresult = _gnutls_asn2err(result);\n\t\treturn result;\n\t}\n\tif (etype == ASN1_ETYPE_BIT_STRING) {\n\t\tlen = (len + 7)/8;\n\t}\n\ttmp = gnutls_malloc((size_t) len + 1);\n\tif (tmp == NULL) {\n\t\tgnutls_assert();\n\t\tresult = GNUTLS_E_MEMORY_ERROR;\n\t\tgoto cleanup;\n\t}\n\tresult = asn1_read_value(c, root, tmp, &len);\n\tif (result != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\tresult = _gnutls_asn2err(result);\n\t\tgoto cleanup;\n\t}\n\tif (etype == ASN1_ETYPE_BIT_STRING) {\n\t\tret->size = (len+7) / 8;\n\t} else {\n\t\tret->size = (unsigned) len;\n\t}\n\ttmp[ret->size] = 0;\n\tret->data = tmp;\n\treturn 0;\n      cleanup:\n\tgnutls_free(tmp);\n\treturn result;\n}", "target": 0}
{"code": "static int dispatch_discard_io(struct xen_blkif *blkif,\n\t\t\t\tstruct blkif_request *req)\n{\n\tint err = 0;\n\tint status = BLKIF_RSP_OKAY;\n\tstruct block_device *bdev = blkif->vbd.bdev;\n\tunsigned long secure;\n\tblkif->st_ds_req++;\n\txen_blkif_get(blkif);\n\tsecure = (blkif->vbd.discard_secure &&\n\t\t (req->u.discard.flag & BLKIF_DISCARD_SECURE)) ?\n\t\t BLKDEV_DISCARD_SECURE : 0;\n\terr = blkdev_issue_discard(bdev, req->u.discard.sector_number,\n\t\t\t\t   req->u.discard.nr_sectors,\n\t\t\t\t   GFP_KERNEL, secure);\n\tif (err == -EOPNOTSUPP) {\n\t\tpr_debug(DRV_PFX \"discard op failed, not supported\\n\");\n\t\tstatus = BLKIF_RSP_EOPNOTSUPP;\n\t} else if (err)\n\t\tstatus = BLKIF_RSP_ERROR;\n\tmake_response(blkif, req->u.discard.id, req->operation, status);\n\txen_blkif_put(blkif);\n\treturn err;\n}", "target": 1}
{"code": "static ssize_t aliases_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", s->refcount < 0 ? 0 : s->refcount - 1);\n}", "target": 0}
{"code": "restore_backup_configuration (GsdXrandrManager *manager, const char *backup_filename, const char *intended_filename, guint32 timestamp)\n{\n        int saved_errno;\n        if (rename (backup_filename, intended_filename) == 0) {\n                GError *error;\n                error = NULL;\n                if (!apply_configuration_from_filename (manager, intended_filename, FALSE, timestamp, &error)) {\n                        error_message (manager, _(\"Could not restore the display's configuration\"), error, NULL);\n                        if (error)\n                                g_error_free (error);\n                }\n                return;\n        }\n        saved_errno = errno;\n        if (saved_errno == ENOENT)\n                unlink (intended_filename);\n        else {\n                char *msg;\n                msg = g_strdup_printf (\"Could not rename %s to %s: %s\",\n                                       backup_filename, intended_filename,\n                                       g_strerror (saved_errno));\n                error_message (manager,\n                               _(\"Could not restore the display's configuration from a backup\"),\n                               NULL,\n                               msg);\n                g_free (msg);\n        }\n        unlink (backup_filename);\n}", "target": 0}
{"code": "rad_get_vendor_attr(u_int32_t *vendor, const void **data, size_t *len)\n{\n\tstruct vendor_attribute *attr;\n\tattr = (struct vendor_attribute *)*data;\n\t*vendor = ntohl(attr->vendor_value);\n\t*data = attr->attrib_data;\n\t*len = attr->attrib_len - 2;\n\treturn (attr->attrib_type);\n}", "target": 1}
{"code": "void rose_stop_timer(struct sock *sk)\n{\n\tdel_timer(&rose_sk(sk)->timer);\n}", "target": 1}
{"code": "static inline void set_pte_at(struct mm_struct *mm, unsigned long addr,\n\t\t\t      pte_t *ptep, pte_t pte)\n{\n\tif (pte_valid_ng(pte)) {\n\t\tif (!pte_special(pte) && pte_exec(pte))\n\t\t\t__sync_icache_dcache(pte, addr);\n\t\tif (pte_dirty(pte) && pte_write(pte))\n\t\t\tpte_val(pte) &= ~PTE_RDONLY;\n\t\telse\n\t\t\tpte_val(pte) |= PTE_RDONLY;\n\t}\n\tset_pte(ptep, pte);\n}", "target": 1}
{"code": "static void ashtech_event_hook(struct gps_device_t *session, event_t event)\n{\n    if (session->context->readonly)\n\treturn;\n    if (event == event_wakeup)\n\t(void)nmea_send(session, \"$PASHQ,RID\");\n    if (event == event_identified) {\n\t(void)nmea_send(session, \"$PASHS,WAS,ON\");\n\t(void)nmea_send(session, \"$PASHS,NME,ALL,A,OFF\");\n#ifdef __future__\n\t(void)nmea_send(session, \"$PASHS,NME,POS,A,ON\");\n\t(void)nmea_send(session, \"$PASHS,NME,SAT,A,ON\");\n#else\n\t(void)nmea_send(session, \"$PASHS,NME,GGA,A,ON\");\n\t(void)nmea_send(session, \"$PASHS,NME,GSA,A,ON\");\n\t(void)nmea_send(session, \"$PASHS,NME,GSV,A,ON\");\n\t(void)nmea_send(session, \"$PASHS,NME,RMC,A,ON\");\n#endif\n\t(void)nmea_send(session, \"$PASHS,NME,ZDA,A,ON\");\n    }\n}", "target": 0}
{"code": "static void xen_irq_lateeoi_locked(struct irq_info *info)\n{\n\tevtchn_port_t evtchn;\n\tevtchn = info->evtchn;\n\tif (!VALID_EVTCHN(evtchn))\n\t\treturn;\n\tunmask_evtchn(evtchn);\n}", "target": 1}
{"code": "void nl80211_send_remain_on_channel_cancel(\n\tstruct cfg80211_registered_device *rdev,\n\tstruct wireless_dev *wdev,\n\tu64 cookie, struct ieee80211_channel *chan, gfp_t gfp)\n{\n\tnl80211_send_remain_on_chan_event(NL80211_CMD_CANCEL_REMAIN_ON_CHANNEL,\n\t\t\t\t\t  rdev, wdev, cookie, chan, 0, gfp);\n}", "target": 0}
{"code": "static void evdev_cleanup(struct evdev *evdev)\n{\n\tstruct input_handle *handle = &evdev->handle;\n\tevdev_mark_dead(evdev);\n\tevdev_hangup(evdev);\n\tcdev_del(&evdev->cdev);\n\tif (evdev->open) {\n\t\tinput_flush_device(handle, NULL);\n\t\tinput_close_device(handle);\n\t}\n}", "target": 0}
{"code": "void __ip_select_ident(struct net *net, struct iphdr *iph, int segs)\n{\n\tstatic u32 ip_idents_hashrnd __read_mostly;\n\tu32 hash, id;\n\tnet_get_random_once(&ip_idents_hashrnd, sizeof(ip_idents_hashrnd));\n\thash = jhash_3words((__force u32)iph->daddr,\n\t\t\t    (__force u32)iph->saddr,\n\t\t\t    iph->protocol ^ net_hash_mix(net),\n\t\t\t    ip_idents_hashrnd);\n\tid = ip_idents_reserve(hash, segs);\n\tiph->id = htons(id);\n}", "target": 1}
{"code": "static int sco_send_frame(struct sock *sk, struct msghdr *msg, int len)\n{\n\tstruct sco_conn *conn = sco_pi(sk)->conn;\n\tstruct sk_buff *skb;\n\tint err;\n\tif (len > conn->mtu)\n\t\treturn -EINVAL;\n\tBT_DBG(\"sk %p len %d\", sk, len);\n\tskb = bt_skb_send_alloc(sk, len, msg->msg_flags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\treturn err;\n\tif (memcpy_from_msg(skb_put(skb, len), msg, len)) {\n\t\tkfree_skb(skb);\n\t\treturn -EFAULT;\n\t}\n\thci_send_sco(conn->hcon, skb);\n\treturn len;\n}", "target": 1}
{"code": "int cg_write(const char *path, const char *buf, size_t size, off_t offset,\n\t     struct fuse_file_info *fi)\n{\n\tstruct fuse_context *fc = fuse_get_context();\n\tchar *localbuf = NULL;\n\tstruct cgfs_files *k = NULL;\n\tstruct file_info *f = (struct file_info *)fi->fh;\n\tbool r;\n\tif (f->type != LXC_TYPE_CGFILE) {\n\t\tfprintf(stderr, \"Internal error: directory cache info used in cg_write\\n\");\n\t\treturn -EIO;\n\t}\n\tif (offset)\n\t\treturn 0;\n\tif (!fc)\n\t\treturn -EIO;\n\tlocalbuf = alloca(size+1);\n\tlocalbuf[size] = '\\0';\n\tmemcpy(localbuf, buf, size);\n\tif ((k = cgfs_get_key(f->controller, f->cgroup, f->file)) == NULL) {\n\t\tsize = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (!fc_may_access(fc, f->controller, f->cgroup, f->file, O_WRONLY)) {\n\t\tsize = -EACCES;\n\t\tgoto out;\n\t}\n\tif (strcmp(f->file, \"tasks\") == 0 ||\n\t\t\tstrcmp(f->file, \"/tasks\") == 0 ||\n\t\t\tstrcmp(f->file, \"/cgroup.procs\") == 0 ||\n\t\t\tstrcmp(f->file, \"cgroup.procs\") == 0)\n\t\tr = do_write_pids(fc->pid, f->controller, f->cgroup, f->file, localbuf);\n\telse\n\t\tr = cgfs_set_value(f->controller, f->cgroup, f->file, localbuf);\n\tif (!r)\n\t\tsize = -EINVAL;\nout:\n\tfree_key(k);\n\treturn size;\n}", "target": 1}
{"code": "cmdline_insert_reg(int *gotesc UNUSED)\n{\n    int\t\ti;\n    int\t\tc;\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = TRUE;\t\n#endif\n    putcmdline('\"', TRUE);\n    ++no_mapping;\n    ++allow_keys;\n    i = c = plain_vgetc();\t\n    if (i == Ctrl_O)\n\ti = Ctrl_R;\t\t\n    if (i == Ctrl_R)\n\tc = plain_vgetc();\t\n    extra_char = NUL;\n    --no_mapping;\n    --allow_keys;\n#ifdef FEAT_EVAL\n    new_cmdpos = -1;\n    if (c == '=')\n    {\n\tif (ccline.cmdfirstc == '='  \n\t\t|| cmdline_star > 0) \n\t{\n\t    beep_flush();\n\t    c = ESC;\n\t}\n\telse\n\t    c = get_expr_register();\n    }\n#endif\n    if (c != ESC)\t    \n    {\n\tcmdline_paste(c, i == Ctrl_R, FALSE);\n#ifdef FEAT_EVAL\n\tif (aborting())\n\t{\n\t    *gotesc = TRUE;  \n\t    return GOTO_NORMAL_MODE;\n\t}\n#endif\n\tKeyTyped = FALSE;\t\n#ifdef FEAT_EVAL\n\tif (new_cmdpos >= 0)\n\t{\n\t    if (new_cmdpos > ccline.cmdlen)\n\t\tccline.cmdpos = ccline.cmdlen;\n\t    else\n\t\tccline.cmdpos = new_cmdpos;\n\t}\n#endif\n    }\n    redrawcmd();\n    return CMDLINE_NOT_CHANGED;\n}", "target": 1}
{"code": "mrb_decode_insn(const mrb_code *pc)\n{\n  struct mrb_insn_data data = { 0 };\n  if (pc == 0) return data;\n  data.addr = pc;\n  mrb_code insn = READ_B();\n  uint16_t a = 0;\n  uint16_t b = 0;\n  uint16_t c = 0;\n  switch (insn) {\n#define FETCH_Z() \n#define OPCODE(i,x) case OP_ ## i: FETCH_ ## x (); break;\n#include \"mruby/ops.h\"\n#undef OPCODE\n  }\n  switch (insn) {\n  case OP_EXT1:\n    insn = READ_B();\n    switch (insn) {\n#define OPCODE(i,x) case OP_ ## i: FETCH_ ## x ## _1 (); break;\n#include \"mruby/ops.h\"\n#undef OPCODE\n    }\n    break;\n  case OP_EXT2:\n    insn = READ_B();\n    switch (insn) {\n#define OPCODE(i,x) case OP_ ## i: FETCH_ ## x ## _2 (); break;\n#include \"mruby/ops.h\"\n#undef OPCODE\n    }\n    break;\n  case OP_EXT3:\n    insn = READ_B();\n    switch (insn) {\n#define OPCODE(i,x) case OP_ ## i: FETCH_ ## x ## _3 (); break;\n#include \"mruby/ops.h\"\n#undef OPCODE\n    }\n    break;\n  default:\n    break;\n  }\n  data.insn = insn;\n  data.a = a;\n  data.b = b;\n  data.c = c;\n  return data;\n}", "target": 0}
{"code": "struct task_struct * __cpuinit fork_idle(int cpu)\n{\n\tstruct task_struct *task;\n\tstruct pt_regs regs;\n\ttask = copy_process(CLONE_VM, 0, idle_regs(&regs), 0, NULL,\n\t\t\t    &init_struct_pid, 0);\n\tif (!IS_ERR(task))\n\t\tinit_idle(task, cpu);\n\treturn task;\n}", "target": 1}
{"code": "unsigned lodepng_decode32(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize)\n{\n  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGBA, 8);\n}", "target": 0}
{"code": "static void sigchld_reaper(void) {\n\tWAIT_T waiter;\n\tPID_T pid;\n\tdo {\n\t\tpid = waitpid(-1, &waiter, WNOHANG);\n\t\tswitch (pid) {\n\t\tcase -1:\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tDebug(DPROC, (\"[%ld] sigchld...no children\\n\", (long) getpid()))\n\t\t\t\tbreak;\n\t\tcase 0:\n\t\t\tDebug(DPROC, (\"[%ld] sigchld...no dead kids\\n\", (long) getpid()))\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\tDebug(DPROC,\n\t\t\t\t(\"[%ld] sigchld...pid #%ld died, stat=%d\\n\",\n\t\t\t\t\t(long) getpid(), (long) pid, WEXITSTATUS(waiter)))\n\t\t\t\tbreak;\n\t\t}\n\t} while (pid > 0);\n}", "target": 0}
{"code": "fribidi_cap_rtl_to_unicode (\n  const char *s,\n  FriBidiStrIndex len,\n  FriBidiChar *us\n)\n{\n  FriBidiStrIndex i, j;\n  if (!caprtl_to_unicode)\n    init_cap_rtl ();\n  j = 0;\n  for (i = 0; i < len; i++)\n    {\n      char ch;\n      ch = s[i];\n      if (ch == '_')\n\t{\n\t  switch (ch = s[++i])\n\t    {\n\t    case '>':\n\t      us[j++] = FRIBIDI_CHAR_LRM;\n\t      break;\n\t    case '<':\n\t      us[j++] = FRIBIDI_CHAR_RLM;\n\t      break;\n\t    case 'l':\n\t      us[j++] = FRIBIDI_CHAR_LRE;\n\t      break;\n\t    case 'r':\n\t      us[j++] = FRIBIDI_CHAR_RLE;\n\t      break;\n\t    case 'o':\n\t      us[j++] = FRIBIDI_CHAR_PDF;\n\t      break;\n\t    case 'L':\n\t      us[j++] = FRIBIDI_CHAR_LRO;\n\t      break;\n\t    case 'R':\n\t      us[j++] = FRIBIDI_CHAR_RLO;\n\t      break;\n            case 'i':\n              us[j++] = FRIBIDI_CHAR_LRI;\n\t      break;\n            case 'y':\n              us[j++] = FRIBIDI_CHAR_RLI;\n\t      break;\n            case 'f':\n              us[j++] = FRIBIDI_CHAR_FSI;\n\t      break;\n            case 'I':\n              us[j++] = FRIBIDI_CHAR_PDI;\n\t      break;\n\t    case '_':\n\t      us[j++] = '_';\n\t      break;\n\t    default:\n\t      us[j++] = '_';\n\t      i--;\n\t      break;\n\t    }\n\t}\n      else\n\tus[j++] = caprtl_to_unicode[(int) s[i]];\n    }\n  return j;\n}", "target": 1}
{"code": "TEST_F(QuantizeDownAndShrinkRangeTest, HandCrafted) {\n  TF_ASSERT_OK(NodeDefBuilder(\"quantize_down_and_shrink_range_op\",\n                              \"QuantizeDownAndShrinkRange\")\n                   .Input(FakeInput(DT_QINT32))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Attr(\"Tinput\", DataTypeToEnum<qint32>::v())\n                   .Attr(\"out_type\", DataTypeToEnum<quint8>::v())\n                   .Finalize(node_def()));\n  TF_ASSERT_OK(InitOp());\n  const int value_count = 3;\n  AddInputFromArray<qint32>(TensorShape({value_count}),\n                            {-(1 << 23), 0, (1 << 23)});\n  AddInputFromArray<float>(TensorShape({1}), {-256.0f});\n  AddInputFromArray<float>(TensorShape({1}), {256.0f});\n  TF_ASSERT_OK(RunOpKernel());\n  Tensor expected(allocator(), DT_QUINT8, TensorShape({value_count}));\n  test::FillValues<quint8>(&expected, {0, 128, 255});\n  test::ExpectTensorEqual<quint8>(expected, *GetOutput(0));\n  Tensor expected_min(allocator(), DT_FLOAT, TensorShape({}));\n  test::FillValues<float>(&expected_min, {-1.0f});\n  test::ExpectTensorEqual<float>(expected_min, *GetOutput(1));\n  Tensor expected_max(allocator(), DT_FLOAT, TensorShape({}));\n  test::FillValues<float>(&expected_max, {1.0f});\n  test::ExpectTensorEqual<float>(expected_max, *GetOutput(2));\n}", "target": 1}
{"code": "ext4_find_extent(struct inode *inode, ext4_lblk_t block,\n\t\t struct ext4_ext_path **orig_path, int flags)\n{\n\tstruct ext4_extent_header *eh;\n\tstruct buffer_head *bh;\n\tstruct ext4_ext_path *path = orig_path ? *orig_path : NULL;\n\tshort int depth, i, ppos = 0;\n\tint ret;\n\teh = ext_inode_hdr(inode);\n\tdepth = ext_depth(inode);\n\tif (path) {\n\t\text4_ext_drop_refs(path);\n\t\tif (depth > path[0].p_maxdepth) {\n\t\t\tkfree(path);\n\t\t\t*orig_path = path = NULL;\n\t\t}\n\t}\n\tif (!path) {\n\t\tpath = kzalloc(sizeof(struct ext4_ext_path) * (depth + 2),\n\t\t\t\tGFP_NOFS);\n\t\tif (unlikely(!path))\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tpath[0].p_maxdepth = depth + 1;\n\t}\n\tpath[0].p_hdr = eh;\n\tpath[0].p_bh = NULL;\n\ti = depth;\n\twhile (i) {\n\t\text_debug(\"depth %d: num %d, max %d\\n\",\n\t\t\t  ppos, le16_to_cpu(eh->eh_entries), le16_to_cpu(eh->eh_max));\n\t\text4_ext_binsearch_idx(inode, path + ppos, block);\n\t\tpath[ppos].p_block = ext4_idx_pblock(path[ppos].p_idx);\n\t\tpath[ppos].p_depth = i;\n\t\tpath[ppos].p_ext = NULL;\n\t\tbh = read_extent_tree_block(inode, path[ppos].p_block, --i,\n\t\t\t\t\t    flags);\n\t\tif (IS_ERR(bh)) {\n\t\t\tret = PTR_ERR(bh);\n\t\t\tgoto err;\n\t\t}\n\t\teh = ext_block_hdr(bh);\n\t\tppos++;\n\t\tpath[ppos].p_bh = bh;\n\t\tpath[ppos].p_hdr = eh;\n\t}\n\tpath[ppos].p_depth = i;\n\tpath[ppos].p_ext = NULL;\n\tpath[ppos].p_idx = NULL;\n\text4_ext_binsearch(inode, path + ppos, block);\n\tif (path[ppos].p_ext)\n\t\tpath[ppos].p_block = ext4_ext_pblock(path[ppos].p_ext);\n\text4_ext_show_path(inode, path);\n\treturn path;\nerr:\n\text4_ext_drop_refs(path);\n\tkfree(path);\n\tif (orig_path)\n\t\t*orig_path = NULL;\n\treturn ERR_PTR(ret);\n}", "target": 1}
{"code": "int nfc_genl_se_connectivity(struct nfc_dev *dev, u8 se_idx)\n{\n\tconst struct nfc_se *se;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_SE_CONNECTIVITY);\n\tif (!hdr)\n\t\tgoto free_msg;\n\tse = nfc_find_se(dev, se_idx);\n\tif (!se)\n\t\tgoto free_msg;\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx) ||\n\t    nla_put_u32(msg, NFC_ATTR_SE_INDEX, se_idx) ||\n\t    nla_put_u8(msg, NFC_ATTR_SE_TYPE, se->type))\n\t\tgoto nla_put_failure;\n\tgenlmsg_end(msg, hdr);\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\treturn 0;\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}", "target": 0}
{"code": "check_pages_isolated_cb(unsigned long start_pfn, unsigned long nr_pages,\n\t\t\tvoid *data)\n{\n\tint ret;\n\tlong offlined = *(long *)data;\n\tret = test_pages_isolated(start_pfn, start_pfn + nr_pages);\n\tofflined = nr_pages;\n\tif (!ret)\n\t\t*(long *)data += offlined;\n\treturn ret;\n}", "target": 0}
{"code": "bool EditorClientBlackBerry::shouldChangeSelectedRange(Range* fromRange, Range* toRange, EAffinity affinity, bool stillSelecting)\n{\n    if (m_webPagePrivate->m_dumpRenderTree)\n        return m_webPagePrivate->m_dumpRenderTree->shouldChangeSelectedDOMRangeToDOMRangeAffinityStillSelecting(fromRange, toRange, static_cast<int>(affinity), stillSelecting);\n     Frame* frame = m_webPagePrivate->focusedOrMainFrame();\n     if (frame && frame->document()) {\n        if (Node* focusedNode = frame->document()->focusedNode()) {\n            if (focusedNode->hasTagName(HTMLNames::selectTag))\n                return false;\n            if (focusedNode->isElementNode() && DOMSupport::isPopupInputField(static_cast<Element*>(focusedNode)))\n                return false;\n        }\n         if (m_webPagePrivate->m_inputHandler->isInputMode() && fromRange && toRange && (fromRange->startContainer() == toRange->startContainer()))\n            m_webPagePrivate->m_inputHandler->notifyClientOfKeyboardVisibilityChange(true);\n    }\n    return true;\n}", "target": 0}
{"code": "void free_key_material(key_material_t* pkey)\n{\n\tint i;\n\tif (!pkey)\n\t{\n\t\treturn;\n\t}\n\tfor (i = 0; i < TAG_MAX; i++)\n\t{\n\t\tif (pkey[i].big)\n\t\t{\n\t\t\tfree(pkey[i].big);\n\t\t}\n\t}\n}", "target": 0}
{"code": "render_pixbuf_size_prepared_cb (GdkPixbufLoader *loader,\n\t\t\t\tgint             width,\n\t\t\t\tgint             height,\n\t\t\t\tgpointer         data)\n{\n\tdouble *scale = data;\n\tint w = (width  * (*scale) + 0.5);\n\tint h = (height * (*scale) + 0.5);\n\tgdk_pixbuf_loader_set_size (loader, w, h);\n}", "target": 1}
{"code": "int unshare_userns(unsigned long unshare_flags, struct cred **new_cred)\n{\n\tstruct cred *cred;\n\tif (!(unshare_flags & CLONE_NEWUSER))\n\t\treturn 0;\n\tcred = prepare_creds();\n\tif (!cred)\n\t\treturn -ENOMEM;\n\t*new_cred = cred;\n\treturn create_user_ns(cred);\n}", "target": 1}
{"code": "QString Helper::temporaryMountDevice(const QString &device, const QString &name, bool readonly)\n{\n    QString mount_point = mountPoint(device);\n    if (!mount_point.isEmpty())\n        return mount_point;\n    mount_point = \"%1/.%2/mount/%3\";\n    const QStringList &tmp_paths = QStandardPaths::standardLocations(QStandardPaths::TempLocation);\n    mount_point = mount_point.arg(tmp_paths.isEmpty() ? \"/tmp\" : tmp_paths.first()).arg(qApp->applicationName()).arg(name);\n    if (!QDir::current().mkpath(mount_point)) {\n        dCError(\"mkpath \\\"%s\\\" failed\", qPrintable(mount_point));\n        return QString();\n    }\n    if (!mountDevice(device, mount_point, readonly)) {\n        dCError(\"Mount the device \\\"%s\\\" to \\\"%s\\\" failed\", qPrintable(device), qPrintable(mount_point));\n        return QString();\n    }\n    return mount_point;\n}", "target": 1}
{"code": "ikev1_cert_print(netdissect_options *ndo, u_char tpay _U_,\n\t\t const struct isakmp_gen *ext, u_int item_len,\n\t\t const u_char *ep _U_, uint32_t phase _U_,\n\t\t uint32_t doi0 _U_,\n\t\t uint32_t proto0 _U_, int depth _U_)\n{\n\tconst struct ikev1_pl_cert *p;\n\tstruct ikev1_pl_cert cert;\n\tstatic const char *certstr[] = {\n\t\t\"none\",\t\"pkcs7\", \"pgp\", \"dns\",\n\t\t\"x509sign\", \"x509ke\", \"kerberos\", \"crl\",\n\t\t\"arl\", \"spki\", \"x509attr\",\n\t};\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_CERT)));\n\tp = (const struct ikev1_pl_cert *)ext;\n\tND_TCHECK(*p);\n\tUNALIGNED_MEMCPY(&cert, ext, sizeof(cert));\n\tND_PRINT((ndo,\" len=%d\", item_len - 4));\n\tND_PRINT((ndo,\" type=%s\", STR_OR_ID((cert.encode), certstr)));\n\tif (2 < ndo->ndo_vflag && 4 < item_len) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), item_len - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + item_len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_CERT)));\n\treturn NULL;\n}", "target": 0}
{"code": "int mp_pack(lua_State *L) {\n    int nargs = lua_gettop(L);\n    int i;\n    mp_buf *buf;\n    if (nargs == 0)\n        return luaL_argerror(L, 0, \"MessagePack pack needs input.\");\n    if (!lua_checkstack(L, nargs))\n        return luaL_argerror(L, 0, \"Too many arguments for MessagePack pack.\");\n    buf = mp_buf_new(L);\n    for(i = 1; i <= nargs; i++) {\n        lua_pushvalue(L, i);\n        mp_encode_lua_type(L,buf,0);\n        lua_pushlstring(L,(char*)buf->b,buf->len);\n        buf->free += buf->len;\n        buf->len = 0;\n    }\n    mp_buf_free(L, buf);\n    lua_concat(L, nargs);\n    return 1;\n}", "target": 0}
{"code": "static int _make_remark(struct pwb_context *ctx,\n\t\t\tint type,\n\t\t\tconst char *text)\n{\n\tint retval = PAM_SUCCESS;\n\tstruct pam_message *pmsg[1], msg[1];\n\tstruct pam_response *resp;\n\tif (ctx->flags & WINBIND_SILENT) {\n\t\treturn PAM_SUCCESS;\n\t}\n\tpmsg[0] = &msg[0];\n\tmsg[0].msg = discard_const_p(char, text);\n\tmsg[0].msg_style = type;\n\tresp = NULL;\n\tretval = converse(ctx->pamh, 1, pmsg, &resp);\n\tif (resp) {\n\t\t_pam_drop_reply(resp, 1);\n\t}\n\treturn retval;\n}", "target": 0}
{"code": "static int handle_wrmsr(struct kvm_vcpu *vcpu)\n{\n\tstruct msr_data msr;\n\tu32 ecx = vcpu->arch.regs[VCPU_REGS_RCX];\n\tu64 data = (vcpu->arch.regs[VCPU_REGS_RAX] & -1u)\n\t\t| ((u64)(vcpu->arch.regs[VCPU_REGS_RDX] & -1u) << 32);\n\tmsr.data = data;\n\tmsr.index = ecx;\n\tmsr.host_initiated = false;\n\tif (vmx_set_msr(vcpu, &msr) != 0) {\n\t\ttrace_kvm_msr_write_ex(ecx, data);\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\ttrace_kvm_msr_write(ecx, data);\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}", "target": 1}
{"code": "int kill_pid_info_as_uid(int sig, struct siginfo *info, struct pid *pid,\n\t\t      uid_t uid, uid_t euid, u32 secid)\n{\n\tint ret = -EINVAL;\n\tstruct task_struct *p;\n\tconst struct cred *pcred;\n\tif (!valid_signal(sig))\n\t\treturn ret;\n\tread_lock(&tasklist_lock);\n\tp = pid_task(pid, PIDTYPE_PID);\n\tif (!p) {\n\t\tret = -ESRCH;\n\t\tgoto out_unlock;\n\t}\n\tpcred = __task_cred(p);\n\tif ((info == SEND_SIG_NOINFO ||\n\t     (!is_si_special(info) && SI_FROMUSER(info))) &&\n\t    euid != pcred->suid && euid != pcred->uid &&\n\t    uid  != pcred->suid && uid  != pcred->uid) {\n\t\tret = -EPERM;\n\t\tgoto out_unlock;\n\t}\n\tret = security_task_kill(p, info, sig, secid);\n\tif (ret)\n\t\tgoto out_unlock;\n\tif (sig && p->sighand) {\n\t\tunsigned long flags;\n\t\tspin_lock_irqsave(&p->sighand->siglock, flags);\n\t\tret = __send_signal(sig, info, p, 1, 0);\n\t\tspin_unlock_irqrestore(&p->sighand->siglock, flags);\n\t}\nout_unlock:\n\tread_unlock(&tasklist_lock);\n\treturn ret;\n}", "target": 0}
{"code": "MenuCacheDir* menu_cache_dup_root_dir( MenuCache* cache )\n{\n    MenuCacheDir* dir;\n    MENU_CACHE_LOCK;\n    dir = cache->root_dir;\n    if(G_LIKELY(dir))\n        menu_cache_item_ref(MENU_CACHE_ITEM(dir));\n    MENU_CACHE_UNLOCK;\n    return dir;\n}", "target": 0}
{"code": "static int nfc_genl_deactivate_target(struct sk_buff *skb,\n\t\t\t\t      struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tu32 device_idx, target_idx;\n\tint rc;\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n\t\treturn -EINVAL;\n\tdevice_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tdev = nfc_get_device(device_idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\ttarget_idx = nla_get_u32(info->attrs[NFC_ATTR_TARGET_INDEX]);\n\trc = nfc_deactivate_target(dev, target_idx, NFC_TARGET_MODE_SLEEP);\n\tnfc_put_device(dev);\n\treturn rc;\n}", "target": 1}
{"code": "static void FNAME(update_model)(CommonState *state, s_bucket * const bucket,\n                                const BYTE curval)\n{\n    SPICE_VERIFY(BPC >= 1);\n    spice_return_if_fail (bucket != NULL);\n    const unsigned int bpp = BPC;\n    COUNTER * const pcounters = bucket->pcounters;\n    unsigned int i;\n    unsigned int bestcode;\n    unsigned int bestcodelen;\n    bestcode = bpp - 1;\n    bestcodelen = (pcounters[bestcode] += FNAME(golomb_code_len)(curval, bestcode));\n    for (i = bpp - 2; i < bpp; i--) { \n        const unsigned int ithcodelen = (pcounters[i] += FNAME(golomb_code_len)(curval, i));\n        if (ithcodelen < bestcodelen) {\n            bestcode = i;\n            bestcodelen = ithcodelen;\n        }\n    }\n    bucket->bestcode = bestcode; \n    if (bestcodelen > state->wm_trigger) { \n        for (i = 0; i < bpp; i++) {\n            pcounters[i] >>= 1;\n        }\n    }\n}", "target": 0}
{"code": "static int db_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_run *kvm_run = svm->vcpu.run;\n\tif (!(svm->vcpu.guest_debug &\n\t      (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) &&\n\t\t!svm->nmi_singlestep) {\n\t\tkvm_queue_exception(&svm->vcpu, DB_VECTOR);\n\t\treturn 1;\n\t}\n\tif (svm->nmi_singlestep) {\n\t\tsvm->nmi_singlestep = false;\n\t\tif (!(svm->vcpu.guest_debug & KVM_GUESTDBG_SINGLESTEP))\n\t\t\tsvm->vmcb->save.rflags &=\n\t\t\t\t~(X86_EFLAGS_TF | X86_EFLAGS_RF);\n\t\tupdate_db_bp_intercept(&svm->vcpu);\n\t}\n\tif (svm->vcpu.guest_debug &\n\t    (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) {\n\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\tkvm_run->debug.arch.pc =\n\t\t\tsvm->vmcb->save.cs.base + svm->vmcb->save.rip;\n\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "int RGWHandler_REST_S3Website::error_handler(int err_no,\n\t\t\t\t\t    string* error_content) {\n  int new_err_no = -1;\n  rgw_http_errors::const_iterator r = rgw_http_s3_errors.find(err_no > 0 ? err_no : -err_no);\n  int http_error_code = -1;\n  if (r != rgw_http_s3_errors.end()) {\n    http_error_code = r->second.first;\n  }\n  ldpp_dout(s, 10) << \"RGWHandler_REST_S3Website::error_handler err_no=\" << err_no << \" http_ret=\" << http_error_code << dendl;\n  RGWBWRoutingRule rrule;\n  bool should_redirect =\n    s->bucket_info.website_conf.should_redirect(original_object_name,\n                                                http_error_code, &rrule);\n  if (should_redirect) {\n    const string& hostname = s->info.env->get(\"HTTP_HOST\", \"\");\n    const string& protocol =\n      (s->info.env->get(\"SERVER_PORT_SECURE\") ? \"https\" : \"http\");\n    int redirect_code = 0;\n    rrule.apply_rule(protocol, hostname, original_object_name,\n                     &s->redirect, &redirect_code);\n    if (redirect_code > 0)\n      s->err.http_ret = redirect_code; \n    ldpp_dout(s, 10) << \"error handler redirect code=\" << redirect_code\n\t\t      << \" proto+host:\" << protocol << \":\n\t\t      << \" -> \" << s->redirect << dendl;\n    return -ERR_WEBSITE_REDIRECT;\n  } else if (err_no == -ERR_WEBSITE_REDIRECT) {\n  } else if (!s->bucket_info.website_conf.error_doc.empty()) {\n    new_err_no = RGWHandler_REST_S3Website::serve_errordoc(http_error_code, s->bucket_info.website_conf.error_doc);\n    if (new_err_no && new_err_no != -1) {\n      err_no = new_err_no;\n    }\n  } else {\n    ldpp_dout(s, 20) << \"No special error handling today!\" << dendl;\n  }\n  return err_no;\n}", "target": 0}
{"code": "int i915_gem_context_destroy_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t   struct drm_file *file)\n{\n\tstruct drm_i915_gem_context_destroy *args = data;\n\tstruct drm_i915_file_private *file_priv = file->driver_priv;\n\tstruct i915_gem_context *ctx;\n\tint ret;\n\tif (args->pad != 0)\n\t\treturn -EINVAL;\n\tif (args->ctx_id == DEFAULT_CONTEXT_HANDLE)\n\t\treturn -ENOENT;\n\tctx = i915_gem_context_lookup(file_priv, args->ctx_id);\n\tif (!ctx)\n\t\treturn -ENOENT;\n\tret = mutex_lock_interruptible(&dev->struct_mutex);\n\tif (ret)\n\t\tgoto out;\n\tidr_remove(&file_priv->context_idr, ctx->user_handle);\n\tcontext_close(ctx);\n\tmutex_unlock(&dev->struct_mutex);\nout:\n\ti915_gem_context_put(ctx);\n\treturn 0;\n}", "target": 1}
{"code": "parse_atxheader(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size)\n{\n\tsize_t level = 0;\n\tsize_t i, end, skip;\n\twhile (level < size && level < 6 && data[level] == '#')\n\t\tlevel++;\n\tfor (i = level; i < size && data[i] == ' '; i++);\n\tfor (end = i; end < size && data[end] != '\\n'; end++);\n\tskip = end;\n\twhile (end && data[end - 1] == '#')\n\t\tend--;\n\twhile (end && data[end - 1] == ' ')\n\t\tend--;\n\tif (end > i) {\n\t\tstruct buf *work = rndr_newbuf(rndr, BUFFER_SPAN);\n\t\tparse_inline(work, rndr, data + i, end - i);\n\t\tif (rndr->cb.header)\n\t\t\trndr->cb.header(ob, work, (int)level, rndr->opaque);\n\t\trndr_popbuf(rndr, BUFFER_SPAN);\n\t}\n\treturn skip;\n}", "target": 0}
{"code": "static bool blit_is_unsafe(struct CirrusVGAState *s)\n{\n    assert(s->cirrus_blt_width > 0);\n    assert(s->cirrus_blt_height > 0);\n    if (blit_region_is_unsafe(s, s->cirrus_blt_dstpitch,\n                              s->cirrus_blt_dstaddr & s->cirrus_addr_mask)) {\n        return true;\n    }\n    if (blit_region_is_unsafe(s, s->cirrus_blt_srcpitch,\n                              s->cirrus_blt_srcaddr & s->cirrus_addr_mask)) {\n        return true;\n    }\n    return false;\n}", "target": 1}
{"code": "xfs_attrmulti_attr_set(\n\tstruct inode\t\t*inode,\n\tunsigned char\t\t*name,\n\tconst unsigned char\t__user *ubuf,\n\tuint32_t\t\tlen,\n\tuint32_t\t\tflags)\n{\n\tstruct xfs_da_args\targs = {\n\t\t.dp\t\t= XFS_I(inode),\n\t\t.attr_filter\t= xfs_attr_filter(flags),\n\t\t.attr_flags\t= xfs_attr_flags(flags),\n\t\t.name\t\t= name,\n\t\t.namelen\t= strlen(name),\n\t};\n\tint\t\t\terror;\n\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\treturn -EPERM;\n\tif (ubuf) {\n\t\tif (len > XFS_XATTR_SIZE_MAX)\n\t\t\treturn -EINVAL;\n\t\targs.value = memdup_user(ubuf, len);\n\t\tif (IS_ERR(args.value))\n\t\t\treturn PTR_ERR(args.value);\n\t\targs.valuelen = len;\n\t}\n\terror = xfs_attr_set(&args);\n\tif (!error && (flags & XFS_IOC_ATTR_ROOT))\n\t\txfs_forget_acl(inode, name);\n\tkfree(args.value);\n\treturn error;\n}", "target": 0}
{"code": "static struct btrfs_device *find_device(struct btrfs_fs_devices *fs_devices,\n\t\tu64 devid, const u8 *uuid)\n{\n\tstruct btrfs_device *dev;\n\tlist_for_each_entry(dev, &fs_devices->devices, dev_list) {\n\t\tif (dev->devid == devid &&\n\t\t    (!uuid || !memcmp(dev->uuid, uuid, BTRFS_UUID_SIZE))) {\n\t\t\treturn dev;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "static int sockfs_setattr(struct dentry *dentry, struct iattr *iattr)\n{\n\tint err = simple_setattr(dentry, iattr);\n\tif (!err && (iattr->ia_valid & ATTR_UID)) {\n\t\tstruct socket *sock = SOCKET_I(d_inode(dentry));\n\t\tsock->sk->sk_uid = iattr->ia_uid;\n\t}\n\treturn err;\n}", "target": 1}
{"code": "int PackLinuxElf32::canUnpack()\n{\n    if (super::canUnpack()) {\n        return true;\n    }\n    if (Elf32_Ehdr::ET_DYN==get_te16(&ehdri.e_type)) {\n        PackLinuxElf32help1(fi);\n    }\n    return false;\n}", "target": 1}
{"code": "mono_dllmap_lookup (MonoImage *assembly, const char *dll, const char* func, const char **rdll, const char **rfunc)\n{\n\tint res;\n\tif (assembly && assembly->dll_map) {\n\t\tres = mono_dllmap_lookup_list (assembly->dll_map, dll, func, rdll, rfunc);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\treturn mono_dllmap_lookup_list (global_dll_map, dll, func, rdll, rfunc);\n}", "target": 0}
{"code": "spnego_gss_wrap_size_limit(\n\tOM_uint32\t*minor_status,\n\tconst gss_ctx_id_t context_handle,\n\tint\t\tconf_req_flag,\n\tgss_qop_t\tqop_req,\n\tOM_uint32\treq_output_size,\n\tOM_uint32\t*max_input_size)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_size_limit(minor_status,\n\t\t\t\tcontext_handle,\n\t\t\t\tconf_req_flag,\n\t\t\t\tqop_req,\n\t\t\t\treq_output_size,\n\t\t\t\tmax_input_size);\n\treturn (ret);\n}", "target": 1}
{"code": "PJ_DEF(void) pj_scan_get_newline( pj_scanner *scanner )\n{\n    if (!PJ_SCAN_IS_NEWLINE(*scanner->curptr)) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n    if (*scanner->curptr == '\\r') {\n\t++scanner->curptr;\n    }\n    if (*scanner->curptr == '\\n') {\n\t++scanner->curptr;\n    }\n    ++scanner->line;\n    scanner->start_line = scanner->curptr;\n}", "target": 1}
{"code": "snmp_ber_decode_oid(snmp_packet_t *snmp_packet, snmp_oid_t *oid)\n{\n  uint8_t *buf_end, type;\n  uint8_t len, j;\n  div_t first;\n  if(!snmp_ber_decode_type(snmp_packet, &type)) {\n    return 0;\n  }\n  if(type != BER_DATA_TYPE_OBJECT_IDENTIFIER) {\n    return 0;\n  }\n  if(!snmp_ber_decode_length(snmp_packet, &len)) {\n    return 0;\n  }\n  buf_end = snmp_packet->in + len;\n  if(snmp_packet->used == 0) {\n    return 0;\n  }\n  snmp_packet->used--;\n  first = div(*snmp_packet->in++, 40);\n  oid->length = 0;\n  oid->data[oid->length++] = (uint32_t)first.quot;\n  oid->data[oid->length++] = (uint32_t)first.rem;\n  while(snmp_packet->in != buf_end) {\n    if(oid->length >= SNMP_MSG_OID_MAX_LEN) {\n      return 0;\n    }\n    if(snmp_packet->used == 0) {\n      return 0;\n    }\n    oid->data[oid->length] = (uint32_t)(*snmp_packet->in & 0x7F);\n    for(j = 0; j < 4; j++) {\n      snmp_packet->used--;\n      if((*snmp_packet->in++ & 0x80) == 0) {\n        break;\n      }\n      if(snmp_packet->used == 0) {\n        return 0;\n      }\n      oid->data[oid->length] <<= 7;\n      oid->data[oid->length] |= (*snmp_packet->in & 0x7F);\n    }\n    oid->length++;\n  }\n  return 1;\n}", "target": 0}
{"code": "static void zynq_slcr_reset_exit(Object *obj)\n{\n    ZynqSLCRState *s = ZYNQ_SLCR(obj);\n    zynq_slcr_compute_clocks(s);\n    zynq_slcr_propagate_clocks(s);\n}", "target": 0}
{"code": "static struct o2nm_cluster *to_o2nm_cluster_from_node(struct o2nm_node *node)\n{\n\treturn to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);\n}", "target": 1}
{"code": "static struct sctp_chunk *sctp_make_asconf(struct sctp_association *asoc,\n\t\t\t\t\t   union sctp_addr *addr,\n\t\t\t\t\t   int vparam_len)\n{\n\tsctp_addiphdr_t asconf;\n\tstruct sctp_chunk *retval;\n\tint length = sizeof(asconf) + vparam_len;\n\tunion sctp_addr_param addrparam;\n\tint addrlen;\n\tstruct sctp_af *af = sctp_get_af_specific(addr->v4.sin_family);\n\taddrlen = af->to_addr_param(addr, &addrparam);\n\tif (!addrlen)\n\t\treturn NULL;\n\tlength += addrlen;\n\tretval = sctp_make_control(asoc, SCTP_CID_ASCONF, 0, length);\n\tif (!retval)\n\t\treturn NULL;\n\tasconf.serial = htonl(asoc->addip_serial++);\n\tretval->subh.addip_hdr =\n\t\tsctp_addto_chunk(retval, sizeof(asconf), &asconf);\n\tretval->param_hdr.v =\n\t\tsctp_addto_chunk(retval, addrlen, &addrparam);\n\treturn retval;\n}", "target": 0}
{"code": "comics_generate_command_lines (ComicsDocument *comics_document, \n\t\t\t       GError         **error)\n{\n\tgchar *quoted_file, *quoted_file_aux;\n\tgchar *quoted_command;\n\tComicBookDecompressType type;\n\ttype = comics_document->command_usage;\n\tcomics_document->regex_arg = command_usage_def[type].regex_arg;\n\tquoted_command = g_shell_quote (comics_document->selected_command);\n\tif (comics_document->regex_arg) {\n\t\tquoted_file = comics_regex_quote (comics_document->archive);\n\t\tquoted_file_aux = g_shell_quote (comics_document->archive);\n\t\tcomics_document->list_command =\n\t\t\t   g_strdup_printf (command_usage_def[type].list,\n\t\t\t                    comics_document->alternative_command,\n\t\t\t                    quoted_file_aux);\n\t\tg_free (quoted_file_aux);\n\t} else {\n\t\tquoted_file = g_shell_quote (comics_document->archive);\n\t\tcomics_document->list_command =\n\t\t\t\tg_strdup_printf (command_usage_def[type].list,\n\t\t\t\t                 quoted_command, quoted_file);\n\t}\n\tcomics_document->extract_command =\n\t\t\t    g_strdup_printf (command_usage_def[type].extract,\n\t\t\t\t             quoted_command);\n\tcomics_document->offset = command_usage_def[type].offset;\n\tif (command_usage_def[type].decompress_tmp) {\n\t\tcomics_document->dir = ev_mkdtemp (\"atril-comics-XXXXXX\", error);\n                if (comics_document->dir == NULL)\n                        return FALSE;\n\t\tcomics_document->decompress_tmp =\n\t\t\tg_strdup_printf (command_usage_def[type].decompress_tmp, \n\t\t\t\t\t quoted_command, quoted_file,\n\t\t\t\t\t comics_document->dir);\n\t\tg_free (quoted_file);\n\t\tg_free (quoted_command);\n\t\tif (!comics_decompress_temp_dir (comics_document->decompress_tmp,\n\t\t    comics_document->selected_command, error))\n\t\t\treturn FALSE;\n\t\telse\n\t\t\treturn TRUE;\n\t} else {\n\t\tg_free (quoted_file);\n\t\tg_free (quoted_command);\n\t\treturn TRUE;\n\t}\n}", "target": 0}
{"code": "static int xar_get_numeric_from_xml_element(xmlTextReaderPtr reader, long * value)\n{\n    const xmlChar * numstr;\n    if (xmlTextReaderRead(reader) == 1 && xmlTextReaderNodeType(reader) == XML_READER_TYPE_TEXT) {\n        numstr = xmlTextReaderConstValue(reader);\n        if (numstr) {\n            *value = atol((const char *)numstr);\n            if (*value < 0) {\n                cli_dbgmsg(\"cli_scanxar: XML element value %li\\n\", *value);\n                return CL_EFORMAT;\n            }\n            return CL_SUCCESS;\n        }\n    }\n    cli_dbgmsg(\"cli_scanxar: No text for XML element\\n\");\n    return CL_EFORMAT;\n}", "target": 1}
{"code": "bool CTransaction::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs, bool* pfMissingInputs)\n{\n    return mempool.accept(txdb, *this, fCheckInputs, pfMissingInputs);\n}", "target": 1}
{"code": "waitfd(int fd, int *timeoutp, short events)\n{\n\tstruct pollfd pfd;\n\tstruct timeval t_start;\n\tint oerrno, r;\n\tpfd.fd = fd;\n\tpfd.events = events;\n\tfor (; *timeoutp >= 0;) {\n\t\tmonotime_tv(&t_start);\n\t\tr = poll(&pfd, 1, *timeoutp);\n\t\toerrno = errno;\n\t\tms_subtract_diff(&t_start, timeoutp);\n\t\terrno = oerrno;\n\t\tif (r > 0)\n\t\t\treturn 0;\n\t\telse if (r == -1 && errno != EAGAIN && errno != EINTR)\n\t\t\treturn -1;\n\t\telse if (r == 0)\n\t\t\tbreak;\n\t}\n\terrno = ETIMEDOUT;\n\treturn -1;\n}", "target": 0}
{"code": "static inline void __file_sb_list_add(struct file *file, struct super_block *sb)\n{\n\tstruct list_head *list;\n#ifdef CONFIG_SMP\n\tint cpu;\n\tcpu = smp_processor_id();\n\tfile->f_sb_list_cpu = cpu;\n\tlist = per_cpu_ptr(sb->s_files, cpu);\n#else\n\tlist = &sb->s_files;\n#endif\n\tlist_add(&file->f_u.fu_list, list);\n}", "target": 1}
{"code": "static void _mysql_close(void *conn)\n{\n    mysql_close(conn);\n}", "target": 0}
{"code": "  void getReadBuffer(void** bufReturn, size_t* lenReturn) override {\n    *bufReturn = buf_.data();\n    *lenReturn = buf_.size();\n  }", "target": 0}
{"code": "static void utee_param_to_param(struct tee_ta_param *p, struct utee_params *up)\n{\n\tsize_t n;\n\tuint32_t types = up->types;\n\tp->types = types;\n\tfor (n = 0; n < TEE_NUM_PARAMS; n++) {\n\t\tuintptr_t a = up->vals[n * 2];\n\t\tsize_t b = up->vals[n * 2 + 1];\n\t\tswitch (TEE_PARAM_TYPE_GET(types, n)) {\n\t\tcase TEE_PARAM_TYPE_MEMREF_INPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_OUTPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_INOUT:\n\t\t\tp->u[n].mem.mobj = &mobj_virt;\n\t\t\tp->u[n].mem.offs = a;\n\t\t\tp->u[n].mem.size = b;\n\t\t\tbreak;\n\t\tcase TEE_PARAM_TYPE_VALUE_INPUT:\n\t\tcase TEE_PARAM_TYPE_VALUE_INOUT:\n\t\t\tp->u[n].val.a = a;\n\t\t\tp->u[n].val.b = b;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmemset(&p->u[n], 0, sizeof(p->u[n]));\n\t\t\tbreak;\n\t\t}\n\t}\n}", "target": 1}
{"code": "int mount_proc_if_needed(const char *rootfs)\n{\n\tchar path[MAXPATHLEN];\n\tchar link[20];\n\tint linklen, ret;\n\tint mypid;\n\tret = snprintf(path, MAXPATHLEN, \"%s/proc/self\", rootfs);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tSYSERROR(\"proc path name too long\");\n\t\treturn -1;\n\t}\n\tmemset(link, 0, 20);\n\tlinklen = readlink(path, link, 20);\n\tmypid = (int)getpid();\n\tINFO(\"I am %d, /proc/self points to '%s'\", mypid, link);\n\tret = snprintf(path, MAXPATHLEN, \"%s/proc\", rootfs);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tSYSERROR(\"proc path name too long\");\n\t\treturn -1;\n\t}\n\tif (linklen < 0) \n\t\tgoto domount;\n\tif (atoi(link) != mypid) {\n\t\tumount2(path, MNT_DETACH); \n\t\tgoto domount;\n\t}\n\treturn 0;\ndomount:\n\tif (mount(\"proc\", path, \"proc\", 0, NULL))\n\t\treturn -1;\n\tINFO(\"Mounted /proc in container for security transition\");\n\treturn 1;\n}", "target": 1}
{"code": "static CallResult<HermesValue> getCodeBlockFileName(\n    Runtime &runtime,\n    const CodeBlock *codeBlock,\n    OptValue<hbc::DebugSourceLocation> location) {\n  RuntimeModule *runtimeModule = codeBlock->getRuntimeModule();\n  if (location) {\n    auto debugInfo = runtimeModule->getBytecode()->getDebugInfo();\n    return StringPrimitive::createEfficient(\n        runtime, debugInfo->getFilenameByID(location->filenameId));\n  } else {\n    llvh::StringRef sourceURL = runtimeModule->getSourceURL();\n    if (!sourceURL.empty()) {\n      return StringPrimitive::createEfficient(runtime, sourceURL);\n    }\n  }\n  return HermesValue::encodeUndefinedValue();\n}", "target": 1}
{"code": "static av_cold int decode_init(AVCodecContext *avctx)\n{\n    AnsiContext *s = avctx->priv_data;\n    avctx->pix_fmt = AV_PIX_FMT_PAL8;\n    s->frame = av_frame_alloc();\n    if (!s->frame)\n        return AVERROR(ENOMEM);\n    s->font        = avpriv_vga16_font;\n    s->font_height = 16;\n    s->fg          = DEFAULT_FG_COLOR;\n    s->bg          = DEFAULT_BG_COLOR;\n    if (!avctx->width || !avctx->height)\n        ff_set_dimensions(avctx, 80 << 3, 25 << 4);\n    return 0;\n}", "target": 0}
{"code": "RedVDIReadBuf::~RedVDIReadBuf()\n{\n    dev->priv->num_read_buf--;\n    if (dev->priv->agent_attached) {\n       dev->wakeup();\n    }\n}", "target": 0}
{"code": "void snd_usb_mixer_disconnect(struct usb_mixer_interface *mixer)\n{\n\tusb_kill_urb(mixer->urb);\n\tusb_kill_urb(mixer->rc_urb);\n}", "target": 1}
{"code": "bool HHVM_FUNCTION(imagesettile, const Resource& image, const Resource& tile) {\n  gdImagePtr im = get_valid_image_resource(image);\n  if (!im) return false;\n  gdImagePtr til = get_valid_image_resource(tile);\n  if (!til) return false;\n  gdImageSetTile(im, til);\n  return true;\n}", "target": 0}
{"code": "int avrcp_set_volume(struct btd_device *dev, int8_t volume, bool notify)\n{\n\tstruct avrcp_server *server;\n\tstruct avrcp *session;\n\tuint8_t buf[AVRCP_HEADER_LENGTH + 1];\n\tstruct avrcp_header *pdu = (void *) buf;\n\tif (volume < 0)\n\t\treturn -EINVAL;\n\tserver = find_server(servers, device_get_adapter(dev));\n\tif (server == NULL)\n\t\treturn -EINVAL;\n\tsession = find_session(server->sessions, dev);\n\tif (session == NULL)\n\t\treturn -ENOTCONN;\n\tif (notify) {\n\t\tif (!session->target)\n\t\t\treturn -ENOTSUP;\n\t\treturn avrcp_event(session, AVRCP_EVENT_VOLUME_CHANGED,\n\t\t\t\t\t\t\t\t&volume);\n\t}\n\tif (!session->controller && !avrcp_event_registered(session,\n\t\t\t\t\tAVRCP_EVENT_VOLUME_CHANGED))\n\t\treturn -ENOTSUP;\n\tmemset(buf, 0, sizeof(buf));\n\tset_company_id(pdu->company_id, IEEEID_BTSIG);\n\tpdu->pdu_id = AVRCP_SET_ABSOLUTE_VOLUME;\n\tpdu->params[0] = volume;\n\tpdu->params_len = htons(1);\n\treturn avctp_send_vendordep_req(session->conn,\n\t\t\t\t\tAVC_CTYPE_CONTROL, AVC_SUBUNIT_PANEL,\n\t\t\t\t\tbuf, sizeof(buf),\n\t\t\t\t\tavrcp_handle_set_volume, session);\n}", "target": 0}
{"code": "static ptrdiff_t finderrfunc(lua_State *L)\n{\n  cTValue *frame = L->base-1, *bot = tvref(L->stack);\n  void *cf = L->cframe;\n  while (frame > bot && cf) {\n    while (cframe_nres(cframe_raw(cf)) < 0) {  \n      if (frame >= restorestack(L, -cframe_nres(cf)))\n\tbreak;\n      if (cframe_errfunc(cf) >= 0)  \n\treturn cframe_errfunc(cf);\n      cf = cframe_prev(cf);  \n      if (cf == NULL)\n\treturn 0;\n    }\n    switch (frame_typep(frame)) {\n    case FRAME_LUA:\n    case FRAME_LUAP:\n      frame = frame_prevl(frame);\n      break;\n    case FRAME_C:\n      cf = cframe_prev(cf);\n    case FRAME_VARG:\n      frame = frame_prevd(frame);\n      break;\n    case FRAME_CONT:\n#if LJ_HASFFI\n      if ((frame-1)->u32.lo == LJ_CONT_FFI_CALLBACK)\n\tcf = cframe_prev(cf);\n#endif\n      frame = frame_prevd(frame);\n      break;\n    case FRAME_CP:\n      if (cframe_canyield(cf)) return 0;\n      if (cframe_errfunc(cf) >= 0)\n\treturn cframe_errfunc(cf);\n      frame = frame_prevd(frame);\n      break;\n    case FRAME_PCALL:\n    case FRAME_PCALLH:\n      if (frame_ftsz(frame) >= (ptrdiff_t)(2*sizeof(TValue)))  \n\treturn savestack(L, frame-1);  \n      return 0;\n    default:\n      lua_assert(0);\n      return 0;\n    }\n  }\n  return 0;\n}", "target": 1}
{"code": "static int sctp_setsockopt_partial_delivery_point(struct sock *sk,\n\t\t\t\t\t\t  char __user *optval,\n\t\t\t\t\t\t  int optlen)\n{\n\tu32 val;\n\tif (optlen != sizeof(u32))\n\t\treturn -EINVAL;\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\tsctp_sk(sk)->pd_point = val;\n\treturn 0; \n}", "target": 0}
{"code": "static bool is_ctx_reg(struct bpf_verifier_env *env, int regno)\n{\n\tconst struct bpf_reg_state *reg = reg_state(env, regno);\n\treturn reg->type == PTR_TO_CTX;\n}", "target": 0}
{"code": "static struct dentry *proc_pident_lookup(struct inode *dir, \n\t\t\t\t\t struct dentry *dentry,\n\t\t\t\t\t const struct pid_entry *ents,\n\t\t\t\t\t unsigned int nents)\n{\n\tstruct inode *inode;\n\tstruct dentry *error;\n\tstruct task_struct *task = get_proc_task(dir);\n\tconst struct pid_entry *p, *last;\n\terror = ERR_PTR(-ENOENT);\n\tinode = NULL;\n\tif (!task)\n\t\tgoto out_no_task;\n\tlast = &ents[nents - 1];\n\tfor (p = ents; p <= last; p++) {\n\t\tif (p->len != dentry->d_name.len)\n\t\t\tcontinue;\n\t\tif (!memcmp(dentry->d_name.name, p->name, p->len))\n\t\t\tbreak;\n\t}\n\tif (p > last)\n\t\tgoto out;\n\terror = proc_pident_instantiate(dir, dentry, task, p);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn error;\n}", "target": 0}
{"code": "int BN_hex2bn(BIGNUM **bn, const char *a)\n{\n    BIGNUM *ret = NULL;\n    BN_ULONG l = 0;\n    int neg = 0, h, m, i, j, k, c;\n    int num;\n    if ((a == NULL) || (*a == '\\0'))\n        return (0);\n    if (*a == '-') {\n        neg = 1;\n        a++;\n    }\n    for (i = 0; i <= (INT_MAX/4) && isxdigit((unsigned char)a[i]); i++)\n        continue;\n    if (i > INT_MAX/4)\n        goto err;\n    num = i + neg;\n    if (bn == NULL)\n        return (num);\n    if (*bn == NULL) {\n        if ((ret = BN_new()) == NULL)\n            return (0);\n    } else {\n        ret = *bn;\n        BN_zero(ret);\n    }\n    if (bn_expand(ret, i * 4) == NULL)\n        goto err;\n    j = i;                      \n    m = 0;\n    h = 0;\n    while (j > 0) {\n        m = ((BN_BYTES * 2) <= j) ? (BN_BYTES * 2) : j;\n        l = 0;\n        for (;;) {\n            c = a[j - m];\n            if ((c >= '0') && (c <= '9'))\n                k = c - '0';\n            else if ((c >= 'a') && (c <= 'f'))\n                k = c - 'a' + 10;\n            else if ((c >= 'A') && (c <= 'F'))\n                k = c - 'A' + 10;\n            else\n                k = 0;          \n            l = (l << 4) | k;\n            if (--m <= 0) {\n                ret->d[h++] = l;\n                break;\n            }\n        }\n        j -= (BN_BYTES * 2);\n    }\n    ret->top = h;\n    bn_correct_top(ret);\n    ret->neg = neg;\n    *bn = ret;\n    bn_check_top(ret);\n    return (num);\n err:\n    if (*bn == NULL)\n        BN_free(ret);\n    return (0);\n}", "target": 0}
{"code": "spnego_gss_wrap_size_limit(\n\tOM_uint32\t*minor_status,\n\tconst gss_ctx_id_t context_handle,\n\tint\t\tconf_req_flag,\n\tgss_qop_t\tqop_req,\n\tOM_uint32\treq_output_size,\n\tOM_uint32\t*max_input_size)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_size_limit(minor_status,\n\t\t\t\tcontext_handle,\n\t\t\t\tconf_req_flag,\n\t\t\t\tqop_req,\n\t\t\t\treq_output_size,\n\t\t\t\tmax_input_size);\n\treturn (ret);\n}", "target": 0}
{"code": "PinholeVerification(struct upnphttp * h, char * int_ip, unsigned short int_port)\n{\n\tint n;\n\tchar senderAddr[INET6_ADDRSTRLEN]=\"\";\n\tstruct addrinfo hints, *ai, *p;\n\tstruct in6_addr result_ip;\n\tsyslog(LOG_INFO, \"Checking internal IP@ and port (Security policy purpose)\");\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_family = AF_UNSPEC;\n\tif (inet_pton(AF_INET6, int_ip, &result_ip) <= 0)\n\t{\n\t\tn = getaddrinfo(int_ip, NULL, &hints, &ai);\n\t\tif(!n && ai->ai_family == AF_INET6)\n\t\t{\n\t\t\tfor(p = ai; p; p = p->ai_next)\n\t\t\t{\n\t\t\t\tinet_ntop(AF_INET6, (struct in6_addr *) p, int_ip, sizeof(struct in6_addr));\n\t\t\t\tresult_ip = *((struct in6_addr *) p);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsyslog(LOG_ERR, \"Failed to convert hostname '%s' to ip address\", int_ip);\n\t\t\tSoapError(h, 402, \"Invalid Args\");\n\t\t\treturn -1;\n\t\t}\n        freeaddrinfo(p);\n\t}\n\tif(inet_ntop(AF_INET6, &(h->clientaddr_v6), senderAddr, INET6_ADDRSTRLEN) == NULL)\n\t{\n\t\tsyslog(LOG_ERR, \"inet_ntop: %m\");\n\t}\n#ifdef DEBUG\n\tprintf(\"\\tPinholeVerification:\\n\\t\\tCompare sender @: %s\\n\\t\\t  to intClient @: %s\\n\", senderAddr, int_ip);\n#endif\n\tif(strcmp(senderAddr, int_ip) != 0)\n\tif(h->clientaddr_v6.s6_addr != result_ip.s6_addr)\n\t{\n\t\tsyslog(LOG_INFO, \"Client %s tried to access pinhole for internal %s and is not authorized to do it\",\n\t\t       senderAddr, int_ip);\n\t\tSoapError(h, 606, \"Action not authorized\");\n\t\treturn 0;\n\t}\n\tif (int_port < 1024)\n\t{\n\t\tsyslog(LOG_INFO, \"Client %s tried to access pinhole with port < 1024 and is not authorized to do it\",\n\t\t       senderAddr);\n\t\tSoapError(h, 606, \"Action not authorized\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "static int dump_suid_policy()\n{\n    int c;\n    int suid_dump_policy = 0;\n    const char *filename = \"/proc/sys/fs/suid_dumpable\";\n    FILE *f  = fopen(filename, \"r\");\n    if (!f)\n    {\n        log(\"Can't open %s\", filename);\n        return suid_dump_policy;\n    }\n    c = fgetc(f);\n    fclose(f);\n    if (c != EOF)\n        suid_dump_policy = c - '0';\n    return suid_dump_policy;\n}", "target": 0}
{"code": "static int __init memory_tier_init(void)\n{\n\tint ret, node;\n\tstruct memory_tier *memtier;\n\tret = subsys_virtual_register(&memory_tier_subsys, NULL);\n\tif (ret)\n\t\tpanic(\"%s() failed to register memory tier subsystem\\n\", __func__);\n#ifdef CONFIG_MIGRATION\n\tnode_demotion = kcalloc(nr_node_ids, sizeof(struct demotion_nodes),\n\t\t\t\tGFP_KERNEL);\n\tWARN_ON(!node_demotion);\n#endif\n\tmutex_lock(&memory_tier_lock);\n\tdefault_dram_type = alloc_memory_type(MEMTIER_ADISTANCE_DRAM);\n\tif (!default_dram_type)\n\t\tpanic(\"%s() failed to allocate default DRAM tier\\n\", __func__);\n\tfor_each_node_state(node, N_MEMORY) {\n\t\tmemtier = set_node_memory_tier(node);\n\t\tif (IS_ERR(memtier))\n\t\t\tbreak;\n\t}\n\testablish_demotion_targets();\n\tmutex_unlock(&memory_tier_lock);\n\thotplug_memory_notifier(memtier_hotplug_callback, MEMTIER_HOTPLUG_PRI);\n\treturn 0;\n}", "target": 1}
{"code": "static void tcp_illinois_info(struct sock *sk, u32 ext,\n\t\t\t      struct sk_buff *skb)\n{\n\tconst struct illinois *ca = inet_csk_ca(sk);\n\tif (ext & (1 << (INET_DIAG_VEGASINFO - 1))) {\n\t\tstruct tcpvegas_info info = {\n\t\t\t.tcpv_enabled = 1,\n\t\t\t.tcpv_rttcnt = ca->cnt_rtt,\n\t\t\t.tcpv_minrtt = ca->base_rtt,\n\t\t};\n\t\tu64 t = ca->sum_rtt;\n\t\tdo_div(t, ca->cnt_rtt);\n\t\tinfo.tcpv_rtt = t;\n\t\tnla_put(skb, INET_DIAG_VEGASINFO, sizeof(info), &info);\n\t}\n}", "target": 1}
{"code": "RenderThreadImpl::RenderThreadImpl(const std::string& channel_name)\n    : ChildThread(Options(channel_name, ShouldUseMojoChannel())) {\n  Init();\n}", "target": 0}
{"code": "  SubgraphGuard(TfLiteContext* context, bool* is_subgraph_in_use)\n      : is_subgraph_in_use_(is_subgraph_in_use) {\n    if (*is_subgraph_in_use_) {\n      TF_LITE_KERNEL_LOG(\n          context,\n          \"Subgraph is already in use. Using an interpreter or a subgraph in \"\n          \"multiple threads is not supported. Recursion in the graph is not \"\n          \"supported.\");\n      status_ = kTfLiteError;\n    } else {\n      *is_subgraph_in_use_ = true;\n    }\n  }", "target": 0}
{"code": "externalEntityInitProcessor2(XML_Parser parser, const char *start,\n                             const char *end, const char **endPtr) {\n  const char *next = start; \n  int tok = XmlContentTok(parser->m_encoding, start, end, &next);\n  switch (tok) {\n  case XML_TOK_BOM:\n#ifdef XML_DTD\n    if (! accountingDiffTolerated(parser, tok, start, next, __LINE__,\n                                  XML_ACCOUNT_DIRECT)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }\n#endif \n    if (next == end && ! parser->m_parsingStatus.finalBuffer) {\n      *endPtr = next;\n      return XML_ERROR_NONE;\n    }\n    start = next;\n    break;\n  case XML_TOK_PARTIAL:\n    if (! parser->m_parsingStatus.finalBuffer) {\n      *endPtr = start;\n      return XML_ERROR_NONE;\n    }\n    parser->m_eventPtr = start;\n    return XML_ERROR_UNCLOSED_TOKEN;\n  case XML_TOK_PARTIAL_CHAR:\n    if (! parser->m_parsingStatus.finalBuffer) {\n      *endPtr = start;\n      return XML_ERROR_NONE;\n    }\n    parser->m_eventPtr = start;\n    return XML_ERROR_PARTIAL_CHAR;\n  }\n  parser->m_processor = externalEntityInitProcessor3;\n  return externalEntityInitProcessor3(parser, start, end, endPtr);\n}", "target": 1}
{"code": "static ssize_t ocfs2_direct_IO(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tget_block_t *get_block;\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn 0;\n\tif (iocb->ki_pos + iter->count > i_size_read(inode) &&\n\t    !ocfs2_supports_append_dio(osb))\n\t\treturn 0;\n\tif (iov_iter_rw(iter) == READ)\n\t\tget_block = ocfs2_get_block;\n\telse\n\t\tget_block = ocfs2_dio_get_block;\n\treturn __blockdev_direct_IO(iocb, inode, inode->i_sb->s_bdev,\n\t\t\t\t    iter, get_block,\n\t\t\t\t    ocfs2_dio_end_io, NULL, 0);\n}", "target": 1}
{"code": "String UTF16BEDecoder::to_utf8(const StringView& input)\n{\n    StringBuilder builder(input.length() / 2);\n    for (size_t i = 0; i < input.length(); i += 2) {\n        u16 code_point = (input[i] << 8) | input[i + 1];\n        builder.append_code_point(code_point);\n    }\n    return builder.to_string();\n}", "target": 1}
{"code": "static struct rt6_info *rt6_multipath_select(struct rt6_info *match,\n\t\t\t\t\t     struct flowi6 *fl6)\n{\n\tstruct rt6_info *sibling, *next_sibling;\n\tint route_choosen;\n\troute_choosen = rt6_info_hash_nhsfn(match->rt6i_nsiblings + 1, fl6);\n\tif (route_choosen)\n\t\tlist_for_each_entry_safe(sibling, next_sibling,\n\t\t\t\t&match->rt6i_siblings, rt6i_siblings) {\n\t\t\troute_choosen--;\n\t\t\tif (route_choosen == 0) {\n\t\t\t\tmatch = sibling;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\treturn match;\n}", "target": 0}
{"code": "transientObjectPutErrorMessage(Runtime *runtime, Handle<> base, SymbolID id) {\n  StringView propName =\n      runtime->getIdentifierTable().getStringView(runtime, id);\n  Handle<StringPrimitive> baseType =\n      runtime->makeHandle(vmcast<StringPrimitive>(typeOf(runtime, base)));\n  StringView baseTypeAsString =\n      StringPrimitive::createStringView(runtime, baseType);\n  MutableHandle<StringPrimitive> valueAsString{runtime};\n  if (base->isSymbol()) {\n    auto str = symbolDescriptiveString(runtime, Handle<SymbolID>::vmcast(base));\n    if (str != ExecutionStatus::EXCEPTION) {\n      valueAsString = *str;\n    } else {\n      runtime->clearThrownValue();\n      valueAsString = StringPrimitive::createNoThrow(\n          runtime, \"<<Exception occurred getting the value>>\");\n    }\n  } else {\n    auto str = toString_RJS(runtime, base);\n    assert(\n        str != ExecutionStatus::EXCEPTION &&\n        \"Primitives should be convertible to string without exceptions\");\n    valueAsString = std::move(*str);\n  }\n  StringView valueAsStringPrintable =\n      StringPrimitive::createStringView(runtime, valueAsString);\n  SmallU16String<32> tmp;\n  return runtime->raiseTypeError(\n      TwineChar16(\"Cannot create property '\") + propName + \"' on \" +\n      baseTypeAsString.getUTF16Ref(tmp) + \" '\" +\n      valueAsStringPrintable.getUTF16Ref(tmp) + \"'\");\n}", "target": 1}
{"code": "char_codespan(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)\n{\n\tsize_t end, nb = 0, i, f_begin, f_end;\n\twhile (nb < size && data[nb] == '`')\n\t\tnb++;\n\ti = 0;\n\tfor (end = nb; end < size && i < nb; end++) {\n\t\tif (data[end] == '`') i++;\n\t\telse i = 0;\n\t}\n\tif (i < nb && end >= size)\n\t\treturn 0; \n\tf_begin = nb;\n\twhile (f_begin < end && data[f_begin] == ' ')\n\t\tf_begin++;\n\tf_end = end - nb;\n\twhile (f_end > nb && data[f_end-1] == ' ')\n\t\tf_end--;\n\tif (f_begin < f_end) {\n\t\tstruct buf work = { data + f_begin, f_end - f_begin, 0, 0 };\n\t\tif (!rndr->cb.codespan(ob, &work, rndr->opaque))\n\t\t\tend = 0;\n\t} else {\n\t\tif (!rndr->cb.codespan(ob, 0, rndr->opaque))\n\t\t\tend = 0;\n\t}\n\treturn end;\n}", "target": 0}
{"code": "static int verify_ee(const gnutls_datum_t *raw_crt, gnutls_certificate_type_t crt_type,\n\t\t dane_cert_type_t ctype, dane_match_type_t match, gnutls_datum_t * data,\n\t\t unsigned int *verify)\n{\ngnutls_datum_t pubkey = {NULL, 0};\nint ret;\n\tif (ctype == DANE_CERT_X509 && crt_type == GNUTLS_CRT_X509) {\n\t\tif (!matches(raw_crt, data, match)) {\n\t\t        gnutls_assert();\n\t\t\t*verify |= DANE_VERIFY_CERT_DIFFERS;\n                }\n\t} else if (ctype == DANE_CERT_PK && crt_type == GNUTLS_CRT_X509) {\n\t\tret = crt_to_pubkey(raw_crt, &pubkey);\n\t\tif (ret < 0) {\n        \t        gnutls_assert();\n\t\t\tgoto cleanup;\n                }\n\t\tif (!matches(&pubkey, data, match)) {\n\t\t        gnutls_assert();\n\t\t\t*verify |= DANE_VERIFY_CERT_DIFFERS;\n                }\n\t} else {\n\t\tret = gnutls_assert_val(DANE_E_UNKNOWN_DANE_DATA);\n\t\tgoto cleanup;\n\t}\n\tret = 0;\ncleanup:\n\tfree(pubkey.data);\n\treturn ret;\n}", "target": 0}
{"code": "static struct dmar_domain *find_domain(struct device *dev)\n{\n\tstruct device_domain_info *info;\n\tinfo = dev->archdata.iommu;\n\tif (likely(info))\n\t\treturn info->domain;\n\treturn NULL;\n}", "target": 0}
{"code": "static int isdn_ppp_skip_ac(struct ippp_struct *is, struct sk_buff *skb)\n{\n\tif (skb->len < 1)\n\t\treturn -1;\n\tif (skb->data[0] == 0xff) {\n\t\tif (skb->len < 2)\n\t\t\treturn -1;\n\t\tif (skb->data[1] != 0x03)\n\t\t\treturn -1;\n\t\tskb_pull(skb, 2);\n\t} else {\n\t\tif (is->pppcfg & SC_REJ_COMP_AC)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "  void DefaultEnv::Initialize()\n  {\n    sLog           = new Log();\n    SetUpLog();\n    sEnv           = new DefaultEnv();\n    sForkHandler   = new ForkHandler();\n    sFileTimer     = new FileTimer();\n    sPlugInManager = new PlugInManager();\n    sPlugInManager->ProcessEnvironmentSettings();\n    sForkHandler->RegisterFileTimer( sFileTimer );\n#ifdef __APPLE__\n    char *errBuff = new char[1024];\n    const char *libs[] =\n    {\n      \"libXrdSeckrb5.so\",\n      \"libXrdSecgsi.so\",\n      \"libXrdSecgsiAuthzVO.so\",\n      \"libXrdSecgsiGMAPDN.so\",\n      \"libXrdSecgsiGMAPLDAP.so\",\n      \"libXrdSecpwd.so\",\n      \"libXrdSecsss.so\",\n      \"libXrdSecunix.so\",\n      0\n    };\n    for( int i = 0; libs[i]; ++i )\n    {\n      sLog->Debug( UtilityMsg, \"Attempting to pre-load: %s\", libs[i] );\n      bool ok = XrdOucPreload( libs[i], errBuff, 1024 );\n      if( !ok )\n        sLog->Error( UtilityMsg, \"Unable to pre-load %s: %s\", libs[i], errBuff );\n    }\n    delete [] errBuff;\n#endif\n  }", "target": 1}
{"code": "void header_time(int stat, char *str, char *more)\n{\n  char buf[64];\n  xprintf(\"HTTP/1.1 %d %s\\r\\nServer: toybox httpd/%s\\r\\nDate: %s\\r\\n%s\"\n    \"Connection: close\\r\\n\\r\\n\", stat, str, TOYBOX_VERSION,\n    rfc1123(buf, time(0)), more ? : \"\");\n}", "target": 0}
{"code": "static inline LineContribType * _gdContributionsAlloc(unsigned int line_length, unsigned int windows_size)\n{\n\tunsigned int u = 0;\n\tLineContribType *res;\n\tint overflow_error = 0;\n\tres = (LineContribType *) gdMalloc(sizeof(LineContribType));\n\tif (!res) {\n\t\treturn NULL;\n\t}\n\tres->WindowSize = windows_size;\n\tres->LineLength = line_length;\n\tif (overflow2(line_length, sizeof(ContributionType))) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tres->ContribRow = (ContributionType *) gdMalloc(line_length * sizeof(ContributionType));\n\tif (res->ContribRow == NULL) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tfor (u = 0 ; u < line_length ; u++) {\n\t\tif (overflow2(windows_size, sizeof(double))) {\n\t\t\toverflow_error = 1;\n\t\t} else {\n\t\t\tres->ContribRow[u].Weights = (double *) gdMalloc(windows_size * sizeof(double));\n\t\t}\n\t\tif (overflow_error == 1 || res->ContribRow[u].Weights == NULL) {\n\t\t\tu--;\n\t\t\twhile (u >= 0) {\n\t\t\t\tgdFree(res->ContribRow[u].Weights);\n\t\t\t\tu--;\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn res;\n}", "target": 1}
{"code": "router_append_dirobj_signature(char *buf, size_t buf_len, const char *digest,\n                               size_t digest_len, crypto_pk_t *private_key)\n{\n  size_t sig_len, s_len;\n  char *sig = router_get_dirobj_signature(digest, digest_len, private_key);\n  if (!sig) {\n    log_warn(LD_BUG, \"No signature generated\");\n    return -1;\n  }\n  sig_len = strlen(sig);\n  s_len = strlen(buf);\n  if (sig_len + s_len + 1 > buf_len) {\n    log_warn(LD_BUG, \"Not enough room for signature\");\n    tor_free(sig);\n    return -1;\n  }\n  memcpy(buf+s_len, sig, sig_len+1);\n  return 0;\n}", "target": 0}
{"code": "vte_sequence_handler_fs (VteTerminal *terminal, GValueArray *params)\n{\n\tterminal->pvt->screen->status_line = FALSE;\n}", "target": 0}
{"code": "void vsock_remove_bound(struct vsock_sock *vsk)\n{\n\tspin_lock_bh(&vsock_table_lock);\n\t__vsock_remove_bound(vsk);\n\tspin_unlock_bh(&vsock_table_lock);\n}", "target": 0}
{"code": "static inline int build_open_flags(int flags, umode_t mode, struct open_flags *op)\n{\n\tint lookup_flags = 0;\n\tint acc_mode;\n\tif (flags & O_CREAT)\n\t\top->mode = (mode & S_IALLUGO) | S_IFREG;\n\telse\n\t\top->mode = 0;\n\tflags &= ~FMODE_NONOTIFY & ~O_CLOEXEC;\n\tif (flags & __O_SYNC)\n\t\tflags |= O_DSYNC;\n\tif (flags & __O_TMPFILE) {\n\t\tif ((flags & O_TMPFILE_MASK) != O_TMPFILE)\n\t\t\treturn -EINVAL;\n\t\tacc_mode = MAY_OPEN | ACC_MODE(flags);\n\t} else if (flags & O_PATH) {\n\t\tflags &= O_DIRECTORY | O_NOFOLLOW | O_PATH;\n\t\tacc_mode = 0;\n\t} else {\n\t\tacc_mode = MAY_OPEN | ACC_MODE(flags);\n\t}\n\top->open_flag = flags;\n\tif (flags & O_TRUNC)\n\t\tacc_mode |= MAY_WRITE;\n\tif (flags & O_APPEND)\n\t\tacc_mode |= MAY_APPEND;\n\top->acc_mode = acc_mode;\n\top->intent = flags & O_PATH ? 0 : LOOKUP_OPEN;\n\tif (flags & O_CREAT) {\n\t\top->intent |= LOOKUP_CREATE;\n\t\tif (flags & O_EXCL)\n\t\t\top->intent |= LOOKUP_EXCL;\n\t}\n\tif (flags & O_DIRECTORY)\n\t\tlookup_flags |= LOOKUP_DIRECTORY;\n\tif (!(flags & O_NOFOLLOW))\n\t\tlookup_flags |= LOOKUP_FOLLOW;\n\top->lookup_flags = lookup_flags;\n\treturn 0;\n}", "target": 0}
{"code": "int _gnutls_x509_verify_signature(const gnutls_datum_t * tbs,\n\t\t\t\t  const gnutls_datum_t * signature,\n\t\t\t\t  gnutls_x509_crt_t issuer)\n{\n    mpi_t issuer_params[MAX_PUBLIC_PARAMS_SIZE];\n    int ret, issuer_params_size, i;\n    issuer_params_size = MAX_PUBLIC_PARAMS_SIZE;\n    ret =\n\t_gnutls_x509_crt_get_mpis(issuer, issuer_params,\n\t\t\t\t  &issuer_params_size);\n    if (ret < 0) {\n\tgnutls_assert();\n\treturn ret;\n    }\n    ret =\n\tverify_sig(tbs, signature,\n\t\t   gnutls_x509_crt_get_pk_algorithm(issuer, NULL),\n\t\t   issuer_params, issuer_params_size);\n    if (ret < 0) {\n\tgnutls_assert();\n    }\n    for (i = 0; i < issuer_params_size; i++) {\n\t_gnutls_mpi_release(&issuer_params[i]);\n    }\n    return ret;\n}", "target": 0}
{"code": "static void lag_pred_line(LagarithContext *l, uint8_t *buf,\n                          int width, int stride, int line)\n{\n    int L, TL;\n    if (!line) {\n        int i, align_width = (width - 1) & ~31;\n        L = l->dsp.add_hfyu_left_prediction(buf + 1, buf + 1,\n                                            align_width, buf[0]);\n        for (i = align_width + 1; i < width; i++)\n            buf[i] += buf[i - 1];\n    } else {\n        L = buf[width - stride - 1];\n        if (line == 1) {\n            TL = l->avctx->pix_fmt == AV_PIX_FMT_YUV420P ? buf[-stride] : L;\n        } else {\n            TL = buf[width - (2 * stride) - 1];\n        }\n        add_lag_median_prediction(buf, buf - stride, buf,\n                                  width, &L, &TL);\n    }\n}", "target": 0}
{"code": "static struct nfs4_state *nfs4_do_open(struct inode *dir,\n\t\t\t\t\tstruct dentry *dentry,\n\t\t\t\t\tfmode_t fmode,\n\t\t\t\t\tint flags,\n\t\t\t\t\tstruct iattr *sattr,\n\t\t\t\t\tstruct rpc_cred *cred,\n\t\t\t\t\tstruct nfs4_threshold **ctx_th)\n{\n\tstruct nfs4_exception exception = { };\n\tstruct nfs4_state *res;\n\tint status;\n\tfmode &= FMODE_READ|FMODE_WRITE|FMODE_EXEC;\n\tdo {\n\t\tstatus = _nfs4_do_open(dir, dentry, fmode, flags, sattr, cred,\n\t\t\t\t       &res, ctx_th);\n\t\tif (status == 0)\n\t\t\tbreak;\n\t\tif (status == -NFS4ERR_BAD_SEQID) {\n\t\t\tpr_warn_ratelimited(\"NFS: v4 server %s \"\n\t\t\t\t\t\" returned a bad sequence-id error!\\n\",\n\t\t\t\t\tNFS_SERVER(dir)->nfs_client->cl_hostname);\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (status == -NFS4ERR_BAD_STATEID) {\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (status == -EAGAIN) {\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tres = ERR_PTR(nfs4_handle_exception(NFS_SERVER(dir),\n\t\t\t\t\tstatus, &exception));\n\t} while (exception.retry);\n\treturn res;\n}", "target": 0}
{"code": "static void __account_cfs_rq_runtime(struct cfs_rq *cfs_rq, u64 delta_exec)\n{\n\tcfs_rq->runtime_remaining -= delta_exec;\n\texpire_cfs_rq_runtime(cfs_rq);\n\tif (likely(cfs_rq->runtime_remaining > 0))\n\t\treturn;\n\tif (!assign_cfs_rq_runtime(cfs_rq) && likely(cfs_rq->curr))\n\t\tresched_curr(rq_of(cfs_rq));\n}", "target": 1}
{"code": "static int tls1_check_sig_alg(SSL *s, X509 *x, int default_nid)\n{\n    int sig_nid, use_pc_sigalgs = 0;\n    size_t i;\n    const SIGALG_LOOKUP *sigalg;\n    size_t sigalgslen;\n    if (default_nid == -1)\n        return 1;\n    sig_nid = X509_get_signature_nid(x);\n    if (default_nid)\n        return sig_nid == default_nid ? 1 : 0;\n    if (SSL_IS_TLS13(s) && s->s3.tmp.peer_cert_sigalgs != NULL) {\n        sigalgslen = s->s3.tmp.peer_cert_sigalgslen;\n        use_pc_sigalgs = 1;\n    } else {\n        sigalgslen = s->shared_sigalgslen;\n    }\n    for (i = 0; i < sigalgslen; i++) {\n        sigalg = use_pc_sigalgs\n                 ? tls1_lookup_sigalg(s->s3.tmp.peer_cert_sigalgs[i])\n                 : s->shared_sigalgs[i];\n        if (sig_nid == sigalg->sigandhash)\n            return 1;\n    }\n    return 0;\n}", "target": 1}
{"code": "static void ndpi_reset_packet_line_info(struct ndpi_packet_struct *packet) {\n  packet->parsed_lines = 0, packet->empty_line_position_set = 0, packet->host_line.ptr = NULL,\n    packet->host_line.len = 0, packet->referer_line.ptr = NULL, packet->referer_line.len = 0,\n    packet->content_line.ptr = NULL, packet->content_line.len = 0, packet->accept_line.ptr = NULL,\n    packet->accept_line.len = 0, packet->user_agent_line.ptr = NULL, packet->user_agent_line.len = 0,\n    packet->http_url_name.ptr = NULL, packet->http_url_name.len = 0, packet->http_encoding.ptr = NULL,\n    packet->http_encoding.len = 0, packet->http_transfer_encoding.ptr = NULL, packet->http_transfer_encoding.len = 0,\n    packet->http_contentlen.ptr = NULL, packet->http_contentlen.len = 0, packet->http_cookie.ptr = NULL,\n    packet->http_cookie.len = 0, packet->http_origin.len = 0, packet->http_origin.ptr = NULL,\n    packet->http_x_session_type.ptr = NULL, packet->http_x_session_type.len = 0, packet->server_line.ptr = NULL,\n    packet->server_line.len = 0, packet->http_method.ptr = NULL, packet->http_method.len = 0,\n    packet->http_response.ptr = NULL, packet->http_response.len = 0, packet->http_num_headers = 0;\n}", "target": 1}
{"code": "inline void update_rq_clock(struct rq *rq)\n{\n\tif (!rq->skip_clock_update) {\n\t\tint cpu = cpu_of(rq);\n\t\tu64 irq_time;\n\t\trq->clock = sched_clock_cpu(cpu);\n\t\tirq_time = irq_time_cpu(cpu);\n\t\tif (rq->clock - irq_time > rq->clock_task)\n\t\t\trq->clock_task = rq->clock - irq_time;\n\t\tsched_irq_time_avg_update(rq, irq_time);\n\t}\n}", "target": 1}
{"code": "void jp2_box_dump(jp2_box_t *box, FILE *out)\n{\n\tjp2_boxinfo_t *boxinfo;\n\tboxinfo = jp2_boxinfolookup(box->type);\n\tassert(boxinfo);\n\tfprintf(out, \"JP2 box: \");\n\tfprintf(out, \"type=%c%s%c (0x%08\"PRIxFAST32\"); length=%\"PRIuFAST32\"\\n\", '\"', boxinfo->name,\n\t  '\"', box->type, box->len);\n\tif (box->ops->dumpdata) {\n\t\t(*box->ops->dumpdata)(box, out);\n\t}\n}", "target": 1}
{"code": "deltas_head_destroy(struct deltas_head *deltas)\n{\n\tdeltas_head_cleanup(deltas);\n\tfree(deltas);\n}", "target": 1}
{"code": "int wsrep_sst_donate(const std::string &msg, const wsrep::gtid &current_gtid,\n                     const bool bypass) {\n  local_status.set(wsrep::server_state::s_donor);\n  const char *method = msg.data();\n  size_t method_len = strlen(method);\n  const char *data = method + method_len + 1;\n  wsp::env env(NULL);\n  if (env.error()) {\n    WSREP_ERROR(\"wsrep_sst_donate_cb(): env var ctor failed: %d\", -env.error());\n    return WSREP_CB_FAILURE;\n  }\n#if 0\n  while (!wsrep_is_SE_initialized()) {\n    sleep(1);\n    THD *applier_thd = static_cast<THD *>(recv_ctx);\n    if (applier_thd->killed == THD::KILL_CONNECTION) return WSREP_CB_FAILURE;\n  }\n#endif\n  int ret;\n  ret = sst_donate_other(method, data, current_gtid, bypass, env());\n  return (ret >= 0 ? WSREP_CB_SUCCESS : WSREP_CB_FAILURE);\n}", "target": 1}
{"code": "AP_CORE_DECLARE(void) ap_random_parent_after_fork(void)\n{\n    apr_uint16_t data;\n    apr_random_insecure_bytes(rng, &data, sizeof(data));\n}", "target": 0}
{"code": "NO_INLINE JsVar *jspeFactorDelete() {\n  JSP_ASSERT_MATCH(LEX_R_DELETE);\n  JsVar *parent = 0;\n  JsVar *a = jspeFactorMember(jspeFactor(), &parent);\n  JsVar *result = 0;\n  if (JSP_SHOULD_EXECUTE) {\n    bool ok = false;\n    if (jsvIsName(a) && !jsvIsNewChild(a)) {\n      if (!parent && jsvIsChild(execInfo.root, a))\n        parent = jsvLockAgain(execInfo.root);\n      if (jsvHasChildren(parent)) {\n        if (jsvIsArray(parent)) {\n          JsVarInt l = jsvGetArrayLength(parent);\n          jsvRemoveChild(parent, a);\n          jsvSetArrayLength(parent, l, false);\n        } else {\n          jsvRemoveChild(parent, a);\n        }\n        ok = true;\n      }\n    }\n    result = jsvNewFromBool(ok);\n  }\n  jsvUnLock2(a, parent);\n  return result;\n}", "target": 1}
{"code": "static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)\n{\n\tstruct mmu_gather tlb;\n\tstruct vm_area_struct *vma;\n\tbool ret = true;\n\tmutex_lock(&oom_lock);\n\tif (!down_read_trylock(&mm->mmap_sem)) {\n\t\tret = false;\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\tgoto unlock_oom;\n\t}\n\tif (mm_has_notifiers(mm)) {\n\t\tup_read(&mm->mmap_sem);\n\t\tschedule_timeout_idle(HZ);\n\t\tgoto unlock_oom;\n\t}\n\tif (test_bit(MMF_OOM_SKIP, &mm->flags)) {\n\t\tup_read(&mm->mmap_sem);\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\tgoto unlock_oom;\n\t}\n\ttrace_start_task_reaping(tsk->pid);\n\tset_bit(MMF_UNSTABLE, &mm->flags);\n\ttlb_gather_mmu(&tlb, mm, 0, -1);\n\tfor (vma = mm->mmap ; vma; vma = vma->vm_next) {\n\t\tif (!can_madv_dontneed_vma(vma))\n\t\t\tcontinue;\n\t\tif (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED))\n\t\t\tunmap_page_range(&tlb, vma, vma->vm_start, vma->vm_end,\n\t\t\t\t\t NULL);\n\t}\n\ttlb_finish_mmu(&tlb, 0, -1);\n\tpr_info(\"oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\",\n\t\t\ttask_pid_nr(tsk), tsk->comm,\n\t\t\tK(get_mm_counter(mm, MM_ANONPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_FILEPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_SHMEMPAGES)));\n\tup_read(&mm->mmap_sem);\n\ttrace_finish_task_reaping(tsk->pid);\nunlock_oom:\n\tmutex_unlock(&oom_lock);\n\treturn ret;\n}", "target": 1}
{"code": "unsigned lodepng_auto_choose_color(LodePNGColorMode* mode_out,\n                                   const unsigned char* image, unsigned w, unsigned h,\n                                   const LodePNGColorMode* mode_in)\n{\n  LodePNGColorProfile prof;\n  unsigned error = 0;\n  unsigned i, n, palettebits, grey_ok, palette_ok;\n  lodepng_color_profile_init(&prof);\n  error = get_color_profile(&prof, image, w, h, mode_in);\n  if(error) return error;\n  mode_out->key_defined = 0;\n  if(prof.key && w * h <= 16) prof.alpha = 1; \n  grey_ok = !prof.colored && !prof.alpha; \n  n = prof.numcolors;\n  palettebits = n <= 2 ? 1 : (n <= 4 ? 2 : (n <= 16 ? 4 : 8));\n  palette_ok = n <= 256 && (n * 2 < w * h) && prof.bits <= 8;\n  if(w * h < n * 2) palette_ok = 0; \n  if(grey_ok && prof.bits <= palettebits) palette_ok = 0; \n  if(palette_ok)\n  {\n    unsigned char* p = prof.palette;\n    lodepng_palette_clear(mode_out); \n    for(i = 0; i < prof.numcolors; i++)\n    {\n      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);\n      if(error) break;\n    }\n    mode_out->colortype = LCT_PALETTE;\n    mode_out->bitdepth = palettebits;\n    if(mode_in->colortype == LCT_PALETTE && mode_in->palettesize >= mode_out->palettesize\n        && mode_in->bitdepth == mode_out->bitdepth)\n    {\n      lodepng_color_mode_cleanup(mode_out);\n      lodepng_color_mode_copy(mode_out, mode_in);\n    }\n  }\n  else \n  {\n    mode_out->bitdepth = prof.bits;\n    mode_out->colortype = prof.alpha ? (prof.colored ? LCT_RGBA : LCT_GREY_ALPHA)\n                                     : (prof.colored ? LCT_RGB : LCT_GREY);\n    if(prof.key && !prof.alpha)\n    {\n      unsigned mask = (1u << mode_out->bitdepth) - 1u; \n      mode_out->key_r = prof.key_r & mask;\n      mode_out->key_g = prof.key_g & mask;\n      mode_out->key_b = prof.key_b & mask;\n      mode_out->key_defined = 1;\n    }\n  }\n  return error;\n}", "target": 0}
{"code": "nfs4_file_open(struct inode *inode, struct file *filp)\n{\n\tstruct nfs_open_context *ctx;\n\tstruct dentry *dentry = file_dentry(filp);\n\tstruct dentry *parent = NULL;\n\tstruct inode *dir;\n\tunsigned openflags = filp->f_flags;\n\tstruct iattr attr;\n\tint err;\n\tdprintk(\"NFS: open file(%pd2)\\n\", dentry);\n\terr = nfs_check_flags(openflags);\n\tif (err)\n\t\treturn err;\n\tif ((openflags & O_ACCMODE) == 3)\n\t\treturn nfs_open(inode, filp);\n\topenflags &= ~(O_CREAT|O_EXCL);\n\tparent = dget_parent(dentry);\n\tdir = d_inode(parent);\n\tctx = alloc_nfs_open_context(file_dentry(filp), filp->f_mode, filp);\n\terr = PTR_ERR(ctx);\n\tif (IS_ERR(ctx))\n\t\tgoto out;\n\tattr.ia_valid = ATTR_OPEN;\n\tif (openflags & O_TRUNC) {\n\t\tattr.ia_valid |= ATTR_SIZE;\n\t\tattr.ia_size = 0;\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\t}\n\tinode = NFS_PROTO(dir)->open_context(dir, ctx, openflags, &attr, NULL);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tswitch (err) {\n\t\tdefault:\n\t\t\tgoto out_put_ctx;\n\t\tcase -ENOENT:\n\t\tcase -ESTALE:\n\t\tcase -EISDIR:\n\t\tcase -ENOTDIR:\n\t\tcase -ELOOP:\n\t\t\tgoto out_drop;\n\t\t}\n\t}\n\tif (inode != d_inode(dentry))\n\t\tgoto out_drop;\n\tnfs_file_set_open_context(filp, ctx);\n\tnfs_fscache_open_file(inode, filp);\n\terr = 0;\nout_put_ctx:\n\tput_nfs_open_context(ctx);\nout:\n\tdput(parent);\n\treturn err;\nout_drop:\n\td_drop(dentry);\n\terr = -EOPENSTALE;\n\tgoto out_put_ctx;\n}", "target": 1}
{"code": "name_to_backref_error(VALUE name)\n{\n    rb_raise(rb_eIndexError, \"undefined group name reference: % \"PRIsVALUE,\n\t     name);\n}", "target": 0}
{"code": "BufferedRandomDevice::BufferedRandomDevice(size_t bufferSize)\n  : bufferSize_(bufferSize),\n    buffer_(new unsigned char[bufferSize]),\n    ptr_(buffer_.get() + bufferSize) {  \n  call_once(flag, [this]() {\n    detail::AtFork::registerHandler(\n        this,\n         []() { return true; },\n         []() {},\n        []() {\n          using Single = SingletonThreadLocal<BufferedRandomDevice, RandomTag>;\n          auto& t = Single::get();\n          t.ptr_ = t.buffer_.get() + t.bufferSize_;\n        });\n  });\n}", "target": 0}
{"code": "compileWarning(FileInfo *nested, char *format, ...) {\n#ifndef __SYMBIAN32__\n\tchar buffer[MAXSTRING];\n\tva_list arguments;\n\tva_start(arguments, format);\n\tvsnprintf(buffer, sizeof(buffer), format, arguments);\n\tva_end(arguments);\n\tif (nested)\n\t\t_lou_logMessage(LOG_WARN, \"%s:%d: warning: %s\", nested->fileName,\n\t\t\t\tnested->lineNumber, buffer);\n\telse\n\t\t_lou_logMessage(LOG_WARN, \"warning: %s\", buffer);\n\twarningCount++;\n#endif\n}", "target": 0}
{"code": "struct file_list *flist_for_ndx(int ndx, const char *fatal_error_loc)\n{\n\tstruct file_list *flist = cur_flist;\n\tif (!flist && !(flist = first_flist))\n\t\tgoto not_found;\n\twhile (ndx < flist->ndx_start-1) {\n\t\tif (flist == first_flist)\n\t\t\tgoto not_found;\n\t\tflist = flist->prev;\n\t}\n\twhile (ndx >= flist->ndx_start + flist->used) {\n\t\tif (!(flist = flist->next))\n\t\t\tgoto not_found;\n\t}\n\treturn flist;\n  not_found:\n\tif (fatal_error_loc) {\n\t\tint first, last;\n\t\tif (first_flist) {\n\t\t\tfirst = first_flist->ndx_start - 1;\n\t\t\tlast = first_flist->prev->ndx_start + first_flist->prev->used - 1;\n\t\t} else {\n\t\t\tfirst = 0;\n\t\t\tlast = -1;\n\t\t}\n\t\trprintf(FERROR,\n\t\t\t\"File-list index %d not in %d - %d (%s) [%s]\\n\",\n\t\t\tndx, first, last, fatal_error_loc, who_am_i());\n\t\texit_cleanup(RERR_PROTOCOL);\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "gopherCachable(const HttpRequest * req)\n{\n    int cachable = 1;\n    char type_id;\n    gopher_request_parse(req,\n                         &type_id,\n                         nullptr);\n    switch (type_id) {\n    case GOPHER_INDEX:\n    case GOPHER_CSO:\n    case GOPHER_TELNET:\n    case GOPHER_3270:\n        cachable = 0;\n        break;\n    default:\n        cachable = 1;\n    }\n    return cachable;\n}", "target": 1}
{"code": "write_config_option_secret (int fd, const char *key, const char *value)\n{\n\tgs_free char *string = NULL;\n\tint x;\n\tstring = g_strdup_printf (\"%s %s\\n\", key, value);\n\tx = write (fd, string, strlen (string));\n\tif (x < 0)\n\t\t_LOGW (\"Unexpected error in write(): %d\", errno);\n\t_LOGD (\"Config: %s <hidden>\", key);\n}", "target": 0}
{"code": "void build_ntlmssp_negotiate_blob(unsigned char *pbuffer,\n\t\t\t\t\t struct cifs_ses *ses)\n{\n\tNEGOTIATE_MESSAGE *sec_blob = (NEGOTIATE_MESSAGE *)pbuffer;\n\t__u32 flags;\n\tmemset(pbuffer, 0, sizeof(NEGOTIATE_MESSAGE));\n\tmemcpy(sec_blob->Signature, NTLMSSP_SIGNATURE, 8);\n\tsec_blob->MessageType = NtLmNegotiate;\n\tflags = NTLMSSP_NEGOTIATE_56 |\tNTLMSSP_REQUEST_TARGET |\n\t\tNTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |\n\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;\n\tif (ses->server->sign) {\n\t\tflags |= NTLMSSP_NEGOTIATE_SIGN;\n\t\tif (!ses->server->session_estab ||\n\t\t\t\tses->ntlmssp->sesskey_per_smbsess)\n\t\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n\t}\n\tsec_blob->NegotiateFlags = cpu_to_le32(flags);\n\tsec_blob->WorkstationName.BufferOffset = 0;\n\tsec_blob->WorkstationName.Length = 0;\n\tsec_blob->WorkstationName.MaximumLength = 0;\n\tsec_blob->DomainName.BufferOffset = 0;\n\tsec_blob->DomainName.Length = 0;\n\tsec_blob->DomainName.MaximumLength = 0;\n}", "target": 1}
{"code": "pango_glyph_string_set_size (PangoGlyphString *string, gint new_len)\n{\n  g_return_if_fail (new_len >= 0);\n  while (new_len > string->space)\n    {\n      if (string->space == 0)\n\tstring->space = 1;\n      else\n\tstring->space *= 2;\n      if (string->space < 0)\n\t{\n\t  g_warning (\"glyph string length overflows maximum integer size, truncated\");\n\t  new_len = string->space = G_MAXINT - 8;\n\t}\n    }\n  string->glyphs = g_realloc (string->glyphs, string->space * sizeof (PangoGlyphInfo));\n  string->log_clusters = g_realloc (string->log_clusters, string->space * sizeof (gint));\n  string->num_glyphs = new_len;\n}", "target": 1}
{"code": "    std::string RafImage::mimeType() const\n    {\n        return \"image/x-fuji-raf\";\n    }", "target": 0}
{"code": "int dns_add_HTTPS_start(struct dns_rr_nested *svcparam_buffer, struct dns_packet *packet, dns_rr_type type,\n\t\t\t\t\t\tconst char *domain, int ttl, int priority, const char *target)\n{\n\tsvcparam_buffer = dns_add_rr_nested_start(svcparam_buffer, packet, type, DNS_T_HTTPS, domain, ttl);\n\tif (svcparam_buffer == NULL) {\n\t\treturn -1;\n\t}\n\tint target_len = strnlen(target, DNS_MAX_CNAME_LEN) + 1;\n\tif (_dns_left_len(&svcparam_buffer->context) < 2 + target_len) {\n\t\treturn -1;\n\t}\n\t_dns_write_short(&svcparam_buffer->context.ptr, priority);\n\tsafe_strncpy((char *)svcparam_buffer->context.ptr, target, target_len);\n\tsvcparam_buffer->context.ptr += target_len;\n\treturn 0;\n}", "target": 1}
{"code": "createenv(const struct rule *rule)\n{\n\tstruct env *env;\n\tu_int i;\n\tenv = malloc(sizeof(*env));\n\tif (!env)\n\t\terr(1, NULL);\n\tRB_INIT(&env->root);\n\tenv->count = 0;\n\tif (rule->options & KEEPENV) {\n\t\textern char **environ;\n\t\tfor (i = 0; environ[i] != NULL; i++) {\n\t\t\tstruct envnode *node;\n\t\t\tconst char *e, *eq;\n\t\t\tsize_t len;\n\t\t\tchar keybuf[1024];\n\t\t\te = environ[i];\n\t\t\tif ((eq = strchr(e, '=')) == NULL || eq == e)\n\t\t\t\tcontinue;\n\t\t\tlen = eq - e;\n\t\t\tif (len > sizeof(keybuf) - 1)\n\t\t\t\tcontinue;\n\t\t\tmemcpy(keybuf, e, len);\n\t\t\tkeybuf[len] = '\\0';\n\t\t\tnode = createnode(keybuf, eq + 1);\n\t\t\tif (RB_INSERT(envtree, &env->root, node)) {\n\t\t\t\tfreenode(node);\n\t\t\t} else {\n\t\t\t\tenv->count++;\n\t\t\t}\n\t\t}\n\t}\n\treturn env;\n}", "target": 1}
{"code": "init_ccline(int firstc, int indent)\n{\n    ccline.overstrike = FALSE;\t\t    \n    ccline.cmdfirstc = (firstc == '@' ? 0 : firstc);\n    ccline.cmdindent = (firstc > 0 ? indent : 0);\n    alloc_cmdbuff(exmode_active ? 250 : indent + 1);\n    if (ccline.cmdbuff == NULL)\n\treturn FAIL;\n    ccline.cmdlen = ccline.cmdpos = 0;\n    ccline.cmdbuff[0] = NUL;\n    sb_text_start_cmdline();\n    if (firstc <= 0)\n    {\n\tvim_memset(ccline.cmdbuff, ' ', indent);\n\tccline.cmdbuff[indent] = NUL;\n\tccline.cmdpos = indent;\n\tccline.cmdspos = indent;\n\tccline.cmdlen = indent;\n    }\n    return OK;\n}", "target": 1}
{"code": "void GfxPath::lineTo(double x, double y)\n{\n    if (justMoved || (n > 0 && subpaths[n - 1]->isClosed())) {\n        if (n >= size) {\n            size *= 2;\n            subpaths = (GfxSubpath **)greallocn(subpaths, size, sizeof(GfxSubpath *));\n        }\n        if (justMoved) {\n            subpaths[n] = new GfxSubpath(firstX, firstY);\n        } else {\n            subpaths[n] = new GfxSubpath(subpaths[n - 1]->getLastX(), subpaths[n - 1]->getLastY());\n        }\n        ++n;\n        justMoved = false;\n    }\n    subpaths[n - 1]->lineTo(x, y);\n}", "target": 0}
{"code": "order_notification_deltas(struct rdr_notification_ctx *ctx)\n{\n\tstruct delta_head **ptr;\n\tarray_index i;\n\tint error;\n\terror = deltas_head_set_size(ctx->notification->deltas_list,\n\t    ctx->deltas.len);\n\tif (error)\n\t\treturn error;\n\tARRAYLIST_FOREACH(&ctx->deltas, ptr, i) {\n\t\terror = deltas_head_add(ctx->notification->deltas_list,\n\t\t    ctx->notification->global_data.serial,\n\t\t    (*ptr)->serial,\n\t\t    (*ptr)->doc_data.uri,\n\t\t    (*ptr)->doc_data.hash,\n\t\t    (*ptr)->doc_data.hash_len);\n\t\tif (!error)\n\t\t\tcontinue;\n\t\tif (error == -EINVAL)\n\t\t\treturn pr_val_err(\"Serial '%lu' at delta elements isn't part of a contiguous list of serials.\",\n\t\t\t    (*ptr)->serial);\n\t\tif (error == -EEXIST)\n\t\t\treturn pr_val_err(\"Duplicated serial '%lu' at delta elements.\",\n\t\t\t    (*ptr)->serial);\n\t\treturn error;\n\t}\n\tif (!deltas_head_values_set(ctx->notification->deltas_list))\n\t\treturn pr_val_err(\"Deltas listed don't have a contiguous sequence of serial numbers\");\n\treturn 0;\n}", "target": 1}
{"code": "long do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t *info)\n{\n\tif (pid <= 0 || tgid <= 0)\n\t\treturn -EINVAL;\n\tif (info->si_code >= 0)\n\t\treturn -EPERM;\n\tinfo->si_signo = sig;\n\treturn do_send_specific(tgid, pid, sig, info);\n}", "target": 1}
{"code": "static int get_vmx_mem_address(struct kvm_vcpu *vcpu,\n\t\t\t\t unsigned long exit_qualification,\n\t\t\t\t u32 vmx_instruction_info, gva_t *ret)\n{\n\tint  scaling = vmx_instruction_info & 3;\n\tint  addr_size = (vmx_instruction_info >> 7) & 7;\n\tbool is_reg = vmx_instruction_info & (1u << 10);\n\tint  seg_reg = (vmx_instruction_info >> 15) & 7;\n\tint  index_reg = (vmx_instruction_info >> 18) & 0xf;\n\tbool index_is_valid = !(vmx_instruction_info & (1u << 22));\n\tint  base_reg       = (vmx_instruction_info >> 23) & 0xf;\n\tbool base_is_valid  = !(vmx_instruction_info & (1u << 27));\n\tif (is_reg) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\t*ret = vmx_get_segment_base(vcpu, seg_reg);\n\tif (base_is_valid)\n\t\t*ret += kvm_register_read(vcpu, base_reg);\n\tif (index_is_valid)\n\t\t*ret += kvm_register_read(vcpu, index_reg)<<scaling;\n\t*ret += exit_qualification; \n\tif (addr_size == 1) \n\t\t*ret &= 0xffffffff;\n\treturn 0;\n}", "target": 0}
{"code": "krb5_encode_histkey(osa_princ_ent_rec *princ_ent)\n{\n    unsigned int i;\n    krb5_error_code err = 0;\n    struct berval **ret = NULL;\n    if (princ_ent->old_key_len <= 0)\n        return NULL;\n    ret = k5calloc(princ_ent->old_key_len + 1, sizeof(struct berval *), &err);\n    if (ret == NULL)\n        goto cleanup;\n    for (i = 0; i < princ_ent->old_key_len; i++) {\n        if (princ_ent->old_keys[i].n_key_data <= 0) {\n            err = EINVAL;\n            goto cleanup;\n        }\n        err = encode_keys(princ_ent->old_keys[i].key_data,\n                          princ_ent->old_keys[i].n_key_data,\n                          princ_ent->admin_history_kvno, &ret[i]);\n        if (err)\n            goto cleanup;\n    }\n    ret[princ_ent->old_key_len] = NULL;\ncleanup:\n    if (err != 0) {\n        free_berdata(ret);\n        ret = NULL;\n    }\n    return ret;\n}", "target": 0}
{"code": "std_term_source(j_decompress_ptr cinfo)\n{\n\t(void) cinfo;\n}", "target": 0}
{"code": "void ssl_set_client_disabled(SSL *s)\n\t{\n\tCERT *c = s->cert;\n\tconst unsigned char *sigalgs;\n\tsize_t i, sigalgslen;\n\tint have_rsa = 0, have_dsa = 0, have_ecdsa = 0;\n\tc->mask_a = 0;\n\tc->mask_k = 0;\n\tif (!SSL_CLIENT_USE_TLS1_2_CIPHERS(s))\n\t\tc->mask_ssl = SSL_TLSV1_2;\n\telse\n\t\tc->mask_ssl = 0;\n\tsigalgslen = tls12_get_psigalgs(s, &sigalgs);\n\tfor (i = 0; i < sigalgslen; i += 2, sigalgs += 2)\n\t\t{\n\t\tswitch(sigalgs[1])\n\t\t\t{\n#ifndef OPENSSL_NO_RSA\n\t\tcase TLSEXT_signature_rsa:\n\t\t\thave_rsa = 1;\n\t\t\tbreak;\n#endif\n#ifndef OPENSSL_NO_DSA\n\t\tcase TLSEXT_signature_dsa:\n\t\t\thave_dsa = 1;\n\t\t\tbreak;\n#endif\n#ifndef OPENSSL_NO_ECDSA\n\t\tcase TLSEXT_signature_ecdsa:\n\t\t\thave_ecdsa = 1;\n\t\t\tbreak;\n#endif\n\t\t\t}\n\t\t}\n\tif (!have_rsa)\n\t\t{\n\t\tc->mask_a |= SSL_aRSA;\n\t\tc->mask_k |= SSL_kDHr|SSL_kECDHr;\n\t\t}\n\tif (!have_dsa)\n\t\t{\n\t\tc->mask_a |= SSL_aDSS;\n\t\tc->mask_k |= SSL_kDHd;\n\t\t}\n\tif (!have_ecdsa)\n\t\t{\n\t\tc->mask_a |= SSL_aECDSA;\n\t\tc->mask_k |= SSL_kECDHe;\n\t\t}\n#ifndef OPENSSL_NO_KRB5\n\tif (!kssl_tgt_is_available(s->kssl_ctx))\n\t\t{\n\t\tc->mask_a |= SSL_aKRB5;\n\t\tc->mask_k |= SSL_kKRB5;\n\t\t}\n#endif\n#ifndef OPENSSL_NO_PSK\n\tif (!s->psk_client_callback)\n\t\t{\n\t\tc->mask_a |= SSL_aPSK;\n\t\tc->mask_k |= SSL_kPSK;\n\t\t}\n#endif \n\tc->valid = 1;\n\t}", "target": 0}
{"code": "int __nla_parse(struct nlattr **tb, int maxtype,\n\t\tconst struct nlattr *head, int len,\n\t\tconst struct nla_policy *policy, unsigned int validate,\n\t\tstruct netlink_ext_ack *extack)\n{\n\treturn __nla_validate_parse(head, len, maxtype, policy, validate,\n\t\t\t\t    extack, tb);\n}", "target": 1}
{"code": "static void tcp_send_challenge_ack(struct sock *sk, const struct sk_buff *skb)\n{\n\tstatic u32 challenge_timestamp;\n\tstatic unsigned int challenge_count;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 now;\n\tif (tcp_oow_rate_limited(sock_net(sk), skb,\n\t\t\t\t LINUX_MIB_TCPACKSKIPPEDCHALLENGE,\n\t\t\t\t &tp->last_oow_ack_time))\n\t\treturn;\n\tnow = jiffies / HZ;\n\tif (now != challenge_timestamp) {\n\t\tchallenge_timestamp = now;\n\t\tchallenge_count = 0;\n\t}\n\tif (++challenge_count <= sysctl_tcp_challenge_ack_limit) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPCHALLENGEACK);\n\t\ttcp_send_ack(sk);\n\t}\n}", "target": 1}
{"code": "static int orinoco_ioctl_setpower(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  struct iw_param *prq,\n\t\t\t\t  char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint err = -EINPROGRESS;\t\t\n\tunsigned long flags;\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\tif (prq->disabled) {\n\t\tpriv->pm_on = 0;\n\t} else {\n\t\tswitch (prq->flags & IW_POWER_MODE) {\n\t\tcase IW_POWER_UNICAST_R:\n\t\t\tpriv->pm_mcast = 0;\n\t\t\tpriv->pm_on = 1;\n\t\t\tbreak;\n\t\tcase IW_POWER_ALL_R:\n\t\t\tpriv->pm_mcast = 1;\n\t\t\tpriv->pm_on = 1;\n\t\t\tbreak;\n\t\tcase IW_POWER_ON:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (prq->flags & IW_POWER_TIMEOUT) {\n\t\t\tpriv->pm_on = 1;\n\t\t\tpriv->pm_timeout = prq->value / 1000;\n\t\t}\n\t\tif (prq->flags & IW_POWER_PERIOD) {\n\t\t\tpriv->pm_on = 1;\n\t\t\tpriv->pm_period = prq->value / 1000;\n\t\t}\n\t\tif (!priv->pm_on) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n out:\n\torinoco_unlock(priv, &flags);\n\treturn err;\n}", "target": 0}
{"code": "static unsigned int help(struct sk_buff *skb,\n\t\t\t enum ip_conntrack_info ctinfo,\n\t\t\t unsigned int protoff,\n\t\t\t unsigned int matchoff,\n\t\t\t unsigned int matchlen,\n\t\t\t struct nf_conntrack_expect *exp)\n{\n\tchar buffer[sizeof(\"4294967296 65635\")];\n\tu_int16_t port;\n\tunsigned int ret;\n\texp->saved_proto.tcp.port = exp->tuple.dst.u.tcp.port;\n\texp->dir = IP_CT_DIR_REPLY;\n\texp->expectfn = nf_nat_follow_master;\n\tfor (port = ntohs(exp->saved_proto.tcp.port); port != 0; port++) {\n\t\tint ret;\n\t\texp->tuple.dst.u.tcp.port = htons(port);\n\t\tret = nf_ct_expect_related(exp);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\telse if (ret != -EBUSY) {\n\t\t\tport = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (port == 0) {\n\t\tnf_ct_helper_log(skb, exp->master, \"all ports in use\");\n\t\treturn NF_DROP;\n\t}\n\tret = nf_nat_mangle_tcp_packet(skb, exp->master, ctinfo,\n\t\t\t\t       protoff, matchoff, matchlen, buffer,\n\t\t\t\t       strlen(buffer));\n\tif (ret != NF_ACCEPT) {\n\t\tnf_ct_helper_log(skb, exp->master, \"cannot mangle packet\");\n\t\tnf_ct_unexpect_related(exp);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static int jpc_qcd_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_qcd_t *qcd = &ms->parms.qcd;\n\tint i;\n\tfprintf(out, \"qntsty = %d; numguard = %d; numstepsizes = %d\\n\",\n\t  (int) qcd->compparms.qntsty, qcd->compparms.numguard, qcd->compparms.numstepsizes);\n\tfor (i = 0; i < qcd->compparms.numstepsizes; ++i) {\n\t\tfprintf(out, \"expn[%d] = 0x%04x; mant[%d] = 0x%04x;\\n\",\n\t\t  i, (unsigned) JPC_QCX_GETEXPN(qcd->compparms.stepsizes[i]),\n\t\t  i, (unsigned) JPC_QCX_GETMANT(qcd->compparms.stepsizes[i]));\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "GF_Err CoLL_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_VPContentLightLevelBox *p = (GF_VPContentLightLevelBox*)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u16(bs, p->maxCLL);\n\tgf_bs_write_u16(bs, p->maxFALL);\n\treturn GF_OK;\n}", "target": 0}
{"code": "ref_param_read_float_array(gs_param_list * plist, gs_param_name pkey,\n                           gs_param_float_array * pvalue)\n{\n    iparam_list *const iplist = (iparam_list *) plist;\n    iparam_loc loc;\n    ref aref, elt;\n    int code = ref_param_read_array(iplist, pkey, &loc);\n    float *pfv;\n    uint size;\n    long i;\n    if (code != 0)\n        return code;\n    size = r_size(loc.pvalue);\n    pfv = (float *)gs_alloc_byte_array(plist->memory, size, sizeof(float),\n                                       \"ref_param_read_float_array\");\n    if (pfv == 0)\n        return_error(gs_error_VMerror);\n    aref = *loc.pvalue;\n    loc.pvalue = &elt;\n    for (i = 0; code >= 0 && i < size; i++) {\n        array_get(plist->memory, &aref, i, &elt);\n        code = float_param(&elt, pfv + i);\n    }\n    if (code < 0) {\n        gs_free_object(plist->memory, pfv, \"ref_read_float_array_param\");\n        return (*loc.presult = code);\n    }\n    pvalue->data = pfv;\n    pvalue->size = size;\n    pvalue->persistent = true;\n    return 0;\n}", "target": 0}
{"code": "static int snd_usb_accessmusic_boot_quirk(struct usb_device *dev)\n{\n\tint err, actual_length;\n\tstatic const u8 seq[] = { 0x4e, 0x73, 0x52, 0x01 };\n\tvoid *buf = kmemdup(seq, ARRAY_SIZE(seq), GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\terr = usb_interrupt_msg(dev, usb_sndintpipe(dev, 0x05), buf,\n\t\t\tARRAY_SIZE(seq), &actual_length, 1000);\n\tkfree(buf);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}", "target": 0}
{"code": "sctp_disposition_t sctp_sf_ootb(struct net *net,\n\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\tvoid *arg,\n\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sk_buff *skb = chunk->skb;\n\tsctp_chunkhdr_t *ch;\n\tsctp_errhdr_t *err;\n\t__u8 *ch_end;\n\tint ootb_shut_ack = 0;\n\tint ootb_cookie_ack = 0;\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\tch = (sctp_chunkhdr_t *) chunk->chunk_hdr;\n\tdo {\n\t\tif (ntohs(ch->length) < sizeof(sctp_chunkhdr_t))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\t\tif (SCTP_CID_SHUTDOWN_ACK == ch->type)\n\t\t\tootb_shut_ack = 1;\n\t\tif (SCTP_CID_ABORT == ch->type)\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\tif (SCTP_CID_COOKIE_ACK == ch->type)\n\t\t\tootb_cookie_ack = 1;\n\t\tif (SCTP_CID_ERROR == ch->type) {\n\t\t\tsctp_walk_errors(err, ch) {\n\t\t\t\tif (SCTP_ERROR_STALE_COOKIE == err->cause) {\n\t\t\t\t\tootb_cookie_ack = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tch_end = ((__u8 *)ch) + SCTP_PAD4(ntohs(ch->length));\n\t\tif (ch_end > skb_tail_pointer(skb))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\t\tch = (sctp_chunkhdr_t *) ch_end;\n\t} while (ch_end < skb_tail_pointer(skb));\n\tif (ootb_shut_ack)\n\t\treturn sctp_sf_shut_8_4_5(net, ep, asoc, type, arg, commands);\n\telse if (ootb_cookie_ack)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\telse\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n}", "target": 1}
{"code": "xmlParseCheckTransition(xmlParserCtxtPtr ctxt, const char *chunk, int size) {\n    if ((ctxt == NULL) || (chunk == NULL) || (size < 0))\n        return(-1);\n    if (ctxt->instate == XML_PARSER_START_TAG) {\n        if (memchr(chunk, '>', size) != NULL)\n            return(1);\n        return(0);\n    }\n    if (ctxt->progressive == XML_PARSER_COMMENT) {\n        if (memchr(chunk, '>', size) != NULL)\n            return(1);\n        return(0);\n    }\n    if (ctxt->instate == XML_PARSER_CDATA_SECTION) {\n        if (memchr(chunk, '>', size) != NULL)\n            return(1);\n        return(0);\n    }\n    if (ctxt->progressive == XML_PARSER_PI) {\n        if (memchr(chunk, '>', size) != NULL)\n            return(1);\n        return(0);\n    }\n    if (ctxt->instate == XML_PARSER_END_TAG) {\n        if (memchr(chunk, '>', size) != NULL)\n            return(1);\n        return(0);\n    }\n    if ((ctxt->progressive == XML_PARSER_DTD) ||\n        (ctxt->instate == XML_PARSER_DTD)) {\n        if (memchr(chunk, '>', size) != NULL)\n            return(1);\n        return(0);\n    }\n    return(1);\n}", "target": 0}
{"code": "cdf_timespec_to_timestamp(cdf_timestamp_t *t, const struct timeval *ts)\n{\n#ifndef __lint__\n\t(void)&t;\n\t(void)&ts;\n#endif\n#ifdef notyet\n\tstruct tm tm;\n\tif (gmtime_r(&ts->ts_sec, &tm) == NULL) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\t*t = (ts->ts_usec / CDF_TIME_PREC) * CDF_TIME_PREC;\n\t*t = tm.tm_sec;\n\t*t += tm.tm_min * 60;\n\t*t += tm.tm_hour * 60 * 60;\n\t*t += tm.tm_mday * 60 * 60 * 24;\n#endif\n\treturn 0;\n}", "target": 0}
{"code": "cmsBool  CMSEXPORT cmsAppendNamedColor(cmsNAMEDCOLORLIST* NamedColorList,\n                                       const char* Name,\n                                       cmsUInt16Number PCS[3], cmsUInt16Number Colorant[cmsMAXCHANNELS])\n{\n    cmsUInt32Number i;\n    if (NamedColorList == NULL) return FALSE;\n    if (NamedColorList ->nColors + 1 > NamedColorList ->Allocated) {\n        if (!GrowNamedColorList(NamedColorList)) return FALSE;\n    }\n    for (i=0; i < NamedColorList ->ColorantCount; i++)\n        NamedColorList ->List[NamedColorList ->nColors].DeviceColorant[i] = Colorant == NULL? 0 : Colorant[i];\n    for (i=0; i < 3; i++)\n        NamedColorList ->List[NamedColorList ->nColors].PCS[i] = PCS == NULL ? 0 : PCS[i];\n    if (Name != NULL) {\n        strncpy(NamedColorList ->List[NamedColorList ->nColors].Name, Name,\n                    sizeof(NamedColorList ->List[NamedColorList ->nColors].Name));\n        NamedColorList ->List[NamedColorList ->nColors].Name[cmsMAX_PATH-1] = 0;\n    }\n    else\n        NamedColorList ->List[NamedColorList ->nColors].Name[0] = 0;\n    NamedColorList ->nColors++;\n    return TRUE;\n}", "target": 1}
{"code": "sudo_auth_cleanup(const struct sudoers_context *ctx, struct passwd *pw,\n    bool force)\n{\n    sudo_auth *auth;\n    debug_decl(sudo_auth_cleanup, SUDOERS_DEBUG_AUTH);\n    for (auth = auth_switch; auth->name; auth++) {\n\tif (auth->cleanup && !IS_DISABLED(auth)) {\n\t    int status = (auth->cleanup)(ctx, pw, auth, force);\n\t    if (status == AUTH_ERROR) {\n\t\tdebug_return_int(-1);\n\t    }\n\t}\n    }\n    debug_return_int(0);\n}", "target": 1}
{"code": "int nfc_stop_poll(struct nfc_dev *dev)\n{\n\tint rc = 0;\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (!dev->polling) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\tdev->ops->stop_poll(dev);\n\tdev->polling = false;\n\tdev->rf_mode = NFC_RF_NONE;\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "static int register_queue_kobjects(struct net_device *dev)\n{\n\tint error = 0, txq = 0, rxq = 0, real_rx = 0, real_tx = 0;\n#ifdef CONFIG_SYSFS\n\tdev->queues_kset = kset_create_and_add(\"queues\",\n\t\t\t\t\t       NULL, &dev->dev.kobj);\n\tif (!dev->queues_kset)\n\t\treturn -ENOMEM;\n\treal_rx = dev->real_num_rx_queues;\n#endif\n\treal_tx = dev->real_num_tx_queues;\n\terror = net_rx_queue_update_kobjects(dev, 0, real_rx);\n\tif (error)\n\t\tgoto error;\n\trxq = real_rx;\n\terror = netdev_queue_update_kobjects(dev, 0, real_tx);\n\tif (error)\n\t\tgoto error;\n\ttxq = real_tx;\n\treturn 0;\nerror:\n\tnetdev_queue_update_kobjects(dev, txq, 0);\n\tnet_rx_queue_update_kobjects(dev, rxq, 0);\n\treturn error;", "target": 1}
{"code": "int expand_downwards(struct vm_area_struct *vma,\n\t\t\t\t   unsigned long address)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct vm_area_struct *prev;\n\tint error;\n\taddress &= PAGE_MASK;\n\terror = security_mmap_addr(address);\n\tif (error)\n\t\treturn error;\n\tprev = vma->vm_prev;\n\tif (prev && !(prev->vm_flags & VM_GROWSDOWN) &&\n\t\t\t(prev->vm_flags & (VM_WRITE|VM_READ|VM_EXEC))) {\n\t\tif (address - prev->vm_end < stack_guard_gap)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\treturn -ENOMEM;\n\tanon_vma_lock_write(vma->anon_vma);\n\tif (address < vma->vm_start) {\n\t\tunsigned long size, grow;\n\t\tsize = vma->vm_end - address;\n\t\tgrow = (vma->vm_start - address) >> PAGE_SHIFT;\n\t\terror = -ENOMEM;\n\t\tif (grow <= vma->vm_pgoff) {\n\t\t\terror = acct_stack_growth(vma, size, grow);\n\t\t\tif (!error) {\n\t\t\t\tspin_lock(&mm->page_table_lock);\n\t\t\t\tif (vma->vm_flags & VM_LOCKED)\n\t\t\t\t\tmm->locked_vm += grow;\n\t\t\t\tvm_stat_account(mm, vma->vm_flags, grow);\n\t\t\t\tanon_vma_interval_tree_pre_update_vma(vma);\n\t\t\t\tvma->vm_start = address;\n\t\t\t\tvma->vm_pgoff -= grow;\n\t\t\t\tanon_vma_interval_tree_post_update_vma(vma);\n\t\t\t\tvma_gap_update(vma);\n\t\t\t\tspin_unlock(&mm->page_table_lock);\n\t\t\t\tperf_event_mmap(vma);\n\t\t\t}\n\t\t}\n\t}\n\tanon_vma_unlock_write(vma->anon_vma);\n\tkhugepaged_enter_vma_merge(vma, vma->vm_flags);\n\tvalidate_mm(mm);\n\treturn error;\n}", "target": 1}
{"code": "long keyctl_instantiate_key_common(key_serial_t id,\n\t\t\t\t   const struct iovec *payload_iov,\n\t\t\t\t   unsigned ioc,\n\t\t\t\t   size_t plen,\n\t\t\t\t   key_serial_t ringid)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct request_key_auth *rka;\n\tstruct key *instkey, *dest_keyring;\n\tvoid *payload;\n\tlong ret;\n\tbool vm = false;\n\tkenter(\"%d,,%zu,%d\", id, plen, ringid);\n\tret = -EINVAL;\n\tif (plen > 1024 * 1024 - 1)\n\t\tgoto error;\n\tret = -EPERM;\n\tinstkey = cred->request_key_auth;\n\tif (!instkey)\n\t\tgoto error;\n\trka = instkey->payload.data;\n\tif (rka->target_key->serial != id)\n\t\tgoto error;\n\tpayload = NULL;\n\tif (payload_iov) {\n\t\tret = -ENOMEM;\n\t\tpayload = kmalloc(plen, GFP_KERNEL);\n\t\tif (!payload) {\n\t\t\tif (plen <= PAGE_SIZE)\n\t\t\t\tgoto error;\n\t\t\tvm = true;\n\t\t\tpayload = vmalloc(plen);\n\t\t\tif (!payload)\n\t\t\t\tgoto error;\n\t\t}\n\t\tret = copy_from_user_iovec(payload, payload_iov, ioc);\n\t\tif (ret < 0)\n\t\t\tgoto error2;\n\t}\n\tret = get_instantiation_keyring(ringid, rka, &dest_keyring);\n\tif (ret < 0)\n\t\tgoto error2;\n\tret = key_instantiate_and_link(rka->target_key, payload, plen,\n\t\t\t\t       dest_keyring, instkey);\n\tkey_put(dest_keyring);\n\tif (ret == 0)\n\t\tkeyctl_change_reqkey_auth(NULL);\nerror2:\n\tif (!vm)\n\t\tkfree(payload);\n\telse\n\t\tvfree(payload);\nerror:\n\treturn ret;\n}", "target": 0}
{"code": "DSA_PrivateKey::create_signature_op(RandomNumberGenerator& ,\n                                    const std::string& params,\n                                    const std::string& provider) const\n   {\n   if(provider == \"base\" || provider.empty())\n      return std::unique_ptr<PK_Ops::Signature>(new DSA_Signature_Operation(*this, params));\n   throw Provider_Not_Found(algo_name(), provider);\n   }", "target": 1}
{"code": "void Statement::Work_AfterReset(napi_env e, napi_status status, void* data) {\n    std::unique_ptr<Baton> baton(static_cast<Baton*>(data));\n    Statement* stmt = baton->stmt;\n    Napi::Env env = stmt->Env();\n    Napi::HandleScope scope(env);\n    Napi::Function cb = baton->callback.Value();\n    if (!cb.IsUndefined() && cb.IsFunction()) {\n        Napi::Value argv[] = { env.Null() };\n        TRY_CATCH_CALL(stmt->Value(), cb, 1, argv);\n    }\n    STATEMENT_END();\n}", "target": 0}
{"code": "TEST_F(SecretManagerImplTest, DeprecatedSanMatcher) {\n  envoy::extensions::transport_sockets::tls::v3::Secret secret_config;\n  const std::string yaml =\n      R\"EOF(\n      name: \"abc.com\"\n      validation_context:\n        trusted_ca: { filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\" }\n        allow_expired_certificate: true\n        match_subject_alt_names:\n          exact: \"example.foo\"\n      )EOF\";\n  TestUtility::loadFromYaml(TestEnvironment::substitute(yaml), secret_config);\n  std::unique_ptr<SecretManager> secret_manager(new SecretManagerImpl(config_tracker_));\n  secret_manager->addStaticSecret(secret_config);\n  ASSERT_EQ(secret_manager->findStaticCertificateValidationContextProvider(\"undefined\"), nullptr);\n  ASSERT_NE(secret_manager->findStaticCertificateValidationContextProvider(\"abc.com\"), nullptr);\n  Ssl::CertificateValidationContextConfigImpl cvc_config(\n      *secret_manager->findStaticCertificateValidationContextProvider(\"abc.com\")->secret(), *api_);\n  EXPECT_EQ(cvc_config.subjectAltNameMatchers().size(), 4);\n  EXPECT_EQ(\"example.foo\", cvc_config.subjectAltNameMatchers()[0].matcher().exact());\n  EXPECT_EQ(envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::DNS,\n            cvc_config.subjectAltNameMatchers()[0].san_type());\n  EXPECT_EQ(\"example.foo\", cvc_config.subjectAltNameMatchers()[1].matcher().exact());\n  EXPECT_EQ(envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::URI,\n            cvc_config.subjectAltNameMatchers()[1].san_type());\n  EXPECT_EQ(\"example.foo\", cvc_config.subjectAltNameMatchers()[2].matcher().exact());\n  EXPECT_EQ(envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::EMAIL,\n            cvc_config.subjectAltNameMatchers()[2].san_type());\n  EXPECT_EQ(\"example.foo\", cvc_config.subjectAltNameMatchers()[3].matcher().exact());\n  EXPECT_EQ(envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::IP_ADDRESS,\n            cvc_config.subjectAltNameMatchers()[3].san_type());\n}", "target": 0}
{"code": "DynamicsCompressorNode* BaseAudioContext::createDynamicsCompressor(\n    ExceptionState& exception_state) {\n  DCHECK(IsMainThread());\n  return DynamicsCompressorNode::Create(*this, exception_state);\n}", "target": 0}
{"code": "vrrp_print_data(void)\n{\n\tFILE *file = fopen (dump_file, \"w\");\n\tif (!file) {\n\t\tlog_message(LOG_INFO, \"Can't open %s (%d: %s)\",\n\t\t\tdump_file, errno, strerror(errno));\n\t\treturn;\n\t}\n\tdump_data_vrrp(file);\n\tfclose(file);\n}", "target": 1}
{"code": "videobuf_vm_open(struct vm_area_struct *vma)\n{\n\tstruct videobuf_mapping *map = vma->vm_private_data;\n\tdprintk(2,\"vm_open %p [count=%d,vma=%08lx-%08lx]\\n\",map,\n\t\tmap->count,vma->vm_start,vma->vm_end);\n\tmap->count++;\n}", "target": 1}
{"code": "static int whiteheat_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tint retval;\n\tretval = start_command_port(port->serial);\n\tif (retval)\n\t\tgoto exit;\n\tretval = firm_open(port);\n\tif (retval) {\n\t\tstop_command_port(port->serial);\n\t\tgoto exit;\n\t}\n\tretval = firm_purge(port, WHITEHEAT_PURGE_RX | WHITEHEAT_PURGE_TX);\n\tif (retval) {\n\t\tfirm_close(port);\n\t\tstop_command_port(port->serial);\n\t\tgoto exit;\n\t}\n\tif (tty)\n\t\tfirm_setup_port(tty);\n\tusb_clear_halt(port->serial->dev, port->read_urb->pipe);\n\tusb_clear_halt(port->serial->dev, port->write_urb->pipe);\n\tretval = usb_serial_generic_open(tty, port);\n\tif (retval) {\n\t\tfirm_close(port);\n\t\tstop_command_port(port->serial);\n\t\tgoto exit;\n\t}\nexit:\n\treturn retval;\n}", "target": 0}
{"code": "read_data_stored(struct archive_read *a, const void **buff, size_t *size,\n                 int64_t *offset)\n{\n  struct rar *rar;\n  ssize_t bytes_avail;\n  rar = (struct rar *)(a->format->data);\n  if (rar->bytes_remaining == 0 &&\n    !(rar->main_flags & MHD_VOLUME && rar->file_flags & FHD_SPLIT_AFTER))\n  {\n    *buff = NULL;\n    *size = 0;\n    *offset = rar->offset;\n    if (rar->file_crc != rar->crc_calculated) {\n      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                        \"File CRC error\");\n      return (ARCHIVE_FATAL);\n    }\n    rar->entry_eof = 1;\n    return (ARCHIVE_EOF);\n  }\n  *buff = rar_read_ahead(a, 1, &bytes_avail);\n  if (bytes_avail <= 0)\n  {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Truncated RAR file data\");\n    return (ARCHIVE_FATAL);\n  }\n  *size = bytes_avail;\n  *offset = rar->offset;\n  rar->offset += bytes_avail;\n  rar->offset_seek += bytes_avail;\n  rar->bytes_remaining -= bytes_avail;\n  rar->bytes_unconsumed = bytes_avail;\n  rar->crc_calculated = crc32(rar->crc_calculated, *buff,\n    (unsigned)bytes_avail);\n  return (ARCHIVE_OK);\n}", "target": 0}
{"code": "static void virtbt_rx_handle(struct virtio_bluetooth *vbt, struct sk_buff *skb)\n{\n\t__u8 pkt_type;\n\tpkt_type = *((__u8 *) skb->data);\n\tskb_pull(skb, 1);\n\tswitch (pkt_type) {\n\tcase HCI_EVENT_PKT:\n\tcase HCI_ACLDATA_PKT:\n\tcase HCI_SCODATA_PKT:\n\tcase HCI_ISODATA_PKT:\n\t\thci_skb_pkt_type(skb) = pkt_type;\n\t\thci_recv_frame(vbt->hdev, skb);\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "static void set_env( char* penv, const char* name )\n{\n    if( penv && *penv )\n        g_setenv( name, penv, TRUE);\n    else\n        g_unsetenv( name );\n}", "target": 0}
{"code": "int nsim_bpf(struct net_device *dev, struct netdev_bpf *bpf)\n{\n\tstruct netdevsim *ns = netdev_priv(dev);\n\tint err;\n\tASSERT_RTNL();\n\tswitch (bpf->command) {\n\tcase XDP_SETUP_PROG:\n\t\terr = nsim_setup_prog_checks(ns, bpf);\n\t\tif (err)\n\t\t\treturn err;\n\t\treturn nsim_xdp_set_prog(ns, bpf, &ns->xdp);\n\tcase XDP_SETUP_PROG_HW:\n\t\terr = nsim_setup_prog_hw_checks(ns, bpf);\n\t\tif (err)\n\t\t\treturn err;\n\t\treturn nsim_xdp_set_prog(ns, bpf, &ns->xdp_hw);\n\tcase BPF_OFFLOAD_MAP_ALLOC:\n\t\tif (!ns->bpf_map_accept)\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn nsim_bpf_map_alloc(ns, bpf->offmap);\n\tcase BPF_OFFLOAD_MAP_FREE:\n\t\tnsim_bpf_map_free(bpf->offmap);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}", "target": 0}
{"code": "static void xen_netbk_fill_frags(struct xen_netbk *netbk, struct sk_buff *skb)\n{\n\tstruct skb_shared_info *shinfo = skb_shinfo(skb);\n\tint nr_frags = shinfo->nr_frags;\n\tint i;\n\tfor (i = 0; i < nr_frags; i++) {\n\t\tskb_frag_t *frag = shinfo->frags + i;\n\t\tstruct xen_netif_tx_request *txp;\n\t\tstruct page *page;\n\t\tu16 pending_idx;\n\t\tpending_idx = frag_get_pending_idx(frag);\n\t\ttxp = &netbk->pending_tx_info[pending_idx].req;\n\t\tpage = virt_to_page(idx_to_kaddr(netbk, pending_idx));\n\t\t__skb_fill_page_desc(skb, i, page, txp->offset, txp->size);\n\t\tskb->len += txp->size;\n\t\tskb->data_len += txp->size;\n\t\tskb->truesize += txp->size;\n\t\tget_page(netbk->mmap_pages[pending_idx]);\n\t\txen_netbk_idx_release(netbk, pending_idx);\n\t}\n}", "target": 1}
{"code": "ext4_xattr_cache_insert(struct mb_cache *ext4_mb_cache, struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(BHDR(bh)->h_hash);\n\tstruct mb_cache_entry *ce;\n\tint error;\n\tce = mb_cache_entry_alloc(ext4_mb_cache, GFP_NOFS);\n\tif (!ce) {\n\t\tea_bdebug(bh, \"out of memory\");\n\t\treturn;\n\t}\n\terror = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);\n\tif (error) {\n\t\tmb_cache_entry_free(ce);\n\t\tif (error == -EBUSY) {\n\t\t\tea_bdebug(bh, \"already in cache\");\n\t\t\terror = 0;\n\t\t}\n\t} else {\n\t\tea_bdebug(bh, \"inserting [%x]\", (int)hash);\n\t\tmb_cache_entry_release(ce);\n\t}\n}", "target": 1}
{"code": "static void *unix_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\t++*pos;\n\treturn unix_next_socket(seq, v, pos);\n}", "target": 0}
{"code": "void gd_stderr_error(int priority, const char *format, va_list args)\n{\n\tswitch (priority) {\n\tcase GD_ERROR:\n\t\tfputs(\"GD Error: \", stderr);\n\t\tbreak;\n\tcase GD_WARNING:\n\t\tfputs(\"GD Warning: \", stderr);\n\t\tbreak;\n\tcase GD_NOTICE:\n\t\tfputs(\"GD Notice: \", stderr);\n\t\tbreak;\n\tcase GD_INFO:\n\t\tfputs(\"GD Info: \", stderr);\n\t\tbreak;\n\tcase GD_DEBUG:\n\t\tfputs(\"GD Debug: \", stderr);\n\t\tbreak;\n\t}\n\tvfprintf(stderr, format, args);\n\tfflush(stderr);\n}", "target": 0}
{"code": "  QInt8() {}", "target": 1}
{"code": "static int ext4_get_block_write(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create)\n{\n\thandle_t *handle = NULL;\n\tint ret = 0;\n\tunsigned max_blocks = bh_result->b_size >> inode->i_blkbits;\n\tint dio_credits;\n\text4_debug(\"ext4_get_block_write: inode %lu, create flag %d\\n\",\n\t\t   inode->i_ino, create);\n\tcreate = EXT4_GET_BLOCKS_IO_CREATE_EXT;\n\tif (max_blocks > DIO_MAX_BLOCKS)\n\t\tmax_blocks = DIO_MAX_BLOCKS;\n\tdio_credits = ext4_chunk_trans_blocks(inode, max_blocks);\n\thandle = ext4_journal_start(inode, dio_credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto out;\n\t}\n\tret = ext4_get_blocks(handle, inode, iblock, max_blocks, bh_result,\n\t\t\t      create);\n\tif (ret > 0) {\n\t\tbh_result->b_size = (ret << inode->i_blkbits);\n\t\tret = 0;\n\t}\n\text4_journal_stop(handle);\nout:\n\treturn ret;\n}", "target": 1}
{"code": "int hns_rcb_get_ring_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn HNS_RING_STATIC_REG_NUM;\n\treturn 0;\n}", "target": 1}
{"code": "static void set_error_response(h2_stream *stream, int http_status)\n{\n    if (!h2_stream_is_ready(stream)) {\n        stream->rtmp->http_status = http_status;\n    }\n}", "target": 1}
{"code": "static const char *cmd_hash_engine(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n    if (strcasecmp(p1, \"on\") == 0)  {\n        dcfg->hash_is_enabled = HASH_ENABLED;\n        dcfg->hash_enforcement = HASH_ENABLED;\n    }\n    else if (strcasecmp(p1, \"off\") == 0)    {\n        dcfg->hash_is_enabled = HASH_DISABLED;\n        dcfg->hash_enforcement = HASH_DISABLED;\n    }\n    else return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecRuleEngine: %s\", p1);\n    return NULL;\n}", "target": 1}
{"code": "static int ion_handle_put(struct ion_handle *handle)\n{\n\tstruct ion_client *client = handle->client;\n\tint ret;\n\tmutex_lock(&client->lock);\n\tret = kref_put(&handle->ref, ion_handle_destroy);\n\tmutex_unlock(&client->lock);\n\treturn ret;\n}", "target": 1}
{"code": "ldap_pvt_tls_init_def_ctx( int is_server )\n{\n\tstruct ldapoptions *lo = LDAP_INT_GLOBAL_OPT();   \n\tint rc;\n\tLDAP_MUTEX_LOCK( &tls_def_ctx_mutex );\n\trc = ldap_int_tls_init_ctx( lo, is_server );\n\tLDAP_MUTEX_UNLOCK( &tls_def_ctx_mutex );\n\treturn rc;\n}", "target": 0}
{"code": "static inline unsigned long do_div_llr(const long long dividend,\n\t\t\t\t       const long divisor, long *remainder)\n{\n\tu64 result = dividend;\n\t*(remainder) = do_div(result, divisor);\n\treturn (unsigned long) result;\n}", "target": 1}
{"code": "u32 GetHintFormat(GF_TrackBox *trak)\n{\n\tGF_HintMediaHeaderBox *hmhd = (GF_HintMediaHeaderBox *)trak->Media->information->InfoHeader;\n\tif (hmhd->type != GF_ISOM_BOX_TYPE_HMHD)\n\t\treturn 0;\n\tif (!hmhd || !hmhd->subType) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\t\tif (!hmhd) return a ? a->type : 0;\n\t\tif (a) hmhd->subType = a->type;\n\t\treturn hmhd->subType;\n\t}\n\treturn hmhd->subType;\n}", "target": 1}
{"code": "long do_io_submit(aio_context_t ctx_id, long nr,\n\t\t  struct iocb __user *__user *iocbpp, bool compat)\n{\n\tstruct kioctx *ctx;\n\tlong ret = 0;\n\tint i;\n\tstruct hlist_head batch_hash[AIO_BATCH_HASH_SIZE] = { { 0, }, };\n\tif (unlikely(nr < 0))\n\t\treturn -EINVAL;\n\tif (unlikely(!access_ok(VERIFY_READ, iocbpp, (nr*sizeof(*iocbpp)))))\n\t\treturn -EFAULT;\n\tctx = lookup_ioctx(ctx_id);\n\tif (unlikely(!ctx)) {\n\t\tpr_debug(\"EINVAL: io_submit: invalid context id\\n\");\n\t\treturn -EINVAL;\n\t}\n\tfor (i=0; i<nr; i++) {\n\t\tstruct iocb __user *user_iocb;\n\t\tstruct iocb tmp;\n\t\tif (unlikely(__get_user(user_iocb, iocbpp + i))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (unlikely(copy_from_user(&tmp, user_iocb, sizeof(tmp)))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tret = io_submit_one(ctx, user_iocb, &tmp, batch_hash, compat);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\taio_batch_free(batch_hash);\n\tput_ioctx(ctx);\n\treturn i ? i : ret;\n}", "target": 1}
{"code": "static void destroy_super(struct super_block *s)\n{\n\tint i;\n\tlist_lru_destroy(&s->s_dentry_lru);\n\tlist_lru_destroy(&s->s_inode_lru);\n#ifdef CONFIG_SMP\n\tfree_percpu(s->s_files);\n#endif\n\tfor (i = 0; i < SB_FREEZE_LEVELS; i++)\n\t\tpercpu_counter_destroy(&s->s_writers.counter[i]);\n\tsecurity_sb_free(s);\n\tWARN_ON(!list_empty(&s->s_mounts));\n\tkfree(s->s_subtype);\n\tkfree(s->s_options);\n\tkfree_rcu(s, rcu);\n}", "target": 1}
{"code": "static int bio_copy_to_iter(struct bio *bio, struct iov_iter iter)\n{\n\tstruct bio_vec *bvec;\n\tstruct bvec_iter_all iter_all;\n\tbio_for_each_segment_all(bvec, bio, iter_all) {\n\t\tssize_t ret;\n\t\tret = copy_page_to_iter(bvec->bv_page,\n\t\t\t\t\tbvec->bv_offset,\n\t\t\t\t\tbvec->bv_len,\n\t\t\t\t\t&iter);\n\t\tif (!iov_iter_count(&iter))\n\t\t\tbreak;\n\t\tif (ret < bvec->bv_len)\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static uint get_alen(char *arg, int default_len)\n{\n\tint\tj;\n\tint\talen;\n\talen = default_len;\n\tfor (j = 0; j < 8; j++) {\n\t\tif (arg[j] == '.') {\n\t\t\talen = arg[j+1] - '0';\n\t\t\tbreak;\n\t\t} else if (arg[j] == '\\0')\n\t\t\tbreak;\n\t}\n\treturn alen;\n}", "target": 1}
{"code": "PHP_FUNCTION(imagetruecolortopalette)\n{\n\tzval *IM;\n\tzend_bool dither;\n\tzend_long ncolors;\n\tgdImagePtr im;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"rbl\", &IM, &dither, &ncolors) == FAILURE)  {\n\t\treturn;\n\t}\n\tif ((im = (gdImagePtr)zend_fetch_resource(Z_RES_P(IM), \"Image\", le_gd)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tif (ncolors <= 0) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Number of colors has to be greater than zero\");\n\t\tRETURN_FALSE;\n\t}\n\tgdImageTrueColorToPalette(im, dither, ncolors);\n\tRETURN_TRUE;\n}", "target": 1}
{"code": "static void _WM_CheckEventMemoryPool(struct _mdi *mdi) {\n    if ((mdi->event_count + 1) >= mdi->events_size) {\n        mdi->events_size += MEM_CHUNK;\n        mdi->events = realloc(mdi->events,\n                              (mdi->events_size * sizeof(struct _event)));\n    }\n}", "target": 0}
{"code": "int cfg80211_mgd_wext_giwessid(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       struct iw_point *data, char *ssid)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tif (WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION))\n\t\treturn -EINVAL;\n\tdata->flags = 0;\n\twdev_lock(wdev);\n\tif (wdev->current_bss) {\n\t\tconst u8 *ie;\n\t\trcu_read_lock();\n\t\tie = ieee80211_bss_get_ie(&wdev->current_bss->pub,\n\t\t\t\t\t  WLAN_EID_SSID);\n\t\tif (ie) {\n\t\t\tdata->flags = 1;\n\t\t\tdata->length = ie[1];\n\t\t\tmemcpy(ssid, ie + 2, data->length);\n\t\t}\n\t\trcu_read_unlock();\n\t} else if (wdev->wext.connect.ssid && wdev->wext.connect.ssid_len) {\n\t\tdata->flags = 1;\n\t\tdata->length = wdev->wext.connect.ssid_len;\n\t\tmemcpy(ssid, wdev->wext.connect.ssid, data->length);\n\t}\n\twdev_unlock(wdev);\n\treturn 0;\n}", "target": 1}
{"code": "OpTypeConstructor UnaryTensorContainer(FullTypeId t, FullTypeId dtype) {\n  return [t, dtype](OpDef* op_def) {\n    FullTypeDef* tdef =\n        op_def->mutable_output_arg(0)->mutable_experimental_full_type();\n    tdef->set_type_id(t);\n    FullTypeDef* arg = tdef->add_args();\n    arg->set_type_id(TFT_TENSOR);\n    FullTypeDef* targ = arg->add_args();\n    targ->set_type_id(dtype);\n    return Status::OK();\n  };\n}", "target": 0}
{"code": "static void nvme_mmio_write(void *opaque, hwaddr addr, uint64_t data,\n                            unsigned size)\n{\n    NvmeCtrl *n = (NvmeCtrl *)opaque;\n    trace_pci_nvme_mmio_write(addr, data, size);\n    if (addr < sizeof(n->bar)) {\n        nvme_write_bar(n, addr, data, size);\n    } else {\n        nvme_process_db(n, addr, data);\n    }\n}", "target": 0}
{"code": "void ssl_update_cache(SSL *s, int mode)\n{\n    int i;\n    if (s->session->session_id_length == 0)\n        return;\n    if (s->server && s->session->sid_ctx_length == 0\n            && (s->verify_mode & SSL_VERIFY_PEER) != 0)\n        return;\n    i = s->session_ctx->session_cache_mode;\n    if ((i & mode) != 0\n        && (!s->hit || SSL_IS_TLS13(s))) {\n        if ((i & SSL_SESS_CACHE_NO_INTERNAL_STORE) == 0\n                && (!SSL_IS_TLS13(s)\n                    || !s->server\n                    || (s->max_early_data > 0\n                        && (s->options & SSL_OP_NO_ANTI_REPLAY) == 0)\n                    || s->session_ctx->remove_session_cb != NULL\n                    || (s->options & SSL_OP_NO_TICKET) != 0))\n            SSL_CTX_add_session(s->session_ctx, s->session);\n        if (s->session_ctx->new_session_cb != NULL) {\n            SSL_SESSION_up_ref(s->session);\n            if (!s->session_ctx->new_session_cb(s, s->session))\n                SSL_SESSION_free(s->session);\n        }\n    }\n    if ((!(i & SSL_SESS_CACHE_NO_AUTO_CLEAR)) && ((i & mode) == mode)) {\n        TSAN_QUALIFIER int *stat;\n        if (mode & SSL_SESS_CACHE_CLIENT)\n            stat = &s->session_ctx->stats.sess_connect_good;\n        else\n            stat = &s->session_ctx->stats.sess_accept_good;\n        if ((ssl_tsan_load(s->session_ctx, stat) & 0xff) == 0xff)\n            SSL_CTX_flush_sessions(s->session_ctx, (unsigned long)time(NULL));\n    }\n}", "target": 1}
{"code": "static int _process_request_metaflags(mcp_parser_t *pr, int token) {\n    if (pr->ntokens <= token) {\n        pr->t.meta.flags = 0; \n        return 0;\n    }\n    const char *cur = pr->request + pr->tokens[token];\n    const char *end = pr->request + pr->reqlen - 2;\n    int state = 0;\n    while (cur != end) {\n        switch (state) {\n            case 0:\n                if (*cur == ' ') {\n                    cur++;\n                } else {\n                    if (*cur < 65 || *cur > 122) {\n                        return -1;\n                    }\n                    P_DEBUG(\"%s: setting meta flag: %d\\n\", __func__, *cur - 65);\n                    pr->t.meta.flags |= (uint64_t)1 << (*cur - 65);\n                    state = 1;\n                }\n                break;\n            case 1:\n                if (*cur != ' ') {\n                    cur++;\n                } else {\n                    state = 0;\n                }\n                break;\n        }\n    }\n    if (pr->t.meta.flags & ((uint64_t)1 << 48)) {\n        pr->noreply = true;\n    }\n    return 0;\n}", "target": 1}
{"code": "get_smb2_acl_by_path(struct cifs_sb_info *cifs_sb,\n\t\t     const char *path, u32 *pacllen, u32 info)\n{\n\tstruct cifs_ntsd *pntsd = NULL;\n\tu8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tunsigned int xid;\n\tint rc;\n\tstruct cifs_tcon *tcon;\n\tstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\t__le16 *utf16_path;\n\tcifs_dbg(FYI, \"get smb3 acl for path %s\\n\", path);\n\tif (IS_ERR(tlink))\n\t\treturn ERR_CAST(tlink);\n\ttcon = tlink_tcon(tlink);\n\txid = get_xid();\n\tutf16_path = cifs_convert_path_to_utf16(path, cifs_sb);\n\tif (!utf16_path) {\n\t\trc = -ENOMEM;\n\t\tfree_xid(xid);\n\t\treturn ERR_PTR(rc);\n\t}\n\toparms.tcon = tcon;\n\toparms.desired_access = READ_CONTROL;\n\toparms.disposition = FILE_OPEN;\n\toparms.create_options = cifs_create_options(cifs_sb, 0) | OPEN_REPARSE_POINT;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\tif (info & SACL_SECINFO)\n\t\toparms.desired_access |= SYSTEM_SECURITY;\n\trc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, NULL, NULL,\n\t\t       NULL);\n\tkfree(utf16_path);\n\tif (!rc) {\n\t\trc = SMB2_query_acl(xid, tlink_tcon(tlink), fid.persistent_fid,\n\t\t\t\t    fid.volatile_fid, (void **)&pntsd, pacllen,\n\t\t\t\t    info);\n\t\tSMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\n\t}\n\tcifs_put_tlink(tlink);\n\tfree_xid(xid);\n\tcifs_dbg(FYI, \"%s: rc = %d ACL len %d\\n\", __func__, rc, *pacllen);\n\tif (rc)\n\t\treturn ERR_PTR(rc);\n\treturn pntsd;\n}", "target": 0}
{"code": "snmp_api_set_time_ticks(snmp_varbind_t *varbind, uint32_t *oid, uint32_t integer)\n{\n  snmp_api_replace_oid(varbind, oid);\n  varbind->value_type = SNMP_DATA_TYPE_TIME_TICKS;\n  varbind->value.integer = integer;\n}", "target": 1}
{"code": "sg_fill_request_table(Sg_fd *sfp, sg_req_info_t *rinfo)\n{\n\tSg_request *srp;\n\tint val;\n\tunsigned int ms;\n\tval = 0;\n\tlist_for_each_entry(srp, &sfp->rq_list, entry) {\n\t\tif (val > SG_MAX_QUEUE)\n\t\t\tbreak;\n\t\tmemset(&rinfo[val], 0, SZ_SG_REQ_INFO);\n\t\trinfo[val].req_state = srp->done + 1;\n\t\trinfo[val].problem =\n\t\t\tsrp->header.masked_status &\n\t\t\tsrp->header.host_status &\n\t\t\tsrp->header.driver_status;\n\t\tif (srp->done)\n\t\t\trinfo[val].duration =\n\t\t\t\tsrp->header.duration;\n\t\telse {\n\t\t\tms = jiffies_to_msecs(jiffies);\n\t\t\trinfo[val].duration =\n\t\t\t\t(ms > srp->header.duration) ?\n\t\t\t\t(ms - srp->header.duration) : 0;\n\t\t}\n\t\trinfo[val].orphan = srp->orphan;\n\t\trinfo[val].sg_io_owned = srp->sg_io_owned;\n\t\trinfo[val].pack_id = srp->header.pack_id;\n\t\trinfo[val].usr_ptr = srp->header.usr_ptr;\n\t\tval++;\n\t}\n}", "target": 1}
{"code": "coolkey_get_attribute_data_fixed(CK_ATTRIBUTE_TYPE attr_type, unsigned long fixed_attributes,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsc_cardctl_coolkey_attribute_t *attr_out) {\n\tunsigned long cka_id = fixed_attributes & 0xf;\n\tunsigned long cka_class = ((fixed_attributes) >> 4) & 0x7;\n\tunsigned long mask, bit;\n\tif (attr_type == CKA_ID) {\n\t\tattr_out->attribute_length = 1;\n\t\tattr_out->attribute_value= &coolkey_static_cka_id[cka_id];\n\t\treturn SC_SUCCESS;\n\t}\n\tif (attr_type == CKA_CLASS) {\n\t\tattr_out->attribute_data_type = SC_CARDCTL_COOLKEY_ATTR_TYPE_ULONG;\n\t\tattr_out->attribute_length = 4;\n\t\tattr_out->attribute_value = coolkey_static_cka_class[cka_class].class_value;\n\t\treturn SC_SUCCESS;\n\t}\n\tmask = coolkey_static_cka_class[cka_class].boolean_mask;\n\tbit = coolkey_get_fixed_boolean_bit(attr_type);\n\tif ((bit & mask) == 0) {\n\t\treturn SC_ERROR_DATA_OBJECT_NOT_FOUND;\n\t}\n\tattr_out->attribute_length = 1;\n\tattr_out->attribute_value = bit & fixed_attributes ? &coolkey_static_true : &coolkey_static_false;\n\treturn SC_SUCCESS;\n}", "target": 0}
{"code": "static void __exit xfrm6_tunnel_fini(void)\n{\n\tunregister_pernet_subsys(&xfrm6_tunnel_net_ops);\n\txfrm6_tunnel_spi_fini();\n\txfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);\n\txfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);\n\txfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);\n}", "target": 1}
{"code": "int install_process_keyring_to_cred(struct cred *new)\n{\n\tstruct key *keyring;\n\tif (new->process_keyring)\n\t\treturn -EEXIST;\n\tkeyring = keyring_alloc(\"_pid\", new->uid, new->gid, new,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN,\n\t\t\t\tNULL, NULL);\n\tif (IS_ERR(keyring))\n\t\treturn PTR_ERR(keyring);\n\tnew->process_keyring = keyring;\n\treturn 0;\n}", "target": 1}
{"code": "AcpiNsPrintNodePathname (\n    ACPI_NAMESPACE_NODE     *Node,\n    const char              *Message)\n{\n    ACPI_BUFFER             Buffer;\n    ACPI_STATUS             Status;\n    if (!Node)\n    {\n        AcpiOsPrintf (\"[NULL NAME]\");\n        return;\n    }\n    Buffer.Length = ACPI_ALLOCATE_LOCAL_BUFFER;\n    Status = AcpiNsHandleToPathname (Node, &Buffer, TRUE);\n    if (ACPI_SUCCESS (Status))\n    {\n        if (Message)\n        {\n            AcpiOsPrintf (\"%s \", Message);\n        }\n        AcpiOsPrintf (\"[%s] (Node %p)\", (char *) Buffer.Pointer, Node);\n        ACPI_FREE (Buffer.Pointer);\n    }\n}", "target": 0}
{"code": "static int __init xfrm6_tunnel_init(void)\n{\n\tint rv;\n\trv = xfrm_register_type(&xfrm6_tunnel_type, AF_INET6);\n\tif (rv < 0)\n\t\tgoto err;\n\trv = xfrm6_tunnel_register(&xfrm6_tunnel_handler, AF_INET6);\n\tif (rv < 0)\n\t\tgoto unreg;\n\trv = xfrm6_tunnel_register(&xfrm46_tunnel_handler, AF_INET);\n\tif (rv < 0)\n\t\tgoto dereg6;\n\trv = xfrm6_tunnel_spi_init();\n\tif (rv < 0)\n\t\tgoto dereg46;\n\trv = register_pernet_subsys(&xfrm6_tunnel_net_ops);\n\tif (rv < 0)\n\t\tgoto deregspi;\n\treturn 0;\nderegspi:\n\txfrm6_tunnel_spi_fini();\ndereg46:\n\txfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);\ndereg6:\n\txfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);\nunreg:\n\txfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);\nerr:\n\treturn rv;\n}", "target": 1}
{"code": "static int add_seccomp_syscall_filter(scmp_filter_ctx seccomp,\n                                      uint32_t arch,\n                                      int nr,\n                                      unsigned int arg_cnt,\n                                      const struct scmp_arg_cmp arg) {\n        int r;\n        r = seccomp_rule_add_exact(seccomp, SCMP_ACT_ERRNO(EPERM), nr, arg_cnt, arg);\n        if (r < 0) {\n                _cleanup_free_ char *n = NULL;\n                n = seccomp_syscall_resolve_num_arch(arch, nr);\n                log_debug_errno(r, \"Failed to add %s() rule for architecture %s, skipping: %m\",\n                                strna(n),\n                                seccomp_arch_to_string(arch));\n        }\n        return r;\n}", "target": 0}
{"code": "\tEventReturn OnPreCommand(CommandSource &source, Command *command, std::vector<Anope::string> &params) anope_override\n\t{\n\t\tif (command->name == \"nickserv/confirm\" && params.size() > 1)\n\t\t{\n\t\t\tif (Anope::ReadOnly)\n\t\t\t{\n\t\t\t\tsource.Reply(READ_ONLY_MODE);\n\t\t\t\treturn EVENT_STOP;\n\t\t\t}\n\t\t\tNickAlias *na = NickAlias::Find(params[0]);\n\t\t\tResetInfo *ri = na ? reset.Get(na->nc) : NULL;\n\t\t\tif (na && ri)\n\t\t\t{\n\t\t\t\tNickCore *nc = na->nc;\n\t\t\t\tif (nc->HasExt(\"NS_SUSPENDED\"))\n\t\t\t\t{\n\t\t\t\t\tsource.Reply(NICK_X_SUSPENDED, nc->display.c_str());\n\t\t\t\t\treturn EVENT_STOP;\n\t\t\t\t}\n\t\t\t\tconst Anope::string &passcode = params[1];\n\t\t\t\tif (ri->time < Anope::CurTime - 3600)\n\t\t\t\t{\n\t\t\t\t\treset.Unset(nc);\n\t\t\t\t\tsource.Reply(_(\"Your password reset request has expired.\"));\n\t\t\t\t}\n\t\t\t\telse if (passcode.equals_cs(ri->code))\n\t\t\t\t{\n\t\t\t\t\treset.Unset(nc);\n\t\t\t\t\tnc->Shrink<bool>(\"UNCONFIRMED\");\n\t\t\t\t\tLog(LOG_COMMAND, source, &commandnsresetpass) << \"to confirm RESETPASS and forcefully identify as \" << na->nick;\n\t\t\t\t\tif (source.GetUser())\n\t\t\t\t\t{\n\t\t\t\t\t\tsource.GetUser()->Identify(na);\n\t\t\t\t\t}\n\t\t\t\t\tsource.Reply(_(\"You are now identified for your nick. Change your password now.\"));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\treturn EVENT_CONTINUE;\n\t\t\t\treturn EVENT_STOP;\n\t\t\t}\n\t\t}\n\t\treturn EVENT_CONTINUE;\n\t}", "target": 0}
{"code": "static void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t      struct userfaultfd_wait_queue *ewq)\n{\n\tstruct userfaultfd_ctx *release_new_ctx;\n\tif (WARN_ON_ONCE(current->flags & PF_EXITING))\n\t\tgoto out;\n\tewq->ctx = ctx;\n\tinit_waitqueue_entry(&ewq->wq, current);\n\trelease_new_ctx = NULL;\n\tspin_lock(&ctx->event_wqh.lock);\n\t__add_wait_queue(&ctx->event_wqh, &ewq->wq);\n\tfor (;;) {\n\t\tset_current_state(TASK_KILLABLE);\n\t\tif (ewq->msg.event == 0)\n\t\t\tbreak;\n\t\tif (READ_ONCE(ctx->released) ||\n\t\t    fatal_signal_pending(current)) {\n\t\t\t__remove_wait_queue(&ctx->event_wqh, &ewq->wq);\n\t\t\tif (ewq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tstruct userfaultfd_ctx *new;\n\t\t\t\tnew = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tewq->msg.arg.reserved.reserved1;\n\t\t\t\trelease_new_ctx = new;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\t\twake_up_poll(&ctx->fd_wqh, EPOLLIN);\n\t\tschedule();\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->event_wqh.lock);\n\tif (release_new_ctx) {\n\t\tstruct vm_area_struct *vma;\n\t\tstruct mm_struct *mm = release_new_ctx->mm;\n\t\tdown_write(&mm->mmap_sem);\n\t\tVM_WARN_ON(!mmget_still_valid(mm));\n\t\tfor (vma = mm->mmap; vma; vma = vma->vm_next)\n\t\t\tif (vma->vm_userfaultfd_ctx.ctx == release_new_ctx) {\n\t\t\t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n\t\t\t\tvma->vm_flags &= ~(VM_UFFD_WP | VM_UFFD_MISSING);\n\t\t\t}\n\t\tup_write(&mm->mmap_sem);\n\t\tuserfaultfd_ctx_put(release_new_ctx);\n\t}\nout:\n\tWRITE_ONCE(ctx->mmap_changing, false);\n\tuserfaultfd_ctx_put(ctx);\n}", "target": 0}
{"code": "static void handle_swbp(struct pt_regs *regs)\n{\n\tstruct uprobe *uprobe;\n\tunsigned long bp_vaddr;\n\tint uninitialized_var(is_swbp);\n\tbp_vaddr = uprobe_get_swbp_addr(regs);\n\tif (bp_vaddr == get_trampoline_vaddr())\n\t\treturn handle_trampoline(regs);\n\tuprobe = find_active_uprobe(bp_vaddr, &is_swbp);\n\tif (!uprobe) {\n\t\tif (is_swbp > 0) {\n\t\t\tsend_sig(SIGTRAP, current, 0);\n\t\t} else {\n\t\t\tinstruction_pointer_set(regs, bp_vaddr);\n\t\t}\n\t\treturn;\n\t}\n\tinstruction_pointer_set(regs, bp_vaddr);\n\tsmp_rmb(); \n\tif (unlikely(!test_bit(UPROBE_COPY_INSN, &uprobe->flags)))\n\t\tgoto out;\n\tif (!get_utask())\n\t\tgoto out;\n\tif (arch_uprobe_ignore(&uprobe->arch, regs))\n\t\tgoto out;\n\thandler_chain(uprobe, regs);\n\tif (arch_uprobe_skip_sstep(&uprobe->arch, regs))\n\t\tgoto out;\n\tif (!pre_ssout(uprobe, regs, bp_vaddr))\n\t\treturn;\nout:\n\tput_uprobe(uprobe);\n}", "target": 0}
{"code": "WandExport double *DrawGetStrokeDashArray(const DrawingWand *wand,\n  size_t *number_elements)\n{\n  double\n    *dasharray;\n  register const double\n    *p;\n  register double\n    *q;\n  register ssize_t\n    i;\n  size_t\n    n;\n  assert(wand != (const DrawingWand *) NULL);\n  assert(wand->signature == MagickWandSignature);\n  if (wand->debug != MagickFalse)\n    (void) LogMagickEvent(WandEvent,GetMagickModule(),\"%s\",wand->name);\n  assert(number_elements != (size_t *) NULL);\n  n=0;\n  p=CurrentContext->dash_pattern;\n  if (p != (const double *) NULL)\n    while (fabs(*p++) >= MagickEpsilon)\n      n++;\n  *number_elements=n;\n  dasharray=(double *) NULL;\n  if (n != 0)\n    {\n      dasharray=(double *) AcquireQuantumMemory((size_t) n+1UL,\n        sizeof(*dasharray));\n      p=CurrentContext->dash_pattern;\n      q=dasharray;\n      for (i=0; i < (ssize_t) n; i++)\n        *q++=(*p++);\n      *q=0.0;\n    }\n  return(dasharray);\n}", "target": 1}
{"code": "static u32 *gen8_emit_fini_breadcrumb_rcs(struct i915_request *request, u32 *cs)\n{\n\tcs = gen8_emit_pipe_control(cs,\n\t\t\t\t    PIPE_CONTROL_RENDER_TARGET_CACHE_FLUSH |\n\t\t\t\t    PIPE_CONTROL_DEPTH_CACHE_FLUSH |\n\t\t\t\t    PIPE_CONTROL_DC_FLUSH_ENABLE,\n\t\t\t\t    0);\n\tcs = gen8_emit_ggtt_write_rcs(cs,\n\t\t\t\t      request->fence.seqno,\n\t\t\t\t      i915_request_active_timeline(request)->hwsp_offset,\n\t\t\t\t      PIPE_CONTROL_FLUSH_ENABLE |\n\t\t\t\t      PIPE_CONTROL_CS_STALL);\n\treturn gen8_emit_fini_breadcrumb_footer(request, cs);\n}", "target": 0}
{"code": "put_mech_oid(unsigned char **buf_out, gss_OID_const mech, unsigned int buflen)\n{\n\tif (buflen < mech->length + 2)\n\t\treturn (-1);\n\t*(*buf_out)++ = MECH_OID;\n\t*(*buf_out)++ = (unsigned char) mech->length;\n\tmemcpy(*buf_out, mech->elements, mech->length);\n\t*buf_out += mech->length;\n\treturn (0);\n}", "target": 0}
{"code": "static void grow_ple_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint old = vmx->ple_window;\n\tvmx->ple_window = __grow_ple_window(old);\n\tif (vmx->ple_window != old)\n\t\tvmx->ple_window_dirty = true;\n\ttrace_kvm_ple_window_grow(vcpu->vcpu_id, vmx->ple_window, old);\n}", "target": 0}
{"code": "char *url_canonize2(char *d, char const * const s, size_t n,\n\t\t    unsigned syn33,\n\t\t    unsigned m32, unsigned m64, unsigned m96)\n{\n  size_t i = 0;\n  if (d == s)\n    for (;s[i] && i < n; d++, i++)\n      if (s[i] == '%')\n\tbreak;\n  for (;s[i] && i < n; d++, i++) {\n    unsigned char c = s[i], h1, h2;\n    if (c != '%') {\n      if (!IS_SYN33(syn33, c) && IS_EXCLUDED(c, m32, m64, m96))\n\treturn NULL;\n      *d = c;\n      continue;\n    }\n    h1 = s[i + 1];\n    if (!h1) {\n        *d = '\\0';\n        return NULL;\n    }\n    h2 = s[i + 2];\n    if (!IS_HEX(h1) || !IS_HEX(h2)) {\n      *d = '\\0';\n      return NULL;\n    }\n#define UNHEX(a) (a - (a >= 'a' ? 'a' - 10 : (a >= 'A' ? 'A' - 10 : '0')))\n    c = (UNHEX(h1) << 4) | UNHEX(h2);\n    if (!IS_EXCLUDED(c, m32, m64, m96)) {\n      *d = c, i += 2;\n      continue;\n    }\n    if (h1 >= 'a' )\n      h1 = h1 - 'a' + 'A';\n    if (h2 >= 'a' )\n      h2 = h2 - 'a' + 'A';\n    d[0] = '%', d[1] = h1, d[2] = h2;\n    d +=2, i += 2;\n#undef    UNHEX\n  }\n  *d = '\\0';\n  return d;\n}", "target": 0}
{"code": "static inline void ok_inflater_write_byte(ok_inflater *inflater, const uint8_t b) {\n    inflater->buffer[inflater->buffer_end_pos & BUFFER_SIZE_MASK] = b;\n    inflater->buffer_end_pos++;\n}", "target": 0}
{"code": "static bool add_free_nid(struct f2fs_sb_info *sbi, nid_t nid, bool build)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\tstruct nat_entry *ne;\n\tint err;\n\tif (unlikely(nid == 0))\n\t\treturn false;\n\tif (build) {\n\t\tne = __lookup_nat_cache(nm_i, nid);\n\t\tif (ne && (!get_nat_flag(ne, IS_CHECKPOINTED) ||\n\t\t\t\tnat_get_blkaddr(ne) != NULL_ADDR))\n\t\t\treturn false;\n\t}\n\ti = f2fs_kmem_cache_alloc(free_nid_slab, GFP_NOFS);\n\ti->nid = nid;\n\ti->state = NID_NEW;\n\tif (radix_tree_preload(GFP_NOFS)) {\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn true;\n\t}\n\tspin_lock(&nm_i->nid_list_lock);\n\terr = __insert_nid_to_list(sbi, i, FREE_NID_LIST, true);\n\tspin_unlock(&nm_i->nid_list_lock);\n\tradix_tree_preload_end();\n\tif (err) {\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn true;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "static int omninet_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct usb_serial\t*serial = port->serial;\n\tstruct usb_serial_port\t*wport;\n\twport = serial->port[1];\n\ttty_port_tty_set(&wport->port, tty);\n\treturn usb_serial_generic_open(tty, port);\n}", "target": 1}
{"code": "static void debug_print_fis(uint8_t *fis, int cmd_len)\n{\n#if DEBUG_AHCI\n    int i;\n    fprintf(stderr, \"fis:\");\n    for (i = 0; i < cmd_len; i++) {\n        if ((i & 0xf) == 0) {\n            fprintf(stderr, \"\\n%02x:\",i);\n        }\n        fprintf(stderr, \"%02x \",fis[i]);\n    }\n    fprintf(stderr, \"\\n\");\n#endif\n}", "target": 0}
{"code": "void __init files_init(unsigned long mempages)\n{ \n\tunsigned long n;\n\tfilp_cachep = kmem_cache_create(\"filp\", sizeof(struct file), 0,\n\t\t\tSLAB_HWCACHE_ALIGN | SLAB_PANIC, NULL);\n\tn = (mempages * (PAGE_SIZE / 1024)) / 10;\n\tfiles_stat.max_files = max_t(unsigned long, n, NR_FILE);\n\tfiles_defer_init();\n\tlg_lock_init(&files_lglock, \"files_lglock\");\n\tpercpu_counter_init(&nr_files, 0);\n} ", "target": 1}
{"code": "static void sctp_generate_timeout_event(struct sctp_association *asoc,\n\t\t\t\t\tsctp_event_timeout_t timeout_type)\n{\n\tstruct net *net = sock_net(asoc->base.sk);\n\tint error = 0;\n\tbh_lock_sock(asoc->base.sk);\n\tif (sock_owned_by_user(asoc->base.sk)) {\n\t\tpr_debug(\"%s: sock is busy: timer %d\\n\", __func__,\n\t\t\t timeout_type);\n\t\tif (!mod_timer(&asoc->timers[timeout_type], jiffies + (HZ/20)))\n\t\t\tsctp_association_hold(asoc);\n\t\tgoto out_unlock;\n\t}\n\tif (asoc->base.dead)\n\t\tgoto out_unlock;\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(timeout_type),\n\t\t\t   asoc->state, asoc->ep, asoc,\n\t\t\t   (void *)timeout_type, GFP_ATOMIC);\n\tif (error)\n\t\tasoc->base.sk->sk_err = -error;\nout_unlock:\n\tbh_unlock_sock(asoc->base.sk);\n\tsctp_association_put(asoc);\n}", "target": 1}
{"code": "save_fonteffect(struct html_feed_environ *h_env, struct readbuffer *obuf)\n{\n    if (obuf->fontstat_sp < FONT_STACK_SIZE)\n\tbcopy(obuf->fontstat, obuf->fontstat_stack[obuf->fontstat_sp],\n\t      FONTSTAT_SIZE);\n    obuf->fontstat_sp++;\n    if (obuf->in_bold)\n\tpush_tag(obuf, \"</b>\", HTML_N_B);\n    if (obuf->in_italic)\n\tpush_tag(obuf, \"</i>\", HTML_N_I);\n    if (obuf->in_under)\n\tpush_tag(obuf, \"</u>\", HTML_N_U);\n    if (obuf->in_strike)\n\tpush_tag(obuf, \"</s>\", HTML_N_S);\n    if (obuf->in_ins)\n\tpush_tag(obuf, \"</ins>\", HTML_N_INS);\n    bzero(obuf->fontstat, FONTSTAT_SIZE);\n}", "target": 0}
{"code": "static void llcp_sock_destruct(struct sock *sk)\n{\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tpr_debug(\"%p\\n\", sk);\n\tif (sk->sk_state == LLCP_CONNECTED)\n\t\tnfc_put_device(llcp_sock->dev);\n\tskb_queue_purge(&sk->sk_receive_queue);\n\tnfc_llcp_sock_free(llcp_sock);\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tpr_err(\"Freeing alive NFC LLCP socket %p\\n\", sk);\n\t\treturn;\n\t}\n}", "target": 0}
{"code": "static void show_object(struct object *obj,\n\t\t\tstruct strbuf *path, const char *component,\n\t\t\tvoid *cb_data)\n{\n\tstruct rev_list_info *info = cb_data;\n\tfinish_object(obj, path, component, cb_data);\n\tif (info->flags & REV_LIST_QUIET)\n\t\treturn;\n\tshow_object_with_name(stdout, obj, path, component);\n}", "target": 1}
{"code": "Goffset JPXStream::getPos() {\n  return priv->counter * priv->ncomps + priv->ccounter;\n}", "target": 0}
{"code": "static MagickBooleanType CheckPrimitiveExtent(MVGInfo *mvg_info,\n  const double pad)\n{\n  double\n    extent;\n  size_t\n    quantum;\n  quantum=sizeof(**mvg_info->primitive_info);\n  extent=(double) mvg_info->offset+pad+(PrimitiveExtentPad+1)*quantum;\n  if (extent <= (double) *mvg_info->extent)\n    return(MagickTrue);\n  if (extent == (double) CastDoubleToLong(extent))\n    {\n      *mvg_info->primitive_info=(PrimitiveInfo *) ResizeQuantumMemory(\n        *mvg_info->primitive_info,(size_t) (extent+1),quantum);\n      if (*mvg_info->primitive_info != (PrimitiveInfo *) NULL)\n        {\n          ssize_t\n            i;\n          *mvg_info->extent=(size_t) extent;\n          for (i=mvg_info->offset+1; i <= (ssize_t) extent; i++)\n          {\n            (*mvg_info->primitive_info)[i].primitive=UndefinedPrimitive;\n            (*mvg_info->primitive_info)[i].text=(char *) NULL;\n          }\n          return(MagickTrue);\n        }\n    }\n  (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n    ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n  if (*mvg_info->primitive_info != (PrimitiveInfo *) NULL)\n    *mvg_info->primitive_info=(PrimitiveInfo *) RelinquishMagickMemory(\n      *mvg_info->primitive_info);\n  *mvg_info->primitive_info=(PrimitiveInfo *) AcquireCriticalMemory((size_t) (\n    (PrimitiveExtentPad+1)*quantum));\n  (void) memset(*mvg_info->primitive_info,0,(size_t) ((PrimitiveExtentPad+1)*\n    quantum));\n  *mvg_info->extent=1;\n  mvg_info->offset=0;\n  return(MagickFalse);\n}", "target": 0}
{"code": "struct tcp_conn_t *tcp_conn_select(struct tcp_sock_t *sock,\n\t\t\t\t   struct tcp_sock_t *sock6)\n{\n\tstruct tcp_conn_t *conn = calloc(1, sizeof *conn);\n\tif (conn == NULL) {\n\t\tERR(\"Calloc for connection struct failed\");\n\t\tgoto error;\n\t}\n\tfd_set rfds;\n\tstruct timeval tv;\n\tint retval = 0;\n\tint nfds = 0;\n\twhile (retval == 0) {\n\t\tFD_ZERO(&rfds);\n\t\tif (sock) {\n\t\t\tFD_SET(sock->sd, &rfds);\n\t\t\tnfds = sock->sd;\n\t\t}\n\t\tif (sock6) {\n\t\t\tFD_SET(sock6->sd, &rfds);\n\t\t\tif (sock6->sd > nfds)\n\t\t\t\tnfds = sock6->sd;\n\t\t}\n\t\tif (nfds == 0) {\n\t\t\tERR(\"No valid TCP socket supplied.\");\n\t\t\tgoto error;\n\t\t}\n\t\tnfds += 1;\n\t\ttv.tv_sec = 5;\n\t\ttv.tv_usec = 0;\n\t\tretval = select(nfds, &rfds, NULL, NULL, &tv);\n\t\tif (retval == -1) {\n\t\t\tERR(\"Failed to open tcp connection\");\n\t\t\tgoto error;\n\t\t}\n\t}\n\tif (sock && FD_ISSET(sock->sd, &rfds)) {\n\t\tconn->sd = accept(sock->sd, NULL, NULL);\n\t\tNOTE (\"Using IPv4\");\n\t} else if (sock6 && FD_ISSET(sock6->sd, &rfds)) {\n\t\tconn->sd = accept(sock6->sd, NULL, NULL);\n\t\tNOTE (\"Using IPv6\");\n\t} else {\n\t\tERR(\"select failed\");\n\t\tgoto error;\n\t}\n\tif (conn->sd < 0) {\n\t\tERR(\"accept failed\");\n\t\tgoto error;\n\t}\n\treturn conn;\nerror:\n\tif (conn != NULL)\n\t\tfree(conn);\n\treturn NULL;\n}", "target": 0}
{"code": "grub_username_get (char buf[], unsigned buf_size)\n{\n  unsigned cur_len = 0;\n  int key;\n  while (1)\n    {\n      key = grub_getkey (); \n      if (key == '\\n' || key == '\\r')\n\tbreak;\n      if (key == '\\e')\n\t{\n\t  cur_len = 0;\n\t  break;\n\t}\n      if (key == '\\b')\n\t{\n\t  cur_len--;\n\t  grub_printf (\"\\b\");\n\t  continue;\n\t}\n      if (!grub_isprint (key))\n\tcontinue;\n      if (cur_len + 2 < buf_size)\n\t{\n\t  buf[cur_len++] = key;\n\t  grub_printf (\"%c\", key);\n\t}\n    }\n  grub_memset (buf + cur_len, 0, buf_size - cur_len);\n  grub_xputs (\"\\n\");\n  grub_refresh ();\n  return (key != '\\e');\n}", "target": 1}
{"code": "int input_set_keycode(struct input_dev *dev,\n\t\t      const struct input_keymap_entry *ke)\n{\n\tunsigned long flags;\n\tunsigned int old_keycode;\n\tint retval;\n\tif (ke->keycode > KEY_MAX)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\tretval = dev->setkeycode(dev, ke, &old_keycode);\n\tif (retval)\n\t\tgoto out;\n\t__clear_bit(KEY_RESERVED, dev->keybit);\n\tif (test_bit(EV_KEY, dev->evbit) &&\n\t    !is_event_supported(old_keycode, dev->keybit, KEY_MAX) &&\n\t    __test_and_clear_bit(old_keycode, dev->key)) {\n\t\tstruct input_value vals[] =  {\n\t\t\t{ EV_KEY, old_keycode, 0 },\n\t\t\tinput_value_sync\n\t\t};\n\t\tinput_pass_values(dev, vals, ARRAY_SIZE(vals));\n\t}\n out:\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\treturn retval;\n}", "target": 1}
{"code": "gtime2generalTime(time_t gtime, char *str_time, size_t str_time_size)\n{\n\tsize_t ret;\n\tstruct tm _tm;\n\tif (gtime == (time_t)-1\n#if SIZEOF_LONG == 8\n\t\t|| gtime >= 253402210800\n#endif\n\t ) {\n        \tsnprintf(str_time, str_time_size, \"99991231235959Z\");\n        \treturn 0;\n\t}\n\tif (!gmtime_r(&gtime, &_tm)) {\n\t\tgnutls_assert();\n\t\treturn GNUTLS_E_INTERNAL_ERROR;\n\t}\n\tret = strftime(str_time, str_time_size, \"%Y%m%d%H%M%SZ\", &_tm);\n\tif (!ret) {\n\t\tgnutls_assert();\n\t\treturn GNUTLS_E_SHORT_MEMORY_BUFFER;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int sr9700_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\n{\n\tstruct sk_buff *sr_skb;\n\tint len;\n\tif (unlikely(skb->len < SR_RX_OVERHEAD)) {\n\t\tnetdev_err(dev->net, \"unexpected tiny rx frame\\n\");\n\t\treturn 0;\n\t}\n\twhile (skb->len > SR_RX_OVERHEAD) {\n\t\tif (skb->data[0] != 0x40)\n\t\t\treturn 0;\n\t\tlen = (skb->data[1] | (skb->data[2] << 8)) - 4;\n\t\tif (len > ETH_FRAME_LEN || len > skb->len)\n\t\t\treturn 0;\n\t\tif (skb->len == (len + SR_RX_OVERHEAD))\t{\n\t\t\tskb_pull(skb, 3);\n\t\t\tskb->len = len;\n\t\t\tskb_set_tail_pointer(skb, len);\n\t\t\tskb->truesize = len + sizeof(struct sk_buff);\n\t\t\treturn 2;\n\t\t}\n\t\tsr_skb = skb_clone(skb, GFP_ATOMIC);\n\t\tif (!sr_skb)\n\t\t\treturn 0;\n\t\tsr_skb->len = len;\n\t\tsr_skb->data = skb->data + 3;\n\t\tskb_set_tail_pointer(sr_skb, len);\n\t\tsr_skb->truesize = len + sizeof(struct sk_buff);\n\t\tusbnet_skb_return(dev, sr_skb);\n\t\tskb_pull(skb, len + SR_RX_OVERHEAD);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "MagickPrivate void LocaleComponentTerminus(void)\n{\n  if (locale_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&locale_semaphore);\n  LockSemaphoreInfo(locale_semaphore);\n  if (locale_cache != (SplayTreeInfo *) NULL)\n    locale_cache=DestroySplayTree(locale_cache);\n#if defined(MAGICKCORE_LOCALE_SUPPORT)\n  DestroyCLocale();\n#endif\n  UnlockSemaphoreInfo(locale_semaphore);\n  RelinquishSemaphoreInfo(&locale_semaphore);\n}", "target": 0}
{"code": "static void credential_write_item(FILE *fp, const char *key, const char *value)\n{\n\tif (!value)\n\t\treturn;\n\tfprintf(fp, \"%s=%s\\n\", key, value);\n}", "target": 1}
{"code": "NTSTATUS ldapsrv_queue_reply(struct ldapsrv_call *call, struct ldapsrv_reply *reply)\n{\n\tNTSTATUS status = ldapsrv_encode(call, reply);\n\tif (!NT_STATUS_IS_OK(status)) {\n\t\treturn status;\n\t}\n\tif (call->reply_size > call->reply_size + reply->blob.length\n\t    || call->reply_size + reply->blob.length > LDAP_SERVER_MAX_REPLY_SIZE) {\n\t\tDBG_WARNING(\"Refusing to queue LDAP search response size \"\n\t\t\t    \"of more than %zu bytes\\n\",\n\t\t\t    LDAP_SERVER_MAX_REPLY_SIZE);\n\t\tTALLOC_FREE(reply->blob.data);\n\t\treturn NT_STATUS_FILE_TOO_LARGE;\n\t}\n\tcall->reply_size += reply->blob.length;\n\tDLIST_ADD_END(call->replies, reply);\n\treturn status;\n}", "target": 0}
{"code": "mrb_prev_pc(codegen_scope *s, const mrb_code *pc)\n{\n  const mrb_code *prev_pc = NULL;\n  const mrb_code *i = s->iseq;\n  while (i<pc) {\n    uint8_t insn = i[0];\n    prev_pc = i;\n    switch (insn) {\n    case OP_EXT1:\n      i += mrb_insn_size1[i[1]] + 1;\n      break;\n    case OP_EXT2:\n      i += mrb_insn_size2[i[1]] + 1;\n      break;\n    case OP_EXT3:\n      i += mrb_insn_size3[i[1]] + 1;\n      break;\n    default:\n      i += mrb_insn_size[insn];\n      break;\n    }\n  }\n  return prev_pc;\n}", "target": 0}
{"code": "static void cfg_free_opt_array(cfg_opt_t *opts)\n{\n\tint i;\n\tfor (i = 0; opts[i].name; ++i) {\n\t\tfree((void *)opts[i].name);\n\t\tif (opts[i].comment)\n\t\t\tfree(opts[i].comment);\n\t\tif (opts[i].def.parsed)\n\t\t\tfree(opts[i].def.parsed);\n\t\tif (opts[i].def.string)\n\t\t\tfree((void *)opts[i].def.string);\n\t\tif (opts[i].subopts)\n\t\t\tcfg_free_opt_array(opts[i].subopts);\n\t}\n\tfree(opts);\n}", "target": 0}
{"code": "sg_vma_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tSg_fd *sfp;\n\tunsigned long offset, len, sa;\n\tSg_scatter_hold *rsv_schp;\n\tint k, length;\n\tif ((NULL == vma) || (!(sfp = (Sg_fd *) vma->vm_private_data)))\n\t\treturn VM_FAULT_SIGBUS;\n\trsv_schp = &sfp->reserve;\n\toffset = vmf->pgoff << PAGE_SHIFT;\n\tif (offset >= rsv_schp->bufflen)\n\t\treturn VM_FAULT_SIGBUS;\n\tSCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t\t      \"sg_vma_fault: offset=%lu, scatg=%d\\n\",\n\t\t\t\t      offset, rsv_schp->k_use_sg));\n\tsa = vma->vm_start;\n\tlength = 1 << (PAGE_SHIFT + rsv_schp->page_order);\n\tfor (k = 0; k < rsv_schp->k_use_sg && sa < vma->vm_end; k++) {\n\t\tlen = vma->vm_end - sa;\n\t\tlen = (len < length) ? len : length;\n\t\tif (offset < len) {\n\t\t\tstruct page *page = nth_page(rsv_schp->pages[k],\n\t\t\t\t\t\t     offset >> PAGE_SHIFT);\n\t\t\tget_page(page);\t\n\t\t\tvmf->page = page;\n\t\t\treturn 0; \n\t\t}\n\t\tsa += len;\n\t\toffset -= len;\n\t}\n\treturn VM_FAULT_SIGBUS;\n}", "target": 0}
{"code": "mm_answer_pam_start(int socket, Buffer *m)\n{\n\tchar *user;\n\tuser = buffer_get_string(m, NULL);\n\tstart_pam(user);\n\txfree(user);\n\treturn (0);\n}", "target": 0}
{"code": "test_function (char * (*my_asnprintf) (char *, size_t *, const char *, ...))\n{\n  char buf[8];\n  int size;\n  for (size = 0; size <= 8; size++)\n    {\n      size_t length = size;\n      char *result = my_asnprintf (NULL, &length, \"%d\", 12345);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"12345\") == 0);\n      ASSERT (length == 5);\n      free (result);\n    }\n  for (size = 0; size <= 8; size++)\n    {\n      size_t length;\n      char *result;\n      memcpy (buf, \"DEADBEEF\", 8);\n      length = size;\n      result = my_asnprintf (buf, &length, \"%d\", 12345);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"12345\") == 0);\n      ASSERT (length == 5);\n      if (size < 6)\n        ASSERT (result != buf);\n      ASSERT (memcmp (buf + size, &\"DEADBEEF\"[size], 8 - size) == 0);\n      if (result != buf)\n        free (result);\n    }\n}", "target": 1}
{"code": "static struct nfs4_state *nfs4_try_open_cached(struct nfs4_opendata *opendata)\n{\n\tstruct nfs4_state *state = opendata->state;\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tstruct nfs_delegation *delegation;\n\tint open_mode = opendata->o_arg.open_flags & (FMODE_READ|FMODE_WRITE|O_EXCL);\n\tnfs4_stateid stateid;\n\tint ret = -EAGAIN;\n\tfor (;;) {\n\t\tif (can_open_cached(state, open_mode)) {\n\t\t\tspin_lock(&state->owner->so_lock);\n\t\t\tif (can_open_cached(state, open_mode)) {\n\t\t\t\tupdate_open_stateflags(state, open_mode);\n\t\t\t\tspin_unlock(&state->owner->so_lock);\n\t\t\t\tgoto out_return_state;\n\t\t\t}\n\t\t\tspin_unlock(&state->owner->so_lock);\n\t\t}\n\t\trcu_read_lock();\n\t\tdelegation = rcu_dereference(nfsi->delegation);\n\t\tif (delegation == NULL ||\n\t\t    !can_open_delegated(delegation, open_mode)) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(stateid.data, delegation->stateid.data, sizeof(stateid.data));\n\t\trcu_read_unlock();\n\t\tret = nfs_may_open(state->inode, state->owner->so_cred, open_mode);\n\t\tif (ret != 0)\n\t\t\tgoto out;\n\t\tret = -EAGAIN;\n\t\tif (update_open_stateid(state, NULL, &stateid, open_mode))\n\t\t\tgoto out_return_state;\n\t}\nout:\n\treturn ERR_PTR(ret);\nout_return_state:\n\tatomic_inc(&state->count);\n\treturn state;\n}", "target": 1}
{"code": "static void nft_objref_map_activate(const struct nft_ctx *ctx,\n\t\t\t\t    const struct nft_expr *expr)\n{\n\tstruct nft_objref_map *priv = nft_expr_priv(expr);\n\tpriv->set->use++;\n}", "target": 1}
{"code": "char *path_name(const struct name_path *path, const char *name)\n{\n\tconst struct name_path *p;\n\tchar *n, *m;\n\tint nlen = strlen(name);\n\tint len = nlen + 1;\n\tfor (p = path; p; p = p->up) {\n\t\tif (p->elem_len)\n\t\t\tlen += p->elem_len + 1;\n\t}\n\tn = xmalloc(len);\n\tm = n + len - (nlen + 1);\n\tstrcpy(m, name);\n\tfor (p = path; p; p = p->up) {\n\t\tif (p->elem_len) {\n\t\t\tm -= p->elem_len + 1;\n\t\t\tmemcpy(m, p->elem, p->elem_len);\n\t\t\tm[p->elem_len] = '/';\n\t\t}\n\t}\n\treturn n;\n}", "target": 1}
{"code": "static char* getPreferredTag(const char* gf_tag)\n{ \n\tchar* result = NULL;\n\tint grOffset = 0;\n\tgrOffset = findOffset( LOC_GRANDFATHERED ,gf_tag);\n\tif(grOffset < 0) {\n\t\treturn NULL;\n\t}\n\tif( grOffset < LOC_PREFERRED_GRANDFATHERED_LEN ){\n\t\tresult = estrdup( LOC_PREFERRED_GRANDFATHERED[grOffset] );\n\t} else {\n\t\tresult = estrdup( LOC_GRANDFATHERED[grOffset] );\n\t}\n\treturn result;\n}", "target": 1}
{"code": "int unlinkat_harder(int dfd, const char *filename, int unlink_flags, RemoveFlags remove_flags) {\n        mode_t old_mode;\n        int r;\n        if (unlinkat(dfd, filename, unlink_flags) >= 0)\n                return 0;\n        if (errno != EACCES || !FLAGS_SET(remove_flags, REMOVE_CHMOD))\n                return -errno;\n        r = patch_dirfd_mode(dfd, &old_mode);\n        if (r < 0)\n                return r;\n        if (unlinkat(dfd, filename, unlink_flags) < 0) {\n                r = -errno;\n                (void) fchmod(dfd, old_mode);\n                return r;\n        }\n        if (FLAGS_SET(remove_flags, REMOVE_CHMOD_RESTORE) && fchmod(dfd, old_mode) < 0)\n                return -errno;\n        return 0;\n}", "target": 1}
{"code": "int compat_dccp_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t   char __user *optval, int optlen)\n{\n\tif (level != SOL_DCCP)\n\t\treturn inet_csk_compat_setsockopt(sk, level, optname,\n\t\t\t\t\t\t  optval, optlen);\n\treturn do_dccp_setsockopt(sk, level, optname, optval, optlen);\n}", "target": 0}
{"code": "static int buffer_chain_size(void)\n{\n\tstruct bio_vec bv;\n\tint size;\n\tstruct req_iterator iter;\n\tchar *base;\n\tbase = bio_data(current_req->bio);\n\tsize = 0;\n\trq_for_each_segment(bv, current_req, iter) {\n\t\tif (page_address(bv.bv_page) + bv.bv_offset != base + size)\n\t\t\tbreak;\n\t\tsize += bv.bv_len;\n\t}\n\treturn size >> 9;\n}", "target": 0}
{"code": "NEDMALLOCNOALIASATTR NEDMALLOCPTRATTR void * nedpcalloc(nedpool *p, size_t no, size_t size) THROWSPEC\n{\n\tunsigned flags=NEDMALLOC_FORCERESERVE(p, 0, no*size);\n\treturn nedpmalloc2(p, size*no, 0, M2_ZERO_MEMORY|flags);\n}", "target": 1}
{"code": "static freelist_idx_t next_random_slot(union freelist_init_state *state)\n{\n\treturn (state->list[state->pos++] + state->rand) % state->count;\n}", "target": 1}
{"code": "static bool imap_client_input_next_cmd(struct client *_client)\n{\n\tstruct imap_client *client = (struct imap_client *)_client;\n\tconst struct imap_arg *args;\n\tbool parsed;\n\tint ret;\n\tif (strcasecmp(client->cmd_name, \"AUTHENTICATE\") == 0) {\n\t\tret = cmd_authenticate(client, &parsed);\n\t\tif (ret == 0 && !parsed)\n\t\t\treturn FALSE;\n\t} else if (strcasecmp(client->cmd_name, \"ID\") == 0) {\n\t\tret = cmd_id(client);\n\t\tif (ret == 0)\n\t\t\treturn FALSE;\n\t\tif (ret < 0)\n\t\t\tret = 1; \n\t} else {\n\t\tret = client_parse_command(client, &args);\n\t\tif (ret < 0)\n\t\t\treturn TRUE;\n\t\tif (ret == 0)\n\t\t\treturn FALSE;\n\t\tret = *client->cmd_tag == '\\0' ? -1 :\n\t\t\tclient_command_execute(client, client->cmd_name, args);\n\t}\n\tclient->cmd_finished = TRUE;\n\tif (ret == -2 && strcasecmp(client->cmd_tag, \"LOGIN\") == 0) {\n\t\tclient_send_reply(&client->common, IMAP_CMD_REPLY_BAD,\n\t\t\t\"First parameter in line is IMAP's command tag, \"\n\t\t\t\"not the command name. Add that before the command, \"\n\t\t\t\"like: a login user pass\");\n\t} else if (ret < 0) {\n\t\tif (!client_invalid_command(client))\n\t\t\treturn FALSE;\n\t}\n\treturn ret != 0 && !client->common.destroyed;\n}", "target": 0}
{"code": "status_t MPEG4Extractor::parse3GPPMetaData(off64_t offset, size_t size, int depth) {\n if (size < 4 || size == SIZE_MAX) {\n return ERROR_MALFORMED;\n }\n uint8_t *buffer = new (std::nothrow) uint8_t[size + 1];\n if (buffer == NULL) {\n return ERROR_MALFORMED;\n }\n if (mDataSource->readAt(\n                offset, buffer, size) != (ssize_t)size) {\n delete[] buffer;\n        buffer = NULL;\n return ERROR_IO;\n }\n uint32_t metadataKey = 0;\n switch (mPath[depth]) {\n case FOURCC('t', 'i', 't', 'l'):\n {\n            metadataKey = kKeyTitle;\n break;\n }\n case FOURCC('p', 'e', 'r', 'f'):\n {\n            metadataKey = kKeyArtist;\n break;\n }\n case FOURCC('a', 'u', 't', 'h'):\n {\n            metadataKey = kKeyWriter;\n break;\n }\n case FOURCC('g', 'n', 'r', 'e'):\n {\n            metadataKey = kKeyGenre;\n break;\n }\n case FOURCC('a', 'l', 'b', 'm'):\n {\n if (buffer[size - 1] != '\\0') {\n char tmp[4];\n              sprintf(tmp, \"%u\", buffer[size - 1]);\n              mFileMetaData->setCString(kKeyCDTrackNumber, tmp);\n }\n            metadataKey = kKeyAlbum;\n break;\n }\n case FOURCC('y', 'r', 'r', 'c'):\n {\n char tmp[5];\n uint16_t year = U16_AT(&buffer[4]);\n if (year < 10000) {\n                sprintf(tmp, \"%u\", year);\n                mFileMetaData->setCString(kKeyYear, tmp);\n }\n break;\n }\n default:\n break;\n }\n if (metadataKey > 0) {\n bool isUTF8 = true; \n char16_t *framedata = NULL;\n         int len16 = 0; \n         if (size - 6 >= 4) {\n             len16 = ((size - 6) / 2) - 1; \n             framedata = (char16_t *)(buffer + 6);\n if (0xfffe == *framedata) {\n for (int i = 0; i < len16; i++) {\n                    framedata[i] = bswap_16(framedata[i]);\n }\n }\n if (0xfeff == *framedata) {\n                framedata++;\n                len16--;\n                isUTF8 = false;\n }\n }\n if (isUTF8) {\n            buffer[size] = 0;\n            mFileMetaData->setCString(metadataKey, (const char *)buffer + 6);\n } else {\n String8 tmpUTF8str(framedata, len16);\n            mFileMetaData->setCString(metadataKey, tmpUTF8str.string());\n }\n }\n delete[] buffer;\n    buffer = NULL;\n return OK;\n}", "target": 1}
{"code": "void bio_trim(struct bio *bio, int offset, int size)\n{\n\tsize <<= 9;\n\tif (offset == 0 && size == bio->bi_iter.bi_size)\n\t\treturn;\n\tbio_clear_flag(bio, BIO_SEG_VALID);\n\tbio_advance(bio, offset << 9);\n\tbio->bi_iter.bi_size = size;\n\tif (bio_integrity(bio))\n\t\tbio_integrity_trim(bio);\n}", "target": 0}
{"code": "    bool operator()(const StatsPartitionKey& a,\n                    const StatsPartitionKey& b) const {\n      if (a.node_id < b.node_id) {\n        return true;\n      }\n      if ((a.node_id == b.node_id) && (a.feature_dim < b.feature_dim)) {\n        return true;\n      }\n      if ((a.node_id == b.node_id) && (a.feature_dim == b.feature_dim) &&\n          (a.bucket_id < b.bucket_id)) {\n        return true;\n      }\n      return false;\n    }", "target": 0}
{"code": "bool Matrix::invertTo(Matrix *other) const\n{\n    const double det_denominator = determinant();\n    if (unlikely(det_denominator == 0)) {\n        *other = { 1, 0, 0, 1, 0, 0 };\n        return false;\n    }\n    const double det = 1 / det_denominator;\n    other->m[0] = m[3] * det;\n    other->m[1] = -m[1] * det;\n    other->m[2] = -m[2] * det;\n    other->m[3] = m[0] * det;\n    other->m[4] = (m[2] * m[5] - m[3] * m[4]) * det;\n    other->m[5] = (m[1] * m[4] - m[0] * m[5]) * det;\n    return true;\n}", "target": 0}
{"code": "static int io_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_vcpu *vcpu = &svm->vcpu;\n\tu32 io_info = svm->vmcb->control.exit_info_1; \n\tint size, in, string;\n\tunsigned port;\n\t++svm->vcpu.stat.io_exits;\n\tstring = (io_info & SVM_IOIO_STR_MASK) != 0;\n\tin = (io_info & SVM_IOIO_TYPE_MASK) != 0;\n\tif (string || in)\n\t\treturn emulate_instruction(vcpu, 0) == EMULATE_DONE;\n\tport = io_info >> 16;\n\tsize = (io_info & SVM_IOIO_SIZE_MASK) >> SVM_IOIO_SIZE_SHIFT;\n\tsvm->next_rip = svm->vmcb->control.exit_info_2;\n\tskip_emulated_instruction(&svm->vcpu);\n\treturn kvm_fast_pio_out(vcpu, size, port);\n}", "target": 0}
{"code": "static int activate(AVFilterContext *ctx)\n{\n    AVFilterLink *inlink = ctx->inputs[0];\n    AVFilterLink *outlink = ctx->outputs[0];\n    AudioFWTDNContext *s = ctx->priv;\n    AVFrame *in = NULL;\n    int ret, status;\n    int64_t pts;\n    FF_FILTER_FORWARD_STATUS_BACK(outlink, inlink);\n    ret = ff_inlink_consume_samples(inlink, s->nb_samples, s->nb_samples, &in);\n    if (ret < 0)\n        return ret;\n    if (ret > 0)\n        return filter_frame(inlink, in);\n    if (ff_inlink_acknowledge_status(inlink, &status, &pts)) {\n        if (status == AVERROR_EOF) {\n            while (s->padd_samples != 0) {\n                ret = filter_frame(inlink, NULL);\n                if (ret < 0)\n                    return ret;\n            }\n            ff_outlink_set_status(outlink, status, pts);\n            return ret;\n        }\n    }\n    FF_FILTER_FORWARD_WANTED(outlink, inlink);\n    return FFERROR_NOT_READY;\n}", "target": 1}
{"code": "void av_fast_padded_malloc(void *ptr, unsigned int *size, size_t min_size)\n{\n    uint8_t **p = ptr;\n    if (min_size > SIZE_MAX - FF_INPUT_BUFFER_PADDING_SIZE) {\n        av_freep(p);\n        *size = 0;\n        return;\n    }\n    if (!ff_fast_malloc(p, size, min_size + FF_INPUT_BUFFER_PADDING_SIZE, 1))\n        memset(*p + min_size, 0, FF_INPUT_BUFFER_PADDING_SIZE);\n}", "target": 0}
{"code": "bool CSPSource::schemeMatches(const KURL& url) const\n {\n     if (m_scheme.isEmpty())\n         return m_policy->protocolMatchesSelf(url);\n    if (equalIgnoringCase(m_scheme, \"http\"))\n        return equalIgnoringCase(url.protocol(), \"http\") || equalIgnoringCase(url.protocol(), \"https\");\n    if (equalIgnoringCase(m_scheme, \"ws\"))\n        return equalIgnoringCase(url.protocol(), \"ws\") || equalIgnoringCase(url.protocol(), \"wss\");\n     return equalIgnoringCase(url.protocol(), m_scheme);\n }", "target": 0}
{"code": "static int ptrace_check_attach(struct task_struct *child, bool ignore_state)\n{\n\tint ret = -ESRCH;\n\tread_lock(&tasklist_lock);\n\tif ((child->ptrace & PT_PTRACED) && child->parent == current) {\n\t\tspin_lock_irq(&child->sighand->siglock);\n\t\tWARN_ON_ONCE(task_is_stopped(child));\n\t\tif (ignore_state || (task_is_traced(child) &&\n\t\t\t\t     !(child->jobctl & JOBCTL_LISTENING)))\n\t\t\tret = 0;\n\t\tspin_unlock_irq(&child->sighand->siglock);\n\t}\n\tread_unlock(&tasklist_lock);\n\tif (!ret && !ignore_state)\n\t\tret = wait_task_inactive(child, TASK_TRACED) ? 0 : -ESRCH;\n\treturn ret;\n}", "target": 1}
{"code": "static int link_pipe(struct pipe_inode_info *ipipe,\n\t\t     struct pipe_inode_info *opipe,\n\t\t     size_t len, unsigned int flags)\n{\n\tstruct pipe_buffer *ibuf, *obuf;\n\tint ret = 0, i = 0, nbuf;\n\tpipe_double_lock(ipipe, opipe);\n\tdo {\n\t\tif (!opipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\t\tif (i >= ipipe->nrbufs || opipe->nrbufs >= opipe->buffers)\n\t\t\tbreak;\n\t\tibuf = ipipe->bufs + ((ipipe->curbuf + i) & (ipipe->buffers-1));\n\t\tnbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);\n\t\tpipe_buf_get(ipipe, ibuf);\n\t\tobuf = opipe->bufs + nbuf;\n\t\t*obuf = *ibuf;\n\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\t\tif (obuf->len > len)\n\t\t\tobuf->len = len;\n\t\topipe->nrbufs++;\n\t\tret += obuf->len;\n\t\tlen -= obuf->len;\n\t\ti++;\n\t} while (len);\n\tif (!ret && ipipe->waiting_writers && (flags & SPLICE_F_NONBLOCK))\n\t\tret = -EAGAIN;\n\tpipe_unlock(ipipe);\n\tpipe_unlock(opipe);\n\tif (ret > 0)\n\t\twakeup_pipe_readers(opipe);\n\treturn ret;\n}", "target": 1}
{"code": "static Image *RenderHoughLines(const ImageInfo *image_info,const size_t columns,\n  const size_t rows,ExceptionInfo *exception)\n{\n#define BoundingBox  \"viewbox\"\n  DrawInfo\n    *draw_info;\n  Image\n    *image;\n  MagickBooleanType\n    status;\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  image->columns=columns;\n  image->rows=rows;\n  draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);\n  draw_info->affine.sx=image->resolution.x == 0.0 ? 1.0 : image->resolution.x/\n    DefaultResolution;\n  draw_info->affine.sy=image->resolution.y == 0.0 ? 1.0 : image->resolution.y/\n    DefaultResolution;\n  image->columns=(size_t) (draw_info->affine.sx*image->columns);\n  image->rows=(size_t) (draw_info->affine.sy*image->rows);\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  if (SetImageBackgroundColor(image,exception) == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (GetBlobStreamData(image) == (unsigned char *) NULL)\n    draw_info->primitive=FileToString(image->filename,~0UL,exception);\n  else\n    {\n      draw_info->primitive=(char *) AcquireMagickMemory((size_t)\n        GetBlobSize(image)+1);\n      if (draw_info->primitive != (char *) NULL)\n        {\n          (void) memcpy(draw_info->primitive,GetBlobStreamData(image),\n            (size_t) GetBlobSize(image));\n          draw_info->primitive[GetBlobSize(image)]='\\0';\n        }\n     }\n  (void) DrawImage(image,draw_info,exception);\n  draw_info=DestroyDrawInfo(draw_info);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}", "target": 0}
{"code": "int __parse_rtattr_nested_compat(struct rtattr *tb[], int max,\n\t\t\t\t struct rtattr *rta,\n\t\t\t\t int len)\n{\n\tif (RTA_PAYLOAD(rta) < len)\n\t\treturn -1;\n\tif (RTA_PAYLOAD(rta) >= RTA_ALIGN(len) + sizeof(struct rtattr)) {\n\t\trta = RTA_DATA(rta) + RTA_ALIGN(len);\n\t\treturn parse_rtattr_nested(tb, max, rta);\n\t}\n\tmemset(tb, 0, sizeof(struct rtattr *) * (max + 1));\n\treturn 0;\n}", "target": 0}
{"code": "BOOL update_write_cache_bitmap_v3_order(wStream* s, CACHE_BITMAP_V3_ORDER* cache_bitmap_v3,\n                                        UINT16* flags)\n{\n\tBYTE bitsPerPixelId;\n\tBITMAP_DATA_EX* bitmapData;\n\tif (!Stream_EnsureRemainingCapacity(\n\t        s, update_approximate_cache_bitmap_v3_order(cache_bitmap_v3, flags)))\n\t\treturn FALSE;\n\tbitmapData = &cache_bitmap_v3->bitmapData;\n\tbitsPerPixelId = BPP_CBR23[cache_bitmap_v3->bpp];\n\t*flags = (cache_bitmap_v3->cacheId & 0x00000003) |\n\t         ((cache_bitmap_v3->flags << 7) & 0x0000FF80) | ((bitsPerPixelId << 3) & 0x00000078);\n\tStream_Write_UINT16(s, cache_bitmap_v3->cacheIndex); \n\tStream_Write_UINT32(s, cache_bitmap_v3->key1);       \n\tStream_Write_UINT32(s, cache_bitmap_v3->key2);       \n\tStream_Write_UINT8(s, bitmapData->bpp);\n\tStream_Write_UINT8(s, 0);                   \n\tStream_Write_UINT8(s, 0);                   \n\tStream_Write_UINT8(s, bitmapData->codecID); \n\tStream_Write_UINT16(s, bitmapData->width);  \n\tStream_Write_UINT16(s, bitmapData->height); \n\tStream_Write_UINT32(s, bitmapData->length); \n\tStream_Write(s, bitmapData->data, bitmapData->length);\n\treturn TRUE;\n}", "target": 1}
{"code": "static inline struct old_rng_alg *crypto_old_rng_alg(struct crypto_rng *tfm)\n{\n\treturn &crypto_rng_tfm(tfm)->__crt_alg->cra_rng;\n}", "target": 1}
{"code": "MP4::Properties::bitrate() const\n{\n  return d->bitrate;\n}", "target": 0}
{"code": "TEST(GifTest, Gif) {\n  Env* env = Env::Default();\n  const string testdata_path = kTestData;\n  std::vector<DecodeGifTestCase> testcases(\n      {\n       {testdata_path + \"lena.gif\", 1, 51, 26, 3},\n       {testdata_path + \"optimized.gif\", 12, 20, 40, 3},\n       {testdata_path + \"red_black.gif\", 1, 16, 16, 3},\n       {testdata_path + \"scan.gif\", 12, 20, 40, 3},\n       {testdata_path + \"squares.gif\", 2, 16, 16, 3}});\n  for (const auto& tc : testcases) {\n    TestDecodeGif(env, tc);\n  }\n}", "target": 1}
{"code": "static inline void sctp_ulpq_store_reasm(struct sctp_ulpq *ulpq,\n\t\t\t\t\t struct sctp_ulpevent *event)\n{\n\tstruct sk_buff *pos;\n\tstruct sctp_ulpevent *cevent;\n\t__u32 tsn, ctsn;\n\ttsn = event->tsn;\n\tpos = skb_peek_tail(&ulpq->reasm);\n\tif (!pos) {\n\t\t__skb_queue_tail(&ulpq->reasm, sctp_event2skb(event));\n\t\treturn;\n\t}\n\tcevent = sctp_skb2event(pos);\n\tctsn = cevent->tsn;\n\tif (TSN_lt(ctsn, tsn)) {\n\t\t__skb_queue_tail(&ulpq->reasm, sctp_event2skb(event));\n\t\treturn;\n\t}\n\tskb_queue_walk(&ulpq->reasm, pos) {\n\t\tcevent = sctp_skb2event(pos);\n\t\tctsn = cevent->tsn;\n\t\tif (TSN_lt(tsn, ctsn))\n\t\t\tbreak;\n\t}\n\t__skb_insert(sctp_event2skb(event), pos->prev, pos, &ulpq->reasm);\n}", "target": 0}
{"code": "static int find_low_bit(unsigned int x)\n{\n\tint i;\n\tfor(i=0;i<=31;i++) {\n\t\tif(x&(1<<i)) return i;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void GfxDeviceCMYKColorSpace::getGray(const GfxColor *color, GfxGray *gray) const\n{\n    *gray = clip01((GfxColorComp)(gfxColorComp1 - color->c[3] - 0.3 * color->c[0] - 0.59 * color->c[1] - 0.11 * color->c[2] + 0.5));\n}", "target": 0}
{"code": "cgiSetArray(const char *name,\t\t\n            int        element,\t\t\n            const char *value)\t\t\n{\n  int\t\ti;\t\t\t\n  _cgi_var_t\t*var;\t\t\t\n  if (name == NULL || value == NULL || element < 0 || element > 100000)\n    return;\n  fprintf(stderr, \"DEBUG: cgiSetArray: %s[%d]=\\\"%s\\\"\\n\", name, element, value);\n  if ((var = cgi_find_variable(name)) == NULL)\n  {\n    cgi_add_variable(name, element, value);\n    cgi_sort_variables();\n  }\n  else\n  {\n    if (element >= var->avalues)\n    {\n      const char **temp;\t\t\n      temp = (const char **)realloc((void *)(var->values),\n                                    sizeof(char *) * (size_t)(element + 16));\n      if (!temp)\n        return;\n      var->avalues = element + 16;\n      var->values  = temp;\n    }\n    if (element >= var->nvalues)\n    {\n      for (i = var->nvalues; i < element; i ++)\n\tvar->values[i] = NULL;\n      var->nvalues = element + 1;\n    }\n    else if (var->values[element])\n      _cupsStrFree((char *)var->values[element]);\n    var->values[element] = _cupsStrAlloc(value);\n  }\n}", "target": 0}
{"code": "static int scantag(const char* in, char* buffer, int* lenp) {\n    int len;\n    for (len = 0; len < 128; len++) {\n        const char c = *in++;\n        switch (c) {\n        case '\\0':\n            return 0;\n        case '<':\n            return 0;\n        case '>':\n            buffer[len] = '\\0';\n            *lenp = len+1;\n            return 1;\n        default:\n            break;\n        }\n        buffer[len] = c;\n    }\n    return 0;\n}", "target": 0}
{"code": "static int set_register(pegasus_t *pegasus, __u16 indx, __u8 data)\n{\n\tint ret;\n\tret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_SET_REG, PEGASUS_REQT_WRITE, data,\n\t\t\t      indx, &data, 1, 1000);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\treturn ret;\n}", "target": 1}
{"code": "MP4::Properties::length() const\n{\n  return d->length;\n}", "target": 0}
{"code": "evbuffer_add(struct evbuffer *buf, const void *data, size_t datlen)\n{\n\tsize_t need = buf->misalign + buf->off + datlen;\n\tsize_t oldoff = buf->off;\n\tif (buf->totallen < need) {\n\t\tif (evbuffer_expand(buf, datlen) == -1)\n\t\t\treturn (-1);\n\t}\n\tmemcpy(buf->buffer + buf->off, data, datlen);\n\tbuf->off += datlen;\n\tif (datlen && buf->cb != NULL)\n\t\t(*buf->cb)(buf, oldoff, buf->off, buf->cbarg);\n\treturn (0);\n}", "target": 1}
{"code": "void hid_reset(HIDState *hs)\n{\n    switch (hs->kind) {\n    case HID_KEYBOARD:\n        memset(hs->kbd.keycodes, 0, sizeof(hs->kbd.keycodes));\n        memset(hs->kbd.key, 0, sizeof(hs->kbd.key));\n        hs->kbd.keys = 0;\n        break;\n    case HID_MOUSE:\n    case HID_TABLET:\n        memset(hs->ptr.queue, 0, sizeof(hs->ptr.queue));\n        break;\n    }\n    hs->head = 0;\n    hs->n = 0;\n    hs->protocol = 1;\n    hs->idle = 0;\n    hs->idle_pending = false;\n    hid_del_idle_timer(hs);\n}", "target": 1}
{"code": "void PDFiumEngine::PostPaint() {\n  for (size_t i = 0; i < progressive_paints_.size(); ++i) {\n    if (progressive_paints_[i].painted_)\n      continue;\n    FPDF_RenderPage_Close(\n        pages_[progressive_paints_[i].page_index]->GetPage());\n    FPDFBitmap_Destroy(progressive_paints_[i].bitmap);\n    progressive_paints_.erase(progressive_paints_.begin() + i);\n    --i;\n  }\n}", "target": 0}
{"code": "struct rad_packet_t *rad_packet_alloc(int code)\n{\n\tstruct rad_packet_t *pack;\n\tpack = mempool_alloc(packet_pool);\n\tif (!pack) {\n\t\tlog_emerg(\"radius:packet: out of memory\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(pack, 0, sizeof(*pack));\n\tpack->code = code;\n\tpack->len = 20;\n\tpack->id = 1;\n\tINIT_LIST_HEAD(&pack->attrs);\n\treturn pack;\n}", "target": 0}
{"code": "static void vmx_set_constant_host_state(struct vcpu_vmx *vmx)\n{\n\tu32 low32, high32;\n\tunsigned long tmpl;\n\tstruct desc_ptr dt;\n\tunsigned long cr4;\n\tvmcs_writel(HOST_CR0, read_cr0() & ~X86_CR0_TS);  \n\tvmcs_writel(HOST_CR3, read_cr3());  \n\tcr4 = read_cr4();\n\tvmcs_writel(HOST_CR4, cr4);\t\t\t\n\tvmx->host_state.vmcs_host_cr4 = cr4;\n\tvmcs_write16(HOST_CS_SELECTOR, __KERNEL_CS);  \n#ifdef CONFIG_X86_64\n\tvmcs_write16(HOST_DS_SELECTOR, 0);\n\tvmcs_write16(HOST_ES_SELECTOR, 0);\n#else\n\tvmcs_write16(HOST_DS_SELECTOR, __KERNEL_DS);  \n\tvmcs_write16(HOST_ES_SELECTOR, __KERNEL_DS);  \n#endif\n\tvmcs_write16(HOST_SS_SELECTOR, __KERNEL_DS);  \n\tvmcs_write16(HOST_TR_SELECTOR, GDT_ENTRY_TSS*8);  \n\tnative_store_idt(&dt);\n\tvmcs_writel(HOST_IDTR_BASE, dt.address);   \n\tvmx->host_idt_base = dt.address;\n\tvmcs_writel(HOST_RIP, vmx_return); \n\trdmsr(MSR_IA32_SYSENTER_CS, low32, high32);\n\tvmcs_write32(HOST_IA32_SYSENTER_CS, low32);\n\trdmsrl(MSR_IA32_SYSENTER_EIP, tmpl);\n\tvmcs_writel(HOST_IA32_SYSENTER_EIP, tmpl);   \n\tif (vmcs_config.vmexit_ctrl & VM_EXIT_LOAD_IA32_PAT) {\n\t\trdmsr(MSR_IA32_CR_PAT, low32, high32);\n\t\tvmcs_write64(HOST_IA32_PAT, low32 | ((u64) high32 << 32));\n\t}\n}", "target": 0}
{"code": "t1mac_output_ascii(char *s, int len)\n{\n  if (blocktyp == POST_BINARY) {\n    output_current_post();\n    blocktyp = POST_ASCII;\n  }\n  if (len > 0 && s[len-1] == '\\n')\n    s[len-1] = '\\r';\n  t1mac_output_data((byte *)s, len);\n  if (strncmp(s, \"/FontName\", 9) == 0) {\n    for (s += 9; isspace(*s); s++) ;\n    if (*s == '/') {\n      const char *t = ++s;\n      while (*t && !isspace(*t)) t++;\n      free(font_name);\n      font_name = (char *)malloc(t - s + 1);\n      memcpy(font_name, s, t - s);\n      font_name[t - s] = 0;\n    }\n  }\n}", "target": 1}
{"code": "p2bit(UINT8 *out, const UINT8 *in, int xsize, const UINT8 *palette) {\n    int x;\n    for (x = 0; x < xsize; x++) {\n        *out++ = (L(&palette[in[x] * 4]) >= 128000) ? 255 : 0;\n    }\n}", "target": 0}
{"code": "build_ycc_rgb_table(j_decompress_ptr cinfo)\n{\n  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n  int i;\n  JLONG x;\n  SHIFT_TEMPS\n  upsample->Cr_r_tab = (int *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (MAXJSAMPLE + 1) * sizeof(int));\n  upsample->Cb_b_tab = (int *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (MAXJSAMPLE + 1) * sizeof(int));\n  upsample->Cr_g_tab = (JLONG *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (MAXJSAMPLE + 1) * sizeof(JLONG));\n  upsample->Cb_g_tab = (JLONG *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (MAXJSAMPLE + 1) * sizeof(JLONG));\n  for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {\n    upsample->Cr_r_tab[i] = (int)\n                    RIGHT_SHIFT(FIX(1.40200) * x + ONE_HALF, SCALEBITS);\n    upsample->Cb_b_tab[i] = (int)\n                    RIGHT_SHIFT(FIX(1.77200) * x + ONE_HALF, SCALEBITS);\n    upsample->Cr_g_tab[i] = (-FIX(0.71414)) * x;\n    upsample->Cb_g_tab[i] = (-FIX(0.34414)) * x + ONE_HALF;\n  }\n}", "target": 1}
{"code": "static int mxf_read_primer_pack(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFContext *mxf = arg;\n    int item_num = avio_rb32(pb);\n    int item_len = avio_rb32(pb);\n    if (item_len != 18) {\n        avpriv_request_sample(pb, \"Primer pack item length %d\", item_len);\n        return AVERROR_PATCHWELCOME;\n    }\n    if (item_num > 65536) {\n        av_log(mxf->fc, AV_LOG_ERROR, \"item_num %d is too large\\n\", item_num);\n        return AVERROR_INVALIDDATA;\n    }\n    mxf->local_tags = av_calloc(item_num, item_len);\n    if (!mxf->local_tags)\n        return AVERROR(ENOMEM);\n    mxf->local_tags_count = item_num;\n    avio_read(pb, mxf->local_tags, item_num*item_len);\n    return 0;\n}", "target": 1}
{"code": "static bool get_user_list(struct torture_context *torture, char ***users)\n{\n\tstruct winbindd_request req;\n\tstruct winbindd_response rep;\n\tchar **u = NULL;\n\tuint32_t count;\n\tchar name[256];\n\tconst char *extra_data;\n\tZERO_STRUCT(req);\n\tZERO_STRUCT(rep);\n\tDO_STRUCT_REQ_REP(WINBINDD_LIST_USERS, &req, &rep);\n\textra_data = (char *)rep.extra_data.data;\n\ttorture_assert(torture, extra_data, \"NULL extra data\");\n\tfor(count = 0;\n\t    next_token(&extra_data, name, \",\", sizeof(name));\n\t    count++)\n\t{\n\t\tu = talloc_realloc(torture, u, char *, count + 2);\n\t\tu[count+1] = NULL;\n\t\tu[count] = talloc_strdup(u, name);\n\t}\n\tSAFE_FREE(rep.extra_data.data);\n\t*users = u;\n\treturn true;\n}", "target": 0}
{"code": "RenderProcessHost* RenderFrameHostImpl::GetProcess() {\n  return render_view_host_->GetProcess();\n}", "target": 0}
{"code": "main_get_appheader (xd3_stream *stream, main_file *ifile,\n\t\t    main_file *output, main_file *sfile)\n{\n  uint8_t *apphead;\n  usize_t appheadsz;\n  int ret;\n  if (! option_use_appheader) { return; }\n  ret = xd3_get_appheader (stream, & apphead, & appheadsz);\n  if (ret != 0) { return; }\n  if (appheadsz > 0)\n    {\n      char *start = (char*)apphead;\n      char *slash;\n      int   place = 0;\n      char *parsed[4];\n      memset (parsed, 0, sizeof (parsed));\n      while ((slash = strchr (start, '/')) != NULL)\n\t{\n\t  *slash = 0;\n\t  parsed[place++] = start;\n\t  start = slash + 1;\n\t}\n      parsed[place++] = start;\n      if (place == 2 || place == 4)\n\t{\n\t  main_get_appheader_params (output, parsed, 1, \"output\", ifile);\n\t}\n      if (place == 4)\n\t{\n\t  main_get_appheader_params (sfile, parsed+2, 0, \"source\", ifile);\n\t}\n    }\n  option_use_appheader = 0;\n  return;\n}", "target": 1}
{"code": "static int ep_loop_check_proc(void *priv, void *cookie, int call_nests)\n{\n\tint error = 0;\n\tstruct file *file = priv;\n\tstruct eventpoll *ep = file->private_data;\n\tstruct eventpoll *ep_tovisit;\n\tstruct rb_node *rbp;\n\tstruct epitem *epi;\n\tmutex_lock_nested(&ep->mtx, call_nests + 1);\n\tep->visited = 1;\n\tlist_add(&ep->visited_list_link, &visited_list);\n\tfor (rbp = rb_first_cached(&ep->rbr); rbp; rbp = rb_next(rbp)) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\t\tif (unlikely(is_file_epoll(epi->ffd.file))) {\n\t\t\tep_tovisit = epi->ffd.file->private_data;\n\t\t\tif (ep_tovisit->visited)\n\t\t\t\tcontinue;\n\t\t\terror = ep_call_nested(&poll_loop_ncalls,\n\t\t\t\t\tep_loop_check_proc, epi->ffd.file,\n\t\t\t\t\tep_tovisit, current);\n\t\t\tif (error != 0)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (list_empty(&epi->ffd.file->f_tfile_llink)) {\n\t\t\t\tget_file(epi->ffd.file);\n\t\t\t\tlist_add(&epi->ffd.file->f_tfile_llink,\n\t\t\t\t\t &tfile_check_list);\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&ep->mtx);\n\treturn error;\n}", "target": 1}
{"code": "static int snd_ctl_elem_user_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\tmutex_lock(&ue->card->user_ctl_lock);\n\tmemcpy(&ucontrol->value, ue->elem_data, ue->elem_data_size);\n\tmutex_unlock(&ue->card->user_ctl_lock);\n\treturn 0;\n}", "target": 0}
{"code": "irc_server_get_name_without_port (const char *name)\n{\n    char *pos;\n    if (!name)\n        return NULL;\n    pos = strchr (name, '/');\n    if (pos && (pos != name))\n        return weechat_strndup (name, pos - name);\n    return strdup (name);\n}", "target": 0}
{"code": "static int evdev_open_device(struct evdev *evdev)\n{\n\tint retval;\n\tretval = mutex_lock_interruptible(&evdev->mutex);\n\tif (retval)\n\t\treturn retval;\n\tif (!evdev->exist)\n\t\tretval = -ENODEV;\n\telse if (!evdev->open++) {\n\t\tretval = input_open_device(&evdev->handle);\n\t\tif (retval)\n\t\t\tevdev->open--;\n\t}\n\tmutex_unlock(&evdev->mutex);\n\treturn retval;\n}", "target": 0}
{"code": "long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\tkey_ref = lookup_user_key(keyid, 0, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n\tkey = key_ref_to_ptr(key_ref);\n\tret = key_permission(key_ref, KEY_READ);\n\tif (ret == 0)\n\t\tgoto can_read_key;\n\tif (ret != -EACCES)\n\t\tgoto error;\n\tif (!is_key_possessed(key_ref)) {\n\t\tret = -EACCES;\n\t\tgoto error2;\n\t}\ncan_read_key:\n\tret = key_validate(key);\n\tif (ret == 0) {\n\t\tret = -EOPNOTSUPP;\n\t\tif (key->type->read) {\n\t\t\tdown_read(&key->sem);\n\t\t\tret = key->type->read(key, buffer, buflen);\n\t\t\tup_read(&key->sem);\n\t\t}\n\t}\nerror2:\n\tkey_put(key);\nerror:\n\treturn ret;\n}", "target": 0}
{"code": "static inline int bitDiff(int value1, int value2)\n{\n  int decBits = 0;\n  if (value2 < value1)\n    while (decBits <= 14 && (value2 << ++decBits) < value1)\n      ;\n  return decBits;\n}", "target": 0}
{"code": "asmlinkage long compat_sys_recvmmsg(int fd, struct compat_mmsghdr __user *mmsg,\n\t\t\t\t    unsigned int vlen, unsigned int flags,\n\t\t\t\t    struct compat_timespec __user *timeout)\n{\n\tint datagrams;\n\tstruct timespec ktspec;\n\tif (flags & MSG_CMSG_COMPAT)\n\t\treturn -EINVAL;\n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t      flags | MSG_CMSG_COMPAT,\n\t\t\t\t      (struct timespec *) timeout);\n\tif (timeout == NULL)\n\t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t      flags | MSG_CMSG_COMPAT, NULL);\n\tif (get_compat_timespec(&ktspec, timeout))\n\t\treturn -EFAULT;\n\tdatagrams = __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t   flags | MSG_CMSG_COMPAT, &ktspec);\n\tif (datagrams > 0 && put_compat_timespec(&ktspec, timeout))\n\t\tdatagrams = -EFAULT;\n\treturn datagrams;\n}", "target": 1}
{"code": "Eina_Bool ewk_view_setting_caret_browsing_set(Evas_Object* ewkView, Eina_Bool enable)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv, false);\n    enable = !!enable;\n    if (priv->settings.caretBrowsing != enable) {\n        priv->pageSettings->setCaretBrowsingEnabled(enable);\n        priv->settings.caretBrowsing = enable;\n    }\n    return true;\n}", "target": 0}
{"code": "const Hybrid_type_traits_integer *Hybrid_type_traits_integer::instance()\n{\n  return &integer_traits_instance;\n}", "target": 0}
{"code": "int app_initialize(const char *const argv[])\n{\n    const char *argv_out[OGS_ARG_MAX];\n    bool user_config = false;\n    int i = 0;\n    for (i = 0; argv[i]; i++) {\n        if (strcmp(\"-c\", argv[i]) == 0) {\n            user_config = true; \n        }\n        argv_out[i] = argv[i];\n    }\n    argv_out[i] = NULL;\n    if (!user_config) {\n        argv_out[i++] = \"-c\";\n        argv_out[i++] = DEFAULT_CONFIG_FILENAME;\n        argv_out[i] = NULL;\n    }\n    if (ogs_app()->parameter.no_nrf == 0)\n        nrf_thread = test_child_create(\"nrf\", argv_out);\n    if (ogs_app()->parameter.no_scp == 0)\n        scp_thread = test_child_create(\"scp\", argv_out);\n    if (ogs_app()->parameter.no_upf == 0)\n        upf_thread = test_child_create(\"upf\", argv_out);\n    if (ogs_app()->parameter.no_smf == 0)\n        smf_thread = test_child_create(\"smf\", argv_out);\n    if (ogs_app()->parameter.no_amf == 0)\n        amf_thread = test_child_create(\"amf\", argv_out);\n    if (ogs_app()->parameter.no_ausf == 0)\n        ausf_thread = test_child_create(\"ausf\", argv_out);\n    if (ogs_app()->parameter.no_udm == 0)\n        udm_thread = test_child_create(\"udm\", argv_out);\n    if (ogs_app()->parameter.no_pcf == 0)\n        pcf_thread = test_child_create(\"pcf\", argv_out);\n    if (ogs_app()->parameter.no_nssf == 0)\n        nssf_thread = test_child_create(\"nssf\", argv_out);\n    if (ogs_app()->parameter.no_bsf == 0)\n        bsf_thread = test_child_create(\"bsf\", argv_out);\n    if (ogs_app()->parameter.no_udr == 0)\n        udr_thread = test_child_create(\"udr\", argv_out);\n    ogs_msleep(300);\n    return OGS_OK;;\n}", "target": 1}
{"code": "static void scalar32_min_max_or(struct bpf_reg_state *dst_reg,\n\t\t\t\tstruct bpf_reg_state *src_reg)\n{\n\tbool src_known = tnum_subreg_is_const(src_reg->var_off);\n\tbool dst_known = tnum_subreg_is_const(dst_reg->var_off);\n\tstruct tnum var32_off = tnum_subreg(dst_reg->var_off);\n\ts32 smin_val = src_reg->smin_value;\n\tu32 umin_val = src_reg->umin_value;\n\tif (src_known && dst_known)\n\t\treturn;\n\tdst_reg->u32_min_value = max(dst_reg->u32_min_value, umin_val);\n\tdst_reg->u32_max_value = var32_off.value | var32_off.mask;\n\tif (dst_reg->s32_min_value < 0 || smin_val < 0) {\n\t\tdst_reg->s32_min_value = S32_MIN;\n\t\tdst_reg->s32_max_value = S32_MAX;\n\t} else {\n\t\tdst_reg->s32_min_value = dst_reg->umin_value;\n\t\tdst_reg->s32_max_value = dst_reg->umax_value;\n\t}\n}", "target": 1}
{"code": "int udp_lib_setsockopt(struct sock *sk, int level, int optname,\n\t\t       char __user *optval, unsigned int optlen,\n\t\t       int (*push_pending_frames)(struct sock *))\n{\n\tstruct udp_sock *up = udp_sk(sk);\n\tint val, valbool;\n\tint err = 0;\n\tint is_udplite = IS_UDPLITE(sk);\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\tvalbool = val ? 1 : 0;\n\tswitch (optname) {\n\tcase UDP_CORK:\n\t\tif (val != 0) {\n\t\t\tup->corkflag = 1;\n\t\t} else {\n\t\t\tup->corkflag = 0;\n\t\t\tlock_sock(sk);\n\t\t\tpush_pending_frames(sk);\n\t\t\trelease_sock(sk);\n\t\t}\n\t\tbreak;\n\tcase UDP_ENCAP:\n\t\tswitch (val) {\n\t\tcase 0:\n\t\tcase UDP_ENCAP_ESPINUDP:\n\t\tcase UDP_ENCAP_ESPINUDP_NON_IKE:\n\t\t\tup->encap_rcv = xfrm4_udp_encap_rcv;\n\t\tcase UDP_ENCAP_L2TPINUDP:\n\t\t\tup->encap_type = val;\n\t\t\tudp_encap_enable();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -ENOPROTOOPT;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase UDP_NO_CHECK6_TX:\n\t\tup->no_check6_tx = valbool;\n\t\tbreak;\n\tcase UDP_NO_CHECK6_RX:\n\t\tup->no_check6_rx = valbool;\n\t\tbreak;\n\tcase UDPLITE_SEND_CSCOV:\n\t\tif (!is_udplite)         \n\t\t\treturn -ENOPROTOOPT;\n\t\tif (val != 0 && val < 8) \n\t\t\tval = 8;\n\t\telse if (val > USHRT_MAX)\n\t\t\tval = USHRT_MAX;\n\t\tup->pcslen = val;\n\t\tup->pcflag |= UDPLITE_SEND_CC;\n\t\tbreak;\n\tcase UDPLITE_RECV_CSCOV:\n\t\tif (!is_udplite)         \n\t\t\treturn -ENOPROTOOPT;\n\t\tif (val != 0 && val < 8) \n\t\t\tval = 8;\n\t\telse if (val > USHRT_MAX)\n\t\t\tval = USHRT_MAX;\n\t\tup->pcrlen = val;\n\t\tup->pcflag |= UDPLITE_RECV_CC;\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\treturn err;\n}", "target": 0}
{"code": "extractDirName(const StaticString &path) {\n\tchar *path_copy = strdup(path.c_str());\n\tchar *result = dirname(path_copy);\n\tstring result_string(result);\n\tfree(path_copy);\n\treturn result_string;\n}", "target": 0}
{"code": "static inline void constructBidiRunsForSegment(InlineBidiResolver& topResolver, BidiRunList<BidiRun>& bidiRuns, const InlineIterator& endOfRuns, VisualDirectionOverride override, bool previousLineBrokeCleanly)\n{\n    ASSERT(&topResolver.runs() == &bidiRuns);\n    ASSERT(topResolver.position() != endOfRuns);\n    RenderObject* currentRoot = topResolver.position().root();\n    topResolver.createBidiRunsForLine(endOfRuns, override, previousLineBrokeCleanly);\n    while (!topResolver.isolatedRuns().isEmpty()) {\n        BidiRun* isolatedRun = topResolver.isolatedRuns().last();\n        topResolver.isolatedRuns().removeLast();\n        RenderObject* startObj = isolatedRun->object();\n        RenderInline* isolatedInline = toRenderInline(containingIsolate(startObj, currentRoot));\n         InlineBidiResolver isolatedResolver;\n         EUnicodeBidi unicodeBidi = isolatedInline->style()->unicodeBidi();\n        TextDirection direction = isolatedInline->style()->direction();\n        if (unicodeBidi == Plaintext)\n            direction = determinePlaintextDirectionality(isolatedInline, startObj);\n        else {\n            ASSERT(unicodeBidi == Isolate || unicodeBidi == IsolateOverride);\n            direction = isolatedInline->style()->direction();\n        }\n        isolatedResolver.setStatus(statusWithDirection(direction, isOverride(unicodeBidi)));\n        setupResolverToResumeInIsolate(isolatedResolver, isolatedInline, startObj);\n        InlineIterator iter = InlineIterator(isolatedInline, startObj, isolatedRun->m_start);\n        isolatedResolver.setPositionIgnoringNestedIsolates(iter);\n        isolatedResolver.createBidiRunsForLine(endOfRuns, NoVisualOverride, previousLineBrokeCleanly);\n        if (isolatedResolver.runs().runCount())\n            bidiRuns.replaceRunWithRuns(isolatedRun, isolatedResolver.runs());\n        if (!isolatedResolver.isolatedRuns().isEmpty()) {\n            topResolver.isolatedRuns().append(isolatedResolver.isolatedRuns());\n            isolatedResolver.isolatedRuns().clear();\n            currentRoot = isolatedInline;\n        }\n    }\n}", "target": 1}
{"code": "SMB2_flush(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\n\t   u64 volatile_fid)\n{\n\tstruct smb_rqst rqst;\n\tstruct smb2_flush_req *req;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov;\n\tint resp_buftype;\n\tint rc = 0;\n\tint flags = 0;\n\tunsigned int total_len;\n\tcifs_dbg(FYI, \"Flush\\n\");\n\tif (!ses || !(ses->server))\n\t\treturn -EIO;\n\trc = smb2_plain_req_init(SMB2_FLUSH, tcon, (void **) &req, &total_len);\n\tif (rc)\n\t\treturn rc;\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\tiov[0].iov_base = (char *)req;\n\tiov[0].iov_len = total_len;\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = 1;\n\trc = cifs_send_recv(xid, ses, &rqst, &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_FLUSH_HE);\n\t\ttrace_smb3_flush_err(xid, persistent_fid, tcon->tid, ses->Suid,\n\t\t\t\t     rc);\n\t}\n\tfree_rsp_buf(resp_buftype, rsp_iov.iov_base);\n\treturn rc;\n}", "target": 0}
{"code": "void mark_progress(struct st_command* command __attribute__((unused)),\n                   int line)\n{\n  static ulonglong progress_start= 0; \n  DYNAMIC_STRING ds_progress;\n  char buf[32], *end;\n  ulonglong timer= timer_now();\n  if (!progress_start)\n    progress_start= timer;\n  timer-= progress_start;\n  if (init_dynamic_string(&ds_progress, \"\", 256, 256))\n    die(\"Out of memory\");\n  end= longlong10_to_str(timer, buf, 10);\n  dynstr_append_mem(&ds_progress, buf, (int)(end-buf));\n  dynstr_append_mem(&ds_progress, \"\\t\", 1);\n  end= int10_to_str(line, buf, 10);\n  dynstr_append_mem(&ds_progress, buf, (int)(end-buf));\n  dynstr_append_mem(&ds_progress, \"\\t\", 1);\n  dynstr_append(&ds_progress, cur_file->file_name);\n  dynstr_append_mem(&ds_progress, \":\", 1);\n  end= int10_to_str(cur_file->lineno, buf, 10);\n  dynstr_append_mem(&ds_progress, buf, (int)(end-buf));\n  dynstr_append_mem(&ds_progress, \"\\n\", 1);\n  progress_file.write(&ds_progress);\n  dynstr_free(&ds_progress);\n}", "target": 0}
{"code": "static void header(RBinFile *bf) {\n\tr_return_if_fail (bf && bf->o);\n\tRCoreSymCacheElement *element = bf->o->bin_obj;\n\tif (!element) {\n\t\treturn;\n\t}\n\tRBin *bin = bf->rbin;\n\tPrintfCallback p = bin->cb_printf;\n\tPJ *pj = pj_new ();\n\tif (!pj) {\n\t\treturn;\n\t}\n\tpj_o (pj);\n\tpj_kn (pj, \"cs_version\", element->hdr->version);\n\tpj_kn (pj, \"size\", element->hdr->size);\n\tif (element->file_name) {\n\t\tpj_ks (pj, \"name\", element->file_name);\n\t}\n\tif (element->binary_version) {\n\t\tpj_ks (pj, \"version\", element->binary_version);\n\t}\n\tchar uuidstr[R_UUID_LENGTH];\n\tr_hex_bin2str (element->hdr->uuid, 16, uuidstr);\n\tpj_ks (pj, \"uuid\", uuidstr);\n\tpj_kn (pj, \"segments\", element->hdr->n_segments);\n\tpj_kn (pj, \"sections\", element->hdr->n_sections);\n\tpj_kn (pj, \"symbols\", element->hdr->n_symbols);\n\tpj_kn (pj, \"lined_symbols\", element->hdr->n_lined_symbols);\n\tpj_kn (pj, \"line_info\", element->hdr->n_line_info);\n\tpj_end (pj);\n\tp (\"%s\\n\", pj_string (pj));\n\tpj_free (pj);\n}", "target": 0}
{"code": "static inline void nfsd4_increment_op_stats(u32 opnum)\n{\n\tif (opnum >= FIRST_NFS4_OP && opnum <= LAST_NFS4_OP)\n\t\tnfsdstats.nfs4_opcount[opnum]++;\n}", "target": 0}
{"code": "static int nfs4_xdr_dec_server_caps(struct rpc_rqst *req,\n\t\t\t\t    struct xdr_stream *xdr,\n\t\t\t\t    struct nfs4_server_caps_res *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, req);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_server_caps(xdr, res);\nout:\n\treturn status;\n}", "target": 0}
{"code": "Bool gf_sys_get_battery_state(Bool *onBattery, u32 *onCharge, u32*level, u32 *batteryLifeTime, u32 *batteryFullLifeTime)\n{\n#if defined(_WIN32_WCE)\n\tSYSTEM_POWER_STATUS_EX sps;\n\tGetSystemPowerStatusEx(&sps, 0);\n\tif (onBattery) *onBattery = sps.ACLineStatus ? 0 : 1;\n\tif (onCharge) *onCharge = (sps.BatteryFlag & BATTERY_FLAG_CHARGING) ? 1 : 0;\n\tif (level) *level = sps.BatteryLifePercent;\n\tif (batteryLifeTime) *batteryLifeTime = sps.BatteryLifeTime;\n\tif (batteryFullLifeTime) *batteryFullLifeTime = sps.BatteryFullLifeTime;\n#elif defined(WIN32)\n\tSYSTEM_POWER_STATUS sps;\n\tGetSystemPowerStatus(&sps);\n\tif (onBattery) *onBattery = sps.ACLineStatus ? GF_FALSE : GF_TRUE;\n\tif (onCharge) *onCharge = (sps.BatteryFlag & BATTERY_FLAG_CHARGING) ? 1 : 0;\n\tif (level) *level = sps.BatteryLifePercent;\n\tif (batteryLifeTime) *batteryLifeTime = sps.BatteryLifeTime;\n\tif (batteryFullLifeTime) *batteryFullLifeTime = sps.BatteryFullLifeTime;\n#endif\n\treturn GF_TRUE;\n}", "target": 0}
{"code": "int mempool_releasebuffer(MemoryPoolHandle handle, void *buf,\n                          size_t released_buffer_size) {\n  struct mempool *pool = (struct mempool *)handle;\n  struct memory_pool_element *pool_item = (struct memory_pool_element *)buf;\n  char *log_msg_fmt =\n      \"mempool(%p): mempool_releasebuffer called for invalid \"\n      \"released_buffer_size(%zu), current pool manages only \"\n      \"mempool_item_size(%zu)\";\n  char log_msg[300];\n  if ((pool == NULL) || (pool_item == NULL)) {\n    return S3_MEMPOOL_INVALID_ARG;\n  }\n  if (pool->mempool_item_size != released_buffer_size) {\n    if (pool->log_callback_func) {\n      snprintf(log_msg, sizeof(log_msg), log_msg_fmt, (void *)pool,\n               released_buffer_size, pool->mempool_item_size);\n      pool->log_callback_func(MEMPOOL_LOG_FATAL, log_msg);\n      return S3_MEMPOOL_INVALID_ARG;\n    }\n  }\n  if ((pool->flags & ENABLE_LOCKING) != 0) {\n    pthread_mutex_lock(&pool->lock);\n  }\n  if ((pool->flags & ZEROED_BUFFER) != 0) {\n    memset(pool_item, 0, pool->mempool_item_size);\n  }\n  pool_item->next = pool->free_list;\n  pool->free_list = pool_item;\n  pool->free_bufs_in_pool++;\n  pool_item = NULL;\n  pool->number_of_bufs_shared--;\n  if ((pool->flags & ENABLE_LOCKING) != 0) {\n    pthread_mutex_unlock(&pool->lock);\n  }\n  return 0;\n}", "target": 0}
{"code": "spnego_gss_inquire_names_for_mech(\n\t\t\t\tOM_uint32\t*minor_status,\n\t\t\t\tgss_OID\t\tmechanism,\n\t\t\t\tgss_OID_set\t*name_types)\n{\n\tOM_uint32   major, minor;\n\tdsyslog(\"Entering inquire_names_for_mech\\n\");\n\tif ((mechanism != GSS_C_NULL_OID) &&\n\t    !g_OID_equal(gss_mech_spnego, mechanism)) {\n\t\t*minor_status = 0;\n\t\treturn (GSS_S_FAILURE);\n\t}\n\tmajor = gss_create_empty_oid_set(minor_status, name_types);\n\tif (major == GSS_S_COMPLETE) {\n\t\tif (((major = gss_add_oid_set_member(minor_status,\n\t\t\t\t(gss_OID) GSS_C_NT_USER_NAME,\n\t\t\t\tname_types)) == GSS_S_COMPLETE) &&\n\t\t    ((major = gss_add_oid_set_member(minor_status,\n\t\t\t\t(gss_OID) GSS_C_NT_MACHINE_UID_NAME,\n\t\t\t\tname_types)) == GSS_S_COMPLETE) &&\n\t\t    ((major = gss_add_oid_set_member(minor_status,\n\t\t\t\t(gss_OID) GSS_C_NT_STRING_UID_NAME,\n\t\t\t\tname_types)) == GSS_S_COMPLETE)) {\n\t\t\tmajor = gss_add_oid_set_member(minor_status,\n\t\t\t\t(gss_OID) GSS_C_NT_HOSTBASED_SERVICE,\n\t\t\t\tname_types);\n\t\t}\n\t\tif (major != GSS_S_COMPLETE)\n\t\t\t(void) gss_release_oid_set(&minor, name_types);\n\t}\n\tdsyslog(\"Leaving inquire_names_for_mech\\n\");\n\treturn (major);\n}", "target": 0}
{"code": "int cg_mkdir(const char *path, mode_t mode)\n{\n\tstruct fuse_context *fc = fuse_get_context();\n\tchar *fpath = NULL, *path1, *cgdir = NULL, *controller;\n\tconst char *cgroup;\n\tint ret;\n\tif (!fc)\n\t\treturn -EIO;\n\tcontroller = pick_controller_from_path(fc, path);\n\tif (!controller)\n\t\treturn -EINVAL;\n\tcgroup = find_cgroup_in_path(path);\n\tif (!cgroup)\n\t\treturn -EINVAL;\n\tget_cgdir_and_path(cgroup, &cgdir, &fpath);\n\tif (!fpath)\n\t\tpath1 = \"/\";\n\telse\n\t\tpath1 = cgdir;\n\tif (!fc_may_access(fc, controller, path1, NULL, O_RDWR)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\tif (!caller_is_in_ancestor(fc->pid, controller, path1, NULL)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\tret = cgfs_create(controller, cgroup, fc->uid, fc->gid);\n\tprintf(\"cgfs_create returned %d for %s %s\\n\", ret, controller, cgroup);\nout:\n\tfree(cgdir);\n\treturn ret;\n}", "target": 1}
{"code": "gen_muldiv(codegen_scope *s, uint8_t op, uint16_t dst)\n{\n  if (no_peephole(s)) {\n  normal:\n    genop_1(s, op, dst);\n    return;\n  }\n  else {\n    struct mrb_insn_data data = mrb_last_insn(s);\n    mrb_int n, n0;\n    if (addr_pc(s, data.addr) == s->lastlabel || !get_int_operand(s, &data, &n)) {\n      goto normal;\n    }\n    struct mrb_insn_data data0 = mrb_decode_insn(mrb_prev_pc(s, data.addr));\n    if (!get_int_operand(s, &data0, &n0) || n == 0) {\n      goto normal;\n    }\n    if (op == OP_MUL) {\n      if (mrb_int_mul_overflow(n0, n, &n)) goto normal;\n    }\n    else { \n      if (n0 == MRB_INT_MIN && n == -1) goto normal;\n      n = n0 / n;\n    }\n    s->pc = addr_pc(s, data0.addr);\n    gen_int(s, dst, n);\n  }\n}", "target": 0}
{"code": "UINT rdpgfx_read_rect16(wStream* s, RECTANGLE_16* rect16)\n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t{\n\t\tWLog_ERR(TAG, \"not enough data!\");\n\t\treturn ERROR_INVALID_DATA;\n\t}\n\tStream_Read_UINT16(s, rect16->left);   \n\tStream_Read_UINT16(s, rect16->top);    \n\tStream_Read_UINT16(s, rect16->right);  \n\tStream_Read_UINT16(s, rect16->bottom); \n\treturn CHANNEL_RC_OK;\n}", "target": 1}
{"code": "static void *m_start(struct seq_file *seq, loff_t *ppos, struct uid_gid_map *map)\n{\n\tstruct uid_gid_extent *extent = NULL;\n\tloff_t pos = *ppos;\n\tif (pos < map->nr_extents)\n\t\textent = &map->extent[pos];\n\treturn extent;\n}", "target": 0}
{"code": "static const char *server_hostname_port(cmd_parms *cmd, void *dummy, const char *arg)\n{\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);\n    const char *portstr, *part;\n    char *scheme;\n    int port;\n    if (err != NULL) {\n        return err;\n    }\n    if (apr_fnmatch_test(arg))\n        return apr_pstrcat(cmd->temp_pool, \"Invalid ServerName \\\"\", arg,\n                \"\\\" use ServerAlias to set multiple server names.\", NULL);\n    part = ap_strstr_c(arg, \":\n    if (part) {\n      scheme = apr_pstrndup(cmd->pool, arg, part - arg);\n      ap_str_tolower(scheme);\n      cmd->server->server_scheme = (const char *)scheme;\n      part += 3;\n    } else {\n      part = arg;\n    }\n    portstr = ap_strchr_c(part, ':');\n    if (portstr) {\n        cmd->server->server_hostname = apr_pstrndup(cmd->pool, part,\n                                                    portstr - part);\n        portstr++;\n        port = atoi(portstr);\n        if (port <= 0 || port >= 65536) { \n            return apr_pstrcat(cmd->temp_pool, \"The port number \\\"\", arg,\n                          \"\\\" is outside the appropriate range \"\n                          \"(i.e., 1..65535).\", NULL);\n        }\n    }\n    else {\n        cmd->server->server_hostname = apr_pstrdup(cmd->pool, part);\n        port = 0;\n    }\n    cmd->server->port = port;\n    return NULL;\n}", "target": 0}
{"code": "static uint8_t avrcp_handle_get_play_status(struct avrcp *session,\n\t\t\t\t\t\tstruct avrcp_header *pdu,\n\t\t\t\t\t\tuint8_t transaction)\n{\n\tstruct avrcp_player *player = target_get_player(session);\n\tuint16_t len = ntohs(pdu->params_len);\n\tuint32_t position;\n\tuint32_t duration;\n\tif (len != 0) {\n\t\tpdu->params_len = htons(1);\n\t\tpdu->params[0] = AVRCP_STATUS_INVALID_PARAM;\n\t\treturn AVC_CTYPE_REJECTED;\n\t}\n\tposition = player_get_position(player);\n\tduration = player_get_duration(player);\n\tposition = htonl(position);\n\tduration = htonl(duration);\n\tmemcpy(&pdu->params[0], &duration, 4);\n\tmemcpy(&pdu->params[4], &position, 4);\n\tpdu->params[8] = player_get_status(player);\n\tpdu->params_len = htons(9);\n\treturn AVC_CTYPE_STABLE;\n}", "target": 0}
{"code": "void exit_mmap(struct mm_struct *mm)\n{\n\tstruct mmu_gather *tlb;\n\tstruct vm_area_struct *vma = mm->mmap;\n\tunsigned long nr_accounted = 0;\n\tunsigned long end;\n\tarch_exit_mmap(mm);\n\tlru_add_drain();\n\tflush_cache_mm(mm);\n\ttlb = tlb_gather_mmu(mm, 1);\n\tend = unmap_vmas(&tlb, vma, 0, -1, &nr_accounted, NULL);\n\tvm_unacct_memory(nr_accounted);\n\tfree_pgtables(&tlb, vma, FIRST_USER_ADDRESS, 0);\n\ttlb_finish_mmu(tlb, 0, end);\n\twhile (vma)\n\t\tvma = remove_vma(vma);\n\tBUG_ON(mm->nr_ptes > (FIRST_USER_ADDRESS+PMD_SIZE-1)>>PMD_SHIFT);\n}", "target": 0}
{"code": "int check_directory(struct dir *dir)\n{\n\tint i;\n\tstruct dir_ent *ent;\n\tif(dir->dir_count < 2)\n\t\treturn TRUE;\n\tfor(ent = dir->dirs, i = 0; i < dir->dir_count - 1; ent = ent->next, i++)\n\t\tif(strcmp(ent->name, ent->next->name) >= 0)\n\t\t\treturn FALSE;\n\treturn TRUE;\n}", "target": 0}
{"code": "static bool kvm_vcpu_check_breakpoint(struct kvm_vcpu *vcpu, int *r)\n{\n\tif (unlikely(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) &&\n\t    (vcpu->arch.guest_debug_dr7 & DR7_BP_EN_MASK)) {\n\t\tstruct kvm_run *kvm_run = vcpu->run;\n\t\tunsigned long eip = kvm_get_linear_rip(vcpu);\n\t\tu32 dr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.guest_debug_dr7,\n\t\t\t\t\t   vcpu->arch.eff_db);\n\t\tif (dr6 != 0) {\n\t\t\tkvm_run->debug.arch.dr6 = dr6 | DR6_ACTIVE_LOW;\n\t\t\tkvm_run->debug.arch.pc = eip;\n\t\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\t\t*r = 0;\n\t\t\treturn true;\n\t\t}\n\t}\n\tif (unlikely(vcpu->arch.dr7 & DR7_BP_EN_MASK) &&\n\t    !(kvm_get_rflags(vcpu) & X86_EFLAGS_RF)) {\n\t\tunsigned long eip = kvm_get_linear_rip(vcpu);\n\t\tu32 dr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.dr7,\n\t\t\t\t\t   vcpu->arch.db);\n\t\tif (dr6 != 0) {\n\t\t\tkvm_queue_exception_p(vcpu, DB_VECTOR, dr6);\n\t\t\t*r = 1;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "target": 1}
{"code": "static int snd_ctl_elem_read(struct snd_card *card,\n\t\t\t     struct snd_ctl_elem_value *control)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int index_offset;\n\tstruct snd_ctl_elem_info info;\n\tconst u32 pattern = 0xdeadbeef;\n\tint ret;\n\tkctl = snd_ctl_find_id(card, &control->id);\n\tif (kctl == NULL)\n\t\treturn -ENOENT;\n\tindex_offset = snd_ctl_get_ioff(kctl, &control->id);\n\tvd = &kctl->vd[index_offset];\n\tif (!(vd->access & SNDRV_CTL_ELEM_ACCESS_READ) || kctl->get == NULL)\n\t\treturn -EPERM;\n\tsnd_ctl_build_ioff(&control->id, kctl, index_offset);\n#ifdef CONFIG_SND_CTL_DEBUG\n\tmemset(&info, 0, sizeof(info));\n\tinfo.id = control->id;\n\tret = __snd_ctl_elem_info(card, kctl, &info, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n#endif\n\tif (!snd_ctl_skip_validation(&info))\n\t\tfill_remaining_elem_value(control, &info, pattern);\n\tret = snd_power_ref_and_wait(card);\n\tif (!ret)\n\t\tret = kctl->get(kctl, control);\n\tsnd_power_unref(card);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!snd_ctl_skip_validation(&info) &&\n\t    sanity_check_elem_value(card, control, &info, pattern) < 0) {\n\t\tdev_err(card->dev,\n\t\t\t\"control %i:%i:%i:%s:%i: access overflow\\n\",\n\t\t\tcontrol->id.iface, control->id.device,\n\t\t\tcontrol->id.subdevice, control->id.name,\n\t\t\tcontrol->id.index);\n\t\treturn -EINVAL;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "pci_lintr_release(struct pci_vdev *dev)\n{\n\tstruct businfo *bi;\n\tstruct slotinfo *si;\n\tint pin;\n\tbi = pci_businfo[dev->bus];\n\tassert(bi != NULL);\n\tsi = &bi->slotinfo[dev->slot];\n\tfor (pin = 1; pin < 4; pin++) {\n\t\tsi->si_intpins[pin].ii_count = 0;\n\t\tsi->si_intpins[pin].ii_pirq_pin = 0;\n\t\tsi->si_intpins[pin].ii_ioapic_irq = 0;\n\t}\n}", "target": 1}
{"code": "NOEXPORT void tray_update(const int num) {\n    NOTIFYICONDATA nid;\n    static ICON_TYPE previous_icon=ICON_NONE;\n    ICON_TYPE current_icon;\n    LPTSTR tip;\n    if(!global_options.option.taskbar) { \n        tray_delete(); \n        return;\n    }\n    if(!tray_menu_handle) \n        tray_menu_handle=LoadMenu(ghInst, MAKEINTRESOURCE(IDM_TRAYMENU));\n    if(!tray_menu_handle) {\n        ioerror(\"LoadMenu\");\n        return;\n    }\n    if(cmdline.service)\n        EnableMenuItem(tray_menu_handle, IDM_EDIT_CONFIG, MF_GRAYED);\n    ZeroMemory(&nid, sizeof nid);\n    nid.cbSize=sizeof nid;\n    nid.uID=1; \n    nid.uFlags=NIF_MESSAGE|NIF_TIP;\n    nid.uCallbackMessage=WM_SYSTRAY; \n    nid.hWnd=hwnd; \n    if(num<0) {\n        tip=str_tprintf(TEXT(\"Server is down\"));\n        current_icon=ICON_ERROR;\n    } else if(num>0) {\n        tip=str_tprintf(TEXT(\"%d active session(s)\"), num);\n        current_icon=ICON_ACTIVE;\n    } else {\n        tip=str_tprintf(TEXT(\"Server is idle\"));\n        current_icon=ICON_IDLE;\n    }\n    _tcsncpy(nid.szTip, tip, 63);\n    nid.szTip[63]=TEXT('\\0');\n    str_free(tip);\n    nid.hIcon=global_options.icon[current_icon];\n    if(current_icon!=previous_icon) {\n        nid.uFlags|=NIF_ICON;\n        previous_icon=current_icon;\n    }\n    if(Shell_NotifyIcon(NIM_MODIFY, &nid)) \n        return; \n    nid.uFlags|=NIF_ICON;\n    Shell_NotifyIcon(NIM_ADD, &nid);\n}", "target": 1}
{"code": "static void irda_connect_indication(void *instance, void *sap,\n\t\t\t\t    struct qos_info *qos, __u32 max_sdu_size,\n\t\t\t\t    __u8 max_header_size, struct sk_buff *skb)\n{\n\tstruct irda_sock *self;\n\tstruct sock *sk;\n\tself = instance;\n\tIRDA_DEBUG(2, \"%s(%p)\\n\", __func__, self);\n\tsk = instance;\n\tif (sk == NULL) {\n\t\tdev_kfree_skb(skb);\n\t\treturn;\n\t}\n\tself->max_header_size = max_header_size;\n\tself->max_sdu_size_tx = max_sdu_size;\n\tswitch (sk->sk_type) {\n\tcase SOCK_STREAM:\n\t\tif (max_sdu_size != 0) {\n\t\t\tIRDA_ERROR(\"%s: max_sdu_size must be 0\\n\",\n\t\t\t\t   __func__);\n\t\t\tkfree_skb(skb);\n\t\t\treturn;\n\t\t}\n\t\tself->max_data_size = irttp_get_max_seg_size(self->tsap);\n\t\tbreak;\n\tcase SOCK_SEQPACKET:\n\t\tif (max_sdu_size == 0) {\n\t\t\tIRDA_ERROR(\"%s: max_sdu_size cannot be 0\\n\",\n\t\t\t\t   __func__);\n\t\t\tkfree_skb(skb);\n\t\t\treturn;\n\t\t}\n\t\tself->max_data_size = max_sdu_size;\n\t\tbreak;\n\tdefault:\n\t\tself->max_data_size = irttp_get_max_seg_size(self->tsap);\n\t}\n\tIRDA_DEBUG(2, \"%s(), max_data_size=%d\\n\", __func__,\n\t\t   self->max_data_size);\n\tmemcpy(&self->qos_tx, qos, sizeof(struct qos_info));\n\tskb_queue_tail(&sk->sk_receive_queue, skb);\n\tsk->sk_state_change(sk);\n}", "target": 0}
{"code": "static int jpc_crg_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_crg_t *crg = &ms->parms.crg;\n\tint compno;\n\tjpc_crgcomp_t *comp;\n\tfor (compno = 0, comp = crg->comps; compno < crg->numcomps; ++compno,\n\t  ++comp) {\n\t\tfprintf(out, \"hoff[%d] = %d; voff[%d] = %d\\n\", compno,\n\t\t  comp->hoff, compno, comp->voff);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "HIDDEN void *zstd_init()\n{\n    ZSTD_CCtx *cctx = ZSTD_createCCtx();\n    if (cctx) {\n        ZSTD_CCtx_setParameter(cctx, ZSTD_c_compressionLevel,\n                               ZSTD_CLEVEL_DEFAULT);\n        ZSTD_CCtx_setParameter(cctx, ZSTD_c_checksumFlag, 1);\n    }\n    return cctx;\n}", "target": 0}
{"code": "Http::Response AbstractWebApplication::processRequest(const Http::Request &request, const Http::Environment &env)\n{\n    session_ = 0;\n    request_ = request;\n    env_ = env;\n    clear(); \n    sessionInitialize();\n    if (!sessionActive() && !isAuthNeeded())\n        sessionStart();\n    if (isBanned()) {\n        status(403, \"Forbidden\");\n        print(QObject::tr(\"Your IP address has been banned after too many failed authentication attempts.\"), Http::CONTENT_TYPE_TXT);\n    }\n    else {\n        processRequest();\n    }\n    return response();\n}", "target": 1}
{"code": "void file_sb_list_add(struct file *file, struct super_block *sb)\n{\n\tif (likely(!(file->f_mode & FMODE_WRITE)))\n\t\treturn;\n\tif (!S_ISREG(file_inode(file)->i_mode))\n\t\treturn;\n\tlg_local_lock(&files_lglock);\n\t__file_sb_list_add(file, sb);\n\tlg_local_unlock(&files_lglock);\n}", "target": 1}
{"code": "int nfs4_open_delegation_recall(struct nfs_open_context *ctx, struct nfs4_state *state, const nfs4_stateid *stateid)\n{\n\tstruct nfs4_exception exception = { };\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tint err;\n\tdo {\n\t\terr = _nfs4_open_delegation_recall(ctx, state, stateid);\n\t\tswitch (err) {\n\t\t\tcase 0:\n\t\t\tcase -ENOENT:\n\t\t\tcase -ESTALE:\n\t\t\t\tgoto out;\n\t\t\tcase -NFS4ERR_BADSESSION:\n\t\t\tcase -NFS4ERR_BADSLOT:\n\t\t\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\t\t\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\t\tcase -NFS4ERR_DEADSESSION:\n\t\t\t\tnfs4_schedule_session_recovery(server->nfs_client->cl_session, err);\n\t\t\t\tgoto out;\n\t\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\tcase -NFS4ERR_STALE_STATEID:\n\t\t\tcase -NFS4ERR_EXPIRED:\n\t\t\t\tnfs4_schedule_lease_recovery(server->nfs_client);\n\t\t\t\tgoto out;\n\t\t\tcase -ERESTARTSYS:\n\t\t\tcase -NFS4ERR_DELEG_REVOKED:\n\t\t\tcase -NFS4ERR_ADMIN_REVOKED:\n\t\t\tcase -NFS4ERR_BAD_STATEID:\n\t\t\t\tnfs_inode_find_state_and_recover(state->inode,\n\t\t\t\t\t\tstateid);\n\t\t\t\tnfs4_schedule_stateid_recovery(server, state);\n\t\t\tcase -EKEYEXPIRED:\n\t\t\tcase -ENOMEM:\n\t\t\t\terr = 0;\n\t\t\t\tgoto out;\n\t\t}\n\t\terr = nfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\nout:\n\treturn err;\n}", "target": 0}
{"code": "irc_nick_nicklist_remove (struct t_irc_server *server,\n                          struct t_irc_channel *channel,\n                          struct t_irc_nick *nick)\n{\n    struct t_gui_nick_group *ptr_group;\n    ptr_group = irc_nick_get_nicklist_group (server, channel->buffer, nick);\n    weechat_nicklist_remove_nick (channel->buffer,\n                                  weechat_nicklist_search_nick (channel->buffer,\n                                                                ptr_group,\n                                                                nick->name));\n}", "target": 0}
{"code": "static int zipfileSerializeLFH(ZipfileEntry *pEntry, u8 *aBuf){\n  ZipfileCDS *pCds = &pEntry->cds;\n  u8 *a = aBuf;\n  pCds->nExtra = 9;\n  zipfileWrite32(a, ZIPFILE_SIGNATURE_LFH);\n  zipfileWrite16(a, pCds->iVersionExtract);\n  zipfileWrite16(a, pCds->flags);\n  zipfileWrite16(a, pCds->iCompression);\n  zipfileWrite16(a, pCds->mTime);\n  zipfileWrite16(a, pCds->mDate);\n  zipfileWrite32(a, pCds->crc32);\n  zipfileWrite32(a, pCds->szCompressed);\n  zipfileWrite32(a, pCds->szUncompressed);\n  zipfileWrite16(a, (u16)pCds->nFile);\n  zipfileWrite16(a, pCds->nExtra);\n  assert( a==&aBuf[ZIPFILE_LFH_FIXED_SZ] );\n  memcpy(a, pCds->zFile, (int)pCds->nFile);\n  a += (int)pCds->nFile;\n  zipfileWrite16(a, ZIPFILE_EXTRA_TIMESTAMP);\n  zipfileWrite16(a, 5);\n  *a++ = 0x01;\n  zipfileWrite32(a, pEntry->mUnixTime);\n  return a-aBuf;\n}", "target": 0}
{"code": "struct sock *dccp_v4_request_recv_sock(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t       struct request_sock *req,\n\t\t\t\t       struct dst_entry *dst)\n{\n\tstruct inet_request_sock *ireq;\n\tstruct inet_sock *newinet;\n\tstruct sock *newsk;\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto exit_overflow;\n\tif (dst == NULL && (dst = inet_csk_route_req(sk, req)) == NULL)\n\t\tgoto exit;\n\tnewsk = dccp_create_openreq_child(sk, req, skb);\n\tif (newsk == NULL)\n\t\tgoto exit_nonewsk;\n\tsk_setup_caps(newsk, dst);\n\tnewinet\t\t   = inet_sk(newsk);\n\tireq\t\t   = inet_rsk(req);\n\tnewinet->inet_daddr\t= ireq->rmt_addr;\n\tnewinet->inet_rcv_saddr = ireq->loc_addr;\n\tnewinet->inet_saddr\t= ireq->loc_addr;\n\tnewinet->opt\t   = ireq->opt;\n\tireq->opt\t   = NULL;\n\tnewinet->mc_index  = inet_iif(skb);\n\tnewinet->mc_ttl\t   = ip_hdr(skb)->ttl;\n\tnewinet->inet_id   = jiffies;\n\tdccp_sync_mss(newsk, dst_mtu(dst));\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tsock_put(newsk);\n\t\tgoto exit;\n\t}\n\t__inet_hash_nolisten(newsk, NULL);\n\treturn newsk;\nexit_overflow:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nexit_nonewsk:\n\tdst_release(dst);\nexit:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn NULL;\n}", "target": 1}
{"code": "static void FNAME_DECL(uncompress_row0_seg)(int i,\n                                            PIXEL * const cur_row,\n                                            const int end,\n                                            const unsigned int waitmask,\n                                            const unsigned int bpc_mask)\n{\n    DECLARE_STATE_VARIABLES;\n    DECLARE_CHANNEL_VARIABLES;\n    int stopidx;\n    spice_assert(end - i > 0);\n    if (i == 0) {\n        unsigned int codewordlen;\n        UNCOMPRESS_PIX_START(&cur_row[i]);\n        APPLY_ALL_COMP(UNCOMPRESS_ONE_ROW0_0);\n        if (state->waitcnt) {\n            --state->waitcnt;\n        } else {\n            state->waitcnt = (tabrand(&state->tabrand_seed) & waitmask);\n            UPDATE_MODEL(0);\n        }\n        stopidx = ++i + state->waitcnt;\n    } else {\n        stopidx = i + state->waitcnt;\n    }\n    while (stopidx < end) {\n        for (; i <= stopidx; i++) {\n            unsigned int codewordlen;\n            UNCOMPRESS_PIX_START(&cur_row[i]);\n            APPLY_ALL_COMP(UNCOMPRESS_ONE_ROW0);\n        }\n        UPDATE_MODEL(stopidx);\n        stopidx = i + (tabrand(&state->tabrand_seed) & waitmask);\n    }\n    for (; i < end; i++) {\n        unsigned int codewordlen;\n        UNCOMPRESS_PIX_START(&cur_row[i]);\n        APPLY_ALL_COMP(UNCOMPRESS_ONE_ROW0);\n    }\n    state->waitcnt = stopidx - end;\n}", "target": 0}
{"code": "FunctionTemplateFactory V8ClassIndex::GetFactory(V8WrapperType type)\n{\n    switch (type) {\n#define MAKE_CASE(type, name)\\\n    case V8ClassIndex::type: return V8##name::GetTemplate;\n    WRAPPER_TYPES(MAKE_CASE)\n#undef MAKE_CASE\n    default: return NULL;\n    }\n}", "target": 0}
{"code": "static int synic_set_irq(struct kvm_vcpu_hv_synic *synic, u32 sint)\n{\n\tstruct kvm_vcpu *vcpu = hv_synic_to_vcpu(synic);\n\tstruct kvm_lapic_irq irq;\n\tint ret, vector;\n\tif (sint >= ARRAY_SIZE(synic->sint))\n\t\treturn -EINVAL;\n\tvector = synic_get_sint_vector(synic_read_sint(synic, sint));\n\tif (vector < 0)\n\t\treturn -ENOENT;\n\tmemset(&irq, 0, sizeof(irq));\n\tirq.shorthand = APIC_DEST_SELF;\n\tirq.dest_mode = APIC_DEST_PHYSICAL;\n\tirq.delivery_mode = APIC_DM_FIXED;\n\tirq.vector = vector;\n\tirq.level = 1;\n\tret = kvm_irq_delivery_to_apic(vcpu->kvm, vcpu->arch.apic, &irq, NULL);\n\ttrace_kvm_hv_synic_set_irq(vcpu->vcpu_id, sint, irq.vector, ret);\n\treturn ret;\n}", "target": 1}
{"code": "comics_document_render (EvDocument      *document,\n\t\t\tEvRenderContext *rc)\n{\n\tGdkPixbuf       *pixbuf;\n\tcairo_surface_t *surface;\n\tpixbuf = comics_document_render_pixbuf (document, rc);\n\tsurface = ev_document_misc_surface_from_pixbuf (pixbuf);\n\tg_object_unref (pixbuf);\n\treturn surface;\n}", "target": 1}
{"code": "DECLAREreadFunc(readContigTilesIntoBuffer)\n{\n\tint status = 1;\n\ttsize_t tilesize = TIFFTileSize(in);\n\ttdata_t tilebuf;\n\tuint32 imagew = TIFFScanlineSize(in);\n\tuint32 tilew  = TIFFTileRowSize(in);\n\tint iskew = imagew - tilew;\n\tuint8* bufp = (uint8*) buf;\n\tuint32 tw, tl;\n\tuint32 row;\n\t(void) spp;\n\ttilebuf = _TIFFmalloc(tilesize);\n\tif (tilebuf == 0)\n\t\treturn 0;\n\t_TIFFmemset(tilebuf, 0, tilesize);\n\t(void) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n\t(void) TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n\tfor (row = 0; row < imagelength; row += tl) {\n\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\n\t\tuint32 colb = 0;\n\t\tuint32 col;\n\t\tfor (col = 0; col < imagewidth; col += tw) {\n\t\t\tif (TIFFReadTile(in, tilebuf, col, row, 0, 0) < 0\n\t\t\t    && !ignore) {\n\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t    \"Error, can't read tile at %lu %lu\",\n\t\t\t\t    (unsigned long) col,\n\t\t\t\t    (unsigned long) row);\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (colb + tilew > imagew) {\n\t\t\t\tuint32 width = imagew - colb;\n\t\t\t\tuint32 oskew = tilew - width;\n\t\t\t\tcpStripToTile(bufp + colb,\n\t\t\t\t    tilebuf, nrow, width,\n\t\t\t\t    oskew + iskew, oskew );\n\t\t\t} else\n\t\t\t\tcpStripToTile(bufp + colb,\n\t\t\t\t    tilebuf, nrow, tilew,\n\t\t\t\t    iskew, 0);\n\t\t\tcolb += tilew;\n\t\t}\n\t\tbufp += imagew * nrow;\n\t}\ndone:\n\t_TIFFfree(tilebuf);\n\treturn status;\n}", "target": 1}
{"code": "void RenderWidgetHostImpl::OnResizeOrRepaintACK(\n    const ViewHostMsg_ResizeOrRepaint_ACK_Params& params) {\n  TRACE_EVENT0(\"renderer_host\", \"RenderWidgetHostImpl::OnResizeOrRepaintACK\");\n  TimeTicks paint_start = TimeTicks::Now();\n  current_size_ = params.view_size;\n  bool is_resize_ack =\n      ViewHostMsg_ResizeOrRepaint_ACK_Flags::is_resize_ack(params.flags);\n  if (is_resize_ack) {\n    DCHECK(!g_check_for_pending_resize_ack || resize_ack_pending_);\n    resize_ack_pending_ = false;\n  }\n  bool is_repaint_ack =\n      ViewHostMsg_ResizeOrRepaint_ACK_Flags::is_repaint_ack(params.flags);\n  if (is_repaint_ack) {\n    DCHECK(repaint_ack_pending_);\n    TRACE_EVENT_ASYNC_END0(\n        \"renderer_host\", \"RenderWidgetHostImpl::repaint_ack_pending_\", this);\n    repaint_ack_pending_ = false;\n    TimeDelta delta = TimeTicks::Now() - repaint_start_time_;\n    UMA_HISTOGRAM_TIMES(\"MPArch.RWH_RepaintDelta\", delta);\n  }\n  DCHECK(!params.view_size.IsEmpty());\n  DidCompleteResizeOrRepaint(params, paint_start);\n  last_auto_resize_request_number_ = params.sequence_number;\n  if (auto_resize_enabled_) {\n    bool post_callback = new_auto_size_.IsEmpty();\n    new_auto_size_ = params.view_size;\n    if (post_callback) {\n      base::ThreadTaskRunnerHandle::Get()->PostTask(\n          FROM_HERE, base::BindOnce(&RenderWidgetHostImpl::DelayedAutoResized,\n                                    weak_factory_.GetWeakPtr()));\n    }\n  }\n  TimeDelta delta = TimeTicks::Now() - paint_start;\n  UMA_HISTOGRAM_TIMES(\"MPArch.RWH_OnMsgResizeOrRepaintACK\", delta);\n}", "target": 0}
{"code": "int read_file(struct sc_card *card, char *str_path, unsigned char **data, size_t *data_len)\n{\n\tstruct sc_path path;\n\tstruct sc_file *file;\n\tunsigned char *p;\n\tint ok = 0;\n\tint r;\n\tsize_t len;\n\tsc_format_path(str_path, &path);\n\tif (SC_SUCCESS != sc_select_file(card, &path, &file)) {\n\t\tgoto err;\n\t}\n\tlen = file && file->size > 0 ? file->size : 4096;\n\tp = realloc(*data, len);\n\tif (!p) {\n\t\tgoto err;\n\t}\n\t*data = p;\n\t*data_len = len;\n\tr = sc_read_binary(card, 0, p, len, 0);\n\tif (r < 0)\n\t\tgoto err;\n\t*data_len = r;\n\tok = 1;\nerr:\n\tsc_file_free(file);\n\treturn ok;\n}", "target": 0}
{"code": "Extension::State ExtensionPrefs::GetExtensionState(\n    const std::string& extension_id) const {\n  const DictionaryValue* extension = GetExtensionPref(extension_id);\n  if (!extension)\n    return Extension::ENABLED;\n  int state = -1;\n  if (!extension->GetInteger(kPrefState, &state) ||\n      state < 0 || state >= Extension::NUM_STATES) {\n    LOG(ERROR) << \"Bad or missing pref 'state' for extension '\"\n               << extension_id << \"'\";\n    return Extension::ENABLED;\n  }\n  return static_cast<Extension::State>(state);\n}", "target": 0}
{"code": "archive_strncat_l(struct archive_string *as, const void *_p, size_t n,\n    struct archive_string_conv *sc)\n{\n\tconst void *s;\n\tsize_t length;\n\tint i, r = 0, r2;\n\tif (_p == NULL || n == 0) {\n\t\tint tn = 1;\n\t\tif (sc != NULL && (sc->flag & SCONV_TO_UTF16))\n\t\t\ttn = 2;\n\t\tif (archive_string_ensure(as, as->length + tn) == NULL)\n\t\t\treturn (-1);\n\t\tas->s[as->length] = 0;\n\t\tif (tn == 2)\n\t\t\tas->s[as->length+1] = 0;\n\t\treturn (0);\n\t}\n\tif (sc == NULL) {\n\t\tlength = mbsnbytes(_p, n);\n\t\tif (archive_string_append(as, _p, length) == NULL)\n\t\t\treturn (-1);\n\t\treturn (0);\n\t}\n\tif (sc->flag & SCONV_FROM_UTF16)\n\t\tlength = utf16nbytes(_p, n);\n\telse\n\t\tlength = mbsnbytes(_p, n);\n\ts = _p;\n\ti = 0;\n\tif (sc->nconverter > 1) {\n\t\tsc->utftmp.length = 0;\n\t\tr2 = sc->converter[0](&(sc->utftmp), s, length, sc);\n\t\tif (r2 != 0 && errno == ENOMEM)\n\t\t\treturn (r2);\n\t\tif (r > r2)\n\t\t\tr = r2;\n\t\ts = sc->utftmp.s;\n\t\tlength = sc->utftmp.length;\n\t\t++i;\n\t}\n\tr2 = sc->converter[i](as, s, length, sc);\n\tif (r > r2)\n\t\tr = r2;\n\treturn (r);\n}", "target": 1}
{"code": "static int jpc_qcd_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_qcd_t *qcd = &ms->parms.qcd;\n\tint i;\n\tfprintf(out, \"qntsty = %d; numguard = %d; numstepsizes = %d\\n\",\n\t  (int) qcd->compparms.qntsty, qcd->compparms.numguard, qcd->compparms.numstepsizes);\n\tfor (i = 0; i < qcd->compparms.numstepsizes; ++i) {\n\t\tfprintf(out, \"expn[%d] = 0x%04x; mant[%d] = 0x%04x;\\n\",\n\t\t  i, (unsigned) JPC_QCX_GETEXPN(qcd->compparms.stepsizes[i]),\n\t\t  i, (unsigned) JPC_QCX_GETMANT(qcd->compparms.stepsizes[i]));\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void arch_pick_mmap_layout(struct mm_struct *mm)\n{\n\tunsigned long random_factor = 0UL;\n\tif (current->flags & PF_RANDOMIZE)\n\t\trandom_factor = arch_mmap_rnd();\n\tmm->mmap_legacy_base = mmap_legacy_base(random_factor);\n\tif (mmap_is_legacy()) {\n\t\tmm->mmap_base = mm->mmap_legacy_base;\n\t\tmm->get_unmapped_area = arch_get_unmapped_area;\n\t} else {\n\t\tmm->mmap_base = mmap_base(random_factor);\n\t\tmm->get_unmapped_area = arch_get_unmapped_area_topdown;\n\t}\n}", "target": 1}
{"code": "tTcpIpPacketParsingResult ParaNdis_ReviewIPPacket(PVOID buffer, ULONG size, LPCSTR caller)\n{\n    tTcpIpPacketParsingResult res = QualifyIpPacket((IPHeader *) buffer, size);\n    PrintOutParsingResult(res, 1, caller);\n    return res;\n}", "target": 1}
{"code": "asmlinkage long compat_sys_ppoll(struct pollfd __user *ufds,\n\tunsigned int nfds, struct compat_timespec __user *tsp,\n\tconst compat_sigset_t __user *sigmask, compat_size_t sigsetsize)\n{\n\tcompat_sigset_t ss32;\n\tsigset_t ksigmask, sigsaved;\n\tstruct compat_timespec ts;\n\ts64 timeout = -1;\n\tint ret;\n\tif (tsp) {\n\t\tif (copy_from_user(&ts, tsp, sizeof(ts)))\n\t\t\treturn -EFAULT;\n\t\ttimeout = ROUND_UP(ts.tv_nsec, 1000000000/HZ);\n\t\ttimeout += ts.tv_sec * HZ;\n\t}\n\tif (sigmask) {\n\t\tif (sigsetsize != sizeof(compat_sigset_t))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&ss32, sigmask, sizeof(ss32)))\n\t\t\treturn -EFAULT;\n\t\tsigset_from_compat(&ksigmask, &ss32);\n\t\tsigdelsetmask(&ksigmask, sigmask(SIGKILL)|sigmask(SIGSTOP));\n\t\tsigprocmask(SIG_SETMASK, &ksigmask, &sigsaved);\n\t}\n\tret = do_sys_poll(ufds, nfds, &timeout);\n\tif (ret == -EINTR) {\n\t\tif (sigmask) {\n\t\t\tmemcpy(&current->saved_sigmask, &sigsaved,\n\t\t\t\tsizeof(sigsaved));\n\t\t\tset_thread_flag(TIF_RESTORE_SIGMASK);\n\t\t}\n\t\tret = -ERESTARTNOHAND;\n\t} else if (sigmask)\n\t\tsigprocmask(SIG_SETMASK, &sigsaved, NULL);\n\tif (tsp && timeout >= 0) {\n\t\tstruct compat_timespec rts;\n\t\tif (current->personality & STICKY_TIMEOUTS)\n\t\t\tgoto sticky;\n\t\trts.tv_nsec = jiffies_to_usecs(do_div((*(u64*)&timeout), HZ)) *\n\t\t\t\t\t1000;\n\t\trts.tv_sec = timeout;\n\t\tif (compat_timespec_compare(&rts, &ts) >= 0)\n\t\t\trts = ts;\n\t\tif (copy_to_user(tsp, &rts, sizeof(rts))) {\nsticky:\n\t\t\tif (ret == -ERESTARTNOHAND && timeout >= 0)\n\t\t\t\tret = -EINTR;\n\t\t}\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "int GfxUnivariateShading::getColor(double t, GfxColor *color)\n{\n    double out[gfxColorMaxComps];\n    int nComps;\n    if (likely(getNFuncs() >= 1)) {\n        nComps = getNFuncs() * funcs[0]->getOutputSize();\n    }\n    if (unlikely(getNFuncs() < 1 || nComps > gfxColorMaxComps)) {\n        clearGfxColor(color);\n        return gfxColorMaxComps;\n    }\n    if (cacheSize > 0) {\n        double x, ix, *l, *u, *upper;\n        if (cacheBounds[lastMatch - 1] >= t) {\n            upper = std::lower_bound(cacheBounds, cacheBounds + lastMatch - 1, t);\n            lastMatch = upper - cacheBounds;\n            lastMatch = std::min<int>(std::max<int>(1, lastMatch), cacheSize - 1);\n        } else if (cacheBounds[lastMatch] < t) {\n            upper = std::lower_bound(cacheBounds + lastMatch + 1, cacheBounds + cacheSize, t);\n            lastMatch = upper - cacheBounds;\n            lastMatch = std::min<int>(std::max<int>(1, lastMatch), cacheSize - 1);\n        }\n        x = (t - cacheBounds[lastMatch - 1]) * cacheCoeff[lastMatch];\n        ix = 1.0 - x;\n        u = cacheValues + lastMatch * nComps;\n        l = u - nComps;\n        for (int i = 0; i < nComps; ++i) {\n            out[i] = ix * l[i] + x * u[i];\n        }\n    } else {\n        for (int i = 0; i < nComps; ++i) {\n            out[i] = 0;\n        }\n        for (int i = 0; i < getNFuncs(); ++i) {\n            if (funcs[i]->getInputSize() != 1) {\n                error(errSyntaxWarning, -1, \"Invalid shading function (input != 1)\");\n                break;\n            }\n            funcs[i]->transform(&t, &out[i]);\n        }\n    }\n    for (int i = 0; i < nComps; ++i) {\n        color->c[i] = dblToCol(out[i]);\n    }\n    return nComps;\n}", "target": 0}
{"code": "static void fio_signal_handler_setup(void) {\n  struct sigaction act;\n  if (fio_old_sig_int.sa_handler)\n    return;\n  memset(&act, 0, sizeof(act));\n  act.sa_handler = sig_int_handler;\n  sigemptyset(&act.sa_mask);\n  act.sa_flags = SA_RESTART | SA_NOCLDSTOP;\n  if (sigaction(SIGINT, &act, &fio_old_sig_int)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n  if (sigaction(SIGTERM, &act, &fio_old_sig_term)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n#if !FIO_DISABLE_HOT_RESTART\n  if (sigaction(SIGUSR1, &act, &fio_old_sig_usr1)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n#endif\n  act.sa_handler = SIG_IGN;\n  if (sigaction(SIGPIPE, &act, &fio_old_sig_pipe)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n}", "target": 1}
{"code": "  CallOpDimensionsFromInputs(const int n, const int h, const int w, const int c,\n                             const int kx, const int ky, const int sx,\n                             const int sy, const string& data_format,\n                             const string& padding) {\n    OpContext op_context;\n    const std::vector<int> x = {n, h, w, c};\n    const std::vector<int> ksize = {1, kx, ky, 1};\n    std::vector<int> strides;\n    if (data_format == \"NHWC\") {\n      strides = {1, sy, sx, 1};\n    } else {\n      strides = {1, 1, sy, sx};\n    }\n    auto& op_info = op_context.op_info;\n    SetCpuDevice(&op_info);\n    op_info.set_op(\"MaxPool\");\n    DescribeTensor4D(x[0], x[1], x[2], x[3], op_info.add_inputs());\n    auto* attr = op_info.mutable_attr();\n    SetAttrValue(data_format, &(*attr)[\"data_format\"]);\n    SetAttrValue(padding, &(*attr)[\"padding\"]);\n    SetAttrValue(strides, &(*attr)[\"strides\"]);\n    SetAttrValue(ksize, &(*attr)[\"ksize\"]);\n    bool found_unknown_shapes;\n    return OpLevelCostEstimator::OpDimensionsFromInputs(\n        op_context.op_info.inputs(0).shape(), op_context.op_info,\n        &found_unknown_shapes);\n  }", "target": 0}
{"code": "int nfc_genl_fw_download_done(struct nfc_dev *dev, const char *firmware_name,\n\t\t\t      u32 result)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_CMD_FW_DOWNLOAD);\n\tif (!hdr)\n\t\tgoto free_msg;\n\tif (nla_put_string(msg, NFC_ATTR_FIRMWARE_NAME, firmware_name) ||\n\t    nla_put_u32(msg, NFC_ATTR_FIRMWARE_DOWNLOAD_STATUS, result) ||\n\t    nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\tgenlmsg_end(msg, hdr);\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\treturn 0;\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "ProcQueryTree(ClientPtr client)\n{\n    xQueryTreeReply reply;\n    int rc, numChildren = 0;\n    WindowPtr pChild, pWin, pHead;\n    Window *childIDs = (Window *) NULL;\n    REQUEST(xResourceReq);\n    REQUEST_SIZE_MATCH(xResourceReq);\n    rc = dixLookupWindow(&pWin, stuff->id, client, DixListAccess);\n    if (rc != Success)\n        return rc;\n    reply = (xQueryTreeReply) {\n        .type = X_Reply,\n        .sequenceNumber = client->sequence,\n        .root = pWin->drawable.pScreen->root->drawable.id,\n        .parent = (pWin->parent) ? pWin->parent->drawable.id : (Window) None\n    };\n    pHead = RealChildHead(pWin);\n    for (pChild = pWin->lastChild; pChild != pHead; pChild = pChild->prevSib)\n        numChildren++;\n    if (numChildren) {\n        int curChild = 0;\n        childIDs = malloc(numChildren * sizeof(Window));\n        if (!childIDs)\n            return BadAlloc;\n        for (pChild = pWin->lastChild; pChild != pHead;\n             pChild = pChild->prevSib)\n            childIDs[curChild++] = pChild->drawable.id;\n    }\n    reply.nChildren = numChildren;\n    reply.length = bytes_to_int32(numChildren * sizeof(Window));\n    WriteReplyToClient(client, sizeof(xQueryTreeReply), &reply);\n    if (numChildren) {\n        client->pSwapReplyFunc = (ReplySwapPtr) Swap32Write;\n        WriteSwappedDataToClient(client, numChildren * sizeof(Window),\n                                 childIDs);\n        free(childIDs);\n    }\n    return Success;\n}", "target": 0}
{"code": "void CoreUserInputHandler::handleSay(const BufferInfo &bufferInfo, const QString &msg)\n{\n    if (bufferInfo.bufferName().isEmpty() || !bufferInfo.acceptsRegularMessages())\n        return;  \n    QByteArray encMsg = channelEncode(bufferInfo.bufferName(), msg);\n#ifdef HAVE_QCA2\n    putPrivmsg(serverEncode(bufferInfo.bufferName()), encMsg, network()->cipher(bufferInfo.bufferName()));\n#else\n    putPrivmsg(serverEncode(bufferInfo.bufferName()), encMsg);\n#endif\n    emit displayMsg(Message::Plain, bufferInfo.type(), bufferInfo.bufferName(), msg, network()->myNick(), Message::Self);\n}", "target": 1}
{"code": "static int sco_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sco_pinfo *pi = sco_pi(sk);\n\tlock_sock(sk);\n\tif (sk->sk_state == BT_CONNECT2 &&\n\t    test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags)) {\n\t\tsco_conn_defer_accept(pi->conn->hcon, pi->setting);\n\t\tsk->sk_state = BT_CONFIG;\n\t\tmsg->msg_namelen = 0;\n\t\trelease_sock(sk);\n\t\treturn 0;\n\t}\n\trelease_sock(sk);\n\treturn bt_sock_recvmsg(iocb, sock, msg, len, flags);\n}", "target": 1}
{"code": "void ping_unhash(struct sock *sk)\n{\n\tstruct inet_sock *isk = inet_sk(sk);\n\tpr_debug(\"ping_unhash(isk=%p,isk->num=%u)\\n\", isk, isk->inet_num);\n\twrite_lock_bh(&ping_table.lock);\n\tif (sk_hashed(sk)) {\n\t\thlist_nulls_del(&sk->sk_nulls_node);\n\t\tsk_nulls_node_init(&sk->sk_nulls_node);\n\t\tsock_put(sk);\n\t\tisk->inet_num = 0;\n\t\tisk->inet_sport = 0;\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\t}\n\twrite_unlock_bh(&ping_table.lock);\n}", "target": 0}
{"code": "static int cdrom_ioctl_media_changed(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tstruct cdrom_changer_info *info;\n\tint ret;\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_MEDIA_CHANGED\\n\");\n\tif (!CDROM_CAN(CDC_MEDIA_CHANGED))\n\t\treturn -ENOSYS;\n\tif (!CDROM_CAN(CDC_SELECT_DISC) || arg == CDSL_CURRENT)\n\t\treturn media_changed(cdi, 1);\n\tif ((unsigned int)arg >= cdi->capacity)\n\t\treturn -EINVAL;\n\tinfo = kmalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\tret = cdrom_read_mech_status(cdi, info);\n\tif (!ret)\n\t\tret = info->slots[arg].change;\n\tkfree(info);\n\treturn ret;\n}", "target": 1}
{"code": "int gdAlphaBlend (int dst, int src) {\n    int src_alpha = gdTrueColorGetAlpha(src);\n    int dst_alpha, alpha, red, green, blue;\n    int src_weight, dst_weight, tot_weight;\n    if( src_alpha == gdAlphaOpaque )\n        return src;\n    dst_alpha = gdTrueColorGetAlpha(dst);\n    if( src_alpha == gdAlphaTransparent )\n        return dst;\n    if( dst_alpha == gdAlphaTransparent )\n        return src;\n    src_weight = gdAlphaTransparent - src_alpha;\n    dst_weight = (gdAlphaTransparent - dst_alpha) * src_alpha / gdAlphaMax;\n    tot_weight = src_weight + dst_weight;\n    alpha = src_alpha * dst_alpha / gdAlphaMax;\n    red = (gdTrueColorGetRed(src) * src_weight\n           + gdTrueColorGetRed(dst) * dst_weight) / tot_weight;\n    green = (gdTrueColorGetGreen(src) * src_weight\n           + gdTrueColorGetGreen(dst) * dst_weight) / tot_weight;\n    blue = (gdTrueColorGetBlue(src) * src_weight\n           + gdTrueColorGetBlue(dst) * dst_weight) / tot_weight;\n    return ((alpha << 24) + (red << 16) + (green << 8) + blue);\n}", "target": 1}
{"code": "int ocfs2_set_acl(handle_t *handle,\n\t\t\t struct inode *inode,\n\t\t\t struct buffer_head *di_bh,\n\t\t\t int type,\n\t\t\t struct posix_acl *acl,\n\t\t\t struct ocfs2_alloc_context *meta_ac,\n\t\t\t struct ocfs2_alloc_context *data_ac)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint ret;\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tumode_t mode = inode->i_mode;\n\t\t\tret = posix_acl_equiv_mode(acl, &mode);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (ret == 0)\n\t\t\t\tacl = NULL;\n\t\t\tret = ocfs2_acl_set_mode(inode, di_bh,\n\t\t\t\t\t\t handle, mode);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tvalue = ocfs2_acl_to_xattr(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\tif (handle)\n\t\tret = ocfs2_xattr_set_handle(handle, inode, di_bh, name_index,\n\t\t\t\t\t     \"\", value, size, 0,\n\t\t\t\t\t     meta_ac, data_ac);\n\telse\n\t\tret = ocfs2_xattr_set(inode, name_index, \"\", value, size, 0);\n\tkfree(value);\n\treturn ret;\n}", "target": 1}
{"code": "rfbSendServerCutText(rfbScreenInfoPtr rfbScreen,char *str, int len)\n{\n    rfbClientPtr cl;\n    rfbServerCutTextMsg sct;\n    rfbClientIteratorPtr iterator;\n    iterator = rfbGetClientIterator(rfbScreen);\n    while ((cl = rfbClientIteratorNext(iterator)) != NULL) {\n        sct.type = rfbServerCutText;\n        sct.length = Swap32IfLE(len);\n        LOCK(cl->sendMutex);\n        if (rfbWriteExact(cl, (char *)&sct,\n                       sz_rfbServerCutTextMsg) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n            UNLOCK(cl->sendMutex);\n            continue;\n        }\n        if (rfbWriteExact(cl, str, len) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n        }\n        UNLOCK(cl->sendMutex);\n        rfbStatRecordMessageSent(cl, rfbServerCutText, sz_rfbServerCutTextMsg+len, sz_rfbServerCutTextMsg+len);\n    }\n    rfbReleaseClientIterator(iterator);\n}", "target": 1}
{"code": "const char* RtmpProtocol::handle_C2(const char *data, size_t len) {\n    if (len < C1_HANDSHARK_SIZE) {\n        return nullptr;\n    }\n    _next_step_func = [this](const char *data, size_t len) {\n        return handle_rtmp(data, len);\n    };\n    return handle_rtmp(data + C1_HANDSHARK_SIZE, len - C1_HANDSHARK_SIZE);\n}", "target": 0}
{"code": "int __pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address)\n{\n\tpmd_t *new = pmd_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\tsmp_wmb(); \n\tspin_lock(&mm->page_table_lock);\n#ifndef __ARCH_HAS_4LEVEL_HACK\n\tif (pud_present(*pud))\t\t\n\t\tpmd_free(mm, new);\n\telse\n\t\tpud_populate(mm, pud, new);\n#else\n\tif (pgd_present(*pud))\t\t\n\t\tpmd_free(mm, new);\n\telse\n\t\tpgd_populate(mm, pud, new);\n#endif \n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}", "target": 0}
{"code": "static unsigned addChunk_iTXt(ucvector* out, unsigned compressed, const char* keyword, const char* langtag,\n                              const char* transkey, const char* textstring, LodePNGCompressSettings* zlibsettings)\n{\n  unsigned error = 0;\n  ucvector data;\n  size_t i, textsize = strlen(textstring);\n  ucvector_init(&data);\n  for(i = 0; keyword[i] != 0; i++) ucvector_push_back(&data, (unsigned char)keyword[i]);\n  if(i < 1 || i > 79) return 89; \n  ucvector_push_back(&data, 0); \n  ucvector_push_back(&data, compressed ? 1 : 0); \n  ucvector_push_back(&data, 0); \n  for(i = 0; langtag[i] != 0; i++) ucvector_push_back(&data, (unsigned char)langtag[i]);\n  ucvector_push_back(&data, 0); \n  for(i = 0; transkey[i] != 0; i++) ucvector_push_back(&data, (unsigned char)transkey[i]);\n  ucvector_push_back(&data, 0); \n  if(compressed)\n  {\n    ucvector compressed_data;\n    ucvector_init(&compressed_data);\n    error = zlib_compress(&compressed_data.data, &compressed_data.size,\n                          (unsigned char*)textstring, textsize, zlibsettings);\n    if(!error)\n    {\n      for(i = 0; i < compressed_data.size; i++) ucvector_push_back(&data, compressed_data.data[i]);\n    }\n    ucvector_cleanup(&compressed_data);\n  }\n  else \n  {\n    for(i = 0; textstring[i] != 0; i++) ucvector_push_back(&data, (unsigned char)textstring[i]);\n  }\n  if(!error) error = addChunk(out, \"iTXt\", data.data, data.size);\n  ucvector_cleanup(&data);\n  return error;\n}", "target": 0}
{"code": "void LibRaw::nikon_coolscan_load_raw()\n{\n  if (!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  int bypp = tiff_bps <= 8 ? 1 : 2;\n  int bufsize = width * 3 * bypp;\n  unsigned char *buf = (unsigned char *)malloc(bufsize);\n  unsigned short *ubuf = (unsigned short *)buf;\n  if (tiff_bps <= 8)\n    gamma_curve(1.0 / imgdata.params.coolscan_nef_gamma, 0., 1, 255);\n  else\n    gamma_curve(1.0 / imgdata.params.coolscan_nef_gamma, 0., 1, 65535);\n  fseek(ifp, data_offset, SEEK_SET);\n  for (int row = 0; row < raw_height; row++)\n  {\n      if(tiff_bps <=8)\n        fread(buf, 1, bufsize, ifp);\n      else\n          read_shorts(ubuf,width*3);\n    unsigned short(*ip)[4] = (unsigned short(*)[4])image + row * width;\n    if (is_NikonTransfer == 2)\n    { \n      for (int col = 0; col < width; col++)\n      {\n        ip[col][0] = ((float)curve[buf[col * 3]]) / 255.0f;\n        ip[col][1] = ((float)curve[buf[col * 3 + 1]]) / 255.0f;\n        ip[col][2] = ((float)curve[buf[col * 3 + 2]]) / 255.0f;\n        ip[col][3] = 0;\n      }\n    }\n    else if (tiff_bps <= 8)\n    {\n      for (int col = 0; col < width; col++)\n      {\n        ip[col][0] = curve[buf[col * 3]];\n        ip[col][1] = curve[buf[col * 3 + 1]];\n        ip[col][2] = curve[buf[col * 3 + 2]];\n        ip[col][3] = 0;\n      }\n    }\n    else\n    {\n      for (int col = 0; col < width; col++)\n      {\n        ip[col][0] = curve[ubuf[col * 3]];\n        ip[col][1] = curve[ubuf[col * 3 + 1]];\n        ip[col][2] = curve[ubuf[col * 3 + 2]];\n        ip[col][3] = 0;\n      }\n    }\n  }\n  free(buf);\n}", "target": 0}
{"code": "static void __exit packet_exit(void)\n{\n\tunregister_netdevice_notifier(&packet_netdev_notifier);\n\tunregister_pernet_subsys(&packet_net_ops);\n\tsock_unregister(PF_PACKET);\n\tproto_unregister(&packet_proto);\n}", "target": 0}
{"code": "mes_lookup (struct message *meslist, int max, int index)\n{\n  if ((index >= 0) && (index < max) && (meslist[index].key == index))\n    return meslist[index].str;\n  {\n    int i;\n    for (i = 0; i < max; i++, meslist++)\n      {\n\tif (meslist->key == index)\n\t  {\n\t    zlog_warn(\"message index %d [%s] found in position %d (max is %d)\",\n\t\t      index, meslist->str, i, max);\n\t    return meslist->str;\n\t  }\n      }\n  }\n  zlog_err(\"message index %d not found (max is %d)\", index, max);\n  return NULL;\n}", "target": 1}
{"code": "static void early_init_amd(struct cpuinfo_x86 *c)\n{\n\tearly_init_amd_mc(c);\n\tif (c->x86_power & (1 << 8)) {\n\t\tset_cpu_cap(c, X86_FEATURE_CONSTANT_TSC);\n\t\tset_cpu_cap(c, X86_FEATURE_NONSTOP_TSC);\n\t\tif (!check_tsc_unstable())\n\t\t\tsched_clock_stable = 1;\n\t}\n#ifdef CONFIG_X86_64\n\tset_cpu_cap(c, X86_FEATURE_SYSCALL32);\n#else\n\tif (c->x86 == 5)\n\t\tif (c->x86_model == 13 || c->x86_model == 9 ||\n\t\t    (c->x86_model == 8 && c->x86_mask >= 8))\n\t\t\tset_cpu_cap(c, X86_FEATURE_K6_MTRR);\n#endif\n#if defined(CONFIG_X86_LOCAL_APIC) && defined(CONFIG_PCI)\n\tif (cpu_has_apic && c->x86 >= 0xf) {\n\t\tunsigned int val;\n\t\tval = read_pci_config(0, 24, 0, 0x68);\n\t\tif ((val & ((1 << 17) | (1 << 18))) == ((1 << 17) | (1 << 18)))\n\t\t\tset_cpu_cap(c, X86_FEATURE_EXTD_APICID);\n\t}\n#endif\n}", "target": 1}
{"code": "static int amdgpu_cs_wait_all_fences(struct amdgpu_device *adev,\n\t\t\t\t     struct drm_file *filp,\n\t\t\t\t     union drm_amdgpu_wait_fences *wait,\n\t\t\t\t     struct drm_amdgpu_fence *fences)\n{\n\tuint32_t fence_count = wait->in.fence_count;\n\tunsigned int i;\n\tlong r = 1;\n\tfor (i = 0; i < fence_count; i++) {\n\t\tstruct dma_fence *fence;\n\t\tunsigned long timeout = amdgpu_gem_timeout(wait->in.timeout_ns);\n\t\tfence = amdgpu_cs_get_fence(adev, filp, &fences[i]);\n\t\tif (IS_ERR(fence))\n\t\t\treturn PTR_ERR(fence);\n\t\telse if (!fence)\n\t\t\tcontinue;\n\t\tr = dma_fence_wait_timeout(fence, true, timeout);\n\t\tdma_fence_put(fence);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t\tif (r == 0)\n\t\t\tbreak;\n\t\tif (fence->error)\n\t\t\treturn fence->error;\n\t}\n\tmemset(wait, 0, sizeof(*wait));\n\twait->out.status = (r > 0);\n\treturn 0;\n}", "target": 1}
{"code": "  bool Messageheader::Parser::state_fieldbody_crlf(char ch)\n  {\n    if (ch == '\\r')\n      SET_STATE(state_end_cr);\n    else if (ch == '\\n')\n    {\n      log_debug(\"header \" << fieldnamePtr << \": \" << fieldbodyPtr);\n      switch (header.onField(fieldnamePtr, fieldbodyPtr))\n      {\n        case OK:\n        case END:  return true;\n                   break;\n        case FAIL: failedFlag = true;\n                   log_warn(\"invalid character \" << chartoprint(ch) << \" in fieldbody\");\n                   break;\n      }\n      *headerdataPtr = '\\0';\n      return true;\n    }\n    else if (std::isspace(ch))\n    {\n      checkHeaderspace(1);\n      *(headerdataPtr - 1) = '\\n';\n      *headerdataPtr++ = ch;\n      SET_STATE(state_fieldbody);\n    }\n    else if (ch >= 33 && ch <= 126)\n    {\n      switch (header.onField(fieldnamePtr, fieldbodyPtr))\n      {\n        case OK:   SET_STATE(state_fieldname);\n                   break;\n        case FAIL: failedFlag = true;\n                   log_warn(\"invalid character \" << chartoprint(ch) << \" in fieldbody\");\n                   break;\n        case END:  return true;\n                   break;\n      }\n      fieldnamePtr = headerdataPtr;\n      checkHeaderspace(1);\n      *headerdataPtr++ = ch;\n    }\n    return false;\n  }", "target": 1}
{"code": "void gru_check_context_placement(struct gru_thread_state *gts)\n{\n\tstruct gru_state *gru;\n\tgru = gts->ts_gru;\n\tif (!gru || gts->ts_tgid_owner != current->tgid)\n\t\treturn;\n\tif (!gru_check_chiplet_assignment(gru, gts)) {\n\t\tSTAT(check_context_unload);\n\t\tgru_unload_context(gts, 1);\n\t} else if (gru_retarget_intr(gts)) {\n\t\tSTAT(check_context_retarget_intr);\n\t}\n}", "target": 1}
{"code": "int unit_name_to_prefix(const char *n, char **ret) {\n        const char *p;\n        char *s;\n        assert(n);\n        assert(ret);\n        if (!unit_name_is_valid(n, UNIT_NAME_ANY))\n                return -EINVAL;\n        p = strchr(n, '@');\n        if (!p)\n                p = strrchr(n, '.');\n        assert_se(p);\n        s = strndup(n, p - n);\n        if (!s)\n                return -ENOMEM;\n        *ret = s;\n        return 0;\n}", "target": 0}
{"code": "sg_release(struct inode *inode, struct file *filp)\n{\n\tSg_device *sdp;\n\tSg_fd *sfp;\n\tif ((!(sfp = (Sg_fd *) filp->private_data)) || (!(sdp = sfp->parentdp)))\n\t\treturn -ENXIO;\n\tSCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sdp, \"sg_release\\n\"));\n\tmutex_lock(&sdp->open_rel_lock);\n\tscsi_autopm_put_device(sdp->device);\n\tkref_put(&sfp->f_ref, sg_remove_sfp);\n\tsdp->open_cnt--;\n\tif (sdp->exclude) {\n\t\tsdp->exclude = false;\n\t\twake_up_interruptible_all(&sdp->open_wait);\n\t} else if (0 == sdp->open_cnt) {\n\t\twake_up_interruptible(&sdp->open_wait);\n\t}\n\tmutex_unlock(&sdp->open_rel_lock);\n\treturn 0;\n}", "target": 0}
{"code": "int inet_sk_rebuild_header(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct rtable *rt = (struct rtable *)__sk_dst_check(sk, 0);\n\t__be32 daddr;\n\tint err;\n\tif (rt)\n\t\treturn 0;\n\tdaddr = inet->inet_daddr;\n\tif (inet->opt && inet->opt->srr)\n\t\tdaddr = inet->opt->faddr;\n\trt = ip_route_output_ports(sock_net(sk), sk, daddr, inet->inet_saddr,\n\t\t\t\t   inet->inet_dport, inet->inet_sport,\n\t\t\t\t   sk->sk_protocol, RT_CONN_FLAGS(sk),\n\t\t\t\t   sk->sk_bound_dev_if);\n\tif (!IS_ERR(rt)) {\n\t\terr = 0;\n\t\tsk_setup_caps(sk, &rt->dst);\n\t} else {\n\t\terr = PTR_ERR(rt);\n\t\tsk->sk_route_caps = 0;\n\t\tif (!sysctl_ip_dynaddr ||\n\t\t    sk->sk_state != TCP_SYN_SENT ||\n\t\t    (sk->sk_userlocks & SOCK_BINDADDR_LOCK) ||\n\t\t    (err = inet_sk_reselect_saddr(sk)) != 0)\n\t\t\tsk->sk_err_soft = -err;\n\t}\n\treturn err;\n}", "target": 1}
{"code": "void vmacache_flush_all(struct mm_struct *mm)\n{\n\tstruct task_struct *g, *p;\n\tcount_vm_vmacache_event(VMACACHE_FULL_FLUSHES);\n\tif (atomic_read(&mm->mm_users) == 1)\n\t\treturn;\n\trcu_read_lock();\n\tfor_each_process_thread(g, p) {\n\t\tif (mm == p->mm)\n\t\t\tvmacache_flush(p);\n\t}\n\trcu_read_unlock();\n}", "target": 1}
{"code": "        EDP* getEDP() { return &edp_; }", "target": 1}
{"code": "bool kvm_valid_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tif (efer & efer_reserved_bits)\n\t\treturn false;\n\tif (efer & EFER_FFXSR) {\n\t\tstruct kvm_cpuid_entry2 *feat;\n\t\tfeat = kvm_find_cpuid_entry(vcpu, 0x80000001, 0);\n\t\tif (!feat || !(feat->edx & bit(X86_FEATURE_FXSR_OPT)))\n\t\t\treturn false;\n\t}\n\tif (efer & EFER_SVME) {\n\t\tstruct kvm_cpuid_entry2 *feat;\n\t\tfeat = kvm_find_cpuid_entry(vcpu, 0x80000001, 0);\n\t\tif (!feat || !(feat->ecx & bit(X86_FEATURE_SVM)))\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "target": 0}
{"code": "int test_gtpu_send_indirect_data_forwarding(\n        ogs_socknode_t *node, test_bearer_t *bearer, ogs_pkbuf_t *pkbuf)\n{\n    test_sess_t *sess = NULL;\n    ogs_gtp2_header_t gtp_hdesc;\n    ogs_gtp2_extension_header_t ext_hdesc;\n    ogs_assert(bearer);\n    sess = bearer->sess;\n    ogs_assert(sess);\n    ogs_assert(pkbuf);\n    memset(&gtp_hdesc, 0, sizeof(gtp_hdesc));\n    memset(&ext_hdesc, 0, sizeof(ext_hdesc));\n    gtp_hdesc.type = OGS_GTPU_MSGTYPE_GPDU;\n    if (bearer->qfi) {\n        gtp_hdesc.teid = sess->handover.upf_dl_teid;\n        ext_hdesc.qos_flow_identifier = bearer->qfi;\n    } else if (bearer->ebi) {\n        ogs_fatal(\"Not implmented EPC Indirect Tunnel\");\n        ogs_assert_if_reached();\n    } else {\n        ogs_fatal(\"No QFI[%d] and EBI[%d]\", bearer->qfi, bearer->ebi);\n        ogs_assert_if_reached();\n    }\n    return test_gtpu_send(node, bearer, &gtp_hdesc, &ext_hdesc, pkbuf);\n}", "target": 1}
{"code": "R_API RBinJavaVerificationObj *r_bin_java_verification_info_from_type(RBinJavaObj *bin, R_BIN_JAVA_STACKMAP_TYPE type, ut32 value) {\n\tRBinJavaVerificationObj *se = R_NEW0 (RBinJavaVerificationObj);\n\tif (!se) {\n\t\treturn NULL;\n\t}\n\tse->tag = type;\n\tif (se->tag == R_BIN_JAVA_STACKMAP_OBJECT) {\n\t\tse->info.obj_val_cp_idx = (ut16) value;\n\t} else if (se->tag == R_BIN_JAVA_STACKMAP_UNINIT) {\n\t\tse->info.uninit_offset = (ut16) value;\n\t}\n\treturn se;\n}", "target": 1}
{"code": "static void smp_update_key_mask(tSMP_CB* p_cb, uint8_t key_type, bool recv) {\n  SMP_TRACE_DEBUG(\n \"%s before update role=%d recv=%d local_i_key = %02x, local_r_key = %02x\",\n      __func__, p_cb->role, recv, p_cb->local_i_key, p_cb->local_r_key);\n if (((p_cb->le_secure_connections_mode_is_used) || (p_cb->smp_over_br)) &&\n ((key_type == SMP_SEC_KEY_TYPE_ENC) ||\n (key_type == SMP_SEC_KEY_TYPE_LK))) {\n    p_cb->local_i_key &= ~key_type;\n    p_cb->local_r_key &= ~key_type;\n } else if (p_cb->role == HCI_ROLE_SLAVE) {\n if (recv)\n      p_cb->local_i_key &= ~key_type;\n else\n      p_cb->local_r_key &= ~key_type;\n } else {\n if (recv)\n      p_cb->local_r_key &= ~key_type;\n else\n      p_cb->local_i_key &= ~key_type;\n }\n  SMP_TRACE_DEBUG(\"updated local_i_key = %02x, local_r_key = %02x\",\n                  p_cb->local_i_key, p_cb->local_r_key);\n}", "target": 0}
{"code": "static ssize_t show_constraint_name(struct device *dev,\n\t\t\t\tstruct device_attribute *dev_attr,\n\t\t\t\tchar *buf)\n{\n\tconst char *name;\n\tstruct powercap_zone *power_zone = to_powercap_zone(dev);\n\tint id;\n\tssize_t len = -ENODATA;\n\tstruct powercap_zone_constraint *pconst;\n\tif (!sscanf(dev_attr->attr.name, \"constraint_%d_\", &id))\n\t\treturn -EINVAL;\n\tif (id >= power_zone->const_id_cnt)\n\t\treturn -EINVAL;\n\tpconst = &power_zone->constraints[id];\n\tif (pconst && pconst->ops && pconst->ops->get_name) {\n\t\tname = pconst->ops->get_name(power_zone, id);\n\t\tif (name) {\n\t\t\tsnprintf(buf, POWERCAP_CONSTRAINT_NAME_LEN,\n\t\t\t\t\t\t\t\t\"%s\\n\", name);\n\t\t\tbuf[POWERCAP_CONSTRAINT_NAME_LEN] = '\\0';\n\t\t\tlen = strlen(buf);\n\t\t}\n\t}\n\treturn len;\n}", "target": 0}
{"code": "static void put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\tif (atomic_dec_and_test(&ucounts->count)) {\n\t\tspin_lock_irqsave(&ucounts_lock, flags);\n\t\thlist_del_init(&ucounts->node);\n\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\t\tkfree(ucounts);\n\t}\n}", "target": 1}
{"code": "sctp_disposition_t sctp_sf_ootb(struct net *net,\n\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\tvoid *arg,\n\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sk_buff *skb = chunk->skb;\n\tsctp_chunkhdr_t *ch;\n\tsctp_errhdr_t *err;\n\t__u8 *ch_end;\n\tint ootb_shut_ack = 0;\n\tint ootb_cookie_ack = 0;\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\tch = (sctp_chunkhdr_t *) chunk->chunk_hdr;\n\tdo {\n\t\tif (ntohs(ch->length) < sizeof(sctp_chunkhdr_t))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\t\tif (SCTP_CID_SHUTDOWN_ACK == ch->type)\n\t\t\tootb_shut_ack = 1;\n\t\tif (SCTP_CID_ABORT == ch->type)\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\tif (SCTP_CID_COOKIE_ACK == ch->type)\n\t\t\tootb_cookie_ack = 1;\n\t\tif (SCTP_CID_ERROR == ch->type) {\n\t\t\tsctp_walk_errors(err, ch) {\n\t\t\t\tif (SCTP_ERROR_STALE_COOKIE == err->cause) {\n\t\t\t\t\tootb_cookie_ack = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tch_end = ((__u8 *)ch) + WORD_ROUND(ntohs(ch->length));\n\t\tif (ch_end > skb_tail_pointer(skb))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\t\tch = (sctp_chunkhdr_t *) ch_end;\n\t} while (ch_end < skb_tail_pointer(skb));\n\tif (ootb_shut_ack)\n\t\treturn sctp_sf_shut_8_4_5(net, ep, asoc, type, arg, commands);\n\telse if (ootb_cookie_ack)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\telse\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n}", "target": 0}
{"code": "ble_hs_conn_timer(void)\n{\n#if MYNEWT_VAL(BLE_L2CAP_RX_FRAG_TIMEOUT) == 0 && \\\n    BLE_HS_ATT_SVR_QUEUED_WRITE_TMO == 0\n    return BLE_HS_FOREVER;\n#endif\n    struct ble_hs_conn *conn;\n    ble_npl_time_t now;\n    int32_t next_exp_in;\n    int32_t time_diff;\n    uint16_t conn_handle;\n    for (;;) {\n        conn_handle = BLE_HS_CONN_HANDLE_NONE;\n        next_exp_in = BLE_HS_FOREVER;\n        now = ble_npl_time_get();\n        ble_hs_lock();\n        SLIST_FOREACH(conn, &ble_hs_conns, bhc_next) {\n            if (!(conn->bhc_flags & BLE_HS_CONN_F_TERMINATING)) {\n#if MYNEWT_VAL(BLE_L2CAP_RX_FRAG_TIMEOUT) != 0\n                if (conn->bhc_rx_chan != NULL) {\n                    time_diff = conn->bhc_rx_timeout - now;\n                    if (time_diff <= 0) {\n                        conn_handle = conn->bhc_handle;\n                        break;\n                    }\n                    if (time_diff < next_exp_in) {\n                        next_exp_in = time_diff;\n                    }\n                }\n#endif\n#if BLE_HS_ATT_SVR_QUEUED_WRITE_TMO\n                time_diff = ble_att_svr_ticks_until_tmo(&conn->bhc_att_svr, now);\n                if (time_diff <= 0) {\n                    conn_handle = conn->bhc_handle;\n                    break;\n                }\n                if (time_diff < next_exp_in) {\n                    next_exp_in = time_diff;\n                }\n#endif\n            }\n        }\n        ble_hs_unlock();\n        if (conn_handle != BLE_HS_CONN_HANDLE_NONE) {\n            ble_gap_terminate(conn_handle, BLE_ERR_REM_USER_CONN_TERM);\n            continue;\n        }\n        return next_exp_in;\n    }\n}", "target": 1}
{"code": "static int vsock_create(struct net *net, struct socket *sock,\n\t\t\tint protocol, int kern)\n{\n\tif (!sock)\n\t\treturn -EINVAL;\n\tif (protocol && protocol != PF_VSOCK)\n\t\treturn -EPROTONOSUPPORT;\n\tswitch (sock->type) {\n\tcase SOCK_DGRAM:\n\t\tsock->ops = &vsock_dgram_ops;\n\t\tbreak;\n\tcase SOCK_STREAM:\n\t\tsock->ops = &vsock_stream_ops;\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\tsock->state = SS_UNCONNECTED;\n\treturn __vsock_create(net, sock, NULL, GFP_KERNEL, 0) ? 0 : -ENOMEM;\n}", "target": 0}
{"code": "      void Init(void)\n      {\n        for(int i = 0;i < 19;i++) {\n#ifdef DEBUG_QMCODER\n          char string[5] = \"X0  \";\n          string[1] = (i / 10) + '0';\n          string[2] = (i % 10) + '0';\n          X[i].Init(string);\n          string[0] = 'M';\n          M[i].Init(string);\n#else\n          X[i].Init();\n          M[i].Init();\n#endif\n        }\n      }", "target": 1}
{"code": "get_blk_size(int fd)\n{\n\tstruct stat stat;\n\tint ret;\n\tret = fstat(fd, &stat);\n\treturn ret == -1 ? (uint64_t)-1 : (uint64_t)stat.st_blksize;\n}", "target": 0}
{"code": "void usbredirparser_init(struct usbredirparser *parser_pub,\n    const char *version, uint32_t *caps, int caps_len, int flags)\n{\n    struct usbredirparser_priv *parser =\n        (struct usbredirparser_priv *)parser_pub;\n    struct usb_redir_hello_header hello = { { 0 }, };\n    parser->flags = (flags & ~usbredirparser_fl_no_hello);\n    if (parser->callb.alloc_lock_func) {\n        parser->lock = parser->callb.alloc_lock_func();\n    }\n    snprintf(hello.version, sizeof(hello.version), \"%s\", version);\n    if (caps_len > USB_REDIR_CAPS_SIZE) {\n        caps_len = USB_REDIR_CAPS_SIZE;\n    }\n    memcpy(parser->our_caps, caps, caps_len * sizeof(uint32_t));\n    if (!(flags & usbredirparser_fl_usb_host))\n        usbredirparser_caps_set_cap(parser->our_caps,\n                                    usb_redir_cap_device_disconnect_ack);\n    usbredirparser_verify_caps(parser, parser->our_caps, \"our\");\n    if (!(flags & usbredirparser_fl_no_hello))\n        usbredirparser_queue(parser_pub, usb_redir_hello, 0, &hello,\n                             (uint8_t *)parser->our_caps,\n                             USB_REDIR_CAPS_SIZE * sizeof(uint32_t));\n}", "target": 0}
{"code": "static int wcd9335_slim_status(struct slim_device *sdev,\n\t\t\t       enum slim_device_status status)\n{\n\tstruct device *dev = &sdev->dev;\n\tstruct device_node *ifc_dev_np;\n\tstruct wcd9335_codec *wcd;\n\tint ret;\n\twcd = dev_get_drvdata(dev);\n\tifc_dev_np = of_parse_phandle(dev->of_node, \"slim-ifc-dev\", 0);\n\tif (!ifc_dev_np) {\n\t\tdev_err(dev, \"No Interface device found\\n\");\n\t\treturn -EINVAL;\n\t}\n\twcd->slim = sdev;\n\twcd->slim_ifc_dev = of_slim_get_device(sdev->ctrl, ifc_dev_np);\n\tof_node_put(ifc_dev_np);\n\tif (!wcd->slim_ifc_dev) {\n\t\tdev_err(dev, \"Unable to get SLIM Interface device\\n\");\n\t\treturn -EINVAL;\n\t}\n\tslim_get_logical_addr(wcd->slim_ifc_dev);\n\twcd->regmap = regmap_init_slimbus(sdev, &wcd9335_regmap_config);\n\tif (IS_ERR(wcd->regmap)) {\n\t\tdev_err(dev, \"Failed to allocate slim register map\\n\");\n\t\treturn PTR_ERR(wcd->regmap);\n\t}\n\twcd->if_regmap = regmap_init_slimbus(wcd->slim_ifc_dev,\n\t\t\t\t\t\t  &wcd9335_ifc_regmap_config);\n\tif (IS_ERR(wcd->if_regmap)) {\n\t\tdev_err(dev, \"Failed to allocate ifc register map\\n\");\n\t\treturn PTR_ERR(wcd->if_regmap);\n\t}\n\tret = wcd9335_bring_up(wcd);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to bringup WCD9335\\n\");\n\t\treturn ret;\n\t}\n\tret = wcd9335_irq_init(wcd);\n\tif (ret)\n\t\treturn ret;\n\twcd9335_probe(wcd);\n\treturn ret;\n}", "target": 0}
{"code": "M_bool M_fs_path_ishidden(const char *path, M_fs_info_t *info)\n{\n\tM_list_str_t *path_parts;\n\tsize_t        len;\n\tM_bool        ret        = M_FALSE;\n\t(void)info;\n\tif (path == NULL || *path == '\\0') {\n\t\treturn M_FALSE;\n\t}\n\tpath_parts = M_fs_path_componentize_path(path, M_FS_SYSTEM_UNIX);\n\tlen = M_list_str_len(path_parts);\n\tif (len > 0) {\n\t\tif (*M_list_str_at(path_parts, len-1) == '.') {\n\t\t\tret = M_TRUE;\n\t\t}\n\t}\n\tM_list_str_destroy(path_parts);\n\treturn ret;\n}", "target": 1}
{"code": "bool setup_tables_and_check_access(THD *thd, Name_resolution_context *context,\n                                   List<TABLE_LIST> *from_clause,\n                                   TABLE_LIST *tables, List<TABLE_LIST> &leaves,\n                                   bool select_insert, ulong want_access_first,\n                                   ulong want_access, bool full_table_list)\n{\n  DBUG_ENTER(\"setup_tables_and_check_access\");\n  if (setup_tables(thd, context, from_clause, tables,\n                   leaves, select_insert, full_table_list))\n    DBUG_RETURN(TRUE);\n  List_iterator<TABLE_LIST> ti(leaves);\n  TABLE_LIST *table_list;\n  ulong access= want_access_first;\n  while ((table_list= ti++))\n  {\n    if (table_list->belong_to_view && !table_list->view && \n        check_single_table_access(thd, access, table_list, FALSE))\n    {\n      tables->hide_view_error(thd);\n      DBUG_RETURN(TRUE);\n    }\n    access= want_access;\n  }\n  DBUG_RETURN(FALSE);\n}", "target": 0}
{"code": "  explicit FractionalMaxPoolOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"pooling_ratio\", &pooling_ratio_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"pseudo_random\", &pseudo_random_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"overlapping\", &overlapping_));\n    OP_REQUIRES(context, pooling_ratio_.size() == 4,\n                errors::InvalidArgument(\"pooling_ratio field must \"\n                                        \"specify 4 dimensions\"));\n    for (std::size_t i = 0; i < pooling_ratio_.size(); ++i) {\n      OP_REQUIRES(context, pooling_ratio_[i] >= 1,\n                  errors::InvalidArgument(\n                      \"pooling_ratio cannot be smaller than 1, got: \",\n                      pooling_ratio_[i]));\n    }\n    OP_REQUIRES(\n        context, pooling_ratio_[0] == 1 && pooling_ratio_[3] == 1,\n        errors::Unimplemented(\"Fractional max pooling is not yet \"\n                              \"supported on the batch nor channel dimension.\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"deterministic\", &deterministic_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed\", &seed_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed2\", &seed2_));\n    if (deterministic_) {\n      if ((seed_ == 0) && (seed2_ == 0)) {\n        seed_ = random::New64();\n        seed2_ = random::New64();\n      }\n    } else {\n      OP_REQUIRES(\n          context, (seed_ == 0) && (seed2_ == 0),\n          errors::InvalidArgument(\n              \"Both seed and seed2 should be 0 if deterministic is false.\"));\n    }\n  }", "target": 0}
{"code": "int vfs_parse_fs_string(struct fs_context *fc, const char *key,\n\t\t\tconst char *value, size_t v_size)\n{\n\tint ret;\n\tstruct fs_parameter param = {\n\t\t.key\t= key,\n\t\t.type\t= fs_value_is_flag,\n\t\t.size\t= v_size,\n\t};\n\tif (value) {\n\t\tparam.string = kmemdup_nul(value, v_size, GFP_KERNEL);\n\t\tif (!param.string)\n\t\t\treturn -ENOMEM;\n\t\tparam.type = fs_value_is_string;\n\t}\n\tret = vfs_parse_fs_param(fc, &param);\n\tkfree(param.string);\n\treturn ret;\n}", "target": 0}
{"code": "static struct dst_entry *inet6_csk_route_socket(struct sock *sk,\n\t\t\t\t\t\tstruct flowi6 *fl6)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct in6_addr *final_p, final;\n\tstruct dst_entry *dst;\n\tmemset(fl6, 0, sizeof(*fl6));\n\tfl6->flowi6_proto = sk->sk_protocol;\n\tfl6->daddr = sk->sk_v6_daddr;\n\tfl6->saddr = np->saddr;\n\tfl6->flowlabel = np->flow_label;\n\tIP6_ECN_flow_xmit(sk, fl6->flowlabel);\n\tfl6->flowi6_oif = sk->sk_bound_dev_if;\n\tfl6->flowi6_mark = sk->sk_mark;\n\tfl6->fl6_sport = inet->inet_sport;\n\tfl6->fl6_dport = inet->inet_dport;\n\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(fl6));\n\tfinal_p = fl6_update_dst(fl6, np->opt, &final);\n\tdst = __inet6_csk_dst_check(sk, np->dst_cookie);\n\tif (!dst) {\n\t\tdst = ip6_dst_lookup_flow(sk, fl6, final_p);\n\t\tif (!IS_ERR(dst))\n\t\t\t__inet6_csk_dst_store(sk, dst, NULL, NULL);\n\t}\n\treturn dst;\n}", "target": 1}
{"code": "static int virtio_net_ufo_pre_save(void *opaque)\n{\n    struct VirtIONetMigTmp *tmp = opaque;\n    tmp->has_ufo = tmp->parent->has_ufo;\n    return 0;\n}", "target": 0}
{"code": "int lxc_safe_long(const char *numstr, long int *converted)\n{\n\tchar *err = NULL;\n\tsigned long int sli;\n\terrno = 0;\n\tsli = strtol(numstr, &err, 0);\n\tif (errno == ERANGE && (sli == LONG_MAX || sli == LONG_MIN))\n\t\treturn -ERANGE;\n\tif (errno != 0 && sli == 0)\n\t\treturn -EINVAL;\n\tif (err == numstr || *err != '\\0')\n\t\treturn -EINVAL;\n\t*converted = sli;\n\treturn 0;\n}", "target": 0}
{"code": "Value ExpressionRegex::nextMatch(RegexExecutionState* regexState) const {\n    int execResult = execute(regexState);\n    if (execResult < 0) {\n        return Value(BSONNULL);\n    }\n    StringData input = *(regexState->input);\n    auto verifyBounds = [&input, this](auto startPos, auto limitPos, auto isCapture) {\n        if (startPos == -1 || limitPos == -1) {\n            massert(31304,\n                    str::stream() << \"Unexpected error occurred while executing \" << _opName\n                                  << \". startPos: \" << startPos << \", limitPos: \" << limitPos,\n                    isCapture && startPos == -1 && limitPos == -1);\n            return;\n        }\n        massert(31305,\n                str::stream() << \"Unexpected error occurred while executing \" << _opName\n                              << \". startPos: \" << startPos,\n                (startPos >= 0 && static_cast<size_t>(startPos) <= input.size()));\n        massert(31306,\n                str::stream() << \"Unexpected error occurred while executing \" << _opName\n                              << \". limitPos: \" << limitPos,\n                (limitPos >= 0 && static_cast<size_t>(limitPos) <= input.size()));\n        massert(31307,\n                str::stream() << \"Unexpected error occurred while executing \" << _opName\n                              << \". startPos: \" << startPos << \", limitPos: \" << limitPos,\n                startPos <= limitPos);\n    };\n    verifyBounds(regexState->capturesBuffer[0], regexState->capturesBuffer[1], false);\n    const int matchStartByteIndex = regexState->capturesBuffer[0];\n    StringData matchedStr =\n        input.substr(matchStartByteIndex, regexState->capturesBuffer[1] - matchStartByteIndex);\n    for (int byteIx = regexState->startBytePos; byteIx < matchStartByteIndex;\n         ++(regexState->startCodePointPos)) {\n        byteIx += getCodePointLength(input[byteIx]);\n    }\n    regexState->startBytePos = matchStartByteIndex;\n    std::vector<Value> captures;\n    captures.reserve(regexState->numCaptures);\n    for (int i = 0; i < regexState->numCaptures; ++i) {\n        const int start = regexState->capturesBuffer[2 * (i + 1)];\n        const int limit = regexState->capturesBuffer[2 * (i + 1) + 1];\n        verifyBounds(start, limit, true);\n        captures.push_back(start == -1 && limit == -1 ? Value(BSONNULL)\n                                                      : Value(input.substr(start, limit - start)));\n    }\n    MutableDocument match;\n    match.addField(\"match\", Value(matchedStr));\n    match.addField(\"idx\", Value(regexState->startCodePointPos));\n    match.addField(\"captures\", Value(captures));\n    return match.freezeToValue();\n}", "target": 0}
{"code": "void TestSocketLineReader::initTestCase()\n{\n    m_server = new Server(this);\n    QVERIFY2(m_server->listen(QHostAddress::LocalHost, 8694), \"Failed to create local tcp server\");\n    m_timer.setInterval(4000);\n    m_timer.setSingleShot(true);\n    connect(&m_timer, &QTimer::timeout, &m_loop, &QEventLoop::quit);\n    m_conn = new QSslSocket(this);\n    m_conn->connectToHost(QHostAddress::LocalHost, 8694);\n    connect(m_conn, &QAbstractSocket::connected, &m_loop, &QEventLoop::quit);\n    m_timer.start();\n    m_loop.exec();\n    QVERIFY2(m_conn->isOpen(), \"Could not connect to local tcp server\");\n}", "target": 1}
{"code": "monitor_sync(struct monitor *pmonitor)\n{\n\tif (options.compression) {\n\t\tmm_share_sync(&pmonitor->m_zlib, &pmonitor->m_zback);\n\t}\n}", "target": 1}
{"code": "ospf_make_md5_digest (struct ospf_interface *oi, struct ospf_packet *op)\n{\n  struct ospf_header *ospfh;\n  unsigned char digest[OSPF_AUTH_MD5_SIZE];\n  MD5_CTX ctx;\n  void *ibuf;\n  u_int32_t t;\n  struct crypt_key *ck;\n  const u_int8_t *auth_key;\n  ibuf = STREAM_DATA (op->s);\n  ospfh = (struct ospf_header *) ibuf;\n  if (ntohs (ospfh->auth_type) != OSPF_AUTH_CRYPTOGRAPHIC)\n    return 0;\n  t = (time(NULL) & 0xFFFFFFFF);\n  if (t > oi->crypt_seqnum)\n    oi->crypt_seqnum = t;\n  else\n    oi->crypt_seqnum++;\n  ospfh->u.crypt.crypt_seqnum = htonl (oi->crypt_seqnum); \n  if (list_isempty (OSPF_IF_PARAM (oi, auth_crypt)))\n    auth_key = (const u_int8_t *) \"\";\n  else\n    {\n      ck = listgetdata (listtail(OSPF_IF_PARAM (oi, auth_crypt)));\n      auth_key = ck->auth_key;\n    }\n  memset(&ctx, 0, sizeof(ctx));\n  MD5Init(&ctx);\n  MD5Update(&ctx, ibuf, ntohs (ospfh->length));\n  MD5Update(&ctx, auth_key, OSPF_AUTH_MD5_SIZE);\n  MD5Final(digest, &ctx);\n  stream_put (op->s, digest, OSPF_AUTH_MD5_SIZE);\n  op->length = ntohs (ospfh->length) + OSPF_AUTH_MD5_SIZE;\n  if (stream_get_endp(op->s) != op->length)\n    zlog_warn(\"ospf_make_md5_digest: length mismatch stream %lu ospf_packet %u\",\n\t      (u_long)stream_get_endp(op->s), op->length);\n  return OSPF_AUTH_MD5_SIZE;\n}", "target": 0}
{"code": "    bool load_face(Face & face, unsigned int options)\n    {\n#ifdef GRAPHITE2_TELEMETRY\n        telemetry::category _misc_cat(face.tele.misc);\n#endif\n        Face::Table silf(face, Tag::Silf, 0x00050000);\n        if (silf)   options &= ~gr_face_dumbRendering;\n        else if (!(options &  gr_face_dumbRendering))\n            return false;\n        if (!face.readGlyphs(options))\n            return false;\n        if (silf)\n        {\n            if (!face.readFeatures() || !face.readGraphite(silf))\n            {\n#if !defined GRAPHITE2_NTRACING\n                if (global_log)\n                {\n                    *global_log << json::object\n                        << \"type\" << \"fontload\"\n                        << \"failure\" << face.error()\n                        << \"context\" << face.error_context()\n                    << json::close;\n                }\n#endif\n                return false;\n            }\n            else\n                return true;\n        }\n        else\n            return options & gr_face_dumbRendering;\n    }", "target": 1}
{"code": "bool f2fs_init_extent_tree(struct inode *inode, struct f2fs_extent *i_ext)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct extent_tree *et;\n\tstruct extent_node *en;\n\tstruct extent_info ei;\n\tif (!f2fs_may_extent_tree(inode)) {\n\t\tif (i_ext && i_ext->len) {\n\t\t\ti_ext->len = 0;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tet = __grab_extent_tree(inode);\n\tif (!i_ext || !i_ext->len)\n\t\treturn false;\n\tget_extent_info(&ei, i_ext);\n\twrite_lock(&et->lock);\n\tif (atomic_read(&et->node_cnt))\n\t\tgoto out;\n\ten = __init_extent_tree(sbi, et, &ei);\n\tif (en) {\n\t\tspin_lock(&sbi->extent_lock);\n\t\tlist_add_tail(&en->list, &sbi->extent_list);\n\t\tspin_unlock(&sbi->extent_lock);\n\t}\nout:\n\twrite_unlock(&et->lock);\n\treturn false;\n}", "target": 1}
{"code": "static void do_client_disconnect(void)\n{\n    if (client_connected) {\n        udscs_server_write_all(server, VDAGENTD_CLIENT_DISCONNECTED, 0, 0,\n                               NULL, 0);\n        client_connected = false;\n    }\n}", "target": 1}
{"code": "set_text_distance(gs_point *pdist, double dx, double dy, const gs_matrix *pmat)\n{\n    int code = gs_distance_transform_inverse(dx, dy, pmat, pdist);\n    double rounded;\n    if (code == gs_error_undefinedresult) {\n        pdist->x = pdist->y = 0;\n    } else if (code < 0)\n        return code;\n    if (fabs(pdist->x - (rounded = floor(pdist->x + 0.5))) < 0.0005)\n        pdist->x = rounded;\n    if (fabs(pdist->y - (rounded = floor(pdist->y + 0.5))) < 0.0005)\n        pdist->y = rounded;\n    return 0;\n}", "target": 1}
{"code": "static void sctp_destroy_sock(struct sock *sk)\n{\n\tstruct sctp_sock *sp;\n\tpr_debug(\"%s: sk:%p\\n\", __func__, sk);\n\tsp = sctp_sk(sk);\n\tif (sp->ep == NULL)\n\t\treturn;\n\tif (sp->do_auto_asconf) {\n\t\tsp->do_auto_asconf = 0;\n\t\tlist_del(&sp->auto_asconf_list);\n\t}\n\tsctp_endpoint_free(sp->ep);\n\tlocal_bh_disable();\n\tsk_sockets_allocated_dec(sk);\n\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\tlocal_bh_enable();\n}", "target": 1}
{"code": "int SafeMulDims(const matvar_t *matvar, size_t* nelems)\n{\n    int i;\n    for ( i = 0; i < matvar->rank; i++ ) {\n        if ( !psnip_safe_size_mul(nelems, *nelems, matvar->dims[i]) ) {\n            *nelems = 0;\n            return 1;\n        }\n    }\n    return 0;\n}", "target": 1}
{"code": "static int neigh_fill_info(struct sk_buff *skb, struct neighbour *n,\n\t\t\t   u32 pid, u32 seq, int event, unsigned int flags)\n{\n\tunsigned long now = jiffies;\n\tunsigned char *b = skb->tail;\n\tstruct nda_cacheinfo ci;\n\tint locked = 0;\n\tu32 probes;\n\tstruct nlmsghdr *nlh = NLMSG_NEW(skb, pid, seq, event,\n\t\t\t\t\t sizeof(struct ndmsg), flags);\n\tstruct ndmsg *ndm = NLMSG_DATA(nlh);\n\tndm->ndm_family\t = n->ops->family;\n\tndm->ndm_flags\t = n->flags;\n\tndm->ndm_type\t = n->type;\n\tndm->ndm_ifindex = n->dev->ifindex;\n\tRTA_PUT(skb, NDA_DST, n->tbl->key_len, n->primary_key);\n\tread_lock_bh(&n->lock);\n\tlocked\t\t = 1;\n\tndm->ndm_state\t = n->nud_state;\n\tif (n->nud_state & NUD_VALID)\n\t\tRTA_PUT(skb, NDA_LLADDR, n->dev->addr_len, n->ha);\n\tci.ndm_used\t = now - n->used;\n\tci.ndm_confirmed = now - n->confirmed;\n\tci.ndm_updated\t = now - n->updated;\n\tci.ndm_refcnt\t = atomic_read(&n->refcnt) - 1;\n\tprobes = atomic_read(&n->probes);\n\tread_unlock_bh(&n->lock);\n\tlocked\t\t = 0;\n\tRTA_PUT(skb, NDA_CACHEINFO, sizeof(ci), &ci);\n\tRTA_PUT(skb, NDA_PROBES, sizeof(probes), &probes);\n\tnlh->nlmsg_len\t = skb->tail - b;\n\treturn skb->len;\nnlmsg_failure:\nrtattr_failure:\n\tif (locked)\n\t\tread_unlock_bh(&n->lock);\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}", "target": 1}
{"code": "static u32 udp6_portaddr_hash(const struct net *net,\n\t\t\t      const struct in6_addr *addr6,\n\t\t\t      unsigned int port)\n{\n\tunsigned int hash, mix = net_hash_mix(net);\n\tif (ipv6_addr_any(addr6))\n\t\thash = jhash_1word(0, mix);\n\telse if (ipv6_addr_v4mapped(addr6))\n\t\thash = jhash_1word((__force u32)addr6->s6_addr32[3], mix);\n\telse\n\t\thash = jhash2((__force u32 *)addr6->s6_addr32, 4, mix);\n\treturn hash ^ port;\n}", "target": 0}
{"code": "static inline int pmd_none_or_trans_huge_or_clear_bad(pmd_t *pmd)\n{\n\tpmd_t pmdval = pmd_read_atomic(pmd);\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tbarrier();\n#endif\n\tif (pmd_none(pmdval))\n\t\treturn 1;\n\tif (unlikely(pmd_bad(pmdval))) {\n\t\tif (!pmd_trans_huge(pmdval))\n\t\t\tpmd_clear_bad(pmd);\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static TValue *trace_exit_cp(lua_State *L, lua_CFunction dummy, void *ud)\n{\n  ExitDataCP *exd = (ExitDataCP *)ud;\n  cframe_errfunc(L->cframe) = -1;  \n  exd->pc = lj_snap_restore(exd->J, exd->exptr);\n  UNUSED(dummy);\n  return NULL;\n}", "target": 1}
{"code": "otError Commissioner::AddJoiner(const Mac::ExtAddress *aEui64, const char *aPskd, uint32_t aTimeout)\n{\n    otError error = OT_ERROR_NO_BUFS;\n    VerifyOrExit(mState == OT_COMMISSIONER_STATE_ACTIVE, error = OT_ERROR_INVALID_STATE);\n    VerifyOrExit(strlen(aPskd) <= Dtls::kPskMaxLength, error = OT_ERROR_INVALID_ARGS);\n    RemoveJoiner(aEui64, 0); \n    for (Joiner *joiner = &mJoiners[0]; joiner < OT_ARRAY_END(mJoiners); joiner++)\n    {\n        if (joiner->mValid)\n        {\n            continue;\n        }\n        if (aEui64 != NULL)\n        {\n            joiner->mEui64 = *aEui64;\n            joiner->mAny   = false;\n        }\n        else\n        {\n            joiner->mAny = true;\n        }\n        (void)strlcpy(joiner->mPsk, aPskd, sizeof(joiner->mPsk));\n        joiner->mValid          = true;\n        joiner->mExpirationTime = TimerMilli::GetNow() + Time::SecToMsec(aTimeout);\n        UpdateJoinerExpirationTimer();\n        SendCommissionerSet();\n        otLogInfoMeshCoP(\"Added Joiner (%s, %s)\", (aEui64 != NULL) ? aEui64->ToString().AsCString() : \"*\", aPskd);\n        ExitNow(error = OT_ERROR_NONE);\n    }\nexit:\n    return error;\n}", "target": 1}
{"code": "int simple_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error;\n\tif (type == ACL_TYPE_ACCESS) {\n\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\tif (error < 0)\n\t\t\treturn 0;\n\t\tif (error == 0)\n\t\t\tacl = NULL;\n\t}\n\tinode->i_ctime = current_time(inode);\n\tset_cached_acl(inode, type, acl);\n\treturn 0;\n}", "target": 1}
{"code": "  Status CalculateOutputIndex(OpKernelContext* context, int dimension,\n                              const vector<INDEX_TYPE>& parent_output_index,\n                              INDEX_TYPE output_index_multiplier,\n                              INDEX_TYPE output_size,\n                              vector<INDEX_TYPE>* result) {\n    const RowPartitionTensor row_partition_tensor =\n        GetRowPartitionTensor(context, dimension);\n    auto partition_type = GetRowPartitionTypeByDimension(dimension);\n    switch (partition_type) {\n      case RowPartitionType::VALUE_ROWIDS:\n        CalculateOutputIndexValueRowID(\n            context, row_partition_tensor, parent_output_index,\n            output_index_multiplier, output_size, result);\n        return tensorflow::Status::OK();\n      case RowPartitionType::ROW_SPLITS:\n        CalculateOutputIndexRowSplit(\n            context, row_partition_tensor, parent_output_index,\n            output_index_multiplier, output_size, result);\n        return tensorflow::Status::OK();\n      default:\n        return errors::InvalidArgument(\n            \"Unsupported partition type:\",\n            RowPartitionTypeToString(partition_type));\n    }\n  }", "target": 1}
{"code": "  base::Time IncrementMockTime() {\n    ++mock_time_counter_;\n    return base::Time::FromDoubleT(mock_time_counter_ * 10.0);\n  }", "target": 0}
{"code": "static void vhost_vsock_common_send_transport_reset(VHostVSockCommon *vvc)\n{\n    VirtQueueElement *elem;\n    VirtQueue *vq = vvc->event_vq;\n    struct virtio_vsock_event event = {\n        .id = cpu_to_le32(VIRTIO_VSOCK_EVENT_TRANSPORT_RESET),\n    };\n    elem = virtqueue_pop(vq, sizeof(VirtQueueElement));\n    if (!elem) {\n        error_report(\"vhost-vsock missed transport reset event\");\n        return;\n    }\n    if (elem->out_num) {\n        error_report(\"invalid vhost-vsock event virtqueue element with \"\n                     \"out buffers\");\n        goto out;\n    }\n    if (iov_from_buf(elem->in_sg, elem->in_num, 0,\n                     &event, sizeof(event)) != sizeof(event)) {\n        error_report(\"vhost-vsock event virtqueue element is too short\");\n        goto out;\n    }\n    virtqueue_push(vq, elem, sizeof(event));\n    virtio_notify(VIRTIO_DEVICE(vvc), vq);\nout:\n    g_free(elem);\n}", "target": 1}
{"code": "_gnutls_x509_decode_string(unsigned int etype,\n\t\t\t   const uint8_t * der, size_t der_size,\n\t\t\t   gnutls_datum_t * output, unsigned allow_ber)\n{\n\tint ret;\n\tuint8_t *str;\n\tunsigned int str_size, len;\n\tgnutls_datum_t td;\n#ifdef HAVE_ASN1_DECODE_SIMPLE_BER\n\tif (allow_ber)\n\t\tret =\n\t\t    asn1_decode_simple_ber(etype, der, der_size, &str, &str_size, NULL);\n\telse\n#endif\n\t\tret =\n\t\t    asn1_decode_simple_der(etype, der, der_size, (const uint8_t**)&str, &str_size);\n\tif (ret != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\tret = _gnutls_asn2err(ret);\n\t\treturn ret;\n\t}\n\ttd.size = str_size;\n\ttd.data = gnutls_malloc(str_size + 1);\n\tif (td.data == NULL)\n\t\treturn gnutls_assert_val(GNUTLS_E_MEMORY_ERROR);\n\tmemcpy(td.data, str, str_size);\n\ttd.data[str_size] = 0;\n#ifdef HAVE_ASN1_DECODE_SIMPLE_BER\n\tif (allow_ber)\n\t\tfree(str);\n#endif\n\tret = make_printable_string(etype, &td, output);\n\tif (ret == GNUTLS_E_INVALID_REQUEST) {\t\n\t\toutput->data = td.data;\n\t\toutput->size = td.size;\n\t\tret = 0;\n\t} else if (ret <= 0) {\n\t\t_gnutls_free_datum(&td);\n\t}\n\tif (etype != ASN1_ETYPE_OCTET_STRING) {\n\t\tif (output->data)\n\t\t\tlen = strlen((void *) output->data);\n\t\telse\n\t\t\tlen = 0;\n\t\tif (len != (size_t) output->size) {\n\t\t\t_gnutls_free_datum(output);\n\t\t\tret = gnutls_assert_val(GNUTLS_E_ASN1_DER_ERROR);\n\t\t}\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "static int lua_websocket_peek(lua_State *L) \n{\n    apr_status_t rv;\n    apr_bucket_brigade *brigade;\n    request_rec *r = ap_lua_check_request_rec(L, 1);\n    brigade = apr_brigade_create(r->connection->pool, \n            r->connection->bucket_alloc);\n    rv = ap_get_brigade(r->connection->input_filters, brigade, \n            AP_MODE_READBYTES, APR_NONBLOCK_READ, 1);\n    if (rv == APR_SUCCESS) {\n        lua_pushboolean(L, 1);\n    }\n    else {\n        lua_pushboolean(L, 0);\n    }\n    apr_brigade_cleanup(brigade);\n    return 1;\n}", "target": 0}
{"code": "check_secret_key( ELG_secret_key *sk )\n{\n    int rc;\n    MPI y = mpi_alloc( mpi_get_nlimbs(sk->y) );\n    mpi_powm( y, sk->g, sk->x, sk->p );\n    rc = !mpi_cmp( y, sk->y );\n    mpi_free( y );\n    return rc;\n}", "target": 0}
{"code": "static bool regsafe(struct bpf_reg_state *rold, struct bpf_reg_state *rcur,\n\t\t    struct idpair *idmap)\n{\n\tif (!(rold->live & REG_LIVE_READ))\n\t\treturn true;\n\tif (memcmp(rold, rcur, offsetof(struct bpf_reg_state, live)) == 0)\n\t\treturn true;\n\tif (rold->type == NOT_INIT)\n\t\treturn true;\n\tif (rcur->type == NOT_INIT)\n\t\treturn false;\n\tswitch (rold->type) {\n\tcase SCALAR_VALUE:\n\t\tif (rcur->type == SCALAR_VALUE) {\n\t\t\treturn range_within(rold, rcur) &&\n\t\t\t       tnum_in(rold->var_off, rcur->var_off);\n\t\t} else {\n\t\t\treturn rold->umin_value == 0 &&\n\t\t\t       rold->umax_value == U64_MAX &&\n\t\t\t       rold->smin_value == S64_MIN &&\n\t\t\t       rold->smax_value == S64_MAX &&\n\t\t\t       tnum_is_unknown(rold->var_off);\n\t\t}\n\tcase PTR_TO_MAP_VALUE:\n\t\treturn memcmp(rold, rcur, offsetof(struct bpf_reg_state, id)) == 0 &&\n\t\t       range_within(rold, rcur) &&\n\t\t       tnum_in(rold->var_off, rcur->var_off);\n\tcase PTR_TO_MAP_VALUE_OR_NULL:\n\t\tif (rcur->type != PTR_TO_MAP_VALUE_OR_NULL)\n\t\t\treturn false;\n\t\tif (memcmp(rold, rcur, offsetof(struct bpf_reg_state, id)))\n\t\t\treturn false;\n\t\treturn check_ids(rold->id, rcur->id, idmap);\n\tcase PTR_TO_PACKET_META:\n\tcase PTR_TO_PACKET:\n\t\tif (rcur->type != rold->type)\n\t\t\treturn false;\n\t\tif (rold->range > rcur->range)\n\t\t\treturn false;\n\t\tif (rold->off != rcur->off)\n\t\t\treturn false;\n\t\tif (rold->id && !check_ids(rold->id, rcur->id, idmap))\n\t\t\treturn false;\n\t\treturn range_within(rold, rcur) &&\n\t\t       tnum_in(rold->var_off, rcur->var_off);\n\tcase PTR_TO_CTX:\n\tcase CONST_PTR_TO_MAP:\n\tcase PTR_TO_STACK:\n\tcase PTR_TO_PACKET_END:\n\tdefault:\n\t\treturn false;\n\t}\n\tWARN_ON_ONCE(1);\n\treturn false;\n}", "target": 1}
{"code": "_dl_dst_substitute (struct link_map *l, const char *name, char *result,\n\t\t    int is_path)\n{\n  char *last_elem, *wp;\n  last_elem = wp = result;\n  do\n    {\n      if (*name == '$')\n\t{\n\t  const char *repl;\n\t  size_t len;\n\t  if ((((strncmp (&name[1], \"ORIGIN\", 6) == 0 && (len = 7) != 0)\n\t\t|| (strncmp (&name[1], \"PLATFORM\", 8) == 0 && (len = 9) != 0))\n\t       && (name[len] == '\\0' || name[len] == '/'\n\t\t   || (is_path && name[len] == ':')))\n\t      || (name[1] == '{'\n\t\t  && ((strncmp (&name[2], \"ORIGIN}\", 7) == 0 && (len = 9) != 0)\n\t\t      || (strncmp (&name[2], \"PLATFORM}\", 9) == 0\n\t\t\t  && (len = 11) != 0))))\n\t    {\n\t      repl = ((len == 7 || name[2] == 'O')\n\t\t      ? (__libc_enable_secure ? NULL : l->l_origin)\n\t\t      : _dl_platform);\n\t      if (repl != NULL && repl != (const char *) -1)\n\t\t{\n\t\t  wp = __stpcpy (wp, repl);\n\t\t  name += len;\n\t\t}\n\t      else\n\t\t{\n\t\t  wp = last_elem;\n\t\t  name += len;\n\t\t  while (*name != '\\0' && (!is_path || *name != ':'))\n\t\t    ++name;\n\t\t}\n\t    }\n\t  else\n\t    *wp++ = *name++;\n\t}\n      else if (is_path && *name == ':')\n\t{\n\t  *wp++ = *name++;\n\t  last_elem = wp;\n\t}\n      else\n\t*wp++ = *name++;\n    }\n  while (*name != '\\0');\n  *wp = '\\0';\n  return result;\n}", "target": 1}
{"code": "uint32_t read32(uint8_t* arr, int pos,  int swapBytes)\n{\n    if(!swapBytes) {\n        return (arr[pos]   << 24) |\n               (arr[pos+1] << 16) |\n               (arr[pos+2] << 8) |\n                arr[pos+3];\n    }\n    return arr[pos] |\n           (arr[pos+1] << 8) |\n           (arr[pos+2] << 16) |\n           (arr[pos+3] << 24);\n}", "target": 0}
{"code": "static int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n#if 0\n\tjp2_pclr_t *pclr = &box->data.pclr;\n#endif\nbox = 0;\nout = 0;\n\treturn -1;\n}", "target": 1}
{"code": "void start_cfs_bandwidth(struct cfs_bandwidth *cfs_b)\n{\n\tu64 overrun;\n\tlockdep_assert_held(&cfs_b->lock);\n\tif (cfs_b->period_active)\n\t\treturn;\n\tcfs_b->period_active = 1;\n\toverrun = hrtimer_forward_now(&cfs_b->period_timer, cfs_b->period);\n\tcfs_b->runtime_expires += (overrun + 1) * ktime_to_ns(cfs_b->period);\n\tcfs_b->expires_seq++;\n\thrtimer_start_expires(&cfs_b->period_timer, HRTIMER_MODE_ABS_PINNED);\n}", "target": 1}
{"code": "static int calc_compression_level(RedsState *reds)\n{\n    spice_assert(reds_get_streaming_video(reds) != SPICE_STREAM_VIDEO_INVALID);\n    if ((reds_get_streaming_video(reds) != SPICE_STREAM_VIDEO_OFF) ||\n        (spice_server_get_image_compression(reds) != SPICE_IMAGE_COMPRESSION_QUIC)) {\n        return 0;\n    } else {\n        return 1;\n    }\n}", "target": 0}
{"code": "static void fill_model_structures(SPICE_GNUC_UNUSED Encoder *encoder, FamilyStat *family_stat,\n                                  unsigned int rep_first, unsigned int first_size,\n                                  unsigned int rep_next, unsigned int mul_size,\n                                  unsigned int levels, unsigned int ncounters,\n                                  unsigned int nbuckets, unsigned int n_buckets_ptrs)\n{\n    unsigned int\n    bsize,\n    bstart,\n    bend = 0,\n    repcntr,\n    bnumber;\n    COUNTER * free_counter = family_stat->counters;\n    bnumber = 0;\n    repcntr = rep_first + 1;    \n    bsize = first_size;\n    do { \n        if (bnumber) {\n            bstart = bend + 1;\n        } else {\n            bstart = 0;\n        }\n        if (!--repcntr) {\n            repcntr = rep_next;\n            bsize *= mul_size;\n        }\n        bend = bstart + bsize - 1;\n        if (bend + bsize >= levels) {\n            bend = levels - 1;\n        }\n        family_stat->buckets_buf[bnumber].pcounters = free_counter;\n        free_counter += ncounters;\n        spice_assert(bstart < n_buckets_ptrs);\n        {\n            unsigned int i;\n            spice_assert(bend < n_buckets_ptrs);\n            for (i = bstart; i <= bend; i++) {\n                family_stat->buckets_ptrs[i] = family_stat->buckets_buf + bnumber;\n            }\n        }\n        bnumber++;\n    } while (bend < levels - 1);\n    spice_assert(free_counter - family_stat->counters == (ptrdiff_t)(nbuckets * ncounters));\n}", "target": 0}
{"code": "lsquic_qeh_settings (struct qpack_enc_hdl *qeh, unsigned max_table_size,\n             unsigned dyn_table_size, unsigned max_risked_streams, int server)\n{\n    enum lsqpack_enc_opts enc_opts;\n    assert(qeh->qeh_flags & QEH_INITIALIZED);\n    if (qeh->qeh_flags & QEH_HAVE_SETTINGS)\n    {\n        LSQ_WARN(\"settings already set\");\n        return -1;\n    }\n    enc_opts = LSQPACK_ENC_OPT_STAGE_2\n             | (server ? LSQPACK_ENC_OPT_SERVER : 0);\n    qeh->qeh_tsu_sz = sizeof(qeh->qeh_tsu_buf);\n    if (0 != lsqpack_enc_init(&qeh->qeh_encoder, (void *) qeh->qeh_conn,\n                max_table_size, dyn_table_size, max_risked_streams, enc_opts,\n                qeh->qeh_tsu_buf, &qeh->qeh_tsu_sz))\n    {\n        LSQ_INFO(\"could not initialize QPACK encoder\");\n        return -1;\n    }\n    LSQ_DEBUG(\"%zu-byte post-init TSU\", qeh->qeh_tsu_sz);\n    qeh->qeh_flags |= QEH_HAVE_SETTINGS;\n    qeh->qeh_max_prefix_size =\n                        lsqpack_enc_header_block_prefix_size(&qeh->qeh_encoder);\n    LSQ_DEBUG(\"have settings: max table size=%u; dyn table size=%u; max risked \"\n        \"streams=%u\", max_table_size, dyn_table_size, max_risked_streams);\n    if (qeh->qeh_enc_sm_out)\n        qeh_begin_out(qeh);\n    return 0;\n}", "target": 1}
{"code": "deltas_head_cleanup(struct deltas_head *list)\n{\n\tsize_t i;\n\tfor (i = 0; i < list->capacity; i++)\n\t\tdelta_head_destroy(list->array[i]);\n\tif (list->array)\n\t\tfree(list->array);\n}", "target": 1}
{"code": "struct mb2_cache *ext2_xattr_create_cache(void)\n{\n\treturn mb2_cache_create(HASH_BUCKET_BITS);\n}", "target": 0}
{"code": "static int switch_listening_mode(GDHCPClient *dhcp_client,\n\t\t\t\t\tListenMode listen_mode)\n{\n\tGIOChannel *listener_channel;\n\tint listener_sockfd;\n\tif (dhcp_client->listen_mode == listen_mode)\n\t\treturn 0;\n\tdebug(dhcp_client, \"switch listening mode (%d ==> %d)\",\n\t\t\t\tdhcp_client->listen_mode, listen_mode);\n\tif (dhcp_client->listen_mode != L_NONE) {\n\t\tif (dhcp_client->listener_watch > 0)\n\t\t\tg_source_remove(dhcp_client->listener_watch);\n\t\tdhcp_client->listen_mode = L_NONE;\n\t\tdhcp_client->listener_sockfd = -1;\n\t\tdhcp_client->listener_watch = 0;\n\t}\n\tif (listen_mode == L_NONE)\n\t\treturn 0;\n\tif (listen_mode == L2)\n\t\tlistener_sockfd = dhcp_l2_socket(dhcp_client->ifindex);\n\telse if (listen_mode == L3) {\n\t\tif (dhcp_client->type == G_DHCP_IPV6)\n\t\t\tlistener_sockfd = dhcp_l3_socket(DHCPV6_CLIENT_PORT,\n\t\t\t\t\t\t\tdhcp_client->interface,\n\t\t\t\t\t\t\tAF_INET6);\n\t\telse\n\t\t\tlistener_sockfd = dhcp_l3_socket(CLIENT_PORT,\n\t\t\t\t\t\t\tdhcp_client->interface,\n\t\t\t\t\t\t\tAF_INET);\n\t} else if (listen_mode == L_ARP)\n\t\tlistener_sockfd = arp_socket(dhcp_client->ifindex);\n\telse\n\t\treturn -EIO;\n\tif (listener_sockfd < 0)\n\t\treturn -EIO;\n\tlistener_channel = g_io_channel_unix_new(listener_sockfd);\n\tif (!listener_channel) {\n\t\tclose(listener_sockfd);\n\t\treturn -EIO;\n\t}\n\tdhcp_client->listen_mode = listen_mode;\n\tdhcp_client->listener_sockfd = listener_sockfd;\n\tg_io_channel_set_close_on_unref(listener_channel, TRUE);\n\tdhcp_client->listener_watch =\n\t\t\tg_io_add_watch_full(listener_channel, G_PRIORITY_HIGH,\n\t\t\t\tG_IO_IN | G_IO_NVAL | G_IO_ERR | G_IO_HUP,\n\t\t\t\t\t\tlistener_event, g_dhcp_client_ref(dhcp_client),\n\t\t\t\t\t\t\t\tlistener_watch_destroy);\n\tg_io_channel_unref(listener_channel);\n\treturn 0;\n}", "target": 0}
{"code": "SPL_METHOD(SplHeap, isEmpty)\n{\n\tspl_heap_object *intern = (spl_heap_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"\") == FAILURE) {\n\t\treturn;\n\t}\n\tRETURN_BOOL(spl_ptr_heap_count(intern->heap)==0);\n}", "target": 0}
{"code": "static int ion_handle_put_nolock(struct ion_handle *handle)\n{\n\tint ret;\n\tret = kref_put(&handle->ref, ion_handle_destroy);\n\treturn ret;\n}", "target": 0}
{"code": "static void timerfd_remove_cancel(struct timerfd_ctx *ctx)\n{\n\tif (ctx->might_cancel) {\n\t\tctx->might_cancel = false;\n\t\tspin_lock(&cancel_lock);\n\t\tlist_del_rcu(&ctx->clist);\n\t\tspin_unlock(&cancel_lock);\n\t}\n}", "target": 1}
{"code": "void recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h, *g;\n\tunsigned int i;\n\tvmcb_mark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\tc = &svm->vmcb->control;\n\th = &svm->vmcb01.ptr->control;\n\tg = &svm->nested.ctl;\n\tfor (i = 0; i < MAX_INTERCEPT; i++)\n\t\tc->intercepts[i] = h->intercepts[i];\n\tif (g->int_ctl & V_INTR_MASKING_MASK) {\n\t\tvmcb_clr_intercept(c, INTERCEPT_CR8_READ);\n\t\tvmcb_clr_intercept(c, INTERCEPT_CR8_WRITE);\n\t\tvmcb_clr_intercept(c, INTERCEPT_VINTR);\n\t}\n\tvmcb_clr_intercept(c, INTERCEPT_VMMCALL);\n\tfor (i = 0; i < MAX_INTERCEPT; i++)\n\t\tc->intercepts[i] |= g->intercepts[i];\n\tif (!intercept_smi)\n\t\tvmcb_clr_intercept(c, INTERCEPT_SMI);\n}", "target": 1}
{"code": "static void _d_rehash(struct dentry * entry)\n{\n\t__d_rehash(entry, d_hash(entry->d_parent, entry->d_name.hash));\n}", "target": 0}
{"code": "static inline int init_new_context(struct task_struct *tsk,\n\t\t\t\t   struct mm_struct *mm)\n{\n\tcpumask_clear(&mm->context.cpu_attach_mask);\n\tatomic_set(&mm->context.attach_count, 0);\n\tmm->context.flush_mm = 0;\n\tmm->context.asce_bits = _ASCE_TABLE_LENGTH | _ASCE_USER_BITS;\n\tmm->context.asce_bits |= _ASCE_TYPE_REGION3;\n#ifdef CONFIG_PGSTE\n\tmm->context.alloc_pgste = page_table_allocate_pgste;\n\tmm->context.has_pgste = 0;\n\tmm->context.use_skey = 0;\n#endif\n\tmm->context.asce_limit = STACK_TOP_MAX;\n\tcrst_table_init((unsigned long *) mm->pgd, pgd_entry_type(mm));\n\treturn 0;\n}", "target": 1}
{"code": "static int fsmMkdir(const char *path, mode_t mode)\n{\n    int rc = mkdir(path, (mode & 07777));\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, 0%04o) %s\\n\", __func__,\n\t       path, (unsigned)(mode & 07777),\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\trc = RPMERR_MKDIR_FAILED;\n    return rc;\n}", "target": 1}
{"code": "ExprResolveBoolean(struct xkb_context *ctx, const ExprDef *expr,\n                   bool *set_rtrn)\n{\n    bool ok = false;\n    const char *ident;\n    switch (expr->expr.op) {\n    case EXPR_VALUE:\n        if (expr->expr.value_type != EXPR_TYPE_BOOLEAN) {\n            log_err(ctx,\n                    \"Found constant of type %s where boolean was expected\\n\",\n                    expr_value_type_to_string(expr->expr.value_type));\n            return false;\n        }\n        *set_rtrn = expr->boolean.set;\n        return true;\n    case EXPR_IDENT:\n        ident = xkb_atom_text(ctx, expr->ident.ident);\n        if (ident) {\n            if (istreq(ident, \"true\") ||\n                istreq(ident, \"yes\") ||\n                istreq(ident, \"on\")) {\n                *set_rtrn = true;\n                return true;\n            }\n            else if (istreq(ident, \"false\") ||\n                     istreq(ident, \"no\") ||\n                     istreq(ident, \"off\")) {\n                *set_rtrn = false;\n                return true;\n            }\n        }\n        log_err(ctx, \"Identifier \\\"%s\\\" of type boolean is unknown\\n\", ident);\n        return false;\n    case EXPR_FIELD_REF:\n        log_err(ctx, \"Default \\\"%s.%s\\\" of type boolean is unknown\\n\",\n                xkb_atom_text(ctx, expr->field_ref.element),\n                xkb_atom_text(ctx, expr->field_ref.field));\n        return false;\n     case EXPR_INVERT:\n     case EXPR_NOT:\n        ok = ExprResolveBoolean(ctx, expr, set_rtrn);\n         if (ok)\n             *set_rtrn = !*set_rtrn;\n         return ok;\n    case EXPR_ADD:\n    case EXPR_SUBTRACT:\n    case EXPR_MULTIPLY:\n    case EXPR_DIVIDE:\n    case EXPR_ASSIGN:\n    case EXPR_NEGATE:\n    case EXPR_UNARY_PLUS:\n        log_err(ctx, \"%s of boolean values not permitted\\n\",\n                expr_op_type_to_string(expr->expr.op));\n        break;\n    default:\n        log_wsgo(ctx, \"Unknown operator %d in ResolveBoolean\\n\",\n                 expr->expr.op);\n        break;\n    }\n    return false;\n}", "target": 1}
{"code": "void blk_cleanup_queue(struct request_queue *q)\n{\n\tmutex_lock(&q->sysfs_lock);\n\tblk_set_queue_dying(q);\n\tblk_queue_flag_set(QUEUE_FLAG_NOMERGES, q);\n\tblk_queue_flag_set(QUEUE_FLAG_NOXMERGES, q);\n\tblk_queue_flag_set(QUEUE_FLAG_DYING, q);\n\tmutex_unlock(&q->sysfs_lock);\n\tblk_freeze_queue(q);\n\trq_qos_exit(q);\n\tblk_queue_flag_set(QUEUE_FLAG_DEAD, q);\n\tblk_flush_integrity();\n\tdel_timer_sync(&q->backing_dev_info->laptop_mode_wb_timer);\n\tblk_sync_queue(q);\n\tif (queue_is_mq(q))\n\t\tblk_mq_exit_queue(q);\n\tpercpu_ref_exit(&q->q_usage_counter);\n\tblk_put_queue(q);\n}", "target": 1}
{"code": "int SMIME_write_PKCS7(BIO *bio, PKCS7 *p7, BIO *data, int flags)\n{\n    STACK_OF(X509_ALGOR) *mdalgs;\n    int ctype_nid = OBJ_obj2nid(p7->type);\n    const PKCS7_CTX *ctx = ossl_pkcs7_get0_ctx(p7);\n    if (ctype_nid == NID_pkcs7_signed)\n        mdalgs = p7->d.sign->md_algs;\n    else\n        mdalgs = NULL;\n    flags ^= SMIME_OLDMIME;\n    return SMIME_write_ASN1_ex(bio, (ASN1_VALUE *)p7, data, flags, ctype_nid,\n                               NID_undef, mdalgs, ASN1_ITEM_rptr(PKCS7),\n                               ossl_pkcs7_ctx_get0_libctx(ctx),\n                               ossl_pkcs7_ctx_get0_propq(ctx));\n}", "target": 1}
{"code": "BOOL freerdp_bitmap_planar_context_reset(BITMAP_PLANAR_CONTEXT* context, UINT32 width,\n                                         UINT32 height)\n{\n\tif (!context)\n\t\treturn FALSE;\n\tcontext->bgr = FALSE;\n\tcontext->maxWidth = PLANAR_ALIGN(width, 4);\n\tcontext->maxHeight = PLANAR_ALIGN(height, 4);\n\tcontext->maxPlaneSize = context->maxWidth * context->maxHeight;\n\tcontext->nTempStep = context->maxWidth * 4;\n\tfree(context->planesBuffer);\n\tfree(context->pTempData);\n\tfree(context->deltaPlanesBuffer);\n\tfree(context->rlePlanesBuffer);\n\tcontext->planesBuffer = calloc(context->maxPlaneSize, 4);\n\tcontext->pTempData = calloc(context->maxPlaneSize, 6);\n\tcontext->deltaPlanesBuffer = calloc(context->maxPlaneSize, 4);\n\tcontext->rlePlanesBuffer = calloc(context->maxPlaneSize, 4);\n\tif (!context->planesBuffer || !context->pTempData || !context->deltaPlanesBuffer ||\n\t    !context->rlePlanesBuffer)\n\t\treturn FALSE;\n\tcontext->planes[0] = &context->planesBuffer[context->maxPlaneSize * 0];\n\tcontext->planes[1] = &context->planesBuffer[context->maxPlaneSize * 1];\n\tcontext->planes[2] = &context->planesBuffer[context->maxPlaneSize * 2];\n\tcontext->planes[3] = &context->planesBuffer[context->maxPlaneSize * 3];\n\tcontext->deltaPlanes[0] = &context->deltaPlanesBuffer[context->maxPlaneSize * 0];\n\tcontext->deltaPlanes[1] = &context->deltaPlanesBuffer[context->maxPlaneSize * 1];\n\tcontext->deltaPlanes[2] = &context->deltaPlanesBuffer[context->maxPlaneSize * 2];\n\tcontext->deltaPlanes[3] = &context->deltaPlanesBuffer[context->maxPlaneSize * 3];\n\treturn TRUE;\n}", "target": 1}
{"code": "static int lsm_set_label_at(int lsm_labelfd, int on_exec, char *lsm_label)\n{\n\tint fret = -1;\n\tconst char* name;\n\tchar *command = NULL;\n\tname = lsm_name();\n\tif (strcmp(name, \"nop\") == 0)\n\t\treturn 0;\n\tif (strcmp(name, \"none\") == 0)\n\t\treturn 0;\n\tif (strcmp(name, \"AppArmor\") == 0)\n\t\ton_exec = 0;\n\tif (strcmp(name, \"AppArmor\") == 0) {\n\t\tint size;\n\t\tcommand = malloc(strlen(lsm_label) + strlen(\"changeprofile \") + 1);\n\t\tif (!command) {\n\t\t\tSYSERROR(\"Failed to write apparmor profile\");\n\t\t\tgoto out;\n\t\t}\n\t\tsize = sprintf(command, \"changeprofile %s\", lsm_label);\n\t\tif (size < 0) {\n\t\t\tSYSERROR(\"Failed to write apparmor profile\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (write(lsm_labelfd, command, size + 1) < 0) {\n\t\t\tSYSERROR(\"Unable to set LSM label: %s.\", command);\n\t\t\tgoto out;\n\t\t}\n\t\tINFO(\"Set LSM label to: %s.\", command);\n\t} else if (strcmp(name, \"SELinux\") == 0) {\n\t\tif (write(lsm_labelfd, lsm_label, strlen(lsm_label) + 1) < 0) {\n\t\t\tSYSERROR(\"Unable to set LSM label\");\n\t\t\tgoto out;\n\t\t}\n\t\tINFO(\"Set LSM label to: %s.\", lsm_label);\n\t} else {\n\t\tERROR(\"Unable to restore label for unknown LSM: %s\", name);\n\t\tgoto out;\n\t}\n\tfret = 0;\nout:\n\tfree(command);\n\tif (lsm_labelfd != -1)\n\t\tclose(lsm_labelfd);\n\treturn fret;\n}", "target": 0}
{"code": "void rose_start_t2timer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\tdel_timer(&rose->timer);\n\trose->timer.function = rose_timer_expiry;\n\trose->timer.expires  = jiffies + rose->t2;\n\tadd_timer(&rose->timer);\n}", "target": 1}
{"code": "static int md_domain_init(struct dmar_domain *domain, int guest_width)\n{\n\tint adjust_width;\n\tinit_iova_domain(&domain->iovad, VTD_PAGE_SIZE, IOVA_START_PFN);\n\tdomain_reserve_special_ranges(domain);\n\tdomain->gaw = guest_width;\n\tadjust_width = guestwidth_to_adjustwidth(guest_width);\n\tdomain->agaw = width_to_agaw(adjust_width);\n\tdomain->iommu_coherency = 0;\n\tdomain->iommu_snooping = 0;\n\tdomain->iommu_superpage = 0;\n\tdomain->max_addr = 0;\n\tdomain->pgd = (struct dma_pte *)alloc_pgtable_page(domain->nid);\n\tif (!domain->pgd)\n\t\treturn -ENOMEM;\n\tdomain_flush_cache(domain, domain->pgd, PAGE_SIZE);\n\treturn 0;\n}", "target": 0}
{"code": "static unsigned long get_unmapped_area_zero(struct file *file,\n\t\t\t\tunsigned long addr, unsigned long len,\n\t\t\t\tunsigned long pgoff, unsigned long flags)\n{\n#ifdef CONFIG_MMU\n\tif (flags & MAP_SHARED) {\n\t\treturn shmem_get_unmapped_area(NULL, addr, len, pgoff, flags);\n\t}\n\treturn current->mm->get_unmapped_area(file, addr, len, pgoff, flags);\n#else\n\treturn -ENOSYS;\n#endif\n}", "target": 0}
{"code": "static bool manager_get_show_status(Manager *m, StatusType type) {\n        assert(m);\n        if (m->running_as != SYSTEMD_SYSTEM)\n                return false;\n        if (m->no_console_output)\n                return false;\n        if (!IN_SET(manager_state(m), MANAGER_INITIALIZING, MANAGER_STARTING, MANAGER_STOPPING))\n                return false;\n        if (type != STATUS_TYPE_EMERGENCY && manager_check_ask_password(m) > 0)\n                return false;\n        if (m->show_status > 0)\n                return true;\n        return plymouth_running();\n}", "target": 0}
{"code": "   Send an email message */\nPHP_FUNCTION(imap_mail)\n{\n\tchar *to=NULL, *message=NULL, *headers=NULL, *subject=NULL, *cc=NULL, *bcc=NULL, *rpath=NULL;\n\tint to_len, message_len, headers_len, subject_len, cc_len, bcc_len, rpath_len, argc = ZEND_NUM_ARGS();\n\tif (zend_parse_parameters(argc TSRMLS_CC, \"sss|ssss\", &to, &to_len, &subject, &subject_len, &message, &message_len,\n\t\t&headers, &headers_len, &cc, &cc_len, &bcc, &bcc_len, &rpath, &rpath_len) == FAILURE) {\n\t\treturn;\n\t}\n\tif (!to_len) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"No to field in mail command\");\n\t\tRETURN_FALSE;\n\t}\n\tif (!subject_len) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"No subject field in mail command\");\n\t\tRETURN_FALSE;\n\t}\n\tif (!message_len) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"No message string in mail command\");\n\t\tmessage = NULL;\n\t}\n\tif (_php_imap_mail(to, subject, message, headers, cc, bcc, rpath TSRMLS_CC)) {\n\t\tRETURN_TRUE;\n\t} else {\n\t\tRETURN_FALSE;\n\t}", "target": 1}
{"code": "static int do_tkill(pid_t tgid, pid_t pid, int sig)\n{\n\tstruct siginfo info;\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code = SI_TKILL;\n\tinfo.si_pid = task_tgid_vnr(current);\n\tinfo.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\treturn do_send_specific(tgid, pid, sig, &info);\n}", "target": 1}
{"code": "ECPKPARAMETERS *ec_asn1_group2pkparameters(const EC_GROUP *group,\n                                           ECPKPARAMETERS *params)\n{\n    int ok = 1, tmp;\n    ECPKPARAMETERS *ret = params;\n    if (ret == NULL) {\n        if ((ret = ECPKPARAMETERS_new()) == NULL) {\n            ECerr(EC_F_EC_ASN1_GROUP2PKPARAMETERS, ERR_R_MALLOC_FAILURE);\n            return NULL;\n        }\n    } else {\n        if (ret->type == 0 && ret->value.named_curve)\n            ASN1_OBJECT_free(ret->value.named_curve);\n        else if (ret->type == 1 && ret->value.parameters)\n            ECPARAMETERS_free(ret->value.parameters);\n    }\n    if (EC_GROUP_get_asn1_flag(group)) {\n        tmp = EC_GROUP_get_curve_name(group);\n        if (tmp) {\n            ret->type = 0;\n            if ((ret->value.named_curve = OBJ_nid2obj(tmp)) == NULL)\n                ok = 0;\n        } else\n            ok = 0;\n    } else {\n        ret->type = 1;\n        if ((ret->value.parameters =\n             ec_asn1_group2parameters(group, NULL)) == NULL)\n            ok = 0;\n    }\n    if (!ok) {\n        ECPKPARAMETERS_free(ret);\n        return NULL;\n    }\n    return ret;\n}", "target": 0}
{"code": "void put_filp(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tsecurity_file_free(file);\n\t\tfile_sb_list_del(file);\n\t\tfile_free(file);\n\t}\n}", "target": 1}
{"code": "int tm_adopt(\n  char  *id,\n  int    adoptCmd,\n  pid_t  pid)\n  {\n  int rc = TM_SUCCESS;\n  int status, ret;\n  pid_t sid;\n  char *env;\n  struct tcp_chan *chan = NULL;\n  sid = getsid(pid);\n  if (init_done) return TM_BADINIT;\n  init_done = 1;\n  if ((tm_jobid = getenv(\"PBS_JOBID\")) == NULL)\n    tm_jobid = (char *)\"ADOPT JOB\";\n  tm_jobid_len = strlen(tm_jobid);\n  if ((tm_jobcookie = getenv(\"PBS_JOBCOOKIE\")) == NULL)\n    tm_jobcookie = (char *)\"ADOPT COOKIE\";\n  tm_jobcookie_len = strlen(tm_jobcookie);\n  tm_jobndid = 0;\n  tm_jobtid = 0;\n  if ((env = getenv(\"PBS_MOMPORT\")) == NULL || (tm_momport = atoi(env)) == 0)\n    tm_momport = PBS_MANAGER_SERVICE_PORT;\n  if (adoptCmd != TM_ADOPT_ALTID && adoptCmd != TM_ADOPT_JOBID)\n    return TM_EUNKNOWNCMD;\n  if (startcom(adoptCmd, TM_NULL_EVENT, &chan) != DIS_SUCCESS)\n    return TM_ESYSTEM;\n  if (diswsi(chan, sid) != DIS_SUCCESS)\n    {\n    rc = TM_ENOTCONNECTED;\n    goto tm_adopt_cleanup;\n    }\n  if (diswsi(chan, pid) != DIS_SUCCESS)\n    {\n    rc =  TM_ENOTCONNECTED;\n    goto tm_adopt_cleanup;\n    }\n  if (diswcs(chan, id, strlen(id)) != DIS_SUCCESS)\n    {\n    rc =  TM_ENOTCONNECTED;\n    goto tm_adopt_cleanup;\n    }\n  DIS_tcp_wflush(chan);\n  status = disrsi(chan, &ret);\n  if (ret != DIS_SUCCESS)\n    {\n    rc = TM_ENOTCONNECTED;\n    goto tm_adopt_cleanup;\n    }\n  tm_finalize();\n  if (local_conn > -1)\n    {\n    close(local_conn);\n    local_conn = -1;\n    }\n  DIS_tcp_cleanup(chan);\n  return (status == TM_OKAY ?\n          TM_SUCCESS :\n          TM_ENOTFOUND);\ntm_adopt_cleanup:\n  if (chan != NULL)\n    DIS_tcp_cleanup(chan);\n  return rc;\n  }", "target": 1}
{"code": "void gf_bs_skip_bytes(GF_BitStream *bs, u64 nbBytes)\n{\n\tif (!bs || !nbBytes) return;\n\tgf_bs_align(bs);\n\tif ((bs->bsmode == GF_BITSTREAM_FILE_WRITE) || (bs->bsmode == GF_BITSTREAM_FILE_READ)) {\n\t\tif (bs->cache_write)\n\t\t\tbs_flush_write_cache(bs);\n\t\tif (bs->cache_read) {\n\t\t\tu32 csize = bs->cache_read_size - bs->cache_read_pos;\n\t\t\tif (csize>=nbBytes) {\n\t\t\t\tbs->cache_read_pos += (u32) nbBytes;\n\t\t\t\tbs->position += nbBytes;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tnbBytes -= csize;\n\t\t\tbs->position += csize;\n\t\t\tbs->cache_read_pos = bs->cache_read_size;\n\t\t}\n\t\tbs->position += nbBytes;\n\t\tif (bs->bsmode == GF_BITSTREAM_FILE_READ) {\n\t\t\tif (bs->position > bs->size) bs->position = bs->size;\n\t\t}\n\t\tgf_fseek(bs->stream, bs->position, SEEK_SET);\n\t\treturn;\n\t}\n\tif (bs->bsmode == GF_BITSTREAM_READ) {\n\t\tif (bs->remove_emul_prevention_byte) {\n\t\t\twhile (nbBytes) {\n\t\t\t\tgf_bs_read_u8(bs);\n\t\t\t\tnbBytes--;\n\t\t\t}\n\t\t} else {\n\t\t\tbs->position += nbBytes;\n\t\t\tif (bs->position>bs->size) {\n\t\t\t\tbs->position = bs->size;\n\t\t\t\tbs->overflow_state = 1;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\twhile (nbBytes) {\n\t\tgf_bs_write_int(bs, 0, 8);\n\t\tnbBytes--;\n\t}\n}", "target": 0}
{"code": "int get_compat_itimerspec(struct itimerspec *dst,\n\t\t\t  const struct compat_itimerspec __user *src)\n{\n\tif (__compat_get_timespec(&dst->it_interval, &src->it_interval) ||\n\t    __compat_get_timespec(&dst->it_value, &src->it_value))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 0}
{"code": "struct key *key_get_instantiation_authkey(key_serial_t target_id)\n{\n\tchar description[16];\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= &key_type_request_key_auth,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= user_match,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t};\n\tstruct key *authkey;\n\tkey_ref_t authkey_ref;\n\tsprintf(description, \"%x\", target_id);\n\tauthkey_ref = search_process_keyrings(&ctx);\n\tif (IS_ERR(authkey_ref)) {\n\t\tauthkey = ERR_CAST(authkey_ref);\n\t\tif (authkey == ERR_PTR(-EAGAIN))\n\t\t\tauthkey = ERR_PTR(-ENOKEY);\n\t\tgoto error;\n\t}\n\tauthkey = key_ref_to_ptr(authkey_ref);\n\tif (test_bit(KEY_FLAG_REVOKED, &authkey->flags)) {\n\t\tkey_put(authkey);\n\t\tauthkey = ERR_PTR(-EKEYREVOKED);\n\t}\nerror:\n\treturn authkey;\n}", "target": 1}
{"code": "get_stdinput(char *(*fn_readline)(const char *), void(*fn_addhist)(const char *))\n{\nint i;\ngstring * g = NULL;\nif (!fn_readline) { printf(\"> \"); fflush(stdout); }\nfor (i = 0;; i++)\n  {\n  uschar buffer[1024];\n  uschar *p, *ss;\n  #ifdef USE_READLINE\n  char *readline_line = NULL;\n  if (fn_readline != NULL)\n    {\n    if ((readline_line = fn_readline((i > 0)? \"\":\"> \")) == NULL) break;\n    if (*readline_line != 0 && fn_addhist != NULL) fn_addhist(readline_line);\n    p = US readline_line;\n    }\n  else\n  #endif\n    {\n    if (Ufgets(buffer, sizeof(buffer), stdin) == NULL) break;\n    p = buffer;\n    }\n  ss = p + (int)Ustrlen(p);\n  while (ss > p && isspace(ss[-1])) ss--;\n  if (i > 0)\n    {\n    while (p < ss && isspace(*p)) p++;   \n    }\n  g = string_catn(g, p, ss - p);\n  #ifdef USE_READLINE\n  if (fn_readline) free(readline_line);\n  #endif\n  if (ss == p || g->s[g->ptr-1] != '\\\\')\n    break;\n  --g->ptr;\n  (void) string_from_gstring(g);\n  }\nif (!g) printf(\"\\n\");\nreturn string_from_gstring(g);\n}", "target": 0}
{"code": "void _WM_do_meta_instrumentname(struct _mdi *mdi, struct _event_data *data) {\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_SDEBUG(__FUNCTION__, ch, data->data.string);\n#else\n    UNUSED(data);\n#endif\n    UNUSED(mdi);\n    return;\n}", "target": 0}
{"code": "  const uint8_t *getBytecode(uint32_t) const override {\n    llvm_unreachable(\"Accessing bytecode from a lazy module\");\n  }", "target": 1}
{"code": "static Jsi_RC SysVerConvertCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_Value *flag = Jsi_ValueArrayIndex(interp, args, 1);\n    if (!val) goto bail;\n    if (Jsi_ValueIsNumber(interp, val)) {\n        char buf[200];\n        Jsi_Number n;\n        if (Jsi_GetNumberFromValue(interp, val, &n) != JSI_OK)\n            goto bail;\n        jsi_VersionNormalize(n, buf, sizeof(buf));\n        int trunc = 0;\n        if (flag && (Jsi_GetIntFromValue(interp, flag, &trunc) != JSI_OK\n            || trunc<0 || trunc>2))\n            return Jsi_LogError(\"arg2: bad trunc: expected int between 0 and 2\");\n        if (trunc) {\n            int len = Jsi_Strlen(buf)-1;\n            while (trunc>0 && len>1) {\n                if (buf[len] == '0' && buf[len-1] == '.')\n                    buf[len-1] = 0;\n                len -= 2;\n                trunc--;\n            }\n        }\n        Jsi_ValueMakeStringDup(interp, ret, buf);\n        return JSI_OK;\n    }\n    if (Jsi_ValueIsString(interp, val)) {\n        Jsi_Number n;\n        if (jsi_GetVerFromVal(interp, val, &n, 0) == JSI_OK) {\n            Jsi_ValueMakeNumber(interp, ret, n);\n            return JSI_OK;\n        }\n    }\nbail:\n    Jsi_ValueMakeNull(interp, ret);\n    return JSI_OK;\n}", "target": 1}
{"code": "int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n{\n#ifndef WITH_BROKER\n\tchar sockpair_data = 0;\n#endif\n\tassert(mosq);\n\tassert(packet);\n\tpacket->pos = 0;\n\tpacket->to_process = packet->packet_length;\n\tpacket->next = NULL;\n\tpthread_mutex_lock(&mosq->out_packet_mutex);\n#ifdef WITH_BROKER\n\tif(mosq->out_packet_count >= db.config->max_queued_messages){\n\t\tmosquitto__free(packet);\n\t\tif(mosq->is_dropping == false){\n\t\t\tmosq->is_dropping = true;\n\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n\t\t\t\t\t\"Outgoing messages are being dropped for client %s.\",\n\t\t\t\t\tmosq->id);\n\t\t}\n\t\tG_MSGS_DROPPED_INC();\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}\n#endif\n\tif(mosq->out_packet){\n\t\tmosq->out_packet_last->next = packet;\n\t}else{\n\t\tmosq->out_packet = packet;\n\t}\n\tmosq->out_packet_last = packet;\n\tmosq->out_packet_count++;\n\tpthread_mutex_unlock(&mosq->out_packet_mutex);\n#ifdef WITH_BROKER\n#  ifdef WITH_WEBSOCKETS\n\tif(mosq->wsi){\n\t\tlws_callback_on_writable(mosq->wsi);\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}else{\n\t\treturn packet__write(mosq);\n\t}\n#  else\n\treturn packet__write(mosq);\n#  endif\n#else\n\tif(mosq->sockpairW != INVALID_SOCKET){\n#ifndef WIN32\n\t\tif(write(mosq->sockpairW, &sockpair_data, 1)){\n\t\t}\n#else\n\t\tsend(mosq->sockpairW, &sockpair_data, 1, 0);\n#endif\n\t}\n\tif(mosq->in_callback == false && mosq->threaded == mosq_ts_none){\n\t\treturn packet__write(mosq);\n\t}else{\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}\n#endif\n}", "target": 0}
{"code": "static int __vhost_add_used_n(struct vhost_virtqueue *vq,\n\t\t\t    struct vring_used_elem *heads,\n\t\t\t    unsigned count)\n{\n\tstruct vring_used_elem __user *used;\n\tu16 old, new;\n\tint start;\n\tstart = vq->last_used_idx % vq->num;\n\tused = vq->used->ring + start;\n\tif (__copy_to_user(used, heads, count * sizeof *used)) {\n\t\tvq_err(vq, \"Failed to write used\");\n\t\treturn -EFAULT;\n\t}\n\tif (unlikely(vq->log_used)) {\n\t\tsmp_wmb();\n\t\tlog_write(vq->log_base,\n\t\t\t  vq->log_addr +\n\t\t\t   ((void __user *)used - (void __user *)vq->used),\n\t\t\t  count * sizeof *used);\n\t}\n\told = vq->last_used_idx;\n\tnew = (vq->last_used_idx += count);\n\tif (unlikely((u16)(new - vq->signalled_used) < (u16)(new - old)))\n\t\tvq->signalled_used_valid = false;\n\treturn 0;\n}", "target": 0}
{"code": "    const std::unordered_map<std::string, std::string> &cookies() const override\n    {\n        return cookies_;\n    }", "target": 1}
{"code": "static int fetch_setup_walk(git_revwalk **out, git_repository *repo)\n{\n\tgit_revwalk *walk = NULL;\n\tgit_strarray refs;\n\tunsigned int i;\n\tgit_reference *ref;\n\tint error;\n\tif ((error = git_reference_list(&refs, repo)) < 0)\n\t\treturn error;\n\tif ((error = git_revwalk_new(&walk, repo)) < 0)\n\t\treturn error;\n\tgit_revwalk_sorting(walk, GIT_SORT_TIME);\n\tfor (i = 0; i < refs.count; ++i) {\n\t\tif (!git__prefixcmp(refs.strings[i], GIT_REFS_TAGS_DIR))\n\t\t\tcontinue;\n\t\tif ((error = git_reference_lookup(&ref, repo, refs.strings[i])) < 0)\n\t\t\tgoto on_error;\n\t\tif (git_reference_type(ref) == GIT_REF_SYMBOLIC)\n\t\t\tcontinue;\n\t\tif ((error = git_revwalk_push(walk, git_reference_target(ref))) < 0)\n\t\t\tgoto on_error;\n\t\tgit_reference_free(ref);\n\t}\n\tgit_strarray_free(&refs);\n\t*out = walk;\n\treturn 0;\non_error:\n\tgit_revwalk_free(walk);\n\tgit_reference_free(ref);\n\tgit_strarray_free(&refs);\n\treturn error;\n}", "target": 0}
{"code": "htp_param_t *htp_tx_req_get_param_ex(htp_tx_t *tx, enum htp_data_source_t source, const char *name, size_t name_len) {\n    if ((tx == NULL) || (name == NULL)) return NULL;\n    htp_param_t *p = NULL;\n    for (size_t i = 0, n = htp_table_size(tx->request_params); i < n; i++) {\n        p = htp_table_get_index(tx->request_params, i, NULL);\n        if (p->source != source) continue;\n        if (bstr_cmp_mem_nocase(p->name, name, name_len) == 0) return p;\n    }\n    return NULL;\n}", "target": 0}
{"code": "int expand_upwards(struct vm_area_struct *vma, unsigned long address)\n{\n\tint error;\n\tif (!(vma->vm_flags & VM_GROWSUP))\n\t\treturn -EFAULT;\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\treturn -ENOMEM;\n\tanon_vma_lock(vma);\n\tif (address < PAGE_ALIGN(address+4))\n\t\taddress = PAGE_ALIGN(address+4);\n\telse {\n\t\tanon_vma_unlock(vma);\n\t\treturn -ENOMEM;\n\t}\n\terror = 0;\n\tif (address > vma->vm_end) {\n\t\tunsigned long size, grow;\n\t\tsize = address - vma->vm_start;\n\t\tgrow = (address - vma->vm_end) >> PAGE_SHIFT;\n\t\terror = acct_stack_growth(vma, size, grow);\n\t\tif (!error)\n\t\t\tvma->vm_end = address;\n\t}\n\tanon_vma_unlock(vma);\n\treturn error;\n}", "target": 0}
{"code": "  void SetInput(std::initializer_list<float> data) {\n    QuantizeAndPopulate<uint8_t>(input_, data);\n  }", "target": 0}
{"code": "  virtual std::string GetHtmlInfo(int refresh) {\n    std::string output;\n    output.append(\"<html><head><title>About Network</title>\");\n    if (refresh > 0)\n      output.append(\"<meta http-equiv=\\\"refresh\\\" content=\\\"\" +\n          base::IntToString(refresh) + \"\\\"/>\");\n    output.append(\"</head><body>\");\n    if (refresh > 0) {\n      output.append(\"(Auto-refreshing page every \" +\n                    base::IntToString(refresh) + \"s)\");\n    } else {\n      output.append(\"(To auto-refresh this page: about:network/&lt;secs&gt;)\");\n    }\n    output.append(\"<h3>Ethernet:</h3><table border=1>\");\n    if (ethernet_ && ethernet_enabled()) {\n      output.append(\"<tr>\" + ToHtmlTableHeader(ethernet_) + \"</tr>\");\n      output.append(\"<tr>\" + ToHtmlTableRow(ethernet_) + \"</tr>\");\n    }\n    output.append(\"</table><h3>Wifi:</h3><table border=1>\");\n    for (size_t i = 0; i < wifi_networks_.size(); ++i) {\n      if (i == 0)\n        output.append(\"<tr>\" + ToHtmlTableHeader(wifi_networks_[i]) + \"</tr>\");\n      output.append(\"<tr>\" + ToHtmlTableRow(wifi_networks_[i]) + \"</tr>\");\n    }\n    output.append(\"</table><h3>Cellular:</h3><table border=1>\");\n    for (size_t i = 0; i < cellular_networks_.size(); ++i) {\n      if (i == 0)\n        output.append(\"<tr>\" + ToHtmlTableHeader(cellular_networks_[i]) +\n            \"</tr>\");\n      output.append(\"<tr>\" + ToHtmlTableRow(cellular_networks_[i]) + \"</tr>\");\n    }\n    output.append(\"</table><h3>Remembered Wifi:</h3><table border=1>\");\n    for (size_t i = 0; i < remembered_wifi_networks_.size(); ++i) {\n      if (i == 0)\n        output.append(\n            \"<tr>\" + ToHtmlTableHeader(remembered_wifi_networks_[i]) +\n            \"</tr>\");\n      output.append(\"<tr>\" + ToHtmlTableRow(remembered_wifi_networks_[i]) +\n          \"</tr>\");\n    }\n    output.append(\"</table></body></html>\");\n    return output;\n  }", "target": 0}
{"code": "static int snd_compress_check_input(struct snd_compr_params *params)\n{\n\tif (params->buffer.fragment_size == 0 ||\n\t\t\tparams->buffer.fragments > SIZE_MAX / params->buffer.fragment_size)\n\t\treturn -EINVAL;\n\tif (params->codec.id == 0 || params->codec.id > SND_AUDIOCODEC_MAX)\n\t\treturn -EINVAL;\n\tif (params->codec.ch_in == 0 || params->codec.ch_out == 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 1}
{"code": "void HeaderMapImpl::addViaMove(HeaderString&& key, HeaderString&& value) {\n  auto* entry = getExistingInline(key.getStringView());\n  if (entry != nullptr) {\n    appendToHeader(entry->value(), value.getStringView());\n    key.clear();\n    value.clear();\n  } else {\n    insertByKey(std::move(key), std::move(value));\n  }\n}", "target": 1}
{"code": "static int nested_vmx_store_msr(struct kvm_vcpu *vcpu, u64 gpa, u32 count)\n{\n\tu32 i;\n\tstruct vmx_msr_entry e;\n\tfor (i = 0; i < count; i++) {\n\t\tstruct msr_data msr_info;\n\t\tif (kvm_vcpu_read_guest(vcpu,\n\t\t\t\t\tgpa + i * sizeof(e),\n\t\t\t\t\t&e, 2 * sizeof(u32))) {\n\t\t\tpr_warn_ratelimited(\n\t\t\t\t\"%s cannot read MSR entry (%u, 0x%08llx)\\n\",\n\t\t\t\t__func__, i, gpa + i * sizeof(e));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (nested_vmx_store_msr_check(vcpu, &e)) {\n\t\t\tpr_warn_ratelimited(\n\t\t\t\t\"%s check failed (%u, 0x%x, 0x%x)\\n\",\n\t\t\t\t__func__, i, e.index, e.reserved);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmsr_info.host_initiated = false;\n\t\tmsr_info.index = e.index;\n\t\tif (kvm_get_msr(vcpu, &msr_info)) {\n\t\t\tpr_warn_ratelimited(\n\t\t\t\t\"%s cannot read MSR (%u, 0x%x)\\n\",\n\t\t\t\t__func__, i, e.index);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (kvm_vcpu_write_guest(vcpu,\n\t\t\t\t\t gpa + i * sizeof(e) +\n\t\t\t\t\t     offsetof(struct vmx_msr_entry, value),\n\t\t\t\t\t &msr_info.data, sizeof(msr_info.data))) {\n\t\t\tpr_warn_ratelimited(\n\t\t\t\t\"%s cannot write MSR (%u, 0x%x, 0x%llx)\\n\",\n\t\t\t\t__func__, i, e.index, msr_info.data);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "int nfs_initiate_commit(struct rpc_clnt *clnt, struct nfs_commit_data *data,\n\t\t\tconst struct rpc_call_ops *call_ops,\n\t\t\tint how, int flags)\n{\n\tstruct rpc_task *task;\n\tint priority = flush_task_priority(how);\n\tstruct rpc_message msg = {\n\t\t.rpc_argp = &data->args,\n\t\t.rpc_resp = &data->res,\n\t\t.rpc_cred = data->cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.task = &data->task,\n\t\t.rpc_client = clnt,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = call_ops,\n\t\t.callback_data = data,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC | flags,\n\t\t.priority = priority,\n\t};\n\tNFS_PROTO(data->inode)->commit_setup(data, &msg);\n\tdprintk(\"NFS: %5u initiated commit call\\n\", data->task.tk_pid);\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tif (how & FLUSH_SYNC)\n\t\trpc_wait_for_completion_task(task);\n\trpc_put_task(task);\n\treturn 0;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& filter = context->input(1);\n    const TensorShape& filter_shape = filter.shape();\n    const Tensor& out_backprop = context->input(2);\n    const TensorShape& out_backprop_shape = out_backprop.shape();\n    TensorShape input_shape;\n    if (takes_shape_) {\n      const Tensor& input_sizes = context->input(0);\n      OP_REQUIRES_OK(context, tensor::MakeShape(input_sizes, &input_shape));\n    } else {\n      input_shape = context->input(0).shape();\n    }\n    OP_REQUIRES(\n        context, input_shape.dim_size(4) == filter_shape.dim_size(3),\n        errors::InvalidArgument(\"input and filter_sizes must have the same \"\n                                \"number of channels. Got \",\n                                input_shape.dim_size(4), \" for input and \",\n                                filter_shape.dim_size(3), \" for filter_sizes\"));\n    OP_REQUIRES(\n        context, out_backprop_shape.dim_size(4) == filter_shape.dim_size(4),\n        errors::InvalidArgument(\"out_backprop and filter_sizes must have the \"\n                                \"same number of channels. Got \",\n                                out_backprop_shape.dim_size(4),\n                                \" for out_backprop and \",\n                                filter_shape.dim_size(4), \" for filter_sizes\"));\n    ConvBackpropDimensions dims;\n    OP_REQUIRES_OK(context, ConvBackpropComputeDimensions(\n                                \"Conv3DBackpropInputOp\", 3,\n                                input_shape, filter_shape, out_backprop_shape,\n                                stride_, padding_, data_format_, &dims));\n    Tensor* in_backprop;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input_shape, &in_backprop));\n    functor::CuboidConvolutionBackwardInput<Device, T>()(\n        context->eigen_device<Device>(),\n        in_backprop->tensor<T, 5>(),                     \n        filter.tensor<T, 5>(),                           \n        out_backprop.tensor<T, 5>(),                     \n        static_cast<int>(dims.spatial_dims[0].stride),   \n        static_cast<int>(dims.spatial_dims[1].stride),   \n        static_cast<int>(dims.spatial_dims[2].stride));  \n  }", "target": 0}
{"code": "RegexMatchExpression::RegexMatchExpression(StringData path, StringData regex, StringData options)\n    : LeafMatchExpression(REGEX, path),\n      _regex(regex.toString()),\n      _flags(options.toString()),\n      _re(new pcrecpp::RE(_regex.c_str(), flags2options(_flags.c_str()))) {\n    _init();\n}", "target": 0}
{"code": "static char *make_filename_safe(const char *filename TSRMLS_DC)\n{\n\tif (*filename && strncmp(filename, \":memory:\", sizeof(\":memory:\")-1)) {\n\t\tchar *fullpath = expand_filepath(filename, NULL TSRMLS_CC);\n\t\tif (!fullpath) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (PG(safe_mode) && (!php_checkuid(fullpath, NULL, CHECKUID_CHECK_FILE_AND_DIR))) {\n\t\t\tefree(fullpath);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (php_check_open_basedir(fullpath TSRMLS_CC)) {\n\t\t\tefree(fullpath);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn fullpath;\n\t}\n\treturn estrdup(filename);\n}", "target": 1}
{"code": "ppp_mp_insert(struct ppp *ppp, struct sk_buff *skb)\n{\n\tstruct sk_buff *p;\n\tstruct sk_buff_head *list = &ppp->mrq;\n\tu32 seq = skb->sequence;\n\tskb_queue_walk(list, p) {\n\t\tif (seq_before(seq, p->sequence))\n\t\t\tbreak;\n\t}\n\t__skb_queue_before(list, p, skb);\n}", "target": 0}
{"code": "EC_GROUP *d2i_ECPKParameters(EC_GROUP **a, const unsigned char **in, long len)\n{\n    EC_GROUP *group = NULL;\n    ECPKPARAMETERS *params = NULL;\n    if ((params = d2i_ECPKPARAMETERS(NULL, in, len)) == NULL) {\n        ECerr(EC_F_D2I_ECPKPARAMETERS, EC_R_D2I_ECPKPARAMETERS_FAILURE);\n        ECPKPARAMETERS_free(params);\n        return NULL;\n    }\n    if ((group = ec_asn1_pkparameters2group(params)) == NULL) {\n        ECerr(EC_F_D2I_ECPKPARAMETERS, EC_R_PKPARAMETERS2GROUP_FAILURE);\n        return NULL;\n    }\n    if (a && *a)\n        EC_GROUP_clear_free(*a);\n    if (a)\n        *a = group;\n    ECPKPARAMETERS_free(params);\n    return (group);\n}", "target": 0}
{"code": "nfp_abm_u32_knode_replace(struct nfp_abm_link *alink,\n\t\t\t  struct tc_cls_u32_knode *knode,\n\t\t\t  __be16 proto, struct netlink_ext_ack *extack)\n{\n\tstruct nfp_abm_u32_match *match = NULL, *iter;\n\tunsigned int tos_off;\n\tu8 mask, val;\n\tint err;\n\tif (!nfp_abm_u32_check_knode(alink->abm, knode, proto, extack))\n\t\tgoto err_delete;\n\ttos_off = proto == htons(ETH_P_IP) ? 16 : 20;\n\tval = be32_to_cpu(knode->sel->keys[0].val) >> tos_off & 0xff;\n\tmask = be32_to_cpu(knode->sel->keys[0].mask) >> tos_off & 0xff;\n\tlist_for_each_entry(iter, &alink->dscp_map, list) {\n\t\tu32 cmask;\n\t\tif (iter->handle == knode->handle) {\n\t\t\tmatch = iter;\n\t\t\tcontinue;\n\t\t}\n\t\tcmask = iter->mask & mask;\n\t\tif ((iter->val & cmask) == (val & cmask) &&\n\t\t    iter->band != knode->res->classid) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"conflict with already offloaded filter\");\n\t\t\tgoto err_delete;\n\t\t}\n\t}\n\tif (!match) {\n\t\tmatch = kzalloc(sizeof(*match), GFP_KERNEL);\n\t\tif (!match)\n\t\t\treturn -ENOMEM;\n\t\tlist_add(&match->list, &alink->dscp_map);\n\t}\n\tmatch->handle = knode->handle;\n\tmatch->band = knode->res->classid;\n\tmatch->mask = mask;\n\tmatch->val = val;\n\terr = nfp_abm_update_band_map(alink);\n\tif (err)\n\t\tgoto err_delete;\n\treturn 0;\nerr_delete:\n\tnfp_abm_u32_knode_delete(alink, knode);\n\treturn -EOPNOTSUPP;\n}", "target": 1}
{"code": "static int test_ifdefine_section(cmd_parms *cmd, const char *arg)\n{\n    return ap_exists_config_define(arg);\n}", "target": 0}
{"code": "dissect_header_lens_v1(tvbuff_t *tvb, int offset, proto_tree *tree, int encoding, int * const *hf_indexes)\n{\n    int param_count;\n    proto_item *ti;\n    proto_tree *len_tree;\n    for (param_count = 0; hf_indexes[param_count]; param_count++);\n    ti = proto_tree_add_item(tree, hf_se_param_lens, tvb, offset, param_count * SYSDIG_PARAM_SIZE, ENC_NA);\n    len_tree = proto_item_add_subtree(ti, ett_sysdig_parm_lens);\n    for (param_count = 0; hf_indexes[param_count]; param_count++) {\n        proto_tree_add_item(len_tree, hf_se_param_len, tvb, offset + (param_count * SYSDIG_PARAM_SIZE), SYSDIG_PARAM_SIZE, encoding);\n    }\n    proto_item_set_len(ti, param_count * SYSDIG_PARAM_SIZE);\n    return param_count * SYSDIG_PARAM_SIZE;\n}", "target": 0}
{"code": "void jbd2_journal_lock_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\tjbd2_might_wait_for_commit(journal);\n\twrite_lock(&journal->j_state_lock);\n\t++journal->j_barrier_count;\n\tif (atomic_read(&journal->j_reserved_credits)) {\n\t\twrite_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_reserved,\n\t\t\t   atomic_read(&journal->j_reserved_credits) == 0);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\tjbd2_journal_wait_updates(journal);\n\twrite_unlock(&journal->j_state_lock);\n\tmutex_lock(&journal->j_barrier);\n}", "target": 1}
{"code": "xmlValidCtxtNormalizeAttributeValue(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\n\t     xmlNodePtr elem, const xmlChar *name, const xmlChar *value) {\n    xmlChar *ret, *dst;\n    const xmlChar *src;\n    xmlAttributePtr attrDecl = NULL;\n    int extsubset = 0;\n    if (doc == NULL) return(NULL);\n    if (elem == NULL) return(NULL);\n    if (name == NULL) return(NULL);\n    if (value == NULL) return(NULL);\n    if ((elem->ns != NULL) && (elem->ns->prefix != NULL)) {\n\txmlChar fn[50];\n\txmlChar *fullname;\n\tfullname = xmlBuildQName(elem->name, elem->ns->prefix, fn, 50);\n\tif (fullname == NULL)\n\t    return(NULL);\n\tattrDecl = xmlGetDtdAttrDesc(doc->intSubset, fullname, name);\n\tif ((attrDecl == NULL) && (doc->extSubset != NULL)) {\n\t    attrDecl = xmlGetDtdAttrDesc(doc->extSubset, fullname, name);\n\t    if (attrDecl != NULL)\n\t\textsubset = 1;\n\t}\n\tif ((fullname != fn) && (fullname != elem->name))\n\t    xmlFree(fullname);\n    }\n    if ((attrDecl == NULL) && (doc->intSubset != NULL))\n\tattrDecl = xmlGetDtdAttrDesc(doc->intSubset, elem->name, name);\n    if ((attrDecl == NULL) && (doc->extSubset != NULL)) {\n\tattrDecl = xmlGetDtdAttrDesc(doc->extSubset, elem->name, name);\n\tif (attrDecl != NULL)\n\t    extsubset = 1;\n    }\n    if (attrDecl == NULL)\n\treturn(NULL);\n    if (attrDecl->atype == XML_ATTRIBUTE_CDATA)\n\treturn(NULL);\n    ret = xmlStrdup(value);\n    if (ret == NULL)\n\treturn(NULL);\n    src = value;\n    dst = ret;\n    while (*src == 0x20) src++;\n    while (*src != 0) {\n\tif (*src == 0x20) {\n\t    while (*src == 0x20) src++;\n\t    if (*src != 0)\n\t\t*dst++ = 0x20;\n\t} else {\n\t    *dst++ = *src++;\n\t}\n    }\n    *dst = 0;\n    if ((doc->standalone) && (extsubset == 1) && (!xmlStrEqual(value, ret))) {\n\txmlErrValidNode(ctxt, elem, XML_DTD_NOT_STANDALONE,\n\"standalone: %s on %s value had to be normalized based on external subset declaration\\n\",\n\t       name, elem->name, NULL);\n\tctxt->valid = 0;\n    }\n    return(ret);\n}", "target": 1}
{"code": "ServiceWorkerContainer* NavigatorServiceWorker::serviceWorker(Navigator& navigator, ExceptionState& exceptionState)\n {\n     return NavigatorServiceWorker::from(navigator).serviceWorker(exceptionState);\n }", "target": 1}
{"code": "static void __mcheck_cpu_clear_vendor(struct cpuinfo_x86 *c)\n{\n\tswitch (c->x86_vendor) {\n\tcase X86_VENDOR_INTEL:\n\t\tmce_intel_feature_clear(c);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "option_persist_cb (const gchar *option_name,\n                   const gchar *value,\n                   gpointer     data,\n                   GError     **error)\n{\n  FlatpakContext *context = data;\n  flatpak_context_set_persistent (context, value);\n  return TRUE;\n}", "target": 1}
{"code": "    bool PamBackend::start(const QString &user) {\n        bool result;\n        QString service = QStringLiteral(\"sddm\");\n        if (user == QStringLiteral(\"sddm\") && m_greeter)\n            service = QStringLiteral(\"sddm-greeter\");\n        else if (m_app->session()->path().isEmpty())\n            service = QStringLiteral(\"sddm-check\");\n        else if (m_autologin)\n            service = QStringLiteral(\"sddm-autologin\");\n        result = m_pam->start(service, user);\n        if (!result)\n            m_app->error(m_pam->errorString(), Auth::ERROR_INTERNAL);\n        return result;\n    }", "target": 1}
{"code": "static inline int xrstor_state_booting(struct xsave_struct *fx, u64 mask)\n{\n\tu32 lmask = mask;\n\tu32 hmask = mask >> 32;\n\tint err = 0;\n\tWARN_ON(system_state != SYSTEM_BOOTING);\n\tif (boot_cpu_has(X86_FEATURE_XSAVES))\n\t\tasm volatile(\"1:\"XRSTORS\"\\n\\t\"\n\t\t\t\"2:\\n\\t\"\n\t\t\t: : \"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t\t:   \"memory\");\n\telse\n\t\tasm volatile(\"1:\"XRSTOR\"\\n\\t\"\n\t\t\t\"2:\\n\\t\"\n\t\t\t: : \"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t\t:   \"memory\");\n\tasm volatile(xstate_fault\n\t\t     : \"0\" (0)\n\t\t     : \"memory\");\n\treturn err;\n}", "target": 1}
{"code": "static int calcstepsizes(uint_fast16_t refstepsize, int numrlvls,\n  uint_fast16_t *stepsizes)\n{\n\tint bandno;\n\tint numbands;\n\tuint_fast16_t expn;\n\tuint_fast16_t mant;\n\texpn = JPC_QCX_GETEXPN(refstepsize);\n\tmant = JPC_QCX_GETMANT(refstepsize);\n\tnumbands = 3 * numrlvls - 2;\n\tfor (bandno = 0; bandno < numbands; ++bandno) {\n\t\tstepsizes[bandno] = JPC_QCX_MANT(mant) | JPC_QCX_EXPN(expn + (bandno + 2) / 3);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "process_bitmap_updates(STREAM s)\n{\n\tuint16 num_updates;\n\tint i;\n\tin_uint16_le(s, num_updates);\t\n\tfor (i = 0; i < num_updates; i++)\n\t{\n\t\tprocess_bitmap_data(s);\n\t}\n}", "target": 0}
{"code": "\t__must_hold(&ctx->completion_lock)\n{\n\tu32 seq = ctx->cached_cq_tail - atomic_read(&ctx->cq_timeouts);\n\tspin_lock_irq(&ctx->timeout_lock);\n\twhile (!list_empty(&ctx->timeout_list)) {\n\t\tu32 events_needed, events_got;\n\t\tstruct io_kiocb *req = list_first_entry(&ctx->timeout_list,\n\t\t\t\t\t\tstruct io_kiocb, timeout.list);\n\t\tif (io_is_timeout_noseq(req))\n\t\t\tbreak;\n\t\tevents_needed = req->timeout.target_seq - ctx->cq_last_tm_flush;\n\t\tevents_got = seq - ctx->cq_last_tm_flush;\n\t\tif (events_got < events_needed)\n\t\t\tbreak;\n\t\tlist_del_init(&req->timeout.list);\n\t\tio_kill_timeout(req, 0);\n\t}\n\tctx->cq_last_tm_flush = seq;\n\tspin_unlock_irq(&ctx->timeout_lock);\n}", "target": 1}
{"code": "void *_zend_shared_memdup(void *source, size_t size, zend_bool free_source TSRMLS_DC)\n{\n\tvoid **old_p, *retval;\n\tif (zend_hash_index_find(&xlat_table, (ulong)source, (void **)&old_p) == SUCCESS) {\n\t\treturn *old_p;\n\t}\n\tretval = ZCG(mem);;\n\tZCG(mem) = (void*)(((char*)ZCG(mem)) + ZEND_ALIGNED_SIZE(size));\n\tmemcpy(retval, source, size);\n\tif (free_source) {\n\t\tinterned_efree((char*)source);\n\t}\n\tzend_shared_alloc_register_xlat_entry(source, retval);\n\treturn retval;\n}", "target": 1}
{"code": "int __pte_alloc(struct mm_struct *mm, pmd_t *pmd, unsigned long address)\n{\n\tpgtable_t new = pte_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\tsmp_wmb(); \n\tspin_lock(&mm->page_table_lock);\n\tif (!pmd_present(*pmd)) {\t\n\t\tmm->nr_ptes++;\n\t\tpmd_populate(mm, pmd, new);\n\t\tnew = NULL;\n\t}\n\tspin_unlock(&mm->page_table_lock);\n\tif (new)\n\t\tpte_free(mm, new);\n\treturn 0;\n}", "target": 0}
{"code": "PHP_FUNCTION(enchant_broker_request_dict)\n{\n\tzval *broker;\n\tenchant_broker *pbroker;\n\tenchant_dict *dict;\n\tEnchantDict *d;\n\tchar *tag;\n\tint taglen;\n\tint pos;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rs\", &broker, &tag, &taglen) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tPHP_ENCHANT_GET_BROKER;\n\tif (taglen == 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Tag cannot be empty\");\n\t\tRETURN_FALSE;\n\t}\n\td = enchant_broker_request_dict(pbroker->pbroker, (const char *)tag);\n\tif (d) {\n\t\tif (pbroker->dictcnt) {\n\t\t\tpbroker->dict = (enchant_dict **)erealloc(pbroker->dict, sizeof(enchant_dict *) * pbroker->dictcnt);\n\t\t\tpos = pbroker->dictcnt++;\n\t\t} else {\n\t\t\tpbroker->dict = (enchant_dict **)emalloc(sizeof(enchant_dict *));\n\t\t\tpos = 0;\n\t\t\tpbroker->dictcnt++;\n\t\t}\n\t\tdict = pbroker->dict[pos] = (enchant_dict *)emalloc(sizeof(enchant_dict));\n\t\tdict->id = pos;\n\t\tdict->pbroker = pbroker;\n\t\tdict->pdict = d;\n\t\tdict->prev = pos ? pbroker->dict[pos-1] : NULL;\n\t\tdict->next = NULL;\n\t\tpbroker->dict[pos] = dict;\n\t\tif (pos) {\n\t\t\tpbroker->dict[pos-1]->next = dict;\n\t\t}\n\t\tdict->rsrc_id = ZEND_REGISTER_RESOURCE(return_value, dict, le_enchant_dict);\n\t\tzend_list_addref(pbroker->rsrc_id);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}", "target": 1}
{"code": "stf_status ikev2parent_inI2outR2(struct msg_digest *md)\n{\n\tstruct state *st = md->st;\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\n\t\t    \"ikev2 parent inI2outR2: calculating g^{xy} in order to decrypt I2\"));\n\tif (!md->chain[ISAKMP_NEXT_v2E]) {\n\t\tlibreswan_log(\"R2 state should receive an encrypted payload\");\n\t\treset_globals();\n\t\treturn STF_FATAL;\n\t}\n\t{\n\t\tstruct dh_continuation *dh = alloc_thing(\n\t\t\tstruct dh_continuation,\n\t\t\t\"ikev2_inI2outR2 KE\");\n\t\tstf_status e;\n\t\tdh->md = md;\n\t\tset_suspended(st, dh->md);\n\t\tpcrc_init(&dh->dh_pcrc);\n\t\tdh->dh_pcrc.pcrc_func = ikev2_parent_inI2outR2_continue;\n\t\te = start_dh_v2(&dh->dh_pcrc, st, st->st_import, RESPONDER,\n\t\t\t\tst->st_oakley.groupnum);\n\t\tif (e != STF_SUSPEND && e != STF_INLINE) {\n\t\t\tloglog(RC_CRYPTOFAILED, \"system too busy\");\n\t\t\tdelete_state(st);\n\t\t}\n\t\treset_globals();\n\t\treturn e;\n\t}\n}", "target": 1}
{"code": "writeRandomBytes_arc4random(void * target, size_t count) {\n  size_t bytesWrittenTotal = 0;\n  while (bytesWrittenTotal < count) {\n    const uint32_t random32 = arc4random();\n    size_t i = 0;\n    for (; (i < sizeof(random32)) && (bytesWrittenTotal < count);\n        i++, bytesWrittenTotal++) {\n      const uint8_t random8 = (uint8_t)(random32 >> (i * 8));\n      ((uint8_t *)target)[bytesWrittenTotal] = random8;\n    }\n  }\n}", "target": 0}
{"code": "static int rm_rf_inner_child(\n                int fd,\n                const char *fname,\n                int is_dir,\n                RemoveFlags flags,\n                const struct stat *root_dev,\n                bool allow_recursion) {\n        struct stat st;\n        int r, q = 0;\n        assert(fd >= 0);\n        assert(fname);\n        if (is_dir < 0 ||\n            root_dev ||\n            (is_dir > 0 && (root_dev || (flags & REMOVE_SUBVOLUME)))) {\n                r = fstatat_harder(fd, fname, &st, AT_SYMLINK_NOFOLLOW, flags);\n                if (r < 0)\n                        return r;\n                is_dir = S_ISDIR(st.st_mode);\n        }\n        if (is_dir) {\n                if (root_dev && st.st_dev != root_dev->st_dev)\n                        return 0;\n                r = fd_is_mount_point(fd, fname, 0);\n                if (r < 0)\n                        return r;\n                if (r > 0)\n                        return 0;\n                if ((flags & REMOVE_SUBVOLUME) && btrfs_might_be_subvol(&st)) {\n                        r = btrfs_subvol_remove_fd(fd, fname, BTRFS_REMOVE_RECURSIVE|BTRFS_REMOVE_QUOTA);\n                        if (r < 0) {\n                                if (!IN_SET(r, -ENOTTY, -EINVAL))\n                                        return r;\n                        } else\n                                return 1;\n                }\n                if (!allow_recursion)\n                        return -EISDIR;\n                int subdir_fd = openat(fd, fname, O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);\n                if (subdir_fd < 0)\n                        return -errno;\n                q = rm_rf_children(subdir_fd, flags | REMOVE_PHYSICAL, root_dev);\n        } else if (flags & REMOVE_ONLY_DIRECTORIES)\n                return 0;\n        r = unlinkat_harder(fd, fname, is_dir ? AT_REMOVEDIR : 0, flags);\n        if (r < 0)\n                return r;\n        if (q < 0)\n                return q;\n        return 1;\n}", "target": 0}
{"code": "  NullVideoFrame() {}", "target": 0}
{"code": "void Logger::addPeer(const QString &ip, bool blocked, const QString &reason)\n{\n    QWriteLocker locker(&lock);\n    Log::Peer temp = { peerCounter++, QDateTime::currentMSecsSinceEpoch(), ip, blocked, reason };\n    m_peers.push_back(temp);\n    if (m_peers.size() >= MAX_LOG_MESSAGES)\n        m_peers.pop_front();\n    emit newLogPeer(temp);\n}", "target": 1}
{"code": "static int copy_verifier_state(struct bpf_verifier_state *dst_state,\n\t\t\t       const struct bpf_verifier_state *src)\n{\n\tstruct bpf_func_state *dst;\n\tu32 jmp_sz = sizeof(struct bpf_idx_pair) * src->jmp_history_cnt;\n\tint i, err;\n\tif (dst_state->jmp_history_cnt < src->jmp_history_cnt) {\n\t\tkfree(dst_state->jmp_history);\n\t\tdst_state->jmp_history = kmalloc(jmp_sz, GFP_USER);\n\t\tif (!dst_state->jmp_history)\n\t\t\treturn -ENOMEM;\n\t}\n\tmemcpy(dst_state->jmp_history, src->jmp_history, jmp_sz);\n\tdst_state->jmp_history_cnt = src->jmp_history_cnt;\n\tfor (i = src->curframe + 1; i <= dst_state->curframe; i++) {\n\t\tfree_func_state(dst_state->frame[i]);\n\t\tdst_state->frame[i] = NULL;\n\t}\n\tdst_state->speculative = src->speculative;\n\tdst_state->curframe = src->curframe;\n\tdst_state->active_spin_lock = src->active_spin_lock;\n\tdst_state->branches = src->branches;\n\tdst_state->parent = src->parent;\n\tdst_state->first_insn_idx = src->first_insn_idx;\n\tdst_state->last_insn_idx = src->last_insn_idx;\n\tfor (i = 0; i <= src->curframe; i++) {\n\t\tdst = dst_state->frame[i];\n\t\tif (!dst) {\n\t\t\tdst = kzalloc(sizeof(*dst), GFP_KERNEL);\n\t\t\tif (!dst)\n\t\t\t\treturn -ENOMEM;\n\t\t\tdst_state->frame[i] = dst;\n\t\t}\n\t\terr = copy_func_state(dst, src->frame[i]);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int process_cpu_clock_get(const clockid_t which_clock,\n\t\t\t\t struct timespec *tp)\n{\n\treturn posix_cpu_clock_get(PROCESS_CLOCK, tp);\n}", "target": 0}
{"code": "int FoFiTrueType::setupGSUB(const char *scriptName)\n{\n  return setupGSUB(scriptName, NULL);\n}", "target": 0}
{"code": "spnego_gss_wrap_iov(OM_uint32 *minor_status,\n\t\t    gss_ctx_id_t context_handle,\n\t\t    int conf_req_flag,\n\t\t    gss_qop_t qop_req,\n\t\t    int *conf_state,\n\t\t    gss_iov_buffer_desc *iov,\n\t\t    int iov_count)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_iov(minor_status,\n\t\t\t   context_handle,\n\t\t\t   conf_req_flag,\n\t\t\t   qop_req,\n\t\t\t   conf_state,\n\t\t\t   iov,\n\t\t\t   iov_count);\n\treturn (ret);\n}", "target": 1}
{"code": "static int hclge_tm_schd_mode_vnet_base_cfg(struct hclge_vport *vport)\n{\n\tstruct hnae3_knic_private_info *kinfo = &vport->nic.kinfo;\n\tstruct hclge_dev *hdev = vport->back;\n\tint ret;\n\tu8 i;\n\tret = hclge_tm_pri_schd_mode_cfg(hdev, vport->vport_id);\n\tif (ret)\n\t\treturn ret;\n\tfor (i = 0; i < kinfo->num_tc; i++) {\n\t\tu8 sch_mode = hdev->tm_info.tc_info[i].tc_sch_mode;\n\t\tret = hclge_tm_qs_schd_mode_cfg(hdev, vport->qs_offset + i,\n\t\t\t\t\t\tsch_mode);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "pipe_setup (Pipe *pipe, FILE *logf, gpointer user_data)\n{\n\tGIOFlags flags = 0;\n\tpipe->logf = logf;\n\tpipe->buf = g_string_sized_new (512);\n\tpipe->channel = g_io_channel_unix_new (pipe->fd);\n\tg_io_channel_set_encoding (pipe->channel, NULL, NULL);\n\tflags = g_io_channel_get_flags (pipe->channel);\n\tg_io_channel_set_flags (pipe->channel, flags | G_IO_FLAG_NONBLOCK, NULL);\n\tg_io_channel_set_buffered (pipe->channel, FALSE);\n\tpipe->watch = g_io_add_watch (pipe->channel,\n\t                              G_IO_IN | G_IO_ERR | G_IO_PRI,\n\t                              data_available,\n\t                              user_data);\n}", "target": 0}
{"code": "static inline void nf_reset(struct sk_buff *skb)\n{\n#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)\n\tnf_conntrack_put(skb->nfct);\n\tskb->nfct = NULL;\n#endif\n#ifdef NET_SKBUFF_NF_DEFRAG_NEEDED\n\tnf_conntrack_put_reasm(skb->nfct_reasm);\n\tskb->nfct_reasm = NULL;\n#endif\n#ifdef CONFIG_BRIDGE_NETFILTER\n\tnf_bridge_put(skb->nf_bridge);\n\tskb->nf_bridge = NULL;\n#endif\n}", "target": 0}
{"code": "static bool dccp_new(struct nf_conn *ct, const struct sk_buff *skb,\n\t\t     unsigned int dataoff, unsigned int *timeouts)\n{\n\tstruct net *net = nf_ct_net(ct);\n\tstruct dccp_net *dn;\n\tstruct dccp_hdr _dh, *dh;\n\tconst char *msg;\n\tu_int8_t state;\n\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);\n\tBUG_ON(dh == NULL);\n\tstate = dccp_state_table[CT_DCCP_ROLE_CLIENT][dh->dccph_type][CT_DCCP_NONE];\n\tswitch (state) {\n\tdefault:\n\t\tdn = dccp_pernet(net);\n\t\tif (dn->dccp_loose == 0) {\n\t\t\tmsg = \"nf_ct_dccp: not picking up existing connection \";\n\t\t\tgoto out_invalid;\n\t\t}\n\tcase CT_DCCP_REQUEST:\n\t\tbreak;\n\tcase CT_DCCP_INVALID:\n\t\tmsg = \"nf_ct_dccp: invalid state transition \";\n\t\tgoto out_invalid;\n\t}\n\tct->proto.dccp.role[IP_CT_DIR_ORIGINAL] = CT_DCCP_ROLE_CLIENT;\n\tct->proto.dccp.role[IP_CT_DIR_REPLY] = CT_DCCP_ROLE_SERVER;\n\tct->proto.dccp.state = CT_DCCP_NONE;\n\tct->proto.dccp.last_pkt = DCCP_PKT_REQUEST;\n\tct->proto.dccp.last_dir = IP_CT_DIR_ORIGINAL;\n\tct->proto.dccp.handshake_seq = 0;\n\treturn true;\nout_invalid:\n\tif (LOG_INVALID(net, IPPROTO_DCCP))\n\t\tnf_log_packet(net, nf_ct_l3num(ct), 0, skb, NULL, NULL,\n\t\t\t      NULL, \"%s\", msg);\n\treturn false;\n}", "target": 1}
{"code": "bool CWalletTx::AcceptWalletTransaction(CTxDB& txdb, bool fCheckInputs)\n{\n    {\n        LOCK(mempool.cs);\n        BOOST_FOREACH(CMerkleTx& tx, vtxPrev)\n        {\n            if (!tx.IsCoinBase())\n            {\n                uint256 hash = tx.GetHash();\n                if (!mempool.exists(hash) && !txdb.ContainsTx(hash))\n                    tx.AcceptToMemoryPool(txdb, fCheckInputs);\n            }\n        }\n        return AcceptToMemoryPool(txdb, fCheckInputs);\n    }\n    return false;\n}", "target": 1}
{"code": "cmsBool OpenOutput(const char* FileName)\n{\n\tOutFile = fopen(FileName, \"wb\");\n\tif (OutFile == NULL) {\n\t\tFatalError(\"Cannot create '%s'\", FileName);\n\t}\n\tCompressor.err                   = jpeg_std_error(&ErrorHandler.pub);\n\tErrorHandler.pub.error_exit      = my_error_exit;\n\tErrorHandler.pub.output_message  = my_error_exit;\n\tCompressor.input_components = Compressor.num_components = 4;\n\tjpeg_create_compress(&Compressor);\n\tjpeg_stdio_dest(&Compressor, OutFile);\n\treturn TRUE;\n}", "target": 0}
{"code": "static void *_clua_allocator(void *ud, void *ptr, size_t osize, size_t nsize)\n{\n    CLua *cl = static_cast<CLua *>(ud);\n    cl->memory_used += nsize - osize;\n    if (nsize > osize && cl->memory_used >= CLUA_MAX_MEMORY_USE * 1024\n        && cl->mixed_call_depth)\n    {\n        return nullptr;\n    }\n    if (!nsize)\n    {\n        free(ptr);\n        return nullptr;\n    }\n    else\n        return realloc(ptr, nsize);\n}", "target": 0}
{"code": "static BOOL update_gdi_mem3blt(rdpContext* context, MEM3BLT_ORDER* mem3blt)\n{\n\tBYTE style;\n\trdpBitmap* bitmap;\n\trdpCache* cache = context->cache;\n\trdpBrush* brush = &mem3blt->brush;\n\tBOOL ret = TRUE;\n\tif (mem3blt->cacheId == 0xFF)\n\t\tbitmap = offscreen_cache_get(cache->offscreen, mem3blt->cacheIndex);\n\telse\n\t\tbitmap = bitmap_cache_get(cache->bitmap, (BYTE)mem3blt->cacheId, mem3blt->cacheIndex);\n\tif (!bitmap)\n\t\treturn TRUE;\n\tstyle = brush->style;\n\tif (brush->style & CACHED_BRUSH)\n\t{\n\t\tbrush->data = brush_cache_get(cache->brush, brush->index, &brush->bpp);\n\t\tif (!brush->data)\n\t\t\treturn FALSE;\n\t\tbrush->style = 0x03;\n\t}\n\tmem3blt->bitmap = bitmap;\n\tIFCALLRET(cache->bitmap->Mem3Blt, ret, context, mem3blt);\n\tbrush->style = style;\n\treturn ret;\n}", "target": 0}
{"code": "flatpak_context_set_persistent (FlatpakContext *context,\n                                const char     *path)\n{\n  g_hash_table_insert (context->persistent, g_strdup (path), GINT_TO_POINTER (1));\n}", "target": 1}
{"code": "TEST_F(QueryPlannerTest, ThreeRegexSameFieldMultikey) {\n    addIndex(BSON(\"a\" << 1), true);\n    runQuery(fromjson(\"{$and: [{a: /0/}, {a: /1/}, {a: /2/}]}\"));\n    ASSERT_EQUALS(getNumSolutions(), 4U);\n    assertSolutionExists(\"{cscan: {filter: {$and:[{a:/0/},{a:/1/},{a:/2/}]}, dir: 1}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: {$and:[{a:/0/},{a:/1/},{a:/2/}]}, node: {ixscan: \"\n        \"{pattern: {a: 1}, filter: null, \"\n        \"bounds: {a: [['', {}, true, false], [/0/, /0/, true, true]]}}}}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: {$and:[{a:/1/},{a:/0/},{a:/2/}]}, node: {ixscan: \"\n        \"{pattern: {a: 1}, filter: null, \"\n        \"bounds: {a: [['', {}, true, false], [/1/, /1/, true, true]]}}}}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: {$and:[{a:/2/},{a:/0/},{a:/1/}]}, node: {ixscan: \"\n        \"{pattern: {a: 1}, filter: null, \"\n        \"bounds: {a: [['', {}, true, false], [/2/, /2/, true, true]]}}}}}\");\n}", "target": 0}
{"code": "static void SerializeGltfSampler(Sampler &sampler, json &o) {\n  if (sampler.magFilter != -1) {\n    SerializeNumberProperty(\"magFilter\", sampler.magFilter, o);\n  }\n  if (sampler.minFilter != -1) {\n    SerializeNumberProperty(\"minFilter\", sampler.minFilter, o);\n  }\n  SerializeNumberProperty(\"wrapS\", sampler.wrapS, o);\n  SerializeNumberProperty(\"wrapT\", sampler.wrapT, o);\n  if (sampler.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", sampler.extras, o);\n  }\n}", "target": 1}
{"code": "static uint8_t net_tx_pkt_get_gso_type(struct NetTxPkt *pkt,\n                                          bool tso_enable)\n{\n    uint8_t rc = VIRTIO_NET_HDR_GSO_NONE;\n    uint16_t l3_proto;\n    l3_proto = eth_get_l3_proto(&pkt->vec[NET_TX_PKT_L2HDR_FRAG], 1,\n        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len);\n    if (!tso_enable) {\n        goto func_exit;\n    }\n    rc = eth_get_gso_type(l3_proto, pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base,\n                          pkt->l4proto);\nfunc_exit:\n    return rc;\n}", "target": 0}
{"code": "void EditorClientBlackBerry::textWillBeDeletedInTextField(Element*)\n{\n    notImplemented();\n}", "target": 0}
{"code": "int ip_build_and_send_pkt(struct sk_buff *skb, struct sock *sk,\n\t\t\t  __be32 saddr, __be32 daddr, struct ip_options *opt)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct rtable *rt = skb_rtable(skb);\n\tstruct iphdr *iph;\n\tskb_push(skb, sizeof(struct iphdr) + (opt ? opt->optlen : 0));\n\tskb_reset_network_header(skb);\n\tiph = ip_hdr(skb);\n\tiph->version  = 4;\n\tiph->ihl      = 5;\n\tiph->tos      = inet->tos;\n\tif (ip_dont_fragment(sk, &rt->dst))\n\t\tiph->frag_off = htons(IP_DF);\n\telse\n\t\tiph->frag_off = 0;\n\tiph->ttl      = ip_select_ttl(inet, &rt->dst);\n\tiph->daddr    = rt->rt_dst;\n\tiph->saddr    = rt->rt_src;\n\tiph->protocol = sk->sk_protocol;\n\tip_select_ident(iph, &rt->dst, sk);\n\tif (opt && opt->optlen) {\n\t\tiph->ihl += opt->optlen>>2;\n\t\tip_options_build(skb, opt, daddr, rt, 0);\n\t}\n\tskb->priority = sk->sk_priority;\n\tskb->mark = sk->sk_mark;\n\treturn ip_local_out(skb);\n}", "target": 1}
{"code": "static int mincore_unmapped_range(unsigned long addr, unsigned long end,\n\t\t\t\t   struct mm_walk *walk)\n{\n\twalk->private += __mincore_unmapped_range(addr, end,\n\t\t\t\t\t\t  walk->vma, walk->private);\n\treturn 0;\n}", "target": 1}
{"code": "get_val_across_arith_op (enum tree_code opcode,\n\t\t\t tree opnd1_type,\n\t\t\t tree opnd2,\n\t\t\t ipcp_value<tree> *src_val,\n\t\t\t tree res_type)\n{\n  tree opnd1 = src_val->value;\n  if (opnd1_type\n      && !useless_type_conversion_p (opnd1_type, TREE_TYPE (opnd1)))\n    return NULL_TREE;\n  return ipa_get_jf_arith_result (opcode, opnd1, opnd2, res_type);\n}", "target": 0}
{"code": "  virtual void SetUpCommandLine(CommandLine* command_line) {\n    GpuFeatureTest::SetUpCommandLine(command_line);\n    command_line->AppendSwitch(switches::kEnableThreadedCompositing);\n  }", "target": 1}
{"code": "static void ax25_kill_by_device(struct net_device *dev)\n{\n\tax25_dev *ax25_dev;\n\tax25_cb *s;\n\tif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\n\t\treturn;\n\tspin_lock_bh(&ax25_list_lock);\nagain:\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->ax25_dev == ax25_dev) {\n\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\tlock_sock(s->sk);\n\t\t\ts->ax25_dev = NULL;\n\t\t\trelease_sock(s->sk);\n\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\tspin_lock_bh(&ax25_list_lock);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock_bh(&ax25_list_lock);\n}", "target": 1}
{"code": "static int __init personal_server_map_irq(const struct pci_dev *dev, u8 slot,\n\tu8 pin)\n{\n\tunsigned char line;\n\tpci_read_config_byte(dev, PCI_INTERRUPT_LINE, &line);\n\tif (line > 0x40 && line <= 0x5f) {\n\t\treturn irqmap_personal_server[(line & 0x1f) - 8];\n\t} else if (line == 0) {\n\t\treturn 0;\n\t} else\n\t\treturn irqmap_personal_server[(line - 1) & 3];\n}", "target": 1}
{"code": "static int intel_iommu_add_device(struct device *dev)\n{\n\tstruct intel_iommu *iommu;\n\tstruct iommu_group *group;\n\tu8 bus, devfn;\n\tiommu = device_to_iommu(dev, &bus, &devfn);\n\tif (!iommu)\n\t\treturn -ENODEV;\n\tiommu_device_link(&iommu->iommu, dev);\n\tgroup = iommu_group_get_for_dev(dev);\n\tif (IS_ERR(group))\n\t\treturn PTR_ERR(group);\n\tiommu_group_put(group);\n\treturn 0;\n}", "target": 0}
{"code": "ikev1_hash_print(netdissect_options *ndo, u_char tpay _U_,\n\t\t const struct isakmp_gen *ext, u_int item_len _U_,\n\t\t const u_char *ep _U_, uint32_t phase _U_, uint32_t doi _U_,\n\t\t uint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_HASH)));\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_HASH)));\n\treturn NULL;\n}", "target": 0}
{"code": "static struct mobj *alloc_ta_mem(size_t size)\n{\n#ifdef CFG_PAGED_USER_TA\n\treturn mobj_paged_alloc(size);\n#else\n\tstruct mobj *mobj = mobj_mm_alloc(mobj_sec_ddr, size, &tee_mm_sec_ddr);\n\tif (mobj)\n\t\tmemset(mobj_get_va(mobj, 0), 0, size);\n\treturn mobj;\n#endif\n}", "target": 1}
{"code": "void qemu_ram_free(struct uc_struct *uc, RAMBlock *block)\n{\n    if (!block) {\n        return;\n    }\n    QLIST_REMOVE(block, next);\n    uc->ram_list.mru_block = NULL;\n    reclaim_ramblock(uc, block);\n}", "target": 1}
{"code": "int hw_atl_utils_fw_rpc_wait(struct aq_hw_s *self,\n\t\t\t     struct hw_atl_utils_fw_rpc **rpc)\n{\n\tstruct aq_hw_atl_utils_fw_rpc_tid_s sw;\n\tstruct aq_hw_atl_utils_fw_rpc_tid_s fw;\n\tint err = 0;\n\tdo {\n\t\tsw.val = aq_hw_read_reg(self, HW_ATL_RPC_CONTROL_ADR);\n\t\tself->rpc_tid = sw.tid;\n\t\terr = readx_poll_timeout_atomic(hw_atl_utils_rpc_state_get,\n\t\t\t\t\t\tself, fw.val,\n\t\t\t\t\t\tsw.tid == fw.tid,\n\t\t\t\t\t\t1000U, 100000U);\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\t\terr = aq_hw_err_from_flags(self);\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\t\tif (fw.len == 0xFFFFU) {\n\t\t\terr = hw_atl_utils_fw_rpc_call(self, sw.len);\n\t\t\tif (err < 0)\n\t\t\t\tgoto err_exit;\n\t\t}\n\t} while (sw.tid != fw.tid || 0xFFFFU == fw.len);\n\tif (rpc) {\n\t\tif (fw.len) {\n\t\t\terr =\n\t\t\thw_atl_utils_fw_downld_dwords(self,\n\t\t\t\t\t\t      self->rpc_addr,\n\t\t\t\t\t\t      (u32 *)(void *)\n\t\t\t\t\t\t      &self->rpc,\n\t\t\t\t\t\t      (fw.len + sizeof(u32) -\n\t\t\t\t\t\t       sizeof(u8)) /\n\t\t\t\t\t\t      sizeof(u32));\n\t\t\tif (err < 0)\n\t\t\t\tgoto err_exit;\n\t\t}\n\t\t*rpc = &self->rpc;\n\t}\nerr_exit:\n\treturn err;\n}", "target": 1}
{"code": "pcl_status_read(byte * data, uint max_data, pcl_state_t * pcs)\n{\n    uint count = min(max_data,\n                     pcs->status.write_pos - pcs->status.read_pos);\n    if (count)\n        memcpy(data, pcs->status.buffer + pcs->status.read_pos, count);\n    pcs->status.read_pos += count;\n    if (pcs->status.read_pos == pcs->status.write_pos) {\n        gs_free_object(pcs->memory, pcs->status.buffer, \"status buffer\");\n        pcs->status.write_pos = pcs->status.read_pos = 0;\n    }\n    return count;\n}", "target": 1}
{"code": "static int vapic_enter(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tstruct page *page;\n\tif (!apic || !apic->vapic_addr)\n\t\treturn 0;\n\tpage = gfn_to_page(vcpu->kvm, apic->vapic_addr >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\treturn -EFAULT;\n\tvcpu->arch.apic->vapic_page = page;\n\treturn 0;\n}", "target": 1}
{"code": "MATCHER_P(MapEqValue, rhs, \"\") {\n  const ProtobufWkt::Struct& obj = arg;\n  EXPECT_TRUE(!rhs.empty());\n  for (auto const& entry : rhs) {\n    EXPECT_TRUE(TestUtility::protoEqual(obj.fields().at(entry.first), entry.second));\n  }\n  return true;\n}", "target": 0}
{"code": "find_jws(struct tang_keys_info* tki, const char* thp)\n{\n    if (!tki) {\n        return NULL;\n    }\n    if (thp == NULL) {\n        json_auto_t* jws = jwk_sign(tki->m_payload, tki->m_sign);\n        if (!jws) {\n            return NULL;\n        }\n        return json_incref(jws);\n    }\n    return find_by_thp(tki, thp);\n}", "target": 1}
{"code": "int nfc_dep_link_up(struct nfc_dev *dev, int target_index, u8 comm_mode)\n{\n\tint rc = 0;\n\tu8 *gb;\n\tsize_t gb_len;\n\tstruct nfc_target *target;\n\tpr_debug(\"dev_name=%s comm %d\\n\", dev_name(&dev->dev), comm_mode);\n\tif (!dev->ops->dep_link_up)\n\t\treturn -EOPNOTSUPP;\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->dep_link_up == true) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\tgb = nfc_llcp_general_bytes(dev, &gb_len);\n\tif (gb_len > NFC_MAX_GT_LEN) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\ttarget = nfc_find_target(dev, target_index);\n\tif (target == NULL) {\n\t\trc = -ENOTCONN;\n\t\tgoto error;\n\t}\n\trc = dev->ops->dep_link_up(dev, target, comm_mode, gb, gb_len);\n\tif (!rc) {\n\t\tdev->active_target = target;\n\t\tdev->rf_mode = NFC_RF_INITIATOR;\n\t}\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "static int skcipher_check_key(struct socket *sock)\n{\n\tint err = 0;\n\tstruct sock *psk;\n\tstruct alg_sock *pask;\n\tstruct skcipher_tfm *tfm;\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tlock_sock(sk);\n\tif (ask->refcnt)\n\t\tgoto unlock_child;\n\tpsk = ask->parent;\n\tpask = alg_sk(ask->parent);\n\ttfm = pask->private;\n\terr = -ENOKEY;\n\tlock_sock_nested(psk, SINGLE_DEPTH_NESTING);\n\tif (!tfm->has_key)\n\t\tgoto unlock;\n\tif (!pask->refcnt++)\n\t\tsock_hold(psk);\n\task->refcnt = 1;\n\tsock_put(psk);\n\terr = 0;\nunlock:\n\trelease_sock(psk);\nunlock_child:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "static inline void sw_tx_timestamp(struct sk_buff *skb)\n{\n\tif (skb_shinfo(skb)->tx_flags & SKBTX_SW_TSTAMP &&\n\t    !(skb_shinfo(skb)->tx_flags & SKBTX_IN_PROGRESS))\n\t\tskb_tstamp_tx(skb, NULL);\n}", "target": 0}
{"code": "smb_flush_file(struct smb_request *sr, struct smb_ofile *ofile)\n{\n\tsr->user_cr = smb_ofile_getcred(ofile);\n\tif ((ofile->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)\n\t\t(void) smb_fsop_commit(sr, sr->user_cr, ofile->f_node);\n}", "target": 1}
{"code": "static ssize_t available_instances_show(struct mdev_type *mtype,\n\t\t\t\t\tstruct mdev_type_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tconst struct mbochs_type *type =\n\t\t&mbochs_types[mtype_get_type_group_id(mtype)];\n\tint count = (max_mbytes - mbochs_used_mbytes) / type->mbytes;\n\treturn sprintf(buf, \"%d\\n\", count);\n}", "target": 1}
{"code": "static inline bool key_is_instantiated(const struct key *key)\n{\n\treturn test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&\n\t\t!test_bit(KEY_FLAG_NEGATIVE, &key->flags);\n}", "target": 1}
{"code": "ff_layout_ntop6_noscopeid(const struct sockaddr *sap, char *buf,\n\t\t\t  const int buflen)\n{\n\tconst struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)sap;\n\tconst struct in6_addr *addr = &sin6->sin6_addr;\n\tif (ipv6_addr_any(addr))\n\t\treturn snprintf(buf, buflen, \"::\");\n\tif (ipv6_addr_loopback(addr))\n\t\treturn snprintf(buf, buflen, \"::1\");\n\tif (ipv6_addr_v4mapped(addr))\n\t\treturn snprintf(buf, buflen, \"::ffff:%pI4\",\n\t\t\t\t\t&addr->s6_addr32[3]);\n\treturn snprintf(buf, buflen, \"%pI6c\", addr);\n}", "target": 0}
{"code": "static void php_mcrypt_module_dtor(zend_rsrc_list_entry *rsrc TSRMLS_DC) \n{\n\tphp_mcrypt *pm = (php_mcrypt *) rsrc->ptr;\n\tif (pm) {\t\n\t\tmcrypt_generic_deinit(pm->td);\n\t\tmcrypt_module_close(pm->td);\n\t\tefree(pm);\n\t\tpm = NULL;\n\t}", "target": 1}
{"code": "init_connection_options(MYSQL *mysql)\n{\n#if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)\n  if (opt_use_ssl)\n  {\n    mysql_ssl_set(mysql, opt_ssl_key, opt_ssl_cert, opt_ssl_ca,\n                  opt_ssl_capath, opt_ssl_cipher);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRL, opt_ssl_crl);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRLPATH, opt_ssl_crlpath);\n  }\n  mysql_options(mysql, MYSQL_OPT_SSL_VERIFY_SERVER_CERT,\n                (char*) &opt_ssl_verify_server_cert);\n#endif\n  if (opt_protocol)\n    mysql_options(mysql, MYSQL_OPT_PROTOCOL, (char*) &opt_protocol);\n#ifdef HAVE_SMEM\n  if (shared_memory_base_name)\n    mysql_options(mysql, MYSQL_SHARED_MEMORY_BASE_NAME, shared_memory_base_name);\n#endif\n}", "target": 1}
{"code": "static int sctp_setsockopt_auth_key(struct sock *sk,\n\t\t\t\t    char __user *optval,\n\t\t\t\t    int optlen)\n{\n\tstruct sctp_authkey *authkey;\n\tstruct sctp_association *asoc;\n\tint ret;\n\tif (!sctp_auth_enable)\n\t\treturn -EACCES;\n\tif (optlen <= sizeof(struct sctp_authkey))\n\t\treturn -EINVAL;\n\tauthkey = kmalloc(optlen, GFP_KERNEL);\n\tif (!authkey)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(authkey, optval, optlen)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\tasoc = sctp_id2assoc(sk, authkey->sca_assoc_id);\n\tif (!asoc && authkey->sca_assoc_id && sctp_style(sk, UDP)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = sctp_auth_set_key(sctp_sk(sk)->ep, asoc, authkey);\nout:\n\tkfree(authkey);\n\treturn ret;\n}", "target": 1}
{"code": "int genl_register_family(struct genl_family *family)\n{\n\tint err, i;\n\tint start = GENL_START_ALLOC, end = GENL_MAX_ID;\n\terr = genl_validate_ops(family);\n\tif (err)\n\t\treturn err;\n\tgenl_lock_all();\n\tif (genl_family_find_byname(family->name)) {\n\t\terr = -EEXIST;\n\t\tgoto errout_locked;\n\t}\n\tif (family == &genl_ctrl) {\n\t\tstart = end = GENL_ID_CTRL;\n\t} else if (strcmp(family->name, \"pmcraid\") == 0) {\n\t\tstart = end = GENL_ID_PMCRAID;\n\t} else if (strcmp(family->name, \"VFS_DQUOT\") == 0) {\n\t\tstart = end = GENL_ID_VFS_DQUOT;\n\t}\n\tif (family->maxattr && !family->parallel_ops) {\n\t\tfamily->attrbuf = kmalloc_array(family->maxattr + 1,\n\t\t\t\t\t\tsizeof(struct nlattr *),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (family->attrbuf == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto errout_locked;\n\t\t}\n\t} else\n\t\tfamily->attrbuf = NULL;\n\tfamily->id = idr_alloc(&genl_fam_idr, family,\n\t\t\t       start, end + 1, GFP_KERNEL);\n\tif (family->id < 0) {\n\t\terr = family->id;\n\t\tgoto errout_locked;\n\t}\n\terr = genl_validate_assign_mc_groups(family);\n\tif (err)\n\t\tgoto errout_remove;\n\tgenl_unlock_all();\n\tgenl_ctrl_event(CTRL_CMD_NEWFAMILY, family, NULL, 0);\n\tfor (i = 0; i < family->n_mcgrps; i++)\n\t\tgenl_ctrl_event(CTRL_CMD_NEWMCAST_GRP, family,\n\t\t\t\t&family->mcgrps[i], family->mcgrp_offset + i);\n\treturn 0;\nerrout_remove:\n\tidr_remove(&genl_fam_idr, family->id);\n\tkfree(family->attrbuf);\nerrout_locked:\n\tgenl_unlock_all();\n\treturn err;\n}", "target": 1}
{"code": "static int pptp_getname(struct socket *sock, struct sockaddr *uaddr,\n\tint *usockaddr_len, int peer)\n{\n\tint len = sizeof(struct sockaddr_pppox);\n\tstruct sockaddr_pppox sp;\n\tmemset(&sp.sa_addr, 0, sizeof(sp.sa_addr));\n\tsp.sa_family    = AF_PPPOX;\n\tsp.sa_protocol  = PX_PROTO_PPTP;\n\tsp.sa_addr.pptp = pppox_sk(sock->sk)->proto.pptp.src_addr;\n\tmemcpy(uaddr, &sp, len);\n\t*usockaddr_len = len;\n\treturn 0;\n}", "target": 0}
{"code": "cd_device_db_set_property (CdDeviceDb *ddb,\n\t\t\t   const gchar *device_id,\n\t\t\t   const gchar *property,\n\t\t\t   const gchar *value,\n\t\t\t   GError  **error)\n{\n\tCdDeviceDbPrivate *priv = GET_PRIVATE (ddb);\n\tgboolean ret = TRUE;\n\tgchar *error_msg = NULL;\n\tgchar *statement;\n\tgint rc;\n\tg_return_val_if_fail (CD_IS_DEVICE_DB (ddb), FALSE);\n\tg_return_val_if_fail (priv->db != NULL, FALSE);\n\tg_debug (\"CdDeviceDb: add device property %s [%s=%s]\",\n\t\t device_id, property, value);\n\tstatement = sqlite3_mprintf (\"INSERT OR REPLACE INTO properties_v2 (device_id, property, value) \"\n\t\t\t\t     \"VALUES ('%q', '%q', '%q');\",\n\t\t\t\t     device_id, property, value);\n\trc = sqlite3_exec (priv->db, statement, NULL, NULL, &error_msg);\n\tif (rc != SQLITE_OK) {\n\t\tg_set_error (error,\n\t\t\t     CD_CLIENT_ERROR,\n\t\t\t     CD_CLIENT_ERROR_INTERNAL,\n\t\t\t     \"SQL error: %s\",\n\t\t\t     error_msg);\n\t\tsqlite3_free (error_msg);\n\t\tret = FALSE;\n\t\tgoto out;\n\t}\nout:\n\tsqlite3_free (statement);\n\treturn ret;\n}", "target": 0}
{"code": "void ext4_superblock_csum_set(struct super_block *sb,\n\t\t\t      struct ext4_super_block *es)\n{\n\tif (!EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\tEXT4_FEATURE_RO_COMPAT_METADATA_CSUM))\n\t\treturn;\n\tes->s_checksum = ext4_superblock_csum(sb, es);\n}", "target": 0}
{"code": "create_worker_threads(uint n)\n{\n\tcomp_thread_ctxt_t\t*threads;\n\tuint \t\t\ti;\n\tthreads = (comp_thread_ctxt_t *)\n\t\tmy_malloc(sizeof(comp_thread_ctxt_t) * n, MYF(MY_FAE));\n\tfor (i = 0; i < n; i++) {\n\t\tcomp_thread_ctxt_t *thd = threads + i;\n\t\tthd->num = i + 1;\n\t\tthd->started = FALSE;\n\t\tthd->cancelled = FALSE;\n\t\tthd->data_avail = FALSE;\n\t\tthd->to = (char *) my_malloc(COMPRESS_CHUNK_SIZE +\n\t\t\t\t\t\t   MY_QLZ_COMPRESS_OVERHEAD,\n\t\t\t\t\t\t   MYF(MY_FAE));\n\t\tif (pthread_mutex_init(&thd->ctrl_mutex, NULL) ||\n\t\t    pthread_cond_init(&thd->ctrl_cond, NULL)) {\n\t\t\tgoto err;\n\t\t}\n\t\tif (pthread_mutex_init(&thd->data_mutex, NULL) ||\n\t\t    pthread_cond_init(&thd->data_cond, NULL)) {\n\t\t\tgoto err;\n\t\t}\n\t\tpthread_mutex_lock(&thd->ctrl_mutex);\n\t\tif (pthread_create(&thd->id, NULL, compress_worker_thread_func,\n\t\t\t\t   thd)) {\n\t\t\tmsg(\"compress: pthread_create() failed: \"\n\t\t\t    \"errno = %d\", errno);\n\t\t\tpthread_mutex_unlock(&thd->ctrl_mutex);\n\t\t\tgoto err;\n\t\t}\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tcomp_thread_ctxt_t *thd = threads + i;\n\t\twhile (thd->started == FALSE)\n\t\t\tpthread_cond_wait(&thd->ctrl_cond, &thd->ctrl_mutex);\n\t\tpthread_mutex_unlock(&thd->ctrl_mutex);\n\t}\n\treturn threads;\nerr:\n\tmy_free(threads);\n\treturn NULL;\n}", "target": 1}
{"code": "static int transfer_size(int ssize, int max_sector, int max_size)\n{\n\tSUPBOUND(max_sector, fsector_t + max_size);\n\tmax_sector -= (max_sector % _floppy->sect) % ssize;\n\tcurrent_count_sectors = max_sector - fsector_t;\n\treturn max_sector;\n}", "target": 0}
{"code": "static void _ewk_view_smart_changed(Ewk_View_Smart_Data* smartData)\n{\n    if (smartData->changed.any)\n        return;\n    smartData->changed.any = true;\n    evas_object_smart_changed(smartData->self);\n}", "target": 0}
{"code": "static void ax25_kill_by_device(struct net_device *dev)\n{\n\tax25_dev *ax25_dev;\n\tax25_cb *s;\n\tstruct sock *sk;\n\tif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\n\t\treturn;\n\tspin_lock_bh(&ax25_list_lock);\nagain:\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->ax25_dev == ax25_dev) {\n\t\t\tsk = s->sk;\n\t\t\tsock_hold(sk);\n\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\tlock_sock(sk);\n\t\t\ts->ax25_dev = NULL;\n\t\t\tax25_dev_put(ax25_dev);\n\t\t\trelease_sock(sk);\n\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\tspin_lock_bh(&ax25_list_lock);\n\t\t\tsock_put(sk);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock_bh(&ax25_list_lock);\n}", "target": 1}
{"code": "CharString *Formattable::internalGetCharString(UErrorCode &status) {\n    if(fDecimalStr == NULL) {\n      if (fDecimalQuantity == NULL) {\n        LocalPointer<DecimalQuantity> dq(new DecimalQuantity(), status);\n        if (U_FAILURE(status)) { return nullptr; }\n        populateDecimalQuantity(*dq, status);\n        if (U_FAILURE(status)) { return nullptr; }\n        fDecimalQuantity = dq.orphan();\n      }\n      fDecimalStr = new CharString();\n      if (fDecimalStr == NULL) {\n        status = U_MEMORY_ALLOCATION_ERROR;\n        return NULL;\n      }\n      if (fDecimalQuantity->isZero()) {\n        fDecimalStr->append(\"0\", -1, status);\n      } else if (std::abs(fDecimalQuantity->getMagnitude()) < 5) {\n        fDecimalStr->appendInvariantChars(fDecimalQuantity->toPlainString(), status);\n      } else {\n        fDecimalStr->appendInvariantChars(fDecimalQuantity->toScientificString(), status);\n      }\n    }\n    return fDecimalStr;\n}", "target": 1}
{"code": "ZEND_API int ZEND_FASTCALL zend_binary_strncmp(const char *s1, size_t len1, const char *s2, size_t len2, size_t length) \n{\n\tint retval;\n\tif (s1 == s2) {\n\t\treturn 0;\n\t}\n\tretval = memcmp(s1, s2, MIN(length, MIN(len1, len2)));\n\tif (!retval) {\n\t\treturn (int)(MIN(length, len1) - MIN(length, len2));\n\t} else {\n\t\treturn retval;\n\t}\n}", "target": 0}
{"code": "blockmix_salsa8(__m128i * Bin, __m128i * Bout, __m128i * X, size_t r)\n{\n  size_t i;\n  blkcpy(X, &Bin[8 * r - 4], 64);\n  for (i = 0; i < r; i++) {\n    blkxor(X, &Bin[i * 8], 64);\n    salsa20_8(X);\n    blkcpy(&Bout[i * 4], X, 64);\n    blkxor(X, &Bin[i * 8 + 4], 64);\n    salsa20_8(X);\n    blkcpy(&Bout[(r + i) * 4], X, 64);\n  }\n}", "target": 1}
{"code": "int nfs4_destroy_clientid(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred;\n\tint ret = 0;\n\tif (clp->cl_mvops->minor_version < 1)\n\t\tgoto out;\n\tif (clp->cl_exchange_flags == 0)\n\t\tgoto out;\n\tif (clp->cl_preserve_clid)\n\t\tgoto out;\n\tcred = nfs4_get_exchange_id_cred(clp);\n\tret = nfs4_proc_destroy_clientid(clp, cred);\n\tif (cred)\n\t\tput_rpccred(cred);\n\tswitch (ret) {\n\tcase 0:\n\tcase -NFS4ERR_STALE_CLIENTID:\n\t\tclp->cl_exchange_flags = 0;\n\t}\nout:\n\treturn ret;\n}", "target": 0}
{"code": "static uint8_t pfkey_proto_to_xfrm(uint8_t proto)\n{\n\treturn proto == IPSEC_PROTO_ANY ? 0 : proto;\n}", "target": 0}
{"code": "static int ftrace_function_set_regexp(struct ftrace_ops *ops, int filter,\n\t\t\t\t      int reset, char *re, int len)\n{\n\tint ret;\n\tif (filter)\n\t\tret = ftrace_set_filter(ops, re, len, reset);\n\telse\n\t\tret = ftrace_set_notrace(ops, re, len, reset);\n\treturn ret;\n}", "target": 0}
{"code": "static void *skcipher_bind(const char *name, u32 type, u32 mask)\n{\n\tstruct skcipher_tfm *tfm;\n\tstruct crypto_ablkcipher *skcipher;\n\ttfm = kzalloc(sizeof(*tfm), GFP_KERNEL);\n\tif (!tfm)\n\t\treturn ERR_PTR(-ENOMEM);\n\tskcipher = crypto_alloc_ablkcipher(name, type, mask);\n\tif (IS_ERR(skcipher)) {\n\t\tkfree(tfm);\n\t\treturn ERR_CAST(skcipher);\n\t}\n\ttfm->skcipher = skcipher;\n\treturn tfm;\n}", "target": 0}
{"code": "    void resize (std::size_t new_size_) { _buf_size = new_size_; }", "target": 1}
{"code": "static int snd_seq_ioctl_remove_events(struct snd_seq_client *client,\n\t\t\t\t       void __user *arg)\n{\n\tstruct snd_seq_remove_events info;\n\tif (copy_from_user(&info, arg, sizeof(info)))\n\t\treturn -EFAULT;\n\tif (info.remove_mode & SNDRV_SEQ_REMOVE_INPUT) {\n\t\tif (client->type == USER_CLIENT)\n\t\t\tsnd_seq_fifo_clear(client->data.user.fifo);\n\t}\n\tif (info.remove_mode & SNDRV_SEQ_REMOVE_OUTPUT)\n\t\tsnd_seq_queue_remove_cells(client->number, &info);\n\treturn 0;\n}", "target": 1}
{"code": "static int decode_fill(AACContext *ac, GetBitContext *gb, int len) {\n    uint8_t buf[256];\n    int i, major, minor;\n    if (len < 13+7*8)\n        goto unknown;\n    get_bits(gb, 13); len -= 13;\n    for(i=0; i+1<sizeof(buf) && len>=8; i++, len-=8)\n        buf[i] = get_bits(gb, 8);\n    buf[i] = 0;\n    if (ac->avctx->debug & FF_DEBUG_PICT_INFO)\n        av_log(ac->avctx, AV_LOG_DEBUG, \"FILL:%s\\n\", buf);\n    if (sscanf(buf, \"libfaac %d.%d\", &major, &minor) == 2){\n        ac->avctx->internal->skip_samples = 1024;\n    }\nunknown:\n    skip_bits_long(gb, len);\n    return 0;\n}", "target": 0}
{"code": "xmlValidGetElemDecl(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\n\t            xmlNodePtr elem, int *extsubset) {\n    xmlElementPtr elemDecl = NULL;\n    const xmlChar *prefix = NULL;\n    if ((ctxt == NULL) || (doc == NULL) ||\n        (elem == NULL) || (elem->name == NULL))\n        return(NULL);\n    if (extsubset != NULL)\n\t*extsubset = 0;\n    if ((elem->ns != NULL) && (elem->ns->prefix != NULL))\n\tprefix = elem->ns->prefix;\n    if (prefix != NULL) {\n\telemDecl = xmlGetDtdQElementDesc(doc->intSubset,\n\t\t                         elem->name, prefix);\n\tif ((elemDecl == NULL) && (doc->extSubset != NULL)) {\n\t    elemDecl = xmlGetDtdQElementDesc(doc->extSubset,\n\t\t                             elem->name, prefix);\n\t    if ((elemDecl != NULL) && (extsubset != NULL))\n\t\t*extsubset = 1;\n\t}\n    }\n    if (elemDecl == NULL) {\n\telemDecl = xmlGetDtdElementDesc(doc->intSubset, elem->name);\n\tif ((elemDecl == NULL) && (doc->extSubset != NULL)) {\n\t    elemDecl = xmlGetDtdElementDesc(doc->extSubset, elem->name);\n\t    if ((elemDecl != NULL) && (extsubset != NULL))\n\t\t*extsubset = 1;\n\t}\n    }\n    if (elemDecl == NULL) {\n\txmlErrValidNode(ctxt, elem,\n\t\t\tXML_DTD_UNKNOWN_ELEM,\n\t       \"No declaration for element %s\\n\",\n\t       elem->name, NULL, NULL);\n    }\n    return(elemDecl);\n}", "target": 0}
{"code": "int vfs_clone_file_range(struct file *file_in, loff_t pos_in,\n\t\tstruct file *file_out, loff_t pos_out, u64 len)\n{\n\tstruct inode *inode_in = file_inode(file_in);\n\tstruct inode *inode_out = file_inode(file_out);\n\tint ret;\n\tif (inode_in->i_sb != inode_out->i_sb ||\n\t    file_in->f_path.mnt != file_out->f_path.mnt)\n\t\treturn -EXDEV;\n\tif (S_ISDIR(inode_in->i_mode) || S_ISDIR(inode_out->i_mode))\n\t\treturn -EISDIR;\n\tif (!S_ISREG(inode_in->i_mode) || !S_ISREG(inode_out->i_mode))\n\t\treturn -EINVAL;\n\tif (!(file_in->f_mode & FMODE_READ) ||\n\t    !(file_out->f_mode & FMODE_WRITE) ||\n\t    (file_out->f_flags & O_APPEND) ||\n\t    !file_in->f_op->clone_file_range)\n\t\treturn -EBADF;\n\tret = clone_verify_area(file_in, pos_in, len, false);\n\tif (ret)\n\t\treturn ret;\n\tret = clone_verify_area(file_out, pos_out, len, true);\n\tif (ret)\n\t\treturn ret;\n\tif (pos_in + len > i_size_read(inode_in))\n\t\treturn -EINVAL;\n\tret = mnt_want_write_file(file_out);\n\tif (ret)\n\t\treturn ret;\n\tret = file_in->f_op->clone_file_range(file_in, pos_in,\n\t\t\tfile_out, pos_out, len);\n\tif (!ret) {\n\t\tfsnotify_access(file_in);\n\t\tfsnotify_modify(file_out);\n\t}\n\tmnt_drop_write_file(file_out);\n\treturn ret;\n}", "target": 0}
{"code": "get_indent_str(\n    char_u\t*ptr,\n    int\t\tts,\n    int\t\tlist) \n{\n    int\t\tcount = 0;\n    for ( ; *ptr; ++ptr)\n    {\n\tif (*ptr == TAB)\n\t{\n\t    if (!list || curwin->w_lcs_chars.tab1)\n\t\tcount += ts - (count % ts);\n\t    else\n\t\tcount += ptr2cells(ptr);\n\t}\n\telse if (*ptr == ' ')\n\t    ++count;\t\t\n\telse\n\t    break;\n    }\n    return count;\n}", "target": 0}
{"code": "s64 ntfs_attr_pread(ntfs_attr *na, const s64 pos, s64 count, void *b)\n{\n\ts64 ret;\n\tif (!na || !na->ni || !na->ni->vol || !b || pos < 0 || count < 0) {\n\t\terrno = EINVAL;\n\t\tntfs_log_perror(\"%s: na=%p  b=%p  pos=%lld  count=%lld\",\n\t\t\t\t__FUNCTION__, na, b, (long long)pos,\n\t\t\t\t(long long)count);\n\t\treturn -1;\n\t}\n\tntfs_log_enter(\"Entering for inode %lld attr 0x%x pos %lld count \"\n\t\t       \"%lld\\n\", (unsigned long long)na->ni->mft_no,\n\t\t       le32_to_cpu(na->type), (long long)pos, (long long)count);\n\tret = ntfs_attr_pread_i(na, pos, count, b);\n\tntfs_log_leave(\"\\n\");\n\treturn ret;\n}", "target": 0}
{"code": "void ApplyChannelMatrix::run(const void *inputData, void *outputData, int frameCount)\n{\n\tconst T *input = reinterpret_cast<const T *>(inputData);\n\tT *output = reinterpret_cast<T *>(outputData);\n\tfor (int frame=0; frame<frameCount; frame++)\n\t{\n\t\tconst T *inputSave = input;\n\t\tconst double *m = m_matrix;\n\t\tfor (int outChannel=0; outChannel < m_outChannels; outChannel++)\n\t\t{\n\t\t\tinput = inputSave;\n\t\t\tdouble t = 0;\n\t\t\tfor (int inChannel=0; inChannel < m_inChannels; inChannel++)\n\t\t\t\tt += *input++ * *m++;\n\t\t\t*output++ = t;\n\t\t}\n\t}\n}", "target": 0}
{"code": "std::vector<std::vector<float>> DefaultColorTable(int depth) {\n  std::vector<std::vector<float>> color_table;\n  color_table.emplace_back(std::vector<float>({1, 1, 0, 1}));      \n  color_table.emplace_back(std::vector<float>({0, 0, 1, 1}));      \n  color_table.emplace_back(std::vector<float>({1, 0, 0, 1}));      \n  color_table.emplace_back(std::vector<float>({0, 1, 0, 1}));      \n  color_table.emplace_back(std::vector<float>({0.5, 0, 0.5, 1}));  \n  color_table.emplace_back(std::vector<float>({0.5, 0.5, 0, 1}));  \n  color_table.emplace_back(std::vector<float>({0.5, 0, 0, 1}));    \n  color_table.emplace_back(std::vector<float>({0, 0, 0.5, 1}));  \n  color_table.emplace_back(std::vector<float>({0, 1, 1, 1}));    \n  color_table.emplace_back(std::vector<float>({1, 0, 1, 1}));    \n  if (depth == 1) {\n    for (int64 i = 0; i < color_table.size(); i++) {\n      color_table[i][0] = 1;\n    }\n  }\n  return color_table;\n}", "target": 0}
{"code": "resolveTable (const char *tableList, const char *base)\n{\n  return (*tableResolver) (tableList, base);\n}", "target": 0}
{"code": "xfs_attr3_leaf_read_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tif ((xfs_sb_version_hascrc(&mp->m_sb) &&\n\t     !xfs_verify_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t\t\t  XFS_ATTR3_LEAF_CRC_OFF)) ||\n\t    !xfs_attr3_leaf_verify(bp)) {\n\t\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp, bp->b_addr);\n\t\txfs_buf_ioerror(bp, EFSCORRUPTED);\n\t}\n}", "target": 0}
{"code": "static PyObject *checkPassword(PyObject *self, PyObject *args)\n{\n    const char *user = NULL;\n    const char *pswd = NULL;\n    const char *service = NULL;\n    const char *default_realm = NULL;\n    int result = 0;\n    if (!PyArg_ParseTuple(args, \"ssss\", &user, &pswd, &service, &default_realm))\n        return NULL;\n    result = authenticate_user_krb5pwd(user, pswd, service, default_realm);\n    if (result)\n        return Py_INCREF(Py_True), Py_True;\n    else\n        return NULL;\n}", "target": 1}
{"code": "static int acl_parse_ver(const char **text, struct acl_pattern *pattern, int *opaque)\n{\n\tpattern->ptr.str = strdup(*text);\n\tif (!pattern->ptr.str)\n\t\treturn 0;\n\tpattern->len = strlen(*text);\n\treturn 1;\n}", "target": 0}
{"code": "calculateNumTiles (int *numTiles,\n\t\t   int numLevels,\n\t\t   int min, int max,\n\t\t   int size,\n\t\t   LevelRoundingMode rmode)\n{\n    for (int i = 0; i < numLevels; i++)\n    {\n        int l = levelSize (min, max, i, rmode);\n        if (l > std::numeric_limits<int>::max() - size + 1)\n            throw IEX_NAMESPACE::ArgExc (\"Invalid size.\");\n        numTiles[i] = (l + size - 1) / size;\n    }\n}", "target": 1}
{"code": "init_ext2_xattr(void)\n{\n\text2_xattr_cache = mb_cache_create(\"ext2_xattr\", 6);\n\tif (!ext2_xattr_cache)\n\t\treturn -ENOMEM;\n\treturn 0;\n}", "target": 1}
{"code": "canonicalize_path (const char *path, char **pcanonical)\n{\n  char *canonical = 0;\n  assert (path && *path);\n  assert (pcanonical);\n  canonical = MALLOC (char, 1+ LT_STRLEN (path));\n  if (!canonical)\n    return 1;\n  {\n    size_t dest = 0;\n    size_t src;\n    for (src = 0; path[src] != LT_EOS_CHAR; ++src)\n      {\n\tif (path[src] == LT_PATHSEP_CHAR)\n\t  {\n\t    if ((dest == 0)\n\t\t|| (path[1+ src] == LT_PATHSEP_CHAR)\n\t\t|| (path[1+ src] == LT_EOS_CHAR))\n\t      continue;\n\t  }\n\tif ((path[src] != '/')\n#if defined(LT_DIRSEP_CHAR)\n\t    && (path[src] != LT_DIRSEP_CHAR)\n#endif\n\t    )\n\t  {\n\t    canonical[dest++] = path[src];\n\t  }\n\telse if ((path[1+ src] != LT_PATHSEP_CHAR)\n\t\t && (path[1+ src] != LT_EOS_CHAR)\n#if defined(LT_DIRSEP_CHAR)\n\t\t && (path[1+ src] != LT_DIRSEP_CHAR)\n#endif\n\t\t && (path[1+ src] != '/'))\n\t  {\n\t    canonical[dest++] = '/';\n\t  }\n      }\n    canonical[dest] = LT_EOS_CHAR;\n  }\n  *pcanonical = canonical;\n  return 0;\n}", "target": 0}
{"code": "int snd_ctl_add(struct snd_card *card, struct snd_kcontrol *kcontrol)\n{\n\tstruct snd_ctl_elem_id id;\n\tunsigned int idx;\n\tunsigned int count;\n\tint err = -EINVAL;\n\tif (! kcontrol)\n\t\treturn err;\n\tif (snd_BUG_ON(!card || !kcontrol->info))\n\t\tgoto error;\n\tid = kcontrol->id;\n\tif (id.index > UINT_MAX - kcontrol->count)\n\t\tgoto error;\n\tdown_write(&card->controls_rwsem);\n\tif (snd_ctl_find_id(card, &id)) {\n\t\tup_write(&card->controls_rwsem);\n\t\tdev_err(card->dev, \"control %i:%i:%i:%s:%i is already present\\n\",\n\t\t\t\t\tid.iface,\n\t\t\t\t\tid.device,\n\t\t\t\t\tid.subdevice,\n\t\t\t\t\tid.name,\n\t\t\t\t\tid.index);\n\t\terr = -EBUSY;\n\t\tgoto error;\n\t}\n\tif (snd_ctl_find_hole(card, kcontrol->count) < 0) {\n\t\tup_write(&card->controls_rwsem);\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\tlist_add_tail(&kcontrol->list, &card->controls);\n\tcard->controls_count += kcontrol->count;\n\tkcontrol->id.numid = card->last_numid + 1;\n\tcard->last_numid += kcontrol->count;\n\tcount = kcontrol->count;\n\tup_write(&card->controls_rwsem);\n\tfor (idx = 0; idx < count; idx++, id.index++, id.numid++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_ADD, &id);\n\treturn 0;\n error:\n\tsnd_ctl_free_one(kcontrol);\n\treturn err;\n}", "target": 0}
{"code": "ds_fgetstr (FILE *f, dynamic_string *s, char eos)\n{\n  int insize;\t\t\t\n  int strsize;\t\t\t\n  int next_ch;\n  insize = 0;\n  strsize = s->ds_length;\n  next_ch = getc (f);\n  while (next_ch != eos && next_ch != EOF)\n    {\n      if (insize >= strsize - 1)\n\t{\n\t  ds_resize (s, strsize * 2 + 2);\n\t  strsize = s->ds_length;\n\t}\n      s->ds_string[insize++] = next_ch;\n      next_ch = getc (f);\n    }\n  s->ds_string[insize++] = '\\0';\n  if (insize == 1 && next_ch == EOF)\n    return NULL;\n  else\n    return s->ds_string;\n}", "target": 1}
{"code": "static void adpt_i2o_post_wait_complete(u32 context, int status)\n{\n\tstruct adpt_i2o_post_wait_data *p1 = NULL;\n\tcontext &= 0x7fff;\n\tspin_lock(&adpt_post_wait_lock);\n\tfor(p1 = adpt_post_wait_queue; p1; p1 = p1->next) {\n\t\tif(p1->id == context) {\n\t\t\tp1->status = status;\n\t\t\tspin_unlock(&adpt_post_wait_lock);\n\t\t\twake_up_interruptible(p1->wq);\n\t\t\treturn;\n\t\t}\n\t}\n\tspin_unlock(&adpt_post_wait_lock);\n\tprintk(KERN_DEBUG\"dpti: Could Not find task %d in wait queue\\n\",context);\n\tprintk(KERN_DEBUG\"      Tasks in wait queue:\\n\");\n\tfor(p1 = adpt_post_wait_queue; p1; p1 = p1->next) {\n\t\tprintk(KERN_DEBUG\"           %d\\n\",p1->id);\n\t}\n\treturn;\n}", "target": 1}
{"code": "crm_recv_tls(gnutls_session * session, size_t max_size, size_t *recv_len, int *disconnected)\n{\n    char *buf = NULL;\n    int rc = 0;\n    size_t len = 0;\n    size_t chunk_size = max_size ? max_size : 1024;\n    size_t buf_size = 0;\n    size_t read_size = 0;\n    if (session == NULL) {\n        if (disconnected) {\n            *disconnected = 1;\n        }\n        goto done;\n    }\n    buf = calloc(1, chunk_size + 1);\n    buf_size = chunk_size;\n    while (TRUE) {\n        read_size = buf_size - len;\n        if (!max_size && (read_size < (chunk_size / 2))) {\n            buf_size += chunk_size;\n            crm_trace(\"Grow buffer by %d more bytes. buf is now %d bytes\", (int)chunk_size, buf_size);\n            buf = realloc(buf, buf_size + 1);\n            CRM_ASSERT(buf != NULL);\n            read_size = buf_size - len;\n        }\n        rc = gnutls_record_recv(*session, buf + len, read_size);\n        if (rc > 0) {\n            crm_trace(\"Got %d more bytes.\", rc);\n            len += rc;\n            buf[len] = '\\0';\n        }\n        if (max_size && (max_size == read_size)) {\n            crm_trace(\"Buffer max read size %d met\" , max_size);\n            goto done;\n        }\n        if (rc == GNUTLS_E_INTERRUPTED) {\n            crm_trace(\"EINTR encoutered, retry tls read\");\n        } else if (rc == GNUTLS_E_AGAIN) {\n            crm_trace(\"non-blocking, exiting read on rc = %d\", rc);\n            goto done;\n        } else if (rc <= 0) {\n            if (rc == 0) {\n                crm_debug(\"EOF encoutered during TLS read\");\n            } else {\n                crm_debug(\"Error receiving message: %s (%d)\", gnutls_strerror(rc), rc);\n            }\n            if (disconnected) {\n                *disconnected = 1;\n            }\n            goto done;\n        }\n    }\ndone:\n    if (recv_len) {\n        *recv_len = len;\n    }\n    if (!len) {\n        free(buf);\n        buf = NULL;\n    }\n    return buf;\n}", "target": 0}
{"code": "void __init psi_init(void)\n{\n\tif (!psi_enable) {\n\t\tstatic_branch_enable(&psi_disabled);\n\t\treturn;\n\t}\n\tpsi_period = jiffies_to_nsecs(PSI_FREQ);\n\tgroup_init(&psi_system);\n}", "target": 0}
{"code": "static int mount_autodev(const char *name, const struct lxc_rootfs *rootfs, const char *lxcpath)\n{\n\tint ret;\n\tsize_t clen;\n\tchar *path;\n\tINFO(\"Mounting container /dev\");\n\tclen = (rootfs->path ? strlen(rootfs->mount) : 0) + 9;\n\tpath = alloca(clen);\n\tret = snprintf(path, clen, \"%s/dev\", rootfs->path ? rootfs->mount : \"\");\n\tif (ret < 0 || ret >= clen)\n\t\treturn -1;\n\tif (!dir_exists(path)) {\n\t\tWARN(\"No /dev in container.\");\n\t\tWARN(\"Proceeding without autodev setup\");\n\t\treturn 0;\n\t}\n\tif (mount(\"none\", path, \"tmpfs\", 0, \"size=100000,mode=755\")) {\n\t\tSYSERROR(\"Failed mounting tmpfs onto %s\\n\", path);\n\t\treturn false;\n\t}\n\tINFO(\"Mounted tmpfs onto %s\",  path);\n\tret = snprintf(path, clen, \"%s/dev/pts\", rootfs->path ? rootfs->mount : \"\");\n\tif (ret < 0 || ret >= clen)\n\t\treturn -1;\n\tif (!dir_exists(path)) {\n\t\tret = mkdir(path, S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);\n\t\tif (ret) {\n\t\t\tSYSERROR(\"Failed to create /dev/pts in container\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\tINFO(\"Mounted container /dev\");\n\treturn 0;\n}", "target": 1}
{"code": "  void connectErr(const AsyncSocketException& ex) noexcept override {\n    FAIL() << ex.what();\n  }", "target": 0}
{"code": "void ewk_view_paint_context_paint_contents(Ewk_View_Paint_Context* context, const Eina_Rectangle* area)\n{\n    EINA_SAFETY_ON_NULL_RETURN(context);\n    EINA_SAFETY_ON_NULL_RETURN(area);\n    WebCore::IntRect rect(area->x, area->y, area->w, area->h);\n    if (context->view->isTransparent())\n        context->graphicContext->clearRect(rect);\n    context->view->paintContents(context->graphicContext, rect);\n}", "target": 0}
{"code": "static int orinoco_ioctl_set_auth(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\thermes_t *hw = &priv->hw;\n\tstruct iw_param *param = &wrqu->param;\n\tunsigned long flags;\n\tint ret = -EINPROGRESS;\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\tswitch (param->flags & IW_AUTH_INDEX) {\n\tcase IW_AUTH_WPA_VERSION:\n\tcase IW_AUTH_CIPHER_PAIRWISE:\n\tcase IW_AUTH_CIPHER_GROUP:\n\tcase IW_AUTH_RX_UNENCRYPTED_EAPOL:\n\tcase IW_AUTH_PRIVACY_INVOKED:\n\tcase IW_AUTH_DROP_UNENCRYPTED:\n\t\tbreak;\n\tcase IW_AUTH_KEY_MGMT:\n\t\tpriv->key_mgmt = param->value;\n\t\tbreak;\n\tcase IW_AUTH_TKIP_COUNTERMEASURES:\n\t\tif (param->value) {\n\t\t\tpriv->tkip_cm_active = 1;\n\t\t\tret = hermes_enable_port(hw, 0);\n\t\t} else {\n\t\t\tpriv->tkip_cm_active = 0;\n\t\t\tret = hermes_disable_port(hw, 0);\n\t\t}\n\t\tbreak;\n\tcase IW_AUTH_80211_AUTH_ALG:\n\t\tif (param->value & IW_AUTH_ALG_SHARED_KEY)\n\t\t\tpriv->wep_restrict = 1;\n\t\telse if (param->value & IW_AUTH_ALG_OPEN_SYSTEM)\n\t\t\tpriv->wep_restrict = 0;\n\t\telse\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\tcase IW_AUTH_WPA_ENABLED:\n\t\tif (priv->has_wpa) {\n\t\t\tpriv->wpa_enabled = param->value ? 1 : 0;\n\t\t} else {\n\t\t\tif (param->value)\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\tpriv->wpa_enabled = 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t}\n\torinoco_unlock(priv, &flags);\n\treturn ret;\n}", "target": 1}
{"code": "static int selinux_netlink_send(struct sock *sk, struct sk_buff *skb)\n{\n\tint err = 0;\n\tu32 perm;\n\tstruct nlmsghdr *nlh;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tif (skb->len < NLMSG_HDRLEN) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\tnlh = nlmsg_hdr(skb);\n\terr = selinux_nlmsg_lookup(sksec->sclass, nlh->nlmsg_type, &perm);\n\tif (err) {\n\t\tif (err == -EINVAL) {\n\t\t\tpr_warn_ratelimited(\"SELinux: unrecognized netlink\"\n\t\t\t       \" message: protocol=%hu nlmsg_type=%hu sclass=%s\"\n\t\t\t       \" pid=%d comm=%s\\n\",\n\t\t\t       sk->sk_protocol, nlh->nlmsg_type,\n\t\t\t       secclass_map[sksec->sclass - 1].name,\n\t\t\t       task_pid_nr(current), current->comm);\n\t\t\tif (!enforcing_enabled(&selinux_state) ||\n\t\t\t    security_get_allow_unknown(&selinux_state))\n\t\t\t\terr = 0;\n\t\t}\n\t\tif (err == -ENOENT)\n\t\t\terr = 0;\n\t\tgoto out;\n\t}\n\terr = sock_has_perm(sk, perm);\nout:\n\treturn err;\n}", "target": 1}
{"code": "int HeaderMapWrapper::luaGet(lua_State* state) {\n  const char* key = luaL_checkstring(state, 2);\n  const auto value =\n      Http::HeaderUtility::getAllOfHeaderAsString(headers_, Http::LowerCaseString(key));\n  if (value.result().has_value()) {\n    lua_pushlstring(state, value.result().value().data(), value.result().value().length());\n    return 1;\n  } else {\n    return 0;\n  }\n}", "target": 0}
{"code": " NativeBrowserFrame* NativeBrowserFrame::CreateNativeBrowserFrame(\n     BrowserFrame* browser_frame,\n     BrowserView* browser_view) {\n  if (views::Widget::IsPureViews())\n     return new BrowserFrameViews(browser_frame, browser_view);\n   return new BrowserFrameGtk(browser_frame, browser_view);\n }", "target": 1}
{"code": "static int __init xfrm6_tunnel_spi_init(void)\n{\n\txfrm6_tunnel_spi_kmem = kmem_cache_create(\"xfrm6_tunnel_spi\",\n\t\t\t\t\t\t  sizeof(struct xfrm6_tunnel_spi),\n\t\t\t\t\t\t  0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t\t  NULL);\n\tif (!xfrm6_tunnel_spi_kmem)\n\t\treturn -ENOMEM;\n\treturn 0;\n}", "target": 1}
{"code": "coolkey_v1_get_attribute_record_len(const u8 *attr, size_t buf_len)\n{\n\tsize_t attribute_len = sizeof(coolkey_attribute_header_t);\n\tsize_t len = 0;\n\tint r;\n\tr = coolkey_v1_get_attribute_len(attr, buf_len, &len, 1);\n\tif (r < 0) {\n\t\treturn buf_len; \n\t}\n\treturn MIN(buf_len,attribute_len+len);\n}", "target": 0}
{"code": "static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)\n{\n\tgit_pkt *pkt;\n\tconst char *line, *line_end;\n\tsize_t line_len;\n\tint error;\n\tint reading_from_buf = data_pkt_buf->size > 0;\n\tif (reading_from_buf) {\n\t\tgit_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);\n\t\tline = data_pkt_buf->ptr;\n\t\tline_len = data_pkt_buf->size;\n\t}\n\telse {\n\t\tline = data_pkt->data;\n\t\tline_len = data_pkt->len;\n\t}\n\twhile (line_len > 0) {\n\t\terror = git_pkt_parse_line(&pkt, line, &line_end, line_len);\n\t\tif (error == GIT_EBUFS) {\n\t\t\tif (!reading_from_buf)\n\t\t\t\tgit_buf_put(data_pkt_buf, line, line_len);\n\t\t\terror = 0;\n\t\t\tgoto done;\n\t\t}\n\t\telse if (error < 0)\n\t\t\tgoto done;\n\t\tline_len -= (line_end - line);\n\t\tline = line_end;\n\t\tif (pkt == NULL)\n\t\t\tcontinue;\n\t\terror = add_push_report_pkt(push, pkt);\n\t\tgit_pkt_free(pkt);\n\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\tgoto done;\n\t}\n\terror = 0;\ndone:\n\tif (reading_from_buf)\n\t\tgit_buf_consume(data_pkt_buf, line_end);\n\treturn error;\n}", "target": 1}
{"code": "static CubeInfo *GetCubeInfo(const QuantizeInfo *quantize_info,\n  const size_t depth,const size_t maximum_colors)\n{\n  CubeInfo\n    *cube_info;\n  double\n    sum,\n    weight;\n  register ssize_t\n    i;\n  size_t\n    length;\n  cube_info=(CubeInfo *) AcquireMagickMemory(sizeof(*cube_info));\n  if (cube_info == (CubeInfo *) NULL)\n    return((CubeInfo *) NULL);\n  (void) memset(cube_info,0,sizeof(*cube_info));\n  cube_info->depth=depth;\n  if (cube_info->depth > MaxTreeDepth)\n    cube_info->depth=MaxTreeDepth;\n  if (cube_info->depth < 2)\n    cube_info->depth=2;\n  cube_info->maximum_colors=maximum_colors;\n  cube_info->root=GetNodeInfo(cube_info,0,0,(NodeInfo *) NULL);\n  if (cube_info->root == (NodeInfo *) NULL)\n    return((CubeInfo *) NULL);\n  cube_info->root->parent=cube_info->root;\n  cube_info->quantize_info=CloneQuantizeInfo(quantize_info);\n  if (cube_info->quantize_info->dither_method == NoDitherMethod)\n    return(cube_info);\n  length=(size_t) (1UL << (4*(8-CacheShift)));\n  cube_info->memory_info=AcquireVirtualMemory(length,sizeof(*cube_info->cache));\n  if (cube_info->memory_info == (MemoryInfo *) NULL)\n    return((CubeInfo *) NULL);\n  cube_info->cache=(ssize_t *) GetVirtualMemoryBlob(cube_info->memory_info);\n  (void) memset(cube_info->cache,(-1),sizeof(*cube_info->cache)*\n    length);\n  weight=1.0;\n  for (i=0; i < ErrorQueueLength; i++)\n  {\n    cube_info->weights[ErrorQueueLength-i-1]=PerceptibleReciprocal(weight);\n    weight*=exp(log(((double) QuantumRange+1.0))/(ErrorQueueLength-1.0));\n  }\n  weight=0.0;\n  for (i=0; i < ErrorQueueLength; i++)\n    weight+=cube_info->weights[i];\n  sum=0.0;\n  for (i=0; i < ErrorQueueLength; i++)\n  {\n    cube_info->weights[i]/=weight;\n    sum+=cube_info->weights[i];\n  }\n  cube_info->weights[0]+=1.0-sum;\n  return(cube_info);\n}", "target": 0}
{"code": "static int sctp_getsockopt_assoc_stats(struct sock *sk, int len,\n\t\t\t\t       char __user *optval,\n\t\t\t\t       int __user *optlen)\n{\n\tstruct sctp_assoc_stats sas;\n\tstruct sctp_association *asoc = NULL;\n \tif (len < sizeof(sctp_assoc_t))\n \t\treturn -EINVAL;\n \tif (copy_from_user(&sas, optval, len))\n \t\treturn -EFAULT;\n\tasoc = sctp_id2assoc(sk, sas.sas_assoc_id);\n\tif (!asoc)\n\t\treturn -EINVAL;\n\tsas.sas_rtxchunks = asoc->stats.rtxchunks;\n\tsas.sas_gapcnt = asoc->stats.gapcnt;\n\tsas.sas_outofseqtsns = asoc->stats.outofseqtsns;\n\tsas.sas_osacks = asoc->stats.osacks;\n\tsas.sas_isacks = asoc->stats.isacks;\n\tsas.sas_octrlchunks = asoc->stats.octrlchunks;\n\tsas.sas_ictrlchunks = asoc->stats.ictrlchunks;\n\tsas.sas_oodchunks = asoc->stats.oodchunks;\n\tsas.sas_iodchunks = asoc->stats.iodchunks;\n\tsas.sas_ouodchunks = asoc->stats.ouodchunks;\n\tsas.sas_iuodchunks = asoc->stats.iuodchunks;\n\tsas.sas_idupchunks = asoc->stats.idupchunks;\n\tsas.sas_opackets = asoc->stats.opackets;\n\tsas.sas_ipackets = asoc->stats.ipackets;\n\tsas.sas_maxrto = asoc->stats.max_obs_rto;\n\tmemcpy(&sas.sas_obs_rto_ipaddr, &asoc->stats.obs_rto_ipaddr,\n\t\tsizeof(struct sockaddr_storage));\n \tasoc->stats.max_obs_rto = asoc->rto_min;\n\tlen = min_t(size_t, len, sizeof(sas));\n \tif (put_user(len, optlen))\n \t\treturn -EFAULT;\n\tSCTP_DEBUG_PRINTK(\"sctp_getsockopt_assoc_stat(%d): %d\\n\",\n\t\t\t  len, sas.sas_assoc_id);\n\tif (copy_to_user(optval, &sas, len))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1}
{"code": "xfs_iunlink_remove(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_agi\t\t*agi;\n\tstruct xfs_buf\t\t*agibp;\n\tstruct xfs_buf\t\t*last_ibp;\n\tstruct xfs_dinode\t*last_dip = NULL;\n\txfs_agnumber_t\t\tagno = XFS_INO_TO_AGNO(mp, ip->i_ino);\n\txfs_agino_t\t\tagino = XFS_INO_TO_AGINO(mp, ip->i_ino);\n\txfs_agino_t\t\tnext_agino;\n\txfs_agino_t\t\thead_agino;\n\tshort\t\t\tbucket_index = agino % XFS_AGI_UNLINKED_BUCKETS;\n\tint\t\t\terror;\n\ttrace_xfs_iunlink_remove(ip);\n\terror = xfs_read_agi(mp, tp, agno, &agibp);\n\tif (error)\n\t\treturn error;\n\tagi = agibp->b_addr;\n\thead_agino = be32_to_cpu(agi->agi_unlinked[bucket_index]);\n\tif (!xfs_verify_agino(mp, agno, head_agino)) {\n\t\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp,\n\t\t\t\tagi, sizeof(*agi));\n\t\treturn -EFSCORRUPTED;\n\t}\n\terror = xfs_iunlink_update_inode(tp, ip, agno, NULLAGINO, &next_agino);\n\tif (error)\n\t\treturn error;\n\tif (next_agino != NULLAGINO) {\n\t\terror = xfs_iunlink_change_backref(agibp->b_pag, next_agino,\n\t\t\t\tNULLAGINO);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (head_agino != agino) {\n\t\tstruct xfs_imap\timap;\n\t\txfs_agino_t\tprev_agino;\n\t\terror = xfs_iunlink_map_prev(tp, agno, head_agino, agino,\n\t\t\t\t&prev_agino, &imap, &last_dip, &last_ibp,\n\t\t\t\tagibp->b_pag);\n\t\tif (error)\n\t\t\treturn error;\n\t\txfs_iunlink_update_dinode(tp, agno, prev_agino, last_ibp,\n\t\t\t\tlast_dip, &imap, next_agino);\n\t\treturn xfs_iunlink_change_backref(agibp->b_pag, agino,\n\t\t\t\tnext_agino);\n\t}\n\treturn xfs_iunlink_update_bucket(tp, agno, agibp, bucket_index,\n\t\t\tnext_agino);\n}", "target": 0}
{"code": "parse_table(\n\tstruct buf *ob,\n\tstruct sd_markdown *rndr,\n\tuint8_t *data,\n\tsize_t size)\n{\n\tsize_t i;\n\tstruct buf *header_work = 0;\n\tstruct buf *body_work = 0;\n\tsize_t columns;\n\tint *col_data = NULL;\n\theader_work = rndr_newbuf(rndr, BUFFER_SPAN);\n\tbody_work = rndr_newbuf(rndr, BUFFER_BLOCK);\n\ti = parse_table_header(header_work, rndr, data, size, &columns, &col_data);\n\tif (i > 0) {\n\t\twhile (i < size) {\n\t\t\tsize_t row_start;\n\t\t\tint pipes = 0;\n\t\t\trow_start = i;\n\t\t\twhile (i < size && data[i] != '\\n')\n\t\t\t\tif (data[i++] == '|')\n\t\t\t\t\tpipes++;\n\t\t\tif (pipes == 0 || i == size) {\n\t\t\t\ti = row_start;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tparse_table_row(\n\t\t\t\tbody_work,\n\t\t\t\trndr,\n\t\t\t\tdata + row_start,\n\t\t\t\ti - row_start,\n\t\t\t\tcolumns,\n\t\t\t\tcol_data, 0\n\t\t\t);\n\t\t\ti++;\n\t\t}\n\t\tif (rndr->cb.table)\n\t\t\trndr->cb.table(ob, header_work, body_work, rndr->opaque);\n\t}\n\tfree(col_data);\n\trndr_popbuf(rndr, BUFFER_SPAN);\n\trndr_popbuf(rndr, BUFFER_BLOCK);\n\treturn i;\n}", "target": 0}
{"code": "static NO_INLINE JsVar *jspGetNamedFieldInParents(JsVar *object, const char* name, bool returnName) {\n  JsVar * child = jspeiFindChildFromStringInParents(object, name);\n  if (!child) {\n    child = jswFindBuiltInFunction(object, name);\n  }\n  if (child && returnName) {\n    if (jsvIsName(child)) {\n      JsVar *t = jsvGetValueOfName(child);\n      jsvUnLock(child);\n      child = t;\n    }\n    JsVar *nameVar = jsvNewFromString(name);\n    JsVar *newChild = jsvCreateNewChild(object, nameVar, child);\n    jsvUnLock2(nameVar, child);\n    child = newChild;\n  }\n  if (!child) {\n    if (jsvIsFunction(object) && strcmp(name, JSPARSE_PROTOTYPE_VAR)==0) {\n      JsVar *proto = jsvNewObject();\n      jsvObjectSetChild(proto, JSPARSE_CONSTRUCTOR_VAR, object);\n      child = jsvAddNamedChild(object, proto, JSPARSE_PROTOTYPE_VAR);\n      jspEnsureIsPrototype(object, child);\n      jsvUnLock(proto);\n    } else if (strcmp(name, JSPARSE_INHERITS_VAR)==0) {\n      const char *objName = jswGetBasicObjectName(object);\n      if (objName) {\n        child = jspNewPrototype(objName);\n      }\n    }\n  }\n  return child;\n}", "target": 1}
{"code": "static int pf_detect(void)\n{\n\tstruct pf_unit *pf = units;\n\tint k, unit;\n\tprintk(\"%s: %s version %s, major %d, cluster %d, nice %d\\n\",\n\t       name, name, PF_VERSION, major, cluster, nice);\n\tpar_drv = pi_register_driver(name);\n\tif (!par_drv) {\n\t\tpr_err(\"failed to register %s driver\\n\", name);\n\t\treturn -1;\n\t}\n\tk = 0;\n\tif (pf_drive_count == 0) {\n\t\tif (pi_init(pf->pi, 1, -1, -1, -1, -1, -1, pf_scratch, PI_PF,\n\t\t\t    verbose, pf->name)) {\n\t\t\tif (!pf_probe(pf) && pf->disk) {\n\t\t\t\tpf->present = 1;\n\t\t\t\tk++;\n\t\t\t} else\n\t\t\t\tpi_release(pf->pi);\n\t\t}\n\t} else\n\t\tfor (unit = 0; unit < PF_UNITS; unit++, pf++) {\n\t\t\tint *conf = *drives[unit];\n\t\t\tif (!conf[D_PRT])\n\t\t\t\tcontinue;\n\t\t\tif (pi_init(pf->pi, 0, conf[D_PRT], conf[D_MOD],\n\t\t\t\t    conf[D_UNI], conf[D_PRO], conf[D_DLY],\n\t\t\t\t    pf_scratch, PI_PF, verbose, pf->name)) {\n\t\t\t\tif (pf->disk && !pf_probe(pf)) {\n\t\t\t\t\tpf->present = 1;\n\t\t\t\t\tk++;\n\t\t\t\t} else\n\t\t\t\t\tpi_release(pf->pi);\n\t\t\t}\n\t\t}\n\tif (k)\n\t\treturn 0;\n\tprintk(\"%s: No ATAPI disk detected\\n\", name);\n\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n\t\tif (!pf->disk)\n\t\t\tcontinue;\n\t\tblk_cleanup_queue(pf->disk->queue);\n\t\tpf->disk->queue = NULL;\n\t\tblk_mq_free_tag_set(&pf->tag_set);\n\t\tput_disk(pf->disk);\n\t}\n\tpi_unregister_driver(par_drv);\n\treturn -1;\n}", "target": 0}
{"code": "int __usb_get_extra_descriptor(char *buffer, unsigned size,\n\t\t\t       unsigned char type, void **ptr)\n{\n\tstruct usb_descriptor_header *header;\n\twhile (size >= sizeof(struct usb_descriptor_header)) {\n\t\theader = (struct usb_descriptor_header *)buffer;\n\t\tif (header->bLength < 2) {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"%s: bogus descriptor, type %d length %d\\n\",\n\t\t\t\tusbcore_name,\n\t\t\t\theader->bDescriptorType,\n\t\t\t\theader->bLength);\n\t\t\treturn -1;\n\t\t}\n\t\tif (header->bDescriptorType == type) {\n\t\t\t*ptr = header;\n\t\t\treturn 0;\n\t\t}\n\t\tbuffer += header->bLength;\n\t\tsize -= header->bLength;\n\t}\n\treturn -1;\n}", "target": 1}
{"code": "static size_t curl_read_cb(void *ptr, size_t size, size_t nmemb, void *opaque)\n{\n    CURLState *s = ((CURLState*)opaque);\n    size_t realsize = size * nmemb;\n    int i;\n    DPRINTF(\"CURL: Just reading %zd bytes\\n\", realsize);\n    if (!s || !s->orig_buf)\n        goto read_end;\n    memcpy(s->orig_buf + s->buf_off, ptr, realsize);\n    s->buf_off += realsize;\n    for(i=0; i<CURL_NUM_ACB; i++) {\n        CURLAIOCB *acb = s->acb[i];\n        if (!acb)\n            continue;\n        if ((s->buf_off >= acb->end)) {\n            qemu_iovec_from_buf(acb->qiov, 0, s->orig_buf + acb->start,\n                                acb->end - acb->start);\n            acb->common.cb(acb->common.opaque, 0);\n            qemu_aio_release(acb);\n            s->acb[i] = NULL;\n        }\n    }\nread_end:\n    return realsize;\n}", "target": 1}
{"code": "static int handle_vmread(struct kvm_vcpu *vcpu)\n{\n\tunsigned long field;\n\tu64 field_value;\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tu32 vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\tgva_t gva = 0;\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\tif (!nested_vmx_check_vmcs12(vcpu))\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\tfield = kvm_register_readl(vcpu, (((vmx_instruction_info) >> 28) & 0xf));\n\tif (vmcs12_read_any(vcpu, field, &field_value) < 0) {\n\t\tnested_vmx_failValid(vcpu, VMXERR_UNSUPPORTED_VMCS_COMPONENT);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\tif (vmx_instruction_info & (1u << 10)) {\n\t\tkvm_register_writel(vcpu, (((vmx_instruction_info) >> 3) & 0xf),\n\t\t\tfield_value);\n\t} else {\n\t\tif (get_vmx_mem_address(vcpu, exit_qualification,\n\t\t\t\tvmx_instruction_info, true, &gva))\n\t\t\treturn 1;\n\t\tkvm_write_guest_virt_system(&vcpu->arch.emulate_ctxt, gva,\n\t\t\t     &field_value, (is_long_mode(vcpu) ? 8 : 4), NULL);\n\t}\n\tnested_vmx_succeed(vcpu);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}", "target": 1}
{"code": "vhost_scsi_send_evt(struct vhost_scsi *vs,\n\t\t   struct vhost_scsi_tpg *tpg,\n\t\t   struct se_lun *lun,\n\t\t   u32 event,\n\t\t   u32 reason)\n{\n\tstruct vhost_scsi_evt *evt;\n\tevt = vhost_scsi_allocate_evt(vs, event, reason);\n\tif (!evt)\n\t\treturn;\n\tif (tpg && lun) {\n\t\tevt->event.lun[0] = 0x01;\n\t\tevt->event.lun[1] = tpg->tport_tpgt & 0xFF;\n\t\tif (lun->unpacked_lun >= 256)\n\t\t\tevt->event.lun[2] = lun->unpacked_lun >> 8 | 0x40 ;\n\t\tevt->event.lun[3] = lun->unpacked_lun & 0xFF;\n\t}\n\tllist_add(&evt->list, &vs->vs_event_list);\n\tvhost_work_queue(&vs->dev, &vs->vs_event_work);\n}", "target": 1}
{"code": "static int stv06xx_isoc_init(struct gspca_dev *gspca_dev)\n{\n\tstruct usb_host_interface *alt;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\talt = &gspca_dev->dev->actconfig->intf_cache[0]->altsetting[1];\n\talt->endpoint[0].desc.wMaxPacketSize =\n\t\tcpu_to_le16(sd->sensor->max_packet_size[gspca_dev->curr_mode]);\n\treturn 0;\n}", "target": 1}
{"code": "yang_read_deviate_units(struct ly_ctx *ctx, struct lys_deviate *deviate, struct lys_node *dev_target)\n{\n    const char **stritem;\n    int j;\n    if (dev_target->nodetype == LYS_LEAFLIST) {\n        stritem = &((struct lys_node_leaflist *)dev_target)->units;\n    } else if (dev_target->nodetype == LYS_LEAF) {\n        stritem = &((struct lys_node_leaf *)dev_target)->units;\n    } else {\n        LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"units\");\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Target node does not allow \\\"units\\\" property.\");\n        goto error;\n    }\n    if (deviate->mod == LY_DEVIATE_DEL) {\n        if (!ly_strequal(*stritem, deviate->units, 1)) {\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, deviate->units, \"units\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Value differs from the target being deleted.\");\n            goto error;\n        }\n        lydict_remove(ctx, *stritem);\n        *stritem = NULL;\n        j = -1;\n        while ((j = lys_ext_iter(dev_target->ext, dev_target->ext_size, j + 1, LYEXT_SUBSTMT_UNITS)) != -1) {\n            lyp_ext_instance_rm(ctx, &dev_target->ext, &dev_target->ext_size, j);\n            --j;\n        }\n    } else {\n        if (deviate->mod == LY_DEVIATE_ADD) {\n            if (*stritem) {\n                LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"units\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Adding property that already exists.\");\n                goto error;\n            }\n        } else { \n            if (!*stritem) {\n                LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"units\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Replacing a property that does not exist.\");\n                goto error;\n            }\n        }\n        lydict_remove(ctx, *stritem);\n        *stritem = lydict_insert(ctx, deviate->units, 0);\n    }\n    return EXIT_SUCCESS;\nerror:\n    return EXIT_FAILURE;\n}", "target": 0}
{"code": "bool VBRISeeker::getOffsetForTime(int64_t *timeUs, off64_t *pos) {\n if (mDurationUs < 0 || mSegments.size() == 0) {\n return false;\n }\n int64_t segmentDurationUs = mDurationUs / mSegments.size();\n int64_t nowUs = 0;\n *pos = mBasePos;\n size_t segmentIndex = 0;\n while (segmentIndex < mSegments.size() && nowUs < *timeUs) {\n        nowUs += segmentDurationUs;\n *pos += mSegments.itemAt(segmentIndex++);\n }\n    ALOGV(\"getOffsetForTime %lld us => 0x%016llx\", (long long)*timeUs, (long long)*pos);\n *timeUs = nowUs;\n return true;\n}", "target": 0}
{"code": "copy_creds_except(krb5_context context, krb5_ccache incc,\n                  krb5_ccache outcc, krb5_principal princ)\n{\n    krb5_error_code ret, ret2;\n    krb5_cc_cursor cur;\n    krb5_creds creds;\n    ret = krb5_cc_set_flags(context, incc, 0);\n    if (ret)\n        return ret;\n    ret = krb5_cc_start_seq_get(context, incc, &cur);\n    if (ret)\n        goto cleanup;\n    while (!(ret = krb5_cc_next_cred(context, incc, &cur, &creds))) {\n        if (krb5_principal_compare(context, princ, creds.server))\n            continue;\n        ret = krb5_cc_store_cred(context, outcc, &creds);\n        krb5_free_cred_contents(context, &creds);\n        if (ret)\n            goto cleanup;\n    }\n    if (ret != KRB5_CC_END)\n        goto cleanup;\n    ret = 0;\ncleanup:\n    ret2 = krb5_cc_set_flags(context, incc, KRB5_TC_OPENCLOSE);\n    return (ret == 0) ? ret2 : ret;\n}", "target": 0}
{"code": "static inline int ReadPropertyByte(const unsigned char **p,size_t *length)\n{\n  int\n    c;\n  if (*length < 1)\n    return(EOF);\n  c=(int) (*(*p)++);\n  (*length)--;\n  return(c);\n}", "target": 0}
{"code": "init_line_list(line_list *ll, gs_memory_t * mem)\n{\n    ll->memory = mem;\n    ll->active_area = 0;\n    ll->next_active = ll->local_active;\n    ll->limit = ll->next_active + MAX_LOCAL_ACTIVE;\n    ll->close_count = 0;\n    ll->y_list = 0;\n    ll->y_line = 0;\n    ll->h_list0 = ll->h_list1 = 0;\n    ll->x_head.prev = NULL;\n    ll->x_head.start.x = 0;\n    ll->x_head.start.y = 0;\n    ll->x_head.end.x = 0;\n    ll->x_head.end.y = 0;\n    INCR(fill);\n}", "target": 0}
{"code": "static INLINE BOOL update_read_brush(wStream* s, rdpBrush* brush, BYTE fieldFlags)\n{\n\tif (fieldFlags & ORDER_FIELD_01)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\t\tStream_Read_UINT8(s, brush->x);\n\t}\n\tif (fieldFlags & ORDER_FIELD_02)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\t\tStream_Read_UINT8(s, brush->y);\n\t}\n\tif (fieldFlags & ORDER_FIELD_03)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\t\tStream_Read_UINT8(s, brush->style);\n\t}\n\tif (fieldFlags & ORDER_FIELD_04)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\t\tStream_Read_UINT8(s, brush->hatch);\n\t}\n\tif (brush->style & CACHED_BRUSH)\n\t{\n\t\tbrush->index = brush->hatch;\n\t\tbrush->bpp = BMF_BPP[brush->style & 0x07];\n\t\tif (brush->bpp == 0)\n\t\t\tbrush->bpp = 1;\n\t}\n\tif (fieldFlags & ORDER_FIELD_05)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 7)\n\t\t\treturn FALSE;\n\t\tbrush->data = (BYTE*)brush->p8x8;\n\t\tStream_Read_UINT8(s, brush->data[7]);\n\t\tStream_Read_UINT8(s, brush->data[6]);\n\t\tStream_Read_UINT8(s, brush->data[5]);\n\t\tStream_Read_UINT8(s, brush->data[4]);\n\t\tStream_Read_UINT8(s, brush->data[3]);\n\t\tStream_Read_UINT8(s, brush->data[2]);\n\t\tStream_Read_UINT8(s, brush->data[1]);\n\t\tbrush->data[0] = brush->hatch;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "static void hci_sock_cmsg(struct sock *sk, struct msghdr *msg,\n\t\t\t  struct sk_buff *skb)\n{\n\t__u32 mask = hci_pi(sk)->cmsg_mask;\n\tif (mask & HCI_CMSG_DIR) {\n\t\tint incoming = bt_cb(skb)->incoming;\n\t\tput_cmsg(msg, SOL_HCI, HCI_CMSG_DIR, sizeof(incoming),\n\t\t\t &incoming);\n\t}\n\tif (mask & HCI_CMSG_TSTAMP) {\n#ifdef CONFIG_COMPAT\n\t\tstruct compat_timeval ctv;\n#endif\n\t\tstruct timeval tv;\n\t\tvoid *data;\n\t\tint len;\n\t\tskb_get_timestamp(skb, &tv);\n\t\tdata = &tv;\n\t\tlen = sizeof(tv);\n#ifdef CONFIG_COMPAT\n\t\tif (!COMPAT_USE_64BIT_TIME &&\n\t\t    (msg->msg_flags & MSG_CMSG_COMPAT)) {\n\t\t\tctv.tv_sec = tv.tv_sec;\n\t\t\tctv.tv_usec = tv.tv_usec;\n\t\t\tdata = &ctv;\n\t\t\tlen = sizeof(ctv);\n\t\t}\n#endif\n\t\tput_cmsg(msg, SOL_HCI, HCI_CMSG_TSTAMP, len, data);\n\t}\n}", "target": 0}
{"code": "static ssize_t carrier_store(struct device *dev, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t len)\n{\n\treturn netdev_store(dev, attr, buf, len, change_carrier);", "target": 0}
{"code": "static inline void CheckEventLogging()\n{\n  if (IsLinkedListEmpty(log_cache) != MagickFalse)\n    event_logging=MagickFalse;\n  else\n    {\n      LogInfo\n        *p;\n      ResetLinkedListIterator(log_cache);\n      p=(LogInfo *) GetNextValueInLinkedList(log_cache);\n      event_logging=p->event_mask != NoEvents ? MagickTrue: MagickFalse;\n    }\n}", "target": 1}
{"code": "enum ImapAuthRes imap_auth_login(struct ImapData *idata, const char *method)\n{\n  char q_user[SHORT_STRING], q_pass[SHORT_STRING];\n  char buf[STRING];\n  int rc;\n  if (mutt_bit_isset(idata->capabilities, LOGINDISABLED))\n  {\n    mutt_message(_(\"LOGIN disabled on this server.\"));\n    return IMAP_AUTH_UNAVAIL;\n  }\n  if (mutt_account_getuser(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n  if (mutt_account_getpass(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n  mutt_message(_(\"Logging in...\"));\n  imap_quote_string(q_user, sizeof(q_user), idata->conn->account.user);\n  imap_quote_string(q_pass, sizeof(q_pass), idata->conn->account.pass);\n  if (DebugLevel < IMAP_LOG_PASS)\n    mutt_debug(2, \"Sending LOGIN command for %s...\\n\", idata->conn->account.user);\n  snprintf(buf, sizeof(buf), \"LOGIN %s %s\", q_user, q_pass);\n  rc = imap_exec(idata, buf, IMAP_CMD_FAIL_OK | IMAP_CMD_PASS);\n  if (!rc)\n  {\n    mutt_clear_error(); \n    return IMAP_AUTH_SUCCESS;\n  }\n  mutt_error(_(\"Login failed.\"));\n  return IMAP_AUTH_FAILURE;\n}", "target": 1}
{"code": "int js_tointeger(js_State *J, int idx)\n{\n\treturn jsV_numbertointeger(jsV_tonumber(J, stackidx(J, idx)));\n}", "target": 0}
{"code": "void SecurityManager::notify_participant_authorized(\n        const ParticipantProxyData& participant_data)\n{\n    participant_->pdp()->notifyAboveRemoteEndpoints(participant_data);\n    EPROSIMA_LOG_INFO(SECURITY, \"Participant \" << participant_data.m_guid << \" authenticated\");\n    if (participant_->getListener() != nullptr)\n    {\n        ParticipantAuthenticationInfo info;\n        info.status = ParticipantAuthenticationInfo::AUTHORIZED_PARTICIPANT;\n        info.guid = participant_data.m_guid;\n        participant_->getListener()->onParticipantAuthentication(\n            participant_->getUserRTPSParticipant(), std::move(info));\n    }\n}", "target": 1}
{"code": "void SpeechSynthesis::voicesDidChange()\n{\n    m_voiceList.clear();\n    if (!executionContext()->activeDOMObjectsAreStopped())\n        dispatchEvent(Event::create(EventTypeNames::voiceschanged));\n}", "target": 0}
{"code": "TEE_Result crypto_acipher_alloc_dsa_public_key(struct dsa_public_key *s,\n\t\t\t\t\t       size_t key_size_bits __unused)\n{\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->g))\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tif (!bn_alloc_max(&s->p))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->q))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->y))\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(s->g);\n\tcrypto_bignum_free(s->p);\n\tcrypto_bignum_free(s->q);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "long keyctl_join_session_keyring(const char __user *_name)\n{\n\tchar *name;\n\tlong ret;\n\tname = NULL;\n\tif (_name) {\n\t\tname = strndup_user(_name, KEY_MAX_DESC_SIZE);\n\t\tif (IS_ERR(name)) {\n\t\t\tret = PTR_ERR(name);\n\t\t\tgoto error;\n\t\t}\n\t\tret = -EPERM;\n\t\tif (name[0] == '.')\n\t\t\tgoto error_name;\n\t}\n\tret = join_session_keyring(name);\nerror_name:\n\tkfree(name);\nerror:\n\treturn ret;\n}", "target": 0}
{"code": "static noinline int audit_inode_permission(struct inode *inode,\n\t\t\t\t\t   u32 perms, u32 audited, u32 denied,\n\t\t\t\t\t   int result)\n{\n\tstruct common_audit_data ad;\n\tstruct inode_security_struct *isec = selinux_inode(inode);\n\tint rc;\n\tad.type = LSM_AUDIT_DATA_INODE;\n\tad.u.inode = inode;\n\trc = slow_avc_audit(&selinux_state,\n\t\t\t    current_sid(), isec->sid, isec->sclass, perms,\n\t\t\t    audited, denied, result, &ad);\n\tif (rc)\n\t\treturn rc;\n\treturn 0;\n}", "target": 0}
{"code": "bool HTMLFormControlElement::isAutofocusable() const\n {\n    if (!fastHasAttribute(autofocusAttr))\n        return false;\n    if (hasTagName(inputTag))\n        return !toHTMLInputElement(this)->isInputTypeHidden();\n    if (hasTagName(selectTag))\n        return true;\n    if (hasTagName(keygenTag))\n        return true;\n    if (hasTagName(buttonTag))\n        return true;\n    if (hasTagName(textareaTag))\n        return true;\n     return false;\n }", "target": 1}
{"code": "return_enc_padata(krb5_context context, krb5_data *req_pkt,\n                  krb5_kdc_req *request, krb5_keyblock *reply_key,\n                  krb5_db_entry *server, krb5_enc_kdc_rep_part *reply_encpart,\n                  krb5_boolean is_referral)\n{\n    krb5_error_code code = 0;\n    assert(reply_encpart->enc_padata == NULL);\n    if (is_referral) {\n        code = return_referral_enc_padata(context, reply_encpart, server);\n        if (code)\n            return code;\n    }\n    code = kdc_handle_protected_negotiation(context, req_pkt, request, reply_key,\n                                            &reply_encpart->enc_padata);\n    if (code)\n        goto cleanup;\ncleanup:\n    return code;\n}", "target": 1}
{"code": "int ZEXPORT inflatePrime(strm, bits, value)\nz_streamp strm;\nint bits;\nint value;\n{\n    struct inflate_state FAR *state;\n    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;\n    state = (struct inflate_state FAR *)strm->state;\n    if (bits < 0) {\n        state->hold = 0;\n        state->bits = 0;\n        return Z_OK;\n    }\n    if (bits > 16 || state->bits + bits > 32) return Z_STREAM_ERROR;\n    value &= (1L << bits) - 1;\n    state->hold += (unsigned)value << state->bits;\n    state->bits += bits;\n    return Z_OK;\n}", "target": 0}
{"code": "static void print_liveness(struct bpf_verifier_env *env,\n\t\t\t   enum bpf_reg_liveness live)\n{\n\tif (live & (REG_LIVE_READ | REG_LIVE_WRITTEN | REG_LIVE_DONE))\n\t    verbose(env, \"_\");\n\tif (live & REG_LIVE_READ)\n\t\tverbose(env, \"r\");\n\tif (live & REG_LIVE_WRITTEN)\n\t\tverbose(env, \"w\");\n\tif (live & REG_LIVE_DONE)\n\t\tverbose(env, \"D\");\n}", "target": 0}
{"code": "static int i740fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tswitch (var->bits_per_pixel) {\n\tcase 8:\n\t\tvar->red.offset\t= var->green.offset = var->blue.offset = 0;\n\t\tvar->red.length\t= var->green.length = var->blue.length = 8;\n\t\tbreak;\n\tcase 16:\n\t\tswitch (var->green.length) {\n\t\tdefault:\n\t\tcase 5:\n\t\t\tvar->red.offset = 10;\n\t\t\tvar->green.offset = 5;\n\t\t\tvar->blue.offset = 0;\n\t\t\tvar->red.length\t= 5;\n\t\t\tvar->green.length = 5;\n\t\t\tvar->blue.length = 5;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tvar->red.offset = 11;\n\t\t\tvar->green.offset = 5;\n\t\t\tvar->blue.offset = 0;\n\t\t\tvar->red.length = var->blue.length = 5;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 24:\n\t\tvar->red.offset = 16;\n\t\tvar->green.offset = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->red.length\t= var->green.length = var->blue.length = 8;\n\t\tbreak;\n\tcase 32:\n\t\tvar->transp.offset = 24;\n\t\tvar->red.offset = 16;\n\t\tvar->green.offset = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->transp.length = 8;\n\t\tvar->red.length = var->green.length = var->blue.length = 8;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (var->xres > var->xres_virtual)\n\t\tvar->xres_virtual = var->xres;\n\tif (var->yres > var->yres_virtual)\n\t\tvar->yres_virtual = var->yres;\n\tif (info->monspecs.hfmax && info->monspecs.vfmax &&\n\t    info->monspecs.dclkmax && fb_validate_mode(var, info) < 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 1}
{"code": "static int __init si_domain_init(int hw)\n{\n\tint nid, ret;\n\tsi_domain = alloc_domain(DOMAIN_FLAG_STATIC_IDENTITY);\n\tif (!si_domain)\n\t\treturn -EFAULT;\n\tif (md_domain_init(si_domain, DEFAULT_DOMAIN_ADDRESS_WIDTH)) {\n\t\tdomain_exit(si_domain);\n\t\treturn -EFAULT;\n\t}\n\tpr_debug(\"Identity mapping domain allocated\\n\");\n\tif (hw)\n\t\treturn 0;\n\tfor_each_online_node(nid) {\n\t\tunsigned long start_pfn, end_pfn;\n\t\tint i;\n\t\tfor_each_mem_pfn_range(i, nid, &start_pfn, &end_pfn, NULL) {\n\t\t\tret = iommu_domain_identity_map(si_domain,\n\t\t\t\t\tPFN_PHYS(start_pfn), PFN_PHYS(end_pfn));\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void gitn_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *)s;\n\tif (ptr == NULL) return;\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tif (ptr->entries[i].name) gf_free(ptr->entries[i].name);\n\t}\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);", "target": 1}
{"code": "void sctp_association_free(struct sctp_association *asoc)\n{\n\tstruct sock *sk = asoc->base.sk;\n\tstruct sctp_transport *transport;\n\tstruct list_head *pos, *temp;\n\tint i;\n\tif (!asoc->temp) {\n\t\tlist_del(&asoc->asocs);\n\t\tif (sctp_style(sk, TCP) && sctp_sstate(sk, LISTENING))\n\t\t\tsk->sk_ack_backlog--;\n\t}\n\tasoc->base.dead = true;\n\tsctp_outq_free(&asoc->outqueue);\n\tsctp_ulpq_free(&asoc->ulpq);\n\tsctp_inq_free(&asoc->base.inqueue);\n\tsctp_tsnmap_free(&asoc->peer.tsn_map);\n\tsctp_ssnmap_free(asoc->ssnmap);\n\tsctp_bind_addr_free(&asoc->base.bind_addr);\n\tfor (i = SCTP_EVENT_TIMEOUT_NONE; i < SCTP_NUM_TIMEOUT_TYPES; ++i) {\n\t\tif (del_timer(&asoc->timers[i]))\n\t\t\tsctp_association_put(asoc);\n\t}\n\tkfree(asoc->peer.cookie);\n\tkfree(asoc->peer.peer_random);\n\tkfree(asoc->peer.peer_chunks);\n\tkfree(asoc->peer.peer_hmacs);\n\tlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {\n\t\ttransport = list_entry(pos, struct sctp_transport, transports);\n\t\tlist_del_rcu(pos);\n\t\tsctp_transport_free(transport);\n\t}\n\tasoc->peer.transport_count = 0;\n\tsctp_asconf_queue_teardown(asoc);\n\tif (asoc->asconf_addr_del_pending != NULL)\n\t\tkfree(asoc->asconf_addr_del_pending);\n\tsctp_auth_destroy_keys(&asoc->endpoint_shared_keys);\n\tsctp_auth_key_put(asoc->asoc_shared_key);\n\tsctp_association_put(asoc);\n}", "target": 1}
{"code": "SWFInput_rewind(SWFInput input)\n{\n\tSWFInput_seek(input, 0, SEEK_SET);\n}", "target": 0}
{"code": "PartitionInstallUdfChildHandles (\n  IN  EFI_DRIVER_BINDING_PROTOCOL  *This,\n  IN  EFI_HANDLE                   Handle,\n  IN  EFI_DISK_IO_PROTOCOL         *DiskIo,\n  IN  EFI_DISK_IO2_PROTOCOL        *DiskIo2,\n  IN  EFI_BLOCK_IO_PROTOCOL        *BlockIo,\n  IN  EFI_BLOCK_IO2_PROTOCOL       *BlockIo2,\n  IN  EFI_DEVICE_PATH_PROTOCOL     *DevicePath\n  )\n{\n  UINT32                       RemainderByMediaBlockSize;\n  EFI_STATUS                   Status;\n  EFI_BLOCK_IO_MEDIA           *Media;\n  EFI_PARTITION_INFO_PROTOCOL  PartitionInfo;\n  EFI_LBA                      StartingLBA;\n  EFI_LBA                      EndingLBA;\n  BOOLEAN                      ChildCreated;\n  Media = BlockIo->Media;\n  ChildCreated = FALSE;\n  DivU64x32Remainder (\n    UDF_LOGICAL_SECTOR_SIZE,   \n    Media->BlockSize,          \n    &RemainderByMediaBlockSize \n    );\n  if (RemainderByMediaBlockSize != 0) {\n    return EFI_NOT_FOUND;\n  }\n  Status = PartitionInstallElToritoChildHandles (\n             This,\n             Handle,\n             DiskIo,\n             DiskIo2,\n             BlockIo,\n             BlockIo2,\n             DevicePath\n             );\n  if (!EFI_ERROR (Status)) {\n    DEBUG ((DEBUG_INFO, \"PartitionDxe: El Torito standard found on handle 0x%p.\\n\", Handle));\n    ChildCreated = TRUE;\n  }\n  Status = FindUdfFileSystem (BlockIo, DiskIo, &StartingLBA, &EndingLBA);\n  if (EFI_ERROR (Status)) {\n    return (ChildCreated ? EFI_SUCCESS : EFI_NOT_FOUND);\n  }\n  ZeroMem (&PartitionInfo, sizeof (EFI_PARTITION_INFO_PROTOCOL));\n  PartitionInfo.Revision = EFI_PARTITION_INFO_PROTOCOL_REVISION;\n  PartitionInfo.Type = PARTITION_TYPE_OTHER;\n  Status = PartitionInstallChildHandle (\n    This,\n    Handle,\n    DiskIo,\n    DiskIo2,\n    BlockIo,\n    BlockIo2,\n    DevicePath,\n    (EFI_DEVICE_PATH_PROTOCOL *)&gUdfDevicePath,\n    &PartitionInfo,\n    StartingLBA,\n    EndingLBA,\n    Media->BlockSize,\n    NULL\n    );\n  if (EFI_ERROR (Status)) {\n    return (ChildCreated ? EFI_SUCCESS : Status);\n  }\n  return EFI_SUCCESS;\n}", "target": 0}
{"code": "CMYK_table_init (void)\n{\n\tg_mutex_lock (&Tables_Mutex);\n\tif (CMYK_Tab == NULL) {\n\t\tint    v, k, i;\n\t\tdouble k1;\n\t\tCMYK_Tab = g_new (unsigned char, 256 * 256);\n\t\ti = 0;\n\t\tfor (k = 0; k <= 255; k++) {\n\t\t\tk1 = (double) k / 255.0;\n\t\t\tfor (v = 0; v <= 255; v++)\n\t\t\t\tCMYK_Tab[i++] = (double) v * k1;\n\t\t}\n\t}\n\tg_mutex_unlock (&Tables_Mutex);\n}", "target": 0}
{"code": "bfad_im_get_stats(struct Scsi_Host *shost)\n{\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s         *bfad = im_port->bfad;\n\tstruct bfad_hal_comp fcomp;\n\tunion bfa_port_stats_u *fcstats;\n\tstruct fc_host_statistics *hstats;\n\tbfa_status_t    rc;\n\tunsigned long   flags;\n\tfcstats = kzalloc(sizeof(union bfa_port_stats_u), GFP_KERNEL);\n\tif (fcstats == NULL)\n\t\treturn NULL;\n\thstats = &bfad->link_stats;\n\tinit_completion(&fcomp.comp);\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\tmemset(hstats, 0, sizeof(struct fc_host_statistics));\n\trc = bfa_port_get_stats(BFA_FCPORT(&bfad->bfa),\n\t\t\t\tfcstats, bfad_hcb_comp, &fcomp);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\tif (rc != BFA_STATUS_OK)\n\t\treturn NULL;\n\twait_for_completion(&fcomp.comp);\n\thstats->seconds_since_last_reset = fcstats->fc.secs_reset;\n\thstats->tx_frames = fcstats->fc.tx_frames;\n\thstats->tx_words  = fcstats->fc.tx_words;\n\thstats->rx_frames = fcstats->fc.rx_frames;\n\thstats->rx_words  = fcstats->fc.rx_words;\n\thstats->lip_count = fcstats->fc.lip_count;\n\thstats->nos_count = fcstats->fc.nos_count;\n\thstats->error_frames = fcstats->fc.error_frames;\n\thstats->dumped_frames = fcstats->fc.dropped_frames;\n\thstats->link_failure_count = fcstats->fc.link_failures;\n\thstats->loss_of_sync_count = fcstats->fc.loss_of_syncs;\n\thstats->loss_of_signal_count = fcstats->fc.loss_of_signals;\n\thstats->prim_seq_protocol_err_count = fcstats->fc.primseq_errs;\n\thstats->invalid_crc_count = fcstats->fc.invalid_crcs;\n\tkfree(fcstats);\n\treturn hstats;\n}", "target": 1}
{"code": "RsaAdjustPrimeCandidate(\n\t\t\tbigNum          prime,\n\t\t\tSEED_COMPAT_LEVEL seedCompatLevel  \n\t\t\t)\n{\n    switch (seedCompatLevel) {\n    case SEED_COMPAT_LEVEL_ORIGINAL:\n        RsaAdjustPrimeCandidate_PreRev155(prime);\n        break;\n    case SEED_COMPAT_LEVEL_RSA_PRIME_ADJUST_FIX:\n        RsaAdjustPrimeCandidate_New(prime);\n        break;\n    default:\n        FAIL(FATAL_ERROR_INTERNAL);\n    }\n}", "target": 1}
{"code": "static int find_uid(struct posix_acl_state *state, struct posix_ace_state_array *a, uid_t uid)\n{\n\tint i;\n\tfor (i = 0; i < a->n; i++)\n\t\tif (a->aces[i].uid == uid)\n\t\t\treturn i;\n\ta->n++;\n\ta->aces[i].uid = uid;\n\ta->aces[i].perms.allow = state->everyone.allow;\n\ta->aces[i].perms.deny  = state->everyone.deny;\n\treturn i;\n}", "target": 0}
{"code": "static int get_filter(struct sss_certmap_ctx *ctx,\n                      struct ldap_mapping_rule *parsed_mapping_rule,\n                      struct sss_cert_content *cert_content,\n                      char **filter)\n{\n    struct ldap_mapping_rule_comp *comp;\n    char *result = NULL;\n    char *expanded = NULL;\n    int ret;\n    result = talloc_strdup(ctx, \"\");\n    if (result == NULL) {\n        return ENOMEM;\n    }\n    for (comp = parsed_mapping_rule->list; comp != NULL; comp = comp->next) {\n        if (comp->type == comp_string) {\n            result = talloc_strdup_append(result, comp->val);\n        } else if (comp->type == comp_template) {\n            ret = expand_template(ctx, comp->parsed_template, cert_content,\n                                  &expanded);\n            if (ret != 0) {\n                CM_DEBUG(ctx, \"Failed to expanded template.\");\n                goto done;\n            }\n            result = talloc_strdup_append(result, expanded);\n            talloc_free(expanded);\n            expanded = NULL;\n            if (result == NULL) {\n                ret = ENOMEM;\n                goto done;\n            }\n        } else {\n            ret = EINVAL;\n            CM_DEBUG(ctx, \"Unsupported component type.\");\n            goto done;\n        }\n    }\n    ret = 0;\ndone:\n    talloc_free(expanded);\n    if (ret == 0) {\n        *filter = result;\n    } else {\n        talloc_free(result);\n    }\n    return ret;\n}", "target": 1}
{"code": "const AtomicString& HTMLInputElement::alt() const\n{\n    return fastGetAttribute(altAttr);\n}", "target": 0}
{"code": "OverscrollControllerAndroid::~OverscrollControllerAndroid() {\n}", "target": 0}
{"code": "void Context::onDownstreamConnectionClose(PeerType peer_type) {\n  if (wasm_->onDownstreamConnectionClose_) {\n    wasm_->onDownstreamConnectionClose_(this, id_, static_cast<uint32_t>(peer_type));\n  }\n}", "target": 1}
{"code": "static void exif_process_TIFF_in_JPEG(image_info_type *ImageInfo, char *CharBuf, size_t length, size_t displacement)\n{\n\tunsigned exif_value_2a, offset_of_ifd;\n\tif (memcmp(CharBuf, \"II\", 2) == 0) {\n\t\tImageInfo->motorola_intel = 0;\n\t} else if (memcmp(CharBuf, \"MM\", 2) == 0) {\n\t\tImageInfo->motorola_intel = 1;\n\t} else {\n\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Invalid TIFF alignment marker\");\n\t\treturn;\n\t}\n\tif (length < 8) {\n\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Invalid TIFF start (1)\");\n\t\treturn;\n\t}\n\texif_value_2a = php_ifd_get16u(CharBuf+2, ImageInfo->motorola_intel);\n\toffset_of_ifd = php_ifd_get32u(CharBuf+4, ImageInfo->motorola_intel);\n\tif (exif_value_2a != 0x2a || offset_of_ifd < 0x08) {\n\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Invalid TIFF start (1)\");\n\t\treturn;\n\t}\n\tif (offset_of_ifd > length) {\n\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Invalid IFD start\");\n\t\treturn;\n\t}\n\tImageInfo->sections_found |= FOUND_IFD0;\n\texif_process_IFD_in_JPEG(ImageInfo, CharBuf+offset_of_ifd, CharBuf, length, displacement, SECTION_IFD0, 0);\n#ifdef EXIF_DEBUG\n\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Process TIFF in JPEG done\");\n#endif\n\tif (ImageInfo->FocalplaneXRes != 0) {\n\t\tImageInfo->CCDWidth = (float)(ImageInfo->ExifImageWidth * ImageInfo->FocalplaneUnits / ImageInfo->FocalplaneXRes);\n\t}\n}", "target": 0}
{"code": "filesystem_list_open_files_completed_cb (DBusGMethodInvocation *context,\n                                         Device *device,\n                                         gboolean job_was_cancelled,\n                                         int status,\n                                         const char *stderr,\n                                         const char *stdout,\n                                         gpointer user_data)\n{\n  if ((WEXITSTATUS (status) == 0 || WEXITSTATUS (status) == 1) && !job_was_cancelled)\n    {\n      GPtrArray *processes;\n      processes = g_ptr_array_new ();\n      lsof_parse (stdout, processes);\n      dbus_g_method_return (context, processes);\n      g_ptr_array_foreach (processes, (GFunc) g_value_array_free, NULL);\n      g_ptr_array_free (processes, TRUE);\n    }\n  else\n    {\n      throw_error (context,\n                   ERROR_FAILED,\n                   \"Error listing open files: lsof exited with exit code %d: %s\",\n                   WEXITSTATUS (status),\n                   stderr);\n    }\n}", "target": 0}
{"code": "struct resource_pool *dce110_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc,\n\tstruct hw_asic_id asic_id)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\tif (!pool)\n\t\treturn NULL;\n\tif (construct(num_virtual_links, dc, pool, asic_id))\n\t\treturn &pool->base;\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 1}
{"code": "void OmniboxViewWin::TrackMousePosition(MouseButton button,\n                                        const CPoint& point) {\n  if (gaining_focus_.get()) {\n    tracking_click_[button] = true;\n    click_point_[button] = point;\n  }\n}", "target": 0}
{"code": "static bool ok_jpg_read_dqt(ok_jpg_decoder *decoder) {\n    ok_jpg *jpg = decoder->jpg;\n    uint8_t buffer[2];\n    if (!ok_read(decoder, buffer, sizeof(buffer))) {\n        return false;\n    }\n    int length = readBE16(buffer) - 2;\n    while (length >= 65) {\n        uint8_t pt = ok_read_uint8(decoder);\n        int Pq = pt >> 4;\n        int Tq = pt & 0x0f;\n        if (Pq == 1) {\n            ok_jpg_error(jpg, OK_JPG_ERROR_UNSUPPORTED, \"Unsupported JPEG (16-bit q_table)\");\n            return false;\n        }\n        if (Pq != 0 || Tq > 3) {\n            ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, \"Invalid JPEG (Pq/Tq)\");\n            return false;\n        }\n        if (!ok_read(decoder, decoder->q_table[Tq], 64)) {\n            return false;\n        }\n        length -= 65;\n    }\n    if (length != 0) {\n        ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, \"Invalid DQT segment length\");\n        return false;\n    } else {\n        return true;\n    }\n}", "target": 0}
{"code": "ldbm_txn_ruv_modify_context( Slapi_PBlock *pb, modify_context *mc )\n{\n    char *uniqueid = NULL;\n    backend *be;\n    Slapi_Mods *smods = NULL;\n    struct backentry *bentry;\n    entry_address bentry_addr;\n    IFP fn = NULL;\n    int rc = 0;\n    back_txn txn = {NULL};\n    slapi_pblock_get(pb, SLAPI_TXN_RUV_MODS_FN, (void *)&fn);\n    slapi_pblock_get(pb, SLAPI_TXN, &txn.back_txn_txn);\n    if (NULL == fn) {\n        return (0);\n    }\n    rc = (*fn)(pb, &uniqueid, &smods);\n    if (1 != rc || NULL == smods || NULL == uniqueid) {\n        return (rc);\n    }\n    slapi_pblock_get( pb, SLAPI_BACKEND, &be);\n    bentry_addr.sdn = NULL;\n    bentry_addr.udn = NULL;\n    bentry_addr.uniqueid = uniqueid;\n    bentry = find_entry2modify_only( pb, be, &bentry_addr, &txn );\n    if (NULL == bentry) {\n        LDAPDebug( LDAP_DEBUG_ANY, \"Error: ldbm_txn_ruv_modify_context failed to retrieve and lock RUV entry\\n\",\n            0, 0, 0 );\n        rc = -1;\n        goto done;\n    }\n    modify_init( mc, bentry );\n    if (modify_apply_mods_ignore_error( mc, smods, LDAP_TYPE_OR_VALUE_EXISTS )) {\n        LDAPDebug( LDAP_DEBUG_ANY, \"Error: ldbm_txn_ruv_modify_context failed to apply updates to RUV entry\\n\",\n            0, 0, 0 );\n        rc = -1;\n        modify_term( mc, be );\n    }\ndone:\n    slapi_ch_free_string( &uniqueid );\n    return (rc);\n}", "target": 1}
{"code": "QMimeData *ServerItem::toMimeData() const {\n\tQMimeData *mime = ServerItem::toMimeData(qsName, qsHostname, usPort);\n\tif (itType == FavoriteType)\n\t\tmime->setData(QLatin1String(\"OriginatedInMumble\"), QByteArray());\n\treturn mime;\n}", "target": 0}
{"code": "xmlNodePtr SimpleXMLElement_exportNode(const Object& sxe) {\n  assert(sxe->instanceof(SimpleXMLElement_classof()));\n  auto data = Native::data<SimpleXMLElement>(sxe.get());\n  return php_sxe_get_first_node(data, data->nodep());\n}", "target": 1}
{"code": "static inline MagickOffsetType WritePixelCacheRegion(\n  const CacheInfo *magick_restrict cache_info,const MagickOffsetType offset,\n  const MagickSizeType length,const unsigned char *magick_restrict buffer)\n{\n  register MagickOffsetType\n    i;\n  ssize_t\n    count;\n#if !defined(MAGICKCORE_HAVE_PWRITE)\n  if (lseek(cache_info->file,offset,SEEK_SET) < 0)\n    return((MagickOffsetType) -1);\n#endif\n  count=0;\n  for (i=0; i < (MagickOffsetType) length; i+=count)\n  {\n#if !defined(MAGICKCORE_HAVE_PWRITE)\n    count=write(cache_info->file,buffer+i,(size_t) MagickMin(length-i,(size_t)\n      SSIZE_MAX));\n#else\n    count=pwrite(cache_info->file,buffer+i,(size_t) MagickMin(length-i,(size_t)\n      SSIZE_MAX),(off_t) (offset+i));\n#endif\n    if (count <= 0)\n      {\n        count=0;\n        if (errno != EINTR)\n          break;\n      }\n  }\n  return(i);\n}", "target": 0}
{"code": "static void irda_connect_confirm(void *instance, void *sap,\n\t\t\t\t struct qos_info *qos,\n\t\t\t\t __u32 max_sdu_size, __u8 max_header_size,\n\t\t\t\t struct sk_buff *skb)\n{\n\tstruct irda_sock *self;\n\tstruct sock *sk;\n\tself = instance;\n\tIRDA_DEBUG(2, \"%s(%p)\\n\", __func__, self);\n\tsk = instance;\n\tif (sk == NULL) {\n\t\tdev_kfree_skb(skb);\n\t\treturn;\n\t}\n\tdev_kfree_skb(skb);\n\tself->max_header_size = max_header_size;\n\tself->max_sdu_size_tx = max_sdu_size;\n\tswitch (sk->sk_type) {\n\tcase SOCK_STREAM:\n\t\tif (max_sdu_size != 0) {\n\t\t\tIRDA_ERROR(\"%s: max_sdu_size must be 0\\n\",\n\t\t\t\t   __func__);\n\t\t\treturn;\n\t\t}\n\t\tself->max_data_size = irttp_get_max_seg_size(self->tsap);\n\t\tbreak;\n\tcase SOCK_SEQPACKET:\n\t\tif (max_sdu_size == 0) {\n\t\t\tIRDA_ERROR(\"%s: max_sdu_size cannot be 0\\n\",\n\t\t\t\t   __func__);\n\t\t\treturn;\n\t\t}\n\t\tself->max_data_size = max_sdu_size;\n\t\tbreak;\n\tdefault:\n\t\tself->max_data_size = irttp_get_max_seg_size(self->tsap);\n\t}\n\tIRDA_DEBUG(2, \"%s(), max_data_size=%d\\n\", __func__,\n\t\t   self->max_data_size);\n\tmemcpy(&self->qos_tx, qos, sizeof(struct qos_info));\n\tsk->sk_state = TCP_ESTABLISHED;\n\tsk->sk_state_change(sk);\n}", "target": 0}
{"code": "base64_decode(packet_info *pinfo, tvbuff_t *b64_tvb, char *name)\n{\n    char *data;\n    tvbuff_t *tvb;\n    data = tvb_get_string_enc(wmem_packet_scope(), b64_tvb, 0, tvb_reported_length(b64_tvb), ENC_ASCII);\n    tvb = base64_to_tvb(b64_tvb, data);\n    add_new_data_source(pinfo, tvb, name);\n    return tvb;\n}", "target": 0}
{"code": "                uint64_t readData(int size) const\n                {\n                    const DataBuf data = Image::io().read(size);\n                    enforce(data.size_ != 0, kerCorruptedMetadata);\n                    uint64_t result = 0;\n                    if (data.size_ == 1)\n                        {}\n                    else if (data.size_ == 2)\n                        result = byteSwap2(data, 0, doSwap_);\n                    else if (data.size_ == 4)\n                        result = byteSwap4(data, 0, doSwap_);\n                    else if (data.size_ == 8)\n                        result = byteSwap8(data, 0, doSwap_);\n                    else\n                        throw Exiv2::Error(kerCorruptedMetadata);\n                    return result;\n                }", "target": 0}
{"code": "compile_string_node(Node* node, regex_t* reg)\n{\n  int r, len, prev_len, slen, ambig;\n  OnigEncoding enc = reg->enc;\n  UChar *p, *prev, *end;\n  StrNode* sn;\n  sn = NSTR(node);\n  if (sn->end <= sn->s)\n    return 0;\n  end = sn->end;\n  ambig = NSTRING_IS_AMBIG(node);\n  p = prev = sn->s;\n  prev_len = enclen(enc, p);\n  p += prev_len;\n  slen = 1;\n  for (; p < end; ) {\n    len = enclen(enc, p);\n    if (len == prev_len) {\n      slen++;\n    }\n    else {\n      r = add_compile_string(prev, prev_len, slen, reg, ambig);\n      if (r) return r;\n      prev  = p;\n      slen  = 1;\n      prev_len = len;\n    }\n    p += len;\n  }\n  return add_compile_string(prev, prev_len, slen, reg, ambig);\n}", "target": 1}
{"code": "static int __init atalk_init(void)\n{\n\tint rc;\n\trc = proto_register(&ddp_proto, 0);\n\tif (rc)\n\t\tgoto out;\n\trc = sock_register(&atalk_family_ops);\n\tif (rc)\n\t\tgoto out_proto;\n\tddp_dl = register_snap_client(ddp_snap_id, atalk_rcv);\n\tif (!ddp_dl)\n\t\tprintk(atalk_err_snap);\n\tdev_add_pack(&ltalk_packet_type);\n\tdev_add_pack(&ppptalk_packet_type);\n\trc = register_netdevice_notifier(&ddp_notifier);\n\tif (rc)\n\t\tgoto out_sock;\n\taarp_proto_init();\n\trc = atalk_proc_init();\n\tif (rc)\n\t\tgoto out_aarp;\n\trc = atalk_register_sysctl();\n\tif (rc)\n\t\tgoto out_proc;\nout:\n\treturn rc;\nout_proc:\n\tatalk_proc_exit();\nout_aarp:\n\taarp_cleanup_module();\n\tunregister_netdevice_notifier(&ddp_notifier);\nout_sock:\n\tdev_remove_pack(&ppptalk_packet_type);\n\tdev_remove_pack(&ltalk_packet_type);\n\tunregister_snap_client(ddp_dl);\n\tsock_unregister(PF_APPLETALK);\nout_proto:\n\tproto_unregister(&ddp_proto);\n\tgoto out;\n}", "target": 1}
{"code": "static int tcp_match_skb_to_sack(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t u32 start_seq, u32 end_seq)\n{\n\tint in_sack, err;\n\tunsigned int pkt_len;\n\tunsigned int mss;\n\tin_sack = !after(start_seq, TCP_SKB_CB(skb)->seq) &&\n\t\t  !before(end_seq, TCP_SKB_CB(skb)->end_seq);\n\tif (tcp_skb_pcount(skb) > 1 && !in_sack &&\n\t    after(TCP_SKB_CB(skb)->end_seq, start_seq)) {\n\t\tmss = tcp_skb_mss(skb);\n\t\tin_sack = !after(start_seq, TCP_SKB_CB(skb)->seq);\n\t\tif (!in_sack) {\n\t\t\tpkt_len = start_seq - TCP_SKB_CB(skb)->seq;\n\t\t\tif (pkt_len < mss)\n\t\t\t\tpkt_len = mss;\n\t\t} else {\n\t\t\tpkt_len = end_seq - TCP_SKB_CB(skb)->seq;\n\t\t\tif (pkt_len < mss)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (pkt_len > mss) {\n\t\t\tunsigned int new_len = (pkt_len / mss) * mss;\n\t\t\tif (!in_sack && new_len < pkt_len) {\n\t\t\t\tnew_len += mss;\n\t\t\t\tif (new_len > skb->len)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpkt_len = new_len;\n\t\t}\n\t\terr = tcp_fragment(sk, skb, pkt_len, mss);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn in_sack;\n}", "target": 0}
{"code": "static SCSIRequest *scsi_new_request(SCSIDevice *d, uint32_t tag,\n                                     uint32_t lun, void *hba_private)\n{\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);\n    SCSIRequest *req;\n    SCSIDiskReq *r;\n    req = scsi_req_alloc(&scsi_disk_reqops, &s->qdev, tag, lun, hba_private);\n    r = DO_UPCAST(SCSIDiskReq, req, req);\n    r->iov.iov_base = qemu_blockalign(s->bs, SCSI_DMA_BUF_SIZE);\n    return req;\n}", "target": 1}
{"code": "void uwbd_stop(struct uwb_rc *rc)\n{\n\tkthread_stop(rc->uwbd.task);\n\tuwbd_flush(rc);\n}", "target": 1}
{"code": "static xmlParserCtxtPtr createMemoryParser(xmlSAXHandlerPtr handlers, void* userData, const char* chunk)\n{\n    if (!didInit) {\n        xmlInitParser();\n        xmlRegisterInputCallbacks(matchFunc, openFunc, readFunc, closeFunc);\n        xmlRegisterOutputCallbacks(matchFunc, openFunc, writeFunc, closeFunc);\n        libxmlLoaderThread = currentThread();\n        didInit = true;\n    }\n    xmlParserCtxtPtr parser = xmlCreateMemoryParserCtxt(chunk, xmlStrlen((const xmlChar*)chunk));\n    if (!parser)\n        return 0;\n    memcpy(parser->sax, handlers, sizeof(xmlSAXHandler));\n    xmlCtxtUseOptions(parser, XML_PARSE_NODICT | XML_PARSE_NOENT);\n    parser->sax2 = 1;\n    parser->instate = XML_PARSER_CONTENT; \n    parser->depth = 0;\n    parser->str_xml = xmlDictLookup(parser->dict, BAD_CAST \"xml\", 3);\n    parser->str_xmlns = xmlDictLookup(parser->dict, BAD_CAST \"xmlns\", 5);\n    parser->str_xml_ns = xmlDictLookup(parser->dict, XML_XML_NAMESPACE, 36);\n    parser->_private = userData;\n    return parser;\n}", "target": 0}
{"code": "int touch(const char *path) {\n        return touch_file(path, false, USEC_INFINITY, UID_INVALID, GID_INVALID, 0);\n}", "target": 1}
{"code": "bool Item_singlerow_subselect::fix_length_and_dec()\n{\n  if ((max_columns= engine->cols()) == 1)\n  {\n    if (engine->fix_length_and_dec(row= &value))\n      return TRUE;\n  }\n  else\n  {\n    if (!(row= (Item_cache**) current_thd->alloc(sizeof(Item_cache*) *\n                                                 max_columns)) ||\n        engine->fix_length_and_dec(row))\n      return TRUE;\n    value= *row;\n  }\n  unsigned_flag= value->unsigned_flag;\n  if (engine->no_tables())\n    maybe_null= engine->may_be_null();\n  else\n  {\n    for (uint i= 0; i < max_columns; i++)\n      row[i]->maybe_null= TRUE;\n  }\n  return FALSE;\n}", "target": 1}
{"code": "EXPORTED int meth_trace(struct transaction_t *txn, void *params)\n{\n    parse_path_t parse_path = (parse_path_t) params;\n    const char **hdr;\n    unsigned long max_fwd = -1;\n    struct buf *msg = &txn->resp_body.payload;\n    txn->flags.cc |= CC_NOCACHE;\n    if (!(txn->req_tgt.allow & ALLOW_TRACE)) return HTTP_NOT_ALLOWED;\n    if ((hdr = spool_getheader(txn->req_hdrs, \"Max-Forwards\"))) {\n        max_fwd = strtoul(hdr[0], NULL, 10);\n    }\n    if (max_fwd && parse_path) {\n        int r;\n        if ((r = parse_path(txn->req_uri->path,\n                            &txn->req_tgt, &txn->error.desc))) return r;\n        if (txn->req_tgt.mbentry && txn->req_tgt.mbentry->server) {\n            struct backend *be;\n            be = proxy_findserver(txn->req_tgt.mbentry->server,\n                                  &http_protocol, httpd_userid,\n                                  &backend_cached, NULL, NULL, httpd_in);\n            if (!be) return HTTP_UNAVAILABLE;\n            return http_pipe_req_resp(be, txn);\n        }\n    }\n    buf_reset(msg);\n    buf_printf(msg, \"TRACE %s %s\\r\\n\", txn->req_line.uri, txn->req_line.ver);\n    spool_enum_hdrcache(txn->req_hdrs, &trace_cachehdr, msg);\n    buf_appendcstr(msg, \"\\r\\n\");\n    txn->resp_body.type = \"message/http\";\n    txn->resp_body.len = buf_len(msg);\n    write_body(HTTP_OK, txn, buf_cstring(msg), buf_len(msg));\n    return 0;\n}", "target": 0}
{"code": "QPDF::QPDF() :\n    encrypted(false),\n    encryption_initialized(false),\n    ignore_xref_streams(false),\n    suppress_warnings(false),\n    out_stream(&std::cout),\n    err_stream(&std::cerr),\n    attempt_recovery(true),\n    encryption_V(0),\n    encryption_R(0),\n    encrypt_metadata(true),\n    cf_stream(e_none),\n    cf_string(e_none),\n    cf_file(e_none),\n    cached_key_objid(0),\n    cached_key_generation(0),\n    pushed_inherited_attributes_to_pages(false),\n    copied_stream_data_provider(0),\n    first_xref_item_offset(0),\n    uncompressed_after_compressed(false)\n{\n}", "target": 1}
{"code": "int mesg_make_query (u_char *qname, uint16_t qtype, uint16_t qclass,\n\t\t     uint32_t id, int rd, u_char *buf, int buflen) {\n\tchar *fn = \"mesg_make_query()\";\n\tu_char *ucp;\n\tint i, written_len;\n\tMesg_Hdr *hdr;\n\tif (T.debug > 4)\n\t\tsyslog (LOG_DEBUG, \"%s: (qtype: %s, id: %d): start\", fn,\n\t\t\tstring_rtype (qtype), id);\n\thdr = (Mesg_Hdr *) buf;\n\thdr->id = id;\n\thdr->opcode = OP_QUERY;\n\thdr->rcode = RC_OK;\n\thdr->rd = rd;\n\thdr->qr = hdr->aa = hdr->tc = hdr->ra = hdr->zero = 0;\n\thdr->qdcnt = ntohs (1);\n\thdr->ancnt = hdr->nscnt = hdr->arcnt = ntohs (0);\n\twritten_len = sizeof (Mesg_Hdr);\n\tucp = (u_char *) (hdr + 1);\n\tif (T.debug > 4)\n\t\tsyslog (LOG_DEBUG, \"%s: qname offset = %zd\", fn, ucp - buf);\n\ti = dname_copy (qname, ucp, buflen - written_len);\n\tif (i < 0)\n\t\treturn -1;\n\twritten_len += i;\n\tucp += i;\n\tif (T.debug > 4)\n\t\tsyslog (LOG_DEBUG, \"%s: qtype/qclass offset = %zd\",\n\t\t\tfn, ucp - buf);\n\twritten_len += sizeof (uint16_t) * 2;\n\tif (written_len > buflen)\n\t\treturn -1;\n\tPUTSHORT (qtype, ucp);\n\tPUTSHORT (qclass, ucp);\n\treturn written_len;\n}", "target": 1}
{"code": "struct pmu *perf_init_event(struct perf_event *event)\n{\n\tstruct pmu *pmu = NULL;\n\tint idx;\n\tint ret;\n\tidx = srcu_read_lock(&pmus_srcu);\n\trcu_read_lock();\n\tpmu = idr_find(&pmu_idr, event->attr.type);\n\trcu_read_unlock();\n\tif (pmu) {\n\t\tevent->pmu = pmu;\n\t\tret = pmu->event_init(event);\n\t\tif (ret)\n\t\t\tpmu = ERR_PTR(ret);\n\t\tgoto unlock;\n\t}\n\tlist_for_each_entry_rcu(pmu, &pmus, entry) {\n\t\tevent->pmu = pmu;\n\t\tret = pmu->event_init(event);\n\t\tif (!ret)\n\t\t\tgoto unlock;\n\t\tif (ret != -ENOENT) {\n\t\t\tpmu = ERR_PTR(ret);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\tpmu = ERR_PTR(-ENOENT);\nunlock:\n\tsrcu_read_unlock(&pmus_srcu, idx);\n\treturn pmu;\n}", "target": 0}
{"code": "void cipso_v4_req_delattr(struct request_sock *req)\n{\n\tstruct ip_options *opt;\n\tstruct inet_request_sock *req_inet;\n\treq_inet = inet_rsk(req);\n\topt = req_inet->opt;\n\tif (opt == NULL || opt->cipso == 0)\n\t\treturn;\n\tcipso_v4_delopt(&req_inet->opt);\n}", "target": 1}
{"code": "hb_map_clear (hb_map_t *map)\n{\n  if (unlikely (hb_object_is_immutable (map)))\n    return;\n  return map->clear ();\n}", "target": 1}
{"code": "static int FNAME(cmpxchg_gpte)(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t       pt_element_t __user *ptep_user, unsigned index,\n\t\t\t       pt_element_t orig_pte, pt_element_t new_pte)\n{\n\tint npages;\n\tpt_element_t ret;\n\tpt_element_t *table;\n\tstruct page *page;\n\tnpages = get_user_pages_fast((unsigned long)ptep_user, 1, FOLL_WRITE, &page);\n\tif (likely(npages == 1)) {\n\t\ttable = kmap_atomic(page);\n\t\tret = CMPXCHG(&table[index], orig_pte, new_pte);\n\t\tkunmap_atomic(table);\n\t\tkvm_release_page_dirty(page);\n\t} else {\n\t\tstruct vm_area_struct *vma;\n\t\tunsigned long vaddr = (unsigned long)ptep_user & PAGE_MASK;\n\t\tunsigned long pfn;\n\t\tunsigned long paddr;\n\t\tmmap_read_lock(current->mm);\n\t\tvma = find_vma_intersection(current->mm, vaddr, vaddr + PAGE_SIZE);\n\t\tif (!vma || !(vma->vm_flags & VM_PFNMAP)) {\n\t\t\tmmap_read_unlock(current->mm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tpfn = ((vaddr - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\t\tpaddr = pfn << PAGE_SHIFT;\n\t\ttable = memremap(paddr, PAGE_SIZE, MEMREMAP_WB);\n\t\tif (!table) {\n\t\t\tmmap_read_unlock(current->mm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tret = CMPXCHG(&table[index], orig_pte, new_pte);\n\t\tmemunmap(table);\n\t\tmmap_read_unlock(current->mm);\n\t}\n\treturn (ret != orig_pte);\n}", "target": 1}
{"code": "coolkey_attribute_start(const u8 *obj, u8 object_record_type, size_t buf_len)\n{\n\tsize_t offset = object_record_type == COOLKEY_V1_OBJECT ? sizeof(coolkey_object_header_t) :\n\t\t\tsizeof(coolkey_v0_object_header_t);\n\tif ((object_record_type != COOLKEY_V1_OBJECT) && (object_record_type != COOLKEY_V0_OBJECT)) {\n\t\treturn NULL;\n\t}\n\tif (offset > buf_len) {\n\t\treturn NULL;\n\t}\n\treturn obj + offset;\n}", "target": 0}
{"code": "static int cg_rmdir(const char *path)\n{\n\tstruct fuse_context *fc = fuse_get_context();\n\tchar *fpath = NULL, *cgdir = NULL, *controller;\n\tconst char *cgroup;\n\tint ret;\n\tif (!fc)\n\t\treturn -EIO;\n\tcontroller = pick_controller_from_path(fc, path);\n\tif (!controller)\n\t\treturn -EINVAL;\n\tcgroup = find_cgroup_in_path(path);\n\tif (!cgroup)\n\t\treturn -EINVAL;\n\tget_cgdir_and_path(cgroup, &cgdir, &fpath);\n\tif (!fpath) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tfprintf(stderr, \"rmdir: verifying access to %s:%s (req path %s)\\n\",\n\t\t\tcontroller, cgdir, path);\n\tif (!fc_may_access(fc, controller, cgdir, NULL, O_WRONLY)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\tif (!caller_is_in_ancestor(fc->pid, controller, cgroup, NULL)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\tif (!cgfs_remove(controller, cgroup)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tfree(cgdir);\n\treturn ret;\n}", "target": 1}
{"code": "static void sycc444_to_rgb(opj_image_t *img)\n{\n\tint *d0, *d1, *d2, *r, *g, *b;\n\tconst int *y, *cb, *cr;\n\tunsigned int maxw, maxh, max, i;\n\tint offset, upb;\n\tupb = (int)img->comps[0].prec;\n\toffset = 1<<(upb - 1); upb = (1<<upb)-1;\n\tmaxw = (unsigned int)img->comps[0].w; maxh = (unsigned int)img->comps[0].h;\n\tmax = maxw * maxh;\n\ty = img->comps[0].data;\n\tcb = img->comps[1].data;\n\tcr = img->comps[2].data;\n\td0 = r = (int*)malloc(sizeof(int) * (size_t)max);\n\td1 = g = (int*)malloc(sizeof(int) * (size_t)max);\n\td2 = b = (int*)malloc(sizeof(int) * (size_t)max);\n\tif(r == NULL || g == NULL || b == NULL) goto fails;\n\tfor(i = 0U; i < max; ++i)\n\t{\n\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t++y; ++cb; ++cr; ++r; ++g; ++b;\n\t}\n\tfree(img->comps[0].data); img->comps[0].data = d0;\n\tfree(img->comps[1].data); img->comps[1].data = d1;\n\tfree(img->comps[2].data); img->comps[2].data = d2;\n\treturn;\nfails:\n\tif(r) free(r);\n\tif(g) free(g);\n\tif(b) free(b);\n}", "target": 1}
{"code": "static int ql_alloc_large_buffers(struct ql3_adapter *qdev)\n{\n\tint i;\n\tstruct ql_rcv_buf_cb *lrg_buf_cb;\n\tstruct sk_buff *skb;\n\tdma_addr_t map;\n\tint err;\n\tfor (i = 0; i < qdev->num_large_buffers; i++) {\n\t\tskb = netdev_alloc_skb(qdev->ndev,\n\t\t\t\t       qdev->lrg_buffer_len);\n\t\tif (unlikely(!skb)) {\n\t\t\tnetdev_err(qdev->ndev,\n\t\t\t\t   \"large buff alloc failed for %d bytes at index %d\\n\",\n\t\t\t\t   qdev->lrg_buffer_len * 2, i);\n\t\t\tql_free_large_buffers(qdev);\n\t\t\treturn -ENOMEM;\n\t\t} else {\n\t\t\tlrg_buf_cb = &qdev->lrg_buf[i];\n\t\t\tmemset(lrg_buf_cb, 0, sizeof(struct ql_rcv_buf_cb));\n\t\t\tlrg_buf_cb->index = i;\n\t\t\tlrg_buf_cb->skb = skb;\n\t\t\tskb_reserve(skb, QL_HEADER_SPACE);\n\t\t\tmap = pci_map_single(qdev->pdev,\n\t\t\t\t\t     skb->data,\n\t\t\t\t\t     qdev->lrg_buffer_len -\n\t\t\t\t\t     QL_HEADER_SPACE,\n\t\t\t\t\t     PCI_DMA_FROMDEVICE);\n\t\t\terr = pci_dma_mapping_error(qdev->pdev, map);\n\t\t\tif (err) {\n\t\t\t\tnetdev_err(qdev->ndev,\n\t\t\t\t\t   \"PCI mapping failed with error: %d\\n\",\n\t\t\t\t\t   err);\n\t\t\t\tql_free_large_buffers(qdev);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tdma_unmap_addr_set(lrg_buf_cb, mapaddr, map);\n\t\t\tdma_unmap_len_set(lrg_buf_cb, maplen,\n\t\t\t\t\t  qdev->lrg_buffer_len -\n\t\t\t\t\t  QL_HEADER_SPACE);\n\t\t\tlrg_buf_cb->buf_phy_addr_low =\n\t\t\t    cpu_to_le32(LS_64BITS(map));\n\t\t\tlrg_buf_cb->buf_phy_addr_high =\n\t\t\t    cpu_to_le32(MS_64BITS(map));\n\t\t}\n\t}\n\treturn 0;", "target": 1}
{"code": "  virtual bool ms_verify_authorizer(Connection *con, int peer_type,\n\t\t\t\t    int protocol, bufferlist& authorizer,\n\t\t\t\t    bufferlist& authorizer_reply,\n\t\t\t\t    bool& isvalid, CryptoKey& session_key) {\n    isvalid = true;\n    return true;\n  };", "target": 1}
{"code": "sldns_affix_token(sldns_buffer* strbuf, char* token, size_t* token_len,\n\tint* quoted, int* parens, size_t* pre_data_pos,\n\tconst char* delimiters, sldns_rdf_type rdftype, size_t* token_strlen)\n{\n\tsize_t addlen = *token_len - *token_strlen;\n\tsize_t addstrlen = 0;\n\tif(addlen < 1) return 0;\n\ttoken[*token_strlen] = ' ';\n\ttoken[++(*token_strlen)] = 0;\n\taddlen = *token_len - *token_strlen;\n\tif(!sldns_parse_rdf_token(strbuf, token+*token_strlen, addlen, quoted,\n\t\tparens, pre_data_pos, delimiters, rdftype, &addstrlen))\n\t\treturn 0;\n\t(*token_strlen) += addstrlen;\n\treturn 1;\n}", "target": 0}
{"code": "void dtls1_reset_seq_numbers(SSL *s, int rw)\n{\n    unsigned char *seq;\n    unsigned int seq_bytes = sizeof(s->s3->read_sequence);\n    if (rw & SSL3_CC_READ) {\n        seq = s->s3->read_sequence;\n        s->d1->r_epoch++;\n        memcpy(&(s->d1->bitmap), &(s->d1->next_bitmap), sizeof(DTLS1_BITMAP));\n        memset(&(s->d1->next_bitmap), 0x00, sizeof(DTLS1_BITMAP));\n    } else {\n        seq = s->s3->write_sequence;\n        memcpy(s->d1->last_write_sequence, seq,\n               sizeof(s->s3->write_sequence));\n        s->d1->w_epoch++;\n    }\n    memset(seq, 0x00, seq_bytes);\n}", "target": 1}
{"code": "static inline int check_sticky(struct inode *dir, struct inode *inode)\n{\n\tkuid_t fsuid = current_fsuid();\n\tif (!(dir->i_mode & S_ISVTX))\n\t\treturn 0;\n\tif (uid_eq(inode->i_uid, fsuid))\n\t\treturn 0;\n\tif (uid_eq(dir->i_uid, fsuid))\n\t\treturn 0;\n\treturn !inode_capable(inode, CAP_FOWNER);\n}", "target": 1}
{"code": "int InlineFlowBox::getFlowSpacingLogicalWidth()\n{\n    int totWidth = marginBorderPaddingLogicalLeft() + marginBorderPaddingLogicalRight();\n    for (InlineBox* curr = firstChild(); curr; curr = curr->nextOnLine()) {\n        if (curr->isInlineFlowBox())\n            totWidth += static_cast<InlineFlowBox*>(curr)->getFlowSpacingLogicalWidth();\n    }\n    return totWidth;\n}", "target": 0}
{"code": "static int nested_vmx_check_tpr_shadow_controls(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\tstruct vmcs12 *vmcs12)\n{\n\tif (!nested_cpu_has(vmcs12, CPU_BASED_TPR_SHADOW))\n\t\treturn 0;\n\tif (!page_address_valid(vcpu, vmcs12->virtual_apic_page_addr))\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 0}
{"code": "void TDStretch::setChannels(int numChannels)\n{\n    assert(numChannels > 0);\n    if (channels == numChannels) return;\n    channels = numChannels;\n    inputBuffer.setChannels(channels);\n    outputBuffer.setChannels(channels);\n    overlapLength=0;\n    setParameters(sampleRate);\n}", "target": 1}
{"code": "void PDPClient::perform_builtin_endpoints_matching(\n        const ParticipantProxyData& pdata)\n{\n    if (mp_builtin->mp_WLP != nullptr)\n    {\n        mp_builtin->mp_WLP->assignRemoteEndpoints(pdata);\n    }\n}", "target": 1}
{"code": "KCleanup::itemDir( const KFileInfo *item ) const\n{\n    QString dir = item->url();\n    if ( ! item->isDir() && ! item->isDotEntry() )\n    {\n\tdir.replace ( QRegExp ( \"/[^/]*$\" ), \"\" );\n    }\n    return dir;\n}", "target": 0}
{"code": "uipbuf_get_len_field(struct uip_ip_hdr *hdr)\n{\n  return ((uint16_t)(hdr->len[0]) << 8) + hdr->len[1];\n}", "target": 0}
{"code": "handle_action(netdissect_options *ndo,\n              const uint8_t *src, const u_char *p, u_int length)\n{\n\tif (!ND_TTEST2(*p, 2))\n\t\treturn 0;\n\tif (length < 2)\n\t\treturn 0;\n\tif (ndo->ndo_eflag) {\n\t\tND_PRINT((ndo, \": \"));\n\t} else {\n\t\tND_PRINT((ndo, \" (%s): \", etheraddr_string(ndo, src)));\n\t}\n\tswitch (p[0]) {\n\tcase 0: ND_PRINT((ndo, \"Spectrum Management Act#%d\", p[1])); break;\n\tcase 1: ND_PRINT((ndo, \"QoS Act#%d\", p[1])); break;\n\tcase 2: ND_PRINT((ndo, \"DLS Act#%d\", p[1])); break;\n\tcase 3: ND_PRINT((ndo, \"BA \")); PRINT_BA_ACTION(p[1]); break;\n\tcase 7: ND_PRINT((ndo, \"HT \")); PRINT_HT_ACTION(p[1]); break;\n\tcase 13: ND_PRINT((ndo, \"MeshAction \")); PRINT_MESH_ACTION(p[1]); break;\n\tcase 14:\n\t\tND_PRINT((ndo, \"MultiohopAction \"));\n\t\tPRINT_MULTIHOP_ACTION(p[1]); break;\n\tcase 15:\n\t\tND_PRINT((ndo, \"SelfprotectAction \"));\n\t\tPRINT_SELFPROT_ACTION(p[1]); break;\n\tcase 127: ND_PRINT((ndo, \"Vendor Act#%d\", p[1])); break;\n\tdefault:\n\t\tND_PRINT((ndo, \"Reserved(%d) Act#%d\", p[0], p[1]));\n\t\tbreak;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "static int __init init_ext2_fs(void)\n{\n\tint err = init_ext2_xattr();\n\tif (err)\n\t\treturn err;\n\terr = init_inodecache();\n\tif (err)\n\t\tgoto out1;\n        err = register_filesystem(&ext2_fs_type);\n\tif (err)\n\t\tgoto out;\n\treturn 0;\nout:\n\tdestroy_inodecache();\nout1:\n\texit_ext2_xattr();\n\treturn err;\n}", "target": 1}
{"code": "auto ReferenceHandle::New(Local<Value> value, MaybeLocal<Object> options) -> unique_ptr<ReferenceHandle> {\n\tauto inherit = ReadOption<bool>(options, StringTable::Get().inheritUnsafe, false);\n\treturn std::make_unique<ReferenceHandle>(value, inherit);\n}", "target": 1}
{"code": "static struct block_device *ext3_blkdev_get(dev_t dev, struct super_block *sb)\n{\n\tstruct block_device *bdev;\n\tchar b[BDEVNAME_SIZE];\n\tbdev = blkdev_get_by_dev(dev, FMODE_READ|FMODE_WRITE|FMODE_EXCL, sb);\n\tif (IS_ERR(bdev))\n\t\tgoto fail;\n\treturn bdev;\nfail:\n\text3_msg(sb, \"error: failed to open journal device %s: %ld\",\n\t\t__bdevname(dev, b), PTR_ERR(bdev));\n\treturn NULL;\n}", "target": 1}
{"code": "static void prepare_attr_stack(const char *path, int dirlen)\n{\n\tstruct attr_stack *elem, *info;\n\tint len;\n\tstruct strbuf pathbuf;\n\tstrbuf_init(&pathbuf, dirlen+2+strlen(GITATTRIBUTES_FILE));\n\tif (!attr_stack)\n\t\tbootstrap_attr_stack();\n\tinfo = attr_stack;\n\tattr_stack = info->prev;\n\twhile (attr_stack && attr_stack->origin) {\n\t\tint namelen = strlen(attr_stack->origin);\n\t\telem = attr_stack;\n\t\tif (namelen <= dirlen &&\n\t\t    !strncmp(elem->origin, path, namelen))\n\t\t\tbreak;\n\t\tdebug_pop(elem);\n\t\tattr_stack = elem->prev;\n\t\tfree_attr_elem(elem);\n\t}\n\tif (!is_bare_repository()) {\n\t\twhile (1) {\n\t\t\tchar *cp;\n\t\t\tlen = strlen(attr_stack->origin);\n\t\t\tif (dirlen <= len)\n\t\t\t\tbreak;\n\t\t\tstrbuf_reset(&pathbuf);\n\t\t\tstrbuf_add(&pathbuf, path, dirlen);\n\t\t\tstrbuf_addch(&pathbuf, '/');\n\t\t\tcp = strchr(pathbuf.buf + len + 1, '/');\n\t\t\tstrcpy(cp + 1, GITATTRIBUTES_FILE);\n\t\t\telem = read_attr(pathbuf.buf, 0);\n\t\t\t*cp = '\\0';\n\t\t\telem->origin = strdup(pathbuf.buf);\n\t\t\telem->prev = attr_stack;\n\t\t\tattr_stack = elem;\n\t\t\tdebug_push(elem);\n\t\t}\n\t}\n\tinfo->prev = attr_stack;\n\tattr_stack = info;\n}", "target": 0}
{"code": "njs_json_parse_iterator_call(njs_vm_t *vm, njs_json_parse_t *parse,\n    njs_json_state_t *state)\n{\n    njs_int_t          ret;\n    njs_value_t        arguments[3], *value;\n    njs_object_prop_t  *prop;\n    prop = state->prop;\n    arguments[0] = state->value;\n    arguments[1] = state->keys->start[state->index++];\n    switch (prop->type) {\n    case NJS_PROPERTY:\n        arguments[2] = prop->value;\n        ret = njs_function_apply(vm, parse->function, arguments, 3,\n                                 &parse->retval);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n        if (njs_is_undefined(&parse->retval)) {\n            prop->type = NJS_WHITEOUT;\n        } else {\n            prop->value = parse->retval;\n        }\n        break;\n    case NJS_PROPERTY_REF:\n        value = prop->value.data.u.value;\n        arguments[2] = *value;\n        ret = njs_function_apply(vm, parse->function, arguments, 3,\n                                 &parse->retval);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n        if (njs_is_undefined(&parse->retval)) {\n            ret = njs_value_property_i64_delete(vm, &state->value,\n                                                state->index - 1, NULL);\n        } else {\n            ret = njs_value_property_i64_set(vm, &state->value,\n                                             state->index - 1, &parse->retval);\n        }\n        if (njs_slow_path(ret == NJS_ERROR)) {\n            return NJS_ERROR;\n        }\n        break;\n    default:\n        njs_internal_error(vm, \"njs_json_parse_iterator_call() unexpected \"\n                         \"property type:%s\", njs_prop_type_string(prop->type));\n    }\n    return NJS_OK;\n}", "target": 1}
{"code": "Function *ESTreeIRGen::genGeneratorFunction(\n    Identifier originalName,\n    Variable *lazyClosureAlias,\n    ESTree::FunctionLikeNode *functionNode) {\n  assert(functionNode && \"Function AST cannot be null\");\n  auto *outerFn = Builder.createGeneratorFunction(\n      originalName,\n      Function::DefinitionKind::ES5Function,\n      ESTree::isStrict(functionNode->strictness),\n       nullptr);\n  auto *innerFn = genES5Function(\n      genAnonymousLabelName(originalName.isValid() ? originalName.str() : \"\"),\n      lazyClosureAlias,\n      functionNode,\n      true);\n  {\n    FunctionContext outerFnContext{this, outerFn, functionNode->getSemInfo()};\n    emitFunctionPrologue(\n        functionNode,\n        Builder.createBasicBlock(outerFn),\n        InitES5CaptureState::Yes,\n        DoEmitParameters::No);\n    auto *gen = Builder.createCreateGeneratorInst(innerFn);\n    if (!hasSimpleParams(functionNode)) {\n      Value *next = Builder.createLoadPropertyInst(gen, \"next\");\n      Builder.createCallInst(next, gen, {});\n    }\n    emitFunctionEpilogue(gen);\n  }\n  return outerFn;\n}", "target": 1}
{"code": "static void slab_bug(struct kmem_cache *s, char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_err(\"=============================================================================\\n\");\n\tpr_err(\"BUG %s (%s): %pV\\n\", s->name, print_tainted(), &vaf);\n\tpr_err(\"-----------------------------------------------------------------------------\\n\\n\");\n\tadd_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);\n\tva_end(args);\n}", "target": 0}
{"code": "static void _gnutls_handshake_internal_state_init(gnutls_session_t session)\n{\n\tsession->internals.adv_version_major = 0;\n\tsession->internals.adv_version_minor = 0;\n\tsession->internals.direction = 0;\n\tsession->internals.last_handshake_in = -1;\n\tsession->internals.last_handshake_out = -1;\n\tsession->internals.resumable = RESUME_TRUE;\n\tsession->internals.handshake_large_loops = 0;\n\tsession->internals.dtls.hsk_read_seq = 0;\n\tsession->internals.dtls.hsk_write_seq = 0;\n}", "target": 1}
{"code": "int RGWPutCORS_ObjStore_S3::get_params()\n{\n  int r;\n  char *data = nullptr;\n  int len = 0;\n  RGWCORSXMLParser_S3 parser(s->cct);\n  RGWCORSConfiguration_S3 *cors_config;\n  const auto max_size = s->cct->_conf->rgw_max_put_param_size;\n  r = rgw_rest_read_all_input(s, &data, &len, max_size, false);\n  if (r < 0) {\n    return r;\n  }\n  auto data_deleter = std::unique_ptr<char, decltype(free)*>{data, free};\n  r = do_aws4_auth_completion();\n  if (r < 0) {\n    return r;\n  }\n  if (!parser.init()) {\n    return -EINVAL;\n  }\n  if (!data || !parser.parse(data, len, 1)) {\n    return -EINVAL;\n  }\n  cors_config =\n    static_cast<RGWCORSConfiguration_S3 *>(parser.find_first(\n\t\t\t\t\t     \"CORSConfiguration\"));\n  if (!cors_config) {\n    return -EINVAL;\n  }\n#define CORS_RULES_MAX_NUM      100\n  int max_num = s->cct->_conf->rgw_cors_rules_max_num;\n  if (max_num < 0) {\n    max_num = CORS_RULES_MAX_NUM;\n  }\n  int cors_rules_num = cors_config->get_rules().size();\n  if (cors_rules_num > max_num) {\n    ldout(s->cct, 4) << \"An cors config can have up to \"\n                     << max_num\n                     << \" rules, request cors rules num: \"\n                     << cors_rules_num << dendl;\n    op_ret = -ERR_INVALID_CORS_RULES_ERROR;\n    s->err.message = \"The number of CORS rules should not exceed allowed limit of \"\n                     + std::to_string(max_num) + \" rules.\";\n    return -ERR_INVALID_REQUEST;\n  }\n  if (!store->is_meta_master()) {\n    in_data.append(data, len);\n  }\n  if (s->cct->_conf->subsys.should_gather<ceph_subsys_rgw, 15>()) {\n    ldout(s->cct, 15) << \"CORSConfiguration\";\n    cors_config->to_xml(*_dout);\n    *_dout << dendl;\n  }\n  cors_config->encode(cors_bl);\n  return 0;\n}", "target": 0}
{"code": "void my_error_exit( j_common_ptr cinfo ) {\n   my_error_ptr myerr = reinterpret_cast<my_error_ptr>(cinfo->err);\n   longjmp( myerr->setjmp_buffer, 1 );\n}", "target": 1}
{"code": "int main(int ac, char *av[])\n{\n  int i, max_threads = 2;\n  pthread_t *threads;\n  if (ac < 2)\n    usage(av[0]);\n  queue = calloc(ac - 1, sizeof(queue[0]));\n  for (i = 1; i < ac; i++)\n  {\n    if (av[i][0] == '-')\n    {\n      if (av[i][1] == 'w')\n        use_camera_wb = 1;\n      if (av[i][1] == 'a')\n        use_auto_wb = 1;\n      if (av[i][1] == 'v')\n        verbose = 1;\n      if (av[i][1] == 'T')\n        tiff_mode = 1;\n      if (av[i][1] == 'J')\n      {\n        max_threads = atoi(av[++i]);\n        if (max_threads < 1)\n        {\n          fprintf(stderr, \"Job count should be at least 1\\n\");\n          exit(1);\n        }\n      }\n    }\n    else\n      queue[qsize++] = av[i];\n  }\n  pthread_mutex_init(&qm, NULL);\n  threads = calloc(max_threads, sizeof(threads[0]));\n  for (i = 0; i < max_threads; i++)\n    pthread_create(&threads[i], NULL, process_files, NULL);\n  for (i = 0; i < max_threads; i++)\n  {\n    int *iptr;\n    if (threads[i])\n    {\n      pthread_join(threads[i], (void *)&iptr);\n    }\n  }\n  return 0;\n}", "target": 0}
{"code": "static int get_manuf_info(struct edgeport_serial *serial, __u8 *buffer)\n{\n\tint status;\n\tint start_address;\n\tstruct ti_i2c_desc *rom_desc;\n\tstruct edge_ti_manuf_descriptor *desc;\n\tstruct device *dev = &serial->serial->dev->dev;\n\trom_desc = kmalloc(sizeof(*rom_desc), GFP_KERNEL);\n\tif (!rom_desc)\n\t\treturn -ENOMEM;\n\tstart_address = get_descriptor_addr(serial, I2C_DESC_TYPE_ION,\n\t\t\t\t\t\t\t\trom_desc);\n\tif (!start_address) {\n\t\tdev_dbg(dev, \"%s - Edge Descriptor not found in I2C\\n\", __func__);\n\t\tstatus = -ENODEV;\n\t\tgoto exit;\n\t}\n\tstatus = read_rom(serial, start_address+sizeof(struct ti_i2c_desc),\n\t\t\t\t\tle16_to_cpu(rom_desc->Size), buffer);\n\tif (status)\n\t\tgoto exit;\n\tstatus = valid_csum(rom_desc, buffer);\n\tdesc = (struct edge_ti_manuf_descriptor *)buffer;\n\tdev_dbg(dev, \"%s - IonConfig      0x%x\\n\", __func__, desc->IonConfig);\n\tdev_dbg(dev, \"%s - Version          %d\\n\", __func__, desc->Version);\n\tdev_dbg(dev, \"%s - Cpu/Board      0x%x\\n\", __func__, desc->CpuRev_BoardRev);\n\tdev_dbg(dev, \"%s - NumPorts         %d\\n\", __func__, desc->NumPorts);\n\tdev_dbg(dev, \"%s - NumVirtualPorts  %d\\n\", __func__, desc->NumVirtualPorts);\n\tdev_dbg(dev, \"%s - TotalPorts       %d\\n\", __func__, desc->TotalPorts);\nexit:\n\tkfree(rom_desc);\n\treturn status;\n}", "target": 0}
{"code": "static struct page **sev_pin_memory(struct kvm *kvm, unsigned long uaddr,\n\t\t\t\t    unsigned long ulen, unsigned long *n,\n\t\t\t\t    int write)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tunsigned long npages, size;\n\tint npinned;\n\tunsigned long locked, lock_limit;\n\tstruct page **pages;\n\tunsigned long first, last;\n\tint ret;\n\tif (ulen == 0 || uaddr + ulen < uaddr)\n\t\treturn ERR_PTR(-EINVAL);\n\tfirst = (uaddr & PAGE_MASK) >> PAGE_SHIFT;\n\tlast = ((uaddr + ulen - 1) & PAGE_MASK) >> PAGE_SHIFT;\n\tnpages = (last - first + 1);\n\tlocked = sev->pages_locked + npages;\n\tlock_limit = rlimit(RLIMIT_MEMLOCK) >> PAGE_SHIFT;\n\tif (locked > lock_limit && !capable(CAP_IPC_LOCK)) {\n\t\tpr_err(\"SEV: %lu locked pages exceed the lock limit of %lu.\\n\", locked, lock_limit);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tif (WARN_ON_ONCE(npages > INT_MAX))\n\t\treturn ERR_PTR(-EINVAL);\n\tsize = npages * sizeof(struct page *);\n\tif (size > PAGE_SIZE)\n\t\tpages = __vmalloc(size, GFP_KERNEL_ACCOUNT | __GFP_ZERO);\n\telse\n\t\tpages = kmalloc(size, GFP_KERNEL_ACCOUNT);\n\tif (!pages)\n\t\treturn ERR_PTR(-ENOMEM);\n\tnpinned = pin_user_pages_fast(uaddr, npages, write ? FOLL_WRITE : 0, pages);\n\tif (npinned != npages) {\n\t\tpr_err(\"SEV: Failure locking %lu pages.\\n\", npages);\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\t*n = npages;\n\tsev->pages_locked = locked;\n\treturn pages;\nerr:\n\tif (npinned > 0)\n\t\tunpin_user_pages(pages, npinned);\n\tkvfree(pages);\n\treturn ERR_PTR(ret);\n}", "target": 0}
{"code": "coolkey_get_public_key(sc_pkcs15_card_t *p15card, sc_cardctl_coolkey_object_t *obj, CK_KEY_TYPE key_type)\n{\n\tsc_pkcs15_pubkey_t *key;\n\tkey = coolkey_make_public_key(p15card->card, obj, key_type);\n\tif (key) {\n\t\treturn key;\n\t}\n\treturn coolkey_get_public_key_from_certificate(p15card, obj);\n}", "target": 0}
{"code": "static Token *make_tok_num(Token *next, int64_t val)\n{\n    char numbuf[32];\n    int len = snprintf(numbuf, sizeof(numbuf), \"%\"PRId64\"\", val);\n    return new_Token(next, TOK_NUMBER, numbuf, len);\n}", "target": 0}
{"code": "int kvm_inject_realmode_interrupt(struct kvm_vcpu *vcpu, int irq, int inc_eip)\n{\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tint ret;\n\tinit_emulate_ctxt(vcpu);\n\tctxt->op_bytes = 2;\n\tctxt->ad_bytes = 2;\n\tctxt->_eip = ctxt->eip + inc_eip;\n\tret = emulate_int_real(ctxt, irq);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn EMULATE_FAIL;\n\tctxt->eip = ctxt->_eip;\n\tkvm_rip_write(vcpu, ctxt->eip);\n\tkvm_set_rflags(vcpu, ctxt->eflags);\n\tif (irq == NMI_VECTOR)\n\t\tvcpu->arch.nmi_pending = 0;\n\telse\n\t\tvcpu->arch.interrupt.pending = false;\n\treturn EMULATE_DONE;\n}", "target": 0}
{"code": "static int x509_info_subject_alt_name( char **buf, size_t *size,\n                                       const mbedtls_x509_sequence *subject_alt_name )\n{\n    size_t i;\n    size_t n = *size;\n    char *p = *buf;\n    const mbedtls_x509_sequence *cur = subject_alt_name;\n    const char *sep = \"\";\n    size_t sep_len = 0;\n    while( cur != NULL )\n    {\n        if( cur->buf.len + sep_len >= n )\n        {\n            *p = '\\0';\n            return( MBEDTLS_ERR_X509_BUFFER_TOO_SMALL );\n        }\n        n -= cur->buf.len + sep_len;\n        for( i = 0; i < sep_len; i++ )\n            *p++ = sep[i];\n        for( i = 0; i < cur->buf.len; i++ )\n            *p++ = cur->buf.p[i];\n        sep = \", \";\n        sep_len = 2;\n        cur = cur->next;\n    }\n    *p = '\\0';\n    *size = n;\n    *buf = p;\n    return( 0 );\n}", "target": 0}
{"code": "    Classifier (const char *&ptr, int size)\n    {\n        if (size <= 0) \n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (truncated rule).\");\n        {\n            char suffix[Name::SIZE+1];\n            memset (suffix, 0, Name::SIZE+1);\n            Xdr::read<CharPtrIO> (ptr, std::min(size, Name::SIZE-1), suffix);\n            _suffix = std::string(suffix);\n        }\n        if (static_cast<size_t>(size) < _suffix.length() + 1 + 2*Xdr::size<char>()) \n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (truncated rule).\");\n        char value;\n        Xdr::read<CharPtrIO> (ptr, value);\n        _cscIdx = (int)(value >> 4) - 1;\n        if (_cscIdx < -1 || _cscIdx >= 3) \n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (corrupt cscIdx rule).\");\n        _scheme = (CompressorScheme)((value >> 2) & 3);\n        if (_scheme < 0 || _scheme >= NUM_COMPRESSOR_SCHEMES) \n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (corrupt scheme rule).\");\n        _caseInsensitive = (value & 1 ? true : false);\n        Xdr::read<CharPtrIO> (ptr, value);\n        if (value < 0 || value >= NUM_PIXELTYPES) \n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (corrupt rule).\");\n        _type = (PixelType)value;\n    }", "target": 0}
{"code": "static void mctp_serial_uninit(struct net_device *ndev)\n{\n\tstruct mctp_serial *dev = netdev_priv(ndev);\n\tcancel_work_sync(&dev->tx_work);\n}", "target": 0}
{"code": "PHP_FUNCTION(locale_parse)\n{\n    const char* loc_name        = NULL;\n    int         loc_name_len    = 0;\n    int         grOffset    \t= 0;\n    intl_error_reset( NULL TSRMLS_CC );\n    if(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, \"s\",\n        &loc_name, &loc_name_len ) == FAILURE)\n    {\n        intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n             \"locale_parse: unable to parse input params\", 0 TSRMLS_CC );\n        RETURN_FALSE;\n    }\n    if(loc_name_len == 0) {\n        loc_name = intl_locale_get_default(TSRMLS_C);\n    }\n\tarray_init( return_value );\n\tgrOffset =  findOffset( LOC_GRANDFATHERED , loc_name );\n\tif( grOffset >= 0 ){\n\t\tadd_assoc_string( return_value , LOC_GRANDFATHERED_LANG_TAG , estrdup(loc_name) ,FALSE );\n\t}\n\telse{\n\t\tadd_array_entry( loc_name , return_value , LOC_LANG_TAG TSRMLS_CC);\n\t\tadd_array_entry( loc_name , return_value , LOC_SCRIPT_TAG TSRMLS_CC);\n\t\tadd_array_entry( loc_name , return_value , LOC_REGION_TAG TSRMLS_CC);\n\t\tadd_array_entry( loc_name , return_value , LOC_VARIANT_TAG TSRMLS_CC);\n\t\tadd_array_entry( loc_name , return_value , LOC_PRIVATE_TAG TSRMLS_CC);\n\t}\n}", "target": 0}
{"code": "JankTimeBomb::JankTimeBomb(base::TimeDelta duration)\n    : weak_ptr_factory_(this) {\n  if (IsEnabled()) {\n    WatchDogThread::PostDelayedTask(\n        FROM_HERE,\n        base::Bind(&JankTimeBomb::Alarm,\n                   weak_ptr_factory_.GetWeakPtr(),\n                   base::PlatformThread::CurrentId()),\n        duration);\n  }\n}", "target": 0}
{"code": "getSystemTempDir() {\n\tconst char *temp_dir = getenv(\"PASSENGER_TEMP_DIR\");\n\tif (temp_dir == NULL || *temp_dir == '\\0') {\n\t\ttemp_dir = getenv(\"PASSENGER_TMPDIR\");\n\t\tif (temp_dir == NULL || *temp_dir == '\\0') {\n\t\t\ttemp_dir = \"/tmp\";\n\t\t}\n\t}\n\treturn temp_dir;\n}", "target": 0}
{"code": "cifs_find_smb_ses(struct TCP_Server_Info *server, char *username)\n{\n\tstruct list_head *tmp;\n\tstruct cifsSesInfo *ses;\n\twrite_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &server->smb_ses_list) {\n\t\tses = list_entry(tmp, struct cifsSesInfo, smb_ses_list);\n\t\tif (strncmp(ses->userName, username, MAX_USERNAME_SIZE))\n\t\t\tcontinue;\n\t\t++ses->ses_count;\n\t\twrite_unlock(&cifs_tcp_ses_lock);\n\t\treturn ses;\n\t}\n\twrite_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}", "target": 1}
{"code": "get_cdtext_generic (void *p_user_data)\n{\n  generic_img_private_t *p_env = p_user_data;\n  uint8_t *p_cdtext_data = NULL;\n  size_t  len;\n  if (!p_env) return NULL;\n  if (p_env->b_cdtext_error) return NULL;\n  if (NULL == p_env->cdtext) {\n    p_cdtext_data = read_cdtext_generic (p_env);\n    if (NULL != p_cdtext_data) {\n      len = CDIO_MMC_GET_LEN16(p_cdtext_data)-2;\n      p_env->cdtext = cdtext_init();\n      if(len <= 0 || 0 != cdtext_data_init (p_env->cdtext, &p_cdtext_data[4], len)) {\n        p_env->b_cdtext_error = true;\n        free(p_env->cdtext);\n        p_env->cdtext = NULL;\n      }\n      free(p_cdtext_data);\n    }\n  }\n  return p_env->cdtext;\n}", "target": 1}
{"code": "static int ioapic_mmio_read(struct kvm_io_device *this, gpa_t addr, int len,\n\t\t\t    void *val)\n{\n\tstruct kvm_ioapic *ioapic = to_ioapic(this);\n\tu32 result;\n\tif (!ioapic_in_range(ioapic, addr))\n\t\treturn -EOPNOTSUPP;\n\tioapic_debug(\"addr %lx\\n\", (unsigned long)addr);\n\tASSERT(!(addr & 0xf));\t\n\taddr &= 0xff;\n\tspin_lock(&ioapic->lock);\n\tswitch (addr) {\n\tcase IOAPIC_REG_SELECT:\n\t\tresult = ioapic->ioregsel;\n\t\tbreak;\n\tcase IOAPIC_REG_WINDOW:\n\t\tresult = ioapic_read_indirect(ioapic, addr, len);\n\t\tbreak;\n\tdefault:\n\t\tresult = 0;\n\t\tbreak;\n\t}\n\tspin_unlock(&ioapic->lock);\n\tswitch (len) {\n\tcase 8:\n\t\t*(u64 *) val = result;\n\t\tbreak;\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\t\tmemcpy(val, (char *)&result, len);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"ioapic: wrong length %d\\n\", len);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "SYSCALL_DEFINE1(timer_getoverrun, timer_t, timer_id)\n{\n\tstruct k_itimer *timr;\n\tint overrun;\n\tunsigned long flags;\n\ttimr = lock_timer(timer_id, &flags);\n\tif (!timr)\n\t\treturn -EINVAL;\n\toverrun = timr->it_overrun_last;\n\tunlock_timer(timr, flags);\n\treturn overrun;\n}", "target": 1}
{"code": "init_ctx_nego(OM_uint32 *minor_status, spnego_gss_ctx_id_t sc,\n\t      OM_uint32 acc_negState, gss_OID supportedMech,\n\t      gss_buffer_t *responseToken, gss_buffer_t *mechListMIC,\n\t      OM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 ret;\n\t*negState = REJECT;\n\t*tokflag = ERROR_TOKEN_SEND;\n\tret = GSS_S_DEFECTIVE_TOKEN;\n\tif (supportedMech == GSS_C_NO_OID) {\n\t\t*minor_status = ERR_SPNEGO_NO_MECH_FROM_ACCEPTOR;\n\t\tmap_errcode(minor_status);\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t}\n\tif (acc_negState == ACCEPT_DEFECTIVE_TOKEN) {\n\t\t*minor_status = ERR_SPNEGO_NEGOTIATION_FAILED;\n\t\tmap_errcode(minor_status);\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t}\n\tif (!(is_kerb_mech(supportedMech) &&\n\t      is_kerb_mech(sc->internal_mech)) &&\n\t    !g_OID_equal(supportedMech, sc->internal_mech)) {\n\t\tret = init_ctx_reselect(minor_status, sc,\n\t\t\t\t\tacc_negState, supportedMech,\n\t\t\t\t\tresponseToken, mechListMIC,\n\t\t\t\t\tnegState, tokflag);\n\t} else if (*responseToken == GSS_C_NO_BUFFER) {\n\t\tif (sc->mech_complete) {\n\t\t\t*negState = ACCEPT_COMPLETE;\n\t\t\t*tokflag = NO_TOKEN_SEND;\n\t\t\tret = GSS_S_COMPLETE;\n\t\t} else {\n\t\t\t*minor_status = ERR_SPNEGO_NO_TOKEN_FROM_ACCEPTOR;\n\t\t\tmap_errcode(minor_status);\n\t\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\t}\n\t} else if ((*responseToken)->length == 0 && sc->mech_complete) {\n\t\t*negState = ACCEPT_COMPLETE;\n\t\t*tokflag = NO_TOKEN_SEND;\n\t\tret = GSS_S_COMPLETE;\n\t} else if (sc->mech_complete) {\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t} else {\n\t\t*negState = ACCEPT_INCOMPLETE;\n\t\t*tokflag = CONT_TOKEN_SEND;\n\t\tret = GSS_S_CONTINUE_NEEDED;\n\t}\n\tsc->nego_done = 1;\n\treturn ret;\n}", "target": 0}
{"code": "build_model(XML_Parser parser) {\n  DTD *const dtd = parser->m_dtd; \n  XML_Content *ret;\n  XML_Char *str; \n#if UINT_MAX >= SIZE_MAX\n  if (dtd->scaffCount > (size_t)(-1) / sizeof(XML_Content)) {\n    return NULL;\n  }\n  if (dtd->contentStringLen > (size_t)(-1) / sizeof(XML_Char)) {\n    return NULL;\n  }\n#endif\n  if (dtd->scaffCount * sizeof(XML_Content)\n      > (size_t)(-1) - dtd->contentStringLen * sizeof(XML_Char)) {\n    return NULL;\n  }\n  const size_t allocsize = (dtd->scaffCount * sizeof(XML_Content)\n                            + (dtd->contentStringLen * sizeof(XML_Char)));\n  ret = (XML_Content *)MALLOC(parser, allocsize);\n  if (! ret)\n    return NULL;\n  XML_Content *dest = ret; \n  XML_Content *const destLimit = &ret[dtd->scaffCount];\n  XML_Content *const stackBottom = &ret[dtd->scaffCount];\n  XML_Content *stackTop = stackBottom; \n  str = (XML_Char *)&ret[dtd->scaffCount];\n  (--stackTop)->numchildren = 0;\n  for (; dest < destLimit; dest++) {\n    const int src_node = (int)(stackTop++)->numchildren;\n    dest->type = dtd->scaffold[src_node].type;\n    dest->quant = dtd->scaffold[src_node].quant;\n    if (dest->type == XML_CTYPE_NAME) {\n      const XML_Char *src;\n      dest->name = str;\n      src = dtd->scaffold[src_node].name;\n      for (;;) {\n        *str++ = *src;\n        if (! *src)\n          break;\n        src++;\n      }\n      dest->numchildren = 0;\n      dest->children = NULL;\n    } else {\n      unsigned int i;\n      int cn;\n      dest->name = NULL;\n      dest->numchildren = dtd->scaffold[src_node].childcnt;\n      dest->children = &dest[1];\n      stackTop -= dest->numchildren;\n      for (i = 0, cn = dtd->scaffold[src_node].firstchild;\n           i < dest->numchildren; i++, cn = dtd->scaffold[cn].nextsib) {\n        (stackTop + i)->numchildren = (unsigned int)cn;\n      }\n    }\n  }\n  return ret;\n}", "target": 0}
{"code": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\tif (inode_capable(inode, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}", "target": 1}
{"code": "l_strnstart(const char *tstr1, u_int tl1, const char *str2, u_int l2)\n{\n\tif (tl1 > l2)\n\t\treturn 0;\n\treturn (strncmp(tstr1, str2, tl1) == 0 ? 1 : 0);\n}", "target": 1}
{"code": "void scheduler_tick(void)\n{\n\tint cpu = smp_processor_id();\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct task_struct *curr = rq->curr;\n\tsched_clock_tick();\n\traw_spin_lock(&rq->lock);\n\tupdate_rq_clock(rq);\n\tcurr->sched_class->task_tick(rq, curr, 0);\n\tupdate_cpu_load_active(rq);\n\tcalc_global_load_tick(rq);\n\traw_spin_unlock(&rq->lock);\n\tperf_event_task_tick();\n#ifdef CONFIG_SMP\n\trq->idle_balance = idle_cpu(cpu);\n\ttrigger_load_balance(rq);\n#endif\n\trq_last_tick_reset(rq);\n}", "target": 0}
{"code": "    void TiffImage::readMetadata()\n    {\n#ifdef DEBUG\n        std::cerr << \"Reading TIFF file \" << io_->path() << \"\\n\";\n#endif\n        if (io_->open() != 0) throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        IoCloser closer(*io_);\n        if (!isTiffType(*io_, false)) {\n            if (io_->error() || io_->eof()) throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAnImage, \"TIFF\");\n        }\n        clearMetadata();\n        ByteOrder bo = TiffParser::decode(exifData_,\n                                          iptcData_,\n                                          xmpData_,\n                                          io_->mmap(),\n                                          (uint32_t) io_->size());\n        setByteOrder(bo);\n        Exiv2::ExifKey            key(\"Exif.Image.InterColorProfile\");\n        Exiv2::ExifData::iterator pos   = exifData_.findKey(key);\n        if ( pos != exifData_.end()  ) {\n            iccProfile_.alloc(pos->count()*pos->typeSize());\n            pos->copy(iccProfile_.pData_,bo);\n        }\n    } ", "target": 1}
{"code": "static int host_start(struct ci13xxx *ci)\n{\n\tstruct usb_hcd *hcd;\n\tstruct ehci_hcd *ehci;\n\tint ret;\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\thcd = usb_create_hcd(&ci_ehci_hc_driver, ci->dev, dev_name(ci->dev));\n\tif (!hcd)\n\t\treturn -ENOMEM;\n\tdev_set_drvdata(ci->dev, ci);\n\thcd->rsrc_start = ci->hw_bank.phys;\n\thcd->rsrc_len = ci->hw_bank.size;\n\thcd->regs = ci->hw_bank.abs;\n\thcd->has_tt = 1;\n\thcd->power_budget = ci->platdata->power_budget;\n\thcd->phy = ci->transceiver;\n\tehci = hcd_to_ehci(hcd);\n\tehci->caps = ci->hw_bank.cap;\n\tehci->has_hostpc = ci->hw_bank.lpm;\n\tret = usb_add_hcd(hcd, 0, 0);\n\tif (ret)\n\t\tusb_put_hcd(hcd);\n\telse\n\t\tci->hcd = hcd;\n\tif (ci->platdata->flags & CI13XXX_DISABLE_STREAMING)\n\t\thw_write(ci, OP_USBMODE, USBMODE_CI_SDIS, USBMODE_CI_SDIS);\n\treturn ret;\n}", "target": 0}
{"code": "static int nf_tables_set_alloc_name(struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t\t    const char *name)\n{\n\tconst struct nft_set *i;\n\tconst char *p;\n\tunsigned long *inuse;\n\tunsigned int n = 0, min = 0;\n\tp = strnchr(name, IFNAMSIZ, '%');\n\tif (p != NULL) {\n\t\tif (p[1] != 'd' || strchr(p + 2, '%'))\n\t\t\treturn -EINVAL;\n\t\tinuse = (unsigned long *)get_zeroed_page(GFP_KERNEL);\n\t\tif (inuse == NULL)\n\t\t\treturn -ENOMEM;\ncont:\n\t\tlist_for_each_entry(i, &ctx->table->sets, list) {\n\t\t\tint tmp;\n\t\t\tif (!sscanf(i->name, name, &tmp))\n\t\t\t\tcontinue;\n\t\t\tif (tmp < min || tmp >= min + BITS_PER_BYTE * PAGE_SIZE)\n\t\t\t\tcontinue;\n\t\t\tset_bit(tmp - min, inuse);\n\t\t}\n\t\tn = find_first_zero_bit(inuse, BITS_PER_BYTE * PAGE_SIZE);\n\t\tif (n >= BITS_PER_BYTE * PAGE_SIZE) {\n\t\t\tmin += BITS_PER_BYTE * PAGE_SIZE;\n\t\t\tmemset(inuse, 0, PAGE_SIZE);\n\t\t\tgoto cont;\n\t\t}\n\t\tfree_page((unsigned long)inuse);\n\t}\n\tsnprintf(set->name, sizeof(set->name), name, min + n);\n\tlist_for_each_entry(i, &ctx->table->sets, list) {\n\t\tif (!strcmp(set->name, i->name))\n\t\t\treturn -ENFILE;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void InstanceKlass::set_implementor(Klass* k) {\n  assert_lock_strong(Compile_lock);\n  assert(is_interface(), \"not interface\");\n  Klass** addr = adr_implementor();\n  assert(addr != NULL, \"null addr\");\n  if (addr != NULL) {\n    *addr = k;\n  }\n}", "target": 0}
{"code": "static int can_open_delegated(struct nfs_delegation *delegation, mode_t open_flags)\n{\n\tif ((delegation->type & open_flags) != open_flags)\n\t\treturn 0;\n\tif (test_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags))\n\t\treturn 0;\n\tnfs_mark_delegation_referenced(delegation);\n\treturn 1;\n}", "target": 1}
{"code": "lsquic_qeh_settings (struct qpack_enc_hdl *qeh, unsigned max_table_size,\n             unsigned dyn_table_size, unsigned max_risked_streams, int server)\n{\n    enum lsqpack_enc_opts enc_opts;\n    assert(qeh->qeh_flags & QEH_INITIALIZED);\n    if (qeh->qeh_flags & QEH_HAVE_SETTINGS)\n    {\n        LSQ_WARN(\"settings already set\");\n        return -1;\n    }\n    enc_opts = LSQPACK_ENC_OPT_STAGE_2\n             | (server ? LSQPACK_ENC_OPT_SERVER : 0);\n    qeh->qeh_tsu_sz = sizeof(qeh->qeh_tsu_buf);\n    if (QENC_MIN_DYN_TABLE_SIZE > dyn_table_size)\n        dyn_table_size = 0;\n    if (0 != lsqpack_enc_init(&qeh->qeh_encoder, (void *) qeh->qeh_conn,\n                max_table_size, dyn_table_size, max_risked_streams, enc_opts,\n                qeh->qeh_tsu_buf, &qeh->qeh_tsu_sz))\n    {\n        LSQ_INFO(\"could not initialize QPACK encoder\");\n        return -1;\n    }\n    LSQ_DEBUG(\"%zu-byte post-init TSU\", qeh->qeh_tsu_sz);\n    qeh->qeh_flags |= QEH_HAVE_SETTINGS;\n    qeh->qeh_max_prefix_size =\n                        lsqpack_enc_header_block_prefix_size(&qeh->qeh_encoder);\n    LSQ_DEBUG(\"have settings: max table size=%u; dyn table size=%u; max risked \"\n        \"streams=%u\", max_table_size, dyn_table_size, max_risked_streams);\n    if (qeh->qeh_enc_sm_out)\n        qeh_begin_out(qeh);\n    return 0;\n}", "target": 0}
{"code": "static int exif_file_sections_add(image_info_type *ImageInfo, int type, size_t size, uchar *data)\n{\n\tfile_section    *tmp;\n\tint             count = ImageInfo->file.count;\n\ttmp = safe_erealloc(ImageInfo->file.list, (count+1), sizeof(file_section), 0);\n\tImageInfo->file.list = tmp;\n\tImageInfo->file.list[count].type = 0xFFFF;\n\tImageInfo->file.list[count].data = NULL;\n\tImageInfo->file.list[count].size = 0;\n\tImageInfo->file.count = count+1;\n\tif (!size) {\n\t\tdata = NULL;\n\t} else if (data == NULL) {\n\t\tdata = safe_emalloc(size, 1, 0);\n\t}\n\tImageInfo->file.list[count].type = type;\n\tImageInfo->file.list[count].data = data;\n\tImageInfo->file.list[count].size = size;\n\treturn count;\n}", "target": 0}
{"code": "create_policy_2_svc(cpol_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->rec.policy;\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_ADD, NULL, NULL)) {\n        ret.code = KADM5_AUTH_ADD;\n        log_unauth(\"kadm5_create_policy\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_create_policy((void *)handle, &arg->rec,\n                                       arg->mask);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_create_policy\",\n                 ((prime_arg == NULL) ? \"(null)\" : prime_arg), errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "static int _FVMenuClose(FontView *fv) {\n    int i;\n    SplineFont *sf = fv->b.cidmaster?fv->b.cidmaster:fv->b.sf;\n    if ( !SFCloseAllInstrs(fv->b.sf) )\nreturn( false );\n    if ( fv->b.nextsame!=NULL || fv->b.sf->fv!=&fv->b ) {\n    } else if ( warn_script_unsaved && fv->script_unsaved && \n                AskScriptChanged()==2 ) {\n        return false;\n    } else if ( SFAnyChanged(sf) ) {\n\ti = AskChanged(fv->b.sf);\n\tif ( i==2 )\t\nreturn( false );\n\tif ( i==0 && !_FVMenuSave(fv))\t\t\nreturn(false);\n\telse\n\t    SFClearAutoSave(sf);\t\t\n    }\n    _FVCloseWindows(fv);\n    if ( sf->filename!=NULL )\n\tRecentFilesRemember(sf->filename);\n    else if ( sf->origname!=NULL )\n\tRecentFilesRemember(sf->origname);\n    GDrawDestroyWindow(fv->gw);\nreturn( true );\n}", "target": 0}
{"code": "int64_t OutputFile::readImpl(char* , int64_t ) {\n  raise_warning(\"cannot read from a php:\n  return -1;\n}", "target": 1}
{"code": "sec_connect(char *server, char *username, char *domain, char *password, RD_BOOL reconnect)\n{\n\tuint32 selected_proto;\n\tstruct stream mcs_data;\n\tif (!mcs_connect_start(server, username, domain, password, reconnect, &selected_proto))\n\t\treturn False;\n\tmcs_data.size = 512;\n\tmcs_data.p = mcs_data.data = (uint8 *) xmalloc(mcs_data.size);\n\tsec_out_mcs_data(&mcs_data, selected_proto);\n\tif (!mcs_connect_finalize(&mcs_data))\n\t\treturn False;\n\tif (g_encryption)\n\t\tsec_establish_key();\n\txfree(mcs_data.data);\n\treturn True;\n}", "target": 0}
{"code": "static apr_status_t lua_websocket_readbytes(conn_rec* c, char* buffer, \n        apr_off_t len) \n{\n    apr_bucket_brigade *brigade = apr_brigade_create(c->pool, c->bucket_alloc);\n    apr_status_t rv;\n    rv = ap_get_brigade(c->input_filters, brigade, AP_MODE_READBYTES, \n            APR_BLOCK_READ, len);\n    if (rv == APR_SUCCESS) {\n        if (!APR_BRIGADE_EMPTY(brigade)) {\n            apr_bucket* bucket = APR_BRIGADE_FIRST(brigade);\n            const char* data = NULL;\n            apr_size_t data_length = 0;\n            rv = apr_bucket_read(bucket, &data, &data_length, APR_BLOCK_READ);\n            if (rv == APR_SUCCESS) {\n                memcpy(buffer, data, len);\n            }\n            apr_bucket_delete(bucket);\n        }\n    }\n    apr_brigade_cleanup(brigade);\n    return rv;\n}", "target": 0}
{"code": "strncmpic(uschar *s, uschar *t, int n)\n{\nwhile (n--)\n  {\n  int c = tolower(*s++) - tolower(*t++);\n  if (c) return c;\n  }\nreturn 0;\n}", "target": 0}
{"code": "void ChildThread::OnChannelError() {\n  set_on_channel_error_called(true);\n  base::MessageLoop::current()->Quit();\n}", "target": 0}
{"code": "int nntp_add_group(char *line, void *data)\n{\n  struct NntpServer *nserv = data;\n  struct NntpData *nntp_data = NULL;\n  char group[LONG_STRING];\n  char desc[HUGE_STRING] = \"\";\n  char mod;\n  anum_t first, last;\n  if (!nserv || !line)\n    return 0;\n  if (sscanf(line, \"%s \" ANUM \" \" ANUM \" %c %[^\\n]\", group, &last, &first, &mod, desc) < 4)\n    return 0;\n  nntp_data = nntp_data_find(nserv, group);\n  nntp_data->deleted = false;\n  nntp_data->first_message = first;\n  nntp_data->last_message = last;\n  nntp_data->allowed = (mod == 'y') || (mod == 'm');\n  mutt_str_replace(&nntp_data->desc, desc);\n  if (nntp_data->newsrc_ent || nntp_data->last_cached)\n    nntp_group_unread_stat(nntp_data);\n  else if (nntp_data->last_message && nntp_data->first_message <= nntp_data->last_message)\n    nntp_data->unread = nntp_data->last_message - nntp_data->first_message + 1;\n  else\n    nntp_data->unread = 0;\n  return 0;\n}", "target": 1}
{"code": "static BOOL nsc_rle_decompress_data(NSC_CONTEXT* context)\n{\n\tif (!context)\n\t\treturn FALSE;\n\tBYTE* rle = context->Planes;\n\tWINPR_ASSERT(rle);\n\tfor (size_t i = 0; i < 4; i++)\n\t{\n\t\tconst UINT32 originalSize = context->OrgByteCount[i];\n\t\tconst UINT32 planeSize = context->PlaneByteCount[i];\n\t\tif (planeSize == 0)\n\t\t{\n\t\t\tif (context->priv->PlaneBuffersLength < originalSize)\n\t\t\t\treturn FALSE;\n\t\t\tFillMemory(context->priv->PlaneBuffers[i], originalSize, 0xFF);\n\t\t}\n\t\telse if (planeSize < originalSize)\n\t\t{\n\t\t\tif (!nsc_rle_decode(rle, context->priv->PlaneBuffers[i],\n\t\t\t                    context->priv->PlaneBuffersLength, originalSize))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (context->priv->PlaneBuffersLength < originalSize)\n\t\t\t\treturn FALSE;\n\t\t\tCopyMemory(context->priv->PlaneBuffers[i], rle, originalSize);\n\t\t}\n\t\trle += planeSize;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "static void mdbEvalSetColumn(MyDbEvalContext *p, int iCol, Jsi_DString *dStr) {\n    char nbuf[200];\n    MysqlPrep *prep = p->prep;\n    SqlFieldResults *field = prep->fieldResult+iCol;\n    Jsi_Interp *interp = p->jdb->interp;\n    if (field->isnull)\n        return;\n    switch(field->jsiTypeMap) {\n        case JSI_OPTION_STRING: {\n            int bytes = field->len;\n            const char *zBlob = field->buffer.vstring;\n            if( !zBlob ) {\n                const char *nv = p->jdb->optPtr->nullvalue;\n                Jsi_DSAppend(dStr, nv?nv:\"null\", NULL);\n                return;\n            }\n            Jsi_DSAppendLen(dStr, zBlob, bytes);\n            return;\n        }\n        case JSI_OPTION_BOOL: {\n            snprintf(nbuf, sizeof(nbuf), \"%s\", field->buffer.vchar?\"true\":\"false\");\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        case JSI_OPTION_INT64: {\n            snprintf(nbuf, sizeof(nbuf), \"%lld\", field->buffer.vlonglong);\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        case JSI_OPTION_TIME_D:\n        case JSI_OPTION_TIME_W: {\n            Jsi_Number jtime = mdbMyTimeToJS(&field->buffer.timestamp);\n            Jsi_NumberToString(interp, jtime, nbuf, sizeof(nbuf));\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        case JSI_OPTION_DOUBLE: {\n            Jsi_NumberToString(interp, field->buffer.vdouble, nbuf, sizeof(nbuf));\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        default:\n            Jsi_LogWarn(\"unknown type: %d\", field->jsiTypeMap);\n    }\n}", "target": 1}
{"code": "unsigned int _gnutls_x509_verify_certificate(\n    const gnutls_x509_crt_t *certificate_list, int clist_size,\n    const gnutls_x509_crt_t *trusted_cas, int tcas_size,\n    const gnutls_x509_crl_t *CRLs, int crls_size,\n    unsigned int flags)\n{\n    int i = 0, ret;\n    unsigned int status = 0, output;\n    ret =\n\t_gnutls_verify_certificate2(certificate_list[clist_size-1], \n\t    trusted_cas, tcas_size, flags, &output);\n    if (ret == 0) {\n\tgnutls_assert();\n\tstatus |= output;\n\tstatus |= GNUTLS_CERT_INVALID;\n\treturn status;\n    }\n#ifdef ENABLE_PKI\n    for (i = 0; i < clist_size; i++) {\n\tret = gnutls_x509_crt_check_revocation(certificate_list[i],\n\t\t\t\t\t       CRLs, crls_size);\n\tif (ret == 1) {\t\t\n\t    status |= GNUTLS_CERT_REVOKED;\n\t    status |= GNUTLS_CERT_INVALID;\n\t    return status;\n\t}\n    }\n#endif\n    for (i = clist_size-1; i > 0; i--) {\n\tif (i - 1 < 0)\n\t    break;\n        flags ^= GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT;\n\tif ((ret =\n\t     _gnutls_verify_certificate2(certificate_list[i-1],\n                  &certificate_list[i], 1, flags, NULL)) == 0) {\n\t    status |= GNUTLS_CERT_INVALID;\n\t    return status;\n\t}\n    }\n    return 0;\n}", "target": 0}
{"code": "static inline uint8_t ok_read_uint8(ok_jpg_decoder *decoder) {\n    if (decoder->input_buffer_start == decoder->input_buffer_end) {\n        size_t len = decoder->input.read(decoder->input_user_data, decoder->input_buffer,\n                                         sizeof(decoder->input_buffer));\n        decoder->input_buffer_start = decoder->input_buffer;\n        decoder->input_buffer_end = decoder->input_buffer + len;\n        if (len == 0) {\n            return 0;\n        }\n    }\n    return *decoder->input_buffer_start++;\n}", "target": 0}
{"code": "static inline RBinWasmCustomNameLocalName *parse_local_name(RBuffer *b, ut64 bound) {\n\tRBinWasmCustomNameLocalName *local_name = R_NEW0 (RBinWasmCustomNameLocalName);\n\tif (local_name) {\n\t\tif (!consume_u32_r (b, bound, &local_name->index)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tlocal_name->names = r_id_storage_new (0, UT32_MAX);\n\t\tif (!local_name->names) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (!parse_namemap (b, bound, local_name->names, &local_name->names_count)) {\n\t\t\tgoto beach;\n\t\t}\n\t\treturn local_name;\n\t}\nbeach:\n\twasm_custom_name_local_free (local_name);\n\treturn NULL;\n}", "target": 0}
{"code": "yang_deviate_delete_unique(struct lys_module *module, struct lys_deviate *deviate,\n                           struct lys_node_list *list, int index, char * value)\n{\n    struct ly_ctx *ctx = module->ctx;\n    int i, j, k;\n    for (i = 0; i < list->unique_size; i++) {\n        if (list->unique[i].expr_size != deviate->unique[index].expr_size) {\n            continue;\n        }\n        for (j = 0; j < deviate->unique[index].expr_size; j++) {\n            if (!ly_strequal(list->unique[i].expr[j], deviate->unique[index].expr[j], 1)) {\n                break;\n            }\n        }\n        if (j == deviate->unique[index].expr_size) {\n            for (j = 0; j < list->unique[i].expr_size; j++) {\n                lydict_remove(ctx, list->unique[i].expr[j]);\n            }\n            free(list->unique[i].expr);\n            list->unique_size--;\n            if (i != list->unique_size) {\n                list->unique[i].expr_size = list->unique[list->unique_size].expr_size;\n                list->unique[i].expr = list->unique[list->unique_size].expr;\n            }\n            if (!list->unique_size) {\n                free(list->unique);\n                list->unique = NULL;\n            } else {\n                list->unique[list->unique_size].expr_size = 0;\n                list->unique[list->unique_size].expr = NULL;\n            }\n            k = i; \n            i = -1; \n            break;\n        }\n    }\n    if (i != -1) {\n        LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"unique\");\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Value differs from the target being deleted.\");\n        return EXIT_FAILURE;\n    }\n    j = -1;\n    while ((j = lys_ext_iter(list->ext, list->ext_size, j + 1, LYEXT_SUBSTMT_UNIQUE)) != -1) {\n        if (list->ext[j]->insubstmt_index == k) {\n            lyp_ext_instance_rm(ctx, &list->ext, &list->ext_size, j);\n            --j;\n        } else if (list->ext[j]->insubstmt_index > k) {\n            list->ext[j]->insubstmt_index--;\n        }\n    }\n    return EXIT_SUCCESS;\n}", "target": 0}
{"code": "void RGWCORSRule::format_exp_headers(string& s) {\n  s = \"\";\n  for(list<string>::iterator it = exposable_hdrs.begin();\n      it != exposable_hdrs.end(); ++it) {\n      if (s.length() > 0)\n        s.append(\",\");\n      s.append((*it));\n  }\n}", "target": 1}
{"code": "static bool FNAME(gpte_changed)(struct kvm_vcpu *vcpu,\n\t\t\t\tstruct guest_walker *gw, int level)\n{\n\tpt_element_t curr_pte;\n\tgpa_t base_gpa, pte_gpa = gw->pte_gpa[level - 1];\n\tu64 mask;\n\tint r, index;\n\tif (level == PT_PAGE_TABLE_LEVEL) {\n\t\tmask = PTE_PREFETCH_NUM * sizeof(pt_element_t) - 1;\n\t\tbase_gpa = pte_gpa & ~mask;\n\t\tindex = (pte_gpa - base_gpa) / sizeof(pt_element_t);\n\t\tr = kvm_vcpu_read_guest_atomic(vcpu, base_gpa,\n\t\t\t\tgw->prefetch_ptes, sizeof(gw->prefetch_ptes));\n\t\tcurr_pte = gw->prefetch_ptes[index];\n\t} else\n\t\tr = kvm_vcpu_read_guest_atomic(vcpu, pte_gpa,\n\t\t\t\t  &curr_pte, sizeof(curr_pte));\n\treturn r || curr_pte != gw->ptes[level - 1];\n}", "target": 0}
{"code": "static void cmd_authinfo_user(char *user)\n{\n    const char *p;\n    if (nntp_authstate) {\n\tprot_printf(nntp_out, \"502 Already authenticated\\r\\n\");\n\treturn;\n    }\n    if (!(nntp_starttls_done || (extprops_ssf > 1) ||\n\t  config_getswitch(IMAPOPT_ALLOWPLAINTEXT))) {\n\tprot_printf(nntp_out,\n\t\t    \"483 AUTHINFO USER command only available under a layer\\r\\n\");\n\treturn;\n    }\n    if (nntp_userid) {\n\tfree(nntp_userid);\n\tnntp_userid = NULL;\n    }\n    if (!(p = canonify_userid(user, NULL, NULL))) {\n\tprot_printf(nntp_out, \"481 Invalid user\\r\\n\");\n\tsyslog(LOG_NOTICE,\n\t       \"badlogin: %s plaintext %s invalid user\",\n\t       nntp_clienthost, beautify_string(user));\n    }\n    else {\n\tnntp_userid = xstrdup(p);\n\tprot_printf(nntp_out, \"381 Give AUTHINFO PASS command\\r\\n\");\n    }\n}", "target": 0}
{"code": "rfbBool ConnectToRFBRepeater(rfbClient* client,const char *repeaterHost, int repeaterPort, const char *destHost, int destPort)\n{\n  rfbProtocolVersionMsg pv;\n  int major,minor;\n  char tmphost[250];\n  int tmphostlen;\n#ifdef LIBVNCSERVER_IPv6\n  client->sock = ConnectClientToTcpAddr6(repeaterHost, repeaterPort);\n  if (client->sock == -1)\n#endif\n  {\n    unsigned int host;\n    if (!StringToIPAddr(repeaterHost, &host)) {\n      rfbClientLog(\"Couldn't convert '%s' to host address\\n\", repeaterHost);\n      return FALSE;\n    }\n    client->sock = ConnectClientToTcpAddr(host, repeaterPort);\n  }\n  if (client->sock < 0) {\n    rfbClientLog(\"Unable to connect to VNC repeater\\n\");\n    return FALSE;\n  }\n  if (!SetNonBlocking(client->sock))\n    return FALSE;\n  if (!ReadFromRFBServer(client, pv, sz_rfbProtocolVersionMsg))\n    return FALSE;\n  pv[sz_rfbProtocolVersionMsg] = 0;\n  if (sscanf(pv,rfbProtocolVersionFormat,&major,&minor) != 2 || major != 0 || minor != 0) {\n    rfbClientLog(\"Not a valid VNC repeater (%s)\\n\",pv);\n    return FALSE;\n  }\n  rfbClientLog(\"Connected to VNC repeater, using protocol version %d.%d\\n\", major, minor);\n  tmphostlen = snprintf(tmphost, sizeof(tmphost), \"%s:%d\", destHost, destPort);\n  if(tmphostlen < 0 || tmphostlen >= (int)sizeof(tmphost))\n    return FALSE; \n  if (!WriteToRFBServer(client, tmphost, tmphostlen + 1))\n    return FALSE;\n  return TRUE;\n}", "target": 0}
{"code": "static int bufp_alloc(USBRedirDevice *dev, uint8_t *data, uint16_t len,\n    uint8_t status, uint8_t ep, void *free_on_destroy)\n{\n    struct buf_packet *bufp;\n    if (!dev->endpoint[EP2I(ep)].bufpq_dropping_packets &&\n        dev->endpoint[EP2I(ep)].bufpq_size >\n            2 * dev->endpoint[EP2I(ep)].bufpq_target_size) {\n        DPRINTF(\"bufpq overflow, dropping packets ep %02X\\n\", ep);\n        dev->endpoint[EP2I(ep)].bufpq_dropping_packets = 1;\n    }\n    if (dev->endpoint[EP2I(ep)].bufpq_dropping_packets) {\n        if (dev->endpoint[EP2I(ep)].bufpq_size >\n                dev->endpoint[EP2I(ep)].bufpq_target_size) {\n            free(data);\n            return -1;\n        }\n        dev->endpoint[EP2I(ep)].bufpq_dropping_packets = 0;\n    }\n    bufp = g_new(struct buf_packet, 1);\n    bufp->data   = data;\n    bufp->len    = len;\n    bufp->offset = 0;\n    bufp->status = status;\n    bufp->free_on_destroy = free_on_destroy;\n    QTAILQ_INSERT_TAIL(&dev->endpoint[EP2I(ep)].bufpq, bufp, next);\n    dev->endpoint[EP2I(ep)].bufpq_size++;\n    return 0;\n}", "target": 1}
{"code": "static void labeljumps(JF, js_JumpList *jump, int baddr, int caddr)\n{\n\twhile (jump) {\n\t\tif (jump->type == STM_BREAK)\n\t\t\tlabelto(J, F, jump->inst, baddr);\n\t\tif (jump->type == STM_CONTINUE)\n\t\t\tlabelto(J, F, jump->inst, caddr);\n\t\tjump = jump->next;\n\t}\n}", "target": 1}
{"code": "void license_decrypt_platform_challenge(rdpLicense* license)\n{\n\tCryptoRc4 rc4;\n\tlicense->PlatformChallenge->data = (BYTE*) malloc(license->EncryptedPlatformChallenge->length);\n\tlicense->PlatformChallenge->length = license->EncryptedPlatformChallenge->length;\n\trc4 = crypto_rc4_init(license->LicensingEncryptionKey, LICENSING_ENCRYPTION_KEY_LENGTH);\n\tcrypto_rc4(rc4, license->EncryptedPlatformChallenge->length,\n\t\t\tlicense->EncryptedPlatformChallenge->data,\n\t\t\tlicense->PlatformChallenge->data);\n\tcrypto_rc4_free(rc4);\n}", "target": 0}
{"code": "v8::Local<v8::Object> CreateNativeEvent(\n    v8::Isolate* isolate,\n    v8::Local<v8::Object> sender,\n    content::RenderFrameHost* frame,\n    electron::mojom::ElectronBrowser::MessageSyncCallback callback) {\n  v8::Local<v8::Object> event;\n  if (frame && callback) {\n    gin::Handle<Event> native_event = Event::Create(isolate);\n    native_event->SetCallback(std::move(callback));\n    event = v8::Local<v8::Object>::Cast(native_event.ToV8());\n  } else {\n    event = CreateEvent(isolate);\n  }\n  Dictionary dict(isolate, event);\n  dict.Set(\"sender\", sender);\n  if (frame)\n    dict.Set(\"frameId\", frame->GetRoutingID());\n  return event;\n}", "target": 1}
{"code": "bool HeaderToMetadataFilter::addMetadata(StructMap& map, const std::string& meta_namespace,\n                                         const std::string& key, std::string value, ValueType type,\n                                         ValueEncode encode) const {\n  ProtobufWkt::Value val;\n  ASSERT(!value.empty());\n  if (value.size() >= MAX_HEADER_VALUE_LEN) {\n    ENVOY_LOG(debug, \"metadata value is too long\");\n    return false;\n  }\n  if (encode == envoy::extensions::filters::http::header_to_metadata::v3::Config::BASE64) {\n    value = Base64::decodeWithoutPadding(value);\n    if (value.empty()) {\n      ENVOY_LOG(debug, \"Base64 decode failed\");\n      return false;\n    }\n  }\n  switch (type) {\n  case envoy::extensions::filters::http::header_to_metadata::v3::Config::STRING:\n    val.set_string_value(std::move(value));\n    break;\n  case envoy::extensions::filters::http::header_to_metadata::v3::Config::NUMBER: {\n    double dval;\n    if (absl::SimpleAtod(StringUtil::trim(value), &dval)) {\n      val.set_number_value(dval);\n    } else {\n      ENVOY_LOG(debug, \"value to number conversion failed\");\n      return false;\n    }\n    break;\n  }\n  case envoy::extensions::filters::http::header_to_metadata::v3::Config::PROTOBUF_VALUE: {\n    if (!val.ParseFromString(value)) {\n      ENVOY_LOG(debug, \"parse from decoded string failed\");\n      return false;\n    }\n    break;\n  }\n  default:\n    NOT_REACHED_GCOVR_EXCL_LINE;\n  }\n  auto namespace_iter = map.find(meta_namespace);\n  if (namespace_iter == map.end()) {\n    map[meta_namespace] = ProtobufWkt::Struct();\n    namespace_iter = map.find(meta_namespace);\n  }\n  auto& keyval = namespace_iter->second;\n  (*keyval.mutable_fields())[key] = val;\n  return true;\n}", "target": 0}
{"code": "static int log_access_ok(void __user *log_base, u64 addr, unsigned long sz)\n{\n\tu64 a = addr / VHOST_PAGE_SIZE / 8;\n\tif (a > ULONG_MAX - (unsigned long)log_base ||\n\t    a + (unsigned long)log_base > ULONG_MAX)\n\t\treturn 0;\n\treturn access_ok(VERIFY_WRITE, log_base + a,\n\t\t\t (sz + VHOST_PAGE_SIZE * 8 - 1) / VHOST_PAGE_SIZE / 8);\n}", "target": 0}
{"code": "unsigned long __ref init_memory_mapping(unsigned long start,\n\t\t\t\t\t       unsigned long end)\n{\n\tstruct map_range mr[NR_RANGE_MR];\n\tunsigned long ret = 0;\n\tint nr_range, i;\n\tpr_debug(\"init_memory_mapping: [mem %#010lx-%#010lx]\\n\",\n\t       start, end - 1);\n\tmemset(mr, 0, sizeof(mr));\n\tnr_range = split_mem_range(mr, 0, start, end);\n\tfor (i = 0; i < nr_range; i++)\n\t\tret = kernel_physical_mapping_init(mr[i].start, mr[i].end,\n\t\t\t\t\t\t   mr[i].page_size_mask);\n\tadd_pfn_range_mapped(start >> PAGE_SHIFT, ret >> PAGE_SHIFT);\n\treturn ret >> PAGE_SHIFT;\n}", "target": 0}
{"code": "Document DocumentSourceGroup::makeDocument(const Value& id,\n                                           const Accumulators& accums,\n                                           bool mergeableOutput) {\n    const size_t n = _accumulatedFields.size();\n    MutableDocument out(1 + n);\n    out.addField(\"_id\", expandId(id));\n    for (size_t i = 0; i < n; ++i) {\n        Value val = accums[i]->getValue(mergeableOutput);\n        if (val.missing()) {\n            out.addField(_accumulatedFields[i].fieldName, Value(BSONNULL));\n        } else {\n            out.addField(_accumulatedFields[i].fieldName, std::move(val));\n        }\n    }\n    _stats.totalOutputDataSizeBytes += out.getApproximateSize();\n    return out.freeze();\n}", "target": 0}
{"code": "njs_function_frame_save(njs_vm_t *vm, njs_frame_t *frame, u_char *pc)\n{\n    size_t              value_count, n;\n    njs_value_t         *start, *end, *p, **new, *value, **local;\n    njs_function_t      *function;\n    njs_native_frame_t  *active, *native;\n    *frame = *vm->active_frame;\n    frame->previous_active_frame = NULL;\n    native = &frame->native;\n    active = &vm->active_frame->native;\n    value_count = njs_function_frame_value_count(active);\n    function = active->function;\n    new = (njs_value_t **) ((u_char *) native + NJS_FRAME_SIZE);\n    value = (njs_value_t *) (new + value_count\n                             + function->u.lambda->temp);\n    native->arguments = value;\n    native->arguments_offset = value + (function->args_offset - 1);\n    native->local = new + njs_function_frame_args_count(active);\n    native->temp = new + value_count;\n    native->pc = pc;\n    start = njs_function_frame_values(active, &end);\n    p = native->arguments;\n    while (start < end) {\n        *p = *start++;\n        *new++ = p++;\n    }\n    p = native->arguments;\n    local = native->local + function->args_offset;\n    for (n = 0; n < function->args_count; n++) {\n        if (!njs_is_valid(p)) {\n            njs_set_undefined(p);\n        }\n        *local++ = p++;\n    }\n    return NJS_OK;\n}", "target": 1}
{"code": "static unsigned readChunk_tEXt(LodePNGInfo* info, const unsigned char* data, size_t chunkLength)\n{\n  unsigned error = 0;\n  char *key = 0, *str = 0;\n  unsigned i;\n  while(!error) \n  {\n    unsigned length, string2_begin;\n    length = 0;\n    while(length < chunkLength && data[length] != 0) length++;\n    if(length < 1 || length > 79) CERROR_BREAK(error, 89); \n    key = (char*)malloc(length + 1);\n    if(!key) CERROR_BREAK(error, 83); \n    key[length] = 0;\n    for(i = 0; i < length; i++) key[i] = (char)data[i];\n    string2_begin = length + 1; \n    length = chunkLength < string2_begin ? 0 : chunkLength - string2_begin;\n    str = (char*)malloc(length + 1);\n    if(!str) CERROR_BREAK(error, 83); \n    str[length] = 0;\n    for(i = 0; i < length; i++) str[i] = (char)data[string2_begin + i];\n    error = lodepng_add_text(info, key, str);\n    break;\n  }\n  free(key);\n  free(str);\n  return error;\n}", "target": 0}
{"code": "static int __io_sync_cancel(struct io_uring_task *tctx,\n\t\t\t    struct io_cancel_data *cd, int fd)\n{\n\tstruct io_ring_ctx *ctx = cd->ctx;\n\tif ((cd->flags & IORING_ASYNC_CANCEL_FD) &&\n\t    (cd->flags & IORING_ASYNC_CANCEL_FD_FIXED)) {\n\t\tunsigned long file_ptr;\n\t\tif (unlikely(fd > ctx->nr_user_files))\n\t\t\treturn -EBADF;\n\t\tfd = array_index_nospec(fd, ctx->nr_user_files);\n\t\tfile_ptr = io_fixed_file_slot(&ctx->file_table, fd)->file_ptr;\n\t\tcd->file = (struct file *) (file_ptr & FFS_MASK);\n\t\tif (!cd->file)\n\t\t\treturn -EBADF;\n\t}\n\treturn __io_async_cancel(cd, tctx, 0);\n}", "target": 1}
{"code": "void ZeroSuggestProvider::Run(const GURL& suggest_url) {\n  if (OmniboxFieldTrial::InZeroSuggestMostVisitedFieldTrial()) {\n    most_visited_urls_.clear();\n    scoped_refptr<history::TopSites> ts = client()->GetTopSites();\n    if (ts) {\n      waiting_for_most_visited_urls_request_ = true;\n      ts->GetMostVisitedURLs(\n          base::Bind(&ZeroSuggestProvider::OnMostVisitedUrlsAvailable,\n                     weak_ptr_factory_.GetWeakPtr()), false);\n    }\n  } else {\n    net::NetworkTrafficAnnotationTag traffic_annotation =\n        net::DefineNetworkTrafficAnnotation(\"omnibox_zerosuggest\", R\"(\n        semantics {\n          sender: \"Omnibox\"\n          description:\n            \"When the user focuses the omnibox, Chrome can provide search or \"\n            \"navigation suggestions from the default search provider in the \"\n            \"omnibox dropdown, based on the current page URL.\\n\"\n            \"This is limited to users whose default search engine is Google, \"\n            \"as no other search engines currently support this kind of \"\n            \"suggestion.\"\n          trigger: \"The omnibox receives focus.\"\n          data: \"The URL of the current page.\"\n          destination: GOOGLE_OWNED_SERVICE\n        }\n        policy {\n          cookies_allowed: true\n          cookies_store: \"user\"\n          setting:\n            \"Users can control this feature via the 'Use a prediction service \"\n            \"to help complete searches and URLs typed in the address bar' \"\n            \"settings under 'Privacy'. The feature is enabled by default.\"\n          chrome_policy {\n            SearchSuggestEnabled {\n                policy_options {mode: MANDATORY}\n                SearchSuggestEnabled: false\n            }\n          }\n        })\");\n    const int kFetcherID = 1;\n    fetcher_ =\n        net::URLFetcher::Create(kFetcherID, suggest_url, net::URLFetcher::GET,\n                                this, traffic_annotation);\n    data_use_measurement::DataUseUserData::AttachToFetcher(\n        fetcher_.get(), data_use_measurement::DataUseUserData::OMNIBOX);\n    fetcher_->SetRequestContext(client()->GetRequestContext());\n    fetcher_->SetLoadFlags(net::LOAD_DO_NOT_SAVE_COOKIES);\n    net::HttpRequestHeaders headers;\n    bool is_signed_in = false;\n    variations::AppendVariationHeaders(fetcher_->GetOriginalURL(),\n                                       client()->IsOffTheRecord(), false,\n                                       is_signed_in, &headers);\n    fetcher_->SetExtraRequestHeaders(headers.ToString());\n    fetcher_->Start();\n    LogOmniboxZeroSuggestRequest(ZERO_SUGGEST_REQUEST_SENT);\n  }\n}", "target": 0}
{"code": "static int32_t virtio_net_rsc_coalesce4(VirtioNetRscChain *chain,\n                                        VirtioNetRscSeg *seg,\n                                        const uint8_t *buf, size_t size,\n                                        VirtioNetRscUnit *unit)\n{\n    struct ip_header *ip1, *ip2;\n    ip1 = (struct ip_header *)(unit->ip);\n    ip2 = (struct ip_header *)(seg->unit.ip);\n    if ((ip1->ip_src ^ ip2->ip_src) || (ip1->ip_dst ^ ip2->ip_dst)\n        || (unit->tcp->th_sport ^ seg->unit.tcp->th_sport)\n        || (unit->tcp->th_dport ^ seg->unit.tcp->th_dport)) {\n        chain->stat.no_match++;\n        return RSC_NO_MATCH;\n    }\n    return virtio_net_rsc_coalesce_data(chain, seg, buf, unit);\n}", "target": 0}
{"code": "static void nfs_set_open_stateid(struct nfs4_state *state, nfs4_stateid *stateid, int open_flags)\n{\n\twrite_seqlock(&state->seqlock);\n\tnfs_set_open_stateid_locked(state, stateid, open_flags);\n\twrite_sequnlock(&state->seqlock);\n}", "target": 1}
{"code": "TEST(LteOp, MatchesMaxKey) {\n    BSONObj operand = BSON(\"a\" << MaxKey);\n    LTEMatchExpression lte(\"a\", operand[\"a\"]);\n    BSONObj minKeyObj = BSON(\"a\" << MinKey);\n    BSONObj maxKeyObj = BSON(\"a\" << MaxKey);\n    BSONObj numObj = BSON(\"a\" << 4);\n    ASSERT(lte.matchesBSON(minKeyObj, NULL));\n    ASSERT(lte.matchesBSON(maxKeyObj, NULL));\n    ASSERT(lte.matchesBSON(numObj, NULL));\n    ASSERT(lte.matchesSingleElement(minKeyObj.firstElement()));\n    ASSERT(lte.matchesSingleElement(maxKeyObj.firstElement()));\n    ASSERT(lte.matchesSingleElement(numObj.firstElement()));\n}", "target": 0}
{"code": "Expr *sqlite3CreateColumnExpr(sqlite3 *db, SrcList *pSrc, int iSrc, int iCol){\n  Expr *p = sqlite3ExprAlloc(db, TK_COLUMN, 0, 0);\n  if( p ){\n    struct SrcList_item *pItem = &pSrc->a[iSrc];\n    p->y.pTab = pItem->pTab;\n    p->iTable = pItem->iCursor;\n    if( p->y.pTab->iPKey==iCol ){\n      p->iColumn = -1;\n    }else{\n      p->iColumn = (ynVar)iCol;\n      testcase( iCol==BMS );\n      testcase( iCol==BMS-1 );\n      pItem->colUsed |= ((Bitmask)1)<<(iCol>=BMS ? BMS-1 : iCol);\n    }\n  }\n  return p;\n}", "target": 1}
{"code": "mrb_f_send(mrb_state *mrb, mrb_value self)\n{\n  mrb_sym name;\n  mrb_value block, *regs;\n  mrb_method_t m;\n  struct RClass *c;\n  mrb_callinfo *ci = mrb->c->ci;\n  int n = ci->n;\n  if (ci->cci > CINFO_NONE) {\n  funcall:;\n    const mrb_value *argv;\n    mrb_int argc;\n    mrb_get_args(mrb, \"n*&\", &name, &argv, &argc, &block);\n    return mrb_funcall_with_block(mrb, self, name, argc, argv, block);\n  }\n  regs = mrb->c->ci->stack+1;\n  if (n == 0) {\n    mrb_argnum_error(mrb, 0, 1, -1);\n  }\n  else if (n == 15) {\n    name = mrb_obj_to_sym(mrb, RARRAY_PTR(regs[0])[0]);\n  }\n  else {\n    name = mrb_obj_to_sym(mrb, regs[0]);\n  }\n  c = mrb_class(mrb, self);\n  m = mrb_method_search_vm(mrb, &c, name);\n  if (MRB_METHOD_UNDEF_P(m)) {            \n    goto funcall;\n  }\n  ci->mid = name;\n  ci->u.target_class = c;\n  if (n == 15) {     \n    regs[0] = mrb_ary_subseq(mrb, regs[0], 1, RARRAY_LEN(regs[0]) - 1);\n  }\n  else { \n    for (int i=0; i<n; i++) {\n      regs[i] = regs[i+1];\n    }\n    regs[n] = regs[n+1];        \n    if (ci->nk > 0) {\n      regs[n+1] = regs[n+2];    \n    }\n    ci->n--;\n  }\n  if (MRB_METHOD_CFUNC_P(m)) {\n    if (MRB_METHOD_NOARG_P(m)) {\n      check_method_noarg(mrb, ci);\n    }\n    if (MRB_METHOD_PROC_P(m)) {\n      mrb_vm_ci_proc_set(ci, MRB_METHOD_PROC(m));\n    }\n    return MRB_METHOD_CFUNC(m)(mrb, self);\n  }\n  return exec_irep(mrb, self, MRB_METHOD_PROC(m));\n}", "target": 1}
{"code": "void generic_pipe_buf_get(struct pipe_inode_info *pipe, struct pipe_buffer *buf)\n{\n\tget_page(buf->page);\n}", "target": 1}
{"code": "flatpak_run_extend_ld_path (FlatpakBwrap *bwrap,\n                            const char *prepend,\n                            const char *append)\n{\n  g_autoptr(GString) ld_library_path = g_string_new (g_environ_getenv (bwrap->envp, \"LD_LIBRARY_PATH\"));\n  if (prepend != NULL && *prepend != '\\0')\n    {\n      if (ld_library_path->len > 0)\n        g_string_prepend (ld_library_path, \":\");\n      g_string_prepend (ld_library_path, prepend);\n    }\n  if (append != NULL && *append != '\\0')\n    {\n      if (ld_library_path->len > 0)\n        g_string_append (ld_library_path, \":\");\n      g_string_append (ld_library_path, append);\n    }\n  flatpak_bwrap_set_env (bwrap, \"LD_LIBRARY_PATH\", ld_library_path->str, TRUE);\n}", "target": 0}
{"code": "static MagickBooleanType ReadPSDChannelPixels(Image *image,\n  const size_t channels,const ssize_t row,const ssize_t type,\n  const unsigned char *pixels,ExceptionInfo *exception)\n{\n  Quantum\n    pixel;\n  const unsigned char\n    *p;\n  IndexPacket\n    *indexes;\n  PixelPacket\n    *q;\n  ssize_t\n    x;\n  size_t\n    packet_size;\n  unsigned short\n    nibble;\n  p=pixels;\n  q=GetAuthenticPixels(image,0,row,image->columns,1,exception);\n  if (q == (PixelPacket *) NULL)\n    return MagickFalse;\n  indexes=GetAuthenticIndexQueue(image);\n  packet_size=GetPSDPacketSize(image);\n  for (x=0; x < (ssize_t) image->columns; x++)\n  {\n    if (packet_size == 1)\n      pixel=ScaleCharToQuantum(*p++);\n    else\n      if (packet_size == 2)\n        {\n          p=PushShortPixel(MSBEndian,p,&nibble);\n          pixel=ScaleShortToQuantum(nibble);\n        }\n      else\n        {\n          MagickFloatType\n            nibble;\n          p=PushFloatPixel(MSBEndian,p,&nibble);\n          pixel=ClampToQuantum((MagickRealType)QuantumRange*nibble);\n        }\n    if (image->depth > 1)\n      {\n        SetPSDPixel(image,channels,type,packet_size,pixel,q,indexes,x);\n        q++;\n      }\n    else\n      {\n        ssize_t\n          bit,\n          number_bits;\n        number_bits=(ssize_t) image->columns-x;\n        if (number_bits > 8)\n          number_bits=8;\n        for (bit=0; bit < number_bits; bit++)\n        {\n          SetPSDPixel(image,channels,type,packet_size,(((unsigned char) pixel)\n            & (0x01 << (7-bit))) != 0 ? 0 : QuantumRange,q++,indexes,x++);\n        }\n        if (x != (ssize_t) image->columns)\n          x--;\n        continue;\n      }\n  }\n  return(SyncAuthenticPixels(image,exception));\n}", "target": 1}
{"code": "static void ikev2_parent_outI1_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\tstruct pluto_crypto_req *r,\n\t\t\t\t\terr_t ugh)\n{\n\tstruct ke_continuation *ke = (struct ke_continuation *)pcrc;\n\tstruct msg_digest *md = ke->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\"ikev2 parent outI1: calculated ke+nonce, sending I1\"));\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \"%s: Request was disconnected from state\",\n\t\t       __FUNCTION__);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t\treturn;\n\t}\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\tpassert(st->st_suspended_md == ke->md);\n\tset_suspended(st, NULL); \n\tset_cur_state(st);\n\tst->st_calculating = FALSE;\n\te = ikev2_parent_outI1_tail(pcrc, r);\n\tif (ke->md != NULL) {\n\t\tcomplete_v2_state_transition(&ke->md, e);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t}\n\treset_cur_state();\n\treset_globals();\n\tpassert(GLOBALS_ARE_RESET());\n}", "target": 1}
{"code": "int rds_get_mr_for_dest(struct rds_sock *rs, char __user *optval, int optlen)\n{\n\tstruct rds_get_mr_for_dest_args args;\n\tstruct rds_get_mr_args new_args;\n\tif (optlen != sizeof(struct rds_get_mr_for_dest_args))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&args, (struct rds_get_mr_for_dest_args __user *)optval,\n\t\t\t   sizeof(struct rds_get_mr_for_dest_args)))\n\t\treturn -EFAULT;\n\tnew_args.vec = args.vec;\n\tnew_args.cookie_addr = args.cookie_addr;\n\tnew_args.flags = args.flags;\n\treturn __rds_rdma_map(rs, &new_args, NULL, NULL);\n}", "target": 0}
{"code": "OMX_ERRORTYPE SimpleSoftOMXComponent::getParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n Mutex::Autolock autoLock(mLock);\n return internalGetParameter(index, params);\n}", "target": 0}
{"code": "int kvm_emulate_hypercall(struct kvm_vcpu *vcpu)\n{\n\tunsigned long nr, a0, a1, a2, a3, ret;\n\tint r = 1;\n\tif (kvm_hv_hypercall_enabled(vcpu->kvm))\n\t\treturn kvm_hv_hypercall(vcpu);\n\tnr = kvm_register_read(vcpu, VCPU_REGS_RAX);\n\ta0 = kvm_register_read(vcpu, VCPU_REGS_RBX);\n\ta1 = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\ta2 = kvm_register_read(vcpu, VCPU_REGS_RDX);\n\ta3 = kvm_register_read(vcpu, VCPU_REGS_RSI);\n\ttrace_kvm_hypercall(nr, a0, a1, a2, a3);\n\tif (!is_long_mode(vcpu)) {\n\t\tnr &= 0xFFFFFFFF;\n\t\ta0 &= 0xFFFFFFFF;\n\t\ta1 &= 0xFFFFFFFF;\n\t\ta2 &= 0xFFFFFFFF;\n\t\ta3 &= 0xFFFFFFFF;\n\t}\n\tif (kvm_x86_ops->get_cpl(vcpu) != 0) {\n\t\tret = -KVM_EPERM;\n\t\tgoto out;\n\t}\n\tswitch (nr) {\n\tcase KVM_HC_VAPIC_POLL_IRQ:\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -KVM_ENOSYS;\n\t\tbreak;\n\t}\nout:\n\tkvm_register_write(vcpu, VCPU_REGS_RAX, ret);\n\t++vcpu->stat.hypercalls;\n\treturn r;\n}", "target": 0}
{"code": "string PacketReader::getLabel(unsigned int recurs)\n{\n  string ret;\n  ret.reserve(40);\n  getLabelFromContent(d_content, d_pos, ret, recurs++);\n  return ret;\n}", "target": 1}
{"code": "MagickExport LinkedListInfo *GetLocaleOptions(const char *filename,\n  ExceptionInfo *exception)\n{\n  char\n    path[MagickPathExtent];\n  const char\n    *element;\n  LinkedListInfo\n    *messages,\n    *paths;\n  StringInfo\n    *xml;\n  assert(filename != (const char *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  (void) CopyMagickString(path,filename,MagickPathExtent);\n  messages=NewLinkedList(0);\n  paths=GetConfigurePaths(filename,exception);\n  if (paths != (LinkedListInfo *) NULL)\n    {\n      ResetLinkedListIterator(paths);\n      element=(const char *) GetNextValueInLinkedList(paths);\n      while (element != (const char *) NULL)\n      {\n        (void) FormatLocaleString(path,MagickPathExtent,\"%s%s\",element,\n          filename);\n        (void) LogMagickEvent(LocaleEvent,GetMagickModule(),\n          \"Searching for locale file: \\\"%s\\\"\",path);\n        xml=ConfigureFileToStringInfo(path);\n        if (xml != (StringInfo *) NULL)\n          (void) AppendValueToLinkedList(messages,xml);\n        element=(const char *) GetNextValueInLinkedList(paths);\n      }\n      paths=DestroyLinkedList(paths,RelinquishMagickMemory);\n    }\n#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n  {\n    char\n      *blob;\n    blob=(char *) NTResourceToBlob(filename);\n    if (blob != (char *) NULL)\n      {\n        xml=AcquireStringInfo(0);\n        SetStringInfoLength(xml,strlen(blob)+1);\n        SetStringInfoDatum(xml,(const unsigned char *) blob);\n        blob=(char *) RelinquishMagickMemory(blob);\n        SetStringInfoPath(xml,filename);\n        (void) AppendValueToLinkedList(messages,xml);\n      }\n  }\n#endif\n  ResetLinkedListIterator(messages);\n  return(messages);\n}", "target": 0}
{"code": "void undefer_input(__G)\n    __GDEF\n{\n    if (G.incnt > 0)\n        G.csize += G.incnt;\n    if (G.incnt_leftover > 0) {\n        G.incnt = G.incnt_leftover + (int)G.csize;\n        G.inptr = G.inptr_leftover - (int)G.csize;\n        G.incnt_leftover = 0;\n    } else if (G.incnt < 0)\n        G.incnt = 0;\n} ", "target": 1}
{"code": "static void vgacon_scrollback_switch(int vc_num)\n{\n\tif (!scrollback_persistent)\n\t\tvc_num = 0;\n\tif (!vgacon_scrollbacks[vc_num].data) {\n\t\tvgacon_scrollback_init(vc_num);\n\t} else {\n\t\tif (scrollback_persistent) {\n\t\t\tvgacon_scrollback_cur = &vgacon_scrollbacks[vc_num];\n\t\t} else {\n\t\t\tsize_t size = CONFIG_VGACON_SOFT_SCROLLBACK_SIZE * 1024;\n\t\t\tvgacon_scrollback_reset(vc_num, size);\n\t\t}\n\t}\n}", "target": 1}
{"code": "static int econet_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t  int *uaddr_len, int peer)\n{\n\tstruct sock *sk;\n\tstruct econet_sock *eo;\n\tstruct sockaddr_ec *sec = (struct sockaddr_ec *)uaddr;\n\tif (peer)\n\t\treturn -EOPNOTSUPP;\n\tmutex_lock(&econet_mutex);\n\tsk = sock->sk;\n\teo = ec_sk(sk);\n\tsec->sec_family\t  = AF_ECONET;\n\tsec->port\t  = eo->port;\n\tsec->addr.station = eo->station;\n\tsec->addr.net\t  = eo->net;\n\tmutex_unlock(&econet_mutex);\n\t*uaddr_len = sizeof(*sec);\n\treturn 0;\n}", "target": 1}
{"code": "GF_Err traf_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackFragmentBox *ptr = (GF_TrackFragmentBox *)s;\n\tGF_Err e = gf_isom_box_array_read(s, bs, traf_on_child_box);\n\tif (e) return e;\n\tif (!ptr->tfhd) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing TrackFragmentHeaderBox \\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "grub_password_get (char buf[], unsigned buf_size)\n{\n  unsigned cur_len = 0;\n  int key;\n  while (1)\n    {\n      key = grub_getkey (); \n      if (key == '\\n' || key == '\\r')\n\tbreak;\n      if (key == '\\e')\n\t{\n\t  cur_len = 0;\n\t  break;\n\t}\n      if (key == '\\b')\n\t{\n\t  cur_len--;\n\t  continue;\n\t}\n      if (!grub_isprint (key))\n\tcontinue;\n      if (cur_len + 2 < buf_size)\n\tbuf[cur_len++] = key;\n    }\n  grub_memset (buf + cur_len, 0, buf_size - cur_len);\n  grub_xputs (\"\\n\");\n  grub_refresh ();\n  return (key != '\\e');\n}", "target": 1}
{"code": "static void copyIPv6IfDifferent(void * dest, const void * src)\n{\n\tif(dest != src) {\n\t\tmemcpy(dest, src, sizeof(struct in6_addr));\n\t}\n}", "target": 1}
{"code": "static void imx_usdhc_init(Object *obj)\n{\n    SDHCIState *s = SYSBUS_SDHCI(obj);\n    s->io_ops = &usdhc_mmio_ops;\n    s->quirks = SDHCI_QUIRK_NO_BUSY_IRQ;\n}", "target": 0}
{"code": "ikev2_vid_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len _U_, const u_char *ep _U_,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\tconst u_char *vid;\n\tint i, len;\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tikev2_pay_print(ndo, NPSTR(tpay), e.critical);\n\tND_PRINT((ndo,\" len=%d vid=\", ntohs(e.len) - 4));\n\tvid = (const u_char *)(ext+1);\n\tlen = ntohs(e.len) - 4;\n\tND_TCHECK2(*vid, len);\n\tfor(i=0; i<len; i++) {\n\t\tif(ND_ISPRINT(vid[i])) ND_PRINT((ndo, \"%c\", vid[i]));\n\t\telse ND_PRINT((ndo, \".\"));\n\t}\n\tif (2 < ndo->ndo_vflag && 4 < len) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}", "target": 0}
{"code": "static int em_grp45(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc = X86EMUL_CONTINUE;\n\tswitch (ctxt->modrm_reg) {\n\tcase 2:  {\n\t\tlong int old_eip;\n\t\told_eip = ctxt->_eip;\n\t\tctxt->_eip = ctxt->src.val;\n\t\tctxt->src.val = old_eip;\n\t\trc = em_push(ctxt);\n\t\tbreak;\n\t}\n\tcase 4: \n\t\tctxt->_eip = ctxt->src.val;\n\t\tbreak;\n\tcase 5: \n\t\trc = em_jmp_far(ctxt);\n\t\tbreak;\n\tcase 6:\t\n\t\trc = em_push(ctxt);\n\t\tbreak;\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "static void fuse_lib_init(void *data, struct fuse_conn_info *conn)\n{\n    struct fuse *f = (struct fuse *) data;\n    struct fuse_context_i *c = fuse_get_context_internal();\n    memset(c, 0, sizeof(*c));\n    c->ctx.fuse = f;\n    fuse_fs_init(f->fs, conn);\n}", "target": 0}
{"code": "MagickExport MagickBooleanType IsOptionMember(const char *option,\n  const char *options)\n{\n  char\n    **option_list,\n    *string;\n  int\n    number_options;\n  MagickBooleanType\n    member;\n  register ssize_t\n    i;\n  if (options == (const char *) NULL)\n    return(MagickFalse);\n  string=ConstantString(options);\n  (void) SubstituteString(&string,\",\",\" \");\n  option_list=StringToArgv(string,&number_options);\n  string=DestroyString(string);\n  if (option_list == (char **) NULL)\n    return(MagickFalse);\n  member=MagickFalse;\n  for (i=1; i < (ssize_t) number_options; i++)\n  {\n    if ((*option_list[i] == '!') &&\n        (LocaleCompare(option,option_list[i]+1) == 0))\n      break;\n    if (GlobExpression(option,option_list[i],MagickTrue) != MagickFalse)\n      {\n        member=MagickTrue;\n        break;\n      }\n    option_list[i]=DestroyString(option_list[i]);\n  }\n  for ( ; i < (ssize_t) number_options; i++)\n    option_list[i]=DestroyString(option_list[i]);\n  option_list=(char **) RelinquishMagickMemory(option_list);\n  return(member);\n}", "target": 1}
{"code": "static size_t ntlm_av_pair_get_next_offset(NTLM_AV_PAIR* pAvPair)\n{\n\treturn ntlm_av_pair_get_len(pAvPair) + sizeof(NTLM_AV_PAIR);\n}", "target": 1}
{"code": "int dev_forward_skb(struct net_device *dev, struct sk_buff *skb)\n{\n\tskb_orphan(skb);\n\tif (!(dev->flags & IFF_UP))\n\t\treturn NET_RX_DROP;\n\tif (skb->len > (dev->mtu + dev->hard_header_len))\n\t\treturn NET_RX_DROP;\n\tskb_set_dev(skb, dev);\n\tskb->tstamp.tv64 = 0;\n\tskb->pkt_type = PACKET_HOST;\n\tskb->protocol = eth_type_trans(skb, dev);\n\treturn netif_rx(skb);\n}", "target": 1}
{"code": "void traverse_commit_list(struct rev_info *revs,\n\t\t\t  show_commit_fn show_commit,\n\t\t\t  show_object_fn show_object,\n\t\t\t  void *data)\n{\n\tint i;\n\tstruct commit *commit;\n\tstruct strbuf base;\n\tstrbuf_init(&base, PATH_MAX);\n\twhile ((commit = get_revision(revs)) != NULL) {\n\t\tif (commit->tree)\n\t\t\tadd_pending_tree(revs, commit->tree);\n\t\tshow_commit(commit, data);\n\t}\n\tfor (i = 0; i < revs->pending.nr; i++) {\n\t\tstruct object_array_entry *pending = revs->pending.objects + i;\n\t\tstruct object *obj = pending->item;\n\t\tconst char *name = pending->name;\n\t\tconst char *path = pending->path;\n\t\tif (obj->flags & (UNINTERESTING | SEEN))\n\t\t\tcontinue;\n\t\tif (obj->type == OBJ_TAG) {\n\t\t\tobj->flags |= SEEN;\n\t\t\tshow_object(obj, NULL, name, data);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!path)\n\t\t\tpath = \"\";\n\t\tif (obj->type == OBJ_TREE) {\n\t\t\tprocess_tree(revs, (struct tree *)obj, show_object,\n\t\t\t\t     &base, path, data);\n\t\t\tcontinue;\n\t\t}\n\t\tif (obj->type == OBJ_BLOB) {\n\t\t\tprocess_blob(revs, (struct blob *)obj, show_object,\n\t\t\t\t     NULL, path, data);\n\t\t\tcontinue;\n\t\t}\n\t\tdie(\"unknown pending object %s (%s)\",\n\t\t    oid_to_hex(&obj->oid), name);\n\t}\n\tobject_array_clear(&revs->pending);\n\tstrbuf_release(&base);\n}", "target": 1}
{"code": "pci_lintr_assert(struct pci_vdev *dev)\n{\n\tassert(dev->lintr.pin > 0);\n\tpthread_mutex_lock(&dev->lintr.lock);\n\tif (dev->lintr.state == IDLE) {\n\t\tif (pci_lintr_permitted(dev)) {\n\t\t\tdev->lintr.state = ASSERTED;\n\t\t\tpci_irq_assert(dev);\n\t\t} else\n\t\t\tdev->lintr.state = PENDING;\n\t}\n\tpthread_mutex_unlock(&dev->lintr.lock);\n}", "target": 1}
{"code": "static void br_multicast_del_pg(struct net_bridge *br,\n\t\t\t\tstruct net_bridge_port_group *pg)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tmdb = mlock_dereference(br->mdb, br);\n\tmp = br_mdb_ip_get(mdb, &pg->addr);\n\tif (WARN_ON(!mp))\n\t\treturn;\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (p != pg)\n\t\t\tcontinue;\n\t\trcu_assign_pointer(*pp, p->next);\n\t\thlist_del_init(&p->mglist);\n\t\tdel_timer(&p->timer);\n\t\tcall_rcu_bh(&p->rcu, br_multicast_free_pg);\n\t\tif (!mp->ports && !mp->mglist &&\n\t\t    netif_running(br->dev))\n\t\t\tmod_timer(&mp->timer, jiffies);\n\t\treturn;\n\t}\n\tWARN_ON(1);\n}", "target": 1}
{"code": "void fuse_sync_release(struct fuse_file *ff, int flags)\n{\n\tWARN_ON(atomic_read(&ff->count) > 1);\n\tfuse_prepare_release(ff, flags, FUSE_RELEASE);\n\tff->reserved_req->force = 1;\n\tfuse_request_send(ff->fc, ff->reserved_req);\n\tfuse_put_request(ff->fc, ff->reserved_req);\n\tkfree(ff);\n}", "target": 0}
{"code": "    bool triggered() const { return m_triggered; }", "target": 0}
{"code": "static const char *unset_define(cmd_parms *cmd, void *dummy,\n                                const char *name)\n{\n    int i;\n    const char **defines;\n    if (cmd->parent && ap_cstr_casecmp(cmd->parent->directive, \"<VirtualHost\")) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name, \" is not valid in \",\n                                      cmd->parent->directive, \" context\", NULL);\n    }\n    if (ap_strchr_c(name, ':') != NULL) {\n        return \"Variable name must not contain ':'\";\n    }\n    if (!saved_server_config_defines) {\n        init_config_defines(cmd->pool);\n    }\n    defines = (const char **)ap_server_config_defines->elts;\n    for (i = 0; i < ap_server_config_defines->nelts; i++) {\n        if (strcmp(defines[i], name) == 0) {\n            defines[i] = *(const char **)apr_array_pop(ap_server_config_defines);\n            break;\n        }\n    }\n    if (server_config_defined_vars) {\n        apr_table_unset(server_config_defined_vars, name);\n    }\n    return NULL;\n}", "target": 0}
{"code": "static int ieee802154_create(struct net *net, struct socket *sock,\n\t\t\t     int protocol, int kern)\n{\n\tstruct sock *sk;\n\tint rc;\n\tstruct proto *proto;\n\tconst struct proto_ops *ops;\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\tswitch (sock->type) {\n\tcase SOCK_RAW:\n\t\tproto = &ieee802154_raw_prot;\n\t\tops = &ieee802154_raw_ops;\n\t\tbreak;\n\tcase SOCK_DGRAM:\n\t\tproto = &ieee802154_dgram_prot;\n\t\tops = &ieee802154_dgram_ops;\n\t\tbreak;\n\tdefault:\n\t\trc = -ESOCKTNOSUPPORT;\n\t\tgoto out;\n\t}\n\trc = -ENOMEM;\n\tsk = sk_alloc(net, PF_IEEE802154, GFP_KERNEL, proto, kern);\n\tif (!sk)\n\t\tgoto out;\n\trc = 0;\n\tsock->ops = ops;\n\tsock_init_data(sock, sk);\n\tsk->sk_family = PF_IEEE802154;\n\tsock_set_flag(sk, SOCK_ZAPPED);\n\tif (sk->sk_prot->hash) {\n\t\trc = sk->sk_prot->hash(sk);\n\t\tif (rc) {\n\t\t\tsk_common_release(sk);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (sk->sk_prot->init) {\n\t\trc = sk->sk_prot->init(sk);\n\t\tif (rc)\n\t\t\tsk_common_release(sk);\n\t}\nout:\n\treturn rc;\n}", "target": 1}
{"code": "static int partition_get_logical_type(blkid_partition par)\n{\n\tblkid_parttable tab;\n\tif (!par)\n\t\treturn -1;\n\ttab = blkid_partition_get_table(par);\n\tif (!tab || !tab->type)\n\t\treturn -1;\n\tif (tab->parent)\n\t\treturn 'L';  \n\tif (!strcmp(tab->type, \"dos\")) {\n\t\tif (par->partno > 4)\n\t\t\treturn 'L';\t\n\t        if(par->type == MBR_DOS_EXTENDED_PARTITION ||\n                   par->type == MBR_W95_EXTENDED_PARTITION ||\n\t\t   par->type == MBR_LINUX_EXTENDED_PARTITION)\n\t\t\treturn 'E';\n\t}\n\treturn 'P';\n}", "target": 0}
{"code": "static long cec_adap_g_log_addrs(struct cec_adapter *adap,\n\t\t\t\t struct cec_log_addrs __user *parg)\n{\n\tstruct cec_log_addrs log_addrs;\n\tmutex_lock(&adap->lock);\n\tlog_addrs = adap->log_addrs;\n\tif (!adap->is_configured)\n\t\tmemset(log_addrs.log_addr, CEC_LOG_ADDR_INVALID,\n\t\t       sizeof(log_addrs.log_addr));\n\tmutex_unlock(&adap->lock);\n\tif (copy_to_user(parg, &log_addrs, sizeof(log_addrs)))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1}
{"code": "int hns_ppe_get_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn ETH_PPE_STATIC_NUM;\n\treturn 0;\n}", "target": 1}
{"code": "snmp_oid_print(uint32_t *oid)\n{\n  uint8_t i;\n  i = 0;\n  LOG_DBG(\"{\");\n  while(oid[i] != ((uint32_t)-1)) {\n    LOG_DBG_(\"%lu\", (unsigned long)oid[i]);\n    i++;\n    if(oid[i] != ((uint32_t)-1)) {\n      LOG_DBG_(\".\");\n    }\n  }\n  LOG_DBG_(\"}\\n\");\n}", "target": 1}
{"code": "static void opl3_setup_voice(int dev, int voice, int chn)\n{\n\tstruct channel_info *info =\n\t&synth_devs[dev]->chn_info[chn];\n\topl3_set_instr(dev, voice, info->pgm_num);\n\tdevc->voc[voice].bender = 0;\n\tdevc->voc[voice].bender_range = info->bender_range;\n\tdevc->voc[voice].volume = info->controllers[CTL_MAIN_VOLUME];\n\tdevc->voc[voice].panning = (info->controllers[CTL_PAN] * 2) - 128;\n}", "target": 1}
{"code": "int sctp_auth_ep_set_hmacs(struct sctp_endpoint *ep,\n\t\t\t   struct sctp_hmacalgo *hmacs)\n{\n\tint has_sha1 = 0;\n\t__u16 id;\n\tint i;\n\tfor (i = 0; i < hmacs->shmac_num_idents; i++) {\n\t\tid = hmacs->shmac_idents[i];\n\t\tif (SCTP_AUTH_HMAC_ID_SHA1 == id)\n\t\t\thas_sha1 = 1;\n\t\tif (!sctp_hmac_list[id].hmac_name)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\tif (!has_sha1)\n\t\treturn -EINVAL;\n\tmemcpy(ep->auth_hmacs_list->hmac_ids, &hmacs->shmac_idents[0],\n\t\thmacs->shmac_num_idents * sizeof(__u16));\n\tep->auth_hmacs_list->param_hdr.length = htons(sizeof(sctp_paramhdr_t) +\n\t\t\t\thmacs->shmac_num_idents * sizeof(__u16));\n\treturn 0;\n}", "target": 1}
{"code": "inline int nci_request(struct nci_dev *ndev,\n\t\t       void (*req)(struct nci_dev *ndev,\n\t\t\t\t   const void *opt),\n\t\t       const void *opt, __u32 timeout)\n{\n\tint rc;\n\tif (!test_bit(NCI_UP, &ndev->flags))\n\t\treturn -ENETDOWN;\n\tmutex_lock(&ndev->req_lock);\n\trc = __nci_request(ndev, req, opt, timeout);\n\tmutex_unlock(&ndev->req_lock);\n\treturn rc;\n}", "target": 1}
{"code": "static int ecryptfs_threadfn(void *ignored)\n{\n\tset_freezable();\n\twhile (1)  {\n\t\tstruct ecryptfs_open_req *req;\n\t\twait_event_freezable(\n\t\t\tecryptfs_kthread_ctl.wait,\n\t\t\t(!list_empty(&ecryptfs_kthread_ctl.req_list)\n\t\t\t || kthread_should_stop()));\n\t\tmutex_lock(&ecryptfs_kthread_ctl.mux);\n\t\tif (ecryptfs_kthread_ctl.flags & ECRYPTFS_KTHREAD_ZOMBIE) {\n\t\t\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\t\t\tgoto out;\n\t\t}\n\t\twhile (!list_empty(&ecryptfs_kthread_ctl.req_list)) {\n\t\t\treq = list_first_entry(&ecryptfs_kthread_ctl.req_list,\n\t\t\t\t\t       struct ecryptfs_open_req,\n\t\t\t\t\t       kthread_ctl_list);\n\t\t\tlist_del(&req->kthread_ctl_list);\n\t\t\t*req->lower_file = dentry_open(&req->path,\n\t\t\t\t(O_RDWR | O_LARGEFILE), current_cred());\n\t\t\tcomplete(&req->done);\n\t\t}\n\t\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\t}\nout:\n\treturn 0;\n}", "target": 0}
{"code": "DECLAREContigPutFunc(putagreytile)\n{\n    int samplesperpixel = img->samplesperpixel;\n    uint32** BWmap = img->BWmap;\n    (void) y;\n    while (h-- > 0) {\n\tfor (x = w; x-- > 0;)\n        {\n            *cp++ = BWmap[*pp][0] & (*(pp+1) << 24 | ~A1);\n            pp += samplesperpixel;\n        }\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}", "target": 1}
{"code": "efind(name)\nchar *name;\n{\n\tstatic char efbuf[100];\n\tmy_regex_t re;\n\tsprintf(efbuf, \"REG_%s\", name);\n\tassert(strlen(efbuf) < sizeof(efbuf));\n\tre.re_endp = efbuf;\n\t(void) my_regerror(REG_ATOI, &re, efbuf, sizeof(efbuf));\n\treturn(atoi(efbuf));\n}", "target": 1}
{"code": "static inline struct shmid_kernel *shm_lock(struct ipc_namespace *ns, int id)\n{\n\tstruct kern_ipc_perm *ipcp = ipc_lock(&shm_ids(ns), id);\n\tif (IS_ERR(ipcp))\n\t\treturn (void *)ipcp;\n\treturn container_of(ipcp, struct shmid_kernel, shm_perm);\n}", "target": 0}
{"code": "bool SimplifiedBackwardsTextIterator::handleTextNode()\n{\n    m_lastTextNode = m_node;\n    int startOffset;\n    int offsetInNode;\n    RenderText* renderer = handleFirstLetter(startOffset, offsetInNode);\n    if (!renderer)\n        return true;\n    String text = renderer->text();\n    if (!renderer->firstTextBox() && text.length() > 0)\n        return true;\n    m_positionEndOffset = m_offset;\n    m_offset = startOffset + offsetInNode;\n    m_positionNode = m_node;\n    m_positionStartOffset = m_offset;\n    ASSERT(0 <= m_positionStartOffset - offsetInNode && m_positionStartOffset - offsetInNode <= static_cast<int>(text.length()));\n    ASSERT(1 <= m_positionEndOffset - offsetInNode && m_positionEndOffset - offsetInNode <= static_cast<int>(text.length()));\n    ASSERT(m_positionStartOffset <= m_positionEndOffset);\n     m_textLength = m_positionEndOffset - m_positionStartOffset;\n     m_textCharacters = text.characters() + (m_positionStartOffset - offsetInNode);\n     ASSERT(m_textCharacters >= text.characters());\n    ASSERT(m_textCharacters + m_textLength <= text.characters() + static_cast<int>(text.length()));\n     m_lastCharacter = text[m_positionEndOffset - 1];\n    return !m_shouldHandleFirstLetter;\n}", "target": 1}
{"code": "static void r_coresym_cache_element_line_info_fini(RCoreSymCacheElementLineInfo *line) {\n\tif (line) {\n\t\tr_coresym_cache_element_flc_fini (&line->flc);\n\t}\n}", "target": 0}
{"code": "static int snd_usb_novation_boot_quirk(struct usb_device *dev)\n{\n\tusb_set_interface(dev, 0, 1);\n\treturn 0;\n}", "target": 0}
{"code": "spnego_gss_context_time(\n\t\t\tOM_uint32\t*minor_status,\n\t\t\tconst gss_ctx_id_t context_handle,\n\t\t\tOM_uint32\t*time_rec)\n{\n\tOM_uint32 ret;\n\tret = gss_context_time(minor_status,\n\t\t\t    context_handle,\n\t\t\t    time_rec);\n\treturn (ret);\n}", "target": 1}
{"code": "static int __br_mdb_del(struct net_bridge *br, struct br_mdb_entry *entry)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tstruct br_ip ip;\n\tint err = -EINVAL;\n\tif (!netif_running(br->dev) || br->multicast_disabled)\n\t\treturn -EINVAL;\n\tif (timer_pending(&br->multicast_querier_timer))\n\t\treturn -EBUSY;\n\tip.proto = entry->addr.proto;\n\tif (ip.proto == htons(ETH_P_IP))\n\t\tip.u.ip4 = entry->addr.u.ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\telse\n\t\tip.u.ip6 = entry->addr.u.ip6;\n#endif\n\tspin_lock_bh(&br->multicast_lock);\n\tmdb = mlock_dereference(br->mdb, br);\n\tmp = br_mdb_ip_get(mdb, &ip);\n\tif (!mp)\n\t\tgoto unlock;\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (!p->port || p->port->dev->ifindex != entry->ifindex)\n\t\t\tcontinue;\n\t\tif (p->port->state == BR_STATE_DISABLED)\n\t\t\tgoto unlock;\n\t\trcu_assign_pointer(*pp, p->next);\n\t\thlist_del_init(&p->mglist);\n\t\tdel_timer(&p->timer);\n\t\tcall_rcu_bh(&p->rcu, br_multicast_free_pg);\n\t\terr = 0;\n\t\tif (!mp->ports && !mp->mglist &&\n\t\t    netif_running(br->dev))\n\t\t\tmod_timer(&mp->timer, jiffies);\n\t\tbreak;\n\t}\nunlock:\n\tspin_unlock_bh(&br->multicast_lock);\n\treturn err;\n}", "target": 1}
{"code": "matchCurrentInput(\n\t\tconst InString *input, int pos, const widechar *passInstructions, int passIC) {\n\tint k;\n\tint kk = pos;\n\tfor (k = passIC + 2; k < passIC + 2 + passInstructions[passIC + 1]; k++)\n\t\tif (input->chars[kk] == ENDSEGMENT || passInstructions[k] != input->chars[kk++])\n\t\t\treturn 0;\n\treturn 1;\n}", "target": 1}
{"code": "void OfflineAudioDestinationHandler::PrepareTaskRunnerForRendering() {\n  DCHECK(IsMainThread());\n  AudioWorklet* audio_worklet = Context()->audioWorklet();\n  if (audio_worklet && audio_worklet->IsReady()) {\n    if (!render_thread_) {\n      if (!render_thread_task_runner_) {\n        render_thread_task_runner_ =\n            audio_worklet->GetMessagingProxy()->GetBackingWorkerThread()\n                         ->GetTaskRunner(TaskType::kMiscPlatformAPI);\n      }\n    } else {\n      render_thread_ = nullptr;\n      render_thread_task_runner_ =\n          audio_worklet->GetMessagingProxy()->GetBackingWorkerThread()\n                       ->GetTaskRunner(TaskType::kMiscPlatformAPI);\n    }\n  } else {\n    if (!render_thread_) {\n      render_thread_ = Platform::Current()->CreateThread(\n          ThreadCreationParams(WebThreadType::kOfflineAudioRenderThread));\n      render_thread_task_runner_ = render_thread_->GetTaskRunner();\n    }\n  }\n  DCHECK(render_thread_task_runner_);\n}", "target": 0}
{"code": "test_appheader (xd3_stream *stream, int ignore)\n{\n  int i;\n  int ret;\n  char buf[TESTBUFSIZE];\n  char bogus[TESTBUFSIZE];\n  xoff_t ssize, tsize;\n  test_setup ();\n  if ((ret = test_make_inputs (stream, &ssize, &tsize))) { return ret; }\n  snprintf_func (buf, TESTBUFSIZE, \"%s -q -f -e -s %s %s %s\", program_name,\n\t\t TEST_SOURCE_FILE, TEST_TARGET_FILE, TEST_DELTA_FILE);\n  if ((ret = do_cmd (stream, buf))) { return ret; }\n  if ((ret = test_copy_to (program_name, TEST_RECON2_FILE))) { return ret; }\n  snprintf_func (buf, TESTBUFSIZE, \"chmod 0700 %s\", TEST_RECON2_FILE);\n  if ((ret = do_cmd (stream, buf))) { return ret; }\n  if ((ret = test_save_copy (TEST_TARGET_FILE))) { return ret; }\n  if ((ret = test_copy_to (TEST_SOURCE_FILE, TEST_TARGET_FILE))) { return ret; }\n  if ((ret = test_compare_files (TEST_TARGET_FILE, TEST_COPY_FILE)) == 0)\n    {\n      return XD3_INVALID;  \n    }\n  snprintf_func (buf, TESTBUFSIZE, \"(cd /tmp && %s -q -f -d %s)\",\n\t\t TEST_RECON2_FILE,\n\t\t TEST_DELTA_FILE);\n  if ((ret = do_cmd (stream, buf))) { return ret; }\n  if ((ret = test_compare_files (TEST_TARGET_FILE, TEST_COPY_FILE)) != 0)\n    {\n      return ret;\n    }\n  for (i = 0; i < TESTBUFSIZE / 4; ++i)\n    {\n      bogus[2*i] = 'G';\n      bogus[2*i+1] = '/';\n    }\n  bogus[TESTBUFSIZE/2-1] = 0;\n  snprintf_func (buf, TESTBUFSIZE, \n\t\t \"%s -q -f -A=%s -e -s %s %s %s\", program_name, bogus,\n\t\t TEST_SOURCE_FILE, TEST_TARGET_FILE, TEST_DELTA_FILE);\n  if ((ret = do_cmd (stream, buf))) { return ret; }\n  snprintf_func (buf, TESTBUFSIZE, \"(cd /tmp && %s -q -f -d %s)\",\n\t\t TEST_RECON2_FILE,\n\t\t TEST_DELTA_FILE);\n  if ((ret = do_cmd (stream, buf)) == 0) \n    { \n      return XD3_INVALID;  \n    }\n  if (!WIFEXITED(ret))\n    {\n      return XD3_INVALID;  \n    }\n  return 0;\n}", "target": 0}
{"code": "static inline void sem_getref(struct sem_array *sma)\n{\n\tspin_lock(&(sma)->sem_perm.lock);\n\tipc_rcu_getref(sma);\n\tipc_unlock(&(sma)->sem_perm);\n}", "target": 1}
{"code": "static void FNAME_DECL(compress_row0)(const PIXEL *cur_row, unsigned int width)\n{\n    DECLARE_STATE_VARIABLES;\n    const unsigned int bpc_mask = BPC_MASK;\n    int pos = 0;\n    while ((DEFwmimax > (int)state->wmidx) && (state->wmileft <= width)) {\n        if (state->wmileft) {\n            FNAME_CALL(compress_row0_seg)(pos, cur_row, pos + state->wmileft,\n                                          bppmask[state->wmidx], bpc_mask);\n            width -= state->wmileft;\n            pos += state->wmileft;\n        }\n        state->wmidx++;\n        set_wm_trigger(state);\n        state->wmileft = DEFwminext;\n    }\n    if (width) {\n        FNAME_CALL(compress_row0_seg)(pos, cur_row, pos + width,\n                                      bppmask[state->wmidx], bpc_mask);\n        if (DEFwmimax > (int)state->wmidx) {\n            state->wmileft -= width;\n        }\n    }\n    spice_assert((int)state->wmidx <= DEFwmimax);\n    spice_assert(state->wmidx <= 32);\n    spice_assert(DEFwminext > 0);\n}", "target": 0}
{"code": "void connection_graceful_shutdown_maint (server *srv) {\n    connections * const conns = &srv->conns;\n    const int graceful_expire =\n      (srv->graceful_expire_ts && srv->graceful_expire_ts < log_epoch_secs);\n    for (uint32_t ndx = 0; ndx < conns->used; ++ndx) {\n        connection * const con = conns->ptr[ndx];\n        int changed = 0;\n        request_st * const r = &con->request;\n        if (r->state == CON_STATE_CLOSE) {\n            if (HTTP_LINGER_TIMEOUT > 1)\n                con->close_timeout_ts -= (HTTP_LINGER_TIMEOUT - 1);\n            if (log_epoch_secs - con->close_timeout_ts > HTTP_LINGER_TIMEOUT)\n                changed = 1;\n        }\n        else if (con->h2 && r->state == CON_STATE_WRITE) {\n            h2_send_goaway(con, H2_E_NO_ERROR);\n            if (0 == con->h2->rused && chunkqueue_is_empty(con->write_queue)) {\n                connection_set_state(r, CON_STATE_RESPONSE_END);\n                changed = 1;\n            }\n        }\n        else if (r->state == CON_STATE_READ && con->request_count > 1\n                 && chunkqueue_is_empty(con->read_queue)) {\n            connection_set_state_error(r, CON_STATE_ERROR);\n            changed = 1;\n        }\n        if (graceful_expire) {\n            connection_set_state_error(r, CON_STATE_ERROR);\n            changed = 1;\n        }\n        r->keep_alive = 0;            \n        r->conf.bytes_per_second = 0;         \n        r->conf.global_bytes_per_second = 0;  \n        if (con->traffic_limit_reached) {\n            con->traffic_limit_reached = 0;\n            changed = 1;\n        }\n        if (changed) {\n            connection_state_machine(con);\n        }\n    }\n}", "target": 0}
{"code": "static int adpt_i2o_install_device(adpt_hba* pHba, struct i2o_device *d)\n{\n\tmutex_lock(&adpt_configuration_lock);\n\td->controller=pHba;\n\td->owner=NULL;\n\td->next=pHba->devices;\n\td->prev=NULL;\n\tif (pHba->devices != NULL){\n\t\tpHba->devices->prev=d;\n\t}\n\tpHba->devices=d;\n\t*d->dev_name = 0;\n\tmutex_unlock(&adpt_configuration_lock);\n\treturn 0;\n}", "target": 1}
{"code": "int RGWHandler_REST_S3::init(RGWRados *store, struct req_state *s,\n                             rgw::io::BasicClient *cio)\n{\n  int ret;\n  s->dialect = \"s3\";\n  ret = rgw_validate_tenant_name(s->bucket_tenant);\n  if (ret)\n    return ret;\n  bool relaxed_names = s->cct->_conf->rgw_relaxed_s3_bucket_names;\n  if (!s->bucket_name.empty()) {\n    ret = valid_s3_bucket_name(s->bucket_name, relaxed_names);\n    if (ret)\n      return ret;\n    ret = validate_object_name(s->object.name);\n    if (ret)\n      return ret;\n  }\n  const char *cacl = s->info.env->get(\"HTTP_X_AMZ_ACL\");\n  if (cacl)\n    s->canned_acl = cacl;\n  s->has_acl_header = s->info.env->exists_prefix(\"HTTP_X_AMZ_GRANT\");\n  const char *copy_source = s->info.env->get(\"HTTP_X_AMZ_COPY_SOURCE\");\n  if (copy_source &&\n      (! s->info.env->get(\"HTTP_X_AMZ_COPY_SOURCE_RANGE\")) &&\n      (! s->info.args.exists(\"uploadId\"))) {\n    ret = RGWCopyObj::parse_copy_location(copy_source,\n                                          s->init_state.src_bucket,\n                                          s->src_object);\n    if (!ret) {\n      ldout(s->cct, 0) << \"failed to parse copy location\" << dendl;\n      return -EINVAL; \n    }\n  }\n  return RGWHandler_REST::init(store, s, cio);\n}", "target": 0}
{"code": "static void addrconf_dev_config(struct net_device *dev)\n{\n\tstruct in6_addr addr;\n\tstruct inet6_dev *idev;\n\tASSERT_RTNL();\n\tif ((dev->type != ARPHRD_ETHER) &&\n\t    (dev->type != ARPHRD_FDDI) &&\n\t    (dev->type != ARPHRD_ARCNET) &&\n\t    (dev->type != ARPHRD_INFINIBAND) &&\n\t    (dev->type != ARPHRD_IEEE802154) &&\n\t    (dev->type != ARPHRD_IEEE1394)) {\n\t\treturn;\n\t}\n\tidev = addrconf_add_dev(dev);\n\tif (IS_ERR(idev))\n\t\treturn;\n\tmemset(&addr, 0, sizeof(struct in6_addr));\n\taddr.s6_addr32[0] = htonl(0xFE800000);\n\tif (ipv6_generate_eui64(addr.s6_addr + 8, dev) == 0)\n\t\taddrconf_add_linklocal(idev, &addr);\n}", "target": 0}
{"code": "v8::Local<v8::Value> SerializedScriptValue::deserialize(MessagePortArray* messagePorts)\n{\n    return deserialize(v8::Isolate::GetCurrent(), messagePorts, 0);\n}", "target": 0}
{"code": "void btrfs_trans_release_chunk_metadata(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tif (!trans->chunk_bytes_reserved)\n\t\treturn;\n\tWARN_ON_ONCE(!list_empty(&trans->new_bgs));\n\tbtrfs_block_rsv_release(fs_info, &fs_info->chunk_block_rsv,\n\t\t\t\ttrans->chunk_bytes_reserved, NULL);\n\tatomic64_sub(trans->chunk_bytes_reserved, &cur_trans->chunk_bytes_reserved);\n\tcond_wake_up(&cur_trans->chunk_reserve_wait);\n\ttrans->chunk_bytes_reserved = 0;\n}", "target": 1}
{"code": "mm_answer_rsa_challenge(int socket, Buffer *m)\n{\n\tKey *key = NULL;\n\tu_char *blob;\n\tu_int blen;\n\tdebug3(\"%s entering\", __func__);\n\tif (!authctxt->valid)\n\t\tfatal(\"%s: authctxt not valid\", __func__);\n\tblob = buffer_get_string(m, &blen);\n\tif (!monitor_allowed_key(blob, blen))\n\t\tfatal(\"%s: bad key, not previously allowed\", __func__);\n\tif (key_blobtype != MM_RSAUSERKEY && key_blobtype != MM_RSAHOSTKEY)\n\t\tfatal(\"%s: key type mismatch\", __func__);\n\tif ((key = key_from_blob(blob, blen)) == NULL)\n\t\tfatal(\"%s: received bad key\", __func__);\n\tif (ssh1_challenge)\n\t\tBN_clear_free(ssh1_challenge);\n\tssh1_challenge = auth_rsa_generate_challenge(key);\n\tbuffer_clear(m);\n\tbuffer_put_bignum2(m, ssh1_challenge);\n\tdebug3(\"%s sending reply\", __func__);\n\tmm_request_send(socket, MONITOR_ANS_RSACHALLENGE, m);\n\tmonitor_permit(mon_dispatch, MONITOR_REQ_RSARESPONSE, 1);\n\txfree(blob);\n\tkey_free(key);\n\treturn (0);\n}", "target": 0}
{"code": "static void fio_cluster_signal_children(void) {\n  if (fio_parent_pid() != getpid()) {\n    fio_stop();\n    return;\n  }\n  fio_cluster_server_sender(fio_msg_internal_create(0, FIO_CLUSTER_MSG_SHUTDOWN,\n                                                    (fio_str_info_s){.len = 0},\n                                                    (fio_str_info_s){.len = 0},\n                                                    0, 1),\n                            -1);\n}", "target": 1}
{"code": "static int print_branch_option(const char *refname, const struct object_id *oid,\n\t\t\t       int flags, void *cb_data)\n{\n\tchar *name = (char *)refname;\n\thtml_option(name, name, ctx.qry.head);\n\treturn 0;\n}", "target": 0}
{"code": "bool CSPSource::schemeMatches(const KURL& url) const\n {\n     if (m_scheme.isEmpty())\n         return m_policy->protocolMatchesSelf(url);\n     return equalIgnoringCase(url.protocol(), m_scheme);\n }", "target": 1}
{"code": "uint16_t read16(uint8_t* arr, int pos,  int swapBytes)\n{\n    uint8_t b1 = arr[pos];\n    uint8_t b2 = arr[pos+1];\n    return (swapBytes) ?  ((b2 << 8) | b1) : ((b1 << 8) | b2);\n}", "target": 0}
{"code": "int service_init(int argc __attribute__((unused)),\n\t\t char **argv __attribute__((unused)),\n\t\t char **envp __attribute__((unused)))\n{\n    int opt;\n    const char *prefix;\n    initialize_nntp_error_table();\n    if (geteuid() == 0) fatal(\"must run as the Cyrus user\", EC_USAGE);\n    setproctitle_init(argc, argv, envp);\n    signals_set_shutdown(&shut_down);\n    signal(SIGPIPE, SIG_IGN);\n    global_sasl_init(1, 1, mysasl_cb);\n    if ((prefix = config_getstring(IMAPOPT_NEWSPREFIX)))\n\tsnprintf(newsprefix, sizeof(newsprefix), \"%s.\", prefix);\n    newsgroups = split_wildmats((char *) config_getstring(IMAPOPT_NEWSGROUPS));\n    if (duplicate_init(NULL, 0) != 0) {\n\tsyslog(LOG_ERR, \n\t       \"unable to init duplicate delivery database\\n\");\n\tfatal(\"unable to init duplicate delivery database\", EC_SOFTWARE);\n    }\n    mboxlist_init(0);\n    mboxlist_open(NULL);\n    quotadb_init(0);\n    quotadb_open(NULL);\n    denydb_init(0);\n    denydb_open(NULL);\n    idle_enabled();\n    while ((opt = getopt(argc, argv, \"srfp:\")) != EOF) {\n\tswitch(opt) {\n\tcase 's': \n\t    nntps = 1;\n\t    if (!tls_enabled()) {\n\t\tsyslog(LOG_ERR, \"nntps: required OpenSSL options not present\");\n\t\tfatal(\"nntps: required OpenSSL options not present\",\n\t\t      EC_CONFIG);\n\t    }\n\t    break;\n\tcase 'r': \n\t    nntp_capa = MODE_READ;\n\t    break;\n\tcase 'f': \n\t    nntp_capa = MODE_FEED;\n\t    break;\n\tcase 'p': \n\t    extprops_ssf = atoi(optarg);\n\t    break;\n\tdefault:\n\t    usage();\n\t}\n    }\n    annotatemore_init(NULL, NULL);\n    annotatemore_open();\n    newsmaster = (char *) config_getstring(IMAPOPT_NEWSMASTER);\n    newsmaster_authstate = auth_newstate(newsmaster);\n    singleinstance = config_getswitch(IMAPOPT_SINGLEINSTANCESTORE);\n    protin = protgroup_new(2);\n    return 0;\n}", "target": 0}
{"code": "bool Parcel::allowFds() const\n{\n return mAllowFds;\n}", "target": 0}
{"code": "method_invocation_get_uid (GDBusMethodInvocation *context)\n{\n  const gchar *sender;\n  PolkitSubject *busname;\n  PolkitSubject *process;\n  uid_t uid;\n  sender = g_dbus_method_invocation_get_sender (context);\n  busname = polkit_system_bus_name_new (sender);\n  process = polkit_system_bus_name_get_process_sync (POLKIT_SYSTEM_BUS_NAME (busname), NULL, NULL);\n  uid = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (process));\n  g_object_unref (busname);\n  g_object_unref (process);\n  return uid;\n}", "target": 1}
{"code": "static int __init sit_init(void)\n{\n\tint err;\n\tprintk(KERN_INFO \"IPv6 over IPv4 tunneling driver\\n\");\n\tif (xfrm4_tunnel_register(&sit_handler, AF_INET6) < 0) {\n\t\tprintk(KERN_INFO \"sit init: Can't add protocol\\n\");\n\t\treturn -EAGAIN;\n\t}\n\terr = register_pernet_device(&sit_net_ops);\n\tif (err < 0)\n\t\txfrm4_tunnel_deregister(&sit_handler, AF_INET6);\n\treturn err;\n}", "target": 1}
{"code": "initialize(int argc, VALUE argv[], VALUE self)\n{\n    ffi_cif * cif;\n    ffi_type **arg_types;\n    ffi_status result;\n    VALUE ptr, args, ret_type, abi, kwds;\n    long i;\n    rb_scan_args(argc, argv, \"31:\", &ptr, &args, &ret_type, &abi, &kwds);\n    if(NIL_P(abi)) abi = INT2NUM(FFI_DEFAULT_ABI);\n    Check_Type(args, T_ARRAY);\n    Check_Max_Args(\"args\", RARRAY_LENINT(args));\n    rb_iv_set(self, \"@ptr\", ptr);\n    rb_iv_set(self, \"@args\", args);\n    rb_iv_set(self, \"@return_type\", ret_type);\n    rb_iv_set(self, \"@abi\", abi);\n    if (!NIL_P(kwds)) rb_hash_foreach(kwds, parse_keyword_arg_i, self);\n    TypedData_Get_Struct(self, ffi_cif, &function_data_type, cif);\n    arg_types = xcalloc(RARRAY_LEN(args) + 1, sizeof(ffi_type *));\n    for (i = 0; i < RARRAY_LEN(args); i++) {\n\tint type = NUM2INT(RARRAY_AREF(args, i));\n\targ_types[i] = INT2FFI_TYPE(type);\n    }\n    arg_types[RARRAY_LEN(args)] = NULL;\n    result = ffi_prep_cif (\n\t    cif,\n\t    NUM2INT(abi),\n\t    RARRAY_LENINT(args),\n\t    INT2FFI_TYPE(NUM2INT(ret_type)),\n\t    arg_types);\n    if (result)\n\trb_raise(rb_eRuntimeError, \"error creating CIF %d\", result);\n    return self;\n}", "target": 1}
{"code": "static void perf_event_comm_event(struct perf_comm_event *comm_event)\n{\n\tstruct perf_cpu_context *cpuctx;\n\tstruct perf_event_context *ctx;\n\tchar comm[TASK_COMM_LEN];\n\tunsigned int size;\n\tstruct pmu *pmu;\n\tint ctxn;\n\tmemset(comm, 0, sizeof(comm));\n\tstrlcpy(comm, comm_event->task->comm, sizeof(comm));\n\tsize = ALIGN(strlen(comm)+1, sizeof(u64));\n\tcomm_event->comm = comm;\n\tcomm_event->comm_size = size;\n\tcomm_event->event_id.header.size = sizeof(comm_event->event_id) + size;\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pmu, &pmus, entry) {\n\t\tcpuctx = get_cpu_ptr(pmu->pmu_cpu_context);\n\t\tif (cpuctx->unique_pmu != pmu)\n\t\t\tgoto next;\n\t\tperf_event_comm_ctx(&cpuctx->ctx, comm_event);\n\t\tctxn = pmu->task_ctx_nr;\n\t\tif (ctxn < 0)\n\t\t\tgoto next;\n\t\tctx = rcu_dereference(current->perf_event_ctxp[ctxn]);\n\t\tif (ctx)\n\t\t\tperf_event_comm_ctx(ctx, comm_event);\nnext:\n\t\tput_cpu_ptr(pmu->pmu_cpu_context);\n\t}\n\trcu_read_unlock();\n}", "target": 0}
{"code": "void luaT_adjustvarargs (lua_State *L, int nfixparams, CallInfo *ci,\n                         const Proto *p) {\n  int i;\n  int actual = cast_int(L->top - ci->func) - 1;  \n  int nextra = actual - nfixparams;  \n  ci->u.l.nextraargs = nextra;\n  checkstackGC(L, p->maxstacksize + 1);\n  setobjs2s(L, L->top++, ci->func);\n  for (i = 1; i <= nfixparams; i++) {\n    setobjs2s(L, L->top++, ci->func + i);\n    setnilvalue(s2v(ci->func + i));  \n  }\n  ci->func += actual + 1;\n  ci->top += actual + 1;\n  lua_assert(L->top <= ci->top && ci->top <= L->stack_last);\n}", "target": 1}
{"code": "JOIN_TAB *first_linear_tab(JOIN *join,\n                           enum enum_with_bush_roots include_bush_roots,\n                           enum enum_with_const_tables const_tbls)\n{\n  JOIN_TAB *first= join->join_tab;\n  if (!first)\n    return NULL;\n  if (const_tbls == WITHOUT_CONST_TABLES)\n    first+= join->const_tables;\n  if (first >= join->join_tab + join->top_join_tab_count)\n    return NULL; \n  if (first->bush_children && include_bush_roots == WITHOUT_BUSH_ROOTS)\n  {\n    return first->bush_children->start;\n  }\n  return first;\n}", "target": 0}
{"code": "send_client_notifications (void)\n{\n  struct {\n    pid_t pid;\n#ifdef HAVE_W32_SYSTEM\n    HANDLE handle;\n#else\n    int signo;\n#endif\n  } killed[50];\n  int killidx = 0;\n  int kidx;\n  struct server_local_s *sl;\n  for (sl=session_list; sl; sl = sl->next_session)\n    {\n      if (sl->event_signal && sl->assuan_ctx)\n        {\n          pid_t pid = assuan_get_pid (sl->assuan_ctx);\n#ifdef HAVE_W32_SYSTEM\n          HANDLE handle = (void *)sl->event_signal;\n          for (kidx=0; kidx < killidx; kidx++)\n            if (killed[kidx].pid == pid\n                && killed[kidx].handle == handle)\n              break;\n          if (kidx < killidx)\n            log_info (\"event %lx (%p) already triggered for client %d\\n\",\n                      sl->event_signal, handle, (int)pid);\n          else\n            {\n              log_info (\"triggering event %lx (%p) for client %d\\n\",\n                        sl->event_signal, handle, (int)pid);\n              if (!SetEvent (handle))\n                log_error (\"SetEvent(%lx) failed: %s\\n\",\n                           sl->event_signal, w32_strerror (-1));\n              if (killidx < DIM (killed))\n                {\n                  killed[killidx].pid = pid;\n                  killed[killidx].handle = handle;\n                  killidx++;\n                }\n            }\n#else \n          int signo = sl->event_signal;\n          if (pid != (pid_t)(-1) && pid && signo > 0)\n            {\n              for (kidx=0; kidx < killidx; kidx++)\n                if (killed[kidx].pid == pid\n                    && killed[kidx].signo == signo)\n                  break;\n              if (kidx < killidx)\n                log_info (\"signal %d already sent to client %d\\n\",\n                          signo, (int)pid);\n              else\n                {\n                  log_info (\"sending signal %d to client %d\\n\",\n                            signo, (int)pid);\n                  kill (pid, signo);\n                  if (killidx < DIM (killed))\n                    {\n                      killed[killidx].pid = pid;\n                      killed[killidx].signo = signo;\n                      killidx++;\n                    }\n                }\n            }\n#endif \n        }\n    }\n}", "target": 0}
{"code": "flatpak_run_add_journal_args (FlatpakBwrap *bwrap)\n{\n  g_autofree char *journal_socket_socket = g_strdup (\"/run/systemd/journal/socket\");\n  g_autofree char *journal_stdout_socket = g_strdup (\"/run/systemd/journal/stdout\");\n  if (g_file_test (journal_socket_socket, G_FILE_TEST_EXISTS))\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", journal_socket_socket, journal_socket_socket,\n                              NULL);\n    }\n  if (g_file_test (journal_stdout_socket, G_FILE_TEST_EXISTS))\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", journal_stdout_socket, journal_stdout_socket,\n                              NULL);\n    }\n}", "target": 0}
{"code": "static void interface_release_resource(QXLInstance *sin,\n                                       QXLReleaseInfoExt ext)\n{\n    PCIQXLDevice *qxl = container_of(sin, PCIQXLDevice, ssd.qxl);\n    QXLReleaseRing *ring;\n    uint64_t *item, id;\n    if (ext.group_id == MEMSLOT_GROUP_HOST) {\n        QXLCommandExt *cmdext = (void *)(intptr_t)(ext.info->id);\n        SimpleSpiceUpdate *update;\n        g_assert(cmdext->cmd.type == QXL_CMD_DRAW);\n        update = container_of(cmdext, SimpleSpiceUpdate, ext);\n        qemu_spice_destroy_update(&qxl->ssd, update);\n        return;\n    }\n    ring = &qxl->ram->release_ring;\n    SPICE_RING_PROD_ITEM(qxl, ring, item);\n    if (!item) {\n        return;\n    }\n    if (*item == 0) {\n        id = ext.info->id;\n        ext.info->next = 0;\n        qxl_ram_set_dirty(qxl, &ext.info->next);\n        *item = id;\n        qxl_ring_set_dirty(qxl);\n    } else {\n        qxl->last_release->next = ext.info->id;\n        qxl_ram_set_dirty(qxl, &qxl->last_release->next);\n        ext.info->next = 0;\n        qxl_ram_set_dirty(qxl, &ext.info->next);\n    }\n    qxl->last_release = ext.info;\n    qxl->num_free_res++;\n    trace_qxl_ring_res_put(qxl->id, qxl->num_free_res);\n    qxl_push_free_res(qxl, 0);\n}", "target": 1}
{"code": "init_ext2_xattr(void)\n{\n\treturn 0;\n}", "target": 1}
{"code": "find_link_ref(struct link_ref **references, uint8_t *name, size_t length)\n{\n\tunsigned int hash = hash_link_ref(name, length);\n\tstruct link_ref *ref = NULL;\n\tref = references[hash % REF_TABLE_SIZE];\n\twhile (ref != NULL) {\n\t\tif (ref->id == hash)\n\t\t\treturn ref;\n\t\tref = ref->next;\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "nfp_abm_u32_knode_replace(struct nfp_abm_link *alink,\n\t\t\t  struct tc_cls_u32_knode *knode,\n\t\t\t  __be16 proto, struct netlink_ext_ack *extack)\n{\n\tstruct nfp_abm_u32_match *match = NULL, *iter;\n\tunsigned int tos_off;\n\tu8 mask, val;\n\tint err;\n\tif (!nfp_abm_u32_check_knode(alink->abm, knode, proto, extack))\n\t\tgoto err_delete;\n\ttos_off = proto == htons(ETH_P_IP) ? 16 : 20;\n\tval = be32_to_cpu(knode->sel->keys[0].val) >> tos_off & 0xff;\n\tmask = be32_to_cpu(knode->sel->keys[0].mask) >> tos_off & 0xff;\n\tlist_for_each_entry(iter, &alink->dscp_map, list) {\n\t\tu32 cmask;\n\t\tif (iter->handle == knode->handle) {\n\t\t\tmatch = iter;\n\t\t\tcontinue;\n\t\t}\n\t\tcmask = iter->mask & mask;\n\t\tif ((iter->val & cmask) == (val & cmask) &&\n\t\t    iter->band != knode->res->classid) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"conflict with already offloaded filter\");\n\t\t\tgoto err_delete;\n\t\t}\n\t}\n\tif (!match) {\n\t\tmatch = kzalloc(sizeof(*match), GFP_KERNEL);\n\t\tif (!match)\n\t\t\treturn -ENOMEM;\n\t\tlist_add(&match->list, &alink->dscp_map);\n\t}\n\tmatch->handle = knode->handle;\n\tmatch->band = knode->res->classid;\n\tmatch->mask = mask;\n\tmatch->val = val;\n\terr = nfp_abm_update_band_map(alink);\n\tif (err)\n\t\tgoto err_delete;\n\treturn 0;\nerr_delete:\n\tnfp_abm_u32_knode_delete(alink, knode);\n\treturn -EOPNOTSUPP;\n}", "target": 1}
{"code": "static int IntensityCompare(const void *x,const void *y)\n{\n  PixelPacket\n    *color_1,\n    *color_2;\n  ssize_t\n    intensity;\n  color_1=(PixelPacket *) x;\n  color_2=(PixelPacket *) y;\n  intensity=(ssize_t) PixelPacketIntensity(color_1)-\n    (ssize_t) PixelPacketIntensity(color_2);\n  return((int) intensity);\n}", "target": 1}
{"code": "struct dentry *debugfs_rename(struct dentry *old_dir, struct dentry *old_dentry,\n\t\tstruct dentry *new_dir, const char *new_name)\n{\n\tint error;\n\tstruct dentry *dentry = NULL, *trap;\n\tconst char *old_name;\n\ttrap = lock_rename(new_dir, old_dir);\n\tif (d_really_is_negative(old_dir) || d_really_is_negative(new_dir))\n\t\tgoto exit;\n\tif (d_really_is_negative(old_dentry) || old_dentry == trap ||\n\t    d_mountpoint(old_dentry))\n\t\tgoto exit;\n\tdentry = lookup_one_len(new_name, new_dir, strlen(new_name));\n\tif (IS_ERR(dentry) || dentry == trap || d_really_is_positive(dentry))\n\t\tgoto exit;\n\told_name = fsnotify_oldname_init(old_dentry->d_name.name);\n\terror = simple_rename(d_inode(old_dir), old_dentry, d_inode(new_dir),\n\t\t\t      dentry, 0);\n\tif (error) {\n\t\tfsnotify_oldname_free(old_name);\n\t\tgoto exit;\n\t}\n\td_move(old_dentry, dentry);\n\tfsnotify_move(d_inode(old_dir), d_inode(new_dir), old_name,\n\t\td_is_dir(old_dentry),\n\t\tNULL, old_dentry);\n\tfsnotify_oldname_free(old_name);\n\tunlock_rename(new_dir, old_dir);\n\tdput(dentry);\n\treturn old_dentry;\nexit:\n\tif (dentry && !IS_ERR(dentry))\n\t\tdput(dentry);\n\tunlock_rename(new_dir, old_dir);\n\treturn NULL;\n}", "target": 1}
{"code": "static int write_empty_blocks(struct page *page, unsigned from, unsigned to,\n\t\t\t      int mode)\n{\n\tstruct inode *inode = page->mapping->host;\n\tunsigned start, end, next, blksize;\n\tsector_t block = page->index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\tint ret;\n\tblksize = 1 << inode->i_blkbits;\n\tnext = end = 0;\n\twhile (next < from) {\n\t\tnext += blksize;\n\t\tblock++;\n\t}\n\tstart = next;\n\tdo {\n\t\tnext += blksize;\n\t\tret = needs_empty_write(block, inode);\n\t\tif (unlikely(ret < 0))\n\t\t\treturn ret;\n\t\tif (ret == 0) {\n\t\t\tif (end) {\n\t\t\t\tret = __block_write_begin(page, start, end - start,\n\t\t\t\t\t\t\t  gfs2_block_map);\n\t\t\t\tif (unlikely(ret))\n\t\t\t\t\treturn ret;\n\t\t\t\tret = empty_write_end(page, start, end, mode);\n\t\t\t\tif (unlikely(ret))\n\t\t\t\t\treturn ret;\n\t\t\t\tend = 0;\n\t\t\t}\n\t\t\tstart = next;\n\t\t}\n\t\telse\n\t\t\tend = next;\n\t\tblock++;\n\t} while (next < to);\n\tif (end) {\n\t\tret = __block_write_begin(page, start, end - start, gfs2_block_map);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t\tret = empty_write_end(page, start, end, mode);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "cdf_read_short_sector(const cdf_stream_t *sst, void *buf, size_t offs,\n    size_t len, const cdf_header_t *h, cdf_secid_t id)\n{\n\tassert((size_t)CDF_SHORT_SEC_SIZE(h) == len);\n\t(void)memcpy(((char *)buf) + offs,\n\t    ((const char *)sst->sst_tab) + CDF_SHORT_SEC_POS(h, id), len);\n\treturn len;\n}", "target": 1}
{"code": "static int sctp_bindx_rem(struct sock *sk, struct sockaddr *addrs, int addrcnt)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_endpoint *ep = sp->ep;\n\tint cnt;\n\tstruct sctp_bind_addr *bp = &ep->base.bind_addr;\n\tint retval = 0;\n\tvoid *addr_buf;\n\tunion sctp_addr *sa_addr;\n\tstruct sctp_af *af;\n\tSCTP_DEBUG_PRINTK(\"sctp_bindx_rem (sk: %p, addrs: %p, addrcnt: %d)\\n\",\n\t\t\t  sk, addrs, addrcnt);\n\taddr_buf = addrs;\n\tfor (cnt = 0; cnt < addrcnt; cnt++) {\n\t\tif (list_empty(&bp->address_list) ||\n\t\t    (sctp_list_single_entry(&bp->address_list))) {\n\t\t\tretval = -EBUSY;\n\t\t\tgoto err_bindx_rem;\n\t\t}\n\t\tsa_addr = (union sctp_addr *)addr_buf;\n\t\taf = sctp_get_af_specific(sa_addr->sa.sa_family);\n\t\tif (!af) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto err_bindx_rem;\n\t\t}\n\t\tif (!af->addr_valid(sa_addr, sp, NULL)) {\n\t\t\tretval = -EADDRNOTAVAIL;\n\t\t\tgoto err_bindx_rem;\n\t\t}\n\t\tif (sa_addr->v4.sin_port != htons(bp->port)) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto err_bindx_rem;\n\t\t}\n\t\tretval = sctp_del_bind_addr(bp, sa_addr);\n\t\taddr_buf += af->sockaddr_len;\nerr_bindx_rem:\n\t\tif (retval < 0) {\n\t\t\tif (cnt > 0)\n\t\t\t\tsctp_bindx_add(sk, addrs, cnt);\n\t\t\treturn retval;\n\t\t}\n\t}\n\treturn retval;\n}", "target": 0}
{"code": "shiftAnchorPosition(AnchorList *al, HmarkerList *hl, int line, int pos,\n\t\t    int shift)\n{\n    Anchor *a;\n    size_t b, e, s = 0;\n    int cmp;\n    if (al == NULL || al->nanchor == 0)\n\treturn;\n    s = al->nanchor / 2;\n    for (b = 0, e = al->nanchor - 1; b <= e; s = (b + e + 1) / 2) {\n\ta = &al->anchors[s];\n\tcmp = onAnchor(a, line, pos);\n\tif (cmp == 0)\n\t    break;\n\telse if (cmp > 0)\n\t    b = s + 1;\n\telse if (s == 0)\n\t    break;\n\telse\n\t    e = s - 1;\n    }\n    for (; s < al->nanchor; s++) {\n\ta = &al->anchors[s];\n\tif (a->start.line > line)\n\t    break;\n\tif (a->start.pos > pos) {\n\t    a->start.pos += shift;\n\t    if (hl->marks[a->hseq].line == line)\n\t\thl->marks[a->hseq].pos = a->start.pos;\n\t}\n\tif (a->end.pos >= pos)\n\t    a->end.pos += shift;\n    }\n}", "target": 1}
{"code": "digest_hex(unsigned char *p)\n{\n    char *h = \"0123456789abcdef\";\n    Str tmp = Strnew_size(MD5_DIGEST_LENGTH * 2 + 1);\n    int i;\n    for (i = 0; i < MD5_DIGEST_LENGTH; i++, p++) {\n\tStrcat_char(tmp, h[(*p >> 4) & 0x0f]);\n\tStrcat_char(tmp, h[*p & 0x0f]);\n    }\n    return tmp;\n}", "target": 0}
{"code": "static int ax25_create(struct net *net, struct socket *sock, int protocol,\n\t\t       int kern)\n{\n \tstruct sock *sk;\n \tax25_cb *ax25;\n\tif (protocol < 0 || protocol > SK_PROTOCOL_MAX)\n\t\treturn -EINVAL;\n \tif (!net_eq(net, &init_net))\n \t\treturn -EAFNOSUPPORT;\n\tswitch (sock->type) {\n\tcase SOCK_DGRAM:\n\t\tif (protocol == 0 || protocol == PF_AX25)\n\t\t\tprotocol = AX25_P_TEXT;\n\t\tbreak;\n\tcase SOCK_SEQPACKET:\n\t\tswitch (protocol) {\n\t\tcase 0:\n\t\tcase PF_AX25:\t\n\t\t\tprotocol = AX25_P_TEXT;\n\t\t\tbreak;\n\t\tcase AX25_P_SEGMENT:\n#ifdef CONFIG_INET\n\t\tcase AX25_P_ARP:\n\t\tcase AX25_P_IP:\n#endif\n#ifdef CONFIG_NETROM\n\t\tcase AX25_P_NETROM:\n#endif\n#ifdef CONFIG_ROSE\n\t\tcase AX25_P_ROSE:\n#endif\n\t\t\treturn -ESOCKTNOSUPPORT;\n#ifdef CONFIG_NETROM_MODULE\n\t\tcase AX25_P_NETROM:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_NETROM))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_ROSE_MODULE\n\t\tcase AX25_P_ROSE:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_ROSE))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SOCK_RAW:\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\tsk = sk_alloc(net, PF_AX25, GFP_ATOMIC, &ax25_proto, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\tax25 = ax25_sk(sk)->cb = ax25_create_cb();\n\tif (!ax25) {\n\t\tsk_free(sk);\n\t\treturn -ENOMEM;\n\t}\n\tsock_init_data(sock, sk);\n\tsk->sk_destruct = ax25_free_sock;\n\tsock->ops    = &ax25_proto_ops;\n\tsk->sk_protocol = protocol;\n\tax25->sk    = sk;\n\treturn 0;\n}", "target": 0}
{"code": "    const std::unordered_map<std::string, std::string> &getHeaders() const\n    {\n        return headers();\n    }", "target": 1}
{"code": "    template<typename t>\n    CImg<_cimg_Ttfloat> get_solve(const CImg<t>& A) const {\n      return CImg<_cimg_Ttfloat>(*this,false).solve(A);", "target": 0}
{"code": "static void OneLine(struct bmp_progressive_state *context)\n{\n\tcontext->BufferDone = 0;\n\tif (context->Lines >= context->Header.height)\n\t\treturn;\n\tif (context->Type == 32)\n\t\tOneLine32(context);\n\telse if (context->Type == 24)\n\t\tOneLine24(context);\n\telse if (context->Type == 16)\n\t\tOneLine16(context);\n\telse if (context->Type == 8)\n\t\tOneLine8(context);\n\telse if (context->Type == 4)\n\t\tOneLine4(context);\n\telse if (context->Type == 1)\n\t\tOneLine1(context);\n\telse\n\t\tg_assert_not_reached ();\n\tcontext->Lines++;\n\tif (context->updated_func != NULL) {\n\t\t(*context->updated_func) (context->pixbuf,\n\t\t\t\t\t  0,\n\t\t\t\t\t  (context->Header.Negative ?\n\t\t\t\t\t   (context->Lines - 1) :\n\t\t\t\t\t   (context->Header.height - context->Lines)),\n\t\t\t\t\t  context->Header.width,\n\t\t\t\t\t  1,\n\t\t\t\t\t  context->user_data);\n\t}\n}", "target": 0}
{"code": "static int get_crl_sk(X509_STORE_CTX *ctx, X509_CRL **pcrl, X509_CRL **pdcrl,\n                      X509 **pissuer, int *pscore, unsigned int *preasons,\n                      STACK_OF(X509_CRL) *crls)\n{\n    int i, crl_score, best_score = *pscore;\n    unsigned int reasons, best_reasons = 0;\n    X509 *x = ctx->current_cert;\n    X509_CRL *crl, *best_crl = NULL;\n    X509 *crl_issuer = NULL, *best_crl_issuer = NULL;\n    for (i = 0; i < sk_X509_CRL_num(crls); i++) {\n         crl = sk_X509_CRL_value(crls, i);\n         reasons = *preasons;\n         crl_score = get_crl_score(ctx, &crl_issuer, &reasons, crl, x);\n        if (crl_score < best_score)\n             continue;\n        if (crl_score == best_score) {\n             int day, sec;\n             if (ASN1_TIME_diff(&day, &sec, X509_CRL_get_lastUpdate(best_crl),\n                                X509_CRL_get_lastUpdate(crl)) == 0)\n                continue;\n            if (day <= 0 && sec <= 0)\n                continue;\n        }\n        best_crl = crl;\n        best_crl_issuer = crl_issuer;\n        best_score = crl_score;\n        best_reasons = reasons;\n    }\n    if (best_crl) {\n        if (*pcrl)\n            X509_CRL_free(*pcrl);\n        *pcrl = best_crl;\n        *pissuer = best_crl_issuer;\n        *pscore = best_score;\n        *preasons = best_reasons;\n        CRYPTO_add(&best_crl->references, 1, CRYPTO_LOCK_X509_CRL);\n        if (*pdcrl) {\n            X509_CRL_free(*pdcrl);\n            *pdcrl = NULL;\n        }\n        get_delta_sk(ctx, pdcrl, pscore, best_crl, crls);\n    }\n    if (best_score >= CRL_SCORE_VALID)\n        return 1;\n    return 0;\n}", "target": 1}
{"code": "void _reset_fxsave_state()\n{\n    static OE_ALIGNED(OE_FXSAVE_ALIGNMENT) const uint64_t\n        _initial_fxstate[OE_FXSAVE_AREA_SIZE / sizeof(uint64_t)] = {\n            0x037F, 0, 0, 0xFFFF00001F80,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n        };\n    asm volatile(\"fxrstor %[fx_state] \\n\\t\"\n                 :\n                 : [fx_state] \"m\"(_initial_fxstate)\n                 :);\n}", "target": 1}
