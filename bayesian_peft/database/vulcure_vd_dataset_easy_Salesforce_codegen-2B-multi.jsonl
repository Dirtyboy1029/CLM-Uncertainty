{"code": "AP_DECLARE(void) ap_set_last_modified(request_rec *r)\n{\n    if (!r->assbackwards) {\n        apr_time_t mod_time = ap_rationalize_mtime(r, r->mtime);\n        char *datestr = apr_palloc(r->pool, APR_RFC822_DATE_LEN);\n        apr_rfc822_date(datestr, mod_time);\n        apr_table_setn(r->headers_out, \"Last-Modified\", datestr);\n    }\n}", "target": 0}
{"code": "static void bfq_idle_slice_timer_body(struct bfq_queue *bfqq)\n{\n\tstruct bfq_data *bfqd = bfqq->bfqd;\n\tenum bfqq_expiration reason;\n\tunsigned long flags;\n\tspin_lock_irqsave(&bfqd->lock, flags);\n\tbfq_clear_bfqq_wait_request(bfqq);\n\tif (bfqq != bfqd->in_service_queue) {\n\t\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\t\treturn;\n\t}\n\tif (bfq_bfqq_budget_timeout(bfqq))\n\t\treason = BFQQE_BUDGET_TIMEOUT;\n\telse if (bfqq->queued[0] == 0 && bfqq->queued[1] == 0)\n\t\treason = BFQQE_TOO_IDLE;\n\telse\n\t\tgoto schedule_dispatch;\n\tbfq_bfqq_expire(bfqd, bfqq, true, reason);\nschedule_dispatch:\n\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\tbfq_schedule_dispatch(bfqd);", "target": 1}
{"code": "recv_fd (const int sock)\n{\n  struct msghdr msg = {0};\n  union\n    {\n      struct cmsghdr hdr;\n      char buf[CMSG_SPACE(sizeof(int))];\n    } cmsgbuf = {0};\n  struct cmsghdr *cmsg;\n  struct iovec vec;\n  ssize_t n;\n  char ch = '\\0';\n  int fd = -1;\n  vec.iov_base = &ch;\n  vec.iov_len = 1;\n  msg.msg_iov = &vec;\n  msg.msg_iovlen = 1;\n  msg.msg_control = &cmsgbuf.buf;\n  msg.msg_controllen = sizeof (cmsgbuf.buf);\n  while ((n = recvmsg (sock, &msg, 0)) == -1 && errno == EINTR);\n  if (n != 1 || ch != 'A')\n    return -1;\n  cmsg = CMSG_FIRSTHDR (&msg);\n  if (cmsg == NULL)\n    return -1;\n  if (cmsg->cmsg_type != SCM_RIGHTS)\n    return -1;\n  memcpy (&fd, CMSG_DATA (cmsg), sizeof (fd));\n  if (fd < 0)\n    return -1;\n  return fd;\n}", "target": 0}
{"code": "static bool regsafe(struct bpf_reg_state *rold, struct bpf_reg_state *rcur,\n\t\t    struct idpair *idmap)\n{\n\tif (!(rold->live & REG_LIVE_READ))\n\t\treturn true;\n\tif (memcmp(rold, rcur, offsetof(struct bpf_reg_state, live)) == 0)\n\t\treturn true;\n\tif (rold->type == NOT_INIT)\n\t\treturn true;\n\tif (rcur->type == NOT_INIT)\n\t\treturn false;\n\tswitch (rold->type) {\n\tcase SCALAR_VALUE:\n\t\tif (rcur->type == SCALAR_VALUE) {\n\t\t\treturn range_within(rold, rcur) &&\n\t\t\t       tnum_in(rold->var_off, rcur->var_off);\n\t\t} else {\n\t\t\treturn rold->umin_value == 0 &&\n\t\t\t       rold->umax_value == U64_MAX &&\n\t\t\t       rold->smin_value == S64_MIN &&\n\t\t\t       rold->smax_value == S64_MAX &&\n\t\t\t       tnum_is_unknown(rold->var_off);\n\t\t}\n\tcase PTR_TO_MAP_VALUE:\n\t\treturn memcmp(rold, rcur, offsetof(struct bpf_reg_state, id)) == 0 &&\n\t\t       range_within(rold, rcur) &&\n\t\t       tnum_in(rold->var_off, rcur->var_off);\n\tcase PTR_TO_MAP_VALUE_OR_NULL:\n\t\tif (rcur->type != PTR_TO_MAP_VALUE_OR_NULL)\n\t\t\treturn false;\n\t\tif (memcmp(rold, rcur, offsetof(struct bpf_reg_state, id)))\n\t\t\treturn false;\n\t\treturn check_ids(rold->id, rcur->id, idmap);\n\tcase PTR_TO_PACKET_META:\n\tcase PTR_TO_PACKET:\n\t\tif (rcur->type != rold->type)\n\t\t\treturn false;\n\t\tif (rold->range > rcur->range)\n\t\t\treturn false;\n\t\tif (rold->off != rcur->off)\n\t\t\treturn false;\n\t\tif (rold->id && !check_ids(rold->id, rcur->id, idmap))\n\t\t\treturn false;\n\t\treturn range_within(rold, rcur) &&\n\t\t       tnum_in(rold->var_off, rcur->var_off);\n\tcase PTR_TO_CTX:\n\tcase CONST_PTR_TO_MAP:\n\tcase PTR_TO_STACK:\n\tcase PTR_TO_PACKET_END:\n\tdefault:\n\t\treturn false;\n\t}\n\tWARN_ON_ONCE(1);\n\treturn false;\n}", "target": 1}
{"code": "void PackLinuxElf32::updateLoader(OutputFile * )\n{\n    unsigned start = linker->getSymbolOffset(\"_start\");\n    unsigned vbase = get_te32(&elfout.phdr[0].p_vaddr);\n    set_te32(&elfout.ehdr.e_entry, start + sz_pack2 + vbase);\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const float in_min = context->input(2).flat<float>()(0);\n    const float in_max = context->input(3).flat<float>()(0);\n    ImageResizerState st(align_corners_, false);\n    st.ValidateAndCreateOutput(context);\n    if (!context->status().ok()) return;\n    if (st.output->NumElements() == 0) return;\n    typename TTypes<T, 4>::ConstTensor image_data(\n        context->input(0).tensor<T, 4>());\n    typename TTypes<T, 4>::Tensor output_data(st.output->tensor<T, 4>());\n    ResizeBilinear<T>(image_data, st.height_scale, st.width_scale, in_min,\n                      in_max, half_pixel_centers_, &output_data);\n    Tensor* out_min = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, {}, &out_min));\n    out_min->flat<float>()(0) = in_min;\n    Tensor* out_max = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(2, {}, &out_max));\n    out_max->flat<float>()(0) = in_max;\n  }", "target": 1}
{"code": "bool chopOffDotted(string &domain)\n{\n  if(domain.empty() || (domain.size()==1 && domain[0]=='.'))\n    return false;\n  string::size_type fdot=domain.find('.');\n  if(fdot == string::npos)\n    return false;\n  if(fdot==domain.size()-1) \n    domain=\".\";\n  else  {\n    string::size_type remain = domain.length() - (fdot + 1);\n    char tmp[remain];\n    memcpy(tmp, domain.c_str()+fdot+1, remain);\n    domain.assign(tmp, remain);\n  }\n  return true;\n}", "target": 1}
{"code": "static void get_icu_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS) \n{\n\tconst char* loc_name        \t= NULL;\n\tint         loc_name_len    \t= 0;\n\tchar*       tag_value\t\t= NULL;\n\tchar*       empty_result\t= \"\";\n\tint         result    \t\t= 0;\n\tchar*       msg        \t\t= NULL;\n\tUErrorCode  status          \t= U_ZERO_ERROR;\n\tintl_error_reset( NULL TSRMLS_CC );\n\tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, \"s\",\n\t&loc_name ,&loc_name_len ) == FAILURE) {\n\t\tspprintf(&msg , 0, \"locale_get_%s : unable to parse input params\", tag_name );\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,  msg , 1 TSRMLS_CC );\n\t\tefree(msg);\n\t\tRETURN_FALSE;\n    }\n\tif(loc_name_len == 0) {\n\t\tloc_name = intl_locale_get_default(TSRMLS_C);\n\t}\n\ttag_value = get_icu_value_internal( loc_name , tag_name , &result ,0);\n\tif( result == -1 ) {\n\t\tif( tag_value){\n\t\t\tefree( tag_value);\n\t\t}\n\t\tRETURN_STRING( empty_result , TRUE);\n\t}\n\tif( tag_value){\n\t\tRETURN_STRING( tag_value , FALSE);\n\t}\n\tif( result ==0) {\n\t\tspprintf(&msg , 0, \"locale_get_%s : unable to get locale %s\", tag_name , tag_name );\n\t\tintl_error_set( NULL, status, msg , 1 TSRMLS_CC );\n\t\tefree(msg);\n\t\tRETURN_NULL();\n\t}\n}", "target": 1}
{"code": "  void readErr(const AsyncSocketException&) noexcept override {}", "target": 0}
{"code": "rfc2253_name(X509_NAME *name, char **str_out)\n{\n    BIO *b = NULL;\n    char *str;\n    *str_out = NULL;\n    b = BIO_new(BIO_s_mem());\n    if (b == NULL)\n        return ENOMEM;\n    if (X509_NAME_print_ex(b, name, 0, XN_FLAG_SEP_COMMA_PLUS) < 0)\n        goto error;\n    str = calloc(BIO_number_written(b) + 1, 1);\n    if (str == NULL)\n        goto error;\n    BIO_read(b, str, BIO_number_written(b));\n    BIO_free(b);\n    *str_out = str;\n    return 0;\nerror:\n    BIO_free(b);\n    return ENOMEM;\n}", "target": 0}
{"code": "static void lwp_write_int64(FILE *fout, int64_t d) {\n  fwrite(&d, sizeof(d), 1, fout);\n  fflush(fout);\n}", "target": 0}
{"code": "TEST_CASE(\"Invalid UTF-8 text test\", \"[general]\")\n{\n    std::string s = \"a <- '\";\n    s += static_cast<char>(0xe8); \n    parser parser(s.c_str());\n    bool ret = parser;\n    REQUIRE(ret == false);\n}", "target": 0}
{"code": "pci_emul_add_msixcap(struct pci_vdev *dev, int msgnum, int barnum)\n{\n\tuint32_t tab_size;\n\tstruct msixcap msixcap;\n\tassert(msgnum >= 1 && msgnum <= MAX_MSIX_TABLE_ENTRIES);\n\tassert(barnum >= 0 && barnum <= PCIR_MAX_BAR_0);\n\ttab_size = msgnum * MSIX_TABLE_ENTRY_SIZE;\n\ttab_size = roundup2(tab_size, 4096);\n\tdev->msix.table_bar = barnum;\n\tdev->msix.pba_bar   = barnum;\n\tdev->msix.table_offset = 0;\n\tdev->msix.table_count = msgnum;\n\tdev->msix.pba_offset = tab_size;\n\tdev->msix.pba_size = PBA_SIZE(msgnum);\n\tpci_msix_table_init(dev, msgnum);\n\tpci_populate_msixcap(&msixcap, msgnum, barnum, tab_size);\n\tpci_emul_alloc_bar(dev, barnum, PCIBAR_MEM32,\n\t\t\t\ttab_size + dev->msix.pba_size);\n\treturn (pci_emul_add_capability(dev, (u_char *)&msixcap,\n\t\t\t\t\tsizeof(msixcap)));\n}", "target": 1}
{"code": "void PrepareTFPass::runOnOperation() {\n  MLIRContext *ctx = &getContext();\n  RewritePatternSet patterns(ctx);\n  RewritePatternSet phase_2_patterns(ctx);\n  auto func = getOperation();\n  if (failed(ValidateOp(func))) {\n    func.emitError() << \"tfl-prepare-tf pass failed.\";\n    signalPassFailure();\n    return;\n  }\n  if (failed(ConvertTf2XlaOps(func, ctx))) {\n    signalPassFailure();\n    return;\n  }\n  patterns.add<ConvertTFDilatedConvOp<TF::Conv2DOp>, FusedBatchNormV3Pat,\n               ConvertTFDilatedConvOp<TF::DepthwiseConv2dNativeOp>>(ctx);\n  patterns.add<RemoveIdentity>(ctx);\n  TFL::populateWithGenerated(patterns);\n  TF::ReshapeOp::getCanonicalizationPatterns(patterns, ctx);\n  (void)applyPatternsAndFoldGreedily(func, std::move(patterns));\n  if (failed(ConvertFakeQuantOps(func, ctx, use_fake_quant_num_bits_))) {\n    signalPassFailure();\n    return;\n  }\n  TFL::populateWithGenerated(phase_2_patterns);\n  if (unfold_batch_matmul_) {\n    TF::PopulateUnrollTfBatchMatMul(ctx, phase_2_patterns);\n  }\n  phase_2_patterns\n      .add<TF::ConvertTFEinsumOp, ConvertTFBroadcastTo, ConvertTFStridedSlice,\n           ConvertRfftToRfft2d, RemoveIdentity>(ctx);\n  phase_2_patterns.add<ConvertTFConv2D, ConvertTFDepthwiseConv2dNative>(\n      ctx, allow_bf16_and_f16_type_legalization_);\n  TF::ReshapeOp::getCanonicalizationPatterns(phase_2_patterns, ctx);\n  (void)applyPatternsAndFoldGreedily(func, std::move(phase_2_patterns));\n}", "target": 0}
{"code": "archive_read_format_zip_cleanup(struct archive_read *a)\n{\n\tstruct zip *zip;\n\tstruct zip_entry *zip_entry, *next_zip_entry;\n\tzip = (struct zip *)(a->format->data);\n#ifdef HAVE_ZLIB_H\n\tif (zip->stream_valid)\n\t\tinflateEnd(&zip->stream);\n#endif\n#if HAVA_LZMA_H && HAVE_LIBLZMA\n    if (zip->zipx_lzma_valid) {\n\t\tlzma_end(&zip->zipx_lzma_stream);\n\t}\n#endif\n#ifdef HAVE_BZLIB_H\n\tif (zip->bzstream_valid) {\n\t\tBZ2_bzDecompressEnd(&zip->bzstream);\n\t}\n#endif\n\tfree(zip->uncompressed_buffer);\n\tif (zip->ppmd8_valid)\n\t\t__archive_ppmd8_functions.Ppmd8_Free(&zip->ppmd8);\n\tif (zip->zip_entries) {\n\t\tzip_entry = zip->zip_entries;\n\t\twhile (zip_entry != NULL) {\n\t\t\tnext_zip_entry = zip_entry->next;\n\t\t\tarchive_string_free(&zip_entry->rsrcname);\n\t\t\tfree(zip_entry);\n\t\t\tzip_entry = next_zip_entry;\n\t\t}\n\t}\n\tfree(zip->decrypted_buffer);\n\tif (zip->cctx_valid)\n\t\tarchive_decrypto_aes_ctr_release(&zip->cctx);\n\tif (zip->hctx_valid)\n\t\tarchive_hmac_sha1_cleanup(&zip->hctx);\n\tfree(zip->iv);\n\tfree(zip->erd);\n\tfree(zip->v_data);\n\tarchive_string_free(&zip->format_name);\n\tfree(zip);\n\t(a->format->data) = NULL;\n\treturn (ARCHIVE_OK);\n}", "target": 1}
{"code": "void ftoa_bounded_extra(JsVarFloat val,char *str, size_t len, int radix, int fractionalDigits) {\n  const JsVarFloat stopAtError = 0.0000001;\n  if (isnan(val)) strncpy(str,\"NaN\",len);\n  else if (!isfinite(val)) {\n    if (val<0) strncpy(str,\"-Infinity\",len);\n    else strncpy(str,\"Infinity\",len);\n  } else {\n    if (val<0) {\n      if (--len <= 0) { *str=0; return; } \n      *(str++) = '-';\n      val = -val;\n    }\n    if (((JsVarInt)(val+stopAtError)) == (1+(JsVarInt)val))\n      val = (JsVarFloat)(1+(JsVarInt)val);\n    JsVarFloat d = 1;\n    while (d*radix <= val) d*=radix;\n    while (d >= 1) {\n      int v = (int)(val / d);\n      val -= v*d;\n      if (--len <= 0) { *str=0; return; } \n      *(str++) = itoch(v);\n      d /= radix;\n    }\n#ifndef USE_NO_FLOATS\n    if (((fractionalDigits<0) && val>0) || fractionalDigits>0) {\n      bool hasPt = false;\n      val*=radix;\n      while (((fractionalDigits<0) && (fractionalDigits>-12) && (val > stopAtError)) || (fractionalDigits > 0)) {\n        int v = (int)(val+((fractionalDigits==1) ? 0.4 : 0.00000001) );\n        val = (val-v)*radix;\n\tif (v==radix) v=radix-1;\n        if (!hasPt) {\t\n\t  hasPt = true;\n          if (--len <= 0) { *str=0; return; } \n          *(str++)='.';\n        }\n        if (--len <= 0) { *str=0; return; } \n        *(str++)=itoch(v);\n        fractionalDigits--;\n      }\n    }\n#endif\n    *(str++)=0;\n  }\n}", "target": 1}
{"code": "static int llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t  int *uaddrlen, int peer)\n{\n\tstruct sockaddr_llc sllc;\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tint rc = 0;\n\tmemset(&sllc, 0, sizeof(sllc));\n\tlock_sock(sk);\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\t*uaddrlen = sizeof(sllc);\n\tmemset(uaddr, 0, *uaddrlen);\n\tif (peer) {\n\t\trc = -ENOTCONN;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\t\tif(llc->dev)\n\t\t\tsllc.sllc_arphrd = llc->dev->type;\n\t\tsllc.sllc_sap = llc->daddr.lsap;\n\t\tmemcpy(&sllc.sllc_mac, &llc->daddr.mac, IFHWADDRLEN);\n\t} else {\n\t\trc = -EINVAL;\n\t\tif (!llc->sap)\n\t\t\tgoto out;\n\t\tsllc.sllc_sap = llc->sap->laddr.lsap;\n\t\tif (llc->dev) {\n\t\t\tsllc.sllc_arphrd = llc->dev->type;\n\t\t\tmemcpy(&sllc.sllc_mac, llc->dev->dev_addr,\n\t\t\t       IFHWADDRLEN);\n\t\t}\n\t}\n\trc = 0;\n\tsllc.sllc_family = AF_LLC;\n\tmemcpy(uaddr, &sllc, sizeof(sllc));\nout:\n\trelease_sock(sk);\n\treturn rc;\n}", "target": 1}
{"code": "build_principal_va(krb5_context context, krb5_principal princ,\n                   unsigned int rlen, const char *realm, va_list ap)\n{\n    krb5_error_code retval = 0;\n    char *r = NULL;\n    krb5_data *data = NULL;\n    krb5_int32 count = 0;\n    krb5_int32 size = 2;  \n    char *component = NULL;\n    data = malloc(size * sizeof(krb5_data));\n    if (!data) { retval = ENOMEM; }\n    if (!retval) {\n        r = strdup(realm);\n        if (!r) { retval = ENOMEM; }\n    }\n    while (!retval && (component = va_arg(ap, char *))) {\n        if (count == size) {\n            krb5_data *new_data = NULL;\n            size *= 2;\n            new_data = realloc(data, size * sizeof(krb5_data));\n            if (new_data) {\n                data = new_data;\n            } else {\n                retval = ENOMEM;\n            }\n        }\n        if (!retval) {\n            data[count].length = strlen(component);\n            data[count].data = strdup(component);\n            if (!data[count].data) { retval = ENOMEM; }\n            count++;\n        }\n    }\n    if (!retval) {\n        princ->type = KRB5_NT_UNKNOWN;\n        princ->magic = KV5M_PRINCIPAL;\n        princ->realm = make_data(r, rlen);\n        princ->data = data;\n        princ->length = count;\n        r = NULL;    \n        data = NULL; \n    }\n    if (data) {\n        while (--count >= 0) {\n            free(data[count].data);\n        }\n        free(data);\n    }\n    free(r);\n    return retval;\n}", "target": 1}
{"code": "static const char *valid_domain_label(const char *label)\n{\n\tunsigned char ch;\n\tunsigned pos = 0;\n\tfor (;;) {\n\t\tch = *label;\n\t\tif ((ch|0x20) < 'a' || (ch|0x20) > 'z') {\n\t\t\tif (ch < '0' || ch > '9') {\n\t\t\t\tif (ch == '\\0' || ch == '.')\n\t\t\t\t\treturn label;\n\t\t\t\tif (ch != '-' && ch != '_')\n\t\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tlabel++;\n\t\tpos++;\n\t}\n}", "target": 0}
{"code": "l2tp_result_code_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\tND_PRINT((ndo, \"%u\", EXTRACT_16BITS(ptr))); ptr++;\t\n\tif (length > 2) {\t\t\t\t\n\t        ND_PRINT((ndo, \"/%u\", EXTRACT_16BITS(ptr))); ptr++;\n\t}\n\tif (length > 4) {\t\t\t\t\n\t\tND_PRINT((ndo, \" \"));\n\t\tprint_string(ndo, (const u_char *)ptr, length - 4);\n\t}\n}", "target": 1}
{"code": "rpmRC rpmReadPackageFile(rpmts ts, FD_t fd, const char * fn, Header * hdrp)\n{\n    char *msg = NULL;\n    Header h = NULL;\n    Header sigh = NULL;\n    hdrblob blob = NULL;\n    hdrblob sigblob = NULL;\n    rpmVSFlags vsflags = rpmtsVSFlags(ts) | RPMVSF_NEEDPAYLOAD;\n    rpmKeyring keyring = rpmtsGetKeyring(ts, 1);\n    struct rpmvs_s *vs = rpmvsCreate(0, vsflags, keyring);\n    struct pkgdata_s pkgdata = {\n\t.msgfunc = loghdrmsg,\n\t.fn = fn ? fn : Fdescr(fd),\n\t.msg = NULL,\n\t.rc = RPMRC_OK,\n    };\n    if (hdrp)\n\t*hdrp = NULL;\n    rpmRC rc = rpmpkgRead(vs, fd, &sigblob, &blob, &msg);\n    if (rc)\n\tgoto exit;\n    rc = RPMRC_FAIL;\n    if (!rpmvsVerify(vs, RPMSIG_VERIFIABLE_TYPE, handleHdrVS, &pkgdata)) {\n\tif (hdrp) {\n\t    if (hdrblobImport(sigblob, 0, &sigh, &msg))\n\t\tgoto exit;\n\t    if (hdrblobImport(blob, 0, &h, &msg))\n\t\tgoto exit;\n\t    headerMergeLegacySigs(h, sigh);\n\t    applyRetrofits(h);\n\t    *hdrp = headerLink(h);\n\t}\n\trc = RPMRC_OK;\n    }\n    if (rc == RPMRC_OK && pkgdata.rc)\n\trc = pkgdata.rc;\nexit:\n    if (rc && msg)\n\trpmlog(RPMLOG_ERR, \"%s: %s\\n\", Fdescr(fd), msg);\n    hdrblobFree(sigblob);\n    hdrblobFree(blob);\n    headerFree(sigh);\n    headerFree(h);\n    rpmKeyringFree(keyring);\n    rpmvsFree(vs);\n    free(msg);\n    return rc;\n}", "target": 1}
{"code": "int inet6_sk_rebuild_header(struct sock *sk)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct dst_entry *dst;\n\tdst = __sk_dst_check(sk, np->dst_cookie);\n\tif (!dst) {\n\t\tstruct inet_sock *inet = inet_sk(sk);\n\t\tstruct in6_addr *final_p, final;\n\t\tstruct flowi6 fl6;\n\t\tmemset(&fl6, 0, sizeof(fl6));\n\t\tfl6.flowi6_proto = sk->sk_protocol;\n\t\tfl6.daddr = sk->sk_v6_daddr;\n\t\tfl6.saddr = np->saddr;\n\t\tfl6.flowlabel = np->flow_label;\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\t\tfl6.flowi6_mark = sk->sk_mark;\n\t\tfl6.fl6_dport = inet->inet_dport;\n\t\tfl6.fl6_sport = inet->inet_sport;\n\t\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\n\t\tfinal_p = fl6_update_dst(&fl6, np->opt, &final);\n\t\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n\t\tif (IS_ERR(dst)) {\n\t\t\tsk->sk_route_caps = 0;\n\t\t\tsk->sk_err_soft = -PTR_ERR(dst);\n\t\t\treturn PTR_ERR(dst);\n\t\t}\n\t\t__ip6_dst_store(sk, dst, NULL, NULL);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "resp_get_length(netdissect_options *ndo, register const u_char *bp, int len, const u_char **endp)\n{\n    int result;\n    u_char c;\n    int saw_digit;\n    int neg;\n    int too_large;\n    if (len == 0)\n        goto trunc;\n    ND_TCHECK(*bp);\n    too_large = 0;\n    neg = 0;\n    if (*bp == '-') {\n        neg = 1;\n        bp++;\n        len--;\n    }\n    result = 0;\n    saw_digit = 0;\n    for (;;) {\n        if (len == 0)\n            goto trunc;\n        ND_TCHECK(*bp);\n        c = *bp;\n        if (!(c >= '0' && c <= '9')) {\n            if (!saw_digit)\n                goto invalid;\n            break;\n        }\n        c -= '0';\n        if (result > (INT_MAX / 10)) {\n            too_large = 1;\n        } else {\n            result *= 10;\n            if (result == INT_MAX && c > (INT_MAX % 10)) {\n                too_large = 1;\n            } else\n                result += c;\n        }\n        bp++;\n        len--;\n        saw_digit = 1;\n    }\n    if (!saw_digit)\n        goto invalid;\n    if (len == 0)\n        goto trunc;\n    ND_TCHECK(*bp);\n    if (*bp != '\\r')\n        goto invalid;\n    bp++;\n    len--;\n    if (len == 0)\n        goto trunc;\n    ND_TCHECK(*bp);\n    if (*bp != '\\n')\n        goto invalid;\n    bp++;\n    len--;\n    *endp = bp;\n    if (neg) {\n        if (too_large || result != 1)\n            return (-4);\n        result = -1;\n    }\n    return (too_large ? -3 : result);\ntrunc:\n    return (-2);\ninvalid:\n    return (-5);\n}", "target": 1}
{"code": "uint64_t HeaderMapImpl::byteSizeInternal() const {\n  uint64_t byte_size = 0;\n  for (const HeaderEntryImpl& header : headers_) {\n    byte_size += header.key().size();\n    byte_size += header.value().size();\n  }\n  return byte_size;\n}", "target": 0}
{"code": "WebMediaPlayer::Preload HTMLMediaElement::EffectivePreloadType() const {\n  if (Autoplay() && !autoplay_policy_->IsGestureNeededForPlayback())\n    return WebMediaPlayer::kPreloadAuto;\n  WebMediaPlayer::Preload preload = PreloadType();\n  if (ignore_preload_none_ && preload == WebMediaPlayer::kPreloadNone)\n    return WebMediaPlayer::kPreloadMetaData;\n  return preload;\n}", "target": 0}
{"code": "int yr_re_match(\n    RE* re,\n    const char* target)\n{\n  return yr_re_exec(\n      re->code,\n      (uint8_t*) target,\n      strlen(target),\n      0,\n      re->flags | RE_FLAGS_SCAN,\n      NULL,\n      NULL);\n}", "target": 0}
{"code": "void HTMLMediaElement::OnRemovedFromDocumentTimerFired(TimerBase*) {\n  if (InActiveDocument())\n    return;\n  PauseInternal();\n}", "target": 0}
{"code": "static void ResetPixelList(PixelList *pixel_list)\n{\n  int\n    level;\n  register SkipNode\n    *root;\n  register SkipList\n    *p;\n  p=(&pixel_list->skip_list);\n  root=p->nodes+65536UL;\n  p->level=0;\n  for (level=0; level < 9; level++)\n    root->next[level]=65536UL;\n  pixel_list->seed=pixel_list->signature++;\n}", "target": 0}
{"code": "*/\nPHP_FUNCTION(date_parse)\n{\n\tchar                           *date;\n\tint                             date_len;\n\tstruct timelib_error_container *error;\n\ttimelib_time                   *parsed_time;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &date, &date_len) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tparsed_time = timelib_strtotime(date, date_len, &error, DATE_TIMEZONEDB, php_date_parse_tzfile_wrapper);\n\tphp_date_do_return_parsed_time(INTERNAL_FUNCTION_PARAM_PASSTHRU, parsed_time, error);", "target": 0}
{"code": "static __u8 *nci_extract_rf_params_nfcb_passive_poll(struct nci_dev *ndev,\n\t\t\tstruct rf_tech_specific_params_nfcb_poll *nfcb_poll,\n\t\t\t\t\t\t     __u8 *data)\n{\n\tnfcb_poll->sensb_res_len = *data++;\n\tpr_debug(\"sensb_res_len %d\\n\", nfcb_poll->sensb_res_len);\n\tmemcpy(nfcb_poll->sensb_res, data, nfcb_poll->sensb_res_len);\n\tdata += nfcb_poll->sensb_res_len;\n\treturn data;\n}", "target": 1}
{"code": "cib_remote_auth(xmlNode *login)\n{\n    const char *user = NULL;\n    const char *pass = NULL;\n    const char *tmp = NULL;\n    crm_log_xml_info(login, \"Login: \");\n    if (login == NULL) {\n        return FALSE;\n    }\n    tmp = crm_element_name(login);\n    if (safe_str_neq(tmp, \"cib_command\")) {\n        crm_err(\"Wrong tag: %s\", tmp);\n        return FALSE;\n    }\n    tmp = crm_element_value(login, \"op\");\n    if (safe_str_neq(tmp, \"authenticate\")) {\n        crm_err(\"Wrong operation: %s\", tmp);\n        return FALSE;\n    }\n    user = crm_element_value(login, \"user\");\n    pass = crm_element_value(login, \"password\");\n    if (!user || !pass) {\n        crm_err(\"missing auth credentials\");\n        return FALSE;\n    }\n    if (check_group_membership(user, CRM_DAEMON_GROUP) == FALSE) {\n        crm_err(\"User is not a member of the required group\");\n        return FALSE;\n    } else if (authenticate_user(user, pass) == FALSE) {\n        crm_err(\"PAM auth failed\");\n        return FALSE;\n    }\n    return TRUE;\n}", "target": 0}
{"code": "static int adpt_i2o_activate_hba(adpt_hba* pHba)\n{\n\tint rcode;\n\tif(pHba->initialized ) {\n\t\tif (adpt_i2o_status_get(pHba) < 0) {\n\t\t\tif((rcode = adpt_i2o_reset_hba(pHba)) != 0){\n\t\t\t\tprintk(KERN_WARNING\"%s: Could NOT reset.\\n\", pHba->name);\n\t\t\t\treturn rcode;\n\t\t\t}\n\t\t\tif (adpt_i2o_status_get(pHba) < 0) {\n\t\t\t\tprintk(KERN_INFO \"HBA not responding.\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif(pHba->status_block->iop_state == ADAPTER_STATE_FAULTED) {\n\t\t\tprintk(KERN_CRIT \"%s: hardware fault\\n\", pHba->name);\n\t\t\treturn -1;\n\t\t}\n\t\tif (pHba->status_block->iop_state == ADAPTER_STATE_READY ||\n\t\t    pHba->status_block->iop_state == ADAPTER_STATE_OPERATIONAL ||\n\t\t    pHba->status_block->iop_state == ADAPTER_STATE_HOLD ||\n\t\t    pHba->status_block->iop_state == ADAPTER_STATE_FAILED) {\n\t\t\tadpt_i2o_reset_hba(pHba);\t\t\t\n\t\t\tif (adpt_i2o_status_get(pHba) < 0 || pHba->status_block->iop_state != ADAPTER_STATE_RESET) {\n\t\t\t\tprintk(KERN_ERR \"%s: Failed to initialize.\\n\", pHba->name);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif((rcode = adpt_i2o_reset_hba(pHba)) != 0){\n\t\t\tprintk(KERN_WARNING\"%s: Could NOT reset.\\n\", pHba->name);\n\t\t\treturn rcode;\n\t\t}\n\t}\n\tif (adpt_i2o_init_outbound_q(pHba) < 0) {\n\t\treturn -1;\n\t}\n\tif (adpt_i2o_hrt_get(pHba) < 0) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "http_error_t::make_body (int n, const str &si, const str &aux)\n{\n  strbuf b;\n  str ldesc;\n  const str sdesc = http_status.get_desc (n, &ldesc);\n  b << \"<html>\\n\"\n    << \" <head>\\n\"\n    << \"  <title>\" << n << \" \" << sdesc << \"</title>\\n\"\n    << \" </head>\\n\"\n    << \" <body>\\n\"\n    << \" <h1>Error \" << n << \" \" << sdesc << \"</h1><br><br>\\n\"\n    ;\n  if (n == HTTP_NOT_FOUND && aux) {\n    b << \"The file <tt>\" << aux \n      << \"</tt> was not found on this server.<br><br>\\n\\n\";\n  }\n  b << \"  <hr>\\n\"\n    << \"  <i>\" << si << \"</i>\\n\"\n    << \" <br>\\n\"\n    << \" </body>\\n\"\n    << \"</html>\\n\"\n    ;\n  return b;\n}", "target": 1}
{"code": "int wait_for_key_construction(struct key *key, bool intr)\n{\n\tint ret;\n\tret = wait_on_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT,\n\t\t\t  intr ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE);\n\tif (ret)\n\t\treturn -ERESTARTSYS;\n\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags)) {\n\t\tsmp_rmb();\n\t\treturn key->reject_error;\n\t}\n\treturn key_validate(key);\n}", "target": 1}
{"code": "    bool fetch(const string & url, const string & expectedETag = \"\")\n    {\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        data.clear();\n        if (requestHeaders) {\n            curl_slist_free_all(requestHeaders);\n            requestHeaders = 0;\n        }\n        if (!expectedETag.empty()) {\n            this->expectedETag = expectedETag;\n            requestHeaders = curl_slist_append(requestHeaders, (\"If-None-Match: \" + expectedETag).c_str());\n        }\n        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, requestHeaders);\n        if (showProgress) {\n            std::cerr << (format(\"downloading ‘%1%’... \") % url);\n            std::cerr.flush();\n            startTime = getTime();\n        }\n        CURLcode res = curl_easy_perform(curl);\n        if (showProgress)\n            std::cerr << \"\\n\";\n        checkInterrupt();\n        if (res == CURLE_WRITE_ERROR && etag == expectedETag) return false;\n        if (res != CURLE_OK)\n            throw DownloadError(format(\"unable to download ‘%1%’: %2% (%3%)\")\n                % url % curl_easy_strerror(res) % res);\n        long httpStatus = 0;\n        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &httpStatus);\n        if (httpStatus == 304) return false;\n        return true;\n    }", "target": 1}
{"code": "static int fscrypt_d_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct dentry *dir;\n\tstruct fscrypt_info *ci;\n\tint dir_has_key, cached_with_key;\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\tdir = dget_parent(dentry);\n\tif (!d_inode(dir)->i_sb->s_cop->is_encrypted(d_inode(dir))) {\n\t\tdput(dir);\n\t\treturn 0;\n\t}\n\tci = d_inode(dir)->i_crypt_info;\n\tif (ci && ci->ci_keyring_key &&\n\t    (ci->ci_keyring_key->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t\t\t  (1 << KEY_FLAG_REVOKED) |\n\t\t\t\t\t  (1 << KEY_FLAG_DEAD))))\n\t\tci = NULL;\n\tspin_lock(&dentry->d_lock);\n\tcached_with_key = dentry->d_flags & DCACHE_ENCRYPTED_WITH_KEY;\n\tspin_unlock(&dentry->d_lock);\n\tdir_has_key = (ci != NULL);\n\tdput(dir);\n\tif ((!cached_with_key && d_is_negative(dentry)) ||\n\t\t\t(!cached_with_key && dir_has_key) ||\n\t\t\t(cached_with_key && !dir_has_key))\n\t\treturn 0;\n\treturn 1;\n}", "target": 1}
{"code": "static ssize_t rpmsg_eptdev_write_iter(struct kiocb *iocb,\n\t\t\t\t       struct iov_iter *from)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct rpmsg_eptdev *eptdev = filp->private_data;\n\tsize_t len = iov_iter_count(from);\n\tvoid *kbuf;\n\tint ret;\n\tkbuf = kzalloc(len, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\tif (!copy_from_iter_full(kbuf, len, from))\n\t\treturn -EFAULT;\n\tif (mutex_lock_interruptible(&eptdev->ept_lock)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto free_kbuf;\n\t}\n\tif (!eptdev->ept) {\n\t\tret = -EPIPE;\n\t\tgoto unlock_eptdev;\n\t}\n\tif (filp->f_flags & O_NONBLOCK)\n\t\tret = rpmsg_trysend(eptdev->ept, kbuf, len);\n\telse\n\t\tret = rpmsg_send(eptdev->ept, kbuf, len);\nunlock_eptdev:\n\tmutex_unlock(&eptdev->ept_lock);\nfree_kbuf:\n\tkfree(kbuf);\n\treturn ret < 0 ? ret : len;\n}", "target": 1}
{"code": "static inline u64 get_canonical(u64 la)\n{\n\treturn ((int64_t)la << 16) >> 16;\n}", "target": 0}
{"code": "dump_threads(void)\n{\n\tFILE *fp;\n\tchar time_buf[26];\n\telement e;\n\tvrrp_t *vrrp;\n\tchar *file_name;\n\tfile_name = make_file_name(\"/tmp/thread_dump.dat\",\n\t\t\t\t\t\"vrrp\",\n#if HAVE_DECL_CLONE_NEWNET\n\t\t\t\t\tglobal_data->network_namespace,\n#else\n\t\t\t\t\tNULL,\n#endif\n\t\t\t\t\tglobal_data->instance_name);\n\tfp = fopen(file_name, \"a\");\n\tFREE(file_name);\n\tset_time_now();\n\tctime_r(&time_now.tv_sec, time_buf);\n\tfprintf(fp, \"\\n%.19s.%6.6ld: Thread dump\\n\", time_buf, time_now.tv_usec);\n\tdump_thread_data(master, fp);\n\tfprintf(fp, \"alloc = %lu\\n\", master->alloc);\n\tfprintf(fp, \"\\n\");\n\tLIST_FOREACH(vrrp_data->vrrp, vrrp, e) {\n\t\tctime_r(&vrrp->sands.tv_sec, time_buf);\n\t\tfprintf(fp, \"VRRP instance %s, sands %.19s.%6.6lu, status %s\\n\", vrrp->iname, time_buf, vrrp->sands.tv_usec,\n\t\t\t\tvrrp->state == VRRP_STATE_INIT ? \"INIT\" :\n\t\t\t\tvrrp->state == VRRP_STATE_BACK ? \"BACKUP\" :\n\t\t\t\tvrrp->state == VRRP_STATE_MAST ? \"MASTER\" :\n\t\t\t\tvrrp->state == VRRP_STATE_FAULT ? \"FAULT\" :\n\t\t\t\tvrrp->state == VRRP_STATE_STOP ? \"STOP\" :\n\t\t\t\tvrrp->state == VRRP_DISPATCHER ? \"DISPATCHER\" : \"unknown\");\n\t}\n\tfclose(fp);\n}", "target": 1}
{"code": "TfLiteStatus GetOutputSafe(const TfLiteContext* context, const TfLiteNode* node,\n                           int index, TfLiteTensor** tensor) {\n  int tensor_index;\n  TF_LITE_ENSURE_OK(\n      context, ValidateTensorIndexingSafe(context, index, node->outputs->size,\n                                          node->outputs->data, &tensor_index));\n  *tensor = GetTensorAtIndex(context, tensor_index);\n  return kTfLiteOk;\n}", "target": 0}
{"code": "convert_to_decimal (mpn_t a, size_t extra_zeroes)\n{\n  mp_limb_t *a_ptr = a.limbs;\n  size_t a_len = a.nlimbs;\n  size_t c_len = 9 * ((size_t)(a_len * (GMP_LIMB_BITS * 0.03345f)) + 1);\n  char *c_ptr = (char *) malloc (xsum (c_len, extra_zeroes));\n  if (c_ptr != NULL)\n    {\n      char *d_ptr = c_ptr;\n      for (; extra_zeroes > 0; extra_zeroes--)\n        *d_ptr++ = '0';\n      while (a_len > 0)\n        {\n          mp_limb_t remainder = 0;\n          mp_limb_t *ptr = a_ptr + a_len;\n          size_t count;\n          for (count = a_len; count > 0; count--)\n            {\n              mp_twolimb_t num =\n                ((mp_twolimb_t) remainder << GMP_LIMB_BITS) | *--ptr;\n              *ptr = num / 1000000000;\n              remainder = num % 1000000000;\n            }\n          for (count = 9; count > 0; count--)\n            {\n              *d_ptr++ = '0' + (remainder % 10);\n              remainder = remainder / 10;\n            }\n          if (a_ptr[a_len - 1] == 0)\n            a_len--;\n        }\n      while (d_ptr > c_ptr && d_ptr[-1] == '0')\n        d_ptr--;\n      if (d_ptr == c_ptr)\n        *d_ptr++ = '0';\n      *d_ptr = '\\0';\n    }\n  return c_ptr;\n}", "target": 1}
{"code": "void handle_get_plugin_schema(nng_aio *aio)\n{\n    size_t      len                        = 0;\n    char *      schema_path                = NULL;\n    char        param[NEU_PLUGIN_NAME_LEN] = { 0 };\n    const char *schema_name                = param;\n    NEU_VALIDATE_JWT(aio);\n    int rv = neu_http_get_param_str(aio, \"schema_name\", param, sizeof(param));\n    if (-2 == rv) {\n        rv = neu_http_get_param_str(aio, \"plugin_name\", param, sizeof(param));\n        schema_name = plugin_name_to_schema_name(param);\n    }\n    if (rv < 0) {\n        neu_http_bad_request(aio, \"{\\\"error\\\": 1002}\");\n        return;\n    }\n    if (0 > neu_asprintf(&schema_path, \"%s/schema/%s.json\", g_plugin_dir,\n                         schema_name)) {\n        NEU_JSON_RESPONSE_ERROR(NEU_ERR_EINTERNAL, {\n            neu_http_response(aio, error_code.error, result_error);\n        });\n        return;\n    }\n    char *buf = NULL;\n    buf = file_string_read(&len, schema_path);\n    if (NULL == buf) {\n        free(schema_path);\n        if (0 > neu_asprintf(&schema_path, \"%s/custom/schema/%s.json\",\n                             g_plugin_dir, schema_name)) {\n            NEU_JSON_RESPONSE_ERROR(NEU_ERR_EINTERNAL, {\n                neu_http_response(aio, error_code.error, result_error);\n            });\n            return;\n        }\n        buf = file_string_read(&len, schema_path);\n    }\n    if (NULL == buf) {\n        free(schema_path);\n        if (0 > neu_asprintf(&schema_path, \"%s/system/schema/%s.json\",\n                             g_plugin_dir, schema_name)) {\n            NEU_JSON_RESPONSE_ERROR(NEU_ERR_EINTERNAL, {\n                neu_http_response(aio, error_code.error, result_error);\n            });\n            return;\n        }\n        buf = file_string_read(&len, schema_path);\n    }\n    if (NULL == buf) {\n        nlog_info(\"open %s error: %d\", schema_path, errno);\n        neu_http_not_found(aio, \"{\\\"status\\\": \\\"error\\\"}\");\n        free(schema_path);\n        return;\n    }\n    neu_http_ok(aio, buf);\n    free(buf);\n    free(schema_path);\n}", "target": 1}
{"code": "frag6_print(netdissect_options *ndo, register const u_char *bp, register const u_char *bp2)\n{\n\tregister const struct ip6_frag *dp;\n\tregister const struct ip6_hdr *ip6;\n\tdp = (const struct ip6_frag *)bp;\n\tip6 = (const struct ip6_hdr *)bp2;\n\tND_TCHECK(dp->ip6f_offlg);\n\tif (ndo->ndo_vflag) {\n\t\tND_PRINT((ndo, \"frag (0x%08x:%d|%ld)\",\n\t\t       EXTRACT_32BITS(&dp->ip6f_ident),\n\t\t       EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK,\n\t\t       sizeof(struct ip6_hdr) + EXTRACT_16BITS(&ip6->ip6_plen) -\n\t\t\t       (long)(bp - bp2) - sizeof(struct ip6_frag)));\n\t} else {\n\t\tND_PRINT((ndo, \"frag (%d|%ld)\",\n\t\t       EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK,\n\t\t       sizeof(struct ip6_hdr) + EXTRACT_16BITS(&ip6->ip6_plen) -\n\t\t\t       (long)(bp - bp2) - sizeof(struct ip6_frag)));\n\t}\n\tif ((EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK) != 0)\n\t\treturn -1;\n\telse\n\t{\n\t\tND_PRINT((ndo, \" \"));\n\t\treturn sizeof(struct ip6_frag);\n\t}\ntrunc:\n\tND_PRINT((ndo, \"[|frag]\"));\n\treturn -1;\n}", "target": 1}
{"code": "static void xar_get_checksum_values(xmlTextReaderPtr reader, unsigned char ** cksum, int * hash)\n{\n    xmlChar * style = xmlTextReaderGetAttribute(reader, (const xmlChar *)\"style\");\n    const xmlChar * xmlval;\n    *hash = XAR_CKSUM_NONE;\n    if (style == NULL) {\n        cli_dbgmsg(\"cli_scaxar: xmlTextReaderGetAttribute no style attribute \"\n                   \"for checksum element\\n\");\n    } else {\n        cli_dbgmsg(\"cli_scanxar: checksum algorithm is %s.\\n\", style);        \n        if (0 == xmlStrcasecmp(style, (const xmlChar *)\"sha1\")) {\n            *hash = XAR_CKSUM_SHA1;\n        } else if (0 == xmlStrcasecmp(style, (const xmlChar *)\"md5\")) {\n            *hash = XAR_CKSUM_MD5;\n        } else {\n            cli_dbgmsg(\"cli_scanxar: checksum algorithm %s is unsupported.\\n\", style);\n            *hash = XAR_CKSUM_OTHER;\n        }\n    }\n    if (style != NULL)\n        xmlFree(style);\n    if (xmlTextReaderRead(reader) == 1 && xmlTextReaderNodeType(reader) == XML_READER_TYPE_TEXT) {\n        xmlval = xmlTextReaderConstValue(reader);\n        if (xmlval) {\n            *cksum = xmlStrdup(xmlval); \n            cli_dbgmsg(\"cli_scanxar: checksum value is %s.\\n\", *cksum);\n        } else {\n            *cksum = NULL;\n            cli_dbgmsg(\"cli_scanxar: xmlTextReaderConstValue() returns NULL for checksum value.\\n\");           \n        }\n    }\n    else\n        cli_dbgmsg(\"cli_scanxar: No text for XML checksum element.\\n\");\n}", "target": 1}
{"code": "auth_line_is_begin (guint8 *line)\n{\n  guint8 next_char;\n  if (!g_str_has_prefix ((char *)line, AUTH_BEGIN))\n    return FALSE;\n  next_char = line[strlen (AUTH_BEGIN)];\n  return (next_char == 0 ||\n          next_char == ' ' ||\n          next_char == '\\t');\n}", "target": 0}
{"code": "flushbuffer(PrintfTarget *target)\n{\n\tsize_t\t\tnc = target->bufptr - target->bufstart;\n\tif (nc > 0)\n\t\ttarget->nchars += fwrite(target->bufstart, 1, nc, target->stream);\n\ttarget->bufptr = target->bufstart;\n}", "target": 0}
{"code": "NOEXPORT int init_section(int eof, SERVICE_OPTIONS **section_ptr) {\n    char *errstr;\n#ifndef USE_WIN32\n    (*section_ptr)->option.log_stderr=new_global_options.option.log_stderr;\n#endif \n    if(*section_ptr==&new_service_options) {\n        errstr=parse_global_option(CMD_INITIALIZE, NULL, NULL);\n        if(errstr) {\n            s_log(LOG_ERR, \"Global options: %s\", errstr);\n            return 1;\n        }\n    }\n    if(*section_ptr!=&new_service_options || eof) {\n        if(*section_ptr==&new_service_options)\n            s_log(LOG_INFO, \"Initializing inetd mode configuration\");\n        else\n            s_log(LOG_INFO, \"Initializing service [%s]\",\n                (*section_ptr)->servname);\n        errstr=parse_service_option(CMD_INITIALIZE, section_ptr, NULL, NULL);\n        if(errstr) {\n            if(*section_ptr==&new_service_options)\n                s_log(LOG_ERR, \"Inetd mode: %s\", errstr);\n            else\n                s_log(LOG_ERR, \"Service [%s]: %s\",\n                    (*section_ptr)->servname, errstr);\n            return 1;\n        }\n    }\n    return 0;\n}", "target": 1}
{"code": "MagickPrivate MagickBooleanType SyncImagePixelCache(Image *image,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n  assert(image != (Image *) NULL);\n  assert(exception != (ExceptionInfo *) NULL);\n  cache_info=(CacheInfo *) GetImagePixelCache(image,MagickTrue,exception);\n  return(cache_info == (CacheInfo *) NULL ? MagickFalse : MagickTrue);\n}", "target": 0}
{"code": "void WifiPacket::handle_prism(const u_char *pc, size_t len)\n{\n    prism2_pkthdr hdr;\n    hdr.host_time \t= EXTRACT_LE_32BITS(pc+32);\n    hdr.mac_time \t= EXTRACT_LE_32BITS(pc+44);\n    hdr.channel \t= EXTRACT_LE_32BITS(pc+56);\n    hdr.rssi \t\t= EXTRACT_LE_32BITS(pc+68);\n    hdr.sq \t\t= EXTRACT_LE_32BITS(pc+80);\n    hdr.signal  \t= EXTRACT_LE_32BITS(pc+92);\n    hdr.noise   \t= EXTRACT_LE_32BITS(pc+104);\n    hdr.rate\t\t= EXTRACT_LE_32BITS(pc+116)/2;\n    hdr.istx\t\t= EXTRACT_LE_32BITS(pc+128);\n    cbs->HandlePrism( *this, &hdr, pc + 144, len - 144);\n    handle_80211(pc+144,len-144);\n}", "target": 1}
{"code": "void encode(ArgumentEncoder* encoder, CFArrayRef array)\n{\n    CFIndex size = CFArrayGetCount(array);\n    Vector<CFTypeRef, 32> values(size);\n    CFArrayGetValues(array, CFRangeMake(0, size), values.data());\n    encoder->encodeUInt64(size);\n    for (CFIndex i = 0; i < size; ++i) {\n        ASSERT(values[i]);\n        encode(encoder, values[i]);\n    }\n}", "target": 0}
{"code": "bool WindowsServiceControl::install( const QString& filePath, const QString& displayName  )\n{\n\tm_serviceHandle = CreateService(\n\t\t\t\tm_serviceManager,\t\t\n\t\t\t\tWindowsCoreFunctions::toConstWCharArray( m_name ),\t\n\t\t\t\tWindowsCoreFunctions::toConstWCharArray( displayName ),\n\t\t\t\tSERVICE_ALL_ACCESS,\t\n\t\t\t\tSERVICE_WIN32_OWN_PROCESS,\n\t\t\t\tSERVICE_AUTO_START,\t\n\t\t\t\tSERVICE_ERROR_NORMAL,\t\n\t\t\t\tWindowsCoreFunctions::toConstWCharArray( filePath ),\t\t\n\t\t\t\tnullptr,\t\t\t\n\t\t\t\tnullptr,\t\t\t\n\t\t\t\tL\"Tcpip\\0RpcSs\\0\\0\",\t\t\n\t\t\t\tnullptr,\t\t\t\n\t\t\t\tnullptr );\t\t\t\n\tif( m_serviceHandle == nullptr )\n\t{\n\t\tconst auto error = GetLastError();\n\t\tif( error == ERROR_SERVICE_EXISTS )\n\t\t{\n\t\t\tvCritical() << qUtf8Printable( tr( \"The service \\\"%1\\\" is already installed.\" ).arg( m_name ) );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvCritical() << qUtf8Printable( tr( \"The service \\\"%1\\\" could not be installed.\" ).arg( m_name ) );\n\t\t}\n\t\treturn false;\n\t}\n\tSC_ACTION serviceActions;\n\tserviceActions.Delay = 10000;\n\tserviceActions.Type = SC_ACTION_RESTART;\n\tSERVICE_FAILURE_ACTIONS serviceFailureActions;\n\tserviceFailureActions.dwResetPeriod = 0;\n\tserviceFailureActions.lpRebootMsg = nullptr;\n\tserviceFailureActions.lpCommand = nullptr;\n\tserviceFailureActions.lpsaActions = &serviceActions;\n\tserviceFailureActions.cActions = 1;\n\tChangeServiceConfig2( m_serviceHandle, SERVICE_CONFIG_FAILURE_ACTIONS, &serviceFailureActions );\n\tvInfo() << qUtf8Printable( tr( \"The service \\\"%1\\\" has been installed successfully.\" ).arg( m_name ) );\n\treturn true;\n}", "target": 1}
{"code": "remove_this_reserved_job(conn c, job j)\n{\n    j = job_remove(j);\n    if (j) {\n        global_stat.reserved_ct--;\n        j->tube->stat.reserved_ct--;\n        j->reserver = NULL;\n    }\n    c->soonest_job = NULL;\n    if (!job_list_any_p(&c->reserved_jobs)) conn_remove(c);\n    return j;\n}", "target": 0}
{"code": "static int mptctl_do_reset(unsigned long arg)\n{\n\tstruct mpt_ioctl_diag_reset __user *urinfo = (void __user *) arg;\n\tstruct mpt_ioctl_diag_reset krinfo;\n\tMPT_ADAPTER\t\t*iocp;\n\tif (copy_from_user(&krinfo, urinfo, sizeof(struct mpt_ioctl_diag_reset))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_do_reset - \"\n\t\t\t\t\"Unable to copy mpt_ioctl_diag_reset struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, urinfo);\n\t\treturn -EFAULT;\n\t}\n\tif (mpt_verify_adapter(krinfo.hdr.iocnum, &iocp) < 0) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s@%d::mptctl_do_reset - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, krinfo.hdr.iocnum);\n\t\treturn -ENODEV; \n\t}\n\tdctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT \"mptctl_do_reset called.\\n\",\n\t    iocp->name));\n\tif (mpt_HardResetHandler(iocp, CAN_SLEEP) != 0) {\n\t\tprintk (MYIOC_s_ERR_FMT \"%s@%d::mptctl_do_reset - reset failed.\\n\",\n\t\t\tiocp->name, __FILE__, __LINE__);\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int build_open_gop_key_points(AVStream *st)\n{\n    int k;\n    int sample_id = 0;\n    uint32_t cra_index;\n    MOVStreamContext *sc = st->priv_data;\n    if (st->codecpar->codec_id != AV_CODEC_ID_HEVC || !sc->sync_group_count)\n        return 0;\n    sc->sample_offsets_count = 0;\n    for (uint32_t i = 0; i < sc->ctts_count; i++)\n        sc->sample_offsets_count += sc->ctts_data[i].count;\n    av_freep(&sc->sample_offsets);\n    sc->sample_offsets = av_calloc(sc->sample_offsets_count, sizeof(*sc->sample_offsets));\n    if (!sc->sample_offsets)\n        return AVERROR(ENOMEM);\n    k = 0;\n    for (uint32_t i = 0; i < sc->ctts_count; i++)\n        for (int j = 0; j < sc->ctts_data[i].count; j++)\n             sc->sample_offsets[k++] = sc->ctts_data[i].duration;\n    cra_index = get_sgpd_sync_index(sc, HEVC_NAL_CRA_NUT); \n    if (!cra_index)\n        return 0;\n    sc->open_key_samples_count = 0;\n    for (uint32_t i = 0; i < sc->sync_group_count; i++)\n        if (sc->sync_group[i].index == cra_index)\n            sc->open_key_samples_count += sc->sync_group[i].count;\n    av_freep(&sc->open_key_samples);\n    sc->open_key_samples = av_calloc(sc->open_key_samples_count, sizeof(*sc->open_key_samples));\n    if (!sc->open_key_samples)\n        return AVERROR(ENOMEM);\n    k = 0;\n    for (uint32_t i = 0; i < sc->sync_group_count; i++) {\n        const MOVSbgp *sg = &sc->sync_group[i];\n        if (sg->index == cra_index)\n            for (uint32_t j = 0; j < sg->count; j++)\n                sc->open_key_samples[k++] = sample_id;\n        sample_id += sg->count;\n    }\n    sc->min_sample_duration = UINT_MAX;\n    for (uint32_t i = 0; i < sc->stts_count; i++)\n        sc->min_sample_duration = FFMIN(sc->min_sample_duration, sc->stts_data[i].duration);\n    return 0;\n}", "target": 1}
{"code": "nvkm_vmm_put_locked(struct nvkm_vmm *vmm, struct nvkm_vma *vma)\n{\n\tconst struct nvkm_vmm_page *page = vmm->func->page;\n\tstruct nvkm_vma *next = vma;\n\tBUG_ON(vma->part);\n\tif (vma->mapref || !vma->sparse) {\n\t\tdo {\n\t\t\tconst bool map = next->memory != NULL;\n\t\t\tconst u8  refd = next->refd;\n\t\t\tconst u64 addr = next->addr;\n\t\t\tu64 size = next->size;\n\t\t\twhile ((next = node(next, next)) && next->part &&\n\t\t\t       (next->memory != NULL) == map &&\n\t\t\t       (next->refd == refd))\n\t\t\t\tsize += next->size;\n\t\t\tif (map) {\n\t\t\t\tnvkm_vmm_ptes_unmap_put(vmm, &page[refd], addr,\n\t\t\t\t\t\t\tsize, vma->sparse);\n\t\t\t} else\n\t\t\tif (refd != NVKM_VMA_PAGE_NONE) {\n\t\t\t\tnvkm_vmm_ptes_put(vmm, &page[refd], addr, size);\n\t\t\t}\n\t\t} while (next && next->part);\n\t}\n\tnext = vma;\n\tdo {\n\t\tif (next->memory)\n\t\t\tnvkm_vmm_unmap_region(vmm, next);\n\t} while ((next = node(vma, next)) && next->part);\n\tif (vma->sparse && !vma->mapref) {\n\t\tnvkm_vmm_ptes_sparse_put(vmm, &page[vma->refd], vma->addr, vma->size);\n\t} else\n\tif (vma->sparse) {\n\t\tnvkm_vmm_ptes_sparse(vmm, vma->addr, vma->size, false);\n\t}\n\trb_erase(&vma->tree, &vmm->root);\n\tvma->page = NVKM_VMA_PAGE_NONE;\n\tvma->refd = NVKM_VMA_PAGE_NONE;\n\tvma->used = false;\n\tvma->user = false;\n\tnvkm_vmm_put_region(vmm, vma);\n}", "target": 1}
{"code": "test_all_FFs(void **state)\n{\n    (void) state;\n    const char *e = Tss2_RC_Decode(0xFFFFFFFF);\n    assert_string_equal(e, \"255:0xFFFFFF\");\n}", "target": 0}
{"code": "newkeys_to_blob(struct sshbuf *m, struct ssh *ssh, int mode)\n{\n\tstruct sshbuf *b;\n\tstruct sshcipher_ctx *cc;\n\tstruct sshcomp *comp;\n\tstruct sshenc *enc;\n\tstruct sshmac *mac;\n\tstruct newkeys *newkey;\n\tint r;\n\tif ((newkey = ssh->state->newkeys[mode]) == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tenc = &newkey->enc;\n\tmac = &newkey->mac;\n\tcomp = &newkey->comp;\n\tcc = (mode == MODE_OUT) ? ssh->state->send_context :\n\t    ssh->state->receive_context;\n\tif ((r = cipher_get_keyiv(cc, enc->iv, enc->iv_len)) != 0)\n\t\treturn r;\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_put_cstring(b, enc->name)) != 0 ||\n\t    (r = sshbuf_put(b, &enc->cipher, sizeof(enc->cipher))) != 0 ||\n\t    (r = sshbuf_put_u32(b, enc->enabled)) != 0 ||\n\t    (r = sshbuf_put_u32(b, enc->block_size)) != 0 ||\n\t    (r = sshbuf_put_string(b, enc->key, enc->key_len)) != 0 ||\n\t    (r = sshbuf_put_string(b, enc->iv, enc->iv_len)) != 0)\n\t\tgoto out;\n\tif (cipher_authlen(enc->cipher) == 0) {\n\t\tif ((r = sshbuf_put_cstring(b, mac->name)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, mac->enabled)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, mac->key, mac->key_len)) != 0)\n\t\t\tgoto out;\n\t}\n\tif ((r = sshbuf_put_u32(b, comp->type)) != 0 ||\n\t    (r = sshbuf_put_u32(b, comp->enabled)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, comp->name)) != 0)\n\t\tgoto out;\n\tr = sshbuf_put_stringb(m, b);\n out:\n\tsshbuf_free(b);\n\treturn r;\n}", "target": 1}
{"code": "static void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t      struct userfaultfd_wait_queue *ewq)\n{\n\tstruct userfaultfd_ctx *release_new_ctx;\n\tif (WARN_ON_ONCE(current->flags & PF_EXITING))\n\t\tgoto out;\n\tewq->ctx = ctx;\n\tinit_waitqueue_entry(&ewq->wq, current);\n\trelease_new_ctx = NULL;\n\tspin_lock(&ctx->event_wqh.lock);\n\t__add_wait_queue(&ctx->event_wqh, &ewq->wq);\n\tfor (;;) {\n\t\tset_current_state(TASK_KILLABLE);\n\t\tif (ewq->msg.event == 0)\n\t\t\tbreak;\n\t\tif (READ_ONCE(ctx->released) ||\n\t\t    fatal_signal_pending(current)) {\n\t\t\t__remove_wait_queue(&ctx->event_wqh, &ewq->wq);\n\t\t\tif (ewq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tstruct userfaultfd_ctx *new;\n\t\t\t\tnew = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tewq->msg.arg.reserved.reserved1;\n\t\t\t\trelease_new_ctx = new;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\t\twake_up_poll(&ctx->fd_wqh, EPOLLIN);\n\t\tschedule();\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->event_wqh.lock);\n\tif (release_new_ctx) {\n\t\tstruct vm_area_struct *vma;\n\t\tstruct mm_struct *mm = release_new_ctx->mm;\n\t\tdown_write(&mm->mmap_sem);\n\t\tVM_WARN_ON(!mmget_still_valid(mm));\n\t\tfor (vma = mm->mmap; vma; vma = vma->vm_next)\n\t\t\tif (vma->vm_userfaultfd_ctx.ctx == release_new_ctx) {\n\t\t\t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n\t\t\t\tvma->vm_flags &= ~(VM_UFFD_WP | VM_UFFD_MISSING);\n\t\t\t}\n\t\tup_write(&mm->mmap_sem);\n\t\tuserfaultfd_ctx_put(release_new_ctx);\n\t}\nout:\n\tWRITE_ONCE(ctx->mmap_changing, false);\n\tuserfaultfd_ctx_put(ctx);\n}", "target": 0}
{"code": "no_peephole(codegen_scope *s)\n{\n  return no_optimize(s) || s->lastlabel == s->pc || s->pc == 0 || s->pc == s->lastpc;\n}", "target": 0}
{"code": "void AcceptRoutingHandler<Pipeline, R>::onRoutingData(\n    uint64_t connId,\n    typename RoutingDataHandler<R>::RoutingData& routingData) {\n  auto routingPipelineIter = routingPipelines_.find(connId);\n  if (routingPipelineIter == routingPipelines_.end()) {\n    VLOG(2) << \"Connection has already been closed, \"\n               \"or routed to a worker thread.\";\n    return;\n  }\n  auto routingPipeline = std::move(routingPipelineIter->second);\n  routingPipelines_.erase(routingPipelineIter);\n  auto socket = std::dynamic_pointer_cast<folly::AsyncSocket>(\n      routingPipeline->getTransport());\n  routingPipeline->transportInactive();\n  socket->detachEventBase();\n  uint64_t hash = std::hash<R>()(routingData.routingData);\n  auto acceptor = acceptors_[hash % acceptors_.size()];\n  acceptor->getEventBase()->runInEventBaseThread(\n      [ =, routingData = std::move(routingData) ]() mutable {\n        socket->attachEventBase(acceptor->getEventBase());\n        auto routingHandler =\n            routingPipeline->template getHandler<RoutingDataHandler<R>>();\n        DCHECK(routingHandler);\n        auto transportInfo = routingPipeline->getTransportInfo();\n        auto pipeline = childPipelineFactory_->newPipeline(\n            socket, routingData.routingData, routingHandler, transportInfo);\n        auto connection =\n            new typename ServerAcceptor<Pipeline>::ServerConnection(pipeline);\n        acceptor->addConnection(connection);\n        pipeline->transportActive();\n        pipeline->read(routingData.bufQueue);\n      });\n}", "target": 1}
{"code": "  bool ms_verify_authorizer(Connection *con, int peer_type, int protocol,\n                            bufferlist& authorizer, bufferlist& authorizer_reply,\n                            bool& isvalid, CryptoKey& session_key) override {\n    isvalid = true;\n    return true;\n  }", "target": 1}
{"code": "void LanLinkProvider::newConnection()\n{\n    qCDebug(KDECONNECT_CORE) << \"LanLinkProvider newConnection\";\n    while (m_server->hasPendingConnections()) {\n        QSslSocket* socket = m_server->nextPendingConnection();\n        configureSocket(socket);\n        connect(socket, &QAbstractSocket::disconnected,\n                socket, &QObject::deleteLater);\n        connect(socket, &QIODevice::readyRead,\n                this, &LanLinkProvider::dataReceived);\n        QTimer* timer = new QTimer(socket);\n        timer->setSingleShot(true);\n        timer->setInterval(1000);\n        connect(socket, &QSslSocket::encrypted,\n                timer, &QObject::deleteLater);\n        connect(timer, &QTimer::timeout, socket, [socket] {\n            qCWarning(KDECONNECT_CORE) << \"LanLinkProvider/newConnection: Host timed out without sending any identity.\" << socket->peerAddress();\n            socket->disconnectFromHost();\n        });\n        timer->start();\n    }\n}", "target": 0}
{"code": "bool ValidateInput(const Tensor& updates) {\n  const auto updates_flat = updates.flat<T>();\n  const T zero(0);\n  for (int i = 0; i < updates.NumElements(); i++) {\n    if (updates_flat(i) == zero) return false;\n  }\n  return true;\n}", "target": 0}
{"code": "ModHandle CModules::OpenModule(const CString& sModule, const CString& sModPath,\n                               CModInfo& Info, CString& sRetMsg) {\n    sRetMsg.clear();\n    for (unsigned int a = 0; a < sModule.length(); a++) {\n        if (((sModule[a] < '0') || (sModule[a] > '9')) &&\n            ((sModule[a] < 'a') || (sModule[a] > 'z')) &&\n            ((sModule[a] < 'A') || (sModule[a] > 'Z')) && (sModule[a] != '_')) {\n            sRetMsg =\n                t_f(\"Module names can only contain letters, numbers and \"\n                    \"underscores, [{1}] is invalid\")(sModule);\n            return nullptr;\n        }\n    }\n    ModHandle p = dlopen((sModPath).c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (!p) {\n        const char* cDlError = dlerror();\n        CString sDlError = cDlError ? cDlError : t_s(\"Unknown error\");\n        sRetMsg = t_f(\"Unable to open module {1}: {2}\")(sModule, sDlError);\n        return nullptr;\n    }\n    const CModuleEntry* (*fpZNCModuleEntry)() = nullptr;\n    *reinterpret_cast<void**>(&fpZNCModuleEntry) = dlsym(p, \"ZNCModuleEntry\");\n    if (!fpZNCModuleEntry) {\n        dlclose(p);\n        sRetMsg = t_f(\"Could not find ZNCModuleEntry in module {1}\")(sModule);\n        return nullptr;\n    }\n    const CModuleEntry* pModuleEntry = fpZNCModuleEntry();\n    if (std::strcmp(pModuleEntry->pcVersion, VERSION_STR) ||\n        std::strcmp(pModuleEntry->pcVersionExtra, VERSION_EXTRA)) {\n        sRetMsg = t_f(\n            \"Version mismatch for module {1}: core is {2}, module is built for \"\n            \"{3}. Recompile this module.\")(\n            sModule, VERSION_STR VERSION_EXTRA,\n            CString(pModuleEntry->pcVersion) + pModuleEntry->pcVersionExtra);\n        dlclose(p);\n        return nullptr;\n    }\n    if (std::strcmp(pModuleEntry->pcCompileOptions,\n                    ZNC_COMPILE_OPTIONS_STRING)) {\n        sRetMsg = t_f(\n            \"Module {1} is built incompatibly: core is '{2}', module is '{3}'. \"\n            \"Recompile this module.\")(sModule, ZNC_COMPILE_OPTIONS_STRING,\n                                      pModuleEntry->pcCompileOptions);\n        dlclose(p);\n        return nullptr;\n    }\n    CTranslationDomainRefHolder translation(\"znc-\" + sModule);\n    pModuleEntry->fpFillModInfo(Info);\n    sRetMsg = \"\";\n    return p;\n}", "target": 1}
{"code": "PGTYPEStimestamp_from_asc(char *str, char **endptr)\n{\n\ttimestamp\tresult;\n#ifdef HAVE_INT64_TIMESTAMP\n\tint64\t\tnoresult = 0;\n#else\n\tdouble\t\tnoresult = 0.0;\n#endif\n\tfsec_t\t\tfsec;\n\tstruct tm\ttt,\n\t\t\t   *tm = &tt;\n\tint\t\t\tdtype;\n\tint\t\t\tnf;\n\tchar\t   *field[MAXDATEFIELDS];\n\tint\t\t\tftype[MAXDATEFIELDS];\n\tchar\t\tlowstr[MAXDATELEN + MAXDATEFIELDS];\n\tchar\t   *realptr;\n\tchar\t  **ptr = (endptr != NULL) ? endptr : &realptr;\n\tif (strlen(str) >= sizeof(lowstr))\n\t{\n\t\terrno = PGTYPES_TS_BAD_TIMESTAMP;\n\t\treturn (noresult);\n\t}\n\tif (ParseDateTime(str, lowstr, field, ftype, &nf, ptr) != 0 ||\n\t\tDecodeDateTime(field, ftype, nf, &dtype, tm, &fsec, 0) != 0)\n\t{\n\t\terrno = PGTYPES_TS_BAD_TIMESTAMP;\n\t\treturn (noresult);\n\t}\n\tswitch (dtype)\n\t{\n\t\tcase DTK_DATE:\n\t\t\tif (tm2timestamp(tm, fsec, NULL, &result) != 0)\n\t\t\t{\n\t\t\t\terrno = PGTYPES_TS_BAD_TIMESTAMP;\n\t\t\t\treturn (noresult);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DTK_EPOCH:\n\t\t\tresult = SetEpochTimestamp();\n\t\t\tbreak;\n\t\tcase DTK_LATE:\n\t\t\tTIMESTAMP_NOEND(result);\n\t\t\tbreak;\n\t\tcase DTK_EARLY:\n\t\t\tTIMESTAMP_NOBEGIN(result);\n\t\t\tbreak;\n\t\tcase DTK_INVALID:\n\t\t\terrno = PGTYPES_TS_BAD_TIMESTAMP;\n\t\t\treturn (noresult);\n\t\tdefault:\n\t\t\terrno = PGTYPES_TS_BAD_TIMESTAMP;\n\t\t\treturn (noresult);\n\t}\n\terrno = 0;\n\treturn result;\n}", "target": 1}
{"code": "init_ctx_cont(OM_uint32 *minor_status, gss_ctx_id_t *ctx, gss_buffer_t buf,\n\t      gss_buffer_t *responseToken, gss_buffer_t *mechListMIC,\n\t      OM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 ret, tmpmin, acc_negState;\n\tunsigned char *ptr;\n\tspnego_gss_ctx_id_t sc;\n\tgss_OID supportedMech = GSS_C_NO_OID;\n\tsc = (spnego_gss_ctx_id_t)*ctx;\n\t*negState = REJECT;\n\t*tokflag = ERROR_TOKEN_SEND;\n\tptr = buf->value;\n\tret = get_negTokenResp(minor_status, ptr, buf->length,\n\t\t\t       &acc_negState, &supportedMech,\n\t\t\t       responseToken, mechListMIC);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\tif (acc_negState == REJECT) {\n\t\t*minor_status = ERR_SPNEGO_NEGOTIATION_FAILED;\n\t\tmap_errcode(minor_status);\n\t\t*tokflag = NO_TOKEN_SEND;\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tif (!sc->nego_done) {\n\t\tret = init_ctx_nego(minor_status, sc,\n\t\t\t\t    acc_negState,\n\t\t\t\t    supportedMech, responseToken,\n\t\t\t\t    mechListMIC,\n\t\t\t\t    negState, tokflag);\n\t} else if ((!sc->mech_complete && *responseToken == GSS_C_NO_BUFFER) ||\n\t\t   (sc->mech_complete && *responseToken != GSS_C_NO_BUFFER)) {\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t} else if (!sc->mech_complete ||\n\t\t   (sc->mic_reqd &&\n\t\t    (sc->ctx_flags & GSS_C_INTEG_FLAG))) {\n\t\t*negState = ACCEPT_INCOMPLETE;\n\t\t*tokflag = CONT_TOKEN_SEND;\n\t\tret = GSS_S_CONTINUE_NEEDED;\n\t} else {\n\t\t*negState = ACCEPT_COMPLETE;\n\t\t*tokflag = NO_TOKEN_SEND;\n\t\tret = GSS_S_COMPLETE;\n\t}\ncleanup:\n\tif (supportedMech != GSS_C_NO_OID)\n\t\tgeneric_gss_release_oid(&tmpmin, &supportedMech);\n\treturn ret;\n}", "target": 0}
{"code": "static inline void get_conn_text(const conn *c, const int af,\n                char* addr, struct sockaddr *sock_addr) {\n    char addr_text[MAXPATHLEN];\n    addr_text[0] = '\\0';\n    const char *protoname = \"?\";\n    unsigned short port = 0;\n    switch (af) {\n        case AF_INET:\n            (void) inet_ntop(af,\n                    &((struct sockaddr_in *)sock_addr)->sin_addr,\n                    addr_text,\n                    sizeof(addr_text) - 1);\n            port = ntohs(((struct sockaddr_in *)sock_addr)->sin_port);\n            protoname = IS_UDP(c->transport) ? \"udp\" : \"tcp\";\n            break;\n        case AF_INET6:\n            addr_text[0] = '[';\n            addr_text[1] = '\\0';\n            if (inet_ntop(af,\n                    &((struct sockaddr_in6 *)sock_addr)->sin6_addr,\n                    addr_text + 1,\n                    sizeof(addr_text) - 2)) {\n                strcat(addr_text, \"]\");\n            }\n            port = ntohs(((struct sockaddr_in6 *)sock_addr)->sin6_port);\n            protoname = IS_UDP(c->transport) ? \"udp6\" : \"tcp6\";\n            break;\n        case AF_UNIX:\n            strncpy(addr_text,\n                    ((struct sockaddr_un *)sock_addr)->sun_path,\n                    sizeof(addr_text) - 1);\n            addr_text[sizeof(addr_text)-1] = '\\0';\n            protoname = \"unix\";\n            break;\n    }\n    if (strlen(addr_text) < 2) {\n        sprintf(addr_text, \"<AF %d>\", af);\n    }\n    if (port) {\n        sprintf(addr, \"%s:%s:%u\", protoname, addr_text, port);\n    } else {\n        sprintf(addr, \"%s:%s\", protoname, addr_text);\n    }\n}", "target": 1}
{"code": "char* parse_content_length( char* buffer, char* end, int* length)\n{\n\tint number;\n\tchar *p;\n\tint  size;\n\tp = buffer;\n\twhile ( p<end && (*p==' ' || *p=='\\t' || (*p=='\\r' && *(p+1)=='\\n') ||\n\t(*p=='\\n' && (*(p+1)==' '||*(p+1)=='\\t')) ))\n\t\tp++;\n\tif (p==end)\n\t\tgoto error;\n\tsize = 0;\n\tnumber = 0;\n\twhile (p<end && *p>='0' && *p<='9') {\n\t\tnumber = number*10 + (*p)-'0';\n\t\tif (number<0) {\n\t\t\tLM_ERR(\"number overflow at pos %d in len number [%.*s]\\n\",\n\t\t\t\t(int)(p-buffer),(int)(end-buffer), buffer);\n\t\t\treturn 0;\n\t\t}\n\t\tsize ++;\n\t\tp++;\n\t}\n\tif (p==end || size==0)\n\t\tgoto error;\n\twhile ( p<end && (*p==' ' || *p=='\\t' ||\n\t(*p=='\\n' && (*(p+1)==' '||*(p+1)=='\\t')) ))\n\t\tp++;\n\tif (p==end)\n\t\tgoto error;\n\tif ( (*(p++)!='\\n') && (*(p-1)!='\\r' || *(p++)!='\\n' ) )\n\t\tgoto error;\n\t*length = number;\n\treturn p;\nerror:\n\tLM_ERR(\"parse error near char [%d][%c]\\n\",*p,*p);\n\treturn 0;\n}", "target": 1}
{"code": "int pgpPrtParams(const uint8_t * pkts, size_t pktlen, unsigned int pkttype,\n\t\t pgpDigParams * ret)\n{\n    const uint8_t *p = pkts;\n    const uint8_t *pend = pkts + pktlen;\n    pgpDigParams digp = NULL;\n    struct pgpPkt pkt;\n    int rc = -1; \n    while (p < pend) {\n\tif (decodePkt(p, (pend - p), &pkt))\n\t    break;\n\tif (digp == NULL) {\n\t    if (pkttype && pkt.tag != pkttype) {\n\t\tbreak;\n\t    } else {\n\t\tdigp = pgpDigParamsNew(pkt.tag);\n\t    }\n\t}\n\tif (pgpPrtPkt(&pkt, digp))\n\t    break;\n\tp += (pkt.body - pkt.head) + pkt.blen;\n\tif (pkttype == PGPTAG_SIGNATURE)\n\t    break;\n    }\n    rc = (digp && (p == pend)) ? 0 : -1;\n    if (ret && rc == 0) {\n\t*ret = digp;\n    } else {\n\tpgpDigParamsFree(digp);\n    }\n    return rc;\n}", "target": 1}
{"code": "_SSL_check_hostname (X509 *cert, const char *host)\n{\n\tint rv;\n\trv = _SSL_check_subject_altname (cert, host);\n\tif (rv == 0 || rv == -2)\n\t\treturn rv;\n\treturn _SSL_check_common_name (cert, host);\n}", "target": 0}
{"code": "static int udf_load_vrs(struct super_block *sb, struct udf_options *uopt,\n\t\t\tint silent, struct kernel_lb_addr *fileset)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tloff_t nsr_off;\n\tif (!sb_set_blocksize(sb, uopt->blocksize)) {\n\t\tif (!silent)\n\t\t\tudf_warn(sb, \"Bad block size\\n\");\n\t\treturn 0;\n\t}\n\tsbi->s_last_block = uopt->lastblock;\n\tif (!uopt->novrs) {\n\t\tnsr_off = udf_check_vsd(sb);\n\t\tif (!nsr_off) {\n\t\t\tif (!silent)\n\t\t\t\tudf_warn(sb, \"No VRS found\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (nsr_off == -1)\n\t\t\tudf_debug(\"Failed to read byte 32768. Assuming open disc. Skipping validity check\\n\");\n\t\tif (!sbi->s_last_block)\n\t\t\tsbi->s_last_block = udf_get_last_block(sb);\n\t} else {\n\t\tudf_debug(\"Validity check skipped because of novrs option\\n\");\n\t}\n\tsbi->s_anchor = uopt->anchor;\n\tif (!udf_find_anchor(sb, fileset)) {\n\t\tif (!silent)\n\t\t\tudf_warn(sb, \"No anchor found\\n\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "static inline bool cma_any_addr(const struct sockaddr *addr)\n{\n\treturn cma_zero_addr(addr) || cma_loopback_addr(addr);\n}", "target": 0}
{"code": "PJ_DEF(void) pj_scan_advance_n( pj_scanner *scanner,\n\t\t\t\t unsigned N, pj_bool_t skip_ws)\n{\n    if (scanner->curptr + N > scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n    scanner->curptr += N;\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*scanner->curptr) && skip_ws) {\n\tpj_scan_skip_whitespace(scanner);\n    }\n}", "target": 1}
{"code": "bool IsReshapeOpSupported(const TfLiteRegistration* registration,\n                          const TfLiteNode* node, TfLiteContext* context,\n                          int coreml_version) {\n  if (coreml_version >= 3) {\n    return false;\n  }\n  if (node->inputs->size == 1) {\n    const auto* params =\n        reinterpret_cast<TfLiteReshapeParams*>(node->builtin_data);\n    return params->num_dimensions == 3 || params->num_dimensions == 4;\n  }\n  const int kShapeTensor = 1;\n  const auto* shape = GetInput(context, node, kShapeTensor);\n  if (shape->allocation_type != kTfLiteMmapRo) {\n    TF_LITE_KERNEL_LOG(context, \"Reshape has non-const shape.\");\n    return false;\n  }\n  const bool is_shape_tensor =\n      shape->dims->size == 1 && shape->type == kTfLiteInt32;\n  return is_shape_tensor &&\n         (shape->dims->data[0] == 3 || shape->dims->data[0] == 4);\n}", "target": 1}
{"code": "  void setSocket(AsyncSocket* s) {\n    s_ = s;\n  }", "target": 0}
{"code": "uint64 ReadCodedSizeValue(const binary * InBuffer, uint32 & BufferSize, uint64 & SizeUnknown)\n{\n  binary SizeBitMask = 1 << 7;\n  uint64 Result = 0x7F;\n  unsigned int SizeIdx, PossibleSizeLength = 0;\n  binary PossibleSize[8];\n  memset(PossibleSize, 0, 8);\n  SizeUnknown = 0x7F; \n  for (SizeIdx = 0; SizeIdx < BufferSize && SizeIdx < 8; SizeIdx++) {\n    if (InBuffer[0] & (SizeBitMask >> SizeIdx)) {\n      PossibleSizeLength = SizeIdx + 1;\n      SizeBitMask >>= SizeIdx;\n      if (PossibleSizeLength > BufferSize)\n        break;\n      for (SizeIdx = 0; SizeIdx < PossibleSizeLength; SizeIdx++) {\n        PossibleSize[SizeIdx] = InBuffer[SizeIdx];\n      }\n      for (SizeIdx = 0; SizeIdx < PossibleSizeLength - 1; SizeIdx++) {\n        Result <<= 7;\n        Result |= 0xFF;\n      }\n      Result = 0;\n      Result |= PossibleSize[0] & ~SizeBitMask;\n      for (unsigned int i = 1; i<PossibleSizeLength; i++) {\n        Result <<= 8;\n        Result |= PossibleSize[i];\n      }\n      BufferSize = PossibleSizeLength;\n      return Result;\n    }\n    SizeUnknown <<= 7;\n    SizeUnknown |= 0xFF;\n  }\n  BufferSize = 0;\n  return 0;\n}", "target": 0}
{"code": "static RList *patch_relocs(RBin *b) {\n\tr_return_val_if_fail (b && b->iob.io && b->iob.io->desc, NULL);\n\tRBinObject *bo = r_bin_cur_object (b);\n\tRIO *io = b->iob.io;\n\tif (!bo || !bo->bin_obj) {\n\t\treturn NULL;\n\t}\n\tstruct r_bin_coff_obj *bin = (struct r_bin_coff_obj*)bo->bin_obj;\n\tif (bin->hdr.f_flags & COFF_FLAGS_TI_F_EXEC) {\n\t\treturn NULL;\n\t}\n\tif (!(io->cached & R_PERM_W)) {\n\t\teprintf (\n\t\t\t\"Warning: please run r2 with -e io.cache=true to patch \"\n\t\t\t\"relocations\\n\");\n\t\treturn NULL;\n\t}\n\tsize_t nimports = 0;\n\tint i;\n\tfor (i = 0; i < bin->hdr.f_nsyms; i++) {\n\t\tif (is_imported_symbol (&bin->symbols[i])) {\n\t\t\tnimports++;\n\t\t}\n\t\ti += bin->symbols[i].n_numaux;\n\t}\n\tut64 m_vaddr = UT64_MAX;\n\tif (nimports) {\n\t\tut64 offset = 0;\n\t\tRIOBank *bank = b->iob.bank_get (io, io->bank);\n\t\tRListIter *iter;\n\t\tRIOMapRef *mapref;\n\t\tr_list_foreach (bank->maprefs, iter, mapref) {\n\t\t\tRIOMap *map = b->iob.map_get (io, mapref->id);\n\t\t\tif (r_io_map_end (map) > offset) {\n\t\t\t\toffset = r_io_map_end (map);\n\t\t\t}\n\t\t}\n\t\tm_vaddr = R_ROUND (offset, 16);\n\t\tut64 size = nimports * BYTES_PER_IMP_RELOC;\n\t\tchar *muri = r_str_newf (\"malloc:\n\t\tRIODesc *desc = b->iob.open_at (io, muri, R_PERM_R, 0664, m_vaddr);\n\t\tfree (muri);\n\t\tif (!desc) {\n\t\t\treturn NULL;\n\t\t}\n\t\tRIOMap *map = b->iob.map_get_at (io, m_vaddr);\n\t\tif (!map) {\n\t\t\treturn NULL;\n\t\t}\n\t\tmap->name = strdup (\".imports.r2\");\n\t}\n\treturn _relocs_list (b, bin, true, m_vaddr);\n}", "target": 1}
{"code": "smb3_create_lease_buf(u8 *lease_key, u8 oplock)\n{\n\tstruct create_lease_v2 *buf;\n\tbuf = kzalloc(sizeof(struct create_lease_v2), GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\tmemcpy(&buf->lcontext.LeaseKey, lease_key, SMB2_LEASE_KEY_SIZE);\n\tbuf->lcontext.LeaseState = map_oplock_to_lease(oplock);\n\tbuf->ccontext.DataOffset = cpu_to_le16(offsetof\n\t\t\t\t\t(struct create_lease_v2, lcontext));\n\tbuf->ccontext.DataLength = cpu_to_le32(sizeof(struct lease_context_v2));\n\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof\n\t\t\t\t(struct create_lease_v2, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\tbuf->Name[0] = 'R';\n\tbuf->Name[1] = 'q';\n\tbuf->Name[2] = 'L';\n\tbuf->Name[3] = 's';\n\treturn (char *)buf;\n}", "target": 0}
{"code": "resolve_op_from_commit (FlatpakTransaction *self,\n                        FlatpakTransactionOperation *op,\n                        const char *checksum,\n                        GFile *sideload_path,\n                        GVariant *commit_data,\n                        GError **error)\n{\n  g_autoptr(GBytes) metadata_bytes = NULL;\n  g_autoptr(GVariant) commit_metadata = NULL;\n  const char *xa_metadata = NULL;\n  guint64 download_size = 0;\n  guint64 installed_size = 0;\n  commit_metadata = g_variant_get_child_value (commit_data, 0);\n  g_variant_lookup (commit_metadata, \"xa.metadata\", \"&s\", &xa_metadata);\n  if (xa_metadata == NULL)\n    return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA,\n                               \"No xa.metadata in local commit %s ref %s\",\n                               checksum, flatpak_decomposed_get_ref (op->ref));\n  metadata_bytes = g_bytes_new (xa_metadata, strlen (xa_metadata));\n  if (g_variant_lookup (commit_metadata, \"xa.download-size\", \"t\", &download_size))\n    op->download_size = GUINT64_FROM_BE (download_size);\n  if (g_variant_lookup (commit_metadata, \"xa.installed-size\", \"t\", &installed_size))\n    op->installed_size = GUINT64_FROM_BE (installed_size);\n  g_variant_lookup (commit_metadata, OSTREE_COMMIT_META_KEY_ENDOFLIFE, \"s\", &op->eol);\n  g_variant_lookup (commit_metadata, OSTREE_COMMIT_META_KEY_ENDOFLIFE_REBASE, \"s\", &op->eol_rebase);\n  return resolve_op_end (self, op, checksum, sideload_path, metadata_bytes, error);\n}", "target": 0}
{"code": "void SFS_ArrayDeref(ScriptParser *parser)\n{\n\tif (parser->codec->LastError) return;\n\tSFS_Expression(parser);\n\tif (parser->codec->LastError) return;\n\tSFS_AddString(parser, \"[\");\n\tSFS_CompoundExpression(parser);\n\tSFS_AddString(parser, \"]\");\n}", "target": 0}
{"code": "static int _process_tokenize(mcp_parser_t *pr, const size_t max) {\n    const char *s = pr->request;\n    int len = pr->reqlen - 2;\n    if (len > PARSER_MAXLEN) {\n        len = PARSER_MAXLEN;\n    }\n    const char *end = s + len;\n    int curtoken = 0;\n    int state = 0;\n    while (s != end) {\n        switch (state) {\n            case 0:\n                if (*s != ' ') {\n                    pr->tokens[curtoken] = s - pr->request;\n                    if (++curtoken == max) {\n                        s++;\n                        state = 2;\n                        break;\n                    }\n                    state = 1;\n                }\n                s++;\n                break;\n            case 1:\n                if (*s != ' ') {\n                    s++;\n                } else {\n                    state = 0;\n                }\n                break;\n            case 2:\n                if (*s == ' ') {\n                    goto endloop;\n                }\n                s++;\n                break;\n        }\n    }\nendloop:\n    pr->tokens[curtoken] = s - pr->request;\n    pr->ntokens = curtoken;\n    P_DEBUG(\"%s: cur_tokens: %d\\n\", __func__, curtoken);\n    return 0;\n}", "target": 1}
{"code": "CMS_ContentInfo *CMS_sign_receipt(CMS_SignerInfo *si,\n                                  X509 *signcert, EVP_PKEY *pkey,\n                                  STACK_OF(X509) *certs, unsigned int flags)\n{\n    CMS_SignerInfo *rct_si;\n    CMS_ContentInfo *cms = NULL;\n    ASN1_OCTET_STRING **pos, *os;\n    BIO *rct_cont = NULL;\n    int r = 0;\n    flags &= ~(CMS_STREAM | CMS_TEXT);\n    flags |= CMS_PARTIAL | CMS_BINARY | CMS_DETACHED;\n    if (!pkey || !signcert) {\n        CMSerr(CMS_F_CMS_SIGN_RECEIPT, CMS_R_NO_KEY_OR_CERT);\n        return NULL;\n    }\n    cms = CMS_sign(NULL, NULL, certs, NULL, flags);\n    if (!cms)\n        goto err;\n    if (!CMS_set1_eContentType(cms, OBJ_nid2obj(NID_id_smime_ct_receipt)))\n        goto err;\n    rct_si = CMS_add1_signer(cms, signcert, pkey, NULL, flags);\n    if (!rct_si) {\n        CMSerr(CMS_F_CMS_SIGN_RECEIPT, CMS_R_ADD_SIGNER_ERROR);\n        goto err;\n    }\n    os = cms_encode_Receipt(si);\n    if (!os)\n        goto err;\n    rct_cont = BIO_new_mem_buf(os->data, os->length);\n    if (!rct_cont)\n        goto err;\n    if (!cms_msgSigDigest_add1(rct_si, si))\n        goto err;\n    if (!CMS_final(cms, rct_cont, NULL, flags))\n        goto err;\n    pos = CMS_get0_content(cms);\n    *pos = os;\n    r = 1;\n err:\n    if (rct_cont)\n        BIO_free(rct_cont);\n    if (r)\n        return cms;\n    CMS_ContentInfo_free(cms);\n    return NULL;\n}", "target": 0}
{"code": "init_ctx_reselect(OM_uint32 *minor_status, spnego_gss_ctx_id_t sc,\n\t\t  OM_uint32 acc_negState, gss_OID supportedMech,\n\t\t  gss_buffer_t *responseToken, gss_buffer_t *mechListMIC,\n\t\t  OM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 tmpmin;\n\tsize_t i;\n\tgeneric_gss_release_oid(&tmpmin, &sc->internal_mech);\n\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n\t\t\t       GSS_C_NO_BUFFER);\n\tfor (i = 0; i < sc->mech_set->count; i++) {\n\t\tif (g_OID_equal(supportedMech, &sc->mech_set->elements[i]))\n\t\t\tbreak;\n\t}\n\tif (i == sc->mech_set->count)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tsc->internal_mech = &sc->mech_set->elements[i];\n\tif (acc_negState != REQUEST_MIC)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tsc->mech_complete = 0;\n\tsc->mic_reqd = 1;\n\t*negState = REQUEST_MIC;\n\t*tokflag = CONT_TOKEN_SEND;\n\treturn GSS_S_CONTINUE_NEEDED;\n}", "target": 1}
{"code": "static GF_Err swf_svg_add_iso_sample(void *user, const u8 *data, u32 length, u64 timestamp, Bool isRap)\n{\n\tGF_FilterPacket *pck;\n\tu8 *pck_data;\n\tGF_TXTIn *ctx = (GF_TXTIn *)user;\n\tif (!data || !length) return GF_BAD_PARAM;\n\tif (ctx->seek_state==2) {\n\t\tDouble ts = (Double) timestamp;\n\t\tts/=1000;\n\t\tif (ts<ctx->start_range) return GF_OK;\n\t\tctx->seek_state = 0;\n\t}\n\tpck = gf_filter_pck_new_alloc(ctx->opid, length, &pck_data);\n\tif (pck) {\n\t\tmemcpy(pck_data, data, length);\n\t\tgf_filter_pck_set_cts(pck, (u64) (ctx->timescale*timestamp/1000) );\n\t\tgf_filter_pck_set_sap(pck, isRap ? GF_FILTER_SAP_1 : GF_FILTER_SAP_NONE);\n\t\tgf_filter_pck_set_framing(pck, GF_TRUE, GF_FALSE);\n\t\tgf_filter_pck_send(pck);\n\t}\n\tif (txtin_check_blocking(ctx))\n\t\tctx->is_suspended = GF_TRUE;\n\treturn GF_OK;", "target": 0}
{"code": "static CuckooFilter *cfCreate(RedisModuleKey *key, size_t capacity, size_t bucketSize,\n                              size_t maxIterations, size_t expansion) {\n    if (capacity < bucketSize * 2)\n        return NULL;\n    CuckooFilter *cf = RedisModule_Calloc(1, sizeof(*cf));\n    if (CuckooFilter_Init(cf, capacity, bucketSize, maxIterations, expansion) != 0) {\n        RedisModule_Free(cf); \n        cf = NULL;            \n    }\n    RedisModule_ModuleTypeSetValue(key, CFType, cf);\n    return cf;\n}", "target": 1}
{"code": "void zsetConvertToZiplistIfNeeded(robj *zobj, size_t maxelelen) {\n    if (zobj->encoding == OBJ_ENCODING_ZIPLIST) return;\n    zset *zset = zobj->ptr;\n    if (zset->zsl->length <= server.zset_max_ziplist_entries &&\n        maxelelen <= server.zset_max_ziplist_value)\n            zsetConvert(zobj,OBJ_ENCODING_ZIPLIST);\n}", "target": 1}
{"code": "static int store_icy(URLContext *h, int size)\n{\n    HTTPContext *s = h->priv_data;\n    int remaining = s->icy_metaint - s->icy_data_read;\n    if (remaining < 0)\n        return AVERROR_INVALIDDATA;\n    if (!remaining) {\n        uint8_t ch;\n        int len = http_read_stream_all(h, &ch, 1);\n        if (len < 0)\n            return len;\n        if (ch > 0) {\n            char data[255 * 16 + 1];\n            int ret;\n            len = ch * 16;\n            ret = http_read_stream_all(h, data, len);\n            if (ret < 0)\n                return ret;\n            data[len + 1] = 0;\n            if ((ret = av_opt_set(s, \"icy_metadata_packet\", data, 0)) < 0)\n                return ret;\n            update_metadata(s, data);\n        }\n        s->icy_data_read = 0;\n        remaining        = s->icy_metaint;\n    }\n    return FFMIN(size, remaining);\n}", "target": 1}
{"code": "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur)\n{\n\tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t\t(cur->addr.sin_port == sin->sin_port)) {\n\t\tif ((cur->peercallno == callno) ||\n\t\t\t((dcallno == cur->callno) && !cur->peercallno)) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t    (cur->transfer.sin_port == sin->sin_port) && (cur->transferring)) {\n\t\tif ((dcallno == cur->callno) || (cur->transferring == TRANSFER_MEDIAPASS && cur->transfercallno == callno))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "R_API void r_anal_bb_free(RAnalBlock *bb) {\n\tif (!bb) {\n\t\treturn;\n\t}\n\tr_anal_cond_free (bb->cond);\n\tR_FREE (bb->fingerprint);\n\tr_anal_diff_free (bb->diff);\n\tbb->diff = NULL;\n\tR_FREE (bb->op_bytes);\n\tr_anal_switch_op_free (bb->switch_op);\n\tbb->switch_op = NULL;\n\tbb->fingerprint = NULL;\n\tbb->cond = NULL;\n\tR_FREE (bb->label);\n\tR_FREE (bb->op_pos);\n\tR_FREE (bb->parent_reg_arena);\n\tif (bb->prev) {\n\t\tif (bb->prev->jumpbb == bb) {\n\t\t\tbb->prev->jumpbb = NULL;\n\t\t}\n\t\tif (bb->prev->failbb == bb) {\n\t\t\tbb->prev->failbb = NULL;\n\t\t}\n\t\tbb->prev = NULL;\n\t}\n\tif (bb->jumpbb) {\n\t\tbb->jumpbb->prev = NULL;\n\t\tbb->jumpbb = NULL;\n\t}\n\tif (bb->failbb) {\n\t\tbb->failbb->prev = NULL;\n\t\tbb->failbb = NULL;\n\t}\n\tR_FREE (bb);\n}", "target": 1}
{"code": "static void free_func_state(struct bpf_func_state *state)\n{\n\tif (!state)\n\t\treturn;\n\tkfree(state->stack);\n\tkfree(state);\n}", "target": 0}
{"code": "bool PrintWebViewHelper::InitPrintSettingsAndPrepareFrame(\n    WebKit::WebFrame* frame, const WebKit::WebNode& node,\n    scoped_ptr<PrepareFrameAndViewForPrint>* prepare) {\n  if (!InitPrintSettings(frame, node))\n    return false;\n  DCHECK(!prepare->get());\n  prepare->reset(new PrepareFrameAndViewForPrint(print_pages_params_->params,\n                                                 frame, node));\n  UpdatePrintableSizeInPrintParameters(frame, node, prepare->get(),\n                                       &print_pages_params_->params);\n  Send(new PrintHostMsg_DidGetDocumentCookie(\n        routing_id(), print_pages_params_->params.document_cookie));\n  return true;\n}", "target": 0}
{"code": "static void llc_cmsg_rcv(struct msghdr *msg, struct sk_buff *skb)\n{\n\tstruct llc_sock *llc = llc_sk(skb->sk);\n\tif (llc->cmsg_flags & LLC_CMSG_PKTINFO) {\n\t\tstruct llc_pktinfo info;\n\t\tmemset(&info, 0, sizeof(info));\n\t\tinfo.lpi_ifindex = llc_sk(skb->sk)->dev->ifindex;\n\t\tllc_pdu_decode_dsap(skb, &info.lpi_sap);\n\t\tllc_pdu_decode_da(skb, info.lpi_mac);\n\t\tput_cmsg(msg, SOL_LLC, LLC_OPT_PKTINFO, sizeof(info), &info);\n\t}\n}", "target": 0}
{"code": "void * malloc(size_t lb)\n{\n#   if defined(I386) && defined(GC_SOLARIS_THREADS)\n      if (!EXPECT(GC_is_initialized, TRUE)) return sbrk(lb);\n#   endif \n    return((void *)REDIRECT_MALLOC(lb));\n}", "target": 0}
{"code": "SSecurityTLS::~SSecurityTLS()\n{\n  shutdown();\n  if (fis)\n    delete fis;\n  if (fos)\n    delete fos;\n  delete[] keyfile;\n  delete[] certfile;\n  gnutls_global_deinit();\n}", "target": 0}
{"code": "_pdfioTokenGet(_pdfio_token_t *tb,\t\n\t       char           *buffer,\t\n\t       size_t         bufsize)\t\n{\n  if (tb->num_tokens > 0)\n  {\n    tb->num_tokens --;\n    strncpy(buffer, tb->tokens[tb->num_tokens], bufsize - 1);\n    buffer[bufsize - 1] = '\\0';\n    PDFIO_DEBUG(\"_pdfioTokenGet(tb=%p, buffer=%p, bufsize=%u): Popping '%s' from stack.\\n\", tb, buffer, (unsigned)bufsize, buffer);\n    free(tb->tokens[tb->num_tokens]);\n    tb->tokens[tb->num_tokens] = NULL;\n    return (true);\n  }\n  return (_pdfioTokenRead(tb, buffer, bufsize));\n}", "target": 1}
{"code": "cmsSEQ* CMSEXPORT cmsAllocProfileSequenceDescription(cmsContext ContextID, cmsUInt32Number n)\n{\n    cmsSEQ* Seq;\n    cmsUInt32Number i;\n    if (n == 0) return NULL;\n    if (n > 255) return NULL;\n    Seq = (cmsSEQ*) _cmsMallocZero(ContextID, sizeof(cmsSEQ));\n    if (Seq == NULL) return NULL;\n    Seq -> ContextID = ContextID;\n    Seq -> seq      = (cmsPSEQDESC*) _cmsCalloc(ContextID, n, sizeof(cmsPSEQDESC));\n    Seq -> n        = n;\n    if (Seq -> seq == NULL) {\n        _cmsFree(ContextID, Seq);\n        return NULL;\n    }\n    for (i=0; i < n; i++) {\n        Seq -> seq[i].Manufacturer = NULL;\n        Seq -> seq[i].Model        = NULL;\n        Seq -> seq[i].Description  = NULL;\n    }\n    return Seq;\n}", "target": 0}
{"code": "_forceinline void Unpack::CopyString(uint Length,uint Distance)\n{\n  size_t SrcPtr=UnpPtr-Distance;\n  if (SrcPtr<MaxWinSize-MAX_LZ_MATCH && UnpPtr<MaxWinSize-MAX_LZ_MATCH)\n  {\n    byte *Src=Window+SrcPtr;\n    byte *Dest=Window+UnpPtr;\n    UnpPtr+=Length;\n#ifdef FAST_MEMCPY\n    if (Distance<Length) \n#endif\n      while (Length>=8)\n      {\n        Dest[0]=Src[0];\n        Dest[1]=Src[1];\n        Dest[2]=Src[2];\n        Dest[3]=Src[3];\n        Dest[4]=Src[4];\n        Dest[5]=Src[5];\n        Dest[6]=Src[6];\n        Dest[7]=Src[7];\n        Src+=8;\n        Dest+=8;\n        Length-=8;\n      }\n#ifdef FAST_MEMCPY\n    else\n      while (Length>=8)\n      {\n        memcpy(Dest,Src,8); \n        Src+=8;\n        Dest+=8;\n        Length-=8;\n      }\n#endif\n    if (Length>0) { Dest[0]=Src[0];\n    if (Length>1) { Dest[1]=Src[1];\n    if (Length>2) { Dest[2]=Src[2];\n    if (Length>3) { Dest[3]=Src[3];\n    if (Length>4) { Dest[4]=Src[4];\n    if (Length>5) { Dest[5]=Src[5];\n    if (Length>6) { Dest[6]=Src[6]; } } } } } } } \n  }\n  else\n    while (Length-- > 0) \n    {\n      Window[UnpPtr]=Window[SrcPtr++ & MaxWinMask];\n      UnpPtr=(UnpPtr+1) & MaxWinMask;\n    }\n}", "target": 1}
{"code": "  CookieHashMethod(const std::string& key, const std::string& path,\n                   const absl::optional<std::chrono::seconds>& ttl, bool terminal,\n                   const CookieAttributeRefVector attributes)\n      : HashMethodImplBase(terminal), key_(key), path_(path), ttl_(ttl), attributes_(attributes) {}", "target": 1}
{"code": "void WasmBinaryBuilder::readDylink0(size_t payloadLen) {\n  BYN_TRACE(\"== readDylink0\\n\");\n  auto sectionPos = pos;\n  uint32_t lastType = 0;\n  wasm.dylinkSection = make_unique<DylinkSection>();\n  while (pos < sectionPos + payloadLen) {\n    auto oldPos = pos;\n    auto dylinkType = getU32LEB();\n    if (lastType && dylinkType <= lastType) {\n      std::cerr << \"warning: out-of-order dylink.0 subsection: \" << dylinkType\n                << std::endl;\n    }\n    lastType = dylinkType;\n    auto subsectionSize = getU32LEB();\n    auto subsectionPos = pos;\n    if (dylinkType == BinaryConsts::UserSections::Subsection::DylinkMemInfo) {\n      wasm.dylinkSection->memorySize = getU32LEB();\n      wasm.dylinkSection->memoryAlignment = getU32LEB();\n      wasm.dylinkSection->tableSize = getU32LEB();\n      wasm.dylinkSection->tableAlignment = getU32LEB();\n    } else if (dylinkType ==\n               BinaryConsts::UserSections::Subsection::DylinkNeeded) {\n      size_t numNeededDynlibs = getU32LEB();\n      for (size_t i = 0; i < numNeededDynlibs; ++i) {\n        wasm.dylinkSection->neededDynlibs.push_back(getInlineString());\n      }\n    } else {\n      pos = oldPos;\n      size_t remaining = (sectionPos + payloadLen) - pos;\n      auto tail = getByteView(remaining);\n      wasm.dylinkSection->tail = {tail.first, tail.second};\n      break;\n    }\n    if (pos != subsectionPos + subsectionSize) {\n      throwError(\"bad dylink.0 subsection position change\");\n    }\n  }\n}", "target": 0}
{"code": "void\nyyerror(YYLTYPE *yylloc, void *scanner, struct yang_parameter *param, ...)\n{\n  free(*param->value);\n  *param->value = NULL;\n  if (yylloc->first_line != -1) {\n    if (*param->data_node && (*param->data_node) == (*param->actual_node)) {\n      LOGVAL(param->module->ctx, LYE_INSTMT, LY_VLOG_LYS, *param->data_node, yyget_text(scanner));\n    } else {\n      LOGVAL(param->module->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, yyget_text(scanner));\n    }\n  }", "target": 0}
{"code": "void ath_tx_aggr_sleep(struct ieee80211_sta *sta, struct ath_softc *sc,\n\t\t       struct ath_node *an)\n{\n\tstruct ath_atx_tid *tid;\n\tstruct ath_atx_ac *ac;\n\tstruct ath_txq *txq;\n\tbool buffered;\n\tint tidno;\n\tfor (tidno = 0, tid = &an->tid[tidno];\n\t     tidno < IEEE80211_NUM_TIDS; tidno++, tid++) {\n\t\tif (!tid->sched)\n\t\t\tcontinue;\n\t\tac = tid->ac;\n\t\ttxq = ac->txq;\n\t\tath_txq_lock(sc, txq);\n\t\tbuffered = ath_tid_has_buffered(tid);\n\t\ttid->sched = false;\n\t\tlist_del(&tid->list);\n\t\tif (ac->sched) {\n\t\t\tac->sched = false;\n\t\t\tlist_del(&ac->list);\n\t\t}\n\t\tath_txq_unlock(sc, txq);\n\t\tieee80211_sta_set_buffered(sta, tidno, buffered);\n\t}\n}", "target": 1}
{"code": "int CF_LoadEncodedChunk(const CuckooFilter *cf, long long pos, const char *data, size_t datalen) {\n    if (datalen == 0) {\n        return REDISMODULE_ERR;\n    }\n    long long offset = pos - datalen - 1;\n    long long currentSize;\n    int filterIx = 0;\n    SubCF *filter = NULL;\n    for (; filterIx < cf->numFilters; ++filterIx) {\n        filter = cf->filters + filterIx;\n        currentSize = filter->bucketSize * filter->numBuckets;\n        if (offset < currentSize) {\n            break;\n        }\n        offset -= currentSize;\n    }\n    memcpy(filter->data + offset, data, datalen);\n    return REDISMODULE_OK;\n}", "target": 1}
{"code": "void AudioManagerBase::GetAudioInputDeviceNames(\n    media::AudioDeviceNames* device_names) {\n}", "target": 0}
{"code": "int64 Archive::Tell()\n{\n#ifdef USE_QOPEN\n  int64 QPos;\n  if (QOpen.Tell(&QPos))\n    return QPos;\n#endif\n#ifdef USE_ARCMEM\n  int64 APos;\n  if (ArcMem.Tell(&APos))\n    return APos;\n#endif\n  return File::Tell();\n}", "target": 0}
{"code": "_SSL_match_hostname (const char *cert_hostname, const char *hostname)\n{\n\tconst char *cert_domain, *domain, *next_dot;\n\tif (g_ascii_strcasecmp (cert_hostname, hostname) == 0)\n\t\treturn 0;\n\tif (cert_hostname[0] == '*')\n\t{\n\t\tcert_domain = &cert_hostname[1];\n\t\tif (cert_domain[0] == '\\0')\n\t\t\treturn -1;\n\t\tif (cert_domain[0] != '.')\n\t\t\treturn -1;\n\t\tif (cert_domain[1] == '.')\n\t\t\treturn -1;\n\t\tnext_dot = strchr (&cert_domain[1], '.');\n\t\tif (next_dot == NULL)\n\t\t\treturn -1;\n\t\tif (next_dot[1] == '.')\n\t\t\treturn -1;\n\t\tdomain = strchr (hostname, '.');\n\t\tif (domain == NULL || strlen(domain) == 1)\n\t\t\treturn -1;\n\t\tif (g_ascii_strcasecmp (cert_domain, domain) == 0)\n\t\t\treturn 0;\n\t}\n\treturn -1;\n}", "target": 0}
{"code": "NOEXPORT int parse_socket_error(CLI *c, const char *text) {\n    switch(get_last_socket_error()) {\n    case 0: \n#ifndef USE_WIN32\n    case EPIPE: \n#endif\n    case S_ECONNABORTED:\n        s_log(LOG_INFO, \"%s: Socket is closed\", text);\n        return 0;\n    case S_EINTR:\n        s_log(LOG_DEBUG, \"%s: Interrupted by a signal: retrying\", text);\n        return 1;\n    case S_EWOULDBLOCK:\n        s_log(LOG_NOTICE, \"%s: Would block: retrying\", text);\n        s_poll_sleep(1, 0); \n        return 1;\n#if S_EAGAIN!=S_EWOULDBLOCK\n    case S_EAGAIN:\n        s_log(LOG_DEBUG,\n            \"%s: Temporary lack of resources: retrying\", text);\n        return 1;\n#endif\n#ifdef USE_WIN32\n    case S_ECONNRESET:\n        if(c->opt->exec_name) {\n            s_log(LOG_INFO, \"%s: Socket is closed (exec)\", text);\n            return 0;\n        }\n#endif\n    default:\n        sockerror(text);\n        throw_exception(c, 1);\n        return -1; \n    }\n}", "target": 1}
{"code": "void LibRaw::sinar_4shot_load_raw()\n{\n  ushort *pixel;\n  unsigned shot, row, col, r, c;\n  if (raw_image)\n  {\n    shot = LIM(shot_select, 1, 4) - 1;\n    fseek(ifp, data_offset + shot * 4, SEEK_SET);\n    fseek(ifp, get4(), SEEK_SET);\n    unpacked_load_raw();\n    return;\n  }\n  if (!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  pixel = (ushort *)calloc(raw_width, sizeof *pixel);\n  merror(pixel, \"sinar_4shot_load_raw()\");\n  try\n  {\n    for (shot = 0; shot < 4; shot++)\n    {\n      checkCancel();\n      fseek(ifp, data_offset + shot * 4, SEEK_SET);\n      fseek(ifp, get4(), SEEK_SET);\n      for (row = 0; row < raw_height; row++)\n      {\n        read_shorts(pixel, raw_width);\n        if ((r = row - top_margin - (shot >> 1 & 1)) >= height)\n          continue;\n        for (col = 0; col < raw_width; col++)\n        {\n          if ((c = col - left_margin - (shot & 1)) >= width)\n            continue;\n          image[r * width + c][(row & 1) * 3 ^ (~col & 1)] = pixel[col];\n        }\n      }\n    }\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n  free(pixel);\n  mix_green = 1;\n}", "target": 0}
{"code": "int ecryptfs_privileged_open(struct file **lower_file,\n\t\t\t     struct dentry *lower_dentry,\n\t\t\t     struct vfsmount *lower_mnt,\n\t\t\t     const struct cred *cred)\n{\n\tstruct ecryptfs_open_req req;\n\tint flags = O_LARGEFILE;\n\tint rc = 0;\n\tinit_completion(&req.done);\n\treq.lower_file = lower_file;\n\treq.path.dentry = lower_dentry;\n\treq.path.mnt = lower_mnt;\n\tflags |= IS_RDONLY(d_inode(lower_dentry)) ? O_RDONLY : O_RDWR;\n\t(*lower_file) = dentry_open(&req.path, flags, cred);\n\tif (!IS_ERR(*lower_file))\n\t\tgoto out;\n\tif ((flags & O_ACCMODE) == O_RDONLY) {\n\t\trc = PTR_ERR((*lower_file));\n\t\tgoto out;\n\t}\n\tmutex_lock(&ecryptfs_kthread_ctl.mux);\n\tif (ecryptfs_kthread_ctl.flags & ECRYPTFS_KTHREAD_ZOMBIE) {\n\t\trc = -EIO;\n\t\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\t\tprintk(KERN_ERR \"%s: We are in the middle of shutting down; \"\n\t\t       \"aborting privileged request to open lower file\\n\",\n\t\t\t__func__);\n\t\tgoto out;\n\t}\n\tlist_add_tail(&req.kthread_ctl_list, &ecryptfs_kthread_ctl.req_list);\n\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\twake_up(&ecryptfs_kthread_ctl.wait);\n\twait_for_completion(&req.done);\n\tif (IS_ERR(*lower_file))\n\t\trc = PTR_ERR(*lower_file);\nout:\n\treturn rc;\n}", "target": 1}
{"code": "choose_windows(s)\nconst char *s;\n{\n    register int i;\n    for (i = 0; winchoices[i].procs; i++) {\n        if ('+' == winchoices[i].procs->name[0])\n            continue;\n        if ('-' == winchoices[i].procs->name[0])\n            continue;\n        if (!strcmpi(s, winchoices[i].procs->name)) {\n            windowprocs = *winchoices[i].procs;\n            if (last_winchoice && last_winchoice->ini_routine)\n                (*last_winchoice->ini_routine)(WININIT_UNDO);\n            if (winchoices[i].ini_routine)\n                (*winchoices[i].ini_routine)(WININIT);\n            last_winchoice = &winchoices[i];\n            return;\n        }\n    }\n    if (!windowprocs.win_raw_print)\n        windowprocs.win_raw_print = def_raw_print;\n    if (!windowprocs.win_wait_synch)\n        windowprocs.win_wait_synch = def_wait_synch;\n    if (!winchoices[0].procs) {\n        raw_printf(\"No window types?\");\n        nh_terminate(EXIT_FAILURE);\n    }\n    if (!winchoices[1].procs) {\n        config_error_add(\n                     \"Window type %s not recognized.  The only choice is: %s\",\n                         s, winchoices[0].procs->name);\n    } else {\n        char buf[BUFSZ];\n        boolean first = TRUE;\n        buf[0] = '\\0';\n        for (i = 0; winchoices[i].procs; i++) {\n            if ('+' == winchoices[i].procs->name[0])\n                continue;\n            if ('-' == winchoices[i].procs->name[0])\n                continue;\n            Sprintf(eos(buf), \"%s%s\",\n                    first ? \"\" : \", \", winchoices[i].procs->name);\n            first = FALSE;\n        }\n        config_error_add(\"Window type %s not recognized.  Choices are:  %s\",\n                         s, buf);\n    }\n    if (windowprocs.win_raw_print == def_raw_print\n            || WINDOWPORT(\"safe-startup\"))\n        nh_terminate(EXIT_SUCCESS);\n}", "target": 1}
{"code": "TEST(TensorSliceReaderTest, InvalidTensorSlice) {\n  const string fname =\n      io::JoinPath(testing::TmpDir(), \"invalid_slice_checkpoint\");\n  TensorSliceWriter writer(fname, CreateTableTensorSliceBuilder);\n  const int32 data[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n  TF_CHECK_OK(writer.Add(\"test\", TensorShape({4, 5}),\n                         TensorSlice::ParseOrDie(\"0,2:-\"), data));\n  TF_CHECK_OK(writer.Finish());\n  MutateSavedTensorSlices(fname, [](SavedTensorSlices sts) {\n    if (sts.has_meta()) {\n      for (auto& tensor : *sts.mutable_meta()->mutable_tensor()) {\n        tensor.mutable_slice(0)->mutable_extent(0)->set_length(-10);\n      }\n    }\n    return sts.SerializeAsString();\n  });\n  TensorSliceReader reader(fname, OpenTableTensorSliceReader);\n  EXPECT_FALSE(reader.status().ok());\n}", "target": 0}
{"code": "void zrandmemberCommand(client *c) {\n    long l;\n    int withscores = 0;\n    robj *zset;\n    listpackEntry ele;\n    if (c->argc >= 3) {\n        if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;\n        if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"withscores\"))) {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return;\n        } else if (c->argc == 4)\n            withscores = 1;\n        zrandmemberWithCountCommand(c, l, withscores);\n        return;\n    }\n    if ((zset = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp]))== NULL ||\n        checkType(c,zset,OBJ_ZSET)) {\n        return;\n    }\n    zsetTypeRandomElement(zset, zsetLength(zset), &ele,NULL);\n    zsetReplyFromListpackEntry(c,&ele);\n}", "target": 1}
{"code": "static void youngcollection (lua_State *L, global_State *g) {\n  GCObject **psurvival;  \n  lua_assert(g->gcstate == GCSpropagate);\n  markold(g, g->survival, g->reallyold);\n  markold(g, g->finobj, g->finobjrold);\n  atomic(L);\n  psurvival = sweepgen(L, g, &g->allgc, g->survival);\n  sweepgen(L, g, psurvival, g->reallyold);\n  g->reallyold = g->old;\n  g->old = *psurvival;  \n  g->survival = g->allgc;  \n  psurvival = sweepgen(L, g, &g->finobj, g->finobjsur);\n  sweepgen(L, g, psurvival, g->finobjrold);\n  g->finobjrold = g->finobjold;\n  g->finobjold = *psurvival;  \n  g->finobjsur = g->finobj;  \n  sweepgen(L, g, &g->tobefnz, NULL);\n  finishgencycle(L, g);\n}", "target": 1}
{"code": "static s32 adpt_i2o_hrt_get(adpt_hba* pHba)\n{\n\tu32 msg[6];\n\tint ret, size = sizeof(i2o_hrt);\n\tdo {\n\t\tif (pHba->hrt == NULL) {\n\t\t\tpHba->hrt = dma_alloc_coherent(&pHba->pDev->dev,\n\t\t\t\t\tsize, &pHba->hrt_pa, GFP_KERNEL);\n\t\t\tif (pHba->hrt == NULL) {\n\t\t\t\tprintk(KERN_CRIT \"%s: Hrt Get failed; Out of memory.\\n\", pHba->name);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\t\tmsg[0]= SIX_WORD_MSG_SIZE| SGL_OFFSET_4;\n\t\tmsg[1]= I2O_CMD_HRT_GET<<24 | HOST_TID<<12 | ADAPTER_TID;\n\t\tmsg[2]= 0;\n\t\tmsg[3]= 0;\n\t\tmsg[4]= (0xD0000000 | size);    \n\t\tmsg[5]= (u32)pHba->hrt_pa;\t\n\t\tif ((ret = adpt_i2o_post_wait(pHba, msg, sizeof(msg),20))) {\n\t\t\tprintk(KERN_ERR \"%s: Unable to get HRT (status=%#10x)\\n\", pHba->name, ret);\n\t\t\treturn ret;\n\t\t}\n\t\tif (pHba->hrt->num_entries * pHba->hrt->entry_len << 2 > size) {\n\t\t\tint newsize = pHba->hrt->num_entries * pHba->hrt->entry_len << 2;\n\t\t\tdma_free_coherent(&pHba->pDev->dev, size,\n\t\t\t\tpHba->hrt, pHba->hrt_pa);\n\t\t\tsize = newsize;\n\t\t\tpHba->hrt = NULL;\n\t\t}\n\t} while(pHba->hrt == NULL);\n\treturn 0;\n}                                                                                                                                       ", "target": 1}
{"code": "  RectangleRequest &operator=(const struct RectangleRequest &req)\n  { \n    memcpy(this,&req,sizeof(struct RectangleRequest));\n    rr_pNext = NULL;\n    return *this;\n  }", "target": 1}
{"code": "static ssize_t write_mem(struct file *file, const char __user *buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tphys_addr_t p = *ppos;\n\tssize_t written, sz;\n\tunsigned long copied;\n\tvoid *ptr;\n\tif (p != *ppos)\n\t\treturn -EFBIG;\n\tif (!valid_phys_addr_range(p, count))\n\t\treturn -EFAULT;\n\twritten = 0;\n#ifdef __ARCH_HAS_NO_PAGE_ZERO_MAPPED\n\tif (p < PAGE_SIZE) {\n\t\tsz = size_inside_page(p, count);\n\t\tbuf += sz;\n\t\tp += sz;\n\t\tcount -= sz;\n\t\twritten += sz;\n\t}\n#endif\n\twhile (count > 0) {\n\t\tsz = size_inside_page(p, count);\n\t\tif (!range_is_allowed(p >> PAGE_SHIFT, sz))\n\t\t\treturn -EPERM;\n\t\tptr = xlate_dev_mem_ptr(p);\n\t\tif (!ptr) {\n\t\t\tif (written)\n\t\t\t\tbreak;\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tcopied = copy_from_user(ptr, buf, sz);\n\t\tunxlate_dev_mem_ptr(p, ptr);\n\t\tif (copied) {\n\t\t\twritten += sz - copied;\n\t\t\tif (written)\n\t\t\t\tbreak;\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tbuf += sz;\n\t\tp += sz;\n\t\tcount -= sz;\n\t\twritten += sz;\n\t}\n\t*ppos += written;\n\treturn written;\n}", "target": 1}
{"code": "acc_ctx_cont(OM_uint32 *minstat,\n\t     gss_buffer_t buf,\n\t     gss_ctx_id_t *ctx,\n\t     gss_buffer_t *responseToken,\n\t     gss_buffer_t *mechListMIC,\n\t     OM_uint32 *negState,\n\t     send_token_flag *return_token)\n{\n\tOM_uint32 ret, tmpmin;\n\tgss_OID supportedMech;\n\tspnego_gss_ctx_id_t sc;\n\tunsigned int len;\n\tunsigned char *ptr, *bufstart;\n\tsc = (spnego_gss_ctx_id_t)*ctx;\n\tret = GSS_S_DEFECTIVE_TOKEN;\n\t*negState = REJECT;\n\t*minstat = 0;\n\tsupportedMech = GSS_C_NO_OID;\n\t*return_token = ERROR_TOKEN_SEND;\n\t*responseToken = *mechListMIC = GSS_C_NO_BUFFER;\n\tptr = bufstart = buf->value;\n#define REMAIN (buf->length - (ptr - bufstart))\n\tif (REMAIN > INT_MAX)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tif (*ptr == HEADER_ID) {\n\t\tret = g_verify_token_header(gss_mech_spnego,\n\t\t\t\t\t    &len, &ptr, 0, REMAIN);\n\t\tif (ret) {\n\t\t\t*minstat = ret;\n\t\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t\t}\n\t}\n\tif (*ptr != (CONTEXT | 0x01)) {\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t}\n\tret = get_negTokenResp(minstat, ptr, REMAIN,\n\t\t\t       negState, &supportedMech,\n\t\t\t       responseToken, mechListMIC);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\tif (*responseToken == GSS_C_NO_BUFFER &&\n\t    *mechListMIC == GSS_C_NO_BUFFER) {\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\tgoto cleanup;\n\t}\n\tif (supportedMech != GSS_C_NO_OID) {\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\tgoto cleanup;\n\t}\n\tsc->firstpass = 0;\n\t*negState = ACCEPT_INCOMPLETE;\n\t*return_token = CONT_TOKEN_SEND;\ncleanup:\n\tif (supportedMech != GSS_C_NO_OID) {\n\t\tgeneric_gss_release_oid(&tmpmin, &supportedMech);\n\t}\n\treturn ret;\n#undef REMAIN\n}", "target": 1}
{"code": "static inline u32 vm_exit_controls_get(struct vcpu_vmx *vmx)\n{\n\treturn vmx->vm_exit_controls_shadow;\n}", "target": 0}
{"code": "callbacks_new_project_activate (GtkMenuItem *menuitem, gpointer user_data)\n{\n\tif (mainProject->last_loaded >= 0) {\n\t\tif (!interface_get_alert_dialog_response (\n\t\t\t_(\"Do you want to close any open layers \"\n\t\t\t\"and start a new project?\"),\n\t\t\t_(\"Starting a new project will cause all currently \"\n\t\t\t\"open layers to be closed. Any unsaved changes \"\n\t\t\t\"will be lost.\"),\n\t\t\tFALSE, NULL, GTK_STOCK_CLOSE, GTK_STOCK_CANCEL))\n\t\t\treturn;\n\t}\n\tgerbv_unload_all_layers (mainProject);\n\tcallbacks_update_layer_tree ();\n\tselection_clear (&screen.selectionInfo);\n\tupdate_selected_object_message (FALSE);\n\tif (mainProject->project) {\n\t    g_free(mainProject->project);\n\t    mainProject->project = NULL;\n\t}\n\trender_refresh_rendered_image_on_screen();\n}", "target": 0}
{"code": "static int do_devinfo_ioctl(struct comedi_device *dev,\n\t\t\t    struct comedi_devinfo __user *arg,\n\t\t\t    struct file *file)\n{\n\tstruct comedi_devinfo devinfo;\n\tconst unsigned minor = iminor(file->f_dentry->d_inode);\n\tstruct comedi_device_file_info *dev_file_info =\n\t    comedi_get_device_file_info(minor);\n\tstruct comedi_subdevice *read_subdev =\n\t    comedi_get_read_subdevice(dev_file_info);\n\tstruct comedi_subdevice *write_subdev =\n\t    comedi_get_write_subdevice(dev_file_info);\n\tmemset(&devinfo, 0, sizeof(devinfo));\n\tdevinfo.version_code = COMEDI_VERSION_CODE;\n\tdevinfo.n_subdevs = dev->n_subdevices;\n\tmemcpy(devinfo.driver_name, dev->driver->driver_name, COMEDI_NAMELEN);\n\tmemcpy(devinfo.board_name, dev->board_name, COMEDI_NAMELEN);\n\tif (read_subdev)\n\t\tdevinfo.read_subdevice = read_subdev - dev->subdevices;\n\telse\n\t\tdevinfo.read_subdevice = -1;\n\tif (write_subdev)\n\t\tdevinfo.write_subdevice = write_subdev - dev->subdevices;\n\telse\n\t\tdevinfo.write_subdevice = -1;\n\tif (copy_to_user(arg, &devinfo, sizeof(struct comedi_devinfo)))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1}
{"code": "vrrp_tfile_end_handler(void)\n{\n\tvrrp_tracked_file_t *tfile = LIST_TAIL_DATA(vrrp_data->vrrp_track_files);\n\tstruct stat statb;\n\tFILE *tf;\n\tint ret;\n\tif (!tfile->file_path) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"No file set for track_file %s - removing\", tfile->fname);\n\t\tfree_list_element(vrrp_data->vrrp_track_files, vrrp_data->vrrp_track_files->tail);\n\t\treturn;\n\t}\n\tif (track_file_init == TRACK_FILE_NO_INIT)\n\t\treturn;\n\tret = stat(tfile->file_path, &statb);\n\tif (!ret) {\n\t\tif (track_file_init == TRACK_FILE_CREATE) {\n\t\t\treturn;\n\t\t}\n\t\tif ((statb.st_mode & S_IFMT) != S_IFREG) {\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Cannot initialise track file %s - it is not a regular file\", tfile->fname);\n\t\t\treturn;\n\t\t}\n\t\tif (reload)\n\t\t\treturn;\n\t}\n\tif (!__test_bit(CONFIG_TEST_BIT, &debug)) {\n\t\tif ((tf = fopen(tfile->file_path, \"w\"))) {\n\t\t\tfprintf(tf, \"%d\\n\", track_file_init_value);\n\t\t\tfclose(tf);\n\t\t}\n\t\telse\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Unable to initialise track file %s\", tfile->fname);\n\t}\n}", "target": 1}
{"code": "void RenderView::OnUndo() {\n  if (!webview())\n    return;\n  webview()->focusedFrame()->executeCommand(WebString::fromUTF8(\"Undo\"));\n  UserMetricsRecordAction(\"Undo\");\n}", "target": 0}
{"code": "static void bpf_adj_branches(struct bpf_prog *prog, u32 pos, u32 delta)\n{\n\tstruct bpf_insn *insn = prog->insnsi;\n\tu32 i, insn_cnt = prog->len;\n\tbool pseudo_call;\n\tu8 code;\n\tint off;\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tcode = insn->code;\n\t\tif (BPF_CLASS(code) != BPF_JMP)\n\t\t\tcontinue;\n\t\tif (BPF_OP(code) == BPF_EXIT)\n\t\t\tcontinue;\n\t\tif (BPF_OP(code) == BPF_CALL) {\n\t\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\t\tpseudo_call = true;\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tpseudo_call = false;\n\t\t}\n\t\toff = pseudo_call ? insn->imm : insn->off;\n\t\tif (i < pos && i + off + 1 > pos)\n\t\t\toff += delta;\n\t\telse if (i > pos + delta && i + off + 1 <= pos + delta)\n\t\t\toff -= delta;\n\t\tif (pseudo_call)\n\t\t\tinsn->imm = off;\n\t\telse\n\t\t\tinsn->off = off;\n\t}\n}", "target": 1}
{"code": "static void ssdp_recv(int sd)\n{\n\tssize_t len;\n\tstruct sockaddr sa;\n\tsocklen_t salen;\n\tchar buf[MAX_PKT_SIZE];\n\tmemset(buf, 0, sizeof(buf));\n\tlen = recvfrom(sd, buf, sizeof(buf), MSG_DONTWAIT, &sa, &salen);\n\tif (len > 0) {\n\t\tbuf[len] = 0;\n\t\tif (sa.sa_family != AF_INET)\n\t\t\treturn;\n\t\tif (strstr(buf, \"M-SEARCH *\")) {\n\t\t\tsize_t i;\n\t\t\tchar *ptr, *type;\n\t\t\tstruct ifsock *ifs;\n\t\t\tstruct sockaddr_in *sin = (struct sockaddr_in *)&sa;\n\t\t\tifs = find_outbound(&sa);\n\t\t\tif (!ifs) {\n\t\t\t\tlogit(LOG_DEBUG, \"No matching socket for client %s\", inet_ntoa(sin->sin_addr));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlogit(LOG_DEBUG, \"Matching socket for client %s\", inet_ntoa(sin->sin_addr));\n\t\t\ttype = strcasestr(buf, \"\\r\\nST:\");\n\t\t\tif (!type) {\n\t\t\t\tlogit(LOG_DEBUG, \"No Search Type (ST:) found in M-SEARCH *, assuming \" SSDP_ST_ALL);\n\t\t\t\ttype = SSDP_ST_ALL;\n\t\t\t\tsend_message(ifs, type, &sa);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttype = strchr(type, ':');\n\t\t\tif (!type)\n\t\t\t\treturn;\n\t\t\ttype++;\n\t\t\twhile (isspace(*type))\n\t\t\t\ttype++;\n\t\t\tptr = strstr(type, \"\\r\\n\");\n\t\t\tif (!ptr)\n\t\t\t\treturn;\n\t\t\t*ptr = 0;\n\t\t\tfor (i = 0; supported_types[i]; i++) {\n\t\t\t\tif (!strcmp(supported_types[i], type)) {\n\t\t\t\t\tlogit(LOG_DEBUG, \"M-SEARCH * ST: %s from %s port %d\", type,\n\t\t\t\t\t      inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\t\t\t\tsend_message(ifs, type, &sa);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlogit(LOG_DEBUG, \"M-SEARCH * for unsupported ST: %s from %s\", type,\n\t\t\t      inet_ntoa(sin->sin_addr));\n\t\t}\n\t}\n}", "target": 1}
{"code": "MagickExport MagickBooleanType LinearStretchImage(Image *image,\n  const double black_point,const double white_point,ExceptionInfo *exception)\n{\n#define LinearStretchImageTag  \"LinearStretch/Image\"\n  CacheView\n    *image_view;\n  double\n    *histogram,\n    intensity;\n  MagickBooleanType\n    status;\n  ssize_t\n    black,\n    white,\n    y;\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  histogram=(double *) AcquireQuantumMemory(MaxMap+1UL,sizeof(*histogram));\n  if (histogram == (double *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  (void) ResetMagickMemory(histogram,0,(MaxMap+1)*sizeof(*histogram));\n  image_view=AcquireVirtualCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict p;\n    register ssize_t\n      x;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      intensity=GetPixelIntensity(image,p);\n      histogram[ScaleQuantumToMap(ClampToQuantum(intensity))]++;\n      p+=GetPixelChannels(image);\n    }\n  }\n  image_view=DestroyCacheView(image_view);\n  intensity=0.0;\n  for (black=0; black < (ssize_t) MaxMap; black++)\n  {\n    intensity+=histogram[black];\n    if (intensity >= black_point)\n      break;\n  }\n  intensity=0.0;\n  for (white=(ssize_t) MaxMap; white != 0; white--)\n  {\n    intensity+=histogram[white];\n    if (intensity >= white_point)\n      break;\n  }\n  histogram=(double *) RelinquishMagickMemory(histogram);\n  status=LevelImage(image,(double) ScaleMapToQuantum((MagickRealType) black),\n    (double) ScaleMapToQuantum((MagickRealType) white),1.0,exception);\n  return(status);\n}", "target": 0}
{"code": "static int match_func(struct libmnt_fs *fs,\n\t\t      void *data __attribute__ ((__unused__)))\n{\n\tint rc = flags & FL_INVERT ? 1 : 0;\n\tconst char *m;\n\tvoid *md;\n\tm = get_match(COL_FSTYPE);\n\tif (m && !mnt_fs_match_fstype(fs, m))\n\t\treturn rc;\n\tm = get_match(COL_OPTIONS);\n\tif (m && !mnt_fs_match_options(fs, m))\n\t\treturn rc;\n\tmd = get_match_data(COL_MAJMIN);\n\tif (md && mnt_fs_get_devno(fs) != *((dev_t *) md))\n\t\treturn rc;\n\tm = get_match(COL_TARGET);\n\tif (m && !mnt_fs_match_target(fs, m, cache))\n\t\treturn rc;\n\tm = get_match(COL_SOURCE);\n\tif (m && !mnt_fs_match_source(fs, m, cache))\n\t\treturn rc;\n\tif ((flags & FL_DF) && !(flags & FL_ALL)) {\n\t\tconst char *type = mnt_fs_get_fstype(fs);\n\t\tif (type && strstr(type, \"tmpfs\"))\t\n\t\t\treturn !rc;\n\t\tif (mnt_fs_is_pseudofs(fs))\n\t\t\treturn rc;\n\t}\n\tif ((flags & FL_REAL) && mnt_fs_is_pseudofs(fs))\n\t    return rc;\n\tif ((flags & FL_PSEUDO) && !mnt_fs_is_pseudofs(fs))\n\t    return rc;\n\tif ((flags & FL_SHADOWED)) {\n\t\tstruct libmnt_table *tb = NULL;\n\t\tmnt_fs_get_table(fs, &tb);\n\t\tif (tb && mnt_table_over_fs(tb, fs, NULL) != 0)\n\t\t\treturn rc;\n\t}\n\tif ((flags & FL_DELETED) && !mnt_fs_is_deleted(fs))\n\t\treturn rc;\n\treturn !rc;\n}", "target": 1}
{"code": "static void dnxhd_setup_threads_slices(DNXHDEncContext *ctx)\n{\n    int mb_y, mb_x;\n    int offset = 0;\n    for (mb_y = 0; mb_y < ctx->m.mb_height; mb_y++) {\n        int thread_size;\n        ctx->slice_offs[mb_y] = offset;\n        ctx->slice_size[mb_y] = 0;\n        for (mb_x = 0; mb_x < ctx->m.mb_width; mb_x++) {\n            unsigned mb = mb_y * ctx->m.mb_width + mb_x;\n            ctx->slice_size[mb_y] += ctx->mb_bits[mb];\n        }\n        ctx->slice_size[mb_y] = (ctx->slice_size[mb_y]+31)&~31;\n        ctx->slice_size[mb_y] >>= 3;\n        thread_size = ctx->slice_size[mb_y];\n        offset += thread_size;\n    }\n}", "target": 0}
{"code": "values_equal_for_ipcp_p (tree x, tree y)\n{\n  gcc_checking_assert (x != NULL_TREE && y != NULL_TREE);\n  if (x == y)\n    return true;\n  if (TREE_CODE (x) ==  ADDR_EXPR\n      && TREE_CODE (y) ==  ADDR_EXPR\n      && TREE_CODE (TREE_OPERAND (x, 0)) == CONST_DECL\n      && TREE_CODE (TREE_OPERAND (y, 0)) == CONST_DECL)\n    return operand_equal_p (DECL_INITIAL (TREE_OPERAND (x, 0)),\n\t\t\t    DECL_INITIAL (TREE_OPERAND (y, 0)), 0);\n  else\n    return operand_equal_p (x, y, 0);\n}", "target": 0}
{"code": "__perf_event_ctx_lock_double(struct perf_event *group_leader,\n\t\t\t     struct perf_event_context *ctx)\n{\n\tstruct perf_event_context *gctx;\nagain:\n\trcu_read_lock();\n\tgctx = READ_ONCE(group_leader->ctx);\n\tif (!atomic_inc_not_zero(&gctx->refcount)) {\n\t\trcu_read_unlock();\n\t\tgoto again;\n\t}\n\trcu_read_unlock();\n\tmutex_lock_double(&gctx->mutex, &ctx->mutex);\n\tif (group_leader->ctx != gctx) {\n\t\tmutex_unlock(&ctx->mutex);\n\t\tmutex_unlock(&gctx->mutex);\n\t\tput_ctx(gctx);\n\t\tgoto again;\n\t}\n\treturn gctx;\n}", "target": 0}
{"code": "ofpacts_parse(char *str, const struct ofpact_parse_params *pp,\n              bool allow_instructions, enum ofpact_type outer_action)\n{\n    if (pp->depth >= MAX_OFPACT_PARSE_DEPTH) {\n        return xstrdup(\"Action nested too deeply\");\n    }\n    CONST_CAST(struct ofpact_parse_params *, pp)->depth++;\n    uint32_t orig_size = pp->ofpacts->size;\n    char *error = ofpacts_parse__(str, pp, allow_instructions, outer_action);\n    if (error) {\n        pp->ofpacts->size = orig_size;\n    }\n    CONST_CAST(struct ofpact_parse_params *, pp)->depth--;\n    return error;\n}", "target": 0}
{"code": "file_transfer_t *imcb_file_send_start(struct im_connection *ic, char *handle, char *file_name, size_t file_size)\n{\n\tbee_t *bee = ic->bee;\n\tbee_user_t *bu = bee_user_by_handle(bee, ic, handle);\n\tif (bee->ui->ft_in_start) {\n\t\treturn bee->ui->ft_in_start(bee, bu, file_name, file_size);\n\t} else {\n\t\treturn NULL;\n\t}\n}", "target": 1}
{"code": "bool AuthUnknownAuthorizeHandler::verify_authorizer(CephContext *cct, KeyStore *keys,\n\t\t\t\t\t\t bufferlist& authorizer_data, bufferlist& authorizer_reply,\n\t\t\t\t\t\t EntityName& entity_name, uint64_t& global_id, AuthCapsInfo& caps_info, CryptoKey& session_key,\nuint64_t *auid)\n{\n  return true;\n}", "target": 1}
{"code": "  void resizeAndFillTable(\n      HeaderTable& table, HPACKHeader& header, uint32_t newMax,\n      uint32_t fillCount) {\n    uint32_t newCapacity = header.bytes() * newMax;\n    resizeTable(table, newCapacity, newMax);\n    for (size_t i = 0; i <= fillCount; ++i) {\n      EXPECT_EQ(table.add(header), true);\n    }\n    EXPECT_EQ(table.size(), newMax);\n    EXPECT_EQ(table.bytes(), newCapacity);\n  }", "target": 0}
{"code": "unique_ptr<IOBuf> IOBuf::takeOwnership(\n    void* buf,\n    std::size_t capacity,\n    std::size_t offset,\n    std::size_t length,\n    FreeFunction freeFn,\n    void* userData,\n    bool freeOnError,\n    TakeOwnershipOption option) {\n  if (capacity > kMaxIOBufSize) {\n    throw_exception<std::bad_alloc>();\n  }\n  DCHECK(\n      !userData || (userData && freeFn) ||\n      (userData && !freeFn && (option == TakeOwnershipOption::STORE_SIZE)));\n  HeapFullStorage* storage = nullptr;\n  auto rollback = makeGuard([&] {\n    if (storage) {\n      free(storage);\n    }\n    takeOwnershipError(freeOnError, buf, freeFn, userData);\n  });\n  size_t requiredStorage = sizeof(HeapFullStorage);\n  size_t mallocSize = goodMallocSize(requiredStorage);\n  storage = static_cast<HeapFullStorage*>(checkedMalloc(mallocSize));\n  new (&storage->hs.prefix)\n      HeapPrefix(kIOBufInUse | kSharedInfoInUse, mallocSize);\n  new (&storage->shared)\n      SharedInfo(freeFn, userData, true );\n  auto result = unique_ptr<IOBuf>(new (&storage->hs.buf) IOBuf(\n      InternalConstructor(),\n      packFlagsAndSharedInfo(0, &storage->shared),\n      static_cast<uint8_t*>(buf),\n      capacity,\n      static_cast<uint8_t*>(buf) + offset,\n      length));\n  rollback.dismiss();\n  if (io_buf_alloc_cb) {\n    io_buf_alloc_cb(storage, mallocSize);\n    if (userData && !freeFn && (option == TakeOwnershipOption::STORE_SIZE)) {\n      io_buf_alloc_cb(buf, capacity);\n    }\n  }\n  return result;\n}", "target": 0}
{"code": "processBatchMultiRuleset(batch_t *pBatch)\n{\n\truleset_t *currRuleset;\n\tbatch_t snglRuleBatch;\n\tint i;\n\tint iStart;\t\n\tint iNew;\t\n\tDEFiRet;\n\tCHKiRet(batchInit(&snglRuleBatch, pBatch->nElem));\n\tsnglRuleBatch.pbShutdownImmediate = pBatch->pbShutdownImmediate;\n\twhile(1) { \n\t\tfor(iStart = 0 ; iStart < pBatch->nElem && pBatch->pElem[iStart].state == BATCH_STATE_DISC ; ++iStart)\n\t\t\t;\n\t\tif(iStart == pBatch->nElem)\n\t\t\tFINALIZE; \n\t\tcurrRuleset = batchElemGetRuleset(pBatch, iStart);\n\t\tiNew = 0;\n\t\tfor(i = iStart ; i < pBatch->nElem ; ++i) {\n\t\t\tif(batchElemGetRuleset(pBatch, i) == currRuleset) {\n\t\t\t\tbatchCopyElem(&(snglRuleBatch.pElem[iNew++]), &(pBatch->pElem[i]));\n\t\t\t\tpBatch->pElem[i].state = BATCH_STATE_DISC;\n\t\t\t}\n\t\t}\n\t\tsnglRuleBatch.nElem = iNew; \n\t\tbatchSetSingleRuleset(&snglRuleBatch, 1);\n\t\tprocessBatch(&snglRuleBatch);\n\t}\n\tbatchFree(&snglRuleBatch);\nfinalize_it:\n\tRETiRet;\n}", "target": 1}
{"code": "read_and_discard_scanlines(j_decompress_ptr cinfo, JDIMENSION num_lines)\n{\n  JDIMENSION n;\n  my_master_ptr master = (my_master_ptr)cinfo->master;\n  void (*color_convert) (j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n                         JDIMENSION input_row, JSAMPARRAY output_buf,\n                         int num_rows) = NULL;\n  void (*color_quantize) (j_decompress_ptr cinfo, JSAMPARRAY input_buf,\n                          JSAMPARRAY output_buf, int num_rows) = NULL;\n  void (*post_process_data) (j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n                             JDIMENSION *in_row_group_ctr,\n                             JDIMENSION in_row_groups_avail,\n                             JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,\n                             JDIMENSION out_rows_avail) = NULL;\n  if (cinfo->cconvert && cinfo->cconvert->color_convert) {\n    color_convert = cinfo->cconvert->color_convert;\n    cinfo->cconvert->color_convert = noop_convert;\n  }\n  if (cinfo->cquantize && cinfo->cquantize->color_quantize) {\n    color_quantize = cinfo->cquantize->color_quantize;\n    cinfo->cquantize->color_quantize = noop_quantize;\n  }\n  if (master->using_merged_upsample && cinfo->post &&\n      cinfo->post->post_process_data) {\n    post_process_data = cinfo->post->post_process_data;\n    cinfo->post->post_process_data = noop_post_process;\n  }\n  for (n = 0; n < num_lines; n++)\n    jpeg_read_scanlines(cinfo, NULL, 1);\n  if (color_convert)\n    cinfo->cconvert->color_convert = color_convert;\n  if (color_quantize)\n    cinfo->cquantize->color_quantize = color_quantize;\n  if (post_process_data)\n    cinfo->post->post_process_data = post_process_data;\n}", "target": 0}
{"code": "selaGetCombName(SELA    *sela,\n                l_int32  size,\n                l_int32  direction)\n{\nchar    *selname;\nchar     combname[L_BUF_SIZE];\nl_int32  i, nsels, sx, sy, found;\nSEL     *sel;\n    PROCNAME(\"selaGetCombName\");\n    if (!sela)\n        return (char *)ERROR_PTR(\"sela not defined\", procName, NULL);\n    if (direction != L_HORIZ && direction != L_VERT)\n        return (char *)ERROR_PTR(\"invalid direction\", procName, NULL);\n    if (direction == L_HORIZ)\n        snprintf(combname, L_BUF_SIZE, \"sel_comb_%dh\", size);\n    else  \n        snprintf(combname, L_BUF_SIZE, \"sel_comb_%dv\", size);\n    found = FALSE;\n    nsels = selaGetCount(sela);\n    for (i = 0; i < nsels; i++) {\n        sel = selaGetSel(sela, i);\n        selGetParameters(sel, &sy, &sx, NULL, NULL);\n        if (sy != 1 && sx != 1)  \n            continue;\n        selname = selGetName(sel);\n        if (!strcmp(selname, combname)) {\n            found = TRUE;\n            break;\n        }\n    }\n    if (found)\n        return stringNew(selname);\n    else\n        return (char *)ERROR_PTR(\"sel not found\", procName, NULL);\n}", "target": 1}
{"code": "static void my_gballoc_free(void* ptr)\n{\n    free(ptr);\n}", "target": 0}
{"code": "static const ut8 *parse_die(const ut8 *buf, const ut8 *buf_end, RzBinDwarfDebugInfo *info, RzBinDwarfAbbrevDecl *abbrev,\n\tRzBinDwarfCompUnitHdr *hdr, RzBinDwarfDie *die, const ut8 *debug_str, size_t debug_str_len, bool big_endian) {\n\tsize_t i;\n\tconst char *comp_dir = NULL;\n\tut64 line_info_offset = UT64_MAX;\n\tfor (i = 0; i < abbrev->count - 1; i++) {\n\t\tmemset(&die->attr_values[i], 0, sizeof(die->attr_values[i]));\n\t\tbuf = parse_attr_value(buf, buf_end - buf, &abbrev->defs[i],\n\t\t\t&die->attr_values[i], hdr, debug_str, debug_str_len, big_endian);\n\t\tRzBinDwarfAttrValue *attribute = &die->attr_values[i];\n\t\tif (attribute->attr_name == DW_AT_comp_dir && (attribute->attr_form == DW_FORM_strp || attribute->attr_form == DW_FORM_string) && attribute->string.content) {\n\t\t\tcomp_dir = attribute->string.content;\n\t\t}\n\t\tif (attribute->attr_name == DW_AT_stmt_list) {\n\t\t\tif (attribute->kind == DW_AT_KIND_CONSTANT) {\n\t\t\t\tline_info_offset = attribute->uconstant;\n\t\t\t} else if (attribute->kind == DW_AT_KIND_REFERENCE) {\n\t\t\t\tline_info_offset = attribute->reference;\n\t\t\t}\n\t\t}\n\t\tdie->count++;\n\t}\n\tif (comp_dir && line_info_offset != UT64_MAX) {\n\t\tchar *name = strdup(comp_dir);\n\t\tif (name) {\n\t\t\tif (!ht_up_insert(info->line_info_offset_comp_dir, line_info_offset, name)) {\n\t\t\t\tfree(name);\n\t\t\t}\n\t\t}\n\t}\n\treturn buf;\n}", "target": 1}
{"code": "void GLES2DecoderImpl::DeleteRenderbuffersHelper(\n    GLsizei n, const GLuint* client_ids) {\n  for (GLsizei ii = 0; ii < n; ++ii) {\n    RenderbufferManager::RenderbufferInfo* info =\n        GetRenderbufferInfo(client_ids[ii]);\n    if (info) {\n      GLuint service_id = info->service_id();\n      glDeleteRenderbuffersEXT(1, &service_id);\n      RemoveRenderbufferInfo(client_ids[ii]);\n    }\n  }\n}", "target": 0}
{"code": "mp_dss_print(netdissect_options *ndo,\n             const u_char *opt, u_int opt_len, u_char flags)\n{\n        const struct mp_dss *mdss = (const struct mp_dss *) opt;\n        if ((opt_len != mp_dss_len(mdss, 1) &&\n             opt_len != mp_dss_len(mdss, 0)) || flags & TH_SYN)\n                return 0;\n        if (mdss->flags & MP_DSS_F)\n                ND_PRINT((ndo, \" fin\"));\n        opt += 4;\n        if (mdss->flags & MP_DSS_A) {\n                ND_PRINT((ndo, \" ack \"));\n                if (mdss->flags & MP_DSS_a) {\n                        ND_PRINT((ndo, \"%\" PRIu64, EXTRACT_64BITS(opt)));\n                        opt += 8;\n                } else {\n                        ND_PRINT((ndo, \"%u\", EXTRACT_32BITS(opt)));\n                        opt += 4;\n                }\n        }\n        if (mdss->flags & MP_DSS_M) {\n                ND_PRINT((ndo, \" seq \"));\n                if (mdss->flags & MP_DSS_m) {\n                        ND_PRINT((ndo, \"%\" PRIu64, EXTRACT_64BITS(opt)));\n                        opt += 8;\n                } else {\n                        ND_PRINT((ndo, \"%u\", EXTRACT_32BITS(opt)));\n                        opt += 4;\n                }\n                ND_PRINT((ndo, \" subseq %u\", EXTRACT_32BITS(opt)));\n                opt += 4;\n                ND_PRINT((ndo, \" len %u\", EXTRACT_16BITS(opt)));\n                opt += 2;\n                if (opt_len == mp_dss_len(mdss, 1))\n                        ND_PRINT((ndo, \" csum 0x%x\", EXTRACT_16BITS(opt)));\n        }\n        return 1;\n}", "target": 1}
{"code": "parse_range(char *str, size_t file_sz, int *nranges)\n{\n\tstatic struct range\t ranges[MAX_RANGES];\n\tint\t\t\t i = 0;\n\tchar\t\t\t*p, *q;\n\tif ((p = strchr(str, '=')) == NULL)\n\t\treturn (NULL);\n\t*p++ = '\\0';\n\tif (strcmp(str, \"bytes\") != 0)\n\t\treturn (NULL);\n\twhile ((q = strchr(p, ',')) != NULL) {\n\t\t*q++ = '\\0';\n\t\tif (parse_range_spec(p, file_sz, &ranges[i]) == 0)\n\t\t\tcontinue;\n\t\ti++;\n\t\tif (i == MAX_RANGES)\n\t\t\treturn (NULL);\n\t\tp = q;\n\t}\n\tif (parse_range_spec(p, file_sz, &ranges[i]) != 0)\n\t\ti++;\n\t*nranges = i;\n\treturn (i ? ranges : NULL);\n}", "target": 1}
{"code": "void DCR_CLASS dcr_cam_xyz_coeff (DCRAW* p, double cam_xyz[4][3])\n{\n\tdouble cam_rgb[4][3], inverse[4][3], num;\n\tint i, j, k;\n\tfor (i=0; i < p->colors; i++)\t\t\n\t\tfor (j=0; j < 3; j++)\n\t\t\tfor (cam_rgb[i][j] = k=0; k < 3; k++)\n\t\t\t\tcam_rgb[i][j] += cam_xyz[i][k] * xyz_rgb[k][j];\n\tfor (i=0; i < p->colors; i++) {\t\t\n\t\tfor (num=j=0; j < 3; j++)\t\t\n\t\t\tnum += cam_rgb[i][j];\n\t\tfor (j=0; j < 3; j++)\n\t\t\tcam_rgb[i][j] /= num;\n\t\tp->pre_mul[i] = 1 / (float)num;\n\t}\n\tdcr_pseudoinverse (cam_rgb, inverse, p->colors);\n\tfor (p->raw_color = i=0; i < 3; i++)\n\t\tfor (j=0; j < p->colors; j++)\n\t\t\tp->rgb_cam[i][j] = (float)inverse[j][i];\n}", "target": 1}
{"code": "double AccessibilityUIElement::clickPointY()\n{\n    return 0.0f;\n}", "target": 0}
{"code": "mysql_list_processes(MYSQL *mysql)\n{\n  MYSQL_DATA *fields;\n  uint field_count;\n  uchar *pos;\n  DBUG_ENTER(\"mysql_list_processes\");\n  LINT_INIT(fields);\n  if (simple_command(mysql,COM_PROCESS_INFO,0,0,0))\n    DBUG_RETURN(0);\n  free_old_query(mysql);\n  pos=(uchar*) mysql->net.read_pos;\n  field_count=(uint) net_field_length(&pos);\n  if (!(fields = (*mysql->methods->read_rows)(mysql,(MYSQL_FIELD*) 0,\n\t\t\t\t\t      protocol_41(mysql) ? 7 : 5)))\n    DBUG_RETURN(NULL);\n  if (!(mysql->fields=unpack_fields(mysql, fields,&mysql->field_alloc,field_count,0,\n\t\t\t\t    mysql->server_capabilities)))\n    DBUG_RETURN(0);\n  mysql->status=MYSQL_STATUS_GET_RESULT;\n  mysql->field_count=field_count;\n  DBUG_RETURN(mysql_store_result(mysql));\n}", "target": 0}
{"code": "  static Address js_entry_sp(ThreadLocalTop* thread) {\n    return thread->js_entry_sp_;\n  }", "target": 0}
{"code": "SQLWCHAR* _multi_string_alloc_and_expand( LPCSTR in )\n{\n    SQLWCHAR *chr;\n    int len = 0;\n    if ( !in )\n    {\n        return in;\n    }\n    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )\n    {\n        len ++;\n    }\n    chr = malloc(sizeof( SQLWCHAR ) * ( len + 2 ));\n    len = 0;\n    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )\n    {\n        chr[ len ] = in[ len ];\n        len ++;\n    }\n    chr[ len ++ ] = 0;\n    chr[ len ++ ] = 0;\n    return chr;\n}", "target": 1}
{"code": "SQLiteDatabase::SQLiteDatabase()\n    : db_(nullptr),\n      page_size_(-1),\n      transaction_in_progress_(false),\n      opening_thread_(0),\n      open_error_(SQLITE_ERROR),\n      open_error_message_(),\n      last_changes_count_(0) {\n}", "target": 0}
{"code": "static inline bool siphash_key_is_zero(const siphash_key_t *key)\n{\n\treturn !(key->key[0] | key->key[1]);\n}", "target": 0}
{"code": "void deletesuccessor(file_t **existing, file_t *duplicate, int matchconfirmed,\n      int (*comparef)(file_t *f1, file_t *f2), struct log_info *loginfo)\n{\n  file_t *to_keep;\n  file_t *to_delete;\n  if (comparef(duplicate, *existing) >= 0)\n  {\n    to_keep = *existing;\n    to_delete = duplicate;\n  }\n  else\n  {\n    to_keep = duplicate;\n    to_delete = *existing;\n    *existing = duplicate;\n  }\n  if (!ISFLAG(flags, F_HIDEPROGRESS)) fprintf(stderr, \"\\r%40s\\r\", \" \");\n  if (loginfo)\n    log_begin_set(loginfo);\n  printf(\"   [+] %s\\n\", to_keep->d_name);\n  if (loginfo)\n    log_file_remaining(loginfo, to_keep->d_name);\n  if (matchconfirmed)\n  {\n    if (remove(to_delete->d_name) == 0) {\n      printf(\"   [-] %s\\n\", to_delete->d_name);\n      if (loginfo)\n        log_file_deleted(loginfo, to_delete->d_name);\n    } else {\n      printf(\"   [!] %s \", to_delete->d_name);\n      printf(\"-- unable to delete file!\\n\");\n      if (loginfo)\n        log_file_remaining(loginfo, to_delete->d_name);\n    }\n  }\n  else\n  {\n    printf(\"   [!] %s\\n\", to_delete->d_name);\n    printf(\" -- unable to confirm match; file not deleted!\\n\");\n    if (loginfo)\n      log_file_remaining(loginfo, to_delete->d_name);\n  }\n  if (loginfo)\n    log_end_set(loginfo);\n  printf(\"\\n\");\n}", "target": 1}
{"code": "flatpak_proxy_client_finalize (GObject *object)\n{\n  FlatpakProxyClient *client = FLATPAK_PROXY_CLIENT (object);\n  client->proxy->clients = g_list_remove (client->proxy->clients, client);\n  g_clear_object (&client->proxy);\n  g_byte_array_free (client->auth_buffer, TRUE);\n  g_hash_table_destroy (client->rewrite_reply);\n  g_hash_table_destroy (client->get_owner_reply);\n  g_hash_table_destroy (client->unique_id_policy);\n  free_side (&client->client_side);\n  free_side (&client->bus_side);\n  G_OBJECT_CLASS (flatpak_proxy_client_parent_class)->finalize (object);\n}", "target": 0}
{"code": "static struct pid *good_sigevent(sigevent_t * event)\n{\n\tstruct task_struct *rtn = current->group_leader;\n\tif ((event->sigev_notify & SIGEV_THREAD_ID ) &&\n\t\t(!(rtn = find_task_by_vpid(event->sigev_notify_thread_id)) ||\n\t\t !same_thread_group(rtn, current) ||\n\t\t (event->sigev_notify & ~SIGEV_THREAD_ID) != SIGEV_SIGNAL))\n\t\treturn NULL;\n\tif (((event->sigev_notify & ~SIGEV_THREAD_ID) != SIGEV_NONE) &&\n\t    ((event->sigev_signo <= 0) || (event->sigev_signo > SIGRTMAX)))\n\t\treturn NULL;\n\treturn task_pid(rtn);\n}", "target": 1}
{"code": "MagickExport MemoryInfo *AcquireVirtualMemory(const size_t count,\n  const size_t quantum)\n{\n  MemoryInfo\n    *memory_info;\n  size_t\n    extent;\n  if (CheckMemoryOverflow(count,quantum) != MagickFalse)\n    return((MemoryInfo *) NULL);\n  memory_info=(MemoryInfo *) MagickAssumeAligned(AcquireAlignedMemory(1,\n    sizeof(*memory_info)));\n  if (memory_info == (MemoryInfo *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(memory_info,0,sizeof(*memory_info));\n  extent=count*quantum;\n  memory_info->length=extent;\n  memory_info->signature=MagickCoreSignature;\n  if (AcquireMagickResource(MemoryResource,extent) != MagickFalse)\n    {\n      memory_info->blob=AcquireAlignedMemory(1,extent);\n      if (memory_info->blob != NULL)\n        {\n          memory_info->type=AlignedVirtualMemory;\n          return(memory_info);\n        }\n    }\n  RelinquishMagickResource(MemoryResource,extent);\n  if (AcquireMagickResource(MapResource,extent) != MagickFalse)\n    {\n      memory_info->blob=MapBlob(-1,IOMode,0,extent);\n      if (memory_info->blob != NULL)\n        {\n          memory_info->type=MapVirtualMemory;\n          return(memory_info);\n        }\n      if (AcquireMagickResource(DiskResource,extent) != MagickFalse)\n        {\n          int\n            file;\n          file=AcquireUniqueFileResource(memory_info->filename);\n          if (file != -1)\n            {\n              MagickOffsetType\n                offset;\n              offset=(MagickOffsetType) lseek(file,extent-1,SEEK_SET);\n              if ((offset == (MagickOffsetType) (extent-1)) &&\n                  (write(file,\"\",1) == 1))\n                {\n                  memory_info->blob=MapBlob(file,IOMode,0,extent);\n                  if (memory_info->blob != NULL)\n                    {\n                      (void) close(file);\n                      memory_info->type=MapVirtualMemory;\n                      return(memory_info);\n                    }\n                }\n              (void) close(file);\n              (void) RelinquishUniqueFileResource(memory_info->filename);\n              *memory_info->filename = '\\0';\n            }\n        }\n      RelinquishMagickResource(DiskResource,extent);\n    }\n  RelinquishMagickResource(MapResource,extent);\n  if (memory_info->blob == NULL)\n    {\n      memory_info->blob=AcquireMagickMemory(extent);\n      if (memory_info->blob != NULL)\n        memory_info->type=UnalignedVirtualMemory;\n    }\n  if (memory_info->blob == NULL)\n    memory_info=RelinquishVirtualMemory(memory_info);\n  return(memory_info);\n}", "target": 1}
{"code": "char *suhosin_encrypt_single_cookie(char *name, int name_len, char *value, int value_len, char *key TSRMLS_DC)\n{\n\tchar buffer[4096];\n    char buffer2[4096];\n\tchar *buf = buffer, *buf2 = buffer2, *d, *d_url;\n    int l;\n\tif (name_len > sizeof(buffer)-2) {\n\t\tbuf = estrndup(name, name_len);\n\t} else {\n\t\tmemcpy(buf, name, name_len);\n\t\tbuf[name_len] = 0;\n\t}\n\tname_len = php_url_decode(buf, name_len);\n    normalize_varname(buf);\n    name_len = strlen(buf);\n\tif (SUHOSIN_G(cookie_plainlist)) {\n\t\tif (zend_hash_exists(SUHOSIN_G(cookie_plainlist), buf, name_len+1)) {\nencrypt_return_plain:\n\t\t\tif (buf != buffer) {\n\t\t\t\tefree(buf);\n\t\t\t}\n\t\t\treturn estrndup(value, value_len);\n\t\t}\n\t} else if (SUHOSIN_G(cookie_cryptlist)) {\n\t\tif (!zend_hash_exists(SUHOSIN_G(cookie_cryptlist), buf, name_len+1)) {\n\t\t\tgoto encrypt_return_plain;\n\t\t}\n\t}\n\tif (strlen(value) <= sizeof(buffer2)-2) {\n\t\tmemcpy(buf2, value, value_len);\n\t\tbuf2[value_len] = 0;\n\t} else {\n\t\tbuf2 = estrndup(value, value_len);\n\t}\n\tvalue_len = php_url_decode(buf2, value_len);\n\td = suhosin_encrypt_string(buf2, value_len, buf, name_len, key TSRMLS_CC);\n\td_url = php_url_encode(d, strlen(d), &l);\n\tefree(d);\n    if (buf != buffer) {\n\t\tefree(buf);\n\t}\n    if (buf2 != buffer2) {\n\t\tefree(buf2);\n\t}\n\treturn d_url;\n}", "target": 1}
{"code": "TEST_P(RBACIntegrationTest, PathIgnoreCase) {\n  config_helper_.addFilter(RBAC_CONFIG_WITH_PATH_IGNORE_CASE_MATCH);\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  const std::vector<std::string> paths{\"/ignore_case\", \"/IGNORE_CASE\", \"/ignore_CASE\"};\n  for (const auto& path : paths) {\n    auto response = codec_client_->makeRequestWithBody(\n        Http::TestRequestHeaderMapImpl{\n            {\":method\", \"POST\"},\n            {\":path\", path},\n            {\":scheme\", \"http\"},\n            {\":authority\", \"host\"},\n            {\"x-forwarded-for\", \"10.0.0.1\"},\n        },\n        1024);\n    waitForNextUpstreamRequest();\n    upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}}, true);\n    response->waitForEndStream();\n    ASSERT_TRUE(response->complete());\n    EXPECT_EQ(\"200\", response->headers().getStatusValue());\n  }\n}", "target": 0}
{"code": "lys_restr_dup(struct lys_module *mod, struct lys_restr *old, int size, int shallow, struct unres_schema *unres)\n{\n    struct lys_restr *result;\n    int i;\n    if (!size) {\n        return NULL;\n    }\n    result = calloc(size, sizeof *result);\n    LY_CHECK_ERR_RETURN(!result, LOGMEM(mod->ctx), NULL);\n    for (i = 0; i < size; i++) {\n        result[i].ext_size = old[i].ext_size;\n        lys_ext_dup(mod->ctx, mod, old[i].ext, old[i].ext_size, &result[i], LYEXT_PAR_RESTR, &result[i].ext, shallow, unres);\n        result[i].expr = lydict_insert(mod->ctx, old[i].expr, 0);\n        result[i].dsc = lydict_insert(mod->ctx, old[i].dsc, 0);\n        result[i].ref = lydict_insert(mod->ctx, old[i].ref, 0);\n        result[i].eapptag = lydict_insert(mod->ctx, old[i].eapptag, 0);\n        result[i].emsg = lydict_insert(mod->ctx, old[i].emsg, 0);\n    }\n    return result;\n}", "target": 1}
{"code": "static void nfs_set_open_stateid_locked(struct nfs4_state *state, nfs4_stateid *stateid, int open_flags)\n{\n\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) == 0)\n\t\tmemcpy(state->stateid.data, stateid->data, sizeof(state->stateid.data));\n\tmemcpy(state->open_stateid.data, stateid->data, sizeof(state->open_stateid.data));\n\tswitch (open_flags) {\n\t\tcase FMODE_READ:\n\t\t\tset_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tset_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tset_bit(NFS_O_RDWR_STATE, &state->flags);\n\t}\n}", "target": 1}
{"code": "void IndexedDBDatabase::Clear(IndexedDBTransaction* transaction,\n                              int64_t object_store_id,\n                              scoped_refptr<IndexedDBCallbacks> callbacks) {\n  DCHECK(transaction);\n  IDB_TRACE1(\"IndexedDBDatabase::Clear\", \"txn.id\", transaction->id());\n  DCHECK_NE(transaction->mode(), blink::mojom::IDBTransactionMode::ReadOnly);\n  if (!ValidateObjectStoreId(object_store_id))\n    return;\n  transaction->ScheduleTask(base::BindOnce(&IndexedDBDatabase::ClearOperation,\n                                           this, object_store_id, callbacks));\n}", "target": 0}
{"code": "void CleanWriters(GF_List *writers)\n{\n\twhile (gf_list_count(writers)) {\n\t\tTrackWriter *writer = (TrackWriter*)gf_list_get(writers, 0);\n\t\tgf_list_del_item(writer->stbl->child_boxes, writer->stco);\n\t\tgf_list_del_item(writer->stbl->child_boxes, writer->stsc);\n\t\tgf_isom_box_del(writer->stco);\n\t\tgf_isom_box_del((GF_Box *)writer->stsc);\n\t\tgf_free(writer);\n\t\tgf_list_rem(writers, 0);\n\t}\n}", "target": 0}
{"code": "PermissionRequestType PermissionUtil::GetRequestType(ContentSettingsType type) {\n  switch (type) {\n    case CONTENT_SETTINGS_TYPE_GEOLOCATION:\n      return PermissionRequestType::PERMISSION_GEOLOCATION;\n    case CONTENT_SETTINGS_TYPE_NOTIFICATIONS:\n      return PermissionRequestType::PERMISSION_NOTIFICATIONS;\n    case CONTENT_SETTINGS_TYPE_MIDI_SYSEX:\n      return PermissionRequestType::PERMISSION_MIDI_SYSEX;\n    case CONTENT_SETTINGS_TYPE_PUSH_MESSAGING:\n      return PermissionRequestType::PERMISSION_PUSH_MESSAGING;\n    case CONTENT_SETTINGS_TYPE_PROTECTED_MEDIA_IDENTIFIER:\n      return PermissionRequestType::PERMISSION_PROTECTED_MEDIA_IDENTIFIER;\n    case CONTENT_SETTINGS_TYPE_PLUGINS:\n      return PermissionRequestType::PERMISSION_FLASH;\n    default:\n      NOTREACHED();\n      return PermissionRequestType::UNKNOWN;\n  }\n}", "target": 0}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* data =\n      reinterpret_cast<TfLiteAudioMicrofrontendParams*>(node->user_data);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 1);\n  TF_LITE_ENSURE_EQ(context, input->type, kTfLiteInt16);\n  output->type = kTfLiteInt32;\n  if (data->out_float) {\n    output->type = kTfLiteFloat32;\n  }\n  TfLiteIntArray* output_size = TfLiteIntArrayCreate(2);\n  int num_frames = 0;\n  if (input->dims->data[0] >= data->state->window.size) {\n    num_frames = (input->dims->data[0] - data->state->window.size) /\n                     data->state->window.step / data->frame_stride +\n                 1;\n  }\n  output_size->data[0] = num_frames;\n  output_size->data[1] = data->state->filterbank.num_channels *\n                         (1 + data->left_context + data->right_context);\n  return context->ResizeTensor(context, output, output_size);\n}", "target": 1}
{"code": "static int floppy_raw_cmd_ioctl(int type, int drive, int cmd,\n\t\t\t\tvoid __user *param)\n{\n\tint ret;\n\tpr_warn_once(\"Note: FDRAWCMD is deprecated and will be removed from the kernel in the near future.\\n\");\n\tif (type)\n\t\treturn -EINVAL;\n\tif (lock_fdc(drive))\n\t\treturn -EINTR;\n\tset_floppy(drive);\n\tret = raw_cmd_ioctl(cmd, param);\n\tif (ret == -EINTR)\n\t\treturn -EINTR;\n\tprocess_fd_request();\n\treturn ret;\n}", "target": 0}
{"code": "vips_foreign_load_start( VipsImage *out, void *a, void *b )\n{\n\tVipsForeignLoad *load = VIPS_FOREIGN_LOAD( b );\n\tVipsForeignLoadClass *class = VIPS_FOREIGN_LOAD_GET_CLASS( load );\n\tif( !load->real ) {\n\t\tif( !(load->real = vips_foreign_load_temp( load )) )\n\t\t\treturn( NULL );\n#ifdef DEBUG\n\t\tprintf( \"vips_foreign_load_start: triggering ->load()\\n\" );\n#endif \n\t\tload->real->progress_signal = load->out;\n\t\tg_object_set_qdata( G_OBJECT( load->real ), \n\t\t\tvips__foreign_load_operation, load ); \n\t\tif( class->load( load ) ||\n\t\t\tvips_image_pio_input( load->real ) ) \n\t\t\treturn( NULL );\n\t\tif( !vips_foreign_load_iscompat( load->real, out ) )\n\t\t\treturn( NULL );\n\t\tvips_image_pipelinev( load->out, load->out->dhint, \n\t\t\tload->real, NULL );\n\t}\n\treturn( vips_region_new( load->real ) );\n}", "target": 1}
{"code": "static uint64_t generatePageID()\n{\n    static uint64_t uniquePageID = 1;\n    return uniquePageID++;\n}", "target": 0}
{"code": "GetIoStats(Mgr::IoActionData& stats)\n{\n    int i;\n    stats.http_reads = IOStats.Http.reads;\n    for (i = 0; i < IoStats::histSize; ++i) {\n        stats.http_read_hist[i] = IOStats.Http.read_hist[i];\n    }\n    stats.ftp_reads = IOStats.Ftp.reads;\n    for (i = 0; i < IoStats::histSize; ++i) {\n        stats.ftp_read_hist[i] = IOStats.Ftp.read_hist[i];\n    }\n    stats.gopher_reads = IOStats.Gopher.reads;\n    for (i = 0; i < IoStats::histSize; ++i) {\n        stats.gopher_read_hist[i] = IOStats.Gopher.read_hist[i];\n    }\n}", "target": 1}
{"code": "int count_mounts(struct mnt_namespace *ns, struct mount *mnt)\n{\n\tunsigned int max = READ_ONCE(sysctl_mount_max);\n\tunsigned int mounts = 0, old, pending, sum;\n\tstruct mount *p;\n\tfor (p = mnt; p; p = next_mnt(p, mnt))\n\t\tmounts++;\n\told = ns->mounts;\n\tpending = ns->pending_mounts;\n\tsum = old + pending;\n\tif ((old > sum) ||\n\t    (pending > sum) ||\n\t    (max < sum) ||\n\t    (mounts > (max - sum)))\n\t\treturn -ENOSPC;\n\tns->pending_mounts = pending + mounts;\n\treturn 0;\n}", "target": 0}
{"code": "int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src)\n{\n\tflush_fp_to_thread(src);\n\tflush_altivec_to_thread(src);\n\tflush_vsx_to_thread(src);\n\tflush_spe_to_thread(src);\n\t__switch_to_tm(src);\n\ttm_recheckpoint_new_task(src);\n\t*dst = *src;\n\tclear_task_ebb(dst);\n\treturn 0;\n}", "target": 0}
{"code": "    OlympusMnHeader::~OlympusMnHeader()\n    {\n    }", "target": 0}
{"code": "find_jws(struct tang_keys_info* tki, const char* thp)\n{\n    if (!tki) {\n        return NULL;\n    }\n    if (thp == NULL) {\n        json_auto_t* jws = jwk_sign(tki->m_payload, tki->m_sign);\n        if (!jws) {\n            return NULL;\n        }\n        return json_incref(jws);\n    }\n    return find_by_thp(tki, thp);\n}", "target": 1}
{"code": "int SSL_free_buffers(SSL *ssl)\n{\n    RECORD_LAYER *rl = &ssl->rlayer;\n    if (RECORD_LAYER_read_pending(rl) || RECORD_LAYER_write_pending(rl))\n        return 0;\n    if (RECORD_LAYER_data_present(rl))\n        return 0;\n    RECORD_LAYER_release(rl);\n    return 1;\n}", "target": 0}
{"code": "int main(void)\n{\n\tSuite *suite;\n\tSRunner *runner;\n\tint tests_failed;\n\tlog_setup(true);\n\tsuite = xml_load_suite();\n\trunner = srunner_create(suite);\n\tsrunner_run_all(runner, CK_NORMAL);\n\ttests_failed = srunner_ntests_failed(runner);\n\tsrunner_free(runner);\n\treturn (tests_failed == 0) ? EXIT_SUCCESS : EXIT_FAILURE;\n}", "target": 0}
{"code": "void hexdump(msg_info msg_info, const char *mem, unsigned int len)\n{\n    unsigned int i, j;\n    char str[10 + HEXDUMP_COLS * 4 + 2];\n    int c = 0; \n    for(i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++)\n    {\n        if(i % HEXDUMP_COLS == 0)\n            c += sprintf(&str[c], \"0x%06x: \", i);\n        if(i < len)\n            c += sprintf(&str[c], \"%02x \", 0xFF & mem[i]);\n        else \n            c+= sprintf(&str[c], \"   \");\n        if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1)) {\n            for(j = i - (HEXDUMP_COLS - 1); j <= i; j++) {\n                if(j >= len) \n                    str[c++] = ' ';\n                else if(isprint(mem[j])) \n                    str[c++] = 0xFF & mem[j];\n                else \n                    str[c++] = '.';\n            }\n            str[c++] = '\\n';\n            str[c++] = 0;\n            print_message(msg_info, str);\n            c = 0;\n        }\n    }\n}", "target": 1}
{"code": "xfs_ilock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\ttrace_xfs_ilock(ip, lock_flags, _RET_IP_);\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_MMAPLOCK_SHARED | XFS_MMAPLOCK_EXCL)) !=\n\t       (XFS_MMAPLOCK_SHARED | XFS_MMAPLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_SUBCLASS_MASK)) == 0);\n\tif (lock_flags & XFS_IOLOCK_EXCL) {\n\t\tdown_write_nested(&VFS_I(ip)->i_rwsem,\n\t\t\t\t  XFS_IOLOCK_DEP(lock_flags));\n\t} else if (lock_flags & XFS_IOLOCK_SHARED) {\n\t\tdown_read_nested(&VFS_I(ip)->i_rwsem,\n\t\t\t\t XFS_IOLOCK_DEP(lock_flags));\n\t}\n\tif (lock_flags & XFS_MMAPLOCK_EXCL)\n\t\tmrupdate_nested(&ip->i_mmaplock, XFS_MMAPLOCK_DEP(lock_flags));\n\telse if (lock_flags & XFS_MMAPLOCK_SHARED)\n\t\tmraccess_nested(&ip->i_mmaplock, XFS_MMAPLOCK_DEP(lock_flags));\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrupdate_nested(&ip->i_lock, XFS_ILOCK_DEP(lock_flags));\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmraccess_nested(&ip->i_lock, XFS_ILOCK_DEP(lock_flags));\n}", "target": 0}
{"code": "static void *HttpMultiBufHeaderThreadDataInit(void *data)\n{\n    HttpMultiBufHeaderThreadData *td = SCCalloc(1, sizeof(*td));\n    return td;\n}", "target": 0}
{"code": "juniper_atm1_print(netdissect_options *ndo,\n                   const struct pcap_pkthdr *h, register const u_char *p)\n{\n        int llc_hdrlen;\n        struct juniper_l2info_t l2info;\n        l2info.pictype = DLT_JUNIPER_ATM1;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n        p+=l2info.header_len;\n        if (l2info.cookie[0] == 0x80) { \n            oam_print(ndo, p, l2info.length, ATM_OAM_NOHEC);\n            return l2info.header_len;\n        }\n        if (EXTRACT_24BITS(p) == 0xfefe03 || \n            EXTRACT_24BITS(p) == 0xaaaa03) { \n            llc_hdrlen = llc_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL);\n            if (llc_hdrlen > 0)\n                return l2info.header_len;\n        }\n        if (p[0] == 0x03) { \n            isoclns_print(ndo, p + 1, l2info.length - 1, l2info.caplen - 1);\n            return l2info.header_len;\n        }\n        if (ip_heuristic_guess(ndo, p, l2info.length) != 0) \n            return l2info.header_len;\n\treturn l2info.header_len;\n}", "target": 1}
{"code": "void CConfig::Write(CFile& File, unsigned int iIndentation) {\n    CString sIndentation = CString(iIndentation, '\\t');\n    for (const auto& it : m_ConfigEntries) {\n        for (const CString& sValue : it.second) {\n            File.Write(sIndentation + it.first + \" = \" + sValue + \"\\n\");\n        }\n    }\n    for (const auto& it : m_SubConfigs) {\n        for (const auto& it2 : it.second) {\n            File.Write(\"\\n\");\n            File.Write(sIndentation + \"<\" + it.first + \" \" + it2.first + \">\\n\");\n            it2.second.m_pSubConfig->Write(File, iIndentation + 1);\n            File.Write(sIndentation + \"</\" + it.first + \">\\n\");\n        }\n    }\n}", "target": 1}
{"code": "InstallSignalHandlers(void)\n{\n    xf86Info.caughtSignal = FALSE;\n    if (!xf86Info.notrapSignals) {\n        OsRegisterSigWrapper(xf86SigWrapper);\n    }\n    else {\n        signal(SIGSEGV, SIG_DFL);\n        signal(SIGILL, SIG_DFL);\n#ifdef SIGEMT\n        signal(SIGEMT, SIG_DFL);\n#endif\n        signal(SIGFPE, SIG_DFL);\n        signal(SIGBUS, SIG_DFL);\n        signal(SIGSYS, SIG_DFL);\n        signal(SIGXCPU, SIG_DFL);\n        signal(SIGXFSZ, SIG_DFL);\n    }\n}", "target": 0}
{"code": "_TIFFmalloc(tmsize_t s)\n{\n        if (s == 0)\n                return ((void *) NULL);\n\treturn (malloc((size_t) s));\n}", "target": 0}
{"code": "key_set(const char *key) {\n    int\t\tlen = (int)strlen(key);\n    int64_t\th = calc_hash(key, &len);\n    Slot\t*bucket = get_bucketp(h);\n    Slot\ts;\n    if (NULL != (s = (Slot)AGOO_MALLOC(sizeof(struct _slot)))) {\n\ts->hash = h;\n\ts->klen = len;\n\ts->key = key;\n\ts->next = *bucket;\n\t*bucket = s;\n    }\n}", "target": 1}
{"code": "int main()\n{\n    gdImagePtr im;\n    FILE *fp;\n    fp = gdTestFileOpen2(\"gd2\", \"bug00354a.gd2\");\n    gdTestAssert(fp != NULL);\n    im = gdImageCreateFromGd2(fp);\n    gdTestAssert(im == NULL);\n    fclose(fp);\n    fp = gdTestFileOpen2(\"gd2\", \"bug00354b.gd2\");\n    gdTestAssert(fp != NULL);\n    im = gdImageCreateFromGd2(fp);\n    gdTestAssert(im == NULL);\n    fclose(fp);\n    return gdNumFailures();\n}", "target": 0}
{"code": "TEST(FormatTest, Regression) {\n  fmt::format(\"...........{:<77777.7p}\", \"foo\");\n}", "target": 0}
{"code": "int db_update(char* name, char* value)\n{\n\tchar* sql;\n\tint r = 0;\n\tif (crypt_key) {\n\t\tvalue = note_encrypt(value,crypt_key);\n\t\tr = asprintf(&sql, \"UPDATE nodau set text='%s' , encrypted='true' WHERE name='%s'\", value, name);\n\t\tfree(value);\n\t\tif (r < 0)\n\t\t\treturn 1;\n\t}else{\n\t\tif (asprintf(&sql, \"UPDATE nodau set text='%s' , encrypted='false' WHERE name='%s'\", value, name) < 0)\n\t\t\treturn 1;\n\t}\n\tr = sqlite3_exec(db_data.db, sql, NULL, 0, &db_data.error_msg);\n\tfree(sql);\n\treturn r;\n}", "target": 1}
{"code": "int epo_copy_color(gx_device *dev, const byte *data, int data_x, int raster, gx_bitmap_id id,\\\n    int x, int y, int width, int height)\n{\n    int code = epo_handle_erase_page(dev);\n    if (code != 0)\n        return code;\n    return dev_proc(dev, copy_color)(dev, data, data_x, raster, id, x, y, width, height);\n}", "target": 0}
{"code": "inline static jas_int_asr(int x, int n)\n{\n\tassert(n >= 0);\n\treturn x >> n;\n}", "target": 0}
{"code": "int Item::save_time_in_field(Field *field)\n{\n  MYSQL_TIME ltime;\n  if (get_time(&ltime))\n    return set_field_to_null_with_conversions(field, 0);\n  field->set_notnull();\n  return field->store_time_dec(&ltime, decimals);\n}", "target": 0}
{"code": "service_info *FindServiceControlURLPath(\n\tservice_table *table, const char *controlURLPath)\n{\n\tservice_info *finger = NULL;\n\turi_type parsed_url;\n\turi_type parsed_url_in;\n\tif (table && parse_uri(controlURLPath,\n\t\t\t     strlen(controlURLPath),\n\t\t\t     &parsed_url_in) == HTTP_SUCCESS) {\n\t\tfinger = table->serviceList;\n\t\twhile (finger) {\n\t\t\tif (finger->controlURL) {\n\t\t\t\tif (parse_uri(finger->controlURL,\n\t\t\t\t\t    strlen(finger->controlURL),\n\t\t\t\t\t    &parsed_url) == HTTP_SUCCESS) {\n\t\t\t\t\tif (!token_cmp(&parsed_url.pathquery,\n\t\t\t\t\t\t    &parsed_url_in.pathquery)) {\n\t\t\t\t\t\treturn finger;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinger = finger->next;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "void UpstreamRequest::onPerTryTimeout() {\n  if (per_try_idle_timeout_) {\n    per_try_idle_timeout_.reset();\n  }\n  if (!parent_.downstreamResponseStarted()) {\n    ENVOY_STREAM_LOG(debug, \"upstream per try timeout\", *parent_.callbacks());\n    stream_info_.setResponseFlag(StreamInfo::CoreResponseFlag::UpstreamRequestTimeout);\n    parent_.onPerTryTimeout(*this);\n  } else {\n    ENVOY_STREAM_LOG(debug,\n                     \"ignored upstream per try timeout due to already started downstream response\",\n                     *parent_.callbacks());\n  }\n}", "target": 0}
{"code": "static int key_verify(pam_handle_t *pamh, int flags, PKCS11_KEY *authkey)\n{\n\tint ok = 0;\n\tunsigned char challenge[30];\n\tunsigned char signature[256];\n\tunsigned int siglen = sizeof signature;\n\tconst EVP_MD *md = EVP_sha1();\n\tEVP_MD_CTX *md_ctx = EVP_MD_CTX_new();\n\tEVP_PKEY *privkey = PKCS11_get_private_key(authkey);\n\tEVP_PKEY *pubkey = PKCS11_get_public_key(authkey);\n\tif (1 != randomize(pamh, challenge, sizeof challenge)) {\n\t\tgoto err;\n\t}\n\tif (NULL == pubkey || NULL == privkey || NULL == md_ctx || NULL == md\n\t\t\t|| !EVP_SignInit(md_ctx, md)\n\t\t\t|| !EVP_SignUpdate(md_ctx, challenge, sizeof challenge)\n\t\t\t|| !EVP_SignFinal(md_ctx, signature, &siglen, privkey)\n\t\t\t|| !EVP_MD_CTX_reset(md_ctx)\n\t\t\t|| !EVP_VerifyInit(md_ctx, md)\n\t\t\t|| !EVP_VerifyUpdate(md_ctx, challenge, sizeof challenge)\n\t\t\t|| 1 != EVP_VerifyFinal(md_ctx, signature, siglen, pubkey)) {\n\t\tpam_syslog(pamh, LOG_DEBUG, \"Error verifying key: %s\\n\",\n\t\t\t\tERR_reason_error_string(ERR_get_error()));\n\t\tprompt(flags, pamh, PAM_ERROR_MSG, NULL, _(\"Error verifying key\"));\n\t\tgoto err;\n\t}\n\tok = 1;\nerr:\n\tif (NULL != pubkey)\n\t\tEVP_PKEY_free(pubkey);\n\tif (NULL != privkey)\n\t\tEVP_PKEY_free(privkey);\n\tif (NULL != md_ctx) {\n\t\tEVP_MD_CTX_free(md_ctx);\n\t}\n\treturn ok;\n}", "target": 1}
{"code": "static int bit_tohex(lua_State *L)\n{\n  UBits b = barg(L, 1);\n  SBits n = lua_isnone(L, 2) ? 8 : (SBits)barg(L, 2);\n  const char *hexdigits = \"0123456789abcdef\";\n  char buf[8];\n  int i;\n  if (n == INT32_MIN) n = INT32_MIN+1;\n  if (n < 0) { n = -n; hexdigits = \"0123456789ABCDEF\"; }\n  if (n > 8) n = 8;\n  for (i = (int)n; --i >= 0; ) { buf[i] = hexdigits[b & 15]; b >>= 4; }\n  lua_pushlstring(L, buf, (size_t)n);\n  return 1;\n}", "target": 0}
{"code": " */\nint re_yyget_lineno  (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n        if (! YY_CURRENT_BUFFER)\n            return 0;\n    return yylineno;", "target": 1}
{"code": "ZEND_API void zend_objects_store_del_ref_by_handle_ex(zend_object_handle handle, const zend_object_handlers *handlers TSRMLS_DC) \n{\n\tstruct _store_object *obj;\n\tint failure = 0;\n\tif (!EG(objects_store).object_buckets) {\n\t\treturn;\n\t}\n\tobj = &EG(objects_store).object_buckets[handle].bucket.obj;\n\tif (EG(objects_store).object_buckets[handle].valid) {\n\t\tif (obj->refcount == 1) {\n\t\t\tif (!EG(objects_store).object_buckets[handle].destructor_called) {\n\t\t\t\tEG(objects_store).object_buckets[handle].destructor_called = 1;\n\t\t\t\tif (obj->dtor) {\n\t\t\t\t\tif (handlers && !obj->handlers) {\n\t\t\t\t\t\tobj->handlers = handlers;\n\t\t\t\t\t}\n\t\t\t\t\tzend_try {\n\t\t\t\t\t\tobj->dtor(obj->object, handle TSRMLS_CC);\n\t\t\t\t\t} zend_catch {\n\t\t\t\t\t\tfailure = 1;\n\t\t\t\t\t} zend_end_try();\n\t\t\t\t}\n\t\t\t}\n\t\t\tobj = &EG(objects_store).object_buckets[handle].bucket.obj;\n\t\t\tif (obj->refcount == 1) {\n\t\t\t\tGC_REMOVE_ZOBJ_FROM_BUFFER(obj);\n\t\t\t\tif (obj->free_storage) {\n\t\t\t\t\tzend_try {\n\t\t\t\t\t\tobj->free_storage(obj->object TSRMLS_CC);\n\t\t\t\t\t} zend_catch {\n\t\t\t\t\t\tfailure = 1;\n\t\t\t\t\t} zend_end_try();\n\t\t\t\t}\n\t\t\t\tZEND_OBJECTS_STORE_ADD_TO_FREE_LIST();\n\t\t\t}\n\t\t}\n\t}\n\tobj->refcount--;\n#if ZEND_DEBUG_OBJECTS\n\tif (obj->refcount == 0) {\n\t\tfprintf(stderr, \"Deallocated object id #%d\\n\", handle);\n\t} else {\n\t\tfprintf(stderr, \"Decreased refcount of object id #%d\\n\", handle);\n\t}\n#endif\n\tif (failure) {\n\t\tzend_bailout();\n\t}\n}", "target": 1}
{"code": "void Splash::setOverprintMask(Guint overprintMask, GBool additive) {\n  state->overprintMask = overprintMask;\n  state->overprintAdditive = additive;\n}", "target": 0}
{"code": "int vm_sockets_get_local_cid(void)\n{\n\treturn transport->get_local_cid();\n}", "target": 0}
{"code": "  void setInVmContextCreatedForTesting() { in_vm_context_created_ = true; }", "target": 0}
{"code": "find_sig8_target_as_global_offset(Dwarf_Attribute attr,\n    Dwarf_Sig8  *sig8,\n    Dwarf_Bool  *is_info,\n    Dwarf_Off   *targoffset,\n    Dwarf_Error *error)\n{\n    Dwarf_Die  targdie = 0;\n    Dwarf_Bool targ_is_info = 0;\n    Dwarf_Off  localoff = 0;\n    int res = 0;\n    targ_is_info = attr->ar_cu_context->cc_is_info;\n    memcpy(sig8,attr->ar_debug_ptr,sizeof(*sig8));\n    res = dwarf_find_die_given_sig8(attr->ar_dbg,\n        sig8,&targdie,&targ_is_info,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    res = dwarf_die_offsets(targdie,targoffset,&localoff,error);\n    if (res != DW_DLV_OK) {\n        dwarf_dealloc_die(targdie);\n        return res;\n    }\n    *is_info = targdie->di_cu_context->cc_is_info;\n    dwarf_dealloc_die(targdie);\n    return DW_DLV_OK;\n}", "target": 1}
{"code": "xmlValidCtxtNormalizeAttributeValue(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\n\t     xmlNodePtr elem, const xmlChar *name, const xmlChar *value) {\n    xmlChar *ret, *dst;\n    const xmlChar *src;\n    xmlAttributePtr attrDecl = NULL;\n    int extsubset = 0;\n    if (doc == NULL) return(NULL);\n    if (elem == NULL) return(NULL);\n    if (name == NULL) return(NULL);\n    if (value == NULL) return(NULL);\n    if ((elem->ns != NULL) && (elem->ns->prefix != NULL)) {\n\txmlChar fn[50];\n\txmlChar *fullname;\n\tfullname = xmlBuildQName(elem->name, elem->ns->prefix, fn, 50);\n\tif (fullname == NULL)\n\t    return(NULL);\n\tattrDecl = xmlGetDtdAttrDesc(doc->intSubset, fullname, name);\n\tif ((attrDecl == NULL) && (doc->extSubset != NULL)) {\n\t    attrDecl = xmlGetDtdAttrDesc(doc->extSubset, fullname, name);\n\t    if (attrDecl != NULL)\n\t\textsubset = 1;\n\t}\n\tif ((fullname != fn) && (fullname != elem->name))\n\t    xmlFree(fullname);\n    }\n    if ((attrDecl == NULL) && (doc->intSubset != NULL))\n\tattrDecl = xmlGetDtdAttrDesc(doc->intSubset, elem->name, name);\n    if ((attrDecl == NULL) && (doc->extSubset != NULL)) {\n\tattrDecl = xmlGetDtdAttrDesc(doc->extSubset, elem->name, name);\n\tif (attrDecl != NULL)\n\t    extsubset = 1;\n    }\n    if (attrDecl == NULL)\n\treturn(NULL);\n    if (attrDecl->atype == XML_ATTRIBUTE_CDATA)\n\treturn(NULL);\n    ret = xmlStrdup(value);\n    if (ret == NULL)\n\treturn(NULL);\n    src = value;\n    dst = ret;\n    while (*src == 0x20) src++;\n    while (*src != 0) {\n\tif (*src == 0x20) {\n\t    while (*src == 0x20) src++;\n\t    if (*src != 0)\n\t\t*dst++ = 0x20;\n\t} else {\n\t    *dst++ = *src++;\n\t}\n    }\n    *dst = 0;\n    if ((doc->standalone) && (extsubset == 1) && (!xmlStrEqual(value, ret))) {\n\txmlErrValidNode(ctxt, elem, XML_DTD_NOT_STANDALONE,\n\"standalone: %s on %s value had to be normalized based on external subset declaration\\n\",\n\t       name, elem->name, NULL);\n\tctxt->valid = 0;\n    }\n    return(ret);\n}", "target": 1}
{"code": "static size_t read_test_file(char **buffer, char *basename)\n{\n    char *filename;\n    FILE *fp;\n    size_t exp_size, act_size;\n    filename = gdTestFilePath2(\"tiff\", basename);\n    fp = fopen(filename, \"rb\");\n    gdTestAssert(fp != NULL);\n\tfseek(fp, 0, SEEK_END);\n\texp_size = ftell(fp);\n\tfseek(fp, 0, SEEK_SET);\n    *buffer = malloc(exp_size);\n    gdTestAssert(*buffer != NULL);\n    act_size = fread(*buffer, sizeof(**buffer), exp_size, fp);\n    gdTestAssert(act_size == exp_size);\n    fclose(fp);\n    free(filename);\n    return act_size;\n}", "target": 0}
{"code": "void HTTPServer::handleRequest(Client *cl, HTTPRequest* req) {\n\tif (!req->parse()) {\n\t\tstd::cout << \"[\" << cl->getClientIP() << \"] There was an error processing the request of type: \" << req->methodIntToStr(req->getMethod()) << std::endl;\n\t\tstd::cout << req->getParseError() << std::endl;\n\t\tsendStatusResponse(cl, Status(BAD_REQUEST), req->getParseError());\n\t\treturn;\n\t}\n\tstd::cout << \"[\" << cl->getClientIP() << \"] \" << req->methodIntToStr(req->getMethod()) << \" \" << req->getRequestUri() << std::endl;\n\tResourceHost* resHost = NULL;\n\tstd::string host = \"\";\n\tif (req->getVersion().compare(HTTP_VERSION_11) == 0) {\n\t\thost = req->getHeaderValue(\"Host\");\n\t\tif (host.find(\":\") == std::string::npos) {\n\t\t\thost.append(\":\" + std::to_string(listenPort));\n\t\t}\n\t\tstd::unordered_map<std::string, ResourceHost*>::const_iterator it = vhosts.find(host);\n\t\tif (it != vhosts.end())\n\t\t\tresHost = it->second;\n\t} else {\n\t\tif (hostList.size() > 0)\n\t\t\tresHost = hostList[0];\n\t}\n\tif (resHost == NULL) {\n\t\tsendStatusResponse(cl, Status(BAD_REQUEST), \"Invalid/No Host specified: \" + host);\n\t\treturn;\n\t}\n\tswitch (req->getMethod()) {\n\tcase Method(HEAD):\n\tcase Method(GET):\n\t\thandleGet(cl, req, resHost);\n\t\tbreak;\n\tcase Method(OPTIONS):\n\t\thandleOptions(cl, req);\n\t\tbreak;\n\tcase Method(TRACE):\n\t\thandleTrace(cl, req);\n\t\tbreak;\n\tdefault:\n\t\tstd::cout << \"[\" << cl->getClientIP() << \"] Could not handle or determine request of type \" << req->methodIntToStr(req->getMethod()) << std::endl;\n\t\tsendStatusResponse(cl, Status(NOT_IMPLEMENTED));\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "  virtual bool ethernet_available() const { return true; }", "target": 0}
{"code": "table_regex_match(const char *string, const char *pattern)\n{\n\tregex_t preg;\n\tint\tcflags = REG_EXTENDED|REG_NOSUB;\n\tif (strncmp(pattern, \"(?i)\", 4) == 0) {\n\t\tcflags |= REG_ICASE;\n\t\tpattern += 4;\n\t}\n\tif (regcomp(&preg, pattern, cflags) != 0)\n\t\treturn (0);\n\tif (regexec(&preg, string, 0, NULL, 0) != 0)\n\t\treturn (0);\n\treturn (1);\n}", "target": 1}
{"code": "static int ocfs2_lock_get_block(struct inode *inode, sector_t iblock,\n\t\t    struct buffer_head *bh_result, int create)\n{\n\tint ret = 0;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tdown_read(&oi->ip_alloc_sem);\n\tret = ocfs2_get_block(inode, iblock, bh_result, create);\n\tup_read(&oi->ip_alloc_sem);\n\treturn ret;\n}", "target": 0}
{"code": "int options_cmdline(char *arg1, char *arg2) {\n    char *name;\n    CONF_TYPE type;\n#ifdef USE_WIN32\n    (void)arg2; \n#endif\n    if(!arg1) {\n        name=\n#ifdef CONFDIR\n            CONFDIR\n#ifdef USE_WIN32\n            \"\\\\\"\n#else\n            \"/\"\n#endif\n#endif\n            \"stunnel.conf\";\n        type=CONF_FILE;\n    } else if(!strcasecmp(arg1, \"-help\")) {\n        parse_global_option(CMD_PRINT_HELP, NULL, NULL);\n        parse_service_option(CMD_PRINT_HELP, NULL, NULL, NULL);\n        log_flush(LOG_MODE_INFO);\n        return 2;\n    } else if(!strcasecmp(arg1, \"-version\")) {\n        parse_global_option(CMD_PRINT_DEFAULTS, NULL, NULL);\n        parse_service_option(CMD_PRINT_DEFAULTS, NULL, NULL, NULL);\n        log_flush(LOG_MODE_INFO);\n        return 2;\n    } else if(!strcasecmp(arg1, \"-sockets\")) {\n        socket_options_print();\n        log_flush(LOG_MODE_INFO);\n        return 2;\n    } else if(!strcasecmp(arg1, \"-options\")) {\n        print_ssl_options();\n        log_flush(LOG_MODE_INFO);\n        return 2;\n    } else\n#ifndef USE_WIN32\n    if(!strcasecmp(arg1, \"-fd\")) {\n        if(!arg2) {\n            s_log(LOG_ERR, \"No file descriptor specified\");\n            print_syntax();\n            return 1;\n        }\n        name=arg2;\n        type=CONF_FD;\n    } else\n#endif\n    {\n        name=arg1;\n        type=CONF_FILE;\n    }\n    if(type==CONF_FILE) {\n#ifdef HAVE_REALPATH\n        char *real_path=NULL;\n#ifdef MAXPATHLEN\n        real_path=malloc(MAXPATHLEN);\n#endif\n        real_path=realpath(name, real_path);\n        if(!real_path) {\n            s_log(LOG_ERR, \"Invalid configuration file name \\\"%s\\\"\", name);\n            ioerror(\"realpath\");\n            return 1;\n        }\n        configuration_file=str_dup(real_path);\n        free(real_path);\n#else\n        configuration_file=str_dup(name);\n#endif\n#ifndef USE_WIN32\n    } else if(type==CONF_FD) {\n        configuration_file=str_dup(name);\n#endif\n    }\n    return options_parse(type);\n}", "target": 1}
{"code": "int __anon_vma_prepare(struct vm_area_struct *vma)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct anon_vma *anon_vma, *allocated;\n\tstruct anon_vma_chain *avc;\n\tmight_sleep();\n\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\tif (!avc)\n\t\tgoto out_enomem;\n\tanon_vma = find_mergeable_anon_vma(vma);\n\tallocated = NULL;\n\tif (!anon_vma) {\n\t\tanon_vma = anon_vma_alloc();\n\t\tif (unlikely(!anon_vma))\n\t\t\tgoto out_enomem_free_avc;\n\t\tallocated = anon_vma;\n\t}\n\tanon_vma_lock_write(anon_vma);\n\tspin_lock(&mm->page_table_lock);\n\tif (likely(!vma->anon_vma)) {\n\t\tvma->anon_vma = anon_vma;\n\t\tanon_vma_chain_link(vma, avc, anon_vma);\n\t\tanon_vma->degree++;\n\t\tallocated = NULL;\n\t\tavc = NULL;\n\t}\n\tspin_unlock(&mm->page_table_lock);\n\tanon_vma_unlock_write(anon_vma);\n\tif (unlikely(allocated))\n\t\tput_anon_vma(allocated);\n\tif (unlikely(avc))\n\t\tanon_vma_chain_free(avc);\n\treturn 0;\n out_enomem_free_avc:\n\tanon_vma_chain_free(avc);\n out_enomem:\n\treturn -ENOMEM;\n}", "target": 1}
{"code": "static void __net_init sctp_ctrlsock_exit(struct net *net)\n{\n\tinet_ctl_sock_destroy(net->sctp.ctl_sock);\n}", "target": 0}
{"code": "ip_optprint(netdissect_options *ndo,\n            register const u_char *cp, u_int length)\n{\n\tregister u_int option_len;\n\tconst char *sep = \"\";\n\tfor (; length > 0; cp += option_len, length -= option_len) {\n\t\tu_int option_code;\n\t\tND_PRINT((ndo, \"%s\", sep));\n\t\tsep = \",\";\n\t\tND_TCHECK(*cp);\n\t\toption_code = *cp;\n\t\tND_PRINT((ndo, \"%s\",\n\t\t          tok2str(ip_option_values,\"unknown %u\",option_code)));\n\t\tif (option_code == IPOPT_NOP ||\n                    option_code == IPOPT_EOL)\n\t\t\toption_len = 1;\n\t\telse {\n\t\t\tND_TCHECK(cp[1]);\n\t\t\toption_len = cp[1];\n\t\t\tif (option_len < 2) {\n\t\t\t\tND_PRINT((ndo, \" [bad length %u]\", option_len));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (option_len > length) {\n\t\t\tND_PRINT((ndo, \" [bad length %u]\", option_len));\n\t\t\treturn;\n\t\t}\n\t\tND_TCHECK2(*cp, option_len);\n\t\tswitch (option_code) {\n\t\tcase IPOPT_EOL:\n\t\t\treturn;\n\t\tcase IPOPT_TS:\n\t\t\tip_printts(ndo, cp, option_len);\n\t\t\tbreak;\n\t\tcase IPOPT_RR:       \n\t\tcase IPOPT_SSRR:\n\t\tcase IPOPT_LSRR:\n\t\t\tip_printroute(ndo, cp, option_len);\n\t\t\tbreak;\n\t\tcase IPOPT_RA:\n\t\t\tif (option_len < 4) {\n\t\t\t\tND_PRINT((ndo, \" [bad length %u]\", option_len));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tND_TCHECK(cp[3]);\n\t\t\tif (EXTRACT_16BITS(&cp[2]) != 0)\n\t\t\t\tND_PRINT((ndo, \" value %u\", EXTRACT_16BITS(&cp[2])));\n\t\t\tbreak;\n\t\tcase IPOPT_NOP:       \n\t\tcase IPOPT_SECURITY:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn;\ntrunc:\n\tND_PRINT((ndo, \"%s\", tstr));\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const Tensor& sizes = context->input(1);\n    OP_REQUIRES(\n        context,\n        (TensorShapeUtils::IsVector(sizes.shape()) ||\n         TensorShapeUtils::IsScalar(sizes.shape())),\n        errors::InvalidArgument(\"sizes input must be 1-D, not \",\n                                sizes.shape().DebugString()));\n    OP_REQUIRES(\n        context, sizes.NumElements() < TensorShape::MaxDimensions(),\n        errors::InvalidArgument(\"too many dimensions: must be < \",\n                                TensorShape::MaxDimensions(), \", but received \",\n                                sizes.NumElements()));\n    TensorShape shape;\n    int64_t product = 1;\n    int unknown_index = -1;\n    bool sizes_has_zero_dim;\n    switch (sizes.dtype()) {\n      case DT_INT32:\n        OP_REQUIRES_OK(context,\n                       ValidateSizes<int32>(sizes, &product, &unknown_index,\n                                            &shape, &sizes_has_zero_dim));\n        break;\n      case DT_INT64:\n        OP_REQUIRES_OK(context,\n                       ValidateSizes<int64_t>(sizes, &product, &unknown_index,\n                                              &shape, &sizes_has_zero_dim));\n        break;\n      default:\n        context->CtxFailure(errors::InvalidArgument(\n            \"desired shape must be a DT_INT32 or DT_INT64 vector, not a \",\n            DataTypeString(sizes.dtype())));\n        return;\n    }\n    if (unknown_index != -1) {\n      int64_t input_num_elements = 1;\n      bool input_has_zero_dim = false;\n      for (int dim = 0; dim < input.dims(); dim++) {\n        if (input.dim_size(dim) > 0 || !sizes_has_zero_dim) {\n          input_num_elements *= input.dim_size(dim);\n        } else {\n          input_has_zero_dim = true;\n        }\n      }\n      const int64_t missing = input_num_elements / product;\n      if (!input_has_zero_dim) {\n        OP_REQUIRES(\n            context, product * missing == input_num_elements,\n            errors::InvalidArgument(\n                \"Input to reshape is a tensor with \", input_num_elements,\n                \" values, but the requested shape requires a multiple of \",\n                product));\n      }\n      shape.set_dim(unknown_index, missing);\n    }\n    OP_REQUIRES(context, shape.num_elements() == input.NumElements(),\n                errors::InvalidArgument(\"Input to reshape is a tensor with \",\n                                        input.NumElements(),\n                                        \" values, but the requested shape has \",\n                                        shape.num_elements()));\n    Tensor output(input.dtype());\n    CHECK(output.CopyFrom(input, shape));\n    context->set_output(0, output);\n  }", "target": 0}
{"code": "void AuthenticationFeature::validateOptions(std::shared_ptr<ProgramOptions> options) {\n  if (!_jwtSecretKeyfileProgramOption.empty() && !_jwtSecretFolderProgramOption.empty()) {\n    LOG_TOPIC(\"d3515\", FATAL, Logger::STARTUP)\n        << \"please specify either '--server.jwt-\"\n           \"secret-keyfile' or '--server.jwt-secret-folder' but not both.\";\n    FATAL_ERROR_EXIT();\n  }\n  if (!_jwtSecretKeyfileProgramOption.empty() || !_jwtSecretFolderProgramOption.empty()) {\n    Result res = loadJwtSecretsFromFile();\n    if (res.fail()) {\n      LOG_TOPIC(\"d3617\", FATAL, Logger::STARTUP) << res.errorMessage();\n      FATAL_ERROR_EXIT();\n    }\n  }\n  if (!_jwtSecretProgramOption.empty()) {\n    if (_jwtSecretProgramOption.length() > _maxSecretLength) {\n      LOG_TOPIC(\"9abfc\", FATAL, arangodb::Logger::STARTUP)\n          << \"Given JWT secret too long. Max length is \" << _maxSecretLength;\n      FATAL_ERROR_EXIT();\n    }\n  }\n  if (_sessionTimeout <= 1.0) {\n    LOG_TOPIC(\"85046\", FATAL, arangodb::Logger::AUTHENTICATION)\n        << \"--server.session-timeout has an invalid value: \" << _sessionTimeout;\n    FATAL_ERROR_EXIT();\n  }\n  if (options->processingResult().touched(\"server.jwt-secret\")) {\n    LOG_TOPIC(\"1aaae\", WARN, arangodb::Logger::AUTHENTICATION)\n        << \"--server.jwt-secret is insecure. Use --server.jwt-secret-keyfile \"\n           \"instead.\";\n  }\n}", "target": 0}
{"code": "\t\tvoid CWebServer::GetFloorplanImage(WebEmSession & session, const request& req, reply & rep)\n\t\t{\n\t\t\tstd::string idx = request::findValue(&req, \"idx\");\n\t\t\tif (idx == \"\") {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tstd::vector<std::vector<std::string> > result;\n\t\t\tresult = m_sql.safe_queryBlob(\"SELECT Image FROM Floorplans WHERE ID=%s\", idx.c_str());\n\t\t\tif (result.empty())\n\t\t\t\treturn;\n\t\t\treply::set_content(&rep, result[0][0].begin(), result[0][0].end());\n\t\t\tstd::string oname = \"floorplan\";\n\t\t\tif (result[0][0].size() > 10)\n\t\t\t{\n\t\t\t\tif (result[0][0][0] == 'P')\n\t\t\t\t\toname += \".png\";\n\t\t\t\telse if (result[0][0][0] == -1)\n\t\t\t\t\toname += \".jpg\";\n\t\t\t\telse if (result[0][0][0] == 'B')\n\t\t\t\t\toname += \".bmp\";\n\t\t\t\telse if (result[0][0][0] == 'G')\n\t\t\t\t\toname += \".gif\";\n\t\t\t}\n\t\t\treply::add_header_attachment(&rep, oname);\n\t\t}", "target": 1}
{"code": "void nfc_llcp_mac_is_up(struct nfc_dev *dev, u32 target_idx,\n\t\t\tu8 comm_mode, u8 rf_mode)\n{\n\tstruct nfc_llcp_local *local;\n\tpr_debug(\"rf mode %d\\n\", rf_mode);\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL)\n\t\treturn;\n\tlocal->target_idx = target_idx;\n\tlocal->comm_mode = comm_mode;\n\tlocal->rf_mode = rf_mode;\n\tif (rf_mode == NFC_RF_INITIATOR) {\n\t\tpr_debug(\"Queueing Tx work\\n\");\n\t\tschedule_work(&local->tx_work);\n\t} else {\n\t\tmod_timer(&local->link_timer,\n\t\t\t  jiffies + msecs_to_jiffies(local->remote_lto));\n\t}\n\tnfc_llcp_local_put(local);\n}", "target": 0}
{"code": "void testPartialDataHandling(const T& val, size_t bytesToPassTheCheck) {\n  auto buf = Serializer::template serialize<folly::IOBufQueue>(val).move();\n  buf->coalesce();\n  EXPECT_NO_THROW(Serializer::template deserialize<T>(buf.get()));\n  buf->trimEnd(buf->length() - bytesToPassTheCheck);\n  EXPECT_THROW(\n      Serializer::template deserialize<T>(buf.get()), std::out_of_range);\n  buf->trimEnd(1);\n  EXPECT_THROW(\n      Serializer::template deserialize<T>(buf.get()),\n      apache::thrift::protocol::TProtocolException);\n}", "target": 0}
{"code": "Status PyArrayDescr_to_TF_DataType(PyArray_Descr* descr,\n                                   TF_DataType* out_tf_datatype) {\n  PyObject* key;\n  PyObject* value;\n  Py_ssize_t pos = 0;\n  if (descr->fields == nullptr) {\n    return errors::Internal(\"Unexpected numpy data type\");\n  }\n  if (PyDict_Next(descr->fields, &pos, &key, &value)) {\n    const char* key_string =\n        PyBytes_Check(key) ? PyBytes_AsString(key)\n                           : PyBytes_AsString(PyUnicode_AsASCIIString(key));\n    if (!key_string) {\n      return errors::Internal(\"Corrupt numpy type descriptor\");\n    }\n    tensorflow::string key = key_string;\n    if (key == \"quint8\") {\n      *out_tf_datatype = TF_QUINT8;\n    } else if (key == \"qint8\") {\n      *out_tf_datatype = TF_QINT8;\n    } else if (key == \"qint16\") {\n      *out_tf_datatype = TF_QINT16;\n    } else if (key == \"quint16\") {\n      *out_tf_datatype = TF_QUINT16;\n    } else if (key == \"qint32\") {\n      *out_tf_datatype = TF_QINT32;\n    } else if (key == \"resource\") {\n      *out_tf_datatype = TF_RESOURCE;\n    } else {\n      return errors::Internal(\"Unsupported numpy data type\");\n    }\n    return Status::OK();\n  }\n  return errors::Internal(\"Unsupported numpy data type\");\n}", "target": 0}
{"code": "inline bool canReadNElements(\n    Protocol_& prot,\n    uint32_t n,\n    std::initializer_list<\n        typename detail::ProtocolReaderWireTypeInfo<Protocol_>::WireType>\n        types) {\n  return prot.getCursor().canAdvance(n * types.size());\n}", "target": 0}
{"code": "int64_t LineBasedFrameDecoder::findEndOfLine(IOBufQueue& buf) {\n  Cursor c(buf.front());\n  for (uint32_t i = 0; i < maxLength_ && i < buf.chainLength(); i++) {\n    auto b = c.read<char>();\n    if (b == '\\n' && terminatorType_ != TerminatorType::CARRIAGENEWLINE) {\n      return i;\n    } else if (terminatorType_ != TerminatorType::NEWLINE &&\n               b == '\\r' && !c.isAtEnd() && c.read<char>() == '\\n') {\n      return i;\n    }\n  }\n  return -1;\n}", "target": 1}
{"code": "static void sas_unregister_devs_sas_addr(struct domain_device *parent,\n\t\t\t\t\t int phy_id, bool last)\n{\n\tstruct expander_device *ex_dev = &parent->ex_dev;\n\tstruct ex_phy *phy = &ex_dev->ex_phy[phy_id];\n\tstruct domain_device *child, *n, *found = NULL;\n\tif (last) {\n\t\tlist_for_each_entry_safe(child, n,\n\t\t\t&ex_dev->children, siblings) {\n\t\t\tif (SAS_ADDR(child->sas_addr) ==\n\t\t\t    SAS_ADDR(phy->attached_sas_addr)) {\n\t\t\t\tset_bit(SAS_DEV_GONE, &child->state);\n\t\t\t\tif (child->dev_type == SAS_EDGE_EXPANDER_DEVICE ||\n\t\t\t\t    child->dev_type == SAS_FANOUT_EXPANDER_DEVICE)\n\t\t\t\t\tsas_unregister_ex_tree(parent->port, child);\n\t\t\t\telse\n\t\t\t\t\tsas_unregister_dev(parent->port, child);\n\t\t\t\tfound = child;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsas_disable_routing(parent, phy->attached_sas_addr);\n\t}\n\tmemset(phy->attached_sas_addr, 0, SAS_ADDR_SIZE);\n\tif (phy->port) {\n\t\tsas_port_delete_phy(phy->port, phy->phy);\n\t\tsas_device_set_phy(found, phy->port);\n\t\tif (phy->port->num_phys == 0)\n\t\t\tsas_port_delete(phy->port);\n\t\tphy->port = NULL;\n\t}\n}", "target": 1}
{"code": "int megasas_alloc_cmds(struct megasas_instance *instance)\n{\n\tint i;\n\tint j;\n\tu16 max_cmd;\n\tstruct megasas_cmd *cmd;\n\tmax_cmd = instance->max_mfi_cmds;\n\tinstance->cmd_list = kcalloc(max_cmd, sizeof(struct megasas_cmd*), GFP_KERNEL);\n\tif (!instance->cmd_list) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"out of memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tmemset(instance->cmd_list, 0, sizeof(struct megasas_cmd *) *max_cmd);\n\tfor (i = 0; i < max_cmd; i++) {\n\t\tinstance->cmd_list[i] = kmalloc(sizeof(struct megasas_cmd),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!instance->cmd_list[i]) {\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tkfree(instance->cmd_list[j]);\n\t\t\tkfree(instance->cmd_list);\n\t\t\tinstance->cmd_list = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tfor (i = 0; i < max_cmd; i++) {\n\t\tcmd = instance->cmd_list[i];\n\t\tmemset(cmd, 0, sizeof(struct megasas_cmd));\n\t\tcmd->index = i;\n\t\tcmd->scmd = NULL;\n\t\tcmd->instance = instance;\n\t\tlist_add_tail(&cmd->list, &instance->cmd_pool);\n\t}\n\tif (megasas_create_frame_pool(instance)) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Error creating frame DMA pool\\n\");\n\t\tmegasas_free_cmds(instance);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int ReadHuffmanCodeLengths(\n    VP8LDecoder* const dec, const int* const code_length_code_lengths,\n    int num_symbols, int* const code_lengths) {\n  int ok = 0;\n  VP8LBitReader* const br = &dec->br_;\n  int symbol;\n  int max_symbol;\n  int prev_code_len = DEFAULT_CODE_LENGTH;\n  HuffmanCode table[1 << LENGTHS_TABLE_BITS];\n  if (!VP8LBuildHuffmanTable(table, LENGTHS_TABLE_BITS,\n                             code_length_code_lengths,\n                             NUM_CODE_LENGTH_CODES)) {\n    goto End;\n  }\n  if (VP8LReadBits(br, 1)) {    \n    const int length_nbits = 2 + 2 * VP8LReadBits(br, 3);\n    max_symbol = 2 + VP8LReadBits(br, length_nbits);\n    if (max_symbol > num_symbols) {\n      goto End;\n    }\n  } else {\n    max_symbol = num_symbols;\n  }\n  symbol = 0;\n  while (symbol < num_symbols) {\n    const HuffmanCode* p;\n    int code_len;\n    if (max_symbol-- == 0) break;\n    VP8LFillBitWindow(br);\n    p = &table[VP8LPrefetchBits(br) & LENGTHS_TABLE_MASK];\n    VP8LSetBitPos(br, br->bit_pos_ + p->bits);\n    code_len = p->value;\n    if (code_len < kCodeLengthLiterals) {\n      code_lengths[symbol++] = code_len;\n      if (code_len != 0) prev_code_len = code_len;\n    } else {\n      const int use_prev = (code_len == kCodeLengthRepeatCode);\n      const int slot = code_len - kCodeLengthLiterals;\n      const int extra_bits = kCodeLengthExtraBits[slot];\n      const int repeat_offset = kCodeLengthRepeatOffsets[slot];\n      int repeat = VP8LReadBits(br, extra_bits) + repeat_offset;\n      if (symbol + repeat > num_symbols) {\n        goto End;\n      } else {\n        const int length = use_prev ? prev_code_len : 0;\n        while (repeat-- > 0) code_lengths[symbol++] = length;\n      }\n    }\n  }\n  ok = 1;\n End:\n  if (!ok) return VP8LSetError(dec, VP8_STATUS_BITSTREAM_ERROR);\n  return ok;\n}", "target": 1}
{"code": "void test_lchown(const char *path)\n{\n\tif (lchown(path, 0, 0) == 0) {\n\t\tfprintf(stderr, \"leak at lchown of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at lchown of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "onig_new_deluxe(regex_t** reg, const UChar* pattern, const UChar* pattern_end,\n                OnigCompileInfo* ci, OnigErrorInfo* einfo)\n{\n  int r;\n  UChar *cpat, *cpat_end;\n  if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;\n  if (ci->pattern_enc != ci->target_enc) {\n    r = conv_encoding(ci->pattern_enc, ci->target_enc, pattern, pattern_end,\n                      &cpat, &cpat_end);\n    if (r != 0) return r;\n  }\n  else {\n    cpat     = (UChar* )pattern;\n    cpat_end = (UChar* )pattern_end;\n  }\n  *reg = (regex_t* )xmalloc(sizeof(regex_t));\n  if (IS_NULL(*reg)) {\n    r = ONIGERR_MEMORY;\n    goto err2;\n  }\n  r = onig_reg_init(*reg, ci->option, ci->case_fold_flag, ci->target_enc,\n                    ci->syntax);\n  if (r != 0) goto err;\n  r = onig_compile(*reg, cpat, cpat_end, einfo);\n  if (r != 0) {\n  err:\n    onig_free(*reg);\n    *reg = NULL;\n  }\n err2:\n  if (cpat != pattern) xfree(cpat);\n  return r;\n}", "target": 1}
{"code": "static void opl3_panning(int dev, int voice, int value)\n{\n\tif (voice < 0 || voice >= devc->nr_voice)\n\t\treturn;\n\tdevc->voc[voice].panning = value;\n}", "target": 0}
{"code": "static int rtnl_fill_link_ifmap(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct rtnl_link_ifmap map = {\n\t\t.mem_start   = dev->mem_start,\n\t\t.mem_end     = dev->mem_end,\n\t\t.base_addr   = dev->base_addr,\n\t\t.irq         = dev->irq,\n\t\t.dma         = dev->dma,\n\t\t.port        = dev->if_port,\n\t};\n\tif (nla_put(skb, IFLA_MAP, sizeof(map), &map))\n\t\treturn -EMSGSIZE;\n\treturn 0;\n}", "target": 1}
{"code": "do_bid_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n    int swap __attribute__((__unused__)), uint32_t namesz, uint32_t descsz,\n    size_t noff, size_t doff, int *flags)\n{\n\tif (namesz == 4 && strcmp((char *)&nbuf[noff], \"GNU\") == 0 &&\n\t    type == NT_GNU_BUILD_ID && (descsz >= 4 || descsz <= 20)) {\n\t\tuint8_t desc[20];\n\t\tconst char *btype;\n\t\tuint32_t i;\n\t\t*flags |= FLAGS_DID_BUILD_ID;\n\t\tswitch (descsz) {\n\t\tcase 8:\n\t\t    btype = \"xxHash\";\n\t\t    break;\n\t\tcase 16:\n\t\t    btype = \"md5/uuid\";\n\t\t    break;\n\t\tcase 20:\n\t\t    btype = \"sha1\";\n\t\t    break;\n\t\tdefault:\n\t\t    btype = \"unknown\";\n\t\t    break;\n\t\t}\n\t\tif (file_printf(ms, \", BuildID[%s]=\", btype) == -1)\n\t\t\treturn 1;\n\t\t(void)memcpy(desc, &nbuf[doff], descsz);\n\t\tfor (i = 0; i < descsz; i++)\n\t\t    if (file_printf(ms, \"%02x\", desc[i]) == -1)\n\t\t\treturn 1;\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static inline int check_entry_size_and_hooks(struct arpt_entry *e,\n\t\t\t\t\t     struct xt_table_info *newinfo,\n\t\t\t\t\t     const unsigned char *base,\n\t\t\t\t\t     const unsigned char *limit,\n\t\t\t\t\t     const unsigned int *hook_entries,\n\t\t\t\t\t     const unsigned int *underflows,\n\t\t\t\t\t     unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct arpt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\tif (!arp_checkentry(&e->arp))\n\t\treturn -EINVAL;\n\terr = xt_check_entry_offsets(e, e->target_offset, e->next_offset);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 1}
{"code": "static FILE * pw_tmpfile(int lockfd)\n{\n\tFILE *fd;\n\tchar *tmpname = NULL;\n\tchar *dir = \"/etc\";\n\tif ((fd = xfmkstemp(&tmpname, dir)) == NULL) {\n\t\tulckpwdf();\n\t\terr(EXIT_FAILURE, _(\"can't open temporary file\"));\n\t}\n\tcopyfile(lockfd, fileno(fd));\n\ttmp_file = tmpname;\n\treturn fd;\n}", "target": 1}
{"code": "inline uint char_val(char X)\n{\n  return (uint) (X >= '0' && X <= '9' ? X-'0' :\n\t\t X >= 'A' && X <= 'Z' ? X-'A'+10 :\n\t\t X-'a'+10);\n}", "target": 0}
{"code": "static struct nfc_llcp_local *nfc_llcp_remove_local(struct nfc_dev *dev)\n{\n\tstruct nfc_llcp_local *local, *tmp;\n\tspin_lock(&llcp_devices_lock);\n\tlist_for_each_entry_safe(local, tmp, &llcp_devices, list)\n\t\tif (local->dev == dev) {\n\t\t\tlist_del(&local->list);\n\t\t\tspin_unlock(&llcp_devices_lock);\n\t\t\treturn local;\n\t\t}\n\tspin_unlock(&llcp_devices_lock);\n\tpr_warn(\"Shutting down device not found\\n\");\n\treturn NULL;\n}", "target": 0}
{"code": "NOEXPORT void reload_config() {\n    static int delay=10; \n#ifdef HAVE_CHROOT\n    struct stat sb;\n#endif \n    if(options_parse(CONF_RELOAD)) {\n        s_log(LOG_ERR, \"Failed to reload the configuration file\");\n        return;\n    }\n    unbind_ports();\n    log_flush(LOG_MODE_BUFFER);\n#ifdef HAVE_CHROOT\n    if(global_options.chroot_dir && stat(\"/dev/log\", &sb))\n        log_close(SINK_OUTFILE);\n    else\n#endif \n        log_close(SINK_SYSLOG|SINK_OUTFILE);\n    options_free();\n    options_apply();\n    log_open(SINK_SYSLOG|SINK_OUTFILE);\n    log_flush(LOG_MODE_CONFIGURED);\n    ui_config_reloaded();\n    if(bind_ports() | exec_connect_start()) {\n        s_poll_sleep(delay/1000, delay%1000); \n        signal_post(SIGNAL_RELOAD_CONFIG); \n        delay*=2;\n        if(delay > 10000) \n            delay=10000;\n    } else {\n        delay=10; \n    }\n}", "target": 1}
{"code": "header_put_byte (SF_PRIVATE *psf, char x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 1)\n\t\tpsf->header [psf->headindex++] = x ;\n} ", "target": 1}
{"code": "static void destroy_pit_timer(struct kvm_pit *pit)\n{\n\thrtimer_cancel(&pit->pit_state.timer);\n\tflush_kthread_work(&pit->expired);\n}", "target": 0}
{"code": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\tif (inode_capable(inode, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}", "target": 1}
{"code": "wb_prep(netdissect_options *ndo,\n        const struct pkt_prep *prep, u_int len)\n{\n\tint n;\n\tconst struct pgstate *ps;\n\tconst u_char *ep = ndo->ndo_snapend;\n\tND_PRINT((ndo, \" wb-prep:\"));\n\tif (len < sizeof(*prep)) {\n\t\treturn (-1);\n\t}\n\tn = EXTRACT_32BITS(&prep->pp_n);\n\tps = (const struct pgstate *)(prep + 1);\n\twhile (--n >= 0 && !ND_TTEST(*ps)) {\n\t\tconst struct id_off *io, *ie;\n\t\tchar c = '<';\n\t\tND_PRINT((ndo, \" %u/%s:%u\",\n\t\t    EXTRACT_32BITS(&ps->slot),\n\t\t    ipaddr_string(ndo, &ps->page.p_sid),\n\t\t    EXTRACT_32BITS(&ps->page.p_uid)));\n\t\tio = (struct id_off *)(ps + 1);\n\t\tfor (ie = io + ps->nid; io < ie && !ND_TTEST(*io); ++io) {\n\t\t\tND_PRINT((ndo, \"%c%s:%u\", c, ipaddr_string(ndo, &io->id),\n\t\t\t    EXTRACT_32BITS(&io->off)));\n\t\t\tc = ',';\n\t\t}\n\t\tND_PRINT((ndo, \">\"));\n\t\tps = (struct pgstate *)io;\n\t}\n\treturn ((u_char *)ps <= ep? 0 : -1);\n}", "target": 1}
{"code": "void cql_server::response::write_short_bytes(bytes b)\n{\n    write_short(cast_if_fits<uint16_t>(b.size()));\n    _body.write(b);\n}", "target": 0}
{"code": "socks_request_free(socks_request_t *req)\n{\n  if (!req)\n    return;\n  if (req->username) {\n    memwipe(req->username, 0x10, req->usernamelen);\n    tor_free(req->username);\n  }\n  if (req->password) {\n    memwipe(req->password, 0x04, req->passwordlen);\n    tor_free(req->password);\n  }\n  memwipe(req, 0xCC, sizeof(socks_request_t));\n  tor_free(req);\n}", "target": 0}
{"code": "static int mp_get_count(struct sb_uart_state *state, struct serial_icounter_struct *icnt)\n{\n\tstruct serial_icounter_struct icount;\n\tstruct sb_uart_icount cnow;\n\tstruct sb_uart_port *port = state->port;\n\tspin_lock_irq(&port->lock);\n\tmemcpy(&cnow, &port->icount, sizeof(struct sb_uart_icount));\n\tspin_unlock_irq(&port->lock);\n\ticount.cts         = cnow.cts;\n\ticount.dsr         = cnow.dsr;\n\ticount.rng         = cnow.rng;\n\ticount.dcd         = cnow.dcd;\n\ticount.rx          = cnow.rx;\n\ticount.tx          = cnow.tx;\n\ticount.frame       = cnow.frame;\n\ticount.overrun     = cnow.overrun;\n\ticount.parity      = cnow.parity;\n\ticount.brk         = cnow.brk;\n\ticount.buf_overrun = cnow.buf_overrun;\n\treturn copy_to_user(icnt, &icount, sizeof(icount)) ? -EFAULT : 0;\n}", "target": 1}
{"code": "inline bool canReadNElements(\n    NimbleProtocolReader& ,\n    uint32_t ,\n    std::initializer_list<detail::nimble::NimbleType> ) {\n  return true;\n}", "target": 0}
{"code": "struct xt_table_info *xt_alloc_table_info(unsigned int size)\n{\n\tstruct xt_table_info *info = NULL;\n\tsize_t sz = sizeof(*info) + size;\n\tif (sz < sizeof(*info))\n\t\treturn NULL;\n\tif ((SMP_ALIGN(size) >> PAGE_SHIFT) + 2 > totalram_pages)\n\t\treturn NULL;\n\tif (sz <= (PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER))\n\t\tinfo = kmalloc(sz, GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);\n\tif (!info) {\n\t\tinfo = vmalloc(sz);\n\t\tif (!info)\n\t\t\treturn NULL;\n\t}\n\tmemset(info, 0, sizeof(*info));\n\tinfo->size = size;\n\treturn info;\n}", "target": 0}
{"code": "Status Tensor::BuildTensor(DataType type, const TensorShape& shape,\n                           Tensor* out_tensor) {\n  CASES_WITH_DEFAULT(\n      type, {}, return errors::InvalidArgument(\"Type not set\"),\n      return errors::InvalidArgument(\"Unexpected type: \", DataType_Name(type)));\n  *out_tensor = Tensor(type, shape);\n  return Status::OK();\n}", "target": 0}
{"code": "static void process_request(struct connection *conn) {\n    num_requests++;\n    if (!parse_request(conn)) {\n        default_reply(conn, 400, \"Bad Request\",\n            \"You sent a request that the server couldn't understand.\");\n    }\n    else if (is_https_redirect(conn)) {\n        redirect_https(conn);\n    }\n    else if (auth_key != NULL &&\n            (conn->authorization == NULL ||\n             strcmp(conn->authorization, auth_key)))\n    {\n        default_reply(conn, 401, \"Unauthorized\",\n            \"Access denied due to invalid credentials.\");\n    }\n    else if (strcmp(conn->method, \"GET\") == 0) {\n        process_get(conn);\n    }\n    else if (strcmp(conn->method, \"HEAD\") == 0) {\n        process_get(conn);\n        conn->header_only = 1;\n    }\n    else {\n        default_reply(conn, 501, \"Not Implemented\",\n                      \"The method you specified is not implemented.\");\n    }\n    conn->state = SEND_HEADER;\n    free(conn->request);\n    conn->request = NULL; \n}", "target": 1}
{"code": "parse_io(VALUE klass, VALUE io, VALUE encoding)\n{\n  xmlParserCtxtPtr ctxt;\n  xmlCharEncoding enc = (xmlCharEncoding)NUM2INT(encoding);\n  if (!rb_respond_to(io, id_read)) {\n    rb_raise(rb_eTypeError, \"argument expected to respond to :read\");\n  }\n  ctxt = xmlCreateIOParserCtxt(NULL, NULL,\n                               (xmlInputReadCallback)noko_io_read,\n                               (xmlInputCloseCallback)noko_io_close,\n                               (void *)io, enc);\n  if (ctxt->sax) {\n    xmlFree(ctxt->sax);\n    ctxt->sax = NULL;\n  }\n  return Data_Wrap_Struct(klass, NULL, deallocate, ctxt);\n}", "target": 0}
{"code": "__attribute__((__always_inline__)) static inline void create_v4_hdr(\n    struct iphdr* iph,\n    __u8 tos,\n    __u32 saddr,\n    __u32 daddr,\n    __u16 pkt_bytes,\n    __u8 proto) {\n  __u64 csum = 0;\n  iph->version = 4;\n  iph->ihl = 5;\n  iph->frag_off = 0;\n  iph->protocol = proto;\n  iph->check = 0;\n#ifdef COPY_INNER_PACKET_TOS\n  iph->tos = tos;\n#else\n  iph->tos = DEFAULT_TOS;\n#endif\n  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));\n  iph->id = 0;\n  iph->daddr = daddr;\n  iph->saddr = saddr;\n  iph->ttl = DEFAULT_TTL;\n  ipv4_csum_inline(iph, &csum);\n  iph->check = csum;\n}", "target": 0}
{"code": "wsemul_sun_output_control(struct wsemul_sun_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tint oargs;\n\tint rc;\n\tswitch (instate->inchar) {\n\tcase '0': case '1': case '2': case '3': case '4': \n\tcase '5': case '6': case '7': case '8': case '9':\n\t\tif (edp->nargs > SUN_EMUL_NARGS - 1) {\n\t\t\tbcopy(edp->args + 1, edp->args,\n\t\t\t    (SUN_EMUL_NARGS - 1) * sizeof(edp->args[0]));\n\t\t\tedp->args[edp->nargs = SUN_EMUL_NARGS - 1] = 0;\n\t\t}\n\t\tedp->args[edp->nargs] = (edp->args[edp->nargs] * 10) +\n\t\t    (instate->inchar - '0');\n\t\tbreak;\n\tcase ';':\t\t\n\t\tedp->nargs++;\n\t\tbreak;\n\tdefault:\t\t\n\t\toargs = edp->nargs++;\n\t\tif (edp->nargs > SUN_EMUL_NARGS)\n\t\t\tedp->nargs = SUN_EMUL_NARGS;\n\t\trc = wsemul_sun_control(edp, instate);\n\t\tif (rc != 0) {\n\t\t\tedp->nargs = oargs;\n\t\t\treturn rc;\n\t\t}\n\t\tedp->state = SUN_EMUL_STATE_NORMAL;\n\t\tbreak;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static void ext_session_lock_v1_handle_finished(void *data, struct ext_session_lock_v1 *lock) {\n\tswaylock_log(LOG_ERROR, \"Failed to lock session -- \"\n\t\t\t\"is another lockscreen running?\");\n\texit(2);\n}", "target": 0}
{"code": "static int proc_cwd_link(struct dentry *dentry, struct path *path)\n{\n\tstruct task_struct *task = get_proc_task(dentry->d_inode);\n\tint result = -ENOENT;\n\tif (task) {\n\t\ttask_lock(task);\n\t\tif (task->fs) {\n\t\t\tget_fs_pwd(task->fs, path);\n\t\t\tresult = 0;\n\t\t}\n\t\ttask_unlock(task);\n\t\tput_task_struct(task);\n\t}\n\treturn result;\n}", "target": 0}
{"code": "static bool access_pmu_evcntr(struct kvm_vcpu *vcpu,\n\t\t\t      struct sys_reg_params *p,\n\t\t\t      const struct sys_reg_desc *r)\n{\n\tu64 idx;\n\tif (!kvm_arm_pmu_v3_ready(vcpu))\n\t\treturn trap_raz_wi(vcpu, p, r);\n\tif (r->CRn == 9 && r->CRm == 13) {\n\t\tif (r->Op2 == 2) {\n\t\t\tif (pmu_access_event_counter_el0_disabled(vcpu))\n\t\t\t\treturn false;\n\t\t\tidx = vcpu_sys_reg(vcpu, PMSELR_EL0)\n\t\t\t      & ARMV8_PMU_COUNTER_MASK;\n\t\t} else if (r->Op2 == 0) {\n\t\t\tif (pmu_access_cycle_counter_el0_disabled(vcpu))\n\t\t\t\treturn false;\n\t\t\tidx = ARMV8_PMU_CYCLE_IDX;\n\t\t} else {\n\t\t\tBUG();\n\t\t}\n\t} else if (r->CRn == 14 && (r->CRm & 12) == 8) {\n\t\tif (pmu_access_event_counter_el0_disabled(vcpu))\n\t\t\treturn false;\n\t\tidx = ((r->CRm & 3) << 3) | (r->Op2 & 7);\n\t} else {\n\t\tBUG();\n\t}\n\tif (!pmu_counter_idx_valid(vcpu, idx))\n\t\treturn false;\n\tif (p->is_write) {\n\t\tif (pmu_access_el0_disabled(vcpu))\n\t\t\treturn false;\n\t\tkvm_pmu_set_counter_value(vcpu, idx, p->regval);\n\t} else {\n\t\tp->regval = kvm_pmu_get_counter_value(vcpu, idx);\n\t}\n\treturn true;\n}", "target": 1}
{"code": "sctp_disposition_t sctp_sf_discard_chunk(struct net *net,\n\t\t\t\t\t const struct sctp_endpoint *ep,\n\t\t\t\t\t const struct sctp_association *asoc,\n\t\t\t\t\t const sctp_subtype_t type,\n\t\t\t\t\t void *arg,\n\t\t\t\t\t sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\tSCTP_DEBUG_PRINTK(\"Chunk %d is discarded\\n\", type.chunk);\n\treturn SCTP_DISPOSITION_DISCARD;\n}", "target": 0}
{"code": "struct nfc_llcp_local *nfc_llcp_local_get(struct nfc_llcp_local *local)\n{\n\tkref_get(&local->ref);\n\treturn local;\n}", "target": 1}
{"code": "static long do_locks(unsigned int fd, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct flock64 kernel;\n\tstruct oabi_flock64 user;\n\tmm_segment_t fs;\n\tlong ret;\n\tif (copy_from_user(&user, (struct oabi_flock64 __user *)arg,\n\t\t\t   sizeof(user)))\n\t\treturn -EFAULT;\n\tkernel.l_type\t= user.l_type;\n\tkernel.l_whence\t= user.l_whence;\n\tkernel.l_start\t= user.l_start;\n\tkernel.l_len\t= user.l_len;\n\tkernel.l_pid\t= user.l_pid;\n\tfs = get_fs();\n\tset_fs(KERNEL_DS);\n\tret = sys_fcntl64(fd, cmd, (unsigned long)&kernel);\n\tset_fs(fs);\n\tif (!ret && (cmd == F_GETLK64 || cmd == F_OFD_GETLK)) {\n\t\tuser.l_type\t= kernel.l_type;\n\t\tuser.l_whence\t= kernel.l_whence;\n\t\tuser.l_start\t= kernel.l_start;\n\t\tuser.l_len\t= kernel.l_len;\n\t\tuser.l_pid\t= kernel.l_pid;\n\t\tif (copy_to_user((struct oabi_flock64 __user *)arg,\n\t\t\t\t &user, sizeof(user)))\n\t\t\tret = -EFAULT;\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "static int fdt_check_no_at(const void *fit, int parent)\n{\n\tconst char *name;\n\tint node;\n\tint ret;\n\tname = fdt_get_name(fit, parent, NULL);\n\tif (!name || strchr(name, '@'))\n\t\treturn -EADDRNOTAVAIL;\n\tfdt_for_each_subnode(node, fit, parent) {\n\t\tret = fdt_check_no_at(fit, node);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static void check_file(char *basename)\n{\n    gdImagePtr im;\n    char *buffer;\n    size_t size;\n    size = read_test_file(&buffer, basename);\n    im = gdImageCreateFromTgaPtr(size, (void *) buffer);\n    gdTestAssert(im == NULL);\n    free(buffer);\n}", "target": 0}
{"code": "static LINK_HANDLE create_link(role link_role)\n{\n    umock_c_reset_all_calls();\n    STRICT_EXPECTED_CALL(gballoc_calloc(IGNORED_NUM_ARG, IGNORED_NUM_ARG));\n    STRICT_EXPECTED_CALL(amqpvalue_clone(IGNORED_PTR_ARG));\n    STRICT_EXPECTED_CALL(amqpvalue_clone(IGNORED_PTR_ARG));\n    STRICT_EXPECTED_CALL(tickcounter_create());\n    STRICT_EXPECTED_CALL(singlylinkedlist_create());\n    STRICT_EXPECTED_CALL(gballoc_malloc(IGNORED_NUM_ARG));\n    STRICT_EXPECTED_CALL(session_create_link_endpoint(TEST_SESSION_HANDLE, TEST_LINK_NAME_1));\n    STRICT_EXPECTED_CALL(session_set_link_endpoint_callback(TEST_LINK_ENDPOINT, IGNORED_PTR_ARG, IGNORED_PTR_ARG));\n    return link_create(TEST_SESSION_HANDLE, TEST_LINK_NAME_1, link_role, TEST_LINK_SOURCE, TEST_LINK_TARGET);\n}", "target": 0}
{"code": "smtp_log_to_file(smtp_t *smtp)\n{\n\tFILE *fp = fopen(\"/tmp/smtp-alert.log\", \"a\");\n\ttime_t now;\n\tstruct tm tm;\n\tchar time_buf[25];\n\tint time_buf_len;\n\ttime(&now);\n\tlocaltime_r(&now, &tm);\n\ttime_buf_len = strftime(time_buf, sizeof time_buf, \"%a %b %e %X %Y\", &tm);\n\tfprintf(fp, \"%s: %s -> %s\\n\"\n\t\t    \"%*sSubject: %s\\n\"\n\t\t    \"%*sBody:    %s\\n\\n\",\n\t\t    time_buf, global_data->email_from, smtp->email_to,\n\t\t    time_buf_len - 7, \"\", smtp->subject,\n\t\t    time_buf_len - 7, \"\", smtp->body);\n\tfclose(fp);\n\tfree_smtp_all(smtp);\n}", "target": 1}
{"code": "static int atalk_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tint rc = -ENOIOCTLCMD;\n\tstruct sock *sk = sock->sk;\n\tvoid __user *argp = (void __user *)arg;\n\tswitch (cmd) {\n\tcase TIOCOUTQ: {\n\t\tlong amount = sk->sk_sndbuf - sk_wmem_alloc_get(sk);\n\t\tif (amount < 0)\n\t\t\tamount = 0;\n\t\trc = put_user(amount, (int __user *)argp);\n\t\tbreak;\n\t}\n\tcase TIOCINQ: {\n\t\tstruct sk_buff *skb = skb_peek(&sk->sk_receive_queue);\n\t\tlong amount = 0;\n\t\tif (skb)\n\t\t\tamount = skb->len - sizeof(struct ddpehdr);\n\t\trc = put_user(amount, (int __user *)argp);\n\t\tbreak;\n\t}\n\tcase SIOCADDRT:\n\tcase SIOCDELRT:\n\t\trc = -EPERM;\n\t\tif (capable(CAP_NET_ADMIN))\n\t\t\trc = atrtr_ioctl(cmd, argp);\n\t\tbreak;\n\tcase SIOCGIFADDR:\n\tcase SIOCSIFADDR:\n\tcase SIOCGIFBRDADDR:\n\tcase SIOCATALKDIFADDR:\n\tcase SIOCDIFADDR:\n\tcase SIOCSARP:\t\t\n\tcase SIOCDARP:\t\t\n\t\trtnl_lock();\n\t\trc = atif_ioctl(cmd, argp);\n\t\trtnl_unlock();\n\t\tbreak;\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "userauth_gssapi(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tgss_OID_desc goid = {0, NULL};\n\tGssctxt *ctxt = NULL;\n\tint r, present;\n\tu_int mechs;\n\tOM_uint32 ms;\n\tsize_t len;\n\tu_char *doid = NULL;\n\tif (!authctxt->valid || authctxt->user == NULL)\n\t\treturn (0);\n\tif ((r = sshpkt_get_u32(ssh, &mechs)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\tif (mechs == 0) {\n\t\tdebug(\"Mechanism negotiation is not supported\");\n\t\treturn (0);\n\t}\n\tdo {\n\t\tmechs--;\n\t\tfree(doid);\n\t\tpresent = 0;\n\t\tif ((r = sshpkt_get_string(ssh, &doid, &len)) != 0)\n\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\t\tif (len > 2 && doid[0] == SSH_GSS_OIDTYPE &&\n\t\t    doid[1] == len - 2) {\n\t\t\tgoid.elements = doid + 2;\n\t\t\tgoid.length   = len - 2;\n\t\t\tssh_gssapi_test_oid_supported(&ms, &goid, &present);\n\t\t} else {\n\t\t\tlogit(\"Badly formed OID received\");\n\t\t}\n\t} while (mechs > 0 && !present);\n\tif (!present) {\n\t\tfree(doid);\n\t\tauthctxt->server_caused_failure = 1;\n\t\treturn (0);\n\t}\n\tif (GSS_ERROR(PRIVSEP(ssh_gssapi_server_ctx(&ctxt, &goid)))) {\n\t\tif (ctxt != NULL)\n\t\t\tssh_gssapi_delete_ctx(&ctxt);\n\t\tfree(doid);\n\t\tauthctxt->server_caused_failure = 1;\n\t\treturn (0);\n\t}\n\tauthctxt->methoddata = (void *)ctxt;\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_GSSAPI_RESPONSE)) != 0 ||\n\t    (r = sshpkt_put_string(ssh, doid, len)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\tfree(doid);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_TOKEN, &input_gssapi_token);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_ERRTOK, &input_gssapi_errtok);\n\tauthctxt->postponed = 1;\n\treturn (0);\n}", "target": 1}
{"code": "static int __f2fs_set_acl(struct inode *inode, int type,\n\t\t\tstruct posix_acl *acl, struct page *ipage)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t\tset_acl_inode(inode, inode->i_mode);\n\t\t\tif (error == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tvalue = f2fs_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value)) {\n\t\t\tclear_inode_flag(inode, FI_ACL_MODE);\n\t\t\treturn (int)PTR_ERR(value);\n\t\t}\n\t}\n\terror = f2fs_setxattr(inode, name_index, \"\", value, size, ipage, 0);\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\tclear_inode_flag(inode, FI_ACL_MODE);\n\treturn error;\n}", "target": 1}
{"code": "Status IndexedDBDatabase::DeleteIndexOperation(\n    int64_t object_store_id,\n    int64_t index_id,\n    IndexedDBTransaction* transaction) {\n  IDB_TRACE1(\n      \"IndexedDBDatabase::DeleteIndexOperation\", \"txn.id\", transaction->id());\n  IndexedDBIndexMetadata index_metadata =\n      RemoveIndex(object_store_id, index_id);\n  Status s = metadata_coding_->DeleteIndex(\n      transaction->BackingStoreTransaction()->transaction(),\n      transaction->database()->id(), object_store_id, index_metadata);\n  if (!s.ok())\n    return s;\n  s = backing_store_->ClearIndex(transaction->BackingStoreTransaction(),\n                                 transaction->database()->id(), object_store_id,\n                                 index_id);\n  if (!s.ok()) {\n    AddIndex(object_store_id, std::move(index_metadata),\n             IndexedDBIndexMetadata::kInvalidId);\n    return s;\n  }\n  transaction->ScheduleAbortTask(\n      base::BindOnce(&IndexedDBDatabase::DeleteIndexAbortOperation, this,\n                     object_store_id, std::move(index_metadata)));\n  return s;\n}", "target": 0}
{"code": "static inline bool mmget_still_valid(struct mm_struct *mm)\n{\n\treturn likely(!mm->core_state);\n}", "target": 0}
{"code": "std::string Network::GetErrorString() const {\n  switch (error_) {\n    case ERROR_UNKNOWN:\n      return l10n_util::GetStringUTF8(IDS_CHROMEOS_NETWORK_ERROR_UNKNOWN);\n    case ERROR_OUT_OF_RANGE:\n      return l10n_util::GetStringUTF8(IDS_CHROMEOS_NETWORK_ERROR_OUT_OF_RANGE);\n    case ERROR_PIN_MISSING:\n      return l10n_util::GetStringUTF8(IDS_CHROMEOS_NETWORK_ERROR_PIN_MISSING);\n    case ERROR_DHCP_FAILED:\n      return l10n_util::GetStringUTF8(IDS_CHROMEOS_NETWORK_ERROR_DHCP_FAILED);\n    case ERROR_CONNECT_FAILED:\n      return l10n_util::GetStringUTF8(\n          IDS_CHROMEOS_NETWORK_ERROR_CONNECT_FAILED);\n    case ERROR_BAD_PASSPHRASE:\n      return l10n_util::GetStringUTF8(\n          IDS_CHROMEOS_NETWORK_ERROR_BAD_PASSPHRASE);\n    case ERROR_BAD_WEPKEY:\n      return l10n_util::GetStringUTF8(IDS_CHROMEOS_NETWORK_ERROR_BAD_WEPKEY);\n    case ERROR_ACTIVATION_FAILED:\n      return l10n_util::GetStringUTF8(\n          IDS_CHROMEOS_NETWORK_ERROR_ACTIVATION_FAILED);\n    case ERROR_NEED_EVDO:\n      return l10n_util::GetStringUTF8(IDS_CHROMEOS_NETWORK_ERROR_NEED_EVDO);\n    case ERROR_NEED_HOME_NETWORK:\n      return l10n_util::GetStringUTF8(\n          IDS_CHROMEOS_NETWORK_ERROR_NEED_HOME_NETWORK);\n    case ERROR_OTASP_FAILED:\n      return l10n_util::GetStringUTF8(IDS_CHROMEOS_NETWORK_ERROR_OTASP_FAILED);\n    case ERROR_AAA_FAILED:\n      return l10n_util::GetStringUTF8(IDS_CHROMEOS_NETWORK_ERROR_AAA_FAILED);\n    default:\n      break;\n  }\n  return l10n_util::GetStringUTF8(IDS_CHROMEOS_NETWORK_STATE_UNRECOGNIZED);\n}", "target": 0}
{"code": "static void ok_jpg_idct_16x16(const int16_t *input, uint8_t *output) {\n    int temp[8 * 16];\n    ok_jpg_idct_1d_col_16(input, temp);\n    ok_jpg_idct_1d_row_16(16, temp, output);\n}", "target": 0}
{"code": "MONGO_EXPORT int mongo_run_command( mongo *conn, const char *db, const bson *command,\n                                    bson *out ) {\n    int ret = MONGO_OK;\n    bson response = {NULL, 0};\n    bson fields;\n    int sl = strlen( db );\n    char *ns = bson_malloc( sl + 5 + 1 ); \n    int res, success = 0;\n    strcpy( ns, db );\n    strcpy( ns+sl, \".$cmd\" );\n    res = mongo_find_one( conn, ns, command, bson_empty( &fields ), &response );\n    bson_free( ns );\n    if( res != MONGO_OK )\n        ret = MONGO_ERROR;\n    else {\n        bson_iterator it;\n        if( bson_find( &it, &response, \"ok\" ) )\n            success = bson_iterator_bool( &it );\n        if( !success ) {\n            conn->err = MONGO_COMMAND_FAILED;\n            bson_destroy( &response );\n            ret = MONGO_ERROR;\n        }\n        else {\n            if( out )\n                *out = response;\n            else\n                bson_destroy( &response );\n        }\n    }\n    return ret;\n}", "target": 1}
{"code": "njs_function_frame_free(njs_vm_t *vm, njs_native_frame_t *native)\n{\n    njs_native_frame_t  *previous;\n    do {\n        previous = native->previous;\n        if (native->size != 0) {\n            vm->stack_size -= native->size;\n            njs_mp_free(vm->mem_pool, native);\n        }\n        native = previous;\n    } while (native->skip);\n}", "target": 0}
{"code": "int gru_set_context_option(unsigned long arg)\n{\n\tstruct gru_thread_state *gts;\n\tstruct gru_set_context_option_req req;\n\tint ret = 0;\n\tSTAT(set_context_option);\n\tif (copy_from_user(&req, (void __user *)arg, sizeof(req)))\n\t\treturn -EFAULT;\n\tgru_dbg(grudev, \"op %d, gseg 0x%lx, value1 0x%lx\\n\", req.op, req.gseg, req.val1);\n\tgts = gru_find_lock_gts(req.gseg);\n\tif (!gts) {\n\t\tgts = gru_alloc_locked_gts(req.gseg);\n\t\tif (IS_ERR(gts))\n\t\t\treturn PTR_ERR(gts);\n\t}\n\tswitch (req.op) {\n\tcase sco_blade_chiplet:\n\t\tif (req.val0 < -1 || req.val0 >= GRU_CHIPLETS_PER_HUB ||\n\t\t    req.val1 < -1 || req.val1 >= GRU_MAX_BLADES ||\n\t\t    (req.val1 >= 0 && !gru_base[req.val1])) {\n\t\t\tret = -EINVAL;\n\t\t} else {\n\t\t\tgts->ts_user_blade_id = req.val1;\n\t\t\tgts->ts_user_chiplet_id = req.val0;\n\t\t\tgru_check_context_placement(gts);\n\t\t}\n\t\tbreak;\n\tcase sco_gseg_owner:\n\t\tgts->ts_tgid_owner = current->tgid;\n\t\tbreak;\n\tcase sco_cch_req_slice:\n\t\tgts->ts_cch_req_slice = req.val1 & 3;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tgru_unlock_gts(gts);\n\treturn ret;\n}", "target": 1}
{"code": "struct resource_pool *dce112_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\tif (!pool)\n\t\treturn NULL;\n\tif (construct(num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\tkfree(pool);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 0}
{"code": "  static void launch(OpKernelContext* context, const PoolParameters& params,\n                     const Tensor& grad_in, const Tensor& argmax,\n                     Tensor* grad_out, const bool include_batch_in_index) {\n    const DeviceBase::CpuWorkerThreads& worker_threads =\n        *(context->device()->tensorflow_cpu_worker_threads());\n    auto shard = [&grad_in, &argmax, &grad_out, include_batch_in_index](\n                     int64 start, int64 limit) {\n      const int64 batch_size =\n          GetTensorDim(grad_out->shape(), FORMAT_NHWC, 'N');\n      const int64 output_size_per_batch = grad_out->NumElements() / batch_size;\n      const int64 input_size_per_batch = grad_in.NumElements() / batch_size;\n      {\n        auto grad_out_flat = grad_out->flat<T>();\n        auto argmax_flat = argmax.flat<int64>();\n        auto grad_in_flat = grad_in.flat<T>();\n        const int64 output_start = start * output_size_per_batch;\n        const int64 output_end = limit * output_size_per_batch;\n        EigenMatrixMap inputShard(grad_out_flat.data() + output_start, 1,\n                                  output_end - output_start);\n        inputShard.setConstant(T(0));\n        const int input_start = start * input_size_per_batch;\n        const int input_end = limit * input_size_per_batch;\n        for (int64 index = input_start; index < input_end; index++) {\n          if (index >= argmax.NumElements()) {\n            break;\n          }\n          int64 grad_out_index = argmax_flat(index);\n          if (!include_batch_in_index) {\n            const int64 cur_batch = index / input_size_per_batch;\n            grad_out_index += cur_batch * output_size_per_batch;\n          }\n          CHECK(grad_out_index >= output_start && grad_out_index < output_end)\n              << \"Invalid output gradient index: \" << grad_out_index << \", \"\n              << output_start << \", \" << output_end;\n          grad_out_flat(grad_out_index) += grad_in_flat(index);\n        }\n      }\n    };\n    const int64 batch_size = GetTensorDim(grad_out->shape(), FORMAT_NHWC, 'N');\n    const int64 shard_cost = grad_out->NumElements() / batch_size;\n    Shard(worker_threads.num_threads, worker_threads.workers, batch_size,\n          shard_cost, shard);\n  }", "target": 0}
{"code": "size_t TensorSliceWriter::MaxBytesPerElementOrZero(DataType dt) {\n  switch (dt) {\n    case DT_FLOAT:\n      return 4;\n    case DT_DOUBLE:\n      return 8;\n    case DT_INT32:\n      return 10;\n    case DT_UINT8:\n      return 2;\n    case DT_INT16:\n      return 10;\n    case DT_INT8:\n      return 10;\n    case DT_COMPLEX64:\n      return 8;\n    case DT_INT64:\n      return 10;\n    case DT_BOOL:\n      return 1;\n    case DT_QINT8:\n      return 10;\n    case DT_QUINT8:\n      return 2;\n    case DT_QINT32:\n      return 10;\n    case DT_QINT16:\n      return 10;\n    case DT_QUINT16:\n      return 3;\n    case DT_UINT16:\n      return 3;\n    case DT_COMPLEX128:\n      return 16;\n    case DT_HALF:\n      return 3;\n    case DT_INVALID:\n    case DT_STRING:\n    case DT_BFLOAT16:\n    default:\n      return 0;\n  }\n}", "target": 0}
{"code": "int ziplistSafeToAdd(unsigned char* zl, size_t add) {\n    size_t len = zl? ziplistBlobLen(zl): 0;\n    if (len + add > ZIPLIST_MAX_SAFETY_SIZE)\n        return 0;\n    return 1;\n}", "target": 0}
{"code": "static inline __u32 secure_dccpv6_sequence_number(__be32 *saddr, __be32 *daddr,\n\t\t\t\t\t\t  __be16 sport, __be16 dport   )\n{\n\treturn secure_tcpv6_sequence_number(saddr, daddr, sport, dport);\n}", "target": 1}
{"code": "activate_desktop_file (ActivateParameters *parameters,\n                       NautilusFile       *file)\n{\n    ActivateParametersDesktop *parameters_desktop;\n    char *primary, *secondary, *display_name;\n    GtkWidget *dialog;\n    GdkScreen *screen;\n    char *uri;\n    screen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window));\n    if (!nautilus_file_is_trusted_link (file))\n    {\n        parameters_desktop = g_new0 (ActivateParametersDesktop, 1);\n        if (parameters->parent_window)\n        {\n            parameters_desktop->parent_window = parameters->parent_window;\n            g_object_add_weak_pointer (G_OBJECT (parameters_desktop->parent_window), (gpointer *) &parameters_desktop->parent_window);\n        }\n        parameters_desktop->file = nautilus_file_ref (file);\n        primary = _(\"Untrusted application launcher\");\n        display_name = nautilus_file_get_display_name (file);\n        secondary =\n            g_strdup_printf (_(\"The application launcher “%s” has not been marked as trusted. \"\n                               \"If you do not know the source of this file, launching it may be unsafe.\"\n                               ),\n                             display_name);\n        dialog = gtk_message_dialog_new (parameters->parent_window,\n                                         0,\n                                         GTK_MESSAGE_WARNING,\n                                         GTK_BUTTONS_NONE,\n                                         NULL);\n        g_object_set (dialog,\n                      \"text\", primary,\n                      \"secondary-text\", secondary,\n                      NULL);\n        gtk_dialog_add_button (GTK_DIALOG (dialog),\n                               _(\"_Launch Anyway\"), RESPONSE_RUN);\n        if (nautilus_file_can_set_permissions (file))\n        {\n            gtk_dialog_add_button (GTK_DIALOG (dialog),\n                                   _(\"Mark as _Trusted\"), RESPONSE_MARK_TRUSTED);\n        }\n        gtk_dialog_add_button (GTK_DIALOG (dialog),\n                               _(\"_Cancel\"), GTK_RESPONSE_CANCEL);\n        gtk_dialog_set_default_response (GTK_DIALOG (dialog), GTK_RESPONSE_CANCEL);\n        g_signal_connect (dialog, \"response\",\n                          G_CALLBACK (untrusted_launcher_response_callback),\n                          parameters_desktop);\n        gtk_widget_show (dialog);\n        g_free (display_name);\n        g_free (secondary);\n        return;\n    }\n    uri = nautilus_file_get_uri (file);\n    DEBUG (\"Launching trusted launcher %s\", uri);\n    nautilus_launch_desktop_file (screen, uri, NULL,\n                                  parameters->parent_window);\n    g_free (uri);\n}", "target": 1}
{"code": "static int hwsim_new_radio_nl(struct sk_buff *msg, struct genl_info *info)\n{\n\tstruct hwsim_new_radio_params param = { 0 };\n\tconst char *hwname = NULL;\n\tint ret;\n\tparam.reg_strict = info->attrs[HWSIM_ATTR_REG_STRICT_REG];\n\tparam.p2p_device = info->attrs[HWSIM_ATTR_SUPPORT_P2P_DEVICE];\n\tparam.channels = channels;\n\tparam.destroy_on_close =\n\t\tinfo->attrs[HWSIM_ATTR_DESTROY_RADIO_ON_CLOSE];\n\tif (info->attrs[HWSIM_ATTR_CHANNELS])\n\t\tparam.channels = nla_get_u32(info->attrs[HWSIM_ATTR_CHANNELS]);\n\tif (info->attrs[HWSIM_ATTR_NO_VIF])\n\t\tparam.no_vif = true;\n\tif (info->attrs[HWSIM_ATTR_RADIO_NAME]) {\n\t\thwname = kasprintf(GFP_KERNEL, \"%.*s\",\n\t\t\t\t   nla_len(info->attrs[HWSIM_ATTR_RADIO_NAME]),\n\t\t\t\t   (char *)nla_data(info->attrs[HWSIM_ATTR_RADIO_NAME]));\n\t\tif (!hwname)\n\t\t\treturn -ENOMEM;\n\t\tparam.hwname = hwname;\n\t}\n\tif (info->attrs[HWSIM_ATTR_USE_CHANCTX])\n\t\tparam.use_chanctx = true;\n\telse\n\t\tparam.use_chanctx = (param.channels > 1);\n\tif (info->attrs[HWSIM_ATTR_REG_HINT_ALPHA2])\n\t\tparam.reg_alpha2 =\n\t\t\tnla_data(info->attrs[HWSIM_ATTR_REG_HINT_ALPHA2]);\n\tif (info->attrs[HWSIM_ATTR_REG_CUSTOM_REG]) {\n\t\tu32 idx = nla_get_u32(info->attrs[HWSIM_ATTR_REG_CUSTOM_REG]);\n\t\tif (idx >= ARRAY_SIZE(hwsim_world_regdom_custom))\n\t\t\treturn -EINVAL;\n\t\tparam.regd = hwsim_world_regdom_custom[idx];\n\t}\n\tret = mac80211_hwsim_new_radio(info, &param);\n\tkfree(hwname);\n\treturn ret;\n}", "target": 1}
{"code": "bool ReadDictionaryValue(const Message* m, PickleIterator* iter,\n                         DictionaryValue* value, int recursion) {\n  int size;\n  if (!ReadParam(m, iter, &size))\n    return false;\n  for (int i = 0; i < size; ++i) {\n    std::string key;\n    Value* subval;\n    if (!ReadParam(m, iter, &key) ||\n        !ReadValue(m, iter, &subval, recursion + 1))\n      return false;\n    value->SetWithoutPathExpansion(key, subval);\n  }\n  return true;\n}", "target": 0}
{"code": "void RootWindow::SetHostSize(const gfx::Size& size_in_pixel) {\n  DispatchHeldMouseMove();\n  gfx::Rect bounds = host_->GetBounds();\n  bounds.set_size(size_in_pixel);\n  host_->SetBounds(bounds);\n  last_mouse_location_ =\n      ui::ConvertPointToDIP(layer(), host_->QueryMouseLocation());\n  synthesize_mouse_move_ = false;\n}", "target": 0}
{"code": "static long madvise_willneed(struct vm_area_struct *vma,\n\t\t\t     struct vm_area_struct **prev,\n\t\t\t     unsigned long start, unsigned long end)\n{\n\tstruct file *file = vma->vm_file;\n#ifdef CONFIG_SWAP\n\tif (!file) {\n\t\t*prev = vma;\n\t\tforce_swapin_readahead(vma, start, end);\n\t\treturn 0;\n\t}\n\tif (shmem_mapping(file->f_mapping)) {\n\t\t*prev = vma;\n\t\tforce_shm_swapin_readahead(vma, start, end,\n\t\t\t\t\tfile->f_mapping);\n\t\treturn 0;\n\t}\n#else\n\tif (!file)\n\t\treturn -EBADF;\n#endif\n\tif (IS_DAX(file_inode(file))) {\n\t\treturn 0;\n\t}\n\t*prev = vma;\n\tstart = ((start - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\tif (end > vma->vm_end)\n\t\tend = vma->vm_end;\n\tend = ((end - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\tforce_page_cache_readahead(file->f_mapping, file, start, end - start);\n\treturn 0;\n}", "target": 1}
{"code": "static int hci_sock_getname(struct socket *sock, struct sockaddr *addr,\n\t\t\t    int *addr_len, int peer)\n{\n\tstruct sockaddr_hci *haddr = (struct sockaddr_hci *) addr;\n\tstruct sock *sk = sock->sk;\n\tstruct hci_dev *hdev = hci_pi(sk)->hdev;\n\tBT_DBG(\"sock %p sk %p\", sock, sk);\n\tif (!hdev)\n\t\treturn -EBADFD;\n\tlock_sock(sk);\n\t*addr_len = sizeof(*haddr);\n\thaddr->hci_family = AF_BLUETOOTH;\n\thaddr->hci_dev    = hdev->id;\n\thaddr->hci_channel= 0;\n\trelease_sock(sk);\n\treturn 0;\n}", "target": 0}
{"code": "R_API int r_socket_ready(RSocket *s, int secs, int usecs) {\n#if __UNIX__\n\tint msecs = (usecs / 1000);\n\tstruct pollfd fds[1];\n\tfds[0].fd = s->fd;\n\tfds[0].events = POLLIN | POLLPRI;\n\tfds[0].revents = POLLNVAL | POLLHUP | POLLERR;\n\treturn poll ((struct pollfd *)&fds, 1, msecs);\n#elif __WINDOWS__\n\tfd_set rfds;\n\tstruct timeval tv;\n\tif (s->fd == R_INVALID_SOCKET) {\n\t\treturn -1;\n\t}\n\tFD_ZERO (&rfds);\n\tFD_SET (s->fd, &rfds);\n\ttv.tv_sec = secs;\n\ttv.tv_usec = usecs;\n\treturn select (s->fd + 1, &rfds, NULL, NULL, &tv);\n#else\n\treturn true; \n#endif\n}", "target": 1}
{"code": "int processCommand(redisClient *c) {\n    struct redisCommand *cmd;\n    if (!strcasecmp(c->argv[0]->ptr,\"quit\")) {\n        addReply(c,shared.ok);\n        c->flags |= REDIS_CLOSE_AFTER_REPLY;\n        return REDIS_ERR;\n    }\n    cmd = lookupCommand(c->argv[0]->ptr);\n    if (!cmd) {\n        addReplyErrorFormat(c,\"unknown command '%s'\",\n            (char*)c->argv[0]->ptr);\n        return REDIS_OK;\n    } else if ((cmd->arity > 0 && cmd->arity != c->argc) ||\n               (c->argc < -cmd->arity)) {\n        addReplyErrorFormat(c,\"wrong number of arguments for '%s' command\",\n            cmd->name);\n        return REDIS_OK;\n    }\n    if (server.requirepass && !c->authenticated && cmd->proc != authCommand) {\n        addReplyError(c,\"operation not permitted\");\n        return REDIS_OK;\n    }\n    if (server.maxmemory) freeMemoryIfNeeded();\n    if (server.maxmemory && (cmd->flags & REDIS_CMD_DENYOOM) &&\n        zmalloc_used_memory() > server.maxmemory)\n    {\n        addReplyError(c,\"command not allowed when used memory > 'maxmemory'\");\n        return REDIS_OK;\n    }\n    if ((dictSize(c->pubsub_channels) > 0 || listLength(c->pubsub_patterns) > 0)\n        &&\n        cmd->proc != subscribeCommand && cmd->proc != unsubscribeCommand &&\n        cmd->proc != psubscribeCommand && cmd->proc != punsubscribeCommand) {\n        addReplyError(c,\"only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context\");\n        return REDIS_OK;\n    }\n    if (server.masterhost && server.replstate != REDIS_REPL_CONNECTED &&\n        server.repl_serve_stale_data == 0 &&\n        cmd->proc != infoCommand && cmd->proc != slaveofCommand)\n    {\n        addReplyError(c,\n            \"link with MASTER is down and slave-serve-stale-data is set to no\");\n        return REDIS_OK;\n    }\n    if (server.loading && cmd->proc != infoCommand) {\n        addReply(c, shared.loadingerr);\n        return REDIS_OK;\n    }\n    if (c->flags & REDIS_MULTI &&\n        cmd->proc != execCommand && cmd->proc != discardCommand &&\n        cmd->proc != multiCommand && cmd->proc != watchCommand)\n    {\n        queueMultiCommand(c,cmd);\n        addReply(c,shared.queued);\n    } else {\n        if (server.vm_enabled && server.vm_max_threads > 0 &&\n            blockClientOnSwappedKeys(c,cmd)) return REDIS_ERR;\n        call(c,cmd);\n    }\n    return REDIS_OK;\n}", "target": 1}
{"code": "static int handle_emulation_failure(struct kvm_vcpu *vcpu)\n{\n\tint r = EMULATE_DONE;\n\t++vcpu->stat.insn_emulation_fail;\n\ttrace_kvm_emulate_insn_failed(vcpu);\n\tif (!is_guest_mode(vcpu) && kvm_x86_ops->get_cpl(vcpu) == 0) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;\n\t\tvcpu->run->internal.ndata = 0;\n\t\tr = EMULATE_FAIL;\n\t}\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\treturn r;\n}", "target": 0}
{"code": "static long __snd_timer_user_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct snd_timer_user *tu;\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *p = argp;\n\ttu = file->private_data;\n\tswitch (cmd) {\n\tcase SNDRV_TIMER_IOCTL_PVERSION:\n\t\treturn put_user(SNDRV_TIMER_VERSION, p) ? -EFAULT : 0;\n\tcase SNDRV_TIMER_IOCTL_NEXT_DEVICE:\n\t\treturn snd_timer_user_next_device(argp);\n\tcase SNDRV_TIMER_IOCTL_TREAD:\n\t{\n\t\tint xarg;\n\t\tif (tu->timeri)\t\n\t\t\treturn -EBUSY;\n\t\tif (get_user(xarg, p))\n\t\t\treturn -EFAULT;\n\t\ttu->tread = xarg ? 1 : 0;\n\t\treturn 0;\n\t}\n\tcase SNDRV_TIMER_IOCTL_GINFO:\n\t\treturn snd_timer_user_ginfo(file, argp);\n\tcase SNDRV_TIMER_IOCTL_GPARAMS:\n\t\treturn snd_timer_user_gparams(file, argp);\n\tcase SNDRV_TIMER_IOCTL_GSTATUS:\n\t\treturn snd_timer_user_gstatus(file, argp);\n\tcase SNDRV_TIMER_IOCTL_SELECT:\n\t\treturn snd_timer_user_tselect(file, argp);\n\tcase SNDRV_TIMER_IOCTL_INFO:\n\t\treturn snd_timer_user_info(file, argp);\n\tcase SNDRV_TIMER_IOCTL_PARAMS:\n\t\treturn snd_timer_user_params(file, argp);\n\tcase SNDRV_TIMER_IOCTL_STATUS:\n\t\treturn snd_timer_user_status(file, argp);\n\tcase SNDRV_TIMER_IOCTL_START:\n\tcase SNDRV_TIMER_IOCTL_START_OLD:\n\t\treturn snd_timer_user_start(file);\n\tcase SNDRV_TIMER_IOCTL_STOP:\n\tcase SNDRV_TIMER_IOCTL_STOP_OLD:\n\t\treturn snd_timer_user_stop(file);\n\tcase SNDRV_TIMER_IOCTL_CONTINUE:\n\tcase SNDRV_TIMER_IOCTL_CONTINUE_OLD:\n\t\treturn snd_timer_user_continue(file);\n\tcase SNDRV_TIMER_IOCTL_PAUSE:\n\tcase SNDRV_TIMER_IOCTL_PAUSE_OLD:\n\t\treturn snd_timer_user_pause(file);\n\t}\n\treturn -ENOTTY;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& shape_t = ctx->input(0);\n    const Tensor& rate_t = ctx->input(1);\n    TensorShape samples_shape;\n    OP_REQUIRES_OK(ctx, tensor::MakeShape(shape_t, &samples_shape));\n    const int64_t num_samples = samples_shape.num_elements();\n    samples_shape.AppendShape(rate_t.shape());\n    Tensor* samples_t = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, samples_shape, &samples_t));\n    if (num_samples == 0) return;\n    const auto rate_flat = rate_t.flat<T>().data();\n    const int64_t num_rate = rate_t.NumElements();\n    auto samples_flat = samples_t->flat<U>().data();\n    random::PhiloxRandom rng = generator_.ReserveRandomOutputs(\n        num_samples * num_rate, kReservedSamplesPerOutput);\n    functor::PoissonFunctor<CPUDevice, T, U>()(\n        ctx, ctx->eigen_device<CPUDevice>(), rate_flat, num_rate, num_samples,\n        rng, samples_flat);\n  }", "target": 1}
{"code": "ECDSA_Signature_Operation::raw_sign(const uint8_t msg[], size_t msg_len,\n                                    RandomNumberGenerator& rng)\n   {\n   BigInt m(msg, msg_len, m_group.get_order_bits());\n#if defined(BOTAN_HAS_RFC6979_GENERATOR)\n   const BigInt k = generate_rfc6979_nonce(m_x, m_group.get_order(), m, m_rfc6979_hash);\n#else\n   const BigInt k = m_group.random_scalar(rng);\n#endif\n   const BigInt k_inv = m_group.inverse_mod_order(k);\n   const BigInt r = m_group.mod_order(\n      m_group.blinded_base_point_multiply_x(k, rng, m_ws));\n   const BigInt xrm = m_group.mod_order(m_group.multiply_mod_order(m_x, r) + m);\n   const BigInt s = m_group.multiply_mod_order(k_inv, xrm);\n   if(r.is_zero() || s.is_zero())\n      throw Internal_Error(\"During ECDSA signature generated zero r/s\");\n   return BigInt::encode_fixed_length_int_pair(r, s, m_group.get_order_bytes());\n   }", "target": 1}
{"code": "static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof TSRMLS_DC)\n{\n\tchar *ksep, *vsep, *val;\n\tsize_t klen, vlen;\n\tunsigned int new_vlen;\n\tif (var->ptr >= var->end) {\n\t\treturn 0;\n\t}\n\tvsep = memchr(var->ptr, '&', var->end - var->ptr);\n\tif (!vsep) {\n\t\tif (!eof) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tvsep = var->end;\n\t\t}\n\t}\n\tksep = memchr(var->ptr, '=', vsep - var->ptr);\n\tif (ksep) {\n\t\t*ksep = '\\0';\n\t\tklen = ksep - var->ptr;\n\t\tvlen = vsep - ++ksep;\n\t} else {\n\t\tksep = \"\";\n\t\tklen = vsep - var->ptr;\n\t\tvlen = 0;\n\t}\n\tphp_url_decode(var->ptr, klen);\n\tval = estrndup(ksep, vlen);\n\tif (vlen) {\n\t\tvlen = php_url_decode(val, vlen);\n\t}\n\tif (sapi_module.input_filter(PARSE_POST, var->ptr, &val, vlen, &new_vlen TSRMLS_CC)) {\n\t\tphp_register_variable_safe(var->ptr, val, new_vlen, arr TSRMLS_CC);\n\t}\n\tefree(val);\n\tvar->ptr = vsep + (vsep != var->end);\n\treturn 1;\n}", "target": 1}
{"code": "void WebGLRenderingContextBase::PushFrame() {\n  if (!marked_canvas_dirty_)\n    return;\n  marked_canvas_dirty_ = false;\n  int width = GetDrawingBuffer()->Size().Width();\n  int height = GetDrawingBuffer()->Size().Height();\n  if (!GetDrawingBuffer()) {\n    return Host()->PushFrame(nullptr, SkIRect::MakeWH(width, height));\n  }\n  std::unique_ptr<viz::SingleReleaseCallback> image_release_callback;\n  scoped_refptr<StaticBitmapImage> image =\n      GetStaticBitmapImage(&image_release_callback);\n  GetDrawingBuffer()->SwapPreviousFrameCallback(\n      std::move(image_release_callback));\n  return Host()->PushFrame(std::move(image), SkIRect::MakeWH(width, height));\n}", "target": 0}
{"code": "TfLiteIntArray* TfLiteIntArrayCreate(int size) {\n  size_t alloc_size = TfLiteIntArrayGetSizeInBytes(size);\n  if (alloc_size <= 0) return NULL;\n  TfLiteIntArray* ret = (TfLiteIntArray*)malloc(alloc_size);\n  if (!ret) return ret;\n  ret->size = size;\n  return ret;\n}", "target": 0}
{"code": "static int getSingletonPos(const char* str)\n{\n\tint result =-1;\n\tint i=0;\n\tint len = 0;\n\tif( str && ((len=strlen(str))>0) ){\n\t\tfor( i=0; i<len ; i++){\n\t\t\tif( isIDSeparator(*(str+i)) ){\n\t\t\t\tif( i==1){\n\t\t\t\t\tresult =0;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tif( isIDSeparator(*(str+i+2)) ){\n\t\t\t\t\t\tresult = i+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "target": 1}
{"code": "horizontalDifference16(unsigned short *ip, int n, int stride, \n\tunsigned short *wp, uint16 *From14)\n{\n    register int  r1, g1, b1, a1, r2, g2, b2, a2, mask;\n#undef   CLAMP\n#define  CLAMP(v) From14[(v) >> 2]\n    mask = CODE_MASK;\n    if (n >= stride) {\n\tif (stride == 3) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);\n\t    n -= 3;\n\t    while (n > 0) {\n\t\tn -= 3;\n\t\twp += 3;\n\t\tip += 3;\n\t\tr1 = CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;\n\t    }\n\t} else if (stride == 4) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);  a2 = wp[3] = CLAMP(ip[3]);\n\t    n -= 4;\n\t    while (n > 0) {\n\t\tn -= 4;\n\t\twp += 4;\n\t\tip += 4;\n\t\tr1 = CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;\n\t\ta1 = CLAMP(ip[3]); wp[3] = (uint16)((a1-a2) & mask); a2 = a1;\n\t    }\n\t} else {\n\t    ip += n - 1;\t\n\t    wp += n - 1;\t\n\t    n -= stride;\n\t    while (n > 0) {\n\t\tREPEAT(stride, wp[0] = CLAMP(ip[0]);\n\t\t\t\twp[stride] -= wp[0];\n\t\t\t\twp[stride] &= mask;\n\t\t\t\twp--; ip--)\n\t\tn -= stride;\n\t    }\n\t    REPEAT(stride, wp[0] = CLAMP(ip[0]); wp--; ip--)\n\t}\n    }\n}", "target": 1}
{"code": "flatpak_print_escaped_string (const char        *s,\n                              FlatpakEscapeFlags flags)\n{\n  g_autofree char *escaped = flatpak_escape_string (s, flags);\n  g_print (\"%s\", escaped);\n}", "target": 0}
{"code": "MONGO_EXPORT int bson_finish( bson *b ) {\n    int i;\n    if( b->err & BSON_NOT_UTF8 )\n        return BSON_ERROR;\n    if ( ! b->finished ) {\n        if ( bson_ensure_space( b, 1 ) == BSON_ERROR ) return BSON_ERROR;\n        bson_append_byte( b, 0 );\n        i = b->cur - b->data;\n        bson_little_endian32( b->data, &i );\n        b->finished = 1;\n    }\n    return BSON_OK;\n}", "target": 1}
{"code": "flatpak_bwrap_take_arg (FlatpakBwrap *bwrap, char *arg)\n{\n  g_ptr_array_add (bwrap->argv, arg);\n}", "target": 0}
{"code": "void LibRaw::nikon_14bit_load_raw()\n{\n  const unsigned linelen =\n      (unsigned)(ceilf((float)(S.raw_width * 7 / 4) / 16.0)) *\n      16; \n  const unsigned pitch = S.raw_pitch ? S.raw_pitch / 2 : S.raw_width;\n  unsigned char *buf = (unsigned char *)malloc(linelen);\n  merror(buf, \"nikon_14bit_load_raw()\");\n  for (int row = 0; row < S.raw_height; row++)\n  {\n    unsigned bytesread =\n        libraw_internal_data.internal_data.input->read(buf, 1, linelen);\n    unsigned short *dest = &imgdata.rawdata.raw_image[pitch * row];\n    for (int sp = 0, dp = 0;\n         dp < pitch - 3 && sp < linelen - 6 && sp < bytesread - 6;\n         sp += 7, dp += 4)\n      unpack7bytesto4x16_nikon(buf + sp, dest + dp);\n  }\n  free(buf);\n}", "target": 0}
{"code": "void macvlan_common_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\tdev->priv_flags\t       &= ~IFF_XMIT_DST_RELEASE;\n\tdev->netdev_ops\t\t= &macvlan_netdev_ops;\n\tdev->destructor\t\t= free_netdev;\n\tdev->header_ops\t\t= &macvlan_hard_header_ops,\n\tdev->ethtool_ops\t= &macvlan_ethtool_ops;\n}", "target": 1}
{"code": "decode_definite_short_string(CBORDecoderObject *self, Py_ssize_t length)\n{\n    PyObject *bytes_obj = fp_read_object(self, length);\n    if (!bytes_obj)\n        return NULL;\n    const char *bytes = PyBytes_AS_STRING(bytes_obj);\n    PyObject *ret = PyUnicode_FromStringAndSize(bytes, length);\n    Py_DECREF(bytes_obj);\n    if (ret && string_namespace_add(self, ret, length) == -1) {\n        Py_DECREF(ret);\n        return NULL;\n    }\n    return ret;\n}", "target": 0}
{"code": "int decomp_get_rddata(js_string *compressed, js_string *out,\n                      unsigned int compressed_offset, int type, int rdlength) {\n    char *desc;\n    int subtype, total, len;\n    desc = decomp_get_rrdesc(type);\n    if(desc == 0) { \n        if(rdlength == 0) {\n            return JS_SUCCESS;\n            }\n        if(decomp_append_bytes(compressed,out,compressed_offset,\n                               rdlength) != JS_SUCCESS) {\n            return JS_ERROR;\n            }\n        else {\n            return JS_SUCCESS;\n            }\n        }\n    else {\n        subtype = *desc;\n        total = 0;\n        while(subtype != 0) {\n            if(subtype > 0 && subtype < 64) {\n                if(decomp_append_bytes(compressed,out,\n                   compressed_offset,subtype) != JS_SUCCESS) {\n                       return JS_ERROR;\n                       }\n                total += subtype;\n                compressed_offset += subtype;\n                }\n            else if(subtype == RRSUB_DLABEL) {\n                len = decomp_append_dlabel(compressed,out,\n                        compressed_offset);\n                if(len == JS_ERROR) {\n                    return JS_ERROR;\n                    }\n                total += len;\n                compressed_offset += len;\n                }\n            else if(subtype == RRSUB_TEXT) {\n                len = *(compressed->string + compressed_offset);\n                len += 1; \n                if(len < 0 || len > 256) {\n                    return JS_ERROR;\n                    }\n                if(decomp_append_bytes(compressed,out,\n                                       compressed_offset,len) !=\n                   JS_SUCCESS) {\n                    return JS_ERROR;\n                    }\n                total += len;\n                compressed_offset += len;\n                }\n            else if(subtype == RRSUB_VARIABLE) {\n                len = rdlength - total;\n                if(len == 0) {\n                    break;\n                    }\n                if(decomp_append_bytes(compressed,out,\n                                       compressed_offset,len) != JS_SUCCESS) {\n                    return JS_ERROR;\n                    }\n                total += len;\n                compressed_offset += len;\n                }\n            else { \n                return JS_ERROR;\n                }\n            desc++;\n            if(subtype != RRSUB_VARIABLE)\n                subtype = *desc;\n            else\n                subtype = 0; \n            }\n        if(rdlength != total) {\n            return JS_ERROR;\n            }\n        }\n    return JS_SUCCESS;\n    }", "target": 1}
{"code": "smb2_queryfs(const unsigned int xid, struct cifs_tcon *tcon,\n\t     struct cifs_sb_info *cifs_sb, struct kstatfs *buf)\n{\n\tstruct smb2_query_info_rsp *rsp;\n\tstruct smb2_fs_full_size_info *info = NULL;\n\tstruct kvec rsp_iov = {NULL, 0};\n\tint buftype = CIFS_NO_BUFFER;\n\tint rc;\n\trc = smb2_query_info_compound(xid, tcon, \"\",\n\t\t\t\t      FILE_READ_ATTRIBUTES,\n\t\t\t\t      FS_FULL_SIZE_INFORMATION,\n\t\t\t\t      SMB2_O_INFO_FILESYSTEM,\n\t\t\t\t      sizeof(struct smb2_fs_full_size_info),\n\t\t\t\t      &rsp_iov, &buftype, cifs_sb);\n\tif (rc)\n\t\tgoto qfs_exit;\n\trsp = (struct smb2_query_info_rsp *)rsp_iov.iov_base;\n\tbuf->f_type = SMB2_SUPER_MAGIC;\n\tinfo = (struct smb2_fs_full_size_info *)(\n\t\tle16_to_cpu(rsp->OutputBufferOffset) + (char *)rsp);\n\trc = smb2_validate_iov(le16_to_cpu(rsp->OutputBufferOffset),\n\t\t\t       le32_to_cpu(rsp->OutputBufferLength),\n\t\t\t       &rsp_iov,\n\t\t\t       sizeof(struct smb2_fs_full_size_info));\n\tif (!rc)\n\t\tsmb2_copy_fs_info_to_kstatfs(info, buf);\nqfs_exit:\n\tfree_rsp_buf(buftype, rsp_iov.iov_base);\n\treturn rc;\n}", "target": 0}
{"code": "int adis_update_scan_mode(struct iio_dev *indio_dev,\n\tconst unsigned long *scan_mask)\n{\n\tstruct adis *adis = iio_device_get_drvdata(indio_dev);\n\tconst struct iio_chan_spec *chan;\n\tunsigned int scan_count;\n\tunsigned int i, j;\n\t__be16 *tx, *rx;\n\tkfree(adis->xfer);\n\tkfree(adis->buffer);\n\tif (adis->burst && adis->burst->en)\n\t\treturn adis_update_scan_mode_burst(indio_dev, scan_mask);\n\tscan_count = indio_dev->scan_bytes / 2;\n\tadis->xfer = kcalloc(scan_count + 1, sizeof(*adis->xfer), GFP_KERNEL);\n\tif (!adis->xfer)\n\t\treturn -ENOMEM;\n\tadis->buffer = kcalloc(indio_dev->scan_bytes, 2, GFP_KERNEL);\n\tif (!adis->buffer)\n\t\treturn -ENOMEM;\n\trx = adis->buffer;\n\ttx = rx + scan_count;\n\tspi_message_init(&adis->msg);\n\tfor (j = 0; j <= scan_count; j++) {\n\t\tadis->xfer[j].bits_per_word = 8;\n\t\tif (j != scan_count)\n\t\t\tadis->xfer[j].cs_change = 1;\n\t\tadis->xfer[j].len = 2;\n\t\tadis->xfer[j].delay_usecs = adis->data->read_delay;\n\t\tif (j < scan_count)\n\t\t\tadis->xfer[j].tx_buf = &tx[j];\n\t\tif (j >= 1)\n\t\t\tadis->xfer[j].rx_buf = &rx[j - 1];\n\t\tspi_message_add_tail(&adis->xfer[j], &adis->msg);\n\t}\n\tchan = indio_dev->channels;\n\tfor (i = 0; i < indio_dev->num_channels; i++, chan++) {\n\t\tif (!test_bit(chan->scan_index, scan_mask))\n\t\t\tcontinue;\n\t\tif (chan->scan_type.storagebits == 32)\n\t\t\t*tx++ = cpu_to_be16((chan->address + 2) << 8);\n\t\t*tx++ = cpu_to_be16(chan->address << 8);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int trusted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct trusted_key_payload *p;\n\tstruct trusted_key_payload *new_p;\n\tstruct trusted_key_options *new_o;\n\tsize_t datalen = prep->datalen;\n\tchar *datablob;\n\tint ret = 0;\n\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n\t\treturn -ENOKEY;\n\tp = key->payload.data[0];\n\tif (!p->migratable)\n\t\treturn -EPERM;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\tdatablob = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!datablob)\n\t\treturn -ENOMEM;\n\tnew_o = trusted_options_alloc();\n\tif (!new_o) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tnew_p = trusted_payload_alloc(key);\n\tif (!new_p) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmemcpy(datablob, prep->data, datalen);\n\tdatablob[datalen] = '\\0';\n\tret = datablob_parse(datablob, new_p, new_o);\n\tif (ret != Opt_update) {\n\t\tret = -EINVAL;\n\t\tkzfree(new_p);\n\t\tgoto out;\n\t}\n\tif (!new_o->keyhandle) {\n\t\tret = -EINVAL;\n\t\tkzfree(new_p);\n\t\tgoto out;\n\t}\n\tnew_p->migratable = p->migratable;\n\tnew_p->key_len = p->key_len;\n\tmemcpy(new_p->key, p->key, p->key_len);\n\tdump_payload(p);\n\tdump_payload(new_p);\n\tret = key_seal(new_p, new_o);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: key_seal failed (%d)\\n\", ret);\n\t\tkzfree(new_p);\n\t\tgoto out;\n\t}\n\tif (new_o->pcrlock) {\n\t\tret = pcrlock(new_o->pcrlock);\n\t\tif (ret < 0) {\n\t\t\tpr_info(\"trusted_key: pcrlock failed (%d)\\n\", ret);\n\t\t\tkzfree(new_p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\trcu_assign_keypointer(key, new_p);\n\tcall_rcu(&p->rcu, trusted_rcu_free);\nout:\n\tkzfree(datablob);\n\tkzfree(new_o);\n\treturn ret;\n}", "target": 1}
{"code": "static void udf_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, udf_i_callback);\n}", "target": 0}
{"code": "void usbredirparser_send_get_configuration(struct usbredirparser *parser,\n    uint64_t id)\n{\n    usbredirparser_queue(parser, usb_redir_get_configuration, id,\n                         NULL, NULL, 0);\n}", "target": 0}
{"code": "static void dbEvalSetColumnJSON(DbEvalContext *p, int iCol, Jsi_DString *dStr) {\n    Jsi_Interp *interp = p->jdb->interp;\n    char nbuf[200];\n    sqlite3_stmt *pStmt = p->pPreStmt->pStmt;\n    switch( sqlite3_column_type(pStmt, iCol) ) {\n    case SQLITE_BLOB: {\n        int bytes = sqlite3_column_bytes(pStmt, iCol);\n        const char *zBlob = (char*)sqlite3_column_blob(pStmt, iCol);\n        if( !zBlob ) {\n            Jsi_DSAppend(dStr, \"null\", NULL);\n            return;\n        }\n        Jsi_JSONQuote(interp, zBlob, bytes, dStr);\n        return;\n    }\n    case SQLITE_INTEGER: {\n        sqlite_int64 v = sqlite3_column_int64(pStmt, iCol);\n        if (v==0 || v==1) {\n            const char *dectyp = sqlite3_column_decltype(pStmt, iCol);\n            if (dectyp && !Jsi_Strncasecmp(dectyp,\"bool\", 4)) {\n                Jsi_DSAppend(dStr, (v?\"true\":\"false\"), NULL);\n                return;\n            }\n        }\n#ifdef __WIN32\n        snprintf(nbuf, sizeof(nbuf), \"%\" PRId64, (Jsi_Wide)v);\n#else\n        snprintf(nbuf, sizeof(nbuf), \"%lld\", v);\n#endif\n        Jsi_DSAppend(dStr, nbuf, NULL);\n        return;\n    }\n    case SQLITE_FLOAT: {\n        Jsi_NumberToString(interp, sqlite3_column_double(pStmt, iCol), nbuf, sizeof(nbuf));\n        Jsi_DSAppend(dStr, nbuf, NULL);\n        return;\n    }\n    case SQLITE_NULL: {\n        Jsi_DSAppend(dStr, \"null\", NULL);\n        return;\n    }\n    }\n    const char *str = (char*)sqlite3_column_text(pStmt, iCol );\n    if (!str)\n        str = p->jdb->optPtr->nullvalue;\n    Jsi_JSONQuote(interp, str?str:\"\", -1, dStr);\n}", "target": 1}
{"code": "GF_HEVCConfig *gf_isom_hevc_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tif (gf_isom_get_reference_count(the_file, trackNumber, GF_ISOM_REF_TBAS)) {\n\t\tu32 ref_track;\n\t\tGF_Err e = gf_isom_get_reference(the_file, trackNumber, GF_ISOM_REF_TBAS, 1, &ref_track);\n\t\tif (e == GF_OK) {\n\t\t\ttrackNumber = ref_track;\n\t\t}\n\t}\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tif (gf_isom_get_hevc_lhvc_type(the_file, trackNumber, DescriptionIndex)==GF_ISOM_HEVCTYPE_NONE)\n\t\treturn NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\tif (!entry) return NULL;\n\tif (!entry->hevc_config) return NULL;\n\treturn HEVC_DuplicateConfig(entry->hevc_config->config);\n}", "target": 0}
{"code": "R_API int r_core_bin_set_env(RCore *r, RBinFile *binfile) {\n\tRBinObject *binobj = binfile ? binfile->o: NULL;\n\tRBinInfo *info = binobj ? binobj->info: NULL;\n\tif (info) {\n\t\tint va = info->has_va;\n\t\tconst char * arch = info->arch;\n\t\tut16 bits = info->bits;\n\t\tut64 baseaddr = r_bin_get_baddr (r->bin);\n\t\tr_config_set_i (r->config, \"io.va\",\n\t\t\t(binobj->info)? binobj->info->has_va: 0);\n\t\tr_config_set_i (r->config, \"bin.baddr\", baseaddr);\n\t\tr_config_set (r->config, \"asm.arch\", arch);\n\t\tr_config_set_i (r->config, \"asm.bits\", bits);\n\t\tr_config_set (r->config, \"anal.arch\", arch);\n\t\tif (info->cpu && *info->cpu) {\n\t\t\tr_config_set (r->config, \"anal.cpu\", info->cpu);\n\t\t} else {\n\t\t\tr_config_set (r->config, \"anal.cpu\", arch);\n\t\t}\n\t\tr_asm_use (r->assembler, arch);\n\t\tr_core_bin_info (r, R_CORE_BIN_ACC_ALL, R_CORE_BIN_SET, va, NULL, NULL);\n\t\tr_core_bin_set_cur (r, binfile);\n\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "size_t _process_request_next_key(mcp_parser_t *pr) {\n    const char *cur = pr->request + pr->parsed;\n    int remain = pr->reqlen - pr->parsed - 2;\n    while (remain) {\n        if (*cur == ' ') {\n            remain--;\n            cur++;\n            pr->parsed++;\n        } else {\n            break;\n        }\n    }\n    const char *s = memchr(cur, ' ', remain);\n    if (s != NULL) {\n        pr->klen = s - cur;\n        pr->parsed += s - cur;\n    } else {\n        pr->klen = remain;\n        pr->parsed += remain;\n    }\n    return cur - pr->request;\n}", "target": 1}
{"code": "static int unix_dgram_peer_wake_me(struct sock *sk, struct sock *other)\n{\n\tint connected;\n\tconnected = unix_dgram_peer_wake_connect(sk, other);\n\tif (unix_recvq_full(other))\n\t\treturn 1;\n\tif (connected)\n\t\tunix_dgram_peer_wake_disconnect(sk, other);\n\treturn 0;\n}", "target": 0}
{"code": "static int __init adpt_init(void)\n{\n\tint\t\terror;\n\tadpt_hba\t*pHba, *next;\n\tprintk(\"Loading Adaptec I2O RAID: Version \" DPT_I2O_VERSION \"\\n\");\n\terror = adpt_detect(&driver_template);\n\tif (error < 0)\n\t\treturn error;\n\tif (hba_chain == NULL)\n\t\treturn -ENODEV;\n\tfor (pHba = hba_chain; pHba; pHba = pHba->next) {\n\t\terror = scsi_add_host(pHba->host, &pHba->pDev->dev);\n\t\tif (error)\n\t\t\tgoto fail;\n\t\tscsi_scan_host(pHba->host);\n\t}\n\treturn 0;\nfail:\n\tfor (pHba = hba_chain; pHba; pHba = next) {\n\t\tnext = pHba->next;\n\t\tscsi_remove_host(pHba->host);\n\t}\n\treturn error;\n}", "target": 1}
{"code": "nfs4_open_revalidate(struct inode *dir, struct dentry *dentry, int openflags, struct nameidata *nd)\n{\n\tstruct path path = {\n\t\t.mnt = nd->path.mnt,\n\t\t.dentry = dentry,\n\t};\n\tstruct rpc_cred *cred;\n\tstruct nfs4_state *state;\n\tcred = rpc_lookup_cred();\n\tif (IS_ERR(cred))\n\t\treturn PTR_ERR(cred);\n\tstate = nfs4_do_open(dir, &path, openflags, NULL, cred);\n\tput_rpccred(cred);\n\tif (IS_ERR(state)) {\n\t\tswitch (PTR_ERR(state)) {\n\t\t\tcase -EPERM:\n\t\t\tcase -EACCES:\n\t\t\tcase -EDQUOT:\n\t\t\tcase -ENOSPC:\n\t\t\tcase -EROFS:\n\t\t\t\tlookup_instantiate_filp(nd, (struct dentry *)state, NULL);\n\t\t\t\treturn 1;\n\t\t\tdefault:\n\t\t\t\tgoto out_drop;\n\t\t}\n\t}\n\tif (state->inode == dentry->d_inode) {\n\t\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\t\tnfs4_intent_set_file(nd, &path, state);\n\t\treturn 1;\n\t}\n\tnfs4_close_sync(&path, state, openflags);\nout_drop:\n\td_drop(dentry);\n\treturn 0;\n}", "target": 1}
{"code": "bool deleteFile(const String& path)\n{\n    String filename = path;\n    return !!DeleteFileW(filename.charactersWithNullTermination());\n}", "target": 0}
{"code": "static int usb_enumerate_device_otg(struct usb_device *udev)\n{\n\tint err = 0;\n#ifdef\tCONFIG_USB_OTG\n\tif (!udev->bus->is_b_host\n\t\t\t&& udev->config\n\t\t\t&& udev->parent == udev->bus->root_hub) {\n\t\tstruct usb_otg_descriptor\t*desc = NULL;\n\t\tstruct usb_bus\t\t\t*bus = udev->bus;\n\t\tunsigned\t\t\tport1 = udev->portnum;\n\t\terr = __usb_get_extra_descriptor(udev->rawdescriptors[0],\n\t\t\t\tle16_to_cpu(udev->config[0].desc.wTotalLength),\n\t\t\t\tUSB_DT_OTG, (void **) &desc);\n\t\tif (err || !(desc->bmAttributes & USB_OTG_HNP))\n\t\t\treturn 0;\n\t\tdev_info(&udev->dev, \"Dual-Role OTG device on %sHNP port\\n\",\n\t\t\t\t\t(port1 == bus->otg_port) ? \"\" : \"non-\");\n\t\tif (port1 == bus->otg_port) {\n\t\t\tbus->b_hnp_enable = 1;\n\t\t\terr = usb_control_msg(udev,\n\t\t\t\tusb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_SET_FEATURE, 0,\n\t\t\t\tUSB_DEVICE_B_HNP_ENABLE,\n\t\t\t\t0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t\t\tif (err < 0) {\n\t\t\t\tdev_err(&udev->dev, \"can't set HNP mode: %d\\n\",\n\t\t\t\t\t\t\t\t\terr);\n\t\t\t\tbus->b_hnp_enable = 0;\n\t\t\t}\n\t\t} else if (desc->bLength == sizeof\n\t\t\t\t(struct usb_otg_descriptor)) {\n\t\t\terr = usb_control_msg(udev,\n\t\t\t\tusb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_SET_FEATURE, 0,\n\t\t\t\tUSB_DEVICE_A_ALT_HNP_SUPPORT,\n\t\t\t\t0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t\t\tif (err < 0)\n\t\t\t\tdev_err(&udev->dev,\n\t\t\t\t\t\"set a_alt_hnp_support failed: %d\\n\",\n\t\t\t\t\terr);\n\t\t}\n\t}\n#endif\n\treturn err;\n}", "target": 1}
{"code": "gss_krb5int_export_lucid_sec_context(\n    OM_uint32           *minor_status,\n    const gss_ctx_id_t  context_handle,\n    const gss_OID       desired_object,\n    gss_buffer_set_t    *data_set)\n{\n    krb5_error_code     kret = 0;\n    OM_uint32           retval;\n    krb5_gss_ctx_id_t   ctx = (krb5_gss_ctx_id_t)context_handle;\n    void                *lctx = NULL;\n    int                 version = 0;\n    gss_buffer_desc     rep;\n    retval = GSS_S_FAILURE;\n    *minor_status = 0;\n    *data_set = GSS_C_NO_BUFFER_SET;\n    if (ctx->terminated || !ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return GSS_S_NO_CONTEXT;\n    }\n    retval = generic_gss_oid_decompose(minor_status,\n                                       GSS_KRB5_EXPORT_LUCID_SEC_CONTEXT_OID,\n                                       GSS_KRB5_EXPORT_LUCID_SEC_CONTEXT_OID_LENGTH,\n                                       desired_object,\n                                       &version);\n    if (GSS_ERROR(retval))\n        return retval;\n    switch (version) {\n    case 1:\n        kret = make_external_lucid_ctx_v1((krb5_pointer)ctx,\n                                          version, &lctx);\n        break;\n    default:\n        kret = (OM_uint32) KG_LUCID_VERSION;\n        break;\n    }\n    if (kret)\n        goto error_out;\n    rep.value = &lctx;\n    rep.length = sizeof(lctx);\n    retval = generic_gss_add_buffer_set_member(minor_status, &rep, data_set);\n    if (GSS_ERROR(retval))\n        goto error_out;\nerror_out:\n    if (*minor_status == 0)\n        *minor_status = (OM_uint32) kret;\n    return(retval);\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    INDEX_TYPE first_dimension;\n    const Tensor first_partition_tensor =\n        context->input(kFirstPartitionInputIndex);\n    OP_REQUIRES(context, first_partition_tensor.NumElements() > 0,\n                errors::InvalidArgument(\"Invalid first partition input. Tensor \"\n                                        \"requires at least one element.\"));\n    OP_REQUIRES_OK(context, GetFirstDimensionSize(context, &first_dimension));\n    vector<INDEX_TYPE> output_size;\n    OP_REQUIRES_OK(context,\n                   CalculateOutputSize(first_dimension, context, &output_size));\n    vector<INDEX_TYPE> multiplier;\n    multiplier.resize(ragged_rank_ + 1);\n    multiplier[multiplier.size() - 1] = 1;\n    for (int i = multiplier.size() - 2; i >= 0; --i) {\n      multiplier[i] = multiplier[i + 1] * output_size[i + 1];\n    }\n    TensorShape output_shape;\n    OP_REQUIRES_OK(context,\n                   TensorShapeUtils::MakeShape(output_size, &output_shape));\n    Tensor* output_tensor = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, output_shape, &output_tensor));\n    const INDEX_TYPE full_size = multiplier[0] * output_size[0];\n    if (full_size > 0) {\n      vector<INDEX_TYPE> output_index, new_output_index;\n      int nvals = context->input(kValueInputIndex).shape().dim_size(0);\n      output_index.reserve(nvals);\n      new_output_index.reserve(nvals);\n      CalculateFirstParentOutputIndex(first_dimension, multiplier[0],\n                                      output_size[0], &output_index);\n      for (int i = 1; i <= ragged_rank_; ++i) {\n        OP_REQUIRES_OK(context, CalculateOutputIndex(\n                                    context, i - 1, output_index, multiplier[i],\n                                    output_size[i], &new_output_index));\n        output_index.swap(new_output_index);\n        new_output_index.clear();\n      }\n      SetOutput(context, ragged_rank_, output_index, output_tensor);\n    }\n  }", "target": 0}
{"code": "const char* menu_cache_item_get_file_basename( MenuCacheItem* item )\n{\n    return item->file_name;\n}", "target": 0}
{"code": "static inline int pri2fac(const int pri)\n{\n\tunsigned fac = pri >> 3;\n\treturn (fac > 23) ? LOG_FAC_INVLD : fac;\n}", "target": 0}
{"code": "  void operator()(const CPUDevice& d, typename TTypes<T, 4>::ConstTensor input,\n                  typename TTypes<T, 3>::ConstTensor filter,\n                  typename TTypes<T, 4>::ConstTensor out_backprop,\n                  int stride_rows, int stride_cols, int rate_rows,\n                  int rate_cols, int pad_top, int pad_left,\n                  typename TTypes<T, 4>::Tensor in_backprop) {\n    const int batch = input.dimension(0);\n    const int input_rows = input.dimension(1);\n    const int input_cols = input.dimension(2);\n    const int depth = input.dimension(3);\n    const int filter_rows = filter.dimension(0);\n    const int filter_cols = filter.dimension(1);\n    const int output_rows = out_backprop.dimension(1);\n    const int output_cols = out_backprop.dimension(2);\n    in_backprop.setZero();\n    for (int b = 0; b < batch; ++b) {\n      for (int h_out = 0; h_out < output_rows; ++h_out) {\n        int h_beg = h_out * stride_rows - pad_top;\n        for (int w_out = 0; w_out < output_cols; ++w_out) {\n          int w_beg = w_out * stride_cols - pad_left;\n          for (int d = 0; d < depth; ++d) {\n            T cur_val = Eigen::NumTraits<T>::lowest();\n            int h_in_max = (h_beg < 0) ? 0 : h_beg;\n            int w_in_max = (w_beg < 0) ? 0 : w_beg;\n            for (int h = 0; h < filter_rows; ++h) {\n              const int h_in = h_beg + h * rate_rows;\n              if (h_in >= 0 && h_in < input_rows) {\n                for (int w = 0; w < filter_cols; ++w) {\n                  const int w_in = w_beg + w * rate_cols;\n                  if (w_in >= 0 && w_in < input_cols) {\n                    const T val = input(b, h_in, w_in, d) + filter(h, w, d);\n                    if (val > cur_val) {\n                      cur_val = val;\n                      h_in_max = h_in;\n                      w_in_max = w_in;\n                    }\n                  }\n                }\n              }\n            }\n            in_backprop(b, h_in_max, w_in_max, d) +=\n                out_backprop(b, h_out, w_out, d);\n          }\n        }\n      }\n    }\n  }", "target": 1}
{"code": "  Status operator()(OpKernelContext* context,\n                    typename TTypes<Tindex>::ConstVec reverse_index_map,\n                    typename TTypes<T>::ConstVec grad_values,\n                    typename TTypes<T>::Vec d_values,\n                    typename TTypes<T>::Scalar d_default_value) {\n    const GPUDevice& device = context->eigen_device<GPUDevice>();\n    const Tindex N = reverse_index_map.dimension(0);\n    const Tindex N_full = grad_values.dimension(0);\n    Tensor visited_t;\n    TF_RETURN_IF_ERROR(\n        context->allocate_temp(DT_BOOL, TensorShape({N_full}), &visited_t));\n    auto visited = visited_t.vec<bool>();\n    visited.device(device) = visited.constant(false);\n    TF_RETURN_IF_ERROR(wrap_kernel_call(\n        GatherOriginalGradValuesKernel<T, Tindex>, device,\n        N, reverse_index_map, grad_values, d_values, visited));\n    gpuprim::CountingInputIterator<Tindex, Tindex> counting_iterator(Tindex(0));\n    ZeroMaskedValues<T, Tindex> mask_values_fn(visited.data(),\n                                               grad_values.data());\n    gpuprim::TransformInputIterator<T, decltype(mask_values_fn),\n                                    decltype(counting_iterator), Tindex>\n        transform_iterator(counting_iterator, mask_values_fn);\n    std::size_t temp_storage_bytes = 0;\n    auto gpuprim_status = gpuprim::DeviceReduce::Sum(\n        nullptr, temp_storage_bytes,\n        transform_iterator,\n        d_default_value.data(),\n        N_full,\n        device.stream());\n    if (gpuprim_status != gpuSuccess) {\n      return errors::Internal(\n          \"SparseFillEmptyRowsGrad: Could not launch \"\n          \"gpuprim::DeviceReduce::Sum to calculate temp_storage_bytes, \"\n          \"status: \",\n          GpuGetErrorString(gpuprim_status));\n    }\n    Tensor temp_storage;\n    TF_RETURN_IF_ERROR(context->allocate_temp(\n        DT_INT8, TensorShape({static_cast<int64_t>(temp_storage_bytes)}),\n        &temp_storage));\n    gpuprim_status = gpuprim::DeviceReduce::Sum(\n        temp_storage.flat<int8>().data(), temp_storage_bytes,\n        transform_iterator,\n        d_default_value.data(),\n        N_full,\n        device.stream());\n    if (gpuprim_status != gpuSuccess) {\n      return errors::Internal(\n          \"SparseFillEmptyRowsGrad: Could not launch \"\n          \"gpuprim::DeviceReduce::Sum to sum values from originally-empty \"\n          \"rows. temp_storage_bytes: \",\n          temp_storage_bytes, \", status: \", GpuGetErrorString(gpuprim_status));\n    }\n    return OkStatus();\n  }", "target": 1}
{"code": "void PrintWebViewHelper::PrintPreviewContext::Failed(bool report_error) {\n  DCHECK(state_ == INITIALIZED || state_ == RENDERING);\n  state_ = INITIALIZED;\n  if (report_error) {\n    DCHECK_NE(PREVIEW_ERROR_NONE, error_);\n    UMA_HISTOGRAM_ENUMERATION(\"PrintPreview.RendererError\", error_,\n                              PREVIEW_ERROR_LAST_ENUM);\n  }\n  ClearContext();\n}", "target": 0}
{"code": "static mongo_message *mongo_message_create( int len , int id , int responseTo , int op ) {\n    mongo_message *mm = ( mongo_message * )bson_malloc( len );\n    if ( !id )\n        id = rand();\n    mm->head.len = len;\n    mm->head.id = id;\n    mm->head.responseTo = responseTo;\n    mm->head.op = op;\n    return mm;\n}", "target": 1}
{"code": "IW_IMPL(int) iw_get_input_density(struct iw_context *ctx,\n   double *px, double *py, int *pcode)\n{\n\t*px = 1.0;\n\t*py = 1.0;\n\t*pcode = ctx->img1.density_code;\n\tif(ctx->img1.density_code!=IW_DENSITY_UNKNOWN) {\n\t\t*px = ctx->img1.density_x;\n\t\t*py = ctx->img1.density_y;\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void TileManager::crop( RawTile *ttt ){\n  int tw = image->getTileWidth();\n  int th = image->getTileHeight();\n  if( loglevel >= 5 ){\n    *logfile << \"TileManager :: Edge tile: Base size: \" << tw << \"x\" << th\n\t     << \": This tile: \" << ttt->width << \"x\" << ttt->height\n\t     << endl;\n  }\n  int len = tw * th * ttt->channels * (ttt->bpc/8);\n  unsigned char* buffer = (unsigned char*) malloc( len );\n  unsigned char* src_ptr = (unsigned char*) memcpy( buffer, ttt->data, len );\n  unsigned char* dst_ptr = (unsigned char*) ttt->data;\n  len =  ttt->width * ttt->channels * (ttt->bpc/8);\n  for( unsigned int i=0; i<ttt->height; i++ ){\n    memcpy( dst_ptr, src_ptr, len );\n    dst_ptr += len;\n    src_ptr += tw * ttt->channels * (ttt->bpc/8);\n  }\n  free( buffer );\n  len = ttt->width * ttt->height * ttt->channels * (ttt->bpc/8);\n  ttt->dataLength = len;\n  ttt->padded = false;\n}", "target": 1}
{"code": "  add_authorized_client(const std::string &name, std::string &&cert) {\n    client_t &client = client_root;\n    named_cert_t named_cert;\n    named_cert.name = name;\n    named_cert.cert = std::move(cert);\n    named_cert.uuid = uuid_util::uuid_t::generate().string();\n    client.named_devices.emplace_back(named_cert);\n    if (!config::sunshine.flags[config::flag::FRESH_STATE]) {\n      save_state();\n    }\n  }", "target": 0}
{"code": "static int read_probe(const AVProbeData *p)\n{\n    int cnt = 0;\n    for (int i = 0; i < p->buf_size; i++)\n        cnt += !!isansicode(p->buf[i]);\n    return (cnt * 100LL / p->buf_size) * (cnt > 400) *\n        !!av_match_ext(p->filename, tty_extensions);\n}", "target": 0}
{"code": "static void nf_tables_expr_destroy(const struct nft_ctx *ctx,\n\t\t\t\t   struct nft_expr *expr)\n{\n\tif (expr->ops->destroy)\n\t\texpr->ops->destroy(ctx, expr);\n\tmodule_put(expr->ops->type->owner);\n}", "target": 0}
{"code": "void test_link(const char *path)\n{\n\tchar *d = strdupa(path), *tmpname;\n\td = dirname(d);\n\tsize_t len = strlen(path) + 30;\n\ttmpname = alloca(len);\n\tsnprintf(tmpname, len, \"%s/%d\", d, (int)getpid());\n\tif (link(path, tmpname) == 0) {\n\t\tfprintf(stderr, \"leak at link of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at link of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n\tif (link(tmpname, path) == 0) {\n\t\tfprintf(stderr, \"leak at link (2) of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at link (2) of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "spnego_gss_process_context_token(\n\t\t\t\tOM_uint32\t*minor_status,\n\t\t\t\tconst gss_ctx_id_t context_handle,\n\t\t\t\tconst gss_buffer_t token_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_process_context_token(minor_status,\n\t\t\t\t\tcontext_handle,\n\t\t\t\t\ttoken_buffer);\n\treturn (ret);\n}", "target": 1}
{"code": "void bio_chain(struct bio *bio, struct bio *parent)\n{\n\tBUG_ON(bio->bi_private || bio->bi_end_io);\n\tbio->bi_private = parent;\n\tbio->bi_end_io\t= bio_chain_endio;\n\tbio_inc_remaining(parent);\n}", "target": 0}
{"code": "int bad_format(\n    char *fmt)\n{\n    char     *ptr;\n    int       n = 0;\n    ptr = fmt;\n    while (*ptr != '\\0')\n        if (*ptr++ == '%') {\n            if (*ptr == '\\0')\n                return 1;\n            if (*ptr == 's' || *ptr == 'S' || *ptr == '%')\n                ptr++;\n            else if (*ptr == 'c') {\n                ptr++;\n                n = 1;\n            }\n            else {\n                if (*ptr == ' ' || *ptr == '+' || *ptr == '-')\n                    ptr++;\n                while (*ptr >= '0' && *ptr <= '9')\n                    ptr++;\n                if (*ptr == '.')\n                    ptr++;\n                while (*ptr >= '0' && *ptr <= '9')\n                    ptr++;\n                if (*ptr++ != 'l')\n                    return 1;\n                if (*ptr == 'e' || *ptr == 'f' || *ptr == 'g')\n                    ptr++;\n                else\n                    return 1;\n                n++;\n            }\n        }\n    return (n != 1);\n}", "target": 1}
{"code": "nf_nat_redirect_ipv4(struct sk_buff *skb,\n\t\t     const struct nf_nat_ipv4_multi_range_compat *mr,\n\t\t     unsigned int hooknum)\n{\n\tstruct nf_conn *ct;\n\tenum ip_conntrack_info ctinfo;\n\t__be32 newdst;\n\tstruct nf_nat_range newrange;\n\tNF_CT_ASSERT(hooknum == NF_INET_PRE_ROUTING ||\n\t\t     hooknum == NF_INET_LOCAL_OUT);\n\tct = nf_ct_get(skb, &ctinfo);\n\tNF_CT_ASSERT(ct && (ctinfo == IP_CT_NEW || ctinfo == IP_CT_RELATED));\n\tif (hooknum == NF_INET_LOCAL_OUT) {\n\t\tnewdst = htonl(0x7F000001);\n\t} else {\n\t\tstruct in_device *indev;\n\t\tstruct in_ifaddr *ifa;\n\t\tnewdst = 0;\n\t\trcu_read_lock();\n\t\tindev = __in_dev_get_rcu(skb->dev);\n\t\tif (indev != NULL) {\n\t\t\tifa = indev->ifa_list;\n\t\t\tnewdst = ifa->ifa_local;\n\t\t}\n\t\trcu_read_unlock();\n\t\tif (!newdst)\n\t\t\treturn NF_DROP;\n\t}\n\tmemset(&newrange.min_addr, 0, sizeof(newrange.min_addr));\n\tmemset(&newrange.max_addr, 0, sizeof(newrange.max_addr));\n\tnewrange.flags\t     = mr->range[0].flags | NF_NAT_RANGE_MAP_IPS;\n\tnewrange.min_addr.ip = newdst;\n\tnewrange.max_addr.ip = newdst;\n\tnewrange.min_proto   = mr->range[0].min;\n\tnewrange.max_proto   = mr->range[0].max;\n\treturn nf_nat_setup_info(ct, &newrange, NF_NAT_MANIP_DST);\n}", "target": 1}
{"code": "void VP8LHuffmanTablesDeallocate(HuffmanTables* const huffman_tables) {\n  HuffmanTablesSegment *current, *next;\n  if (huffman_tables == NULL) return;\n  current = &huffman_tables->root;\n  next = current->next;\n  WebPSafeFree(current->start);\n  current->start = NULL;\n  current->next = NULL;\n  current = next;\n  while (current != NULL) {\n    next = current->next;\n    WebPSafeFree(current->start);\n    WebPSafeFree(current);\n    current = next;\n  }\n}", "target": 0}
{"code": "void free_bprm(struct linux_binprm *bprm)\n{\n\tfree_arg_pages(bprm);\n\tif (bprm->cred) {\n\t\tmutex_unlock(&current->signal->cred_guard_mutex);\n\t\tabort_creds(bprm->cred);\n\t}\n\tif (bprm->interp != bprm->filename)\n\t\tkfree(bprm->interp);\n\tkfree(bprm);\n}", "target": 0}
{"code": "Cleanup Ipv4Instance::forceProtocolUnsupportedForTest(bool new_val) {\n  bool old_val = force_ipv4_unsupported_for_test;\n  force_ipv4_unsupported_for_test = new_val;\n  return Cleanup([old_val]() { force_ipv4_unsupported_for_test = old_val; });\n}", "target": 0}
{"code": "lys_getnext_data(const struct lys_module *mod, const struct lys_node *parent, const char *name, int nam_len,\n                 LYS_NODE type, const struct lys_node **ret)\n{\n    const struct lys_node *node;\n    assert((mod || parent) && name);\n    assert(!(type & (LYS_AUGMENT | LYS_USES | LYS_GROUPING | LYS_CHOICE | LYS_CASE | LYS_INPUT | LYS_OUTPUT)));\n    if (!mod) {\n        mod = lys_node_module(parent);\n    }\n    node = NULL;\n    while ((node = lys_getnext(node, parent, mod, 0))) {\n        if (!type || (node->nodetype & type)) {\n            if (lys_node_module(node) != lys_main_module(mod)) {\n                continue;\n            }\n            if (!strncmp(node->name, name, nam_len) && !node->name[nam_len]) {\n                if (ret) {\n                    *ret = node;\n                }\n                return EXIT_SUCCESS;\n            }\n        }\n    }\n    return EXIT_FAILURE;\n}", "target": 1}
{"code": "static const char *WorkingDirectory()\n{\n   static char path[kMAXPATHLEN];\n   if (getcwd(path, kMAXPATHLEN)) return path;\n   return 0;\n}", "target": 0}
{"code": "static void perf_event_init_cpu(int cpu)\n{\n\tstruct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);\n\tmutex_lock(&swhash->hlist_mutex);\n\tswhash->online = true;\n\tif (swhash->hlist_refcount > 0) {\n\t\tstruct swevent_hlist *hlist;\n\t\thlist = kzalloc_node(sizeof(*hlist), GFP_KERNEL, cpu_to_node(cpu));\n\t\tWARN_ON(!hlist);\n\t\trcu_assign_pointer(swhash->swevent_hlist, hlist);\n\t}\n\tmutex_unlock(&swhash->hlist_mutex);\n}", "target": 1}
{"code": "nfs4_proc_layoutget(struct nfs4_layoutget *lgp, gfp_t gfp_flags)\n{\n\tstruct nfs_server *server = NFS_SERVER(lgp->args.inode);\n\tsize_t max_pages = max_response_pages(server);\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LAYOUTGET],\n\t\t.rpc_argp = &lgp->args,\n\t\t.rpc_resp = &lgp->res,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = server->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_layoutget_call_ops,\n\t\t.callback_data = lgp,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tstruct pnfs_layout_segment *lseg = NULL;\n\tint status = 0;\n\tdprintk(\"--> %s\\n\", __func__);\n\tlgp->args.layout.pages = nfs4_alloc_pages(max_pages, gfp_flags);\n\tif (!lgp->args.layout.pages) {\n\t\tnfs4_layoutget_release(lgp);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tlgp->args.layout.pglen = max_pages * PAGE_SIZE;\n\tlgp->res.layoutp = &lgp->args.layout;\n\tlgp->res.seq_res.sr_slot = NULL;\n\tnfs41_init_sequence(&lgp->args.seq_args, &lgp->res.seq_res, 0);\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn ERR_CAST(task);\n\tstatus = nfs4_wait_for_completion_rpc_task(task);\n\tif (status == 0)\n\t\tstatus = task->tk_status;\n\tif (status == 0)\n\t\tlseg = pnfs_layout_process(lgp);\n\trpc_put_task(task);\n\tdprintk(\"<-- %s status=%d\\n\", __func__, status);\n\tif (status)\n\t\treturn ERR_PTR(status);\n\treturn lseg;\n}", "target": 0}
{"code": "TfLiteTensor* GetTemporary(TfLiteContext* context, const TfLiteNode* node,\n                           int index) {\n  const int tensor_index = ValidateTensorIndexing(\n      context, index, node->temporaries->size, node->temporaries->data);\n  if (tensor_index < 0) {\n    return nullptr;\n  }\n  return GetTensorAtIndex(context, tensor_index);\n}", "target": 0}
{"code": "static unsigned int get_exif_ui32(struct iw_exif_state *e, unsigned int pos)\n{\n\tif(e->d_len<4 || pos>e->d_len-4) return 0;\n\treturn iw_get_ui32_e(&e->d[pos], e->endian);\n}", "target": 0}
{"code": "std::wstring Utf8To16(const std::string& utf8_string) {\n  return MB2WC(utf8_string, CP_UTF8);\n}", "target": 0}
{"code": "static inline bool spectre_v2_in_eibrs_mode(enum spectre_v2_mitigation mode)\n{\n\treturn mode == SPECTRE_V2_EIBRS ||\n\t       mode == SPECTRE_V2_EIBRS_RETPOLINE ||\n\t       mode == SPECTRE_V2_EIBRS_LFENCE;\n}", "target": 0}
{"code": "void imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_backtick)\n{\n  const char *quote = \"`\\\"\\\\\";\n  if (!quote_backtick)\n    quote++;\n  char *pt = dest;\n  const char *s = src;\n  *pt++ = '\"';\n  dlen -= 3;\n  for (; *s && dlen; s++)\n  {\n    if (strchr(quote, *s))\n    {\n      if (dlen < 2)\n        break;\n      dlen -= 2;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\"';\n  *pt = '\\0';\n}", "target": 0}
{"code": "compat_cipher_proposal(struct ssh *ssh, char *cipher_prop)\n{\n\tif (!(ssh->compat & SSH_BUG_BIGENDIANAES))\n\t\treturn cipher_prop;\n\tdebug2_f(\"original cipher proposal: %s\", cipher_prop);\n\tif ((cipher_prop = match_filter_denylist(cipher_prop, \"aes*\")) == NULL)\n\t\tfatal(\"match_filter_denylist failed\");\n\tdebug2_f(\"compat cipher proposal: %s\", cipher_prop);\n\tif (*cipher_prop == '\\0')\n\t\tfatal(\"No supported ciphers found\");\n\treturn cipher_prop;\n}", "target": 1}
{"code": "void nfc_llcp_mac_is_down(struct nfc_dev *dev)\n{\n\tstruct nfc_llcp_local *local;\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL)\n\t\treturn;\n\tlocal->remote_miu = LLCP_DEFAULT_MIU;\n\tlocal->remote_lto = LLCP_DEFAULT_LTO;\n\tnfc_llcp_socket_release(local, true, 0);\n\tnfc_llcp_local_put(local);\n}", "target": 0}
{"code": "void PPB_URLLoader_Impl::didReceiveData(WebURLLoader* loader,\n                                        const char* data,\n                                        int data_length,\n                                        int encoded_data_length) {\n  bytes_received_ += data_length;\n  UpdateStatus();\n  buffer_.insert(buffer_.end(), data, data + data_length);\n  DCHECK(request_data_.prefetch_buffer_lower_threshold <\n         request_data_.prefetch_buffer_upper_threshold);\n  if (!is_streaming_to_file_ &&\n      !is_asynchronous_load_suspended_ &&\n      (buffer_.size() >= static_cast<size_t>(\n          request_data_.prefetch_buffer_upper_threshold))) {\n    DVLOG(1) << \"Suspending async load - buffer size: \" << buffer_.size();\n    SetDefersLoading(true);\n  }\n  if (user_buffer_) {\n    RunCallback(FillUserBuffer());\n  } else {\n    DCHECK(!TrackedCallback::IsPending(pending_callback_));\n  }\n}", "target": 0}
{"code": "static const char *adpt_info(struct Scsi_Host *host)\n{\n\tadpt_hba* pHba;\n\tpHba = (adpt_hba *) host->hostdata[0];\n\treturn (char *) (pHba->detail);\n}", "target": 1}
{"code": "static void ssh2_send_newkeys(PTInstVar pvar)\n{\n\tbegin_send_packet(pvar, SSH2_MSG_NEWKEYS, 0);\n\tfinish_send_packet(pvar);\n\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: SSH2_MSG_NEWKEYS was sent.\", __FUNCTION__);\n\tssh2_set_newkeys(pvar, MODE_OUT);\n\tif (!CRYPT_start_encryption(pvar, 1, 0)) {\n\t}\n\tpvar->ssh2_keys[MODE_OUT].mac.enabled = 1;\n\tpvar->ssh2_keys[MODE_OUT].comp.enabled = 1;\n\tenable_send_compression(pvar);\n\tpvar->kex_status |= KEX_FLAG_NEWKEYS_SENT;\n\tif (pvar->server_strict_kex) {\n\t\tpvar->ssh_state.sender_sequence_number = 0;\n\t}\n\tif (pvar->kex_status & KEX_FLAG_NEWKEYS_RECEIVED) {\n\t\tif ((pvar->kex_status & KEX_FLAG_REKEYING)) {\n\t\t\tdo_SSH2_dispatch_setup_for_transfer(pvar);\n\t\t}\n\t\telse {\n\t\t\tssh2_finish_encryption_setup(pvar);\n\t\t\tssh2_prep_userauth(pvar);\n\t\t}\n\t\tpvar->kex_status = KEX_FLAG_KEXDONE;\n\t}\n\treturn;\n}", "target": 0}
{"code": "TEST_P(JSITest, HostObjectProtoTest) {\n  class ProtoHostObject : public HostObject {\n    Value get(Runtime& rt, const PropNameID&) override {\n      return String::createFromAscii(rt, \"phoprop\");\n    }\n  };\n  rt.global().setProperty(\n      rt,\n      \"pho\",\n      Object::createFromHostObject(rt, std::make_shared<ProtoHostObject>()));\n  EXPECT_EQ(\n      eval(\"({__proto__: pho})[Symbol.toPrimitive]\").getString(rt).utf8(rt),\n      \"phoprop\");\n}", "target": 0}
{"code": "http_dissect_hdrs(struct worker *w, struct http *hp, int fd, char *p,\n    const struct http_conn *htc)\n{\n\tchar *q, *r;\n\ttxt t = htc->rxbuf;\n\tif (*p == '\\r')\n\t\tp++;\n\thp->nhd = HTTP_HDR_FIRST;\n\thp->conds = 0;\n\tr = NULL;\t\t\n\tfor (; p < t.e; p = r) {\n\t\tq = r = p;\n\t\twhile (r < t.e) {\n\t\t\tif (!vct_iscrlf(*r)) {\n\t\t\t\tr++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tq = r;\n\t\t\tassert(r < t.e);\n\t\t\tr += vct_skipcrlf(r);\n\t\t\tif (r >= t.e)\n\t\t\t\tbreak;\n\t\t\tif (!vct_issp(*r))\n\t\t\t\tbreak;\n\t\t\twhile (vct_islws(*q))\n\t\t\t\t*q++ = ' ';\n\t\t}\n\t\tif (q - p > htc->maxhdr) {\n\t\t\tVSC_C_main->losthdr++;\n\t\t\tWSL(w, SLT_LostHeader, fd, \"%.*s\",\n\t\t\t    q - p > 20 ? 20 : q - p, p);\n\t\t\treturn (413);\n\t\t}\n\t\tif (p == q)\n\t\t\tbreak;\n\t\tif ((p[0] == 'i' || p[0] == 'I') &&\n\t\t    (p[1] == 'f' || p[1] == 'F') &&\n\t\t    p[2] == '-')\n\t\t\thp->conds = 1;\n\t\twhile (q > p && vct_issp(q[-1]))\n\t\t\tq--;\n\t\t*q = '\\0';\n\t\tif (hp->nhd < hp->shd) {\n\t\t\thp->hdf[hp->nhd] = 0;\n\t\t\thp->hd[hp->nhd].b = p;\n\t\t\thp->hd[hp->nhd].e = q;\n\t\t\tWSLH(w, fd, hp, hp->nhd);\n\t\t\thp->nhd++;\n\t\t} else {\n\t\t\tVSC_C_main->losthdr++;\n\t\t\tWSL(w, SLT_LostHeader, fd, \"%.*s\",\n\t\t\t    q - p > 20 ? 20 : q - p, p);\n\t\t\treturn (413);\n\t\t}\n\t}\n\treturn (0);\n}", "target": 1}
{"code": "void sctp_generate_t3_rtx_event(unsigned long peer)\n{\n\tint error;\n\tstruct sctp_transport *transport = (struct sctp_transport *) peer;\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct net *net = sock_net(asoc->base.sk);\n\tbh_lock_sock(asoc->base.sk);\n\tif (sock_owned_by_user(asoc->base.sk)) {\n\t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n\t\tif (!mod_timer(&transport->T3_rtx_timer, jiffies + (HZ/20)))\n\t\t\tsctp_transport_hold(transport);\n\t\tgoto out_unlock;\n\t}\n\tif (transport->dead)\n\t\tgoto out_unlock;\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(SCTP_EVENT_TIMEOUT_T3_RTX),\n\t\t\t   asoc->state,\n\t\t\t   asoc->ep, asoc,\n\t\t\t   transport, GFP_ATOMIC);\n\tif (error)\n\t\tasoc->base.sk->sk_err = -error;\nout_unlock:\n\tbh_unlock_sock(asoc->base.sk);\n\tsctp_transport_put(transport);\n}", "target": 1}
{"code": "static inline int http_test_encoded_path(const char *mem, size_t len) {\n  const char *pos = NULL;\n  const char *end = mem + len;\n  while (mem < end && (pos = memchr(mem, '/', (size_t)len))) {\n    len = end - pos;\n    mem = pos + 1;\n    if (pos[1] == '/')\n      return -1;\n    if (len > 3 && pos[1] == '.' && pos[2] == '.' && pos[3] == '/')\n      return -1;\n  }\n  return 0;\n}", "target": 0}
{"code": "void gru_check_context_placement(struct gru_thread_state *gts)\n{\n\tstruct gru_state *gru;\n\tgru = gts->ts_gru;\n\tif (!gru || gts->ts_tgid_owner != current->tgid)\n\t\treturn;\n\tif (!gru_check_chiplet_assignment(gru, gts)) {\n\t\tSTAT(check_context_unload);\n\t\tgru_unload_context(gts, 1);\n\t} else if (gru_retarget_intr(gts)) {\n\t\tSTAT(check_context_retarget_intr);\n\t}\n}", "target": 1}
{"code": "    void SetProhibitQOpen(bool Mode) {ProhibitQOpen=Mode;}", "target": 0}
{"code": "bool all_tests () {\n\tmu_run_test (test_r_str_newf);\n\tmu_run_test (test_r_str_replace_char_once);\n\tmu_run_test (test_r_str_replace_char);\n\tmu_run_test (test_r_str_replace);\n\tmu_run_test (test_r_str_bits64);\n\tmu_run_test (test_r_str_rwx);\n\tmu_run_test (test_r_str_rwx_i);\n\tmu_run_test (test_r_str_bool);\n\tmu_run_test (test_r_str_trim);\n\tmu_run_test (test_r_str_case);\n\tmu_run_test (test_r_str_split);\n\tmu_run_test (test_r_str_tokenize);\n\tmu_run_test (test_r_str_char_count);\n\tmu_run_test (test_r_str_word_count);\n\tmu_run_test (test_r_str_ichr);\n\tmu_run_test (test_r_str_lchr);\n\tmu_run_test (test_r_sub_str_lchr);\n\tmu_run_test (test_r_sub_str_rchr);\n\tmu_run_test (test_r_str_rchr);\n\tmu_run_test (test_r_str_ansi_len);\n\tmu_run_test (test_r_str_len_utf8_ansi);\n\tmu_run_test (test_r_str_utf8_charsize);\n\tmu_run_test (test_r_str_utf8_charsize_prev);\n\tmu_run_test (test_r_str_sanitize_sdb_key);\n\tmu_run_test (test_r_str_escape_sh);\n\tmu_run_test (test_r_str_unescape);\n\tmu_run_test (test_r_str_constpool);\n\tmu_run_test (test_r_str_format_msvc_argv);\n\tmu_run_test (test_r_str_str_xy);\n\treturn tests_passed != tests_run;\n}", "target": 0}
{"code": "static int mcryptd_create_hash(struct crypto_template *tmpl, struct rtattr **tb,\n\t\t\t      struct mcryptd_queue *queue)\n{\n\tstruct hashd_instance_ctx *ctx;\n\tstruct ahash_instance *inst;\n\tstruct hash_alg_common *halg;\n\tstruct crypto_alg *alg;\n\tu32 type = 0;\n\tu32 mask = 0;\n\tint err;\n\tmcryptd_check_internal(tb, &type, &mask);\n\thalg = ahash_attr_alg(tb[1], type, mask);\n\tif (IS_ERR(halg))\n\t\treturn PTR_ERR(halg);\n\talg = &halg->base;\n\tpr_debug(\"crypto: mcryptd hash alg: %s\\n\", alg->cra_name);\n\tinst = mcryptd_alloc_instance(alg, ahash_instance_headroom(),\n\t\t\t\t\tsizeof(*ctx));\n\terr = PTR_ERR(inst);\n\tif (IS_ERR(inst))\n\t\tgoto out_put_alg;\n\tctx = ahash_instance_ctx(inst);\n\tctx->queue = queue;\n\terr = crypto_init_ahash_spawn(&ctx->spawn, halg,\n\t\t\t\t      ahash_crypto_instance(inst));\n\tif (err)\n\t\tgoto out_free_inst;\n\ttype = CRYPTO_ALG_ASYNC;\n\tif (alg->cra_flags & CRYPTO_ALG_INTERNAL)\n\t\ttype |= CRYPTO_ALG_INTERNAL;\n\tinst->alg.halg.base.cra_flags = type;\n\tinst->alg.halg.digestsize = halg->digestsize;\n\tinst->alg.halg.statesize = halg->statesize;\n\tinst->alg.halg.base.cra_ctxsize = sizeof(struct mcryptd_hash_ctx);\n\tinst->alg.halg.base.cra_init = mcryptd_hash_init_tfm;\n\tinst->alg.halg.base.cra_exit = mcryptd_hash_exit_tfm;\n\tinst->alg.init   = mcryptd_hash_init_enqueue;\n\tinst->alg.update = mcryptd_hash_update_enqueue;\n\tinst->alg.final  = mcryptd_hash_final_enqueue;\n\tinst->alg.finup  = mcryptd_hash_finup_enqueue;\n\tinst->alg.export = mcryptd_hash_export;\n\tinst->alg.import = mcryptd_hash_import;\n\tinst->alg.setkey = mcryptd_hash_setkey;\n\tinst->alg.digest = mcryptd_hash_digest_enqueue;\n\terr = ahash_register_instance(tmpl, inst);\n\tif (err) {\n\t\tcrypto_drop_ahash(&ctx->spawn);\nout_free_inst:\n\t\tkfree(inst);\n\t}\nout_put_alg:\n\tcrypto_mod_put(alg);\n\treturn err;\n}", "target": 1}
{"code": "static BYTE get_cbr2_bpp(UINT32 bpp, BOOL* pValid)\n{\n\tif (pValid)\n\t\t*pValid = TRUE;\n\tswitch (bpp)\n\t{\n\t\tcase 3:\n\t\t\treturn 8;\n\t\tcase 4:\n\t\t\treturn 16;\n\t\tcase 5:\n\t\t\treturn 24;\n\t\tcase 6:\n\t\t\treturn 32;\n\t\tdefault:\n\t\t\tWLog_WARN(TAG, \"Invalid bpp %\" PRIu32, bpp);\n\t\t\tif (pValid)\n\t\t\t\t*pValid = FALSE;\n\t\t\treturn 0;\n\t}\n}", "target": 0}
{"code": "decode_definite_short_bytestring(CBORDecoderObject *self, Py_ssize_t length)\n{\n    PyObject *ret = fp_read_object(self, length);\n    if (!ret)\n        return NULL;\n    if (string_namespace_add(self, ret, length) == -1) {\n        Py_DECREF(ret);\n        return NULL;\n    }\n    return ret;\n}", "target": 0}
{"code": "int sss_certmap_expand_mapping_rule(struct sss_certmap_ctx *ctx,\n                                    const uint8_t *der_cert, size_t der_size,\n                                    char **_expanded, char ***_domains)\n{\n    return expand_mapping_rule_ex(ctx, der_cert, der_size, false,\n                                  _expanded, _domains);\n}", "target": 0}
{"code": "ikev2_vid_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len _U_, const u_char *ep _U_,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\tconst u_char *vid;\n\tint i, len;\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tikev2_pay_print(ndo, NPSTR(tpay), e.critical);\n\tND_PRINT((ndo,\" len=%d vid=\", ntohs(e.len) - 4));\n\tvid = (const u_char *)(ext+1);\n\tlen = ntohs(e.len) - 4;\n\tND_TCHECK2(*vid, len);\n\tfor(i=0; i<len; i++) {\n\t\tif(ND_ISPRINT(vid[i])) ND_PRINT((ndo, \"%c\", vid[i]));\n\t\telse ND_PRINT((ndo, \".\"));\n\t}\n\tif (2 < ndo->ndo_vflag && 4 < len) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}", "target": 0}
{"code": "static int mwifiex_pcie_alloc_cmdrsp_buf(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct sk_buff *skb;\n\tskb = dev_alloc_skb(MWIFIEX_UPLD_SIZE);\n\tif (!skb) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Unable to allocate skb for command response data.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_put(skb, MWIFIEX_UPLD_SIZE);\n\tif (mwifiex_map_pci_memory(adapter, skb, MWIFIEX_UPLD_SIZE,\n\t\t\t\t   PCI_DMA_FROMDEVICE))\n\t\treturn -1;\n\tcard->cmdrsp_buf = skb;\n\treturn 0;\n}", "target": 1}
{"code": "clamp_indexed(const fz_colorspace *cs, const float *in, float *out)\n{\n\tstruct indexed *idx = cs->data;\n\t*out = fz_clamp(*in, 0, idx->high) / 255.0f; \n}", "target": 0}
{"code": "void CefVideoConsumerOSR::OnFrameCaptured(\n    media::mojom::VideoBufferHandlePtr data,\n    media::mojom::VideoFrameInfoPtr info,\n    const gfx::Rect& content_rect,\n    mojo::PendingRemote<viz::mojom::FrameSinkVideoConsumerFrameCallbacks>\n        callbacks) {\n  ScopedVideoFrameDone scoped_done(std::move(callbacks));\n  if (info->pixel_format != media::PIXEL_FORMAT_ARGB) {\n    DLOG(ERROR) << \"Unsupported pixel format \" << info->pixel_format;\n    return;\n  }\n  CHECK(data->is_read_only_shmem_region());\n  base::ReadOnlySharedMemoryRegion& shmem_region =\n      data->get_read_only_shmem_region();\n  DCHECK(shmem_region.IsValid());\n  base::ReadOnlySharedMemoryMapping mapping = shmem_region.Map();\n  if (!mapping.IsValid()) {\n    DLOG(ERROR) << \"Shared memory mapping failed.\";\n    return;\n  }\n  if (mapping.size() <\n      media::VideoFrame::AllocationSize(info->pixel_format, info->coded_size)) {\n    DLOG(ERROR) << \"Shared memory size was less than expected.\";\n    return;\n  }\n  void* const pixels = const_cast<void*>(mapping.memory());\n  media::VideoFrameMetadata metadata = info->metadata;\n  gfx::Rect damage_rect;\n  if (bounds_in_pixels_) {\n    damage_rect = gfx::Rect(info->coded_size);\n    damage_rect.Intersect(*bounds_in_pixels_);\n    bounds_in_pixels_ = absl::nullopt;\n  } else {\n    if (metadata.capture_update_rect) {\n      damage_rect = *metadata.capture_update_rect;\n    }\n    if (damage_rect.IsEmpty()) {\n      damage_rect = gfx::Rect(info->coded_size);\n    }\n  }\n  view_->OnPaint(damage_rect, info->coded_size, pixels);\n}", "target": 0}
{"code": "deltas_head_init(struct deltas_head *list)\n{\n\tlist->array = NULL;\n\tlist->len = 0;\n\tlist->capacity = 0;\n}", "target": 1}
{"code": "static int can_open_cached(struct nfs4_state *state, int mode)\n{\n\tint ret = 0;\n\tswitch (mode & (FMODE_READ|FMODE_WRITE|O_EXCL)) {\n\t\tcase FMODE_READ:\n\t\t\tret |= test_bit(NFS_O_RDONLY_STATE, &state->flags) != 0;\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tret |= test_bit(NFS_O_WRONLY_STATE, &state->flags) != 0;\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tret |= test_bit(NFS_O_RDWR_STATE, &state->flags) != 0;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "int pico_tcp_initconn(struct pico_socket *s)\n{\n    struct pico_socket_tcp *ts = TCP_SOCK(s);\n    struct pico_frame *syn;\n    struct pico_tcp_hdr *hdr;\n    uint16_t mtu, opt_len = tcp_options_size(ts, PICO_TCP_SYN);\n    syn = s->net->alloc(s->stack, s->net, NULL, (uint16_t)(PICO_SIZE_TCPHDR + opt_len));\n    if (!syn)\n        return -1;\n    hdr = (struct pico_tcp_hdr *) syn->transport_hdr;\n    if (!ts->snd_nxt)\n        ts->snd_nxt = long_be(pico_paws());\n    ts->snd_last = ts->snd_nxt;\n    ts->cwnd = PICO_TCP_IW;\n    mtu = (uint16_t)pico_socket_get_mss(s);\n    ts->mss = (uint16_t)(mtu - PICO_SIZE_TCPHDR);\n    ts->ssthresh = (uint16_t)((uint16_t)(PICO_DEFAULT_SOCKETQ / ts->mss) -  (((uint16_t)(PICO_DEFAULT_SOCKETQ / ts->mss)) >> 3u));\n    syn->sock = s;\n    hdr->seq = long_be(ts->snd_nxt);\n    hdr->len = (uint8_t)((PICO_SIZE_TCPHDR + opt_len) << 2);\n    hdr->flags = PICO_TCP_SYN;\n    tcp_set_space(ts);\n    hdr->rwnd = short_be(ts->wnd);\n    tcp_add_options(ts, syn, PICO_TCP_SYN, opt_len);\n    hdr->trans.sport = ts->sock.local_port;\n    hdr->trans.dport = ts->sock.remote_port;\n    hdr->crc = 0;\n    hdr->crc = short_be(pico_tcp_checksum(syn));\n    tcp_dbg(\"Sending SYN... (ports: %d - %d) size: %d\\n\", short_be(ts->sock.local_port), short_be(ts->sock.remote_port), syn->buffer_len);\n    ts->retrans_tmr = pico_timer_add(s->stack, PICO_TCP_SYN_TO << ts->backoff, initconn_retry, ts);\n    if (!ts->retrans_tmr) {\n        tcp_dbg(\"TCP: Failed to start initconn_retry timer\\n\");\n        PICO_FREE(syn);\n        return -1;\n    }\n    pico_enqueue(&s->stack->q_tcp.out, syn);\n    return 0;\n}", "target": 1}
{"code": "void WebContentsImpl::SetParentNativeViewAccessible(\ngfx::NativeViewAccessible accessible_parent) {\n  accessible_parent_ = accessible_parent;\n  if (GetRenderViewHost())\n    GetRenderViewHostImpl()->SetParentNativeViewAccessible(accessible_parent);\n}", "target": 0}
{"code": "static int ac_interception(struct vcpu_svm *svm)\n{\n\tkvm_queue_exception_e(&svm->vcpu, AC_VECTOR, 0);\n\treturn 1;\n}", "target": 0}
{"code": "static std::string WC2MB(const std::wstring& input, unsigned int code_page) {\n  if (input.empty()) {\n    return \"\";\n  }\n  DWORD flags = 0;\n  if (code_page != 65001 && code_page != 54936) {\n    flags = WC_NO_BEST_FIT_CHARS | WC_COMPOSITECHECK | WC_DEFAULTCHAR;\n  }\n  int length = ::WideCharToMultiByte(code_page, flags, &input[0],\n                                     static_cast<int>(input.size()), NULL, 0,\n                                     NULL, NULL);\n  std::string output(length, '\\0');\n  ::WideCharToMultiByte(code_page, flags, &input[0],\n                        static_cast<int>(input.size()), &output[0],\n                        static_cast<int>(output.size()), NULL, NULL);\n  return output;\n}", "target": 0}
{"code": "static int _process_request_metaflags(mcp_parser_t *pr, int token) {\n    if (pr->ntokens <= token) {\n        pr->t.meta.flags = 0; \n        return 0;\n    }\n    const char *cur = pr->request + pr->tokens[token];\n    const char *end = pr->request + pr->reqlen - 2;\n    int state = 0;\n    while (cur != end) {\n        switch (state) {\n            case 0:\n                if (*cur == ' ') {\n                    cur++;\n                } else {\n                    if (*cur < 65 || *cur > 122) {\n                        return -1;\n                    }\n                    P_DEBUG(\"%s: setting meta flag: %d\\n\", __func__, *cur - 65);\n                    pr->t.meta.flags |= (uint64_t)1 << (*cur - 65);\n                    state = 1;\n                }\n                break;\n            case 1:\n                if (*cur != ' ') {\n                    cur++;\n                } else {\n                    state = 0;\n                }\n                break;\n        }\n    }\n    if (pr->t.meta.flags & ((uint64_t)1 << 48)) {\n        pr->noreply = true;\n    }\n    return 0;\n}", "target": 1}
{"code": "static const unsigned char *parse_object(cJSON *item, const unsigned char *value, const unsigned char **ep)\n{\n    cJSON *child = NULL;\n    if (*value != '{')\n    {\n        *ep = value;\n        goto fail;\n    }\n    item->type = cJSON_Object;\n    value = skip(value + 1);\n    if (*value == '}')\n    {\n        return value + 1;\n    }\n    child = cJSON_New_Item();\n    item->child = child;\n    if (!item->child)\n    {\n        goto fail;\n    }\n    value = skip(parse_string(child, skip(value), ep));\n    if (!value)\n    {\n        goto fail;\n    }\n    child->string = child->valuestring;\n    child->valuestring = NULL;\n    if (*value != ':')\n    {\n        *ep = value;\n        goto fail;\n    }\n    value = skip(parse_value(child, skip(value + 1), ep));\n    if (!value)\n    {\n        goto fail;\n    }\n    while (*value == ',')\n    {\n        cJSON *new_item = NULL;\n        if (!(new_item = cJSON_New_Item()))\n        {\n            goto fail;\n        }\n        child->next = new_item;\n        new_item->prev = child;\n        child = new_item;\n        value = skip(parse_string(child, skip(value + 1), ep));\n        if (!value)\n        {\n            goto fail;\n        }\n        child->string = child->valuestring;\n        child->valuestring = NULL;\n        if (*value != ':')\n        {\n            *ep = value;\n            goto fail;\n        }\n        value = skip(parse_value(child, skip(value + 1), ep));\n        if (!value)\n        {\n            goto fail;\n        }\n    }\n    if (*value == '}')\n    {\n        return value + 1;\n    }\n    *ep = value;\nfail:\n    if (item->child != NULL)\n    {\n        cJSON_Delete(child);\n        item->child = NULL;\n    }\n    return NULL;\n}", "target": 1}
{"code": "void UpdateDownloader::CleanLeftovers()\n{\n    std::wstring tmpdir;\n    if ( !Settings::ReadConfigValue(\"UpdateTempDir\", tmpdir) )\n        return;\n    try\n    {\n        if (tmpdir.find(GetUniqueTempDirectoryPrefix()) != 0)\n        {\n            Settings::DeleteConfigValue(\"UpdateTempDir\");\n            return;\n        }\n    }\n    catch (Win32Exception&) \n    {\n        return;\n    }\n    tmpdir.append(1, '\\0'); \n    SHFILEOPSTRUCT fos = {0};\n    fos.wFunc = FO_DELETE;\n    fos.pFrom = tmpdir.c_str();\n    fos.fFlags = FOF_NO_UI | \n                 FOF_SILENT |\n                 FOF_NOCONFIRMATION |\n                 FOF_NOERRORUI;\n    if ( SHFileOperation(&fos) == 0 )\n    {\n        Settings::DeleteConfigValue(\"UpdateTempDir\");\n    }\n}", "target": 0}
{"code": "void CoreUserInputHandler::putPrivmsg(const QByteArray &target, const QByteArray &message, Cipher *cipher)\n{\n    static const char *cmd = \"PRIVMSG\";\n    static const char *splitter = \" .,-!?\";\n    int maxSplitPos = message.count();\n    int splitPos = maxSplitPos;\n    forever {\n        QByteArray crypted = message.left(splitPos);\n        bool isEncrypted = false;\n#ifdef HAVE_QCA2\n        if (cipher && !cipher->key().isEmpty() && !message.isEmpty()) {\n            isEncrypted = cipher->encrypt(crypted);\n        }\n#endif\n        int overrun = lastParamOverrun(cmd, QList<QByteArray>() << target << crypted);\n        if (overrun) {\n            if (!isEncrypted)\n                maxSplitPos = message.count() - overrun;\n            splitPos = -1;\n            for (const char *splitChar = splitter; *splitChar != 0; splitChar++) {\n                splitPos = qMax(splitPos, message.lastIndexOf(*splitChar, maxSplitPos) + 1); \n            }\n            if (splitPos <= 0 || splitPos > maxSplitPos)\n                splitPos = maxSplitPos;\n            maxSplitPos = splitPos - 1;\n            if (maxSplitPos <= 0) { \n                qWarning() << tr(\"[Error] Could not encrypt your message: %1\").arg(message.data());\n                return;\n            }\n            continue; \n        }\n        putCmd(cmd, QList<QByteArray>() << target << crypted);\n        if (splitPos < message.count())\n            putPrivmsg(target, message.mid(splitPos), cipher);\n        return;\n    }\n}", "target": 1}
{"code": "void FrameLoader::begin(const KURL& url, bool dispatch, SecurityOrigin* origin)\n{\n    RefPtr<SecurityOrigin> forcedSecurityOrigin = origin;\n    RefPtr<Document> document;\n    if (!m_isDisplayingInitialEmptyDocument && m_client->shouldUsePluginDocument(m_responseMIMEType))\n        document = PluginDocument::create(m_frame);\n    else if (!m_client->hasHTMLView())\n        document = PlaceholderDocument::create(m_frame);\n    else\n        document = DOMImplementation::createDocument(m_responseMIMEType, m_frame, m_frame->inViewSourceMode());\n    bool resetScripting = !(m_isDisplayingInitialEmptyDocument && m_frame->document()->securityOrigin()->isSecureTransitionTo(url));\n    clear(resetScripting, resetScripting);\n    if (resetScripting)\n        m_frame->script()->updatePlatformScriptObjects();\n    m_needsClear = true;\n    m_isComplete = false;\n    m_didCallImplicitClose = false;\n    m_isLoadingMainResource = true;\n    m_isDisplayingInitialEmptyDocument = m_creatingInitialEmptyDocument;\n    KURL ref(url);\n    ref.setUser(String());\n    ref.setPass(String());\n    ref.removeFragmentIdentifier();\n    m_outgoingReferrer = ref.string();\n    m_URL = url;\n    document->setURL(m_URL);\n    m_frame->setDocument(document);\n    if (m_decoder)\n        document->setDecoder(m_decoder.get());\n    if (forcedSecurityOrigin)\n        document->setSecurityOrigin(forcedSecurityOrigin.get());\n    m_frame->domWindow()->setURL(document->url());\n    m_frame->domWindow()->setSecurityOrigin(document->securityOrigin());\n    if (dispatch)\n        dispatchWindowObjectAvailable();\n    updateFirstPartyForCookies();\n    Settings* settings = document->settings();\n    document->docLoader()->setAutoLoadImages(settings && settings->loadsImagesAutomatically());\n    if (m_documentLoader) {\n        String dnsPrefetchControl = m_documentLoader->response().httpHeaderField(\"X-DNS-Prefetch-Control\");\n        if (!dnsPrefetchControl.isEmpty())\n            document->parseDNSPrefetchControlHeader(dnsPrefetchControl);\n    }\n    history()->restoreDocumentState();\n    document->implicitOpen();\n    if (m_frame->view() && m_client->hasHTMLView())\n        m_frame->view()->setContentsSize(IntSize());\n}", "target": 0}
{"code": "static int mwifiex_pcie_init_evt_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct mwifiex_evt_buf_desc *desc;\n\tstruct sk_buff *skb;\n\tdma_addr_t buf_pa;\n\tint i;\n\tfor (i = 0; i < MWIFIEX_MAX_EVT_BD; i++) {\n\t\tskb = dev_alloc_skb(MAX_EVENT_SIZE);\n\t\tif (!skb) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Unable to allocate skb for EVENT buf.\\n\");\n\t\t\tkfree(card->evtbd_ring_vbase);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tskb_put(skb, MAX_EVENT_SIZE);\n\t\tif (mwifiex_map_pci_memory(adapter, skb, MAX_EVENT_SIZE,\n\t\t\t\t\t   PCI_DMA_FROMDEVICE))\n\t\t\treturn -1;\n\t\tbuf_pa = MWIFIEX_SKB_DMA_ADDR(skb);\n\t\tmwifiex_dbg(adapter, EVENT,\n\t\t\t    \"info: EVT ring: skb=%p len=%d data=%p buf_pa=%#x:%x\\n\",\n\t\t\t    skb, skb->len, skb->data, (u32)buf_pa,\n\t\t\t    (u32)((u64)buf_pa >> 32));\n\t\tcard->evt_buf_list[i] = skb;\n\t\tcard->evtbd_ring[i] = (void *)(card->evtbd_ring_vbase +\n\t\t\t\t      (sizeof(*desc) * i));\n\t\tdesc = card->evtbd_ring[i];\n\t\tdesc->paddr = buf_pa;\n\t\tdesc->len = (u16)skb->len;\n\t\tdesc->flags = 0;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "unsigned long insn_get_seg_base(struct pt_regs *regs, int seg_reg_idx)\n{\n\tstruct desc_struct *desc;\n\tshort sel;\n\tsel = get_segment_selector(regs, seg_reg_idx);\n\tif (sel < 0)\n\t\treturn -1L;\n\tif (v8086_mode(regs))\n\t\treturn (unsigned long)(sel << 4);\n\tif (user_64bit_mode(regs)) {\n\t\tunsigned long base;\n\t\tif (seg_reg_idx == INAT_SEG_REG_FS)\n\t\t\trdmsrl(MSR_FS_BASE, base);\n\t\telse if (seg_reg_idx == INAT_SEG_REG_GS)\n\t\t\trdmsrl(MSR_KERNEL_GS_BASE, base);\n\t\telse\n\t\t\tbase = 0;\n\t\treturn base;\n\t}\n\tif (!sel)\n\t\treturn -1L;\n\tdesc = get_desc(sel);\n\tif (!desc)\n\t\treturn -1L;\n\treturn get_desc_base(desc);\n}", "target": 1}
{"code": "int shadow_server_start(rdpShadowServer* server)\n{\n\tBOOL ipc;\n\tBOOL status;\n\tWSADATA wsaData;\n\tif (!server)\n\t\treturn -1;\n\tif (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0)\n\t\treturn -1;\n#ifndef _WIN32\n\tsignal(SIGPIPE, SIG_IGN);\n#endif\n\tserver->screen = shadow_screen_new(server);\n\tif (!server->screen)\n\t{\n\t\tWLog_ERR(TAG, \"screen_new failed\");\n\t\treturn -1;\n\t}\n\tserver->capture = shadow_capture_new(server);\n\tif (!server->capture)\n\t{\n\t\tWLog_ERR(TAG, \"capture_new failed\");\n\t\treturn -1;\n\t}\n\tipc = server->ipcSocket && (strncmp(bind_address, server->ipcSocket,\n\t                                    strnlen(bind_address, sizeof(bind_address))) != 0);\n\tif (!ipc)\n\t{\n\t\tsize_t x, count;\n\t\tchar** list = CommandLineParseCommaSeparatedValuesEx(NULL, server->ipcSocket, &count);\n\t\tif (!list || (count <= 1))\n\t\t{\n\t\t\tfree(list);\n\t\t\tif (server->ipcSocket == NULL)\n\t\t\t{\n\t\t\t\tif (!open_port(server, NULL))\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t\tfor (x = 1; x < count; x++)\n\t\t{\n\t\t\tBOOL success = open_port(server, list[x]);\n\t\t\tif (!success)\n\t\t\t{\n\t\t\t\tfree(list);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(list);\n\t}\n\telse\n\t{\n\t\tstatus = server->listener->OpenLocal(server->listener, server->ipcSocket);\n\t\tif (!status)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Problem creating local socket listener. (Port already used or \"\n\t\t\t              \"insufficient permissions?)\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (!(server->thread = CreateThread(NULL, 0, shadow_server_thread, (void*)server, 0, NULL)))\n\t{\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int32_t check_load_area(uintptr_t dst, uintptr_t len)\n{\n\tuint32_t legacy = dst + len <= UINT32_MAX - 1 ? 1 : 0;\n\tuintptr_t dram_start, dram_end;\n\tuintptr_t prot_start, prot_end;\n\tint32_t result = IO_SUCCESS;\n\tdram_start = legacy ? DRAM1_NS_BASE : DRAM_40BIT_BASE;\n\tdram_end = legacy ? DRAM1_NS_BASE + DRAM1_NS_SIZE :\n\t    DRAM_40BIT_BASE + DRAM_40BIT_SIZE;\n\tprot_start = legacy ? DRAM_PROTECTED_BASE : DRAM_40BIT_PROTECTED_BASE;\n\tprot_end = prot_start + DRAM_PROTECTED_SIZE;\n\tif (dst < dram_start || dst > dram_end - len || dram_end < len) {\n\t\tERROR(\"BL2: dst address is on the protected area.\\n\");\n\t\tresult = IO_FAIL;\n\t\tgoto done;\n\t}\n\tif (dst >= prot_start && dst < prot_end) {\n\t\tERROR(\"BL2: dst address is on the protected area.\\n\");\n\t\tresult = IO_FAIL;\n\t}\n\tif ((dst < prot_start && dst > prot_start - len) || prot_start < len) {\n\t\tERROR(\"BL2: loaded data is on the protected area.\\n\");\n\t\tresult = IO_FAIL;\n\t}\ndone:\n\tif (result == IO_FAIL) {\n\t\tERROR(\"BL2: Out of range : dst=0x%lx len=0x%lx\\n\", dst, len);\n\t}\n\tif (addr_loaded_cnt >= CHECK_IMAGE_AREA_CNT) {\n\t\tERROR(\"BL2: max loadable non secure images reached\\n\");\n\t\tresult = IO_FAIL;\n\t}\n\taddr_loaded[addr_loaded_cnt].dest = dst;\n\taddr_loaded[addr_loaded_cnt].length = len;\n\tfor(int n=0; n<addr_loaded_cnt; n++) {\n\t\tif (((dst > addr_loaded[n].dest) &&\n\t\t     (dst <  addr_loaded[n].dest + addr_loaded[n].length)) ||\n\t\t    (((dst < addr_loaded[n].dest) &&\n\t\t      (dst + len)) > addr_loaded[n].dest)) {\n\t\t\tERROR(\"BL2: image is inside a previous image area.\\n\");\n\t\t\tresult = IO_FAIL;\n\t\t}\n\t}\n\taddr_loaded_cnt++;\n\treturn result;\n}", "target": 1}
{"code": "CopyKeyAliasesToKeymap(struct xkb_keymap *keymap, KeyNamesInfo *info)\n{\n    AliasInfo *alias;\n    unsigned i, num_key_aliases;\n    struct xkb_key_alias *key_aliases;\n    num_key_aliases = 0;\n    darray_foreach(alias, info->aliases) {\n        if (!XkbKeyByName(keymap, alias->real, false)) {\n            log_vrb(info->ctx, 5,\n                    \"Attempt to alias %s to non-existent key %s; Ignored\\n\",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n        if (XkbKeyByName(keymap, alias->alias, false)) {\n            log_vrb(info->ctx, 5,\n                    \"Attempt to create alias with the name of a real key; \"\n                    \"Alias \\\"%s = %s\\\" ignored\\n\",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n        num_key_aliases++;\n    }\n    key_aliases = NULL;\n    if (num_key_aliases > 0) {\n        key_aliases = calloc(num_key_aliases, sizeof(*key_aliases));\n        if (!key_aliases)\n            return false;\n    }\n    i = 0;\n    darray_foreach(alias, info->aliases) {\n        if (alias->real != XKB_ATOM_NONE) {\n            key_aliases[i].alias = alias->alias;\n            key_aliases[i].real = alias->real;\n            i++;\n        }\n    }\n    keymap->num_key_aliases = num_key_aliases;\n    keymap->key_aliases = key_aliases;\n    return true;\n}", "target": 1}
{"code": "std::string queueloader::get_filename(const std::string& str) {\n\tstd::string fn = ctrl->get_dlpath();\n\tif (fn[fn.length()-1] != NEWSBEUTER_PATH_SEP[0])\n\t\tfn.append(NEWSBEUTER_PATH_SEP);\n\tchar buf[1024];\n\tsnprintf(buf, sizeof(buf), \"%s\", str.c_str());\n\tchar * base = basename(buf);\n\tif (!base || strlen(base) == 0) {\n\t\tchar lbuf[128];\n\t\ttime_t t = time(nullptr);\n\t\tstrftime(lbuf, sizeof(lbuf), \"%Y-%b-%d-%H%M%S.unknown\", localtime(&t));\n\t\tfn.append(lbuf);\n\t} else {\n\t\tfn.append(base);\n\t}\n\treturn fn;\n}", "target": 1}
{"code": "static void bt_tags_for_each(struct blk_mq_tags *tags,\n\t\tstruct blk_mq_bitmap_tags *bt, unsigned int off,\n\t\tbusy_tag_iter_fn *fn, void *data, bool reserved)\n{\n\tstruct request *rq;\n\tint bit, i;\n\tif (!tags->rqs)\n\t\treturn;\n\tfor (i = 0; i < bt->map_nr; i++) {\n\t\tstruct blk_align_bitmap *bm = &bt->map[i];\n\t\tfor (bit = find_first_bit(&bm->word, bm->depth);\n\t\t     bit < bm->depth;\n\t\t     bit = find_next_bit(&bm->word, bm->depth, bit + 1)) {\n\t\t\trq = blk_mq_tag_to_rq(tags, off + bit);\n\t\t\tfn(rq, data, reserved);\n\t\t}\n\t\toff += (1 << bt->bits_per_word);\n\t}\n}", "target": 1}
{"code": "void bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)\n\t{\n\tBN_ULONG t1,t2;\n\tBN_ULONG c1,c2,c3;\n\tc1=0;\n\tc2=0;\n\tc3=0;\n\tsqr_add_c(a,0,c1,c2,c3);\n\tr[0]=c1;\n\tc1=0;\n\tsqr_add_c2(a,1,0,c2,c3,c1);\n\tr[1]=c2;\n\tc2=0;\n\tsqr_add_c(a,1,c3,c1,c2);\n\tsqr_add_c2(a,2,0,c3,c1,c2);\n\tr[2]=c3;\n\tc3=0;\n\tsqr_add_c2(a,3,0,c1,c2,c3);\n\tsqr_add_c2(a,2,1,c1,c2,c3);\n\tr[3]=c1;\n\tc1=0;\n\tsqr_add_c(a,2,c2,c3,c1);\n\tsqr_add_c2(a,3,1,c2,c3,c1);\n\tr[4]=c2;\n\tc2=0;\n\tsqr_add_c2(a,3,2,c3,c1,c2);\n\tr[5]=c3;\n\tc3=0;\n\tsqr_add_c(a,3,c1,c2,c3);\n\tr[6]=c1;\n\tr[7]=c2;\n\t}", "target": 1}
{"code": "static int walk_hugetlb_range(unsigned long addr, unsigned long end,\n\t\t\t      struct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct hstate *h = hstate_vma(vma);\n\tunsigned long next;\n\tunsigned long hmask = huge_page_mask(h);\n\tunsigned long sz = huge_page_size(h);\n\tpte_t *pte;\n\tint err = 0;\n\tdo {\n\t\tnext = hugetlb_entry_end(h, addr, end);\n\t\tpte = huge_pte_offset(walk->mm, addr & hmask, sz);\n\t\tif (pte && walk->hugetlb_entry)\n\t\t\terr = walk->hugetlb_entry(pte, hmask, addr, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (addr = next, addr != end);\n\treturn err;\n}", "target": 1}
{"code": "check_entry_size_and_hooks(struct ip6t_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\tif (!ip6_checkentry(&e->ipv6))\n\t\treturn -EINVAL;\n\terr = xt_check_entry_offsets(e, e->target_offset, e->next_offset);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 1}
{"code": "psf_asciiheader_printf (SF_PRIVATE *psf, const char *format, ...)\n{\tva_list\targptr ;\n\tint\t\tmaxlen ;\n\tchar\t*start ;\n\tmaxlen = strlen ((char*) psf->header) ;\n\tstart\t= ((char*) psf->header) + maxlen ;\n\tmaxlen\t= sizeof (psf->header) - maxlen ;\n\tva_start (argptr, format) ;\n\tvsnprintf (start, maxlen, format, argptr) ;\n\tva_end (argptr) ;\n\tstart [maxlen - 1] = 0 ;\n\tpsf->headindex = strlen ((char*) psf->header) ;\n\treturn ;\n} ", "target": 1}
{"code": "void gf_bs_skip_bytes(GF_BitStream *bs, u64 nbBytes)\n{\n\tif (!bs || !nbBytes) return;\n\tgf_bs_align(bs);\n\tif ((bs->bsmode == GF_BITSTREAM_FILE_WRITE) || (bs->bsmode == GF_BITSTREAM_FILE_READ)) {\n\t\tif (bs->cache_write)\n\t\t\tbs_flush_write_cache(bs);\n\t\tif (bs->cache_read) {\n\t\t\tu32 csize = bs->cache_read_size - bs->cache_read_pos;\n\t\t\tif (csize>=nbBytes) {\n\t\t\t\tbs->cache_read_pos += (u32) nbBytes;\n\t\t\t\tbs->position += nbBytes;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tnbBytes -= csize;\n\t\t\tbs->position += csize;\n\t\t\tbs->cache_read_pos = bs->cache_read_size;\n\t\t}\n\t\tbs->position += nbBytes;\n\t\tif (bs->bsmode == GF_BITSTREAM_FILE_READ) {\n\t\t\tif (bs->position > bs->size) bs->position = bs->size;\n\t\t}\n\t\tgf_fseek(bs->stream, bs->position, SEEK_SET);\n\t\treturn;\n\t}\n\tif (bs->bsmode == GF_BITSTREAM_READ) {\n\t\tif (bs->remove_emul_prevention_byte) {\n\t\t\twhile (nbBytes) {\n\t\t\t\tgf_bs_read_u8(bs);\n\t\t\t\tnbBytes--;\n\t\t\t}\n\t\t} else {\n\t\t\tbs->position += nbBytes;\n\t\t\tif (bs->position>bs->size) {\n\t\t\t\tbs->position = bs->size;\n\t\t\t\tbs->overflow_state = 1;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\twhile (nbBytes) {\n\t\tgf_bs_write_int(bs, 0, 8);\n\t\tnbBytes--;\n\t}\n}", "target": 0}
{"code": "resolve_list_keys(struct lys_node_list *list, const char *keys_str)\n{\n    int i, len, rc;\n    const char *value;\n    char *s = NULL;\n    struct ly_ctx *ctx = list->module->ctx;\n    for (i = 0; i < list->keys_size; ++i) {\n        assert(keys_str);\n        if (!list->child) {\n            LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_LYS, list, \"list keys\", keys_str);\n            return EXIT_FAILURE;\n        }\n        if ((value = strpbrk(keys_str, \" \\t\\n\"))) {\n            len = value - keys_str;\n            while (isspace(value[0])) {\n                value++;\n            }\n        } else {\n            len = strlen(keys_str);\n        }\n        rc = lys_getnext_data(lys_node_module((struct lys_node *)list), (struct lys_node *)list, keys_str, len, LYS_LEAF,\n                              (const struct lys_node **)&list->keys[i]);\n        if (rc) {\n            LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_LYS, list, \"list key\", keys_str);\n            return EXIT_FAILURE;\n        }\n        if (check_key(list, i, keys_str, len)) {\n            return -1;\n        }\n        if (lyp_check_status(list->flags, list->module, list->name,\n                             list->keys[i]->flags, list->keys[i]->module, list->keys[i]->name,\n                             (struct lys_node *)list->keys[i])) {\n            return -1;\n        }\n        if (list->keys[i]->dflt) {\n            assert(log_opt == ILO_STORE);\n            log_opt = ILO_LOG;\n            LOGWRN(ctx, \"Default value \\\"%s\\\" in the list key \\\"%s\\\" is ignored. (%s)\", list->keys[i]->dflt,\n                   list->keys[i]->name, s = lys_path((struct lys_node*)list, LYS_PATH_FIRST_PREFIX));\n            log_opt = ILO_STORE;\n            free(s);\n        }\n        while (value && isspace(value[0])) {\n            value++;\n        }\n        keys_str = value;\n    }\n    return EXIT_SUCCESS;\n}", "target": 1}
{"code": "  void ComputeAsyncImpl(OpKernelContext* c, CollectiveExecutor* col_exec,\n                        DoneCallback done) override {\n    auto output_shape = c->input(0).shape();\n    OP_REQUIRES_ASYNC(c, output_shape.dims() > 0,\n                      errors::InvalidArgument(\"input should have rank > 0, \",\n                                              \"recieved \", output_shape.dims()),\n                      done);\n    output_shape.set_dim(\n        0, output_shape.dim_size(0) * col_params_->group.group_size);\n    col_params_->instance.shape = output_shape;\n    if (c->mutable_output(0) == nullptr) {\n      Tensor* output = nullptr;\n      OP_REQUIRES_OK_ASYNC(\n          c, c->allocate_output(0, col_params_->instance.shape, &output), done);\n    }\n    if (!CanProceedWithCompute(c, col_exec, done)) return;\n    auto actual_done = [c, col_params = col_params_, done](const Status& s) {\n      VLOG(1) << \"CollectiveGatherOpKernel ExecuteAsync done for collective \"\n              << c->op_kernel().name() << \" device \" << c->device()->name()\n              << \" group \" << col_params->group.group_key << \" instance \"\n              << col_params->instance.instance_key << \" status \" << s;\n      col_params->Unref();\n      OP_REQUIRES_OK_ASYNC(c, s, done);\n      done();\n    };\n    VLOG(1) << \"CollectiveGatherOpKernel ExecuteAsync start for collective \"\n            << col_params_->name << \" device \" << c->device()->name()\n            << \" group \" << col_params_->group.group_key << \" instance \"\n            << col_params_->instance.instance_key;\n    col_params_->Ref();\n    col_exec->ExecuteAsync(c, col_params_, GetCollectiveKey(c), actual_done);\n  }", "target": 0}
{"code": "batadv_frag_merge_packets(struct hlist_head *chain, struct sk_buff *skb)\n{\n\tstruct batadv_frag_packet *packet;\n\tstruct batadv_frag_list_entry *entry;\n\tstruct sk_buff *skb_out = NULL;\n\tint size, hdr_size = sizeof(struct batadv_frag_packet);\n\tpacket = (struct batadv_frag_packet *)skb->data;\n\tsize = ntohs(packet->total_size);\n\tif (size > batadv_frag_size_limit())\n\t\tgoto free;\n\tentry = hlist_entry(chain->first, struct batadv_frag_list_entry, list);\n\thlist_del(&entry->list);\n\tskb_out = entry->skb;\n\tkfree(entry);\n\tif (pskb_expand_head(skb_out, 0, size - skb->len, GFP_ATOMIC) < 0) {\n\t\tkfree_skb(skb_out);\n\t\tskb_out = NULL;\n\t\tgoto free;\n\t}\n\tskb_pull_rcsum(skb_out, hdr_size);\n\tmemmove(skb_out->data - ETH_HLEN, skb_mac_header(skb_out), ETH_HLEN);\n\tskb_set_mac_header(skb_out, -ETH_HLEN);\n\tskb_reset_network_header(skb_out);\n\tskb_reset_transport_header(skb_out);\n\thlist_for_each_entry(entry, chain, list) {\n\t\tsize = entry->skb->len - hdr_size;\n\t\tmemcpy(skb_put(skb_out, size), entry->skb->data + hdr_size,\n\t\t       size);\n\t}\nfree:\n\tbatadv_frag_clear_chain(chain);\n\treturn skb_out;\n}", "target": 1}
{"code": "static void settings_init(void) {\n    settings.use_cas = true;\n    settings.access = 0700;\n    settings.port = 11211;\n    settings.udpport = 11211;\n    settings.inter = NULL;\n    settings.maxbytes = 64 * 1024 * 1024; \n    settings.maxconns = 1024;         \n    settings.verbose = 0;\n    settings.oldest_live = 0;\n    settings.oldest_cas = 0;          \n    settings.evict_to_free = 1;       \n    settings.socketpath = NULL;       \n    settings.factor = 1.25;\n    settings.chunk_size = 48;         \n    settings.num_threads = 4;         \n    settings.num_threads_per_udp = 0;\n    settings.prefix_delimiter = ':';\n    settings.detail_enabled = 0;\n    settings.reqs_per_event = 20;\n    settings.backlog = 1024;\n    settings.binding_protocol = negotiating_prot;\n    settings.item_size_max = 1024 * 1024; \n    settings.slab_page_size = 1024 * 1024; \n    settings.slab_chunk_size_max = settings.slab_page_size / 2;\n    settings.sasl = false;\n    settings.maxconns_fast = true;\n    settings.lru_crawler = false;\n    settings.lru_crawler_sleep = 100;\n    settings.lru_crawler_tocrawl = 0;\n    settings.lru_maintainer_thread = false;\n    settings.lru_segmented = true;\n    settings.hot_lru_pct = 20;\n    settings.warm_lru_pct = 40;\n    settings.hot_max_factor = 0.2;\n    settings.warm_max_factor = 2.0;\n    settings.inline_ascii_response = false;\n    settings.temp_lru = false;\n    settings.temporary_ttl = 61;\n    settings.idle_timeout = 0; \n    settings.hashpower_init = 0;\n    settings.slab_reassign = true;\n    settings.slab_automove = 1;\n    settings.slab_automove_ratio = 0.8;\n    settings.slab_automove_window = 30;\n    settings.shutdown_command = false;\n    settings.tail_repair_time = TAIL_REPAIR_TIME_DEFAULT;\n    settings.flush_enabled = true;\n    settings.dump_enabled = true;\n    settings.crawls_persleep = 1000;\n    settings.logger_watcher_buf_size = LOGGER_WATCHER_BUF_SIZE;\n    settings.logger_buf_size = LOGGER_BUF_SIZE;\n    settings.drop_privileges = true;\n#ifdef MEMCACHED_DEBUG\n    settings.relaxed_privileges = false;\n#endif\n}", "target": 1}
{"code": "ansi_step(pansi, ch)\n\tstruct ansi_state *pansi;\n\tLWCHAR ch;\n{\n\tif (pansi->hlink)\n\t{\n\t\tif (ch == '\\7')\n\t\t\treturn ANSI_END;\n\t\tif (pansi->prev_esc && ch == '\\\\')\n\t\t\treturn ANSI_END;\n\t\tpansi->prev_esc = (ch == ESC);\n\t\treturn ANSI_MID;\n\t}\n\tif (pansi->hindex >= 0)\n\t{\n\t\tstatic char hlink_prefix[] = ESCS \"]8;\";\n\t\tif (ch == hlink_prefix[pansi->hindex] ||\n\t\t    (pansi->hindex == 0 && IS_CSI_START(ch)))\n\t\t{\n\t\t\tpansi->hindex++;\n\t\t\tif (hlink_prefix[pansi->hindex] == '\\0')\n\t\t\t\tpansi->hlink = 1; \n\t\t\treturn ANSI_MID;\n\t\t}\n\t\tpansi->hindex = -1; \n\t}\n\tif (is_ansi_middle(ch))\n\t\treturn ANSI_MID;\n\tif (is_ansi_end(ch))\n\t\treturn ANSI_END;\n\treturn ANSI_ERR;\n}", "target": 1}
{"code": "static inline bool cpu_has_vmx_invept_context(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_EXTENT_CONTEXT_BIT;\n}", "target": 0}
{"code": "void *enc_untrusted_realloc(void *ptr, size_t size) {\n  MessageWriter input;\n  input.Push(reinterpret_cast<uint64_t>(ptr));\n  input.Push(static_cast<uint64_t>(size));\n  MessageReader output;\n  asylo::primitives::PrimitiveStatus status =\n      asylo::host_call::NonSystemCallDispatcher(\n          asylo::host_call::kReallocHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_realloc\", 2);\n  void *result = output.next<void *>();\n  int klinux_errno = output.next<int>();\n  if (!result && size != 0) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n  }\n  if (!::asylo::primitives::TrustedPrimitives::IsOutsideEnclave(result, size)) {\n    ::asylo::primitives::TrustedPrimitives::BestEffortAbort(\n        \"enc_untrusted_realloc: realloc result should be in untrusted \"\n        \"memory\");\n  }\n  return result;\n}", "target": 0}
{"code": "gfx::Rect RootWindowHostLinux::GetBounds() const {\n  return bounds_;\n}", "target": 0}
{"code": "static void __exit mb2cache_exit(void)\n{\n\tkmem_cache_destroy(mb2_entry_cache);\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    auto x = ctx->input(0);\n    auto i = ctx->input(1);\n    auto v = ctx->input(2);\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(i.shape()),\n                errors::InvalidArgument(\"i must be a vector. \",\n                                        i.shape().DebugString()));\n    OP_REQUIRES(ctx, x.dims() == v.dims(),\n                errors::InvalidArgument(\n                    \"x and v shape doesn't match (ranks differ): \",\n                    x.shape().DebugString(), \" vs. \", v.shape().DebugString()));\n    for (int i = 1; i < x.dims(); ++i) {\n      OP_REQUIRES(\n          ctx, x.dim_size(i) == v.dim_size(i),\n          errors::InvalidArgument(\"x and v shape doesn't match at index \", i,\n                                  \" : \", x.shape().DebugString(), \" vs. \",\n                                  v.shape().DebugString()));\n    }\n    OP_REQUIRES(ctx, i.dim_size(0) == v.dim_size(0),\n                errors::InvalidArgument(\n                    \"i and x shape doesn't match at index 0: \",\n                    i.shape().DebugString(), \" vs. \", v.shape().DebugString()));\n    Tensor y = x;  \n    if (x.NumElements() > 0 || v.NumElements() > 0) {\n      OP_REQUIRES_OK(ctx, DoCompute(ctx, i, v, &y));\n    }\n    ctx->set_output(0, y);\n  }", "target": 1}
{"code": "bool chopOff(string &domain) \n{\n  if(domain.empty())\n    return false;\n  string::size_type fdot=domain.find('.');\n  if(fdot==string::npos) \n    domain=\"\";\n  else {\n    string::size_type remain = domain.length() - (fdot + 1);\n    char tmp[remain];\n    memcpy(tmp, domain.c_str()+fdot+1, remain);\n    domain.assign(tmp, remain); \n  }\n  return true;\n}", "target": 1}
{"code": "static pyc_object *get_array_object_generic(RBuffer *buffer, ut32 size) {\n\tpyc_object *tmp = NULL;\n\tpyc_object *ret = NULL;\n\tut32 i = 0;\n\tret = R_NEW0 (pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->data = r_list_newf ((RListFree)free_object);\n\tif (!ret->data) {\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < size; i++) {\n\t\ttmp = get_object (buffer);\n\t\tif (!tmp) {\n\t\t\tr_list_free (ret->data);\n\t\t\tR_FREE (ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!r_list_append (ret->data, tmp)) {\n\t\t\tfree_object (tmp);\n\t\t\tr_list_free (ret->data);\n\t\t\tfree (ret);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static void vmcs_set_bits(unsigned long field, u32 mask)\n{\n\tvmcs_writel(field, vmcs_readl(field) | mask);\n}", "target": 0}
{"code": "void beforeSleep(struct aeEventLoop *eventLoop) {\n    REDIS_NOTUSED(eventLoop);\n    listNode *ln;\n    redisClient *c;\n    if (server.vm_enabled && listLength(server.io_ready_clients)) {\n        listIter li;\n        listRewind(server.io_ready_clients,&li);\n        while((ln = listNext(&li))) {\n            c = ln->value;\n            struct redisCommand *cmd;\n            listDelNode(server.io_ready_clients,ln);\n            c->flags &= (~REDIS_IO_WAIT);\n            server.vm_blocked_clients--;\n            aeCreateFileEvent(server.el, c->fd, AE_READABLE,\n                readQueryFromClient, c);\n            cmd = lookupCommand(c->argv[0]->ptr);\n            redisAssert(cmd != NULL);\n            call(c,cmd);\n            resetClient(c);\n            if (c->querybuf && sdslen(c->querybuf) > 0)\n                processInputBuffer(c);\n        }\n    }\n    while (listLength(server.unblocked_clients)) {\n        ln = listFirst(server.unblocked_clients);\n        redisAssert(ln != NULL);\n        c = ln->value;\n        listDelNode(server.unblocked_clients,ln);\n        if (c->querybuf && sdslen(c->querybuf) > 0)\n            processInputBuffer(c);\n    }\n    flushAppendOnlyFile();\n}", "target": 1}
{"code": "static void flush_cmd(void)\n{\n    scanned = readnbd = (size_t) 0U;\n}", "target": 0}
{"code": "usm_free_usmStateReference(void *old)\n{\n    struct usmStateReference *old_ref = (struct usmStateReference *) old;\n    if (old_ref) {\n        if (old_ref->usr_name_length)\n            SNMP_FREE(old_ref->usr_name);\n        if (old_ref->usr_engine_id_length)\n            SNMP_FREE(old_ref->usr_engine_id);\n        if (old_ref->usr_auth_protocol_length)\n            SNMP_FREE(old_ref->usr_auth_protocol);\n        if (old_ref->usr_priv_protocol_length)\n            SNMP_FREE(old_ref->usr_priv_protocol);\n        if (old_ref->usr_auth_key_length && old_ref->usr_auth_key) {\n            SNMP_ZERO(old_ref->usr_auth_key, old_ref->usr_auth_key_length);\n            SNMP_FREE(old_ref->usr_auth_key);\n        }\n        if (old_ref->usr_priv_key_length && old_ref->usr_priv_key) {\n            SNMP_ZERO(old_ref->usr_priv_key, old_ref->usr_priv_key_length);\n            SNMP_FREE(old_ref->usr_priv_key);\n        }\n        SNMP_ZERO(old_ref, sizeof(*old_ref));\n        SNMP_FREE(old_ref);\n    }\n}                               ", "target": 1}
{"code": "static void send(node_t *node, node_t *child, byte *fout) {\n\tif (node->parent) {\n\t\tsend(node->parent, node, fout);\n\t}\n\tif (child) {\n\t\tif (node->right == child) {\n\t\t\tadd_bit(1, fout);\n\t\t} else {\n\t\t\tadd_bit(0, fout);\n\t\t}\n\t}\n}", "target": 1}
{"code": "spnego_gss_unwrap(\n\t\tOM_uint32 *minor_status,\n\t\tgss_ctx_id_t context_handle,\n\t\tgss_buffer_t input_message_buffer,\n\t\tgss_buffer_t output_message_buffer,\n\t\tint *conf_state,\n\t\tgss_qop_t *qop_state)\n{\n\tOM_uint32 ret;\n\tret = gss_unwrap(minor_status,\n\t\t\tcontext_handle,\n\t\t\tinput_message_buffer,\n\t\t\toutput_message_buffer,\n\t\t\tconf_state,\n\t\t\tqop_state);\n\treturn (ret);\n}", "target": 1}
{"code": "bool WideToCharMap(const wchar *Src,char *Dest,size_t DestSize,bool &Success)\n{\n  if (wcschr(Src,(wchar)MappedStringMark)==NULL)\n    return false;\n  Success=true;\n  uint SrcPos=0,DestPos=0;\n  while (Src[SrcPos]!=0 && DestPos<DestSize-MB_CUR_MAX)\n  {\n    if (uint(Src[SrcPos])==MappedStringMark)\n    {\n      SrcPos++;\n      continue;\n    }\n    if (uint(Src[SrcPos])>=MapAreaStart+0x80 && uint(Src[SrcPos])<MapAreaStart+0x100)\n      Dest[DestPos++]=char(uint(Src[SrcPos++])-MapAreaStart);\n    else\n    {\n      mbstate_t ps;\n      memset(&ps,0,sizeof(ps));\n      if (wcrtomb(Dest+DestPos,Src[SrcPos],&ps)==-1)\n      {\n        Dest[DestPos]='_';\n        Success=false;\n      }\n      SrcPos++;\n      memset(&ps,0,sizeof(ps));\n      int Length=mbrlen(Dest+DestPos,MB_CUR_MAX,&ps);\n      DestPos+=Max(Length,1);\n    }\n  }\n  Dest[Min(DestPos,DestSize-1)]=0;\n  return true;\n}", "target": 1}
{"code": "static inline int ccid_hc_tx_getsockopt(struct ccid *ccid, struct sock *sk,\n\t\t\t\t\tconst int optname, int len,\n\t\t\t\t\tu32 __user *optval, int __user *optlen)\n{\n\tint rc = -ENOPROTOOPT;\n\tif (ccid->ccid_ops->ccid_hc_tx_getsockopt != NULL)\n\t\trc = ccid->ccid_ops->ccid_hc_tx_getsockopt(sk, optname, len,\n\t\t\t\t\t\t optval, optlen);\n\treturn rc;\n}", "target": 1}
{"code": "FileInformation ImageReadJPEG(\n      Image& out,\n      String const& filename\n) {\n   JpegInput jpeg( filename );\n   FileInformation info = GetJPEGInfo( jpeg );\n   int nchan = jpeg.cinfo().num_components;\n   jpeg.cinfo().out_color_space = nchan > 1 ? JCS_RGB : JCS_GRAYSCALE;\n   out.ReForge( info.sizes, info.tensorElements, DT_UINT8, Option::AcceptDataTypeChange::DONT_ALLOW );\n   out.SetPixelSize( info.pixelSize );\n   out.SetColorSpace( info.colorSpace );\n   jpeg_start_decompress( jpeg.cinfoptr() );\n   std::vector< JSAMPLE > buffer( info.sizes[ 0 ] * static_cast< unsigned >( nchan )); \n   dip::uint8* imagedata = static_cast< dip::uint8* >( out.Origin() );\n   auto stride = out.Strides();\n   auto tStride = out.TensorStride();\n   for( dip::uint ii = 0; ii < info.sizes[ 1 ]; ++ii ) {\n      JSAMPLE* indata = buffer.data();\n      jpeg_read_scanlines( jpeg.cinfoptr(), &indata, 1 );\n      dip::uint8* outdata = imagedata;\n      if( nchan > 1 ) {\n         for( dip::uint jj = 0; jj < info.sizes[ 0 ]; ++jj ) {\n            for( int kk = 0; kk < nchan; ++kk ) {\n               *( outdata + kk * tStride ) = *indata;\n               ++indata;\n            }\n            outdata += stride[ 0 ];\n         }\n      } else {\n         for( dip::uint jj = 0; jj < info.sizes[ 0 ]; ++jj ) {\n            *outdata = *indata;\n            ++indata;\n            outdata += stride[ 0 ];\n         }\n      }\n      imagedata += stride[ 1 ];\n   }\n   jpeg_finish_decompress( jpeg.cinfoptr() );\n   return info;\n}", "target": 1}
{"code": "void Lab2ITU(const cmsCIELab* Lab, cmsUInt16Number Out[3])\n{\n\tOut[0] = (cmsUInt16Number) floor((double) (Lab -> L / 100.)* 65535. );\n\tOut[1] = (cmsUInt16Number) floor((double) (Lab -> a / 170.)* 65535. + 32768. );\n\tOut[2] = (cmsUInt16Number) floor((double) (Lab -> b / 200.)* 65535. + 24576. );\n}", "target": 0}
{"code": "nfsd4_getdeviceinfo(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_getdeviceinfo *gdp)\n{\n\tconst struct nfsd4_layout_ops *ops;\n\tstruct nfsd4_deviceid_map *map;\n\tstruct svc_export *exp;\n\t__be32 nfserr;\n\tdprintk(\"%s: layout_type %u dev_id [0x%llx:0x%x] maxcnt %u\\n\",\n\t       __func__,\n\t       gdp->gd_layout_type,\n\t       gdp->gd_devid.fsid_idx, gdp->gd_devid.generation,\n\t       gdp->gd_maxcount);\n\tmap = nfsd4_find_devid_map(gdp->gd_devid.fsid_idx);\n\tif (!map) {\n\t\tdprintk(\"%s: couldn't find device ID to export mapping!\\n\",\n\t\t\t__func__);\n\t\treturn nfserr_noent;\n\t}\n\texp = rqst_exp_find(rqstp, map->fsid_type, map->fsid);\n\tif (IS_ERR(exp)) {\n\t\tdprintk(\"%s: could not find device id\\n\", __func__);\n\t\treturn nfserr_noent;\n\t}\n\tnfserr = nfserr_layoutunavailable;\n\tops = nfsd4_layout_verify(exp, gdp->gd_layout_type);\n\tif (!ops)\n\t\tgoto out;\n\tnfserr = nfs_ok;\n\tif (gdp->gd_maxcount != 0) {\n\t\tnfserr = ops->proc_getdeviceinfo(exp->ex_path.mnt->mnt_sb,\n\t\t\t\trqstp, cstate->session->se_client, gdp);\n\t}\n\tgdp->gd_notify_types &= ops->notify_types;\nout:\n\texp_put(exp);\n\treturn nfserr;\n}", "target": 0}
{"code": "void RGWDelBucketMetaSearch_ObjStore_S3::send_response()\n{\n  if (op_ret)\n    set_req_state_err(s, op_ret);\n  dump_errno(s);\n  end_header(s, this);\n}", "target": 0}
{"code": "void RenderView::SyncNavigationState() {\n  if (!webview())\n    return;\n  const WebHistoryItem& item = webview()->mainFrame()->currentHistoryItem();\n  if (item.isNull())\n    return;\n  Send(new ViewHostMsg_UpdateState(\n      routing_id_, page_id_, webkit_glue::HistoryItemToString(item)));\n}", "target": 0}
{"code": "static int ScaKwdTab(GmfMshSct *msh)\n{\n   int      KwdCod, c;\n   int64_t  NexPos, EndPos, LstPos;\n   char     str[ GmfStrSiz ];\n   if(msh->typ & Asc)\n   {\n      while(fscanf(msh->hdl, \"%s\", str) != EOF)\n      {\n         if(isalpha(str[0]))\n         {\n            for(KwdCod=1; KwdCod<= GmfMaxKwd; KwdCod++)\n               if(!strcmp(str, GmfKwdFmt[ KwdCod ][0]))\n               {\n                  ScaKwdHdr(msh, KwdCod);\n                  break;\n               }\n         }\n         else if(str[0] == '#')\n            while((c = fgetc(msh->hdl)) != '\\n' && c != EOF);\n      }\n   }\n   else\n   {\n      EndPos = GetFilSiz(msh);\n      LstPos = -1;\n      do\n      {\n         ScaWrd(msh, ( char *)&KwdCod);\n         NexPos = GetPos(msh);\n         if(NexPos > EndPos)\n            longjmp(msh->err, -24);\n         if(NexPos && (NexPos <= LstPos))\n            longjmp(msh->err, -30);\n         LstPos = NexPos;\n         if( (KwdCod >= 1) && (KwdCod <= GmfMaxKwd) )\n            ScaKwdHdr(msh, KwdCod);\n         if(NexPos && !(SetFilPos(msh, NexPos)))\n            longjmp(msh->err, -25);\n      }while(NexPos && (KwdCod != GmfEnd));\n   }\n   return(1);\n}", "target": 1}
{"code": "static int fallocate_chunk(struct inode *inode, loff_t offset, loff_t len,\n\t\t\t   int mode)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct buffer_head *dibh;\n\tint error;\n\tu64 start = offset >> PAGE_CACHE_SHIFT;\n\tunsigned int start_offset = offset & ~PAGE_CACHE_MASK;\n\tu64 end = (offset + len - 1) >> PAGE_CACHE_SHIFT;\n\tpgoff_t curr;\n\tstruct page *page;\n\tunsigned int end_offset = (offset + len) & ~PAGE_CACHE_MASK;\n\tunsigned int from, to;\n\tif (!end_offset)\n\t\tend_offset = PAGE_CACHE_SIZE;\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (unlikely(error))\n\t\tgoto out;\n\tgfs2_trans_add_bh(ip->i_gl, dibh, 1);\n\tif (gfs2_is_stuffed(ip)) {\n\t\terror = gfs2_unstuff_dinode(ip, NULL);\n\t\tif (unlikely(error))\n\t\t\tgoto out;\n\t}\n\tcurr = start;\n\toffset = start << PAGE_CACHE_SHIFT;\n\tfrom = start_offset;\n\tto = PAGE_CACHE_SIZE;\n\twhile (curr <= end) {\n\t\tpage = grab_cache_page_write_begin(inode->i_mapping, curr,\n\t\t\t\t\t\t   AOP_FLAG_NOFS);\n\t\tif (unlikely(!page)) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tif (curr == end)\n\t\t\tto = end_offset;\n\t\terror = write_empty_blocks(page, from, to, mode);\n\t\tif (!error && offset + to > inode->i_size &&\n\t\t    !(mode & FALLOC_FL_KEEP_SIZE)) {\n\t\t\ti_size_write(inode, offset + to);\n\t\t}\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tcurr++;\n\t\toffset += PAGE_CACHE_SIZE;\n\t\tfrom = 0;\n\t}\n\tmark_inode_dirty(inode);\n\tbrelse(dibh);\nout:\n\treturn error;\n}", "target": 1}
{"code": "mbc_case_fold(OnigCaseFoldType flag,\n\t      const UChar** pp, const UChar* end ARG_UNUSED, UChar* lower,\n\t      OnigEncoding enc ARG_UNUSED)\n{\n  const UChar* p = *pp;\n  if (*p == SHARP_s && (flag & INTERNAL_ONIGENC_CASE_FOLD_MULTI_CHAR) != 0) {\n    *lower++ = 's';\n    *lower   = 's';\n    (*pp)++;\n    return 2;\n  }\n  *lower = ENC_CP1254_TO_LOWER_CASE(*p);\n  (*pp)++;\n  return 1;\n}", "target": 0}
{"code": "sudo_auth_end_session(void)\n{\n    sudo_auth *auth;\n    int status;\n    debug_decl(sudo_auth_end_session, SUDOERS_DEBUG_AUTH);\n    for (auth = auth_switch; auth->name; auth++) {\n\tif (auth->end_session && !IS_DISABLED(auth)) {\n\t    status = (auth->end_session)(auth);\n\t    if (status == AUTH_ERROR) {\n\t\tdebug_return_int(-1);\n\t    }\n\t}\n    }\n    debug_return_int(1);\n}", "target": 1}
{"code": "void ImplPolygon::ImplSplit( sal_uInt16 nPos, sal_uInt16 nSpace, ImplPolygon const * pInitPoly )\n{\n    if (mnPoints + nSpace > USHRT_MAX)\n        return;\n    const sal_uInt16    nNewSize = mnPoints + nSpace;\n    const std::size_t   nSpaceSize = static_cast<std::size_t>(nSpace) * sizeof(Point);\n    if( nPos >= mnPoints )\n    {\n        nPos = mnPoints;\n        ImplSetSize( nNewSize );\n        if( pInitPoly )\n        {\n            memcpy( mpPointAry + nPos, pInitPoly->mpPointAry, nSpaceSize );\n            if( pInitPoly->mpFlagAry )\n                memcpy( mpFlagAry + nPos, pInitPoly->mpFlagAry, nSpace );\n        }\n    }\n    else\n    {\n        const sal_uInt16    nSecPos = nPos + nSpace;\n        const sal_uInt16    nRest = mnPoints - nPos;\n        Point* pNewAry = reinterpret_cast<Point*>(new char[ static_cast<std::size_t>(nNewSize) * sizeof(Point) ]);\n        memcpy( pNewAry, mpPointAry, nPos * sizeof( Point ) );\n        if( pInitPoly )\n            memcpy( pNewAry + nPos, pInitPoly->mpPointAry, nSpaceSize );\n        else\n            memset( pNewAry + nPos, 0, nSpaceSize );\n        memcpy( pNewAry + nSecPos, mpPointAry + nPos, nRest * sizeof( Point ) );\n        delete[] reinterpret_cast<char*>(mpPointAry);\n        if( mpFlagAry )\n        {\n            PolyFlags* pNewFlagAry = new PolyFlags[ nNewSize ];\n            memcpy( pNewFlagAry, mpFlagAry, nPos );\n            if( pInitPoly && pInitPoly->mpFlagAry )\n                memcpy( pNewFlagAry + nPos, pInitPoly->mpFlagAry, nSpace );\n            else\n                memset( pNewFlagAry + nPos, 0, nSpace );\n            memcpy( pNewFlagAry + nSecPos, mpFlagAry + nPos, nRest );\n            delete[] mpFlagAry;\n            mpFlagAry = pNewFlagAry;\n        }\n        mpPointAry = pNewAry;\n        mnPoints   = nNewSize;\n    }\n}", "target": 1}
{"code": "isis_print_id(const uint8_t *cp, int id_len)\n{\n    int i;\n    static char id[sizeof(\"xxxx.xxxx.xxxx.yy-zz\")];\n    char *pos = id;\n    for (i = 1; i <= SYSTEM_ID_LEN; i++) {\n        snprintf(pos, sizeof(id) - (pos - id), \"%02x\", *cp++);\n\tpos += strlen(pos);\n\tif (i == 2 || i == 4)\n\t    *pos++ = '.';\n\t}\n    if (id_len >= NODE_ID_LEN) {\n        snprintf(pos, sizeof(id) - (pos - id), \".%02x\", *cp++);\n\tpos += strlen(pos);\n    }\n    if (id_len == LSP_ID_LEN)\n        snprintf(pos, sizeof(id) - (pos - id), \"-%02x\", *cp);\n    return (id);\n}", "target": 1}
{"code": "check_sudo (GError **error)\n{\n  const char *sudo_command_env = g_getenv (\"SUDO_COMMAND\");\n  g_auto(GStrv) split_command = NULL;\n  if (!sudo_command_env)\n    return TRUE;\n  split_command = g_strsplit (sudo_command_env, \" \", 2);\n  if (g_str_has_suffix (split_command[0], \"flatpak\"))\n    return flatpak_fail_error (error, FLATPAK_ERROR, _(\"\\\"flatpak run\\\" is not intended to be run as `sudo flatpak run`, use `sudo -i` or `su -l` instead and invoke \\\"flatpak run\\\" from inside the new shell\"));\n  return TRUE;\n}", "target": 0}
{"code": "l2tp_call_errors_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\tuint16_t val_h, val_l;\n\tptr++;\t\t\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"CRCErr=%u \", (val_h<<16) + val_l));\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"FrameErr=%u \", (val_h<<16) + val_l));\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"HardOver=%u \", (val_h<<16) + val_l));\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"BufOver=%u \", (val_h<<16) + val_l));\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"Timeout=%u \", (val_h<<16) + val_l));\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"AlignErr=%u \", (val_h<<16) + val_l));\n}", "target": 1}
{"code": "search_impl(i_ctx_t *i_ctx_p, bool forward)\n{\n    os_ptr op = osp;\n    os_ptr op1 = op - 1;\n    uint size = r_size(op);\n    uint count;\n    byte *pat;\n    byte *ptr;\n    byte ch;\n    int incr = forward ? 1 : -1;\n    check_read_type(*op1, t_string);\n    check_read_type(*op, t_string);\n    if (size > r_size(op1)) {\t\n        make_false(op);\n        return 0;\n    }\n    count = r_size(op1) - size;\n    ptr = op1->value.bytes;\n    if (size == 0)\n        goto found;\n    if (!forward)\n        ptr += count;\n    pat = op->value.bytes;\n    ch = pat[0];\n    do {\n        if (*ptr == ch && (size == 1 || !memcmp(ptr, pat, size)))\n            goto found;\n        ptr += incr;\n    }\n    while (count--);\n    make_false(op);\n    return 0;\nfound:\n    op->tas.type_attrs = op1->tas.type_attrs;\n    op->value.bytes = ptr;\n    r_set_size(op, size);\n    push(2);\n    op[-1] = *op1;\n    r_set_size(op - 1, ptr - op[-1].value.bytes);\n    op1->value.bytes = ptr + size;\n    r_set_size(op1, count + (!forward ? (size - 1) : 0));\n    make_true(op);\n    return 0;\n}", "target": 1}
{"code": "str_to_archive_type (const char *str)\n{\n\tg_return_val_if_fail (str != NULL, EV_ARCHIVE_TYPE_NONE);\n\tif (g_strcmp0 (str, \"rar\") == 0)\n\t\treturn EV_ARCHIVE_TYPE_RAR;\n\tif (g_strcmp0 (str, \"zip\") == 0)\n\t\treturn EV_ARCHIVE_TYPE_ZIP;\n\tif (g_strcmp0 (str, \"7z\") == 0)\n\t\treturn EV_ARCHIVE_TYPE_7Z;\n\tif (g_strcmp0 (str, \"tar\") == 0)\n\t\treturn EV_ARCHIVE_TYPE_TAR;\n\tg_warning (\"Archive type '%s' not supported\", str);\n\treturn EV_ARCHIVE_TYPE_NONE;\n}", "target": 0}
{"code": "void CZNC::ForceEncoding() {\n    m_uiForceEncoding++;\n#ifdef HAVE_ICU\n    for (Csock* pSock : GetManager()) {\n        if (pSock->GetEncoding().empty()) {\n            pSock->SetEncoding(\"UTF-8\");\n        }\n    }\n#endif\n}", "target": 1}
{"code": "static int AskScriptChanged() {\n    int ret;\n    char *buts[4];\n    buts[0] = _(\"_Yes\");\n    buts[1] = _(\"Yes, and don't _remind me again\");\n    buts[2] = _(\"_No\");\n    buts[3] = NULL;\n    ret = gwwv_ask( _(\"Unsaved script\"),(const char **) buts,0,2,_(\"You have an unsaved script in the «Execute Script» dialog. Do you intend to discard it?\"));\n    if (ret == 1) {\n        warn_script_unsaved = false;\n        SavePrefs(true);\n    }\nreturn( ret );\n}", "target": 0}
{"code": "SYSCALL_DEFINE4(ptrace, long, request, long, pid, unsigned long, addr,\n\t\tunsigned long, data)\n{\n\tstruct task_struct *child;\n\tlong ret;\n\tif (request == PTRACE_TRACEME) {\n\t\tret = ptrace_traceme();\n\t\tif (!ret)\n\t\t\tarch_ptrace_attach(current);\n\t\tgoto out;\n\t}\n\tchild = ptrace_get_task_struct(pid);\n\tif (IS_ERR(child)) {\n\t\tret = PTR_ERR(child);\n\t\tgoto out;\n\t}\n\tif (request == PTRACE_ATTACH || request == PTRACE_SEIZE) {\n\t\tret = ptrace_attach(child, request, addr, data);\n\t\tif (!ret)\n\t\t\tarch_ptrace_attach(child);\n\t\tgoto out_put_task_struct;\n\t}\n\tret = ptrace_check_attach(child, request == PTRACE_KILL ||\n\t\t\t\t  request == PTRACE_INTERRUPT);\n\tif (ret < 0)\n\t\tgoto out_put_task_struct;\n\tret = arch_ptrace(child, request, addr, data);\n\tif (ret || request != PTRACE_DETACH)\n\t\tptrace_unfreeze_traced(child);\n out_put_task_struct:\n\tput_task_struct(child);\n out:\n\treturn ret;\n}", "target": 0}
{"code": "static int dn_create(struct net *net, struct socket *sock, int protocol,\n\t\t     int kern)\n{\n\tstruct sock *sk;\n\tif (protocol < 0 || protocol > SK_PROTOCOL_MAX)\n\t\treturn -EINVAL;\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\tswitch (sock->type) {\n\tcase SOCK_SEQPACKET:\n\t\tif (protocol != DNPROTO_NSP)\n\t\t\treturn -EPROTONOSUPPORT;\n\t\tbreak;\n\tcase SOCK_STREAM:\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\tif ((sk = dn_alloc_sock(net, sock, GFP_KERNEL, kern)) == NULL)\n\t\treturn -ENOBUFS;\n\tsk->sk_protocol = protocol;\n\treturn 0;\n}", "target": 0}
{"code": "\tCxFile(void) { };", "target": 1}
{"code": "nautilus_file_mark_desktop_file_executable (GFile              *file,\n                                            GtkWindow          *parent_window,\n                                            gboolean            interactive,\n                                            NautilusOpCallback  done_callback,\n                                            gpointer            done_callback_data)\n{\n    GTask *task;\n    MarkTrustedJob *job;\n    job = op_job_new (MarkTrustedJob, parent_window);\n    job->file = g_object_ref (file);\n    job->interactive = interactive;\n    job->done_callback = done_callback;\n    job->done_callback_data = done_callback_data;\n    task = g_task_new (NULL, NULL, mark_desktop_file_executable_task_done, job);\n    g_task_set_task_data (task, job, NULL);\n    g_task_run_in_thread (task, mark_desktop_file_executable_task_thread_func);\n    g_object_unref (task);\n}", "target": 0}
{"code": "static int sco_send_frame(struct sock *sk, struct msghdr *msg, int len)\n{\n\tstruct sco_conn *conn = sco_pi(sk)->conn;\n\tstruct sk_buff *skb;\n\tint err;\n\tif (len > conn->mtu)\n\t\treturn -EINVAL;\n\tBT_DBG(\"sk %p len %d\", sk, len);\n\tskb = bt_skb_send_alloc(sk, len, msg->msg_flags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\treturn err;\n\tif (memcpy_from_msg(skb_put(skb, len), msg, len)) {\n\t\tkfree_skb(skb);\n\t\treturn -EFAULT;\n\t}\n\thci_send_sco(conn->hcon, skb);\n\treturn len;\n}", "target": 1}
{"code": "  void whenInputIs(const char *json, size_t len) {\n    memcpy(_jsonString, json, len);\n    _result = QuotedString::extractFrom(_jsonString, &_trailing);\n  }", "target": 0}
{"code": "u32 secure_ipv6_port_ephemeral(const __be32 *saddr, const __be32 *daddr,\n\t\t\t       __be16 dport)\n{\n\tstruct keydata *keyptr = get_keyptr();\n\tu32 hash[12];\n\tmemcpy(hash, saddr, 16);\n\thash[4] = (__force u32)dport;\n\tmemcpy(&hash[5], keyptr->secret, sizeof(__u32) * 7);\n\treturn twothirdsMD4Transform((const __u32 *)daddr, hash);\n}", "target": 1}
{"code": "void sas_unregister_dev(struct asd_sas_port *port, struct domain_device *dev)\n{\n\tif (!test_bit(SAS_DEV_DESTROY, &dev->state) &&\n\t    !list_empty(&dev->disco_list_node)) {\n\t\tlist_del_init(&dev->disco_list_node);\n\t\tsas_rphy_free(dev->rphy);\n\t\tsas_unregister_common_dev(port, dev);\n\t\treturn;\n\t}\n\tif (!test_and_set_bit(SAS_DEV_DESTROY, &dev->state)) {\n\t\tsas_rphy_unlink(dev->rphy);\n\t\tlist_move_tail(&dev->disco_list_node, &port->destroy_list);\n\t\tsas_discover_event(dev->port, DISCE_DESTRUCT);\n\t}\n}", "target": 1}
{"code": "static int __init memory_tier_init(void)\n{\n\tint ret, node;\n\tstruct memory_tier *memtier;\n\tret = subsys_virtual_register(&memory_tier_subsys, NULL);\n\tif (ret)\n\t\tpanic(\"%s() failed to register memory tier subsystem\\n\", __func__);\n#ifdef CONFIG_MIGRATION\n\tnode_demotion = kcalloc(nr_node_ids, sizeof(struct demotion_nodes),\n\t\t\t\tGFP_KERNEL);\n\tWARN_ON(!node_demotion);\n#endif\n\tmutex_lock(&memory_tier_lock);\n\tdefault_dram_type = alloc_memory_type(MEMTIER_ADISTANCE_DRAM);\n\tif (!default_dram_type)\n\t\tpanic(\"%s() failed to allocate default DRAM tier\\n\", __func__);\n\tfor_each_node_state(node, N_MEMORY) {\n\t\tmemtier = set_node_memory_tier(node);\n\t\tif (IS_ERR(memtier))\n\t\t\tbreak;\n\t}\n\testablish_demotion_targets();\n\tmutex_unlock(&memory_tier_lock);\n\thotplug_memory_notifier(memtier_hotplug_callback, MEMTIER_HOTPLUG_PRI);\n\treturn 0;\n}", "target": 1}
{"code": "void AsfVideo::streamProperties() {\n  DataBuf streamTypedBuf = io_->read(GUID);\n  enum class streamTypeInfo { Audio = 1, Video = 2 };\n  auto stream = static_cast<streamTypeInfo>(0);\n  auto tag_stream_type = GUIDReferenceTags.find(GUIDTag(streamTypedBuf.data()));\n  if (tag_stream_type != GUIDReferenceTags.end()) {\n    if (tag_stream_type->second == \"Audio_Media\")\n      stream = streamTypeInfo::Audio;\n    else if (tag_stream_type->second == \"Video_Media\")\n      stream = streamTypeInfo::Video;\n    io_->seek(io_->tell() + GUID, BasicIo::beg);  \n    uint64_t time_offset = readQWORDTag(io_);\n    if (stream == streamTypeInfo::Video)\n      xmpData()[\"Xmp.video.TimeOffset\"] = time_offset;\n    else if (stream == streamTypeInfo::Audio)\n      xmpData()[\"Xmp.audio.TimeOffset\"] = time_offset;\n    auto specific_data_length = readDWORDTag(io_);\n    auto correction_data_length = readDWORDTag(io_);\n    io_->seek(io_->tell() + WORD  + DWORD  + specific_data_length + correction_data_length,\n              BasicIo::beg);\n  }\n}  ", "target": 1}
{"code": "      void Init(void)\n      {\n        for(int i = 0;i < 19;i++) {\n#ifdef DEBUG_QMCODER\n          char string[5] = \"X0  \";\n          string[1] = (i / 10) + '0';\n          string[2] = (i % 10) + '0';\n          X[i].Init(string);\n          string[0] = 'M';\n          M[i].Init(string);\n#else\n          X[i].Init();\n          M[i].Init();\n#endif\n        }\n      }", "target": 1}
{"code": "static BOOL nsc_rle_decode(BYTE* in, BYTE* out, UINT32 outSize, UINT32 originalSize)\n{\n\tUINT32 left = originalSize;\n\twhile (left > 4)\n\t{\n\t\tconst BYTE value = *in++;\n\t\tUINT32 len = 0;\n\t\tif (left == 5)\n\t\t{\n\t\t\tif (outSize < 1)\n\t\t\t\treturn FALSE;\n\t\t\toutSize--;\n\t\t\t*out++ = value;\n\t\t\tleft--;\n\t\t}\n\t\telse if (value == *in)\n\t\t{\n\t\t\tin++;\n\t\t\tif (*in < 0xFF)\n\t\t\t{\n\t\t\t\tlen = (UINT32)*in++;\n\t\t\t\tlen += 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tin++;\n\t\t\t\tlen = ((UINT32)(*in++));\n\t\t\t\tlen |= ((UINT32)(*in++)) << 8U;\n\t\t\t\tlen |= ((UINT32)(*in++)) << 16U;\n\t\t\t\tlen |= ((UINT32)(*in++)) << 24U;\n\t\t\t}\n\t\t\tif (outSize < len)\n\t\t\t\treturn FALSE;\n\t\t\toutSize -= len;\n\t\t\tFillMemory(out, len, value);\n\t\t\tout += len;\n\t\t\tleft -= len;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (outSize < 1)\n\t\t\t\treturn FALSE;\n\t\t\toutSize--;\n\t\t\t*out++ = value;\n\t\t\tleft--;\n\t\t}\n\t}\n\tif ((outSize < 4) || (left < 4))\n\t\treturn FALSE;\n\tmemcpy(out, in, 4);\n\treturn TRUE;\n}", "target": 1}
{"code": "Jsi_RC Jsi_ValueInsertArray(Jsi_Interp *interp, Jsi_Value *target, int key, Jsi_Value *val, int flags)\n{\n    if (target->vt != JSI_VT_OBJECT) {\n        if (interp->strict)\n            Jsi_LogWarn(\"Target is not object\");\n        return JSI_ERROR;\n    }\n    Jsi_Obj *obj = target->d.obj;\n    if (obj->isarrlist) {\n        if (key >= 0 && key < interp->maxArrayList) {\n            Jsi_ObjArraySet(interp, obj, val, key);\n            return JSI_OK;\n        }\n        return JSI_ERROR;\n    }\n    char unibuf[100];\n    Jsi_NumberItoA10(key, unibuf, sizeof(unibuf));\n    Jsi_ObjInsert(interp, obj, unibuf, val, flags);\n    return JSI_OK;\n}", "target": 1}
{"code": "static int apparmor_setprocattr(struct task_struct *task, char *name,\n\t\t\t\tvoid *value, size_t size)\n{\n\tchar *command, *args = value;\n\tsize_t arg_size;\n\tint error;\n\tif (size == 0)\n\t\treturn -EINVAL;\n\tif (args[size - 1] != '\\0') {\n\t\tif (size == PAGE_SIZE)\n\t\t\treturn -EINVAL;\n\t\targs[size] = '\\0';\n\t}\n\tif (current != task)\n\t\treturn -EACCES;\n\targs = value;\n\targs = strim(args);\n\tcommand = strsep(&args, \" \");\n\tif (!args)\n\t\treturn -EINVAL;\n\targs = skip_spaces(args);\n\tif (!*args)\n\t\treturn -EINVAL;\n\targ_size = size - (args - (char *) value);\n\tif (strcmp(name, \"current\") == 0) {\n\t\tif (strcmp(command, \"changehat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permhat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t AA_DO_TEST);\n\t\t} else if (strcmp(command, \"changeprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permipc\") == 0) {\n\t\t\terror = aa_setprocattr_permipc(args);\n\t\t} else {\n\t\t\tstruct common_audit_data sa;\n\t\t\tCOMMON_AUDIT_DATA_INIT(&sa, NONE);\n\t\t\tsa.aad.op = OP_SETPROCATTR;\n\t\t\tsa.aad.info = name;\n\t\t\tsa.aad.error = -EINVAL;\n\t\t\treturn aa_audit(AUDIT_APPARMOR_DENIED, NULL, GFP_KERNEL,\n\t\t\t\t\t&sa, NULL);\n\t\t}\n\t} else if (strcmp(name, \"exec\") == 0) {\n\t\terror = aa_setprocattr_changeprofile(args, AA_ONEXEC,\n\t\t\t\t\t\t     !AA_DO_TEST);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\tif (!error)\n\t\terror = size;\n\treturn error;\n}", "target": 1}
{"code": "static int crypto_report(struct sk_buff *in_skb, struct nlmsghdr *in_nlh,\n\t\t\t struct nlattr **attrs)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct crypto_user_alg *p = nlmsg_data(in_nlh);\n\tstruct crypto_alg *alg;\n\tstruct sk_buff *skb;\n\tstruct crypto_dump_info info;\n\tint err;\n\tif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\n\t\treturn -EINVAL;\n\talg = crypto_alg_match(p, 0);\n\tif (!alg)\n\t\treturn -ENOENT;\n\terr = -ENOMEM;\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!skb)\n\t\tgoto drop_alg;\n\tinfo.in_skb = in_skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = in_nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = 0;\n\terr = crypto_report_alg(alg, &info);\ndrop_alg:\n\tcrypto_mod_put(alg);\n\tif (err)\n\t\treturn err;\n\treturn nlmsg_unicast(net->crypto_nlsk, skb, NETLINK_CB(in_skb).portid);\n}", "target": 1}
{"code": "ikev1_attrmap_print(netdissect_options *ndo,\n\t\t    const u_char *p, const u_char *ep,\n\t\t    const struct attrmap *map, size_t nmap)\n{\n\tint totlen;\n\tuint32_t t, v;\n\tif (p[0] & 0x80)\n\t\ttotlen = 4;\n\telse\n\t\ttotlen = 4 + EXTRACT_16BITS(&p[2]);\n\tif (ep < p + totlen) {\n\t\tND_PRINT((ndo,\"[|attr]\"));\n\t\treturn ep + 1;\n\t}\n\tND_PRINT((ndo,\"(\"));\n\tt = EXTRACT_16BITS(&p[0]) & 0x7fff;\n\tif (map && t < nmap && map[t].type)\n\t\tND_PRINT((ndo,\"type=%s \", map[t].type));\n\telse\n\t\tND_PRINT((ndo,\"type=#%d \", t));\n\tif (p[0] & 0x80) {\n\t\tND_PRINT((ndo,\"value=\"));\n\t\tv = EXTRACT_16BITS(&p[2]);\n\t\tif (map && t < nmap && v < map[t].nvalue && map[t].value[v])\n\t\t\tND_PRINT((ndo,\"%s\", map[t].value[v]));\n\t\telse\n\t\t\trawprint(ndo, (const uint8_t *)&p[2], 2);\n\t} else {\n\t\tND_PRINT((ndo,\"len=%d value=\", EXTRACT_16BITS(&p[2])));\n\t\trawprint(ndo, (const uint8_t *)&p[4], EXTRACT_16BITS(&p[2]));\n\t}\n\tND_PRINT((ndo,\")\"));\n\treturn p + totlen;\n}", "target": 1}
{"code": "static Jsi_RC jsi_ArrayJoinCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    const char *jstr = \"\";\n    int argc, curlen;\n    Jsi_DString dStr = {};\n    curlen = Jsi_ObjGetLength(interp, _this->d.obj);\n    if (curlen == 0) {\n        goto bail;\n    }\n    if (Jsi_ValueGetLength(interp, args) >= 1) {\n        Jsi_Value *sc = Jsi_ValueArrayIndex(interp, args, 0);\n        if (sc != NULL)\n            jstr = Jsi_ValueToString(interp, sc, NULL);\n    }\n    if (0 == (argc=Jsi_ObjGetLength(interp, _this->d.obj))) {\n        goto bail;\n    }\n    int i;\n    for (i = 0; i < argc; ++i) {\n        const char *cp;\n        Jsi_Value *ov = Jsi_ValueArrayIndex(interp, _this, i);\n        if (!ov) {\n            continue;\n            cp = \"\";\n        } else\n            cp = Jsi_ValueToString(interp, ov, NULL);\n        if (i && jstr[0])\n            Jsi_DSAppend(&dStr, jstr, NULL);\n        Jsi_DSAppend(&dStr, cp, NULL);\n    }\n    Jsi_ValueMakeStringDup(interp, ret, Jsi_DSValue(&dStr));\n    Jsi_DSFree(&dStr);\n    return JSI_OK;\nbail:\n    Jsi_ValueMakeStringDup(interp, ret, \"\");\n    return JSI_OK;        \n}", "target": 1}
{"code": "static uint32_t generate_seed() {\n    uint32_t seed;\n    int done = 0;\n#if !defined(_WIN32) && defined(USE_URANDOM)\n    if (!done && seed_from_urandom(&seed) == 0)\n        done = 1;\n#endif\n#if defined(_WIN32) && defined(USE_WINDOWS_CRYPTOAPI)\n    if (!done && seed_from_windows_cryptoapi(&seed) == 0)\n        done = 1;\n#endif\n    if (!done) {\n        seed_from_timestamp_and_pid(&seed);\n    }\n    if (seed == 0)\n        seed = 1;\n    return seed;\n}", "target": 0}
{"code": "static int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_bpcc_t *bpcc = &box->data.bpcc;\n\tunsigned int i;\n\tbpcc->bpcs = 0;\n\tbpcc->numcmpts = box->datalen;\n\tif (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts, sizeof(uint_fast8_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < bpcc->numcmpts; ++i) {\n\t\tif (jp2_getuint8(in, &bpcc->bpcs[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "int sub__messages_queue(const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store **stored)\n{\n\tint rc = MOSQ_ERR_SUCCESS, rc2;\n\tstruct mosquitto__subhier *subhier;\n\tchar **split_topics = NULL;\n\tchar *local_topic = NULL;\n\tassert(topic);\n\tif(sub__topic_tokenise(topic, &local_topic, &split_topics, NULL)) return 1;\n\tdb__msg_store_ref_inc(*stored);\n\tHASH_FIND(hh, db.subs, split_topics[0], strlen(split_topics[0]), subhier);\n\tif(subhier){\n\t\trc = sub__search(subhier, split_topics, source_id, topic, qos, retain, *stored);\n\t}\n\tif(retain){\n\t\trc2 = retain__store(topic, *stored, split_topics);\n\t\tif(rc2) rc = rc2;\n\t}\n\tmosquitto__free(split_topics);\n\tmosquitto__free(local_topic);\n\tdb__msg_store_ref_dec(stored);\n\treturn rc;\n}", "target": 1}
{"code": "static int f2fs_set_data_page_dirty(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode = mapping->host;\n\ttrace_f2fs_set_page_dirty(page, DATA);\n\tif (!PageUptodate(page))\n\t\tSetPageUptodate(page);\n\tif (f2fs_is_atomic_file(inode) && !f2fs_is_commit_atomic_write(inode)) {\n\t\tif (!IS_ATOMIC_WRITTEN_PAGE(page)) {\n\t\t\tf2fs_register_inmem_page(inode, page);\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (!PageDirty(page)) {\n\t\t__set_page_dirty_nobuffers(page);\n\t\tf2fs_update_dirty_page(inode, page);\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "inline TfLiteStatus ValidateTensorIndexingSafe(const TfLiteContext* context,\n                                               int index, int max_size,\n                                               const int* tensor_indices,\n                                               int* tensor_index) {\n  if (index < 0 || index >= max_size) {\n    TF_LITE_KERNEL_LOG(const_cast<TfLiteContext*>(context),\n                       \"Invalid tensor index %d (not in [0, %d))\\n\", index,\n                       max_size);\n    return kTfLiteError;\n  }\n  if (tensor_indices[index] == kTfLiteOptionalTensor) {\n    TF_LITE_KERNEL_LOG(const_cast<TfLiteContext*>(context),\n                       \"Tensor at index %d was optional but was expected\\n\",\n                       index);\n    return kTfLiteError;\n  }\n  *tensor_index = tensor_indices[index];\n  return kTfLiteOk;\n}", "target": 0}
{"code": "PassOwnPtr<SVGDocumentExtensions::SVGPendingElements> SVGDocumentExtensions::removePendingResource(const AtomicString& id)\n{\n    ASSERT(m_pendingResources.contains(id));\n    return m_pendingResources.take(id);\n}", "target": 0}
{"code": "struct lib_t* MACH0_(get_libs)(struct MACH0_(obj_t)* bin) {\n\tstruct lib_t *libs;\n\tint i;\n\tif (!bin->nlibs)\n\t\treturn NULL;\n\tif (!(libs = calloc ((bin->nlibs + 1), sizeof(struct lib_t))))\n\t\treturn NULL;\n\tfor (i = 0; i < bin->nlibs; i++) {\n\t\tstrncpy (libs[i].name, bin->libs[i], R_BIN_MACH0_STRING_LENGTH);\n\t\tlibs[i].name[R_BIN_MACH0_STRING_LENGTH-1] = '\\0';\n\t\tlibs[i].last = 0;\n\t}\n\tlibs[i].last = 1;\n\treturn libs;\n}", "target": 1}
{"code": "void URI_FUNC(ResetUri)(URI_TYPE(Uri) * uri) {\n\tif (uri == NULL) {\n\t\treturn;\n\t}\n\tmemset(uri, 0, sizeof(URI_TYPE(Uri)));\n}", "target": 0}
{"code": "static int inet6_fill_ifla6_attrs(struct sk_buff *skb, struct inet6_dev *idev)\n{\n\tstruct nlattr *nla;\n\tstruct ifla_cacheinfo ci;\n\tif (nla_put_u32(skb, IFLA_INET6_FLAGS, idev->if_flags))\n\t\tgoto nla_put_failure;\n\tci.max_reasm_len = IPV6_MAXPLEN;\n\tci.tstamp = cstamp_delta(idev->tstamp);\n\tci.reachable_time = jiffies_to_msecs(idev->nd_parms->reachable_time);\n\tci.retrans_time = jiffies_to_msecs(idev->nd_parms->retrans_time);\n\tif (nla_put(skb, IFLA_INET6_CACHEINFO, sizeof(ci), &ci))\n\t\tgoto nla_put_failure;\n\tnla = nla_reserve(skb, IFLA_INET6_CONF, DEVCONF_MAX * sizeof(s32));\n\tif (nla == NULL)\n\t\tgoto nla_put_failure;\n\tipv6_store_devconf(&idev->cnf, nla_data(nla), nla_len(nla));\n\tnla = nla_reserve(skb, IFLA_INET6_STATS, IPSTATS_MIB_MAX * sizeof(u64));\n\tif (nla == NULL)\n\t\tgoto nla_put_failure;\n\tsnmp6_fill_stats(nla_data(nla), idev, IFLA_INET6_STATS, nla_len(nla));\n\tnla = nla_reserve(skb, IFLA_INET6_ICMP6STATS, ICMP6_MIB_MAX * sizeof(u64));\n\tif (nla == NULL)\n\t\tgoto nla_put_failure;\n\tsnmp6_fill_stats(nla_data(nla), idev, IFLA_INET6_ICMP6STATS, nla_len(nla));\n\tnla = nla_reserve(skb, IFLA_INET6_TOKEN, sizeof(struct in6_addr));\n\tif (nla == NULL)\n\t\tgoto nla_put_failure;\n\tread_lock_bh(&idev->lock);\n\tmemcpy(nla_data(nla), idev->token.s6_addr, nla_len(nla));\n\tread_unlock_bh(&idev->lock);\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 0}
{"code": "struct resource_pool *dcn10_create_resource_pool(\n\t\tconst struct dc_init_data *init_data,\n\t\tstruct dc *dc)\n{\n\tstruct dcn10_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dcn10_resource_pool), GFP_KERNEL);\n\tif (!pool)\n\t\treturn NULL;\n\tif (construct(init_data->num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\tkfree(pool);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 0}
{"code": "static struct dentry *aio_mount(struct file_system_type *fs_type,\n\t\t\t\tint flags, const char *dev_name, void *data)\n{\n\tstatic const struct dentry_operations ops = {\n\t\t.d_dname\t= simple_dname,\n\t};\n\treturn mount_pseudo(fs_type, \"aio:\", NULL, &ops, AIO_RING_MAGIC);\n}", "target": 1}
{"code": "bool IsFullyConnectedOpSupported(const TfLiteRegistration* registration,\n                                 const TfLiteNode* node,\n                                 TfLiteContext* context) {\n  if (node->builtin_data == nullptr) return false;\n  const auto* fc_params =\n      reinterpret_cast<const TfLiteFullyConnectedParams*>(node->builtin_data);\n  const int kInput = 0;\n  const int kWeights = 1;\n  const int kBias = 2;\n  if (fc_params->weights_format != kTfLiteFullyConnectedWeightsFormatDefault) {\n    return false;\n  }\n  const TfLiteTensor* input = GetInput(context, node, kInput);\n  const TfLiteTensor* weights = GetInput(context, node, kWeights);\n  if (!IsFloatType(input->type)) {\n    return false;\n  }\n  if (!IsFloatType(weights->type) || !IsConstantTensor(weights)) {\n    return false;\n  }\n  if (input->dims->data[input->dims->size - 1] != NumElements(input)) {\n    return false;\n  }\n  if (node->inputs->size > 2) {\n    const TfLiteTensor* bias = GetInput(context, node, kBias);\n    if (!IsFloatType(bias->type) || !IsConstantTensor(bias)) {\n      return false;\n    }\n  }\n  TfLiteFusedActivation activation = fc_params->activation;\n  if (activation == kTfLiteActSignBit) {\n    return false;\n  }\n  return true;\n}", "target": 1}
{"code": "header_gets (SF_PRIVATE *psf, char *ptr, int bufsize)\n{\tint\t\tk ;\n\tfor (k = 0 ; k < bufsize - 1 ; k++)\n\t{\tif (psf->headindex < psf->headend)\n\t\t{\tptr [k] = psf->header [psf->headindex] ;\n\t\t\tpsf->headindex ++ ;\n\t\t\t}\n\t\telse\n\t\t{\tpsf->headend += psf_fread (psf->header + psf->headend, 1, 1, psf) ;\n\t\t\tptr [k] = psf->header [psf->headindex] ;\n\t\t\tpsf->headindex = psf->headend ;\n\t\t\t} ;\n\t\tif (ptr [k] == '\\n')\n\t\t\tbreak ;\n\t\t} ;\n\tptr [k] = 0 ;\n\treturn k ;\n} ", "target": 1}
{"code": "static u32 seq_scale(u32 seq)\n{\n\treturn seq + (ktime_to_ns(ktime_get_real()) >> 6);\n}", "target": 0}
{"code": "bool StringSanMatcher::match(const GENERAL_NAME* general_name) const {\n  if (general_name->type != general_name_type_) {\n    return false;\n  }\n  const std::string san = Utility::generalNameAsString(general_name);\n  return general_name->type == GEN_DNS &&\n                 matcher_.matcher().match_pattern_case() ==\n                     envoy::type::matcher::v3::StringMatcher::MatchPatternCase::kExact\n             ? Utility::dnsNameMatch(matcher_.matcher().exact(), absl::string_view(san))\n             : matcher_.match(san);\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, SortSkipLimit) {\n    runQuerySortProjSkipNToReturn(BSONObj(), fromjson(\"{a: 1}\"), BSONObj(), 2, -3);\n    assertNumSolutions(1U);\n    assertSolutionExists(\n        \"{skip: {n: 2, node: \"\n        \"{sort: {pattern: {a: 1}, limit: 5, node: {sortKeyGen: \"\n        \"{node: {cscan: {dir: 1}}}}}}}}\");\n}", "target": 0}
{"code": "static void write_version(\n    FILE       *fp,\n    const char *fname,\n    const char *dirname,\n    xref_t     *xref)\n{\n    long  start;\n    char *c, *new_fname, data;\n    FILE *new_fp;\n    start = ftell(fp);\n    if ((c = strstr(fname, \".pdf\")))\n      *c = '\\0';\n    new_fname = malloc(strlen(fname) + strlen(dirname) + 16);\n    snprintf(new_fname, strlen(fname) + strlen(dirname) + 16,\n             \"%s/%s-version-%d.pdf\", dirname, fname, xref->version);\n    if (!(new_fp = fopen(new_fname, \"w\")))\n    {\n        ERR(\"Could not create file '%s'\\n\", new_fname);\n        fseek(fp, start, SEEK_SET);\n        free(new_fname);\n        return;\n    }\n    fseek(fp, 0, SEEK_SET);\n    while (fread(&data, 1, 1, fp))\n      fwrite(&data, 1, 1, new_fp);\n    fprintf(new_fp, \"\\r\\nstartxref\\r\\n%ld\\r\\n%%%%EOF\", xref->start);\n    fclose(new_fp);\n    free(new_fname);\n    fseek(fp, start, SEEK_SET);\n}", "target": 1}
{"code": "static int base64decode_block(unsigned char *target, const char *data, size_t data_size)\n{\n\tint w1,w2,w3,w4;\n\tint i;\n\tsize_t n;\n\tif (!data || (data_size <= 0)) {\n\t\treturn 0;\n\t}\n\tn = 0;\n\ti = 0;\n\twhile (n < data_size-3) {\n\t\tw1 = base64_table[(int)data[n]];\n\t\tw2 = base64_table[(int)data[n+1]];\n\t\tw3 = base64_table[(int)data[n+2]];\n\t\tw4 = base64_table[(int)data[n+3]];\n\t\tif (w2 >= 0) {\n\t\t\ttarget[i++] = (char)((w1*4 + (w2 >> 4)) & 255);\n\t\t}\n\t\tif (w3 >= 0) {\n\t\t\ttarget[i++] = (char)((w2*16 + (w3 >> 2)) & 255);\n\t\t}\n\t\tif (w4 >= 0) {\n\t\t\ttarget[i++] = (char)((w3*64 + w4) & 255);\n\t\t}\n\t\tn+=4;\n\t}\n\treturn i;\n}", "target": 1}
{"code": "void FrameLoader::finishedLoadingDocument(DocumentLoader* loader)\n{\n#if PLATFORM(WIN) || PLATFORM(CHROMIUM)\n    if (m_creatingInitialEmptyDocument)\n        return;\n#endif\n    const String& responseMIMEType = loader->responseMIMEType();\n#if PLATFORM(MAC)\n    m_client->finishedLoading(loader);\n    if (!ArchiveFactory::isArchiveMimeType(responseMIMEType))\n        return;\n#else\n    if (!ArchiveFactory::isArchiveMimeType(responseMIMEType)) {\n        m_client->finishedLoading(loader);\n        return;\n    }\n#endif\n    RefPtr<Archive> archive(ArchiveFactory::create(loader->mainResourceData().get(), responseMIMEType));\n    if (!archive)\n        return;\n    loader->addAllArchiveResources(archive.get());\n    ArchiveResource* mainResource = archive->mainResource();\n    loader->setParsedArchiveData(mainResource->data());\n    m_responseMIMEType = mainResource->mimeType();\n    closeURL();\n    didOpenURL(mainResource->url());\n    String userChosenEncoding = documentLoader()->overrideEncoding();\n    bool encodingIsUserChosen = !userChosenEncoding.isNull();\n    setEncoding(encodingIsUserChosen ? userChosenEncoding : mainResource->textEncoding(), encodingIsUserChosen);\n    ASSERT(m_frame->document());\n    addData(mainResource->data()->data(), mainResource->data()->size());\n}", "target": 0}
{"code": "rfbHandleAuthResult(rfbClient* client)\n{\n    uint32_t authResult=0, reasonLen=0;\n    char *reason=NULL;\n    if (!ReadFromRFBServer(client, (char *)&authResult, 4)) return FALSE;\n    authResult = rfbClientSwap32IfLE(authResult);\n    switch (authResult) {\n    case rfbVncAuthOK:\n      rfbClientLog(\"VNC authentication succeeded\\n\");\n      return TRUE;\n      break;\n    case rfbVncAuthFailed:\n      if (client->major==3 && client->minor>7)\n      {\n        if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return FALSE;\n        reasonLen = rfbClientSwap32IfLE(reasonLen);\n        reason = malloc((uint64_t)reasonLen+1);\n        if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return FALSE; }\n        reason[reasonLen]=0;\n        rfbClientLog(\"VNC connection failed: %s\\n\",reason);\n        free(reason);\n        return FALSE;\n      }\n      rfbClientLog(\"VNC authentication failed\\n\");\n      return FALSE;\n    case rfbVncAuthTooMany:\n      rfbClientLog(\"VNC authentication failed - too many tries\\n\");\n      return FALSE;\n    }\n    rfbClientLog(\"Unknown VNC authentication result: %d\\n\",\n                 (int)authResult);\n    return FALSE;\n}", "target": 1}
{"code": "static void vvc_parse_general_timing_hrd_parameters(GF_BitStream *bs, VVC_SPS *sps, VVC_VPS *vps, Bool *general_nal_hrd_params_present_flag, Bool *general_vcl_hrd_params_present_flag, Bool *general_du_hrd_params_present_flag, u32 *hrd_cpb_cnt_minus1)\n{\n\tsps->has_timing_info = 1;\n\tsps->num_units_in_tick = gf_bs_read_int_log(bs, 32, \"num_units_in_tick\");\n\tsps->time_scale = gf_bs_read_int_log(bs, 32, \"timescale\");\n\t*general_du_hrd_params_present_flag = GF_FALSE;\n\t*general_nal_hrd_params_present_flag = gf_bs_read_int_log(bs, 1, \"general_nal_hrd_params_present_flag\");\n\t*general_vcl_hrd_params_present_flag = gf_bs_read_int_log(bs, 1, \"general_vcl_hrd_params_present_flag\");\n\tif (*general_nal_hrd_params_present_flag || *general_vcl_hrd_params_present_flag) {\n\t\tgf_bs_read_int_log(bs, 1, \"general_same_pic_timing_in_all_ols_flag\");\n\t\t*general_du_hrd_params_present_flag = gf_bs_read_int_log(bs, 1, \"general_du_hrd_params_present_flag\");\n\t\tif (*general_du_hrd_params_present_flag)\n\t\t\tgf_bs_read_int_log(bs, 8, \"tick_divisor_minus2\");\n\t\tgf_bs_read_int_log(bs, 4, \"bit_rate_scale\");\n\t\tgf_bs_read_int_log(bs, 4, \"cpb_size_scale\");\n\t\tif (*general_du_hrd_params_present_flag)\n\t\t\tgf_bs_read_int_log(bs, 4, \"cpb_size_du_scale\");\n\t\t*hrd_cpb_cnt_minus1 = gf_bs_read_ue_log(bs, \"hrd_cpb_cnt_minus1\");\n\t}\n}", "target": 0}
{"code": "static int ext4_write_begin(struct file *file, struct address_space *mapping,\n\t\t\t    loff_t pos, unsigned len, unsigned flags,\n\t\t\t    struct page **pagep, void **fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tint ret, needed_blocks;\n\thandle_t *handle;\n\tint retries = 0;\n\tstruct page *page;\n\tpgoff_t index;\n\tunsigned from, to;\n\ttrace_ext4_write_begin(inode, pos, len, flags);\n\tneeded_blocks = ext4_writepage_trans_blocks(inode) + 1;\n\tindex = pos >> PAGE_CACHE_SHIFT;\n\tfrom = pos & (PAGE_CACHE_SIZE - 1);\n\tto = from + len;\nretry:\n\thandle = ext4_journal_start(inode, needed_blocks);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto out;\n\t}\n\tflags |= AOP_FLAG_NOFS;\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page) {\n\t\text4_journal_stop(handle);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\t*pagep = page;\n\tret = block_write_begin(file, mapping, pos, len, flags, pagep, fsdata,\n\t\t\t\text4_get_block);\n\tif (!ret && ext4_should_journal_data(inode)) {\n\t\tret = walk_page_buffers(handle, page_buffers(page),\n\t\t\t\tfrom, to, NULL, do_journal_get_write_access);\n\t}\n\tif (ret) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tif (pos + len > inode->i_size && ext4_can_truncate(inode))\n\t\t\text4_orphan_add(handle, inode);\n\t\text4_journal_stop(handle);\n\t\tif (pos + len > inode->i_size) {\n\t\t\text4_truncate_failed_write(inode);\n\t\t\tif (inode->i_nlink)\n\t\t\t\text4_orphan_del(NULL, inode);\n\t\t}\n\t}\n\tif (ret == -ENOSPC && ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\tgoto retry;\nout:\n\treturn ret;\n}", "target": 1}
{"code": "static int pppol2tp_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t       char __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2tp_session *session;\n\tstruct l2tp_tunnel *tunnel;\n\tstruct pppol2tp_session *ps;\n\tint val;\n\tint err;\n\tif (level != SOL_PPPOL2TP)\n\t\treturn udp_prot.setsockopt(sk, level, optname, optval, optlen);\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\terr = -ENOTCONN;\n\tif (sk->sk_user_data == NULL)\n\t\tgoto end;\n\terr = -EBADF;\n\tsession = pppol2tp_sock_to_session(sk);\n\tif (session == NULL)\n\t\tgoto end;\n\tps = l2tp_session_priv(session);\n\tif ((session->session_id == 0) &&\n\t    (session->peer_session_id == 0)) {\n\t\terr = -EBADF;\n\t\ttunnel = l2tp_sock_to_tunnel(ps->tunnel_sock);\n\t\tif (tunnel == NULL)\n\t\t\tgoto end_put_sess;\n\t\terr = pppol2tp_tunnel_setsockopt(sk, tunnel, optname, val);\n\t\tsock_put(ps->tunnel_sock);\n\t} else\n\t\terr = pppol2tp_session_setsockopt(sk, session, optname, val);\n\terr = 0;\nend_put_sess:\n\tsock_put(sk);\nend:\n\treturn err;\n}", "target": 1}
{"code": "static int adpt_show_info(struct seq_file *m, struct Scsi_Host *host)\n{\n\tstruct adpt_device* d;\n\tint id;\n\tint chan;\n\tadpt_hba* pHba;\n\tint unit;\n\tmutex_lock(&adpt_configuration_lock);\n\tfor (pHba = hba_chain; pHba; pHba = pHba->next) {\n\t\tif (pHba->host == host) {\n\t\t\tbreak;\t\n\t\t}\n\t}\n\tmutex_unlock(&adpt_configuration_lock);\n\tif (pHba == NULL) {\n\t\treturn 0;\n\t}\n\thost = pHba->host;\n\tseq_printf(m, \"Adaptec I2O RAID Driver Version: %s\\n\\n\", DPT_I2O_VERSION);\n\tseq_printf(m, \"%s\\n\", pHba->detail);\n\tseq_printf(m, \"SCSI Host=scsi%d  Control Node=/dev/%s  irq=%d\\n\", \n\t\t\tpHba->host->host_no, pHba->name, host->irq);\n\tseq_printf(m, \"\\tpost fifo size  = %d\\n\\treply fifo size = %d\\n\\tsg table size   = %d\\n\\n\",\n\t\t\thost->can_queue, (int) pHba->reply_fifo_size , host->sg_tablesize);\n\tseq_puts(m, \"Devices:\\n\");\n\tfor(chan = 0; chan < MAX_CHANNEL; chan++) {\n\t\tfor(id = 0; id < MAX_ID; id++) {\n\t\t\td = pHba->channel[chan].device[id];\n\t\t\twhile(d) {\n\t\t\t\tseq_printf(m,\"\\t%-24.24s\", d->pScsi_dev->vendor);\n\t\t\t\tseq_printf(m,\" Rev: %-8.8s\\n\", d->pScsi_dev->rev);\n\t\t\t\tunit = d->pI2o_dev->lct_data.tid;\n\t\t\t\tseq_printf(m, \"\\tTID=%d, (Channel=%d, Target=%d, Lun=%llu)  (%s)\\n\\n\",\n\t\t\t\t\t       unit, (int)d->scsi_channel, (int)d->scsi_id, d->scsi_lun,\n\t\t\t\t\t       scsi_device_online(d->pScsi_dev)? \"online\":\"offline\"); \n\t\t\t\td = d->next_lun;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int tls_construct_cke_dhe(SSL *s, unsigned char **p, int *len, int *al)\n{\n#ifndef OPENSSL_NO_DH\n    DH *dh_clnt = NULL;\n    const BIGNUM *pub_key;\n    EVP_PKEY *ckey = NULL, *skey = NULL;\n    skey = s->s3->peer_tmp;\n    if (skey == NULL) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n    ckey = ssl_generate_pkey(skey);\n    if (ckey == NULL) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n    dh_clnt = EVP_PKEY_get0_DH(ckey);\n    if (dh_clnt == NULL || ssl_derive(s, ckey, skey) == 0) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);\n        EVP_PKEY_free(ckey);\n        return 0;\n    }\n    DH_get0_key(dh_clnt, &pub_key, NULL);\n    *len = BN_num_bytes(pub_key);\n    s2n(*len, *p);\n    BN_bn2bin(pub_key, *p);\n    *len += 2;\n    EVP_PKEY_free(ckey);\n    return 1;\n#else\n    SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);\n    *al = SSL_AD_INTERNAL_ERROR;\n    return 0;\n#endif\n}", "target": 0}
{"code": "netsnmp_mibindex_load( void )\n{\n    DIR *dir;\n    struct dirent *file;\n    FILE *fp;\n    char tmpbuf[ 300];\n    char tmpbuf2[300];\n    int  i;\n    char *cp;\n    snprintf( tmpbuf, sizeof(tmpbuf), \"%s/mib_indexes\",\n              get_persistent_directory());\n    tmpbuf[sizeof(tmpbuf)-1] = 0;\n    dir = opendir( tmpbuf );\n    if ( dir == NULL ) {\n        DEBUGMSGTL((\"mibindex\", \"load: (new)\\n\"));\n        mkdirhier( tmpbuf, NETSNMP_AGENT_DIRECTORY_MODE, 0);\n        return;\n    }\n    while ((file = readdir( dir ))) {\n        if ( !isdigit((unsigned char)(file->d_name[0])))\n            continue;\n        i = atoi( file->d_name );\n        snprintf( tmpbuf, sizeof(tmpbuf), \"%s/mib_indexes/%d\",\n              get_persistent_directory(), i );\n        tmpbuf[sizeof(tmpbuf)-1] = 0;\n        fp = fopen( tmpbuf, \"r\" );\n        if (!fp)\n            continue;\n        cp = fgets( tmpbuf2, sizeof(tmpbuf2), fp );\n        fclose( fp );\n        if ( !cp ) {\n            DEBUGMSGTL((\"mibindex\", \"Empty MIB index (%d)\\n\", i));\n            continue;\n        }\n        if ( strncmp( tmpbuf2, \"DIR \", 4 ) != 0 ) {\n            DEBUGMSGTL((\"mibindex\", \"Malformed MIB index (%d)\\n\", i));\n            continue;\n        }\n        tmpbuf2[strlen(tmpbuf2)-1] = 0;\n        DEBUGMSGTL((\"mibindex\", \"load: (%d) %s\\n\", i, tmpbuf2));\n        (void)_mibindex_add( tmpbuf2+4, i );  \n    }\n    closedir( dir );\n}", "target": 1}
{"code": "lyd_new_leaf(struct lyd_node *parent, const struct lys_module *module, const char *name, const char *val_str)\n{\n    const struct lys_node *snode = NULL, *siblings;\n    if ((!parent && !module) || !name) {\n        LOGARG;\n        return NULL;\n    }\n    siblings = lyd_new_find_schema(parent, module, 0);\n    if (!siblings) {\n        LOGARG;\n        return NULL;\n    }\n    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_LEAFLIST | LYS_LEAF, &snode) || !snode) {\n        LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",\n               name, lys_node_module(siblings)->name, siblings->name);\n        return NULL;\n    }\n    return _lyd_new_leaf(parent, snode, val_str, 0, 0);\n}", "target": 1}
{"code": "  void DefaultEnv::Initialize()\n  {\n    sLog           = new Log();\n    SetUpLog();\n    sEnv           = new DefaultEnv();\n    sForkHandler   = new ForkHandler();\n    sFileTimer     = new FileTimer();\n    sPlugInManager = new PlugInManager();\n    sPlugInManager->ProcessEnvironmentSettings();\n    sForkHandler->RegisterFileTimer( sFileTimer );\n#ifdef __APPLE__\n    char *errBuff = new char[1024];\n    const char *libs[] =\n    {\n      \"libXrdSeckrb5.so\",\n      \"libXrdSecgsi.so\",\n      \"libXrdSecgsiAuthzVO.so\",\n      \"libXrdSecgsiGMAPDN.so\",\n      \"libXrdSecgsiGMAPLDAP.so\",\n      \"libXrdSecpwd.so\",\n      \"libXrdSecsss.so\",\n      \"libXrdSecunix.so\",\n      0\n    };\n    for( int i = 0; libs[i]; ++i )\n    {\n      sLog->Debug( UtilityMsg, \"Attempting to pre-load: %s\", libs[i] );\n      bool ok = XrdOucPreload( libs[i], errBuff, 1024 );\n      if( !ok )\n        sLog->Error( UtilityMsg, \"Unable to pre-load %s: %s\", libs[i], errBuff );\n    }\n    delete [] errBuff;\n#endif\n  }", "target": 1}
{"code": "void RootWindow::RemoveRootWindowObserver(RootWindowObserver* observer) {\n  observers_.RemoveObserver(observer);\n}", "target": 0}
{"code": "static int32_t check_load_area(uintptr_t dst, uintptr_t len)\n{\n\tuint32_t legacy = dst + len <= UINT32_MAX - 1 ? 1 : 0;\n\tuintptr_t dram_start, dram_end;\n\tuintptr_t prot_start, prot_end;\n\tint32_t result = IO_SUCCESS;\n\tdram_start = legacy ? DRAM1_NS_BASE : DRAM_40BIT_BASE;\n\tdram_end = legacy ? DRAM1_NS_BASE + DRAM1_NS_SIZE :\n\t    DRAM_40BIT_BASE + DRAM_40BIT_SIZE;\n\tprot_start = legacy ? DRAM_PROTECTED_BASE : DRAM_40BIT_PROTECTED_BASE;\n\tprot_end = prot_start + DRAM_PROTECTED_SIZE;\n\tif (dst < dram_start || dst > dram_end - len || dram_end < len) {\n\t\tERROR(\"BL2: dst address is on the protected area.\\n\");\n\t\tresult = IO_FAIL;\n\t\tgoto done;\n\t}\n\tif (dst >= prot_start && dst < prot_end) {\n\t\tERROR(\"BL2: dst address is on the protected area.\\n\");\n\t\tresult = IO_FAIL;\n\t\tgoto done;\n\t}\n\tif ((dst < prot_start && dst > prot_start - len) || prot_start < len) {\n\t\tERROR(\"BL2: loaded data is on the protected area.\\n\");\n\t\tresult = IO_FAIL;\n\t\tgoto done;\n\t}\n\tif (addr_loaded_cnt >= CHECK_IMAGE_AREA_CNT) {\n\t\tERROR(\"BL2: max loadable non secure images reached\\n\");\n\t\tresult = IO_FAIL;\n\t\tgoto done;\n\t}\n\taddr_loaded[addr_loaded_cnt].dest = dst;\n\taddr_loaded[addr_loaded_cnt].length = len;\n\tfor(int n=0; n<addr_loaded_cnt; n++) {\n\t\tif (((dst >= addr_loaded[n].dest) &&\n\t\t     (dst <=  addr_loaded[n].dest + addr_loaded[n].length)) ||\n\t\t    ((dst + len >= addr_loaded[n].dest) &&\n\t\t     (dst + len <= addr_loaded[n].dest + addr_loaded[n].length)) ||\n\t\t    ((dst <= addr_loaded[n].dest) &&\n\t\t     (dst + len >= addr_loaded[n].dest + addr_loaded[n].length))) {\n\t\t\tERROR(\"BL2: next image overlap a previous image area.\\n\");\n\t\t\tresult = IO_FAIL;\n\t\t\tgoto done;\n\t\t}\n\t}\n\taddr_loaded_cnt++;\ndone:\n\tif (result == IO_FAIL) {\n\t\tERROR(\"BL2: Out of range : dst=0x%lx len=0x%lx\\n\", dst, len);\n\t}\n\treturn result;\n}", "target": 0}
{"code": "static ssize_t module_gzip_decompress(struct load_info *info,\n\t\t\t\t      const void *buf, size_t size)\n{\n\tstruct z_stream_s s = { 0 };\n\tsize_t new_size = 0;\n\tsize_t gzip_hdr_len;\n\tssize_t retval;\n\tint rc;\n\tgzip_hdr_len = module_gzip_header_len(buf, size);\n\tif (!gzip_hdr_len) {\n\t\tpr_err(\"not a gzip compressed module\\n\");\n\t\treturn -EINVAL;\n\t}\n\ts.next_in = buf + gzip_hdr_len;\n\ts.avail_in = size - gzip_hdr_len;\n\ts.workspace = kmalloc(zlib_inflate_workspacesize(), GFP_KERNEL);\n\tif (!s.workspace)\n\t\treturn -ENOMEM;\n\trc = zlib_inflateInit2(&s, -MAX_WBITS);\n\tif (rc != Z_OK) {\n\t\tpr_err(\"failed to initialize decompressor: %d\\n\", rc);\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\tdo {\n\t\tstruct page *page = module_get_next_page(info);\n\t\tif (!page) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out_inflate_end;\n\t\t}\n\t\ts.next_out = kmap_local_page(page);\n\t\ts.avail_out = PAGE_SIZE;\n\t\trc = zlib_inflate(&s, 0);\n\t\tkunmap_local(s.next_out);\n\t\tnew_size += PAGE_SIZE - s.avail_out;\n\t} while (rc == Z_OK);\n\tif (rc != Z_STREAM_END) {\n\t\tpr_err(\"decompression failed with status %d\\n\", rc);\n\t\tretval = -EINVAL;\n\t\tgoto out_inflate_end;\n\t}\n\tretval = new_size;\nout_inflate_end:\n\tzlib_inflateEnd(&s);\nout:\n\tkfree(s.workspace);\n\treturn retval;\n}", "target": 1}
{"code": "void dns_server_deinit(void)\n{\n\tif (dns_server_pcb != NULL) {\n\t\tudp_remove(dns_server_pcb);\n\t\tdns_server_pcb = NULL;\n\t}\n}", "target": 0}
{"code": "struct dns_https_param *dns_get_HTTPS_svcparm_start(struct dns_rrs *rrs, char *domain, int maxsize, int *ttl,\n\t\t\t\t\t\t\t\t\t\t\t\t\tint *priority, char *target, int target_size)\n{\n\tint qtype = 0;\n\tunsigned char *data = NULL;\n\tint rr_len = 0;\n\tdata = dns_get_rr_nested_start(rrs, domain, maxsize, &qtype, ttl, &rr_len);\n\tif (data == NULL) {\n\t\treturn NULL;\n\t}\n\tif (qtype != DNS_T_HTTPS) {\n\t\treturn NULL;\n\t}\n\tif (rr_len < 2) {\n\t\treturn NULL;\n\t}\n\t*priority = _dns_read_short(&data);\n\trr_len -= 2;\n\tif (rr_len <= 0) {\n\t\treturn NULL;\n\t}\n\tint len = strnlen((char *)data, rr_len);\n\tsafe_strncpy(target, (char *)data, target_size);\n\tdata += len + 1;\n\trr_len -= len + 1;\n\tif (rr_len <= 0) {\n\t\treturn NULL;\n\t}\n\treturn (struct dns_https_param *)data;\n}", "target": 1}
{"code": "int imap_subscribe(char *path, bool subscribe)\n{\n  struct ImapData *idata = NULL;\n  char buf[LONG_STRING];\n  char mbox[LONG_STRING];\n  char errstr[STRING];\n  struct Buffer err, token;\n  struct ImapMbox mx;\n  if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)\n  {\n    mutt_error(_(\"Bad mailbox name\"));\n    return -1;\n  }\n  idata = imap_conn_find(&(mx.account), 0);\n  if (!idata)\n    goto fail;\n  imap_fix_path(idata, mx.mbox, buf, sizeof(buf));\n  if (!*buf)\n    mutt_str_strfcpy(buf, \"INBOX\", sizeof(buf));\n  if (ImapCheckSubscribed)\n  {\n    mutt_buffer_init(&token);\n    mutt_buffer_init(&err);\n    err.data = errstr;\n    err.dsize = sizeof(errstr);\n    snprintf(mbox, sizeof(mbox), \"%smailboxes \\\"%s\\\"\", subscribe ? \"\" : \"un\", path);\n    if (mutt_parse_rc_line(mbox, &token, &err))\n      mutt_debug(1, \"Error adding subscribed mailbox: %s\\n\", errstr);\n    FREE(&token.data);\n  }\n  if (subscribe)\n    mutt_message(_(\"Subscribing to %s...\"), buf);\n  else\n    mutt_message(_(\"Unsubscribing from %s...\"), buf);\n  imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf);\n  snprintf(buf, sizeof(buf), \"%sSUBSCRIBE %s\", subscribe ? \"\" : \"UN\", mbox);\n  if (imap_exec(idata, buf, 0) < 0)\n    goto fail;\n  imap_unmunge_mbox_name(idata, mx.mbox);\n  if (subscribe)\n    mutt_message(_(\"Subscribed to %s\"), mx.mbox);\n  else\n    mutt_message(_(\"Unsubscribed from %s\"), mx.mbox);\n  FREE(&mx.mbox);\n  return 0;\nfail:\n  FREE(&mx.mbox);\n  return -1;\n}", "target": 1}
{"code": "static u32 rgb_48_to_32(char *val)\n{\n\tu32 res = 0x0;\n\tu32 i;\n\tfor (i=0; i<3; i++) {\n\t\tu32 v = val[2*i];\n\t\tv<<=8;\n\t\tv|=val[2*i + 1];\n\t\tv/=0xFF;\n\t\tres <<= 8;\n\t\tres |= v;\n\t}\n\treturn res;\n}", "target": 0}
{"code": "static int crypto_givcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_blkcipher rblkcipher;\n\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"givcipher\");\n\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \"%s\",\n\t\t alg->cra_ablkcipher.geniv ?: \"<built-in>\");\n\trblkcipher.blocksize = alg->cra_blocksize;\n\trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;\n\trblkcipher.max_keysize = alg->cra_ablkcipher.max_keysize;\n\trblkcipher.ivsize = alg->cra_ablkcipher.ivsize;\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,\n\t\t    sizeof(struct crypto_report_blkcipher), &rblkcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "static void iwjpeg_scan_exif_ifd(struct iwjpegrcontext *rctx,\n\tstruct iw_exif_state *e, iw_uint32 ifd)\n{\n\tunsigned int tag_count;\n\tunsigned int i;\n\tunsigned int tag_pos;\n\tunsigned int tag_id;\n\tunsigned int v;\n\tdouble v_dbl;\n\tif(ifd<8 || ifd>e->d_len-18) return;\n\ttag_count = iw_get_ui16_e(&e->d[ifd],e->endian);\n\tif(tag_count>1000) return; \n\tfor(i=0;i<tag_count;i++) {\n\t\ttag_pos = ifd+2+i*12;\n\t\tif(tag_pos+12 > e->d_len) return; \n\t\ttag_id = iw_get_ui16_e(&e->d[tag_pos],e->endian);\n\t\tswitch(tag_id) {\n\t\tcase 274: \n\t\t\tif(get_exif_tag_int_value(e,tag_pos,&v)) {\n\t\t\t\trctx->exif_orientation = v;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 296: \n\t\t\tif(get_exif_tag_int_value(e,tag_pos,&v)) {\n\t\t\t\trctx->exif_density_unit = v;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 282: \n\t\t\tif(get_exif_tag_dbl_value(e,tag_pos,&v_dbl)) {\n\t\t\t\trctx->exif_density_x = v_dbl;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 283: \n\t\t\tif(get_exif_tag_dbl_value(e,tag_pos,&v_dbl)) {\n\t\t\t\trctx->exif_density_y = v_dbl;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}", "target": 1}
{"code": "header_put_le_int (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 4)\n\t{\tpsf->header [psf->headindex++] = x ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 24) ;\n\t\t} ;\n} ", "target": 1}
{"code": "void snd_msndmidi_input_read(void *mpuv)\n{\n\tunsigned long flags;\n\tstruct snd_msndmidi *mpu = mpuv;\n\tvoid *pwMIDQData = mpu->dev->mappedbase + MIDQ_DATA_BUFF;\n\tspin_lock_irqsave(&mpu->input_lock, flags);\n\twhile (readw(mpu->dev->MIDQ + JQS_wTail) !=\n\t       readw(mpu->dev->MIDQ + JQS_wHead)) {\n\t\tu16 wTmp, val;\n\t\tval = readw(pwMIDQData + 2 * readw(mpu->dev->MIDQ + JQS_wHead));\n\t\t\tif (test_bit(MSNDMIDI_MODE_BIT_INPUT_TRIGGER,\n\t\t\t\t     &mpu->mode))\n\t\t\t\tsnd_rawmidi_receive(mpu->substream_input,\n\t\t\t\t\t\t    (unsigned char *)&val, 1);\n\t\twTmp = readw(mpu->dev->MIDQ + JQS_wHead) + 1;\n\t\tif (wTmp > readw(mpu->dev->MIDQ + JQS_wSize))\n\t\t\twritew(0,  mpu->dev->MIDQ + JQS_wHead);\n\t\telse\n\t\t\twritew(wTmp,  mpu->dev->MIDQ + JQS_wHead);\n\t}\n\tspin_unlock_irqrestore(&mpu->input_lock, flags);\n}", "target": 1}
{"code": "static inline int rb_null_event(struct ring_buffer_event *event)\n{\n\treturn event->type_len == RINGBUF_TYPE_PADDING && !event->time_delta;\n}", "target": 0}
{"code": "static void outbound_phy_packet_callback(struct fw_packet *packet,\n\t\t\t\t\t struct fw_card *card, int status)\n{\n\tstruct outbound_phy_packet_event *e =\n\t\tcontainer_of(packet, struct outbound_phy_packet_event, p);\n\tswitch (status) {\n\tcase ACK_COMPLETE:\te->phy_packet.rcode = RCODE_COMPLETE;\tbreak;\n\tcase ACK_PENDING:\te->phy_packet.rcode = RCODE_COMPLETE;\tbreak;\n\tcase ACK_BUSY_X:\n\tcase ACK_BUSY_A:\n\tcase ACK_BUSY_B:\te->phy_packet.rcode = RCODE_BUSY;\tbreak;\n\tcase ACK_DATA_ERROR:\te->phy_packet.rcode = RCODE_DATA_ERROR;\tbreak;\n\tcase ACK_TYPE_ERROR:\te->phy_packet.rcode = RCODE_TYPE_ERROR;\tbreak;\n\tdefault:\t\te->phy_packet.rcode = status;\t\tbreak;\n\t}\n\te->phy_packet.data[0] = packet->timestamp;\n\tqueue_event(e->client, &e->event, &e->phy_packet,\n\t\t    sizeof(e->phy_packet) + e->phy_packet.length, NULL, 0);\n\tclient_put(e->client);\n}", "target": 1}
{"code": "h2_end_headers(struct worker *wrk, struct h2_sess *h2,\n    struct req *req, struct h2_req *r2)\n{\n\th2_error h2e;\n\tconst char *b;\n\tASSERT_RXTHR(h2);\n\tassert(r2->state == H2_S_OPEN);\n\th2e = h2h_decode_fini(h2);\n\th2->new_req = NULL;\n\tif (r2->req->req_body_status == REQ_BODY_NONE) {\n\t\tr2->state = H2_S_CLOS_REM;\n\t}\n\tif (h2e != NULL) {\n\t\tLck_Lock(&h2->sess->mtx);\n\t\tVSLb(h2->vsl, SLT_Debug, \"HPACK/FINI %s\", h2e->name);\n\t\tLck_Unlock(&h2->sess->mtx);\n\t\tAZ(r2->req->ws->r);\n\t\th2_del_req(wrk, r2);\n\t\treturn (h2e);\n\t}\n\tVSLb_ts_req(req, \"Req\", req->t_req);\n\thttp_CollectHdrSep(req->http, H_Cookie, \"; \");\t\n\tif (req->req_body_status == REQ_BODY_INIT) {\n\t\tif (!http_GetHdr(req->http, H_Content_Length, &b))\n\t\t\treq->req_body_status = REQ_BODY_WITHOUT_LEN;\n\t\telse\n\t\t\treq->req_body_status = REQ_BODY_WITH_LEN;\n\t} else {\n\t\tassert (req->req_body_status == REQ_BODY_NONE);\n\t\tif (http_GetContentLength(req->http) > 0)\n\t\t\treturn (H2CE_PROTOCOL_ERROR); \n\t}\n\tif (req->http->hd[HTTP_HDR_METHOD].b == NULL) {\n\t\tVSLb(h2->vsl, SLT_Debug, \"Missing :method\");\n\t\treturn (H2SE_PROTOCOL_ERROR); \n\t}\n\tif (req->http->hd[HTTP_HDR_URL].b == NULL) {\n\t\tVSLb(h2->vsl, SLT_Debug, \"Missing :path\");\n\t\treturn (H2SE_PROTOCOL_ERROR); \n\t}\n\tAN(req->http->hd[HTTP_HDR_PROTO].b);\n\treq->req_step = R_STP_TRANSPORT;\n\treq->task.func = h2_do_req;\n\treq->task.priv = req;\n\tr2->scheduled = 1;\n\tif (Pool_Task(wrk->pool, &req->task, TASK_QUEUE_STR) != 0) {\n\t\tr2->scheduled = 0;\n\t\tr2->state = H2_S_CLOSED;\n\t\treturn (H2SE_REFUSED_STREAM); \n\t}\n\treturn (0);\n}", "target": 1}
{"code": "get_princs_2_svc(gprincs_arg *arg, struct svc_req *rqstp)\n{\n    static gprincs_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_gprincs_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->exp;\n    if (prime_arg == NULL)\n        prime_arg = \"*\";\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_LIST,\n                                                       NULL,\n                                                       NULL)) {\n        ret.code = KADM5_AUTH_LIST;\n        log_unauth(\"kadm5_get_principals\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code  = kadm5_get_principals((void *)handle,\n                                         arg->exp, &ret.princs,\n                                         &ret.count);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_get_principals\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "void test_stat(const char *path)\n{\n\tstruct stat sb;\n\tif (stat(path, &sb) >= 0) {\n\t\tfprintf(stderr, \"leak at stat of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT) {\n\t\tfprintf(stderr, \"leak at stat of %s: errno was %d\\n\", path, errno);\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "static u64 gen_hi_max(struct tnum var)\n{\n\treturn (var.value | var.mask) & ~0xffffffffULL;\n}", "target": 0}
{"code": "apr_byte_t oidc_post_preserve_javascript(request_rec *r, const char *location,\n\t\tchar **javascript, char **javascript_method) {\n\tif (oidc_cfg_dir_preserve_post(r) == 0)\n\t\treturn FALSE;\n\toidc_debug(r, \"enter\");\n\toidc_cfg *cfg = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\tconst char *method = oidc_original_request_method(r, cfg, FALSE);\n\tif (apr_strnatcmp(method, OIDC_METHOD_FORM_POST) != 0)\n\t\treturn FALSE;\n\tapr_table_t *params = apr_table_make(r->pool, 8);\n\tif (oidc_util_read_post_params(r, params, FALSE, NULL) == FALSE) {\n\t\toidc_error(r, \"something went wrong when reading the POST parameters\");\n\t\treturn FALSE;\n\t}\n\tconst apr_array_header_t *arr = apr_table_elts(params);\n\tconst apr_table_entry_t *elts = (const apr_table_entry_t*) arr->elts;\n\tint i;\n\tchar *json = \"\";\n\tfor (i = 0; i < arr->nelts; i++) {\n\t\tjson = apr_psprintf(r->pool, \"%s'%s': '%s'%s\", json,\n\t\t\t\toidc_util_escape_string(r, elts[i].key),\n\t\t\t\toidc_util_escape_string(r, elts[i].val),\n\t\t\t\ti < arr->nelts - 1 ? \",\" : \"\");\n\t}\n\tjson = apr_psprintf(r->pool, \"{ %s }\", json);\n\tconst char *jmethod = \"preserveOnLoad\";\n\tconst char *jscript =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\t\t\"      function %s() {\\n\"\n\t\t\t\t\t\"        sessionStorage.setItem('mod_auth_openidc_preserve_post_params', JSON.stringify(%s));\\n\"\n\t\t\t\t\t\"        %s\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"    </script>\\n\", jmethod, json,\n\t\t\t\t\tlocation ?\n\t\t\t\t\t\t\tapr_psprintf(r->pool, \"window.location='%s';\\n\",\n\t\t\t\t\t\t\t\t\tlocation) :\n\t\t\t\t\t\t\t\t\t\"\");\n\tif (location == NULL) {\n\t\tif (javascript_method)\n\t\t\t*javascript_method = apr_pstrdup(r->pool, jmethod);\n\t\tif (javascript)\n\t\t\t*javascript = apr_pstrdup(r->pool, jscript);\n\t} else {\n\t\toidc_util_html_send(r, \"Preserving...\", jscript, jmethod,\n\t\t\t\t\"<p>Preserving...</p>\", OK);\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "void WasmBinaryWriter::writeDebugLocation(Expression* curr, Function* func) {\n  if (sourceMap) {\n    auto& debugLocations = func->debugLocations;\n    auto iter = debugLocations.find(curr);\n    if (iter != debugLocations.end()) {\n      writeDebugLocation(iter->second);\n    }\n  }\n  if (func && !func->expressionLocations.empty()) {\n    binaryLocations.expressions[curr] =\n      BinaryLocations::Span{BinaryLocation(o.size()), 0};\n    binaryLocationTrackedExpressionsForFunc.push_back(curr);\n  }\n}", "target": 0}
{"code": "bool SrvAnsiImpl::ReportString(LPCWSTR asRet)\n{\n\tif (!asRet || !*asRet)\n\t\treturn FALSE;\n\tINPUT_RECORD ir[16] = {};\n\tint nLen = lstrlen(asRet);\n\tINPUT_RECORD* pir = (nLen <= (int)countof(ir)) ? ir : (INPUT_RECORD*)calloc(nLen,sizeof(INPUT_RECORD));\n\tif (!pir)\n\t\treturn FALSE;\n\tINPUT_RECORD* p = pir;\n\tLPCWSTR pc = asRet;\n\tfor (int i = 0; i < nLen; i++, p++, pc++)\n\t{\n\t\tconst char ch = *pc >= 0x20 ? *pc : L' ';\n\t\tp->EventType = KEY_EVENT;\n\t\tp->Event.KeyEvent.bKeyDown = TRUE;\n\t\tp->Event.KeyEvent.wRepeatCount = 1;\n\t\tp->Event.KeyEvent.uChar.UnicodeChar = ch;\n\t}\n\tDumpKnownEscape(asRet, nLen, SrvAnsi::de_Report);\n\tDWORD nWritten = 0;\n\tHANDLE hIn = GetStdHandle(STD_INPUT_HANDLE);\n\tbool bSuccess = WriteConsoleInput(hIn, pir, nLen, &nWritten) && (nWritten == nLen);\n\tif (pir != ir)\n\t\tfree(pir);\n\treturn bSuccess;\n}", "target": 1}
{"code": "static ssize_t o2nm_node_ipv4_address_store(struct config_item *item,\n\t\t\t\t\t    const char *page,\n\t\t\t\t\t    size_t count)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n\tint ret, i;\n\tstruct rb_node **p, *parent;\n\tunsigned int octets[4];\n\t__be32 ipv4_addr = 0;\n\tret = sscanf(page, \"%3u.%3u.%3u.%3u\", &octets[3], &octets[2],\n\t\t     &octets[1], &octets[0]);\n\tif (ret != 4)\n\t\treturn -EINVAL;\n\tfor (i = 0; i < ARRAY_SIZE(octets); i++) {\n\t\tif (octets[i] > 255)\n\t\t\treturn -ERANGE;\n\t\tbe32_add_cpu(&ipv4_addr, octets[i] << (i * 8));\n\t}\n\tret = 0;\n\twrite_lock(&cluster->cl_nodes_lock);\n\tif (o2nm_node_ip_tree_lookup(cluster, ipv4_addr, &p, &parent))\n\t\tret = -EEXIST;\n\telse if (test_and_set_bit(O2NM_NODE_ATTR_ADDRESS,\n\t\t\t&node->nd_set_attributes))\n\t\tret = -EBUSY;\n\telse {\n\t\trb_link_node(&node->nd_ip_node, parent, p);\n\t\trb_insert_color(&node->nd_ip_node, &cluster->cl_node_ip_tree);\n\t}\n\twrite_unlock(&cluster->cl_nodes_lock);\n\tif (ret)\n\t\treturn ret;\n\tmemcpy(&node->nd_ipv4_address, &ipv4_addr, sizeof(ipv4_addr));\n\treturn count;\n}", "target": 1}
{"code": "int dns_add_HTTPS_start(struct dns_rr_nested *svcparam_buffer, struct dns_packet *packet, dns_rr_type type,\n\t\t\t\t\t\tconst char *domain, int ttl, int priority, const char *target)\n{\n\tsvcparam_buffer = dns_add_rr_nested_start(svcparam_buffer, packet, type, DNS_T_HTTPS, domain, ttl);\n\tif (svcparam_buffer == NULL) {\n\t\treturn -1;\n\t}\n\tint target_len = strnlen(target, DNS_MAX_CNAME_LEN) + 1;\n\tif (_dns_left_len(&svcparam_buffer->context) < 2 + target_len) {\n\t\treturn -1;\n\t}\n\t_dns_write_short(&svcparam_buffer->context.ptr, priority);\n\tsafe_strncpy((char *)svcparam_buffer->context.ptr, target, target_len);\n\tsvcparam_buffer->context.ptr += target_len;\n\treturn 0;\n}", "target": 1}
{"code": "  void MakeDataset(OpKernelContext* ctx, DatasetBase** output) override {\n    const Tensor* indices;\n    OP_REQUIRES_OK(ctx, ctx->input(\"indices\", &indices));\n    const Tensor* values;\n    OP_REQUIRES_OK(ctx, ctx->input(\"values\", &values));\n    const Tensor* dense_shape;\n    OP_REQUIRES_OK(ctx, ctx->input(\"dense_shape\", &dense_shape));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(indices->shape()),\n                errors::InvalidArgument(\n                    \"Input indices should be a matrix but received shape \",\n                    indices->shape().DebugString()));\n    const auto num_indices = indices->NumElements();\n    const auto num_values = values->NumElements();\n    if (num_indices == 0 || num_values == 0) {\n      OP_REQUIRES(ctx, num_indices == num_values,\n                  errors::InvalidArgument(\n                      \"If indices or values are empty, the other one must also \"\n                      \"be. Got indices of shape \",\n                      indices->shape().DebugString(), \" and values of shape \",\n                      values->shape().DebugString()));\n    }\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(values->shape()),\n                errors::InvalidArgument(\n                    \"Input values should be a vector but received shape \",\n                    indices->shape().DebugString()));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(dense_shape->shape()),\n                errors::InvalidArgument(\n                    \"Input shape should be a vector but received shape \",\n                    dense_shape->shape().DebugString()));\n    int64_t previous_batch_index = -1;\n    for (int64_t i = 0; i < indices->dim_size(0); ++i) {\n      int64_t next_batch_index = indices->matrix<int64_t>()(i, 0);\n      OP_REQUIRES(\n          ctx, next_batch_index >= previous_batch_index,\n          errors::Unimplemented(\"The SparseTensor must be ordered in the batch \"\n                                \"dimension; handling arbitrarily ordered input \"\n                                \"is not currently supported.\"));\n      previous_batch_index = next_batch_index;\n    }\n    gtl::InlinedVector<int64_t, 8> std_order(dense_shape->NumElements(), 0);\n    sparse::SparseTensor tensor;\n    OP_REQUIRES_OK(\n        ctx, sparse::SparseTensor::Create(\n                 *indices, *values, TensorShape(dense_shape->vec<int64_t>()),\n                 std_order, &tensor));\n    *output = new Dataset<T>(ctx, std::move(tensor));\n  }", "target": 1}
{"code": "flatpak_filesystem_key_in_home (const char *filesystem)\n{\n  if (strcmp (filesystem, \"home\") == 0)\n    return TRUE;\n  if (g_strv_contains (flatpak_context_special_filesystems, filesystem) ||\n      g_str_has_prefix (filesystem, \"/\"))\n    return FALSE;\n  if (g_str_has_prefix (filesystem, \"xdg-run\"))\n    return FALSE;\n  return TRUE;\n}", "target": 0}
{"code": "bool ImageLoader::HasPendingEvent() const {\n  if (image_content_ && !image_complete_ && !loading_image_document_)\n    return true;\n  if (pending_load_event_.IsActive() || pending_error_event_.IsActive())\n    return true;\n  return false;\n}", "target": 0}
{"code": "void WasmBinaryBuilder::requireFunctionContext(const char* error) {\n  if (!currFunction) {\n    throwError(std::string(\"in a non-function context: \") + error);\n  }\n}", "target": 0}
{"code": "  DllDef float libraw_get_pre_mul(libraw_data_t *lr, int index)\n  {\n    if (!lr)\n      return EINVAL;\n    return lr->color.pre_mul[LIM(index, 0, 3)];\n  }", "target": 0}
{"code": "void ExtractStreams(Archive &Arc,const wchar *FileName,bool TestMode)\n{\n  wchar FullName[NM+2];\n  if (FileName[0]!=0 && FileName[1]==0)\n  {\n    wcsncpyz(FullName,L\".\\\\\",ASIZE(FullName));\n    wcsncatz(FullName,FileName,ASIZE(FullName));\n  }\n  else\n    wcsncpyz(FullName,FileName,ASIZE(FullName));\n  wchar StreamName[NM];\n  GetStreamNameNTFS(Arc,StreamName,ASIZE(StreamName));\n  if (*StreamName!=':')\n  {\n    uiMsg(UIERROR_STREAMBROKEN,Arc.FileName,FileName);\n    ErrHandler.SetErrorCode(RARX_CRC);\n    return;\n  }\n  if (TestMode)\n  {\n    File CurFile;\n    Arc.ReadSubData(NULL,&CurFile,true);\n    return;\n  }\n  wcsncatz(FullName,StreamName,ASIZE(FullName));\n  FindData fd;\n  bool HostFound=FindFile::FastFind(FileName,&fd);\n  if ((fd.FileAttr & FILE_ATTRIBUTE_READONLY)!=0)\n    SetFileAttr(FileName,fd.FileAttr & ~FILE_ATTRIBUTE_READONLY);\n  File CurFile;\n  if (CurFile.WCreate(FullName) && Arc.ReadSubData(NULL,&CurFile,false))\n    CurFile.Close();\n  File HostFile;\n  if (HostFound && HostFile.Open(FileName,FMF_OPENSHARED|FMF_UPDATE))\n    SetFileTime(HostFile.GetHandle(),&fd.ftCreationTime,&fd.ftLastAccessTime,\n                &fd.ftLastWriteTime);\n  SetFileAttr(FileName,fd.FileAttr);\n}", "target": 1}
{"code": "static void rose_idletimer_expiry(struct timer_list *t)\n{\n\tstruct rose_sock *rose = from_timer(rose, t, idletimer);\n\tstruct sock *sk = &rose->sock;\n\tbh_lock_sock(sk);\n\trose_clear_queues(sk);\n\trose_write_internal(sk, ROSE_CLEAR_REQUEST);\n\trose_sk(sk)->state = ROSE_STATE_2;\n\trose_start_t3timer(sk);\n\tsk->sk_state     = TCP_CLOSE;\n\tsk->sk_err       = 0;\n\tsk->sk_shutdown |= SEND_SHUTDOWN;\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tsk->sk_state_change(sk);\n\t\tsock_set_flag(sk, SOCK_DEAD);\n\t}\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n}", "target": 0}
{"code": "set_cs_start(char *line)\n{\n  char *p, *q, *r;\n  if ((p = strstr(line, \"string currentfile\"))) {\n    if (!strstr(line, \"readstring\"))\n      return;\n    *p = '\\0';\t\t\t\t\t  \n    q = strrchr(line, '/');\n    if (q) {\n      r = cs_start;\n      ++q;\n      while (!isspace(*q) && *q != '{')\n\t*r++ = *q++;\n      *r = '\\0';\n    }\n    *p = 's';\t\t\t\t\t  \n  }\n}", "target": 1}
{"code": "static RzList  *__io_maps(RzDebug *dbg) {\n\tRzList *list = rz_list_new();\n\tchar *str = dbg->iob.system(dbg->iob.io, \"dm\");\n\tif (!str) {\n\t\trz_list_free(list);\n\t\treturn NULL;\n\t}\n\tchar *ostr = str;\n\tut64 map_start, map_end;\n\tchar perm[32];\n\tchar name[512];\n\tfor (;;) {\n\t\tchar *nl = strchr(str, '\\n');\n\t\tif (nl) {\n\t\t\t*nl = 0;\n\t\t\t*name = 0;\n\t\t\t*perm = 0;\n\t\t\tmap_start = map_end = 0LL;\n\t\t\tif (!strncmp(str, \"sys \", 4)) {\n\t\t\t\tchar *sp = strchr(str + 4, ' ');\n\t\t\t\tif (sp) {\n\t\t\t\t\tstr = sp + 1;\n\t\t\t\t} else {\n\t\t\t\t\tstr += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tchar *_s_ = strstr(str, \" s \");\n\t\t\tif (_s_) {\n\t\t\t\tmemmove(_s_, _s_ + 2, strlen(_s_));\n\t\t\t}\n\t\t\t_s_ = strstr(str, \" ? \");\n\t\t\tif (_s_) {\n\t\t\t\tmemmove(_s_, _s_ + 2, strlen(_s_));\n\t\t\t}\n\t\t\tsscanf(str, \"0x%\" PFMT64x \" - 0x%\" PFMT64x \" %s %s\",\n\t\t\t\t&map_start, &map_end, perm, name);\n\t\t\tif (map_end != 0LL) {\n\t\t\t\tRzDebugMap *map = rz_debug_map_new(name, map_start, map_end, rz_str_rwx(perm), 0);\n\t\t\t\trz_list_append(list, map);\n\t\t\t}\n\t\t\tstr = nl + 1;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree(ostr);\n\trz_cons_reset();\n\treturn list;\n}", "target": 1}
{"code": "static int _string_check(int linenumber, char *buf, const char *buf2)\n{\n  if(strcmp(buf, buf2)) {\n    printf(\"sprintf line %d failed:\\nwe      '%s'\\nsystem: '%s'\\n\",\n           linenumber, buf, buf2);\n    return 1;\n  }\n  return 0;\n}", "target": 0}
{"code": "static void JS_FoxxAllowInstallFromRemote(\n    v8::FunctionCallbackInfo<v8::Value> const& args) {\n  TRI_V8_TRY_CATCH_BEGIN(isolate)\n  v8::HandleScope scope(isolate);\n  TRI_GET_GLOBALS();\n  ServerSecurityFeature& security =\n      v8g->_server.getFeature<ServerSecurityFeature>();\n  TRI_V8_RETURN_BOOL(security.foxxAllowInstallFromRemote());\n  TRI_V8_TRY_CATCH_END\n}", "target": 0}
{"code": "static bool ndp_msg_addrto_validate_link_local(struct in6_addr *addr)\n{\n\treturn IN6_IS_ADDR_LINKLOCAL (addr);\n}", "target": 0}
{"code": "int h1_parse_cont_len_header(struct h1m *h1m, struct ist *value)\n{\n\tchar *e, *n;\n\tlong long cl;\n\tint not_first = !!(h1m->flags & H1_MF_CLEN);\n\tstruct ist word;\n\tword.ptr = value->ptr - 1; \n\te = value->ptr + value->len;\n\twhile (++word.ptr < e) {\n\t\tif (unlikely(HTTP_IS_LWS(*word.ptr)))\n\t\t\tcontinue;\n\t\tfor (cl = 0, n = word.ptr; n < e; n++) {\n\t\t\tunsigned int c = *n - '0';\n\t\t\tif (unlikely(c > 9)) {\n\t\t\t\tif (unlikely(n == word.ptr)) \n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (unlikely(cl > ULLONG_MAX / 10ULL))\n\t\t\t\tgoto fail; \n\t\t\tcl = cl * 10ULL;\n\t\t\tif (unlikely(cl + c < cl))\n\t\t\t\tgoto fail; \n\t\t\tcl = cl + c;\n\t\t}\n\t\tword.len = n - word.ptr;\n\t\tfor (; n < e; n++) {\n\t\t\tif (!HTTP_IS_LWS(*n)) {\n\t\t\t\tif (unlikely(*n != ','))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (h1m->flags & H1_MF_CLEN && cl != h1m->body_len)\n\t\t\tgoto fail;\n\t\th1m->flags |= H1_MF_CLEN;\n\t\th1m->curr_len = h1m->body_len = cl;\n\t\t*value = word;\n\t\tword.ptr = n;\n\t}\n\treturn !not_first;\n fail:\n\treturn -1;\n}", "target": 1}
{"code": "static uint32_t scsi_init_iovec(SCSIDiskReq *r)\n{\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    if (!r->iov.iov_base) {\n        r->buflen = SCSI_DMA_BUF_SIZE;\n        r->iov.iov_base = qemu_blockalign(s->bs, r->buflen);\n    }\n    r->iov.iov_len = MIN(r->sector_count * 512, r->buflen);\n    qemu_iovec_init_external(&r->qiov, &r->iov, 1);\n    return r->qiov.size / 512;\n}", "target": 0}
{"code": "static String cachedStorageDirectory(DWORD pathIdentifier)\n{\n    static HashMap<DWORD, String> directories;\n    HashMap<DWORD, String>::iterator it = directories.find(pathIdentifier);\n    if (it != directories.end())\n        return it->value;\n    String directory = storageDirectory(pathIdentifier);\n    directories.add(pathIdentifier, directory);\n    return directory;\n}", "target": 0}
{"code": "static bool can_skip_alu_sanitation(const struct bpf_verifier_env *env,\n\t\t\t\t    const struct bpf_insn *insn)\n{\n\treturn env->allow_ptr_leaks || BPF_SRC(insn->code) == BPF_K;\n}", "target": 0}
{"code": "Error HeifContext::get_id_of_non_virtual_child_image(heif_item_id id, heif_item_id& out) const\n{\n  std::string image_type = m_heif_file->get_item_type(id);\n  if (image_type==\"grid\" ||\n      image_type==\"iden\" ||\n      image_type==\"iovl\") {\n    auto iref_box = m_heif_file->get_iref_box();\n    if (!iref_box) {\n      return Error(heif_error_Invalid_input,\n                   heif_suberror_No_item_data,\n                   \"Derived image does not reference any other image items\");\n    }\n    std::vector<heif_item_id> image_references = iref_box->get_references(id, fourcc(\"dimg\"));\n    if (image_references.empty()) {\n      return Error(heif_error_Invalid_input,\n                   heif_suberror_No_item_data,\n                   \"Derived image does not reference any other image items\");\n    }\n    else {\n      return get_id_of_non_virtual_child_image(image_references[0], out);\n    }\n  }\n  else {\n    out = id;\n    return Error::Ok;\n  }\n}", "target": 0}
{"code": "int lstat_cache_aware_rmdir(const char *path)\n{\n\tint ret = rmdir(path);\n\tif (!ret)\n\t\tinvalidate_lstat_cache();\n\treturn ret;\n}", "target": 0}
{"code": "static int atusb_get_and_show_build(struct atusb *atusb)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tchar build[ATUSB_BUILD_SIZE + 1];\n\tint ret;\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_BUILD, ATUSB_REQ_FROM_DEV, 0, 0,\n\t\t\t\tbuild, ATUSB_BUILD_SIZE, 1000);\n\tif (ret >= 0) {\n\t\tbuild[ret] = 0;\n\t\tdev_info(&usb_dev->dev, \"Firmware: build %s\\n\", build);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "TEST_F(QueryPlannerTest, InSparseIndex) {\n    addIndex(fromjson(\"{a: 1}\"),\n             false,  \n             true);  \n    runQuery(fromjson(\"{a: {$in: [null]}}\"));\n    assertNumSolutions(1U);\n    assertSolutionExists(\"{cscan: {dir: 1, filter: {a: {$eq: null}}}}\");\n}", "target": 0}
{"code": "static int __do_page_fault(struct mm_struct *mm, unsigned long addr,\n\t\t\t   unsigned int mm_flags, unsigned long vm_flags,\n\t\t\t   struct task_struct *tsk)\n{\n\tstruct vm_area_struct *vma;\n\tint fault;\n\tvma = find_vma(mm, addr);\n\tfault = VM_FAULT_BADMAP;\n\tif (unlikely(!vma))\n\t\tgoto out;\n\tif (unlikely(vma->vm_start > addr))\n\t\tgoto check_stack;\ngood_area:\n\tif (!(vma->vm_flags & vm_flags)) {\n\t\tfault = VM_FAULT_BADACCESS;\n\t\tgoto out;\n\t}\n\treturn handle_mm_fault(mm, vma, addr & PAGE_MASK, mm_flags);\ncheck_stack:\n\tif (vma->vm_flags & VM_GROWSDOWN && !expand_stack(vma, addr))\n\t\tgoto good_area;\nout:\n\treturn fault;\n}", "target": 1}
{"code": "static u32 gasp_version(__be32 *p)\n{\n\treturn be32_to_cpu(p[1]) & 0xffffff;\n}", "target": 0}
{"code": "sd_markdown_new(\n\tunsigned int extensions,\n\tsize_t max_nesting,\n\tconst struct sd_callbacks *callbacks,\n\tvoid *opaque)\n{\n\tstruct sd_markdown *md = NULL;\n\tassert(max_nesting > 0 && callbacks);\n\tmd = malloc(sizeof(struct sd_markdown));\n\tif (!md)\n\t\treturn NULL;\n\tmemcpy(&md->cb, callbacks, sizeof(struct sd_callbacks));\n\tredcarpet_stack_init(&md->work_bufs[BUFFER_BLOCK], 4);\n\tredcarpet_stack_init(&md->work_bufs[BUFFER_SPAN], 8);\n\tmemset(md->active_char, 0x0, 256);\n\tif (md->cb.emphasis || md->cb.double_emphasis || md->cb.triple_emphasis) {\n\t\tmd->active_char['*'] = MD_CHAR_EMPHASIS;\n\t\tmd->active_char['_'] = MD_CHAR_EMPHASIS;\n\t\tif (extensions & MKDEXT_STRIKETHROUGH)\n\t\t\tmd->active_char['~'] = MD_CHAR_EMPHASIS;\n\t\tif (extensions & MKDEXT_HIGHLIGHT)\n\t\t\tmd->active_char['='] = MD_CHAR_EMPHASIS;\n\t}\n\tif (md->cb.codespan)\n\t\tmd->active_char['`'] = MD_CHAR_CODESPAN;\n\tif (md->cb.linebreak)\n\t\tmd->active_char['\\n'] = MD_CHAR_LINEBREAK;\n\tif (md->cb.image || md->cb.link)\n\t\tmd->active_char['['] = MD_CHAR_LINK;\n\tmd->active_char['<'] = MD_CHAR_LANGLE;\n\tmd->active_char['\\\\'] = MD_CHAR_ESCAPE;\n\tmd->active_char['&'] = MD_CHAR_ENTITITY;\n\tif (extensions & MKDEXT_AUTOLINK) {\n\t\tmd->active_char[':'] = MD_CHAR_AUTOLINK_URL;\n\t\tmd->active_char['@'] = MD_CHAR_AUTOLINK_EMAIL;\n\t\tmd->active_char['w'] = MD_CHAR_AUTOLINK_WWW;\n\t}\n\tif (extensions & MKDEXT_SUPERSCRIPT)\n\t\tmd->active_char['^'] = MD_CHAR_SUPERSCRIPT;\n\tif (extensions & MKDEXT_QUOTE)\n\t\tmd->active_char['\"'] = MD_CHAR_QUOTE;\n\tmd->ext_flags = extensions;\n\tmd->opaque = opaque;\n\tmd->max_nesting = max_nesting;\n\tmd->in_link_body = 0;\n\treturn md;\n}", "target": 0}
{"code": "static inline bool key_is_negative(const struct key *key)\n{\n\treturn key_read_state(key) < 0;\n}", "target": 0}
{"code": "crm_initiate_client_tls_handshake(void *session_data, int timeout_ms)\n{\n    int rc = 0;\n    int pollrc = 0;\n    time_t start = time(NULL);\n    gnutls_session *session = session_data;\n    do {\n        rc = gnutls_handshake(*session);\n        if (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN) {\n            pollrc = crm_recv_remote_ready(session, TRUE, 1000);\n            if (pollrc < 0) {\n                rc = -1;\n            }\n        }\n    } while (((time(NULL) - start) < (timeout_ms/1000)) &&\n            (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN));\n    return rc;\n}", "target": 0}
{"code": "static void dbOutputHexBlob(Jsi_DString *dStr, const void *pBlob, int nBlob){\n  int i;\n  char out[100], *zBlob = (char *)pBlob;\n  Jsi_DSAppend(dStr, \"X'\", NULL);\n  for(i=0; i<nBlob; i++){ snprintf(out, sizeof(out),\"%02x\",zBlob[i]&0xff);Jsi_DSAppend(dStr, out, NULL); }\n  Jsi_DSAppend(dStr, \"'\", NULL);\n}", "target": 1}
{"code": "static int gup_huge_pmd(pmd_t orig, pmd_t *pmdp, unsigned long addr,\n\t\tunsigned long end, int write, struct page **pages, int *nr)\n{\n\tstruct page *head, *page;\n\tint refs;\n\tif (!pmd_access_permitted(orig, write))\n\t\treturn 0;\n\tif (pmd_devmap(orig))\n\t\treturn __gup_device_huge_pmd(orig, pmdp, addr, end, pages, nr);\n\trefs = 0;\n\tpage = pmd_page(orig) + ((addr & ~PMD_MASK) >> PAGE_SHIFT);\n\tdo {\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\t\tpage++;\n\t\trefs++;\n\t} while (addr += PAGE_SIZE, addr != end);\n\thead = compound_head(pmd_page(orig));\n\tif (!page_cache_add_speculative(head, refs)) {\n\t\t*nr -= refs;\n\t\treturn 0;\n\t}\n\tif (unlikely(pmd_val(orig) != pmd_val(*pmdp))) {\n\t\t*nr -= refs;\n\t\twhile (refs--)\n\t\t\tput_page(head);\n\t\treturn 0;\n\t}\n\tSetPageReferenced(head);\n\treturn 1;\n}", "target": 1}
{"code": "static uint32_t qpp_hash(QppEntry e)\n{\n    return qemu_xxhash7(e.ino_prefix, e.dev, 0, 0, 0);\n}", "target": 0}
{"code": "get_chainname_rulenum(const struct ip6t_entry *s, const struct ip6t_entry *e,\n\t\t      const char *hookname, const char **chainname,\n\t\t      const char **comment, unsigned int *rulenum)\n{\n\tconst struct xt_standard_target *t = (void *)ip6t_get_target_c(s);\n\tif (strcmp(t->target.u.kernel.target->name, XT_ERROR_TARGET) == 0) {\n\t\t*chainname = t->target.data;\n\t\t(*rulenum) = 0;\n\t} else if (s == e) {\n\t\t(*rulenum)++;\n\t\tif (s->target_offset == sizeof(struct ip6t_entry) &&\n\t\t    strcmp(t->target.u.kernel.target->name,\n\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t    t->verdict < 0 &&\n\t\t    unconditional(&s->ipv6)) {\n\t\t\t*comment = *chainname == hookname\n\t\t\t\t? comments[NF_IP6_TRACE_COMMENT_POLICY]\n\t\t\t\t: comments[NF_IP6_TRACE_COMMENT_RETURN];\n\t\t}\n\t\treturn 1;\n\t} else\n\t\t(*rulenum)++;\n\treturn 0;\n}", "target": 1}
{"code": "Integer InvertibleRWFunction::CalculateInverse(RandomNumberGenerator &rng, const Integer &x) const\n{\n\tDoQuickSanityCheck();\n\tModularArithmetic modn(m_n);\n\tInteger r, rInv;\n\tdo {\t\n\t\tr.Randomize(rng, Integer::One(), m_n - Integer::One());\n\t\trInv = modn.MultiplicativeInverse(r);\n\t} while (rInv.IsZero());\n\tInteger re = modn.Square(r);\n\tre = modn.Multiply(re, x);\t\t\t\n\tInteger cp=re%m_p, cq=re%m_q;\n\tif (Jacobi(cp, m_p) * Jacobi(cq, m_q) != 1)\n\t{\n\t\tcp = cp.IsOdd() ? (cp+m_p) >> 1 : cp >> 1;\n\t\tcq = cq.IsOdd() ? (cq+m_q) >> 1 : cq >> 1;\n\t}\n\t#pragma omp parallel\n\t\t#pragma omp sections\n\t\t{\n\t\t\t#pragma omp section\n\t\t\t\tcp = ModularSquareRoot(cp, m_p);\n\t\t\t#pragma omp section\n\t\t\t\tcq = ModularSquareRoot(cq, m_q);\n\t\t}\n\tInteger y = CRT(cq, m_q, cp, m_p, m_u);\n\ty = modn.Multiply(y, rInv);\t\t\t\t\n\ty = STDMIN(y, m_n-y);\n\tif (ApplyFunction(y) != x)\t\t\t\t\n\t\tthrow Exception(Exception::OTHER_ERROR, \"InvertibleRWFunction: computational error during private key operation\");\n\treturn y;\n}", "target": 1}
{"code": "void error_handler(int priority, const char *format, ...)\n{\n    gdTestAssert(priority == GD_WARNING);\n    gdTestAssert(!strcmp(format, MSG));\n}", "target": 0}
{"code": "TEST(ArrayOpsTest, QuantizeAndDequantizeV2_ShapeFn) {\n  ShapeInferenceTestOp op(\"QuantizeAndDequantizeV2\");\n  op.input_tensors.resize(3);\n  TF_ASSERT_OK(NodeDefBuilder(\"test\", \"QuantizeAndDequantizeV2\")\n                   .Input(\"input\", 0, DT_FLOAT)\n                   .Input(\"input_min\", 1, DT_FLOAT)\n                   .Input(\"input_max\", 2, DT_FLOAT)\n                   .Attr(\"signed_input\", true)\n                   .Attr(\"num_bits\", 8)\n                   .Attr(\"range_given\", false)\n                   .Attr(\"narrow_range\", false)\n                   .Attr(\"axis\", -1)\n                   .Finalize(&op.node_def));\n  INFER_OK(op, \"?;?;?\", \"in0\");\n  INFER_OK(op, \"[];?;?\", \"in0\");\n  INFER_OK(op, \"[1,2,?,4,5];?;?\", \"in0\");\n  INFER_ERROR(\"Shape must be rank 0 but is rank 1\", op, \"[1,2,?,4,5];[1];[]\");\n  INFER_ERROR(\"Shapes must be equal rank, but are 1 and 0\", op,\n              \"[1,2,?,4,5];[];[1]\");\n  INFER_ERROR(\"Shape must be rank 0 but is rank 1\", op, \"[1,2,?,4,5];[1];[1]\");\n  (*op.node_def.mutable_attr())[\"axis\"].set_i(-2);\n  INFER_ERROR(\"axis should be at least -1, got -2\", op, \"?;?;?\");\n}", "target": 0}
{"code": "  virtual void DisconnectFromWirelessNetwork(const WirelessNetwork* network) {\n    DCHECK(network);\n    if (!EnsureCrosLoaded() || !network)\n      return;\n    if (DisconnectFromNetwork(network->service_path().c_str())) {\n      if (network->type() == TYPE_WIFI) {\n        WifiNetwork* wifi = GetWirelessNetworkByPath(\n            wifi_networks_, network->service_path());\n        if (wifi) {\n          wifi->set_connected(false);\n          wifi_ = NULL;\n        }\n      } else if (network->type() == TYPE_CELLULAR) {\n        CellularNetwork* cellular = GetWirelessNetworkByPath(\n            cellular_networks_, network->service_path());\n        if (cellular) {\n          cellular->set_connected(false);\n          cellular_ = NULL;\n        }\n      }\n      NotifyNetworkManagerChanged();\n    }\n  }", "target": 0}
{"code": "static void sanitize_dead_code(struct bpf_verifier_env *env)\n{\n\tstruct bpf_insn_aux_data *aux_data = env->insn_aux_data;\n\tstruct bpf_insn nop = BPF_MOV64_REG(BPF_REG_0, BPF_REG_0);\n\tstruct bpf_insn *insn = env->prog->insnsi;\n\tconst int insn_cnt = env->prog->len;\n\tint i;\n\tfor (i = 0; i < insn_cnt; i++) {\n\t\tif (aux_data[i].seen)\n\t\t\tcontinue;\n\t\tmemcpy(insn + i, &nop, sizeof(nop));\n\t}\n}", "target": 0}
{"code": "  virtual ~GatherHostUsageTask() {}", "target": 0}
{"code": "static void regulator_ena_gpio_free(struct regulator_dev *rdev)\n{\n\tstruct regulator_enable_gpio *pin, *n;\n\tif (!rdev->ena_pin)\n\t\treturn;\n\tlist_for_each_entry_safe(pin, n, &regulator_ena_gpio_list, list) {\n\t\tif (pin->gpiod == rdev->ena_pin->gpiod) {\n\t\t\tif (pin->request_count <= 1) {\n\t\t\t\tpin->request_count = 0;\n\t\t\t\tgpiod_put(pin->gpiod);\n\t\t\t\tlist_del(&pin->list);\n\t\t\t\tkfree(pin);\n\t\t\t\trdev->ena_pin = NULL;\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tpin->request_count--;\n\t\t\t}\n\t\t}\n\t}\n}", "target": 0}
{"code": "  StringSanMatcher(int general_name_type, envoy::type::matcher::v3::StringMatcher matcher)\n      : general_name_type_(general_name_type), matcher_(matcher) {}", "target": 0}
{"code": "void jspReplaceWithOrAddToRoot(JsVar *dst, JsVar *src) {\n  if (!jsvGetRefs(dst) && jsvIsName(dst)) {\n    if (!jsvIsArrayBufferName(dst) && !jsvIsNewChild(dst))\n      jsvAddName(execInfo.root, dst);\n  }\n  jspReplaceWith(dst, src);\n}", "target": 0}
{"code": "void IndexedDBDatabase::DeleteDatabase(\n    scoped_refptr<IndexedDBCallbacks> callbacks,\n    bool force_close) {\n  AppendRequest(std::make_unique<DeleteRequest>(this, callbacks));\n  if (force_close)\n    ForceClose();\n}", "target": 0}
{"code": "static int dynamicGetbuf(gdIOCtxPtr ctx, void *buf, int len)\n{\n\tint rlen, remain;\n\tdpIOCtxPtr dctx;\n\tdynamicPtr *dp;\n\tdctx = (dpIOCtxPtr) ctx;\n\tdp = dctx->dp;\n\tremain = dp->logicalSize - dp->pos;\n\tif(remain >= len) {\n\t\trlen = len;\n\t} else {\n\t\tif(remain == 0) {\n\t\t\treturn 0; \n\t\t}\n\t\trlen = remain;\n\t}\n\tmemcpy(buf, (void *) ((char *)dp->data + dp->pos), rlen);\n\tdp->pos += rlen;\n\treturn rlen;\n}", "target": 1}
{"code": "static int do_sched_cfs_period_timer(struct cfs_bandwidth *cfs_b, int overrun, unsigned long flags)\n{\n\tu64 runtime, runtime_expires;\n\tint throttled;\n\tif (cfs_b->quota == RUNTIME_INF)\n\t\tgoto out_deactivate;\n\tthrottled = !list_empty(&cfs_b->throttled_cfs_rq);\n\tcfs_b->nr_periods += overrun;\n\tif (cfs_b->idle && !throttled)\n\t\tgoto out_deactivate;\n\t__refill_cfs_bandwidth_runtime(cfs_b);\n\tif (!throttled) {\n\t\tcfs_b->idle = 1;\n\t\treturn 0;\n\t}\n\tcfs_b->nr_throttled += overrun;\n\truntime_expires = cfs_b->runtime_expires;\n\twhile (throttled && cfs_b->runtime > 0 && !cfs_b->distribute_running) {\n\t\truntime = cfs_b->runtime;\n\t\tcfs_b->distribute_running = 1;\n\t\traw_spin_unlock_irqrestore(&cfs_b->lock, flags);\n\t\truntime = distribute_cfs_runtime(cfs_b, runtime,\n\t\t\t\t\t\t runtime_expires);\n\t\traw_spin_lock_irqsave(&cfs_b->lock, flags);\n\t\tcfs_b->distribute_running = 0;\n\t\tthrottled = !list_empty(&cfs_b->throttled_cfs_rq);\n\t\tlsub_positive(&cfs_b->runtime, runtime);\n\t}\n\tcfs_b->idle = 0;\n\treturn 0;\nout_deactivate:\n\treturn 1;\n}", "target": 1}
{"code": "    Status CmdAuthenticate::_authenticateX509(const UserName& user, const BSONObj& cmdObj) {\n        if (!getSSLManager()) {\n            return Status(ErrorCodes::ProtocolError,\n                          \"SSL support is required for the MONGODB-X509 mechanism.\");\n        }\n        if(user.getDB() != \"$external\") {\n            return Status(ErrorCodes::ProtocolError,\n                          \"X.509 authentication must always use the $external database.\");\n        }\n        ClientBasic *client = ClientBasic::getCurrent();\n        AuthorizationSession* authorizationSession = client->getAuthorizationSession();\n        std::string subjectName = client->port()->getX509SubjectName();\n        if (user.getUser() != subjectName) {\n            return Status(ErrorCodes::AuthenticationFailed,\n                          \"There is no x.509 client certificate matching the user.\");\n        }\n        else {\n            std::string srvSubjectName = getSSLManager()->getServerSubjectName();\n            std::string srvClusterId = srvSubjectName.substr(srvSubjectName.find(\",OU=\"));\n            std::string peerClusterId = subjectName.substr(subjectName.find(\",OU=\"));\n            fassert(17002, !srvClusterId.empty() && srvClusterId != srvSubjectName);\n            int clusterAuthMode = serverGlobalParams.clusterAuthMode.load(); \n            if (srvClusterId == peerClusterId) {\n                if (clusterAuthMode == ServerGlobalParams::ClusterAuthMode_undefined ||\n                    clusterAuthMode == ServerGlobalParams::ClusterAuthMode_keyFile) {\n                    return Status(ErrorCodes::AuthenticationFailed, \"The provided certificate \" \n                                  \"can only be used for cluster authentication, not client \" \n                                  \"authentication. The current configuration does not allow \" \n                                  \"x.509 cluster authentication, check the --clusterAuthMode flag\");\n                }\n                authorizationSession->grantInternalAuthorization();\n            }\n            else {\n                if (_isX509AuthDisabled) {\n                    return Status(ErrorCodes::BadValue,\n                                  _x509AuthenticationDisabledMessage);\n                }\n                Status status = authorizationSession->addAndAuthorizeUser(user);\n                if (!status.isOK()) {\n                    return status;\n                }\n            }\n            return Status::OK();\n        }\n    }", "target": 1}
{"code": "int cx23888_ir_probe(struct cx23885_dev *dev)\n{\n\tstruct cx23888_ir_state *state;\n\tstruct v4l2_subdev *sd;\n\tstruct v4l2_subdev_ir_parameters default_params;\n\tint ret;\n\tstate = kzalloc(sizeof(struct cx23888_ir_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&state->rx_kfifo_lock);\n\tif (kfifo_alloc(&state->rx_kfifo, CX23888_IR_RX_KFIFO_SIZE, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\tstate->dev = dev;\n\tsd = &state->sd;\n\tv4l2_subdev_init(sd, &cx23888_ir_controller_ops);\n\tv4l2_set_subdevdata(sd, state);\n\tsnprintf(sd->name, sizeof(sd->name), \"%s/888-ir\", dev->name);\n\tsd->grp_id = CX23885_HW_888_IR;\n\tret = v4l2_device_register_subdev(&dev->v4l2_dev, sd);\n\tif (ret == 0) {\n\t\tcx23888_ir_write4(dev, CX23888_IR_IRQEN_REG, 0);\n\t\tmutex_init(&state->rx_params_lock);\n\t\tdefault_params = default_rx_params;\n\t\tv4l2_subdev_call(sd, ir, rx_s_parameters, &default_params);\n\t\tmutex_init(&state->tx_params_lock);\n\t\tdefault_params = default_tx_params;\n\t\tv4l2_subdev_call(sd, ir, tx_s_parameters, &default_params);\n\t} else {\n\t\tkfifo_free(&state->rx_kfifo);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "add_mibfile(const char* tmpstr, const char* d_name, FILE *ip )\n{\n    FILE           *fp;\n    char            token[MAXTOKEN], token2[MAXTOKEN];\n    if ((fp = fopen(tmpstr, \"r\")) == NULL) {\n        snmp_log_perror(tmpstr);\n        return 1;\n    }\n    DEBUGMSGTL((\"parse-mibs\", \"Checking file: %s...\\n\",\n                tmpstr));\n    mibLine = 1;\n    File = tmpstr;\n    if (get_token(fp, token, MAXTOKEN) != LABEL) {\n\t    fclose(fp);\n\t    return 1;\n    }\n    if (get_token(fp, token2, MAXTOKEN) == DEFINITIONS) {\n        new_module(token, tmpstr);\n        if (ip)\n            fprintf(ip, \"%s %s\\n\", token, d_name);\n        fclose(fp);\n        return 0;\n    } else {\n        fclose(fp);\n        return 1;\n    }\n}", "target": 1}
{"code": "static char *lxclock_name(const char *p, const char *n)\n{\n\tint ret;\n\tint len;\n\tchar *dest;\n\tchar *rundir;\n\tlen = strlen(\"/lock/lxc/\") + strlen(n) + strlen(p) + 3;\n\trundir = get_rundir();\n\tif (!rundir)\n\t\treturn NULL;\n\tlen += strlen(rundir);\n\tif ((dest = malloc(len)) == NULL) {\n\t\tfree(rundir);\n\t\treturn NULL;\n\t}\n\tret = snprintf(dest, len, \"%s/lock/lxc/%s\", rundir, p);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(dest);\n\t\tfree(rundir);\n\t\treturn NULL;\n\t}\n\tret = mkdir_p(dest, 0755);\n\tif (ret < 0) {\n\t\tint l2 = 22 + strlen(n) + strlen(p);\n\t\tif (l2 > len) {\n\t\t\tchar *d;\n\t\t\td = realloc(dest, l2);\n\t\t\tif (!d) {\n\t\t\t\tfree(dest);\n\t\t\t\tfree(rundir);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tlen = l2;\n\t\t\tdest = d;\n\t\t}\n\t\tret = snprintf(dest, len, \"/tmp/%d/lxc%s\", geteuid(), p);\n\t\tif (ret < 0 || ret >= len) {\n\t\t\tfree(dest);\n\t\t\tfree(rundir);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = mkdir_p(dest, 0755);\n\t\tif (ret < 0) {\n\t\t\tfree(dest);\n\t\t\tfree(rundir);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = snprintf(dest, len, \"/tmp/%d/lxc%s/.%s\", geteuid(), p, n);\n\t} else\n\t\tret = snprintf(dest, len, \"%s/lock/lxc/%s/.%s\", rundir, p, n);\n\tfree(rundir);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(dest);\n\t\treturn NULL;\n\t}\n\treturn dest;\n}", "target": 1}
{"code": "static void coroutine_fn v9fs_getattr(void *opaque)\n{\n    int32_t fid;\n    size_t offset = 7;\n    ssize_t retval = 0;\n    struct stat stbuf;\n    V9fsFidState *fidp;\n    uint64_t request_mask;\n    V9fsStatDotl v9stat_dotl;\n    V9fsPDU *pdu = opaque;\n    retval = pdu_unmarshal(pdu, offset, \"dq\", &fid, &request_mask);\n    if (retval < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_getattr(pdu->tag, pdu->id, fid, request_mask);\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        retval = -ENOENT;\n        goto out_nofid;\n    }\n    retval = v9fs_co_lstat(pdu, &fidp->path, &stbuf);\n    if (retval < 0) {\n        goto out;\n    }\n    retval = stat_to_v9stat_dotl(pdu, &stbuf, &v9stat_dotl);\n    if (retval < 0) {\n        goto out;\n    }\n    if (request_mask & P9_STATS_GEN) {\n        retval = v9fs_co_st_gen(pdu, &fidp->path, stbuf.st_mode, &v9stat_dotl);\n        switch (retval) {\n        case 0:\n            v9stat_dotl.st_result_mask |= P9_STATS_GEN;\n            break;\n        case -EINTR:\n            goto out;\n        default:\n            break;\n        }\n    }\n    retval = pdu_marshal(pdu, offset, \"A\", &v9stat_dotl);\n    if (retval < 0) {\n        goto out;\n    }\n    retval += offset;\n    trace_v9fs_getattr_return(pdu->tag, pdu->id, v9stat_dotl.st_result_mask,\n                              v9stat_dotl.st_mode, v9stat_dotl.st_uid,\n                              v9stat_dotl.st_gid);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, retval);\n}", "target": 0}
{"code": "void WasmBinaryBuilder::visitUnreachable(Unreachable* curr) {\n  BYN_TRACE(\"zz node: Unreachable\\n\");\n}", "target": 0}
{"code": "bool IsSupported(const tensorflow::DataType data_type) {\n  switch (data_type) {\n    case tensorflow::DT_FLOAT:\n    case tensorflow::DT_DOUBLE:\n    case tensorflow::DT_INT32:\n    case tensorflow::DT_UINT8:\n    case tensorflow::DT_INT16:\n    case tensorflow::DT_INT8:\n    case tensorflow::DT_STRING:\n    case tensorflow::DT_COMPLEX64:\n    case tensorflow::DT_INT64:\n    case tensorflow::DT_BOOL:\n    case tensorflow::DT_QINT8:\n    case tensorflow::DT_QUINT8:\n    case tensorflow::DT_QINT32:\n    case tensorflow::DT_BFLOAT16:\n    case tensorflow::DT_QINT16:\n    case tensorflow::DT_QUINT16:\n    case tensorflow::DT_UINT16:\n    case tensorflow::DT_COMPLEX128:\n    case tensorflow::DT_HALF:\n    case tensorflow::DT_UINT32:\n    case tensorflow::DT_UINT64:\n    case tensorflow::DT_FLOAT8_E5M2:\n    case tensorflow::DT_FLOAT8_E4M3FN:\n    case tensorflow::DT_INT4:\n    case tensorflow::DT_UINT4:\n      return true;\n    default:\n      return false;\n  }\n}", "target": 0}
{"code": "cib_remote_signon(cib_t * cib, const char *name, enum cib_conn_type type)\n{\n    int rc = pcmk_ok;\n    cib_remote_opaque_t *private = cib->variant_opaque;\n    if (private->passwd == NULL) {\n        struct termios settings;\n        int rc;\n        rc = tcgetattr(0, &settings);\n        settings.c_lflag &= ~ECHO;\n        rc = tcsetattr(0, TCSANOW, &settings);\n        fprintf(stderr, \"Password: \");\n        private->passwd = calloc(1, 1024);\n        rc = scanf(\"%s\", private->passwd);\n        fprintf(stdout, \"\\n\");\n        if (rc < 1) {\n            private->passwd = NULL;\n        }\n        settings.c_lflag |= ECHO;\n        rc = tcsetattr(0, TCSANOW, &settings);\n    }\n    if (private->server == NULL || private->user == NULL) {\n        rc = -EINVAL;\n    }\n    if (rc == pcmk_ok) {\n        rc = cib_tls_signon(cib, &(private->command));\n    }\n    if (rc == pcmk_ok) {\n        rc = cib_tls_signon(cib, &(private->callback));\n    }\n    if (rc == pcmk_ok) {\n        xmlNode *hello =\n            cib_create_op(0, private->callback.token, CRM_OP_REGISTER, NULL, NULL, NULL, 0, NULL);\n        crm_xml_add(hello, F_CIB_CLIENTNAME, name);\n        crm_send_remote_msg(private->command.session, hello, private->command.encrypted);\n        free_xml(hello);\n    }\n    if (rc == pcmk_ok) {\n        fprintf(stderr, \"%s: Opened connection to %s:%d\\n\", name, private->server, private->port);\n        cib->state = cib_connected_command;\n        cib->type = cib_command;\n    } else {\n        fprintf(stderr, \"%s: Connection to %s:%d failed: %s\\n\",\n                name, private->server, private->port, pcmk_strerror(rc));\n    }\n    return rc;\n}", "target": 1}
{"code": "bool RepeatedAttrDefEqual(\n    const protobuf::RepeatedPtrField<OpDef::AttrDef>& a1,\n    const protobuf::RepeatedPtrField<OpDef::AttrDef>& a2) {\n  std::unordered_map<string, const OpDef::AttrDef*> a1_set;\n  for (const OpDef::AttrDef& def : a1) {\n    DCHECK(a1_set.find(def.name()) == a1_set.end())\n        << \"AttrDef names must be unique, but '\" << def.name()\n        << \"' appears more than once\";\n    a1_set[def.name()] = &def;\n  }\n  for (const OpDef::AttrDef& def : a2) {\n    auto iter = a1_set.find(def.name());\n    if (iter == a1_set.end()) return false;\n    if (!AttrDefEqual(*iter->second, def)) return false;\n    a1_set.erase(iter);\n  }\n  if (!a1_set.empty()) return false;\n  return true;\n}", "target": 1}
{"code": "int ff_amf_get_field_value(const uint8_t *data, const uint8_t *data_end,\n                           const uint8_t *name, uint8_t *dst, int dst_size)\n{\n    int namelen = strlen(name);\n    int len;\n    while (*data != AMF_DATA_TYPE_OBJECT && data < data_end) {\n        len = ff_amf_tag_size(data, data_end);\n        if (len < 0)\n            len = data_end - data;\n        data += len;\n    }\n    if (data_end - data < 3)\n        return -1;\n    data++;\n    for (;;) {\n        int size = bytestream_get_be16(&data);\n        if (!size)\n            break;\n        if (size < 0 || size >= data_end - data)\n            return -1;\n        data += size;\n        if (size == namelen && !memcmp(data-size, name, namelen)) {\n            switch (*data++) {\n            case AMF_DATA_TYPE_NUMBER:\n                snprintf(dst, dst_size, \"%g\", av_int2double(AV_RB64(data)));\n                break;\n            case AMF_DATA_TYPE_BOOL:\n                snprintf(dst, dst_size, \"%s\", *data ? \"true\" : \"false\");\n                break;\n            case AMF_DATA_TYPE_STRING:\n                len = bytestream_get_be16(&data);\n                av_strlcpy(dst, data, FFMIN(len+1, dst_size));\n                break;\n            default:\n                return -1;\n            }\n            return 0;\n        }\n        len = ff_amf_tag_size(data, data_end);\n        if (len < 0 || len >= data_end - data)\n            return -1;\n        data += len;\n    }\n    return -1;\n}", "target": 1}
{"code": "static void\nyydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, void *yyscanner, HEX_LEX_ENVIRONMENT *lex_env)\n{\n  YYUSE (yyvaluep);\n  YYUSE (yyscanner);\n  YYUSE (lex_env);\n  if (!yymsg)\n    yymsg = \"Deleting\";\n  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  switch (yytype)\n    {\n          case 16: \n#line 94 \"hex_grammar.y\" \n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1023 \"hex_grammar.c\" \n        break;\n    case 17: \n#line 95 \"hex_grammar.y\" \n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1029 \"hex_grammar.c\" \n        break;\n    case 18: \n#line 96 \"hex_grammar.y\" \n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1035 \"hex_grammar.c\" \n        break;\n    case 19: \n#line 97 \"hex_grammar.y\" \n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1041 \"hex_grammar.c\" \n        break;\n    case 21: \n#line 100 \"hex_grammar.y\" \n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1047 \"hex_grammar.c\" \n        break;\n    case 22: \n#line 99 \"hex_grammar.y\" \n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1053 \"hex_grammar.c\" \n        break;\n    case 23: \n#line 98 \"hex_grammar.y\" \n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1059 \"hex_grammar.c\" \n        break;\n      default:\n        break;\n    }", "target": 1}
{"code": "gopherMimeCreate(GopherStateData * gopherState)\n{\n    StoreEntry *entry = gopherState->entry;\n    const char *mime_type = nullptr;\n    const char *mime_enc = nullptr;\n    switch (gopherState->type_id) {\n    case GOPHER_DIRECTORY:\n    case GOPHER_INDEX:\n    case GOPHER_HTML:\n    case GOPHER_WWW:\n    case GOPHER_CSO:\n        mime_type = \"text/html\";\n        break;\n    case GOPHER_GIF:\n    case GOPHER_IMAGE:\n    case GOPHER_PLUS_IMAGE:\n        mime_type = \"image/gif\";\n        break;\n    case GOPHER_SOUND:\n    case GOPHER_PLUS_SOUND:\n        mime_type = \"audio/basic\";\n        break;\n    case GOPHER_PLUS_MOVIE:\n        mime_type = \"video/mpeg\";\n        break;\n    case GOPHER_MACBINHEX:\n    case GOPHER_DOSBIN:\n    case GOPHER_UUENCODED:\n    case GOPHER_BIN:\n        mime_enc = mimeGetContentEncoding(gopherState->request);\n        mime_type = mimeGetContentType(gopherState->request);\n        if (!mime_type)\n            mime_type = def_gopher_bin;\n        break;\n    case GOPHER_FILE:\n    default:\n        mime_enc = mimeGetContentEncoding(gopherState->request);\n        mime_type = mimeGetContentType(gopherState->request);\n        if (!mime_type)\n            mime_type = def_gopher_text;\n        break;\n    }\n    assert(entry->isEmpty());\n    HttpReply *reply = new HttpReply;\n    entry->buffer();\n    reply->setHeaders(Http::scOkay, \"Gatewaying\", mime_type, -1, -1, -2);\n    if (mime_enc)\n        reply->header.putStr(Http::HdrType::CONTENT_ENCODING, mime_enc);\n    entry->replaceHttpReply(reply);\n    gopherState->reply_ = reply;\n}", "target": 1}
{"code": "void unlink_anon_vmas(struct vm_area_struct *vma)\n{\n\tstruct anon_vma_chain *avc, *next;\n\tstruct anon_vma *root = NULL;\n\tlist_for_each_entry_safe(avc, next, &vma->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma = avc->anon_vma;\n\t\troot = lock_anon_vma_root(root, anon_vma);\n\t\tanon_vma_interval_tree_remove(avc, &anon_vma->rb_root);\n\t\tif (RB_EMPTY_ROOT(&anon_vma->rb_root.rb_root)) {\n\t\t\tanon_vma->parent->degree--;\n\t\t\tcontinue;\n\t\t}\n\t\tlist_del(&avc->same_vma);\n\t\tanon_vma_chain_free(avc);\n\t}\n\tif (vma->anon_vma) {\n\t\tvma->anon_vma->degree--;\n\t\tvma->anon_vma = NULL;\n\t}\n\tunlock_anon_vma_root(root);\n\tlist_for_each_entry_safe(avc, next, &vma->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma = avc->anon_vma;\n\t\tVM_WARN_ON(anon_vma->degree);\n\t\tput_anon_vma(anon_vma);\n\t\tlist_del(&avc->same_vma);\n\t\tanon_vma_chain_free(avc);\n\t}\n}", "target": 1}
{"code": "static int validate_user_key(struct fscrypt_info *crypt_info,\n\t\t\tstruct fscrypt_context *ctx, u8 *raw_key,\n\t\t\tconst char *prefix)\n{\n\tchar *description;\n\tstruct key *keyring_key;\n\tstruct fscrypt_key *master_key;\n\tconst struct user_key_payload *ukp;\n\tint res;\n\tdescription = kasprintf(GFP_NOFS, \"%s%*phN\", prefix,\n\t\t\t\tFS_KEY_DESCRIPTOR_SIZE,\n\t\t\t\tctx->master_key_descriptor);\n\tif (!description)\n\t\treturn -ENOMEM;\n\tkeyring_key = request_key(&key_type_logon, description, NULL);\n\tkfree(description);\n\tif (IS_ERR(keyring_key))\n\t\treturn PTR_ERR(keyring_key);\n\tif (keyring_key->type != &key_type_logon) {\n\t\tprintk_once(KERN_WARNING\n\t\t\t\t\"%s: key type must be logon\\n\", __func__);\n\t\tres = -ENOKEY;\n\t\tgoto out;\n\t}\n\tdown_read(&keyring_key->sem);\n\tukp = user_key_payload(keyring_key);\n\tif (ukp->datalen != sizeof(struct fscrypt_key)) {\n\t\tres = -EINVAL;\n\t\tup_read(&keyring_key->sem);\n\t\tgoto out;\n\t}\n\tmaster_key = (struct fscrypt_key *)ukp->data;\n\tBUILD_BUG_ON(FS_AES_128_ECB_KEY_SIZE != FS_KEY_DERIVATION_NONCE_SIZE);\n\tif (master_key->size != FS_AES_256_XTS_KEY_SIZE) {\n\t\tprintk_once(KERN_WARNING\n\t\t\t\t\"%s: key size incorrect: %d\\n\",\n\t\t\t\t__func__, master_key->size);\n\t\tres = -ENOKEY;\n\t\tup_read(&keyring_key->sem);\n\t\tgoto out;\n\t}\n\tres = derive_key_aes(ctx->nonce, master_key->raw, raw_key);\n\tup_read(&keyring_key->sem);\n\tif (res)\n\t\tgoto out;\n\tcrypt_info->ci_keyring_key = keyring_key;\n\treturn 0;\nout:\n\tkey_put(keyring_key);\n\treturn res;\n}", "target": 1}
{"code": "juniper_atm2_print(netdissect_options *ndo,\n                   const struct pcap_pkthdr *h, register const u_char *p)\n{\n        int llc_hdrlen;\n        struct juniper_l2info_t l2info;\n        l2info.pictype = DLT_JUNIPER_ATM2;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n        p+=l2info.header_len;\n        if (l2info.cookie[7] & ATM2_PKT_TYPE_MASK) { \n            oam_print(ndo, p, l2info.length, ATM_OAM_NOHEC);\n            return l2info.header_len;\n        }\n        if (EXTRACT_24BITS(p) == 0xfefe03 || \n            EXTRACT_24BITS(p) == 0xaaaa03) { \n            llc_hdrlen = llc_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL);\n            if (llc_hdrlen > 0)\n                return l2info.header_len;\n        }\n        if (l2info.direction != JUNIPER_BPF_PKT_IN && \n            (EXTRACT_32BITS(l2info.cookie) & ATM2_GAP_COUNT_MASK)) {\n            ether_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL);\n            return l2info.header_len;\n        }\n        if (p[0] == 0x03) { \n            isoclns_print(ndo, p + 1, l2info.length - 1, l2info.caplen - 1);\n            return l2info.header_len;\n        }\n        if(juniper_ppp_heuristic_guess(ndo, p, l2info.length) != 0) \n            return l2info.header_len;\n        if (ip_heuristic_guess(ndo, p, l2info.length) != 0) \n            return l2info.header_len;\n\treturn l2info.header_len;\n}", "target": 1}
{"code": "int32_t *enc_untrusted_create_wait_queue() {\n  MessageWriter input;\n  MessageReader output;\n  input.Push<uint64_t>(sizeof(int32_t));\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kLocalLifetimeAllocHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_create_wait_queue\",\n                           2);\n  int32_t *queue = reinterpret_cast<int32_t *>(output.next<uintptr_t>());\n  if (!TrustedPrimitives::IsOutsideEnclave(queue, sizeof(int32_t))) {\n    TrustedPrimitives::BestEffortAbort(\n        \"enc_untrusted_create_wait_queue: queue should be in untrusted memory\");\n  }\n  int klinux_errno = output.next<int>();\n  if (queue == nullptr) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n  }\n  enc_untrusted_disable_waiting(queue);\n  return queue;\n}", "target": 0}
{"code": "static int do_new_mount(struct path *path, const char *fstype, int flags,\n\t\t\tint mnt_flags, const char *name, void *data)\n{\n\tstruct file_system_type *type;\n\tstruct user_namespace *user_ns = current->nsproxy->mnt_ns->user_ns;\n\tstruct vfsmount *mnt;\n\tint err;\n\tif (!fstype)\n\t\treturn -EINVAL;\n\ttype = get_fs_type(fstype);\n\tif (!type)\n\t\treturn -ENODEV;\n\tif (user_ns != &init_user_ns) {\n\t\tif (!(type->fs_flags & FS_USERNS_MOUNT)) {\n\t\t\tput_filesystem(type);\n\t\t\treturn -EPERM;\n\t\t}\n\t\tif (!(type->fs_flags & FS_USERNS_DEV_MOUNT)) {\n\t\t\tflags |= MS_NODEV;\n\t\t\tmnt_flags |= MNT_NODEV;\n\t\t}\n\t}\n\tmnt = vfs_kern_mount(type, flags, name, data);\n\tif (!IS_ERR(mnt) && (type->fs_flags & FS_HAS_SUBTYPE) &&\n\t    !mnt->mnt_sb->s_subtype)\n\t\tmnt = fs_set_subtype(mnt, fstype);\n\tput_filesystem(type);\n\tif (IS_ERR(mnt))\n\t\treturn PTR_ERR(mnt);\n\terr = do_add_mount(real_mount(mnt), path, mnt_flags);\n\tif (err)\n\t\tmntput(mnt);\n\treturn err;\n}", "target": 1}
{"code": "const char *string_of_NPNVariable(int variable)\n{\n  const char *str;\n  switch (variable) {\n#define _(VAL) case VAL: str = #VAL; break;\n\t_(NPNVxDisplay);\n\t_(NPNVxtAppContext);\n\t_(NPNVnetscapeWindow);\n\t_(NPNVjavascriptEnabledBool);\n\t_(NPNVasdEnabledBool);\n\t_(NPNVisOfflineBool);\n\t_(NPNVserviceManager);\n\t_(NPNVDOMElement);\n\t_(NPNVDOMWindow);\n\t_(NPNVToolkit);\n\t_(NPNVSupportsXEmbedBool);\n\t_(NPNVWindowNPObject);\n\t_(NPNVPluginElementNPObject);\n\t_(NPNVSupportsWindowless);\n\t_(NPNVprivateModeBool);\n\t_(NPNVsupportsAdvancedKeyHandling);\n#undef _\n  default:\n\tswitch (variable & 0xff) {\n#define _(VAL, VAR) case VAL: str = #VAR; break\n\t  _(10, NPNVserviceManager);\n\t  _(11, NPNVDOMElement);\n\t  _(12, NPNVDOMWindow);\n\t  _(13, NPNVToolkit);\n#undef _\n\tdefault:\n\t  str = \"<unknown variable>\";\n\t  break;\n\t}\n\tbreak;\n  }\n  return str;\n}", "target": 0}
{"code": "  void Clear() {\n    size_ = 0;\n    SetOffset(0);\n  }", "target": 0}
{"code": "bool LIRGenerator::can_store_as_constant(Value v, BasicType type) const {\n  if (type == T_SHORT || type == T_CHAR) {\n    return false;\n  }\n  Constant* c = v->as_Constant();\n  if (c && c->state_before() == NULL) {\n    return true;\n  }\n  return false;\n}", "target": 0}
{"code": "static int netbk_count_requests(struct xenvif *vif,\n\t\t\t\tstruct xen_netif_tx_request *first,\n\t\t\t\tstruct xen_netif_tx_request *txp,\n\t\t\t\tint work_to_do)\n{\n\tRING_IDX cons = vif->tx.req_cons;\n\tint frags = 0;\n\tif (!(first->flags & XEN_NETTXF_more_data))\n\t\treturn 0;\n\tdo {\n\t\tif (frags >= work_to_do) {\n\t\t\tnetdev_dbg(vif->dev, \"Need more frags\\n\");\n\t\t\treturn -frags;\n\t\t}\n\t\tif (unlikely(frags >= MAX_SKB_FRAGS)) {\n\t\t\tnetdev_dbg(vif->dev, \"Too many frags\\n\");\n\t\t\treturn -frags;\n\t\t}\n\t\tmemcpy(txp, RING_GET_REQUEST(&vif->tx, cons + frags),\n\t\t       sizeof(*txp));\n\t\tif (txp->size > first->size) {\n\t\t\tnetdev_dbg(vif->dev, \"Frags galore\\n\");\n\t\t\treturn -frags;\n\t\t}\n\t\tfirst->size -= txp->size;\n\t\tfrags++;\n\t\tif (unlikely((txp->offset + txp->size) > PAGE_SIZE)) {\n\t\t\tnetdev_dbg(vif->dev, \"txp->offset: %x, size: %u\\n\",\n\t\t\t\t txp->offset, txp->size);\n\t\t\treturn -frags;\n\t\t}\n\t} while ((txp++)->flags & XEN_NETTXF_more_data);\n\treturn frags;\n}", "target": 1}
{"code": "writefile(const char *name, struct string *s)\n{\n\tFILE *f;\n\tint ret;\n\tf = fopen(name, \"w\");\n\tif (!f) {\n\t\twarn(\"open %s:\", name);\n\t\treturn -1;\n\t}\n\tret = 0;\n\tif (fwrite(s->s, 1, s->n, f) != s->n || fflush(f) != 0) {\n\t\twarn(\"write %s:\", name);\n\t\tret = -1;\n\t}\n\tfclose(f);\n\treturn ret;\n}", "target": 1}
{"code": "DEFINE_TEST(test_read_format_mtree_crash747)\n{\n\tconst char *reffile = \"test_read_format_mtree_crash747.mtree.bz2\";\n\tstruct archive *a;\n\textract_reference_file(reffile);\n\tassert((a = archive_read_new()) != NULL);\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_support_filter_bzip2(a));\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_support_format_mtree(a));\n\tassertEqualIntA(a, ARCHIVE_FATAL, archive_read_open_filename(a, reffile, 10240));\n\tassertEqualInt(ARCHIVE_OK, archive_read_free(a));\n}", "target": 0}
{"code": "void setrangeCommand(client *c) {\n    robj *o;\n    long offset;\n    sds value = c->argv[3]->ptr;\n    if (getLongFromObjectOrReply(c,c->argv[2],&offset,NULL) != C_OK)\n        return;\n    if (offset < 0) {\n        addReplyError(c,\"offset is out of range\");\n        return;\n    }\n    o = lookupKeyWrite(c->db,c->argv[1]);\n    if (o == NULL) {\n        if (sdslen(value) == 0) {\n            addReply(c,shared.czero);\n            return;\n        }\n        if (checkStringLength(c,offset+sdslen(value)) != C_OK)\n            return;\n        o = createObject(OBJ_STRING,sdsnewlen(NULL, offset+sdslen(value)));\n        dbAdd(c->db,c->argv[1],o);\n    } else {\n        size_t olen;\n        if (checkType(c,o,OBJ_STRING))\n            return;\n        olen = stringObjectLen(o);\n        if (sdslen(value) == 0) {\n            addReplyLongLong(c,olen);\n            return;\n        }\n        if (checkStringLength(c,offset+sdslen(value)) != C_OK)\n            return;\n        o = dbUnshareStringValue(c->db,c->argv[1],o);\n    }\n    if (sdslen(value) > 0) {\n        o->ptr = sdsgrowzero(o->ptr,offset+sdslen(value));\n        memcpy((char*)o->ptr+offset,value,sdslen(value));\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_STRING,\n            \"setrange\",c->argv[1],c->db->id);\n        server.dirty++;\n    }\n    addReplyLongLong(c,sdslen(o->ptr));\n}", "target": 1}
{"code": "_gnutls_x509_get_signature_algorithm(ASN1_TYPE src, const char *src_name)\n{\n\tint result;\n\tgnutls_datum_t sa;\n\tresult = _gnutls_x509_read_value(src, src_name, &sa);\n\tif (result < 0) {\n\t\tgnutls_assert();\n\t\treturn result;\n\t}\n\tresult = _gnutls_x509_oid2sign_algorithm((char *) sa.data);\n\t_gnutls_free_datum(&sa);\n\treturn result;\n}", "target": 0}
{"code": "void UpstreamRequest::onPerTryIdleTimeout() {\n  ENVOY_STREAM_LOG(debug, \"upstream per try idle timeout\", *parent_.callbacks());\n  if (per_try_timeout_) {\n    per_try_timeout_->disableTimer();\n  }\n  stream_info_.setResponseFlag(StreamInfo::CoreResponseFlag::StreamIdleTimeout);\n  parent_.onPerTryIdleTimeout(*this);\n}", "target": 0}
{"code": "wsemul_vt100_output_dcs(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tu_int newstate = VT100_EMUL_STATE_DCS;\n\tswitch (instate->inchar) {\n\tcase '0': case '1': case '2': case '3': case '4':\n\tcase '5': case '6': case '7': case '8': case '9':\n\t\tif (edp->nargs > VT100_EMUL_NARGS - 1)\n\t\t\tbreak;\n\t\tedp->args[edp->nargs] = (edp->args[edp->nargs] * 10) +\n\t\t    (instate->inchar - '0');\n\t\tbreak;\n\tcase ';': \n\t\tedp->nargs++;\n\t\tbreak;\n\tdefault:\n\t\tedp->nargs++;\n\t\tif (edp->nargs > VT100_EMUL_NARGS) {\n#ifdef VT100_DEBUG\n\t\t\tprintf(\"vt100: too many arguments\\n\");\n#endif\n\t\t\tedp->nargs = VT100_EMUL_NARGS;\n\t\t}\n\t\tnewstate = VT100_EMUL_STATE_STRING;\n\t\tswitch (instate->inchar) {\n\t\tcase '$':\n\t\t\tnewstate = VT100_EMUL_STATE_DCS_DOLLAR;\n\t\t\tbreak;\n\t\tcase '{': \t\n\t\tcase '!': \n\t\tcase '|': \n#ifdef VT100_PRINTNOTIMPL\n\t\t\tprintf(\"DCS%c ignored\\n\", (char)instate->inchar);\n#endif\n\t\t\tbreak;\n\t\tdefault:\n#ifdef VT100_PRINTUNKNOWN\n\t\t\tprintf(\"DCS %x (%d, %d) unknown\\n\", instate->inchar,\n\t\t\t    ARG(0), ARG(1));\n#endif\n\t\t\tbreak;\n\t\t}\n\t}\n\tedp->state = newstate;\n\treturn 0;\n}", "target": 1}
{"code": "void release_dentry_name_snapshot(struct name_snapshot *name)\n{\n\tif (unlikely(name->name != name->inline_name)) {\n\t\tstruct external_name *p;\n\t\tp = container_of(name->name, struct external_name, name[0]);\n\t\tif (unlikely(atomic_dec_and_test(&p->u.count)))\n\t\t\tkfree_rcu(p, u.head);\n\t}\n}", "target": 0}
{"code": "njs_promise_perform_all_handler(njs_vm_t *vm, njs_iterator_args_t *args,\n    njs_value_t *value, int64_t index)\n{\n    njs_int_t                    ret;\n    njs_array_t                  *array;\n    njs_value_t                  arguments[2], next;\n    njs_function_t               *on_fulfilled;\n    njs_promise_capability_t     *capability;\n    njs_promise_all_context_t    *context;\n    njs_promise_iterator_args_t  *pargs;\n    if (!njs_is_valid(value)) {\n        value = njs_value_arg(&njs_value_undefined);\n    }\n    pargs = (njs_promise_iterator_args_t *) args;\n    capability = pargs->capability;\n    array = args->data;\n    njs_set_undefined(&array->start[index]);\n    ret = njs_function_call(vm, pargs->function, pargs->constructor, value,\n                            1, &next);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n    on_fulfilled = njs_promise_create_function(vm,\n                                            sizeof(njs_promise_all_context_t));\n    if (njs_slow_path(on_fulfilled == NULL)) {\n        return NJS_ERROR;\n    }\n    on_fulfilled->u.native = njs_promise_all_resolve_element_functions;\n    on_fulfilled->args_count = 1;\n    context = on_fulfilled->context;\n    context->already_called = 0;\n    context->index = (uint32_t) index;\n    context->values = pargs->args.data;\n    context->capability = capability;\n    context->remaining_elements = pargs->remaining;\n    (*pargs->remaining)++;\n    njs_set_function(&arguments[0], on_fulfilled);\n    arguments[1] = capability->reject;\n    ret = njs_promise_invoke_then(vm, &next, arguments, 2);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n    return NJS_OK;\n}", "target": 0}
{"code": "juniper_mlppp_print(netdissect_options *ndo,\n                    const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n        l2info.pictype = DLT_JUNIPER_MLPPP;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n        if (ndo->ndo_eflag &&\n            EXTRACT_16BITS(&l2info.cookie) != PPP_OSI &&\n            EXTRACT_16BITS(&l2info.cookie) !=  (PPP_ADDRESS << 8 | PPP_CONTROL))\n            ND_PRINT((ndo, \"Bundle-ID %u: \", l2info.bundle));\n        p+=l2info.header_len;\n        switch(l2info.proto) {\n        case JUNIPER_LSQ_L3_PROTO_IPV4:\n            if (l2info.cookie[4] == (JUNIPER_LSQ_COOKIE_RE|JUNIPER_LSQ_COOKIE_DIR))\n                ppp_print(ndo, p, l2info.length);\n            else\n                ip_print(ndo, p, l2info.length);\n            return l2info.header_len;\n        case JUNIPER_LSQ_L3_PROTO_IPV6:\n            ip6_print(ndo, p,l2info.length);\n            return l2info.header_len;\n        case JUNIPER_LSQ_L3_PROTO_MPLS:\n            mpls_print(ndo, p, l2info.length);\n            return l2info.header_len;\n        case JUNIPER_LSQ_L3_PROTO_ISO:\n            isoclns_print(ndo, p, l2info.length, l2info.caplen);\n            return l2info.header_len;\n        default:\n            break;\n        }\n        switch (EXTRACT_16BITS(&l2info.cookie)) {\n        case PPP_OSI:\n            ppp_print(ndo, p - 2, l2info.length + 2);\n            break;\n        case (PPP_ADDRESS << 8 | PPP_CONTROL): \n        default:\n            ppp_print(ndo, p, l2info.length);\n            break;\n        }\n        return l2info.header_len;\n}", "target": 1}
{"code": "AtomicString SrcSchemeToURL(TestURLScheme scheme) {\n  switch (scheme) {\n    case TestURLScheme::kHttp:\n      return \"http:\n    case TestURLScheme::kHttps:\n      return \"https:\n    case TestURLScheme::kFtp:\n      return \"ftp:\n    case TestURLScheme::kFile:\n      return \"file:\n    case TestURLScheme::kData:\n      return \"data:video/mp4;base64,XXXXXXX\";\n    case TestURLScheme::kBlob:\n      return \"blob:http:\n    default:\n      NOTREACHED();\n  }\n  return g_empty_atom;\n}", "target": 0}
{"code": "bool RootWindow::DispatchTouchEvent(TouchEvent* event) {\n  DispatchHeldMouseMove();\n  if (ui::IsDIPEnabled()) {\n    float scale = ui::GetDeviceScaleFactor(layer());\n    ui::Transform transform = layer()->transform();\n    transform.ConcatScale(scale, scale);\n    event->UpdateForRootTransform(transform);\n  } else {\n    event->UpdateForRootTransform(layer()->transform());\n  }\n  bool handled = false;\n  ui::TouchStatus status = ui::TOUCH_STATUS_UNKNOWN;\n  Window* target = capture_window_;\n  if (!target) {\n    target = ConsumerToWindow(\n        gesture_recognizer_->GetTouchLockedTarget(event));\n    if (!target) {\n      target = ConsumerToWindow(\n          gesture_recognizer_->GetTargetForLocation(event->GetLocation()));\n    }\n  }\n  if (!target && !bounds().Contains(event->location())) {\n    target = this;\n  } else {\n    if (!target) {\n      target = GetEventHandlerForPoint(event->location());\n      if (!target)\n        return false;\n    }\n    TouchEvent translated_event(*event, this, target);\n    status = ProcessTouchEvent(target, &translated_event);\n    handled = status != ui::TOUCH_STATUS_UNKNOWN;\n    if (status == ui::TOUCH_STATUS_QUEUED ||\n        status == ui::TOUCH_STATUS_QUEUED_END)\n      gesture_recognizer_->QueueTouchEventForGesture(target, *event);\n  }\n  scoped_ptr<ui::GestureRecognizer::Gestures> gestures;\n  gestures.reset(gesture_recognizer_->ProcessTouchEventForGesture(\n      *event, status, target));\n  return ProcessGestures(gestures.get()) ? true : handled;\n}", "target": 0}
{"code": "GF_Box *emsg_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_EventMessageBox, GF_ISOM_BOX_TYPE_EMSG);\n\treturn (GF_Box *)tmp;\n}", "target": 0}
{"code": "buffer_add_range(int fd, struct evbuffer *evb, struct range *range)\n{\n\tchar\tbuf[BUFSIZ];\n\tsize_t\tn, range_sz;\n\tssize_t\tnread;\n\tif (lseek(fd, range->start, SEEK_SET) == -1)\n\t\treturn (0);\n\trange_sz = range->end - range->start + 1;\n\twhile (range_sz) {\n\t\tn = MINIMUM(range_sz, sizeof(buf));\n\t\tif ((nread = read(fd, buf, n)) == -1)\n\t\t\treturn (0);\n\t\tevbuffer_add(evb, buf, nread);\n\t\trange_sz -= nread;\n\t}\n\treturn (1);\n}", "target": 1}
{"code": "otError Commissioner::AddJoiner(const Mac::ExtAddress *aEui64, const char *aPskd, uint32_t aTimeout)\n{\n    otError error = OT_ERROR_NO_BUFS;\n    VerifyOrExit(mState == OT_COMMISSIONER_STATE_ACTIVE, error = OT_ERROR_INVALID_STATE);\n    VerifyOrExit(strlen(aPskd) <= Dtls::kPskMaxLength, error = OT_ERROR_INVALID_ARGS);\n    RemoveJoiner(aEui64, 0); \n    for (Joiner *joiner = &mJoiners[0]; joiner < OT_ARRAY_END(mJoiners); joiner++)\n    {\n        if (joiner->mValid)\n        {\n            continue;\n        }\n        if (aEui64 != NULL)\n        {\n            joiner->mEui64 = *aEui64;\n            joiner->mAny   = false;\n        }\n        else\n        {\n            joiner->mAny = true;\n        }\n        (void)strlcpy(joiner->mPsk, aPskd, sizeof(joiner->mPsk));\n        joiner->mValid          = true;\n        joiner->mExpirationTime = TimerMilli::GetNow() + Time::SecToMsec(aTimeout);\n        UpdateJoinerExpirationTimer();\n        SendCommissionerSet();\n        otLogInfoMeshCoP(\"Added Joiner (%s, %s)\", (aEui64 != NULL) ? aEui64->ToString().AsCString() : \"*\", aPskd);\n        ExitNow(error = OT_ERROR_NONE);\n    }\nexit:\n    return error;\n}", "target": 1}
{"code": "static bool vtable_is_value_in_text_section(RVTableContext *context, ut64 curAddress, ut64 *value) {\n\tut64 curAddressValue;\n\tif (!context->read_addr (context->anal, curAddress, &curAddressValue)) {\n\t\treturn false;\n\t}\n\tbool ret = vtable_addr_in_text_section (context, curAddressValue);\n\tif (value) {\n\t\t*value = curAddressValue;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "sudo_passwd_verify(const struct sudoers_context *ctx, struct passwd *pw,\n    const char *pass, sudo_auth *auth, struct sudo_conv_callback *callback)\n{\n    char des_pass[9], *epass;\n    char *pw_epasswd = auth->data;\n    size_t pw_len;\n    int matched = 0;\n    debug_decl(sudo_passwd_verify, SUDOERS_DEBUG_AUTH);\n    if (pass[0] == '\\0')\n\tdebug_return_int(pw_epasswd[0] ? AUTH_FAILURE : AUTH_SUCCESS);\n    pw_len = strlen(pw_epasswd);\n    if (pw_len == DESLEN || HAS_AGEINFO(pw_epasswd, pw_len)) {\n\tstrlcpy(des_pass, pass, sizeof(des_pass));\n\tpass = des_pass;\n    }\n    epass = (char *) crypt(pass, pw_epasswd);\n    if (epass != NULL) {\n\tif (HAS_AGEINFO(pw_epasswd, pw_len) && strlen(epass) == DESLEN)\n\t    matched = !strncmp(pw_epasswd, epass, DESLEN);\n\telse\n\t    matched = !strcmp(pw_epasswd, epass);\n    }\n    explicit_bzero(des_pass, sizeof(des_pass));\n    debug_return_int(matched ? AUTH_SUCCESS : AUTH_FAILURE);\n}", "target": 1}
{"code": "int http_parse_cont_len_header(struct ist *value, unsigned long long *body_len,\n                               int not_first)\n{\n\tchar *e, *n;\n\tunsigned long long cl;\n\tstruct ist word;\n\tint check_prev = not_first;\n\tword.ptr = value->ptr - 1; \n\te = value->ptr + value->len;\n\twhile (++word.ptr < e) {\n\t\tif (unlikely(HTTP_IS_LWS(*word.ptr)))\n\t\t\tcontinue;\n\t\tfor (cl = 0, n = word.ptr; n < e; n++) {\n\t\t\tunsigned int c = *n - '0';\n\t\t\tif (unlikely(c > 9)) {\n\t\t\t\tif (unlikely(n == word.ptr)) \n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (unlikely(cl > ULLONG_MAX / 10ULL))\n\t\t\t\tgoto fail; \n\t\t\tcl = cl * 10ULL;\n\t\t\tif (unlikely(cl + c < cl))\n\t\t\t\tgoto fail; \n\t\t\tcl = cl + c;\n\t\t}\n\t\tword.len = n - word.ptr;\n\t\tfor (; n < e; n++) {\n\t\t\tif (!HTTP_IS_LWS(*n)) {\n\t\t\t\tif (unlikely(*n != ','))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (check_prev && cl != *body_len)\n\t\t\tgoto fail;\n\t\t*body_len = cl;\n\t\t*value = word;\n\t\tword.ptr = n;\n\t\tcheck_prev = 1;\n\t}\n\treturn !not_first;\n fail:\n\treturn -1;\n}", "target": 1}
{"code": "static int empty_write_end(struct page *page, unsigned from,\n\t\t\t   unsigned to, int mode)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct buffer_head *bh;\n\tunsigned offset, blksize = 1 << inode->i_blkbits;\n\tpgoff_t end_index = i_size_read(inode) >> PAGE_CACHE_SHIFT;\n\tzero_user(page, from, to-from);\n\tmark_page_accessed(page);\n\tif (page->index < end_index || !(mode & FALLOC_FL_KEEP_SIZE)) {\n\t\tif (!gfs2_is_writeback(ip))\n\t\t\tgfs2_page_add_databufs(ip, page, from, to);\n\t\tblock_commit_write(page, from, to);\n\t\treturn 0;\n\t}\n\toffset = 0;\n\tbh = page_buffers(page);\n\twhile (offset < to) {\n\t\tif (offset >= from) {\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tclear_buffer_new(bh);\n\t\t\twrite_dirty_buffer(bh, WRITE);\n\t\t}\n\t\toffset += blksize;\n\t\tbh = bh->b_this_page;\n\t}\n\toffset = 0;\n\tbh = page_buffers(page);\n\twhile (offset < to) {\n\t\tif (offset >= from) {\n\t\t\twait_on_buffer(bh);\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\treturn -EIO;\n\t\t}\n\t\toffset += blksize;\n\t\tbh = bh->b_this_page;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "ia64_patch_rse (unsigned long start, unsigned long end)\n{\n\ts32 *offp = (s32 *) start;\n\tu64 ip, *b;\n\twhile (offp < (s32 *) end) {\n\t\tip = (u64) offp + *offp;\n\t\tb = (u64 *)(ip & -16);\n\t\tb[1] &= ~0xf800000L;\n\t\tia64_fc((void *) ip);\n\t\t++offp;\n\t}\n\tia64_sync_i();\n\tia64_srlz_i();\n}", "target": 0}
{"code": "ExprResolveGroup(struct xkb_context *ctx, const ExprDef *expr,\n                 xkb_layout_index_t *group_rtrn)\n{\n    bool ok;\n    int result;\n    ok = ExprResolveIntegerLookup(ctx, expr, &result, SimpleLookup,\n                                  groupNames);\n    if (!ok)\n        return false;\n    if (result <= 0 || result > XKB_MAX_GROUPS) {\n        log_err(ctx, \"Group index %u is out of range (1..%d)\\n\",\n                result, XKB_MAX_GROUPS);\n        return false;\n    }\n    *group_rtrn = (xkb_layout_index_t) result;\n    return true;\n}", "target": 0}
{"code": "static int decode_dds1(GetByteContext *gb, uint8_t *frame, int width, int height)\n{\n    const uint8_t *frame_start = frame;\n    const uint8_t *frame_end   = frame + width * height;\n    int mask = 0x10000, bitbuf = 0;\n    int i, v, offset, count, segments;\n    segments = bytestream2_get_le16(gb);\n    while (segments--) {\n        if (bytestream2_get_bytes_left(gb) < 2)\n            return AVERROR_INVALIDDATA;\n        if (mask == 0x10000) {\n            bitbuf = bytestream2_get_le16u(gb);\n            mask = 1;\n        }\n        if (bitbuf & mask) {\n            v = bytestream2_get_le16(gb);\n            offset = (v & 0x1FFF) << 2;\n            count = ((v >> 13) + 2) << 1;\n            if (frame - frame_start < offset || frame_end - frame < count*2 + width)\n                return AVERROR_INVALIDDATA;\n            for (i = 0; i < count; i++) {\n                frame[0] = frame[1] =\n                frame[width] = frame[width + 1] = frame[-offset];\n                frame += 2;\n            }\n        } else if (bitbuf & (mask << 1)) {\n            v = bytestream2_get_le16(gb)*2;\n            if (frame - frame_end < v)\n                return AVERROR_INVALIDDATA;\n            frame += v;\n        } else {\n            if (frame_end - frame < width + 3)\n                return AVERROR_INVALIDDATA;\n            frame[0] = frame[1] =\n            frame[width] = frame[width + 1] =  bytestream2_get_byte(gb);\n            frame += 2;\n            frame[0] = frame[1] =\n            frame[width] = frame[width + 1] =  bytestream2_get_byte(gb);\n            frame += 2;\n        }\n        mask <<= 2;\n    }\n    return 0;\n}", "target": 1}
{"code": "static int parse_import_ptr(struct MACH0_(obj_t)* bin, struct reloc_t *reloc, int idx) {\n\tint i, j, sym, wordsize;\n\tut32 stype;\n\twordsize = MACH0_(get_bits)(bin) / 8;\n\tif (idx < 0 || idx >= bin->nsymtab) {\n\t\treturn 0;\n\t}\n\tif ((bin->symtab[idx].n_desc & REFERENCE_TYPE) == REFERENCE_FLAG_UNDEFINED_LAZY) {\n\t\tstype = S_LAZY_SYMBOL_POINTERS;\n\t} else {\n\t\tstype = S_NON_LAZY_SYMBOL_POINTERS;\n\t}\n\treloc->offset = 0;\n\treloc->addr = 0;\n\treloc->addend = 0;\n#define CASE(T) case (T / 8): reloc->type = R_BIN_RELOC_ ## T; break\n\tswitch (wordsize) {\n\t\tCASE(8);\n\t\tCASE(16);\n\t\tCASE(32);\n\t\tCASE(64);\n\t\tdefault: return false;\n\t}\n#undef CASE\n\tfor (i = 0; i < bin->nsects; i++) {\n\t\tif ((bin->sects[i].flags & SECTION_TYPE) == stype) {\n\t\t\tfor (j=0, sym=-1; bin->sects[i].reserved1+j < bin->nindirectsyms; j++)\n\t\t\t\tif (idx == bin->indirectsyms[bin->sects[i].reserved1 + j]) {\n\t\t\t\t\tsym = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\treloc->offset = sym == -1 ? 0 : bin->sects[i].offset + sym * wordsize;\n\t\t\treloc->addr = sym == -1 ? 0 : bin->sects[i].addr + sym * wordsize;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "target": 1}
{"code": "static int crypto_aead_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_aead raead;\n\tstruct aead_alg *aead = &alg->cra_aead;\n\tsnprintf(raead.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"aead\");\n\tsnprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, \"%s\",\n\t\t aead->geniv ?: \"<built-in>\");\n\traead.blocksize = alg->cra_blocksize;\n\traead.maxauthsize = aead->maxauthsize;\n\traead.ivsize = aead->ivsize;\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_AEAD,\n\t\t    sizeof(struct crypto_report_aead), &raead))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "static void nfs4_open_confirm_release(void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\tstruct nfs4_state *state = NULL;\n\tif (data->cancelled == 0)\n\t\tgoto out_free;\n\tif (!data->rpc_done)\n\t\tgoto out_free;\n\tstate = nfs4_opendata_to_nfs4_state(data);\n\tif (!IS_ERR(state))\n\t\tnfs4_close_state(&data->path, state, data->o_arg.open_flags);\nout_free:\n\tnfs4_opendata_put(data);\n}", "target": 1}
{"code": "soup_server_new (const char *optname1, ...)\n{\n\tSoupServer *server;\n\tva_list ap;\n\tva_start (ap, optname1);\n\tserver = (SoupServer *)g_object_new_valist (SOUP_TYPE_SERVER,\n\t\t\t\t\t\t    optname1, ap);\n\tva_end (ap);\n\treturn server;\n}", "target": 0}
{"code": "static void free_todo_entries(TodoEntry **todos) {\n        for (TodoEntry *x = *todos; x && x->dir; x++) {\n                closedir(x->dir);\n                free(x->dirname);\n        }\n        freep(todos);\n}", "target": 0}
{"code": "static inline int pmd_none_or_trans_huge_or_clear_bad(pmd_t *pmd)\n{\n\tpmd_t pmdval = pmd_read_atomic(pmd);\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tbarrier();\n#endif\n\tif (pmd_none(pmdval))\n\t\treturn 1;\n\tif (unlikely(pmd_bad(pmdval))) {\n\t\tif (!pmd_trans_huge(pmdval))\n\t\t\tpmd_clear_bad(pmd);\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static const char* ConvertOneFloat(PyObject* v, T* out) {\n  if (PyErr_Occurred()) {\n    return nullptr;\n  }\n  if (TF_PREDICT_TRUE(PyFloat_Check(v))) {\n    const double as_double = PyFloat_AS_DOUBLE(v);\n    *out = static_cast<T>(as_double);\n    if (TF_PREDICT_FALSE(sizeof(T) < sizeof(double) && std::isinf(*out) &&\n                         std::isfinite(as_double))) {\n      return ErrorOutOfRangeDouble;\n    }\n    return nullptr;\n  }\n#if PY_MAJOR_VERSION < 3\n  if (PyInt_Check(v)) {\n    *out = PyInt_AS_LONG(v);\n    return nullptr;\n  }\n#endif\n  if (PyLong_Check(v)) {\n    *out = PyLong_AsDouble(v);\n    if (PyErr_Occurred()) return ErrorOutOfRangeDouble;\n    return nullptr;\n  }\n  if (PyIsInstance(v, &PyFloatingArrType_Type)) {  \n    Safe_PyObjectPtr as_float = make_safe(PyNumber_Float(v));\n    if (PyErr_Occurred()) {\n      return nullptr;\n    }\n    return ConvertOneFloat<T>(as_float.get(), out);\n  }\n  if (PyIsInstance(v, &PyIntegerArrType_Type)) {  \n#if PY_MAJOR_VERSION < 3\n    Safe_PyObjectPtr as_int = make_safe(PyNumber_Int(v));\n#else\n    Safe_PyObjectPtr as_int = make_safe(PyNumber_Long(v));\n#endif\n    if (PyErr_Occurred()) {\n      return nullptr;\n    }\n    return ConvertOneFloat<T>(as_int.get(), out);\n  }\n  return ErrorMixedTypes;\n}", "target": 1}
{"code": "static OPJ_BOOL opj_j2k_write_sod(opj_j2k_t *p_j2k,\n                                  opj_tcd_t * p_tile_coder,\n                                  OPJ_BYTE * p_data,\n                                  OPJ_UINT32 * p_data_written,\n                                  OPJ_UINT32 p_total_data_size,\n                                  const opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager\n                                 )\n{\n    opj_codestream_info_t *l_cstr_info = 00;\n    OPJ_UINT32 l_remaining_data;\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n    OPJ_UNUSED(p_stream);\n    if (p_total_data_size < 4) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Not enough bytes in output buffer to write SOD marker\\n\");\n        return OPJ_FALSE;\n    }\n    opj_write_bytes(p_data, J2K_MS_SOD,\n                    2);                                 \n    p_data += 2;\n    l_remaining_data =  p_total_data_size - 4;\n    p_tile_coder->tp_num =\n        p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number ;\n    p_tile_coder->cur_tp_num =\n        p_j2k->m_specific_param.m_encoder.m_current_tile_part_number;\n#ifdef USE_JPWL\n    assert(0 && \"TODO\");\n#endif \n    if (p_j2k->m_specific_param.m_encoder.m_current_tile_part_number == 0) {\n        p_tile_coder->tcd_image->tiles->packno = 0;\n        if (l_cstr_info) {\n            l_cstr_info->packno = 0;\n        }\n    }\n    *p_data_written = 0;\n    if (! opj_tcd_encode_tile(p_tile_coder, p_j2k->m_current_tile_number, p_data,\n                              p_data_written, l_remaining_data, l_cstr_info,\n                              p_manager)) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Cannot encode tile\\n\");\n        return OPJ_FALSE;\n    }\n    *p_data_written += 2;\n    return OPJ_TRUE;\n}", "target": 0}
{"code": "void luaD_call (lua_State *L, StkId func, int nresults) {\n  lua_CFunction f;\n retry:\n  switch (ttypetag(s2v(func))) {\n    case LUA_VCCL:  \n      f = clCvalue(s2v(func))->f;\n      goto Cfunc;\n    case LUA_VLCF:  \n      f = fvalue(s2v(func));\n     Cfunc: {\n      int n;  \n      CallInfo *ci = next_ci(L);\n      checkstackp(L, LUA_MINSTACK, func);  \n      ci->nresults = nresults;\n      ci->callstatus = CIST_C;\n      ci->top = L->top + LUA_MINSTACK;\n      ci->func = func;\n      L->ci = ci;\n      lua_assert(ci->top <= L->stack_last);\n      if (L->hookmask & LUA_MASKCALL) {\n        int narg = cast_int(L->top - func) - 1;\n        luaD_hook(L, LUA_HOOKCALL, -1, 1, narg);\n      }\n      lua_unlock(L);\n      n = (*f)(L);  \n      lua_lock(L);\n      api_checknelems(L, n);\n      luaD_poscall(L, ci, n);\n      break;\n    }\n    case LUA_VLCL: {  \n      CallInfo *ci = next_ci(L);\n      Proto *p = clLvalue(s2v(func))->p;\n      int narg = cast_int(L->top - func) - 1;  \n      int nfixparams = p->numparams;\n      int fsize = p->maxstacksize;  \n      checkstackp(L, fsize, func);\n      ci->nresults = nresults;\n      ci->u.l.savedpc = p->code;  \n      ci->callstatus = 0;\n      ci->top = func + 1 + fsize;\n      ci->func = func;\n      L->ci = ci;\n      for (; narg < nfixparams; narg++)\n        setnilvalue(s2v(L->top++));  \n      lua_assert(ci->top <= L->stack_last);\n      luaV_execute(L, ci);  \n      break;\n    }\n    default: {  \n      checkstackp(L, 1, func);  \n      luaD_tryfuncTM(L, func);  \n      goto retry;  \n    }\n  }\n}", "target": 1}
{"code": "static std::wstring MB2WC(const std::string& input, unsigned int code_page) {\n  if (input.empty()) {\n    return L\"\";\n  }\n  int length = ::MultiByteToWideChar(code_page, 0, &input[0],\n                                     static_cast<int>(input.size()),\n                                     NULL, 0);\n  std::wstring output(length, '\\0');\n  ::MultiByteToWideChar(code_page, 0, &input[0], static_cast<int>(input.size()),\n                        &output[0], static_cast<int>(output.size()));\n  return output;\n}", "target": 0}
{"code": "void inet6_destroy_sock(struct sock *sk)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sk_buff *skb;\n\tstruct ipv6_txoptions *opt;\n\tskb = xchg(&np->pktoptions, NULL);\n\tif (skb)\n\t\tkfree_skb(skb);\n\tskb = xchg(&np->rxpmtu, NULL);\n\tif (skb)\n\t\tkfree_skb(skb);\n\tfl6_free_socklist(sk);\n\topt = xchg(&np->opt, NULL);\n\tif (opt)\n\t\tsock_kfree_s(sk, opt, opt->tot_len);\n}", "target": 1}
{"code": "static int setup_config(int type)\n{\n\tint rv;\n\trv = read_config(cl.configfile, type);\n\tif (rv < 0)\n\t\tgoto out;\n\tif (is_auth_req()) {\n\t\trv = read_authkey();\n\t\tif (rv < 0)\n\t\t\tgoto out;\n#if HAVE_LIBGCRYPT\n\t\tif (!gcry_check_version(NULL)) {\n\t\t\tlog_error(\"gcry_check_version\");\n\t\t\trv = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tgcry_control(GCRYCTL_DISABLE_SECMEM, 0);\n\t\tgcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0);\n#endif\n\t}\n\tif (cl.type == DAEMON && cl.site[0]) {\n\t\tif (!find_site_by_name(cl.site, &local, 1)) {\n\t\t\tlog_error(\"Cannot find \\\"%s\\\" in the configuration.\",\n\t\t\t\t\tcl.site);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlocal->local = 1;\n\t} else\n\t\tfind_myself(NULL, type == CLIENT || type == GEOSTORE);\n\trv = check_config(type);\n\tif (rv < 0)\n\t\tgoto out;\n\tif (!cl.lockfile[0]) {\n\t\tsnprintf(cl.lockfile, sizeof(cl.lockfile)-1,\n\t\t\t\t\"%s/%s.pid\", BOOTH_RUN_DIR, booth_conf->name);\n\t}\nout:\n\treturn rv;\n}", "target": 1}
{"code": "bool CSSStyleSheet::isLoading()\n{\n    unsigned len = length();\n    for (unsigned i = 0; i < len; ++i) {\n        StyleBase* rule = item(i);\n        if (rule->isImportRule() && static_cast<CSSImportRule*>(rule)->isLoading())\n            return true;\n    }\n    return false;\n}", "target": 0}
{"code": "static int irda_create(struct net *net, struct socket *sock, int protocol,\n\t\t       int kern)\n{\n\tstruct sock *sk;\n\tstruct irda_sock *self;\n\tif (protocol < 0 || protocol > SK_PROTOCOL_MAX)\n\t\treturn -EINVAL;\n\tif (net != &init_net)\n\t\treturn -EAFNOSUPPORT;\n\tswitch (sock->type) {\n\tcase SOCK_STREAM:     \n\tcase SOCK_SEQPACKET:  \n\tcase SOCK_DGRAM:      \n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\tsk = sk_alloc(net, PF_IRDA, GFP_KERNEL, &irda_proto, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\tself = irda_sk(sk);\n\tpr_debug(\"%s() : self is %p\\n\", __func__, self);\n\tinit_waitqueue_head(&self->query_wait);\n\tswitch (sock->type) {\n\tcase SOCK_STREAM:\n\t\tsock->ops = &irda_stream_ops;\n\t\tself->max_sdu_size_rx = TTP_SAR_DISABLE;\n\t\tbreak;\n\tcase SOCK_SEQPACKET:\n\t\tsock->ops = &irda_seqpacket_ops;\n\t\tself->max_sdu_size_rx = TTP_SAR_UNBOUND;\n\t\tbreak;\n\tcase SOCK_DGRAM:\n\t\tswitch (protocol) {\n#ifdef CONFIG_IRDA_ULTRA\n\t\tcase IRDAPROTO_ULTRA:\n\t\t\tsock->ops = &irda_ultra_ops;\n\t\t\tself->max_data_size = ULTRA_MAX_DATA - LMP_PID_HEADER;\n\t\t\tself->max_header_size = IRDA_MAX_HEADER + LMP_PID_HEADER;\n\t\t\tbreak;\n#endif \n\t\tcase IRDAPROTO_UNITDATA:\n\t\t\tsock->ops = &irda_dgram_ops;\n\t\t\tself->max_sdu_size_rx = TTP_SAR_UNBOUND;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsk_free(sk);\n\t\t\treturn -ESOCKTNOSUPPORT;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tsk_free(sk);\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\tsock_init_data(sock, sk);\t\n\tsk->sk_family = PF_IRDA;\n\tsk->sk_protocol = protocol;\n\tself->ckey = irlmp_register_client(0, NULL, NULL, NULL);\n\tself->mask.word = 0xffff;\n\tself->rx_flow = self->tx_flow = FLOW_START;\n\tself->nslots = DISCOVERY_DEFAULT_SLOTS;\n\tself->daddr = DEV_ADDR_ANY;\t\n\tself->saddr = 0x0;\t\t\n\treturn 0;\n}", "target": 0}
{"code": "static int __poke_user(struct task_struct *child, addr_t addr, addr_t data)\n{\n\tstruct user *dummy = NULL;\n\taddr_t offset;\n\tif (addr < (addr_t) &dummy->regs.acrs) {\n\t\tif (addr == (addr_t) &dummy->regs.psw.mask) {\n\t\t\tunsigned long mask = PSW_MASK_USER;\n\t\t\tmask |= is_ri_task(child) ? PSW_MASK_RI : 0;\n\t\t\tif ((data & ~mask) != PSW_USER_BITS)\n\t\t\t\treturn -EINVAL;\n\t\t\tif ((data & PSW_MASK_EA) && !(data & PSW_MASK_BA))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\t*(addr_t *)((addr_t) &task_pt_regs(child)->psw + addr) = data;\n\t} else if (addr < (addr_t) (&dummy->regs.orig_gpr2)) {\n\t\toffset = addr - (addr_t) &dummy->regs.acrs;\n#ifdef CONFIG_64BIT\n\t\tif (addr == (addr_t) &dummy->regs.acrs[15])\n\t\t\tchild->thread.acrs[15] = (unsigned int) (data >> 32);\n\t\telse\n#endif\n\t\t*(addr_t *)((addr_t) &child->thread.acrs + offset) = data;\n\t} else if (addr == (addr_t) &dummy->regs.orig_gpr2) {\n\t\ttask_pt_regs(child)->orig_gpr2 = data;\n\t} else if (addr < (addr_t) &dummy->regs.fp_regs) {\n\t\treturn 0;\n\t} else if (addr < (addr_t) (&dummy->regs.fp_regs + 1)) {\n\t\tif (addr == (addr_t) &dummy->regs.fp_regs.fpc)\n\t\t\tif ((unsigned int) data != 0 ||\n\t\t\t    test_fp_ctl(data >> (BITS_PER_LONG - 32)))\n\t\t\t\treturn -EINVAL;\n\t\toffset = addr - (addr_t) &dummy->regs.fp_regs;\n\t\t*(addr_t *)((addr_t) &child->thread.fp_regs + offset) = data;\n\t} else if (addr < (addr_t) (&dummy->regs.per_info + 1)) {\n\t\taddr -= (addr_t) &dummy->regs.per_info;\n\t\t__poke_user_per(child, addr, data);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\tgss_qop_t qop_req, gss_iov_buffer_desc *iov, int iov_count)\n{\n    OM_uint32 status;\n    gss_union_ctx_id_t ctx;\n    gss_mechanism mech;\n    status = val_wrap_iov_args(minor_status, context_handle, 0, qop_req, NULL,\n\t\t\t       iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn status;\n    ctx = (gss_union_ctx_id_t)context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n    mech = gssint_get_mechanism(ctx->mech_type);\n    if (mech == NULL)\n\treturn GSS_S_BAD_MECH;\n    if (mech->gss_get_mic_iov == NULL)\n\treturn GSS_S_UNAVAILABLE;\n    status = mech->gss_get_mic_iov(minor_status, ctx->internal_ctx_id, qop_req,\n\t\t\t\t   iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\tmap_error(minor_status, mech);\n    return status;\n}", "target": 0}
{"code": "__u32 secure_ip_id(__be32 daddr)\n{\n\tu32 hash[MD5_DIGEST_WORDS];\n\thash[0] = (__force __u32) daddr;\n\thash[1] = net_secret[13];\n\thash[2] = net_secret[14];\n\thash[3] = net_secret[15];\n\tmd5_transform(hash, net_secret);\n\treturn hash[0];\n}", "target": 0}
{"code": "static void skip_metadata(struct pstore *ps)\n{\n\tuint32_t stride = ps->exceptions_per_area + 1;\n\tchunk_t next_free = ps->next_free;\n\tif (sector_div(next_free, stride) == NUM_SNAPSHOT_HDR_CHUNKS)\n\t\tps->next_free++;\n}", "target": 0}
{"code": "static ssize_t o2nm_node_num_store(struct config_item *item, const char *page,\n\t\t\t\t   size_t count)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n\tunsigned long tmp;\n\tchar *p = (char *)page;\n\tint ret = 0;\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\tif (tmp >= O2NM_MAX_NODES)\n\t\treturn -ERANGE;\n\tif (!test_bit(O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes) ||\n\t    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))\n\t\treturn -EINVAL; \n\twrite_lock(&cluster->cl_nodes_lock);\n\tif (cluster->cl_nodes[tmp])\n\t\tret = -EEXIST;\n\telse if (test_and_set_bit(O2NM_NODE_ATTR_NUM,\n\t\t\t&node->nd_set_attributes))\n\t\tret = -EBUSY;\n\telse  {\n\t\tcluster->cl_nodes[tmp] = node;\n\t\tnode->nd_num = tmp;\n\t\tset_bit(tmp, cluster->cl_nodes_bitmap);\n\t}\n\twrite_unlock(&cluster->cl_nodes_lock);\n\tif (ret)\n\t\treturn ret;\n\treturn count;\n}", "target": 1}
{"code": "int kvm_io_bus_write(struct kvm_vcpu *vcpu, enum kvm_bus bus_idx, gpa_t addr,\n\t\t     int len, const void *val)\n{\n\tstruct kvm_io_bus *bus;\n\tstruct kvm_io_range range;\n\tint r;\n\trange = (struct kvm_io_range) {\n\t\t.addr = addr,\n\t\t.len = len,\n\t};\n\tbus = srcu_dereference(vcpu->kvm->buses[bus_idx], &vcpu->kvm->srcu);\n\tr = __kvm_io_bus_write(vcpu, bus, &range, val);\n\treturn r < 0 ? r : 0;\n}", "target": 0}
{"code": "static struct file *path_openat(int dfd, struct filename *pathname,\n\t\tstruct nameidata *nd, const struct open_flags *op, int flags)\n{\n\tstruct file *file;\n\tstruct path path;\n\tint opened = 0;\n\tint error;\n\tfile = get_empty_filp();\n\tif (IS_ERR(file))\n\t\treturn file;\n\tfile->f_flags = op->open_flag;\n\tif (unlikely(file->f_flags & __O_TMPFILE)) {\n\t\terror = do_tmpfile(dfd, pathname, nd, flags, op, file, &opened);\n\t\tgoto out;\n\t}\n\terror = path_init(dfd, pathname, flags, nd);\n\tif (unlikely(error))\n\t\tgoto out;\n\terror = do_last(nd, &path, file, op, &opened, pathname);\n\twhile (unlikely(error > 0)) { \n\t\tstruct path link = path;\n\t\tvoid *cookie;\n\t\tif (!(nd->flags & LOOKUP_FOLLOW)) {\n\t\t\tpath_put_conditional(&path, nd);\n\t\t\tpath_put(&nd->path);\n\t\t\terror = -ELOOP;\n\t\t\tbreak;\n\t\t}\n\t\terror = may_follow_link(&link, nd);\n\t\tif (unlikely(error))\n\t\t\tbreak;\n\t\tnd->flags |= LOOKUP_PARENT;\n\t\tnd->flags &= ~(LOOKUP_OPEN|LOOKUP_CREATE|LOOKUP_EXCL);\n\t\terror = follow_link(&link, nd, &cookie);\n\t\tif (unlikely(error))\n\t\t\tbreak;\n\t\terror = do_last(nd, &path, file, op, &opened, pathname);\n\t\tput_link(nd, &link, cookie);\n\t}\nout:\n\tpath_cleanup(nd);\n\tif (!(opened & FILE_OPENED)) {\n\t\tBUG_ON(!error);\n\t\tput_filp(file);\n\t}\n\tif (unlikely(error)) {\n\t\tif (error == -EOPENSTALE) {\n\t\t\tif (flags & LOOKUP_RCU)\n\t\t\t\terror = -ECHILD;\n\t\t\telse\n\t\t\t\terror = -ESTALE;\n\t\t}\n\t\tfile = ERR_PTR(error);\n\t}\n\treturn file;\n}", "target": 1}
{"code": "static int threaded_has_dirs_only_path(struct cache_def *cache, const char *name, int len, int prefix_len)\n{\n\treturn lstat_cache(cache, name, len,\n\t\t\t   FL_DIR|FL_FULLPATH, prefix_len) &\n\t\tFL_DIR;\n}", "target": 0}
{"code": "void FrameLoader::checkCompleted()\n{\n    RefPtr<Frame> protect(m_frame);\n    m_shouldCallCheckCompleted = false;\n    if (m_frame->view())\n        m_frame->view()->handleLoadCompleted();\n    if (m_isComplete)\n        return;\n    if (m_frame->document()->parsing())\n        return;\n    if (m_frame->document()->fetcher()->requestCount())\n        return;\n    if (m_frame->document()->isDelayingLoadEvent())\n        return;\n    if (!allChildrenAreComplete())\n        return;\n    m_isComplete = true;\n    m_requestedHistoryItem = 0;\n    m_frame->document()->setReadyState(Document::Complete);\n    if (m_frame->document()->loadEventStillNeeded())\n        m_frame->document()->implicitClose();\n    m_frame->navigationScheduler()->startTimer();\n    completed();\n    if (m_frame->page())\n        checkLoadComplete();\n    if (m_frame->view())\n        m_frame->view()->handleLoadCompleted();\n}", "target": 0}
{"code": "int main(int argc, char *argv[]) {\n  struct mschm_decompressor *chmd;\n  struct mschmd_header *chm;\n  struct mschmd_file *file, **f;\n  unsigned int numf, i;\n  setbuf(stdout, NULL);\n  setbuf(stderr, NULL);\n  user_umask = umask(0); umask(user_umask);\n  MSPACK_SYS_SELFTEST(i);\n  if (i) return 0;\n  if ((chmd = mspack_create_chm_decompressor(NULL))) {\n    for (argv++; *argv; argv++) {\n      printf(\"%s\\n\", *argv);\n      if ((chm = chmd->open(chmd, *argv))) {\n\tfor (numf=0, file=chm->files; file; file = file->next) numf++;\n\tif ((f = (struct mschmd_file **) calloc(numf, sizeof(struct mschmd_file *)))) {\n\t  for (i=0, file=chm->files; file; file = file->next) f[i++] = file;\n\t  qsort(f, numf, sizeof(struct mschmd_file *), &sortfunc);\n\t  for (i = 0; i < numf; i++) {\n\t    char *outname = create_output_name((unsigned char *)f[i]->filename,NULL,0,1,0);\n\t    printf(\"Extracting %s\\n\", outname);\n\t    ensure_filepath(outname);\n\t    if (chmd->extract(chmd, f[i], outname)) {\n\t      printf(\"%s: extract error on \\\"%s\\\": %s\\n\",\n\t\t     *argv, f[i]->filename, ERROR(chmd));\n\t    }\n\t    free(outname);\n\t  }\n\t  free(f);\n\t}\n\tchmd->close(chmd, chm);\n      }\n      else {\n\tprintf(\"%s: can't open -- %s\\n\", *argv, ERROR(chmd));\n      }\n    }\n    mspack_destroy_chm_decompressor(chmd);\n  }\n  return 0;\n}", "target": 1}
{"code": "static int xfrm_dump_policy_done(struct netlink_callback *cb)\n{\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];\n\txfrm_policy_walk_done(walk);\n\treturn 0;\n}", "target": 1}
{"code": "xfs_attr_fork_reset(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_trans\t*tp)\n{\n\txfs_idestroy_fork(ip, XFS_ATTR_FORK);\n\tip->i_d.di_forkoff = 0;\n\tip->i_d.di_aformat = XFS_DINODE_FMT_EXTENTS;\n\tASSERT(ip->i_d.di_anextents == 0);\n\tASSERT(ip->i_afp == NULL);\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n}", "target": 0}
{"code": "void RenderWidgetHostImpl::ClearDisplayedGraphics() {\n  NotifyNewContentRenderingTimeoutForTesting();\n  if (view_)\n    view_->ClearCompositorFrame();\n}", "target": 0}
{"code": "TEST(VulnerabilityTest, CRLFInjection) {\n  Server svr;\n  svr.Post(\"/test1\", [](const Request &, Response &res) {\n    res.set_content(\"Hello 1\", \"text/plain\");\n  });\n  svr.Delete(\"/test2\", [](const Request &, Response &res) {\n    res.set_content(\"Hello 2\", \"text/plain\");\n  });\n  svr.Put(\"/test3\", [](const Request &, Response &res) {\n    res.set_content(\"Hello 3\", \"text/plain\");\n  });\n  svr.Patch(\"/test4\", [](const Request &, Response &res) {\n    res.set_content(\"Hello 4\", \"text/plain\");\n  });\n  svr.set_logger([](const Request &req, const Response & ) {\n    for (const auto &x : req.headers) {\n      auto key = x.first;\n      EXPECT_STRNE(\"evil\", key.c_str());\n    }\n  });\n  auto thread = std::thread([&]() { svr.listen(HOST, PORT); });\n  auto se = detail::scope_exit([&] {\n    svr.stop();\n    thread.join();\n    ASSERT_FALSE(svr.is_running());\n  });\n  std::this_thread::sleep_for(std::chrono::seconds(1));\n  {\n    Client cli(HOST, PORT);\n    cli.Post(\"/test1\", \"A=B\",\n             \"application/x-www-form-urlencoded\\r\\nevil: hello1\");\n    cli.Delete(\"/test2\", \"A=B\", \"text/plain\\r\\nevil: hello2\");\n    cli.Put(\"/test3\", \"text\", \"text/plain\\r\\nevil: hello3\");\n    cli.Patch(\"/test4\", \"content\", \"text/plain\\r\\nevil: hello4\");\n  }\n}", "target": 0}
{"code": "bool IsPadOpSupported(const TfLiteRegistration* registration,\n                      const TfLiteNode* node, TfLiteContext* context) {\n  const TfLiteTensor* padding = GetInput(context, node, 1);\n  if (!IsConstantTensor(padding)) {\n    TF_LITE_KERNEL_LOG(context,\n                       \"%s: Only constant padding is supported for PAD.\",\n                       padding->name);\n    return false;\n  }\n  if (padding->dims->data[0] != 4 || padding->dims->data[1] != 2) {\n    TF_LITE_KERNEL_LOG(context, \"%s: Only 4D inputs are supported for PAD.\",\n                       padding->name);\n    return false;\n  }\n  const int32_t* padding_data = GetTensorData<int32_t>(padding);\n  if (!(padding_data[0] == 0 && padding_data[1] == 0)) {\n    TF_LITE_KERNEL_LOG(\n        context, \"%s: Padding for batch dimension is not supported in PAD.\",\n        padding->name);\n    return false;\n  }\n  if (!(padding_data[6] == 0 && padding_data[7] == 0)) {\n    TF_LITE_KERNEL_LOG(\n        context, \"%s: Padding for channel dimension is not supported in PAD.\",\n        padding->name);\n    return false;\n  }\n  return true;\n}", "target": 1}
{"code": "long ZEXPORT inflateMark(strm)\nz_streamp strm;\n{\n    struct inflate_state FAR *state;\n    if (strm == Z_NULL || strm->state == Z_NULL) return -1L << 16;\n    state = (struct inflate_state FAR *)strm->state;\n    return ((long)(state->back) << 16) +\n        (state->mode == COPY ? state->length :\n            (state->mode == MATCH ? state->was - state->length : 0));\n}", "target": 1}
{"code": "    size_t operator()(const ArrayOrObject data) const {\n      return data.toOpaque();\n    }", "target": 0}
{"code": "l2tp_bearer_type_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint32_t *ptr = (const uint32_t *)dat;\n\tif (EXTRACT_32BITS(ptr) &  L2TP_BEARER_TYPE_ANALOG_MASK) {\n\t\tND_PRINT((ndo, \"A\"));\n\t}\n\tif (EXTRACT_32BITS(ptr) &  L2TP_BEARER_TYPE_DIGITAL_MASK) {\n\t\tND_PRINT((ndo, \"D\"));\n\t}\n}", "target": 1}
{"code": "\t\tSetRunner(\n\t\t\tReferenceHandle& that,\n\t\t\tLocal<Value> key_handle,\n\t\t\tLocal<Value> val_handle,\n\t\t\tMaybeLocal<Object> maybe_options\n\t\t) :\n\t\t\t\tkey{ExternalCopy::CopyIfPrimitive(key_handle)},\n\t\t\t\tval{TransferOut(val_handle, TransferOptions{maybe_options})},\n\t\t\t\tcontext{that.context},\n\t\t\t\treference{that.reference} {\n\t\t\tthat.CheckDisposed();\n\t\t\tif (!key) {\n\t\t\t\tthrow RuntimeTypeError(\"Invalid `key`\");\n\t\t\t}\n\t\t}", "target": 1}
{"code": "static struct dst_entry *ip6_sk_dst_check(struct sock *sk,\n\t\t\t\t\t  struct dst_entry *dst,\n\t\t\t\t\t  const struct flowi6 *fl6)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct rt6_info *rt = (struct rt6_info *)dst;\n\tif (!dst)\n\t\tgoto out;\n\tif (ip6_rt_check(&rt->rt6i_dst, &fl6->daddr, np->daddr_cache) ||\n#ifdef CONFIG_IPV6_SUBTREES\n\t    ip6_rt_check(&rt->rt6i_src, &fl6->saddr, np->saddr_cache) ||\n#endif\n\t    (fl6->flowi6_oif && fl6->flowi6_oif != dst->dev->ifindex)) {\n\t\tdst_release(dst);\n\t\tdst = NULL;\n\t}\nout:\n\treturn dst;\n}", "target": 1}
{"code": "nfsd4_encode_getdeviceinfo(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\tstruct nfsd4_getdeviceinfo *gdev)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tconst struct nfsd4_layout_ops *ops =\n\t\tnfsd4_layout_ops[gdev->gd_layout_type];\n\tu32 starting_len = xdr->buf->len, needed_len;\n\t__be32 *p;\n\tdprintk(\"%s: err %d\\n\", __func__, be32_to_cpu(nfserr));\n\tif (nfserr)\n\t\tgoto out;\n\tnfserr = nfserr_resource;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out;\n\t*p++ = cpu_to_be32(gdev->gd_layout_type);\n\tif (gdev->gd_maxcount != 0) {\n\t\tnfserr = ops->encode_getdeviceinfo(xdr, gdev);\n\t\tif (nfserr) {\n\t\t\tif (xdr->buf->len + 4 > gdev->gd_maxcount)\n\t\t\t\tgoto toosmall;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tnfserr = nfserr_resource;\n\tif (gdev->gd_notify_types) {\n\t\tp = xdr_reserve_space(xdr, 4 + 4);\n\t\tif (!p)\n\t\t\tgoto out;\n\t\t*p++ = cpu_to_be32(1);\t\t\t\n\t\t*p++ = cpu_to_be32(gdev->gd_notify_types);\n\t} else {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out;\n\t\t*p++ = 0;\n\t}\n\tnfserr = 0;\nout:\n\tkfree(gdev->gd_device);\n\tdprintk(\"%s: done: %d\\n\", __func__, be32_to_cpu(nfserr));\n\treturn nfserr;\ntoosmall:\n\tdprintk(\"%s: maxcount too small\\n\", __func__);\n\tneeded_len = xdr->buf->len + 4 ;\n\txdr_truncate_encode(xdr, starting_len);\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p) {\n\t\tnfserr = nfserr_resource;\n\t} else {\n\t\t*p++ = cpu_to_be32(needed_len);\n\t\tnfserr = nfserr_toosmall;\n\t}\n\tgoto out;\n}", "target": 1}
{"code": "TEST_F(QueryPlannerTest, MergeSortReverseSubtreeContainedOr) {\n    addIndex(BSON(\"a\" << 1 << \"e\" << 1));\n    addIndex(BSON(\"c\" << 1 << \"e\" << -1));\n    addIndex(BSON(\"d\" << 1 << \"e\" << -1));\n    runQueryAsCommand(fromjson(\n        \"{find: 'testns', filter: {$or: [{a: 1}, {b: 1, $or: [{c: 1}, {d: 1}]}]}, sort: {e: 1}}\"));\n    assertNumSolutions(2U);\n    assertSolutionExists(\n        \"{sort: {pattern: {e: 1}, limit: 0, node: {sortKeyGen: {node: \"\n        \"{cscan: {dir: 1}}}}}}\");\n    assertSolutionExists(\n        \"{fetch: {node: {mergeSort: {nodes: \"\n        \"[{ixscan: {pattern: {a: 1, e: 1}, dir: 1}}, {fetch: {node: {mergeSort: {nodes: \"\n        \"[{ixscan: {pattern: {c: 1, e: -1}, dir: -1}}, {ixscan: {pattern: {d: 1, e: -1}, dir: \"\n        \"-1}}]}}}}]}}}}\");\n}", "target": 0}
{"code": "static int hidp_setup_hid(struct hidp_session *session,\n\t\t\t\tstruct hidp_connadd_req *req)\n{\n\tstruct hid_device *hid;\n\tint err;\n\tsession->rd_data = kzalloc(req->rd_size, GFP_KERNEL);\n\tif (!session->rd_data)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(session->rd_data, req->rd_data, req->rd_size)) {\n\t\terr = -EFAULT;\n\t\tgoto fault;\n\t}\n\tsession->rd_size = req->rd_size;\n\thid = hid_allocate_device();\n\tif (IS_ERR(hid)) {\n\t\terr = PTR_ERR(hid);\n\t\tgoto fault;\n\t}\n\tsession->hid = hid;\n\thid->driver_data = session;\n\thid->bus     = BUS_BLUETOOTH;\n\thid->vendor  = req->vendor;\n\thid->product = req->product;\n\thid->version = req->version;\n\thid->country = req->country;\n\tstrncpy(hid->name, req->name, 128);\n\tsnprintf(hid->phys, sizeof(hid->phys), \"%pMR\",\n\t\t &bt_sk(session->ctrl_sock->sk)->src);\n\tsnprintf(hid->uniq, sizeof(hid->uniq), \"%pMR\",\n\t\t &bt_sk(session->ctrl_sock->sk)->dst);\n\thid->dev.parent = &session->conn->dev;\n\thid->ll_driver = &hidp_hid_driver;\n\thid->hid_get_raw_report = hidp_get_raw_report;\n\thid->hid_output_raw_report = hidp_output_raw_report;\n\tif (hid_ignore(hid)) {\n\t\thid_destroy_device(session->hid);\n\t\tsession->hid = NULL;\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\nfault:\n\tkfree(session->rd_data);\n\tsession->rd_data = NULL;\n\treturn err;\n}", "target": 1}
{"code": "static M_bool M_fs_check_overwrite_allowed(const char *p1, const char *p2, M_uint32 mode)\n{\n\tM_fs_info_t  *info = NULL;\n\tchar         *pold = NULL;\n\tchar         *pnew = NULL;\n\tM_fs_type_t   type;\n\tM_bool        ret  = M_TRUE;\n\tif (mode & M_FS_FILE_MODE_OVERWRITE)\n\t\treturn M_TRUE;\n\tif (M_fs_info(&info, p1, M_FS_PATH_INFO_FLAGS_BASIC) != M_FS_ERROR_SUCCESS)\n\t\treturn M_FALSE;\n\ttype = M_fs_info_get_type(info);\n\tM_fs_info_destroy(info);\n\tif (type != M_FS_TYPE_DIR) {\n\t\tif (M_fs_perms_can_access(p2, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS)\n\t\t{\n\t\t\tret = M_FALSE;\n\t\t\tgoto done;\n\t\t}\n\t}\n\tpold = M_fs_path_basename(p1, M_FS_SYSTEM_AUTO);\n\tpnew = M_fs_path_join(p2, pnew, M_FS_SYSTEM_AUTO);\n\tif (M_fs_perms_can_access(pnew, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {\n\t\tret = M_FALSE;\n\t\tgoto done;\n\t}\ndone:\n\tM_free(pnew);\n\tM_free(pold);\n\treturn ret;\n}", "target": 1}
{"code": "static int em_bt(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->dst.type = OP_NONE;\n\tctxt->src.val &= (ctxt->dst.bytes << 3) - 1;\n\temulate_2op_SrcV_nobyte(ctxt, \"bt\");\n\treturn X86EMUL_CONTINUE;\n}", "target": 0}
{"code": "void GLES2DecoderImpl::DoUniform1i(GLint fake_location, GLint v0) {\n  GLenum type = 0;\n  GLsizei count = 1;\n  GLint real_location = -1;\n  if (!PrepForSetUniformByLocation(\n      fake_location, \"glUniform1iv\", &real_location, &type, &count)) {\n    return;\n  }\n  current_program_->SetSamplers(fake_location, 1, &v0);\n  glUniform1i(real_location, v0);\n}", "target": 0}
{"code": "void AAHD::refine_hv_dirs()\n{\n  for (int i = 0; i < libraw.imgdata.sizes.iheight; ++i)\n  {\n    refine_hv_dirs(i, i & 1);\n  }\n  for (int i = 0; i < libraw.imgdata.sizes.iheight; ++i)\n  {\n    refine_hv_dirs(i, (i & 1) ^ 1);\n  }\n  for (int i = 0; i < libraw.imgdata.sizes.iheight; ++i)\n  {\n    refine_ihv_dirs(i);\n  }\n}", "target": 0}
{"code": "int ip_options_get_from_user(struct net *net, struct ip_options **optp,\n\t\t\t     unsigned char __user *data, int optlen)\n{\n\tstruct ip_options *opt = ip_options_get_alloc(optlen);\n\tif (!opt)\n\t\treturn -ENOMEM;\n\tif (optlen && copy_from_user(opt->__data, data, optlen)) {\n\t\tkfree(opt);\n\t\treturn -EFAULT;\n\t}\n\treturn ip_options_get_finish(net, optp, opt, optlen);\n}", "target": 1}
{"code": "int CJSON_CDECL main(void)\n{\n    UNITY_BEGIN();\n    RUN_TEST(cjson_array_foreach_should_loop_over_arrays);\n    RUN_TEST(cjson_array_foreach_should_not_dereference_null_pointer);\n    RUN_TEST(cjson_get_object_item_should_get_object_items);\n    RUN_TEST(cjson_get_object_item_case_sensitive_should_get_object_items);\n    RUN_TEST(cjson_get_object_item_should_not_crash_with_array);\n    RUN_TEST(cjson_get_object_item_case_sensitive_should_not_crash_with_array);\n    RUN_TEST(typecheck_functions_should_check_type);\n    RUN_TEST(cjson_should_not_parse_to_deeply_nested_jsons);\n    RUN_TEST(cjson_set_number_value_should_set_numbers);\n    RUN_TEST(cjson_detach_item_via_pointer_should_detach_items);\n    RUN_TEST(cjson_replace_item_via_pointer_should_replace_items);\n    RUN_TEST(cjson_replace_item_in_object_should_preserve_name);\n    RUN_TEST(cjson_functions_shouldnt_crash_with_null_pointers);\n    RUN_TEST(ensure_should_fail_on_failed_realloc);\n    RUN_TEST(skip_utf8_bom_should_skip_bom);\n    RUN_TEST(skip_utf8_bom_should_not_skip_bom_if_not_at_beginning);\n    RUN_TEST(cjson_get_string_value_should_get_a_string);\n    RUN_TEST(cjson_create_string_reference_should_create_a_string_reference);\n    RUN_TEST(cjson_create_object_reference_should_create_an_object_reference);\n    RUN_TEST(cjson_create_array_reference_should_create_an_array_reference);\n    RUN_TEST(cjson_add_item_to_object_should_not_use_after_free_when_string_is_aliased);\n    return UNITY_END();\n}", "target": 0}
{"code": "static pj_status_t STATUS_FROM_SSL_ERR2(char *action, pj_ssl_sock_t *ssock,\n\t\t\t\t\tint ret, int err, int len)\n{\n    unsigned long ssl_err = err;\n    if (err == SSL_ERROR_SSL) {\n\tssl_err = ERR_peek_error();\n    }\n    SSLLogErrors(action, ret, err, len, ssock);\n    ssock->last_err = ssl_err;\n    return GET_STATUS_FROM_SSL_ERR(ssl_err);\n}", "target": 1}
{"code": "dns_lookup_timerwrap(dns_answer *dnsa, const uschar *name, int type,\n  const uschar **fully_qualified_name)\n{\nint retval;\nunsigned long time_msec;\nif (!slow_lookup_log)\n  return dns_lookup(dnsa, name, type, fully_qualified_name);\ntime_msec = get_time_in_ms();\nretval = dns_lookup(dnsa, name, type, fully_qualified_name);\nif ((time_msec = get_time_in_ms() - time_msec) > slow_lookup_log)\n  log_long_lookup(US\"name\", name, time_msec);\nreturn retval;\n}", "target": 0}
{"code": "int af_alg_make_sg(struct af_alg_sgl *sgl, struct iov_iter *iter, int len)\n{\n\tsize_t off;\n\tssize_t n;\n\tint npages, i;\n\tn = iov_iter_get_pages(iter, sgl->pages, len, ALG_MAX_PAGES, &off);\n\tif (n < 0)\n\t\treturn n;\n\tnpages = PAGE_ALIGN(off + n);\n\tif (WARN_ON(npages == 0))\n\t\treturn -EINVAL;\n\tsg_init_table(sgl->sg, npages);\n\tfor (i = 0, len = n; i < npages; i++) {\n\t\tint plen = min_t(int, len, PAGE_SIZE - off);\n\t\tsg_set_page(sgl->sg + i, sgl->pages[i], plen, off);\n\t\toff = 0;\n\t\tlen -= plen;\n\t}\n\treturn n;\n}", "target": 1}
{"code": "bool allow_svhandler_flash_sector(const FlashSector* sector) {\n  return sector->use == FLASH_STORAGE1 ||\n         sector->use == FLASH_STORAGE2 ||\n         sector->use == FLASH_STORAGE3 ||\n         sector->use == FLASH_UNUSED0 ||\n         sector->use == FLASH_APP;\n}", "target": 0}
{"code": "struct addr_t* MACH0_(get_entrypoint)(struct MACH0_(obj_t)* bin) {\n\tstruct addr_t *entry;\n\tint i;\n\tif (!bin->entry && !bin->sects) {\n\t\treturn NULL;\n\t}\n\tif (!(entry = calloc (1, sizeof (struct addr_t)))) {\n\t\treturn NULL;\n\t}\n\tif (bin->entry) {\n\t\tentry->addr = entry_to_vaddr (bin);\n\t\tentry->offset = addr_to_offset (bin, entry->addr);\n\t\tentry->haddr = sdb_num_get (bin->kv, \"mach0.entry.offset\", 0);\n\t}\n\tif (!bin->entry || entry->offset == 0) {\n\t\tfor (i = 0; i < bin->nsects; i++) {\n\t\t\tif (!strncmp (bin->sects[i].sectname, \"__text\", 6)) {\n\t\t\t\tentry->offset = (ut64)bin->sects[i].offset;\n\t\t\t\tsdb_num_set (bin->kv, \"mach0.entry\", entry->offset, 0);\n\t\t\t\tentry->addr = (ut64)bin->sects[i].addr;\n\t\t\t\tif (!entry->addr) { \n\t\t\t\t\tentry->addr = entry->offset;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbin->entry = entry->addr;\n\t}\n\treturn entry;\n}", "target": 1}
{"code": "TEST(FloatPoolingOpTest, MaxPoolWithZeroStride) {\n  EXPECT_DEATH(\n      FloatPoolingOpModel m(BuiltinOperator_MAX_POOL_2D,\n                            {TensorType_FLOAT32, {1, 2, 4, 1}},\n                            2, 2,\n                            {TensorType_FLOAT32, {}},\n                            Padding_VALID,\n                            0, 0),\n      \"Cannot allocate tensors\");\n}", "target": 0}
{"code": "static noinline void key_gc_unused_keys(struct list_head *keys)\n{\n\twhile (!list_empty(keys)) {\n\t\tstruct key *key =\n\t\t\tlist_entry(keys->next, struct key, graveyard_link);\n\t\tlist_del(&key->graveyard_link);\n\t\tkdebug(\"- %u\", key->serial);\n\t\tkey_check(key);\n\t\tsecurity_key_free(key);\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\t\tatomic_dec(&key->user->nkeys);\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))\n\t\t\tatomic_dec(&key->user->nikeys);\n\t\tkey_user_put(key->user);\n\t\tif (key->type->destroy)\n\t\t\tkey->type->destroy(key);\n\t\tkfree(key->description);\n#ifdef KEY_DEBUGGING\n\t\tkey->magic = KEY_DEBUG_MAGIC_X;\n#endif\n\t\tkmem_cache_free(key_jar, key);\n\t}\n}", "target": 1}
{"code": "static void ossl_disassociate_connection(struct Curl_easy *data,\n                                         int sockindex)\n{\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  if(!backend->handle)\n    return;\n  if(SSL_SET_OPTION(primary.sessionid)) {\n    bool isproxy = FALSE;\n    bool incache;\n    void *old_ssl_sessionid = NULL;\n    int data_idx = ossl_get_ssl_data_index();\n    int connectdata_idx = ossl_get_ssl_conn_index();\n    int sockindex_idx = ossl_get_ssl_sockindex_index();\n    int proxy_idx = ossl_get_proxy_index();\n    if(data_idx >= 0 && connectdata_idx >= 0 && sockindex_idx >= 0 &&\n       proxy_idx >= 0) {\n      isproxy = SSL_get_ex_data(backend->handle, proxy_idx) ? TRUE : FALSE;\n      SSL_set_ex_data(backend->handle, data_idx, NULL);\n      SSL_set_ex_data(backend->handle, connectdata_idx, NULL);\n      SSL_set_ex_data(backend->handle, sockindex_idx, NULL);\n      SSL_set_ex_data(backend->handle, proxy_idx, NULL);\n    }\n    Curl_ssl_sessionid_lock(data);\n    incache = !(Curl_ssl_getsessionid(data, conn, isproxy,\n                                      &old_ssl_sessionid, NULL, sockindex));\n    if(incache)\n      Curl_ssl_delsessionid(data, old_ssl_sessionid);\n    Curl_ssl_sessionid_unlock(data);\n  }\n}", "target": 0}
{"code": "void LanLinkProvider::dataReceived()\n{\n    QSslSocket* socket = qobject_cast<QSslSocket*>(sender());\n    if (socket->bytesAvailable() > 8192) {\n        qCWarning(KDECONNECT_CORE) << \"LanLinkProvider/newConnection: Suspiciously long identity package received. Closing connection.\" << socket->peerAddress() << socket->bytesAvailable();\n        socket->disconnectFromHost();\n        return;\n    }\n#if QT_VERSION < QT_VERSION_CHECK(5,7,0)\n    if (!socket->canReadLine())\n        return;\n#else\n    socket->startTransaction();\n#endif\n    const QByteArray data = socket->readLine();\n    qCDebug(KDECONNECT_CORE) << \"LanLinkProvider received reply:\" << data;\n    NetworkPacket* np = new NetworkPacket(QLatin1String(\"\"));\n    bool success = NetworkPacket::unserialize(data, np);\n#if QT_VERSION < QT_VERSION_CHECK(5,7,0)\n    if (!success) {\n        delete np;\n        return;\n    }\n#else\n    if (!success) {\n        delete np;\n        socket->rollbackTransaction();\n        return;\n    }\n    socket->commitTransaction();\n#endif\n    if (np->type() != PACKET_TYPE_IDENTITY) {\n        qCWarning(KDECONNECT_CORE) << \"LanLinkProvider/newConnection: Expected identity, received \" << np->type();\n        delete np;\n        return;\n    }\n    m_receivedIdentityPackets[socket].np = np;\n    const QString& deviceId = np->get<QString>(QStringLiteral(\"deviceId\"));\n    disconnect(socket, &QIODevice::readyRead, this, &LanLinkProvider::dataReceived);\n    if (np->get<int>(QStringLiteral(\"protocolVersion\")) >= MIN_VERSION_WITH_SSL_SUPPORT) {\n        bool isDeviceTrusted = KdeConnectConfig::instance().trustedDevices().contains(deviceId);\n        configureSslSocket(socket, deviceId, isDeviceTrusted);\n        qCDebug(KDECONNECT_CORE) << \"Starting client ssl (but I'm the server TCP socket)\";\n        connect(socket, &QSslSocket::encrypted, this, &LanLinkProvider::encrypted);\n        if (isDeviceTrusted) {\n            connect(socket, QOverload<const QList<QSslError> &>::of(&QSslSocket::sslErrors), this, &LanLinkProvider::sslErrors);\n        }\n        socket->startClientEncryption();\n    } else {\n        qWarning() << np->get<QString>(QStringLiteral(\"deviceName\")) << \"uses an old protocol version, this won't work\";\n        delete m_receivedIdentityPackets.take(socket).np;\n    }\n}", "target": 0}
{"code": "vte_sequence_handler_DC (VteTerminal *terminal, GValueArray *params)\n{\n\tvte_sequence_handler_multiple(terminal, params, vte_sequence_handler_dc);\n}", "target": 0}
{"code": "static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)\n{\n\tgit_pkt *pkt;\n\tconst char *line, *line_end = NULL;\n\tsize_t line_len;\n\tint error;\n\tint reading_from_buf = data_pkt_buf->size > 0;\n\tif (reading_from_buf) {\n\t\tgit_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);\n\t\tline = data_pkt_buf->ptr;\n\t\tline_len = data_pkt_buf->size;\n\t}\n\telse {\n\t\tline = data_pkt->data;\n\t\tline_len = data_pkt->len;\n\t}\n\twhile (line_len > 0) {\n\t\terror = git_pkt_parse_line(&pkt, line, &line_end, line_len);\n\t\tif (error == GIT_EBUFS) {\n\t\t\tif (!reading_from_buf)\n\t\t\t\tgit_buf_put(data_pkt_buf, line, line_len);\n\t\t\terror = 0;\n\t\t\tgoto done;\n\t\t}\n\t\telse if (error < 0)\n\t\t\tgoto done;\n\t\tline_len -= (line_end - line);\n\t\tline = line_end;\n\t\tif (pkt == NULL)\n\t\t\tcontinue;\n\t\terror = add_push_report_pkt(push, pkt);\n\t\tgit_pkt_free(pkt);\n\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\tgoto done;\n\t}\n\terror = 0;\ndone:\n\tif (reading_from_buf)\n\t\tgit_buf_consume(data_pkt_buf, line_end);\n\treturn error;\n}", "target": 1}
{"code": "static void __return_cfs_rq_runtime(struct cfs_rq *cfs_rq)\n{\n\tstruct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(cfs_rq->tg);\n\ts64 slack_runtime = cfs_rq->runtime_remaining - min_cfs_rq_runtime;\n\tif (slack_runtime <= 0)\n\t\treturn;\n\traw_spin_lock(&cfs_b->lock);\n\tif (cfs_b->quota != RUNTIME_INF &&\n\t    cfs_rq->runtime_expires == cfs_b->runtime_expires) {\n\t\tcfs_b->runtime += slack_runtime;\n\t\tif (cfs_b->runtime > sched_cfs_bandwidth_slice() &&\n\t\t    !list_empty(&cfs_b->throttled_cfs_rq))\n\t\t\tstart_cfs_slack_bandwidth(cfs_b);\n\t}\n\traw_spin_unlock(&cfs_b->lock);\n\tcfs_rq->runtime_remaining -= slack_runtime;\n}", "target": 1}
{"code": "PJ_DEF(void) pj_scan_get_newline( pj_scanner *scanner )\n{\n    if (!PJ_SCAN_IS_NEWLINE(*scanner->curptr)) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n    if (*scanner->curptr == '\\r') {\n\t++scanner->curptr;\n    }\n    if (*scanner->curptr == '\\n') {\n\t++scanner->curptr;\n    }\n    ++scanner->line;\n    scanner->start_line = scanner->curptr;\n}", "target": 1}
{"code": "  void ValidateInputs(OpKernelContext* ctx,\n                      const CSRSparseMatrix& sparse_matrix,\n                      const Tensor& permutation_indices, int* batch_size,\n                      int64* num_rows) {\n    OP_REQUIRES(ctx, sparse_matrix.dtype() == DataTypeToEnum<T>::value,\n                errors::InvalidArgument(\n                    \"Asked for a CSRSparseMatrix of type \",\n                    DataTypeString(DataTypeToEnum<T>::value),\n                    \" but saw dtype: \", DataTypeString(sparse_matrix.dtype())));\n    const Tensor& dense_shape = sparse_matrix.dense_shape();\n    const int rank = dense_shape.dim_size(0);\n    OP_REQUIRES(ctx, rank == 2 || rank == 3,\n                errors::InvalidArgument(\"sparse matrix must have rank 2 or 3; \",\n                                        \"but dense_shape has size \", rank));\n    const int row_dim = (rank == 2) ? 0 : 1;\n    auto dense_shape_vec = dense_shape.vec<int64>();\n    *num_rows = dense_shape_vec(row_dim);\n    const int64 num_cols = dense_shape_vec(row_dim + 1);\n    OP_REQUIRES(ctx, *num_rows == num_cols,\n                errors::InvalidArgument(\"sparse matrix must be square; got: \",\n                                        *num_rows, \" != \", num_cols));\n    const TensorShape& perm_shape = permutation_indices.shape();\n    OP_REQUIRES(\n        ctx, perm_shape.dims() + 1 == rank,\n        errors::InvalidArgument(\n            \"sparse matrix must have the same rank as permutation; got: \", rank,\n            \" != \", perm_shape.dims(), \" + 1.\"));\n    OP_REQUIRES(\n        ctx, perm_shape.dim_size(rank - 2) == *num_rows,\n        errors::InvalidArgument(\n            \"permutation must have the same number of elements in each batch \"\n            \"as the number of rows in sparse matrix; got: \",\n            perm_shape.dim_size(rank - 2), \" != \", *num_rows));\n    *batch_size = sparse_matrix.batch_size();\n    if (*batch_size > 1) {\n      OP_REQUIRES(\n          ctx, perm_shape.dim_size(0) == *batch_size,\n          errors::InvalidArgument(\"permutation must have the same batch size \"\n                                  \"as sparse matrix; got: \",\n                                  perm_shape.dim_size(0), \" != \", *batch_size));\n    }\n  }", "target": 1}
{"code": "DECLAREwriteFunc(writeBufferToContigTiles)\n{\n\tuint32 imagew = TIFFScanlineSize(out);\n\tuint32 tilew  = TIFFTileRowSize(out);\n\tint iskew = imagew - tilew;\n\ttsize_t tilesize = TIFFTileSize(out);\n\ttdata_t obuf;\n\tuint8* bufp = (uint8*) buf;\n\tuint32 tl, tw;\n\tuint32 row;\n\t(void) spp;\n\tobuf = _TIFFmalloc(TIFFTileSize(out));\n\tif (obuf == NULL)\n\t\treturn 0;\n\t_TIFFmemset(obuf, 0, tilesize);\n\t(void) TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);\n\t(void) TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);\n\tfor (row = 0; row < imagelength; row += tilelength) {\n\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\n\t\tuint32 colb = 0;\n\t\tuint32 col;\n\t\tfor (col = 0; col < imagewidth; col += tw) {\n\t\t\tif (colb + tilew > imagew) {\n\t\t\t\tuint32 width = imagew - colb;\n\t\t\t\tint oskew = tilew - width;\n\t\t\t\tcpStripToTile(obuf, bufp + colb, nrow, width,\n\t\t\t\t    oskew, oskew + iskew);\n\t\t\t} else\n\t\t\t\tcpStripToTile(obuf, bufp + colb, nrow, tilew,\n\t\t\t\t    0, iskew);\n\t\t\tif (TIFFWriteTile(out, obuf, col, row, 0, 0) < 0) {\n\t\t\t\tTIFFError(TIFFFileName(out),\n\t\t\t\t    \"Error, can't write tile at %lu %lu\",\n\t\t\t\t    (unsigned long) col,\n\t\t\t\t    (unsigned long) row);\n\t\t\t\t_TIFFfree(obuf);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcolb += tilew;\n\t\t}\n\t\tbufp += nrow * imagew;\n\t}\n\t_TIFFfree(obuf);\n\treturn 1;\n}", "target": 1}
{"code": "static int ath10k_usb_hif_tx_sg(struct ath10k *ar, u8 pipe_id,\n\t\t\t\tstruct ath10k_hif_sg_item *items, int n_items)\n{\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\tstruct ath10k_usb_pipe *pipe = &ar_usb->pipes[pipe_id];\n\tstruct ath10k_urb_context *urb_context;\n\tstruct sk_buff *skb;\n\tstruct urb *urb;\n\tint ret, i;\n\tfor (i = 0; i < n_items; i++) {\n\t\turb_context = ath10k_usb_alloc_urb_from_pipe(pipe);\n\t\tif (!urb_context) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t\tskb = items[i].transfer_context;\n\t\turb_context->skb = skb;\n\t\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\t\tif (!urb) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_free_urb_to_pipe;\n\t\t}\n\t\tusb_fill_bulk_urb(urb,\n\t\t\t\t  ar_usb->udev,\n\t\t\t\t  pipe->usb_pipe_handle,\n\t\t\t\t  skb->data,\n\t\t\t\t  skb->len,\n\t\t\t\t  ath10k_usb_transmit_complete, urb_context);\n\t\tif (!(skb->len % pipe->max_packet_size)) {\n\t\t\turb->transfer_flags |= URB_ZERO_PACKET;\n\t\t}\n\t\tusb_anchor_urb(urb, &pipe->urb_submitted);\n\t\tret = usb_submit_urb(urb, GFP_ATOMIC);\n\t\tif (ret) {\n\t\t\tath10k_dbg(ar, ATH10K_DBG_USB_BULK,\n\t\t\t\t   \"usb bulk transmit failed: %d\\n\", ret);\n\t\t\tusb_unanchor_urb(urb);\n\t\t\tusb_free_urb(urb);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_free_urb_to_pipe;\n\t\t}\n\t\tusb_free_urb(urb);\n\t}\n\treturn 0;\nerr_free_urb_to_pipe:\n\tath10k_usb_free_urb_to_pipe(urb_context->pipe, urb_context);\nerr:\n\treturn ret;\n}", "target": 0}
{"code": "char *curl_easy_unescape(CURL *handle, const char *string, int length,\n                         int *olen)\n{\n  int alloc = (length?length:(int)strlen(string))+1;\n  char *ns = malloc(alloc);\n  unsigned char in;\n  int strindex=0;\n  unsigned long hex;\n  CURLcode res;\n  if(!ns)\n    return NULL;\n  while(--alloc > 0) {\n    in = *string;\n    if(('%' == in) && ISXDIGIT(string[1]) && ISXDIGIT(string[2])) {\n      char hexstr[3];\n      char *ptr;\n      hexstr[0] = string[1];\n      hexstr[1] = string[2];\n      hexstr[2] = 0;\n      hex = strtoul(hexstr, &ptr, 16);\n      in = curlx_ultouc(hex); \n      res = Curl_convert_from_network(handle, &in, 1);\n      if(res) {\n        free(ns);\n        return NULL;\n      }\n      string+=2;\n      alloc-=2;\n    }\n    ns[strindex++] = in;\n    string++;\n  }\n  ns[strindex]=0; \n  if(olen)\n    *olen = strindex;\n  return ns;\n}", "target": 1}
{"code": "MagickExport void RemoveDuplicateLayers(Image **images,\n     ExceptionInfo *exception)\n{\n  register Image\n    *curr,\n    *next;\n  RectangleInfo\n    bounds;\n  assert((*images) != (const Image *) NULL);\n  assert((*images)->signature == MagickCoreSignature);\n  if ((*images)->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",(*images)->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  curr=GetFirstImageInList(*images);\n  for (; (next=GetNextImageInList(curr)) != (Image *) NULL; curr=next)\n  {\n    if ( curr->columns != next->columns || curr->rows != next->rows\n         || curr->page.x != next->page.x || curr->page.y != next->page.y )\n      continue;\n    bounds=CompareImagesBounds(curr,next,CompareAnyLayer,exception);\n    if ( bounds.x < 0 ) {\n      size_t time;\n      time = curr->delay*1000/curr->ticks_per_second;\n      time += next->delay*1000/next->ticks_per_second;\n      next->ticks_per_second = 100L;\n      next->delay = time*curr->ticks_per_second/1000;\n      next->iterations = curr->iterations;\n      *images = curr;\n      (void) DeleteImageFromList(images);\n    }\n  }\n  *images = GetFirstImageInList(*images);\n}", "target": 1}
{"code": "std::shared_ptr<EC_Group_Data> EC_Group::BER_decode_EC_group(const uint8_t bits[], size_t len,\n                                                             EC_Group_Source source)\n   {\n   BER_Decoder ber(bits, len);\n   BER_Object obj = ber.get_next_object();\n   if(obj.type() == NULL_TAG)\n      {\n      throw Decoding_Error(\"Cannot handle ImplicitCA ECC parameters\");\n      }\n   else if(obj.type() == OBJECT_ID)\n      {\n      OID dom_par_oid;\n      BER_Decoder(bits, len).decode(dom_par_oid);\n      return ec_group_data().lookup(dom_par_oid);\n      }\n   else if(obj.type() == SEQUENCE)\n      {\n      BigInt p, a, b, order, cofactor;\n      std::vector<uint8_t> base_pt;\n      std::vector<uint8_t> seed;\n      BER_Decoder(bits, len)\n         .start_cons(SEQUENCE)\n           .decode_and_check<size_t>(1, \"Unknown ECC param version code\")\n           .start_cons(SEQUENCE)\n            .decode_and_check(OID(\"1.2.840.10045.1.1\"),\n                              \"Only prime ECC fields supported\")\n             .decode(p)\n           .end_cons()\n           .start_cons(SEQUENCE)\n             .decode_octet_string_bigint(a)\n             .decode_octet_string_bigint(b)\n             .decode_optional_string(seed, BIT_STRING, BIT_STRING)\n           .end_cons()\n           .decode(base_pt, OCTET_STRING)\n           .decode(order)\n           .decode(cofactor)\n         .end_cons()\n         .verify_end();\n      if(p.bits() < 64 || p.is_negative() || !is_bailie_psw_probable_prime(p))\n         throw Decoding_Error(\"Invalid ECC p parameter\");\n      if(a.is_negative() || a >= p)\n         throw Decoding_Error(\"Invalid ECC a parameter\");\n      if(b <= 0 || b >= p)\n         throw Decoding_Error(\"Invalid ECC b parameter\");\n      if(order <= 0 || !is_bailie_psw_probable_prime(order))\n         throw Decoding_Error(\"Invalid ECC order parameter\");\n      if(cofactor <= 0 || cofactor >= 16)\n         throw Decoding_Error(\"Invalid ECC cofactor parameter\");\n      std::pair<BigInt, BigInt> base_xy = Botan::OS2ECP(base_pt.data(), base_pt.size(), p, a, b);\n      return ec_group_data().lookup_or_create(p, a, b, base_xy.first, base_xy.second,\n                                              order, cofactor, OID(), source);\n      }\n   else\n      {\n      throw Decoding_Error(\"Unexpected tag while decoding ECC domain params\");\n      }\n   }", "target": 1}
{"code": "__ext4_set_acl(handle_t *handle, struct inode *inode, int type,\n\t     struct posix_acl *acl)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t\telse {\n\t\t\t\tinode->i_ctime = ext4_current_time(inode);\n\t\t\t\text4_mark_inode_dirty(handle, inode);\n\t\t\t\tif (error == 0)\n\t\t\t\t\tacl = NULL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tvalue = ext4_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\terror = ext4_xattr_set_handle(handle, inode, name_index, \"\",\n\t\t\t\t      value, size, 0);\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\treturn error;\n}", "target": 1}
{"code": "njs_module_path(njs_vm_t *vm, const njs_str_t *dir, njs_module_info_t *info)\n{\n    char        *p;\n    size_t      length;\n    njs_bool_t  trail;\n    char        src[NJS_MAX_PATH + 1];\n    trail = 0;\n    length = info->name.length;\n    if (dir != NULL) {\n        length = dir->length;\n        if (length == 0) {\n            return NJS_DECLINED;\n        }\n        trail = (dir->start[dir->length - 1] != '/');\n        if (trail) {\n            length++;\n        }\n    }\n    if (njs_slow_path(length > NJS_MAX_PATH)) {\n        return NJS_ERROR;\n    }\n    p = &src[0];\n    if (dir != NULL) {\n        p = (char *) njs_cpymem(p, dir->start, dir->length);\n        if (trail) {\n            *p++ = '/';\n        }\n    }\n    p = (char *) njs_cpymem(p, info->name.start, info->name.length);\n    *p = '\\0';\n    p = realpath(&src[0], &info->path[0]);\n    if (p == NULL) {\n        return NJS_DECLINED;\n    }\n    info->fd = open(&info->path[0], O_RDONLY);\n    if (info->fd < 0) {\n        return NJS_DECLINED;\n    }\n    info->file.start = (u_char *) &info->path[0];\n    info->file.length = njs_strlen(info->file.start);\n    return NJS_OK;\n}", "target": 1}
{"code": "void migrate_page_copy(struct page *newpage, struct page *page)\n{\n\tint cpupid;\n\tif (PageHuge(page) || PageTransHuge(page))\n\t\tcopy_huge_page(newpage, page);\n\telse\n\t\tcopy_highpage(newpage, page);\n\tif (PageError(page))\n\t\tSetPageError(newpage);\n\tif (PageReferenced(page))\n\t\tSetPageReferenced(newpage);\n\tif (PageUptodate(page))\n\t\tSetPageUptodate(newpage);\n\tif (TestClearPageActive(page)) {\n\t\tVM_BUG_ON_PAGE(PageUnevictable(page), page);\n\t\tSetPageActive(newpage);\n\t} else if (TestClearPageUnevictable(page))\n\t\tSetPageUnevictable(newpage);\n\tif (PageChecked(page))\n\t\tSetPageChecked(newpage);\n\tif (PageMappedToDisk(page))\n\t\tSetPageMappedToDisk(newpage);\n\tif (PageDirty(page)) {\n\t\tclear_page_dirty_for_io(page);\n\t\tif (PageSwapBacked(page))\n\t\t\tSetPageDirty(newpage);\n\t\telse\n\t\t\t__set_page_dirty_nobuffers(newpage);\n \t}\n\tif (page_is_young(page))\n\t\tset_page_young(newpage);\n\tif (page_is_idle(page))\n\t\tset_page_idle(newpage);\n\tcpupid = page_cpupid_xchg_last(page, -1);\n\tpage_cpupid_xchg_last(newpage, cpupid);\n\tksm_migrate_page(newpage, page);\n\tif (PageSwapCache(page))\n\t\tClearPageSwapCache(page);\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tif (PageWriteback(newpage))\n\t\tend_page_writeback(newpage);\n}", "target": 1}
{"code": "void DelegatedFrameHost::ResetCompositorFrameSinkSupport() {\n  if (!support_)\n    return;\n  if (compositor_)\n    compositor_->RemoveFrameSink(frame_sink_id_);\n  support_.reset();\n}", "target": 0}
{"code": "inline void ImageLoader::ClearFailedLoadURL() {\n  failed_load_url_ = AtomicString();\n}", "target": 0}
{"code": "static int getlblockinc(Jpeg2000DecoderContext *s)\n{\n    int res = 0, ret;\n    while (ret = get_bits(s, 1)) {\n        if (ret < 0)\n            return ret;\n        res++;\n    }\n    return res;\n}", "target": 0}
{"code": "TfLiteStatus TanhPrepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n  OpData* data = static_cast<OpData*>(node->user_data);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE(context, input != nullptr);\n  data->input_zero_point = input->params.zero_point;\n  return CalculateArithmeticOpData(context, node, data);\n}", "target": 0}
{"code": "snmp_ber_decode_unsigned_integer(unsigned char *buf, uint32_t *buff_len, uint8_t expected_type, uint32_t *num)\n{\n  uint8_t i, len, type;\n  buf = snmp_ber_decode_type(buf, buff_len, &type);\n  if(buf == NULL || type != expected_type) {\n    return NULL;\n  }\n  buf = snmp_ber_decode_length(buf, buff_len, &len);\n  if(buf == NULL || len > 4) {\n    return NULL;\n  }\n  if(*buff_len < len) {\n    return NULL;\n  }\n  *num = (uint32_t)(*buf++ & 0xFF);\n  (*buff_len)--;\n  for(i = 1; i < len; ++i) {\n    *num <<= 8;\n    *num |= (uint8_t)(*buf++ & 0xFF);\n    (*buff_len)--;\n  }\n  return buf;\n}", "target": 1}
{"code": "void xacct_add_tsk(struct taskstats *stats, struct task_struct *p)\n{\n\tstats->coremem = jiffies_to_usecs(p->acct_rss_mem1) * PAGE_SIZE / MB;\n\tstats->virtmem = jiffies_to_usecs(p->acct_vm_mem1) * PAGE_SIZE / MB;\n\tif (p->mm) {\n\t\tstats->hiwater_rss   = p->mm->hiwater_rss * PAGE_SIZE / KB;\n\t\tstats->hiwater_vm    = p->mm->hiwater_vm * PAGE_SIZE / KB;\n\t}\n\tstats->read_char\t= p->rchar;\n\tstats->write_char\t= p->wchar;\n\tstats->read_syscalls\t= p->syscr;\n\tstats->write_syscalls\t= p->syscw;\n}", "target": 1}
{"code": "void LibRaw::lch_to_rgb(double (*image2)[3])\n{\n  int indx;\n  for (indx = 0; indx < height * width; indx++)\n  {\n    image[indx][0] = CLIP(image2[indx][0] / 3.0 - image2[indx][2] / 6.0 +\n                          image2[indx][1] / 3.464101615);\n    image[indx][1] = CLIP(image2[indx][0] / 3.0 - image2[indx][2] / 6.0 -\n                          image2[indx][1] / 3.464101615);\n    image[indx][2] = CLIP(image2[indx][0] / 3.0 + image2[indx][2] / 3.0);\n  }\n}", "target": 0}
{"code": "  inline void init (hb_face_t *face,\n\t\t    hb_tag_t _hea_tag, hb_tag_t _mtx_tag,\n\t\t    unsigned int default_advance_)\n  {\n    this->default_advance = default_advance_;\n    this->num_metrics = face->get_num_glyphs ();\n    hb_blob_t *_hea_blob = OT::Sanitizer<OT::_hea>::sanitize (face->reference_table (_hea_tag));\n    const OT::_hea *_hea = OT::Sanitizer<OT::_hea>::lock_instance (_hea_blob);\n    this->num_advances = _hea->numberOfLongMetrics;\n    hb_blob_destroy (_hea_blob);\n    this->blob = OT::Sanitizer<OT::_mtx>::sanitize (face->reference_table (_mtx_tag));\n    if (unlikely (!this->num_advances ||\n\t\t  2 * (this->num_advances + this->num_metrics) < hb_blob_get_length (this->blob)))\n    {\n      this->num_metrics = this->num_advances = 0;\n      hb_blob_destroy (this->blob);\n      this->blob = hb_blob_get_empty ();\n    }\n    this->table = OT::Sanitizer<OT::_mtx>::lock_instance (this->blob);\n  }", "target": 1}
{"code": "static inline void TCP_ECN_queue_cwr(struct tcp_sock *tp)\n{\n\tif (tp->ecn_flags & TCP_ECN_OK)\n\t\ttp->ecn_flags |= TCP_ECN_QUEUE_CWR;\n}", "target": 0}
{"code": "void HTMLMediaElement::AudioTracksTimerFired(TimerBase*) {\n  Vector<WebMediaPlayer::TrackId> enabled_track_ids;\n  for (unsigned i = 0; i < audioTracks().length(); ++i) {\n    AudioTrack* track = audioTracks().AnonymousIndexedGetter(i);\n    if (track->enabled())\n      enabled_track_ids.push_back(track->id());\n  }\n  GetWebMediaPlayer()->EnabledAudioTracksChanged(enabled_track_ids);\n}", "target": 0}
{"code": "int submit_bio_wait(struct bio *bio)\n{\n\tstruct submit_bio_ret ret;\n\tinit_completion(&ret.event);\n\tbio->bi_private = &ret;\n\tbio->bi_end_io = submit_bio_wait_endio;\n\tbio->bi_opf |= REQ_SYNC;\n\tsubmit_bio(bio);\n\twait_for_completion_io(&ret.event);\n\treturn ret.error;\n}", "target": 0}
{"code": "static int fsmMkdirs(rpmfiles files, rpmfs fs, rpmPlugins plugins)\n{\n    DNLI_t dnli = dnlInitIterator(files, fs, 0);\n    struct stat sb;\n    const char *dpath;\n    int rc = 0;\n    int i;\n    size_t ldnlen = 0;\n    const char * ldn = NULL;\n    while ((dpath = dnlNextIterator(dnli)) != NULL) {\n\tsize_t dnlen = strlen(dpath);\n\tchar * te, dn[dnlen+1];\n\tif (dnlen <= 1)\n\t    continue;\n\tif (dnlen == ldnlen && rstreq(dpath, ldn))\n\t    continue;\n\t(void) stpcpy(dn, dpath);\n\tfor (i = 1, te = dn + 1; *te != '\\0'; te++, i++) {\n\t    if (*te != '/')\n\t\tcontinue;\n\t    if (i < ldnlen &&\n\t\t(ldn[i] == '/' || ldn[i] == '\\0') && rstreqn(dn, ldn, i))\n\t\tcontinue;\n\t    *te = '\\0';\n\t    rc = fsmStat(dn, 1, &sb); \n\t    *te = '/';\n\t    if (rc == 0 && S_ISDIR(sb.st_mode)) {\n\t\tcontinue;\n\t    } else if (rc == RPMERR_ENOENT) {\n\t\t*te = '\\0';\n\t\tmode_t mode = S_IFDIR | (_dirPerms & 07777);\n\t\trpmFsmOp op = (FA_CREATE|FAF_UNOWNED);\n\t\trc = rpmpluginsCallFsmFilePre(plugins, NULL, dn, mode, op);\n\t\tif (!rc)\n\t\t    rc = fsmMkdir(dn, mode);\n\t\tif (!rc) {\n\t\t    rc = rpmpluginsCallFsmFilePrepare(plugins, NULL, dn, dn,\n\t\t\t\t\t\t      mode, op);\n\t\t}\n\t\trpmpluginsCallFsmFilePost(plugins, NULL, dn, mode, op, rc);\n\t\tif (!rc) {\n\t\t    rpmlog(RPMLOG_DEBUG,\n\t\t\t    \"%s directory created with perms %04o\\n\",\n\t\t\t    dn, (unsigned)(mode & 07777));\n\t\t}\n\t\t*te = '/';\n\t    }\n\t    if (rc)\n\t\tbreak;\n\t}\n\tif (rc) break;\n\tldn = dpath;\n\tldnlen = dnlen;\n    }\n    dnlFreeIterator(dnli);\n    return rc;\n}", "target": 1}
{"code": "inline bool SegmentReader::amplifiedRead(WordCount virtualAmount) {\n  return readLimiter->canRead(virtualAmount, arena);\n}", "target": 0}
{"code": "void luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v) {\n  global_State *g = G(L);\n  lua_assert(isblack(o) && iswhite(v) && !isdead(g, v) && !isdead(g, o));\n  if (keepinvariant(g)) {  \n    reallymarkobject(g, v);  \n    if (isold(o)) {\n      lua_assert(!isold(v));  \n      setage(v, G_OLD0);  \n    }\n  }\n  else {  \n    lua_assert(issweepphase(g));\n    makewhite(g, o);  \n  }\n}", "target": 1}
{"code": "static int segmented_write_std(struct x86_emulate_ctxt *ctxt,\n\t\t\t       struct segmented_address addr,\n\t\t\t       void *data,\n\t\t\t       unsigned int size)\n{\n\tint rc;\n\tulong linear;\n\trc = linearize(ctxt, addr, size, true, &linear);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\treturn ctxt->ops->write_std(ctxt, linear, data, size, &ctxt->exception);\n}", "target": 0}
{"code": "void NotificationService::AddObserver(NotificationObserver* observer,\n                                      NotificationType type,\n                                      const NotificationSource& source) {\n  DCHECK(type.value < NotificationType::NOTIFICATION_TYPE_COUNT);\n  CHECK(observer);\n  NotificationObserverList* observer_list;\n  if (HasKey(observers_[type.value], source)) {\n    observer_list = observers_[type.value][source.map_key()];\n  } else {\n    observer_list = new NotificationObserverList;\n    observers_[type.value][source.map_key()] = observer_list;\n  }\n  observer_list->AddObserver(observer);\n#ifndef NDEBUG\n  ++observer_counts_[type.value];\n#endif\n}", "target": 0}
{"code": "unsigned lodepng_info_copy(LodePNGInfo* dest, const LodePNGInfo* source)\n{\n  lodepng_info_cleanup(dest);\n  *dest = *source;\n  lodepng_color_mode_init(&dest->color);\n  CERROR_TRY_RETURN(lodepng_color_mode_copy(&dest->color, &source->color));\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n  CERROR_TRY_RETURN(LodePNGText_copy(dest, source));\n  CERROR_TRY_RETURN(LodePNGIText_copy(dest, source));\n  LodePNGUnknownChunks_init(dest);\n  CERROR_TRY_RETURN(LodePNGUnknownChunks_copy(dest, source));\n#endif \n  return 0;\n}", "target": 0}
{"code": "void ImmutableConstantOp::Compute(OpKernelContext* ctx) {\n  std::unique_ptr<MemmappedTensorAllocator> allocator(\n      new MemmappedTensorAllocator());\n  OP_REQUIRES_OK(ctx,\n                 allocator->InitializeFromRegion(region_name_, ctx->env()));\n  OP_REQUIRES(ctx, dtype_ != DT_STRING,\n              errors::Unimplemented(\"Sorry, DT_STRING is not currently \"\n                                    \"supported for ImmutableConstOp.\"));\n  ctx->set_output(0, Tensor(allocator.get(), dtype_, shape_));\n  OP_REQUIRES_OK(ctx, allocator->allocation_status());\n  allocator.release()->set_delete_on_deallocate();\n}", "target": 0}
{"code": "ProcCloseFont(ClientPtr client)\n{\n    FontPtr pFont;\n    int rc;\n    REQUEST(xResourceReq);\n    REQUEST_SIZE_MATCH(xResourceReq);\n    rc = dixLookupResourceByType((void **) &pFont, stuff->id, RT_FONT,\n                                 client, DixDestroyAccess);\n    if (rc == Success) {\n        FreeResource(stuff->id, RT_NONE);\n        return Success;\n    }\n    else {\n        client->errorValue = stuff->id;\n        return rc;\n    }\n}", "target": 0}
{"code": "void device_init()\n{\n    hw_init(LOW_FREQUENCY);\n    if (! tsc_sensor_exists())\n    {\n        _NFC_status = nfc_init();\n    }\n    if (_NFC_status == NFC_IS_ACTIVE)\n    {\n        printf1(TAG_NFC, \"Have NFC\\r\\n\");\n        isLowFreq = 1;\n        IS_BUTTON_PRESSED = is_physical_button_pressed;\n    }\n    else\n    {\n        printf1(TAG_NFC, \"Have NO NFC\\r\\n\");\n        hw_init(HIGH_FREQUENCY);\n        isLowFreq = 0;\n        device_init_button();\n    }\n    usbhid_init();\n    ctaphid_init();\n    ctap_init();\n    device_migrate();\n#if BOOT_TO_DFU\n    flash_option_bytes_init(1);\n#else\n    flash_option_bytes_init(0);\n#endif\n}", "target": 1}
{"code": "cmsUInt8Number Word2Byte(cmsUInt16Number w)\n{\n    return (cmsUInt8Number) floor((cmsFloat64Number) w / 257.0 + 0.5);\n}", "target": 0}
{"code": "static int su3000_frontend_attach(struct dvb_usb_adapter *d)\n{\n\tu8 obuf[3] = { 0xe, 0x80, 0 };\n\tu8 ibuf[] = { 0 };\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x02;\n\tobuf[2] = 1;\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tmsleep(300);\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x83;\n\tobuf[2] = 0;\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x83;\n\tobuf[2] = 1;\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tobuf[0] = 0x51;\n\tif (dvb_usb_generic_rw(d->dev, obuf, 1, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x51 transfer failed.\");\n\td->fe_adap[0].fe = dvb_attach(ds3000_attach, &su3000_ds3000_config,\n\t\t\t\t\t&d->dev->i2c_adap);\n\tif (d->fe_adap[0].fe == NULL)\n\t\treturn -EIO;\n\tif (dvb_attach(ts2020_attach, d->fe_adap[0].fe,\n\t\t\t\t&dw2104_ts2020_config,\n\t\t\t\t&d->dev->i2c_adap)) {\n\t\tinfo(\"Attached DS3000/TS2020!\");\n\t\treturn 0;\n\t}\n\tinfo(\"Failed to attach DS3000/TS2020!\");\n\treturn -EIO;\n}", "target": 1}
{"code": "Status QuantizeV2Shape(InferenceContext* c) {\n  int axis = -1;\n  Status s = c->GetAttr(\"axis\", &axis);\n  if (!s.ok() && s.code() != error::NOT_FOUND) {\n    return s;\n  }\n  if (axis < -1) {\n    return errors::InvalidArgument(\"axis should be at least -1, got \", axis);\n  }\n  const int minmax_rank = (axis == -1) ? 0 : 1;\n  TF_RETURN_IF_ERROR(shape_inference::UnchangedShape(c));\n  ShapeHandle minmax;\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(1), minmax_rank, &minmax));\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(2), minmax_rank, &minmax));\n  if (axis != -1) {\n    ShapeHandle input;\n    TF_RETURN_IF_ERROR(c->WithRankAtLeast(c->input(0), axis + 1, &input));\n    DimensionHandle depth;\n    TF_RETURN_IF_ERROR(\n        c->Merge(c->Dim(minmax, 0), c->Dim(input, axis), &depth));\n  }\n  c->set_output(1, minmax);\n  c->set_output(2, minmax);\n  return Status::OK();\n}", "target": 0}
{"code": "static bool is_simm32(s64 value)\n{\n\treturn value == (s64) (s32) value;\n}", "target": 0}
{"code": "    OVS_REQUIRES(ofproto_mutex)\n{\n    const struct rule_actions *actions = rule_get_actions(rule);\n    ovs_assert(rule->state == RULE_INITIALIZED);\n    if (rule->hard_timeout || rule->idle_timeout) {\n        ovs_list_insert(&ofproto->expirable, &rule->expirable);\n    }\n    cookies_insert(ofproto, rule);\n    eviction_group_add_rule(rule);\n    if (actions->has_meter) {\n        meter_insert_rule(rule);\n    }\n    if (actions->has_groups) {\n        const struct ofpact_group *a;\n        OFPACT_FOR_EACH_TYPE_FLATTENED (a, GROUP, actions->ofpacts,\n                                        actions->ofpacts_len) {\n            struct ofgroup *group;\n            group = ofproto_group_lookup(ofproto, a->group_id, OVS_VERSION_MAX,\n                                         false);\n            ovs_assert(group != NULL);\n            group_add_rule(group, rule);\n        }\n    }\n    rule->state = RULE_INSERTED;\n}", "target": 1}
{"code": "int main(void)\n{\n\tint fd;\n\tunsigned int i;\n\tunsigned int start = 0;\n\tunsigned int _gap = ~0;\n\tunsigned int gap = _gap / 8;\n\tstruct qcedev_cipher_op_req req = { 0 };\n\tchar *data;\n\tfd = open(dev, O_RDWR);\n\tif (fd < 0) {\n\t\tprintf(\"Failed to open %s with errno %s\\n\", dev,\n\t\t       strerror(errno));\n\t\treturn EXIT_FAILURE;\n\t}\n\tthread_func(start, start + gap, fd);\n\tsleep(1000000);\n\treturn EXIT_FAILURE;\n}", "target": 0}
{"code": "static BOOL drive_file_remove_dir(const WCHAR* path)\n{\n\tWIN32_FIND_DATAW findFileData;\n\tBOOL ret = TRUE;\n\tHANDLE dir;\n\tWCHAR* fullpath;\n\tWCHAR* path_slash;\n\tsize_t base_path_length;\n\tif (!path)\n\t\treturn FALSE;\n\tbase_path_length = _wcslen(path) * 2;\n\tpath_slash = (WCHAR*)calloc(1, base_path_length + sizeof(WCHAR) * 3);\n\tif (!path_slash)\n\t{\n\t\tWLog_ERR(TAG, \"malloc failed!\");\n\t\treturn FALSE;\n\t}\n\tCopyMemory(path_slash, path, base_path_length);\n\tpath_slash[base_path_length / 2] = L'/';\n\tpath_slash[base_path_length / 2 + 1] = L'*';\n\tDEBUG_WSTR(\"Search in %s\", path_slash);\n\tdir = FindFirstFileW(path_slash, &findFileData);\n\tpath_slash[base_path_length / 2 + 1] = 0;\n\tif (dir == INVALID_HANDLE_VALUE)\n\t{\n\t\tfree(path_slash);\n\t\treturn FALSE;\n\t}\n\tdo\n\t{\n\t\tsize_t len = _wcslen(findFileData.cFileName);\n\t\tif ((len == 1 && findFileData.cFileName[0] == L'.') ||\n\t\t    (len == 2 && findFileData.cFileName[0] == L'.' && findFileData.cFileName[1] == L'.'))\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tfullpath = drive_file_combine_fullpath(path_slash, findFileData.cFileName, len * 2);\n\t\tDEBUG_WSTR(\"Delete %s\", fullpath);\n\t\tif (findFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)\n\t\t{\n\t\t\tret = drive_file_remove_dir(fullpath);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tret = DeleteFileW(fullpath);\n\t\t}\n\t\tfree(fullpath);\n\t\tif (!ret)\n\t\t\tbreak;\n\t} while (ret && FindNextFileW(dir, &findFileData) != 0);\n\tFindClose(dir);\n\tif (ret)\n\t{\n\t\tif (!RemoveDirectoryW(path))\n\t\t{\n\t\t\tret = FALSE;\n\t\t}\n\t}\n\tfree(path_slash);\n\treturn ret;\n}", "target": 1}
{"code": "int ipc_addid(struct ipc_ids *ids, struct kern_ipc_perm *new, int size)\n{\n\tkuid_t euid;\n\tkgid_t egid;\n\tint id;\n\tint next_id = ids->next_id;\n\tif (size > IPCMNI)\n\t\tsize = IPCMNI;\n\tif (ids->in_use >= size)\n\t\treturn -ENOSPC;\n\tidr_preload(GFP_KERNEL);\n\tspin_lock_init(&new->lock);\n\tnew->deleted = false;\n\trcu_read_lock();\n\tspin_lock(&new->lock);\n\tid = idr_alloc(&ids->ipcs_idr, new,\n\t\t       (next_id < 0) ? 0 : ipcid_to_idx(next_id), 0,\n\t\t       GFP_NOWAIT);\n\tidr_preload_end();\n\tif (id < 0) {\n\t\tspin_unlock(&new->lock);\n\t\trcu_read_unlock();\n\t\treturn id;\n\t}\n\tids->in_use++;\n\tcurrent_euid_egid(&euid, &egid);\n\tnew->cuid = new->uid = euid;\n\tnew->gid = new->cgid = egid;\n\tif (next_id < 0) {\n\t\tnew->seq = ids->seq++;\n\t\tif (ids->seq > IPCID_SEQ_MAX)\n\t\t\tids->seq = 0;\n\t} else {\n\t\tnew->seq = ipcid_to_seqx(next_id);\n\t\tids->next_id = -1;\n\t}\n\tnew->id = ipc_buildid(id, new->seq);\n\treturn id;\n}", "target": 1}
{"code": "static bool isHexDigit(char ch) {\n  return (ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'f') ||\n         (ch >= 'A' && ch <= 'F');\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& sorted_inputs_t = ctx->input(0);\n    const Tensor& values_t = ctx->input(1);\n    OP_REQUIRES(\n        ctx, sorted_inputs_t.shape().dims() >= 2,\n        errors::InvalidArgument(\"sorted input argument must be a matrix\"));\n    OP_REQUIRES(ctx, sorted_inputs_t.dim_size(0) == values_t.dim_size(0),\n                Status(error::INVALID_ARGUMENT,\n                       \"Leading dim_size of both tensors must match.\"));\n    OP_REQUIRES(ctx, values_t.NumElements() < std::numeric_limits<int>::max(),\n                Status(error::INVALID_ARGUMENT,\n                       \"values tensor size must less than INT_MAX\"));\n    Tensor* output_t;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, values_t.shape(), &output_t));\n    if (output_t->dtype() == DT_INT32) {\n      OP_REQUIRES(ctx,\n                  FastBoundsCheck(sorted_inputs_t.dim_size(1),\n                                  std::numeric_limits<int>::max()),\n                  errors::InvalidArgument(\"trailing dim_size must less than \"\n                                          \"INT_MAX for int32 output type, was \",\n                                          sorted_inputs_t.dim_size(1)));\n    }\n    auto output = output_t->template flat<OutType>();\n    const auto sorted_inputs = sorted_inputs_t.template flat<T>();\n    const auto values = values_t.template flat<T>();\n    if (sorted_inputs.size() == 0) {\n      functor::SetZeroFunctor<Device, OutType> set_zero;\n      set_zero(ctx->eigen_device<Device>(), output);\n      return;\n    }\n    OP_REQUIRES_OK(\n        ctx, functor::UpperBoundFunctor<Device, T, OutType>::Compute(\n                 ctx, sorted_inputs, values, sorted_inputs_t.dim_size(0),\n                 sorted_inputs_t.dim_size(1), values_t.dim_size(1), &output));\n  }", "target": 0}
{"code": "double AccessibilityUIElement::width()\n{\n    if (!m_element || !ATK_IS_OBJECT(m_element))\n        return 0.0f;\n    int width, height;\n    atk_component_get_size(ATK_COMPONENT(m_element), &width, &height);\n    return width;\n}", "target": 0}
{"code": "static void upnp_event_prepare(struct upnp_event_notify * obj)\n{\n\tstatic const char notifymsg[] =\n\t\t\"NOTIFY %s HTTP/1.1\\r\\n\"\n\t\t\"Host: %s%s\\r\\n\"\n#if (UPNP_VERSION_MAJOR == 1) && (UPNP_VERSION_MINOR == 0)\n\t\t\"Content-Type: text/xml\\r\\n\"\t\n#else\n\t\t\"Content-Type: text/xml; charset=\\\"utf-8\\\"\\r\\n\"\t\n#endif\n\t\t\"Content-Length: %d\\r\\n\"\n\t\t\"NT: upnp:event\\r\\n\"\n\t\t\"NTS: upnp:propchange\\r\\n\"\n\t\t\"SID: %s\\r\\n\"\n\t\t\"SEQ: %u\\r\\n\"\n\t\t\"Connection: close\\r\\n\"\n\t\t\"Cache-Control: no-cache\\r\\n\"\n\t\t\"\\r\\n\"\n\t\t\"%.*s\\r\\n\";\n\tchar * xml;\n\tint l;\n\tif(obj->sub == NULL) {\n\t\tobj->state = EError;\n\t\treturn;\n\t}\n\tswitch(obj->sub->service) {\n\tcase EWanCFG:\n\t\txml = getVarsWANCfg(&l);\n\t\tbreak;\n\tcase EWanIPC:\n\t\txml = getVarsWANIPCn(&l);\n\t\tbreak;\n#ifdef ENABLE_L3F_SERVICE\n\tcase EL3F:\n\t\txml = getVarsL3F(&l);\n\t\tbreak;\n#endif\n#ifdef ENABLE_6FC_SERVICE\n\tcase E6FC:\n\t\txml = getVars6FC(&l);\n\t\tbreak;\n#endif\n#ifdef ENABLE_DP_SERVICE\n\tcase EDP:\n\t\txml = getVarsDP(&l);\n\t\tbreak;\n#endif\n\tdefault:\n\t\txml = NULL;\n\t\tl = 0;\n\t}\n\tobj->buffersize = 1024;\n\tobj->buffer = malloc(obj->buffersize);\n\tif(!obj->buffer) {\n\t\tsyslog(LOG_ERR, \"%s: malloc returned NULL\", \"upnp_event_prepare\");\n\t\tif(xml) {\n\t\t\tfree(xml);\n\t\t}\n\t\tobj->state = EError;\n\t\treturn;\n\t}\n\tobj->tosend = snprintf(obj->buffer, obj->buffersize, notifymsg,\n\t                       obj->path, obj->addrstr, obj->portstr, l+2,\n\t                       obj->sub->uuid, obj->sub->seq,\n\t                       l, xml);\n\tif(xml) {\n\t\tfree(xml);\n\t\txml = NULL;\n\t}\n\tobj->state = ESending;\n}", "target": 1}
{"code": "bool is_valid_status(const string& s) {\n  return (s == \"Enabled\" ||\n          s == \"Disabled\");\n}", "target": 0}
{"code": "static int ptrace_check_attach(struct task_struct *child, bool ignore_state)\n{\n\tint ret = -ESRCH;\n\tread_lock(&tasklist_lock);\n\tif ((child->ptrace & PT_PTRACED) && child->parent == current) {\n\t\tspin_lock_irq(&child->sighand->siglock);\n\t\tWARN_ON_ONCE(task_is_stopped(child));\n\t\tif (ignore_state || (task_is_traced(child) &&\n\t\t\t\t     !(child->jobctl & JOBCTL_LISTENING)))\n\t\t\tret = 0;\n\t\tspin_unlock_irq(&child->sighand->siglock);\n\t}\n\tread_unlock(&tasklist_lock);\n\tif (!ret && !ignore_state)\n\t\tret = wait_task_inactive(child, TASK_TRACED) ? 0 : -ESRCH;\n\treturn ret;\n}", "target": 1}
{"code": "int main()\n{\n    gdImagePtr im, clone;\n    int style[] = {0, 0, 0};\n    im = gdImageCreate(8, 8);\n    gdImageSetStyle(im, style, sizeof(style)/sizeof(style[0]));\n    clone = gdImageClone(im);\n    gdTestAssert(clone != NULL);\n    gdTestAssert(clone->styleLength == im->styleLength);\n    gdTestAssert(clone->stylePos == im->stylePos);\n    gdTestAssert(!memcmp(clone->style, im->style, sizeof(style)/sizeof(style[0])));\n    gdImageDestroy(clone);\n    gdImageDestroy(im);\n    return gdNumFailures();\n}", "target": 0}
{"code": "static int bson_string_is_db_ref( const unsigned char *string, const int length ) {\n    int result = 0;\n    if( length >= 4 ) {\n        if( string[1] == 'r' && string[2] == 'e' && string[3] == 'f' )\n            result = 1;\n    }\n    else if( length >= 3 ) {\n        if( string[1] == 'i' && string[2] == 'd' )\n            result = 1;\n        else if( string[1] == 'd' && string[2] == 'b' )\n            result = 1;\n    }\n    return result;\n}", "target": 1}
{"code": "static int ip_setup_cork(struct sock *sk, struct inet_cork *cork,\n\t\t\t struct ipcm_cookie *ipc, struct rtable **rtp)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_options *opt;\n\tstruct rtable *rt;\n\topt = ipc->opt;\n\tif (opt) {\n\t\tif (cork->opt == NULL) {\n\t\t\tcork->opt = kmalloc(sizeof(struct ip_options) + 40,\n\t\t\t\t\t    sk->sk_allocation);\n\t\t\tif (unlikely(cork->opt == NULL))\n\t\t\t\treturn -ENOBUFS;\n\t\t}\n\t\tmemcpy(cork->opt, opt, sizeof(struct ip_options) + opt->optlen);\n\t\tcork->flags |= IPCORK_OPT;\n\t\tcork->addr = ipc->addr;\n\t}\n\trt = *rtp;\n\tif (unlikely(!rt))\n\t\treturn -EFAULT;\n\t*rtp = NULL;\n\tcork->fragsize = inet->pmtudisc == IP_PMTUDISC_PROBE ?\n\t\t\t rt->dst.dev->mtu : dst_mtu(rt->dst.path);\n\tcork->dst = &rt->dst;\n\tcork->length = 0;\n\tcork->tx_flags = ipc->tx_flags;\n\tcork->page = NULL;\n\tcork->off = 0;\n\treturn 0;\n}", "target": 1}
{"code": "create_principal3_2_svc(cprinc3_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret          ret;\n    char                        *prime_arg;\n    gss_buffer_desc             client_name, service_name;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n    restriction_t               *rp;\n    const char                  *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->rec.principal, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (CHANGEPW_SERVICE(rqstp)\n        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_ADD,\n                               arg->rec.principal, &rp)\n        || kadm5int_acl_impose_restrictions(handle->context,\n                                            &arg->rec, &arg->mask, rp)) {\n        ret.code = KADM5_AUTH_ADD;\n        log_unauth(\"kadm5_create_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_create_principal_3((void *)handle,\n                                            &arg->rec, arg->mask,\n                                            arg->n_ks_tuple,\n                                            arg->ks_tuple,\n                                            arg->passwd);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_create_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "        int          GetU16BE (int nPos, bool *pbSuccess)\n        {\n            if ( nPos < 0 || nPos + 1 >= m_nLen)\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            int nRes = m_sFile[ nPos ];\n            nRes = (nRes << 8) + m_sFile[ nPos + 1 ];\n            return nRes;\n        }", "target": 1}
{"code": "check_entry_size_and_hooks(struct ipt_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct ipt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ipt_entry) >= limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct ipt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_err(\"Underflows must be unconditional and \"\n\t\t\t\t       \"use the STANDARD target with \"\n\t\t\t\t       \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 1}
{"code": "static int http_connect(http_subtransport *t)\n{\n\tint error;\n\tchar *proxy_url;\n\tif (t->connected &&\n\t\thttp_should_keep_alive(&t->parser) &&\n\t\tt->parse_finished)\n\t\treturn 0;\n\tif (t->io) {\n\t\tgit_stream_close(t->io);\n\t\tgit_stream_free(t->io);\n\t\tt->io = NULL;\n\t\tt->connected = 0;\n\t}\n\tif (t->connection_data.use_ssl) {\n\t\terror = git_tls_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n\t} else {\n#ifdef GIT_CURL\n\t\terror = git_curl_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n#else\n\t\terror = git_socket_stream_new(&t->io,  t->connection_data.host, t->connection_data.port);\n#endif\n\t}\n\tif (error < 0)\n\t\treturn error;\n\tGITERR_CHECK_VERSION(t->io, GIT_STREAM_VERSION, \"git_stream\");\n\tif (git_stream_supports_proxy(t->io) &&\n\t    !git_remote__get_http_proxy(t->owner->owner, !!t->connection_data.use_ssl, &proxy_url)) {\n\t\terror = git_stream_set_proxy(t->io, proxy_url);\n\t\tgit__free(proxy_url);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\terror = git_stream_connect(t->io);\n#if defined(GIT_OPENSSL) || defined(GIT_SECURE_TRANSPORT) || defined(GIT_CURL)\n\tif ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&\n\t    git_stream_is_encrypted(t->io)) {\n\t\tgit_cert *cert;\n\t\tint is_valid;\n\t\tif ((error = git_stream_certificate(&cert, t->io)) < 0)\n\t\t\treturn error;\n\t\tgiterr_clear();\n\t\tis_valid = error != GIT_ECERTIFICATE;\n\t\terror = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);\n\t\tif (error < 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set(GITERR_NET, \"user cancelled certificate check\");\n\t\t\treturn error;\n\t\t}\n\t}\n#endif\n\tif (error < 0)\n\t\treturn error;\n\tt->connected = 1;\n\treturn 0;\n}", "target": 1}
{"code": "get_pols_2_svc(gpols_arg *arg, struct svc_req *rqstp)\n{\n    static gpols_ret                ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_gpols_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->exp;\n    if (prime_arg == NULL)\n        prime_arg = \"*\";\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_LIST, NULL, NULL)) {\n        ret.code = KADM5_AUTH_LIST;\n        log_unauth(\"kadm5_get_policies\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code  = kadm5_get_policies((void *)handle,\n                                       arg->exp, &ret.pols,\n                                       &ret.count);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_get_policies\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "static inline ut32 r_read_le32(const void *src) {\n\tif (!src) {\n\t\treturn UT32_MAX;\n\t}\n\tconst ut8 *s = (const ut8*)src;\n\treturn (((ut32)s[3]) << 24) | (((ut32)s[2]) << 16) |\n\t\t(((ut32)s[1]) << 8) | (((ut32)s[0]) << 0);\n}", "target": 0}
{"code": "void IndexedDBDatabase::RenameObjectStore(IndexedDBTransaction* transaction,\n                                          int64_t object_store_id,\n                                          const base::string16& new_name) {\n  DCHECK(transaction);\n  IDB_TRACE1(\"IndexedDBDatabase::RenameObjectStore\", \"txn.id\",\n             transaction->id());\n  DCHECK_EQ(transaction->mode(),\n            blink::mojom::IDBTransactionMode::VersionChange);\n  if (!ValidateObjectStoreId(object_store_id))\n    return;\n  IndexedDBObjectStoreMetadata& object_store_metadata =\n      metadata_.object_stores[object_store_id];\n  base::string16 old_name;\n  Status s = metadata_coding_->RenameObjectStore(\n      transaction->BackingStoreTransaction()->transaction(),\n      transaction->database()->id(), new_name, &old_name,\n      &object_store_metadata);\n  if (!s.ok()) {\n    ReportErrorWithDetails(s, \"Internal error renaming object store.\");\n    return;\n  }\n  DCHECK_EQ(object_store_metadata.name, new_name);\n  transaction->ScheduleAbortTask(\n      base::BindOnce(&IndexedDBDatabase::RenameObjectStoreAbortOperation, this,\n                     object_store_id, std::move(old_name)));\n}", "target": 0}
{"code": "static bool msr_mtrr_valid(unsigned msr)\n{\n\tswitch (msr) {\n\tcase 0x200 ... 0x200 + 2 * KVM_NR_VAR_MTRR - 1:\n\tcase MSR_MTRRfix64K_00000:\n\tcase MSR_MTRRfix16K_80000:\n\tcase MSR_MTRRfix16K_A0000:\n\tcase MSR_MTRRfix4K_C0000:\n\tcase MSR_MTRRfix4K_C8000:\n\tcase MSR_MTRRfix4K_D0000:\n\tcase MSR_MTRRfix4K_D8000:\n\tcase MSR_MTRRfix4K_E0000:\n\tcase MSR_MTRRfix4K_E8000:\n\tcase MSR_MTRRfix4K_F0000:\n\tcase MSR_MTRRfix4K_F8000:\n\tcase MSR_MTRRdefType:\n\tcase MSR_IA32_CR_PAT:\n\t\treturn true;\n\tcase 0x2f8:\n\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "get_chainname_rulenum(const struct ipt_entry *s, const struct ipt_entry *e,\n\t\t      const char *hookname, const char **chainname,\n\t\t      const char **comment, unsigned int *rulenum)\n{\n\tconst struct xt_standard_target *t = (void *)ipt_get_target_c(s);\n\tif (strcmp(t->target.u.kernel.target->name, XT_ERROR_TARGET) == 0) {\n\t\t*chainname = t->target.data;\n\t\t(*rulenum) = 0;\n\t} else if (s == e) {\n\t\t(*rulenum)++;\n\t\tif (s->target_offset == sizeof(struct ipt_entry) &&\n\t\t    strcmp(t->target.u.kernel.target->name,\n\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t   t->verdict < 0 &&\n\t\t   unconditional(&s->ip)) {\n\t\t\t*comment = *chainname == hookname\n\t\t\t\t? comments[NF_IP_TRACE_COMMENT_POLICY]\n\t\t\t\t: comments[NF_IP_TRACE_COMMENT_RETURN];\n\t\t}\n\t\treturn 1;\n\t} else\n\t\t(*rulenum)++;\n\treturn 0;\n}", "target": 1}
{"code": "static int setup_ttydir_console(const struct lxc_rootfs *rootfs,\n\t\t\t const struct lxc_console *console,\n\t\t\t char *ttydir)\n{\n\tchar path[MAXPATHLEN], lxcpath[MAXPATHLEN];\n\tint ret;\n\tret = snprintf(path, sizeof(path), \"%s/dev/%s\", rootfs->mount,\n\t\t       ttydir);\n\tif (ret >= sizeof(path))\n\t\treturn -1;\n\tret = mkdir(path, 0755);\n\tif (ret && errno != EEXIST) {\n\t\tSYSERROR(\"failed with errno %d to create %s\", errno, path);\n\t\treturn -1;\n\t}\n\tINFO(\"created %s\", path);\n\tret = snprintf(lxcpath, sizeof(lxcpath), \"%s/dev/%s/console\",\n\t\t       rootfs->mount, ttydir);\n\tif (ret >= sizeof(lxcpath)) {\n\t\tERROR(\"console path too long\");\n\t\treturn -1;\n\t}\n\tsnprintf(path, sizeof(path), \"%s/dev/console\", rootfs->mount);\n\tret = unlink(path);\n\tif (ret && errno != ENOENT) {\n\t\tSYSERROR(\"error unlinking %s\", path);\n\t\treturn -1;\n\t}\n\tret = creat(lxcpath, 0660);\n\tif (ret==-1 && errno != EEXIST) {\n\t\tSYSERROR(\"error %d creating %s\", errno, lxcpath);\n\t\treturn -1;\n\t}\n\tif (ret >= 0)\n\t\tclose(ret);\n\tif (console->master < 0) {\n\t\tINFO(\"no console\");\n\t\treturn 0;\n\t}\n\tif (mount(console->name, lxcpath, \"none\", MS_BIND, 0)) {\n\t\tERROR(\"failed to mount '%s' on '%s'\", console->name, lxcpath);\n\t\treturn -1;\n\t}\n\tret = snprintf(lxcpath, sizeof(lxcpath), \"%s/console\", ttydir);\n\tif (ret >= sizeof(lxcpath)) {\n\t\tERROR(\"lxc/console path too long\");\n\t\treturn -1;\n\t}\n\tret = symlink(lxcpath, path);\n\tif (ret) {\n\t\tSYSERROR(\"failed to create symlink for console\");\n\t\treturn -1;\n\t}\n\tINFO(\"console has been setup on %s\", lxcpath);\n\treturn 0;\n}", "target": 1}
{"code": "int luaD_pretailcall (lua_State *L, CallInfo *ci, StkId func,\n                                    int narg1, int delta) {\n retry:\n  switch (ttypetag(s2v(func))) {\n    case LUA_VCCL:  \n      return precallC(L, func, LUA_MULTRET, clCvalue(s2v(func))->f);\n    case LUA_VLCF:  \n      return precallC(L, func, LUA_MULTRET, fvalue(s2v(func)));\n    case LUA_VLCL: {  \n      Proto *p = clLvalue(s2v(func))->p;\n      int fsize = p->maxstacksize;  \n      int nfixparams = p->numparams;\n      int i;\n      ci->func -= delta;  \n      for (i = 0; i < narg1; i++)  \n        setobjs2s(L, ci->func + i, func + i);\n      checkstackGC(L, fsize);\n      func = ci->func;  \n      for (; narg1 <= nfixparams; narg1++)\n        setnilvalue(s2v(func + narg1));  \n      ci->top = func + 1 + fsize;  \n      lua_assert(ci->top <= L->stack_last);\n      ci->u.l.savedpc = p->code;  \n      ci->callstatus |= CIST_TAIL;\n      L->top = func + narg1;  \n      return -1;\n    }\n    default: {  \n      func = luaD_tryfuncTM(L, func);  \n      narg1++;\n      goto retry;  \n    }\n  }\n}", "target": 1}
{"code": "i915_gem_execbuffer_retire_commands(struct drm_device *dev,\n\t\t\t\t    struct drm_file *file,\n\t\t\t\t    struct intel_ring_buffer *ring)\n{\n\tring->gpu_caches_dirty = true;\n\t(void)i915_add_request(ring, file, NULL);\n}", "target": 0}
{"code": "bool HTMLMediaElement::ShouldShowControls(\n    const RecordMetricsBehavior record_metrics) const {\n  Settings* settings = GetDocument().GetSettings();\n  if (settings && !settings->GetMediaControlsEnabled()) {\n    if (record_metrics == RecordMetricsBehavior::kDoRecord)\n      ShowControlsHistogram().Count(kMediaControlsShowDisabledSettings);\n    return false;\n  }\n  if (FastHasAttribute(kControlsAttr)) {\n    if (record_metrics == RecordMetricsBehavior::kDoRecord)\n      ShowControlsHistogram().Count(kMediaControlsShowAttribute);\n    return true;\n  }\n  if (IsFullscreen()) {\n    if (record_metrics == RecordMetricsBehavior::kDoRecord)\n      ShowControlsHistogram().Count(kMediaControlsShowFullscreen);\n    return true;\n  }\n  LocalFrame* frame = GetDocument().GetFrame();\n  if (frame && !GetDocument().CanExecuteScripts(kNotAboutToExecuteScript)) {\n    if (record_metrics == RecordMetricsBehavior::kDoRecord)\n      ShowControlsHistogram().Count(kMediaControlsShowNoScript);\n    return true;\n  }\n  if (record_metrics == RecordMetricsBehavior::kDoRecord)\n    ShowControlsHistogram().Count(kMediaControlsShowNotShown);\n  return false;\n}", "target": 0}
{"code": "llvm::Optional<Value> simplifyBroadcast(ShapeComponentAnalysis& analysis,\n                                        ValueRange shapes, Location loc,\n                                        OpBuilder* builder) {\n  SmallVector<ArrayRef<ShapeComponentAnalysis::SymbolicExpr>> shapes_found;\n  size_t maxRank = 0;\n  for (const auto &shape : llvm::enumerate(shapes)) {\n    auto found_shape = analysis.GetValueInfo(shape.value());\n    if (!found_shape) return {};\n    shapes_found.push_back(*found_shape);\n    maxRank = std::max(maxRank, found_shape->size());\n  }\n  if (maxRank == 0) {\n    return Value(builder->create<tensor::FromElementsOp>(\n        loc, shapes[0].getType(), SmallVector<Value>()));\n  }\n  SmallVector<const ShapeComponentAnalysis::SymbolicExpr*> joined_dimensions(\n      maxRank);\n  SmallVector<std::pair<Value, int64_t>> shape_and_rank_for_dim(maxRank);\n  for (const auto &shape : llvm::enumerate(shapes_found)) {\n    for (const auto &dim : llvm::enumerate(llvm::reverse(shape.value()))) {\n      if (dim.value().isConstant(1)) continue;\n      auto index = maxRank - dim.index() - 1;\n      if (!joined_dimensions[index]) {\n        joined_dimensions[index] = &dim.value();\n        shape_and_rank_for_dim[index] =\n            std::make_pair(shapes[shape.index()], shape.value().size());\n        continue;\n      }\n      if (*joined_dimensions[index] != dim.value()) return {};\n    }\n  }\n  if (llvm::is_splat(shape_and_rank_for_dim) &&\n      shape_and_rank_for_dim[0].first) {\n    return shape_and_rank_for_dim[0].first;\n  }\n  SmallVector<Value> elements;\n  for (int i = 0; i != maxRank; ++i) {\n    if (!shape_and_rank_for_dim[i].first) {\n      auto one = builder->getIntegerAttr(\n          shapes[0].getType().cast<RankedTensorType>().getElementType(), 1);\n      elements.push_back(builder->create<ConstantOp>(loc, one));\n      continue;\n    }\n    Value index = builder->create<ConstantIndexOp>(\n        loc, i - maxRank + shape_and_rank_for_dim[i].second);\n    elements.push_back(builder->create<tensor::ExtractOp>(\n        loc, shape_and_rank_for_dim[i].first, index));\n  }\n  return Value(builder->create<tensor::FromElementsOp>(loc, elements));\n}", "target": 0}
{"code": "TEST_F(HermesRuntimeTest, SpreadHostObjectWithOwnProperties) {\n  class HostObjectWithPropertyNames : public HostObject {\n    std::vector<PropNameID> getPropertyNames(Runtime &rt) override {\n      return PropNameID::names(rt, \"prop1\", \"1\", \"2\", \"prop2\", \"3\");\n    }\n    Value get(Runtime &runtime, const PropNameID &name) override {\n      return Value();\n    }\n  };\n  Object ho = Object::createFromHostObject(\n      *rt, std::make_shared<HostObjectWithPropertyNames>());\n  rt->global().setProperty(*rt, \"ho\", ho);\n  auto res = eval(R\"###(\nvar spreaded = {...ho};\nvar props = Object.getOwnPropertyNames(spreaded);\nprops.toString();\n)###\")\n                 .getString(*rt)\n                 .utf8(*rt);\n  EXPECT_EQ(res, \"1,2,3,prop1,prop2\");\n}", "target": 0}
{"code": "void build_ntlmssp_negotiate_blob(unsigned char *pbuffer,\n\t\t\t\t\t struct cifs_ses *ses)\n{\n\tNEGOTIATE_MESSAGE *sec_blob = (NEGOTIATE_MESSAGE *)pbuffer;\n\t__u32 flags;\n\tmemset(pbuffer, 0, sizeof(NEGOTIATE_MESSAGE));\n\tmemcpy(sec_blob->Signature, NTLMSSP_SIGNATURE, 8);\n\tsec_blob->MessageType = NtLmNegotiate;\n\tflags = NTLMSSP_NEGOTIATE_56 |\tNTLMSSP_REQUEST_TARGET |\n\t\tNTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |\n\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;\n\tif (ses->server->sign) {\n\t\tflags |= NTLMSSP_NEGOTIATE_SIGN;\n\t\tif (!ses->server->session_estab ||\n\t\t\t\tses->ntlmssp->sesskey_per_smbsess)\n\t\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n\t}\n\tsec_blob->NegotiateFlags = cpu_to_le32(flags);\n\tsec_blob->WorkstationName.BufferOffset = 0;\n\tsec_blob->WorkstationName.Length = 0;\n\tsec_blob->WorkstationName.MaximumLength = 0;\n\tsec_blob->DomainName.BufferOffset = 0;\n\tsec_blob->DomainName.Length = 0;\n\tsec_blob->DomainName.MaximumLength = 0;\n}", "target": 1}
{"code": "STACK_OF(PKCS7) *PKCS12_unpack_authsafes(const PKCS12 *p12)\n{\n    STACK_OF(PKCS7) *p7s;\n    PKCS7 *p7;\n    int i;\n    if (!PKCS7_type_is_data(p12->authsafes)) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_CONTENT_TYPE_NOT_DATA);\n        return NULL;\n    }\n    if (p12->authsafes->d.data == NULL) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_DECODE_ERROR);\n        return NULL;\n    }\n    p7s = ASN1_item_unpack(p12->authsafes->d.data,\n                           ASN1_ITEM_rptr(PKCS12_AUTHSAFES));\n    if (p7s != NULL) {\n        for (i = 0; i < sk_PKCS7_num(p7s); i++) {\n            p7 = sk_PKCS7_value(p7s, i);\n            if (!ossl_pkcs7_ctx_propagate(p12->authsafes, p7))\n                goto err;\n        }\n    }\n    return p7s;\nerr:\n    sk_PKCS7_free(p7s);\n    return NULL;\n}", "target": 0}
{"code": "YCPBoolean IniAgent::Write(const YCPPath &path, const YCPValue& value, const YCPValue& arg)\n{\n    if (!parser.isStarted())\n    {\n\ty2warning(\"Can't execute Write before being mounted.\");\n\treturn YCPBoolean (false);\n    }\n    bool ok = false; \n    YCPBoolean b (true);\n    if (0 == path->length ())\n    {\n\tif (value->isString() && value->asString()->value() == \"force\")\n\t    parser.inifile.setDirty();\n\telse if (value->isString () && value->asString()->value() == \"clean\")\n\t    parser.inifile.clean ();\n\tif (0 != parser.write ())\n\t    b = false;\n\tok = true;\n    }\n    else\n    {\n\tif (( parser.repeatNames () && value->isList ()) ||\n\t    (!parser.repeatNames () &&  (value->isString () || value->isInteger())) ||\n\t    path->component_str(0) == \"all\"\n\t    )\n\t    {\n\t\tok = true;\n\t\tif (parser.inifile.Write (path, value, parser.HaveRewrites ()))\n\t\t    b = false;\n\t    }\n        else if (value->isVoid ())\n\t    {\n\t\tint wb  = -1;\n\t\tstring del_sec = \"\";\n\t\tok = true;\n\t\tif (2 == path->length ())\n\t\t{\n\t\t    string pc = path->component_str(0);\n\t\t    if (\"s\" == pc || \"section\" == pc)\n\t\t    {\t\n\t\t\tdel_sec = path->component_str (1);\n\t\t\twb = parser.inifile.getSubSectionRewriteBy (del_sec.c_str());\n\t\t    }\n\t\t}\n\t\tif (parser.inifile.Delete (path))\n\t\t    b = false;\n\t\telse if (del_sec != \"\")\n\t\t{\n\t\t    parser.deleted_sections.insert (parser.getFileName (del_sec, wb));\n\t\t}\n\t    }\n\telse\n\t{\n\t    ycp2error (\"Wrong value for path %s: %s\", path->toString ().c_str (), value->toString ().c_str ());\n\t    b = false;\n\t}\n    }\n    if (!ok)\n    {\n    \tycp2error ( \"Wrong path '%s' in Write().\", path->toString().c_str () );\n    }\n    return b;\n}", "target": 1}
{"code": "static enum sctp_ierror sctp_process_unk_param(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tunion sctp_params param,\n\t\t\t\t\tstruct sctp_chunk *chunk,\n\t\t\t\t\tstruct sctp_chunk **errp)\n{\n\tint retval = SCTP_IERROR_NO_ERROR;\n\tswitch (param.p->type & SCTP_PARAM_ACTION_MASK) {\n\tcase SCTP_PARAM_ACTION_DISCARD:\n\t\tretval =  SCTP_IERROR_ERROR;\n\t\tbreak;\n\tcase SCTP_PARAM_ACTION_SKIP:\n\t\tbreak;\n\tcase SCTP_PARAM_ACTION_DISCARD_ERR:\n\t\tretval =  SCTP_IERROR_ERROR;\n\tcase SCTP_PARAM_ACTION_SKIP_ERR:\n\t\tif (NULL == *errp)\n\t\t\t*errp = sctp_make_op_error_fixed(asoc, chunk);\n\t\tif (*errp) {\n\t\t\tif (!sctp_init_cause_fixed(*errp, SCTP_ERROR_UNKNOWN_PARAM,\n\t\t\t\t\tSCTP_PAD4(ntohs(param.p->length))))\n\t\t\t\tsctp_addto_chunk_fixed(*errp,\n\t\t\t\t\t\tSCTP_PAD4(ntohs(param.p->length)),\n\t\t\t\t\t\tparam.v);\n\t\t} else {\n\t\t\tretval = SCTP_IERROR_NOMEM;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn retval;\n}", "target": 0}
{"code": "fbCombineConjointInReverseC (CARD32 *dest, CARD32 *src, CARD32 *mask, int width)\n{\n    fbCombineConjointGeneralC (dest, src, mask, width, CombineBIn);\n}", "target": 0}
{"code": "MYSQL_PARAMETERS *STDCALL mysql_get_parameters(void)\n{\n  return &mysql_internal_parameters;\n}", "target": 0}
{"code": "_zip_cdir_new(int nentry, struct zip_error *error)\n{\n    struct zip_cdir *cd;\n    if ((cd=(struct zip_cdir *)malloc(sizeof(*cd))) == NULL) {\n\t_zip_error_set(error, ZIP_ER_MEMORY, 0);\n\treturn NULL;\n    }\n    if ( nentry > ((size_t)-1)/sizeof(*(cd->entry)) || (cd->entry=(struct zip_dirent *)malloc(sizeof(*(cd->entry))*(size_t)nentry))\n\t== NULL) {\n\t_zip_error_set(error, ZIP_ER_MEMORY, 0);\n\tfree(cd);\n\treturn NULL;\n    }\n    cd->nentry = nentry;\n    cd->size = cd->offset = 0;\n    cd->comment = NULL;\n    cd->comment_len = 0;\n    return cd;\n}", "target": 0}
{"code": "static int do_i2c_loop(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t       char *const argv[])\n{\n\tuint\tchip;\n\tint alen;\n\tuint\taddr;\n\tuint\tlength;\n\tu_char\tbytes[16];\n\tint\tdelay;\n\tint ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n#endif\n\tif (argc < 3)\n\t\treturn CMD_RET_USAGE;\n\tchip = hextoul(argv[1], NULL);\n\taddr = hextoul(argv[2], NULL);\n\talen = get_alen(argv[2], DEFAULT_ADDR_LEN);\n\tif (alen > 3)\n\t\treturn CMD_RET_USAGE;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret && alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n#endif\n\tlength = 1;\n\tlength = hextoul(argv[3], NULL);\n\tif (length > sizeof(bytes))\n\t\tlength = sizeof(bytes);\n\tdelay = 1000;\n\tif (argc > 3)\n\t\tdelay = dectoul(argv[4], NULL);\n\twhile (1) {\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\tret = dm_i2c_read(dev, addr, bytes, length);\n#else\n\t\tret = i2c_read(chip, addr, alen, bytes, length);\n#endif\n\t\tif (ret)\n\t\t\ti2c_report_err(ret, I2C_ERR_READ);\n\t\tudelay(delay);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "mptctl_replace_fw (unsigned long arg)\n{\n\tstruct mpt_ioctl_replace_fw __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_replace_fw\t karg;\n\tMPT_ADAPTER\t\t *ioc;\n\tint\t\t\t iocnum;\n\tint\t\t\t newFwSize;\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_replace_fw))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_replace_fw - \"\n\t\t\t\"Unable to read in mpt_ioctl_replace_fw struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_replace_fw() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_replace_fw called.\\n\",\n\t    ioc->name));\n\tif (ioc->cached_fw == NULL)\n\t\treturn 0;\n\tmpt_free_fw_memory(ioc);\n\tnewFwSize = ALIGN(karg.newImageSize, 4);\n\tmpt_alloc_fw_memory(ioc, newFwSize);\n\tif (ioc->cached_fw == NULL)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(ioc->cached_fw, uarg->newImage, newFwSize)) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_replace_fw - \"\n\t\t\t\t\"Unable to read in mpt_ioctl_replace_fw image \"\n\t\t\t\t\"@ %p\\n\", ioc->name, __FILE__, __LINE__, uarg);\n\t\tmpt_free_fw_memory(ioc);\n\t\treturn -EFAULT;\n\t}\n\tioc->facts.FWImageSize = newFwSize;\n\treturn 0;\n}", "target": 1}
{"code": "int stringmatchlen(const char *pattern, int patternLen,\n        const char *string, int stringLen, int nocase) {\n    int skipLongerMatches = 0;\n    return stringmatchlen_impl(pattern,patternLen,string,stringLen,nocase,&skipLongerMatches,0);\n}", "target": 0}
{"code": "static inline int process_numeric_entity(const char **buf, unsigned *code_point)\n{\n\tlong code_l;\n\tint hexadecimal = (**buf == 'x' || **buf == 'X'); \n\tchar *endptr;\n\tif (hexadecimal && (**buf != '\\0'))\n\t\t(*buf)++;\n\tif ((hexadecimal && !isxdigit(**buf)) ||\n\t\t\t(!hexadecimal && !isdigit(**buf))) {\n\t\treturn FAILURE;\n\t}\n\tcode_l = strtol(*buf, &endptr, hexadecimal ? 16 : 10);\n\t*buf = endptr;\n\tif (**buf != ';')\n\t\treturn FAILURE;\n\tif (code_l > 0x10FFFFL)\n\t\treturn FAILURE;\n\tif (code_point != NULL)\n\t\t*code_point = (unsigned)code_l;\n\treturn SUCCESS;\n}", "target": 1}
{"code": "create_principal_2_svc(cprinc_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret          ret;\n    char                        *prime_arg;\n    gss_buffer_desc             client_name, service_name;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n    restriction_t               *rp;\n    const char                  *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->rec.principal, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (CHANGEPW_SERVICE(rqstp)\n        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_ADD,\n                               arg->rec.principal, &rp)\n        || kadm5int_acl_impose_restrictions(handle->context,\n                                            &arg->rec, &arg->mask, rp)) {\n        ret.code = KADM5_AUTH_ADD;\n        log_unauth(\"kadm5_create_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_create_principal((void *)handle,\n                                          &arg->rec, arg->mask,\n                                          arg->passwd);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_create_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "static void mirror_abort(Job *job)\n{\n    int ret = mirror_exit_common(job);\n    assert(ret == 0);\n}", "target": 0}
{"code": "Status ArrayFromMemory(int dim_size, npy_intp* dims, void* data, DataType dtype,\n                       std::function<void()> destructor, PyObject** result) {\n  if (dtype == DT_STRING || dtype == DT_RESOURCE) {\n    return errors::FailedPrecondition(\n        \"Cannot convert string or resource Tensors.\");\n  }\n  int type_num = -1;\n  Status s =\n      TF_DataType_to_PyArray_TYPE(static_cast<TF_DataType>(dtype), &type_num);\n  if (!s.ok()) {\n    return s;\n  }\n  if (dim_size > NPY_MAXDIMS) {\n    return errors::InvalidArgument(\n        \"Cannot convert tensor with \", dim_size,\n        \" dimensions to NumPy array. NumPy arrays can have at most \",\n        NPY_MAXDIMS, \" dimensions\");\n  }\n  auto* np_array = reinterpret_cast<PyArrayObject*>(\n      PyArray_SimpleNewFromData(dim_size, dims, type_num, data));\n  if (np_array == nullptr) {\n    string shape_str = absl::StrJoin(\n        absl::Span<npy_intp>{dims, static_cast<size_t>(dim_size)}, \", \");\n    if (PyErr_Occurred()) {\n      string exception_str = PyExceptionFetch();\n      PyErr_Clear();\n      return errors::InvalidArgument(\n          \"Failed to create numpy array from tensor of shape [\", shape_str,\n          \"]. Numpy error: \", exception_str);\n    }\n    return errors::Internal(\n        \"Failed to create numpy array from tensor of shape [\", shape_str, \"]\");\n  }\n  PyArray_CLEARFLAGS(np_array, NPY_ARRAY_OWNDATA);\n  if (PyType_Ready(&TensorReleaserType) == -1) {\n    return errors::Unknown(\"Python type initialization failed.\");\n  }\n  auto* releaser = reinterpret_cast<TensorReleaser*>(\n      TensorReleaserType.tp_alloc(&TensorReleaserType, 0));\n  releaser->destructor = new std::function<void()>(std::move(destructor));\n  if (PyArray_SetBaseObject(np_array, reinterpret_cast<PyObject*>(releaser)) ==\n      -1) {\n    Py_DECREF(releaser);\n    return errors::Unknown(\"Python array refused to use memory.\");\n  }\n  *result = reinterpret_cast<PyObject*>(np_array);\n  return OkStatus();\n}", "target": 0}
{"code": "static inline struct nlattr *nla_next(const struct nlattr *nla, int *remaining)\n{\n\tint totlen = NLA_ALIGN(nla->nla_len);\n\t*remaining -= totlen;\n\treturn (struct nlattr *) ((char *) nla + totlen);\n}", "target": 0}
{"code": "kick_delayed_job(tube t)\n{\n    int r;\n    job j;\n    size_t z;\n    j = pq_take(&t->delay);\n    if (!j) return 0;\n    z = binlog_reserve_space_update(j);\n    if (!z) return pq_give(&t->delay, j), 0; \n    j->reserved_binlog_space += z;\n    j->kick_ct++;\n    r = enqueue_job(j, 0, 1);\n    if (r == 1) return 1;\n    r = enqueue_job(j, j->delay, 0);\n    if (r == 1) return 0;\n    bury_job(j, 0);\n    return 0;\n}", "target": 0}
{"code": "bool WasmBinaryBuilder::maybeVisitRefCast(Expression*& out, uint32_t code) {\n  if (code == BinaryConsts::RefCast) {\n    auto* rtt = popNonVoidExpression();\n    auto* ref = popNonVoidExpression();\n    out = Builder(wasm).makeRefCast(ref, rtt);\n    return true;\n  } else if (code == BinaryConsts::RefCastStatic) {\n    auto intendedType = getIndexedHeapType();\n    auto* ref = popNonVoidExpression();\n    out = Builder(wasm).makeRefCast(ref, intendedType);\n    return true;\n  }\n  return false;\n}", "target": 0}
{"code": "static inline ut16 r_read_at_le16(const void *src, size_t offset) {\n\tif (!src) {\n\t\treturn UT16_MAX;\n\t}\n\tconst ut8 *s = (const ut8*)src + offset;\n\treturn r_read_le16 (s);\n}", "target": 0}
{"code": "LUA_API void *lua_upvalueid (lua_State *L, int fidx, int n) {\n  StkId fi = index2addr(L, fidx);\n  switch (ttype(fi)) {\n    case LUA_TLCL: {  \n      return *getupvalref(L, fidx, n, NULL);\n    }\n    case LUA_TCCL: {  \n      CClosure *f = clCvalue(fi);\n      api_check(L, 1 <= n && n <= f->nupvalues, \"invalid upvalue index\");\n      return &f->upvalue[n - 1];\n    }\n    default: {\n      api_check(L, 0, \"closure expected\");\n      return NULL;\n    }\n  }\n}", "target": 1}
{"code": "static int cac_cac1_get_certificate(sc_card_t *card, u8 **out_buf, size_t *out_len)\n{\n\tu8 buf[CAC_MAX_SIZE];\n\tu8 *out_ptr;\n\tsize_t size = 0;\n\tsize_t left = 0;\n\tsize_t len, next_len;\n\tsc_apdu_t apdu;\n\tint r = SC_SUCCESS;\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tsize = left = *out_buf ? *out_len : sizeof(buf);\n\tout_ptr = *out_buf ? *out_buf : buf;\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, CAC_INS_GET_CERTIFICATE, 0, 0 );\n\tnext_len = MIN(left, 100);\n\tfor (; left > 0; left -= len, out_ptr += len) {\n\t\tlen = next_len;\n\t\tapdu.resp = out_ptr;\n\t\tapdu.le = len;\n\t\tapdu.resplen = left;\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t\tif (r < 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (apdu.resplen == 0) {\n\t\t\tr = SC_ERROR_INTERNAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (apdu.sw1 != 0x63 || apdu.sw2 < 1)  {\n\t\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\t\tleft -= len;\n\t\t\tbreak;\n\t\t}\n\t\tnext_len = MIN(left, apdu.sw2);\n\t}\n\tif (r < 0) {\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);\n\t}\n\tr = size - left;\n\tif (*out_buf == NULL) {\n\t\t*out_buf = malloc(r);\n\t\tif (*out_buf == NULL) {\n\t\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t\tSC_ERROR_OUT_OF_MEMORY);\n\t\t}\n\t\tmemcpy(*out_buf, buf, r);\n\t}\n\t*out_len = r;\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);\n}", "target": 1}
{"code": "static void parse_media(pj_scanner *scanner, pjmedia_sdp_media *med,\n\t\t\tvolatile parse_context *ctx)\n{\n    pj_str_t str;\n    ctx->last_error = PJMEDIA_SDP_EINMEDIA;\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n    pj_scan_get_until_ch(scanner, ' ', &med->desc.media);\n    pj_scan_get_char(scanner);\n    pj_scan_get(scanner, &cs_token, &str);\n    med->desc.port = (unsigned short)pj_strtoul(&str);\n    if (*scanner->curptr == '/') {\n\tpj_scan_get_char(scanner);\n\tpj_scan_get(scanner, &cs_token, &str);\n\tmed->desc.port_count = pj_strtoul(&str);\n    } else {\n\tmed->desc.port_count = 0;\n    }\n    if (pj_scan_get_char(scanner) != ' ') {\n\tPJ_THROW(SYNTAX_ERROR);\n    }\n    pj_scan_get_until_chr(scanner, \" \\t\\r\\n\", &med->desc.transport);\n    med->desc.fmt_count = 0;\n    while (*scanner->curptr == ' ') {\n\tpj_str_t fmt;\n\tpj_scan_get_char(scanner);\n\tif ((*scanner->curptr == '\\r') || (*scanner->curptr == '\\n'))\n\t\tbreak;\n\tpj_scan_get(scanner, &cs_token, &fmt);\n\tif (med->desc.fmt_count < PJMEDIA_MAX_SDP_FMT)\n\t    med->desc.fmt[med->desc.fmt_count++] = fmt;\n\telse\n\t    PJ_PERROR(2,(THIS_FILE, PJ_ETOOMANY, \n\t\t         \"Error adding SDP media format %.*s, \"\n\t\t\t \"format is ignored\",\n\t\t\t (int)fmt.slen, fmt.ptr));\n    }\n    pj_scan_skip_line(scanner);\n}", "target": 1}
{"code": "bool ConstantFolding::IsSimplifiableReshape(\n    const NodeDef& node, const GraphProperties& properties) const {\n  if (!IsReshape(node)) {\n    return false;\n  }\n  CHECK_LE(2, node.input_size());\n  const NodeDef* new_shape = node_map_->GetNode(node.input(1));\n  if (!IsReallyConstant(*new_shape)) {\n    return false;\n  }\n  TensorVector outputs;\n  auto outputs_cleanup = gtl::MakeCleanup([&outputs] {\n    for (const auto& output : outputs) {\n      delete output.tensor;\n    }\n  });\n  Status s = EvaluateNode(*new_shape, TensorVector(), &outputs);\n  if (!s.ok()) {\n    return false;\n  }\n  CHECK_EQ(1, outputs.size());\n  const std::vector<OpInfo::TensorProperties>& props =\n      properties.GetInputProperties(node.name());\n  if (props.empty()) {\n    return false;\n  }\n  const OpInfo::TensorProperties& prop = props[0];\n  if (prop.dtype() == DT_INVALID) {\n    return false;\n  }\n  const PartialTensorShape shape(prop.shape());\n  if (!shape.IsFullyDefined()) {\n    return false;\n  }\n  PartialTensorShape new_dims;\n  if (outputs[0]->dtype() == DT_INT32) {\n    std::vector<int32> shp;\n    for (int i = 0; i < outputs[0]->NumElements(); ++i) {\n      int32_t dim = outputs[0]->flat<int32>()(i);\n      shp.push_back(dim);\n    }\n    TF_CHECK_OK(TensorShapeUtils::MakeShape(shp, &new_dims));\n  } else {\n    std::vector<int64_t> shp;\n    for (int i = 0; i < outputs[0]->NumElements(); ++i) {\n      int64_t dim = outputs[0]->flat<int64_t>()(i);\n      shp.push_back(dim);\n    }\n    TF_CHECK_OK(TensorShapeUtils::MakeShape(shp, &new_dims));\n  }\n  return shape.IsCompatibleWith(new_dims);\n}", "target": 1}
{"code": "void test_access(const char *path)\n{\n\tif (access(path, O_RDONLY) >= 0) {\n\t\tfprintf(stderr, \"leak at access of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT) {\n\t\tfprintf(stderr, \"leak at access of %s: errno was %d\\n\", path, errno);\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "static void dhcps_send_ack(struct pbuf *packet_buffer)\n{\n\tdhcp_message_repository = (struct dhcp_msg *)packet_buffer->payload;\n\tdhcps_initialize_message(dhcp_message_repository);\n\tadd_offer_options(add_msg_type(&dhcp_message_repository->options[4],\n\t\t\t      \t\t\tDHCP_MESSAGE_TYPE_ACK));\n\tudp_sendto_if(dhcps_pcb, packet_buffer,\n\t\t   &dhcps_send_broadcast_address, DHCP_CLIENT_PORT, dhcps_netif);\n}", "target": 1}
{"code": "static int crypto_nivaead_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_aead raead;\n\tstruct aead_alg *aead = &alg->cra_aead;\n\tsnprintf(raead.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"nivaead\");\n\tsnprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, \"%s\", aead->geniv);\n\traead.blocksize = alg->cra_blocksize;\n\traead.maxauthsize = aead->maxauthsize;\n\traead.ivsize = aead->ivsize;\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_AEAD,\n\t\t    sizeof(struct crypto_report_aead), &raead))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "MagickExport void *DetachBlob(BlobInfo *blob_info)\n{\n  void\n    *data;\n  assert(blob_info != (BlobInfo *) NULL);\n  if (blob_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  if (blob_info->mapped != MagickFalse)\n    {\n      (void) UnmapBlob(blob_info->data,blob_info->length);\n      blob_info->data=NULL;\n      RelinquishMagickResource(MapResource,blob_info->length);\n    }\n  blob_info->mapped=MagickFalse;\n  blob_info->length=0;\n  blob_info->offset=0;\n  blob_info->eof=MagickFalse;\n  blob_info->error=0;\n  blob_info->exempt=MagickFalse;\n  blob_info->type=UndefinedStream;\n  blob_info->file_info.file=(FILE *) NULL;\n  data=blob_info->data;\n  blob_info->data=(unsigned char *) NULL;\n  blob_info->stream=(StreamHandler) NULL;\n  blob_info->custom_stream=(CustomStreamInfo *) NULL;\n  return(data);\n}", "target": 0}
{"code": "int migrate_page_move_mapping(struct address_space *mapping,\n\t\tstruct page *newpage, struct page *page,\n\t\tstruct buffer_head *head, enum migrate_mode mode,\n\t\tint extra_count)\n{\n\tint expected_count = 1 + extra_count;\n\tvoid **pslot;\n\tif (!mapping) {\n\t\tif (page_count(page) != expected_count)\n\t\t\treturn -EAGAIN;\n\t\tset_page_memcg(newpage, page_memcg(page));\n\t\tnewpage->index = page->index;\n\t\tnewpage->mapping = page->mapping;\n\t\tif (PageSwapBacked(page))\n\t\t\tSetPageSwapBacked(newpage);\n\t\treturn MIGRATEPAGE_SUCCESS;\n\t}\n\tspin_lock_irq(&mapping->tree_lock);\n\tpslot = radix_tree_lookup_slot(&mapping->page_tree,\n \t\t\t\t\tpage_index(page));\n\texpected_count += 1 + page_has_private(page);\n\tif (page_count(page) != expected_count ||\n\t\tradix_tree_deref_slot_protected(pslot, &mapping->tree_lock) != page) {\n\t\tspin_unlock_irq(&mapping->tree_lock);\n\t\treturn -EAGAIN;\n\t}\n\tif (!page_freeze_refs(page, expected_count)) {\n\t\tspin_unlock_irq(&mapping->tree_lock);\n\t\treturn -EAGAIN;\n\t}\n\tif (mode == MIGRATE_ASYNC && head &&\n\t\t\t!buffer_migrate_lock_buffers(head, mode)) {\n\t\tpage_unfreeze_refs(page, expected_count);\n\t\tspin_unlock_irq(&mapping->tree_lock);\n\t\treturn -EAGAIN;\n\t}\n\tset_page_memcg(newpage, page_memcg(page));\n\tnewpage->index = page->index;\n\tnewpage->mapping = page->mapping;\n\tif (PageSwapBacked(page))\n\t\tSetPageSwapBacked(newpage);\n\tget_page(newpage);\t\n\tif (PageSwapCache(page)) {\n\t\tSetPageSwapCache(newpage);\n\t\tset_page_private(newpage, page_private(page));\n\t}\n\tradix_tree_replace_slot(pslot, newpage);\n\tpage_unfreeze_refs(page, expected_count - 1);\n\t__dec_zone_page_state(page, NR_FILE_PAGES);\n\t__inc_zone_page_state(newpage, NR_FILE_PAGES);\n\tif (!PageSwapCache(page) && PageSwapBacked(page)) {\n\t\t__dec_zone_page_state(page, NR_SHMEM);\n\t\t__inc_zone_page_state(newpage, NR_SHMEM);\n\t}\n\tspin_unlock_irq(&mapping->tree_lock);\n\treturn MIGRATEPAGE_SUCCESS;\n}", "target": 1}
{"code": "static int atusb_get_and_show_revision(struct atusb *atusb)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tunsigned char buffer[3];\n\tint ret;\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_ID, ATUSB_REQ_FROM_DEV, 0, 0,\n\t\t\t\tbuffer, 3, 1000);\n\tif (ret >= 0) {\n\t\tatusb->fw_ver_maj = buffer[0];\n\t\tatusb->fw_ver_min = buffer[1];\n\t\tatusb->fw_hw_type = buffer[2];\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware: major: %u, minor: %u, hardware type: %u\\n\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min, atusb->fw_hw_type);\n\t}\n\tif (atusb->fw_ver_maj == 0 && atusb->fw_ver_min < 2) {\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware version (%u.%u) predates our first public release.\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min);\n\t\tdev_info(&usb_dev->dev, \"Please update to version 0.2 or newer\");\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static void *nested_svm_map(struct vcpu_svm *svm, u64 gpa, struct page **_page)\n{\n\tstruct page *page;\n\tmight_sleep();\n\tpage = gfn_to_page(svm->vcpu.kvm, gpa >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\tgoto error;\n\t*_page = page;\n\treturn kmap(page);\nerror:\n\tkvm_inject_gp(&svm->vcpu, 0);\n\treturn NULL;\n}", "target": 0}
{"code": "int CLASS ljpeg_start (struct jhead *jh, int info_only)\n{\n  int c, tag, len;\n  uchar data[0x10000];\n  const uchar *dp;\n  memset (jh, 0, sizeof *jh);\n  jh->restart = INT_MAX;\n  fread (data, 2, 1, ifp);\n  if (data[1] != 0xd8) return 0;\n  do {\n    fread (data, 2, 2, ifp);\n    tag =  data[0] << 8 | data[1];\n    len = (data[2] << 8 | data[3]) - 2;\n    if (tag <= 0xff00) return 0;\n    fread (data, 1, len, ifp);\n    switch (tag) {\n      case 0xffc3:\n\tjh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;\n      case 0xffc0:\n\tjh->bits = data[0];\n\tjh->high = data[1] << 8 | data[2];\n\tjh->wide = data[3] << 8 | data[4];\n\tjh->clrs = data[5] + jh->sraw;\n\tif (len == 9 && !dng_version) getc(ifp);\n\tbreak;\n      case 0xffc4:\n\tif (info_only) break;\n\tfor (dp = data; dp < data+len && (c = *dp++) < 4; )\n\t  jh->free[c] = jh->huff[c] = make_decoder_ref (&dp);\n\tbreak;\n      case 0xffda:\n\tjh->psv = data[1+data[0]*2];\n\tjh->bits -= data[3+data[0]*2] & 15;\n\tbreak;\n      case 0xffdd:\n\tjh->restart = data[0] << 8 | data[1];\n    }\n  } while (tag != 0xffda);\n  if (info_only) return 1;\n  if (jh->clrs > 6 || !jh->huff[0]) return 0;\n  FORC(5) if (!jh->huff[c+1]) jh->huff[c+1] = jh->huff[c];\n  if (jh->sraw) {\n    FORC(4)        jh->huff[2+c] = jh->huff[1];\n    FORC(jh->sraw) jh->huff[1+c] = jh->huff[0];\n  }\n  jh->row = (ushort *) calloc (jh->wide*jh->clrs, 4);\n  merror (jh->row, \"ljpeg_start()\");\n  return zero_after_ff = 1;\n}", "target": 1}
{"code": "static void infra_ip_create_ratedata(struct infra_cache* infra,\n\tstruct sockaddr_storage* addr, socklen_t addrlen, time_t timenow)\n{\n\thashvalue_type h = hash_addr(addr, addrlen, 0);\n\tstruct ip_rate_key* k = (struct ip_rate_key*)calloc(1, sizeof(*k));\n\tstruct ip_rate_data* d = (struct ip_rate_data*)calloc(1, sizeof(*d));\n\tif(!k || !d) {\n\t\tfree(k);\n\t\tfree(d);\n\t\treturn; \n\t}\n\tk->addr = *addr;\n\tk->addrlen = addrlen;\n\tlock_rw_init(&k->entry.lock);\n\tk->entry.hash = h;\n\tk->entry.key = k;\n\tk->entry.data = d;\n\td->qps[0] = 1;\n\td->timestamp[0] = timenow;\n\tslabhash_insert(infra->client_ip_rates, h, &k->entry, d, NULL);\n}", "target": 1}
{"code": "noscale(j_decompress_ptr cinfo,\n        JDIFFROW diff_buf, _JSAMPROW output_buf, JDIMENSION width)\n{\n  do {\n#if BITS_IN_JSAMPLE == 12\n    *output_buf++ = (_JSAMPLE)((*diff_buf++) & 0xFFF);\n#else\n    *output_buf++ = (_JSAMPLE)(*diff_buf++);\n#endif\n  } while (--width);\n}", "target": 0}
{"code": "static int ip_identify_match_check(void *obj, void *arg, int flags)\n{\n\tstruct ip_identify_match *identify = obj;\n\tstruct ast_sockaddr_with_tp *addr_with_tp = arg;\n\tstruct ast_sockaddr address = addr_with_tp->addr;\n\tint sense;\n\tsense = ast_apply_ha(identify->matches, &address);\n\tif (sense != AST_SENSE_ALLOW) {\n\t\tast_debug(3, \"Address %s matches identify '%s'\\n\",\n\t\t\t\tast_sockaddr_stringify(&address),\n\t\t\t\tast_sorcery_object_get_id(identify));\n\t\tif (ast_strlen_zero(identify->transport) || !strcasecmp(identify->transport, addr_with_tp->tp)) {\n\t\t\tast_debug(3, \"Transport %s matches identify '%s'\\n\",\n\t\t\t\taddr_with_tp->tp,\n\t\t\t\tast_sorcery_object_get_id(identify));\n\t\t\treturn CMP_MATCH;\n\t\t} else {\n\t\t\tast_debug(3, \"Transport %s match not matched identify '%s'\\n\",\n\t\t\t\taddr_with_tp->tp,\n\t\t\t\tast_sorcery_object_get_id(identify));\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tast_debug(3, \"Address %s does not match identify '%s'\\n\",\n\t\t\t\tast_sockaddr_stringify(&address),\n\t\t\t\tast_sorcery_object_get_id(identify));\n\t\treturn 0;\n\t}\n}", "target": 1}
{"code": "static __inline__ int scm_check_creds(struct ucred *creds)\n{\n\tconst struct cred *cred = current_cred();\n\tkuid_t uid = make_kuid(cred->user_ns, creds->uid);\n\tkgid_t gid = make_kgid(cred->user_ns, creds->gid);\n\tif (!uid_valid(uid) || !gid_valid(gid))\n\t\treturn -EINVAL;\n\tif ((creds->pid == task_tgid_vnr(current) ||\n\t     ns_capable(task_active_pid_ns(current)->user_ns, CAP_SYS_ADMIN)) &&\n\t    ((uid_eq(uid, cred->uid)   || uid_eq(uid, cred->euid) ||\n\t      uid_eq(uid, cred->suid)) || nsown_capable(CAP_SETUID)) &&\n\t    ((gid_eq(gid, cred->gid)   || gid_eq(gid, cred->egid) ||\n\t      gid_eq(gid, cred->sgid)) || nsown_capable(CAP_SETGID))) {\n\t       return 0;\n\t}\n\treturn -EPERM;\n}", "target": 0}
{"code": "do_macro(uschar *p)\n{\nint length;\nint nest = 0;\nargstr **pp;\nmacrodef *md = misc_malloc(sizeof(macrodef));\nmd->name = misc_readitem(p, NULL, &length, NULL, 0);\nmd->namelength = Ustrlen(md->name);\np += length;\nif (length == 0)\n  {\n  error(14);\n  return;\n  }\nmd->lines = md->args = NULL;\nmd->next = macrolist;\nmacrolist = md;\npp = &(md->args);\nwhile (*p != 0)\n  {\n  argstr *as = misc_malloc(sizeof(argstr));\n  as->next = NULL;\n  *pp = as;\n  pp = &(as->next);\n  as->string = misc_readitem(p, NULL, &length, NULL, 0);\n  p += length;\n  }\npp = &(md->lines);\nfor (;;)\n  {\n  argstr *as;\n  uschar *line = read_nextline();\n  if (line == NULL) { error(13, \".endmacro\"); return; }\n  if (Ustrncmp(line, \".macro \", 7) == 0) nest++;\n  else if (Ustrncmp(line, \".endmacro\", 9) == 0)\n    {\n    if (isspace(line[9]) || line[9] == '\\n')\n    if (--nest < 0) break;\n    }\n  as = misc_malloc(sizeof(argstr));\n  as->next = NULL;\n  *pp = as;\n  pp = &(as->next);\n  as->string = misc_copystring(line, Ustrlen(line));\n  }\nif (md->lines == NULL)\n  {\n  md->lines = misc_malloc(sizeof(argstr));\n  md->lines->next = NULL;\n  md->lines->string = misc_copystring(US\". Dummy line\\n\", 13);\n  }\n}", "target": 1}
{"code": "const u32 *gf_isom_get_track_switch_parameter(GF_ISOFile *movie, u32 trackNumber, u32 group_index, u32 *switchGroupID, u32 *criteriaListSize)\n{\n\tGF_TrackBox *trak;\n\tGF_UserDataMap *map;\n\tGF_TrackSelectionBox *tsel;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!group_index || !trak || !trak->udta) return NULL;\n\tmap = udta_getEntry(trak->udta, GF_ISOM_BOX_TYPE_TSEL, NULL);\n\tif (!map) return NULL;\n\ttsel = (GF_TrackSelectionBox*)gf_list_get(map->boxes, group_index-1);\n\tif (!tsel) return NULL;\n\t*switchGroupID = tsel->switchGroup;\n\t*criteriaListSize = tsel->attributeListCount;\n\treturn (const u32 *) tsel->attributeList;\n}", "target": 0}
{"code": "  virtual ~AuthAuthorizerChallenge() {}", "target": 0}
{"code": "ctcompare(const char *a,\t\t\n          const char *b)\t\t\n{\n  int\tresult = 0;\t\t\t\n  while (*a && *b)\n  {\n    result |= *a ^ *b;\n    a ++;\n    b ++;\n  }\n  return (result);\n}", "target": 1}
{"code": "bool CxImage::Transfer(CxImage &from, bool bTransferFrames )\n{\n\tif (!Destroy())\n\t\treturn false;\n\tmemcpy(&head,&from.head,sizeof(BITMAPINFOHEADER));\n\tmemcpy(&info,&from.info,sizeof(CXIMAGEINFO));\n\tpDib = from.pDib;\n\tpSelection = from.pSelection;\n\tpAlpha = from.pAlpha;\n\tppLayers = from.ppLayers;\n\tmemset(&from.head,0,sizeof(BITMAPINFOHEADER));\n\tmemset(&from.info,0,sizeof(CXIMAGEINFO));\n\tfrom.pDib = from.pSelection = from.pAlpha = NULL;\n\tfrom.ppLayers = NULL;\n\tif (bTransferFrames){\n\t\tDestroyFrames();\n\t\tppFrames = from.ppFrames;\n\t\tfrom.ppFrames = NULL;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "static int umocktypes_are_equal_bool_ptr(bool** left, bool** right)\n{\n    int result;\n    if (*left == *right)\n    {\n        result = 1;\n    }\n    else\n    {\n        if (*(*left) == *(*right))\n        {\n            result = 1;\n        }\n        else\n        {\n            result = 0;\n        }\n    }\n    return result;\n}", "target": 0}
{"code": "static void update_attr(struct vc_data *vc)\n{\n\tvc->vc_attr = build_attr(vc, vc->vc_color, vc->vc_intensity,\n\t              vc->vc_blink, vc->vc_underline,\n\t              vc->vc_reverse ^ vc->vc_decscnm, vc->vc_italic);\n\tvc->vc_video_erase_char = (build_attr(vc, vc->vc_color, 1, vc->vc_blink, 0, vc->vc_decscnm, 0) << 8) | ' ';\n}", "target": 0}
{"code": "lldpd_alloc_mgmt(int family, void *addrptr, size_t addrsize, u_int32_t iface)\n{\n\tstruct lldpd_mgmt *mgmt;\n\tlog_debug(\"alloc\", \"allocate a new management address (family: %d)\", family);\n\tif (family <= LLDPD_AF_UNSPEC || family >= LLDPD_AF_LAST) {\n\t\terrno = EAFNOSUPPORT;\n\t\treturn NULL;\n\t}\n\tif (addrsize > LLDPD_MGMT_MAXADDRSIZE) {\n\t\terrno = EOVERFLOW;\n\t\treturn NULL;\n\t}\n\tmgmt = calloc(1, sizeof(struct lldpd_mgmt));\n\tif (mgmt == NULL) {\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\tmgmt->m_family = family;\n\tassert(addrsize <= LLDPD_MGMT_MAXADDRSIZE);\n\tmemcpy(&mgmt->m_addr, addrptr, addrsize);\n\tmgmt->m_addrsize = addrsize;\n\tmgmt->m_iface = iface;\n\treturn mgmt;\n}", "target": 1}
{"code": "static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)\n{\n\tstruct mmu_gather tlb;\n\tstruct vm_area_struct *vma;\n\tbool ret = true;\n\tmutex_lock(&oom_lock);\n\tif (!down_read_trylock(&mm->mmap_sem)) {\n\t\tret = false;\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\tgoto unlock_oom;\n\t}\n\tif (mm_has_notifiers(mm)) {\n\t\tup_read(&mm->mmap_sem);\n\t\tschedule_timeout_idle(HZ);\n\t\tgoto unlock_oom;\n\t}\n\tif (test_bit(MMF_OOM_SKIP, &mm->flags)) {\n\t\tup_read(&mm->mmap_sem);\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\tgoto unlock_oom;\n\t}\n\ttrace_start_task_reaping(tsk->pid);\n\tset_bit(MMF_UNSTABLE, &mm->flags);\n\ttlb_gather_mmu(&tlb, mm, 0, -1);\n\tfor (vma = mm->mmap ; vma; vma = vma->vm_next) {\n\t\tif (!can_madv_dontneed_vma(vma))\n\t\t\tcontinue;\n\t\tif (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED))\n\t\t\tunmap_page_range(&tlb, vma, vma->vm_start, vma->vm_end,\n\t\t\t\t\t NULL);\n\t}\n\ttlb_finish_mmu(&tlb, 0, -1);\n\tpr_info(\"oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\",\n\t\t\ttask_pid_nr(tsk), tsk->comm,\n\t\t\tK(get_mm_counter(mm, MM_ANONPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_FILEPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_SHMEMPAGES)));\n\tup_read(&mm->mmap_sem);\n\ttrace_finish_task_reaping(tsk->pid);\nunlock_oom:\n\tmutex_unlock(&oom_lock);\n\treturn ret;\n}", "target": 1}
{"code": "isakmp_rfc3948_print(netdissect_options *ndo,\n\t\t     const u_char *bp, u_int length,\n\t\t     const u_char *bp2)\n{\n\tif(length == 1 && bp[0]==0xff) {\n\t\tND_PRINT((ndo, \"isakmp-nat-keep-alive\"));\n\t\treturn;\n\t}\n\tif(length < 4) {\n\t\tgoto trunc;\n\t}\n\tif(bp[0]==0 && bp[1]==0 && bp[2]==0 && bp[3]==0) {\n\t\tND_PRINT((ndo, \"NONESP-encap: \"));\n\t\tisakmp_print(ndo, bp+4, length-4, bp2);\n\t\treturn;\n\t}\n\t{\n\t\tint nh, enh, padlen;\n\t\tint advance;\n\t\tND_PRINT((ndo, \"UDP-encap: \"));\n\t\tadvance = esp_print(ndo, bp, length, bp2, &enh, &padlen);\n\t\tif(advance <= 0)\n\t\t\treturn;\n\t\tbp += advance;\n\t\tlength -= advance + padlen;\n\t\tnh = enh & 0xff;\n\t\tip_print_inner(ndo, bp, length, nh, bp2);\n\t\treturn;\n\t}\ntrunc:\n\tND_PRINT((ndo,\"[|isakmp]\"));\n\treturn;\n}", "target": 1}
{"code": "SanMatcherPtr createStringSanMatcher(\n    envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher const& matcher) {\n  static_assert(envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::SanType_MAX ==\n                4);\n  switch (matcher.san_type()) {\n  case envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::DNS:\n    return SanMatcherPtr{std::make_unique<StringSanMatcher>(GEN_DNS, matcher.matcher())};\n  case envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::EMAIL:\n    return SanMatcherPtr{std::make_unique<StringSanMatcher>(GEN_EMAIL, matcher.matcher())};\n  case envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::URI:\n    return SanMatcherPtr{std::make_unique<StringSanMatcher>(GEN_URI, matcher.matcher())};\n  case envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::IP_ADDRESS:\n    return SanMatcherPtr{std::make_unique<StringSanMatcher>(GEN_IPADD, matcher.matcher())};\n  default:\n    NOT_REACHED_GCOVR_EXCL_LINE;\n  }\n}", "target": 0}
{"code": "static void prep_new_huge_page(struct hstate *h, struct page *page, int nid)\n{\n\t__prep_new_huge_page(h, page);\n\tspin_lock_irq(&hugetlb_lock);\n\t__prep_account_new_huge_page(h, nid);\n\tspin_unlock_irq(&hugetlb_lock);\n}", "target": 0}
{"code": "static void dp8393x_register_types(void)\n{\n    type_register_static(&dp8393x_info);\n}", "target": 0}
{"code": "inline bool CheckForOverflow<Eigen::half>(double as_double, Eigen::half* out) {\n  return (sizeof(Eigen::half) < sizeof(double) &&\n          Eigen::half_impl::isinf(*out) && std::isfinite(as_double));\n}", "target": 0}
{"code": "static RList *r_bin_wasm_get_global_entries (RBinWasmObj *bin, RBinWasmSection *sec) {\n\tRList *ret = NULL;\n\tRBinWasmGlobalEntry *ptr = NULL;\n\tint buflen = bin->buf->length;\n\tif (sec->payload_data + 32 > buflen) {\n\t\treturn NULL;\n\t}\n\tif (!(ret = r_list_newf ((RListFree)free))) {\n\t\treturn NULL;\n\t}\n\tut8* buf = bin->buf->buf + (ut32)sec->payload_data;\n\tut32 len =  sec->payload_len;\n\tut32 count = sec->count;\n\tut32 i = 0, r = 0;\n\twhile (i < len && len < buflen && r < count) {\n\t\tif (!(ptr = R_NEW0 (RBinWasmGlobalEntry))) {\n\t\t\treturn ret;\n\t\t}\n\t\tif (len + 8 > buflen || !(consume_u8 (buf + i, buf + len, (ut8*)&ptr->content_type, &i))) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (len + 8 > buflen || !(consume_u8 (buf + i, buf + len, &ptr->mutability, &i))) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (len + 8 > buflen || !(consume_init_expr (buf + i, buf + len, R_BIN_WASM_END_OF_CODE, NULL, &i))) {\n\t\t\tgoto beach;\n\t\t}\n\t\tr_list_append (ret, ptr);\n\t\tr++;\n\t}\n\treturn ret;\nbeach:\n\tfree (ptr);\n\treturn ret;\n}", "target": 1}
{"code": "  void expectTrailers(\n      std::function<void()> callback = std::function<void()>()) {\n    if (callback) {\n      EXPECT_CALL(*this, onTrailers(testing::_))\n          .WillOnce(testing::InvokeWithoutArgs(callback))\n          .RetiresOnSaturation();\n    } else {\n      EXPECT_CALL(*this, onTrailers(testing::_));\n    }\n  }", "target": 0}
{"code": "format_nstime_as_iso8601(gchar *buf, size_t buflen, const nstime_t *ns,\n    char *decimal_point, gboolean local, int precision)\n{\n\tstruct tm tm, *tmp;\n\tgchar *ptr;\n\tsize_t buf_remaining;\n\tint num_chars;\n\tif (local)\n\t\ttmp = ws_localtime_r(&ns->secs, &tm);\n\telse\n\t\ttmp = ws_gmtime_r(&ns->secs, &tm);\n\tif (tmp == NULL) {\n\t\tsnprintf(buf, buflen, \"Not representable\");\n\t\treturn;\n\t}\n\tptr = buf;\n\tbuf_remaining = buflen;\n\tnum_chars = snprintf(ptr, buf_remaining,\n\t    \"%04d-%02d-%02d %02d:%02d:%02d\",\n\t    tmp->tm_year + 1900,\n\t    tmp->tm_mon + 1,\n\t    tmp->tm_mday,\n\t    tmp->tm_hour,\n\t    tmp->tm_min,\n\t    tmp->tm_sec);\n\tif (num_chars < 0) {\n\t\tsnprintf(buf, buflen, \"snprintf() failed\");\n\t\treturn;\n\t}\n\tif ((unsigned int)num_chars >= buf_remaining) {\n\t\treturn;\n\t}\n\tptr += num_chars;\n\tbuf_remaining -= num_chars;\n\tif (precision == 0) {\n\t\treturn;\n\t}\n\tformat_fractional_part_nsecs(ptr, buf_remaining, (guint32)ns->nsecs, decimal_point, precision);\n}", "target": 1}
{"code": "int ar6000_create_ap_interface(struct ar6_softc *ar, char *ap_ifname)\n{\n    struct net_device *dev;\n    struct ar_virtual_interface *arApDev;\n    dev = alloc_etherdev(sizeof(struct ar_virtual_interface));\n    if (dev == NULL) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"ar6000_create_ap_interface: can't alloc etherdev\\n\"));\n        return A_ERROR;\n    } \n    ether_setup(dev);\n    init_netdev(dev, ap_ifname);\n    dev->priv_flags &= ~IFF_TX_SKB_SHARING;\n    if (register_netdev(dev)) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"ar6000_create_ap_interface: register_netdev failed\\n\"));\n        return A_ERROR;\n    }\n    arApDev = netdev_priv(dev);\n    arApDev->arDev = ar;\n    arApDev->arNetDev = dev;\n    arApDev->arStaNetDev = ar->arNetDev;\n    ar->arApDev = arApDev;\n    arApNetDev = dev;\n    memcpy(dev->dev_addr, ar->arNetDev->dev_addr, AR6000_ETH_ADDR_LEN);\n    return 0;\n}", "target": 0}
{"code": "void RenderView::OnDownloadFavIcon(int id,\n                                   const GURL& image_url,\n                                   int image_size) {\n  bool data_image_failed = false;\n  if (image_url.SchemeIs(\"data\")) {\n    SkBitmap data_image = ImageFromDataUrl(image_url);\n    data_image_failed = data_image.empty();\n    if (!data_image_failed) {\n      Send(new ViewHostMsg_DidDownloadFavIcon(routing_id_, id, image_url, false,\n                                              data_image));\n    }\n  }\n  if (data_image_failed ||\n      !DownloadImage(id, image_url, image_size)) {\n    Send(new ViewHostMsg_DidDownloadFavIcon(routing_id_, id, image_url, true,\n                                            SkBitmap()));\n  }\n}", "target": 0}
{"code": "static void audit_log_execve_info(struct audit_context *context,\n\t\t\t\t  struct audit_buffer **ab)\n{\n\tint i, len;\n\tsize_t len_sent = 0;\n\tconst char __user *p;\n\tchar *buf;\n\tp = (const char __user *)current->mm->arg_start;\n\taudit_log_format(*ab, \"argc=%d\", context->execve.argc);\n\tbuf = kmalloc(MAX_EXECVE_AUDIT_LEN + 1, GFP_KERNEL);\n\tif (!buf) {\n\t\taudit_panic(\"out of memory for argv string\");\n\t\treturn;\n\t}\n\tfor (i = 0; i < context->execve.argc; i++) {\n\t\tlen = audit_log_single_execve_arg(context, ab, i,\n\t\t\t\t\t\t  &len_sent, p, buf);\n\t\tif (len <= 0)\n\t\t\tbreak;\n\t\tp += len;\n\t}\n\tkfree(buf);\n}", "target": 1}
{"code": "  absl::string_view failureReason() const override { return NotReadyReason; }", "target": 0}
{"code": "CURLcode Curl_smtp_escape_eob(struct connectdata *conn, const ssize_t nread)\n{\n  ssize_t i;\n  ssize_t si;\n  struct Curl_easy *data = conn->data;\n  struct SMTP *smtp = data->req.protop;\n  char *scratch = data->state.scratch;\n  char *newscratch = NULL;\n  char *oldscratch = NULL;\n  size_t eob_sent;\n  if(!scratch || data->set.crlf) {\n    oldscratch = scratch;\n    scratch = newscratch = malloc(2 * data->set.buffer_size);\n    if(!newscratch) {\n      failf(data, \"Failed to alloc scratch buffer!\");\n      return CURLE_OUT_OF_MEMORY;\n    }\n  }\n  eob_sent = smtp->eob;\n  for(i = 0, si = 0; i < nread; i++) {\n    if(SMTP_EOB[smtp->eob] == data->req.upload_fromhere[i]) {\n      smtp->eob++;\n      if(2 == smtp->eob || SMTP_EOB_LEN == smtp->eob)\n        smtp->trailing_crlf = TRUE;\n      else\n        smtp->trailing_crlf = FALSE;\n    }\n    else if(smtp->eob) {\n      memcpy(&scratch[si], &SMTP_EOB[eob_sent], smtp->eob - eob_sent);\n      si += smtp->eob - eob_sent;\n      if(SMTP_EOB[0] == data->req.upload_fromhere[i])\n        smtp->eob = 1;\n      else\n        smtp->eob = 0;\n      eob_sent = 0;\n      smtp->trailing_crlf = FALSE;\n    }\n    if(SMTP_EOB_FIND_LEN == smtp->eob) {\n      memcpy(&scratch[si], &SMTP_EOB_REPL[eob_sent],\n             SMTP_EOB_REPL_LEN - eob_sent);\n      si += SMTP_EOB_REPL_LEN - eob_sent;\n      smtp->eob = 0;\n      eob_sent = 0;\n    }\n    else if(!smtp->eob)\n      scratch[si++] = data->req.upload_fromhere[i];\n  }\n  if(smtp->eob - eob_sent) {\n    memcpy(&scratch[si], &SMTP_EOB[eob_sent], smtp->eob - eob_sent);\n    si += smtp->eob - eob_sent;\n  }\n  if(si != nread) {\n    data->req.upload_fromhere = scratch;\n    data->state.scratch = scratch;\n    free(oldscratch);\n    data->req.upload_present = si;\n  }\n  else\n    free(newscratch);\n  return CURLE_OK;\n}", "target": 1}
{"code": "v8::Handle<v8::Value> V8ThrowException::throwTypeError(v8::Isolate* isolate, const String& message)\n{\n    v8::Handle<v8::Value> exception = V8ThrowException::createTypeError(isolate, message);\n    return V8ThrowException::throwException(exception, isolate);\n}", "target": 0}
{"code": "mp_obj_t mp_vfs_umount(mp_obj_t mnt_in) {\n    mp_vfs_mount_t *vfs = NULL;\n    size_t mnt_len;\n    const char *mnt_str = NULL;\n    if (mp_obj_is_str(mnt_in)) {\n        mnt_str = mp_obj_str_get_data(mnt_in, &mnt_len);\n    }\n    for (mp_vfs_mount_t **vfsp = &MP_STATE_VM(vfs_mount_table); *vfsp != NULL; vfsp = &(*vfsp)->next) {\n        if ((mnt_str != NULL && !memcmp(mnt_str, (*vfsp)->str, mnt_len + 1)) || (*vfsp)->obj == mnt_in) {\n            vfs = *vfsp;\n            *vfsp = (*vfsp)->next;\n            break;\n        }\n    }\n    if (vfs == NULL) {\n        mp_raise_OSError(MP_EINVAL);\n    }\n    if (MP_STATE_VM(vfs_cur) == vfs) {\n        MP_STATE_VM(vfs_cur) = MP_VFS_ROOT;\n    }\n    mp_vfs_proxy_call(vfs, MP_QSTR_umount, 0, NULL);\n    return mp_const_none;\n}", "target": 1}
{"code": "void CUser::SetClientEncoding(const CString& s) {\n    m_sClientEncoding = s;\n    for (CClient* pClient : GetAllClients()) {\n        pClient->SetEncoding(s);\n    }\n}", "target": 1}
{"code": "TEST_F(HeaderToMetadataTest, CookieValueUsed) {\n  const std::string response_config_yaml = R\"EOF(\nresponse_rules:\n  - cookie: bar\n    on_header_present:\n      key: bar\n      type: STRING\n    remove: false\n)EOF\";\n  initializeFilter(response_config_yaml);\n  Http::TestResponseHeaderMapImpl incoming_headers{{\"cookie\", \"bar=foo\"}};\n  std::map<std::string, std::string> expected = {{\"bar\", \"foo\"}};\n  EXPECT_CALL(encoder_callbacks_, streamInfo()).WillRepeatedly(ReturnRef(req_info_));\n  EXPECT_CALL(req_info_,\n              setDynamicMetadata(HttpFilterNames::get().HeaderToMetadata, MapEq(expected)));\n  EXPECT_EQ(Http::FilterHeadersStatus::Continue, filter_->encodeHeaders(incoming_headers, false));\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, CantExplodeMetaSort) {\n    addIndex(BSON(\"a\" << 1 << \"b\" << 1 << \"c\"\n                      << \"text\"));\n    runQuerySortProj(fromjson(\"{a: {$in: [1, 2]}, b: {$in: [3, 4]}}\"),\n                     fromjson(\"{c: {$meta: 'textScore'}}\"),\n                     fromjson(\"{c: {$meta: 'textScore'}}\"));\n    assertNumSolutions(1U);\n    assertSolutionExists(\n        \"{proj: {spec: {c:{$meta:'textScore'}}, node: \"\n        \"{sort: {pattern: {c:{$meta:'textScore'}}, limit: 0, node: {sortKeyGen: {node: \"\n        \"{cscan: {filter: {a:{$in:[1,2]},b:{$in:[3,4]}}, dir: 1}}}}}}}}\");\n}", "target": 0}
{"code": "Variant HHVM_FUNCTION(imageaffinematrixget,\n                      int64_t type,\n                      const Variant& options ) {\n  Array ret = Array::Create();\n  double affine[6];\n  int res = GD_FALSE, i;\n  switch((gdAffineStandardMatrix)type) {\n    case GD_AFFINE_TRANSLATE:\n    case GD_AFFINE_SCALE: {\n      double x, y;\n      Array aoptions = options.toArray();\n      if (aoptions.empty()) {\n        raise_warning(\"imageaffinematrixget(): Array expected as options\");\n        return false;\n      }\n      if (aoptions.exists(s_x)) {\n        x = aoptions[s_x].toDouble();\n      } else {\n        raise_warning(\"imageaffinematrixget(): Missing x position\");\n        return false;\n      }\n      if (aoptions.exists(s_y)) {\n        y = aoptions[s_y].toDouble();\n      } else {\n        raise_warning(\"imageaffinematrixget(): Missing x position\");\n        return false;\n      }\n      if (type == GD_AFFINE_TRANSLATE) {\n        res = gdAffineTranslate(affine, x, y);\n      } else {\n        res = gdAffineScale(affine, x, y);\n      }\n      break;\n    }\n    case GD_AFFINE_ROTATE:\n    case GD_AFFINE_SHEAR_HORIZONTAL:\n    case GD_AFFINE_SHEAR_VERTICAL: {\n      double angle;\n      double doptions = options.toDouble();\n      if (!doptions) {\n        raise_warning(\"imageaffinematrixget(): Number is expected as option\");\n        return false;\n      }\n      angle = doptions;\n      if (type == GD_AFFINE_SHEAR_HORIZONTAL) {\n        res = gdAffineShearHorizontal(affine, angle);\n      } else if (type == GD_AFFINE_SHEAR_VERTICAL) {\n        res = gdAffineShearVertical(affine, angle);\n      } else {\n        res = gdAffineRotate(affine, angle);\n      }\n      break;\n    }\n    default:\n      raise_warning(\"imageaffinematrixget():Invalid type for \"\n                    \"element %\" PRId64, type);\n      return false;\n  }\n  if (res == GD_FALSE) {\n    return false;\n  } else {\n    for (i = 0; i < 6; i++) {\n      ret.set(String(i, CopyString), affine[i]);\n    }\n  }\n  return ret;\n}", "target": 0}
{"code": "static void gen_vector_table16(TrueMotion1Context *s, const uint8_t *sel_vector_table)\n{\n    int len, i, j;\n    unsigned char delta_pair;\n    for (i = 0; i < 1024; i += 4)\n    {\n        len = *sel_vector_table++ / 2;\n        for (j = 0; j < len; j++)\n        {\n            delta_pair = *sel_vector_table++;\n            s->y_predictor_table[i+j] = 0xfffffffe &\n                make_ydt16_entry(delta_pair >> 4, delta_pair & 0xf, s->ydt);\n            s->c_predictor_table[i+j] = 0xfffffffe &\n                make_cdt16_entry(delta_pair >> 4, delta_pair & 0xf, s->cdt);\n        }\n        s->y_predictor_table[i+(j-1)] |= 1;\n        s->c_predictor_table[i+(j-1)] |= 1;\n    }\n}", "target": 0}
{"code": "struct bpf_prog *bpf_patch_insn_single(struct bpf_prog *prog, u32 off,\n\t\t\t\t       const struct bpf_insn *patch, u32 len)\n{\n\tu32 insn_adj_cnt, insn_rest, insn_delta = len - 1;\n\tstruct bpf_prog *prog_adj;\n\tif (insn_delta == 0) {\n\t\tmemcpy(prog->insnsi + off, patch, sizeof(*patch));\n\t\treturn prog;\n\t}\n\tinsn_adj_cnt = prog->len + insn_delta;\n\tprog_adj = bpf_prog_realloc(prog, bpf_prog_size(insn_adj_cnt),\n\t\t\t\t    GFP_USER);\n\tif (!prog_adj)\n\t\treturn NULL;\n\tprog_adj->len = insn_adj_cnt;\n\tinsn_rest = insn_adj_cnt - off - len;\n\tmemmove(prog_adj->insnsi + off + len, prog_adj->insnsi + off + 1,\n\t\tsizeof(*patch) * insn_rest);\n\tmemcpy(prog_adj->insnsi + off, patch, sizeof(*patch) * len);\n\tbpf_adj_branches(prog_adj, off, insn_delta);\n\treturn prog_adj;\n}", "target": 1}
{"code": "int avcodec_default_execute2(AVCodecContext *c, int (*func)(AVCodecContext *c2, void *arg2, int jobnr, int threadnr), void *arg, int *ret, int count)\n{\n    int i;\n    for (i = 0; i < count; i++) {\n        int r = func(c, arg, i, 0);\n        if (ret)\n            ret[i] = r;\n    }\n    return 0;\n}", "target": 0}
{"code": "  bool verify_authorizer(Connection *con, int peer_type, int protocol, bufferlist& auth, bufferlist& auth_reply,\n                         bool& isvalid, CryptoKey& session_key) {\n    return ms_deliver_verify_authorizer(con, peer_type, protocol, auth,\n                                        auth_reply, isvalid, session_key);\n  }", "target": 1}
{"code": "static int skcipher_recvmsg_nokey(struct socket *sock, struct msghdr *msg,\n\t\t\t\t  size_t ignored, int flags)\n{\n\tint err;\n\terr = skcipher_check_key(sock);\n\tif (err)\n\t\treturn err;\n\treturn skcipher_recvmsg(sock, msg, ignored, flags);\n}", "target": 0}
{"code": "bool ServerSecurityFeature::foxxAllowInstallFromRemote() const {\n  return _foxxAllowInstallFromRemote;\n}", "target": 0}
{"code": "section_size (asection *section, Elf_Internal_Phdr *segment)\n{\n  if ((section->flags & SEC_HAS_CONTENTS) != 0\n      || (section->flags & SEC_THREAD_LOCAL) == 0\n      || segment->p_type == PT_TLS)\n    return section->size;\n  return 0;\n}", "target": 0}
{"code": "static int expand_mapping_rule_ex(struct sss_certmap_ctx *ctx,\n                                  const uint8_t *der_cert, size_t der_size,\n                                  bool sanitize,\n                                  char **_filter, char ***_domains)\n{\n    int ret;\n    struct match_map_rule *r;\n    struct priority_list *p;\n    struct sss_cert_content *cert_content = NULL;\n    char *filter = NULL;\n    char **domains = NULL;\n    size_t c;\n    if (_filter == NULL || _domains == NULL) {\n        return EINVAL;\n    }\n    ret = sss_cert_get_content(ctx, der_cert, der_size, &cert_content);\n    if (ret != 0) {\n        CM_DEBUG(ctx, \"Failed to get certificate content [%d].\", ret);\n        return ret;\n    }\n    if (ctx->prio_list == NULL) {\n        if (ctx->default_mapping_rule == NULL) {\n            CM_DEBUG(ctx, \"No matching or mapping rules available.\");\n            return EINVAL;\n        }\n        ret = get_filter(ctx, ctx->default_mapping_rule, cert_content, sanitize,\n                         &filter);\n        goto done;\n    }\n    for (p = ctx->prio_list; p != NULL; p = p->next) {\n        for (r = p->rule_list; r != NULL; r = r->next) {\n            ret = do_match(ctx, r->parsed_match_rule, cert_content);\n            if (ret == 0) {\n                ret = get_filter(ctx, r->parsed_mapping_rule, cert_content,\n                                 sanitize, &filter);\n                if (ret != 0) {\n                    CM_DEBUG(ctx, \"Failed to get filter\");\n                    goto done;\n                }\n                if (r->domains != NULL) {\n                    for (c = 0; r->domains[c] != NULL; c++);\n                    domains = talloc_zero_array(ctx, char *, c + 1);\n                    if (domains == NULL) {\n                        ret = ENOMEM;\n                        goto done;\n                    }\n                    for (c = 0; r->domains[c] != NULL; c++) {\n                        domains[c] = talloc_strdup(domains, r->domains[c]);\n                        if (domains[c] == NULL) {\n                            ret = ENOMEM;\n                            goto done;\n                        }\n                    }\n                }\n                ret = 0;\n                goto done;\n            }\n        }\n    }\n    ret = ENOENT;\ndone:\n    talloc_free(cert_content);\n    if (ret == 0) {\n        *_filter = filter;\n        *_domains = domains;\n    } else {\n        talloc_free(filter);\n        talloc_free(domains);\n    }\n    return ret;\n}", "target": 0}
{"code": "static int is_fuse_usermount(struct libmnt_context *cxt, int *errsv)\n{\n\tstruct libmnt_ns *ns_old;\n\tconst char *type = mnt_fs_get_fstype(cxt->fs);\n\tconst char *optstr;\n\tchar *user_id = NULL;\n\tsize_t sz;\n\tuid_t uid;\n\tchar uidstr[sizeof(stringify_value(ULONG_MAX))];\n\t*errsv = 0;\n\tif (!type)\n\t\treturn 0;\n\tif (strcmp(type, \"fuse\") != 0 &&\n\t    strcmp(type, \"fuseblk\") != 0 &&\n\t    strncmp(type, \"fuse.\", 5) != 0 &&\n\t    strncmp(type, \"fuseblk.\", 8) != 0)\n\t\treturn 0;\n\toptstr = mnt_fs_get_fs_options(cxt->fs);\n\tif (!optstr)\n\t\treturn 0;\n\tif (mnt_optstr_get_option(optstr, \"user_id\", &user_id, &sz) != 0)\n\t\treturn 0;\n\tif (sz == 0 || user_id == NULL)\n\t\treturn 0;\n\tns_old = mnt_context_switch_origin_ns(cxt);\n\tif (!ns_old) {\n\t\t*errsv = -MNT_ERR_NAMESPACE;\n\t\treturn 0;\n\t}\n\tuid = getuid();\n\tif (!mnt_context_switch_ns(cxt, ns_old)) {\n\t\t*errsv = -MNT_ERR_NAMESPACE;\n\t\treturn 0;\n\t}\n\tsnprintf(uidstr, sizeof(uidstr), \"%lu\", (unsigned long) uid);\n\treturn strncmp(user_id, uidstr, sz) == 0;\n}", "target": 1}
{"code": "static int hmac_create(struct crypto_template *tmpl, struct rtattr **tb)\n{\n\tstruct shash_instance *inst;\n\tstruct crypto_alg *alg;\n\tstruct shash_alg *salg;\n\tint err;\n\tint ds;\n\tint ss;\n\terr = crypto_check_attr_type(tb, CRYPTO_ALG_TYPE_SHASH);\n\tif (err)\n\t\treturn err;\n\tsalg = shash_attr_alg(tb[1], 0, 0);\n\tif (IS_ERR(salg))\n\t\treturn PTR_ERR(salg);\n\terr = -EINVAL;\n\tds = salg->digestsize;\n\tss = salg->statesize;\n\talg = &salg->base;\n\tif (ds > alg->cra_blocksize ||\n\t    ss < alg->cra_blocksize)\n\t\tgoto out_put_alg;\n\tinst = shash_alloc_instance(\"hmac\", alg);\n\terr = PTR_ERR(inst);\n\tif (IS_ERR(inst))\n\t\tgoto out_put_alg;\n\terr = crypto_init_shash_spawn(shash_instance_ctx(inst), salg,\n\t\t\t\t      shash_crypto_instance(inst));\n\tif (err)\n\t\tgoto out_free_inst;\n\tinst->alg.base.cra_priority = alg->cra_priority;\n\tinst->alg.base.cra_blocksize = alg->cra_blocksize;\n\tinst->alg.base.cra_alignmask = alg->cra_alignmask;\n\tss = ALIGN(ss, alg->cra_alignmask + 1);\n\tinst->alg.digestsize = ds;\n\tinst->alg.statesize = ss;\n\tinst->alg.base.cra_ctxsize = sizeof(struct hmac_ctx) +\n\t\t\t\t     ALIGN(ss * 2, crypto_tfm_ctx_alignment());\n\tinst->alg.base.cra_init = hmac_init_tfm;\n\tinst->alg.base.cra_exit = hmac_exit_tfm;\n\tinst->alg.init = hmac_init;\n\tinst->alg.update = hmac_update;\n\tinst->alg.final = hmac_final;\n\tinst->alg.finup = hmac_finup;\n\tinst->alg.export = hmac_export;\n\tinst->alg.import = hmac_import;\n\tinst->alg.setkey = hmac_setkey;\n\terr = shash_register_instance(tmpl, inst);\n\tif (err) {\nout_free_inst:\n\t\tshash_free_instance(shash_crypto_instance(inst));\n\t}\nout_put_alg:\n\tcrypto_mod_put(alg);\n\treturn err;\n}", "target": 1}
{"code": "static bool couldRecur(const Variant& v, const ArrayData* arr) {\n  return v.isReferenced() ||\n    arr->kind() == ArrayData::kGlobalsKind ||\n    arr->kind() == ArrayData::kProxyKind;\n}", "target": 0}
{"code": "void key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}", "target": 0}
{"code": "static int32_t check_load_area(uintptr_t dst, uintptr_t len)\n{\n\tuint32_t legacy = dst + len <= UINT32_MAX - 1 ? 1 : 0;\n\tuintptr_t dram_start, dram_end;\n\tuintptr_t prot_start, prot_end;\n\tint32_t result = IO_SUCCESS;\n\tdram_start = legacy ? DRAM1_BASE : DRAM_40BIT_BASE;\n\tdram_end = legacy ? DRAM1_BASE + DRAM1_SIZE :\n\t    DRAM_40BIT_BASE + DRAM_40BIT_SIZE;\n\tprot_start = legacy ? DRAM_PROTECTED_BASE : DRAM_40BIT_PROTECTED_BASE;\n\tprot_end = prot_start + DRAM_PROTECTED_SIZE;\n\tif (dst < dram_start || dst > dram_end - len) {\n\t\tERROR(\"BL2: dst address is on the protected area.\\n\");\n\t\tresult = IO_FAIL;\n\t\tgoto done;\n\t}\n\tif (dst >= prot_start && dst < prot_end) {\n\t\tERROR(\"BL2: dst address is on the protected area.\\n\");\n\t\tresult = IO_FAIL;\n\t}\n\tif (dst < prot_start && dst > prot_start - len) {\n\t\tERROR(\"BL2: loaded data is on the protected area.\\n\");\n\t\tresult = IO_FAIL;\n\t}\ndone:\n\tif (result == IO_FAIL) {\n\t\tERROR(\"BL2: Out of range : dst=0x%lx len=0x%lx\\n\", dst, len);\n\t}\n\treturn result;\n}", "target": 1}
{"code": "void *safe_calloc(size_t size) {\n  void *addr;\n  if (!size)\n  {\n    ERR(\"Invalid allocation size.\\n\");\n    exit(EXIT_FAILURE);\n  }\n  if (!(addr = calloc(1, size)))\n  {\n      ERR(\"Failed to allocate requested number of bytes, out of memory?\\n\");\n      exit(EXIT_FAILURE);\n  }\n  return addr;\n}", "target": 0}
{"code": "static enum count_type __read_io_type(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tif (mapping) {\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\t\tif (inode->i_ino == F2FS_META_INO(sbi))\n\t\t\treturn F2FS_RD_META;\n\t\tif (inode->i_ino == F2FS_NODE_INO(sbi))\n\t\t\treturn F2FS_RD_NODE;\n\t}\n\treturn F2FS_RD_DATA;\n}", "target": 1}
{"code": "static int handle_vmread(struct kvm_vcpu *vcpu)\n{\n\tunsigned long field;\n\tu64 field_value;\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tu32 vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\tgva_t gva = 0;\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\tif (!nested_vmx_check_vmcs12(vcpu))\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\tfield = kvm_register_readl(vcpu, (((vmx_instruction_info) >> 28) & 0xf));\n\tif (vmcs12_read_any(vcpu, field, &field_value) < 0) {\n\t\tnested_vmx_failValid(vcpu, VMXERR_UNSUPPORTED_VMCS_COMPONENT);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\tif (vmx_instruction_info & (1u << 10)) {\n\t\tkvm_register_writel(vcpu, (((vmx_instruction_info) >> 3) & 0xf),\n\t\t\tfield_value);\n\t} else {\n\t\tif (get_vmx_mem_address(vcpu, exit_qualification,\n\t\t\t\tvmx_instruction_info, true, &gva))\n\t\t\treturn 1;\n\t\tkvm_write_guest_virt_system(&vcpu->arch.emulate_ctxt, gva,\n\t\t\t     &field_value, (is_long_mode(vcpu) ? 8 : 4), NULL);\n\t}\n\tnested_vmx_succeed(vcpu);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}", "target": 1}
{"code": "int sqliteAuthorizer(void* userData,\n                     int code,\n                     const char* arg3,\n                     const char* arg4,\n                     const char* arg5,\n                     const char* arg6) {\n  if (kAllowedSQLiteActionCodes.count(code) > 0) {\n    return SQLITE_OK;\n  }\n  LOG(ERROR) << \"Authorizer denied action \" << code << \" \"\n             << (arg3 ? arg3 : \"null\") << \" \" << (arg4 ? arg4 : \"null\") << \" \"\n             << (arg5 ? arg5 : \"null\") << \" \" << (arg6 ? arg6 : \"null\");\n  return SQLITE_DENY;\n}", "target": 0}
{"code": "int ossl_dsa_check_pub_key(const DSA *dsa, const BIGNUM *pub_key, int *ret)\n{\n    if (!dsa_precheck_params(dsa, ret))\n        return 0;\n    return ossl_ffc_validate_public_key(&dsa->params, pub_key, ret)\n           && *ret == 0;\n}", "target": 0}
{"code": "relay_websocket_decode_frame (const unsigned char *buffer,\n                              unsigned long long buffer_length,\n                              unsigned char *decoded,\n                              unsigned long long *decoded_length)\n{\n    unsigned long long i, index_buffer, length_frame_size, length_frame;\n    unsigned char opcode;\n    *decoded_length = 0;\n    index_buffer = 0;\n    while (index_buffer + 1 < buffer_length)\n    {\n        opcode = buffer[index_buffer] & 15;\n        if (!(buffer[index_buffer + 1] & 128))\n            return 0;\n        length_frame_size = 1;\n        length_frame = buffer[index_buffer + 1] & 127;\n        index_buffer += 2;\n        if (index_buffer >= buffer_length)\n            return 0;\n        if ((length_frame == 126) || (length_frame == 127))\n        {\n            length_frame_size = (length_frame == 126) ? 2 : 8;\n            if (index_buffer + length_frame_size > buffer_length)\n                return 0;\n            length_frame = 0;\n            for (i = 0; i < length_frame_size; i++)\n            {\n                length_frame += (unsigned long long)buffer[index_buffer + i] << ((length_frame_size - i - 1) * 8);\n            }\n            index_buffer += length_frame_size;\n        }\n        if (index_buffer + 4 > buffer_length)\n            return 0;\n        int masks[4];\n        for (i = 0; i < 4; i++)\n        {\n            masks[i] = (int)((unsigned char)buffer[index_buffer + i]);\n        }\n        index_buffer += 4;\n        switch (opcode)\n        {\n            case WEBSOCKET_FRAME_OPCODE_PING:\n                decoded[*decoded_length] = RELAY_CLIENT_MSG_PING;\n                break;\n            case WEBSOCKET_FRAME_OPCODE_CLOSE:\n                decoded[*decoded_length] = RELAY_CLIENT_MSG_CLOSE;\n                break;\n            default:\n                decoded[*decoded_length] = RELAY_CLIENT_MSG_STANDARD;\n                break;\n        }\n        *decoded_length += 1;\n        if ((length_frame > buffer_length)\n            || (index_buffer + length_frame > buffer_length))\n        {\n            return 0;\n        }\n        for (i = 0; i < length_frame; i++)\n        {\n            decoded[*decoded_length + i] = (int)((unsigned char)buffer[index_buffer + i]) ^ masks[i % 4];\n        }\n        decoded[*decoded_length + length_frame] = '\\0';\n        *decoded_length += length_frame + 1;\n        index_buffer += length_frame;\n    }\n    return 1;\n}", "target": 0}
{"code": "void ModuleSQL::init()\n{\n\tif (mysql_library_init(0, NULL, NULL))\n\t\tthrow ModuleException(\"Unable to initialise the MySQL library!\");\n\tDispatcher = new DispatcherThread(this);\n\tServerInstance->Threads->Start(Dispatcher);\n\tImplementation eventlist[] = { I_OnRehash, I_OnUnloadModule };\n\tServerInstance->Modules->Attach(eventlist, this, sizeof(eventlist)/sizeof(Implementation));\n\tOnRehash(NULL);\n}", "target": 0}
{"code": "static int cp2112_gpio_get_all(struct gpio_chip *chip)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tunsigned long flags;\n\tint ret;\n\tspin_lock_irqsave(&dev->lock, flags);\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_GET, buf,\n\t\t\t\t CP2112_GPIO_GET_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_GET_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO values: %d\\n\", ret);\n\t\tret = ret < 0 ? ret : -EIO;\n\t\tgoto exit;\n\t}\n\tret = buf[1];\nexit:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\treturn ret;\n}", "target": 1}
{"code": "cdf_tole2(uint16_t sv)\n{\n\treturn CDF_TOLE2(sv);\n}", "target": 0}
{"code": "get_parent_resource(const dav_resource *resource,\n                    dav_resource **parent_resource)\n{\n  dav_resource *parent;\n  dav_resource_private *parentinfo;\n  svn_stringbuf_t *path = resource->info->uri_path;\n  *parent_resource = NULL;\n  if (path->len == 1 && *path->data == '/')\n    return NULL;\n  switch (resource->type)\n    {\n    case DAV_RESOURCE_TYPE_REGULAR:\n      parent = apr_pcalloc(resource->pool, sizeof(*parent));\n      parentinfo  = apr_pcalloc(resource->pool, sizeof(*parentinfo));\n      parent->type = DAV_RESOURCE_TYPE_REGULAR;\n      parent->exists = 1;\n      parent->collection = 1;\n      parent->versioned = 1;\n      parent->hooks = resource->hooks;\n      parent->pool = resource->pool;\n      parent->uri = get_parent_path(svn_urlpath__canonicalize(resource->uri,\n                                                              resource->pool),\n                                    TRUE, resource->pool);\n      parent->info = parentinfo;\n      parentinfo->uri_path =\n        svn_stringbuf_create(get_parent_path(resource->info->uri_path->data,\n                                             TRUE, resource->pool),\n                             resource->pool);\n      parentinfo->repos = resource->info->repos;\n      parentinfo->root = resource->info->root;\n      parentinfo->r = resource->info->r;\n      parentinfo->svn_client_options = resource->info->svn_client_options;\n      parentinfo->repos_path = get_parent_path(resource->info->repos_path,\n                                               FALSE, resource->pool);\n      *parent_resource = parent;\n      break;\n    case DAV_RESOURCE_TYPE_WORKING:\n      *parent_resource =\n        create_private_resource(resource, DAV_SVN_RESTYPE_WRK_COLLECTION);\n      break;\n    case DAV_RESOURCE_TYPE_ACTIVITY:\n      *parent_resource =\n        create_private_resource(resource, DAV_SVN_RESTYPE_ACT_COLLECTION);\n      break;\n    case DAV_RESOURCE_TYPE_PRIVATE:\n      if ((resource->info->restype == DAV_SVN_RESTYPE_TXN_COLLECTION)\n          || (resource->info->restype == DAV_SVN_RESTYPE_REV_COLLECTION))\n        *parent_resource =\n          create_private_resource(resource, resource->info->restype);\n      break;\n    default:\n      break;\n    }\n  if (! *parent_resource)\n    return dav_svn__new_error(resource->pool, HTTP_INTERNAL_SERVER_ERROR, 0,\n                              apr_psprintf(resource->pool,\n                                           \"get_parent_resource was called for \"\n                                           \"%s (type %d)\",\n                                           resource->uri, resource->type));\n  return NULL;\n}", "target": 1}
{"code": "TfLiteStatus PrepareHashtableFind(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 3);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input_resource_id_tensor =\n      GetInput(context, node, kInputResourceIdTensor);\n  TF_LITE_ENSURE_EQ(context, input_resource_id_tensor->type, kTfLiteInt32);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input_resource_id_tensor), 1);\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(input_resource_id_tensor, 0), 1);\n  const TfLiteTensor* default_value_tensor =\n      GetInput(context, node, kDefaultValueTensor);\n  const TfLiteTensor* key_tensor = GetInput(context, node, kKeyTensor);\n  TfLiteTensor* output_tensor = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE_EQ(context, default_value_tensor->type, output_tensor->type);\n  TF_LITE_ENSURE(context, (key_tensor->type == kTfLiteInt64 &&\n                           output_tensor->type == kTfLiteString) ||\n                              (key_tensor->type == kTfLiteString &&\n                               output_tensor->type == kTfLiteInt64));\n  return context->ResizeTensor(context, output_tensor,\n                               TfLiteIntArrayCopy(key_tensor->dims));\n}", "target": 1}
{"code": "void ciEnv::cache_jvmti_state() {\n  VM_ENTRY_MARK;\n  MutexLocker mu(JvmtiThreadState_lock);\n  _jvmti_can_hotswap_or_post_breakpoint = JvmtiExport::can_hotswap_or_post_breakpoint();\n  _jvmti_can_access_local_variables     = JvmtiExport::can_access_local_variables();\n  _jvmti_can_post_on_exceptions         = JvmtiExport::can_post_on_exceptions();\n  _jvmti_can_pop_frame                  = JvmtiExport::can_pop_frame();\n}", "target": 0}
{"code": "bool GTextFieldIsEmpty(GGadget *g) {\n    GTextField *gt = (GTextField *) g;\n    return gt->text == NULL || *gt->text == '\\0';\n}", "target": 0}
{"code": "static gg_action_t gg_handle_connecting(struct gg_session *sess, struct gg_event *e, enum gg_state_t next_state, enum gg_state_t alt_state, enum gg_state_t alt2_state)\n{\n\tint res;\n\tsess->soft_timeout = 0;\n\tif (gg_async_connect_failed(sess, &res)) {\n\t\tgg_debug_session(sess, GG_DEBUG_MISC, \"\n\t\tclose(sess->fd);\n\t\tsess->fd = -1;\n\t\tsess->resolver_index++;\n\t\tsess->state = alt_state;\n\t} else {\n\t\tif (sess->state != GG_STATE_CONNECTING_PROXY_HUB) {\n\t\t\tfree(sess->resolver_result);\n\t\t\tsess->resolver_result = NULL;\n\t\t}\n\t\tsess->state = next_state;\n\t}\n\treturn GG_ACTION_NEXT;\n}", "target": 0}
{"code": "display_debug_not_supported (struct dwarf_section *section,\n\t\t\t     void *file ATTRIBUTE_UNUSED)\n{\n  printf (_(\"Displaying the debug contents of section %s is not yet supported.\\n\"),\n\t    section->name);\n  return 1;\n}", "target": 0}
{"code": "static void umocktypes_free_FLOW_HANDLE(FLOW_HANDLE* value)\n{\n    (void)value;\n}", "target": 0}
{"code": "static int pfkey_recvmsg(struct kiocb *kiocb,\n\t\t\t struct socket *sock, struct msghdr *msg, size_t len,\n\t\t\t int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\tstruct sk_buff *skb;\n\tint copied, err;\n\terr = -EINVAL;\n\tif (flags & ~(MSG_PEEK|MSG_DONTWAIT|MSG_TRUNC|MSG_CMSG_COMPAT))\n\t\tgoto out;\n\tmsg->msg_namelen = 0;\n\tskb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &err);\n\tif (skb == NULL)\n\t\tgoto out;\n\tcopied = skb->len;\n\tif (copied > len) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto out_free;\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\terr = (flags & MSG_TRUNC) ? skb->len : copied;\n\tif (pfk->dump.dump != NULL &&\n\t    3 * atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf)\n\t\tpfkey_do_dump(pfk);\nout_free:\n\tskb_free_datagram(sk, skb);\nout:\n\treturn err;\n}", "target": 1}
{"code": "int fscrypt_setup_filename(struct inode *dir, const struct qstr *iname,\n\t\t\t      int lookup, struct fscrypt_name *fname)\n{\n\tint ret = 0, bigname = 0;\n\tmemset(fname, 0, sizeof(struct fscrypt_name));\n\tfname->usr_fname = iname;\n\tif (!dir->i_sb->s_cop->is_encrypted(dir) ||\n\t\t\t\tfscrypt_is_dot_dotdot(iname)) {\n\t\tfname->disk_name.name = (unsigned char *)iname->name;\n\t\tfname->disk_name.len = iname->len;\n\t\treturn 0;\n\t}\n\tret = fscrypt_get_crypt_info(dir);\n\tif (ret && ret != -EOPNOTSUPP)\n\t\treturn ret;\n\tif (dir->i_crypt_info) {\n\t\tret = fscrypt_fname_alloc_buffer(dir, iname->len,\n\t\t\t\t\t\t\t&fname->crypto_buf);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = fname_encrypt(dir, iname, &fname->crypto_buf);\n\t\tif (ret)\n\t\t\tgoto errout;\n\t\tfname->disk_name.name = fname->crypto_buf.name;\n\t\tfname->disk_name.len = fname->crypto_buf.len;\n\t\treturn 0;\n\t}\n\tif (!lookup)\n\t\treturn -ENOKEY;\n\tif (iname->name[0] == '_')\n\t\tbigname = 1;\n\tif ((bigname && (iname->len != 33)) || (!bigname && (iname->len > 43)))\n\t\treturn -ENOENT;\n\tfname->crypto_buf.name = kmalloc(32, GFP_KERNEL);\n\tif (fname->crypto_buf.name == NULL)\n\t\treturn -ENOMEM;\n\tret = digest_decode(iname->name + bigname, iname->len - bigname,\n\t\t\t\tfname->crypto_buf.name);\n\tif (ret < 0) {\n\t\tret = -ENOENT;\n\t\tgoto errout;\n\t}\n\tfname->crypto_buf.len = ret;\n\tif (bigname) {\n\t\tmemcpy(&fname->hash, fname->crypto_buf.name, 4);\n\t\tmemcpy(&fname->minor_hash, fname->crypto_buf.name + 4, 4);\n\t} else {\n\t\tfname->disk_name.name = fname->crypto_buf.name;\n\t\tfname->disk_name.len = fname->crypto_buf.len;\n\t}\n\treturn 0;\nerrout:\n\tfscrypt_fname_free_buffer(&fname->crypto_buf);\n\treturn ret;\n}", "target": 1}
{"code": "find_entry_only(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n\tback_txn *txn\n)\n{\n\treturn( find_entry_internal( pb, be, addr, 0, txn, FE_REALLY_INTERNAL ) );\n}", "target": 1}
{"code": "static jboolean Region_getBounds(JNIEnv* env, jobject, jlong regionHandle, jobject rectBounds) {\n SkRegion* region = reinterpret_cast<SkRegion*>(regionHandle);\n GraphicsJNI::irect_to_jrect(region->getBounds(), env, rectBounds);\n bool result = !region->isEmpty();\n return boolTojboolean(result);\n}", "target": 0}
{"code": "create_tls_session(int csock, int type  )\n{\n    int rc = 0;\n    gnutls_session *session = gnutls_malloc(sizeof(gnutls_session));\n    gnutls_init(session, type);\n#  ifdef HAVE_GNUTLS_PRIORITY_SET_DIRECT\n    gnutls_priority_set_direct(*session, \"NORMAL:+ANON-DH\", NULL);\n#  else\n    gnutls_set_default_priority(*session);\n    gnutls_kx_set_priority(*session, tls_kx_order);\n#  endif\n    gnutls_transport_set_ptr(*session, (gnutls_transport_ptr) GINT_TO_POINTER(csock));\n    switch (type) {\n        case GNUTLS_SERVER:\n            gnutls_credentials_set(*session, GNUTLS_CRD_ANON, anon_cred_s);\n            break;\n        case GNUTLS_CLIENT:\n            gnutls_credentials_set(*session, GNUTLS_CRD_ANON, anon_cred_c);\n            break;\n    }\n    do {\n        rc = gnutls_handshake(*session);\n    } while (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN);\n    if (rc < 0) {\n        crm_err(\"Handshake failed: %s\", gnutls_strerror(rc));\n        gnutls_deinit(*session);\n        gnutls_free(session);\n        return NULL;\n    }\n    return session;\n}", "target": 1}
{"code": "inline void update_rq_clock(struct rq *rq)\n{\n\tif (!rq->skip_clock_update) {\n\t\tint cpu = cpu_of(rq);\n\t\tu64 irq_time;\n\t\trq->clock = sched_clock_cpu(cpu);\n\t\tirq_time = irq_time_cpu(cpu);\n\t\tif (rq->clock - irq_time > rq->clock_task)\n\t\t\trq->clock_task = rq->clock - irq_time;\n\t\tsched_irq_time_avg_update(rq, irq_time);\n\t}\n}", "target": 1}
{"code": "void RenderView::OnSetDOMUIProperty(const std::string& name,\n                                    const std::string& value) {\n  DCHECK(BindingsPolicy::is_dom_ui_enabled(enabled_bindings_));\n  dom_ui_bindings_.SetProperty(name, value);\n}", "target": 0}
{"code": "char *M_fs_path_join_parts(const M_list_str_t *path, M_fs_system_t sys_type)\n{\n\tM_list_str_t *parts;\n\tconst char   *part;\n\tchar         *out;\n\tsize_t        len;\n\tsize_t        i;\n\tsize_t        count;\n\tif (path == NULL) {\n\t\treturn NULL;\n\t}\n\tlen = M_list_str_len(path);\n\tif (len == 0) {\n\t\treturn NULL;\n\t}\n\tsys_type = M_fs_path_get_system_type(sys_type);\n\tparts = M_list_str_duplicate(path);\n\tfor (i=len-1; i>0; i--) {\n\t\tpart = M_list_str_at(parts, i);\n\t\tif (part == NULL || *part == '\\0') {\n\t\t\tM_list_str_remove_at(parts, i);\n\t\t}\n\t}\n\tlen = M_list_str_len(parts);\n\tpart = M_list_str_at(parts, 0);\n\tif (len == 1 && (part == NULL || *part == '\\0')) {\n\t\tM_list_str_destroy(parts);\n\t\tif (sys_type == M_FS_SYSTEM_WINDOWS) {\n\t\t\treturn M_strdup(\"\\\\\\\\\");\n\t\t}\n\t\treturn M_strdup(\"/\");\n\t}\n\tif (sys_type == M_FS_SYSTEM_WINDOWS && len > 0) {\n\t\tpart  = M_list_str_at(parts, 0);\n\t\tcount = (len == 1) ? 2 : 1;\n\t\tif (part != NULL && *part == '\\0') {\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tM_list_str_insert_at(parts, \"\", 0);\n\t\t\t}\n\t\t} else if (M_fs_path_isabs(part, sys_type) && len == 1) {\n\t\t\tM_list_str_insert_at(parts, \"\", 1);\n\t\t}\n\t}\n\tout = M_list_str_join(parts, (unsigned char)M_fs_path_get_system_sep(sys_type));\n\tM_list_str_destroy(parts);\n\treturn out;\n}", "target": 1}
{"code": "void WasmBinaryWriter::writeDebugLocationEnd(Expression* curr, Function* func) {\n  if (func && !func->expressionLocations.empty()) {\n    auto& span = binaryLocations.expressions.at(curr);\n    span.end = o.size();\n  }\n}", "target": 0}
{"code": "int mingw_rmdir(const char *pathname)\n{\n\tint ret, tries = 0;\n\twchar_t wpathname[MAX_PATH];\n\tif (xutftowcs_path(wpathname, pathname) < 0)\n\t\treturn -1;\n\twhile ((ret = _wrmdir(wpathname)) == -1 && tries < ARRAY_SIZE(delay)) {\n\t\tif (!is_file_in_use_error(GetLastError()))\n\t\t\terrno = err_win_to_posix(GetLastError());\n\t\tif (errno != EACCES)\n\t\t\tbreak;\n\t\tif (!is_dir_empty(wpathname)) {\n\t\t\terrno = ENOTEMPTY;\n\t\t\tbreak;\n\t\t}\n\t\tSleep(delay[tries]);\n\t\ttries++;\n\t}\n\twhile (ret == -1 && errno == EACCES && is_file_in_use_error(GetLastError()) &&\n\t       ask_yes_no_if_possible(\"Deletion of directory '%s' failed. \"\n\t\t\t\"Should I try again?\", pathname))\n\t       ret = _wrmdir(wpathname);\n\tif (!ret)\n\t\tinvalidate_lstat_cache();\n\treturn ret;\n}", "target": 0}
{"code": "static void cjson_get_object_item_case_sensitive_should_not_crash_with_array(void) {\n    cJSON *array = NULL;\n    cJSON *found = NULL;\n    array = cJSON_Parse(\"[1]\");\n    found = cJSON_GetObjectItemCaseSensitive(array, \"name\");\n    TEST_ASSERT_NULL(found);\n    cJSON_Delete(array);\n}", "target": 0}
{"code": "GF_Err SFScript_Parse(GF_BifsDecoder *codec, SFScript *script_field, GF_BitStream *bs, GF_Node *n)\n{\n\tGF_Err e;\n\tu32 i, count, nbBits;\n\tchar *ptr;\n\tScriptParser parser;\n\te = GF_OK;\n\tif (gf_node_get_tag(n) != TAG_MPEG4_Script) return GF_NON_COMPLIANT_BITSTREAM;\n\tmemset(&parser, 0, sizeof(ScriptParser));\n\tparser.codec = codec;\n\tparser.script = n;\n\tparser.bs = bs;\n\tparser.length = 500;\n\tparser.string = (char *) gf_malloc(sizeof(char)* parser.length);\n\tparser.string[0] = 0;\n\tparser.identifiers = gf_list_new();\n\tparser.new_line = (char *) (codec->dec_memory_mode ? \"\\n\" : NULL);\n\tparser.indent = 0;\n\tif (gf_bs_read_int(bs, 1)) {\n\t\twhile (!gf_bs_read_int(bs, 1)) {\n\t\t\te = ParseScriptField(&parser);\n\t\t\tif (e) goto exit;\n\t\t}\n\t} else {\n\t\tnbBits = gf_bs_read_int(bs, 4);\n\t\tcount = gf_bs_read_int(bs, nbBits);\n\t\tfor (i=0; i<count; i++) {\n\t\t\te = ParseScriptField(&parser);\n\t\t\tif (e) goto exit;\n\t\t}\n\t}\n\tgf_bs_read_int(bs, 1);\n\tSFS_AddString(&parser, \"javascript:\");\n\tSFS_AddString(&parser, parser.new_line);\n\twhile (gf_bs_read_int(bs, 1)) {\n\t\tSFS_AddString(&parser, \"function \");\n\t\tSFS_Identifier(&parser);\n\t\tSFS_Arguments(&parser, GF_FALSE);\n\t\tSFS_Space(&parser);\n\t\tSFS_StatementBlock(&parser, GF_TRUE);\n\t\tSFS_Line(&parser);\n\t\tif (codec->LastError) {\n\t\t\te = codec->LastError;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\tSFS_Line(&parser);\n\tif (script_field->script_text) gf_free(script_field->script_text);\n\tscript_field->script_text = (char *) gf_strdup(parser.string);\nexit:\n\twhile (gf_list_count(parser.identifiers)) {\n\t\tptr = (char *)gf_list_get(parser.identifiers, 0);\n\t\tgf_free(ptr);\n\t\tgf_list_rem(parser.identifiers, 0);\n\t}\n\tgf_list_del(parser.identifiers);\n\tif (parser.string) gf_free(parser.string);\n\treturn e;\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, CantUseHashedIndexToProvideSortWithIndexablePred) {\n    addIndex(BSON(\"x\"\n                  << \"hashed\"));\n    runQuerySortProj(BSON(\"x\" << BSON(\"$in\" << BSON_ARRAY(0 << 1))), BSON(\"x\" << 1), BSONObj());\n    ASSERT_EQUALS(getNumSolutions(), 2U);\n    assertSolutionExists(\n        \"{sort: {pattern: {x: 1}, limit: 0, node: {sortKeyGen: {node: \"\n        \"{fetch: {node: \"\n        \"{ixscan: {pattern: {x: 'hashed'}}}}}}}}}\");\n    assertSolutionExists(\n        \"{sort: {pattern: {x: 1}, limit: 0, node: {sortKeyGen: {node:\"\n        \"{cscan: {dir: 1, filter: {x: {$in: [0, 1]}}}}}}}}\");\n}", "target": 0}
{"code": "DocumentLoader* FrameLoader::activeDocumentLoader() const\n{\n    if (m_state == FrameStateProvisional)\n        return m_provisionalDocumentLoader.get();\n    return m_documentLoader.get();\n}", "target": 0}
{"code": "explain_slow_path(enum slow_path_reason slow, struct ds *output)\n{\n    ds_put_cstr(output, \"\\nThis flow is handled by the userspace \"\n                \"slow path because it:\");\n    for (; slow; slow = zero_rightmost_1bit(slow)) {\n        enum slow_path_reason bit = rightmost_1bit(slow);\n        ds_put_format(output, \"\\n  - %s.\",\n                      slow_path_reason_to_explanation(bit));\n    }\n}", "target": 0}
{"code": "xml_read_notification(xmlTextReaderPtr reader, void *arg)\n{\n\tstruct rdr_notification_ctx *ctx = arg;\n\txmlReaderTypes type;\n\txmlChar const *name;\n\tint error;\n\terror = 0;\n\tname = xmlTextReaderConstLocalName(reader);\n\ttype = xmlTextReaderNodeType(reader);\n\tswitch (type) {\n\tcase XML_READER_TYPE_ELEMENT:\n\t\tif (xmlStrEqual(name, BAD_CAST RRDP_ELEM_DELTA)) {\n\t\t\terror = parse_notification_delta(reader, ctx);\n\t\t} else if (xmlStrEqual(name, BAD_CAST RRDP_ELEM_SNAPSHOT)) {\n\t\t\terror = parse_doc_data(reader, true, true,\n\t\t\t    &ctx->notification->snapshot);\n\t\t} else if (xmlStrEqual(name, BAD_CAST RRDP_ELEM_NOTIFICATION)) {\n\t\t\terror = parse_global_data(reader,\n\t\t\t    &ctx->notification->global_data, NULL, 0);\n\t\t\trdr_notification_ctx_init(ctx);\n\t\t} else {\n\t\t\treturn pr_val_err(\"Unexpected '%s' element\", name);\n\t\t}\n\t\tbreak;\n\tcase XML_READER_TYPE_END_ELEMENT:\n\t\tif (xmlStrEqual(name, BAD_CAST RRDP_ELEM_NOTIFICATION)) {\n\t\t\terror = order_notification_deltas(ctx);\n\t\t\trdr_notification_ctx_cleanup(ctx);\n\t\t\treturn error; \n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tif (error) {\n\t\trdr_notification_ctx_cleanup(ctx);\n\t\treturn error;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "rs_filter_graph(RSFilter *filter)\n{\n\tg_return_if_fail(RS_IS_FILTER(filter));\n\tGString *str = g_string_new(\"digraph G {\\n\");\n\trs_filter_graph_helper(str, filter);\n\tg_string_append_printf(str, \"}\\n\");\n\tg_file_set_contents(\"/tmp/rs-filter-graph\", str->str, str->len, NULL);\n\tif (0 != system(\"dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph\"))\n\t\tg_warning(\"Calling dot failed\");\n\tif (0 != system(\"gnome-open /tmp/rs-filter-graph.png\"))\n\t\tg_warning(\"Calling gnome-open failed.\");\n\tg_string_free(str, TRUE);\n}", "target": 1}
{"code": "int main(int argc, char **argv) {\n  mlir::registerAsmPrinterCLOptions();\n  tensorflow::InitMlir y(&argc, &argv);\n  return failed(\n      mlir::mlirTranslateMain(argc, argv, \"Graph(Def)<->TFG Translation Tool\"));\n}", "target": 0}
{"code": "static void WriteBinaryGltfStream(std::ostream &stream,\n                                  const std::string &content,\n                                  const std::vector<unsigned char> &binBuffer) {\n  const std::string header = \"glTF\";\n  const int version = 2;\n  const uint32_t content_size = uint32_t(content.size());\n  const uint32_t binBuffer_size = uint32_t(binBuffer.size());\n  const uint32_t content_padding_size = content_size % 4 == 0 ? 0 : 4 - content_size % 4;\n  const uint32_t bin_padding_size = binBuffer_size % 4 == 0 ? 0 : 4 - binBuffer_size % 4;\n  const uint32_t length =\n      12 + 8 + content_size + content_padding_size +\n      (binBuffer_size ? (8 + binBuffer_size + bin_padding_size) : 0);\n  stream.write(header.c_str(), std::streamsize(header.size()));\n  stream.write(reinterpret_cast<const char *>(&version), sizeof(version));\n  stream.write(reinterpret_cast<const char *>(&length), sizeof(length));\n  const uint32_t model_length = uint32_t(content.size()) + content_padding_size;\n  const uint32_t model_format = 0x4E4F534A;\n  stream.write(reinterpret_cast<const char *>(&model_length),\n               sizeof(model_length));\n  stream.write(reinterpret_cast<const char *>(&model_format),\n               sizeof(model_format));\n  stream.write(content.c_str(), std::streamsize(content.size()));\n  if (content_padding_size > 0) {\n    const std::string padding = std::string(size_t(content_padding_size), ' ');\n    stream.write(padding.c_str(), std::streamsize(padding.size()));\n  }\n  if (binBuffer.size() > 0) {\n    const uint32_t bin_length = uint32_t(binBuffer.size()) + bin_padding_size;\n    const uint32_t bin_format = 0x004e4942;\n    stream.write(reinterpret_cast<const char *>(&bin_length),\n                 sizeof(bin_length));\n    stream.write(reinterpret_cast<const char *>(&bin_format),\n                 sizeof(bin_format));\n    stream.write(reinterpret_cast<const char *>(binBuffer.data()),\n                 std::streamsize(binBuffer.size()));\n    if (bin_padding_size > 0) {\n      const std::vector<unsigned char> padding =\n          std::vector<unsigned char>(size_t(bin_padding_size), 0);\n      stream.write(reinterpret_cast<const char *>(padding.data()),\n                   std::streamsize(padding.size()));\n    }\n  }\n}", "target": 1}
{"code": "void BezierOval(double w, double h, char *action)\n{\n    char *outpos = outputbuffer;\n    outpos +=\n    sprintf(outpos,\" %12.3f 0 m %12.3f %12.3f %12.3f %12.3f 0 %12.3f c\\n\",-w,-w,h*BzK,-w*BzK,h,h);\n    outpos +=\n    sprintf(outpos,\" %12.3f %12.3f %12.3f %12.3f %12.3f 0 c\\n\",w*BzK,h,w,h*BzK,w);\n    outpos +=\n    sprintf(outpos,\" %12.3f %12.3f %12.3f %12.3f 0 %12.3f c\\n\",w,-h*BzK,w*BzK,-h,-h);\n    outpos +=\n    sprintf(outpos,\" %12.3f %12.3f %12.3f %12.3f %12.3f 0 c %s\\n\",-w*BzK,-h,-w,-h*BzK,-w,action);\n    sendClean(outputbuffer);\n}", "target": 0}
{"code": "TypeAttr CastQuantizedTypeAttrFromExpressedType(Builder builder,\n                                                TypeAttr source, Type target,\n                                                int axis) {\n  auto source_type = source.getValue().dyn_cast_or_null<ShapedType>();\n  if (!source_type) return {};\n  auto src_ele_type = source_type.getElementType();\n  auto qtype = src_ele_type.dyn_cast<quant::QuantizedType>();\n  if (auto per_axis =\n          qtype.dyn_cast_or_null<quant::UniformQuantizedPerAxisType>()) {\n    if (axis == -1) return {};\n    qtype =\n        ResetAxisAndBroadcast(source_type.getShape(), per_axis, target, axis);\n  }\n  if (!qtype) return {};\n  Type final_type = qtype.castFromExpressedType(target);\n  if (!final_type) return {};\n  return TypeAttr::get(final_type);\n}", "target": 0}
{"code": "static void hog_exit(void)\n{\n\tif (suspend_supported)\n\t\tsuspend_exit();\n\tbtd_profile_unregister(&hog_profile);\n}", "target": 0}
{"code": "\t inline uLONG osdSwap4(uLONG *inLong) {\n\t return *inLong = DPT_Bswapl(*inLong);\n\t }", "target": 1}
{"code": "int bt_sock_recvmsg(struct socket *sock, struct msghdr *msg, size_t len,\n\t\t    int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tsize_t copied;\n\tsize_t skblen;\n\tint err;\n\tBT_DBG(\"sock %p sk %p len %zu\", sock, sk, len);\n\tif (flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\tskb = skb_recv_datagram(sk, flags, &err);\n\tif (!skb) {\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\tskblen = skb->len;\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (err == 0) {\n\t\tsock_recv_cmsgs(msg, sk, skb);\n\t\tif (msg->msg_name && bt_sk(sk)->skb_msg_name)\n\t\t\tbt_sk(sk)->skb_msg_name(skb, msg->msg_name,\n\t\t\t\t\t\t&msg->msg_namelen);\n\t\tif (test_bit(BT_SK_PKT_STATUS, &bt_sk(sk)->flags)) {\n\t\t\tu8 pkt_status = hci_skb_pkt_status(skb);\n\t\t\tput_cmsg(msg, SOL_BLUETOOTH, BT_SCM_PKT_STATUS,\n\t\t\t\t sizeof(pkt_status), &pkt_status);\n\t\t}\n\t}\n\tskb_free_datagram(sk, skb);\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skblen;\n\treturn err ? : copied;\n}", "target": 1}
{"code": "  UTF16Ref getUTF16Ref(llvh::SmallVectorImpl<char16_t> &allocator) const {\n    assert(allocator.empty() && \"Shouldn't use a non-empty allocator\");\n    return getUTF16Ref(allocator, false);\n  }", "target": 0}
{"code": "static void f_parser (lua_State *L, void *ud) {\n  int i;\n  Proto *tf;\n  Closure *cl;\n  struct SParser *p = cast(struct SParser *, ud);\n  int c = luaZ_lookahead(p->z);\n  luaC_checkGC(L);\n  tf = ((c == LUA_SIGNATURE[0]) ? luaU_undump : luaY_parser)(L, p->z,\n                                                             &p->buff, p->name);\n  cl = luaF_newLclosure(L, tf->nups, hvalue(gt(L)));\n  cl->l.p = tf;\n  for (i = 0; i < tf->nups; i++)  \n    cl->l.upvals[i] = luaF_newupval(L);\n  setclvalue(L, L->top, cl);\n  incr_top(L);\n}", "target": 1}
{"code": "    TiffBinaryArray::~TiffBinaryArray()\n    {\n        for (Components::iterator i = elements_.begin(); i != elements_.end(); ++i) {\n            delete *i;\n        }\n    }", "target": 0}
{"code": "static bool glfs_check_config(const char *cfgstring, char **reason)\n{\n\tchar *path;\n\tglfs_t *fs = NULL;\n\tglfs_fd_t *gfd = NULL;\n\tgluster_server *hosts = NULL; \n\tbool result = true;\n\tpath = strchr(cfgstring, '/');\n\tif (!path) {\n\t\tif (asprintf(reason, \"No path found\") == -1)\n\t\t\t*reason = NULL;\n\t\tresult = false;\n\t\tgoto done;\n\t}\n\tpath += 1; \n\tfs = tcmu_create_glfs_object(path, &hosts);\n\tif (!fs) {\n\t\ttcmu_err(\"tcmu_create_glfs_object failed\\n\");\n\t\tgoto done;\n\t}\n\tgfd = glfs_open(fs, hosts->path, ALLOWED_BSOFLAGS);\n\tif (!gfd) {\n\t\tif (asprintf(reason, \"glfs_open failed: %m\") == -1)\n\t\t\t*reason = NULL;\n\t\tresult = false;\n\t\tgoto unref;\n\t}\n\tif (glfs_access(fs, hosts->path, R_OK|W_OK) == -1) {\n\t\tif (asprintf(reason, \"glfs_access file not present, or not writable\") == -1)\n\t\t\t*reason = NULL;\n\t\tresult = false;\n\t\tgoto unref;\n\t}\n\tgoto done;\nunref:\n\tgluster_cache_refresh(fs, path);\ndone:\n\tif (gfd)\n\t\tglfs_close(gfd);\n\tgluster_free_server(&hosts);\n\treturn result;\n}", "target": 1}
{"code": "int bson_ensure_space( bson *b, const int bytesNeeded ) {\n    int pos = b->cur - b->data;\n    char *orig = b->data;\n    int new_size;\n    if ( pos + bytesNeeded <= b->dataSize )\n        return BSON_OK;\n    new_size = 1.5 * ( b->dataSize + bytesNeeded );\n    if( new_size < b->dataSize ) {\n        if( ( b->dataSize + bytesNeeded ) < INT_MAX )\n            new_size = INT_MAX;\n        else {\n            b->err = BSON_SIZE_OVERFLOW;\n            return BSON_ERROR;\n        }\n    }\n    b->data = bson_realloc( b->data, new_size );\n    if ( !b->data )\n        bson_fatal_msg( !!b->data, \"realloc() failed\" );\n    b->dataSize = new_size;\n    b->cur += b->data - orig;\n    return BSON_OK;\n}", "target": 1}
{"code": "static void ext_session_lock_v1_handle_locked(void *data, struct ext_session_lock_v1 *lock) {\n}", "target": 0}
{"code": "static void mirror_free_init(MirrorBlockJob *s)\n{\n    int granularity = s->granularity;\n    size_t buf_size = s->buf_size;\n    uint8_t *buf = s->buf;\n    assert(s->buf_free_count == 0);\n    QSIMPLEQ_INIT(&s->buf_free);\n    while (buf_size != 0) {\n        MirrorBuffer *cur = (MirrorBuffer *)buf;\n        QSIMPLEQ_INSERT_TAIL(&s->buf_free, cur, next);\n        s->buf_free_count++;\n        buf_size -= granularity;\n        buf += granularity;\n    }\n}", "target": 0}
{"code": "git_commit_list_node *git_commit_list_alloc_node(git_revwalk *walk)\n{\n\treturn (git_commit_list_node *)git_pool_mallocz(&walk->commit_pool, 1);\n}", "target": 0}
{"code": "static int64_t http_seek_internal(URLContext *h, int64_t off, int whence, int force_reconnect)\n{\n    HTTPContext *s = h->priv_data;\n    URLContext *old_hd = s->hd;\n    int64_t old_off = s->off;\n    uint8_t old_buf[BUFFER_SIZE];\n    int old_buf_size, ret;\n    AVDictionary *options = NULL;\n    if (whence == AVSEEK_SIZE)\n        return s->filesize;\n    else if (!force_reconnect &&\n             ((whence == SEEK_CUR && off == 0) ||\n              (whence == SEEK_SET && off == s->off)))\n        return s->off;\n    else if ((s->filesize == -1 && whence == SEEK_END))\n        return AVERROR(ENOSYS);\n    if (whence == SEEK_CUR)\n        off += s->off;\n    else if (whence == SEEK_END)\n        off += s->filesize;\n    else if (whence != SEEK_SET)\n        return AVERROR(EINVAL);\n    if (off < 0)\n        return AVERROR(EINVAL);\n    s->off = off;\n    if (s->off && h->is_streamed)\n        return AVERROR(ENOSYS);\n    old_buf_size = s->buf_end - s->buf_ptr;\n    memcpy(old_buf, s->buf_ptr, old_buf_size);\n    s->hd = NULL;\n    if ((ret = http_open_cnx(h, &options)) < 0) {\n        av_dict_free(&options);\n        memcpy(s->buffer, old_buf, old_buf_size);\n        s->buf_ptr = s->buffer;\n        s->buf_end = s->buffer + old_buf_size;\n        s->hd      = old_hd;\n        s->off     = old_off;\n        return ret;\n    }\n    av_dict_free(&options);\n    ffurl_close(old_hd);\n    return off;\n}", "target": 1}
{"code": "dup_list_from_ptrarray (GPtrArray *p)\n{\n  GList *ret;\n  guint n;\n  ret = NULL;\n  for (n = 0; n < p->len; n++)\n    ret = g_list_prepend (ret, g_strdup (((gchar **) p->pdata)[n]));\n  return ret;\n}", "target": 0}
{"code": "bool OmniboxViewWin::IsSelectAll() {\n  CHARRANGE selection;\n  GetSel(selection);\n  return IsSelectAllForRange(selection);\n}", "target": 0}
{"code": "static void fpm_child_init(struct fpm_worker_pool_s *wp) \n{\n\tfpm_globals.max_requests = wp->config->pm_max_requests;\n\tfpm_globals.listening_socket = dup(wp->listening_socket);\n\tif (0 > fpm_stdio_init_child(wp)  ||\n\t    0 > fpm_log_init_child(wp)    ||\n\t    0 > fpm_status_init_child(wp) ||\n\t    0 > fpm_unix_init_child(wp)   ||\n\t    0 > fpm_signals_init_child()  ||\n\t    0 > fpm_env_init_child(wp)    ||\n\t    0 > fpm_php_init_child(wp)) {\n\t\tzlog(ZLOG_ERROR, \"[pool %s] child failed to initialize\", wp->config->name);\n\t\texit(FPM_EXIT_SOFTWARE);\n\t}\n}", "target": 0}
{"code": "void LibRaw::android_tight_load_raw()\n{\n  uchar *data, *dp;\n  int bwide, row, col, c;\n  bwide = -(-5 * raw_width >> 5) << 3;\n  data = (uchar *)malloc(bwide);\n  merror(data, \"android_tight_load_raw()\");\n  for (row = 0; row < raw_height; row++)\n  {\n    if (fread(data, 1, bwide, ifp) < bwide)\n      derror();\n    for (dp = data, col = 0; col < raw_width; dp += 5, col += 4)\n      FORC4 RAW(row, col + c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);\n  }\n  free(data);\n}", "target": 0}
{"code": "inline int ValidateTensorIndexing(const TfLiteContext* context, int index,\n                                  int max_size, const int* tensor_indices) {\n  if (index >= 0 && index < max_size) {\n    const int tensor_index = tensor_indices[index];\n    if (tensor_index != kTfLiteOptionalTensor) {\n      return tensor_index;\n    }\n  }\n  return -1;\n}", "target": 0}
{"code": "option_env_fd_cb (const gchar *option_name,\n                  const gchar *value,\n                  gpointer     data,\n                  GError     **error)\n{\n  FlatpakContext *context = data;\n  g_autoptr(GBytes) env_block = NULL;\n  gsize remaining;\n  const char *p;\n  guint64 fd;\n  gchar *endptr;\n  fd = g_ascii_strtoull (value, &endptr, 10);\n  if (endptr == NULL || *endptr != '\\0' || fd > G_MAXINT)\n    return glnx_throw (error, \"Not a valid file descriptor: %s\", value);\n  env_block = glnx_fd_readall_bytes ((int) fd, NULL, error);\n  if (env_block == NULL)\n    return FALSE;\n  p = g_bytes_get_data (env_block, &remaining);\n  while (remaining > 0)\n    {\n      size_t len = strnlen (p, remaining);\n      const char *equals;\n      g_assert (len <= remaining);\n      equals = memchr (p, '=', len);\n      if (equals == NULL || equals == p)\n        return glnx_throw (error,\n                           \"Environment variable must be given in the form VARIABLE=VALUE, not %.*s\", (int) len, p);\n      flatpak_context_set_env_var (context,\n                                   g_strndup (p, equals - p),\n                                   g_strndup (equals + 1, len - (equals - p) - 1));\n      p += len;\n      remaining -= len;\n      if (remaining > 0)\n        {\n          g_assert (*p == '\\0');\n          p += 1;\n          remaining -= 1;\n        }\n    }\n  if (fd >= 3)\n    close (fd);\n  return TRUE;\n}", "target": 0}
{"code": "pf_remove_state(struct pf_state *st)\n{\n\tPF_ASSERT_LOCKED();\n\tif (st->timeout == PFTM_UNLINKED)\n\t\treturn;\n\tst->timeout = PFTM_UNLINKED;\n\tpf_postprocess_addr(st);\n\tif (st->src.state == PF_TCPS_PROXY_DST) {\n\t\tpf_send_tcp(st->rule.ptr, st->key[PF_SK_WIRE]->af,\n\t\t    &st->key[PF_SK_WIRE]->addr[1],\n\t\t    &st->key[PF_SK_WIRE]->addr[0],\n\t\t    st->key[PF_SK_WIRE]->port[1],\n\t\t    st->key[PF_SK_WIRE]->port[0],\n\t\t    st->src.seqhi, st->src.seqlo + 1,\n\t\t    TH_RST|TH_ACK, 0, 0, 0, 1, st->tag,\n\t\t    st->key[PF_SK_WIRE]->rdomain);\n\t}\n\tif (st->key[PF_SK_STACK]->proto == IPPROTO_TCP)\n\t\tpf_set_protostate(st, PF_PEER_BOTH, TCPS_CLOSED);\n\tRBT_REMOVE(pf_state_tree_id, &tree_id, st);\n#if NPFLOW > 0\n\tif (st->state_flags & PFSTATE_PFLOW)\n\t\texport_pflow(st);\n#endif\t\n#if NPFSYNC > 0\n\tpfsync_delete_state(st);\n#endif\t\n\tpf_src_tree_remove_state(st);\n\tpf_detach_state(st);\n}", "target": 1}
{"code": "RenderSVGResourceContainer* SVGDocumentExtensions::resourceById(const AtomicString& id) const\n{\n    if (id.isEmpty())\n        return 0;\n    return m_resources.get(id);\n}", "target": 0}
{"code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, kInput);\n  const TfLiteTensor* input_state = GetInput(context, node, kInputState);\n  const TfLiteTensor* gate_weight = GetInput(context, node, kGateWeight);\n  const TfLiteTensor* gate_bias = GetInput(context, node, kGateBias);\n  const TfLiteTensor* candidate_weight =\n      GetInput(context, node, kCandidateWeight);\n  const TfLiteTensor* candidate_bias = GetInput(context, node, kCandidateBias);\n  TfLiteTensor* output = GetOutput(context, node, kOutput);\n  TfLiteTensor* output_state = GetOutput(context, node, kOutputState);\n  TfLiteTensor* activation = GetTemporary(context, node, kActivation);\n  TfLiteTensor* concat = GetTemporary(context, node, kConcat);\n  auto cpu_backend_context = CpuBackendContext::GetFromContext(context);\n  if (gate_weight->type == kTfLiteFloat32) {\n    GruImpl(input, input_state, gate_weight, gate_bias, candidate_weight,\n            candidate_bias, output, output_state, activation, concat,\n            cpu_backend_context);\n  } else {\n    context->ReportError(context,\n                         \"Unsupported combination of data types for GruCell\");\n    return kTfLiteError;\n  }\n  return kTfLiteOk;\n}", "target": 1}
{"code": "ldbm_config_search_entry_callback(Slapi_PBlock *pb __attribute__((unused)),\n                                  Slapi_Entry *e,\n                                  Slapi_Entry *entryAfter __attribute__((unused)),\n                                  int *returncode,\n                                  char *returntext,\n                                  void *arg)\n{\n    char buf[BUFSIZ];\n    struct berval *vals[2];\n    struct berval val;\n    struct ldbminfo *li = (struct ldbminfo *)arg;\n    config_info *config;\n    int scope;\n    vals[0] = &val;\n    vals[1] = NULL;\n    returntext[0] = '\\0';\n    PR_Lock(li->li_config_mutex);\n    if (pb) {\n        slapi_pblock_get(pb, SLAPI_SEARCH_SCOPE, &scope);\n        if (scope == LDAP_SCOPE_BASE) {\n            char **attrs = NULL;\n            slapi_pblock_get(pb, SLAPI_SEARCH_ATTRS, &attrs);\n            if (attrs) {\n                for (size_t i = 0; attrs[i]; i++) {\n                    if (ldbm_config_moved_attr(attrs[i])) {\n                        slapi_pblock_set(pb, SLAPI_PB_RESULT_TEXT, \"at least one required attribute has been moved to the BDB scecific configuration entry\");\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    for (config = ldbm_config; config->config_name != NULL; config++) {\n        if (!(config->config_flags & (CONFIG_FLAG_ALWAYS_SHOW | CONFIG_FLAG_PREVIOUSLY_SET))) {\n            continue;\n        }\n        ldbm_config_get((void *)li, config, buf);\n        val.bv_val = buf;\n        val.bv_len = strlen(buf);\n        slapi_entry_attr_replace(e, config->config_name, vals);\n    }\n    PR_Unlock(li->li_config_mutex);\n    *returncode = LDAP_SUCCESS;\n    return SLAPI_DSE_CALLBACK_OK;\n}", "target": 1}
{"code": "static void free_states(struct bpf_verifier_env *env)\n{\n\tstruct bpf_verifier_state_list *sl, *sln;\n\tint i;\n\tsl = env->free_list;\n\twhile (sl) {\n\t\tsln = sl->next;\n\t\tfree_verifier_state(&sl->state, false);\n\t\tkfree(sl);\n\t\tsl = sln;\n\t}\n\tenv->free_list = NULL;\n\tif (!env->explored_states)\n\t\treturn;\n\tfor (i = 0; i < state_htab_size(env); i++) {\n\t\tsl = env->explored_states[i];\n\t\twhile (sl) {\n\t\t\tsln = sl->next;\n\t\t\tfree_verifier_state(&sl->state, false);\n\t\t\tkfree(sl);\n\t\t\tsl = sln;\n\t\t}\n\t\tenv->explored_states[i] = NULL;\n\t}\n}", "target": 0}
{"code": "static int asymmetric_key_match_preparse(struct key_match_data *match_data)\n{\n\tmatch_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;\n\tmatch_data->cmp = asymmetric_key_cmp;\n\treturn 0;\n}", "target": 0}
{"code": "static inline void o2nm_unlock_subsystem(void)\n{\n\tmutex_unlock(&o2nm_cluster_group.cs_subsys.su_mutex);\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    PoolParameters params{context,\n                          ksize_,\n                          stride_,\n                          padding_,\n                          {},\n                          FORMAT_NHWC,\n                          tensor_in.shape()};\n    if (!context->status().ok()) {\n      return;\n    }\n    const float min_input = context->input(1).flat<float>()(0);\n    const float max_input = context->input(2).flat<float>()(0);\n    OP_REQUIRES(context, params.depth_window == 1,\n                errors::Unimplemented(\"Non-spatial pooling is not \"\n                                      \"yet supported. Volunteers? :)\"));\n    OP_REQUIRES(context, tensor_in.dims() == 4,\n                errors::InvalidArgument(\"tensor_in must be 4-dimensional\"));\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                0, params.forward_output_shape(), &output));\n    const int32_t highest = static_cast<int32>(Eigen::NumTraits<T>::highest());\n    const int32_t lowest = static_cast<int32>(Eigen::NumTraits<T>::lowest());\n    Tensor int32_output(DT_INT32, params.forward_output_shape());\n    Tensor int32_input(DT_INT32, tensor_in.shape());\n    int32_input.flat<int32>() = tensor_in.flat<T>().template cast<int32>();\n    SpatialAvgPool<Device, int32>(context, &int32_output, int32_input, params,\n                                  padding_);\n    output->flat<T>() = int32_output.flat<int32>()\n                            .cwiseMax(lowest)\n                            .cwiseMin(highest)\n                            .template cast<T>();\n    Tensor* output_min = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, {}, &output_min));\n    output_min->flat<float>()(0) = min_input;\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(2, {}, &output_max));\n    output_max->flat<float>()(0) = max_input;\n  }", "target": 1}
{"code": "int smb2_allocate_rsp_buf(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *hdr = smb2_get_msg(work->request_buf);\n\tsize_t small_sz = MAX_CIFS_SMALL_BUFFER_SIZE;\n\tsize_t large_sz = small_sz + work->conn->vals->max_trans_size;\n\tsize_t sz = small_sz;\n\tint cmd = le16_to_cpu(hdr->Command);\n\tif (cmd == SMB2_IOCTL_HE || cmd == SMB2_QUERY_DIRECTORY_HE)\n\t\tsz = large_sz;\n\tif (cmd == SMB2_QUERY_INFO_HE) {\n\t\tstruct smb2_query_info_req *req;\n\t\treq = smb2_get_msg(work->request_buf);\n\t\tif (req->InfoType == SMB2_O_INFO_FILE &&\n\t\t    (req->FileInfoClass == FILE_FULL_EA_INFORMATION ||\n\t\t     req->FileInfoClass == FILE_ALL_INFORMATION))\n\t\t\tsz = large_sz;\n\t}\n\tif (le32_to_cpu(hdr->NextCommand) > 0)\n\t\tsz = large_sz;\n\twork->response_buf = kvmalloc(sz, GFP_KERNEL | __GFP_ZERO);\n\tif (!work->response_buf)\n\t\treturn -ENOMEM;\n\twork->response_sz = sz;\n\treturn 0;\n}", "target": 1}
{"code": "getprivs_ret * get_privs_2_svc(krb5_ui_4 *arg, struct svc_req *rqstp)\n{\n    static getprivs_ret            ret;\n    gss_buffer_desc                client_name, service_name;\n    OM_uint32                      minor_stat;\n    kadm5_server_handle_t          handle;\n    const char                     *errmsg = NULL;\n    xdr_free(xdr_getprivs_ret, &ret);\n    if ((ret.code = new_server_handle(*arg, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    ret.code = kadm5_get_privs((void *)handle, &ret.privs);\n    if( ret.code != 0 )\n        errmsg = krb5_get_error_message(handle->context, ret.code);\n    log_done(\"kadm5_get_privs\", client_name.value, errmsg,\n             &client_name, &service_name, rqstp);\n    if (errmsg != NULL)\n        krb5_free_error_message(handle->context, errmsg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "void cmov_int16(int16_t *r, int16_t v, uint16_t b)\n{\n  b = -b;\n  *r ^= b & ((*r) ^ v);\n}", "target": 0}
{"code": "static int bson_append_estart( bson *b, int type, const char *name, const int dataSize ) {\n    const int len = strlen( name ) + 1;\n    if ( b->finished ) {\n        b->err |= BSON_ALREADY_FINISHED;\n        return BSON_ERROR;\n    }\n    if ( bson_ensure_space( b, 1 + len + dataSize ) == BSON_ERROR ) {\n        return BSON_ERROR;\n    }\n    if( bson_check_field_name( b, ( const char * )name, len - 1 ) == BSON_ERROR ) {\n        bson_builder_error( b );\n        return BSON_ERROR;\n    }\n    bson_append_byte( b, ( char )type );\n    bson_append( b, name, len );\n    return BSON_OK;\n}", "target": 1}
{"code": "ZEND_API void zend_object_store_ctor_failed(zval *zobject TSRMLS_DC)\n{\n\tzend_object_handle handle = Z_OBJ_HANDLE_P(zobject);\n\tzend_object_store_bucket *obj_bucket = &EG(objects_store).object_buckets[handle];\n\tobj_bucket->bucket.obj.handlers = Z_OBJ_HT_P(zobject);;\n\tobj_bucket->destructor_called = 1;\n}", "target": 1}
{"code": "void flush_tlb_mm_range(struct mm_struct *mm, unsigned long start,\n\t\t\t\tunsigned long end, unsigned long vmflag)\n{\n\tunsigned long addr;\n\tunsigned long base_pages_to_flush = TLB_FLUSH_ALL;\n\tpreempt_disable();\n\tif (current->active_mm != mm)\n\t\tgoto out;\n\tif (!current->mm) {\n\t\tleave_mm(smp_processor_id());\n\t\tgoto out;\n\t}\n\tif ((end != TLB_FLUSH_ALL) && !(vmflag & VM_HUGETLB))\n\t\tbase_pages_to_flush = (end - start) >> PAGE_SHIFT;\n\tif (base_pages_to_flush > tlb_single_page_flush_ceiling) {\n\t\tbase_pages_to_flush = TLB_FLUSH_ALL;\n\t\tcount_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ALL);\n\t\tlocal_flush_tlb();\n\t} else {\n\t\tfor (addr = start; addr < end;\taddr += PAGE_SIZE) {\n\t\t\tcount_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ONE);\n\t\t\t__flush_tlb_single(addr);\n\t\t}\n\t}\n\ttrace_tlb_flush(TLB_LOCAL_MM_SHOOTDOWN, base_pages_to_flush);\nout:\n\tif (base_pages_to_flush == TLB_FLUSH_ALL) {\n\t\tstart = 0UL;\n\t\tend = TLB_FLUSH_ALL;\n\t}\n\tif (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) < nr_cpu_ids)\n\t\tflush_tlb_others(mm_cpumask(mm), mm, start, end);\n\tpreempt_enable();\n}", "target": 1}
{"code": "flatpak_validate_path_characters (const char *path,\n                                  GError    **error)\n{\n  while (*path)\n    {\n      gunichar c = g_utf8_get_char_validated (path, -1);\n      if (c == (gunichar)-1 || c == (gunichar)-2)\n        {\n          g_autofree char *escaped_char = escape_character ((unsigned char)*path);\n          g_autofree char *escaped = flatpak_escape_string (path, FLATPAK_ESCAPE_DEFAULT);\n          g_set_error (error, G_IO_ERROR, G_IO_ERROR_INVALID_DATA,\n                       \"Non-UTF8 byte %s in path %s\", escaped_char, escaped);\n          return FALSE;\n        }\n      else if (!is_char_safe (c))\n        {\n          g_autofree char *escaped_char = escape_character (c);\n          g_autofree char *escaped = flatpak_escape_string (path, FLATPAK_ESCAPE_DEFAULT);\n          g_set_error (error, G_IO_ERROR, G_IO_ERROR_INVALID_DATA,\n                       \"Non-graphical character %s in path %s\", escaped_char, escaped);\n          return FALSE;\n        }\n      path = g_utf8_find_next_char (path, NULL);\n    }\n  return TRUE;\n}", "target": 0}
{"code": "static void process_constructors(RKernelCacheObj *obj, struct MACH0_(obj_t) *mach0, RList *ret, ut64 paddr, bool is_first, int mode, const char *prefix) {\n\tconst RVector *sections = MACH0_(load_sections) (mach0);\n\tif (!sections) {\n\t\treturn;\n\t}\n\tint type;\n\tstruct section_t *section;\n\tr_vector_foreach (sections, section) {\n\t\tif (section->size == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strstr (section->name, \"_mod_fini_func\") || strstr (section->name, \"_mod_term_func\")) {\n\t\t\ttype  = R_BIN_ENTRY_TYPE_FINI;\n\t\t} else if (strstr (section->name, \"_mod_init_func\")) {\n\t\t\ttype  = is_first ? 0 : R_BIN_ENTRY_TYPE_INIT;\n\t\t\tis_first = false;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\tut8 *buf = calloc (section->size, 1);\n\t\tif (!buf) {\n\t\t\tbreak;\n\t\t}\n\t\tif (r_buf_read_at (obj->cache_buf, section->paddr + paddr, buf, section->size) < section->size) {\n\t\t\tfree (buf);\n\t\t\tbreak;\n\t\t}\n\t\tint j;\n\t\tint count = 0;\n\t\tfor (j = 0; j < section->size; j += 8) {\n\t\t\tut64 addr64 = K_RPTR (buf + j);\n\t\t\tut64 paddr64 = section->paddr + paddr + j;\n\t\t\tif (mode == R_K_CONSTRUCTOR_TO_ENTRY) {\n\t\t\t\tRBinAddr *ba = newEntry (paddr64, addr64, type);\n\t\t\t\tr_list_append (ret, ba);\n\t\t\t} else if (mode == R_K_CONSTRUCTOR_TO_SYMBOL) {\n\t\t\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\t\t\tif (!sym) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsym->name = r_str_newf (\"%s.%s.%d\", prefix, (type == R_BIN_ENTRY_TYPE_INIT) ? \"init\" : \"fini\", count++);\n\t\t\t\tsym->vaddr = addr64;\n\t\t\t\tsym->paddr = paddr64;\n\t\t\t\tsym->size = 0;\n\t\t\t\tsym->forwarder = \"NONE\";\n\t\t\t\tsym->bind = \"GLOBAL\";\n\t\t\t\tsym->type = \"FUNC\";\n\t\t\t\tr_list_append (ret, sym);\n\t\t\t}\n\t\t}\n\t\tfree (buf);\n\t}\n}", "target": 1}
{"code": "static void perf_callchain_user_64(struct perf_callchain_entry *entry,\n\t\t\t\t   struct pt_regs *regs)\n{\n\tunsigned long sp, next_sp;\n\tunsigned long next_ip;\n\tunsigned long lr;\n\tlong level = 0;\n\tstruct signal_frame_64 __user *sigframe;\n\tunsigned long __user *fp, *uregs;\n\tnext_ip = perf_instruction_pointer(regs);\n\tlr = regs->link;\n\tsp = regs->gpr[1];\n\tperf_callchain_store(entry, next_ip);\n\tfor (;;) {\n\t\tfp = (unsigned long __user *) sp;\n\t\tif (!valid_user_sp(sp, 1) || read_user_stack_64(fp, &next_sp))\n\t\t\treturn;\n\t\tif (level > 0 && read_user_stack_64(&fp[2], &next_ip))\n\t\t\treturn;\n\t\tif (next_sp - sp >= sizeof(struct signal_frame_64) &&\n\t\t    (is_sigreturn_64_address(next_ip, sp) ||\n\t\t     (level <= 1 && is_sigreturn_64_address(lr, sp))) &&\n\t\t    sane_signal_64_frame(sp)) {\n\t\t\tsigframe = (struct signal_frame_64 __user *) sp;\n\t\t\turegs = sigframe->uc.uc_mcontext.gp_regs;\n\t\t\tif (read_user_stack_64(&uregs[PT_NIP], &next_ip) ||\n\t\t\t    read_user_stack_64(&uregs[PT_LNK], &lr) ||\n\t\t\t    read_user_stack_64(&uregs[PT_R1], &sp))\n\t\t\t\treturn;\n\t\t\tlevel = 0;\n\t\t\tperf_callchain_store(entry, PERF_CONTEXT_USER);\n\t\t\tperf_callchain_store(entry, next_ip);\n\t\t\tcontinue;\n\t\t}\n\t\tif (level == 0)\n\t\t\tnext_ip = lr;\n\t\tperf_callchain_store(entry, next_ip);\n\t\t++level;\n\t\tsp = next_sp;\n\t}\n}", "target": 1}
{"code": "header_put_be_int (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 4)\n\t{\tpsf->header [psf->headindex++] = (x >> 24) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = x ;\n\t\t} ;\n} ", "target": 1}
{"code": "static OPJ_BOOL opj_j2k_write_sot(opj_j2k_t *p_j2k,\n                                  OPJ_BYTE * p_data,\n                                  OPJ_UINT32 p_total_data_size,\n                                  OPJ_UINT32 * p_data_written,\n                                  const opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager\n                                 )\n{\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n    OPJ_UNUSED(p_stream);\n    OPJ_UNUSED(p_manager);\n    if (p_total_data_size < 12) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Not enough bytes in output buffer to write SOT marker\\n\");\n        return OPJ_FALSE;\n    }\n    opj_write_bytes(p_data, J2K_MS_SOT,\n                    2);                                 \n    p_data += 2;\n    opj_write_bytes(p_data, 10,\n                    2);                                                   \n    p_data += 2;\n    opj_write_bytes(p_data, p_j2k->m_current_tile_number,\n                    2);                        \n    p_data += 2;\n    p_data += 4;\n    opj_write_bytes(p_data,\n                    p_j2k->m_specific_param.m_encoder.m_current_tile_part_number,\n                    1);                        \n    ++p_data;\n    opj_write_bytes(p_data,\n                    p_j2k->m_cp.tcps[p_j2k->m_current_tile_number].m_nb_tile_parts,\n                    1);                      \n    ++p_data;\n#ifdef USE_JPWL\n    assert(0 && \"TODO\");\n#endif \n    * p_data_written = 12;\n    return OPJ_TRUE;\n}", "target": 0}
{"code": "static void start_daemon()\n{\n\tstruct usb_sock_t *usb_sock;\n\tif (g_options.noprinter_mode == 0) {\n\t\tusb_sock = usb_open();\n\t\tif (usb_sock == NULL)\n\t\t\tgoto cleanup_usb;\n\t} else\n\t\tusb_sock = NULL;\n\tuint16_t desired_port = g_options.desired_port;\n\tstruct tcp_sock_t *tcp_socket;\n\twhile ((tcp_socket = tcp_open(desired_port)) == NULL &&\n\t       g_options.only_desired_port == 0) {\n\t\tdesired_port ++;\n\t\tif (desired_port == 1 || desired_port == 0)\n\t\t\tdesired_port = 49152;\n\t}\n\tif (tcp_socket == NULL)\n\t\tgoto cleanup_tcp;\n\tuint16_t real_port = tcp_port_number_get(tcp_socket);\n\tif (desired_port != 0 && g_options.only_desired_port == 1 &&\n\t    desired_port != real_port) {\n\t\tERR(\"Received port number did not match requested port number.\"\n\t\t    \" The requested port number may be too high.\");\n\t\tgoto cleanup_tcp;\n\t}\n\tprintf(\"%u|\", real_port);\n\tfflush(stdout);\n\tuint16_t pid;\n\tif (!g_options.nofork_mode && (pid = fork()) > 0) {\n\t\tprintf(\"%u|\", pid);\n\t\texit(0);\n\t}\n\tif (usb_can_callback(usb_sock))\n\t\tusb_register_callback(usb_sock);\n\tfor (;;) {\n\t\tstruct service_thread_param *args = calloc(1, sizeof(*args));\n\t\tif (args == NULL) {\n\t\t\tERR(\"Failed to alloc space for thread args\");\n\t\t\tgoto cleanup_thread;\n\t\t}\n\t\targs->usb_sock = usb_sock;\n\t\targs->tcp = tcp_conn_accept(tcp_socket);\n\t\tif (args->tcp == NULL) {\n\t\t\tERR(\"Failed to open tcp connection\");\n\t\t\tgoto cleanup_thread;\n\t\t}\n\t\tint status = pthread_create(&args->thread_handle, NULL,\n\t\t                            &service_connection, args);\n\t\tif (status) {\n\t\t\tERR(\"Failed to spawn thread, error %d\", status);\n\t\t\tgoto cleanup_thread;\n\t\t}\n\t\tcontinue;\n\tcleanup_thread:\n\t\tif (args != NULL) {\n\t\t\tif (args->tcp != NULL)\n\t\t\t\ttcp_conn_close(args->tcp);\n\t\t\tfree(args);\n\t\t}\n\t\tbreak;\n\t}\ncleanup_tcp:\n\tif (tcp_socket!= NULL)\n\t\ttcp_close(tcp_socket);\ncleanup_usb:\n\tif (usb_sock != NULL)\n\t\tusb_close(usb_sock);\n\treturn;\n}", "target": 1}
{"code": "void test_xattrs(const char *path)\n{\n\t char value[200];\n\t if (getxattr(path, \"security.selinux\", value, 200) >= 0) {\n\t\tfprintf(stderr, \"leak at getxattr of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at getxattr of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "call_bind_status(struct rpc_task *task)\n{\n\tint status = -EIO;\n\tif (task->tk_status >= 0) {\n\t\tdprint_status(task);\n\t\ttask->tk_status = 0;\n\t\ttask->tk_action = call_connect;\n\t\treturn;\n\t}\n\tswitch (task->tk_status) {\n\tcase -ENOMEM:\n\t\tdprintk(\"RPC: %5u rpcbind out of memory\\n\", task->tk_pid);\n\t\trpc_delay(task, HZ >> 2);\n\t\tgoto retry_timeout;\n\tcase -EACCES:\n\t\tdprintk(\"RPC: %5u remote rpcbind: RPC program/version \"\n\t\t\t\t\"unavailable\\n\", task->tk_pid);\n\t\tif (task->tk_msg.rpc_proc->p_proc == 0) {\n\t\t\tstatus = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n\t\tif (task->tk_rebind_retry == 0)\n\t\t\tbreak;\n\t\ttask->tk_rebind_retry--;\n\t\trpc_delay(task, 3*HZ);\n\t\tgoto retry_timeout;\n\tcase -ETIMEDOUT:\n\t\tdprintk(\"RPC: %5u rpcbind request timed out\\n\",\n\t\t\t\ttask->tk_pid);\n\t\tgoto retry_timeout;\n\tcase -EPFNOSUPPORT:\n\t\tdprintk(\"RPC: %5u unrecognized remote rpcbind service\\n\",\n\t\t\t\ttask->tk_pid);\n\t\tbreak;\n\tcase -EPROTONOSUPPORT:\n\t\tdprintk(\"RPC: %5u remote rpcbind version unavailable, retrying\\n\",\n\t\t\t\ttask->tk_pid);\n\t\ttask->tk_status = 0;\n\t\ttask->tk_action = call_bind;\n\t\treturn;\n\tcase -ECONNREFUSED:\t\t\n\tcase -ECONNRESET:\n\tcase -ENOTCONN:\n\tcase -EHOSTDOWN:\n\tcase -EHOSTUNREACH:\n\tcase -ENETUNREACH:\n\tcase -EPIPE:\n\t\tdprintk(\"RPC: %5u remote rpcbind unreachable: %d\\n\",\n\t\t\t\ttask->tk_pid, task->tk_status);\n\t\tif (!RPC_IS_SOFTCONN(task)) {\n\t\t\trpc_delay(task, 5*HZ);\n\t\t\tgoto retry_timeout;\n\t\t}\n\t\tstatus = task->tk_status;\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"RPC: %5u unrecognized rpcbind error (%d)\\n\",\n\t\t\t\ttask->tk_pid, -task->tk_status);\n\t}\n\trpc_exit(task, status);\n\treturn;\nretry_timeout:\n\ttask->tk_action = call_timeout;\n}", "target": 0}
{"code": "rpki_rtr_print(netdissect_options *ndo, register const u_char *pptr, register u_int len)\n{\n    u_int tlen, pdu_type, pdu_len;\n    const u_char *tptr;\n    const rpki_rtr_pdu *pdu_header;\n    tptr = pptr;\n    tlen = len;\n    if (!ndo->ndo_vflag) {\n\tND_PRINT((ndo, \", RPKI-RTR\"));\n\treturn;\n    }\n    while (tlen >= sizeof(rpki_rtr_pdu)) {\n        ND_TCHECK2(*tptr, sizeof(rpki_rtr_pdu));\n\tpdu_header = (const rpki_rtr_pdu *)tptr;\n        pdu_type = pdu_header->pdu_type;\n        pdu_len = EXTRACT_32BITS(pdu_header->length);\n        ND_TCHECK2(*tptr, pdu_len);\n        if (!pdu_type || !pdu_len) {\n            break;\n        }\n        if (tlen < pdu_len) {\n            goto trunc;\n        }\n\tif (rpki_rtr_pdu_print(ndo, tptr, 8))\n\t\tgoto trunc;\n        tlen -= pdu_len;\n        tptr += pdu_len;\n    }\n    return;\ntrunc:\n    ND_PRINT((ndo, \"\\n\\t%s\", tstr));\n}", "target": 1}
{"code": "static void __exit acpi_custom_method_exit(void)\n{\n\tif (cm_dentry)\n\t\tdebugfs_remove(cm_dentry);\n }", "target": 0}
{"code": "static int digi_startup(struct usb_serial *serial)\n{\n\tstruct device *dev = &serial->interface->dev;\n\tstruct digi_serial *serial_priv;\n\tint ret;\n\tint i;\n\tif (serial->num_port_pointers < serial->type->num_ports + 1) {\n\t\tdev_err(dev, \"OOB endpoints missing\\n\");\n\t\treturn -ENODEV;\n\t}\n\tfor (i = 0; i < serial->type->num_ports + 1 ; i++) {\n\t\tif (!serial->port[i]->read_urb) {\n\t\t\tdev_err(dev, \"bulk-in endpoint missing\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tif (!serial->port[i]->write_urb) {\n\t\t\tdev_err(dev, \"bulk-out endpoint missing\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\tserial_priv = kzalloc(sizeof(*serial_priv), GFP_KERNEL);\n\tif (!serial_priv)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&serial_priv->ds_serial_lock);\n\tserial_priv->ds_oob_port_num = serial->type->num_ports;\n\tserial_priv->ds_oob_port = serial->port[serial_priv->ds_oob_port_num];\n\tret = digi_port_init(serial_priv->ds_oob_port,\n\t\t\t\t\t\tserial_priv->ds_oob_port_num);\n\tif (ret) {\n\t\tkfree(serial_priv);\n\t\treturn ret;\n\t}\n\tusb_set_serial_data(serial, serial_priv);\n\treturn 0;\n}", "target": 0}
{"code": "enum nss_status _nss_mymachines_getgrnam_r(\n                const char *name,\n                struct group *gr,\n                char *buffer, size_t buflen,\n                int *errnop) {\n        _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL;\n        _cleanup_bus_message_unref_ sd_bus_message* reply = NULL;\n        _cleanup_bus_flush_close_unref_ sd_bus *bus = NULL;\n        const char *p, *e, *machine;\n        uint32_t mapped;\n        uid_t gid;\n        size_t l;\n        int r;\n        assert(name);\n        assert(gr);\n        p = startswith(name, \"vg-\");\n        if (!p)\n                goto not_found;\n        e = strrchr(p, '-');\n        if (!e || e == p)\n                goto not_found;\n        if (e - p > HOST_NAME_MAX - 1)  \n                goto not_found;\n        r = parse_gid(e + 1, &gid);\n        if (r < 0)\n                goto not_found;\n        machine = strndupa(p, e - p);\n        if (!machine_name_is_valid(machine))\n                goto not_found;\n        r = sd_bus_open_system(&bus);\n        if (r < 0)\n                goto fail;\n        r = sd_bus_call_method(bus,\n                               \"org.freedesktop.machine1\",\n                               \"/org/freedesktop/machine1\",\n                               \"org.freedesktop.machine1.Manager\",\n                               \"MapFromMachineGroup\",\n                               &error,\n                               &reply,\n                               \"su\",\n                               machine, (uint32_t) gid);\n        if (r < 0) {\n                if (sd_bus_error_has_name(&error, BUS_ERROR_NO_SUCH_GROUP_MAPPING))\n                        goto not_found;\n                goto fail;\n        }\n        r = sd_bus_message_read(reply, \"u\", &mapped);\n        if (r < 0)\n                goto fail;\n        l = sizeof(char*) + strlen(name) + 1;\n        if (buflen < l) {\n                *errnop = ENOMEM;\n                return NSS_STATUS_TRYAGAIN;\n        }\n        memzero(buffer, sizeof(char*));\n        strcpy(buffer + sizeof(char*), name);\n        gr->gr_name = buffer + sizeof(char*);\n        gr->gr_gid = gid;\n        gr->gr_passwd = (char*) \"*\"; \n        gr->gr_mem = (char**) buffer;\n        *errnop = 0;\n        return NSS_STATUS_SUCCESS;\nnot_found:\n        *errnop = 0;\n        return NSS_STATUS_NOTFOUND;\nfail:\n        *errnop = -r;\n        return NSS_STATUS_UNAVAIL;\n}", "target": 0}
{"code": "DefragTracker *DefragGetTrackerFromHash (Packet *p)\n{\n    DefragTracker *dt = NULL;\n    uint32_t key = DefragHashGetKey(p);\n    DefragTrackerHashRow *hb = &defragtracker_hash[key];\n    DRLOCK_LOCK(hb);\n    if (hb->head == NULL) {\n        dt = DefragTrackerGetNew(p);\n        if (dt == NULL) {\n            DRLOCK_UNLOCK(hb);\n            return NULL;\n        }\n        hb->head = dt;\n        hb->tail = dt;\n        DefragTrackerInit(dt,p);\n        DRLOCK_UNLOCK(hb);\n        return dt;\n    }\n    dt = hb->head;\n    if (dt->remove || DefragTrackerCompare(dt, p) == 0) {\n        DefragTracker *pdt = NULL; \n        while (dt) {\n            pdt = dt;\n            dt = dt->hnext;\n            if (dt == NULL) {\n                dt = pdt->hnext = DefragTrackerGetNew(p);\n                if (dt == NULL) {\n                    DRLOCK_UNLOCK(hb);\n                    return NULL;\n                }\n                hb->tail = dt;\n                dt->hprev = pdt;\n                DefragTrackerInit(dt,p);\n                DRLOCK_UNLOCK(hb);\n                return dt;\n            }\n            if (DefragTrackerCompare(dt, p) != 0) {\n                if (dt->hnext) {\n                    dt->hnext->hprev = dt->hprev;\n                }\n                if (dt->hprev) {\n                    dt->hprev->hnext = dt->hnext;\n                }\n                if (dt == hb->tail) {\n                    hb->tail = dt->hprev;\n                }\n                dt->hnext = hb->head;\n                dt->hprev = NULL;\n                hb->head->hprev = dt;\n                hb->head = dt;\n                SCMutexLock(&dt->lock);\n                (void) DefragTrackerIncrUsecnt(dt);\n                DRLOCK_UNLOCK(hb);\n                return dt;\n            }\n        }\n    }\n    SCMutexLock(&dt->lock);\n    (void) DefragTrackerIncrUsecnt(dt);\n    DRLOCK_UNLOCK(hb);\n    return dt;\n}", "target": 1}
{"code": "static Jsi_RC jsi_ArrayUnshiftCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    Jsi_Obj *obj = _this->d.obj;\n    int argc = Jsi_ValueGetLength(interp, args);\n    int curlen = Jsi_ObjGetLength(interp, obj);\n    if (curlen < 0) {\n        Jsi_ObjSetLength(interp, obj, 0);\n    }\n    if (argc <= 0) {\n        Jsi_ValueMakeNumber(interp, ret, 0);\n        return JSI_OK;\n    }\n    Jsi_ObjListifyArray(interp, obj);\n    if (Jsi_ObjArraySizer(interp, obj, curlen+argc)<=0) \n        return Jsi_LogError(\"too long\");\n    memmove(obj->arr+argc, obj->arr, (curlen)*sizeof(Jsi_Value*));\n    obj->arrCnt += argc;\n    int i;\n    for (i = 0; i < argc; ++i) {\n        Jsi_Value *ov = Jsi_ValueArrayIndex(interp, args, i);\n        obj->arr[i] = NULL;\n        if (!ov) { Jsi_LogBug(\"Arguments Error\"); continue; }\n        obj->arr[i] = ov;\n        Jsi_IncrRefCount(interp, ov);\n    }\n    Jsi_ObjSetLength(interp, obj, curlen+argc);\n    Jsi_ValueMakeNumber(interp, ret, Jsi_ObjGetLength(interp, obj));\n    return JSI_OK;\n}", "target": 1}
{"code": "ImmutableConstantOp::ImmutableConstantOp(OpKernelConstruction* context)\n    : OpKernel(context) {\n  OP_REQUIRES_OK(context,\n                 context->GetAttr(kMemoryRegionNameAttr, &region_name_));\n  OP_REQUIRES_OK(context, context->GetAttr(kDTypeAttr, &dtype_));\n  OP_REQUIRES(context, dtype_ != DT_RESOURCE && dtype_ != DT_VARIANT,\n              errors::InvalidArgument(\n                  \"Resource and variant dtypes are invalid for this op.\"));\n  OP_REQUIRES_OK(context, context->GetAttr(kShapeAttr, &shape_));\n}", "target": 0}
{"code": "static void* my_gballoc_realloc(void* ptr, size_t size)\n{\n    return realloc(ptr, size);\n}", "target": 0}
{"code": "void PixelBuffer::setSize(int width, int height)\n{\n  if ((width < 0) || (width > maxPixelBufferWidth))\n    throw rfb::Exception(\"Invalid PixelBuffer width of %d pixels requested\", width);\n  if ((height < 0) || (height > maxPixelBufferHeight))\n    throw rfb::Exception(\"Invalid PixelBuffer height of %d pixels requested\", height);\n  width_ = width;\n  height_ = height;\n}", "target": 0}
{"code": "static void on_bytes_received(void* context, const unsigned char* buffer, size_t size)\n{\n    unsigned char* new_received_bytes;\n    HTTP_HANDLE_DATA* http_instance = (HTTP_HANDLE_DATA*)context;\n    if (http_instance != NULL)\n    {\n        if (buffer == NULL)\n        {\n            http_instance->is_io_error = 1;\n            LogError(\"NULL pointer error\");\n        }\n        else\n        {\n            new_received_bytes = (unsigned char*)realloc(http_instance->received_bytes, http_instance->received_bytes_count + size);\n            if (new_received_bytes == NULL)\n            {\n                http_instance->is_io_error = 1;\n                LogError(\"Error allocating memory for received data\");\n            }\n            else\n            {\n                http_instance->received_bytes = new_received_bytes;\n                if (memcpy(http_instance->received_bytes + http_instance->received_bytes_count, buffer, size) == NULL)\n                {\n                    http_instance->is_io_error = 1;\n                    LogError(\"Error copping received data to the HTTP bufffer\");\n                }\n                else\n                {\n                    http_instance->received_bytes_count += size;\n                }\n            }\n        }\n    }\n}", "target": 1}
{"code": "static char *oidc_cache_get_hashed_key(request_rec *r, const char *passphrase,\n\t\tconst char *key) {\n\tchar *input = apr_psprintf(r->pool, \"%s:%s\", passphrase, key);\n\tchar *output = NULL;\n\tif (oidc_util_hash_string_and_base64url_encode(r, OIDC_JOSE_ALG_SHA256,\n\t\t\tinput, &output) == FALSE) {\n\t\toidc_error(r,\n\t\t\t\t\"oidc_util_hash_string_and_base64url_encode returned an error\");\n\t\treturn NULL;\n\t}\n\treturn output;\n}", "target": 1}
{"code": "FastCGIServer::FastCGIServer(const std::string &address,\n                             int port,\n                             int workers,\n                             bool useFileSocket)\n  : Server(address, port),\n    m_worker(&m_eventBaseManager),\n    m_dispatcher(workers, workers,\n                 RuntimeOption::ServerThreadDropCacheTimeoutSeconds,\n                 RuntimeOption::ServerThreadDropStack,\n                 this,\n                 RuntimeOption::ServerThreadJobLIFOSwitchThreshold,\n                 RuntimeOption::ServerThreadJobMaxQueuingMilliSeconds,\n                 RequestPriority::k_numPriorities) {\n  folly::SocketAddress sock_addr;\n  if (useFileSocket) {\n    sock_addr.setFromPath(address);\n  } else if (address.empty()) {\n    sock_addr.setFromLocalPort(port);\n  } else {\n    sock_addr.setFromHostPort(address, port);\n  }\n  m_socketConfig.bindAddress = sock_addr;\n  m_socketConfig.acceptBacklog = RuntimeOption::ServerBacklog;\n  std::chrono::seconds timeout;\n  if (RuntimeOption::ConnectionTimeoutSeconds >= 0) {\n    timeout = std::chrono::seconds(RuntimeOption::ConnectionTimeoutSeconds);\n  } else {\n    timeout = std::chrono::seconds(120);\n  }\n  m_socketConfig.connectionIdleTimeout = timeout;\n}", "target": 1}
{"code": "GetSamplingFrequencyIndex(unsigned int sampling_frequency)\n{\n    switch (sampling_frequency) {\n        case 96000: return 0;\n        case 88200: return 1;\n        case 64000: return 2;\n        case 48000: return 3;\n        case 44100: return 4;\n        case 32000: return 5;\n        case 24000: return 6;\n        case 22050: return 7;\n        case 16000: return 8;\n        case 12000: return 9;\n        case 11025: return 10;\n        case 8000:  return 11;\n        case 7350:  return 12;\n        default:    return 0;\n    }\n}", "target": 0}
{"code": "TEST(DepthToSpaceOpModel, NoBlockSize) {\n  EXPECT_DEATH(DepthToSpaceOpModel({TensorType_FLOAT32, {1, 1, 1, 4}}, 0),\n               \"Cannot allocate tensors\");\n}", "target": 0}
{"code": "folly::Optional<ErrorCode> HTTP2Codec::parseHeadersDecodeFrames(\n    const folly::Optional<http2::PriorityUpdate>& priority,\n    const folly::Optional<uint32_t>& promisedStream,\n    const folly::Optional<ExAttributes>& exAttributes,\n    std::unique_ptr<HTTPMessage>& msg) {\n  Cursor headerCursor(curHeaderBlock_.front());\n  bool isReq = false;\n  if (promisedStream) {\n    isReq = true;\n  } else if (exAttributes) {\n    isReq = isRequest(curHeader_.stream);\n  } else {\n    isReq = transportDirection_ == TransportDirection::DOWNSTREAM;\n  }\n  decodeInfo_.init(isReq, parsingDownstreamTrailers_);\n  if (priority) {\n    if (curHeader_.stream == priority->streamDependency) {\n      streamError(folly::to<string>(\"Circular dependency for txn=\",\n                                    curHeader_.stream),\n                  ErrorCode::PROTOCOL_ERROR,\n                  curHeader_.type == http2::FrameType::HEADERS);\n      return ErrorCode::NO_ERROR;\n    }\n    decodeInfo_.msg->setHTTP2Priority(\n        std::make_tuple(priority->streamDependency,\n                        priority->exclusive,\n                        priority->weight));\n  }\n  headerCodec_.decodeStreaming(\n      headerCursor, curHeaderBlock_.chainLength(), this);\n  msg = std::move(decodeInfo_.msg);\n  auto g = folly::makeGuard([this] { curHeaderBlock_.move(); });\n  if (decodeInfo_.decodeError != HPACK::DecodeError::NONE) {\n    static const std::string decodeErrorMessage =\n        \"Failed decoding header block for stream=\";\n    if (decodeInfo_.decodeError != HPACK::DecodeError::HEADERS_TOO_LARGE) {\n      LOG(ERROR) << decodeErrorMessage << curHeader_.stream\n                 << \" header block=\";\n      VLOG(3) << IOBufPrinter::printHexFolly(curHeaderBlock_.front(), true);\n    } else {\n      LOG(ERROR) << decodeErrorMessage << curHeader_.stream;\n    }\n    if (msg) {\n      msg->dumpMessage(3);\n    }\n    return ErrorCode::COMPRESSION_ERROR;\n  }\n  if (decodeInfo_.parsingError != \"\") {\n    LOG(ERROR) << \"Failed parsing header list for stream=\" << curHeader_.stream\n               << \", error=\" << decodeInfo_.parsingError << \", header block=\";\n    VLOG(3) << IOBufPrinter::printHexFolly(curHeaderBlock_.front(), true);\n    HTTPException err(HTTPException::Direction::INGRESS,\n                      folly::to<std::string>(\"HTTP2Codec stream error: \",\n                                             \"stream=\",\n                                             curHeader_.stream,\n                                             \" status=\",\n                                             400,\n                                             \" error: \",\n                                             decodeInfo_.parsingError));\n    err.setHttpStatusCode(400);\n    callback_->onError(curHeader_.stream, err, true);\n    return ErrorCode::NO_ERROR;\n  }\n  return folly::Optional<ErrorCode>();\n}", "target": 1}
{"code": "compute_U_value_R3(std::string const& user_password,\n\t\t   QPDF::EncryptionData const& data)\n{\n    std::string k1 = QPDF::compute_encryption_key(user_password, data);\n    MD5 md5;\n    md5.encodeDataIncrementally(\n\tpad_or_truncate_password_V4(\"\").c_str(), key_bytes);\n    md5.encodeDataIncrementally(data.getId1().c_str(),\n                                data.getId1().length());\n    MD5::Digest digest;\n    md5.digest(digest);\n    pad_short_parameter(k1, data.getLengthBytes());\n    iterate_rc4(digest, sizeof(MD5::Digest),\n\t\tQUtil::unsigned_char_pointer(k1),\n                data.getLengthBytes(), 20, false);\n    char result[key_bytes];\n    memcpy(result, digest, sizeof(MD5::Digest));\n    for (unsigned int i = sizeof(MD5::Digest); i < key_bytes; ++i)\n    {\n\tresult[i] = static_cast<char>((i * i) % 0xff);\n    }\n    return std::string(result, key_bytes);\n}", "target": 0}
{"code": "static Jsi_RC StringSearchCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int sLen, bLen;\n    const char *source_str;\n    ChkString(_this, funcPtr, source_str, &sLen, &bLen);\n    char *v = _this->d.obj->d.s.str;\n    Jsi_Value *seq = Jsi_ValueArrayIndex(interp, args, skip);\n    if (Jsi_ValueIsString(interp, seq)) {\n        char *ce, *cp = Jsi_ValueString(interp, seq, NULL);\n        int n = -1;\n        if ((ce = Jsi_Strstr(source_str, cp))) {\n            n = (ce-source_str);\n        }\n        Jsi_ValueMakeNumber(interp, ret, n);\n        return JSI_OK;\n    }\n    if (!seq || seq->vt != JSI_VT_OBJECT || seq->d.obj->ot != JSI_OT_REGEXP) {\n        Jsi_ValueMakeNumber(interp, ret, -1);\n        return JSI_OK;\n    }\n    regex_t *reg = &seq->d.obj->d.robj->reg;\n    regmatch_t pos[MAX_SUBREGEX] = {};\n    int r;\n    if ((r = regexec(reg, v, MAX_SUBREGEX, pos, 0)) != 0) {\n        if (r == REG_NOMATCH) {\n            Jsi_ValueMakeNumber(interp, ret, -1.0);\n            return JSI_OK;\n        }\n        if (r >= REG_BADPAT) {\n            char buf[100];\n            regerror(r, reg, buf, sizeof(buf));\n            Jsi_LogError(\"error while matching pattern: %s\", buf);\n            return JSI_ERROR;\n        }\n    }\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)pos[0].rm_so);\n    return JSI_OK;\n}", "target": 1}
{"code": "void RenderView::didUpdateInspectorSetting(const WebString& key,\n                                           const WebString& value) {\n  Send(new ViewHostMsg_UpdateInspectorSetting(routing_id_,\n                                              key.utf8(),\n                                              value.utf8()));\n}", "target": 0}
{"code": "ikev1_cr_print(netdissect_options *ndo, u_char tpay _U_,\n\t       const struct isakmp_gen *ext, u_int item_len,\n\t       const u_char *ep _U_, uint32_t phase _U_, uint32_t doi0 _U_,\n\t       uint32_t proto0 _U_, int depth _U_)\n{\n\tconst struct ikev1_pl_cert *p;\n\tstruct ikev1_pl_cert cert;\n\tstatic const char *certstr[] = {\n\t\t\"none\",\t\"pkcs7\", \"pgp\", \"dns\",\n\t\t\"x509sign\", \"x509ke\", \"kerberos\", \"crl\",\n\t\t\"arl\", \"spki\", \"x509attr\",\n\t};\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_CR)));\n\tp = (const struct ikev1_pl_cert *)ext;\n\tND_TCHECK(*p);\n\tUNALIGNED_MEMCPY(&cert, ext, sizeof(cert));\n\tND_PRINT((ndo,\" len=%d\", item_len - 4));\n\tND_PRINT((ndo,\" type=%s\", STR_OR_ID((cert.encode), certstr)));\n\tif (2 < ndo->ndo_vflag && 4 < item_len) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), item_len - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + item_len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_CR)));\n\treturn NULL;\n}", "target": 0}
{"code": "void HeaderMapImpl::remove(const LowerCaseString& key) {\n  EntryCb cb = ConstSingleton<StaticLookupTable>::get().find(key.get());\n  if (cb) {\n    StaticLookupResponse ref_lookup_response = cb(*this);\n    removeInline(ref_lookup_response.entry_);\n  } else {\n    for (auto i = headers_.begin(); i != headers_.end();) {\n      if (i->key() == key.get().c_str()) {\n        subtractSize(i->key().size() + i->value().size());\n        i = headers_.erase(i);\n      } else {\n        ++i;\n      }\n    }\n  }\n}", "target": 0}
{"code": "void PeerListWidget::updatePeer(const QString &ip, BitTorrent::TorrentHandle *const torrent, const BitTorrent::PeerInfo &peer)\n{\n    QStandardItem *item = m_peerItems.value(ip);\n    int row = item->row();\n    if (m_resolveCountries) {\n        const QIcon ico = GuiIconProvider::instance()->getFlagIcon(peer.country());\n        if (!ico.isNull()) {\n            m_listModel->setData(m_listModel->index(row, PeerListDelegate::COUNTRY), ico, Qt::DecorationRole);\n            const QString countryName = Net::GeoIPManager::CountryName(peer.country());\n            m_listModel->setData(m_listModel->index(row, PeerListDelegate::COUNTRY), countryName, Qt::ToolTipRole);\n            m_missingFlags.remove(ip);\n        }\n    }\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::CONNECTION), peer.connectionType());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::PORT), peer.address().port);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flags());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flagsDescription(), Qt::ToolTipRole);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::CLIENT), peer.client());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::PROGRESS), peer.progress());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWN_SPEED), peer.payloadDownSpeed());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::UP_SPEED), peer.payloadUpSpeed());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::TOT_DOWN), peer.totalDownload());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::TOT_UP), peer.totalUpload());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::RELEVANCE), peer.relevance());\n    QStringList downloadingFiles(torrent->info().filesForPiece(peer.downloadingPieceIndex()));\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWNLOADING_PIECE), downloadingFiles.join(QLatin1String(\";\")));\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWNLOADING_PIECE), downloadingFiles.join(QLatin1String(\"\\n\")), Qt::ToolTipRole);\n}", "target": 1}
{"code": "libarchive_read_next_header (EvArchive *archive,\n\t\t\t     GError   **error)\n{\n\twhile (1) {\n\t\tint r;\n\t\tr = archive_read_next_header (archive->libar, &archive->libar_entry);\n\t\tif (r != ARCHIVE_OK) {\n\t\t\tif (r != ARCHIVE_EOF)\n\t\t\t\tg_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,\n\t\t\t\t\t     \"Error reading archive: %s\", archive_error_string (archive->libar));\n\t\t\treturn FALSE;\n\t\t}\n\t\tif (archive_entry_filetype (archive->libar_entry) != AE_IFREG) {\n\t\t\tg_debug (\"Skipping '%s' as it's not a regular file\",\n\t\t\t\t archive_entry_pathname (archive->libar_entry));\n\t\t\tcontinue;\n\t\t}\n\t\tg_debug (\"At header for file '%s'\", archive_entry_pathname (archive->libar_entry));\n\t\tbreak;\n\t}\n\treturn TRUE;\n}", "target": 0}
{"code": "Status SparseCountSparseOutputShapeFn(InferenceContext *c) {\n  ShapeHandle unused;\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &unused));\n  auto rank = c->Dim(c->input(0), 1);\n  auto nvals = c->UnknownDim();\n  c->set_output(0, c->Matrix(nvals, rank));  \n  c->set_output(1, c->Vector(nvals));        \n  c->set_output(2, c->Vector(rank));         \n  return Status::OK();\n}", "target": 0}
{"code": "int genl_register_family(struct genl_family *family)\n{\n\tint err, i;\n\tint start = GENL_START_ALLOC, end = GENL_MAX_ID;\n\terr = genl_validate_ops(family);\n\tif (err)\n\t\treturn err;\n\tgenl_lock_all();\n\tif (genl_family_find_byname(family->name)) {\n\t\terr = -EEXIST;\n\t\tgoto errout_locked;\n\t}\n\tif (family == &genl_ctrl) {\n\t\tstart = end = GENL_ID_CTRL;\n\t} else if (strcmp(family->name, \"pmcraid\") == 0) {\n\t\tstart = end = GENL_ID_PMCRAID;\n\t} else if (strcmp(family->name, \"VFS_DQUOT\") == 0) {\n\t\tstart = end = GENL_ID_VFS_DQUOT;\n\t}\n\tif (family->maxattr && !family->parallel_ops) {\n\t\tfamily->attrbuf = kmalloc_array(family->maxattr + 1,\n\t\t\t\t\t\tsizeof(struct nlattr *),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (family->attrbuf == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto errout_locked;\n\t\t}\n\t} else\n\t\tfamily->attrbuf = NULL;\n\tfamily->id = idr_alloc(&genl_fam_idr, family,\n\t\t\t       start, end + 1, GFP_KERNEL);\n\tif (family->id < 0) {\n\t\terr = family->id;\n\t\tgoto errout_locked;\n\t}\n\terr = genl_validate_assign_mc_groups(family);\n\tif (err)\n\t\tgoto errout_remove;\n\tgenl_unlock_all();\n\tgenl_ctrl_event(CTRL_CMD_NEWFAMILY, family, NULL, 0);\n\tfor (i = 0; i < family->n_mcgrps; i++)\n\t\tgenl_ctrl_event(CTRL_CMD_NEWMCAST_GRP, family,\n\t\t\t\t&family->mcgrps[i], family->mcgrp_offset + i);\n\treturn 0;\nerrout_remove:\n\tidr_remove(&genl_fam_idr, family->id);\n\tkfree(family->attrbuf);\nerrout_locked:\n\tgenl_unlock_all();\n\treturn err;\n}", "target": 1}
{"code": "BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n{\n\tuint8_t *argb;\n\tint x, y;\n\tuint8_t *p;\n\tuint8_t *out;\n\tsize_t out_size;\n\tif (im == NULL) {\n\t\treturn;\n\t}\n\tif (!gdImageTrueColor(im)) {\n\t\tgd_error(\"Paletter image not supported by webp\");\n\t\treturn;\n\t}\n\tif (quality == -1) {\n\t\tquality = 80;\n\t}\n\tif (overflow2(gdImageSX(im), 4)) {\n\t\treturn;\n\t}\n\tif (overflow2(gdImageSX(im) * 4, gdImageSY(im))) {\n\t\treturn;\n\t}\n\targb = (uint8_t *)gdMalloc(gdImageSX(im) * 4 * gdImageSY(im));\n\tif (!argb) {\n\t\treturn;\n\t}\n\tp = argb;\n\tfor (y = 0; y < gdImageSY(im); y++) {\n\t\tfor (x = 0; x < gdImageSX(im); x++) {\n\t\t\tregister int c;\n\t\t\tregister char a;\n\t\t\tc = im->tpixels[y][x];\n\t\t\ta = gdTrueColorGetAlpha(c);\n\t\t\tif (a == 127) {\n\t\t\t\ta = 0;\n\t\t\t} else {\n\t\t\t\ta = 255 - ((a << 1) + (a >> 6));\n\t\t\t}\n\t\t\t*(p++) = gdTrueColorGetRed(c);\n\t\t\t*(p++) = gdTrueColorGetGreen(c);\n\t\t\t*(p++) = gdTrueColorGetBlue(c); \n\t\t\t*(p++) = a;\n\t\t}\n\t}\n\tout_size = WebPEncodeRGBA(argb, gdImageSX(im), gdImageSY(im), gdImageSX(im) * 4, quality, &out);\n\tif (out_size == 0) {\n\t\tgd_error(\"gd-webp encoding failed\");\n\t\tgoto freeargb;\n\t}\n\tgdPutBuf(out, out_size, outfile);\n\tfree(out);\nfreeargb:\n\tgdFree(argb);\n}", "target": 1}
{"code": "static char *r_socket_http_answer (RSocket *s, int *code, int *rlen) {\n\tr_return_val_if_fail (s, NULL);\n\tconst char *p;\n\tint ret, len = 0, bufsz = 32768, delta = 0;\n\tchar *dn, *buf = calloc (1, bufsz + 32); \n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\tchar *res = NULL;\n\tint olen = __socket_slurp (s, (ut8*)buf, bufsz);\n\tif ((dn = (char*)r_str_casestr (buf, \"\\n\\n\"))) {\n\t\tdelta += 2;\n\t} else if ((dn = (char*)r_str_casestr (buf, \"\\r\\n\\r\\n\"))) {\n\t\tdelta += 4;\n\t} else {\n\t\tgoto fail;\n\t}\n\tolen -= delta;\n\t*dn = 0; \n\tp = r_str_casestr (buf, \"Content-Length: \");\n\tif (p) {\n\t\tlen = atoi (p + 16);\n\t} else {\n\t\tlen = olen - (dn - buf);\n\t}\n\tif (len > 0) {\n\t\tif (len > olen) {\n\t\t\tres = malloc (len + 2);\n\t\t\tmemcpy (res, dn + delta, olen);\n\t\t\tdo {\n\t\t\t\tret = r_socket_read_block (s, (ut8*) res + olen, len - olen);\n\t\t\t\tif (ret < 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tolen += ret;\n\t\t\t} while (olen < len);\n\t\t\tres[len] = 0;\n\t\t} else {\n\t\t\tres = malloc (len + 1);\n\t\t\tif (res) {\n\t\t\t\tmemcpy (res, dn + delta, len);\n\t\t\t\tres[len] = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tres = NULL;\n\t}\nfail:\n\tfree (buf);\n\tr_socket_close (s);\n\tif (rlen) {\n\t\t*rlen = len;\n\t}\n\treturn res;\n}", "target": 1}
{"code": "static void start_auth_request(PgSocket *client, const char *username)\n{\n\tint res;\n\tPktBuf *buf;\n\tclient->auth_user = client->db->auth_user;\n\tclient->pool = get_pool(client->db, client->db->auth_user);\n\tif (!find_server(client)) {\n\t\tclient->wait_for_user_conn = true;\n\t\treturn;\n\t}\n\tslog_noise(client, \"Doing auth_conn query\");\n\tclient->wait_for_user_conn = false;\n\tclient->wait_for_user = true;\n\tif (!sbuf_pause(&client->sbuf)) {\n\t\trelease_server(client->link);\n\t\tdisconnect_client(client, true, \"pause failed\");\n\t\treturn;\n\t}\n\tclient->link->ready = 0;\n\tres = 0;\n\tbuf = pktbuf_dynamic(512);\n\tif (buf) {\n\t\tpktbuf_write_ExtQuery(buf, cf_auth_query, 1, username);\n\t\tres = pktbuf_send_immediate(buf, client->link);\n\t\tpktbuf_free(buf);\n\t}\n\tif (!res)\n\t\tdisconnect_server(client->link, false, \"unable to send login query\");\n}", "target": 1}
{"code": "PHPAPI zend_string *php_escape_shell_arg(char *str)\n{\n\tint x, y = 0, l = (int)strlen(str);\n\tzend_string *cmd;\n\tsize_t estimate = (4 * l) + 3;\n\tcmd = zend_string_alloc(4 * l + 2, 0); \n#ifdef PHP_WIN32\n\tZSTR_VAL(cmd)[y++] = '\"';\n#else\n\tZSTR_VAL(cmd)[y++] = '\\'';\n#endif\n\tfor (x = 0; x < l; x++) {\n\t\tint mb_len = php_mblen(str + x, (l - x));\n\t\tif (mb_len < 0) {\n\t\t\tcontinue;\n\t\t} else if (mb_len > 1) {\n\t\t\tmemcpy(ZSTR_VAL(cmd) + y, str + x, mb_len);\n\t\t\ty += mb_len;\n\t\t\tx += mb_len - 1;\n\t\t\tcontinue;\n\t\t}\n\t\tswitch (str[x]) {\n#ifdef PHP_WIN32\n\t\tcase '\"':\n\t\tcase '%':\n\t\tcase '!':\n\t\t\tZSTR_VAL(cmd)[y++] = ' ';\n\t\t\tbreak;\n#else\n\t\tcase '\\'':\n\t\t\tZSTR_VAL(cmd)[y++] = '\\'';\n\t\t\tZSTR_VAL(cmd)[y++] = '\\\\';\n\t\t\tZSTR_VAL(cmd)[y++] = '\\'';\n#endif\n\t\tdefault:\n\t\t\tZSTR_VAL(cmd)[y++] = str[x];\n\t\t}\n\t}\n#ifdef PHP_WIN32\n\tif (y > 0 && '\\\\' == ZSTR_VAL(cmd)[y - 1]) {\n\t\tint k = 0, n = y - 1;\n\t\tfor (; n >= 0 && '\\\\' == ZSTR_VAL(cmd)[n]; n--, k++);\n\t\tif (k % 2) {\n\t\t\tZSTR_VAL(cmd)[y++] = '\\\\';\n\t\t}\n\t}\n\tZSTR_VAL(cmd)[y++] = '\"';\n#else\n\tZSTR_VAL(cmd)[y++] = '\\'';\n#endif\n\tZSTR_VAL(cmd)[y] = '\\0';\n\tif ((estimate - y) > 4096) {\n\t\tcmd = zend_string_truncate(cmd, y, 0);\n\t}\n\tZSTR_LEN(cmd) = y;\n\treturn cmd;\n}", "target": 1}
{"code": "struct mb2_cache *ext2_xattr_create_cache(void)\n{\n\treturn mb2_cache_create(HASH_BUCKET_BITS);\n}", "target": 0}
{"code": "static apr_status_t parse_chunk_size(http_ctx_t *ctx, const char *buffer,\n        apr_size_t len, int linelimit)\n{\n    apr_size_t i = 0;\n    while (i < len) {\n        char c = buffer[i];\n        ap_xlate_proto_from_ascii(&c, 1);\n        if (ctx->state == BODY_CHUNK_END) {\n            if (c == LF) {\n                ctx->state = BODY_CHUNK;\n            }\n            i++;\n            continue;\n        }\n        if (ctx->state == BODY_CHUNK) {\n            if (!apr_isxdigit(c)) {\n                return APR_EGENERAL;\n            }\n            else {\n                ctx->state = BODY_CHUNK_PART;\n            }\n            ctx->remaining = 0;\n            ctx->chunkbits = sizeof(long) * 8;\n            ctx->chunk_used = 0;\n        }\n        if (c == ';' || c == CR) {\n            ctx->state = BODY_CHUNK_EXT;\n        }\n        else if (c == LF) {\n            if (ctx->remaining) {\n                ctx->state = BODY_CHUNK_DATA;\n            }\n            else {\n                ctx->state = BODY_CHUNK_TRAILER;\n            }\n        }\n        else if (ctx->state != BODY_CHUNK_EXT) {\n            int xvalue = 0;\n            if (!ctx->remaining && c == '0') {\n                i++;\n                continue;\n            }\n            if (c >= '0' && c <= '9') {\n                xvalue = c - '0';\n            }\n            else if (c >= 'A' && c <= 'F') {\n                xvalue = c - 'A' + 0xa;\n            }\n            else if (c >= 'a' && c <= 'f') {\n                xvalue = c - 'a' + 0xa;\n            }\n            else {\n                return APR_EGENERAL;\n            }\n            ctx->remaining = (ctx->remaining << 4) | xvalue;\n            ctx->chunkbits -= 4;\n            if (ctx->chunkbits <= 0 || ctx->remaining < 0) {\n                return APR_ENOSPC;\n            }\n        }\n        i++;\n    }\n    ctx->chunk_used += len;\n    if (ctx->chunk_used < 0 || ctx->chunk_used > linelimit) {\n        return APR_ENOSPC;\n    }\n    return APR_SUCCESS;\n}", "target": 1}
{"code": "TEST(TensorSliceTest, BuildTensorSlice) {\n  TensorSliceProto proto;\n  TensorSlice({{0, -1}, {0, 10}, {14, 1}}).AsProto(&proto);\n  TensorSlice s;\n  {\n    TF_ASSERT_OK(TensorSlice::BuildTensorSlice(proto, &s));\n    EXPECT_EQ(\"-:0,10:14,1\", s.DebugString());\n  }\n  {\n    TensorSliceProto invalid_proto = proto;\n    invalid_proto.mutable_extent(0)->set_start(-1);\n    EXPECT_FALSE(TensorSlice::BuildTensorSlice(invalid_proto, &s).ok());\n  }\n  {\n    TensorSliceProto invalid_proto = proto;\n    invalid_proto.mutable_extent(2)->set_length(-1);\n    EXPECT_FALSE(TensorSlice::BuildTensorSlice(invalid_proto, &s).ok());\n  }\n  {\n    TensorSliceProto invalid_proto = proto;\n    invalid_proto.mutable_extent(2)->clear_length();\n    EXPECT_FALSE(TensorSlice::BuildTensorSlice(invalid_proto, &s).ok());\n  }\n  {\n    TensorSliceProto invalid_proto = proto;\n    invalid_proto.mutable_extent(2)->set_length(\n        std::numeric_limits<int64_t>::max());\n    EXPECT_FALSE(TensorSlice::BuildTensorSlice(invalid_proto, &s).ok());\n  }\n}", "target": 0}
{"code": "inline int ComputeOutSize(TfLitePadding padding, int image_size,\n                          int filter_size, int stride, int dilation_rate = 1) {\n  int effective_filter_size = (filter_size - 1) * dilation_rate + 1;\n  if (stride == 0) return 0;\n  switch (padding) {\n    case kTfLitePaddingSame:\n      return (image_size + stride - 1) / stride;\n    case kTfLitePaddingValid:\n      return (image_size + stride - effective_filter_size) / stride;\n    default:\n      return 0;\n  }\n}", "target": 0}
{"code": "try_resolve_op_from_metadata (FlatpakTransaction *self,\n                              FlatpakTransactionOperation *op,\n                              const char *checksum,\n                              GFile *sideload_path,\n                              FlatpakRemoteState *state,\n                              GError **error)\n{\n  g_autoptr(GBytes) metadata_bytes = NULL;\n  guint64 download_size = 0;\n  guint64 installed_size = 0;\n  const char *metadata = NULL;\n  VarMetadataRef sparse_cache;\n  VarRefInfoRef info;\n  g_autofree char *summary_checksum = NULL;\n  if ((state->summary == NULL && state->index == NULL) ||\n      !flatpak_remote_state_lookup_ref (state, flatpak_decomposed_get_ref (op->ref),\n                                        &summary_checksum, NULL, NULL, NULL, NULL) ||\n      strcmp (summary_checksum, checksum) != 0)\n    return FALSE;\n  if (!flatpak_remote_state_lookup_cache (state, flatpak_decomposed_get_ref (op->ref),\n                                          &download_size, &installed_size, &metadata, NULL))\n      return FALSE;\n  metadata_bytes = g_bytes_new (metadata, strlen (metadata));\n  if (flatpak_remote_state_lookup_ref (state, flatpak_decomposed_get_ref (op->ref),\n                                       NULL, NULL, &info, NULL, NULL))\n    op->summary_metadata = var_metadata_dup_to_gvariant (var_ref_info_get_metadata (info));\n  op->installed_size = installed_size;\n  op->download_size = download_size;\n  op->token_type = state->default_token_type;\n  if (flatpak_remote_state_lookup_sparse_cache (state, flatpak_decomposed_get_ref (op->ref), &sparse_cache, NULL))\n    {\n      op->eol = g_strdup (var_metadata_lookup_string (sparse_cache, FLATPAK_SPARSE_CACHE_KEY_ENDOFLINE, NULL));\n      op->eol_rebase = g_strdup (var_metadata_lookup_string (sparse_cache, FLATPAK_SPARSE_CACHE_KEY_ENDOFLINE_REBASE, NULL));\n      op->token_type = GINT32_FROM_LE (var_metadata_lookup_int32 (sparse_cache, FLATPAK_SPARSE_CACHE_KEY_TOKEN_TYPE, op->token_type));\n    }\n  return resolve_op_end (self, op, checksum, sideload_path, metadata_bytes, error);\n}", "target": 0}
{"code": "void rds_rdma_drop_keys(struct rds_sock *rs)\n{\n\tstruct rds_mr *mr;\n\tstruct rb_node *node;\n\tunsigned long flags;\n\tspin_lock_irqsave(&rs->rs_rdma_lock, flags);\n\twhile ((node = rb_first(&rs->rs_rdma_keys))) {\n\t\tmr = rb_entry(node, struct rds_mr, r_rb_node);\n\t\tif (mr->r_trans == rs->rs_transport)\n\t\t\tmr->r_invalidate = 0;\n\t\trb_erase(&mr->r_rb_node, &rs->rs_rdma_keys);\n\t\tRB_CLEAR_NODE(&mr->r_rb_node);\n\t\tspin_unlock_irqrestore(&rs->rs_rdma_lock, flags);\n\t\trds_destroy_mr(mr);\n\t\trds_mr_put(mr);\n\t\tspin_lock_irqsave(&rs->rs_rdma_lock, flags);\n\t}\n\tspin_unlock_irqrestore(&rs->rs_rdma_lock, flags);\n\tif (rs->rs_transport && rs->rs_transport->flush_mrs)\n\t\trs->rs_transport->flush_mrs();\n}", "target": 0}
{"code": "static void add_binary_option(gpointer key, gpointer value, gpointer user_data)\n{\n\tuint8_t *option = value;\n\tstruct dhcp_packet *packet = user_data;\n\tdhcp_add_binary_option(packet, option);\n}", "target": 0}
{"code": "R_API RSocket *r_socket_accept_timeout(RSocket *s, unsigned int timeout) {\n\tfd_set read_fds;\n\tfd_set except_fds;\n\tFD_ZERO (&read_fds);\n\tFD_SET (s->fd, &read_fds);\n\tFD_ZERO (&except_fds);\n\tFD_SET (s->fd, &except_fds);\n\tstruct timeval t;\n\tt.tv_sec = timeout;\n\tt.tv_usec = 0;\n\tint r = select (s->fd + 1, &read_fds, NULL, &except_fds, &t);\n\tif(r < 0) {\n\t\tperror (\"select\");\n\t} else if (r > 0 && FD_ISSET (s->fd, &read_fds)) {\n\t\treturn r_socket_accept (s);\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "comics_generate_command_lines (ComicsDocument *comics_document, \n\t\t\t       GError         **error)\n{\n\tgchar *quoted_file, *quoted_file_aux;\n\tgchar *quoted_command;\n\tComicBookDecompressType type;\n\ttype = comics_document->command_usage;\n\tcomics_document->regex_arg = command_usage_def[type].regex_arg;\n\tquoted_command = g_shell_quote (comics_document->selected_command);\n\tif (comics_document->regex_arg) {\n\t\tquoted_file = comics_regex_quote (comics_document->archive);\n\t\tquoted_file_aux = g_shell_quote (comics_document->archive);\n\t\tcomics_document->list_command =\n\t\t\t   g_strdup_printf (command_usage_def[type].list,\n\t\t\t                    comics_document->alternative_command,\n\t\t\t                    quoted_file_aux);\n\t\tg_free (quoted_file_aux);\n\t} else {\n\t\tquoted_file = g_shell_quote (comics_document->archive);\n\t\tcomics_document->list_command =\n\t\t\t\tg_strdup_printf (command_usage_def[type].list,\n\t\t\t\t                 quoted_command, quoted_file);\n\t}\n\tcomics_document->extract_command =\n\t\t\t    g_strdup_printf (command_usage_def[type].extract,\n\t\t\t\t             quoted_command);\n\tcomics_document->offset = command_usage_def[type].offset;\n\tif (command_usage_def[type].decompress_tmp) {\n\t\tcomics_document->dir = ev_mkdtemp (\"xreader-comics-XXXXXX\", error);\n                if (comics_document->dir == NULL)\n                        return FALSE;\n\t\tcomics_document->decompress_tmp =\n\t\t\tg_strdup_printf (command_usage_def[type].decompress_tmp, \n\t\t\t\t\t quoted_command, quoted_file,\n\t\t\t\t\t comics_document->dir);\n\t\tg_free (quoted_file);\n\t\tg_free (quoted_command);\n\t\tif (!comics_decompress_temp_dir (comics_document->decompress_tmp,\n\t\t    comics_document->selected_command, error))\n\t\t\treturn FALSE;\n\t\telse\n\t\t\treturn TRUE;\n\t} else {\n\t\tg_free (quoted_file);\n\t\tg_free (quoted_command);\n\t\treturn TRUE;\n\t}\n}", "target": 1}
{"code": "mark_desktop_file_executable_task_done (GObject      *source_object,\n                                        GAsyncResult *res,\n                                        gpointer      user_data)\n{\n    MarkTrustedJob *job = user_data;\n    g_object_unref (job->file);\n    if (job->done_callback)\n    {\n        job->done_callback (!job_aborted ((CommonJob *) job),\n                            job->done_callback_data);\n    }\n    finalize_common ((CommonJob *) job);\n}", "target": 0}
{"code": "int bprm_change_interp(char *interp, struct linux_binprm *bprm)\n{\n\tif (bprm->interp != bprm->filename)\n\t\tkfree(bprm->interp);\n\tbprm->interp = kstrdup(interp, GFP_KERNEL);\n\tif (!bprm->interp)\n\t\treturn -ENOMEM;\n\treturn 0;\n}", "target": 0}
{"code": "static void cmd_parse_lsub(struct ImapData *idata, char *s)\n{\n  char buf[STRING];\n  char errstr[STRING];\n  struct Buffer err, token;\n  struct Url url;\n  struct ImapList list;\n  if (idata->cmddata && idata->cmdtype == IMAP_CT_LIST)\n  {\n    cmd_parse_list(idata, s);\n    return;\n  }\n  if (!ImapCheckSubscribed)\n    return;\n  idata->cmdtype = IMAP_CT_LIST;\n  idata->cmddata = &list;\n  cmd_parse_list(idata, s);\n  idata->cmddata = NULL;\n  if (!list.name || list.noselect)\n    return;\n  mutt_debug(3, \"Subscribing to %s\\n\", list.name);\n  mutt_str_strfcpy(buf, \"mailboxes \\\"\", sizeof(buf));\n  mutt_account_tourl(&idata->conn->account, &url);\n  imap_quote_string(errstr, sizeof(errstr), list.name);\n  url.path = errstr + 1;\n  url.path[strlen(url.path) - 1] = '\\0';\n  if (mutt_str_strcmp(url.user, ImapUser) == 0)\n    url.user = NULL;\n  url_tostring(&url, buf + 11, sizeof(buf) - 11, 0);\n  mutt_str_strcat(buf, sizeof(buf), \"\\\"\");\n  mutt_buffer_init(&token);\n  mutt_buffer_init(&err);\n  err.data = errstr;\n  err.dsize = sizeof(errstr);\n  if (mutt_parse_rc_line(buf, &token, &err))\n    mutt_debug(1, \"Error adding subscribed mailbox: %s\\n\", errstr);\n  FREE(&token.data);\n}", "target": 1}
{"code": "bool L2NormalizeReduceAxis(Value sq_op, DenseElementsAttr axis) {\n  if (axis.getNumElements() == 0) {\n    return false;\n  }\n  if (sq_op.getType().cast<ShapedType>().getRank() - 1 ==\n          *axis.getValues<int>().begin() ||\n      *axis.getValues<int>().begin() == -1) {\n    return true;\n  }\n  if (sq_op.getType().cast<ShapedType>().getRank() != axis.getNumElements()) {\n    return false;\n  }\n  auto shape = sq_op.getType().cast<ShapedType>();\n  SmallVector<int, 4> elems{axis.getValues<int>().begin(),\n                            axis.getValues<int>().end()};\n  for (int i = 0; i < shape.getRank(); ++i) {\n    if (i != elems[i]) return false;\n  }\n  return true;\n}", "target": 0}
{"code": "get_number(int *numptr, int low, const char *names[], int ch, FILE *file,\n    const char *terms) {\n\tchar temp[MAX_TEMPSTR], *pc;\n\tint len, i;\n\tpc = temp;\n\tlen = 0;\n\twhile (isdigit((unsigned char)ch)) {\n\t\tif (++len >= MAX_TEMPSTR)\n\t\t\tgoto bad;\n\t\t*pc++ = ch;\n\t\tch = get_char(file);\n\t}\n\t*pc = '\\0';\n\tif (len != 0) {\n\t\tif (!strchr(terms, ch))\n\t\t\tgoto bad;\n\t\t*numptr = atoi(temp);\n\t\treturn (ch);\n\t}\n\tif (names) {\n\t\twhile (isalpha((unsigned char)ch)) {\n\t\t\tif (++len >= MAX_TEMPSTR)\n\t\t\t\tgoto bad;\n\t\t\t*pc++ = ch;\n\t\t\tch = get_char(file);\n\t\t}\n\t\t*pc = '\\0';\n\t\tif (len != 0 && strchr(terms, ch)) {\n\t\t\tfor (i = 0;  names[i] != NULL;  i++) {\n\t\t\t\tDebug(DPARS|DEXT,\n\t\t\t\t\t(\"get_num, compare(%s,%s)\\n\", names[i],\n\t\t\t\t\ttemp))\n\t\t\t\tif (!strcasecmp(names[i], temp)) {\n\t\t\t\t\t*numptr = i+low;\n\t\t\t\t\treturn (ch);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nbad:\n\tunget_char(ch, file);\n\treturn (EOF);\n}", "target": 1}
{"code": "void HTMLSelectElement::setSize(int size)\n{\n    setIntegralAttribute(sizeAttr, size);\n}", "target": 0}
{"code": "PJ_DEF(void) pj_scan_get_until_chr( pj_scanner *scanner,\n\t\t\t\t     const char *until_spec, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n    pj_size_t speclen;\n    if (s >= scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n    speclen = strlen(until_spec);\n    while (PJ_SCAN_CHECK_EOF(s) && !memchr(until_spec, *s, speclen)) {\n\t++s;\n    }\n    pj_strset3(out, scanner->curptr, s);\n    scanner->curptr = s;\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*s) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);\n    }\n}", "target": 1}
{"code": "static inline unsigned char *skb_inner_mac_header(const struct sk_buff *skb)\n{\n\treturn skb->inner_mac_header;\n}", "target": 0}
{"code": "mptctl_fw_download(unsigned long arg)\n{\n\tstruct mpt_fw_xfer __user *ufwdl = (void __user *) arg;\n\tstruct mpt_fw_xfer\t kfwdl;\n\tif (copy_from_user(&kfwdl, ufwdl, sizeof(struct mpt_fw_xfer))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::_ioctl_fwdl - \"\n\t\t\t\t\"Unable to copy mpt_fw_xfer struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, ufwdl);\n\t\treturn -EFAULT;\n\t}\n\treturn mptctl_do_fw_download(kfwdl.iocnum, kfwdl.bufp, kfwdl.fwlen);\n}", "target": 1}
{"code": "static void coroutine_fn v9fs_attach(void *opaque)\n{\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n    int32_t fid, afid, n_uname;\n    V9fsString uname, aname;\n    V9fsFidState *fidp;\n    size_t offset = 7;\n    V9fsQID qid;\n    ssize_t err;\n    v9fs_string_init(&uname);\n    v9fs_string_init(&aname);\n    err = pdu_unmarshal(pdu, offset, \"ddssd\", &fid,\n                        &afid, &uname, &aname, &n_uname);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_attach(pdu->tag, pdu->id, fid, afid, uname.data, aname.data);\n    fidp = alloc_fid(s, fid);\n    if (fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    fidp->uid = n_uname;\n    err = v9fs_co_name_to_path(pdu, NULL, \"/\", &fidp->path);\n    if (err < 0) {\n        err = -EINVAL;\n        clunk_fid(s, fid);\n        goto out;\n    }\n    err = fid_to_qid(pdu, fidp, &qid);\n    if (err < 0) {\n        err = -EINVAL;\n        clunk_fid(s, fid);\n        goto out;\n    }\n    if (!s->migration_blocker) {\n        error_setg(&s->migration_blocker,\n                   \"Migration is disabled when VirtFS export path '%s' is mounted in the guest using mount_tag '%s'\",\n                   s->ctx.fs_root ? s->ctx.fs_root : \"NULL\", s->tag);\n        err = migrate_add_blocker(s->migration_blocker, NULL);\n        if (err < 0) {\n            error_free(s->migration_blocker);\n            s->migration_blocker = NULL;\n            clunk_fid(s, fid);\n            goto out;\n        }\n        s->root_fid = fid;\n    }\n    err = pdu_marshal(pdu, offset, \"Q\", &qid);\n    if (err < 0) {\n        clunk_fid(s, fid);\n        goto out;\n    }\n    err += offset;\n    memcpy(&s->root_qid, &qid, sizeof(qid));\n    trace_v9fs_attach_return(pdu->tag, pdu->id,\n                             qid.type, qid.version, qid.path);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&uname);\n    v9fs_string_free(&aname);\n}", "target": 0}
{"code": "static int crypto_report_one(struct crypto_alg *alg,\n\t\t\t     struct crypto_user_alg *ualg, struct sk_buff *skb)\n{\n\tmemcpy(&ualg->cru_name, &alg->cra_name, sizeof(ualg->cru_name));\n\tmemcpy(&ualg->cru_driver_name, &alg->cra_driver_name,\n\t       sizeof(ualg->cru_driver_name));\n\tmemcpy(&ualg->cru_module_name, module_name(alg->cra_module),\n\t       CRYPTO_MAX_ALG_NAME);\n\tualg->cru_flags = alg->cra_flags;\n\tualg->cru_refcnt = atomic_read(&alg->cra_refcnt);\n\tif (nla_put_u32(skb, CRYPTOCFGA_PRIORITY_VAL, alg->cra_priority))\n\t\tgoto nla_put_failure;\n\tif (alg->cra_flags & CRYPTO_ALG_LARVAL) {\n\t\tstruct crypto_report_larval rl;\n\t\tsnprintf(rl.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"larval\");\n\t\tif (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,\n\t\t\t    sizeof(struct crypto_report_larval), &rl))\n\t\t\tgoto nla_put_failure;\n\t\tgoto out;\n\t}\n\tif (alg->cra_type && alg->cra_type->report) {\n\t\tif (alg->cra_type->report(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tgoto out;\n\t}\n\tswitch (alg->cra_flags & (CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL)) {\n\tcase CRYPTO_ALG_TYPE_CIPHER:\n\t\tif (crypto_report_cipher(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_COMPRESS:\n\t\tif (crypto_report_comp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\t}\nout:\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "choose_filters(struct archive_read *a)\n{\n\tint number_bidders, i, bid, best_bid;\n\tstruct archive_read_filter_bidder *bidder, *best_bidder;\n\tstruct archive_read_filter *filter;\n\tssize_t avail;\n\tint r;\n\tfor (;;) {\n\t\tnumber_bidders = sizeof(a->bidders) / sizeof(a->bidders[0]);\n\t\tbest_bid = 0;\n\t\tbest_bidder = NULL;\n\t\tbidder = a->bidders;\n\t\tfor (i = 0; i < number_bidders; i++, bidder++) {\n\t\t\tif (bidder->bid != NULL) {\n\t\t\t\tbid = (bidder->bid)(bidder, a->filter);\n\t\t\t\tif (bid > best_bid) {\n\t\t\t\t\tbest_bid = bid;\n\t\t\t\t\tbest_bidder = bidder;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (best_bidder == NULL) {\n\t\t\t__archive_read_filter_ahead(a->filter, 1, &avail);\n\t\t\tif (avail < 0) {\n\t\t\t\t__archive_read_close_filters(a);\n\t\t\t\t__archive_read_free_filters(a);\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\ta->archive.compression_name = a->filter->name;\n\t\t\ta->archive.compression_code = a->filter->code;\n\t\t\treturn (ARCHIVE_OK);\n\t\t}\n\t\tfilter\n\t\t    = (struct archive_read_filter *)calloc(1, sizeof(*filter));\n\t\tif (filter == NULL)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tfilter->bidder = best_bidder;\n\t\tfilter->archive = a;\n\t\tfilter->upstream = a->filter;\n\t\ta->filter = filter;\n\t\tr = (best_bidder->init)(a->filter);\n\t\tif (r != ARCHIVE_OK) {\n\t\t\t__archive_read_close_filters(a);\n\t\t\t__archive_read_free_filters(a);\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t}\n}", "target": 1}
{"code": "static int hci_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t len, int flags)\n{\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint copied, err;\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\tif (flags & (MSG_OOB))\n\t\treturn -EOPNOTSUPP;\n\tif (sk->sk_state == BT_CLOSED)\n\t\treturn 0;\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\treturn err;\n\tmsg->msg_namelen = 0;\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tswitch (hci_pi(sk)->channel) {\n\tcase HCI_CHANNEL_RAW:\n\t\thci_sock_cmsg(sk, msg, skb);\n\t\tbreak;\n\tcase HCI_CHANNEL_USER:\n\tcase HCI_CHANNEL_CONTROL:\n\tcase HCI_CHANNEL_MONITOR:\n\t\tsock_recv_timestamp(msg, sk, skb);\n\t\tbreak;\n\t}\n\tskb_free_datagram(sk, skb);\n\treturn err ? : copied;\n}", "target": 1}
{"code": "snmp_ber_decode_integer(unsigned char *buf, uint32_t *buff_len, uint32_t *num)\n{\n  uint8_t i, len, type;\n  buf = snmp_ber_decode_type(buf, buff_len, &type);\n  if(buf == NULL || type != BER_DATA_TYPE_INTEGER) {\n    return NULL;\n  }\n  buf = snmp_ber_decode_length(buf, buff_len, &len);\n  if(buf == NULL || len > 4) {\n    return NULL;\n  }\n  if(*buff_len < len) {\n    return NULL;\n  }\n  *num = (uint32_t)(*buf++ & 0xFF);\n  (*buff_len)--;\n  for(i = 1; i < len; ++i) {\n    *num <<= 8;\n    *num |= (uint8_t)(*buf++ & 0xFF);\n    (*buff_len)--;\n  }\n  return buf;\n}", "target": 1}
{"code": "struct r_bin_pe_addr_t *PE_(check_unknow)(RBinPEObj *pe) {\n\tstruct r_bin_pe_addr_t *entry;\n\tif (!pe || !pe->b) {\n\t\treturn 0LL;\n\t}\n\tut8 b[512];\n\tZERO_FILL (b);\n\tentry = PE_ (r_bin_pe_get_entrypoint) (pe);\n\tif (r_buf_read_at (pe->b, entry->paddr, b, 512) < 1) {\n\t\tpe_printf (\"Warning: Cannot read entry at 0x%08\"PFMT64x\"\\n\", entry->paddr);\n\t\tfree (entry);\n\t\treturn NULL;\n\t}\n\tif (b[367] == 0xe8) {\n\t\tfollow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 367);\n\t\treturn entry;\n\t}\n\tsize_t i;\n\tfor (i = 0; i < 512 - 16 ; i++) {\n\t\tif (!memcmp (b + i, \"\\xff\\x15\", 2)) {\n\t\t\tif (b[i + 6] == 0x50) {\n\t\t\t\tif (b[i + 7] == 0xe8) {\n\t\t\t\t\tfollow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, i + 7);\n\t\t\t\t\treturn entry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfree (entry);\n\treturn NULL;\n}", "target": 1}
{"code": "ext2_xattr_cache_find(struct inode *inode, struct ext2_xattr_header *header)\n{\n\t__u32 hash = le32_to_cpu(header->h_hash);\n\tstruct mb_cache_entry *ce;\n\tif (!header->h_hash)\n\t\treturn NULL;  \n\tea_idebug(inode, \"looking for cached blocks [%x]\", (int)hash);\nagain:\n\tce = mb_cache_entry_find_first(ext2_xattr_cache, inode->i_sb->s_bdev,\n\t\t\t\t       hash);\n\twhile (ce) {\n\t\tstruct buffer_head *bh;\n\t\tif (IS_ERR(ce)) {\n\t\t\tif (PTR_ERR(ce) == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tbreak;\n\t\t}\n\t\tbh = sb_bread(inode->i_sb, ce->e_block);\n\t\tif (!bh) {\n\t\t\text2_error(inode->i_sb, \"ext2_xattr_cache_find\",\n\t\t\t\t\"inode %ld: block %ld read error\",\n\t\t\t\tinode->i_ino, (unsigned long) ce->e_block);\n\t\t} else {\n\t\t\tlock_buffer(bh);\n\t\t\tif (le32_to_cpu(HDR(bh)->h_refcount) >\n\t\t\t\t   EXT2_XATTR_REFCOUNT_MAX) {\n\t\t\t\tea_idebug(inode, \"block %ld refcount %d>%d\",\n\t\t\t\t\t  (unsigned long) ce->e_block,\n\t\t\t\t\t  le32_to_cpu(HDR(bh)->h_refcount),\n\t\t\t\t\t  EXT2_XATTR_REFCOUNT_MAX);\n\t\t\t} else if (!ext2_xattr_cmp(header, HDR(bh))) {\n\t\t\t\tea_bdebug(bh, \"b_count=%d\",\n\t\t\t\t\t  atomic_read(&(bh->b_count)));\n\t\t\t\tmb_cache_entry_release(ce);\n\t\t\t\treturn bh;\n\t\t\t}\n\t\t\tunlock_buffer(bh);\n\t\t\tbrelse(bh);\n\t\t}\n\t\tce = mb_cache_entry_find_next(ce, inode->i_sb->s_bdev, hash);\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "static int bson_append_string_base( bson *b, const char *name,\n                                    const char *value, int len, bson_type type ) {\n    int sl = len + 1;\n    if ( bson_check_string( b, ( const char * )value, sl - 1 ) == BSON_ERROR )\n        return BSON_ERROR;\n    if ( bson_append_estart( b, type, name, 4 + sl ) == BSON_ERROR ) {\n        return BSON_ERROR;\n    }\n    bson_append32( b , &sl );\n    bson_append( b , value , sl - 1 );\n    bson_append( b , \"\\0\" , 1 );\n    return BSON_OK;\n}", "target": 1}
{"code": "sds *ldbReplParseCommand(int *argcp) {\n    sds *argv = NULL;\n    int argc = 0;\n    if (sdslen(ldb.cbuf) == 0) return NULL;\n    sds copy = sdsdup(ldb.cbuf);\n    char *p = copy;\n    p = strchr(p,'*'); if (!p) goto protoerr;\n    char *plen = p+1; \n    p = strstr(p,\"\\r\\n\"); if (!p) goto protoerr;\n    *p = '\\0'; p += 2;\n    *argcp = atoi(plen);\n    if (*argcp <= 0 || *argcp > 1024) goto protoerr;\n    argv = zmalloc(sizeof(sds)*(*argcp));\n    argc = 0;\n    while(argc < *argcp) {\n        if (*p != '$') goto protoerr;\n        plen = p+1; \n        p = strstr(p,\"\\r\\n\"); if (!p) goto protoerr;\n        *p = '\\0'; p += 2;\n        int slen = atoi(plen); \n        if (slen <= 0 || slen > 1024) goto protoerr;\n        argv[argc++] = sdsnewlen(p,slen);\n        p += slen; \n        if (p[0] != '\\r' || p[1] != '\\n') goto protoerr;\n        p += 2; \n    }\n    sdsfree(copy);\n    return argv;\nprotoerr:\n    sdsfreesplitres(argv,argc);\n    sdsfree(copy);\n    return NULL;\n}", "target": 1}
{"code": "bool hostuid_to_ns(uid_t uid, pid_t pid, uid_t *answer)\n{\n\tFILE *f;\n\tchar line[400];\n\tsprintf(line, \"/proc/%d/uid_map\", pid);\n\tif ((f = fopen(line, \"r\")) == NULL) {\n\t\treturn false;\n\t}\n\t*answer = convert_id_to_ns(f, uid);\n\tfclose(f);\n\tif (*answer == -1)\n\t\treturn false;\n\treturn true;\n}", "target": 0}
{"code": "unique_ptr<IOBuf> IOBuf::create(std::size_t capacity) {\n  if (capacity > kMaxIOBufSize) {\n    throw_exception<std::bad_alloc>();\n  }\n  if (capacity <= kDefaultCombinedBufSize) {\n    return createCombined(capacity);\n  }\n  if (canNallocx()) {\n    auto mallocSize = goodMallocSize(capacity);\n    size_t minSize = ((capacity + 7) & ~7) + sizeof(SharedInfo);\n    if (mallocSize < minSize) {\n      auto* buf = checkedMalloc(mallocSize);\n      return takeOwnership(SIZED_FREE, buf, mallocSize, 0, 0);\n    }\n  }\n  return createSeparate(capacity);\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor* stamp_token_t;\n    OP_REQUIRES_OK(context, context->input(\"stamp_token\", &stamp_token_t));\n    int64_t stamp_token = stamp_token_t->scalar<int64>()();\n    const Tensor* tree_ensemble_serialized_t;\n    OP_REQUIRES_OK(context, context->input(\"tree_ensemble_serialized\",\n                                           &tree_ensemble_serialized_t));\n    std::unique_ptr<BoostedTreesEnsembleResource> result(\n        new BoostedTreesEnsembleResource());\n    if (!result->InitFromSerialized(\n            tree_ensemble_serialized_t->scalar<tstring>()(), stamp_token)) {\n      result->Unref();\n      result.release();  \n      OP_REQUIRES(\n          context, false,\n          errors::InvalidArgument(\"Unable to parse tree ensemble proto.\"));\n    }\n    auto status =\n        CreateResource(context, HandleFromInput(context, 0), result.release());\n    if (status.code() != tensorflow::error::ALREADY_EXISTS) {\n      OP_REQUIRES_OK(context, status);\n    }\n  }", "target": 0}
{"code": "static void lwp_read_int32(FILE *fin, int32_t &d) {\n  fread(&d, sizeof(d), 1, fin);\n}", "target": 0}
{"code": "static void utee_param_to_param(struct tee_ta_param *p, struct utee_params *up)\n{\n\tsize_t n;\n\tuint32_t types = up->types;\n\tp->types = types;\n\tfor (n = 0; n < TEE_NUM_PARAMS; n++) {\n\t\tuintptr_t a = up->vals[n * 2];\n\t\tsize_t b = up->vals[n * 2 + 1];\n\t\tswitch (TEE_PARAM_TYPE_GET(types, n)) {\n\t\tcase TEE_PARAM_TYPE_MEMREF_INPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_OUTPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_INOUT:\n\t\t\tp->u[n].mem.mobj = &mobj_virt;\n\t\t\tp->u[n].mem.offs = a;\n\t\t\tp->u[n].mem.size = b;\n\t\t\tbreak;\n\t\tcase TEE_PARAM_TYPE_VALUE_INPUT:\n\t\tcase TEE_PARAM_TYPE_VALUE_INOUT:\n\t\t\tp->u[n].val.a = a;\n\t\t\tp->u[n].val.b = b;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmemset(&p->u[n], 0, sizeof(p->u[n]));\n\t\t\tbreak;\n\t\t}\n\t}\n}", "target": 1}
{"code": "lldp_mgmt_addr_tlv_print(netdissect_options *ndo,\n                         const u_char *pptr, u_int len)\n{\n    uint8_t mgmt_addr_len, intf_num_subtype, oid_len;\n    const u_char *tptr;\n    u_int tlen;\n    char *mgmt_addr;\n    tlen = len;\n    tptr = pptr;\n    if (tlen < 1) {\n        return 0;\n    }\n    mgmt_addr_len = *tptr++;\n    tlen--;\n    if (tlen < mgmt_addr_len) {\n        return 0;\n    }\n    mgmt_addr = lldp_network_addr_print(ndo, tptr, mgmt_addr_len);\n    if (mgmt_addr == NULL) {\n        return 0;\n    }\n    ND_PRINT((ndo, \"\\n\\t  Management Address length %u, %s\",\n           mgmt_addr_len, mgmt_addr));\n    tptr += mgmt_addr_len;\n    tlen -= mgmt_addr_len;\n    if (tlen < LLDP_INTF_NUM_LEN) {\n        return 0;\n    }\n    intf_num_subtype = *tptr;\n    ND_PRINT((ndo, \"\\n\\t  %s Interface Numbering (%u): %u\",\n           tok2str(lldp_intf_numb_subtype_values, \"Unknown\", intf_num_subtype),\n           intf_num_subtype,\n           EXTRACT_32BITS(tptr + 1)));\n    tptr += LLDP_INTF_NUM_LEN;\n    tlen -= LLDP_INTF_NUM_LEN;\n    if (tlen) {\n        oid_len = *tptr;\n        if (tlen < oid_len) {\n            return 0;\n        }\n        if (oid_len) {\n            ND_PRINT((ndo, \"\\n\\t  OID length %u\", oid_len));\n            safeputs(ndo, tptr + 1, oid_len);\n        }\n    }\n    return 1;\n}", "target": 1}
{"code": "  base::WaitableEvent* event() { return event_.get(); }", "target": 0}
{"code": "virSecuritySELinuxRestoreMemoryLabel(virSecurityManager *mgr,\n                                     virDomainDef *def,\n                                     virDomainMemoryDef *mem)\n{\n    int ret = -1;\n    virSecurityLabelDef *seclabel;\n    switch (mem->model) {\n    case VIR_DOMAIN_MEMORY_MODEL_NVDIMM:\n    case VIR_DOMAIN_MEMORY_MODEL_VIRTIO_PMEM:\n        seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n        if (!seclabel || !seclabel->relabel)\n            return 0;\n        ret = virSecuritySELinuxRestoreFileLabel(mgr, mem->nvdimmPath, true);\n        break;\n    case VIR_DOMAIN_MEMORY_MODEL_DIMM:\n    case VIR_DOMAIN_MEMORY_MODEL_NONE:\n    case VIR_DOMAIN_MEMORY_MODEL_LAST:\n        ret = 0;\n        break;\n    }\n    return ret;\n}", "target": 0}
{"code": "static SQLRETURN qt_string_SQLSetConnectAttr(SQLHDBC handle, SQLINTEGER attr, const QString &val)\n{\n    auto encoded = toSQLTCHAR(val);\n    return SQLSetConnectAttr(handle, attr,\n                             encoded.data(),\n                             SQLINTEGER(encoded.size() * sizeof(SQLTCHAR))); \n}", "target": 0}
{"code": "static int __adpt_reset(struct scsi_cmnd* cmd)\n{\n\tadpt_hba* pHba;\n\tint rcode;\n\tchar name[32];\n\tpHba = (adpt_hba*)cmd->device->host->hostdata[0];\n\tstrncpy(name, pHba->name, sizeof(name));\n\tprintk(KERN_WARNING\"%s: Hba Reset: scsi id %d: tid: %d\\n\", name, cmd->device->channel, pHba->channel[cmd->device->channel].tid);\n\trcode =  adpt_hba_reset(pHba);\n\tif(rcode == 0){\n\t\tprintk(KERN_WARNING\"%s: HBA reset complete\\n\", name);\n\t\treturn SUCCESS;\n\t} else {\n\t\tprintk(KERN_WARNING\"%s: HBA reset failed (%x)\\n\", name, rcode);\n\t\treturn FAILED;\n\t}\n}", "target": 1}
{"code": "int main()\n{\n    gdImagePtr im;\n    FILE *fp;\n    fp = gdTestFileOpen2(\"gd2\", \"too_few_image_data.gd2\");\n    gdTestAssert(fp != NULL);\n    im = gdImageCreateFromGd2(fp);\n    gdTestAssert(im == NULL);\n    fclose(fp);\n    return gdNumFailures();\n}", "target": 0}
{"code": "GF_Err moof_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs, moof_on_child_box);\n}", "target": 0}
{"code": "SQLiteDBInstanceRef SQLiteDBManager::getConnection(bool primary) {\n  auto& self = instance();\n  WriteLock lock(self.create_mutex_);\n  if (self.db_ == nullptr) {\n    openOptimized(self.db_);\n    self.connection_ = SQLiteDBInstanceRef(new SQLiteDBInstance(self.db_));\n    attachVirtualTables(self.connection_);\n  }\n  if (primary) {\n    return self.connection_;\n  }\n  auto instance = std::make_shared<SQLiteDBInstance>(self.db_, self.mutex_);\n  if (!instance->isPrimary()) {\n    attachVirtualTables(instance);\n  }\n  return instance;\n}", "target": 0}
{"code": "void bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)\n\t{\n#ifdef BN_LLONG\n\tBN_ULLONG t,tt;\n#else\n\tBN_ULONG bl,bh;\n#endif\n\tBN_ULONG t1,t2;\n\tBN_ULONG c1,c2,c3;\n\tc1=0;\n\tc2=0;\n\tc3=0;\n\tsqr_add_c(a,0,c1,c2,c3);\n\tr[0]=c1;\n\tc1=0;\n\tsqr_add_c2(a,1,0,c2,c3,c1);\n\tr[1]=c2;\n\tc2=0;\n\tsqr_add_c(a,1,c3,c1,c2);\n\tsqr_add_c2(a,2,0,c3,c1,c2);\n\tr[2]=c3;\n\tc3=0;\n\tsqr_add_c2(a,3,0,c1,c2,c3);\n\tsqr_add_c2(a,2,1,c1,c2,c3);\n\tr[3]=c1;\n\tc1=0;\n\tsqr_add_c(a,2,c2,c3,c1);\n\tsqr_add_c2(a,3,1,c2,c3,c1);\n\tr[4]=c2;\n\tc2=0;\n\tsqr_add_c2(a,3,2,c3,c1,c2);\n\tr[5]=c3;\n\tc3=0;\n\tsqr_add_c(a,3,c1,c2,c3);\n\tr[6]=c1;\n\tr[7]=c2;\n\t}", "target": 1}
{"code": "void update_process_times(int user_tick)\n{\n\tstruct task_struct *p = current;\n\taccount_process_tick(p, user_tick);\n\trun_local_timers();\n\trcu_sched_clock_irq(user_tick);\n#ifdef CONFIG_IRQ_WORK\n\tif (in_irq())\n\t\tirq_work_tick();\n#endif\n\tscheduler_tick();\n\tif (IS_ENABLED(CONFIG_POSIX_TIMERS))\n\t\trun_posix_cpu_timers();\n\tthis_cpu_add(net_rand_state.s1, rol32(jiffies, 24) + user_tick);\n}", "target": 0}
{"code": "static int __init init_ext2_fs(void)\n{\n\tint err = init_ext2_xattr();\n\tif (err)\n\t\treturn err;\n\terr = init_inodecache();\n\tif (err)\n\t\tgoto out1;\n        err = register_filesystem(&ext2_fs_type);\n\tif (err)\n\t\tgoto out;\n\treturn 0;\nout:\n\tdestroy_inodecache();\nout1:\n\texit_ext2_xattr();\n\treturn err;\n}", "target": 1}
{"code": "static inline void flush(Encoder *encoder)\n{\n    if (encoder->io_available_bits > 0 && encoder->io_available_bits != 32) {\n        encode(encoder, 0, encoder->io_available_bits);\n    }\n    encode_32(encoder, 0);\n    encode(encoder, 0, 1);\n}", "target": 0}
{"code": "BOOL update_write_cache_brush_order(wStream* s, const CACHE_BRUSH_ORDER* cache_brush, UINT16* flags)\n{\n\tint i;\n\tBYTE iBitmapFormat;\n\tBOOL compressed = FALSE;\n\tif (!Stream_EnsureRemainingCapacity(s,\n\t                                    update_approximate_cache_brush_order(cache_brush, flags)))\n\t\treturn FALSE;\n\tiBitmapFormat = BPP_BMF[cache_brush->bpp];\n\tStream_Write_UINT8(s, cache_brush->index);  \n\tStream_Write_UINT8(s, iBitmapFormat);       \n\tStream_Write_UINT8(s, cache_brush->cx);     \n\tStream_Write_UINT8(s, cache_brush->cy);     \n\tStream_Write_UINT8(s, cache_brush->style);  \n\tStream_Write_UINT8(s, cache_brush->length); \n\tif ((cache_brush->cx == 8) && (cache_brush->cy == 8))\n\t{\n\t\tif (cache_brush->bpp == 1)\n\t\t{\n\t\t\tif (cache_brush->length != 8)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"incompatible 1bpp brush of length:%\" PRIu32 \"\", cache_brush->length);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\tfor (i = 7; i >= 0; i--)\n\t\t\t{\n\t\t\t\tStream_Write_UINT8(s, cache_brush->data[i]);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((iBitmapFormat == BMF_8BPP) && (cache_brush->length == 20))\n\t\t\t\tcompressed = TRUE;\n\t\t\telse if ((iBitmapFormat == BMF_16BPP) && (cache_brush->length == 24))\n\t\t\t\tcompressed = TRUE;\n\t\t\telse if ((iBitmapFormat == BMF_32BPP) && (cache_brush->length == 32))\n\t\t\t\tcompressed = TRUE;\n\t\t\tif (compressed != FALSE)\n\t\t\t{\n\t\t\t\tif (!update_compress_brush(s, cache_brush->data, cache_brush->bpp))\n\t\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint scanline = (cache_brush->bpp / 8) * 8;\n\t\t\t\tfor (i = 7; i >= 0; i--)\n\t\t\t\t{\n\t\t\t\t\tStream_Write(s, &cache_brush->data[i * scanline], scanline);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "R_API int r_io_bank_read_from_submap_at(RIO *io, const ut32 bankid, ut64 addr, ut8 *buf, int len) {\n\tr_return_val_if_fail (io, -1);\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tif (!bank) {\n\t\treturn 0;\n\t}\n\tif (!len) {\n\t\treturn 0;\n\t}\n\tRRBNode *node;\n\tif (bank->last_used && r_io_submap_contain (((RIOSubMap *)bank->last_used->data), addr)) {\n\t\tnode = bank->last_used;\n\t} else {\n\t\tnode = r_crbtree_find_node (bank->submaps, &addr, _find_sm_by_vaddr_cb, NULL);\n\t\tif (!node) {\n\t\t\treturn 0;\n\t\t}\n\t\tbank->last_used = node;\n\t}\n\tRIOSubMap *sm = (RIOSubMap *)node->data;\n\tif (!r_io_submap_contain (sm, addr)) {\n\t\treturn 0;\n\t}\n\tRIOMap *map = r_io_map_get_by_ref (io, &sm->mapref);\n\tif (!map || !(map->perm & R_PERM_R)) {\n\t\treturn -1;\n\t}\n\tconst int read_len = R_MIN (len, r_io_submap_to (sm) - addr + 1);\n\tif (map->perm & R_PERM_RELOC) {\n\t\treturn map->reloc_map->read (io, map, addr, buf, read_len);\n\t}\n\tconst ut64 paddr = addr - r_io_map_from (map) + map->delta;\n\treturn r_io_fd_read_at (io, map->fd, paddr, buf, read_len);\n}", "target": 1}
{"code": "    bool replaceHostInUri( std::string& uri, const char* szHost, const char* szPort ) {\n        su_home_t* home = theOneAndOnlyController->getHome() ;\n        char *s ;\n        char buf[255];\n        char obuf[255] ;\n        char hp[64] ;\n        char const *display = NULL;\n        url_t url[1];\n        msg_param_t const *params = NULL;\n        char const *comment = NULL;\n        int rc ;\n        s = strncpy( buf, uri.c_str(), 255 ) ;\n        rc = sip_name_addr_d(home, &s, &display, url, &params, &comment) ;\n        if( rc < 0 ) {  \n            return false ;\n        }\n        url->url_host = szHost ;\n        url->url_port = szPort ;\n        int nChars = sip_name_addr_e(obuf, 255, 0, display, 1, url, params, comment) ;\n        if( params ) {\n            su_free(home, (void *) params) ;\n        }\n        if( nChars <= 0 ) {\n            return false ;\n        }\n        uri.assign( obuf ) ;\n        return true ;\n    }", "target": 1}
{"code": "inline static jas_int_asl(int x, int n)\n{\n\tassert(n >= 0);\n\treturn x << n;\n}", "target": 0}
{"code": "static MagickBooleanType SkipDXTMipmaps(Image *image,DDSInfo *dds_info,\n  int texel_size,ExceptionInfo *exception)\n{\n  MagickOffsetType\n    offset;\n  register ssize_t\n    i;\n  size_t\n    h,\n    w;\n  if (EOFBlob(image) != MagickFalse)\n    {\n      ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n        image->filename);\n      return(MagickFalse);\n    }\n  if (dds_info->ddscaps1 & DDSCAPS_MIPMAP\n      && (dds_info->ddscaps1 & DDSCAPS_TEXTURE\n          || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))\n    {\n      w = DIV2(dds_info->width);\n      h = DIV2(dds_info->height);\n      for (i = 1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)\n      {\n        offset = (MagickOffsetType) ((w + 3) / 4) * ((h + 3) / 4) * texel_size;\n        (void) SeekBlob(image, offset, SEEK_CUR);\n        w = DIV2(w);\n        h = DIV2(h);\n      }\n    }\n  return(MagickTrue);\n}", "target": 1}
{"code": "int Jsi_ObjArraySizer(Jsi_Interp *interp, Jsi_Obj *obj, uint len)\n{\n    int nsiz = len + 1, mod = ALLOC_MOD_SIZE;\n    assert(obj->isarrlist);\n    if (mod>1)\n        nsiz = nsiz + ((mod-1) - (nsiz + mod - 1)%mod);\n    if (nsiz > MAX_ARRAY_LIST) {\n        Jsi_LogError(\"array size too large\");\n        return 0;\n    }\n    if (len >= obj->arrMaxSize) {\n        int oldsz = (nsiz-obj->arrMaxSize);\n        obj->arr = (Jsi_Value**)Jsi_Realloc(obj->arr, nsiz*sizeof(Jsi_Value*));\n        memset(obj->arr+obj->arrMaxSize, 0, oldsz*sizeof(Jsi_Value*));\n        obj->arrMaxSize = nsiz;\n    }\n    if (len>obj->arrCnt)\n        obj->arrCnt = len;\n    return nsiz;\n}", "target": 1}
{"code": "static int make_ydt24_entry(int p1, int p2, int16_t *ydt)\n{\n    int lo, hi;\n    lo = ydt[p1];\n    hi = ydt[p2];\n    return (lo + (hi << 8) + (hi << 16)) << 1;\n}", "target": 0}
{"code": "TfLiteStatus EvalScatterNd(TfLiteContext* context, const TfLiteTensor* indices,\n                           const TfLiteTensor* updates,\n                           const TfLiteTensor* shape, TfLiteTensor* output) {\n  if (IsDynamicTensor(output)) {\n    TF_LITE_ENSURE_OK(\n        context, CheckShapes<IndicesT>(\n                     context, GetTensorShape(indices), GetTensorShape(updates),\n                     GetTensorShape(shape), GetTensorData<IndicesT>(shape)));\n    TF_LITE_ENSURE_OK(context,\n                      ResizeOutputTensor<IndicesT>(context, shape, output));\n  }\n  switch (updates->type) {\n    case kTfLiteFloat32:\n      return ScatterNd<IndicesT, float>(indices, updates, output);\n    case kTfLiteUInt8:\n      return ScatterNd<IndicesT, uint8_t>(indices, updates, output);\n    case kTfLiteBool:\n      return ScatterNd<IndicesT, bool>(indices, updates, output);\n    case kTfLiteInt8:\n      return ScatterNd<IndicesT, int8_t>(indices, updates, output);\n    case kTfLiteInt32:\n      return ScatterNd<IndicesT, int32_t>(indices, updates, output);\n    case kTfLiteInt64:\n      return ScatterNd<IndicesT, int64_t>(indices, updates, output);\n    default:\n      TF_LITE_KERNEL_LOG(\n          context, \"Updates of type '%s' are not supported by scatter_nd.\",\n          TfLiteTypeGetName(updates->type));\n      return kTfLiteError;\n  }\n}", "target": 1}
{"code": "char *ReadInput(char *filename)\n{\n    FILE *finput;\n    long filesize, num;\n    char *buffer;\n    if ( ( finput = fopen(filename,\"r\") ) == 0 ) {\n        fprintf(stderr,\"%s: Cannot open file %s\\n\",axohelp,filename);\n        exit(-1);\n    }\n    if ( ( fseek(finput,0,SEEK_END) != 0 )\n      || ( ( filesize = ftell(finput) ) < 0 )\n      || ( fseek(finput,0,SEEK_SET) != 0 ) ) {\n        fprintf(stderr,\"%s: File error in file %s\\n\",axohelp,filename);\n        exit(-1);\n    }\n    if ( ( buffer = malloc((filesize+1)*sizeof(char)) ) == 0 ) {\n        fprintf(stderr,\"%s: Error allocating %ld bytes of memory\",axohelp,filesize+1);\n        exit(-1);\n    }\n    num = fread( buffer, 1, filesize, finput );\n    if ( ferror(finput) ) {\n        fprintf(stderr,\"%s: Error reading file %s\\n\",axohelp,filename);\n        exit(-1);\n    }\n    buffer[num] = 0;\n    fclose(finput);\n    return(buffer);\n}", "target": 1}
{"code": "static int tls_construct_cke_ecdhe(SSL *s, unsigned char **p, int *len, int *al)\n{\n#ifndef OPENSSL_NO_EC\n    unsigned char *encodedPoint = NULL;\n    int encoded_pt_len = 0;\n    EVP_PKEY *ckey = NULL, *skey = NULL;\n    skey = s->s3->peer_tmp;\n    if (skey == NULL) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n    ckey = ssl_generate_pkey(skey);\n    if (ckey == NULL) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n    if (ssl_derive(s, ckey, skey) == 0) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EVP_LIB);\n        goto err;\n    }\n    encoded_pt_len = EVP_PKEY_get1_tls_encodedpoint(ckey, &encodedPoint);\n    if (encoded_pt_len == 0) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EC_LIB);\n        goto err;\n    }\n    EVP_PKEY_free(ckey);\n    ckey = NULL;\n    *len = encoded_pt_len;\n    **p = *len;\n    *p += 1;\n    memcpy(*p, encodedPoint, *len);\n    *len += 1;\n    OPENSSL_free(encodedPoint);\n    return 1;\n err:\n    EVP_PKEY_free(ckey);\n    return 0;\n#else\n    SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);\n    *al = SSL_AD_INTERNAL_ERROR;\n    return 0;\n#endif\n}", "target": 0}
{"code": "cib_remote_command_dispatch(gpointer user_data)\n{\n    int disconnected = 0;\n    cib_t *cib = user_data;\n    cib_remote_opaque_t *private = cib->variant_opaque;\n    crm_recv_remote_msg(private->command.session, &private->command.recv_buf, private->command.encrypted, -1, &disconnected);\n    free(private->command.recv_buf);\n    private->command.recv_buf = NULL;\n    crm_err(\"received late reply for remote cib connection, discarding\");\n    if (disconnected) {\n        return -1;\n    }\n    return 0;\n}", "target": 0}
{"code": "TEST(TensorSliceReaderTest, MissingTensorData) {\n  const string fname =\n      io::JoinPath(testing::TmpDir(), \"missing_data_checkpoint\");\n  TensorSliceWriter writer(fname, CreateTableTensorSliceBuilder);\n  const int32 data[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n  TF_ASSERT_OK(writer.Add(\"test\", TensorShape({4, 5}),\n                          TensorSlice::ParseOrDie(\"0,2:-\"), data));\n  TF_ASSERT_OK(writer.Finish());\n  MutateSavedTensorSlices(fname, [&](SavedTensorSlices sts) {\n    if (sts.has_data()) {\n      Fill(data, 4, sts.mutable_data()->mutable_data());\n    }\n    return sts.SerializeAsString();\n  });\n  TensorSliceReader reader(fname, OpenTableTensorSliceReader);\n  TF_ASSERT_OK(reader.status());\n  EXPECT_TRUE(reader.HasTensor(\"test\", nullptr, nullptr));\n  std::unique_ptr<Tensor> tensor;\n  EXPECT_FALSE(reader.GetTensor(\"test\", &tensor).ok());\n}", "target": 0}
{"code": "bool CephxAuthorizeHandler::verify_authorizer(CephContext *cct, KeyStore *keys,\n\t\t\t\t\t      bufferlist& authorizer_data, bufferlist& authorizer_reply,\n                                              EntityName& entity_name, uint64_t& global_id, AuthCapsInfo& caps_info, CryptoKey& session_key,  uint64_t *auid)\n{\n  bufferlist::iterator iter = authorizer_data.begin();\n  if (!authorizer_data.length()) {\n    ldout(cct, 1) << \"verify authorizer, authorizer_data.length()=0\" << dendl;\n    return false;\n  }\n  CephXServiceTicketInfo auth_ticket_info;\n  bool isvalid = cephx_verify_authorizer(cct, keys, iter, auth_ticket_info, authorizer_reply);\n  if (isvalid) {\n    caps_info = auth_ticket_info.ticket.caps;\n    entity_name = auth_ticket_info.ticket.name;\n    global_id = auth_ticket_info.ticket.global_id;\n    session_key = auth_ticket_info.session_key;\n    if (auid) *auid = auth_ticket_info.ticket.auid;\n  }\n  return isvalid;\n}", "target": 1}
{"code": "NOEXPORT int ssl_tlsext_ticket_key_cb(SSL *ssl, unsigned char *key_name,\n        unsigned char *iv, EVP_CIPHER_CTX *ctx, HMAC_CTX *hctx, int enc) {\n    CLI *c;\n    const EVP_CIPHER *cipher;\n    int iv_len;\n    (void)key_name; \n    s_log(LOG_DEBUG, \"Session ticket processing callback\");\n    c=SSL_get_ex_data(ssl, index_ssl_cli);\n    if(!HMAC_Init_ex(hctx, (const unsigned char *)(c->opt->ticket_mac->key_val),\n        c->opt->ticket_mac->key_len, EVP_sha256(), NULL)) {\n        s_log(LOG_ERR, \"HMAC_Init_ex failed\");\n        return -1;\n    }\n    if(c->opt->ticket_key->key_len == 16)\n        cipher = EVP_aes_128_cbc();\n    else \n        cipher = EVP_aes_256_cbc();\n    if(enc) { \n        iv_len = EVP_CIPHER_iv_length(cipher);\n        if(RAND_bytes(iv, iv_len) <= 0) { \n            s_log(LOG_ERR, \"RAND_bytes failed\");\n            return -1;\n        }\n        if(!EVP_EncryptInit_ex(ctx, cipher, NULL,\n            (const unsigned char *)(c->opt->ticket_key->key_val), iv)) {\n            s_log(LOG_ERR, \"EVP_EncryptInit_ex failed\");\n            return -1;\n        }\n    } else \n        if(!EVP_DecryptInit_ex(ctx, cipher, NULL,\n            (const unsigned char *)(c->opt->ticket_key->key_val), iv)) {\n            s_log(LOG_ERR, \"EVP_DecryptInit_ex failed\");\n            return -1;\n        }\n    if(strcmp(SSL_get_version(c->ssl), \"TLSv1.3\"))\n        return 1; \n    else\n        return 2; \n}", "target": 1}
{"code": "static void freeary(struct ipc_namespace *ns, struct kern_ipc_perm *ipcp)\n{\n\tstruct sem_undo *un, *tu;\n\tstruct sem_queue *q, *tq;\n\tstruct sem_array *sma = container_of(ipcp, struct sem_array, sem_perm);\n\tstruct list_head tasks;\n\tint i;\n\tassert_spin_locked(&sma->sem_perm.lock);\n\tlist_for_each_entry_safe(un, tu, &sma->list_id, list_id) {\n\t\tlist_del(&un->list_id);\n\t\tspin_lock(&un->ulp->lock);\n\t\tun->semid = -1;\n\t\tlist_del_rcu(&un->list_proc);\n\t\tspin_unlock(&un->ulp->lock);\n\t\tkfree_rcu(un, rcu);\n\t}\n\tINIT_LIST_HEAD(&tasks);\n\tlist_for_each_entry_safe(q, tq, &sma->sem_pending, list) {\n\t\tunlink_queue(sma, q);\n\t\twake_up_sem_queue_prepare(&tasks, q, -EIDRM);\n\t}\n\tfor (i = 0; i < sma->sem_nsems; i++) {\n\t\tstruct sem *sem = sma->sem_base + i;\n\t\tlist_for_each_entry_safe(q, tq, &sem->sem_pending, list) {\n\t\t\tunlink_queue(sma, q);\n\t\t\twake_up_sem_queue_prepare(&tasks, q, -EIDRM);\n\t\t}\n\t}\n\tsem_rmid(ns, sma);\n\tsem_unlock(sma);\n\twake_up_sem_queue_do(&tasks);\n\tns->used_sems -= sma->sem_nsems;\n\tsecurity_sem_free(sma);\n\tipc_rcu_putref(sma);\n}", "target": 1}
{"code": "static inline bool is_noncanonical_address(u64 la)\n{\n#ifdef CONFIG_X86_64\n\treturn get_canonical(la) != la;\n#else\n\treturn false;\n#endif\n}", "target": 0}
{"code": "void __skb_tstamp_tx(struct sk_buff *orig_skb,\n\t\t     struct skb_shared_hwtstamps *hwtstamps,\n\t\t     struct sock *sk, int tstype)\n{\n\tstruct sk_buff *skb;\n\tbool tsonly;\n\tif (!sk)\n\t\treturn;\n\ttsonly = sk->sk_tsflags & SOF_TIMESTAMPING_OPT_TSONLY;\n\tif (!skb_may_tx_timestamp(sk, tsonly))\n\t\treturn;\n\tif (tsonly) {\n#ifdef CONFIG_INET\n\t\tif ((sk->sk_tsflags & SOF_TIMESTAMPING_OPT_STATS) &&\n\t\t    sk->sk_protocol == IPPROTO_TCP &&\n\t\t    sk->sk_type == SOCK_STREAM)\n\t\t\tskb = tcp_get_timestamping_opt_stats(sk);\n\t\telse\n#endif\n\t\t\tskb = alloc_skb(0, GFP_ATOMIC);\n\t} else {\n\t\tskb = skb_clone(orig_skb, GFP_ATOMIC);\n\t}\n\tif (!skb)\n\t\treturn;\n\tif (tsonly) {\n\t\tskb_shinfo(skb)->tx_flags = skb_shinfo(orig_skb)->tx_flags;\n\t\tskb_shinfo(skb)->tskey = skb_shinfo(orig_skb)->tskey;\n\t}\n\tif (hwtstamps)\n\t\t*skb_hwtstamps(skb) = *hwtstamps;\n\telse\n\t\tskb->tstamp = ktime_get_real();\n\t__skb_complete_tx_timestamp(skb, sk, tstype);", "target": 1}
{"code": "static int oidc_cache_crypto_encrypt_impl(request_rec *r,\n\t\tunsigned char *plaintext, int plaintext_len, const unsigned char *aad,\n\t\tint aad_len, unsigned char *key, const unsigned char *iv, int iv_len,\n\t\tunsigned char *ciphertext, const unsigned char *tag, int tag_len) {\n\tEVP_CIPHER_CTX *ctx;\n\tint len;\n\tint ciphertext_len;\n\tif (!(ctx = EVP_CIPHER_CTX_new())) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_CIPHER_CTX_new\");\n\t\treturn -1;\n\t}\n\tif (!EVP_EncryptInit_ex(ctx, OIDC_CACHE_CIPHER, NULL, NULL, NULL)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_EncryptInit_ex\");\n\t\treturn -1;\n\t}\n\tif (!EVP_CIPHER_CTX_ctrl(ctx, OIDC_CACHE_CRYPTO_SET_IVLEN, iv_len, NULL)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_CIPHER_CTX_ctrl\");\n\t\treturn -1;\n\t}\n\tif (!EVP_EncryptInit_ex(ctx, NULL, NULL, key, iv)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_EncryptInit_ex\");\n\t\treturn -1;\n\t}\n\tif (!EVP_EncryptUpdate(ctx, NULL, &len, aad, aad_len)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_DecryptUpdate aad: aad_len=%d\",\n\t\t\t\taad_len);\n\t\treturn -1;\n\t}\n\tif (!EVP_EncryptUpdate(ctx, ciphertext, &len, plaintext, plaintext_len)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_EncryptUpdate ciphertext\");\n\t\treturn -1;\n\t}\n\tciphertext_len = len;\n\tif (!EVP_EncryptFinal_ex(ctx, ciphertext + len, &len)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_EncryptFinal_ex\");\n\t\treturn -1;\n\t}\n\tciphertext_len += len;\n\tif (!EVP_CIPHER_CTX_ctrl(ctx, OIDC_CACHE_CRYPTO_GET_TAG, tag_len,\n\t\t\t(void *) tag)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_CIPHER_CTX_ctrl\");\n\t\treturn -1;\n\t}\n\tEVP_CIPHER_CTX_free(ctx);\n\treturn ciphertext_len;\n}", "target": 1}
{"code": "  bool AllocatesOpaqueHandle() const override { return true; }", "target": 0}
{"code": "pci_emul_add_capability(struct pci_vdev *dev, u_char *capdata, int caplen)\n{\n\tint i, capoff, reallen;\n\tuint16_t sts;\n\tassert(caplen > 0);\n\treallen = roundup2(caplen, 4);\t\t\n\tsts = pci_get_cfgdata16(dev, PCIR_STATUS);\n\tif ((sts & PCIM_STATUS_CAPPRESENT) == 0)\n\t\tcapoff = CAP_START_OFFSET;\n\telse\n\t\tcapoff = dev->capend + 1;\n\tif (capoff + reallen > PCI_REGMAX + 1)\n\t\treturn -1;\n\tif ((sts & PCIM_STATUS_CAPPRESENT) == 0) {\n\t\tpci_set_cfgdata8(dev, PCIR_CAP_PTR, capoff);\n\t\tpci_set_cfgdata16(dev, PCIR_STATUS, sts|PCIM_STATUS_CAPPRESENT);\n\t} else\n\t\tpci_set_cfgdata8(dev, dev->prevcap + 1, capoff);\n\tfor (i = 0; i < caplen; i++)\n\t\tpci_set_cfgdata8(dev, capoff + i, capdata[i]);\n\tpci_set_cfgdata8(dev, capoff + 1, 0);\n\tdev->prevcap = capoff;\n\tdev->capend = capoff + reallen - 1;\n\treturn 0;\n}", "target": 1}
{"code": "const aura::Window* Shell::GetContainer(const aura::Window* root_window,\n                                        int container_id) {\n  return root_window->GetChildById(container_id);\n}", "target": 0}
{"code": "void fiin_box_del(GF_Box *s)\n{\n\tFDItemInformationBox *ptr = (FDItemInformationBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->partition_entries) gf_list_del(ptr->partition_entries);\n\tgf_free(ptr);\n}", "target": 0}
{"code": "void exit_io_context(struct task_struct *task)\n{\n\tstruct io_context *ioc;\n\ttask_lock(task);\n\tioc = task->io_context;\n\ttask->io_context = NULL;\n\ttask_unlock(task);\n\tif (atomic_dec_and_test(&ioc->nr_tasks)) {\n\t\tif (ioc->aic && ioc->aic->exit)\n\t\t\tioc->aic->exit(ioc->aic);\n\t\tcfq_exit(ioc);\n\t}\n\tput_io_context(ioc);\n}", "target": 0}
{"code": "  void ClearSchemes() {\n    schemes_.clear();\n  }", "target": 0}
{"code": "bool isKeyInvalid(const String &key) {\n  return key.find('\\0') != -1;\n}", "target": 0}
{"code": "static int newque(struct ipc_namespace *ns, struct ipc_params *params)\n{\n\tstruct msg_queue *msq;\n\tint id, retval;\n\tkey_t key = params->key;\n\tint msgflg = params->flg;\n\tmsq = ipc_rcu_alloc(sizeof(*msq));\n\tif (!msq)\n\t\treturn -ENOMEM;\n\tmsq->q_perm.mode = msgflg & S_IRWXUGO;\n\tmsq->q_perm.key = key;\n\tmsq->q_perm.security = NULL;\n\tretval = security_msg_queue_alloc(msq);\n\tif (retval) {\n\t\tipc_rcu_putref(msq, ipc_rcu_free);\n\t\treturn retval;\n\t}\n\tid = ipc_addid(&msg_ids(ns), &msq->q_perm, ns->msg_ctlmni);\n\tif (id < 0) {\n\t\tipc_rcu_putref(msq, msg_rcu_free);\n\t\treturn id;\n\t}\n\tmsq->q_stime = msq->q_rtime = 0;\n\tmsq->q_ctime = get_seconds();\n\tmsq->q_cbytes = msq->q_qnum = 0;\n\tmsq->q_qbytes = ns->msg_ctlmnb;\n\tmsq->q_lspid = msq->q_lrpid = 0;\n\tINIT_LIST_HEAD(&msq->q_messages);\n\tINIT_LIST_HEAD(&msq->q_receivers);\n\tINIT_LIST_HEAD(&msq->q_senders);\n\tipc_unlock_object(&msq->q_perm);\n\trcu_read_unlock();\n\treturn msq->q_perm.id;\n}", "target": 1}
{"code": "CSecurityTLS::~CSecurityTLS()\n{\n  shutdown(true);\n  if (fis)\n    delete fis;\n  if (fos)\n    delete fos;\n  delete[] cafile;\n  delete[] crlfile;\n  gnutls_global_deinit();\n}", "target": 0}
{"code": "static Jsi_RC jsi_ArrayPushCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Obj *obj;\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {\n        Jsi_ValueMakeNumber(interp, ret, 0);\n        return JSI_OK;\n    }\n    obj = _this->d.obj;\n    int argc = Jsi_ValueGetLength(interp, args);\n    int curlen = Jsi_ObjGetLength(interp, obj);\n    if (curlen < 0) {\n        Jsi_ObjSetLength(interp, obj, 0);\n    }\n    int i;\n    for (i = 0; i < argc; ++i) {\n        Jsi_Value *ov = Jsi_ValueArrayIndex(interp, args, i);\n        if (!ov) { Jsi_LogBug(\"Arguments Error\"); ov = Jsi_ValueNew(interp); }\n        Jsi_ValueInsertArray(interp, _this, curlen + i, ov, 0);\n    }\n    Jsi_ValueMakeNumber(interp, ret, Jsi_ObjGetLength(interp, obj));\n    return JSI_OK;\n}", "target": 1}
{"code": "raw_copy_to_user(void __user *dst, const void *src, unsigned long size)\n{\n\tint ret = 0;\n\tif (!__builtin_constant_p(size))\n\t\treturn copy_user_generic((__force void *)dst, src, size);\n\tswitch (size) {\n\tcase 1:\n\t\t__uaccess_begin();\n\t\t__put_user_asm(*(u8 *)src, (u8 __user *)dst,\n\t\t\t      ret, \"b\", \"b\", \"iq\", 1);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 2:\n\t\t__uaccess_begin();\n\t\t__put_user_asm(*(u16 *)src, (u16 __user *)dst,\n\t\t\t      ret, \"w\", \"w\", \"ir\", 2);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 4:\n\t\t__uaccess_begin();\n\t\t__put_user_asm(*(u32 *)src, (u32 __user *)dst,\n\t\t\t      ret, \"l\", \"k\", \"ir\", 4);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 8:\n\t\t__uaccess_begin();\n\t\t__put_user_asm(*(u64 *)src, (u64 __user *)dst,\n\t\t\t      ret, \"q\", \"\", \"er\", 8);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 10:\n\t\t__uaccess_begin();\n\t\t__put_user_asm(*(u64 *)src, (u64 __user *)dst,\n\t\t\t       ret, \"q\", \"\", \"er\", 10);\n\t\tif (likely(!ret)) {\n\t\t\tasm(\"\":::\"memory\");\n\t\t\t__put_user_asm(4[(u16 *)src], 4 + (u16 __user *)dst,\n\t\t\t\t       ret, \"w\", \"w\", \"ir\", 2);\n\t\t}\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 16:\n\t\t__uaccess_begin();\n\t\t__put_user_asm(*(u64 *)src, (u64 __user *)dst,\n\t\t\t       ret, \"q\", \"\", \"er\", 16);\n\t\tif (likely(!ret)) {\n\t\t\tasm(\"\":::\"memory\");\n\t\t\t__put_user_asm(1[(u64 *)src], 1 + (u64 __user *)dst,\n\t\t\t\t       ret, \"q\", \"\", \"er\", 8);\n\t\t}\n\t\t__uaccess_end();\n\t\treturn ret;\n\tdefault:\n\t\treturn copy_user_generic((__force void *)dst, src, size);\n\t}\n}", "target": 1}
{"code": "slhc_free(struct slcompress *comp)\n{\n  printk(KERN_DEBUG \"Called IP function on non IP-system: slhc_free\");\n}", "target": 0}
{"code": "TEST(HeaderMapImplTest, RemoveHost) {\n  TestRequestHeaderMapImpl headers;\n  headers.setHost(\"foo\");\n  EXPECT_EQ(\"foo\", headers.get_(\"host\"));\n  EXPECT_EQ(\"foo\", headers.get_(\":authority\"));\n  EXPECT_EQ(1UL, headers.remove(\"host\"));\n  EXPECT_EQ(\"\", headers.get_(\"host\"));\n  EXPECT_EQ(\"\", headers.get_(\":authority\"));\n  EXPECT_EQ(nullptr, headers.Host());\n}", "target": 0}
{"code": "attr_unknown_count (void)\n{\n  return transit_hash->count;\n}", "target": 0}
{"code": "TEST_F(StuffingTest, SignedData_missing_codesigning_EKU) {\n  auto certs = uthenticode::read_certs(pe);\n  auto signed_data = certs[0].as_signed_data();\n  ASSERT_TRUE(signed_data->verify_signature());\n}", "target": 0}
{"code": "static int sqfs_disk_read(__u32 block, __u32 nr_blocks, void *buf)\n{\n\tulong ret;\n\tif (!ctxt.cur_dev)\n\t\treturn -1;\n\tret = blk_dread(ctxt.cur_dev, ctxt.cur_part_info.start + block,\n\t\t\tnr_blocks, buf);\n\tif (ret != nr_blocks)\n\t\treturn -1;\n\treturn ret;\n}", "target": 0}
{"code": "void test_bindmount(const char *path)\n{\n\tif (mount(path, path, \"none\", MS_BIND, NULL) == 0) {\n\t\tfprintf(stderr, \"leak at bind mount of %s\\n\", path);\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "static int checkStringLength(client *c, long long size) {\n    if (!mustObeyClient(c) && size > server.proto_max_bulk_len) {\n        addReplyError(c,\"string exceeds maximum allowed size (proto-max-bulk-len)\");\n        return C_ERR;\n    }\n    return C_OK;\n}", "target": 1}
{"code": "header_put_marker (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 4)\n\t{\tpsf->header [psf->headindex++] = (x >> 24) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = x ;\n\t\t} ;\n} ", "target": 1}
{"code": "ev_archive_reset (EvArchive *archive)\n{\n\tg_return_if_fail (EV_IS_ARCHIVE (archive));\n\tg_return_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE);\n\tswitch (archive->type) {\n\tcase EV_ARCHIVE_TYPE_RAR:\n\tcase EV_ARCHIVE_TYPE_ZIP:\n\tcase EV_ARCHIVE_TYPE_7Z:\n\tcase EV_ARCHIVE_TYPE_TAR:\n\t\tg_clear_pointer (&archive->libar, archive_free);\n\t\tlibarchive_set_archive_type (archive, archive->type);\n\t\tarchive->libar_entry = NULL;\n\t\tbreak;\n\tdefault:\n\t\tg_assert_not_reached ();\n\t}\n}", "target": 0}
{"code": "void sctp_association_free(struct sctp_association *asoc)\n{\n\tstruct sock *sk = asoc->base.sk;\n\tstruct sctp_transport *transport;\n\tstruct list_head *pos, *temp;\n\tint i;\n\tif (!asoc->temp) {\n\t\tlist_del(&asoc->asocs);\n\t\tif (sctp_style(sk, TCP) && sctp_sstate(sk, LISTENING))\n\t\t\tsk->sk_ack_backlog--;\n\t}\n\tasoc->base.dead = true;\n\tsctp_outq_free(&asoc->outqueue);\n\tsctp_ulpq_free(&asoc->ulpq);\n\tsctp_inq_free(&asoc->base.inqueue);\n\tsctp_tsnmap_free(&asoc->peer.tsn_map);\n\tsctp_ssnmap_free(asoc->ssnmap);\n\tsctp_bind_addr_free(&asoc->base.bind_addr);\n\tfor (i = SCTP_EVENT_TIMEOUT_NONE; i < SCTP_NUM_TIMEOUT_TYPES; ++i) {\n\t\tif (del_timer(&asoc->timers[i]))\n\t\t\tsctp_association_put(asoc);\n\t}\n\tkfree(asoc->peer.cookie);\n\tkfree(asoc->peer.peer_random);\n\tkfree(asoc->peer.peer_chunks);\n\tkfree(asoc->peer.peer_hmacs);\n\tlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {\n\t\ttransport = list_entry(pos, struct sctp_transport, transports);\n\t\tlist_del_rcu(pos);\n\t\tsctp_transport_free(transport);\n\t}\n\tasoc->peer.transport_count = 0;\n\tsctp_asconf_queue_teardown(asoc);\n\tif (asoc->asconf_addr_del_pending != NULL)\n\t\tkfree(asoc->asconf_addr_del_pending);\n\tsctp_auth_destroy_keys(&asoc->endpoint_shared_keys);\n\tsctp_auth_key_put(asoc->asoc_shared_key);\n\tsctp_association_put(asoc);\n}", "target": 1}
{"code": "\t__must_hold(&ctx->completion_lock)\n{\n\tu32 seq = ctx->cached_cq_tail - atomic_read(&ctx->cq_timeouts);\n\tspin_lock_irq(&ctx->timeout_lock);\n\twhile (!list_empty(&ctx->timeout_list)) {\n\t\tu32 events_needed, events_got;\n\t\tstruct io_kiocb *req = list_first_entry(&ctx->timeout_list,\n\t\t\t\t\t\tstruct io_kiocb, timeout.list);\n\t\tif (io_is_timeout_noseq(req))\n\t\t\tbreak;\n\t\tevents_needed = req->timeout.target_seq - ctx->cq_last_tm_flush;\n\t\tevents_got = seq - ctx->cq_last_tm_flush;\n\t\tif (events_got < events_needed)\n\t\t\tbreak;\n\t\tlist_del_init(&req->timeout.list);\n\t\tio_kill_timeout(req, 0);\n\t}\n\tctx->cq_last_tm_flush = seq;\n\tspin_unlock_irq(&ctx->timeout_lock);\n}", "target": 1}
{"code": "addMultiArrayContentJSON(CtxJson *ctx, void* array, const UA_DataType *type, \n                         size_t *index, UA_UInt32 *arrayDimensions, size_t dimensionIndex, \n                         size_t dimensionSize) {\n    if(ctx->depth > UA_JSON_ENCODING_MAX_RECURSION)\n        return UA_STATUSCODE_BADENCODINGERROR;\n    status ret;\n    if(dimensionIndex == (dimensionSize - 1)) {\n        ret = encodeJsonArray(ctx, ((u8*)array) + (type->memSize * *index),\n                              arrayDimensions[dimensionIndex], type);\n        (*index) += arrayDimensions[dimensionIndex];\n        return ret;\n    }\n    ret = writeJsonArrStart(ctx);\n    for(size_t i = 0; i < arrayDimensions[dimensionIndex]; i++) {\n        ret |= writeJsonCommaIfNeeded(ctx);\n        ret |= addMultiArrayContentJSON(ctx, array, type, index, arrayDimensions,\n                                        dimensionIndex + 1, dimensionSize);\n        ctx->commaNeeded[ctx->depth] = true;\n        if(ret != UA_STATUSCODE_GOOD)\n            return ret;\n    }\n    ret |= writeJsonArrEnd(ctx);\n    return ret;\n}", "target": 1}
{"code": "int ppp_register_net_channel(struct net *net, struct ppp_channel *chan)\n{\n\tstruct channel *pch;\n\tstruct ppp_net *pn;\n\tpch = kzalloc(sizeof(struct channel), GFP_KERNEL);\n\tif (!pch)\n\t\treturn -ENOMEM;\n\tpn = ppp_pernet(net);\n\tpch->ppp = NULL;\n\tpch->chan = chan;\n\tpch->chan_net = net;\n\tchan->ppp = pch;\n\tinit_ppp_file(&pch->file, CHANNEL);\n\tpch->file.hdrlen = chan->hdrlen;\n#ifdef CONFIG_PPP_MULTILINK\n\tpch->lastseq = -1;\n#endif \n\tinit_rwsem(&pch->chan_sem);\n\tspin_lock_init(&pch->downl);\n\trwlock_init(&pch->upl);\n\tspin_lock_bh(&pn->all_channels_lock);\n\tpch->file.index = ++pn->last_channel_index;\n\tlist_add(&pch->list, &pn->new_channels);\n\tatomic_inc(&channel_count);\n\tspin_unlock_bh(&pn->all_channels_lock);\n\treturn 0;\n}", "target": 1}
{"code": "static void __reg_deduce_bounds(struct bpf_reg_state *reg)\n{\n\t__reg32_deduce_bounds(reg);\n\t__reg64_deduce_bounds(reg);\n}", "target": 0}
{"code": "static struct sk_buff *ipv6_gso_segment(struct sk_buff *skb, int features)\n{\n\tstruct sk_buff *segs = ERR_PTR(-EINVAL);\n\tstruct ipv6hdr *ipv6h;\n\tstruct inet6_protocol *ops;\n\tif (!(features & NETIF_F_V6_CSUM))\n\t\tfeatures &= ~NETIF_F_SG;\n\tif (unlikely(skb_shinfo(skb)->gso_type &\n\t\t     ~(SKB_GSO_UDP |\n\t\t       SKB_GSO_DODGY |\n\t\t       SKB_GSO_TCP_ECN |\n\t\t       SKB_GSO_TCPV6 |\n\t\t       0)))\n\t\tgoto out;\n\tif (unlikely(!pskb_may_pull(skb, sizeof(*ipv6h))))\n\t\tgoto out;\n\tipv6h = ipv6_hdr(skb);\n\t__skb_pull(skb, sizeof(*ipv6h));\n\tsegs = ERR_PTR(-EPROTONOSUPPORT);\n\trcu_read_lock();\n\tops = ipv6_gso_pull_exthdrs(skb, ipv6h->nexthdr);\n\tif (likely(ops && ops->gso_segment)) {\n\t\tskb_reset_transport_header(skb);\n\t\tsegs = ops->gso_segment(skb, features);\n\t}\n\trcu_read_unlock();\n\tif (unlikely(IS_ERR(segs)))\n\t\tgoto out;\n\tfor (skb = segs; skb; skb = skb->next) {\n\t\tipv6h = ipv6_hdr(skb);\n\t\tipv6h->payload_len = htons(skb->len - skb->mac_len -\n\t\t\t\t\t   sizeof(*ipv6h));\n\t}\nout:\n\treturn segs;\n}", "target": 0}
{"code": "static struct nft_trans *nft_trans_alloc_gfp(const struct nft_ctx *ctx,\n\t\t\t\t\t     int msg_type, u32 size, gfp_t gfp)\n{\n\tstruct nft_trans *trans;\n\ttrans = kzalloc(sizeof(struct nft_trans) + size, gfp);\n\tif (trans == NULL)\n\t\treturn NULL;\n\tINIT_LIST_HEAD(&trans->list);\n\ttrans->msg_type = msg_type;\n\ttrans->ctx\t= *ctx;\n\treturn trans;\n}", "target": 0}
{"code": "void setScaleAndScrollAndLayout(WebKit::WebView* webView, WebPoint scroll, float scale)\n{\n    webView->setPageScaleFactor(scale, WebPoint(scroll.x, scroll.y));\n    webView->layout();\n}", "target": 0}
{"code": "QStringList JlCompress::extractDir(QuaZip &zip, const QString &dir)\n{\n    if(!zip.open(QuaZip::mdUnzip)) {\n        return QStringList();\n    }\n    QDir directory(dir);\n    QStringList extracted;\n    if (!zip.goToFirstFile()) {\n        return QStringList();\n    }\n    do {\n        QString name = zip.getCurrentFileName();\n        QString absFilePath = directory.absoluteFilePath(name);\n        if (!extractFile(&zip, \"\", absFilePath)) {\n            removeFile(extracted);\n            return QStringList();\n        }\n        extracted.append(absFilePath);\n    } while (zip.goToNextFile());\n    zip.close();\n    if(zip.getZipError()!=0) {\n        removeFile(extracted);\n        return QStringList();\n    }\n    return extracted;\n}", "target": 1}
{"code": "LIBOPENMPT_MODPLUG_API unsigned int ModPlug_InstrumentName(ModPlugFile* file, unsigned int qual, char* buff)\n{\n\tconst char* str;\n\tunsigned int retval;\n\tsize_t tmpretval;\n\tif(!file) return 0;\n\tstr = openmpt_module_get_instrument_name(file->mod,qual-1);\n\tif(!str){\n\t\tif(buff){\n\t\t\t*buff = '\\0';\n\t\t}\n\t\treturn 0;\n\t}\n\ttmpretval = strlen(str);\n\tif(tmpretval>=INT_MAX){\n\t\ttmpretval = INT_MAX-1;\n\t}\n\tretval = (int)tmpretval;\n\tif(buff){\n\t\tmemcpy(buff,str,retval+1);\n\t\tbuff[retval] = '\\0';\n\t}\n\topenmpt_free_string(str);\n\treturn retval;\n}", "target": 1}
{"code": "selReadStream(FILE  *fp)\n{\nchar    *selname;\nchar     linebuf[L_BUF_SIZE];\nl_int32  sy, sx, cy, cx, i, j, version, ignore;\nSEL     *sel;\n    PROCNAME(\"selReadStream\");\n    if (!fp)\n        return (SEL *)ERROR_PTR(\"stream not defined\", procName, NULL);\n    if (fscanf(fp, \"  Sel Version %d\\n\", &version) != 1)\n        return (SEL *)ERROR_PTR(\"not a sel file\", procName, NULL);\n    if (version != SEL_VERSION_NUMBER)\n        return (SEL *)ERROR_PTR(\"invalid sel version\", procName, NULL);\n    if (fgets(linebuf, L_BUF_SIZE, fp) == NULL)\n        return (SEL *)ERROR_PTR(\"error reading into linebuf\", procName, NULL);\n    selname = stringNew(linebuf);\n    sscanf(linebuf, \"  ------  %s  ------\", selname);\n    if (fscanf(fp, \"  sy = %d, sx = %d, cy = %d, cx = %d\\n\",\n            &sy, &sx, &cy, &cx) != 4) {\n        LEPT_FREE(selname);\n        return (SEL *)ERROR_PTR(\"dimensions not read\", procName, NULL);\n    }\n    if ((sel = selCreate(sy, sx, selname)) == NULL) {\n        LEPT_FREE(selname);\n        return (SEL *)ERROR_PTR(\"sel not made\", procName, NULL);\n    }\n    selSetOrigin(sel, cy, cx);\n    for (i = 0; i < sy; i++) {\n        ignore = fscanf(fp, \"    \");\n        for (j = 0; j < sx; j++)\n            ignore = fscanf(fp, \"%1d\", &sel->data[i][j]);\n        ignore = fscanf(fp, \"\\n\");\n    }\n    ignore = fscanf(fp, \"\\n\");\n    LEPT_FREE(selname);\n    return sel;\n}", "target": 1}
{"code": "static int l2cap_sock_getname(struct socket *sock, struct sockaddr *addr, int *len, int peer)\n{\n\tstruct sockaddr_l2 *la = (struct sockaddr_l2 *) addr;\n\tstruct sock *sk = sock->sk;\n\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\tmemset(la, 0, sizeof(struct sockaddr_l2));\n\taddr->sa_family = AF_BLUETOOTH;\n\t*len = sizeof(struct sockaddr_l2);\n\tif (peer) {\n\t\tla->l2_psm = chan->psm;\n\t\tbacpy(&la->l2_bdaddr, &bt_sk(sk)->dst);\n\t\tla->l2_cid = cpu_to_le16(chan->dcid);\n\t} else {\n\t\tla->l2_psm = chan->sport;\n\t\tbacpy(&la->l2_bdaddr, &bt_sk(sk)->src);\n\t\tla->l2_cid = cpu_to_le16(chan->scid);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "d_lite_s_alloc_simple(VALUE klass)\n{\n    return d_simple_new_internal(klass,\n\t\t\t\t INT2FIX(0), 0,\n\t\t\t\t DEFAULT_SG,\n\t\t\t\t 0, 0, 0,\n\t\t\t\t HAVE_JD);\n}", "target": 0}
{"code": "DSA_PrivateKey::create_signature_op(RandomNumberGenerator& ,\n                                    const std::string& params,\n                                    const std::string& provider) const\n   {\n   if(provider == \"base\" || provider.empty())\n      return std::unique_ptr<PK_Ops::Signature>(new DSA_Signature_Operation(*this, params));\n   throw Provider_Not_Found(algo_name(), provider);\n   }", "target": 1}
{"code": "static inline void x86_assign_hw_event(struct perf_event *event,\n\t\t\t\tstruct cpu_hw_events *cpuc, int i)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\thwc->idx = cpuc->assign[i];\n\thwc->last_cpu = smp_processor_id();\n\thwc->last_tag = ++cpuc->tags[i];\n\tif (hwc->idx == X86_PMC_IDX_FIXED_BTS) {\n\t\thwc->config_base = 0;\n\t\thwc->event_base\t= 0;\n\t} else if (hwc->idx >= X86_PMC_IDX_FIXED) {\n\t\thwc->config_base = MSR_ARCH_PERFMON_FIXED_CTR_CTRL;\n\t\thwc->event_base = MSR_ARCH_PERFMON_FIXED_CTR0;\n\t} else {\n\t\thwc->config_base = x86_pmu_config_addr(hwc->idx);\n\t\thwc->event_base  = x86_pmu_event_addr(hwc->idx);\n\t}\n}", "target": 1}
{"code": "void HeaderMapImpl::subtractSize(uint64_t size) {\n  if (cached_byte_size_.has_value()) {\n    ASSERT(cached_byte_size_ >= size);\n    cached_byte_size_.value() -= size;\n  }\n}", "target": 0}
{"code": "R_API bool r_sys_mkdirp(const char *dir) {\n\tbool ret = true;\n\tchar slash = R_SYS_DIR[0];\n\tchar *path = strdup (dir), *ptr = path;\n\tif (!path) {\n\t\teprintf (\"r_sys_mkdirp: Unable to allocate memory\\n\");\n\t\treturn false;\n\t}\n\tif (*ptr == slash) {\n\t\tptr++;\n\t}\n#if __WINDOWS__\n\t{\n\t\tchar *p = strstr (ptr, \":\\\\\");\n\t\tif (p) {\n\t\t\tptr = p + 2;\n\t\t}\n\t}\n#endif\n\tfor (;;) {\n\t\tfor (; *ptr; ptr++) {\n\t\t\tif (*ptr == '/' || *ptr == '\\\\') {\n\t\t\t\tslash = *ptr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!*ptr) {\n\t\t\tbreak;\n\t\t}\n\t\t*ptr = 0;\n\t\tif (!r_sys_mkdir (path) && r_sys_mkdir_failed ()) {\n\t\t\teprintf (\"r_sys_mkdirp: fail '%s' of '%s'\\n\", path, dir);\n\t\t\tfree (path);\n\t\t\treturn false;\n\t\t}\n\t\t*ptr = slash;\n\t\tptr++;\n\t}\n\tif (!r_sys_mkdir (path) && r_sys_mkdir_failed ()) {\n\t\tret = false;\n\t}\n\tfree (path);\n\treturn ret;\n}", "target": 1}
{"code": "inline TfLiteTensor* GetTensorAtIndex(const TfLiteContext* context,\n                                      int tensor_index) {\n  if (context->tensors != nullptr) {\n    return &context->tensors[tensor_index];\n  } else {\n    return context->GetTensor(context, tensor_index);\n  }\n}", "target": 0}
{"code": "GF_Box *flxs_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AdobeFlashAccessParamsBox, GF_ISOM_BOX_TYPE_FLXS);\n\treturn (GF_Box *)tmp;\n}", "target": 0}
{"code": "static int add_array_entry(const char* loc_name, zval* hash_arr, char* key_name TSRMLS_DC)\n{\n\tchar*   key_value \t= NULL;\n\tchar*   cur_key_name\t= NULL;\n\tchar*   token        \t= NULL;\n\tchar*   last_ptr  \t= NULL;\n\tint\tresult\t\t= 0;\n\tint \tcur_result  \t= 0;\n\tint \tcnt  \t\t= 0;\n\tif( strcmp(key_name , LOC_PRIVATE_TAG)==0 ){\n\t\tkey_value = get_private_subtags( loc_name );\n\t\tresult = 1;\n\t} else {\n\t\tkey_value = get_icu_value_internal( loc_name , key_name , &result,1 );\n\t}\n\tif( (strcmp(key_name , LOC_PRIVATE_TAG)==0) || \n\t\t( strcmp(key_name , LOC_VARIANT_TAG)==0) ){\n\t\tif( result > 0 && key_value){\n\t\t\ttoken = php_strtok_r( key_value , DELIMITER ,&last_ptr);\t\n\t\t\tif( cur_key_name ){\n\t\t\t\tefree( cur_key_name);\n\t\t\t}\n\t\t\tcur_key_name = (char*)ecalloc( 25,  25);\n\t\t\tsprintf( cur_key_name , \"%s%d\", key_name , cnt++);\t\n\t\t\tadd_assoc_string( hash_arr, cur_key_name , token ,TRUE );\n\t\t\twhile( (token = php_strtok_r(NULL , DELIMITER , &last_ptr)) && (strlen(token)>1) ){\n\t\t\t\tsprintf( cur_key_name , \"%s%d\", key_name , cnt++);\t\n\t\t\t\tadd_assoc_string( hash_arr, cur_key_name , token , TRUE );\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif( result == 1 ){\n\t\t\tadd_assoc_string( hash_arr, key_name , key_value , TRUE );\n\t\t\tcur_result = 1;\n\t\t}\n\t}\n\tif( cur_key_name ){\n\t\tefree( cur_key_name);\n\t}\n\tif( key_value){\n\t\tefree(key_value);\t\n\t}\n\treturn cur_result;\n}", "target": 1}
{"code": "static void hardware_enable(void *junk)\n{\n\traw_spin_lock(&kvm_lock);\n\thardware_enable_nolock(junk);\n\traw_spin_unlock(&kvm_lock);\n}", "target": 0}
{"code": "static int ext4_fill_flex_info(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_group_desc *gdp = NULL;\n\text4_group_t flex_group_count;\n\text4_group_t flex_group;\n\tint groups_per_flex = 0;\n\tsize_t size;\n\tint i;\n\tsbi->s_log_groups_per_flex = sbi->s_es->s_log_groups_per_flex;\n\tgroups_per_flex = 1 << sbi->s_log_groups_per_flex;\n\tif (groups_per_flex < 2) {\n\t\tsbi->s_log_groups_per_flex = 0;\n\t\treturn 1;\n\t}\n\tflex_group_count = ((sbi->s_groups_count + groups_per_flex - 1) +\n\t\t\t((le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) + 1) <<\n\t\t\t      EXT4_DESC_PER_BLOCK_BITS(sb))) / groups_per_flex;\n\tsize = flex_group_count * sizeof(struct flex_groups);\n\tsbi->s_flex_groups = ext4_kvzalloc(size, GFP_KERNEL);\n\tif (sbi->s_flex_groups == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory for %u flex groups\",\n\t\t\t flex_group_count);\n\t\tgoto failed;\n\t}\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\t\tflex_group = ext4_flex_group(sbi, i);\n\t\tatomic_add(ext4_free_inodes_count(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].free_inodes);\n\t\tatomic_add(ext4_free_group_clusters(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].free_clusters);\n\t\tatomic_add(ext4_used_dirs_count(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].used_dirs);\n\t}\n\treturn 1;\nfailed:\n\treturn 0;\n}", "target": 1}
{"code": "static ut64 r_buf_read64le (RBuffer *buf, ut64 off) {\n\tut8 data[8] = {0};\n\tr_buf_read_at (buf, off, data, 8);\n\treturn r_read_le64 (data);\n}", "target": 0}
{"code": "int ossl_dsa_check_params(const DSA *dsa, int checktype, int *ret)\n{\n    if (!dsa_precheck_params(dsa, ret))\n        return 0;\n    if (checktype == OSSL_KEYMGMT_VALIDATE_QUICK_CHECK)\n        return ossl_ffc_params_simple_validate(dsa->libctx, &dsa->params,\n                                               FFC_PARAM_TYPE_DSA, ret);\n    else\n        return ossl_ffc_params_full_validate(dsa->libctx, &dsa->params,\n                                             FFC_PARAM_TYPE_DSA, ret);\n}", "target": 0}
{"code": "DECLAREcpFunc(cpContigStrips2SeparateTiles)\n{\n\treturn cpImage(in, out,\n\t    readContigStripsIntoBuffer,\n\t    writeBufferToSeparateTiles,\n\t    imagelength, imagewidth, spp);\n}", "target": 0}
{"code": "static int iwl_process_add_sta_resp(struct iwl_priv *priv,\n\t\t\t\t    struct iwl_addsta_cmd *addsta,\n\t\t\t\t    struct iwl_rx_packet *pkt)\n{\n\tu8 sta_id = addsta->sta.sta_id;\n\tunsigned long flags;\n\tint ret = -EIO;\n\tif (pkt->hdr.flags & IWL_CMD_FAILED_MSK) {\n\t\tIWL_ERR(priv, \"Bad return from REPLY_ADD_STA (0x%08X)\\n\",\n\t\t\tpkt->hdr.flags);\n\t\treturn ret;\n\t}\n\tIWL_DEBUG_INFO(priv, \"Processing response for adding station %u\\n\",\n\t\t       sta_id);\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags);\n\tswitch (pkt->u.add_sta.status) {\n\tcase ADD_STA_SUCCESS_MSK:\n\t\tIWL_DEBUG_INFO(priv, \"REPLY_ADD_STA PASSED\\n\");\n\t\tiwl_sta_ucode_activate(priv, sta_id);\n\t\tret = 0;\n\t\tbreak;\n\tcase ADD_STA_NO_ROOM_IN_TABLE:\n\t\tIWL_ERR(priv, \"Adding station %d failed, no room in table.\\n\",\n\t\t\tsta_id);\n\t\tbreak;\n\tcase ADD_STA_NO_BLOCK_ACK_RESOURCE:\n\t\tIWL_ERR(priv, \"Adding station %d failed, no block ack \"\n\t\t\t\"resource.\\n\", sta_id);\n\t\tbreak;\n\tcase ADD_STA_MODIFY_NON_EXIST_STA:\n\t\tIWL_ERR(priv, \"Attempting to modify non-existing station %d\\n\",\n\t\t\tsta_id);\n\t\tbreak;\n\tdefault:\n\t\tIWL_DEBUG_ASSOC(priv, \"Received REPLY_ADD_STA:(0x%08X)\\n\",\n\t\t\t\tpkt->u.add_sta.status);\n\t\tbreak;\n\t}\n\tIWL_DEBUG_INFO(priv, \"%s station id %u addr %pM\\n\",\n\t\t       priv->stations[sta_id].sta.mode ==\n\t\t       STA_CONTROL_MODIFY_MSK ?  \"Modified\" : \"Added\",\n\t\t       sta_id, priv->stations[sta_id].sta.sta.addr);\n\tIWL_DEBUG_INFO(priv, \"%s station according to cmd buffer %pM\\n\",\n\t\t       priv->stations[sta_id].sta.mode ==\n\t\t       STA_CONTROL_MODIFY_MSK ? \"Modified\" : \"Added\",\n\t\t       addsta->sta.addr);\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\treturn ret;\n}", "target": 1}
{"code": "static Jsi_RC jsi_ArrayForeachCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) \n{\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) \n        return Jsi_LogError(\"expected array object\");\n    Jsi_Obj *obj;\n    int curlen;\n    uint i;\n    Jsi_Value *func, *vpargs;\n    func = Jsi_ValueArrayIndex(interp, args, 0);\n    if (!Jsi_ValueIsFunction(interp, func)) \n        return Jsi_LogError(\"expected function\");\n    Jsi_Value *sthis = Jsi_ValueArrayIndex(interp, args, 1);\n    Jsi_Value *nthis = NULL;\n    if (!sthis)\n        sthis = nthis = Jsi_ValueNew1(interp);\n    obj = _this->d.obj;\n    curlen = Jsi_ObjGetLength(interp, obj);    \n    if (curlen < 0) {\n        Jsi_ObjSetLength(interp, obj, 0);\n    }\n    Jsi_ObjListifyArray(interp, obj);\n    Jsi_RC rc = JSI_OK;\n    Jsi_Value *vobjs[3];\n    Jsi_Func *fptr = func->d.obj->d.fobj->func;\n    int maa = (fptr->argnames?fptr->argnames->argCnt:0);\n    if (maa>3)\n        maa = 3;\n    for (i = 0; i < obj->arrCnt && rc == JSI_OK; i++) {\n        if (!obj->arr[i]) continue;\n        vobjs[0] = obj->arr[i];\n        vobjs[1] = (maa>1?Jsi_ValueNewNumber(interp, i):NULL);\n        vobjs[2] = _this;\n        vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, vobjs, maa, 0));\n        Jsi_IncrRefCount(interp, vpargs);\n        rc = Jsi_FunctionInvoke(interp, func, vpargs, ret, sthis);\n        Jsi_DecrRefCount(interp, vpargs);\n    }\n    if (nthis)\n        Jsi_DecrRefCount(interp, nthis);\n    return rc;\n}", "target": 1}
{"code": "    bool ms_verify_authorizer(Connection *con, int peer_type,\n\t\t\t      int protocol, bufferlist& authorizer_data, bufferlist& authorizer_reply,\n\t\t\t      bool& isvalid, CryptoKey& session_key) override {\n      isvalid = true;\n      return true;\n    }", "target": 1}
{"code": "_dbus_get_monotonic_time (long *tv_sec,\n                          long *tv_usec)\n{\n#ifdef HAVE_MONOTONIC_CLOCK\n  struct timespec ts;\n  clock_gettime (CLOCK_MONOTONIC, &ts);\n  if (tv_sec)\n    *tv_sec = ts.tv_sec;\n  if (tv_usec)\n    *tv_usec = ts.tv_nsec / 1000;\n#else\n  struct timeval t;\n  gettimeofday (&t, NULL);\n  if (tv_sec)\n    *tv_sec = t.tv_sec;\n  if (tv_usec)\n    *tv_usec = t.tv_usec;\n#endif\n}", "target": 0}
{"code": "void skip(Protocol_& prot, TType arg_type) {\n  switch (arg_type) {\n    case TType::T_BOOL: {\n      bool boolv;\n      prot.readBool(boolv);\n      return;\n    }\n    case TType::T_BYTE: {\n      int8_t bytev;\n      prot.readByte(bytev);\n      return;\n    }\n    case TType::T_I16: {\n      int16_t i16;\n      prot.readI16(i16);\n      return;\n    }\n    case TType::T_I32: {\n      int32_t i32;\n      prot.readI32(i32);\n      return;\n    }\n    case TType::T_I64: {\n      int64_t i64;\n      prot.readI64(i64);\n      return;\n    }\n    case TType::T_DOUBLE: {\n      double dub;\n      prot.readDouble(dub);\n      return;\n    }\n    case TType::T_FLOAT: {\n      float flt;\n      prot.readFloat(flt);\n      return;\n    }\n    case TType::T_STRING: {\n      std::string str;\n      prot.readBinary(str);\n      return;\n    }\n    case TType::T_STRUCT: {\n      std::string name;\n      int16_t fid;\n      TType ftype;\n      prot.readStructBegin(name);\n      while (true) {\n        prot.readFieldBegin(name, ftype, fid);\n        if (ftype == TType::T_STOP) {\n          break;\n        }\n        apache::thrift::skip(prot, ftype);\n        prot.readFieldEnd();\n      }\n      prot.readStructEnd();\n      return;\n    }\n    case TType::T_MAP: {\n      TType keyType;\n      TType valType;\n      uint32_t i, size;\n      prot.readMapBegin(keyType, valType, size);\n      for (i = 0; i < size; i++) {\n        apache::thrift::skip(prot, keyType);\n        apache::thrift::skip(prot, valType);\n      }\n      prot.readMapEnd();\n      return;\n    }\n    case TType::T_SET: {\n      TType elemType;\n      uint32_t i, size;\n      prot.readSetBegin(elemType, size);\n      for (i = 0; i < size; i++) {\n        apache::thrift::skip(prot, elemType);\n      }\n      prot.readSetEnd();\n      return;\n    }\n    case TType::T_LIST: {\n      TType elemType;\n      uint32_t i, size;\n      prot.readListBegin(elemType, size);\n      for (i = 0; i < size; i++) {\n        apache::thrift::skip(prot, elemType);\n      }\n      prot.readListEnd();\n      return;\n    }\n    default:\n      return;\n  }\n}", "target": 1}
{"code": "sf_open_virtual\t(SF_VIRTUAL_IO *sfvirtual, int mode, SF_INFO *sfinfo, void *user_data)\n{\tSF_PRIVATE \t*psf ;\n\tif (sfvirtual->get_filelen == NULL || sfvirtual->seek == NULL || sfvirtual->tell == NULL)\n\t{\tsf_errno = SFE_BAD_VIRTUAL_IO ;\n\t\tsnprintf (sf_parselog, sizeof (sf_parselog), \"Bad vio_get_filelen / vio_seek / vio_tell in SF_VIRTUAL_IO struct.\\n\") ;\n\t\treturn NULL ;\n\t\t} ;\n\tif ((mode == SFM_READ || mode == SFM_RDWR) && sfvirtual->read == NULL)\n\t{\tsf_errno = SFE_BAD_VIRTUAL_IO ;\n\t\tsnprintf (sf_parselog, sizeof (sf_parselog), \"Bad vio_read in SF_VIRTUAL_IO struct.\\n\") ;\n\t\treturn NULL ;\n\t\t} ;\n\tif ((mode == SFM_WRITE || mode == SFM_RDWR) && sfvirtual->write == NULL)\n\t{\tsf_errno = SFE_BAD_VIRTUAL_IO ;\n\t\tsnprintf (sf_parselog, sizeof (sf_parselog), \"Bad vio_write in SF_VIRTUAL_IO struct.\\n\") ;\n\t\treturn NULL ;\n\t\t} ;\n\tif ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)\n\t{\tsf_errno = SFE_MALLOC_FAILED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\tpsf_init_files (psf) ;\n\tpsf->virtual_io = SF_TRUE ;\n\tpsf->vio = *sfvirtual ;\n\tpsf->vio_user_data = user_data ;\n\tpsf->file.mode = mode ;\n\treturn psf_open_file (psf, sfinfo) ;\n} ", "target": 1}
{"code": "void bnep_net_setup(struct net_device *dev)\n{\n\tmemset(dev->broadcast, 0xff, ETH_ALEN);\n\tdev->addr_len = ETH_ALEN;\n\tether_setup(dev);\n\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\tdev->netdev_ops = &bnep_netdev_ops;\n\tdev->watchdog_timeo  = HZ * 2;\n}", "target": 0}
{"code": "int bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t\tstruct msghdr *msg, size_t len, int flags)\n{\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tsize_t copied;\n\tint err;\n\tBT_DBG(\"sock %p sk %p len %zu\", sock, sk, len);\n\tif (flags & (MSG_OOB))\n\t\treturn -EOPNOTSUPP;\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb) {\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN) {\n\t\t\tmsg->msg_namelen = 0;\n\t\t\treturn 0;\n\t\t}\n\t\treturn err;\n\t}\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err == 0) {\n\t\tsock_recv_ts_and_drops(msg, sk, skb);\n\t\tif (bt_sk(sk)->skb_msg_name)\n\t\t\tbt_sk(sk)->skb_msg_name(skb, msg->msg_name,\n\t\t\t\t\t\t&msg->msg_namelen);\n\t\telse\n\t\t\tmsg->msg_namelen = 0;\n\t}\n\tskb_free_datagram(sk, skb);\n\treturn err ? : copied;\n}", "target": 1}
{"code": "static ssize_t fuse_fill_write_pages(struct fuse_req *req,\n\t\t\t       struct address_space *mapping,\n\t\t\t       struct iov_iter *ii, loff_t pos)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(mapping->host);\n\tunsigned offset = pos & (PAGE_CACHE_SIZE - 1);\n\tsize_t count = 0;\n\tint err;\n\treq->in.argpages = 1;\n\treq->page_descs[0].offset = offset;\n\tdo {\n\t\tsize_t tmp;\n\t\tstruct page *page;\n\t\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\t\tsize_t bytes = min_t(size_t, PAGE_CACHE_SIZE - offset,\n\t\t\t\t     iov_iter_count(ii));\n\t\tbytes = min_t(size_t, bytes, fc->max_write - count);\n again:\n\t\terr = -EFAULT;\n\t\tif (iov_iter_fault_in_readable(ii, bytes))\n\t\t\tbreak;\n\t\terr = -ENOMEM;\n\t\tpage = grab_cache_page_write_begin(mapping, index, 0);\n\t\tif (!page)\n\t\t\tbreak;\n\t\tif (mapping_writably_mapped(mapping))\n\t\t\tflush_dcache_page(page);\n\t\ttmp = iov_iter_copy_from_user_atomic(page, ii, offset, bytes);\n\t\tflush_dcache_page(page);\n\t\tif (!tmp) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tbytes = min(bytes, iov_iter_single_seg_count(ii));\n\t\t\tgoto again;\n\t\t}\n\t\terr = 0;\n\t\treq->pages[req->num_pages] = page;\n\t\treq->page_descs[req->num_pages].length = tmp;\n\t\treq->num_pages++;\n\t\tiov_iter_advance(ii, tmp);\n\t\tcount += tmp;\n\t\tpos += tmp;\n\t\toffset += tmp;\n\t\tif (offset == PAGE_CACHE_SIZE)\n\t\t\toffset = 0;\n\t\tif (!fc->big_writes)\n\t\t\tbreak;\n\t} while (iov_iter_count(ii) && count < fc->max_write &&\n\t\t req->num_pages < req->max_pages && offset == 0);\n\treturn count > 0 ? count : err;\n}", "target": 1}
{"code": "static void irda_flow_indication(void *instance, void *sap, LOCAL_FLOW flow)\n{\n\tstruct irda_sock *self;\n\tstruct sock *sk;\n\tIRDA_DEBUG(2, \"%s()\\n\", __func__);\n\tself = instance;\n\tsk = instance;\n\tBUG_ON(sk == NULL);\n\tswitch (flow) {\n\tcase FLOW_STOP:\n\t\tIRDA_DEBUG(1, \"%s(), IrTTP wants us to slow down\\n\",\n\t\t\t   __func__);\n\t\tself->tx_flow = flow;\n\t\tbreak;\n\tcase FLOW_START:\n\t\tself->tx_flow = flow;\n\t\tIRDA_DEBUG(1, \"%s(), IrTTP wants us to start again\\n\",\n\t\t\t   __func__);\n\t\twake_up_interruptible(sk->sk_sleep);\n\t\tbreak;\n\tdefault:\n\t\tIRDA_DEBUG(0, \"%s(), Unknown flow command!\\n\", __func__);\n\t\tself->tx_flow = flow;\n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "pkinit_check_kdc_pkid(krb5_context context,\n                      pkinit_plg_crypto_context plg_cryptoctx,\n                      pkinit_req_crypto_context req_cryptoctx,\n                      pkinit_identity_crypto_context id_cryptoctx,\n                      unsigned char *pdid_buf,\n                      unsigned int pkid_len,\n                      int *valid_kdcPkId)\n{\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n    PKCS7_ISSUER_AND_SERIAL *is = NULL;\n    const unsigned char *p = pdid_buf;\n    int status = 1;\n    X509 *kdc_cert = sk_X509_value(id_cryptoctx->my_certs, id_cryptoctx->cert_index);\n    *valid_kdcPkId = 0;\n    pkiDebug(\"found kdcPkId in AS REQ\\n\");\n    is = d2i_PKCS7_ISSUER_AND_SERIAL(NULL, &p, (int)pkid_len);\n    if (is == NULL)\n        goto cleanup;\n    status = X509_NAME_cmp(X509_get_issuer_name(kdc_cert), is->issuer);\n    if (!status) {\n        status = ASN1_INTEGER_cmp(X509_get_serialNumber(kdc_cert), is->serial);\n        if (!status)\n            *valid_kdcPkId = 1;\n    }\n    retval = 0;\ncleanup:\n    X509_NAME_free(is->issuer);\n    ASN1_INTEGER_free(is->serial);\n    free(is);\n    return retval;\n}", "target": 1}
{"code": "int init_aliases(void)\n{\n    FILE *fp;\n    char alias[MAXALIASLEN + 1U];\n    char dir[PATH_MAX + 1U];\n    if ((fp = fopen(ALIASES_FILE, \"r\")) == NULL) {\n        return 0;\n    }\n    while (fgets(alias, sizeof alias, fp) != NULL) {\n        if (*alias == '#' || *alias == '\\n' || *alias == 0) {\n            continue;\n        }\n        {\n            char * const z = alias + strlen(alias) - 1U;\n            if (*z != '\\n') {\n                goto bad;\n            }\n            *z = 0;\n        }\n        do {\n            if (fgets(dir, sizeof dir, fp) == NULL || *dir == 0) {\n                goto bad;\n            }\n            {\n                char * const z = dir + strlen(dir) - 1U;\n                if (*z == '\\n') {\n                    *z = 0;\n                }\n            }\n        } while (*dir == '#' || *dir == 0);\n        if (head == NULL) {\n            if ((head = tail = malloc(sizeof *head)) == NULL ||\n                (tail->alias = strdup(alias)) == NULL ||\n                (tail->dir = strdup(dir)) == NULL) {\n                die_mem();\n            }\n            tail->next = NULL;\n        } else {\n            DirAlias *curr;\n            if ((curr = malloc(sizeof *curr)) == NULL ||\n                (curr->alias = strdup(alias)) == NULL ||\n                (curr->dir = strdup(dir)) == NULL) {\n                die_mem();\n            }\n            tail->next = curr;\n            tail = curr;\n        }\n    }\n    fclose(fp);\n    aliases_up++;\n    return 0;\n    bad:\n    fclose(fp);\n    logfile(LOG_ERR, MSG_ALIASES_BROKEN_FILE \" [\" ALIASES_FILE \"]\");\n    return -1;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& handle = ctx->input(0);\n    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(handle.shape()),\n                errors::InvalidArgument(\"handle must be scalar\"));\n    const string& name = handle.scalar<tstring>()();\n    Tensor val;\n    auto session_state = ctx->session_state();\n    OP_REQUIRES(ctx, session_state != nullptr,\n                errors::FailedPrecondition(\n                    \"GetSessionTensor called on null session state\"));\n    OP_REQUIRES_OK(ctx, session_state->GetTensor(name, &val));\n    ctx->set_output(0, val);\n  }", "target": 0}
{"code": "static void sock_def_wakeup(struct sock *sk)\n{\n\tread_lock(&sk->sk_callback_lock);\n\tif (sk->sk_sleep && waitqueue_active(sk->sk_sleep))\n\t\twake_up_interruptible_all(sk->sk_sleep);\n\tread_unlock(&sk->sk_callback_lock);\n}", "target": 0}
{"code": "void* IOBuf::operator new(size_t size) {\n  if (size > kMaxIOBufSize) {\n    throw_exception<std::bad_alloc>();\n  }\n  size_t fullSize = offsetof(HeapStorage, buf) + size;\n  auto storage = static_cast<HeapStorage*>(checkedMalloc(fullSize));\n  new (&storage->prefix) HeapPrefix(kIOBufInUse, fullSize);\n  if (io_buf_alloc_cb) {\n    io_buf_alloc_cb(storage, fullSize);\n  }\n  return &(storage->buf);\n}", "target": 0}
{"code": "static ssize_t ext4_ext_direct_IO(int rw, struct kiocb *iocb,\n\t\t\t      const struct iovec *iov, loff_t offset,\n\t\t\t      unsigned long nr_segs)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tssize_t ret;\n\tsize_t count = iov_length(iov, nr_segs);\n\tloff_t final_size = offset + count;\n\tif (rw == WRITE && final_size <= inode->i_size) {\n\t\tiocb->private = NULL;\n\t\tEXT4_I(inode)->cur_aio_dio = NULL;\n\t\tif (!is_sync_kiocb(iocb)) {\n\t\t\tiocb->private = ext4_init_io_end(inode);\n\t\t\tif (!iocb->private)\n\t\t\t\treturn -ENOMEM;\n\t\t\tEXT4_I(inode)->cur_aio_dio = iocb->private;\n\t\t}\n\t\tret = blockdev_direct_IO(rw, iocb, inode,\n\t\t\t\t\t inode->i_sb->s_bdev, iov,\n\t\t\t\t\t offset, nr_segs,\n\t\t\t\t\t ext4_get_block_write,\n\t\t\t\t\t ext4_end_io_dio);\n\t\tif (iocb->private)\n\t\t\tEXT4_I(inode)->cur_aio_dio = NULL;\n\t\tif (ret != -EIOCBQUEUED && ret <= 0 && iocb->private) {\n\t\t\text4_free_io_end(iocb->private);\n\t\t\tiocb->private = NULL;\n\t\t} else if (ret > 0 && ext4_test_inode_state(inode,\n\t\t\t\t\t\tEXT4_STATE_DIO_UNWRITTEN)) {\n\t\t\tint err;\n\t\t\terr = ext4_convert_unwritten_extents(inode,\n\t\t\t\t\t\t\t     offset, ret);\n\t\t\tif (err < 0)\n\t\t\t\tret = err;\n\t\t\text4_clear_inode_state(inode, EXT4_STATE_DIO_UNWRITTEN);\n\t\t}\n\t\treturn ret;\n\t}\n\treturn ext4_ind_direct_IO(rw, iocb, iov, offset, nr_segs);\n}", "target": 1}
{"code": "char *enl_ipc_get(const char *msg_data)\n{\n\tstatic char *message = NULL;\n\tstatic unsigned short len = 0;\n\tchar buff[13], *ret_msg = NULL;\n\tregister unsigned char i;\n\tunsigned char blen;\n\tif (msg_data == IPC_TIMEOUT) {\n\t\treturn(IPC_TIMEOUT);\n\t}\n\tfor (i = 0; i < 12; i++) {\n\t\tbuff[i] = msg_data[i];\n\t}\n\tbuff[12] = 0;\n\tblen = strlen(buff);\n\tif (message != NULL) {\n\t\tlen += blen;\n\t\tmessage = (char *) erealloc(message, len + 1);\n\t\tstrcat(message, buff);\n\t} else {\n\t\tlen = blen;\n\t\tmessage = (char *) emalloc(len + 1);\n\t\tstrcpy(message, buff);\n\t}\n\tif (blen < 12) {\n\t\tret_msg = message;\n\t\tmessage = NULL;\n\t\tD((\"Received complete reply:  \\\"%s\\\"\\n\", ret_msg));\n\t}\n\treturn(ret_msg);\n}", "target": 1}
{"code": "void test_chdir(const char *path)\n{\n\tif (chdir(path) == 0) {\n\t\tfprintf(stderr, \"leak at chdir to %s\\n\", path);\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "ext2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\tswitch(type) {\n\t\tcase ACL_TYPE_ACCESS:\n\t\t\tname_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\t\tif (acl) {\n\t\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\t\tif (error < 0)\n\t\t\t\t\treturn error;\n\t\t\t\telse {\n\t\t\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\t\t\t\tmark_inode_dirty(inode);\n\t\t\t\t\tif (error == 0)\n\t\t\t\t\t\tacl = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ACL_TYPE_DEFAULT:\n\t\t\tname_index = EXT2_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\t\treturn acl ? -EACCES : 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n \tif (acl) {\n\t\tvalue = ext2_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\terror = ext2_xattr_set(inode, name_index, \"\", value, size, 0);\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\treturn error;\n}", "target": 1}
{"code": "Map1toN(SDL_PixelFormat * src, Uint8 Rmod, Uint8 Gmod, Uint8 Bmod, Uint8 Amod,\n        SDL_PixelFormat * dst)\n{\n    Uint8 *map;\n    int i;\n    int bpp;\n    SDL_Palette *pal = src->palette;\n    bpp = ((dst->BytesPerPixel == 3) ? 4 : dst->BytesPerPixel);\n    map = (Uint8 *) SDL_malloc(pal->ncolors * bpp);\n    if (map == NULL) {\n        SDL_OutOfMemory();\n        return (NULL);\n    }\n    for (i = 0; i < pal->ncolors; ++i) {\n        Uint8 R = (Uint8) ((pal->colors[i].r * Rmod) / 255);\n        Uint8 G = (Uint8) ((pal->colors[i].g * Gmod) / 255);\n        Uint8 B = (Uint8) ((pal->colors[i].b * Bmod) / 255);\n        Uint8 A = (Uint8) ((pal->colors[i].a * Amod) / 255);\n        ASSEMBLE_RGBA(&map[i * bpp], dst->BytesPerPixel, dst, (Uint32)R, (Uint32)G, (Uint32)B, (Uint32)A);\n    }\n    return (map);\n}", "target": 1}
{"code": "int ext4_group_add(struct super_block *sb, struct ext4_new_group_data *input)\n{\n\tstruct ext4_new_flex_group_data flex_gd;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tint reserved_gdb = ext4_bg_has_super(sb, input->group) ?\n\t\tle16_to_cpu(es->s_reserved_gdt_blocks) : 0;\n\tstruct inode *inode = NULL;\n\tint gdb_off, gdb_num;\n\tint err;\n\t__u16 bg_flags = 0;\n\tgdb_num = input->group / EXT4_DESC_PER_BLOCK(sb);\n\tgdb_off = input->group % EXT4_DESC_PER_BLOCK(sb);\n\tif (gdb_off == 0 && !EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER)) {\n\t\text4_warning(sb, \"Can't resize non-sparse filesystem further\");\n\t\treturn -EPERM;\n\t}\n\tif (ext4_blocks_count(es) + input->blocks_count <\n\t    ext4_blocks_count(es)) {\n\t\text4_warning(sb, \"blocks_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\tif (le32_to_cpu(es->s_inodes_count) + EXT4_INODES_PER_GROUP(sb) <\n\t    le32_to_cpu(es->s_inodes_count)) {\n\t\text4_warning(sb, \"inodes_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\tif (reserved_gdb || gdb_off == 0) {\n\t\tif (!EXT4_HAS_COMPAT_FEATURE(sb,\n\t\t\t\t\t     EXT4_FEATURE_COMPAT_RESIZE_INODE)\n\t\t    || !le16_to_cpu(es->s_reserved_gdt_blocks)) {\n\t\t\text4_warning(sb,\n\t\t\t\t     \"No reserved GDT blocks, can't resize\");\n\t\t\treturn -EPERM;\n\t\t}\n\t\tinode = ext4_iget(sb, EXT4_RESIZE_INO);\n\t\tif (IS_ERR(inode)) {\n\t\t\text4_warning(sb, \"Error opening resize inode\");\n\t\t\treturn PTR_ERR(inode);\n\t\t}\n\t}\n\terr = verify_group_input(sb, input);\n\tif (err)\n\t\tgoto out;\n\tflex_gd.count = 1;\n\tflex_gd.groups = input;\n\tflex_gd.bg_flags = &bg_flags;\n\terr = ext4_flex_group_add(sb, inode, &flex_gd);\nout:\n\tiput(inode);\n\treturn err;\n} ", "target": 0}
{"code": "my_ulonglong STDCALL mysql_insert_id(MYSQL *mysql)\n{\n  return mysql->insert_id;\n}", "target": 0}
{"code": "callbacks_show_selection_on_invisible (GtkMenuItem *menuitem, gpointer user_data)\n{\n\tmainProject->show_invisible_selection = GTK_CHECK_MENU_ITEM(menuitem)->active;\n\trender_refresh_rendered_image_on_screen();\n}", "target": 0}
{"code": "Status CreateTempFileFloat(Env* env, float value, uint64 size,\n                           string* filename) {\n  const string dir = testing::TmpDir();\n  *filename = io::JoinPath(dir, strings::StrCat(\"file_\", value));\n  std::unique_ptr<WritableFile> file;\n  TF_RETURN_IF_ERROR(env->NewWritableFile(*filename, &file));\n  for (uint64 i = 0; i < size; ++i) {\n    StringPiece sp(static_cast<char*>(static_cast<void*>(&value)),\n                   sizeof(value));\n    TF_RETURN_IF_ERROR(file->Append(sp));\n  }\n  TF_RETURN_IF_ERROR(file->Close());\n  return Status::OK();\n}", "target": 0}
{"code": "TEST(Random, SecureFork) {\n  unsigned char buffer = 0;\n  folly::Random::secureRandom(&buffer, 1);\n  auto pid = fork();\n  EXPECT_NE(pid, -1);\n  if (pid) {\n    int status = 0;\n    folly::Random::secureRandom(&buffer, 1);\n    auto pid2 = wait(&status);\n    EXPECT_NE(WEXITSTATUS(status), buffer);\n    EXPECT_EQ(pid, pid2);\n  } else {\n    folly::Random::secureRandom(&buffer, 1);\n    exit(buffer); \n  }\n}", "target": 0}
{"code": "STACK_OF(PKCS7) *PKCS12_unpack_authsafes(const PKCS12 *p12)\n{\n    STACK_OF(PKCS7) *p7s;\n    PKCS7_CTX *p7ctx;\n    PKCS7 *p7;\n    int i;\n    if (!PKCS7_type_is_data(p12->authsafes)) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_CONTENT_TYPE_NOT_DATA);\n        return NULL;\n    }\n    if (p12->authsafes->d.data == NULL) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_DECODE_ERROR);\n        return NULL;\n    }\n    p7ctx = &p12->authsafes->ctx;\n    p7s = ASN1_item_unpack_ex(p12->authsafes->d.data,\n                              ASN1_ITEM_rptr(PKCS12_AUTHSAFES),\n                              ossl_pkcs7_ctx_get0_libctx(p7ctx),\n                              ossl_pkcs7_ctx_get0_propq(p7ctx));\n    if (p7s != NULL) {\n        for (i = 0; i < sk_PKCS7_num(p7s); i++) {\n            p7 = sk_PKCS7_value(p7s, i);\n            if (!ossl_pkcs7_ctx_propagate(p12->authsafes, p7))\n                goto err;\n        }\n    }\n    return p7s;\nerr:\n    sk_PKCS7_free(p7s);\n    return NULL;\n}", "target": 0}
{"code": "Map1to1(SDL_Palette * src, SDL_Palette * dst, int *identical)\n{\n    Uint8 *map;\n    int i;\n    if (identical) {\n        if (src->ncolors <= dst->ncolors) {\n            if (src == dst\n                ||\n                (SDL_memcmp\n                 (src->colors, dst->colors,\n                  src->ncolors * sizeof(SDL_Color)) == 0)) {\n                *identical = 1;\n                return (NULL);\n            }\n        }\n        *identical = 0;\n    }\n    map = (Uint8 *) SDL_malloc(src->ncolors);\n    if (map == NULL) {\n        SDL_OutOfMemory();\n        return (NULL);\n    }\n    for (i = 0; i < src->ncolors; ++i) {\n        map[i] = SDL_FindColor(dst,\n                               src->colors[i].r, src->colors[i].g,\n                               src->colors[i].b, src->colors[i].a);\n    }\n    return (map);\n}", "target": 1}
{"code": "static void __mcheck_cpu_clear_vendor(struct cpuinfo_x86 *c)\n{\n\tswitch (c->x86_vendor) {\n\tcase X86_VENDOR_INTEL:\n\t\tmce_intel_feature_clear(c);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "HeaderEntry* HeaderMapImpl::get(const LowerCaseString& key) {\n  for (HeaderEntryImpl& header : headers_) {\n    if (header.key() == key.get().c_str()) {\n      cached_byte_size_.reset();\n      return &header;\n    }\n  }\n  return nullptr;\n}", "target": 0}
{"code": "Network::FilterStatus Context::onNetworkNewConnection() {\n  onCreate(root_context_id_);\n  in_vm_context_created_ = true;\n  if (!wasm_->onNewConnection_) {\n    return Network::FilterStatus::Continue;\n  }\n  if (wasm_->onNewConnection_(this, id_).u64_ == 0) {\n    return Network::FilterStatus::Continue;\n  }\n  return Network::FilterStatus::StopIteration;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    Buffer* buf = nullptr;\n    OP_REQUIRES_OK(ctx, GetBuffer(ctx, def(), &buf));\n    core::ScopedUnref scope(buf);\n    Buffer::Tuple tuple;\n    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(ctx->input(0).shape()),\n                errors::InvalidArgument(\"index must be scalar\"));\n    std::size_t index = ctx->input(0).scalar<int>()();\n    OP_REQUIRES_OK(ctx, buf->Peek(index, &tuple));\n    OP_REQUIRES(\n        ctx, tuple.size() == (size_t)ctx->num_outputs(),\n        errors::InvalidArgument(\"Mismatch stage/unstage: \", tuple.size(),\n                                \" vs. \", ctx->num_outputs()));\n    for (size_t i = 0; i < tuple.size(); ++i) {\n      ctx->set_output(i, tuple[i]);\n    }\n  }", "target": 0}
{"code": "static ram_addr_t find_ram_offset(struct uc_struct *uc, ram_addr_t size)\n{\n    RAMBlock *block, *next_block;\n    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;\n    assert(size != 0); \n    if (QLIST_EMPTY(&uc->ram_list.blocks)) {\n        return 0;\n    }\n    RAMBLOCK_FOREACH(block) {\n        ram_addr_t candidate, next = RAM_ADDR_MAX;\n        candidate = block->offset + block->max_length;\n        candidate = ROUND_UP(candidate, BITS_PER_LONG << TARGET_PAGE_BITS);\n        RAMBLOCK_FOREACH(next_block) {\n            if (next_block->offset >= candidate) {\n                next = MIN(next, next_block->offset);\n            }\n        }\n        if (next - candidate >= size && next - candidate < mingap) {\n            offset = candidate;\n            mingap = next - candidate;\n        }\n    }\n    if (offset == RAM_ADDR_MAX) {\n        fprintf(stderr, \"Failed to find gap of requested size: %\" PRIu64 \"\\n\",\n                (uint64_t)size);\n        abort();\n    }\n    return offset;\n}", "target": 1}
{"code": "monitor_sync(struct monitor *pmonitor)\n{\n\tif (options.compression) {\n\t\tmm_share_sync(&pmonitor->m_zlib, &pmonitor->m_zback);\n\t}\n}", "target": 1}
{"code": "static int netlbl_cipsov4_add_common(struct genl_info *info,\n\t\t\t\t     struct cipso_v4_doi *doi_def)\n{\n\tstruct nlattr *nla;\n\tint nla_rem;\n\tu32 iter = 0;\n\tdoi_def->doi = nla_get_u32(info->attrs[NLBL_CIPSOV4_A_DOI]);\n\tif (nla_validate_nested(info->attrs[NLBL_CIPSOV4_A_TAGLST],\n\t\t\t\tNLBL_CIPSOV4_A_MAX,\n\t\t\t\tnetlbl_cipsov4_genl_policy) != 0)\n\t\treturn -EINVAL;\n\tnla_for_each_nested(nla, info->attrs[NLBL_CIPSOV4_A_TAGLST], nla_rem)\n\t\tif (nla->nla_type == NLBL_CIPSOV4_A_TAG) {\n\t\t\tif (iter > CIPSO_V4_TAG_MAXCNT)\n\t\t\t\treturn -EINVAL;\n\t\t\tdoi_def->tags[iter++] = nla_get_u8(nla);\n\t\t}\n\tif (iter < CIPSO_V4_TAG_MAXCNT)\n\t\tdoi_def->tags[iter] = CIPSO_V4_TAG_INVALID;\n\treturn 0;\n}", "target": 1}
{"code": "    void StackMsg::appendLine( char *szLine, bool complete ) {\n        if( complete ) {\n            m_os.flush() ;\n            m_sipMessage = m_os.str() ;\n            m_sipMessage.resize( m_sipMessage.length() - 1) ;\n            boost::replace_all(m_sipMessage, \"\\n\", DR_CRLF);\n        }\n        else if( 0 == strcmp(szLine, \"\\n\") ) {\n            m_os << endl ;\n        }\n        else {\n            int i = 0 ;\n            while( ' ' == szLine[i] && '\\0' != szLine[i]) i++ ;\n            m_os << ( szLine + i ) ;\n        }\n    }", "target": 1}
{"code": "static void ossl_associate_connection(struct Curl_easy *data,\n                                      struct connectdata *conn,\n                                      int sockindex)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  if(!backend->handle)\n    return;\n  if(SSL_SET_OPTION(primary.sessionid)) {\n    int data_idx = ossl_get_ssl_data_index();\n    int connectdata_idx = ossl_get_ssl_conn_index();\n    int sockindex_idx = ossl_get_ssl_sockindex_index();\n    int proxy_idx = ossl_get_proxy_index();\n    if(data_idx >= 0 && connectdata_idx >= 0 && sockindex_idx >= 0 &&\n       proxy_idx >= 0) {\n      SSL_set_ex_data(backend->handle, data_idx, data);\n      SSL_set_ex_data(backend->handle, connectdata_idx, conn);\n      SSL_set_ex_data(backend->handle, sockindex_idx, conn->sock + sockindex);\n#ifndef CURL_DISABLE_PROXY\n      SSL_set_ex_data(backend->handle, proxy_idx, SSL_IS_PROXY() ? (void *) 1:\n                      NULL);\n#else\n      SSL_set_ex_data(backend->handle, proxy_idx, NULL);\n#endif\n    }\n  }\n}", "target": 0}
{"code": "unset_nonblock(int fd)\n{\n\tint val;\n\tval = fcntl(fd, F_GETFL);\n\tif (val == -1) {\n\t\terror(\"fcntl(%d, F_GETFL): %s\", fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\tif (!(val & O_NONBLOCK)) {\n\t\tdebug3(\"fd %d is not O_NONBLOCK\", fd);\n\t\treturn (0);\n\t}\n\tdebug(\"fd %d clearing O_NONBLOCK\", fd);\n\tval &= ~O_NONBLOCK;\n\tif (fcntl(fd, F_SETFL, val) == -1) {\n\t\tdebug(\"fcntl(%d, F_SETFL, ~O_NONBLOCK): %s\",\n\t\t    fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}", "target": 0}
{"code": "static int __copy_insn(struct address_space *mapping, struct file *filp,\n\t\t\tvoid *insn, int nbytes, loff_t offset)\n{\n\tstruct page *page;\n\tif (mapping->a_ops->readpage)\n\t\tpage = read_mapping_page(mapping, offset >> PAGE_SHIFT, filp);\n\telse\n\t\tpage = shmem_read_mapping_page(mapping, offset >> PAGE_SHIFT);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\tcopy_from_page(page, offset, insn, nbytes);\n\tput_page(page);\n\treturn 0;\n}", "target": 0}
{"code": "void CtcpParser::query(CoreNetwork *net, const QString &bufname, const QString &ctcpTag, const QString &message)\n{\n    QList<QByteArray> params;\n    params << net->serverEncode(bufname) << lowLevelQuote(pack(net->serverEncode(ctcpTag), net->userEncode(bufname, message)));\n    static const char *splitter = \" .,-!?\";\n    int maxSplitPos = message.count();\n    int splitPos = maxSplitPos;\n    int overrun = net->userInputHandler()->lastParamOverrun(\"PRIVMSG\", params);\n    if (overrun) {\n        maxSplitPos = message.count() - overrun -2;\n        splitPos = -1;\n        for (const char *splitChar = splitter; *splitChar != 0; splitChar++) {\n            splitPos = qMax(splitPos, message.lastIndexOf(*splitChar, maxSplitPos) + 1); \n        }\n        if (splitPos <= 0 || splitPos > maxSplitPos)\n            splitPos = maxSplitPos;\n        params = params.mid(0, 1) <<  lowLevelQuote(pack(net->serverEncode(ctcpTag), net->userEncode(bufname, message.left(splitPos))));\n    }\n    net->putCmd(\"PRIVMSG\", params);\n    if (splitPos < message.count())\n        query(net, bufname, ctcpTag, message.mid(splitPos));\n}", "target": 1}
{"code": "  Status ArgSortByRows(OpKernelContext* context, const GPUDevice& device,\n                       Tindex N, int rank, Tindex dense_rows,\n                       typename TTypes<Tindex>::ConstMatrix indices,\n                       Tensor* input_index_map_t) {\n    DataType index_type = DataTypeToEnum<Tindex>::value;\n    Tensor row_indices_t;\n    TF_RETURN_IF_ERROR(\n        context->allocate_temp(index_type, TensorShape({N}), &row_indices_t));\n    auto row_indices = row_indices_t.flat<Tindex>();\n    TF_RETURN_IF_ERROR(wrap_kernel_call(CopyRowIndicesKernel<Tindex>,\n                                        device, N, rank,\n                                        indices, row_indices));\n    TF_RETURN_IF_ERROR(context->allocate_temp(index_type, TensorShape({N}),\n                                              input_index_map_t));\n    Tindex* input_index_map = input_index_map_t->flat<Tindex>().data();\n    return GpuRadixSort(context, N, row_indices.data(),\n                        static_cast<Tindex*>(nullptr),\n                        static_cast<Tindex*>(nullptr),\n                        input_index_map,\n                        Log2Ceiling64(dense_rows));\n  }", "target": 1}
{"code": "static int ion_handle_put(struct ion_handle *handle)\n{\n\tstruct ion_client *client = handle->client;\n\tint ret;\n\tmutex_lock(&client->lock);\n\tret = kref_put(&handle->ref, ion_handle_destroy);\n\tmutex_unlock(&client->lock);\n\treturn ret;\n}", "target": 1}
{"code": "CharString *Formattable::internalGetCharString(UErrorCode &status) {\n    if(fDecimalStr == NULL) {\n      if (fDecimalQuantity == NULL) {\n        LocalPointer<DecimalQuantity> dq(new DecimalQuantity(), status);\n        if (U_FAILURE(status)) { return nullptr; }\n        populateDecimalQuantity(*dq, status);\n        if (U_FAILURE(status)) { return nullptr; }\n        fDecimalQuantity = dq.orphan();\n      }\n      fDecimalStr = new CharString();\n      if (fDecimalStr == NULL) {\n        status = U_MEMORY_ALLOCATION_ERROR;\n        return NULL;\n      }\n      if (fDecimalQuantity->isZero()) {\n        fDecimalStr->append(\"0\", -1, status);\n      } else if (std::abs(fDecimalQuantity->getMagnitude()) < 5) {\n        fDecimalStr->appendInvariantChars(fDecimalQuantity->toPlainString(), status);\n      } else {\n        fDecimalStr->appendInvariantChars(fDecimalQuantity->toScientificString(), status);\n      }\n    }\n    return fDecimalStr;\n}", "target": 1}
{"code": "bool ecdsa_verify_legacy(const ecdsa_verify_context_t *ctx, const ecc_25519_work_t *pubkey) {\n  ecc_25519_work_t s2, work;\n  ecc_int256_t w, tmp;\n  if (ecc_25519_gf_is_zero(&ctx->r))\n    return false;\n  ecc_25519_scalarmult(&s2, &ctx->u2, pubkey);\n  ecc_25519_add(&work, &ctx->s1, &s2);\n  ecc_25519_store_xy_legacy(&w, NULL, &work);\n  ecc_25519_gf_sub(&tmp, &ctx->r, &w);\n  return ecc_25519_gf_is_zero(&tmp);\n}", "target": 0}
{"code": "ext4_xattr_cache_find(struct inode *inode, struct ext4_xattr_header *header,\n\t\t      struct mb_cache_entry **pce)\n{\n\t__u32 hash = le32_to_cpu(header->h_hash);\n\tstruct mb_cache_entry *ce;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\tif (!header->h_hash)\n\t\treturn NULL;  \n\tea_idebug(inode, \"looking for cached blocks [%x]\", (int)hash);\nagain:\n\tce = mb_cache_entry_find_first(ext4_mb_cache, inode->i_sb->s_bdev,\n\t\t\t\t       hash);\n\twhile (ce) {\n\t\tstruct buffer_head *bh;\n\t\tif (IS_ERR(ce)) {\n\t\t\tif (PTR_ERR(ce) == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tbreak;\n\t\t}\n\t\tbh = sb_bread(inode->i_sb, ce->e_block);\n\t\tif (!bh) {\n\t\t\tEXT4_ERROR_INODE(inode, \"block %lu read error\",\n\t\t\t\t\t (unsigned long) ce->e_block);\n\t\t} else if (le32_to_cpu(BHDR(bh)->h_refcount) >=\n\t\t\t\tEXT4_XATTR_REFCOUNT_MAX) {\n\t\t\tea_idebug(inode, \"block %lu refcount %d>=%d\",\n\t\t\t\t  (unsigned long) ce->e_block,\n\t\t\t\t  le32_to_cpu(BHDR(bh)->h_refcount),\n\t\t\t\t\t  EXT4_XATTR_REFCOUNT_MAX);\n\t\t} else if (ext4_xattr_cmp(header, BHDR(bh)) == 0) {\n\t\t\t*pce = ce;\n\t\t\treturn bh;\n\t\t}\n\t\tbrelse(bh);\n\t\tce = mb_cache_entry_find_next(ce, inode->i_sb->s_bdev, hash);\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "static void lwp_write(FILE *fout, const std::string &buf) {\n  size_t len = buf.length();\n  fwrite(&len, sizeof(len), 1, fout);\n  fwrite(buf.c_str(), sizeof(buf[0]), len, fout);\n  fflush(fout);\n}", "target": 0}
{"code": "int ieee80211_radiotap_iterator_init(\n\tstruct ieee80211_radiotap_iterator *iterator,\n\tstruct ieee80211_radiotap_header *radiotap_header,\n\tint max_length, const struct ieee80211_radiotap_vendor_namespaces *vns)\n{\n\tif (radiotap_header->it_version)\n\t\treturn -EINVAL;\n\tif (max_length < get_unaligned_le16(&radiotap_header->it_len))\n\t\treturn -EINVAL;\n\titerator->_rtheader = radiotap_header;\n\titerator->_max_length = get_unaligned_le16(&radiotap_header->it_len);\n\titerator->_arg_index = 0;\n\titerator->_bitmap_shifter = get_unaligned_le32(&radiotap_header->it_present);\n\titerator->_arg = (uint8_t *)radiotap_header + sizeof(*radiotap_header);\n\titerator->_reset_on_ext = 0;\n\titerator->_next_bitmap = &radiotap_header->it_present;\n\titerator->_next_bitmap++;\n\titerator->_vns = vns;\n\titerator->current_namespace = &radiotap_ns;\n\titerator->is_radiotap_ns = 1;\n\tif (iterator->_bitmap_shifter & (1<<IEEE80211_RADIOTAP_EXT)) {\n\t\twhile (get_unaligned_le32(iterator->_arg) &\n\t\t\t\t\t(1 << IEEE80211_RADIOTAP_EXT)) {\n\t\t\titerator->_arg += sizeof(uint32_t);\n\t\t\tif ((unsigned long)iterator->_arg -\n\t\t\t    (unsigned long)iterator->_rtheader >\n\t\t\t    (unsigned long)iterator->_max_length)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\titerator->_arg += sizeof(uint32_t);\n\t}\n\titerator->this_arg = iterator->_arg;\n\treturn 0;\n}", "target": 1}
{"code": "gbk_mbc_case_fold(OnigCaseFoldType flag, const UChar** pp, const UChar* end,\n                    UChar* lower, OnigEncoding enc)\n{\n  return onigenc_mbn_mbc_case_fold(enc, flag,\n                                   pp, end, lower);\n}", "target": 0}
{"code": "static void ep_nested_calls_init(struct nested_calls *ncalls)\n{\n\tINIT_LIST_HEAD(&ncalls->tasks_call_list);\n\tspin_lock_init(&ncalls->lock);\n}", "target": 0}
{"code": "void QuantizeMultiplier(double double_multiplier, int32_t* quantized_multiplier,\n                        int* left_shift) {\n  if (double_multiplier < 1.0) {\n    QuantizeMultiplierSmallerThanOneExp(double_multiplier, quantized_multiplier,\n                                        left_shift);\n  } else {\n    QuantizeMultiplierGreaterThanOne(double_multiplier, quantized_multiplier,\n                                     left_shift);\n  }\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* const context) override {\n    core::RefCountPtr<BoostedTreesEnsembleResource> resource;\n    OP_REQUIRES_OK(context, LookupResource(context, HandleFromInput(context, 0),\n                                           &resource));\n    OpInputList bucketized_features_list;\n    OP_REQUIRES_OK(context, context->input_list(\"bucketized_features\",\n                                                &bucketized_features_list));\n    std::vector<tensorflow::TTypes<int32>::ConstMatrix> bucketized_features;\n    bucketized_features.reserve(bucketized_features_list.size());\n    ConvertVectorsToMatrices(bucketized_features_list, bucketized_features);\n    const int batch_size = bucketized_features[0].dimension(0);\n    Tensor* output_logits_t = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                \"logits\", {batch_size, logits_dimension_},\n                                &output_logits_t));\n    auto output_logits = output_logits_t->matrix<float>();\n    if (resource->num_trees() <= 0) {\n      output_logits.setZero();\n      return;\n    }\n    const int32 last_tree = resource->num_trees() - 1;\n    auto do_work = [&resource, &bucketized_features, &output_logits, last_tree,\n                    this](int32 start, int32 end) {\n      for (int32 i = start; i < end; ++i) {\n        std::vector<float> tree_logits(logits_dimension_, 0.0);\n        int32 tree_id = 0;\n        int32 node_id = 0;\n        while (true) {\n          if (resource->is_leaf(tree_id, node_id)) {\n            const float tree_weight = resource->GetTreeWeight(tree_id);\n            const auto& leaf_logits = resource->node_value(tree_id, node_id);\n            DCHECK_EQ(leaf_logits.size(), logits_dimension_);\n            for (int32 j = 0; j < logits_dimension_; ++j) {\n              tree_logits[j] += tree_weight * leaf_logits[j];\n            }\n            if (tree_id == last_tree) {\n              break;\n            }\n            ++tree_id;\n            node_id = 0;\n          } else {\n            node_id =\n                resource->next_node(tree_id, node_id, i, bucketized_features);\n          }\n        }\n        for (int32 j = 0; j < logits_dimension_; ++j) {\n          output_logits(i, j) = tree_logits[j];\n        }\n      }\n    };\n    const int64 cost = (last_tree + 1) * 10;\n    thread::ThreadPool* const worker_threads =\n        context->device()->tensorflow_cpu_worker_threads()->workers;\n    Shard(worker_threads->NumThreads(), worker_threads, batch_size,\n          cost, do_work);\n  }", "target": 1}
{"code": "static x86newTokenType getToken(const char *str, size_t *begin, size_t *end) {\n\twhile (begin && isspace ((ut8)str[*begin])) {\n\t\t++(*begin);\n\t}\n\tif (!str[*begin]) {                \n\t\t*end = *begin;\n\t\treturn TT_EOF;\n\t} else if (isalpha ((ut8)str[*begin])) {   \n\t\t*end = *begin;\n\t\twhile (end && isalnum ((ut8)str[*end])) {\n\t\t\t++(*end);\n\t\t}\n\t\treturn TT_WORD;\n\t} else if (isdigit ((ut8)str[*begin])) {   \n\t\t*end = *begin;\n\t\twhile (end && isalnum ((ut8)str[*end])) {     \n\t\t\t++(*end);\n\t\t}\n\t\treturn TT_NUMBER;\n\t} else {                             \n\t\t*end = *begin + 1;\n\t\treturn TT_SPECIAL;\n\t}\n}", "target": 1}
{"code": "lt_dlgetinfo (lt_dlhandle handle)\n{\n  if (!handle)\n    {\n      LT__SETERROR (INVALID_HANDLE);\n      return 0;\n    }\n  return &(handle->info);\n}", "target": 0}
{"code": "header_put_be_short (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 2)\n\t{\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = x ;\n\t\t} ;\n} ", "target": 1}
{"code": "set_lenIV(const char* line)\n{\n  char *p = strstr(line, \"/lenIV \");\n  if (p && (isdigit((unsigned char) p[7]) || p[7] == '+' || p[7] == '-')) {\n    lenIV = atoi(p + 7);\n  }\n}", "target": 0}
{"code": "int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,\n                   const char *dir) {\n  char offset[40] = \"\", name[200] = \"\", path[256];\n  mg_http_get_var(&hm->query, \"offset\", offset, sizeof(offset));\n  mg_http_get_var(&hm->query, \"name\", name, sizeof(name));\n  if (name[0] == '\\0') {\n    mg_http_reply(c, 400, \"\", \"%s\", \"name required\");\n    return -1;\n  } else {\n    FILE *fp;\n    size_t oft = strtoul(offset, NULL, 0);\n    snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);\n    LOG(LL_DEBUG,\n        (\"%p %d bytes @ %d [%s]\", c->fd, (int) hm->body.len, (int) oft, name));\n    if ((fp = fopen(path, oft == 0 ? \"wb\" : \"ab\")) == NULL) {\n      mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", name, errno);\n      return -2;\n    } else {\n      fwrite(hm->body.ptr, 1, hm->body.len, fp);\n      fclose(fp);\n      mg_http_reply(c, 200, \"\", \"\");\n      return (int) hm->body.len;\n    }\n  }\n}", "target": 1}
{"code": "static int handle_pte_fault(struct mm_struct *mm,\n\t\t     struct vm_area_struct *vma, unsigned long address,\n\t\t     pte_t *pte, pmd_t *pmd, unsigned int flags)\n{\n\tpte_t entry;\n\tspinlock_t *ptl;\n\tentry = *pte;\n\tbarrier();\n\tif (!pte_present(entry)) {\n\t\tif (pte_none(entry)) {\n\t\t\tif (vma->vm_ops) {\n\t\t\t\tif (likely(vma->vm_ops->fault))\n\t\t\t\t\treturn do_fault(mm, vma, address, pte,\n\t\t\t\t\t\t\tpmd, flags, entry);\n\t\t\t}\n\t\t\treturn do_anonymous_page(mm, vma, address,\n\t\t\t\t\t\t pte, pmd, flags);\n\t\t}\n\t\treturn do_swap_page(mm, vma, address,\n\t\t\t\t\tpte, pmd, flags, entry);\n\t}\n\tif (pte_protnone(entry))\n\t\treturn do_numa_page(mm, vma, address, entry, pte, pmd);\n\tptl = pte_lockptr(mm, pmd);\n\tspin_lock(ptl);\n\tif (unlikely(!pte_same(*pte, entry)))\n\t\tgoto unlock;\n\tif (flags & FAULT_FLAG_WRITE) {\n\t\tif (!pte_write(entry))\n\t\t\treturn do_wp_page(mm, vma, address,\n\t\t\t\t\tpte, pmd, ptl, entry);\n\t\tentry = pte_mkdirty(entry);\n\t}\n\tentry = pte_mkyoung(entry);\n\tif (ptep_set_access_flags(vma, address, pte, entry, flags & FAULT_FLAG_WRITE)) {\n\t\tupdate_mmu_cache(vma, address, pte);\n\t} else {\n\t\tif (flags & FAULT_FLAG_WRITE)\n\t\t\tflush_tlb_fix_spurious_fault(vma, address);\n\t}\nunlock:\n\tpte_unmap_unlock(pte, ptl);\n\treturn 0;\n}", "target": 1}
{"code": "mainloop_destroy_trigger(crm_trigger_t * source)\n{\n    source->trigger = FALSE;\n    if (source->id > 0) {\n        g_source_remove(source->id);\n        source->id = 0;\n    }\n    return TRUE;\n}", "target": 0}
{"code": "        CFontFileBase(char *sFile, int nLen, bool bFreeFileData)\n        {\n            m_sFileData = m_sFile = (unsigned char *)sFile;\n            m_nLen = nLen;\n            m_bFreeFileData = bFreeFileData;\n            m_nPos = 0;\n        }", "target": 1}
{"code": "static void __xen_evtchn_do_upcall(void)\n{\n\tstruct vcpu_info *vcpu_info = __this_cpu_read(xen_vcpu);\n\tint cpu = smp_processor_id();\n\tread_lock(&evtchn_rwlock);\n\tdo {\n\t\tvcpu_info->evtchn_upcall_pending = 0;\n\t\txen_evtchn_handle_events(cpu);\n\t\tBUG_ON(!irqs_disabled());\n\t\tvirt_rmb(); \n\t} while (vcpu_info->evtchn_upcall_pending);\n\tread_unlock(&evtchn_rwlock);\n}", "target": 0}
{"code": "\t__releases(&keyring_serialise_link_sem)\n{\n\tBUG_ON(index_key->type == NULL);\n\tkenter(\"%d,%s,\", keyring->serial, index_key->type->name);\n\tif (index_key->type == &key_type_keyring)\n\t\tup_write(&keyring_serialise_link_sem);\n\tif (edit && !edit->dead_leaf) {\n\t\tkey_payload_reserve(keyring,\n\t\t\t\t    keyring->datalen - KEYQUOTA_LINK_BYTES);\n\t\tassoc_array_cancel_edit(edit);\n\t}\n\tup_write(&keyring->sem);\n}", "target": 1}
{"code": "void msetGenericCommand(client *c, int nx) {\n    int j;\n    int setkey_flags = 0;\n    if ((c->argc % 2) == 0) {\n        addReplyErrorArity(c);\n        return;\n    }\n    if (nx) {\n        for (j = 1; j < c->argc; j += 2) {\n            if (lookupKeyWrite(c->db,c->argv[j]) != NULL) {\n                addReply(c, shared.czero);\n                return;\n            }\n        }\n        setkey_flags |= SETKEY_DOESNT_EXIST;\n    }\n    for (j = 1; j < c->argc; j += 2) {\n        c->argv[j+1] = tryObjectEncoding(c->argv[j+1]);\n        setKey(c, c->db, c->argv[j], c->argv[j + 1], setkey_flags);\n        notifyKeyspaceEvent(NOTIFY_STRING,\"set\",c->argv[j],c->db->id);\n    }\n    server.dirty += (c->argc-1)/2;\n    addReply(c, nx ? shared.cone : shared.ok);\n}", "target": 1}
{"code": "static int rm_read_multi(AVFormatContext *s, AVIOContext *pb,\n                         AVStream *st, char *mime)\n{\n    int number_of_streams = avio_rb16(pb);\n    int number_of_mdpr;\n    int i, ret;\n    unsigned size2;\n    for (i = 0; i<number_of_streams; i++)\n        avio_rb16(pb);\n    number_of_mdpr = avio_rb16(pb);\n    if (number_of_mdpr != 1) {\n        avpriv_request_sample(s, \"MLTI with multiple (%d) MDPR\", number_of_mdpr);\n    }\n    for (i = 0; i < number_of_mdpr; i++) {\n        AVStream *st2;\n        if (i > 0) {\n            st2 = avformat_new_stream(s, NULL);\n            if (!st2) {\n                ret = AVERROR(ENOMEM);\n                return ret;\n            }\n            st2->id = st->id + (i<<16);\n            st2->codecpar->bit_rate = st->codecpar->bit_rate;\n            st2->start_time = st->start_time;\n            st2->duration   = st->duration;\n            st2->codecpar->codec_type = AVMEDIA_TYPE_DATA;\n            st2->priv_data = ff_rm_alloc_rmstream();\n            if (!st2->priv_data)\n                return AVERROR(ENOMEM);\n        } else\n            st2 = st;\n        size2 = avio_rb32(pb);\n        ret = ff_rm_read_mdpr_codecdata(s, s->pb, st2, st2->priv_data,\n                                        size2, mime);\n        if (ret < 0)\n            return ret;\n    }\n    return 0;\n}", "target": 1}
{"code": "void test_truncate(const char *path)\n{\n\tif (truncate(path, 0) == 0) {\n\t\tfprintf(stderr, \"leak at truncate of %s\\n\", path);\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "static int atusb_read_reg(struct atusb *atusb, uint8_t reg)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tint ret;\n\tuint8_t value;\n\tdev_dbg(&usb_dev->dev, \"atusb: reg = 0x%x\\n\", reg);\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_REG_READ, ATUSB_REQ_FROM_DEV,\n\t\t\t\t0, reg, &value, 1, 1000);\n\treturn ret >= 0 ? value : ret;\n}", "target": 1}
{"code": "TfLiteStatus StoreAllDecodedSequences(\n    TfLiteContext* context,\n    const std::vector<std::vector<std::vector<int>>>& sequences,\n    TfLiteNode* node, int top_paths) {\n  const int32_t batch_size = sequences.size();\n  std::vector<int32_t> num_entries(top_paths, 0);\n  for (const auto& batch_s : sequences) {\n    TF_LITE_ENSURE_EQ(context, batch_s.size(), top_paths);\n    for (int p = 0; p < top_paths; ++p) {\n      num_entries[p] += batch_s[p].size();\n    }\n  }\n  for (int p = 0; p < top_paths; ++p) {\n    const int32_t p_num = num_entries[p];\n    TfLiteTensor* indices = GetOutput(context, node, p);\n    TF_LITE_ENSURE_OK(context, Resize(context, {p_num, 2}, indices));\n    TfLiteTensor* values = GetOutput(context, node, p + top_paths);\n    TF_LITE_ENSURE_OK(context, Resize(context, {p_num}, values));\n    TfLiteTensor* decoded_shape = GetOutput(context, node, p + 2 * top_paths);\n    TF_LITE_ENSURE_OK(context, Resize(context, {2}, decoded_shape));\n    int32_t max_decoded = 0;\n    int32_t offset = 0;\n    int32_t* indices_data = GetTensorData<int32_t>(indices);\n    int32_t* values_data = GetTensorData<int32_t>(values);\n    int32_t* decoded_shape_data = GetTensorData<int32_t>(decoded_shape);\n    for (int b = 0; b < batch_size; ++b) {\n      auto& p_batch = sequences[b][p];\n      int32_t num_decoded = p_batch.size();\n      max_decoded = std::max(max_decoded, num_decoded);\n      std::copy_n(p_batch.begin(), num_decoded, values_data + offset);\n      for (int32_t t = 0; t < num_decoded; ++t, ++offset) {\n        indices_data[offset * 2] = b;\n        indices_data[offset * 2 + 1] = t;\n      }\n    }\n    decoded_shape_data[0] = batch_size;\n    decoded_shape_data[1] = max_decoded;\n  }\n  return kTfLiteOk;\n}", "target": 1}
{"code": "qedi_dbg_err(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t     const char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\tchar nfunc[32];\n\tmemset(nfunc, 0, sizeof(nfunc));\n\tmemcpy(nfunc, func, sizeof(nfunc) - 1);\n\tva_start(va, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_err(\"[%s]:[%s:%d]:%d: %pV\", dev_name(&qedi->pdev->dev),\n\t\t       nfunc, line, qedi->host_no, &vaf);\n\telse\n\t\tpr_err(\"[0000:00:00.0]:[%s:%d]: %pV\", nfunc, line, &vaf);\n\tva_end(va);\n}", "target": 1}
{"code": "void Curl_attach_connnection(struct Curl_easy *data,\n                             struct connectdata *conn)\n{\n  DEBUGASSERT(!data->conn);\n  DEBUGASSERT(conn);\n  data->conn = conn;\n  Curl_llist_insert_next(&conn->easyq, conn->easyq.tail, data,\n                         &data->conn_queue);\n  if(conn->handler->attach)\n    conn->handler->attach(data, conn);\n  Curl_ssl_associate_conn(data, conn);\n}", "target": 0}
{"code": "static uint32_t dp8393x_crda(dp8393xState *s)\n{\n    return (s->regs[SONIC_URDA] << 16) |\n           (s->regs[SONIC_CRDA] & SONIC_DESC_ADDR);\n}", "target": 0}
{"code": "void ServerSecurityFeature::collectOptions(std::shared_ptr<ProgramOptions> options) {\n  options->addOption(\"--server.harden\",\n                     \"lock down REST APIs that reveal version information or server \"\n                     \"internals for non-admin users\",\n                     new BooleanParameter(&_hardenedRestApi))\n                     .setIntroducedIn(30500);\n  options->addOption(\"--foxx.api\", \"enables Foxx management REST APIs\",\n                     new BooleanParameter(&_enableFoxxApi),\n                     arangodb::options::makeFlags(\n                     arangodb::options::Flags::DefaultNoComponents,\n                     arangodb::options::Flags::OnCoordinator,\n                     arangodb::options::Flags::OnSingle))\n                     .setIntroducedIn(30500);\n  options->addOption(\"--foxx.store\", \"enables Foxx store in web interface\",\n                     new BooleanParameter(&_enableFoxxStore),\n                     arangodb::options::makeFlags(\n                     arangodb::options::Flags::DefaultNoComponents,\n                     arangodb::options::Flags::OnCoordinator,\n                     arangodb::options::Flags::OnSingle))\n                     .setIntroducedIn(30500);\n}", "target": 1}
{"code": "njs_promise_perform_race_handler(njs_vm_t *vm, njs_iterator_args_t *args,\n    njs_value_t *value, int64_t index)\n{\n    njs_int_t                    ret;\n    njs_value_t                  arguments[2], next;\n    njs_promise_capability_t     *capability;\n    njs_promise_iterator_args_t  *pargs;\n    if (!njs_is_valid(value)) {\n        value = njs_value_arg(&njs_value_undefined);\n    }\n    pargs = (njs_promise_iterator_args_t *) args;\n    ret = njs_function_call(vm, pargs->function, pargs->constructor, value,\n                            1, &next);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n    capability = pargs->capability;\n    arguments[0] = capability->resolve;\n    arguments[1] = capability->reject;\n    (void) njs_promise_invoke_then(vm, &next, arguments, 2);\n    return NJS_OK;\n}", "target": 0}
{"code": "ScopedDefaultGLContext::ScopedDefaultGLContext(GLES2DecoderImpl* decoder)\n    : decoder_(decoder) {\n  decoder_->default_context_->MakeCurrent();\n}", "target": 0}
{"code": "static int rndis_set_response(struct rndis_params *params,\n\t\t\t      rndis_set_msg_type *buf)\n{\n\tu32 BufLength, BufOffset;\n\trndis_set_cmplt_type *resp;\n\trndis_resp_t *r;\n\tr = rndis_add_response(params, sizeof(rndis_set_cmplt_type));\n\tif (!r)\n\t\treturn -ENOMEM;\n\tresp = (rndis_set_cmplt_type *)r->buf;\n\tBufLength = le32_to_cpu(buf->InformationBufferLength);\n\tBufOffset = le32_to_cpu(buf->InformationBufferOffset);\n#ifdef\tVERBOSE_DEBUG\n\tpr_debug(\"%s: Length: %d\\n\", __func__, BufLength);\n\tpr_debug(\"%s: Offset: %d\\n\", __func__, BufOffset);\n\tpr_debug(\"%s: InfoBuffer: \", __func__);\n\tfor (i = 0; i < BufLength; i++) {\n\t\tpr_debug(\"%02x \", *(((u8 *) buf) + i + 8 + BufOffset));\n\t}\n\tpr_debug(\"\\n\");\n#endif\n\tresp->MessageType = cpu_to_le32(RNDIS_MSG_SET_C);\n\tresp->MessageLength = cpu_to_le32(16);\n\tresp->RequestID = buf->RequestID; \n\tif (gen_ndis_set_resp(params, le32_to_cpu(buf->OID),\n\t\t\t((u8 *)buf) + 8 + BufOffset, BufLength, r))\n\t\tresp->Status = cpu_to_le32(RNDIS_STATUS_NOT_SUPPORTED);\n\telse\n\t\tresp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);\n\tparams->resp_avail(params->v);\n\treturn 0;\n}", "target": 1}
{"code": "void irsock_cleanup(void)\n{\n\tsock_unregister(PF_IRDA);\n\tproto_unregister(&irda_proto);\n}", "target": 0}
{"code": "Status BuildXlaCompilationCache(DeviceBase* device, FunctionLibraryRuntime* flr,\n                                const XlaPlatformInfo& platform_info,\n                                XlaCompilationCache** cache) {\n  if (platform_info.xla_device_metadata()) {\n    *cache = new XlaCompilationCache(\n        platform_info.xla_device_metadata()->client(),\n        platform_info.xla_device_metadata()->jit_device_type());\n    return Status::OK();\n  }\n  auto platform =\n      se::MultiPlatformManager::PlatformWithId(platform_info.platform_id());\n  if (!platform.ok()) {\n    return platform.status();\n  }\n  StatusOr<xla::Compiler*> compiler_for_platform =\n      xla::Compiler::GetForPlatform(platform.ValueOrDie());\n  if (!compiler_for_platform.ok()) {\n    const Status& status = compiler_for_platform.status();\n    if (status.code() == error::NOT_FOUND) {\n      return errors::Unimplemented(\"Could not find compiler for platform \",\n                                   platform.ValueOrDie()->Name(), \": \",\n                                   status.ToString());\n    }\n  }\n  xla::LocalClientOptions client_options;\n  client_options.set_platform(platform.ValueOrDie());\n  client_options.set_intra_op_parallelism_threads(\n      device->tensorflow_cpu_worker_threads()->num_threads);\n  string allowed_gpus =\n      flr->config_proto()->gpu_options().visible_device_list();\n  TF_ASSIGN_OR_RETURN(absl::optional<std::set<int>> gpu_ids,\n                      ParseVisibleDeviceList(allowed_gpus));\n  client_options.set_allowed_devices(gpu_ids);\n  auto client = xla::ClientLibrary::GetOrCreateLocalClient(client_options);\n  if (!client.ok()) {\n    return client.status();\n  }\n  const XlaOpRegistry::DeviceRegistration* registration;\n  if (!XlaOpRegistry::GetCompilationDevice(platform_info.device_type().type(),\n                                           &registration)) {\n    return errors::InvalidArgument(\"No JIT device registered for \",\n                                   platform_info.device_type().type());\n  }\n  *cache = new XlaCompilationCache(\n      client.ValueOrDie(), DeviceType(registration->compilation_device_name));\n  return Status::OK();\n}", "target": 1}
{"code": "static void nfs4_open_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\tstruct nfs4_state_owner *sp = data->owner;\n\tif (nfs_wait_on_sequence(data->o_arg.seqid, task) != 0)\n\t\treturn;\n\tif (data->state != NULL) {\n\t\tstruct nfs_delegation *delegation;\n\t\tif (can_open_cached(data->state, data->o_arg.open_flags & (FMODE_READ|FMODE_WRITE|O_EXCL)))\n\t\t\tgoto out_no_action;\n\t\trcu_read_lock();\n\t\tdelegation = rcu_dereference(NFS_I(data->state->inode)->delegation);\n\t\tif (delegation != NULL &&\n\t\t    test_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags) == 0) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto out_no_action;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\tdata->o_arg.id = sp->so_owner_id.id;\n\tdata->o_arg.clientid = sp->so_client->cl_clientid;\n\tif (data->o_arg.claim == NFS4_OPEN_CLAIM_PREVIOUS) {\n\t\ttask->tk_msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_NOATTR];\n\t\tnfs_copy_fh(&data->o_res.fh, data->o_arg.fh);\n\t}\n\tdata->timestamp = jiffies;\n\trpc_call_start(task);\n\treturn;\nout_no_action:\n\ttask->tk_action = NULL;\n}", "target": 1}
{"code": "int infra_ip_ratelimit_inc(struct infra_cache* infra,\n\tstruct sockaddr_storage* addr, socklen_t addrlen, time_t timenow,\n\tint has_cookie, int backoff, struct sldns_buffer* buffer)\n{\n\tint max;\n\tstruct lruhash_entry* entry;\n\tif(!infra_ip_ratelimit) {\n\t\treturn 1;\n\t}\n\tentry = infra_find_ip_ratedata(infra, addr, addrlen, 1);\n\tif(entry) {\n\t\tint premax = infra_rate_max(entry->data, timenow, backoff);\n\t\tint* cur = infra_rate_give_second(entry->data, timenow);\n\t\t(*cur)++;\n\t\tmax = infra_rate_max(entry->data, timenow, backoff);\n\t\tlock_rw_unlock(&entry->lock);\n\t\treturn check_ip_ratelimit(addr, addrlen, buffer, premax, max,\n\t\t\thas_cookie);\n\t}\n\tinfra_ip_create_ratedata(infra, addr, addrlen, timenow);\n\treturn 1;\n}", "target": 1}
{"code": "void RenderViewTest::SendWebGestureEvent(\n    const blink::WebGestureEvent& gesture_event) {\n  SendInputEvent(gesture_event);\n}", "target": 0}
{"code": "ZEND_API int ZEND_FASTCALL shift_left_function(zval *result, zval *op1, zval *op2) \n{\n\tzend_long op1_lval, op2_lval;\n\tconvert_op1_op2_long(op1, op1_lval, op2, op2_lval, result, ZEND_SL, shift_left_function);\n\tif (UNEXPECTED((zend_ulong)op2_lval >= SIZEOF_ZEND_LONG * 8)) {\n\t\tif (EXPECTED(op2_lval > 0)) {\n\t\t\tif (op1 == result) {\n\t\t\t\tzval_ptr_dtor(result);\n\t\t\t}\n\t\t\tZVAL_LONG(result, 0);\n\t\t\treturn SUCCESS;\n\t\t} else {\n\t\t\tif (EG(current_execute_data) && !CG(in_compilation)) {\n\t\t\t\tzend_throw_exception_ex(zend_ce_arithmetic_error, 0, \"Bit shift by negative number\");\n\t\t\t} else {\n\t\t\t\tzend_error_noreturn(E_ERROR, \"Bit shift by negative number\");\n\t\t\t}\n\t\t\tif (op1 != result) {\n\t\t\t\tZVAL_UNDEF(result);\n\t\t\t}\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\tif (op1 == result) {\n\t\tzval_ptr_dtor(result);\n\t}\n\tZVAL_LONG(result, (zend_long) ((zend_ulong) op1_lval << op2_lval));\n\treturn SUCCESS;\n}", "target": 0}
{"code": "static void cjson_get_object_item_should_not_crash_with_array(void) {\n    cJSON *array = NULL;\n    cJSON *found = NULL;\n    array = cJSON_Parse(\"[1]\");\n    found = cJSON_GetObjectItem(array, \"name\");\n    TEST_ASSERT_NULL(found);\n    cJSON_Delete(array);\n}", "target": 0}
{"code": "const char *fz_colorspace_colorant(fz_context *ctx, const fz_colorspace *cs, int i)\n{\n\tif (!cs || i < 0 || i >= cs->n)\n\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"Colorant out of range\");\n\treturn cs->colorant[i];\n}", "target": 0}
{"code": "void IndexedDBDatabase::RequestComplete(ConnectionRequest* request) {\n  DCHECK_EQ(request, active_request_.get());\n  active_request_.reset();\n  if (!pending_requests_.empty())\n    ProcessRequestQueue();\n}", "target": 0}
{"code": "void l2tp_packet_print(const struct l2tp_packet_t *pack,\n\t\t       void (*print)(const char *fmt, ...))\n{\n\tconst struct l2tp_attr_t *attr;\n\tconst struct l2tp_dict_value_t *val;\n\tif (pack->hdr.ver == 2) {\n\t\tprint(\"[L2TP tid=%u sid=%u\", ntohs(pack->hdr.tid), ntohs(pack->hdr.sid));\n\t\tlog_ppp_debug(\" Ns=%u Nr=%u\", ntohs(pack->hdr.Ns), ntohs(pack->hdr.Nr));\n\t} else {\n\t\tprint(\"[L2TP cid=%u\", pack->hdr.cid);\n\t\tlog_ppp_debug(\" Ns=%u Nr=%u\", ntohs(pack->hdr.Ns), ntohs(pack->hdr.Nr));\n\t}\n\tlist_for_each_entry(attr, &pack->attrs, entry) {\n\t\tprint(\" <%s\", attr->attr->name);\n\t\tval = l2tp_dict_find_value(attr->attr, attr->val);\n\t\tif (val)\n\t\t\tprint(\" %s\", val->name);\n\t\telse if (attr->H)\n\t\t\tprint(\" (hidden, %hu bytes)\", attr->length);\n\t\telse {\n\t\t\tswitch (attr->attr->type) {\n\t\t\t\tcase ATTR_TYPE_INT16:\n\t\t\t\t\tprint(\" %i\", attr->val.int16);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE_INT32:\n\t\t\t\t\tprint(\" %i\", attr->val.int32);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE_STRING:\n\t\t\t\t\tprint(\" %s\", attr->val.string);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprint(\">\");\n\t}\n\tprint(\"]\\n\");\n}", "target": 1}
{"code": "cluster_free (struct cluster_list *cluster)\n{\n  if (cluster->list)\n    XFREE (MTYPE_CLUSTER_VAL, cluster->list);\n  XFREE (MTYPE_CLUSTER, cluster);\n}", "target": 0}
{"code": "static void enable_nmi_window(struct kvm_vcpu *vcpu)\n{\n\tif (vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) & GUEST_INTR_STATE_STI) {\n\t\tenable_irq_window(vcpu);\n\t\treturn;\n\t}\n\tvmcs_set_bits(CPU_BASED_VM_EXEC_CONTROL,\n\t\t      CPU_BASED_VIRTUAL_NMI_PENDING);\n}", "target": 0}
{"code": "RestStatus RestAuthHandler::execute() {\n  auto const type = _request->requestType();\n  if (type != rest::RequestType::POST) {\n    generateError(rest::ResponseCode::METHOD_NOT_ALLOWED, TRI_ERROR_HTTP_METHOD_NOT_ALLOWED);\n    return RestStatus::DONE;\n  }\n  bool parseSuccess = false;\n  VPackSlice slice = this->parseVPackBody(parseSuccess);\n  if (!parseSuccess) { \n    return RestStatus::DONE;\n  }\n  if (!slice.isObject()) {\n    return badRequest();\n  }\n  VPackSlice usernameSlice = slice.get(\"username\");\n  VPackSlice passwordSlice = slice.get(\"password\");\n  if (!usernameSlice.isString() || !passwordSlice.isString()) {\n    return badRequest();\n  }\n  _username = usernameSlice.copyString();\n  std::string const password = passwordSlice.copyString();\n  auth::UserManager* um = AuthenticationFeature::instance()->userManager();\n  if (um == nullptr) {\n    std::string msg = \"This server does not support users\";\n    LOG_TOPIC(\"2e7d4\", ERR, Logger::AUTHENTICATION) << msg;\n    generateError(rest::ResponseCode::UNAUTHORIZED, TRI_ERROR_HTTP_UNAUTHORIZED, msg);\n  } else if (um->checkPassword(_username, password)) {\n    VPackBuilder resultBuilder;\n    {\n      VPackObjectBuilder b(&resultBuilder);\n      std::string jwt = generateJwt(_username, password);\n      resultBuilder.add(\"jwt\", VPackValue(jwt));\n    }\n    _isValid = true;\n    generateDocument(resultBuilder.slice(), true, &VPackOptions::Defaults);\n  } else {\n    generateError(rest::ResponseCode::UNAUTHORIZED, TRI_ERROR_HTTP_UNAUTHORIZED,\n                  \"Wrong credentials\");\n  }\n  return RestStatus::DONE;\n}", "target": 1}
{"code": "bool DevToolsDownloadManagerDelegate::ShouldOpenDownload(\n    content::DownloadItem* item,\n    const content::DownloadOpenDelayedCallback& callback) {\n  DevToolsDownloadManagerHelper* download_helper =\n      DevToolsDownloadManagerHelper::FromWebContents(item->GetWebContents());\n  if (download_helper)\n    return true;\n  if (proxy_download_delegate_)\n    return proxy_download_delegate_->ShouldOpenDownload(item, callback);\n  return false;\n}", "target": 0}
{"code": "static bool valid_filemode(const int filemode)\n{\n\treturn (filemode == GIT_FILEMODE_TREE\n\t\t|| filemode == GIT_FILEMODE_BLOB\n\t\t|| filemode == GIT_FILEMODE_BLOB_EXECUTABLE\n\t\t|| filemode == GIT_FILEMODE_LINK\n\t\t|| filemode == GIT_FILEMODE_COMMIT);\n}", "target": 0}
{"code": "start_output_ppm (j_decompress_ptr cinfo, djpeg_dest_ptr dinfo)\n{\n  ppm_dest_ptr dest = (ppm_dest_ptr) dinfo;\n  switch (cinfo->out_color_space) {\n  case JCS_GRAYSCALE:\n    fprintf(dest->pub.output_file, \"P5\\n%ld %ld\\n%d\\n\",\n            (long) cinfo->output_width, (long) cinfo->output_height,\n            PPM_MAXVAL);\n    break;\n  case JCS_RGB:\n  case JCS_EXT_RGB:\n  case JCS_EXT_RGBX:\n  case JCS_EXT_BGR:\n  case JCS_EXT_BGRX:\n  case JCS_EXT_XBGR:\n  case JCS_EXT_XRGB:\n  case JCS_EXT_RGBA:\n  case JCS_EXT_BGRA:\n  case JCS_EXT_ABGR:\n  case JCS_EXT_ARGB:\n  case JCS_CMYK:\n    fprintf(dest->pub.output_file, \"P6\\n%ld %ld\\n%d\\n\",\n            (long) cinfo->output_width, (long) cinfo->output_height,\n            PPM_MAXVAL);\n    break;\n  default:\n    ERREXIT(cinfo, JERR_PPM_COLORSPACE);\n  }\n}", "target": 0}
{"code": "int mlx4_register_mac(struct mlx4_dev *dev, u8 port, u64 mac, int *index)\n{\n\tstruct mlx4_mac_table *table = &mlx4_priv(dev)->port[port].mac_table;\n\tint i, err = 0;\n\tint free = -1;\n\tmlx4_dbg(dev, \"Registering MAC: 0x%llx\\n\", (unsigned long long) mac);\n\tmutex_lock(&table->mutex);\n\tfor (i = 0; i < MLX4_MAX_MAC_NUM - 1; i++) {\n\t\tif (free < 0 && !table->refs[i]) {\n\t\t\tfree = i;\n\t\t\tcontinue;\n\t\t}\n\t\tif (mac == (MLX4_MAC_MASK & be64_to_cpu(table->entries[i]))) {\n\t\t\t*index = i;\n\t\t\t++table->refs[i];\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (free < 0) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmlx4_dbg(dev, \"Free MAC index is %d\\n\", free);\n\tif (table->total == table->max) {\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\ttable->refs[free] = 1;\n\ttable->entries[free] = cpu_to_be64(mac | MLX4_MAC_VALID);\n\terr = mlx4_set_port_mac_table(dev, port, table->entries);\n\tif (unlikely(err)) {\n\t\tmlx4_err(dev, \"Failed adding MAC: 0x%llx\\n\", (unsigned long long) mac);\n\t\ttable->refs[free] = 0;\n\t\ttable->entries[free] = 0;\n\t\tgoto out;\n\t}\n\t*index = free;\n\t++table->total;\nout:\n\tmutex_unlock(&table->mutex);\n\treturn err;\n}", "target": 0}
{"code": "inline int TensorProtoDataSize<Eigen::half>(const TensorProto& t) {\n  return t.half_val_size();\n}", "target": 0}
{"code": "static void kvm_destroy_devices(struct kvm *kvm)\n{\n\tstruct kvm_device *dev, *tmp;\n\tlist_for_each_entry_safe(dev, tmp, &kvm->devices, vm_node) {\n\t\tlist_del(&dev->vm_node);\n\t\tdev->ops->destroy(dev);\n\t}\n}", "target": 0}
{"code": "bool IsIdentityConsumingSwitch(const MutableGraphView& graph,\n                               const NodeDef& node) {\n  if ((IsIdentity(node) || IsIdentityNSingleInput(node)) &&\n      node.input_size() > 0) {\n    TensorId tensor_id = ParseTensorName(node.input(0));\n    if (IsTensorIdControlling(tensor_id)) {\n      return false;\n    }\n    NodeDef* input_node = graph.GetNode(tensor_id.node());\n    if (input_node == nullptr) {\n      return false;\n    }\n    return IsSwitch(*input_node);\n  }\n  return false;\n}", "target": 0}
{"code": "void get_pid_creds(pid_t pid, uid_t *uid, gid_t *gid)\n{\n\tchar line[400];\n\tuid_t u;\n\tgid_t g;\n\tFILE *f;\n\t*uid = -1;\n\t*gid = -1;\n\tsprintf(line, \"/proc/%d/status\", pid);\n\tif ((f = fopen(line, \"r\")) == NULL) {\n\t\tfprintf(stderr, \"Error opening %s: %s\\n\", line, strerror(errno));\n\t\treturn;\n\t}\n\twhile (fgets(line, 400, f)) {\n\t\tif (strncmp(line, \"Uid:\", 4) == 0) {\n\t\t\tif (sscanf(line+4, \"%u\", &u) != 1) {\n\t\t\t\tfprintf(stderr, \"bad uid line for pid %u\\n\", pid);\n\t\t\t\tfclose(f);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t*uid = u;\n\t\t} else if (strncmp(line, \"Gid:\", 4) == 0) {\n\t\t\tif (sscanf(line+4, \"%u\", &g) != 1) {\n\t\t\t\tfprintf(stderr, \"bad gid line for pid %u\\n\", pid);\n\t\t\t\tfclose(f);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t*gid = g;\n\t\t}\n\t}\n\tfclose(f);\n}", "target": 0}
{"code": "static int rfcomm_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)\n{\n\tstruct sockaddr_rc *sa = (struct sockaddr_rc *) addr;\n\tstruct sock *sk = sock->sk;\n\tint chan = sa->rc_channel;\n\tint err = 0;\n\tBT_DBG(\"sk %p %pMR\", sk, &sa->rc_bdaddr);\n\tif (!addr || addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\tlock_sock(sk);\n\tif (sk->sk_state != BT_OPEN) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\tif (sk->sk_type != SOCK_STREAM) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\twrite_lock(&rfcomm_sk_list.lock);\n\tif (chan && __rfcomm_get_listen_sock_by_addr(chan, &sa->rc_bdaddr)) {\n\t\terr = -EADDRINUSE;\n\t} else {\n\t\tbacpy(&rfcomm_pi(sk)->src, &sa->rc_bdaddr);\n\t\trfcomm_pi(sk)->channel = chan;\n\t\tsk->sk_state = BT_BOUND;\n\t}\n\twrite_unlock(&rfcomm_sk_list.lock);\ndone:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 1}
{"code": "static int adpt_i2o_install_device(adpt_hba* pHba, struct i2o_device *d)\n{\n\tmutex_lock(&adpt_configuration_lock);\n\td->controller=pHba;\n\td->owner=NULL;\n\td->next=pHba->devices;\n\td->prev=NULL;\n\tif (pHba->devices != NULL){\n\t\tpHba->devices->prev=d;\n\t}\n\tpHba->devices=d;\n\t*d->dev_name = 0;\n\tmutex_unlock(&adpt_configuration_lock);\n\treturn 0;\n}", "target": 1}
{"code": "static void ax25_kill_by_device(struct net_device *dev)\n{\n\tax25_dev *ax25_dev;\n\tax25_cb *s;\n\tstruct sock *sk;\n\tif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\n\t\treturn;\n\tspin_lock_bh(&ax25_list_lock);\nagain:\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->ax25_dev == ax25_dev) {\n\t\t\tsk = s->sk;\n\t\t\tsock_hold(sk);\n\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\tlock_sock(sk);\n\t\t\ts->ax25_dev = NULL;\n\t\t\tax25_dev_put(ax25_dev);\n\t\t\trelease_sock(sk);\n\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\tspin_lock_bh(&ax25_list_lock);\n\t\t\tsock_put(sk);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock_bh(&ax25_list_lock);\n}", "target": 1}
{"code": "void* ipc_rcu_alloc(int size)\n{\n\tvoid* out;\n\tif (rcu_use_vmalloc(size)) {\n\t\tout = vmalloc(HDRLEN_VMALLOC + size);\n\t\tif (out) {\n\t\t\tout += HDRLEN_VMALLOC;\n\t\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 1;\n\t\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->refcount = 1;\n\t\t}\n\t} else {\n\t\tout = kmalloc(HDRLEN_KMALLOC + size, GFP_KERNEL);\n\t\tif (out) {\n\t\t\tout += HDRLEN_KMALLOC;\n\t\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 0;\n\t\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->refcount = 1;\n\t\t}\n\t}\n\treturn out;\n}", "target": 1}
{"code": "static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {\n\tRBuffer *fbuf = r_buf_ref (buf);\n\tstruct MACH0_(opts_t) opts;\n\tMACH0_(opts_set_default) (&opts, bf);\n\tstruct MACH0_(obj_t) *main_mach0 = MACH0_(new_buf) (fbuf, &opts);\n\tif (!main_mach0) {\n\t\treturn false;\n\t}\n\tRRebaseInfo *rebase_info = r_rebase_info_new_from_mach0 (fbuf, main_mach0);\n\tRKernelCacheObj *obj = NULL;\n\tRPrelinkRange *prelink_range = get_prelink_info_range_from_mach0 (main_mach0);\n\tif (!prelink_range) {\n\t\tgoto beach;\n\t}\n\tobj = R_NEW0 (RKernelCacheObj);\n\tif (!obj) {\n\t\tR_FREE (prelink_range);\n\t\tgoto beach;\n\t}\n\tRCFValueDict *prelink_info = NULL;\n\tif (main_mach0->hdr.filetype != MH_FILESET && prelink_range->range.size) {\n\t\tprelink_info = r_cf_value_dict_parse (fbuf, prelink_range->range.offset,\n\t\t\t\tprelink_range->range.size, R_CF_OPTION_SKIP_NSDATA);\n\t\tif (!prelink_info) {\n\t\t\tR_FREE (prelink_range);\n\t\t\tR_FREE (obj);\n\t\t\tgoto beach;\n\t\t}\n\t}\n\tif (!pending_bin_files) {\n\t\tpending_bin_files = r_list_new ();\n\t\tif (!pending_bin_files) {\n\t\t\tR_FREE (prelink_range);\n\t\t\tR_FREE (obj);\n\t\t\tR_FREE (prelink_info);\n\t\t\tgoto beach;\n\t\t}\n\t}\n\tobj->mach0 = main_mach0;\n\tobj->rebase_info = rebase_info;\n\tobj->prelink_info = prelink_info;\n\tobj->cache_buf = fbuf;\n\tobj->pa2va_exec = prelink_range->pa2va_exec;\n\tobj->pa2va_data = prelink_range->pa2va_data;\n\tR_FREE (prelink_range);\n\t*bin_obj = obj;\n\tr_list_push (pending_bin_files, bf);\n\tif (rebase_info || main_mach0->chained_starts) {\n\t\tRIO *io = bf->rbin->iob.io;\n\t\tswizzle_io_read (obj, io);\n\t}\n\treturn true;\nbeach:\n\tr_buf_free (fbuf);\n\tobj->cache_buf = NULL;\n\tMACH0_(mach0_free) (main_mach0);\n\treturn false;\n}", "target": 1}
{"code": "WebSharedWorker* RenderView::createSharedWorker(\n    WebFrame* frame, const WebURL& url, const WebString& name,\n    unsigned long long document_id) {\n  int route_id = MSG_ROUTING_NONE;\n  bool exists = false;\n  bool url_mismatch = false;\n  ViewHostMsg_CreateWorker_Params params;\n  params.url = url;\n  params.is_shared = true;\n  params.name = name;\n  params.document_id = document_id;\n  params.render_view_route_id = routing_id_;\n  params.route_id = MSG_ROUTING_NONE;\n  params.parent_appcache_host_id = 0;\n  params.script_resource_appcache_id = 0;\n  Send(new ViewHostMsg_LookupSharedWorker(\n      params, &exists, &route_id, &url_mismatch));\n  if (url_mismatch) {\n    return NULL;\n  } else {\n    return new WebSharedWorkerProxy(RenderThread::current(),\n                                    document_id,\n                                    exists,\n                                    route_id,\n                                    routing_id_);\n  }\n}", "target": 0}
{"code": "void usb_serial_console_disconnect(struct usb_serial *serial)\n{\n\tif (serial->port[0] == usbcons_info.port) {\n\t\tusb_serial_console_exit();\n\t\tusb_serial_put(serial);\n\t}\n}", "target": 1}
{"code": "service_info *FindServiceEventURLPath(\n\tservice_table *table, const char *eventURLPath)\n{\n\tservice_info *finger = NULL;\n\turi_type parsed_url;\n\turi_type parsed_url_in;\n\tif (table &&\n\t\tparse_uri(eventURLPath, strlen(eventURLPath), &parsed_url_in) ==\n\t\t\tHTTP_SUCCESS) {\n\t\tfinger = table->serviceList;\n\t\twhile (finger) {\n\t\t\tif (finger->eventURL) {\n\t\t\t\tif (parse_uri(finger->eventURL,\n\t\t\t\t\t    strlen(finger->eventURL),\n\t\t\t\t\t    &parsed_url) == HTTP_SUCCESS) {\n\t\t\t\t\tif (!token_cmp(&parsed_url.pathquery,\n\t\t\t\t\t\t    &parsed_url_in.pathquery)) {\n\t\t\t\t\t\treturn finger;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinger = finger->next;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "static void svm_write_tsc_offset(struct kvm_vcpu *vcpu, u64 offset)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu64 g_tsc_offset = 0;\n\tif (is_guest_mode(vcpu)) {\n\t\tg_tsc_offset = svm->vmcb->control.tsc_offset -\n\t\t\t       svm->nested.hsave->control.tsc_offset;\n\t\tsvm->nested.hsave->control.tsc_offset = offset;\n\t} else\n\t\ttrace_kvm_write_tsc_offset(vcpu->vcpu_id,\n\t\t\t\t\t   svm->vmcb->control.tsc_offset,\n\t\t\t\t\t   offset);\n\tsvm->vmcb->control.tsc_offset = offset + g_tsc_offset;\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n}", "target": 0}
{"code": "PJ_DEF(void) pj_scan_get_until_ch( pj_scanner *scanner, \n\t\t\t\t   int until_char, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n    if (s >= scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n    while (PJ_SCAN_CHECK_EOF(s) && *s != until_char) {\n\t++s;\n    }\n    pj_strset3(out, scanner->curptr, s);\n    scanner->curptr = s;\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*s) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);\n    }\n}", "target": 1}
{"code": "Literal *hermes::evalUnaryOperator(\n    UnaryOperatorInst::OpKind kind,\n    IRBuilder &builder,\n    Literal *operand) {\n  switch (kind) {\n    case UnaryOperatorInst::OpKind::MinusKind:\n      switch (operand->getKind()) {\n        case ValueKind::LiteralNumberKind:\n          if (auto *literalNum = llvh::dyn_cast<LiteralNumber>(operand)) {\n            auto V = -literalNum->getValue();\n            return builder.getLiteralNumber(V);\n          }\n          break;\n        case ValueKind::LiteralUndefinedKind:\n          return builder.getLiteralNaN();\n        case ValueKind::LiteralBoolKind:\n          if (evalIsTrue(builder, operand)) {\n            return builder.getLiteralNumber(-1);\n          } else { \n            return builder.getLiteralNegativeZero();\n          }\n        case ValueKind::LiteralNullKind:\n          return builder.getLiteralNegativeZero();\n        default:\n          break;\n      }\n      break;\n    case UnaryOperatorInst::OpKind::TypeofKind:\n      switch (operand->getKind()) {\n        case ValueKind::GlobalObjectKind:\n        case ValueKind::LiteralNullKind:\n          return builder.getLiteralString(\"object\");\n        case ValueKind::LiteralUndefinedKind:\n          return builder.getLiteralString(\"undefined\");\n        case ValueKind::LiteralBoolKind:\n          return builder.getLiteralString(\"boolean\");\n        case ValueKind::LiteralNumberKind:\n          return builder.getLiteralString(\"number\");\n        case ValueKind::LiteralStringKind:\n          return builder.getLiteralString(\"string\");\n        default:\n          llvm_unreachable(\"Invalid literal kind.\");\n      }\n      break;\n    case UnaryOperatorInst::OpKind::BangKind:\n      if (evalIsTrue(builder, operand)) {\n        return builder.getLiteralBool(false);\n      }\n      if (evalIsFalse(builder, operand)) {\n        return builder.getLiteralBool(true);\n      }\n      break;\n    case UnaryOperatorInst::OpKind::VoidKind:\n      return builder.getLiteralUndefined();\n    default:\n      break;\n  }\n  return nullptr;\n}", "target": 1}
{"code": "static void _clean_slate_datagram(gnrc_sixlowpan_frag_fb_t *fbuf)\n{\n    clist_node_t new_queue = { .next = NULL };\n    fbuf->sfr.arq_timeout_event.msg.content.ptr = NULL;\n    evtimer_del((evtimer_t *)(&_arq_timer),\n                &fbuf->sfr.arq_timeout_event.event);\n    fbuf->sfr.arq_timeout_event.event.next = NULL;\n    if (gnrc_sixlowpan_frag_sfr_congure_snd_has_inter_frame_gap()) {\n        for (clist_node_t *node = clist_lpop(&_frame_queue);\n             node != NULL; node = clist_lpop(&_frame_queue)) {\n            _frame_queue_t *entry = (_frame_queue_t *)node;\n            if (entry->datagram_tag == fbuf->tag) {\n                gnrc_pktbuf_release(entry->frame);\n                entry->frame = NULL;\n                clist_rpush(&_frag_descs_free, node);\n            }\n            else {\n                clist_rpush(&new_queue, node);\n            }\n        }\n        _frame_queue = new_queue;\n    }\n    fbuf->offset = 0U;\n    fbuf->sfr.cur_seq = 0U;\n    fbuf->sfr.frags_sent = 0U;\n    for (clist_node_t *node = clist_lpop(&fbuf->sfr.window);\n         node != NULL; node = clist_lpop(&fbuf->sfr.window)) {\n        clist_rpush(&_frag_descs_free, node);\n    }\n}", "target": 1}
{"code": "static StkId rethook (lua_State *L, CallInfo *ci, StkId firstres, int nres) {\n  ptrdiff_t oldtop = savestack(L, L->top);  \n  int delta = 0;\n  if (isLuacode(ci)) {\n    Proto *p = clLvalue(s2v(ci->func))->p;\n    if (p->is_vararg)\n      delta = ci->u.l.nextraargs + p->numparams + 1;\n    if (L->top < ci->top)\n      L->top = ci->top;  \n  }\n  if (L->hookmask & LUA_MASKRET) {  \n    int ftransfer;\n    ci->func += delta;  \n    ftransfer = cast(unsigned short, firstres - ci->func);\n    luaD_hook(L, LUA_HOOKRET, -1, ftransfer, nres);  \n    ci->func -= delta;\n  }\n  if (isLua(ci->previous))\n    L->oldpc = ci->previous->u.l.savedpc;  \n  return restorestack(L, oldtop);\n}", "target": 1}
{"code": "static int emulate_store_desc_ptr(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t  void (*get)(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t\t      struct desc_ptr *ptr))\n{\n\tstruct desc_ptr desc_ptr;\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tctxt->op_bytes = 8;\n\tget(ctxt, &desc_ptr);\n\tif (ctxt->op_bytes == 2) {\n\t\tctxt->op_bytes = 4;\n\t\tdesc_ptr.address &= 0x00ffffff;\n\t}\n\tctxt->dst.type = OP_NONE;\n\treturn segmented_write_std(ctxt, ctxt->dst.addr.mem,\n\t\t\t\t   &desc_ptr, 2 + ctxt->op_bytes);\n}", "target": 0}
{"code": "BOOL transport_connect_nla(rdpTransport* transport)\n{\n\tfreerdp* instance;\n\trdpSettings* settings;\n\tif (transport->layer == TRANSPORT_LAYER_TSG)\n\t\treturn TRUE;\n\tif (!transport_connect_tls(transport))\n\t\treturn FALSE;\n\tif (transport->settings->Authentication != TRUE)\n\t\treturn TRUE;\n\tsettings = transport->settings;\n\tinstance = (freerdp*) settings->instance;\n\tif (transport->credssp == NULL)\n\t\ttransport->credssp = credssp_new(instance, transport, settings);\n\tif (credssp_authenticate(transport->credssp) < 0)\n\t{\n\t\tif (!connectErrorCode)\n\t\t\tconnectErrorCode = AUTHENTICATIONERROR;\n\t\tfprintf(stderr, \"Authentication failure, check credentials.\\n\"\n\t\t\t\"If credentials are valid, the NTLMSSP implementation may be to blame.\\n\");\n\t\tcredssp_free(transport->credssp);\n\t\ttransport->credssp = NULL;\n\t\treturn FALSE;\n\t}\n\tcredssp_free(transport->credssp);\n\treturn TRUE;\n}", "target": 0}
{"code": "epilogProcessor(XML_Parser parser, const char *s, const char *end,\n                const char **nextPtr) {\n  parser->m_processor = epilogProcessor;\n  parser->m_eventPtr = s;\n  for (;;) {\n    const char *next = NULL;\n    int tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n#ifdef XML_DTD\n    if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                  XML_ACCOUNT_DIRECT)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }\n#endif\n    parser->m_eventEndPtr = next;\n    switch (tok) {\n    case -XML_TOK_PROLOG_S:\n      if (parser->m_defaultHandler) {\n        reportDefault(parser, parser->m_encoding, s, next);\n        if (parser->m_parsingStatus.parsing == XML_FINISHED)\n          return XML_ERROR_ABORTED;\n      }\n      *nextPtr = next;\n      return XML_ERROR_NONE;\n    case XML_TOK_NONE:\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    case XML_TOK_PROLOG_S:\n      if (parser->m_defaultHandler)\n        reportDefault(parser, parser->m_encoding, s, next);\n      break;\n    case XML_TOK_PI:\n      if (! reportProcessingInstruction(parser, parser->m_encoding, s, next))\n        return XML_ERROR_NO_MEMORY;\n      break;\n    case XML_TOK_COMMENT:\n      if (! reportComment(parser, parser->m_encoding, s, next))\n        return XML_ERROR_NO_MEMORY;\n      break;\n    case XML_TOK_INVALID:\n      parser->m_eventPtr = next;\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL:\n      if (! parser->m_parsingStatus.finalBuffer) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_UNCLOSED_TOKEN;\n    case XML_TOK_PARTIAL_CHAR:\n      if (! parser->m_parsingStatus.finalBuffer) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_PARTIAL_CHAR;\n    default:\n      return XML_ERROR_JUNK_AFTER_DOC_ELEMENT;\n    }\n    parser->m_eventPtr = s = next;\n    switch (parser->m_parsingStatus.parsing) {\n    case XML_SUSPENDED:\n      *nextPtr = next;\n      return XML_ERROR_NONE;\n    case XML_FINISHED:\n      return XML_ERROR_ABORTED;\n    default:;\n    }\n  }\n}", "target": 1}
{"code": "  Status ValidateInputsGenerateOutputs(\n      OpKernelContext* ctx, const Tensor** inputs, const Tensor** seq_len,\n      Tensor** log_prob, OpOutputList* decoded_indices,\n      OpOutputList* decoded_values, OpOutputList* decoded_shape) const {\n    Status status = ctx->input(\"inputs\", inputs);\n    if (!status.ok()) return status;\n    status = ctx->input(\"sequence_length\", seq_len);\n    if (!status.ok()) return status;\n    const TensorShape& inputs_shape = (*inputs)->shape();\n    if (inputs_shape.dims() != 3) {\n      return errors::InvalidArgument(\"inputs is not a 3-Tensor\");\n    }\n    if (inputs_shape.num_elements() == 0) {\n      return errors::InvalidArgument(\"inputs must not be empty\");\n    }\n    const int64 max_time = inputs_shape.dim_size(0);\n    const int64 batch_size = inputs_shape.dim_size(1);\n    if (max_time == 0) {\n      return errors::InvalidArgument(\"max_time is 0\");\n    }\n    if (!TensorShapeUtils::IsVector((*seq_len)->shape())) {\n      return errors::InvalidArgument(\"sequence_length is not a vector\");\n    }\n    if (!(batch_size == (*seq_len)->dim_size(0))) {\n      return errors::FailedPrecondition(\n          \"len(sequence_length) != batch_size.  \",\n          \"len(sequence_length):  \", (*seq_len)->dim_size(0),\n          \" batch_size: \", batch_size);\n    }\n    auto seq_len_t = (*seq_len)->vec<int32>();\n    for (int b = 0; b < batch_size; ++b) {\n      if (!(seq_len_t(b) <= max_time)) {\n        return errors::FailedPrecondition(\"sequence_length(\", b,\n                                          \") <= \", max_time);\n      }\n    }\n    Status s = ctx->allocate_output(\n        \"log_probability\", TensorShape({batch_size, top_paths_}), log_prob);\n    if (!s.ok()) return s;\n    s = ctx->output_list(\"decoded_indices\", decoded_indices);\n    if (!s.ok()) return s;\n    s = ctx->output_list(\"decoded_values\", decoded_values);\n    if (!s.ok()) return s;\n    s = ctx->output_list(\"decoded_shape\", decoded_shape);\n    if (!s.ok()) return s;\n    return Status::OK();\n  }", "target": 0}
{"code": "PHPAPI PHP_FUNCTION(fread)\n{\n\tzval *arg1;\n\tlong len;\n\tphp_stream *stream;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rl\", &arg1, &len) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\tif (len <= 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter must be greater than 0\");\n\t\tRETURN_FALSE;\n\t}\n\tif (len > INT_MAX) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter must be no more than %d\", INT_MAX);\n\t\tRETURN_FALSE;\n\t}\n\tZ_STRVAL_P(return_value) = emalloc(len + 1);\n\tZ_STRLEN_P(return_value) = php_stream_read(stream, Z_STRVAL_P(return_value), len);\n\tZ_STRVAL_P(return_value)[Z_STRLEN_P(return_value)] = 0;\n\tZ_TYPE_P(return_value) = IS_STRING;\n}", "target": 0}
{"code": "wsemul_vt100_output_csi(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tu_int newstate = VT100_EMUL_STATE_CSI;\n\tint oargs;\n\tint rc = 0;\n\tswitch (instate->inchar) {\n\tcase '0': case '1': case '2': case '3': case '4':\n\tcase '5': case '6': case '7': case '8': case '9':\n\t\tif (edp->nargs > VT100_EMUL_NARGS - 1)\n\t\t\tbreak;\n\t\tedp->args[edp->nargs] = (edp->args[edp->nargs] * 10) +\n\t\t    (instate->inchar - '0');\n\t\tbreak;\n\tcase ';': \n\t\tedp->nargs++;\n\t\tbreak;\n\tcase '?': \n\tcase '>': \n\t\tedp->modif1 = (char)instate->inchar;\n\t\tbreak;\n\tcase '!':\n\tcase '\"':\n\tcase '$':\n\tcase '&':\n\t\tedp->modif2 = (char)instate->inchar;\n\t\tbreak;\n\tdefault: \n\t\toargs = edp->nargs++;\n\t\tif (edp->nargs > VT100_EMUL_NARGS) {\n#ifdef VT100_DEBUG\n\t\t\tprintf(\"vt100: too many arguments\\n\");\n#endif\n\t\t\tedp->nargs = VT100_EMUL_NARGS;\n\t\t}\n\t\trc = wsemul_vt100_handle_csi(edp, instate);\n\t\tif (rc != 0) {\n\t\t\tedp->nargs = oargs;\n\t\t\treturn rc;\n\t\t}\n\t\tnewstate = VT100_EMUL_STATE_NORMAL;\n\t\tbreak;\n\t}\n\tif (COLS_LEFT != 0)\n\t\tedp->flags &= ~VTFL_LASTCHAR;\n\tedp->state = newstate;\n\treturn 0;\n}", "target": 1}
{"code": "void HttpIntegrationTest::testManyRequestHeaders(std::chrono::milliseconds time) {\n  config_helper_.addConfigModifier(\n      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void { hcm.mutable_max_request_headers_kb()->set_value(96); });\n  max_request_headers_kb_ = 96;\n  Http::TestHeaderMapImpl big_headers{\n      {\":method\", \"GET\"}, {\":path\", \"/test/long/url\"}, {\":scheme\", \"http\"}, {\":authority\", \"host\"}};\n  for (int i = 0; i < 20000; i++) {\n    big_headers.addCopy(std::to_string(i), std::string(0, 'a'));\n  }\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response =\n      sendRequestAndWaitForResponse(big_headers, 0, default_response_headers_, 0, 0, time);\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n}", "target": 0}
{"code": "static std::string make_relative_path(const std::string& path) {\n  if (path.empty()) {\n    return path;\n  }\n  std::string canonical(FileUtil::canonicalize(path));\n  if (FileUtil::isDirSeparator(canonical[0])) {\n    return canonical.substr(1);\n  }\n  std::string relative(canonical);\n  int idx = canonical.length() - 1;\n  while (1) {\n    while (idx > 0 && !(FileUtil::isDirSeparator(canonical[idx]))) {\n      idx--;\n    }\n    if (idx == 0) {\n      return canonical;\n    }\n    if (idx >= 1 && (canonical[idx - 1] == '.' || canonical[idx - 1] == ':')) {\n      relative = canonical.substr(idx + 1);\n      break;\n    }\n    idx--;\n  }\n  return relative;\n}", "target": 0}
{"code": "static void write_palette(int idx, uint32_t color, void *opaque)\n{\n    struct palette_cb_priv *priv = opaque;\n    VncState *vs = priv->vs;\n    uint32_t bytes = vs->client_pf.bytes_per_pixel;\n    if (bytes == 4) {\n        ((uint32_t*)priv->header)[idx] = color;\n    } else {\n        ((uint16_t*)priv->header)[idx] = color;\n    }\n}", "target": 0}
{"code": "static int websocket_send(lua_State *L) {\n    lastCFunction = __func__;\n    std::string str = checkstring(L, 1);\n    if (config.http_max_websocket_message > 0 && str.size() > (unsigned)config.http_max_websocket_message) luaL_error(L, \"Message is too large\");\n    ws_handle * ws = *(ws_handle**)lua_touserdata(L, lua_upvalueindex(1));\n    if (ws == NULL) luaL_error(L, \"attempt to use a closed file\");\n    std::lock_guard<std::mutex> lock(ws->lock);\n    if (ws->ws == NULL) return luaL_error(L, \"attempt to use a closed file\");\n    if (ws->ws->sendFrame(str.c_str(), str.size(), (int)WebSocket::FRAME_FLAG_FIN | (int)(lua_toboolean(L, 2) ? WebSocket::FRAME_BINARY : WebSocket::FRAME_TEXT)) < 1) \n        websocket_close(L);\n    return 0;\n}", "target": 1}
{"code": "int setup_tests(void)\n{\n    crv_len = EC_get_builtin_curves(NULL, 0);\n    if (!TEST_ptr(curves = OPENSSL_malloc(sizeof(*curves) * crv_len))\n        || !TEST_true(EC_get_builtin_curves(curves, crv_len)))\n        return 0;\n    ADD_TEST(field_tests_ecp_simple);\n    ADD_TEST(field_tests_ecp_mont);\n#ifndef OPENSSL_NO_EC2M\n    ADD_TEST(ec2m_field_sanity);\n    ADD_TEST(field_tests_ec2_simple);\n#endif\n    ADD_ALL_TESTS(field_tests_default, crv_len);\n#ifndef OPENSSL_NO_EC_NISTP_64_GCC_128\n    ADD_TEST(underflow_test);\n#endif\n    ADD_TEST(set_private_key);\n    ADD_TEST(decoded_flag_test);\n    ADD_ALL_TESTS(ecpkparams_i2d2i_test, crv_len);\n    return 1;\n}", "target": 0}
{"code": "static Bool leap_year(u32 year) {\n\tyear += 1900;\n\treturn (year % 4) == 0 && ((year % 100) != 0 || (year % 400) == 0) ? GF_TRUE : GF_FALSE;\n}", "target": 0}
{"code": "rx_cache_insert(netdissect_options *ndo,\n                const u_char *bp, const struct ip *ip, int dport)\n{\n\tstruct rx_cache_entry *rxent;\n\tconst struct rx_header *rxh = (const struct rx_header *) bp;\n\tif (ndo->ndo_snapend - bp + 1 <= (int)(sizeof(struct rx_header) + sizeof(int32_t)))\n\t\treturn;\n\trxent = &rx_cache[rx_cache_next];\n\tif (++rx_cache_next >= RX_CACHE_SIZE)\n\t\trx_cache_next = 0;\n\trxent->callnum = EXTRACT_32BITS(&rxh->callNumber);\n\tUNALIGNED_MEMCPY(&rxent->client, &ip->ip_src, sizeof(uint32_t));\n\tUNALIGNED_MEMCPY(&rxent->server, &ip->ip_dst, sizeof(uint32_t));\n\trxent->dport = dport;\n\trxent->serviceId = EXTRACT_32BITS(&rxh->serviceId);\n\trxent->opcode = EXTRACT_32BITS(bp + sizeof(struct rx_header));\n}", "target": 1}
{"code": "RecordPadAlign(int size, int align)\n{\n    return (align - (size & (align - 1))) & (align - 1);\n}                               ", "target": 0}
{"code": "void js_rot(js_State *J, int n)\n{\n\tint i;\n\tjs_Value tmp = STACK[TOP-1];\n\tfor (i = 1; i < n; ++i)\n\t\tSTACK[TOP-i] = STACK[TOP-i-1];\n\tSTACK[TOP-i] = tmp;\n}", "target": 0}
{"code": "    void CFontFileType1::DecryptEexec(unsigned char** ppEexecBuffer, int nLen)\n    {\n        unsigned char *sCur = (unsigned char*)(*ppEexecBuffer);\n        while( sCur < (unsigned char*)(*ppEexecBuffer) + nLen && ( ' ' == *sCur || '\\t' == *sCur || '\\r' == *sCur || '\\n' == *sCur ) )\n            ++sCur;\n        bool bASCII = false;\n        if ( isxdigit( sCur[0] ) && isxdigit( sCur[1] ) && isxdigit( sCur[2] ) && isxdigit( sCur[3] ) )\n            bASCII = true;\n        if ( bASCII )\n            ASCIIHexDecode( &sCur, sCur + nLen, sCur, nLen );\n        unsigned short ushKey = 55665U;\n        EexecDecode( &sCur, *ppEexecBuffer + nLen, sCur, nLen, &ushKey );\n    }", "target": 1}
{"code": "int LibRaw_bigfile_datastream::seek(INT64 o, int whence)\n{\n  LR_BF_CHK();\n#if defined(_WIN32)\n#ifdef WIN32SECURECALLS\n  return _fseeki64(f, o, whence);\n#else\n  return fseek(f, (long)o, whence);\n#endif\n#else\n  return fseeko(f, o, whence);\n#endif\n}", "target": 0}
{"code": "struct clock_source *dcn20_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\tif (!clk_src)\n\t\treturn NULL;\n\tif (dcn20_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\tkfree(clk_src);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 0}
{"code": "static void rtc_irq_eoi_tracking_reset(struct kvm_ioapic *ioapic)\n{\n\tioapic->rtc_status.pending_eoi = 0;\n\tbitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPUS);\n}", "target": 1}
{"code": "krb5_gss_process_context_token(minor_status, context_handle,\n                               token_buffer)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    gss_buffer_t token_buffer;\n{\n    krb5_gss_ctx_id_rec *ctx;\n    OM_uint32 majerr;\n    ctx = (krb5_gss_ctx_id_t) context_handle;\n    if (! ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n    if (GSS_ERROR(majerr = kg_unseal(minor_status, context_handle,\n                                     token_buffer,\n                                     GSS_C_NO_BUFFER, NULL, NULL,\n                                     KG_TOK_DEL_CTX)))\n        return(majerr);\n    return(krb5_gss_delete_sec_context(minor_status, &context_handle,\n                                       GSS_C_NO_BUFFER));\n}", "target": 1}
{"code": "TEST(ComparisonsTest,\n     QuantizedInt8GreaterWithBroadcastMultiplierGreaterThanOne) {\n  const float kMin = -127.f;\n  const float kMax = 127.f;\n  std::vector<std::vector<int>> test_shapes = {\n      {6}, {2, 3}, {2, 1, 3}, {1, 3, 1, 2}};\n  for (int i = 0; i < test_shapes.size(); ++i) {\n    ComparisonOpModel model({TensorType_INT8, test_shapes[i], kMin, kMax},\n                            {TensorType_INT8, {}, kMin, kMax}, TensorType_INT8,\n                            BuiltinOperator_GREATER);\n    model.QuantizeAndPopulate<int8_t>(model.input1(),\n                                      {572, -2, -71, 8, 11, 20});\n    model.QuantizeAndPopulate<int8_t>(model.input2(), {8});\n    model.Invoke();\n    EXPECT_THAT(model.GetOutput(),\n                ElementsAre(true, false, false, false, true, true))\n        << \"With shape number \" << i;\n  }\n}", "target": 0}
{"code": "apr_byte_t oidc_cache_get(request_rec *r, const char *section, const char *key,\n\t\tchar **value) {\n\toidc_cfg *cfg = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\tint encrypted = oidc_cfg_cache_encrypt(r);\n\tapr_byte_t rc = TRUE;\n\tchar *msg = NULL;\n\toidc_debug(r, \"enter: %s (section=%s, decrypt=%d, type=%s)\", key, section,\n\t\t\tencrypted, cfg->cache->name);\n\tif (encrypted == 1)\n\t\tkey = oidc_cache_get_hashed_key(r, cfg->crypto_passphrase, key);\n\tconst char *cache_value = NULL;\n\tif (cfg->cache->get(r, section, key, &cache_value) == FALSE) {\n\t\trc = FALSE;\n\t\tgoto out;\n\t}\n\tif (cache_value == NULL)\n\t\tgoto out;\n\tif (encrypted == 0) {\n\t\t*value = apr_pstrdup(r->pool, cache_value);\n\t\tgoto out;\n\t}\n\trc = (oidc_cache_crypto_decrypt(r, cache_value,\n\t\t\toidc_cache_hash_passphrase(r, cfg->crypto_passphrase),\n\t\t\t(unsigned char **) value) > 0);\nout:\n\tmsg = apr_psprintf(r->pool, \"from %s cache backend for %skey %s\",\n\t\t\tcfg->cache->name, encrypted ? \"encrypted \" : \"\", key);\n\tif (rc == TRUE)\n\t\tif (*value != NULL)\n\t\t\toidc_debug(r, \"cache hit: return %d bytes %s\",\n\t\t\t\t\t*value ? (int )strlen(*value) : 0, msg);\n\t\telse\n\t\t\toidc_debug(r, \"cache miss %s\", msg);\n\telse\n\t\toidc_warn(r, \"error retrieving value %s\", msg);\n\treturn rc;\n}", "target": 1}
{"code": "static int midi_setup_sysex_roland_reset(struct _mdi *mdi) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,0,0);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_sysex_roland_reset;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.value = 0;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}", "target": 0}
{"code": "StatusOr<FullTypeDef> SpecializeType(const AttrSlice& attrs,\n                                     const OpDef& op_def) {\n  FullTypeDef ft;\n  ft.set_type_id(TFT_PRODUCT);\n  for (int i = 0; i < op_def.output_arg_size(); i++) {\n    auto* t = ft.add_args();\n    *t = op_def.output_arg(i).experimental_full_type();\n    for (int j = 0; j < t->args_size(); j++) {\n      auto* arg = t->mutable_args(i);\n      if (arg->type_id() == TFT_VAR) {\n        const auto* attr = attrs.Find(arg->s());\n        DCHECK(attr != nullptr);\n        if (attr->value_case() == AttrValue::kList) {\n          const auto& attr_list = attr->list();\n          arg->set_type_id(TFT_PRODUCT);\n          for (int i = 0; i < attr_list.type_size(); i++) {\n            map_dtype_to_tensor(attr_list.type(i), arg->add_args());\n          }\n        } else if (attr->value_case() == AttrValue::kType) {\n          map_dtype_to_tensor(attr->type(), arg);\n        } else {\n          return Status(error::UNIMPLEMENTED,\n                        absl::StrCat(\"unknown attribute type\",\n                                     attrs.DebugString(), \" key=\", arg->s()));\n        }\n        arg->clear_s();\n      }\n    }\n  }\n  return ft;\n}", "target": 1}
{"code": "static int vivid_fb_ioctl(struct fb_info *info, unsigned cmd, unsigned long arg)\n{\n\tstruct vivid_dev *dev = (struct vivid_dev *)info->par;\n\tswitch (cmd) {\n\tcase FBIOGET_VBLANK: {\n\t\tstruct fb_vblank vblank;\n\t\tmemset(&vblank, 0, sizeof(vblank));\n\t\tvblank.flags = FB_VBLANK_HAVE_COUNT | FB_VBLANK_HAVE_VCOUNT |\n\t\t\tFB_VBLANK_HAVE_VSYNC;\n\t\tvblank.count = 0;\n\t\tvblank.vcount = 0;\n\t\tvblank.hcount = 0;\n\t\tif (copy_to_user((void __user *)arg, &vblank, sizeof(vblank)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tdefault:\n\t\tdprintk(dev, 1, \"Unknown ioctl %08x\\n\", cmd);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static void ConvertLoopSequence(ModSample &smp, STPLoopList &loopList)\n{\n\tif(!smp.HasSampleData() || loopList.size() < 2) return;\n\tModSample newSmp = smp;\n\tnewSmp.nLength = 0;\n\tnewSmp.pSample = nullptr;\n\tsize_t numLoops = loopList.size();\n\tfor(size_t i = 0; i < numLoops; i++)\n\t{\n\t\tSTPLoopInfo &info = loopList[i];\n\t\tif((newSmp.nLength + info.loopLength > MAX_SAMPLE_LENGTH) ||\n\t\t   (info.loopLength > MAX_SAMPLE_LENGTH) ||\n\t\t   (info.loopStart + info.loopLength > smp.nLength))\n\t\t{\n\t\t\tnumLoops = i;\n\t\t\tbreak;\n\t\t}\n\t\tnewSmp.nLength += info.loopLength;\n\t}\n\tif(!newSmp.AllocateSample())\n\t{\n\t\treturn;\n\t}\n\tSmpLength start = 0;\n\tfor(size_t i = 0; i < numLoops; i++)\n\t{\n\t\tSTPLoopInfo &info = loopList[i];\n\t\tmemcpy(newSmp.pSample8 + start, smp.pSample8 + info.loopStart, info.loopLength);\n\t\tinfo.loopStart = start;\n\t\tif(i > 0 && i <= mpt::size(newSmp.cues))\n\t\t{\n\t\t\tnewSmp.cues[i - 1] = start;\n\t\t}\n\t\tstart += info.loopLength;\n\t}\n\tsmp.FreeSample();\n\tsmp = newSmp;\n\tsmp.nLoopStart = 0;\n\tsmp.nLoopEnd = smp.nLength;\n\tsmp.uFlags.set(CHN_LOOP);\n}", "target": 1}
{"code": "int CLASS ljpeg_diff_new (LibRaw_bit_buffer& bits, LibRaw_byte_buffer* buf,ushort *huff)\n{\n  int len, diff;\n  if(!huff || !buf)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  len = bits._gethuff_lj(buf,*huff,huff+1);\n  if (len == 16 && (!dng_version || dng_version >= 0x1010000))\n    return -32768;\n  diff = bits._getbits_lj(buf,len);\n  if ((diff & (1 << (len-1))) == 0)\n    diff -= (1 << len) - 1;\n  return diff;\n}", "target": 0}
{"code": "    size_t SonyMnHeader::size() const\n    {\n        return sizeOfSignature();\n    }", "target": 0}
{"code": "unsigned char *base64decode(const char *buf, size_t *size)\n{\n\tif (!buf || !size) return NULL;\n\tsize_t len = (*size > 0) ? *size : strlen(buf);\n\tif (len <= 0) return NULL;\n\tunsigned char *outbuf = (unsigned char*)malloc((len/4)*3+3);\n\tconst char *ptr = buf;\n\tint p = 0;\n\tsize_t l = 0;\n\tdo {\n\t\tptr += strspn(ptr, \"\\r\\n\\t \");\n\t\tif (*ptr == '\\0' || ptr >= buf+len) {\n\t\t\tbreak;\n\t\t}\n\t\tl = strcspn(ptr, \"\\r\\n\\t \");\n\t\tif (l > 3 && ptr+l <= buf+len) {\n\t\t\tp+=base64decode_block(outbuf+p, ptr, l);\n\t\t\tptr += l;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t} while (1);\n\toutbuf[p] = 0;\n\t*size = p;\n\treturn outbuf;\n}", "target": 1}
{"code": "fribidi_cap_rtl_to_unicode (\n  const char *s,\n  FriBidiStrIndex len,\n  FriBidiChar *us\n)\n{\n  FriBidiStrIndex i, j;\n  if (!caprtl_to_unicode)\n    init_cap_rtl ();\n  j = 0;\n  for (i = 0; i < len; i++)\n    {\n      char ch;\n      ch = s[i];\n      if (ch == '_')\n\t{\n\t  switch (ch = s[++i])\n\t    {\n\t    case '>':\n\t      us[j++] = FRIBIDI_CHAR_LRM;\n\t      break;\n\t    case '<':\n\t      us[j++] = FRIBIDI_CHAR_RLM;\n\t      break;\n\t    case 'l':\n\t      us[j++] = FRIBIDI_CHAR_LRE;\n\t      break;\n\t    case 'r':\n\t      us[j++] = FRIBIDI_CHAR_RLE;\n\t      break;\n\t    case 'o':\n\t      us[j++] = FRIBIDI_CHAR_PDF;\n\t      break;\n\t    case 'L':\n\t      us[j++] = FRIBIDI_CHAR_LRO;\n\t      break;\n\t    case 'R':\n\t      us[j++] = FRIBIDI_CHAR_RLO;\n\t      break;\n            case 'i':\n              us[j++] = FRIBIDI_CHAR_LRI;\n\t      break;\n            case 'y':\n              us[j++] = FRIBIDI_CHAR_RLI;\n\t      break;\n            case 'f':\n              us[j++] = FRIBIDI_CHAR_FSI;\n\t      break;\n            case 'I':\n              us[j++] = FRIBIDI_CHAR_PDI;\n\t      break;\n\t    case '_':\n\t      us[j++] = '_';\n\t      break;\n\t    default:\n\t      us[j++] = '_';\n\t      i--;\n\t      break;\n\t    }\n\t}\n      else\n\tus[j++] = caprtl_to_unicode[(int) s[i]];\n    }\n  return j;\n}", "target": 1}
{"code": "unsigned int bounded_iostream::write_no_buffer(const void *from, size_t bytes_to_write) {\n    std::pair<unsigned int, Sirikata::JpegError> retval;\n    if (byte_bound != 0 && byte_position + bytes_to_write > byte_bound) {\n        size_t real_bytes_to_write = byte_bound - byte_position;\n        byte_position += real_bytes_to_write;\n        retval = parent->Write(reinterpret_cast<const unsigned char*>(from), real_bytes_to_write);\n        if (retval.first < real_bytes_to_write) {\n            err = retval.second;\n            return retval.first;\n        }\n        return bytes_to_write; \n    }\n    size_t total = bytes_to_write;\n    retval = parent->Write(reinterpret_cast<const unsigned char*>(from), total);\n    unsigned int written = retval.first;\n    byte_position += written;\n    if (written < total ) {\n        err = retval.second;\n        return written;\n    }\n    return bytes_to_write;\n}", "target": 1}
{"code": "off_t FileModule::tell()\n{\n\treturn m_fh->tell();\n}", "target": 0}
{"code": "void Item::cleanup()\n{\n  DBUG_ENTER(\"Item::cleanup\");\n  DBUG_PRINT(\"enter\", (\"this: %p\", this));\n  fixed=0;\n  marker= 0;\n  join_tab_idx= MAX_TABLES;\n  if (orig_name)\n    name= orig_name;\n  DBUG_VOID_RETURN;\n}", "target": 0}
{"code": "Jsi_RC jsi_evalcode(jsi_Pstate *ps, Jsi_Func *func, Jsi_OpCodes *opcodes, \n         jsi_ScopeChain *scope, Jsi_Value *fargs,\n         Jsi_Value *_this,\n         Jsi_Value **vret)\n{\n    Jsi_Interp *interp = ps->interp;\n    if (interp->exited)\n        return JSI_ERROR;\n    Jsi_RC rc;\n    jsi_Frame frame = *interp->framePtr;\n    frame.parent = interp->framePtr;\n    interp->framePtr = &frame;\n    frame.parent->child = interp->framePtr = &frame;\n    frame.ps = ps;\n    frame.ingsc = scope;\n    frame.incsc = fargs;\n    frame.inthis = _this;\n    frame.opcodes = opcodes;\n    frame.fileName = ((func && func->script)?func->script:interp->curFile);\n    frame.funcName = interp->curFunction;\n    frame.dirName = interp->curDir;\n    if (frame.fileName && frame.fileName == frame.parent->fileName)\n        frame.logflag = frame.parent->logflag;\n    else\n        frame.logflag = 0;\n    frame.level = frame.parent->level+1;\n    frame.evalFuncPtr = func;\n    frame.arguments = NULL;\n    if (interp->curIp)\n        frame.parent->line = interp->curIp->Line;\n    frame.ip = interp->curIp;\n    interp->refCount++;\n    interp->level++;\n    Jsi_IncrRefCount(interp, fargs);\n    rc = jsi_evalcode_sub(ps, opcodes, scope, fargs, _this, *vret);\n    Jsi_DecrRefCount(interp, fargs);\n    if (interp->didReturn == 0 && !interp->exited) {\n        if ((interp->evalFlags&JSI_EVAL_RETURN)==0)\n            Jsi_ValueMakeUndef(interp, vret);\n    }\n    if (frame.arguments)\n        Jsi_DecrRefCount(interp, frame.arguments);\n    interp->didReturn = 0;\n    interp->refCount--;\n    interp->level--;\n    interp->framePtr = frame.parent;\n    interp->framePtr->child = NULL;\n    interp->curIp = frame.ip;\n    if (interp->exited)\n        rc = JSI_ERROR;\n    return rc;\n}", "target": 1}
{"code": "MONGO_EXPORT mongo_cursor *gridfile_get_chunks( gridfile *gfile, int start, int size ) {\n    bson_iterator it;\n    bson_oid_t id;\n    bson gte;\n    bson query;\n    bson orderby;\n    bson command;\n    mongo_cursor *cursor;\n    bson_find( &it, gfile->meta, \"_id\" );\n    id = *bson_iterator_oid( &it );\n    bson_init( &query );\n    bson_append_oid( &query, \"files_id\", &id );\n    if ( size == 1 ) {\n        bson_append_int( &query, \"n\", start );\n    }\n    else {\n        bson_init( &gte );\n        bson_append_int( &gte, \"$gte\", start );\n        bson_finish( &gte );\n        bson_append_bson( &query, \"n\", &gte );\n        bson_destroy( &gte );\n    }\n    bson_finish( &query );\n    bson_init( &orderby );\n    bson_append_int( &orderby, \"n\", 1 );\n    bson_finish( &orderby );\n    bson_init( &command );\n    bson_append_bson( &command, \"query\", &query );\n    bson_append_bson( &command, \"orderby\", &orderby );\n    bson_finish( &command );\n    cursor = mongo_find( gfile->gfs->client, gfile->gfs->chunks_ns,\n                         &command, NULL, size, 0, 0 );\n    bson_destroy( &command );\n    bson_destroy( &query );\n    bson_destroy( &orderby );\n    return cursor;\n}", "target": 1}
{"code": "sf_open\t(const char *path, int mode, SF_INFO *sfinfo)\n{\tSF_PRIVATE \t*psf ;\n\tassert (sizeof (sf_count_t) == 8) ;\n\tif ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)\n\t{\tsf_errno = SFE_MALLOC_FAILED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\tpsf_init_files (psf) ;\n\tpsf_log_printf (psf, \"File : %s\\n\", path) ;\n\tif (copy_filename (psf, path) != 0)\n\t{\tsf_errno = psf->error ;\n\t\treturn\tNULL ;\n\t\t} ;\n\tpsf->file.mode = mode ;\n\tif (strcmp (path, \"-\") == 0)\n\t\tpsf->error = psf_set_stdio (psf) ;\n\telse\n\t\tpsf->error = psf_fopen (psf) ;\n\treturn psf_open_file (psf, sfinfo) ;\n} ", "target": 1}
{"code": "static void kvm_vcpu_ioctl_x86_get_debugregs(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     struct kvm_debugregs *dbgregs)\n{\n\tunsigned long val;\n\tmemcpy(dbgregs->db, vcpu->arch.db, sizeof(vcpu->arch.db));\n\tkvm_get_dr(vcpu, 6, &val);\n\tdbgregs->dr6 = val;\n\tdbgregs->dr7 = vcpu->arch.dr7;\n\tdbgregs->flags = 0;\n\tmemset(&dbgregs->reserved, 0, sizeof(dbgregs->reserved));\n}", "target": 1}
{"code": "static char *decode_text_string(const char *str, size_t str_len)\n{\n    int   idx, is_hex, is_utf16be, ascii_idx;\n    char *ascii, hex_buf[5] = {0};\n    is_hex = is_utf16be = idx = ascii_idx = 0;\n    if (str[0] == '(')\n    {\n        ascii = malloc(strlen(str) + 1);\n        strncpy(ascii, str, strlen(str) + 1);\n        return ascii;\n    }\n    else if (str[0] == '<')\n    {\n        is_hex = 1;\n        ++idx;\n    }\n    if (is_hex && (str_len > 5) && \n        (str[idx] == 'F') && (str[idx+1] == 'E') &&\n        (str[idx+2] == 'F') && (str[idx+3] == 'F'))\n    {\n        is_utf16be = 1;\n        idx += 4;\n    }\n    else\n      return NULL;\n    ascii = malloc(str_len);\n    for ( ; idx<str_len; ++idx)\n    {\n        hex_buf[0] = str[idx++];\n        hex_buf[1] = str[idx++];\n        hex_buf[2] = str[idx++];\n        hex_buf[3] = str[idx];\n        ascii[ascii_idx++] = strtol(hex_buf, NULL, 16);\n    }\n    return ascii;\n}", "target": 1}
{"code": "static int xgene_hwmon_remove(struct platform_device *pdev)\n{\n\tstruct xgene_hwmon_dev *ctx = platform_get_drvdata(pdev);\n\tcancel_work_sync(&ctx->workq);\n\thwmon_device_unregister(ctx->hwmon_dev);\n\tkfifo_free(&ctx->async_msg_fifo);\n\tif (acpi_disabled)\n\t\tmbox_free_channel(ctx->mbox_chan);\n\telse\n\t\tpcc_mbox_free_channel(ctx->pcc_chan);\n\treturn 0;\n}", "target": 0}
{"code": "check_1_6_dummy(kadm5_principal_ent_t entry, long mask,\n                int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char **passptr)\n{\n    int i;\n    char *password = *passptr;\n    if (!(mask & KADM5_ATTRIBUTES) ||\n        !(entry->attributes & KRB5_KDB_DISALLOW_ALL_TIX))\n        return;\n    for (i = 0; (unsigned char) password[i] == i + 1; i++);\n    if (password[i] != '\\0' || i != 255)\n        return;\n    *passptr = NULL;\n}", "target": 1}
{"code": "PHP_NAMED_FUNCTION(zif_locale_set_default)\n{\n\tchar* locale_name = NULL;\n\tint   len=0;\t\n\tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC,  \"s\",\n\t\t&locale_name ,&len ) == FAILURE)\n\t{\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t \t\"locale_set_default: unable to parse input params\", 0 TSRMLS_CC );\n\t\tRETURN_FALSE;\n\t}\n\tif(len == 0) {\n\t\tlocale_name =  (char *)uloc_getDefault() ;\n\t\tlen = strlen(locale_name);\n\t}\n\tzend_alter_ini_entry(LOCALE_INI_NAME, sizeof(LOCALE_INI_NAME), locale_name, len, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);\t\n\tRETURN_TRUE;\n}", "target": 1}
{"code": "main (void)\n{\n  char *login;\n  int errors = 0;\n  login = getlogin ();\n  if (login == NULL)\n    puts (\"getlogin returned NULL, no further tests\");\n  else\n    {\n      char name[1024];\n      int ret;\n      printf (\"getlogin returned: `%s'\\n\", login);\n      ret = getlogin_r (name, sizeof (name));\n      if (ret == 0)\n\t{\n\t  printf (\"getlogin_r returned: `%s'\\n\", name);\n\t  if (strcmp (name, login) != 0)\n\t    {\n\t      puts (\"Error: getlogin and getlogin_r returned different names\");\n\t      ++errors;\n\t    }\n\t}\n      else\n\t{\n\t  printf (\"Error: getlogin_r returned: %d (%s)\\n\",\n\t\t  ret, strerror (ret));\n\t  ++errors;\n\t}\n    }\n  return errors != 0;\n}", "target": 0}
{"code": "\tUnbufferedAsioTlsStream(UnbufferedAsioTlsStreamParams& init)\n\t\t: AsioTcpTlsStream(init.IoContext, init.SslContext), m_VerifyOK(true), m_Hostname(init.Hostname)\n\t{\n\t}", "target": 1}
{"code": "static int pagemap_open(struct inode *inode, struct file *file)\n{\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tpr_warn_once(\"Bits 55-60 of /proc/PID/pagemap entries are about \"\n\t\t\t\"to stop being page-shift some time soon. See the \"\n\t\t\t\"linux/Documentation/vm/pagemap.txt for details.\\n\");\n\treturn 0;\n}", "target": 0}
{"code": "static void on_umock_c_error(UMOCK_C_ERROR_CODE error_code)\n{\n    ASSERT_FAIL(\"umock_c reported error :%\" PRI_MU_ENUM \"\", MU_ENUM_VALUE(UMOCK_C_ERROR_CODE, error_code));\n}", "target": 0}
{"code": "uint32_t negate_negative_int32(int32_t x)\n{\n  assert(x <= 0);\n  if (x == INT32_MIN) {\n    return static_cast<uint32_t>(INT32_MAX) + 1;\n  }\n  else {\n    return static_cast<uint32_t>(-x);\n  }\n}", "target": 0}
{"code": "        unsigned int GetU32LE (int nPos, bool *pbSuccess)\n        {\n            if ( nPos < 0 || nPos + 3 >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            unsigned int nRes = m_sFile[nPos + 3];\n            nRes = (nRes << 8) + m_sFile[nPos + 2];\n            nRes = (nRes << 8) + m_sFile[nPos + 1];\n            nRes = (nRes << 8) + m_sFile[nPos + 0];\n            return nRes;\n        }", "target": 1}
{"code": "int _yr_re_is_word_char(\n    uint8_t* input,\n    int character_size)\n{\n  int result = ((isalnum(*input) || (*input) == '_'));\n  if (character_size == 2)\n    result = result && (*(input + 1) == 0);\n  return result;\n}", "target": 0}
{"code": "static int propagate_one(struct mount *m)\n{\n\tstruct mount *child;\n\tint type;\n\tif (IS_MNT_NEW(m))\n\t\treturn 0;\n\tif (!is_subdir(mp->m_dentry, m->mnt.mnt_root))\n\t\treturn 0;\n\tif (peers(m, last_dest)) {\n\t\ttype = CL_MAKE_SHARED;\n\t} else {\n\t\tstruct mount *n, *p;\n\t\tfor (n = m; ; n = p) {\n\t\t\tp = n->mnt_master;\n\t\t\tif (p == dest_master || IS_MNT_MARKED(p)) {\n\t\t\t\twhile (last_dest->mnt_master != p) {\n\t\t\t\t\tlast_source = last_source->mnt_master;\n\t\t\t\t\tlast_dest = last_source->mnt_parent;\n\t\t\t\t}\n\t\t\t\tif (!peers(n, last_dest)) {\n\t\t\t\t\tlast_source = last_source->mnt_master;\n\t\t\t\t\tlast_dest = last_source->mnt_parent;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ttype = CL_SLAVE;\n\t\tif (IS_MNT_SHARED(m))\n\t\t\ttype |= CL_MAKE_SHARED;\n\t}\n\tif (m->mnt_ns->user_ns != user_ns)\n\t\ttype |= CL_UNPRIVILEGED;\n\tchild = copy_tree(last_source, last_source->mnt.mnt_root, type);\n\tif (IS_ERR(child))\n\t\treturn PTR_ERR(child);\n\tchild->mnt.mnt_flags &= ~MNT_LOCKED;\n\tmnt_set_mountpoint(m, mp, child);\n\tlast_dest = m;\n\tlast_source = child;\n\tif (m->mnt_master != dest_master) {\n\t\tread_seqlock_excl(&mount_lock);\n\t\tSET_MNT_MARK(m->mnt_master);\n\t\tread_sequnlock_excl(&mount_lock);\n\t}\n\thlist_add_head(&child->mnt_hash, list);\n\treturn 0;\n}", "target": 1}
{"code": "int ff_combine_frame(ParseContext *pc, int next, const uint8_t **buf, int *buf_size)\n{\n    if(pc->overread){\n        av_dlog(NULL, \"overread %d, state:%X next:%d index:%d o_index:%d\\n\",\n                pc->overread, pc->state, next, pc->index, pc->overread_index);\n        av_dlog(NULL, \"%X %X %X %X\\n\", (*buf)[0], (*buf)[1], (*buf)[2], (*buf)[3]);\n    }\n    for(; pc->overread>0; pc->overread--){\n        pc->buffer[pc->index++]= pc->buffer[pc->overread_index++];\n    }\n    if(!*buf_size && next == END_NOT_FOUND){\n        next= 0;\n    }\n    pc->last_index= pc->index;\n    if(next == END_NOT_FOUND){\n        void* new_buffer = av_fast_realloc(pc->buffer, &pc->buffer_size, (*buf_size) + pc->index + FF_INPUT_BUFFER_PADDING_SIZE);\n        if(!new_buffer)\n            return AVERROR(ENOMEM);\n        pc->buffer = new_buffer;\n        memcpy(&pc->buffer[pc->index], *buf, *buf_size);\n        pc->index += *buf_size;\n        return -1;\n    }\n    *buf_size=\n    pc->overread_index= pc->index + next;\n    if(pc->index){\n        void* new_buffer = av_fast_realloc(pc->buffer, &pc->buffer_size, next + pc->index + FF_INPUT_BUFFER_PADDING_SIZE);\n        if(!new_buffer)\n            return AVERROR(ENOMEM);\n        pc->buffer = new_buffer;\n        if (next > -FF_INPUT_BUFFER_PADDING_SIZE)\n            memcpy(&pc->buffer[pc->index], *buf,\n                   next + FF_INPUT_BUFFER_PADDING_SIZE);\n        pc->index = 0;\n        *buf= pc->buffer;\n    }\n    for(;next < 0; next++){\n        pc->state = (pc->state<<8) | pc->buffer[pc->last_index + next];\n        pc->state64 = (pc->state64<<8) | pc->buffer[pc->last_index + next];\n        pc->overread++;\n    }\n    if(pc->overread){\n        av_dlog(NULL, \"overread %d, state:%X next:%d index:%d o_index:%d\\n\",\n                pc->overread, pc->state, next, pc->index, pc->overread_index);\n        av_dlog(NULL, \"%X %X %X %X\\n\", (*buf)[0], (*buf)[1],(*buf)[2],(*buf)[3]);\n    }\n    return 0;\n}", "target": 1}
{"code": "RenderWidgetHostViewPort* GetRenderWidgetHostViewFromSurfaceID(\n    int surface_id) {\n  int render_process_id = 0;\n  int render_widget_id = 0;\n  if (!GpuSurfaceTracker::Get()->GetRenderWidgetIDForSurface(\n        surface_id, &render_process_id, &render_widget_id))\n    return NULL;\n  content::RenderProcessHost* process =\n      content::RenderProcessHost::FromID(render_process_id);\n  if (!process)\n    return NULL;\n  content::RenderWidgetHost* host = process->GetRenderWidgetHostByID(\n      render_widget_id);\n  return host ? RenderWidgetHostViewPort::FromRWHV(host->GetView()) : NULL;\n}", "target": 0}
{"code": "    void resetTriggered() { m_triggered = false; }", "target": 0}
{"code": "static void tcp_illinois_info(struct sock *sk, u32 ext,\n\t\t\t      struct sk_buff *skb)\n{\n\tconst struct illinois *ca = inet_csk_ca(sk);\n\tif (ext & (1 << (INET_DIAG_VEGASINFO - 1))) {\n\t\tstruct tcpvegas_info info = {\n\t\t\t.tcpv_enabled = 1,\n\t\t\t.tcpv_rttcnt = ca->cnt_rtt,\n\t\t\t.tcpv_minrtt = ca->base_rtt,\n\t\t};\n\t\tu64 t = ca->sum_rtt;\n\t\tdo_div(t, ca->cnt_rtt);\n\t\tinfo.tcpv_rtt = t;\n\t\tnla_put(skb, INET_DIAG_VEGASINFO, sizeof(info), &info);\n\t}\n}", "target": 1}
{"code": "static void __mark_reg32_unbounded(struct bpf_reg_state *reg)\n{\n\treg->s32_min_value = S32_MIN;\n\treg->s32_max_value = S32_MAX;\n\treg->u32_min_value = 0;\n\treg->u32_max_value = U32_MAX;\n}", "target": 0}
{"code": "  void readErr(const AsyncSocketException& ex) noexcept override {\n    LOG(ERROR) << ex.what();\n  }", "target": 0}
{"code": "hermesBuiltinApply(void *, Runtime *runtime, NativeArgs args) {\n  GCScopeMarkerRAII marker{runtime};\n  Handle<Callable> fn = args.dyncastArg<Callable>(0);\n  if (LLVM_UNLIKELY(!fn)) {\n    return runtime->raiseTypeErrorForValue(\n        args.getArgHandle(0), \" is not a function\");\n  }\n  Handle<JSArray> argArray = args.dyncastArg<JSArray>(1);\n  if (LLVM_UNLIKELY(!argArray)) {\n    return runtime->raiseTypeError(\"args must be an array\");\n  }\n  uint32_t len = JSArray::getLength(*argArray);\n  bool isConstructor = args.getArgCount() == 2;\n  MutableHandle<> thisVal{runtime};\n  if (isConstructor) {\n    auto thisValRes = Callable::createThisForConstruct(fn, runtime);\n    if (LLVM_UNLIKELY(thisValRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    thisVal = *thisValRes;\n  } else {\n    thisVal = args.getArg(2);\n  }\n  ScopedNativeCallFrame newFrame{\n      runtime, len, *fn, isConstructor, thisVal.getHermesValue()};\n  if (LLVM_UNLIKELY(newFrame.overflowed()))\n    return runtime->raiseStackOverflow(Runtime::StackOverflowKind::NativeStack);\n  for (uint32_t i = 0; i < len; ++i) {\n    newFrame->getArgRef(i) = argArray->at(runtime, i);\n  }\n  return isConstructor ? Callable::construct(fn, runtime, thisVal)\n                       : Callable::call(fn, runtime);\n}", "target": 0}
{"code": "static void ion_free_nolock(struct ion_client *client, struct ion_handle *handle)\n{\n\tbool valid_handle;\n\tBUG_ON(client != handle->client);\n\tvalid_handle = ion_handle_validate(client, handle);\n\tif (!valid_handle) {\n\t\tWARN(1, \"%s: invalid handle passed to free.\\n\", __func__);\n\t\treturn;\n\t}\n\tion_handle_put_nolock(handle);\n}", "target": 0}
{"code": "      explicit JpegOutput( String const& filename ) {\n         if( FileHasExtension( filename )) {\n            outfile_ = std::fopen(filename.c_str(), \"wb\");\n         } else {\n            outfile_ = std::fopen( FileAddExtension( filename, \"jpg\" ).c_str(), \"wb\" );\n         }\n         if( outfile_ == nullptr ) {\n            DIP_THROW_RUNTIME( \"Could not open file for writing\" );\n         }\n         cinfo_.err = jpeg_std_error( &jerr_.pub );\n         jerr_.pub.error_exit = my_error_exit;\n         jerr_.pub.output_message = my_output_message;\n         if( setjmp( jerr_.setjmp_buffer )) {\n            DIP_THROW_RUNTIME( \"Error writing JPEG file.\" );\n         }\n         jpeg_create_compress( &cinfo_ );\n         initialized_ = true;\n         jpeg_stdio_dest( &cinfo_, outfile_ );\n      }", "target": 1}
{"code": "int anon_vma_clone(struct vm_area_struct *dst, struct vm_area_struct *src)\n{\n\tstruct anon_vma_chain *avc, *pavc;\n\tstruct anon_vma *root = NULL;\n\tlist_for_each_entry_reverse(pavc, &src->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma;\n\t\tavc = anon_vma_chain_alloc(GFP_NOWAIT | __GFP_NOWARN);\n\t\tif (unlikely(!avc)) {\n\t\t\tunlock_anon_vma_root(root);\n\t\t\troot = NULL;\n\t\t\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\t\t\tif (!avc)\n\t\t\t\tgoto enomem_failure;\n\t\t}\n\t\tanon_vma = pavc->anon_vma;\n\t\troot = lock_anon_vma_root(root, anon_vma);\n\t\tanon_vma_chain_link(dst, avc, anon_vma);\n\t\tif (!dst->anon_vma && src->anon_vma &&\n\t\t    anon_vma != src->anon_vma && anon_vma->degree < 2)\n\t\t\tdst->anon_vma = anon_vma;\n\t}\n\tif (dst->anon_vma)\n\t\tdst->anon_vma->degree++;\n\tunlock_anon_vma_root(root);\n\treturn 0;\n enomem_failure:\n\tdst->anon_vma = NULL;\n\tunlink_anon_vmas(dst);\n\treturn -ENOMEM;\n}", "target": 1}
{"code": "static void f2fs_put_super(struct super_block *sb)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tint i;\n\tf2fs_quota_off_umount(sb);\n\tmutex_lock(&sbi->umount_mutex);\n\tif (is_sbi_flag_set(sbi, SBI_IS_DIRTY) ||\n\t\t\t!is_set_ckpt_flags(sbi, CP_UMOUNT_FLAG)) {\n\t\tstruct cp_control cpc = {\n\t\t\t.reason = CP_UMOUNT,\n\t\t};\n\t\twrite_checkpoint(sbi, &cpc);\n\t}\n\tf2fs_wait_discard_bios(sbi);\n\tif (f2fs_discard_en(sbi) && !sbi->discard_blks) {\n\t\tstruct cp_control cpc = {\n\t\t\t.reason = CP_UMOUNT | CP_TRIMMED,\n\t\t};\n\t\twrite_checkpoint(sbi, &cpc);\n\t}\n\tf2fs_destroy_stats(sbi);\n\trelease_ino_entry(sbi, true);\n\tf2fs_leave_shrinker(sbi);\n\tmutex_unlock(&sbi->umount_mutex);\n\tf2fs_flush_merged_writes(sbi);\n\tiput(sbi->node_inode);\n\tiput(sbi->meta_inode);\n\tdestroy_node_manager(sbi);\n\tdestroy_segment_manager(sbi);\n\tkfree(sbi->ckpt);\n\tf2fs_unregister_sysfs(sbi);\n\tsb->s_fs_info = NULL;\n\tif (sbi->s_chksum_driver)\n\t\tcrypto_free_shash(sbi->s_chksum_driver);\n\tkfree(sbi->raw_super);\n\tdestroy_device_list(sbi);\n\tmempool_destroy(sbi->write_io_dummy);\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\tdestroy_percpu_info(sbi);\n\tfor (i = 0; i < NR_PAGE_TYPE; i++)\n\t\tkfree(sbi->write_io[i]);\n\tkfree(sbi);\n}", "target": 1}
{"code": "BOOL nego_read_request(rdpNego* nego, wStream* s)\n{\n\tBYTE li;\n\tBYTE type;\n\tUINT16 length;\n\tif (!tpkt_read_header(s, &length))\n\t\treturn FALSE;\n\tif (!tpdu_read_connection_request(s, &li, length))\n\t\treturn FALSE;\n\tif (li != Stream_GetRemainingLength(s) + 6)\n\t{\n\t\tWLog_ERR(TAG, \"Incorrect TPDU length indicator.\");\n\t\treturn FALSE;\n\t}\n\tif (!nego_read_request_token_or_cookie(nego, s))\n\t{\n\t\tWLog_ERR(TAG, \"Failed to parse routing token or cookie.\");\n\t\treturn FALSE;\n\t}\n\tif (Stream_GetRemainingLength(s) >= 8)\n\t{\n\t\tStream_Read_UINT8(s, type); \n\t\tif (type != TYPE_RDP_NEG_REQ)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Incorrect negotiation request type %\" PRIu8 \"\", type);\n\t\t\treturn FALSE;\n\t\t}\n\t\tnego_process_negotiation_request(nego, s);\n\t}\n\treturn tpkt_ensure_stream_consumed(s, length);\n}", "target": 1}
{"code": "STATIC void\nS_put_code_point(pTHX_ SV *sv, UV c)\n{\n    PERL_ARGS_ASSERT_PUT_CODE_POINT;\n    if (c > 255) {\n        Perl_sv_catpvf(aTHX_ sv, \"\\\\x{%04\" UVXf \"}\", c);\n    }\n    else if (isPRINT(c)) {\n\tconst char string = (char) c;\n\tif (isBACKSLASHED_PUNCT(c) || c == '{' || c == '}')\n\t    sv_catpvs(sv, \"\\\\\");\n\tsv_catpvn(sv, &string, 1);\n    }\n    else if (isMNEMONIC_CNTRL(c)) {\n        Perl_sv_catpvf(aTHX_ sv, \"%s\", cntrl_to_mnemonic((U8) c));\n    }\n    else {\n        Perl_sv_catpvf(aTHX_ sv, \"\\\\x%02X\", (U8) c);\n    }", "target": 0}
{"code": "pci_bus_configured(int bus)\n{\n\tassert(bus >= 0 && bus < MAXBUSES);\n\treturn (pci_businfo[bus] != NULL);\n}", "target": 1}
{"code": "static int check_ci(const struct atm_vcc *vcc, short vpi, int vci)\n{\n\tstruct hlist_head *head = &vcc_hash[vci & (VCC_HTABLE_SIZE - 1)];\n\tstruct hlist_node *node;\n\tstruct sock *s;\n\tstruct atm_vcc *walk;\n\tsk_for_each(s, node, head) {\n\t\twalk = atm_sk(s);\n\t\tif (walk->dev != vcc->dev)\n\t\t\tcontinue;\n\t\tif (test_bit(ATM_VF_ADDR, &walk->flags) && walk->vpi == vpi &&\n\t\t    walk->vci == vci && ((walk->qos.txtp.traffic_class !=\n\t\t    ATM_NONE && vcc->qos.txtp.traffic_class != ATM_NONE) ||\n\t\t    (walk->qos.rxtp.traffic_class != ATM_NONE &&\n\t\t    vcc->qos.rxtp.traffic_class != ATM_NONE)))\n\t\t\treturn -EADDRINUSE;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "  void event_cb(drachtio::RequestHandler::GlobalInfo *g, curl_socket_t s,\n                       int action, const boost::system::error_code & error,\n                       int *fdp) {\n    std::shared_ptr<RequestHandler> p = RequestHandler::getInstance() ;\n    std::map<curl_socket_t, boost::asio::ip::tcp::socket *>& socket_map = p->getSocketMap() ;\n    boost::asio::deadline_timer& timer = p->getTimer() ;\n    if(socket_map.find(s) == socket_map.end()) {\n      DR_LOG(log_error) << \"event_cb: socket already closed\";\n      return;\n    }\n    if(*fdp == action || *fdp == CURL_POLL_INOUT) {\n      CURLMcode rc;\n      if(error)\n        action = CURL_CSELECT_ERR;\n      rc = curl_multi_socket_action(g->multi, s, action, &g->still_running);\n      mcode_test(\"event_cb: curl_multi_socket_action\", rc);\n      check_multi_info(g);\n      if(g->still_running <= 0) {\n        timer.cancel();\n      }\n      if(!error && socket_map.find(s) != socket_map.end() &&\n         (*fdp == action || *fdp == CURL_POLL_INOUT)) {\n        boost::asio::ip::tcp::socket *tcp_socket = socket_map.find(s)->second;\n        if(action == CURL_POLL_IN) {\n          tcp_socket->async_read_some(boost::asio::null_buffers(),\n                                      boost::bind(&event_cb, g, s,\n                                                  action, boost::placeholders::_1, fdp));\n        }\n        if(action == CURL_POLL_OUT) {\n          tcp_socket->async_write_some(boost::asio::null_buffers(),\n                                       boost::bind(&event_cb, g, s,\n                                                   action, boost::placeholders::_1, fdp));\n        } \n      }\n    }\n  }", "target": 1}
{"code": "static const ut8 *parse_die(const ut8 *buf, const ut8 *buf_end, RBinDwarfAbbrevDecl *abbrev, RBinDwarfCompUnitHdr *hdr, RBinDwarfDie *die, const ut8 *debug_str, size_t debug_str_len, Sdb *sdb) {\n\tsize_t i;\n\tif (!buf || !buf_end || buf > buf_end) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < die->count; i++) {\n\t\tmemset (&die->attr_values[i], 0, sizeof (RBinDwarfDie));\n\t}\n\tfor (i = 0; i < abbrev->count && i < die->capacity; i++) {\n\t\tmemset (&die->attr_values[i], 0, sizeof (die->attr_values[i]));\n\t\tconst ut8 *nbuf = parse_attr_value (buf, buf_end - buf,\n\t\t\t&abbrev->defs[i],\n\t\t\t&die->attr_values[i],\n\t\t\thdr, debug_str, debug_str_len);\n\t\tif (nbuf) {\n\t\t\tbuf = nbuf;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t\tRBinDwarfAttrValue *attribute = &die->attr_values[i];\n\t\tbool is_string = (attribute->attr_form == DW_FORM_strp || attribute->attr_form == DW_FORM_string);\n\t\tbool is_valid_string_form = is_string && attribute->string.content;\n\t\tif (attribute->attr_name == DW_AT_comp_dir && is_valid_string_form) {\n\t\t\tconst char *name = attribute->string.content;\n\t\t\tsdb_set (sdb, \"DW_AT_comp_dir\", name, 0);\n\t\t}\n\t\tdie->count++;\n\t}\n\treturn buf;\n}", "target": 1}
{"code": "  void SetUp() override {\n    auto *file = UTHENTICODE_TEST_ASSETS \"/YourPhone.exe\";\n    pe = peparse::ParsePEFromFile(file);\n    ASSERT_TRUE(pe != nullptr);\n  }", "target": 0}
{"code": "int wvlan_set_station_nickname(struct net_device *dev,\n\t\t      struct iw_request_info *info,\n\t\t      union iwreq_data *wrqu,\n\t\t      char *extra)\n{\n\tstruct wl_private *lp = wl_priv(dev);\n\tunsigned long flags;\n\tint         ret = 0;\n\tDBG_FUNC(\"wvlan_set_station_nickname\");\n\tDBG_ENTER(DbgInfo);\n\twl_lock(lp, &flags);\n\tmemset(lp->StationName, 0, sizeof(lp->StationName));\n\tmemcpy(lp->StationName, extra, wrqu->data.length);\n\twl_apply(lp);\n\twl_unlock(lp, &flags);\n\tDBG_LEAVE(DbgInfo);\n\treturn ret;\n} ", "target": 1}
{"code": "static inline void find_entity_for_char(\n\tunsigned int k,\n\tenum entity_charset charset,\n\tconst entity_stage1_row *table,\n\tconst unsigned char **entity,\n\tsize_t *entity_len,\n\tunsigned char *old,\n\tsize_t oldlen,\n\tsize_t *cursor)\n{\n\tunsigned stage1_idx = ENT_STAGE1_INDEX(k);\n\tconst entity_stage3_row *c;\n\tif (stage1_idx > 0x1D) {\n\t\t*entity     = NULL;\n\t\t*entity_len = 0;\n\t\treturn;\n\t}\n\tc = &table[stage1_idx][ENT_STAGE2_INDEX(k)][ENT_STAGE3_INDEX(k)];\n\tif (!c->ambiguous) {\n\t\t*entity     = (const unsigned char *)c->data.ent.entity;\n\t\t*entity_len = c->data.ent.entity_len;\n\t} else {\n\t\tsize_t\t cursor_before\t= *cursor;\n\t\tint\t\t status\t\t\t= SUCCESS;\n\t\tunsigned next_char;\n\t\tif (!(*cursor < oldlen))\n\t\t\tgoto no_suitable_2nd;\n\t\tnext_char = get_next_char(charset, old, oldlen, cursor, &status); \n\t\tif (status == FAILURE)\n\t\t\tgoto no_suitable_2nd;\n\t\t{\n\t\t\tconst entity_multicodepoint_row *s, *e;\n\t\t\ts = &c->data.multicodepoint_table[1];\n\t\t\te = s - 1 + c->data.multicodepoint_table[0].leading_entry.size;\n\t\t\tfor ( ; s <= e; s++) {\n\t\t\t\tif (s->normal_entry.second_cp == next_char) {\n\t\t\t\t\t*entity     = s->normal_entry.entity;\n\t\t\t\t\t*entity_len = s->normal_entry.entity_len;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\nno_suitable_2nd:\n\t\t*cursor = cursor_before;\n\t\t*entity = (const unsigned char *)\n\t\t\tc->data.multicodepoint_table[0].leading_entry.default_entity;\n\t\t*entity_len = c->data.multicodepoint_table[0].leading_entry.default_entity_len;\n\t}\t\n}", "target": 1}
{"code": "void test_refs_revparse__parses_at_head(void)\n{\n\ttest_id(\"HEAD\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\", NULL, GIT_REVSPEC_SINGLE);\n\ttest_id(\"@{0}\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\", NULL, GIT_REVSPEC_SINGLE);\n\ttest_id(\"@\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\", NULL, GIT_REVSPEC_SINGLE);\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* c) override {\n    const TensorList* input_list = nullptr;\n    OP_REQUIRES_OK(c, GetInputList(c, 0, &input_list));\n    OP_REQUIRES(c, TensorShapeUtils::IsScalar(c->input(1).shape()),\n                errors::InvalidArgument(\"size must be a scalar\"));\n    int32_t size = c->input(1).scalar<int32>()();\n    OP_REQUIRES(\n        c, size >= 0,\n        errors::InvalidArgument(\n            \"TensorListSlice expects size to be non-negative. Got: \", size));\n    std::unique_ptr<Tensor> maybe_result =\n        c->forward_input(0, 0, DT_VARIANT, TensorShape{},\n                         c->input_memory_type(0), AllocatorAttributes());\n    if (maybe_result != nullptr) {\n      TensorList* out = maybe_result->scalar<Variant>()().get<TensorList>();\n      if (out->RefCountIsOne()) {\n        out->tensors().resize(size, Tensor(DT_INVALID));\n        c->set_output(0, *maybe_result);\n        return;\n      }\n    }\n    Tensor* result;\n    AllocatorAttributes attr;\n    attr.set_on_host(true);\n    OP_REQUIRES_OK(c, c->allocate_output(0, TensorShape{}, &result, attr));\n    TensorList output_list;\n    output_list.element_shape = input_list->element_shape;\n    output_list.element_dtype = input_list->element_dtype;\n    output_list.max_num_elements = input_list->max_num_elements;\n    if (size > input_list->tensors().size()) {\n      output_list.tensors().insert(output_list.tensors().begin(),\n                                   input_list->tensors().begin(),\n                                   input_list->tensors().end());\n      output_list.tensors().resize(size, Tensor(DT_INVALID));\n    } else {\n      output_list.tensors().insert(output_list.tensors().begin(),\n                                   input_list->tensors().begin(),\n                                   input_list->tensors().begin() + size);\n    }\n    result->scalar<Variant>()() = std::move(output_list);\n  }", "target": 0}
{"code": "static inline int page_is_allowed(unsigned long pfn)\n{\n\treturn devmem_is_allowed(pfn);\n}", "target": 0}
{"code": "static void add_password(AUTH_HDR *request, unsigned char type, CONST char *password, char *secret)\n{\n\tMD5_CTX md5_secret, my_md5;\n\tunsigned char misc[AUTH_VECTOR_LEN];\n\tint i;\n\tint length = strlen(password);\n\tunsigned char hashed[256 + AUTH_PASS_LEN];\t\n\tunsigned char *vector;\n\tattribute_t *attr;\n\tif (length > MAXPASS) {\t\t\t\t\n\t\tlength = MAXPASS;\n\t}\n\tif (length == 0) {\n\t\tlength = AUTH_PASS_LEN;\t\t\t\n\t} if ((length & (AUTH_PASS_LEN - 1)) != 0) {\n\t\tlength += (AUTH_PASS_LEN - 1);\t\t\n\t\tlength &= ~(AUTH_PASS_LEN - 1);\t\t\n\t}\t\t\t\t\t\t\n\tmemset(hashed, 0, length);\n\tmemcpy(hashed, password, strlen(password));\n\tattr = find_attribute(request, PW_PASSWORD);\n\tif (type == PW_PASSWORD) {\n\t\tvector = request->vector;\n\t} else {\n\t\tvector = attr->data;\t\t\t\n\t}\n\tMD5Init(&md5_secret);\n\tMD5Update(&md5_secret, (unsigned char *) secret, strlen(secret));\n\tmy_md5 = md5_secret;\t\t\t\t\n\tMD5Update(&my_md5, vector, AUTH_VECTOR_LEN);\n\tMD5Final(misc, &my_md5);\t\t\t\n\txor(hashed, misc, AUTH_PASS_LEN);\n\tfor (i = 1; i < (length >> 4); i++) {\n\t\tmy_md5 = md5_secret;\t\t\t\n\t\tMD5Update(&my_md5, &hashed[(i-1) * AUTH_PASS_LEN], AUTH_PASS_LEN);\n\t\tMD5Final(misc, &my_md5);\t\t\t\n\t\txor(&hashed[i * AUTH_PASS_LEN], misc, AUTH_PASS_LEN);\n\t}\n\tif (type == PW_OLD_PASSWORD) {\n\t\tattr = find_attribute(request, PW_OLD_PASSWORD);\n\t}\n\tif (!attr) {\n\t\tadd_attribute(request, type, hashed, length);\n\t} else {\n\t\tmemcpy(attr->data, hashed, length); \n\t}\n}", "target": 1}
{"code": "TEST_F(QueryPlannerTest, MaxMinBadHintSelectsReverseIndex) {\n    addIndex(BSON(\"a\" << 1));\n    addIndex(BSON(\"a\" << -1));\n    runInvalidQueryFull(BSONObj(),\n                        BSONObj(),\n                        BSONObj(),\n                        0,\n                        0,\n                        fromjson(\"{a: 1}\"),\n                        fromjson(\"{a: 8}\"),\n                        fromjson(\"{a: 2}\"),\n                        false);\n}", "target": 0}
{"code": "unsigned WebGraphicsContext3DDefaultImpl::createRenderbuffer()\n{\n    makeContextCurrent();\n    GLuint o;\n    glGenRenderbuffersEXT(1, &o);\n    return o;\n}", "target": 0}
{"code": "node_new_anychar(void)\n{\n  Node* node = node_new_ctype(CTYPE_ANYCHAR, 0, ONIG_OPTION_NONE);\n  return node;\n}", "target": 0}
{"code": "http_splitheader(struct http *hp, int req)\n{\n\tchar *p, *q, **hh;\n\tint n;\n\tchar buf[20];\n\tCHECK_OBJ_NOTNULL(hp, HTTP_MAGIC);\n\tif (req) {\n\t\tmemset(hp->req, 0, sizeof hp->req);\n\t\thh = hp->req;\n\t} else {\n\t\tmemset(hp->resp, 0, sizeof hp->resp);\n\t\thh = hp->resp;\n\t}\n\tn = 0;\n\tp = hp->rxbuf;\n\twhile (vct_islws(*p))\n\t\tp++;\n\thh[n++] = p;\n\twhile (!vct_islws(*p))\n\t\tp++;\n\tassert(!vct_iscrlf(*p));\n\t*p++ = '\\0';\n\twhile (vct_issp(*p))\t\t\n\t\tp++;\n\tassert(!vct_iscrlf(*p));\n\thh[n++] = p;\n\twhile (!vct_islws(*p))\n\t\tp++;\n\tif (vct_iscrlf(*p)) {\n\t\thh[n++] = NULL;\n\t\tq = p;\n\t\tp += vct_skipcrlf(p);\n\t\t*q = '\\0';\n\t} else {\n\t\t*p++ = '\\0';\n\t\twhile (vct_issp(*p))\t\t\n\t\t\tp++;\n\t\thh[n++] = p;\n\t\twhile (!vct_iscrlf(*p))\n\t\t\tp++;\n\t\tq = p;\n\t\tp += vct_skipcrlf(p);\n\t\t*q = '\\0';\n\t}\n\tassert(n == 3);\n\twhile (*p != '\\0') {\n\t\tassert(n < MAX_HDR);\n\t\tif (vct_iscrlf(*p))\n\t\t\tbreak;\n\t\thh[n++] = p++;\n\t\twhile (*p != '\\0' && !vct_iscrlf(*p))\n\t\t\tp++;\n\t\tq = p;\n\t\tp += vct_skipcrlf(p);\n\t\t*q = '\\0';\n\t}\n\tp += vct_skipcrlf(p);\n\tassert(*p == '\\0');\n\tfor (n = 0; n < 3 || hh[n] != NULL; n++) {\n\t\tsprintf(buf, \"http[%2d] \", n);\n\t\tvtc_dump(hp->vl, 4, buf, hh[n], -1);\n\t}\n}", "target": 1}
{"code": "cmd_readcert (assuan_context_t ctx, char *line)\n{\n  ctrl_t ctrl = assuan_get_pointer (ctx);\n  int rc;\n  unsigned char *cert;\n  size_t ncert;\n  if ((rc = open_card (ctrl, NULL)))\n    return rc;\n  line = xstrdup (line); \n  rc = app_readcert (ctrl->app_ctx, line, &cert, &ncert);\n  if (rc)\n    log_error (\"app_readcert failed: %s\\n\", gpg_strerror (rc));\n  xfree (line);\n  line = NULL;\n  if (!rc)\n    {\n      rc = assuan_send_data (ctx, cert, ncert);\n      xfree (cert);\n      if (rc)\n        return rc;\n    }\n  TEST_CARD_REMOVAL (ctrl, rc);\n  return rc;\n}", "target": 0}
{"code": "GF_Err gf_isom_last_error(GF_ISOFile *the_file)\n{\n\tif (!the_file) return MP4_API_IO_Err;\n\treturn the_file->LastError;\n}", "target": 0}
{"code": "const char *cgit_loginurl(void)\n{\n\tstatic const char *login_url;\n\tif (!login_url)\n\t\tlogin_url = fmtalloc(\"%s?p=login\", cgit_rooturl());\n\treturn login_url;\n}", "target": 0}
{"code": "gx_default_get_alpha_bits(gx_device * dev, graphics_object_type type)\n{\n    return (type == go_text ? dev->color_info.anti_alias.text_bits :\n            dev->color_info.anti_alias.graphics_bits);\n}", "target": 0}
{"code": "bool Archive::IsOpened()\n{\n#ifdef USE_ARCMEM\n  if (ArcMem.IsLoaded())\n    return true;\n#endif\n  return File::IsOpened();\n};", "target": 0}
{"code": "static char *r_buf_read_string (RBuffer *buf, ut64 addr, int len) {\n\tut8 *data = malloc (len);\n\tif (data) {\n\t\tr_buf_read_at (buf, addr, data, len);\n\t\tdata[len-1] = 0;\n\t\treturn data;\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "  void encode(bufferlist& bl) const {\n    __u8 struct_v = 1;\n    ::encode(struct_v, bl);\n    ::encode(server_challenge, bl);\n  }", "target": 0}
{"code": "void kvm_arch_flush_shadow_memslot(struct kvm *kvm,\n\t\t\t\t   struct kvm_memory_slot *slot)\n{\n\tkvm_arch_flush_shadow_all(kvm);\n}", "target": 0}
{"code": "ssize_t enc_untrusted_recvfrom(int sockfd, void *buf, size_t len, int flags,\n                               struct sockaddr *src_addr, socklen_t *addrlen) {\n  int klinux_flags = TokLinuxRecvSendFlag(flags);\n  if (klinux_flags == 0 && flags != 0) {\n    errno = EINVAL;\n    return -1;\n  }\n  MessageWriter input;\n  input.Push<int>(sockfd);\n  input.Push<uint64_t>(len);\n  input.Push<int>(klinux_flags);\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kRecvFromHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_recvfrom\", 4);\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return result;\n  }\n  if (result > len) {\n    ::asylo::primitives::TrustedPrimitives::BestEffortAbort(\n        \"enc_untrusted_recvfrom: result exceeds requested\");\n  }\n  auto buffer_received = output.next();\n  memcpy(buf, buffer_received.data(), std::min(len, buffer_received.size()));\n  if (src_addr != nullptr && addrlen != nullptr) {\n    auto klinux_sockaddr_buf = output.next();\n    const struct klinux_sockaddr *klinux_addr =\n        klinux_sockaddr_buf.As<struct klinux_sockaddr>();\n    FromkLinuxSockAddr(klinux_addr, klinux_sockaddr_buf.size(), src_addr,\n                       addrlen, TrustedPrimitives::BestEffortAbort);\n  }\n  return result;\n}", "target": 0}
{"code": "void StelScriptOutput::saveOutputAs(const QString &name)\n{\n\tQFile asFile;\n\tQFileInfo outputInfo(outputFile);\n\tQDir dir=outputInfo.dir(); \n\tQFileInfo newFileNameInfo(name);\n\tbool okToSaveToAbsolutePath=StelApp::getInstance().getSettings()->value(\"scripts/flag_script_allow_write_absolute_path\", false).toBool();\n\tif (!okToSaveToAbsolutePath && (newFileNameInfo.isAbsolute()))\n\t{\n\t\tqWarning() << \"SCRIPTING CONFIGURATION ISSUE: You are trying to save to an absolute pathname.\";\n\t\tqWarning() << \"  To enable this, edit config.ini and set [scripts]/flag_script_allow_write_absolute_path=true\";\n\t\tasFile.setFileName(dir.absolutePath() + \"/\" + newFileNameInfo.fileName());\n\t\tqWarning() << \"  Storing to \" << asFile.fileName() << \" instead\";\n\t}\n\telse if (okToSaveToAbsolutePath && (newFileNameInfo.isAbsolute()))\n\t{\n\t\tasFile.setFileName(name);\n\t}\n\telse\n\t{\n\t\tasFile.setFileName(dir.absolutePath() + \"/\" + name);\n\t}\n\tif (!asFile.open(QIODevice::WriteOnly | QIODevice::Truncate | QIODevice::Text | QIODevice::Unbuffered))\n\t{\n\t\tqDebug() << \"ERROR: Cannot open file\" << asFile.fileName();\n\t\treturn;\n\t}\n\tqDebug() << \"saving copy of output.txt to \" << asFile.fileName();\n\tasFile.write(qPrintable(outputText), outputText.size());\n\tasFile.close();\n}", "target": 1}
{"code": "static void stellaris_enet_save(QEMUFile *f, void *opaque)\n{\n    stellaris_enet_state *s = (stellaris_enet_state *)opaque;\n    int i;\n    qemu_put_be32(f, s->ris);\n    qemu_put_be32(f, s->im);\n    qemu_put_be32(f, s->rctl);\n    qemu_put_be32(f, s->tctl);\n    qemu_put_be32(f, s->thr);\n    qemu_put_be32(f, s->mctl);\n    qemu_put_be32(f, s->mdv);\n    qemu_put_be32(f, s->mtxd);\n    qemu_put_be32(f, s->mrxd);\n    qemu_put_be32(f, s->np);\n    qemu_put_be32(f, s->tx_fifo_len);\n    qemu_put_buffer(f, s->tx_fifo, sizeof(s->tx_fifo));\n    for (i = 0; i < 31; i++) {\n        qemu_put_be32(f, s->rx[i].len);\n        qemu_put_buffer(f, s->rx[i].data, sizeof(s->rx[i].data));\n    }\n    qemu_put_be32(f, s->next_packet);\n    qemu_put_be32(f, s->rx_fifo_offset);\n}", "target": 1}
{"code": "void LanLinkProvider::addLink(const QString& deviceId, QSslSocket* socket, NetworkPacket* receivedPacket, LanDeviceLink::ConnectionStarted connectionOrigin)\n{\n    disconnect(socket, &QAbstractSocket::disconnected, socket, &QObject::deleteLater);\n    LanDeviceLink* deviceLink;\n    QMap< QString, LanDeviceLink* >::iterator linkIterator = m_links.find(deviceId);\n    if (linkIterator != m_links.end()) {\n        deviceLink = linkIterator.value();\n        deviceLink->reset(socket, connectionOrigin);\n    } else {\n        deviceLink = new LanDeviceLink(deviceId, this, socket, connectionOrigin);\n        disconnect(socket, &QAbstractSocket::disconnected, socket, &QObject::deleteLater);\n        bool isDeviceTrusted = KdeConnectConfig::instance().trustedDevices().contains(deviceId);\n        if (!isDeviceTrusted && m_links.size() > MAX_UNPAIRED_CONNECTIONS) {\n            qCWarning(KDECONNECT_CORE) << \"Too many unpaired devices to remember them all. Ignoring \" << deviceId;\n            socket->disconnectFromHost();\n            socket->deleteLater();\n            return;\n        }\n        connect(deviceLink, &QObject::destroyed, this, &LanLinkProvider::deviceLinkDestroyed);\n        m_links[deviceId] = deviceLink;\n        if (m_pairingHandlers.contains(deviceId)) {\n            Q_ASSERT(m_pairingHandlers.contains(deviceId));\n            m_pairingHandlers[deviceId]->setDeviceLink(deviceLink);\n        }\n    }\n    Q_EMIT onConnectionReceived(*receivedPacket, deviceLink);\n}", "target": 0}
{"code": "static gboolean key_value_ok(gchar *key, gchar *value)\n{\n    char *i;\n    for (i = key; *i != 0; i++)\n    {\n        if (!isalpha(*i) && (*i != '-') && (*i != '_') && (*i != ' '))\n            return FALSE;\n    }\n    if (strcmp(key, \"basename\") == 0\n     || strcmp(key, FILENAME_TYPE) == 0\n    )\n    {\n        if (!is_correct_filename(value))\n        {\n            error_msg(\"Value of '%s' ('%s') is not a valid directory name\",\n                      key, value);\n            return FALSE;\n        }\n    }\n    return TRUE;\n}", "target": 1}
{"code": "sudo_auth_init(const struct sudoers_context *ctx, struct passwd *pw,\n    unsigned int mode)\n{\n    sudo_auth *auth;\n    int status = AUTH_SUCCESS;\n    debug_decl(sudo_auth_init, SUDOERS_DEBUG_AUTH);\n    if (auth_switch[0].name == NULL)\n\tdebug_return_int(0);\n    for (auth = auth_switch; auth->name; auth++) {\n\tif (ISSET(mode, MODE_NONINTERACTIVE))\n\t    SET(auth->flags, FLAG_NONINTERACTIVE);\n\tif (auth->init && !IS_DISABLED(auth)) {\n\t    status = (auth->init)(ctx, pw, auth);\n\t    if (status == AUTH_FAILURE)\n\t\tSET(auth->flags, FLAG_DISABLED);\n\t    else if (status == AUTH_ERROR)\n\t\tbreak;\t\t\n\t}\n    }\n    if ((standalone = IS_STANDALONE(&auth_switch[0]))) {\n\tbool found = false;\n\tfor (auth = auth_switch; auth->name; auth++) {\n\t    if (IS_DISABLED(auth))\n\t\tcontinue;\n\t    if (!IS_STANDALONE(auth)) {\n\t\taudit_failure(ctx, ctx->runas.argv,\n\t\t    N_(\"invalid authentication methods\"));\n\t\tlog_warningx(ctx, SLOG_SEND_MAIL,\n\t\t    N_(\"Invalid authentication methods compiled into sudo!  \"\n\t\t    \"You may not mix standalone and non-standalone authentication.\"));\n\t\tdebug_return_int(-1);\n\t    }\n\t    if (!found) {\n\t\tfound = true;\n\t\tcontinue;\n\t    }\n\t    SET(auth->flags, FLAG_DISABLED);\n\t}\n    }\n    for (auth = auth_switch; auth->name; auth++) {\n\tif (!IS_DISABLED(auth)) {\n\t    sudo_auth *first = auth;\n\t    for (; auth->name; auth++) {\n\t\tif (!IS_DISABLED(auth))\n\t\t    break;\n\t    }\n\t    if (auth->name == NULL)\n\t\tSET(first->flags, FLAG_ONEANDONLY);\n\t    break;\n\t}\n    }\n    debug_return_int(status == AUTH_ERROR ? -1 : 0);\n}", "target": 1}
{"code": "  virtual void ForgetWifiNetwork(const std::string& service_path) {}", "target": 0}
{"code": "bool IsConstantFoldable(\n    const Node* n,\n    const std::unordered_map<string, std::vector<PartialTensorShape>>*\n        shape_map,\n    const std::function<bool(const Node*)>& consider,\n    int64_t max_constant_size_in_bytes,\n    std::unordered_map<const Node*, std::vector<Tensor>>*\n        shape_replacement_map) {\n  if (n->IsConstant()) {\n    return true;\n  }\n  if (MaybeReplaceShapeOp(n, shape_map, shape_replacement_map)) {\n    return true;\n  }\n  if (n->op_def().is_stateful()) {\n    return false;\n  }\n  if (consider && !consider(n)) {\n    return false;\n  }\n  if (shape_map != nullptr) {\n    auto shape_it = shape_map->find(n->name());\n    if (shape_it != shape_map->end()) {\n      for (int64_t i = 0; i < shape_it->second.size(); ++i) {\n        const auto& out_shape = shape_it->second[i];\n        if (out_shape.IsFullyDefined() &&\n            out_shape.num_elements() * DataTypeSize(n->output_type(i)) >\n                max_constant_size_in_bytes) {\n          return false;\n        }\n      }\n    }\n  }\n  if (n->IsControlFlow() || n->IsSend() || n->IsRecv()) {\n    return false;\n  }\n  if (n->IsGetSessionHandle() || n->IsGetSessionTensor() ||\n      n->IsDeleteSessionTensor()) {\n    return false;\n  }\n  if (n->IsSource()) {\n    return false;\n  }\n  if (n->IsSink()) {\n    return false;\n  }\n  if (n->IsFakeParam()) {\n    return false;\n  }\n  if (!KernelDefAvailable(DeviceType(DEVICE_CPU), n->def())) {\n    return false;\n  }\n  if (n->attrs().Find(kScopedAllocatorAttrName) != nullptr) {\n    VLOG(2) << \"Skip node [\" << n->DebugString()\n            << \"] for constant folding due to scoped allocator\";\n    return false;\n  }\n  return true;\n}", "target": 1}
{"code": "get_word_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    register unsigned int temp;\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n    *ptr++ = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n    *ptr++ = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n    *ptr++ = rescale[temp];\n  }\n  return 1;\n}", "target": 1}
{"code": "R_API RBinJavaAttrInfo *r_bin_java_source_code_file_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tif (!sz) {\n\t\treturn NULL;\n\t}\n\tut64 offset = 0;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\toffset += 6;\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_SOURCE_FILE_ATTR;\n\tattr->info.source_file_attr.sourcefile_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->size = offset;\n\treturn attr;\n}", "target": 1}
{"code": "static int sco_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sco_pinfo *pi = sco_pi(sk);\n\tlock_sock(sk);\n\tif (sk->sk_state == BT_CONNECT2 &&\n\t    test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags)) {\n\t\tsco_conn_defer_accept(pi->conn->hcon, pi->setting);\n\t\tsk->sk_state = BT_CONFIG;\n\t\tmsg->msg_namelen = 0;\n\t\trelease_sock(sk);\n\t\treturn 0;\n\t}\n\trelease_sock(sk);\n\treturn bt_sock_recvmsg(iocb, sock, msg, len, flags);\n}", "target": 1}
{"code": "DLLIMPORT int cfg_rmnsec(cfg_t *cfg, const char *name, unsigned int index)\n{\n\treturn cfg_opt_rmnsec(cfg_getopt(cfg, name), index);\n}", "target": 0}
{"code": "mm_sync_list(struct mmtree *oldtree, struct mmtree *newtree,\n    struct mm_master *mm, struct mm_master *mmold)\n{\n\tstruct mm_master *mmalloc = mm->mmalloc;\n\tstruct mm_share *mms, *new;\n\tRB_FOREACH(mms, mmtree, oldtree) {\n\t\tmm_memvalid(mmold, mms, sizeof(struct mm_share));\n\t\tmm_memvalid(mm, mms->address, mms->size);\n\t\tnew = mm_xmalloc(mmalloc, sizeof(struct mm_share));\n\t\tmemcpy(new, mms, sizeof(struct mm_share));\n\t\tRB_INSERT(mmtree, newtree, new);\n\t}\n}", "target": 1}
{"code": "static inline int udp4_csum_init(struct sk_buff *skb, struct udphdr *uh,\n\t\t\t\t int proto)\n{\n\tint err;\n\tUDP_SKB_CB(skb)->partial_cov = 0;\n\tUDP_SKB_CB(skb)->cscov = skb->len;\n\tif (proto == IPPROTO_UDPLITE) {\n\t\terr = udplite_checksum_init(skb, uh);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn skb_checksum_init_zero_check(skb, proto, uh->check,\n\t\t\t\t\t    inet_compute_pseudo);\n}", "target": 0}
{"code": "static bool check_buffer(RBinFile *bf, RBuffer *b) {\n\tut8 buf[4];\n\tr_buf_read_at (b, 0, buf, sizeof (buf));\n\treturn !memcmp (buf, \"\\x02\\xff\\x01\\xff\", 4);\n}", "target": 0}
{"code": "void color_cmyk_to_rgb(opj_image_t *image)\n{\n\tfloat C, M, Y, K;\n\tfloat sC, sM, sY, sK;\n\tunsigned int w, h, max, i;\n\tw = image->comps[0].w;\n\th = image->comps[0].h;\n\tif(image->numcomps < 4) return;\n\tmax = w * h;\n\tsC = 1.0F / (float)((1 << image->comps[0].prec) - 1);\n\tsM = 1.0F / (float)((1 << image->comps[1].prec) - 1);\n\tsY = 1.0F / (float)((1 << image->comps[2].prec) - 1);\n\tsK = 1.0F / (float)((1 << image->comps[3].prec) - 1);\n\tfor(i = 0; i < max; ++i)\n\t{\n\t\tC = (float)(image->comps[0].data[i]) * sC;\n\t\tM = (float)(image->comps[1].data[i]) * sM;\n\t\tY = (float)(image->comps[2].data[i]) * sY;\n\t\tK = (float)(image->comps[3].data[i]) * sK;\n\t\tC = 1.0F - C;\n\t\tM = 1.0F - M;\n\t\tY = 1.0F - Y;\n\t\tK = 1.0F - K;\n\t\timage->comps[0].data[i] = (int)(255.0F * C * K); \n\t\timage->comps[1].data[i] = (int)(255.0F * M * K); \n\t\timage->comps[2].data[i] = (int)(255.0F * Y * K); \n\t}\n\tfree(image->comps[3].data); image->comps[3].data = NULL;\n\timage->comps[0].prec = 8;\n\timage->comps[1].prec = 8;\n\timage->comps[2].prec = 8;\n\timage->numcomps -= 1;\n\timage->color_space = OPJ_CLRSPC_SRGB;\n\tfor (i = 3; i < image->numcomps; ++i) {\n\t\tmemcpy(&(image->comps[i]), &(image->comps[i+1]), sizeof(image->comps[i]));\n\t}\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    const Tensor& grad_in = context->input(1);\n    const Tensor& argmax = context->input(2);\n    PoolParameters params{context,\n                          ksize_,\n                          stride_,\n                          padding_,\n                          {},\n                          FORMAT_NHWC,\n                          tensor_in.shape()};\n    if (!context->status().ok()) {\n      return;\n    }\n    TensorShape out_shape({params.tensor_in_batch, params.tensor_in_rows,\n                           params.tensor_in_cols, params.depth});\n    Tensor* grad_out = nullptr;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                {0}, 0, out_shape, &grad_out));\n    if (out_shape.num_elements() == 0) return;  \n    LaunchMaxPoolingGradWithArgmax<Device, T>::launch(\n        context, params, grad_in, argmax, grad_out, include_batch_in_index_);\n  }", "target": 0}
{"code": "void test_rmdir(const char *path)\n{\n\tsize_t len = strlen(path) + 30;\n\tchar *tmpname = alloca(len);\n\tsnprintf(tmpname, len, \"%s/%d\", path, (int)getpid());\n\tif (rmdir(path) == 0 || errno != ENOENT) {\n\t\tfprintf(stderr, \"leak at rmdir of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (rmdir(tmpname) == 0 || errno != ENOENT) {\n\t\tfprintf(stderr, \"leak at rmdir of %s\\n\", tmpname);\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "static void sctp_sock_rfree_frag(struct sk_buff *skb)\n{\n\tstruct sk_buff *frag;\n\tif (!skb->data_len)\n\t\tgoto done;\n\tfor (frag = skb_shinfo(skb)->frag_list; frag; frag = frag->next)\n\t\tsctp_sock_rfree_frag(frag);\ndone:\n\tsctp_sock_rfree(skb);\n}", "target": 0}
{"code": "extract_argv (EvDocument *document, gint page)\n{\n\tComicsDocument *comics_document = COMICS_DOCUMENT (document);\n\tchar **argv;\n\tchar *command_line, *quoted_archive, *quoted_filename;\n\tGError *err = NULL;\n\tif (g_strrstr (comics_document->page_names->pdata[page], \"--checkpoint-action=\"))\n\t{\n\t\tg_warning (\"File unsupported\\n\");\n\t\tgtk_main_quit ();\n\t}\n        if (page >= comics_document->page_names->len)\n                return NULL;\n\tif (comics_document->regex_arg) {\n\t\tquoted_archive = g_shell_quote (comics_document->archive);\n\t\tquoted_filename =\n\t\t\tcomics_regex_quote (comics_document->page_names->pdata[page]);\n\t} else {\n\t\tquoted_archive = g_shell_quote (comics_document->archive);\n\t\tquoted_filename = g_shell_quote (comics_document->page_names->pdata[page]);\n\t}\n\tcommand_line = g_strdup_printf (\"%s %s %s\",\n\t\t\t\t\tcomics_document->extract_command,\n\t\t\t\t\tquoted_archive,\n\t\t\t\t\tquoted_filename);\n\tg_free (quoted_archive);\n\tg_free (quoted_filename);\n\tg_shell_parse_argv (command_line, NULL, &argv, &err);\n\tg_free (command_line);\n\tif (err) {\n\t\tg_warning (_(\"Error %s\"), err->message);\n\t\tg_error_free (err);\n\t\treturn NULL;\n\t}\n\treturn argv;\n}", "target": 1}
{"code": "static void consume_one_event(unsigned cpu,\n\t\t\t      struct evtchn_fifo_control_block *control_block,\n\t\t\t      unsigned priority, unsigned long *ready,\n\t\t\t      bool drop)\n{\n\tstruct evtchn_fifo_queue *q = &per_cpu(cpu_queue, cpu);\n\tuint32_t head;\n\tevtchn_port_t port;\n\tevent_word_t *word;\n\thead = q->head[priority];\n\tif (head == 0) {\n\t\tvirt_rmb(); \n\t\thead = control_block->head[priority];\n\t}\n\tport = head;\n\tword = event_word_from_port(port);\n\thead = clear_linked(word);\n\tif (head == 0)\n\t\tclear_bit(priority, ready);\n\tif (evtchn_fifo_is_pending(port) && !evtchn_fifo_is_masked(port)) {\n\t\tif (unlikely(drop))\n\t\t\tpr_warn(\"Dropping pending event for port %u\\n\", port);\n\t\telse\n\t\t\thandle_irq_for_port(port);\n\t}\n\tq->head[priority] = head;\n}", "target": 1}
{"code": "parse_tsquery(char *buf,\n\t\t\t  PushFunction pushval,\n\t\t\t  Datum opaque,\n\t\t\t  bool isplain)\n{\n\tstruct TSQueryParserStateData state;\n\tint\t\t\ti;\n\tTSQuery\t\tquery;\n\tint\t\t\tcommonlen;\n\tQueryItem  *ptr;\n\tListCell   *cell;\n\tstate.buffer = buf;\n\tstate.buf = buf;\n\tstate.state = (isplain) ? WAITSINGLEOPERAND : WAITFIRSTOPERAND;\n\tstate.count = 0;\n\tstate.polstr = NIL;\n\tstate.valstate = init_tsvector_parser(state.buffer, true, true);\n\tstate.sumlen = 0;\n\tstate.lenop = 64;\n\tstate.curop = state.op = (char *) palloc(state.lenop);\n\t*(state.curop) = '\\0';\n\tmakepol(&state, pushval, opaque);\n\tclose_tsvector_parser(state.valstate);\n\tif (list_length(state.polstr) == 0)\n\t{\n\t\tereport(NOTICE,\n\t\t\t\t(errmsg(\"text-search query doesn't contain lexemes: \\\"%s\\\"\",\n\t\t\t\t\t\tstate.buffer)));\n\t\tquery = (TSQuery) palloc(HDRSIZETQ);\n\t\tSET_VARSIZE(query, HDRSIZETQ);\n\t\tquery->size = 0;\n\t\treturn query;\n\t}\n\tcommonlen = COMPUTESIZE(list_length(state.polstr), state.sumlen);\n\tquery = (TSQuery) palloc0(commonlen);\n\tSET_VARSIZE(query, commonlen);\n\tquery->size = list_length(state.polstr);\n\tptr = GETQUERY(query);\n\ti = 0;\n\tforeach(cell, state.polstr)\n\t{\n\t\tQueryItem  *item = (QueryItem *) lfirst(cell);\n\t\tswitch (item->type)\n\t\t{\n\t\t\tcase QI_VAL:\n\t\t\t\tmemcpy(&ptr[i], item, sizeof(QueryOperand));\n\t\t\t\tbreak;\n\t\t\tcase QI_VALSTOP:\n\t\t\t\tptr[i].type = QI_VALSTOP;\n\t\t\t\tbreak;\n\t\t\tcase QI_OPR:\n\t\t\t\tmemcpy(&ptr[i], item, sizeof(QueryOperator));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized QueryItem type: %d\", item->type);\n\t\t}\n\t\ti++;\n\t}\n\tmemcpy((void *) GETOPERAND(query), (void *) state.op, state.sumlen);\n\tpfree(state.op);\n\tfindoprnd(ptr, query->size);\n\treturn query;\n}", "target": 1}
{"code": "get_strings_2_svc(gstrings_arg *arg, struct svc_req *rqstp)\n{\n    static gstrings_ret             ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_gstrings_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (! cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ) &&\n        (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                        rqst2name(rqstp),\n                                                        ACL_INQUIRE,\n                                                        arg->princ,\n                                                        NULL))) {\n        ret.code = KADM5_AUTH_GET;\n        log_unauth(\"kadm5_get_strings\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_get_strings((void *)handle, arg->princ, &ret.strings,\n                                     &ret.count);\n        if (ret.code != 0)\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_get_strings\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "pci_emul_cmdsts_write(struct pci_vdev *dev, int coff, uint32_t new, int bytes)\n{\n\tint i, rshift;\n\tuint32_t cmd, cmd2, changed, old, readonly;\n\tcmd = pci_get_cfgdata16(dev, PCIR_COMMAND);\t\n\trshift = (coff & 0x3) * 8;\n\treadonly = 0xFFFFF880 >> rshift;\n\told = CFGREAD(dev, coff, bytes);\n\tnew &= ~readonly;\n\tnew |= (old & readonly);\n\tCFGWRITE(dev, coff, new, bytes);\t\t\n\tcmd2 = pci_get_cfgdata16(dev, PCIR_COMMAND);\t\n\tchanged = cmd ^ cmd2;\n\tfor (i = 0; i <= PCI_BARMAX; i++) {\n\t\tswitch (dev->bar[i].type) {\n\t\tcase PCIBAR_NONE:\n\t\tcase PCIBAR_MEMHI64:\n\t\t\tbreak;\n\t\tcase PCIBAR_IO:\n\t\t\tif (changed & PCIM_CMD_PORTEN) {\n\t\t\t\tif (porten(dev))\n\t\t\t\t\tregister_bar(dev, i);\n\t\t\t\telse\n\t\t\t\t\tunregister_bar(dev, i);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PCIBAR_MEM32:\n\t\tcase PCIBAR_MEM64:\n\t\t\tif (changed & PCIM_CMD_MEMEN) {\n\t\t\t\tif (memen(dev))\n\t\t\t\t\tregister_bar(dev, i);\n\t\t\t\telse\n\t\t\t\t\tunregister_bar(dev, i);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(0);\n\t\t}\n\t}\n\tpci_lintr_update(dev);\n}", "target": 1}
{"code": "void _single_copy_to_wide( SQLWCHAR *out, LPCSTR in, int len )\n{\n    while ( len >= 0 )\n    {\n        *out = *in;\n        out++;\n        in++;\n        len --;\n    }\n}", "target": 0}
{"code": "static int iax2_do_register(struct iax2_registry *reg)\n{\n\tstruct iax_ie_data ied;\n\tif (iaxdebug)\n\t\tast_debug(1, \"Sending registration request for '%s'\\n\", reg->username);\n\tif (reg->dnsmgr && \n\t    ((reg->regstate == REG_STATE_TIMEOUT) || !reg->addr.sin_addr.s_addr)) {\n\t\tast_dnsmgr_refresh(reg->dnsmgr);\n\t}\n\tif (reg->dnsmgr && ast_dnsmgr_changed(reg->dnsmgr) && (reg->callno > 0)) {\n\t\tast_mutex_lock(&iaxsl[reg->callno]);\n\t\tiax2_destroy(reg->callno);\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t\treg->callno = 0;\n\t}\n\tif (!reg->addr.sin_addr.s_addr) {\n\t\tif (iaxdebug)\n\t\t\tast_debug(1, \"Unable to send registration request for '%s' without IP address\\n\", reg->username);\n\t\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t\treturn -1;\n\t}\n\tif (!reg->callno) {\n\t\tast_debug(1, \"Allocate call number\\n\");\n\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd);\n\t\tif (reg->callno < 1) {\n\t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n\t\t\treturn -1;\n\t\t} else\n\t\t\tast_debug(1, \"Registration created on call %d\\n\", reg->callno);\n\t\tiaxs[reg->callno]->reg = reg;\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t}\n\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_str(&ied, IAX_IE_USERNAME, reg->username);\n\tiax_ie_append_short(&ied, IAX_IE_REFRESH, reg->refresh);\n\tsend_command(iaxs[reg->callno],AST_FRAME_IAX, IAX_COMMAND_REGREQ, 0, ied.buf, ied.pos, -1);\n\treg->regstate = REG_STATE_REGSENT;\n\treturn 0;\n}", "target": 1}
{"code": "void LIRGenerator::do_BlockBegin(BlockBegin* x) {\n}", "target": 0}
{"code": "void __meminit setup_zone_pageset(struct zone *zone)\n{\n\tint cpu;\n\tzone->pageset = alloc_percpu(struct per_cpu_pageset);\n\tfor_each_possible_cpu(cpu)\n\t\tzone_pageset_init(zone, cpu);\n}", "target": 0}
{"code": "static struct rpmsg_device *rpmsg_virtio_add_ctrl_dev(struct virtio_device *vdev)\n{\n\tstruct virtproc_info *vrp = vdev->priv;\n\tstruct virtio_rpmsg_channel *vch;\n\tstruct rpmsg_device *rpdev_ctrl;\n\tint err = 0;\n\tvch = kzalloc(sizeof(*vch), GFP_KERNEL);\n\tif (!vch)\n\t\treturn ERR_PTR(-ENOMEM);\n\tvch->vrp = vrp;\n\trpdev_ctrl = &vch->rpdev;\n\trpdev_ctrl->ops = &virtio_rpmsg_ops;\n\trpdev_ctrl->dev.parent = &vrp->vdev->dev;\n\trpdev_ctrl->dev.release = virtio_rpmsg_release_device;\n\trpdev_ctrl->little_endian = virtio_is_little_endian(vrp->vdev);\n\terr = rpmsg_ctrldev_register_device(rpdev_ctrl);\n\tif (err) {\n\t\tkfree(vch);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn rpdev_ctrl;\n}", "target": 1}
{"code": "nfsd4_encode_layoutget(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\tstruct nfsd4_layoutget *lgp)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tconst struct nfsd4_layout_ops *ops =\n\t\tnfsd4_layout_ops[lgp->lg_layout_type];\n\t__be32 *p;\n\tdprintk(\"%s: err %d\\n\", __func__, nfserr);\n\tif (nfserr)\n\t\tgoto out;\n\tnfserr = nfserr_resource;\n\tp = xdr_reserve_space(xdr, 36 + sizeof(stateid_opaque_t));\n\tif (!p)\n\t\tgoto out;\n\t*p++ = cpu_to_be32(1);\t\n\t*p++ = cpu_to_be32(lgp->lg_sid.si_generation);\n\tp = xdr_encode_opaque_fixed(p, &lgp->lg_sid.si_opaque,\n\t\t\t\t    sizeof(stateid_opaque_t));\n\t*p++ = cpu_to_be32(1);\t\n\tp = xdr_encode_hyper(p, lgp->lg_seg.offset);\n\tp = xdr_encode_hyper(p, lgp->lg_seg.length);\n\t*p++ = cpu_to_be32(lgp->lg_seg.iomode);\n\t*p++ = cpu_to_be32(lgp->lg_layout_type);\n\tnfserr = ops->encode_layoutget(xdr, lgp);\nout:\n\tkfree(lgp->lg_content);\n\treturn nfserr;\n}", "target": 1}
{"code": "void RenderView::OnShouldClose() {\n  bool should_close = webview()->dispatchBeforeUnloadEvent();\n  Send(new ViewHostMsg_ShouldClose_ACK(routing_id_, should_close));\n}", "target": 0}
{"code": "static int __init random_int_secret_init(void)\n{\n\tget_random_bytes(random_int_secret, sizeof(random_int_secret));\n\treturn 0;\n}", "target": 0}
{"code": "usm_malloc_usmStateReference(void)\n{\n    struct usmStateReference *retval = (struct usmStateReference *)\n        calloc(1, sizeof(struct usmStateReference));\n    return retval;\n}                               ", "target": 1}
{"code": "mm_freelist(struct mm_master *mmalloc, struct mmtree *head)\n{\n\tstruct mm_share *mms, *next;\n\tfor (mms = RB_ROOT(head); mms; mms = next) {\n\t\tnext = RB_NEXT(mmtree, head, mms);\n\t\tRB_REMOVE(mmtree, head, mms);\n\t\tif (mmalloc == NULL)\n\t\t\tfree(mms);\n\t\telse\n\t\t\tmm_free(mmalloc, mms);\n\t}\n}", "target": 1}
{"code": "int LibRaw::dcraw_thumb_writer(const char *fname)\n{\n  if(!fname) \n    return ENOENT;\n  FILE *tfp = fopen(fname,\"wb\");\n  if(!tfp) \n    return errno;\n  if(!T.thumb)\n    {\n      fclose(tfp);\n      return LIBRAW_OUT_OF_ORDER_CALL;\n    }\n  try {\n    switch (T.tformat)\n      {\n      case LIBRAW_THUMBNAIL_JPEG:\n        jpeg_thumb_writer (tfp,T.thumb,T.tlength);\n        break;\n      case LIBRAW_THUMBNAIL_BITMAP:\n        fprintf (tfp, \"P6\\n%d %d\\n255\\n\", T.twidth, T.theight);\n        fwrite (T.thumb, 1, T.tlength, tfp);\n        break;\n      default:\n        fclose(tfp);\n        return LIBRAW_UNSUPPORTED_THUMBNAIL;\n      }\n    fclose(tfp);\n    return 0;\n  }\n  catch ( LibRaw_exceptions err) {\n    fclose(tfp);\n    EXCEPTION_HANDLER(err);\n  }\n}", "target": 0}
{"code": "int usbredirparser_have_peer_caps(struct usbredirparser *parser_pub)\n{\n    struct usbredirparser_priv *parser =\n        (struct usbredirparser_priv *)parser_pub;\n    return parser->have_peer_caps;\n}", "target": 0}
{"code": "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1);\n}", "target": 1}
{"code": "  explicit SparseFillEmptyRowsGPUOp(OpKernelConstruction* context)\n      : AsyncOpKernel(context) {}", "target": 0}
{"code": "static int count_args(const char **argv)\n{\n\tint i = 0;\n\tif (argv) {\n\t\twhile (argv[i] != NULL)\n\t\t\ti++;\n\t}\n\treturn i;\n}", "target": 0}
{"code": "static int snd_seq_ioctl_remove_events(struct snd_seq_client *client,\n\t\t\t\t       void __user *arg)\n{\n\tstruct snd_seq_remove_events info;\n\tif (copy_from_user(&info, arg, sizeof(info)))\n\t\treturn -EFAULT;\n\tif (info.remove_mode & SNDRV_SEQ_REMOVE_INPUT) {\n\t\tif (client->type == USER_CLIENT)\n\t\t\tsnd_seq_fifo_clear(client->data.user.fifo);\n\t}\n\tif (info.remove_mode & SNDRV_SEQ_REMOVE_OUTPUT)\n\t\tsnd_seq_queue_remove_cells(client->number, &info);\n\treturn 0;\n}", "target": 1}
{"code": "static int64_t adjust_scale(int64_t scale) {\n  if (scale < 0) {\n    scale = BCG(bc_precision);\n    if (scale < 0) scale = 0;\n  }\n  if ((uint64_t)scale > StringData::MaxSize) return StringData::MaxSize;\n  return scale;\n}", "target": 0}
{"code": "test(int equal, const char *user_input, const char *secret)\n{\n    int out = password_equal(user_input, secret);\n    printf(\"%s: \\\"%s\\\" \\\"%s\\\"\\n\",\n        (equal == out) ? \"PASS\" : \"FAIL\",\n        user_input, secret);\n}", "target": 0}
{"code": "    std::string Converter::computeExifDigest(bool)\n    {\n        return std::string(\"\");\n    }", "target": 0}
{"code": "static int adpt_i2o_enable_hba(adpt_hba* pHba)\n{\n\tu32 msg[4];\n\tint ret;\n\tadpt_i2o_status_get(pHba);\n\tif(!pHba->status_block){\n\t\treturn -ENOMEM;\n\t}\n\tif(pHba->status_block->iop_state == ADAPTER_STATE_OPERATIONAL)\n\t\treturn 0;\n\tif(pHba->status_block->iop_state != ADAPTER_STATE_READY)\n\t\treturn -EINVAL;\n\tmsg[0]=FOUR_WORD_MSG_SIZE|SGL_OFFSET_0;\n\tmsg[1]=I2O_CMD_SYS_ENABLE<<24|HOST_TID<<12|ADAPTER_TID;\n\tmsg[2]= 0;\n\tmsg[3]= 0;\n\tif ((ret = adpt_i2o_post_wait(pHba, msg, sizeof(msg), 240))) {\n\t\tprintk(KERN_WARNING\"%s: Could not enable (status=%#10x).\\n\", \n\t\t\tpHba->name, ret);\n\t} else {\n\t\tPDEBUG(\"%s: Enabled.\\n\", pHba->name);\n\t}\n\tadpt_i2o_status_get(pHba);\n\treturn ret;\n}", "target": 1}
{"code": "void SMsgReader::readExtendedClipboard(rdr::S32 len)\n{\n  rdr::U32 flags;\n  rdr::U32 action;\n  if (len < 4)\n    throw Exception(\"Invalid extended clipboard message\");\n  if (len > maxCutText) {\n    vlog.error(\"Extended clipboard message too long (%d bytes) - ignoring\", len);\n    is->skip(len);\n    return;\n  }\n  flags = is->readU32();\n  action = flags & clipboardActionMask;\n  if (action & clipboardCaps) {\n    int i;\n    size_t num;\n    rdr::U32 lengths[16];\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (flags & (1 << i))\n        num++;\n    }\n    if (len < (rdr::S32)(4 + 4*num))\n      throw Exception(\"Invalid extended clipboard message\");\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (flags & (1 << i))\n        lengths[num++] = is->readU32();\n    }\n    handler->handleClipboardCaps(flags, lengths);\n  } else if (action == clipboardProvide) {\n    rdr::ZlibInStream zis;\n    int i;\n    size_t num;\n    size_t lengths[16];\n    rdr::U8* buffers[16];\n    zis.setUnderlying(is, len - 4);\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (!(flags & 1 << i))\n        continue;\n      lengths[num] = zis.readU32();\n      if (lengths[num] > (size_t)maxCutText) {\n        vlog.error(\"Extended clipboard data too long (%d bytes) - ignoring\",\n                   (unsigned)lengths[num]);\n        zis.skip(lengths[num]);\n        flags &= ~(1 << i);\n        continue;\n      }\n      buffers[num] = new rdr::U8[lengths[num]];\n      zis.readBytes(buffers[num], lengths[num]);\n      num++;\n    }\n    zis.removeUnderlying();\n    handler->handleClipboardProvide(flags, lengths, buffers);\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (!(flags & 1 << i))\n        continue;\n      delete [] buffers[num++];\n    }\n  } else {\n    switch (action) {\n    case clipboardRequest:\n      handler->handleClipboardRequest(flags);\n      break;\n    case clipboardPeek:\n      handler->handleClipboardPeek(flags);\n      break;\n    case clipboardNotify:\n      handler->handleClipboardNotify(flags);\n      break;\n    default:\n      throw Exception(\"Invalid extended clipboard action\");\n    }\n  }\n}", "target": 1}
{"code": "static void JP2WarningHandler(const char *message,void *client_data)\n{\n  ExceptionInfo\n    *exception;\n  exception=(ExceptionInfo *) client_data;\n  (void) ThrowMagickException(exception,GetMagickModule(),CoderWarning,\n    message,\"`%s'\",\"OpenJP2\");\n}", "target": 0}
{"code": "const char* ExpressionRandom::getOpName() const {\n    return \"$rand\";\n}", "target": 0}
{"code": "struct l2tp_packet_t *l2tp_packet_alloc(int ver, int msg_type,\n\t\t\t\t\tconst struct sockaddr_in *addr, int H,\n\t\t\t\t\tconst char *secret, size_t secret_len)\n{\n\tstruct l2tp_packet_t *pack = mempool_alloc(pack_pool);\n\tif (!pack)\n\t\treturn NULL;\n\tmemset(pack, 0, sizeof(*pack));\n\tINIT_LIST_HEAD(&pack->attrs);\n\tpack->hdr.ver = ver;\n\tpack->hdr.T = 1;\n\tpack->hdr.L = 1;\n\tpack->hdr.S = 1;\n\tmemcpy(&pack->addr, addr, sizeof(*addr));\n\tpack->hide_avps = H;\n\tpack->secret = secret;\n\tpack->secret_len = secret_len;\n\tif (msg_type) {\n\t\tif (l2tp_packet_add_int16(pack, Message_Type, msg_type, 1)) {\n\t\t\tmempool_free(pack);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn pack;\n}", "target": 1}
{"code": "static int dispatch_discard_io(struct xen_blkif *blkif,\n\t\t\t\tstruct blkif_request *req)\n{\n\tint err = 0;\n\tint status = BLKIF_RSP_OKAY;\n\tstruct block_device *bdev = blkif->vbd.bdev;\n\tunsigned long secure;\n\tblkif->st_ds_req++;\n\txen_blkif_get(blkif);\n\tsecure = (blkif->vbd.discard_secure &&\n\t\t (req->u.discard.flag & BLKIF_DISCARD_SECURE)) ?\n\t\t BLKDEV_DISCARD_SECURE : 0;\n\terr = blkdev_issue_discard(bdev, req->u.discard.sector_number,\n\t\t\t\t   req->u.discard.nr_sectors,\n\t\t\t\t   GFP_KERNEL, secure);\n\tif (err == -EOPNOTSUPP) {\n\t\tpr_debug(DRV_PFX \"discard op failed, not supported\\n\");\n\t\tstatus = BLKIF_RSP_EOPNOTSUPP;\n\t} else if (err)\n\t\tstatus = BLKIF_RSP_ERROR;\n\tmake_response(blkif, req->u.discard.id, req->operation, status);\n\txen_blkif_put(blkif);\n\treturn err;\n}", "target": 1}
{"code": "comics_remove_dir (gchar *path_name)\n{\n\tGDir  *content_dir;\n\tconst gchar *filename;\n\tgchar *filename_with_path;\n\tif (g_file_test (path_name, G_FILE_TEST_IS_DIR)) {\n\t\tcontent_dir = g_dir_open  (path_name, 0, NULL);\n\t\tfilename  = g_dir_read_name (content_dir);\n\t\twhile (filename) {\n\t\t\tfilename_with_path =\n\t\t\t\tg_build_filename (path_name,\n\t\t\t\t\t\t  filename, NULL);\n\t\t\tcomics_remove_dir (filename_with_path);\n\t\t\tg_free (filename_with_path);\n\t\t\tfilename = g_dir_read_name (content_dir);\n\t\t}\n\t\tg_dir_close (content_dir);\n\t}\n\treturn (g_remove (path_name));\n}", "target": 1}
{"code": "static __u8 *sp_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 107 && rdesc[104] == 0x26 && rdesc[105] == 0x80 &&\n\t\t\trdesc[106] == 0x03) {\n\t\thid_info(hdev, \"fixing up Sunplus Wireless Desktop report descriptor\\n\");\n\t\trdesc[105] = rdesc[110] = 0x03;\n\t\trdesc[106] = rdesc[111] = 0x21;\n\t}\n\treturn rdesc;\n}", "target": 1}
{"code": "struct r_bin_dyldcache_obj_t* r_bin_dyldcache_from_bytes_new(const ut8* buf, ut64 size) {\n\tstruct r_bin_dyldcache_obj_t *bin;\n\tif (!(bin = malloc (sizeof (struct r_bin_dyldcache_obj_t)))) {\n\t\treturn NULL;\n\t}\n\tmemset (bin, 0, sizeof (struct r_bin_dyldcache_obj_t));\n\tif (!buf) {\n\t\treturn r_bin_dyldcache_free (bin);\n\t}\n\tbin->b = r_buf_new();\n\tif (!r_buf_set_bytes (bin->b, buf, size)) {\n\t\treturn r_bin_dyldcache_free (bin);\n\t}\n\tif (!r_bin_dyldcache_init (bin)) {\n\t\treturn r_bin_dyldcache_free (bin);\n\t}\n\tbin->size = size;\n\treturn bin;\n}", "target": 1}
{"code": "static int java_switch_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {\n\tut8 op_byte = data[0];\n\tut64 offset = addr - java_get_method_start ();\n\tut8 pos = (offset+1)%4 ? 1 + 4 - (offset+1)%4 : 1;\n\tif (op_byte == 0xaa) {\n\t\tif (pos + 8 > len) {\n\t\t\treturn op->size;\n\t\t}\n\t\tint min_val = (ut32)(UINT (data, pos + 4)),\n\t\t\tmax_val = (ut32)(UINT (data, pos + 8));\n\t\tut32 default_loc = (ut32) (UINT (data, pos)), cur_case = 0;\n\t\top->switch_op = r_anal_switch_op_new (addr, min_val, default_loc);\n\t\tRAnalCaseOp *caseop = NULL;\n\t\tpos += 12;\n\t\tif (max_val > min_val && ((max_val - min_val)<(UT16_MAX/4))) {\n\t\t\tfor (cur_case = 0; cur_case <= max_val - min_val; pos += 4, cur_case++) {\n\t\t\t\tif (pos + 4 >= len) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint offset = (int)(ut32)(R_BIN_JAVA_UINT (data, pos));\n\t\t\t\tcaseop = r_anal_switch_op_add_case (op->switch_op,\n\t\t\t\t\taddr + pos, cur_case + min_val, addr + offset);\n\t\t\t\tif (caseop) {\n\t\t\t\t\tcaseop->bb_ref_to = addr+offset;\n\t\t\t\t\tcaseop->bb_ref_from = addr; \n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Invalid switch boundaries at 0x%\"PFMT64x\"\\n\", addr);\n\t\t}\n\t}\n\top->size = pos;\n\treturn op->size;\n}", "target": 1}
{"code": "subscription_update (subscriptionPtr subscription, guint flags)\n{\n\tUpdateRequest\t*request;\n\tguint64\t\tnow;\n\tguint\t\tcount, maxcount;\n\tif (!subscription)\n\t\treturn;\n\tif (subscription->updateJob)\n\t\treturn;\n\tdebug1 (DEBUG_UPDATE, \"Scheduling %s to be updated\", node_get_title (subscription->node));\n\tif (subscription_can_be_updated (subscription)) {\n\t\tnow = g_get_real_time();\n\t\tsubscription_reset_update_counter (subscription, &now);\n\t\trequest = update_request_new (\n\t\t\tsubscription_get_source (subscription),\n\t\t\tsubscription->updateState,\n\t\t\tsubscription->updateOptions\n\t\t);\n\t\tupdate_request_allow_commands (request, TRUE);\n\t\tif (subscription_get_filter (subscription))\n\t\t\trequest->filtercmd = g_strdup (subscription_get_filter (subscription));\n\t\tif (SUBSCRIPTION_TYPE (subscription)->prepare_update_request (subscription, request))\n\t\t\tsubscription->updateJob = update_execute_request (subscription, request, subscription_process_update_result, subscription, flags);\n\t\telse\n\t\t\tg_object_unref (request);\n\t\tupdate_jobs_get_count (&count, &maxcount);\n\t\tif (count > 1)\n\t\t\tliferea_shell_set_status_bar (_(\"Updating (%d / %d) ...\"), maxcount - count, maxcount);\n\t\telse\n\t\t\tliferea_shell_set_status_bar (_(\"Updating '%s'...\"), node_get_title (subscription->node));\n\t}\n}", "target": 0}
{"code": "static void nfs4_close_prepare(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_closedata *calldata = data;\n\tstruct nfs4_state *state = calldata->state;\n\tint clear_rd, clear_wr, clear_rdwr;\n\tif (nfs_wait_on_sequence(calldata->arg.seqid, task) != 0)\n\t\treturn;\n\tclear_rd = clear_wr = clear_rdwr = 0;\n\tspin_lock(&state->owner->so_lock);\n\tif (state->n_rdwr == 0) {\n\t\tif (state->n_rdonly == 0) {\n\t\t\tclear_rd |= test_and_clear_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\t\tclear_rdwr |= test_and_clear_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t}\n\t\tif (state->n_wronly == 0) {\n\t\t\tclear_wr |= test_and_clear_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\t\tclear_rdwr |= test_and_clear_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t}\n\t}\n\tspin_unlock(&state->owner->so_lock);\n\tif (!clear_rd && !clear_wr && !clear_rdwr) {\n\t\ttask->tk_action = NULL;\n\t\treturn;\n\t}\n\tnfs_fattr_init(calldata->res.fattr);\n\tif (test_bit(NFS_O_RDONLY_STATE, &state->flags) != 0) {\n\t\ttask->tk_msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_DOWNGRADE];\n\t\tcalldata->arg.open_flags = FMODE_READ;\n\t} else if (test_bit(NFS_O_WRONLY_STATE, &state->flags) != 0) {\n\t\ttask->tk_msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_DOWNGRADE];\n\t\tcalldata->arg.open_flags = FMODE_WRITE;\n\t}\n\tcalldata->timestamp = jiffies;\n\trpc_call_start(task);\n}", "target": 1}
{"code": "l_noret luaG_runerror (lua_State *L, const char *fmt, ...) {\n  CallInfo *ci = L->ci;\n  const char *msg;\n  va_list argp;\n  luaC_checkGC(L);  \n  va_start(argp, fmt);\n  msg = luaO_pushvfstring(L, fmt, argp);  \n  va_end(argp);\n  if (isLua(ci))  \n    luaG_addinfo(L, msg, ci_func(ci)->p->source, getcurrentline(ci));\n  luaG_errormsg(L);\n}", "target": 1}
{"code": "static UpVal **getupvalref (lua_State *L, int fidx, int n, LClosure **pf) {\n  LClosure *f;\n  StkId fi = index2addr(L, fidx);\n  api_check(L, ttisLclosure(fi), \"Lua function expected\");\n  f = clLvalue(fi);\n  api_check(L, (1 <= n && n <= f->p->sizeupvalues), \"invalid upvalue index\");\n  if (pf) *pf = f;\n  return &f->upvals[n - 1];  \n}", "target": 1}
{"code": "mm_compare(struct mm_share *a, struct mm_share *b)\n{\n\tptrdiff_t diff = (char *)a->address - (char *)b->address;\n\tif (diff == 0)\n\t\treturn (0);\n\telse if (diff < 0)\n\t\treturn (-1);\n\telse\n\t\treturn (1);\n}", "target": 1}
{"code": "void inet_sock_destruct(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\t__skb_queue_purge(&sk->sk_receive_queue);\n\t__skb_queue_purge(&sk->sk_error_queue);\n\tsk_mem_reclaim(sk);\n\tif (sk->sk_type == SOCK_STREAM && sk->sk_state != TCP_CLOSE) {\n\t\tpr_err(\"Attempt to release TCP socket in state %d %p\\n\",\n\t\t       sk->sk_state, sk);\n\t\treturn;\n\t}\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tpr_err(\"Attempt to release alive inet socket %p\\n\", sk);\n\t\treturn;\n\t}\n\tWARN_ON(atomic_read(&sk->sk_rmem_alloc));\n\tWARN_ON(atomic_read(&sk->sk_wmem_alloc));\n\tWARN_ON(sk->sk_wmem_queued);\n\tWARN_ON(sk->sk_forward_alloc);\n\tkfree(inet->opt);\n\tdst_release(rcu_dereference_check(sk->sk_dst_cache, 1));\n\tsk_refcnt_debug_dec(sk);\n}", "target": 1}
{"code": "NOEXPORT void tray_update(const int num) {\n    NOTIFYICONDATA nid;\n    static ICON_TYPE previous_icon=ICON_NONE;\n    ICON_TYPE current_icon;\n    LPTSTR tip;\n    if(!global_options.option.taskbar) { \n        tray_delete(); \n        return;\n    }\n    if(!tray_menu_handle) \n        tray_menu_handle=LoadMenu(ghInst, MAKEINTRESOURCE(IDM_TRAYMENU));\n    if(!tray_menu_handle) {\n        ioerror(\"LoadMenu\");\n        return;\n    }\n    if(cmdline.service)\n        EnableMenuItem(tray_menu_handle, IDM_EDIT_CONFIG, MF_GRAYED);\n    ZeroMemory(&nid, sizeof nid);\n    nid.cbSize=sizeof nid;\n    nid.uID=1; \n    nid.uFlags=NIF_MESSAGE|NIF_TIP;\n    nid.uCallbackMessage=WM_SYSTRAY; \n    nid.hWnd=hwnd; \n    if(num<0) {\n        tip=str_tprintf(TEXT(\"Server is down\"));\n        current_icon=ICON_ERROR;\n    } else if(num>0) {\n        tip=str_tprintf(TEXT(\"%d active session(s)\"), num);\n        current_icon=ICON_ACTIVE;\n    } else {\n        tip=str_tprintf(TEXT(\"Server is idle\"));\n        current_icon=ICON_IDLE;\n    }\n    _tcsncpy(nid.szTip, tip, 63);\n    nid.szTip[63]=TEXT('\\0');\n    str_free(tip);\n    nid.hIcon=global_options.icon[current_icon];\n    if(current_icon!=previous_icon) {\n        nid.uFlags|=NIF_ICON;\n        previous_icon=current_icon;\n    }\n    if(Shell_NotifyIcon(NIM_MODIFY, &nid)) \n        return; \n    nid.uFlags|=NIF_ICON;\n    Shell_NotifyIcon(NIM_ADD, &nid);\n}", "target": 1}
{"code": "getFileTypeNoFollowSymlinks(const StaticString &filename) {\n\tstruct stat buf;\n\tint ret;\n\tret = lstat(filename.c_str(), &buf);\n\tif (ret == 0) {\n\t\tif (S_ISREG(buf.st_mode)) {\n\t\t\treturn FT_REGULAR;\n\t\t} else if (S_ISDIR(buf.st_mode)) {\n\t\t\treturn FT_DIRECTORY;\n\t\t} else if (S_ISLNK(buf.st_mode)) {\n\t\t\treturn FT_SYMLINK;\n\t\t} else {\n\t\t\treturn FT_OTHER;\n\t\t}\n\t} else {\n\t\tif (errno == ENOENT) {\n\t\t\treturn FT_NONEXISTANT;\n\t\t} else {\n\t\t\tint e = errno;\n\t\t\tstring message(\"Cannot lstat '\");\n\t\t\tmessage.append(filename);\n\t\t\tmessage.append(\"'\");\n\t\t\tthrow FileSystemException(message, e, filename);\n\t\t}\n\t}\n}", "target": 1}
{"code": "static NTSTATUS dcesrv_interface_dnsserver_bind(struct dcesrv_connection_context *context,\n\t\t\t\t\t        const struct dcesrv_interface *iface)\n{\n\treturn dcesrv_interface_bind_require_integrity(context, iface);\n}", "target": 0}
{"code": "  Status CheckInputs(Tensor group_size_t, Tensor group_key_t) {\n    if (group_size_t.dims() > 0) {\n      return errors::Internal(\n          \"Unexpected dimensions on input group_size. \"\n          \"It shoulbe a scalar, got tensor with shape \",\n          group_size_t.shape().DebugString());\n    }\n    if (group_key_t.dims() > 0) {\n      return errors::Internal(\"Unexpected dimensions on input group_key, got \",\n                              group_key_t.shape().DebugString());\n    }\n    auto group_size = group_size_t.unaligned_flat<int32>()(0);\n    if (group_size <= 0) {\n      return errors::InvalidArgument(\n          \"group_size must be positive integer but got \", group_size);\n    }\n    return Status::OK();\n  }", "target": 1}
{"code": "static void destroy_compound_gigantic_page(struct page *page,\n\t\t\t\t\tunsigned int order)\n{\n\t__destroy_compound_gigantic_page(page, order, false);\n}", "target": 0}
{"code": "Server::Server(boost::asio::ip::tcp protocol, std::uint16_t port,\n               const fs::path& doc_root)\n    : protocol_(protocol),\n      port_(port),\n      doc_root_(doc_root),\n      acceptor_(io_context_),\n      signals_(io_context_) {\n  CheckDocRoot();\n  AddSignals();\n}", "target": 0}
{"code": "static int adpt_i2o_systab_send(adpt_hba* pHba)\n{\n\tu32 msg[12];\n\tint ret;\n\tmsg[0] = I2O_MESSAGE_SIZE(12) | SGL_OFFSET_6;\n\tmsg[1] = I2O_CMD_SYS_TAB_SET<<24 | HOST_TID<<12 | ADAPTER_TID;\n\tmsg[2] = 0;\n\tmsg[3] = 0;\n\tmsg[4] = (0<<16) | ((pHba->unit+2) << 12); \n\tmsg[5] = 0;\t\t\t\t   \n\tmsg[6] = 0x54000000 | sys_tbl_len;\n\tmsg[7] = (u32)sys_tbl_pa;\n\tmsg[8] = 0x54000000 | 0;\n\tmsg[9] = 0;\n\tmsg[10] = 0xD4000000 | 0;\n\tmsg[11] = 0;\n\tif ((ret=adpt_i2o_post_wait(pHba, msg, sizeof(msg), 120))) {\n\t\tprintk(KERN_INFO \"%s: Unable to set SysTab (status=%#10x).\\n\", \n\t\t\tpHba->name, ret);\n\t}\n#ifdef DEBUG\n\telse {\n\t\tPINFO(\"%s: SysTab set.\\n\", pHba->name);\n\t}\n#endif\n\treturn ret;\t\n}", "target": 1}
{"code": "static int __init llc2_init(void)\n{\n\tint rc = proto_register(&llc_proto, 0);\n\tif (rc != 0)\n\t\tgoto out;\n\tllc_build_offset_table();\n\tllc_station_init();\n\tllc_ui_sap_last_autoport = LLC_SAP_DYN_START;\n\trc = llc_proc_init();\n\tif (rc != 0) {\n\t\tprintk(llc_proc_err_msg);\n\t\tgoto out_unregister_llc_proto;\n\t}\n\trc = llc_sysctl_init();\n\tif (rc) {\n\t\tprintk(llc_sysctl_err_msg);\n\t\tgoto out_proc;\n\t}\n\trc = sock_register(&llc_ui_family_ops);\n\tif (rc) {\n\t\tprintk(llc_sock_err_msg);\n\t\tgoto out_sysctl;\n\t}\n\tllc_add_pack(LLC_DEST_SAP, llc_sap_handler);\n\tllc_add_pack(LLC_DEST_CONN, llc_conn_handler);\nout:\n\treturn rc;\nout_sysctl:\n\tllc_sysctl_exit();\nout_proc:\n\tllc_proc_exit();\nout_unregister_llc_proto:\n\tproto_unregister(&llc_proto);\n\tgoto out;\n}", "target": 0}
{"code": "    **/\n    T cubic_cut_atXYZ(const float fx, const float fy, const float fz, const int c, const T& out_value) const {\n      return cimg::type<T>::cut(cubic_atXYZ(fx,fy,fz,c,out_value));", "target": 0}
{"code": "  SubgraphGuard(TfLiteContext* context, bool* is_subgraph_in_use)\n      : is_subgraph_in_use_(is_subgraph_in_use) {\n    if (*is_subgraph_in_use_) {\n      TF_LITE_KERNEL_LOG(\n          context,\n          \"Subgraph is already in use. Using an interpreter or a subgraph in \"\n          \"multiple threads is not supported. Recursion in the graph is not \"\n          \"supported.\");\n      status_ = kTfLiteError;\n    } else {\n      *is_subgraph_in_use_ = true;\n    }\n  }", "target": 0}
{"code": "BaseAudioContext::~BaseAudioContext() {\n  {\n    GraphAutoLocker locker(this);\n    destination_handler_ = nullptr;\n  }\n  GetDeferredTaskHandler().ContextWillBeDestroyed();\n}", "target": 0}
{"code": "static int udp_v6_push_pending_frames(struct sock *sk)\n{\n\tstruct sk_buff *skb;\n\tstruct udphdr *uh;\n\tstruct udp_sock  *up = udp_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct flowi6 *fl6 = &inet->cork.fl.u.ip6;\n\tint err = 0;\n\tint is_udplite = IS_UDPLITE(sk);\n\t__wsum csum = 0;\n\tif ((skb = skb_peek(&sk->sk_write_queue)) == NULL)\n\t\tgoto out;\n\tuh = udp_hdr(skb);\n\tuh->source = fl6->fl6_sport;\n\tuh->dest = fl6->fl6_dport;\n\tuh->len = htons(up->len);\n\tuh->check = 0;\n\tif (is_udplite)\n\t\tcsum = udplite_csum_outgoing(sk, skb);\n\telse if (skb->ip_summed == CHECKSUM_PARTIAL) { \n\t\tudp6_hwcsum_outgoing(sk, skb, &fl6->saddr, &fl6->daddr,\n\t\t\t\t     up->len);\n\t\tgoto send;\n\t} else\n\t\tcsum = udp_csum_outgoing(sk, skb);\n\tuh->check = csum_ipv6_magic(&fl6->saddr, &fl6->daddr,\n\t\t\t\t    up->len, fl6->flowi6_proto, csum);\n\tif (uh->check == 0)\n\t\tuh->check = CSUM_MANGLED_0;\nsend:\n\terr = ip6_push_pending_frames(sk);\n\tif (err) {\n\t\tif (err == -ENOBUFS && !inet6_sk(sk)->recverr) {\n\t\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\t    UDP_MIB_SNDBUFERRORS, is_udplite);\n\t\t\terr = 0;\n\t\t}\n\t} else\n\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\t    UDP_MIB_OUTDATAGRAMS, is_udplite);\nout:\n\tup->len = 0;\n\tup->pending = 0;\n\treturn err;\n}", "target": 1}
{"code": "hermesInternalIsLazy(void *, Runtime &runtime, NativeArgs args) {\n  auto callable = args.dyncastArg<Callable>(0);\n  if (!callable) {\n    return HermesValue::encodeBoolValue(false);\n  }\n  auto codeBlock = getLeafCodeBlock(callable, runtime);\n  if (!codeBlock) {\n    return HermesValue::encodeBoolValue(false);\n  }\n  RuntimeModule *runtimeModule = codeBlock->getRuntimeModule();\n  return HermesValue::encodeBoolValue(\n      runtimeModule && runtimeModule->getBytecode()->isLazy());\n}", "target": 0}
{"code": "modify_bar_registration(struct pci_vdev *dev, int idx, int registration)\n{\n\tint error;\n\tstruct inout_port iop;\n\tstruct mem_range mr;\n\tif (is_pci_gvt(dev)) {\n\t\tprintf(\"modify_bar_registration: bypass for pci-gvt\\n\");\n\t\treturn;\n\t}\n\tswitch (dev->bar[idx].type) {\n\tcase PCIBAR_IO:\n\t\tbzero(&iop, sizeof(struct inout_port));\n\t\tiop.name = dev->name;\n\t\tiop.port = dev->bar[idx].addr;\n\t\tiop.size = dev->bar[idx].size;\n\t\tif (registration) {\n\t\t\tiop.flags = IOPORT_F_INOUT;\n\t\t\tiop.handler = pci_emul_io_handler;\n\t\t\tiop.arg = dev;\n\t\t\terror = register_inout(&iop);\n\t\t} else\n\t\t\terror = unregister_inout(&iop);\n\t\tbreak;\n\tcase PCIBAR_MEM32:\n\tcase PCIBAR_MEM64:\n\t\tbzero(&mr, sizeof(struct mem_range));\n\t\tmr.name = dev->name;\n\t\tmr.base = dev->bar[idx].addr;\n\t\tmr.size = dev->bar[idx].size;\n\t\tif (registration) {\n\t\t\tmr.flags = MEM_F_RW;\n\t\t\tmr.handler = pci_emul_mem_handler;\n\t\t\tmr.arg1 = dev;\n\t\t\tmr.arg2 = idx;\n\t\t\terror = register_mem(&mr);\n\t\t} else\n\t\t\terror = unregister_mem(&mr);\n\t\tbreak;\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\tassert(error == 0);\n}", "target": 1}
{"code": "int extractVersionQuadFromString(const char* string, int* quad) {\n    const char* nextNumber = string;\n    for (int i = 0; i < 4; i++) {\n        quad[i] = (int)strtol(nextNumber, (char**)&nextNumber, 10);\n        if (*nextNumber != 0) {\n            nextNumber++;\n        }\n    }\n    return 0;\n}", "target": 0}
{"code": "static int getStrrtokenPos(char* str, int savedPos)\n{\n\tint result =-1;\n\tint i;\n\tfor(i=savedPos-1; i>=0; i--) {\n\t\tif(isIDSeparator(*(str+i)) ){\n\t\t\tif(i>=2 && isIDSeparator(*(str+i-2)) ){\n\t\t\t\tresult = i-2;\n\t\t\t} else {\n\t\t\t\tresult = i;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(result < 1){\n\t\tresult =-1;\n\t}\n\treturn result;\n}", "target": 1}
{"code": "String StringUtil::Implode(const Variant& items, const String& delim,\n                           const bool checkIsContainer ) {\n  if (checkIsContainer && !isContainer(items)) {\n    throw_param_is_not_container();\n  }\n  int size = getContainerSize(items);\n  if (size == 0) return empty_string();\n  req::vector<String> sitems;\n  sitems.reserve(size);\n  int len = 0;\n  int lenDelim = delim.size();\n  for (ArrayIter iter(items); iter; ++iter) {\n    sitems.emplace_back(iter.second().toString());\n    len += sitems.back().size() + lenDelim;\n  }\n  len -= lenDelim; \n  assert(sitems.size() == size);\n  String s = String(len, ReserveString);\n  char *buffer = s.mutableData();\n  const char *sdelim = delim.data();\n  char *p = buffer;\n  String &init_str = sitems[0];\n  int init_len = init_str.size();\n  memcpy(p, init_str.data(), init_len);\n  p += init_len;\n  for (int i = 1; i < size; i++) {\n    String &item = sitems[i];\n    memcpy(p, sdelim, lenDelim);\n    p += lenDelim;\n    int lenItem = item.size();\n    memcpy(p, item.data(), lenItem);\n    p += lenItem;\n  }\n  assert(p - buffer == len);\n  s.setSize(len);\n  return s;\n}", "target": 1}
{"code": "const RootWindow* RootWindow::GetRootWindow() const {\n  return this;\n}", "target": 0}
{"code": "main(void)\n{\n    test(1, \"\", \"\");\n    test(1, \"a\", \"a\");\n    test(1, \"abc\", \"abc\");\n    test(0, \"a\", \"\");\n    test(0, \"ab\", \"\");\n    test(0, \"\", \"a\");\n    test(0, \"\", \"ab\");\n    test(0, \"abcd\", \"abc\");\n    test(0, \"abc\", \"abcd\");\n    return 0;\n}", "target": 0}
{"code": "spnego_gss_unwrap_iov(OM_uint32 *minor_status,\n\t\t      gss_ctx_id_t context_handle,\n\t\t      int *conf_state,\n\t\t      gss_qop_t *qop_state,\n\t\t      gss_iov_buffer_desc *iov,\n\t\t      int iov_count)\n{\n\tOM_uint32 ret;\n\tret = gss_unwrap_iov(minor_status,\n\t\t\t     context_handle,\n\t\t\t     conf_state,\n\t\t\t     qop_state,\n\t\t\t     iov,\n\t\t\t     iov_count);\n\treturn (ret);\n}", "target": 1}
{"code": "uint64_t ldq_be_phys(AddressSpace *as, hwaddr addr)\n{\n    return address_space_ldq_be(as, addr, MEMTXATTRS_UNSPECIFIED, NULL);\n}", "target": 0}
{"code": "    size_t FileIo::write(BasicIo& src)\n    {\n        assert(p_->fp_ != 0);\n        if (static_cast<BasicIo*>(this) == &src) return 0;\n        if (!src.isopen()) return 0;\n        if (p_->switchMode(Impl::opWrite) != 0) return 0;\n        byte buf[4096];\n        size_t readCount = 0;\n        size_t writeTotal = 0;\n        while ((readCount = src.read(buf, sizeof(buf)))) {\n            const size_t writeCount = static_cast<long>(std::fwrite(buf, 1, static_cast<size_t>(readCount), p_->fp_));\n            writeTotal += writeCount;\n            if (writeCount != readCount) {\n                src.seek(writeCount-readCount, BasicIo::cur);\n                break;\n            }\n        }\n        return writeTotal;\n    }", "target": 0}
{"code": "gimp_channel_new_from_buffer (GimpImage     *image,\n                              GeglBuffer    *buffer,\n                              const gchar   *name,\n                              const GimpRGB *color)\n{\n  GimpChannel *channel;\n  GeglBuffer  *dest;\n  g_return_val_if_fail (GIMP_IS_IMAGE (image), NULL);\n  g_return_val_if_fail (GEGL_IS_BUFFER (buffer), NULL);\n  channel = gimp_channel_new (image,\n                              gegl_buffer_get_width  (buffer),\n                              gegl_buffer_get_height (buffer),\n                              name, color);\n  dest = gimp_drawable_get_buffer (GIMP_DRAWABLE (channel));\n  gimp_gegl_buffer_copy (buffer, NULL, GEGL_ABYSS_NONE, dest, NULL);\n  return channel;\n}", "target": 0}
{"code": "__reiserfs_set_acl(struct reiserfs_transaction_handle *th, struct inode *inode,\n\t\t int type, struct posix_acl *acl)\n{\n\tchar *name;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t\telse {\n\t\t\t\tif (error == 0)\n\t\t\t\t\tacl = NULL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tvalue = reiserfs_posix_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\terror = reiserfs_xattr_set_handle(th, inode, name, value, size, 0);\n\tif (error == -ENODATA) {\n\t\terror = 0;\n\t\tif (type == ACL_TYPE_ACCESS) {\n\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t}\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\treturn error;\n}", "target": 1}
{"code": "ImagingConvertInPlace(Imaging imIn, const char *mode) {\n    ImagingSectionCookie cookie;\n    ImagingShuffler convert;\n    int y;\n    if (strcmp(imIn->mode, \"L\") == 0 && strcmp(mode, \"1\") == 0) {\n        convert = l2bit;\n    } else if (strcmp(imIn->mode, \"1\") == 0 && strcmp(mode, \"L\") == 0) {\n        convert = bit2l;\n    } else {\n        return ImagingError_ModeError();\n    }\n    ImagingSectionEnter(&cookie);\n    for (y = 0; y < imIn->ysize; y++) {\n        (*convert)((UINT8 *)imIn->image[y], (UINT8 *)imIn->image[y], imIn->xsize);\n    }\n    ImagingSectionLeave(&cookie);\n    return imIn;\n}", "target": 0}
{"code": "TEST(InMatchExpression, MatchesNull) {\n    BSONObj operand = BSON_ARRAY(BSONNULL);\n    InMatchExpression in(\"a\");\n    std::vector<BSONElement> equalities{operand.firstElement()};\n    ASSERT_OK(in.setEqualities(std::move(equalities)));\n    ASSERT(in.matchesBSON(BSONObj(), NULL));\n    ASSERT(in.matchesBSON(BSON(\"a\" << BSONNULL), NULL));\n    ASSERT(!in.matchesBSON(BSON(\"a\" << 4), NULL));\n    ASSERT(in.matchesBSON(BSON(\"b\" << 4), NULL));\n}", "target": 0}
{"code": "\tvoid verifyDirectoryPermissions(const string &path) {\n\t\tTRACE_POINT();\n\t\tstruct stat buf;\n\t\tif (stat(path.c_str(), &buf) == -1) {\n\t\t\tint e = errno;\n\t\t\tthrow FileSystemException(\"Cannot stat() \" + path, e, path);\n\t\t} else if (buf.st_mode != (S_IFDIR | parseModeString(\"u=rwx,g=rx,o=rx\"))) {\n\t\t\tthrow RuntimeException(\"Tried to reuse existing server instance directory \" +\n\t\t\t\tpath + \", but it has wrong permissions\");\n\t\t} else if (buf.st_uid != geteuid() || buf.st_gid != getegid()) {\n\t\t\tthrow RuntimeException(\"Tried to reuse existing server instance directory \" +\n\t\t\t\tpath + \", but it has wrong owner and group\");\n\t\t}\n\t}", "target": 1}
{"code": "int ZEXPORT deflateCopy (dest, source)\n    z_streamp dest;\n    z_streamp source;\n{\n#ifdef MAXSEG_64K\n    return Z_STREAM_ERROR;\n#else\n    deflate_state *ds;\n    deflate_state *ss;\n    ushf *overlay;\n    if (deflateStateCheck(source) || dest == Z_NULL) {\n        return Z_STREAM_ERROR;\n    }\n    ss = source->state;\n    zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));\n    ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));\n    if (ds == Z_NULL) return Z_MEM_ERROR;\n    dest->state = (struct internal_state FAR *) ds;\n    zmemcpy((voidpf)ds, (voidpf)ss, sizeof(deflate_state));\n    ds->strm = dest;\n    ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));\n    ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));\n    ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));\n    overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2);\n    ds->pending_buf = (uchf *) overlay;\n    if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||\n        ds->pending_buf == Z_NULL) {\n        deflateEnd (dest);\n        return Z_MEM_ERROR;\n    }\n    zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));\n    zmemcpy((voidpf)ds->prev, (voidpf)ss->prev, ds->w_size * sizeof(Pos));\n    zmemcpy((voidpf)ds->head, (voidpf)ss->head, ds->hash_size * sizeof(Pos));\n    zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);\n    ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);\n    ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);\n    ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;\n    ds->l_desc.dyn_tree = ds->dyn_ltree;\n    ds->d_desc.dyn_tree = ds->dyn_dtree;\n    ds->bl_desc.dyn_tree = ds->bl_tree;\n    return Z_OK;\n#endif \n}", "target": 1}
{"code": "int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)\n{\n\tstruct sctp_association *asoc = sctp_id2assoc(sk, id);\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct socket *sock;\n\tint err = 0;\n\tif (!asoc)\n\t\treturn -EINVAL;\n\tif (waitqueue_active(&asoc->wait))\n\t\treturn -EBUSY;\n\tif (!sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\terr = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);\n\tif (err < 0)\n\t\treturn err;\n\tsctp_copy_sock(sock->sk, sk, asoc);\n\tsp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);\n\tsctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);\n\t*sockp = sock;\n\treturn err;\n}", "target": 0}
{"code": "int __cil_build_ast_last_child_helper(struct cil_tree_node *parse_current, void *extra_args)\n{\n\tstruct cil_args_build *args = extra_args;\n\tstruct cil_tree_node *ast = args->ast;\n\tif (ast->flavor == CIL_ROOT) {\n\t\treturn SEPOL_OK;\n\t}\n\targs->ast = ast->parent;\n\tif (ast->flavor == CIL_TUNABLEIF) {\n\t\targs->tunif = NULL;\n\t}\n\tif (ast->flavor == CIL_IN) {\n\t\targs->in = NULL;\n\t}\n\tif (ast->flavor == CIL_MACRO) {\n\t\targs->macro = NULL;\n\t}\n\tif (ast->flavor == CIL_OPTIONAL) {\n\t\tstruct cil_tree_node *n = ast->parent;\n\t\targs->optional = NULL;\n\t\twhile (n && n->flavor != CIL_ROOT) {\n\t\t\tif (n->flavor == CIL_OPTIONAL) {\n\t\t\t\targs->optional = n;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn = n->parent;\n\t\t}\n\t}\n\tif (ast->flavor == CIL_BOOLEANIF) {\n\t\targs->boolif = NULL;\n\t}\n\tcil_tree_children_destroy(parse_current->parent);\n\treturn SEPOL_OK;\n}", "target": 0}
{"code": "static void labeljumps(JF, js_JumpList *jump, int baddr, int caddr)\n{\n\twhile (jump) {\n\t\tif (jump->type == STM_BREAK)\n\t\t\tlabelto(J, F, jump->inst, baddr);\n\t\tif (jump->type == STM_CONTINUE)\n\t\t\tlabelto(J, F, jump->inst, caddr);\n\t\tjump = jump->next;\n\t}\n}", "target": 1}
{"code": "String BuildElementErrorMessage(const String& error) {\n  DEFINE_STATIC_LOCAL(const String, element_error_prefix,\n                      (\"MEDIA_ELEMENT_ERROR: \"));\n  StringBuilder builder;\n  builder.Append(element_error_prefix);\n  builder.Append(error);\n  return builder.ToString();\n}", "target": 0}
{"code": "xmlPushInput(xmlParserCtxtPtr ctxt, xmlParserInputPtr input) {\n    int ret;\n    if (input == NULL) return(-1);\n    if (xmlParserDebugEntities) {\n\tif ((ctxt->input != NULL) && (ctxt->input->filename))\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"%s(%d): \", ctxt->input->filename,\n\t\t    ctxt->input->line);\n\txmlGenericError(xmlGenericErrorContext,\n\t\t\"Pushing input %d : %.30s\\n\", ctxt->inputNr+1, input->cur);\n    }\n    if (((ctxt->inputNr > 40) && ((ctxt->options & XML_PARSE_HUGE) == 0)) ||\n        (ctxt->inputNr > 1024)) {\n        xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n        while (ctxt->inputNr > 1)\n            xmlFreeInputStream(inputPop(ctxt));\n\treturn(-1);\n    }\n    ret = inputPush(ctxt, input);\n    if (ctxt->instate == XML_PARSER_EOF)\n        return(-1);\n    GROW;\n    return(ret);\n}", "target": 0}
{"code": "static int adpt_bus_reset(struct scsi_cmnd* cmd)\n{\n\tadpt_hba* pHba;\n\tu32 msg[4];\n\tu32 rcode;\n\tpHba = (adpt_hba*)cmd->device->host->hostdata[0];\n\tmemset(msg, 0, sizeof(msg));\n\tprintk(KERN_WARNING\"%s: Bus reset: SCSI Bus %d: tid: %d\\n\",pHba->name, cmd->device->channel,pHba->channel[cmd->device->channel].tid );\n\tmsg[0] = FOUR_WORD_MSG_SIZE|SGL_OFFSET_0;\n\tmsg[1] = (I2O_HBA_BUS_RESET<<24|HOST_TID<<12|pHba->channel[cmd->device->channel].tid);\n\tmsg[2] = 0;\n\tmsg[3] = 0;\n\tif (pHba->host)\n\t\tspin_lock_irq(pHba->host->host_lock);\n\trcode = adpt_i2o_post_wait(pHba, msg,sizeof(msg), FOREVER);\n\tif (pHba->host)\n\t\tspin_unlock_irq(pHba->host->host_lock);\n\tif (rcode != 0) {\n\t\tprintk(KERN_WARNING\"%s: Bus reset failed.\\n\",pHba->name);\n\t\treturn FAILED;\n\t} else {\n\t\tprintk(KERN_WARNING\"%s: Bus reset success.\\n\",pHba->name);\n\t\treturn SUCCESS;\n\t}\n}", "target": 1}
{"code": "bool PrintWebViewHelper::PrintPreviewContext::CreatePreviewDocument(\n    PrepareFrameAndViewForPrint* prepared_frame,\n    const std::vector<int>& pages) {\n  DCHECK_EQ(INITIALIZED, state_);\n  state_ = RENDERING;\n  prep_frame_view_.reset(prepared_frame);\n  prep_frame_view_->StartPrinting();\n  total_page_count_ = prep_frame_view_->GetExpectedPageCount();\n  if (total_page_count_ == 0) {\n    LOG(ERROR) << \"CreatePreviewDocument got 0 page count\";\n    set_error(PREVIEW_ERROR_ZERO_PAGES);\n    return false;\n  }\n  metafile_.reset(new PdfMetafileSkia);\n  if (!metafile_->Init()) {\n    set_error(PREVIEW_ERROR_METAFILE_INIT_FAILED);\n    LOG(ERROR) << \"PdfMetafileSkia Init failed\";\n    return false;\n  }\n  current_page_index_ = 0;\n  pages_to_render_ = pages;\n  std::sort(pages_to_render_.begin(), pages_to_render_.end());\n  pages_to_render_.resize(\n      std::unique(pages_to_render_.begin(), pages_to_render_.end()) -\n      pages_to_render_.begin());\n  pages_to_render_.resize(std::lower_bound(pages_to_render_.begin(),\n                                           pages_to_render_.end(),\n                                           total_page_count_) -\n                          pages_to_render_.begin());\n  print_ready_metafile_page_count_ = pages_to_render_.size();\n  if (pages_to_render_.empty()) {\n    print_ready_metafile_page_count_ = total_page_count_;\n    for (int i = 0; i < total_page_count_; ++i)\n      pages_to_render_.push_back(i);\n  } else if (generate_draft_pages_) {\n    int pages_index = 0;\n    for (int i = 0; i < total_page_count_; ++i) {\n      if (pages_index < print_ready_metafile_page_count_ &&\n          i == pages_to_render_[pages_index]) {\n        pages_index++;\n        continue;\n      }\n      pages_to_render_.push_back(i);\n    }\n  }\n  document_render_time_ = base::TimeDelta();\n  begin_time_ = base::TimeTicks::Now();\n  return true;\n}", "target": 0}
{"code": "void CLASS parse_qt (int end)\n{\n  unsigned save, size;\n  char tag[4];\n  order = 0x4d4d;\n  while (ftell(ifp)+7 < end) {\n    save = ftell(ifp);\n    if ((size = get4()) < 8) return;\n    if ((int)size < 0) return; \n    if (save + size < save) return; \n    fread (tag, 4, 1, ifp);\n    if (!memcmp(tag,\"moov\",4) ||\n\t!memcmp(tag,\"udta\",4) ||\n\t!memcmp(tag,\"CNTH\",4))\n      parse_qt (save+size);\n    if (!memcmp(tag,\"CNDA\",4))\n      parse_jpeg (ftell(ifp));\n    fseek (ifp, save+size, SEEK_SET);\n  }\n}", "target": 0}
{"code": "int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu, struct kvm_run *run)\n{\n\tint ret;\n\tsigset_t sigsaved;\n\tif (unlikely(vcpu->arch.target < 0))\n\t\treturn -ENOEXEC;\n\tret = kvm_vcpu_first_run_init(vcpu);\n\tif (ret)\n\t\treturn ret;\n\tif (run->exit_reason == KVM_EXIT_MMIO) {\n\t\tret = kvm_handle_mmio_return(vcpu, vcpu->run);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (vcpu->sigset_active)\n\t\tsigprocmask(SIG_SETMASK, &vcpu->sigset, &sigsaved);\n\tret = 1;\n\trun->exit_reason = KVM_EXIT_UNKNOWN;\n\twhile (ret > 0) {\n\t\tcond_resched();\n\t\tupdate_vttbr(vcpu->kvm);\n\t\tif (vcpu->arch.pause)\n\t\t\tvcpu_pause(vcpu);\n\t\tkvm_vgic_flush_hwstate(vcpu);\n\t\tkvm_timer_flush_hwstate(vcpu);\n\t\tlocal_irq_disable();\n\t\tif (signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\trun->exit_reason = KVM_EXIT_INTR;\n\t\t}\n\t\tif (ret <= 0 || need_new_vmid_gen(vcpu->kvm)) {\n\t\t\tlocal_irq_enable();\n\t\t\tkvm_timer_sync_hwstate(vcpu);\n\t\t\tkvm_vgic_sync_hwstate(vcpu);\n\t\t\tcontinue;\n\t\t}\n\t\ttrace_kvm_entry(*vcpu_pc(vcpu));\n\t\tkvm_guest_enter();\n\t\tvcpu->mode = IN_GUEST_MODE;\n\t\tret = kvm_call_hyp(__kvm_vcpu_run, vcpu);\n\t\tvcpu->mode = OUTSIDE_GUEST_MODE;\n\t\tvcpu->arch.last_pcpu = smp_processor_id();\n\t\tkvm_guest_exit();\n\t\ttrace_kvm_exit(*vcpu_pc(vcpu));\n\t\tlocal_irq_enable();\n\t\tkvm_timer_sync_hwstate(vcpu);\n\t\tkvm_vgic_sync_hwstate(vcpu);\n\t\tret = handle_exit(vcpu, run, ret);\n\t}\n\tif (vcpu->sigset_active)\n\t\tsigprocmask(SIG_SETMASK, &sigsaved, NULL);\n\treturn ret;\n}", "target": 1}
{"code": "rfbSetClientColourMapBGR233(rfbClientPtr cl)\n{\n    char buf[sz_rfbSetColourMapEntriesMsg + 256 * 3 * 2];\n    rfbSetColourMapEntriesMsg *scme = (rfbSetColourMapEntriesMsg *)buf;\n    uint16_t *rgb = (uint16_t *)(&buf[sz_rfbSetColourMapEntriesMsg]);\n    int i, len;\n    int r, g, b;\n    if (cl->format.bitsPerPixel != 8 ) {\n        rfbErr(\"%s: client not 8 bits per pixel\\n\",\n                \"rfbSetClientColourMapBGR233\");\n        rfbCloseClient(cl);\n        return FALSE;\n    }\n    scme->type = rfbSetColourMapEntries;\n    scme->firstColour = Swap16IfLE(0);\n    scme->nColours = Swap16IfLE(256);\n    len = sz_rfbSetColourMapEntriesMsg;\n    i = 0;\n    for (b = 0; b < 4; b++) {\n        for (g = 0; g < 8; g++) {\n            for (r = 0; r < 8; r++) {\n                rgb[i++] = Swap16IfLE(r * 65535 / 7);\n                rgb[i++] = Swap16IfLE(g * 65535 / 7);\n                rgb[i++] = Swap16IfLE(b * 65535 / 3);\n            }\n        }\n    }\n    len += 256 * 3 * 2;\n    if (rfbWriteExact(cl, buf, len) < 0) {\n        rfbLogPerror(\"rfbSetClientColourMapBGR233: write\");\n        rfbCloseClient(cl);\n        return FALSE;\n    }\n    return TRUE;\n}", "target": 1}
{"code": "static bool tls_desc_okay(const struct user_desc *info)\n{\n\tif (LDT_empty(info))\n\t\treturn true;\n\tif (!info->seg_32bit)\n\t\treturn false;\n\treturn true;\n}", "target": 0}
{"code": "static void prefetch_dec(void)\n{\n  dec_tables.counter_head++;\n  dec_tables.counter_tail++;\n  prefetch_table((const void *)&dec_tables, sizeof(dec_tables));\n}", "target": 0}
{"code": "static void edge_bulk_in_callback(struct urb *urb)\n{\n\tstruct edgeport_port *edge_port = urb->context;\n\tstruct device *dev = &edge_port->port->dev;\n\tunsigned char *data = urb->transfer_buffer;\n\tint retval = 0;\n\tint port_number;\n\tint status = urb->status;\n\tswitch (status) {\n\tcase 0:\n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\tdev_dbg(&urb->dev->dev, \"%s - urb shutting down with status: %d\\n\", __func__, status);\n\t\treturn;\n\tdefault:\n\t\tdev_err(&urb->dev->dev, \"%s - nonzero read bulk status received: %d\\n\", __func__, status);\n\t}\n\tif (status == -EPIPE)\n\t\tgoto exit;\n\tif (status) {\n\t\tdev_err(&urb->dev->dev, \"%s - stopping read!\\n\", __func__);\n\t\treturn;\n\t}\n\tport_number = edge_port->port->port_number;\n\tif (edge_port->lsr_event) {\n\t\tedge_port->lsr_event = 0;\n\t\tdev_dbg(dev, \"%s ===== Port %u LSR Status = %02x, Data = %02x ======\\n\",\n\t\t\t__func__, port_number, edge_port->lsr_mask, *data);\n\t\thandle_new_lsr(edge_port, 1, edge_port->lsr_mask, *data);\n\t\t--urb->actual_length;\n\t\t++data;\n\t}\n\tif (urb->actual_length) {\n\t\tusb_serial_debug_data(dev, __func__, urb->actual_length, data);\n\t\tif (edge_port->close_pending)\n\t\t\tdev_dbg(dev, \"%s - close pending, dropping data on the floor\\n\",\n\t\t\t\t\t\t\t\t__func__);\n\t\telse\n\t\t\tedge_tty_recv(edge_port->port, data,\n\t\t\t\t\turb->actual_length);\n\t\tedge_port->port->icount.rx += urb->actual_length;\n\t}\nexit:\n\tspin_lock(&edge_port->ep_lock);\n\tif (edge_port->ep_read_urb_state == EDGE_READ_URB_RUNNING)\n\t\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\telse if (edge_port->ep_read_urb_state == EDGE_READ_URB_STOPPING)\n\t\tedge_port->ep_read_urb_state = EDGE_READ_URB_STOPPED;\n\tspin_unlock(&edge_port->ep_lock);\n\tif (retval)\n\t\tdev_err(dev, \"%s - usb_submit_urb failed with result %d\\n\", __func__, retval);\n}", "target": 1}
{"code": "MONGO_EXPORT bson_type bson_iterator_next( bson_iterator *i ) {\n    int ds;\n    if ( i->first ) {\n        i->first = 0;\n        return ( bson_type )( *i->cur );\n    }\n    switch ( bson_iterator_type( i ) ) {\n    case BSON_EOO:\n        return BSON_EOO; \n    case BSON_UNDEFINED:\n    case BSON_NULL:\n        ds = 0;\n        break;\n    case BSON_BOOL:\n        ds = 1;\n        break;\n    case BSON_INT:\n        ds = 4;\n        break;\n    case BSON_LONG:\n    case BSON_DOUBLE:\n    case BSON_TIMESTAMP:\n    case BSON_DATE:\n        ds = 8;\n        break;\n    case BSON_OID:\n        ds = 12;\n        break;\n    case BSON_STRING:\n    case BSON_SYMBOL:\n    case BSON_CODE:\n        ds = 4 + bson_iterator_int_raw( i );\n        break;\n    case BSON_BINDATA:\n        ds = 5 + bson_iterator_int_raw( i );\n        break;\n    case BSON_OBJECT:\n    case BSON_ARRAY:\n    case BSON_CODEWSCOPE:\n        ds = bson_iterator_int_raw( i );\n        break;\n    case BSON_DBREF:\n        ds = 4+12 + bson_iterator_int_raw( i );\n        break;\n    case BSON_REGEX: {\n        const char *s = bson_iterator_value( i );\n        const char *p = s;\n        p += strlen( p )+1;\n        p += strlen( p )+1;\n        ds = p-s;\n        break;\n    }\n    default: {\n        char msg[] = \"unknown type: 000000000000\";\n        bson_numstr( msg+14, ( unsigned )( i->cur[0] ) );\n        bson_fatal_msg( 0, msg );\n        return 0;\n    }\n    }\n    i->cur += 1 + strlen( i->cur + 1 ) + 1 + ds;\n    return ( bson_type )( *i->cur );\n}", "target": 1}
{"code": "int LibRaw::minolta_z2()\n{\n  int i, nz;\n  char tail[424];\n  fseek(ifp, -sizeof tail, SEEK_END);\n  fread(tail, 1, sizeof tail, ifp);\n  for (nz = i = 0; i < sizeof tail; i++)\n    if (tail[i])\n      nz++;\n  return nz > 20;\n}", "target": 0}
{"code": "struct tcp_sock_t *tcp_open(uint16_t port)\n{\n\tstruct tcp_sock_t *this = calloc(1, sizeof *this);\n\tif (this == NULL) {\n\t\tERR(\"callocing this failed\");\n\t\tgoto error;\n\t}\n\tthis->sd = -1;\n\tthis->sd = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (this->sd < 0) {\n\t\tERR(\"sockect open failed\");\n\t\tgoto error;\n\t}\n\tstruct sockaddr_in6 addr;\n\tmemset(&addr, 0, sizeof addr);\n\taddr.sin6_family = AF_INET6;\n\taddr.sin6_port = htons(port);\n\taddr.sin6_addr = in6addr_any;\n\tif (bind(this->sd,\n\t        (struct sockaddr *)&addr,\n\t        sizeof addr) < 0) {\n\t\tif (g_options.only_desired_port == 1)\n\t\t\tERR(\"Bind on port failed. \"\n\t\t\t    \"Requested port may be taken or require root permissions.\");\n\t\tgoto error;\n\t}\n\tif (listen(this->sd, HTTP_MAX_PENDING_CONNS) < 0) {\n\t\tERR(\"listen failed on socket\");\n\t\tgoto error;\n\t}\n\treturn this;\nerror:\n\tif (this != NULL) {\n\t\tif (this->sd != -1) {\n\t\t\tclose(this->sd);\n\t\t}\n\t\tfree(this);\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "R_API bool r_io_bank_read_at(RIO *io, const ut32 bankid, ut64 addr, ut8 *buf, int len) {\n\tr_return_val_if_fail (io, false);\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tif (!bank) {\n\t\treturn false;\n\t}\n\tRIOSubMap fake_sm = {{0}};\n\tfake_sm.itv.addr = addr;\n\tfake_sm.itv.size = len;\n\tRRBNode *node;\n\tif (R_LIKELY (bank->last_used && r_io_submap_contain (((RIOSubMap *)bank->last_used->data), addr))) {\n\t\tnode = bank->last_used;\n\t} else {\n\t\tnode = _find_entry_submap_node (bank, &fake_sm);\n\t}\n\tmemset (buf, io->Oxff, len);\n\tRIOSubMap *sm = node ? (RIOSubMap *)node->data : NULL;\n\tbool ret = true;\n\twhile (sm && r_io_submap_overlap ((&fake_sm), sm)) {\n\t\tbank->last_used = node;\n\t\tRIOMap *map = r_io_map_get_by_ref (io, &sm->mapref);\n\t\tif (!map) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!(map->perm & R_PERM_R)) {\n\t\t\tnode = r_rbnode_next (node);\n\t\t\tsm = node ? (RIOSubMap *)node->data : NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tconst ut64 buf_off = R_MAX (addr, r_io_submap_from (sm)) - addr;\n\t\tconst int read_len = R_MIN (r_io_submap_to ((&fake_sm)),\n\t\t\t\t\t     r_io_submap_to (sm)) - (addr + buf_off) + 1;\n\t\tif (map->perm & R_PERM_RELOC) {\n\t\t\tret &= map->reloc_map->read (io, map, addr + buf_off, &buf[buf_off], read_len);\n\t\t} else {\n\t\t\tconst ut64 paddr = addr + buf_off - r_io_map_from (map) + map->delta;\n\t\t\tret &= (r_io_fd_read_at (io, map->fd, paddr, &buf[buf_off], read_len) == read_len);\n\t\t}\n\t\tnode = r_rbnode_next (node);\n\t\tsm = node ? (RIOSubMap *)node->data : NULL;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "date_s_rfc3339(int argc, VALUE *argv, VALUE klass)\n{\n    VALUE str, sg, opt;\n    rb_scan_args(argc, argv, \"02:\", &str, &sg, &opt);\n    if (!NIL_P(opt)) argc--;\n    switch (argc) {\n      case 0:\n\tstr = rb_str_new2(\"-4712-01-01T00:00:00+00:00\");\n      case 1:\n\tsg = INT2FIX(DEFAULT_SG);\n    }\n    {\n        int argc2 = 1;\n        VALUE argv2[2];\n        argv2[0] = str;\n        if (!NIL_P(opt)) argv2[argc2++] = opt;\n\tVALUE hash = date_s__rfc3339(argc2, argv2, klass);\n\treturn d_new_by_frags(klass, hash, sg);\n    }\n}", "target": 0}
{"code": "SessionStorageNamespace* WebContentsImpl::GetSessionStorageNamespace(\n    SiteInstance* instance) {\n  return controller_.GetSessionStorageNamespace(instance);\n}", "target": 0}
{"code": "static void my_error_exit( j_common_ptr cinfo ) {\n   my_error_ptr myerr = reinterpret_cast<my_error_ptr>( cinfo->err );\n   longjmp( myerr->setjmp_buffer, 1 );\n}", "target": 0}
{"code": "TEST_P(Http2IntegrationTest, LargeRequestTrailersRejected) { testLargeRequestTrailers(66, 60); }", "target": 0}
{"code": "static void vmx_sync_pir_to_irr(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tif (!pi_test_and_clear_on(&vmx->pi_desc))\n\t\treturn;\n\tkvm_apic_update_irr(vcpu, vmx->pi_desc.pir);\n}", "target": 0}
{"code": "hphp_libxml_input_buffer(const char *URI, xmlCharEncoding enc) {\n  if (s_libxml_errors->m_entity_loader_disabled) {\n    return nullptr;\n  }\n  return __xmlParserInputBufferCreateFilename(URI, enc);\n}", "target": 0}
{"code": "elg_get_nbits (int algo, gcry_mpi_t *pkey)\n{\n  (void)algo;\n  return mpi_get_nbits (pkey[0]);\n}", "target": 0}
{"code": "static int parse_bigBN(BIGNUM **out, const char *bn_strings[])\n{\n    char *bigstring = glue_strings(bn_strings, NULL);\n    int ret = BN_hex2bn(out, bigstring);\n    OPENSSL_free(bigstring);\n    return ret;\n}", "target": 0}
{"code": "static inline int xsave_state(struct xsave_struct *fx, u64 mask)\n{\n\tu32 lmask = mask;\n\tu32 hmask = mask >> 32;\n\tint err = 0;\n\talternative_input_2(\n\t\t\"1:\"XSAVE,\n\t\t\"1:\"XSAVEOPT,\n\t\tX86_FEATURE_XSAVEOPT,\n\t\t\"1:\"XSAVES,\n\t\tX86_FEATURE_XSAVES,\n\t\t[fx] \"D\" (fx), \"a\" (lmask), \"d\" (hmask) :\n\t\t\"memory\");\n\tasm volatile(\"2:\\n\\t\"\n\t\t     xstate_fault\n\t\t     : \"0\" (0)\n\t\t     : \"memory\");\n\treturn err;\n}", "target": 1}
{"code": "ZEND_API void zend_update_property_null(zend_class_entry *scope, zval *object, const char *name, int name_length TSRMLS_DC) \n{\n\tzval *tmp;\n\tALLOC_ZVAL(tmp);\n\tZ_UNSET_ISREF_P(tmp);\n\tZ_SET_REFCOUNT_P(tmp, 0);\n\tZVAL_NULL(tmp);\n\tzend_update_property(scope, object, name, name_length, tmp TSRMLS_CC);\n}", "target": 0}
{"code": "bool initialise_control(rzip_control *control)\n{\n\ttime_t now_t, tdiff;\n\tchar localeptr[] = \"./\", *eptr; \n\tsize_t len;\n\tmemset(control, 0, sizeof(rzip_control));\n\tcontrol->msgout = stderr;\n\tcontrol->msgerr = stderr;\n\tregister_outputfile(control, control->msgout);\n\tcontrol->flags = FLAG_SHOW_PROGRESS | FLAG_KEEP_FILES | FLAG_THRESHOLD;\n\tcontrol->suffix = \".lrz\";\n\tcontrol->compression_level = 7;\n\tcontrol->ramsize = get_ram(control);\n\tif (unlikely(control->ramsize == -1))\n\t\treturn false;\n\tcontrol->threads = PROCESSORS;\t\n\tcontrol->page_size = PAGE_SIZE;\n\tcontrol->nice_val = 19;\n\tif (unlikely((now_t = time(NULL)) == ((time_t)-1)))\n\t\tfatal_return((\"Failed to call time in main\\n\"), false);\n\tif (unlikely(now_t < T_ZERO)) {\n\t\tprint_output(\"Warning your time reads before the year 2011, check your system clock\\n\");\n\t\tnow_t = T_ZERO;\n\t}\n\ttdiff = (now_t - T_ZERO) / 4;\n\tnow_t = T_ZERO + tdiff;\n\tcontrol->secs = now_t;\n\tcontrol->encloops = nloops(control->secs, control->salt, control->salt + 1);\n\tif (unlikely(!get_rand(control, control->salt + 2, 6)))\n\t\treturn false;\n\teptr = getenv(\"TMPDIR\");\n\tif (!eptr)\n\t\teptr = getenv(\"TMP\");\n\tif (!eptr)\n\t\teptr = getenv(\"TEMPDIR\");\n\tif (!eptr)\n\t\teptr = getenv(\"TEMP\");\n\tif (!eptr)\n\t\teptr = localeptr;\n\tlen = strlen(eptr);\n\tcontrol->tmpdir = malloc(len + 2);\n\tif (control->tmpdir == NULL)\n\t\tfatal_return((\"Failed to allocate for tmpdir\\n\"), false);\n\tstrcpy(control->tmpdir, eptr);\n\tif (control->tmpdir[len - 1] != '/') {\n\t\tcontrol->tmpdir[len] = '/'; \n\t\tcontrol->tmpdir[len + 1] = '\\0';\n\t}\n\treturn true;\n}", "target": 1}
{"code": "  void decode(bufferlist::iterator& bl) {\n    __u8 struct_v;\n    ::decode(struct_v, bl);\n    ::decode(nonce, bl);\n    if (struct_v >= 2) {\n      ::decode(have_challenge, bl);\n      ::decode(server_challenge_plus_one, bl);\n    }\n  }", "target": 0}
{"code": "ev_archive_new (void)\n{\n\treturn g_object_new (EV_TYPE_ARCHIVE, NULL);\n}", "target": 0}
{"code": "static std::vector<std::string> AllDirectoryPrefixes(const std::string& d) {\n  std::vector<std::string> dirs;\n  const std::string patched = PatchPattern(d);\n  StringPiece dir(patched);\n  bool is_directory = d[d.size() - 1] == '/';\n#ifdef PLATFORM_WINDOWS\n  is_directory = is_directory || (d[d.size() - 1] == '\\\\');\n#endif\n  if (is_directory) {\n    dir = io::Dirname(dir);\n  }\n  while (!dir.empty()) {\n    dirs.emplace_back(dir);\n    StringPiece new_dir(io::Dirname(dir));\n    if (dir == new_dir) break;\n    dir = new_dir;\n  }\n  std::reverse(dirs.begin(), dirs.end());\n  return dirs;\n}", "target": 0}
{"code": "void* CxImage::GetDIBLimit() const\n{\n    return pDibLimit;\n}", "target": 0}
{"code": "FILE *LightProcess::LightPopenImpl(const char *cmd, const char *type,\n                                   const char *cwd) {\n  int id = GetId();\n  Lock lock(g_procs[id].m_procMutex);\n  fprintf(g_procs[id].m_fout, \"popen\\n%s\\n%s\\n%s\\n\", type, cmd, cwd);\n  fflush(g_procs[id].m_fout);\n  char buf[BUFFER_SIZE];\n  read_buf(g_procs[id].m_fin, buf);\n  if (strncmp(buf, \"error\", 5) == 0) {\n    return nullptr;\n  }\n  int64_t fptr = 0;\n  read_buf(g_procs[id].m_fin, buf);\n  sscanf(buf, \"%\" PRId64, &fptr);\n  if (!fptr) {\n    Logger::Error(\"Light process failed to return the file pointer.\");\n    return nullptr;\n  }\n  int fd = recv_fd(g_procs[id].m_afdt_fd);\n  if (fd < 0) {\n    Logger::Error(\"Light process failed to send the file descriptor.\");\n    return nullptr;\n  }\n  FILE *f = fdopen(fd, type);\n  g_procs[id].m_popenMap[(int64_t)f] = fptr;\n  return f;\n}", "target": 1}
{"code": "static int get_task_ioprio(struct task_struct *p)\n{\n\tint ret;\n\tret = security_task_getioprio(p);\n\tif (ret)\n\t\tgoto out;\n\tret = IOPRIO_PRIO_VALUE(IOPRIO_CLASS_NONE, IOPRIO_NORM);\n\ttask_lock(p);\n\tif (p->io_context)\n\t\tret = p->io_context->ioprio;\n\ttask_unlock(p);\nout:\n\treturn ret;\n}", "target": 0}
{"code": "ext4_xattr_block_get(struct inode *inode, int name_index, const char *name,\n\t\t     void *buffer, size_t buffer_size)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct ext4_xattr_entry *entry;\n\tsize_t size;\n\tint error;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\tea_idebug(inode, \"name=%d.%s, buffer=%p, buffer_size=%ld\",\n\t\t  name_index, name, buffer, (long)buffer_size);\n\terror = -ENODATA;\n\tif (!EXT4_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tea_idebug(inode, \"reading block %llu\",\n\t\t  (unsigned long long)EXT4_I(inode)->i_file_acl);\n\tbh = sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl);\n\tif (!bh)\n\t\tgoto cleanup;\n\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\tatomic_read(&(bh->b_count)), le32_to_cpu(BHDR(bh)->h_refcount));\n\tif (ext4_xattr_check_block(inode, bh)) {\nbad_block:\n\t\tEXT4_ERROR_INODE(inode, \"bad block %llu\",\n\t\t\t\t EXT4_I(inode)->i_file_acl);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto cleanup;\n\t}\n\text4_xattr_cache_insert(ext4_mb_cache, bh);\n\tentry = BFIRST(bh);\n\terror = ext4_xattr_find_entry(&entry, name_index, name, bh->b_size, 1);\n\tif (error == -EFSCORRUPTED)\n\t\tgoto bad_block;\n\tif (error)\n\t\tgoto cleanup;\n\tsize = le32_to_cpu(entry->e_value_size);\n\tif (buffer) {\n\t\terror = -ERANGE;\n\t\tif (size > buffer_size)\n\t\t\tgoto cleanup;\n\t\tmemcpy(buffer, bh->b_data + le16_to_cpu(entry->e_value_offs),\n\t\t       size);\n\t}\n\terror = size;\ncleanup:\n\tbrelse(bh);\n\treturn error;\n}", "target": 1}
{"code": "static int _sqlite_rollback_txn(void *db, const sasl_utils_t *utils)\n{\n    return _sqlite_exec(db, \"ROLLBACK TRANSACTION\", NULL, 0, NULL, utils);\n}", "target": 0}
{"code": "remote_addr(VALUE self) {\n    return req_remote_addr((agooReq)DATA_PTR(self));\n}", "target": 0}
{"code": "static void sctp_skb_set_owner_r_frag(struct sk_buff *skb, struct sock *sk)\n{\n\tstruct sk_buff *frag;\n\tif (!skb->data_len)\n\t\tgoto done;\n\tfor (frag = skb_shinfo(skb)->frag_list; frag; frag = frag->next)\n\t\tsctp_skb_set_owner_r_frag(frag, sk);\ndone:\n\tsctp_skb_set_owner_r(skb, sk);\n}", "target": 0}
{"code": "static int turn_dns_lookup(struct zapi_ice_server *turn,\n\t\t\t   struct stun_uri *uri)\n{\n\tstruct lookup_entry *lent;\n\tint err = 0;\n\tlent = mem_zalloc(sizeof(*lent), lent_destructor);\n\tif (!lent)\n\t\treturn ENOMEM;\n\tlent->turn = *turn;\n\tlent->ts = tmr_jiffies();\n\tlent->proto = uri->proto;\n\tlent->secure = uri->secure;\n\tlent->port = uri->port;\n\terr = str_dup(&lent->host, uri->host);\n\tif (err)\n\t\tgoto out;\n\tre_printf(\"dns_lookup for: %s:%d\\n\", lent->host, lent->port);\n\terr = dns_lookup(lent->host, dns_handler, lent);\n\tif (err) {\n\t\twarning(\"dns_lookup: failed: %m\\n\", err);\n\t\tgoto out;\n\t}\n out:\n\tif (err)\n\t\tmem_deref(lent);\n\treturn err;\n}", "target": 0}
{"code": "static void llc_sap_rcv(struct llc_sap *sap, struct sk_buff *skb,\n\t\t\tstruct sock *sk)\n{\n\tstruct llc_sap_state_ev *ev = llc_sap_ev(skb);\n\tev->type   = LLC_SAP_EV_TYPE_PDU;\n\tev->reason = 0;\n\tskb_orphan(skb);\n\tsock_hold(sk);\n\tskb->sk = sk;\n\tskb->destructor = sock_efree;\n\tllc_sap_state_process(sap, skb);\n}", "target": 0}
{"code": "int ptrace_setxregs(struct task_struct *child, void __user *uregs)\n{\n\tstruct thread_info *ti = task_thread_info(child);\n\tstruct pt_regs *regs = task_pt_regs(child);\n\telf_xtregs_t *xtregs = uregs;\n\tint ret = 0;\n\tif (!access_ok(VERIFY_READ, uregs, sizeof(elf_xtregs_t)))\n\t\treturn -EFAULT;\n#if XTENSA_HAVE_COPROCESSORS\n\tcoprocessor_flush_all(ti);\n\tcoprocessor_release_all(ti);\n\tret |= __copy_from_user(&ti->xtregs_cp, &xtregs->cp0, \n\t\t\t\tsizeof(xtregs_coprocessor_t));\n#endif\n\tret |= __copy_from_user(&regs->xtregs_opt, &xtregs->opt,\n\t\t\t\tsizeof(xtregs->opt));\n\tret |= __copy_from_user(&ti->xtregs_user, &xtregs->user,\n\t\t\t\tsizeof(xtregs->user));\n\treturn ret ? -EFAULT : 0;\n}", "target": 0}
{"code": "static void srv_close(void)\n{\n\tverifyd.sock = mem_deref(verifyd.sock);\n}", "target": 0}
{"code": "QPDFWriter::enqueueObject(QPDFObjectHandle object)\n{\n    if (object.isIndirect())\n    {\n        if (object.getOwningQPDF() != &(this->pdf))\n        {\n            QTC::TC(\"qpdf\", \"QPDFWriter foreign object\");\n            throw std::logic_error(\n                \"QPDFObjectHandle from different QPDF found while writing.\"\n                \"  Use QPDF::copyForeignObject to add objects from\"\n                \" another file.\");\n        }\n\tQPDFObjGen og = object.getObjGen();\n\tif (obj_renumber.count(og) == 0)\n\t{\n\t    if (this->object_to_object_stream.count(og))\n\t    {\n\t\tint stream_id = this->object_to_object_stream[og];\n                obj_renumber[og] = 0;\n\t\tenqueueObject(this->pdf.getObjectByID(stream_id, 0));\n\t    }\n\t    else\n\t    {\n\t\tobject_queue.push_back(object);\n\t\tobj_renumber[og] = next_objid++;\n\t\tif ((og.getGen() == 0) &&\n                    this->object_stream_to_objects.count(og.getObj()))\n\t\t{\n\t\t    if (! this->linearized)\n\t\t    {\n\t\t\tassignCompressedObjectNumbers(og);\n\t\t    }\n\t\t}\n\t\telse if ((! this->direct_stream_lengths) && object.isStream())\n\t\t{\n\t\t    ++next_objid;\n\t\t}\n\t    }\n\t}\n        else if (obj_renumber[og] == 0)\n        {\n            QTC::TC(\"qpdf\", \"QPDFWriter ignore self-referential object stream\");\n        }\n    }\n    else if (object.isArray())\n    {\n\tint n = object.getArrayNItems();\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t    if (! this->linearized)\n\t    {\n\t\tenqueueObject(object.getArrayItem(i));\n\t    }\n\t}\n    }\n    else if (object.isDictionary())\n    {\n\tstd::set<std::string> keys = object.getKeys();\n\tfor (std::set<std::string>::iterator iter = keys.begin();\n\t     iter != keys.end(); ++iter)\n\t{\n\t    if (! this->linearized)\n\t    {\n\t\tenqueueObject(object.getKey(*iter));\n\t    }\n\t}\n    }\n    else\n    {\n    }\n}", "target": 0}
{"code": "BOOL freerdp_bitmap_planar_context_reset(BITMAP_PLANAR_CONTEXT* context, UINT32 width,\n                                         UINT32 height)\n{\n\tif (!context)\n\t\treturn FALSE;\n\tcontext->bgr = FALSE;\n\tcontext->maxWidth = PLANAR_ALIGN(width, 4);\n\tcontext->maxHeight = PLANAR_ALIGN(height, 4);\n\tcontext->maxPlaneSize = context->maxWidth * context->maxHeight;\n\tcontext->nTempStep = context->maxWidth * 4;\n\tfree(context->planesBuffer);\n\tfree(context->pTempData);\n\tfree(context->deltaPlanesBuffer);\n\tfree(context->rlePlanesBuffer);\n\tcontext->planesBuffer = calloc(context->maxPlaneSize, 4);\n\tcontext->pTempData = calloc(context->maxPlaneSize, 6);\n\tcontext->deltaPlanesBuffer = calloc(context->maxPlaneSize, 4);\n\tcontext->rlePlanesBuffer = calloc(context->maxPlaneSize, 4);\n\tif (!context->planesBuffer || !context->pTempData || !context->deltaPlanesBuffer ||\n\t    !context->rlePlanesBuffer)\n\t\treturn FALSE;\n\tcontext->planes[0] = &context->planesBuffer[context->maxPlaneSize * 0];\n\tcontext->planes[1] = &context->planesBuffer[context->maxPlaneSize * 1];\n\tcontext->planes[2] = &context->planesBuffer[context->maxPlaneSize * 2];\n\tcontext->planes[3] = &context->planesBuffer[context->maxPlaneSize * 3];\n\tcontext->deltaPlanes[0] = &context->deltaPlanesBuffer[context->maxPlaneSize * 0];\n\tcontext->deltaPlanes[1] = &context->deltaPlanesBuffer[context->maxPlaneSize * 1];\n\tcontext->deltaPlanes[2] = &context->deltaPlanesBuffer[context->maxPlaneSize * 2];\n\tcontext->deltaPlanes[3] = &context->deltaPlanesBuffer[context->maxPlaneSize * 3];\n\treturn TRUE;\n}", "target": 1}
{"code": "const char *jsi_GetHomeDir(Jsi_Interp *interp) {\n    const char *str = NULL;\n    if (interp->homeDir)\n        return interp->homeDir;\n#ifdef __WIN32\n    str = getenv(\"USERPROFILE\"); \n#else\n    if ((str = getenv(\"HOME\")) == NULL) {\n        struct passwd pwd, *pw;\n        char buf[20000];\n        if (getpwuid_r(getuid(), &pwd, buf, sizeof(buf), &pw) == 0 && pw->pw_dir)        \n            str = pw->pw_dir;\n    }\n#endif\n    if (!str) {\n        Jsi_LogBug(\"no home dir\");\n        str = \"/\";\n    }\n#ifdef JSI_LITE_ONLY\n    return str;\n#else\n    return (interp->homeDir = Jsi_KeyAdd(interp, str));\n#endif\n}", "target": 1}
{"code": "void test_path_dotgit__dotgit_modules_symlink(void)\n{\n\tcl_assert_equal_b(true, git_path_isvalid(NULL, \".gitmodules\", 0, GIT_PATH_REJECT_DOT_GIT_HFS|GIT_PATH_REJECT_DOT_GIT_NTFS));\n\tcl_assert_equal_b(false, git_path_isvalid(NULL, \".gitmodules\", S_IFLNK, GIT_PATH_REJECT_DOT_GIT_HFS));\n\tcl_assert_equal_b(false, git_path_isvalid(NULL, \".gitmodules\", S_IFLNK, GIT_PATH_REJECT_DOT_GIT_NTFS));\n\tcl_assert_equal_b(false, git_path_isvalid(NULL, \".gitmodules . .::$DATA\", S_IFLNK, GIT_PATH_REJECT_DOT_GIT_NTFS));\n}", "target": 0}
{"code": "static int crypto_rsa_common(const BYTE* input, int length, UINT32 key_length, const BYTE* modulus,\n                             const BYTE* exponent, int exponent_size, BYTE* output)\n{\n\tBN_CTX* ctx;\n\tint output_length = -1;\n\tBYTE* input_reverse;\n\tBYTE* modulus_reverse;\n\tBYTE* exponent_reverse;\n\tBIGNUM *mod, *exp, *x, *y;\n\tinput_reverse = (BYTE*)malloc(2 * key_length + exponent_size);\n\tif (!input_reverse)\n\t\treturn -1;\n\tmodulus_reverse = input_reverse + key_length;\n\texponent_reverse = modulus_reverse + key_length;\n\tmemcpy(modulus_reverse, modulus, key_length);\n\tcrypto_reverse(modulus_reverse, key_length);\n\tmemcpy(exponent_reverse, exponent, exponent_size);\n\tcrypto_reverse(exponent_reverse, exponent_size);\n\tmemcpy(input_reverse, input, length);\n\tcrypto_reverse(input_reverse, length);\n\tif (!(ctx = BN_CTX_new()))\n\t\tgoto fail_bn_ctx;\n\tif (!(mod = BN_new()))\n\t\tgoto fail_bn_mod;\n\tif (!(exp = BN_new()))\n\t\tgoto fail_bn_exp;\n\tif (!(x = BN_new()))\n\t\tgoto fail_bn_x;\n\tif (!(y = BN_new()))\n\t\tgoto fail_bn_y;\n\tBN_bin2bn(modulus_reverse, key_length, mod);\n\tBN_bin2bn(exponent_reverse, exponent_size, exp);\n\tBN_bin2bn(input_reverse, length, x);\n\tBN_mod_exp(y, x, exp, mod, ctx);\n\toutput_length = BN_bn2bin(y, output);\n\tcrypto_reverse(output, output_length);\n\tif (output_length < (int)key_length)\n\t\tmemset(output + output_length, 0, key_length - output_length);\n\tBN_free(y);\nfail_bn_y:\n\tBN_clear_free(x);\nfail_bn_x:\n\tBN_free(exp);\nfail_bn_exp:\n\tBN_free(mod);\nfail_bn_mod:\n\tBN_CTX_free(ctx);\nfail_bn_ctx:\n\tfree(input_reverse);\n\treturn output_length;\n}", "target": 1}
{"code": "static inline void perf_cgroup_sched_out(struct task_struct *task,\n\t\t\t\t\t struct task_struct *next)\n{\n}", "target": 0}
{"code": "void kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP &&\n\t    kvm_is_linear_rip(vcpu, vcpu->arch.singlestep_rip))\n\t\trflags |= X86_EFLAGS_TF;\n\tkvm_x86_ops->set_rflags(vcpu, rflags);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}", "target": 0}
{"code": "bool do_memory_ranges_overlap(size_t range1Start, size_t range1End, size_t range2Start, size_t range2End) {\n  if (range1Start <= range2Start) {\n    return range2Start < range1End;\n  } else {\n    return range1Start < range2End;\n  }\n}", "target": 0}
{"code": "void HeaderMapImpl::addSize(uint64_t size) {\n  if (cached_byte_size_.has_value()) {\n    cached_byte_size_.value() += size;\n  }\n}", "target": 0}
{"code": "R_API RBinJavaAttrInfo *r_bin_java_line_number_table_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tut64 curpos, offset = 0;\n\tRBinJavaLineNumberAttribute *lnattr;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\toffset += 6;\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_LINE_NUMBER_TABLE_ATTR;\n\tattr->info.line_number_table_attr.line_number_table_length = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.line_number_table_attr.line_number_table = r_list_newf (free);\n\tut32 linenum_len = attr->info.line_number_table_attr.line_number_table_length;\n\tRList *linenum_list = attr->info.line_number_table_attr.line_number_table;\n\tif (linenum_len > sz) {\n\t\tfree (attr);\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < linenum_len; i++) {\n\t\tcurpos = buf_offset + offset;\n\t\tlnattr = R_NEW0 (RBinJavaLineNumberAttribute);\n\t\tif (!lnattr) {\n\t\t\tbreak;\n\t\t}\n\t\tlnattr->start_pc = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlnattr->line_number = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlnattr->file_offset = curpos;\n\t\tlnattr->size = 4;\n\t\tr_list_append (linenum_list, lnattr);\n\t}\n\tattr->size = offset;\n\treturn attr;\n}", "target": 1}
{"code": "TfLiteStatus SimpleStatefulOp::Invoke(TfLiteContext* context,\n                                      TfLiteNode* node) {\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n  *data->invoke_count += 1;\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const uint8_t* input_data = GetTensorData<uint8_t>(input);\n  int size = NumElements(input->dims);\n  uint8_t* sorting_buffer = reinterpret_cast<uint8_t*>(\n      context->GetScratchBuffer(context, data->sorting_buffer));\n  for (int i = 0; i < size; i++) {\n    sorting_buffer[i] = input_data[i];\n  }\n  for (int i = 1; i < size; i++) {\n    for (int j = i; j > 0 && sorting_buffer[j] < sorting_buffer[j - 1]; j--) {\n      std::swap(sorting_buffer[j], sorting_buffer[j - 1]);\n    }\n  }\n  TfLiteTensor* median = GetOutput(context, node, kMedianTensor);\n  uint8_t* median_data = GetTensorData<uint8_t>(median);\n  TfLiteTensor* invoke_count = GetOutput(context, node, kInvokeCount);\n  int32_t* invoke_count_data = GetTensorData<int32_t>(invoke_count);\n  median_data[0] = sorting_buffer[size / 2];\n  invoke_count_data[0] = *data->invoke_count;\n  return kTfLiteOk;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& in0 = ctx->input(0);\n    const Tensor& in1 = ctx->input(1);\n    OP_REQUIRES(\n        ctx, in0.NumElements() == in1.NumElements(),\n        errors::InvalidArgument(\"The two arguments to a cwise op must have \"\n                                \"same number of elements, got \",\n                                in0.NumElements(), \" and \", in1.NumElements()));\n    auto in0_flat = in0.flat<Tin>();\n    auto in1_flat = in1.flat<Tin>();\n    const Device& eigen_device = ctx->eigen_device<Device>();\n    Tensor* out = nullptr;\n    if (std::is_same<Tin, Tout>::value) {\n      OP_REQUIRES_OK(ctx, ctx->forward_input_or_allocate_output(\n                              {0, 1}, 0, in0.shape(), &out));\n    } else {\n      OP_REQUIRES_OK(ctx, ctx->allocate_output(0, in0.shape(), &out));\n    }\n    auto out_flat = out->flat<Tout>();\n    functor::SimpleBinaryFunctor<Device, Functor>()(eigen_device, out_flat,\n                                                    in0_flat, in1_flat);\n  }", "target": 0}
{"code": "void SFS_Params(ScriptParser *parser)\n{\n\tu32 val;\n\tif (parser->codec->LastError) return;\n\tval = gf_bs_read_int(parser->bs, 1);\n\twhile (val) {\n\t\tSFS_Expression(parser);\n\t\tif (parser->codec->LastError) return;\n\t\tval = gf_bs_read_int(parser->bs, 1);\n\t\tif(val) SFS_AddString(parser, \",\");\n\t}\n}", "target": 0}
{"code": "int jas_stream_write(jas_stream_t *stream, const void *buf, int cnt)\n{\n\tint n;\n\tconst char *bufptr;\n\tif (cnt < 0) {\n\t\tjas_deprecated(\"negative count for jas_stream_write\");\n\t}\n\tbufptr = buf;\n\tn = 0;\n\twhile (n < cnt) {\n\t\tif (jas_stream_putc(stream, *bufptr) == EOF) {\n\t\t\treturn n;\n\t\t}\n\t\t++bufptr;\n\t\t++n;\n\t}\n\treturn n;\n}", "target": 0}
{"code": "TEE_Result tee_mmu_check_access_rights(const struct user_ta_ctx *utc,\n\t\t\t\t       uint32_t flags, uaddr_t uaddr,\n\t\t\t\t       size_t len)\n{\n\tuaddr_t a;\n\tsize_t addr_incr = MIN(CORE_MMU_USER_CODE_SIZE,\n\t\t\t       CORE_MMU_USER_PARAM_SIZE);\n\tif (ADD_OVERFLOW(uaddr, len, &a))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t    (flags & TEE_MEMORY_ACCESS_SECURE))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\tif (!(flags & TEE_MEMORY_ACCESS_ANY_OWNER) &&\n\t   !tee_mmu_is_vbuf_inside_ta_private(utc, (void *)uaddr, len))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\tfor (a = uaddr; a < (uaddr + len); a += addr_incr) {\n\t\tuint32_t attr;\n\t\tTEE_Result res;\n\t\tres = tee_mmu_user_va2pa_attr(utc, (void *)a, NULL, &attr);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t\t    (attr & TEE_MATTR_SECURE))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t\tif ((flags & TEE_MEMORY_ACCESS_SECURE) &&\n\t\t    !(attr & TEE_MATTR_SECURE))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t\tif ((flags & TEE_MEMORY_ACCESS_WRITE) && !(attr & TEE_MATTR_UW))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t\tif ((flags & TEE_MEMORY_ACCESS_READ) && !(attr & TEE_MATTR_UR))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t}\n\treturn TEE_SUCCESS;\n}", "target": 1}
{"code": "void test_mkdir(const char *path)\n{\n\tsize_t len = strlen(path) + 30;\n\tchar *tmpname = alloca(len);\n\tsnprintf(tmpname, len, \"%s/%d\", path, (int)getpid());\n\tif (mkdir(path, 0755) == 0) {\n\t\tfprintf(stderr, \"leak at mkdir of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT) {\n\t\tfprintf(stderr, \"leak at mkdir of %s, errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n\tif (mkdir(tmpname, 0755) == 0) {\n\t\tfprintf(stderr, \"leak at mkdir of %s\\n\", tmpname);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT) {\n\t\tfprintf(stderr, \"leak at mkdir of %s, errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "int hashtable_set(hashtable_t *hashtable,\n                  const char *key, size_t serial,\n                  json_t *value)\n{\n    pair_t *pair;\n    bucket_t *bucket;\n    size_t hash, index;\n    if(hashtable->size >= num_buckets(hashtable))\n        if(hashtable_do_rehash(hashtable))\n            return -1;\n    hash = hash_str(key);\n    index = hash % num_buckets(hashtable);\n    bucket = &hashtable->buckets[index];\n    pair = hashtable_find_pair(hashtable, bucket, key, hash);\n    if(pair)\n    {\n        json_decref(pair->value);\n        pair->value = value;\n    }\n    else\n    {\n        pair = jsonp_malloc(offsetof(pair_t, key) + strlen(key) + 1);\n        if(!pair)\n            return -1;\n        pair->hash = hash;\n        pair->serial = serial;\n        strcpy(pair->key, key);\n        pair->value = value;\n        list_init(&pair->list);\n        insert_to_bucket(hashtable, bucket, &pair->list);\n        hashtable->size++;\n    }\n    return 0;\n}", "target": 1}
{"code": "void initialize_CABAC_models(thread_context* tctx)\n{\n  const int QPY = tctx->shdr->SliceQPY;\n  const int initType = tctx->shdr->initType;\n  assert(initType >= 0 && initType <= 2);\n  tctx->ctx_model.init(initType, QPY);\n  for (int i=0;i<4;i++) {\n    tctx->StatCoeff[i] = 0;\n  }\n}", "target": 0}
{"code": "WebWidget* RenderView::createPopupMenu(WebKit::WebPopupType popup_type) {\n  RenderWidget* widget = RenderWidget::Create(routing_id_,\n                                              render_thread_,\n                                              popup_type);\n  return widget->webwidget();\n}", "target": 0}
{"code": "  static Status ParseEquation(const string& equation,\n                              OperandLabels* input_labels,\n                              Labels* output_labels,\n                              std::vector<DimensionType>* label_types,\n                              OperandLabelCounts* input_label_counts,\n                              LabelCounts* output_label_counts,\n                              gtl::InlinedVector<bool, 2>* input_has_ellipsis,\n                              bool* output_has_ellipsis) {\n    gtl::InlinedVector<string, 2> input_str;\n    string output_str;\n    TF_RETURN_IF_ERROR(ParseEinsumEquation(equation, &input_str, &output_str));\n    absl::flat_hash_map<char, int> label_mapping;\n    int num_inputs = input_str.size();\n    input_labels->resize(num_inputs);\n    for (int i = 0; i < num_inputs; ++i) {\n      MapToLabels(input_str[i], &input_labels->at(i), &label_mapping);\n    }\n    MapToLabels(output_str, output_labels, &label_mapping);\n    int num_labels = label_mapping.size();\n    input_label_counts->resize(num_inputs);\n    input_has_ellipsis->resize(num_inputs);\n    for (int i = 0; i < num_inputs; ++i) {\n      input_label_counts->at(i).resize(num_labels);\n      input_has_ellipsis->at(i) = false;\n      for (const int label : input_labels->at(i)) {\n        if (label != kEllipsisLabel)\n          input_label_counts->at(i)[label] += 1;\n        else\n          input_has_ellipsis->at(i) = true;\n      }\n    }\n    output_label_counts->resize(num_labels);\n    *output_has_ellipsis = false;\n    for (const int label : *output_labels) {\n      if (label != kEllipsisLabel)\n        output_label_counts->at(label) += 1;\n      else\n        *output_has_ellipsis = true;\n    }\n    label_types->resize(num_labels);\n    for (int label = 0; label < num_labels; ++label) {\n      if (label == kEllipsisLabel) continue;\n      bool removed = (*output_label_counts)[label] == 0;\n      bool unique = num_inputs == 1 || (*input_label_counts)[0][label] == 0 ||\n                    (*input_label_counts)[1][label] == 0;\n      (*label_types)[label] = GetDimensionType(removed, unique);\n    }\n    return Status::OK();\n  }", "target": 0}
{"code": "static int check_passwd(unsigned char *passwd, size_t length)\n{\n\tstruct digest *d = NULL;\n\tunsigned char *passwd1_sum;\n\tunsigned char *passwd2_sum;\n\tint ret = 0;\n\tint hash_len;\n\tif (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) {\n\t\thash_len = PBKDF2_LENGTH;\n\t} else {\n\t\td = digest_alloc(PASSWD_SUM);\n\t\tif (!d) {\n\t\t\tpr_err(\"No such digest: %s\\n\",\n\t\t\t       PASSWD_SUM ? PASSWD_SUM : \"NULL\");\n\t\t\treturn -ENOENT;\n\t\t}\n\t\thash_len = digest_length(d);\n\t}\n\tpasswd1_sum = calloc(hash_len * 2, sizeof(unsigned char));\n\tif (!passwd1_sum)\n\t\treturn -ENOMEM;\n\tpasswd2_sum = passwd1_sum + hash_len;\n\tif (is_passwd_env_enable())\n\t\tret = read_env_passwd(passwd2_sum, hash_len);\n\telse if (is_passwd_default_enable())\n\t\tret = read_default_passwd(passwd2_sum, hash_len);\n\telse\n\t\tret = -EINVAL;\n\tif (ret < 0)\n\t\tgoto err;\n\tif (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) {\n\t\tchar *key = passwd2_sum + PBKDF2_SALT_LEN;\n\t\tchar *salt = passwd2_sum;\n\t\tint keylen = PBKDF2_LENGTH - PBKDF2_SALT_LEN;\n\t\tret = pkcs5_pbkdf2_hmac_sha1(passwd, length, salt,\n\t\t\tPBKDF2_SALT_LEN, PBKDF2_COUNT, keylen, passwd1_sum);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tif (strncmp(passwd1_sum, key, keylen) == 0)\n\t\t\tret = 1;\n\t} else {\n\t\tret = digest_digest(d, passwd, length, passwd1_sum);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tif (strncmp(passwd1_sum, passwd2_sum, hash_len) == 0)\n\t\t\tret = 1;\n\t}\nerr:\n\tfree(passwd1_sum);\n\tdigest_free(d);\n\treturn ret;\n}", "target": 1}
{"code": "void luaT_adjustvarargs (lua_State *L, int nfixparams, CallInfo *ci,\n                         const Proto *p) {\n  int i;\n  int actual = cast_int(L->top - ci->func) - 1;  \n  int nextra = actual - nfixparams;  \n  ci->u.l.nextraargs = nextra;\n  checkstackGC(L, p->maxstacksize + 1);\n  setobjs2s(L, L->top++, ci->func);\n  for (i = 1; i <= nfixparams; i++) {\n    setobjs2s(L, L->top++, ci->func + i);\n    setnilvalue(s2v(ci->func + i));  \n  }\n  ci->func += actual + 1;\n  ci->top += actual + 1;\n  lua_assert(L->top <= ci->top && ci->top <= L->stack_last);\n}", "target": 1}
{"code": "snmp_ber_encode_string_len(unsigned char *out, uint32_t *out_len, const char *str, uint32_t length)\n{\n  uint32_t i;\n  str += length - 1;\n  for(i = 0; i < length; ++i) {\n    (*out_len)++;\n    *out-- = (uint8_t)*str--;\n  }\n  out = snmp_ber_encode_length(out, out_len, length);\n  out = snmp_ber_encode_type(out, out_len, BER_DATA_TYPE_OCTET_STRING);\n  return out;\n}", "target": 1}
{"code": "int iscsi_decode_text_input(\n\tu8 phase,\n\tu8 sender,\n\tchar *textbuf,\n\tu32 length,\n\tstruct iscsi_conn *conn)\n{\n\tstruct iscsi_param_list *param_list = conn->param_list;\n\tchar *tmpbuf, *start = NULL, *end = NULL;\n\ttmpbuf = kzalloc(length + 1, GFP_KERNEL);\n\tif (!tmpbuf) {\n\t\tpr_err(\"Unable to allocate memory for tmpbuf.\\n\");\n\t\treturn -1;\n\t}\n\tmemcpy(tmpbuf, textbuf, length);\n\ttmpbuf[length] = '\\0';\n\tstart = tmpbuf;\n\tend = (start + length);\n\twhile (start < end) {\n\t\tchar *key, *value;\n\t\tstruct iscsi_param *param;\n\t\tif (iscsi_extract_key_value(start, &key, &value) < 0) {\n\t\t\tkfree(tmpbuf);\n\t\t\treturn -1;\n\t\t}\n\t\tpr_debug(\"Got key: %s=%s\\n\", key, value);\n\t\tif (phase & PHASE_SECURITY) {\n\t\t\tif (iscsi_check_for_auth_key(key) > 0) {\n\t\t\t\tchar *tmpptr = key + strlen(key);\n\t\t\t\t*tmpptr = '=';\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tparam = iscsi_check_key(key, phase, sender, param_list);\n\t\tif (!param) {\n\t\t\tif (iscsi_add_notunderstood_response(key,\n\t\t\t\t\tvalue, param_list) < 0) {\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tstart += strlen(key) + strlen(value) + 2;\n\t\t\tcontinue;\n\t\t}\n\t\tif (iscsi_check_value(param, value) < 0) {\n\t\t\tkfree(tmpbuf);\n\t\t\treturn -1;\n\t\t}\n\t\tstart += strlen(key) + strlen(value) + 2;\n\t\tif (IS_PSTATE_PROPOSER(param)) {\n\t\t\tif (iscsi_check_proposer_state(param, value) < 0) {\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tSET_PSTATE_RESPONSE_GOT(param);\n\t\t} else {\n\t\t\tif (iscsi_check_acceptor_state(param, value, conn) < 0) {\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tSET_PSTATE_ACCEPTOR(param);\n\t\t}\n\t}\n\tkfree(tmpbuf);\n\treturn 0;\n}", "target": 1}
{"code": "void LanLinkProvider::udpBroadcastReceived()\n{\n    while (m_udpSocket.hasPendingDatagrams()) {\n        QByteArray datagram;\n        datagram.resize(m_udpSocket.pendingDatagramSize());\n        QHostAddress sender;\n        m_udpSocket.readDatagram(datagram.data(), datagram.size(), &sender);\n        if (sender.isLoopback() && !m_testMode)\n            continue;\n        NetworkPacket* receivedPacket = new NetworkPacket(QLatin1String(\"\"));\n        bool success = NetworkPacket::unserialize(datagram, receivedPacket);\n        if (!success) {\n            qCDebug(KDECONNECT_CORE) << \"Could not unserialize UDP packet\";\n            delete receivedPacket;\n            continue;\n        }\n        if (receivedPacket->type() != PACKET_TYPE_IDENTITY) {\n            qCDebug(KDECONNECT_CORE) << \"Received a UDP packet of wrong type\" << receivedPacket->type();\n            delete receivedPacket;\n            continue;\n        }\n        if (receivedPacket->get<QString>(QStringLiteral(\"deviceId\")) == KdeConnectConfig::instance().deviceId()) {\n            delete receivedPacket;\n            continue;\n        }\n        int tcpPort = receivedPacket->get<int>(QStringLiteral(\"tcpPort\"));\n        if (m_receivedIdentityPackets.size() > MAX_REMEMBERED_IDENTITY_PACKETS) {\n            qCWarning(KDECONNECT_CORE) << \"Too many remembered identities, ignoring\" << receivedPacket->get<QString>(QStringLiteral(\"deviceId\")) << \"received via UDP\";\n            delete receivedPacket;\n            continue;\n        }\n        QSslSocket* socket = new QSslSocket(this);\n        socket->setProxy(QNetworkProxy::NoProxy);\n        m_receivedIdentityPackets[socket].np = receivedPacket;\n        m_receivedIdentityPackets[socket].sender = sender;\n        connect(socket, &QAbstractSocket::connected, this, &LanLinkProvider::tcpSocketConnected);\n#if QT_VERSION < QT_VERSION_CHECK(5,15,0)\n        connect(socket, QOverload<QAbstractSocket::SocketError>::of(&QAbstractSocket::error), this, &LanLinkProvider::connectError);\n#else\n        connect(socket, &QAbstractSocket::errorOccurred, this, &LanLinkProvider::connectError);\n#endif\n        socket->connectToHost(sender, tcpPort);\n    }\n}", "target": 0}
{"code": "static void svm_handle_exit_irqoff(struct kvm_vcpu *vcpu)\n{\n\tif (to_svm(vcpu)->vmcb->control.exit_code == SVM_EXIT_INTR)\n\t\tvcpu->arch.at_instruction_boundary = true;\n}", "target": 0}
{"code": "MONGO_EXPORT int bson_append_code_n( bson *b, const char *name, const char *value, int len ) {\n    return bson_append_string_base( b, name, value, len, BSON_CODE );\n}", "target": 1}
{"code": "static void ip6_append_data_mtu(int *mtu,\n\t\t\t\tint *maxfraglen,\n\t\t\t\tunsigned int fragheaderlen,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tstruct rt6_info *rt)\n{\n\tif (!(rt->dst.flags & DST_XFRM_TUNNEL)) {\n\t\tif (skb == NULL) {\n\t\t\t*mtu = *mtu - rt->dst.header_len;\n\t\t} else {\n\t\t\t*mtu = dst_mtu(rt->dst.path);\n\t\t}\n\t\t*maxfraglen = ((*mtu - fragheaderlen) & ~7)\n\t\t\t      + fragheaderlen - sizeof(struct frag_hdr);\n\t}\n}", "target": 1}
{"code": "static std::string PatchPattern(const std::string& pattern) {\n  const std::string fixed_prefix =\n      pattern.substr(0, pattern.find_first_of(kGlobbingChars));\n  if (io::Dirname(fixed_prefix).empty()) {\n    return io::JoinPath(\".\", pattern);\n  }\n  return pattern;\n}", "target": 0}
{"code": "static int handle_invvpid(struct kvm_vcpu *vcpu)\n{\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\treturn 1;\n}", "target": 0}
{"code": "void RenderWidgetHostImpl::SetView(RenderWidgetHostViewBase* view) {\n  if (view)\n    view_ = view->GetWeakPtr();\n  else\n    view_.reset();\n  if (view_ && renderer_initialized_) {\n    Send(new ViewMsg_SetSurfaceIdNamespace(routing_id_,\n                                           view_->GetSurfaceIdNamespace()));\n  }\n  synthetic_gesture_controller_.reset();\n}", "target": 0}
{"code": "static void sgi_timer_get(struct k_itimer *timr, struct itimerspec *cur_setting)\n{\n\tif (timr->it.mmtimer.clock == TIMER_OFF) {\n\t\tcur_setting->it_interval.tv_nsec = 0;\n\t\tcur_setting->it_interval.tv_sec = 0;\n\t\tcur_setting->it_value.tv_nsec = 0;\n\t\tcur_setting->it_value.tv_sec =0;\n\t\treturn;\n\t}\n\tns_to_timespec(cur_setting->it_interval, timr->it.mmtimer.incr * sgi_clock_period);\n\tns_to_timespec(cur_setting->it_value, (timr->it.mmtimer.expires - rtc_time())* sgi_clock_period);\n\treturn;\n}", "target": 1}
{"code": "static int dynamicGetbuf(gdIOCtxPtr ctx, void *buf, int len)\n{\n\tint rlen, remain;\n\tdpIOCtxPtr dctx;\n\tdynamicPtr *dp;\n\tdctx = (dpIOCtxPtr) ctx;\n\tdp = dctx->dp;\n\tif (dp->pos < 0 || dp->pos >= dp->realSize) {\n\t\treturn 0;\n\t}\n\tremain = dp->logicalSize - dp->pos;\n\tif(remain >= len) {\n\t\trlen = len;\n\t} else {\n\t\tif(remain <= 0) {\n\t\t\treturn 0;\n\t\t}\n\t\trlen = remain;\n\t}\n\tif (dp->pos + rlen > dp->realSize) {\n\t\trlen = dp->realSize - dp->pos;\n\t}\n\tmemcpy(buf, (void *) ((char *)dp->data + dp->pos), rlen);\n\tdp->pos += rlen;\n\treturn rlen;\n}", "target": 0}
{"code": "static int write_empty_blocks(struct page *page, unsigned from, unsigned to,\n\t\t\t      int mode)\n{\n\tstruct inode *inode = page->mapping->host;\n\tunsigned start, end, next, blksize;\n\tsector_t block = page->index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\tint ret;\n\tblksize = 1 << inode->i_blkbits;\n\tnext = end = 0;\n\twhile (next < from) {\n\t\tnext += blksize;\n\t\tblock++;\n\t}\n\tstart = next;\n\tdo {\n\t\tnext += blksize;\n\t\tret = needs_empty_write(block, inode);\n\t\tif (unlikely(ret < 0))\n\t\t\treturn ret;\n\t\tif (ret == 0) {\n\t\t\tif (end) {\n\t\t\t\tret = __block_write_begin(page, start, end - start,\n\t\t\t\t\t\t\t  gfs2_block_map);\n\t\t\t\tif (unlikely(ret))\n\t\t\t\t\treturn ret;\n\t\t\t\tret = empty_write_end(page, start, end, mode);\n\t\t\t\tif (unlikely(ret))\n\t\t\t\t\treturn ret;\n\t\t\t\tend = 0;\n\t\t\t}\n\t\t\tstart = next;\n\t\t}\n\t\telse\n\t\t\tend = next;\n\t\tblock++;\n\t} while (next < to);\n\tif (end) {\n\t\tret = __block_write_begin(page, start, end - start, gfs2_block_map);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t\tret = empty_write_end(page, start, end, mode);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static void jsonNewDString(Jsi_Interp *interp, Jsi_DString *dStr, const char* str, int len)\n{\n    char buf[100], *dp = buf;\n    const char *cp = str;\n    int ulen;\n    while ((cp-str)<len) {\n        if (*cp == '\\\\') {\n            switch (cp[1]) {\n                case 'b': *dp++ = '\\b'; break;\n                case 'n': *dp++ = '\\n'; break;\n                case 'r': *dp++ = '\\r'; break;\n                case 'f': *dp++ = '\\f'; break;\n                case 't': *dp++ = '\\t'; break;\n                case '\\\"': *dp++ = '\\\"'; break;\n                case '\\\\': *dp++ = '\\\\'; break;\n                case 'u': \n                    if ((ulen=Jsi_UtfDecode(cp+2, dp))) {\n                        dp += ulen;\n                        cp += 4;\n                    } else {                    \n                        *dp++ = '\\\\';\n                        *dp++ = 'u';\n                    }\n                    break;\n            }\n            cp+=2;\n        } else {\n            *dp++ = *cp++;\n        }\n        if ((dp-buf)>90) {\n            *dp = 0;\n            Jsi_DSAppendLen(dStr, buf, dp-buf);\n            dp = buf;\n        }\n    }\n    *dp = 0;\n    Jsi_DSAppendLen(dStr, buf, dp-buf);\n}", "target": 1}
{"code": "long keyctl_set_reqkey_keyring(int reqkey_defl)\n{\n\tstruct cred *new;\n\tint ret, old_setting;\n\told_setting = current_cred_xxx(jit_keyring);\n\tif (reqkey_defl == KEY_REQKEY_DEFL_NO_CHANGE)\n\t\treturn old_setting;\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\tswitch (reqkey_defl) {\n\tcase KEY_REQKEY_DEFL_THREAD_KEYRING:\n\t\tret = install_thread_keyring_to_cred(new);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tgoto set;\n\tcase KEY_REQKEY_DEFL_PROCESS_KEYRING:\n\t\tret = install_process_keyring_to_cred(new);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -EEXIST)\n\t\t\t\tgoto error;\n\t\t\tret = 0;\n\t\t}\n\t\tgoto set;\n\tcase KEY_REQKEY_DEFL_DEFAULT:\n\tcase KEY_REQKEY_DEFL_SESSION_KEYRING:\n\tcase KEY_REQKEY_DEFL_USER_KEYRING:\n\tcase KEY_REQKEY_DEFL_USER_SESSION_KEYRING:\n\tcase KEY_REQKEY_DEFL_REQUESTOR_KEYRING:\n\t\tgoto set;\n\tcase KEY_REQKEY_DEFL_NO_CHANGE:\n\tcase KEY_REQKEY_DEFL_GROUP_KEYRING:\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\nset:\n\tnew->jit_keyring = reqkey_defl;\n\tcommit_creds(new);\n\treturn old_setting;\nerror:\n\tabort_creds(new);\n\treturn ret;\n}", "target": 1}
{"code": "static inline int file_list_cpu(struct file *file)\n{\n#ifdef CONFIG_SMP\n\treturn file->f_sb_list_cpu;\n#else\n\treturn smp_processor_id();\n#endif\n}", "target": 1}
{"code": "char *oidc_util_get_chunked_cookie(request_rec *r, const char *cookieName, int chunkSize) {\n\tchar *cookieValue = NULL;\n\tchar *chunkValue = NULL;\n\tint i = 0;\n\tif (chunkSize == 0) {\n\t\tcookieValue = oidc_util_get_cookie(r, cookieName);\n\t} else {\n\t\tint chunkCount = oidc_util_get_chunked_count(r, cookieName);\n\t\tif (chunkCount > 0) {\n\t\t\tcookieValue = \"\";\n\t\t\tfor (i = 0; i < chunkCount; i++) {\n\t\t\t\tchunkValue = oidc_util_get_cookie(r, oidc_util_get_chunk_cookie_name(r, cookieName, i));\n\t\t\t\tif (chunkValue != NULL)\n\t\t\t\t\tcookieValue = apr_psprintf(r->pool, \"%s%s\", cookieValue, chunkValue);\n\t\t\t}\n\t\t} else {\n\t\t\tcookieValue = oidc_util_get_cookie(r, cookieName);\n\t\t}\n\t}\n\treturn cookieValue;\n}", "target": 1}
{"code": "static void update_ia32_tsc_adjust_msr(struct kvm_vcpu *vcpu, s64 offset)\n{\n\tu64 curr_offset = kvm_x86_ops->read_tsc_offset(vcpu);\n\tvcpu->arch.ia32_tsc_adjust_msr += offset - curr_offset;\n}", "target": 0}
{"code": "static inline union cpu_time_count cpu_time_sub(const clockid_t which_clock,\n\t\t\t\t\t\tunion cpu_time_count a,\n\t\t\t\t\t\tunion cpu_time_count b)\n{\n\tif (CPUCLOCK_WHICH(which_clock) == CPUCLOCK_SCHED) {\n\t\ta.sched -= b.sched;\n\t}  else {\n\t\ta.cpu = cputime_sub(a.cpu, b.cpu);\n\t}\n\treturn a;\n}", "target": 0}
{"code": "R_API RCmdAliasVal *r_cmd_alias_get(RCmd *cmd, const char *k) {\n\tr_return_val_if_fail (cmd && cmd->aliases && k, NULL);\n\treturn ht_pp_find(cmd->aliases, k, NULL);\n}", "target": 1}
{"code": "    bool ms_verify_authorizer(Connection *con, int peer_type, int protocol,\n                              bufferlist& authorizer, bufferlist& authorizer_reply,\n                              bool& isvalid, CryptoKey& session_key) override {\n      isvalid = true;\n      return true;\n    }", "target": 1}
{"code": "static void vhost_net_ubuf_put_wait_and_free(struct vhost_net_ubuf_ref *ubufs)\n{\n\tvhost_net_ubuf_put_and_wait(ubufs);\n\tkfree(ubufs);\n}", "target": 0}
{"code": "static void keyring_describe(const struct key *keyring, struct seq_file *m)\n{\n\tif (keyring->description)\n\t\tseq_puts(m, keyring->description);\n\telse\n\t\tseq_puts(m, \"[anon]\");\n\tif (key_is_instantiated(keyring)) {\n\t\tif (keyring->keys.nr_leaves_on_tree != 0)\n\t\t\tseq_printf(m, \": %lu\", keyring->keys.nr_leaves_on_tree);\n\t\telse\n\t\t\tseq_puts(m, \": empty\");\n\t}\n}", "target": 1}
{"code": "apply_intended_configuration (GsdXrandrManager *manager, const char *intended_filename, guint32 timestamp)\n{\n        GError *my_error;\n        my_error = NULL;\n        if (!apply_configuration_from_filename (manager, intended_filename, FALSE, timestamp, &my_error)) {\n                if (my_error) {\n                        if (!g_error_matches (my_error, G_FILE_ERROR, G_FILE_ERROR_NOENT))\n                                error_message (manager, _(\"Could not apply the stored configuration for monitors\"), my_error, NULL);\n                        g_error_free (my_error);\n                }\n        }\n}", "target": 0}
{"code": "static int vmx_cpu_uses_apicv(struct kvm_vcpu *vcpu)\n{\n\treturn enable_apicv && lapic_in_kernel(vcpu);\n}", "target": 0}
{"code": "static void recalculate_apic_map(struct kvm *kvm)\n{\n\tstruct kvm_apic_map *new, *old = NULL;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\tnew = kzalloc(sizeof(struct kvm_apic_map), GFP_KERNEL);\n\tmutex_lock(&kvm->arch.apic_map_lock);\n\tif (!new)\n\t\tgoto out;\n\tnew->ldr_bits = 8;\n\tnew->cid_shift = 8;\n\tnew->cid_mask = 0;\n\tnew->lid_mask = 0xff;\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\t\tu16 cid, lid;\n\t\tu32 ldr;\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tnew->ldr_bits = 32;\n\t\t\tnew->cid_shift = 16;\n\t\t\tnew->cid_mask = new->lid_mask = 0xffff;\n\t\t} else if (kvm_apic_sw_enabled(apic) &&\n\t\t\t\t!new->cid_mask  &&\n\t\t\t\tkvm_apic_get_reg(apic, APIC_DFR) == APIC_DFR_CLUSTER) {\n\t\t\tnew->cid_shift = 4;\n\t\t\tnew->cid_mask = 0xf;\n\t\t\tnew->lid_mask = 0xf;\n\t\t}\n\t\tnew->phys_map[kvm_apic_id(apic)] = apic;\n\t\tldr = kvm_apic_get_reg(apic, APIC_LDR);\n\t\tcid = apic_cluster_id(new, ldr);\n\t\tlid = apic_logical_id(new, ldr);\n\t\tif (lid)\n\t\t\tnew->logical_map[cid][ffs(lid) - 1] = apic;\n\t}\nout:\n\told = rcu_dereference_protected(kvm->arch.apic_map,\n\t\t\tlockdep_is_held(&kvm->arch.apic_map_lock));\n\trcu_assign_pointer(kvm->arch.apic_map, new);\n\tmutex_unlock(&kvm->arch.apic_map_lock);\n\tif (old)\n\t\tkfree_rcu(old, rcu);\n\tkvm_vcpu_request_scan_ioapic(kvm);\n}", "target": 1}
{"code": "ModuleExport size_t RegisterXWDImage(void)\n{\n  MagickInfo\n    *entry;\n  entry=AcquireMagickInfo(\"XWD\",\"XWD\",\"X Windows system window dump (color)\");\n#if defined(MAGICKCORE_X11_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadXWDImage;\n  entry->encoder=(EncodeImageHandler *) WriteXWDImage;\n#endif\n  entry->magick=(IsImageFormatHandler *) IsXWD;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}", "target": 0}
{"code": "static void init_timeout(void *arg)\n{\n\tint local_port = *(int *)arg;\n\tinfo(\"init_timeout: srv_init\\n\");\n\tsrv_init((uint16_t)local_port);\n}", "target": 0}
{"code": "spnego_gss_context_time(\n\t\t\tOM_uint32\t*minor_status,\n\t\t\tconst gss_ctx_id_t context_handle,\n\t\t\tOM_uint32\t*time_rec)\n{\n\tOM_uint32 ret;\n\tret = gss_context_time(minor_status,\n\t\t\t    context_handle,\n\t\t\t    time_rec);\n\treturn (ret);\n}", "target": 1}
{"code": "static int EscChar(const char *src, char *dst, int dstlen, const char *specchars, char escchar)\n{\n   const char *p;\n   char *q, *end = dst+dstlen-1;\n   for (p = src, q = dst; *p && q < end; ) {\n      if (strchr(specchars, *p)) {\n         *q++ = escchar;\n         if (q < end)\n            *q++ = *p++;\n      } else\n         *q++ = *p++;\n   }\n   *q = '\\0';\n   if (*p != 0)\n      return -1;\n   return q-dst;\n}", "target": 1}
{"code": "static inline void mcryptd_check_internal(struct rtattr **tb, u32 *type,\n\t\t\t\t\t  u32 *mask)\n{\n\tstruct crypto_attr_type *algt;\n\talgt = crypto_get_attr_type(tb);\n\tif (IS_ERR(algt))\n\t\treturn;\n\tif ((algt->type & CRYPTO_ALG_INTERNAL))\n\t\t*type |= CRYPTO_ALG_INTERNAL;\n\tif ((algt->mask & CRYPTO_ALG_INTERNAL))\n\t\t*mask |= CRYPTO_ALG_INTERNAL;\n}", "target": 1}
{"code": "int setTypeAdd(robj *subject, sds value) {\n    long long llval;\n    if (subject->encoding == OBJ_ENCODING_HT) {\n        dict *ht = subject->ptr;\n        dictEntry *de = dictAddRaw(ht,value,NULL);\n        if (de) {\n            dictSetKey(ht,de,sdsdup(value));\n            dictSetVal(ht,de,NULL);\n            return 1;\n        }\n    } else if (subject->encoding == OBJ_ENCODING_INTSET) {\n        if (isSdsRepresentableAsLongLong(value,&llval) == C_OK) {\n            uint8_t success = 0;\n            subject->ptr = intsetAdd(subject->ptr,llval,&success);\n            if (success) {\n                if (intsetLen(subject->ptr) > server.set_max_intset_entries)\n                    setTypeConvert(subject,OBJ_ENCODING_HT);\n                return 1;\n            }\n        } else {\n            setTypeConvert(subject,OBJ_ENCODING_HT);\n            serverAssert(dictAdd(subject->ptr,sdsdup(value),NULL) == DICT_OK);\n            return 1;\n        }\n    } else {\n        serverPanic(\"Unknown set encoding\");\n    }\n    return 0;\n}", "target": 1}
{"code": "static int mincore_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,\n\t\t\tstruct mm_walk *walk)\n{\n\tspinlock_t *ptl;\n\tstruct vm_area_struct *vma = walk->vma;\n\tpte_t *ptep;\n\tunsigned char *vec = walk->private;\n\tint nr = (end - addr) >> PAGE_SHIFT;\n\tptl = pmd_trans_huge_lock(pmd, vma);\n\tif (ptl) {\n\t\tmemset(vec, 1, nr);\n\t\tspin_unlock(ptl);\n\t\tgoto out;\n\t}\n\tif (pmd_trans_unstable(pmd)) {\n\t\t__mincore_unmapped_range(addr, end, vma, vec);\n\t\tgoto out;\n\t}\n\tptep = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);\n\tfor (; addr != end; ptep++, addr += PAGE_SIZE) {\n\t\tpte_t pte = *ptep;\n\t\tif (pte_none(pte))\n\t\t\t__mincore_unmapped_range(addr, addr + PAGE_SIZE,\n\t\t\t\t\t\t vma, vec);\n\t\telse if (pte_present(pte))\n\t\t\t*vec = 1;\n\t\telse { \n\t\t\tswp_entry_t entry = pte_to_swp_entry(pte);\n\t\t\tif (non_swap_entry(entry)) {\n\t\t\t\t*vec = 1;\n\t\t\t} else {\n#ifdef CONFIG_SWAP\n\t\t\t\t*vec = mincore_page(swap_address_space(entry),\n\t\t\t\t\t\t    swp_offset(entry));\n#else\n\t\t\t\tWARN_ON(1);\n\t\t\t\t*vec = 1;\n#endif\n\t\t\t}\n\t\t}\n\t\tvec++;\n\t}\n\tpte_unmap_unlock(ptep - 1, ptl);\nout:\n\twalk->private += nr;\n\tcond_resched();\n\treturn 0;\n}", "target": 1}
{"code": "static int iax2_poke_peer(struct iax2_peer *peer, int heldcall)\n{\n\tif (!peer->maxms || (!peer->addr.sin_addr.s_addr && !peer->dnsmgr)) {\n\t\tpeer->lastms = 0;\n\t\tpeer->historicms = 0;\n\t\tpeer->pokeexpire = -1;\n\t\tpeer->callno = 0;\n\t\treturn 0;\n\t}\n\tif (peer->callno > 0) {\n\t\tast_log(LOG_NOTICE, \"Still have a callno...\\n\");\n\t\tast_mutex_lock(&iaxsl[peer->callno]);\n\t\tiax2_destroy(peer->callno);\n\t\tast_mutex_unlock(&iaxsl[peer->callno]);\n\t}\n\tif (heldcall)\n\t\tast_mutex_unlock(&iaxsl[heldcall]);\n\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd);\n\tif (heldcall)\n\t\tast_mutex_lock(&iaxsl[heldcall]);\n\tif (peer->callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to allocate call for poking peer '%s'\\n\", peer->name);\n\t\treturn -1;\n\t}\n\tiaxs[peer->callno]->pingtime = peer->maxms / 4 + 1;\n\tiaxs[peer->callno]->peerpoke = peer;\n \tif (peer->pokeexpire > -1) {\n \t\tif (!ast_sched_del(sched, peer->pokeexpire)) {\n \t\t\tpeer->pokeexpire = -1;\n \t\t\tpeer_unref(peer);\n \t\t}\n \t}\n\tif (peer->lastms < 0)\n \t\tpeer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_noanswer, peer_ref(peer));\n\telse\n \t\tpeer->pokeexpire = iax2_sched_add(sched, DEFAULT_MAXMS * 2, iax2_poke_noanswer, peer_ref(peer));\n \tif (peer->pokeexpire == -1)\n \t\tpeer_unref(peer);\n\tsend_command(iaxs[peer->callno], AST_FRAME_IAX, IAX_COMMAND_POKE, 0, NULL, 0, -1);\n\treturn 0;\n}", "target": 1}
{"code": "  static void Launch(OpKernelContext* context, const Tensor& in_x,\n                     const Tensor& in_y, bool adjoint, bool lower,\n                     const MatMulBCast& bcast, Tensor* out) {\n    const int64 batch_size = bcast.output_batch_size();\n    const int64 cost_per_unit =\n        in_x.dim_size(1) * in_x.dim_size(2) * in_y.dim_size(2);\n    auto worker_threads = *(context->device()->tensorflow_cpu_worker_threads());\n    using Matrix =\n        Eigen::Matrix<Scalar, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor>;\n    using ConstMatrixMap = Eigen::Map<const Matrix>;\n    using RealScalar = typename Eigen::NumTraits<Scalar>::Real;\n    auto matrix = ConstMatrixMap(in_x.flat<Scalar>().data(), in_x.dim_size(1),\n                                 in_x.dim_size(2));\n    RealScalar min_abs_pivot;\n    if (lower) {\n      min_abs_pivot = matrix.row(0).cwiseAbs().minCoeff();\n    } else {\n      min_abs_pivot = matrix.row(in_x.dim_size(1) - 1).cwiseAbs().minCoeff();\n    }\n    OP_REQUIRES(context, min_abs_pivot > RealScalar(0),\n                errors::InvalidArgument(\"Input matrix is not invertible.\"));\n    Shard(worker_threads.num_threads, worker_threads.workers, batch_size,\n          cost_per_unit,\n          [&in_x, &in_y, adjoint, lower, &bcast, out](int start, int limit) {\n            SequentialBandedTriangularSolveKernel<Scalar>::Run(\n                in_x, in_y, lower, adjoint, bcast, out, start, limit);\n          });\n  }", "target": 1}
{"code": "shutdown_mib(void)\n{\n    unload_all_mibs();\n    if (tree_top) {\n        if (tree_top->label)\n            SNMP_FREE(tree_top->label);\n        SNMP_FREE(tree_top);\n    }\n    tree_head = NULL;\n    Mib = NULL;\n    if (_mibindexes) {\n        int i;\n        for (i = 0; i < _mibindex; ++i)\n            SNMP_FREE(_mibindexes[i]);\n        free(_mibindexes);\n        _mibindex = 0;\n        _mibindex_max = 0;\n        _mibindexes = NULL;\n    }\n    if (Prefix != NULL && Prefix != &Standard_Prefix[0])\n        SNMP_FREE(Prefix);\n    if (Prefix)\n        Prefix = NULL;\n    SNMP_FREE(confmibs);\n    SNMP_FREE(confmibdir);\n}", "target": 1}
{"code": "mcs_send_connect_initial(STREAM mcs_data)\n{\n\tint datalen = mcs_data->end - mcs_data->data;\n\tint length = 9 + 3 * 34 + 4 + datalen;\n\tSTREAM s;\n\ts = iso_init(length + 5);\n\tber_out_header(s, MCS_CONNECT_INITIAL, length);\n\tber_out_header(s, BER_TAG_OCTET_STRING, 1);\t\n\tout_uint8(s, 1);\n\tber_out_header(s, BER_TAG_OCTET_STRING, 1);\t\n\tout_uint8(s, 1);\n\tber_out_header(s, BER_TAG_BOOLEAN, 1);\n\tout_uint8(s, 0xff);\t\n\tmcs_out_domain_params(s, 34, 2, 0, 0xffff);\t\n\tmcs_out_domain_params(s, 1, 1, 1, 0x420);\t\n\tmcs_out_domain_params(s, 0xffff, 0xfc17, 0xffff, 0xffff);\t\n\tber_out_header(s, BER_TAG_OCTET_STRING, datalen);\n\tout_uint8p(s, mcs_data->data, datalen);\n\ts_mark_end(s);\n\tiso_send(s);\n}", "target": 0}
{"code": "createenv(const struct rule *rule)\n{\n\tstruct env *env;\n\tu_int i;\n\tenv = malloc(sizeof(*env));\n\tif (!env)\n\t\terr(1, NULL);\n\tRB_INIT(&env->root);\n\tenv->count = 0;\n\tif (rule->options & KEEPENV) {\n\t\textern char **environ;\n\t\tfor (i = 0; environ[i] != NULL; i++) {\n\t\t\tstruct envnode *node;\n\t\t\tconst char *e, *eq;\n\t\t\tsize_t len;\n\t\t\tchar keybuf[1024];\n\t\t\te = environ[i];\n\t\t\tif ((eq = strchr(e, '=')) == NULL || eq == e)\n\t\t\t\tcontinue;\n\t\t\tlen = eq - e;\n\t\t\tif (len > sizeof(keybuf) - 1)\n\t\t\t\tcontinue;\n\t\t\tmemcpy(keybuf, e, len);\n\t\t\tkeybuf[len] = '\\0';\n\t\t\tnode = createnode(keybuf, eq + 1);\n\t\t\tif (RB_INSERT(envtree, &env->root, node)) {\n\t\t\t\tfreenode(node);\n\t\t\t} else {\n\t\t\t\tenv->count++;\n\t\t\t}\n\t\t}\n\t}\n\treturn env;\n}", "target": 1}
{"code": "static void mem_cgroup_usage_unregister_event(struct cgroup *cgrp,\n\tstruct cftype *cft, struct eventfd_ctx *eventfd)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_cont(cgrp);\n\tstruct mem_cgroup_thresholds *thresholds;\n\tstruct mem_cgroup_threshold_ary *new;\n\tint type = MEMFILE_TYPE(cft->private);\n\tu64 usage;\n\tint i, j, size;\n\tmutex_lock(&memcg->thresholds_lock);\n\tif (type == _MEM)\n\t\tthresholds = &memcg->thresholds;\n\telse if (type == _MEMSWAP)\n\t\tthresholds = &memcg->memsw_thresholds;\n\telse\n\t\tBUG();\n\tBUG_ON(!thresholds);\n\tusage = mem_cgroup_usage(memcg, type == _MEMSWAP);\n\t__mem_cgroup_threshold(memcg, type == _MEMSWAP);\n\tsize = 0;\n\tfor (i = 0; i < thresholds->primary->size; i++) {\n\t\tif (thresholds->primary->entries[i].eventfd != eventfd)\n\t\t\tsize++;\n\t}\n\tnew = thresholds->spare;\n\tif (!size) {\n\t\tkfree(new);\n\t\tnew = NULL;\n\t\tgoto swap_buffers;\n\t}\n\tnew->size = size;\n\tnew->current_threshold = -1;\n\tfor (i = 0, j = 0; i < thresholds->primary->size; i++) {\n\t\tif (thresholds->primary->entries[i].eventfd == eventfd)\n\t\t\tcontinue;\n\t\tnew->entries[j] = thresholds->primary->entries[i];\n\t\tif (new->entries[j].threshold < usage) {\n\t\t\t++new->current_threshold;\n\t\t}\n\t\tj++;\n\t}\nswap_buffers:\n\tthresholds->spare = thresholds->primary;\n\trcu_assign_pointer(thresholds->primary, new);\n\tsynchronize_rcu();\n\tmutex_unlock(&memcg->thresholds_lock);\n}", "target": 1}
{"code": "static void __net_exit sctp_net_exit(struct net *net)\n{\n\tsctp_free_addr_wq(net);\n\tsctp_free_local_addr_list(net);\n\tinet_ctl_sock_destroy(net->sctp.ctl_sock);\n\tsctp_dbg_objcnt_exit(net);\n\tsctp_proc_exit(net);\n\tcleanup_sctp_mibs(net);\n\tsctp_sysctl_net_unregister(net);\n}", "target": 1}
{"code": "netsnmp_mibindex_lookup( const char *dirname )\n{\n    int i;\n    static char tmpbuf[300];\n    for (i=0; i<_mibindex; i++) {\n        if ( _mibindexes[i] &&\n             strcmp( _mibindexes[i], dirname ) == 0) {\n             snprintf(tmpbuf, sizeof(tmpbuf), \"%s/mib_indexes/%d\",\n                      get_persistent_directory(), i);\n             tmpbuf[sizeof(tmpbuf)-1] = 0;\n             DEBUGMSGTL((\"mibindex\", \"lookup: %s (%d) %s\\n\", dirname, i, tmpbuf ));\n             return tmpbuf;\n        }\n    }\n    DEBUGMSGTL((\"mibindex\", \"lookup: (none)\\n\"));\n    return NULL;\n}", "target": 1}
{"code": "static inline u32 nla_get_u32(struct nlattr *nla)\n{\n\treturn *(u32 *) nla_data(nla);\n}", "target": 0}
{"code": "gplotMakeOutput(GPLOT  *gplot)\n{\nchar     buf[L_BUF_SIZE];\nchar    *cmdname;\nl_int32  ignore;\n    PROCNAME(\"gplotMakeOutput\");\n    if (!gplot)\n        return ERROR_INT(\"gplot not defined\", procName, 1);\n    gplotGenCommandFile(gplot);\n    gplotGenDataFiles(gplot);\n    cmdname = genPathname(gplot->cmdname, NULL);\n#ifndef _WIN32\n    snprintf(buf, L_BUF_SIZE, \"gnuplot %s\", cmdname);\n#else\n    snprintf(buf, L_BUF_SIZE, \"wgnuplot %s\", cmdname);\n#endif  \n#ifndef OS_IOS \n    ignore = system(buf);  \n#endif \n    LEPT_FREE(cmdname);\n    return 0;\n}", "target": 1}
{"code": "TfLiteStatus ResizeOutputTensors(TfLiteContext* context, TfLiteNode* node,\n                                 const TfLiteTensor* axis,\n                                 const TfLiteTensor* input, int num_splits) {\n  int axis_value = GetTensorData<int>(axis)[0];\n  if (axis_value < 0) {\n    axis_value += NumDimensions(input);\n  }\n  TF_LITE_ENSURE(context, axis_value >= 0);\n  TF_LITE_ENSURE(context, axis_value < NumDimensions(input));\n  const int input_size = SizeOfDimension(input, axis_value);\n  TF_LITE_ENSURE(context, num_splits != 0);\n  TF_LITE_ENSURE_MSG(context, input_size % num_splits == 0,\n                     \"Not an even split\");\n  const int slice_size = input_size / num_splits;\n  for (int i = 0; i < NumOutputs(node); ++i) {\n    TfLiteIntArray* output_dims = TfLiteIntArrayCopy(input->dims);\n    output_dims->data[axis_value] = slice_size;\n    TfLiteTensor* output;\n    TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, i, &output));\n    TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, output, output_dims));\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "midi_synth_load_patch(int dev, int format, const char __user *addr,\n\t\t      int offs, int count, int pmgr_flag)\n{\n\tint             orig_dev = synth_devs[dev]->midi_dev;\n\tstruct sysex_info sysex;\n\tint             i;\n\tunsigned long   left, src_offs, eox_seen = 0;\n\tint             first_byte = 1;\n\tint             hdr_size = (unsigned long) &sysex.data[0] - (unsigned long) &sysex;\n\tleave_sysex(dev);\n\tif (!prefix_cmd(orig_dev, 0xf0))\n\t\treturn 0;\n\tif (format != SYSEX_PATCH)\n\t{\n\t\t  return -EINVAL;\n\t}\n\tif (count < hdr_size)\n\t{\n\t\treturn -EINVAL;\n\t}\n\tcount -= hdr_size;\n\tif(copy_from_user(&((char *) &sysex)[offs], &(addr)[offs], hdr_size - offs))\n\t\treturn -EFAULT;\n \tif (count < sysex.len)\n\t{\n\t\tsysex.len = count;\n\t}\n  \tleft = sysex.len;\n  \tsrc_offs = 0;\n\tfor (i = 0; i < left && !signal_pending(current); i++)\n\t{\n\t\tunsigned char   data;\n\t\tif (get_user(data,\n\t\t    (unsigned char __user *)(addr + hdr_size + i)))\n\t\t\treturn -EFAULT;\n\t\teox_seen = (i > 0 && data & 0x80);\t\n\t\tif (eox_seen && data != 0xf7)\n\t\t\tdata = 0xf7;\n\t\tif (i == 0)\n\t\t{\n\t\t\tif (data != 0xf0)\n\t\t\t{\n\t\t\t\tprintk(KERN_WARNING \"midi_synth: Sysex start missing\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\twhile (!midi_devs[orig_dev]->outputc(orig_dev, (unsigned char) (data & 0xff)) &&\n\t\t\t!signal_pending(current))\n\t\t\tschedule();\n\t\tif (!first_byte && data & 0x80)\n\t\t\treturn 0;\n\t\tfirst_byte = 0;\n\t}\n\tif (!eox_seen)\n\t\tmidi_outc(orig_dev, 0xf7);\n\treturn 0;\n}", "target": 1}
{"code": "static int intf_start_seq_timer(struct ipmi_smi *intf,\n\t\t\t\tlong       msgid)\n{\n\tint           rv = -ENODEV;\n\tunsigned long flags;\n\tunsigned char seq;\n\tunsigned long seqid;\n\tGET_SEQ_FROM_MSGID(msgid, seq, seqid);\n\tspin_lock_irqsave(&intf->seq_lock, flags);\n\tif ((intf->seq_table[seq].inuse)\n\t\t\t\t&& (intf->seq_table[seq].seqid == seqid)) {\n\t\tstruct seq_table *ent = &intf->seq_table[seq];\n\t\tent->timeout = ent->orig_timeout;\n\t\trv = 0;\n\t}\n\tspin_unlock_irqrestore(&intf->seq_lock, flags);\n\treturn rv;\n}", "target": 0}
{"code": "int page_name_is_good(char* page_name)\n{\n    if (!page_name)\n        return FALSE;\n    if (!isalnum(page[0]))\n        return FALSE;\n    if (strstr(page, \"..\"))\n        return FALSE;\n    return TRUE;\n}", "target": 0}
{"code": "static bool blk_kick_flush(struct request_queue *q, struct blk_flush_queue *fq)\n{\n\tstruct list_head *pending = &fq->flush_queue[fq->flush_pending_idx];\n\tstruct request *first_rq =\n\t\tlist_first_entry(pending, struct request, flush.list);\n\tstruct request *flush_rq = fq->flush_rq;\n\tif (fq->flush_pending_idx != fq->flush_running_idx || list_empty(pending))\n\t\treturn false;\n\tif (!list_empty(&fq->flush_data_in_flight) &&\n\t    time_before(jiffies,\n\t\t\tfq->flush_pending_since + FLUSH_PENDING_TIMEOUT))\n\t\treturn false;\n\tfq->flush_pending_idx ^= 1;\n\tblk_rq_init(q, flush_rq);\n\tif (q->mq_ops) {\n\t\tflush_rq->mq_ctx = first_rq->mq_ctx;\n\t\tflush_rq->tag = first_rq->tag;\n\t}\n\tflush_rq->cmd_type = REQ_TYPE_FS;\n\tflush_rq->cmd_flags = WRITE_FLUSH | REQ_FLUSH_SEQ;\n\tflush_rq->rq_disk = first_rq->rq_disk;\n\tflush_rq->end_io = flush_end_io;\n\treturn blk_flush_queue_rq(flush_rq, false);\n}", "target": 1}
{"code": "err_t verify_signed_hash(const struct RSA_public_key *k\n                         , u_char *s, unsigned int s_max_octets\n                         , u_char **psig\n                         , size_t hash_len\n                         , const u_char *sig_val, size_t sig_len)\n{\n    unsigned int padlen;\n    {\n\tchunk_t temp_s;\n\tMP_INT c;\n\tn_to_mpz(&c, sig_val, sig_len);\n\toswcrypto.mod_exp(&c, &c, &k->e, &k->n);\n\ttemp_s = mpz_to_n(&c, sig_len);\t\n        if(s_max_octets < sig_len) {\n            return \"2\"\"exponentiation failed; too many octets\";\n        }\n\tmemcpy(s, temp_s.ptr, sig_len);\n\tpfree(temp_s.ptr);\n\tmpz_clear(&c);\n    }\n    padlen = sig_len - 3 - hash_len;\n    DBG(DBG_CRYPT,\n\tDBG_dump(\"verify_sh decrypted SIG1:\", s, sig_len));\n    DBG(DBG_CRYPT, DBG_log(\"pad_len calculated: %d hash_len: %d\", padlen, (int)hash_len));\n    if(s[0]    != 0x00\n       || s[1] != 0x01\n       || s[padlen+2] != 0x00) {\n\treturn \"3\"\"SIG padding does not check out\";\n    }\n    s += padlen + 3;\n    (*psig) = s;\n    return NULL;\n}", "target": 1}
{"code": "PassRefPtr<WebProcessProxy> WebProcessProxy::create(PassRefPtr<WebContext> context)\n{\n    return adoptRef(new WebProcessProxy(context));\n}", "target": 0}
{"code": "messageFindArgument(const message *m, const char *variable)\n{\n\tint i;\n\tsize_t len;\n\tassert(m != NULL);\n\tassert(variable != NULL);\n\tlen = strlen(variable);\n\tfor(i = 0; i < m->numberOfArguments; i++) {\n\t\tconst char *ptr;\n\t\tptr = messageGetArgument(m, i);\n\t\tif((ptr == NULL) || (*ptr == '\\0'))\n\t\t\tcontinue;\n#ifdef\tCL_DEBUG\n\t\tcli_dbgmsg(\"messageFindArgument: compare %lu bytes of %s with %s\\n\",\n\t\t\t(unsigned long)len, variable, ptr);\n#endif\n\t\tif(strncasecmp(ptr, variable, len) == 0) {\n\t\t\tptr = &ptr[len];\n\t\t\twhile(isspace(*ptr))\n\t\t\t\tptr++;\n\t\t\tif(*ptr != '=') {\n\t\t\t\tcli_dbgmsg(\"messageFindArgument: no '=' sign found in MIME header '%s' (%s)\\n\", variable, messageGetArgument(m, i));\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif((*++ptr == '\"') && (strchr(&ptr[1], '\"') != NULL)) {\n\t\t\t\tchar *ret = cli_strdup(++ptr);\n\t\t\t\tchar *p;\n\t\t\t\tif(ret == NULL)\n\t\t\t\t\treturn NULL;\n\t\t\t\tif((p = strchr(ret, '\"')) != NULL) {\n\t\t\t\t\tret[strlen(ret) - 1] = '\\0';\n\t\t\t\t\t*p = '\\0';\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\treturn cli_strdup(ptr);\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "rpl_print(netdissect_options *ndo,\n          const struct icmp6_hdr *hdr,\n          const u_char *bp, u_int length)\n{\n        int secured = hdr->icmp6_code & 0x80;\n        int basecode= hdr->icmp6_code & 0x7f;\n        if(secured) {\n                ND_PRINT((ndo, \", (SEC) [worktodo]\"));\n                return;\n        } else {\n                ND_PRINT((ndo, \", (CLR)\"));\n        }\n        switch(basecode) {\n        case ND_RPL_DAG_IS:\n                ND_PRINT((ndo, \"DODAG Information Solicitation\"));\n                if(ndo->ndo_vflag) {\n                }\n                break;\n        case ND_RPL_DAG_IO:\n                ND_PRINT((ndo, \"DODAG Information Object\"));\n                if(ndo->ndo_vflag) {\n                        rpl_dio_print(ndo, bp, length);\n                }\n                break;\n        case ND_RPL_DAO:\n                ND_PRINT((ndo, \"Destination Advertisement Object\"));\n                if(ndo->ndo_vflag) {\n                        rpl_dao_print(ndo, bp, length);\n                }\n                break;\n        case ND_RPL_DAO_ACK:\n                ND_PRINT((ndo, \"Destination Advertisement Object Ack\"));\n                if(ndo->ndo_vflag) {\n                        rpl_daoack_print(ndo, bp, length);\n                }\n                break;\n        default:\n                ND_PRINT((ndo, \"RPL message, unknown code %u\",hdr->icmp6_code));\n                break;\n        }\n\treturn;\n#if 0\ntrunc:\n\tND_PRINT((ndo,\" [|truncated]\"));\n\treturn;\n#endif\n}", "target": 1}
{"code": "void sendClean( char* str ) {\n    CleanupOutput(str);\n    send(str);\n}", "target": 0}
{"code": "int nft_expr_inner_parse(const struct nft_ctx *ctx, const struct nlattr *nla,\n\t\t\t struct nft_expr_info *info)\n{\n\tstruct nlattr *tb[NFTA_EXPR_MAX + 1];\n\tconst struct nft_expr_type *type;\n\tint err;\n\terr = nla_parse_nested_deprecated(tb, NFTA_EXPR_MAX, nla,\n\t\t\t\t\t  nft_expr_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\tif (!tb[NFTA_EXPR_DATA])\n\t\treturn -EINVAL;\n\ttype = __nft_expr_type_get(ctx->family, tb[NFTA_EXPR_NAME]);\n\tif (!type)\n\t\treturn -ENOENT;\n\tif (!type->inner_ops)\n\t\treturn -EOPNOTSUPP;\n\terr = nla_parse_nested_deprecated(info->tb, type->maxattr,\n\t\t\t\t\t  tb[NFTA_EXPR_DATA],\n\t\t\t\t\t  type->policy, NULL);\n\tif (err < 0)\n\t\tgoto err_nla_parse;\n\tinfo->attr = nla;\n\tinfo->ops = type->inner_ops;\n\treturn 0;\nerr_nla_parse:\n\treturn err;\n}", "target": 1}
{"code": "static int ext4_write_end(struct file *file,\n\t\t\t  struct address_space *mapping,\n\t\t\t  loff_t pos, unsigned len, unsigned copied,\n\t\t\t  struct page *page, void *fsdata)\n{\n\thandle_t *handle = ext4_journal_current_handle();\n\tstruct inode *inode = mapping->host;\n\tloff_t old_size = inode->i_size;\n\tint ret = 0, ret2;\n\tint i_size_changed = 0;\n\ttrace_ext4_write_end(inode, pos, len, copied);\n\tif (ext4_test_inode_state(inode, EXT4_STATE_ORDERED_MODE)) {\n\t\tret = ext4_jbd2_file_inode(handle, inode);\n\t\tif (ret) {\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tgoto errout;\n\t\t}\n\t}\n\tif (ext4_has_inline_data(inode)) {\n\t\tret = ext4_write_inline_data_end(inode, pos, len,\n\t\t\t\t\t\t copied, page);\n\t\tif (ret < 0)\n\t\t\tgoto errout;\n\t\tcopied = ret;\n\t} else\n\t\tcopied = block_write_end(file, mapping, pos,\n\t\t\t\t\t len, copied, page, fsdata);\n\ti_size_changed = ext4_update_inode_size(inode, pos + copied);\n\tunlock_page(page);\n\tput_page(page);\n\tif (old_size < pos)\n\t\tpagecache_isize_extended(inode, old_size, pos);\n\tif (i_size_changed)\n\t\text4_mark_inode_dirty(handle, inode);\n\tif (pos + len > inode->i_size && ext4_can_truncate(inode))\n\t\text4_orphan_add(handle, inode);\nerrout:\n\tret2 = ext4_journal_stop(handle);\n\tif (!ret)\n\t\tret = ret2;\n\tif (pos + len > inode->i_size) {\n\t\text4_truncate_failed_write(inode);\n\t\tif (inode->i_nlink)\n\t\t\text4_orphan_del(NULL, inode);\n\t}\n\treturn ret ? ret : copied;\n}", "target": 1}
{"code": "    size_t Exifdatum::size() const\n    {\n        return value_.get() == 0 ? 0 : value_->size();\n    }", "target": 0}
{"code": "bool SVGAnimateElement::calculateFromAndToValues(const String& fromString, const String& toString)\n{\n    SVGElement* targetElement = this->targetElement();\n    if (!targetElement)\n        return false;\n    determinePropertyValueTypes(fromString, toString);\n    ensureAnimator()->calculateFromAndToValues(m_fromType, m_toType, fromString, toString);\n    ASSERT(m_animatedPropertyType == m_animator->type());\n    return true;\n}", "target": 0}
{"code": "int bad_format_print(char *fmt){\n    return bad_format_check(\"^\" SAFE_STRING FLOAT_STRING SAFE_STRING \"%s\" SAFE_STRING \"$\",fmt);\n}", "target": 0}
{"code": "Item *Item_field::update_value_transformer(uchar *select_arg)\n{\n  SELECT_LEX *select= (SELECT_LEX*)select_arg;\n  DBUG_ASSERT(fixed);\n  if (field->table != select->context.table_list->table &&\n      type() != Item::TRIGGER_FIELD_ITEM)\n  {\n    List<Item> *all_fields= &select->join->all_fields;\n    Item **ref_pointer_array= select->ref_pointer_array;\n    DBUG_ASSERT(all_fields->elements <= select->ref_pointer_array_size);\n    int el= all_fields->elements;\n    Item_ref *ref;\n    ref_pointer_array[el]= (Item*)this;\n    all_fields->push_front((Item*)this);\n    ref= new Item_ref(&select->context, ref_pointer_array + el,\n                      table_name, field_name);\n    return ref;\n  }\n  return this;\n}", "target": 0}
{"code": "static inline struct page *try_get_compound_head(struct page *page, int refs)\n{\n\tstruct page *head = compound_head(page);\n\tif (WARN_ON_ONCE(page_ref_count(head) < 0))\n\t\treturn NULL;\n\tif (unlikely(!page_cache_add_speculative(head, refs)))\n\t\treturn NULL;\n\treturn head;\n}", "target": 0}
{"code": "static cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)\n{\n    cJSON *current_element = NULL;\n    if ((object == NULL) || (name == NULL))\n    {\n        return NULL;\n    }\n    current_element = object->child;\n    if (case_sensitive)\n    {\n        while ((current_element != NULL) && (strcmp(name, current_element->string) != 0))\n        {\n            current_element = current_element->next;\n        }\n    }\n    else\n    {\n        while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))\n        {\n            current_element = current_element->next;\n        }\n    }\n    return current_element;\n}", "target": 1}
{"code": "_SSL_check_common_name (X509 *cert, const char *host)\n{\n\tX509_NAME *name;\n\tchar *common_name = NULL;\n\tint common_name_len;\n\tint rv = -1;\n\tGInetAddress *addr;\n\tname = X509_get_subject_name (cert);\n\tif (name == NULL)\n\t\treturn -1;\n\tcommon_name_len = X509_NAME_get_text_by_NID (name, NID_commonName, NULL, 0);\n\tif (common_name_len < 0)\n\t\treturn -1;\n\tcommon_name = calloc (common_name_len + 1, 1);\n\tif (common_name == NULL)\n\t\treturn -1;\n\tX509_NAME_get_text_by_NID (name, NID_commonName, common_name, common_name_len + 1);\n\tif (common_name_len != (int)strlen(common_name))\n\t{\n\t\tg_warning (\"NUL byte in Common Name field, probably a malicious certificate.\\n\");\n\t\trv = -2;\n\t\tgoto out;\n\t}\n\tif ((addr = g_inet_address_new_from_string (host)) != NULL)\n\t{\n\t\tif (g_strcmp0 (common_name, host) == 0)\n\t\t\trv = 0;\n\t\telse\n\t\t\trv = -1;\n\t\tg_object_unref (addr);\n\t}\n\telse if (_SSL_match_hostname (common_name, host) == 0)\n\t\trv = 0;\nout:\n\tfree(common_name);\n\treturn rv;\n}", "target": 0}
{"code": "static void adpt_release(adpt_hba *pHba)\n{\n\tstruct Scsi_Host *shost = pHba->host;\n\tscsi_remove_host(shost);\n\tadpt_i2o_delete_hba(pHba);\n\tscsi_host_put(shost);\n}", "target": 1}
{"code": "void Huff_Compress(msg_t *mbuf, int offset) {\n\tint\t\t\ti, ch, size;\n\tbyte\t\tseq[65536];\n\tbyte*\t\tbuffer;\n\thuff_t\t\thuff;\n\tsize = mbuf->cursize - offset;\n\tbuffer = mbuf->data+ + offset;\n\tif (size<=0) {\n\t\treturn;\n\t}\n\tCom_Memset(&huff, 0, sizeof(huff_t));\n\thuff.tree = huff.lhead = huff.loc[NYT] =  &(huff.nodeList[huff.blocNode++]);\n\thuff.tree->symbol = NYT;\n\thuff.tree->weight = 0;\n\thuff.lhead->next = huff.lhead->prev = NULL;\n\thuff.tree->parent = huff.tree->left = huff.tree->right = NULL;\n\tseq[0] = (size>>8);\n\tseq[1] = size&0xff;\n\tbloc = 16;\n\tfor (i=0; i<size; i++ ) {\n\t\tch = buffer[i];\n\t\tHuff_transmit(&huff, ch, seq);\t\t\t\t\t\t\n\t\tHuff_addRef(&huff, (byte)ch);\t\t\t\t\t\t\t\t\n\t}\n\tbloc += 8;\t\t\t\t\t\t\t\t\t\t\t\t\n\tmbuf->cursize = (bloc>>3) + offset;\n\tCom_Memcpy(mbuf->data+offset, seq, (bloc>>3));\n}", "target": 1}
{"code": "get_one_option(int optid, const struct my_option *opt,\n               char *argument)\n{\n  my_bool add_option= TRUE;\n  switch (optid) {\n  case '?':\n    printf(\"%s  Ver %s Distrib %s, for %s (%s)\\n\",\n           my_progname, VER, MYSQL_SERVER_VERSION, SYSTEM_TYPE, MACHINE_TYPE);\n    puts(ORACLE_WELCOME_COPYRIGHT_NOTICE(\"2000\"));\n    puts(\"MySQL utility for upgrading databases to new MySQL versions.\\n\");\n    my_print_help(my_long_options);\n    exit(0);\n    break;\n  case '#':\n    DBUG_PUSH(argument ? argument : default_dbug_option);\n    add_option= FALSE;\n    debug_check_flag= 1;\n    break;\n  case 'p':\n    if (argument == disabled_my_option)\n      argument= (char*) \"\";\t\t\t\n    tty_password= 1;\n    add_option= FALSE;\n    if (argument)\n    {\n      add_one_option(&ds_args, opt, argument);\n      while (*argument)\n        *argument++= 'x';                       \n      tty_password= 0;\n    }\n    break;\n  case 't':\n    my_stpnmov(opt_tmpdir, argument, sizeof(opt_tmpdir));\n    add_option= FALSE;\n    break;\n  case 'k':                                     \n  case 'v': \n  case 'f': \n  case 's':                                     \n  case OPT_WRITE_BINLOG:                        \n    add_option= FALSE;\n    break;\n  case 'h': \n  case 'W': \n  case 'P': \n  case 'S': \n  case OPT_MYSQL_PROTOCOL: \n  case OPT_SHARED_MEMORY_BASE_NAME: \n  case OPT_PLUGIN_DIR:                          \n  case OPT_DEFAULT_AUTH:                        \n    add_one_option(&conn_args, opt, argument);\n    break;\n  }\n  if (add_option)\n  {\n    add_one_option(&ds_args, opt, argument);\n  }\n  return 0;\n}", "target": 1}
{"code": "PHP_MINFO_FUNCTION(mcrypt) \n{\n\tchar **modules;\n\tchar mcrypt_api_no[16];\n\tint i, count;\n\tsmart_str tmp1 = {0};\n\tsmart_str tmp2 = {0};\n\tmodules = mcrypt_list_algorithms(MCG(algorithms_dir), &count);\n\tif (count == 0) {\n\t\tsmart_str_appends(&tmp1, \"none\");\n\t}\n\tfor (i = 0; i < count; i++) {\n\t\tsmart_str_appends(&tmp1, modules[i]);\n\t\tsmart_str_appendc(&tmp1, ' ');\n\t}\n\tsmart_str_0(&tmp1);\n\tmcrypt_free_p(modules, count);\n\tmodules = mcrypt_list_modes(MCG(modes_dir), &count);\n\tif (count == 0) {\n\t\tsmart_str_appends(&tmp2, \"none\");\n\t}\n\tfor (i = 0; i < count; i++) {\n\t\tsmart_str_appends(&tmp2, modules[i]);\n\t\tsmart_str_appendc(&tmp2, ' ');\n\t}\n\tsmart_str_0 (&tmp2);\n\tmcrypt_free_p (modules, count);\n\tsnprintf (mcrypt_api_no, 16, \"%d\", MCRYPT_API_VERSION);\n\tphp_info_print_table_start();\n\tphp_info_print_table_header(2, \"mcrypt support\", \"enabled\");\n\tphp_info_print_table_header(2, \"mcrypt_filter support\", \"enabled\");\n\tphp_info_print_table_row(2, \"Version\", LIBMCRYPT_VERSION);\n\tphp_info_print_table_row(2, \"Api No\", mcrypt_api_no);\n\tphp_info_print_table_row(2, \"Supported ciphers\", tmp1.c);\n\tphp_info_print_table_row(2, \"Supported modes\", tmp2.c);\n\tsmart_str_free(&tmp1);\n\tsmart_str_free(&tmp2);\n\tphp_info_print_table_end();\n\tDISPLAY_INI_ENTRIES();", "target": 1}
{"code": "find_entry_internal_uniqueid(\n\tSlapi_PBlock\t*pb,\n    backend *be,\n\tconst char \t\t\t*uniqueid,\n    int\t\t\t\tlock,\n\tback_txn\t\t*txn\n)\n{\n\tldbm_instance *inst = (ldbm_instance *) be->be_instance_info;\n\tstruct backentry\t*e;\n\tint\t\t\terr;\n\tsize_t tries = 0;\n\twhile ( (tries < LDBM_CACHE_RETRY_COUNT) && \n\t\t\t(e = uniqueid2entry(be, uniqueid, txn, &err ))\n\t    != NULL ) {\n\t\tif ( !lock || cache_lock_entry( &inst->inst_cache, e ) == 0 ) {\n\t\t\tLDAPDebug( LDAP_DEBUG_TRACE,\n\t\t\t    \"<= find_entry_internal_uniqueid found; uniqueid = (%s)\\n\", \n\t\t\tuniqueid, 0, 0 );\n\t\t\treturn( e );\n\t\t}\n\t\tLDAPDebug( LDAP_DEBUG_ARGS,\n\t\t\t\"   find_entry_internal_uniqueid retrying; uniqueid = (%s)\\n\", \n\t\t\tuniqueid, 0, 0 );\n\t\tCACHE_RETURN( &inst->inst_cache, &e );\n\t\ttries++;\n\t}\n\tif (tries >= LDBM_CACHE_RETRY_COUNT) {\n\t\tLDAPDebug( LDAP_DEBUG_ANY,\n\t\t\t\"find_entry_internal_uniqueid retry count exceeded; uniqueid = (%s)\\n\", \n\t\t\tuniqueid , 0, 0 );\n\t}\n\tslapi_send_ldap_result( pb, ( 0 == err || DB_NOTFOUND == err ) ?\n\t\tLDAP_NO_SUCH_OBJECT : LDAP_OPERATIONS_ERROR, NULL , NULL,\n\t\t0, NULL );\n\tLDAPDebug( LDAP_DEBUG_TRACE, \n\t\t\"<= find_entry_internal_uniqueid not found; uniqueid = (%s)\\n\",\n\t    uniqueid, 0, 0 );\n\treturn( NULL );\n}", "target": 1}
{"code": "void test_open(const char *path)\n{\n\tint fd = open(path, O_RDONLY);\n\tif (fd >= 0) {\n\t\tfprintf(stderr, \"leak at open of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT) {\n\t\tfprintf(stderr, \"leak at open of %s: errno was %d\\n\", path, errno);\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "BGD_DECLARE(void) gdImageFillToBorder (gdImagePtr im, int x, int y, int border, int color)\n{\n\tint lastBorder;\n\tint leftLimit, rightLimit;\n\tint i;\n\tint restoreAlphaBleding;\n\tif (border < 0) {\n\t\treturn;\n\t}\n\tleftLimit = (-1);\n\trestoreAlphaBleding = im->alphaBlendingFlag;\n\tim->alphaBlendingFlag = 0;\n\tif (x >= im->sx) {\n\t\tx = im->sx - 1;\n\t} else if (x < 0) {\n\t\tx = 0;\n\t}\n\tif (y >= im->sy) {\n\t\ty = im->sy - 1;\n\t} else if (y < 0) {\n\t\ty = 0;\n\t}\n\tfor (i = x; (i >= 0); i--) {\n\t\tif (gdImageGetPixel (im, i, y) == border) {\n\t\t\tbreak;\n\t\t}\n\t\tgdImageSetPixel (im, i, y, color);\n\t\tleftLimit = i;\n\t}\n\tif (leftLimit == (-1)) {\n\t\tim->alphaBlendingFlag = restoreAlphaBleding;\n\t\treturn;\n\t}\n\trightLimit = x;\n\tfor (i = (x + 1); (i < im->sx); i++) {\n\t\tif (gdImageGetPixel (im, i, y) == border) {\n\t\t\tbreak;\n\t\t}\n\t\tgdImageSetPixel (im, i, y, color);\n\t\trightLimit = i;\n\t}\n\tif (y > 0) {\n\t\tlastBorder = 1;\n\t\tfor (i = leftLimit; (i <= rightLimit); i++) {\n\t\t\tint c;\n\t\t\tc = gdImageGetPixel (im, i, y - 1);\n\t\t\tif (lastBorder) {\n\t\t\t\tif ((c != border) && (c != color)) {\n\t\t\t\t\tgdImageFillToBorder (im, i, y - 1, border, color);\n\t\t\t\t\tlastBorder = 0;\n\t\t\t\t}\n\t\t\t} else if ((c == border) || (c == color)) {\n\t\t\t\tlastBorder = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (y < ((im->sy) - 1)) {\n\t\tlastBorder = 1;\n\t\tfor (i = leftLimit; (i <= rightLimit); i++) {\n\t\t\tint c = gdImageGetPixel (im, i, y + 1);\n\t\t\tif (lastBorder) {\n\t\t\t\tif ((c != border) && (c != color)) {\n\t\t\t\t\tgdImageFillToBorder (im, i, y + 1, border, color);\n\t\t\t\t\tlastBorder = 0;\n\t\t\t\t}\n\t\t\t} else if ((c == border) || (c == color)) {\n\t\t\t\tlastBorder = 1;\n\t\t\t}\n\t\t}\n\t}\n\tim->alphaBlendingFlag = restoreAlphaBleding;\n}", "target": 1}
{"code": "set_range(bitstr_t *bits, int low, int high, int start, int stop, int step) {\n\tDebug(DPARS|DEXT, (\"set_range(?,%d,%d,%d,%d,%d)\\n\",\n\t\t\t   low, high, start, stop, step))\n\tif (start < low || stop > high)\n\t\treturn (EOF);\n\tstart -= low;\n\tstop -= low;\n\tif (step == 1) {\n\t\tbit_nset(bits, start, stop);\n\t} else {\n\t\tfor (int i = start; i <= stop; i += step)\n\t\t\tbit_set(bits, i);\n\t}\n\treturn (OK);\n}", "target": 1}
{"code": "struct resource_pool *dce120_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\tif (!pool)\n\t\treturn NULL;\n\tif (construct(num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\tkfree(pool);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 0}
{"code": "device_linux_md_stop_authorized_cb (Daemon *daemon,\n                                    Device *device,\n                                    DBusGMethodInvocation *context,\n                                    const gchar *action_id,\n                                    guint num_user_data,\n                                    gpointer *user_data_elements)\n{\n  int n;\n  char *argv[10];\n  GError *error;\n  n = 0;\n  argv[n++] = \"mdadm\";\n  argv[n++] = \"--stop\";\n  argv[n++] = device->priv->device_file;\n  argv[n++] = NULL;\n  error = NULL;\n  if (!job_new (context, \"LinuxMdStop\", TRUE, device, argv, NULL, linux_md_stop_completed_cb, FALSE, NULL, NULL))\n    {\n      goto out;\n    }\n out:\n  ;\n}", "target": 0}
{"code": "bool extract_sockaddr(char *url, char **sockaddr_url, char **sockaddr_port)\n{\n\tchar *url_begin, *url_end, *ipv6_begin, *ipv6_end, *port_start = NULL;\n\tchar url_address[256], port[6];\n\tint url_len, port_len = 0;\n\t*sockaddr_url = url;\n\turl_begin = strstr(url, \"\n\tif (!url_begin)\n\t\turl_begin = url;\n\telse\n\t\turl_begin += 2;\n\tipv6_begin = strstr(url_begin, \"[\");\n\tipv6_end = strstr(url_begin, \"]\");\n\tif (ipv6_begin && ipv6_end && ipv6_end > ipv6_begin)\n\t\turl_end = strstr(ipv6_end, \":\");\n\telse\n\t\turl_end = strstr(url_begin, \":\");\n\tif (url_end) {\n\t\turl_len = url_end - url_begin;\n\t\tport_len = strlen(url_begin) - url_len - 1;\n\t\tif (port_len < 1)\n\t\t\treturn false;\n\t\tport_start = url_end + 1;\n\t} else\n\t\turl_len = strlen(url_begin);\n\tif (url_len < 1)\n\t\treturn false;\n\tsprintf(url_address, \"%.*s\", url_len, url_begin);\n\tif (port_len) {\n\t\tchar *slash;\n\t\tsnprintf(port, 6, \"%.*s\", port_len, port_start);\n\t\tslash = strchr(port, '/');\n\t\tif (slash)\n\t\t\t*slash = '\\0';\n\t} else\n\t\tstrcpy(port, \"80\");\n\t*sockaddr_port = strdup(port);\n\t*sockaddr_url = strdup(url_address);\n\treturn true;\n}", "target": 1}
{"code": "mptctl_readtest (unsigned long arg)\n{\n\tstruct mpt_ioctl_test __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_test\t karg;\n\tMPT_ADAPTER *ioc;\n\tint iocnum;\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_test))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_readtest - \"\n\t\t\t\"Unable to read in mpt_ioctl_test struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_readtest() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_readtest called.\\n\",\n\t    ioc->name));\n#ifdef MFCNT\n\tkarg.chip_type = ioc->mfcnt;\n#else\n\tkarg.chip_type = ioc->pcidev->device;\n#endif\n\tstrncpy (karg.name, ioc->name, MPT_MAX_NAME);\n\tkarg.name[MPT_MAX_NAME-1]='\\0';\n\tstrncpy (karg.product, ioc->prod_name, MPT_PRODUCT_LENGTH);\n\tkarg.product[MPT_PRODUCT_LENGTH-1]='\\0';\n\tif (copy_to_user((char __user *)arg, &karg, sizeof(struct mpt_ioctl_test))) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_readtest - \"\n\t\t\t\"Unable to write out mpt_ioctl_test struct @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void context__cleanup(struct mosquitto *context, bool force_free)\n{\n\tstruct mosquitto__packet *packet;\n\tif(!context) return;\n\tif(force_free){\n\t\tcontext->clean_start = true;\n\t}\n#ifdef WITH_BRIDGE\n\tif(context->bridge){\n\t\tbridge__cleanup(context);\n\t}\n#endif\n\talias__free_all(context);\n\tmosquitto__free(context->auth_method);\n\tcontext->auth_method = NULL;\n\tmosquitto__free(context->username);\n\tcontext->username = NULL;\n\tmosquitto__free(context->password);\n\tcontext->password = NULL;\n\tnet__socket_close(context);\n\tif(force_free){\n\t\tsub__clean_session(context);\n\t}\n\tdb__messages_delete(context, force_free);\n\tmosquitto__free(context->address);\n\tcontext->address = NULL;\n\tcontext__send_will(context);\n\tif(context->id){\n\t\tcontext__remove_from_by_id(context);\n\t\tmosquitto__free(context->id);\n\t\tcontext->id = NULL;\n\t}\n\tpacket__cleanup(&(context->in_packet));\n\tif(context->current_out_packet){\n\t\tpacket__cleanup(context->current_out_packet);\n\t\tmosquitto__free(context->current_out_packet);\n\t\tcontext->current_out_packet = NULL;\n\t}\n\twhile(context->out_packet){\n\t\tpacket__cleanup(context->out_packet);\n\t\tpacket = context->out_packet;\n\t\tcontext->out_packet = context->out_packet->next;\n\t\tmosquitto__free(packet);\n\t}\n\tcontext->out_packet_count = 0;\n#if defined(WITH_BROKER) && defined(__GLIBC__) && defined(WITH_ADNS)\n\tif(context->adns){\n\t\tgai_cancel(context->adns);\n\t\tmosquitto__free((struct addrinfo *)context->adns->ar_request);\n\t\tmosquitto__free(context->adns);\n\t}\n#endif\n\tif(force_free){\n\t\tmosquitto__free(context);\n\t}\n}", "target": 1}
{"code": "zend_op_array *compile_string(zval *source_string, char *filename TSRMLS_DC)\n{\n\tzend_lex_state original_lex_state;\n\tzend_op_array *op_array = (zend_op_array *) emalloc(sizeof(zend_op_array));\n\tzend_op_array *original_active_op_array = CG(active_op_array);\n\tzend_op_array *retval;\n\tzval tmp;\n\tint compiler_result;\n\tzend_bool original_in_compilation = CG(in_compilation);\n\tif (source_string->value.str.len==0) {\n\t\tefree(op_array);\n\t\treturn NULL;\n\t}\n\tCG(in_compilation) = 1;\n\ttmp = *source_string;\n\tzval_copy_ctor(&tmp);\n\tconvert_to_string(&tmp);\n\tsource_string = &tmp;\n\tzend_save_lexical_state(&original_lex_state TSRMLS_CC);\n\tif (zend_prepare_string_for_scanning(source_string, filename TSRMLS_CC)==FAILURE) {\n\t\tefree(op_array);\n\t\tretval = NULL;\n\t} else {\n\t\tzend_bool orig_interactive = CG(interactive);\n\t\tCG(interactive) = 0;\n\t\tinit_op_array(op_array, ZEND_EVAL_CODE, INITIAL_OP_ARRAY_SIZE TSRMLS_CC);\n\t\tCG(interactive) = orig_interactive;\n\t\tCG(active_op_array) = op_array;\n\t\tzend_stack_push(&CG(context_stack), (void *) &CG(context), sizeof(CG(context)));\n\t\tzend_init_compiler_context(TSRMLS_C);\n\t\tBEGIN(ST_IN_SCRIPTING);\n\t\tcompiler_result = zendparse(TSRMLS_C);\n\t\tif (SCNG(script_filtered)) {\n\t\t\tefree(SCNG(script_filtered));\n\t\t\tSCNG(script_filtered) = NULL;\n\t\t}\n\t\tif (compiler_result==1) {\n\t\t\tCG(active_op_array) = original_active_op_array;\n\t\t\tCG(unclean_shutdown)=1;\n\t\t\tdestroy_op_array(op_array TSRMLS_CC);\n\t\t\tefree(op_array);\n\t\t\tretval = NULL;\n\t\t} else {\n\t\t\tzend_do_return(NULL, 0 TSRMLS_CC);\n\t\t\tCG(active_op_array) = original_active_op_array;\n\t\t\tpass_two(op_array TSRMLS_CC);\n\t\t\tzend_release_labels(0 TSRMLS_CC);\n\t\t\tretval = op_array;\n\t\t}\n\t}\n\tzend_restore_lexical_state(&original_lex_state TSRMLS_CC);\n\tzval_dtor(&tmp);\n\tCG(in_compilation) = original_in_compilation;\n\treturn retval;\n}", "target": 1}
{"code": "void xenvif_carrier_off(struct xenvif *vif)\n{\n\tstruct net_device *dev = vif->dev;\n\trtnl_lock();\n\tnetif_carrier_off(dev); \n\tif (netif_running(dev))\n\t\txenvif_down(vif);\n\trtnl_unlock();\n\txenvif_put(vif);\n}", "target": 0}
{"code": "Status XlaOpKernelContext::ConstantInputAsShape(int index, TensorShape* shape,\n                                                xla::ValueInferenceMode mode) {\n  xla::Literal literal;\n  TF_RETURN_IF_ERROR(ConstantInput(index, &literal, mode));\n  std::vector<int64_t> dims;\n  TF_RETURN_IF_ERROR(LiteralToInt64Vector(literal, &dims));\n  int64_t num_elements = 1;\n  for (auto i = dims.begin(); i != dims.end(); ++i) {\n    num_elements = MultiplyWithoutOverflow(num_elements, *i);\n    if (num_elements < 0)\n      return errors::InvalidArgument(\n          \"The total elements specified by orig_input_shape is too large.\",\n          \"Encountered overflow after multiplying\", *i,\n          \", result: \", num_elements);\n  }\n  *shape = TensorShape(dims);\n  return OkStatus();\n}", "target": 0}
{"code": "    TiffComponent* TiffIfdMakernote::doAddChild(TiffComponent::UniquePtr tiffComponent)\n    {\n        return ifd_.addChild(std::move(tiffComponent));\n    }", "target": 0}
{"code": "      BigInt square_mod_order(const BigInt& x) const\n         {\n         return m_mod_order.square(x);\n         }", "target": 0}
{"code": "void CharToWideMap(const char *Src,wchar *Dest,size_t DestSize,bool &Success)\n{\n  Success=false;\n  bool MarkAdded=false;\n  uint SrcPos=0,DestPos=0;\n  while (DestPos<DestSize)\n  {\n    if (Src[SrcPos]==0)\n    {\n      Success=true;\n      break;\n    }\n    mbstate_t ps;\n    memset(&ps,0,sizeof(ps));\n    if (mbrtowc(Dest+DestPos,Src+SrcPos,MB_CUR_MAX,&ps)==-1)\n    {\n      if (byte(Src[SrcPos])>=0x80)\n      {\n        if (!MarkAdded)\n        {\n          Dest[DestPos++]=MappedStringMark;\n          MarkAdded=true;\n          if (DestPos>=DestSize)\n            break;\n        }\n        Dest[DestPos++]=byte(Src[SrcPos++])+MapAreaStart;\n      }\n      else\n        break;\n    }\n    else\n    {\n      memset(&ps,0,sizeof(ps));\n      int Length=mbrlen(Src+SrcPos,MB_CUR_MAX,&ps);\n      SrcPos+=Max(Length,1);\n      DestPos++;\n    }\n  }\n  Dest[Min(DestPos,DestSize-1)]=0;\n}", "target": 1}
{"code": "add_prefix_matches(lookup_state_t *state,\n                   const svn_stringbuf_t *segment,\n                   apr_array_header_t *prefixes)\n{\n  int i = svn_sort__bsearch_lower_bound(prefixes, segment->data,\n                                        compare_node_path_segment);\n  if (i < prefixes->nelts)\n    add_if_prefix_matches(state,\n                          &APR_ARRAY_IDX(prefixes, i, sorted_pattern_t),\n                          segment);\n  if (i > 0)\n    {\n      sorted_pattern_t *pattern;\n      for (pattern = &APR_ARRAY_IDX(prefixes, i - 1, sorted_pattern_t);\n           pattern;\n           pattern = pattern->next)\n        {\n          add_if_prefix_matches(state, pattern, segment);\n        }\n    }\n}", "target": 0}
{"code": "static Jsi_RC SysTimesCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_RC rc = JSI_OK;\n    int i, n=1, argc = Jsi_ValueGetLength(interp, args);\n    Jsi_Value *func = Jsi_ValueArrayIndex(interp, args, 0);\n    if (Jsi_ValueIsBoolean(interp, func)) {\n        bool bv;\n        if (argc != 1)\n            return Jsi_LogError(\"bool must be only arg\");\n        Jsi_GetBoolFromValue(interp, func, &bv);\n        double now = jsi_GetTimestamp();\n        if (bv)\n            interp->timesStart = now;\n        else {\n            char buf[100];\n            snprintf(buf, sizeof(buf), \" (times = %.6f sec)\\n\", (now-interp->timesStart));\n            Jsi_Puts(interp, jsi_Stderr, buf, -1);\n        }\n        Jsi_ValueMakeNumber(interp, ret, 0);\n        return JSI_OK;\n    }\n    Jsi_Wide diff, start, end;\n    if (!Jsi_ValueIsFunction(interp, func))\n        return Jsi_LogError(\"arg1: expected function|bool\");\n    if (argc > 1 && Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, 1), &n) != JSI_OK)\n        return JSI_ERROR;\n    if (n<=0) \n        return Jsi_LogError(\"count not > 0: %d\", n);\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    start = (Jsi_Wide) tv.tv_sec * 1000000 + tv.tv_usec;\n    for (i=0; i<n && rc == JSI_OK; i++) {\n        rc = Jsi_FunctionInvoke(interp, func, NULL, ret, NULL);\n    }\n    gettimeofday(&tv, NULL);\n    end = (Jsi_Wide) tv.tv_sec * 1000000 + tv.tv_usec;\n    diff = (end - start);\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)diff);\n    return rc;\n}", "target": 1}
{"code": "mark_desktop_file_executable_task_thread_func (GTask        *task,\n                                               gpointer      source_object,\n                                               gpointer      task_data,\n                                               GCancellable *cancellable)\n{\n    MarkTrustedJob *job = task_data;\n    CommonJob *common;\n    common = (CommonJob *) job;\n    nautilus_progress_info_start (job->common.progress);\n    mark_desktop_file_executable (common,\n                                  cancellable,\n                                  job->file,\n                                  job->interactive);\n}", "target": 0}
{"code": "u64 local_clock(void)\n{\n\tif (!sched_clock_stable())\n\t\treturn sched_clock_cpu(raw_smp_processor_id());\n\treturn sched_clock();\n}", "target": 0}
{"code": "add_header_value(VALUE hh, const char *key, int klen, const char *val, int vlen) {\n    if (sizeof(content_type) - 1 == klen && 0 == strncasecmp(key, content_type, sizeof(content_type) - 1)) {\n\trb_hash_aset(hh, content_type_val, rb_str_new(val, vlen));\n    } else if (sizeof(content_length) - 1 == klen && 0 == strncasecmp(key, content_length, sizeof(content_length) - 1)) {\n\trb_hash_aset(hh, content_length_val, rb_str_new(val, vlen));\n    } else {\n\tchar\t\thkey[1024];\n\tchar\t\t*k = hkey;\n\tvolatile VALUE\tsval = rb_str_new(val, vlen);\n\tstrcpy(hkey, \"HTTP_\");\n\tk = hkey + 5;\n\tif ((int)(sizeof(hkey) - 5) <= klen) {\n\t    klen = sizeof(hkey) - 6;\n\t}\n\tstrncpy(k, key, klen);\n\thkey[klen + 5] = '\\0';\n\tfor (k = hkey + 5; '\\0' != *k; k++) {\n\t    if ('-' == *k) {\n\t\t*k = '_';\n\t    } else {\n\t\t*k = toupper(*k);\n\t    }\n\t}\n\trb_hash_aset(hh, rb_str_new(hkey, klen + 5), sval);\n    }\n}", "target": 1}
{"code": "validate_serials(struct deltas_head *deltas, ...)\n{\n\tunsigned long serial;\n\tunsigned int i;\n\tva_list vl;\n\tva_start(vl, deltas);\n\ti = 0;\n\twhile ((serial = va_arg(vl, unsigned long)) != END) {\n\t\tck_assert_uint_eq(serial, deltas->array[i].serial);\n\t\ti++;\n\t}\n\tva_end(vl);\n}", "target": 0}
{"code": "selaComputeCompositeParameters(const char  *fileout)\n{\nchar    *str, *nameh1, *nameh2, *namev1, *namev2;\nchar     buf[L_BUF_SIZE];\nl_int32  size, size1, size2, len;\nSARRAY  *sa;\nSELA    *selabasic, *selacomb;\n    selabasic = selaAddBasic(NULL);\n    selacomb = selaAddDwaCombs(NULL);\n    sa = sarrayCreate(64);\n    for (size = 2; size < 64; size++) {\n        selectComposableSizes(size, &size1, &size2);\n        nameh1 = selaGetBrickName(selabasic, size1, 1);\n        namev1 = selaGetBrickName(selabasic, 1, size1);\n        if (size2 > 1) {\n            nameh2 = selaGetCombName(selacomb, size1 * size2, L_HORIZ);\n            namev2 = selaGetCombName(selacomb, size1 * size2, L_VERT);\n        } else {\n            nameh2 = stringNew(\"\");\n            namev2 = stringNew(\"\");\n        }\n        snprintf(buf, L_BUF_SIZE,\n                 \"      { %d, %d, %d, \\\"%s\\\", \\\"%s\\\", \\\"%s\\\", \\\"%s\\\" },\",\n                 size, size1, size2, nameh1, nameh2, namev1, namev2);\n        sarrayAddString(sa, buf, L_COPY);\n        LEPT_FREE(nameh1);\n        LEPT_FREE(nameh2);\n        LEPT_FREE(namev1);\n        LEPT_FREE(namev2);\n    }\n    str = sarrayToString(sa, 1);\n    len = strlen(str);\n    l_binaryWrite(fileout, \"w\", str, len + 1);\n    LEPT_FREE(str);\n    sarrayDestroy(&sa);\n    selaDestroy(&selabasic);\n    selaDestroy(&selacomb);\n    return;\n}", "target": 1}
{"code": "static int adpt_i2o_issue_params(int cmd, adpt_hba* pHba, int tid, \n\t\t  void *opblk_va,  dma_addr_t opblk_pa, int oplen,\n\t\tvoid *resblk_va, dma_addr_t resblk_pa, int reslen)\n{\n\tu32 msg[9]; \n\tu32 *res = (u32 *)resblk_va;\n\tint wait_status;\n\tmsg[0] = NINE_WORD_MSG_SIZE | SGL_OFFSET_5;\n\tmsg[1] = cmd << 24 | HOST_TID << 12 | tid; \n\tmsg[2] = 0;\n\tmsg[3] = 0;\n\tmsg[4] = 0;\n\tmsg[5] = 0x54000000 | oplen;\t\n\tmsg[6] = (u32)opblk_pa;\n\tmsg[7] = 0xD0000000 | reslen;\t\n\tmsg[8] = (u32)resblk_pa;\n\tif ((wait_status = adpt_i2o_post_wait(pHba, msg, sizeof(msg), 20))) {\n\t\tprintk(\"adpt_i2o_issue_params: post_wait failed (%p)\\n\", resblk_va);\n   \t\treturn wait_status; \t\n\t}\n\tif (res[1]&0x00FF0000) { \t\n\t\tprintk(KERN_WARNING \"%s: %s - Error:\\n  ErrorInfoSize = 0x%02x, \"\n\t\t\t\"BlockStatus = 0x%02x, BlockSize = 0x%04x\\n\",\n\t\t\tpHba->name,\n\t\t\t(cmd == I2O_CMD_UTIL_PARAMS_SET) ? \"PARAMS_SET\"\n\t\t\t\t\t\t\t : \"PARAMS_GET\",   \n\t\t\tres[1]>>24, (res[1]>>16)&0xFF, res[1]&0xFFFF);\n\t\treturn -((res[1] >> 16) & 0xFF); \n\t}\n\treturn 4 + ((res[1] & 0x0000FFFF) << 2); \n}", "target": 1}
{"code": "static bool fib6_rule_suppress(struct fib_rule *rule, struct fib_lookup_arg *arg)\n{\n\tstruct fib6_result *res = arg->result;\n\tstruct rt6_info *rt = res->rt6;\n\tstruct net_device *dev = NULL;\n\tif (!rt)\n\t\treturn false;\n\tif (rt->rt6i_idev)\n\t\tdev = rt->rt6i_idev->dev;\n\tif (rt->rt6i_dst.plen <= rule->suppress_prefixlen)\n\t\tgoto suppress_route;\n\tif (rule->suppress_ifgroup != -1 && dev && dev->group == rule->suppress_ifgroup)\n\t\tgoto suppress_route;\n\treturn false;\nsuppress_route:\n\tip6_rt_put(rt);\n\treturn true;\n}", "target": 1}
{"code": "static int bnx2x_vlan_rx_add_vid(struct net_device *dev, __be16 proto, u16 vid)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\tstruct bnx2x_vlan_entry *vlan;\n\tDP(NETIF_MSG_IFUP, \"Adding VLAN %d\\n\", vid);\n\tvlan = kmalloc(sizeof(*vlan), GFP_KERNEL);\n\tif (!vlan)\n\t\treturn -ENOMEM;\n\tvlan->vid = vid;\n\tvlan->hw = false;\n\tlist_add_tail(&vlan->link, &bp->vlan_reg);\n\tif (netif_running(dev))\n\t\tbnx2x_vlan_configure(bp, true);\n\treturn 0;\n}", "target": 0}
{"code": "void sigsegvHandler(int sig, siginfo_t *info, void *secret) {\n    UNUSED(secret);\n    UNUSED(info);\n    bugReportStart();\n    serverLog(LL_WARNING,\n        \"Redis %s crashed by signal: %d, si_code: %d\", REDIS_VERSION, sig, info->si_code);\n    if (sig == SIGSEGV || sig == SIGBUS) {\n        serverLog(LL_WARNING,\n        \"Accessing address: %p\", (void*)info->si_addr);\n    }\n    if (info->si_code == SI_USER && info->si_pid != -1) {\n        serverLog(LL_WARNING, \"Killed by PID: %ld, UID: %d\", (long) info->si_pid, info->si_uid);\n    }\n#ifdef HAVE_BACKTRACE\n    ucontext_t *uc = (ucontext_t*) secret;\n    void *eip = getMcontextEip(uc);\n    if (eip != NULL) {\n        serverLog(LL_WARNING,\n        \"Crashed running the instruction at: %p\", eip);\n    }\n    logStackTrace(getMcontextEip(uc), 1);\n    logRegisters(uc);\n#endif\n    printCrashReport();\n#ifdef HAVE_BACKTRACE\n    if (eip != NULL)\n        dumpCodeAroundEIP(eip);\n#endif\n    bugReportEnd(1, sig);\n}", "target": 1}
{"code": "vips_foreign_load_gif_scan_image( VipsForeignLoadGif *gif ) \n{\n\tVipsObjectClass *class = VIPS_OBJECT_GET_CLASS( gif );\n\tGifFileType *file = gif->file;\n\tColorMapObject *map = file->Image.ColorMap ?\n\t\tfile->Image.ColorMap : file->SColorMap;\n\tGifByteType *extension;\n\tif( DGifGetImageDesc( gif->file ) == GIF_ERROR ) {\n\t\tvips_foreign_load_gif_error( gif ); \n\t\treturn( -1 );\n\t}\n\tif( file->Image.Left < 0 ||\n\t\tfile->Image.Width < 1 ||\n\t\tfile->Image.Width > 10000 ||\n\t\tfile->Image.Left + file->Image.Width > file->SWidth ||\n\t\tfile->Image.Top < 0 ||\n\t\tfile->Image.Height < 1 ||\n\t\tfile->Image.Height > 10000 ||\n\t\tfile->Image.Top + file->Image.Height > file->SHeight ) {\n\t\tvips_error( class->nickname, \"%s\", _( \"bad frame size\" ) ); \n\t\treturn( -1 ); \n\t}\n\tif( !gif->has_colour &&\n\t\tmap ) {\n\t\tint i;\n\t\tfor( i = 0; i < map->ColorCount; i++ ) \n\t\t\tif( map->Colors[i].Red != map->Colors[i].Green ||\n\t\t\t\tmap->Colors[i].Green != map->Colors[i].Blue ) {\n\t\t\t\tgif->has_colour = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\tdo {\n\t\tif( vips_foreign_load_gif_code_next( gif, &extension ) ) \n\t\t\treturn( -1 );\n\t} while( extension != NULL );\n\treturn( 0 );\n}", "target": 1}
{"code": "pim_print(netdissect_options *ndo,\n          register const u_char *bp, register u_int len, const u_char *bp2)\n{\n\tregister const u_char *ep;\n\tregister const struct pim *pim = (const struct pim *)bp;\n\tep = (const u_char *)ndo->ndo_snapend;\n\tif (bp >= ep)\n\t\treturn;\n#ifdef notyet\t\t\t\n\tND_TCHECK(pim->pim_rsv);\n#endif\n\tswitch (PIM_VER(pim->pim_typever)) {\n\tcase 2:\n\t\tif (!ndo->ndo_vflag) {\n\t\t\tND_PRINT((ndo, \"PIMv%u, %s, length %u\",\n\t\t\t          PIM_VER(pim->pim_typever),\n\t\t\t          tok2str(pimv2_type_values,\"Unknown Type\",PIM_TYPE(pim->pim_typever)),\n\t\t\t          len));\n\t\t\treturn;\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"PIMv%u, length %u\\n\\t%s\",\n\t\t\t          PIM_VER(pim->pim_typever),\n\t\t\t          len,\n\t\t\t          tok2str(pimv2_type_values,\"Unknown Type\",PIM_TYPE(pim->pim_typever))));\n\t\t\tpimv2_print(ndo, bp, len, bp2);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \"PIMv%u, length %u\",\n\t\t          PIM_VER(pim->pim_typever),\n\t\t          len));\n\t\tbreak;\n\t}\n\treturn;\n}", "target": 1}
{"code": "static long compat_adpt_ioctl(struct file *file,\n\t\t\t\tunsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode;\n\tlong ret;\n\tinode = file_inode(file);\n\tmutex_lock(&adpt_mutex);\n\tswitch(cmd) {\n\t\tcase DPT_SIGNATURE:\n\t\tcase I2OUSRCMD:\n\t\tcase DPT_CTRLINFO:\n\t\tcase DPT_SYSINFO:\n\t\tcase DPT_BLINKLED:\n\t\tcase I2ORESETCMD:\n\t\tcase I2ORESCANCMD:\n\t\tcase (DPT_TARGET_BUSY & 0xFFFF):\n\t\tcase DPT_TARGET_BUSY:\n\t\t\tret = adpt_ioctl(inode, file, cmd, arg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret =  -ENOIOCTLCMD;\n\t}\n\tmutex_unlock(&adpt_mutex);\n\treturn ret;\n}", "target": 1}
{"code": "void imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_backtick)\n{\n  const char *quote = \"`\\\"\\\\\";\n  if (!quote_backtick)\n    quote++;\n  char *pt = dest;\n  const char *s = src;\n  *pt++ = '\"';\n  dlen -= 2;\n  for (; *s && dlen; s++)\n  {\n    if (strchr(quote, *s))\n    {\n      if (dlen < 2)\n        break;\n      dlen -= 2;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\"';\n  *pt = '\\0';\n}", "target": 0}
{"code": "static int umocktypes_copy_FLOW_HANDLE(FLOW_HANDLE* destination, const FLOW_HANDLE* source)\n{\n    int result = 0;\n    *(destination) = *(source);\n    return result;\n}", "target": 0}
{"code": "GF_Err stbl_AppendSize(GF_SampleTableBox *stbl, u32 size, u32 nb_pack)\n{\n\tu32 i;\n\tif (!nb_pack) nb_pack = 1;\n\tif (!stbl->SampleSize->sampleCount) {\n\t\tstbl->SampleSize->sampleSize = size;\n\t\tstbl->SampleSize->sampleCount += nb_pack;\n\t\treturn GF_OK;\n\t}\n\tif (stbl->SampleSize->sampleSize && (stbl->SampleSize->sampleSize==size)) {\n\t\tstbl->SampleSize->sampleCount += nb_pack;\n\t\treturn GF_OK;\n\t}\n\tif (!stbl->SampleSize->sizes || (stbl->SampleSize->sampleCount+nb_pack > stbl->SampleSize->alloc_size)) {\n\t\tBool init_table = (stbl->SampleSize->sizes==NULL) ? 1 : 0;\n\t\tALLOC_INC(stbl->SampleSize->alloc_size);\n\t\tif (stbl->SampleSize->sampleCount+nb_pack > stbl->SampleSize->alloc_size)\n\t\t\tstbl->SampleSize->alloc_size = stbl->SampleSize->sampleCount+nb_pack;\n\t\tstbl->SampleSize->sizes = (u32 *)gf_realloc(stbl->SampleSize->sizes, sizeof(u32)*stbl->SampleSize->alloc_size);\n\t\tif (!stbl->SampleSize->sizes) return GF_OUT_OF_MEM;\n\t\tmemset(&stbl->SampleSize->sizes[stbl->SampleSize->sampleCount], 0, sizeof(u32) * (stbl->SampleSize->alloc_size - stbl->SampleSize->sampleCount) );\n\t\tif (init_table) {\n\t\t\tfor (i=0; i<stbl->SampleSize->sampleCount; i++)\n\t\t\t\tstbl->SampleSize->sizes[i] = stbl->SampleSize->sampleSize;\n\t\t}\n\t}\n\tstbl->SampleSize->sampleSize = 0;\n\tfor (i=0; i<nb_pack; i++) {\n\t\tstbl->SampleSize->sizes[stbl->SampleSize->sampleCount+i] = size;\n\t}\n\tstbl->SampleSize->sampleCount += nb_pack;\n\tif (size > stbl->SampleSize->max_size)\n\t\tstbl->SampleSize->max_size = size;\n\tstbl->SampleSize->total_size += size;\n\tstbl->SampleSize->total_samples += nb_pack;\n\treturn GF_OK;\n}", "target": 1}
{"code": "server_request_direct_streamlocal(void)\n{\n\tChannel *c = NULL;\n\tchar *target, *originator;\n\tu_short originator_port;\n\ttarget = packet_get_string(NULL);\n\toriginator = packet_get_string(NULL);\n\toriginator_port = packet_get_int();\n\tpacket_check_eom();\n\tdebug(\"server_request_direct_streamlocal: originator %s port %d, target %s\",\n\t    originator, originator_port, target);\n\tif ((options.allow_streamlocal_forwarding & FORWARD_LOCAL) != 0 &&\n\t    !no_port_forwarding_flag && !options.disable_forwarding) {\n\t\tc = channel_connect_to_path(target,\n\t\t    \"direct-streamlocal@openssh.com\", \"direct-streamlocal\");\n\t} else {\n\t\tlogit(\"refused streamlocal port forward: \"\n\t\t    \"originator %s port %d, target %s\",\n\t\t    originator, originator_port, target);\n\t}\n\tfree(originator);\n\tfree(target);\n\treturn c;\n}", "target": 1}
{"code": "smb2_query_eas(const unsigned int xid, struct cifs_tcon *tcon,\n\t       const unsigned char *path, const unsigned char *ea_name,\n\t       char *ea_data, size_t buf_size,\n\t       struct cifs_sb_info *cifs_sb)\n{\n\tint rc;\n\tstruct kvec rsp_iov = {NULL, 0};\n\tint buftype = CIFS_NO_BUFFER;\n\tstruct smb2_query_info_rsp *rsp;\n\tstruct smb2_file_full_ea_info *info = NULL;\n\trc = smb2_query_info_compound(xid, tcon, path,\n\t\t\t\t      FILE_READ_EA,\n\t\t\t\t      FILE_FULL_EA_INFORMATION,\n\t\t\t\t      SMB2_O_INFO_FILE,\n\t\t\t\t      CIFSMaxBufSize -\n\t\t\t\t      MAX_SMB2_CREATE_RESPONSE_SIZE -\n\t\t\t\t      MAX_SMB2_CLOSE_RESPONSE_SIZE,\n\t\t\t\t      &rsp_iov, &buftype, cifs_sb);\n\tif (rc) {\n\t\tif (!ea_name && rc == -ENODATA)\n\t\t\trc = 0;\n\t\tgoto qeas_exit;\n\t}\n\trsp = (struct smb2_query_info_rsp *)rsp_iov.iov_base;\n\trc = smb2_validate_iov(le16_to_cpu(rsp->OutputBufferOffset),\n\t\t\t       le32_to_cpu(rsp->OutputBufferLength),\n\t\t\t       &rsp_iov,\n\t\t\t       sizeof(struct smb2_file_full_ea_info));\n\tif (rc)\n\t\tgoto qeas_exit;\n\tinfo = (struct smb2_file_full_ea_info *)(\n\t\t\tle16_to_cpu(rsp->OutputBufferOffset) + (char *)rsp);\n\trc = move_smb2_ea_to_cifs(ea_data, buf_size, info,\n\t\t\tle32_to_cpu(rsp->OutputBufferLength), ea_name);\n qeas_exit:\n\tfree_rsp_buf(buftype, rsp_iov.iov_base);\n\treturn rc;\n}", "target": 0}
{"code": "void gdImageSetBrush (gdImagePtr im, gdImagePtr brush)\n{\n\tint i;\n\tim->brush = brush;\n\tif (!im->trueColor && !im->brush->trueColor) {\n\t\tfor (i = 0; i < gdImageColorsTotal(brush); i++) {\n\t\t\tint index;\n\t\t\tindex = gdImageColorResolveAlpha(im, gdImageRed(brush, i), gdImageGreen(brush, i), gdImageBlue(brush, i), gdImageAlpha(brush, i));\n\t\t\tim->brushColorMap[i] = index;\n\t\t}\n\t}\n}", "target": 0}
{"code": "exo_open_find_scheme (const gchar *string)\n{\n  gchar *current_dir;\n  gchar *uri;\n  gchar *path;\n  if (g_path_is_absolute (string))\n    return exo_open_get_path (string);\n  current_dir = g_get_current_dir ();\n  path = g_build_filename (current_dir, string, NULL);\n  g_free (current_dir);\n  if (g_file_test (path, G_FILE_TEST_EXISTS))\n    {\n       uri = exo_open_get_path (path);\n       g_free (path);\n       return uri;\n    }\n  g_free (path);\n  if (g_regex_match_simple (MATCH_PATTERN_EMAIL, string, G_REGEX_CASELESS, 0))\n    return g_strconcat (\"mailto:\", string, NULL);\n  if (g_regex_match_simple (MATCH_PATTERN_HTTP, string, G_REGEX_CASELESS, 0))\n    return g_strconcat (\"http:\n  return NULL;\n}", "target": 0}
{"code": "static int opl3_load_patch(int dev, int format, const char __user *addr,\n\t\tint offs, int count, int pmgr_flag)\n{\n\tstruct sbi_instrument ins;\n\tif (count <sizeof(ins))\n\t{\n\t\tprintk(KERN_WARNING \"FM Error: Patch record too short\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif(copy_from_user(&((char *) &ins)[offs], addr + offs, sizeof(ins) - offs))\n\t\treturn -EFAULT;\n\tif (ins.channel < 0 || ins.channel >= SBFM_MAXINSTR)\n\t{\n\t\tprintk(KERN_WARNING \"FM Error: Invalid instrument number %d\\n\", ins.channel);\n\t\treturn -EINVAL;\n\t}\n\tins.key = format;\n\treturn store_instr(ins.channel, &ins);\n}", "target": 1}
{"code": "static int proc_readdir(const char *path, void *buf, fuse_fill_dir_t filler, off_t offset,\n\t\tstruct fuse_file_info *fi)\n{\n\tif (filler(buf, \"cpuinfo\", NULL, 0) != 0 ||\n\t\t\t\tfiller(buf, \"meminfo\", NULL, 0) != 0 ||\n\t\t\t\tfiller(buf, \"stat\", NULL, 0) != 0 ||\n\t\t\t\tfiller(buf, \"uptime\", NULL, 0) != 0 ||\n\t\t\t\tfiller(buf, \"diskstats\", NULL, 0) != 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 0}
{"code": "}\nstatic inline bool f2fs_force_buffered_io(struct inode *inode,\n\t\t\t\tstruct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tint rw = iov_iter_rw(iter);\n\tif (f2fs_post_read_required(inode))\n\t\treturn true;\n\tif (f2fs_is_multi_device(sbi))\n\t\treturn true;\n\tif (f2fs_sb_has_blkzoned(sbi))\n\t\treturn true;\n\tif (test_opt(sbi, LFS) && (rw == WRITE) &&\n\t\t\t\tblock_unaligned_IO(inode, iocb, iter))\n\t\treturn true;\n\tif (is_sbi_flag_set(F2FS_I_SB(inode), SBI_CP_DISABLED))\n\t\treturn true;", "target": 1}
{"code": "hufDecode\n    (const Int64 * \thcode,\t\n     const HufDec * \thdecod,\t\n     const char* \tin,\t\n     int\t\tni,\t\n     int\t\trlc,\t\n     int\t\tno,\t\n     unsigned short*\tout)\t\n{\n    Int64 c = 0;\n    int lc = 0;\n    unsigned short * outb = out;\n    unsigned short * oe = out + no;\n    const char * ie = in + (ni + 7) / 8; \n    while (in < ie)\n    {\n\tgetChar (c, lc, in);\n\twhile (lc >= HUF_DECBITS)\n\t{\n\t    const HufDec pl = hdecod[(c >> (lc-HUF_DECBITS)) & HUF_DECMASK];\n\t    if (pl.len)\n\t    {\n\t\tlc -= pl.len;\n\t\tif ( lc < 0 )\n\t\t{\n\t\t\tinvalidCode(); \n\t\t}\n\t\tgetCode (pl.lit, rlc, c, lc, in, out, outb, oe);\n\t    }\n\t    else\n\t    {\n\t\tif (!pl.p)\n\t\t    invalidCode(); \n\t\tint j;\n\t\tfor (j = 0; j < pl.lit; j++)\n\t\t{\n\t\t    int\tl = hufLength (hcode[pl.p[j]]);\n\t\t    while (lc < l && in < ie)\t\n\t\t\tgetChar (c, lc, in);\n\t\t    if (lc >= l)\n\t\t    {\n\t\t\tif (hufCode (hcode[pl.p[j]]) ==\n\t\t\t\t((c >> (lc - l)) & ((Int64(1) << l) - 1)))\n\t\t\t{\n\t\t\t    lc -= l;\n\t\t\t    getCode (pl.p[j], rlc, c, lc, in, out, outb, oe);\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (j == pl.lit)\n\t\t    invalidCode(); \n\t    }\n\t}\n    }\n    int i = (8 - ni) & 7;\n    c >>= i;\n    lc -= i;\n    while (lc > 0)\n    {\n\tconst HufDec pl = hdecod[(c << (HUF_DECBITS - lc)) & HUF_DECMASK];\n\tif (pl.len)\n\t{\n\t    lc -= pl.len;\n            if ( lc < 0 )\n            {\n   \t        invalidCode(); \n            }\n\t    getCode (pl.lit, rlc, c, lc, in, out, outb, oe);\n\t}\n\telse\n\t{\n\t    invalidCode(); \n\t}\n    }\n    if (out - outb != no)\n\tnotEnoughData ();\n}", "target": 0}
{"code": "static int oidc_cache_crypto_encrypt(request_rec *r, const char *plaintext,\n\t\tunsigned char *key, char **result) {\n\tchar *encoded = NULL, *p = NULL, *e_tag = NULL;\n\tunsigned char *ciphertext = NULL;\n\tint plaintext_len, ciphertext_len, encoded_len, e_tag_len;\n\tunsigned char tag[OIDC_CACHE_TAG_LEN];\n\tplaintext_len = strlen(plaintext) + 1;\n\tciphertext = apr_pcalloc(r->pool,\n\t\t\t(plaintext_len + EVP_CIPHER_block_size(OIDC_CACHE_CIPHER)));\n\tciphertext_len = oidc_cache_crypto_encrypt_impl(r,\n\t\t\t(unsigned char *) plaintext, plaintext_len,\n\t\t\tOIDC_CACHE_CRYPTO_GCM_AAD, sizeof(OIDC_CACHE_CRYPTO_GCM_AAD), key,\n\t\t\tOIDC_CACHE_CRYPTO_GCM_IV, sizeof(OIDC_CACHE_CRYPTO_GCM_IV),\n\t\t\tciphertext, tag, sizeof(tag));\n\tencoded_len = oidc_base64url_encode(r, &encoded, (const char *) ciphertext,\n\t\t\tciphertext_len, 1);\n\tif (encoded_len > 0) {\n\t\tp = encoded;\n\t\te_tag_len = oidc_base64url_encode(r, &e_tag, (const char *) tag,\n\t\t\t\tOIDC_CACHE_TAG_LEN, 1);\n\t\tencoded = apr_pcalloc(r->pool, encoded_len + 1 + e_tag_len + 1);\n\t\tmemcpy(encoded, p, encoded_len);\n\t\tp = encoded + encoded_len;\n\t\t*p = OIDC_CHAR_DOT;\n\t\tp++;\n\t\tmemcpy(p, e_tag, e_tag_len);\n\t\tencoded_len += e_tag_len + 1;\n\t\tencoded[encoded_len] = '\\0';\n\t\t*result = encoded;\n\t}\n\treturn encoded_len;\n}", "target": 1}
{"code": "static int keyring_search_iterator(const void *object, void *iterator_data)\n{\n\tstruct keyring_search_context *ctx = iterator_data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\tunsigned long kflags = key->flags;\n\tkenter(\"{%d}\", key->serial);\n\tif (key->type != ctx->index_key.type) {\n\t\tkleave(\" = 0 [!type]\");\n\t\treturn 0;\n\t}\n\tif (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {\n\t\tif (kflags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t      (1 << KEY_FLAG_REVOKED))) {\n\t\t\tctx->result = ERR_PTR(-EKEYREVOKED);\n\t\t\tkleave(\" = %d [invrev]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\t\tif (key->expiry && ctx->now.tv_sec >= key->expiry) {\n\t\t\tif (!(ctx->flags & KEYRING_SEARCH_SKIP_EXPIRED))\n\t\t\t\tctx->result = ERR_PTR(-EKEYEXPIRED);\n\t\t\tkleave(\" = %d [expire]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\t}\n\tif (!ctx->match_data.cmp(key, &ctx->match_data)) {\n\t\tkleave(\" = 0 [!match]\");\n\t\treturn 0;\n\t}\n\tif (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM) &&\n\t    key_task_permission(make_key_ref(key, ctx->possessed),\n\t\t\t\tctx->cred, KEY_NEED_SEARCH) < 0) {\n\t\tctx->result = ERR_PTR(-EACCES);\n\t\tkleave(\" = %d [!perm]\", ctx->skipped_ret);\n\t\tgoto skipped;\n\t}\n\tif (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {\n\t\tif (kflags & (1 << KEY_FLAG_NEGATIVE)) {\n\t\t\tsmp_rmb();\n\t\t\tctx->result = ERR_PTR(key->reject_error);\n\t\t\tkleave(\" = %d [neg]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\t}\n\tctx->result = make_key_ref(key, ctx->possessed);\n\tkleave(\" = 1 [found]\");\n\treturn 1;\nskipped:\n\treturn ctx->skipped_ret;\n}", "target": 1}
{"code": "AP4_AvccAtom::InspectFields(AP4_AtomInspector& inspector)\n{\n    inspector.AddField(\"Configuration Version\", m_ConfigurationVersion);\n    const char* profile_name = GetProfileName(m_Profile);\n    if (profile_name) {\n        inspector.AddField(\"Profile\", profile_name);\n    } else {\n        inspector.AddField(\"Profile\", m_Profile);\n    }\n    inspector.AddField(\"Profile Compatibility\", m_ProfileCompatibility, AP4_AtomInspector::HINT_HEX);\n    inspector.AddField(\"Level\", m_Level);\n    inspector.AddField(\"NALU Length Size\", m_NaluLengthSize);\n    for (unsigned int i=0; i<m_SequenceParameters.ItemCount(); i++) {\n        inspector.AddField(\"Sequence Parameter\", m_SequenceParameters[i].GetData(), m_SequenceParameters[i].GetDataSize());\n    }\n    for (unsigned int i=0; i<m_SequenceParameters.ItemCount(); i++) {\n        inspector.AddField(\"Picture Parameter\", m_PictureParameters[i].GetData(), m_PictureParameters[i].GetDataSize());\n    }\n    return AP4_SUCCESS;\n}", "target": 1}
{"code": "void test_bind(const char *path)\n{\n\tint sfd;\n\tstruct sockaddr_un my_addr, peer_addr;\n\tsfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\tif (sfd < 0) {\n\t\tfprintf(stderr, \"Failed to open a socket for bind test\\n\");\n\t\texit(1);\n\t}\n\tmemset(&my_addr, 0, sizeof(struct sockaddr_un));\n\tmy_addr.sun_family = AF_UNIX;\n\tstrncpy(my_addr.sun_path, path,\n\t\t\tsizeof(my_addr.sun_path) - 1);\n\tif (bind(sfd, (struct sockaddr *) &my_addr,\n\t\t\t\tsizeof(struct sockaddr_un)) != -1) {\n\t\tfprintf(stderr, \"leak at bind of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at bind of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n\tclose(sfd);\n}", "target": 0}
{"code": "  void SetContextState(AudioContext* audio_context,\n                       AudioContext::AudioContextState state) {\n    audio_context->SetContextState(state);\n  }", "target": 0}
{"code": "AnimatedPropertyType SVGAnimateElement::determineAnimatedPropertyType(SVGElement* targetElement) const\n{\n    ASSERT(targetElement);\n    Vector<AnimatedPropertyType> propertyTypes;\n    targetElement->animatedPropertyTypeForAttribute(attributeName(), propertyTypes);\n    if (propertyTypes.isEmpty())\n        return AnimatedUnknown;\n    ASSERT(propertyTypes.size() <= 2);\n    AnimatedPropertyType type = propertyTypes[0];\n    if (hasTagName(SVGNames::animateColorTag) && type != AnimatedColor)\n        return AnimatedUnknown;\n    if (type == AnimatedTransformList && !hasTagName(SVGNames::animateTransformTag))\n        return AnimatedUnknown;\n    if (targetElement->hasTagName(SVGNames::markerTag) && type == AnimatedAngle) {\n        ASSERT(propertyTypes.size() == 2);\n        ASSERT(propertyTypes[0] == AnimatedAngle);\n        ASSERT(propertyTypes[1] == AnimatedEnumeration);\n    } else if (propertyTypes.size() == 2)\n        ASSERT(propertyTypes[0] == propertyTypes[1]);\n    return type;\n}", "target": 0}
{"code": "void DoImageProjectiveTransformOp(OpKernelContext* ctx,\n                                  const Interpolation& interpolation,\n                                  const Mode& fill_mode) {\n  const Tensor& images_t = ctx->input(0);\n  const Tensor& transform_t = ctx->input(1);\n  OP_REQUIRES(ctx, images_t.shape().dims() == 4,\n              errors::InvalidArgument(\"Input images must have rank 4\"));\n  OP_REQUIRES(ctx,\n              (TensorShapeUtils::IsMatrix(transform_t.shape()) &&\n               (transform_t.dim_size(0) == images_t.dim_size(0) ||\n                transform_t.dim_size(0) == 1) &&\n               transform_t.dim_size(1) == 8),\n              errors::InvalidArgument(\n                  \"Input transform should be num_images x 8 or 1 x 8\"));\n  int32_t out_height, out_width;\n  if (ctx->num_inputs() >= 3) {\n    const Tensor& shape_t = ctx->input(2);\n    OP_REQUIRES(ctx, shape_t.dims() == 1,\n                errors::InvalidArgument(\"output shape must be 1-dimensional\",\n                                        shape_t.shape().DebugString()));\n    OP_REQUIRES(ctx, shape_t.NumElements() == 2,\n                errors::InvalidArgument(\"output shape must have two elements\",\n                                        shape_t.shape().DebugString()));\n    auto shape_vec = shape_t.vec<int32>();\n    out_height = shape_vec(0);\n    out_width = shape_vec(1);\n    OP_REQUIRES(ctx, out_height > 0 && out_width > 0,\n                errors::InvalidArgument(\"output dimensions must be positive\"));\n  } else {\n    out_height = images_t.shape().dim_size(1);\n    out_width = images_t.shape().dim_size(2);\n  }\n  T fill_value(0);\n  if (ctx->num_inputs() >= 4) {\n    const Tensor& fill_value_t = ctx->input(3);\n    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(fill_value_t.shape()),\n                errors::InvalidArgument(\"fill_value must be a scalar\",\n                                        fill_value_t.shape().DebugString()));\n    fill_value = static_cast<T>(*(fill_value_t.scalar<float>().data()));\n  }\n  Tensor* output_t;\n  OP_REQUIRES_OK(\n      ctx, ctx->allocate_output(0,\n                                TensorShape({images_t.dim_size(0), out_height,\n                                             out_width, images_t.dim_size(3)}),\n                                &output_t));\n  auto output = output_t->tensor<T, 4>();\n  auto images = images_t.tensor<T, 4>();\n  auto transform = transform_t.matrix<float>();\n  (FillProjectiveTransform<Device, T>(interpolation))(\n      ctx->eigen_device<Device>(), &output, images, transform, fill_mode,\n      fill_value);\n}", "target": 1}
{"code": "header_put_be_8byte (SF_PRIVATE *psf, sf_count_t x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 8)\n\t{\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = (x >> 24) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = x ;\n\t\t} ;\n} ", "target": 1}
{"code": "dissect_ac_if_hdr_body(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,\n        proto_tree *tree, usb_conv_info_t *usb_conv_info)\n{\n    gint     offset_start;\n    guint16  bcdADC;\n    guint8   ver_major;\n    double   ver;\n    guint8   if_in_collection, i;\n    audio_conv_info_t *audio_conv_info;\n    offset_start = offset;\n    bcdADC = tvb_get_letohs(tvb, offset);\n    ver_major = USB_AUDIO_BCD44_TO_DEC(bcdADC>>8);\n    ver = ver_major + USB_AUDIO_BCD44_TO_DEC(bcdADC&0xFF) / 100.0;\n    proto_tree_add_double_format_value(tree, hf_ac_if_hdr_ver,\n            tvb, offset, 2, ver, \"%2.2f\", ver);\n    audio_conv_info = (audio_conv_info_t *)usb_conv_info->class_data;\n    if(!audio_conv_info) {\n        audio_conv_info = wmem_new(wmem_file_scope(), audio_conv_info_t);\n        usb_conv_info->class_data = audio_conv_info;\n        usb_conv_info->class_data_type = USB_CONV_AUDIO;\n    } else if (usb_conv_info->class_data_type != USB_CONV_AUDIO) {\n        return 0;\n    }\n    audio_conv_info->ver_major = ver_major;\n    offset += 2;\n    if (ver_major==1) {\n        proto_tree_add_item(tree, hf_ac_if_hdr_total_len,\n                tvb, offset, 2, ENC_LITTLE_ENDIAN);\n        offset += 2;\n        if_in_collection = tvb_get_guint8(tvb, offset);\n        proto_tree_add_item(tree, hf_ac_if_hdr_bInCollection,\n                tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        offset++;\n        for (i=0; i<if_in_collection; i++) {\n            proto_tree_add_item(tree, hf_ac_if_hdr_if_num,\n                    tvb, offset, 1, ENC_LITTLE_ENDIAN);\n            offset++;\n        }\n    }\n    return offset-offset_start;\n}", "target": 0}
{"code": "  void operator()(const CPUDevice& d, typename TTypes<T, 4>::ConstTensor input,\n                  typename TTypes<T, 3>::ConstTensor filter,\n                  typename TTypes<T, 4>::ConstTensor out_backprop,\n                  int stride_rows, int stride_cols, int rate_rows,\n                  int rate_cols, int pad_top, int pad_left,\n                  typename TTypes<T, 3>::Tensor filter_backprop) {\n    const int batch = input.dimension(0);\n    const int input_rows = input.dimension(1);\n    const int input_cols = input.dimension(2);\n    const int depth = input.dimension(3);\n    const int filter_rows = filter.dimension(0);\n    const int filter_cols = filter.dimension(1);\n    const int output_rows = out_backprop.dimension(1);\n    const int output_cols = out_backprop.dimension(2);\n    filter_backprop.setZero();\n    for (int b = 0; b < batch; ++b) {\n      for (int h_out = 0; h_out < output_rows; ++h_out) {\n        int h_beg = h_out * stride_rows - pad_top;\n        for (int w_out = 0; w_out < output_cols; ++w_out) {\n          int w_beg = w_out * stride_cols - pad_left;\n          for (int d = 0; d < depth; ++d) {\n            T cur_val = Eigen::NumTraits<T>::lowest();\n            int h_max = 0;\n            int w_max = 0;\n            for (int h = 0; h < filter_rows; ++h) {\n              const int h_in = h_beg + h * rate_rows;\n              if (h_in >= 0 && h_in < input_rows) {\n                for (int w = 0; w < filter_cols; ++w) {\n                  const int w_in = w_beg + w * rate_cols;\n                  if (w_in >= 0 && w_in < input_cols) {\n                    const T val = input(b, h_in, w_in, d) + filter(h, w, d);\n                    if (val > cur_val) {\n                      cur_val = val;\n                      h_max = h;\n                      w_max = w;\n                    }\n                  }\n                }\n              }\n            }\n            filter_backprop(h_max, w_max, d) +=\n                out_backprop(b, h_out, w_out, d);\n          }\n        }\n      }\n    }\n  }", "target": 1}
{"code": "hash_new_from_regs(mrb_state *mrb, mrb_int argc, mrb_int idx)\n{\n  mrb_value hash = mrb_hash_new_capa(mrb, argc);\n  while (argc--) {\n    mrb_hash_set(mrb, hash, regs[idx+0], regs[idx+1]);\n    idx += 2;\n  }\n  return hash;\n}", "target": 0}
{"code": "static int ext4_dax_pmd_fault(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\t\t\tpmd_t *pmd, unsigned int flags)\n{\n\tint result;\n\thandle_t *handle = NULL;\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tstruct super_block *sb = inode->i_sb;\n\tbool write = flags & FAULT_FLAG_WRITE;\n\tif (write) {\n\t\tsb_start_pagefault(sb);\n\t\tfile_update_time(vma->vm_file);\n\t\thandle = ext4_journal_start_sb(sb, EXT4_HT_WRITE_PAGE,\n\t\t\t\text4_chunk_trans_blocks(inode,\n\t\t\t\t\t\t\tPMD_SIZE / PAGE_SIZE));\n\t}\n\tif (IS_ERR(handle))\n\t\tresult = VM_FAULT_SIGBUS;\n\telse\n\t\tresult = __dax_pmd_fault(vma, addr, pmd, flags,\n\t\t\t\text4_get_block_dax, ext4_end_io_unwritten);\n\tif (write) {\n\t\tif (!IS_ERR(handle))\n\t\t\text4_journal_stop(handle);\n\t\tsb_end_pagefault(sb);\n\t}\n\treturn result;\n}", "target": 1}
{"code": "ikev1_cert_print(netdissect_options *ndo, u_char tpay _U_,\n\t\t const struct isakmp_gen *ext, u_int item_len,\n\t\t const u_char *ep _U_, uint32_t phase _U_,\n\t\t uint32_t doi0 _U_,\n\t\t uint32_t proto0 _U_, int depth _U_)\n{\n\tconst struct ikev1_pl_cert *p;\n\tstruct ikev1_pl_cert cert;\n\tstatic const char *certstr[] = {\n\t\t\"none\",\t\"pkcs7\", \"pgp\", \"dns\",\n\t\t\"x509sign\", \"x509ke\", \"kerberos\", \"crl\",\n\t\t\"arl\", \"spki\", \"x509attr\",\n\t};\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_CERT)));\n\tp = (const struct ikev1_pl_cert *)ext;\n\tND_TCHECK(*p);\n\tUNALIGNED_MEMCPY(&cert, ext, sizeof(cert));\n\tND_PRINT((ndo,\" len=%d\", item_len - 4));\n\tND_PRINT((ndo,\" type=%s\", STR_OR_ID((cert.encode), certstr)));\n\tif (2 < ndo->ndo_vflag && 4 < item_len) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), item_len - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + item_len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_CERT)));\n\treturn NULL;\n}", "target": 0}
{"code": "static void cleanup_shm_refs(const uint64_t *saved_attr,\n\t\t\t     struct tee_ta_param *param, uint32_t num_params)\n{\n\tsize_t n;\n\tfor (n = 0; n < num_params; n++) {\n\t\tswitch (saved_attr[n]) {\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_INPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_INOUT:\n#ifdef CFG_CORE_DYN_SHM\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_INPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_OUTPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_INOUT:\n#endif\n\t\t\tmobj_put(param->u[n].mem.mobj);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}", "target": 1}
{"code": "static void parse_relocation_info(struct MACH0_(obj_t) *bin, RSkipList *relocs, ut32 offset, ut32 num) {\n\tif (!num || !offset || (st32)num < 0) {\n\t\treturn;\n\t}\n\tut64 total_size = num * sizeof (struct relocation_info);\n\tif (offset > bin->size) {\n\t\treturn;\n\t}\n\tif (total_size > bin->size) {\n\t\ttotal_size = bin->size - offset;\n\t\tnum = total_size /= sizeof (struct relocation_info);\n\t}\n\tstruct relocation_info *info = calloc (num, sizeof (struct relocation_info));\n\tif (!info) {\n\t\treturn;\n\t}\n\tif (r_buf_read_at (bin->b, offset, (ut8 *) info, total_size) < total_size) {\n\t\tfree (info);\n\t\treturn;\n\t}\n\tsize_t i;\n\tfor (i = 0; i < num; i++) {\n\t\tstruct relocation_info a_info = info[i];\n\t\tut32 sym_num = a_info.r_symbolnum;\n\t\tif (sym_num > bin->nsymtab) {\n\t\t\tcontinue;\n\t\t}\n\t\tut32 stridx = bin->symtab[sym_num].n_strx;\n\t\tchar *sym_name = get_name (bin, stridx, false);\n\t\tif (!sym_name) {\n\t\t\tcontinue;\n\t\t}\n\t\tstruct reloc_t *reloc = R_NEW0 (struct reloc_t);\n\t\tif (!reloc) {\n\t\t\tfree (info);\n\t\t\tfree (sym_name);\n\t\t\treturn;\n\t\t}\n\t\treloc->addr = offset_to_vaddr (bin, a_info.r_address);\n\t\treloc->offset = a_info.r_address;\n\t\treloc->ord = sym_num;\n\t\treloc->type = a_info.r_type; \n\t\treloc->external = a_info.r_extern;\n\t\treloc->pc_relative = a_info.r_pcrel;\n\t\treloc->size = a_info.r_length;\n\t\tr_str_ncpy (reloc->name, sym_name, sizeof (reloc->name) - 1);\n\t\tr_skiplist_insert (relocs, reloc);\n\t\tfree (sym_name);\n\t}\n\tfree (info);\n}", "target": 1}
{"code": "struct resource_pool *dce110_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc,\n\tstruct hw_asic_id asic_id)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\tif (!pool)\n\t\treturn NULL;\n\tif (construct(num_virtual_links, dc, pool, asic_id))\n\t\treturn &pool->base;\n\tkfree(pool);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 0}
{"code": "append_hex_escaped_character (GString *result,\n                              gunichar c)\n{\n  if (c <= 0xFF)\n    g_string_append_printf (result, \"\\\\x%02X\", c);\n  else if (c <= 0xFFFF)\n    g_string_append_printf (result, \"\\\\u%04X\", c);\n  else\n    g_string_append_printf (result, \"\\\\U%08X\", c);\n}", "target": 0}
{"code": "xfs_ioctl_setattr_xflags(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tstruct fileattr\t\t*fa)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tuint64_t\t\ti_flags2;\n\tif ((ip->i_df.if_nextents || ip->i_delayed_blks) &&\n\t    XFS_IS_REALTIME_INODE(ip) != (fa->fsx_xflags & FS_XFLAG_REALTIME))\n\t\treturn -EINVAL;\n\tif (fa->fsx_xflags & FS_XFLAG_REALTIME) {\n\t\tif (mp->m_sb.sb_rblocks == 0 || mp->m_sb.sb_rextsize == 0 ||\n\t\t    (ip->i_extsize % mp->m_sb.sb_rextsize))\n\t\t\treturn -EINVAL;\n\t}\n\tif ((fa->fsx_xflags & FS_XFLAG_REALTIME) && xfs_is_reflink_inode(ip))\n\t\tip->i_diflags2 &= ~XFS_DIFLAG2_REFLINK;\n\tif ((fa->fsx_xflags & FS_XFLAG_DAX) && xfs_is_reflink_inode(ip))\n\t\treturn -EINVAL;\n\ti_flags2 = xfs_flags2diflags2(ip, fa->fsx_xflags);\n\tif (i_flags2 && !xfs_has_v3inodes(mp))\n\t\treturn -EINVAL;\n\tip->i_diflags = xfs_flags2diflags(ip, fa->fsx_xflags);\n\tip->i_diflags2 = i_flags2;\n\txfs_diflags_to_iflags(ip, false);\n\txfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_CHG);\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\tXFS_STATS_INC(mp, xs_ig_attrchg);\n\treturn 0;\n}", "target": 0}
{"code": "deltas_head_sort(struct deltas_head *deltas, unsigned long max_serial)\n{\n\tunsigned long min_serial;\n\tstruct delta_head *cursor;\n\tarray_index i;\n\tint error;\n\tif (max_serial + 1 < deltas->len)\n\t\treturn pr_val_err(\"Deltas: Too many deltas (%zu) for serial %lu. (Negative serials not implemented.)\",\n\t\t    deltas->len, max_serial);\n\tmin_serial = max_serial + 1 - deltas->len;\n\tARRAYLIST_FOREACH(deltas, cursor, i) {\n\t\terror = swap_until_sorted(deltas->array, i, min_serial,\n\t\t    max_serial);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "TfLiteStatus Subgraph::AllocateTensors() {\n  TFLITE_SCOPED_TAGGED_DEFAULT_PROFILE(profiler_.get(), \"AllocateTensors\");\n  if (!consistent_) {\n    ReportError(\"AllocateTensors() called on inconsistent model.\");\n    return kTfLiteError;\n  }\n  TF_LITE_ENSURE_STATUS(RedoAllDelegates());\n  if (state_ != kStateUninvokable &&\n      !HasDynamicTensorImpl(context_, inputs())) {\n    if (memory_planner_ && !memory_planner_->HasNonPersistentMemory()) {\n      memory_planner_->AcquireNonPersistentMemory();\n    }\n    return kTfLiteOk;\n  }\n  SubgraphGuard guard(&context_, &is_subgraph_in_use_);\n  TF_LITE_ENSURE_OK(&context_, guard.status());\n  next_execution_plan_index_to_prepare_ = 0;\n  next_execution_plan_index_to_plan_allocation_ = 0;\n  next_original_execution_plan_index_to_prepare_ = 0;\n  if (memory_planner_) {\n    TF_LITE_ENSURE_STATUS(memory_planner_->ResetAllocations());\n  }\n  TF_LITE_ENSURE_STATUS(PrepareOpsAndTensors());\n  state_ = kStateInvokable;\n  ResetVariableTensors();\n  return kTfLiteOk;\n}", "target": 0}
{"code": "static Jsi_RC jsi_ArrayShiftCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    Jsi_Value *v;\n    Jsi_Obj *obj = _this->d.obj;\n    Jsi_ObjListifyArray(interp, obj);\n    uint n = Jsi_ObjGetLength(interp, obj);\n    assert(n <= obj->arrCnt);\n    if (n<=0) {\n        Jsi_ValueMakeUndef(interp, ret);\n    } else {\n        n--;\n        v = obj->arr[0];\n        memmove(obj->arr, obj->arr+1, n*sizeof(Jsi_Value*));\n        obj->arr[n] = NULL;\n        Jsi_ValueDup2(interp, ret, v);\n        Jsi_DecrRefCount(interp, v);\n        Jsi_ObjSetLength(interp, obj, n);\n    }\n    return JSI_OK;\n}", "target": 1}
{"code": "static int update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_stateid, nfs4_stateid *delegation, int open_flags)\n{\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tstruct nfs_delegation *deleg_cur;\n\tint ret = 0;\n\topen_flags &= (FMODE_READ|FMODE_WRITE);\n\trcu_read_lock();\n\tdeleg_cur = rcu_dereference(nfsi->delegation);\n\tif (deleg_cur == NULL)\n\t\tgoto no_delegation;\n\tspin_lock(&deleg_cur->lock);\n\tif (nfsi->delegation != deleg_cur ||\n\t    (deleg_cur->type & open_flags) != open_flags)\n\t\tgoto no_delegation_unlock;\n\tif (delegation == NULL)\n\t\tdelegation = &deleg_cur->stateid;\n\telse if (memcmp(deleg_cur->stateid.data, delegation->data, NFS4_STATEID_SIZE) != 0)\n\t\tgoto no_delegation_unlock;\n\tnfs_mark_delegation_referenced(deleg_cur);\n\t__update_open_stateid(state, open_stateid, &deleg_cur->stateid, open_flags);\n\tret = 1;\nno_delegation_unlock:\n\tspin_unlock(&deleg_cur->lock);\nno_delegation:\n\trcu_read_unlock();\n\tif (!ret && open_stateid != NULL) {\n\t\t__update_open_stateid(state, open_stateid, NULL, open_flags);\n\t\tret = 1;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static int bson_validate_string( bson *b, const unsigned char *string,\n                                 const int length, const char check_utf8, const char check_dot,\n                                 const char check_dollar ) {\n    int position = 0;\n    int sequence_length = 1;\n    if( check_dollar && string[0] == '$' ) {\n        if( !bson_string_is_db_ref( string, length ) )\n            b->err |= BSON_FIELD_INIT_DOLLAR;\n    }\n    while ( position < length ) {\n        if ( check_dot && *( string + position ) == '.' ) {\n            b->err |= BSON_FIELD_HAS_DOT;\n        }\n        if ( check_utf8 ) {\n            sequence_length = trailingBytesForUTF8[*( string + position )] + 1;\n            if ( ( position + sequence_length ) > length ) {\n                b->err |= BSON_NOT_UTF8;\n                return BSON_ERROR;\n            }\n            if ( !isLegalUTF8( string + position, sequence_length ) ) {\n                b->err |= BSON_NOT_UTF8;\n                return BSON_ERROR;\n            }\n        }\n        position += sequence_length;\n    }\n    return BSON_OK;\n}", "target": 1}
{"code": "int jp2_box_put(jp2_box_t *box, jas_stream_t *out)\n{\n\tjas_stream_t *tmpstream;\n\tbool extlen;\n\tbool dataflag;\n\ttmpstream = 0;\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (box->ops->putdata) {\n\t\t\tif ((*box->ops->putdata)(box, tmpstream)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tbox->len = jas_stream_tell(tmpstream) + JP2_BOX_HDRLEN(false);\n\t\tjas_stream_rewind(tmpstream);\n\t}\n\textlen = (box->len >= (((uint_fast64_t)1) << 32)) != 0;\n\tif (jp2_putuint32(out, extlen ? 1 : box->len)) {\n\t\tgoto error;\n\t}\n\tif (jp2_putuint32(out, box->type)) {\n\t\tgoto error;\n\t}\n\tif (extlen) {\n\t\tif (jp2_putuint64(out, box->len)) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\tif (dataflag) {\n\t\tif (jas_stream_copy(out, tmpstream, box->len - JP2_BOX_HDRLEN(false))) {\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn 0;\nerror:\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn -1;\n}", "target": 1}
{"code": "static int __init ip6_tunnel_init(void)\n{\n\tint  err;\n\tif (xfrm6_tunnel_register(&ip4ip6_handler, AF_INET)) {\n\t\tprintk(KERN_ERR \"ip6_tunnel init: can't register ip4ip6\\n\");\n\t\terr = -EAGAIN;\n\t\tgoto out;\n\t}\n\tif (xfrm6_tunnel_register(&ip6ip6_handler, AF_INET6)) {\n\t\tprintk(KERN_ERR \"ip6_tunnel init: can't register ip6ip6\\n\");\n\t\terr = -EAGAIN;\n\t\tgoto unreg_ip4ip6;\n\t}\n\terr = register_pernet_device(&ip6_tnl_net_ops);\n\tif (err < 0)\n\t\tgoto err_pernet;\n\treturn 0;\nerr_pernet:\n\txfrm6_tunnel_deregister(&ip6ip6_handler, AF_INET6);\nunreg_ip4ip6:\n\txfrm6_tunnel_deregister(&ip4ip6_handler, AF_INET);\nout:\n\treturn err;\n}", "target": 1}
{"code": "Server::clientWriteDone(const CommIoCbParams &io)\n{\n    debugs(33,5, io.conn);\n    Must(writer != nullptr);\n    writer = nullptr;\n    if (io.flag == Comm::ERR_CLOSING || !Comm::IsConnOpen(clientConnection)) {\n        debugs(33,5, io.conn << \" closing Bailout.\");\n        return;\n    }\n    Must(io.conn->fd == clientConnection->fd);\n    if (io.flag && pipeline.front())\n        pipeline.front()->initiateClose(\"write failure\");\n    afterClientWrite(io.size); \n    writeSomeData(); \n}", "target": 1}
{"code": "bool ExtractHardlink(CommandData *Cmd,wchar *NameNew,wchar *NameExisting,size_t NameExistingSize)\n{\n  SlashToNative(NameExisting,NameExisting,NameExistingSize); \n  if (!FileExist(NameExisting))\n  {\n    uiMsg(UIERROR_HLINKCREATE,NameNew);\n    uiMsg(UIERROR_NOLINKTARGET);\n    ErrHandler.SetErrorCode(RARX_CREATE);\n    return false;\n  }\n  CreatePath(NameNew,true,Cmd->DisableNames);\n#ifdef _WIN_ALL\n  bool Success=CreateHardLink(NameNew,NameExisting,NULL)!=0;\n  if (!Success)\n  {\n    uiMsg(UIERROR_HLINKCREATE,NameNew);\n    ErrHandler.SysErrMsg();\n    ErrHandler.SetErrorCode(RARX_CREATE);\n  }\n  return Success;\n#elif defined(_UNIX)\n  char NameExistingA[NM],NameNewA[NM];\n  WideToChar(NameExisting,NameExistingA,ASIZE(NameExistingA));\n  WideToChar(NameNew,NameNewA,ASIZE(NameNewA));\n  bool Success=link(NameExistingA,NameNewA)==0;\n  if (!Success)\n  {\n    uiMsg(UIERROR_HLINKCREATE,NameNew);\n    ErrHandler.SysErrMsg();\n    ErrHandler.SetErrorCode(RARX_CREATE);\n  }\n  return Success;\n#else\n  return false;\n#endif\n}", "target": 1}
{"code": "static int cp2112_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t\tunsigned offset, int value)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tunsigned long flags;\n\tint ret;\n\tspin_lock_irqsave(&dev->lock, flags);\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_CONFIG_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO config: %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\tbuf[1] |= 1 << offset;\n\tbuf[2] = gpio_push_pull;\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"error setting GPIO config: %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\tcp2112_gpio_set(chip, offset, value);\n\treturn 0;\nfail:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\treturn ret < 0 ? ret : -EIO;\n}", "target": 1}
{"code": "void LayerTilerChromium::growLayerToContain(const IntRect& contentRect)\n{\n    IntRect layerRect = contentRectToLayerRect(contentRect);\n    IntSize layerSize = IntSize(layerRect.maxX(), layerRect.maxY());\n    IntSize newSize = layerSize.expandedTo(m_layerSize);\n    resizeLayer(newSize);\n}", "target": 0}
{"code": "static void my_output_message( j_common_ptr ) {} ", "target": 0}
{"code": "snmp_ber_decode_type(unsigned char *buff, uint32_t *buff_len, uint8_t *type)\n{\n  if(*buff_len == 0) {\n    return NULL;\n  }\n  *type = *buff++;\n  (*buff_len)--;\n  return buff;\n}", "target": 1}
{"code": "comics_decompress_temp_dir (const gchar *command_decompress_tmp,\n\t\t\t    const gchar *command, \n\t\t\t    GError      **error)\n{\n\tgboolean success;\n\tgchar *std_out, *basename;\n\tGError *err = NULL;\n\tgint retval;\n\tsuccess = g_spawn_command_line_sync (command_decompress_tmp, &std_out, \n\t\t\t\t\t     NULL, &retval, &err);\n\tbasename = g_path_get_basename (command);\n\tif (!success) {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR, \n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"Error launching the command “%s” in order to \"\n\t\t\t     \"decompress the comic book: %s\"),\n\t\t\t     basename,\n\t\t\t     err->message);\n\t\tg_error_free (err);\n\t} else if (WIFEXITED (retval)) {\n\t\tif (WEXITSTATUS (retval) == EXIT_SUCCESS) {\n\t\t\tg_free (std_out);\n\t\t\tg_free (basename);\n\t\t\treturn TRUE;\n\t\t} else {\n\t\t\tg_set_error (error,\n\t\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t\t     _(\"The command “%s” failed at \"\n\t\t\t\t     \"decompressing the comic book.\"),\n\t\t\t\t     basename);\n\t\t\tg_free (std_out);\n\t\t}\n\t} else {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"The command “%s” did not end normally.\"),\n\t\t\t     basename);\n\t\tg_free (std_out);\n\t}\n\tg_free (basename);\n\treturn FALSE;\n}", "target": 1}
{"code": "static inline bool is_exception(u32 intr_info)\n{\n\treturn (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VALID_MASK))\n\t\t== (INTR_TYPE_HARD_EXCEPTION | INTR_INFO_VALID_MASK);\n}", "target": 1}
{"code": "need_reloc_mappable(struct drm_i915_gem_object *obj)\n{\n\tstruct drm_i915_gem_exec_object2 *entry = obj->exec_entry;\n\treturn entry->relocation_count && !use_cpu_reloc(obj);\n}", "target": 0}
{"code": "static void _php_pgsql_notice_handler(void *resource_id, const char *message)\n{\n\tphp_pgsql_notice *notice;\n\tTSRMLS_FETCH();\n\tif (! PGG(ignore_notices)) {\n\t\tnotice = (php_pgsql_notice *)emalloc(sizeof(php_pgsql_notice));\n\t\tnotice->message = _php_pgsql_trim_message(message, (int *)&notice->len);\n\t\tif (PGG(log_notices)) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"%s\", notice->message);\n\t\t}\n\t\tzend_hash_index_update(&PGG(notices), (ulong)resource_id, (void **)&notice, sizeof(php_pgsql_notice *), NULL);\n\t}\n}", "target": 0}
{"code": "gx_fill_edgebuffer_app(gx_device       * pdev,\n                 const gx_device_color * pdevc,\n                       gx_edgebuffer   * edgebuffer,\n                       int               log_op)\n{\n    int i, code;\n    for (i=0; i < edgebuffer->height; i++) {\n        int *row    = &edgebuffer->table[edgebuffer->index[i]];\n        int  rowlen = *row++;\n        int  left, right;\n        while (rowlen > 0) {\n            left  = *row++;\n            right = *row++;\n            left  = fixed2int(left);\n            right = fixed2int(right + fixed_1 - 1);\n            rowlen -= 2;\n            right -= left;\n            if (right > 0) {\n                if (log_op < 0)\n                    code = dev_proc(pdev, fill_rectangle)(pdev, left, edgebuffer->base+i, right, 1, pdevc->colors.pure);\n                else\n                    code = gx_fill_rectangle_device_rop(left, edgebuffer->base+i, right, 1, pdevc, pdev, (gs_logical_operation_t)log_op);\n                if (code < 0)\n                    return code;\n            }\n        }\n    }\n    return 0;\n}", "target": 0}
{"code": "escape(unsigned char ch, char *buf)\n{\n    const int len = ch < 0100 ? (ch < 010 ? 3 : 4) : 5;\n    switch (len) {\n    case 5:\n\tbuf[4] = (ch & 7) + '0';\n\tch >>= 3;\n\tFALLTHROUGH;\n    case 4:\n\tbuf[3] = (ch & 7) + '0';\n\tch >>= 3;\n\tFALLTHROUGH;\n    case 3:\n\tbuf[2] = (ch & 7) + '0';\n\tbuf[1] = '0';\n\tbuf[0] = '#';\n\tbreak;\n    }\n    buf[len] = '\\0';\n    return len;\n}", "target": 0}
{"code": "kdc_process_for_user(kdc_realm_t *kdc_active_realm,\n                     krb5_pa_data *pa_data,\n                     krb5_keyblock *tgs_session,\n                     krb5_pa_s4u_x509_user **s4u_x509_user,\n                     const char **status)\n{\n    krb5_error_code             code;\n    krb5_pa_for_user            *for_user;\n    krb5_data                   req_data;\n    req_data.length = pa_data->length;\n    req_data.data = (char *)pa_data->contents;\n    code = decode_krb5_pa_for_user(&req_data, &for_user);\n    if (code)\n        return code;\n    code = verify_for_user_checksum(kdc_context, tgs_session, for_user);\n    if (code) {\n        *status = \"INVALID_S4U2SELF_CHECKSUM\";\n        krb5_free_pa_for_user(kdc_context, for_user);\n        return code;\n    }\n    *s4u_x509_user = calloc(1, sizeof(krb5_pa_s4u_x509_user));\n    if (*s4u_x509_user == NULL) {\n        krb5_free_pa_for_user(kdc_context, for_user);\n        return ENOMEM;\n    }\n    (*s4u_x509_user)->user_id.user = for_user->user;\n    for_user->user = NULL;\n    krb5_free_pa_for_user(kdc_context, for_user);\n    return 0;\n}", "target": 1}
{"code": "static char *get_cert_prompt(TALLOC_CTX *mem_ctx,\n                             struct cert_auth_info *cert_info)\n{\n    int ret;\n    struct sss_certmap_ctx *ctx = NULL;\n    unsigned char *der = NULL;\n    size_t der_size;\n    char *prompt = NULL;\n    char *filter = NULL;\n    char **domains = NULL;\n    ret = sss_certmap_init(mem_ctx, NULL, NULL, &ctx);\n    if (ret != 0) {\n        DEBUG(SSSDBG_OP_FAILURE, \"sss_certmap_init failed.\\n\");\n        return NULL;\n    }\n    ret = sss_certmap_add_rule(ctx, 10, \"KRB5:<ISSUER>.*\",\n                               \"LDAP:{subject_dn!nss}\", NULL);\n    if (ret != 0) {\n        DEBUG(SSSDBG_OP_FAILURE, \"sss_certmap_add_rule failed.\\n\");\n        goto done;\n    }\n    der = sss_base64_decode(mem_ctx, sss_cai_get_cert(cert_info), &der_size);\n    if (der == NULL) {\n        DEBUG(SSSDBG_OP_FAILURE, \"sss_base64_decode failed.\\n\");\n        goto done;\n    }\n    ret = sss_certmap_get_search_filter(ctx, der, der_size, &filter, &domains);\n    if (ret != 0) {\n        DEBUG(SSSDBG_OP_FAILURE, \"sss_certmap_get_search_filter failed.\\n\");\n        goto done;\n    }\n    prompt = talloc_asprintf(mem_ctx, \"%s\\n%s\", sss_cai_get_label(cert_info),\n                                                filter);\n    if (prompt == NULL) {\n        DEBUG(SSSDBG_OP_FAILURE, \"talloc_strdup failed.\\n\");\n    }\ndone:\n    sss_certmap_free_filter_and_domains(filter, domains);\n    sss_certmap_free_ctx(ctx);\n    talloc_free(der);\n    return prompt;\n}", "target": 1}
{"code": "static int orinoco_ioctl_set_auth(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\thermes_t *hw = &priv->hw;\n\tstruct iw_param *param = &wrqu->param;\n\tunsigned long flags;\n\tint ret = -EINPROGRESS;\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\tswitch (param->flags & IW_AUTH_INDEX) {\n\tcase IW_AUTH_WPA_VERSION:\n\tcase IW_AUTH_CIPHER_PAIRWISE:\n\tcase IW_AUTH_CIPHER_GROUP:\n\tcase IW_AUTH_RX_UNENCRYPTED_EAPOL:\n\tcase IW_AUTH_PRIVACY_INVOKED:\n\tcase IW_AUTH_DROP_UNENCRYPTED:\n\t\tbreak;\n\tcase IW_AUTH_KEY_MGMT:\n\t\tpriv->key_mgmt = param->value;\n\t\tbreak;\n\tcase IW_AUTH_TKIP_COUNTERMEASURES:\n\t\tif (param->value) {\n\t\t\tpriv->tkip_cm_active = 1;\n\t\t\tret = hermes_enable_port(hw, 0);\n\t\t} else {\n\t\t\tpriv->tkip_cm_active = 0;\n\t\t\tret = hermes_disable_port(hw, 0);\n\t\t}\n\t\tbreak;\n\tcase IW_AUTH_80211_AUTH_ALG:\n\t\tif (param->value & IW_AUTH_ALG_SHARED_KEY)\n\t\t\tpriv->wep_restrict = 1;\n\t\telse if (param->value & IW_AUTH_ALG_OPEN_SYSTEM)\n\t\t\tpriv->wep_restrict = 0;\n\t\telse\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\tcase IW_AUTH_WPA_ENABLED:\n\t\tif (priv->has_wpa) {\n\t\t\tpriv->wpa_enabled = param->value ? 1 : 0;\n\t\t} else {\n\t\t\tif (param->value)\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\tpriv->wpa_enabled = 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t}\n\torinoco_unlock(priv, &flags);\n\treturn ret;\n}", "target": 1}
{"code": "SPL_METHOD(Array, valid)\n{\n\tzval *object = getThis();\n\tspl_array_object *intern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);\n\tHashTable *aht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\tif (spl_array_object_verify_pos(intern, aht TSRMLS_CC) == FAILURE) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_BOOL(zend_hash_has_more_elements_ex(aht, &intern->pos) == SUCCESS);\n\t}\n}", "target": 0}
{"code": "static void timelib_eat_until_separator(char **ptr)\n{\n\twhile (strchr(\" \\t.,:;/-0123456789\", **ptr) == NULL) {\n\t\t++*ptr;\n\t}\n}", "target": 0}
{"code": "AutoFillManager::AutoFillManager(TabContents* tab_contents,\n                                 PersonalDataManager* personal_data)\n    : tab_contents_(tab_contents),\n      personal_data_(personal_data),\n      download_manager_(NULL) {\n  DCHECK(tab_contents);\n}", "target": 0}
{"code": "static void sanitize_string(std::string &str)\n{\n\tstr.erase(std::remove(str.begin(), str.end(), DESERIALIZE_START), str.end());\n\tstr.erase(std::remove(str.begin(), str.end(), DESERIALIZE_KV_DELIM), str.end());\n\tstr.erase(std::remove(str.begin(), str.end(), DESERIALIZE_PAIR_DELIM), str.end());\n}", "target": 0}
{"code": "static int kvm_vcpu_initialized(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.target >= 0;\n}", "target": 0}
{"code": "decode_rt_routing_info(netdissect_options *ndo,\n                       const u_char *pptr, char *buf, u_int buflen)\n{\n\tuint8_t route_target[8];\n\tu_int plen;\n\tND_TCHECK(pptr[0]);\n\tplen = pptr[0];   \n\tif (0 == plen) {\n\t\tsnprintf(buf, buflen, \"default route target\");\n\t\treturn 1;\n\t}\n\tif (32 > plen)\n\t\treturn -1;\n        plen-=32; \n\tif (64 < plen)\n\t\treturn -1;\n\tmemset(&route_target, 0, sizeof(route_target));\n\tND_TCHECK2(pptr[1], (plen + 7) / 8);\n\tmemcpy(&route_target, &pptr[1], (plen + 7) / 8);\n\tif (plen % 8) {\n\t\t((u_char *)&route_target)[(plen + 7) / 8 - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n\tsnprintf(buf, buflen, \"origin AS: %s, route target %s\",\n\t    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(pptr+1)),\n\t    bgp_vpn_rd_print(ndo, (u_char *)&route_target));\n\treturn 5 + (plen + 7) / 8;\ntrunc:\n\treturn -2;\n}", "target": 1}
{"code": "struct pico_socket *pico_tcp_open(struct pico_stack *S, uint16_t family)\n{\n    struct pico_socket_tcp *t = PICO_ZALLOC(sizeof(struct pico_socket_tcp));\n    if (!t)\n        return NULL;\n    t->sock.stack = S;\n    t->sock.timestamp = TCP_TIME;\n    pico_socket_set_family(&t->sock, family);\n    t->mss = (uint16_t)(pico_socket_get_mss(&t->sock) - PICO_SIZE_TCPHDR);\n    t->tcpq_in.pool.root = t->tcpq_hold.pool.root = t->tcpq_out.pool.root = &LEAF;\n    t->tcpq_hold.pool.compare = t->tcpq_out.pool.compare = segment_compare;\n    t->tcpq_in.pool.compare = input_segment_compare;\n    t->tcpq_in.max_size = PICO_DEFAULT_SOCKETQ;\n    t->tcpq_out.max_size = PICO_DEFAULT_SOCKETQ;\n    t->tcpq_hold.max_size = 2u * t->mss;\n    rto_set(t, PICO_TCP_RTO_MIN);\n    t->sock.opt_flags |= (1 << PICO_SOCKET_OPT_TCPNODELAY);\n    t->linger_timeout = PICO_SOCKET_LINGER_TIMEOUT;\n#ifdef PICO_TCP_SUPPORT_SOCKET_STATS\n    if (!pico_timer_add(t->sock.stack, 2000, sock_stats, t)) {\n        tcp_dbg(\"TCP: Failed to start socket statistics timer\\n\");\n        PICO_FREE(t);\n        return NULL;\n    }\n#endif\n    t->keepalive_tmr = pico_timer_add(t->sock.stack, 1000, pico_tcp_keepalive, t);\n    if (!t->keepalive_tmr) {\n        tcp_dbg(\"TCP: Failed to start keepalive timer\\n\");\n        PICO_FREE(t);\n        return NULL;\n    }\n    tcp_set_space(t);\n    return &t->sock;\n}", "target": 1}
{"code": "static int _anetTcpServer(char *err, int port, char *bindaddr, int af, int backlog)\n{\n    int s = -1, rv;\n    char _port[6];  \n    struct addrinfo hints, *servinfo, *p;\n    snprintf(_port,6,\"%d\",port);\n    memset(&hints,0,sizeof(hints));\n    hints.ai_family = af;\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_flags = AI_PASSIVE;    \n    if (bindaddr && !strcmp(\"*\", bindaddr))\n        bindaddr = NULL;\n    if (af == AF_INET6 && bindaddr && !strcmp(\"::*\", bindaddr))\n        bindaddr = NULL;\n    if ((rv = getaddrinfo(bindaddr,_port,&hints,&servinfo)) != 0) {\n        anetSetError(err, \"%s\", gai_strerror(rv));\n        return ANET_ERR;\n    }\n    for (p = servinfo; p != NULL; p = p->ai_next) {\n        if ((s = socket(p->ai_family,p->ai_socktype,p->ai_protocol)) == -1)\n            continue;\n        if (af == AF_INET6 && anetV6Only(err,s) == ANET_ERR) goto error;\n        if (anetSetReuseAddr(err,s) == ANET_ERR) goto error;\n        if (anetListen(err,s,p->ai_addr,p->ai_addrlen,backlog) == ANET_ERR) s = ANET_ERR;\n        goto end;\n    }\n    if (p == NULL) {\n        anetSetError(err, \"unable to bind socket, errno: %d\", errno);\n        goto error;\n    }\nerror:\n    if (s != -1) close(s);\n    s = ANET_ERR;\nend:\n    freeaddrinfo(servinfo);\n    return s;\n}", "target": 1}
{"code": "int fit_config_verify_required_sigs(const void *fit, int conf_noffset,\n\t\t\t\t    const void *sig_blob)\n{\n\tint noffset;\n\tint sig_node;\n\tint verified = 0;\n\tint reqd_sigs = 0;\n\tbool reqd_policy_all = true;\n\tconst char *reqd_mode;\n\tsig_node = fdt_subnode_offset(sig_blob, 0, FIT_SIG_NODENAME);\n\tif (sig_node < 0) {\n\t\tdebug(\"%s: No signature node found: %s\\n\", __func__,\n\t\t      fdt_strerror(sig_node));\n\t\treturn 0;\n\t}\n\treqd_mode = fdt_getprop(sig_blob, sig_node, \"required-mode\", NULL);\n\tif (reqd_mode && !strcmp(reqd_mode, \"any\"))\n\t\treqd_policy_all = false;\n\tdebug(\"%s: required-mode policy set to '%s'\\n\", __func__,\n\t      reqd_policy_all ? \"all\" : \"any\");\n\tfdt_for_each_subnode(noffset, sig_blob, sig_node) {\n\t\tconst char *required;\n\t\tint ret;\n\t\trequired = fdt_getprop(sig_blob, noffset, FIT_KEY_REQUIRED,\n\t\t\t\t       NULL);\n\t\tif (!required || strcmp(required, \"conf\"))\n\t\t\tcontinue;\n\t\treqd_sigs++;\n\t\tret = fit_config_verify_sig(fit, conf_noffset, sig_blob,\n\t\t\t\t\t    noffset);\n\t\tif (ret) {\n\t\t\tif (reqd_policy_all) {\n\t\t\t\tprintf(\"Failed to verify required signature '%s'\\n\",\n\t\t\t\t       fit_get_name(sig_blob, noffset, NULL));\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else {\n\t\t\tverified++;\n\t\t\tif (!reqd_policy_all)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (reqd_sigs && !verified) {\n\t\tprintf(\"Failed to verify 'any' of the required signature(s)\\n\");\n\t\treturn -EPERM;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void OfflineAudioDestinationHandler::DoOfflineRendering() {\n  DCHECK(!IsMainThread());\n  unsigned number_of_channels;\n  Vector<float*> destinations;\n  {\n    bool has_lock = ProcessHeap::CrossThreadPersistentMutex().TryLock();\n    if (!has_lock) {\n      render_thread_task_runner_->PostTask(\n          FROM_HERE,\n          WTF::Bind(&OfflineAudioDestinationHandler::DoOfflineRendering,\n                    WrapRefCounted(this)));\n      return;\n    }\n    number_of_channels = render_target_->numberOfChannels();\n    destinations.ReserveInitialCapacity(number_of_channels);\n    for (unsigned i = 0; i < number_of_channels; ++i)\n      destinations.push_back(render_target_->getChannelData(i).View()->Data());\n    ProcessHeap::CrossThreadPersistentMutex().unlock();\n  }\n  while (frames_to_process_ > 0) {\n    if (RenderIfNotSuspended(nullptr, render_bus_.get(),\n                             audio_utilities::kRenderQuantumFrames))\n      return;\n    uint32_t frames_available_to_copy =\n        std::min(frames_to_process_, audio_utilities::kRenderQuantumFrames);\n    for (unsigned channel_index = 0; channel_index < number_of_channels;\n         ++channel_index) {\n      const float* source = render_bus_->Channel(channel_index)->Data();\n      memcpy(destinations[channel_index] + frames_processed_, source,\n             sizeof(float) * frames_available_to_copy);\n    }\n    frames_processed_ += frames_available_to_copy;\n    DCHECK_GE(frames_to_process_, frames_available_to_copy);\n    frames_to_process_ -= frames_available_to_copy;\n  }\n  DCHECK_EQ(frames_to_process_, 0u);\n  FinishOfflineRendering();\n}", "target": 0}
{"code": "int __init acpi_debugger_init(void)\n{\n\tmutex_init(&acpi_debugger.lock);\n\tacpi_debugger_initialized = true;\n\treturn 0;\n}", "target": 0}
{"code": "static inline int timer_overrun_to_int(struct k_itimer *timr, int baseval)\n{\n\ts64 sum = timr->it_overrun_last + (s64)baseval;\n\treturn sum > (s64)INT_MAX ? INT_MAX : (int)sum;\n}", "target": 0}
{"code": "static inline void *nvme_addr_to_cmb(NvmeCtrl *n, hwaddr addr)\n{\n    hwaddr base = n->params.legacy_cmb ? n->cmb.mem.addr : n->cmb.cba;\n    return &n->cmb.buf[addr - base];\n}", "target": 0}
{"code": "int main()\n{\n\tgdImagePtr im;\n\tFILE *fp;\n\tchar path[1024];\n\tsprintf(path, \"%s/gd2/invalid_neg_size.gd2\", GDTEST_TOP_DIR);\n\tfp = fopen(path, \"rb\");\n\tif (!fp) {\n\t\tprintf(\"failed, cannot open file\\n\");\n\t\treturn 1;\n\t}\n\tim = gdImageCreateFromGd2(fp);\n\tfclose(fp);\n\treturn im == NULL ? 0 : 1;\n}", "target": 0}
{"code": "static int aac_compat_ioctl(struct scsi_device *sdev, int cmd, void __user *arg)\n{\n\tstruct aac_dev *dev = (struct aac_dev *)sdev->host->hostdata;\n\tif (!capable(CAP_SYS_RAWIO))\n\t\treturn -EPERM;\n\treturn aac_compat_do_ioctl(dev, cmd, (unsigned long)arg);\n}", "target": 0}
{"code": "void test_openat(const char *path)\n{\n\tchar *d = strdupa(path), *f, *tmpname;\n\tint fd, fd2;\n\tf = basename(d);\n\td = dirname(d);\n\tfd = open(d, O_RDONLY);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Error in openat test: could not open parent dir\\n\");\n\t\tfprintf(stderr, \"(this is expected on the second run)\\n\");\n\t\treturn;\n\t}\n\tfd2 = openat(fd, f, O_RDONLY);\n\tif (fd2 >= 0 || errno != ENOENT) {\n\t\tfprintf(stderr, \"leak at openat of %s\\n\", f);\n\t\texit(1);\n\t}\n\tsize_t len = strlen(path) + strlen(\"/cgroup.procs\") + 1;\n\ttmpname = alloca(len);\n\tsnprintf(tmpname, len, \"%s/cgroup.procs\", f);\n\tfd2 = openat(fd, tmpname, O_RDONLY);\n\tif (fd2 >= 0 || errno != ENOENT) {\n\t\tfprintf(stderr, \"leak at openat of %s\\n\", tmpname);\n\t\texit(1);\n\t}\n\tclose(fd);\n}", "target": 0}
{"code": "int dns_HTTPS_add_alpn(struct dns_rr_nested *svcparam, const char *alpn, int alpn_len)\n{\n\tif (_dns_left_len(&svcparam->context) < 2 + 2 + alpn_len) {\n\t\treturn -1;\n\t}\n\tunsigned short value = DNS_HTTPS_T_ALPN;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\tvalue = alpn_len;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\tdns_add_rr_nested_memcpy(svcparam, alpn, alpn_len);\n\treturn 0;\n}", "target": 0}
{"code": "static int rose_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\tstruct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tsize_t copied;\n\tunsigned char *asmptr;\n\tstruct sk_buff *skb;\n\tint n, er, qbit;\n\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\treturn -ENOTCONN;\n\tif ((skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT, flags & MSG_DONTWAIT, &er)) == NULL)\n\t\treturn er;\n\tqbit = (skb->data[0] & ROSE_Q_BIT) == ROSE_Q_BIT;\n\tskb_pull(skb, ROSE_MIN_LEN);\n\tif (rose->qbitincl) {\n\t\tasmptr  = skb_push(skb, 1);\n\t\t*asmptr = qbit;\n\t}\n\tskb_reset_transport_header(skb);\n\tcopied     = skb->len;\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\tskb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (msg->msg_name) {\n\t\tstruct sockaddr_rose *srose;\n\t\tmemset(msg->msg_name, 0, sizeof(struct full_sockaddr_rose));\n\t\tsrose = msg->msg_name;\n\t\tsrose->srose_family = AF_ROSE;\n\t\tsrose->srose_addr   = rose->dest_addr;\n\t\tsrose->srose_call   = rose->dest_call;\n\t\tsrose->srose_ndigis = rose->dest_ndigis;\n\t\tif (msg->msg_namelen >= sizeof(struct full_sockaddr_rose)) {\n\t\t\tstruct full_sockaddr_rose *full_srose = (struct full_sockaddr_rose *)msg->msg_name;\n\t\t\tfor (n = 0 ; n < rose->dest_ndigis ; n++)\n\t\t\t\tfull_srose->srose_digis[n] = rose->dest_digis[n];\n\t\t\tmsg->msg_namelen = sizeof(struct full_sockaddr_rose);\n\t\t} else {\n\t\t\tif (rose->dest_ndigis >= 1) {\n\t\t\t\tsrose->srose_ndigis = 1;\n\t\t\t\tsrose->srose_digi = rose->dest_digis[0];\n\t\t\t}\n\t\t\tmsg->msg_namelen = sizeof(struct sockaddr_rose);\n\t\t}\n\t}\n\tskb_free_datagram(sk, skb);\n\treturn copied;\n}", "target": 0}
{"code": "static int ida_checks(void)\n{\n\tIDA_BUG_ON(&ida, !ida_is_empty(&ida));\n\tida_check_alloc(&ida);\n\tida_check_destroy(&ida);\n\tida_check_leaf(&ida, 0);\n\tida_check_leaf(&ida, 1024);\n\tida_check_leaf(&ida, 1024 * 64);\n\tida_check_max(&ida);\n\tida_check_conv(&ida);\n\tida_check_bad_free(&ida);\n\tprintk(\"IDA: %u of %u tests passed\\n\", tests_passed, tests_run);\n\treturn (tests_run != tests_passed) ? 0 : -EINVAL;\n}", "target": 0}
{"code": "filesystem_create_completed_cb (DBusGMethodInvocation *context,\n                                Device *device,\n                                gboolean job_was_cancelled,\n                                int status,\n                                const char *stderr,\n                                const char *stdout,\n                                gpointer user_data)\n{\n  MkfsData *data = user_data;\n  device_generate_kernel_change_event (device);\n  if (WEXITSTATUS (status) == 0 && !job_was_cancelled)\n    {\n      if (data->hook_func != NULL)\n        data->hook_func (context, device, TRUE, data->hook_user_data);\n      else\n        dbus_g_method_return (context);\n    }\n  else\n    {\n      if (job_was_cancelled)\n        {\n          throw_error (context, ERROR_CANCELLED, \"Job was cancelled\");\n        }\n      else if (WEXITSTATUS (status) == 3)\n        {\n          throw_error (context,\n                       ERROR_FILESYSTEM_TOOLS_MISSING,\n                       \"Error creating file system: Cannot run mkfs: %s\",\n                       stderr);\n        }\n      else\n        {\n          throw_error (context,\n                       ERROR_FAILED,\n                       \"Error creating file system: helper exited with exit code %d: %s\\n%s\",\n                       WEXITSTATUS (status),\n                       stderr,\n                       stdout);\n        }\n      if (data->hook_func != NULL)\n        data->hook_func (context, device, FALSE, data->hook_user_data);\n    }\n}", "target": 0}
{"code": "char *LibRaw_file_datastream::gets(char *str, int sz)\n{\n  if(sz<1) return NULL;\n  LR_STREAM_CHK();\n  std::istream is(f.get());\n  is.getline(str, sz);\n  if (is.fail())\n    return 0;\n  return str;\n}", "target": 0}
{"code": "static void snd_usb_mixer_free(struct usb_mixer_interface *mixer)\n{\n\tsnd_usb_mixer_disconnect(mixer);\n\tkfree(mixer->id_elems);\n\tif (mixer->urb) {\n\t\tkfree(mixer->urb->transfer_buffer);\n\t\tusb_free_urb(mixer->urb);\n\t}\n\tusb_free_urb(mixer->rc_urb);\n\tkfree(mixer->rc_setup_packet);\n\tkfree(mixer);\n}", "target": 0}
{"code": "void test_chown(const char *path)\n{\n\tif (chown(path, 0, 0) == 0) {\n\t\tfprintf(stderr, \"leak at chown of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at chown of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "void WebContentsImpl::OnJSOutOfMemory() {\n  if (delegate_)\n    delegate_->JSOutOfMemory(this);\n}", "target": 0}
{"code": "le64addr_string(netdissect_options *ndo, const u_char *ep)\n{\n\tconst unsigned int len = 8;\n\tregister u_int i;\n\tregister char *cp;\n\tregister struct enamemem *tp;\n\tchar buf[BUFSIZE];\n\ttp = lookup_bytestring(ndo, ep, len);\n\tif (tp->e_name)\n\t\treturn (tp->e_name);\n\tcp = buf;\n\tfor (i = len; i > 0 ; --i) {\n\t\t*cp++ = hex[*(ep + i - 1) >> 4];\n\t\t*cp++ = hex[*(ep + i - 1) & 0xf];\n\t\t*cp++ = ':';\n\t}\n\tcp --;\n\t*cp = '\\0';\n\ttp->e_name = strdup(buf);\n\tif (tp->e_name == NULL)\n\t\t(*ndo->ndo_error)(ndo, \"le64addr_string: strdup(buf)\");\n\treturn (tp->e_name);\n}", "target": 1}
{"code": "void kvm_lapic_sync_to_vapic(struct kvm_vcpu *vcpu)\n{\n\tu32 data, tpr;\n\tint max_irr, max_isr;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tvoid *vapic;\n\tapic_sync_pv_eoi_to_guest(vcpu, apic);\n\tif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\n\t\treturn;\n\ttpr = kvm_apic_get_reg(apic, APIC_TASKPRI) & 0xff;\n\tmax_irr = apic_find_highest_irr(apic);\n\tif (max_irr < 0)\n\t\tmax_irr = 0;\n\tmax_isr = apic_find_highest_isr(apic);\n\tif (max_isr < 0)\n\t\tmax_isr = 0;\n\tdata = (tpr & 0xff) | ((max_isr & 0xf0) << 8) | (max_irr << 24);\n\tvapic = kmap_atomic(vcpu->arch.apic->vapic_page);\n\t*(u32 *)(vapic + offset_in_page(vcpu->arch.apic->vapic_addr)) = data;\n\tkunmap_atomic(vapic);\n}", "target": 1}
{"code": "static void sysfs_slab_remove(struct kmem_cache *s)\n{\n\tkobject_uevent(&s->kobj, KOBJ_REMOVE);\n\tkobject_del(&s->kobj);\n\tkobject_put(&s->kobj);\n}", "target": 0}
{"code": "test_keys ( ELG_secret_key *sk, unsigned int nbits, int nodie )\n{\n  ELG_public_key pk;\n  gcry_mpi_t test = gcry_mpi_new ( 0 );\n  gcry_mpi_t out1_a = gcry_mpi_new ( nbits );\n  gcry_mpi_t out1_b = gcry_mpi_new ( nbits );\n  gcry_mpi_t out2 = gcry_mpi_new ( nbits );\n  int failed = 0;\n  pk.p = sk->p;\n  pk.g = sk->g;\n  pk.y = sk->y;\n  gcry_mpi_randomize ( test, nbits, GCRY_WEAK_RANDOM );\n  do_encrypt ( out1_a, out1_b, test, &pk );\n  decrypt ( out2, out1_a, out1_b, sk );\n  if ( mpi_cmp( test, out2 ) )\n    failed |= 1;\n  sign ( out1_a, out1_b, test, sk );\n  if ( !verify( out1_a, out1_b, test, &pk ) )\n    failed |= 2;\n  gcry_mpi_release ( test );\n  gcry_mpi_release ( out1_a );\n  gcry_mpi_release ( out1_b );\n  gcry_mpi_release ( out2 );\n  if (failed && !nodie)\n    log_fatal (\"Elgamal test key for %s %s failed\\n\",\n               (failed & 1)? \"encrypt+decrypt\":\"\",\n               (failed & 2)? \"sign+verify\":\"\");\n  if (failed && DBG_CIPHER)\n    log_debug (\"Elgamal test key for %s %s failed\\n\",\n               (failed & 1)? \"encrypt+decrypt\":\"\",\n               (failed & 2)? \"sign+verify\":\"\");\n  return failed;\n}", "target": 0}
{"code": "iakerb_gss_import_sec_context(OM_uint32 *minor_status,\n                              gss_buffer_t interprocess_token,\n                              gss_ctx_id_t *context_handle)\n{\n    OM_uint32 maj, tmpmin;\n    krb5_error_code code;\n    gss_ctx_id_t gssc;\n    krb5_gss_ctx_id_t kctx;\n    iakerb_ctx_id_t ctx;\n    maj = krb5_gss_import_sec_context(minor_status, interprocess_token, &gssc);\n    if (maj != GSS_S_COMPLETE)\n        return maj;\n    kctx = (krb5_gss_ctx_id_t)gssc;\n    if (!kctx->established) {\n        krb5_gss_delete_sec_context(&tmpmin, &gssc, GSS_C_NO_BUFFER);\n        return GSS_S_FAILURE;\n    }\n    code = iakerb_alloc_context(&ctx, kctx->initiate);\n    if (code != 0) {\n        krb5_gss_delete_sec_context(&tmpmin, &gssc, GSS_C_NO_BUFFER);\n        *minor_status = code;\n        return GSS_S_FAILURE;\n    }\n    ctx->gssc = gssc;\n    ctx->established = 1;\n    *context_handle = (gss_ctx_id_t)ctx;\n    return GSS_S_COMPLETE;\n}", "target": 0}
{"code": "static int nested_vmx_check_permission(struct kvm_vcpu *vcpu)\n{\n\tif (vmx_get_cpl(vcpu)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 0;\n\t}\n\tif (!to_vmx(vcpu)->nested.vmxon) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "WebContents* WebContents::FromRenderViewHost(const RenderViewHost* rvh) {\n  return rvh->GetDelegate()->GetAsWebContents();\n}", "target": 0}
{"code": "match_to_s(VALUE match)\n{\n    VALUE str = rb_reg_last_match(match);\n    match_check(match);\n    if (NIL_P(str)) str = rb_str_new(0,0);\n    if (OBJ_TAINTED(match)) OBJ_TAINT(str);\n    if (OBJ_TAINTED(RMATCH(match)->str)) OBJ_TAINT(str);\n    return str;\n}", "target": 0}
{"code": "int luaopen_x509(lua_State *L)\n{\n  auxiliar_newclass(L, \"openssl.x509\", x509_funcs);\n  lua_newtable(L);\n  luaL_setfuncs(L, R, 0);\n  openssl_register_xname(L);\n  lua_setfield(L, -2, \"name\");\n  openssl_register_xattribute(L);\n  lua_setfield(L, -2, \"attribute\");\n  openssl_register_xextension(L);\n  lua_setfield(L, -2, \"extension\");\n  openssl_register_xstore(L);\n  lua_setfield(L, -2, \"store\");\n  openssl_register_xalgor(L);\n  lua_setfield(L, -2, \"algor\");\n  luaopen_x509_req(L);\n  lua_setfield(L, -2, \"req\");\n  luaopen_x509_crl(L);\n  lua_setfield(L, -2, \"crl\");\n  lua_pushliteral(L, \"version\");    \n  lua_pushliteral(L, MYVERSION);\n  lua_settable(L, -3);\n#if OPENSSL_VERSION_NUMBER > 0x10002000L\n  lua_pushliteral(L, \"check_flag\");\n  lua_newtable(L);\n  auxiliar_enumerate(L, -1, check_flags_const);\n  lua_settable(L, -3);\n#endif\n  return 1;\n}", "target": 0}
{"code": "BGD_DECLARE(void) gdImageFilledRectangle (gdImagePtr im, int x1, int y1, int x2, int y2,\n\t\tint color)\n{\n\t_gdImageFilledVRectangle(im, x1, y1, x2, y2, color);\n}", "target": 0}
{"code": "void QuickOpen::Load(uint64 BlockPos)\n{\n  if (!Loaded) \n  {\n    SeekPos=Arc->Tell();\n    UnsyncSeekPos=false;\n    SaveFilePos SavePos(*Arc);\n    Arc->Seek(BlockPos,SEEK_SET);\n    if (Arc->ReadHeader()==0 || Arc->GetHeaderType()!=HEAD_SERVICE ||\n        !Arc->SubHead.CmpName(SUBHEAD_TYPE_QOPEN))\n      return;\n    QLHeaderPos=Arc->CurBlockPos;\n    RawDataStart=Arc->Tell();\n    RawDataSize=Arc->SubHead.UnpSize;\n    Loaded=true; \n  }\n  if (Arc->SubHead.Encrypted)\n  {\n    RAROptions *Cmd=Arc->GetRAROptions();\n#ifndef RAR_NOCRYPT\n    if (Cmd->Password.IsSet())\n      Crypt.SetCryptKeys(false,CRYPT_RAR50,&Cmd->Password,Arc->SubHead.Salt,\n                         Arc->SubHead.InitV,Arc->SubHead.Lg2Count,\n                         Arc->SubHead.HashKey,Arc->SubHead.PswCheck);\n    else\n#endif\n      return;\n  }\n  RawDataPos=0;\n  ReadBufSize=0;\n  ReadBufPos=0;\n  LastReadHeader.Reset();\n  LastReadHeaderPos=0;\n  ReadBuffer();\n}", "target": 1}
{"code": "void Curl_ssl_detach_conn(struct Curl_easy *data,\n                          struct connectdata *conn)\n{\n  if(Curl_ssl->disassociate_connection) {\n    Curl_ssl->disassociate_connection(data, FIRSTSOCKET);\n    if(conn->sock[SECONDARYSOCKET] && conn->bits.sock_accepted)\n      Curl_ssl->disassociate_connection(data, SECONDARYSOCKET);\n  }\n}", "target": 0}
{"code": "static void ext4_clamp_want_extra_isize(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE &&\n\t    sbi->s_want_extra_isize == 0) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (ext4_has_feature_extra_isize(sb)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\text4_msg(sb, KERN_INFO,\n\t\t\t \"required extra inode space not available\");\n\t}\n}", "target": 1}
{"code": "    Value::UniquePtr Xmpdatum::getValue() const\n    {\n        return p_->value_.get() == 0 ? nullptr : p_->value_->clone();\n    }", "target": 0}
{"code": "void FrameLoader::frameDetached()\n{\n    stopAllLoaders();\n    m_frame->document()->stopActiveDOMObjects();\n    detachFromParent();\n}", "target": 0}
{"code": "error::Error GLES2DecoderImpl::GetAttribLocationHelper(\n    GLuint client_id, uint32 location_shm_id, uint32 location_shm_offset,\n    const std::string& name_str) {\n  if (!StringIsValidForGLES(name_str.c_str())) {\n    SetGLError(GL_INVALID_VALUE, \"glGetAttribLocation: Invalid character\");\n    return error::kNoError;\n  }\n  ProgramManager::ProgramInfo* info = GetProgramInfoNotShader(\n      client_id, \"glGetAttribLocation\");\n  if (!info) {\n    return error::kNoError;\n  }\n  if (!info->IsValid()) {\n    SetGLError(GL_INVALID_OPERATION, \"glGetAttribLocation: program not linked\");\n    return error::kNoError;\n  }\n  GLint* location = GetSharedMemoryAs<GLint*>(\n      location_shm_id, location_shm_offset, sizeof(GLint));\n  if (!location) {\n    return error::kOutOfBounds;\n  }\n  if (*location != -1) {\n    return error::kGenericError;\n  }\n  *location = info->GetAttribLocation(name_str);\n  return error::kNoError;\n}", "target": 0}
{"code": "TEST(MultiplyAndCheckOverflow, Validate) {\n  size_t res = 0;\n  EXPECT_TRUE(MultiplyAndCheckOverflow(1, 2, &res) == kTfLiteOk);\n  EXPECT_FALSE(MultiplyAndCheckOverflow(static_cast<size_t>(123456789023),\n                                        1223423425, &res) == kTfLiteOk);\n}", "target": 0}
{"code": "static int ssl_parse_server_psk_hint( mbedtls_ssl_context *ssl,\n                                      unsigned char **p,\n                                      unsigned char *end )\n{\n    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;\n    size_t  len;\n    ((void) ssl);\n    if( (*p) > end - 2 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message \"\n                                    \"(psk_identity_hint length)\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n    len = (*p)[0] << 8 | (*p)[1];\n    *p += 2;\n    if( (*p) > end - len )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message \"\n                                    \"(psk_identity_hint length)\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n    *p += len;\n    ret = 0;\n    return( ret );\n}", "target": 0}
{"code": "static void nlmclnt_unlock_callback(struct rpc_task *task, void *data)\n{\n\tstruct nlm_rqst\t*req = data;\n\tu32 status = ntohl(req->a_res.status);\n\tif (RPC_ASSASSINATED(task))\n\t\tgoto die;\n\tif (task->tk_status < 0) {\n\t\tdprintk(\"lockd: unlock failed (err = %d)\\n\", -task->tk_status);\n\t\tgoto retry_rebind;\n\t}\n\tif (status == NLM_LCK_DENIED_GRACE_PERIOD) {\n\t\trpc_delay(task, NLMCLNT_GRACE_WAIT);\n\t\tgoto retry_unlock;\n\t}\n\tif (status != NLM_LCK_GRANTED)\n\t\tprintk(KERN_WARNING \"lockd: unexpected unlock status: %d\\n\", status);\ndie:\n\treturn;\n retry_rebind:\n\tnlm_rebind_host(req->a_host);\n retry_unlock:\n\trpc_restart_call(task);\n}", "target": 1}
{"code": "x509stack_push(struct cert_stack *stack, struct rpki_uri *uri, X509 *x509,\n    enum rpki_policy policy, enum cert_type type)\n{\n\tstruct metadata_node *meta;\n\tstruct repo_level_node *repo, *head_repo;\n\tstruct defer_node *defer_separator;\n\tunsigned int work_repo_level;\n\tint ok;\n\tint error;\n\trepo = malloc(sizeof(struct repo_level_node));\n\tif (repo == NULL)\n\t\treturn pr_enomem();\n\trepo->level = 0;\n\twork_repo_level = working_repo_peek_level();\n\thead_repo = SLIST_FIRST(&stack->levels);\n\tif (head_repo != NULL && work_repo_level > head_repo->level)\n\t\trepo->level = work_repo_level;\n\tSLIST_INSERT_HEAD(&stack->levels, repo, next);\n\tmeta = malloc(sizeof(struct metadata_node));\n\tif (meta == NULL) {\n\t\terror = pr_enomem();\n\t\tgoto end3;\n\t}\n\tmeta->uri = uri;\n\turi_refget(uri);\n\tserial_numbers_init(&meta->serials);\n\tsubjects_init(&meta->subjects);\n\tmeta->resources = resources_create(false);\n\tif (meta->resources == NULL) {\n\t\terror = pr_enomem();\n\t\tgoto end4;\n\t}\n\tresources_set_policy(meta->resources, policy);\n\terror = certificate_get_resources(x509, meta->resources, type);\n\tif (error)\n\t\tgoto end5;\n\tif (type == TA && resources_empty(meta->resources)) {\n\t\terror = pr_val_err(\"Trust Anchor certificate does not define any number resources.\");\n\t\tgoto end5;\n\t}\n\tdefer_separator = malloc(sizeof(struct defer_node));\n\tif (defer_separator == NULL) {\n\t\terror = pr_enomem();\n\t\tgoto end5;\n\t}\n\tdefer_separator->type = DNT_SEPARATOR;\n\tok = sk_X509_push(stack->x509s, x509);\n\tif (ok <= 0) {\n\t\terror = val_crypto_err(\n\t\t    \"Could not add certificate to trusted stack: %d\", ok);\n\t\tgoto end5;\n\t}\n\tSLIST_INSERT_HEAD(&stack->defers, defer_separator, next);\n\tSLIST_INSERT_HEAD(&stack->metas, meta, next);\n\treturn 0;\nend5:\tresources_destroy(meta->resources);\nend4:\tsubjects_cleanup(&meta->subjects, subject_cleanup);\n\tserial_numbers_cleanup(&meta->serials, serial_cleanup);\n\turi_refput(meta->uri);\n\tfree(meta);\nend3:\tSLIST_REMOVE_HEAD(&stack->levels, next);\n\tfree(repo);\n\treturn error;\n}", "target": 1}
{"code": "netsnmp_mibindex_new( const char *dirname )\n{\n    FILE *fp;\n    char  tmpbuf[300];\n    char *cp;\n    int   i;\n    cp = netsnmp_mibindex_lookup( dirname );\n    if (!cp) {\n        i  = _mibindex_add( dirname, -1 );\n        snprintf( tmpbuf, sizeof(tmpbuf), \"%s/mib_indexes/%d\",\n                  get_persistent_directory(), i );\n        tmpbuf[sizeof(tmpbuf)-1] = 0;\n        cp = tmpbuf;\n    }\n    DEBUGMSGTL((\"mibindex\", \"new: %s (%s)\\n\", dirname, cp ));\n    fp = fopen( cp, \"w\" );\n    if (fp)\n        fprintf( fp, \"DIR %s\\n\", dirname );\n    return fp;\n}", "target": 1}
{"code": "print_bacp_config_options(netdissect_options *ndo,\n                          const u_char *p, int length)\n{\n\tint len, opt;\n\tif (length < 2)\n\t\treturn 0;\n\tND_TCHECK2(*p, 2);\n\tlen = p[1];\n\topt = p[0];\n\tif (length < len)\n\t\treturn 0;\n\tif (len < 2) {\n\t\tND_PRINT((ndo, \"\\n\\t  %s Option (0x%02x), length %u (length bogus, should be >= 2)\",\n\t\t          tok2str(bacconfopts_values, \"Unknown\", opt),\n\t\t          opt,\n\t\t          len));\n\t\treturn 0;\n\t}\n\tND_PRINT((ndo, \"\\n\\t  %s Option (0x%02x), length %u\",\n\t          tok2str(bacconfopts_values, \"Unknown\", opt),\n\t          opt,\n\t          len));\n\tswitch (opt) {\n\tcase BACPOPT_FPEER:\n\t\tif (len != 6) {\n\t\t\tND_PRINT((ndo, \" (length bogus, should be = 6)\"));\n\t\t\treturn len;\n\t\t}\n\t\tND_TCHECK2(*(p + 2), 4);\n\t\tND_PRINT((ndo, \": Magic-Num 0x%08x\", EXTRACT_32BITS(p + 2)));\n\t\tbreak;\n\tdefault:\n\t\tif (ndo->ndo_vflag < 2)\n\t\t\tprint_unknown_data(ndo, &p[2], \"\\n\\t    \", len - 2);\n\t\tbreak;\n\t}\n\tif (ndo->ndo_vflag > 1)\n\t\tprint_unknown_data(ndo, &p[2], \"\\n\\t    \", len - 2); \n\treturn len;\ntrunc:\n\tND_PRINT((ndo, \"[|bacp]\"));\n\treturn 0;\n}", "target": 1}
{"code": "static int virtio_gpu_object_shmem_init(struct virtio_gpu_device *vgdev,\n\t\t\t\t\tstruct virtio_gpu_object *bo,\n\t\t\t\t\tstruct virtio_gpu_mem_entry **ents,\n\t\t\t\t\tunsigned int *nents)\n{\n\tbool use_dma_api = !virtio_has_dma_quirk(vgdev->vdev);\n\tstruct virtio_gpu_object_shmem *shmem = to_virtio_gpu_shmem(bo);\n\tstruct scatterlist *sg;\n\tint si, ret;\n\tret = drm_gem_shmem_pin(&bo->base);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\tshmem->pages = drm_gem_shmem_get_sg_table(&bo->base);\n\tif (!shmem->pages) {\n\t\tdrm_gem_shmem_unpin(&bo->base);\n\t\treturn -EINVAL;\n\t}\n\tif (use_dma_api) {\n\t\tret = dma_map_sgtable(vgdev->vdev->dev.parent,\n\t\t\t\t      shmem->pages, DMA_TO_DEVICE, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t*nents = shmem->mapped = shmem->pages->nents;\n\t} else {\n\t\t*nents = shmem->pages->orig_nents;\n\t}\n\t*ents = kvmalloc_array(*nents,\n\t\t\t       sizeof(struct virtio_gpu_mem_entry),\n\t\t\t       GFP_KERNEL);\n\tif (!(*ents)) {\n\t\tDRM_ERROR(\"failed to allocate ent list\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tif (use_dma_api) {\n\t\tfor_each_sgtable_dma_sg(shmem->pages, sg, si) {\n\t\t\t(*ents)[si].addr = cpu_to_le64(sg_dma_address(sg));\n\t\t\t(*ents)[si].length = cpu_to_le32(sg_dma_len(sg));\n\t\t\t(*ents)[si].padding = 0;\n\t\t}\n\t} else {\n\t\tfor_each_sgtable_sg(shmem->pages, sg, si) {\n\t\t\t(*ents)[si].addr = cpu_to_le64(sg_phys(sg));\n\t\t\t(*ents)[si].length = cpu_to_le32(sg->length);\n\t\t\t(*ents)[si].padding = 0;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static Jsi_Value *jsi_treeFmtKey(Jsi_MapEntry* h, struct Jsi_MapOpts *opts, int flags)\n{\n    Jsi_TreeEntry* hPtr = (Jsi_TreeEntry*)h;\n    void *key = Jsi_TreeKeyGet(hPtr);\n    if (opts->keyType == JSI_KEYS_ONEWORD)\n        return Jsi_ValueNewNumber(opts->interp, (Jsi_Number)(intptr_t)key);\n    char nbuf[100];\n    snprintf(nbuf, sizeof(nbuf), \"%p\", key);\n    return Jsi_ValueNewStringDup(opts->interp, nbuf);\n}", "target": 1}
{"code": "int X509_cmp_time(const ASN1_TIME *ctm, time_t *cmp_time)\n{\n    char *str;\n    ASN1_TIME atm;\n    long offset;\n    char buff1[24], buff2[24], *p;\n    int i, j;\n    p = buff1;\n    i = ctm->length;\n    str = (char *)ctm->data;\n    if (ctm->type == V_ASN1_UTCTIME) {\n        if ((i < 11) || (i > 17))\n            return 0;\n        memcpy(p, str, 10);\n        p += 10;\n        str += 10;\n    } else {\n        if (i < 13)\n            return 0;\n        memcpy(p, str, 12);\n        p += 12;\n        str += 12;\n    }\n    if ((*str == 'Z') || (*str == '-') || (*str == '+')) {\n        *(p++) = '0';\n        *(p++) = '0';\n    } else {\n        *(p++) = *(str++);\n        *(p++) = *(str++);\n        if (*str == '.') {\n            str++;\n            while ((*str >= '0') && (*str <= '9'))\n                str++;\n        }\n    }\n    *(p++) = 'Z';\n    *(p++) = '\\0';\n    if (*str == 'Z')\n        offset = 0;\n    else {\n        if ((*str != '+') && (*str != '-'))\n            return 0;\n        offset = ((str[1] - '0') * 10 + (str[2] - '0')) * 60;\n        offset += (str[3] - '0') * 10 + (str[4] - '0');\n        if (*str == '-')\n            offset = -offset;\n    }\n    atm.type = ctm->type;\n    atm.flags = 0;\n    atm.length = sizeof(buff2);\n    atm.data = (unsigned char *)buff2;\n    if (X509_time_adj(&atm, offset * 60, cmp_time) == NULL)\n        return 0;\n    if (ctm->type == V_ASN1_UTCTIME) {\n        i = (buff1[0] - '0') * 10 + (buff1[1] - '0');\n        if (i < 50)\n            i += 100;           \n        j = (buff2[0] - '0') * 10 + (buff2[1] - '0');\n        if (j < 50)\n            j += 100;\n        if (i < j)\n            return -1;\n        if (i > j)\n            return 1;\n    }\n    i = strcmp(buff1, buff2);\n    if (i == 0)                 \n        return -1;\n    else\n        return i;\n}", "target": 1}
{"code": "TEST_F(ExtractorTest, TestPrefixHeaderMatch) {\n  auto headers = TestRequestHeaderMapImpl{{\"prefix-header\", \"AAABBBjwt_token\"}};\n  auto tokens = extractor_->extract(headers);\n  EXPECT_EQ(tokens.size(), 2);\n  EXPECT_TRUE(tokens[0]->isIssuerSpecified(\"issuer5\"));\n  EXPECT_EQ(tokens[0]->token(), \"BBBjwt_token\");\n  EXPECT_TRUE(tokens[1]->isIssuerSpecified(\"issuer6\"));\n  EXPECT_EQ(tokens[1]->token(), \"jwt_token\");\n  tokens[0]->removeJwt(headers);\n  EXPECT_FALSE(headers.get(Http::LowerCaseString(\"prefix-header\")));\n}", "target": 0}
{"code": "EventQueue* Document::GetEventQueue() const {\n  if (!dom_window_)\n    return nullptr;\n  return dom_window_->GetEventQueue();\n}", "target": 0}
{"code": "bool WebContentsImpl::UpdateTitleForEntry(NavigationEntryImpl* entry,\n                                          const string16& title) {\n  string16 final_title;\n  bool explicit_set;\n  if (entry && entry->GetURL().SchemeIsFile() && title.empty()) {\n    final_title = UTF8ToUTF16(entry->GetURL().ExtractFileName());\n    explicit_set = false;  \n  } else {\n    TrimWhitespace(title, TRIM_ALL, &final_title);\n    explicit_set = true;\n  }\n  if (entry) {\n    if (final_title == entry->GetTitle())\n      return false;  \n    entry->SetTitle(final_title);\n  } else {\n    if (page_title_when_no_navigation_entry_ == final_title)\n      return false;  \n    page_title_when_no_navigation_entry_ = final_title;\n  }\n  view_->SetPageTitle(final_title);\n  std::pair<NavigationEntry*, bool> details =\n      std::make_pair(entry, explicit_set);\n  NotificationService::current()->Notify(\n      NOTIFICATION_WEB_CONTENTS_TITLE_UPDATED,\n      Source<WebContents>(this),\n      Details<std::pair<NavigationEntry*, bool> >(&details));\n  return true;\n}", "target": 0}
{"code": "static unsigned int ipv6_defrag(void *priv,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tconst struct nf_hook_state *state)\n{\n\tint err;\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\n\tif (skb->nfct && !nf_ct_is_template((struct nf_conn *)skb->nfct))\n\t\treturn NF_ACCEPT;\n#endif\n\terr = nf_ct_frag6_gather(state->net, skb,\n\t\t\t\t nf_ct6_defrag_user(state->hook, skb));\n\tif (err == -EINPROGRESS)\n\t\treturn NF_STOLEN;\n\treturn NF_ACCEPT;\n}", "target": 1}
{"code": "ttwu_do_activate(struct rq *rq, struct task_struct *p, int wake_flags)\n{\n\tlockdep_assert_held(&rq->lock);\n#ifdef CONFIG_SMP\n\tif (p->sched_contributes_to_load)\n\t\trq->nr_uninterruptible--;\n#endif\n\tttwu_activate(rq, p, ENQUEUE_WAKEUP | ENQUEUE_WAKING);\n\tttwu_do_wakeup(rq, p, wake_flags);\n}", "target": 0}
{"code": "    float parseFloat(const std::string& s, bool& ok)\n    {\n        float ret = stringTo<float>(s, ok);\n        if (ok) return ret;\n        Rational r = stringTo<Rational>(s, ok);\n        if (ok) {\n            if (r.second == 0) {\n                ok = false;\n                return 0.0;\n            }\n            return static_cast<float>(r.first) / r.second;\n        }\n        bool b = stringTo<bool>(s, ok);\n        if (ok) return b ? 1.0f : 0.0f;\n        return ret;\n    }", "target": 0}
{"code": "static void adpt_i2o_sys_shutdown(void)\n{\n\tadpt_hba *pHba, *pNext;\n\tstruct adpt_i2o_post_wait_data *p1, *old;\n\tprintk(KERN_INFO \"Shutting down Adaptec I2O controllers.\\n\");\n\tprintk(KERN_INFO \"   This could take a few minutes if there are many devices attached\\n\");\n\tfor (pHba = hba_chain; pHba; pHba = pNext) {\n\t\tpNext = pHba->next;\n\t\tadpt_i2o_delete_hba(pHba);\n\t}\n\tfor(p1 = adpt_post_wait_queue; p1;) {\n\t\told = p1;\n\t\tp1 = p1->next;\n\t\tkfree(old);\n\t}\n\tadpt_post_wait_queue = NULL;\n\tprintk(KERN_INFO \"Adaptec I2O controllers down.\\n\");\n}", "target": 1}
{"code": "static int crypto_report_kpp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_kpp rkpp;\n\tstrlcpy(rkpp.type, \"kpp\", sizeof(rkpp.type));\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_KPP,\n\t\t    sizeof(struct crypto_report_kpp), &rkpp))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "int compat_get_timex(struct timex *txc, const struct compat_timex __user *utp)\n{\n\tstruct compat_timex tx32;\n\tmemset(txc, 0, sizeof(struct timex));\n\tif (copy_from_user(&tx32, utp, sizeof(struct compat_timex)))\n\t\treturn -EFAULT;\n\ttxc->modes = tx32.modes;\n\ttxc->offset = tx32.offset;\n\ttxc->freq = tx32.freq;\n\ttxc->maxerror = tx32.maxerror;\n\ttxc->esterror = tx32.esterror;\n\ttxc->status = tx32.status;\n\ttxc->constant = tx32.constant;\n\ttxc->precision = tx32.precision;\n\ttxc->tolerance = tx32.tolerance;\n\ttxc->time.tv_sec = tx32.time.tv_sec;\n\ttxc->time.tv_usec = tx32.time.tv_usec;\n\ttxc->tick = tx32.tick;\n\ttxc->ppsfreq = tx32.ppsfreq;\n\ttxc->jitter = tx32.jitter;\n\ttxc->shift = tx32.shift;\n\ttxc->stabil = tx32.stabil;\n\ttxc->jitcnt = tx32.jitcnt;\n\ttxc->calcnt = tx32.calcnt;\n\ttxc->errcnt = tx32.errcnt;\n\ttxc->stbcnt = tx32.stbcnt;\n\treturn 0;\n}", "target": 0}
{"code": "        unsigned int GetU32BE (int nPos, bool *pbSuccess)\n        {\n            if ( nPos < 0 || nPos + 3 >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            unsigned int nRes = m_sFile[nPos];\n            nRes = (nRes << 8) + m_sFile[nPos + 1];\n            nRes = (nRes << 8) + m_sFile[nPos + 2];\n            nRes = (nRes << 8) + m_sFile[nPos + 3];\n            return nRes;\n        }", "target": 1}
{"code": "void cliprdr_free_format_list(CLIPRDR_FORMAT_LIST* formatList)\n{\n\tUINT index = 0;\n\tif (formatList == NULL)\n\t\treturn;\n\tif (formatList->formats)\n\t{\n\t\tfor (index = 0; index < formatList->numFormats; index++)\n\t\t{\n\t\t\tfree(formatList->formats[index].formatName);\n\t\t}\n\t\tfree(formatList->formats);\n\t\tformatList->formats = NULL;\n\t\tformatList->numFormats = 0;\n\t}\n}", "target": 0}
{"code": "void receive_tcppacket(connection_t *c, const char *buffer, int len) {\n\tvpn_packet_t outpkt;\n\tif(len > sizeof outpkt.data)\n\t\treturn;\n\toutpkt.len = len;\n\tif(c->options & OPTION_TCPONLY)\n\t\toutpkt.priority = 0;\n\telse\n\t\toutpkt.priority = -1;\n\tmemcpy(outpkt.data, buffer, len);\n\treceive_packet(c->node, &outpkt);\n}", "target": 0}
{"code": "TightDecoder::FilterGradient24(const rdr::U8 *inbuf,\n                               const PixelFormat& pf, PIXEL_T* outbuf,\n                               int stride, const Rect& r)\n{\n  int x, y, c;\n  rdr::U8 prevRow[TIGHT_MAX_WIDTH*3];\n  rdr::U8 thisRow[TIGHT_MAX_WIDTH*3];\n  rdr::U8 pix[3]; \n  int est[3]; \n  memset(prevRow, 0, sizeof(prevRow));\n  int rectHeight = r.height();\n  int rectWidth = r.width();\n  for (y = 0; y < rectHeight; y++) {\n    for (c = 0; c < 3; c++) {\n      pix[c] = inbuf[y*rectWidth*3+c] + prevRow[c];\n      thisRow[c] = pix[c];\n    }\n    pf.bufferFromRGB((rdr::U8*)&outbuf[y*stride], pix, 1);\n    for (x = 1; x < rectWidth; x++) {\n      for (c = 0; c < 3; c++) {\n        est[c] = prevRow[x*3+c] + pix[c] - prevRow[(x-1)*3+c];\n        if (est[c] > 0xff) {\n          est[c] = 0xff;\n        } else if (est[c] < 0) {\n          est[c] = 0;\n        }\n        pix[c] = inbuf[(y*rectWidth+x)*3+c] + est[c];\n        thisRow[x*3+c] = pix[c];\n      }\n      pf.bufferFromRGB((rdr::U8*)&outbuf[y*stride+x], pix, 1);\n    }\n    memcpy(prevRow, thisRow, sizeof(prevRow));\n  }\n}", "target": 1}
{"code": "gfx::Rect WebContentsImpl::GetRootWindowResizerRect() const {\n  if (delegate_)\n    return delegate_->GetRootWindowResizerRect();\n  return gfx::Rect();\n}", "target": 0}
{"code": "CompileResult generateBytecodeForSerialization(\n    raw_ostream &OS,\n    Module &M,\n    const BytecodeGenerationOptions &genOptions,\n    const SHA1 &sourceHash,\n    hermes::OptValue<uint32_t> segment,\n    SourceMapGenerator *sourceMapGenOrNull,\n    BaseBytecodeMap &baseBytecodeMap) {\n  if (cl::BytecodeFormat == cl::BytecodeFormatKind::HBC) {\n    std::unique_ptr<hbc::BCProviderFromBuffer> baseBCProvider = nullptr;\n    auto itr = baseBytecodeMap.find(segment ? *segment : 0);\n    if (itr != baseBytecodeMap.end()) {\n      baseBCProvider = std::move(itr->second);\n      baseBytecodeMap.erase(itr);\n    }\n    auto bytecodeModule = hbc::generateBytecode(\n        &M,\n        OS,\n        genOptions,\n        sourceHash,\n        segment,\n        sourceMapGenOrNull,\n        std::move(baseBCProvider));\n    if (auto N = M.getContext().getSourceErrorManager().getErrorCount()) {\n      llvh::errs() << \"Emitted \" << N << \" errors in the backend. exiting.\\n\";\n      return BackendError;\n    }\n    if (cl::DumpTarget == DumpBytecode) {\n      disassembleBytecode(hbc::BCProviderFromSrc::createBCProviderFromSrc(\n          std::move(bytecodeModule)));\n    }\n  } else {\n    llvm_unreachable(\"Invalid bytecode kind\");\n  }\n  return Success;\n}", "target": 0}
{"code": "void Item_direct_view_ref::update_used_tables()\n{\n  set_null_ref_table();\n  Item_direct_ref::update_used_tables();\n}", "target": 0}
{"code": "ProcAllocColorCells(ClientPtr client)\n{\n    ColormapPtr pcmp;\n    int rc;\n    REQUEST(xAllocColorCellsReq);\n    REQUEST_SIZE_MATCH(xAllocColorCellsReq);\n    rc = dixLookupResourceByType((void **) &pcmp, stuff->cmap, RT_COLORMAP,\n                                 client, DixAddAccess);\n    if (rc == Success) {\n        int npixels, nmasks;\n        long length;\n        Pixel *ppixels, *pmasks;\n        npixels = stuff->colors;\n        if (!npixels) {\n            client->errorValue = npixels;\n            return BadValue;\n        }\n        if (stuff->contiguous != xTrue && stuff->contiguous != xFalse) {\n            client->errorValue = stuff->contiguous;\n            return BadValue;\n        }\n        nmasks = stuff->planes;\n        length = ((long) npixels + (long) nmasks) * sizeof(Pixel);\n        ppixels = malloc(length);\n        if (!ppixels)\n            return BadAlloc;\n        pmasks = ppixels + npixels;\n        if ((rc = AllocColorCells(client->index, pcmp, npixels, nmasks,\n                                  (Bool) stuff->contiguous, ppixels, pmasks))) {\n            free(ppixels);\n            return rc;\n        }\n#ifdef PANORAMIX\n        if (noPanoramiXExtension || !pcmp->pScreen->myNum)\n#endif\n        {\n            xAllocColorCellsReply accr = {\n                .type = X_Reply,\n                .sequenceNumber = client->sequence,\n                .length = bytes_to_int32(length),\n                .nPixels = npixels,\n                .nMasks = nmasks\n            };\n            WriteReplyToClient(client, sizeof(xAllocColorCellsReply), &accr);\n            client->pSwapReplyFunc = (ReplySwapPtr) Swap32Write;\n            WriteSwappedDataToClient(client, length, ppixels);\n        }\n        free(ppixels);\n        return Success;\n    }\n    else {\n        client->errorValue = stuff->cmap;\n        return rc;\n    }\n}", "target": 0}
{"code": "static int get_filter(void __user *arg, struct sock_filter **p)\n{\n\tstruct sock_fprog uprog;\n\tstruct sock_filter *code = NULL;\n\tint len;\n\tif (copy_from_user(&uprog, arg, sizeof(uprog)))\n\t\treturn -EFAULT;\n\tif (!uprog.len) {\n\t\t*p = NULL;\n\t\treturn 0;\n\t}\n\tlen = uprog.len * sizeof(struct sock_filter);\n\tcode = memdup_user(uprog.filter, len);\n\tif (IS_ERR(code))\n\t\treturn PTR_ERR(code);\n\t*p = code;\n\treturn uprog.len;\n}", "target": 0}
{"code": "static int mongo_cursor_get_more( mongo_cursor *cursor ) {\n    int res;\n    if( cursor->limit > 0 && cursor->seen >= cursor->limit ) {\n        cursor->err = MONGO_CURSOR_EXHAUSTED;\n        return MONGO_ERROR;\n    }\n    else if( ! cursor->reply ) {\n        cursor->err = MONGO_CURSOR_INVALID;\n        return MONGO_ERROR;\n    }\n    else if( ! cursor->reply->fields.cursorID ) {\n        cursor->err = MONGO_CURSOR_EXHAUSTED;\n        return MONGO_ERROR;\n    }\n    else {\n        char *data;\n        int sl = strlen( cursor->ns )+1;\n        int limit = 0;\n        mongo_message *mm;\n        if( cursor->limit > 0 )\n            limit = cursor->limit - cursor->seen;\n        mm = mongo_message_create( 16 \n                                   +4 \n                                   +sl\n                                   +4 \n                                   +8 \n                                   , 0, 0, MONGO_OP_GET_MORE );\n        data = &mm->data;\n        data = mongo_data_append32( data, &ZERO );\n        data = mongo_data_append( data, cursor->ns, sl );\n        data = mongo_data_append32( data, &limit );\n        mongo_data_append64( data, &cursor->reply->fields.cursorID );\n        bson_free( cursor->reply );\n        res = mongo_message_send( cursor->conn, mm );\n        if( res != MONGO_OK ) {\n            mongo_cursor_destroy( cursor );\n            return MONGO_ERROR;\n        }\n        res = mongo_read_response( cursor->conn, &( cursor->reply ) );\n        if( res != MONGO_OK ) {\n            mongo_cursor_destroy( cursor );\n            return MONGO_ERROR;\n        }\n        cursor->current.data = NULL;\n        cursor->seen += cursor->reply->fields.num;\n        return MONGO_OK;\n    }\n}", "target": 1}
{"code": "int kvm_set_xcr(struct kvm_vcpu *vcpu, u32 index, u64 xcr)\n{\n\tif (__kvm_set_xcr(vcpu, index, xcr)) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static struct clock_source *dce120_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(*clk_src), GFP_KERNEL);\n\tif (!clk_src)\n\t\treturn NULL;\n\tif (dce112_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\t\t     regs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\tkfree(clk_src);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 0}
{"code": "static RList *r_bin_wasm_get_data_entries (RBinWasmObj *bin, RBinWasmSection *sec) {\n\tRList *ret = NULL;\n\tRBinWasmDataEntry *ptr = NULL;\n\tif (!(ret = r_list_newf ((RListFree)free))) {\n\t\treturn NULL;\n\t}\n\tut8* buf = bin->buf->buf + (ut32)sec->payload_data;\n\tut32 len =  sec->payload_len;\n\tut32 count = sec->count;\n\tut32 i = 0, r = 0;\n\tsize_t n = 0;\n\twhile (i < len && r < count) {\n\t\tif (!(ptr = R_NEW0 (RBinWasmDataEntry))) {\n\t\t\treturn ret;\n\t\t}\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->index, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\t\tif (!(n = consume_init_expr (buf + i, buf + len, R_BIN_WASM_END_OF_CODE, NULL, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\t\tptr->offset.len = n;\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->size, &i))) {\t\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\t\tptr->data = sec->payload_data + i;\n\t\tr_list_append (ret, ptr);\n\t\tr += 1;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "doc_data_init(struct doc_data *data)\n{\n\tdata->hash = NULL;\n\tdata->hash_len = 0;\n\tdata->uri = NULL;\n}", "target": 1}
{"code": "static int nfs4_intent_set_file(struct nameidata *nd, struct path *path, struct nfs4_state *state)\n{\n\tstruct file *filp;\n\tint ret;\n\tif (nd->intent.open.flags & FMODE_EXEC) {\n\t\tret = nfs_may_open(state->inode,\n\t\t\t\tstate->owner->so_cred,\n\t\t\t\tnd->intent.open.flags);\n\t\tif (ret < 0)\n\t\t\tgoto out_close;\n\t}\n\tfilp = lookup_instantiate_filp(nd, path->dentry, NULL);\n\tif (!IS_ERR(filp)) {\n\t\tstruct nfs_open_context *ctx;\n\t\tctx = nfs_file_open_context(filp);\n\t\tctx->state = state;\n\t\treturn 0;\n\t}\n\tret = PTR_ERR(filp);\nout_close:\n\tnfs4_close_sync(path, state, nd->intent.open.flags);\n\treturn ret;\n}", "target": 1}
{"code": "static int do_video_set_spu_palette(unsigned int fd, unsigned int cmd,\n\t\tstruct compat_video_spu_palette __user *up)\n{\n\tstruct video_spu_palette __user *up_native;\n\tcompat_uptr_t palp;\n\tint length, err;\n\terr  = get_user(palp, &up->palette);\n\terr |= get_user(length, &up->length);\n\tif (err)\n\t\treturn -EFAULT;\n\tup_native = compat_alloc_user_space(sizeof(struct video_spu_palette));\n\terr  = put_user(compat_ptr(palp), &up_native->palette);\n\terr |= put_user(length, &up_native->length);\n\tif (err)\n\t\treturn -EFAULT;\n\terr = sys_ioctl(fd, cmd, (unsigned long) up_native);\n\treturn err;\n}", "target": 0}
{"code": "void comps_rtree_unite(COMPS_RTree *rt1, COMPS_RTree *rt2) {\n    COMPS_HSList *tmplist, *tmp_subnodes;\n    COMPS_HSListItem *it;\n    struct Pair {\n        COMPS_HSList * subnodes;\n        char * key;\n        char added;\n    } *pair, *parent_pair;\n    pair = malloc(sizeof(struct Pair));\n    pair->subnodes = rt2->subnodes;\n    pair->key = NULL;\n    tmplist = comps_hslist_create();\n    comps_hslist_init(tmplist, NULL, NULL, &free);\n    comps_hslist_append(tmplist, pair, 0);\n    while (tmplist->first != NULL) {\n        it = tmplist->first;\n        comps_hslist_remove(tmplist, tmplist->first);\n        tmp_subnodes = ((struct Pair*)it->data)->subnodes;\n        parent_pair = (struct Pair*) it->data;\n        free(it);\n        for (it = tmp_subnodes->first; it != NULL; it=it->next) {\n            pair = malloc(sizeof(struct Pair));\n            pair->subnodes = ((COMPS_RTreeData*)it->data)->subnodes;\n            if (parent_pair->key != NULL) {\n                pair->key = malloc(sizeof(char)\n                               * (strlen(((COMPS_RTreeData*)it->data)->key)\n                               + strlen(parent_pair->key) + 1));\n                memcpy(pair->key, parent_pair->key,\n                       sizeof(char) * strlen(parent_pair->key));\n                memcpy(pair->key + strlen(parent_pair->key),\n                       ((COMPS_RTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_RTreeData*)it->data)->key)+1));\n            } else {\n                pair->key = malloc(sizeof(char)*\n                                (strlen(((COMPS_RTreeData*)it->data)->key) +1));\n                memcpy(pair->key, ((COMPS_RTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_RTreeData*)it->data)->key)+1));\n            }\n            if (((COMPS_RTreeData*)it->data)->data != NULL) {\n                    comps_rtree_set(rt1,\n                                    pair->key,\n                        rt2->data_cloner(((COMPS_RTreeData*)it->data)->data));\n            }\n            if (((COMPS_RTreeData*)it->data)->subnodes->first) {\n                comps_hslist_append(tmplist, pair, 0);\n            } else {\n                free(pair->key);\n                free(pair);\n            }\n        }\n        free(parent_pair->key);\n        free(parent_pair);\n    }\n    comps_hslist_destroy(&tmplist);\n}", "target": 1}
{"code": " bool makeAllDirectories(const String& path)\n {\n    String fullPath = path;\n    if (SHCreateDirectoryEx(0, fullPath.charactersWithNullTermination(), 0) != ERROR_SUCCESS) {\n        DWORD error = GetLastError();\n        if (error != ERROR_FILE_EXISTS && error != ERROR_ALREADY_EXISTS) {\n            LOG_ERROR(\"Failed to create path %s\", path.ascii().data());\n            return false;\n        }\n    }\n    return true;\n}", "target": 0}
{"code": "static void put_crypt_info(struct fscrypt_info *ci)\n{\n\tif (!ci)\n\t\treturn;\n\tkey_put(ci->ci_keyring_key);\n\tcrypto_free_skcipher(ci->ci_ctfm);\n\tkmem_cache_free(fscrypt_info_cachep, ci);\n}", "target": 1}
{"code": "pci_emul_alloc_resource(uint64_t *baseptr, uint64_t limit, uint64_t size,\n\t\t\tuint64_t *addr)\n{\n\tuint64_t base;\n\tassert((size & (size - 1)) == 0);\t\n\tbase = roundup2(*baseptr, size);\n\tif (base + size <= limit) {\n\t\t*addr = base;\n\t\t*baseptr = base + size;\n\t\treturn 0;\n\t} else\n\t\treturn -1;\n}", "target": 1}
{"code": "static void bson_append32_as_int( bson *b, int data ) {\n    bson_little_endian32( b->cur, &data );\n    b->cur += 4;\n}", "target": 0}
{"code": "static void gsm_cleanup_mux(struct gsm_mux *gsm, bool disc)\n{\n\tint i;\n\tstruct gsm_dlci *dlci = gsm->dlci[0];\n\tstruct gsm_msg *txq, *ntxq;\n\tgsm->dead = true;\n\tmutex_lock(&gsm->mutex);\n\tif (dlci) {\n\t\tif (disc && dlci->state != DLCI_CLOSED) {\n\t\t\tgsm_dlci_begin_close(dlci);\n\t\t\twait_event(gsm->event, dlci->state == DLCI_CLOSED);\n\t\t}\n\t\tdlci->dead = true;\n\t}\n\tdel_timer_sync(&gsm->kick_timer);\n\tdel_timer_sync(&gsm->t2_timer);\n\tdel_timer_sync(&gsm->ka_timer);\n\tflush_work(&gsm->tx_work);\n\tif (gsm->has_devices) {\n\t\tgsm_unregister_devices(gsm_tty_driver, gsm->num);\n\t\tgsm->has_devices = false;\n\t}\n\tfor (i = NUM_DLCI - 1; i >= 0; i--)\n\t\tif (gsm->dlci[i]) {\n\t\t\tgsm_dlci_release(gsm->dlci[i]);\n\t\t\tgsm->dlci[i] = NULL;\n\t\t}\n\tmutex_unlock(&gsm->mutex);\n\ttty_ldisc_flush(gsm->tty);\n\tlist_for_each_entry_safe(txq, ntxq, &gsm->tx_ctrl_list, list)\n\t\tkfree(txq);\n\tINIT_LIST_HEAD(&gsm->tx_ctrl_list);\n\tlist_for_each_entry_safe(txq, ntxq, &gsm->tx_data_list, list)\n\t\tkfree(txq);\n\tINIT_LIST_HEAD(&gsm->tx_data_list);\n}", "target": 1}
{"code": "set_cs_start(const char* line)\n{\n    static int cs_start_set = 0;\n    char *p, *q, *r;\n    if ((p = strstr(line, \"string currentfile\"))\n        && strstr(line, \"readstring\")) {\n        for (q = p; q != line && q[-1] != '/'; --q)\n            ;\n        if (q != line) {\n            for (r = q; r != p && !isspace((unsigned char) *r) && *r != '{'; ++r)\n                ;\n            if (cs_start_set)\n                free((char*) cs_start);\n            cs_start = p = malloc(r - q + 1);\n            memcpy(p, q, r - q);\n            p[r - q] = 0;\n            cs_start_set = 1;\n        }\n    }\n}", "target": 0}
{"code": "escape_character (gunichar c)\n{\n  g_autoptr(GString) res = g_string_new (\"\");\n  append_hex_escaped_character (res, c);\n  return g_string_free (g_steal_pointer (&res), FALSE);\n}", "target": 0}
{"code": "TEST(RegexMatchExpression, MatchesNull) {\n    RegexMatchExpression regex(\"a\", \"b\", \"\");\n    ASSERT(!regex.matchesBSON(BSONObj(), NULL));\n    ASSERT(!regex.matchesBSON(BSON(\"a\" << BSONNULL), NULL));\n}", "target": 0}
{"code": "\tvirtual size_t\tRead(void *buffer, size_t size, size_t count)\n\t{\n\t\tif (!m_fp) return 0;\n\t\treturn fread(buffer, size, count, m_fp);\n\t}", "target": 1}
{"code": "ikev2_gen_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext)\n{\n\tstruct isakmp_gen e;\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tikev2_pay_print(ndo, NPSTR(tpay), e.critical);\n\tND_PRINT((ndo,\" len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}", "target": 0}
{"code": "gss_get_mic_iov_length(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n\t\t       int iov_count)\n{\n    OM_uint32 status;\n    gss_union_ctx_id_t ctx;\n    gss_mechanism mech;\n    status = val_wrap_iov_args(minor_status, context_handle, 0, qop_req, NULL,\n\t\t\t       iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn status;\n    ctx = (gss_union_ctx_id_t)context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n    mech = gssint_get_mechanism(ctx->mech_type);\n    if (mech == NULL)\n\treturn GSS_S_BAD_MECH;\n    if (mech->gss_get_mic_iov_length == NULL)\n\treturn GSS_S_UNAVAILABLE;\n    status = mech->gss_get_mic_iov_length(minor_status, ctx->internal_ctx_id,\n\t\t\t\t\t  qop_req, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\tmap_error(minor_status, mech);\n    return status;\n}", "target": 0}
{"code": "bool IsBlacklistedArg(const base::CommandLine::CharType* arg) {\n#if defined(OS_WIN)\n  const auto converted = base::WideToUTF8(arg);\n  const char* a = converted.c_str();\n#else\n  const char* a = arg;\n#endif\n  static const char* prefixes[] = {\"--\", \"-\", \"/\"};\n  int prefix_length = 0;\n  for (auto& prefix : prefixes) {\n    if (base::StartsWith(a, prefix, base::CompareCase::SENSITIVE)) {\n      prefix_length = strlen(prefix);\n      break;\n    }\n  }\n  if (prefix_length > 0) {\n    a += prefix_length;\n    std::string switch_name(a, strcspn(a, \"=\"));\n    auto* iter = std::lower_bound(std::begin(kBlacklist), std::end(kBlacklist),\n                                  switch_name);\n    if (iter != std::end(kBlacklist) && switch_name == *iter) {\n      return true;\n    }\n  }\n  return false;\n}", "target": 1}
{"code": "void Jsi_ValueArrayShift(Jsi_Interp *interp, Jsi_Value *v)\n{\n    if (v->vt != JSI_VT_OBJECT) {\n        Jsi_LogBug(\"Jsi_ValueArrayShift, target is not object\");\n        return;\n    }\n    Jsi_Obj *o = v->d.obj;\n    if (o->isarrlist) {\n        uint i;\n        if (!o->arrCnt)\n            return;\n        if (o->arr[0])\n            Jsi_DecrRefCount(interp, o->arr[0]);\n        for (i=1; i<o->arrCnt; i++) {\n            o->arr[i-1] = o->arr[i];\n        }\n        o->arr[o->arrCnt--] = NULL;\n        return;\n    }\n    int len = Jsi_ObjGetLength(interp, v->d.obj);\n    if (len <= 0) return;\n    Jsi_Value *v0 = Jsi_ValueArrayIndex(interp, v, 0);\n    if (!v0) return;\n    Jsi_ValueReset(interp, &v0);\n    int i;\n    Jsi_Value *last = v0;\n    for (i = 1; i < len; ++i) {\n        Jsi_Value *t = Jsi_ValueArrayIndex(interp, v, i);\n        if (!t) return;\n        Jsi_ValueCopy(interp, last, t);\n        Jsi_ValueReset(interp, &t);\n        last = t;\n    }\n    Jsi_ObjSetLength(interp, v->d.obj, len - 1);\n}", "target": 1}
{"code": "void zend_shared_alloc_register_xlat_entry(const void *old, const void *new)\n{\n\tzend_hash_index_update_ptr(&xlat_table, (zend_ulong)old, (void*)new);\n}", "target": 0}
{"code": "static ssize_t k90_show_current_profile(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tint ret;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tint current_profile;\n\tchar data[8];\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_STATUS,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 8,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial state (error %d).\\n\",\n\t\t\t ret);\n\t\treturn -EIO;\n\t}\n\tcurrent_profile = data[7];\n\tif (current_profile < 1 || current_profile > 3) {\n\t\tdev_warn(dev, \"Read invalid current profile: %02hhx.\\n\",\n\t\t\t data[7]);\n\t\treturn -EIO;\n\t}\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", current_profile);\n}", "target": 1}
{"code": "static int adpt_abort(struct scsi_cmnd * cmd)\n{\n\tadpt_hba* pHba = NULL;\t\n\tstruct adpt_device* dptdevice;\t\n\tu32 msg[5];\n\tint rcode;\n\tpHba = (adpt_hba*) cmd->device->host->hostdata[0];\n\tprintk(KERN_INFO\"%s: Trying to Abort\\n\",pHba->name);\n\tif ((dptdevice = (void*) (cmd->device->hostdata)) == NULL) {\n\t\tprintk(KERN_ERR \"%s: Unable to abort: No device in cmnd\\n\",pHba->name);\n\t\treturn FAILED;\n\t}\n\tmemset(msg, 0, sizeof(msg));\n\tmsg[0] = FIVE_WORD_MSG_SIZE|SGL_OFFSET_0;\n\tmsg[1] = I2O_CMD_SCSI_ABORT<<24|HOST_TID<<12|dptdevice->tid;\n\tmsg[2] = 0;\n\tmsg[3]= 0;\n\tmsg[4] = scsi_cmd_to_rq(cmd)->tag + 1;\n\tif (pHba->host)\n\t\tspin_lock_irq(pHba->host->host_lock);\n\trcode = adpt_i2o_post_wait(pHba, msg, sizeof(msg), FOREVER);\n\tif (pHba->host)\n\t\tspin_unlock_irq(pHba->host->host_lock);\n\tif (rcode != 0) {\n\t\tif(rcode == -EOPNOTSUPP ){\n\t\t\tprintk(KERN_INFO\"%s: Abort cmd not supported\\n\",pHba->name);\n\t\t\treturn FAILED;\n\t\t}\n\t\tprintk(KERN_INFO\"%s: Abort failed.\\n\",pHba->name);\n\t\treturn FAILED;\n\t} \n\tprintk(KERN_INFO\"%s: Abort complete.\\n\",pHba->name);\n\treturn SUCCESS;\n}", "target": 1}
{"code": "static void drop_privs(void)\n{\n\tif (getuid() != 0) {\n\t\toldfsuid = setfsuid(getuid());\n\t\toldfsgid = setfsgid(getgid());\n\t}\n}", "target": 0}
{"code": "rpcap_remoteact_getsock(const char *host, int *error, char *errbuf)\n{\n\tstruct activehosts *temp;\t\t\t\n\tstruct addrinfo hints, *addrinfo, *ai_next;\t\n\tint retval;\n\taddrinfo = NULL;\n\tmemset(&hints, 0, sizeof(struct addrinfo));\n\thints.ai_family = PF_UNSPEC;\n\thints.ai_socktype = SOCK_STREAM;\n\tretval = sock_initaddress(host, NULL, &hints, &addrinfo, errbuf,\n\t    PCAP_ERRBUF_SIZE);\n\tif (retval != 0)\n\t{\n\t\t*error = 1;\n\t\treturn NULL;\n\t}\n\ttemp = activeHosts;\n\twhile (temp)\n\t{\n\t\tai_next = addrinfo;\n\t\twhile (ai_next)\n\t\t{\n\t\t\tif (sock_cmpaddr(&temp->host, (struct sockaddr_storage *) ai_next->ai_addr) == 0)\n\t\t\t{\n\t\t\t\t*error = 0;\n\t\t\t\tfreeaddrinfo(addrinfo);\n\t\t\t\treturn temp;\n\t\t\t}\n\t\t\tai_next = ai_next->ai_next;\n\t\t}\n\t\ttemp = temp->next;\n\t}\n\tif (addrinfo)\n\t\tfreeaddrinfo(addrinfo);\n\t*error = 0;\n\treturn NULL;\n}", "target": 1}
{"code": "bool DNP3_Base::ParseAppLayer(Endpoint* endp)\n\t{\n\tbool orig = (endp == &orig_state);\n\tbinpac::DNP3::DNP3_Flow* flow = orig ? interp->upflow() : interp->downflow();\n\tu_char* data = endp->buffer + PSEUDO_TRANSPORT_INDEX; \n\tint len = endp->pkt_length - 5;\n\tint is_first = (endp->tpflags & 0x40) >> 6; \n\tint is_last = (endp->tpflags & 0x80) >> 7; \n\tint transport = PSEUDO_TRANSPORT_LEN;\n\tint i = 0;\n\twhile ( len > 0 )\n\t\t{\n\t\tint n = min(len, 16);\n\t\tif ( ! CheckCRC(n, data, data + n, \"app_chunk\") )\n\t\t\treturn false;\n\t\tassert(data + n < endp->buffer + endp->buffer_len);\n\t\tflow->flow_buffer()->BufferData(data + transport, data + n);\n\t\ttransport = 0;\n\t\tdata += n + 2;\n\t\tlen -= n;\n\t\t}\n\tif ( is_first )\n\t\tendp->encountered_first_chunk = true;\n\tif ( ! is_first && ! endp->encountered_first_chunk )\n\t\t{\n\t\tanalyzer->Weird(\"dnp3_first_application_layer_chunk_missing\");\n\t\treturn false;\n\t\t}\n\tif ( is_last )\n\t\t{\n\t\tflow->flow_buffer()->FinishBuffer();\n\t\tflow->FlowEOF();\n\t\tClearEndpointState(orig);\n\t\t}\n\treturn true;\n\t}", "target": 1}
{"code": "static inline void vpid_sync_context(struct vcpu_vmx *vmx)\n{\n\tif (cpu_has_vmx_invvpid_single())\n\t\tvpid_sync_vcpu_single(vmx);\n\telse\n\t\tvpid_sync_vcpu_global();\n}", "target": 0}
{"code": "static ssize_t aio_setup_vectored_rw(struct kiocb *kiocb,\n\t\t\t\t     int rw, char __user *buf,\n\t\t\t\t     unsigned long *nr_segs,\n\t\t\t\t     size_t *len,\n\t\t\t\t     struct iovec **iovec,\n\t\t\t\t     bool compat)\n{\n\tssize_t ret;\n\t*nr_segs = *len;\n#ifdef CONFIG_COMPAT\n\tif (compat)\n\t\tret = compat_rw_copy_check_uvector(rw,\n\t\t\t\t(struct compat_iovec __user *)buf,\n\t\t\t\t*nr_segs, UIO_FASTIOV, *iovec, iovec);\n\telse\n#endif\n\t\tret = rw_copy_check_uvector(rw,\n\t\t\t\t(struct iovec __user *)buf,\n\t\t\t\t*nr_segs, UIO_FASTIOV, *iovec, iovec);\n\tif (ret < 0)\n\t\treturn ret;\n\t*len = ret;\n\treturn 0;\n}", "target": 1}
{"code": "bool Archive::Close()\n{\n#ifdef USE_ARCMEM\n  if (ArcMem.Unload())\n    return true;\n#endif\n  return File::Close();\n}", "target": 0}
{"code": "static int oidc_cache_crypto_decrypt(request_rec *r, const char *cache_value,\n\t\tunsigned char *key, unsigned char **plaintext) {\n\tint len = -1;\n\tchar *encoded_tag = strstr(cache_value, \".\");\n\tif (encoded_tag == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"corrupted cache value: no tag separator found in encrypted value\");\n\t\treturn FALSE;\n\t}\n\tcache_value = apr_pstrmemdup(r->pool, cache_value,\n\t\t\tstrlen(cache_value) - strlen(encoded_tag));\n\tencoded_tag++;\n\tchar *d_bytes = NULL;\n\tint d_len = oidc_base64url_decode(r->pool, &d_bytes, cache_value);\n\tchar *t_bytes = NULL;\n\tint t_len = oidc_base64url_decode(r->pool, &t_bytes, encoded_tag);\n\tif ((d_len > 0) && (t_len > 0)) {\n\t\t*plaintext = apr_pcalloc(r->pool,\n\t\t\t\t(d_len + EVP_CIPHER_block_size(OIDC_CACHE_CIPHER) - 1));\n\t\tlen = oidc_cache_crypto_decrypt_impl(r, (unsigned char *) d_bytes,\n\t\t\t\td_len, OIDC_CACHE_CRYPTO_GCM_AAD,\n\t\t\t\tsizeof(OIDC_CACHE_CRYPTO_GCM_AAD), (unsigned char *) t_bytes,\n\t\t\t\tt_len, key, OIDC_CACHE_CRYPTO_GCM_IV,\n\t\t\t\tsizeof(OIDC_CACHE_CRYPTO_GCM_IV), *plaintext);\n\t\tif (len > -1) {\n\t\t\t(*plaintext)[len] = '\\0';\n\t\t} else {\n\t\t\t*plaintext = NULL;\n\t\t}\n\t}\n\treturn len;\n}", "target": 1}
{"code": "bool isCPUDevice() {\n  return false;\n}", "target": 0}
{"code": "void FIO_TLS_WEAK fio_tls_destroy(fio_tls_s *tls) {\n  if (!tls)\n    return;\n  REQUIRE_LIBRARY();\n  if (fio_atomic_sub(&tls->ref, 1))\n    return;\n  fio_tls_destroy_context(tls);\n  alpn_list_free(&tls->alpn);\n  cert_ary_free(&tls->sni);\n  trust_ary_free(&tls->trust);\n  free(tls);\n}", "target": 0}
{"code": "static int count_leading_dotdots(const char *url, const char **out)\n{\n\tint result = 0;\n\twhile (1) {\n\t\tif (starts_with_dot_dot_slash(url)) {\n\t\t\tresult++;\n\t\t\turl += strlen(\"../\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (starts_with_dot_slash(url)) {\n\t\t\turl += strlen(\"./\");\n\t\t\tcontinue;\n\t\t}\n\t\t*out = url;\n\t\treturn result;\n\t}\n}", "target": 0}
{"code": "static void zend_throw_or_error(int fetch_type, zend_class_entry *exception_ce, const char *format, ...) \n{\n\tva_list va;\n\tchar *message = NULL;\n\tva_start(va, format);\n\tzend_vspprintf(&message, 0, format, va);\n\tif (fetch_type & ZEND_FETCH_CLASS_EXCEPTION) {\n\t\tzend_throw_error(exception_ce, message);\n\t} else {\n\t\tzend_error(E_ERROR, \"%s\", message);\n\t}\n\tefree(message);\n\tva_end(va);\n}", "target": 1}
{"code": "static int sctp_v6_xmit(struct sk_buff *skb, struct sctp_transport *transport)\n{\n\tstruct sock *sk = skb->sk;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct flowi6 fl6;\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.flowi6_proto = sk->sk_protocol;\n\tfl6.daddr = transport->ipaddr.v6.sin6_addr;\n\tfl6.saddr = transport->saddr.v6.sin6_addr;\n\tfl6.flowlabel = np->flow_label;\n\tIP6_ECN_flow_xmit(sk, fl6.flowlabel);\n\tif (ipv6_addr_type(&fl6.saddr) & IPV6_ADDR_LINKLOCAL)\n\t\tfl6.flowi6_oif = transport->saddr.v6.sin6_scope_id;\n\telse\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\tif (np->opt && np->opt->srcrt) {\n\t\tstruct rt0_hdr *rt0 = (struct rt0_hdr *) np->opt->srcrt;\n\t\tfl6.daddr = *rt0->addr;\n\t}\n\tpr_debug(\"%s: skb:%p, len:%d, src:%pI6 dst:%pI6\\n\", __func__, skb,\n\t\t skb->len, &fl6.saddr, &fl6.daddr);\n\tSCTP_INC_STATS(sock_net(sk), SCTP_MIB_OUTSCTPPACKS);\n\tif (!(transport->param_flags & SPP_PMTUD_ENABLE))\n\t\tskb->local_df = 1;\n\treturn ip6_xmit(sk, skb, &fl6, np->opt, np->tclass);\n}", "target": 1}
{"code": "request_env(agooReq req, VALUE self) {\n    if (Qnil == (VALUE)req->env) {\n\tvolatile VALUE\tenv = rb_hash_new();\n\trb_hash_aset(env, request_method_val, req_method(req));\n\trb_hash_aset(env, script_name_val, req_script_name(req));\n\trb_hash_aset(env, path_info_val, req_path_info(req));\n\trb_hash_aset(env, query_string_val, req_query_string(req));\n\trb_hash_aset(env, server_name_val, req_server_name(req));\n\trb_hash_aset(env, server_port_val, req_server_port(req));\n\tfill_headers(req, env);\n\trb_hash_aset(env, rack_version_val, rack_version_val_val);\n\trb_hash_aset(env, rack_url_scheme_val, req_rack_url_scheme(req));\n\trb_hash_aset(env, rack_input_val, req_rack_input(req));\n\trb_hash_aset(env, rack_errors_val, req_rack_errors(req));\n\trb_hash_aset(env, rack_multithread_val, req_rack_multithread(req));\n\trb_hash_aset(env, rack_multiprocess_val, Qfalse);\n\trb_hash_aset(env, rack_run_once_val, Qfalse);\n\trb_hash_aset(env, rack_logger_val, req_rack_logger(req));\n\trb_hash_aset(env, rack_upgrade_val, req_rack_upgrade(req));\n\trb_hash_aset(env, rack_hijackq_val, Qtrue);\n\trb_hash_aset(env, rack_hijack_val, self);\n\trb_hash_aset(env, rack_hijack_io_val, Qnil);\n\tif (agoo_server.rack_early_hints) {\n\t    volatile VALUE\teh = agoo_early_hints_new(req);\n\t    rb_hash_aset(env, early_hints_val, eh);\n\t}\n\treq->env = (void*)env;\n    }\n    return (VALUE)req->env;\n}", "target": 1}
{"code": "int hashbin_delete( hashbin_t* hashbin, FREE_FUNC free_func)\n{\n\tirda_queue_t* queue;\n\tunsigned long flags = 0;\n\tint i;\n\tIRDA_ASSERT(hashbin != NULL, return -1;);\n\tIRDA_ASSERT(hashbin->magic == HB_MAGIC, return -1;);\n\tif ( hashbin->hb_type & HB_LOCK ) {\n\t\tspin_lock_irqsave_nested(&hashbin->hb_spinlock, flags,\n\t\t\t\t\t hashbin_lock_depth++);\n\t}\n\tfor (i = 0; i < HASHBIN_SIZE; i ++ ) {\n\t\tqueue = dequeue_first((irda_queue_t**) &hashbin->hb_queue[i]);\n\t\twhile (queue ) {\n\t\t\tif (free_func)\n\t\t\t\t(*free_func)(queue);\n\t\t\tqueue = dequeue_first(\n\t\t\t\t(irda_queue_t**) &hashbin->hb_queue[i]);\n\t\t}\n\t}\n\thashbin->hb_current = NULL;\n\thashbin->magic = ~HB_MAGIC;\n\tif ( hashbin->hb_type & HB_LOCK) {\n\t\tspin_unlock_irqrestore(&hashbin->hb_spinlock, flags);\n#ifdef CONFIG_LOCKDEP\n\t\thashbin_lock_depth--;\n#endif\n\t}\n\tkfree(hashbin);\n\treturn 0;\n}", "target": 1}
{"code": "static void lwp_read(FILE *fin, std::string &buf) {\n  size_t len;\n  fread(&len, sizeof(len), 1, fin);\n  char *buffer = (char *)malloc(len + 1);\n  fread(buffer, sizeof(*buffer), len, fin);\n  buffer[len] = '\\0';\n  buf = std::string(buffer);\n  free(buffer);\n}", "target": 0}
{"code": "setup_efi_state(struct boot_params *params, unsigned long params_load_addr,\n\t\tunsigned int efi_map_offset, unsigned int efi_map_sz,\n\t\tunsigned int efi_setup_data_offset)\n{\n\tstruct efi_info *current_ei = &boot_params.efi_info;\n\tstruct efi_info *ei = &params->efi_info;\n\tif (!current_ei->efi_memmap_size)\n\t\treturn 0;\n\tif (efi_enabled(EFI_OLD_MEMMAP))\n\t\treturn 0;\n\tparams->secure_boot = boot_params.secure_boot;\n\tei->efi_loader_signature = current_ei->efi_loader_signature;\n\tei->efi_systab = current_ei->efi_systab;\n\tei->efi_systab_hi = current_ei->efi_systab_hi;\n\tei->efi_memdesc_version = current_ei->efi_memdesc_version;\n\tei->efi_memdesc_size = efi_get_runtime_map_desc_size();\n\tsetup_efi_info_memmap(params, params_load_addr, efi_map_offset,\n\t\t\t      efi_map_sz);\n\tprepare_add_efi_setup_data(params, params_load_addr,\n\t\t\t\t   efi_setup_data_offset);\n\treturn 0;\n}", "target": 0}
{"code": "static ssize_t compress(zckCtx *zck, zckComp *comp, const char *src,\n                        const size_t src_size, char **dst, size_t *dst_size,\n                        bool use_dict) {\n    VALIDATE_INT(zck);\n    ALLOCD_INT(zck, dst);\n    ALLOCD_INT(zck, src);\n    ALLOCD_INT(zck, dst_size);\n    ALLOCD_INT(zck, comp);\n    if((comp->dc_data_size > comp->dc_data_size + src_size) ||\n       (src_size > comp->dc_data_size + src_size)) {\n        zck_log(ZCK_LOG_ERROR, \"Integer overflow when reading decompressed data\");\n        return false;\n    }\n    comp->dc_data = zrealloc(comp->dc_data, comp->dc_data_size + src_size);\n    if (!comp->dc_data) {\n        zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n        return -1;\n    }\n    memcpy(comp->dc_data + comp->dc_data_size, src, src_size);\n    *dst = NULL;\n    *dst_size = 0;\n    return 0;\n}", "target": 0}
{"code": "static int sanitize_val_alu(struct bpf_verifier_env *env,\n\t\t\t    struct bpf_insn *insn)\n{\n\tstruct bpf_insn_aux_data *aux = cur_aux(env);\n\tif (can_skip_alu_sanitation(env, insn))\n\t\treturn 0;\n\treturn update_alu_sanitation_state(aux, BPF_ALU_NON_POINTER, 0);\n}", "target": 0}
{"code": "static int ras_getcmap(jas_stream_t *in, ras_hdr_t *hdr, ras_cmap_t *cmap)\n{\n\tint i;\n\tint j;\n\tint x;\n\tint c;\n\tint numcolors;\n\tint actualnumcolors;\n\tswitch (hdr->maptype) {\n\tcase RAS_MT_NONE:\n\t\tbreak;\n\tcase RAS_MT_EQUALRGB:\n\t\t{\n\t\tjas_eprintf(\"warning: palettized images not fully supported\\n\");\n\t\tnumcolors = 1 << hdr->depth;\n\t\tassert(numcolors <= RAS_CMAP_MAXSIZ);\n\t\tactualnumcolors = hdr->maplength / 3;\n\t\tfor (i = 0; i < numcolors; i++) {\n\t\t\tcmap->data[i] = 0;\n\t\t}\n\t\tif ((hdr->maplength % 3) || hdr->maplength < 0 ||\n\t\t  hdr->maplength > 3 * numcolors) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tfor (j = 0; j < actualnumcolors; j++) {\n\t\t\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tx = 0;\n\t\t\t\tswitch (i) {\n\t\t\t\tcase 0:\n\t\t\t\t\tx = RAS_RED(c);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tx = RAS_GREEN(c);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tx = RAS_BLUE(c);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcmap->data[j] |= x;\n\t\t\t}\n\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t\tbreak;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "  void writeErr(size_t, const AsyncSocketException& ex) noexcept override {\n    LOG(ERROR) << \"write error: \" << ex.what();\n    EXPECT_NE(\n        ex.getType(),\n        AsyncSocketException::AsyncSocketExceptionType::SSL_ERROR);\n  }", "target": 0}
{"code": "static void ram_block_add(struct uc_struct *uc, RAMBlock *new_block)\n{\n    RAMBlock *block;\n    RAMBlock *last_block = NULL;\n    new_block->offset = find_ram_offset(uc, new_block->max_length);\n    if (!new_block->host) {\n        new_block->host = phys_mem_alloc(uc, new_block->max_length,\n                &new_block->mr->align);\n        if (!new_block->host) {\n            return;\n        }\n    }\n    RAMBLOCK_FOREACH(block) {\n        last_block = block;\n        if (block->max_length < new_block->max_length) {\n            break;\n        }\n    }\n    if (block) {\n        QLIST_INSERT_BEFORE(block, new_block, next);\n    } else if (last_block) {\n        QLIST_INSERT_AFTER(last_block, new_block, next);\n    } else { \n        QLIST_INSERT_HEAD(&uc->ram_list.blocks, new_block, next);\n    }\n    uc->ram_list.mru_block = NULL;\n    cpu_physical_memory_set_dirty_range(new_block->offset,\n                                        new_block->used_length,\n                                        DIRTY_CLIENTS_ALL);\n}", "target": 1}
{"code": "static void vhost_vdpa_reset(struct vhost_vdpa *v)\n{\n\tstruct vdpa_device *vdpa = v->vdpa;\n\tvdpa_reset(vdpa);\n\tv->in_batch = 0;\n}", "target": 0}
{"code": "clamp_lab(const fz_colorspace *cs, const float *src, float *dst)\n{\n\tint i;\n\tfor (i = 0; i < 3; i++)\n\t\tdst[i] = fz_clamp(src[i], i ? -128 : 0, i ? 127 : 100);\n}", "target": 0}
{"code": "has_supported_extension (const char *name,\n\t\t\t GHashTable *supported_extensions)\n{\n\tgboolean ret = FALSE;\n\tgchar *suffix;\n\tsuffix = g_strrstr (name, \".\");\n\tif (!suffix)\n\t\treturn ret;\n\tsuffix = g_ascii_strdown (suffix + 1, -1);\n\tret = GPOINTER_TO_INT (g_hash_table_lookup (supported_extensions, suffix));\n\tg_free (suffix);\n\treturn ret;\n}", "target": 0}
{"code": " struct timespec ns_to_timespec(const s64 nsec)\n {\n \tstruct timespec ts;\n\ts32 rem;\n \tif (!nsec)\n \t\treturn (struct timespec) {0, 0};\n\tts.tv_sec = div_s64_rem(nsec, NSEC_PER_SEC, &rem);\n\tif (unlikely(rem < 0)) {\n\t\tts.tv_sec--;\n\t\trem += NSEC_PER_SEC;\n\t}\n\tts.tv_nsec = rem;\n \treturn ts;\n }", "target": 0}
{"code": "void dhcps_deinit(void)\n{\n\tif (dhcps_pcb != NULL) {\n\t\tudp_remove(dhcps_pcb);\n\t\tdhcps_pcb = NULL;\t\n\t}\n\tif (dhcps_ip_table_semaphore != NULL) {\t\n\t\tvSemaphoreDelete(dhcps_ip_table_semaphore);\n\t\tdhcps_ip_table_semaphore = NULL;\n\t}\t\t\n}", "target": 1}
{"code": "int vp9_alloc_context_buffers(VP9_COMMON *cm, int width, int height) {\n  int new_mi_size;\n  vp9_set_mb_mi(cm, width, height);\n  new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);\n  if (cm->mi_alloc_size < new_mi_size) {\n    cm->free_mi(cm);\n    if (cm->alloc_mi(cm, new_mi_size)) goto fail;\n  }\n  if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {\n    free_seg_map(cm);\n    if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols)) goto fail;\n  }\n  if (cm->above_context_alloc_cols < cm->mi_cols) {\n    vpx_free(cm->above_context);\n    cm->above_context = (ENTROPY_CONTEXT *)vpx_calloc(\n        2 * mi_cols_aligned_to_sb(cm->mi_cols) * MAX_MB_PLANE,\n        sizeof(*cm->above_context));\n    if (!cm->above_context) goto fail;\n    vpx_free(cm->above_seg_context);\n    cm->above_seg_context = (PARTITION_CONTEXT *)vpx_calloc(\n        mi_cols_aligned_to_sb(cm->mi_cols), sizeof(*cm->above_seg_context));\n    if (!cm->above_seg_context) goto fail;\n    cm->above_context_alloc_cols = cm->mi_cols;\n  }\n  if (vp9_alloc_loop_filter(cm)) goto fail;\n  return 0;\nfail:\n  vp9_set_mb_mi(cm, 0, 0);\n  vp9_free_context_buffers(cm);\n  return 1;\n}", "target": 1}
{"code": "static int nfc_genl_llc_get_params(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tstruct nfc_llcp_local *local;\n\tint rc = 0;\n\tstruct sk_buff *msg = NULL;\n\tu32 idx;\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_FIRMWARE_NAME])\n\t\treturn -EINVAL;\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\tdevice_lock(&dev->dev);\n\tlocal = nfc_llcp_find_local(dev);\n\tif (!local) {\n\t\trc = -ENODEV;\n\t\tgoto exit;\n\t}\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg) {\n\t\trc = -ENOMEM;\n\t\tgoto exit;\n\t}\n\trc = nfc_genl_send_params(msg, local, info->snd_portid, info->snd_seq);\nexit:\n\tdevice_unlock(&dev->dev);\n\tnfc_put_device(dev);\n\tif (rc < 0) {\n\t\tif (msg)\n\t\t\tnlmsg_free(msg);\n\t\treturn rc;\n\t}\n\treturn genlmsg_reply(msg, info);\n}", "target": 1}
{"code": "static int js_doregexec(js_State *J, Reprog *prog, const char *string, Resub *sub, int eflags)\n{\n\tint result = js_regexec(prog, string, sub, eflags);\n\tif (result < 0)\n\t\tjs_error(J, \"regexec failed\");\n\treturn result;\n}", "target": 0}
{"code": "void svhandler_flash_pgm_blk(void) {\n  uint32_t beginAddr = _param_1;\n  uint32_t data = _param_2;\n  uint32_t length = _param_3;\n  if (beginAddr + length < beginAddr) return;\n  if (((beginAddr >= BSTRP_FLASH_SECT_START) &&\n       (beginAddr <= (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN - 1))) ||\n      (((beginAddr + length) >= BSTRP_FLASH_SECT_START) &&\n       ((beginAddr + length) <=\n        (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN - 1)))) {\n    return;\n  }\n  if (((beginAddr >= BLDR_FLASH_SECT_START) &&\n       (beginAddr <= (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN - 1))) ||\n      (((beginAddr + length) >= BLDR_FLASH_SECT_START) &&\n       ((beginAddr + length) <=\n        (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN - 1)))) {\n    return;\n  }\n  flash_clear_status_flags();\n  flash_unlock();\n  flash_program(beginAddr, (uint8_t *)data, length);\n  _param_1 = !!flash_chk_status();\n  _param_2 = 0;\n  _param_3 = 0;\n  flash_wait_for_last_operation();\n  FLASH_CR &= ~FLASH_CR_PG;\n  FLASH_CR |= FLASH_CR_LOCK;\n}", "target": 1}
{"code": "static void dnsserver_reload_zones(struct dnsserver_state *dsstate)\n{\n\tstruct dnsserver_partition *p;\n\tstruct dnsserver_zone *zones, *z, *znext, *zmatch;\n\tstruct dnsserver_zone *old_list, *new_list;\n\told_list = dsstate->zones;\n\tnew_list = NULL;\n\tfor (p = dsstate->partitions; p; p = p->next) {\n\t\tzones = dnsserver_db_enumerate_zones(dsstate, dsstate->samdb, p);\n\t\tif (zones == NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (z = zones; z; ) {\n\t\t\tznext = z->next;\n\t\t\tzmatch = dnsserver_find_zone(old_list, z->name);\n\t\t\tif (zmatch == NULL) {\n\t\t\t\tz->zoneinfo = dnsserver_init_zoneinfo(z, dsstate->serverinfo);\n\t\t\t\tif (z->zoneinfo == NULL) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tDLIST_ADD_END(new_list, z);\n\t\t\t\tp->zones_count++;\n\t\t\t\tdsstate->zones_count++;\n\t\t\t} else {\n\t\t\t\ttalloc_free(z);\n\t\t\t\tDLIST_REMOVE(old_list, zmatch);\n\t\t\t\tDLIST_ADD_END(new_list, zmatch);\n\t\t\t}\n\t\t\tz = znext;\n\t\t}\n\t}\n\tif (new_list == NULL) {\n\t\treturn;\n\t}\n\tfor (z = old_list; z; ) {\n\t\tznext = z->next;\n\t\tz->partition->zones_count--;\n\t\tdsstate->zones_count--;\n\t\ttalloc_free(z);\n\t\tz = znext;\n\t}\n\tdsstate->zones = new_list;\n}", "target": 0}
{"code": "TEST_F(PlaintextRecordTest, TestSkipOversizedRecord) {\n  read_.setSkipEncryptedRecords(true);\n  addToQueue(\"170301fffb\");\n  auto longBuf = IOBuf::create(0xfffb);\n  longBuf->append(0xfffb);\n  queue_.append(std::move(longBuf));\n  EXPECT_FALSE(read_.read(queue_).hasValue());\n  EXPECT_TRUE(queue_.empty());\n}", "target": 0}
{"code": "static int attach_link(LINK_HANDLE link, ON_ENDPOINT_FRAME_RECEIVED* on_frame_received)\n{\n    umock_c_reset_all_calls();\n    STRICT_EXPECTED_CALL(session_begin(TEST_SESSION_HANDLE));\n    STRICT_EXPECTED_CALL(session_start_link_endpoint(TEST_LINK_ENDPOINT, IGNORED_PTR_ARG, IGNORED_PTR_ARG, IGNORED_PTR_ARG, link))\n        .CaptureArgumentValue_frame_received_callback(on_frame_received);\n    return link_attach(link, test_on_transfer_received, test_on_link_state_changed, test_on_link_flow_on, NULL);\n}", "target": 0}
{"code": "static void write_cb(struct bt_att_chan *chan, uint8_t opcode, const void *pdu,\n\t\t\t\t\tuint16_t length, void *user_data)\n{\n\tstruct bt_gatt_server *server = user_data;\n\tstruct gatt_db_attribute *attr;\n\tuint16_t handle = 0;\n\tstruct async_write_op *op = NULL;\n\tuint8_t ecode;\n\tif (length < 2) {\n\t\tecode = BT_ATT_ERROR_INVALID_PDU;\n\t\tgoto error;\n\t}\n\tecode = authorize_req(server, opcode, handle);\n\tif (ecode)\n\t\tgoto error;\n\thandle = get_le16(pdu);\n\tattr = gatt_db_get_attribute(server->db, handle);\n\tif (!attr) {\n\t\tecode = BT_ATT_ERROR_INVALID_HANDLE;\n\t\tgoto error;\n\t}\n\tutil_debug(server->debug_callback, server->debug_data,\n\t\t\t\t\"Write %s - handle: 0x%04x\",\n\t\t\t\t(opcode == BT_ATT_OP_WRITE_REQ) ? \"Req\" : \"Cmd\",\n\t\t\t\thandle);\n\tecode = check_length(length, 0);\n\tif (ecode)\n\t\tgoto error;\n\tecode = check_permissions(server, attr, BT_ATT_PERM_WRITE_MASK);\n\tif (ecode)\n\t\tgoto error;\n\top = new0(struct async_write_op, 1);\n\top->chan = chan;\n\top->server = bt_gatt_server_ref(server);\n\top->opcode = opcode;\n\tif (gatt_db_attribute_write(attr, 0, pdu + 2, length - 2, opcode,\n\t\t\t\t\t\t\tserver->att,\n\t\t\t\t\t\t\twrite_complete_cb, op))\n\t\treturn;\n\tasync_write_op_destroy(op);\n\tecode = BT_ATT_ERROR_UNLIKELY;\nerror:\n\tif (opcode == BT_ATT_OP_WRITE_CMD)\n\t\treturn;\n\tbt_att_chan_send_error_rsp(chan, opcode, handle, ecode);\n}", "target": 0}
{"code": "void ldapsrv_recv(struct stream_connection *c, uint16_t flags)\n{\n\tsmb_panic(__location__);\n}", "target": 0}
{"code": "static void xen_free_irq(unsigned irq)\n{\n\tstruct irq_info *info = info_for_irq(irq);\n\tunsigned long flags;\n\tif (WARN_ON(!info))\n\t\treturn;\n\twrite_lock_irqsave(&evtchn_rwlock, flags);\n\tlist_del(&info->list);\n\tset_info_for_irq(irq, NULL);\n\tWARN_ON(info->refcnt > 0);\n\twrite_unlock_irqrestore(&evtchn_rwlock, flags);\n\tkfree(info);\n\tif (irq < nr_legacy_irqs())\n\t\treturn;\n\tirq_free_desc(irq);\n}", "target": 0}
{"code": "bool HTMLTextAreaElement::hasCustomFocusLogic() const\n{\n    return true;\n}", "target": 0}
{"code": "has_supported_extension (const char *name,\n\t\t\t GHashTable *supported_extensions)\n{\n\tgboolean ret = FALSE;\n\tgchar *suffix;\n\tsuffix = g_strrstr (name, \".\");\n\tif (!suffix)\n\t\treturn ret;\n\tsuffix = g_ascii_strdown (suffix + 1, -1);\n\tret = GPOINTER_TO_INT (g_hash_table_lookup (supported_extensions, suffix));\n\tg_free (suffix);\n\treturn ret;\n}", "target": 0}
{"code": "bool ExtractUnixLink30(CommandData *Cmd,ComprDataIO &DataIO,Archive &Arc,const wchar *LinkName)\n{\n  char Target[NM];\n  if (IsLink(Arc.FileHead.FileAttr))\n  {\n    size_t DataSize=(size_t)Arc.FileHead.PackSize;\n    if (DataSize>ASIZE(Target)-1)\n      return false;\n    if ((size_t)DataIO.UnpRead((byte *)Target,DataSize)!=DataSize)\n      return false;\n    Target[DataSize]=0;\n    DataIO.UnpHash.Init(Arc.FileHead.FileHash.Type,1);\n    DataIO.UnpHash.Update(Target,strlen(Target));\n    DataIO.UnpHash.Result(&Arc.FileHead.FileHash);\n    if (!DataIO.UnpHash.Cmp(&Arc.FileHead.FileHash,Arc.FileHead.UseHashKey ? Arc.FileHead.HashKey:NULL))\n      return true;\n    wchar TargetW[NM];\n    if (!SafeCharToWide(Target,TargetW,ASIZE(TargetW)))\n      return false;\n    if (!Cmd->AbsoluteLinks && (IsFullPath(TargetW) ||\n        !IsRelativeSymlinkSafe(Cmd,Arc.FileHead.FileName,LinkName,TargetW)))\n      return false;\n    return UnixSymlink(Cmd,Target,LinkName,&Arc.FileHead.mtime,&Arc.FileHead.atime);\n  }\n  return false;\n}", "target": 1}
{"code": "disconnect_ice_connection (IceConn ice_conn)\n{\n        IceSetShutdownNegotiation (ice_conn, FALSE);\n        IceCloseConnection (ice_conn);\n}", "target": 0}
{"code": "static __u8 *nci_extract_rf_params_nfcf_passive_poll(struct nci_dev *ndev,\n\t\t\tstruct rf_tech_specific_params_nfcf_poll *nfcf_poll,\n\t\t\t\t\t\t     __u8 *data)\n{\n\tnfcf_poll->bit_rate = *data++;\n\tnfcf_poll->sensf_res_len = *data++;\n\tpr_debug(\"bit_rate %d, sensf_res_len %d\\n\",\n\t\t nfcf_poll->bit_rate, nfcf_poll->sensf_res_len);\n\tmemcpy(nfcf_poll->sensf_res, data, nfcf_poll->sensf_res_len);\n\tdata += nfcf_poll->sensf_res_len;\n\treturn data;\n}", "target": 1}
{"code": "static void get_sem_elements(struct sem_data *p)\n{\n\tsize_t i;\n\tif (!p || !p->sem_nsems || p->sem_perm.id < 0)\n\t\treturn;\n\tp->elements = xcalloc(p->sem_nsems, sizeof(struct sem_elem));\n\tfor (i = 0; i < p->sem_nsems; i++) {\n\t\tstruct sem_elem *e = &p->elements[i];\n\t\tunion semun arg = { .val = 0 };\n\t\te->semval = semctl(p->sem_perm.id, i, GETVAL, arg);\n\t\tif (e->semval < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETVAL)\");\n\t\te->ncount = semctl(p->sem_perm.id, i, GETNCNT, arg);\n\t\tif (e->ncount < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETNCNT)\");\n\t\te->zcount = semctl(p->sem_perm.id, i, GETZCNT, arg);\n\t\tif (e->zcount < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETZCNT)\");\n\t\te->pid = semctl(p->sem_perm.id, i, GETPID, arg);\n\t\tif (e->pid < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETPID)\");\n\t}\n}", "target": 1}
{"code": "void OmniboxViewWin::BuildContextMenu() {\n  if (context_menu_contents_.get())\n    return;\n  context_menu_contents_.reset(new ui::SimpleMenuModel(this));\n  if (popup_window_mode_) {\n    context_menu_contents_->AddItemWithStringId(IDC_COPY, IDS_COPY);\n  } else {\n    context_menu_contents_->AddItemWithStringId(IDS_UNDO, IDS_UNDO);\n    context_menu_contents_->AddSeparator();\n    context_menu_contents_->AddItemWithStringId(IDC_CUT, IDS_CUT);\n    context_menu_contents_->AddItemWithStringId(IDC_COPY, IDS_COPY);\n    context_menu_contents_->AddItemWithStringId(IDC_PASTE, IDS_PASTE);\n    context_menu_contents_->AddItemWithStringId(IDS_PASTE_AND_GO,\n                                                IDS_PASTE_AND_GO);\n    context_menu_contents_->AddSeparator();\n    context_menu_contents_->AddItemWithStringId(IDS_SELECT_ALL, IDS_SELECT_ALL);\n    context_menu_contents_->AddSeparator();\n    context_menu_contents_->AddItemWithStringId(IDS_EDIT_SEARCH_ENGINES,\n                                                IDS_EDIT_SEARCH_ENGINES);\n  }\n  context_menu_.reset(new views::Menu2(context_menu_contents_.get()));\n}", "target": 0}
{"code": "static void __timerfd_remove_cancel(struct timerfd_ctx *ctx)\n{\n\tif (ctx->might_cancel) {\n\t\tctx->might_cancel = false;\n\t\tspin_lock(&cancel_lock);\n\t\tlist_del_rcu(&ctx->clist);\n\t\tspin_unlock(&cancel_lock);\n\t}\n}", "target": 0}
{"code": "static int stellaris_enet_load(QEMUFile *f, void *opaque, int version_id)\n{\n    stellaris_enet_state *s = (stellaris_enet_state *)opaque;\n    int i;\n    if (version_id != 1)\n        return -EINVAL;\n    s->ris = qemu_get_be32(f);\n    s->im = qemu_get_be32(f);\n    s->rctl = qemu_get_be32(f);\n    s->tctl = qemu_get_be32(f);\n    s->thr = qemu_get_be32(f);\n    s->mctl = qemu_get_be32(f);\n    s->mdv = qemu_get_be32(f);\n    s->mtxd = qemu_get_be32(f);\n    s->mrxd = qemu_get_be32(f);\n    s->np = qemu_get_be32(f);\n    s->tx_fifo_len = qemu_get_be32(f);\n    qemu_get_buffer(f, s->tx_fifo, sizeof(s->tx_fifo));\n    for (i = 0; i < 31; i++) {\n        s->rx[i].len = qemu_get_be32(f);\n        qemu_get_buffer(f, s->rx[i].data, sizeof(s->rx[i].data));\n    }\n    s->next_packet = qemu_get_be32(f);\n    s->rx_fifo_offset = qemu_get_be32(f);\n    return 0;\n}", "target": 1}
{"code": "  bool isReference() const { return type() == Type::Reference; }", "target": 0}
{"code": "force_removal (Device *device,\n               ForceRemovalCompleteFunc callback,\n               gpointer user_data)\n{\n  if (device->priv->device_is_mounted && device->priv->device_mount_paths->len > 0)\n    {\n      gboolean remove_dir_on_unmount;\n      if (mount_file_has_device (device->priv->device_file, NULL, &remove_dir_on_unmount) ||\n          is_device_in_fstab (device, NULL))\n        {\n          g_print (\"**** NOTE: Force unmounting device %s\\n\", device->priv->device_file);\n          force_unmount (device, callback, user_data);\n          goto pending;\n        }\n    }\n  if (device->priv->id_usage != NULL && strcmp (device->priv->id_usage, \"crypto\") == 0)\n    {\n      GList *devices;\n      GList *l;\n      devices = daemon_local_get_all_devices (device->priv->daemon);\n      for (l = devices; l != NULL; l = l->next)\n        {\n          Device *d = DEVICE (l->data);\n          if (d->priv->device_is_luks_cleartext && d->priv->luks_cleartext_slave != NULL\n              && strcmp (d->priv->luks_cleartext_slave, device->priv->object_path) == 0)\n            {\n              if (d->priv->dm_name != NULL && g_str_has_prefix (d->priv->dm_name, \"udisks-luks-uuid-\"))\n                {\n                  g_print (\"**** NOTE: Force luks teardown device %s (cleartext %s)\\n\",\n                           device->priv->device_file,\n                           d->priv->device_file);\n                  force_luks_teardown (device, d, callback, user_data);\n                  goto pending;\n                }\n            }\n        }\n    }\n  if (callback != NULL)\n    callback (device, TRUE, user_data);\n pending:\n  ;\n}", "target": 0}
{"code": "TfLiteTensor* GetOutput(TfLiteContext* context, const TfLiteNode* node,\n                        int index) {\n  const int tensor_index = ValidateTensorIndexing(\n      context, index, node->outputs->size, node->outputs->data);\n  if (tensor_index < 0) {\n    return nullptr;\n  }\n  return GetTensorAtIndex(context, tensor_index);\n}", "target": 0}
{"code": "smb2_flush(smb_request_t *sr)\n{\n\tsmb_ofile_t *of = NULL;\n\tuint16_t StructSize;\n\tuint16_t reserved1;\n\tuint32_t reserved2;\n\tsmb2fid_t smb2fid;\n\tuint32_t status;\n\tint rc = 0;\n\trc = smb_mbc_decodef(\n\t    &sr->smb_data, \"wwlqq\",\n\t    &StructSize,\t\t\n\t    &reserved1,\t\t\t\n\t    &reserved2,\t\t\t\n\t    &smb2fid.persistent,\t\n\t    &smb2fid.temporal);\t\t\n\tif (rc)\n\t\treturn (SDRC_ERROR);\n\tif (StructSize != 24)\n\t\treturn (SDRC_ERROR);\n\tstatus = smb2sr_lookup_fid(sr, &smb2fid);\n\tif (status) {\n\t\tsmb2sr_put_error(sr, status);\n\t\treturn (SDRC_SUCCESS);\n\t}\n\tof = sr->fid_ofile;\n\tif ((of->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)\n\t\t(void) smb_fsop_commit(sr, of->f_cr, of->f_node);\n\t(void) smb_mbc_encodef(\n\t    &sr->reply, \"wwl\",\n\t    4,\t\t\n\t    0); \t\t\n\treturn (SDRC_SUCCESS);\n}", "target": 1}
{"code": "v8::Handle<v8::Value> V8DOMWindow::addEventListenerMethodCustom(const v8::Arguments& args)\n{\n    String eventType = toWebCoreString(args[0]);\n    bool useCapture = args[2]->BooleanValue();\n    DOMWindow* imp = V8DOMWindow::toNative(args.Holder());\n    if (!BindingSecurity::shouldAllowAccessToFrame(imp->frame()))\n        return v8::Undefined();\n    Document* doc = imp->document();\n    if (!doc)\n        return v8::Undefined();\n    if (!imp->frame())\n        return v8::Undefined();\n    RefPtr<EventListener> listener = V8EventListenerList::getEventListener(args[1], false, ListenerFindOrCreate);\n    if (listener) {\n        imp->addEventListener(eventType, listener, useCapture);\n        createHiddenDependency(args.Holder(), args[1], eventListenerCacheIndex, args.GetIsolate());\n    }\n    return v8::Undefined();\n}", "target": 0}
{"code": "rpl_dao_print(netdissect_options *ndo,\n              const u_char *bp, u_int length)\n{\n        const struct nd_rpl_dao *dao = (const struct nd_rpl_dao *)bp;\n        const char *dagid_str = \"<elided>\";\n        ND_TCHECK(*dao);\n        if (length < ND_RPL_DAO_MIN_LEN)\n        \tgoto tooshort;\n        bp += ND_RPL_DAO_MIN_LEN;\n        length -= ND_RPL_DAO_MIN_LEN;\n        if(RPL_DAO_D(dao->rpl_flags)) {\n                ND_TCHECK2(dao->rpl_dagid, DAGID_LEN);\n                if (length < DAGID_LEN)\n                \tgoto tooshort;\n                dagid_str = ip6addr_string (ndo, dao->rpl_dagid);\n                bp += DAGID_LEN;\n                length -= DAGID_LEN;\n        }\n        ND_PRINT((ndo, \" [dagid:%s,seq:%u,instance:%u%s%s,%02x]\",\n                  dagid_str,\n                  dao->rpl_daoseq,\n                  dao->rpl_instanceid,\n                  RPL_DAO_K(dao->rpl_flags) ? \",acK\":\"\",\n                  RPL_DAO_D(dao->rpl_flags) ? \",Dagid\":\"\",\n                  dao->rpl_flags));\n        if(ndo->ndo_vflag > 1) {\n                const struct rpl_dio_genoption *opt = (const struct rpl_dio_genoption *)bp;\n                rpl_dio_printopt(ndo, opt, length);\n        }\n\treturn;\ntrunc:\n\tND_PRINT((ndo,\" [|truncated]\"));\n\treturn;\ntooshort:\n\tND_PRINT((ndo,\" [|length too short]\"));\n\treturn;\n}", "target": 1}
{"code": "void Polygon::Insert( sal_uInt16 nPos, const Point& rPt )\n{\n    ImplMakeUnique();\n    if( nPos >= mpImplPolygon->mnPoints )\n        nPos = mpImplPolygon->mnPoints;\n    mpImplPolygon->ImplSplit( nPos, 1 );\n    mpImplPolygon->mpPointAry[ nPos ] = rPt;\n}", "target": 1}
{"code": "void* CxImage::Create(uint32_t dwWidth, uint32_t dwHeight, uint32_t wBpp, uint32_t imagetype)\n{\n\tif (!Destroy())\n\t\treturn NULL;\n\tif ((dwWidth == 0) || (dwHeight == 0)){\n\t\tstrcpy(info.szLastError,\"CxImage::Create : width and height must be greater than zero\");\n\t\treturn NULL;\n\t}\n    if\t\t(wBpp <= 1)\twBpp = 1;\n    else if (wBpp <= 4)\twBpp = 4;\n    else if (wBpp <= 8)\twBpp = 8;\n    else\t\t\t\twBpp = 24;\n\tif ((((float)dwWidth*(float)dwHeight*(float)wBpp)/8.0f) > (float)CXIMAGE_MAX_MEMORY)\n\t{\n\t\tstrcpy(info.szLastError,\"CXIMAGE_MAX_MEMORY exceeded\");\n\t\treturn NULL;\n\t}\n    switch (wBpp){\n        case 1:\n            head.biClrUsed = 2;\tbreak;\n        case 4:\n            head.biClrUsed = 16; break;\n        case 8:\n            head.biClrUsed = 256; break;\n        default:\n            head.biClrUsed = 0;\n    }\n    info.dwEffWidth = ((((wBpp * dwWidth) + 31) / 32) * 4);\n    info.dwType = imagetype;\n\thead.biSize = sizeof(BITMAPINFOHEADER); \n    head.biWidth = dwWidth;\t\t\n    head.biHeight = dwHeight;\t\n    head.biPlanes = 1;\t\t\t\n    head.biBitCount = (uint16_t)wBpp;\t\t\n    head.biCompression = BI_RGB;    \n    head.biSizeImage = info.dwEffWidth * dwHeight;\n\tpDib = malloc(GetSize()); \n    if (!pDib){\n\t\tstrcpy(info.szLastError,\"CxImage::Create can't allocate memory\");\n\t\treturn NULL;\n\t}\n    pDibLimit = (void*)((uint8_t*)pDib + GetSize());\n\tRGBQUAD* pal=GetPalette();\n\tif (pal) memset(pal,0,GetPaletteSize());\n#if CXIMAGE_SUPPORT_SELECTION\n\tif (pSelection) SelectionDelete();\n#endif \n#if CXIMAGE_SUPPORT_ALPHA\n\tif (pAlpha) AlphaDelete();\n#endif \n    BITMAPINFOHEADER*  lpbi;\n\tlpbi = (BITMAPINFOHEADER*)(pDib);\n    *lpbi = head;\n\tinfo.pImage=GetBits();\n    return pDib; \n}", "target": 0}
{"code": "TEST_CASE(\"Start rule with ignore operator test\", \"[general]\")\n{\n    parser parser(R\"(\n        ~ROOT <- _\n        _ <- ' '\n    )\");\n    bool ret = parser;\n    REQUIRE(ret == false);\n}", "target": 0}
{"code": "disable_priv_mode ()\n{\n  int e;\n#if HAVE_DECL_SETRESUID\n  if (setresuid (current_user.uid, current_user.uid, current_user.uid) < 0)\n#else\n  if (setuid (current_user.uid) < 0)\n#endif\n    {\n      e = errno;\n      sys_error (_(\"cannot set uid to %d: effective uid %d\"), current_user.uid, current_user.euid);\n#if defined (EXIT_ON_SETUID_FAILURE)\n      if (e == EAGAIN)\n\texit (e);\n#endif\n    }\n#if HAVE_DECL_SETRESGID\n  if (setresgid (current_user.gid, current_user.gid, current_user.gid) < 0)\n#else\n  if (setgid (current_user.gid) < 0)\n#endif\n    sys_error (_(\"cannot set gid to %d: effective gid %d\"), current_user.gid, current_user.egid);\n  current_user.euid = current_user.uid;\n  current_user.egid = current_user.gid;\n}", "target": 0}
{"code": "int CServer::SendMsg(CMsgPacker *pMsg, int Flags, int ClientID)\n{\n\tCNetChunk Packet;\n\tif(!pMsg)\n\t\treturn -1;\n\tif(0 <= ClientID && ClientID < MAX_CLIENTS && GameServer()->IsClientBot(ClientID))\n\t\treturn 0;\n\tmem_zero(&Packet, sizeof(CNetChunk));\n\tPacket.m_ClientID = ClientID;\n\tPacket.m_pData = pMsg->Data();\n\tPacket.m_DataSize = pMsg->Size();\n\tif(Flags&MSGFLAG_VITAL)\n\t\tPacket.m_Flags |= NETSENDFLAG_VITAL;\n\tif(Flags&MSGFLAG_FLUSH)\n\t\tPacket.m_Flags |= NETSENDFLAG_FLUSH;\n\tif(!(Flags&MSGFLAG_NORECORD))\n\t\tm_DemoRecorder.RecordMessage(pMsg->Data(), pMsg->Size());\n\tif(!(Flags&MSGFLAG_NOSEND))\n\t{\n\t\tif(ClientID == -1)\n\t\t{\n\t\t\tint i;\n\t\t\tfor(i = 0; i < MAX_CLIENTS; i++)\n\t\t\t\tif(m_aClients[i].m_State == CClient::STATE_INGAME && !m_aClients[i].m_Quitting)\n\t\t\t\t{\n\t\t\t\t\tPacket.m_ClientID = i;\n\t\t\t\t\tm_NetServer.Send(&Packet);\n\t\t\t\t}\n\t\t}\n\t\telse\n\t\t\tm_NetServer.Send(&Packet);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void DoEmbedProfile(const char* ProfileFile)\n{\n    FILE* f;\n    size_t size, EmbedLen;\n    cmsUInt8Number* EmbedBuffer;\n        f = fopen(ProfileFile, \"rb\");\n        if (f == NULL) return;\n        size = cmsfilelength(f);\n        EmbedBuffer = (cmsUInt8Number*) malloc(size + 1);\n        EmbedLen = fread(EmbedBuffer, 1, size, f);\n        fclose(f);\n        EmbedBuffer[EmbedLen] = 0;\n        write_icc_profile (&Compressor, EmbedBuffer, EmbedLen);\n        free(EmbedBuffer);\n}", "target": 0}
{"code": "static ssize_t exitcode_proc_write(struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\tchar *end, buf[sizeof(\"nnnnn\\0\")];\n\tint tmp;\n\tif (copy_from_user(buf, buffer, count))\n\t\treturn -EFAULT;\n\ttmp = simple_strtol(buf, &end, 0);\n\tif ((*end != '\\0') && !isspace(*end))\n\t\treturn -EINVAL;\n\tuml_exitcode = tmp;\n\treturn count;\n}", "target": 1}
{"code": "*/\nPHP_FUNCTION(date_sub)\n{\n\tzval *object, *interval;\n\tif (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), \"OO\", &object, date_ce_date, &interval, date_ce_interval) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tphp_date_sub(object, interval, return_value TSRMLS_CC);\n\tRETURN_ZVAL(object, 1, 0);", "target": 0}
{"code": "static int filter_frame(AVFilterLink *inlink, AVFrame *frame)\n{\n    AVFilterContext   *ctx     = inlink->dst;\n    FieldOrderContext *s       = ctx->priv;\n    AVFilterLink      *outlink = ctx->outputs[0];\n    int h, plane, line_step, line_size, line;\n    uint8_t *data;\n    if (!frame->interlaced_frame ||\n        frame->top_field_first == s->dst_tff)\n        return ff_filter_frame(outlink, frame);\n    av_dlog(ctx,\n            \"picture will move %s one line\\n\",\n            s->dst_tff ? \"up\" : \"down\");\n    h = frame->height;\n    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {\n        line_step = frame->linesize[plane];\n        line_size = s->line_size[plane];\n        data = frame->data[plane];\n        if (s->dst_tff) {\n            for (line = 0; line < h; line++) {\n                if (1 + line < frame->height) {\n                    memcpy(data, data + line_step, line_size);\n                } else {\n                    memcpy(data, data - line_step - line_step, line_size);\n                }\n                data += line_step;\n            }\n        } else {\n            data += (h - 1) * line_step;\n            for (line = h - 1; line >= 0 ; line--) {\n                if (line > 0) {\n                    memcpy(data, data - line_step, line_size);\n                } else {\n                    memcpy(data, data + line_step + line_step, line_size);\n                }\n                data -= line_step;\n            }\n        }\n    }\n    frame->top_field_first = s->dst_tff;\n    return ff_filter_frame(outlink, frame);\n}", "target": 1}
{"code": "Item *Item_hex_constant::safe_charset_converter(CHARSET_INFO *tocs)\n{\n  Item_string *conv;\n  String tmp, *str= val_str(&tmp);\n  if (!(conv= new Item_string(str->ptr(), str->length(), tocs)))\n    return NULL;\n  conv->str_value.copy();\n  conv->str_value.mark_as_const();\n  return conv;\n}", "target": 0}
{"code": "static int encrypt(struct blkcipher_desc *desc,\n\t\t   struct scatterlist *dst, struct scatterlist *src,\n\t\t   unsigned int nbytes)\n{\n\tstruct blkcipher_walk walk;\n\tstruct crypto_blkcipher *tfm = desc->tfm;\n\tstruct salsa20_ctx *ctx = crypto_blkcipher_ctx(tfm);\n\tint err;\n\tblkcipher_walk_init(&walk, dst, src, nbytes);\n\terr = blkcipher_walk_virt_block(desc, &walk, 64);\n\tsalsa20_ivsetup(ctx, walk.iv);\n\tif (likely(walk.nbytes == nbytes))\n\t{\n\t\tsalsa20_encrypt_bytes(ctx, walk.dst.virt.addr,\n\t\t\t\t      walk.src.virt.addr, nbytes);\n\t\treturn blkcipher_walk_done(desc, &walk, 0);\n\t}\n\twhile (walk.nbytes >= 64) {\n\t\tsalsa20_encrypt_bytes(ctx, walk.dst.virt.addr,\n\t\t\t\t      walk.src.virt.addr,\n\t\t\t\t      walk.nbytes - (walk.nbytes % 64));\n\t\terr = blkcipher_walk_done(desc, &walk, walk.nbytes % 64);\n\t}\n\tif (walk.nbytes) {\n\t\tsalsa20_encrypt_bytes(ctx, walk.dst.virt.addr,\n\t\t\t\t      walk.src.virt.addr, walk.nbytes);\n\t\terr = blkcipher_walk_done(desc, &walk, 0);\n\t}\n\treturn err;\n}", "target": 1}
{"code": "_dl_dst_count (const char *name, int is_path)\n{\n  size_t cnt = 0;\n  do\n    {\n      size_t len = 1;\n      if ((((!__libc_enable_secure\n\t     && strncmp (&name[1], \"ORIGIN\", 6) == 0 && (len = 7) != 0)\n\t    || (strncmp (&name[1], \"PLATFORM\", 8) == 0 && (len = 9) != 0))\n\t   && (name[len] == '\\0' || name[len] == '/'\n\t       || (is_path && name[len] == ':')))\n\t  || (name[1] == '{'\n\t      && ((!__libc_enable_secure\n\t\t   && strncmp (&name[2], \"ORIGIN}\", 7) == 0 && (len = 9) != 0)\n\t\t  || (strncmp (&name[2], \"PLATFORM}\", 9) == 0\n\t\t      && (len = 11) != 0))))\n\t++cnt;\n      name = strchr (name + len, '$');\n    }\n  while (name != NULL);\n  return cnt;\n}", "target": 1}
{"code": "test_all_FFs_set_handler(void **state)\n{\n    (void) state;\n    Tss2_RC_SetHandler(0xFF, \"garbage\", custom_err_handler);\n    Tss2_RC_SetHandler(0xFF, NULL, NULL);\n}", "target": 0}
{"code": "prepenv(const struct rule *rule)\n{\n\tstatic const char *safeset[] = {\n\t\t\"DISPLAY\", \"HOME\", \"LOGNAME\", \"MAIL\",\n\t\t\"PATH\", \"TERM\", \"USER\", \"USERNAME\",\n\t\tNULL\n\t};\n\tstruct env *env;\n\tenv = createenv(rule);\n\tif (!(rule->options & KEEPENV))\n\t\tfillenv(env, safeset);\n\tif (rule->envlist)\n\t\tfillenv(env, rule->envlist);\n\treturn flattenenv(env);\n}", "target": 1}
{"code": "void RenderView::InsertCSS(const std::wstring& frame_xpath,\n                           const std::string& css,\n                           const std::string& id) {\n  WebFrame* web_frame = GetChildFrame(frame_xpath);\n  if (!web_frame)\n    return;\n  web_frame->insertStyleText(WebString::fromUTF8(css), WebString::fromUTF8(id));\n}", "target": 0}
{"code": "mm_answer_pam_free_ctx(int sock, Buffer *m)\n{\n\tdebug3(\"%s\", __func__);\n\t(sshpam_device.free_ctx)(sshpam_ctxt);\n\tbuffer_clear(m);\n\tmm_request_send(sock, MONITOR_ANS_PAM_FREE_CTX, m);\n\tauth_method = \"keyboard-interactive\";\n\tauth_submethod = \"pam\";\n\treturn (sshpam_authok == sshpam_ctxt);\n}", "target": 1}
{"code": "int oidc_handle_redirect_uri_request(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\tif (oidc_proto_is_redirect_authorization_response(r, c)) {\n\t\treturn oidc_handle_redirect_authorization_response(r, c, session);\n\t} else if (oidc_proto_is_post_authorization_response(r, c)) {\n\t\treturn oidc_handle_post_authorization_response(r, c, session);\n\t} else if (oidc_is_discovery_response(r, c)) {\n\t\treturn oidc_handle_discovery_response(r, c);\n\t} else if (oidc_util_request_has_parameter(r, \"logout\")) {\n\t\treturn oidc_handle_logout(r, c, session);\n\t} else if (oidc_util_request_has_parameter(r, \"jwks\")) {\n\t\treturn oidc_handle_jwks(r, c);\n\t} else if (oidc_util_request_has_parameter(r, \"session\")) {\n\t\treturn oidc_handle_session_management(r, c, session);\n\t} else if (oidc_util_request_has_parameter(r, \"refresh\")) {\n\t\treturn oidc_handle_refresh_token_request(r, c, session);\n\t} else if (oidc_util_request_has_parameter(r, \"request_uri\")) {\n\t\treturn oidc_handle_request_uri(r, c);\n\t} else if (oidc_util_request_has_parameter(r, \"remove_at_cache\")) {\n\t\treturn oidc_handle_remove_at_cache(r, c);\n\t} else if ((r->args == NULL) || (apr_strnatcmp(r->args, \"\") == 0)) {\n\t\treturn oidc_proto_javascript_implicit(r, c);\n\t}\n\tif (oidc_util_request_has_parameter(r, \"error\")) {\n\t\toidc_handle_redirect_authorization_response(r, c, session);\n\t}\n\treturn oidc_util_html_send_error(r, c->error_template, \"Invalid Request\",\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"The OpenID Connect callback URL received an invalid request: %s\",\n\t\t\t\t\tr->args), HTTP_INTERNAL_SERVER_ERROR);\n}", "target": 1}
{"code": "void CheckAuthTest::TestValidToken(const std::string &auth_token,\n                                   const std::string &user_info) {\n  EXPECT_CALL(*raw_request_, FindHeader(\"x-goog-iap-jwt-assertion\", _))\n      .WillOnce(Invoke([](const std::string &, std::string *token) {\n        *token = \"\";\n        return false;\n      }));\n  EXPECT_CALL(*raw_request_, FindHeader(kAuthHeader, _))\n      .WillOnce(Invoke([auth_token](const std::string &, std::string *token) {\n        *token = std::string(kBearer) + auth_token;\n        return true;\n      }));\n  EXPECT_CALL(*raw_request_, SetAuthToken(auth_token)).Times(1);\n  EXPECT_CALL(*raw_env_, DoRunHTTPRequest(_))\n      .Times(2)\n      .WillOnce(Invoke([](HTTPRequest *req) {\n        EXPECT_EQ(req->url(), kIssuer1OpenIdUrl);\n        std::string body(kOpenIdContent);\n        std::map<std::string, std::string> empty;\n        req->OnComplete(Status::OK, std::move(empty), std::move(body));\n      }))\n      .WillOnce(Invoke([](HTTPRequest *req) {\n        EXPECT_EQ(req->url(), kIssuer1PubkeyUrl);\n        std::string body(kPubkey);\n        std::map<std::string, std::string> empty;\n        req->OnComplete(Status::OK, std::move(empty), std::move(body));\n      }));\n  std::cout << \"need be replaced: \" << user_info << std::endl;\n  EXPECT_CALL(*raw_request_,\n              AddHeaderToBackend(kEndpointApiUserInfo, user_info))\n      .WillOnce(Return(utils::Status::OK));\n  CheckAuth(context_, [](Status status) { ASSERT_TRUE(status.ok()); });\n}", "target": 1}
{"code": "static void on_page_prepare(GtkNotebook *assistant, GtkWidget *page, gpointer user_data)\n{\n    if (!is_processing_finished())\n    {\n        show_next_step_button();\n        clear_warnings();\n    }\n    gtk_widget_hide(g_btn_detail);\n    gtk_widget_hide(g_btn_onfail);\n    if (!g_expert_mode)\n        gtk_widget_hide(g_btn_repeat);\n    save_items_from_notepad();\n    save_text_from_text_view(g_tv_comment, FILENAME_COMMENT);\n    if (pages[PAGENO_SUMMARY].page_widget == page)\n    {\n        if (!g_expert_mode)\n        {\n            int n = select_next_page_no(pages[PAGENO_SUMMARY].page_no, NULL);\n            log_info(\"switching to page_no:%d\", n);\n            gtk_notebook_set_current_page(assistant, n);\n            return;\n        }\n    }\n    if (pages[PAGENO_EDIT_ELEMENTS].page_widget == page)\n    {\n        if (highlight_forbidden())\n        {\n            add_sensitive_data_warning();\n            show_warnings();\n            gtk_expander_set_expanded(g_exp_search, TRUE);\n        }\n        else\n            gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g_rb_custom_search), TRUE);\n        show_warnings();\n    }\n    if (pages[PAGENO_REVIEW_DATA].page_widget == page)\n    {\n        update_ls_details_checkboxes(g_event_selected);\n        gtk_widget_set_sensitive(g_btn_next, gtk_toggle_button_get_active(g_tb_approve_bt));\n    }\n    if (pages[PAGENO_EDIT_COMMENT].page_widget == page)\n    {\n        gtk_widget_show(g_btn_detail);\n        gtk_widget_set_sensitive(g_btn_next, false);\n        on_comment_changed(gtk_text_view_get_buffer(g_tv_comment), NULL);\n    }\n    if (pages[PAGENO_EVENT_PROGRESS].page_widget == page)\n    {\n        log_info(\"g_event_selected:'%s'\", g_event_selected);\n        if (g_event_selected\n         && g_event_selected[0]\n        ) {\n            clear_warnings();\n            start_event_run(g_event_selected);\n        }\n    }\n    if(pages[PAGENO_EVENT_SELECTOR].page_widget == page)\n    {\n        if (!g_expert_mode && !g_auto_event_list)\n            hide_next_step_button();\n    }\n}", "target": 1}
{"code": "void color_sycc_to_rgb(opj_image_t *img)\n{\n\tif(img->numcomps < 3)\n\t{\n\t\timg->color_space = OPJ_CLRSPC_GRAY;\n\t\treturn;\n\t}\n\tif((img->comps[0].dx == 1)\n\t&& (img->comps[1].dx == 2)\n\t&& (img->comps[2].dx == 2)\n\t&& (img->comps[0].dy == 1)\n\t&& (img->comps[1].dy == 2)\n\t&& (img->comps[2].dy == 2))\n  {\n\t\tsycc420_to_rgb(img);\n  }\n\telse\n\tif((img->comps[0].dx == 1)\n\t&& (img->comps[1].dx == 2)\n\t&& (img->comps[2].dx == 2)\n\t&& (img->comps[0].dy == 1)\n\t&& (img->comps[1].dy == 1)\n\t&& (img->comps[2].dy == 1))\n  {\n\t\tsycc422_to_rgb(img);\n  }\n\telse\n\tif((img->comps[0].dx == 1)\n\t&& (img->comps[1].dx == 1)\n\t&& (img->comps[2].dx == 1)\n\t&& (img->comps[0].dy == 1)\n\t&& (img->comps[1].dy == 1)\n\t&& (img->comps[2].dy == 1))\n  {\n\t\tsycc444_to_rgb(img);\n  }\n\telse\n  {\n\t\tfprintf(stderr,\"%s:%d:color_sycc_to_rgb\\n\\tCAN NOT CONVERT\\n\", __FILE__,__LINE__);\n\t\treturn;\n  }\n\timg->color_space = OPJ_CLRSPC_SRGB;\n}", "target": 1}
{"code": "void Interpreter::saveGenerator(\n    Runtime *runtime,\n    PinnedHermesValue *frameRegs,\n    const Inst *resumeIP) {\n  auto *innerFn = vmcast<GeneratorInnerFunction>(FRAME.getCalleeClosure());\n  innerFn->saveStack(runtime);\n  innerFn->setNextIP(resumeIP);\n  innerFn->setState(GeneratorInnerFunction::State::SuspendedYield);\n}", "target": 0}
{"code": "static inline void write_desc(struct intel_engine_execlists *execlists, u64 desc, u32 port)\n{\n\tif (execlists->ctrl_reg) {\n\t\twritel(lower_32_bits(desc), execlists->submit_reg + port * 2);\n\t\twritel(upper_32_bits(desc), execlists->submit_reg + port * 2 + 1);\n\t} else {\n\t\twritel(upper_32_bits(desc), execlists->submit_reg);\n\t\twritel(lower_32_bits(desc), execlists->submit_reg);\n\t}\n}", "target": 0}
{"code": "bool Archive::ReadSubData(Array<byte> *UnpData,File *DestFile,bool TestMode)\n{\n  if (BrokenHeader)\n  {\n    uiMsg(UIERROR_SUBHEADERBROKEN,FileName);\n    ErrHandler.SetErrorCode(RARX_CRC);\n    return false;\n  }\n  if (SubHead.Method>5 || SubHead.UnpVer>(Format==RARFMT50 ? VER_UNPACK5:VER_UNPACK))\n  {\n    uiMsg(UIERROR_SUBHEADERUNKNOWN,FileName);\n    return false;\n  }\n  if (SubHead.PackSize==0 && !SubHead.SplitAfter)\n    return true;\n  SubDataIO.Init();\n  Unpack Unpack(&SubDataIO);\n  Unpack.Init(SubHead.WinSize,false);\n  if (DestFile==NULL)\n  {\n    if (SubHead.UnpSize>0x1000000)\n    {\n      uiMsg(UIERROR_SUBHEADERUNKNOWN,FileName);\n      return false;\n    }\n    if (UnpData==NULL)\n      SubDataIO.SetTestMode(true);\n    else\n    {\n      UnpData->Alloc((size_t)SubHead.UnpSize);\n      SubDataIO.SetUnpackToMemory(&(*UnpData)[0],(uint)SubHead.UnpSize);\n    }\n  }\n  if (SubHead.Encrypted)\n    if (Cmd->Password.IsSet())\n      SubDataIO.SetEncryption(false,SubHead.CryptMethod,&Cmd->Password,\n                SubHead.SaltSet ? SubHead.Salt:NULL,SubHead.InitV,\n                SubHead.Lg2Count,SubHead.HashKey,SubHead.PswCheck);\n    else\n      return false;\n  SubDataIO.UnpHash.Init(SubHead.FileHash.Type,1);\n  SubDataIO.SetPackedSizeToRead(SubHead.PackSize);\n  SubDataIO.EnableShowProgress(false);\n  SubDataIO.SetFiles(this,DestFile);\n  SubDataIO.SetTestMode(TestMode);\n  SubDataIO.UnpVolume=SubHead.SplitAfter;\n  SubDataIO.SetSubHeader(&SubHead,NULL);\n  Unpack.SetDestSize(SubHead.UnpSize);\n  if (SubHead.Method==0)\n    CmdExtract::UnstoreFile(SubDataIO,SubHead.UnpSize);\n  else\n    Unpack.DoUnpack(SubHead.UnpVer,false);\n  if (!SubDataIO.UnpHash.Cmp(&SubHead.FileHash,SubHead.UseHashKey ? SubHead.HashKey:NULL))\n  {\n    uiMsg(UIERROR_SUBHEADERDATABROKEN,FileName,SubHead.FileName);\n    ErrHandler.SetErrorCode(RARX_CRC);\n    if (UnpData!=NULL)\n      UnpData->Reset();\n    return false;\n  }\n  return true;\n}", "target": 1}
{"code": "write(Protocol_* iprot, const StructInfo& structInfo, const void* object) {\n  DCHECK(object);\n  size_t written = iprot->writeStructBegin(structInfo.name);\n  if (UNLIKELY(structInfo.unionExt != nullptr)) {\n    const FieldInfo* end = structInfo.fieldInfos + structInfo.numFields;\n    const auto& unionId =\n        activeUnionMemberId(object, structInfo.unionExt->unionTypeOffset);\n    const FieldInfo* found = std::lower_bound(\n        structInfo.fieldInfos,\n        end,\n        unionId,\n        [](const FieldInfo& lhs, FieldID rhs) { return lhs.id < rhs; });\n    if (found < end && found->id == unionId) {\n      const OptionalThriftValue value = getValue(*found->typeInfo, object);\n      if (value.hasValue()) {\n        written += writeField(iprot, *found, value.value());\n      } else if (found->typeInfo->type == protocol::TType::T_STRUCT) {\n        written += iprot->writeFieldBegin(\n            found->name, found->typeInfo->type, found->id);\n        written += iprot->writeStructBegin(found->name);\n        written += iprot->writeStructEnd();\n        written += iprot->writeFieldStop();\n        written += iprot->writeFieldEnd();\n      }\n    }\n  } else {\n    for (std::int16_t index = 0; index < structInfo.numFields; index++) {\n      const auto& fieldInfo = structInfo.fieldInfos[index];\n      if (fieldInfo.isUnqualified || fieldInfo.issetOffset == 0 ||\n          fieldIsSet(object, fieldInfo.issetOffset)) {\n        const OptionalThriftValue value =\n            getValue(*fieldInfo.typeInfo, getMember(fieldInfo, object));\n        if (value.hasValue()) {\n          written += writeField(iprot, fieldInfo, value.value());\n        }\n      }\n    }\n  }\n  written += iprot->writeFieldStop();\n  written += iprot->writeStructEnd();\n  return written;\n}", "target": 1}
{"code": "int nfc_llcp_set_remote_gb(struct nfc_dev *dev, const u8 *gb, u8 gb_len)\n{\n\tstruct nfc_llcp_local *local;\n\tif (gb_len < 3 || gb_len > NFC_MAX_GT_LEN)\n\t\treturn -EINVAL;\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tpr_err(\"No LLCP device\\n\");\n\t\treturn -ENODEV;\n\t}\n\tmemset(local->remote_gb, 0, NFC_MAX_GT_LEN);\n\tmemcpy(local->remote_gb, gb, gb_len);\n\tlocal->remote_gb_len = gb_len;\n\tif (memcmp(local->remote_gb, llcp_magic, 3)) {\n\t\tpr_err(\"MAC does not support LLCP\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn nfc_llcp_parse_gb_tlv(local,\n\t\t\t\t     &local->remote_gb[3],\n\t\t\t\t     local->remote_gb_len - 3);\n}", "target": 1}
{"code": "void CMsgReader::readExtendedClipboard(rdr::S32 len)\n{\n  rdr::U32 flags;\n  rdr::U32 action;\n  if (len < 4)\n    throw Exception(\"Invalid extended clipboard message\");\n  if (len > maxCutText) {\n    vlog.error(\"Extended clipboard message too long (%d bytes) - ignoring\", len);\n    is->skip(len);\n    return;\n  }\n  flags = is->readU32();\n  action = flags & clipboardActionMask;\n  if (action & clipboardCaps) {\n    int i;\n    size_t num;\n    rdr::U32 lengths[16];\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (flags & (1 << i))\n        num++;\n    }\n    if (len < (rdr::S32)(4 + 4*num))\n      throw Exception(\"Invalid extended clipboard message\");\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (flags & (1 << i))\n        lengths[num++] = is->readU32();\n    }\n    handler->handleClipboardCaps(flags, lengths);\n  } else if (action == clipboardProvide) {\n    rdr::ZlibInStream zis;\n    int i;\n    size_t num;\n    size_t lengths[16];\n    rdr::U8* buffers[16];\n    zis.setUnderlying(is, len - 4);\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (!(flags & 1 << i))\n        continue;\n      lengths[num] = zis.readU32();\n      if (lengths[num] > (size_t)maxCutText) {\n        vlog.error(\"Extended clipboard data too long (%d bytes) - ignoring\",\n                   (unsigned)lengths[num]);\n        zis.skip(lengths[num]);\n        flags &= ~(1 << i);\n        continue;\n      }\n      buffers[num] = new rdr::U8[lengths[num]];\n      zis.readBytes(buffers[num], lengths[num]);\n      num++;\n    }\n    zis.removeUnderlying();\n    handler->handleClipboardProvide(flags, lengths, buffers);\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (!(flags & 1 << i))\n        continue;\n      delete [] buffers[num++];\n    }\n  } else {\n    switch (action) {\n    case clipboardRequest:\n      handler->handleClipboardRequest(flags);\n      break;\n    case clipboardPeek:\n      handler->handleClipboardPeek(flags);\n      break;\n    case clipboardNotify:\n      handler->handleClipboardNotify(flags);\n      break;\n    default:\n      throw Exception(\"Invalid extended clipboard action\");\n    }\n  }\n}", "target": 1}
{"code": "cdf_tole4(uint32_t sv)\n{\n\treturn CDF_TOLE4(sv);\n}", "target": 0}
{"code": "static int start_netprobe(const struct sa *turn_srv,\n\t\t\t  int proto, bool secure,\n\t\t\t  const char *username, const char *password)\n{\n\tint err;\n\tre_printf(\"starting netprobe with TURN%s-server %J\"\n\t\t  \" (proto=%s) ..\\n\",\n\t\t  secure ? \"S\" : \"\", turn_srv,\n\t\t  net_proto2name(proto));\n#define PACKET_COUNT 50\n#define PACKET_INTERVAL 20\n\tif (netprobec >= ARRAY_SIZE(netprobev)) {\n\t\twarning(\"reached maximum %zu netprobes\\n\", netprobec);\n\t\treturn 0;\n\t}\n\tnetprobev[netprobec].turn_srv = *turn_srv;\n\tnetprobev[netprobec].secure = secure;\n\tnetprobev[netprobec].proto = proto;\n\terr = netprobe_alloc(&netprobev[netprobec].np,\n\t\t\t     turn_srv, proto, secure,\n\t\t\t     username, password,\n\t\t\t     PACKET_COUNT, PACKET_INTERVAL,\n\t\t\t     netprobe_handler, (void *)netprobec);\n\tif (err) {\n\t\twarning(\"could not create netprobe (%m)\\n\", err);\n\t\tgoto out;\n\t}\n\tnetprobec++;\n out:\n\treturn err;\n}", "target": 0}
{"code": "static char* getPreferredTag(const char* gf_tag)\n{ \n\tchar* result = NULL;\n\tint grOffset = 0;\n\tgrOffset = findOffset( LOC_GRANDFATHERED ,gf_tag);\n\tif(grOffset < 0) {\n\t\treturn NULL;\n\t}\n\tif( grOffset < LOC_PREFERRED_GRANDFATHERED_LEN ){\n\t\tresult = estrdup( LOC_PREFERRED_GRANDFATHERED[grOffset] );\n\t} else {\n\t\tresult = estrdup( LOC_GRANDFATHERED[grOffset] );\n\t}\n\treturn result;\n}", "target": 1}
{"code": "int main() {\n  int selftest;\n  MSPACK_SYS_SELFTEST(selftest);\n  TEST(selftest == MSPACK_ERR_OK);\n  kwajd_open_test_01();\n  printf(\"ALL %d TESTS PASSED.\\n\", test_count);\n  return 0;\n}", "target": 0}
{"code": "void ModuleSQL::init()\n{\n\tif (mysql_library_init(0, NULL, NULL))\n\t\tthrow ModuleException(\"Unable to initialise the MySQL library!\");\n\tDispatcher = new DispatcherThread(this);\n\tServerInstance->Threads.Start(Dispatcher);\n}", "target": 0}
{"code": "void kvm_queue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code)\n{\n\tkvm_multiple_exception(vcpu, nr, true, error_code, false);\n}", "target": 0}
{"code": "struct expr_parse_ctx *expr__ctx_new(void)\n{\n\tstruct expr_parse_ctx *ctx;\n\tctx = malloc(sizeof(struct expr_parse_ctx));\n\tif (!ctx)\n\t\treturn NULL;\n\tctx->ids = hashmap__new(key_hash, key_equal, NULL);\n\tif (IS_ERR(ctx->ids)) {\n\t\tfree(ctx);\n\t\treturn NULL;\n\t}\n\tctx->runtime = 0;\n\treturn ctx;\n}", "target": 0}
{"code": "void isdn_ppp_receive(isdn_net_dev *net_dev, isdn_net_local *lp, struct sk_buff *skb)\n{\n\tstruct ippp_struct *is;\n\tint slot;\n\tint proto;\n\tBUG_ON(net_dev->local->master); \n\tslot = lp->ppp_slot;\n\tif (slot < 0 || slot >= ISDN_MAX_CHANNELS) {\n\t\tprintk(KERN_ERR \"isdn_ppp_receive: lp->ppp_slot(%d)\\n\",\n\t\t       lp->ppp_slot);\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\tis = ippp_table[slot];\n\tif (is->debug & 0x4) {\n\t\tprintk(KERN_DEBUG \"ippp_receive: is:%08lx lp:%08lx slot:%d unit:%d len:%d\\n\",\n\t\t       (long)is, (long)lp, lp->ppp_slot, is->unit, (int)skb->len);\n\t\tisdn_ppp_frame_log(\"receive\", skb->data, skb->len, 32, is->unit, lp->ppp_slot);\n\t}\n\tif (isdn_ppp_skip_ac(is, skb) < 0) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\tproto = isdn_ppp_strip_proto(skb);\n\tif (proto < 0) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n#ifdef CONFIG_ISDN_MPP\n\tif (is->compflags & SC_LINK_DECOMP_ON) {\n\t\tskb = isdn_ppp_decompress(skb, is, NULL, &proto);\n\t\tif (!skb) \n\t\t\treturn;\n\t}\n\tif (!(is->mpppcfg & SC_REJ_MP_PROT)) { \n\t\tif (proto == PPP_MP) {\n\t\t\tisdn_ppp_mp_receive(net_dev, lp, skb);\n\t\t\treturn;\n\t\t}\n\t}\n#endif\n\tisdn_ppp_push_higher(net_dev, lp, skb, proto);\n}", "target": 0}
{"code": "show_tree(tree_t *t,                    \n          int    indent)                \n{\n  while (t)\n  {\n    if (t->markup == MARKUP_NONE)\n      printf(\"%*s\\\"%s\\\"\\n\", indent, \"\", t->data);\n    else\n      printf(\"%*s%s\\n\", indent, \"\", _htmlMarkups[t->markup]);\n    if (t->child)\n      show_tree(t->child, indent + 2);\n    t = t->next;\n  }\n}", "target": 1}
{"code": "static Jsi_RC jsi_BitfieldToValue(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value **outValue,\n    Jsi_DString *outStr, void *record, Jsi_Wide flags)\n{\n    Jsi_csgset *bsget = spec->init.OPT_BITS;\n    Jsi_Interp *d = interp;\n    int idx = spec->idx;\n    uchar *data = (uchar*)record;\n    int64_t inum;\n    Jsi_OptionSpec* enumSpec = (typeof(enumSpec))spec->data;\n    if (!d || !bsget || idx<0) \n        return Jsi_LogBug(\"invalid bitfield\");\n    Jsi_RC rc = (*bsget)(interp, data, &inum, spec, idx, 0);\n    if (rc != JSI_OK)\n        return JSI_ERROR;\n    if (enumSpec) {\n        struct numStruct { int64_t numVal; } nval = { inum };\n        Jsi_OptionSpec eSpec[] = {\n            JSI_OPT(CUSTOM, struct numStruct, numVal, .help=spec->help, .flags=JSI_OPT_ENUM_SPEC, .custom=Jsi_Opt_SwitchEnum,\n            .data=(void*)enumSpec, .info=0, .tname=spec->tname, .value=0, .bits=0, .boffset=8*sizeof(int64_t) ), \n            JSI_OPT_END(struct numStruct)\n        };\n        if (JSI_OK != jsi_EnumToValue(interp, eSpec, outValue, outStr, (void*)&nval, flags))\n            return JSI_ERROR;\n    } else if (outStr) {\n        char obuf[100];\n        snprintf(obuf, sizeof(obuf), \"%\" PRId64, inum);\n        Jsi_DSAppend(outStr, obuf, NULL);\n    } else {\n        Jsi_Number num = (Jsi_Number)inum;\n        Jsi_ValueMakeNumber(interp, outValue, num);\n    }\n    return JSI_OK;\n}", "target": 1}
{"code": "void WasmBinaryWriter::writeFunctionSignatures() {\n  if (importInfo->getNumDefinedFunctions() == 0) {\n    return;\n  }\n  BYN_TRACE(\"== writeFunctionSignatures\\n\");\n  auto start = startSection(BinaryConsts::Section::Function);\n  o << U32LEB(importInfo->getNumDefinedFunctions());\n  ModuleUtils::iterDefinedFunctions(*wasm, [&](Function* func) {\n    BYN_TRACE(\"write one\\n\");\n    o << U32LEB(getTypeIndex(func->type));\n  });\n  finishSection(start);\n}", "target": 0}
{"code": "static int parse_video_info(AVIOContext *pb, AVStream *st)\n{\n    uint16_t size_asf; \n    uint32_t size_bmp; \n    unsigned int tag;\n    st->codecpar->width  = avio_rl32(pb);\n    st->codecpar->height = avio_rl32(pb);\n    avio_skip(pb, 1); \n    size_asf = avio_rl16(pb);\n    tag = ff_get_bmp_header(pb, st, &size_bmp);\n    st->codecpar->codec_tag = tag;\n    st->codecpar->codec_id  = ff_codec_get_id(ff_codec_bmp_tags, tag);\n    size_bmp = FFMAX(size_asf, size_bmp);\n    if (size_bmp > BMP_HEADER_SIZE) {\n        int ret;\n        st->codecpar->extradata_size  = size_bmp - BMP_HEADER_SIZE;\n        if (!(st->codecpar->extradata = av_malloc(st->codecpar->extradata_size +\n                                               AV_INPUT_BUFFER_PADDING_SIZE))) {\n            st->codecpar->extradata_size = 0;\n            return AVERROR(ENOMEM);\n        }\n        memset(st->codecpar->extradata + st->codecpar->extradata_size , 0,\n               AV_INPUT_BUFFER_PADDING_SIZE);\n        if ((ret = avio_read(pb, st->codecpar->extradata,\n                             st->codecpar->extradata_size)) < 0)\n            return ret;\n    }\n    return 0;\n}", "target": 1}
{"code": "pci_get_vdev_info(int slot)\n{\n\tstruct businfo *bi;\n\tstruct slotinfo *si;\n\tstruct pci_vdev *dev = NULL;\n\tbi = pci_businfo[0];\n\tassert(bi != NULL);\n\tsi = &bi->slotinfo[slot];\n\tif (si != NULL)\n\t\tdev = si->si_funcs[0].fi_devi;\n\telse\n\t\tfprintf(stderr, \"slot=%d is empty!\\n\", slot);\n\treturn dev;\n}", "target": 1}
{"code": "static void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n{\n\tLIST_HEAD(tmp_list);\n\tstruct mount *p;\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_mount_unlock(mnt);\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tp->mnt.mnt_flags |= MNT_UMOUNT;\n\t\tlist_move(&p->mnt_list, &tmp_list);\n\t}\n\tlist_for_each_entry(p, &tmp_list, mnt_list) {\n\t\tlist_del_init(&p->mnt_child);\n\t}\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_umount(&tmp_list);\n\twhile (!list_empty(&tmp_list)) {\n\t\tbool disconnect;\n\t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n\t\tlist_del_init(&p->mnt_expire);\n\t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n\t\tif (how & UMOUNT_SYNC)\n\t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\t\tdisconnect = disconnect_mount(p, how);\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,\n\t\t\t\t disconnect ? &unmounted : NULL);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tif (!disconnect) {\n\t\t\t\tlist_add_tail(&p->mnt_child, &p->mnt_parent->mnt_mounts);\n\t\t\t} else {\n\t\t\t\tumount_mnt(p);\n\t\t\t}\n\t\t}\n\t\tchange_mnt_propagation(p, MS_PRIVATE);\n\t}\n}", "target": 1}
{"code": "    void Xmpdatum::setValue(const Value* pValue)\n    {\n        p_->value_.reset();\n        if (pValue) p_->value_ = pValue->clone();\n    }", "target": 0}
{"code": "static int file_exp(STANZA *s)\n{\n    BIGNUM *a = NULL, *e = NULL, *exp = NULL, *ret = NULL;\n    int st = 0;\n    if (!TEST_ptr(a = getBN(s, \"A\"))\n            || !TEST_ptr(e = getBN(s, \"E\"))\n            || !TEST_ptr(exp = getBN(s, \"Exp\"))\n            || !TEST_ptr(ret = BN_new()))\n        goto err;\n    if (!TEST_true(BN_exp(ret, a, e, ctx))\n            || !equalBN(\"A ^ E\", exp, ret))\n        goto err;\n    st = 1;\n err:\n    BN_free(a);\n    BN_free(e);\n    BN_free(exp);\n    BN_free(ret);\n    return st;\n}", "target": 0}
{"code": "print_line_header(Dwarf_Debug dbg,\n    Dwarf_Bool is_single_tab,\n    Dwarf_Bool is_actuals_tab)\n{\nif (!is_single_tab) {\nif (is_actuals_tab) {\n_dwarf_printf(dbg,\"\\nActuals Table\\n\");\n_dwarf_printf(dbg,\n\"                                                         be\\n\"\n\"                                                         ls\\n\"\n\"                                                         ce\\n\"\n\" section    op                                           kq\\n\"\n\" offset     code                address/index    row isa ??\\n\");\n    return;\n} else {\n_dwarf_printf(dbg,\"\\nLogicals Table\\n\");\n_dwarf_printf(dbg,\n\"                                                                              s pe\\n\"\n\"                                                                              tirp\\n\"\n\"                                                                              msoi\\n\"\n\" section          op                                                          tall\\n\"\n\" offset      row  code                address/indx fil lne col disc cntx subp ????\\n\");\n    return;\n}\n}\n_dwarf_printf(dbg,\n\"                                                         s b e p e i d\\n\"\n\"                                                         t l s r p s i\\n\"\n\"                                                         m c e o i a s\\n\"\n\" section    op                                       col t k q l l   c\\n\"\n\" offset     code               address     file line umn ? ? ? ? ?\\n\");\n} ", "target": 1}
{"code": "  void clear_scheduled_exception() {\n    thread_local_top_.scheduled_exception_ = heap_.the_hole_value();\n  }", "target": 0}
{"code": "static Jsi_RC jsi_ArraySliceCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n   if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    Jsi_RC rc = JSI_OK;\n    int istart = 0, iend, n, nsiz;\n    Jsi_Number nstart;\n    Jsi_Obj *nobj, *obj;\n    Jsi_Value *start = Jsi_ValueArrayIndex(interp, args, 0),\n        *end = Jsi_ValueArrayIndex(interp, args, 1);\n    if (!start) {\n        goto bail;\n    }\n    obj = _this->d.obj;\n    n = Jsi_ObjGetLength(interp, obj);\n    if (Jsi_GetNumberFromValue(interp,start, &nstart) == JSI_OK) {\n        istart = (int)nstart;\n        if (istart > n)\n            goto done;\n        if (istart < 0)\n            istart = (n+istart);\n        if (istart<0)\n            goto bail;\n    }\n    if (n == 0) {\ndone:\n        Jsi_ValueMakeArrayObject(interp, ret, Jsi_ObjNewType(interp, JSI_OT_ARRAY));\n        return JSI_OK;\n    }\n    Jsi_Number nend;\n    iend = n-1;\n    if (end && Jsi_GetNumberFromValue(interp,end, &nend) == JSI_OK) {\n        iend = (int) nend;\n        if (iend >= n)\n            iend = n;\n        if (iend < 0)\n            iend = (n+iend);\n        if (iend<0)\n            goto bail;\n    }\n    nsiz = iend-istart+1;\n    if (nsiz<=0)\n        goto done;\n    Jsi_ObjListifyArray(interp, obj);\n    nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    if (Jsi_ObjArraySizer(interp, nobj, nsiz) <= 0) {\n        rc = Jsi_LogError(\"index too large: %d\", nsiz);\n        goto bail;\n    }\n    int i, m;\n    for (m = 0, i = istart; i <= iend; i++, m++)\n    {\n        if (!obj->arr[i]) continue;\n        nobj->arr[m] = NULL;\n        Jsi_ValueDup2(interp, nobj->arr+m, obj->arr[i]);\n    }\n    Jsi_ObjSetLength(interp, nobj, nsiz);\n    Jsi_ValueMakeArrayObject(interp, ret, nobj);\n    return JSI_OK;\nbail:\n    Jsi_ValueMakeNull(interp, ret);\n    return rc;\n}", "target": 1}
{"code": "static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)\n{\n\tgit_pkt *pkt;\n\tconst char *line, *line_end;\n\tsize_t line_len;\n\tint error;\n\tint reading_from_buf = data_pkt_buf->size > 0;\n\tif (reading_from_buf) {\n\t\tgit_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);\n\t\tline = data_pkt_buf->ptr;\n\t\tline_len = data_pkt_buf->size;\n\t}\n\telse {\n\t\tline = data_pkt->data;\n\t\tline_len = data_pkt->len;\n\t}\n\twhile (line_len > 0) {\n\t\terror = git_pkt_parse_line(&pkt, line, &line_end, line_len);\n\t\tif (error == GIT_EBUFS) {\n\t\t\tif (!reading_from_buf)\n\t\t\t\tgit_buf_put(data_pkt_buf, line, line_len);\n\t\t\terror = 0;\n\t\t\tgoto done;\n\t\t}\n\t\telse if (error < 0)\n\t\t\tgoto done;\n\t\tline_len -= (line_end - line);\n\t\tline = line_end;\n\t\tif (pkt == NULL)\n\t\t\tcontinue;\n\t\terror = add_push_report_pkt(push, pkt);\n\t\tgit_pkt_free(pkt);\n\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\tgoto done;\n\t}\n\terror = 0;\ndone:\n\tif (reading_from_buf)\n\t\tgit_buf_consume(data_pkt_buf, line_end);\n\treturn error;\n}", "target": 1}
{"code": "ev_archive_init (EvArchive *archive)\n{\n}", "target": 0}
{"code": "MagickExport int LocaleUppercase(const int c)\n{\n  if (c == EOF)\n    return(c);\n#if defined(MAGICKCORE_LOCALE_SUPPORT)\n  if (c_locale != (locale_t) NULL)\n    return(toupper_l((int) ((unsigned char) c),c_locale));\n#endif\n  return(toupper((int) ((unsigned char) c)));\n}", "target": 0}
{"code": "int jpc_ppxstab_insert(jpc_ppxstab_t *tab, jpc_ppxstabent_t *ent)\n{\n\tint inspt;\n\tint i;\n\tfor (i = 0; i < tab->numents; ++i) {\n\t\tif (tab->ents[i]->ind > ent->ind) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tinspt = i;\n\tif (tab->numents >= tab->maxents) {\n\t\tif (jpc_ppxstab_grow(tab, tab->maxents + 128)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tfor (i = tab->numents; i > inspt; --i) {\n\t\ttab->ents[i] = tab->ents[i - 1];\n\t}\n\ttab->ents[i] = ent;\n\t++tab->numents;\n\treturn 0;\n}", "target": 1}
{"code": "static void update_blocked_averages(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct cfs_rq *cfs_rq, *pos;\n\tconst struct sched_class *curr_class;\n\tstruct rq_flags rf;\n\tbool done = true;\n\trq_lock_irqsave(rq, &rf);\n\tupdate_rq_clock(rq);\n\tfor_each_leaf_cfs_rq_safe(rq, cfs_rq, pos) {\n\t\tstruct sched_entity *se;\n\t\tif (throttled_hierarchy(cfs_rq))\n\t\t\tcontinue;\n\t\tif (update_cfs_rq_load_avg(cfs_rq_clock_task(cfs_rq), cfs_rq))\n\t\t\tupdate_tg_load_avg(cfs_rq, 0);\n\t\tse = cfs_rq->tg->se[cpu];\n\t\tif (se && !skip_blocked_update(se))\n\t\t\tupdate_load_avg(cfs_rq_of(se), se, 0);\n\t\tif (cfs_rq_is_decayed(cfs_rq))\n\t\t\tlist_del_leaf_cfs_rq(cfs_rq);\n\t\tif (cfs_rq_has_blocked(cfs_rq))\n\t\t\tdone = false;\n\t}\n\tcurr_class = rq->curr->sched_class;\n\tupdate_rt_rq_load_avg(rq_clock_task(rq), rq, curr_class == &rt_sched_class);\n\tupdate_dl_rq_load_avg(rq_clock_task(rq), rq, curr_class == &dl_sched_class);\n\tupdate_irq_load_avg(rq, 0);\n\tif (others_have_blocked(rq))\n\t\tdone = false;\n#ifdef CONFIG_NO_HZ_COMMON\n\trq->last_blocked_load_update_tick = jiffies;\n\tif (done)\n\t\trq->has_blocked_load = 0;\n#endif\n\trq_unlock_irqrestore(rq, &rf);\n}", "target": 1}
{"code": "ElectronNavigationThrottle::WillStartRequest() {\n  auto* handle = navigation_handle();\n  auto* contents = handle->GetWebContents();\n  if (!contents) {\n    NOTREACHED();\n    return PROCEED;\n  }\n  v8::Isolate* isolate = v8::Isolate::GetCurrent();\n  v8::HandleScope scope(isolate);\n  auto api_contents = electron::api::WebContents::From(isolate, contents);\n  if (api_contents.IsEmpty()) {\n    return PROCEED;\n  }\n  if (handle->IsRendererInitiated() && handle->IsInMainFrame() &&\n      api_contents->EmitNavigationEvent(\"will-navigate\", handle)) {\n    return CANCEL;\n  }\n  return PROCEED;\n}", "target": 0}
{"code": "static void __exit pcd_exit(void)\n{\n\tstruct pcd_unit *cd;\n\tint unit;\n\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\tif (!cd->disk)\n\t\t\tcontinue;\n\t\tif (cd->present) {\n\t\t\tdel_gendisk(cd->disk);\n\t\t\tpi_release(cd->pi);\n\t\t\tunregister_cdrom(&cd->info);\n\t\t}\n\t\tblk_cleanup_queue(cd->disk->queue);\n\t\tblk_mq_free_tag_set(&cd->tag_set);\n\t\tput_disk(cd->disk);\n\t}\n\tunregister_blkdev(major, name);\n\tpi_unregister_driver(par_drv);\n}", "target": 0}
{"code": "void handle_irq_for_port(evtchn_port_t port, struct evtchn_loop_ctrl *ctrl)\n{\n\tint irq;\n\tstruct irq_info *info;\n\tirq = get_evtchn_to_irq(port);\n\tif (irq == -1)\n\t\treturn;\n\tif (!ctrl->defer_eoi && !(++ctrl->count & 0xff)) {\n\t\tktime_t kt = ktime_get();\n\t\tif (!ctrl->timeout) {\n\t\t\tkt = ktime_add_ms(kt,\n\t\t\t\t\t  jiffies_to_msecs(event_loop_timeout));\n\t\t\tctrl->timeout = kt;\n\t\t} else if (kt > ctrl->timeout) {\n\t\t\tctrl->defer_eoi = true;\n\t\t}\n\t}\n\tinfo = info_for_irq(irq);\n\tif (ctrl->defer_eoi) {\n\t\tinfo->eoi_cpu = smp_processor_id();\n\t\tinfo->irq_epoch = __this_cpu_read(irq_epoch);\n\t\tinfo->eoi_time = get_jiffies_64() + event_eoi_delay;\n\t}\n\tgeneric_handle_irq(irq);\n}", "target": 0}
{"code": "mp_capable_print(netdissect_options *ndo,\n                 const u_char *opt, u_int opt_len, u_char flags)\n{\n        const struct mp_capable *mpc = (const struct mp_capable *) opt;\n        if (!(opt_len == 12 && flags & TH_SYN) &&\n            !(opt_len == 20 && (flags & (TH_SYN | TH_ACK)) == TH_ACK))\n                return 0;\n        if (MP_CAPABLE_OPT_VERSION(mpc->sub_ver) != 0) {\n                ND_PRINT((ndo, \" Unknown Version (%d)\", MP_CAPABLE_OPT_VERSION(mpc->sub_ver)));\n                return 1;\n        }\n        if (mpc->flags & MP_CAPABLE_C)\n                ND_PRINT((ndo, \" csum\"));\n        ND_PRINT((ndo, \" {0x%\" PRIx64, EXTRACT_64BITS(mpc->sender_key)));\n        if (opt_len == 20) \n                ND_PRINT((ndo, \",0x%\" PRIx64, EXTRACT_64BITS(mpc->receiver_key)));\n        ND_PRINT((ndo, \"}\"));\n        return 1;\n}", "target": 1}
{"code": "static struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)\n{\n\tstruct hlist_head *hashent = ucounts_hashentry(ns, uid);\n\tstruct ucounts *ucounts, *new;\n\tspin_lock_irq(&ucounts_lock);\n\tucounts = find_ucounts(ns, uid, hashent);\n\tif (!ucounts) {\n\t\tspin_unlock_irq(&ucounts_lock);\n\t\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\t\tif (!new)\n\t\t\treturn NULL;\n\t\tnew->ns = ns;\n\t\tnew->uid = uid;\n\t\tatomic_set(&new->count, 0);\n\t\tspin_lock_irq(&ucounts_lock);\n\t\tucounts = find_ucounts(ns, uid, hashent);\n\t\tif (ucounts) {\n\t\t\tkfree(new);\n\t\t} else {\n\t\t\thlist_add_head(&new->node, hashent);\n\t\t\tucounts = new;\n\t\t}\n\t}\n\tif (!atomic_add_unless(&ucounts->count, 1, INT_MAX))\n\t\tucounts = NULL;\n\tspin_unlock_irq(&ucounts_lock);\n\treturn ucounts;\n}", "target": 1}
{"code": "void HTMLMediaElement::SetSrc(const USVStringOrTrustedURL& stringOrURL,\n                              ExceptionState& exception_state) {\n  setAttribute(kSrcAttr, stringOrURL, exception_state);\n}", "target": 0}
{"code": "static void prekey_handler(const char *userid,\n\t\t\t   const uint8_t *key, size_t key_len,\n\t\t\t   uint16_t id, const char *clientid,\n\t\t\t   bool last, void *arg)\n{\n\tstruct session *sess;\n\tchar lclientid[64];\n\tint err;\n\toutput(\"prekey_handler: %zu bytes, user:%s[%u] -> %s\\n\",\n\t       key_len, userid, id, clientid);\n\terr = client_id_load(lclientid, sizeof(lclientid));\n\tif (err) {\n\t\tdebug(\"my clientid not set -- cannot store prekeys\\n\");\n\t\treturn;\n\t}\n\tsess = cryptobox_session_find(g_cryptobox, userid, clientid, lclientid);\n\tif (sess) {\n\t\toutput(\"prekey: session found\\n\");\n\t}\n\telse {\n\t\tinfo(\"conv: adding key to cryptobox for clientid=%s\\n\",\n\t\t     clientid);\n\t\terr = cryptobox_session_add_send(g_cryptobox, userid, clientid, lclientid,\n\t\t\t\t\t\t key, key_len);\n\t\tif (err) {\n\t\t\twarning(\"cryptobox_session_add_send failed (%m)\\n\",\n\t\t\t\terr);\n\t\t}\n\t}\n}", "target": 1}
{"code": "bool ExtractSymlink(CommandData *Cmd,ComprDataIO &DataIO,Archive &Arc,const wchar *LinkName)\n{\n#if defined(SAVE_LINKS) && defined(_UNIX)\n  if (Arc.Format==RARFMT15)\n    return ExtractUnixLink30(Cmd,DataIO,Arc,LinkName);\n  if (Arc.Format==RARFMT50)\n    return ExtractUnixLink50(Cmd,LinkName,&Arc.FileHead);\n#elif defined _WIN_ALL\n  if (Arc.Format==RARFMT50)\n    return CreateReparsePoint(Cmd,LinkName,&Arc.FileHead);\n#endif\n  return false;\n}", "target": 1}
{"code": "struct r_bin_pe_addr_t *PE_(check_mingw)(RBinPEObj *pe) {\n\tstruct r_bin_pe_addr_t* entry;\n\tbool sw = false;\n\tut8 b[1024];\n\tsize_t n = 0;\n\tif (!pe || !pe->b) {\n\t\treturn 0LL;\n\t}\n\tentry = PE_(r_bin_pe_get_entrypoint) (pe);\n\tZERO_FILL (b);\n\tif (r_buf_read_at (pe->b, entry->paddr, b, sizeof (b)) < 0) {\n\t\tpe_printf (\"Warning: Cannot read entry at 0x%08\"PFMT64x \"\\n\", entry->paddr);\n\t\tfree (entry);\n\t\treturn NULL;\n\t}\n\tif (b[0] == 0x55 && b[1] == 0x89 && b[3] == 0x83 && b[6] == 0xc7 && b[13] == 0xff && b[19] == 0xe8) {\n\t\tsw = follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 19);\n\t}\n\tif (b[0] == 0x83 && b[3] == 0xc7 && b[10] == 0xff && b[16] == 0xe8) {\n\t\tsw = follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 16);\n\t}\n\tif (b[0] == 0x83 && b[3] == 0xc7 && b[13] == 0xe8 && b[18] == 0x83 && b[21] == 0xe9) {\n\t\tsw = follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 21);\n\t}\n\tif (sw) {\n\t\tfor (n = 0; n < sizeof (b) - 12; n++) {\n\t\t\tif (b[n] == 0xa1 && b[n + 5] == 0x89 && b[n + 8] == 0xe8) {\n\t\t\t\tsw = follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, n + 8);\n\t\t\t\treturn entry;\n\t\t\t}\n\t\t}\n\t}\n\tfree (entry);\n\treturn NULL;\n}", "target": 1}
{"code": "MONGO_EXPORT int bson_append_code_w_scope_n( bson *b, const char *name,\n        const char *code, int len, const bson *scope ) {\n    int sl, size;\n    if ( !scope ) return BSON_ERROR;\n    sl = len + 1;\n    size = 4 + 4 + sl + bson_size( scope );\n    if ( bson_append_estart( b, BSON_CODEWSCOPE, name, size ) == BSON_ERROR )\n        return BSON_ERROR;\n    bson_append32( b, &size );\n    bson_append32( b, &sl );\n    bson_append( b, code, sl );\n    bson_append( b, scope->data, bson_size( scope ) );\n    return BSON_OK;\n}", "target": 1}
{"code": "void bpf_int_jit_compile(struct bpf_prog *prog)\n{\n\tstruct bpf_binary_header *header = NULL;\n\tint proglen, oldproglen = 0;\n\tstruct jit_context ctx = {};\n\tu8 *image = NULL;\n\tint *addrs;\n\tint pass;\n\tint i;\n\tif (!bpf_jit_enable)\n\t\treturn;\n\tif (!prog || !prog->len)\n\t\treturn;\n\taddrs = kmalloc(prog->len * sizeof(*addrs), GFP_KERNEL);\n\tif (!addrs)\n\t\treturn;\n\tfor (proglen = 0, i = 0; i < prog->len; i++) {\n\t\tproglen += 64;\n\t\taddrs[i] = proglen;\n\t}\n\tctx.cleanup_addr = proglen;\n\tfor (pass = 0; pass < 10; pass++) {\n\t\tproglen = do_jit(prog, addrs, image, oldproglen, &ctx);\n\t\tif (proglen <= 0) {\n\t\t\timage = NULL;\n\t\t\tif (header)\n\t\t\t\tbpf_jit_binary_free(header);\n\t\t\tgoto out;\n\t\t}\n\t\tif (image) {\n\t\t\tif (proglen != oldproglen) {\n\t\t\t\tpr_err(\"bpf_jit: proglen=%d != oldproglen=%d\\n\",\n\t\t\t\t       proglen, oldproglen);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (proglen == oldproglen) {\n\t\t\theader = bpf_jit_binary_alloc(proglen, &image,\n\t\t\t\t\t\t      1, jit_fill_hole);\n\t\t\tif (!header)\n\t\t\t\tgoto out;\n\t\t}\n\t\toldproglen = proglen;\n\t}\n\tif (bpf_jit_enable > 1)\n\t\tbpf_jit_dump(prog->len, proglen, 0, image);\n\tif (image) {\n\t\tbpf_flush_icache(header, image + proglen);\n\t\tset_memory_ro((unsigned long)header, header->pages);\n\t\tprog->bpf_func = (void *)image;\n\t\tprog->jited = true;\n\t}\nout:\n\tkfree(addrs);\n}", "target": 1}
{"code": "cfm_network_addr_print(netdissect_options *ndo,\n                       register const u_char *tptr)\n{\n    u_int network_addr_type;\n    u_int hexdump =  FALSE;\n    network_addr_type = *tptr;\n    ND_PRINT((ndo, \"\\n\\t  Network Address Type %s (%u)\",\n           tok2str(af_values, \"Unknown\", network_addr_type),\n           network_addr_type));\n    switch(network_addr_type) {\n    case AFNUM_INET:\n        ND_PRINT((ndo, \", %s\", ipaddr_string(ndo, tptr + 1)));\n        break;\n    case AFNUM_INET6:\n        ND_PRINT((ndo, \", %s\", ip6addr_string(ndo, tptr + 1)));\n        break;\n    default:\n        hexdump = TRUE;\n        break;\n    }\n    return hexdump;\n}", "target": 1}
{"code": "Status TransposeShapeFn(InferenceContext* c) {\n  ShapeHandle input = c->input(0);\n  ShapeHandle perm_shape = c->input(1);\n  const Tensor* perm = c->input_tensor(1);\n  DimensionHandle perm_elems = c->NumElements(perm_shape);\n  if (!c->RankKnown(input) && !c->ValueKnown(perm_elems) && perm == nullptr) {\n    c->set_output(0, c->UnknownShape());\n    return Status::OK();\n  }\n  int64_t rank;\n  if (c->RankKnown(input)) {\n    rank = c->Rank(input);\n  } else if (c->ValueKnown(perm_elems)) {\n    rank = c->Value(perm_elems);\n  } else {\n    rank = perm->NumElements();\n  }\n  if (!c->RankKnown(input) && rank < 2) {\n    c->set_output(0, input);\n    return Status::OK();\n  }\n  std::vector<DimensionHandle> dims;\n  dims.resize(rank);\n  TF_RETURN_IF_ERROR(c->WithRank(input, rank, &input));\n  TF_RETURN_IF_ERROR(c->WithRank(perm_shape, 1, &perm_shape));\n  TF_RETURN_IF_ERROR(c->WithValue(perm_elems, rank, &perm_elems));\n  if (perm != nullptr) {\n    std::vector<int64_t> data;\n    if (perm->dtype() == DT_INT32) {\n      data = AsInt64<int32>(perm, rank);\n    } else {\n      data = AsInt64<int64_t>(perm, rank);\n    }\n    for (int32_t i = 0; i < rank; ++i) {\n      int64_t in_idx = data[i];\n      if (in_idx >= rank) {\n        return errors::InvalidArgument(\"perm dim \", in_idx,\n                                       \" is out of range of input rank \", rank);\n      }\n      dims[i] = c->Dim(input, in_idx);\n    }\n  } else {\n    for (int i = 0; i < rank; ++i) {\n      dims[i] = c->UnknownDim();\n    }\n  }\n  c->set_output(0, c->MakeShape(dims));\n  return Status::OK();\n}", "target": 1}
{"code": "void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n\t{\n\tBN_ULONG t1,t2;\n\tBN_ULONG c1,c2,c3;\n\tc1=0;\n\tc2=0;\n\tc3=0;\n\tmul_add_c(a[0],b[0],c1,c2,c3);\n\tr[0]=c1;\n\tc1=0;\n\tmul_add_c(a[0],b[1],c2,c3,c1);\n\tmul_add_c(a[1],b[0],c2,c3,c1);\n\tr[1]=c2;\n\tc2=0;\n\tmul_add_c(a[2],b[0],c3,c1,c2);\n\tmul_add_c(a[1],b[1],c3,c1,c2);\n\tmul_add_c(a[0],b[2],c3,c1,c2);\n\tr[2]=c3;\n\tc3=0;\n\tmul_add_c(a[0],b[3],c1,c2,c3);\n\tmul_add_c(a[1],b[2],c1,c2,c3);\n\tmul_add_c(a[2],b[1],c1,c2,c3);\n\tmul_add_c(a[3],b[0],c1,c2,c3);\n\tr[3]=c1;\n\tc1=0;\n\tmul_add_c(a[3],b[1],c2,c3,c1);\n\tmul_add_c(a[2],b[2],c2,c3,c1);\n\tmul_add_c(a[1],b[3],c2,c3,c1);\n\tr[4]=c2;\n\tc2=0;\n\tmul_add_c(a[2],b[3],c3,c1,c2);\n\tmul_add_c(a[3],b[2],c3,c1,c2);\n\tr[5]=c3;\n\tc3=0;\n\tmul_add_c(a[3],b[3],c1,c2,c3);\n\tr[6]=c1;\n\tr[7]=c2;\n\t}", "target": 1}
{"code": "void *js_touserdata(js_State *J, int idx, const char *tag)\n{\n\tjs_Value *v = stackidx(J, idx);\n\tif (v->type == JS_TOBJECT && v->u.object->type == JS_CUSERDATA)\n\t\tif (!strcmp(tag, v->u.object->u.user.tag))\n\t\t\treturn v->u.object->u.user.data;\n\tjs_typeerror(J, \"not a %s\", tag);\n}", "target": 0}
{"code": "bool DelegatedFrameHost::TransformPointToLocalCoordSpace(\n    const gfx::Point& point,\n    const viz::SurfaceId& original_surface,\n    gfx::Point* transformed_point) {\n  viz::SurfaceId surface_id(frame_sink_id_, local_surface_id_);\n  if (!surface_id.is_valid())\n    return false;\n  *transformed_point = point;\n  if (original_surface == surface_id)\n    return true;\n  viz::SurfaceHittest hittest(nullptr,\n                              GetFrameSinkManager()->surface_manager());\n  return hittest.TransformPointToTargetSurface(original_surface, surface_id,\n                                               transformed_point);\n}", "target": 0}
{"code": "is_anychar_star_quantifier(QtfrNode* qn)\n{\n  if (qn->greedy && IS_REPEAT_INFINITE(qn->upper) &&\n      NTYPE(qn->target) == NT_CANY)\n    return 1;\n  else\n    return 0;\n}", "target": 0}
{"code": "static AMQP_VALUE test_on_transfer_received(void* context, TRANSFER_HANDLE transfer, uint32_t payload_size, const unsigned char* payload_bytes)\n{\n    (void)context;\n    test_on_transfer_received_transfer = transfer;\n    test_on_transfer_received_payload_size = payload_size;\n    memcpy(test_on_transfer_received_payload_bytes, payload_bytes, payload_size);\n    return (AMQP_VALUE)0x6000;\n}", "target": 0}
{"code": "static int l2cap_build_conf_req(struct sock *sk, void *data)\n{\n\tstruct l2cap_pinfo *pi = l2cap_pi(sk);\n\tstruct l2cap_conf_req *req = data;\n\tstruct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };\n\tvoid *ptr = req->data;\n\tBT_DBG(\"sk %p\", sk);\n\tswitch (pi->mode) {\n\tcase L2CAP_MODE_BASIC:\n\t\tif (pi->imtu != L2CAP_DEFAULT_MTU)\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->imtu);\n\t\tbreak;\n\tcase L2CAP_MODE_ERTM:\n\t\trfc.mode            = L2CAP_MODE_ERTM;\n\t\trfc.txwin_size      = L2CAP_DEFAULT_RX_WINDOW;\n\t\trfc.max_transmit    = L2CAP_DEFAULT_MAX_RECEIVE;\n\t\trfc.retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO);\n\t\trfc.monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO);\n\t\trfc.max_pdu_size    = cpu_to_le16(L2CAP_DEFAULT_MAX_RX_APDU);\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,\n\t\t\t\t\tsizeof(rfc), (unsigned long) &rfc);\n\t\tbreak;\n\t}\n\treq->dcid  = cpu_to_le16(pi->dcid);\n\treq->flags = cpu_to_le16(0);\n\treturn ptr - data;\n}", "target": 1}
{"code": "V8WindowShell* ScriptController::windowShell(DOMWrapperWorld* world)\n{\n    ASSERT(world);\n    V8WindowShell* shell = 0;\n    if (world->isMainWorld())\n        shell = m_windowShell.get();\n    else {\n        IsolatedWorldMap::iterator iter = m_isolatedWorlds.find(world->worldId());\n        if (iter != m_isolatedWorlds.end())\n            shell = iter->value.get();\n        else {\n            OwnPtr<V8WindowShell> isolatedWorldShell = V8WindowShell::create(m_frame, world, m_isolate);\n            shell = isolatedWorldShell.get();\n            m_isolatedWorlds.set(world->worldId(), isolatedWorldShell.release());\n        }\n    }\n    if (!shell->isContextInitialized() && shell->initializeIfNeeded()) {\n        if (world->isMainWorld()) {\n            m_frame->loader()->dispatchDidClearWindowObjectInWorld(existingWindowShellWorkaroundWorld());\n        } else\n            m_frame->loader()->dispatchDidClearWindowObjectInWorld(world);\n    }\n    return shell;\n}", "target": 0}
{"code": "void GfxState::ReusablePathIterator::reset()\n{\n    coordOff = 0;\n    subPathOff = 0;\n    curSubPath = path->getSubpath(0);\n    numCoords = curSubPath->getNumPoints();\n}", "target": 0}
{"code": "        int          GetS16BE (int nPos, bool *pbSuccess)\n        {\n            if ( nPos < 0 || nPos + 1 >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            int nRes = m_sFile[nPos];\n            nRes = (nRes << 8) + m_sFile[ nPos + 1 ];\n            if ( nRes & 0x8000 )\n                nRes |= ~0xffff;\n            return nRes;\n        }", "target": 1}
{"code": "int URI_FUNC(ComposeQueryEngine)(URI_CHAR * dest,\n\t\tconst URI_TYPE(QueryList) * queryList,\n\t\tint maxChars, int * charsWritten, int * charsRequired,\n\t\tUriBool spaceToPlus, UriBool normalizeBreaks) {\n\tUriBool firstItem = URI_TRUE;\n\tint ampersandLen = 0;  \n\tURI_CHAR * write = dest;\n\tif (dest == NULL) {\n\t\t*charsRequired = 0;\n\t} else {\n\t\tmaxChars--;\n\t}\n\twhile (queryList != NULL) {\n\t\tconst URI_CHAR * const key = queryList->key;\n\t\tconst URI_CHAR * const value = queryList->value;\n\t\tconst int worstCase = (normalizeBreaks == URI_TRUE ? 6 : 3);\n\t\tconst int keyLen = (key == NULL) ? 0 : (int)URI_STRLEN(key);\n\t\tconst int keyRequiredChars = worstCase * keyLen;\n\t\tconst int valueLen = (value == NULL) ? 0 : (int)URI_STRLEN(value);\n\t\tconst int valueRequiredChars = worstCase * valueLen;\n\t\tif (dest == NULL) {\n\t\t\t(*charsRequired) += ampersandLen + keyRequiredChars + ((value == NULL)\n\t\t\t\t\t\t? 0\n\t\t\t\t\t\t: 1 + valueRequiredChars);\n\t\t\tif (firstItem == URI_TRUE) {\n\t\t\t\tampersandLen = 1;\n\t\t\t\tfirstItem = URI_FALSE;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((write - dest) + ampersandLen + keyRequiredChars > maxChars) {\n\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t}\n\t\t\tif (firstItem == URI_TRUE) {\n\t\t\t\tampersandLen = 1;\n\t\t\t\tfirstItem = URI_FALSE;\n\t\t\t} else {\n\t\t\t\twrite[0] = _UT('&');\n\t\t\t\twrite++;\n\t\t\t}\n\t\t\twrite = URI_FUNC(EscapeEx)(key, key + keyLen,\n\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\t\t\tif (value != NULL) {\n\t\t\t\tif ((write - dest) + 1 + valueRequiredChars > maxChars) {\n\t\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t\t}\n\t\t\t\twrite[0] = _UT('=');\n\t\t\t\twrite++;\n\t\t\t\twrite = URI_FUNC(EscapeEx)(value, value + valueLen,\n\t\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\t\t\t}\n\t\t}\n\t\tqueryList = queryList->next;\n\t}\n\tif (dest != NULL) {\n\t\twrite[0] = _UT('\\0');\n\t\tif (charsWritten != NULL) {\n\t\t\t*charsWritten = (int)(write - dest) + 1; \n\t\t}\n\t}\n\treturn URI_SUCCESS;\n}", "target": 1}
{"code": "GIT_INLINE(bool) only_spaces_and_dots(const char *path)\n{\n\tconst char *c = path;\n\tfor (;; c++) {\n\t\tif (*c == '\\0')\n\t\t\treturn true;\n\t\tif (*c != ' ' && *c != '.')\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "qedi_dbg_notice(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t\tconst char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\tchar nfunc[32];\n\tmemset(nfunc, 0, sizeof(nfunc));\n\tmemcpy(nfunc, func, sizeof(nfunc) - 1);\n\tva_start(va, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\tif (!(qedi_dbg_log & QEDI_LOG_NOTICE))\n\t\tgoto ret;\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_notice(\"[%s]:[%s:%d]:%d: %pV\",\n\t\t\t  dev_name(&qedi->pdev->dev), nfunc, line,\n\t\t\t  qedi->host_no, &vaf);\n\telse\n\t\tpr_notice(\"[0000:00:00.0]:[%s:%d]: %pV\", nfunc, line, &vaf);\nret:\n\tva_end(va);\n}", "target": 1}
{"code": "is_apple_double (const char *name)\n{\nchar *basename;\n\tgboolean ret = FALSE;\n\tbasename = g_path_get_basename (name);\n\tif (basename == NULL) {\n\t\tg_debug (\"Filename '%s' doesn't have a basename?\", name);\n\t\treturn ret;\n\t}\n\tret = g_str_has_prefix (basename, APPLE_DOUBLE_PREFIX);\n\tg_free (basename);\n\treturn ret;\n}", "target": 0}
{"code": "static void *seq_buf_alloc(unsigned long size)\n{\n\tif (unlikely(size > MAX_RW_COUNT))\n\t\treturn NULL;\n\treturn kvmalloc(size, GFP_KERNEL_ACCOUNT);\n}", "target": 0}
{"code": "GF_Err pasp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_PixelAspectRatioBox *ptr = (GF_PixelAspectRatioBox *)s;\n\tGF_Err e = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->hSpacing);\n\tgf_bs_write_u32(bs, ptr->vSpacing);\n\treturn GF_OK;\n}", "target": 0}
{"code": "static int myrecvfrom6(int sockfd, void *buf, size_t *buflen, int flags,\n\t\t       struct in6_addr *addr, uint32_t *ifindex)\n{\n\tstruct sockaddr_in6 sin6;\n\tunsigned char cbuf[CMSG_SPACE(sizeof(struct in6_pktinfo))];\n\tstruct iovec iovec;\n\tstruct msghdr msghdr;\n\tstruct cmsghdr *cmsghdr;\n\tssize_t len;\n\tiovec.iov_len = *buflen;\n\tiovec.iov_base = buf;\n\tmemset(&msghdr, 0, sizeof(msghdr));\n\tmsghdr.msg_name = &sin6;\n\tmsghdr.msg_namelen = sizeof(sin6);\n\tmsghdr.msg_iov = &iovec;\n\tmsghdr.msg_iovlen = 1;\n\tmsghdr.msg_control = cbuf;\n\tmsghdr.msg_controllen = sizeof(cbuf);\n\tlen = recvmsg(sockfd, &msghdr, flags);\n\tif (len == -1)\n\t\treturn -errno;\n\t*buflen = len;\n\t*ifindex = sin6.sin6_scope_id;\n        for (cmsghdr = CMSG_FIRSTHDR(&msghdr); cmsghdr;\n\t     cmsghdr = CMSG_NXTHDR(&msghdr, cmsghdr)) {\n\t\tif (cmsghdr->cmsg_level == IPPROTO_IPV6 &&\n\t\t    cmsghdr->cmsg_type == IPV6_PKTINFO &&\n\t\t    cmsghdr->cmsg_len == CMSG_LEN(sizeof(struct in6_pktinfo))) {\n\t\t\tstruct in6_pktinfo *pktinfo;\n\t\t\tpktinfo = (struct in6_pktinfo *) CMSG_DATA(cmsghdr);\n\t\t\t*ifindex = pktinfo->ipi6_ifindex;\n\t\t}\n\t}\n\t*addr = sin6.sin6_addr;\n\treturn 0;\n}", "target": 1}
{"code": "bits_at(const OnigCodePoint *c, const int n)\n{\n  return bits_of(c[n / 3], n % 3);\n}", "target": 0}
{"code": "void RenderWidgetHostViewAura::UpdateExternalTexture() {\n  if (accelerated_compositing_state_changed_)\n    accelerated_compositing_state_changed_ = false;\n  bool is_compositing_active = host_->is_accelerated_compositing_active();\n  if (is_compositing_active && current_surface_.get()) {\n    window_->layer()->SetExternalTexture(current_surface_.get());\n    current_frame_size_ = ConvertSizeToDIP(\n        current_surface_->device_scale_factor(), current_surface_->size());\n    CheckResizeLock();\n    software_frame_manager_->DiscardCurrentFrame();\n  } else if (is_compositing_active &&\n             software_frame_manager_->HasCurrentFrame()) {\n    cc::TextureMailbox mailbox;\n    scoped_ptr<cc::SingleReleaseCallback> callback;\n    software_frame_manager_->GetCurrentFrameMailbox(&mailbox, &callback);\n    window_->layer()->SetTextureMailbox(mailbox,\n                                        callback.Pass(),\n                                        last_swapped_surface_scale_factor_);\n    current_frame_size_ = ConvertSizeToDIP(last_swapped_surface_scale_factor_,\n                                           mailbox.shared_memory_size());\n    CheckResizeLock();\n  } else {\n    window_->layer()->SetShowPaintedContent();\n    resize_lock_.reset();\n    host_->WasResized();\n    software_frame_manager_->DiscardCurrentFrame();\n  }\n}", "target": 0}
{"code": "  void onComplete(const Status& status, ContextImpl& context) const override {\n    auto& completion_state = context.getCompletionState(this);\n    if (completion_state.is_completed_) {\n      return;\n    }\n    if (Status::Ok == status) {\n      completion_state.is_completed_ = true;\n      completeWithStatus(status, context);\n      return;\n    }\n    if (++completion_state.number_completed_children_ == verifiers_.size()) {\n      Status final_status = Status::JwtMissed;\n      for (const auto& it : verifiers_) {\n        Status child_status = context.getCompletionState(it.get()).status_;\n        if (child_status != Status::JwtMissed && child_status != Status::JwtUnknownIssuer) {\n          final_status = child_status;\n        }\n      }\n      if (is_allow_missing_or_failed_) {\n        final_status = Status::Ok;\n      } else if (is_allow_missing_ && final_status == Status::JwtMissed) {\n        final_status = Status::Ok;\n      }\n      completion_state.is_completed_ = true;\n      completeWithStatus(final_status, context);\n    }\n  }", "target": 1}
{"code": "void luaV_concat (lua_State *L, int total) {\n  if (total == 1)\n    return;  \n  do {\n    StkId top = L->top;\n    int n = 2;  \n    if (!(ttisstring(s2v(top - 2)) || cvt2str(s2v(top - 2))) ||\n        !tostring(L, s2v(top - 1)))\n      luaT_tryconcatTM(L);\n    else if (isemptystr(s2v(top - 1)))  \n      cast_void(tostring(L, s2v(top - 2)));  \n    else if (isemptystr(s2v(top - 2))) {  \n      setobjs2s(L, top - 2, top - 1);  \n    }\n    else {\n      size_t tl = vslen(s2v(top - 1));\n      TString *ts;\n      for (n = 1; n < total && tostring(L, s2v(top - n - 1)); n++) {\n        size_t l = vslen(s2v(top - n - 1));\n        if (l_unlikely(l >= (MAX_SIZE/sizeof(char)) - tl))\n          luaG_runerror(L, \"string length overflow\");\n        tl += l;\n      }\n      if (tl <= LUAI_MAXSHORTLEN) {  \n        char buff[LUAI_MAXSHORTLEN];\n        copy2buff(top, n, buff);  \n        ts = luaS_newlstr(L, buff, tl);\n      }\n      else {  \n        ts = luaS_createlngstrobj(L, tl);\n        copy2buff(top, n, getstr(ts));\n      }\n      setsvalue2s(L, top - n, ts);  \n    }\n    total -= n-1;  \n    L->top -= n-1;  \n  } while (total > 1);  \n}", "target": 1}
{"code": "ikev1_sig_print(netdissect_options *ndo, u_char tpay _U_,\n\t\tconst struct isakmp_gen *ext, u_int item_len _U_,\n\t\tconst u_char *ep _U_, uint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_SIG)));\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_SIG)));\n\treturn NULL;\n}", "target": 0}
{"code": "static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_cipher rcipher;\n\tsnprintf(rcipher.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"cipher\");\n\trcipher.blocksize = alg->cra_blocksize;\n\trcipher.min_keysize = alg->cra_cipher.cia_min_keysize;\n\trcipher.max_keysize = alg->cra_cipher.cia_max_keysize;\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_CIPHER,\n\t\t    sizeof(struct crypto_report_cipher), &rcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "TEST_F(RaggedRangeOpTest, RangeSizeOverflow) {\n  BuildRaggedRangeGraph<float>();\n  AddInputFromArray<float>(TensorShape({2}), {1.1, 0.1});    \n  AddInputFromArray<float>(TensorShape({2}), {10.0, 1e10});  \n  AddInputFromArray<float>(TensorShape({2}), {1, 1e-10});    \n  EXPECT_EQ(absl::StrCat(\"Requires ((limit - start) / delta) <= \",\n                         std::numeric_limits<int64_t>::max()),\n            RunOpKernel().error_message());\n}", "target": 0}
{"code": "static unsigned char mincore_page(struct address_space *mapping, pgoff_t pgoff)\n{\n\tunsigned char present = 0;\n\tstruct page *page;\n#ifdef CONFIG_SWAP\n\tif (shmem_mapping(mapping)) {\n\t\tpage = find_get_entry(mapping, pgoff);\n\t\tif (xa_is_value(page)) {\n\t\t\tswp_entry_t swp = radix_to_swp_entry(page);\n\t\t\tpage = find_get_page(swap_address_space(swp),\n\t\t\t\t\t     swp_offset(swp));\n\t\t}\n\t} else\n\t\tpage = find_get_page(mapping, pgoff);\n#else\n\tpage = find_get_page(mapping, pgoff);\n#endif\n\tif (page) {\n\t\tpresent = PageUptodate(page);\n\t\tput_page(page);\n\t}\n\treturn present;\n}", "target": 1}
{"code": "TEST(TF_CTStringTest, OffsetType) {\n  {\n    TF_TString s71;\n    TF_TString_Init(&s71);\n    size_t header_length = 24;\n    size_t size = 8;\n    TF_TString_ResizeUninitialized(&s71, header_length + size);\n    uint32_t save_size = s71.u.offset.size;\n    uint32_t save_offset = s71.u.offset.offset;\n    uint32_t save_count = s71.u.offset.count;\n    s71.u.offset.size = TF_TString_ToInternalSizeT(size, TF_TSTR_OFFSET);\n    s71.u.offset.offset = header_length;\n    s71.u.offset.count = 0;\n    EXPECT_EQ(size, TF_TString_GetSize(&s71));\n    EXPECT_EQ(TF_TSTR_OFFSET, TF_TString_GetType(&s71));\n    s71.u.offset.size = save_size;\n    s71.u.offset.offset = save_offset;\n    s71.u.offset.count = save_count;\n    TF_TString_Dealloc(&s71);\n  }\n}", "target": 0}
{"code": "int btrfs_get_dev_stats(struct btrfs_fs_info *fs_info,\n\t\t\tstruct btrfs_ioctl_get_dev_stats *stats)\n{\n\tstruct btrfs_device *dev;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tint i;\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(fs_info->fs_devices, stats->devid, NULL, NULL);\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\tif (!dev) {\n\t\tbtrfs_warn(fs_info, \"get dev_stats failed, device not found\");\n\t\treturn -ENODEV;\n\t} else if (!dev->dev_stats_valid) {\n\t\tbtrfs_warn(fs_info, \"get dev_stats failed, not yet valid\");\n\t\treturn -ENODEV;\n\t} else if (stats->flags & BTRFS_DEV_STATS_RESET) {\n\t\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++) {\n\t\t\tif (stats->nr_items > i)\n\t\t\t\tstats->values[i] =\n\t\t\t\t\tbtrfs_dev_stat_read_and_reset(dev, i);\n\t\t\telse\n\t\t\t\tbtrfs_dev_stat_reset(dev, i);\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++)\n\t\t\tif (stats->nr_items > i)\n\t\t\t\tstats->values[i] = btrfs_dev_stat_read(dev, i);\n\t}\n\tif (stats->nr_items > BTRFS_DEV_STAT_VALUES_MAX)\n\t\tstats->nr_items = BTRFS_DEV_STAT_VALUES_MAX;\n\treturn 0;\n}", "target": 1}
{"code": "  absl::string_view failureReason() const override { return error_; }", "target": 0}
{"code": "static bool reg_type_may_be_null(enum bpf_reg_type type)\n{\n\treturn type == PTR_TO_MAP_VALUE_OR_NULL ||\n\t       type == PTR_TO_SOCKET_OR_NULL ||\n\t       type == PTR_TO_SOCK_COMMON_OR_NULL ||\n\t       type == PTR_TO_TCP_SOCK_OR_NULL;\n}", "target": 0}
{"code": "archive_read_format_zip_read_data_skip_seekable(struct archive_read *a)\n{\n\tstruct zip *zip;\n\tzip = (struct zip *)(a->format->data);\n\tzip->unconsumed = 0;\n\treturn (ARCHIVE_OK);\n}", "target": 0}
{"code": "del_aubio_filterbank (aubio_filterbank_t * fb)\n{\n  del_fmat (fb->filters);\n  AUBIO_FREE (fb);\n}", "target": 0}
{"code": "static SDL_Surface* Create_Surface_Solid(int width, int height, SDL_Color fg, Uint32 *color)\n{\n    const int alignment = Get_Alignement() - 1;\n    SDL_Surface *textbuf;\n    Sint64 size;\n    void *pixels, *ptr;\n    Sint64 pitch = width + alignment;\n    pitch += alignment;\n    pitch &= ~alignment;\n    size = height * pitch + sizeof (void *) + alignment;\n    if (size < 0 || size > SDL_MAX_SINT32) {\n        return NULL;\n    }\n    ptr = SDL_malloc((size_t)size);\n    if (ptr == NULL) {\n        return NULL;\n    }\n    pixels = (void *)(((uintptr_t)ptr + sizeof(void *) + alignment) & ~alignment);\n    ((void **)pixels)[-1] = ptr;\n    textbuf = SDL_CreateRGBSurfaceWithFormatFrom(pixels, width, height, 0, pitch, SDL_PIXELFORMAT_INDEX8);\n    if (textbuf == NULL) {\n        SDL_free(ptr);\n        return NULL;\n    }\n    textbuf->flags &= ~SDL_PREALLOC;\n    textbuf->flags |= SDL_SIMD_ALIGNED;\n    SDL_memset(pixels, 0, height * pitch);\n    *color = 1;\n    {\n        SDL_Palette *palette = textbuf->format->palette;\n        palette->colors[0].r = 255 - fg.r;\n        palette->colors[0].g = 255 - fg.g;\n        palette->colors[0].b = 255 - fg.b;\n        palette->colors[1].r = fg.r;\n        palette->colors[1].g = fg.g;\n        palette->colors[1].b = fg.b;\n        palette->colors[1].a = fg.a;\n    }\n    SDL_SetColorKey(textbuf, SDL_TRUE, 0);\n    return textbuf;", "target": 1}
{"code": "std::string queueloader::get_filename(const std::string& str) {\n\tstd::string fn = ctrl->get_dlpath();\n\tif (fn[fn.length()-1] != NEWSBEUTER_PATH_SEP[0])\n\t\tfn.append(NEWSBEUTER_PATH_SEP);\n\tchar buf[1024];\n\tsnprintf(buf, sizeof(buf), \"%s\", str.c_str());\n\tchar * base = basename(buf);\n\tif (!base || strlen(base) == 0) {\n\t\tchar lbuf[128];\n\t\ttime_t t = time(NULL);\n\t\tstrftime(lbuf, sizeof(lbuf), \"%Y-%b-%d-%H%M%S.unknown\", localtime(&t));\n\t\tfn.append(lbuf);\n\t} else {\n\t\tfn.append(base);\n\t}\n\treturn fn;\n}", "target": 1}
{"code": "static OPCODE_DESC* avr_op_analyze(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *buf, int len, CPU_MODEL *cpu) {\n\tOPCODE_DESC *opcode_desc;\n\tif (len < 2) {\n\t\treturn NULL;\n\t}\n\tut16 ins = (buf[1] << 8) | buf[0];\n\tint fail;\n\tchar *t;\n\tmemset (op, 0, sizeof (RAnalOp));\n\top->ptr = UT64_MAX;\n\top->val = UT64_MAX;\n\top->jump = UT64_MAX;\n\tr_strbuf_init (&op->esil);\n\tfor (opcode_desc = opcodes; opcode_desc->handler; opcode_desc++) {\n\t\tif ((ins & opcode_desc->mask) == opcode_desc->selector) {\n\t\t\tfail = 0;\n\t\t\top->cycles = opcode_desc->cycles;\n\t\t\top->size = opcode_desc->size;\n\t\t\top->type = opcode_desc->type;\n\t\t\top->jump = UT64_MAX;\n\t\t\top->fail = UT64_MAX;\n\t\t\top->addr = addr;\n\t\t\tr_strbuf_setf (&op->esil, \"\");\n\t\t\topcode_desc->handler (anal, op, buf, len, &fail, cpu);\n\t\t\tif (fail) {\n\t\t\t\tgoto INVALID_OP;\n\t\t\t}\n\t\t\tif (op->cycles <= 0) {\n\t\t\t\topcode_desc->cycles = 2;\n\t\t\t}\n\t\t\top->nopcode = (op->type == R_ANAL_OP_TYPE_UNK);\n\t\t\tt = r_strbuf_get (&op->esil);\n\t\t\tif (t && strlen (t) > 1) {\n\t\t\t\tt += strlen (t) - 1;\n\t\t\t\tif (*t == ',') {\n\t\t\t\t\t*t = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn opcode_desc;\n\t\t}\n\t}\n\tif ((ins & 0xff00) == 0xff00 && (ins & 0xf) > 7) {\n\t\tgoto INVALID_OP;\n\t}\nINVALID_OP:\n\top->family = R_ANAL_OP_FAMILY_UNKNOWN;\n\top->type = R_ANAL_OP_TYPE_UNK;\n\top->addr = addr;\n\top->fail = UT64_MAX;\n\top->jump = UT64_MAX;\n\top->ptr = UT64_MAX;\n\top->val = UT64_MAX;\n\top->nopcode = 1;\n\top->cycles = 1;\n\top->size = 2;\n\tr_strbuf_set (&op->esil, \"1,$\");\n\treturn NULL;\n}", "target": 0}
{"code": "cmnd_matches_all(const struct sudoers_parse_tree *parse_tree,\n    const struct member *m, const char *runchroot, struct cmnd_info *info)\n{\n    const bool negated = m->negated;\n    struct sudo_command *c;\n    int matched = UNSPEC;\n    struct alias *a;\n    debug_decl(cmnd_matches_all, SUDOERS_DEBUG_MATCH);\n    switch (m->type) {\n\tcase ALL:\n\t    c = (struct sudo_command *)m->name;\n\t    if (command_matches(parse_tree->ctx, c->cmnd, c->args, runchroot,\n\t\t    info, &c->digests))\n\t\tmatched = negated ? DENY : ALLOW;\n\t    break;\n\tcase ALIAS:\n\t    a = alias_get(parse_tree, m->name, CMNDALIAS);\n\t    if (a != NULL) {\n\t\tTAILQ_FOREACH_REVERSE(m, &a->members, member_list, entries) {\n\t\t    matched = cmnd_matches_all(parse_tree, m, runchroot, info);\n\t\t    if (matched != UNSPEC) {\n\t\t\tif (negated)\n\t\t\t    matched = matched == ALLOW ? DENY : ALLOW;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\talias_put(a);\n\t    }\n\t    break;\n    }\n    debug_return_int(matched);\n}", "target": 1}
{"code": "R_API RBinJavaVerificationObj *r_bin_java_verification_info_from_type(RBinJavaObj *bin, R_BIN_JAVA_STACKMAP_TYPE type, ut32 value) {\n\tRBinJavaVerificationObj *se = R_NEW0 (RBinJavaVerificationObj);\n\tif (!se) {\n\t\treturn NULL;\n\t}\n\tse->tag = type;\n\tif (se->tag == R_BIN_JAVA_STACKMAP_OBJECT) {\n\t\tse->info.obj_val_cp_idx = (ut16) value;\n\t} else if (se->tag == R_BIN_JAVA_STACKMAP_UNINIT) {\n\t\tse->info.uninit_offset = (ut16) value;\n\t}\n\treturn se;\n}", "target": 1}
{"code": "Status SparseTensorFromContext(OpKernelContext* ctx, const int32_t base_index,\n                               const bool validate_indices,\n                               sparse::SparseTensor* tensor) {\n  TensorShape shape;\n  TF_RETURN_IF_ERROR(TensorShape::BuildTensorShape(\n      ctx->input(base_index + 2).vec<int64_t>(), &shape));\n  CheckRankAtLeast2(ctx, shape);\n  std::vector<int64_t> order(shape.dims());\n  std::iota(order.begin(), order.end(), 0);\n  Status status = sparse::SparseTensor::Create(\n      ctx->input(base_index), ctx->input(base_index + 1), shape, order, tensor);\n  if (!validate_indices || !status.ok()) return status;\n  return tensor->IndicesValid();\n}", "target": 1}
{"code": "_prolog_error(batch_job_launch_msg_t *req, int rc)\n{\n\tchar *err_name_ptr, err_name[256], path_name[MAXPATHLEN];\n\tchar *fmt_char;\n\tint fd;\n\tif (req->std_err || req->std_out) {\n\t\tif (req->std_err)\n\t\t\tstrncpy(err_name, req->std_err, sizeof(err_name));\n\t\telse\n\t\t\tstrncpy(err_name, req->std_out, sizeof(err_name));\n\t\tif ((fmt_char = strchr(err_name, (int) '%')) &&\n\t\t    (fmt_char[1] == 'j') && !strchr(fmt_char+1, (int) '%')) {\n\t\t\tchar tmp_name[256];\n\t\t\tfmt_char[1] = 'u';\n\t\t\tsnprintf(tmp_name, sizeof(tmp_name), err_name,\n\t\t\t\t req->job_id);\n\t\t\tstrncpy(err_name, tmp_name, sizeof(err_name));\n\t\t}\n\t} else {\n\t\tsnprintf(err_name, sizeof(err_name), \"slurm-%u.out\",\n\t\t\t req->job_id);\n\t}\n\terr_name_ptr = err_name;\n\tif (err_name_ptr[0] == '/')\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s\", err_name_ptr);\n\telse if (req->work_dir)\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s/%s\",\n\t\t\treq->work_dir, err_name_ptr);\n\telse\n\t\tsnprintf(path_name, MAXPATHLEN, \"/%s\", err_name_ptr);\n\tif ((fd = open(path_name, (O_CREAT|O_APPEND|O_WRONLY), 0644)) == -1) {\n\t\terror(\"Unable to open %s: %s\", path_name,\n\t\t      slurm_strerror(errno));\n\t\treturn;\n\t}\n\tsnprintf(err_name, sizeof(err_name),\n\t\t \"Error running slurm prolog: %d\\n\", WEXITSTATUS(rc));\n\tsafe_write(fd, err_name, strlen(err_name));\n\tif (fchown(fd, (uid_t) req->uid, (gid_t) req->gid) == -1) {\n\t\tsnprintf(err_name, sizeof(err_name),\n\t\t\t \"Couldn't change fd owner to %u:%u: %m\\n\",\n\t\t\t req->uid, req->gid);\n\t}\nrwfail:\n\tclose(fd);\n}", "target": 1}
{"code": "static int adpt_queue_lck(struct scsi_cmnd *cmd)\n{\n\tadpt_hba* pHba = NULL;\n\tstruct adpt_device* pDev = NULL;\t\n\tif ((cmd->cmnd[0] == REQUEST_SENSE) && (cmd->sense_buffer[0] != 0)) {\n\t\tcmd->result = (DID_OK << 16);\n\t\tscsi_done(cmd);\n\t\treturn 0;\n\t}\n\tpHba = (adpt_hba*)cmd->device->host->hostdata[0];\n\tif (!pHba) {\n\t\treturn FAILED;\n\t}\n\trmb();\n\tif ((pHba->state) & DPTI_STATE_RESET)\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\tif((pDev = (struct adpt_device*) (cmd->device->hostdata)) == NULL) {\n\t\tif ((pDev = adpt_find_device(pHba, (u32)cmd->device->channel, (u32)cmd->device->id, cmd->device->lun)) == NULL) {\n\t\t\tcmd->result = (DID_NO_CONNECT << 16);\n\t\t\tscsi_done(cmd);\n\t\t\treturn 0;\n\t\t}\n\t\tcmd->device->hostdata = pDev;\n\t}\n\tpDev->pScsi_dev = cmd->device;\n\tif (pDev->state & DPTI_DEV_RESET ) {\n\t\treturn FAILED;\n\t}\n\treturn adpt_scsi_to_i2o(pHba, cmd, pDev);\n}", "target": 1}
{"code": "static int caif_seqpkt_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t       struct msghdr *m, size_t len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint ret;\n\tint copylen;\n\tret = -EOPNOTSUPP;\n\tif (m->msg_flags&MSG_OOB)\n\t\tgoto read_error;\n\tm->msg_namelen = 0;\n\tskb = skb_recv_datagram(sk, flags, 0 , &ret);\n\tif (!skb)\n\t\tgoto read_error;\n\tcopylen = skb->len;\n\tif (len < copylen) {\n\t\tm->msg_flags |= MSG_TRUNC;\n\t\tcopylen = len;\n\t}\n\tret = skb_copy_datagram_iovec(skb, 0, m->msg_iov, copylen);\n\tif (ret)\n\t\tgoto out_free;\n\tret = (flags & MSG_TRUNC) ? skb->len : copylen;\nout_free:\n\tskb_free_datagram(sk, skb);\n\tcaif_check_flow_release(sk);\n\treturn ret;\nread_error:\n\treturn ret;\n}", "target": 1}
{"code": "void audit_free(struct task_struct *tsk)\n{\n\tstruct audit_context *context;\n\tcontext = audit_get_context(tsk, 0, 0);\n\tif (likely(!context))\n\t\treturn;\n\tif (context->in_syscall && context->auditable)\n\t\taudit_log_exit(context, tsk);\n\taudit_free_context(context);\n}", "target": 0}
{"code": "void br_mdb_notify(struct net_device *dev, struct net_bridge_port *port,\n\t\t   struct br_ip *group, int type)\n{\n\tstruct br_mdb_entry entry;\n\tmemset(&entry, 0, sizeof(entry));\n\tentry.ifindex = port->dev->ifindex;\n\tentry.addr.proto = group->proto;\n\tentry.addr.u.ip4 = group->u.ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\tentry.addr.u.ip6 = group->u.ip6;\n#endif\n\t__br_mdb_notify(dev, &entry, type);\n}", "target": 0}
{"code": "static void credential_write_item(FILE *fp, const char *key, const char *value)\n{\n\tif (!value)\n\t\treturn;\n\tif (strchr(value, '\\n'))\n\t\tdie(\"credential value for %s contains newline\", key);\n\tfprintf(fp, \"%s=%s\\n\", key, value);\n}", "target": 0}
{"code": "static void vgacon_scrolldelta(struct vc_data *c, int lines)\n{\n\tint start, end, count, soff;\n\tif (!lines) {\n\t\tvgacon_restore_screen(c);\n\t\treturn;\n\t}\n\tif (!vgacon_scrollback_cur->data)\n\t\treturn;\n\tif (!vgacon_scrollback_cur->save) {\n\t\tvgacon_cursor(c, CM_ERASE);\n\t\tvgacon_save_screen(c);\n\t\tc->vc_origin = (unsigned long)c->vc_screenbuf;\n\t\tvgacon_scrollback_cur->save = 1;\n\t}\n\tvgacon_scrollback_cur->restore = 0;\n\tstart = vgacon_scrollback_cur->cur + lines;\n\tend = start + abs(lines);\n\tif (start < 0)\n\t\tstart = 0;\n\tif (start > vgacon_scrollback_cur->cnt)\n\t\tstart = vgacon_scrollback_cur->cnt;\n\tif (end < 0)\n\t\tend = 0;\n\tif (end > vgacon_scrollback_cur->cnt)\n\t\tend = vgacon_scrollback_cur->cnt;\n\tvgacon_scrollback_cur->cur = start;\n\tcount = end - start;\n\tsoff = vgacon_scrollback_cur->tail -\n\t\t((vgacon_scrollback_cur->cnt - end) * c->vc_size_row);\n\tsoff -= count * c->vc_size_row;\n\tif (soff < 0)\n\t\tsoff += vgacon_scrollback_cur->size;\n\tcount = vgacon_scrollback_cur->cnt - start;\n\tif (count > c->vc_rows)\n\t\tcount = c->vc_rows;\n\tif (count) {\n\t\tint copysize;\n\t\tint diff = c->vc_rows - count;\n\t\tvoid *d = (void *) c->vc_visible_origin;\n\t\tvoid *s = (void *) c->vc_screenbuf;\n\t\tcount *= c->vc_size_row;\n\t\tcopysize = min(count, vgacon_scrollback_cur->size - soff);\n\t\tscr_memcpyw(d, vgacon_scrollback_cur->data + soff, copysize);\n\t\td += copysize;\n\t\tcount -= copysize;\n\t\tif (count) {\n\t\t\tscr_memcpyw(d, vgacon_scrollback_cur->data, count);\n\t\t\td += count;\n\t\t}\n\t\tif (diff)\n\t\t\tscr_memcpyw(d, s, diff * c->vc_size_row);\n\t} else\n\t\tvgacon_cursor(c, CM_MOVE);\n}", "target": 1}
{"code": "void PacketReader::getLabelFromContent(const vector<uint8_t>& content, uint16_t& frompos, string& ret, int recurs) \n{\n  if(recurs > 100) \n    throw MOADNSException(\"Loop\");\n  int pos = frompos;\n  for(;;) {\n    unsigned char labellen=content.at(frompos++);\n    if(!labellen) {\n      if(ret.empty())\n              ret.append(1,'.');\n      break;\n    }\n    else if((labellen & 0xc0) == 0xc0) {\n      uint16_t offset=256*(labellen & ~0xc0) + (unsigned int)content.at(frompos++) - sizeof(dnsheader);\n      if(offset >= pos)\n        throw MOADNSException(\"forward reference during label decompression\");\n      return getLabelFromContent(content, offset, ret, ++recurs);\n    }\n    else if(labellen > 63) \n      throw MOADNSException(\"Overly long label during label decompression (\"+lexical_cast<string>((unsigned int)labellen)+\")\");\n    else {\n      for(string::size_type n = 0 ; n < labellen; ++n, frompos++) {\n        if(content.at(frompos)=='.' || content.at(frompos)=='\\\\') {\n          ret.append(1, '\\\\');\n          ret.append(1, content[frompos]);\n        }\n        else if(content.at(frompos)==' ') {\n          ret+=\"\\\\032\";\n        }\n        else \n          ret.append(1, content[frompos]);\n      }\n      ret.append(1,'.');\n    }\n    if (ret.length() > 1024)\n      throw MOADNSException(\"Total name too long\");\n  }\n}", "target": 1}
{"code": "static int rfcomm_sock_getname(struct socket *sock, struct sockaddr *addr, int *len, int peer)\n{\n\tstruct sockaddr_rc *sa = (struct sockaddr_rc *) addr;\n\tstruct sock *sk = sock->sk;\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\tmemset(sa, 0, sizeof(*sa));\n\tsa->rc_family  = AF_BLUETOOTH;\n\tsa->rc_channel = rfcomm_pi(sk)->channel;\n\tif (peer)\n\t\tbacpy(&sa->rc_bdaddr, &bt_sk(sk)->dst);\n\telse\n\t\tbacpy(&sa->rc_bdaddr, &bt_sk(sk)->src);\n\t*len = sizeof(struct sockaddr_rc);\n\treturn 0;\n}", "target": 0}
{"code": "static void ready_handler(void *arg)\n{\n\tstruct stun_uri uri;\n\tint err;\n\tdns_init(NULL);\n\t(void)uri;\n\t(void)err;\n\tre_printf(\"engine ready.\\n\");\n\tconfig_alloc(&g_config, config_req_handler, NULL, NULL);\n\tconfig_start(g_config);\n#if 0\n\terr = stun_uri_decode(&uri, turn_uri);\n\tif (err) {\n\t\twarning(\"netprobe: ready_handler: failed to parse URI: %s\\n\",\n\t\t\tturn_uri);\n\t\treturn;\n\t}\n\tstart_netprobe(&uri.addr, uri.proto, uri.secure, \"\", \"\");\n#endif\n}", "target": 0}
{"code": "int WebContentsImpl::GetEmbeddedInstanceID() const {\n  BrowserPluginGuest* guest = GetBrowserPluginGuest();\n  if (guest)\n    return guest->instance_id();\n  return 0;\n}", "target": 0}
{"code": "archive_write_disk_set_acls(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode)\n{\n\tint\t\tret = ARCHIVE_OK;\n#if !ARCHIVE_ACL_LIBRICHACL\n\t(void)mode;\t\n#endif\n#if ARCHIVE_ACL_LIBRICHACL\n\tif ((archive_acl_types(abstract_acl)\n\t    & ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {\n\t\tret = set_richacl(a, fd, name, abstract_acl, mode,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4, \"nfs4\");\n\t}\n#if ARCHIVE_ACL_LIBACL\n\telse\n#endif\n#endif\t\n#if ARCHIVE_ACL_LIBACL\n\tif ((archive_acl_types(abstract_acl)\n\t    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {\n\t\tif ((archive_acl_types(abstract_acl)\n\t\t    & ARCHIVE_ENTRY_ACL_TYPE_ACCESS) != 0) {\n\t\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_ACCESS, \"access\");\n\t\t\tif (ret != ARCHIVE_OK)\n\t\t\t\treturn (ret);\n\t\t}\n\t\tif ((archive_acl_types(abstract_acl)\n\t\t    & ARCHIVE_ENTRY_ACL_TYPE_DEFAULT) != 0)\n\t\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT, \"default\");\n\t}\n#endif\t\n\treturn (ret);\n}", "target": 1}
{"code": "void CxImage::Startup(uint32_t imagetype)\n{\n\tpDib = pSelection = pAlpha = NULL;\n\tppLayers = ppFrames = NULL;\n\tmemset(&head,0,sizeof(BITMAPINFOHEADER));\n\tmemset(&info,0,sizeof(CXIMAGEINFO));\n    info.dwType = imagetype;\n\tinfo.fQuality = 90.0f;\n\tinfo.nAlphaMax = 255;\n\tinfo.nBkgndIndex = -1;\n\tinfo.bEnabled = true;\n\tinfo.nJpegScale = 1;\n\tSetXDPI(CXIMAGE_DEFAULT_DPI);\n\tSetYDPI(CXIMAGE_DEFAULT_DPI);\n\tint16_t test = 1;\n\tinfo.bLittleEndianHost = (*((char *) &test) == 1);\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input_sizes = context->input(0);\n    const Tensor& filter = context->input(1);\n    const Tensor& out_backprop = context->input(2);\n    OP_REQUIRES(\n        context, out_backprop.dims() == 4,\n        errors::InvalidArgument(\"input_sizes must be 4-dimensional, got: \",\n                                out_backprop.dims()));\n    TensorShape input_shape;\n    OP_REQUIRES_OK(context,\n                   Conv2DBackpropComputeInputShape(input_sizes, filter.shape(),\n                                                   out_backprop.shape(),\n                                                   data_format_, &input_shape));\n    Tensor* in_backprop = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input_shape, &in_backprop));\n    if (input_shape.num_elements() == 0) {\n      return;\n    }\n    if (out_backprop.NumElements() == 0) {\n      functor::SetZeroFunctor<Device, T> set_zero;\n      set_zero(context->eigen_device<Device>(),\n               in_backprop->template flat<T>());\n      return;\n    }\n    const int stride_rows = GetTensorDim(strides_, data_format_, 'H');\n    const int stride_cols = GetTensorDim(strides_, data_format_, 'W');\n    const int dilation_rows = GetTensorDim(dilations_, data_format_, 'H');\n    const int dilation_cols = GetTensorDim(dilations_, data_format_, 'W');\n    VLOG(2) << \"Conv2DBackpropInput:\"\n            << \" input: \" << input_shape.DebugString()\n            << \" filter:\" << filter.shape().DebugString()\n            << \" out_backprop: \" << out_backprop.shape().DebugString()\n            << \" strides: [\" << stride_rows << \", \" << stride_cols << \"]\"\n            << \" dilations: [\" << dilation_rows << \", \" << dilation_cols << \"]\";\n    LaunchConv2DBackpropInputOp<Device, T> launch;\n    launch(context, use_cudnn_, cudnn_use_autotune_, out_backprop, filter,\n           dilation_rows, dilation_cols, stride_rows, stride_cols, padding_,\n           explicit_paddings_, in_backprop, data_format_);\n  }", "target": 0}
{"code": "TEST_IMPL(utf8_decode1_overrun) {\n  const char* p;\n  char b[1];\n  char c[1];\n  p = b;\n  b[0] = 0x7F;\n  ASSERT_EQ(0x7F, uv__utf8_decode1(&p, b + 1));\n  ASSERT_PTR_EQ(p, b + 1);\n  p = b;\n  b[0] = 0xC0;\n  ASSERT_EQ((unsigned) -1, uv__utf8_decode1(&p, b + 1));\n  ASSERT_PTR_EQ(p, b + 1);\n  b[0] = 0x7F;\n  ASSERT_EQ(UV_EINVAL, uv__idna_toascii(b, b + 0, c, c + 1));\n  ASSERT_EQ(UV_EINVAL, uv__idna_toascii(b, b + 1, c, c + 1));\n  return 0;\n}", "target": 0}
{"code": "  bool ms_verify_authorizer(Connection *con, int peer_type,\n\t\t\t\t    int protocol, bufferlist& authorizer,\n\t\t\t\t    bufferlist& authorizer_reply,\n\t\t\t\t    bool& isvalid, CryptoKey& session_key) override {\n    isvalid = true;\n    return true;\n  };", "target": 1}
{"code": "void Statement::Work_Bind(napi_env e, void* data) {\n    STATEMENT_INIT(Baton);\n    STATEMENT_MUTEX(mtx);\n    sqlite3_mutex_enter(mtx);\n    stmt->Bind(baton->parameters);\n    sqlite3_mutex_leave(mtx);\n}", "target": 0}
{"code": "static void __skb_complete_tx_timestamp(struct sk_buff *skb,\n\t\t\t\t\tstruct sock *sk,\n\t\t\t\t\tint tstype)\n{\n\tstruct sock_exterr_skb *serr;\n\tint err;\n\tserr = SKB_EXT_ERR(skb);\n\tmemset(serr, 0, sizeof(*serr));\n\tserr->ee.ee_errno = ENOMSG;\n\tserr->ee.ee_origin = SO_EE_ORIGIN_TIMESTAMPING;\n\tserr->ee.ee_info = tstype;\n\tif (sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID) {\n\t\tserr->ee.ee_data = skb_shinfo(skb)->tskey;\n\t\tif (sk->sk_protocol == IPPROTO_TCP &&\n\t\t    sk->sk_type == SOCK_STREAM)\n\t\t\tserr->ee.ee_data -= sk->sk_tskey;\n\t}\n\terr = sock_queue_err_skb(sk, skb);\n\tif (err)\n\t\tkfree_skb(skb);", "target": 1}
{"code": "int rm_rf_child(int fd, const char *name, RemoveFlags flags) {\n        if (fd < 0)\n                return -EBADF;\n        if (!filename_is_valid(name))\n                return -EINVAL;\n        if ((flags & (REMOVE_ROOT|REMOVE_MISSING_OK)) != 0) \n                return -EINVAL;\n        if (FLAGS_SET(flags, REMOVE_ONLY_DIRECTORIES|REMOVE_SUBVOLUME))\n                return -EINVAL;\n        return rm_rf_children_inner(fd, name, -1, flags, NULL);\n}", "target": 1}
{"code": "static int verify_ordered(unsigned mode1, const char *name1, unsigned mode2, const char *name2)\n{\n\tint len1 = strlen(name1);\n\tint len2 = strlen(name2);\n\tint len = len1 < len2 ? len1 : len2;\n\tunsigned char c1, c2;\n\tint cmp;\n\tcmp = memcmp(name1, name2, len);\n\tif (cmp < 0)\n\t\treturn 0;\n\tif (cmp > 0)\n\t\treturn TREE_UNORDERED;\n\tc1 = name1[len];\n\tc2 = name2[len];\n\tif (!c1 && !c2)\n\t\treturn TREE_HAS_DUPS;\n\tif (!c1 && S_ISDIR(mode1))\n\t\tc1 = '/';\n\tif (!c2 && S_ISDIR(mode2))\n\t\tc2 = '/';\n\treturn c1 < c2 ? 0 : TREE_UNORDERED;\n}", "target": 0}
{"code": "static MagickBooleanType ReadPSDChannelPixels(Image *image,\n  const size_t channels,const size_t row,const ssize_t type,\n  const unsigned char *pixels,ExceptionInfo *exception)\n{\n  Quantum\n    pixel;\n  register const unsigned char\n    *p;\n  register Quantum\n    *q;\n  register ssize_t\n    x;\n  size_t\n    packet_size;\n  unsigned short\n    nibble;\n  p=pixels;\n  q=GetAuthenticPixels(image,0,row,image->columns,1,exception);\n  if (q == (Quantum *) NULL)\n    return MagickFalse;\n  packet_size=GetPSDPacketSize(image);\n  for (x=0; x < (ssize_t) image->columns; x++)\n  {\n    if (packet_size == 1)\n      pixel=ScaleCharToQuantum(*p++);\n    else\n      {\n        p=PushShortPixel(MSBEndian,p,&nibble);\n        pixel=ScaleShortToQuantum(nibble);\n      }\n    if (image->depth > 1)\n      {\n        SetPSDPixel(image,channels,type,packet_size,pixel,q,exception);\n        q+=GetPixelChannels(image);\n      }\n    else\n      {\n        ssize_t\n          bit,\n          number_bits;\n        number_bits=image->columns-x;\n        if (number_bits > 8)\n          number_bits=8;\n        for (bit = 0; bit < number_bits; bit++)\n        {\n          SetPSDPixel(image,channels,type,packet_size,(((unsigned char) pixel)\n            & (0x01 << (7-bit))) != 0 ? 0 : 255,q,exception);\n          q+=GetPixelChannels(image);\n          x++;\n        }\n        if (x != image->columns)\n          x--;\n        continue;\n      }\n  }\n  return(SyncAuthenticPixels(image,exception));\n}", "target": 0}
{"code": "void ConnPoolImplBase::checkForIdleAndNotify() {\n  if (isIdleImpl()) {\n    ENVOY_LOG(debug, \"invoking idle callbacks - is_draining_for_deletion_={}\",\n              is_draining_for_deletion_);\n    for (const Instance::IdleCb& cb : idle_callbacks_) {\n      cb();\n    }\n  }\n}", "target": 0}
{"code": "static ssize_t k90_show_macro_mode(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tint ret;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tconst char *macro_mode;\n\tchar data[8];\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_GET_MODE,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 2,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial mode (error %d).\\n\",\n\t\t\t ret);\n\t\treturn -EIO;\n\t}\n\tswitch (data[0]) {\n\tcase K90_MACRO_MODE_HW:\n\t\tmacro_mode = \"HW\";\n\t\tbreak;\n\tcase K90_MACRO_MODE_SW:\n\t\tmacro_mode = \"SW\";\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dev, \"K90 in unknown mode: %02hhx.\\n\",\n\t\t\t data[0]);\n\t\treturn -EIO;\n\t}\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", macro_mode);\n}", "target": 1}
{"code": "ebt_check_watcher(struct ebt_entry_watcher *w, struct xt_tgchk_param *par,\n\t\t  unsigned int *cnt)\n{\n\tconst struct ebt_entry *e = par->entryinfo;\n\tstruct xt_target *watcher;\n\tsize_t left = ((char *)e + e->target_offset) - (char *)w;\n\tint ret;\n\tif (left < sizeof(struct ebt_entry_watcher) ||\n\t   left - sizeof(struct ebt_entry_watcher) < w->watcher_size)\n\t\treturn -EINVAL;\n\twatcher = xt_request_find_target(NFPROTO_BRIDGE, w->u.name, 0);\n\tif (IS_ERR(watcher))\n\t\treturn PTR_ERR(watcher);\n\tw->u.watcher = watcher;\n\tpar->target   = watcher;\n\tpar->targinfo = w->data;\n\tret = xt_check_target(par, w->watcher_size,\n\t      e->ethproto, e->invflags & EBT_IPROTO);\n\tif (ret < 0) {\n\t\tmodule_put(watcher->me);\n\t\treturn ret;\n\t}\n\t(*cnt)++;\n\treturn 0;\n}", "target": 0}
{"code": "ecma_op_internal_buffer_append (ecma_collection_t *container_p, \n                                ecma_value_t key_arg, \n                                ecma_value_t value_arg, \n                                lit_magic_string_id_t lit_id) \n{\n  JERRY_ASSERT (container_p != NULL);\n  ecma_collection_push_back (container_p, ecma_copy_value_if_not_object (key_arg));\n  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_MAP_UL)\n  {\n    ecma_collection_push_back (container_p, ecma_copy_value_if_not_object (value_arg));\n  }\n  ECMA_CONTAINER_SET_SIZE (container_p, ECMA_CONTAINER_GET_SIZE (container_p) + 1);\n} ", "target": 1}
{"code": "      static double mp_g(_cimg_math_parser& mp) {\n        cimg::unused(mp);\n        return cimg::grand();", "target": 0}
{"code": "static void ie_destructor(void *arg)\n{\n\tstruct ident_entry *ie = arg;\n\tmem_deref(ie->content.publish);\n\tmem_deref(ie->content.accept);\n\tmem_deref(ie->ident);\n}", "target": 0}
{"code": "fbFetchPixel_b1g2r1 (const FbBits *bits, int offset, miIndexedPtr indexed)\n{\n    CARD32  pixel = Fetch4(bits, offset);\n    CARD32  r,g,b;\n    b = ((pixel & 0x8) * 0xff) >> 3;\n    g = ((pixel & 0x6) * 0x55) << 7;\n    r = ((pixel & 0x1) * 0xff) << 16;\n    return 0xff000000|r|g|b;\n}", "target": 0}
{"code": "int addattr32(struct nlmsghdr *n, int maxlen, int type, __u32 data)\n{\n\treturn addattr_l(n, maxlen, type, &data, sizeof(__u32));\n}", "target": 0}
{"code": "fb_mmap(struct file *file, struct vm_area_struct * vma)\n{\n\tstruct fb_info *info = file_fb_info(file);\n\tstruct fb_ops *fb;\n\tunsigned long off;\n\tunsigned long start;\n\tu32 len;\n\tif (!info)\n\t\treturn -ENODEV;\n\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT))\n\t\treturn -EINVAL;\n\toff = vma->vm_pgoff << PAGE_SHIFT;\n\tfb = info->fbops;\n\tif (!fb)\n\t\treturn -ENODEV;\n\tmutex_lock(&info->mm_lock);\n\tif (fb->fb_mmap) {\n\t\tint res;\n\t\tres = fb->fb_mmap(info, vma);\n\t\tmutex_unlock(&info->mm_lock);\n\t\treturn res;\n\t}\n\tstart = info->fix.smem_start;\n\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.smem_len);\n\tif (off >= len) {\n\t\toff -= len;\n\t\tif (info->var.accel_flags) {\n\t\t\tmutex_unlock(&info->mm_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tstart = info->fix.mmio_start;\n\t\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.mmio_len);\n\t}\n\tmutex_unlock(&info->mm_lock);\n\tstart &= PAGE_MASK;\n\tif ((vma->vm_end - vma->vm_start + off) > len)\n\t\treturn -EINVAL;\n\toff += start;\n\tvma->vm_pgoff = off >> PAGE_SHIFT;\n\tvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\n\tfb_pgprotect(file, vma, off);\n\tif (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,\n\t\t\t     vma->vm_end - vma->vm_start, vma->vm_page_prot))\n\t\treturn -EAGAIN;\n\treturn 0;\n}", "target": 1}
{"code": "static Image *ExtractPostscript(Image *image,const ImageInfo *image_info,\n  MagickOffsetType PS_Offset,ssize_t PS_Size,ExceptionInfo *exception)\n{\n  char\n    postscript_file[MagickPathExtent];\n  const MagicInfo\n    *magic_info;    \n  FILE\n    *ps_file;\n  ImageInfo\n    *clone_info;\n  Image\n    *image2;\n  unsigned char\n    magick[2*MagickPathExtent];    \n  if ((clone_info=CloneImageInfo(image_info)) == NULL)\n    return(image);\n  clone_info->blob=(void *) NULL;\n  clone_info->length=0;\n  (void) AcquireUniqueFilename(postscript_file);\n  ps_file=fopen_utf8(postscript_file,\"wb\");\n  if (ps_file == (FILE *) NULL)\n    goto FINISH;\n  (void) SeekBlob(image,PS_Offset,SEEK_SET);\n  (void) ReadBlob(image, 2*MagickPathExtent, magick);\n  (void) SeekBlob(image,PS_Offset,SEEK_SET);\n  while(PS_Size-- > 0)\n    {\n      (void) fputc(ReadBlobByte(image),ps_file);\n    }\n  (void) fclose(ps_file);\n  magic_info=GetMagicInfo(magick,2*MagickPathExtent,exception);\n  if(magic_info == (const MagicInfo *) NULL) goto FINISH_UNL;\n  if(exception->severity != UndefinedException) goto FINISH_UNL;     \n  if(magic_info->name == (char *) NULL) goto FINISH_UNL;\n  (void) CopyMagickMemory(clone_info->magick,magic_info->name,MagickPathExtent);\n  FormatLocaleString(clone_info->filename,MagickPathExtent,\"%s\",postscript_file);\n  image2=ReadImage(clone_info,exception);\n  if (!image2)\n    goto FINISH_UNL;\n  (void) CopyMagickMemory(image2->filename,image->filename,MagickPathExtent);\n  (void) CopyMagickMemory(image2->magick_filename,image->magick_filename,MagickPathExtent);\n  (void) CopyMagickMemory(image2->magick,image->magick,MagickPathExtent);\n  image2->depth=image->depth;\n  DestroyBlob(image2);\n  image2->blob=ReferenceBlob(image->blob);\n  if ((image->rows == 0) || (image->columns == 0))\n    DeleteImageFromList(&image);\n  AppendImageToList(&image,image2);\n FINISH_UNL:    \n  (void) RelinquishUniqueFileResource(postscript_file);\n FINISH:\n  DestroyImageInfo(clone_info);\n  return(image);\n}", "target": 1}
{"code": "static ssize_t yurex_read(struct file *file, char __user *buffer, size_t count,\n\t\t\t  loff_t *ppos)\n{\n\tstruct usb_yurex *dev;\n\tint retval = 0;\n\tint bytes_read = 0;\n\tchar in_buffer[20];\n\tunsigned long flags;\n\tdev = file->private_data;\n\tmutex_lock(&dev->io_mutex);\n\tif (!dev->interface) {\t\t\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n\t}\n\tspin_lock_irqsave(&dev->lock, flags);\n\tbytes_read = snprintf(in_buffer, 20, \"%lld\\n\", dev->bbu);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\tif (*ppos < bytes_read) {\n\t\tif (copy_to_user(buffer, in_buffer + *ppos, bytes_read - *ppos))\n\t\t\tretval = -EFAULT;\n\t\telse {\n\t\t\tretval = bytes_read - *ppos;\n\t\t\t*ppos += bytes_read;\n\t\t}\n\t}\nexit:\n\tmutex_unlock(&dev->io_mutex);\n\treturn retval;\n}", "target": 1}
{"code": "void mutt_socket_empty(struct Connection *conn)\n{\n  if (!conn)\n    return;\n  char buf[1024];\n  int bytes;\n  while ((bytes = mutt_socket_poll(conn, 0)) > 0)\n  {\n    mutt_socket_read(conn, buf, MIN(bytes, sizeof(buf)));\n  }\n}", "target": 0}
{"code": "static long vbg_misc_device_ioctl(struct file *filp, unsigned int req,\n\t\t\t\t  unsigned long arg)\n{\n\tstruct vbg_session *session = filp->private_data;\n\tsize_t returned_size, size;\n\tstruct vbg_ioctl_hdr hdr;\n\tbool is_vmmdev_req;\n\tint ret = 0;\n\tvoid *buf;\n\tif (copy_from_user(&hdr, (void *)arg, sizeof(hdr)))\n\t\treturn -EFAULT;\n\tif (hdr.version != VBG_IOCTL_HDR_VERSION)\n\t\treturn -EINVAL;\n\tif (hdr.size_in < sizeof(hdr) ||\n\t    (hdr.size_out && hdr.size_out < sizeof(hdr)))\n\t\treturn -EINVAL;\n\tsize = max(hdr.size_in, hdr.size_out);\n\tif (_IOC_SIZE(req) && _IOC_SIZE(req) != size)\n\t\treturn -EINVAL;\n\tif (size > SZ_16M)\n\t\treturn -E2BIG;\n\tis_vmmdev_req = (req & ~IOCSIZE_MASK) == VBG_IOCTL_VMMDEV_REQUEST(0) ||\n\t\t\t req == VBG_IOCTL_VMMDEV_REQUEST_BIG;\n\tif (is_vmmdev_req)\n\t\tbuf = vbg_req_alloc(size, VBG_IOCTL_HDR_TYPE_DEFAULT);\n\telse\n\t\tbuf = kmalloc(size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(buf, (void *)arg, hdr.size_in)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\tif (hdr.size_in < size)\n\t\tmemset(buf + hdr.size_in, 0, size -  hdr.size_in);\n\tret = vbg_core_ioctl(session, req, buf);\n\tif (ret)\n\t\tgoto out;\n\treturned_size = ((struct vbg_ioctl_hdr *)buf)->size_out;\n\tif (returned_size > size) {\n\t\tvbg_debug(\"%s: too much output data %zu > %zu\\n\",\n\t\t\t  __func__, returned_size, size);\n\t\treturned_size = size;\n\t}\n\tif (copy_to_user((void *)arg, buf, returned_size) != 0)\n\t\tret = -EFAULT;\nout:\n\tif (is_vmmdev_req)\n\t\tvbg_req_free(buf, size);\n\telse\n\t\tkfree(buf);\n\treturn ret;\n}", "target": 1}
{"code": "de_dotdot( char* file )\n    {\n    char* cp;\n    char* cp2;\n    int l;\n    while ( ( cp = strstr( file, \"\n\t{\n\tfor ( cp2 = cp + 2; *cp2 == '/'; ++cp2 )\n\t    continue;\n\t(void) strcpy( cp + 1, cp2 );\n\t}\n    while ( strncmp( file, \"./\", 2 ) == 0 )\n\t(void) memmove( file, file + 2, strlen( file ) - 1 );\n    while ( ( cp = strstr( file, \"/./\") ) != (char*) 0 )\n\t(void) memmove( cp, cp + 2, strlen( file ) - 1 );\n    for (;;)\n\t{\n\twhile ( strncmp( file, \"../\", 3 ) == 0 )\n\t    (void) memmove( file, file + 3, strlen( file ) - 2 );\n\tcp = strstr( file, \"/../\" );\n\tif ( cp == (char*) 0 )\n\t    break;\n\tfor ( cp2 = cp - 1; cp2 >= file && *cp2 != '/'; --cp2 )\n\t    continue;\n\t(void) strcpy( cp2 + 1, cp + 4 );\n\t}\n    while ( ( l = strlen( file ) ) > 3 &&\n\t    strcmp( ( cp = file + l - 3 ), \"/..\" ) == 0 )\n\t{\n\tfor ( cp2 = cp - 1; cp2 >= file && *cp2 != '/'; --cp2 )\n\t    continue;\n\tif ( cp2 < file )\n\t    break;\n\t*cp2 = '\\0';\n\t}\n    }", "target": 1}
{"code": "static char *rfc2047_decode_word(const char *s, size_t len, enum ContentEncoding enc)\n{\n  const char *it = s;\n  const char *end = s + len;\n  if (enc == ENCQUOTEDPRINTABLE)\n  {\n    struct Buffer buf = { 0 };\n    for (; it < end; ++it)\n    {\n      if (*it == '_')\n      {\n        mutt_buffer_addch(&buf, ' ');\n      }\n      else if ((*it == '=') && (!(it[1] & ~127) && hexval(it[1]) != -1) &&\n               (!(it[2] & ~127) && hexval(it[2]) != -1))\n      {\n        mutt_buffer_addch(&buf, (hexval(it[1]) << 4) | hexval(it[2]));\n        it += 2;\n      }\n      else\n      {\n        mutt_buffer_addch(&buf, *it);\n      }\n    }\n    mutt_buffer_addch(&buf, '\\0');\n    return buf.data;\n  }\n  else if (enc == ENCBASE64)\n  {\n    char *out = mutt_mem_malloc(3 * len / 4 + 1);\n    int dlen = mutt_b64_decode(out, it);\n    if (dlen == -1)\n    {\n      FREE(&out);\n      return NULL;\n    }\n    out[dlen] = '\\0';\n    return out;\n  }\n  assert(0); \n  return NULL;\n}", "target": 1}
{"code": "int wcall_i_answer(struct wcall *wcall,\n\t\t   int call_type, int audio_cbr)\n{\n\tint err = 0;\n\tbool cbr = audio_cbr != 0;\n\tif (!wcall) {\n\t\twarning(\"wcall; answer: no wcall\\n\");\n\t\treturn EINVAL;\n\t}\n\tcall_type = (call_type == WCALL_CALL_TYPE_FORCED_AUDIO) ?\n\t\t    WCALL_CALL_TYPE_NORMAL : call_type;\n\tinfo(APITAG \"wcall(%p): answer calltype=%s\\n\",\n\t     wcall, wcall_call_type_name(call_type));\n\tif (wcall->disable_audio)\n\t\twcall->disable_audio = false;\n\tif (!wcall->icall) {\n\t\twarning(\"wcall(%p): answer: no call object found\\n\", wcall);\n\t\treturn ENOTSUP;\n\t}\n\tset_state(wcall, WCALL_STATE_ANSWERED);\n\tif (call_type == WCALL_CALL_TYPE_VIDEO) {\n\t\tICALL_CALL(wcall->icall,\n\t\t\t   set_video_send_state,\n\t\t\t   ICALL_VIDEO_STATE_STARTED);\n\t}\n\telse {\n\t\tICALL_CALL(wcall->icall,\n\t\t\t   set_video_send_state,\n\t\t\t   ICALL_VIDEO_STATE_STOPPED);\n\t}\n\terr = ICALL_CALLE(wcall->icall, answer,\n\t\t\t  call_type, cbr);\n\treturn err;\n}", "target": 1}
{"code": "static int semctl_down(struct ipc_namespace *ns, int semid,\n\t\t       int cmd, int version, void __user *p)\n{\n\tstruct sem_array *sma;\n\tint err;\n\tstruct semid64_ds semid64;\n\tstruct kern_ipc_perm *ipcp;\n\tif(cmd == IPC_SET) {\n\t\tif (copy_semid_from_user(&semid64, p, version))\n\t\t\treturn -EFAULT;\n\t}\n\tipcp = ipcctl_pre_down_nolock(ns, &sem_ids(ns), semid, cmd,\n\t\t\t\t      &semid64.sem_perm, 0);\n\tif (IS_ERR(ipcp))\n\t\treturn PTR_ERR(ipcp);\n\tsma = container_of(ipcp, struct sem_array, sem_perm);\n\terr = security_sem_semctl(sma, cmd);\n\tif (err) {\n\t\trcu_read_unlock();\n\t\tgoto out_unlock;\n\t}\n\tswitch(cmd){\n\tcase IPC_RMID:\n\t\tipc_lock_object(&sma->sem_perm);\n\t\tfreeary(ns, ipcp);\n\t\tgoto out_up;\n\tcase IPC_SET:\n\t\tipc_lock_object(&sma->sem_perm);\n\t\terr = ipc_update_perm(&semid64.sem_perm, ipcp);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t\tsma->sem_ctime = get_seconds();\n\t\tbreak;\n\tdefault:\n\t\trcu_read_unlock();\n\t\terr = -EINVAL;\n\t\tgoto out_up;\n\t}\nout_unlock:\n\tsem_unlock(sma);\nout_up:\n\tup_write(&sem_ids(ns).rw_mutex);\n\treturn err;\n}", "target": 1}
{"code": "_dbus_fd_set_close_on_exec (intptr_t fd)\n{\n  int val;\n  val = fcntl (fd, F_GETFD, 0);\n  if (val < 0)\n    return;\n  val |= FD_CLOEXEC;\n  fcntl (fd, F_SETFD, val);\n}", "target": 0}
{"code": "\tvoid initialize(const string &path, bool owner) {\n\t\tTRACE_POINT();\n\t\tthis->path  = path;\n\t\tthis->owner = owner;\n\t\tif (owner) {\n\t\t\tswitch (getFileTypeNoFollowSymlinks(path)) {\n\t\t\tcase FT_NONEXISTANT:\n\t\t\t\tcreateDirectory(path);\n\t\t\t\tbreak;\n\t\t\tcase FT_DIRECTORY:\n\t\t\t\tverifyDirectoryPermissions(path);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow RuntimeException(\"'\" + path + \"' already exists, and is not a directory\");\n\t\t\t}\n\t\t} else if (getFileType(path) != FT_DIRECTORY) {\n\t\t\tthrow RuntimeException(\"Server instance directory '\" + path +\n\t\t\t\t\"' does not exist\");\n\t\t}\n\t}", "target": 1}
{"code": "static size_t GetImageChannels(const Image *image)\n{\n  register ssize_t\n    i;\n  size_t\n    channels;\n  channels=0;\n  for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n  {\n    PixelChannel channel = GetPixelChannelChannel(image,i);\n    PixelTrait traits = GetPixelChannelTraits(image,channel);\n    if (traits == UndefinedPixelTrait)\n      continue;\n    if ((traits & UpdatePixelTrait) == 0)\n      continue;\n    channels++;\n  }\n  return((size_t) (channels == 0 ? 1 : channels));\n}", "target": 0}
{"code": "static inline ut8 r_read_ble8(const void *src) {\n\tif (!src) {\n\t\treturn UT8_MAX;\n\t}\n\treturn *(ut8 *)src;\n}", "target": 0}
{"code": "TEST(TensorSliceWriterTest, InvalidInput) {\n  SavedSlice ss;\n  std::array<uint32_t, 1> data;\n  std::fill(data.begin(), data.end(), 1234);\n  Status s = TensorSliceWriter::SaveData(data.data(), data.size(), &ss);\n  EXPECT_EQ(s.code(), error::INVALID_ARGUMENT);\n  EXPECT_TRUE(absl::StrContains(\n      s.error_message(),\n      \"Tensor slice serialization not implemented for dtype\"));\n}", "target": 0}
{"code": "static inline void ext2_xattr_destroy_cache(struct mb2_cache *cache)\n{\n}", "target": 0}
{"code": "R_API ut64 r_bin_java_element_pair_calc_size(RBinJavaElementValuePair *evp) {\n\tut64 sz = 0;\n\tif (evp == NULL) {\n\t\treturn sz;\n\t}\n\tsz += 2;\n\tif (evp->value) {\n\t\tsz += r_bin_java_element_value_calc_size (evp->value);\n\t}\n\treturn sz;\n}", "target": 1}
{"code": "static Jsi_RC jsi_ArrayFillCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) \n        return Jsi_LogError(\"expected array object\");\n    Jsi_RC rc = JSI_OK;\n    int istart = 0, iend, n, nsiz;\n    Jsi_Number nstart = 0, nend = 0; \n    Jsi_Value *value = Jsi_ValueArrayIndex(interp, args, 0),\n        *start = Jsi_ValueArrayIndex(interp, args, 1),\n        *end = Jsi_ValueArrayIndex(interp, args, 2);\n    Jsi_Obj *obj = _this->d.obj;\n    n = Jsi_ObjGetLength(interp, obj);\n    if (start && Jsi_GetNumberFromValue(interp, start, &nstart) == JSI_OK) {\n        istart = (int)nstart;\n        if (istart > n)\n            goto bail;\n        if (istart < 0)\n            istart = (n+istart);\n        if (istart<0)\n            goto bail;\n    }\n    if (n == 0) {\n        goto bail;\n    }\n    iend = n-1;\n    if (end && Jsi_GetNumberFromValue(interp,end, &nend) == JSI_OK) {\n        iend = (int) nend;\n        if (iend >= n)\n            iend = n;\n        if (iend < 0)\n            iend = (n+iend);\n        if (iend<0)\n            goto bail;\n    }\n    nsiz = iend-istart+1;\n    if (nsiz<=0)\n        goto bail;\n    int i;\n    for (i = istart; i <= iend; i++)\n    {\n        if (obj->arr[i])\n            Jsi_ValueCopy(interp, obj->arr[i], value);\n        else\n            obj->arr[i] = Jsi_ValueDup(interp, value);\n    }\nbail:\n    if (_this != *ret) {\n        Jsi_ValueMove(interp, *ret, _this);\n    }\n    return rc;\n}", "target": 1}
{"code": "lyd_new_output_leaf(struct lyd_node *parent, const struct lys_module *module, const char *name, const char *val_str)\n{\n    const struct lys_node *snode = NULL, *siblings;\n    if ((!parent && !module) || !name) {\n        LOGARG;\n        return NULL;\n    }\n    siblings = lyd_new_find_schema(parent, module, 1);\n    if (!siblings) {\n        LOGARG;\n        return NULL;\n    }\n    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_LEAFLIST | LYS_LEAF, &snode) || !snode) {\n        LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",\n               name, lys_node_module(siblings)->name, siblings->name);\n        return NULL;\n    }\n    return _lyd_new_leaf(parent, snode, val_str, 0, 0);\n}", "target": 1}
{"code": "void skb_complete_tx_timestamp(struct sk_buff *skb,\n\t\t\t       struct skb_shared_hwtstamps *hwtstamps)\n{\n\tstruct sock *sk = skb->sk;\n\tif (!skb_may_tx_timestamp(sk, false))\n\t\treturn;\n\tif (likely(atomic_inc_not_zero(&sk->sk_refcnt))) {\n\t\t*skb_hwtstamps(skb) = *hwtstamps;\n\t\t__skb_complete_tx_timestamp(skb, sk, SCM_TSTAMP_SND);\n\t\tsock_put(sk);\n\t}", "target": 1}
{"code": "void hashTypeTryConversion(robj *o, robj **argv, int start, int end) {\n    int i;\n    if (o->encoding != OBJ_ENCODING_ZIPLIST) return;\n    for (i = start; i <= end; i++) {\n        if (sdsEncodedObject(argv[i]) &&\n            sdslen(argv[i]->ptr) > server.hash_max_ziplist_value)\n        {\n            hashTypeConvert(o, OBJ_ENCODING_HT);\n            break;\n        }\n    }\n}", "target": 1}
{"code": "static MagickOffsetType TIFFSeekCustomStream(const MagickOffsetType offset,\n  const int whence,void *user_data)\n{\n  PhotoshopProfile\n    *profile;\n  profile=(PhotoshopProfile *) user_data;\n  switch (whence)\n  {\n    case SEEK_SET:\n    default:\n    {\n      if (offset < 0)\n        return(-1);\n      profile->offset=offset;\n      break;\n    }\n    case SEEK_CUR:\n    {\n      if (((offset > 0) && (profile->offset > (SSIZE_MAX-offset))) ||\n          ((offset < 0) && (profile->offset < (-SSIZE_MAX-offset))))\n        {\n          errno=EOVERFLOW;\n          return(-1);\n        }\n      if ((profile->offset+offset) < 0)\n        return(-1);\n      profile->offset+=offset;\n      break;\n    }\n    case SEEK_END:\n    {\n      if (((MagickOffsetType) profile->length+offset) < 0)\n        return(-1);\n      profile->offset=profile->length+offset;\n      break;\n    }\n  }\n  return(profile->offset);\n}", "target": 0}
{"code": "cib_remote_callback_dispatch(gpointer user_data)\n{\n    cib_t *cib = user_data;\n    cib_remote_opaque_t *private = cib->variant_opaque;\n    xmlNode *msg = NULL;\n    int disconnected = 0;\n    crm_info(\"Message on callback channel\");\n    crm_recv_remote_msg(private->callback.session, &private->callback.recv_buf, private->callback.encrypted, -1, &disconnected);\n    msg = crm_parse_remote_buffer(&private->callback.recv_buf);\n    while (msg) {\n        const char *type = crm_element_value(msg, F_TYPE);\n        crm_trace(\"Activating %s callbacks...\", type);\n        if (safe_str_eq(type, T_CIB)) {\n            cib_native_callback(cib, msg, 0, 0);\n        } else if (safe_str_eq(type, T_CIB_NOTIFY)) {\n            g_list_foreach(cib->notify_list, cib_native_notify, msg);\n        } else {\n            crm_err(\"Unknown message type: %s\", type);\n        }\n        free_xml(msg);\n        msg = crm_parse_remote_buffer(&private->callback.recv_buf);\n    }\n    if (disconnected) {\n        return -1;\n    }\n    return 0;\n}", "target": 0}
{"code": "static bool freelist_state_initialize(union freelist_init_state *state,\n\t\t\t\tstruct kmem_cache *cachep,\n\t\t\t\tunsigned int count)\n{\n\tbool ret;\n\tunsigned int rand;\n\trand = get_random_int();\n\tif (!cachep->random_seq) {\n\t\tprandom_seed_state(&state->rnd_state, rand);\n\t\tret = false;\n\t} else {\n\t\tstate->list = cachep->random_seq;\n\t\tstate->count = count;\n\t\tstate->pos = 0;\n\t\tstate->rand = rand;\n\t\tret = true;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static CPINLINE zend_class_entry* swoole_try_get_ce(zend_string *class_name)\n{\n    zend_class_entry *ce = zend_lookup_class(class_name);\n    if (ce)\n    {\n        return ce;\n    }\n    zval user_func, args[1], retval;\n    if ((PG(unserialize_callback_func) == NULL) || (PG(unserialize_callback_func)[0] == '\\0'))\n    {\n        zend_throw_exception_ex(NULL, 0, \"can not find class %s\", class_name->val TSRMLS_CC);\n        return NULL;\n    }\n    zend_string *fname = swoole_string_init(ZEND_STRL(PG(unserialize_callback_func)));\n    Z_STR(user_func) = fname;\n    Z_TYPE_INFO(user_func) = IS_STRING_EX;\n    ZVAL_STR(&args[0], class_name);\n    call_user_function_ex(CG(function_table), NULL, &user_func, &retval, 1, args, 0, NULL);\n    swoole_string_release(fname);\n    ce = zend_lookup_class(class_name);\n    if (!ce)\n    {\n        zend_throw_exception_ex(NULL, 0, \"can not find class %s\", class_name->val TSRMLS_CC);\n        return NULL;\n    }\n    else\n    {\n        return ce;\n    }\n}", "target": 1}
{"code": "bool GLES2DecoderImpl::IsDrawValid(GLuint max_vertex_accessed) {\n  if (!current_program_ || current_program_->IsDeleted()) {\n    return false;\n  }\n  const VertexAttribManager::VertexAttribInfoList& infos =\n      vertex_attrib_manager_.GetEnabledVertexAttribInfos();\n  for (VertexAttribManager::VertexAttribInfoList::const_iterator it =\n           infos.begin(); it != infos.end(); ++it) {\n    const VertexAttribManager::VertexAttribInfo* info = *it;\n    const ProgramManager::ProgramInfo::VertexAttribInfo* attrib_info =\n        current_program_->GetAttribInfoByLocation(info->index());\n    if (attrib_info) {\n      if (!info->CanAccess(max_vertex_accessed)) {\n        SetGLError(GL_INVALID_OPERATION,\n                   \"glDrawXXX: attempt to access out of range vertices\");\n        return false;\n      }\n    } else {\n      if (!info->buffer() || info->buffer()->IsDeleted()) {\n        SetGLError(\n            GL_INVALID_OPERATION,\n            \"glDrawXXX: attempt to render with no buffer attached to enabled \"\n            \"attrib\");\n        return false;\n      }\n    }\n  }\n  return true;\n}", "target": 0}
{"code": "utils::Status NgxEspRequest::AddHeaderToBackend(const std::string &key,\n                                                const std::string &value) {\n  ngx_table_elt_t *h = nullptr;\n  for (auto &h_in : r_->headers_in) {\n    if (key.size() == h_in.key.len &&\n        strncasecmp(key.c_str(), reinterpret_cast<const char *>(h_in.key.data),\n                    h_in.key.len) == 0) {\n      h = &h_in;\n      break;\n    }\n  }\n  if (h == nullptr) {\n    h = reinterpret_cast<ngx_table_elt_t *>(\n        ngx_list_push(&r_->headers_in.headers));\n    if (h == nullptr) {\n      return utils::Status(Code::INTERNAL, \"Out of memory\");\n    }\n    h->lowcase_key =\n        reinterpret_cast<u_char *>(ngx_pcalloc(r_->pool, key.size()));\n    if (h->lowcase_key == nullptr) {\n      return utils::Status(Code::INTERNAL, \"Out of memory\");\n    }\n    h->hash = ngx_hash_strlow(\n        h->lowcase_key,\n        reinterpret_cast<u_char *>(const_cast<char *>(key.c_str())),\n        key.size());\n  }\n  if (ngx_str_copy_from_std(r_->pool, key, &h->key) != NGX_OK ||\n      ngx_str_copy_from_std(r_->pool, value, &h->value) != NGX_OK) {\n    return utils::Status(Code::INTERNAL, \"Out of memory\");\n  }\n  ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r_->connection->log, 0,\n                 \"updates header to backend: \\\"%V: %V\\\"\", &h->key, &h->value);\n  return utils::Status::OK;\n}", "target": 1}
{"code": "X509_NAME_oneline_ex(X509_NAME * a,\n                     char *buf,\n                     unsigned int *size,\n                     unsigned long flag)\n{\n    BIO *out = NULL;\n    out = BIO_new(BIO_s_mem ());\n    if (X509_NAME_print_ex(out, a, 0, flag) > 0) {\n        if (buf != NULL && (*size) >  (unsigned int) BIO_number_written(out)) {\n            memset(buf, 0, *size);\n            BIO_read(out, buf, (int) BIO_number_written(out));\n        }\n        else {\n            *size = BIO_number_written(out);\n        }\n    }\n    BIO_free(out);\n    return (buf);\n}", "target": 1}
{"code": "static int pppol2tp_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t       char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2tp_session *session;\n\tstruct l2tp_tunnel *tunnel;\n\tint val, len;\n\tint err;\n\tstruct pppol2tp_session *ps;\n\tif (level != SOL_PPPOL2TP)\n\t\treturn udp_prot.getsockopt(sk, level, optname, optval, optlen);\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tlen = min_t(unsigned int, len, sizeof(int));\n\tif (len < 0)\n\t\treturn -EINVAL;\n\terr = -ENOTCONN;\n\tif (sk->sk_user_data == NULL)\n\t\tgoto end;\n\terr = -EBADF;\n\tsession = pppol2tp_sock_to_session(sk);\n\tif (session == NULL)\n\t\tgoto end;\n\tps = l2tp_session_priv(session);\n\tif ((session->session_id == 0) &&\n\t    (session->peer_session_id == 0)) {\n\t\terr = -EBADF;\n\t\ttunnel = l2tp_sock_to_tunnel(ps->tunnel_sock);\n\t\tif (tunnel == NULL)\n\t\t\tgoto end_put_sess;\n\t\terr = pppol2tp_tunnel_getsockopt(sk, tunnel, optname, &val);\n\t\tsock_put(ps->tunnel_sock);\n\t} else\n\t\terr = pppol2tp_session_getsockopt(sk, session, optname, &val);\n\terr = -EFAULT;\n\tif (put_user(len, optlen))\n\t\tgoto end_put_sess;\n\tif (copy_to_user((void __user *) optval, &val, len))\n\t\tgoto end_put_sess;\n\terr = 0;\nend_put_sess:\n\tsock_put(sk);\nend:\n\treturn err;\n}", "target": 1}
{"code": "static FORCEINLINE NEDMALLOCNOALIASATTR NEDMALLOCPTRATTR void *CallMalloc(void *RESTRICT mspace, size_t size, size_t alignment, unsigned flags) THROWSPEC\n{\n\tvoid *RESTRICT ret=0;\n#if USE_MAGIC_HEADERS\n\tsize_t _alignment=alignment;\n\tsize_t *_ret=0;\n\tsize+=alignment+3*sizeof(size_t);\n\t_alignment=0;\n#endif\n#if USE_ALLOCATOR==0\n\tret=(flags & M2_ZERO_MEMORY) ? syscalloc(1, size) : sysmalloc(size);\t\n#elif USE_ALLOCATOR==1\n\tret=mspace_malloc2((mstate) mspace, size, alignment, flags);\n#ifndef ENABLE_FAST_HEAP_DETECTION\n\tif(ret)\n\t{\n\t\tmchunkptr p=mem2chunk(ret);\n\t\tsize_t truesize=chunksize(p) - overhead_for(p);\n\t\tif(!leastusedaddress || (void *)((mstate) mspace)->least_addr<leastusedaddress) leastusedaddress=(void *)((mstate) mspace)->least_addr;\n\t\tif(!largestusedblock || truesize>largestusedblock) largestusedblock=(truesize+mparams.page_size) & ~(mparams.page_size-1);\n\t}\n#endif\n#endif\n\tif(!ret) return 0;\n#if DEBUG\n\tif(flags & M2_ZERO_MEMORY)\n\t{\n\t\tconst char *RESTRICT n;\n\t\tfor(n=(const char *)ret; n<(const char *)ret+size; n++)\n\t\t{\n\t\t\tassert(!*n);\n\t\t}\n\t}\n#endif\n#if USE_MAGIC_HEADERS\n\t_ret=(size_t *) ret;\n\tret=(void *)(_ret+3);\n\tif(alignment) ret=(void *)(((size_t) ret+alignment-1)&~(alignment-1));\n\tfor(; _ret<(size_t *)ret-2; _ret++) *_ret=*(size_t *)\"NEDMALOC\";\n\t_ret[0]=(size_t) mspace;\n\t_ret[1]=size-3*sizeof(size_t);\n#endif\n\treturn ret;\n}", "target": 1}
{"code": "juniper_mlfr_print(netdissect_options *ndo,\n                   const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n        l2info.pictype = DLT_JUNIPER_MLFR;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n        p+=l2info.header_len;\n        if (ndo->ndo_eflag && EXTRACT_32BITS(l2info.cookie) != 1)\n            ND_PRINT((ndo, \"Bundle-ID %u, \", l2info.bundle));\n        switch (l2info.proto) {\n        case (LLC_UI):\n        case (LLC_UI<<8):\n            isoclns_print(ndo, p, l2info.length, l2info.caplen);\n            break;\n        case (LLC_UI<<8 | NLPID_Q933):\n        case (LLC_UI<<8 | NLPID_IP):\n        case (LLC_UI<<8 | NLPID_IP6):\n            isoclns_print(ndo, p - 1, l2info.length + 1, l2info.caplen + 1);\n            break;\n        default:\n            ND_PRINT((ndo, \"unknown protocol 0x%04x, length %u\", l2info.proto, l2info.length));\n        }\n        return l2info.header_len;\n}", "target": 1}
{"code": "static int target_xcopy_locate_se_dev_e4_iter(struct se_device *se_dev,\n\t\t\t\t\t      void *data)\n{\n\tstruct xcopy_dev_search_info *info = data;\n\tunsigned char tmp_dev_wwn[XCOPY_NAA_IEEE_REGEX_LEN];\n\tint rc;\n\tif (!se_dev->dev_attrib.emulate_3pc)\n\t\treturn 0;\n\tmemset(&tmp_dev_wwn[0], 0, XCOPY_NAA_IEEE_REGEX_LEN);\n\ttarget_xcopy_gen_naa_ieee(se_dev, &tmp_dev_wwn[0]);\n\trc = memcmp(&tmp_dev_wwn[0], info->dev_wwn, XCOPY_NAA_IEEE_REGEX_LEN);\n\tif (rc != 0)\n\t\treturn 0;\n\tinfo->found_dev = se_dev;\n\tpr_debug(\"XCOPY 0xe4: located se_dev: %p\\n\", se_dev);\n\trc = target_depend_item(&se_dev->dev_group.cg_item);\n\tif (rc != 0) {\n\t\tpr_err(\"configfs_depend_item attempt failed: %d for se_dev: %p\\n\",\n\t\t       rc, se_dev);\n\t\treturn rc;\n\t}\n\tpr_debug(\"Called configfs_depend_item for se_dev: %p se_dev->se_dev_group: %p\\n\",\n\t\t se_dev, &se_dev->dev_group);\n\treturn 1;\n}", "target": 1}
{"code": "smtp_mailaddr(struct mailaddr *maddr, char *line, int mailfrom, char **args,\n    const char *domain)\n{\n\tchar   *p, *e;\n\tif (line == NULL)\n\t\treturn (0);\n\tif (*line != '<')\n\t\treturn (0);\n\te = strchr(line, '>');\n\tif (e == NULL)\n\t\treturn (0);\n\t*e++ = '\\0';\n\twhile (*e == ' ')\n\t\te++;\n\t*args = e;\n\tif (!text_to_mailaddr(maddr, line + 1))\n\t\treturn (0);\n\tp = strchr(maddr->user, ':');\n\tif (p != NULL) {\n\t\tp++;\n\t\tmemmove(maddr->user, p, strlen(p) + 1);\n\t}\n\tif (!valid_localpart(maddr->user) ||\n\t    !valid_domainpart(maddr->domain)) {\n\t\tif (mailfrom && maddr->user[0] == '\\0' && maddr->domain[0] == '\\0')\n\t\t\treturn (1);\n\t\tif (maddr->user[0] == '\\0')\n\t\t\treturn (0);\n\t\tif (maddr->domain[0] == '\\0') {\n\t\t\t(void)strlcpy(maddr->domain, domain,\n\t\t\t    sizeof(maddr->domain));\n\t\t\treturn (1);\n\t\t}\n\t\treturn (0);\n\t}\n\treturn (1);\n}", "target": 1}
{"code": "passGetEmphasis ()\n{\n  int more = 1;\n  passLinepos++;\n  passEmphasis = 0;\n  while (more)\n    {\n      switch (passLine.chars[passLinepos])\n\t{\n\tcase 'i':\n\t  passEmphasis |= italic;\n\t  break;\n\tcase 'b':\n\t  passEmphasis |= bold;\n\t  break;\n\tcase 'u':\n\t  passEmphasis |= underline;\n\t  break;\n\tcase 'c':\n\t  passEmphasis |= computer_braille;\n\t  break;\n\tdefault:\n\t  more = 0;\n\t  break;\n\t}\n      if (more)\n\tpassLinepos++;\n    }\n  if (!passEmphasis)\n    {\n      compileError (passNested, \"emphasis indicators expected\");\n      passLinepos--;\n      return 0;\n    }\n  return 1;\n}", "target": 0}
{"code": "static int msg_parse_fetch(struct ImapHeader *h, char *s)\n{\n  char tmp[SHORT_STRING];\n  char *ptmp = NULL;\n  if (!s)\n    return -1;\n  while (*s)\n  {\n    SKIPWS(s);\n    if (mutt_str_strncasecmp(\"FLAGS\", s, 5) == 0)\n    {\n      s = msg_parse_flags(h, s);\n      if (!s)\n        return -1;\n    }\n    else if (mutt_str_strncasecmp(\"UID\", s, 3) == 0)\n    {\n      s += 3;\n      SKIPWS(s);\n      if (mutt_str_atoui(s, &h->data->uid) < 0)\n        return -1;\n      s = imap_next_word(s);\n    }\n    else if (mutt_str_strncasecmp(\"INTERNALDATE\", s, 12) == 0)\n    {\n      s += 12;\n      SKIPWS(s);\n      if (*s != '\\\"')\n      {\n        mutt_debug(1, \"bogus INTERNALDATE entry: %s\\n\", s);\n        return -1;\n      }\n      s++;\n      ptmp = tmp;\n      while (*s && *s != '\\\"')\n        *ptmp++ = *s++;\n      if (*s != '\\\"')\n        return -1;\n      s++; \n      *ptmp = '\\0';\n      h->received = mutt_date_parse_imap(tmp);\n    }\n    else if (mutt_str_strncasecmp(\"RFC822.SIZE\", s, 11) == 0)\n    {\n      s += 11;\n      SKIPWS(s);\n      ptmp = tmp;\n      while (isdigit((unsigned char) *s))\n        *ptmp++ = *s++;\n      *ptmp = '\\0';\n      if (mutt_str_atol(tmp, &h->content_length) < 0)\n        return -1;\n    }\n    else if ((mutt_str_strncasecmp(\"BODY\", s, 4) == 0) ||\n             (mutt_str_strncasecmp(\"RFC822.HEADER\", s, 13) == 0))\n    {\n      return -2;\n    }\n    else if (*s == ')')\n      s++; \n    else if (*s)\n    {\n      imap_error(\"msg_parse_fetch\", s);\n      return -1;\n    }\n  }\n  return 0;\n}", "target": 1}
{"code": "unsigned long _copy_from_user(void *to, const void __user *from, unsigned long n)\n{\n\tunsigned long res = n;\n\tmight_fault();\n\tif (!should_fail_usercopy() && likely(access_ok(from, n))) {\n\t\tbarrier_nospec();\n\t\tinstrument_copy_from_user_before(to, from, n);\n\t\tres = raw_copy_from_user(to, from, n);\n\t\tinstrument_copy_from_user_after(to, from, n, res);\n\t}\n\tif (unlikely(res))\n\t\tmemset(to + (n - res), 0, res);\n\treturn res;\n}", "target": 0}
{"code": "sudoers_lookup(struct sudo_nss_list *snl, struct sudoers_context *ctx,\n    time_t now, sudoers_lookup_callback_fn_t callback, void *cb_data,\n    int *cmnd_status, int pwflag)\n{\n    struct defaults_list *defs = NULL;\n    struct sudoers_parse_tree *parse_tree = NULL;\n    struct cmndspec *cs = NULL;\n    struct sudo_nss *nss;\n    struct cmnd_info info;\n    unsigned int validated = FLAG_NO_USER | FLAG_NO_HOST;\n    int m, match = UNSPEC;\n    debug_decl(sudoers_lookup, SUDOERS_DEBUG_PARSER);\n    if (pwflag) {\n\tdebug_return_uint(sudoers_lookup_pseudo(snl, ctx, now, callback,\n\t    cb_data, pwflag));\n    }\n    if (!set_perms(ctx, PERM_RUNAS))\n\tdebug_return_uint(validated);\n    TAILQ_FOREACH(nss, snl, entries) {\n\tif (nss->query(ctx, nss, ctx->user.pw) == -1) {\n\t    SET(validated, VALIDATE_ERROR);\n\t    break;\n\t}\n\tm = sudoers_lookup_check(nss, ctx, &validated, &info, now, callback,\n\t    cb_data, &cs, &defs);\n\tif (m != UNSPEC) {\n\t    match = m;\n\t    parse_tree = nss->parse_tree;\n\t}\n\tif (!sudo_nss_can_continue(nss, m))\n\t    break;\n    }\n    if (match != UNSPEC) {\n\tif (info.cmnd_path != NULL) {\n\t    free(ctx->user.cmnd);\n\t    ctx->user.cmnd = info.cmnd_path;\n\t    if (ctx->user.cmnd_stat != NULL)\n\t\t*ctx->user.cmnd_stat = info.cmnd_stat;\n\t    *cmnd_status = info.status;\n\t}\n\tif (defs != NULL)\n\t    (void)update_defaults(ctx, parse_tree, defs, SETDEF_GENERIC, false);\n\tif (!apply_cmndspec(ctx, cs))\n\t    SET(validated, VALIDATE_ERROR);\n\telse if (match == ALLOW)\n\t    SET(validated, VALIDATE_SUCCESS);\n\telse\n\t    SET(validated, VALIDATE_FAILURE);\n    }\n    if (!restore_perms())\n\tSET(validated, VALIDATE_ERROR);\n    debug_return_uint(validated);\n}", "target": 1}
{"code": "  void readEOF() noexcept override {}", "target": 0}
{"code": "static void php_zip_get_from(INTERNAL_FUNCTION_PARAMETERS, int type) \n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tstruct zip_stat sb;\n\tstruct zip_file *zf;\n\tzend_long index = -1;\n\tzend_long flags = 0;\n\tzend_long len = 0;\n\tzend_string *filename;\n\tzend_string *buffer;\n\tint n = 0;\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\tZIP_FROM_OBJECT(intern, self);\n\tif (type == 1) {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P|ll\", &filename, &len, &flags) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t\tPHP_ZIP_STAT_PATH(intern, ZSTR_VAL(filename), ZSTR_LEN(filename), flags, sb);\n\t} else {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"l|ll\", &index, &len, &flags) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t\tPHP_ZIP_STAT_INDEX(intern, index, 0, sb);\n\t}\n\tif (sb.size < 1) {\n\t\tRETURN_EMPTY_STRING();\n\t}\n\tif (len < 1) {\n\t\tlen = sb.size;\n\t}\n\tif (index >= 0) {\n\t\tzf = zip_fopen_index(intern, index, flags);\n\t} else {\n\t\tzf = zip_fopen(intern, ZSTR_VAL(filename), flags);\n\t}\n\tif (zf == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tbuffer = zend_string_alloc(len, 0);\n\tn = zip_fread(zf, ZSTR_VAL(buffer), ZSTR_LEN(buffer));\n\tif (n < 1) {\n\t\tzend_string_free(buffer);\n\t\tRETURN_EMPTY_STRING();\n\t}\n\tzip_fclose(zf);\n\tZSTR_VAL(buffer)[n] = '\\0';\n\tZSTR_LEN(buffer) = n;\n\tRETURN_NEW_STR(buffer);\n}", "target": 1}
{"code": "static void commit_tree(struct mount *mnt, struct mount *shadows)\n{\n\tstruct mount *parent = mnt->mnt_parent;\n\tstruct mount *m;\n\tLIST_HEAD(head);\n\tstruct mnt_namespace *n = parent->mnt_ns;\n\tBUG_ON(parent == mnt);\n\tlist_add_tail(&head, &mnt->mnt_list);\n\tlist_for_each_entry(m, &head, mnt_list)\n\t\tm->mnt_ns = n;\n\tlist_splice(&head, n->list.prev);\n\tn->mounts += n->pending_mounts;\n\tn->pending_mounts = 0;\n\tattach_shadowed(mnt, parent, shadows);\n\ttouch_mnt_namespace(n);\n}", "target": 0}
{"code": "void sctp_generate_proto_unreach_event(unsigned long data)\n{\n\tstruct sctp_transport *transport = (struct sctp_transport *) data;\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct net *net = sock_net(asoc->base.sk);\n\tbh_lock_sock(asoc->base.sk);\n\tif (sock_owned_by_user(asoc->base.sk)) {\n\t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n\t\tif (!mod_timer(&transport->proto_unreach_timer,\n\t\t\t\tjiffies + (HZ/20)))\n\t\t\tsctp_association_hold(asoc);\n\t\tgoto out_unlock;\n\t}\n\tif (asoc->base.dead)\n\t\tgoto out_unlock;\n\tsctp_do_sm(net, SCTP_EVENT_T_OTHER,\n\t\t   SCTP_ST_OTHER(SCTP_EVENT_ICMP_PROTO_UNREACH),\n\t\t   asoc->state, asoc->ep, asoc, transport, GFP_ATOMIC);\nout_unlock:\n\tbh_unlock_sock(asoc->base.sk);\n\tsctp_association_put(asoc);\n}", "target": 1}
{"code": "matchCurrentInput(\n\t\tconst InString *input, int pos, const widechar *passInstructions, int passIC) {\n\tint k;\n\tint kk = pos;\n\tfor (k = passIC + 2; k < passIC + 2 + passInstructions[passIC + 1]; k++)\n\t\tif (input->chars[kk] == ENDSEGMENT || passInstructions[k] != input->chars[kk++])\n\t\t\treturn 0;\n\treturn 1;\n}", "target": 1}
{"code": "GF_Err url_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s;\n\tif (ptr->size) {\n\t\tptr->location = (char*)gf_malloc((u32) ptr->size);\n\t\tif (! ptr->location) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->location, (u32)ptr->size);\n\t\tif (ptr->location[ptr->size-1]) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] url box location is not 0-terminated\\n\" ));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "static irqreturn_t sunkbd_interrupt(struct serio *serio,\n\t\tunsigned char data, unsigned int flags)\n{\n\tstruct sunkbd *sunkbd = serio_get_drvdata(serio);\n\tif (sunkbd->reset <= -1) {\n\t\tsunkbd->reset = data;\n\t\twake_up_interruptible(&sunkbd->wait);\n\t\tgoto out;\n\t}\n\tif (sunkbd->layout == -1) {\n\t\tsunkbd->layout = data;\n\t\twake_up_interruptible(&sunkbd->wait);\n\t\tgoto out;\n\t}\n\tswitch (data) {\n\tcase SUNKBD_RET_RESET:\n\t\tschedule_work(&sunkbd->tq);\n\t\tsunkbd->reset = -1;\n\t\tbreak;\n\tcase SUNKBD_RET_LAYOUT:\n\t\tsunkbd->layout = -1;\n\t\tbreak;\n\tcase SUNKBD_RET_ALLUP: \n\t\tbreak;\n\tdefault:\n\t\tif (!sunkbd->enabled)\n\t\t\tbreak;\n\t\tif (sunkbd->keycode[data & SUNKBD_KEY]) {\n\t\t\tinput_report_key(sunkbd->dev,\n\t\t\t\t\t sunkbd->keycode[data & SUNKBD_KEY],\n\t\t\t\t\t !(data & SUNKBD_RELEASE));\n\t\t\tinput_sync(sunkbd->dev);\n\t\t} else {\n\t\t\tprintk(KERN_WARNING\n\t\t\t\t\"sunkbd.c: Unknown key (scancode %#x) %s.\\n\",\n\t\t\t\tdata & SUNKBD_KEY,\n\t\t\t\tdata & SUNKBD_RELEASE ? \"released\" : \"pressed\");\n\t\t}\n\t}\nout:\n\treturn IRQ_HANDLED;\n}", "target": 1}
{"code": "static int decode_zbuf(AVBPrint *bp, const uint8_t *data,\n                       const uint8_t *data_end)\n{\n    z_stream zstream;\n    unsigned char *buf;\n    unsigned buf_size;\n    int ret;\n    zstream.zalloc = ff_png_zalloc;\n    zstream.zfree  = ff_png_zfree;\n    zstream.opaque = NULL;\n    if (inflateInit(&zstream) != Z_OK)\n        return AVERROR_EXTERNAL;\n    zstream.next_in  = (unsigned char *)data;\n    zstream.avail_in = data_end - data;\n    av_bprint_init(bp, 0, -1);\n    while (zstream.avail_in > 0) {\n        av_bprint_get_buffer(bp, 1, &buf, &buf_size);\n        if (!buf_size) {\n            ret = AVERROR(ENOMEM);\n            goto fail;\n        }\n        zstream.next_out  = buf;\n        zstream.avail_out = buf_size;\n        ret = inflate(&zstream, Z_PARTIAL_FLUSH);\n        if (ret != Z_OK && ret != Z_STREAM_END) {\n            ret = AVERROR_EXTERNAL;\n            goto fail;\n        }\n        bp->len += zstream.next_out - buf;\n        if (ret == Z_STREAM_END)\n            break;\n    }\n    inflateEnd(&zstream);\n    bp->str[bp->len] = 0;\n    return 0;\nfail:\n    inflateEnd(&zstream);\n    av_bprint_finalize(bp, NULL);\n    return ret;\n}", "target": 1}
{"code": "static bool meta_set(RAnal *a, RAnalMetaType type, int subtype, ut64 from, ut64 to, const char *str) {\n\tif (to < from) {\n\t\treturn false;\n\t}\n\tRSpace *space = r_spaces_current (&a->meta_spaces);\n\tRIntervalNode *node = find_node_at (a, type, space, from);\n\tRAnalMetaItem *item = node ? node->data : R_NEW0 (RAnalMetaItem);\n\tif (!item) {\n\t\treturn false;\n\t}\n\titem->type = type;\n\titem->subtype = subtype;\n\titem->space = space;\n\tfree (item->str);\n\titem->str = str ? strdup (str) : NULL;\n\tif (str && !item->str) {\n\t\tif (!node) { \n\t\t\tfree (item);\n\t\t}\n\t\treturn false;\n\t}\n\tR_DIRTY (a);\n\tif (!node) {\n\t\tr_interval_tree_insert (&a->meta, from, to, item);\n\t} else if (node->end != to) {\n\t\tr_interval_tree_resize (&a->meta, node, from, to);\n\t}\n\treturn true;\n}", "target": 1}
{"code": "gdImagePtr gdImageCreate (int sx, int sy)\n{\n\tint i;\n\tgdImagePtr im;\n\tif (overflow2(sx, sy)) {\n\t\treturn NULL;\n\t}\n\tif (overflow2(sizeof(unsigned char *), sy)) {\n\t\treturn NULL;\n\t}\n\tif (overflow2(sizeof(unsigned char *), sx)) {\n\t\treturn NULL;\n\t}\n\tim = (gdImage *) gdCalloc(1, sizeof(gdImage));\n\tim->pixels = (unsigned char **) gdMalloc(sizeof(unsigned char *) * sy);\n\tim->AA_opacity = (unsigned char **) gdMalloc(sizeof(unsigned char *) * sy);\n\tim->polyInts = 0;\n\tim->polyAllocated = 0;\n\tim->brush = 0;\n\tim->tile = 0;\n\tim->style = 0;\n\tfor (i = 0; i < sy; i++) {\n\t\tim->pixels[i] = (unsigned char *) gdCalloc(sx, sizeof(unsigned char));\n\t\tim->AA_opacity[i] = (unsigned char *) gdCalloc(sx, sizeof(unsigned char));\n\t}\n\tim->sx = sx;\n\tim->sy = sy;\n\tim->colorsTotal = 0;\n\tim->transparent = (-1);\n\tim->interlace = 0;\n\tim->thick = 1;\n\tim->AA = 0;\n\tim->AA_polygon = 0;\n\tfor (i = 0; i < gdMaxColors; i++) {\n\t\tim->open[i] = 1;\n\t\tim->red[i] = 0;\n\t\tim->green[i] = 0;\n\t\tim->blue[i] = 0;\n\t}\n\tim->trueColor = 0;\n\tim->tpixels = 0;\n\tim->cx1 = 0;\n\tim->cy1 = 0;\n\tim->cx2 = im->sx - 1;\n\tim->cy2 = im->sy - 1;\n\tim->interpolation = NULL;\n\tim->interpolation_id = GD_BILINEAR_FIXED;\n\treturn im;\n}", "target": 0}
{"code": "int ipmi_si_mem_setup(struct si_sm_io *io)\n{\n\tunsigned long addr = io->addr_data;\n\tint           mapsize, idx;\n\tif (!addr)\n\t\treturn -ENODEV;\n\tio->io_cleanup = mem_cleanup;\n\tswitch (io->regsize) {\n\tcase 1:\n\t\tio->inputb = intf_mem_inb;\n\t\tio->outputb = intf_mem_outb;\n\t\tbreak;\n\tcase 2:\n\t\tio->inputb = intf_mem_inw;\n\t\tio->outputb = intf_mem_outw;\n\t\tbreak;\n\tcase 4:\n\t\tio->inputb = intf_mem_inl;\n\t\tio->outputb = intf_mem_outl;\n\t\tbreak;\n#ifdef readq\n\tcase 8:\n\t\tio->inputb = mem_inq;\n\t\tio->outputb = mem_outq;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tdev_warn(io->dev, \"Invalid register size: %d\\n\",\n\t\t\t io->regsize);\n\t\treturn -EINVAL;\n\t}\n\tfor (idx = 0; idx < io->io_size; idx++) {\n\t\tif (request_mem_region(addr + idx * io->regspacing,\n\t\t\t\t       io->regsize, DEVICE_NAME) == NULL) {\n\t\t\tmem_region_cleanup(io, idx);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\tmapsize = ((io->io_size * io->regspacing)\n\t\t   - (io->regspacing - io->regsize));\n\tio->addr = ioremap(addr, mapsize);\n\tif (io->addr == NULL) {\n\t\tmem_region_cleanup(io, io->io_size);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static request_rec *my_ap_create_request(conn_rec *c)\n{\n    apr_pool_t *p;\n    request_rec *r;\n    apr_pool_create(&p, c->pool);\n    apr_pool_tag(p, \"request\");\n    r = apr_pcalloc(p, sizeof(request_rec));\n    AP_READ_REQUEST_ENTRY((intptr_t)r, (uintptr_t)c);\n    r->pool            = p;\n    r->connection      = c;\n    r->server          = c->base_server;\n    r->user            = NULL;\n    r->ap_auth_type    = NULL;\n    r->allowed_methods = ap_make_method_list(p, 2);\n    r->headers_in      = apr_table_make(r->pool, 5);\n    r->trailers_in     = apr_table_make(r->pool, 5);\n    r->subprocess_env  = apr_table_make(r->pool, 25);\n    r->headers_out     = apr_table_make(r->pool, 12);\n    r->err_headers_out = apr_table_make(r->pool, 5);\n    r->trailers_out    = apr_table_make(r->pool, 5);\n    r->notes           = apr_table_make(r->pool, 5);\n    r->request_config  = ap_create_request_config(r->pool);\n    r->proto_output_filters = c->output_filters;\n    r->output_filters  = r->proto_output_filters;\n    r->proto_input_filters = c->input_filters;\n    r->input_filters   = r->proto_input_filters;\n    ap_run_create_request(r);\n    r->per_dir_config  = r->server->lookup_defaults;\n    r->sent_bodyct     = 0;                      \n    r->read_length     = 0;\n    r->read_body       = REQUEST_NO_BODY;\n    r->status          = HTTP_OK;  \n    r->header_only     = 0;\n    r->the_request     = NULL;\n    r->used_path_info = AP_REQ_DEFAULT_PATH_INFO;\n    r->useragent_addr = c->client_addr;\n    r->useragent_ip = c->client_ip;\n    return r;\n}", "target": 1}
{"code": "void JSArray::sortNumeric(ExecState* exec, JSValue compareFunction, CallType callType, const CallData& callData)\n{\n    ArrayStorage* storage = m_storage;\n    unsigned lengthNotIncludingUndefined = compactForSorting();\n    if (storage->m_sparseValueMap) {\n        throwOutOfMemoryError(exec);\n        return;\n    }\n    if (!lengthNotIncludingUndefined)\n        return;\n    bool allValuesAreNumbers = true;\n    size_t size = storage->m_numValuesInVector;\n    for (size_t i = 0; i < size; ++i) {\n        if (!storage->m_vector[i].isNumber()) {\n            allValuesAreNumbers = false;\n            break;\n        }\n    }\n    if (!allValuesAreNumbers)\n        return sort(exec, compareFunction, callType, callData);\n    qsort(storage->m_vector, size, sizeof(JSValue), compareNumbersForQSort);\n    checkConsistency(SortConsistencyCheck);\n}", "target": 0}
{"code": "cifs_find_smb_ses(struct TCP_Server_Info *server, char *username)\n{\n\tstruct list_head *tmp;\n\tstruct cifsSesInfo *ses;\n\twrite_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &server->smb_ses_list) {\n\t\tses = list_entry(tmp, struct cifsSesInfo, smb_ses_list);\n\t\tif (strncmp(ses->userName, username, MAX_USERNAME_SIZE))\n\t\t\tcontinue;\n\t\t++ses->ses_count;\n\t\twrite_unlock(&cifs_tcp_ses_lock);\n\t\treturn ses;\n\t}\n\twrite_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}", "target": 1}
{"code": "uint64_t HeaderMapImpl::refreshByteSize() {\n  if (!cached_byte_size_.has_value()) {\n    cached_byte_size_ = byteSizeInternal();\n  }\n  return cached_byte_size_.value();\n}", "target": 0}
{"code": "static inline struct sec_path *skb_sec_path(struct sk_buff *skb)\n{\n\treturn NULL;\n}", "target": 0}
{"code": "static int cit_get_packet_size(struct gspca_dev *gspca_dev)\n{\n\tstruct usb_host_interface *alt;\n\tstruct usb_interface *intf;\n\tintf = usb_ifnum_to_if(gspca_dev->dev, gspca_dev->iface);\n\talt = usb_altnum_to_altsetting(intf, gspca_dev->alt);\n\tif (!alt) {\n\t\tpr_err(\"Couldn't get altsetting\\n\");\n\t\treturn -EIO;\n\t}\n\tif (alt->desc.bNumEndpoints < 1)\n\t\treturn -ENODEV;\n\treturn le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n}", "target": 0}
{"code": "static void inotify_free_group_priv(struct fsnotify_group *group)\n{\n\tidr_for_each(&group->inotify_data.idr, idr_callback, group);\n\tidr_remove_all(&group->inotify_data.idr);\n\tidr_destroy(&group->inotify_data.idr);\n\tatomic_dec(&group->inotify_data.user->inotify_devs);\n\tfree_uid(group->inotify_data.user);\n}", "target": 0}
{"code": "BGD_DECLARE(gdImagePtr) gdImageCreate (int sx, int sy)\n{\n\tint i;\n\tgdImagePtr im;\n\tif (overflow2(sx, sy)) {\n\t\treturn NULL;\n\t}\n\tif (overflow2(sizeof (unsigned char *), sy)) {\n\t\treturn NULL;\n\t}\n\tif (overflow2(sizeof (unsigned char), sx)) {\n\t\treturn NULL;\n\t}\n\tim = (gdImage *) gdCalloc(1, sizeof(gdImage));\n\tif (!im) {\n\t\treturn NULL;\n\t}\n\tim->pixels = (unsigned char **) gdMalloc (sizeof (unsigned char *) * sy);\n\tif (!im->pixels) {\n\t\tgdFree(im);\n\t\treturn NULL;\n\t}\n\tim->polyInts = 0;\n\tim->polyAllocated = 0;\n\tim->brush = 0;\n\tim->tile = 0;\n\tim->style = 0;\n\tfor (i = 0; (i < sy); i++) {\n\t\tim->pixels[i] = (unsigned char *) gdCalloc (sx, sizeof (unsigned char));\n\t\tif (!im->pixels[i]) {\n\t\t\tfor (--i ; i >= 0; i--) {\n\t\t\t\tgdFree(im->pixels[i]);\n\t\t\t}\n\t\t\tgdFree(im->pixels);\n\t\t\tgdFree(im);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tim->sx = sx;\n\tim->sy = sy;\n\tim->colorsTotal = 0;\n\tim->transparent = (-1);\n\tim->interlace = 0;\n\tim->thick = 1;\n\tim->AA = 0;\n\tfor (i = 0; (i < gdMaxColors); i++) {\n\t\tim->open[i] = 1;\n\t};\n\tim->trueColor = 0;\n\tim->tpixels = 0;\n\tim->cx1 = 0;\n\tim->cy1 = 0;\n\tim->cx2 = im->sx - 1;\n\tim->cy2 = im->sy - 1;\n\tim->res_x = GD_RESOLUTION;\n\tim->res_y = GD_RESOLUTION;\n\tim->interpolation = NULL;\n\tim->interpolation_id = GD_BILINEAR_FIXED;\n\treturn im;\n}", "target": 0}
{"code": "const git_tree_entry *git_treebuilder_get(git_treebuilder *bld, const char *filename)\n{\n\treturn treebuilder_get(bld, filename);\n}", "target": 0}
{"code": "static int sched_read_attr(struct sched_attr __user *uattr,\n\t\t\t   struct sched_attr *attr,\n\t\t\t   unsigned int usize)\n{\n\tint ret;\n\tif (!access_ok(VERIFY_WRITE, uattr, usize))\n\t\treturn -EFAULT;\n\tif (usize < sizeof(*attr)) {\n\t\tunsigned char *addr;\n\t\tunsigned char *end;\n\t\taddr = (void *)attr + usize;\n\t\tend  = (void *)attr + sizeof(*attr);\n\t\tfor (; addr < end; addr++) {\n\t\t\tif (*addr)\n\t\t\t\tgoto err_size;\n\t\t}\n\t\tattr->size = usize;\n\t}\n\tret = copy_to_user(uattr, attr, usize);\n\tif (ret)\n\t\treturn -EFAULT;\nout:\n\treturn ret;\nerr_size:\n\tret = -E2BIG;\n\tgoto out;\n}", "target": 1}
{"code": "static unsigned mounts_poll(struct file *file, poll_table *wait)\n{\n\tstruct proc_mounts *p = file->private_data;\n\tstruct mnt_namespace *ns = p->m.private;\n\tunsigned res = 0;\n\tpoll_wait(file, &ns->poll, wait);\n\tspin_lock(&vfsmount_lock);\n\tif (p->event != ns->event) {\n\t\tp->event = ns->event;\n\t\tres = POLLERR;\n\t}\n\tspin_unlock(&vfsmount_lock);\n\treturn res;\n}", "target": 0}
{"code": "struct file *get_empty_filp(void)\n{\n\tconst struct cred *cred = current_cred();\n\tstatic long old_max;\n\tstruct file *f;\n\tint error;\n\tif (get_nr_files() >= files_stat.max_files && !capable(CAP_SYS_ADMIN)) {\n\t\tif (percpu_counter_sum_positive(&nr_files) >= files_stat.max_files)\n\t\t\tgoto over;\n\t}\n\tf = kmem_cache_zalloc(filp_cachep, GFP_KERNEL);\n\tif (unlikely(!f))\n\t\treturn ERR_PTR(-ENOMEM);\n\tpercpu_counter_inc(&nr_files);\n\tf->f_cred = get_cred(cred);\n\terror = security_file_alloc(f);\n\tif (unlikely(error)) {\n\t\tfile_free(f);\n\t\treturn ERR_PTR(error);\n\t}\n\tINIT_LIST_HEAD(&f->f_u.fu_list);\n\tatomic_long_set(&f->f_count, 1);\n\trwlock_init(&f->f_owner.lock);\n\tspin_lock_init(&f->f_lock);\n\teventpoll_init_file(f);\n\treturn f;\nover:\n\tif (get_nr_files() > old_max) {\n\t\tpr_info(\"VFS: file-max limit %lu reached\\n\", get_max_files());\n\t\told_max = get_nr_files();\n\t}\n\treturn ERR_PTR(-ENFILE);\n}", "target": 1}
{"code": "TEST_F(OpLevelCostEstimatorTest, OpDimensionsFromInputsError) {\n  std::vector<string> paddings = {\"VALID\", \"SAME\"};\n  std::vector<string> formats = {\"NHWC\", \"NCHW\"};\n  for (const auto& p : paddings) {\n    for (const auto& f : formats) {\n      ASSERT_THAT(\n          CallOpDimensionsFromInputs(10, 14, 14, 3840, 3, 3, 0, 2, f, p),\n          testing::StatusIs(\n              error::INVALID_ARGUMENT,\n              \"Stride must be > 0 for Height and Width, but got (2, 0)\"));\n      ASSERT_THAT(\n          CallOpDimensionsFromInputs(10, 14, 14, 3840, 3, 3, 2, 0, f, p),\n          testing::StatusIs(\n              error::INVALID_ARGUMENT,\n              \"Stride must be > 0 for Height and Width, but got (0, 2)\"));\n    }\n  }\n}", "target": 0}
{"code": "pacparser_find_proxy(const char *url, const char *host)\n{\n  char *error_prefix = \"pacparser.c: pacparser_find_proxy:\";\n  if (_debug()) print_error(\"DEBUG: Finding proxy for URL: %s and Host:\"\n                        \" %s\\n\", url, host);\n  jsval rval;\n  char *script;\n  if (url == NULL || (strcmp(url, \"\") == 0)) {\n    print_error(\"%s %s\\n\", error_prefix, \"URL not defined\");\n    return NULL;\n  }\n  if (host == NULL || (strcmp(host,\"\") == 0)) {\n    print_error(\"%s %s\\n\", error_prefix, \"Host not defined\");\n    return NULL;\n  }\n  if (cx == NULL || global == NULL) {\n    print_error(\"%s %s\\n\", error_prefix, \"Pac parser is not initialized.\");\n    return NULL;\n  }\n  script = \"typeof(findProxyForURL);\";\n  if (_debug()) print_error(\"DEBUG: Executing JavaScript: %s\\n\", script);\n  JS_EvaluateScript(cx, global, script, strlen(script), NULL, 1, &rval);\n  if (strcmp(\"function\", JS_GetStringBytes(JS_ValueToString(cx, rval))) != 0) {\n    print_error(\"%s %s\\n\", error_prefix,\n\t\t  \"Javascript function findProxyForURL not defined.\");\n    return NULL;\n  }\n  char *sanitized_url = str_replace(url, \"'\", \"%27\");\n  if (strchr(host, '\\'')) {\n    print_error(\"%s %s\\n\", error_prefix,\n\t\t\"Invalid hostname: hostname can't have single quotes.\");\n    return NULL;\n  }\n  script = (char*) malloc(32 + strlen(url) + strlen(host));\n  script[0] = '\\0';\n  strcat(script, \"findProxyForURL('\");\n  strcat(script, sanitized_url);\n  strcat(script, \"', '\");\n  strcat(script, host);\n  strcat(script, \"')\");\n  if (_debug()) print_error(\"DEBUG: Executing JavaScript: %s\\n\", script);\n  if (!JS_EvaluateScript(cx, global, script, strlen(script), NULL, 1, &rval)) {\n    print_error(\"%s %s\\n\", error_prefix, \"Problem in executing findProxyForURL.\");\n    free(sanitized_url);\n    free(script);\n    return NULL;\n  }\n  free(sanitized_url);\n  free(script);\n  return JS_GetStringBytes(JS_ValueToString(cx, rval));\n}", "target": 1}
{"code": "TEST_F(AutoParallelTest, SimpleParallelNoDequeue) {\n  tensorflow::Scope s = tensorflow::Scope::DisabledShapeInferenceScope();\n  Output constant_a = ops::Const(s.WithOpName(\"constant_a\"), 1.0f, {1});\n  Output constant_c = ops::Const(s.WithOpName(\"constant_c\"), 1.0f, {1});\n  Output constant_b = ops::Const(s.WithOpName(\"constant_b\"), 1, {1});\n  Output var = ops::Variable(s.WithOpName(\"var\"), {1}, DT_FLOAT);\n  Output assign = ops::Assign(s.WithOpName(\"assign\"), {var}, {constant_a});\n  Output add = ops::AddN(s.WithOpName(\"add\"), {constant_a, constant_c});\n  Output learning_rate = ops::Const(s.WithOpName(\"learning_rate\"), 0.01f, {1});\n  Output apply_gradient = ops::ApplyGradientDescent(\n      s.WithOpName(\"apply_gradient\"), {var}, {learning_rate}, {add});\n  GrapplerItem item;\n  item.init_ops.push_back(\"assign\");\n  item.fetch.push_back(\"apply_gradient\");\n  item.init_ops.push_back(\"assign\");\n  TF_CHECK_OK(s.ToGraphDef(&item.graph));\n  AutoParallel parallel(2);\n  GraphDef output;\n  Status status = parallel.Optimize(nullptr, item, &output);\n  TF_EXPECT_OK(status);\n}", "target": 0}
{"code": "ProcStoreNamedColor(ClientPtr client)\n{\n    ColormapPtr pcmp;\n    int rc;\n    REQUEST(xStoreNamedColorReq);\n    REQUEST_FIXED_SIZE(xStoreNamedColorReq, stuff->nbytes);\n    rc = dixLookupResourceByType((void **) &pcmp, stuff->cmap, RT_COLORMAP,\n                                 client, DixWriteAccess);\n    if (rc == Success) {\n        xColorItem def;\n        if (OsLookupColor(pcmp->pScreen->myNum, (char *) &stuff[1],\n                          stuff->nbytes, &def.red, &def.green, &def.blue)) {\n            def.flags = stuff->flags;\n            def.pixel = stuff->pixel;\n            return StoreColors(pcmp, 1, &def, client);\n        }\n        return BadName;\n    }\n    else {\n        client->errorValue = stuff->cmap;\n        return rc;\n    }\n}", "target": 0}
{"code": "update_info_in_idle_device_unreffed (gpointer user_data,\n                                     GObject *where_the_object_was)\n{\n  UpdateInfoInIdleData *data = user_data;\n  g_source_remove (data->idle_id);\n}", "target": 0}
{"code": "TEST_FUNCTION_CLEANUP(test_cleanup)\n{\n    TEST_MUTEX_RELEASE(g_testByTest);\n}", "target": 0}
{"code": "uint32_t WasmBinaryWriter::getTableIndex(Name name) const {\n  auto it = indexes.tableIndexes.find(name);\n  assert(it != indexes.tableIndexes.end());\n  return it->second;\n}", "target": 0}
{"code": "main (int argc, char *argv[])\n{\n  g_test_init (&argc, &argv, NULL);\n  g_test_add_func (\"/context/env\", test_context_env);\n  g_test_add_func (\"/context/env-fd\", test_context_env_fd);\n  g_test_add_func (\"/context/merge-fs\", test_context_merge_fs);\n  g_test_add_func (\"/context/validate-path-args\", test_validate_path_args);\n  g_test_add_func (\"/context/validate-path-meta\", test_validate_path_meta);\n  return g_test_run ();\n}", "target": 0}
{"code": "static MagickBooleanType ReadPSDChannelRLE(Image *image,const PSDInfo *psd_info,\n  const ssize_t type,MagickOffsetType *sizes,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n  size_t\n    length,\n    row_size;\n  ssize_t\n    count,\n    y;\n  unsigned char\n    *compact_pixels,\n    *pixels;\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \"      layer data is RLE compressed\");\n  row_size=GetPSDRowSize(image);\n  pixels=(unsigned char *) AcquireQuantumMemory(row_size,sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  length=0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n    if ((MagickOffsetType) length < sizes[y])\n      length=(size_t) sizes[y];\n  if (length > row_size + 256) \n    {\n      pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      ThrowBinaryException(ResourceLimitError,\"InvalidLength\",\n        image->filename);\n    }\n  compact_pixels=(unsigned char *) AcquireQuantumMemory(length,sizeof(*pixels));\n  if (compact_pixels == (unsigned char *) NULL)\n    {\n      pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  (void) ResetMagickMemory(compact_pixels,0,length*sizeof(*compact_pixels));\n  status=MagickTrue;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    status=MagickFalse;\n    count=ReadBlob(image,(size_t) sizes[y],compact_pixels);\n    if (count != (ssize_t) sizes[y])\n      break;\n    count=DecodePSDPixels((size_t) sizes[y],compact_pixels,\n      (ssize_t) (image->depth == 1 ? 123456 : image->depth),row_size,pixels);\n    if (count != (ssize_t) row_size)\n      break;\n    status=ReadPSDChannelPixels(image,psd_info->channels,y,type,pixels,\n      exception);\n    if (status == MagickFalse)\n      break;\n  }\n  compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  return(status);\n}", "target": 1}
{"code": "void WasmBinaryWriter::prepare() {\n  ModuleUtils::collectHeapTypes(*wasm, types, typeIndices);\n  importInfo = wasm::make_unique<ImportInfo>(*wasm);\n}", "target": 0}
{"code": "GF_Box *stri_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SubTrackInformationBox, GF_ISOM_BOX_TYPE_STRI);\n\treturn (GF_Box *)tmp;\n}", "target": 0}
{"code": "userlist_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct passwd *pw, const struct member_list *list)\n{\n    struct member *m;\n    int matched = UNSPEC;\n    debug_decl(userlist_matches, SUDOERS_DEBUG_MATCH);\n    TAILQ_FOREACH_REVERSE(m, list, member_list, entries) {\n\tif ((matched = user_matches(parse_tree, pw, m)) != UNSPEC)\n\t    break;\n    }\n    debug_return_int(matched);\n}", "target": 1}
{"code": "static void do_proc_open(FILE *fin, FILE *fout, int afdt_fd) {\n  char cmd[BUFFER_SIZE];\n  read_buf(fin, cmd);\n  if (strlen(cmd) == 0) {\n    fprintf(fout, \"error\\n%d\\n\", ENOENT);\n    fflush(fout);\n    return;\n  }\n  char cwd[BUFFER_SIZE];\n  read_buf(fin, cwd);\n  char buf[BUFFER_SIZE];\n  int env_size = 0;\n  std::vector<std::string> env;\n  read_buf(fin, buf);\n  sscanf(buf, \"%d\", &env_size);\n  for (int i = 0; i < env_size; i++) {\n    read_buf(fin, buf);\n    env.push_back(buf);\n  }\n  int pipe_size = 0;\n  read_buf(fin, buf);\n  sscanf(buf, \"%d\", &pipe_size);\n  std::vector<int> pvals;\n  for (int i = 0; i < pipe_size; i++) {\n    int fd_value;\n    read_buf(fin, buf);\n    sscanf(buf, \"%d\", &fd_value);\n    pvals.push_back(fd_value);\n  }\n  std::vector<int> pkeys;\n  for (int i = 0; i < pipe_size; i++) {\n    int fd = recv_fd(afdt_fd);\n    if (fd < 0) {\n      fprintf(fout, \"error\\n%d\\n\", EPROTO);\n      fflush(fout);\n      close_fds(pkeys);\n      return;\n    }\n    pkeys.push_back(fd);\n  }\n  pid_t child = fork();\n  if (child == 0) {\n    for (int i = 0; i < pipe_size; i++) {\n      dup2(pkeys[i], pvals[i]);\n    }\n    if (strlen(cwd) > 0 && chdir(cwd)) {\n    }\n    if (!env.empty()) {\n      char **envp = build_envp(env);\n      execle(\"/bin/sh\", \"sh\", \"-c\", cmd, nullptr, envp);\n      free(envp);\n    } else {\n      execl(\"/bin/sh\", \"sh\", \"-c\", cmd, nullptr);\n    }\n    _exit(127);\n  } else if (child > 0) {\n    fprintf(fout, \"%\" PRId64 \"\\n\", (int64_t)child);\n    fflush(fout);\n  } else {\n    fprintf(fout, \"error\\n%d\\n\", errno);\n    fflush(fout);\n  }\n  close_fds(pkeys);\n}", "target": 1}
{"code": "void ChildProcessSecurityPolicy::GrantReadRawCookies(int renderer_id) {\n  AutoLock lock(lock_);\n  SecurityStateMap::iterator state = security_state_.find(renderer_id);\n  if (state == security_state_.end())\n    return;\n  state->second->GrantReadRawCookies();\n}", "target": 0}
{"code": "static inline bool sched_clock_stable(void)\n{\n\treturn true;\n}", "target": 0}
{"code": "static bool read_header_from_file(zckCtx *zck) {\n    if(zck->lead_size == 0 || zck->header_length == 0) {\n        set_error(zck, \"Lead and header sizes are both 0.  Have you run zck_read_lead() yet?\");\n        return false;\n    }\n    zck->header = zrealloc(zck->header, zck->lead_size + zck->header_length);\n    if (!zck->header) {\n        zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n        return false;\n    }\n    zck->lead_string = zck->header;\n    char *header = zck->header + zck->lead_size;\n    size_t loaded = 0;\n    if(zck->header_length < zck->header_size - zck->lead_size) {\n        set_fatal_error(zck, \"Header size is too small for actual data\");\n        return false;\n    }\n    if(zck->lead_size < zck->header_size)\n        loaded = zck->header_size - zck->lead_size;\n    zck_log(ZCK_LOG_DEBUG, \"Reading the rest of the header: %llu bytes\",\n            (long long unsigned) zck->header_length);\n    if(loaded < zck->header_length) {\n        if(read_data(zck, header + loaded, zck->header_length - loaded) < zck->header_length - loaded) {\n            set_fatal_error(zck, \"Unable to read %llu bytes from the file\", zck->header_length - loaded);\n            return false;\n        }\n        zck->header_size = zck->lead_size + zck->header_length;\n    }\n    if(!hash_init(zck, &(zck->check_full_hash), &(zck->hash_type)))\n        return false;\n    if(!hash_update(zck, &(zck->check_full_hash), \"\\0ZCK1\", 5))\n        return false;\n    if(!hash_update(zck, &(zck->check_full_hash), zck->header+5,\n                    zck->hdr_digest_loc-5))\n        return false;\n    if(!hash_update(zck, &(zck->check_full_hash), header, zck->header_length))\n        return false;\n    int ret = validate_header(zck);\n    if(ret < 1) {\n        if(ret == -1)\n            set_fatal_error(zck, \"Header checksum failed verification\");\n        return false;\n    }\n    return true;\n}", "target": 1}
{"code": "static void cfg_resp_handler(int err, const struct http_msg *msg,\n\t\t\t     struct mbuf *mb, struct json_object *jobj,\n\t\t\t     void *arg)\n{\n\tchar *json_str = NULL;\n\tstruct zapi_ice_server *servers;\n\tsize_t nservers = 0;\n\tsize_t i;\n\tre_printf(\"config ready! err=%d\\n\");\n\tif (err == ECONNABORTED)\n\t\tgoto out;\n\tif (!err && jobj) {\n\t\terr = jzon_encode(&json_str, jobj);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\tre_printf(\"CONFIG: %s\\n\", json_str);\n\tconfig_update(g_config, err, json_str, str_len(json_str));\n\tmem_deref(json_str);\n\tservers = config_get_iceservers(g_config, &nservers);\n\tre_printf(\"Probing: %d servers\\n\", nservers);\n\tfor (i = 0; i < nservers; ++i) {\n\t\tstruct zapi_ice_server *turn = &servers[i];\n\t\tstruct stun_uri uri;\n\t\terr = stun_uri_decode(&uri, turn->url);\n\t\tif (err)\n\t\t\terr = turn_dns_lookup(turn, &uri);\n\t\telse {\n\t\t\tstart_netprobe(&uri.addr, uri.proto, uri.secure,\n\t\t\t\t       turn->username, turn->credential);\n\t\t}\n\t}\n out:\n\tif (err)\n\t\terror(\"config request failed: %m\\n\", err);\n}", "target": 0}
{"code": "NAN_METHOD(TxnWrap::putString) {\n    if (!info[2]->IsString())\n        return Nan::ThrowError(\"Value must be a string.\");\n    return putCommon(info, [](Nan::NAN_METHOD_ARGS_TYPE info, MDB_val &data) -> void {\n        CustomExternalStringResource::writeTo(Local<String>::Cast(info[2]), &data);\n    }, [](MDB_val &data) -> void {\n        delete[] (uint16_t*)data.mv_data;\n    });\n}", "target": 0}
{"code": "bool recovery_cipher_abort(void)\n{\n    recovery_started = false;\n    if (awaiting_character) {\n        awaiting_character = false;\n        return true;\n    }\n    return false;\n}", "target": 0}
{"code": "PJ_DEF(pj_status_t) pjmedia_rtp_decode_rtp2(\n\t\t\t\t\t    pjmedia_rtp_session *ses,\n\t\t\t\t\t    const void *pkt, int pkt_len,\n\t\t\t\t\t    const pjmedia_rtp_hdr **hdr,\n\t\t\t\t\t    pjmedia_rtp_dec_hdr *dec_hdr,\n\t\t\t\t\t    const void **payload,\n\t\t\t\t\t    unsigned *payloadlen)\n{\n    int offset;\n    PJ_UNUSED_ARG(ses);\n    *hdr = (pjmedia_rtp_hdr*)pkt;\n    if ((*hdr)->v != RTP_VERSION) {\n\treturn PJMEDIA_RTP_EINVER;\n    }\n    offset = sizeof(pjmedia_rtp_hdr) + ((*hdr)->cc * sizeof(pj_uint32_t));\n    if ((*hdr)->x) {\n        if (offset + sizeof (pjmedia_rtp_ext_hdr) > (unsigned)pkt_len)\n            return PJMEDIA_RTP_EINLEN;\n        dec_hdr->ext_hdr = (pjmedia_rtp_ext_hdr*)(((pj_uint8_t*)pkt) + offset);\n        dec_hdr->ext = (pj_uint32_t*)(dec_hdr->ext_hdr + 1);\n        dec_hdr->ext_len = pj_ntohs((dec_hdr->ext_hdr)->length);\n        offset += ((dec_hdr->ext_len + 1) * sizeof(pj_uint32_t));\n    } else {\n\tdec_hdr->ext_hdr = NULL;\n\tdec_hdr->ext = NULL;\n\tdec_hdr->ext_len = 0;\n    }\n    if (offset > pkt_len)\n\treturn PJMEDIA_RTP_EINLEN;\n    *payload = ((pj_uint8_t*)pkt) + offset;\n    *payloadlen = pkt_len - offset;\n    if ((*hdr)->p && *payloadlen > 0) {\n\tpj_uint8_t pad_len;\n\tpad_len = ((pj_uint8_t*)(*payload))[*payloadlen - 1];\n\tif (pad_len <= *payloadlen)\n\t    *payloadlen -= pad_len;\n    }\n    return PJ_SUCCESS;\n}", "target": 1}
{"code": "snmp_engine_get_next(snmp_header_t *header, snmp_varbind_t *varbinds, uint32_t varbinds_length)\n{\n  snmp_mib_resource_t *resource;\n  uint32_t i;\n  for(i = 0; i < varbinds_length; i++) {\n    resource = snmp_mib_find_next(varbinds[i].oid);\n    if(!resource) {\n      switch(header->version) {\n      case SNMP_VERSION_1:\n        header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n        header->error_index_max_repetitions.error_index = i + 1;\n        break;\n      case SNMP_VERSION_2C:\n        (&varbinds[i])->value_type = SNMP_DATA_TYPE_END_OF_MIB_VIEW;\n        break;\n      default:\n        header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n        header->error_index_max_repetitions.error_index = 0;\n      }\n    } else {\n      resource->handler(&varbinds[i], resource->oid);\n    }\n  }\n  return 0;\n}", "target": 1}
{"code": "LIBOPENMPT_MODPLUG_API unsigned int ModPlug_SampleName(ModPlugFile* file, unsigned int qual, char* buff)\n{\n\tconst char* str;\n\tunsigned int retval;\n\tsize_t tmpretval;\n\tif(!file) return 0;\n\tstr = openmpt_module_get_sample_name(file->mod,qual-1);\n\tif(!str){\n\t\tif(buff){\n\t\t\t*buff = '\\0';\n\t\t}\n\t\treturn 0;\n\t}\n\ttmpretval = strlen(str);\n\tif(tmpretval>=INT_MAX){\n\t\ttmpretval = INT_MAX-1;\n\t}\n\tretval = (int)tmpretval;\n\tif(buff){\n\t\tmemcpy(buff,str,retval+1);\n\t\tbuff[retval] = '\\0';\n\t}\n\topenmpt_free_string(str);\n\treturn retval;\n}", "target": 1}
{"code": "int nbd_client(int fd)\n{\n    return -ENOTSUP;\n}", "target": 0}
{"code": "static struct ast_sip_endpoint *transport_identify(pjsip_rx_data *rdata)\n{\n\tchar buffer[PJ_INET6_ADDRSTRLEN];\n\tpj_status_t status;\n\tstruct ast_sockaddr_with_tp addr_with_tp = { { { 0, } }, };\n\tunion pj_sockaddr sock = rdata->tp_info.transport->local_addr;\n\tpj_ansi_strxcpy(addr_with_tp.tp, rdata->tp_info.transport->type_name, sizeof(addr_with_tp.tp));\n\tif (sock.addr.sa_family == PJ_AF_INET6) {\n\t\tstatus = pj_inet_ntop(PJ_AF_INET6, &(sock.ipv6.sin6_addr), buffer, PJ_INET6_ADDRSTRLEN);\n\t\tif (status == PJ_SUCCESS && !strcmp(buffer, \"::\")) {\n\t\t\tast_log(LOG_WARNING, \"Matching against '::' may be unpredictable.\\n\");\n\t\t}\n\t} else {\n\t\tstatus = pj_inet_ntop(PJ_AF_INET, &(sock.ipv4.sin_addr), buffer, PJ_INET_ADDRSTRLEN);\n\t\tif (status == PJ_SUCCESS && !strcmp(buffer, \"0.0.0.0\")) {\n\t\t\tast_log(LOG_WARNING, \"Matching against '0.0.0.0' may be unpredictable.\\n\");\n\t\t}\n\t}\n\tif (status == PJ_SUCCESS) {\n\t\tast_sockaddr_parse(&addr_with_tp.addr, buffer, PARSE_PORT_FORBID);\n\t\tast_sockaddr_set_port(&addr_with_tp.addr, rdata->tp_info.transport->local_name.port);\n\t\treturn common_identify(ip_identify_match_check, &addr_with_tp);\n\t} else {\n\t\treturn NULL;\n\t}\n}", "target": 1}
{"code": "std::set<std::string> getMounts(Computer * computer, const std::string& comp_path) {\n    std::vector<std::string> elems = split(comp_path, \"/\\\\\");\n    std::list<std::string> pathc;\n    std::set<std::string> retval;\n    for (std::string s : elems) {\n        if (s == \"..\") { if (pathc.empty()) return retval; else pathc.pop_back(); }\n        else if (!s.empty() && !std::all_of(s.begin(), s.end(), [](const char c)->bool{return c == '.';})) {\n            s.erase(std::remove_if(s.begin(), s.end(), [](char c)->bool{return c=='\"'||c==':'||c=='<'||c=='>'||c=='?'||c=='|';}), s.end());\n            pathc.push_back(s);\n        }\n    }\n    for (const auto& m : computer->mounts)\n        if (pathc.size() + 1 == std::get<0>(m).size() && std::equal(pathc.begin(), pathc.end(), std::get<0>(m).begin()))\n            retval.insert(std::get<0>(m).back());\n    return retval;\n}", "target": 1}
{"code": "static int isansicode(int x)\n{\n    return x == 0x1B || x == 0x0A || x == 0x0D || (x >= 0x20 && x < 0x7f);\n}", "target": 0}
{"code": "MONGO_EXPORT bson_bool_t mongo_cmd_authenticate( mongo *conn, const char *db, const char *user, const char *pass ) {\n    bson from_db;\n    bson cmd;\n    const char *nonce;\n    int result;\n    mongo_md5_state_t st;\n    mongo_md5_byte_t digest[16];\n    char hex_digest[33];\n    if( mongo_simple_int_command( conn, db, \"getnonce\", 1, &from_db ) == MONGO_OK ) {\n        bson_iterator it;\n        bson_find( &it, &from_db, \"nonce\" );\n        nonce = bson_iterator_string( &it );\n    }\n    else {\n        return MONGO_ERROR;\n    }\n    mongo_pass_digest( user, pass, hex_digest );\n    mongo_md5_init( &st );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )nonce, strlen( nonce ) );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )user, strlen( user ) );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )hex_digest, 32 );\n    mongo_md5_finish( &st, digest );\n    digest2hex( digest, hex_digest );\n    bson_init( &cmd );\n    bson_append_int( &cmd, \"authenticate\", 1 );\n    bson_append_string( &cmd, \"user\", user );\n    bson_append_string( &cmd, \"nonce\", nonce );\n    bson_append_string( &cmd, \"key\", hex_digest );\n    bson_finish( &cmd );\n    bson_destroy( &from_db );\n    result = mongo_run_command( conn, db, &cmd, NULL );\n    bson_destroy( &cmd );\n    return result;\n}", "target": 1}
{"code": "static bool new_idmap_permitted(struct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *new_map)\n{\n\tif ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1)) {\n\t\tu32 id = new_map->extent[0].lower_first;\n\t\tif (cap_setid == CAP_SETUID) {\n\t\t\tkuid_t uid = make_kuid(ns->parent, id);\n\t\t\tif (uid_eq(uid, current_fsuid()))\n\t\t\t\treturn true;\n\t\t}\n\t\telse if (cap_setid == CAP_SETGID) {\n\t\t\tkgid_t gid = make_kgid(ns->parent, id);\n\t\t\tif (gid_eq(gid, current_fsgid()))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\tif (!cap_valid(cap_setid))\n\t\treturn true;\n\tif (ns_capable(ns->parent, cap_setid))\n\t\treturn true;\n\treturn false;\n}", "target": 1}
{"code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  TfLiteType output_type = GetOutput(context, node, kOutputTensor)->type;\n  switch (output_type) {  \n    case kTfLiteFloat32:\n      EvalUnquantized<float>(context, node);\n      break;\n    case kTfLiteInt32:\n      EvalUnquantized<int32_t>(context, node);\n      break;\n    case kTfLiteUInt8:\n      EvalQuantizedUInt8(context, node);\n      break;\n    case kTfLiteInt8:\n      EvalUnquantized<int8_t>(context, node);\n      break;\n    case kTfLiteInt64:\n      EvalUnquantized<int64_t>(context, node);\n      break;\n    default:\n      TF_LITE_KERNEL_LOG(\n          context, \"Op Concatenation does not currently support Type '%s'.\",\n          TfLiteTypeGetName(output_type));\n      return kTfLiteError;\n  }\n  return kTfLiteOk;\n}", "target": 1}
{"code": "void RenderWidgetHostViewAura::SoftwareFrameWasFreed(\n    uint32 output_surface_id, unsigned frame_id) {\n  ReleaseSoftwareFrame(output_surface_id, frame_id);\n}", "target": 0}
{"code": "static int xfrm_dump_policy(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];\n\tstruct xfrm_dump_info info;\n\tBUILD_BUG_ON(sizeof(struct xfrm_policy_walk) >\n\t\t     sizeof(cb->args) - sizeof(cb->args[0]));\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\tif (!cb->args[0]) {\n\t\tcb->args[0] = 1;\n\t\txfrm_policy_walk_init(walk, XFRM_POLICY_TYPE_ANY);\n\t}\n\t(void) xfrm_policy_walk(net, walk, dump_one_policy, &info);\n\treturn skb->len;\n}", "target": 1}
{"code": "static inline void native_tss_invalidate_io_bitmap(void)\n{\n\tthis_cpu_write(cpu_tss_rw.x86_tss.io_bitmap_base,\n\t\t       IO_BITMAP_OFFSET_INVALID);\n}", "target": 0}
{"code": "double AccessibilityUIElement::maxValue()\n{\n    if (!m_element || !ATK_IS_OBJECT(m_element))\n        return 0.0f;\n    GValue value = G_VALUE_INIT;\n    atk_value_get_maximum_value(ATK_VALUE(m_element), &value);\n    if (!G_VALUE_HOLDS_FLOAT(&value))\n        return 0.0f;\n    return g_value_get_float(&value);\n}", "target": 0}
{"code": "void usb_sg_cancel(struct usb_sg_request *io)\n{\n\tunsigned long flags;\n\tint i, retval;\n\tspin_lock_irqsave(&io->lock, flags);\n\tif (io->status) {\n\t\tspin_unlock_irqrestore(&io->lock, flags);\n\t\treturn;\n\t}\n\tio->status = -ECONNRESET;\n\tspin_unlock_irqrestore(&io->lock, flags);\n\tfor (i = io->entries - 1; i >= 0; --i) {\n\t\tusb_block_urb(io->urbs[i]);\n\t\tretval = usb_unlink_urb(io->urbs[i]);\n\t\tif (retval != -EINPROGRESS\n\t\t    && retval != -ENODEV\n\t\t    && retval != -EBUSY\n\t\t    && retval != -EIDRM)\n\t\t\tdev_warn(&io->dev->dev, \"%s, unlink --> %d\\n\",\n\t\t\t\t __func__, retval);\n\t}\n}", "target": 1}
{"code": "__u32 secure_tcpv6_sequence_number(__be32 *saddr, __be32 *daddr,\n\t\t\t\t   __be16 sport, __be16 dport)\n{\n\tu32 secret[MD5_MESSAGE_BYTES / 4];\n\tu32 hash[MD5_DIGEST_WORDS];\n\tu32 i;\n\tmemcpy(hash, saddr, 16);\n\tfor (i = 0; i < 4; i++)\n\t\tsecret[i] = net_secret[i] + daddr[i];\n\tsecret[4] = net_secret[4] +\n\t\t(((__force u16)sport << 16) + (__force u16)dport);\n\tfor (i = 5; i < MD5_MESSAGE_BYTES / 4; i++)\n\t\tsecret[i] = net_secret[i];\n\tmd5_transform(hash, secret);\n\treturn seq_scale(hash[0]);\n}", "target": 0}
{"code": "compat_mptfwxfer_ioctl(struct file *filp, unsigned int cmd,\n\t\t\tunsigned long arg)\n{\n\tstruct mpt_fw_xfer32 kfw32;\n\tstruct mpt_fw_xfer kfw;\n\tMPT_ADAPTER *iocp = NULL;\n\tint iocnum, iocnumX;\n\tint nonblock = (filp->f_flags & O_NONBLOCK);\n\tint ret;\n\tif (copy_from_user(&kfw32, (char __user *)arg, sizeof(kfw32)))\n\t\treturn -EFAULT;\n\tiocnumX = kfw32.iocnum & 0xFF;\n\tif (((iocnum = mpt_verify_adapter(iocnumX, &iocp)) < 0) ||\n\t    (iocp == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"::compat_mptfwxfer_ioctl @%d - ioc%d not found!\\n\",\n\t\t\t__LINE__, iocnumX);\n\t\treturn -ENODEV;\n\t}\n\tif ((ret = mptctl_syscall_down(iocp, nonblock)) != 0)\n\t\treturn ret;\n\tdctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT \"compat_mptfwxfer_ioctl() called\\n\",\n\t    iocp->name));\n\tkfw.iocnum = iocnum;\n\tkfw.fwlen = kfw32.fwlen;\n\tkfw.bufp = compat_ptr(kfw32.bufp);\n\tret = mptctl_do_fw_download(kfw.iocnum, kfw.bufp, kfw.fwlen);\n\tmutex_unlock(&iocp->ioctl_cmds.mutex);\n\treturn ret;\n}", "target": 1}
{"code": "heap_available()\n{\n    long avail = 0;\n    void *probes[max_malloc_probes];\n    uint n;\n    for (n = 0; n < max_malloc_probes; n++) {\n        if ((probes[n] = malloc(malloc_probe_size)) == 0)\n            break;\n        if_debug2('a', \"[a]heap_available probe[%d]=0x%lx\\n\",\n                  n, (ulong) probes[n]);\n        avail += malloc_probe_size;\n    }\n    while (n)\n        free(probes[--n]);\n    return avail;\n}", "target": 0}
{"code": "generatePreview (const char inFileName[],\n\t\t float exposure,\n\t\t int previewWidth,\n\t\t int &previewHeight,\n\t\t Array2D <PreviewRgba> &previewPixels)\n{\n    RgbaInputFile in (inFileName);\n    Box2i dw = in.dataWindow();\n    float a = in.pixelAspectRatio();\n    int w = dw.max.x - dw.min.x + 1;\n    int h = dw.max.y - dw.min.y + 1;\n    Array2D <Rgba> pixels (h, w);\n    in.setFrameBuffer (ComputeBasePointer (&pixels[0][0], dw), 1, w);\n    in.readPixels (dw.min.y, dw.max.y);\n    previewHeight = max (int (h / (w * a) * previewWidth + .5f), 1);\n    previewPixels.resizeErase (previewHeight, previewWidth);\n    float fx = (previewWidth  > 0)? (float (w - 1) / (previewWidth  - 1)): 1;\n    float fy = (previewHeight > 0)? (float (h - 1) / (previewHeight - 1)): 1;\n    float m  = Math<float>::pow (2.f, IMATH_NAMESPACE::clamp (exposure + 2.47393f, -20.f, 20.f));\n    for (int y = 0; y < previewHeight; ++y)\n    {\n\tfor (int x = 0; x < previewWidth; ++x)\n\t{\n\t    PreviewRgba &preview = previewPixels[y][x];\n\t    const Rgba &pixel = pixels[int (y * fy + .5f)][int (x * fx + .5f)];\n\t    preview.r = gamma (pixel.r, m);\n\t    preview.g = gamma (pixel.g, m);\n\t    preview.b = gamma (pixel.b, m);\n\t    preview.a = int (IMATH_NAMESPACE::clamp (pixel.a * 255.f, 0.f, 255.f) + .5f);\n\t}\n    }\n}", "target": 1}
{"code": "void PrintWebViewHelper::DidFinishPrinting(PrintingResult result) {\n  switch (result) {\n    case OK:\n      break;\n    case FAIL_PRINT_INIT:\n      DCHECK(!notify_browser_of_print_failure_);\n      break;\n    case FAIL_PRINT:\n      if (notify_browser_of_print_failure_ && print_pages_params_) {\n        int cookie = print_pages_params_->params.document_cookie;\n        Send(new PrintHostMsg_PrintingFailed(routing_id(), cookie));\n      }\n      break;\n    case FAIL_PREVIEW:\n      int cookie =\n          print_pages_params_ ? print_pages_params_->params.document_cookie : 0;\n      if (notify_browser_of_print_failure_) {\n        LOG(ERROR) << \"CreatePreviewDocument failed\";\n        Send(new PrintHostMsg_PrintPreviewFailed(routing_id(), cookie));\n      } else {\n        Send(new PrintHostMsg_PrintPreviewCancelled(routing_id(), cookie));\n      }\n      print_preview_context_.Failed(notify_browser_of_print_failure_);\n      break;\n  }\n  prep_frame_view_.reset();\n  print_pages_params_.reset();\n  notify_browser_of_print_failure_ = true;\n}", "target": 0}
{"code": "static int dp8393x_receive_filter(dp8393xState *s, const uint8_t * buf,\n                                  int size)\n{\n    static const uint8_t bcast[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\n    int i;\n    if ((s->regs[SONIC_RCR] & SONIC_RCR_PRO) && (buf[0] & 1) == 0) {\n        return 0;\n    }\n    if ((s->regs[SONIC_RCR] & SONIC_RCR_AMC) && (buf[0] & 1) == 1) {\n        return SONIC_RCR_MC;\n    }\n    if ((s->regs[SONIC_RCR] & SONIC_RCR_BRD) && !memcmp(buf, bcast, sizeof(bcast))) {\n        return SONIC_RCR_BC;\n    }\n    for (i = 0; i < 16; i++) {\n        if (s->regs[SONIC_CE] & (1 << i)) {\n             if (!memcmp(buf, s->cam[i], sizeof(s->cam[i]))) {\n                 return 0;\n             }\n        }\n    }\n    return -1;\n}", "target": 0}
{"code": "void Shell::DeleteInstance() {\n  delete instance_;\n  instance_ = nullptr;\n}", "target": 0}
{"code": "static ssize_t bat_socket_read(struct file *file, char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct socket_client *socket_client = file->private_data;\n\tstruct socket_packet *socket_packet;\n\tsize_t packet_len;\n\tint error;\n\tif ((file->f_flags & O_NONBLOCK) && (socket_client->queue_len == 0))\n\t\treturn -EAGAIN;\n\tif ((!buf) || (count < sizeof(struct icmp_packet)))\n\t\treturn -EINVAL;\n\tif (!access_ok(VERIFY_WRITE, buf, count))\n\t\treturn -EFAULT;\n\terror = wait_event_interruptible(socket_client->queue_wait,\n\t\t\t\t\t socket_client->queue_len);\n\tif (error)\n\t\treturn error;\n\tspin_lock_bh(&socket_client->lock);\n\tsocket_packet = list_first_entry(&socket_client->queue_list,\n\t\t\t\t\t struct socket_packet, list);\n\tlist_del(&socket_packet->list);\n\tsocket_client->queue_len--;\n\tspin_unlock_bh(&socket_client->lock);\n\terror = copy_to_user(buf, &socket_packet->icmp_packet,\n\t\t\t     socket_packet->icmp_len);\n\tpacket_len = socket_packet->icmp_len;\n\tkfree(socket_packet);\n\tif (error)\n\t\treturn -EFAULT;\n\treturn packet_len;\n}", "target": 1}
{"code": "void warn_on_nonidempotent_op(struct nfsd4_op *op)\n{\n\tif (OPDESC(op)->op_flags & OP_MODIFIES_SOMETHING) {\n\t\tpr_err(\"unable to encode reply to nonidempotent op %d (%s)\\n\",\n\t\t\top->opnum, nfsd4_op_name(op->opnum));\n\t\tWARN_ON_ONCE(1);\n\t}\n}", "target": 0}
{"code": "flatpak_run_get_cups_server_name (void)\n{\n  g_autofree char * cups_server = NULL;\n  g_autofree char * cups_config_path = NULL;\n  cups_server = g_strdup (g_getenv (\"CUPS_SERVER\"));\n  if (cups_server && flatpak_run_cups_check_server_is_socket (cups_server))\n    return g_steal_pointer (&cups_server);\n  g_clear_pointer (&cups_server, g_free);\n  cups_config_path = g_build_filename (g_get_home_dir (), \".cups/client.conf\", NULL);\n  cups_server = flatpak_run_get_cups_server_name_config (cups_config_path);\n  if (cups_server && flatpak_run_cups_check_server_is_socket (cups_server))\n    return g_steal_pointer (&cups_server);\n  g_clear_pointer (&cups_server, g_free);\n  cups_server = flatpak_run_get_cups_server_name_config (\"/etc/cups/client.conf\");\n  if (cups_server && flatpak_run_cups_check_server_is_socket (cups_server))\n    return g_steal_pointer (&cups_server);\n  return g_strdup (\"/var/run/cups/cups.sock\");\n}", "target": 0}
{"code": "str_lower_case_match(OnigEncoding enc, int case_fold_flag,\n                     const UChar* t, const UChar* tend,\n                     const UChar* p, const UChar* end)\n{\n  int lowlen;\n  UChar *q, lowbuf[ONIGENC_MBC_CASE_FOLD_MAXLEN];\n  while (t < tend) {\n    lowlen = ONIGENC_MBC_CASE_FOLD(enc, case_fold_flag, &p, end, lowbuf);\n    q = lowbuf;\n    while (lowlen > 0) {\n      if (t >= tend)    return 0;\n      if (*t++ != *q++) return 0;\n      lowlen--;\n    }\n  }\n  return 1;\n}", "target": 0}
{"code": "noko_init_xml_sax_parser_context()\n{\n  cNokogiriXmlSaxParserContext = rb_define_class_under(mNokogiriXmlSax, \"ParserContext\", rb_cObject);\n  rb_undef_alloc_func(cNokogiriXmlSaxParserContext);\n  rb_define_singleton_method(cNokogiriXmlSaxParserContext, \"io\", parse_io, 2);\n  rb_define_singleton_method(cNokogiriXmlSaxParserContext, \"memory\", parse_memory, 1);\n  rb_define_singleton_method(cNokogiriXmlSaxParserContext, \"file\", parse_file, 1);\n  rb_define_method(cNokogiriXmlSaxParserContext, \"parse_with\", parse_with, 1);\n  rb_define_method(cNokogiriXmlSaxParserContext, \"replace_entities=\", set_replace_entities, 1);\n  rb_define_method(cNokogiriXmlSaxParserContext, \"replace_entities\", get_replace_entities, 0);\n  rb_define_method(cNokogiriXmlSaxParserContext, \"recovery=\", set_recovery, 1);\n  rb_define_method(cNokogiriXmlSaxParserContext, \"recovery\", get_recovery, 0);\n  rb_define_method(cNokogiriXmlSaxParserContext, \"line\", line, 0);\n  rb_define_method(cNokogiriXmlSaxParserContext, \"column\", column, 0);\n  id_read = rb_intern(\"read\");\n}", "target": 0}
{"code": "static Status ValidateFunctionNotRecursive(const FunctionDef& function) {\n  const auto& function_name = function.signature().name();\n  for (const auto& node : function.node_def()) {\n    if (node.op() == function_name) {\n      return errors::FailedPrecondition(\n          \"Function \", function_name,\n          \" is self recursive and TensorFlow does not support this scenario.\");\n    }\n  }\n  return Status::OK();\n}", "target": 0}
{"code": "pci_populate_msicap(struct msicap *msicap, int msgnum, int nextptr)\n{\n\tint mmc;\n\tassert((msgnum & (msgnum - 1)) == 0 && msgnum >= 1 && msgnum <= 32);\n\tmmc = ffs(msgnum) - 1;\n\tbzero(msicap, sizeof(struct msicap));\n\tmsicap->capid = PCIY_MSI;\n\tmsicap->nextptr = nextptr;\n\tmsicap->msgctrl = PCIM_MSICTRL_64BIT | (mmc << 1);\n}", "target": 1}
{"code": "bool CoinSpend::HasValidSerial() const\n{\n\treturn coinSerialNumber > 0 && coinSerialNumber < params->coinCommitmentGroup.groupOrder;\n}", "target": 0}
{"code": "static int ghash_final(struct shash_desc *desc, u8 *dst)\n{\n\tstruct ghash_desc_ctx *dctx = shash_desc_ctx(desc);\n\tstruct ghash_ctx *ctx = crypto_shash_ctx(desc->tfm);\n\tu8 *buf = dctx->buffer;\n\tif (!ctx->gf128)\n\t\treturn -ENOKEY;\n\tghash_flush(ctx, dctx);\n\tmemcpy(dst, buf, GHASH_BLOCK_SIZE);\n\treturn 0;\n}", "target": 0}
{"code": "int main()\n{\n    check_file(\"tiff_invalid_read_1.tiff\");\n    check_file(\"tiff_invalid_read_2.tiff\");\n    check_file(\"tiff_invalid_read_3.tiff\");\n    return gdNumFailures();\n}", "target": 0}
{"code": "njs_json_parse_iterator(njs_vm_t *vm, njs_json_parse_t *parse,\n    njs_value_t *object)\n{\n    njs_int_t             ret;\n    njs_value_t           *key, wrapper;\n    njs_object_t          *obj;\n    njs_json_state_t      *state;\n    njs_object_prop_t     *prop;\n    njs_property_query_t  pq;\n    obj = njs_json_wrap_value(vm, &wrapper, object);\n    if (njs_slow_path(obj == NULL)) {\n        return NJS_ERROR;\n    }\n    state = njs_json_push_parse_state(vm, parse, &wrapper);\n    if (njs_slow_path(state == NULL)) {\n        return NJS_ERROR;\n    }\n    for ( ;; ) {\n        if (state->index < state->keys->length) {\n            njs_property_query_init(&pq, NJS_PROPERTY_QUERY_SET, 0);\n            key = &state->keys->start[state->index];\n            ret = njs_property_query(vm, &pq, &state->value, key);\n            if (njs_slow_path(ret != NJS_OK)) {\n                if (ret == NJS_DECLINED) {\n                    state->index++;\n                    continue;\n                }\n                return NJS_ERROR;\n            }\n            prop = pq.lhq.value;\n            if (prop->type == NJS_WHITEOUT) {\n                state->index++;\n                continue;\n            }\n            state->prop = prop;\n            if (prop->type == NJS_PROPERTY && njs_is_object(&prop->value)) {\n                state = njs_json_push_parse_state(vm, parse, &prop->value);\n                if (state == NULL) {\n                    return NJS_ERROR;\n                }\n                continue;\n            }\n            if (prop->type == NJS_PROPERTY_REF\n                && njs_is_object(prop->value.data.u.value))\n            {\n                state = njs_json_push_parse_state(vm, parse,\n                                                  prop->value.data.u.value);\n                if (state == NULL) {\n                    return NJS_ERROR;\n                }\n                continue;\n            }\n        } else {\n            state = njs_json_pop_parse_state(vm, parse);\n            if (state == NULL) {\n                vm->retval = parse->retval;\n                return NJS_OK;\n            }\n        }\n        ret = njs_json_parse_iterator_call(vm, parse, state);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n    }\n}", "target": 1}
{"code": "static inline int GetFirstGlobbingEntry(const std::vector<std::string>& dirs) {\n  int i = 0;\n  for (const auto& d : dirs) {\n    if (IsGlobbingPattern(d)) {\n      break;\n    }\n    i++;\n  }\n  return i;\n}", "target": 0}
{"code": "    template<typename t>\n    CImg<T>& convolve(const CImg<t>& kernel, const bool boundary_conditions=true, const bool is_normalized=false) {\n      if (is_empty() || !kernel) return *this;\n      return get_convolve(kernel,boundary_conditions,is_normalized).move_to(*this);", "target": 0}
{"code": "test_validate_path_meta (void)\n{\n  gsize idx;\n  for (idx = 0; idx < G_N_ELEMENTS (invalid_path_meta); idx++)\n    {\n      g_autoptr(FlatpakContext) context = flatpak_context_new ();\n      g_autoptr(GKeyFile) metakey = g_key_file_new ();\n      g_autoptr(GError) local_error = NULL;\n      PathValidityData *data = &invalid_path_meta[idx];\n      gboolean ret = FALSE;\n      g_key_file_set_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                  data->key, &data->value, 1);\n      ret = flatpak_context_load_metadata (context, metakey, &local_error);\n      g_assert_false (ret);\n      g_assert_error (local_error, G_IO_ERROR, G_IO_ERROR_INVALID_DATA);\n      g_assert (strstr (local_error->message, \"Non-graphical character\"));\n    }\n}", "target": 0}
{"code": "static int xfrm_expand_policies(const struct flowi *fl, u16 family,\n\t\t\t\tstruct xfrm_policy **pols,\n\t\t\t\tint *num_pols, int *num_xfrms)\n{\n\tint i;\n\tif (*num_pols == 0 || !pols[0]) {\n\t\t*num_pols = 0;\n\t\t*num_xfrms = 0;\n\t\treturn 0;\n\t}\n\tif (IS_ERR(pols[0]))\n\t\treturn PTR_ERR(pols[0]);\n\t*num_xfrms = pols[0]->xfrm_nr;\n#ifdef CONFIG_XFRM_SUB_POLICY\n\tif (pols[0]->action == XFRM_POLICY_ALLOW &&\n\t    pols[0]->type != XFRM_POLICY_TYPE_MAIN) {\n\t\tpols[1] = xfrm_policy_lookup_bytype(xp_net(pols[0]),\n\t\t\t\t\t\t    XFRM_POLICY_TYPE_MAIN,\n\t\t\t\t\t\t    fl, family,\n\t\t\t\t\t\t    XFRM_POLICY_OUT,\n\t\t\t\t\t\t    pols[0]->if_id);\n\t\tif (pols[1]) {\n\t\t\tif (IS_ERR(pols[1])) {\n\t\t\t\txfrm_pols_put(pols, *num_pols);\n\t\t\t\treturn PTR_ERR(pols[1]);\n\t\t\t}\n\t\t\t(*num_pols)++;\n\t\t\t(*num_xfrms) += pols[1]->xfrm_nr;\n\t\t}\n\t}\n#endif\n\tfor (i = 0; i < *num_pols; i++) {\n\t\tif (pols[i]->action != XFRM_POLICY_ALLOW) {\n\t\t\t*num_xfrms = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "Status ValidateNumThreads(int32_t num_threads) {\n  if (num_threads < 0) {\n    return errors::InvalidArgument(\"`num_threads` must be >= 0\");\n  }\n  if (num_threads >= kThreadLimit) {\n    return errors::InvalidArgument(\"`num_threads` must be < \", kThreadLimit);\n  }\n  return Status::OK();\n}", "target": 0}
{"code": "TEST_F(QuotedString_ExtractFrom_Tests, UnterminatedEscapeSequence) {\n  whenInputIs(\"\\\"\\\\\\0\\\"\", 4);\n  resultMustBe(0);\n}", "target": 0}
{"code": "void Magick::Image::read(MagickCore::Image *image,\n  MagickCore::ExceptionInfo *exceptionInfo)\n{\n  if (image != (MagickCore::Image *) NULL &&\n      image->next != (MagickCore::Image *) NULL)\n    {\n      MagickCore::Image\n        *next;\n      next=image->next;\n      image->next=(MagickCore::Image *) NULL;\n      next->previous=(MagickCore::Image *) NULL;\n      DestroyImageList(next);\n    }\n  replaceImage(image);\n  if (exceptionInfo->severity == MagickCore::UndefinedException &&\n      image == (MagickCore::Image *) NULL)\n    {\n      (void) MagickCore::DestroyExceptionInfo(exceptionInfo);\n      if (!quiet())\n        throwExceptionExplicit(MagickCore::ImageWarning,\n          \"No image was loaded.\");\n      return;\n    }\n  ThrowImageException;\n}", "target": 0}
{"code": "  virtual ~EmbeddedWorkerBrowserTest() {}", "target": 0}
{"code": "struct clock_source *dcn10_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\tif (!clk_src)\n\t\treturn NULL;\n\tif (dce112_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\tkfree(clk_src);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 0}
{"code": "public char * shell_quoten(constant char *s, size_t slen)\n{\n\tconstant char *p;\n\tchar *np;\n\tchar *newstr;\n\tsize_t len;\n\tconstant char *esc = get_meta_escape();\n\tsize_t esclen = strlen(esc);\n\tlbool use_quotes = FALSE;\n\tlbool have_quotes = FALSE;\n\tlen = 1; \n\tfor (p = s;  p < s + slen;  p++)\n\t{\n\t\tlen++;\n\t\tif (*p == openquote || *p == closequote)\n\t\t\thave_quotes = TRUE;\n\t\tif (metachar(*p))\n\t\t{\n\t\t\tif (esclen == 0)\n\t\t\t{\n\t\t\t\tuse_quotes = TRUE;\n\t\t\t} else\n\t\t\t{\n\t\t\t\tlen += esclen;\n\t\t\t}\n\t\t}\n\t}\n\tif (use_quotes)\n\t{\n\t\tif (have_quotes)\n\t\t\treturn (NULL);\n\t\tlen = slen + 3;\n\t}\n\tnewstr = np = (char *) ecalloc(len, sizeof(char));\n\tif (use_quotes)\n\t{\n\t\tSNPRINTF4(newstr, len, \"%c%.*s%c\", openquote, (int) slen, s, closequote);\n\t} else\n\t{\n\t\tconstant char *es = s + slen;\n\t\twhile (s < es)\n\t\t{\n\t\t\tif (metachar(*s))\n\t\t\t{\n\t\t\t\tstrcpy(np, esc);\n\t\t\t\tnp += esclen;\n\t\t\t}\n\t\t\t*np++ = *s++;\n\t\t}\n\t\t*np = '\\0';\n\t}\n\treturn (newstr);\n}", "target": 1}
{"code": "static void do_sched_cfs_slack_timer(struct cfs_bandwidth *cfs_b)\n{\n\tu64 runtime = 0, slice = sched_cfs_bandwidth_slice();\n\tunsigned long flags;\n\tu64 expires;\n\traw_spin_lock_irqsave(&cfs_b->lock, flags);\n\tcfs_b->slack_started = false;\n\tif (cfs_b->distribute_running) {\n\t\traw_spin_unlock_irqrestore(&cfs_b->lock, flags);\n\t\treturn;\n\t}\n\tif (runtime_refresh_within(cfs_b, min_bandwidth_expiration)) {\n\t\traw_spin_unlock_irqrestore(&cfs_b->lock, flags);\n\t\treturn;\n\t}\n\tif (cfs_b->quota != RUNTIME_INF && cfs_b->runtime > slice)\n\t\truntime = cfs_b->runtime;\n\texpires = cfs_b->runtime_expires;\n\tif (runtime)\n\t\tcfs_b->distribute_running = 1;\n\traw_spin_unlock_irqrestore(&cfs_b->lock, flags);\n\tif (!runtime)\n\t\treturn;\n\truntime = distribute_cfs_runtime(cfs_b, runtime, expires);\n\traw_spin_lock_irqsave(&cfs_b->lock, flags);\n\tif (expires == cfs_b->runtime_expires)\n\t\tlsub_positive(&cfs_b->runtime, runtime);\n\tcfs_b->distribute_running = 0;\n\traw_spin_unlock_irqrestore(&cfs_b->lock, flags);\n}", "target": 1}
{"code": "init_util(void)\n{\n\tfilegen_register(statsdir, \"peerstats\",\t  &peerstats);\n\tfilegen_register(statsdir, \"loopstats\",\t  &loopstats);\n\tfilegen_register(statsdir, \"clockstats\",  &clockstats);\n\tfilegen_register(statsdir, \"rawstats\",\t  &rawstats);\n\tfilegen_register(statsdir, \"sysstats\",\t  &sysstats);\n\tfilegen_register(statsdir, \"protostats\",  &protostats);\n#ifdef AUTOKEY\n\tfilegen_register(statsdir, \"cryptostats\", &cryptostats);\n#endif\t\n#ifdef DEBUG_TIMING\n\tfilegen_register(statsdir, \"timingstats\", &timingstats);\n#endif\t\n\tstep_callback = &ntpd_time_stepped;\n#ifdef DEBUG\n\tatexit(&uninit_util);\n#endif \n}", "target": 1}
{"code": "match_expr(struct search_node_list *head, struct eventlog *evlog, bool last_match)\n{\n    struct search_node *sn;\n    bool res = false, matched = last_match;\n    int rc;\n    debug_decl(match_expr, SUDO_DEBUG_UTIL);\n    STAILQ_FOREACH(sn, head, entries) {\n\tswitch (sn->type) {\n\tcase ST_EXPR:\n\t    res = match_expr(&sn->u.expr, evlog, matched);\n\t    break;\n\tcase ST_CWD:\n\t    if (evlog->cwd != NULL)\n\t\tres = strcmp(sn->u.cwd, evlog->cwd) == 0;\n\t    break;\n\tcase ST_HOST:\n\t    if (evlog->submithost != NULL)\n\t\tres = strcmp(sn->u.host, evlog->submithost) == 0;\n\t    break;\n\tcase ST_TTY:\n\t    if (evlog->ttyname != NULL)\n\t\tres = strcmp(sn->u.tty, evlog->ttyname) == 0;\n\t    break;\n\tcase ST_RUNASGROUP:\n\t    if (evlog->rungroup != NULL)\n\t\tres = strcmp(sn->u.runas_group, evlog->rungroup) == 0;\n\t    break;\n\tcase ST_RUNASUSER:\n\t    if (evlog->runuser != NULL)\n\t\tres = strcmp(sn->u.runas_user, evlog->runuser) == 0;\n\t    break;\n\tcase ST_USER:\n\t    if (evlog->submituser != NULL)\n\t\tres = strcmp(sn->u.user, evlog->submituser) == 0;\n\t    break;\n\tcase ST_PATTERN:\n\t    rc = regexec(&sn->u.cmdre, evlog->command, 0, NULL, 0);\n\t    if (rc && rc != REG_NOMATCH) {\n\t\tchar buf[BUFSIZ];\n\t\tregerror(rc, &sn->u.cmdre, buf, sizeof(buf));\n\t\tsudo_fatalx(\"%s\", buf);\n\t    }\n\t    res = rc == REG_NOMATCH ? 0 : 1;\n\t    break;\n\tcase ST_FROMDATE:\n\t    res = sudo_timespeccmp(&evlog->submit_time, &sn->u.tstamp, >=);\n\t    break;\n\tcase ST_TODATE:\n\t    res = sudo_timespeccmp(&evlog->submit_time, &sn->u.tstamp, <=);\n\t    break;\n\tdefault:\n\t    sudo_fatalx(U_(\"unknown search type %d\"), sn->type);\n\t}\n\tif (sn->negated)\n\t    res = !res;\n\tmatched = sn->or ? (res || last_match) : (res && last_match);\n\tlast_match = matched;\n    }\n    debug_return_bool(matched);\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const auto& input = context->input(0);\n    auto flat_in = input.flat<tstring>();\n    int fixed_length;\n    const auto& length_input = context->input(1);\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(length_input.shape()),\n                errors::InvalidArgument(\"k must be scalar, got shape \",\n                                        length_input.shape().DebugString()));\n    fixed_length = length_input.scalar<int32>()();\n    OP_REQUIRES(\n        context, fixed_length % sizeof(T) == 0,\n        errors::InvalidArgument(\n            \"fixed_length (\", fixed_length,\n            \") must be a multiple of the size of out_type (\", sizeof(T), \")\"));\n    OP_REQUIRES(context, fixed_length > 0,\n                errors::InvalidArgument(\"fixed_length (\", fixed_length,\n                                        \") must be greater than zero.\"));\n    int width = fixed_length / sizeof(T);\n    TensorShape out_shape = input.shape();\n    out_shape.AddDim(width);\n    Tensor* output_tensor = nullptr;\n    OP_REQUIRES_OK(\n        context, context->allocate_output(\"output\", out_shape, &output_tensor));\n    if (flat_in.size() == 0) {  \n      return;\n    }\n    auto out = output_tensor->flat_inner_dims<T>();\n    T* out_data = out.data();\n    memset(out_data, 0, fixed_length * flat_in.size());\n    if (!convert_data_endianness_ || sizeof(T) == 1) {\n      for (int64 i = 0; i < flat_in.size(); ++i) {\n        const T* in_data = reinterpret_cast<const T*>(flat_in(i).data());\n        if (flat_in(i).size() > fixed_length) {\n          memcpy(out_data, in_data, fixed_length);\n        } else {\n          memcpy(out_data, in_data, flat_in(i).size());\n        }\n        out_data += fixed_length;\n      }\n    } else {\n      for (int64 i = 0; i < flat_in.size(); ++i) {\n        const char* in_data_bytes =\n            reinterpret_cast<const char*>(flat_in(i).data());\n        char* out_data_bytes = reinterpret_cast<char*>(out_data);\n        const char* p_in = in_data_bytes;\n        char* p_out = out_data_bytes;\n        for (; p_in < in_data_bytes + fixed_length;\n             p_in += sizeof(T), p_out += sizeof(T)) {\n          std::reverse_copy(p_in, p_in + sizeof(T), p_out);\n        }\n        out_data += fixed_length;\n      }\n    }\n  }", "target": 1}
{"code": "static struct nfs4_state *nfs4_do_open(struct inode *dir, struct path *path, int flags, struct iattr *sattr, struct rpc_cred *cred)\n{\n\tstruct nfs4_exception exception = { };\n\tstruct nfs4_state *res;\n\tint status;\n\tdo {\n\t\tstatus = _nfs4_do_open(dir, path, flags, sattr, cred, &res);\n\t\tif (status == 0)\n\t\t\tbreak;\n\t\tif (status == -NFS4ERR_BAD_SEQID) {\n\t\t\tprintk(KERN_WARNING \"NFS: v4 server %s \"\n\t\t\t\t\t\" returned a bad sequence-id error!\\n\",\n\t\t\t\t\tNFS_SERVER(dir)->nfs_client->cl_hostname);\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (status == -NFS4ERR_BAD_STATEID) {\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (status == -EAGAIN) {\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tres = ERR_PTR(nfs4_handle_exception(NFS_SERVER(dir),\n\t\t\t\t\tstatus, &exception));\n\t} while (exception.retry);\n\treturn res;\n}", "target": 1}
{"code": "static int dns_resolver_match_preparse(struct key_match_data *match_data)\n{\n\tmatch_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;\n\tmatch_data->cmp = dns_resolver_cmp;\n\treturn 0;\n}", "target": 0}
{"code": "bool Item_splocal::set_value(THD *thd, sp_rcontext *ctx, Item **it)\n{\n  return ctx->set_variable(thd, get_var_idx(), it);\n}", "target": 0}
{"code": "    ExprMatchTest() : _expCtx(new ExpressionContextForTest()) {}", "target": 0}
{"code": "bool allow_svhandler_flash_sector_num(int sector) {\n  for (const FlashSector *s = flash_sector_map; s->use != FLASH_INVALID; s++) {\n    if (s->sector == sector) return allow_svhandler_flash_sector(s);\n  }\n  return false;\n}", "target": 0}
{"code": "  void SetUp() override {\n    auto *file = UTHENTICODE_TEST_ASSETS \"/A_SSLippery_Slope.exe\";\n    pe = peparse::ParsePEFromFile(file);\n    ASSERT_TRUE(pe != nullptr);\n  }", "target": 0}
{"code": "static inline void o2nm_lock_subsystem(void)\n{\n\tmutex_lock(&o2nm_cluster_group.cs_subsys.su_mutex);\n}", "target": 0}
{"code": "level_cost(unsigned int n)\n{\n    static const double log_1_1 = 0.09531017980432493;\n\treturn ceil(log(n + 0.1)/log_1_1);\n}", "target": 0}
{"code": "aiff_read_chanmap (SF_PRIVATE * psf, unsigned dword)\n{\tconst AIFF_CAF_CHANNEL_MAP * map_info ;\n\tunsigned channel_bitmap, channel_decriptions, bytesread ;\n\tint layout_tag ;\n\tbytesread = psf_binheader_readf (psf, \"444\", &layout_tag, &channel_bitmap, &channel_decriptions) ;\n\tif ((map_info = aiff_caf_of_channel_layout_tag (layout_tag)) == NULL)\n\t\treturn 0 ;\n\tpsf_log_printf (psf, \"  Tag    : %x\\n\", layout_tag) ;\n\tif (map_info)\n\t\tpsf_log_printf (psf, \"  Layout : %s\\n\", map_info->name) ;\n\tif (bytesread < dword)\n\t\tpsf_binheader_readf (psf, \"j\", dword - bytesread) ;\n\tif (map_info->channel_map != NULL)\n\t{\tsize_t chanmap_size = psf->sf.channels * sizeof (psf->channel_map [0]) ;\n\t\tfree (psf->channel_map) ;\n\t\tif ((psf->channel_map = malloc (chanmap_size)) == NULL)\n\t\t\treturn SFE_MALLOC_FAILED ;\n\t\tmemcpy (psf->channel_map, map_info->channel_map, chanmap_size) ;\n\t\t} ;\n\treturn 0 ;\n} ", "target": 1}
{"code": "asmlinkage void __sched schedule(void)\n{\n\tstruct task_struct *prev, *next;\n\tunsigned long *switch_count;\n\tstruct rq *rq;\n\tint cpu;\nneed_resched:\n\tpreempt_disable();\n\tcpu = smp_processor_id();\n\trq = cpu_rq(cpu);\n\trcu_note_context_switch(cpu);\n\tprev = rq->curr;\n\trelease_kernel_lock(prev);\nneed_resched_nonpreemptible:\n\tschedule_debug(prev);\n\tif (sched_feat(HRTICK))\n\t\thrtick_clear(rq);\n\traw_spin_lock_irq(&rq->lock);\n\tclear_tsk_need_resched(prev);\n\tswitch_count = &prev->nivcsw;\n\tif (prev->state && !(preempt_count() & PREEMPT_ACTIVE)) {\n\t\tif (unlikely(signal_pending_state(prev->state, prev))) {\n\t\t\tprev->state = TASK_RUNNING;\n\t\t} else {\n\t\t\tif (prev->flags & PF_WQ_WORKER) {\n\t\t\t\tstruct task_struct *to_wakeup;\n\t\t\t\tto_wakeup = wq_worker_sleeping(prev, cpu);\n\t\t\t\tif (to_wakeup)\n\t\t\t\t\ttry_to_wake_up_local(to_wakeup);\n\t\t\t}\n\t\t\tdeactivate_task(rq, prev, DEQUEUE_SLEEP);\n\t\t}\n\t\tswitch_count = &prev->nvcsw;\n\t}\n\tpre_schedule(rq, prev);\n\tif (unlikely(!rq->nr_running))\n\t\tidle_balance(cpu, rq);\n\tput_prev_task(rq, prev);\n\tnext = pick_next_task(rq);\n\tif (likely(prev != next)) {\n\t\tsched_info_switch(prev, next);\n\t\tperf_event_task_sched_out(prev, next);\n\t\trq->nr_switches++;\n\t\trq->curr = next;\n\t\t++*switch_count;\n\t\tcontext_switch(rq, prev, next); \n\t\tcpu = smp_processor_id();\n\t\trq = cpu_rq(cpu);\n\t} else\n\t\traw_spin_unlock_irq(&rq->lock);\n\tpost_schedule(rq);\n\tif (unlikely(reacquire_kernel_lock(prev)))\n\t\tgoto need_resched_nonpreemptible;\n\tpreempt_enable_no_resched();\n\tif (need_resched())\n\t\tgoto need_resched;\n}", "target": 1}
{"code": "GF_Err pcrb_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_PcrInfoBox *ptr = (GF_PcrInfoBox*) s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->subsegment_count);\n\tfor (i=0; i<ptr->subsegment_count; i++ ) {\n\t\tu32 data1 = (u32) (ptr->pcr_values[i] >> 10);\n\t\tu16 data2 = (u16) (ptr->pcr_values[i] << 6);\n\t\tgf_bs_write_u32(bs, data1);\n\t\tgf_bs_write_u16(bs, data2);\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "static void construct_get_dest_keyring(struct key **_dest_keyring)\n{\n\tstruct request_key_auth *rka;\n\tconst struct cred *cred = current_cred();\n\tstruct key *dest_keyring = *_dest_keyring, *authkey;\n\tkenter(\"%p\", dest_keyring);\n\tif (dest_keyring) {\n\t\tkey_get(dest_keyring);\n\t} else {\n\t\tswitch (cred->jit_keyring) {\n\t\tcase KEY_REQKEY_DEFL_DEFAULT:\n\t\tcase KEY_REQKEY_DEFL_REQUESTOR_KEYRING:\n\t\t\tif (cred->request_key_auth) {\n\t\t\t\tauthkey = cred->request_key_auth;\n\t\t\t\tdown_read(&authkey->sem);\n\t\t\t\trka = authkey->payload.data[0];\n\t\t\t\tif (!test_bit(KEY_FLAG_REVOKED,\n\t\t\t\t\t      &authkey->flags))\n\t\t\t\t\tdest_keyring =\n\t\t\t\t\t\tkey_get(rka->dest_keyring);\n\t\t\t\tup_read(&authkey->sem);\n\t\t\t\tif (dest_keyring)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\tcase KEY_REQKEY_DEFL_THREAD_KEYRING:\n\t\t\tdest_keyring = key_get(cred->thread_keyring);\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\t\tcase KEY_REQKEY_DEFL_PROCESS_KEYRING:\n\t\t\tdest_keyring = key_get(cred->process_keyring);\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\t\tcase KEY_REQKEY_DEFL_SESSION_KEYRING:\n\t\t\trcu_read_lock();\n\t\t\tdest_keyring = key_get(\n\t\t\t\trcu_dereference(cred->session_keyring));\n\t\t\trcu_read_unlock();\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\t\tcase KEY_REQKEY_DEFL_USER_SESSION_KEYRING:\n\t\t\tdest_keyring =\n\t\t\t\tkey_get(cred->user->session_keyring);\n\t\t\tbreak;\n\t\tcase KEY_REQKEY_DEFL_USER_KEYRING:\n\t\t\tdest_keyring = key_get(cred->user->uid_keyring);\n\t\t\tbreak;\n\t\tcase KEY_REQKEY_DEFL_GROUP_KEYRING:\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n\t*_dest_keyring = dest_keyring;\n\tkleave(\" [dk %d]\", key_serial(dest_keyring));\n\treturn;\n}", "target": 1}
{"code": "static long ec_device_ioctl_xcmd(struct cros_ec_dev *ec, void __user *arg)\n{\n\tlong ret;\n\tstruct cros_ec_command u_cmd;\n\tstruct cros_ec_command *s_cmd;\n\tif (copy_from_user(&u_cmd, arg, sizeof(u_cmd)))\n\t\treturn -EFAULT;\n\tif ((u_cmd.outsize > EC_MAX_MSG_BYTES) ||\n\t    (u_cmd.insize > EC_MAX_MSG_BYTES))\n\t\treturn -EINVAL;\n\ts_cmd = kmalloc(sizeof(*s_cmd) + max(u_cmd.outsize, u_cmd.insize),\n\t\t\tGFP_KERNEL);\n\tif (!s_cmd)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(s_cmd, arg, sizeof(*s_cmd) + u_cmd.outsize)) {\n\t\tret = -EFAULT;\n\t\tgoto exit;\n\t}\n\ts_cmd->command += ec->cmd_offset;\n\tret = cros_ec_cmd_xfer(ec->ec_dev, s_cmd);\n\tif (ret < 0)\n\t\tgoto exit;\n\tif (copy_to_user(arg, s_cmd, sizeof(*s_cmd) + u_cmd.insize))\n\t\tret = -EFAULT;\nexit:\n\tkfree(s_cmd);\n\treturn ret;\n}", "target": 1}
{"code": "static void skcipher_sock_destruct(struct sock *sk)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tstruct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(&ctx->req);\n\tskcipher_free_sgl(sk);\n\tsock_kfree_s(sk, ctx->iv, crypto_ablkcipher_ivsize(tfm));\n\tsock_kfree_s(sk, ctx, ctx->len);\n\taf_alg_release_parent(sk);\n}", "target": 0}
{"code": "wb_id(netdissect_options *ndo,\n      const struct pkt_id *id, u_int len)\n{\n\tint i;\n\tconst char *cp;\n\tconst struct id_off *io;\n\tchar c;\n\tint nid;\n\tND_PRINT((ndo, \" wb-id:\"));\n\tif (len < sizeof(*id) || !ND_TTEST(*id))\n\t\treturn (-1);\n\tlen -= sizeof(*id);\n\tND_PRINT((ndo, \" %u/%s:%u (max %u/%s:%u) \",\n\t       EXTRACT_32BITS(&id->pi_ps.slot),\n\t       ipaddr_string(ndo, &id->pi_ps.page.p_sid),\n\t       EXTRACT_32BITS(&id->pi_ps.page.p_uid),\n\t       EXTRACT_32BITS(&id->pi_mslot),\n\t       ipaddr_string(ndo, &id->pi_mpage.p_sid),\n\t       EXTRACT_32BITS(&id->pi_mpage.p_uid)));\n\tnid = EXTRACT_16BITS(&id->pi_ps.nid);\n\tlen -= sizeof(*io) * nid;\n\tio = (struct id_off *)(id + 1);\n\tcp = (char *)(io + nid);\n\tif (!ND_TTEST2(cp, len)) {\n\t\tND_PRINT((ndo, \"\\\"\"));\n\t\tfn_print(ndo, (u_char *)cp, (u_char *)cp + len);\n\t\tND_PRINT((ndo, \"\\\"\"));\n\t}\n\tc = '<';\n\tfor (i = 0; i < nid && ND_TTEST(*io); ++io, ++i) {\n\t\tND_PRINT((ndo, \"%c%s:%u\",\n\t\t    c, ipaddr_string(ndo, &io->id), EXTRACT_32BITS(&io->off)));\n\t\tc = ',';\n\t}\n\tif (i >= nid) {\n\t\tND_PRINT((ndo, \">\"));\n\t\treturn (0);\n\t}\n\treturn (-1);\n}", "target": 1}
{"code": "B44Compressor::B44Compressor\n    (const Header &hdr,\n     size_t maxScanLineSize,\n     size_t numScanLines,\n     bool optFlatFields)\n:\n    Compressor (hdr),\n    _maxScanLineSize (maxScanLineSize),\n    _optFlatFields (optFlatFields),\n    _format (XDR),\n    _numScanLines (numScanLines),\n    _tmpBuffer (0),\n    _outBuffer (0),\n    _numChans (0),\n    _channels (hdr.channels()),\n    _channelData (0)\n{\n    (void)_maxScanLineSize;\n    _tmpBuffer = new unsigned short\n        [checkArraySize (uiMult (maxScanLineSize, numScanLines),\n                         sizeof (unsigned short))];\n    const ChannelList &channels = header().channels();\n    int numHalfChans = 0;\n    for (ChannelList::ConstIterator c = channels.begin();\n\t c != channels.end();\n\t ++c)\n    {\n\tassert (pixelTypeSize (c.channel().type) % pixelTypeSize (HALF) == 0);\n\t++_numChans;\n\tif (c.channel().type == HALF)\n\t    ++numHalfChans;\n    }\n    size_t padding = 12 * numHalfChans * (numScanLines + 3) / 4;\n    _outBuffer = new char\n        [uiAdd (uiMult (maxScanLineSize, numScanLines), padding)];\n    _channelData = new ChannelData[_numChans];\n    int i = 0;\n    for (ChannelList::ConstIterator c = channels.begin();\n\t c != channels.end();\n\t ++c, ++i)\n    {\n\t_channelData[i].ys = c.channel().ySampling;\n\t_channelData[i].type = c.channel().type;\n\t_channelData[i].pLinear = c.channel().pLinear;\n\t_channelData[i].size =\n\t    pixelTypeSize (c.channel().type) / pixelTypeSize (HALF);\n    }\n    const Box2i &dataWindow = hdr.dataWindow();\n    _minX = dataWindow.min.x;\n    _maxX = dataWindow.max.x;\n    _maxY = dataWindow.max.y;\n    assert (sizeof (unsigned short) == pixelTypeSize (HALF));\n    if (_numChans == numHalfChans)\n\t_format = NATIVE;\n}", "target": 1}
{"code": "PJ_DEF(void) pj_scan_get_unescape( pj_scanner *scanner,\n\t\t\t\t   const pj_cis_t *spec, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n    char *dst = s;\n    pj_assert(pj_cis_match(spec,0)==0);\n    pj_assert(pj_cis_match(spec,'%')==0);\n    if (!pj_cis_match(spec, *s) && *s != '%') {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n    out->ptr = s;\n    do {\n\tif (*s == '%') {\n\t    if (s+3 <= scanner->end && pj_isxdigit(*(s+1)) && \n\t\tpj_isxdigit(*(s+2))) \n\t    {\n\t\t*dst = (pj_uint8_t) ((pj_hex_digit_to_val(*(s+1)) << 4) +\n\t\t\t\t      pj_hex_digit_to_val(*(s+2)));\n\t\t++dst;\n\t\ts += 3;\n\t    } else {\n\t\t*dst++ = *s++;\n\t\t*dst++ = *s++;\n\t\tbreak;\n\t    }\n\t}\n\tif (pj_cis_match(spec, *s)) {\n\t    char *start = s;\n\t    do {\n\t\t++s;\n\t    } while (pj_cis_match(spec, *s));\n\t    if (dst != start) pj_memmove(dst, start, s-start);\n\t    dst += (s-start);\n\t} \n    } while (*s == '%');\n    scanner->curptr = s;\n    out->slen = (dst - out->ptr);\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*s) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);    \n    }\n}", "target": 1}
{"code": "static inline void PrefetchPixelCacheNexusPixels(const NexusInfo *nexus_info,\n  const MapMode mode)\n{\n  if (mode == ReadMode)\n    {\n      MagickCachePrefetch((unsigned char *) nexus_info->pixels,0,1);\n      return;\n    }\n  MagickCachePrefetch((unsigned char *) nexus_info->pixels,1,1);\n}", "target": 0}
{"code": "static int assign_cfs_rq_runtime(struct cfs_rq *cfs_rq)\n{\n\tstruct task_group *tg = cfs_rq->tg;\n\tstruct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(tg);\n\tu64 amount = 0, min_amount, expires;\n\tint expires_seq;\n\tmin_amount = sched_cfs_bandwidth_slice() - cfs_rq->runtime_remaining;\n\traw_spin_lock(&cfs_b->lock);\n\tif (cfs_b->quota == RUNTIME_INF)\n\t\tamount = min_amount;\n\telse {\n\t\tstart_cfs_bandwidth(cfs_b);\n\t\tif (cfs_b->runtime > 0) {\n\t\t\tamount = min(cfs_b->runtime, min_amount);\n\t\t\tcfs_b->runtime -= amount;\n\t\t\tcfs_b->idle = 0;\n\t\t}\n\t}\n\texpires_seq = cfs_b->expires_seq;\n\texpires = cfs_b->runtime_expires;\n\traw_spin_unlock(&cfs_b->lock);\n\tcfs_rq->runtime_remaining += amount;\n\tif (cfs_rq->expires_seq != expires_seq) {\n\t\tcfs_rq->expires_seq = expires_seq;\n\t\tcfs_rq->runtime_expires = expires;\n\t}\n\treturn cfs_rq->runtime_remaining > 0;\n}", "target": 1}
{"code": "    bool read(ReadonlyBytes buffer)\n    {\n        auto fields_size = sizeof(LocalFileHeader) - (sizeof(u8*) * 3);\n        if (buffer.size() < fields_size)\n            return false;\n        if (memcmp(buffer.data(), local_file_header_signature, sizeof(local_file_header_signature)) != 0)\n            return false;\n        memcpy(reinterpret_cast<void*>(&minimum_version), buffer.data() + sizeof(local_file_header_signature), fields_size);\n        name = buffer.data() + sizeof(local_file_header_signature) + fields_size;\n        extra_data = name + name_length;\n        compressed_data = extra_data + extra_data_length;\n        return true;\n    }", "target": 1}
{"code": "asmlinkage void bad_mode(struct pt_regs *regs, int reason, unsigned int esr)\n{\n\tconsole_verbose();\n\tpr_crit(\"Bad mode in %s handler detected, code 0x%08x\\n\",\n\t\thandler[reason], esr);\n\tdie(\"Oops - bad mode\", regs, 0);\n\tlocal_irq_disable();\n\tpanic(\"bad mode\");\n}", "target": 1}
{"code": "static int adts_decode_extradata(AVFormatContext *s, ADTSContext *adts, const uint8_t *buf, int size)\n{\n    GetBitContext gb;\n    PutBitContext pb;\n    MPEG4AudioConfig m4ac;\n    int off;\n    init_get_bits(&gb, buf, size * 8);\n    off = avpriv_mpeg4audio_get_config2(&m4ac, buf, size, 1, s);\n    if (off < 0)\n        return off;\n    skip_bits_long(&gb, off);\n    adts->objecttype        = m4ac.object_type - 1;\n    adts->sample_rate_index = m4ac.sampling_index;\n    adts->channel_conf      = m4ac.chan_config;\n    if (adts->objecttype > 3U) {\n        av_log(s, AV_LOG_ERROR, \"MPEG-4 AOT %d is not allowed in ADTS\\n\", adts->objecttype+1);\n        return AVERROR_INVALIDDATA;\n    }\n    if (adts->sample_rate_index == 15) {\n        av_log(s, AV_LOG_ERROR, \"Escape sample rate index illegal in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (get_bits(&gb, 1)) {\n        av_log(s, AV_LOG_ERROR, \"960/120 MDCT window is not allowed in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (get_bits(&gb, 1)) {\n        av_log(s, AV_LOG_ERROR, \"Scalable configurations are not allowed in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (get_bits(&gb, 1)) {\n        av_log(s, AV_LOG_ERROR, \"Extension flag is not allowed in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (!adts->channel_conf) {\n        init_put_bits(&pb, adts->pce_data, MAX_PCE_SIZE);\n        put_bits(&pb, 3, 5); \n        adts->pce_size = (ff_copy_pce_data(&pb, &gb) + 3) / 8;\n        flush_put_bits(&pb);\n    }\n    adts->write_adts = 1;\n    return 0;\n}", "target": 1}
{"code": "void TableLookUp::setTable(int ntable, const std::vector<ushort16>& table) {\n  assert(!table.empty());\n  const int nfilled = table.size();\n  if (nfilled >= 65536)\n    ThrowRDE(\"Table lookup with %i entries is unsupported\", nfilled);\n  if (ntable > ntables) {\n    ThrowRDE(\"Table lookup with number greater than number of tables.\");\n  }\n  ushort16* t = &tables[ntable * TABLE_SIZE];\n  if (!dither) {\n    for (int i = 0; i < 65536; i++) {\n      t[i] = (i < nfilled) ? table[i] : table[nfilled - 1];\n    }\n    return;\n  }\n  for (int i = 0; i < nfilled; i++) {\n    int center = table[i];\n    int lower = i > 0 ? table[i - 1] : center;\n    int upper = i < (nfilled - 1) ? table[i + 1] : center;\n    int delta = upper - lower;\n    t[i * 2] = center - ((upper - lower + 2) / 4);\n    t[i * 2 + 1] = delta;\n  }\n  for (int i = nfilled; i < 65536; i++) {\n    t[i * 2] = table[nfilled - 1];\n    t[i * 2 + 1] = 0;\n  }\n  t[0] = t[1];\n  t[TABLE_SIZE - 1] = t[TABLE_SIZE - 2];\n}", "target": 0}
{"code": "memcmp_constant_time (const void *a, const void *b, size_t size) {\n  const uint8_t * a1 = a;\n  const uint8_t * b1 = b;\n  int ret = 0;\n  size_t i;\n  for (i = 0; i < size; i++) {\n      ret |= *a1++ ^ *b1++;\n  }\n  return ret;\n}", "target": 0}
{"code": "void SavePackage::Cancel(bool user_action) {\n  if (!canceled()) {\n    if (user_action)\n      user_canceled_ = true;\n    else\n      disk_error_occurred_ = true;\n    Stop();\n  }\n  RecordSavePackageEvent(SAVE_PACKAGE_CANCELLED);\n}", "target": 0}
{"code": "GF_Err gf_avc_change_color(GF_AVCConfig *avcc, s32 fullrange, s32 vidformat, s32 colorprim, s32 transfer, s32 colmatrix)\n{\n\tGF_VUIInfo vuii;\n\tmemset(&vuii, 0, sizeof(GF_VUIInfo));\n\tvuii.ar_num = -1;\n\tvuii.ar_den = -1;\n\tvuii.fullrange = fullrange;\n\tvuii.video_format = vidformat;\n\tvuii.color_prim = colorprim;\n\tvuii.color_tfc = transfer;\n\tvuii.color_matrix = colmatrix;\n\treturn gf_avc_change_vui(avcc, &vuii);\n}", "target": 0}
{"code": "static int __init sit_init(void)\n{\n\tint err;\n\tprintk(KERN_INFO \"IPv6 over IPv4 tunneling driver\\n\");\n\tif (xfrm4_tunnel_register(&sit_handler, AF_INET6) < 0) {\n\t\tprintk(KERN_INFO \"sit init: Can't add protocol\\n\");\n\t\treturn -EAGAIN;\n\t}\n\terr = register_pernet_device(&sit_net_ops);\n\tif (err < 0)\n\t\txfrm4_tunnel_deregister(&sit_handler, AF_INET6);\n\treturn err;\n}", "target": 1}
{"code": "TEST_F(ZNCTest, Modpython) {\n    if (QProcessEnvironment::systemEnvironment().value(\n            \"DISABLED_ZNC_PERL_PYTHON_TEST\") == \"1\") {\n        return;\n    }\n    auto znc = Run();\n    znc->CanLeak();\n    auto ircd = ConnectIRCd();\n    auto client = LoginClient();\n    client.Write(\"znc loadmod modpython\");\n    client.Write(\"znc loadmod pyeval\");\n    client.Write(\"PRIVMSG *pyeval :2+2\");\n    client.ReadUntil(\":*pyeval!znc@znc.in PRIVMSG nick :4\");\n    client.Write(\"PRIVMSG *pyeval :module.GetUser().GetUserName()\");\n    client.ReadUntil(\"nick :'user'\");\n    ircd.Write(\":server 001 nick :Hello\");\n    ircd.Write(\":n!u@h PRIVMSG nick :Hi\\xF0, github issue #1229\");\n    client.ReadUntil(\"Hi\\xEF\\xBF\\xBD, github issue\");\n    client.Write(\"PRIVMSG *controlpanel :Set ClientEncoding $me Western\");\n    client.Write(\"JOIN #a\\342\");\n    client.ReadUntil(\n        \":*controlpanel!znc@znc.in PRIVMSG nick :ClientEncoding = UTF-8\");\n    ircd.ReadUntil(\"JOIN #a\\xEF\\xBF\\xBD\");\n}", "target": 0}
{"code": "static void adapter_stop(struct btd_adapter *adapter)\n{\n\treply_pending_requests(adapter);\n\tcancel_passive_scanning(adapter);\n\tremove_discovery_list(adapter);\n\tdiscovery_cleanup(adapter, 0);\n\tadapter->filtered_discovery = false;\n\tadapter->no_scan_restart_delay = false;\n\tg_free(adapter->current_discovery_filter);\n\tadapter->current_discovery_filter = NULL;\n\tset_discovery_discoverable(adapter, false);\n\tadapter->discovering = false;\n\twhile (adapter->connections) {\n\t\tstruct btd_device *device = adapter->connections->data;\n\t\tuint8_t addr_type = btd_device_get_bdaddr_type(device);\n\t\tadapter_remove_connection(adapter, device, BDADDR_BREDR);\n\t\tif (addr_type != BDADDR_BREDR)\n\t\t\tadapter_remove_connection(adapter, device, addr_type);\n\t}\n\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Discovering\");\n\tif (adapter->dev_class) {\n\t\tadapter->dev_class = 0;\n\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\t\tADAPTER_INTERFACE, \"Class\");\n\t}\n\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\t\tADAPTER_INTERFACE, \"Powered\");\n\tDBG(\"adapter %s has been disabled\", adapter->path);\n}", "target": 0}
{"code": "static int client_mpvio_read_packet(struct st_plugin_vio *mpv, uchar **buf)\n{\n  MCPVIO_EXT *mpvio= (MCPVIO_EXT*)mpv;\n  MYSQL *mysql= mpvio->mysql;\n  ulong  pkt_len;\n  if (mpvio->cached_server_reply.pkt)\n  {\n    *buf= mpvio->cached_server_reply.pkt;\n    mpvio->cached_server_reply.pkt= 0;\n    mpvio->packets_read++;\n    return mpvio->cached_server_reply.pkt_len;\n  }\n  if (mpvio->packets_read == 0)\n  {\n    if (client_mpvio_write_packet(mpv, 0, 0))\n      return (int)packet_error;\n  }\n  pkt_len= (*mysql->methods->read_change_user_result)(mysql);\n  mpvio->last_read_packet_len= pkt_len;\n  *buf= mysql->net.read_pos;\n  if (pkt_len == packet_error || **buf == 254)\n    return (int)packet_error; \n  if (pkt_len && **buf == 1)\n  {\n    (*buf)++;\n    pkt_len--;\n  }\n  mpvio->packets_read++;\n  return pkt_len;\n}", "target": 0}
{"code": "static void set_ntacl_dacl(struct user_namespace *user_ns,\n\t\t\t   struct smb_acl *pndacl,\n\t\t\t   struct smb_acl *nt_dacl,\n\t\t\t   const struct smb_sid *pownersid,\n\t\t\t   const struct smb_sid *pgrpsid,\n\t\t\t   struct smb_fattr *fattr)\n{\n\tstruct smb_ace *ntace, *pndace;\n\tint nt_num_aces = le32_to_cpu(nt_dacl->num_aces), num_aces = 0;\n\tunsigned short size = 0;\n\tint i;\n\tpndace = (struct smb_ace *)((char *)pndacl + sizeof(struct smb_acl));\n\tif (nt_num_aces) {\n\t\tntace = (struct smb_ace *)((char *)nt_dacl + sizeof(struct smb_acl));\n\t\tfor (i = 0; i < nt_num_aces; i++) {\n\t\t\tmemcpy((char *)pndace + size, ntace, le16_to_cpu(ntace->size));\n\t\t\tsize += le16_to_cpu(ntace->size);\n\t\t\tntace = (struct smb_ace *)((char *)ntace + le16_to_cpu(ntace->size));\n\t\t\tnum_aces++;\n\t\t}\n\t}\n\tset_posix_acl_entries_dacl(user_ns, pndace, fattr,\n\t\t\t\t   &num_aces, &size, nt_num_aces);\n\tpndacl->num_aces = cpu_to_le32(num_aces);\n\tpndacl->size = cpu_to_le16(le16_to_cpu(pndacl->size) + size);\n}", "target": 1}
{"code": "static void setGenericValues(EctEnhancedCT *ct)\n{\n    if (!ct)\n        return;\n    OFCHECK(ct->getPatient().setPatientName(\"Bond^James\").good());\n    OFCHECK(ct->getPatient().setPatientID(\"007\").good());\n    OFCHECK(ct->getPatient().setPatientBirthDate(\"19771007\").good());\n    OFCHECK(ct->getStudy().setStudyDate(\"20190801\").good());\n    OFCHECK(ct->getStudy().setStudyTime(\"120000\").good());\n    OFCHECK(ct->getStudy().setStudyID(\"1\").good());\n    OFCHECK(ct->getPatientStudy().setPatientAge(\"040Y\").good());\n    OFCHECK(ct->getSeries().setSeriesDescription(\"Test Description\").good());\n    OFCHECK(ct->getSeries().setSeriesNumber(\"1\").good());\n    OFCHECK(ct->getSeries().setPatientPosition(\"HFS\").good());\n    OFCHECK(ct->getStudy().setStudyInstanceUID(\"1.2.276.0.7230010.3.1.2.8323329.14863.1565940357.864811\").good());\n    OFCHECK(ct->getFrameOfReference().setFrameOfReferenceUID(\"2.25.30853397773651184949181049330553108086\").good());\n    OFCHECK(ct->getSeries().setSeriesInstanceUID(\"1.2.276.0.7230010.3.1.3.8323329.14863.1565940357.864812\").good());\n    OFCHECK(ct->getSOPCommon().setSOPInstanceUID(\"1.2.276.0.7230010.3.1.4.8323329.14863.1565940357.864813\").good());\n    OFCHECK(ct->getIODMultiFrameFGModule().setContentTime(\"092557\").good());\n    OFCHECK(ct->getIODMultiFrameFGModule().setContentDate(\"20190816\").good());\n}", "target": 0}
{"code": "unsigned long get_zeroed_page(gfp_t gfp_mask)\n{\n\treturn __get_free_pages(gfp_mask | __GFP_ZERO, 0);\n}", "target": 0}
{"code": "static void virtio_net_detach_epbf_rss(VirtIONet *n)\n{\n    virtio_net_attach_ebpf_to_backend(n->nic, -1);\n}", "target": 0}
{"code": "ev_archive_get_entry_size (EvArchive *archive)\n{\n\tg_return_val_if_fail (EV_IS_ARCHIVE (archive), -1);\n\tg_return_val_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE, -1);\n\tswitch (archive->type) {\n\tcase EV_ARCHIVE_TYPE_NONE:\n\t\tg_assert_not_reached ();\n\tcase EV_ARCHIVE_TYPE_RAR:\n\tcase EV_ARCHIVE_TYPE_ZIP:\n\tcase EV_ARCHIVE_TYPE_7Z:\n\tcase EV_ARCHIVE_TYPE_TAR:\n\t\tg_return_val_if_fail (archive->libar_entry != NULL, -1);\n\t\treturn archive_entry_size (archive->libar_entry);\n\t}\n\treturn -1;\n}", "target": 0}
{"code": "Status GetInitOp(const string& export_dir, const MetaGraphDef& meta_graph_def,\n                 string* init_op_name) {\n  const auto& sig_def_map = meta_graph_def.signature_def();\n  const auto& init_op_sig_it =\n      meta_graph_def.signature_def().find(kSavedModelInitOpSignatureKey);\n  if (init_op_sig_it != sig_def_map.end()) {\n    *init_op_name = init_op_sig_it->second.outputs()\n                        .find(kSavedModelInitOpSignatureKey)\n                        ->second.name();\n    return Status::OK();\n  }\n  const auto& collection_def_map = meta_graph_def.collection_def();\n  string init_op_collection_key;\n  if (collection_def_map.find(kSavedModelMainOpKey) !=\n      collection_def_map.end()) {\n    init_op_collection_key = kSavedModelMainOpKey;\n  } else {\n    init_op_collection_key = kSavedModelLegacyInitOpKey;\n  }\n  const auto init_op_it = collection_def_map.find(init_op_collection_key);\n  if (init_op_it != collection_def_map.end()) {\n    if (init_op_it->second.node_list().value_size() != 1) {\n      return errors::FailedPrecondition(\n          strings::StrCat(\"Expected exactly one main op in : \", export_dir));\n    }\n    *init_op_name = init_op_it->second.node_list().value(0);\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "String roamingUserSpecificStorageDirectory()\n{\n    return cachedStorageDirectory(CSIDL_APPDATA);\n}", "target": 0}
{"code": "void util_hex_dump(FILE *f, const u8 *in, int len, const char *sep)\n{\n\tint i;\n\tfor (i = 0; i < len; i++) {\n\t\tif (sep != NULL && i)\n\t\t\tfprintf(f, \"%s\", sep);\n\t\tfprintf(f, \"%02X\", in[i]);\n\t}\n}", "target": 0}
{"code": "int mpol_parse_str(char *str, struct mempolicy **mpol)\n{\n\tstruct mempolicy *new = NULL;\n\tunsigned short mode_flags;\n\tnodemask_t nodes;\n\tchar *nodelist = strchr(str, ':');\n\tchar *flags = strchr(str, '=');\n\tint err = 1, mode;\n\tif (flags)\n\t\t*flags++ = '\\0';\t\n\tif (nodelist) {\n\t\t*nodelist++ = '\\0';\n\t\tif (nodelist_parse(nodelist, nodes))\n\t\t\tgoto out;\n\t\tif (!nodes_subset(nodes, node_states[N_MEMORY]))\n\t\t\tgoto out;\n\t} else\n\t\tnodes_clear(nodes);\n\tmode = match_string(policy_modes, MPOL_MAX, str);\n\tif (mode < 0)\n\t\tgoto out;\n\tswitch (mode) {\n\tcase MPOL_PREFERRED:\n\t\tif (nodelist) {\n\t\t\tchar *rest = nodelist;\n\t\t\twhile (isdigit(*rest))\n\t\t\t\trest++;\n\t\t\tif (*rest)\n\t\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase MPOL_INTERLEAVE:\n\t\tif (!nodelist)\n\t\t\tnodes = node_states[N_MEMORY];\n\t\tbreak;\n\tcase MPOL_LOCAL:\n\t\tif (nodelist)\n\t\t\tgoto out;\n\t\tmode = MPOL_PREFERRED;\n\t\tbreak;\n\tcase MPOL_DEFAULT:\n\t\tif (!nodelist)\n\t\t\terr = 0;\n\t\tgoto out;\n\tcase MPOL_BIND:\n\t\tif (!nodelist)\n\t\t\tgoto out;\n\t}\n\tmode_flags = 0;\n\tif (flags) {\n\t\tif (!strcmp(flags, \"static\"))\n\t\t\tmode_flags |= MPOL_F_STATIC_NODES;\n\t\telse if (!strcmp(flags, \"relative\"))\n\t\t\tmode_flags |= MPOL_F_RELATIVE_NODES;\n\t\telse\n\t\t\tgoto out;\n\t}\n\tnew = mpol_new(mode, mode_flags, &nodes);\n\tif (IS_ERR(new))\n\t\tgoto out;\n\tif (mode != MPOL_PREFERRED)\n\t\tnew->v.nodes = nodes;\n\telse if (nodelist)\n\t\tnew->v.preferred_node = first_node(nodes);\n\telse\n\t\tnew->flags |= MPOL_F_LOCAL;\n\tnew->w.user_nodemask = nodes;\n\terr = 0;\nout:\n\tif (nodelist)\n\t\t*--nodelist = ':';\n\tif (flags)\n\t\t*--flags = '=';\n\tif (!err)\n\t\t*mpol = new;\n\treturn err;\n}", "target": 1}
{"code": "parserep(netdissect_options *ndo,\n         register const struct sunrpc_msg *rp, register u_int length)\n{\n\tregister const uint32_t *dp;\n\tu_int len;\n\tenum sunrpc_accept_stat astat;\n\tdp = ((const uint32_t *)&rp->rm_reply) + 1;\n\tND_TCHECK(dp[1]);\n\tlen = EXTRACT_32BITS(&dp[1]);\n\tif (len >= length)\n\t\treturn (NULL);\n\tdp += (len + (2*sizeof(uint32_t) + 3)) / sizeof(uint32_t);\n\tND_TCHECK2(dp[0], 0);\n\tastat = (enum sunrpc_accept_stat) EXTRACT_32BITS(dp);\n\tif (astat != SUNRPC_SUCCESS) {\n\t\tND_PRINT((ndo, \" %s\", tok2str(sunrpc_str, \"ar_stat %d\", astat)));\n\t\tnfserr = 1;\t\t\n\t\treturn (NULL);\n\t}\n\tND_TCHECK2(*dp, sizeof(astat));\n\treturn ((const uint32_t *) (sizeof(astat) + ((const char *)dp)));\ntrunc:\n\treturn (0);\n}", "target": 1}
{"code": "static void ffs_user_copy_worker(struct work_struct *work)\n{\n\tstruct ffs_io_data *io_data = container_of(work, struct ffs_io_data,\n\t\t\t\t\t\t   work);\n\tint ret = io_data->req->status ? io_data->req->status :\n\t\t\t\t\t io_data->req->actual;\n\tif (io_data->read && ret > 0) {\n\t\tuse_mm(io_data->mm);\n\t\tret = copy_to_iter(io_data->buf, ret, &io_data->data);\n\t\tif (iov_iter_count(&io_data->data))\n\t\t\tret = -EFAULT;\n\t\tunuse_mm(io_data->mm);\n\t}\n\tio_data->kiocb->ki_complete(io_data->kiocb, ret, ret);\n\tif (io_data->ffs->ffs_eventfd &&\n\t    !(io_data->kiocb->ki_flags & IOCB_EVENTFD))\n\t\teventfd_signal(io_data->ffs->ffs_eventfd, 1);\n\tusb_ep_free_request(io_data->ep, io_data->req);\n\tio_data->kiocb->private = NULL;\n\tif (io_data->read)\n\t\tkfree(io_data->to_free);\n\tkfree(io_data->buf);\n\tkfree(io_data);\n}", "target": 1}
{"code": "storagePoolGetXMLDesc(virStoragePoolPtr pool,\n                      unsigned int flags)\n{\n    virStoragePoolObj *obj;\n    virStoragePoolDef *def;\n    virStoragePoolDef *newDef;\n    virStoragePoolDef *curDef;\n    char *ret = NULL;\n    virCheckFlags(VIR_STORAGE_XML_INACTIVE, NULL);\n    if (!(obj = virStoragePoolObjFromStoragePool(pool)))\n        return NULL;\n    def = virStoragePoolObjGetDef(obj);\n    newDef = virStoragePoolObjGetNewDef(obj);\n    if (virStoragePoolGetXMLDescEnsureACL(pool->conn, def) < 0)\n        goto cleanup;\n    if ((flags & VIR_STORAGE_XML_INACTIVE) && newDef)\n        curDef = newDef;\n    else\n        curDef = def;\n    ret = virStoragePoolDefFormat(curDef);\n cleanup:\n    virStoragePoolObjEndAPI(&obj);\n    return ret;\n}", "target": 0}
{"code": "void test_creat(const char *path)\n{\n\tif (creat(path, 0755) >= 0) {\n\t\tfprintf(stderr, \"leak at creat of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at creat of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "cdf_dump(void *v, size_t len)\n{\n\tsize_t i, j;\n\tunsigned char *p = v;\n\tchar abuf[16];\n\t(void)fprintf(stderr, \"%.4x: \", 0);\n\tfor (i = 0, j = 0; i < len; i++, p++) {\n\t\t(void)fprintf(stderr, \"%.2x \", *p);\n\t\tabuf[j++] = isprint(*p) ? *p : '.';\n\t\tif (j == 16) {\n\t\t\tj = 0;\n\t\t\tabuf[15] = '\\0';\n\t\t\t(void)fprintf(stderr, \"%s\\n%.4\" SIZE_T_FORMAT \"x: \",\n\t\t\t    abuf, i + 1);\n\t\t}\n\t}\n\t(void)fprintf(stderr, \"\\n\");\n}", "target": 0}
{"code": "static inline uint32_t mp_clz_mpi(mp_int_t x) {\n    MP_STATIC_ASSERT(sizeof(mp_int_t) == sizeof(long long)\n        || sizeof(mp_int_t) == sizeof(long));\n    if (sizeof(mp_int_t) == sizeof(long)) {\n        return mp_clzl(x);\n    } else {\n        return mp_clzll(x);\n    }\n}", "target": 0}
{"code": "snmp_mib_add(snmp_mib_resource_t *new_resource)\n{\n  snmp_mib_resource_t *resource;\n  for(resource = list_head(snmp_mib);\n      resource; resource = resource->next) {\n    if(snmp_oid_cmp_oid(resource->oid, new_resource->oid) > 0) {\n      break;\n    }\n  }\n  if(resource == NULL) {\n    list_add(snmp_mib, new_resource);\n  } else {\n    list_insert(snmp_mib, new_resource, resource);\n  }\n#if LOG_LEVEL == LOG_LEVEL_DBG\n  LOG_DBG(\"Table after insert.\\n\");\n  for(resource = list_head(snmp_mib);\n      resource; resource = resource->next) {\n    snmp_oid_print(resource->oid);\n  }\n#endif \n}", "target": 1}
{"code": "snmp_oid_encode_oid(unsigned char *out, uint32_t *out_len, uint32_t *oid)\n{\n  uint32_t original_out_len;\n  uint32_t *oid_start = oid;\n  uint32_t num;\n  original_out_len = *out_len;\n  while(*oid != ((uint32_t)-1)) {\n    ++oid;\n  }\n  --oid;\n  while(oid != oid_start) {\n    num = *oid;\n    (*out_len)++;\n    *out-- = (uint8_t)(num & 0x7F);\n    num >>= 7;\n    while(num) {\n      (*out_len)++;\n      *out-- = (uint8_t)((num & 0x7F) | 0x80);\n      num >>= 7;\n    }\n    --oid;\n  }\n  num = *(out + 1) + 40 * *oid;\n  (*out_len)--;\n  out++;\n  (*out_len)++;\n  *out-- = (uint8_t)(num & 0x7F);\n  num >>= 7;\n  while(num) {\n    (*out_len)++;\n    *out-- = (uint8_t)((num & 0x7F) | 0x80);\n    num >>= 7;\n  }\n  out = snmp_ber_encode_length(out, out_len, ((*out_len - original_out_len) & 0xFF));\n  out = snmp_ber_encode_type(out, out_len, SNMP_DATA_TYPE_OBJECT);\n  return out;\n}", "target": 1}
{"code": "sixel_allocator_calloc(\n    sixel_allocator_t    *allocator,  \n    size_t               nelm,        \n    size_t               elsize)      \n{\n    size_t n;\n    assert(allocator);\n    assert(allocator->fn_calloc);\n    n = nelm * elsize;\n    if (n == 0) {\n        sixel_helper_set_additional_message(\n            \"sixel_allocator_malloc: called with n == 0\");\n        return NULL;\n    }\n    if (n > SIXEL_ALLOCATE_BYTES_MAX) {\n        return NULL;\n    }\n    return allocator->fn_calloc(nelm, elsize);\n}", "target": 0}
{"code": "static int decode_band_types(AACContext *ac, enum BandType band_type[120],\n                             int band_type_run_end[120], GetBitContext *gb,\n                             IndividualChannelStream *ics)\n{\n    int g, idx = 0;\n    const int bits = (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) ? 3 : 5;\n    for (g = 0; g < ics->num_window_groups; g++) {\n        int k = 0;\n        while (k < ics->max_sfb) {\n            uint8_t sect_end = k;\n            int sect_len_incr;\n            int sect_band_type = get_bits(gb, 4);\n            if (sect_band_type == 12) {\n                av_log(ac->avctx, AV_LOG_ERROR, \"invalid band type\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n            do {\n                sect_len_incr = get_bits(gb, bits);\n                sect_end += sect_len_incr;\n                if (get_bits_left(gb) < 0) {\n                    av_log(ac->avctx, AV_LOG_ERROR, \"decode_band_types: \"overread_err);\n                    return AVERROR_INVALIDDATA;\n                }\n                if (sect_end > ics->max_sfb) {\n                    av_log(ac->avctx, AV_LOG_ERROR,\n                           \"Number of bands (%d) exceeds limit (%d).\\n\",\n                           sect_end, ics->max_sfb);\n                    return AVERROR_INVALIDDATA;\n                }\n            } while (sect_len_incr == (1 << bits) - 1);\n            for (; k < sect_end; k++) {\n                band_type        [idx]   = sect_band_type;\n                band_type_run_end[idx++] = sect_end;\n            }\n        }\n    }\n    return 0;\n}", "target": 0}
{"code": "static int m88rs2000_frontend_attach(struct dvb_usb_adapter *d)\n{\n\tu8 obuf[] = { 0x51 };\n\tu8 ibuf[] = { 0 };\n\tif (dvb_usb_generic_rw(d->dev, obuf, 1, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x51 transfer failed.\");\n\td->fe_adap[0].fe = dvb_attach(m88rs2000_attach, &s421_m88rs2000_config,\n\t\t\t\t\t&d->dev->i2c_adap);\n\tif (d->fe_adap[0].fe == NULL)\n\t\treturn -EIO;\n\tif (dvb_attach(ts2020_attach, d->fe_adap[0].fe,\n\t\t\t\t&dw2104_ts2020_config,\n\t\t\t\t&d->dev->i2c_adap)) {\n\t\tinfo(\"Attached RS2000/TS2020!\");\n\t\treturn 0;\n\t}\n\tinfo(\"Failed to attach RS2000/TS2020!\");\n\treturn -EIO;\n}", "target": 1}
{"code": "getSystemTempDir() {\n\tconst char *temp_dir = getenv(\"PASSENGER_TEMP_DIR\");\n\tif (temp_dir == NULL || *temp_dir == '\\0') {\n\t\ttemp_dir = getenv(\"PASSENGER_TMPDIR\");\n\t\tif (temp_dir == NULL || *temp_dir == '\\0') {\n\t\t\ttemp_dir = \"/tmp\";\n\t\t}\n\t}\n\treturn temp_dir;\n}", "target": 0}
{"code": "archive_write_disk_set_acls(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode)\n{\n\tint\t\tret = ARCHIVE_OK;\n\t(void)mode;\t\n\tif ((archive_acl_types(abstract_acl)\n\t    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {\n\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_POSIX1E, \"posix1e\");\n\t\treturn (ret);\n\t}\n#if ARCHIVE_ACL_SUNOS_NFS4\n\telse if ((archive_acl_types(abstract_acl) &\n\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {\n\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4, \"nfs4\");\n\t}\n#endif\n\treturn (ret);\n}", "target": 1}
{"code": "int for_each_problem_in_dir(const char *path,\n                        uid_t caller_uid,\n                        int (*callback)(struct dump_dir *dd, void *arg),\n                        void *arg)\n{\n    DIR *dp = opendir(path);\n    if (!dp)\n    {\n        return 0;\n    }\n    int brk = 0;\n    struct dirent *dent;\n    while ((dent = readdir(dp)) != NULL)\n    {\n        if (dot_or_dotdot(dent->d_name))\n            continue; \n        char *full_name = concat_path_file(path, dent->d_name);\n        if (caller_uid == -1 || dump_dir_accessible_by_uid(full_name, caller_uid))\n        {\n            int sv_logmode = logmode;\n            logmode = 0;\n            struct dump_dir *dd = dd_opendir(full_name, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES | DD_DONT_WAIT_FOR_LOCK);\n            logmode = sv_logmode;\n            if (dd)\n            {\n                brk = callback ? callback(dd, arg) : 0;\n                dd_close(dd);\n            }\n        }\n        free(full_name);\n        if (brk)\n            break;\n    }\n    closedir(dp);\n    return brk;\n}", "target": 1}
{"code": "webSocketsHasDataInBuffer(rfbClientPtr cl)\n{\n    ws_ctx_t *wsctx = (ws_ctx_t *)cl->wsctx;\n    if (wsctx && wsctx->readbuflen)\n      return TRUE;\n    return (cl->sslctx && rfbssl_pending(cl) > 0);\n}", "target": 1}
{"code": "static void http_req_handler(struct http_conn *conn,\n\t\t\t     const struct http_msg *msg, void *arg)\n{\n\tstruct mbuf *mb = mbuf_alloc(1024);\n\tint err = 0;\n\t(void)arg;\n\tinfo(\"restsrv: request %r %r%r from %J\\n\",\n\t     &msg->met, &msg->path, &msg->prm,\n\t     http_conn_peer(conn));\n\tif (0 == pl_strcasecmp(&msg->met, \"POST\") &&\n\t    0 == pl_strcasecmp(&msg->path, \"/create\")) {\n\t\thandle_post_create(conn, msg->mb, (size_t)msg->clen);\n\t}\n\telse if (0 == pl_strcasecmp(&msg->met, \"PUT\") &&\n\t\t 0 == pl_strcasecmp(&msg->path, \"/publish\")) {\n\t\thandle_put_publish(conn, msg, msg->mb, (size_t)msg->clen);\n\t}\n\telse if (0 == pl_strcasecmp(&msg->met, \"PUT\") &&\n\t\t 0 == pl_strcasecmp(&msg->path, \"/accept\")) {\n\t\thandle_put_accept(conn, msg, msg->mb, (size_t)msg->clen);\n\t}\n\telse if (0 == pl_strcasecmp(&msg->met, \"GET\") &&\n\t\t 0 == pl_strcasecmp(&msg->path, \"/publish\")) {\n\t\thandle_get_publish(conn, msg, msg->mb, (size_t)msg->clen);\n\t}\n\telse if (0 == pl_strcasecmp(&msg->met, \"GET\") &&\n\t\t 0 == pl_strcasecmp(&msg->path, \"/accept\")) {\n\t\thandle_get_accept(conn, msg, msg->mb, (size_t)msg->clen);\n\t}\n\telse {\n\t\twarning(\"no such resource\\n\");\n\t\terr = ENOENT;\n\t\tgoto out;\n\t}\n out:\n\tif (err) {\n\t\thttp_ereply(conn, 400, \"Bad Request\");\n\t\twarning(\"restsrv: response 400 Bad Request (%m)\\n\", err);\n\t\thttp_conn_close(conn);\n\t}\n\tmem_deref(mb);\n}", "target": 0}
{"code": "DSA_Signature_Operation::raw_sign(const uint8_t msg[], size_t msg_len,\n                                  RandomNumberGenerator& rng)\n   {\n   const BigInt& q = m_group.get_q();\n   BigInt i(msg, msg_len, q.bits());\n   while(i >= q)\n      i -= q;\n#if defined(BOTAN_HAS_RFC6979_GENERATOR)\n   BOTAN_UNUSED(rng);\n   const BigInt k = generate_rfc6979_nonce(m_x, q, i, m_rfc6979_hash);\n#else\n   const BigInt k = BigInt::random_integer(rng, 1, q);\n#endif\n   BigInt s = inverse_mod(k, q);\n   const BigInt r = m_mod_q.reduce(m_group.power_g_p(k));\n   s = m_mod_q.multiply(s, mul_add(m_x, r, i));\n   if(r.is_zero() || s.is_zero())\n      throw Internal_Error(\"Computed zero r/s during DSA signature\");\n   return BigInt::encode_fixed_length_int_pair(r, s, q.bytes());\n   }", "target": 1}
{"code": "static int ec2m_field_sanity(void)\n{\n    int ret = 0;\n    BN_CTX *ctx = BN_CTX_new();\n    BIGNUM *p, *a, *b;\n    EC_GROUP *group1 = NULL, *group2 = NULL, *group3 = NULL;\n    TEST_info(\"Testing GF2m hardening\\n\");\n    BN_CTX_start(ctx);\n    p = BN_CTX_get(ctx);\n    a = BN_CTX_get(ctx);\n    if (!TEST_ptr(b = BN_CTX_get(ctx))\n        || !TEST_true(BN_one(a))\n        || !TEST_true(BN_one(b)))\n        goto out;\n    if (!TEST_true(BN_set_word(p, 0xf2)))\n        goto out;\n    if (!TEST_ptr_null(group1 = EC_GROUP_new_curve_GF2m(p, a, b, ctx)))\n        TEST_error(\"Zero constant term accepted in GF2m polynomial\");\n    if (!TEST_true(BN_set_word(p, 0xf3)))\n        goto out;\n    if (!TEST_ptr_null(group2 = EC_GROUP_new_curve_GF2m(p, a, b, ctx)))\n        TEST_error(\"Hexanomial accepted as GF2m polynomial\");\n    if (!TEST_true(BN_set_word(p, 0x71))\n        || !TEST_true(BN_set_bit(p, OPENSSL_ECC_MAX_FIELD_BITS + 1)))\n        goto out;\n    if (!TEST_ptr_null(group3 = EC_GROUP_new_curve_GF2m(p, a, b, ctx)))\n        TEST_error(\"GF2m polynomial degree > %d accepted\",\n                   OPENSSL_ECC_MAX_FIELD_BITS);\n    ret = group1 == NULL && group2 == NULL && group3 == NULL;\n out:\n    EC_GROUP_free(group1);\n    EC_GROUP_free(group2);\n    EC_GROUP_free(group3);\n    BN_CTX_end(ctx);\n    BN_CTX_free(ctx);\n    return ret;\n}", "target": 0}
{"code": "    const std::unordered_map<std::string, std::string> &headers() const override\n    {\n        return headers_;\n    }", "target": 1}
{"code": "int nf_ct_frag6_gather(struct net *net, struct sk_buff *skb, u32 user)\n{\n\tstruct net_device *dev = skb->dev;\n\tint fhoff, nhoff, ret;\n\tstruct frag_hdr *fhdr;\n\tstruct frag_queue *fq;\n\tstruct ipv6hdr *hdr;\n\tu8 prevhdr;\n\tif (ipv6_hdr(skb)->payload_len == 0) {\n\t\tpr_debug(\"payload len = 0\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (find_prev_fhdr(skb, &prevhdr, &nhoff, &fhoff) < 0)\n\t\treturn -EINVAL;\n\tif (!pskb_may_pull(skb, fhoff + sizeof(*fhdr)))\n\t\treturn -ENOMEM;\n\tskb_set_transport_header(skb, fhoff);\n\thdr = ipv6_hdr(skb);\n\tfhdr = (struct frag_hdr *)skb_transport_header(skb);\n\tfq = fq_find(net, fhdr->identification, user, &hdr->saddr, &hdr->daddr,\n\t\t     skb->dev ? skb->dev->ifindex : 0, ip6_frag_ecn(hdr));\n\tif (fq == NULL) {\n\t\tpr_debug(\"Can't find and can't create new queue\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tspin_lock_bh(&fq->q.lock);\n\tif (nf_ct_frag6_queue(fq, skb, fhdr, nhoff) < 0) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\tret = -EINPROGRESS;\n\tif (fq->q.flags == (INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN) &&\n\t    fq->q.meat == fq->q.len &&\n\t    nf_ct_frag6_reasm(fq, skb, dev))\n\t\tret = 0;\nout_unlock:\n\tspin_unlock_bh(&fq->q.lock);\n\tinet_frag_put(&fq->q, &nf_frags);\n\treturn ret;\n}", "target": 1}
{"code": "bool DNP3_Base::AddToBuffer(Endpoint* endp, int target_len, const u_char** data, int* len)\n\t{\n\tif ( ! target_len )\n\t\treturn true;\n\tint to_copy = min(*len, target_len - endp->buffer_len);\n\tmemcpy(endp->buffer + endp->buffer_len, *data, to_copy);\n\t*data += to_copy;\n\t*len -= to_copy;\n\tendp->buffer_len += to_copy;\n\treturn endp->buffer_len == target_len;\n\t}", "target": 1}
{"code": "Status ImportNodes(ValueMapManager value_manager,\n                   const RepeatedPtrField<NodeDef>& nodes, OpBuilder& builder) {\n  Location unknown_loc = builder.getUnknownLoc();\n  MLIRContext* context = builder.getContext();\n  Type placeholder_ty = OpaqueTensorType::get(context);\n  Type control_ty = ControlType::get(context);\n  TFGraphDialect* tfgDialect =\n      cast<TFGraphDialect>(context->getLoadedDialect(\"tfg\"));\n  StringAttr device_attr = tfgDialect->getDeviceAttrIdentifier();\n  StringAttr name_attr = tfgDialect->getNameAttrIdentifier();\n  StringAttr fulltype_attr = tfgDialect->getFullTypeAttrIdentifier();\n  for (const NodeDef& node : nodes) {\n    DVLOG(1) << \"Processing node \" << node.name() << \"\\n\";\n    if (node.op().empty()) return InvalidArgument(\"empty op type\");\n    OperationState state(unknown_loc, absl::StrCat(\"tfg.\", node.op()));\n    for (const std::string& input : node.input())\n      state.operands.push_back(\n          value_manager.GetValueOrCreatePlaceholder(input));\n    state.types.push_back(placeholder_ty);\n    state.types.push_back(control_ty);\n    for (const auto& namedAttr : node.attr()) {\n      const std::string& name = namedAttr.first;\n      const AttrValue& tf_attr = namedAttr.second;\n      TF_ASSIGN_OR_RETURN(Attribute attr,\n                          ConvertAttributeValue(tf_attr, builder, tfgDialect));\n      state.addAttribute(name, attr);\n    }\n    if (!node.device().empty())\n      state.addAttribute(device_attr, StringAttr::get(context, node.device()));\n    if (!node.name().empty())\n      state.addAttribute(name_attr, StringAttr::get(context, node.name()));\n    if (node.has_experimental_type()) {\n      TF_ASSIGN_OR_RETURN(\n          tf_type::FullTypeAttr type,\n          ConvertAttribute(node.experimental_type(), builder, tfgDialect));\n      state.addAttribute(fulltype_attr, type);\n    }\n    Operation* op = builder.create(state);\n    StringRef node_name = node.name();\n    {\n      size_t colon_sep = node_name.find_first_of(':');\n      if (colon_sep != StringRef::npos)\n        node_name = node_name.take_front(colon_sep);\n    }\n    TF_RETURN_IF_ERROR(value_manager.DefineOperation(op, node_name));\n  }\n  for (Operation& op : *builder.getInsertionBlock()) {\n    if (op.getName().getStringRef() == \"tfg.__mlir_placeholder\") {\n      return InvalidArgument(absl::StrCat(\n          \"Couldn't import graph: placeholder left \",\n          op.getAttrOfType<StringAttr>(name_attr).getValue().str()));\n    }\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "daemon_AuthUserPwd(char *username, char *password, char *errbuf)\n{\n#ifdef _WIN32\n\tHANDLE Token;\n\tif (LogonUser(username, \".\", password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &Token) == 0)\n\t{\n\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"LogonUser() failed\");\n\t\treturn -1;\n\t}\n\tif (ImpersonateLoggedOnUser(Token) == 0)\n\t{\n\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"ImpersonateLoggedOnUser() failed\");\n\t\tCloseHandle(Token);\n\t\treturn -1;\n\t}\n\tCloseHandle(Token);\n\treturn 0;\n#else\n\tstruct passwd *user;\n\tchar *user_password;\n#ifdef HAVE_GETSPNAM\n\tstruct spwd *usersp;\n#endif\n\tif ((user = getpwnam(username)) == NULL)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");\n\t\treturn -1;\n\t}\n#ifdef HAVE_GETSPNAM\n\tif ((usersp = getspnam(username)) == NULL)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");\n\t\treturn -1;\n\t}\n\tuser_password = usersp->sp_pwdp;\n#else\n\tuser_password = user->pw_passwd;\n#endif\n\tif (strcmp(user_password, (char *) crypt(password, user_password)) != 0)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");\n\t\treturn -1;\n\t}\n\tif (setuid(user->pw_uid))\n\t{\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"setuid\");\n\t\treturn -1;\n\t}\n\treturn 0;\n#endif\n}", "target": 1}
{"code": "void jbd2_journal_wait_updates(journal_t *journal)\n{\n\ttransaction_t *commit_transaction = journal->j_running_transaction;\n\tif (!commit_transaction)\n\t\treturn;\n\tspin_lock(&commit_transaction->t_handle_lock);\n\twhile (atomic_read(&commit_transaction->t_updates)) {\n\t\tDEFINE_WAIT(wait);\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (atomic_read(&commit_transaction->t_updates)) {\n\t\t\tspin_unlock(&commit_transaction->t_handle_lock);\n\t\t\twrite_unlock(&journal->j_state_lock);\n\t\t\tschedule();\n\t\t\twrite_lock(&journal->j_state_lock);\n\t\t\tspin_lock(&commit_transaction->t_handle_lock);\n\t\t}\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t}\n\tspin_unlock(&commit_transaction->t_handle_lock);\n}", "target": 1}
{"code": "void traverse_commit_list(struct rev_info *revs,\n\t\t\t  show_commit_fn show_commit,\n\t\t\t  show_object_fn show_object,\n\t\t\t  void *data)\n{\n\tint i;\n\tstruct commit *commit;\n\tstruct strbuf base;\n\tstrbuf_init(&base, PATH_MAX);\n\twhile ((commit = get_revision(revs)) != NULL) {\n\t\tif (commit->tree)\n\t\t\tadd_pending_tree(revs, commit->tree);\n\t\tshow_commit(commit, data);\n\t}\n\tfor (i = 0; i < revs->pending.nr; i++) {\n\t\tstruct object_array_entry *pending = revs->pending.objects + i;\n\t\tstruct object *obj = pending->item;\n\t\tconst char *name = pending->name;\n\t\tconst char *path = pending->path;\n\t\tif (obj->flags & (UNINTERESTING | SEEN))\n\t\t\tcontinue;\n\t\tif (obj->type == OBJ_TAG) {\n\t\t\tobj->flags |= SEEN;\n\t\t\tshow_object(obj, NULL, name, data);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!path)\n\t\t\tpath = \"\";\n\t\tif (obj->type == OBJ_TREE) {\n\t\t\tprocess_tree(revs, (struct tree *)obj, show_object,\n\t\t\t\t     &base, path, data);\n\t\t\tcontinue;\n\t\t}\n\t\tif (obj->type == OBJ_BLOB) {\n\t\t\tprocess_blob(revs, (struct blob *)obj, show_object,\n\t\t\t\t     NULL, path, data);\n\t\t\tcontinue;\n\t\t}\n\t\tdie(\"unknown pending object %s (%s)\",\n\t\t    oid_to_hex(&obj->oid), name);\n\t}\n\tobject_array_clear(&revs->pending);\n\tstrbuf_release(&base);\n}", "target": 1}
{"code": "TfLiteStatus SimpleStatefulOp::Prepare(TfLiteContext* context,\n                                       TfLiteNode* node) {\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n  const TfLiteTensor* input = tflite::GetInput(context, node, kInputTensor);\n  if (input->type != kTfLiteUInt8) return kTfLiteError;\n  if (NumElements(input->dims) == 0) return kTfLiteError;\n  TF_LITE_ENSURE_STATUS(context->RequestScratchBufferInArena(\n      context, sizeof(uint8_t) * NumElements(input->dims),\n      &data->sorting_buffer));\n  data->invoke_count = reinterpret_cast<int*>(\n      context->AllocatePersistentBuffer(context, sizeof(int)));\n  *data->invoke_count = 0;\n  return kTfLiteOk;\n}", "target": 1}
{"code": "storageDriverAutostartCallback(virStoragePoolObj *obj,\n                               const void *opaque G_GNUC_UNUSED)\n{\n    virStoragePoolDef *def = virStoragePoolObjGetDef(obj);\n    virStorageBackend *backend;\n    bool started = false;\n    if (!(backend = virStorageBackendForType(def->type)))\n        return;\n    if (virStoragePoolObjIsAutostart(obj) &&\n        !virStoragePoolObjIsActive(obj)) {\n        virStoragePoolObjSetStarting(obj, true);\n        if (backend->startPool &&\n            backend->startPool(obj) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to autostart storage pool '%s': %s\"),\n                           def->name, virGetLastErrorMessage());\n            goto cleanup;\n        }\n        started = true;\n    }\n    if (started) {\n        g_autofree char *stateFile = NULL;\n        stateFile = virFileBuildPath(driver->stateDir, def->name, \".xml\");\n        if (!stateFile ||\n            virStoragePoolSaveState(stateFile, def) < 0 ||\n            storagePoolRefreshImpl(backend, obj, stateFile) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to autostart storage pool '%s': %s\"),\n                           def->name, virGetLastErrorMessage());\n        } else {\n            virStoragePoolObjSetActive(obj, true);\n        }\n    }\n cleanup:\n    if (virStoragePoolObjIsStarting(obj)) {\n        if (!virStoragePoolObjIsActive(obj))\n            virStoragePoolUpdateInactive(obj);\n        virStoragePoolObjSetStarting(obj, false);\n    }\n}", "target": 0}
{"code": "void InputMethodBase::OnFocus() {\n  DCHECK(!system_toplevel_window_focused_);\n  system_toplevel_window_focused_ = true;\n}", "target": 0}
{"code": "TfLiteStatus CalculateArithmeticOpData(TfLiteContext* context, TfLiteNode* node,\n                                       OpData* data) {\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  if (input->type == kTfLiteInt8) {\n    TF_LITE_ENSURE_EQ(context, output->params.zero_point,\n                      std::numeric_limits<int8_t>::min());\n    static constexpr int kInputIntegerBits = 4;\n    const double input_real_multiplier =\n        static_cast<double>(input->params.scale) *\n        static_cast<double>(1 << (31 - kInputIntegerBits));\n    data->input_zero_point = input->params.zero_point;\n    const double q = std::frexp(input_real_multiplier, &data->input_left_shift);\n    data->input_multiplier = static_cast<int32_t>(TfLiteRound(q * (1ll << 31)));\n    data->input_range_radius =\n        CalculateInputRadius(kInputIntegerBits, data->input_left_shift, 31);\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "void PDPSimple::notifyAboveRemoteEndpoints(\n        const ParticipantProxyData& pdata)\n{\n    if (mp_EDP != nullptr)\n    {\n        mp_EDP->assignRemoteEndpoints(pdata);\n    }\n    if (mp_builtin->mp_WLP != nullptr)\n    {\n        mp_builtin->mp_WLP->assignRemoteEndpoints(pdata);\n    }\n    if (mp_builtin->tlm_ != nullptr)\n    {\n        mp_builtin->tlm_->assign_remote_endpoints(pdata);\n    }\n}", "target": 1}
{"code": "  cert_chain_t::clear() {\n    _certs.clear();\n  }", "target": 0}
{"code": "int pdf_load_xrefs(FILE *fp, pdf_t *pdf)\n{\n    int  i, ver, is_linear;\n    long pos, pos_count;\n    char x, *c, buf[256];\n    c = NULL;\n    pdf->n_xrefs = 0;\n    fseek(fp, 0, SEEK_SET);\n    while (get_next_eof(fp) >= 0)\n      ++pdf->n_xrefs;\n    if (!pdf->n_xrefs)\n      return 0;\n    fseek(fp, 0, SEEK_SET);\n    pdf->xrefs = calloc(1, sizeof(xref_t) * pdf->n_xrefs);\n    ver = 1;\n    for (i=0; i<pdf->n_xrefs; i++)\n    {\n        if ((pos = get_next_eof(fp)) < 0)\n          break;\n        pdf->xrefs[i].version = ver++;\n        pos_count = 0;\n        while (SAFE_F(fp, ((x = fgetc(fp)) != 'f')))\n          fseek(fp, pos - (++pos_count), SEEK_SET);\n        if (pos_count >= sizeof(buf)) {\n          ERR(\"Failed to locate the startxref token. \"\n              \"This might be a corrupt PDF.\\n\");\n          return -1;\n        }\n        memset(buf, 0, sizeof(buf));\n        SAFE_E(fread(buf, 1, pos_count, fp), pos_count,\n               \"Failed to read startxref.\\n\");\n        c = buf;\n        while (*c == ' ' || *c == '\\n' || *c == '\\r')\n          ++c;\n        pdf->xrefs[i].start = atol(c);\n        if (pdf->xrefs[i].start == 0)\n          get_xref_linear_skipped(fp, &pdf->xrefs[i]);\n        else\n        {\n            pos = ftell(fp);\n            fseek(fp, pdf->xrefs[i].start, SEEK_SET);\n            pdf->xrefs[i].end = get_next_eof(fp);\n            fseek(fp, pos, SEEK_SET);\n        }\n        if (!is_valid_xref(fp, pdf, &pdf->xrefs[i]))\n        {\n            is_linear = pdf->xrefs[i].is_linear;\n            memset(&pdf->xrefs[i], 0, sizeof(xref_t));\n            pdf->xrefs[i].is_linear = is_linear;\n            rewind(fp);\n            get_next_eof(fp);\n            continue;\n        }\n        load_xref_entries(fp, &pdf->xrefs[i]);\n    }\n    if (pdf->xrefs[0].is_linear)\n      resolve_linearized_pdf(pdf);\n    load_creator(fp, pdf);\n    return pdf->n_xrefs;\n}", "target": 1}
{"code": "mptctl_eventquery (unsigned long arg)\n{\n\tstruct mpt_ioctl_eventquery __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_eventquery\t karg;\n\tMPT_ADAPTER *ioc;\n\tint iocnum;\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_eventquery))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_eventquery - \"\n\t\t\t\"Unable to read in mpt_ioctl_eventquery struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_eventquery() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_eventquery called.\\n\",\n\t    ioc->name));\n\tkarg.eventEntries = MPTCTL_EVENT_LOG_SIZE;\n\tkarg.eventTypes = ioc->eventTypes;\n\tif (copy_to_user((char __user *)arg, &karg, sizeof(struct mpt_ioctl_eventquery))) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_eventquery - \"\n\t\t\t\"Unable to write out mpt_ioctl_eventquery struct @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "apr_byte_t oidc_cache_set(request_rec *r, const char *section, const char *key,\n\t\tconst char *value, apr_time_t expiry) {\n\toidc_cfg *cfg = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\tint encrypted = oidc_cfg_cache_encrypt(r);\n\tchar *encoded = NULL;\n\tapr_byte_t rc = FALSE;\n\tchar *msg = NULL;\n\toidc_debug(r,\n\t\t\t\"enter: %s (section=%s, len=%d, encrypt=%d, ttl(s)=%\" APR_TIME_T_FMT \", type=%s)\",\n\t\t\tkey, section, value ? (int )strlen(value) : 0, encrypted,\n\t\t\t\t\tapr_time_sec(expiry - apr_time_now()), cfg->cache->name);\n\tif (encrypted == 1) {\n\t\tkey = oidc_cache_get_hashed_key(r, cfg->crypto_passphrase, key);\n\t\tif (key == NULL)\n\t\t\tgoto out;\n\t\tif (value != NULL) {\n\t\t\tif (oidc_cache_crypto_encrypt(r, value,\n\t\t\t\t\toidc_cache_hash_passphrase(r, cfg->crypto_passphrase),\n\t\t\t\t\t&encoded) <= 0)\n\t\t\t\tgoto out;\n\t\t\tvalue = encoded;\n\t\t}\n\t}\n\trc = cfg->cache->set(r, section, key, value, expiry);\nout:\n\tmsg = apr_psprintf(r->pool, \"%d bytes in %s cache backend for %skey %s\",\n\t\t\t(value ? (int) strlen(value) : 0),\n\t\t\t(cfg->cache->name ? cfg->cache->name : \"\"),\n\t\t\t(encrypted ? \"encrypted \" : \"\"), (key ? key : \"\"));\n\tif (rc == TRUE)\n\t\toidc_debug(r, \"successfully stored %s\", msg);\n\telse\n\t\toidc_warn(r, \"could NOT store %s\", msg);\n\treturn rc;\n}", "target": 1}
{"code": "static int filter_frame(AVFilterLink *inlink, AVFrame *in)\n{\n    PadContext *s = inlink->dst->priv;\n    AVFrame *out;\n    int needs_copy = frame_needs_copy(s, in);\n    if (needs_copy) {\n        av_log(inlink->dst, AV_LOG_DEBUG, \"Direct padding impossible allocating new frame\\n\");\n        out = ff_get_video_buffer(inlink->dst->outputs[0],\n                                  FFMAX(inlink->w, s->w),\n                                  FFMAX(inlink->h, s->h));\n        if (!out) {\n            av_frame_free(&in);\n            return AVERROR(ENOMEM);\n        }\n        av_frame_copy_props(out, in);\n    } else {\n        int i;\n        out = in;\n        for (i = 0; i < 4 && out->data[i]; i++) {\n            int hsub = s->draw.hsub[i];\n            int vsub = s->draw.vsub[i];\n            out->data[i] -= (s->x >> hsub) * s->draw.pixelstep[i] +\n                            (s->y >> vsub) * out->linesize[i];\n        }\n    }\n    if (s->y) {\n        ff_fill_rectangle(&s->draw, &s->color,\n                          out->data, out->linesize,\n                          0, 0, s->w, s->y);\n    }\n    if (s->h > s->y + s->in_h) {\n        ff_fill_rectangle(&s->draw, &s->color,\n                          out->data, out->linesize,\n                          0, s->y + s->in_h, s->w, s->h - s->y - s->in_h);\n    }\n    ff_fill_rectangle(&s->draw, &s->color, out->data, out->linesize,\n                      0, s->y, s->x, in->height);\n    if (needs_copy) {\n        ff_copy_rectangle2(&s->draw,\n                          out->data, out->linesize, in->data, in->linesize,\n                          s->x, s->y, 0, 0, in->width, in->height);\n    }\n    ff_fill_rectangle(&s->draw, &s->color, out->data, out->linesize,\n                      s->x + s->in_w, s->y, s->w - s->x - s->in_w,\n                      in->height);\n    out->width  = s->w;\n    out->height = s->h;\n    if (in != out)\n        av_frame_free(&in);\n    return ff_filter_frame(inlink->dst->outputs[0], out);\n}", "target": 1}
{"code": "LibRaw_byte_buffer *LibRaw_buffer_datastream::make_byte_buffer(unsigned int sz)\n{\n  if(INT64(sz)>size())\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n    LibRaw_byte_buffer *ret = new LibRaw_byte_buffer(0);\n    if(!ret) \n      throw LIBRAW_EXCEPTION_ALLOC;\n    if(streampos + sz > streamsize)\n        sz = streamsize - streampos;\n    ret->set_buffer(buf+streampos,sz);\n    return ret;\n}", "target": 0}
{"code": "_archive_write_data(struct archive *_a, const void *buff, size_t s)\n{\n\tstruct archive_write *a = (struct archive_write *)_a;\n\tconst size_t max_write = INT_MAX;\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n\t    ARCHIVE_STATE_DATA, \"archive_write_data\");\n\tif (s > max_write)\n\t\ts = max_write;\n\tarchive_clear_error(&a->archive);\n\treturn ((a->format_write_data)(a, buff, s));\n}", "target": 0}
{"code": "bool EditorClientBlackBerry::shouldApplyStyle(StylePropertySet*, Range*)\n{\n    notImplemented();\n    return true;\n}", "target": 0}
{"code": "libxlDomainObjPrivateAlloc(void *opaque G_GNUC_UNUSED)\n{\n    libxlDomainObjPrivate *priv;\n    priv = g_new0(libxlDomainObjPrivate, 1);\n    if (!(priv->devs = virChrdevAlloc())) {\n        g_free(priv);\n        return NULL;\n    }\n    if (libxlDomainObjInitJob(priv) < 0) {\n        virChrdevFree(priv->devs);\n        g_free(priv);\n        return NULL;\n    }\n    return priv;\n}", "target": 0}
{"code": "int enc_untrusted_inet_pton(int af, const char *src, void *dst) {\n  if (!src || !dst) {\n    return 0;\n  }\n  MessageWriter input;\n  input.Push<int>(TokLinuxAfFamily(af));\n  input.PushByReference(Extent{\n      src, std::min(strlen(src) + 1, static_cast<size_t>(INET6_ADDRSTRLEN))});\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kInetPtonHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_inet_pton\", 3);\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return -1;\n  }\n  auto klinux_addr_buffer = output.next();\n  size_t max_size = 0;\n  if (af == AF_INET) {\n    if (klinux_addr_buffer.size() != sizeof(klinux_in_addr)) {\n      ::asylo::primitives::TrustedPrimitives::BestEffortAbort(\n          \"enc_untrusted_inet_pton: unexpected output size\");\n    }\n    max_size = sizeof(struct in_addr);\n  } else if (af == AF_INET6) {\n    if (klinux_addr_buffer.size() != sizeof(klinux_in6_addr)) {\n      ::asylo::primitives::TrustedPrimitives::BestEffortAbort(\n          \"enc_untrusted_inet_pton: unexpected output size\");\n    }\n    max_size = sizeof(struct in6_addr);\n  }\n  memcpy(dst, klinux_addr_buffer.data(),\n         std::min(klinux_addr_buffer.size(), max_size));\n  return result;\n}", "target": 0}
{"code": "static void _out_result(conn_t out, nad_t nad) {\n    int attr;\n    jid_t from, to;\n    char *rkey;\n    int rkeylen;\n    attr = nad_find_attr(nad, 0, -1, \"from\", NULL);\n    if(attr < 0 || (from = jid_new(NAD_AVAL(nad, attr), NAD_AVAL_L(nad, attr))) == NULL) {\n        log_debug(ZONE, \"missing or invalid from on db result packet\");\n        nad_free(nad);\n        return;\n    }\n    attr = nad_find_attr(nad, 0, -1, \"to\", NULL);\n    if(attr < 0 || (to = jid_new(NAD_AVAL(nad, attr), NAD_AVAL_L(nad, attr))) == NULL) {\n        log_debug(ZONE, \"missing or invalid to on db result packet\");\n        jid_free(from);\n        nad_free(nad);\n        return;\n    }\n    rkey = s2s_route_key(NULL, to->domain, from->domain);\n    rkeylen = strlen(rkey);\n    if(nad_find_attr(nad, 0, -1, \"type\", \"valid\") >= 0) {\n        log_write(out->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] outgoing route '%s' is now valid%s%s\", out->fd->fd, out->ip, out->port, rkey, (out->s->flags & SX_SSL_WRAPPER) ? \", TLS negotiated\" : \"\", out->s->compressed ? \", ZLIB compression enabled\" : \"\");\n        xhash_put(out->states, pstrdup(xhash_pool(out->states), rkey), (void *) conn_VALID);    \n        log_debug(ZONE, \"%s valid, flushing queue\", rkey);\n        out_flush_route_queue(out->s2s, rkey, rkeylen);\n        free(rkey);\n        jid_free(from);\n        jid_free(to);\n        nad_free(nad);\n        return;\n    }\n    log_write(out->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] outgoing route '%s' is now invalid\", out->fd->fd, out->ip, out->port, rkey);\n    log_write(out->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] closing connection\", out->fd->fd, out->ip, out->port);\n    sx_error(out->s, stream_err_INVALID_ID, \"dialback negotiation failed\");\n    sx_close(out->s);\n    out_bounce_route_queue(out->s2s, rkey, rkeylen, stanza_err_SERVICE_UNAVAILABLE);\n    free(rkey);\n    jid_free(from);\n    jid_free(to);\n    nad_free(nad);\n}", "target": 1}
{"code": "static void draw_fill_color_rgb( wmfAPI* API, const wmfRGB* rgb )\n{\n  PixelWand\n    *fill_color;\n  fill_color=NewPixelWand();\n  PixelSetRedQuantum(fill_color,ScaleCharToQuantum(rgb->r));\n  PixelSetGreenQuantum(fill_color,ScaleCharToQuantum(rgb->g));\n  PixelSetBlueQuantum(fill_color,ScaleCharToQuantum(rgb->b));\n  PixelSetAlphaQuantum(fill_color,OpaqueAlpha);\n  DrawSetFillColor(WmfDrawingWand,fill_color);\n  fill_color=DestroyPixelWand(fill_color);\n}", "target": 0}
{"code": "ble_hs_conn_timer(void)\n{\n#if MYNEWT_VAL(BLE_L2CAP_RX_FRAG_TIMEOUT) == 0 && \\\n    BLE_HS_ATT_SVR_QUEUED_WRITE_TMO == 0\n    return BLE_HS_FOREVER;\n#endif\n    struct ble_hs_conn *conn;\n    ble_npl_time_t now;\n    int32_t next_exp_in;\n    int32_t time_diff;\n    uint16_t conn_handle;\n    for (;;) {\n        conn_handle = BLE_HS_CONN_HANDLE_NONE;\n        next_exp_in = BLE_HS_FOREVER;\n        now = ble_npl_time_get();\n        ble_hs_lock();\n        SLIST_FOREACH(conn, &ble_hs_conns, bhc_next) {\n            if (!(conn->bhc_flags & BLE_HS_CONN_F_TERMINATING)) {\n#if MYNEWT_VAL(BLE_L2CAP_RX_FRAG_TIMEOUT) != 0\n                if (conn->bhc_rx_chan != NULL) {\n                    time_diff = conn->bhc_rx_timeout - now;\n                    if (time_diff <= 0) {\n                        conn_handle = conn->bhc_handle;\n                        break;\n                    }\n                    if (time_diff < next_exp_in) {\n                        next_exp_in = time_diff;\n                    }\n                }\n#endif\n#if BLE_HS_ATT_SVR_QUEUED_WRITE_TMO\n                time_diff = ble_att_svr_ticks_until_tmo(&conn->bhc_att_svr, now);\n                if (time_diff <= 0) {\n                    conn_handle = conn->bhc_handle;\n                    break;\n                }\n                if (time_diff < next_exp_in) {\n                    next_exp_in = time_diff;\n                }\n#endif\n            }\n        }\n        ble_hs_unlock();\n        if (conn_handle != BLE_HS_CONN_HANDLE_NONE) {\n            ble_gap_terminate(conn_handle, BLE_ERR_REM_USER_CONN_TERM);\n            continue;\n        }\n        return next_exp_in;\n    }\n}", "target": 1}
{"code": "INST_HANDLER (lds) {\t\n\tif (len < 4) {\n\t\treturn;\n\t}\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tint k = (buf[3] << 8) | buf[2];\n\top->ptr = k;\n\t__generic_ld_st (op, \"ram\", 0, 1, 0, k, 0);\n\tESIL_A (\"r%d,=,\", d);\n}", "target": 0}
{"code": "static void new_huffman_tree(x3f_hufftree_t *HTP, int bits)\n{\n  int leaves = 1 << bits;\n  HTP->free_node_index = 0;\n  HTP->total_node_index = HUF_TREE_MAX_NODES(leaves);\n  HTP->nodes = (x3f_huffnode_t *)calloc(1, HUF_TREE_MAX_NODES(leaves) *\n                                               sizeof(x3f_huffnode_t));\n}", "target": 0}
{"code": "static pj_status_t STATUS_FROM_SSL_ERR(char *action, pj_ssl_sock_t *ssock,\n\t\t\t\t       unsigned long err)\n{\n    int level = 0;\n    int len = 0; \n    ERROR_LOG(\"STATUS_FROM_SSL_ERR\", err, ssock);\n    level++;\n    if (err == SSL_ERROR_SSL) {\n\terr = ERR_get_error();\n\tERROR_LOG(\"STATUS_FROM_SSL_ERR\", err, ssock);\n    }\n    ssock->last_err = err;\n    return GET_STATUS_FROM_SSL_ERR(err);\n}", "target": 1}
{"code": "void comps_objrtree_unite(COMPS_ObjRTree *rt1, COMPS_ObjRTree *rt2) {\n    COMPS_HSList *tmplist, *tmp_subnodes;\n    COMPS_HSListItem *it;\n    struct Pair {\n        COMPS_HSList * subnodes;\n        char * key;\n        char added;\n    } *pair, *parent_pair;\n    pair = malloc(sizeof(struct Pair));\n    pair->subnodes = rt2->subnodes;\n    pair->key = NULL;\n    tmplist = comps_hslist_create();\n    comps_hslist_init(tmplist, NULL, NULL, &free);\n    comps_hslist_append(tmplist, pair, 0);\n    while (tmplist->first != NULL) {\n        it = tmplist->first;\n        comps_hslist_remove(tmplist, tmplist->first);\n        tmp_subnodes = ((struct Pair*)it->data)->subnodes;\n        parent_pair = (struct Pair*) it->data;\n        free(it);\n        for (it = tmp_subnodes->first; it != NULL; it=it->next) {\n            pair = malloc(sizeof(struct Pair));\n            pair->subnodes = ((COMPS_ObjRTreeData*)it->data)->subnodes;\n            if (parent_pair->key != NULL) {\n                pair->key = malloc(sizeof(char)\n                               * (strlen(((COMPS_ObjRTreeData*)it->data)->key)\n                               + strlen(parent_pair->key) + 1));\n                memcpy(pair->key, parent_pair->key,\n                       sizeof(char) * strlen(parent_pair->key));\n                memcpy(pair->key + strlen(parent_pair->key),\n                       ((COMPS_ObjRTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_ObjRTreeData*)it->data)->key)+1));\n            } else {\n                pair->key = malloc(sizeof(char)*\n                                (strlen(((COMPS_ObjRTreeData*)it->data)->key) +1));\n                memcpy(pair->key, ((COMPS_ObjRTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_ObjRTreeData*)it->data)->key)+1));\n            }\n            if (((COMPS_ObjRTreeData*)it->data)->data != NULL) {\n                    comps_objrtree_set(rt1, pair->key,\n                                      (((COMPS_ObjRTreeData*)it->data)->data));\n            }\n            if (((COMPS_ObjRTreeData*)it->data)->subnodes->first) {\n                comps_hslist_append(tmplist, pair, 0);\n            } else {\n                free(pair->key);\n                free(pair);\n            }\n        }\n        free(parent_pair->key);\n        free(parent_pair);\n    }\n    comps_hslist_destroy(&tmplist);\n}", "target": 1}
{"code": "static void save_client_addr(struct ip_addr *client_ip, uint8_t *hwaddr)\n{\n\tuint8_t d = (uint8_t)ip4_addr4(client_ip);\n\txSemaphoreTake(dhcps_ip_table_semaphore, portMAX_DELAY);\n\tmemcpy(ip_table.client_mac[d], hwaddr, 6); \n#if (debug_dhcps)\t\n\tprintf(\"\\r\\n%s: ip %d.%d.%d.%d, hwaddr %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x\\n\", __func__,\n\t\tip4_addr1(client_ip), ip4_addr2(client_ip), ip4_addr3(client_ip), ip4_addr4(client_ip),\n\t\thwaddr[0], hwaddr[1], hwaddr[2], hwaddr[3], hwaddr[4], hwaddr[5]);\n#endif\t\n\txSemaphoreGive(dhcps_ip_table_semaphore);\n}", "target": 1}
{"code": "static void nfs4_close_done(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_closedata *calldata = data;\n\tstruct nfs4_state *state = calldata->state;\n\tstruct nfs_server *server = NFS_SERVER(calldata->inode);\n\tif (RPC_ASSASSINATED(task))\n\t\treturn;\n\tswitch (task->tk_status) {\n\t\tcase 0:\n\t\t\tnfs_set_open_stateid(state, &calldata->res.stateid, 0);\n\t\t\trenew_lease(server, calldata->timestamp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\tcase -NFS4ERR_OLD_STATEID:\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tif (calldata->arg.open_flags == 0)\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (nfs4_async_handle_error(task, server, state) == -EAGAIN) {\n\t\t\t\trpc_restart_call(task);\n\t\t\t\treturn;\n\t\t\t}\n\t}\n\tnfs_refresh_inode(calldata->inode, calldata->res.fattr);\n}", "target": 1}
{"code": "      DSA_Signature_Operation(const DSA_PrivateKey& dsa, const std::string& emsa) :\n         PK_Ops::Signature_with_EMSA(emsa),\n         m_group(dsa.get_group()),\n         m_x(dsa.get_x()),\n         m_mod_q(dsa.group_q())\n         {\n#if defined(BOTAN_HAS_RFC6979_GENERATOR)\n         m_rfc6979_hash = hash_for_emsa(emsa);\n#endif\n         }", "target": 1}
{"code": "socket_accept(const int sock)\n{\n        struct sockaddr_storage addrin;\n        socklen_t addrinlen = sizeof(addrin);\n        int net;\n        net = accept(sock, (struct sockaddr *) &addrin, &addrinlen);\n        if (net < 0) {\n                err_nonfatal(\"Failed to accept socket connection: %m\");\n        }\n        return net;\n}", "target": 0}
{"code": "static void dhcps_send_offer(struct pbuf *packet_buffer)\n{\n\tuint8_t temp_ip = 0;\n\tdhcp_message_repository = (struct dhcp_msg *)packet_buffer->payload;\t\n#if (!IS_USE_FIXED_IP) \t\n\ttemp_ip = check_client_request_ip(&client_request_ip, client_addr);\n\tif(temp_ip == 0)\n\t\ttemp_ip = search_next_ip();\n#if (debug_dhcps)\t\n\tprintf(\"\\r\\n temp_ip = %d\",temp_ip);\n#endif\t\n\tif (temp_ip == 0) {\n#if 0\t\n\t  \tmemset(&ip_table, 0, sizeof(struct table));\n\t\tmark_ip_in_table((uint8_t)ip4_addr4(&dhcps_local_address));\n\t\tprintf(\"\\r\\n reset ip table!!\\r\\n\");\t\n#endif\t\n\t\tprintf(\"\\r\\n No useable ip!!!!\\r\\n\");\n\t}\n\tprintf(\"\\n\\r[%d]DHCP assign ip = %d.%d.%d.%d\\n\", xTaskGetTickCount(), ip4_addr1(&dhcps_network_id),ip4_addr2(&dhcps_network_id),ip4_addr3(&dhcps_network_id),temp_ip);\n\tIP4_ADDR(&dhcps_allocated_client_address, (ip4_addr1(&dhcps_network_id)),\n\t\t\tip4_addr2(&dhcps_network_id), ip4_addr3(&dhcps_network_id), temp_ip);\n#endif   \n\tdhcps_initialize_message(dhcp_message_repository);\n\tadd_offer_options(add_msg_type(&dhcp_message_repository->options[4],\n\t\t\tDHCP_MESSAGE_TYPE_OFFER));\n\tudp_sendto_if(dhcps_pcb, packet_buffer,\n\t\t\t&dhcps_send_broadcast_address, DHCP_CLIENT_PORT, dhcps_netif);\n}", "target": 1}
{"code": "static inline Quantum ScaleLongLongToQuantum(const MagickSizeType value)\n{\n#if !defined(MAGICKCORE_HDRI_SUPPORT)\n  return((Quantum) ((value)/MagickULLConstant(281479271743489)));\n#else\n  return((Quantum) (value/281479271743489.0));\n#endif\n}", "target": 0}
{"code": "static int vhost_vdpa_open(struct inode *inode, struct file *filep)\n{\n\tstruct vhost_vdpa *v;\n\tstruct vhost_dev *dev;\n\tstruct vhost_virtqueue **vqs;\n\tint nvqs, i, r, opened;\n\tv = container_of(inode->i_cdev, struct vhost_vdpa, cdev);\n\topened = atomic_cmpxchg(&v->opened, 0, 1);\n\tif (opened)\n\t\treturn -EBUSY;\n\tnvqs = v->nvqs;\n\tr = vhost_vdpa_reset(v);\n\tif (r)\n\t\tgoto err;\n\tvqs = kmalloc_array(nvqs, sizeof(*vqs), GFP_KERNEL);\n\tif (!vqs) {\n\t\tr = -ENOMEM;\n\t\tgoto err;\n\t}\n\tdev = &v->vdev;\n\tfor (i = 0; i < nvqs; i++) {\n\t\tvqs[i] = &v->vqs[i];\n\t\tvqs[i]->handle_kick = handle_vq_kick;\n\t}\n\tvhost_dev_init(dev, vqs, nvqs, 0, 0, 0, false,\n\t\t       vhost_vdpa_process_iotlb_msg);\n\tdev->iotlb = vhost_iotlb_alloc(0, 0);\n\tif (!dev->iotlb) {\n\t\tr = -ENOMEM;\n\t\tgoto err_init_iotlb;\n\t}\n\tr = vhost_vdpa_alloc_domain(v);\n\tif (r)\n\t\tgoto err_init_iotlb;\n\tvhost_vdpa_set_iova_range(v);\n\tfilep->private_data = v;\n\treturn 0;\nerr_init_iotlb:\n\tvhost_dev_cleanup(&v->vdev);\n\tkfree(vqs);\nerr:\n\tatomic_dec(&v->opened);\n\treturn r;\n}", "target": 0}
{"code": "print_attr_string(netdissect_options *ndo,\n                  register const u_char *data, u_int length, u_short attr_code)\n{\n   register u_int i;\n   ND_TCHECK2(data[0],length);\n   switch(attr_code)\n   {\n      case TUNNEL_PASS:\n           if (length < 3)\n           {\n              ND_PRINT((ndo, \"%s\", tstr));\n              return;\n           }\n           if (*data && (*data <=0x1F) )\n              ND_PRINT((ndo, \"Tag[%u] \", *data));\n           else\n              ND_PRINT((ndo, \"Tag[Unused] \"));\n           data++;\n           length--;\n           ND_PRINT((ndo, \"Salt %u \", EXTRACT_16BITS(data)));\n           data+=2;\n           length-=2;\n        break;\n      case TUNNEL_CLIENT_END:\n      case TUNNEL_SERVER_END:\n      case TUNNEL_PRIV_GROUP:\n      case TUNNEL_ASSIGN_ID:\n      case TUNNEL_CLIENT_AUTH:\n      case TUNNEL_SERVER_AUTH:\n           if (*data <= 0x1F)\n           {\n              if (length < 1)\n              {\n                 ND_PRINT((ndo, \"%s\", tstr));\n                 return;\n              }\n              if (*data)\n                ND_PRINT((ndo, \"Tag[%u] \", *data));\n              else\n                ND_PRINT((ndo, \"Tag[Unused] \"));\n              data++;\n              length--;\n           }\n        break;\n      case EGRESS_VLAN_NAME:\n           ND_PRINT((ndo, \"%s (0x%02x) \",\n                  tok2str(rfc4675_tagged,\"Unknown tag\",*data),\n                  *data));\n           data++;\n           length--;\n        break;\n   }\n   for (i=0; *data && i < length ; i++, data++)\n       ND_PRINT((ndo, \"%c\", (*data < 32 || *data > 126) ? '.' : *data));\n   return;\n   trunc:\n      ND_PRINT((ndo, \"%s\", tstr));\n}", "target": 1}
{"code": "lyd_new_output_anydata(struct lyd_node *parent, const struct lys_module *module, const char *name,\n                       void *value, LYD_ANYDATA_VALUETYPE value_type)\n{\n    const struct lys_node *siblings, *snode;\n    if ((!parent && !module) || !name) {\n        LOGARG;\n        return NULL;\n    }\n    siblings = lyd_new_find_schema(parent, module, 1);\n    if (!siblings) {\n        LOGARG;\n        return NULL;\n    }\n    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_ANYDATA, &snode) || !snode) {\n        LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",\n               name, lys_node_module(siblings)->name, siblings->name);\n        return NULL;\n    }\n    return lyd_create_anydata(parent, snode, value, value_type);\n}", "target": 1}
{"code": "p_ntp_time(netdissect_options *ndo,\n\t   const struct l_fixedpt *lfp)\n{\n\tuint32_t i;\n\tuint32_t uf;\n\tuint32_t f;\n\tdouble ff;\n\ti = GET_BE_U_4(lfp->int_part);\n\tuf = GET_BE_U_4(lfp->fraction);\n\tff = uf;\n\tif (ff < 0.0)\t\t\n\t\tff += FMAXINT;\n\tff = ff / FMAXINT;\t\t\t\n\tf = (uint32_t)(ff * 1000000000.0);\t\n\tND_PRINT(\"%u.%09u\", i, f);\n\tif (i) {\n\t    int64_t seconds_64bit = (int64_t)i - JAN_1970;\n\t    time_t seconds;\n\t    struct tm *tm;\n\t    char time_buf[128];\n\t    seconds = (time_t)seconds_64bit;\n\t    if (seconds != seconds_64bit) {\n\t\tND_PRINT(\" (unrepresentable)\");\n\t    } else {\n\t\ttm = gmtime(&seconds);\n\t\tif (tm == NULL) {\n\t\t    ND_PRINT(\" (unrepresentable)\");\n\t\t} else {\n\t\t    strftime(time_buf, sizeof (time_buf), \"%Y-%m-%dT%H:%M:%SZ\", tm);\n\t\t    ND_PRINT(\" (%s)\", time_buf);\n\t\t}\n\t    }\n\t}\n}", "target": 1}
{"code": "static int get_exif_tag_dbl_value(struct iw_exif_state *e, unsigned int tag_pos,\n\tdouble *pv)\n{\n\tunsigned int field_type;\n\tunsigned int value_count;\n\tunsigned int value_pos;\n\tunsigned int numer, denom;\n\tfield_type = iw_get_ui16_e(&e->d[tag_pos+2],e->endian);\n\tvalue_count = iw_get_ui32_e(&e->d[tag_pos+4],e->endian);\n\tif(value_count!=1) return 0;\n\tif(field_type!=5) return 0; \n\tvalue_pos = iw_get_ui32_e(&e->d[tag_pos+8],e->endian);\n\tif(value_pos > e->d_len-8) return 0;\n\tnumer = iw_get_ui32_e(&e->d[value_pos  ],e->endian);\n\tdenom = iw_get_ui32_e(&e->d[value_pos+4],e->endian);\n\tif(denom==0) return 0;\n\t*pv = ((double)numer)/denom;\n\treturn 1;\n}", "target": 1}
{"code": "static RList *r_bin_wasm_get_element_entries (RBinWasmObj *bin, RBinWasmSection *sec) {\n\tRList *ret = NULL;\n\tRBinWasmElementEntry *ptr = NULL;\n\tif (!(ret = r_list_newf ((RListFree)free))) {\n\t\treturn NULL;\n\t}\n\tut8* buf = bin->buf->buf + (ut32)sec->payload_data;\n\tut32 len =  sec->payload_len;\n\tut32 count = sec->count;\n\tut32 i = 0, r = 0;\n\twhile (i < len && r < count) {\n\t\tif (!(ptr = R_NEW0 (RBinWasmElementEntry))) {\n\t\t\treturn ret;\n\t\t}\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->index, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\t\tif (!(consume_init_expr (buf + i, buf + len, R_BIN_WASM_END_OF_CODE, NULL, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->num_elem, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\t\tut32 j = 0;\n\t\twhile (i < len && j < ptr->num_elem\t) {\n\t\t\tut32 e;\n\t\t\tif (!(consume_u32 (buf + i, buf + len, &e, &i))) {\n\t\t\t\tfree (ptr);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tr_list_append (ret, ptr);\n\t\tr += 1;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "find_by_thp(struct tang_keys_info* tki, const char* target)\n{\n    if (!tki) {\n        return NULL;\n    }\n    json_auto_t* keys = json_deep_copy(tki->m_keys);\n    json_array_extend(keys, tki->m_rotated_keys);\n    size_t idx;\n    json_t* jwk;\n    const char** hashes = supported_hashes();\n    json_array_foreach(keys, idx, jwk) {\n        for (int i = 0; hashes[i]; i++) {\n            __attribute__ ((__cleanup__(cleanup_str))) char* thumbprint = jwk_thumbprint(jwk, hashes[i]);\n            if (!thumbprint || strcmp(thumbprint, target) != 0) {\n                continue;\n            }\n            if (jwk_valid_for_deriving_keys(jwk)) {\n                return json_incref(jwk);\n            } else if (jwk_valid_for_signing(jwk)) {\n                json_auto_t* sign = json_deep_copy(tki->m_sign);\n                if (json_array_append(sign, jwk) == -1) {\n                    return NULL;\n                }\n                json_auto_t* jws = jwk_sign(tki->m_payload, sign);\n                if (!jws) {\n                    return NULL;\n                }\n                return json_incref(jws);\n            }\n        }\n    }\n    return NULL;\n}", "target": 1}
{"code": "static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs)\n{\n    FILE *fp = fopen(dest_filename, \"w\");\n    if (!fp)\n        return false;\n    unsigned fd = 0;\n    while (fd <= 99999) \n    {\n        sprintf(source_filename + source_base_ofs, \"fd/%u\", fd);\n        char *name = malloc_readlink(source_filename);\n        if (!name)\n            break;\n        fprintf(fp, \"%u:%s\\n\", fd, name);\n        free(name);\n        sprintf(source_filename + source_base_ofs, \"fdinfo/%u\", fd);\n        fd++;\n        FILE *in = fopen(source_filename, \"r\");\n        if (!in)\n            continue;\n        char buf[128];\n        while (fgets(buf, sizeof(buf)-1, in))\n        {\n            char *eol = strchrnul(buf, '\\n');\n            eol[0] = '\\n';\n            eol[1] = '\\0';\n            fputs(buf, fp);\n        }\n        fclose(in);\n    }\n    fclose(fp);\n    return true;\n}", "target": 1}
{"code": "bool isCPUDevice<CPUDevice>() {\n  return true;\n}", "target": 0}
{"code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* data =\n      reinterpret_cast<TfLiteAudioMicrofrontendParams*>(node->user_data);\n  FrontendReset(data->state);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  if (data->out_float) {\n    GenerateFeatures<float>(data, input, output);\n  } else {\n    GenerateFeatures<int32>(data, input, output);\n  }\n  return kTfLiteOk;\n}", "target": 1}
{"code": "static bool ParseSampler(Sampler *sampler, std::string *err, const json &o,\n                         bool store_original_json_for_extras_and_extensions) {\n  ParseStringProperty(&sampler->name, err, o, \"name\", false);\n  int minFilter = -1;\n  int magFilter = -1;\n  int wrapS = TINYGLTF_TEXTURE_WRAP_REPEAT;\n  int wrapT = TINYGLTF_TEXTURE_WRAP_REPEAT;\n  ParseIntegerProperty(&minFilter, err, o, \"minFilter\", false);\n  ParseIntegerProperty(&magFilter, err, o, \"magFilter\", false);\n  ParseIntegerProperty(&wrapS, err, o, \"wrapS\", false);\n  ParseIntegerProperty(&wrapT, err, o, \"wrapT\", false);\n  sampler->minFilter = minFilter;\n  sampler->magFilter = magFilter;\n  sampler->wrapS = wrapS;\n  sampler->wrapT = wrapT;\n  ParseExtensionsProperty(&(sampler->extensions), err, o);\n  ParseExtrasProperty(&(sampler->extras), o);\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        sampler->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        sampler->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n  return true;\n}", "target": 1}
{"code": "static void bio_map_kern_endio(struct bio *bio)\n{\n\tbio_put(bio);\n}", "target": 0}
{"code": "ppmd_read(void* p) {\n\tstruct archive_read *a = ((IByteIn*)p)->a;\n\tstruct zip *zip = (struct zip*) a->format->data;\n\tconst uint8_t* data = __archive_read_ahead(a, 1, NULL);\n\t__archive_read_consume(a, 1);\n\t++zip->zipx_ppmd_read_compressed;\n\treturn data[0];\n}", "target": 0}
{"code": "void NavigationControllerImpl::LoadIfNecessary() {\n  if (!needs_reload_)\n    return;\n  if (pending_entry_) {\n    NavigateToPendingEntry(ReloadType::NONE, nullptr );\n  } else if (last_committed_entry_index_ != -1) {\n    pending_entry_ = entries_[last_committed_entry_index_].get();\n    pending_entry_index_ = last_committed_entry_index_;\n    NavigateToPendingEntry(ReloadType::NONE, nullptr );\n  } else {\n    needs_reload_ = false;\n  }\n}", "target": 0}
{"code": "static int update_header(void *obj)\n{\n\tstruct header_data *data = obj;\n\tpjsip_hdr *hdr = NULL;\n\tRAII_VAR(struct ast_datastore *, datastore,\n\t\t\t ast_sip_session_get_datastore(data->channel->session, data->header_datastore->type),\n\t\t\t ao2_cleanup);\n\tif (!datastore || !datastore->data) {\n\t\tast_log(AST_LOG_ERROR, \"No headers had been previously added to this session.\\n\");\n\t\treturn -1;\n\t}\n\thdr = find_header((struct hdr_list *) datastore->data, data->header_name,\n\t\t\t\t\t  data->header_number);\n\tif (!hdr) {\n\t\tast_log(AST_LOG_ERROR, \"There was no header named %s.\\n\", data->header_name);\n\t\treturn -1;\n\t}\n\tpj_strcpy2(&((pjsip_generic_string_hdr *) hdr)->hvalue, data->header_value);\n\treturn 0;\n}", "target": 1}
{"code": "int OmniboxViewWin::OnPerformDrop(const views::DropTargetEvent& event) {\n  return OnPerformDropImpl(event, false);\n}", "target": 0}
{"code": "init_copy(mrb_state *mrb, mrb_value dest, mrb_value obj)\n{\n  switch (mrb_type(obj)) {\n    case MRB_TT_ICLASS:\n      copy_class(mrb, dest, obj);\n      return;\n    case MRB_TT_CLASS:\n    case MRB_TT_MODULE:\n      copy_class(mrb, dest, obj);\n      mrb_iv_copy(mrb, dest, obj);\n      mrb_iv_remove(mrb, dest, mrb_intern_lit(mrb, \"__classname__\"));\n      break;\n    case MRB_TT_OBJECT:\n    case MRB_TT_SCLASS:\n    case MRB_TT_HASH:\n    case MRB_TT_DATA:\n    case MRB_TT_EXCEPTION:\n      mrb_iv_copy(mrb, dest, obj);\n      break;\n    case MRB_TT_ISTRUCT:\n      mrb_istruct_copy(dest, obj);\n      break;\n    default:\n      break;\n  }\n  mrb_funcall(mrb, dest, \"initialize_copy\", 1, obj);\n}", "target": 0}
{"code": "dn2ancestor(\n    Slapi_Backend *be,\n    const Slapi_DN\t*sdn,\n\tSlapi_DN *ancestordn,\n    back_txn\t\t*txn,\n    int\t\t\t*err\n)\n{\n\tstruct backentry *e = NULL;\n\tLDAPDebug( LDAP_DEBUG_TRACE, \"=> dn2ancestor \\\"%s\\\"\\n\", slapi_sdn_get_dn(sdn), 0, 0 );\n    if (!slapi_sdn_isempty(sdn) && !slapi_be_issuffix( be, sdn )) {\n        Slapi_DN ancestorndn;\n        const char *ptr;\n        ptr = slapi_dn_find_parent(slapi_sdn_get_dn(sdn));\n        slapi_sdn_set_normdn_byref(ancestordn, ptr); \n        ptr = slapi_dn_find_parent(slapi_sdn_get_ndn(sdn));\n        slapi_sdn_init_ndn_byref(&ancestorndn, ptr);\n        while (!e && !slapi_sdn_isempty(&ancestorndn) && !slapi_be_issuffix( be, &ancestorndn )) {\n            e= dn2entry(be,&ancestorndn,txn,err);\n            if (!e) {\n                ptr = slapi_dn_find_parent(slapi_sdn_get_ndn(&ancestorndn));\n                slapi_sdn_set_ndn_byref(&ancestorndn, ptr); \n                ptr = slapi_dn_find_parent(slapi_sdn_get_dn(ancestordn));\n                slapi_sdn_set_normdn_byref(ancestordn, ptr); \n            }\n        }\n        slapi_sdn_done(&ancestorndn);\n    }\n    LDAPDebug( LDAP_DEBUG_TRACE, \"<= dn2ancestor %p\\n\", e, 0, 0 );\n    return( e );\n}", "target": 1}
{"code": "static inline bool is_flush_request(struct request *rq,\n\t\tstruct blk_flush_queue *fq, unsigned int tag)\n{\n\treturn ((rq->cmd_flags & REQ_FLUSH_SEQ) &&\n\t\t\tfq->flush_rq->tag == tag);\n}", "target": 1}
{"code": "int LightProcess::pclose(FILE *f) {\n  if (!Available()) {\n    return ::pclose(f);\n  }\n  int id = GetId();\n  Lock lock(g_procs[id].m_procMutex);\n  std::map<int64_t, int64_t>::iterator it = g_procs[id].m_popenMap.find((int64_t)f);\n  if (it == g_procs[id].m_popenMap.end()) {\n    return ::pclose(f);\n  }\n  int64_t f2 = it->second;\n  g_procs[id].m_popenMap.erase((int64_t)f);\n  fclose(f);\n  fprintf(g_procs[id].m_fout, \"pclose\\n%\" PRId64 \"\\n\", f2);\n  fflush(g_procs[id].m_fout);\n  char buf[BUFFER_SIZE];\n  read_buf(g_procs[id].m_fin, buf);\n  int ret = -1;\n  sscanf(buf, \"%d\", &ret);\n  if (ret < 0) {\n    read_buf(g_procs[id].m_fin, buf);\n    sscanf(buf, \"%d\", &errno);\n  }\n  return ret;\n}", "target": 1}
{"code": "ext2_xattr_delete_inode(struct inode *inode)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct mb_cache_entry *ce;\n\tdown_write(&EXT2_I(inode)->xattr_sem);\n\tif (!EXT2_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tbh = sb_bread(inode->i_sb, EXT2_I(inode)->i_file_acl);\n\tif (!bh) {\n\t\text2_error(inode->i_sb, \"ext2_xattr_delete_inode\",\n\t\t\t\"inode %ld: block %d read error\", inode->i_ino,\n\t\t\tEXT2_I(inode)->i_file_acl);\n\t\tgoto cleanup;\n\t}\n\tea_bdebug(bh, \"b_count=%d\", atomic_read(&(bh->b_count)));\n\tif (HDR(bh)->h_magic != cpu_to_le32(EXT2_XATTR_MAGIC) ||\n\t    HDR(bh)->h_blocks != cpu_to_le32(1)) {\n\t\text2_error(inode->i_sb, \"ext2_xattr_delete_inode\",\n\t\t\t\"inode %ld: bad block %d\", inode->i_ino,\n\t\t\tEXT2_I(inode)->i_file_acl);\n\t\tgoto cleanup;\n\t}\n\tce = mb_cache_entry_get(ext2_xattr_cache, bh->b_bdev, bh->b_blocknr);\n\tlock_buffer(bh);\n\tif (HDR(bh)->h_refcount == cpu_to_le32(1)) {\n\t\tif (ce)\n\t\t\tmb_cache_entry_free(ce);\n\t\text2_free_blocks(inode, EXT2_I(inode)->i_file_acl, 1);\n\t\tget_bh(bh);\n\t\tbforget(bh);\n\t\tunlock_buffer(bh);\n\t} else {\n\t\tle32_add_cpu(&HDR(bh)->h_refcount, -1);\n\t\tif (ce)\n\t\t\tmb_cache_entry_release(ce);\n\t\tea_bdebug(bh, \"refcount now=%d\",\n\t\t\tle32_to_cpu(HDR(bh)->h_refcount));\n\t\tunlock_buffer(bh);\n\t\tmark_buffer_dirty(bh);\n\t\tif (IS_SYNC(inode))\n\t\t\tsync_dirty_buffer(bh);\n\t\tdquot_free_block_nodirty(inode, 1);\n\t}\n\tEXT2_I(inode)->i_file_acl = 0;\ncleanup:\n\tbrelse(bh);\n\tup_write(&EXT2_I(inode)->xattr_sem);\n}", "target": 1}
{"code": "void EditorClientBlackBerry::learnWord(const WTF::String&)\n{\n    notImplemented();\n}", "target": 0}
{"code": "static int get_exif_tag_int_value(struct iw_exif_state *e, unsigned int tag_pos,\n\tunsigned int *pv)\n{\n\tunsigned int field_type;\n\tunsigned int value_count;\n\tfield_type = iw_get_ui16_e(&e->d[tag_pos+2],e->endian);\n\tvalue_count = iw_get_ui32_e(&e->d[tag_pos+4],e->endian);\n\tif(value_count!=1) return 0;\n\tif(field_type==3) { \n\t\t*pv = iw_get_ui16_e(&e->d[tag_pos+8],e->endian);\n\t\treturn 1;\n\t}\n\telse if(field_type==4) { \n\t\t*pv = iw_get_ui32_e(&e->d[tag_pos+8],e->endian);\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "deallocateCharacterClasses ()\n{\n  while (characterClasses)\n    {\n      struct CharacterClass *class = characterClasses;\n      characterClasses = characterClasses->next;\n      if (class)\n\tfree (class);\n    }\n}", "target": 0}
{"code": "DECLARESepPutFunc(putRGBseparate16bittile)\n{\n\tuint16 *wr = (uint16*) r;\n\tuint16 *wg = (uint16*) g;\n\tuint16 *wb = (uint16*) b;\n\t(void) img; (void) y; (void) a;\n\twhile (h-- > 0) {\n\t\tfor (x = 0; x < w; x++)\n\t\t\t*cp++ = PACK(img->Bitdepth16To8[*wr++],\n\t\t\t    img->Bitdepth16To8[*wg++],\n\t\t\t    img->Bitdepth16To8[*wb++]);\n\t\tSKEW(wr, wg, wb, fromskew);\n\t\tcp += toskew;\n\t}\n}", "target": 0}
{"code": "dns_resolver_match(const struct key *key,\n\t\t   const struct key_match_data *match_data)\n{\n\tint slen, dlen, ret = 0;\n\tconst char *src = key->description, *dsp = match_data->raw_data;\n\tkenter(\"%s,%s\", src, dsp);\n\tif (!src || !dsp)\n\t\tgoto no_match;\n\tif (strcasecmp(src, dsp) == 0)\n\t\tgoto matched;\n\tslen = strlen(src);\n\tdlen = strlen(dsp);\n\tif (slen <= 0 || dlen <= 0)\n\t\tgoto no_match;\n\tif (src[slen - 1] == '.')\n\t\tslen--;\n\tif (dsp[dlen - 1] == '.')\n\t\tdlen--;\n\tif (slen != dlen || strncasecmp(src, dsp, slen) != 0)\n\t\tgoto no_match;\nmatched:\n\tret = 1;\nno_match:\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}", "target": 1}
{"code": "int sub__remove(struct mosquitto *context, const char *sub, uint8_t *reason)\n{\n\tint rc = 0;\n\tstruct mosquitto__subhier *subhier;\n\tconst char *sharename = NULL;\n\tchar *local_sub = NULL;\n\tchar **topics = NULL;\n\tassert(sub);\n\trc = sub__topic_tokenise(sub, &local_sub, &topics, &sharename);\n\tif(rc) return rc;\n\tHASH_FIND(hh, db.subs, topics[0], strlen(topics[0]), subhier);\n\tif(subhier){\n\t\t*reason = MQTT_RC_NO_SUBSCRIPTION_EXISTED;\n\t\trc = sub__remove_recurse(context, subhier, topics, reason, sharename);\n\t}\n\tmosquitto__free(local_sub);\n\tmosquitto__free(topics);\n\treturn rc;\n}", "target": 1}
{"code": "static OPJ_BOOL bmp_read_rle8_data(FILE* IN, OPJ_UINT8* pData,\n                                   OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)\n{\n    OPJ_UINT32 x, y;\n    OPJ_UINT8 *pix;\n    const OPJ_UINT8 *beyond;\n    beyond = pData + stride * height;\n    pix = pData;\n    x = y = 0U;\n    while (y < height) {\n        int c = getc(IN);\n        if (c == EOF) {\n            return OPJ_FALSE;\n        }\n        if (c) {\n            int j, c1_int;\n            OPJ_UINT8 c1;\n            c1_int = getc(IN);\n            if (c1_int == EOF) {\n                return OPJ_FALSE;\n            }\n            c1 = (OPJ_UINT8)c1_int;\n            for (j = 0; (j < c) && (x < width) &&\n                    ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n                *pix = c1;\n            }\n        } else {\n            c = getc(IN);\n            if (c == EOF) {\n                return OPJ_FALSE;\n            }\n            if (c == 0x00) { \n                x = 0;\n                ++y;\n                pix = pData + y * stride + x;\n            } else if (c == 0x01) { \n                break;\n            } else if (c == 0x02) { \n                c = getc(IN);\n                if (c == EOF) {\n                    return OPJ_FALSE;\n                }\n                x += (OPJ_UINT32)c;\n                c = getc(IN);\n                if (c == EOF) {\n                    return OPJ_FALSE;\n                }\n                y += (OPJ_UINT32)c;\n                pix = pData + y * stride + x;\n            } else { \n                int j;\n                for (j = 0; (j < c) && (x < width) &&\n                        ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n                    int c1_int;\n                    OPJ_UINT8 c1;\n                    c1_int = getc(IN);\n                    if (c1_int == EOF) {\n                        return OPJ_FALSE;\n                    }\n                    c1 = (OPJ_UINT8)c1_int;\n                    *pix = c1;\n                }\n                if ((OPJ_UINT32)c & 1U) { \n                    c = getc(IN);\n                    if (c == EOF) {\n                        return OPJ_FALSE;\n                    }\n                }\n            }\n        }\n    }\n    return OPJ_TRUE;\n}", "target": 1}
{"code": "static int pppol2tp_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t len,\n\t\t\t    int flags)\n{\n\tint err;\n\tstruct sk_buff *skb;\n\tstruct sock *sk = sock->sk;\n\terr = -EIO;\n\tif (sk->sk_state & PPPOX_BOUND)\n\t\tgoto end;\n\tmsg->msg_namelen = 0;\n\terr = 0;\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\tgoto end;\n\tif (len > skb->len)\n\t\tlen = skb->len;\n\telse if (len < skb->len)\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, len);\n\tif (likely(err == 0))\n\t\terr = len;\n\tkfree_skb(skb);\nend:\n\treturn err;\n}", "target": 1}
{"code": "mmsMsg_parseFileName(char* filename, uint8_t* buffer, int* bufPos, int maxBufPos , uint32_t invokeId, ByteBuffer* response)\n{\n    if (*bufPos == maxBufPos)\n        return false;\n    uint8_t tag = buffer[(*bufPos)++];\n    if (tag != 0x19) {\n      mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n      return false;\n    }\n    int length;\n    *bufPos = BerDecoder_decodeLength(buffer, &length, *bufPos, maxBufPos);\n    if (*bufPos < 0)  {\n      mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n      return false;\n    }\n    if (length > 255) {\n      mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_REQUEST_INVALID_ARGUMENT, response);\n      return false;\n    }\n    memcpy(filename, buffer + *bufPos, length);\n    filename[length] = 0;\n    *bufPos += length;\n    if (strstr(filename, \"..\") != NULL) {\n        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILENAME_SYNTAX_ERROR);\n        return false;\n    }\n    return true;\n}", "target": 1}
{"code": "_clone_pdu_header(netsnmp_pdu *pdu)\n{\n    netsnmp_pdu    *newpdu;\n    struct snmp_secmod_def *sptr;\n    int ret;\n    if (!pdu)\n        return NULL;\n    newpdu = (netsnmp_pdu *) malloc(sizeof(netsnmp_pdu));\n    if (!newpdu)\n        return NULL;\n    memmove(newpdu, pdu, sizeof(netsnmp_pdu));\n    newpdu->variables = NULL;\n    newpdu->enterprise = NULL;\n    newpdu->community = NULL;\n    newpdu->securityEngineID = NULL;\n    newpdu->securityName = NULL;\n    newpdu->contextEngineID = NULL;\n    newpdu->contextName = NULL;\n    newpdu->transport_data = NULL;\n    if (snmp_clone_mem((void **) &newpdu->enterprise, pdu->enterprise,\n                       sizeof(oid) * pdu->enterprise_length) ||\n        snmp_clone_mem((void **) &newpdu->community, pdu->community,\n                       pdu->community_len) ||\n        snmp_clone_mem((void **) &newpdu->contextEngineID,\n                       pdu->contextEngineID, pdu->contextEngineIDLen)\n        || snmp_clone_mem((void **) &newpdu->securityEngineID,\n                          pdu->securityEngineID, pdu->securityEngineIDLen)\n        || snmp_clone_mem((void **) &newpdu->contextName, pdu->contextName,\n                          pdu->contextNameLen)\n        || snmp_clone_mem((void **) &newpdu->securityName,\n                          pdu->securityName, pdu->securityNameLen)\n        || snmp_clone_mem((void **) &newpdu->transport_data,\n                          pdu->transport_data,\n                          pdu->transport_data_length)) {\n        snmp_free_pdu(newpdu);\n        return NULL;\n    }\n    if (pdu->securityStateRef &&\n        pdu->command == SNMP_MSG_TRAP2) {\n        netsnmp_assert(pdu->securityModel == SNMP_DEFAULT_SECMODEL);\n        ret = usm_clone_usmStateReference((struct usmStateReference *) pdu->securityStateRef,\n                (struct usmStateReference **) &newpdu->securityStateRef );\n        if (ret)\n        {\n            snmp_free_pdu(newpdu);\n            return NULL;\n        }\n    }\n    if ((sptr = find_sec_mod(newpdu->securityModel)) != NULL &&\n        sptr->pdu_clone != NULL) {\n        (*sptr->pdu_clone) (pdu, newpdu);\n    }\n    return newpdu;\n}", "target": 1}
{"code": "static gpa_t FNAME(gva_to_gpa)(struct kvm_vcpu *vcpu, gva_t vaddr, u32 access,\n\t\t\t       struct x86_exception *exception)\n{\n\tstruct guest_walker walker;\n\tgpa_t gpa = UNMAPPED_GVA;\n\tint r;\n\tr = FNAME(walk_addr)(&walker, vcpu, vaddr, access);\n\tif (r) {\n\t\tgpa = gfn_to_gpa(walker.gfn);\n\t\tgpa |= vaddr & ~PAGE_MASK;\n\t} else if (exception)\n\t\t*exception = walker.fault;\n\treturn gpa;\n}", "target": 0}
{"code": "static void vgacon_scrollback_update(struct vc_data *c, int t, int count)\n{\n\tvoid *p;\n\tif (!vgacon_scrollback_cur->data || !vgacon_scrollback_cur->size ||\n\t    c->vc_num != fg_console)\n\t\treturn;\n\tp = (void *) (c->vc_origin + t * c->vc_size_row);\n\twhile (count--) {\n\t\tif ((vgacon_scrollback_cur->tail + c->vc_size_row) >\n\t\t    vgacon_scrollback_cur->size)\n\t\t\tvgacon_scrollback_cur->tail = 0;\n\t\tscr_memcpyw(vgacon_scrollback_cur->data +\n\t\t\t    vgacon_scrollback_cur->tail,\n\t\t\t    p, c->vc_size_row);\n\t\tvgacon_scrollback_cur->cnt++;\n\t\tp += c->vc_size_row;\n\t\tvgacon_scrollback_cur->tail += c->vc_size_row;\n\t\tif (vgacon_scrollback_cur->tail >= vgacon_scrollback_cur->size)\n\t\t\tvgacon_scrollback_cur->tail = 0;\n\t\tif (vgacon_scrollback_cur->cnt > vgacon_scrollback_cur->rows)\n\t\t\tvgacon_scrollback_cur->cnt = vgacon_scrollback_cur->rows;\n\t\tvgacon_scrollback_cur->cur = vgacon_scrollback_cur->cnt;\n\t}\n}", "target": 1}
{"code": "RenderObject::SelectionState InlineFlowBox::selectionState()\n{\n    return RenderObject::SelectionNone;\n}", "target": 0}
{"code": "static inline unsigned long get_tpuser(void)\n{\n\tunsigned long reg = 0;\n\tif (has_tls_reg && !tls_emu)\n\t\t__asm__(\"mrc p15, 0, %0, c13, c0, 2\" : \"=r\" (reg));\n\treturn reg;\n}", "target": 0}
{"code": "SYSCALL_DEFINE2(clock_adjtime, const clockid_t, which_clock,\n\t\tstruct timex __user *, utx)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\tstruct timex ktx;\n\tint err;\n\tif (!kc)\n\t\treturn -EINVAL;\n\tif (!kc->clock_adj)\n\t\treturn -EOPNOTSUPP;\n\tif (copy_from_user(&ktx, utx, sizeof(ktx)))\n\t\treturn -EFAULT;\n\terr = kc->clock_adj(which_clock, &ktx);\n\tif (err >= 0 && copy_to_user(utx, &ktx, sizeof(ktx)))\n\t\treturn -EFAULT;\n\treturn err;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& handle = ctx->input(0);\n    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(handle.shape()),\n                errors::InvalidArgument(\"`handle` must be scalar\"));\n    const string& name = handle.scalar<tstring>()();\n    auto session_state = ctx->session_state();\n    OP_REQUIRES(ctx, session_state != nullptr,\n                errors::FailedPrecondition(\n                    \"DeleteSessionTensor called on null session state\"));\n    OP_REQUIRES_OK(ctx, session_state->DeleteTensor(name));\n  }", "target": 0}
{"code": "static struct block_device *ext3_blkdev_get(dev_t dev, struct super_block *sb)\n{\n\tstruct block_device *bdev;\n\tchar b[BDEVNAME_SIZE];\n\tbdev = blkdev_get_by_dev(dev, FMODE_READ|FMODE_WRITE|FMODE_EXCL, sb);\n\tif (IS_ERR(bdev))\n\t\tgoto fail;\n\treturn bdev;\nfail:\n\text3_msg(sb, \"error: failed to open journal device %s: %ld\",\n\t\t__bdevname(dev, b), PTR_ERR(bdev));\n\treturn NULL;\n}", "target": 1}
{"code": "TEST_IMPL(utf8_decode1_overrun) {\n  const char* p;\n  char b[1];\n  char c[1];\n  p = b;\n  b[0] = 0x7F;\n  ASSERT_EQ(0x7F, uv__utf8_decode1(&p, b + 1));\n  ASSERT_PTR_EQ(p, b + 1);\n  p = b;\n  b[0] = 0xC0;\n  ASSERT_EQ((unsigned) -1, uv__utf8_decode1(&p, b + 1));\n  ASSERT_PTR_EQ(p, b + 1);\n  b[0] = 0x7F;\n  ASSERT_EQ(UV_EINVAL, uv__idna_toascii(b, b + 1, c, c + 1));\n  return 0;\n}", "target": 0}
{"code": "enum ImapAuthRes imap_auth_login(struct ImapData *idata, const char *method)\n{\n  char q_user[SHORT_STRING], q_pass[SHORT_STRING];\n  char buf[STRING];\n  int rc;\n  if (mutt_bit_isset(idata->capabilities, LOGINDISABLED))\n  {\n    mutt_message(_(\"LOGIN disabled on this server.\"));\n    return IMAP_AUTH_UNAVAIL;\n  }\n  if (mutt_account_getuser(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n  if (mutt_account_getpass(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n  mutt_message(_(\"Logging in...\"));\n  imap_quote_string(q_user, sizeof(q_user), idata->conn->account.user);\n  imap_quote_string(q_pass, sizeof(q_pass), idata->conn->account.pass);\n  if (DebugLevel < IMAP_LOG_PASS)\n    mutt_debug(2, \"Sending LOGIN command for %s...\\n\", idata->conn->account.user);\n  snprintf(buf, sizeof(buf), \"LOGIN %s %s\", q_user, q_pass);\n  rc = imap_exec(idata, buf, IMAP_CMD_FAIL_OK | IMAP_CMD_PASS);\n  if (!rc)\n  {\n    mutt_clear_error(); \n    return IMAP_AUTH_SUCCESS;\n  }\n  mutt_error(_(\"Login failed.\"));\n  return IMAP_AUTH_FAILURE;\n}", "target": 1}
{"code": "linkaddr_string(netdissect_options *ndo, const u_char *ep,\n\t\tconst unsigned int type, const unsigned int len)\n{\n\tregister u_int i;\n\tregister char *cp;\n\tregister struct enamemem *tp;\n\tif (len == 0)\n\t\treturn (\"<empty>\");\n\tif (type == LINKADDR_ETHER && len == ETHER_ADDR_LEN)\n\t\treturn (etheraddr_string(ndo, ep));\n\tif (type == LINKADDR_FRELAY)\n\t\treturn (q922_string(ndo, ep, len));\n\ttp = lookup_bytestring(ndo, ep, len);\n\tif (tp->e_name)\n\t\treturn (tp->e_name);\n\ttp->e_name = cp = (char *)malloc(len*3);\n\tif (tp->e_name == NULL)\n\t\t(*ndo->ndo_error)(ndo, \"linkaddr_string: malloc\");\n\t*cp++ = hex[*ep >> 4];\n\t*cp++ = hex[*ep++ & 0xf];\n\tfor (i = len-1; i > 0 ; --i) {\n\t\t*cp++ = ':';\n\t\t*cp++ = hex[*ep >> 4];\n\t\t*cp++ = hex[*ep++ & 0xf];\n\t}\n\t*cp = '\\0';\n\treturn (tp->e_name);\n}", "target": 1}
{"code": "void __refill_cfs_bandwidth_runtime(struct cfs_bandwidth *cfs_b)\n{\n\tu64 now;\n\tif (cfs_b->quota == RUNTIME_INF)\n\t\treturn;\n\tnow = sched_clock_cpu(smp_processor_id());\n\tcfs_b->runtime = cfs_b->quota;\n\tcfs_b->runtime_expires = now + ktime_to_ns(cfs_b->period);\n\tcfs_b->expires_seq++;\n}", "target": 1}
{"code": "TEST(UriSuite, TestIpSixOverread) {\n\t\tUriUriA uri;\n\t\tconst char * errorPos;\n\t\tchar uriText[2 + 3 + 2 + 1 + 1];\n\t\tstrncpy(uriText, \"\n\t\tEXPECT_EQ(uriParseSingleUriExA(&uri, uriText,\n\t\t\t\turiText + sizeof(uriText), &errorPos), URI_ERROR_SYNTAX);\n\t\tEXPECT_EQ(errorPos, uriText + sizeof(uriText));\n}", "target": 0}
{"code": "void cgit_tag_link(const char *name, const char *title, const char *class,\n\t\t   const char *tag)\n{\n\treporevlink(\"tag\", name, title, class, tag, NULL, NULL);\n}", "target": 0}
{"code": "QString Utils::String::toHtmlEscaped(const QString &str)\n{\n#ifdef QBT_USES_QT5\n    return str.toHtmlEscaped();\n#else\n    return Qt::escape(str);\n#endif\n}", "target": 0}
{"code": "ospf6_print_lshdr(netdissect_options *ndo,\n                  register const struct lsa6_hdr *lshp, const u_char *dataend)\n{\n\tif ((const u_char *)(lshp + 1) > dataend)\n\t\tgoto trunc;\n\tND_TCHECK(lshp->ls_type);\n\tND_TCHECK(lshp->ls_seq);\n\tND_PRINT((ndo, \"\\n\\t  Advertising Router %s, seq 0x%08x, age %us, length %u\",\n               ipaddr_string(ndo, &lshp->ls_router),\n               EXTRACT_32BITS(&lshp->ls_seq),\n               EXTRACT_16BITS(&lshp->ls_age),\n               EXTRACT_16BITS(&lshp->ls_length)-(u_int)sizeof(struct lsa6_hdr)));\n\tospf6_print_ls_type(ndo, EXTRACT_16BITS(&lshp->ls_type), &lshp->ls_stateid);\n\treturn (0);\ntrunc:\n\treturn (1);\n}", "target": 1}
{"code": "TEST(BasicFlatBufferModel, TestHandleMalformedModel) {\n  const auto model_paths = {\n      \"tensorflow/lite/testdata/add_shared_tensors.bin\",\n  };\n  for (const auto& model_path : model_paths) {\n    std::unique_ptr<tflite::FlatBufferModel> model =\n        FlatBufferModel::BuildFromFile(model_path);\n    ASSERT_NE(model, nullptr);\n    tflite::ops::builtin::BuiltinOpResolver resolver;\n    InterpreterBuilder builder(*model, resolver);\n    std::unique_ptr<Interpreter> interpreter;\n    ASSERT_EQ(builder(&interpreter), kTfLiteOk);\n    ASSERT_NE(interpreter, nullptr);\n    ASSERT_NE(interpreter->AllocateTensors(), kTfLiteOk);\n  }\n}", "target": 0}
{"code": "static inline int preempt_count_equals(int preempt_offset)\n{\n\tint nested = preempt_count() + rcu_preempt_depth();\n\treturn (nested == preempt_offset);\n}", "target": 0}
{"code": "static void print_value(int output, int num, const char *devname,\n\t\t\tconst char *value, const char *name, size_t valsz)\n{\n\tif (output & OUTPUT_VALUE_ONLY) {\n\t\tfputs(value, stdout);\n\t\tfputc('\\n', stdout);\n\t} else if (output & OUTPUT_UDEV_LIST) {\n\t\tprint_udev_format(name, value);\n\t} else if (output & OUTPUT_EXPORT_LIST) {\n\t\tif (num == 1 && devname)\n\t\t\tprintf(\"DEVNAME=%s\\n\", devname);\n\t\tfputs(name, stdout);\n\t\tfputs(\"=\", stdout);\n\t\tsafe_print(value, valsz, NULL);\n\t\tfputs(\"\\n\", stdout);\n\t} else {\n\t\tif (num == 1 && devname)\n\t\t\tprintf(\"%s:\", devname);\n\t\tfputs(\" \", stdout);\n\t\tfputs(name, stdout);\n\t\tfputs(\"=\\\"\", stdout);\n\t\tsafe_print(value, valsz, \"\\\"\");\n\t\tfputs(\"\\\"\", stdout);\n\t}\n}", "target": 1}
{"code": "static unsigned long ioapic_read_indirect(struct kvm_ioapic *ioapic,\n\t\t\t\t\t  unsigned long addr,\n\t\t\t\t\t  unsigned long length)\n{\n\tunsigned long result = 0;\n\tswitch (ioapic->ioregsel) {\n\tcase IOAPIC_REG_VERSION:\n\t\tresult = ((((IOAPIC_NUM_PINS - 1) & 0xff) << 16)\n\t\t\t  | (IOAPIC_VERSION_ID & 0xff));\n\t\tbreak;\n\tcase IOAPIC_REG_APIC_ID:\n\tcase IOAPIC_REG_ARB_ID:\n\t\tresult = ((ioapic->id & 0xf) << 24);\n\t\tbreak;\n\tdefault:\n\t\t{\n\t\t\tu32 redir_index = (ioapic->ioregsel - 0x10) >> 1;\n\t\t\tu64 redir_content;\n\t\t\tASSERT(redir_index < IOAPIC_NUM_PINS);\n\t\t\tredir_content = ioapic->redirtbl[redir_index].bits;\n\t\t\tresult = (ioapic->ioregsel & 0x1) ?\n\t\t\t    (redir_content >> 32) & 0xffffffff :\n\t\t\t    redir_content & 0xffffffff;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}", "target": 1}
{"code": "LIR_Opr LIRGenerator::result_register_for(ValueType* type, bool callee) {\n  LIR_Opr opr;\n  switch (type->tag()) {\n    case intTag:     opr = FrameMap::rax_opr;          break;\n    case objectTag:  opr = FrameMap::rax_oop_opr;      break;\n    case longTag:    opr = FrameMap::long0_opr;        break;\n    case floatTag:   opr = UseSSE >= 1 ? FrameMap::xmm0_float_opr  : FrameMap::fpu0_float_opr;  break;\n    case doubleTag:  opr = UseSSE >= 2 ? FrameMap::xmm0_double_opr : FrameMap::fpu0_double_opr;  break;\n    case addressTag:\n    default: ShouldNotReachHere(); return LIR_OprFact::illegalOpr;\n  }\n  assert(opr->type_field() == as_OprType(as_BasicType(type)), \"type mismatch\");\n  return opr;\n}", "target": 0}
{"code": "void nego_process_negotiation_failure(rdpNego* nego, wStream* s)\n{\n\tBYTE flags;\n\tUINT16 length;\n\tUINT32 failureCode;\n\tWLog_DBG(TAG, \"RDP_NEG_FAILURE\");\n\tStream_Read_UINT8(s, flags);\n\tStream_Read_UINT16(s, length);\n\tStream_Read_UINT32(s, failureCode);\n\tswitch (failureCode)\n\t{\n\t\tcase SSL_REQUIRED_BY_SERVER:\n\t\t\tWLog_WARN(TAG, \"Error: SSL_REQUIRED_BY_SERVER\");\n\t\t\tbreak;\n\t\tcase SSL_NOT_ALLOWED_BY_SERVER:\n\t\t\tWLog_WARN(TAG, \"Error: SSL_NOT_ALLOWED_BY_SERVER\");\n\t\t\tnego->sendNegoData = TRUE;\n\t\t\tbreak;\n\t\tcase SSL_CERT_NOT_ON_SERVER:\n\t\t\tWLog_ERR(TAG, \"Error: SSL_CERT_NOT_ON_SERVER\");\n\t\t\tnego->sendNegoData = TRUE;\n\t\t\tbreak;\n\t\tcase INCONSISTENT_FLAGS:\n\t\t\tWLog_ERR(TAG, \"Error: INCONSISTENT_FLAGS\");\n\t\t\tbreak;\n\t\tcase HYBRID_REQUIRED_BY_SERVER:\n\t\t\tWLog_WARN(TAG, \"Error: HYBRID_REQUIRED_BY_SERVER\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWLog_ERR(TAG, \"Error: Unknown protocol security error %\" PRIu32 \"\", failureCode);\n\t\t\tbreak;\n\t}\n\tnego->state = NEGO_STATE_FAIL;\n}", "target": 1}
{"code": "void addReply(redisClient *c, robj *obj) {\n    if (_installWriteEvent(c) != REDIS_OK) return;\n    redisAssert(!server.vm_enabled || obj->storage == REDIS_VM_MEMORY);\n    if (obj->encoding == REDIS_ENCODING_RAW) {\n        if (_addReplyToBuffer(c,obj->ptr,sdslen(obj->ptr)) != REDIS_OK)\n            _addReplyObjectToList(c,obj);\n    } else {\n        obj = getDecodedObject(obj);\n        if (_addReplyToBuffer(c,obj->ptr,sdslen(obj->ptr)) != REDIS_OK)\n            _addReplyObjectToList(c,obj);\n        decrRefCount(obj);\n    }\n}", "target": 1}
{"code": "static inline ut16 r_read_le16(const void *src) {\n\tif (!src) {\n\t\treturn UT16_MAX;\n\t}\n\tconst ut8 *s = (const ut8*)src;\n\treturn (((ut16)s[1]) << 8) | (((ut16)s[0]) << 0);\n}", "target": 0}
{"code": "mptctl_mpt_command (unsigned long arg)\n{\n\tstruct mpt_ioctl_command __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_command  karg;\n\tMPT_ADAPTER\t*ioc;\n\tint\t\tiocnum;\n\tint\t\trc;\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_command))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_mpt_command - \"\n\t\t\t\"Unable to read in mpt_ioctl_command struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_mpt_command() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\trc = mptctl_do_mpt_command (karg, &uarg->MF);\n\treturn rc;\n}", "target": 1}
{"code": "static inline void init_fs_pin(struct fs_pin *p, void (*kill)(struct fs_pin *))\n{\n\tinit_waitqueue_head(&p->wait);\n\tINIT_HLIST_NODE(&p->s_list);\n\tINIT_HLIST_NODE(&p->m_list);\n\tp->kill = kill;\n}", "target": 0}
{"code": "qedi_dbg_info(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t      u32 level, const char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\tchar nfunc[32];\n\tmemset(nfunc, 0, sizeof(nfunc));\n\tmemcpy(nfunc, func, sizeof(nfunc) - 1);\n\tva_start(va, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\tif (!(qedi_dbg_log & level))\n\t\tgoto ret;\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_info(\"[%s]:[%s:%d]:%d: %pV\", dev_name(&qedi->pdev->dev),\n\t\t\tnfunc, line, qedi->host_no, &vaf);\n\telse\n\t\tpr_info(\"[0000:00:00.0]:[%s:%d]: %pV\", nfunc, line, &vaf);\nret:\n\tva_end(va);\n}", "target": 1}
{"code": "static void vgacon_putc(struct vc_data *vc, int c, int ypos, int xpos) { }", "target": 0}
{"code": "static void load_xref_from_plaintext(FILE *fp, xref_t *xref)\n{\n    int  i, buf_idx, obj_id, added_entries;\n    char c, buf[32] = {0};\n    long start, pos;\n    start = ftell(fp);\n    pos = xref->end;\n    fseek(fp, pos, SEEK_SET);\n    while (ftell(fp) != 0)\n      if (SAFE_F(fp, (fgetc(fp) == '/' && fgetc(fp) == 'S')))\n        break;\n      else\n        SAFE_E(fseek(fp, --pos, SEEK_SET), 0, \"Failed seek to xref /Size.\\n\");\n    SAFE_E(fread(buf, 1, 21, fp), 21, \"Failed to load entry Size string.\\n\");\n    xref->n_entries = atoi(buf + strlen(\"ize \"));\n    xref->entries = calloc(1, xref->n_entries * sizeof(struct _xref_entry));\n    obj_id = 0;\n    fseek(fp, xref->start + strlen(\"xref\"), SEEK_SET);\n    added_entries = 0;\n    for (i=0; i<xref->n_entries; i++)\n    {\n        c = fgetc(fp);\n        while (c == '\\n' || c == '\\r')\n          c = fgetc(fp);\n        buf_idx = 0;\n        while (c != '\\n' && c != '\\r' && !feof(fp) &&\n               !ferror(fp) && buf_idx < sizeof(buf))\n        {\n            buf[buf_idx++] = c;\n            c = fgetc(fp);\n        }\n        if (buf_idx >= sizeof(buf))\n        {\n            ERR(\"Failed to locate newline character. \"\n                \"This might be a corrupt PDF.\\n\");\n            exit(EXIT_FAILURE);\n        }\n        buf[buf_idx] = '\\0';\n        if (strchr(buf, 't'))\n          break;\n        if (strlen(buf) > 17)\n        {\n            xref->entries[i].obj_id = obj_id++;\n            xref->entries[i].offset = atol(strtok(buf, \" \"));\n            xref->entries[i].gen_num = atoi(strtok(NULL, \" \"));\n            xref->entries[i].f_or_n = buf[17];\n            ++added_entries;\n        }\n        else\n        {\n            obj_id = atoi(buf);\n            --i;\n        }\n    }\n    xref->n_entries = added_entries;\n    fseek(fp, start, SEEK_SET);\n}", "target": 1}
{"code": "int SetNonBlocking(int fd) {\n#if defined(OS_WIN)\n  unsigned long no_block = 1;\n  return ioctlsocket(fd, FIONBIO, &no_block);\n#elif defined(OS_POSIX)\n  int flags = fcntl(fd, F_GETFL, 0);\n  if (-1 == flags)\n    flags = 0;\n  return fcntl(fd, F_SETFL, flags | O_NONBLOCK);\n#endif\n}", "target": 0}
{"code": "rb_xml_reader_attribute_hash(VALUE rb_reader)\n{\n  VALUE rb_attributes = rb_hash_new();\n  xmlTextReaderPtr c_reader;\n  xmlNodePtr c_node;\n  xmlAttrPtr c_property;\n  Data_Get_Struct(rb_reader, xmlTextReader, c_reader);\n  if (!has_attributes(c_reader)) {\n    return rb_attributes;\n  }\n  c_node = xmlTextReaderExpand(c_reader);\n  if (c_node == NULL) {\n    return Qnil;\n  }\n  c_property = c_node->properties;\n  while (c_property != NULL) {\n    VALUE rb_name = NOKOGIRI_STR_NEW2(c_property->name);\n    VALUE rb_value = Qnil;\n    xmlChar *c_value = xmlNodeGetContent((xmlNode *)c_property);\n    if (c_value) {\n      rb_value = NOKOGIRI_STR_NEW2(c_value);\n      xmlFree(c_value);\n    }\n    rb_hash_aset(rb_attributes, rb_name, rb_value);\n    c_property = c_property->next;\n  }\n  return rb_attributes;\n}", "target": 0}
{"code": "static void umocktypes_free_bool_ptr(bool** value)\n{\n    if (*value != NULL)\n    {\n        my_gballoc_free(*value);\n    }\n}", "target": 0}
{"code": "void DCR_CLASS dcr_parse_riff(DCRAW* p)\n{\n\tunsigned i, size, end;\n\tchar tag[4], date[64], month[64];\n\tstatic const char mon[12][4] =\n\t{ \"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\" };\n\tstruct tm t;\n\tp->order = 0x4949;\n\tdcr_fread(p->obj_, tag, 4, 1);\n\tsize = dcr_get4(p);\n\tend = dcr_ftell(p->obj_) + size;\n\tif (!memcmp(tag,\"RIFF\",4) || !memcmp(tag,\"LIST\",4)) {\n\t\tdcr_get4(p);\n\t\twhile (dcr_ftell(p->obj_)+7 < (long)end)\n\t\t\tdcr_parse_riff(p);\n\t} else if (!memcmp(tag,\"nctg\",4)) {\n\t\twhile (dcr_ftell(p->obj_)+7 < (long)end) {\n\t\t\ti = dcr_get2(p);\n\t\t\tsize = dcr_get2(p);\n\t\t\tif ((i+1) >> 1 == 10 && size == 20)\n\t\t\t\tdcr_get_timestamp(p,0);\n\t\t\telse dcr_fseek(p->obj_, size, SEEK_CUR);\n\t\t}\n\t} else if (!memcmp(tag,\"IDIT\",4) && size < 64) {\n\t\tdcr_fread(p->obj_, date, 64, 1);\n\t\tdate[size] = 0;\n\t\tmemset (&t, 0, sizeof t);\n\t\tif (sscanf (date, \"%*s %s %d %d:%d:%d %d\", month, &t.tm_mday,\n\t\t\t&t.tm_hour, &t.tm_min, &t.tm_sec, &t.tm_year) == 6) {\n\t\t\tfor (i=0; i < 12 && strcasecmp(mon[i],month); i++);\n\t\t\tt.tm_mon = i;\n\t\t\tt.tm_year -= 1900;\n\t\t\tif (mktime(&t) > 0)\n\t\t\t\tp->timestamp = mktime(&t);\n\t\t}\n\t} else\n\t\tdcr_fseek(p->obj_, size, SEEK_CUR);\n}", "target": 1}
{"code": "struct key *key_get_instantiation_authkey(key_serial_t target_id)\n{\n\tchar description[16];\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= &key_type_request_key_auth,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= user_match,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t};\n\tstruct key *authkey;\n\tkey_ref_t authkey_ref;\n\tsprintf(description, \"%x\", target_id);\n\tauthkey_ref = search_process_keyrings(&ctx);\n\tif (IS_ERR(authkey_ref)) {\n\t\tauthkey = ERR_CAST(authkey_ref);\n\t\tif (authkey == ERR_PTR(-EAGAIN))\n\t\t\tauthkey = ERR_PTR(-ENOKEY);\n\t\tgoto error;\n\t}\n\tauthkey = key_ref_to_ptr(authkey_ref);\n\tif (test_bit(KEY_FLAG_REVOKED, &authkey->flags)) {\n\t\tkey_put(authkey);\n\t\tauthkey = ERR_PTR(-EKEYREVOKED);\n\t}\nerror:\n\treturn authkey;\n}", "target": 1}
{"code": "static int handle_pause(struct kvm_vcpu *vcpu)\n{\n\tif (ple_gap)\n\t\tgrow_ple_window(vcpu);\n\tkvm_vcpu_on_spin(vcpu, true);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}", "target": 0}
{"code": "bool VariableUnserializer::matchString(folly::StringPiece str) {\n  const char* p = m_buf;\n  assertx(p <= m_end);\n  int total = 0;\n  if (*p == 'S') {\n    total = 2 + 8 + 1;\n    if (p + total > m_end) return false;\n    p++;\n    if (*p++ != ':') return false;\n    auto const sd = *reinterpret_cast<StringData*const*>(p);\n    assertx(sd->isStatic());\n    if (str.compare(sd->slice()) != 0) return false;\n    p += size_t(8);\n  } else {\n    const auto ss = str.size();\n    if (ss >= 100) return false;\n    int digits = ss >= 10 ? 2 : 1;\n    total = 2 + digits + 2 + ss + 2;\n    if (p + total > m_end) return false;\n    if (*p++ != 's') return false;\n    if (*p++ != ':') return false;\n    if (digits == 2) {\n      if (*p++ != '0' + ss/10) return false;\n      if (*p++ != '0' + ss%10) return false;\n    } else {\n      if (*p++ != '0' + ss) return false;\n    }\n    if (*p++ != ':') return false;\n    if (*p++ != '\\\"') return false;\n    if (memcmp(p, str.data(), ss)) return false;\n    p += ss;\n    if (*p++ != '\\\"') return false;\n  }\n  if (*p++ != ';') return false;\n  assertx(m_buf + total == p);\n  m_buf = p;\n  return true;\n}", "target": 1}
{"code": "static grub_err_t read_foo (struct grub_disk *disk, grub_disk_addr_t sector, grub_size_t size, char *buf) {\n\tif (disk != NULL) {\n\t\tconst int blocksize = 512; \n\t\tint ret;\n\t\tRIOBind *iob = disk->data;\n\t\tif (bio) iob = bio;\n\t\tret = iob->read_at (iob->io, delta+(blocksize*sector),\n\t\t\t(ut8*)buf, size*blocksize);\n\t\tif (ret == -1)\n\t\t\treturn 1;\n\t} else eprintf (\"oops. no disk\\n\");\n\treturn 0; \n}", "target": 1}
{"code": "static long gethugepagesize(const char *path, Error **errp)\n{\n    struct statfs fs;\n    int ret;\n    do {\n        ret = statfs(path, &fs);\n    } while (ret != 0 && errno == EINTR);\n    if (ret != 0) {\n        error_setg_errno(errp, errno, \"failed to get page size of file %s\",\n                         path);\n        return 0;\n    }\n    if (fs.f_type != HUGETLBFS_MAGIC)\n        fprintf(stderr, \"Warning: path not on HugeTLBFS: %s\\n\", path);\n    return fs.f_bsize;\n}", "target": 0}
{"code": "static RBinWasmCustomNameEntry *parse_custom_name_entry(RBinWasmObj *bin, ut64 bound) {\n\tRBuffer *b = bin->buf;\n\tRBinWasmCustomNameEntry *cust = R_NEW0 (RBinWasmCustomNameEntry);\n\tif (!cust) {\n\t\treturn NULL;\n\t}\n\tcust->type = R_BIN_WASM_NAMETYPE_None;\n\tsize_t start = r_buf_tell (b);\n\tif (!consume_u7_r (b, bound, &cust->type)) {\n\t\tgoto beach;\n\t};\n\tif (!consume_u32_r (b, bound, &cust->size)) {\n\t\tgoto beach;\n\t};\n\tswitch (cust->type) {\n\tcase R_BIN_WASM_NAMETYPE_Module:\n\t\tif (!consume_encoded_name_new (b, bound, NULL, &cust->mod_name)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tbreak;\n\tcase R_BIN_WASM_NAMETYPE_Function:\n\t\tcust->func = R_NEW0 (RBinWasmCustomNameFunctionNames);\n\t\tif (!cust->func) {\n\t\t\tgoto beach;\n\t\t}\n\t\tcust->func->names = r_id_storage_new (0, UT32_MAX);\n\t\tif (!cust->func->names) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (!parse_namemap (b, bound, cust->func->names, &cust->func->count)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tbreak;\n\tcase R_BIN_WASM_NAMETYPE_Local:\n\t\tcust->local = parse_custom_names_local (b, bound);\n\t\tif (!cust->local) {\n\t\t\tgoto beach;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tR_LOG_WARN (\"[wasm] Halting custom name section parsing at unknown type 0x%x offset 0x%\" PFMTSZx \"\\n\", cust->type, start);\n\t\tcust->type = R_BIN_WASM_NAMETYPE_None;\n\t\tgoto beach;\n\t}\n\treturn cust;\nbeach:\n\twasm_custom_name_free (cust);\n\treturn NULL;\n}", "target": 0}
{"code": "sf_open_fd\t(int fd, int mode, SF_INFO *sfinfo, int close_desc)\n{\tSF_PRIVATE \t*psf ;\n\tif ((SF_CONTAINER (sfinfo->format)) == SF_FORMAT_SD2)\n\t{\tsf_errno = SFE_SD2_FD_DISALLOWED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\tif ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)\n\t{\tsf_errno = SFE_MALLOC_FAILED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\tpsf_init_files (psf) ;\n\tcopy_filename (psf, \"\") ;\n\tpsf->file.mode = mode ;\n\tpsf_set_file (psf, fd) ;\n\tpsf->is_pipe = psf_is_pipe (psf) ;\n\tpsf->fileoffset = psf_ftell (psf) ;\n\tif (! close_desc)\n\t\tpsf->file.do_not_close_descriptor = SF_TRUE ;\n\treturn psf_open_file (psf, sfinfo) ;\n} ", "target": 1}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* axis = GetInput(context, node, 0);\n  TF_LITE_ENSURE(context, axis != nullptr);\n  TF_LITE_ENSURE_MSG(context, IsConstantTensor(axis),\n                     \"Non constant axis tensor not supported\");\n  return kTfLiteOk;\n}", "target": 0}
{"code": "void FrameLoader::updateFirstPartyForCookies()\n{\n    if (m_frame->tree()->parent())\n        setFirstPartyForCookies(m_frame->tree()->parent()->document()->firstPartyForCookies());\n    else\n        setFirstPartyForCookies(m_URL);\n}", "target": 0}
{"code": "static inline int memcmp_P(const void *a1, const void *b1, size_t len) {\n    const uint8_t* a = (const uint8_t*)(a1);\n    uint8_t* b = (uint8_t*)(b1);\n    for (size_t i=0; i<len; i++) {\n        uint8_t d = pgm_read_byte(a) - pgm_read_byte(b);\n        if (d) return d;\n        a++;\n        b++;\n    }\n    return 0;\n}", "target": 0}
{"code": "remote_auth_timeout_cb(gpointer data)\n{\n    cib_client_t *client = data;\n    client->remote_auth_timeout = 0;\n    if (client->remote_auth == TRUE) {\n        return FALSE;\n    }\n    mainloop_del_fd(client->remote);\n    crm_err(\"Remote client authentication timed out\");\n    return FALSE;\n}", "target": 0}
{"code": "d_lite_amjd(VALUE self)\n{\n    get_d1(self);\n    return m_amjd(dat);\n}", "target": 0}
{"code": "static int vhost_attach_cgroups(struct vhost_dev *dev)\n{\n\tstruct vhost_attach_cgroups_struct attach;\n\tattach.owner = current;\n\tvhost_work_init(&attach.work, vhost_attach_cgroups_work);\n\tvhost_work_queue(dev, &attach.work);\n\tvhost_work_flush(dev, &attach.work);\n\treturn attach.ret;\n}", "target": 0}
{"code": "static void xen_netbk_fill_frags(struct xen_netbk *netbk, struct sk_buff *skb)\n{\n\tstruct skb_shared_info *shinfo = skb_shinfo(skb);\n\tint nr_frags = shinfo->nr_frags;\n\tint i;\n\tfor (i = 0; i < nr_frags; i++) {\n\t\tskb_frag_t *frag = shinfo->frags + i;\n\t\tstruct xen_netif_tx_request *txp;\n\t\tstruct page *page;\n\t\tu16 pending_idx;\n\t\tpending_idx = frag_get_pending_idx(frag);\n\t\ttxp = &netbk->pending_tx_info[pending_idx].req;\n\t\tpage = virt_to_page(idx_to_kaddr(netbk, pending_idx));\n\t\t__skb_fill_page_desc(skb, i, page, txp->offset, txp->size);\n\t\tskb->len += txp->size;\n\t\tskb->data_len += txp->size;\n\t\tskb->truesize += txp->size;\n\t\tget_page(netbk->mmap_pages[pending_idx]);\n\t\txen_netbk_idx_release(netbk, pending_idx);\n\t}\n}", "target": 1}
{"code": "generic_ret *init_2_svc(krb5_ui_4 *arg, struct svc_req *rqstp)\n{\n    static generic_ret         ret;\n    gss_buffer_desc            client_name,\n        service_name;\n    kadm5_server_handle_t      handle;\n    OM_uint32                  minor_stat;\n    const char                 *errmsg = NULL;\n    size_t clen, slen;\n    char *cdots, *sdots;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(*arg, rqstp, &handle)))\n        goto exit_func;\n    if (! (ret.code = check_handle((void *)handle))) {\n        ret.api_version = handle->api_version;\n    }\n    free_server_handle(handle);\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (ret.code != 0)\n        errmsg = krb5_get_error_message(NULL, ret.code);\n    clen = client_name.length;\n    trunc_name(&clen, &cdots);\n    slen = service_name.length;\n    trunc_name(&slen, &sdots);\n    krb5_klog_syslog(LOG_NOTICE, _(\"Request: kadm5_init, %.*s%s, %s, \"\n                                   \"client=%.*s%s, service=%.*s%s, addr=%s, \"\n                                   \"vers=%d, flavor=%d\"),\n                     (int)clen, (char *)client_name.value, cdots,\n                     errmsg ? errmsg : _(\"success\"),\n                     (int)clen, (char *)client_name.value, cdots,\n                     (int)slen, (char *)service_name.value, sdots,\n                     client_addr(rqstp->rq_xprt),\n                     ret.api_version & ~(KADM5_API_VERSION_MASK),\n                     rqstp->rq_cred.oa_flavor);\n    if (errmsg != NULL)\n        krb5_free_error_message(NULL, errmsg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    return(&ret);\n}", "target": 1}
{"code": "static struct child_process *git_connect_git(int fd[2], char *hostandport,\n\t\t\t\t\t     const char *path, const char *prog,\n\t\t\t\t\t     enum protocol_version version,\n\t\t\t\t\t     int flags)\n{\n\tstruct child_process *conn;\n\tstruct strbuf request = STRBUF_INIT;\n\tchar *target_host = getenv(\"GIT_OVERRIDE_VIRTUAL_HOST\");\n\tif (target_host)\n\t\ttarget_host = xstrdup(target_host);\n\telse\n\t\ttarget_host = xstrdup(hostandport);\n\ttransport_check_allowed(\"git\");\n\tif (strchr(target_host, '\\n') || strchr(path, '\\n'))\n\t\tdie(_(\"newline is forbidden in git:\n\tif (git_use_proxy(hostandport))\n\t\tconn = git_proxy_connect(fd, hostandport);\n\telse\n\t\tconn = git_tcp_connect(fd, hostandport, flags);\n\tstrbuf_addf(&request,\n\t\t    \"%s %s%chost=%s%c\",\n\t\t    prog, path, 0,\n\t\t    target_host, 0);\n\tif (version > 0) {\n\t\tstrbuf_addch(&request, '\\0');\n\t\tstrbuf_addf(&request, \"version=%d%c\",\n\t\t\t    version, '\\0');\n\t}\n\tpacket_write(fd[1], request.buf, request.len);\n\tfree(target_host);\n\tstrbuf_release(&request);\n\treturn conn;\n}", "target": 0}
{"code": "int nfs4_do_close(struct path *path, struct nfs4_state *state, int wait)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs4_closedata *calldata;\n\tstruct nfs4_state_owner *sp = state->owner;\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_CLOSE],\n\t\t.rpc_cred = state->owner->so_cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = server->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_close_ops,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tint status = -ENOMEM;\n\tcalldata = kmalloc(sizeof(*calldata), GFP_KERNEL);\n\tif (calldata == NULL)\n\t\tgoto out;\n\tcalldata->inode = state->inode;\n\tcalldata->state = state;\n\tcalldata->arg.fh = NFS_FH(state->inode);\n\tcalldata->arg.stateid = &state->open_stateid;\n\tcalldata->arg.seqid = nfs_alloc_seqid(&state->owner->so_seqid);\n\tif (calldata->arg.seqid == NULL)\n\t\tgoto out_free_calldata;\n\tcalldata->arg.open_flags = 0;\n\tcalldata->arg.bitmask = server->attr_bitmask;\n\tcalldata->res.fattr = &calldata->fattr;\n\tcalldata->res.seqid = calldata->arg.seqid;\n\tcalldata->res.server = server;\n\tcalldata->path.mnt = mntget(path->mnt);\n\tcalldata->path.dentry = dget(path->dentry);\n\tmsg.rpc_argp = &calldata->arg,\n\tmsg.rpc_resp = &calldata->res,\n\ttask_setup_data.callback_data = calldata;\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tstatus = 0;\n\tif (wait)\n\t\tstatus = rpc_wait_for_completion_task(task);\n\trpc_put_task(task);\n\treturn status;\nout_free_calldata:\n\tkfree(calldata);\nout:\n\tnfs4_put_open_state(state);\n\tnfs4_put_state_owner(sp);\n\treturn status;\n}", "target": 1}
{"code": "static int __verify_planes_array_core(struct vb2_buffer *vb, const void *pb)\n{\n\treturn __verify_planes_array(vb, pb);\n}", "target": 0}
{"code": "void CommandData::ParseArg(wchar *Arg)\n{\n  if (IsSwitch(*Arg) && !NoMoreSwitches)\n    if (Arg[1]=='-' && Arg[2]==0)\n      NoMoreSwitches=true;\n    else\n      ProcessSwitch(Arg+1);\n  else\n    if (*Command==0)\n    {\n      wcsncpy(Command,Arg,ASIZE(Command));\n      *Command=toupperw(*Command);\n      if (*Command!='I' && *Command!='S')\n        wcsupper(Command);\n    }\n    else\n      if (*ArcName==0)\n        wcsncpyz(ArcName,Arg,ASIZE(ArcName));\n      else\n      {\n        size_t Length=wcslen(Arg);\n        wchar EndChar=Length==0 ? 0:Arg[Length-1];\n        bool EndSeparator=IsDriveDiv(EndChar) || IsPathDiv(EndChar);\n        wchar CmdChar=toupperw(*Command);\n        bool Add=wcschr(L\"AFUM\",CmdChar)!=NULL;\n        bool Extract=CmdChar=='X' || CmdChar=='E';\n        if (EndSeparator && !Add)\n          wcsncpyz(ExtrPath,Arg,ASIZE(ExtrPath));\n        else\n          if ((Add || CmdChar=='T') && (*Arg!='@' || ListMode==RCLM_REJECT_LISTS))\n            FileArgs.AddString(Arg);\n          else\n          {\n            FindData FileData;\n            bool Found=FindFile::FastFind(Arg,&FileData);\n            if ((!Found || ListMode==RCLM_ACCEPT_LISTS) && \n                ListMode!=RCLM_REJECT_LISTS && *Arg=='@' && !IsWildcard(Arg))\n            {\n              FileLists=true;\n              ReadTextFile(Arg+1,&FileArgs,false,true,FilelistCharset,true,true,true);\n            }\n            else\n              if (Found && FileData.IsDir && Extract && *ExtrPath==0)\n              {\n                wcsncpyz(ExtrPath,Arg,ASIZE(ExtrPath));\n                AddEndSlash(ExtrPath,ASIZE(ExtrPath));\n              }\n              else\n                FileArgs.AddString(Arg);\n          }\n      }\n}", "target": 1}
{"code": "static int __key_instantiate_and_link(struct key *key,\n\t\t\t\t      struct key_preparsed_payload *prep,\n\t\t\t\t      struct key *keyring,\n\t\t\t\t      struct key *authkey,\n\t\t\t\t      struct assoc_array_edit **_edit)\n{\n\tint ret, awaken;\n\tkey_check(key);\n\tkey_check(keyring);\n\tawaken = 0;\n\tret = -EBUSY;\n\tmutex_lock(&key_construction_mutex);\n\tif (!test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {\n\t\tret = key->type->instantiate(key, prep);\n\t\tif (ret == 0) {\n\t\t\tatomic_inc(&key->user->nikeys);\n\t\t\tset_bit(KEY_FLAG_INSTANTIATED, &key->flags);\n\t\t\tif (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags))\n\t\t\t\tawaken = 1;\n\t\t\tif (keyring) {\n\t\t\t\tif (test_bit(KEY_FLAG_KEEP, &keyring->flags))\n\t\t\t\t\tset_bit(KEY_FLAG_KEEP, &key->flags);\n\t\t\t\t__key_link(key, _edit);\n\t\t\t}\n\t\t\tif (authkey)\n\t\t\t\tkey_revoke(authkey);\n\t\t\tif (prep->expiry != TIME_T_MAX) {\n\t\t\t\tkey->expiry = prep->expiry;\n\t\t\t\tkey_schedule_gc(prep->expiry + key_gc_delay);\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&key_construction_mutex);\n\tif (awaken)\n\t\twake_up_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT);\n\treturn ret;\n}", "target": 1}
{"code": "static void exif_error_docref(const char *docref EXIFERR_DC, const image_info_type *ImageInfo, int type, const char *format, ...)\n{\n\tva_list args;\n\tva_start(args, format);\n#ifdef EXIF_DEBUG\n\t{\n\t\tchar *buf;\n\t\tspprintf(&buf, 0, \"%s(%d): %s\", _file, _line, format);\n\t\tphp_verror(docref, ImageInfo && ImageInfo->FileName ? ImageInfo->FileName:\"\", type, buf, args);\n\t\tefree(buf);\n\t}\n#else\n\tphp_verror(docref, ImageInfo && ImageInfo->FileName ? ImageInfo->FileName:\"\", type, format, args);\n#endif\n\tva_end(args);\n}", "target": 0}
{"code": "bool Filter::parseTlvs(const uint8_t* buf, size_t len) {\n  size_t idx{0};\n  while (idx < len) {\n    const uint8_t tlv_type = buf[idx];\n    idx++;\n    if ((idx + 1) >= len) {\n      ENVOY_LOG(debug,\n                fmt::format(\"failed to read proxy protocol extension. No bytes for TLV length. \"\n                            \"Extension length is {}, current index is {}, current type is {}.\",\n                            len, idx, tlv_type));\n      return false;\n    }\n    const uint8_t tlv_length_upper = buf[idx];\n    const uint8_t tlv_length_lower = buf[idx + 1];\n    const size_t tlv_value_length = (tlv_length_upper << 8) + tlv_length_lower;\n    idx += 2;\n    if ((idx + tlv_value_length - 1) >= len) {\n      ENVOY_LOG(\n          debug,\n          fmt::format(\"failed to read proxy protocol extension. No bytes for TLV value. \"\n                      \"Extension length is {}, current index is {}, current type is {}, current \"\n                      \"value length is {}.\",\n                      len, idx, tlv_type, tlv_length_upper));\n      return false;\n    }\n    absl::string_view tlv_value(reinterpret_cast<char const*>(buf + idx), tlv_value_length);\n    auto key_value_pair = config_->isTlvTypeNeeded(tlv_type);\n    if (nullptr != key_value_pair) {\n      ProtobufWkt::Value metadata_value;\n      metadata_value.set_string_value(tlv_value.data(), tlv_value.size());\n      std::string metadata_key = key_value_pair->metadata_namespace().empty()\n                                     ? \"envoy.filters.listener.proxy_protocol\"\n                                     : key_value_pair->metadata_namespace();\n      ProtobufWkt::Struct metadata(\n          (*cb_->dynamicMetadata().mutable_filter_metadata())[metadata_key]);\n      metadata.mutable_fields()->insert({key_value_pair->key(), metadata_value});\n      cb_->setDynamicMetadata(metadata_key, metadata);\n    } else {\n      ENVOY_LOG(trace,\n                \"proxy_protocol: Skip TLV of type {} since it's not needed for dynamic metadata\",\n                tlv_type);\n    }\n    if (config_->isPassThroughTlvTypeNeeded(tlv_type)) {\n      ENVOY_LOG(trace, \"proxy_protocol: Storing parsed TLV of type {} to filter state.\", tlv_type);\n      parsed_tlvs_.push_back({tlv_type, {tlv_value.begin(), tlv_value.end()}});\n    }\n    idx += tlv_value_length;\n    ASSERT(idx <= len);\n  }\n  return true;\n}", "target": 1}
{"code": "static inline int may_ptrace_stop(void)\n{\n\tif (!likely(current->ptrace))\n\t\treturn 0;\n\tif (unlikely(current->mm->core_state) &&\n\t    unlikely(current->mm == current->parent->mm))\n\t\treturn 0;\n\treturn 1;\n}", "target": 0}
{"code": "static xmlParserInputPtr plist_xml_external_entity_loader(const char *URL, const char *ID, xmlParserCtxtPtr ctxt)\n{\n    return NULL;\n}", "target": 0}
{"code": "static void print_primaries(WriterContext *w, enum AVColorPrimaries color_primaries)\n{\n    const char *val = av_color_primaries_name(color_primaries);\n    if (!val || color_primaries == AVCOL_PRI_UNSPECIFIED) {\n        print_str_opt(\"color_primaries\", \"unknown\");\n    } else {\n        print_str(\"color_primaries\", val);\n    }\n}", "target": 0}
{"code": "RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {\n\tint i;\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tRList *segments = r_list_newf (free);\n\tfor (i = 0; i < bin->ne_header->SegCount; i++) {\n\t\tRBinSection *bs = R_NEW0 (RBinSection);\n\t\tNE_image_segment_entry *se = &bin->segment_entries[i];\n\t\tif (!bs) {\n\t\t\treturn segments;\n\t\t}\n\t\tbs->size = se->length;\n\t\tbs->vsize = se->minAllocSz ? se->minAllocSz : 64000;\n\t\tbs->bits = R_SYS_BITS_16;\n\t\tbs->is_data = se->flags & IS_DATA;\n\t\tbs->perm = __translate_perms (se->flags);\n\t\tbs->paddr = (ut64)se->offset * bin->alignment;\n\t\tbs->name = r_str_newf (\"%s.%\" PFMT64d, se->flags & IS_MOVEABLE ? \"MOVEABLE\" : \"FIXED\", bs->paddr);\n\t\tbs->is_segment = true;\n\t\tr_list_append (segments, bs);\n\t}\n\tbin->segments = segments;\n\treturn segments;\n}", "target": 1}
{"code": "static struct key *construct_key_and_link(struct keyring_search_context *ctx,\n\t\t\t\t\t  const char *callout_info,\n\t\t\t\t\t  size_t callout_len,\n\t\t\t\t\t  void *aux,\n\t\t\t\t\t  struct key *dest_keyring,\n\t\t\t\t\t  unsigned long flags)\n{\n\tstruct key_user *user;\n\tstruct key *key;\n\tint ret;\n\tkenter(\"\");\n\tif (ctx->index_key.type == &key_type_keyring)\n\t\treturn ERR_PTR(-EPERM);\n\tuser = key_user_lookup(current_fsuid());\n\tif (!user)\n\t\treturn ERR_PTR(-ENOMEM);\n\tconstruct_get_dest_keyring(&dest_keyring);\n\tret = construct_alloc_key(ctx, dest_keyring, flags, user, &key);\n\tkey_user_put(user);\n\tif (ret == 0) {\n\t\tret = construct_key(key, callout_info, callout_len, aux,\n\t\t\t\t    dest_keyring);\n\t\tif (ret < 0) {\n\t\t\tkdebug(\"cons failed\");\n\t\t\tgoto construction_failed;\n\t\t}\n\t} else if (ret == -EINPROGRESS) {\n\t\tret = 0;\n\t} else {\n\t\tgoto couldnt_alloc_key;\n\t}\n\tkey_put(dest_keyring);\n\tkleave(\" = key %d\", key_serial(key));\n\treturn key;\nconstruction_failed:\n\tkey_negate_and_link(key, key_negative_timeout, NULL, NULL);\n\tkey_put(key);\ncouldnt_alloc_key:\n\tkey_put(dest_keyring);\n\tkleave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}", "target": 1}
{"code": "gfx::Rect OverlayWindowViews::GetVideoBounds() {\n  return video_bounds_;\n}", "target": 0}
{"code": "static BOOL nsc_stream_initialize(NSC_CONTEXT* context, wStream* s)\n{\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(context->priv);\n\tif (!Stream_CheckAndLogRequiredLengthWLog(context->priv->log, s, 20))\n\t\treturn FALSE;\n\tsize_t total = 0;\n\tfor (size_t i = 0; i < 4; i++)\n\t{\n\t\tStream_Read_UINT32(s, context->PlaneByteCount[i]);\n\t\ttotal += context->PlaneByteCount[i];\n\t}\n\tStream_Read_UINT8(s, context->ColorLossLevel);         \n\tStream_Read_UINT8(s, context->ChromaSubsamplingLevel); \n\tStream_Seek(s, 2);                                     \n\tcontext->Planes = Stream_Pointer(s);\n\tcontext->PlanesSize = total;\n\treturn Stream_CheckAndLogRequiredLengthWLog(context->priv->log, s, total);\n}", "target": 0}
{"code": "device_drive_benchmark (Device *device,\n                        gboolean do_write_benchmark,\n                        char **options,\n                        DBusGMethodInvocation *context)\n{\n  if (!device->priv->device_is_drive)\n    {\n      throw_error (context, ERROR_FAILED, \"Device is not a drive\");\n      goto out;\n    }\n  daemon_local_check_auth (device->priv->daemon,\n                           device,\n                           \"org.freedesktop.udisks.change\",\n                           \"DriveBenchmark\",\n                           TRUE,\n                           device_drive_benchmark_authorized_cb,\n                           context,\n                           2,\n                           GINT_TO_POINTER (do_write_benchmark),\n                           NULL,\n                           g_strdupv (options),\n                           g_strfreev);\n out:\n  return TRUE;\n}", "target": 0}
{"code": "static void fdc_specify(void)\n{\n\tunsigned char spec1;\n\tunsigned char spec2;\n\tunsigned long srt;\n\tunsigned long hlt;\n\tunsigned long hut;\n\tunsigned long dtr = NOMINAL_DTR;\n\tunsigned long scale_dtr = NOMINAL_DTR;\n\tint hlt_max_code = 0x7f;\n\tint hut_max_code = 0xf;\n\tif (FDCS->need_configure && FDCS->version >= FDC_82072A) {\n\t\tfdc_configure();\n\t\tFDCS->need_configure = 0;\n\t}\n\tswitch (raw_cmd->rate & 0x03) {\n\tcase 3:\n\t\tdtr = 1000;\n\t\tbreak;\n\tcase 1:\n\t\tdtr = 300;\n\t\tif (FDCS->version >= FDC_82078) {\n\t\t\toutput_byte(FD_DRIVESPEC);\n\t\t\tif (need_more_output() == MORE_OUTPUT) {\n\t\t\t\toutput_byte(UNIT(current_drive));\n\t\t\t\toutput_byte(0xc0);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tdtr = 250;\n\t\tbreak;\n\t}\n\tif (FDCS->version >= FDC_82072) {\n\t\tscale_dtr = dtr;\n\t\thlt_max_code = 0x00;\t\n\t\thut_max_code = 0x0;\t\n\t}\n\tsrt = 16 - DIV_ROUND_UP(DP->srt * scale_dtr / 1000, NOMINAL_DTR);\n\tif (slow_floppy)\n\t\tsrt = srt / 4;\n\tSUPBOUND(srt, 0xf);\n\tINFBOUND(srt, 0);\n\thlt = DIV_ROUND_UP(DP->hlt * scale_dtr / 2, NOMINAL_DTR);\n\tif (hlt < 0x01)\n\t\thlt = 0x01;\n\telse if (hlt > 0x7f)\n\t\thlt = hlt_max_code;\n\thut = DIV_ROUND_UP(DP->hut * scale_dtr / 16, NOMINAL_DTR);\n\tif (hut < 0x1)\n\t\thut = 0x1;\n\telse if (hut > 0xf)\n\t\thut = hut_max_code;\n\tspec1 = (srt << 4) | hut;\n\tspec2 = (hlt << 1) | (use_virtual_dma & 1);\n\tif (FDCS->spec1 != spec1 || FDCS->spec2 != spec2) {\n\t\toutput_byte(FD_SPECIFY);\n\t\toutput_byte(FDCS->spec1 = spec1);\n\t\toutput_byte(FDCS->spec2 = spec2);\n\t}\n}\t\t\t\t", "target": 0}
{"code": "int DH_set0_pqg(DH *dh, BIGNUM *p, BIGNUM *q, BIGNUM *g) {\n    if(!p || !g) \n        return 0;\n    BN_free(dh->p);\n    BN_free(dh->q);\n    BN_free(dh->g);\n    dh->p = p;\n    dh->q = q;\n    dh->g = g;\n    if(q)\n        dh->length = BN_num_bits(q);\n    return 1;\n}", "target": 1}
{"code": "static void encode_share_access(struct xdr_stream *xdr, int open_flags)\n{\n\t__be32 *p;\n\tRESERVE_SPACE(8);\n\tswitch (open_flags & (FMODE_READ|FMODE_WRITE)) {\n\t\tcase FMODE_READ:\n\t\t\tWRITE32(NFS4_SHARE_ACCESS_READ);\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tWRITE32(NFS4_SHARE_ACCESS_WRITE);\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tWRITE32(NFS4_SHARE_ACCESS_BOTH);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t}\n\tWRITE32(0);\t\t\n}", "target": 1}
{"code": "int AVI_read_audio(avi_t *AVI, u8 *audbuf, int bytes, int *continuous)\n{\n\tint nr, todo;\n\ts64 pos;\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\tif(!AVI->track[AVI->aptr].audio_index)         {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\tnr = 0; \n\tif (bytes==0) {\n\t\tAVI->track[AVI->aptr].audio_posc++;\n\t\tAVI->track[AVI->aptr].audio_posb = 0;\n\t}\n\t*continuous = 1;\n\twhile(bytes>0)\n\t{\n\t\ts64 ret;\n\t\tint left = (int) (AVI->track[AVI->aptr].audio_index[AVI->track[AVI->aptr].audio_posc].len - AVI->track[AVI->aptr].audio_posb);\n\t\tif(left==0)\n\t\t{\n\t\t\tif(AVI->track[AVI->aptr].audio_posc>=AVI->track[AVI->aptr].audio_chunks-1) return nr;\n\t\t\tAVI->track[AVI->aptr].audio_posc++;\n\t\t\tAVI->track[AVI->aptr].audio_posb = 0;\n\t\t\t*continuous = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif(bytes<left)\n\t\t\ttodo = bytes;\n\t\telse\n\t\t\ttodo = left;\n\t\tpos = AVI->track[AVI->aptr].audio_index[AVI->track[AVI->aptr].audio_posc].pos + AVI->track[AVI->aptr].audio_posb;\n\t\tgf_fseek(AVI->fdes, pos, SEEK_SET);\n\t\tif ( (ret = avi_read(AVI->fdes,audbuf+nr,todo)) != todo)\n\t\t{\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] XXX pos = %\"LLD\", ret = %\"LLD\", todo = %ld\\n\", pos, ret, todo));\n\t\t\tAVI_errno = AVI_ERR_READ;\n\t\t\treturn -1;\n\t\t}\n\t\tbytes -= todo;\n\t\tnr    += todo;\n\t\tAVI->track[AVI->aptr].audio_posb += todo;\n\t}\n\treturn nr;\n}", "target": 1}
{"code": "peek_from_buf(char *string, size_t string_len, const buf_t *buf)\n{\n  chunk_t *chunk;\n  tor_assert(string);\n  tor_assert(string_len <= buf->datalen);\n  chunk = buf->head;\n  while (string_len) {\n    size_t copy = string_len;\n    tor_assert(chunk);\n    if (chunk->datalen < copy)\n      copy = chunk->datalen;\n    memcpy(string, chunk->data, copy);\n    string_len -= copy;\n    string += copy;\n    chunk = chunk->next;\n  }\n}", "target": 0}
{"code": "int ConnectionImpl::onFrameSend(const nghttp2_frame* frame) {\n  ENVOY_CONN_LOG(trace, \"sent frame type={}\", connection_, static_cast<uint64_t>(frame->hd.type));\n  switch (frame->hd.type) {\n  case NGHTTP2_GOAWAY: {\n    ENVOY_CONN_LOG(debug, \"sent goaway code={}\", connection_, frame->goaway.error_code);\n    if (frame->goaway.error_code != NGHTTP2_NO_ERROR) {\n      return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n    break;\n  }\n  case NGHTTP2_RST_STREAM: {\n    ENVOY_CONN_LOG(debug, \"sent reset code={}\", connection_, frame->rst_stream.error_code);\n    stats_.tx_reset_.inc();\n    break;\n  }\n  case NGHTTP2_HEADERS:\n  case NGHTTP2_DATA: {\n    StreamImpl* stream = getStream(frame->hd.stream_id);\n    if (stream->headers_) {\n      ASSERT(stream->headers_->byteSize().has_value() &&\n             stream->headers_->byteSize().value() == stream->headers_->byteSizeInternal());\n    }\n    stream->local_end_stream_sent_ = frame->hd.flags & NGHTTP2_FLAG_END_STREAM;\n    break;\n  }\n  }\n  return 0;\n}", "target": 0}
{"code": "void DISOpticalFlowImpl::autoSelectPatchSizeAndScales(int img_width)\n{\n    switch (finest_scale)\n    {\n    case 1:\n        patch_size = 8;\n        coarsest_scale = autoSelectCoarsestScale(img_width);\n        finest_scale = std::max(coarsest_scale-2, 0);\n        break;\n    case 3:\n        patch_size = 12;\n        coarsest_scale = autoSelectCoarsestScale(img_width);\n        finest_scale = std::max(coarsest_scale-4, 0);\n        break;\n    case 4:\n        patch_size = 12;\n        coarsest_scale = autoSelectCoarsestScale(img_width);\n        finest_scale = std::max(coarsest_scale-5, 0);\n        break;\n    case 2:\n    default:\n        patch_size = 8;\n        coarsest_scale = autoSelectCoarsestScale(img_width);\n        finest_scale = std::max(coarsest_scale-2, 0);\n        break;\n    }\n}", "target": 0}
{"code": "static inline struct sk_buff *skb_share_check(struct sk_buff *skb, gfp_t pri)\n{\n\tmight_sleep_if(pri & __GFP_WAIT);\n\tif (skb_shared(skb)) {\n\t\tstruct sk_buff *nskb = skb_clone(skb, pri);\n\t\tif (likely(nskb))\n\t\t\tconsume_skb(skb);\n\t\telse\n\t\t\tkfree_skb(skb);\n\t\tskb = nskb;\n\t}\n\treturn skb;\n}", "target": 0}
{"code": "archive_string_append_from_wcs(struct archive_string *as,\n    const wchar_t *w, size_t len)\n{\n\tint n, ret_val = 0;\n\tchar *p;\n\tchar *end;\n#if HAVE_WCRTOMB\n\tmbstate_t shift_state;\n\tmemset(&shift_state, 0, sizeof(shift_state));\n#else\n\twctomb(NULL, L'\\0');\n#endif\n\tif (archive_string_ensure(as, as->length + len + 1) == NULL)\n\t\treturn (-1);\n\tp = as->s + as->length;\n\tend = as->s + as->buffer_length - MB_CUR_MAX -1;\n\twhile (*w != L'\\0' && len > 0) {\n\t\tif (p >= end) {\n\t\t\tas->length = p - as->s;\n\t\t\tas->s[as->length] = '\\0';\n\t\t\tif (archive_string_ensure(as,\n\t\t\t    as->length + len * 2 + 1) == NULL)\n\t\t\t\treturn (-1);\n\t\t\tp = as->s + as->length;\n\t\t\tend = as->s + as->buffer_length - MB_CUR_MAX -1;\n\t\t}\n#if HAVE_WCRTOMB\n\t\tn = wcrtomb(p, *w++, &shift_state);\n#else\n\t\tn = wctomb(p, *w++);\n#endif\n\t\tif (n == -1) {\n\t\t\tif (errno == EILSEQ) {\n\t\t\t\t*p++ = '?';\n\t\t\t\tret_val = -1;\n\t\t\t} else {\n\t\t\t\tret_val = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\tp += n;\n\t\tlen--;\n\t}\n\tas->length = p - as->s;\n\tas->s[as->length] = '\\0';\n\treturn (ret_val);\n}", "target": 1}
{"code": "static void check_file(char *basename)\n{\n    gdImagePtr im;\n    char *buffer;\n    size_t size;\n    size = read_test_file(&buffer, basename);\n    im = gdImageCreateFromTiffPtr(size, (void *) buffer);\n    gdTestAssert(im == NULL);\n    free(buffer);\n}", "target": 0}
{"code": "bool PrintMsg_Print_Params_IsEqual(\n    const PrintMsg_PrintPages_Params& oldParams,\n    const PrintMsg_PrintPages_Params& newParams) {\n  return PageLayoutIsEqual(oldParams, newParams) &&\n         oldParams.params.max_shrink == newParams.params.max_shrink &&\n         oldParams.params.min_shrink == newParams.params.min_shrink &&\n         oldParams.params.selection_only == newParams.params.selection_only &&\n         oldParams.params.supports_alpha_blend ==\n             newParams.params.supports_alpha_blend &&\n         oldParams.pages.size() == newParams.pages.size() &&\n         oldParams.params.display_header_footer ==\n             newParams.params.display_header_footer &&\n         oldParams.params.date == newParams.params.date &&\n         oldParams.params.title == newParams.params.title &&\n         oldParams.params.url == newParams.params.url &&\n         std::equal(oldParams.pages.begin(), oldParams.pages.end(),\n             newParams.pages.begin());\n}", "target": 0}
{"code": "gopherSendComplete(const Comm::ConnectionPointer &conn, char *, size_t size, Comm::Flag errflag, int xerrno, void *data)\n{\n    GopherStateData *gopherState = (GopherStateData *) data;\n    StoreEntry *entry = gopherState->entry;\n    debugs(10, 5, conn << \" size: \" << size << \" errflag: \" << errflag);\n    if (size > 0) {\n        fd_bytes(conn->fd, size, FD_WRITE);\n        statCounter.server.all.kbytes_out += size;\n        statCounter.server.other.kbytes_out += size;\n    }\n    if (!entry->isAccepting()) {\n        debugs(10, 3, \"terminating due to bad \" << *entry);\n        gopherState->serverConn->close();\n        return;\n    }\n    if (errflag) {\n        const auto err = new ErrorState(ERR_WRITE_ERROR, Http::scServiceUnavailable, gopherState->fwd->request, gopherState->fwd->al);\n        err->xerrno = xerrno;\n        err->port = gopherState->fwd->request->url.port();\n        err->url = xstrdup(entry->url());\n        gopherState->fwd->fail(err);\n        gopherState->serverConn->close();\n        return;\n    }\n    entry->buffer();\n    gopherMimeCreate(gopherState);\n    switch (gopherState->type_id) {\n    case GOPHER_DIRECTORY:\n        gopherState->conversion = GopherStateData::HTML_DIR;\n        gopherState->HTML_header_added = 0;\n        break;\n    case GOPHER_INDEX:\n        gopherState->conversion = GopherStateData::HTML_INDEX_RESULT;\n        gopherState->HTML_header_added = 0;\n        break;\n    case GOPHER_CSO:\n        gopherState->conversion = GopherStateData::HTML_CSO_RESULT;\n        gopherState->cso_recno = 0;\n        gopherState->HTML_header_added = 0;\n        break;\n    default:\n        gopherState->conversion = GopherStateData::NORMAL;\n        entry->flush();\n    }\n    GopherStateData::DelayAwareRead(gopherState);\n}", "target": 1}
{"code": "static int cdc_ncm_bind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tint ret;\n\tif (cdc_ncm_select_altsetting(intf) != CDC_NCM_COMM_ALTSETTING_NCM)\n\t\treturn -ENODEV;\n\tret = cdc_ncm_bind_common(dev, intf, CDC_NCM_DATA_ALTSETTING_NCM, 0);\n\tusbnet_link_change(dev, 0, 0);\n\treturn ret;\n}", "target": 1}
{"code": "apply_all_case_fold(OnigCaseFoldType flag,\n\t\t    OnigApplyAllCaseFoldFunc f, void* arg,\n\t\t    OnigEncoding enc ARG_UNUSED)\n{\n  return onigenc_apply_all_case_fold_with_map(\n             sizeof(CaseFoldMap)/sizeof(OnigPairCaseFoldCodes), CaseFoldMap, 1,\n             flag, f, arg);\n}", "target": 0}
{"code": "defbackend_bind( Slapi_PBlock *pb )\n{\n    int\t\t\trc;\n    ber_tag_t\t\tmethod;\n    struct berval\t*cred;\n    LDAPDebug( LDAP_DEBUG_TRACE, \"defbackend_bind\\n\", 0, 0, 0 );\n    slapi_pblock_get( pb, SLAPI_BIND_METHOD, &method );\n    slapi_pblock_get( pb, SLAPI_BIND_CREDENTIALS, &cred );\n    if ( method == LDAP_AUTH_SIMPLE && cred->bv_len == 0 ) {\n\tslapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsAnonymousBinds);\n\trc = SLAPI_BIND_ANONYMOUS;\n    } else {\n\tsend_nobackend_ldap_result( pb );\n\trc = SLAPI_BIND_FAIL;\n    }\n    return( rc );\n}", "target": 1}
{"code": "stack_param_list_read(stack_param_list * plist, ref_stack_t * pstack,\n                      uint skip, const ref * ppolicies, bool require_all,\n                      gs_ref_memory_t *imem)\n{\n    iparam_list *const iplist = (iparam_list *) plist;\n    uint count = ref_stack_counttomark(pstack);\n    if (count == 0)\n        return_error(gs_error_unmatchedmark);\n    count -= skip + 1;\n    if (count & 1)\n        return_error(gs_error_rangecheck);\n    plist->u.r.read = stack_param_read;\n    plist->enumerate = stack_param_enumerate;\n    plist->pstack = pstack;\n    plist->skip = skip;\n    return ref_param_read_init(iplist, count >> 1, ppolicies, require_all, imem);\n}", "target": 0}
{"code": "gen_hash(codegen_scope *s, node *tree, int val, int limit)\n{\n  int slimit = GEN_VAL_STACK_MAX;\n  if (cursp() >= GEN_LIT_ARY_MAX) slimit = INT16_MAX;\n  int len = 0;\n  mrb_bool update = FALSE;\n  while (tree) {\n    if (nint(tree->car->car->car) == NODE_KW_REST_ARGS) {\n      if (len > 0) {\n        pop_n(len*2);\n        if (!update) {\n          genop_2(s, OP_HASH, cursp(), len);\n        }\n        else {\n          pop();\n          genop_2(s, OP_HASHADD, cursp(), len);\n        }\n        push();\n      }\n      codegen(s, tree->car->cdr, val);\n      if (len > 0 || update) {\n        pop(); pop();\n        genop_1(s, OP_HASHCAT, cursp());\n        push();\n      }\n      update = TRUE;\n      len = 0;\n    }\n    else {\n      codegen(s, tree->car->car, val);\n      codegen(s, tree->car->cdr, val);\n      len++;\n    }\n    tree = tree->cdr;\n    if (val && cursp() >= slimit) {\n      pop_n(len*2);\n      if (!update) {\n        genop_2(s, OP_HASH, cursp(), len);\n      }\n      else {\n        pop();\n        genop_2(s, OP_HASHADD, cursp(), len);\n      }\n      push();\n      update = TRUE;\n      len = 0;\n    }\n  }\n  if (update) {\n    if (len > 0) {\n      pop_n(len*2+1);\n      genop_2(s, OP_HASHADD, cursp(), len);\n      push();\n    }\n    return -1;                  \n  }\n  if (update) return -1;\n  return len;\n}", "target": 1}
{"code": "header_put_be_3byte (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 3)\n\t{\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = x ;\n\t\t} ;\n} ", "target": 1}
{"code": "static void seg_setup(int seg)\n{\n\tconst struct kvm_vmx_segment_field *sf = &kvm_vmx_segment_fields[seg];\n\tunsigned int ar;\n\tvmcs_write16(sf->selector, 0);\n\tvmcs_writel(sf->base, 0);\n\tvmcs_write32(sf->limit, 0xffff);\n\tar = 0x93;\n\tif (seg == VCPU_SREG_CS)\n\t\tar |= 0x08; \n\tvmcs_write32(sf->ar_bytes, ar);\n}", "target": 0}
{"code": "int perf_config(config_fn_t fn, void *data)\n{\n\tint ret = 0, found = 0;\n\tchar *repo_config = NULL;\n\tconst char *home = NULL;\n\tif (config_exclusive_filename)\n\t\treturn perf_config_from_file(fn, config_exclusive_filename, data);\n\tif (perf_config_system() && !access(perf_etc_perfconfig(), R_OK)) {\n\t\tret += perf_config_from_file(fn, perf_etc_perfconfig(),\n\t\t\t\t\t    data);\n\t\tfound += 1;\n\t}\n\thome = getenv(\"HOME\");\n\tif (perf_config_global() && home) {\n\t\tchar *user_config = strdup(mkpath(\"%s/.perfconfig\", home));\n\t\tif (!access(user_config, R_OK)) {\n\t\t\tret += perf_config_from_file(fn, user_config, data);\n\t\t\tfound += 1;\n\t\t}\n\t\tfree(user_config);\n\t}\n\trepo_config = perf_pathdup(\"config\");\n\tif (!access(repo_config, R_OK)) {\n\t\tret += perf_config_from_file(fn, repo_config, data);\n\t\tfound += 1;\n\t}\n\tfree(repo_config);\n\tif (found == 0)\n\t\treturn -1;\n\treturn ret;\n}", "target": 1}
{"code": "static int iax2_provision(struct sockaddr_in *end, int sockfd, char *dest, const char *template, int force)\n{\n\tstruct iax_ie_data provdata;\n\tstruct iax_ie_data ied;\n\tunsigned int sig;\n\tstruct sockaddr_in sin;\n\tint callno;\n\tstruct create_addr_info cai;\n\tmemset(&cai, 0, sizeof(cai));\n\tast_debug(1, \"Provisioning '%s' from template '%s'\\n\", dest, template);\n\tif (iax_provision_build(&provdata, &sig, template, force)) {\n\t\tast_debug(1, \"No provisioning found for template '%s'\\n\", template);\n\t\treturn 0;\n\t}\n\tif (end) {\n\t\tmemcpy(&sin, end, sizeof(sin));\n\t\tcai.sockfd = sockfd;\n\t} else if (create_addr(dest, NULL, &sin, &cai))\n\t\treturn -1;\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_raw(&ied, IAX_IE_PROVISIONING, provdata.buf, provdata.pos);\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n\tif (!callno)\n\t\treturn -1;\n\tif (iaxs[callno]) {\n\t\tiaxs[callno]->autoid = iax2_sched_replace(iaxs[callno]->autoid, \n\t\t\tsched, 15000, auto_hangup, (void *)(long)callno);\n\t\tast_set_flag(iaxs[callno], IAX_PROVISION);\n\t\tsend_command(iaxs[callno], AST_FRAME_IAX, IAX_COMMAND_PROVISION, 0, ied.buf, ied.pos, -1);\n\t}\n\tast_mutex_unlock(&iaxsl[callno]);\n\treturn 1;\n}", "target": 1}
{"code": "d_lite_inspect(VALUE self)\n{\n    get_d1(self);\n    return mk_inspect(dat, rb_obj_class(self), self);\n}", "target": 0}
{"code": "int mg_http_parse(const char *s, size_t len, struct mg_http_message *hm) {\n  int is_response, req_len = mg_http_get_request_len((unsigned char *) s, len);\n  const char *end = s == NULL ? NULL : s + req_len, *qs;  \n  struct mg_str *cl;\n  memset(hm, 0, sizeof(*hm));\n  if (req_len <= 0) return req_len;\n  hm->message.ptr = hm->head.ptr = s;\n  hm->body.ptr = end;\n  hm->head.len = (size_t) req_len;\n  hm->chunk.ptr = end;\n  hm->message.len = hm->body.len = (size_t) ~0;  \n  s = skip(s, end, \" \", &hm->method);\n  s = skip(s, end, \" \", &hm->uri);\n  s = skip(s, end, \"\\r\\n\", &hm->proto);\n  if (hm->method.len == 0 || hm->uri.len == 0) return -1;\n  if ((qs = (const char *) memchr(hm->uri.ptr, '?', hm->uri.len)) != NULL) {\n    hm->query.ptr = qs + 1;\n    hm->query.len = (size_t) (&hm->uri.ptr[hm->uri.len] - (qs + 1));\n    hm->uri.len = (size_t) (qs - hm->uri.ptr);\n  }\n  mg_http_parse_headers(s, end, hm->headers,\n                        sizeof(hm->headers) / sizeof(hm->headers[0]));\n  if ((cl = mg_http_get_header(hm, \"Content-Length\")) != NULL) {\n    hm->body.len = (size_t) mg_to64(*cl);\n    hm->message.len = (size_t) req_len + hm->body.len;\n  }\n  is_response = mg_ncasecmp(hm->method.ptr, \"HTTP/\", 5) == 0;\n  if (hm->body.len == (size_t) ~0 && !is_response &&\n      mg_vcasecmp(&hm->method, \"PUT\") != 0 &&\n      mg_vcasecmp(&hm->method, \"POST\") != 0) {\n    hm->body.len = 0;\n    hm->message.len = (size_t) req_len;\n  }\n  if (hm->body.len == (size_t) ~0 && is_response &&\n      mg_vcasecmp(&hm->uri, \"204\") == 0) {\n    hm->body.len = 0;\n    hm->message.len = (size_t) req_len;\n  }\n  return req_len;\n}", "target": 1}
{"code": "static Jsi_RC jsi_ArrayIndexSubCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr, int op) {\n    int istart = 0, n, i = 0, dir=1, idx=-1;\n    Jsi_Value *seq = Jsi_ValueArrayIndex(interp, args, 0),\n        *start = Jsi_ValueArrayIndex(interp, args, 1);\n    Jsi_Obj *obj = _this->d.obj;\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    if (!seq) {\n        goto bail;\n    }\n    n = Jsi_ObjGetLength(interp, obj);    \n    if (n == 0) {\n        goto bail;\n    }\n    Jsi_Number nstart;\n    if (op == 2) {\n        istart = n-1;\n    }\n    if (start && Jsi_GetNumberFromValue(interp,start, &nstart)==JSI_OK) {\n        istart = (int)nstart;\n        if (istart > n)\n            goto bail;\n        if (istart < 0)\n            istart = (n+istart);\n        if (istart<0)\n            goto bail;\n    }\n    if (op == 2) {\n        istart = n-1;\n        dir = -1;\n    }\n    Jsi_ObjListifyArray(interp, obj);\n    for (i = istart; ; i+=dir)\n    {\n        if ((dir>0 && i>=n) || (dir<0 && i<0) || i>=(int)obj->arrCnt)\n            break;\n        if (obj->arr[i] && Jsi_ValueCmp(interp, obj->arr[i], seq, JSI_CMP_EXACT)==0) {\n            idx = i;\n            break;\n        }\n    }\nbail:\n    if (op == 3)\n        Jsi_ValueMakeBool(interp, ret, (idx!=-1));\n    else\n        Jsi_ValueMakeNumber(interp, ret, idx);\n    return JSI_OK;\n}", "target": 1}
{"code": "void test_chmod(const char *path)\n{\n\tif (chmod(path, 0755) == 0) {\n\t\tfprintf(stderr, \"leak at chmod of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at chmod of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "static void nested_release_page(struct page *page)\n{\n\tkvm_release_page_dirty(page);\n}", "target": 0}
{"code": "static int ext4_end_io_dio(struct kiocb *iocb, loff_t offset,\n\t\t\t    ssize_t size, void *private)\n{\n        ext4_io_end_t *io_end = private;\n\tif (!io_end)\n\t\treturn 0;\n\text_debug(\"ext4_end_io_dio(): io_end 0x%p \"\n\t\t  \"for inode %lu, iocb 0x%p, offset %llu, size %zd\\n\",\n\t\t  io_end, io_end->inode->i_ino, iocb, offset, size);\n\tif (size <= 0) {\n\t\text4_clear_io_unwritten_flag(io_end);\n\t\tsize = 0;\n\t}\n\tio_end->offset = offset;\n\tio_end->size = size;\n\text4_put_io_end(io_end);\n\treturn 0;\n}", "target": 0}
{"code": "    void TiffSizeEntry::doAccept(TiffVisitor& visitor)\n    {\n        visitor.visitSizeEntry(this);\n    } ", "target": 0}
{"code": "static int read_exceptions(struct pstore *ps,\n\t\t\t   int (*callback)(void *callback_context, chunk_t old,\n\t\t\t\t\t   chunk_t new),\n\t\t\t   void *callback_context)\n{\n\tint r, full = 1;\n\tfor (ps->current_area = 0; full; ps->current_area++) {\n\t\tr = area_io(ps, READ);\n\t\tif (r)\n\t\t\treturn r;\n\t\tr = insert_exceptions(ps, callback, callback_context, &full);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\tps->current_area--;\n\tskip_metadata(ps);\n\treturn 0;\n}", "target": 0}
{"code": "static int uas_switch_interface(struct usb_device *udev,\n\t\t\t\tstruct usb_interface *intf)\n{\n\tint alt;\n\talt = uas_find_uas_alt_setting(intf);\n\tif (alt < 0)\n\t\treturn alt;\n\treturn usb_set_interface(udev,\n\t\t\tintf->altsetting[0].desc.bInterfaceNumber, alt);\n}", "target": 1}
{"code": "static int append_key_value(smart_str* loc_name, HashTable* hash_arr, char* key_name)\n{\n\tzval**\tele_value\t= NULL;\n\tif(zend_hash_find(hash_arr , key_name , strlen(key_name) + 1 ,(void **)&ele_value ) == SUCCESS ) {\n\t\tif(Z_TYPE_PP(ele_value)!= IS_STRING ){\n\t\t\treturn FAILURE;\n\t\t}\n\t\tif(strcmp(key_name, LOC_LANG_TAG) != 0 && \n\t\t   strcmp(key_name, LOC_GRANDFATHERED_LANG_TAG)!=0 ) {\n\t\t\tsmart_str_appendl(loc_name, SEPARATOR , sizeof(SEPARATOR)-1);\n\t\t}\n\t\tsmart_str_appendl(loc_name, Z_STRVAL_PP(ele_value) , Z_STRLEN_PP(ele_value));\n\t\treturn SUCCESS;\n\t}\n\treturn LOC_NOT_FOUND;\n}", "target": 1}
{"code": "ev_archive_open_filename (EvArchive   *archive,\n\t\t\t  const char  *path,\n\t\t\t  GError     **error)\n{\n\tint r;\n\tg_return_val_if_fail (EV_IS_ARCHIVE (archive), FALSE);\n\tg_return_val_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE, FALSE);\n\tg_return_val_if_fail (path != NULL, FALSE);\n\tswitch (archive->type) {\n\tcase EV_ARCHIVE_TYPE_NONE:\n\t\tg_assert_not_reached ();\n\tcase EV_ARCHIVE_TYPE_RAR:\n\tcase EV_ARCHIVE_TYPE_ZIP:\n\tcase EV_ARCHIVE_TYPE_7Z:\n\tcase EV_ARCHIVE_TYPE_TAR:\n\t\tr = archive_read_open_filename (archive->libar, path, BUFFER_SIZE);\n\t\tif (r != ARCHIVE_OK) {\n\t\t\tg_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,\n\t\t\t\t     \"Error opening archive: %s\", archive_error_string (archive->libar));\n\t\t\treturn FALSE;\n\t\t}\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}", "target": 0}
{"code": "static void __route4_delete_filter(struct route4_filter *f)\n{\n\ttcf_exts_destroy(&f->exts);\n\ttcf_exts_put_net(&f->exts);\n\tkfree(f);\n}", "target": 0}
{"code": "static int fbcon_set_font(struct vc_data *vc, struct console_font *font,\n\t\t\t  unsigned int flags)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tunsigned charcount = font->charcount;\n\tint w = font->width;\n\tint h = font->height;\n\tint size;\n\tint i, csum;\n\tu8 *new_data, *data = font->data;\n\tint pitch = PITCH(font->width);\n\tif (charcount != 256 && charcount != 512)\n\t\treturn -EINVAL;\n\tif (w > FBCON_SWAP(info->var.rotate, info->var.xres, info->var.yres) ||\n\t    h > FBCON_SWAP(info->var.rotate, info->var.yres, info->var.xres))\n\t\treturn -EINVAL;\n\tif (!(info->pixmap.blit_x & (1 << (font->width - 1))) ||\n\t    !(info->pixmap.blit_y & (1 << (font->height - 1))))\n\t\treturn -EINVAL;\n\tif (fbcon_invalid_charcount(info, charcount))\n\t\treturn -EINVAL;\n\tsize = CALC_FONTSZ(h, pitch, charcount);\n\tnew_data = kmalloc(FONT_EXTRA_WORDS * sizeof(int) + size, GFP_USER);\n\tif (!new_data)\n\t\treturn -ENOMEM;\n\tmemset(new_data, 0, FONT_EXTRA_WORDS * sizeof(int));\n\tnew_data += FONT_EXTRA_WORDS * sizeof(int);\n\tFNTSIZE(new_data) = size;\n\tREFCOUNT(new_data) = 0;\t\n\tfor (i=0; i< charcount; i++) {\n\t\tmemcpy(new_data + i*h*pitch, data +  i*32*pitch, h*pitch);\n\t}\n\tcsum = crc32(0, new_data, size);\n\tFNTSUM(new_data) = csum;\n\tfor (i = first_fb_vc; i <= last_fb_vc; i++) {\n\t\tstruct vc_data *tmp = vc_cons[i].d;\n\t\tif (fb_display[i].userfont &&\n\t\t    fb_display[i].fontdata &&\n\t\t    FNTSUM(fb_display[i].fontdata) == csum &&\n\t\t    FNTSIZE(fb_display[i].fontdata) == size &&\n\t\t    tmp->vc_font.width == w &&\n\t\t    !memcmp(fb_display[i].fontdata, new_data, size)) {\n\t\t\tkfree(new_data - FONT_EXTRA_WORDS * sizeof(int));\n\t\t\tnew_data = (u8 *)fb_display[i].fontdata;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn fbcon_do_set_font(vc, font->width, font->height, charcount, new_data, 1);\n}", "target": 1}
{"code": "int anetUnixServer(char *err, char *path, mode_t perm, int backlog)\n{\n    int s;\n    struct sockaddr_un sa;\n    if (strlen(path) > sizeof(sa.sun_path)-1) {\n        anetSetError(err,\"unix socket path too long (%zu), must be under %zu\", strlen(path), sizeof(sa.sun_path));\n        return ANET_ERR;\n    }\n    if ((s = anetCreateSocket(err,AF_LOCAL)) == ANET_ERR)\n        return ANET_ERR;\n    memset(&sa,0,sizeof(sa));\n    sa.sun_family = AF_LOCAL;\n    redis_strlcpy(sa.sun_path,path,sizeof(sa.sun_path));\n    if (anetListen(err,s,(struct sockaddr*)&sa,sizeof(sa),backlog) == ANET_ERR)\n        return ANET_ERR;\n    if (perm)\n        chmod(sa.sun_path, perm);\n    return s;\n}", "target": 1}
{"code": "int nbd_init(int fd, QIOChannelSocket *sioc, uint16_t flags, off_t size)\n{\n    unsigned long sectors = size / BDRV_SECTOR_SIZE;\n    if (size / BDRV_SECTOR_SIZE != sectors) {\n        LOG(\"Export size %lld too large for 32-bit kernel\", (long long) size);\n        return -E2BIG;\n    }\n    TRACE(\"Setting NBD socket\");\n    if (ioctl(fd, NBD_SET_SOCK, (unsigned long) sioc->fd) < 0) {\n        int serrno = errno;\n        LOG(\"Failed to set NBD socket\");\n        return -serrno;\n    }\n    TRACE(\"Setting block size to %lu\", (unsigned long)BDRV_SECTOR_SIZE);\n    if (ioctl(fd, NBD_SET_BLKSIZE, (unsigned long)BDRV_SECTOR_SIZE) < 0) {\n        int serrno = errno;\n        LOG(\"Failed setting NBD block size\");\n        return -serrno;\n    }\n    TRACE(\"Setting size to %lu block(s)\", sectors);\n    if (size % BDRV_SECTOR_SIZE) {\n        TRACE(\"Ignoring trailing %d bytes of export\",\n              (int) (size % BDRV_SECTOR_SIZE));\n    }\n    if (ioctl(fd, NBD_SET_SIZE_BLOCKS, sectors) < 0) {\n        int serrno = errno;\n        LOG(\"Failed setting size (in blocks)\");\n        return -serrno;\n    }\n    if (ioctl(fd, NBD_SET_FLAGS, (unsigned long) flags) < 0) {\n        if (errno == ENOTTY) {\n            int read_only = (flags & NBD_FLAG_READ_ONLY) != 0;\n            TRACE(\"Setting readonly attribute\");\n            if (ioctl(fd, BLKROSET, (unsigned long) &read_only) < 0) {\n                int serrno = errno;\n                LOG(\"Failed setting read-only attribute\");\n                return -serrno;\n            }\n        } else {\n            int serrno = errno;\n            LOG(\"Failed setting flags\");\n            return -serrno;\n        }\n    }\n    TRACE(\"Negotiation ended\");\n    return 0;\n}", "target": 0}
{"code": "static char *__filterShell(const char *arg) {\n\tr_return_val_if_fail (arg, NULL);\n\tchar *a = malloc (strlen (arg) + 1);\n\tif (!a) {\n\t\treturn NULL;\n\t}\n\tchar *b = a;\n\twhile (*arg) {\n\t\tswitch (*arg) {\n\t\tcase '@':\n\t\tcase '`':\n\t\tcase '|':\n\t\tcase ';':\n\t\tcase '\\n':\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*b++ = *arg;\n\t\t\tbreak;\n\t\t}\n\t\targ++;\n\t}\n\t*b = 0;\n\treturn a;\n}", "target": 1}
{"code": "static php_mb_regex_t *php_mbregex_compile_pattern(const char *pattern, int patlen, OnigOptionType options, OnigEncoding enc, OnigSyntaxType *syntax TSRMLS_DC)\n{\n\tint err_code = 0;\n\tint found = 0;\n\tphp_mb_regex_t *retval = NULL, **rc = NULL;\n\tOnigErrorInfo err_info;\n\tOnigUChar err_str[ONIG_MAX_ERROR_MESSAGE_LEN];\n\tfound = zend_hash_find(&MBREX(ht_rc), (char *)pattern, patlen+1, (void **) &rc);\n\tif (found == FAILURE || (*rc)->options != options || (*rc)->enc != enc || (*rc)->syntax != syntax) {\n\t\tif ((err_code = onig_new(&retval, (OnigUChar *)pattern, (OnigUChar *)(pattern + patlen), options, enc, syntax, &err_info)) != ONIG_NORMAL) {\n\t\t\tonig_error_code_to_str(err_str, err_code, err_info);\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"mbregex compile err: %s\", err_str);\n\t\t\tretval = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tzend_hash_update(&MBREX(ht_rc), (char *) pattern, patlen + 1, (void *) &retval, sizeof(retval), NULL);\n\t} else if (found == SUCCESS) {\n\t\tretval = *rc;\n\t}\nout:\n\treturn retval; \n}", "target": 1}
{"code": "void InstanceKlass::remove_unshareable_info() {\n  if (can_be_verified_at_dumptime()) {\n    set_verified_at_dump_time();\n  }\n  Klass::remove_unshareable_info();\n  if (SystemDictionaryShared::has_class_failed_verification(this)) {\n    return;\n  }\n  _init_state = allocated;\n  { \n    assert(SafepointSynchronize::is_at_safepoint(), \"only called at safepoint\");\n    init_implementor();\n  }\n  constants()->remove_unshareable_info();\n  for (int i = 0; i < methods()->length(); i++) {\n    Method* m = methods()->at(i);\n    m->remove_unshareable_info();\n  }\n  if (array_klasses() != NULL) {\n    array_klasses()->remove_unshareable_info();\n  }\n  _source_debug_extension = NULL;\n  _dep_context = NULL;\n  _osr_nmethods_head = NULL;\n#if INCLUDE_JVMTI\n  _breakpoints = NULL;\n  _previous_versions = NULL;\n  _cached_class_file = NULL;\n  _jvmti_cached_class_field_map = NULL;\n#endif\n  _init_thread = NULL;\n  _methods_jmethod_ids = NULL;\n  _jni_ids = NULL;\n  _oop_map_cache = NULL;\n  _nest_host = NULL;\n  init_shared_package_entry();\n  _dep_context_last_cleaned = 0;\n}", "target": 0}
{"code": "int flush_completed_IO(struct inode *inode)\n{\n\text4_io_end_t *io;\n\tint ret = 0;\n\tint ret2 = 0;\n\tif (list_empty(&EXT4_I(inode)->i_completed_io_list))\n\t\treturn ret;\n\tdump_completed_IO(inode);\n\twhile (!list_empty(&EXT4_I(inode)->i_completed_io_list)){\n\t\tio = list_entry(EXT4_I(inode)->i_completed_io_list.next,\n\t\t\t\text4_io_end_t, list);\n\t\tret = ext4_end_io_nolock(io);\n\t\tif (ret < 0)\n\t\t\tret2 = ret;\n\t\telse\n\t\t\tlist_del_init(&io->list);\n\t}\n\treturn (ret2 < 0) ? ret2 : 0;\n}", "target": 1}
{"code": "bool UnbufferedAsioTlsStream::IsVerifyOK() const\n{\n\treturn m_VerifyOK;\n}", "target": 1}
{"code": "void appendCommand(client *c) {\n    size_t totlen;\n    robj *o, *append;\n    o = lookupKeyWrite(c->db,c->argv[1]);\n    if (o == NULL) {\n        c->argv[2] = tryObjectEncoding(c->argv[2]);\n        dbAdd(c->db,c->argv[1],c->argv[2]);\n        incrRefCount(c->argv[2]);\n        totlen = stringObjectLen(c->argv[2]);\n    } else {\n        if (checkType(c,o,OBJ_STRING))\n            return;\n        append = c->argv[2];\n        totlen = stringObjectLen(o)+sdslen(append->ptr);\n        if (checkStringLength(c,totlen) != C_OK)\n            return;\n        o = dbUnshareStringValue(c->db,c->argv[1],o);\n        o->ptr = sdscatlen(o->ptr,append->ptr,sdslen(append->ptr));\n        totlen = sdslen(o->ptr);\n    }\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_STRING,\"append\",c->argv[1],c->db->id);\n    server.dirty++;\n    addReplyLongLong(c,totlen);\n}", "target": 1}
{"code": "njs_promise_prototype_then(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    njs_int_t                 ret;\n    njs_value_t               *promise, *fulfilled, *rejected, constructor;\n    njs_object_t              *object;\n    njs_function_t            *function;\n    njs_promise_capability_t  *capability;\n    promise = njs_argument(args, 0);\n    if (njs_slow_path(!njs_is_object(promise))) {\n        goto failed;\n    }\n    object = njs_object_proto_lookup(njs_object(promise), NJS_PROMISE,\n                                     njs_object_t);\n    if (njs_slow_path(object == NULL)) {\n        goto failed;\n    }\n    function = njs_promise_create_function(vm, sizeof(njs_promise_context_t));\n    function->u.native = njs_promise_constructor;\n    njs_set_function(&constructor, function);\n    ret = njs_value_species_constructor(vm, promise, &constructor,\n                                        &constructor);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    capability = njs_promise_new_capability(vm, &constructor);\n    if (njs_slow_path(capability == NULL)) {\n        return NJS_ERROR;\n    }\n    fulfilled = njs_arg(args, nargs, 1);\n    rejected = njs_arg(args, nargs, 2);\n    return njs_promise_perform_then(vm, promise, fulfilled, rejected,\n                                    capability);\nfailed:\n    njs_type_error(vm, \"required a promise object\");\n    return NJS_ERROR;\n}", "target": 1}
{"code": "static void jpeg2000_init_static_data(AVCodec *codec)\n{\n    ff_jpeg2000_init_tier1_luts();\n    ff_mqc_init_context_tables();\n}", "target": 0}
{"code": "static av_cold void uninit(AVFilterContext *ctx)\n{\n    ColorCorrectContext *s = ctx->priv;\n    av_freep(&s->analyzeret);\n    av_freep(&s->uhistogram);\n    av_freep(&s->vhistogram);\n}", "target": 0}
{"code": "static bool IsAudible(const AudioBus* rendered_data) {\n  float energy = 0;\n  uint32_t data_size = rendered_data->length();\n  for (uint32_t k = 0; k < rendered_data->NumberOfChannels(); ++k) {\n    const float* data = rendered_data->Channel(k)->Data();\n    float channel_energy;\n    vector_math::Vsvesq(data, 1, &channel_energy, data_size);\n    energy += channel_energy;\n  }\n  return energy > 0;\n}", "target": 0}
{"code": "void MSG_WriteBits( msg_t *msg, int value, int bits ) {\n\tint\ti;\n\toldsize += bits;\n\tif ( msg->maxsize - msg->cursize < 4 ) {\n\t\tmsg->overflowed = qtrue;\n\t\treturn;\n\t}\n\tif ( bits == 0 || bits < -31 || bits > 32 ) {\n\t\tCom_Error( ERR_DROP, \"MSG_WriteBits: bad bits %i\", bits );\n\t}\n\tif ( bits < 0 ) {\n\t\tbits = -bits;\n\t}\n\tif ( msg->oob ) {\n\t\tif ( bits == 8 ) {\n\t\t\tmsg->data[msg->cursize] = value;\n\t\t\tmsg->cursize += 1;\n\t\t\tmsg->bit += 8;\n\t\t} else if ( bits == 16 ) {\n\t\t\tshort temp = value;\n\t\t\tCopyLittleShort( &msg->data[msg->cursize], &temp );\n\t\t\tmsg->cursize += 2;\n\t\t\tmsg->bit += 16;\n\t\t} else if ( bits==32 ) {\n\t\t\tCopyLittleLong( &msg->data[msg->cursize], &value );\n\t\t\tmsg->cursize += 4;\n\t\t\tmsg->bit += 32;\n\t\t} else {\n\t\t\tCom_Error( ERR_DROP, \"can't write %d bits\", bits );\n\t\t}\n\t} else {\n\t\tvalue &= (0xffffffff >> (32 - bits));\n\t\tif ( bits&7 ) {\n\t\t\tint nbits;\n\t\t\tnbits = bits&7;\n\t\t\tfor( i = 0; i < nbits; i++ ) {\n\t\t\t\tHuff_putBit( (value & 1), msg->data, &msg->bit );\n\t\t\t\tvalue = (value >> 1);\n\t\t\t}\n\t\t\tbits = bits - nbits;\n\t\t}\n\t\tif ( bits ) {\n\t\t\tfor( i = 0; i < bits; i += 8 ) {\n\t\t\t\tHuff_offsetTransmit( &msgHuff.compressor, (value & 0xff), msg->data, &msg->bit );\n\t\t\t\tvalue = (value >> 8);\n\t\t\t}\n\t\t}\n\t\tmsg->cursize = (msg->bit >> 3) + 1;\n\t}\n}", "target": 1}
{"code": "BOOL CEAnsi::ReportString(LPCWSTR asRet)\n{\n\tif (!asRet || !*asRet)\n\t\treturn FALSE;\n\tINPUT_RECORD ir[16] = {};\n\tconst size_t nLen = wcslen(asRet);\n\tif (nLen > std::numeric_limits<DWORD>::max())\n\t\treturn false;\n\tINPUT_RECORD* pir = (nLen <= static_cast<int>(countof(ir))) ? ir : static_cast<INPUT_RECORD*>(calloc(nLen, sizeof(INPUT_RECORD)));\n\tif (!pir)\n\t\treturn FALSE;\n\tINPUT_RECORD* p = pir;\n\tLPCWSTR pc = asRet;\n\tfor (size_t i = 0; i < nLen; i++, p++, pc++)\n\t{\n\t\tconst char ch = *pc >= 0x20 ? *pc : L' ';\n\t\tp->EventType = KEY_EVENT;\n\t\tp->Event.KeyEvent.bKeyDown = TRUE;\n\t\tp->Event.KeyEvent.wRepeatCount = 1;\n\t\tp->Event.KeyEvent.uChar.UnicodeChar = ch;\n\t}\n\tDumpKnownEscape(asRet, nLen, de_Report);\n\tDWORD nWritten = 0;\n\tHANDLE hIn = GetStdHandle(STD_INPUT_HANDLE);\n\tconst BOOL bSuccess = WriteConsoleInput(hIn, pir, static_cast<DWORD>(nLen), &nWritten) && (nWritten == nLen);\n\tif (pir != ir)\n\t\tfree(pir);\n\treturn bSuccess;\n}", "target": 1}
{"code": "    bool CFontFileType1::RemovePfbMarkers()\n    {\n        bool bSuccess = true;\n        int nBlockType = 0;\n        int nBlockLen  = 0;\n        int nChar = 0;\n        unsigned char *sBuffer = NULL;\n        int nBufLen = 0;\n        while ( nBlockType != PFB_DONE )\n        {\n            while ( 0 == nBlockLen )\n            {\n                nChar = ReadU8( &bSuccess );\n                if ( !bSuccess )\n                    return false;\n                nBlockType = ReadU8( &bSuccess );\n                if ( !bSuccess || PFB_MARKER != nChar || ( PFB_ASCII != nBlockType && PFB_BINARY != nBlockType && PFB_DONE != nBlockType ) )\n                    return false;\n                if ( PFB_DONE == nBlockType )\n                    break;\n                nBlockLen = ReadU32LE( &bSuccess );\n                if ( !bSuccess )\n                    return false;\n            }\n            if ( nBlockLen > 0 )\n            {\n                if ( !sBuffer )\n                {\n                    sBuffer = (unsigned char*)MemUtilsMalloc( nBlockLen );\n                    if ( !sBuffer )\n                        return false;\n                }\n                else\n                    sBuffer = (unsigned char*)MemUtilsRealloc( sBuffer, nBufLen + nBlockLen );\n                Read( sBuffer + nBufLen, nBlockLen );\n                nBufLen += nBlockLen;\n            }\n            nBlockLen = 0;\n        }\n        if ( m_bFreeFileData )\n            MemUtilsFree( m_sFile );\n        m_bFreeFileData = true;\n        m_sFile         = (unsigned char*)sBuffer;\n        m_sFileData     = m_sFile;\n        m_nLen          = nBufLen;\n        m_nPos          = 0;\n        return true;\n    }", "target": 1}
{"code": "static long vhost_vdpa_set_config_call(struct vhost_vdpa *v, u32 __user *argp)\n{\n\tstruct vdpa_callback cb;\n\tint fd;\n\tstruct eventfd_ctx *ctx;\n\tcb.callback = vhost_vdpa_config_cb;\n\tcb.private = v->vdpa;\n\tif (copy_from_user(&fd, argp, sizeof(fd)))\n\t\treturn  -EFAULT;\n\tctx = fd == VHOST_FILE_UNBIND ? NULL : eventfd_ctx_fdget(fd);\n\tswap(ctx, v->config_ctx);\n\tif (!IS_ERR_OR_NULL(ctx))\n\t\teventfd_ctx_put(ctx);\n\tif (IS_ERR(v->config_ctx))\n\t\treturn PTR_ERR(v->config_ctx);\n\tv->vdpa->config->set_config_cb(v->vdpa, &cb);\n\treturn 0;\n}", "target": 0}
{"code": "inline bool RARPPM_CONTEXT::decodeSymbol2(ModelPPM *Model)\n{\n  int count, HiCnt, i=NumStats-Model->NumMasked;\n  RARPPM_SEE2_CONTEXT* psee2c=makeEscFreq2(Model,i);\n  RARPPM_STATE* ps[256], ** pps=ps, * p=U.Stats-1;\n  HiCnt=0;\n  do \n  {\n    do \n    { \n      p++; \n    } while (Model->CharMask[p->Symbol] == Model->EscCount);\n    HiCnt += p->Freq;\n    if (pps>=ps+ASIZE(ps))\n      return false;\n    *pps++ = p;\n  } while ( --i );\n  Model->Coder.SubRange.scale += HiCnt;\n  count=Model->Coder.GetCurrentCount();\n  if (count>=(int)Model->Coder.SubRange.scale)\n    return(false);\n  p=*(pps=ps);\n  if (count < HiCnt) \n  {\n    HiCnt=0;\n    while ((HiCnt += p->Freq) <= count) \n    {\n      pps++;\n      if (pps>=ps+ASIZE(ps)) \n        return false;\n      p=*pps;\n    }\n    Model->Coder.SubRange.LowCount = (Model->Coder.SubRange.HighCount=HiCnt)-p->Freq;\n    psee2c->update();\n    update2(Model,p);\n  }\n  else\n  {\n    Model->Coder.SubRange.LowCount=HiCnt;\n    Model->Coder.SubRange.HighCount=Model->Coder.SubRange.scale;\n    i=NumStats-Model->NumMasked;\n    pps--;\n    do \n    { \n      pps++;\n      if (pps>=ps+ASIZE(ps)) \n        return false;\n      Model->CharMask[(*pps)->Symbol]=Model->EscCount; \n    } while ( --i );\n    psee2c->Summ += Model->Coder.SubRange.scale;\n    Model->NumMasked = NumStats;\n  }\n  return true;\n}", "target": 1}
{"code": "static int libusb_udev_isoch_transfer(IUDEVICE* idev, URBDRC_CHANNEL_CALLBACK* callback,\n                                      UINT32 MessageId, UINT32 RequestId, UINT32 EndpointAddress,\n                                      UINT32 TransferFlags, UINT32 StartFrame, UINT32 ErrorCount,\n                                      BOOL NoAck, const BYTE* packetDescriptorData,\n                                      UINT32 NumberOfPackets, UINT32 BufferSize, const BYTE* Buffer,\n                                      t_isoch_transfer_cb cb, UINT32 Timeout)\n{\n\tUINT32 iso_packet_size;\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\tASYNC_TRANSFER_USER_DATA* user_data;\n\tstruct libusb_transfer* iso_transfer = NULL;\n\tURBDRC_PLUGIN* urbdrc;\n\tsize_t outSize = (NumberOfPackets * 12);\n\tuint32_t streamID = 0x40000000 | RequestId;\n\tif (!pdev || !pdev->urbdrc)\n\t\treturn -1;\n\turbdrc = pdev->urbdrc;\n\tuser_data = async_transfer_user_data_new(idev, MessageId, 48, BufferSize, Buffer,\n\t                                         outSize + 1024, NoAck, cb, callback);\n\tif (!user_data)\n\t\treturn -1;\n\tuser_data->ErrorCount = ErrorCount;\n\tuser_data->StartFrame = StartFrame;\n\tif (!Buffer)\n\t\tStream_Seek(user_data->data, (NumberOfPackets * 12));\n\tiso_packet_size = BufferSize / NumberOfPackets;\n\tiso_transfer = libusb_alloc_transfer(NumberOfPackets);\n\tif (iso_transfer == NULL)\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_ERROR, \"Error: libusb_alloc_transfer.\");\n\t\tasync_transfer_user_data_free(user_data);\n\t\treturn -1;\n\t}\n\tlibusb_fill_iso_transfer(iso_transfer, pdev->libusb_handle, EndpointAddress,\n\t                         Stream_Pointer(user_data->data), BufferSize, NumberOfPackets,\n\t                         func_iso_callback, user_data, Timeout);\n\tset_stream_id_for_buffer(iso_transfer, streamID);\n\tlibusb_set_iso_packet_lengths(iso_transfer, iso_packet_size);\n\tif (ArrayList_Add(pdev->request_queue, iso_transfer) < 0)\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_WARN,\n\t\t           \"Failed to queue iso transfer, streamID %08\" PRIx32 \" already in use!\",\n\t\t           streamID);\n\t\trequest_free(iso_transfer);\n\t\treturn -1;\n\t}\n\treturn libusb_submit_transfer(iso_transfer);\n}", "target": 1}
{"code": "static int adis_update_scan_mode_burst(struct iio_dev *indio_dev,\n\tconst unsigned long *scan_mask)\n{\n\tstruct adis *adis = iio_device_get_drvdata(indio_dev);\n\tunsigned int burst_length;\n\tu8 *tx;\n\tburst_length = (indio_dev->num_channels - 1) * sizeof(u16);\n\tburst_length += adis->burst->extra_len;\n\tadis->xfer = kcalloc(2, sizeof(*adis->xfer), GFP_KERNEL);\n\tif (!adis->xfer)\n\t\treturn -ENOMEM;\n\tadis->buffer = kzalloc(burst_length + sizeof(u16), GFP_KERNEL);\n\tif (!adis->buffer)\n\t\treturn -ENOMEM;\n\ttx = adis->buffer + burst_length;\n\ttx[0] = ADIS_READ_REG(adis->burst->reg_cmd);\n\ttx[1] = 0;\n\tadis->xfer[0].tx_buf = tx;\n\tadis->xfer[0].bits_per_word = 8;\n\tadis->xfer[0].len = 2;\n\tadis->xfer[1].rx_buf = adis->buffer;\n\tadis->xfer[1].bits_per_word = 8;\n\tadis->xfer[1].len = burst_length;\n\tspi_message_init(&adis->msg);\n\tspi_message_add_tail(&adis->xfer[0], &adis->msg);\n\tspi_message_add_tail(&adis->xfer[1], &adis->msg);\n\treturn 0;\n}", "target": 1}
{"code": "bool Unpack::ProcessDecoded(UnpackThreadData &D)\n{\n  UnpackDecodedItem *Item=D.Decoded,*Border=D.Decoded+D.DecodedSize;\n  while (Item<Border)\n  {\n    UnpPtr&=MaxWinMask;\n    if (((WriteBorder-UnpPtr) & MaxWinMask)<MAX_LZ_MATCH+3 && WriteBorder!=UnpPtr)\n    {\n      UnpWriteBuf();\n      if (WrittenFileSize>DestUnpSize)\n        return false;\n    }\n    if (Item->Type==UNPDT_LITERAL)\n    {\n#if defined(LITTLE_ENDIAN) && defined(ALLOW_MISALIGNED)\n      if (Item->Length==3 && UnpPtr<MaxWinSize-4)\n      {\n        *(uint32 *)(Window+UnpPtr)=*(uint32 *)Item->Literal;\n        UnpPtr+=4;\n      }\n      else\n#endif\n        for (uint I=0;I<=Item->Length;I++)\n          Window[UnpPtr++ & MaxWinMask]=Item->Literal[I];\n    }\n    else\n      if (Item->Type==UNPDT_MATCH)\n      {\n        InsertOldDist(Item->Distance);\n        LastLength=Item->Length;\n        CopyString(Item->Length,Item->Distance);\n      }\n      else\n        if (Item->Type==UNPDT_REP)\n        {\n          uint Distance=OldDist[Item->Distance];\n          for (uint I=Item->Distance;I>0;I--)\n            OldDist[I]=OldDist[I-1];\n          OldDist[0]=Distance;\n          LastLength=Item->Length;\n          CopyString(Item->Length,Distance);\n        }\n        else\n          if (Item->Type==UNPDT_FULLREP)\n          {\n            if (LastLength!=0)\n              CopyString(LastLength,OldDist[0]);\n          }\n          else\n            if (Item->Type==UNPDT_FILTER)\n            {\n              UnpackFilter Filter;\n              Filter.Type=(byte)Item->Length;\n              Filter.BlockStart=Item->Distance;\n              Item++;\n              Filter.Channels=(byte)Item->Length;\n              Filter.BlockLength=Item->Distance;\n              AddFilter(Filter);\n            }\n    Item++;\n  }\n  return true;\n}", "target": 1}
{"code": "int fpm_unix_resolve_socket_premissions(struct fpm_worker_pool_s *wp) \n{\n\tstruct fpm_worker_pool_config_s *c = wp->config;\n\twp->socket_uid = -1;\n\twp->socket_gid = -1;\n\twp->socket_mode = 0666;\n\tif (!c) {\n\t\treturn 0;\n\t}\n\tif (c->listen_owner && *c->listen_owner) {\n\t\tstruct passwd *pwd;\n\t\tpwd = getpwnam(c->listen_owner);\n\t\tif (!pwd) {\n\t\t\tzlog(ZLOG_SYSERROR, \"[pool %s] cannot get uid for user '%s'\", wp->config->name, c->listen_owner);\n\t\t\treturn -1;\n\t\t}\n\t\twp->socket_uid = pwd->pw_uid;\n\t\twp->socket_gid = pwd->pw_gid;\n\t}\n\tif (c->listen_group && *c->listen_group) {\n\t\tstruct group *grp;\n\t\tgrp = getgrnam(c->listen_group);\n\t\tif (!grp) {\n\t\t\tzlog(ZLOG_SYSERROR, \"[pool %s] cannot get gid for group '%s'\", wp->config->name, c->listen_group);\n\t\t\treturn -1;\n\t\t}\n\t\twp->socket_gid = grp->gr_gid;\n\t}\n\tif (c->listen_mode && *c->listen_mode) {\n\t\twp->socket_mode = strtoul(c->listen_mode, 0, 8);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "bool copyaudiodata (AFfilehandle infile, AFfilehandle outfile, int trackid)\n{\n\tint frameSize = afGetVirtualFrameSize(infile, trackid, 1);\n\tconst int kBufferFrameCount = 65536;\n\tvoid *buffer = malloc(kBufferFrameCount * frameSize);\n\tAFframecount totalFrames = afGetFrameCount(infile, AF_DEFAULT_TRACK);\n\tAFframecount totalFramesWritten = 0;\n\tbool success = true;\n\twhile (totalFramesWritten < totalFrames)\n\t{\n\t\tAFframecount framesToRead = totalFrames - totalFramesWritten;\n\t\tif (framesToRead > kBufferFrameCount)\n\t\t\tframesToRead = kBufferFrameCount;\n\t\tAFframecount framesRead = afReadFrames(infile, trackid, buffer,\n\t\t\tframesToRead);\n\t\tif (framesRead < framesToRead)\n\t\t{\n\t\t\tfprintf(stderr, \"Bad read of audio track data.\\n\");\n\t\t\tsuccess = false;\n\t\t\tbreak;\n\t\t}\n\t\tAFframecount framesWritten = afWriteFrames(outfile, trackid, buffer,\n\t\t\tframesRead);\n\t\tif (framesWritten < framesRead)\n\t\t{\n\t\t\tfprintf(stderr, \"Bad write of audio track data.\\n\");\n\t\t\tsuccess = false;\n\t\t\tbreak;\n\t\t}\n\t\ttotalFramesWritten += framesWritten;\n\t}\n\tfree(buffer);\n\treturn success;\n}", "target": 1}
{"code": "static void ReversePoints(PointInfo *points,const size_t number_points)\n{\n  PointInfo\n    point;\n  ssize_t\n    i;\n  for (i=0; i < (ssize_t) (number_points >> 1); i++)\n  {\n    point=points[i];\n    points[i]=points[number_points-(i+1)];\n    points[number_points-(i+1)]=point;\n  }\n}", "target": 0}
{"code": "static bool MR_primality_test(UnsignedBigInteger n, const Vector<UnsignedBigInteger, 256>& tests)\n{\n    ASSERT(!(n < 4));\n    auto predecessor = n.minus({ 1 });\n    auto d = predecessor;\n    size_t r = 0;\n    {\n        auto div_result = d.divided_by(2);\n        while (div_result.remainder == 0) {\n            d = div_result.quotient;\n            div_result = d.divided_by(2);\n            ++r;\n        }\n    }\n    if (r == 0) {\n        return n == 2;\n    }\n    for (auto a : tests) {\n        ASSERT(a < n);\n        auto x = ModularPower(a, d, n);\n        if (x == 1 || x == predecessor)\n            continue;\n        bool skip_this_witness = false;\n        for (size_t i = 0; i < r - 1; ++i) {\n            x = ModularPower(x, 2, n);\n            if (x == predecessor) {\n                skip_this_witness = true;\n                break;\n            }\n        }\n        if (skip_this_witness)\n            continue;\n        return false; \n    }\n    return true; \n}", "target": 1}
{"code": "static void fts3SnippetAdvance(char **ppIter, int *piIter, int iNext){\n  char *pIter = *ppIter;\n  if( pIter ){\n    int iIter = *piIter;\n    while( iIter<iNext ){\n      if( 0==(*pIter & 0xFE) ){\n        iIter = -1;\n        pIter = 0;\n        break;\n      }\n      fts3GetDeltaPosition(&pIter, &iIter);\n    }\n    *piIter = iIter;\n    *ppIter = pIter;\n  }\n}", "target": 0}
{"code": "pci_lintr_route(struct pci_vdev *dev)\n{\n\tstruct businfo *bi;\n\tstruct intxinfo *ii;\n\tif (dev->lintr.pin == 0)\n\t\treturn;\n\tbi = pci_businfo[dev->bus];\n\tassert(bi != NULL);\n\tii = &bi->slotinfo[dev->slot].si_intpins[dev->lintr.pin - 1];\n\tif (ii->ii_ioapic_irq == 0)\n\t\tii->ii_ioapic_irq = ioapic_pci_alloc_irq(dev);\n\tassert(ii->ii_ioapic_irq > 0);\n\tif (ii->ii_pirq_pin == 0)\n\t\tii->ii_pirq_pin = pirq_alloc_pin(dev);\n\tassert(ii->ii_pirq_pin > 0);\n\tdev->lintr.ioapic_irq = ii->ii_ioapic_irq;\n\tdev->lintr.pirq_pin = ii->ii_pirq_pin;\n\tpci_set_cfgdata8(dev, PCIR_INTLINE, pirq_irq(ii->ii_pirq_pin));\n}", "target": 1}
{"code": "TEST_F(ExprMatchTest, AndNestedWithinOrMatchesCorrectly) {\n    createMatcher(fromjson(\n        \"{$expr: {$or: [{$and: [{$eq: ['$x', 3]}, {$gt: ['$z', 5]}]}, {$lt: ['$y', 4]}]}}\"));\n    ASSERT_TRUE(matches(BSON(\"x\" << 3 << \"z\" << 7)));\n    ASSERT_TRUE(matches(BSON(\"y\" << 1)));\n    ASSERT_FALSE(matches(BSON(\"y\" << 5)));\n}", "target": 0}
{"code": "LUA_API void lua_sethook (lua_State *L, lua_Hook func, int mask, int count) {\n  if (func == NULL || mask == 0) {  \n    mask = 0;\n    func = NULL;\n  }\n  if (isLua(L->ci))\n    L->oldpc = L->ci->u.l.savedpc;\n  L->hook = func;\n  L->basehookcount = count;\n  resethookcount(L);\n  L->hookmask = cast_byte(mask);\n  if (mask)\n    settraps(L->ci);  \n}", "target": 1}
{"code": "void FullFramePixelBuffer::setBuffer(int width, int height,\n                                     rdr::U8* data_, int stride_)\n{\n  if ((width < 0) || (width > maxPixelBufferWidth))\n    throw rfb::Exception(\"Invalid PixelBuffer width of %d pixels requested\", width);\n  if ((height < 0) || (height > maxPixelBufferHeight))\n    throw rfb::Exception(\"Invalid PixelBuffer height of %d pixels requested\", height);\n  if ((stride_ < 0) || (stride_ > maxPixelBufferStride) || (stride_ < width))\n    throw rfb::Exception(\"Invalid PixelBuffer stride of %d pixels requested\", stride_);\n  if ((width != 0) && (height != 0) && (data_ == NULL))\n    throw rfb::Exception(\"PixelBuffer requested without a valid memory area\");\n  ModifiablePixelBuffer::setSize(width, height);\n  stride = stride_;\n  data = data_;\n}", "target": 0}
{"code": "static inline void set_pte_at(struct mm_struct *mm, unsigned long addr,\n\t\t\t      pte_t *ptep, pte_t pte)\n{\n\tif (pte_valid_ng(pte)) {\n\t\tif (!pte_special(pte) && pte_exec(pte))\n\t\t\t__sync_icache_dcache(pte, addr);\n\t\tif (pte_dirty(pte) && pte_write(pte))\n\t\t\tpte_val(pte) &= ~PTE_RDONLY;\n\t\telse\n\t\t\tpte_val(pte) |= PTE_RDONLY;\n\t}\n\tset_pte(ptep, pte);\n}", "target": 1}
{"code": "static Jsi_RC NumberToStringCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[500];\n    int radix = 10, skip = 0, argc = Jsi_ValueGetLength(interp, args);\n    Jsi_Number num;\n    Jsi_Value *v;\n    ChkStringN(_this, funcPtr, v);\n    Jsi_GetDoubleFromValue(interp, v, &num);\n    if (argc>skip && (Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, skip), &radix) != JSI_OK\n        || radix<2))\n        return JSI_ERROR;\n    if (argc==skip)\n        return jsi_ObjectToStringCmd(interp, args, _this, ret, funcPtr);\n    switch (radix) {\n        case 16: snprintf(buf, sizeof(buf), \"%\" PRIx64, (Jsi_Wide)num); break;\n        case 8: snprintf(buf, sizeof(buf), \"%\" PRIo64, (Jsi_Wide)num); break;\n        case 10: snprintf(buf, sizeof(buf), \"%\" PRId64, (Jsi_Wide)num); break;\n        default: return jsi_ObjectToStringCmd(interp, args, _this, ret, funcPtr);\n    }\n    Jsi_ValueMakeStringDup(interp, ret, buf);\n    return JSI_OK;\n}", "target": 1}
{"code": "void pdf_load_pages_kids(FILE *fp, pdf_t *pdf)\n{\n    int     i, id, dummy;\n    char   *buf, *c;\n    long    start, sz;\n    start = ftell(fp);\n    for (i=0; i<pdf->n_xrefs; i++)\n    {\n        if (pdf->xrefs[i].version && (pdf->xrefs[i].end != 0))\n        {\n            fseek(fp, pdf->xrefs[i].start, SEEK_SET);\n            while (SAFE_F(fp, (fgetc(fp) != 't')))\n                ; \n            sz = pdf->xrefs[i].end - ftell(fp);\n            buf = malloc(sz + 1);\n            SAFE_E(fread(buf, 1, sz, fp), sz, \"Failed to load /Root.\\n\");\n            buf[sz] = '\\0';\n            if (!(c = strstr(buf, \"/Root\")))\n            {\n                free(buf);\n                continue;\n            }\n            id = atoi(c + strlen(\"/Root\") + 1);\n            free(buf);\n            buf = get_object(fp, id, &pdf->xrefs[i], NULL, &dummy);\n            if (!buf || !(c = strstr(buf, \"/Pages\")))\n            {\n                free(buf);\n                continue;\n            }\n            id = atoi(c + strlen(\"/Pages\") + 1);\n            load_kids(fp, id, &pdf->xrefs[i]);\n            free(buf); \n        }\n    }\n    fseek(fp, start, SEEK_SET);\n}", "target": 1}
{"code": "void CharCodeToUnicode::addMapping(CharCode code, char *uStr, int n,\n\t\t\t\t   int offset) {\n  CharCode oldLen, i;\n  Unicode u;\n  char uHex[5];\n  int j;\n  if (code >= mapLen) {\n    oldLen = mapLen;\n    mapLen = (code + 256) & ~255;\n    map = (Unicode *)greallocn(map, mapLen, sizeof(Unicode));\n    for (i = oldLen; i < mapLen; ++i) {\n      map[i] = 0;\n    }\n  }\n  if (n <= 4) {\n    if (sscanf(uStr, \"%x\", &u) != 1) {\n      error(-1, \"Illegal entry in ToUnicode CMap\");\n      return;\n    }\n    map[code] = u + offset;\n  } else {\n    if (sMapLen >= sMapSize) {\n      sMapSize = sMapSize + 16;\n      sMap = (CharCodeToUnicodeString *)\n\t       greallocn(sMap, sMapSize, sizeof(CharCodeToUnicodeString));\n    }\n    map[code] = 0;\n    sMap[sMapLen].c = code;\n    sMap[sMapLen].len = n / 4;\n    for (j = 0; j < sMap[sMapLen].len && j < maxUnicodeString; ++j) {\n      strncpy(uHex, uStr + j*4, 4);\n      uHex[4] = '\\0';\n      if (sscanf(uHex, \"%x\", &sMap[sMapLen].u[j]) != 1) {\n\terror(-1, \"Illegal entry in ToUnicode CMap\");\n      }\n    }\n    sMap[sMapLen].u[sMap[sMapLen].len - 1] += offset;\n    ++sMapLen;\n  }\n}", "target": 1}
{"code": "static long process_cpu_nsleep_restart(struct restart_block *restart_block)\n{\n\treturn -EINVAL;\n}", "target": 0}
{"code": "const char* ewk_view_setting_encoding_custom_get(const Evas_Object* ewkView)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, 0);\n    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv, 0);\n    Evas_Object* main_frame = ewk_view_frame_main_get(ewkView);\n    WebCore::Frame* core_frame = EWKPrivate::coreFrame(main_frame);\n    String overrideEncoding = core_frame->loader()->documentLoader()->overrideEncoding();\n    if (overrideEncoding.isEmpty())\n        return 0;\n    eina_stringshare_replace(&priv->settings.encodingCustom, overrideEncoding.utf8().data());\n    return priv->settings.encodingCustom;\n}", "target": 0}
{"code": "  void connectSuccess() noexcept override {\n    ssl_->writeChain(nullptr, IOBuf::copyBuffer(\"hi\"));\n    auto ssl = const_cast<SSL*>(ssl_->getSSL());\n    SSL_shutdown(ssl);\n    auto fd = ssl_->detachNetworkSocket();\n    tcp_.reset(new AsyncSocket(evb_, fd), AsyncSocket::Destructor());\n    evb_->runAfterDelay(\n        [this]() {\n          perLoopReads_.setSocket(tcp_.get());\n          tcp_->setReadCB(&perLoopReads_);\n          evb_->runAfterDelay([this]() { tcp_->closeNow(); }, 10);\n        },\n        100);\n  }", "target": 0}
{"code": "ikev2_auth_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len _U_, const u_char *ep,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct ikev2_auth a;\n\tconst char *v2_auth[]={ \"invalid\", \"rsasig\",\n\t\t\t\t\"shared-secret\", \"dsssig\" };\n\tconst u_char *authdata = (const u_char*)ext + sizeof(a);\n\tunsigned int len;\n\tND_TCHECK2(*ext, sizeof(a));\n\tUNALIGNED_MEMCPY(&a, ext, sizeof(a));\n\tikev2_pay_print(ndo, NPSTR(tpay), a.h.critical);\n\tlen = ntohs(a.h.len);\n\tND_PRINT((ndo,\" len=%u method=%s\", len-4,\n\t\t  STR_OR_ID(a.auth_method, v2_auth)));\n\tif (len > 4) {\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\tND_PRINT((ndo, \" authdata=(\"));\n\t\t\tif (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))\n\t\t\t\tgoto trunc;\n\t\t\tND_PRINT((ndo, \") \"));\n\t\t} else if (ndo->ndo_vflag) {\n\t\t\tif (!ike_show_somedata(ndo, authdata, ep))\n\t\t\t\tgoto trunc;\n\t\t}\n\t}\n\treturn (const u_char *)ext + len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}", "target": 0}
{"code": "hb_buffer_get_reference_count (hb_buffer_t *buffer)\n{\n  HB_OBJECT_DO_GET_REFERENCE_COUNT (buffer);\n}", "target": 0}
{"code": "static void validate_dex_header(const dex_header* dh,\n                                size_t dexsize,\n                                int support_dex_version) {\n  bool supported = false;\n  switch (support_dex_version) {\n  case 38:\n    supported = supported ||\n                !memcmp(dh->magic, DEX_HEADER_DEXMAGIC_V38, sizeof(dh->magic));\n    FALLTHROUGH_INTENDED; \n  case 37:\n    supported = supported ||\n                !memcmp(dh->magic, DEX_HEADER_DEXMAGIC_V37, sizeof(dh->magic));\n    FALLTHROUGH_INTENDED; \n  case 35:\n    supported = supported ||\n                !memcmp(dh->magic, DEX_HEADER_DEXMAGIC_V35, sizeof(dh->magic));\n    break;\n  default:\n    not_reached_log(\"Unrecognized support_dex_version %d\\n\",\n                    support_dex_version);\n  }\n  always_assert_log(supported, \"Bad dex magic %s for support_dex_version %d\\n\",\n                    dh->magic, support_dex_version);\n  always_assert_log(\n      dh->file_size == dexsize,\n      \"Reported size in header (%zu) does not match file size (%u)\\n\",\n      dexsize,\n      dh->file_size);\n  auto off = (uint64_t)dh->class_defs_off;\n  auto limit = off + dh->class_defs_size * sizeof(dex_class_def);\n  always_assert_log(off < dexsize, \"class_defs_off out of range\");\n  always_assert_log(limit <= dexsize, \"invalid class_defs_size\");\n}", "target": 1}
{"code": "register_disks_device (Device *device)\n{\n  DBusConnection *connection;\n  GError *error = NULL;\n  device->priv->system_bus_connection = dbus_g_bus_get (DBUS_BUS_SYSTEM, &error);\n  if (device->priv->system_bus_connection == NULL)\n    {\n      if (error != NULL)\n        {\n          g_critical (\"error getting system bus: %s\", error->message);\n          g_error_free (error);\n        }\n      goto error;\n    }\n  connection = dbus_g_connection_get_connection (device->priv->system_bus_connection);\n  device->priv->object_path = compute_object_path (device->priv->native_path);\n  if (dbus_g_connection_lookup_g_object (device->priv->system_bus_connection, device->priv->object_path) != NULL)\n    {\n      g_error (\"**** HACK: Wanting to register object at path `%s' but there is already an \"\n               \"object there. This is an internal error in the daemon. Aborting.\\n\", device->priv->object_path);\n    }\n  dbus_g_connection_register_g_object (device->priv->system_bus_connection,\n                                       device->priv->object_path,\n                                       G_OBJECT (device));\n  return TRUE;\n error:\n  return FALSE;\n}", "target": 0}
{"code": "utf32le_mbc_case_fold(OnigCaseFoldType flag,\n\t\t      const UChar** pp, const UChar* end, UChar* fold)\n{\n  const UChar* p = *pp;\n  if (ONIGENC_IS_ASCII_CODE(*p) && *(p+1) == 0 && *(p+2) == 0 && *(p+3) == 0) {\n#ifdef USE_UNICODE_CASE_FOLD_TURKISH_AZERI\n    if ((flag & ONIGENC_CASE_FOLD_TURKISH_AZERI) != 0) {\n      if (*p == 0x49) {\n        *fold++ = 0x31;\n        *fold++ = 0x01;\n      }\n    }\n    else {\n#endif\n      *fold++ = ONIGENC_ASCII_CODE_TO_LOWER_CASE(*p);\n      *fold++ = 0;\n#ifdef USE_UNICODE_CASE_FOLD_TURKISH_AZERI\n    }\n#endif\n    *fold++ = 0;\n    *fold   = 0;\n    *pp += 4;\n    return 4;\n  }\n  else\n    return onigenc_unicode_mbc_case_fold(ONIG_ENCODING_UTF32_LE, flag, pp, end,\n                                         fold);\n}", "target": 0}
{"code": "static int __init fm10k_init_module(void)\n{\n\tpr_info(\"%s - version %s\\n\", fm10k_driver_string, fm10k_driver_version);\n\tpr_info(\"%s\\n\", fm10k_copyright);\n\tfm10k_workqueue = alloc_workqueue(\"%s\", WQ_MEM_RECLAIM, 0,\n\t\t\t\t\t  fm10k_driver_name);\n\tif (!fm10k_workqueue)\n\t\treturn -ENOMEM;\n\tfm10k_dbg_init();\n\treturn fm10k_register_pci_driver();\n}", "target": 0}
{"code": "struct sctp_chunk *sctp_inq_pop(struct sctp_inq *queue)\n{\n\tstruct sctp_chunk *chunk;\n\tsctp_chunkhdr_t *ch = NULL;\n\tif ((chunk = queue->in_progress)) {\n\t\tif (chunk->singleton ||\n\t\t    chunk->end_of_packet ||\n\t\t    chunk->pdiscard) {\n\t\t\tsctp_chunk_free(chunk);\n\t\t\tchunk = queue->in_progress = NULL;\n\t\t} else {\n\t\t\tch = (sctp_chunkhdr_t *) chunk->chunk_end;\n\t\t\tskb_pull(chunk->skb,\n\t\t\t\t chunk->chunk_end - chunk->skb->data);\n\t\t\tif (skb_headlen(chunk->skb) < sizeof(sctp_chunkhdr_t)) {\n\t\t\t\tsctp_chunk_free(chunk);\n\t\t\t\tchunk = queue->in_progress = NULL;\n\t\t\t}\n\t\t}\n\t}\n\tif (!chunk) {\n\t\tstruct list_head *entry;\n\t\tif (list_empty(&queue->in_chunk_list))\n\t\t\treturn NULL;\n\t\tentry = queue->in_chunk_list.next;\n\t\tchunk = queue->in_progress =\n\t\t\tlist_entry(entry, struct sctp_chunk, list);\n\t\tlist_del_init(entry);\n\t\tchunk->singleton = 1;\n\t\tch = (sctp_chunkhdr_t *) chunk->skb->data;\n\t\tchunk->data_accepted = 0;\n\t}\n\tchunk->chunk_hdr = ch;\n\tchunk->chunk_end = ((__u8 *)ch) + WORD_ROUND(ntohs(ch->length));\n\tif (unlikely(skb_is_nonlinear(chunk->skb))) {\n\t\tif (chunk->chunk_end > skb_tail_pointer(chunk->skb))\n\t\t\tchunk->chunk_end = skb_tail_pointer(chunk->skb);\n\t}\n\tskb_pull(chunk->skb, sizeof(sctp_chunkhdr_t));\n\tchunk->subh.v = NULL; \n\tif (chunk->chunk_end < skb_tail_pointer(chunk->skb)) {\n\t\tchunk->singleton = 0;\n\t} else if (chunk->chunk_end > skb_tail_pointer(chunk->skb)) {\n\t\tsctp_chunk_free(chunk);\n\t\tchunk = queue->in_progress = NULL;\n\t\treturn NULL;\n\t} else {\n\t\tchunk->end_of_packet = 1;\n\t}\n\tpr_debug(\"+++sctp_inq_pop+++ chunk:%p[%s], length:%d, skb->len:%d\\n\",\n\t\t chunk, sctp_cname(SCTP_ST_CHUNK(chunk->chunk_hdr->type)),\n\t\t ntohs(chunk->chunk_hdr->length), chunk->skb->len);\n\treturn chunk;\n}", "target": 1}
{"code": "static void ssl_calc_finished_tls(\n                ssl_context *ssl, unsigned char *buf, int from )\n{\n    int len = 12;\n    char *sender;\n    md5_context  md5;\n    sha1_context sha1;\n    unsigned char padbuf[36];\n    ssl_session *session = ssl->session_negotiate;\n    if( !session )\n        session = ssl->session;\n    SSL_DEBUG_MSG( 2, ( \"=> calc  finished tls\" ) );\n    memcpy( &md5 , &ssl->handshake->fin_md5 , sizeof(md5_context)  );\n    memcpy( &sha1, &ssl->handshake->fin_sha1, sizeof(sha1_context) );\n    SSL_DEBUG_BUF( 4, \"finished  md5 state\", (unsigned char *)\n                    md5.state, sizeof(  md5.state ) );\n    SSL_DEBUG_BUF( 4, \"finished sha1 state\", (unsigned char *)\n                   sha1.state, sizeof( sha1.state ) );\n    sender = ( from == SSL_IS_CLIENT )\n             ? (char *) \"client finished\"\n             : (char *) \"server finished\";\n    md5_finish(  &md5, padbuf );\n    sha1_finish( &sha1, padbuf + 16 );\n    ssl->handshake->tls_prf( session->master, 48, sender,\n                             padbuf, 36, buf, len );\n    SSL_DEBUG_BUF( 3, \"calc finished result\", buf, len );\n    memset(  &md5, 0, sizeof(  md5_context ) );\n    memset( &sha1, 0, sizeof( sha1_context ) );\n    memset(  padbuf, 0, sizeof(  padbuf ) );\n    SSL_DEBUG_MSG( 2, ( \"<= calc  finished\" ) );\n}", "target": 0}
{"code": "slice_unit::slice_unit(decoder_context* decctx)\n  : nal(NULL),\n    shdr(NULL),\n    imgunit(NULL),\n    flush_reorder_buffer(false),\n    nThreads(0),\n    first_decoded_CTB_RS(-1),\n    last_decoded_CTB_RS(-1),\n    thread_contexts(NULL),\n    ctx(decctx)\n{\n  state = Unprocessed;\n  nThreadContexts = 0;\n}", "target": 0}
{"code": "const char *osdp_reply_name(int reply_id)\n{\n\tconst char *name;\n\tstatic const char * const names[] = {\n\t\t[REPLY_ACK       - REPLY_ACK] = \"ACK\",\n\t\t[REPLY_NAK       - REPLY_ACK] = \"NAK\",\n\t\t[REPLY_PDID      - REPLY_ACK] = \"PDID\",\n\t\t[REPLY_PDCAP     - REPLY_ACK] = \"PDCAP\",\n\t\t[REPLY_LSTATR    - REPLY_ACK] = \"LSTATR\",\n\t\t[REPLY_ISTATR    - REPLY_ACK] = \"ISTATR\",\n\t\t[REPLY_OSTATR    - REPLY_ACK] = \"OSTATR\",\n\t\t[REPLY_RSTATR    - REPLY_ACK] = \"RSTATR\",\n\t\t[REPLY_RAW       - REPLY_ACK] = \"RAW\",\n\t\t[REPLY_FMT       - REPLY_ACK] = \"FMT\",\n\t\t[REPLY_KEYPPAD   - REPLY_ACK] = \"KEYPPAD\",\n\t\t[REPLY_COM       - REPLY_ACK] = \"COM\",\n\t\t[REPLY_BIOREADR  - REPLY_ACK] = \"BIOREADR\",\n\t\t[REPLY_BIOMATCHR - REPLY_ACK] = \"BIOMATCHR\",\n\t\t[REPLY_CCRYPT    - REPLY_ACK] = \"CCRYPT\",\n\t\t[REPLY_RMAC_I    - REPLY_ACK] = \"RMAC_I\",\n\t\t[REPLY_FTSTAT    - REPLY_ACK] = \"FTSTAT\",\n\t\t[REPLY_MFGREP    - REPLY_ACK] = \"MFGREP\",\n\t\t[REPLY_BUSY      - REPLY_ACK] = \"BUSY\",\n\t\t[REPLY_PIVDATAR  - REPLY_ACK] = \"PIVDATA\",\n\t\t[REPLY_CRAUTHR   - REPLY_ACK] = \"CRAUTH\",\n\t\t[REPLY_MFGSTATR  - REPLY_ACK] = \"MFGSTATR\",\n\t\t[REPLY_MFGERRR   - REPLY_ACK] = \"MFGERR\",\n\t\t[REPLY_XRD       - REPLY_ACK] = \"XRD\",\n\t};\n\tif (reply_id < REPLY_ACK || reply_id > REPLY_XRD) {\n\t\treturn \"INVALID\";\n\t}\n\tname = names[reply_id - REPLY_ACK];\n\tif (name[0] == '\\0') {\n\t\treturn \"UNKNOWN\";\n\t}\n\treturn name;\n}", "target": 1}
{"code": "rrdp_process_deltas(struct update_notification *parent,\n    unsigned long cur_serial, struct visited_uris *visited_uris,\n    bool log_operation)\n{\n\tstruct proc_upd_args args;\n\targs.parent = parent;\n\targs.visited_uris = visited_uris;\n\targs.log_operation = log_operation;\n\treturn deltas_head_for_each(parent->deltas_list,\n\t    parent->global_data.serial, cur_serial, process_delta, &args);\n}", "target": 1}
{"code": "flatpak_bwrap_envp_to_args (FlatpakBwrap *bwrap)\n{\n  gsize i;\n  for (i = 0; bwrap->envp[i] != NULL; i++)\n    {\n      char *key_val = bwrap->envp[i];\n      char *eq = strchr (key_val, '=');\n      if (eq)\n        {\n          flatpak_bwrap_add_arg (bwrap, \"--setenv\");\n          flatpak_bwrap_take_arg (bwrap, g_strndup (key_val, eq - key_val));\n          flatpak_bwrap_add_arg (bwrap, eq + 1);\n        }\n      else\n        {\n          g_warn_if_reached ();\n        }\n    }\n  g_strfreev (g_steal_pointer (&bwrap->envp));\n  bwrap->envp = g_strdupv (flatpak_bwrap_empty_env);\n}", "target": 0}
{"code": "header_put_le_short (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 2)\n\t{\tpsf->header [psf->headindex++] = x ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\t} ;\n} ", "target": 1}
{"code": "static UINT drive_process_irp_query_directory(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tconst WCHAR* path;\n\tDRIVE_FILE* file;\n\tBYTE InitialQuery;\n\tUINT32 PathLength;\n\tUINT32 FsInformationClass;\n\tif (!drive || !irp || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\tStream_Read_UINT32(irp->input, FsInformationClass);\n\tStream_Read_UINT8(irp->input, InitialQuery);\n\tStream_Read_UINT32(irp->input, PathLength);\n\tStream_Seek(irp->input, 23); \n\tpath = (WCHAR*)Stream_Pointer(irp->input);\n\tif (!Stream_CheckAndLogRequiredLength(TAG, irp->input, PathLength))\n\t\treturn ERROR_INVALID_DATA;\n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\tif (file == NULL)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tStream_Write_UINT32(irp->output, 0); \n\t}\n\telse if (!drive_file_query_directory(file, FsInformationClass, InitialQuery, path,\n\t                                     PathLength / sizeof(WCHAR), irp->output))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t}\n\treturn irp->Complete(irp);\n}", "target": 0}
{"code": "code_to_mbclen(OnigCodePoint code, OnigEncoding enc ARG_UNUSED)\n{\n  if      ((code & 0xffffff80) == 0) return 1;\n  else if ((code & 0xfffff800) == 0) return 2;\n  else if ((code & 0xffff0000) == 0) return 3;\n  else if ((code & 0xffe00000) == 0) return 4;\n  else if ((code & 0xfc000000) == 0) return 5;\n  else if ((code & 0x80000000) == 0) return 6;\n#ifdef USE_INVALID_CODE_SCHEME\n  else if (code == INVALID_CODE_FE) return 1;\n  else if (code == INVALID_CODE_FF) return 1;\n#endif\n  else\n    return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE;\n}", "target": 0}
{"code": "bool ECDSA_Verification_Operation::verify(const uint8_t msg[], size_t msg_len,\n                                          const uint8_t sig[], size_t sig_len)\n   {\n   if(sig_len != m_group.get_order_bytes() * 2)\n      return false;\n   const BigInt e(msg, msg_len, m_group.get_order_bits());\n   const BigInt r(sig, sig_len / 2);\n   const BigInt s(sig + sig_len / 2, sig_len / 2);\n   if(r <= 0 || r >= m_group.get_order() || s <= 0 || s >= m_group.get_order())\n      return false;\n   const BigInt w = m_group.inverse_mod_order(s);\n   const BigInt u1 = m_group.multiply_mod_order(e, w);\n   const BigInt u2 = m_group.multiply_mod_order(r, w);\n   const PointGFp R = m_gy_mul.multi_exp(u1, u2);\n   if(R.is_zero())\n      return false;\n   const BigInt v = m_group.mod_order(R.get_affine_x());\n   return (v == r);\n   }", "target": 1}
{"code": "const AtomicString& HTMLInputElement::defaultValue() const\n{\n    return fastGetAttribute(valueAttr);\n}", "target": 0}
{"code": "static int ldb_msg_append_value_impl(struct ldb_message *msg,\n\t\t\t\t     const char *attr_name,\n\t\t\t\t     const struct ldb_val *val,\n\t\t\t\t     int flags,\n\t\t\t\t     struct ldb_message_element **return_el)\n{\n\tstruct ldb_message_element *el = NULL;\n\tint ret;\n\tret = ldb_msg_add_empty(msg, attr_name, flags, &el);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tret = ldb_msg_element_add_value(msg->elements, el, val);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tif (return_el != NULL) {\n\t\t*return_el = el;\n\t}\n\treturn LDB_SUCCESS;\n}", "target": 0}
{"code": "int intel_execlists_submission_setup(struct intel_engine_cs *engine)\n{\n\ttasklet_init(&engine->execlists.tasklet,\n\t\t     execlists_submission_tasklet, (unsigned long)engine);\n\ttimer_setup(&engine->execlists.timer, execlists_timeslice, 0);\n\ttimer_setup(&engine->execlists.preempt, execlists_preempt, 0);\n\tlogical_ring_default_vfuncs(engine);\n\tlogical_ring_default_irqs(engine);\n\tif (engine->class == RENDER_CLASS)\n\t\trcs_submission_override(engine);\n\treturn 0;\n}", "target": 0}
{"code": "static std::string WrapWithTH(std::string text) {\n  return \"<th>\" + text + \"</th>\";\n}", "target": 0}
{"code": "static PHP_NAMED_FUNCTION(zif_zip_entry_read)\n{\n\tzval * zip_entry;\n\tzend_long len = 0;\n\tzip_read_rsrc * zr_rsrc;\n\tzend_string *buffer;\n\tint n = 0;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"r|l\", &zip_entry, &len) == FAILURE) {\n\t\treturn;\n\t}\n\tif ((zr_rsrc = (zip_read_rsrc *)zend_fetch_resource(Z_RES_P(zip_entry), le_zip_entry_name, le_zip_entry)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tif (len <= 0) {\n\t\tlen = 1024;\n\t}\n\tif (zr_rsrc->zf) {\n\t\tbuffer = zend_string_alloc(len, 0);\n\t\tn = zip_fread(zr_rsrc->zf, ZSTR_VAL(buffer), ZSTR_LEN(buffer));\n\t\tif (n > 0) {\n\t\t\tZSTR_VAL(buffer)[n] = '\\0';\n\t\t\tZSTR_LEN(buffer) = n;\n\t\t\tRETURN_NEW_STR(buffer);\n\t\t} else {\n\t\t\tzend_string_free(buffer);\n\t\t\tRETURN_EMPTY_STRING()\n\t\t}\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}", "target": 1}
{"code": "static inline int dpt_dma64(adpt_hba *pHba)\n{\n\treturn (sizeof(dma_addr_t) > 4 && (pHba)->dma64);\n}", "target": 1}
{"code": "int lxc_switch_uid_gid(uid_t uid, gid_t gid)\n{\n\tif (setgid(gid) < 0) {\n\t\tSYSERROR(\"Failed to switch to gid %d.\", gid);\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Switched to gid %d.\", gid);\n\tif (setuid(uid) < 0) {\n\t\tSYSERROR(\"Failed to switch to uid %d.\", uid);\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Switched to uid %d.\", uid);\n\treturn 0;\n}", "target": 0}
{"code": "static void bdrv_cloop_init(void)\n{\n    bdrv_register(&bdrv_cloop);\n}", "target": 0}
{"code": "SSLNetVConnection::populate_protocol(std::string_view *results, int n) const\n{\n  int retval = 0;\n  if (n > retval) {\n    results[retval] = map_tls_protocol_to_tag(getSSLProtocol());\n    if (!results[retval].empty()) {\n      ++retval;\n    }\n    if (n > retval) {\n      retval += super::populate_protocol(results + retval, n - retval);\n    }\n  }\n  return retval;\n}", "target": 0}
{"code": "FPDF_SYSTEMTIME PDFiumEngine::Form_GetLocalTime(FPDF_FORMFILLINFO* param) {\n  base::Time time = base::Time::Now();\n  base::Time::Exploded exploded;\n  time.LocalExplode(&exploded);\n  FPDF_SYSTEMTIME rv;\n  rv.wYear = exploded.year;\n  rv.wMonth = exploded.month;\n  rv.wDayOfWeek = exploded.day_of_week;\n  rv.wDay = exploded.day_of_month;\n  rv.wHour = exploded.hour;\n  rv.wMinute = exploded.minute;\n  rv.wSecond = exploded.second;\n  rv.wMilliseconds = exploded.millisecond;\n  return rv;\n}", "target": 0}
{"code": " */\nstatic void re_yyensure_buffer_stack (yyscan_t yyscanner)\n{\n\tyy_size_t num_to_alloc;\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\tif (!yyg->yy_buffer_stack) {\n\t\tnum_to_alloc = 1; \n\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)re_yyalloc\n\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t, yyscanner);\n\t\tif ( ! yyg->yy_buffer_stack )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in re_yyensure_buffer_stack()\" );\n\t\tmemset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n\t\tyyg->yy_buffer_stack_max = num_to_alloc;\n\t\tyyg->yy_buffer_stack_top = 0;\n\t\treturn;\n\t}\n\tif (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){\n\t\tyy_size_t grow_size = 8 ;\n\t\tnum_to_alloc = yyg->yy_buffer_stack_max + grow_size;\n\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)re_yyrealloc\n\t\t\t\t\t\t\t\t(yyg->yy_buffer_stack,\n\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t, yyscanner);\n\t\tif ( ! yyg->yy_buffer_stack )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in re_yyensure_buffer_stack()\" );\n\t\tmemset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));\n\t\tyyg->yy_buffer_stack_max = num_to_alloc;\n\t}", "target": 1}
{"code": "bool CmdExtract::ExtractFileCopy(File &New,wchar *ArcName,const wchar *RedirName,wchar *NameNew,wchar *NameExisting,size_t NameExistingSize,int64 UnpSize)\n{\n  SlashToNative(NameExisting,NameExisting,NameExistingSize); \n  File Existing;\n  if (!Existing.Open(NameExisting))\n  {\n    bool OpenFailed=true;\n    for (size_t I=0;I<RefList.Size();I++)\n      if (wcscmp(RedirName,RefList[I].RefName)==0 && RefList[I].TmpName!=NULL)\n      {\n        bool RefMove=RefList[I].RefCount-- == 1;\n        NameExisting=RefList[I].TmpName;\n        if (RefMove) \n        {\n          New.Delete(); \n          bool MoveFailed=!RenameFile(NameExisting,NameNew);\n          if (MoveFailed)\n          {\n            if (!New.WCreate(NameNew,FMF_WRITE|FMF_SHAREREAD))\n              return false;\n            RefMove=false; \n          }\n          else\n          {\n            if (New.Open(NameNew))\n              New.Seek(0,SEEK_END);\n            free(RefList[I].TmpName);\n            RefList[I].TmpName=NULL;\n            return true;\n          }\n        }\n        if (!RefMove)\n          OpenFailed=!Existing.Open(NameExisting);\n        break;\n      }\n    if (OpenFailed)\n    {\n      ErrHandler.OpenErrorMsg(NameExisting);\n      uiMsg(UIERROR_FILECOPY,ArcName,NameExisting,NameNew);\n      uiMsg(UIERROR_FILECOPYHINT,ArcName);\n#ifdef RARDLL\n      Cmd->DllError=ERAR_EREFERENCE;\n#endif\n      return false;\n    }\n  }\n  Array<byte> Buffer(0x100000);\n  int64 CopySize=0;\n  while (true)\n  {\n    Wait();\n    int ReadSize=Existing.Read(&Buffer[0],Buffer.Size());\n    if (ReadSize==0)\n      break;\n    uiExtractProgress(CopySize,UnpSize,0,0);\n    New.Write(&Buffer[0],ReadSize);\n    CopySize+=ReadSize;\n  }\n  return true;\n}", "target": 1}
{"code": "static void fuse_lib_setxattr(fuse_req_t req, fuse_ino_t ino, const char *name,\n                              const char *value, size_t size, int flags)\n{\n    struct fuse *f = req_fuse_prepare(req);\n    char *path;\n    int err;\n    err = -ENOENT;\n    pthread_rwlock_rdlock(&f->tree_lock);\n    path = get_path(f, ino);\n    if (path != NULL) {\n        struct fuse_intr_data d;\n        fuse_prepare_interrupt(f, req, &d);\n        err = fuse_fs_setxattr(f->fs, path, name, value, size, flags);\n        fuse_finish_interrupt(f, req, &d);\n        free(path);\n    }\n    pthread_rwlock_unlock(&f->tree_lock);\n    reply_err(req, err);\n}", "target": 0}
{"code": "acl_fetch_stver(struct proxy *px, struct session *l4, void *l7, int dir,\n                struct acl_expr *expr, struct acl_test *test)\n{\n\tstruct http_txn *txn = l7;\n\tchar *ptr;\n\tint len;\n\tif (!txn)\n\t\treturn 0;\n\tif (txn->rsp.msg_state < HTTP_MSG_BODY)\n\t\treturn 0;\n\tlen = txn->rsp.sl.st.v_l;\n\tptr = txn->rsp.sol;\n\twhile ((len-- > 0) && (*ptr++ != '/'));\n\tif (len <= 0)\n\t\treturn 0;\n\ttest->ptr = ptr;\n\ttest->len = len;\n\ttest->flags = ACL_TEST_F_READ_ONLY | ACL_TEST_F_VOL_1ST;\n\treturn 1;\n}", "target": 0}
{"code": "static void lent_destructor(void *arg)\n{\n\tstruct lookup_entry *lent = arg;\n\tmem_deref(lent->host);\n}", "target": 0}
{"code": "mptctl_eventenable (unsigned long arg)\n{\n\tstruct mpt_ioctl_eventenable __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_eventenable\t karg;\n\tMPT_ADAPTER *ioc;\n\tint iocnum;\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_eventenable))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_eventenable - \"\n\t\t\t\"Unable to read in mpt_ioctl_eventenable struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_eventenable() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_eventenable called.\\n\",\n\t    ioc->name));\n\tif (ioc->events == NULL) {\n\t\tint sz = MPTCTL_EVENT_LOG_SIZE * sizeof(MPT_IOCTL_EVENTS);\n\t\tioc->events = kzalloc(sz, GFP_KERNEL);\n\t\tif (!ioc->events) {\n\t\t\tprintk(MYIOC_s_ERR_FMT\n\t\t\t    \": ERROR - Insufficient memory to add adapter!\\n\",\n\t\t\t    ioc->name);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tioc->alloc_total += sz;\n\t\tioc->eventContext = 0;\n        }\n\tioc->eventTypes = karg.eventTypes;\n\treturn 0;\n}", "target": 1}
{"code": "static int edit_ext(char* editor, char* name, char* date, char* data)\n{\n\tint fd;\n\tint st;\n\tint sz;\n\tchar* b;\n\tchar* l;\n\tchar buff[512];\n\tpid_t pid;\n\tstrcpy(buff,\"/tmp/nodau.XXXXXX\");\n\tfd = mkstemp(buff);\n\tif (fd < 0)\n\t\treturn 1;\n\tpid = fork();\n\tif (pid < 0) {\n\t\treturn 1;\n\t}else if (pid) {\n\t\tclose(fd);\n\t\twaitpid(pid,&st,0);\n\t\tif (!st) {\n\t\t\tif ((fd = open(buff,O_RDONLY)) < 0)\n\t\t\t\treturn 1;\n\t\t\tsz = lseek(fd,0,SEEK_END);\n\t\t\tlseek(fd,0,SEEK_SET);\n\t\t\tif (sz) {\n\t\t\t\tb = alloca(sz+1);\n\t\t\t\tif (sz != read(fd,b,sz))\n\t\t\t\t\treturn 1;\n\t\t\t\tclose(fd);\n\t\t\t\tremove(buff);\n\t\t\t\tb[sz] = 0;\n\t\t\t\tl = strstr(b,\"-----\");\n\t\t\t\tif (l) {\n\t\t\t\t\tl += 6;\n\t\t\t\t\tif (db_update(name,l))\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\tprintf(\"%s saved\\n\",name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn st;\n\t}\n\tsz = strlen(name)+strlen(date)+strlen(data)+50;\n\tb = alloca(sz);\n\tsz = sprintf(\n\t\tb,\n\t\t\"%s (%s)\\nText above this line is ignored\\n-----\\n%s\",\n\t\tname,\n\t\tdate,\n\t\tdata\n\t);\n\tif (write(fd,b,sz) != sz) {\n\t\texit(1);\n\t}\n\tfsync(fd);\n\tclose(fd);\n\tst = execl(editor,editor,buff,(char*)NULL);\n\texit(st);\n\treturn 1;\n}", "target": 1}
{"code": "static void do_free_keypair(struct rsa_keypair *s)\n{\n\tsss_status_t st = kStatus_SSS_Fail;\n\tsss_se05x_object_t k_object = { };\n\tuint32_t key_id = 0;\n\tif (!s)\n\t\treturn;\n\tkey_id = se050_rsa_keypair_from_nvm(s);\n\tif (key_id) {\n\t\tst = sss_se05x_key_object_get_handle(&k_object, key_id);\n\t\tif (st == kStatus_SSS_Success)\n\t\t\tsss_se05x_key_store_erase_key(se050_kstore, &k_object);\n\t}\n\tcrypto_bignum_free(s->e);\n\tcrypto_bignum_free(s->d);\n\tcrypto_bignum_free(s->n);\n\tcrypto_bignum_free(s->p);\n\tcrypto_bignum_free(s->q);\n\tcrypto_bignum_free(s->qp);\n\tcrypto_bignum_free(s->dp);\n\tcrypto_bignum_free(s->dq);\n}", "target": 1}
{"code": "GF_Box *prft_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ProducerReferenceTimeBox, GF_ISOM_BOX_TYPE_PRFT);\n\treturn (GF_Box *)tmp;\n}", "target": 0}
{"code": "static struct nfs4_opendata *nfs4_open_recoverdata_alloc(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs4_opendata *opendata;\n\topendata = nfs4_opendata_alloc(&ctx->path, state->owner, 0, NULL);\n\tif (opendata == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\topendata->state = state;\n\tatomic_inc(&state->count);\n\treturn opendata;\n}", "target": 1}
{"code": "catch_handler_set(codegen_scope *s, int ent, enum mrb_catch_type type, uint32_t begin, uint32_t end, uint32_t target)\n{\n  struct mrb_irep_catch_handler *e;\n  mrb_assert(ent >= 0 && ent < s->irep->clen);\n  e = &s->catch_table[ent];\n  uint8_to_bin(type, &e->type);\n  mrb_irep_catch_handler_pack(begin, e->begin);\n  mrb_irep_catch_handler_pack(end, e->end);\n  mrb_irep_catch_handler_pack(target, e->target);\n}", "target": 0}
{"code": "PHPAPI zend_string *php_escape_shell_cmd(char *str)\n{\n\tregister int x, y, l = (int)strlen(str);\n\tsize_t estimate = (2 * l) + 1;\n\tzend_string *cmd;\n#ifndef PHP_WIN32\n\tchar *p = NULL;\n#endif\n\tcmd = zend_string_alloc(2 * l, 0);\n\tfor (x = 0, y = 0; x < l; x++) {\n\t\tint mb_len = php_mblen(str + x, (l - x));\n\t\tif (mb_len < 0) {\n\t\t\tcontinue;\n\t\t} else if (mb_len > 1) {\n\t\t\tmemcpy(ZSTR_VAL(cmd) + y, str + x, mb_len);\n\t\t\ty += mb_len;\n\t\t\tx += mb_len - 1;\n\t\t\tcontinue;\n\t\t}\n\t\tswitch (str[x]) {\n#ifndef PHP_WIN32\n\t\t\tcase '\"':\n\t\t\tcase '\\'':\n\t\t\t\tif (!p && (p = memchr(str + x + 1, str[x], l - x - 1))) {\n\t\t\t\t} else if (p && *p == str[x]) {\n\t\t\t\t\tp = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tZSTR_VAL(cmd)[y++] = '\\\\';\n\t\t\t\t}\n\t\t\t\tZSTR_VAL(cmd)[y++] = str[x];\n\t\t\t\tbreak;\n#else\n\t\t\tcase '%':\n\t\t\tcase '!':\n\t\t\tcase '\"':\n\t\t\tcase '\\'':\n#endif\n\t\t\tcase '#': \n\t\t\tcase '&':\n\t\t\tcase ';':\n\t\t\tcase '`':\n\t\t\tcase '|':\n\t\t\tcase '*':\n\t\t\tcase '?':\n\t\t\tcase '~':\n\t\t\tcase '<':\n\t\t\tcase '>':\n\t\t\tcase '^':\n\t\t\tcase '(':\n\t\t\tcase ')':\n\t\t\tcase '[':\n\t\t\tcase ']':\n\t\t\tcase '{':\n\t\t\tcase '}':\n\t\t\tcase '$':\n\t\t\tcase '\\\\':\n\t\t\tcase '\\x0A': \n\t\t\tcase '\\xFF':\n#ifdef PHP_WIN32\n\t\t\t\tZSTR_VAL(cmd)[y++] = '^';\n#else\n\t\t\t\tZSTR_VAL(cmd)[y++] = '\\\\';\n#endif\n\t\t\tdefault:\n\t\t\t\tZSTR_VAL(cmd)[y++] = str[x];\n\t\t}\n\t}\n\tZSTR_VAL(cmd)[y] = '\\0';\n\tif ((estimate - y) > 4096) {\n\t\tcmd = zend_string_truncate(cmd, y, 0);\n\t}\n\tZSTR_LEN(cmd) = y;\n\treturn cmd;\n}", "target": 1}
{"code": "_pdfioDictSetValue(\n    pdfio_dict_t   *dict,\t\t\n    const char     *key,\t\t\n    _pdfio_value_t *value)\t\t\n{\n  _pdfio_pair_t\t*pair;\t\t\t\n  PDFIO_DEBUG(\"_pdfioDictSetValue(dict=%p, key=\\\"%s\\\", value=%p)\\n\", dict, key, (void *)value);\n  if (dict->num_pairs > 0)\n  {\n    _pdfio_pair_t\tpkey;\t\t\n    pkey.key = key;\n    if ((pair = (_pdfio_pair_t *)bsearch(&pkey, dict->pairs, dict->num_pairs, sizeof(_pdfio_pair_t), (int (*)(const void *, const void *))compare_pairs)) != NULL)\n    {\n      PDFIO_DEBUG(\"_pdfioDictSetValue: Replacing existing value.\\n\");\n      if (pair->value.type == PDFIO_VALTYPE_BINARY)\n        free(pair->value.value.binary.data);\n      pair->value = *value;\n      return (true);\n    }\n  }\n  if (dict->num_pairs >= dict->alloc_pairs)\n  {\n    _pdfio_pair_t *temp = (_pdfio_pair_t *)realloc(dict->pairs, (dict->alloc_pairs + 8) * sizeof(_pdfio_pair_t));\n    if (!temp)\n    {\n      PDFIO_DEBUG(\"_pdfioDictSetValue: Out of memory.\\n\");\n      return (false);\n    }\n    dict->pairs       = temp;\n    dict->alloc_pairs += 8;\n  }\n  pair = dict->pairs + dict->num_pairs;\n  dict->num_pairs ++;\n  pair->key   = key;\n  pair->value = *value;\n  if (dict->num_pairs > 1 && compare_pairs(pair - 1, pair) > 0)\n    qsort(dict->pairs, dict->num_pairs, sizeof(_pdfio_pair_t), (int (*)(const void *, const void *))compare_pairs);\n#ifdef DEBUG\n  PDFIO_DEBUG(\"_pdfioDictSetValue(%p): %lu pairs\\n\", (void *)dict, (unsigned long)dict->num_pairs);\n  PDFIO_DEBUG(\"_pdfioDictSetValue(%p): \", (void *)dict);\n  PDFIO_DEBUG_DICT(dict);\n  PDFIO_DEBUG(\"\\n\");\n#endif \n  return (true);\n}", "target": 1}
{"code": "int nfc_genl_fw_download_done(struct nfc_dev *dev, const char *firmware_name,\n\t\t\t      u32 result)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_CMD_FW_DOWNLOAD);\n\tif (!hdr)\n\t\tgoto free_msg;\n\tif (nla_put_string(msg, NFC_ATTR_FIRMWARE_NAME, firmware_name) ||\n\t    nla_put_u32(msg, NFC_ATTR_FIRMWARE_DOWNLOAD_STATUS, result) ||\n\t    nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\tgenlmsg_end(msg, hdr);\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\treturn 0;\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "static pdf_creator_t *new_creator(int *n_elements)\n{\n    pdf_creator_t *daddy;\n    static const pdf_creator_t creator_template[] = \n    {\n        {\"Title\",        \"\"},\n        {\"Author\",       \"\"},\n        {\"Subject\",      \"\"},\n        {\"Keywords\",     \"\"},\n        {\"Creator\",      \"\"},\n        {\"Producer\",     \"\"},\n        {\"CreationDate\", \"\"},\n        {\"ModDate\",      \"\"},\n        {\"Trapped\",      \"\"},\n    };\n    daddy = malloc(sizeof(creator_template));\n    memcpy(daddy, creator_template, sizeof(creator_template));\n    if (n_elements)\n      *n_elements = sizeof(creator_template) / sizeof(creator_template[0]);\n    return daddy;\n}", "target": 1}
{"code": "static int set_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)\n{\n\tint ret;\n\tret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_SET_REGS, PEGASUS_REQT_WRITE, 0,\n\t\t\t      indx, data, size, 100);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\treturn ret;\n}", "target": 1}
{"code": "read_pbm_integer(j_compress_ptr cinfo, FILE *infile, unsigned int maxval)\n{\n  register int ch;\n  register unsigned int val;\n  do {\n    ch = pbm_getc(infile);\n    if (ch == EOF)\n      ERREXIT(cinfo, JERR_INPUT_EOF);\n  } while (ch == ' ' || ch == '\\t' || ch == '\\n' || ch == '\\r');\n  if (ch < '0' || ch > '9')\n    ERREXIT(cinfo, JERR_PPM_NONNUMERIC);\n  val = ch - '0';\n  while ((ch = pbm_getc(infile)) >= '0' && ch <= '9') {\n    val *= 10;\n    val += ch - '0';\n  }\n  if (val > maxval)\n    ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n  return val;\n}", "target": 1}
{"code": "void IdentifierHashTable::growAndRehash(uint32_t newCapacity) {\n  if (LLVM_UNLIKELY(newCapacity <= capacity())) {\n    hermes_fatal(\"too many identifiers created\");\n  }\n  assert(llvh::isPowerOf2_32(newCapacity) && \"capacity must be power of 2\");\n  CompactTable tmpTable(newCapacity, table_.getCurrentScale());\n  tmpTable.swap(table_);\n  for (uint32_t oldIdx = 0; oldIdx < tmpTable.size(); ++oldIdx) {\n    if (!tmpTable.isValid(oldIdx)) {\n      continue;\n    }\n    uint32_t idx = 0;\n    uint32_t oldVal = tmpTable.get(oldIdx);\n    auto &lookupTableEntry = identifierTable_->getLookupTableEntry(oldVal);\n    uint32_t hash = lookupTableEntry.getHash();\n    if (lookupTableEntry.isStringPrim()) {\n      idx = lookupString(lookupTableEntry.getStringPrim(), hash, true);\n    } else if (lookupTableEntry.isLazyASCII()) {\n      idx = lookupString(lookupTableEntry.getLazyASCIIRef(), hash, true);\n    } else if (lookupTableEntry.isLazyUTF16()) {\n      idx = lookupString(lookupTableEntry.getLazyUTF16Ref(), hash, true);\n    }\n    table_.set(idx, oldVal);\n  }\n  nonEmptyEntryCount_ = size_;\n}", "target": 0}
{"code": "static int gasp_source_id(__be32 *p)\n{\n\treturn be32_to_cpu(p[0]) >> 16;\n}", "target": 0}
{"code": "static int rfcomm_get_dev_list(void __user *arg)\n{\n\tstruct rfcomm_dev *dev;\n\tstruct rfcomm_dev_list_req *dl;\n\tstruct rfcomm_dev_info *di;\n\tint n = 0, size, err;\n\tu16 dev_num;\n\tBT_DBG(\"\");\n\tif (get_user(dev_num, (u16 __user *) arg))\n\t\treturn -EFAULT;\n\tif (!dev_num || dev_num > (PAGE_SIZE * 4) / sizeof(*di))\n\t\treturn -EINVAL;\n\tsize = sizeof(*dl) + dev_num * sizeof(*di);\n\tdl = kmalloc(size, GFP_KERNEL);\n\tif (!dl)\n\t\treturn -ENOMEM;\n\tdi = dl->dev_info;\n\tspin_lock(&rfcomm_dev_lock);\n\tlist_for_each_entry(dev, &rfcomm_dev_list, list) {\n\t\tif (test_bit(RFCOMM_TTY_RELEASED, &dev->flags))\n\t\t\tcontinue;\n\t\t(di + n)->id      = dev->id;\n\t\t(di + n)->flags   = dev->flags;\n\t\t(di + n)->state   = dev->dlc->state;\n\t\t(di + n)->channel = dev->channel;\n\t\tbacpy(&(di + n)->src, &dev->src);\n\t\tbacpy(&(di + n)->dst, &dev->dst);\n\t\tif (++n >= dev_num)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&rfcomm_dev_lock);\n\tdl->dev_num = n;\n\tsize = sizeof(*dl) + n * sizeof(*di);\n\terr = copy_to_user(arg, dl, size);\n\tkfree(dl);\n\treturn err ? -EFAULT : 0;\n}", "target": 1}
{"code": "int main()\n{\n    gdImagePtr src, dst;\n    int size;\n    src = gdImageCreateTrueColor(1, 10);\n    gdTestAssert(src != NULL);\n    src->sx = 0; \n    dst = gdImageJpegPtr(src, &size, 0);\n    gdTestAssert(dst == NULL);\n    gdImageDestroy(src);\n    return gdNumFailures();\n}", "target": 0}
{"code": "static void add_offer_options(uint8_t *option_start_address)\n{\n\tuint8_t *temp_option_addr;\n\ttemp_option_addr = fill_one_option_content(option_start_address,\n\t\t\tDHCP_OPTION_CODE_SUBNET_MASK, DHCP_OPTION_LENGTH_FOUR,\n\t\t\t\t\t(void *)&dhcps_local_mask);\n\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n\t\t\tDHCP_OPTION_CODE_ROUTER, DHCP_OPTION_LENGTH_FOUR,\n\t\t\t\t\t(void *)&dhcps_local_address);\n\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n\t\t\tDHCP_OPTION_CODE_DNS_SERVER, DHCP_OPTION_LENGTH_FOUR,\n\t\t\t\t\t(void *)&dhcps_local_address);\t\n\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n\t\t\tDHCP_OPTION_CODE_LEASE_TIME, DHCP_OPTION_LENGTH_FOUR,\n\t\t\t\t\t(void *)&dhcp_option_lease_time);\n\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n\t\t\tDHCP_OPTION_CODE_SERVER_ID, DHCP_OPTION_LENGTH_FOUR,\n\t\t\t\t(void *)&dhcps_local_address);\n\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n\t\tDHCP_OPTION_CODE_BROADCAST_ADDRESS, DHCP_OPTION_LENGTH_FOUR,\n\t\t\t\t(void *)&dhcps_subnet_broadcast);\n\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n\t\tDHCP_OPTION_CODE_INTERFACE_MTU, DHCP_OPTION_LENGTH_TWO,\n\t\t\t\t\t(void *) &dhcp_option_interface_mtu);\n\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n\t\tDHCP_OPTION_CODE_PERFORM_ROUTER_DISCOVERY, DHCP_OPTION_LENGTH_ONE,\n\t\t\t\t\t\t\t\tNULL);\n\t*temp_option_addr++ = DHCP_OPTION_CODE_END;\n}", "target": 1}
{"code": "static u64 vmx_read_l1_tsc(struct kvm_vcpu *vcpu, u64 host_tsc)\n{\n\tu64 tsc_offset;\n\ttsc_offset = is_guest_mode(vcpu) ?\n\t\tto_vmx(vcpu)->nested.vmcs01_tsc_offset :\n\t\tvmcs_read64(TSC_OFFSET);\n\treturn host_tsc + tsc_offset;\n}", "target": 0}
{"code": "static void __exit ipgre_fini(void)\n{\n\trtnl_link_unregister(&ipgre_tap_ops);\n\trtnl_link_unregister(&ipgre_link_ops);\n\tunregister_pernet_device(&ipgre_net_ops);\n\tif (inet_del_protocol(&ipgre_protocol, IPPROTO_GRE) < 0)\n\t\tprintk(KERN_INFO \"ipgre close: can't remove protocol\\n\");\n}", "target": 1}
{"code": "int backport_getrandom(void *buf, size_t buflen, unsigned int flags)\n{\n\treturn (int)syscall(SYS_getrandom, buf, buflen, flags);\n}", "target": 0}
{"code": "static void process_COM (const uchar * Data, int length)\n{\n    int ch;\n    char Comment[MAX_COMMENT_SIZE+1];\n    int nch;\n    int a;\n    nch = 0;\n    if (length > MAX_COMMENT_SIZE) length = MAX_COMMENT_SIZE; \n    for (a=2;a<length;a++){\n        ch = Data[a];\n        if (ch == '\\r' && Data[a+1] == '\\n') continue; \n        if (ch >= 32 || ch == '\\n' || ch == '\\t'){\n            Comment[nch++] = (char)ch;\n        }else{\n            Comment[nch++] = '?';\n        }\n    }\n    Comment[nch] = '\\0'; \n    if (ShowTags){\n        printf(\"COM marker comment: %s\\n\",Comment);\n    }\n    strcpy(ImageInfo.Comments,Comment);\n}", "target": 1}
{"code": "read_packet(int fd, gss_buffer_t buf, int timeout, int first)\n{\n\tint\t  ret;\n\tstatic uint32_t\t\tlen = 0;\n\tstatic char\t\tlen_buf[4];\n\tstatic int\t\tlen_buf_pos = 0;\n\tstatic char *\t\ttmpbuf = 0;\n\tstatic int\t\ttmpbuf_pos = 0;\n\tif (first) {\n\t\tlen_buf_pos = 0;\n\t\treturn -2;\n\t}\n\tif (len_buf_pos < 4) {\n\t\tret = timed_read(fd, &len_buf[len_buf_pos], 4 - len_buf_pos,\n\t\t    timeout);\n\t\tif (ret == -1) {\n\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\treturn -2;\n\t\t\tLOG(LOG_ERR, (\"%s\", strerror(errno)));\n\t\t\treturn -1;\n\t\t}\n\t\tif (ret == 0) {\t\t\n\t\t\tif (len_buf_pos == 0)\n\t\t\t\treturn 0;\n\t\t\tLOG(LOG_INFO, (\"EOF reading packet len\"));\n\t\t\treturn -1;\n\t\t}\n\t\tlen_buf_pos += ret;\n\t}\n\tif (len_buf_pos != 4)\n\t\treturn -2;\n\tlen = ntohl(*(uint32_t *)len_buf);\n\tif (len > GSTD_MAXPACKETCONTENTS + 512) {\n\t\tLOG(LOG_ERR, (\"ridiculous length, %ld\", len));\n\t\treturn -1;\n\t}\n\tif (!tmpbuf) {\n\t\tif ((tmpbuf = malloc(len)) == NULL) {\n\t\t\tLOG(LOG_CRIT, (\"malloc failure, %ld bytes\", len));\n\t\t\treturn -1;\n\t\t}\n\t}\n\tret = timed_read(fd, tmpbuf + tmpbuf_pos, len - tmpbuf_pos, timeout);\n\tif (ret == -1) {\n\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\treturn -2;\n\t\tLOG(LOG_ERR, (\"%s\", strerror(errno)));\n\t\treturn -1;\n\t}\n\tif (ret == 0) {\n\t\tLOG(LOG_ERR, (\"EOF while reading packet (len=%d)\", len));\n\t\treturn -1;\n\t}\n\ttmpbuf_pos += ret;\n\tif (tmpbuf_pos == len) {\n\t\tbuf->length = len;\n\t\tbuf->value = tmpbuf;\n\t\tlen = len_buf_pos = tmpbuf_pos = 0;\n\t\ttmpbuf = NULL;\n\t\tLOG(LOG_DEBUG, (\"read packet of length %d\", buf->length));\n\t\treturn 1;\n\t}\n\treturn -2;\n}", "target": 1}
{"code": "drm_atomic_state_init(struct drm_device *dev, struct drm_atomic_state *state)\n{\n\tkref_init(&state->ref);\n\tstate->allow_modeset = true;\n\tstate->crtcs = kcalloc(dev->mode_config.num_crtc,\n\t\t\t       sizeof(*state->crtcs), GFP_KERNEL);\n\tif (!state->crtcs)\n\t\tgoto fail;\n\tstate->planes = kcalloc(dev->mode_config.num_total_plane,\n\t\t\t\tsizeof(*state->planes), GFP_KERNEL);\n\tif (!state->planes)\n\t\tgoto fail;\n\tdrm_dev_get(dev);\n\tstate->dev = dev;\n\tdrm_dbg_atomic(dev, \"Allocated atomic state %p\\n\", state);\n\treturn 0;\nfail:\n\tdrm_atomic_state_default_release(state);\n\treturn -ENOMEM;\n}", "target": 0}
{"code": "host_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct passwd *pw, const char *lhost, const char *shost,\n    const struct member *m)\n{\n    struct alias *a;\n    int matched = UNSPEC;\n    debug_decl(host_matches, SUDOERS_DEBUG_MATCH);\n    switch (m->type) {\n\tcase ALL:\n\t    matched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase NETGROUP:\n\t    if (netgr_matches(parse_tree->nss, m->name, lhost, shost,\n\t\tdef_netgroup_tuple ? pw->pw_name : NULL))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase NTWKADDR:\n\t    if (addr_matches(m->name))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase ALIAS:\n\t    a = alias_get(parse_tree, m->name, HOSTALIAS);\n\t    if (a != NULL) {\n\t\tconst int rc = hostlist_matches_int(parse_tree, pw, lhost,\n\t\t    shost, &a->members);\n\t\tif (rc != UNSPEC) {\n\t\t    if (m->negated) {\n\t\t\tmatched = rc == ALLOW ? DENY : ALLOW;\n\t\t    } else {\n\t\t\tmatched = rc;\n\t\t    }\n\t\t}\n\t\talias_put(a);\n\t\tbreak;\n\t    }\n\t    FALLTHROUGH;\n\tcase WORD:\n\t    if (hostname_matches(shost, lhost, m->name))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n    }\n    sudo_debug_printf(SUDO_DEBUG_DEBUG,\n\t\"host %s (%s) matches sudoers host %s%s: %s\", lhost, shost,\n\tm->negated ? \"!\" : \"\", m->name ? m->name : \"ALL\",\n\tmatched == true ? \"true\" : \"false\");\n    debug_return_int(matched);\n}", "target": 1}
{"code": "static void vhost_net_ubuf_put_and_wait(struct vhost_net_ubuf_ref *ubufs)\n{\n\tkref_put(&ubufs->kref, vhost_net_zerocopy_done_signal);\n\twait_event(ubufs->wait, !atomic_read(&ubufs->kref.refcount));\n}", "target": 0}
{"code": "static int xen_evtchn_cpu_prepare(unsigned int cpu)\n{\n\tint ret = 0;\n\txen_cpu_init_eoi(cpu);\n\tif (evtchn_ops->percpu_init)\n\t\tret = evtchn_ops->percpu_init(cpu);\n\treturn ret;\n}", "target": 0}
{"code": "static void rose_loopback_timer(unsigned long param)\n{\n\tstruct sk_buff *skb;\n\tstruct net_device *dev;\n\trose_address *dest;\n\tstruct sock *sk;\n\tunsigned short frametype;\n\tunsigned int lci_i, lci_o;\n\twhile ((skb = skb_dequeue(&loopback_queue)) != NULL) {\n\t\tlci_i     = ((skb->data[0] << 8) & 0xF00) + ((skb->data[1] << 0) & 0x0FF);\n\t\tframetype = skb->data[2];\n\t\tdest      = (rose_address *)(skb->data + 4);\n\t\tlci_o     = ROSE_DEFAULT_MAXVC + 1 - lci_i;\n\t\tskb_reset_transport_header(skb);\n\t\tsk = rose_find_socket(lci_o, rose_loopback_neigh);\n\t\tif (sk) {\n\t\t\tif (rose_process_rx_frame(sk, skb) == 0)\n\t\t\t\tkfree_skb(skb);\n\t\t\tcontinue;\n\t\t}\n\t\tif (frametype == ROSE_CALL_REQUEST) {\n\t\t\tif ((dev = rose_dev_get(dest)) != NULL) {\n\t\t\t\tif (rose_rx_call_request(skb, dev, rose_loopback_neigh, lci_o) == 0)\n\t\t\t\t\tkfree_skb(skb);\n\t\t\t} else {\n\t\t\t\tkfree_skb(skb);\n\t\t\t}\n\t\t} else {\n\t\t\tkfree_skb(skb);\n\t\t}\n\t}\n}", "target": 1}
{"code": "static void spl_filesystem_dir_it_current_data(zend_object_iterator *iter, zval ***data TSRMLS_DC)\n{\n\tspl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\n\t*data = &iterator->current;\n}", "target": 0}
{"code": "static MagickBooleanType IsTXT(const unsigned char *magick,const size_t length)\n{\n#define MagickID  \"# ImageMagick pixel enumeration:\"\n  char\n    colorspace[MagickPathExtent];\n  ssize_t\n    count;\n  unsigned long\n    columns,\n    depth,\n    rows;\n  if (length < 40)\n    return(MagickFalse);\n  if (LocaleNCompare((const char *) magick,MagickID,strlen(MagickID)) != 0)\n    return(MagickFalse);\n  count=(ssize_t) sscanf((const char *) magick+32,\"%lu,%lu,%lu,%s\",&columns,\n    &rows,&depth,colorspace);\n  if (count != 4)\n    return(MagickFalse);\n  return(MagickTrue);\n}", "target": 0}
{"code": "find_cleartext_device (Device *device)\n{\n  GList *devices;\n  GList *l;\n  Device *ret;\n  ret = NULL;\n  devices = daemon_local_get_all_devices (device->priv->daemon);\n  for (l = devices; l != NULL; l = l->next)\n    {\n      Device *d = DEVICE (l->data);\n      if (d->priv->device_is_luks_cleartext && d->priv->luks_cleartext_slave != NULL\n          && strcmp (d->priv->luks_cleartext_slave, device->priv->object_path) == 0)\n        {\n          ret = d;\n          goto out;\n        }\n    }\n out:\n  g_list_free (devices);\n  return ret;\n}", "target": 0}
{"code": "static inline int perf_intr_is_nmi(struct pt_regs *regs)\n{\n\treturn !regs->softe;\n}", "target": 0}
{"code": "dump_keywords(vector_t *keydump, int level, FILE *fp)\n{\n\tunsigned int i;\n\tkeyword_t *keyword_vec;\n\tchar file_name[21];\n\tif (!level) {\n\t\tsnprintf(file_name, sizeof(file_name), \"/tmp/keywords.%d\", getpid());\n\t\tfp = fopen(file_name, \"w\");\n\t\tif (!fp)\n\t\t\treturn;\n\t}\n\tfor (i = 0; i < vector_size(keydump); i++) {\n\t\tkeyword_vec = vector_slot(keydump, i);\n\t\tfprintf(fp, \"%*sKeyword : %s (%s)\\n\", level * 2, \"\", keyword_vec->string, keyword_vec->active ? \"active\": \"disabled\");\n\t\tif (keyword_vec->sub)\n\t\t\tdump_keywords(keyword_vec->sub, level + 1, fp);\n\t}\n\tif (!level)\n\t\tfclose(fp);\n}", "target": 1}
{"code": "void HTMLMediaElement::setPlaybackRate(double rate,\n                                       ExceptionState& exception_state) {\n  BLINK_MEDIA_LOG << \"setPlaybackRate(\" << (void*)this << \", \" << rate << \")\";\n  if (GetLoadType() == WebMediaPlayer::kLoadTypeMediaStream)\n    return;\n  if (rate != 0.0 && (rate < kMinRate || rate > kMaxRate)) {\n    UseCounter::Count(GetDocument(),\n                      WebFeature::kHTMLMediaElementMediaPlaybackRateOutOfRange);\n    exception_state.ThrowDOMException(\n        DOMExceptionCode::kNotSupportedError,\n        \"The provided playback rate (\" + String::Number(rate) +\n            \") is not in the \" + \"supported playback range.\");\n    return;\n  }\n  if (playback_rate_ != rate) {\n    playback_rate_ = rate;\n    ScheduleEvent(event_type_names::kRatechange);\n  }\n  UpdatePlaybackRate();\n}", "target": 0}
{"code": "nvkm_vmm_free_remove(struct nvkm_vmm *vmm, struct nvkm_vma *vma)\n{\n\trb_erase(&vma->tree, &vmm->free);\n}", "target": 0}
{"code": "sudo_auth_begin_session(const struct sudoers_context *ctx, struct passwd *pw,\n    char **user_env[])\n{\n    sudo_auth *auth;\n    debug_decl(sudo_auth_begin_session, SUDOERS_DEBUG_AUTH);\n    for (auth = auth_switch; auth->name; auth++) {\n\tif (auth->begin_session && !IS_DISABLED(auth)) {\n\t    int status = (auth->begin_session)(ctx, pw, user_env, auth);\n\t    if (status != AUTH_SUCCESS) {\n\t\tdebug_return_int(-1);\n\t    }\n\t}\n    }\n    debug_return_int(1);\n}", "target": 1}
{"code": "int jpc_bitstream_putbits(jpc_bitstream_t *bitstream, int n, long v)\n{\n\tint m;\n\tassert(n >= 0 && n < 32);\n\tassert(!(v & (~JAS_ONES(n))));\n\tm = n - 1;\n\twhile (--n >= 0) {\n\t\tif (jpc_bitstream_putbit(bitstream, (v >> m) & 1) == EOF) {\n\t\t\treturn EOF;\n\t\t}\n\t\tv <<= 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static void destroy_super(struct super_block *s)\n{\n\tint i;\n\tlist_lru_destroy(&s->s_dentry_lru);\n\tlist_lru_destroy(&s->s_inode_lru);\n#ifdef CONFIG_SMP\n\tfree_percpu(s->s_files);\n#endif\n\tfor (i = 0; i < SB_FREEZE_LEVELS; i++)\n\t\tpercpu_counter_destroy(&s->s_writers.counter[i]);\n\tsecurity_sb_free(s);\n\tWARN_ON(!list_empty(&s->s_mounts));\n\tkfree(s->s_subtype);\n\tkfree(s->s_options);\n\tkfree_rcu(s, rcu);\n}", "target": 1}
{"code": "static void* my_gballoc_malloc(size_t size)\n{\n    return malloc(size);\n}", "target": 0}
{"code": "static void oidc_scrub_headers(request_rec *r) {\n\toidc_cfg *cfg = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\tif (cfg->scrub_request_headers != 0) {\n\t\toidc_scrub_request_headers(r, OIDC_DEFAULT_HEADER_PREFIX,\n\t\t\t\toidc_cfg_dir_authn_header(r));\n\t\tif ((strstr(cfg->claim_prefix, OIDC_DEFAULT_HEADER_PREFIX)\n\t\t\t\t!= cfg->claim_prefix)) {\n\t\t\toidc_scrub_request_headers(r, cfg->claim_prefix, NULL);\n\t\t}\n\t}\n}", "target": 1}
{"code": "      DSA_Verification_Operation(const DSA_PublicKey& dsa,\n                                 const std::string& emsa) :\n         PK_Ops::Verification_with_EMSA(emsa),\n         m_group(dsa.get_group()),\n         m_y(dsa.get_y()),\n         m_mod_q(dsa.group_q())\n         {}", "target": 1}
{"code": "void hrandfieldCommand(client *c) {\n    long l;\n    int withvalues = 0;\n    robj *hash;\n    listpackEntry ele;\n    if (c->argc >= 3) {\n        if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;\n        if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"withvalues\"))) {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return;\n        } else if (c->argc == 4)\n            withvalues = 1;\n        hrandfieldWithCountCommand(c, l, withvalues);\n        return;\n    }\n    if ((hash = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp]))== NULL ||\n        checkType(c,hash,OBJ_HASH)) {\n        return;\n    }\n    hashTypeRandomElement(hash,hashTypeLength(hash),&ele,NULL);\n    hashReplyFromListpackEntry(c, &ele);\n}", "target": 1}
{"code": "static int sco_sock_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t    size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tint err;\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\terr = sock_error(sk);\n\tif (err)\n\t\treturn err;\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\tlock_sock(sk);\n\tif (sk->sk_state == BT_CONNECTED)\n\t\terr = sco_send_frame(sk, msg, len);\n\telse\n\t\terr = -ENOTCONN;\n\trelease_sock(sk);\n\treturn err;\n}", "target": 1}
{"code": "void GfxDeviceGrayColorSpace::getGray(const GfxColor *color, GfxGray *gray) const\n{\n    *gray = clip01(color->c[0]);\n}", "target": 0}
{"code": "void NetworkScreen::OnHelpLinkActivated() {\n  ClearErrors();\n  if (!help_app_.get())\n    help_app_.reset(new HelpAppLauncher(view()->GetNativeWindow()));\n  help_app_->ShowHelpTopic(HelpAppLauncher::HELP_CONNECTIVITY);\n}", "target": 0}
{"code": "static noinline int btrfs_mksubvol(struct path *parent,\n\t\t\t\t   char *name, int namelen,\n\t\t\t\t   struct btrfs_root *snap_src,\n\t\t\t\t   u64 *async_transid, bool readonly,\n\t\t\t\t   struct btrfs_qgroup_inherit **inherit)\n{\n\tstruct inode *dir  = parent->dentry->d_inode;\n\tstruct dentry *dentry;\n\tint error;\n\tmutex_lock_nested(&dir->i_mutex, I_MUTEX_PARENT);\n\tdentry = lookup_one_len(name, parent->dentry, namelen);\n\terror = PTR_ERR(dentry);\n\tif (IS_ERR(dentry))\n\t\tgoto out_unlock;\n\terror = -EEXIST;\n\tif (dentry->d_inode)\n\t\tgoto out_dput;\n\terror = btrfs_may_create(dir, dentry);\n\tif (error)\n\t\tgoto out_dput;\n\terror = btrfs_check_dir_item_collision(BTRFS_I(dir)->root,\n\t\t\t\t\t       dir->i_ino, name,\n\t\t\t\t\t       namelen);\n\tif (error)\n\t\tgoto out_dput;\n\tdown_read(&BTRFS_I(dir)->root->fs_info->subvol_sem);\n\tif (btrfs_root_refs(&BTRFS_I(dir)->root->root_item) == 0)\n\t\tgoto out_up_read;\n\tif (snap_src) {\n\t\terror = create_snapshot(snap_src, dentry, name, namelen,\n\t\t\t\t\tasync_transid, readonly, inherit);\n\t} else {\n\t\terror = create_subvol(BTRFS_I(dir)->root, dentry,\n\t\t\t\t      name, namelen, async_transid, inherit);\n\t}\n\tif (!error)\n\t\tfsnotify_mkdir(dir, dentry);\nout_up_read:\n\tup_read(&BTRFS_I(dir)->root->fs_info->subvol_sem);\nout_dput:\n\tdput(dentry);\nout_unlock:\n\tmutex_unlock(&dir->i_mutex);\n\treturn error;\n}", "target": 0}
{"code": "ev_archive_class_init (EvArchiveClass *klass)\n{\n        GObjectClass *object_class = (GObjectClass *) klass;\n        object_class->finalize = ev_archive_finalize;\n}", "target": 0}
{"code": "static inline bool crypto_shash_alg_has_setkey(struct shash_alg *alg)\n{\n\treturn alg->setkey != shash_no_setkey;\n}", "target": 0}
{"code": "sc_pkcs15emu_add_cert(sc_pkcs15_card_t *p15card,\n\t\tint type, int authority,\n\t\tconst sc_path_t *path,\n\t\tconst sc_pkcs15_id_t *id,\n                const char *label, int obj_flags)\n{\n\tsc_pkcs15_cert_info_t *info;\n\tinfo = calloc(1, sizeof(*info));\n\tif (!info)\n\t{\n\t\tLOG_FUNC_RETURN(p15card->card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\tinfo->id\t\t= *id;\n\tinfo->authority\t\t= authority;\n\tif (path)\n\t\tinfo->path = *path;\n\treturn sc_pkcs15emu_add_object(p15card, type, label, info, NULL, obj_flags);\n}", "target": 0}
{"code": "static int udp_push_pending_frames(struct sock *sk)\n{\n\tstruct udp_sock  *up = udp_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct flowi4 *fl4 = &inet->cork.fl.u.ip4;\n\tstruct sk_buff *skb;\n\tint err = 0;\n\tskb = ip_finish_skb(sk, fl4);\n\tif (!skb)\n\t\tgoto out;\n\terr = udp_send_skb(skb, fl4);\nout:\n\tup->len = 0;\n\tup->pending = 0;\n\treturn err;\n}", "target": 1}
{"code": "int do_remount_sb(struct super_block *sb, int flags, void *data, int force)\n{\n\tint retval;\n\tint remount_ro;\n\tif (sb->s_writers.frozen != SB_UNFROZEN)\n\t\treturn -EBUSY;\n#ifdef CONFIG_BLOCK\n\tif (!(flags & MS_RDONLY) && bdev_read_only(sb->s_bdev))\n\t\treturn -EACCES;\n#endif\n\tif (flags & MS_RDONLY)\n\t\tacct_auto_close(sb);\n\tshrink_dcache_sb(sb);\n\tsync_filesystem(sb);\n\tremount_ro = (flags & MS_RDONLY) && !(sb->s_flags & MS_RDONLY);\n\tif (remount_ro) {\n\t\tif (force) {\n\t\t\tmark_files_ro(sb);\n\t\t} else {\n\t\t\tretval = sb_prepare_remount_readonly(sb);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t}\n\t}\n\tif (sb->s_op->remount_fs) {\n\t\tretval = sb->s_op->remount_fs(sb, &flags, data);\n\t\tif (retval) {\n\t\t\tif (!force)\n\t\t\t\tgoto cancel_readonly;\n\t\t\tWARN(1, \"forced remount of a %s fs returned %i\\n\",\n\t\t\t     sb->s_type->name, retval);\n\t\t}\n\t}\n\tsb->s_flags = (sb->s_flags & ~MS_RMT_MASK) | (flags & MS_RMT_MASK);\n\tsmp_wmb();\n\tsb->s_readonly_remount = 0;\n\tif (remount_ro && sb->s_bdev)\n\t\tinvalidate_bdev(sb->s_bdev);\n\treturn 0;\ncancel_readonly:\n\tsb->s_readonly_remount = 0;\n\treturn retval;\n}", "target": 1}
{"code": "static int IntensityCompare(const void *x,const void *y)\n{\n  const PixelChannels\n    *color_1,\n    *color_2;\n  double\n    distance;\n  ssize_t\n    i;\n  color_1=(const PixelChannels *) x;\n  color_2=(const PixelChannels *) y;\n  distance=0.0;\n  for (i=0; i < MaxPixelChannels; i++)\n    distance+=color_1->channel[i]-(double) color_2->channel[i];\n  return(distance < 0.0 ? -1 : distance > 0.0 ? 1 : 0);\n}", "target": 0}
{"code": "int BN_bn2binpad(const BIGNUM *a, unsigned char *to, int tolen)\n{\n    if (tolen < 0)\n        return -1;\n    return bn2binpad(a, to, tolen);\n}", "target": 0}
{"code": "int module_load(\n    YR_SCAN_CONTEXT* context,\n    YR_OBJECT* module_object,\n    void* module_data,\n    size_t module_data_size)\n{\n  set_integer(1, module_object, \"constants.one\");\n  set_integer(2, module_object, \"constants.two\");\n  set_string(\"foo\", module_object, \"constants.foo\");\n  set_string(\"\", module_object, \"constants.empty\");\n  set_integer(1, module_object, \"struct_array[1].i\");\n  set_integer(0, module_object, \"integer_array[%i]\", 0);\n  set_integer(1, module_object, \"integer_array[%i]\", 1);\n  set_integer(2, module_object, \"integer_array[%i]\", 2);\n  set_integer(256, module_object, \"integer_array[%i]\", 256);\n  set_string(\"foo\", module_object, \"string_array[%i]\", 0);\n  set_string(\"bar\", module_object, \"string_array[%i]\", 1);\n  set_string(\"baz\", module_object, \"string_array[%i]\", 2);\n  set_sized_string(\"foo\\0bar\", 7, module_object, \"string_array[%i]\", 3);\n  set_string(\"foo\", module_object, \"string_dict[%s]\", \"foo\");\n  set_string(\"bar\", module_object, \"string_dict[\\\"bar\\\"]\");\n  set_string(\"foo\", module_object, \"struct_dict[%s].s\", \"foo\");\n  set_integer(1, module_object, \"struct_dict[%s].i\", \"foo\");\n  return ERROR_SUCCESS;\n}", "target": 0}
{"code": "static const char *adpt_i2o_get_class_name(int class)\n{\n\tint idx = 16;\n\tstatic char *i2o_class_name[] = {\n\t\t\"Executive\",\n\t\t\"Device Driver Module\",\n\t\t\"Block Device\",\n\t\t\"Tape Device\",\n\t\t\"LAN Interface\",\n\t\t\"WAN Interface\",\n\t\t\"Fibre Channel Port\",\n\t\t\"Fibre Channel Device\",\n\t\t\"SCSI Device\",\n\t\t\"ATE Port\",\n\t\t\"ATE Device\",\n\t\t\"Floppy Controller\",\n\t\t\"Floppy Device\",\n\t\t\"Secondary Bus Port\",\n\t\t\"Peer Transport Agent\",\n\t\t\"Peer Transport\",\n\t\t\"Unknown\"\n\t};\n\tswitch(class&0xFFF) {\n\tcase I2O_CLASS_EXECUTIVE:\n\t\tidx = 0; break;\n\tcase I2O_CLASS_DDM:\n\t\tidx = 1; break;\n\tcase I2O_CLASS_RANDOM_BLOCK_STORAGE:\n\t\tidx = 2; break;\n\tcase I2O_CLASS_SEQUENTIAL_STORAGE:\n\t\tidx = 3; break;\n\tcase I2O_CLASS_LAN:\n\t\tidx = 4; break;\n\tcase I2O_CLASS_WAN:\n\t\tidx = 5; break;\n\tcase I2O_CLASS_FIBRE_CHANNEL_PORT:\n\t\tidx = 6; break;\n\tcase I2O_CLASS_FIBRE_CHANNEL_PERIPHERAL:\n\t\tidx = 7; break;\n\tcase I2O_CLASS_SCSI_PERIPHERAL:\n\t\tidx = 8; break;\n\tcase I2O_CLASS_ATE_PORT:\n\t\tidx = 9; break;\n\tcase I2O_CLASS_ATE_PERIPHERAL:\n\t\tidx = 10; break;\n\tcase I2O_CLASS_FLOPPY_CONTROLLER:\n\t\tidx = 11; break;\n\tcase I2O_CLASS_FLOPPY_DEVICE:\n\t\tidx = 12; break;\n\tcase I2O_CLASS_BUS_ADAPTER_PORT:\n\t\tidx = 13; break;\n\tcase I2O_CLASS_PEER_TRANSPORT_AGENT:\n\t\tidx = 14; break;\n\tcase I2O_CLASS_PEER_TRANSPORT:\n\t\tidx = 15; break;\n\t}\n\treturn i2o_class_name[idx];\n}", "target": 1}
{"code": "static __be32 nfsd3_proc_setacl(struct svc_rqst * rqstp,\n\t\tstruct nfsd3_setaclargs *argp,\n\t\tstruct nfsd3_attrstat *resp)\n{\n\tstruct inode *inode;\n\tsvc_fh *fh;\n\t__be32 nfserr = 0;\n\tint error;\n\tfh = fh_copy(&resp->fh, &argp->fh);\n\tnfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);\n\tif (nfserr)\n\t\tgoto out;\n\tinode = d_inode(fh->fh_dentry);\n\tif (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {\n\t\terror = -EOPNOTSUPP;\n\t\tgoto out_errno;\n\t}\n\terror = fh_want_write(fh);\n\tif (error)\n\t\tgoto out_errno;\n\terror = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);\n\tif (error)\n\t\tgoto out_drop_write;\n\terror = inode->i_op->set_acl(inode, argp->acl_default,\n\t\t\t\t     ACL_TYPE_DEFAULT);\nout_drop_write:\n\tfh_drop_write(fh);\nout_errno:\n\tnfserr = nfserrno(error);\nout:\n\tposix_acl_release(argp->acl_access);\n\tposix_acl_release(argp->acl_default);\n\tRETURN_STATUS(nfserr);\n}", "target": 1}
{"code": "void Item_hex_string::print(String *str, enum_query_type query_type)\n{\n  str->append(\"X'\");\n  str->append_hex(str_value.ptr(), str_value.length());\n  str->append(\"'\");\n}", "target": 0}
{"code": "static int selinux_inode_getsecurity(struct inode *inode, const char *name, void **buffer, bool alloc)\n{\n\tu32 size;\n\tint error;\n\tchar *context = NULL;\n\tstruct inode_security_struct *isec;\n\tif (strcmp(name, XATTR_SELINUX_SUFFIX))\n\t\treturn -EOPNOTSUPP;\n\tisec = inode_security(inode);\n\tif (has_cap_mac_admin(false))\n\t\terror = security_sid_to_context_force(&selinux_state,\n\t\t\t\t\t\t      isec->sid, &context,\n\t\t\t\t\t\t      &size);\n\telse\n\t\terror = security_sid_to_context(&selinux_state, isec->sid,\n\t\t\t\t\t\t&context, &size);\n\tif (error)\n\t\treturn error;\n\terror = size;\n\tif (alloc) {\n\t\t*buffer = context;\n\t\tgoto out_nofree;\n\t}\n\tkfree(context);\nout_nofree:\n\treturn error;\n}", "target": 0}
{"code": "spnego_gss_get_mic(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tgss_qop_t  qop_req,\n\t\tconst gss_buffer_t message_buffer,\n\t\tgss_buffer_t message_token)\n{\n\tOM_uint32 ret;\n\tret = gss_get_mic(minor_status,\n\t\t    context_handle,\n\t\t    qop_req,\n\t\t    message_buffer,\n\t\t    message_token);\n\treturn (ret);\n}", "target": 1}
{"code": "d_lite_next_day(int argc, VALUE *argv, VALUE self)\n{\n    VALUE n;\n    rb_scan_args(argc, argv, \"01\", &n);\n    if (argc < 1)\n\tn = INT2FIX(1);\n    return d_lite_plus(self, n);\n}", "target": 0}
{"code": "static void run(int argc, const char *const argv[],\n        const char *name, void (*init)(const char * const argv[]))\n{\n    int rv;\n    bool user_config;\n    const char *argv_out[argc+4], *new_argv[argc+4];\n    int argc_out;\n    char conf_file[OGS_MAX_FILEPATH_LEN];\n    user_config = false;\n    for (argc_out = 0; argc_out < argc; argc_out++) {\n        if (strcmp(\"-c\", argv[argc_out]) == 0) {\n            user_config = true; \n        }\n        argv_out[argc_out] = argv[argc_out];\n    }\n    argv_out[argc_out] = NULL;\n    if (!user_config) {\n        ogs_snprintf(conf_file, sizeof conf_file, \"%s%s\",\n            MESON_BUILD_ROOT OGS_DIR_SEPARATOR_S\n            \"configs\" OGS_DIR_SEPARATOR_S, name);\n        argv_out[argc_out++] = \"-c\";\n        argv_out[argc_out++] = conf_file;\n        argv_out[argc_out] = NULL;\n    }\n    argv_out[0] = MESON_BUILD_ROOT OGS_DIR_SEPARATOR_S \n            \"src\" OGS_DIR_SEPARATOR_S \"open5gs-main\";\n    rv = abts_main(argc_out, argv_out, new_argv);\n    ogs_assert(rv == OGS_OK);\n    (*init)(new_argv);\n}", "target": 1}
{"code": "static bool disconnect_cb(struct io *io, void *user_data)\n{\n\tstruct bt_att_chan *chan = user_data;\n\tstruct bt_att *att = chan->att;\n\tint err;\n\tsocklen_t len;\n\tlen = sizeof(err);\n\tif (getsockopt(chan->fd, SOL_SOCKET, SO_ERROR, &err, &len) < 0) {\n\t\tutil_debug(chan->att->debug_callback, chan->att->debug_data,\n\t\t\t\t\t\"(chan %p) Failed to obtain disconnect\"\n\t\t\t\t\t\" error: %s\", chan, strerror(errno));\n\t\terr = 0;\n\t}\n\tutil_debug(chan->att->debug_callback, chan->att->debug_data,\n\t\t\t\t\t\"Channel %p disconnected: %s\",\n\t\t\t\t\tchan, strerror(err));\n\tqueue_remove(att->chans, chan);\n\tqueue_remove_all(att->req_queue, NULL, NULL, disc_att_send_op);\n\tqueue_remove_all(att->ind_queue, NULL, NULL, disc_att_send_op);\n\tqueue_remove_all(att->write_queue, NULL, NULL, disc_att_send_op);\n\tif (chan->pending_req) {\n\t\tdisc_att_send_op(chan->pending_req);\n\t\tchan->pending_req = NULL;\n\t}\n\tif (chan->pending_ind) {\n\t\tdisc_att_send_op(chan->pending_ind);\n\t\tchan->pending_ind = NULL;\n\t}\n\tbt_att_chan_free(chan);\n\tif (!queue_isempty(att->chans))\n\t\treturn false;\n\tbt_att_ref(att);\n\tqueue_foreach(att->disconn_list, disconn_handler, INT_TO_PTR(err));\n\tbt_att_unregister_all(att);\n\tbt_att_unref(att);\n\treturn false;\n}", "target": 1}
{"code": "static void begin_read(TsHashTable *ht)\n{\n#ifdef ZTS\n\ttsrm_mutex_lock(ht->mx_reader);\n\tif ((++(ht->reader)) == 1) {\n\t\ttsrm_mutex_lock(ht->mx_writer);\n\t}\n\ttsrm_mutex_unlock(ht->mx_reader);\n#endif\n}", "target": 0}
{"code": "GopherStateData::iconUrl(const char gtype)\n{\n    switch (gtype) {\n    case GOPHER_DIRECTORY:\n        return mimeGetIconURL(\"internal-menu\");\n    case GOPHER_HTML:\n    case GOPHER_FILE:\n        return mimeGetIconURL(\"internal-text\");\n    case GOPHER_INDEX:\n    case GOPHER_CSO:\n        return mimeGetIconURL(\"internal-index\");\n    case GOPHER_IMAGE:\n    case GOPHER_GIF:\n    case GOPHER_PLUS_IMAGE:\n        return mimeGetIconURL(\"internal-image\");\n    case GOPHER_SOUND:\n    case GOPHER_PLUS_SOUND:\n        return mimeGetIconURL(\"internal-sound\");\n    case GOPHER_PLUS_MOVIE:\n        return mimeGetIconURL(\"internal-movie\");\n    case GOPHER_TELNET:\n    case GOPHER_3270:\n        return mimeGetIconURL(\"internal-telnet\");\n    case GOPHER_BIN:\n    case GOPHER_MACBINHEX:\n    case GOPHER_DOSBIN:\n    case GOPHER_UUENCODED:\n        return mimeGetIconURL(\"internal-binary\");\n    case GOPHER_INFO:\n        return nullptr;\n    case GOPHER_WWW:\n        return mimeGetIconURL(\"internal-link\");\n    default:\n        return mimeGetIconURL(\"internal-unknown\");\n    }\n}", "target": 1}
{"code": "static int stv06xx_start(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct usb_host_interface *alt;\n\tstruct usb_interface *intf;\n\tint err, packet_size;\n\tintf = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);\n\talt = usb_altnum_to_altsetting(intf, sd->gspca_dev.alt);\n\tif (!alt) {\n\t\tgspca_err(gspca_dev, \"Couldn't get altsetting\\n\");\n\t\treturn -EIO;\n\t}\n\tif (alt->desc.bNumEndpoints < 1)\n\t\treturn -ENODEV;\n\tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n\terr = stv06xx_write_bridge(sd, STV_ISO_SIZE_L, packet_size);\n\tif (err < 0)\n\t\treturn err;\n\terr = sd->sensor->start(sd);\n\tif (err < 0)\n\t\tgoto out;\n\terr = stv06xx_write_bridge(sd, STV_ISO_ENABLE, 1);\nout:\n\tif (err < 0)\n\t\tgspca_dbg(gspca_dev, D_STREAM, \"Starting stream failed\\n\");\n\telse\n\t\tgspca_dbg(gspca_dev, D_STREAM, \"Started streaming\\n\");\n\treturn (err < 0) ? err : 0;\n}", "target": 0}
{"code": "static bool parse_reconnect(struct pool *pool, json_t *val)\n{\n\tchar *sockaddr_url, *stratum_port, *tmp;\n\tchar *url, *port, address[256];\n\tmemset(address, 0, 255);\n\turl = (char *)json_string_value(json_array_get(val, 0));\n\tif (!url)\n\t\turl = pool->sockaddr_url;\n\telse {\n\t\tchar *dot_pool, *dot_reconnect;\n\t\tdot_pool = strchr(pool->sockaddr_url, '.');\n\t\tif (!dot_pool) {\n\t\t\tapplog(LOG_ERR, \"Denied stratum reconnect request for pool without domain '%s'\",\n\t\t\t       pool->sockaddr_url);\n\t\t\treturn false;\n\t\t}\n\t\tdot_reconnect = strchr(url, '.');\n\t\tif (!dot_reconnect) {\n\t\t\tapplog(LOG_ERR, \"Denied stratum reconnect request to url without domain '%s'\",\n\t\t\t       url);\n\t\t\treturn false;\n\t\t}\n\t\tif (strcmp(dot_pool, dot_reconnect)) {\n\t\t\tapplog(LOG_ERR, \"Denied stratum reconnect request to non-matching domain url '%s'\",\n\t\t\t\tpool->sockaddr_url);\n\t\t\treturn false;\n\t\t}\n\t}\n\tport = (char *)json_string_value(json_array_get(val, 1));\n\tif (!port)\n\t\tport = pool->stratum_port;\n\tsprintf(address, \"%s:%s\", url, port);\n\tif (!extract_sockaddr(address, &sockaddr_url, &stratum_port))\n\t\treturn false;\n\tapplog(LOG_WARNING, \"Stratum reconnect requested from pool %d to %s\", pool->pool_no, address);\n\tclear_pool_work(pool);\n\tmutex_lock(&pool->stratum_lock);\n\t__suspend_stratum(pool);\n\ttmp = pool->sockaddr_url;\n\tpool->sockaddr_url = sockaddr_url;\n\tpool->stratum_url = pool->sockaddr_url;\n\tfree(tmp);\n\ttmp = pool->stratum_port;\n\tpool->stratum_port = stratum_port;\n\tfree(tmp);\n\tmutex_unlock(&pool->stratum_lock);\n\tif (!restart_stratum(pool)) {\n\t\tpool_failed(pool);\n\t\treturn false;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "void WasmBinaryWriter::writeIndexedHeapType(HeapType type) {\n  o << U32LEB(getTypeIndex(type));\n}", "target": 0}
{"code": "void RenderFrameHostImpl::OnCrossSiteResponse(\n    const GlobalRequestID& global_request_id,\n    scoped_ptr<CrossSiteTransferringRequest> cross_site_transferring_request,\n    const std::vector<GURL>& transfer_url_chain,\n    const Referrer& referrer,\n    PageTransition page_transition,\n    bool should_replace_current_entry) {\n  frame_tree_node_->render_manager()->OnCrossSiteResponse(\n      this, global_request_id, cross_site_transferring_request.Pass(),\n      transfer_url_chain, referrer, page_transition,\n      should_replace_current_entry);\n}", "target": 0}
{"code": "static const char *cmd_hash_engine(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n    if (strcasecmp(p1, \"on\") == 0)  {\n        dcfg->hash_is_enabled = HASH_ENABLED;\n        dcfg->hash_enforcement = HASH_ENABLED;\n    }\n    else if (strcasecmp(p1, \"off\") == 0)    {\n        dcfg->hash_is_enabled = HASH_DISABLED;\n        dcfg->hash_enforcement = HASH_DISABLED;\n    }\n    else return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecRuleEngine: %s\", p1);\n    return NULL;\n}", "target": 1}
{"code": "void ff_jpeg2000_cleanup(Jpeg2000Component *comp, Jpeg2000CodingStyle *codsty)\n{\n    int reslevelno, bandno, precno;\n    for (reslevelno = 0;\n         comp->reslevel && reslevelno < codsty->nreslevels;\n         reslevelno++) {\n        Jpeg2000ResLevel *reslevel = comp->reslevel + reslevelno;\n        for (bandno = 0; bandno < reslevel->nbands; bandno++) {\n            Jpeg2000Band *band = reslevel->band + bandno;\n            for (precno = 0; precno < reslevel->num_precincts_x * reslevel->num_precincts_y; precno++) {\n                Jpeg2000Prec *prec = band->prec + precno;\n                av_freep(&prec->zerobits);\n                av_freep(&prec->cblkincl);\n                av_freep(&prec->cblk);\n            }\n            av_freep(&band->prec);\n        }\n        av_freep(&reslevel->band);\n    }\n    ff_dwt_destroy(&comp->dwt);\n    av_freep(&comp->reslevel);\n    av_freep(&comp->i_data);\n    av_freep(&comp->f_data);\n}", "target": 1}
{"code": "void nghttp2_option_set_max_continuations(nghttp2_option *option, size_t val) {\n  option->opt_set_mask |= NGHTTP2_OPT_MAX_CONTINUATIONS;\n  option->max_continuations = val;\n}", "target": 0}
{"code": "  bool ms_deliver_verify_authorizer(Connection *con, int peer_type,\n\t\t\t\t    int protocol, bufferlist& authorizer, bufferlist& authorizer_reply,\n\t\t\t\t    bool& isvalid, CryptoKey& session_key) {\n    for (list<Dispatcher*>::iterator p = dispatchers.begin();\n\t p != dispatchers.end();\n\t ++p) {\n      if ((*p)->ms_verify_authorizer(con, peer_type, protocol, authorizer, authorizer_reply, isvalid, session_key))\n\treturn true;\n    }\n    return false;\n  }", "target": 1}
{"code": "static int adpt_device_reset(struct scsi_cmnd* cmd)\n{\n\tadpt_hba* pHba;\n\tu32 msg[4];\n\tu32 rcode;\n\tint old_state;\n\tstruct adpt_device* d = cmd->device->hostdata;\n\tpHba = (void*) cmd->device->host->hostdata[0];\n\tprintk(KERN_INFO\"%s: Trying to reset device\\n\",pHba->name);\n\tif (!d) {\n\t\tprintk(KERN_INFO\"%s: Reset Device: Device Not found\\n\",pHba->name);\n\t\treturn FAILED;\n\t}\n\tmemset(msg, 0, sizeof(msg));\n\tmsg[0] = FOUR_WORD_MSG_SIZE|SGL_OFFSET_0;\n\tmsg[1] = (I2O_DEVICE_RESET<<24|HOST_TID<<12|d->tid);\n\tmsg[2] = 0;\n\tmsg[3] = 0;\n\tif (pHba->host)\n\t\tspin_lock_irq(pHba->host->host_lock);\n\told_state = d->state;\n\td->state |= DPTI_DEV_RESET;\n\trcode = adpt_i2o_post_wait(pHba, msg,sizeof(msg), FOREVER);\n\td->state = old_state;\n\tif (pHba->host)\n\t\tspin_unlock_irq(pHba->host->host_lock);\n\tif (rcode != 0) {\n\t\tif(rcode == -EOPNOTSUPP ){\n\t\t\tprintk(KERN_INFO\"%s: Device reset not supported\\n\",pHba->name);\n\t\t\treturn FAILED;\n\t\t}\n\t\tprintk(KERN_INFO\"%s: Device reset failed\\n\",pHba->name);\n\t\treturn FAILED;\n\t} else {\n\t\tprintk(KERN_INFO\"%s: Device reset successful\\n\",pHba->name);\n\t\treturn SUCCESS;\n\t}\n}", "target": 1}
{"code": "static void *load_bytes(RBinFile *arch, const ut8 *buf, ut64 sz, ut64 loaddr, Sdb *sdb) {\n\tif (!buf || !sz || sz == UT64_MAX) {\n\t\treturn NULL;\n\t}\n\tRBuffer *tbuf = r_buf_new ();\n\tif (!tbuf) {\n\t\treturn NULL;\n\t}\n\tr_buf_set_bytes (tbuf, buf, sz);\n\tstruct r_bin_bflt_obj *res = r_bin_bflt_new_buf (tbuf);\n\tr_buf_free (tbuf);\n\treturn res ? res : NULL;\n}", "target": 0}
{"code": "void freeClient(redisClient *c) {\n    listNode *ln;\n    sdsfree(c->querybuf);\n    c->querybuf = NULL;\n    if (c->flags & REDIS_BLOCKED)\n        unblockClientWaitingData(c);\n    unwatchAllKeys(c);\n    listRelease(c->watched_keys);\n    pubsubUnsubscribeAllChannels(c,0);\n    pubsubUnsubscribeAllPatterns(c,0);\n    dictRelease(c->pubsub_channels);\n    listRelease(c->pubsub_patterns);\n    aeDeleteFileEvent(server.el,c->fd,AE_READABLE);\n    aeDeleteFileEvent(server.el,c->fd,AE_WRITABLE);\n    listRelease(c->reply);\n    freeClientArgv(c);\n    close(c->fd);\n    ln = listSearchKey(server.clients,c);\n    redisAssert(ln != NULL);\n    listDelNode(server.clients,ln);\n    if (c->flags & REDIS_IO_WAIT) {\n        redisAssert(server.vm_enabled);\n        if (listLength(c->io_keys) == 0) {\n            ln = listSearchKey(server.io_ready_clients,c);\n            redisAssert(ln != NULL);\n            listDelNode(server.io_ready_clients,ln);\n        } else {\n            while (listLength(c->io_keys)) {\n                ln = listFirst(c->io_keys);\n                dontWaitForSwappedKey(c,ln->value);\n            }\n        }\n        server.vm_blocked_clients--;\n    }\n    listRelease(c->io_keys);\n    if (c->flags & REDIS_SLAVE) {\n        if (c->replstate == REDIS_REPL_SEND_BULK && c->repldbfd != -1)\n            close(c->repldbfd);\n        list *l = (c->flags & REDIS_MONITOR) ? server.monitors : server.slaves;\n        ln = listSearchKey(l,c);\n        redisAssert(ln != NULL);\n        listDelNode(l,ln);\n    }\n    if (c->flags & REDIS_MASTER) {\n        server.master = NULL;\n        server.replstate = REDIS_REPL_CONNECT;\n        while (listLength(server.slaves)) {\n            ln = listFirst(server.slaves);\n            freeClient((redisClient*)ln->value);\n        }\n    }\n    zfree(c->argv);\n    freeClientMultiState(c);\n    zfree(c);\n}", "target": 1}
{"code": "static int zerocopy_sg_from_iovec(struct sk_buff *skb, const struct iovec *from,\n\t\t\t\t  int offset, size_t count)\n{\n\tint len = iov_length(from, count) - offset;\n\tint copy = skb_headlen(skb);\n\tint size, offset1 = 0;\n\tint i = 0;\n\twhile (count && (offset >= from->iov_len)) {\n\t\toffset -= from->iov_len;\n\t\t++from;\n\t\t--count;\n\t}\n\twhile (count && (copy > 0)) {\n\t\tsize = min_t(unsigned int, copy, from->iov_len - offset);\n\t\tif (copy_from_user(skb->data + offset1, from->iov_base + offset,\n\t\t\t\t   size))\n\t\t\treturn -EFAULT;\n\t\tif (copy > size) {\n\t\t\t++from;\n\t\t\t--count;\n\t\t\toffset = 0;\n\t\t} else\n\t\t\toffset += size;\n\t\tcopy -= size;\n\t\toffset1 += size;\n\t}\n\tif (len == offset1)\n\t\treturn 0;\n\twhile (count--) {\n\t\tstruct page *page[MAX_SKB_FRAGS];\n\t\tint num_pages;\n\t\tunsigned long base;\n\t\tunsigned long truesize;\n\t\tlen = from->iov_len - offset;\n\t\tif (!len) {\n\t\t\toffset = 0;\n\t\t\t++from;\n\t\t\tcontinue;\n\t\t}\n\t\tbase = (unsigned long)from->iov_base + offset;\n\t\tsize = ((base & ~PAGE_MASK) + len + ~PAGE_MASK) >> PAGE_SHIFT;\n\t\tnum_pages = get_user_pages_fast(base, size, 0, &page[i]);\n\t\tif ((num_pages != size) ||\n\t\t    (num_pages > MAX_SKB_FRAGS - skb_shinfo(skb)->nr_frags)) {\n\t\t\tfor (i = 0; i < num_pages; i++)\n\t\t\t\tput_page(page[i]);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\ttruesize = size * PAGE_SIZE;\n\t\tskb->data_len += len;\n\t\tskb->len += len;\n\t\tskb->truesize += truesize;\n\t\tatomic_add(truesize, &skb->sk->sk_wmem_alloc);\n\t\twhile (len) {\n\t\t\tint off = base & ~PAGE_MASK;\n\t\t\tint size = min_t(int, len, PAGE_SIZE - off);\n\t\t\t__skb_fill_page_desc(skb, i, page[i], off, size);\n\t\t\tskb_shinfo(skb)->nr_frags++;\n\t\t\tbase += size;\n\t\t\tlen -= size;\n\t\t\ti++;\n\t\t}\n\t\toffset = 0;\n\t\t++from;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int set_register(pegasus_t *pegasus, __u16 indx, __u8 data)\n{\n\tint ret;\n\tret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_SET_REG, PEGASUS_REQT_WRITE, data,\n\t\t\t      indx, &data, 1, 1000);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\treturn ret;\n}", "target": 1}
{"code": "render_pixbuf_size_prepared_cb (GdkPixbufLoader *loader,\n\t\t\t\tgint             width,\n\t\t\t\tgint             height,\n\t\t\t\tEvRenderContext *rc)\n{\n\tdouble scale = rc->scale;\n\tint w = (width  * scale + 0.5);\n\tint h = (height * scale + 0.5);\n\tgdk_pixbuf_loader_set_size (loader, w, h);\n}", "target": 0}
{"code": "static gpointer openssl_global_init_once(gpointer arg)\n{\n    SSL_library_init();\n    SSL_load_error_strings();\n    openssl_thread_setup();\n    return NULL;\n}", "target": 0}
{"code": "int __fsnotify_parent(const struct path *path, struct dentry *dentry, __u32 mask)\n{\n\tstruct dentry *parent;\n\tstruct inode *p_inode;\n\tint ret = 0;\n\tif (!dentry)\n\t\tdentry = path->dentry;\n\tif (!(dentry->d_flags & DCACHE_FSNOTIFY_PARENT_WATCHED))\n\t\treturn 0;\n\tparent = dget_parent(dentry);\n\tp_inode = parent->d_inode;\n\tif (unlikely(!fsnotify_inode_watches_children(p_inode)))\n\t\t__fsnotify_update_child_dentry_flags(p_inode);\n\telse if (p_inode->i_fsnotify_mask & mask) {\n\t\tmask |= FS_EVENT_ON_CHILD;\n\t\tif (path)\n\t\t\tret = fsnotify(p_inode, mask, path, FSNOTIFY_EVENT_PATH,\n\t\t\t\t       dentry->d_name.name, 0);\n\t\telse\n\t\t\tret = fsnotify(p_inode, mask, dentry->d_inode, FSNOTIFY_EVENT_INODE,\n\t\t\t\t       dentry->d_name.name, 0);\n\t}\n\tdput(parent);\n\treturn ret;\n}", "target": 1}
{"code": "static int oidc_request_post_preserved_restore(request_rec *r,\n\t\tconst char *original_url) {\n\toidc_debug(r, \"enter: original_url=%s\", original_url);\n\tconst char *method = \"postOnLoad\";\n\tconst char *script =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\t\t\"      function str_decode(string) {\\n\"\n\t\t\t\t\t\"        try {\\n\"\n\t\t\t\t\t\"          result = decodeURIComponent(string);\\n\"\n\t\t\t\t\t\"        } catch (e) {\\n\"\n\t\t\t\t\t\"          result =  unescape(string);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        return result;\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"      function %s() {\\n\"\n\t\t\t\t\t\"        var mod_auth_openidc_preserve_post_params = JSON.parse(sessionStorage.getItem('mod_auth_openidc_preserve_post_params'));\\n\"\n\t\t\t\t\t\"\t\t sessionStorage.removeItem('mod_auth_openidc_preserve_post_params');\\n\"\n\t\t\t\t\t\"        for (var key in mod_auth_openidc_preserve_post_params) {\\n\"\n\t\t\t\t\t\"          var input = document.createElement(\\\"input\\\");\\n\"\n\t\t\t\t\t\"          input.name = str_decode(key);\\n\"\n\t\t\t\t\t\"          input.value = str_decode(mod_auth_openidc_preserve_post_params[key]);\\n\"\n\t\t\t\t\t\"          input.type = \\\"hidden\\\";\\n\"\n\t\t\t\t\t\"          document.forms[0].appendChild(input);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        document.forms[0].action = '%s';\\n\"\n\t\t\t\t\t\"        document.forms[0].submit();\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"    </script>\\n\", method, original_url);\n\tconst char *body = \"    <p>Restoring...</p>\\n\"\n\t\t\t\"    <form method=\\\"post\\\"></form>\\n\";\n\treturn oidc_util_html_send(r, \"Restoring...\", script, method, body,\n\t\t\tOK);\n}", "target": 1}
{"code": "WebKit::WebView* RenderView::webview() const {\n  return static_cast<WebKit::WebView*>(webwidget());\n}", "target": 0}
{"code": "static ssize_t read_mem(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tphys_addr_t p = *ppos;\n\tssize_t read, sz;\n\tvoid *ptr;\n\tif (p != *ppos)\n\t\treturn 0;\n\tif (!valid_phys_addr_range(p, count))\n\t\treturn -EFAULT;\n\tread = 0;\n#ifdef __ARCH_HAS_NO_PAGE_ZERO_MAPPED\n\tif (p < PAGE_SIZE) {\n\t\tsz = size_inside_page(p, count);\n\t\tif (sz > 0) {\n\t\t\tif (clear_user(buf, sz))\n\t\t\t\treturn -EFAULT;\n\t\t\tbuf += sz;\n\t\t\tp += sz;\n\t\t\tcount -= sz;\n\t\t\tread += sz;\n\t\t}\n\t}\n#endif\n\twhile (count > 0) {\n\t\tunsigned long remaining;\n\t\tsz = size_inside_page(p, count);\n\t\tif (!range_is_allowed(p >> PAGE_SHIFT, count))\n\t\t\treturn -EPERM;\n\t\tptr = xlate_dev_mem_ptr(p);\n\t\tif (!ptr)\n\t\t\treturn -EFAULT;\n\t\tremaining = copy_to_user(buf, ptr, sz);\n\t\tunxlate_dev_mem_ptr(p, ptr);\n\t\tif (remaining)\n\t\t\treturn -EFAULT;\n\t\tbuf += sz;\n\t\tp += sz;\n\t\tcount -= sz;\n\t\tread += sz;\n\t}\n\t*ppos += read;\n\treturn read;\n}", "target": 1}
{"code": "int ipfilter(struct pico_frame *f)\n{\n    struct filter_node temp;\n    struct pico_ipv4_hdr *ipv4_hdr = (struct pico_ipv4_hdr *) f->net_hdr;\n    struct pico_trans *trans;\n    struct pico_icmp4_hdr *icmp_hdr;\n    memset(&temp, 0u, sizeof(struct filter_node));\n    temp.fdev = f->dev;\n    temp.out_addr = ipv4_hdr->dst.addr;\n    temp.in_addr = ipv4_hdr->src.addr;\n    if ((ipv4_hdr->proto == PICO_PROTO_TCP) || (ipv4_hdr->proto == PICO_PROTO_UDP)) {\n        trans = (struct pico_trans *) f->transport_hdr;\n        temp.out_port = short_be(trans->dport);\n        temp.in_port = short_be(trans->sport);\n    }\n    else if(ipv4_hdr->proto == PICO_PROTO_ICMP4) {\n        icmp_hdr = (struct pico_icmp4_hdr *) f->transport_hdr;\n        if(icmp_hdr->type == PICO_ICMP_UNREACH && icmp_hdr->code == PICO_ICMP_UNREACH_FILTER_PROHIB)\n            return 0;\n    }\n    temp.proto = ipv4_hdr->proto;\n    temp.priority = f->priority;\n    temp.tos = ipv4_hdr->tos;\n    return ipfilter_apply_filter(f, &temp);\n}", "target": 1}
{"code": "static inline void tss_invalidate_io_bitmap(void)\n{\n\tPVOP_VCALL0(cpu.invalidate_io_bitmap);\n}", "target": 0}
{"code": "bool req_is_in_chain(struct smb_request *req)\n{\n\tif (req->vwv != (uint16_t *)(req->inbuf+smb_vwv)) {\n\t\treturn true;\n\t}\n\tif (!is_andx_req(req->cmd)) {\n\t\treturn false;\n\t}\n\tif (req->wct < 2) {\n\t\treturn false;\n\t}\n\treturn (CVAL(req->vwv+0, 0) != 0xFF);\n}", "target": 0}
{"code": "static struct sk_buff *xfrm_state_netlink(struct sk_buff *in_skb,\n\t\t\t\t\t  struct xfrm_state *x, u32 seq)\n{\n\tstruct xfrm_dump_info info;\n\tstruct sk_buff *skb;\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\tinfo.in_skb = in_skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = seq;\n\tinfo.nlmsg_flags = 0;\n\tif (dump_one_state(x, 0, &info)) {\n\t\tkfree_skb(skb);\n\t\treturn NULL;\n\t}\n\treturn skb;\n}", "target": 1}
{"code": "  Logger* logger() {\n    ASSERT(logger_ != NULL);\n    return logger_;\n  }", "target": 0}
{"code": "  void SetInput(const std::vector<float>& data) {\n    QuantizeAndPopulate<uint8_t>(input_, data);\n  }", "target": 0}
{"code": "file_fmtcheck(struct magic_set *ms, const char *desc, const char *def,\n\tconst char *file, size_t line)\n{\n\tconst char *ptr = fmtcheck(desc, def);\n\tif (ptr == def)\n\t\tfile_magerror(ms,\n\t\t    \"%s, %\" SIZE_T_FORMAT \"u: format `%s' does not match\"\n\t\t    \" with `%s'\", file, line, desc, def);\n\treturn ptr;\n}", "target": 0}
{"code": "DwaCompressor::uncompress\n    (const char *inPtr,\n     int inSize,\n     int minY,\n     const char *&outPtr)\n{\n    return uncompress (inPtr,\n                       inSize,\n                       IMATH_NAMESPACE::Box2i (IMATH_NAMESPACE::V2i (_min[0], minY),\n                       IMATH_NAMESPACE::V2i (_max[0], minY + numScanLines() - 1)),\n                       outPtr);\n}", "target": 0}
{"code": "void nfs_idmap_quit(void)\n{\n\tnfs_idmap_quit_keyring();\n}", "target": 0}
{"code": "static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof)\n{\n\tchar *ksep, *vsep, *val;\n\tsize_t klen, vlen;\n\tsize_t new_vlen;\n\tif (var->ptr >= var->end) {\n\t\treturn 0;\n\t}\n\tvsep = memchr(var->ptr, '&', var->end - var->ptr);\n\tif (!vsep) {\n\t\tif (!eof) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tvsep = var->end;\n\t\t}\n\t}\n\tksep = memchr(var->ptr, '=', vsep - var->ptr);\n\tif (ksep) {\n\t\t*ksep = '\\0';\n\t\tklen = ksep - var->ptr;\n\t\tvlen = vsep - ++ksep;\n\t} else {\n\t\tksep = \"\";\n\t\tklen = vsep - var->ptr;\n\t\tvlen = 0;\n\t}\n\tphp_url_decode(var->ptr, klen);\n\tval = estrndup(ksep, vlen);\n\tif (vlen) {\n\t\tvlen = php_url_decode(val, vlen);\n\t}\n\tif (sapi_module.input_filter(PARSE_POST, var->ptr, &val, vlen, &new_vlen)) {\n\t\tphp_register_variable_safe(var->ptr, val, new_vlen, arr);\n\t}\n\tefree(val);\n\tvar->ptr = vsep + (vsep != var->end);\n\treturn 1;\n}", "target": 1}
{"code": "struct mosquitto *context__init(mosq_sock_t sock)\n{\n\tstruct mosquitto *context;\n\tchar address[1024];\n\tcontext = mosquitto__calloc(1, sizeof(struct mosquitto));\n\tif(!context) return NULL;\n#ifdef WITH_EPOLL\n\tcontext->ident = id_client;\n#else\n\tcontext->pollfd_index = -1;\n#endif\n\tmosquitto__set_state(context, mosq_cs_new);\n\tcontext->sock = sock;\n\tcontext->last_msg_in = db.now_s;\n\tcontext->next_msg_out = db.now_s + 60;\n\tcontext->keepalive = 60; \n\tcontext->clean_start = true;\n\tcontext->id = NULL;\n\tcontext->last_mid = 0;\n\tcontext->will = NULL;\n\tcontext->username = NULL;\n\tcontext->password = NULL;\n\tcontext->listener = NULL;\n\tcontext->acl_list = NULL;\n\tcontext->retain_available = true;\n\tcontext->is_bridge = false;\n\tcontext->in_packet.payload = NULL;\n\tpacket__cleanup(&context->in_packet);\n\tcontext->out_packet = NULL;\n\tcontext->current_out_packet = NULL;\n\tcontext->out_packet_count = 0;\n\tcontext->address = NULL;\n\tif((int)sock >= 0){\n\t\tif(!net__socket_get_address(sock, address, 1024, &context->remote_port)){\n\t\t\tcontext->address = mosquitto__strdup(address);\n\t\t}\n\t\tif(!context->address){\n\t\t\tmosquitto__free(context);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tcontext->bridge = NULL;\n\tcontext->msgs_in.inflight_maximum = db.config->max_inflight_messages;\n\tcontext->msgs_out.inflight_maximum = db.config->max_inflight_messages;\n\tcontext->msgs_in.inflight_quota = db.config->max_inflight_messages;\n\tcontext->msgs_out.inflight_quota = db.config->max_inflight_messages;\n\tcontext->max_qos = 2;\n#ifdef WITH_TLS\n\tcontext->ssl = NULL;\n#endif\n\tif((int)context->sock >= 0){\n\t\tHASH_ADD(hh_sock, db.contexts_by_sock, sock, sizeof(context->sock), context);\n\t}\n\treturn context;\n}", "target": 1}
{"code": "child_func (void * const arg)\n{\n  xclose (sockfd[0]);\n  const int sock = sockfd[1];\n  char ch;\n  TEST_VERIFY_EXIT (read (sock, &ch, 1) == 1);\n  TEST_VERIFY_EXIT (ch == '1');\n  if (mount (\"/\", MOUNT_NAME, NULL, MS_BIND | MS_REC, NULL))\n    FAIL_EXIT1 (\"mount failed: %m\\n\");\n  const int fd = xopen (\"mpoint\",\n\t\t\tO_RDONLY | O_PATH | O_DIRECTORY | O_NOFOLLOW, 0);\n  send_fd (sock, fd);\n  xclose (fd);\n  TEST_VERIFY_EXIT (read (sock, &ch, 1) == 1);\n  TEST_VERIFY_EXIT (ch == 'a');\n  xclose (sock);\n  return 0;\n}", "target": 0}
{"code": "bool CSPSource::portMatches(const KURL& url) const\n{\n    if (m_portWildcard == HasWildcard)\n        return true;\n    int port = url.port();\n    if (port == m_port)\n        return true;\n    if (!port)\n        return isDefaultPortForProtocol(m_port, url.protocol());\n    if (!m_port)\n        return isDefaultPortForProtocol(port, url.protocol());\n    return false;\n}", "target": 0}
{"code": "static void release_posix_timer(struct k_itimer *tmr, int it_id_set)\n{\n\tif (it_id_set) {\n\t\tunsigned long flags;\n\t\tspin_lock_irqsave(&hash_lock, flags);\n\t\thlist_del_rcu(&tmr->t_hash);\n\t\tspin_unlock_irqrestore(&hash_lock, flags);\n\t}\n\tput_pid(tmr->it_pid);\n\tsigqueue_free(tmr->sigq);\n\tcall_rcu(&tmr->it.rcu, k_itimer_rcu_free);\n}", "target": 0}
{"code": "decodeJsonStructure(void *dst, const UA_DataType *type, CtxJson *ctx, \n                    ParseCtx *parseCtx, UA_Boolean moveToken) {\n    (void) moveToken;\n    if(ctx->depth > UA_JSON_ENCODING_MAX_RECURSION)\n        return UA_STATUSCODE_BADENCODINGERROR;\n    ctx->depth++;\n    uintptr_t ptr = (uintptr_t)dst;\n    status ret = UA_STATUSCODE_GOOD;\n    u8 membersSize = type->membersSize;\n    const UA_DataType *typelists[2] = { UA_TYPES, &type[-type->typeIndex] };\n    UA_STACKARRAY(DecodeEntry, entries, membersSize);\n    for(size_t i = 0; i < membersSize && ret == UA_STATUSCODE_GOOD; ++i) {\n        const UA_DataTypeMember *m = &type->members[i];\n        const UA_DataType *mt = &typelists[!m->namespaceZero][m->memberTypeIndex];\n        entries[i].type = mt;\n        if(!m->isArray) {\n            ptr += m->padding;\n            entries[i].fieldName = m->memberName;\n            entries[i].fieldPointer = (void*)ptr;\n            entries[i].function = decodeJsonJumpTable[mt->typeKind];\n            entries[i].found = false;\n            ptr += mt->memSize;\n        } else {\n            ptr += m->padding;\n            ptr += sizeof(size_t);\n            entries[i].fieldName = m->memberName;\n            entries[i].fieldPointer = (void*)ptr;\n            entries[i].function = (decodeJsonSignature)Array_decodeJson;\n            entries[i].found = false;\n            ptr += sizeof(void*);\n        }\n    }\n    ret = decodeFields(ctx, parseCtx, entries, membersSize, type);\n    ctx->depth--;\n    return ret;\n}", "target": 1}
{"code": "ExpressionMap::ExpressionMap(ExpressionContext* const expCtx,\n                             const string& varName,\n                             Variables::Id varId,\n                             intrusive_ptr<Expression> input,\n                             intrusive_ptr<Expression> each)\n    : Expression(expCtx, {std::move(input), std::move(each)}),\n      _varName(varName),\n      _varId(varId),\n      _input(_children[0]),\n      _each(_children[1]) {}", "target": 0}
{"code": "    size_t operator()(const std::string &str) const\n    {\n        const size_t A = 6665339;\n        const size_t B = 2534641;\n        size_t h = fixedRandomNumber;\n        for (char ch : str)\n            h = (h * A) ^ (ch * B);\n        return h;\n    }", "target": 0}
{"code": "struct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6,\n\t\t\t\t   const struct sk_buff *skb,\n\t\t\t\t   int flags, pol_lookup_t lookup)\n{\n\tstruct rt6_info *rt;\n\trt = lookup(net, net->ipv6.fib6_main_tbl, fl6, skb, flags);\n\tif (rt->dst.error == -EAGAIN) {\n\t\tip6_rt_put_flags(rt, flags);\n\t\trt = net->ipv6.ip6_null_entry;\n\t\tif (!(flags | RT6_LOOKUP_F_DST_NOREF))\n\t\t\tdst_hold(&rt->dst);\n\t}\n\treturn &rt->dst;\n}", "target": 1}
{"code": "bool CSPSource::isSchemeOnly() const\n{\n    return m_host.isEmpty();\n}", "target": 0}
{"code": "int DISOpticalFlowImpl::autoSelectCoarsestScale(int img_width)\n{\n    const int fratio = 5;\n    return std::max(0, (int)std::floor(log2((2.0f*(float)img_width) / ((float)fratio * (float)patch_size))));\n}", "target": 0}
{"code": "static inline void ModulateHSL(const double percent_hue,\n  const double percent_saturation,const double percent_lightness,double *red,\n  double *green,double *blue)\n{\n  double\n    hue,\n    lightness,\n    saturation;\n  ConvertRGBToHSL(*red,*green,*blue,&hue,&saturation,&lightness);\n  hue+=0.5*(0.01*percent_hue-1.0);\n  saturation*=0.01*percent_saturation;\n  lightness*=0.01*percent_lightness;\n  ConvertHSLToRGB(hue,saturation,lightness,red,green,blue);\n}", "target": 0}
{"code": "void cql_server::response::write_long_string(const sstring& s)\n{\n    write_int(cast_if_fits<int32_t>(s.size()));\n    _body.write(bytes_view(reinterpret_cast<const int8_t*>(s.data()), s.size()));\n}", "target": 0}
{"code": "static BOOL autodetect_recv_bandwidth_measure_results(rdpRdp* rdp, wStream* s,\n                                                      AUTODETECT_RSP_PDU* autodetectRspPdu)\n{\n\tBOOL success = TRUE;\n\tif (autodetectRspPdu->headerLength != 0x0E)\n\t\treturn FALSE;\n\tWLog_VRB(AUTODETECT_TAG, \"received Bandwidth Measure Results PDU\");\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn -1;\n\tStream_Read_UINT32(s, rdp->autodetect->bandwidthMeasureTimeDelta); \n\tStream_Read_UINT32(s, rdp->autodetect->bandwidthMeasureByteCount); \n\tif (rdp->autodetect->bandwidthMeasureTimeDelta > 0)\n\t\trdp->autodetect->netCharBandwidth = rdp->autodetect->bandwidthMeasureByteCount * 8 /\n\t\t                                    rdp->autodetect->bandwidthMeasureTimeDelta;\n\telse\n\t\trdp->autodetect->netCharBandwidth = 0;\n\tIFCALLRET(rdp->autodetect->BandwidthMeasureResults, success, rdp->context,\n\t          autodetectRspPdu->sequenceNumber);\n\treturn success;\n}", "target": 0}
{"code": "static struct phy *serdes_simple_xlate(struct device *dev,\n\t\t\t\t       struct of_phandle_args *args)\n{\n\tstruct serdes_ctrl *ctrl = dev_get_drvdata(dev);\n\tunsigned int port, idx, i;\n\tif (args->args_count != 2)\n\t\treturn ERR_PTR(-EINVAL);\n\tport = args->args[0];\n\tidx = args->args[1];\n\tfor (i = 0; i <= SERDES_MAX; i++) {\n\t\tstruct serdes_macro *macro = phy_get_drvdata(ctrl->phys[i]);\n\t\tif (idx != macro->idx)\n\t\t\tcontinue;\n\t\tif (idx != SERDES6G(0) && macro->port >= 0)\n\t\t\treturn ERR_PTR(-EBUSY);\n\t\tmacro->port = port;\n\t\treturn ctrl->phys[i];\n\t}\n\treturn ERR_PTR(-ENODEV);\n}", "target": 1}
{"code": "static void nfs4_return_incompatible_delegation(struct inode *inode, mode_t open_flags)\n{\n\tstruct nfs_delegation *delegation;\n\trcu_read_lock();\n\tdelegation = rcu_dereference(NFS_I(inode)->delegation);\n\tif (delegation == NULL || (delegation->type & open_flags) == open_flags) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\trcu_read_unlock();\n\tnfs_inode_return_delegation(inode);\n}", "target": 1}
{"code": "MONGO_EXPORT int bson_append_regex( bson *b, const char *name, const char *pattern, const char *opts ) {\n    const int plen = strlen( pattern )+1;\n    const int olen = strlen( opts )+1;\n    if ( bson_append_estart( b, BSON_REGEX, name, plen + olen ) == BSON_ERROR )\n        return BSON_ERROR;\n    if ( bson_check_string( b, pattern, plen - 1 ) == BSON_ERROR )\n        return BSON_ERROR;\n    bson_append( b , pattern , plen );\n    bson_append( b , opts , olen );\n    return BSON_OK;\n}", "target": 1}
{"code": "static int mon_bin_mmap(struct file *filp, struct vm_area_struct *vma)\n{\n\tvma->vm_ops = &mon_bin_vm_ops;\n\tif (vma->vm_flags & VM_WRITE)\n\t\treturn -EPERM;\n\tvma->vm_flags &= ~VM_MAYWRITE;\n\tvma->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;\n\tvma->vm_private_data = filp->private_data;\n\tmon_bin_vma_open(vma);\n\treturn 0;\n}", "target": 0}
{"code": "static int rds_ib_laddr_check(__be32 addr)\n{\n\tint ret;\n\tstruct rdma_cm_id *cm_id;\n\tstruct sockaddr_in sin;\n\tcm_id = rdma_create_id(NULL, NULL, RDMA_PS_TCP, IB_QPT_RC);\n\tif (IS_ERR(cm_id))\n\t\treturn PTR_ERR(cm_id);\n\tmemset(&sin, 0, sizeof(sin));\n\tsin.sin_family = AF_INET;\n\tsin.sin_addr.s_addr = addr;\n\tret = rdma_bind_addr(cm_id, (struct sockaddr *)&sin);\n\tif (ret || cm_id->device->node_type != RDMA_NODE_IB_CA)\n\t\tret = -EADDRNOTAVAIL;\n\trdsdebug(\"addr %pI4 ret %d node type %d\\n\",\n\t\t&addr, ret,\n\t\tcm_id->device ? cm_id->device->node_type : -1);\n\trdma_destroy_id(cm_id);\n\treturn ret;\n}", "target": 1}
{"code": "void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n\t{\n#ifdef BN_LLONG\n\tBN_ULLONG t;\n#else\n\tBN_ULONG bl,bh;\n#endif\n\tBN_ULONG t1,t2;\n\tBN_ULONG c1,c2,c3;\n\tc1=0;\n\tc2=0;\n\tc3=0;\n\tmul_add_c(a[0],b[0],c1,c2,c3);\n\tr[0]=c1;\n\tc1=0;\n\tmul_add_c(a[0],b[1],c2,c3,c1);\n\tmul_add_c(a[1],b[0],c2,c3,c1);\n\tr[1]=c2;\n\tc2=0;\n\tmul_add_c(a[2],b[0],c3,c1,c2);\n\tmul_add_c(a[1],b[1],c3,c1,c2);\n\tmul_add_c(a[0],b[2],c3,c1,c2);\n\tr[2]=c3;\n\tc3=0;\n\tmul_add_c(a[0],b[3],c1,c2,c3);\n\tmul_add_c(a[1],b[2],c1,c2,c3);\n\tmul_add_c(a[2],b[1],c1,c2,c3);\n\tmul_add_c(a[3],b[0],c1,c2,c3);\n\tr[3]=c1;\n\tc1=0;\n\tmul_add_c(a[3],b[1],c2,c3,c1);\n\tmul_add_c(a[2],b[2],c2,c3,c1);\n\tmul_add_c(a[1],b[3],c2,c3,c1);\n\tr[4]=c2;\n\tc2=0;\n\tmul_add_c(a[2],b[3],c3,c1,c2);\n\tmul_add_c(a[3],b[2],c3,c1,c2);\n\tr[5]=c3;\n\tc3=0;\n\tmul_add_c(a[3],b[3],c1,c2,c3);\n\tr[6]=c1;\n\tr[7]=c2;\n\t}", "target": 1}
{"code": "EntropyParser::EntropyParser(class Frame *frame,class Scan *scan)\n  : JKeeper(scan->EnvironOf()), m_pScan(scan), m_pFrame(frame)\n{\n  m_ucCount = scan->ComponentsInScan();\n  for(volatile UBYTE i = 0;i < m_ucCount && i < 4;i++) {\n    JPG_TRY {\n      m_pComponent[i] = scan->ComponentOf(i);\n    } JPG_CATCH {\n      m_pComponent[i] = NULL;\n    } JPG_ENDTRY;\n  }\n  m_ulRestartInterval   = m_pFrame->TablesOf()->RestartIntervalOf();\n  m_usNextRestartMarker = 0xffd0;\n  m_ulMCUsToGo          = m_ulRestartInterval;\n  m_bSegmentIsValid     = true;\n  m_bScanForDNL         = (m_pFrame->HeightOf() == 0)?true:false;\n  m_bDNLFound           = false;\n}", "target": 1}
{"code": "rpl_dio_printopt(netdissect_options *ndo,\n                 const struct rpl_dio_genoption *opt,\n                 u_int length)\n{\n        if(length < RPL_DIO_GENOPTION_LEN) return;\n        length -= RPL_DIO_GENOPTION_LEN;\n        ND_TCHECK(opt->rpl_dio_len);\n        while((opt->rpl_dio_type == RPL_OPT_PAD0 &&\n               (const u_char *)opt < ndo->ndo_snapend) ||\n              ND_TTEST2(*opt,(opt->rpl_dio_len+2))) {\n                unsigned int optlen = opt->rpl_dio_len+2;\n                if(opt->rpl_dio_type == RPL_OPT_PAD0) {\n                        optlen = 1;\n                        ND_PRINT((ndo, \" opt:pad0\"));\n                } else {\n                        ND_PRINT((ndo, \" opt:%s len:%u \",\n                                  tok2str(rpl_subopt_values, \"subopt:%u\", opt->rpl_dio_type),\n                                  optlen));\n                        if(ndo->ndo_vflag > 2) {\n                                unsigned int paylen = opt->rpl_dio_len;\n                                if(paylen > length) paylen = length;\n                                hex_print(ndo,\n                                          \" \",\n                                          ((const uint8_t *)opt) + RPL_DIO_GENOPTION_LEN,  \n                                          paylen);\n                        }\n                }\n                opt = (const struct rpl_dio_genoption *)(((const char *)opt) + optlen);\n                length -= optlen;\n        }\n        return;\ntrunc:\n\tND_PRINT((ndo,\" [|truncated]\"));\n\treturn;\n}", "target": 1}
{"code": "void RenderWidgetHostImpl::ForwardMouseEvent(const WebMouseEvent& mouse_event) {\n  ForwardMouseEventWithLatencyInfo(mouse_event, ui::LatencyInfo());\n  if (owner_delegate_)\n    owner_delegate_->RenderWidgetDidForwardMouseEvent(mouse_event);\n}", "target": 0}
{"code": "static int input_default_setkeycode(struct input_dev *dev,\n\t\t\t\t    const struct input_keymap_entry *ke,\n\t\t\t\t    unsigned int *old_keycode)\n{\n\tunsigned int index;\n\tint error;\n\tint i;\n\tif (!dev->keycodesize)\n\t\treturn -EINVAL;\n\tif (ke->flags & INPUT_KEYMAP_BY_INDEX) {\n\t\tindex = ke->index;\n\t} else {\n\t\terror = input_scancode_to_scalar(ke, &index);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (index >= dev->keycodemax)\n\t\treturn -EINVAL;\n\tif (dev->keycodesize < sizeof(ke->keycode) &&\n\t\t\t(ke->keycode >> (dev->keycodesize * 8)))\n\t\treturn -EINVAL;\n\tswitch (dev->keycodesize) {\n\t\tcase 1: {\n\t\t\tu8 *k = (u8 *)dev->keycode;\n\t\t\t*old_keycode = k[index];\n\t\t\tk[index] = ke->keycode;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2: {\n\t\t\tu16 *k = (u16 *)dev->keycode;\n\t\t\t*old_keycode = k[index];\n\t\t\tk[index] = ke->keycode;\n\t\t\tbreak;\n\t\t}\n\t\tdefault: {\n\t\t\tu32 *k = (u32 *)dev->keycode;\n\t\t\t*old_keycode = k[index];\n\t\t\tk[index] = ke->keycode;\n\t\t\tbreak;\n\t\t}\n\t}\n\t__clear_bit(*old_keycode, dev->keybit);\n\t__set_bit(ke->keycode, dev->keybit);\n\tfor (i = 0; i < dev->keycodemax; i++) {\n\t\tif (input_fetch_keycode(dev, i) == *old_keycode) {\n\t\t\t__set_bit(*old_keycode, dev->keybit);\n\t\t\tbreak; \n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "String *Item_decimal::val_str(String *result)\n{\n  result->set_charset(&my_charset_numeric);\n  my_decimal2string(E_DEC_FATAL_ERROR, &decimal_value, 0, 0, 0, result);\n  return result;\n}", "target": 0}
{"code": "long keyctl_update_key(key_serial_t id,\n\t\t       const void __user *_payload,\n\t\t       size_t plen)\n{\n\tkey_ref_t key_ref;\n\tvoid *payload;\n\tlong ret;\n\tret = -EINVAL;\n\tif (plen > PAGE_SIZE)\n\t\tgoto error;\n\tpayload = NULL;\n\tif (_payload) {\n\t\tret = -ENOMEM;\n\t\tpayload = kmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error;\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(payload, _payload, plen) != 0)\n\t\t\tgoto error2;\n\t}\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_WRITE);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\tret = key_update(key_ref, payload, plen);\n\tkey_ref_put(key_ref);\nerror2:\n\tkfree(payload);\nerror:\n\treturn ret;\n}", "target": 1}
{"code": "static Jsi_RC NumberToPrecisionCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[100];\n    int prec = 0, skip = 0;\n    Jsi_Number num;\n    Jsi_Value *v;\n    ChkStringN(_this, funcPtr, v);\n    if (Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, skip), &prec) != JSI_OK)\n        return JSI_ERROR;\n    if (prec<=0) return JSI_ERROR;\n    Jsi_GetDoubleFromValue(interp, v, &num);\n    snprintf(buf, sizeof(buf),\"%.*\" JSI_NUMFFMT, prec, num);\n    if (num<0)\n        prec++;\n    buf[prec+1] = 0;\n    if (buf[prec] == '.')\n        buf[prec] = 0;\n    Jsi_ValueMakeStringDup(interp, ret, buf);\n    return JSI_OK;\n}", "target": 1}
{"code": "TEE_Result syscall_cryp_obj_populate(unsigned long obj,\n\t\t\tstruct utee_attribute *usr_attrs,\n\t\t\tunsigned long attr_count)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\tconst struct tee_cryp_obj_type_props *type_props;\n\tTEE_Attribute *attrs = NULL;\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\ttype_props = tee_svc_find_type_props(o->info.objectType);\n\tif (!type_props)\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\tattrs = malloc(sizeof(TEE_Attribute) * attr_count);\n\tif (!attrs)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_attrs, attr_count,\n\t\t\t    attrs);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\tres = tee_svc_cryp_check_attr(ATTR_USAGE_POPULATE, type_props,\n\t\t\t\t      attrs, attr_count);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\tres = tee_svc_cryp_obj_populate_type(o, type_props, attrs, attr_count);\n\tif (res == TEE_SUCCESS)\n\t\to->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\nout:\n\tfree(attrs);\n\treturn res;\n}", "target": 1}
{"code": "ext4_xattr_block_list(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct buffer_head *bh = NULL;\n\tint error;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\tea_idebug(inode, \"buffer=%p, buffer_size=%ld\",\n\t\t  buffer, (long)buffer_size);\n\terror = 0;\n\tif (!EXT4_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tea_idebug(inode, \"reading block %llu\",\n\t\t  (unsigned long long)EXT4_I(inode)->i_file_acl);\n\tbh = sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl);\n\terror = -EIO;\n\tif (!bh)\n\t\tgoto cleanup;\n\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\tatomic_read(&(bh->b_count)), le32_to_cpu(BHDR(bh)->h_refcount));\n\tif (ext4_xattr_check_block(inode, bh)) {\n\t\tEXT4_ERROR_INODE(inode, \"bad block %llu\",\n\t\t\t\t EXT4_I(inode)->i_file_acl);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto cleanup;\n\t}\n\text4_xattr_cache_insert(ext4_mb_cache, bh);\n\terror = ext4_xattr_list_entries(dentry, BFIRST(bh), buffer, buffer_size);\ncleanup:\n\tbrelse(bh);\n\treturn error;\n}", "target": 1}
{"code": "juniper_mfr_print(netdissect_options *ndo,\n                  const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n        memset(&l2info, 0, sizeof(l2info));\n        l2info.pictype = DLT_JUNIPER_MFR;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n        p+=l2info.header_len;\n        if (l2info.cookie_len == 0) {\n            mfr_print(ndo, p, l2info.length);\n            return l2info.header_len;\n        }\n        if (l2info.cookie_len == AS_PIC_COOKIE_LEN) {\n            switch(l2info.proto) {\n            case JUNIPER_LSQ_L3_PROTO_IPV4:\n                ip_print(ndo, p, l2info.length);\n                return l2info.header_len;\n            case JUNIPER_LSQ_L3_PROTO_IPV6:\n                ip6_print(ndo, p,l2info.length);\n                return l2info.header_len;\n            case JUNIPER_LSQ_L3_PROTO_MPLS:\n                mpls_print(ndo, p, l2info.length);\n                return l2info.header_len;\n            case JUNIPER_LSQ_L3_PROTO_ISO:\n                isoclns_print(ndo, p, l2info.length, l2info.caplen);\n                return l2info.header_len;\n            default:\n                break;\n            }\n            return l2info.header_len;\n        }\n        if (ndo->ndo_eflag && EXTRACT_32BITS(l2info.cookie) != 1)\n            ND_PRINT((ndo, \"Bundle-ID %u, \", l2info.bundle));\n        switch (l2info.proto) {\n        case (LLCSAP_ISONS<<8 | LLCSAP_ISONS):\n            isoclns_print(ndo, p + 1, l2info.length - 1, l2info.caplen - 1);\n            break;\n        case (LLC_UI<<8 | NLPID_Q933):\n        case (LLC_UI<<8 | NLPID_IP):\n        case (LLC_UI<<8 | NLPID_IP6):\n            isoclns_print(ndo, p - 1, l2info.length + 1, l2info.caplen + 1);\n            break;\n        default:\n            ND_PRINT((ndo, \"unknown protocol 0x%04x, length %u\", l2info.proto, l2info.length));\n        }\n        return l2info.header_len;\n}", "target": 1}
{"code": "SYSCALL_DEFINE6(move_pages, pid_t, pid, unsigned long, nr_pages,\n\t\tconst void __user * __user *, pages,\n\t\tconst int __user *, nodes,\n\t\tint __user *, status, int, flags)\n{\n\tconst struct cred *cred = current_cred(), *tcred;\n\tstruct task_struct *task;\n\tstruct mm_struct *mm;\n\tint err;\n\tnodemask_t task_nodes;\n\tif (flags & ~(MPOL_MF_MOVE|MPOL_MF_MOVE_ALL))\n\t\treturn -EINVAL;\n\tif ((flags & MPOL_MF_MOVE_ALL) && !capable(CAP_SYS_NICE))\n\t\treturn -EPERM;\n\trcu_read_lock();\n\ttask = pid ? find_task_by_vpid(pid) : current;\n\tif (!task) {\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\tget_task_struct(task);\n\ttcred = __task_cred(task);\n\tif (!uid_eq(cred->euid, tcred->suid) && !uid_eq(cred->euid, tcred->uid) &&\n\t    !uid_eq(cred->uid,  tcred->suid) && !uid_eq(cred->uid,  tcred->uid) &&\n\t    !capable(CAP_SYS_NICE)) {\n\t\trcu_read_unlock();\n\t\terr = -EPERM;\n\t\tgoto out;\n\t}\n\trcu_read_unlock();\n \terr = security_task_movememory(task);\n \tif (err)\n\t\tgoto out;\n\ttask_nodes = cpuset_mems_allowed(task);\n\tmm = get_task_mm(task);\n\tput_task_struct(task);\n\tif (!mm)\n\t\treturn -EINVAL;\n\tif (nodes)\n\t\terr = do_pages_move(mm, task_nodes, nr_pages, pages,\n\t\t\t\t    nodes, status, flags);\n\telse\n\t\terr = do_pages_stat(mm, nr_pages, pages, status);\n\tmmput(mm);\n\treturn err;\nout:\n\tput_task_struct(task);\n\treturn err;\n}", "target": 1}
{"code": "xmlValidNormalizeAttributeValue(xmlDocPtr doc, xmlNodePtr elem,\n\t\t\t        const xmlChar *name, const xmlChar *value) {\n    xmlChar *ret, *dst;\n    const xmlChar *src;\n    xmlAttributePtr attrDecl = NULL;\n    if (doc == NULL) return(NULL);\n    if (elem == NULL) return(NULL);\n    if (name == NULL) return(NULL);\n    if (value == NULL) return(NULL);\n    if ((elem->ns != NULL) && (elem->ns->prefix != NULL)) {\n\txmlChar fn[50];\n\txmlChar *fullname;\n\tfullname = xmlBuildQName(elem->name, elem->ns->prefix, fn, 50);\n\tif (fullname == NULL)\n\t    return(NULL);\n\tif ((fullname != fn) && (fullname != elem->name))\n\t    xmlFree(fullname);\n    }\n    attrDecl = xmlGetDtdAttrDesc(doc->intSubset, elem->name, name);\n    if ((attrDecl == NULL) && (doc->extSubset != NULL))\n\tattrDecl = xmlGetDtdAttrDesc(doc->extSubset, elem->name, name);\n    if (attrDecl == NULL)\n\treturn(NULL);\n    if (attrDecl->atype == XML_ATTRIBUTE_CDATA)\n\treturn(NULL);\n    ret = xmlStrdup(value);\n    if (ret == NULL)\n\treturn(NULL);\n    src = value;\n    dst = ret;\n    while (*src == 0x20) src++;\n    while (*src != 0) {\n\tif (*src == 0x20) {\n\t    while (*src == 0x20) src++;\n\t    if (*src != 0)\n\t\t*dst++ = 0x20;\n\t} else {\n\t    *dst++ = *src++;\n\t}\n    }\n    *dst = 0;\n    return(ret);\n}", "target": 1}
{"code": "int crypto_reportstat(struct sk_buff *in_skb, struct nlmsghdr *in_nlh,\n\t\t      struct nlattr **attrs)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct crypto_user_alg *p = nlmsg_data(in_nlh);\n\tstruct crypto_alg *alg;\n\tstruct sk_buff *skb;\n\tstruct crypto_dump_info info;\n\tint err;\n\tif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\n\t\treturn -EINVAL;\n\talg = crypto_alg_match(p, 0);\n\tif (!alg)\n\t\treturn -ENOENT;\n\terr = -ENOMEM;\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto drop_alg;\n\tinfo.in_skb = in_skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = in_nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = 0;\n\terr = crypto_reportstat_alg(alg, &info);\ndrop_alg:\n\tcrypto_mod_put(alg);\n\tif (err)\n\t\treturn err;\n\treturn nlmsg_unicast(net->crypto_nlsk, skb, NETLINK_CB(in_skb).portid);\n}", "target": 1}
{"code": "int button_open(Button *b) {\n        char *p, name[256];\n        int r;\n        assert(b);\n        b->fd = safe_close(b->fd);\n        p = strjoina(\"/dev/input/\", b->name);\n        b->fd = open(p, O_RDWR|O_CLOEXEC|O_NOCTTY|O_NONBLOCK);\n        if (b->fd < 0)\n                return log_warning_errno(errno, \"Failed to open %s: %m\", p);\n        r = button_suitable(b);\n        if (r < 0)\n                return log_warning_errno(r, \"Failed to determine whether input device is relevant to us: %m\");\n        if (r == 0)\n                return log_debug_errno(SYNTHETIC_ERRNO(EADDRNOTAVAIL),\n                                       \"Device %s does not expose keys or switches relevant to us, ignoring.\",\n                                       p);\n        if (ioctl(b->fd, EVIOCGNAME(sizeof(name)), name) < 0) {\n                r = log_error_errno(errno, \"Failed to get input name: %m\");\n                goto fail;\n        }\n        (void) button_set_mask(b);\n        r = sd_event_add_io(b->manager->event, &b->io_event_source, b->fd, EPOLLIN, button_dispatch, b);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to add button event: %m\");\n                goto fail;\n        }\n        log_info(\"Watching system buttons on /dev/input/%s (%s)\", b->name, name);\n        return 0;\nfail:\n        b->fd = safe_close(b->fd);\n        return r;\n}", "target": 1}
{"code": "int yr_object_copy(\n    YR_OBJECT* object,\n    YR_OBJECT** object_copy)\n{\n  YR_OBJECT* copy;\n  YR_OBJECT* o;\n  YR_STRUCTURE_MEMBER* structure_member;\n  YR_OBJECT_FUNCTION* func;\n  YR_OBJECT_FUNCTION* func_copy;\n  int i;\n  *object_copy = NULL;\n  FAIL_ON_ERROR(yr_object_create(\n      object->type,\n      object->identifier,\n      NULL,\n      &copy));\n  switch(object->type)\n  {\n    case OBJECT_TYPE_INTEGER:\n      ((YR_OBJECT_INTEGER*) copy)->value = UNDEFINED;\n      break;\n    case OBJECT_TYPE_STRING:\n      ((YR_OBJECT_STRING*) copy)->value = NULL;\n      break;\n    case OBJECT_TYPE_FUNCTION:\n      func = (YR_OBJECT_FUNCTION*) object;\n      func_copy = (YR_OBJECT_FUNCTION*) copy;\n      FAIL_ON_ERROR_WITH_CLEANUP(\n        yr_object_copy(func->return_obj, &func_copy->return_obj),\n        yr_object_destroy(copy));\n      for (i = 0; i < MAX_OVERLOADED_FUNCTIONS; i++)\n        func_copy->prototypes[i] = func->prototypes[i];\n      break;\n    case OBJECT_TYPE_STRUCTURE:\n      structure_member = ((YR_OBJECT_STRUCTURE*) object)->members;\n      while (structure_member != NULL)\n      {\n        FAIL_ON_ERROR_WITH_CLEANUP(\n            yr_object_copy(structure_member->object, &o),\n            yr_object_destroy(copy));\n        FAIL_ON_ERROR_WITH_CLEANUP(\n            yr_object_structure_set_member(copy, o),\n            yr_free(o);\n            yr_object_destroy(copy));\n        structure_member = structure_member->next;\n      }\n      break;\n    case OBJECT_TYPE_ARRAY:\n      yr_object_copy(\n        ((YR_OBJECT_ARRAY *) object)->prototype_item,\n        &o);\n      ((YR_OBJECT_ARRAY *)copy)->prototype_item = o;\n      break;\n    case OBJECT_TYPE_DICTIONARY:\n      yr_object_copy(\n        ((YR_OBJECT_DICTIONARY *) object)->prototype_item,\n        &o);\n      ((YR_OBJECT_DICTIONARY *)copy)->prototype_item = o;\n      break;\n    default:\n      assert(FALSE);\n  }\n  *object_copy = copy;\n  return ERROR_SUCCESS;\n}", "target": 1}
{"code": "ppmd_read(void *p)\n{\n  struct archive_read *a = ((IByteIn*)p)->a;\n  struct rar *rar = (struct rar *)(a->format->data);\n  struct rar_br *br = &(rar->br);\n  Byte b;\n  if (!rar_br_read_ahead(a, br, 8))\n  {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Truncated RAR file data\");\n    rar->valid = 0;\n    return 0;\n  }\n  b = rar_br_bits(br, 8);\n  rar_br_consume(br, 8);\n  return b;\n}", "target": 0}
{"code": "int ntlm_read_message_fields_buffer(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (fields->Len > 0)\n\t{\n\t\tif ((fields->BufferOffset + fields->Len) > Stream_Length(s))\n\t\t\treturn -1;\n\t\tfields->Buffer = (PBYTE) malloc(fields->Len);\n\t\tif (!fields->Buffer)\n\t\t\treturn -1;\n\t\tStream_SetPosition(s, fields->BufferOffset);\n\t\tStream_Read(s, fields->Buffer, fields->Len);\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "static int fsmVerify(const char *path, rpmfi fi)\n{\n    int rc;\n    int saveerrno = errno;\n    struct stat dsb;\n    mode_t mode = rpmfiFMode(fi);\n    rc = fsmStat(path, 1, &dsb);\n    if (rc)\n\treturn rc;\n    if (S_ISREG(mode)) {\n\tchar *rmpath = rstrscat(NULL, path, \"-RPMDELETE\", NULL);\n\trc = fsmRename(path, rmpath);\n\tif (!rc)\n\t    (void) fsmUnlink(rmpath);\n\telse\n\t    rc = RPMERR_UNLINK_FAILED;\n\tfree(rmpath);\n        return (rc ? rc : RPMERR_ENOENT);\t\n    } else if (S_ISDIR(mode)) {\n        if (S_ISDIR(dsb.st_mode)) return 0;\n        if (S_ISLNK(dsb.st_mode)) {\n            rc = fsmStat(path, 0, &dsb);\n            if (rc == RPMERR_ENOENT) rc = 0;\n            if (rc) return rc;\n            errno = saveerrno;\n            if (S_ISDIR(dsb.st_mode)) return 0;\n        }\n    } else if (S_ISLNK(mode)) {\n        if (S_ISLNK(dsb.st_mode)) {\n            char buf[8 * BUFSIZ];\n            size_t len;\n            rc = fsmReadLink(path, buf, 8 * BUFSIZ, &len);\n            errno = saveerrno;\n            if (rc) return rc;\n            if (rstreq(rpmfiFLink(fi), buf)) return 0;\n        }\n    } else if (S_ISFIFO(mode)) {\n        if (S_ISFIFO(dsb.st_mode)) return 0;\n    } else if (S_ISCHR(mode) || S_ISBLK(mode)) {\n        if ((S_ISCHR(dsb.st_mode) || S_ISBLK(dsb.st_mode)) &&\n            (dsb.st_rdev == rpmfiFRdev(fi))) return 0;\n    } else if (S_ISSOCK(mode)) {\n        if (S_ISSOCK(dsb.st_mode)) return 0;\n    }\n    rc = fsmUnlink(path);\n    if (rc == 0)\trc = RPMERR_ENOENT;\n    return (rc ? rc : RPMERR_ENOENT);\t\n}", "target": 1}
{"code": "void V8DOMWrapper::setJSWrapperForActiveDOMObject(void* object, v8::Persistent<v8::Object> wrapper)\n{\n    ASSERT(V8DOMWrapper::maybeDOMWrapper(wrapper));\n#ifndef NDEBUG\n    V8ClassIndex::V8WrapperType type = V8DOMWrapper::domWrapperType(wrapper);\n    switch (type) {\n#define MAKE_CASE(TYPE, NAME) case V8ClassIndex::TYPE: break;\n        ACTIVE_DOM_OBJECT_TYPES(MAKE_CASE)\n    default: \n        ASSERT_NOT_REACHED();\n#undef MAKE_CASE\n    }\n#endif\n    getActiveDOMObjectMap().set(object, wrapper);\n}", "target": 0}
{"code": "validate_event(struct pmu_hw_events *hw_events,\n\t       struct perf_event *event)\n{\n\tstruct arm_pmu *armpmu = to_arm_pmu(event->pmu);\n\tstruct hw_perf_event fake_event = event->hw;\n\tstruct pmu *leader_pmu = event->group_leader->pmu;\n\tif (is_software_event(event))\n\t\treturn 1;\n\tif (event->pmu != leader_pmu || event->state < PERF_EVENT_STATE_OFF)\n\t\treturn 1;\n\tif (event->state == PERF_EVENT_STATE_OFF && !event->attr.enable_on_exec)\n\t\treturn 1;\n\treturn armpmu->get_event_idx(hw_events, &fake_event) >= 0;\n}", "target": 1}
{"code": "void dmar_free_irte(const struct intr_source *intr_src, uint16_t index)\n{\n\tstruct dmar_drhd_rt *dmar_unit;\n\tunion dmar_ir_entry *ir_table, *ir_entry;\n\tunion pci_bdf sid;\n\tif (intr_src->is_msi) {\n\t\tdmar_unit = device_to_dmaru((uint8_t)intr_src->src.msi.bits.b, intr_src->src.msi.fields.devfun);\n\t} else {\n\t\tdmar_unit = ioapic_to_dmaru(intr_src->src.ioapic_id, &sid);\n\t}\n\tif (is_dmar_unit_valid(dmar_unit, sid)) {\n\t\tir_table = (union dmar_ir_entry *)hpa2hva(dmar_unit->ir_table_addr);\n\t\tir_entry = ir_table + index;\n\t\tir_entry->bits.remap.present = 0x0UL;\n\t\tiommu_flush_cache(ir_entry, sizeof(union dmar_ir_entry));\n\t\tdmar_invalid_iec(dmar_unit, index, 0U, false);\n\t\tif (!is_irte_reserved(dmar_unit, index)) {\n\t\t\tspinlock_obtain(&dmar_unit->lock);\n\t\t\tbitmap_clear_nolock(index & 0x3FU, &dmar_unit->irte_alloc_bitmap[index >> 6U]);\n\t\t\tspinlock_release(&dmar_unit->lock);\n\t\t}\n\t}\n}", "target": 1}
{"code": "static int xfrm_dump_sa(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_state_walk *walk = (struct xfrm_state_walk *) &cb->args[1];\n\tstruct xfrm_dump_info info;\n\tBUILD_BUG_ON(sizeof(struct xfrm_state_walk) >\n\t\t     sizeof(cb->args) - sizeof(cb->args[0]));\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\tif (!cb->args[0]) {\n\t\tstruct nlattr *attrs[XFRMA_MAX+1];\n\t\tstruct xfrm_address_filter *filter = NULL;\n\t\tu8 proto = 0;\n\t\tint err;\n\t\tcb->args[0] = 1;\n\t\terr = nlmsg_parse(cb->nlh, 0, attrs, XFRMA_MAX,\n\t\t\t\t  xfrma_policy);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (attrs[XFRMA_ADDRESS_FILTER]) {\n\t\t\tfilter = kmemdup(nla_data(attrs[XFRMA_ADDRESS_FILTER]),\n\t\t\t\t\t sizeof(*filter), GFP_KERNEL);\n\t\t\tif (filter == NULL)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (attrs[XFRMA_PROTO])\n\t\t\tproto = nla_get_u8(attrs[XFRMA_PROTO]);\n\t\txfrm_state_walk_init(walk, proto, filter);\n\t}\n\t(void) xfrm_state_walk(net, walk, dump_one_state, &info);\n\treturn skb->len;\n}", "target": 1}
{"code": "void zend_extension_dtor(zend_extension *extension)\n{\n#if ZEND_EXTENSIONS_SUPPORT && !ZEND_DEBUG\n\tif (extension->handle) {\n\t\tDL_UNLOAD(extension->handle);\n\t}\n#endif\n}", "target": 0}
{"code": "segment_end (Elf_Internal_Phdr *segment, bfd_vma start)\n{\n  return start + segment_size (segment);\n}", "target": 0}
{"code": "static uint32_t mp_clzl(unsigned long x) {\n    unsigned long lz = 0;\n    return _BitScanReverse(&lz, x) ? (sizeof(x) * 8 - 1) - lz : 0;\n}", "target": 0}
{"code": "static Jsi_RC jsi_ArrayPopCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {\n        Jsi_ValueMakeNumber(interp, ret, 0);\n        return JSI_OK;\n    }\n    Jsi_Value *v;\n    Jsi_Obj *obj;\n    obj = _this->d.obj;\n    int i = Jsi_ObjGetLength(interp, obj) - 1;\n    if (i < 0) {\n        Jsi_ValueMakeUndef(interp, ret);\n        return JSI_OK;\n    }\n    if (obj->arr) {\n        if ((v = obj->arr[i])) {\n            obj->arr[i] = NULL;\n            obj->arrCnt--;\n        }\n    } else {\n        v = Jsi_ValueArrayIndex(interp, _this, i);\n    }\n    if (v) {\n        Jsi_DecrRefCount(interp, *ret);\n        *ret = v;\n    }\n    Jsi_ObjSetLength(interp, obj, i);\n    return JSI_OK;\n}", "target": 1}
{"code": "qemuProcessHandleMonitorEOF(qemuMonitorPtr mon,\n                            virDomainObjPtr vm,\n                            void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    qemuDomainObjPrivatePtr priv;\n    struct qemuProcessEvent *processEvent;\n    virObjectLock(vm);\n    VIR_DEBUG(\"Received EOF on %p '%s'\", vm, vm->def->name);\n    priv = vm->privateData;\n    if (priv->beingDestroyed) {\n        VIR_DEBUG(\"Domain is being destroyed, EOF is expected\");\n        goto cleanup;\n    }\n    processEvent = g_new0(struct qemuProcessEvent, 1);\n    processEvent->eventType = QEMU_PROCESS_EVENT_MONITOR_EOF;\n    processEvent->vm = virObjectRef(vm);\n    if (virThreadPoolSendJob(driver->workerPool, 0, processEvent) < 0) {\n        virObjectUnref(vm);\n        qemuProcessEventFree(processEvent);\n        goto cleanup;\n    }\n    virObjectLock(mon);\n    qemuMonitorUnregister(mon);\n    virObjectUnlock(mon);\n    qemuDomainDestroyNamespace(driver, vm);\n cleanup:\n    virObjectUnlock(vm);\n}", "target": 0}
{"code": "static int get_bitmap_file(struct mddev *mddev, void __user * arg)\n{\n\tmdu_bitmap_file_t *file = NULL; \n\tchar *ptr;\n\tint err;\n\tfile = kmalloc(sizeof(*file), GFP_NOIO);\n\tif (!file)\n\t\treturn -ENOMEM;\n\terr = 0;\n\tspin_lock(&mddev->lock);\n\tif (!mddev->bitmap_info.file)\n\t\tfile->pathname[0] = '\\0';\n\telse if ((ptr = file_path(mddev->bitmap_info.file,\n\t\t\t       file->pathname, sizeof(file->pathname))),\n\t\t IS_ERR(ptr))\n\t\terr = PTR_ERR(ptr);\n\telse\n\t\tmemmove(file->pathname, ptr,\n\t\t\tsizeof(file->pathname)-(ptr-file->pathname));\n\tspin_unlock(&mddev->lock);\n\tif (err == 0 &&\n\t    copy_to_user(arg, file, sizeof(*file)))\n\t\terr = -EFAULT;\n\tkfree(file);\n\treturn err;\n}", "target": 1}
{"code": "static struct adpt_device* adpt_find_device(adpt_hba* pHba, u32 chan, u32 id, u64 lun)\n{\n\tstruct adpt_device* d;\n\tif (chan >= MAX_CHANNEL)\n\t\treturn NULL;\n\td = pHba->channel[chan].device[id];\n\tif(!d || d->tid == 0) {\n\t\treturn NULL;\n\t}\n\tif(d->scsi_lun == lun){\n\t\treturn d;\n\t}\n\tfor(d=d->next_lun ; d ; d = d->next_lun){\n\t\tif(d->scsi_lun == lun){\n\t\t\treturn d;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "cp949_mbc_to_code(const UChar* p, const UChar* end, OnigEncoding enc)\n{\n  return onigenc_mbn_mbc_to_code(enc, p, end);\n}", "target": 0}
{"code": "static int srv_init(uint16_t lport)\n{\n\tstruct sa laddr;\n\tstruct tcp_sock *tsock;\n\tint err;\n\tinfo(\"srv_init: lport=%d\\n\", (int)lport);\n\terr = sa_set_str(&laddr, \"0.0.0.0\", lport);\n\tif (err)\n\t\treturn err;\n\terr = http_listen(&verifyd.sock, &laddr, http_req_handler, NULL);\n\tif (err) {\n\t\tre_fprintf(stderr, \"http_listen: failed: %m\\n\", err);\n\t\treturn err;\n\t}\n\ttsock = http_sock_tcp(verifyd.sock);\n\tif (tsock) {\n\t\ttcp_sock_local_get(tsock, &laddr);\n\t}\n\tre_fprintf(stderr, \"verifyd: listening on %J\\n\", &laddr);\n\treturn 0;\n}", "target": 0}
{"code": "cdf_read_short_sector(const cdf_stream_t *sst, void *buf, size_t offs,\n    size_t len, const cdf_header_t *h, cdf_secid_t id)\n{\n\tassert((size_t)CDF_SHORT_SEC_SIZE(h) == len);\n\t(void)memcpy(((char *)buf) + offs,\n\t    ((const char *)sst->sst_tab) + CDF_SHORT_SEC_POS(h, id), len);\n\treturn len;\n}", "target": 1}
{"code": "static int compat_setdrvprm(int drive,\n\t\t\t    struct compat_floppy_drive_params __user *arg)\n{\n\tstruct compat_floppy_drive_params v;\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (copy_from_user(&v, arg, sizeof(struct compat_floppy_drive_params)))\n\t\treturn -EFAULT;\n\tmutex_lock(&floppy_mutex);\n\tUDP->cmos = v.cmos;\n\tUDP->max_dtr = v.max_dtr;\n\tUDP->hlt = v.hlt;\n\tUDP->hut = v.hut;\n\tUDP->srt = v.srt;\n\tUDP->spinup = v.spinup;\n\tUDP->spindown = v.spindown;\n\tUDP->spindown_offset = v.spindown_offset;\n\tUDP->select_delay = v.select_delay;\n\tUDP->rps = v.rps;\n\tUDP->tracks = v.tracks;\n\tUDP->timeout = v.timeout;\n\tUDP->interleave_sect = v.interleave_sect;\n\tUDP->max_errors = v.max_errors;\n\tUDP->flags = v.flags;\n\tUDP->read_track = v.read_track;\n\tmemcpy(UDP->autodetect, v.autodetect, sizeof(v.autodetect));\n\tUDP->checkfreq = v.checkfreq;\n\tUDP->native_format = v.native_format;\n\tmutex_unlock(&floppy_mutex);\n\treturn 0;\n}", "target": 0}
{"code": "CephXAuthorizer *CephXTicketHandler::build_authorizer(uint64_t global_id) const\n{\n  CephXAuthorizer *a = new CephXAuthorizer(cct);\n  a->session_key = session_key;\n  a->nonce = ((uint64_t)rand() << 32) + rand();\n  __u8 authorizer_v = 1;\n  ::encode(authorizer_v, a->bl);\n  ::encode(global_id, a->bl);\n  ::encode(service_id, a->bl);\n  ::encode(ticket, a->bl);\n  a->base_bl = a->bl;\n  CephXAuthorize msg;\n  msg.nonce = a->nonce;\n  std::string error;\n  if (encode_encrypt(cct, msg, session_key, a->bl, error)) {\n    ldout(cct, 0) << \"failed to encrypt authorizer: \" << error << dendl;\n    delete a;\n    return 0;\n  }\n  return a;\n}", "target": 0}
{"code": "ev_archive_read_next_header (EvArchive *archive,\n\t\t\t     GError   **error)\n{\n\tg_return_val_if_fail (EV_IS_ARCHIVE (archive), FALSE);\n\tg_return_val_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE, FALSE);\n\tswitch (archive->type) {\n\tcase EV_ARCHIVE_TYPE_NONE:\n\t\tg_assert_not_reached ();\n\tcase EV_ARCHIVE_TYPE_RAR:\n\tcase EV_ARCHIVE_TYPE_ZIP:\n\tcase EV_ARCHIVE_TYPE_7Z:\n\tcase EV_ARCHIVE_TYPE_TAR:\n\t\treturn libarchive_read_next_header (archive, error);\n\t}\n\treturn FALSE;\n}", "target": 0}
{"code": "      TF_EXCLUSIVE_LOCKS_REQUIRED(mu_) {\n    if (tuple[index].has_value()) {\n      return Status(errors::InvalidArgument(\n          \"The tensor for index '\", index, \"' for key '\", key.scalar<int64>()(),\n          \"' was already initialized '\", dtypes_.size(), \"'.\"));\n    }\n    return Status::OK();\n  }", "target": 1}
{"code": "CHUNK_REMAINING_CAPACITY(const chunk_t *chunk)\n{\n  return (chunk->mem + chunk->memlen) - (chunk->data + chunk->datalen);\n}", "target": 0}
{"code": "static int ipv4ll_recv_arp_packet(GDHCPClient *dhcp_client)\n{\n\tint bytes;\n\tstruct ether_arp arp;\n\tuint32_t ip_requested;\n\tint source_conflict;\n\tint target_conflict;\n\tguint timeout_ms;\n\tmemset(&arp, 0, sizeof(arp));\n\tbytes = read(dhcp_client->listener_sockfd, &arp, sizeof(arp));\n\tif (bytes < 0)\n\t\treturn bytes;\n\tif (arp.arp_op != htons(ARPOP_REPLY) &&\n\t\t\tarp.arp_op != htons(ARPOP_REQUEST))\n\t\treturn -EINVAL;\n\tif (memcmp(arp.arp_sha, dhcp_client->mac_address, ETH_ALEN) == 0)\n\t\treturn 0;\n\tip_requested = htonl(dhcp_client->requested_ip);\n\tsource_conflict = !memcmp(arp.arp_spa, &ip_requested,\n\t\t\t\t\t\tsizeof(ip_requested));\n\ttarget_conflict = !memcmp(arp.arp_tpa, &ip_requested,\n\t\t\t\tsizeof(ip_requested));\n\tif (!source_conflict && !target_conflict)\n\t\treturn 0;\n\tdhcp_client->conflicts++;\n\tdebug(dhcp_client, \"IPV4LL conflict detected\");\n\tif (dhcp_client->state == IPV4LL_MONITOR) {\n\t\tif (!source_conflict)\n\t\t\treturn 0;\n\t\tdhcp_client->state = IPV4LL_DEFEND;\n\t\tdebug(dhcp_client, \"DEFEND mode conflicts : %d\",\n\t\t\tdhcp_client->conflicts);\n\t\tsend_announce_packet(dhcp_client);\n\t\treturn 0;\n\t}\n\tif (dhcp_client->state == IPV4LL_DEFEND) {\n\t\tif (!source_conflict)\n\t\t\treturn 0;\n\t\telse if (dhcp_client->ipv4ll_lost_cb)\n\t\t\tdhcp_client->ipv4ll_lost_cb(dhcp_client,\n\t\t\t\t\t\tdhcp_client->ipv4ll_lost_data);\n\t}\n\tipv4ll_stop(dhcp_client);\n\tif (dhcp_client->conflicts < MAX_CONFLICTS)\n\t\ttimeout_ms = __connman_util_random_delay_ms(PROBE_WAIT);\n\telse\n\t\ttimeout_ms = RATE_LIMIT_INTERVAL * 1000;\n\tdhcp_client->retry_times++;\n\tdhcp_client->timeout =\n\t\tg_timeout_add_full(G_PRIORITY_HIGH,\n\t\t\t\ttimeout_ms,\n\t\t\t\tsend_probe_packet,\n\t\t\t\tdhcp_client,\n\t\t\t\tNULL);\n\treturn 0;\n}", "target": 0}
{"code": "[[noreturn]] void TProtocolException::throwTruncatedData() {\n  throw TProtocolException(\n      TProtocolException::INVALID_DATA,\n      \"Not enough bytes to read the entire message, the data appears to be \"\n      \"truncated\");\n}", "target": 0}
{"code": "rrd_info_t *rrd_graph_v(\n    int argc,\n    char **argv)\n{\n    image_desc_t im;\n    rrd_info_t *grinfo;\n    rrd_graph_init(&im);\n    rrd_graph_options(argc, argv, &im);\n    if (rrd_test_error()) {\n        rrd_info_free(im.grinfo);\n        im_free(&im);\n        return NULL;\n    }\n    if (optind >= argc) {\n        rrd_info_free(im.grinfo);\n        im_free(&im);\n        rrd_set_error(\"missing filename\");\n        return NULL;\n    }\n    if (strlen(argv[optind]) >= MAXPATH) {\n        rrd_set_error(\"filename (including path) too long\");\n        rrd_info_free(im.grinfo);\n        im_free(&im);\n        return NULL;\n    }\n    strncpy(im.graphfile, argv[optind], MAXPATH - 1);\n    im.graphfile[MAXPATH - 1] = '\\0';\n    if (strcmp(im.graphfile, \"-\") == 0) {\n        im.graphfile[0] = '\\0';\n    }\n    rrd_graph_script(argc, argv, &im, 1);\n    if (rrd_test_error()) {\n        rrd_info_free(im.grinfo);\n        im_free(&im);\n        return NULL;\n    }\n    if (graph_paint(&im) == -1) {\n      rrd_info_free(im.grinfo);\n      im_free(&im);\n      return NULL;\n    }\n    if (im.imginfo && *im.imginfo) {\n        rrd_infoval_t info;\n        char     *path;\n        char     *filename;\n        if (bad_format_imginfo(im.imginfo)) {\n            rrd_info_free(im.grinfo);\n            im_free(&im);\n            rrd_set_error(\"bad format for imginfo\");\n            return NULL;\n        }\n        path = strdup(im.graphfile);\n        filename = basename(path);\n        info.u_str =\n            sprintf_alloc(im.imginfo,\n                          filename,\n                          (long) (im.zoom *\n                                  im.ximg), (long) (im.zoom * im.yimg));\n        grinfo_push(&im, sprintf_alloc(\"image_info\"), RD_I_STR, info);\n        free(info.u_str);\n        free(path);\n    }\n    if (im.rendered_image) {\n        rrd_infoval_t img;\n        img.u_blo.size = im.rendered_image_size;\n        img.u_blo.ptr = im.rendered_image;\n        grinfo_push(&im, sprintf_alloc(\"image\"), RD_I_BLO, img);\n    }\n    grinfo = im.grinfo;\n    im_free(&im);\n    return grinfo;\n}", "target": 1}
{"code": "vips_tracked_malloc( size_t size )\n{\n        void *buf;\n\tvips_tracked_init(); \n\tsize += 16;\n        if( !(buf = g_try_malloc( size )) ) {\n#ifdef DEBUG\n\t\tg_assert_not_reached();\n#endif \n\t\tvips_error( \"vips_tracked\", \n\t\t\t_( \"out of memory --- size == %dMB\" ), \n\t\t\t(int) (size / (1024.0 * 1024.0))  );\n\t\tg_warning( _( \"out of memory --- size == %dMB\" ), \n\t\t\t(int) (size / (1024.0 * 1024.0))  );\n                return( NULL );\n\t}\n\tg_mutex_lock( vips_tracked_mutex );\n\t*((size_t *)buf) = size;\n\tbuf = (void *) ((char *)buf + 16);\n\tvips_tracked_mem += size;\n\tif( vips_tracked_mem > vips_tracked_mem_highwater ) \n\t\tvips_tracked_mem_highwater = vips_tracked_mem;\n\tvips_tracked_allocs += 1;\n#ifdef DEBUG_VERBOSE\n\tprintf( \"vips_tracked_malloc: %p, %zd bytes\\n\", buf, size ); \n#endif \n\tg_mutex_unlock( vips_tracked_mutex );\n\tVIPS_GATE_MALLOC( size ); \n        return( buf );\n}", "target": 1}
{"code": "size_t CxMemFile::Read(void *buffer, size_t size, size_t count)\n{\n\tif (buffer==NULL) return 0;\n\tif (m_pBuffer==NULL) return 0;\n\tif (m_Position >= (int32_t)m_Size){\n\t\tm_bEOF = true;\n\t\treturn 0;\n\t}\n\tint32_t nCount = (int32_t)(count*size);\n\tif (nCount == 0) return 0;\n\tint32_t nRead;\n\tif (m_Position + nCount > (int32_t)m_Size){\n\t\tm_bEOF = true;\n\t\tnRead = (m_Size - m_Position);\n\t} else\n\t\tnRead = nCount;\n\tmemcpy(buffer, m_pBuffer + m_Position, nRead);\n\tm_Position += nRead;\n\treturn (size_t)(nRead/size);\n}", "target": 1}
{"code": "void IndexedDBDatabase::CallUpgradeTransactionStartedForTesting(\n    int64_t old_version) {\n  DCHECK(active_request_);\n  active_request_->UpgradeTransactionStarted(old_version);\n}", "target": 0}
{"code": "void sctp_generate_heartbeat_event(unsigned long data)\n{\n\tint error = 0;\n\tstruct sctp_transport *transport = (struct sctp_transport *) data;\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct net *net = sock_net(asoc->base.sk);\n\tbh_lock_sock(asoc->base.sk);\n\tif (sock_owned_by_user(asoc->base.sk)) {\n\t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n\t\tif (!mod_timer(&transport->hb_timer, jiffies + (HZ/20)))\n\t\t\tsctp_transport_hold(transport);\n\t\tgoto out_unlock;\n\t}\n\tif (transport->dead)\n\t\tgoto out_unlock;\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(SCTP_EVENT_TIMEOUT_HEARTBEAT),\n\t\t\t   asoc->state, asoc->ep, asoc,\n\t\t\t   transport, GFP_ATOMIC);\n\tif (error)\n\t\tasoc->base.sk->sk_err = -error;\nout_unlock:\n\tbh_unlock_sock(asoc->base.sk);\n\tsctp_transport_put(transport);\n}", "target": 1}
{"code": "static int changedline (const Proto *p, int oldpc, int newpc) {\n  while (oldpc++ < newpc) {\n    if (p->lineinfo[oldpc] != 0)\n      return (luaG_getfuncline(p, oldpc - 1) != luaG_getfuncline(p, newpc));\n  }\n  return 0;  \n}", "target": 1}
{"code": "    inline EndpointSecurityAttributesMask mask() const\n    {\n        EndpointSecurityAttributesMask rv = ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_VALID;\n        if (is_read_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_READ_PROTECTED;\n        if (is_write_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_WRITE_PROTECTED;\n        if (is_discovery_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_DISCOVERY_PROTECTED;\n        if (is_liveliness_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_LIVELINESS_PROTECTED;\n        if (is_submessage_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_SUBMESSAGE_PROTECTED;\n        if (is_payload_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_PAYLOAD_PROTECTED;\n        if (is_key_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_KEY_PROTECTED;\n        return rv;\n    }", "target": 1}
{"code": "static long btrfs_ioctl_qgroup_assign(struct file *file, void __user *arg)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_ioctl_qgroup_assign_args *sa;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\tint err;\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\tsa = memdup_user(arg, sizeof(*sa));\n\tif (IS_ERR(sa)) {\n\t\tret = PTR_ERR(sa);\n\t\tgoto drop_write;\n\t}\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\tif (sa->assign) {\n\t\tret = btrfs_add_qgroup_relation(trans, sa->src, sa->dst);\n\t} else {\n\t\tret = btrfs_del_qgroup_relation(trans, sa->src, sa->dst);\n\t}\n\tmutex_lock(&fs_info->qgroup_ioctl_lock);\n\terr = btrfs_run_qgroups(trans);\n\tmutex_unlock(&fs_info->qgroup_ioctl_lock);\n\tif (err < 0)\n\t\tbtrfs_handle_fs_error(fs_info, err,\n\t\t\t\t      \"failed to update qgroup status and info\");\n\terr = btrfs_end_transaction(trans);\n\tif (err && !ret)\n\t\tret = err;\nout:\n\tkfree(sa);\ndrop_write:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}", "target": 0}
{"code": "Status CreateTempFileBadString(Env* env, char value, uint64 size,\n                               const string suffix, string* filename) {\n  const string dir = testing::TmpDir();\n  *filename = io::JoinPath(dir, strings::StrCat(\"file_\", suffix));\n  std::unique_ptr<WritableFile> file;\n  TF_RETURN_IF_ERROR(env->NewWritableFile(*filename, &file));\n  TF_RETURN_IF_ERROR(file->Append(std::string(size, value)));\n  TF_RETURN_IF_ERROR(file->Close());\n  return Status::OK();\n}", "target": 0}
{"code": "static void do_popen(FILE *fin, FILE *fout, int afdt_fd) {\n  char buf[BUFFER_SIZE];\n  char cwd[BUFFER_SIZE];\n  if (!fgets(buf, BUFFER_SIZE, fin)) buf[0] = '\\0';\n  bool read_only = (buf[0] == 'r');\n  read_buf(fin, buf);\n  std::string old_cwd = Process::GetCurrentDirectory();\n  read_buf(fin, cwd);\n  if (old_cwd != cwd) {\n    if (chdir(cwd)) {\n      Logger::Warning(\"Light Process failed chdir to %s.\", cwd);\n    }\n  }\n  FILE *f = buf[0] ? ::popen(buf, read_only ? \"r\" : \"w\") : nullptr;\n  if (old_cwd != cwd && chdir(old_cwd.c_str())) {\n  }\n  if (f == nullptr) {\n    Logger::Error(\"Light process failed popen: %d (%s).\", errno,\n                  folly::errnoStr(errno).c_str());\n    fprintf(fout, \"error\\n\");\n    fflush(fout);\n  } else {\n    fprintf(fout, \"success\\n%\" PRId64 \"\\n\", (int64_t)f);\n    fflush(fout);\n    int fd = fileno(f);\n    send_fd(afdt_fd, fd);\n  }\n}", "target": 1}
{"code": "static inline void write_s3row_data(\n\tconst entity_stage3_row *r,\n\tunsigned orig_cp,\n\tenum entity_charset charset,\n\tzval *arr)\n{\n\tchar key[9] = \"\"; \n\tchar entity[LONGEST_ENTITY_LENGTH + 2] = {'&'};\n\tsize_t written_k1;\n\twritten_k1 = write_octet_sequence(key, charset, orig_cp);\n\tif (!r->ambiguous) {\n\t\tsize_t l = r->data.ent.entity_len;\n\t\tmemcpy(&entity[1], r->data.ent.entity, l);\n\t\tentity[l + 1] = ';';\n\t\tadd_assoc_stringl_ex(arr, key, written_k1 + 1, entity, l + 2, 1);\n\t} else {\n\t\tunsigned i,\n\t\t\t     num_entries;\n\t\tconst entity_multicodepoint_row *mcpr = r->data.multicodepoint_table;\n\t\tif (mcpr[0].leading_entry.default_entity != NULL) {\n\t\t\tsize_t l = mcpr[0].leading_entry.default_entity_len;\n\t\t\tmemcpy(&entity[1], mcpr[0].leading_entry.default_entity, l);\n\t\t\tentity[l + 1] = ';';\n\t\t\tadd_assoc_stringl_ex(arr, key, written_k1 + 1, entity, l + 2, 1);\n\t\t}\n\t\tnum_entries = mcpr[0].leading_entry.size;\n\t\tfor (i = 1; i <= num_entries; i++) {\n\t\t\tsize_t   l,\n\t\t\t\t     written_k2;\n\t\t\tunsigned uni_cp,\n\t\t\t\t\t spe_cp;\n\t\t\tuni_cp = mcpr[i].normal_entry.second_cp;\n\t\t\tl = mcpr[i].normal_entry.entity_len;\n\t\t\tif (!CHARSET_UNICODE_COMPAT(charset)) {\n\t\t\t\tif (map_from_unicode(uni_cp, charset, &spe_cp) == FAILURE)\n\t\t\t\t\tcontinue; \n\t\t\t} else {\n\t\t\t\tspe_cp = uni_cp;\n\t\t\t}\n\t\t\twritten_k2 = write_octet_sequence(&key[written_k1], charset, spe_cp);\n\t\t\tmemcpy(&entity[1], mcpr[i].normal_entry.entity, l);\n\t\t\tentity[l + 1] = ';';\n\t\t\tentity[l + 1] = '\\0';\n\t\t\tadd_assoc_stringl_ex(arr, key, written_k1 + written_k2 + 1, entity, l + 1, 1);\n\t\t}\n\t}\n}", "target": 1}
{"code": "inline int NumOutputs(const TfLiteNode* node) { return node->outputs->size; }", "target": 0}
{"code": "int main()\n{\n    gdImagePtr im1, im2;\n    FILE *fp;\n    int size;\n    fp = gdTestFileOpen2(\"webp\", \"bug_double_free.jpg\");\n    gdTestAssert(fp != NULL);\n    im1 = gdImageCreateFromJpeg(fp);\n    gdTestAssert(im1 != NULL);\n    fclose(fp);\n    im2 = gdImageWebpPtr(im1, &size);\n    gdTestAssert(im2 == NULL);\n    gdImageDestroy(im1);\n    return gdNumFailures();\n}", "target": 0}
{"code": "static void adpt_i2o_report_hba_unit(adpt_hba* pHba, struct i2o_device *d)\n{\n\tchar buf[64];\n\tint unit = d->lct_data.tid;\n\tprintk(KERN_INFO \"TID %3.3d \", unit);\n\tif(adpt_i2o_query_scalar(pHba, unit, 0xF100, 3, buf, 16)>=0)\n\t{\n\t\tbuf[16]=0;\n\t\tprintk(\" Vendor: %-12.12s\", buf);\n\t}\n\tif(adpt_i2o_query_scalar(pHba, unit, 0xF100, 4, buf, 16)>=0)\n\t{\n\t\tbuf[16]=0;\n\t\tprintk(\" Device: %-12.12s\", buf);\n\t}\n\tif(adpt_i2o_query_scalar(pHba, unit, 0xF100, 6, buf, 8)>=0)\n\t{\n\t\tbuf[8]=0;\n\t\tprintk(\" Rev: %-12.12s\\n\", buf);\n\t}\n#ifdef DEBUG\n\t printk(KERN_INFO \"\\tClass: %.21s\\n\", adpt_i2o_get_class_name(d->lct_data.class_id));\n\t printk(KERN_INFO \"\\tSubclass: 0x%04X\\n\", d->lct_data.sub_class);\n\t printk(KERN_INFO \"\\tFlags: \");\n\t if(d->lct_data.device_flags&(1<<0))\n\t\t  printk(\"C\");\t     \n\t if(d->lct_data.device_flags&(1<<1))\n\t\t  printk(\"U\");\t     \n\t if(!(d->lct_data.device_flags&(1<<4)))\n\t\t  printk(\"P\");\t     \n\t if(!(d->lct_data.device_flags&(1<<5)))\n\t\t  printk(\"M\");\t     \n\t printk(\"\\n\");\n#endif\n}", "target": 1}
{"code": "static void sycc444_to_rgb(opj_image_t *img)\n{\n\tint *d0, *d1, *d2, *r, *g, *b;\n\tconst int *y, *cb, *cr;\n\tunsigned int maxw, maxh, max, i;\n\tint offset, upb;\n\tupb = (int)img->comps[0].prec;\n\toffset = 1<<(upb - 1); upb = (1<<upb)-1;\n\tmaxw = (unsigned int)img->comps[0].w; maxh = (unsigned int)img->comps[0].h;\n\tmax = maxw * maxh;\n\ty = img->comps[0].data;\n\tcb = img->comps[1].data;\n\tcr = img->comps[2].data;\n\td0 = r = (int*)malloc(sizeof(int) * (size_t)max);\n\td1 = g = (int*)malloc(sizeof(int) * (size_t)max);\n\td2 = b = (int*)malloc(sizeof(int) * (size_t)max);\n\tif(r == NULL || g == NULL || b == NULL) goto fails;\n\tfor(i = 0U; i < max; ++i)\n\t{\n\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t++y; ++cb; ++cr; ++r; ++g; ++b;\n\t}\n\tfree(img->comps[0].data); img->comps[0].data = d0;\n\tfree(img->comps[1].data); img->comps[1].data = d1;\n\tfree(img->comps[2].data); img->comps[2].data = d2;\n\treturn;\nfails:\n\tif(r) free(r);\n\tif(g) free(g);\n\tif(b) free(b);\n}", "target": 1}
{"code": "  static Handle<Value> Reinitialize(const Arguments& args) {\n    HandleScope scope;\n    http_parser_type type =\n        static_cast<http_parser_type>(args[0]->Int32Value());\n    if (type != HTTP_REQUEST && type != HTTP_RESPONSE) {\n      return ThrowException(Exception::Error(String::New(\n          \"Argument must be HTTPParser.REQUEST or HTTPParser.RESPONSE\")));\n    }\n    Parser* parser = ObjectWrap::Unwrap<Parser>(args.This());\n    parser->Init(type);\n    return Undefined();\n  }", "target": 0}
{"code": "utf16le_mbc_to_code(const UChar* p, const UChar* end)\n{\n  OnigCodePoint code;\n  UChar c0 = *p;\n  UChar c1 = *(p+1);\n  if (UTF16_IS_SURROGATE_FIRST(c1)) {\n    if (end - p < 4) return 0;\n    code = ((((c1 - 0xd8) << 2) + ((c0  & 0xc0) >> 6) + 1) << 16)\n         + ((((c0 & 0x3f) << 2) + (p[3] - 0xdc)) << 8)\n         + p[2];\n  }\n  else {\n    code = c1 * 256 + p[0];\n  }\n  return code;\n}", "target": 0}
{"code": "PixarLogSetupDecode(TIFF* tif)\n{\n\tstatic const char module[] = \"PixarLogSetupDecode\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tPixarLogState* sp = DecoderState(tif);\n\ttmsize_t tbuf_size;\n\tassert(sp != NULL);\n\ttif->tif_postdecode = _TIFFNoPostDecode;  \n\tsp->stride = (td->td_planarconfig == PLANARCONFIG_CONTIG ?\n\t    td->td_samplesperpixel : 1);\n\ttbuf_size = multiply_ms(multiply_ms(multiply_ms(sp->stride, td->td_imagewidth),\n\t\t\t\t      td->td_rowsperstrip), sizeof(uint16));\n\ttbuf_size = add_ms(tbuf_size, sizeof(uint16) * sp->stride);\n\tif (tbuf_size == 0)\n\t\treturn (0);   \n\tsp->tbuf = (uint16 *) _TIFFmalloc(tbuf_size);\n\tif (sp->tbuf == NULL)\n\t\treturn (0);\n\tsp->tbuf_size = tbuf_size;\n\tif (sp->user_datafmt == PIXARLOGDATAFMT_UNKNOWN)\n\t\tsp->user_datafmt = PixarLogGuessDataFmt(td);\n\tif (sp->user_datafmt == PIXARLOGDATAFMT_UNKNOWN) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\"PixarLog compression can't handle bits depth/data format combination (depth: %d)\", \n\t\t\ttd->td_bitspersample);\n\t\treturn (0);\n\t}\n\tif (inflateInit(&sp->stream) != Z_OK) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"%s\", sp->stream.msg ? sp->stream.msg : \"(null)\");\n\t\treturn (0);\n\t} else {\n\t\tsp->state |= PLSTATE_INIT;\n\t\treturn (1);\n\t}\n}", "target": 0}
{"code": "static int cg_opendir(const char *path, struct fuse_file_info *fi)\n{\n\tstruct fuse_context *fc = fuse_get_context();\n\tconst char *cgroup;\n\tstruct file_info *dir_info;\n\tchar *controller = NULL;\n\tif (!fc)\n\t\treturn -EIO;\n\tif (strcmp(path, \"/cgroup\") == 0) {\n\t\tcgroup = NULL;\n\t\tcontroller = NULL;\n\t} else {\n\t\tcontroller = pick_controller_from_path(fc, path);\n\t\tif (!controller)\n\t\t\treturn -EIO;\n\t\tcgroup = find_cgroup_in_path(path);\n\t\tif (!cgroup) {\n\t\t\tcgroup = \"/\";\n\t\t}\n\t}\n\tif (cgroup && !fc_may_access(fc, controller, cgroup, NULL, O_RDONLY)) {\n\t\treturn -EACCES;\n\t}\n\tdir_info = malloc(sizeof(*dir_info));\n\tif (!dir_info)\n\t\treturn -ENOMEM;\n\tdir_info->controller = must_copy_string(controller);\n\tdir_info->cgroup = must_copy_string(cgroup);\n\tdir_info->type = LXC_TYPE_CGDIR;\n\tdir_info->buf = NULL;\n\tdir_info->file = NULL;\n\tdir_info->buflen = 0;\n\tfi->fh = (unsigned long)dir_info;\n\treturn 0;\n}", "target": 1}
{"code": "set_num_722(unsigned char *p, uint16_t value)\n{\n\tarchive_be16enc(p, value);\n}", "target": 0}
{"code": "WifiNetwork::WifiNetwork(const ServiceInfo* service)\n    : WirelessNetwork(service) {\n  encryption_ = service->security;\n  passphrase_ = SafeString(service->passphrase);\n  identity_ = SafeString(service->identity);\n  cert_path_ = SafeString(service->cert_path);\n  type_ = TYPE_WIFI;\n}", "target": 0}
{"code": "static int pvc_getname(struct socket *sock, struct sockaddr *sockaddr,\n\t\t       int *sockaddr_len, int peer)\n{\n\tstruct sockaddr_atmpvc *addr;\n\tstruct atm_vcc *vcc = ATM_SD(sock);\n\tif (!vcc->dev || !test_bit(ATM_VF_ADDR, &vcc->flags))\n\t\treturn -ENOTCONN;\n\t*sockaddr_len = sizeof(struct sockaddr_atmpvc);\n\taddr = (struct sockaddr_atmpvc *)sockaddr;\n\tmemset(addr, 0, sizeof(*addr));\n\taddr->sap_family = AF_ATMPVC;\n\taddr->sap_addr.itf = vcc->dev->number;\n\taddr->sap_addr.vpi = vcc->vpi;\n\taddr->sap_addr.vci = vcc->vci;\n\treturn 0;\n}", "target": 0}
{"code": "static void do_bad_area(unsigned long addr, unsigned int esr, struct pt_regs *regs)\n{\n\tstruct task_struct *tsk = current;\n\tstruct mm_struct *mm = tsk->active_mm;\n\tif (user_mode(regs))\n\t\t__do_user_fault(tsk, addr, esr, SIGSEGV, SEGV_MAPERR, regs);\n\telse\n\t\t__do_kernel_fault(mm, addr, esr, regs);\n}", "target": 0}
{"code": "static int expand_template(struct sss_certmap_ctx *ctx,\n                           struct parsed_template *parsed_template,\n                           struct sss_cert_content *cert_content,\n                           bool sanitize,\n                           char **expanded)\n{\n    int ret;\n    char *exp = NULL;\n    char *exp_sanitized = NULL;\n    if (strcmp(\"issuer_dn\", parsed_template->name) == 0) {\n        ret = rdn_list_2_dn_str(ctx, parsed_template->conversion,\n                                cert_content->issuer_rdn_list, &exp);\n    } else if (strcmp(\"subject_dn\", parsed_template->name) == 0) {\n        ret = rdn_list_2_dn_str(ctx, parsed_template->conversion,\n                                cert_content->subject_rdn_list, &exp);\n    } else if (strncmp(\"subject_\", parsed_template->name, 8) == 0) {\n        ret = expand_san(ctx, parsed_template, cert_content->san_list, &exp);\n    } else if (strcmp(\"cert\", parsed_template->name) == 0) {\n        sanitize = false;\n        ret = expand_cert(ctx, parsed_template, cert_content, &exp);\n    } else {\n        CM_DEBUG(ctx, \"Unsupported template name.\");\n        ret = EINVAL;\n        goto done;\n    }\n    if (ret != 0) {\n        CM_DEBUG(ctx, \"Failed to expand [%s] template.\", parsed_template->name);\n        goto done;\n    }\n    if (exp == NULL) {\n        ret = ENOMEM;\n        goto done;\n    }\n    if (sanitize) {\n        ret = sss_filter_sanitize(ctx, exp, &exp_sanitized);\n        if (ret != EOK) {\n            CM_DEBUG(ctx, \"Failed to sanitize expanded template.\");\n            goto done;\n        }\n        talloc_free(exp);\n        exp = exp_sanitized;\n    }\n    ret = 0;\ndone:\n    if (ret == 0) {\n        *expanded = exp;\n    } else {\n        talloc_free(exp);\n    }\n    return ret;\n}", "target": 0}
{"code": "file_check_mem(struct magic_set *ms, unsigned int level)\n{\n\tsize_t len;\n\tif (level >= ms->c.len) {\n\t\tlen = (ms->c.len += 20) * sizeof(*ms->c.li);\n\t\tms->c.li = CAST(struct level_info *, (ms->c.li == NULL) ?\n\t\t    malloc(len) :\n\t\t    realloc(ms->c.li, len));\n\t\tif (ms->c.li == NULL) {\n\t\t\tfile_oomem(ms, len);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tms->c.li[level].got_match = 0;\n#ifdef ENABLE_CONDITIONALS\n\tms->c.li[level].last_match = 0;\n\tms->c.li[level].last_cond = COND_NONE;\n#endif \n\treturn 0;\n}", "target": 1}
{"code": "check_entry_size_and_hooks(struct ipt_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct ipt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ipt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct ipt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\tif (!ip_checkentry(&e->ip))\n\t\treturn -EINVAL;\n\terr = xt_check_entry_offsets(e, e->target_offset, e->next_offset);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 1}
{"code": "monitor_apply_keystate(struct monitor *pmonitor)\n{\n\tstruct ssh *ssh = active_state;\t\n\tstruct kex *kex;\n\tint r;\n\tdebug3(\"%s: packet_set_state\", __func__);\n\tif ((r = ssh_packet_set_state(ssh, child_state)) != 0)\n                fatal(\"%s: packet_set_state: %s\", __func__, ssh_err(r));\n\tsshbuf_free(child_state);\n\tchild_state = NULL;\n\tif ((kex = ssh->kex) != NULL) {\n#ifdef WITH_OPENSSL\n\t\tkex->kex[KEX_DH_GRP1_SHA1] = kexdh_server;\n\t\tkex->kex[KEX_DH_GRP14_SHA1] = kexdh_server;\n\t\tkex->kex[KEX_DH_GRP14_SHA256] = kexdh_server;\n\t\tkex->kex[KEX_DH_GRP16_SHA512] = kexdh_server;\n\t\tkex->kex[KEX_DH_GRP18_SHA512] = kexdh_server;\n\t\tkex->kex[KEX_DH_GEX_SHA1] = kexgex_server;\n\t\tkex->kex[KEX_DH_GEX_SHA256] = kexgex_server;\n\t\tkex->kex[KEX_ECDH_SHA2] = kexecdh_server;\n#endif\n\t\tkex->kex[KEX_C25519_SHA256] = kexc25519_server;\n\t\tkex->load_host_public_key=&get_hostkey_public_by_type;\n\t\tkex->load_host_private_key=&get_hostkey_private_by_type;\n\t\tkex->host_key_index=&get_hostkey_index;\n\t\tkex->sign = sshd_hostkey_sign;\n\t}\n\tif (options.compression) {\n\t\tssh_packet_set_compress_hooks(ssh, pmonitor->m_zlib,\n\t\t    (ssh_packet_comp_alloc_func *)mm_zalloc,\n\t\t    (ssh_packet_comp_free_func *)mm_zfree);\n\t}\n}", "target": 1}
{"code": "static int off_nominal_sync_run(struct ast_test *test, const char *domain, int rr_type,\n\t\tint rr_class, int expected_rcode)\n{\n\tstruct ast_dns_result *result;\n\tint res = 0;\n\tif (ast_dns_resolve(domain, rr_type, rr_class, &result)) {\n\t\tast_test_status_update(test, \"Failed to perform resolution :(\\n\");\n\t\treturn -1;\n\t}\n\tif (!result) {\n\t\tast_test_status_update(test, \"Resolution returned no result\\n\");\n\t\treturn -1;\n\t}\n\tif (ast_dns_result_get_rcode(result) != expected_rcode) {\n\t\tast_test_status_update(test, \"Unexpected rcode from DNS resolution\\n\");\n\t\tres = -1;\n\t}\n\tif (ast_dns_result_get_records(result)) {\n\t\tast_test_status_update(test, \"DNS resolution returned records unexpectedly\\n\");\n\t\tres = -1;\n\t}\n\tast_dns_result_free(result);\n\treturn res;\n}", "target": 1}
{"code": "void ParamTraits<string16>::Log(const param_type& p, std::string* l) {\n  l->append(UTF16ToUTF8(p));\n}", "target": 0}
{"code": "bgp_capability_vty_out (struct vty *vty, struct peer *peer)\n{\n  char *pnt;\n  char *end;\n  struct capability cap;\n  pnt = peer->notify.data;\n  end = pnt + peer->notify.length;\n  while (pnt < end)\n    {\n      memcpy(&cap, pnt, sizeof(struct capability));\n      if (pnt + 2 > end)\n\treturn;\n      if (pnt + (cap.length + 2) > end)\n\treturn;\n      if (cap.code == CAPABILITY_CODE_MP)\n\t{\n\t  vty_out (vty, \"  Capability error for: Multi protocol \");\n\t  switch (ntohs (cap.mpc.afi))\n\t    {\n\t    case AFI_IP:\n\t      vty_out (vty, \"AFI IPv4, \");\n\t      break;\n\t    case AFI_IP6:\n\t      vty_out (vty, \"AFI IPv6, \");\n\t      break;\n\t    default:\n\t      vty_out (vty, \"AFI Unknown %d, \", ntohs (cap.mpc.afi));\n\t      break;\n\t    }\n\t  switch (cap.mpc.safi)\n\t    {\n\t    case SAFI_UNICAST:\n\t      vty_out (vty, \"SAFI Unicast\");\n\t      break;\n\t    case SAFI_MULTICAST:\n\t      vty_out (vty, \"SAFI Multicast\");\n\t      break;\n\t    case SAFI_UNICAST_MULTICAST:\n\t      vty_out (vty, \"SAFI Unicast Multicast\");\n\t      break;\n\t    case BGP_SAFI_VPNV4:\n\t      vty_out (vty, \"SAFI MPLS-VPN\");\n\t      break;\n\t    default:\n\t      vty_out (vty, \"SAFI Unknown %d \", cap.mpc.safi);\n\t      break;\n\t    }\n\t  vty_out (vty, \"%s\", VTY_NEWLINE);\n\t}\n      else if (cap.code >= 128)\n\tvty_out (vty, \"  Capability error: vendor specific capability code %d\",\n\t\t cap.code);\n      else\n\tvty_out (vty, \"  Capability error: unknown capability code %d\", \n\t\t cap.code);\n      pnt += cap.length + 2;\n    }\n}", "target": 1}
{"code": "TEST(SpecializeType, ForEachRejectsMalformedInput) {\n  OpDef op;\n  FullTypeDef* t = op.add_output_arg()->mutable_experimental_full_type();\n  t->set_type_id(TFT_FOR_EACH);\n  t->add_args()->set_type_id(TFT_PRODUCT);\n  NodeDef ndef;\n  AttrSlice attrs(ndef);\n  FullTypeDef ft;\n  EXPECT_FALSE(SpecializeType(attrs, op, ft).ok());\n}", "target": 0}
{"code": "smb_com_flush(smb_request_t *sr)\n{\n\tsmb_ofile_t\t*file;\n\tsmb_llist_t\t*flist;\n\tint\t\trc;\n\tif (smb_flush_required == 0) {\n\t\trc = smbsr_encode_empty_result(sr);\n\t\treturn ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);\n\t}\n\tif (sr->smb_fid != 0xffff) {\n\t\tsmbsr_lookup_file(sr);\n\t\tif (sr->fid_ofile == NULL) {\n\t\t\tsmbsr_error(sr, NT_STATUS_INVALID_HANDLE,\n\t\t\t    ERRDOS, ERRbadfid);\n\t\t\treturn (SDRC_ERROR);\n\t\t}\n\t\tsmb_flush_file(sr, sr->fid_ofile);\n\t} else {\n\t\tflist = &sr->tid_tree->t_ofile_list;\n\t\tsmb_llist_enter(flist, RW_READER);\n\t\tfile = smb_llist_head(flist);\n\t\twhile (file) {\n\t\t\tmutex_enter(&file->f_mutex);\n\t\t\tsmb_flush_file(sr, file);\n\t\t\tmutex_exit(&file->f_mutex);\n\t\t\tfile = smb_llist_next(flist, file);\n\t\t}\n\t\tsmb_llist_exit(flist);\n\t}\n\trc = smbsr_encode_empty_result(sr);\n\treturn ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);\n}", "target": 1}
{"code": "int IniParser::write()\n{\n    int bugs = 0;\n    if (!inifile.isDirty())\n    {\n        y2debug (\"File %s did not change. Not saving.\", multiple_files ? files[0].c_str () : file.c_str ());\n\treturn 0;\n    }\n    if (read_only)\n    {\n        y2debug (\"Attempt to write file %s that was mounted read-only. Not saving.\", multiple_files ? files[0].c_str () : file.c_str ());\n\treturn 0;\n    }\n    UpdateIfModif ();\n    if (multiple_files)\n    {\n\tIniIterator\n\t    ci = inifile.getContainerBegin (),\n\t    ce = inifile.getContainerEnd ();\n\tfor (;ci != ce; ++ci)\n\t    {\n\t\tif (ci->t () == SECTION)\n\t\t    {\n\t\t\tIniSection&s = ci->s ();\n\t\t\tint wb = s.getRewriteBy (); \n\t\t\tstring filename = getFileName (s.getName (), wb);\n\t\t\tdeleted_sections.erase (filename);\n\t\t\tif (!s.isDirty ()) {\n\t\t\t    y2debug (\"Skipping file %s that was not changed.\", filename.c_str());\n\t\t\t    continue;\n\t\t\t}\n\t\t\ts.initReadBy ();\n\t\t\tPathname pn (filename);\n\t\t\tPathInfo::assert_dir (pn.dirname ());\n\t\t\tofstream of(filename.c_str());\n\t\t\tif (!of.good())\n\t\t\t{\n\t\t\t    bugs++;\n\t\t\t    y2error (\"Can not open file %s for write\", filename.c_str());\n\t\t\t    continue;\n\t\t\t}\n\t\t\twrite_helper (s, of, 0);\n\t\t\ts.clean();\n\t\t\tof.close ();\n\t\t    }\n\t\telse\n\t\t    {\n\t\t\ty2error (\"Value %s encountered at multifile top level\",\n\t\t\t\t ci->e ().getName ());\n\t\t    }\n\t    }\n\tfor (set<string>::iterator i = deleted_sections.begin (); i!=deleted_sections.end();i++)\n\t    if (multi_files.find (*i) != multi_files.end ()) {\n\t\ty2debug (\"Removing file %s\\n\", (*i).c_str());\n\t\tunlink ((*i).c_str());\n\t    }\n    }\n    else\n    {\n\tPathname pn (file);\n\tPathInfo::assert_dir (pn.dirname ());\n\tofstream of(file.c_str());\n\tif (!of.good())\n\t{\n\t    y2error (\"Can not open file %s for write\", file.c_str());\n\t    return -1;\n\t}\n\twrite_helper (inifile, of, 0);\n\tof.close();\n\ttimestamp = getTimeStamp ();\n    }\n    inifile.clean ();\n    return bugs ? -1 : 0;\n}", "target": 1}
{"code": "static inline pmd_t pmd_read_atomic(pmd_t *pmdp)\n{\n\treturn *pmdp;\n}", "target": 0}
{"code": "static int load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t   u16 selector, int seg)\n{\n\tu8 cpl = ctxt->ops->cpl(ctxt);\n\tif (seg == VCPU_SREG_SS && selector == 3 &&\n\t    ctxt->mode == X86EMUL_MODE_PROT64)\n\t\treturn emulate_exception(ctxt, GP_VECTOR, 0, true);\n\treturn __load_segment_descriptor(ctxt, selector, seg, cpl,\n\t\t\t\t\t X86_TRANSFER_NONE, NULL);\n}", "target": 0}
{"code": "void main_init() { \n#ifdef USE_SYSTEMD\n    int i;\n    systemd_fds=sd_listen_fds(1);\n    if(systemd_fds<0)\n        fatal(\"systemd initialization failed\");\n    listen_fds_start=SD_LISTEN_FDS_START;\n    for(i=0; i<systemd_fds; ++i)\n        set_nonblock(listen_fds_start+i, 1);\n#else\n    systemd_fds=0; \n    listen_fds_start=3; \n#endif\n    if(ssl_init()) \n        fatal(\"TLS initialization failed\");\n    if(sthreads_init()) \n        fatal(\"Threads initialization failed\");\n    options_defaults();\n    options_apply();\n#ifndef USE_FORK\n    get_limits(); \n#endif\n    fds=s_poll_alloc();\n    if(pipe_init(signal_pipe, \"signal_pipe\"))\n        fatal(\"Signal pipe initialization failed: \"\n            \"check your personal firewall\");\n    if(pipe_init(terminate_pipe, \"terminate_pipe\"))\n        fatal(\"Terminate pipe initialization failed: \"\n            \"check your personal firewall\");\n    stunnel_info(LOG_NOTICE);\n    if(systemd_fds>0)\n        s_log(LOG_INFO, \"Systemd socket activation: %d descriptors received\",\n            systemd_fds);\n}", "target": 1}
{"code": "static int timer_start(Unit *u) {\n        Timer *t = TIMER(u);\n        TimerValue *v;\n        assert(t);\n        assert(t->state == TIMER_DEAD || t->state == TIMER_FAILED);\n        if (UNIT_TRIGGER(u)->load_state != UNIT_LOADED)\n                return -ENOENT;\n        t->last_trigger = DUAL_TIMESTAMP_NULL;\n        LIST_FOREACH(value, v, t->values)\n                if (v->base == TIMER_ACTIVE)\n                        v->disabled = false;\n        if (t->stamp_path) {\n                struct stat st;\n                if (stat(t->stamp_path, &st) >= 0)\n                        t->last_trigger.realtime = timespec_load(&st.st_atim);\n                else if (errno == ENOENT)\n                        touch_file(t->stamp_path, true, USEC_INFINITY, UID_INVALID, GID_INVALID, 0);\n        }\n        t->result = TIMER_SUCCESS;\n        timer_enter_waiting(t, true);\n        return 1;\n}", "target": 1}
{"code": "check_mime_type(const gchar* uri,GError** error)\n{\n    GError * err = NULL;\n    const gchar* mimeFromFile;\n    mimeFromFile = ev_file_get_mime_type(uri, FALSE, &err);\n    if (mimeFromFile)\n    {\n        const gchar* mimetypes[] = {\"application/epub+zip\", \"application/x-booki+zip\", NULL};\n        guint i;\n        for (i = 0; i < g_strv_length (mimetypes); i++) {\n           if (strcmp(mimeFromFile, mimetypes[i]) == 0)\n                return TRUE;\n\t}\n        if (strcmp (mimeFromFile, \"application/zip\") == 0)\n        {\n            mimeFromFile = ev_file_get_mime_type (uri, TRUE, &err);\n            if (mimeFromFile)\n            {\n                for (i = 0; i < g_strv_length (mimetypes); i++) {\n                    if (g_strcmp0(mimeFromFile, mimetypes[i]) == 0)\n                        return TRUE;\n                }\n                g_set_error_literal (error,\n                                     EV_DOCUMENT_ERROR,\n                                     EV_DOCUMENT_ERROR_INVALID,\n                                     _(\"Not an ePub document\"));\n                return FALSE;\n            }\n        }\n    }\n    if (err)\n        g_propagate_error (error, err);\n    else\n        g_set_error_literal (error,\n                             EV_DOCUMENT_ERROR,\n                             EV_DOCUMENT_ERROR_INVALID,\n                             _(\"Unknown MIME Type\"));\n    return FALSE;\n}", "target": 1}
{"code": "\t\tauto Phase3() -> Local<Value> final {\n\t\t\treturn Boolean::New(Isolate::GetCurrent(), result);\n\t\t}", "target": 1}
{"code": "   int64 usage() const { return usage_; }", "target": 0}
{"code": "bool OSD::ms_verify_authorizer(Connection *con, int peer_type,\n\t\t\t       int protocol, bufferlist& authorizer_data, bufferlist& authorizer_reply,\n\t\t\t       bool& isvalid, CryptoKey& session_key)\n{\n  AuthAuthorizeHandler *authorize_handler = 0;\n  switch (peer_type) {\n  case CEPH_ENTITY_TYPE_MDS:\n  case CEPH_ENTITY_TYPE_OSD:\n  case CEPH_ENTITY_TYPE_MGR:\n    authorize_handler = authorize_handler_cluster_registry->get_handler(protocol);\n    break;\n  default:\n    authorize_handler = authorize_handler_service_registry->get_handler(protocol);\n  }\n  if (!authorize_handler) {\n    dout(0) << \"No AuthAuthorizeHandler found for protocol \" << protocol << dendl;\n    isvalid = false;\n    return true;\n  }\n  AuthCapsInfo caps_info;\n  EntityName name;\n  uint64_t global_id;\n  uint64_t auid = CEPH_AUTH_UID_DEFAULT;\n  RotatingKeyRing *keys = monc->rotating_secrets.get();\n  if (keys) {\n    isvalid = authorize_handler->verify_authorizer(\n      cct, keys,\n      authorizer_data, authorizer_reply, name, global_id, caps_info, session_key,\n      &auid);\n  } else {\n    dout(10) << __func__ << \" no rotating_keys (yet), denied\" << dendl;\n    isvalid = false;\n  }\n  if (isvalid) {\n    Session *s = static_cast<Session *>(con->get_priv());\n    if (!s) {\n      s = new Session(cct);\n      con->set_priv(s->get());\n      s->con = con;\n      dout(10) << \" new session \" << s << \" con=\" << s->con << \" addr=\" << s->con->get_peer_addr() << dendl;\n    }\n    s->entity_name = name;\n    if (caps_info.allow_all)\n      s->caps.set_allow_all();\n    s->auid = auid;\n    if (caps_info.caps.length() > 0) {\n      bufferlist::iterator p = caps_info.caps.begin();\n      string str;\n      try {\n\t::decode(str, p);\n      }\n      catch (buffer::error& e) {\n      }\n      bool success = s->caps.parse(str);\n      if (success)\n\tdout(10) << \" session \" << s << \" \" << s->entity_name << \" has caps \" << s->caps << \" '\" << str << \"'\" << dendl;\n      else\n\tdout(10) << \" session \" << s << \" \" << s->entity_name << \" failed to parse caps '\" << str << \"'\" << dendl;\n    }\n    s->put();\n  }\n  return true;\n}", "target": 1}
{"code": "static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next,\n\t\t\t     struct task_struct *tsk)\n{\n\tunsigned cpu = smp_processor_id();\n\tif (likely(prev != next)) {\n#ifdef CONFIG_SMP\n\t\tthis_cpu_write(cpu_tlbstate.state, TLBSTATE_OK);\n\t\tthis_cpu_write(cpu_tlbstate.active_mm, next);\n#endif\n\t\tcpumask_set_cpu(cpu, mm_cpumask(next));\n\t\tload_cr3(next->pgd);\n\t\ttrace_tlb_flush(TLB_FLUSH_ON_TASK_SWITCH, TLB_FLUSH_ALL);\n\t\tcpumask_clear_cpu(cpu, mm_cpumask(prev));\n\t\tload_mm_cr4(next);\n#ifdef CONFIG_MODIFY_LDT_SYSCALL\n\t\tif (unlikely(prev->context.ldt != next->context.ldt))\n\t\t\tload_mm_ldt(next);\n#endif\n\t}\n#ifdef CONFIG_SMP\n\t  else {\n\t\tthis_cpu_write(cpu_tlbstate.state, TLBSTATE_OK);\n\t\tBUG_ON(this_cpu_read(cpu_tlbstate.active_mm) != next);\n\t\tif (!cpumask_test_cpu(cpu, mm_cpumask(next))) {\n\t\t\tcpumask_set_cpu(cpu, mm_cpumask(next));\n\t\t\tload_cr3(next->pgd);\n\t\t\ttrace_tlb_flush(TLB_FLUSH_ON_TASK_SWITCH, TLB_FLUSH_ALL);\n\t\t\tload_mm_cr4(next);\n\t\t\tload_mm_ldt(next);\n\t\t}\n\t}\n#endif\n}", "target": 1}
{"code": "static int proc_connectinfo(struct usb_dev_state *ps, void __user *arg)\n{\n\tstruct usbdevfs_connectinfo ci = {\n\t\t.devnum = ps->dev->devnum,\n\t\t.slow = ps->dev->speed == USB_SPEED_LOW\n\t};\n\tif (copy_to_user(arg, &ci, sizeof(ci)))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1}
{"code": "void Context::onStart(absl::string_view root_id, absl::string_view vm_configuration) {\n  if (wasm_->onStart_) {\n    auto root_id_addr = wasm_->copyString(root_id);\n    auto config_addr = wasm_->copyString(vm_configuration);\n    wasm_->onStart_(this, id_, root_id_addr, root_id.size(), config_addr, vm_configuration.size());\n  }\n  in_vm_context_created_ = true;\n}", "target": 0}
{"code": "R_API bool r_crbtree_insert(RRBTree *tree, void *data, RRBComparator cmp, void *user) {\n\tr_return_val_if_fail (tree && data && cmp, false);\n\tbool inserted = false;\n\tif (tree->root == NULL) {\n\t\ttree->root = _node_new (data, NULL);\n\t\tif (tree->root == NULL) {\n\t\t\treturn false;\n\t\t}\n\t\tinserted = true;\n\t\tgoto out_exit;\n\t}\n\tRRBNode head; \n\tmemset (&head, 0, sizeof (RRBNode));\n\tRRBNode *g = NULL, *parent = &head; \n\tRRBNode *p = NULL, *q = tree->root; \n\tint dir = 0, last = 0; \n\t_set_link (parent, q, 1);\n\tfor (;;) {\n\t\tif (!q) {\n\t\t\tq = _node_new (data, p);\n\t\t\tif (!q) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tp->link[dir] = q;\n\t\t\tinserted = true;\n\t\t} else if (IS_RED (q->link[0]) && IS_RED (q->link[1])) {\n\t\t\tq->red = 1;\n\t\t\tq->link[0]->red = 0;\n\t\t\tq->link[1]->red = 0;\n\t\t}\n\t\tif (IS_RED (q) && IS_RED (p)) {\n#if 0\n\t\t\tif (!parent) {\n\t\t\t\treturn false;\n\t\t\t}\n#endif\n\t\t\tint dir2 = parent->link[1] == g;\n\t\t\tif (q == p->link[last]) {\n\t\t\t\t_set_link (parent, _rot_once (g, !last), dir2);\n\t\t\t} else {\n\t\t\t\t_set_link (parent, _rot_twice (g, !last), dir2);\n\t\t\t}\n\t\t}\n\t\tif (inserted) {\n\t\t\tbreak;\n\t\t}\n\t\tlast = dir;\n\t\tdir = cmp (data, q->data, user) >= 0;\n\t\tif (g) {\n\t\t\tparent = g;\n\t\t}\n\t\tg = p;\n\t\tp = q;\n\t\tq = q->link[dir];\n\t}\n\ttree->root = head.link[1];\nout_exit:\n\ttree->root->red = 0;\n\ttree->root->parent = NULL;\n\tif (inserted) {\n\t\ttree->size++;\n\t}\n\treturn inserted;\n}", "target": 1}
{"code": "xmlParseMarkupDecl(xmlParserCtxtPtr ctxt) {\n    GROW;\n    if (CUR == '<') {\n        if (NXT(1) == '!') {\n\t    switch (NXT(2)) {\n\t        case 'E':\n\t\t    if (NXT(3) == 'L')\n\t\t\txmlParseElementDecl(ctxt);\n\t\t    else if (NXT(3) == 'N')\n\t\t\txmlParseEntityDecl(ctxt);\n\t\t    break;\n\t        case 'A':\n\t\t    xmlParseAttributeListDecl(ctxt);\n\t\t    break;\n\t        case 'N':\n\t\t    xmlParseNotationDecl(ctxt);\n\t\t    break;\n\t        case '-':\n\t\t    xmlParseComment(ctxt);\n\t\t    break;\n\t\tdefault:\n\t\t    break;\n\t    }\n\t} else if (NXT(1) == '?') {\n\t    xmlParsePI(ctxt);\n\t}\n    }\n    if ((ctxt->external == 0) && (ctxt->inputNr == 1))\n\txmlParsePEReference(ctxt);\n    if ((ctxt->external == 0) && (ctxt->inputNr > 1)) {\n        if ((RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {\n\t    xmlParseConditionalSections(ctxt);\n\t}\n    }\n    ctxt->instate = XML_PARSER_DTD;\n}", "target": 0}
{"code": "handle_ppp(netdissect_options *ndo,\n           u_int proto, const u_char *p, int length)\n{\n\tif ((proto & 0xff00) == 0x7e00) { \n\t\tppp_hdlc(ndo, p - 1, length);\n\t\treturn;\n\t}\n\tswitch (proto) {\n\tcase PPP_LCP: \n\tcase PPP_IPCP:\n\tcase PPP_OSICP:\n\tcase PPP_MPLSCP:\n\tcase PPP_IPV6CP:\n\tcase PPP_CCP:\n\tcase PPP_BACP:\n\t\thandle_ctrl_proto(ndo, proto, p, length);\n\t\tbreak;\n\tcase PPP_ML:\n\t\thandle_mlppp(ndo, p, length);\n\t\tbreak;\n\tcase PPP_CHAP:\n\t\thandle_chap(ndo, p, length);\n\t\tbreak;\n\tcase PPP_PAP:\n\t\thandle_pap(ndo, p, length);\n\t\tbreak;\n\tcase PPP_BAP:\t\t\n\t\thandle_bap(ndo, p, length);\n\t\tbreak;\n\tcase ETHERTYPE_IP:\t\n        case PPP_VJNC:\n\tcase PPP_IP:\n\t\tip_print(ndo, p, length);\n\t\tbreak;\n\tcase ETHERTYPE_IPV6:\t\n\tcase PPP_IPV6:\n\t\tip6_print(ndo, p, length);\n\t\tbreak;\n\tcase ETHERTYPE_IPX:\t\n\tcase PPP_IPX:\n\t\tipx_print(ndo, p, length);\n\t\tbreak;\n\tcase PPP_OSI:\n\t\tisoclns_print(ndo, p, length, length);\n\t\tbreak;\n\tcase PPP_MPLS_UCAST:\n\tcase PPP_MPLS_MCAST:\n\t\tmpls_print(ndo, p, length);\n\t\tbreak;\n\tcase PPP_COMP:\n\t\tND_PRINT((ndo, \"compressed PPP data\"));\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \"%s \", tok2str(ppptype2str, \"unknown PPP protocol (0x%04x)\", proto)));\n\t\tprint_unknown_data(ndo, p, \"\\n\\t\", length);\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "ldap_pvt_tls_check_hostname( LDAP *ld, void *s, const char *name_in )\n{\n\ttls_session *session = s;\n\tif (ld->ld_options.ldo_tls_require_cert != LDAP_OPT_X_TLS_NEVER &&\n\t    ld->ld_options.ldo_tls_require_cert != LDAP_OPT_X_TLS_ALLOW) {\n\t\tld->ld_errno = tls_imp->ti_session_chkhost( ld, session, name_in );\n\t\tif (ld->ld_errno != LDAP_SUCCESS) {\n\t\t\treturn ld->ld_errno;\n\t\t}\n\t}\n\treturn LDAP_SUCCESS;\n}", "target": 0}
{"code": "static Jsi_RC ObjListifyCallback(Jsi_Tree *tree, Jsi_TreeEntry *hPtr, void *data)\n{\n    Jsi_Interp *interp = tree->opts.interp;\n    Jsi_Obj *obj = (Jsi_Obj*)data;\n    int n;\n    if (!hPtr->f.bits.dontenum) {\n        char *ep = NULL, *cp = (char*)Jsi_TreeKeyGet(hPtr);\n        if (!cp || !isdigit(*cp))\n            return JSI_OK;\n        n = (int)strtol(cp, &ep, 0);\n        if (n<0 || n >= interp->maxArrayList)\n            return JSI_OK;\n        hPtr->f.bits.isarrlist = 1;\n        if (Jsi_ObjArraySizer(interp, obj, n) <= 0) \n            return Jsi_LogError(\"too long\");\n        obj->arr[n] = (Jsi_Value*)Jsi_TreeValueGet(hPtr);\n    }\n    return JSI_OK;\n}", "target": 1}
{"code": "static Jsi_RC SysGetEnvCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    extern char **environ;\n    char *cp;\n    int i;\n    if (interp->isSafe)\n        return Jsi_LogError(\"no getenv in safe mode\");\n    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n    if (v != NULL) {\n        const char *fnam = Jsi_ValueString(interp, v, NULL);\n        if (!fnam) \n            return Jsi_LogError(\"arg1: expected string 'name'\");\n        cp = getenv(fnam);\n        if (cp != NULL) {\n            Jsi_ValueMakeStringDup(interp, ret, cp);\n        }\n        return JSI_OK;\n    }\n    Jsi_Value *vres;\n    Jsi_Obj  *ores = Jsi_ObjNew(interp);\n    Jsi_Value *nnv;\n    char *val, nam[200];\n    vres = Jsi_ValueMakeObject(interp, NULL, ores);\n    for (i=0; ; i++) {\n        int n;\n        cp = environ[i];\n        if (cp == 0 || ((val = Jsi_Strchr(cp, '='))==NULL))\n            break;\n        n = val-cp+1;\n        if (n>=(int)sizeof(nam))\n            n = sizeof(nam)-1;\n        Jsi_Strncpy(nam, cp, n);\n        val = val+1;\n        nnv = Jsi_ValueMakeStringDup(interp, NULL, val);\n        Jsi_ObjInsert(interp, ores, nam, nnv, 0);\n    }\n    Jsi_ValueReplace(interp, ret, vres);\n    return JSI_OK;\n}", "target": 1}
{"code": "static struct nfs4_opendata *nfs4_opendata_alloc(struct path *path,\n\t\tstruct nfs4_state_owner *sp, int flags,\n\t\tconst struct iattr *attrs)\n{\n\tstruct dentry *parent = dget_parent(path->dentry);\n\tstruct inode *dir = parent->d_inode;\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs4_opendata *p;\n\tp = kzalloc(sizeof(*p), GFP_KERNEL);\n\tif (p == NULL)\n\t\tgoto err;\n\tp->o_arg.seqid = nfs_alloc_seqid(&sp->so_seqid);\n\tif (p->o_arg.seqid == NULL)\n\t\tgoto err_free;\n\tp->path.mnt = mntget(path->mnt);\n\tp->path.dentry = dget(path->dentry);\n\tp->dir = parent;\n\tp->owner = sp;\n\tatomic_inc(&sp->so_count);\n\tp->o_arg.fh = NFS_FH(dir);\n\tp->o_arg.open_flags = flags,\n\tp->o_arg.clientid = server->nfs_client->cl_clientid;\n\tp->o_arg.id = sp->so_owner_id.id;\n\tp->o_arg.name = &p->path.dentry->d_name;\n\tp->o_arg.server = server;\n\tp->o_arg.bitmask = server->attr_bitmask;\n\tp->o_arg.claim = NFS4_OPEN_CLAIM_NULL;\n\tif (flags & O_EXCL) {\n\t\tu32 *s = (u32 *) p->o_arg.u.verifier.data;\n\t\ts[0] = jiffies;\n\t\ts[1] = current->pid;\n\t} else if (flags & O_CREAT) {\n\t\tp->o_arg.u.attrs = &p->attrs;\n\t\tmemcpy(&p->attrs, attrs, sizeof(p->attrs));\n\t}\n\tp->c_arg.fh = &p->o_res.fh;\n\tp->c_arg.stateid = &p->o_res.stateid;\n\tp->c_arg.seqid = p->o_arg.seqid;\n\tnfs4_init_opendata_res(p);\n\tkref_init(&p->kref);\n\treturn p;\nerr_free:\n\tkfree(p);\nerr:\n\tdput(parent);\n\treturn NULL;\n}", "target": 1}
{"code": "static void copy_password_acl_validation_control(\n\tstruct ldb_request *req,\n\tstruct ldb_reply *ares)\n{\n\tstruct ldb_control *pav_ctrl = NULL;\n\tstruct dsdb_control_password_acl_validation *pav = NULL;\n\tpav_ctrl = ldb_request_get_control(\n\t\tdiscard_const(req),\n\t\tDSDB_CONTROL_PASSWORD_ACL_VALIDATION_OID);\n\tif (pav_ctrl == NULL) {\n\t\treturn;\n\t}\n\tpav = talloc_get_type_abort(\n\t\tpav_ctrl->data,\n\t\tstruct dsdb_control_password_acl_validation);\n\tif (pav == NULL) {\n\t\treturn;\n\t}\n\tldb_reply_add_control(\n\t\tares,\n\t\tDSDB_CONTROL_PASSWORD_ACL_VALIDATION_OID,\n\t\tfalse,\n\t\tpav);\n}", "target": 0}
{"code": "nfsd4_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tstruct nfs4_acl *acl)\n{\n\t__be32 error;\n\tint host_error;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tstruct posix_acl *pacl = NULL, *dpacl = NULL;\n\tunsigned int flags = 0;\n\terror = fh_verify(rqstp, fhp, 0, NFSD_MAY_SATTR);\n\tif (error)\n\t\treturn error;\n\tdentry = fhp->fh_dentry;\n\tinode = d_inode(dentry);\n\tif (!inode->i_op->set_acl || !IS_POSIXACL(inode))\n\t\treturn nfserr_attrnotsupp;\n\tif (S_ISDIR(inode->i_mode))\n\t\tflags = NFS4_ACL_DIR;\n\thost_error = nfs4_acl_nfsv4_to_posix(acl, &pacl, &dpacl, flags);\n\tif (host_error == -EINVAL)\n\t\treturn nfserr_attrnotsupp;\n\tif (host_error < 0)\n\t\tgoto out_nfserr;\n\thost_error = inode->i_op->set_acl(inode, pacl, ACL_TYPE_ACCESS);\n\tif (host_error < 0)\n\t\tgoto out_release;\n\tif (S_ISDIR(inode->i_mode)) {\n\t\thost_error = inode->i_op->set_acl(inode, dpacl,\n\t\t\t\t\t\t  ACL_TYPE_DEFAULT);\n\t}\nout_release:\n\tposix_acl_release(pacl);\n\tposix_acl_release(dpacl);\nout_nfserr:\n\tif (host_error == -EOPNOTSUPP)\n\t\treturn nfserr_attrnotsupp;\n\telse\n\t\treturn nfserrno(host_error);\n}", "target": 1}
{"code": "bool FormContainsNonDefaultPasswordValue(const PasswordForm& password_form) {\n  return (!password_form.password_value.empty() &&\n          !password_form.password_value_is_default) ||\n      (!password_form.new_password_value.empty() &&\n       !password_form.new_password_value_is_default);\n}", "target": 0}
{"code": "static int do_i2c_mw(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t     char *const argv[])\n{\n\tuint\tchip;\n\tulong\taddr;\n\tint\talen;\n\tuchar\tbyte;\n\tint\tcount;\n\tint ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n#endif\n\tif ((argc < 4) || (argc > 5))\n\t\treturn CMD_RET_USAGE;\n\tchip = hextoul(argv[1], NULL);\n\taddr = hextoul(argv[2], NULL);\n\talen = get_alen(argv[2], DEFAULT_ADDR_LEN);\n\tif (alen > 3)\n\t\treturn CMD_RET_USAGE;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret && alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n#endif\n\tbyte = hextoul(argv[3], NULL);\n\tif (argc == 5)\n\t\tcount = hextoul(argv[4], NULL);\n\telse\n\t\tcount = 1;\n\twhile (count-- > 0) {\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\tret = dm_i2c_write(dev, addr++, &byte, 1);\n#else\n\t\tret = i2c_write(chip, addr++, alen, &byte, 1);\n#endif\n\t\tif (ret)\n\t\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n#if !defined(CONFIG_SYS_I2C_FRAM)\n\t\tudelay(11000);\n#endif\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static inline ut32 r_read_at_le32(const void *src, size_t offset) {\n\tif (!src) {\n\t\treturn UT32_MAX;\n\t}\n\tconst ut8 *s = (const ut8*)src + offset;\n\treturn r_read_le32 (s);\n}", "target": 0}
{"code": "GF_Err xtra_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_XtraBox *ptr = (GF_XtraBox *)s;\n\twhile (ptr->size) {\n\t\tGF_XtraTag *tag;\n\t\tu32 prop_type = 0;\n\t\tchar *data=NULL, *data2=NULL;\n\t\tISOM_DECREASE_SIZE_NO_ERR(ptr, 8)\n\t\ts32 tag_size = gf_bs_read_u32(bs);\n\t\tu32 name_size = gf_bs_read_u32(bs);\n\t\tif (tag_size < 8) return GF_ISOM_INVALID_FILE;\n\t\ttag_size -= 8;\n\t\tif ((tag_size>ptr->size) || (name_size>ptr->size)) {\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tISOM_DECREASE_SIZE_NO_ERR(ptr, 10)\n\t\tISOM_DECREASE_SIZE_NO_ERR(ptr, name_size)\n\t\tdata = gf_malloc(sizeof(char) * (name_size+1));\n\t\tgf_bs_read_data(bs, data, name_size);\n\t\tdata[name_size] = 0;\n\t\ttag_size-=name_size;\n\t\tu32 flags = gf_bs_read_u32(bs);\n\t\tu32 prop_size = gf_bs_read_u32(bs);\n\t\ttag_size-=8;\n\t\tif (prop_size>4) {\n\t\t\ttag_size-=2;\n\t\t\tprop_type = gf_bs_read_u16(bs);\n\t\t\tprop_size -= 6;\n\t\t\tISOM_DECREASE_SIZE_NO_ERR(ptr, prop_size)\n\t\t\tdata2 = gf_malloc(sizeof(char) * (prop_size+2));\n\t\t\tgf_bs_read_data(bs, data2, prop_size);\n\t\t\tdata2[prop_size] = 0;\n\t\t\tdata2[prop_size+1] = 0;\n\t\t\ttag_size-=prop_size;\n\t\t} else {\n\t\t\tprop_size = 0;\n\t\t}\n\t\tGF_SAFEALLOC(tag, GF_XtraTag)\n\t\ttag->flags = flags;\n\t\ttag->name = data;\n\t\ttag->prop_size = prop_size;\n\t\ttag->prop_value = data2;\n\t\ttag->prop_type = prop_type;\n\t\tgf_list_add(ptr->tags, tag);\n\t\tif (tag_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isom] invalid tag size in Xtra !\\n\"));\n\t\t}\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "snmp_ber_decode_string_len_buffer(unsigned char *buf, uint32_t *buff_len, const char **str, uint32_t *length)\n{\n  uint8_t type, i, length_bytes;\n  buf = snmp_ber_decode_type(buf, buff_len, &type);\n  if(buf == NULL || type != BER_DATA_TYPE_OCTET_STRING) {\n    return NULL;\n  }\n  if((*buf & 0x80) == 0) {\n    *length = (uint32_t)*buf++;\n    (*buff_len)--;\n  } else {\n    length_bytes = (uint8_t)(*buf++ & 0x7F);\n    (*buff_len)--;\n    if(length_bytes > 4) {\n      return NULL;\n    }\n    *length = (uint32_t)*buf++;\n    (*buff_len)--;\n    for(i = 1; i < length_bytes; ++i) {\n      *length <<= 8;\n      *length |= *buf++;\n      (*buff_len)--;\n    }\n  }\n  *str = (const char *)buf;\n  *buff_len -= *length;\n  return buf + *length;\n}", "target": 1}
{"code": "int socketio_setoption(CONCRETE_IO_HANDLE socket_io, const char* optionName, const void* value)\n{\n    int result;\n    if (socket_io == NULL ||\n        optionName == NULL ||\n        value == NULL)\n    {\n        result = MU_FAILURE;\n    }\n    else\n    {\n        SOCKET_IO_INSTANCE* socket_io_instance = (SOCKET_IO_INSTANCE*)socket_io;\n        if (strcmp(optionName, \"tcp_keepalive\") == 0)\n        {\n            result = setsockopt(socket_io_instance->socket, SOL_SOCKET, SO_KEEPALIVE, value, sizeof(int));\n            if (result == -1) result = errno;\n        }\n        else if (strcmp(optionName, \"tcp_keepalive_time\") == 0)\n        {\n#ifdef __APPLE__\n            result = setsockopt(socket_io_instance->socket, IPPROTO_TCP, TCP_KEEPALIVE, value, sizeof(int));\n#else\n            result = setsockopt(socket_io_instance->socket, SOL_TCP, TCP_KEEPIDLE, value, sizeof(int));\n#endif\n            if (result == -1) result = errno;\n        }\n        else if (strcmp(optionName, \"tcp_keepalive_interval\") == 0)\n        {\n            result = setsockopt(socket_io_instance->socket, SOL_TCP, TCP_KEEPINTVL, value, sizeof(int));\n            if (result == -1) result = errno;\n        }\n        else if (strcmp(optionName, OPTION_NET_INT_MAC_ADDRESS) == 0)\n        {\n#ifdef __APPLE__\n            LogError(\"option not supported.\");\n            result = MU_FAILURE;\n#else\n            if (strlen(value) == 0)\n            {\n                LogError(\"option value must be a valid mac address\");\n                result = MU_FAILURE;\n            }\n            else if ((socket_io_instance->target_mac_address = (char*)malloc(sizeof(char) * (strlen(value) + 1))) == NULL)\n            {\n                LogError(\"failed setting net_interface_mac_address option (malloc failed)\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                strcpy(socket_io_instance->target_mac_address, value);\n                strtoup(socket_io_instance->target_mac_address);\n                result = 0;\n            }\n#endif\n        }\n        else if (strcmp(optionName, OPTION_ADDRESS_TYPE) == 0)\n        {\n            result = socketio_setaddresstype_option(socket_io_instance, (const char*)value);\n        }\n        else\n        {\n            result = MU_FAILURE;\n        }\n    }\n    return result;\n}", "target": 1}
{"code": "pf_remove_divert_state(struct pf_state_key *sk)\n{\n\tstruct pf_state_item\t*si;\n\tPF_ASSERT_UNLOCKED();\n\tPF_LOCK();\n\tPF_STATE_ENTER_WRITE();\n\tTAILQ_FOREACH(si, &sk->sk_states, si_entry) {\n\t\tstruct pf_state *sist = si->si_st;\n\t\tif (sk == sist->key[PF_SK_STACK] && sist->rule.ptr &&\n\t\t    (sist->rule.ptr->divert.type == PF_DIVERT_TO ||\n\t\t     sist->rule.ptr->divert.type == PF_DIVERT_REPLY)) {\n\t\t\tif (sist->key[PF_SK_STACK]->proto == IPPROTO_TCP &&\n\t\t\t    sist->key[PF_SK_WIRE] != sist->key[PF_SK_STACK]) {\n\t\t\t\tif (sist->src.state < TCPS_FIN_WAIT_2 ||\n\t\t\t\t    sist->dst.state < TCPS_FIN_WAIT_2) {\n\t\t\t\t\tpf_set_protostate(sist, PF_PEER_BOTH,\n\t\t\t\t\t    TCPS_TIME_WAIT);\n\t\t\t\t\tsist->timeout = PFTM_TCP_CLOSED;\n\t\t\t\t\tsist->expire = getuptime();\n\t\t\t\t}\n\t\t\t\tsist->state_flags |= PFSTATE_INP_UNLINKED;\n\t\t\t} else\n\t\t\t\tpf_remove_state(sist);\n\t\t\tbreak;\n\t\t}\n\t}\n\tPF_STATE_EXIT_WRITE();\n\tPF_UNLOCK();\n}", "target": 1}
{"code": "static int gup_pte_range(pmd_t pmd, unsigned long addr, unsigned long end,\n\t\t\t int write, struct page **pages, int *nr)\n{\n\tstruct dev_pagemap *pgmap = NULL;\n\tint nr_start = *nr, ret = 0;\n\tpte_t *ptep, *ptem;\n\tptem = ptep = pte_offset_map(&pmd, addr);\n\tdo {\n\t\tpte_t pte = gup_get_pte(ptep);\n\t\tstruct page *head, *page;\n\t\tif (pte_protnone(pte))\n\t\t\tgoto pte_unmap;\n\t\tif (!pte_access_permitted(pte, write))\n\t\t\tgoto pte_unmap;\n\t\tif (pte_devmap(pte)) {\n\t\t\tpgmap = get_dev_pagemap(pte_pfn(pte), pgmap);\n\t\t\tif (unlikely(!pgmap)) {\n\t\t\t\tundo_dev_pagemap(nr, nr_start, pages);\n\t\t\t\tgoto pte_unmap;\n\t\t\t}\n\t\t} else if (pte_special(pte))\n\t\t\tgoto pte_unmap;\n\t\tVM_BUG_ON(!pfn_valid(pte_pfn(pte)));\n\t\tpage = pte_page(pte);\n\t\thead = compound_head(page);\n\t\tif (!page_cache_get_speculative(head))\n\t\t\tgoto pte_unmap;\n\t\tif (unlikely(pte_val(pte) != pte_val(*ptep))) {\n\t\t\tput_page(head);\n\t\t\tgoto pte_unmap;\n\t\t}\n\t\tVM_BUG_ON_PAGE(compound_head(page) != head, page);\n\t\tSetPageReferenced(page);\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\t} while (ptep++, addr += PAGE_SIZE, addr != end);\n\tret = 1;\npte_unmap:\n\tif (pgmap)\n\t\tput_dev_pagemap(pgmap);\n\tpte_unmap(ptem);\n\treturn ret;\n}", "target": 1}
{"code": "daemon_linux_lvm2_vg_add_pv (Daemon *daemon,\n                             const gchar *uuid,\n                             const gchar *object_path,\n                             gchar **options,\n                             DBusGMethodInvocation *context)\n{\n  daemon_local_check_auth (daemon,\n                           NULL,\n                           \"org.freedesktop.udisks.linux-lvm2\",\n                           \"LinuxLvm2VGAddPV\",\n                           TRUE,\n                           daemon_linux_lvm2_vg_add_pv_authorized_cb,\n                           context,\n                           3,\n                           g_strdup (uuid),\n                           g_free,\n                           g_strdup (object_path),\n                           g_free,\n                           g_strdupv (options),\n                           g_strfreev);\n  return TRUE;\n}", "target": 0}
{"code": "static int stszin(int size)\n{\n    int cnt;\n    uint32_t ofs;\n    u32in();\n    u32in();\n    mp4config.frame.ents = u32in();\n    mp4config.frame.data = malloc(sizeof(*mp4config.frame.data)\n                                  * (mp4config.frame.ents + 1));\n    if (!mp4config.frame.data)\n        return ERR_FAIL;\n    ofs = 0;\n    mp4config.frame.data[0] = ofs;\n    for (cnt = 0; cnt < mp4config.frame.ents; cnt++)\n    {\n        uint32_t fsize = u32in();\n        ofs += fsize;\n        if (mp4config.frame.maxsize < fsize)\n            mp4config.frame.maxsize = fsize;\n        mp4config.frame.data[cnt + 1] = ofs;\n        if (ofs < mp4config.frame.data[cnt])\n            return ERR_FAIL;\n    }\n    return size;\n}", "target": 1}
{"code": "static int http_open(URLContext *h, const char *uri, int flags,\n                     AVDictionary **options)\n{\n    HTTPContext *s = h->priv_data;\n    int ret;\n    if( s->seekable == 1 )\n        h->is_streamed = 0;\n    else\n        h->is_streamed = 1;\n    s->filesize = -1;\n    s->location = av_strdup(uri);\n    if (!s->location)\n        return AVERROR(ENOMEM);\n    if (options)\n        av_dict_copy(&s->chained_options, *options, 0);\n    if (s->headers) {\n        int len = strlen(s->headers);\n        if (len < 2 || strcmp(\"\\r\\n\", s->headers + len - 2)) {\n            av_log(h, AV_LOG_WARNING,\n                   \"No trailing CRLF found in HTTP header.\\n\");\n            ret = av_reallocp(&s->headers, len + 3);\n            if (ret < 0)\n                return ret;\n            s->headers[len]     = '\\r';\n            s->headers[len + 1] = '\\n';\n            s->headers[len + 2] = '\\0';\n        }\n    }\n    if (s->listen) {\n        return http_listen(h, uri, flags, options);\n    }\n    ret = http_open_cnx(h, options);\n    if (ret < 0)\n        av_dict_free(&s->chained_options);\n    return ret;\n}", "target": 1}
{"code": "static void mdbEvalSetColumn(MyDbEvalContext *p, int iCol, Jsi_DString *dStr) {\n    char nbuf[200];\n    MysqlPrep *prep = p->prep;\n    SqlFieldResults *field = prep->fieldResult+iCol;\n    Jsi_Interp *interp = p->jdb->interp;\n    if (field->isnull)\n        return;\n    switch(field->jsiTypeMap) {\n        case JSI_OPTION_STRING: {\n            int bytes = field->len;\n            const char *zBlob = field->buffer.vstring;\n            if( !zBlob ) {\n                const char *nv = p->jdb->optPtr->nullvalue;\n                Jsi_DSAppend(dStr, nv?nv:\"null\", NULL);\n                return;\n            }\n            Jsi_DSAppendLen(dStr, zBlob, bytes);\n            return;\n        }\n        case JSI_OPTION_BOOL: {\n            snprintf(nbuf, sizeof(nbuf), \"%s\", field->buffer.vchar?\"true\":\"false\");\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        case JSI_OPTION_INT64: {\n            snprintf(nbuf, sizeof(nbuf), \"%lld\", field->buffer.vlonglong);\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        case JSI_OPTION_TIME_D:\n        case JSI_OPTION_TIME_W: {\n            Jsi_Number jtime = mdbMyTimeToJS(&field->buffer.timestamp);\n            Jsi_NumberToString(interp, jtime, nbuf, sizeof(nbuf));\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        case JSI_OPTION_DOUBLE: {\n            Jsi_NumberToString(interp, field->buffer.vdouble, nbuf, sizeof(nbuf));\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        default:\n            Jsi_LogWarn(\"unknown type: %d\", field->jsiTypeMap);\n    }\n}", "target": 1}
{"code": "ikev1_hash_print(netdissect_options *ndo, u_char tpay _U_,\n\t\t const struct isakmp_gen *ext, u_int item_len _U_,\n\t\t const u_char *ep _U_, uint32_t phase _U_, uint32_t doi _U_,\n\t\t uint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_HASH)));\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_HASH)));\n\treturn NULL;\n}", "target": 0}
{"code": "\tCmdResult HandleLocal(LocalUser* user, const Params& parameters) CXX11_OVERRIDE\n\t{\n\t\tsize_t origin = parameters.size() > 1 ? 1 : 0;\n\t\tif (parameters[origin].empty())\n\t\t{\n\t\t\tuser->WriteNumeric(ERR_NOORIGIN, \"No origin specified\");\n\t\t\treturn CMD_FAILURE;\n\t\t}\n\t\tClientProtocol::Messages::Pong pong(parameters[0], origin ? parameters[1] : \"\");\n\t\tuser->Send(ServerInstance->GetRFCEvents().pong, pong);\n\t\treturn CMD_SUCCESS;\n\t}", "target": 1}
{"code": "void GfxCalGrayColorSpace::getDefaultColor(GfxColor *color) const\n{\n    color->c[0] = 0;\n}", "target": 0}
{"code": "CONCRETE_IO_HANDLE socketio_create(void* io_create_parameters)\n{\n    SOCKETIO_CONFIG* socket_io_config = (SOCKETIO_CONFIG*)io_create_parameters;\n    SOCKET_IO_INSTANCE* result;\n    struct tcp_keepalive tcp_keepalive = { 0, 0, 0 };\n    if (socket_io_config == NULL)\n    {\n        LogError(\"Invalid argument: socket_io_config is NULL\");\n        result = NULL;\n    }\n    else\n    {\n        result = (SOCKET_IO_INSTANCE*)malloc(sizeof(SOCKET_IO_INSTANCE));\n        if (result != NULL)\n        {\n            (void)memset(result, 0, sizeof(SOCKET_IO_INSTANCE));\n            result->address_type = ADDRESS_TYPE_IP;\n            result->pending_io_list = singlylinkedlist_create();\n            if (result->pending_io_list == NULL)\n            {\n                LogError(\"Failure: singlylinkedlist_create unable to create pending list.\");\n                destroy_socket_io_instance(result);\n                result = NULL;\n            }\n            else\n            {\n                if (socket_io_config->hostname != NULL)\n                {\n                    result->hostname = (char*)malloc(strlen(socket_io_config->hostname) + 1);\n                    if (result->hostname != NULL)\n                    {\n                        (void)strcpy(result->hostname, socket_io_config->hostname);\n                    }\n                    result->socket = INVALID_SOCKET;\n                }\n                else\n                {\n                    result->hostname = NULL;\n                    result->socket = *((SOCKET*)socket_io_config->accepted_socket);\n                }\n                if ((result->hostname == NULL) && (result->socket == INVALID_SOCKET))\n                {\n                    LogError(\"Failure: hostname == NULL and socket is invalid.\");\n                    destroy_socket_io_instance(result);\n                    result = NULL;\n                }\n                else if ((result->addrInfo = calloc(1, sizeof(struct addrinfo))) == NULL)\n                {\n                    LogError(\"Failure: addrInfo == NULL.\");\n                    destroy_socket_io_instance(result);\n                    result = NULL;\n                }\n                else\n                {\n                    result->port = socket_io_config->port;\n                    result->on_io_open_complete = NULL;\n                    result->dns_resolver = dns_resolver_create(result->hostname, socket_io_config->port, NULL);\n                    result->on_bytes_received = NULL;\n                    result->on_io_error = NULL;\n                    result->on_bytes_received_context = NULL;\n                    result->on_io_error_context = NULL;\n                    result->io_state = IO_STATE_CLOSED;\n                    result->keep_alive = tcp_keepalive;\n                }\n            }\n        }\n        else\n        {\n            LogError(\"Allocation Failure: SOCKET_IO_INSTANCE\");\n        }\n    }\n    return (XIO_HANDLE)result;\n}", "target": 1}
{"code": "static void* my_gballoc_calloc(size_t nmemb, size_t size)\n{\n    return calloc(nmemb, size);\n}", "target": 0}
{"code": "Suite *xml_load_suite(void)\n{\n\tSuite *suite;\n\tTCase *validate;\n\tvalidate = tcase_create(\"Validate\");\n\ttcase_add_test(validate, test_deltas_head_sort);\n\tsuite = suite_create(\"xml_test()\");\n\tsuite_add_tcase(suite, validate);\n\treturn suite;\n}", "target": 0}
{"code": "static void nested_svm_uninit_mmu_context(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.walk_mmu = &vcpu->arch.mmu;\n}", "target": 0}
{"code": "is_url(const char *source)\n{\n\tchar *colonp;\n\tcolonp = strchr(source, ':');\n\tif (colonp == NULL)\n\t{\n\t\treturn (0);\n\t}\n\tif (strncmp(colonp + 1, \"\n\t{\n\t\treturn (0);\n\t}\n\treturn (1);\n}", "target": 0}
{"code": "static int http_read_header(URLContext *h, int *new_location)\n{\n    HTTPContext *s = h->priv_data;\n    char line[MAX_URL_SIZE];\n    int err = 0;\n    s->chunksize = -1;\n    for (;;) {\n        if ((err = http_get_line(s, line, sizeof(line))) < 0)\n            return err;\n        av_log(h, AV_LOG_TRACE, \"header='%s'\\n\", line);\n        err = process_line(h, line, s->line_count, new_location);\n        if (err < 0)\n            return err;\n        if (err == 0)\n            break;\n        s->line_count++;\n    }\n    if (s->seekable == -1 && s->is_mediagateway && s->filesize == 2000000000)\n        h->is_streamed = 1; \n    cookie_string(s->cookie_dict, &s->cookies);\n    av_dict_free(&s->cookie_dict);\n    return err;\n}", "target": 1}
{"code": "    bool IsOpened() {return hFile!=FILE_BAD_HANDLE;};", "target": 1}
{"code": "unquoted_glob_pattern_p (string)\n     register char *string;\n{\n  register int c;\n  char *send;\n  int open, bsquote;\n  DECLARE_MBSTATE;\n  open = bsquote = 0;\n  send = string + strlen (string);\n  while (c = *string++)\n    {\n      switch (c)\n\t{\n\tcase '?':\n\tcase '*':\n\t  return (1);\n\tcase '[':\n\t  open++;\n\t  continue;\n\tcase ']':\n\t  if (open)\n\t    return (1);\n\t  continue;\n\tcase '+':\n\tcase '@':\n\tcase '!':\n\t  if (*string == '(')\t\n\t    return (1);\n\t  continue;\n\tcase '\\\\':\n\t  if (*string != '\\0' && *string != '/')\n\t    {\n\t      bsquote = 1;\n\t      string++;\n\t      continue;\n\t    }\n\t  else if (*string == 0)\n\t    return (0);\n\tcase CTLESC:\n\t  if (*string++ == '\\0')\n\t    return (0);\n\t}\n#ifdef HANDLE_MULTIBYTE\n      string--;\n      ADVANCE_CHAR_P (string, send - string);\n      string++;\n#else\n      ADVANCE_CHAR_P (string, send - string);\n#endif\n    }\n  return ((bsquote && posix_glob_backslash) ? 2 : 0);\n}", "target": 1}
{"code": "static inline void context_set_translation_type(struct context_entry *context,\n\t\t\t\t\t\tunsigned long value)\n{\n\tcontext->lo &= (((u64)-1) << 4) | 3;\n\tcontext->lo |= (value & 3) << 2;\n}", "target": 0}
{"code": "Status ExtractVariantFromInput(OpKernelContext* ctx, int index,\n                               const T** value) {\n  const Tensor& input_t = ctx->input(index);\n  if (!TensorShapeUtils::IsScalar(input_t.shape())) {\n    return errors::InvalidArgument(\n        \"Invalid input matrix: Shape must be rank 0 but is rank \",\n        input_t.dims());\n  }\n  const Variant& input_variant = input_t.scalar<Variant>()();\n  *value = input_variant.get<T>();\n  if (*value == nullptr) {\n    return errors::InvalidArgument(\"Could not retrieve Variant input \", index);\n  }\n  if (!(*value)->valid()) {\n    return errors::InvalidArgument(\"Variant input \", index, \" is not valid.\");\n  }\n  return OkStatus();\n}", "target": 0}
{"code": "static inline __u32 skb_get_rxhash(struct sk_buff *skb)\n{\n\tif (!skb->l4_rxhash)\n\t\t__skb_get_rxhash(skb);\n\treturn skb->rxhash;\n}", "target": 0}
{"code": "pci_emul_capwrite(struct pci_vdev *dev, int offset, int bytes, uint32_t val)\n{\n\tint capid;\n\tuint8_t capoff, nextoff;\n\tif ((offset & (bytes - 1)) != 0)\n\t\treturn;\n\tcapoff = CAP_START_OFFSET;\n\twhile (1) {\n\t\tnextoff = pci_get_cfgdata8(dev, capoff + 1);\n\t\tif (nextoff == 0)\n\t\t\tbreak;\n\t\tif (offset >= capoff && offset < nextoff)\n\t\t\tbreak;\n\t\tcapoff = nextoff;\n\t}\n\tassert(offset >= capoff);\n\tif (offset == capoff || offset == capoff + 1) {\n\t\tif (offset == capoff && bytes == 4) {\n\t\t\tbytes = 2;\n\t\t\toffset += 2;\n\t\t\tval >>= 16;\n\t\t} else\n\t\t\treturn;\n\t}\n\tcapid = pci_get_cfgdata8(dev, capoff);\n\tswitch (capid) {\n\tcase PCIY_MSI:\n\t\tmsicap_cfgwrite(dev, capoff, offset, bytes, val);\n\t\tbreak;\n\tcase PCIY_MSIX:\n\t\tmsixcap_cfgwrite(dev, capoff, offset, bytes, val);\n\t\tbreak;\n\tcase PCIY_EXPRESS:\n\t\tpciecap_cfgwrite(dev, capoff, offset, bytes, val);\n\t\tbreak;\n\tdefault:\n\t\tCFGWRITE(dev, offset, val, bytes);\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "valid_weeknum_sub(int argc, VALUE *argv, VALUE klass, int need_jd)\n{\n    VALUE nth, y;\n    int w, d, f, ry, rw, rd;\n    double sg;\n    y = argv[0];\n    w = NUM2INT(argv[1]);\n    d = NUM2INT(argv[2]);\n    f = NUM2INT(argv[3]);\n    sg = NUM2DBL(argv[4]);\n    valid_sg(sg);\n    {\n\tint rjd, ns;\n\tVALUE rjd2;\n\tif (!valid_weeknum_p(y, w, d, f, sg,\n\t\t\t     &nth, &ry,\n\t\t\t     &rw, &rd, &rjd,\n\t\t\t     &ns))\n\t    return Qnil;\n\tif (!need_jd)\n\t    return INT2FIX(0); \n\tencode_jd(nth, rjd, &rjd2);\n\treturn rjd2;\n    }\n}", "target": 0}
{"code": "static void progress_handler(int progress, void *arg)\n{\n\tprintf(\"Progress=%d\\n\", progress);\n}", "target": 0}
{"code": "void ConnectDialogEdit::accept() {\n\tvalidate();\n\tif (bOk) {\n\t\tQString server = qleServer->text().simplified();\n\t\tconst int schemaPos = server.indexOf(QLatin1String(\":\n\t\tif (schemaPos != -1) {\n\t\t\tserver.remove(0, schemaPos + 3);\n\t\t}\n\t\tconst int pathPos = server.indexOf(QLatin1Char('/'));\n\t\tif (pathPos != -1) {\n\t\t\tserver.resize(pathPos);\n\t\t}\n\t\tqleServer->setText(server);\n\t\tif (qleName->text().simplified().isEmpty() || !bCustomLabel) {\n\t\t\tqleName->setText(server);\n\t\t}\n\t\tQDialog::accept();\n\t}\n}", "target": 0}
{"code": "get_principal_2_svc(gprinc_arg *arg, struct svc_req *rqstp)\n{\n    static gprinc_ret               ret;\n    char                            *prime_arg, *funcname;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_gprinc_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    funcname = \"kadm5_get_principal\";\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (! cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ) &&\n        (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                        rqst2name(rqstp),\n                                                        ACL_INQUIRE,\n                                                        arg->princ,\n                                                        NULL))) {\n        ret.code = KADM5_AUTH_GET;\n        log_unauth(funcname, prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_get_principal(handle, arg->princ, &ret.rec,\n                                       arg->mask);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(funcname, prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "TEST(ModMatchExpression, MatchesArrayValue) {\n    ModMatchExpression mod(\"a\", 5, 2);\n    ASSERT(mod.matchesBSON(BSON(\"a\" << BSON_ARRAY(5 << 12LL)), NULL));\n    ASSERT(!mod.matchesBSON(BSON(\"a\" << BSON_ARRAY(6 << 8)), NULL));\n}", "target": 0}
{"code": "static int crypto_pcomp_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_comp rpcomp;\n\tsnprintf(rpcomp.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"pcomp\");\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n\t\t    sizeof(struct crypto_report_comp), &rpcomp))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "GF_Err text_box_size(GF_Box *s)\n{\n\tGF_TextSampleEntryBox *ptr = (GF_TextSampleEntryBox*)s;\n\ts->size += 51 + 1;\n\tif (ptr->textName)\n\t\ts->size += strlen(ptr->textName);\n\treturn GF_OK;\n}", "target": 1}
{"code": "int compat_sock_common_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t\t  char __user *optval, int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tif (sk->sk_prot->compat_setsockopt != NULL)\n\t\treturn sk->sk_prot->compat_setsockopt(sk, level, optname,\n\t\t\t\t\t\t      optval, optlen);\n\treturn sk->sk_prot->setsockopt(sk, level, optname, optval, optlen);\n}", "target": 0}
{"code": "TEST_F(QuicUnencryptedServerTransportTest, DuplicateOneRttWriteCipher) {\n  setupClientReadCodec();\n  recvClientHello();\n  recvClientFinished();\n  loopForWrites();\n  try {\n    recvClientHello();\n    recvClientFinished();\n    FAIL();\n  } catch (const std::runtime_error& ex) {\n    EXPECT_THAT(ex.what(), HasSubstr(\"Crypto error\"));\n  }\n  EXPECT_TRUE(server->isClosed());\n}", "target": 0}
{"code": "size_t IOBuf::goodExtBufferSize(std::size_t minCapacity) {\n  if (minCapacity > kMaxIOBufSize) {\n    throw_exception<std::bad_alloc>();\n  }\n  size_t minSize = static_cast<size_t>(minCapacity) + sizeof(SharedInfo);\n  minSize = (minSize + 7) & ~7;\n  return goodMallocSize(minSize);\n}", "target": 0}
{"code": "static int __init proc_genhd_init(void)\n{\n\tproc_create(\"diskstats\", 0, NULL, &proc_diskstats_operations);\n\tproc_create(\"partitions\", 0, NULL, &proc_partitions_operations);\n\treturn 0;\n}", "target": 0}
{"code": "static int8_t sn_coap_parser_add_u16_limit(uint16_t a, uint16_t b, uint16_t *result)\n{\n    uint16_t c;\n    c = a + b;\n    if (c < a || c < b)\n    {\n        return -1;\n    }\n    *result = c;\n    return 0;\n}", "target": 0}
{"code": "double Item_cache_str::val_real()\n{\n  DBUG_ASSERT(fixed == 1);\n  int err_not_used;\n  char *end_not_used;\n  if (!has_value())\n    return 0.0;\n  if (value)\n    return my_strntod(value->charset(), (char*) value->ptr(),\n\t\t      value->length(), &end_not_used, &err_not_used);\n  return (double) 0;\n}", "target": 0}
{"code": "struct clock_source *dce112_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\tif (!clk_src)\n\t\treturn NULL;\n\tif (dce112_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\tkfree(clk_src);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 0}
{"code": "header_cache_t *imap_hcache_open(struct ImapData *idata, const char *path)\n{\n  struct ImapMbox mx;\n  struct Url url;\n  char cachepath[PATH_MAX];\n  char mbox[PATH_MAX];\n  if (path)\n    imap_cachepath(idata, path, mbox, sizeof(mbox));\n  else\n  {\n    if (!idata->ctx || imap_parse_path(idata->ctx->path, &mx) < 0)\n      return NULL;\n    imap_cachepath(idata, mx.mbox, mbox, sizeof(mbox));\n    FREE(&mx.mbox);\n  }\n  if (strstr(mbox, \"/../\") || (strcmp(mbox, \"..\") == 0) || (strncmp(mbox, \"../\", 3) == 0))\n    return NULL;\n  size_t len = strlen(mbox);\n  if ((len > 3) && (strcmp(mbox + len - 3, \"/..\") == 0))\n    return NULL;\n  mutt_account_tourl(&idata->conn->account, &url);\n  url.path = mbox;\n  url_tostring(&url, cachepath, sizeof(cachepath), U_PATH);\n  return mutt_hcache_open(HeaderCache, cachepath, imap_hcache_namer);\n}", "target": 0}
{"code": "status_t Parcel::setDataSize(size_t size)\n{\n if (size > INT32_MAX) {\n return BAD_VALUE;\n }\n status_t err;\n    err = continueWrite(size);\n if (err == NO_ERROR) {\n        mDataSize = size;\n        ALOGV(\"setDataSize Setting data size of %p to %zu\", this, mDataSize);\n }\n return err;\n}", "target": 0}
{"code": "xfs_attr3_leaf_getvalue(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tint\t\t\tvaluelen;\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(ichdr.count < XFS_LBSIZE(args->dp->i_mount) / 8);\n\tASSERT(args->index < ichdr.count);\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tASSERT(name_loc->namelen == args->namelen);\n\t\tASSERT(memcmp(args->name, name_loc->nameval, args->namelen) == 0);\n\t\tvaluelen = be16_to_cpu(name_loc->valuelen);\n\t\tif (args->flags & ATTR_KERNOVAL) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn 0;\n\t\t}\n\t\tif (args->valuelen < valuelen) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn XFS_ERROR(ERANGE);\n\t\t}\n\t\targs->valuelen = valuelen;\n\t\tmemcpy(args->value, &name_loc->nameval[args->namelen], valuelen);\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tASSERT(name_rmt->namelen == args->namelen);\n\t\tASSERT(memcmp(args->name, name_rmt->name, args->namelen) == 0);\n\t\tvaluelen = be32_to_cpu(name_rmt->valuelen);\n\t\targs->rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(args->dp->i_mount,\n\t\t\t\t\t\t       valuelen);\n\t\tif (args->flags & ATTR_KERNOVAL) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn 0;\n\t\t}\n\t\tif (args->valuelen < valuelen) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn XFS_ERROR(ERANGE);\n\t\t}\n\t\targs->valuelen = valuelen;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void HTMLMediaElement::OnVisibilityChangedForLazyLoad(bool is_visible) {\n  if (!is_visible || !web_media_player_)\n    return;\n  web_media_player_->OnBecameVisible();\n  lazy_load_visibility_observer_->Stop();\n  lazy_load_visibility_observer_ = nullptr;\n}", "target": 0}
{"code": "  static void  Ins_MDRP( INS_ARG )\n  {\n    Int         point;\n    TT_F26Dot6  distance,\n                org_dist;\n    point = (Int)args[0];\n    if ( BOUNDS( args[0], CUR.zp1.n_points ) )\n    {\n      return;\n    }\n    org_dist = CUR_Func_dualproj( CUR.zp1.org_x[point] -\n                                    CUR.zp0.org_x[CUR.GS.rp0],\n                                  CUR.zp1.org_y[point] -\n                                    CUR.zp0.org_y[CUR.GS.rp0] );\n    if ( ABS(org_dist) < CUR.GS.single_width_cutin )\n    {\n      if ( org_dist >= 0 )\n        org_dist = CUR.GS.single_width_value;\n      else\n        org_dist = -CUR.GS.single_width_value;\n    }\n    if ( (CUR.opcode & 4) != 0 )\n      distance = CUR_Func_round( org_dist,\n                                 CUR.metrics.compensations[CUR.opcode & 3] );\n    else\n      distance = Round_None( EXEC_ARGS\n                             org_dist,\n                             CUR.metrics.compensations[CUR.opcode & 3]  );\n    if ( (CUR.opcode & 8) != 0 )\n    {\n      if ( org_dist >= 0 )\n      {\n        if ( distance < CUR.GS.minimum_distance )\n          distance = CUR.GS.minimum_distance;\n      }\n      else\n      {\n        if ( distance > -CUR.GS.minimum_distance )\n          distance = -CUR.GS.minimum_distance;\n      }\n    }\n    org_dist = CUR_Func_project( CUR.zp1.cur_x[point] -\n                                   CUR.zp0.cur_x[CUR.GS.rp0],\n                                 CUR.zp1.cur_y[point] -\n                                   CUR.zp0.cur_y[CUR.GS.rp0] );\n    CUR_Func_move( &CUR.zp1, point, distance - org_dist );\n    CUR.GS.rp1 = CUR.GS.rp0;\n    CUR.GS.rp2 = point;\n    if ( (CUR.opcode & 16) != 0 )\n      CUR.GS.rp0 = point;\n  }", "target": 0}
{"code": "static int smb2_calc_max_out_buf_len(struct ksmbd_work *work,\n\t\t\t\t     unsigned short hdr2_len,\n\t\t\t\t     unsigned int out_buf_len)\n{\n\tint free_len;\n\tif (out_buf_len > work->conn->vals->max_trans_size)\n\t\treturn -EINVAL;\n\tfree_len = (int)(work->response_sz -\n\t\t\t (get_rfc1002_len(work->response_buf) + 4)) -\n\t\thdr2_len;\n\tif (free_len < 0)\n\t\treturn -EINVAL;\n\treturn min_t(int, out_buf_len, free_len);\n}", "target": 1}
{"code": "void WidgetUtils::openUrlByDesktop(const QUrl &p_url)\n{\n    const auto scheme = p_url.scheme();\n    if (scheme != \"http\" && scheme != \"https\") {\n        int ret = MessageBoxHelper::questionYesNo(MessageBoxHelper::Warning,\n                                                  MainWindow::tr(\"Are you sure to open link (%1)?\").arg(p_url.toString()),\n                                                  MainWindow::tr(\"Malicious link might do harm to your device.\"),\n                                                  QString(),\n                                                  nullptr);\n        if (ret == QMessageBox::No) {\n            return;\n        }\n    }\n    QDesktopServices::openUrl(p_url);\n}", "target": 0}
{"code": "GF_Err ainf_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_AssetInformationBox *ptr = (GF_AssetInformationBox *) s;\n\tISOM_DECREASE_SIZE(s, 4)\n\tptr->profile_version = gf_bs_read_u32(bs);\n\treturn gf_isom_read_null_terminated_string(s, bs, s->size, &ptr->APID);\n}", "target": 0}
{"code": "set_ssl_ciphers(SCHANNEL_CRED *schannel_cred, char *ciphers,\n                ALG_ID *algIds)\n{\n  char *startCur = ciphers;\n  int algCount = 0;\n  while(startCur && (0 != *startCur) && (algCount < NUMOF_CIPHERS)) {\n    long alg = strtol(startCur, 0, 0);\n    if(!alg)\n      alg = get_alg_id_by_name(startCur);\n    if(alg)\n      algIds[algCount++] = alg;\n    else if(!strncmp(startCur, \"USE_STRONG_CRYPTO\",\n                     sizeof(\"USE_STRONG_CRYPTO\") - 1) ||\n            !strncmp(startCur, \"SCH_USE_STRONG_CRYPTO\",\n                     sizeof(\"SCH_USE_STRONG_CRYPTO\") - 1))\n      schannel_cred->dwFlags |= SCH_USE_STRONG_CRYPTO;\n    else\n      return CURLE_SSL_CIPHER;\n    startCur = strchr(startCur, ':');\n    if(startCur)\n      startCur++;\n  }\n  schannel_cred->palgSupportedAlgs = algIds;\n  schannel_cred->cSupportedAlgs = algCount;\n  return CURLE_OK;\n}", "target": 0}
{"code": "PJ_DEF(void) pj_scan_get_until( pj_scanner *scanner,\n\t\t\t\tconst pj_cis_t *spec, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n    if (s >= scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n    while (PJ_SCAN_CHECK_EOF(s) && !pj_cis_match(spec, *s)) {\n\t++s;\n    }\n    pj_strset3(out, scanner->curptr, s);\n    scanner->curptr = s;\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*s) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);\n    }\n}", "target": 1}
{"code": "vhost_scsi_make_tpg(struct se_wwn *wwn,\n\t\t   struct config_group *group,\n\t\t   const char *name)\n{\n\tstruct vhost_scsi_tport *tport = container_of(wwn,\n\t\t\tstruct vhost_scsi_tport, tport_wwn);\n\tstruct vhost_scsi_tpg *tpg;\n\tunsigned long tpgt;\n\tint ret;\n\tif (strstr(name, \"tpgt_\") != name)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (kstrtoul(name + 5, 10, &tpgt) || tpgt > UINT_MAX)\n\t\treturn ERR_PTR(-EINVAL);\n\ttpg = kzalloc(sizeof(struct vhost_scsi_tpg), GFP_KERNEL);\n\tif (!tpg) {\n\t\tpr_err(\"Unable to allocate struct vhost_scsi_tpg\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tmutex_init(&tpg->tv_tpg_mutex);\n\tINIT_LIST_HEAD(&tpg->tv_tpg_list);\n\ttpg->tport = tport;\n\ttpg->tport_tpgt = tpgt;\n\tret = core_tpg_register(&vhost_scsi_fabric_configfs->tf_ops, wwn,\n\t\t\t\t&tpg->se_tpg, tpg, TRANSPORT_TPG_TYPE_NORMAL);\n\tif (ret < 0) {\n\t\tkfree(tpg);\n\t\treturn NULL;\n\t}\n\tmutex_lock(&vhost_scsi_mutex);\n\tlist_add_tail(&tpg->tv_tpg_list, &vhost_scsi_list);\n\tmutex_unlock(&vhost_scsi_mutex);\n\treturn &tpg->se_tpg;\n}", "target": 1}
{"code": "void LibRaw::Canon_WBpresets(int skip1, int skip2)\n{\n  int c;\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();\n  if (skip1)\n    fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();\n  if (skip1)\n    fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();\n  if (skip1)\n    fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();\n  if (skip1)\n    fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();\n  if (skip2)\n    fseek(ifp, skip2, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();\n  return;\n}", "target": 0}
{"code": "uint32_t mt_random (mtrand *mt) {\n  uint32_t y;\n  unsigned long mag01[2];\n  mag01[0] = 0;\n  mag01[1] = MATRIX_A;\n  if (mt->mt_index_ >= MT_LEN) {\n    int kk;\n    for (kk = 0; kk < MT_LEN - MT_IA; kk++) {\n      y = (mt->mt_buffer_[kk] & UPPER_MASK) | \n\t(mt->mt_buffer_[kk + 1] & LOWER_MASK);\n      mt->mt_buffer_[kk] = mt->mt_buffer_[kk + MT_IA] ^ \n\t(y >> 1) ^ mag01[y & 0x1UL];\n    }\n    for (;kk < MT_LEN - 1; kk++) {\n      y = (mt->mt_buffer_[kk] & UPPER_MASK) | \n\t(mt->mt_buffer_[kk + 1] & LOWER_MASK);\n      mt->mt_buffer_[kk] = mt->mt_buffer_[kk + (MT_IA - MT_LEN)] ^ \n\t(y >> 1) ^ mag01[y & 0x1UL];\n    }\n    y = (mt->mt_buffer_[MT_LEN - 1] & UPPER_MASK) | \n      (mt->mt_buffer_[0] & LOWER_MASK);\n    mt->mt_buffer_[MT_LEN - 1] = mt->mt_buffer_[MT_IA - 1] ^ \n      (y >> 1) ^ mag01[y & 0x1UL];\n    mt->mt_index_ = 0;\n  }\n  y = mt->mt_buffer_[mt->mt_index_++];\n  y ^= (y >> 11);\n  y ^= (y << 7) & 0x9d2c5680UL;\n  y ^= (y << 15) & 0xefc60000UL;\n  y ^= (y >> 18);\n  return y;\n}", "target": 1}
{"code": "Cleanup Ipv6Instance::forceProtocolUnsupportedForTest(bool new_val) {\n  bool old_val = force_ipv6_unsupported_for_test;\n  force_ipv6_unsupported_for_test = new_val;\n  return Cleanup([old_val]() { force_ipv6_unsupported_for_test = old_val; });\n}", "target": 0}
{"code": "address_space_translate_for_iotlb(CPUState *cpu, int asidx, hwaddr addr,\n                                  hwaddr *xlat, hwaddr *plen,\n                                  MemTxAttrs attrs, int *prot)\n{\n    MemoryRegionSection *section;\n    IOMMUMemoryRegion *iommu_mr;\n    IOMMUMemoryRegionClass *imrc;\n    IOMMUTLBEntry iotlb;\n    int iommu_idx;\n    AddressSpaceDispatch *d =\n        qatomic_rcu_read(&cpu->cpu_ases[asidx].memory_dispatch);\n    for (;;) {\n        section = address_space_translate_internal(d, addr, &addr, plen, false);\n        iommu_mr = memory_region_get_iommu(section->mr);\n        if (!iommu_mr) {\n            break;\n        }\n        imrc = memory_region_get_iommu_class_nocheck(iommu_mr);\n        iommu_idx = imrc->attrs_to_index(iommu_mr, attrs);\n        tcg_register_iommu_notifier(cpu, iommu_mr, iommu_idx);\n        iotlb = imrc->translate(iommu_mr, addr, IOMMU_NONE, iommu_idx);\n        addr = ((iotlb.translated_addr & ~iotlb.addr_mask)\n                | (addr & iotlb.addr_mask));\n        if (!(iotlb.perm & IOMMU_RO)) {\n            *prot &= ~(PAGE_READ | PAGE_EXEC);\n        }\n        if (!(iotlb.perm & IOMMU_WO)) {\n            *prot &= ~PAGE_WRITE;\n        }\n        if (!*prot) {\n            goto translate_fail;\n        }\n        d = flatview_to_dispatch(address_space_to_flatview(iotlb.target_as));\n    }\n    assert(!memory_region_is_iommu(section->mr));\n    *xlat = addr;\n    return section;\ntranslate_fail:\n    return &d->map.sections[PHYS_SECTION_UNASSIGNED];\n}", "target": 1}
{"code": "DECLAREreadFunc(readContigTilesIntoBuffer)\n{\n\tint status = 1;\n\ttsize_t tilesize = TIFFTileSize(in);\n\ttdata_t tilebuf;\n\tuint32 imagew = TIFFScanlineSize(in);\n\tuint32 tilew  = TIFFTileRowSize(in);\n\tint iskew = imagew - tilew;\n\tuint8* bufp = (uint8*) buf;\n\tuint32 tw, tl;\n\tuint32 row;\n\t(void) spp;\n\ttilebuf = _TIFFmalloc(tilesize);\n\tif (tilebuf == 0)\n\t\treturn 0;\n\t_TIFFmemset(tilebuf, 0, tilesize);\n\t(void) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n\t(void) TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n\tfor (row = 0; row < imagelength; row += tl) {\n\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\n\t\tuint32 colb = 0;\n\t\tuint32 col;\n\t\tfor (col = 0; col < imagewidth; col += tw) {\n\t\t\tif (TIFFReadTile(in, tilebuf, col, row, 0, 0) < 0\n\t\t\t    && !ignore) {\n\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t    \"Error, can't read tile at %lu %lu\",\n\t\t\t\t    (unsigned long) col,\n\t\t\t\t    (unsigned long) row);\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (colb + tilew > imagew) {\n\t\t\t\tuint32 width = imagew - colb;\n\t\t\t\tuint32 oskew = tilew - width;\n\t\t\t\tcpStripToTile(bufp + colb,\n\t\t\t\t    tilebuf, nrow, width,\n\t\t\t\t    oskew + iskew, oskew );\n\t\t\t} else\n\t\t\t\tcpStripToTile(bufp + colb,\n\t\t\t\t    tilebuf, nrow, tilew,\n\t\t\t\t    iskew, 0);\n\t\t\tcolb += tilew;\n\t\t}\n\t\tbufp += imagew * nrow;\n\t}\ndone:\n\t_TIFFfree(tilebuf);\n\treturn status;\n}", "target": 1}
{"code": "static void JS_FoxxAllowInstallFromRemote(v8::FunctionCallbackInfo<v8::Value> const& args) {\n  TRI_V8_TRY_CATCH_BEGIN(isolate)\n  v8::HandleScope scope(isolate);\n  TRI_GET_GLOBALS();\n  ServerSecurityFeature& security = v8g->_server.getFeature<ServerSecurityFeature>();\n  TRI_V8_RETURN_BOOL(security.foxxAllowInstallFromRemote());\n  TRI_V8_TRY_CATCH_END\n}", "target": 0}
{"code": "int kvm_arch_vcpu_ioctl_translate(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_translation *tr)\n{\n\tunsigned long vaddr = tr->linear_address;\n\tgpa_t gpa;\n\tint idx;\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tgpa = kvm_mmu_gva_to_gpa_system(vcpu, vaddr, NULL);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\ttr->physical_address = gpa;\n\ttr->valid = gpa != UNMAPPED_GVA;\n\ttr->writeable = 1;\n\ttr->usermode = 0;\n\treturn 0;\n}", "target": 0}
{"code": "ossl_cipher_set_key(VALUE self, VALUE key)\n{\n    EVP_CIPHER_CTX *ctx;\n    int key_len;\n    StringValue(key);\n    GetCipher(self, ctx);\n    key_len = EVP_CIPHER_CTX_key_length(ctx);\n    if (RSTRING_LEN(key) != key_len)\n\tossl_raise(rb_eArgError, \"key must be %d bytes\", key_len);\n    if (EVP_CipherInit_ex(ctx, NULL, NULL, (unsigned char *)RSTRING_PTR(key), NULL, -1) != 1)\n\tossl_raise(eCipherError, NULL);\n    rb_ivar_set(self, id_key_set, Qtrue);\n    return key;\n}", "target": 0}
{"code": "void flush_tlb_current_task(void)\n{\n\tstruct mm_struct *mm = current->mm;\n\tpreempt_disable();\n\tcount_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ALL);\n\tlocal_flush_tlb();\n\ttrace_tlb_flush(TLB_LOCAL_SHOOTDOWN, TLB_FLUSH_ALL);\n\tif (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) < nr_cpu_ids)\n\t\tflush_tlb_others(mm_cpumask(mm), mm, 0UL, TLB_FLUSH_ALL);\n\tpreempt_enable();\n}", "target": 0}
{"code": "static int masq_inet_event(struct notifier_block *this,\n\t\t\t   unsigned long event,\n\t\t\t   void *ptr)\n{\n\tstruct net_device *dev = ((struct in_ifaddr *)ptr)->ifa_dev->dev;\n\tstruct netdev_notifier_info info;\n\tnetdev_notifier_info_init(&info, dev);\n\treturn masq_device_event(this, event, &info);\n}", "target": 1}
{"code": "gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t   gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n\t\t   int iov_count)\n{\n    OM_uint32 status;\n    gss_union_ctx_id_t ctx;\n    gss_mechanism mech;\n    status = val_unwrap_iov_args(minor_status, context_handle, NULL,\n\t\t\t\t qop_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn status;\n    ctx = (gss_union_ctx_id_t)context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n    mech = gssint_get_mechanism(ctx->mech_type);\n    if (mech == NULL)\n\treturn GSS_S_BAD_MECH;\n    if (mech->gss_verify_mic_iov == NULL)\n\treturn GSS_S_UNAVAILABLE;\n    status = mech->gss_verify_mic_iov(minor_status, ctx->internal_ctx_id,\n\t\t\t\t      qop_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\tmap_error(minor_status, mech);\n    return status;\n}", "target": 0}
{"code": "mm_make_entry(struct mm_master *mm, struct mmtree *head,\n    void *address, size_t size)\n{\n\tstruct mm_share *tmp, *tmp2;\n\tif (mm->mmalloc == NULL)\n\t\ttmp = xcalloc(1, sizeof(struct mm_share));\n\telse\n\t\ttmp = mm_xmalloc(mm->mmalloc, sizeof(struct mm_share));\n\ttmp->address = address;\n\ttmp->size = size;\n\ttmp2 = RB_INSERT(mmtree, head, tmp);\n\tif (tmp2 != NULL)\n\t\tfatal(\"mm_make_entry(%p): double address %p->%p(%zu)\",\n\t\t    mm, tmp2, address, size);\n\treturn (tmp);\n}", "target": 1}
{"code": "static inline int alloc_debug_processing(struct kmem_cache *s,\n\tstruct page *page, void *object, void *addr) { return 0; }", "target": 0}
{"code": "static Jsi_RC NumberToFixedCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[100];\n    int prec = 0, skip = 0;\n    Jsi_Number num;\n    Jsi_Value *v;\n    ChkStringN(_this, funcPtr, v);\n    Jsi_Value *pa = Jsi_ValueArrayIndex(interp, args, skip);\n    if (pa && Jsi_GetIntFromValue(interp, pa, &prec) != JSI_OK)\n        return JSI_ERROR;\n    if (prec<0) prec = 0;\n    Jsi_GetDoubleFromValue(interp, v, &num);\n    snprintf(buf, sizeof(buf), \"%.*\" JSI_NUMFFMT, prec, num);\n    Jsi_ValueMakeStringDup(interp, ret, buf);\n    return JSI_OK;\n}", "target": 1}
{"code": "static void cliRefreshPrompt(void) {\n    int len;\n    if (config.eval_ldb) return;\n    if (config.hostsocket != NULL)\n        len = snprintf(config.prompt,sizeof(config.prompt),\"redis %s\",\n                       config.hostsocket);\n    else\n        len = anetFormatAddr(config.prompt, sizeof(config.prompt),\n                           config.hostip, config.hostport);\n    if (config.dbnum != 0)\n        len += snprintf(config.prompt+len,sizeof(config.prompt)-len,\"[%d]\",\n            config.dbnum);\n    snprintf(config.prompt+len,sizeof(config.prompt)-len,\"> \");\n}", "target": 1}
{"code": "pci_populate_msixcap(struct msixcap *msixcap, int msgnum, int barnum,\n\t\t     uint32_t msix_tab_size)\n{\n\tassert(msix_tab_size % 4096 == 0);\n\tbzero(msixcap, sizeof(struct msixcap));\n\tmsixcap->capid = PCIY_MSIX;\n\tmsixcap->msgctrl = msgnum - 1;\n\tmsixcap->table_info = barnum & PCIM_MSIX_BIR_MASK;\n\tmsixcap->pba_info = msix_tab_size | (barnum & PCIM_MSIX_BIR_MASK);\n}", "target": 1}
{"code": "static void nvme_zone_reset_cancel(BlockAIOCB *aiocb)\n{\n    NvmeZoneResetAIOCB *iocb = container_of(aiocb, NvmeZoneResetAIOCB, common);\n    NvmeRequest *req = iocb->req;\n    NvmeNamespace *ns = req->ns;\n    iocb->idx = ns->num_zones;\n    iocb->ret = -ECANCELED;\n    if (iocb->aiocb) {\n        blk_aio_cancel_async(iocb->aiocb);\n        iocb->aiocb = NULL;\n    }\n}", "target": 0}
{"code": "get_page_size_prepared_cb (GdkPixbufLoader *loader,\n\t\t\t   int              width,\n\t\t\t   int              height,\n\t\t\t   PixbufInfo      *info)\n{\n\tinfo->got_info = TRUE;\n\tinfo->height = height;\n\tinfo->width = width;\n}", "target": 0}
{"code": "void* WebGraphicsContext3DDefaultImpl::mapBufferSubDataCHROMIUM(unsigned target, int offset, int size, unsigned access)\n{\n    return 0;\n}", "target": 0}
{"code": "RootWindow* RootWindow::GetRootWindow() {\n  return this;\n}", "target": 0}
{"code": "irc_server_get_prefix_char_for_mode (struct t_irc_server *server, char mode)\n{\n    const char *prefix_chars;\n    int index;\n    if (server)\n    {\n        prefix_chars = irc_server_get_prefix_chars (server);\n        index = irc_server_get_prefix_mode_index (server, mode);\n        if (index >= 0)\n            return prefix_chars[index];\n    }\n    return ' ';\n}", "target": 0}
{"code": "static int redirect_to_splashpage(struct MHD_Connection *connection, t_client *client, const char *host, const char *url)\n{\n\tchar *originurl_raw;\n\tchar *originurl;\n\tchar *query;\n\tint ret = 0;\n\tconst char *separator = \"&\";\n\tchar *querystr;\n\tquery = safe_calloc(QUERYMAXLEN);\n\tif (!query) {\n\t\tret = send_error(connection, 503);\n\t\tfree(query);\n\t\treturn ret;\n\t}\n\tquerystr = safe_calloc(QUERYMAXLEN);\n\tif (!querystr) {\n\t\tret = send_error(connection, 503);\n\t\tfree(querystr);\n\t\treturn ret;\n\t}\n\toriginurl_raw = safe_calloc(MID_BUF);\n\tif (!originurl_raw) {\n\t\tret = send_error(connection, 503);\n\t\tfree(originurl_raw);\n\t\treturn ret;\n\t}\n\toriginurl = safe_calloc(CUSTOM_ENC);\n\tif (!originurl) {\n\t\tret = send_error(connection, 503);\n\t\tfree(originurl);\n\t\treturn ret;\n\t}\n\tget_query(connection, &query, separator);\n\tif (!query) {\n\t\tdebug(LOG_DEBUG, \"Unable to get query string - error 503\");\n\t\tfree(query);\n\t\treturn send_error(connection, 503);\n\t}\n\tdebug(LOG_DEBUG, \"Query string is [ %s ]\", query);\n\tsafe_asprintf(&originurl_raw, \"http:\n\tuh_urlencode(originurl, CUSTOM_ENC, originurl_raw, strlen(originurl_raw));\n\tif (strcmp(url, \"/login\") == 0) {\n\t\tclient->cpi_query = safe_strdup(originurl);\n\t\tdebug(LOG_DEBUG, \"RFC8910 request: %s\", client->cpi_query);\n\t} else {\n\t\tclient->cpi_query = \"none\";\n\t}\n\tdebug(LOG_DEBUG, \"originurl_raw: %s\", originurl_raw);\n\tdebug(LOG_DEBUG, \"originurl: %s\", originurl);\n\tquerystr=construct_querystring(connection, client, originurl, querystr);\n\tret = encode_and_redirect_to_splashpage(connection, client, originurl, querystr);\n\tfree(originurl_raw);\n\tfree(originurl);\n\tfree(query);\n\tfree(querystr);\n\treturn ret;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    const Tensor& grad_in = context->input(1);\n    const Tensor& argmax = context->input(2);\n    PoolParameters params{context,\n                          ksize_,\n                          stride_,\n                          padding_,\n                          {},\n                          FORMAT_NHWC,\n                          tensor_in.shape()};\n    if (!context->status().ok()) {\n      return;\n    }\n    OP_REQUIRES(\n        context, grad_in.shape() == tensor_in.shape(),\n        errors::InvalidArgument(\"Expected grad shape to be \", tensor_in.shape(),\n                                \", but got \", grad_in.shape()));\n    OP_REQUIRES(context, argmax.shape() == params.forward_output_shape(),\n                errors::InvalidArgument(\"Expected argmax shape to be \",\n                                        params.forward_output_shape(),\n                                        \", but got \", argmax.shape()));\n    TensorShape out_shape({params.tensor_in_batch, params.out_height,\n                           params.out_width, params.depth});\n    Tensor* grad_out = nullptr;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                {0}, 0, out_shape, &grad_out));\n    LaunchMaxPoolingGradGradWithArgmax<Device, T>::launch(\n        context, params, grad_in, argmax, grad_out, include_batch_in_index_);\n  }", "target": 0}
{"code": "void test_unlink(const char *path)\n{\n\tif (unlink(path) == 0) {\n\t\tfprintf(stderr, \"leak at unlink of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at unlink of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "iakerb_gss_export_sec_context(OM_uint32 *minor_status,\n                              gss_ctx_id_t *context_handle,\n                              gss_buffer_t interprocess_token)\n{\n    OM_uint32 maj;\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)*context_handle;\n    if (!ctx->established)\n        return GSS_S_UNAVAILABLE;\n    maj = krb5_gss_export_sec_context(minor_status, &ctx->gssc,\n                                      interprocess_token);\n    if (ctx->gssc == GSS_C_NO_CONTEXT) {\n        iakerb_release_context(ctx);\n        *context_handle = GSS_C_NO_CONTEXT;\n    }\n    return maj;\n}", "target": 0}
{"code": " */\nint re_yyget_column  (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n        if (! YY_CURRENT_BUFFER)\n            return 0;\n    return yycolumn;", "target": 1}
{"code": "GF_Err gf_isom_use_compact_size(GF_ISOFile *movie, u32 trackNumber, Bool CompactionOn)\n{\n\tGF_TrackBox *trak;\n\tu32 i, size;\n\tGF_SampleSizeBox *stsz;\n\tGF_Err e;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media || !trak->Media->information\n\t        || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleSize)\n\t\treturn GF_ISOM_INVALID_FILE;\n\tstsz = trak->Media->information->sampleTable->SampleSize;\n\tif (!CompactionOn) {\n\t\tif (stsz->type == GF_ISOM_BOX_TYPE_STSZ) return GF_OK;\n\t\tstsz->type = GF_ISOM_BOX_TYPE_STSZ;\n\t\tstsz->sampleSize = 0;\n\t\tif (!stsz->sampleCount) return GF_OK;\n\t\tif (!stsz->sizes) return GF_OK;\n\t\tsize = stsz->sizes[0];\n\t\tfor (i=1; i<stsz->sampleCount; i++) {\n\t\t\tif (size != stsz->sizes[i]) {\n\t\t\t\tsize = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (size) {\n\t\t\tgf_free(stsz->sizes);\n\t\t\tstsz->sizes = NULL;\n\t\t\tstsz->sampleSize = size;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (stsz->type == GF_ISOM_BOX_TYPE_STZ2) return GF_OK;\n\tif (stsz->sampleSize) {\n\t\tif (stsz->sizes) gf_free(stsz->sizes);\n\t\tstsz->sizes = (u32*) gf_malloc(sizeof(u32)*stsz->sampleCount);\n\t\tif (!stsz->sizes) return GF_OUT_OF_MEM;\n\t\tmemset(stsz->sizes, stsz->sampleSize, sizeof(u32));\n\t}\n\tstsz->sampleSize = 0;\n\tstsz->type = GF_ISOM_BOX_TYPE_STZ2;\n\treturn GF_OK;\n}", "target": 1}
{"code": "create_spnego_ctx(void)\n{\n\tspnego_gss_ctx_id_t spnego_ctx = NULL;\n\tspnego_ctx = (spnego_gss_ctx_id_t)\n\t\tmalloc(sizeof (spnego_gss_ctx_id_rec));\n\tif (spnego_ctx == NULL) {\n\t\treturn (NULL);\n\t}\n\tspnego_ctx->magic_num = SPNEGO_MAGIC_ID;\n\tspnego_ctx->ctx_handle = GSS_C_NO_CONTEXT;\n\tspnego_ctx->mech_set = NULL;\n\tspnego_ctx->internal_mech = NULL;\n\tspnego_ctx->optionStr = NULL;\n\tspnego_ctx->DER_mechTypes.length = 0;\n\tspnego_ctx->DER_mechTypes.value = NULL;\n\tspnego_ctx->default_cred = GSS_C_NO_CREDENTIAL;\n\tspnego_ctx->mic_reqd = 0;\n\tspnego_ctx->mic_sent = 0;\n\tspnego_ctx->mic_rcvd = 0;\n\tspnego_ctx->mech_complete = 0;\n\tspnego_ctx->nego_done = 0;\n\tspnego_ctx->internal_name = GSS_C_NO_NAME;\n\tspnego_ctx->actual_mech = GSS_C_NO_OID;\n\tcheck_spnego_options(spnego_ctx);\n\treturn (spnego_ctx);\n}", "target": 1}
{"code": "static void seek_floppy(void)\n{\n\tint track;\n\tblind_seek = 0;\n\tdebug_dcl(DP->flags, \"calling disk change from %s\\n\", __func__);\n\tif (!test_bit(FD_DISK_NEWCHANGE_BIT, &DRS->flags) &&\n\t    disk_change(current_drive) && (raw_cmd->flags & FD_RAW_NEED_DISK)) {\n\t\tset_bit(FD_DISK_CHANGED_BIT, &DRS->flags);\n\t\tcont->done(0);\n\t\tcont->redo();\n\t\treturn;\n\t}\n\tif (DRS->track <= NEED_1_RECAL) {\n\t\trecalibrate_floppy();\n\t\treturn;\n\t} else if (test_bit(FD_DISK_NEWCHANGE_BIT, &DRS->flags) &&\n\t\t   (raw_cmd->flags & FD_RAW_NEED_DISK) &&\n\t\t   (DRS->track <= NO_TRACK || DRS->track == raw_cmd->track)) {\n\t\tif (raw_cmd->track)\n\t\t\ttrack = raw_cmd->track - 1;\n\t\telse {\n\t\t\tif (DP->flags & FD_SILENT_DCL_CLEAR) {\n\t\t\t\tset_dor(fdc, ~(0x10 << UNIT(current_drive)), 0);\n\t\t\t\tblind_seek = 1;\n\t\t\t\traw_cmd->flags |= FD_RAW_NEED_SEEK;\n\t\t\t}\n\t\t\ttrack = 1;\n\t\t}\n\t} else {\n\t\tcheck_wp();\n\t\tif (raw_cmd->track != DRS->track &&\n\t\t    (raw_cmd->flags & FD_RAW_NEED_SEEK))\n\t\t\ttrack = raw_cmd->track;\n\t\telse {\n\t\t\tsetup_rw_floppy();\n\t\t\treturn;\n\t\t}\n\t}\n\tdo_floppy = seek_interrupt;\n\toutput_byte(FD_SEEK);\n\toutput_byte(UNIT(current_drive));\n\tif (output_byte(track) < 0) {\n\t\treset_fdc();\n\t\treturn;\n\t}\n\tdebugt(__func__, \"\");\n}", "target": 0}
{"code": "static int rm_rf_children_inner(\n                int fd,\n                const char *fname,\n                int is_dir,\n                RemoveFlags flags,\n                const struct stat *root_dev) {\n        struct stat st;\n        int r, q = 0;\n        assert(fd >= 0);\n        assert(fname);\n        if (is_dir < 0 ||\n            root_dev ||\n            (is_dir > 0 && (root_dev || (flags & REMOVE_SUBVOLUME)))) {\n                r = fstatat_harder(fd, fname, &st, AT_SYMLINK_NOFOLLOW, flags);\n                if (r < 0)\n                        return r;\n                is_dir = S_ISDIR(st.st_mode);\n        }\n        if (is_dir) {\n                _cleanup_close_ int subdir_fd = -1;\n                if (root_dev && st.st_dev != root_dev->st_dev)\n                        return 0;\n                r = fd_is_mount_point(fd, fname, 0);\n                if (r < 0)\n                        return r;\n                if (r > 0)\n                        return 0;\n                if ((flags & REMOVE_SUBVOLUME) && btrfs_might_be_subvol(&st)) {\n                        r = btrfs_subvol_remove_fd(fd, fname, BTRFS_REMOVE_RECURSIVE|BTRFS_REMOVE_QUOTA);\n                        if (r < 0) {\n                                if (!IN_SET(r, -ENOTTY, -EINVAL))\n                                        return r;\n                        } else\n                                return 1;\n                }\n                subdir_fd = openat(fd, fname, O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);\n                if (subdir_fd < 0)\n                        return -errno;\n                q = rm_rf_children(TAKE_FD(subdir_fd), flags | REMOVE_PHYSICAL, root_dev);\n        } else if (flags & REMOVE_ONLY_DIRECTORIES)\n                return 0;\n        r = unlinkat_harder(fd, fname, is_dir ? AT_REMOVEDIR : 0, flags);\n        if (r < 0)\n                return r;\n        if (q < 0)\n                return q;\n        return 1;\n}", "target": 1}
{"code": "mlx5_fw_fatal_reporter_dump(struct devlink_health_reporter *reporter,\n\t\t\t    struct devlink_fmsg *fmsg, void *priv_ctx)\n{\n\tstruct mlx5_core_dev *dev = devlink_health_reporter_priv(reporter);\n\tu32 crdump_size = dev->priv.health.crdump_size;\n\tu32 *cr_data;\n\tu32 data_size;\n\tu32 offset;\n\tint err;\n\tif (!mlx5_core_is_pf(dev))\n\t\treturn -EPERM;\n\tcr_data = kvmalloc(crdump_size, GFP_KERNEL);\n\tif (!cr_data)\n\t\treturn -ENOMEM;\n\terr = mlx5_crdump_collect(dev, cr_data);\n\tif (err)\n\t\treturn err;\n\tif (priv_ctx) {\n\t\tstruct mlx5_fw_reporter_ctx *fw_reporter_ctx = priv_ctx;\n\t\terr = mlx5_fw_reporter_ctx_pairs_put(fmsg, fw_reporter_ctx);\n\t\tif (err)\n\t\t\tgoto free_data;\n\t}\n\terr = devlink_fmsg_arr_pair_nest_start(fmsg, \"crdump_data\");\n\tif (err)\n\t\tgoto free_data;\n\tfor (offset = 0; offset < crdump_size; offset += data_size) {\n\t\tif (crdump_size - offset < MLX5_CR_DUMP_CHUNK_SIZE)\n\t\t\tdata_size = crdump_size - offset;\n\t\telse\n\t\t\tdata_size = MLX5_CR_DUMP_CHUNK_SIZE;\n\t\terr = devlink_fmsg_binary_put(fmsg, (char *)cr_data + offset,\n\t\t\t\t\t      data_size);\n\t\tif (err)\n\t\t\tgoto free_data;\n\t}\n\terr = devlink_fmsg_arr_pair_nest_end(fmsg);\nfree_data:\n\tkvfree(cr_data);\n\treturn err;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const Tensor& filter = context->input(1);\n    const Tensor& out_backprop = context->input(2);\n    int stride_rows = 0, stride_cols = 0;\n    int rate_rows = 0, rate_cols = 0;\n    int64 pad_top = 0, pad_left = 0;\n    int64 out_rows = 0, out_cols = 0;\n    ParseSizes(context, strides_, rates_, padding_, &stride_rows, &stride_cols,\n               &rate_rows, &rate_cols, &pad_top, &pad_left, &out_rows,\n               &out_cols);\n    if (!context->status().ok()) return;\n    const int batch = input.dim_size(0);\n    const int depth = input.dim_size(3);\n    OP_REQUIRES(context,\n                batch == out_backprop.dim_size(0) &&\n                    out_rows == out_backprop.dim_size(1) &&\n                    out_cols == out_backprop.dim_size(2) &&\n                    depth == out_backprop.dim_size(3),\n                errors::InvalidArgument(\"out_backprop has incompatible size.\"));\n    Tensor* filter_backprop = nullptr;\n    OP_REQUIRES_OK(\n        context, context->allocate_output(0, filter.shape(), &filter_backprop));\n    if (filter.shape().num_elements() == 0) {\n      return;\n    }\n    functor::DilationBackpropFilter<Device, T>()(\n        context->eigen_device<Device>(), input.tensor<T, 4>(),\n        filter.tensor<T, 3>(), out_backprop.tensor<T, 4>(), stride_rows,\n        stride_cols, rate_rows, rate_cols, pad_top, pad_left,\n        filter_backprop->tensor<T, 3>());\n  }", "target": 0}
{"code": "static int crypto_blkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_blkcipher rblkcipher;\n\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"blkcipher\");\n\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \"%s\",\n\t\t alg->cra_blkcipher.geniv ?: \"<default>\");\n\trblkcipher.blocksize = alg->cra_blocksize;\n\trblkcipher.min_keysize = alg->cra_blkcipher.min_keysize;\n\trblkcipher.max_keysize = alg->cra_blkcipher.max_keysize;\n\trblkcipher.ivsize = alg->cra_blkcipher.ivsize;\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,\n\t\t    sizeof(struct crypto_report_blkcipher), &rblkcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "void FoFiTrueType::cvtEncoding(char **encoding,\n\t\t\t       FoFiOutputFunc outputFunc,\n\t\t\t       void *outputStream) {\n  const char *name;\n  GooString *buf;\n  int i;\n  (*outputFunc)(outputStream, \"/Encoding 256 array\\n\", 20);\n  if (encoding) {\n    for (i = 0; i < 256; ++i) {\n      if (!(name = encoding[i])) {\n\tname = \".notdef\";\n      }\n      buf = GooString::format(\"dup {0:d} /\", i);\n      (*outputFunc)(outputStream, buf->getCString(), buf->getLength());\n      delete buf;\n      (*outputFunc)(outputStream, name, strlen(name));\n      (*outputFunc)(outputStream, \" put\\n\", 5);\n    }\n  } else {\n    for (i = 0; i < 256; ++i) {\n      buf = GooString::format(\"dup {0:d} /c{1:02x} put\\n\", i, i);\n      (*outputFunc)(outputStream, buf->getCString(), buf->getLength());\n      delete buf;\n    }\n  }\n  (*outputFunc)(outputStream, \"readonly def\\n\", 13);\n}", "target": 0}
{"code": "void ParamTraits<NullableString16>::Log(const param_type& p, std::string* l) {\n  l->append(\"(\");\n  LogParam(p.string(), l);\n  l->append(\", \");\n  LogParam(p.is_null(), l);\n  l->append(\")\");\n}", "target": 0}
{"code": "enum ImapAuthRes imap_auth_cram_md5(struct ImapData *idata, const char *method)\n{\n  char ibuf[LONG_STRING * 2], obuf[LONG_STRING];\n  unsigned char hmac_response[MD5_DIGEST_LEN];\n  int len;\n  int rc;\n  if (!mutt_bit_isset(idata->capabilities, ACRAM_MD5))\n    return IMAP_AUTH_UNAVAIL;\n  mutt_message(_(\"Authenticating (CRAM-MD5)...\"));\n  if (mutt_account_getlogin(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n  if (mutt_account_getpass(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n  imap_cmd_start(idata, \"AUTHENTICATE CRAM-MD5\");\n  do\n    rc = imap_cmd_step(idata);\n  while (rc == IMAP_CMD_CONTINUE);\n  if (rc != IMAP_CMD_RESPOND)\n  {\n    mutt_debug(1, \"Invalid response from server: %s\\n\", ibuf);\n    goto bail;\n  }\n  len = mutt_b64_decode(obuf, idata->buf + 2);\n  if (len == -1)\n  {\n    mutt_debug(1, \"Error decoding base64 response.\\n\");\n    goto bail;\n  }\n  obuf[len] = '\\0';\n  mutt_debug(2, \"CRAM challenge: %s\\n\", obuf);\n  hmac_md5(idata->conn->account.pass, obuf, hmac_response);\n  int off = snprintf(obuf, sizeof(obuf), \"%s \", idata->conn->account.user);\n  mutt_md5_toascii(hmac_response, obuf + off);\n  mutt_debug(2, \"CRAM response: %s\\n\", obuf);\n  mutt_b64_encode(ibuf, obuf, strlen(obuf), sizeof(ibuf) - 2);\n  mutt_str_strcat(ibuf, sizeof(ibuf), \"\\r\\n\");\n  mutt_socket_send(idata->conn, ibuf);\n  do\n    rc = imap_cmd_step(idata);\n  while (rc == IMAP_CMD_CONTINUE);\n  if (rc != IMAP_CMD_OK)\n  {\n    mutt_debug(1, \"Error receiving server response.\\n\");\n    goto bail;\n  }\n  if (imap_code(idata->buf))\n    return IMAP_AUTH_SUCCESS;\nbail:\n  mutt_error(_(\"CRAM-MD5 authentication failed.\"));\n  return IMAP_AUTH_FAILURE;\n}", "target": 1}
{"code": "int dsOpen(void) {\n    struct stat sb;\n    int retval;\n    char *path = server.diskstore_path;\n    if ((retval = stat(path,&sb) == -1) && errno != ENOENT) {\n        redisLog(REDIS_WARNING, \"Error opening disk store at %s: %s\",\n                path, strerror(errno));\n        return REDIS_ERR;\n    }\n    if (retval == 0 && S_ISDIR(sb.st_mode)) return REDIS_OK;\n    if (retval == 0 && !S_ISDIR(sb.st_mode)) {\n        redisLog(REDIS_WARNING,\"Disk store at %s is not a directory\", path);\n        return REDIS_ERR;\n    }\n    if (mkdir(path) == -1) {\n        redisLog(REDIS_WARNING,\"Disk store init failed creating dir %s: %s\",\n            path, strerror(errno));\n        return REDIS_ERR;\n    }\n    return REDIS_OK;\n}", "target": 1}
{"code": "void TestJlCompress::extractDir()\n{\n    QFETCH(QString, zipName);\n    QFETCH(QStringList, fileNames);\n    QDir curDir;\n    if (!curDir.mkpath(\"jlext/jldir\")) {\n        QFAIL(\"Couldn't mkpath jlext/jldir\");\n    }\n    if (!createTestFiles(fileNames)) {\n        QFAIL(\"Couldn't create test files\");\n    }\n    if (!createTestArchive(zipName, fileNames)) {\n        QFAIL(\"Couldn't create test archive\");\n    }\n    QStringList extracted;\n    QCOMPARE((extracted = JlCompress::extractDir(zipName, \"jlext/jldir\"))\n        .count(), fileNames.count());\n    foreach (QString fileName, fileNames) {\n        QString fullName = \"jlext/jldir/\" + fileName;\n        QFileInfo fileInfo(fullName);\n        QFileInfo extInfo(\"tmp/\" + fileName);\n        if (!fileInfo.isDir())\n            QCOMPARE(fileInfo.size(), extInfo.size());\n        QCOMPARE(fileInfo.permissions(), extInfo.permissions());\n        curDir.remove(fullName);\n        curDir.rmpath(fileInfo.dir().path());\n        QString absolutePath = fileInfo.absoluteFilePath();\n        if (fileInfo.isDir() && !absolutePath.endsWith('/'))\n\t    absolutePath += '/';\n        QVERIFY(extracted.contains(absolutePath));\n    }\n    QFile zipFile(zipName);\n    QVERIFY(zipFile.open(QIODevice::ReadOnly));\n    QCOMPARE((extracted = JlCompress::extractDir(&zipFile, \"jlext/jldir\"))\n        .count(), fileNames.count());\n    foreach (QString fileName, fileNames) {\n        QString fullName = \"jlext/jldir/\" + fileName;\n        QFileInfo fileInfo(fullName);\n        QFileInfo extInfo(\"tmp/\" + fileName);\n        if (!fileInfo.isDir())\n            QCOMPARE(fileInfo.size(), extInfo.size());\n        QCOMPARE(fileInfo.permissions(), extInfo.permissions());\n        curDir.remove(fullName);\n        curDir.rmpath(fileInfo.dir().path());\n        QString absolutePath = fileInfo.absoluteFilePath();\n        if (fileInfo.isDir() && !absolutePath.endsWith('/'))\n        absolutePath += '/';\n        QVERIFY(extracted.contains(absolutePath));\n    }\n    zipFile.close();\n    curDir.rmpath(\"jlext/jldir\");\n    removeTestFiles(fileNames);\n    curDir.remove(zipName);\n}", "target": 1}
{"code": "uint64_t countBytesForTest(const HeaderMapImpl& headers) {\n  uint64_t byte_size = 0;\n  headers.iterate(\n      [](const Http::HeaderEntry& header, void* context) -> Http::HeaderMap::Iterate {\n        auto* byte_size = static_cast<uint64_t*>(context);\n        *byte_size += header.key().getStringView().size() + header.value().getStringView().size();\n        return Http::HeaderMap::Iterate::Continue;\n      },\n      &byte_size);\n  return byte_size;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    OpInputList ragged_nested_splits_in;\n    OP_REQUIRES_OK(context, context->input_list(\"rt_nested_splits\",\n                                                &ragged_nested_splits_in));\n    const int ragged_nested_splits_len = ragged_nested_splits_in.size();\n    RaggedTensorVariant batched_ragged_input;\n    batched_ragged_input.set_values(context->input(ragged_nested_splits_len));\n    batched_ragged_input.mutable_nested_splits()->reserve(\n        ragged_nested_splits_len);\n    for (int i = 0; i < ragged_nested_splits_len; i++) {\n      OP_REQUIRES(context, ragged_nested_splits_in[i].dims() == 1,\n                  errors::InvalidArgument(\"Requires nested_row_splits[\", i, \"]\",\n                                          \" to be rank 1 but is rank \",\n                                          ragged_nested_splits_in[i].dims()));\n      batched_ragged_input.append_splits(ragged_nested_splits_in[i]);\n    }\n    if (!batched_input_) {\n      Tensor* encoded_scalar;\n      OP_REQUIRES_OK(context, context->allocate_output(0, TensorShape({}),\n                                                       &encoded_scalar));\n      encoded_scalar->scalar<Variant>()() = std::move(batched_ragged_input);\n      return;\n    }\n    std::vector<RaggedTensorVariant> unbatched_ragged_input;\n    OP_REQUIRES_OK(context, UnbatchRaggedZerothDim<VALUE_TYPE, SPLIT_TYPE>(\n                                batched_ragged_input, &unbatched_ragged_input));\n    Tensor* encoded_vector;\n    int64_t output_size = unbatched_ragged_input.size();\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, TensorShape({output_size}),\n                                            &encoded_vector));\n    auto encoded_vector_t = encoded_vector->vec<Variant>();\n    for (auto i = decltype(output_size){}; i < output_size; i++) {\n      encoded_vector_t(i) = unbatched_ragged_input[i];\n    }\n  }", "target": 0}
{"code": "void __init files_init(unsigned long mempages)\n{ \n\tunsigned long n;\n\tfilp_cachep = kmem_cache_create(\"filp\", sizeof(struct file), 0,\n\t\t\tSLAB_HWCACHE_ALIGN | SLAB_PANIC, NULL);\n\tn = (mempages * (PAGE_SIZE / 1024)) / 10;\n\tfiles_stat.max_files = max_t(unsigned long, n, NR_FILE);\n\tfiles_defer_init();\n\tlg_lock_init(&files_lglock, \"files_lglock\");\n\tpercpu_counter_init(&nr_files, 0);\n} ", "target": 1}
{"code": "BOOL rdp_decrypt(rdpRdp* rdp, STREAM* s, int length, UINT16 securityFlags)\n{\n\tBYTE cmac[8];\n\tBYTE wmac[8];\n\tif (rdp->settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS)\n\t{\n\t\tUINT16 len;\n\t\tBYTE version, pad;\n\t\tBYTE* sig;\n\t\tif (stream_get_left(s) < 12)\n\t\t\treturn FALSE;\n\t\tstream_read_UINT16(s, len); \n\t\tstream_read_BYTE(s, version); \n\t\tstream_read_BYTE(s, pad);\n\t\tsig = s->p;\n\t\tstream_seek(s, 8);\t\n\t\tlength -= 12;\n\t\tif (!security_fips_decrypt(s->p, length, rdp))\n\t\t{\n\t\t\tprintf(\"FATAL: cannot decrypt\\n\");\n\t\t\treturn FALSE; \n\t\t}\n\t\tif (!security_fips_check_signature(s->p, length - pad, sig, rdp))\n\t\t{\n\t\t\tprintf(\"FATAL: invalid packet signature\\n\");\n\t\t\treturn FALSE; \n\t\t}\n\t\ts->size -= pad;\n\t\treturn TRUE;\n\t}\n\tif (stream_get_left(s) < 8)\n\t\treturn FALSE;\n\tstream_read(s, wmac, sizeof(wmac));\n\tlength -= sizeof(wmac);\n\tsecurity_decrypt(s->p, length, rdp);\n\tif (securityFlags & SEC_SECURE_CHECKSUM)\n\t\tsecurity_salted_mac_signature(rdp, s->p, length, FALSE, cmac);\n\telse\n\t\tsecurity_mac_signature(rdp, s->p, length, cmac);\n\tif (memcmp(wmac, cmac, sizeof(wmac)) != 0)\n\t{\n\t\tprintf(\"WARNING: invalid packet signature\\n\");\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "static int _nfs4_do_open_reclaim(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs_delegation *delegation;\n\tstruct nfs4_opendata *opendata;\n\tint delegation_type = 0;\n\tint status;\n\topendata = nfs4_open_recoverdata_alloc(ctx, state);\n\tif (IS_ERR(opendata))\n\t\treturn PTR_ERR(opendata);\n\topendata->o_arg.claim = NFS4_OPEN_CLAIM_PREVIOUS;\n\topendata->o_arg.fh = NFS_FH(state->inode);\n\trcu_read_lock();\n\tdelegation = rcu_dereference(NFS_I(state->inode)->delegation);\n\tif (delegation != NULL && test_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags) != 0)\n\t\tdelegation_type = delegation->type;\n\trcu_read_unlock();\n\topendata->o_arg.u.delegation_type = delegation_type;\n\tstatus = nfs4_open_recover(opendata, state);\n\tnfs4_opendata_put(opendata);\n\treturn status;\n}", "target": 1}
{"code": "std::string Utf16To8(const std::wstring& utf16_string) {\n  return WC2MB(utf16_string, CP_UTF8);\n}", "target": 0}
{"code": "\t\tDeleteRunner(ReferenceHandle& that, Local<Value> key_handle) :\n\t\t\t\tkey{ExternalCopy::CopyIfPrimitive(key_handle)},\n\t\t\t\tcontext{that.context},\n\t\t\t\treference{that.reference} {\n\t\t\tthat.CheckDisposed();\n\t\t\tif (!key) {\n\t\t\t\tthrow RuntimeTypeError(\"Invalid `key`\");\n\t\t\t}\n\t\t}", "target": 1}
{"code": "void mpz_as_bytes(const mpz_t *z, bool big_endian, size_t len, byte *buf) {\n    byte *b = buf;\n    if (big_endian) {\n        b += len;\n    }\n    mpz_dig_t *zdig = z->dig;\n    int bits = 0;\n    mpz_dbl_dig_t d = 0;\n    mpz_dbl_dig_t carry = 1;\n    for (size_t zlen = z->len; zlen > 0; --zlen) {\n        bits += DIG_SIZE;\n        d = (d << DIG_SIZE) | *zdig++;\n        for (; bits >= 8; bits -= 8, d >>= 8) {\n            mpz_dig_t val = d;\n            if (z->neg) {\n                val = (~val & 0xff) + carry;\n                carry = val >> 8;\n            }\n            if (big_endian) {\n                *--b = val;\n                if (b == buf) {\n                    return;\n                }\n            } else {\n                *b++ = val;\n                if (b == buf + len) {\n                    return;\n                }\n            }\n        }\n    }\n    if (big_endian) {\n        len = b - buf;\n    } else {\n        len = buf + len - b;\n        buf = b;\n    }\n    memset(buf, z->neg ? 0xff : 0x00, len);\n}", "target": 1}
{"code": "static int encode_open_downgrade(struct xdr_stream *xdr, const struct nfs_closeargs *arg)\n{\n\t__be32 *p;\n\tRESERVE_SPACE(4+NFS4_STATEID_SIZE+4);\n\tWRITE32(OP_OPEN_DOWNGRADE);\n\tWRITEMEM(arg->stateid->data, NFS4_STATEID_SIZE);\n\tWRITE32(arg->seqid->sequence->counter);\n\tencode_share_access(xdr, arg->open_flags);\n\treturn 0;\n}", "target": 1}
{"code": "static int delete_path(const char *dump_dir_name)\n{\n    if (!dir_is_in_dump_location(dump_dir_name))\n    {\n        error_msg(\"Bad problem directory name '%s', should start with: '%s'\", dump_dir_name, g_settings_dump_location);\n        return 400; \n    }\n    if (!dir_has_correct_permissions(dump_dir_name))\n    {\n        error_msg(\"Problem directory '%s' isn't owned by root:abrt or others are not restricted from access\", dump_dir_name);\n        return 400; \n    }\n    if (!dump_dir_accessible_by_uid(dump_dir_name, client_uid))\n    {\n        if (errno == ENOTDIR)\n        {\n            error_msg(\"Path '%s' isn't problem directory\", dump_dir_name);\n            return 404; \n        }\n        error_msg(\"Problem directory '%s' can't be accessed by user with uid %ld\", dump_dir_name, (long)client_uid);\n        return 403; \n    }\n    delete_dump_dir(dump_dir_name);\n    return 0; \n}", "target": 0}
{"code": "static inline void ext4_truncate_failed_write(struct inode *inode)\n{\n\tdown_write(&EXT4_I(inode)->i_mmap_sem);\n\ttruncate_inode_pages(inode->i_mapping, inode->i_size);\n\text4_truncate(inode);\n\tup_write(&EXT4_I(inode)->i_mmap_sem);\n}", "target": 0}
{"code": "void HTMLTextAreaElement::setMaxLength(int newValue, ExceptionState& exceptionState)\n{\n    if (newValue < 0)\n        exceptionState.throwDOMException(IndexSizeError, \"The value provided (\" + String::number(newValue) + \") is not positive or 0.\");\n    else\n        setIntegralAttribute(maxlengthAttr, newValue);\n}", "target": 0}
{"code": "main(int argc, char* argv[])\n{\n    (void) argc;\n    (void) argv;\n    const struct CMUnitTest tests[] = {\n            cmocka_unit_test(test_layers),\n            cmocka_unit_test(test_tpm_format_0_version2_0_error),\n            cmocka_unit_test(test_tpm_format_0_version2_0_warn),\n            cmocka_unit_test(test_tpm2_format_0_unknown),\n            cmocka_unit_test(test_tpm_format_1_unk_handle),\n            cmocka_unit_test(test_tpm_format_1_unk_parameter),\n            cmocka_unit_test(test_tpm_format_1_unk_session),\n            cmocka_unit_test(test_tpm_format_1_5_handle),\n            cmocka_unit_test(test_tpm2_format_1_unknown),\n            cmocka_unit_test(test_tpm2_format_1_success),\n            cmocka_unit_test(test_custom_handler),\n            cmocka_unit_test(test_zero_length_name),\n            cmocka_unit_test(test_over_length_name),\n            cmocka_unit_test(test_null_name),\n            cmocka_unit_test(test_sys),\n            cmocka_unit_test(test_esys),\n            cmocka_unit_test(test_mu),\n            cmocka_unit_test(test_tcti),\n            cmocka_unit_test(test_info_fmt0),\n            cmocka_unit_test(test_info_fmt1_parameter),\n            cmocka_unit_test(test_info_fmt1_handle),\n            cmocka_unit_test(test_info_fmt1_session),\n            cmocka_unit_test(test_info_null),\n            cmocka_unit_test(test_info_str_fmt1),\n            cmocka_unit_test(test_info_str_fmt1_ff),\n            cmocka_unit_test(test_info_str_fmt0_err),\n            cmocka_unit_test(test_info_str_fmt0_warn),\n            cmocka_unit_test(test_info_str_fmt0_ff),\n            cmocka_unit_test(test_info_str_null),\n            cmocka_unit_test(test_all_FFs),\n            cmocka_unit_test(test_all_FFs_set_handler)\n    };\n    return cmocka_run_group_tests(tests, NULL, NULL);\n}", "target": 0}
{"code": "static void engine_shutdown_handler(void *arg)\n{\n\t(void) arg;\n\tre_printf(\"The engine shutted down.\\n\");\n\tre_cancel();\n}", "target": 0}
{"code": "koi8_r_is_mbc_ambiguous(OnigCaseFoldType flag, const UChar** pp,\n\t\t\tconst UChar* end, OnigEncoding enc ARG_UNUSED)\n{\n  int v;\n  const UChar* p = *pp;\n  (*pp)++;\n  v = (EncKOI8_R_CtypeTable[*p] & (BIT_CTYPE_UPPER | BIT_CTYPE_LOWER));\n  return (v != 0 ? TRUE : FALSE);\n}", "target": 0}
{"code": "CURLcode Curl_auth_create_plain_message(struct Curl_easy *data,\n                                        const char *userp,\n                                        const char *passwdp,\n                                        char **outptr, size_t *outlen)\n{\n  CURLcode result;\n  char *plainauth;\n  size_t ulen;\n  size_t plen;\n  size_t plainlen;\n  *outlen = 0;\n  *outptr = NULL;\n  ulen = strlen(userp);\n  plen = strlen(passwdp);\n  if((ulen > SIZE_T_MAX/2) || (plen > (SIZE_T_MAX/2 - 2)))\n    return CURLE_OUT_OF_MEMORY;\n  plainlen = 2 * ulen + plen + 2;\n  plainauth = malloc(plainlen);\n  if(!plainauth)\n    return CURLE_OUT_OF_MEMORY;\n  memcpy(plainauth, userp, ulen);\n  plainauth[ulen] = '\\0';\n  memcpy(plainauth + ulen + 1, userp, ulen);\n  plainauth[2 * ulen + 1] = '\\0';\n  memcpy(plainauth + 2 * ulen + 2, passwdp, plen);\n  result = Curl_base64_encode(data, plainauth, plainlen, outptr, outlen);\n  free(plainauth);\n  return result;\n}", "target": 1}
{"code": "gx_dc_pattern2_clip_with_bbox_simple(const gx_device_color * pdevc, gx_device * pdev,\n                              gx_clip_path *cpath_local)\n{\n    int code = 0;\n    if (gx_dc_is_pattern2_color(pdevc) && gx_dc_pattern2_color_has_bbox(pdevc) &&\n            (*dev_proc(pdev, dev_spec_op))(pdev, gxdso_pattern_shading_area, NULL, 0) == 0) {\n        gs_pattern2_instance_t *pinst = (gs_pattern2_instance_t *)pdevc->ccolor.pattern;\n        gx_path box_path;\n        gs_memory_t *mem = cpath_local->path.memory;\n        gx_path_init_local(&box_path, mem);\n        code = gx_dc_shading_path_add_box(&box_path, pdevc);\n        if (code == gs_error_limitcheck) {\n            code = 0;\n        } else if (code >= 0) {\n            code = gx_cpath_intersect(cpath_local, &box_path, gx_rule_winding_number, (gs_gstate *)pinst->saved);\n        }\n        gx_path_free(&box_path, \"gx_default_fill_path(path_bbox)\");\n    }\n    return code;\n}", "target": 0}
{"code": "fbFetch_r8g8b8 (const FbBits *bits, int x, int width, CARD32 *buffer, miIndexedPtr indexed)\n{\n    const CARD8 *pixel = (const CARD8 *)bits + 3*x;\n    const CARD8 *end = pixel + 3*width;\n    while (pixel < end) {\n        CARD32 b = Fetch24(pixel) | 0xff000000;\n        pixel += 3;\n        WRITE(buffer++, b);\n    }\n}", "target": 0}
{"code": "void is888Tests()\n{\n    printf(\"Simple format detection:\\n\\n\");\n    do888Test(true, 32, 24, false, true, 255, 255, 255, 0, 8, 16);\n    do888Test(true, 32, 24, false, true, 255, 255, 255, 24, 16, 8);\n    do888Test(true, 32, 24, false, true, 255, 255, 255, 24, 8, 0);\n    do888Test(false, 32, 16, false, true, 15, 31, 15, 0, 8, 16);\n    do888Test(false, 32, 8, false, true, 3, 7, 3, 0, 8, 16);\n    do888Test(false, 16, 16, false, true, 15, 31, 15, 0, 5, 11);\n    do888Test(false, 8, 8, false, true, 3, 7, 3, 0, 2, 5);\n    do888Test(false, 8, 8, false, false, 0, 0, 0, 0, 0, 0);\n    do888Test(false, 32, 24, false, true, 255, 255, 255, 0, 8, 18);\n    do888Test(false, 32, 24, false, true, 255, 255, 255, 0, 11, 24);\n    do888Test(false, 32, 24, false, true, 255, 255, 255, 4, 16, 24);\n    printf(\"\\n\");\n}", "target": 0}
{"code": "LUA_API void lua_upvaluejoin (lua_State *L, int fidx1, int n1,\n                                            int fidx2, int n2) {\n  LClosure *f1;\n  UpVal **up1 = getupvalref(L, fidx1, n1, &f1);\n  UpVal **up2 = getupvalref(L, fidx2, n2, NULL);\n  luaC_upvdeccount(L, *up1);\n  *up1 = *up2;\n  (*up1)->refcount++;\n  if (upisopen(*up1)) (*up1)->u.open.touched = 1;\n  luaC_upvalbarrier(L, *up1);\n}", "target": 1}
{"code": "void ciEnv::report_failure(const char* reason) {\n  EventCompilationFailure event;\n  if (event.should_commit()) {\n    CompilerEvent::CompilationFailureEvent::post(event, compile_id(), reason);\n  }\n}", "target": 0}
{"code": "static inline int unicode_cp_is_allowed(unsigned uni_cp, int document_type)\n{\n\tswitch (document_type) {\n\tcase ENT_HTML_DOC_HTML401:\n\t\treturn (uni_cp >= 0x20 && uni_cp <= 0x7E) ||\n\t\t\t(uni_cp == 0x0A || uni_cp == 0x09 || uni_cp == 0x0D) ||\n\t\t\t(uni_cp >= 0xA0 && uni_cp <= 0xD7FF) ||\n\t\t\t(uni_cp >= 0xE000 && uni_cp <= 0x10FFFF);\n\tcase ENT_HTML_DOC_HTML5:\n\t\treturn (uni_cp >= 0x20 && uni_cp <= 0x7E) ||\n\t\t\t(uni_cp >= 0x09 && uni_cp <= 0x0D && uni_cp != 0x0B) || \n\t\t\t(uni_cp >= 0xA0 && uni_cp <= 0xD7FF) ||\n\t\t\t(uni_cp >= 0xE000 && uni_cp <= 0x10FFFF &&\n\t\t\t\t((uni_cp & 0xFFFF) < 0xFFFE) && \n\t\t\t\t(uni_cp < 0xFDD0 || uni_cp > 0xFDEF)); \n\tcase ENT_HTML_DOC_XHTML:\n\tcase ENT_HTML_DOC_XML1:\n\t\treturn (uni_cp >= 0x20 && uni_cp <= 0xD7FF) ||\n\t\t\t(uni_cp == 0x0A || uni_cp == 0x09 || uni_cp == 0x0D) ||\n\t\t\t(uni_cp >= 0xE000 && uni_cp <= 0x10FFFF && uni_cp != 0xFFFE && uni_cp != 0xFFFF);\n\tdefault:\n\t\treturn 1;\n\t}\n}", "target": 1}
{"code": "        int          GetS32BE (int nPos, bool *pbSuccess)\n        {\n            if ( nPos < 0 || nPos + 3 >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            int nRes = m_sFile[ nPos ];\n            nRes = (nRes << 8) + m_sFile[nPos + 1];\n            nRes = (nRes << 8) + m_sFile[nPos + 2];\n            nRes = (nRes << 8) + m_sFile[nPos + 3];\n            if ( nRes & 0x80000000 )\n                nRes |= ~0xffffffff;\n            return nRes;\n        }", "target": 1}
{"code": "void init_tls_dissector(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\tu_int32_t *id, NDPI_PROTOCOL_BITMASK *detection_bitmask) {\n  ndpi_set_bitmask_protocol_detection(\"TLS\", ndpi_struct, detection_bitmask, *id,\n\t\t\t\t      NDPI_PROTOCOL_TLS,\n\t\t\t\t      ndpi_search_tls_wrapper,\n\t\t\t\t      NDPI_SELECTION_BITMASK_PROTOCOL_V4_V6_TCP_WITH_PAYLOAD_WITHOUT_RETRANSMISSION,\n\t\t\t\t      SAVE_DETECTION_BITMASK_AS_UNKNOWN,\n\t\t\t\t      ADD_TO_DETECTION_BITMASK);\n  *id += 1;\n  ndpi_set_bitmask_protocol_detection(\"TLS\", ndpi_struct, detection_bitmask, *id,\n\t\t\t\t      NDPI_PROTOCOL_TLS,\n\t\t\t\t      ndpi_search_tls_wrapper,\n\t\t\t\t      NDPI_SELECTION_BITMASK_PROTOCOL_V4_V6_UDP_WITH_PAYLOAD,\n\t\t\t\t      SAVE_DETECTION_BITMASK_AS_UNKNOWN,\n\t\t\t\t      ADD_TO_DETECTION_BITMASK);\n  *id += 1;\n}", "target": 0}
{"code": "nvkm_vmm_node_delete(struct nvkm_vmm *vmm, struct nvkm_vma *vma)\n{\n\tnvkm_vmm_node_remove(vmm, vma);\n\tlist_del(&vma->head);\n\tkfree(vma);\n}", "target": 0}
{"code": "static int translate_desc(struct vhost_dev *dev, u64 addr, u32 len,\n\t\t\t  struct iovec iov[], int iov_size)\n{\n\tconst struct vhost_memory_region *reg;\n\tstruct vhost_memory *mem;\n\tstruct iovec *_iov;\n\tu64 s = 0;\n\tint ret = 0;\n\trcu_read_lock();\n\tmem = rcu_dereference(dev->memory);\n\twhile ((u64)len > s) {\n\t\tu64 size;\n\t\tif (unlikely(ret >= iov_size)) {\n\t\t\tret = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\treg = find_region(mem, addr, len);\n\t\tif (unlikely(!reg)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\t_iov = iov + ret;\n\t\tsize = reg->memory_size - addr + reg->guest_phys_addr;\n\t\t_iov->iov_len = min((u64)len, size);\n\t\t_iov->iov_base = (void __user *)(unsigned long)\n\t\t\t(reg->userspace_addr + addr - reg->guest_phys_addr);\n\t\ts += size;\n\t\taddr += size;\n\t\t++ret;\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}", "target": 1}
{"code": "WifiNetwork::WifiNetwork()\n    : WirelessNetwork(),\n      encryption_(SECURITY_NONE) {\n  type_ = TYPE_WIFI;\n}", "target": 0}
{"code": "int ipmi_si_port_setup(struct si_sm_io *io)\n{\n\tunsigned int addr = io->addr_data;\n\tint          idx;\n\tif (!addr)\n\t\treturn -ENODEV;\n\tio->io_cleanup = port_cleanup;\n\tswitch (io->regsize) {\n\tcase 1:\n\t\tio->inputb = port_inb;\n\t\tio->outputb = port_outb;\n\t\tbreak;\n\tcase 2:\n\t\tio->inputb = port_inw;\n\t\tio->outputb = port_outw;\n\t\tbreak;\n\tcase 4:\n\t\tio->inputb = port_inl;\n\t\tio->outputb = port_outl;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(io->dev, \"Invalid register size: %d\\n\",\n\t\t\t io->regsize);\n\t\treturn -EINVAL;\n\t}\n\tfor (idx = 0; idx < io->io_size; idx++) {\n\t\tif (request_region(addr + idx * io->regspacing,\n\t\t\t\t   io->regsize, DEVICE_NAME) == NULL) {\n\t\t\twhile (idx--)\n\t\t\t\trelease_region(addr + idx * io->regspacing,\n\t\t\t\t\t       io->regsize);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static inline void vm_entry_controls_init(struct vcpu_vmx *vmx, u32 val)\n{\n\tvmcs_write32(VM_ENTRY_CONTROLS, val);\n\tvmx->vm_entry_controls_shadow = val;\n}", "target": 0}
{"code": "int ossl_dsa_check_pub_key_partial(const DSA *dsa, const BIGNUM *pub_key, int *ret)\n{\n    if (!dsa_precheck_params(dsa, ret))\n        return 0;\n    return ossl_ffc_validate_public_key_partial(&dsa->params, pub_key, ret)\n           && *ret == 0;\n}", "target": 0}
{"code": "static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,\n\t\t\t\t   size_t count, loff_t *offset)\n{\n\tstruct snd_timer_user *tu;\n\tlong result = 0, unit;\n\tint qhead;\n\tint err = 0;\n\ttu = file->private_data;\n\tunit = tu->tread ? sizeof(struct snd_timer_tread) : sizeof(struct snd_timer_read);\n\tspin_lock_irq(&tu->qlock);\n\twhile ((long)count - result >= unit) {\n\t\twhile (!tu->qused) {\n\t\t\twait_queue_t wait;\n\t\t\tif ((file->f_flags & O_NONBLOCK) != 0 || result > 0) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tinit_waitqueue_entry(&wait, current);\n\t\t\tadd_wait_queue(&tu->qchange_sleep, &wait);\n\t\t\tspin_unlock_irq(&tu->qlock);\n\t\t\tschedule();\n\t\t\tspin_lock_irq(&tu->qlock);\n\t\t\tremove_wait_queue(&tu->qchange_sleep, &wait);\n\t\t\tif (tu->disconnected) {\n\t\t\t\terr = -ENODEV;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t\tif (signal_pending(current)) {\n\t\t\t\terr = -ERESTARTSYS;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t}\n\t\tqhead = tu->qhead++;\n\t\ttu->qhead %= tu->queue_size;\n\t\ttu->qused--;\n\t\tspin_unlock_irq(&tu->qlock);\n\t\tmutex_lock(&tu->ioctl_lock);\n\t\tif (tu->tread) {\n\t\t\tif (copy_to_user(buffer, &tu->tqueue[qhead],\n\t\t\t\t\t sizeof(struct snd_timer_tread)))\n\t\t\t\terr = -EFAULT;\n\t\t} else {\n\t\t\tif (copy_to_user(buffer, &tu->queue[qhead],\n\t\t\t\t\t sizeof(struct snd_timer_read)))\n\t\t\t\terr = -EFAULT;\n\t\t}\n\t\tmutex_unlock(&tu->ioctl_lock);\n\t\tspin_lock_irq(&tu->qlock);\n\t\tif (err < 0)\n\t\t\tgoto _error;\n\t\tresult += unit;\n\t\tbuffer += unit;\n\t}\n _error:\n\tspin_unlock_irq(&tu->qlock);\n\treturn result > 0 ? result : err;\n}", "target": 1}
{"code": "int nsim_bpf(struct net_device *dev, struct netdev_bpf *bpf)\n{\n\tstruct netdevsim *ns = netdev_priv(dev);\n\tint err;\n\tASSERT_RTNL();\n\tswitch (bpf->command) {\n\tcase XDP_SETUP_PROG:\n\t\terr = nsim_setup_prog_checks(ns, bpf);\n\t\tif (err)\n\t\t\treturn err;\n\t\treturn nsim_xdp_set_prog(ns, bpf, &ns->xdp);\n\tcase XDP_SETUP_PROG_HW:\n\t\terr = nsim_setup_prog_hw_checks(ns, bpf);\n\t\tif (err)\n\t\t\treturn err;\n\t\treturn nsim_xdp_set_prog(ns, bpf, &ns->xdp_hw);\n\tcase BPF_OFFLOAD_MAP_ALLOC:\n\t\tif (!ns->bpf_map_accept)\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn nsim_bpf_map_alloc(ns, bpf->offmap);\n\tcase BPF_OFFLOAD_MAP_FREE:\n\t\tnsim_bpf_map_free(bpf->offmap);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}", "target": 0}
{"code": "  void connectErr(const AsyncSocketException& ex) noexcept override {\n    FAIL() << ex.what();\n  }", "target": 0}
{"code": "void ThreadWatcher::StartWatching(const WatchingParams& params) {\n  DCHECK_GE(params.sleep_time.InMilliseconds(), 0);\n  DCHECK_GE(params.unresponsive_time.InMilliseconds(),\n            params.sleep_time.InMilliseconds());\n  if (!WatchDogThread::CurrentlyOnWatchDogThread()) {\n    WatchDogThread::PostTask(\n        FROM_HERE,\n        base::Bind(&ThreadWatcher::StartWatching, params));\n    return;\n  }\n  DCHECK(WatchDogThread::CurrentlyOnWatchDogThread());\n  ThreadWatcher* watcher = new ThreadWatcher(params);\n  DCHECK(watcher);\n  if (!ThreadWatcherList::IsRegistered(params.thread_id))\n    return;\n  watcher->ActivateThreadWatching();\n}", "target": 0}
{"code": "linux_lvm2_vg_remove_pv_completed_cb (DBusGMethodInvocation *context,\n                                      Device *device,\n                                      gboolean job_was_cancelled,\n                                      int status,\n                                      const char *stderr,\n                                      const char *stdout,\n                                      gpointer user_data)\n{\n  if (WEXITSTATUS (status) == 0 && !job_was_cancelled)\n    {\n      dbus_g_method_return (context);\n    }\n  else\n    {\n      if (job_was_cancelled)\n        {\n          throw_error (context, ERROR_CANCELLED, \"Job was cancelled\");\n        }\n      else\n        {\n          throw_error (context,\n                       ERROR_FAILED,\n                       \"Error removing PV for LVM2 Volume Group: vgreduce exited with exit code %d: %s\",\n                       WEXITSTATUS (status),\n                       stderr);\n        }\n    }\n}", "target": 0}
{"code": "namespace{void nop(){}}", "target": 0}
{"code": "static inline int r_sys_mkdirp(char *dir) {\n\tint ret = 1;\n\tconst char slash = DIRSEP;\n\tchar *path = dir;\n\tchar *ptr = path;\n\tif (*ptr == slash) {\n\t\tptr++;\n\t}\n#if __SDB_WINDOWS__\n\tchar *p = strstr (ptr, \":\\\\\");\n\tif (p) {\n\t\tptr = p + 2;\n\t}\n#endif\n\twhile ((ptr = strchr (ptr, slash))) {\n\t\t*ptr = 0;\n\t\tif (!r_sys_mkdir (path) && r_sys_mkdir_failed ()) {\n\t\t\teprintf (\"r_sys_mkdirp: fail '%s' of '%s'\\n\", path, dir);\n\t\t\t*ptr = slash;\n\t\t\treturn 0;\n\t\t}\n\t\t*ptr = slash;\n\t\tptr++;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "bool SQLiteDatabase::ExecuteCommand(const String& sql) {\n  return SQLiteStatement(*this, sql).ExecuteCommand();\n}", "target": 0}
{"code": "TfLiteStatus PrepareHashtable(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 0);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  TF_LITE_ENSURE(context, node->user_data != nullptr);\n  const auto* params =\n      reinterpret_cast<const TfLiteHashtableParams*>(node->user_data);\n  TF_LITE_ENSURE(context, !params->table_name.empty());\n  TF_LITE_ENSURE(context, (params->key_dtype == kTfLiteInt64 &&\n                           params->value_dtype == kTfLiteString) ||\n                              (params->key_dtype == kTfLiteString &&\n                               params->value_dtype == kTfLiteInt64));\n  TfLiteTensor* resource_handle_tensor =\n      GetOutput(context, node, kResourceHandleTensor);\n  TF_LITE_ENSURE(context, resource_handle_tensor != nullptr);\n  TF_LITE_ENSURE_EQ(context, resource_handle_tensor->type, kTfLiteInt32);\n  TfLiteIntArray* outputSize = TfLiteIntArrayCreate(1);\n  outputSize->data[0] = 1;\n  return context->ResizeTensor(context, resource_handle_tensor, outputSize);\n}", "target": 1}
{"code": "int linenoiseHistorySave(const char* filename) {\n    FILE* fp = fopen(filename, \"wt\");\n    if (fp == NULL) {\n        return -1;\n    }\n    for (int j = 0; j < historyLen; ++j) {\n        if (history[j][0] != '\\0') {\n            fprintf(fp, \"%s\\n\", history[j]);\n        }\n    }\n    fclose(fp);\n    return 0;\n}", "target": 1}
{"code": "char *path_name(const struct name_path *path, const char *name)\n{\n\tconst struct name_path *p;\n\tchar *n, *m;\n\tint nlen = strlen(name);\n\tint len = nlen + 1;\n\tfor (p = path; p; p = p->up) {\n\t\tif (p->elem_len)\n\t\t\tlen += p->elem_len + 1;\n\t}\n\tn = xmalloc(len);\n\tm = n + len - (nlen + 1);\n\tstrcpy(m, name);\n\tfor (p = path; p; p = p->up) {\n\t\tif (p->elem_len) {\n\t\t\tm -= p->elem_len + 1;\n\t\t\tmemcpy(m, p->elem, p->elem_len);\n\t\t\tm[p->elem_len] = '/';\n\t\t}\n\t}\n\treturn n;\n}", "target": 1}
{"code": "static unsigned long kvm_get_tsc_khz(void)\n{\n\tstruct pvclock_vcpu_time_info *src;\n\tsrc = &per_cpu(hv_clock, 0);\n\treturn pvclock_tsc_khz(src);\n}", "target": 0}
{"code": "sigterm_handler(int sig)\t\t\n{\n  (void)sig;\n  fprintf(stderr,\n\t  \"DEBUG: beh: Job canceled.\\n\");\n  if (job_canceled)\n    _exit(CUPS_BACKEND_OK);\n  else\n    job_canceled = 1;\n}", "target": 1}
{"code": "GF_Err gf_isom_set_extraction_slc(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex, const GF_SLConfig *slConfig)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_Err e;\n\tGF_SLConfig **slc;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\te = Media_GetSampleDesc(trak->Media, StreamDescriptionIndex, &entry, NULL);\n\tif (e) return e;\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\tif (((GF_MPEGSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = & ((GF_MPEGSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tif (((GF_MPEGAudioSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = & ((GF_MPEGAudioSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tif (((GF_MPEGVisualSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = & ((GF_MPEGVisualSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\tif (*slc) {\n\t\tgf_odf_desc_del((GF_Descriptor *)*slc);\n\t\t*slc = NULL;\n\t}\n\tif (!slConfig) return GF_OK;\n\treturn gf_odf_desc_copy((GF_Descriptor *) slConfig, (GF_Descriptor **) slc);\n}", "target": 1}
{"code": "lib_contains_symbol(const char *path, const char *s)\n{\n\tstruct nlist nl[2];\n\tint ret = -1, r;\n\tmemset(nl, 0, sizeof(nl));\n\tnl[0].n_name = xstrdup(s);\n\tnl[1].n_name = NULL;\n\tif ((r = nlist(path, nl)) == -1) {\n\t\terror_f(\"nlist failed for %s\", path);\n\t\tgoto out;\n\t}\n\tif (r != 0 || nl[0].n_value == 0 || nl[0].n_type == 0) {\n\t\terror_f(\"library %s does not contain symbol %s\", path, s);\n\t\tgoto out;\n\t}\n\tret = 0;\n out:\n\tfree(nl[0].n_name);\n\treturn ret;\n}", "target": 0}
{"code": "static int ax25_shutdown(struct socket *sk, int how)\n{\n\treturn -EOPNOTSUPP;\n}", "target": 0}
{"code": "void GHASH::key_schedule(std::span<const uint8_t> key) {\n   m_H.assign(key.begin(), key.end());  \n   m_H_ad.resize(GCM_BS);\n   m_ad_len = 0;\n   m_text_len = 0;\n   uint64_t H0 = load_be<uint64_t>(m_H.data(), 0);\n   uint64_t H1 = load_be<uint64_t>(m_H.data(), 1);\n   const uint64_t R = 0xE100000000000000;\n   m_HM.resize(256);\n   for(size_t i = 0; i != 2; ++i) {\n      for(size_t j = 0; j != 64; ++j) {\n         m_HM[4 * j + 2 * i] = H0;\n         m_HM[4 * j + 2 * i + 1] = H1;\n         const uint64_t carry = R * (H1 & 1);\n         H1 = (H1 >> 1) | (H0 << 63);\n         H0 = (H0 >> 1) ^ carry;\n      }\n   }\n#if defined(BOTAN_HAS_GHASH_CLMUL_CPU)\n   if(CPUID::has_carryless_multiply()) {\n      m_H_pow.resize(8);\n      ghash_precompute_cpu(m_H.data(), m_H_pow.data());\n   }\n#endif\n}", "target": 1}
{"code": "ext4_xattr_cache_insert(struct mb_cache *ext4_mb_cache, struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(BHDR(bh)->h_hash);\n\tstruct mb_cache_entry *ce;\n\tint error;\n\tce = mb_cache_entry_alloc(ext4_mb_cache, GFP_NOFS);\n\tif (!ce) {\n\t\tea_bdebug(bh, \"out of memory\");\n\t\treturn;\n\t}\n\terror = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);\n\tif (error) {\n\t\tmb_cache_entry_free(ce);\n\t\tif (error == -EBUSY) {\n\t\t\tea_bdebug(bh, \"already in cache\");\n\t\t\terror = 0;\n\t\t}\n\t} else {\n\t\tea_bdebug(bh, \"inserting [%x]\", (int)hash);\n\t\tmb_cache_entry_release(ce);\n\t}\n}", "target": 1}
{"code": "  StatusOr<std::vector<int64_t>> GetKernelSize(XlaOpKernelContext* ctx) {\n    if (ctx->num_inputs() == 1) {\n      return ksize_;\n    }\n    const TensorShape ksize_shape = ctx->InputShape(1);\n    if (!TensorShapeUtils::IsVector(ksize_shape)) {\n      return errors::InvalidArgument(\"ksize must be a vector, not shape \",\n                                     ksize_shape.DebugString());\n    }\n    if (ksize_shape.num_elements() != num_dims()) {\n      return errors::InvalidArgument(\n          \"Sliding window ksize field must \"\n          \"specify \",\n          num_dims(), \" dimensions\");\n    }\n    std::vector<int64_t> ksize;\n    auto status = ctx->ConstantInputAsIntVector(1, &ksize);\n    if (!status.ok()) {\n      return status;\n    }\n    return ksize;\n  }", "target": 1}
{"code": "compat_mpt_command(struct file *filp, unsigned int cmd,\n\t\t\tunsigned long arg)\n{\n\tstruct mpt_ioctl_command32 karg32;\n\tstruct mpt_ioctl_command32 __user *uarg = (struct mpt_ioctl_command32 __user *) arg;\n\tstruct mpt_ioctl_command karg;\n\tMPT_ADAPTER *iocp = NULL;\n\tint iocnum, iocnumX;\n\tint nonblock = (filp->f_flags & O_NONBLOCK);\n\tint ret;\n\tif (copy_from_user(&karg32, (char __user *)arg, sizeof(karg32)))\n\t\treturn -EFAULT;\n\tiocnumX = karg32.hdr.iocnum & 0xFF;\n\tif (((iocnum = mpt_verify_adapter(iocnumX, &iocp)) < 0) ||\n\t    (iocp == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"::compat_mpt_command @%d - ioc%d not found!\\n\",\n\t\t\t__LINE__, iocnumX);\n\t\treturn -ENODEV;\n\t}\n\tif ((ret = mptctl_syscall_down(iocp, nonblock)) != 0)\n\t\treturn ret;\n\tdctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT \"compat_mpt_command() called\\n\",\n\t    iocp->name));\n\tkarg.hdr.iocnum = karg32.hdr.iocnum;\n\tkarg.hdr.port = karg32.hdr.port;\n\tkarg.timeout = karg32.timeout;\n\tkarg.maxReplyBytes = karg32.maxReplyBytes;\n\tkarg.dataInSize = karg32.dataInSize;\n\tkarg.dataOutSize = karg32.dataOutSize;\n\tkarg.maxSenseBytes = karg32.maxSenseBytes;\n\tkarg.dataSgeOffset = karg32.dataSgeOffset;\n\tkarg.replyFrameBufPtr = (char __user *)(unsigned long)karg32.replyFrameBufPtr;\n\tkarg.dataInBufPtr = (char __user *)(unsigned long)karg32.dataInBufPtr;\n\tkarg.dataOutBufPtr = (char __user *)(unsigned long)karg32.dataOutBufPtr;\n\tkarg.senseDataPtr = (char __user *)(unsigned long)karg32.senseDataPtr;\n\tret = mptctl_do_mpt_command (karg, &uarg->MF);\n\tmutex_unlock(&iocp->ioctl_cmds.mutex);\n\treturn ret;\n}", "target": 1}
{"code": "static void sas_probe_devices(struct work_struct *work)\n{\n\tstruct domain_device *dev, *n;\n\tstruct sas_discovery_event *ev = to_sas_discovery_event(work);\n\tstruct asd_sas_port *port = ev->port;\n\tclear_bit(DISCE_PROBE, &port->disc.pending);\n\tlist_for_each_entry(dev, &port->disco_list, disco_list_node) {\n\t\tspin_lock_irq(&port->dev_list_lock);\n\t\tlist_add_tail(&dev->dev_list_node, &port->dev_list);\n\t\tspin_unlock_irq(&port->dev_list_lock);\n\t}\n\tsas_probe_sata(port);\n\tlist_for_each_entry_safe(dev, n, &port->disco_list, disco_list_node) {\n\t\tint err;\n\t\terr = sas_rphy_add(dev->rphy);\n\t\tif (err)\n\t\t\tsas_fail_probe(dev, __func__, err);\n\t\telse\n\t\t\tlist_del_init(&dev->disco_list_node);\n\t}\n}", "target": 1}
{"code": "static UINT rdpei_recv_pdu(RDPEI_CHANNEL_CALLBACK* callback, wStream* s)\n{\n\tUINT16 eventId;\n\tUINT32 pduLength;\n\tUINT error;\n\tif (Stream_GetRemainingLength(s) < 6)\n\t\treturn ERROR_INVALID_DATA;\n\tStream_Read_UINT16(s, eventId);   \n\tStream_Read_UINT32(s, pduLength); \n#ifdef WITH_DEBUG_RDPEI\n\tWLog_DBG(TAG, \"rdpei_recv_pdu: eventId: %\" PRIu16 \" (%s) length: %\" PRIu32 \"\", eventId,\n\t         rdpei_eventid_string(eventId), pduLength);\n#endif\n\tswitch (eventId)\n\t{\n\t\tcase EVENTID_SC_READY:\n\t\t\tif ((error = rdpei_recv_sc_ready_pdu(callback, s)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_recv_sc_ready_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tif ((error = rdpei_send_cs_ready_pdu(callback)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_send_cs_ready_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EVENTID_SUSPEND_TOUCH:\n\t\t\tif ((error = rdpei_recv_suspend_touch_pdu(callback, s)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_recv_suspend_touch_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EVENTID_RESUME_TOUCH:\n\t\t\tif ((error = rdpei_recv_resume_touch_pdu(callback, s)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_recv_resume_touch_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn CHANNEL_RC_OK;\n}", "target": 0}
{"code": "static int search_old_relocation(struct reloc_struct_t *reloc_table, ut32 addr_to_patch, int n_reloc) {\n\tint i;\n\tfor (i = 0; i < n_reloc; i++) {\n\t\tif (addr_to_patch == reloc_table[i].data_offset) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}", "target": 1}
{"code": "static int __init net_secret_init(void)\n{\n\tget_random_bytes(net_secret, sizeof(net_secret));\n\treturn 0;\n}", "target": 0}
{"code": "    void XmpSidecar::writeMetadata()\n    {\n        if (io_->open() != 0) {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        if (writeXmpFromPacket() == false) {\n            Exiv2::XmpData  copy   ;\n            for (Exiv2::XmpData::const_iterator it = xmpData_.begin(); it != xmpData_.end(); ++it) {\n                if ( !matchi(it->key(),\"exif\") && !matchi(it->key(),\"iptc\") ) {\n                    copy[it->key()] = it->value();\n                }\n            }\n            copyExifToXmp(exifData_, xmpData_);\n            copyIptcToXmp(iptcData_, xmpData_);\n            for (Exiv2::XmpData::const_iterator it = copy.begin(); it != copy.end(); ++it) {\n                xmpData_[it->key()] = it->value() ;\n            }\n            for ( Exiv2::Dictionary_i it = dates_.begin() ; it != dates_.end() ; ++it ) {\n                std::string   sKey = it->first;\n                Exiv2::XmpKey key(sKey);\n                if ( xmpData_.findKey(key) != xmpData_.end() ) {\n                    std::string value_orig(it->second);\n                    std::string value_now(xmpData_[sKey].value().toString());\n                    if ( value_orig.find(value_now.substr(0,10)) != std::string::npos ) {\n                        xmpData_[sKey] = value_orig ;\n                    }\n                }\n            }\n            if (XmpParser::encode(xmpPacket_, xmpData_,\n                                  XmpParser::omitPacketWrapper|XmpParser::useCompactFormat) > 1) {\n#ifndef SUPPRESS_WARNINGS\n                EXV_ERROR << \"Failed to encode XMP metadata.\\n\";\n#endif\n            }\n        }\n        if (xmpPacket_.size() > 0) {\n            if (xmpPacket_.substr(0, 5)  != \"<?xml\") {\n                xmpPacket_ = xmlHeader + xmpPacket_ + xmlFooter;\n            }\n            BasicIo::UniquePtr tempIo(new MemIo);\n            assert(tempIo.get() != 0);\n            if (tempIo->write(reinterpret_cast<const byte*>(xmpPacket_.data()), xmpPacket_.size()) != xmpPacket_.size())\n                throw Error(kerImageWriteFailed);\n            if (tempIo->error()) throw Error(kerImageWriteFailed);\n            io_->close();\n            io_->transfer(*tempIo); \n        }\n    } ", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& rhs = context->input(1);\n    context->forward_ref_input_to_ref_output(0, 0);\n    OP_REQUIRES(\n        context, rhs.IsInitialized(),\n        errors::Internal(\"Right hand side of AssignOp is not initialized\"));\n    AllocatorAttributes attr;\n    if (!relax_constraints_) {\n      attr.set_gpu_compatible(true);\n      attr.set_nic_compatible(true);\n    }\n    {\n      mutex_lock l(*context->input_ref_mutex(0));\n      const Tensor& old_lhs = context->mutable_input(0,  true);\n      const bool same_shape = old_lhs.shape().IsSameSize(rhs.shape());\n      if (validate_shape_) {\n        OP_REQUIRES(context, same_shape,\n                    errors::InvalidArgument(\n                        \"Assign requires shapes of both tensors to match. \"\n                        \"lhs shape= \",\n                        old_lhs.shape().DebugString(),\n                        \" rhs shape= \", rhs.shape().DebugString()));\n      }\n      if (old_lhs.IsInitialized() &&\n          old_lhs.shape().num_elements() == rhs.shape().num_elements()) {\n        Tensor reshaped_old_lhs;\n        if (same_shape) {\n          reshaped_old_lhs = old_lhs;\n        } else {\n          CHECK(reshaped_old_lhs.CopyFrom(old_lhs, rhs.shape()));\n          context->replace_ref_input(0, reshaped_old_lhs,\n                                      true);\n        }\n        if (use_exclusive_lock_) {\n          Copy(context, &reshaped_old_lhs, rhs);\n          return;\n        }\n      } else {\n        std::unique_ptr<Tensor> input_alias = context->forward_input(\n            1, OpKernelContext::Params::kNoReservation ,\n            rhs.dtype(), rhs.shape(), DEVICE_MEMORY, attr);\n        if (input_alias != nullptr) {\n          context->replace_ref_input(0, *input_alias,  true);\n          return;\n        }\n        Tensor copy_tensor;\n        OP_REQUIRES_OK(context,\n                       context->allocate_temp(old_lhs.dtype(), rhs.shape(),\n                                              &copy_tensor, attr));\n        context->clear_recorded_memory();\n        context->replace_ref_input(0, copy_tensor,  true);\n        if (use_exclusive_lock_) {\n          Copy(context, &copy_tensor, rhs);\n          return;\n        }\n      }\n    }\n    Tensor old_unlocked_lhs = context->mutable_input(0,  false);\n    Copy(context, &old_unlocked_lhs, rhs);\n  }", "target": 0}
{"code": "static void inet6_net_exit(struct net *net)\n{\n#ifdef CONFIG_PROC_FS\n\tudp6_proc_exit(net);\n\ttcp6_proc_exit(net);\n\tac6_proc_exit(net);\n#endif\n}", "target": 0}
{"code": "static void lwp_read_int64(FILE *fin, int64_t &d) {\n  fread(&d, sizeof(d), 1, fin);\n}", "target": 0}
{"code": "Opal::Call::get_remote_party_name () const\n{\n  return remote_party_name;\n}", "target": 0}
{"code": "static int check_func_proto(const struct bpf_func_proto *fn, int func_id)\n{\n\treturn check_raw_mode_ok(fn) &&\n\t       check_arg_pair_ok(fn) &&\n\t       check_btf_id_ok(fn) &&\n\t       check_refcount_ok(fn, func_id) ? 0 : -EINVAL;\n}", "target": 0}
{"code": "void bio_advance(struct bio *bio, unsigned bytes)\n{\n\tif (bio_integrity(bio))\n\t\tbio_integrity_advance(bio, bytes);\n\tbio_advance_iter(bio, &bio->bi_iter, bytes);\n}", "target": 0}
{"code": "TfLiteStatus GatherNd(const TfLiteEvalTensor* params,\n                      const TfLiteEvalTensor* indices,\n                      TfLiteEvalTensor* output) {\n  const int indices_dims = indices->dims->size;\n  const int indices_nd = indices->dims->data[indices_dims - 1];\n  const int params_dims = params->dims->size;\n  const IndicesT* index_data = tflite::micro::GetTensorData<IndicesT>(indices);\n  const ParamsT* param_data = tflite::micro::GetTensorData<ParamsT>(params);\n  ParamsT* output_data = tflite::micro::GetTensorData<ParamsT>(output);\n  int n_slices = 1;\n  for (int i = 0; i < indices_dims - 1; ++i) {\n    n_slices *= indices->dims->data[i];\n  }\n  int slice_size = 1;\n  for (int i = indices_nd; i < params_dims; ++i) {\n    slice_size *= params->dims->data[i];\n  }\n  int remain_flat_size = ElementCount(*params->dims);\n  int dims_to_count[MAX_INDICES_ND];\n  for (int i = 0; i < indices_nd; ++i) {\n    dims_to_count[i] = remain_flat_size / params->dims->data[i];\n    remain_flat_size = dims_to_count[i];\n  }\n  for (int i = 0; i < n_slices; ++i) {\n    int from_pos = 0;\n    for (int j = 0; j < indices_nd; ++j) {\n      int offset = i * indices_nd + j;\n      IndicesT index = index_data[offset];\n      from_pos += index * dims_to_count[j];\n    }\n    std::memcpy(output_data + i * slice_size, param_data + from_pos,\n                sizeof(ParamsT) * slice_size);\n  }\n  return kTfLiteOk;\n}", "target": 1}
{"code": "void ContainerNode::cloneChildNodes(ContainerNode *clone)\n{\n    TrackExceptionState exceptionState;\n    for (Node* n = firstChild(); n && !exceptionState.hadException(); n = n->nextSibling())\n        clone->appendChild(n->cloneNode(true), exceptionState);\n}", "target": 0}
{"code": "void test_checkout_nasty__dotgit_alternate_data_stream(void)\n{\n\ttest_checkout_fails(\"refs/heads/dotgit_alternate_data_stream\", \".git/dummy-file\");\n\ttest_checkout_fails(\"refs/heads/dotgit_alternate_data_stream\", \".git::$INDEX_ALLOCATION/dummy-file\");\n}", "target": 0}
{"code": "AP4_VisualSampleEntry::ReadFields(AP4_ByteStream& stream)\n{\n    AP4_Result result = AP4_SampleEntry::ReadFields(stream);\n    if (result < 0) return result;\n    stream.ReadUI16(m_Predefined1);\n    stream.ReadUI16(m_Reserved2);\n    stream.Read(m_Predefined2, sizeof(m_Predefined2));\n    stream.ReadUI16(m_Width);\n    stream.ReadUI16(m_Height);\n    stream.ReadUI32(m_HorizResolution);\n    stream.ReadUI32(m_VertResolution);\n    stream.ReadUI32(m_Reserved3);\n    stream.ReadUI16(m_FrameCount);\n    char compressor_name[33];\n    compressor_name[32] = 0;\n    stream.Read(compressor_name, 32);\n    int name_length = compressor_name[0];\n    if (name_length < 32) {\n        compressor_name[name_length+1] = 0; \n        m_CompressorName = &compressor_name[1];\n    }\n    stream.ReadUI16(m_Depth);\n    stream.ReadUI16(m_Predefined3);\n    return AP4_SUCCESS;\n}", "target": 1}
{"code": "static void evdev_hangup(struct evdev *evdev)\n{\n\tstruct evdev_client *client;\n\tspin_lock(&evdev->client_lock);\n\tlist_for_each_entry(client, &evdev->client_list, node)\n\t\tkill_fasync(&client->fasync, SIGIO, POLL_HUP);\n\tspin_unlock(&evdev->client_lock);\n\twake_up_interruptible(&evdev->wait);\n}", "target": 0}
{"code": "is_char_safe (gunichar c)\n{\n  return g_unichar_isgraph (c) || c == ' ';\n}", "target": 0}
{"code": "static inline Quantum ClampPixel(const MagickRealType value)\n{\n#if !defined(MAGICKCORE_HDRI_SUPPORT)\n  return((Quantum) value);\n#else\n  if (value < 0.0)\n    return((Quantum) 0.0);\n  if (value >= (MagickRealType) QuantumRange)\n    return((Quantum) QuantumRange);\n  return((Quantum) value);\n#endif\n}", "target": 0}
{"code": "static inline void set_attr(map<string, bufferlist>& attrs, const char* key, const char* value)\n{\n  bufferlist bl;\n  encode(value,bl);\n  attrs.emplace(key, std::move(bl));\n}", "target": 0}
{"code": "    void CrwMap::encode0x1810(const Image&      image,\n                              const CrwMapping* pCrwMapping,\n                                    CiffHeader* pHead)\n    {\n        assert(pCrwMapping != 0);\n        assert(pHead != 0);\n        const ExifKey kX(\"Exif.Photo.PixelXDimension\");\n        const ExifKey kY(\"Exif.Photo.PixelYDimension\");\n        const ExifKey kO(\"Exif.Image.Orientation\");\n        const ExifData &exivData = image.exifData();\n        const ExifData::const_iterator edX = exivData.findKey(kX);\n        const ExifData::const_iterator edY = exivData.findKey(kY);\n        const ExifData::const_iterator edO = exivData.findKey(kO);\n        const ExifData::const_iterator edEnd = exivData.end();\n        CiffComponent* cc = pHead->findComponent(pCrwMapping->crwTagId_,\n                                                 pCrwMapping->crwDir_);\n        if (edX != edEnd || edY != edEnd || edO != edEnd) {\n            uint32_t size = 28;\n            if (cc) {\n              if (cc->size() < size)\n                throw Error(kerCorruptedMetadata);\n              size = cc->size();\n            }\n            DataBuf buf(size);\n            std::memset(buf.pData_, 0x0, buf.size_);\n            if (cc) std::memcpy(buf.pData_ + 8, cc->pData() + 8, cc->size() - 8);\n            if (edX != edEnd && edX->size() == 4) {\n                edX->copy(buf.pData_, pHead->byteOrder());\n            }\n            if (edY != edEnd && edY->size() == 4) {\n                edY->copy(buf.pData_ + 4, pHead->byteOrder());\n            }\n            int32_t d = 0;\n            if (edO != edEnd && edO->count() > 0 && edO->typeId() == unsignedShort) {\n                d = RotationMap::degrees(static_cast<uint16_t>(edO->toLong()));\n            }\n            l2Data(buf.pData_ + 12, d, pHead->byteOrder());\n            pHead->add(pCrwMapping->crwTagId_, pCrwMapping->crwDir_, buf);\n        }\n        else {\n            pHead->remove(pCrwMapping->crwTagId_, pCrwMapping->crwDir_);\n        }\n    } ", "target": 0}
{"code": "base::string16 Browser::GetWindowTitleForTab(bool include_app_name,\n                                             int index) const {\n  return GetWindowTitleFromWebContents(\n      include_app_name, tab_strip_model_->GetWebContentsAt(index));\n}", "target": 0}
{"code": "static void jsiSqlFunc(sqlite3_context *context, int argc, sqlite3_value**argv) {\n    SqlFunc *p = (SqlFunc*)sqlite3_user_data(context);\n    int i;\n    int rc;\n    Jsi_Interp *interp = p->interp;\n    Jsi_Value *vpargs, *itemsStatic[100], **items = itemsStatic, *ret;\n    if (argc>100)\n        items = (Jsi_Value**)Jsi_Calloc(argc, sizeof(Jsi_Value*));\n    for(i=0; i<argc; i++) {\n        items[i] = dbGetValueGet(interp, argv[i]);\n    }\n    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, argc, 0));\n    Jsi_IncrRefCount(interp, vpargs);\n    ret = Jsi_ValueNew1(interp);\n    rc = Jsi_FunctionInvoke(interp, p->tocall, vpargs, &ret, NULL);\n    Jsi_DecrRefCount(interp, vpargs);\n    if (items != itemsStatic)\n        Jsi_Free(items);\n    bool b;\n    if( rc != JSI_OK) {\n        char buf[250];\n        snprintf(buf, sizeof(buf), \"error in function: %.200s\", p->zName);\n        sqlite3_result_error(context, buf, -1);\n    } else if (Jsi_ValueIsBoolean(interp, ret)) {\n        Jsi_GetBoolFromValue(interp, ret, &b);\n        sqlite3_result_int(context, b);\n    } else if (Jsi_ValueIsNumber(interp, ret)) {\n        Jsi_Number d;\n        Jsi_GetNumberFromValue(interp, ret, &d);\n        sqlite3_result_double(context, (double)d);\n    } else {\n        const char * data;\n        if (!(data = Jsi_ValueGetStringLen(interp, ret, &i))) {\n            data = Jsi_ValueToString(interp, ret, NULL);\n            i = Jsi_Strlen(data);\n        }\n        sqlite3_result_text(context, (char *)data, i, SQLITE_TRANSIENT );\n    }\n    Jsi_DecrRefCount(interp, ret);\n}", "target": 1}
{"code": "test_string_escape (void)\n{\n  gsize idx;\n  for (idx = 0; idx < G_N_ELEMENTS (escapes); idx++)\n    {\n      EscapeData *data = &escapes[idx];\n      g_autofree char *ret = NULL;\n      ret = flatpak_escape_string (data->in, data->flags);\n      g_assert_cmpstr (ret, ==, data->out);\n    }\n}", "target": 0}
{"code": "njs_function_closure_value(njs_vm_t *vm, njs_value_t **scope, njs_index_t index,\n    void *start, void *end)\n{\n    njs_value_t  *value, *newval;\n    value = scope[njs_scope_index_value(index)];\n    if (start <= (void *) value && end > (void *) value) {\n        newval = njs_mp_alloc(vm->mem_pool, sizeof(njs_value_t));\n        if (njs_slow_path(newval == NULL)) {\n            njs_memory_error(vm);\n            return NULL;\n        }\n        *newval = *value;\n        value = newval;\n    }\n    scope[njs_scope_index_value(index)] = value;\n    return value;\n}", "target": 0}
{"code": "cherokee_validator_ldap_check (cherokee_validator_ldap_t *ldap,\n                               cherokee_connection_t     *conn)\n{\n\tint                              re;\n\tret_t                            ret;\n\tsize_t                           size;\n\tchar                            *dn;\n\tLDAPMessage                     *message;\n\tLDAPMessage                     *first;\n\tchar                            *attrs[] = { LDAP_NO_ATTRS, NULL };\n\tcherokee_validator_ldap_props_t *props   = VAL_LDAP_PROP(ldap);\n\tif ((conn->validator == NULL) ||\n\t    cherokee_buffer_is_empty (&conn->validator->user))\n\t\treturn ret_error;\n\tsize = cherokee_buffer_cnt_cspn (&conn->validator->user, 0, \"*()\");\n\tif (size != conn->validator->user.len)\n\t\treturn ret_error;\n\tret = init_filter (ldap, props, conn);\n\tif (ret != ret_ok)\n\t\treturn ret;\n\tre = ldap_search_s (ldap->conn, props->basedn.buf, LDAP_SCOPE_SUBTREE, ldap->filter.buf, attrs, 0, &message);\n\tif (re != LDAP_SUCCESS) {\n\t\tLOG_ERROR (CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH,\n\t\t           props->filter.buf ? props->filter.buf : \"\");\n\t\treturn ret_error;\n\t}\n\tTRACE (ENTRIES, \"subtree search (%s): done\\n\", ldap->filter.buf ? ldap->filter.buf : \"\");\n\tre = ldap_count_entries (ldap->conn, message);\n\tif (re != 1) {\n\t\tldap_msgfree (message);\n\t\treturn ret_not_found;\n\t}\n\tfirst = ldap_first_entry (ldap->conn, message);\n\tif (first == NULL) {\n\t\tldap_msgfree (message);\n\t\treturn ret_not_found;\n\t}\n\tdn = ldap_get_dn (ldap->conn, first);\n\tif (dn == NULL) {\n\t\tldap_msgfree (message);\n\t\treturn ret_error;\n\t}\n\tldap_msgfree (message);\n\tret = validate_dn (props, dn, conn->validator->passwd.buf);\n\tif (ret != ret_ok)\n\t\treturn ret;\n\tre = ldap_unbind_s (ldap->conn);\n\tif (re != LDAP_SUCCESS)\n\t\treturn ret_error;\n\tTRACE (ENTRIES, \"Access to use %s has been granted\\n\", conn->validator->user.buf);\n\treturn ret_ok;\n}", "target": 1}
{"code": "static int snd_timer_user_open(struct inode *inode, struct file *file)\n{\n\tstruct snd_timer_user *tu;\n\tint err;\n\terr = nonseekable_open(inode, file);\n\tif (err < 0)\n\t\treturn err;\n\ttu = kzalloc(sizeof(*tu), GFP_KERNEL);\n\tif (tu == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&tu->qlock);\n\tinit_waitqueue_head(&tu->qchange_sleep);\n\tmutex_init(&tu->tread_sem);\n\ttu->ticks = 1;\n\ttu->queue_size = 128;\n\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t    GFP_KERNEL);\n\tif (tu->queue == NULL) {\n\t\tkfree(tu);\n\t\treturn -ENOMEM;\n\t}\n\tfile->private_data = tu;\n\treturn 0;\n}", "target": 1}
{"code": "bool_t xdr_nullstring(XDR *xdrs, char **objp)\n{\n     u_int size;\n     if (xdrs->x_op == XDR_ENCODE) {\n\t  if (*objp == NULL)\n\t       size = 0;\n\t  else\n\t       size = strlen(*objp) + 1;\n     }\n     if (! xdr_u_int(xdrs, &size)) {\n\t  return FALSE;\n\t}\n     switch (xdrs->x_op) {\n     case XDR_DECODE:\n\t  if (size == 0) {\n\t       *objp = NULL;\n\t       return TRUE;\n\t  } else if (*objp == NULL) {\n\t       *objp = (char *) mem_alloc(size);\n\t       if (*objp == NULL) {\n\t\t    errno = ENOMEM;\n\t\t    return FALSE;\n\t       }\n\t  }\n\t  return (xdr_opaque(xdrs, *objp, size));\n     case XDR_ENCODE:\n\t  if (size != 0)\n\t       return (xdr_opaque(xdrs, *objp, size));\n\t  return TRUE;\n     case XDR_FREE:\n\t  if (*objp != NULL)\n\t       mem_free(*objp, size);\n\t  *objp = NULL;\n\t  return TRUE;\n     }\n     return FALSE;\n}", "target": 1}
{"code": "int __usb_get_extra_descriptor(char *buffer, unsigned size,\n\t\t\t       unsigned char type, void **ptr)\n{\n\tstruct usb_descriptor_header *header;\n\twhile (size >= sizeof(struct usb_descriptor_header)) {\n\t\theader = (struct usb_descriptor_header *)buffer;\n\t\tif (header->bLength < 2) {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"%s: bogus descriptor, type %d length %d\\n\",\n\t\t\t\tusbcore_name,\n\t\t\t\theader->bDescriptorType,\n\t\t\t\theader->bLength);\n\t\t\treturn -1;\n\t\t}\n\t\tif (header->bDescriptorType == type) {\n\t\t\t*ptr = header;\n\t\t\treturn 0;\n\t\t}\n\t\tbuffer += header->bLength;\n\t\tsize -= header->bLength;\n\t}\n\treturn -1;\n}", "target": 1}
{"code": "gss_complete_auth_token (OM_uint32 *minor_status,\n\t                 const gss_ctx_id_t context_handle,\n\t                 gss_buffer_t input_message_buffer)\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (mech != NULL) {\n\tif (mech->gss_complete_auth_token != NULL) {\n\t    status = mech->gss_complete_auth_token(minor_status,\n\t\t\t\t\t\t   ctx->internal_ctx_id,\n\t\t\t\t\t\t   input_message_buffer);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_COMPLETE;\n    } else\n\tstatus = GSS_S_BAD_MECH;\n    return status;\n}", "target": 0}
{"code": "videobuf_vm_close(struct vm_area_struct *vma)\n{\n\tstruct videobuf_mapping *map = vma->vm_private_data;\n\tstruct videobuf_queue *q = map->q;\n\tint i;\n\tdprintk(2,\"vm_close %p [count=%d,vma=%08lx-%08lx]\\n\",map,\n\t\tmap->count,vma->vm_start,vma->vm_end);\n\tmap->count--;\n\tif (0 == map->count) {\n\t\tdprintk(1,\"munmap %p q=%p\\n\",map,q);\n\t\tmutex_lock(&q->lock);\n\t\tfor (i = 0; i < VIDEO_MAX_FRAME; i++) {\n\t\t\tif (NULL == q->bufs[i])\n\t\t\t\tcontinue;\n\t\t\tif (q->bufs[i]->map != map)\n\t\t\t\tcontinue;\n\t\t\tq->ops->buf_release(q,q->bufs[i]);\n\t\t\tq->bufs[i]->map   = NULL;\n\t\t\tq->bufs[i]->baddr = 0;\n\t\t}\n\t\tmutex_unlock(&q->lock);\n\t\tkfree(map);\n\t}\n\treturn;\n}", "target": 1}
{"code": "exif_data_load_data_entry (ExifData *data, ExifEntry *entry,\n\t\t\t   const unsigned char *d,\n\t\t\t   unsigned int size, unsigned int offset)\n{\n\tunsigned int s, doff;\n\tentry->tag        = exif_get_short (d + offset + 0, data->priv->order);\n\tentry->format     = exif_get_short (d + offset + 2, data->priv->order);\n\tentry->components = exif_get_long  (d + offset + 4, data->priv->order);\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t  \"Loading entry 0x%x ('%s')...\", entry->tag,\n\t\t  exif_tag_get_name (entry->tag));\n\ts = exif_format_get_size(entry->format) * entry->components;\n\tif ((s < entry->components) || (s == 0)){\n\t\treturn 0;\n\t}\n\tif (s > 4)\n\t\tdoff = exif_get_long (d + offset + 8, data->priv->order);\n\telse\n\t\tdoff = offset + 8;\n\tif ((doff + s < doff) || (doff + s < s) || (doff + s > size)) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t  \"Tag data past end of buffer (%u > %u)\", doff+s, size);\t\n\t\treturn 0;\n\t}\n\tentry->data = exif_data_alloc (data, s);\n\tif (entry->data) {\n\t\tentry->size = s;\n\t\tmemcpy (entry->data, d + doff, s);\n\t} else {\n\t\tEXIF_LOG_NO_MEMORY(data->priv->log, \"ExifData\", s);\n\t\treturn 0;\n\t}\n\tif (entry->tag == EXIF_TAG_MAKER_NOTE) {\n\t\tif (!entry->data) {\n\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t\t  \"MakerNote found with empty data\");\t\n\t\t} else if (entry->size > 6) {\n\t\t\texif_log (data->priv->log,\n\t\t\t\t\t       EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t\t       \"MakerNote found (%02x %02x %02x %02x \"\n\t\t\t\t\t       \"%02x %02x %02x...).\",\n\t\t\t\t\t       entry->data[0], entry->data[1], entry->data[2],\n\t\t\t\t\t       entry->data[3], entry->data[4], entry->data[5],\n\t\t\t\t\t       entry->data[6]);\n\t\t}\n\t\tdata->priv->offset_mnote = doff;\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "MONGO_EXPORT int bson_append_element( bson *b, const char *name_or_null, const bson_iterator *elem ) {\n    bson_iterator next = *elem;\n    int size;\n    bson_iterator_next( &next );\n    size = next.cur - elem->cur;\n    if ( name_or_null == NULL ) {\n        if( bson_ensure_space( b, size ) == BSON_ERROR )\n            return BSON_ERROR;\n        bson_append( b, elem->cur, size );\n    }\n    else {\n        int data_size = size - 2 - strlen( bson_iterator_key( elem ) );\n        bson_append_estart( b, elem->cur[0], name_or_null, data_size );\n        bson_append( b, bson_iterator_value( elem ), data_size );\n    }\n    return BSON_OK;\n}", "target": 1}
{"code": "void AdsIntegrationTest::initializeAds(const bool rate_limiting) {\n  config_helper_.addRuntimeOverride(\"envoy.restart_features.explicit_wildcard_resource\",\n                                    oldDssOrNewDss() == OldDssOrNewDss::Old ? \"false\" : \"true\");\n  config_helper_.addConfigModifier([this, &rate_limiting](\n                                       envoy::config::bootstrap::v3::Bootstrap& bootstrap) {\n    auto* ads_config = bootstrap.mutable_dynamic_resources()->mutable_ads_config();\n    if (rate_limiting) {\n      ads_config->mutable_rate_limit_settings();\n    }\n    auto* grpc_service = ads_config->add_grpc_services();\n    setGrpcService(*grpc_service, \"ads_cluster\", xds_upstream_->localAddress());\n    auto* ads_cluster = bootstrap.mutable_static_resources()->add_clusters();\n    ads_cluster->MergeFrom(bootstrap.static_resources().clusters()[0]);\n    ads_cluster->set_name(\"ads_cluster\");\n    envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext context;\n    auto* validation_context = context.mutable_common_tls_context()->mutable_validation_context();\n    validation_context->mutable_trusted_ca()->set_filename(\n        TestEnvironment::runfilesPath(\"test/config/integration/certs/upstreamcacert.pem\"));\n    validation_context->add_match_subject_alt_names()->set_suffix(\"lyft.com\");\n    if (clientType() == Grpc::ClientType::GoogleGrpc) {\n      auto* google_grpc = grpc_service->mutable_google_grpc();\n      auto* ssl_creds = google_grpc->mutable_channel_credentials()->mutable_ssl_credentials();\n      ssl_creds->mutable_root_certs()->set_filename(\n          TestEnvironment::runfilesPath(\"test/config/integration/certs/upstreamcacert.pem\"));\n    }\n    ads_cluster->mutable_transport_socket()->set_name(\"envoy.transport_sockets.tls\");\n    ads_cluster->mutable_transport_socket()->mutable_typed_config()->PackFrom(context);\n  });\n  HttpIntegrationTest::initialize();\n  if (xds_stream_ == nullptr) {\n    createXdsConnection();\n    AssertionResult result = xds_connection_->waitForNewStream(*dispatcher_, xds_stream_);\n    RELEASE_ASSERT(result, result.message());\n    xds_stream_->startGrpcStream();\n  }\n}", "target": 1}
{"code": "messageAddArgument(message *m, const char *arg)\n{\n\tint offset;\n\tchar *p;\n\tassert(m != NULL);\n\tif(arg == NULL)\n\t\treturn;\t\n\twhile(isspace(*arg))\n\t\targ++;\n\tif(*arg == '\\0')\n\t\treturn;\n\tcli_dbgmsg(\"messageAddArgument, arg='%s'\\n\", arg);\n\tif(!usefulArg(arg))\n\t\treturn;\n\tfor(offset = 0; offset < m->numberOfArguments; offset++)\n\t\tif(m->mimeArguments[offset] == NULL)\n\t\t\tbreak;\n\t\telse if(strcasecmp(arg, m->mimeArguments[offset]) == 0)\n\t\t\treturn;\t\n\tif(offset == m->numberOfArguments) {\n\t\tchar **q;\n\t\tm->numberOfArguments++;\n\t\tq = (char **)cli_realloc(m->mimeArguments, m->numberOfArguments * sizeof(char *));\n\t\tif(q == NULL) {\n\t\t\tm->numberOfArguments--;\n\t\t\treturn;\n\t\t}\n\t\tm->mimeArguments = q;\n\t}\n\tp = m->mimeArguments[offset] = rfc2231(arg);\n\tif(!p) {\n\t\tcli_dbgmsg(\"messageAddArgument, error from rfc2231()\\n\");\n\t\treturn;\n\t}\n\tif(strchr(p, '=') == NULL) {\n\t\tif(strncmp(p, \"filename\", 8) == 0) {\n\t\t\tcli_dbgmsg(\"Possible data corruption fixed\\n\");\n\t\t\tp[8] = '=';\n\t\t} else {\n\t\t\tif(*p)\n\t\t\t\tcli_dbgmsg(\"messageAddArgument, '%s' contains no '='\\n\", p);\n\t\t\tfree(m->mimeArguments[offset]);\n\t\t\tm->mimeArguments[offset] = NULL;\n\t\t\treturn;\n\t\t}\n\t}\n\tif((strncasecmp(p, \"filename=\", 9) == 0) || (strncasecmp(p, \"name=\", 5) == 0))\n\t\tif(messageGetMimeType(m) == NOMIME) {\n\t\t\tcli_dbgmsg(\"Force mime encoding to application\\n\");\n\t\t\tmessageSetMimeType(m, \"application\");\n\t\t}\n}", "target": 1}
{"code": "static void test_map_big_memory(void)\n{\n    uc_engine *uc;\n    OK(uc_open(UC_ARCH_X86, UC_MODE_64, &uc));\n    uc_assert_err(UC_ERR_NOMEM,\n                  uc_mem_map(uc, 0x0, 0xfffffffffffff000, UC_PROT_ALL));\n    OK(uc_close(uc));\n}", "target": 0}
{"code": "static int selinux_task_setnice(struct task_struct *p, int nice)\n{\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    current_sid(), task_sid(p), SECCLASS_PROCESS,\n\t\t\t    PROCESS__SETSCHED, NULL);\n}", "target": 0}
{"code": "static void ConvertLoopSlice(ModSample &src, ModSample &dest, SmpLength start, SmpLength len, bool loop)\n{\n\tif(!src.HasSampleData()) return;\n\tdest.FreeSample();\n\tdest = src;\n\tdest.nLength = len;\n\tdest.pSample = nullptr;\n\tif(!dest.AllocateSample())\n\t{\n\t\treturn;\n\t}\n\tif(len != src.nLength)\n\t\tMemsetZero(dest.cues);\n\tstd::memcpy(dest.pSample8, src.pSample8 + start, len);\n\tdest.uFlags.set(CHN_LOOP, loop);\n\tif(loop)\n\t{\n\t\tdest.nLoopStart = 0;\n\t\tdest.nLoopEnd = len;\n\t} else\n\t{\n\t\tdest.nLoopStart = 0;\n\t\tdest.nLoopEnd = 0;\n\t}\n}", "target": 1}
{"code": "ngx_http_lua_copy_request_headers(ngx_http_request_t *sr, ngx_http_request_t *r)\n{\n    ngx_table_elt_t                 *header;\n    ngx_list_part_t                 *part;\n    ngx_uint_t                       i;\n    if (ngx_list_init(&sr->headers_in.headers, sr->pool, 20,\n                      sizeof(ngx_table_elt_t)) != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n    dd(\"before: parent req headers count: %d\",\n       (int) r->headers_in.headers.part.nelts);\n    part = &r->headers_in.headers.part;\n    header = part->elts;\n    for (i = 0; ; i++) {\n        if (i >= part->nelts) {\n            if (part->next == NULL) {\n                break;\n            }\n            part = part->next;\n            header = part->elts;\n            i = 0;\n        }\n        dd(\"setting request header %.*s: %.*s\", (int) header[i].key.len,\n           header[i].key.data, (int) header[i].value.len,\n           header[i].value.data);\n        if (ngx_http_lua_set_input_header(sr, header[i].key,\n                                          header[i].value, 0) == NGX_ERROR)\n        {\n            return NGX_ERROR;\n        }\n    }\n    dd(\"after: parent req headers count: %d\",\n       (int) r->headers_in.headers.part.nelts);\n    return NGX_OK;\n}", "target": 1}
{"code": "_dbus_get_monotonic_time (long *tv_sec,\n                          long *tv_usec)\n{\n  _dbus_get_real_time (tv_sec, tv_usec);\n}", "target": 0}
{"code": "void SFS_CompoundExpression(ScriptParser *parser)\n{\n\tif (parser->codec->LastError) return;\n\tSFS_Expression(parser);\n\tif (! gf_bs_read_int(parser->bs, 1)) return;\n\tif (parser->codec->LastError) return;\n\tSFS_AddString(parser, \",\");\n\tSFS_CompoundExpression(parser);\n}", "target": 0}
{"code": "static inline void skb_reserve(struct sk_buff *skb, int len)\n{\n\tskb->data += len;\n\tskb->tail += len;\n}", "target": 0}
{"code": "list_fields(MYSQL *mysql,const char *db,const char *table,\n\t    const char *wild)\n{\n  char query[1024],*end;\n  MYSQL_RES *result;\n  MYSQL_ROW row;\n  ulong UNINIT_VAR(rows);\n  if (mysql_select_db(mysql,db))\n  {\n    fprintf(stderr,\"%s: Cannot connect to db: %s: %s\\n\",my_progname,db,\n\t    mysql_error(mysql));\n    return 1;\n  }\n  if (opt_count)\n  {\n    sprintf(query,\"select count(*) from `%s`\", table);\n    if (mysql_query(mysql,query) || !(result=mysql_store_result(mysql)))\n    {\n      fprintf(stderr,\"%s: Cannot get record count for db: %s, table: %s: %s\\n\",\n              my_progname,db,table,mysql_error(mysql));\n      return 1;\n    }\n    row= mysql_fetch_row(result);\n    rows= (ulong) strtoull(row[0], (char**) 0, 10);\n    mysql_free_result(result);\n  }\n  end=strmov(strmov(strmov(query,\"show  columns from `\"),table),\"`\");\n  if (wild && wild[0])\n    strxmov(end,\" like '\",wild,\"'\",NullS);\n  if (mysql_query(mysql,query) || !(result=mysql_store_result(mysql)))\n  {\n    fprintf(stderr,\"%s: Cannot list columns in db: %s, table: %s: %s\\n\",\n\t    my_progname,db,table,mysql_error(mysql));\n    return 1;\n  }\n  printf(\"Database: %s  Table: %s\", db, table);\n  if (opt_count)\n    printf(\"  Rows: %lu\", rows);\n  if (wild && wild[0])\n    printf(\"  Wildcard: %s\",wild);\n  putchar('\\n');\n  print_res_header(result);\n  while ((row=mysql_fetch_row(result)))\n    print_res_row(result,row);\n  print_res_top(result);\n  if (opt_show_keys)\n  {\n    end=strmov(strmov(strmov(query,\"show keys from `\"),table),\"`\");\n    if (mysql_query(mysql,query) || !(result=mysql_store_result(mysql)))\n    {\n      fprintf(stderr,\"%s: Cannot list keys in db: %s, table: %s: %s\\n\",\n\t      my_progname,db,table,mysql_error(mysql));\n      return 1;\n    }\n    if (mysql_num_rows(result))\n    {\n      print_res_header(result);\n      while ((row=mysql_fetch_row(result)))\n\tprint_res_row(result,row);\n      print_res_top(result);\n    }\n    else\n      puts(\"Table has no keys\");\n  }\n  mysql_free_result(result);\n  return 0;\n}", "target": 1}
{"code": "free_ice_connection_watch (GsmIceConnectionWatch *data)\n{\n        if (data->watch_id) {\n                g_source_remove (data->watch_id);\n                data->watch_id = 0;\n        }\n        if (data->protocol_timeout) {\n                g_source_remove (data->protocol_timeout);\n                data->protocol_timeout = 0;\n        }\n        g_free (data);\n}", "target": 0}
{"code": "\tPong(const std::string& cookie, const std::string& server = \"\")\n\t\t: ClientProtocol::Message(\"PONG\", ServerInstance->Config->GetServerName())\n\t{\n\t\tPushParamRef(ServerInstance->Config->GetServerName());\n\t\tif (!server.empty())\n\t\t\tPushParamRef(server);\n\t\tPushParamRef(cookie);\n\t}", "target": 1}
{"code": "ptr_str_array_compare (const gchar **a,\n                       const gchar **b)\n{\n  return g_strcmp0 (*a, *b);\n}", "target": 0}
{"code": "NavigationControllerImpl& WebContentsImpl::GetControllerForRenderManager() {\n  return GetController();\n}", "target": 0}
{"code": "static void __xen_evtchn_do_upcall(void)\n{\n\tstruct vcpu_info *vcpu_info = __this_cpu_read(xen_vcpu);\n\tint cpu = smp_processor_id();\n\tstruct evtchn_loop_ctrl ctrl = { 0 };\n\tread_lock(&evtchn_rwlock);\n\tdo {\n\t\tvcpu_info->evtchn_upcall_pending = 0;\n\t\txen_evtchn_handle_events(cpu, &ctrl);\n\t\tBUG_ON(!irqs_disabled());\n\t\tvirt_rmb(); \n\t} while (vcpu_info->evtchn_upcall_pending);\n\tread_unlock(&evtchn_rwlock);\n\t__this_cpu_inc(irq_epoch);\n}", "target": 0}
{"code": "static void draw_pattern_push( wmfAPI* API,\n                               unsigned long id,\n                               unsigned long columns,\n                               unsigned long rows )\n{\n  char\n    pattern_id[MagickPathExtent];\n  (void) FormatLocaleString(pattern_id,MagickPathExtent,\"brush_%lu\",id);\n  (void) DrawPushPattern(WmfDrawingWand,pattern_id,0,0,columns,rows);\n}", "target": 0}
{"code": "    bool normalizeSipUri( std::string& uri, int brackets ) {\n        su_home_t* home = theOneAndOnlyController->getHome() ;\n        char *s ;\n        char buf[255];\n        char obuf[255] ;\n        char hp[64] ;\n        char const *display = NULL;\n        url_t url[1];\n        msg_param_t const *params = NULL;\n        char const *comment = NULL;\n        int rc ;\n        s = strncpy( buf, uri.c_str(), 255 ) ;\n        rc = sip_name_addr_d(home, &s, &display, url, &params, &comment) ;\n        if( rc < 0 ) {  \n            return false ;\n        }\n        if( NULL == url->url_scheme && NULL == url->url_user && NULL != url->url_host ) {\n            url->url_scheme = \"sip\" ;\n            url->url_user = url->url_host ;\n            url->url_host = \"localhost\" ;   \n         }\n        int nChars = sip_name_addr_e(obuf, 255, 0, display, brackets, url, params, comment) ;\n        if( params ) {\n            su_free(home, (void *) params) ;\n        }\n        if( nChars <= 0 ) {\n            return false ;\n        }\n        uri.assign( obuf ) ;\n        return true ;\n    }", "target": 1}
{"code": "static struct nfs4_state *nfs4_try_open_cached(struct nfs4_opendata *opendata)\n{\n\tstruct nfs4_state *state = opendata->state;\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tstruct nfs_delegation *delegation;\n\tint open_mode = opendata->o_arg.open_flags & (FMODE_READ|FMODE_WRITE|O_EXCL);\n\tnfs4_stateid stateid;\n\tint ret = -EAGAIN;\n\tfor (;;) {\n\t\tif (can_open_cached(state, open_mode)) {\n\t\t\tspin_lock(&state->owner->so_lock);\n\t\t\tif (can_open_cached(state, open_mode)) {\n\t\t\t\tupdate_open_stateflags(state, open_mode);\n\t\t\t\tspin_unlock(&state->owner->so_lock);\n\t\t\t\tgoto out_return_state;\n\t\t\t}\n\t\t\tspin_unlock(&state->owner->so_lock);\n\t\t}\n\t\trcu_read_lock();\n\t\tdelegation = rcu_dereference(nfsi->delegation);\n\t\tif (delegation == NULL ||\n\t\t    !can_open_delegated(delegation, open_mode)) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(stateid.data, delegation->stateid.data, sizeof(stateid.data));\n\t\trcu_read_unlock();\n\t\tret = nfs_may_open(state->inode, state->owner->so_cred, open_mode);\n\t\tif (ret != 0)\n\t\t\tgoto out;\n\t\tret = -EAGAIN;\n\t\tif (update_open_stateid(state, NULL, &stateid, open_mode))\n\t\t\tgoto out_return_state;\n\t}\nout:\n\treturn ERR_PTR(ret);\nout_return_state:\n\tatomic_inc(&state->count);\n\treturn state;\n}", "target": 1}
{"code": "header_read (SF_PRIVATE *psf, void *ptr, int bytes)\n{\tint count = 0 ;\n\tif (psf->headindex >= SIGNED_SIZEOF (psf->header))\n\t\treturn psf_fread (ptr, 1, bytes, psf) ;\n\tif (psf->headindex + bytes > SIGNED_SIZEOF (psf->header))\n\t{\tint most ;\n\t\tmost = SIGNED_SIZEOF (psf->header) - psf->headend ;\n\t\tpsf_fread (psf->header + psf->headend, 1, most, psf) ;\n\t\tmemcpy (ptr, psf->header + psf->headend, most) ;\n\t\tpsf->headend = psf->headindex += most ;\n\t\tpsf_fread ((char *) ptr + most, bytes - most, 1, psf) ;\n\t\treturn bytes ;\n\t\t} ;\n\tif (psf->headindex + bytes > psf->headend)\n\t{\tcount = psf_fread (psf->header + psf->headend, 1, bytes - (psf->headend - psf->headindex), psf) ;\n\t\tif (count != bytes - (int) (psf->headend - psf->headindex))\n\t\t{\tpsf_log_printf (psf, \"Error : psf_fread returned short count.\\n\") ;\n\t\t\treturn count ;\n\t\t\t} ;\n\t\tpsf->headend += count ;\n\t\t} ;\n\tmemcpy (ptr, psf->header + psf->headindex, bytes) ;\n\tpsf->headindex += bytes ;\n\treturn bytes ;\n} ", "target": 1}
{"code": "static gboolean irssi_ssl_verify(SSL *ssl, SSL_CTX *ctx, X509 *cert)\n{\n\tif (SSL_get_verify_result(ssl) != X509_V_OK) {\n\t\tunsigned char md[EVP_MAX_MD_SIZE];\n\t\tunsigned int n;\n\t\tchar *str;\n\t\tg_warning(\"Could not verify SSL servers certificate:\");\n\t\tif ((str = X509_NAME_oneline(X509_get_subject_name(cert), 0, 0)) == NULL)\n\t\t\tg_warning(\"  Could not get subject-name from peer certificate\");\n\t\telse {\n\t\t\tg_warning(\"  Subject : %s\", str);\n\t\t\tfree(str);\n\t\t}\n\t\tif ((str = X509_NAME_oneline(X509_get_issuer_name(cert), 0, 0)) == NULL)\n\t\t\tg_warning(\"  Could not get issuer-name from peer certificate\");\n\t\telse {\n\t\t\tg_warning(\"  Issuer  : %s\", str);\n\t\t\tfree(str);\n\t\t}\n\t\tif (! X509_digest(cert, EVP_md5(), md, &n))\n\t\t\tg_warning(\"  Could not get fingerprint from peer certificate\");\n\t\telse {\n\t\t\tchar hex[] = \"0123456789ABCDEF\";\n\t\t\tchar fp[EVP_MAX_MD_SIZE*3];\n\t\t\tif (n < sizeof(fp)) {\n\t\t\t\tunsigned int i;\n\t\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\t\tfp[i*3+0] = hex[(md[i] >> 4) & 0xF];\n\t\t\t\t\tfp[i*3+1] = hex[(md[i] >> 0) & 0xF];\n\t\t\t\t\tfp[i*3+2] = i == n - 1 ? '\\0' : ':';\n\t\t\t\t}\n\t\t\t\tg_warning(\"  MD5 Fingerprint : %s\", fp);\n\t\t\t}\n\t\t}\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "static cache_accel_t *read_cache_accel(RBuffer *cache_buf, cache_hdr_t *hdr, cache_map_t *maps) {\n\tif (!cache_buf || !hdr || !hdr->accelerateInfoSize || !hdr->accelerateInfoAddr) {\n\t\treturn NULL;\n\t}\n\tut64 offset = va2pa (hdr->accelerateInfoAddr, hdr->mappingCount, maps, cache_buf, 0, NULL, NULL);\n\tif (!offset) {\n\t\treturn NULL;\n\t}\n\tut64 size = sizeof (cache_accel_t);\n\tcache_accel_t *accel = R_NEW0 (cache_accel_t);\n\tif (!accel) {\n\t\treturn NULL;\n\t}\n\tif (r_buf_fread_at (cache_buf, offset, (ut8*) accel, \"16il\", 1) != size) {\n\t\tR_FREE (accel);\n\t\treturn NULL;\n\t}\n\taccel->imagesExtrasOffset += offset;\n\taccel->bottomUpListOffset += offset;\n\taccel->dylibTrieOffset += offset;\n\taccel->initializersOffset += offset;\n\taccel->dofSectionsOffset += offset;\n\taccel->reExportListOffset += offset;\n\taccel->depListOffset += offset;\n\taccel->rangeTableOffset += offset;\n\treturn accel;\n}", "target": 1}
{"code": "    **/\n    CImg<T>& autocrop(const T *const color=0, const char *const axes=\"zyx\") {\n      if (is_empty()) return *this;\n      if (!color) { \n        const CImg<T> col1 = get_vector_at(0,0,0);\n        const unsigned int w = _width, h = _height, d = _depth, s = _spectrum;\n        autocrop(col1,axes);\n        if (_width==w && _height==h && _depth==d && _spectrum==s) {\n          const CImg<T> col2 = get_vector_at(w - 1,h - 1,d - 1);\n          autocrop(col2,axes);\n        }\n        return *this;\n      }\n      for (const char *s = axes; *s; ++s) {\n        const char axis = cimg::lowercase(*s);\n        switch (axis) {\n        case 'x' : {\n\t  int x0 = width(), x1 = -1;\n\t  cimg_forC(*this,c) {\n\t    const CImg<intT> coords = get_shared_channel(c)._autocrop(color[c],'x');\n\t    const int nx0 = coords[0], nx1 = coords[1];\n\t    if (nx0>=0 && nx1>=0) { x0 = std::min(x0,nx0); x1 = std::max(x1,nx1); }\n\t  }\n          if (x0==width() && x1==-1) return assign(); else crop(x0,x1);\n\t} break;\n        case 'y' : {\n\t  int y0 = height(), y1 = -1;\n\t  cimg_forC(*this,c) {\n\t    const CImg<intT> coords = get_shared_channel(c)._autocrop(color[c],'y');\n\t    const int ny0 = coords[0], ny1 = coords[1];\n\t    if (ny0>=0 && ny1>=0) { y0 = std::min(y0,ny0); y1 = std::max(y1,ny1); }\n\t  }\n          if (y0==height() && y1==-1) return assign(); else crop(0,y0,_width - 1,y1);\n\t} break;\n        default : {\n\t  int z0 = depth(), z1 = -1;\n\t  cimg_forC(*this,c) {\n\t    const CImg<intT> coords = get_shared_channel(c)._autocrop(color[c],'z');\n\t    const int nz0 = coords[0], nz1 = coords[1];\n\t    if (nz0>=0 && nz1>=0) { z0 = std::min(z0,nz0); z1 = std::max(z1,nz1); }\n\t  }\n\t  if (z0==depth() && z1==-1) return assign(); else crop(0,0,z0,_width - 1,_height - 1,z1);\n\t}\n        }\n      }\n      return *this;", "target": 0}
{"code": "AP4_AvccAtom::AP4_AvccAtom(AP4_UI32 size, const AP4_UI08* payload) :\n    AP4_Atom(AP4_ATOM_TYPE_AVCC, size)\n{\n    unsigned int payload_size = size-AP4_ATOM_HEADER_SIZE;\n    m_RawBytes.SetData(payload, payload_size);\n    m_ConfigurationVersion = payload[0];\n    m_Profile              = payload[1];\n    m_ProfileCompatibility = payload[2];\n    m_Level                = payload[3];\n    m_NaluLengthSize       = 1+(payload[4]&3);\n    AP4_UI08 num_seq_params = payload[5]&31;\n    m_SequenceParameters.EnsureCapacity(num_seq_params);\n    unsigned int cursor = 6;\n    for (unsigned int i=0; i<num_seq_params; i++) {\n        m_SequenceParameters.Append(AP4_DataBuffer());\n        AP4_UI16 param_length = AP4_BytesToInt16BE(&payload[cursor]);\n        m_SequenceParameters[i].SetData(&payload[cursor]+2, param_length);\n        cursor += 2+param_length;\n    }\n    AP4_UI08 num_pic_params = payload[cursor++];\n    m_PictureParameters.EnsureCapacity(num_pic_params);\n    for (unsigned int i=0; i<num_pic_params; i++) {\n        m_PictureParameters.Append(AP4_DataBuffer());\n        AP4_UI16 param_length = AP4_BytesToInt16BE(&payload[cursor]);\n        m_PictureParameters[i].SetData(&payload[cursor]+2, param_length);\n        cursor += 2+param_length;\n    }\n}", "target": 1}
{"code": "extract_epub_from_container (const gchar* uri,\n                             EpubDocument *epub_document,\n                             GError ** error)\n{\n    GError *err = NULL;\n    epub_document->archivename = g_filename_from_uri(uri,NULL,error);\n    if ( !epub_document->archivename )\n    {\n        if (err) {\n            g_propagate_error (error, err);\n        }\n        else {\n            g_set_error_literal (error,\n                         EV_DOCUMENT_ERROR,\n                         EV_DOCUMENT_ERROR_INVALID,\n                         _(\"could not retrieve filename\"));\n        }\n        return FALSE;\n    }\n    gchar *epubfilename = g_strrstr(epub_document->archivename,\"/\");\n    if ( *epubfilename == '/' )\n        epubfilename++ ;\n    GString *temporary_sub_directory = g_string_new(epubfilename);\n    g_string_append(temporary_sub_directory,\"XXXXXX\") ;\n    epub_document->tmp_archive_dir = ev_mkdtemp(temporary_sub_directory->str, error);\n    g_string_free(temporary_sub_directory, TRUE);\n    if (!epub_document->tmp_archive_dir) {\n        return FALSE;\n    }\n    epub_document->epubDocument = unzOpen64(epub_document->archivename);\n    if ( epub_document->epubDocument == NULL )\n    {\n        if (err)    {\n            g_propagate_error (error, err);\n        }\n        else    {\n            g_set_error_literal (error,\n                         EV_DOCUMENT_ERROR,\n                         EV_DOCUMENT_ERROR_INVALID,\n                         _(\"could not open archive\"));\n        }\n        return FALSE;\n    }\n    gboolean result = FALSE;\n    if ( unzGoToFirstFile(epub_document->epubDocument) != UNZ_OK )\n    {\n        if (err) {\n            g_propagate_error (error, err);\n        }\n        else    {\n            g_set_error_literal (error,\n                         EV_DOCUMENT_ERROR,\n                         EV_DOCUMENT_ERROR_INVALID,\n                         _(\"could not extract archive\"));\n        }\n        goto out;\n    }\n    while ( TRUE )\n    {\n        if ( extract_one_file(epub_document,&err) == FALSE )\n        {\n            if (err) {\n                g_propagate_error (error, err);\n            }\n            else    {\n                g_set_error_literal (error,\n                             EV_DOCUMENT_ERROR,\n                             EV_DOCUMENT_ERROR_INVALID,\n                             _(\"could not extract archive\"));\n            }\n\t\t\tgoto out;\n        }\n        if ( unzGoToNextFile(epub_document->epubDocument) == UNZ_END_OF_LIST_OF_FILE ) {\n            result = TRUE;\n            break;\n        }\n    }\nout:\n    unzClose(epub_document->epubDocument);\n    return result;\n}", "target": 1}
{"code": "bool ExtractUnixLink50(CommandData *Cmd,const wchar *Name,FileHeader *hd)\n{\n  char Target[NM];\n  WideToChar(hd->RedirName,Target,ASIZE(Target));\n  if (hd->RedirType==FSREDIR_WINSYMLINK || hd->RedirType==FSREDIR_JUNCTION)\n  {\n    if (strncmp(Target,\"\\\\??\\\\\",4)==0 || strncmp(Target,\"/\\?\\?/\",4)==0)\n      return false;\n    DosSlashToUnix(Target,Target,ASIZE(Target));\n  }\n  wchar TargetW[NM];\n  if (!SafeCharToWide(Target,TargetW,ASIZE(TargetW)))\n    return false;\n  if (!Cmd->AbsoluteLinks && (IsFullPath(TargetW) ||\n      !IsRelativeSymlinkSafe(Cmd,hd->FileName,Name,TargetW)))\n    return false;\n  return UnixSymlink(Cmd,Target,Name,&hd->mtime,&hd->atime);\n}", "target": 1}
{"code": "static Jsi_RC DebugRemoveCmd_(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr, int op)\n{\n    Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 0);\n    if (interp->breakpointHash)\n    {\n        int num;\n        char nbuf[100];\n        if (Jsi_GetIntFromValue(interp, val, &num) != JSI_OK) \n            return Jsi_LogError(\"bad number\");\n        snprintf(nbuf, sizeof(nbuf), \"%d\", num);\n        Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->breakpointHash, nbuf);\n        jsi_BreakPoint* bptr;\n        if (hPtr && (bptr = (jsi_BreakPoint*)Jsi_HashValueGet(hPtr))) {\n            switch (op) {\n                case 1: bptr->enabled = 0; break;\n                case 2: bptr->enabled = 1; break;\n                default:\n                    Jsi_HashEntryDelete(hPtr);\n            }\n            return JSI_OK;\n        }\n    }\n    return Jsi_LogError(\"unknown breakpoint\");\n}", "target": 1}
{"code": "struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,\n\t\t\t\t\t\tint port)\n{\n\tunsigned long flags;\n\tstruct snd_seq_client_port *new_port, *p;\n\tint num = -1;\n\tif (snd_BUG_ON(!client))\n\t\treturn NULL;\n\tif (client->num_ports >= SNDRV_SEQ_MAX_PORTS) {\n\t\tpr_warn(\"ALSA: seq: too many ports for client %d\\n\", client->number);\n\t\treturn NULL;\n\t}\n\tnew_port = kzalloc(sizeof(*new_port), GFP_KERNEL);\n\tif (!new_port)\n\t\treturn NULL;\t\n\tnew_port->addr.client = client->number;\n\tnew_port->addr.port = -1;\n\tnew_port->owner = THIS_MODULE;\n\tsprintf(new_port->name, \"port-%d\", num);\n\tsnd_use_lock_init(&new_port->use_lock);\n\tport_subs_info_init(&new_port->c_src);\n\tport_subs_info_init(&new_port->c_dest);\n\tnum = port >= 0 ? port : 0;\n\tmutex_lock(&client->ports_mutex);\n\twrite_lock_irqsave(&client->ports_lock, flags);\n\tlist_for_each_entry(p, &client->ports_list_head, list) {\n\t\tif (p->addr.port > num)\n\t\t\tbreak;\n\t\tif (port < 0) \n\t\t\tnum = p->addr.port + 1;\n\t}\n\tlist_add_tail(&new_port->list, &p->list);\n\tclient->num_ports++;\n\tnew_port->addr.port = num;\t\n\twrite_unlock_irqrestore(&client->ports_lock, flags);\n\tmutex_unlock(&client->ports_mutex);\n\tsprintf(new_port->name, \"port-%d\", num);\n\treturn new_port;\n}", "target": 1}
{"code": "void * pvPortMalloc( size_t xWantedSize )\n{\n    BlockLink_t * pxBlock, * pxPreviousBlock, * pxNewBlockLink;\n    static BaseType_t xHeapHasBeenInitialised = pdFALSE;\n    void * pvReturn = NULL;\n    vTaskSuspendAll();\n    {\n        if( xHeapHasBeenInitialised == pdFALSE )\n        {\n            prvHeapInit();\n            xHeapHasBeenInitialised = pdTRUE;\n        }\n        if( xWantedSize > 0 )\n        {\n            xWantedSize += heapSTRUCT_SIZE;\n            if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0 )\n            {\n                xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );\n            }\n        }\n        if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )\n        {\n            pxPreviousBlock = &xStart;\n            pxBlock = xStart.pxNextFreeBlock;\n            while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )\n            {\n                pxPreviousBlock = pxBlock;\n                pxBlock = pxBlock->pxNextFreeBlock;\n            }\n            if( pxBlock != &xEnd )\n            {\n                pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );\n                pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;\n                if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )\n                {\n                    pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );\n                    pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;\n                    pxBlock->xBlockSize = xWantedSize;\n                    prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );\n                }\n                xFreeBytesRemaining -= pxBlock->xBlockSize;\n            }\n        }\n        traceMALLOC( pvReturn, xWantedSize );\n    }\n    ( void ) xTaskResumeAll();\n    #if ( configUSE_MALLOC_FAILED_HOOK == 1 )\n        {\n            if( pvReturn == NULL )\n            {\n                extern void vApplicationMallocFailedHook( void );\n                vApplicationMallocFailedHook();\n            }\n        }\n    #endif\n    return pvReturn;\n}", "target": 1}
{"code": "static void bnx2x_pf_tx_q_prep(struct bnx2x *bp,\n\tstruct bnx2x_fastpath *fp, struct bnx2x_txq_setup_params *txq_init,\n\tu8 cos)\n{\n\ttxq_init->dscr_map = fp->txdata_ptr[cos]->tx_desc_mapping;\n\ttxq_init->sb_cq_index = HC_INDEX_ETH_FIRST_TX_CQ_CONS + cos;\n\ttxq_init->traffic_type = LLFC_TRAFFIC_TYPE_NW;\n\ttxq_init->fw_sb_id = fp->fw_sb_id;\n\ttxq_init->tss_leading_cl_id = bnx2x_fp(bp, 0, cl_id);\n\tif (IS_FCOE_FP(fp)) {\n\t\ttxq_init->sb_cq_index = HC_SP_INDEX_ETH_FCOE_TX_CQ_CONS;\n\t\ttxq_init->traffic_type = LLFC_TRAFFIC_TYPE_FCOE;\n\t}\n}", "target": 0}
{"code": "archive_read_format_rar_read_data(struct archive_read *a, const void **buff,\n                                  size_t *size, int64_t *offset)\n{\n  struct rar *rar = (struct rar *)(a->format->data);\n  int ret;\n  if (rar->has_encrypted_entries == ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW) {\n\t  rar->has_encrypted_entries = 0;\n  }\n  if (rar->bytes_unconsumed > 0) {\n      __archive_read_consume(a, rar->bytes_unconsumed);\n      rar->bytes_unconsumed = 0;\n  }\n  *buff = NULL;\n  if (rar->entry_eof || rar->offset_seek >= rar->unp_size) {\n    *size = 0;\n    *offset = rar->offset;\n    if (*offset < rar->unp_size)\n      *offset = rar->unp_size;\n    return (ARCHIVE_EOF);\n  }\n  switch (rar->compression_method)\n  {\n  case COMPRESS_METHOD_STORE:\n    ret = read_data_stored(a, buff, size, offset);\n    break;\n  case COMPRESS_METHOD_FASTEST:\n  case COMPRESS_METHOD_FAST:\n  case COMPRESS_METHOD_NORMAL:\n  case COMPRESS_METHOD_GOOD:\n  case COMPRESS_METHOD_BEST:\n    ret = read_data_compressed(a, buff, size, offset);\n    if (ret != ARCHIVE_OK && ret != ARCHIVE_WARN)\n      __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context);\n    break;\n  default:\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Unsupported compression method for RAR file.\");\n    ret = ARCHIVE_FATAL;\n    break;\n  }\n  return (ret);\n}", "target": 1}
{"code": "void common_timer_get(struct k_itimer *timr, struct itimerspec64 *cur_setting)\n{\n\tconst struct k_clock *kc = timr->kclock;\n\tktime_t now, remaining, iv;\n\tstruct timespec64 ts64;\n\tbool sig_none;\n\tsig_none = timr->it_sigev_notify == SIGEV_NONE;\n\tiv = timr->it_interval;\n\tif (iv) {\n\t\tcur_setting->it_interval = ktime_to_timespec64(iv);\n\t} else if (!timr->it_active) {\n\t\tif (!sig_none)\n\t\t\treturn;\n\t}\n\tkc->clock_get(timr->it_clock, &ts64);\n\tnow = timespec64_to_ktime(ts64);\n\tif (iv && (timr->it_requeue_pending & REQUEUE_PENDING || sig_none))\n\t\ttimr->it_overrun += (int)kc->timer_forward(timr, now);\n\tremaining = kc->timer_remaining(timr, now);\n\tif (remaining <= 0) {\n\t\tif (!sig_none)\n\t\t\tcur_setting->it_value.tv_nsec = 1;\n\t} else {\n\t\tcur_setting->it_value = ktime_to_timespec64(remaining);\n\t}\n}", "target": 1}
{"code": "AP_DECLARE(void) ap_update_vhost_from_headers(request_rec *r)\n{\n    core_server_config *conf = ap_get_core_module_config(r->server->module_config);\n    const char *host_header = apr_table_get(r->headers_in, \"Host\");\n    int is_v6literal = 0;\n    int have_hostname_from_url = 0;\n    if (r->hostname) {\n        have_hostname_from_url = 1;\n        is_v6literal = fix_hostname(r, NULL, conf->http_conformance);\n    }\n    else if (host_header != NULL) {\n        is_v6literal = fix_hostname(r, host_header, conf->http_conformance);\n    }\n    if (r->status != HTTP_OK)\n        return;\n    if (conf->http_conformance != AP_HTTP_CONFORMANCE_UNSAFE) {\n        if (have_hostname_from_url && host_header != NULL) {\n            const char *repl = construct_host_header(r, is_v6literal);\n            apr_table_setn(r->headers_in, \"Host\", repl);\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02417)\n                          \"Replacing host header '%s' with host '%s' given \"\n                          \"in the request uri\", host_header, repl);\n        }\n    }\n    if (r->connection->vhost_lookup_data) {\n        if (r->hostname)\n            check_hostalias(r);\n        else\n            check_serverpath(r);\n    }\n}", "target": 1}
{"code": "static struct dentry *bad_inode_lookup(struct inode *dir,\n\t\t\tstruct dentry *dentry, struct nameidata *nd)\n{\n\treturn ERR_PTR(-EIO);\n}", "target": 0}
{"code": "char* _multi_string_alloc_and_copy( LPCWSTR in )\n{\n    char *chr;\n    int len = 0;\n    if ( !in )\n    {\n        return in;\n    }\n    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )\n    {\n        len ++;\n    }\n    chr = malloc( len + 2 );\n    len = 0;\n    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )\n    {\n        chr[ len ] = 0xFF & in[ len ];\n        len ++;\n    }\n    chr[ len ++ ] = '\\0';\n    chr[ len ++ ] = '\\0';\n    return chr;\n}", "target": 1}
{"code": "atm_if_print(netdissect_options *ndo,\n             const struct pcap_pkthdr *h, const u_char *p)\n{\n\tu_int caplen = h->caplen;\n\tu_int length = h->len;\n\tuint32_t llchdr;\n\tu_int hdrlen = 0;\n\tif (caplen < 1 || length < 1) {\n\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\treturn (caplen);\n\t}\n        if (*p == LLC_UI) {\n            if (ndo->ndo_eflag)\n                ND_PRINT((ndo, \"CNLPID \"));\n            isoclns_print(ndo, p + 1, length - 1, caplen - 1);\n            return hdrlen;\n        }\n\tif (caplen < 3 || length < 3) {\n\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\treturn (caplen);\n\t}\n\tllchdr = EXTRACT_24BITS(p);\n\tif (llchdr != LLC_UI_HDR(LLCSAP_SNAP) &&\n\t    llchdr != LLC_UI_HDR(LLCSAP_ISONS) &&\n\t    llchdr != LLC_UI_HDR(LLCSAP_IP)) {\n\t\tif (caplen < 20 || length < 20) {\n\t\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\t\treturn (caplen);\n\t\t}\n\t\tif (ndo->ndo_eflag)\n\t\t\tND_PRINT((ndo, \"%08x%08x %08x%08x \",\n\t\t\t       EXTRACT_32BITS(p),\n\t\t\t       EXTRACT_32BITS(p+4),\n\t\t\t       EXTRACT_32BITS(p+8),\n\t\t\t       EXTRACT_32BITS(p+12)));\n\t\tp += 20;\n\t\tlength -= 20;\n\t\tcaplen -= 20;\n\t\thdrlen += 20;\n\t}\n\thdrlen += atm_llc_print(ndo, p, length, caplen);\n\treturn (hdrlen);\n}", "target": 1}
{"code": "static void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)\n{\n\tconst struct sched_class *class;\n\tif (p->sched_class == rq->curr->sched_class) {\n\t\trq->curr->sched_class->check_preempt_curr(rq, p, flags);\n\t} else {\n\t\tfor_each_class(class) {\n\t\t\tif (class == rq->curr->sched_class)\n\t\t\t\tbreak;\n\t\t\tif (class == p->sched_class) {\n\t\t\t\tresched_task(rq->curr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (test_tsk_need_resched(rq->curr))\n\t\trq->skip_clock_update = 1;\n}", "target": 1}
{"code": "void key_set_timeout(struct key *key, unsigned timeout)\n{\n\tstruct timespec now;\n\ttime_t expiry = 0;\n\tdown_write(&key->sem);\n\tif (timeout > 0) {\n\t\tnow = current_kernel_time();\n\t\texpiry = now.tv_sec + timeout;\n\t}\n\tkey->expiry = expiry;\n\tkey_schedule_gc(key->expiry + key_gc_delay);\n\tup_write(&key->sem);\n}", "target": 0}
{"code": "iasecc_chv_verify(struct sc_card *card, struct sc_pin_cmd_data *pin_cmd,\n\t\tint *tries_left)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_acl_entry acl = pin_cmd->pin1.acls[IASECC_ACLS_CHV_VERIFY];\n\tstruct sc_apdu apdu;\n\tint rv;\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"Verify CHV PIN(ref:%i,len:%i,acl:%X:%X)\", pin_cmd->pin_reference, pin_cmd->pin1.len,\n\t\t\tacl.method, acl.key_ref);\n\tif (acl.method & IASECC_SCB_METHOD_SM)   {\n\t\trv = iasecc_sm_pin_verify(card, acl.key_ref, pin_cmd, tries_left);\n\t\tLOG_FUNC_RETURN(ctx, rv);\n\t}\n\tif (pin_cmd->pin1.data && !pin_cmd->pin1.len)   {\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_1, 0x20, 0, pin_cmd->pin_reference);\n\t}\n\telse if (pin_cmd->pin1.data && pin_cmd->pin1.len)   {\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x20, 0, pin_cmd->pin_reference);\n\t\tapdu.data = pin_cmd->pin1.data;\n\t\tapdu.datalen = pin_cmd->pin1.len;\n\t\tapdu.lc = pin_cmd->pin1.len;\n\t}\n\telse if ((card->reader->capabilities & SC_READER_CAP_PIN_PAD) && !pin_cmd->pin1.data && !pin_cmd->pin1.len)   {\n\t\trv = iasecc_chv_verify_pinpad(card, pin_cmd, tries_left);\n\t\tsc_log(ctx, \"Result of verifying CHV with PIN pad %i\", rv);\n\t\tLOG_FUNC_RETURN(ctx, rv);\n\t}\n\telse   {\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);\n\t}\n\trv = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\tif (tries_left && apdu.sw1 == 0x63 && (apdu.sw2 & 0xF0) == 0xC0)\n\t\t*tries_left = apdu.sw2 & 0x0F;\n\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_FUNC_RETURN(ctx, rv);\n}", "target": 0}
{"code": "ts_date_hmsfrac_print(netdissect_options *ndo, long sec, long usec,\n\t\t      enum date_flag date_flag, enum time_flag time_flag)\n{\n\ttime_t Time = sec;\n\tstruct tm *tm;\n\tchar timestr[32];\n\tif ((unsigned)sec & 0x80000000) {\n\t\tND_PRINT(\"[Error converting time]\");\n\t\treturn;\n\t}\n\tif (time_flag == LOCAL_TIME)\n\t\ttm = localtime(&Time);\n\telse\n\t\ttm = gmtime(&Time);\n\tif (!tm) {\n\t\tND_PRINT(\"[Error converting time]\");\n\t\treturn;\n\t}\n\tif (date_flag == WITH_DATE)\n\t\tstrftime(timestr, sizeof(timestr), \"%Y-%m-%d %H:%M:%S\", tm);\n\telse\n\t\tstrftime(timestr, sizeof(timestr), \"%H:%M:%S\", tm);\n\tND_PRINT(\"%s\", timestr);\n\tts_frac_print(ndo, usec);\n}", "target": 1}
{"code": "git_filemode_t git_tree_entry_filemode(const git_tree_entry *entry)\n{\n\treturn normalize_filemode(entry->attr);\n}", "target": 0}
{"code": "BOOL freerdp_bitmap_planar_context_reset(BITMAP_PLANAR_CONTEXT* context, UINT32 width,\n                                         UINT32 height)\n{\n\tif (!context)\n\t\treturn FALSE;\n\tcontext->bgr = FALSE;\n\tcontext->maxWidth = PLANAR_ALIGN(width, 4);\n\tcontext->maxHeight = PLANAR_ALIGN(height, 4);\n\tcontext->maxPlaneSize = context->maxWidth * context->maxHeight;\n\tcontext->nTempStep = context->maxWidth * 4;\n\tvoid* tmp = winpr_aligned_recalloc(context->planesBuffer, context->maxPlaneSize, 4, 32);\n\tif (!tmp)\n\t\treturn FALSE;\n\tcontext->planesBuffer = tmp;\n\ttmp = winpr_aligned_recalloc(context->pTempData, context->maxPlaneSize, 6, 32);\n\tif (!tmp)\n\t\treturn FALSE;\n\tcontext->pTempData = tmp;\n\ttmp = winpr_aligned_recalloc(context->deltaPlanesBuffer, context->maxPlaneSize, 4, 32);\n\tif (!tmp)\n\t\treturn FALSE;\n\tcontext->deltaPlanesBuffer = tmp;\n\ttmp = winpr_aligned_recalloc(context->rlePlanesBuffer, context->maxPlaneSize, 4, 32);\n\tif (!tmp)\n\t\treturn FALSE;\n\tcontext->rlePlanesBuffer = tmp;\n\tcontext->planes[0] = &context->planesBuffer[context->maxPlaneSize * 0];\n\tcontext->planes[1] = &context->planesBuffer[context->maxPlaneSize * 1];\n\tcontext->planes[2] = &context->planesBuffer[context->maxPlaneSize * 2];\n\tcontext->planes[3] = &context->planesBuffer[context->maxPlaneSize * 3];\n\tcontext->deltaPlanes[0] = &context->deltaPlanesBuffer[context->maxPlaneSize * 0];\n\tcontext->deltaPlanes[1] = &context->deltaPlanesBuffer[context->maxPlaneSize * 1];\n\tcontext->deltaPlanes[2] = &context->deltaPlanesBuffer[context->maxPlaneSize * 2];\n\tcontext->deltaPlanes[3] = &context->deltaPlanesBuffer[context->maxPlaneSize * 3];\n\treturn TRUE;\n}", "target": 1}
{"code": "static bool vtable_is_addr_vtable_start_msvc(RVTableContext *context, ut64 curAddress) {\n\tRAnalRef *xref;\n\tRListIter *xrefIter;\n\tif (!curAddress || curAddress == UT64_MAX) {\n\t\treturn false;\n\t}\n\tif (curAddress && !vtable_is_value_in_text_section (context, curAddress, NULL)) {\n\t\treturn false;\n\t}\n\tRList *xrefs = r_anal_xrefs_get (context->anal, curAddress);\n\tif (r_list_empty (xrefs)) {\n\t\tr_list_free (xrefs);\n\t\treturn false;\n\t}\n\tr_list_foreach (xrefs, xrefIter, xref) {\n\t\tif (vtable_addr_in_text_section (context, xref->addr)) {\n\t\t\tut8 buf[VTABLE_BUFF_SIZE];\n\t\t\tcontext->anal->iob.read_at (context->anal->iob.io, xref->addr, buf, sizeof(buf));\n\t\t\tRAnalOp analop = {0};\n\t\t\tr_anal_op (context->anal, &analop, xref->addr, buf, sizeof(buf), R_ANAL_OP_MASK_BASIC);\n\t\t\tif (analop.type == R_ANAL_OP_TYPE_MOV\n\t\t\t\t|| analop.type == R_ANAL_OP_TYPE_LEA) {\n\t\t\t\tr_list_free (xrefs);\n\t\t\t\tr_anal_op_fini (&analop);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tr_anal_op_fini (&analop);\n\t\t}\n\t}\n\tr_list_free (xrefs);\n\treturn false;\n}", "target": 1}
{"code": "inline TfLiteTensor* GetMutableInput(const TfLiteContext* context,\n                                     const TfLiteNode* node, int index) {\n  const int tensor_index = ValidateTensorIndexing(\n      context, index, node->inputs->size, node->inputs->data);\n  if (tensor_index < 0) {\n    return nullptr;\n  }\n  return GetTensorAtIndex(context, tensor_index);\n}", "target": 0}
{"code": "static unsigned short get_tga_ushort(const unsigned char *data)\n{\n    return data[0] | (data[1] << 8);\n}", "target": 0}
{"code": "void PrintWebViewHelper::PrintPreviewContext::set_error(\n    enum PrintPreviewErrorBuckets error) {\n  error_ = error;\n}", "target": 0}
{"code": "char *uwsgi_expand_path(char *dir, int dir_len, char *ptr) {\n\tchar src[PATH_MAX + 1];\n\tmemcpy(src, dir, dir_len);\n\tsrc[dir_len] = 0;\n\tchar *dst = ptr;\n\tif (!dst)\n\t\tdst = uwsgi_malloc(PATH_MAX + 1);\n\tif (!realpath(src, dst)) {\n\t\tuwsgi_error_realpath(src);\n\t\tif (!ptr)\n\t\t\tfree(dst);\n\t\treturn NULL;\n\t}\n\treturn dst;\n}", "target": 1}
{"code": "static const char *jsi_evalprint(Jsi_Value *v)\n{\n    static char buf[100];\n    if (!v)\n        return \"nil\";\n    if (v->vt == JSI_VT_NUMBER) {\n        snprintf(buf, 100, \"NUM:%\" JSI_NUMGFMT \" \", v->d.num);\n    } else if (v->vt == JSI_VT_BOOL) {\n        snprintf(buf, 100, \"BOO:%d\", v->d.val);\n    } else if (v->vt == JSI_VT_STRING) {\n        snprintf(buf, 100, \"STR:'%s'\", v->d.s.str);\n    } else if (v->vt == JSI_VT_VARIABLE) {\n        snprintf(buf, 100, \"VAR:%p\", v->d.lval);\n    } else if (v->vt == JSI_VT_NULL) {\n        snprintf(buf, 100, \"NULL\");\n    } else if (v->vt == JSI_VT_OBJECT) {\n        snprintf(buf, 100, \"OBJ:%p\", v->d.obj);\n    } else if (v->vt == JSI_VT_UNDEF) {\n        snprintf(buf, 100, \"UNDEFINED\");\n    }\n    return buf;\n}", "target": 1}
{"code": "PBKDF2_SHA256(const uint8_t * passwd, size_t passwdlen, const uint8_t * salt,\n    size_t saltlen, uint64_t c, uint8_t * buf, size_t dkLen)\n{\n  struct HMAC_SHA256_CTX PShctx, hctx;\n  size_t i;\n  uint8_t ivec[4];\n  uint32_t *ivec_p;\n  uint8_t U[32];\n  uint8_t T[32];\n  uint64_t j;\n  int k;\n  size_t clen;\n  HMAC_SHA256_Init(&PShctx, passwd, passwdlen);\n  HMAC_SHA256_Update(&PShctx, salt, saltlen);\n  ivec_p = (uint32_t *) ivec;\n  for (i = 0; i * 32 < dkLen; i++) {\n    *ivec_p = folly::Endian::big32((uint32_t)(i + 1));\n    memcpy(&hctx, &PShctx, sizeof(struct HMAC_SHA256_CTX));\n    HMAC_SHA256_Update(&hctx, ivec, 4);\n    HMAC_SHA256_Final(U, &hctx);\n    memcpy(T, U, 32);\n    for (j = 2; j <= c; j++) {\n      HMAC_SHA256_Init(&hctx, passwd, passwdlen);\n      HMAC_SHA256_Update(&hctx, U, 32);\n      HMAC_SHA256_Final(U, &hctx);\n      for (k = 0; k < 32; k++)\n        T[k] ^= U[k];\n    }\n    clen = dkLen - i * 32;\n    if (clen > 32)\n      clen = 32;\n    memcpy(&buf[i * 32], T, clen);\n  }\n  memset(&PShctx, 0, sizeof(struct HMAC_SHA256_CTX));\n}", "target": 1}
{"code": "set_default_colour_sequences(void)\n{\n    fg_bg_sequences[COL_SEQ_FG].start = ztrdup(TC_COL_FG_START);\n    fg_bg_sequences[COL_SEQ_FG].end = ztrdup(TC_COL_FG_END);\n    fg_bg_sequences[COL_SEQ_FG].def = ztrdup(TC_COL_FG_DEFAULT);\n    fg_bg_sequences[COL_SEQ_BG].start = ztrdup(TC_COL_BG_START);\n    fg_bg_sequences[COL_SEQ_BG].end = ztrdup(TC_COL_BG_END);\n    fg_bg_sequences[COL_SEQ_BG].def = ztrdup(TC_COL_BG_DEFAULT);\n}", "target": 0}
{"code": "is_apple_double (const char *name)\n{\n\tchar *basename;\n\tgboolean ret = FALSE;\n\tbasename = g_path_get_basename (name);\n\tif (basename == NULL) {\n\t\tg_debug (\"Filename '%s' doesn't have a basename?\", name);\n\t\treturn ret;\n\t}\n\tret = g_str_has_prefix (basename, APPLE_DOUBLE_PREFIX);\n\tg_free (basename);\n\treturn ret;\n}", "target": 0}
{"code": "static void sas_destruct_ports(struct asd_sas_port *port)\n{\n\tstruct sas_port *sas_port, *p;\n\tlist_for_each_entry_safe(sas_port, p, &port->sas_port_del_list, del_list) {\n\t\tlist_del_init(&sas_port->del_list);\n\t\tsas_port_delete(sas_port);\n\t}\n}", "target": 0}
{"code": "static int swevent_hlist_get_cpu(struct perf_event *event, int cpu)\n{\n\tstruct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);\n\tint err = 0;\n\tmutex_lock(&swhash->hlist_mutex);\n\tif (!swevent_hlist_deref(swhash) && cpu_online(cpu)) {\n\t\tstruct swevent_hlist *hlist;\n\t\thlist = kzalloc(sizeof(*hlist), GFP_KERNEL);\n\t\tif (!hlist) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto exit;\n\t\t}\n\t\trcu_assign_pointer(swhash->swevent_hlist, hlist);\n\t}\n\tswhash->hlist_refcount++;\nexit:\n\tmutex_unlock(&swhash->hlist_mutex);\n\treturn err;\n}", "target": 1}
{"code": "gs_malloc_init(void)\n{\n    gs_malloc_memory_t *malloc_memory_default = gs_malloc_memory_init();\n    gs_memory_t *memory_t_default;\n    if (malloc_memory_default == NULL)\n        return NULL;\n    if (gs_lib_ctx_init((gs_memory_t *)malloc_memory_default) != 0)\n        return NULL;\n#if defined(USE_RETRY_MEMORY_WRAPPER)\n    gs_malloc_wrap(&memory_t_default, malloc_memory_default);\n#else\n    memory_t_default = (gs_memory_t *)malloc_memory_default;\n#endif\n    memory_t_default->stable_memory = memory_t_default;\n    return memory_t_default;\n}", "target": 0}
{"code": "}\nGF_Err jp2h_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read_ex(s, bs, jp2h_on_child_box, s->type);", "target": 0}
{"code": "static void sig_int_handler(int sig) {\n  struct sigaction *old = NULL;\n  switch (sig) {\n#if !FIO_DISABLE_HOT_RESTART\n  case SIGUSR1:\n    fio_signal_children_flag = 1;\n    old = &fio_old_sig_usr1;\n    break;\n#endif\n  case SIGINT:\n    if (!old)\n      old = &fio_old_sig_int;\n  case SIGTERM:\n    if (!old)\n      old = &fio_old_sig_term;\n    fio_stop();\n    break;\n  case SIGPIPE:\n    if (!old)\n      old = &fio_old_sig_pipe;\n  default:\n    break;\n  }\n  if (old->sa_handler != SIG_IGN && old->sa_handler != SIG_DFL)\n    old->sa_handler(sig);\n}", "target": 1}
{"code": "static void mctp_unregister(struct net_device *dev)\n{\n\tstruct mctp_dev *mdev;\n\tmdev = mctp_dev_get_rtnl(dev);\n\tif (mdev && !mctp_known(dev)) {\n\t\tnetdev_warn(dev, \"%s: BUG mctp_ptr set for unknown type %d\",\n\t\t\t    __func__, dev->type);\n\t\treturn;\n\t}\n\tif (!mdev)\n\t\treturn;\n\tRCU_INIT_POINTER(mdev->dev->mctp_ptr, NULL);\n\tmctp_route_remove_dev(mdev);\n\tmctp_neigh_remove_dev(mdev);\n\tkfree(mdev->addrs);\n\tmctp_dev_put(mdev);\n}", "target": 1}
{"code": "int __cil_build_ast_first_child_helper(__attribute__((unused)) struct cil_tree_node *parse_current, void *extra_args)\n{\n\tstruct cil_args_build *args = extra_args;\n\tstruct cil_tree_node *ast = args->ast;\n\tif (ast->flavor == CIL_TUNABLEIF) {\n\t\targs->tunif = ast;\n\t}\n\tif (ast->flavor == CIL_IN) {\n\t\targs->in = ast;\n\t}\n\tif (ast->flavor == CIL_MACRO) {\n\t\targs->macro = ast;\n\t}\n\tif (ast->flavor == CIL_OPTIONAL) {\n\t\targs->optional = ast;\n\t}\n\tif (ast->flavor == CIL_BOOLEANIF) {\n\t\targs->boolif = ast;\n\t}\n\treturn SEPOL_OK;\n}", "target": 0}
{"code": "PHPAPI char *php_unescape_html_entities(unsigned char *old, size_t oldlen, size_t *newlen, int all, int flags, char *hint_charset TSRMLS_DC)\n{\n\tsize_t retlen;\n\tchar *ret;\n\tenum entity_charset charset;\n\tconst entity_ht *inverse_map = NULL;\n\tsize_t new_size = TRAVERSE_FOR_ENTITIES_EXPAND_SIZE(oldlen);\n\tif (all) {\n\t\tcharset = determine_charset(hint_charset TSRMLS_CC);\n\t} else {\n\t\tcharset = cs_8859_1; \n\t}\n\tif (oldlen > new_size) {\n\t\tret = estrndup((char*)old, oldlen);\n\t\tretlen = oldlen;\n\t\tgoto empty_source;\n\t}\n\tret = emalloc(new_size);\n\t*ret = '\\0';\n\tretlen = oldlen;\n\tif (retlen == 0) {\n\t\tgoto empty_source;\n\t}\n\tinverse_map = unescape_inverse_map(all, flags);\n\ttraverse_for_entities(old, oldlen, ret, &retlen, all, flags, inverse_map, charset);\nempty_source:\t\n\t*newlen = retlen;\n\treturn ret;\n}", "target": 1}
{"code": "IOBasicTypes::LongBufferSizeType ObjectByteWriterWithPosition::Write(const IOBasicTypes::Byte* inBuffer,IOBasicTypes::LongBufferSizeType inBufferSize)\n{\n\tCREATE_ISOLATE_CONTEXT;\n\tCREATE_ESCAPABLE_SCOPE;\n    Local<Object> anArray = NEW_ARRAY((int)inBufferSize);\n    for(int i=0;i<(int)inBufferSize;++i)\n        anArray->Set(GET_CURRENT_CONTEXT, NEW_NUMBER(i),NEW_NUMBER(inBuffer[i]));\n\tLocal<Value> value = OBJECT_FROM_PERSISTENT(mObject)->Get(GET_CURRENT_CONTEXT, NEW_STRING(\"write\")).ToLocalChecked();\n    if(value->IsUndefined() || !value->IsFunction())\n    {\n\t\tTHROW_EXCEPTION(\"write is not a function, it should be you know...\");\n        return 0;\n    }\n    Local<Function> func = Local<Function>::Cast(value);\n    Local<Value> args[1];\n    args[0] = anArray;\n\tLocal<Value> result = func->Call(GET_CURRENT_CONTEXT,  OBJECT_FROM_PERSISTENT(mObject), 1, args).ToLocalChecked();\n    if(result.IsEmpty())\n    {\n\t\tTHROW_EXCEPTION(\"wrong return value. it's empty. return the number of written characters\");\n\t\treturn 0;\n    }\n    else if(result->IsNumber())\n    {\n        return TO_UINT32(result)->Value();\n    }\n    else\n    {\n\t\tTHROW_EXCEPTION(\"wrong return value. write should return the number of written characters\");\n\t\treturn 0;\n    }\n}", "target": 1}
{"code": "vq_is_ready(struct vhost_virtqueue *vq)\n{\n\treturn vq && vq->desc && vq->avail && vq->used &&\n\t       vq->kickfd != VIRTIO_UNINITIALIZED_EVENTFD &&\n\t       vq->callfd != VIRTIO_UNINITIALIZED_EVENTFD;\n}", "target": 0}
{"code": "int devmem_is_allowed(unsigned long pagenr)\n{\n\tif (pagenr < 256)\n\t\treturn 1;\n\tif (iomem_is_exclusive(pagenr << PAGE_SHIFT))\n\t\treturn 0;\n\tif (!page_is_ram(pagenr))\n\t\treturn 1;\n\treturn 0;\n}", "target": 1}
{"code": "static int zipfileRollback(sqlite3_vtab *pVtab){\n  return zipfileCommit(pVtab);\n}", "target": 0}
{"code": "pk_transaction_finished_emit (PkTransaction *transaction,\n\t\t\t      PkExitEnum exit_enum,\n\t\t\t      guint time_ms)\n{\n\tg_assert (!transaction->priv->emitted_finished);\n\ttransaction->priv->emitted_finished = TRUE;\n\tg_debug (\"emitting finished '%s', %i\",\n\t\t pk_exit_enum_to_string (exit_enum),\n\t\t time_ms);\n\tg_dbus_connection_emit_signal (transaction->priv->connection,\n\t\t\t\t       NULL,\n\t\t\t\t       transaction->priv->tid,\n\t\t\t\t       PK_DBUS_INTERFACE_TRANSACTION,\n\t\t\t\t       \"Finished\",\n\t\t\t\t       g_variant_new (\"(uu)\",\n\t\t\t\t\t\t      exit_enum,\n\t\t\t\t\t\t      time_ms),\n\t\t\t\t       NULL);\n\tg_signal_emit (transaction, signals[SIGNAL_FINISHED], 0);\n}", "target": 0}
{"code": "GF_Err dOps_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_OpusSpecificBox *ptr = (GF_OpusSpecificBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs,  0);\n\tgf_bs_write_u8(bs, ptr->opcfg.OutputChannelCount);\n\tgf_bs_write_u16(bs, ptr->opcfg.PreSkip);\n\tgf_bs_write_u32(bs, ptr->opcfg.InputSampleRate);\n\tgf_bs_write_u16(bs, ptr->opcfg.OutputGain);\n\tgf_bs_write_u8(bs, ptr->opcfg.ChannelMappingFamily);\n\tif (ptr->opcfg.ChannelMappingFamily) {\n\t\tgf_bs_write_u8(bs, ptr->opcfg.StreamCount);\n\t\tgf_bs_write_u8(bs, ptr->opcfg.CoupledCount);\n\t\tgf_bs_write_data(bs, (char *) ptr->opcfg.ChannelMapping, ptr->opcfg.OutputChannelCount);\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "  static void operator delete(void *, MEM_ROOT*) {}", "target": 0}
{"code": "void JNIid::deallocate(JNIid* current) {\n  while (current != NULL) {\n    JNIid* next = current->next();\n    delete current;\n    current = next;\n  }\n}", "target": 0}
{"code": "JSON_read(int fd)\n{\n    uint32_t hsize, nsize;\n    char *str;\n    cJSON *json = NULL;\n    int rc;\n    if (Nread(fd, (char*) &nsize, sizeof(nsize), Ptcp) >= 0) {\n\thsize = ntohl(nsize);\n\tstr = (char *) calloc(sizeof(char), hsize+1);\t\n\tif (str != NULL) {\n\t    rc = Nread(fd, str, hsize, Ptcp);\n\t    if (rc >= 0) {\n\t\tif (rc == hsize) {\n\t\t    json = cJSON_Parse(str);\n\t\t}\n\t\telse {\n\t\t    printf(\"WARNING:  Size of data read does not correspond to offered length\\n\");\n\t\t}\n\t    }\n\t}\n\tfree(str);\n    }\n    return json;\n}", "target": 1}
{"code": "SYSCALL_DEFINE1(inotify_init1, int, flags)\n{\n\tstruct fsnotify_group *group;\n\tint ret;\n\tBUILD_BUG_ON(IN_CLOEXEC != O_CLOEXEC);\n\tBUILD_BUG_ON(IN_NONBLOCK != O_NONBLOCK);\n\tif (flags & ~(IN_CLOEXEC | IN_NONBLOCK))\n\t\treturn -EINVAL;\n\tgroup = inotify_new_group(inotify_max_queued_events);\n\tif (IS_ERR(group))\n\t\treturn PTR_ERR(group);\n\tret = anon_inode_getfd(\"inotify\", &inotify_fops, group,\n\t\t\t\t  O_RDONLY | flags);\n\tif (ret < 0)\n\t\tfsnotify_put_group(group);\n\treturn ret;\n}", "target": 0}
{"code": "TypedValue HHVM_FUNCTION(array_uintersect,\n                         const Variant& array1,\n                         const Variant& array2,\n                         const Variant& data_compare_func,\n                         const Array& args ) {\n  Variant func = data_compare_func;\n  Array extra = args;\n  if (!extra.empty()) {\n    extra.prepend(func);\n    func = extra.pop();\n  }\n  diff_intersect_body(intersect, extra, false COMMA true COMMA NULL COMMA NULL\n                      COMMA cmp_func COMMA &func);\n}", "target": 0}
{"code": "Opal::Call::emit_established_in_main ()\n{\n  established ();\n}", "target": 0}
{"code": "ikev1_ke_print(netdissect_options *ndo, u_char tpay _U_,\n\t       const struct isakmp_gen *ext, u_int item_len _U_,\n\t       const u_char *ep _U_, uint32_t phase _U_, uint32_t doi _U_,\n\t       uint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_KE)));\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" key len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_KE)));\n\treturn NULL;\n}", "target": 0}
{"code": "void LIRGenerator::do_NegateOp(NegateOp* x) {\n  LIRItem value(x->x(), this);\n  value.set_destroys_register();\n  value.load_item();\n  LIR_Opr reg = rlock(x);\n  LIR_Opr tmp = LIR_OprFact::illegalOpr;\n#ifdef _LP64\n  if (UseAVX > 2 && !VM_Version::supports_avx512vl()) {\n    if (x->type()->tag() == doubleTag) {\n      tmp = new_register(T_DOUBLE);\n      __ move(LIR_OprFact::doubleConst(-0.0), tmp);\n    }\n    else if (x->type()->tag() == floatTag) {\n      tmp = new_register(T_FLOAT);\n      __ move(LIR_OprFact::floatConst(-0.0), tmp);\n    }\n  }\n#endif\n  __ negate(value.result(), reg, tmp);\n  set_result(x, round_item(reg));\n}", "target": 0}
{"code": "_archive_write_disk_close(struct archive *_a)\n{\n\tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n\tstruct fixup_entry *next, *p;\n\tint fd, ret;\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,\n\t    ARCHIVE_STATE_HEADER | ARCHIVE_STATE_DATA,\n\t    \"archive_write_disk_close\");\n\tret = _archive_write_disk_finish_entry(&a->archive);\n\tp = sort_dir_list(a->fixup_list);\n\twhile (p != NULL) {\n\t\tfd = -1;\n\t\ta->pst = NULL; \n\t\tif (p->fixup &\n\t\t    (TODO_TIMES | TODO_MODE_BASE | TODO_ACLS | TODO_FFLAGS)) {\n\t\t\tfd = open(p->name,\n\t\t\t    O_WRONLY | O_BINARY | O_NOFOLLOW | O_CLOEXEC);\n\t\t}\n\t\tif (p->fixup & TODO_TIMES) {\n\t\t\tset_times(a, fd, p->mode, p->name,\n\t\t\t    p->atime, p->atime_nanos,\n\t\t\t    p->birthtime, p->birthtime_nanos,\n\t\t\t    p->mtime, p->mtime_nanos,\n\t\t\t    p->ctime, p->ctime_nanos);\n\t\t}\n\t\tif (p->fixup & TODO_MODE_BASE) {\n#ifdef HAVE_FCHMOD\n\t\t\tif (fd >= 0)\n\t\t\t\tfchmod(fd, p->mode);\n\t\t\telse\n#endif\n\t\t\tchmod(p->name, p->mode);\n\t\t}\n\t\tif (p->fixup & TODO_ACLS)\n\t\t\tarchive_write_disk_set_acls(&a->archive, fd,\n\t\t\t    p->name, &p->acl, p->mode);\n\t\tif (p->fixup & TODO_FFLAGS)\n\t\t\tset_fflags_platform(a, fd, p->name,\n\t\t\t    p->mode, p->fflags_set, 0);\n\t\tif (p->fixup & TODO_MAC_METADATA)\n\t\t\tset_mac_metadata(a, p->name, p->mac_metadata,\n\t\t\t\t\t p->mac_metadata_size);\n\t\tnext = p->next;\n\t\tarchive_acl_clear(&p->acl);\n\t\tfree(p->mac_metadata);\n\t\tfree(p->name);\n\t\tif (fd >= 0)\n\t\t\tclose(fd);\n\t\tfree(p);\n\t\tp = next;\n\t}\n\ta->fixup_list = NULL;\n\treturn (ret);\n}", "target": 1}
{"code": "    FIO_NAME(_find_map_pos_)(FIO_NAME(s) * set, FIO_SET_HASH_TYPE hash_value,\n                             FIO_SET_TYPE obj) {\n  if (FIO_SET_HASH_COMPARE(hash_value, FIO_SET_HASH_INVALID))\n    hash_value = FIO_SET_HASH_FORCE;\n  if (set->map) {\n    if (set->has_collisions && set->pos != set->count) {\n      FIO_NAME(rehash)(set);\n    }\n    size_t full_collisions_counter = 0;\n    FIO_NAME(_map_s_) * pos;\n    const uintptr_t mask = (1ULL << set->used_bits) - 1;\n    uintptr_t i;\n    const uintptr_t hash_value_i = FIO_SET_HASH2UINTPTR(hash_value, 0);\n    uintptr_t hash_alt = FIO_SET_HASH2UINTPTR(hash_value, set->used_bits);\n    pos = set->map + (hash_alt & mask);\n    if (FIO_SET_HASH_COMPARE(FIO_SET_HASH_INVALID, pos->hash))\n      return pos;\n    if (FIO_SET_HASH_COMPARE(pos->hash, hash_value_i)) {\n      if (!pos->pos || FIO_SET_COMPARE(pos->pos->obj, obj))\n        return pos;\n      set->has_collisions = 1;\n      ++full_collisions_counter;\n    }\n    i = 0;\n    const uintptr_t limit =\n        FIO_SET_CUCKOO_STEPS * (set->capa > (FIO_SET_MAX_MAP_SEEK << 2)\n                                    ? FIO_SET_MAX_MAP_SEEK\n                                    : (set->capa >> 2));\n    while (i < limit) {\n      i += FIO_SET_CUCKOO_STEPS;\n      pos = set->map + ((hash_alt + i) & mask);\n      if (FIO_SET_HASH_COMPARE(FIO_SET_HASH_INVALID, pos->hash))\n        return pos;\n      if (FIO_SET_HASH_COMPARE(pos->hash, hash_value_i)) {\n        if (!pos->pos || FIO_SET_COMPARE(pos->pos->obj, obj))\n          return pos;\n        set->has_collisions = 1;\n        if (++full_collisions_counter >= FIO_SET_MAX_MAP_FULL_COLLISIONS) {\n          FIO_LOG_WARNING(\n              \"(fio hash map) too many full collisions - under attack?\");\n          set->under_attack = 1;\n        }\n        if (set->under_attack) {\n          return pos;\n        }\n      }\n    }\n  }\n  return NULL;\n  (void)obj; \n}", "target": 1}
{"code": "cmsBool  CMSEXPORT cmsAppendNamedColor(cmsNAMEDCOLORLIST* NamedColorList,\n                                       const char* Name,\n                                       cmsUInt16Number PCS[3], cmsUInt16Number Colorant[cmsMAXCHANNELS])\n{\n    cmsUInt32Number i;\n    if (NamedColorList == NULL) return FALSE;\n    if (NamedColorList ->nColors + 1 > NamedColorList ->Allocated) {\n        if (!GrowNamedColorList(NamedColorList)) return FALSE;\n    }\n    for (i=0; i < NamedColorList ->ColorantCount; i++)\n        NamedColorList ->List[NamedColorList ->nColors].DeviceColorant[i] = Colorant == NULL? 0 : Colorant[i];\n    for (i=0; i < 3; i++)\n        NamedColorList ->List[NamedColorList ->nColors].PCS[i] = PCS == NULL ? 0 : PCS[i];\n    if (Name != NULL) {\n        strncpy(NamedColorList ->List[NamedColorList ->nColors].Name, Name,\n                    sizeof(NamedColorList ->List[NamedColorList ->nColors].Name));\n        NamedColorList ->List[NamedColorList ->nColors].Name[cmsMAX_PATH-1] = 0;\n    }\n    else\n        NamedColorList ->List[NamedColorList ->nColors].Name[0] = 0;\n    NamedColorList ->nColors++;\n    return TRUE;\n}", "target": 1}
{"code": "  bool has_dom_ui_bindings() const {\n    return BindingsPolicy::is_dom_ui_enabled(enabled_bindings_);\n  }", "target": 0}
{"code": "void common_timer_get(struct k_itimer *timr, struct itimerspec64 *cur_setting)\n{\n\tconst struct k_clock *kc = timr->kclock;\n\tktime_t now, remaining, iv;\n\tstruct timespec64 ts64;\n\tbool sig_none;\n\tsig_none = (timr->it_sigev_notify & ~SIGEV_THREAD_ID) == SIGEV_NONE;\n\tiv = timr->it_interval;\n\tif (iv) {\n\t\tcur_setting->it_interval = ktime_to_timespec64(iv);\n\t} else if (!timr->it_active) {\n\t\tif (!sig_none)\n\t\t\treturn;\n\t}\n\tkc->clock_get(timr->it_clock, &ts64);\n\tnow = timespec64_to_ktime(ts64);\n\tif (iv && (timr->it_requeue_pending & REQUEUE_PENDING || sig_none))\n\t\ttimr->it_overrun += kc->timer_forward(timr, now);\n\tremaining = kc->timer_remaining(timr, now);\n\tif (remaining <= 0) {\n\t\tif (!sig_none)\n\t\t\tcur_setting->it_value.tv_nsec = 1;\n\t} else {\n\t\tcur_setting->it_value = ktime_to_timespec64(remaining);\n\t}\n}", "target": 1}
{"code": "pam_converse (int num_msg, PAM_CONVERSE_ARG2_TYPE **msg,\n  struct pam_response **resp, void *appdata_ptr)\n{\nint sep = 0;\nstruct pam_response *reply;\nif (  pam_arg_ended\n   || !(reply = malloc(sizeof(struct pam_response) * num_msg)))\n  return PAM_CONV_ERR;\nfor (int i = 0; i < num_msg; i++)\n  {\n  uschar *arg;\n  switch (msg[i]->msg_style)\n    {\n    case PAM_PROMPT_ECHO_ON:\n    case PAM_PROMPT_ECHO_OFF:\n      if (!(arg = string_nextinlist(&pam_args, &sep, NULL, 0)))\n\t{\n\targ = US\"\";\n\tpam_arg_ended = TRUE;\n\t}\n      reply[i].resp = CS string_copy_malloc(arg); \n      reply[i].resp_retcode = PAM_SUCCESS;\n      break;\n    case PAM_TEXT_INFO:    \n    case PAM_ERROR_MSG:\n      reply[i].resp_retcode = PAM_SUCCESS;\n      reply[i].resp = NULL;\n      break;\n    default:  \n      free(reply);\n      pam_conv_had_error = TRUE;\n      return PAM_CONV_ERR;\n    }\n  }\n*resp = reply;\nreturn PAM_SUCCESS;\n}", "target": 1}
{"code": "      ECDSA_Signature_Operation(const ECDSA_PrivateKey& ecdsa,\n                                const std::string& emsa) :\n         PK_Ops::Signature_with_EMSA(emsa),\n         m_group(ecdsa.domain()),\n         m_x(ecdsa.private_value())\n         {\n#if defined(BOTAN_HAS_RFC6979_GENERATOR)\n         m_rfc6979_hash = hash_for_emsa(emsa);\n#endif\n         }", "target": 1}
{"code": "static void GTextFieldSaved(GTextField *gt) {\n    GEvent e;\n    e.type = et_controlevent;\n    e.w = gt->g.base;\n    e.u.control.subtype = et_save;\n    e.u.control.g = &gt->g;\n    if ( gt->g.handle_controlevent != NULL )\n\t(gt->g.handle_controlevent)(&gt->g,&e);\n    else\n\tGDrawPostEvent(&e);\n}", "target": 0}
{"code": "GF_Err tenc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu8 iv_size;\n\tGF_TrackEncryptionBox *ptr = (GF_TrackEncryptionBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 3);\n\tgf_bs_read_u8(bs); \n\tif (!ptr->version) {\n\t\tgf_bs_read_u8(bs); \n\t} else {\n\t\tptr->crypt_byte_block = gf_bs_read_int(bs, 4);\n\t\tptr->skip_byte_block = gf_bs_read_int(bs, 4);\n\t}\n\tptr->isProtected = gf_bs_read_u8(bs);\n\tISOM_DECREASE_SIZE(ptr, 17);\n\tptr->key_info[0] = 0;\n\tptr->key_info[1] = 0;\n\tptr->key_info[2] = 0;\n\tptr->key_info[3] = iv_size = gf_bs_read_u8(bs);\n\tgf_bs_read_data(bs, ptr->key_info+4, 16);\n\tif (!iv_size && ptr->isProtected) {\n\t\tISOM_DECREASE_SIZE(ptr, 1);\n\t\tiv_size = ptr->key_info[20] = gf_bs_read_u8(bs);\n\t\tISOM_DECREASE_SIZE(ptr, ptr->key_info[20]);\n\t\tif ((iv_size!=8) && (iv_size!=16)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid constant IV size %d, must be 8 or 16\\n\", (u32) iv_size));\n\t\t\tptr->key_info[20] = 16;\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tgf_bs_read_data(bs, ptr->key_info+21, iv_size);\n\t}\n\telse if ((iv_size!=0) && (iv_size!=8) && (iv_size!=16)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid IV size %d, must be 0, 8 or 16\\n\", (u32) iv_size));\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "setv4key_principal_2_svc(setv4key_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (!(CHANGEPW_SERVICE(rqstp)) &&\n        kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                           ACL_SETKEY, arg->princ, NULL)) {\n        ret.code = kadm5_setv4key_principal((void *)handle, arg->princ,\n                                            arg->keyblock);\n    } else {\n        log_unauth(\"kadm5_setv4key_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_SETKEY;\n    }\n    if(ret.code != KADM5_AUTH_SETKEY) {\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_setv4key_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "static void CorrectPhaseLHS(const size_t width,const size_t height,\n  double *fourier_pixels)\n{\n  register ssize_t\n    x;\n  ssize_t\n    y;\n  for (y=0L; y < (ssize_t) height; y++)\n    for (x=0L; x < (ssize_t) (width/2L); x++)\n      fourier_pixels[y*width+x]*=(-1.0);\n}", "target": 0}
{"code": "NavigatorServiceWorker::NavigatorServiceWorker(Navigator& navigator)\n    : DOMWindowProperty(navigator.frame())\n{\n}", "target": 0}
{"code": "static void apply_server_config(request_rec *r)\n{\n    apr_socket_t *csd;\n    csd = ap_get_conn_socket(r->connection);\n    apr_socket_timeout_set(csd, r->server->timeout);\n    r->per_dir_config = r->server->lookup_defaults;\n}", "target": 0}
{"code": "static bool do_write_pids(pid_t tpid, const char *contrl, const char *cg, const char *file, const char *buf)\n{\n\tint sock[2] = {-1, -1};\n\tpid_t qpid, cpid = -1;\n\tFILE *pids_file = NULL;\n\tbool answer = false, fail = false;\n\tpids_file = open_pids_file(contrl, cg);\n\tif (!pids_file)\n\t\treturn false;\n\tif (socketpair(AF_UNIX, SOCK_DGRAM, 0, sock) < 0) {\n\t\tperror(\"socketpair\");\n\t\tgoto out;\n\t}\n\tcpid = fork();\n\tif (cpid == -1)\n\t\tgoto out;\n\tif (!cpid) { \n\t\tfclose(pids_file);\n\t\tpid_from_ns_wrapper(sock[1], tpid);\n\t}\n\tconst char *ptr = buf;\n\twhile (sscanf(ptr, \"%d\", &qpid) == 1) {\n\t\tstruct ucred cred;\n\t\tchar v;\n\t\tif (write(sock[0], &qpid, sizeof(qpid)) != sizeof(qpid)) {\n\t\t\tfprintf(stderr, \"%s: error writing pid to child: %s\\n\",\n\t\t\t\t__func__, strerror(errno));\n\t\t\tgoto out;\n\t\t}\n\t\tif (recv_creds(sock[0], &cred, &v)) {\n\t\t\tif (v == '0') {\n\t\t\t\tif (fprintf(pids_file, \"%d\", (int) cred.pid) < 0)\n\t\t\t\t\tfail = true;\n\t\t\t}\n\t\t}\n\t\tptr = strchr(ptr, '\\n');\n\t\tif (!ptr)\n\t\t\tbreak;\n\t\tptr++;\n\t}\n\tqpid = -1;\n\tif (write(sock[0], &qpid ,sizeof(qpid)) != sizeof(qpid))\n\t\tfprintf(stderr, \"Warning: failed to ask child to exit\\n\");\n\tif (!fail)\n\t\tanswer = true;\nout:\n\tif (cpid != -1)\n\t\twait_for_pid(cpid);\n\tif (sock[0] != -1) {\n\t\tclose(sock[0]);\n\t\tclose(sock[1]);\n\t}\n\tif (pids_file) {\n\t\tif (fclose(pids_file) != 0)\n\t\t\tanswer = false;\n\t}\n\treturn answer;\n}", "target": 1}
{"code": "__xfs_inode_free(\n\tstruct xfs_inode\t*ip)\n{\n\tASSERT(atomic_read(&ip->i_pincount) == 0);\n\tXFS_STATS_DEC(ip->i_mount, vn_active);\n\tcall_rcu(&VFS_I(ip)->i_rcu, xfs_inode_free_callback);\n}", "target": 0}
{"code": "void RenderWidgetHostImpl::DidStopFlinging() {\n  if (view_)\n    view_->DidStopFlinging();\n}", "target": 0}
{"code": "static int iscsi_add_notunderstood_response(\n\tchar *key,\n\tchar *value,\n\tstruct iscsi_param_list *param_list)\n{\n\tstruct iscsi_extra_response *extra_response;\n\tif (strlen(value) > VALUE_MAXLEN) {\n\t\tpr_err(\"Value for notunderstood key \\\"%s\\\" exceeds %d,\"\n\t\t\t\" protocol error.\\n\", key, VALUE_MAXLEN);\n\t\treturn -1;\n\t}\n\textra_response = kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);\n\tif (!extra_response) {\n\t\tpr_err(\"Unable to allocate memory for\"\n\t\t\t\" struct iscsi_extra_response.\\n\");\n\t\treturn -1;\n\t}\n\tINIT_LIST_HEAD(&extra_response->er_list);\n\tstrncpy(extra_response->key, key, strlen(key) + 1);\n\tstrncpy(extra_response->value, NOTUNDERSTOOD,\n\t\t\tstrlen(NOTUNDERSTOOD) + 1);\n\tlist_add_tail(&extra_response->er_list,\n\t\t\t&param_list->extra_response_list);\n\treturn 0;\n}", "target": 1}
{"code": "static void asmlinkage smm_do_relocation(void *arg)\n{\n\tconst struct smm_module_params *p;\n\tconst struct smm_runtime *runtime;\n\tint cpu;\n\tuintptr_t curr_smbase;\n\tuintptr_t perm_smbase;\n\tp = arg;\n\truntime = p->runtime;\n\tcpu = p->cpu;\n\tcurr_smbase = runtime->smbase;\n\tif (cpu >= CONFIG_MAX_CPUS) {\n\t\tprintk(BIOS_CRIT,\n\t\t       \"Invalid CPU number assigned in SMM stub: %d\\n\", cpu);\n\t\treturn;\n\t}\n\tperm_smbase = mp_state.perm_smbase;\n\tperm_smbase -= cpu * runtime->save_state_size;\n\tprintk(BIOS_DEBUG, \"New SMBASE 0x%08lx\\n\", perm_smbase);\n\tmp_state.ops.relocation_handler(cpu, curr_smbase, perm_smbase);\n\tif (CONFIG(STM)) {\n\t\tuintptr_t mseg;\n\t\tmseg = mp_state.perm_smbase +\n\t\t\t(mp_state.perm_smsize - CONFIG_MSEG_SIZE);\n\t\tstm_setup(mseg, p->cpu,\n\t\t\t\tperm_smbase,\n\t\t\t\tmp_state.perm_smbase,\n\t\t\t\truntime->start32_offset);\n\t}\n}", "target": 1}
{"code": "error(int n, ...)\n{\nint ec;\nmacroexe *me;\nistackstr *fe;\nva_list ap;\nva_start(ap, n);\nif (n > error_maxerror)\n  {\n  (void)fprintf(stderr, \"** Unknown error number %d\\n\", n);\n  ec = ec_disaster;\n  }\nelse\n  {\n  ec = error_data[n].ec;\n  if (ec == ec_warning)\n    {\n    if (suppress_warnings) return;\n    (void)fprintf(stderr, \"** Warning: \");\n    }\n  else if (ec > ec_warning)\n    (void)fprintf(stderr, \"** Error: \");\n  (void)vfprintf(stderr, error_data[n].text, ap);\n  (void)fprintf(stderr, \"\\n\");\n  }\nva_end(ap);\nme = macrocurrent;\nfe = istack;\nif (from_type_ptr < 0) (void)fprintf(stderr, \"   Detected near end of file\\n\");\nelse for (int i = from_type_ptr; i >= 0; i--)\n  {\n  if (from_type[i] == FROM_MACRO)\n    {\n    const char *eof = (i == 0)? \" at end of input\" : \"\";\n    (void)fprintf(stderr, \"   Processing macro %s%s\\n\", me->macro->name, eof);\n    me = me->prev;\n    }\n  else\n    {\n    if (fe != NULL)\n      {\n      if (fe->linenumber > 0) \n        (void)fprintf(stderr, \"   Detected near line %d of %s\\n\",\n          fe->linenumber, fe->filename);\n      fe = fe->prev;\n      }\n    else\n      {\n      (void)fprintf(stderr, \"   Detected near end of file\\n\"); \n      }\n    }\n  }\nif (ec == ec_warning)\n  {\n  warning_count++;\n  if (warning_count > 40)\n    {\n    (void)fprintf(stderr, \"** Too many warnings - subsequent ones suppressed\\n\");\n    suppress_warnings = TRUE;\n    }\n  }\nelse if (ec > ec_warning)\n  {\n  return_code = EXIT_FAILURE;\n  error_count++;\n  if (error_count > 40)\n    {\n    (void)fprintf(stderr, \"** Too many errors\\n\");\n    ec = ec_failed;\n    }\n  }\nif (ec >= ec_failed)\n  {\n  (void)fprintf(stderr, \"** xfpt abandoned\\n\");\n  suppress_warnings = TRUE;  \n  exit(EXIT_FAILURE);\n  }\n(void)fprintf(stderr, \"\\n\");   \n}", "target": 1}
{"code": "nfs_printfh(netdissect_options *ndo,\n            register const uint32_t *dp, const u_int len)\n{\n\tmy_fsid fsid;\n\tuint32_t ino;\n\tconst char *sfsname = NULL;\n\tchar *spacep;\n\tif (ndo->ndo_uflag) {\n\t\tu_int i;\n\t\tchar const *sep = \"\";\n\t\tND_PRINT((ndo, \" fh[\"));\n\t\tfor (i=0; i<len; i++) {\n\t\t\tND_PRINT((ndo, \"%s%x\", sep, dp[i]));\n\t\t\tsep = \":\";\n\t\t}\n\t\tND_PRINT((ndo, \"]\"));\n\t\treturn;\n\t}\n\tParse_fh((const u_char *)dp, len, &fsid, &ino, NULL, &sfsname, 0);\n\tif (sfsname) {\n\t\tstatic char temp[NFSX_V3FHMAX+1];\n\t\tstrncpy(temp, sfsname, NFSX_V3FHMAX);\n\t\ttemp[sizeof(temp) - 1] = '\\0';\n\t\tspacep = strchr(temp, ' ');\n\t\tif (spacep)\n\t\t\t*spacep = '\\0';\n\t\tND_PRINT((ndo, \" fh %s/\", temp));\n\t} else {\n\t\tND_PRINT((ndo, \" fh %d,%d/\",\n\t\t\t     fsid.Fsid_dev.Major, fsid.Fsid_dev.Minor));\n\t}\n\tif(fsid.Fsid_dev.Minor == 257)\n\t\tND_PRINT((ndo, \"%s\", fsid.Opaque_Handle));\n\telse\n\t\tND_PRINT((ndo, \"%ld\", (long) ino));\n}", "target": 1}
{"code": "encodeJsonStructure(const void *src, const UA_DataType *type, CtxJson *ctx) {\n    if(ctx->depth > UA_JSON_ENCODING_MAX_RECURSION)\n        return UA_STATUSCODE_BADENCODINGERROR;\n    ctx->depth++;\n    status ret = writeJsonObjStart(ctx);\n    uintptr_t ptr = (uintptr_t) src;\n    u8 membersSize = type->membersSize;\n    const UA_DataType * typelists[2] = {UA_TYPES, &type[-type->typeIndex]};\n    for(size_t i = 0; i < membersSize && ret == UA_STATUSCODE_GOOD; ++i) {\n        const UA_DataTypeMember *m = &type->members[i];\n        const UA_DataType *mt = &typelists[!m->namespaceZero][m->memberTypeIndex];\n        if(m->memberName != NULL && *m->memberName != 0)\n            ret |= writeJsonKey(ctx, m->memberName);\n        if(!m->isArray) {\n            ptr += m->padding;\n            size_t memSize = mt->memSize;\n            ret |= encodeJsonJumpTable[mt->typeKind]((const void*) ptr, mt, ctx);\n            ptr += memSize;\n        } else {\n            ptr += m->padding;\n            const size_t length = *((const size_t*) ptr);\n            ptr += sizeof (size_t);\n            ret |= encodeJsonArray(ctx, *(void * const *)ptr, length, mt);\n            ptr += sizeof (void*);\n        }\n    }\n    ret |= writeJsonObjEnd(ctx);\n    ctx->depth--;\n    return ret;\n}", "target": 1}
{"code": "static int crypto_report_akcipher(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_akcipher rakcipher;\n\tstrlcpy(rakcipher.type, \"akcipher\", sizeof(rakcipher.type));\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_AKCIPHER,\n\t\t    sizeof(struct crypto_report_akcipher), &rakcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "static void set_own_dir(const char *argv0) {\n\tsize_t l = strlen(argv0);\n\twhile(l && argv0[l - 1] != '/')\n\t\tl--;\n\tif(l == 0)\n#ifdef SUPER_SECURE\n\t\tmemcpy(own_dir, \"/dev/null/\", 2);\n#else\n\t\tmemcpy(own_dir, \".\", 2);\n#endif\n\telse {\n\t\tmemcpy(own_dir, argv0, l - 1);\n\t\town_dir[l] = 0;\n\t}\n}", "target": 0}
{"code": "void BytecodeModuleGenerator::setFunctionGenerator(\n    Function *F,\n    unique_ptr<BytecodeFunctionGenerator> BFG) {\n  assert(\n      functionGenerators_.find(F) == functionGenerators_.end() &&\n      \"Adding same function twice.\");\n  assert(\n      !BFG->hasEncodingError() && \"Error should have been reported already.\");\n  functionGenerators_[F] = std::move(BFG);\n}", "target": 0}
{"code": "valid_hostname(const char *s)\n{\n\tsize_t i;\n\tif (*s == '-')\n\t\treturn 0;\n\tfor (i = 0; s[i] != 0; i++) {\n\t\tif (strchr(\"'`\\\"$\\\\;&<>|(){}\", s[i]) != NULL ||\n\t\t    isspace((u_char)s[i]) || iscntrl((u_char)s[i]))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "bool SimpleMessenger::verify_authorizer(Connection *con, int peer_type,\n\t\t\t\t\tint protocol, bufferlist& authorizer, bufferlist& authorizer_reply,\n\t\t\t\t\tbool& isvalid,CryptoKey& session_key)\n{\n  return ms_deliver_verify_authorizer(con, peer_type, protocol, authorizer, authorizer_reply, isvalid,session_key);\n}", "target": 1}
{"code": "static int sanitize_ptr_alu(struct bpf_verifier_env *env,\n\t\t\t    struct bpf_insn *insn,\n\t\t\t    const struct bpf_reg_state *ptr_reg,\n\t\t\t    struct bpf_reg_state *dst_reg,\n\t\t\t    bool off_is_neg)\n{\n\tstruct bpf_verifier_state *vstate = env->cur_state;\n\tstruct bpf_insn_aux_data *aux = cur_aux(env);\n\tbool ptr_is_dst_reg = ptr_reg == dst_reg;\n\tu8 opcode = BPF_OP(insn->code);\n\tu32 alu_state, alu_limit;\n\tstruct bpf_reg_state tmp;\n\tbool ret;\n\tif (can_skip_alu_sanitation(env, insn))\n\t\treturn 0;\n\tif (vstate->speculative)\n\t\tgoto do_sim;\n\talu_state  = off_is_neg ? BPF_ALU_NEG_VALUE : 0;\n\talu_state |= ptr_is_dst_reg ?\n\t\t     BPF_ALU_SANITIZE_SRC : BPF_ALU_SANITIZE_DST;\n\tif (retrieve_ptr_limit(ptr_reg, &alu_limit, opcode, off_is_neg))\n\t\treturn 0;\n\tif (update_alu_sanitation_state(aux, alu_state, alu_limit))\n\t\treturn -EACCES;\ndo_sim:\n\tif (!ptr_is_dst_reg) {\n\t\ttmp = *dst_reg;\n\t\t*dst_reg = *ptr_reg;\n\t}\n\tret = push_stack(env, env->insn_idx + 1, env->insn_idx, true);\n\tif (!ptr_is_dst_reg)\n\t\t*dst_reg = tmp;\n\treturn !ret ? -EFAULT : 0;\n}", "target": 0}
{"code": "static int adpt_system_info(void __user *buffer)\n{\n\tsysInfo_S si;\n\tmemset(&si, 0, sizeof(si));\n\tsi.osType = OS_LINUX;\n\tsi.osMajorVersion = 0;\n\tsi.osMinorVersion = 0;\n\tsi.osRevision = 0;\n\tsi.busType = SI_PCI_BUS;\n\tsi.processorFamily = DPTI_sig.dsProcessorFamily;\n#if defined __i386__\n\tadpt_i386_info(&si);\n#elif defined (__ia64__)\n\tadpt_ia64_info(&si);\n#elif defined(__sparc__)\n\tadpt_sparc_info(&si);\n#elif defined (__alpha__)\n\tadpt_alpha_info(&si);\n#else\n\tsi.processorType = 0xff ;\n#endif\n\tif (copy_to_user(buffer, &si, sizeof(si))){\n\t\tprintk(KERN_WARNING\"dpti: Could not copy buffer TO user\\n\");\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "comics_generate_command_lines (ComicsDocument *comics_document,\n\t\t\t       GError         **error)\n{\n\tgchar *quoted_file, *quoted_file_aux;\n\tgchar *quoted_command;\n\tComicBookDecompressType type;\n\ttype = comics_document->command_usage;\n\tcomics_document->regex_arg = command_usage_def[type].regex_arg;\n\tquoted_command = g_shell_quote (comics_document->selected_command);\n\tif (comics_document->regex_arg) {\n\t\tquoted_file = comics_regex_quote (comics_document->archive);\n\t\tquoted_file_aux = g_shell_quote (comics_document->archive);\n\t\tcomics_document->list_command =\n\t\t\t   g_strdup_printf (command_usage_def[type].list,\n\t\t\t                    comics_document->alternative_command,\n\t\t\t                    quoted_file_aux);\n\t\tg_free (quoted_file_aux);\n\t} else {\n\t\tquoted_file = g_shell_quote (comics_document->archive);\n\t\tcomics_document->list_command =\n\t\t\t\tg_strdup_printf (command_usage_def[type].list,\n\t\t\t\t                 quoted_command, quoted_file);\n\t}\n\tcomics_document->extract_command =\n\t\t\t    g_strdup_printf (command_usage_def[type].extract,\n\t\t\t\t             quoted_command);\n\tcomics_document->offset = command_usage_def[type].offset;\n\tif (command_usage_def[type].decompress_tmp) {\n\t\tcomics_document->dir = ev_mkdtemp (\"atril-comics-XXXXXX\", error);\n                if (comics_document->dir == NULL)\n                        return FALSE;\n\t\tcomics_document->decompress_tmp =\n\t\t\tg_strdup_printf (command_usage_def[type].decompress_tmp,\n\t\t\t\t\t quoted_command, quoted_file,\n\t\t\t\t\t comics_document->dir);\n\t\tg_free (quoted_file);\n\t\tg_free (quoted_command);\n\t\tif (!comics_decompress_temp_dir (comics_document->decompress_tmp,\n\t\t    comics_document->selected_command, error))\n\t\t\treturn FALSE;\n\t\telse\n\t\t\treturn TRUE;\n\t} else {\n\t\tg_free (quoted_file);\n\t\tg_free (quoted_command);\n\t\treturn TRUE;\n\t}\n}", "target": 1}
{"code": "void M_LoadDefaults (void)\n{\n    int\t\ti;\n    int\t\tlen;\n    FILE*\tf;\n    char\tdef[80];\n    char\tstrparm[100];\n    char*\tnewstring;\n    int\t\tparm;\n    boolean\tisstring;\n    numdefaults = sizeof(defaults)/sizeof(defaults[0]);\n    for (i=0 ; i<numdefaults ; i++)\n\t*defaults[i].location = defaults[i].defaultvalue;\n    i = M_CheckParm (\"-config\");\n    if (i && i<myargc-1)\n    {\n\tdefaultfile = myargv[i+1];\n\tprintf (\"\tdefault file: %s\\n\",defaultfile);\n    }\n    else\n\tdefaultfile = basedefault;\n    f = fopen (defaultfile, \"r\");\n    if (f)\n    {\n\twhile (!feof(f))\n\t{\n\t    isstring = false;\n\t    if (fscanf (f, \"%79s %[^\\n]\\n\", def, strparm) == 2)\n\t    {\n\t\tif (strparm[0] == '\"')\n\t\t{\n\t\t    isstring = true;\n\t\t    len = strlen(strparm);\n\t\t    newstring = (char *) malloc(len);\n\t\t    strparm[len-1] = 0;\n\t\t    strcpy(newstring, strparm+1);\n\t\t}\n\t\telse if (strparm[0] == '0' && strparm[1] == 'x')\n\t\t    sscanf(strparm+2, \"%x\", &parm);\n\t\telse\n\t\t    sscanf(strparm, \"%i\", &parm);\n\t\tfor (i=0 ; i<numdefaults ; i++)\n\t\t    if (!strcmp(def, defaults[i].name))\n\t\t    {\n\t\t\tif (!isstring)\n\t\t\t    *defaults[i].location = parm;\n\t\t\telse\n\t\t\t    *defaults[i].location =\n\t\t\t\t(int) newstring;\n\t\t\tbreak;\n\t\t    }\n\t    }\n\t}\n\tfclose (f);\n    }\n    for (i = 0; i < numdefaults; i++)\n    {\n        if (defaults[i].scantranslate)\n        {\n            parm = *defaults[i].location;\n            defaults[i].untranslated = parm;\n            *defaults[i].location = scantokey[parm];\n        }\n    }\n}", "target": 1}
{"code": "pci_set_cfgdata8(struct pci_vdev *dev, int offset, uint8_t val)\n{\n\tassert(offset <= PCI_REGMAX);\n\t*(uint8_t *)(dev->cfgdata + offset) = val;\n}", "target": 1}
{"code": "int xmkstemp(char **tmpname, char *dir)\n{\n\tchar *localtmp;\n\tchar *tmpenv;\n\tmode_t old_mode;\n\tint fd, rc;\n\tif (dir != NULL)\n\t\ttmpenv = dir;\n\telse\n\t\ttmpenv = getenv(\"TMPDIR\");\n\tif (tmpenv)\n\t\trc = asprintf(&localtmp, \"%s/%s.XXXXXX\", tmpenv,\n\t\t\t  program_invocation_short_name);\n\telse\n\t\trc = asprintf(&localtmp, \"%s/%s.XXXXXX\", _PATH_TMP,\n\t\t\t  program_invocation_short_name);\n\tif (rc < 0)\n\t\treturn -1;\n\told_mode = umask(077);\n\tfd = mkostemp(localtmp, O_RDWR|O_CREAT|O_EXCL|O_CLOEXEC);\n\tumask(old_mode);\n\tif (fd == -1) {\n\t\tfree(localtmp);\n\t\tlocaltmp = NULL;\n\t}\n\t*tmpname = localtmp;\n\treturn fd;\n}", "target": 1}
{"code": "local block_state deflate_huff(s, flush)\n    deflate_state *s;\n    int flush;\n{\n    int bflush;             \n    for (;;) {\n        if (s->lookahead == 0) {\n            fill_window(s);\n            if (s->lookahead == 0) {\n                if (flush == Z_NO_FLUSH)\n                    return need_more;\n                break;      \n            }\n        }\n        s->match_length = 0;\n        Tracevv((stderr,\"%c\", s->window[s->strstart]));\n        _tr_tally_lit (s, s->window[s->strstart], bflush);\n        s->lookahead--;\n        s->strstart++;\n        if (bflush) FLUSH_BLOCK(s, 0);\n    }\n    s->insert = 0;\n    if (flush == Z_FINISH) {\n        FLUSH_BLOCK(s, 1);\n        return finish_done;\n    }\n    if (s->last_lit)\n        FLUSH_BLOCK(s, 0);\n    return block_done;\n}", "target": 1}
{"code": "bool dir_has_correct_permissions(const char *dir_name)\n{\n    if (g_settings_privatereports)\n    {\n        struct stat statbuf;\n        if (lstat(dir_name, &statbuf) != 0 || !S_ISDIR(statbuf.st_mode))\n        {\n            error_msg(\"Path '%s' isn't directory\", dir_name);\n            return false;\n        }\n        struct group *gr = getgrnam(\"abrt\");\n        if (!gr)\n        {\n            error_msg(\"Group 'abrt' does not exist\");\n            return false;\n        }\n        if (statbuf.st_uid != 0 || !(statbuf.st_gid == 0 || statbuf.st_gid == gr->gr_gid) || statbuf.st_mode & 07)\n            return false;\n    }\n    return true;\n}", "target": 0}
{"code": "PGTYPESdate_from_asc(char *str, char **endptr)\n{\n\tdate\t\tdDate;\n\tfsec_t\t\tfsec;\n\tstruct tm\ttt,\n\t\t\t   *tm = &tt;\n\tint\t\t\tdtype;\n\tint\t\t\tnf;\n\tchar\t   *field[MAXDATEFIELDS];\n\tint\t\t\tftype[MAXDATEFIELDS];\n\tchar\t\tlowstr[MAXDATELEN + 1];\n\tchar\t   *realptr;\n\tchar\t  **ptr = (endptr != NULL) ? endptr : &realptr;\n\tbool\t\tEuroDates = FALSE;\n\terrno = 0;\n\tif (strlen(str) >= sizeof(lowstr))\n\t{\n\t\terrno = PGTYPES_DATE_BAD_DATE;\n\t\treturn INT_MIN;\n\t}\n\tif (ParseDateTime(str, lowstr, field, ftype, &nf, ptr) != 0 ||\n\t\tDecodeDateTime(field, ftype, nf, &dtype, tm, &fsec, EuroDates) != 0)\n\t{\n\t\terrno = PGTYPES_DATE_BAD_DATE;\n\t\treturn INT_MIN;\n\t}\n\tswitch (dtype)\n\t{\n\t\tcase DTK_DATE:\n\t\t\tbreak;\n\t\tcase DTK_EPOCH:\n\t\t\tif (GetEpochTime(tm) < 0)\n\t\t\t{\n\t\t\t\terrno = PGTYPES_DATE_BAD_DATE;\n\t\t\t\treturn INT_MIN;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terrno = PGTYPES_DATE_BAD_DATE;\n\t\t\treturn INT_MIN;\n\t}\n\tdDate = (date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - date2j(2000, 1, 1));\n\treturn dDate;\n}", "target": 1}
{"code": "SPL_METHOD(MultipleIterator, getFlags)\n{\n\tspl_SplObjectStorage *intern = (spl_SplObjectStorage*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\tRETURN_LONG(intern->flags);\n}", "target": 0}
{"code": "void queue_push(register Queue *qp, size_t extra_length, char const *info)\n{\n    register char *cp;\n    size_t memory_length;\n    size_t available_length;\n    size_t begin_length;\n    size_t n_begin;\n    size_t q_length;\n    if (!extra_length)\n        return;\n    memory_length    = qp->d_memory_end - qp->d_memory;\n    q_length = \n        qp->d_read <= qp->d_write ?\n            (size_t)(qp->d_write - qp->d_read)\n        :\n            memory_length - (qp->d_read - qp->d_write);\n    available_length = memory_length - q_length - 1;\n    if (message_show(MSG_INFO))\n        message(\"push_front %u bytes in `%s'\", (unsigned)extra_length, info);\n    if (extra_length > available_length)\n    {\n        memory_length += extra_length - available_length + BLOCK_QUEUE;\n        cp = new_memory(memory_length, sizeof(char));\n        if (message_show(MSG_INFO))\n            message(\"Reallocating queue at %p to %p\", qp->d_memory, cp);\n        if (qp->d_read > qp->d_write)               \n        {\n            size_t tail_len = qp->d_memory_end - qp->d_read;\n            memcpy(cp, qp->d_read, tail_len);       \n            memcpy(cp + tail_len, qp->d_memory, \n                                    (size_t)(qp->d_write - qp->d_memory));\n            qp->d_write = cp + q_length;\n            qp->d_read = cp;\n        }\n        else                                        \n        {\n            memcpy(cp, qp->d_memory, memory_length);\n            qp->d_read = cp + (qp->d_read - qp->d_memory);\n            qp->d_write = cp + (qp->d_write - qp->d_memory);\n        }\n        free(qp->d_memory);                         \n        qp->d_memory_end = cp + memory_length;      \n        qp->d_memory = cp;                          \n    }\n    begin_length = qp->d_read - qp->d_memory;   \n    n_begin = extra_length <= begin_length ?    \n                    extra_length                \n                :\n                    begin_length;\n    memcpy                                      \n    (                                           \n        qp->d_read -= n_begin,\n        info + extra_length - n_begin,\n        n_begin\n    );\n    if (extra_length > begin_length)            \n    {\n        extra_length -= begin_length;           \n        memcpy                                  \n        (                                       \n            qp->d_read = qp->d_memory_end - extra_length,\n            info,\n            extra_length\n        );\n    }\n}", "target": 1}
{"code": "auth_line_is_valid (guint8 *line, guint8 *line_end)\n{\n  guint8 *p;\n  for (p = line; p < line_end; p++)\n    {\n      if (!_DBUS_ISASCII(*p))\n        return FALSE;\n      if (*p < ' ')\n        return FALSE;\n    }\n  if (line[0] < 'A' || line[0] > 'Z')\n    return FALSE;\n  return TRUE;\n}", "target": 0}
{"code": "void test_readlink(const char *path)\n{\n\tchar *dest = alloca(2 * strlen(path));\n\tif (readlink(path, dest, 2 * strlen(path)) >= 0) {\n\t\tfprintf(stderr, \"leak at readlink of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at readlink of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "static BYTE get_bpp_bmf(UINT32 bpp, BOOL* pValid)\n{\n\tif (pValid)\n\t\t*pValid = TRUE;\n\tswitch (bpp)\n\t{\n\t\tcase 1:\n\t\t\treturn 1;\n\t\tcase 8:\n\t\t\treturn 3;\n\t\tcase 16:\n\t\t\treturn 4;\n\t\tcase 24:\n\t\t\treturn 5;\n\t\tcase 32:\n\t\t\treturn 6;\n\t\tdefault:\n\t\t\tWLog_WARN(TAG, \"Invalid color depth %\" PRIu32, bpp);\n\t\t\tif (pValid)\n\t\t\t\t*pValid = FALSE;\n\t\t\treturn 0;\n\t}\n}", "target": 0}
{"code": "TEST(RegexMatchExpression, MatchesElementExtendedOn) {\n    BSONObj match = BSON(\"x\"\n                         << \"ab\");\n    BSONObj notMatch = BSON(\"x\"\n                            << \"a b\");\n    RegexMatchExpression regex(\"\", \"a b\", \"x\");\n    ASSERT(regex.matchesSingleElement(match.firstElement()));\n    ASSERT(!regex.matchesSingleElement(notMatch.firstElement()));\n}", "target": 0}
{"code": "int sas_ex_revalidate_domain(struct domain_device *port_dev)\n{\n\tint res;\n\tstruct domain_device *dev = NULL;\n\tres = sas_find_bcast_dev(port_dev, &dev);\n\twhile (res == 0 && dev) {\n\t\tstruct expander_device *ex = &dev->ex_dev;\n\t\tint i = 0, phy_id;\n\t\tdo {\n\t\t\tphy_id = -1;\n\t\t\tres = sas_find_bcast_phy(dev, &phy_id, i, true);\n\t\t\tif (phy_id == -1)\n\t\t\t\tbreak;\n\t\t\tres = sas_rediscover(dev, phy_id);\n\t\t\ti = phy_id + 1;\n\t\t} while (i < ex->num_phys);\n\t\tdev = NULL;\n\t\tres = sas_find_bcast_dev(port_dev, &dev);\n\t}\n\treturn res;\n}", "target": 1}
{"code": "inline void ComputeInterpolationWeights(\n    const int64 out_size, const int64 in_size, const float scale,\n    const int resolution, InterpolationCache<T_SCALE>* interpolation) {\n  const Scaler scaler;\n  interpolation->lower.resize(out_size + 1);\n  interpolation->upper.resize(out_size + 1);\n  interpolation->lerp.resize(out_size + 1);\n  interpolation->ilerp.resize(out_size + 1);\n  interpolation->lower[out_size] = 0;\n  interpolation->upper[out_size] = 0;\n  for (int64 i = out_size - 1; i >= 0; --i) {\n    const float in = scaler(i, scale);\n    const float in_f = std::floor(in);\n    interpolation->lower[i] =\n        std::max(static_cast<int64>(in_f), static_cast<int64>(0));\n    interpolation->upper[i] =\n        std::min(static_cast<int64>(std::ceil(in)), in_size - 1);\n    interpolation->lower[i] =\n        std::min(interpolation->lower[i], interpolation->upper[i]);\n    interpolation->lerp[i] = in - in_f;\n    interpolation->ilerp[i] =\n        static_cast<T_SCALE>((in - in_f) * (1 << resolution));\n  }\n}", "target": 0}
{"code": "        bool         CheckRegion(int nPos, int nSize)\n        {\n            return (nPos >= 0 && nPos + nSize >= nPos && nPos + nSize <= m_nLen);\n        }", "target": 1}
{"code": "int delete_sdp_line( struct sip_msg * msg, char * s)\n{\n\tchar * start,*end;\n\tif( !s )\n\t\treturn 1;\n\tstart = s;\n\tend  = s;\n\twhile(*start != '\\n')\n\t\tstart--;\n\tstart++;\n\twhile(*end != '\\n')\n\t\tend++;\n\tend++;\n\tif( del_lump(msg, start - msg->buf, end - start,0) == NULL )\n\t{\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static size_t socket_slurp(RSocket *s, RBuffer *buf) {\n\tsize_t i;\n\tif (r_socket_ready (s, 1, 0) != 1) {\n\t\treturn 0;\n\t}\n\tr_socket_block_time (s, 1, 0, 1000);\n\tfor (i = 0; i < SOCKET_HTTP_MAX_HEADER_LENGTH; i += 1) {\n\t\tut8 c;\n\t\tint olen = r_socket_read_block (s, &c, 1);\n\t\tif (olen != 1) {\n\t\t\tr_buf_append_bytes (buf, (ut8 *)\"\", 1);\n\t\t\tbreak;\n\t\t}\n\t\tr_buf_append_bytes (buf, &c, 1);\n\t}\n\treturn i;\n}", "target": 0}
{"code": "vips_malloc( VipsObject *object, size_t size )\n{\n\tvoid *buf;\n\tbuf = g_malloc( size );\n        if( object ) {\n\t\tg_signal_connect( object, \"postclose\", \n\t\t\tG_CALLBACK( vips_malloc_cb ), buf );\n\t\tobject->local_memory += size;\n\t}\n\treturn( buf );\n}", "target": 1}
{"code": "bool Monitor::ms_verify_authorizer(Connection *con, int peer_type,\n\t\t\t\t   int protocol, bufferlist& authorizer_data,\n\t\t\t\t   bufferlist& authorizer_reply,\n\t\t\t\t   bool& isvalid, CryptoKey& session_key)\n{\n  dout(10) << \"ms_verify_authorizer \" << con->get_peer_addr()\n\t   << \" \" << ceph_entity_type_name(peer_type)\n\t   << \" protocol \" << protocol << dendl;\n  if (is_shutdown())\n    return false;\n  if (peer_type == CEPH_ENTITY_TYPE_MON &&\n      auth_cluster_required.is_supported_auth(CEPH_AUTH_CEPHX)) {\n    isvalid = false;\n    if (protocol == CEPH_AUTH_CEPHX) {\n      bufferlist::iterator iter = authorizer_data.begin();\n      CephXServiceTicketInfo auth_ticket_info;\n      if (authorizer_data.length()) {\n\tbool ret = cephx_verify_authorizer(g_ceph_context, &keyring, iter,\n\t\t\t\t\t  auth_ticket_info, authorizer_reply);\n\tif (ret) {\n\t  session_key = auth_ticket_info.session_key;\n\t  isvalid = true;\n\t} else {\n\t  dout(0) << \"ms_verify_authorizer bad authorizer from mon \" << con->get_peer_addr() << dendl;\n        }\n      }\n    } else {\n      dout(0) << \"ms_verify_authorizer cephx enabled, but no authorizer (required for mon)\" << dendl;\n    }\n  } else {\n    isvalid = true;\n  }\n  return true;\n}", "target": 1}
{"code": "void luaD_shrinkstack (lua_State *L) {\n  int inuse = stackinuse(L);\n  int goodsize = inuse + (inuse / 8) + 2*EXTRA_STACK;\n  if (goodsize > LUAI_MAXSTACK)\n    goodsize = LUAI_MAXSTACK;  \n  if (inuse <= (LUAI_MAXSTACK - EXTRA_STACK) &&\n      goodsize < L->stacksize)\n    luaD_reallocstack(L, goodsize, 0);  \n  else  \n    condmovestack(L,{},{});  \n  luaE_shrinkCI(L);  \n}", "target": 1}
{"code": "static void flush_end_io(struct request *flush_rq, int error)\n{\n\tstruct request_queue *q = flush_rq->q;\n\tstruct list_head *running;\n\tbool queued = false;\n\tstruct request *rq, *n;\n\tunsigned long flags = 0;\n\tstruct blk_flush_queue *fq = blk_get_flush_queue(q, flush_rq->mq_ctx);\n\tif (q->mq_ops) {\n\t\tstruct blk_mq_hw_ctx *hctx;\n\t\tspin_lock_irqsave(&fq->mq_flush_lock, flags);\n\t\thctx = q->mq_ops->map_queue(q, flush_rq->mq_ctx->cpu);\n\t\tblk_mq_tag_set_rq(hctx, flush_rq->tag, fq->orig_rq);\n\t\tflush_rq->tag = -1;\n\t}\n\trunning = &fq->flush_queue[fq->flush_running_idx];\n\tBUG_ON(fq->flush_pending_idx == fq->flush_running_idx);\n\tfq->flush_running_idx ^= 1;\n\tif (!q->mq_ops)\n\t\telv_completed_request(q, flush_rq);\n\tlist_for_each_entry_safe(rq, n, running, flush.list) {\n\t\tunsigned int seq = blk_flush_cur_seq(rq);\n\t\tBUG_ON(seq != REQ_FSEQ_PREFLUSH && seq != REQ_FSEQ_POSTFLUSH);\n\t\tqueued |= blk_flush_complete_seq(rq, fq, seq, error);\n\t}\n\tif (queued || fq->flush_queue_delayed) {\n\t\tWARN_ON(q->mq_ops);\n\t\tblk_run_queue_async(q);\n\t}\n\tfq->flush_queue_delayed = 0;\n\tif (q->mq_ops)\n\t\tspin_unlock_irqrestore(&fq->mq_flush_lock, flags);\n}", "target": 0}
{"code": "gx_default_create_compositor(gx_device * dev, gx_device ** pcdev,\n                             const gs_composite_t * pcte,\n                             gs_gstate * pgs, gs_memory_t * memory,\n                             gx_device *cdev)\n{\n    return pcte->type->procs.create_default_compositor\n        (pcte, pcdev, dev, pgs, memory);\n}", "target": 0}
{"code": "static void mongo_pass_digest( const char *user, const char *pass, char hex_digest[33] ) {\n    mongo_md5_state_t st;\n    mongo_md5_byte_t digest[16];\n    mongo_md5_init( &st );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )user, strlen( user ) );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )\":mongo:\", 7 );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )pass, strlen( pass ) );\n    mongo_md5_finish( &st, digest );\n    digest2hex( digest, hex_digest );\n}", "target": 1}
{"code": "static int faultin_page(struct task_struct *tsk, struct vm_area_struct *vma,\n\t\tunsigned long address, unsigned int *flags, int *nonblocking)\n{\n\tunsigned int fault_flags = 0;\n\tint ret;\n\tif ((*flags & (FOLL_POPULATE | FOLL_MLOCK)) == FOLL_MLOCK)\n\t\treturn -ENOENT;\n\tif ((*flags & FOLL_POPULATE) &&\n\t\t\t(stack_guard_page_start(vma, address) ||\n\t\t\t stack_guard_page_end(vma, address + PAGE_SIZE)))\n\t\treturn -ENOENT;\n\tif (*flags & FOLL_WRITE)\n\t\tfault_flags |= FAULT_FLAG_WRITE;\n\tif (*flags & FOLL_REMOTE)\n\t\tfault_flags |= FAULT_FLAG_REMOTE;\n\tif (nonblocking)\n\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY;\n\tif (*flags & FOLL_NOWAIT)\n\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_RETRY_NOWAIT;\n\tif (*flags & FOLL_TRIED) {\n\t\tVM_WARN_ON_ONCE(fault_flags & FAULT_FLAG_ALLOW_RETRY);\n\t\tfault_flags |= FAULT_FLAG_TRIED;\n\t}\n\tret = handle_mm_fault(vma, address, fault_flags);\n\tif (ret & VM_FAULT_ERROR) {\n\t\tif (ret & VM_FAULT_OOM)\n\t\t\treturn -ENOMEM;\n\t\tif (ret & (VM_FAULT_HWPOISON | VM_FAULT_HWPOISON_LARGE))\n\t\t\treturn *flags & FOLL_HWPOISON ? -EHWPOISON : -EFAULT;\n\t\tif (ret & (VM_FAULT_SIGBUS | VM_FAULT_SIGSEGV))\n\t\t\treturn -EFAULT;\n\t\tBUG();\n\t}\n\tif (tsk) {\n\t\tif (ret & VM_FAULT_MAJOR)\n\t\t\ttsk->maj_flt++;\n\t\telse\n\t\t\ttsk->min_flt++;\n\t}\n\tif (ret & VM_FAULT_RETRY) {\n\t\tif (nonblocking)\n\t\t\t*nonblocking = 0;\n\t\treturn -EBUSY;\n\t}\n\tif ((ret & VM_FAULT_WRITE) && !(vma->vm_flags & VM_WRITE))\n\t\t*flags &= ~FOLL_WRITE;\n\treturn 0;\n}", "target": 1}
{"code": "rx_cache_find(const struct rx_header *rxh, const struct ip *ip, int sport,\n\t      int32_t *opcode)\n{\n\tint i;\n\tstruct rx_cache_entry *rxent;\n\tuint32_t clip;\n\tuint32_t sip;\n\tUNALIGNED_MEMCPY(&clip, &ip->ip_dst, sizeof(uint32_t));\n\tUNALIGNED_MEMCPY(&sip, &ip->ip_src, sizeof(uint32_t));\n\ti = rx_cache_hint;\n\tdo {\n\t\trxent = &rx_cache[i];\n\t\tif (rxent->callnum == EXTRACT_32BITS(&rxh->callNumber) &&\n\t\t    rxent->client.s_addr == clip &&\n\t\t    rxent->server.s_addr == sip &&\n\t\t    rxent->serviceId == EXTRACT_32BITS(&rxh->serviceId) &&\n\t\t    rxent->dport == sport) {\n\t\t\trx_cache_hint = i;\n\t\t\t*opcode = rxent->opcode;\n\t\t\treturn(1);\n\t\t}\n\t\tif (++i >= RX_CACHE_SIZE)\n\t\t\ti = 0;\n\t} while (i != rx_cache_hint);\n\treturn(0);\n}", "target": 1}
{"code": "void RenderWidgetHostViewAura::SwapBuffersCompleted(\n    const BufferPresentedCallback& ack_callback,\n    const scoped_refptr<ui::Texture>& texture_to_return) {\n  ui::Compositor* compositor = GetCompositor();\n  if (!compositor) {\n    ack_callback.Run(false, texture_to_return);\n  } else {\n    AddOnCommitCallbackAndDisableLocks(\n        base::Bind(ack_callback, false, texture_to_return));\n  }\n  DidReceiveFrameFromRenderer();\n}", "target": 0}
{"code": "finalize_subnode_array(apr_array_header_t *array,\n                       limited_rights_t *sum,\n                       apr_pool_t *scratch_pool)\n{\n  if (array)\n    {\n      int i;\n      for (i = 0; i < array->nelts; ++i)\n        finalize_tree(APR_ARRAY_IDX(array, i, sorted_pattern_t).node, sum,\n                      scratch_pool);\n    }\n}", "target": 0}
{"code": "static BIO *cms_get_text_bio(BIO *out, unsigned int flags)\n\t{\n\tBIO *rbio;\n\tif (out == NULL)\n\t\trbio = BIO_new(BIO_s_null());\n\telse if (flags & CMS_TEXT)\n\t\t{\n\t\trbio = BIO_new(BIO_s_mem());\n\t\tBIO_set_mem_eof_return(rbio, 0);\n\t\t}\n\telse\n\t\trbio = out;\n\treturn rbio;\n\t}", "target": 0}
{"code": "MONGO_EXPORT int bson_append_finish_object( bson *b ) {\n    char *start;\n    int i;\n    if ( bson_ensure_space( b, 1 ) == BSON_ERROR ) return BSON_ERROR;\n    bson_append_byte( b , 0 );\n    start = b->data + b->stack[ --b->stackPos ];\n    i = b->cur - start;\n    bson_little_endian32( start, &i );\n    return BSON_OK;\n}", "target": 1}
{"code": "static void wdm_in_callback(struct urb *urb)\n{\n\tstruct wdm_device *desc = urb->context;\n\tint status = urb->status;\n\tspin_lock(&desc->iuspin);\n\tclear_bit(WDM_RESPONDING, &desc->flags);\n\tif (status) {\n\t\tswitch (status) {\n\t\tcase -ENOENT:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ENOENT\");\n\t\t\tgoto skip_error;\n\t\tcase -ECONNRESET:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ECONNRESET\");\n\t\t\tgoto skip_error;\n\t\tcase -ESHUTDOWN:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ESHUTDOWN\");\n\t\t\tgoto skip_error;\n\t\tcase -EPIPE:\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -EPIPE\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"Unexpected error %d\\n\", status);\n\t\t\tbreak;\n\t\t}\n\t}\n\tdesc->rerr = status;\n\tdesc->reslength = urb->actual_length;\n\tmemmove(desc->ubuf + desc->length, desc->inbuf, desc->reslength);\n\tdesc->length += desc->reslength;\nskip_error:\n\twake_up(&desc->wait);\n\tset_bit(WDM_READ, &desc->flags);\n\tspin_unlock(&desc->iuspin);\n}", "target": 1}
{"code": "void OfflineAudioDestinationHandler::SuspendOfflineRendering() {\n  DCHECK(!IsMainThread());\n  PostCrossThreadTask(\n      *main_thread_task_runner_, FROM_HERE,\n      CrossThreadBind(&OfflineAudioDestinationHandler::NotifySuspend,\n                      WrapRefCounted(this), Context()->CurrentSampleFrame()));\n}", "target": 0}
{"code": "print_arrays_for(char *set)\n{\n  FILE *f;\n  sprintf(buf, \"%s.conf\", set);\n  if ((f = fopen(buf, \"r\")) == NULL) {\n    fprintf(stderr, \"%s: can't read conf file for charset %s\\n\", prog, set);\n    exit(EXIT_FAILURE);\n  }\n  printf(\"\\\n\\n\\n\",\n\t set, prog);\n  print_array(f, set, \"ctype\",      CTYPE_TABLE_SIZE);\n  print_array(f, set, \"to_lower\",   TO_LOWER_TABLE_SIZE);\n  print_array(f, set, \"to_upper\",   TO_UPPER_TABLE_SIZE);\n  print_array(f, set, \"sort_order\", SORT_ORDER_TABLE_SIZE);\n  printf(\"\\n\");\n  fclose(f);\n  return;\n}", "target": 1}
{"code": "deinit_authz(void *data)\n{\n  authz_pool = NULL;\n  filtered_pool = NULL;\n  authz_pool_initialized = FALSE;\n  return APR_SUCCESS;\n}", "target": 0}
{"code": "void jas_deprecated(const char *s)\n{\n\tstatic char message[] =\n\t\"WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!!\\n\"\n\t\"WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!!\\n\"\n\t\"WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!!\\n\"\n\t\"YOUR CODE IS RELYING ON DEPRECATED FUNCTIONALTIY IN THE JASPER LIBRARY.\\n\"\n\t\"THIS FUNCTIONALITY WILL BE REMOVED IN THE NEAR FUTURE.\\n\"\n\t\"PLEASE FIX THIS PROBLEM BEFORE YOUR CODE STOPS WORKING!\\n\"\n\t;\n\tjas_eprintf(\"%s\", message);\n\tjas_eprintf(\"The specific problem is as follows:\\n%s\\n\", s);\n}", "target": 0}
{"code": "static int svm_vm_has_apicv(struct kvm *kvm)\n{\n\treturn 0;\n}", "target": 0}
{"code": "AP4_HdlrAtom::AP4_HdlrAtom(AP4_UI32        size, \n                           AP4_UI08        version,\n                           AP4_UI32        flags,\n                           AP4_ByteStream& stream) :\n    AP4_Atom(AP4_ATOM_TYPE_HDLR, size, version, flags)\n{\n    AP4_UI32 predefined;\n    stream.ReadUI32(predefined);\n    stream.ReadUI32(m_HandlerType);\n    stream.ReadUI32(m_Reserved[0]);\n    stream.ReadUI32(m_Reserved[1]);\n    stream.ReadUI32(m_Reserved[2]);\n    int name_size = size-(AP4_FULL_ATOM_HEADER_SIZE+20);\n    if (name_size == 0) return;\n    char* name = new char[name_size+1];\n    stream.Read(name, name_size);\n    name[name_size] = '\\0'; \n    if (name[0] == name_size-1) {\n        m_HandlerName = name+1;\n    } else {\n        m_HandlerName = name;\n    }\n    delete[] name;\n}", "target": 1}
{"code": "DownloadProxy* WebProcessProxy::createDownloadProxy()\n{\n#if ENABLE(NETWORK_PROCESS)\n    ASSERT(!m_context->usesNetworkProcess());\n#endif\n    if (!m_downloadProxyMap)\n        m_downloadProxyMap = adoptPtr(new DownloadProxyMap(m_messageReceiverMap));\n    return m_downloadProxyMap->createDownloadProxy(m_context.get());\n}", "target": 0}
{"code": "int re_yylex_init_extra(YY_EXTRA_TYPE yy_user_defined,yyscan_t* ptr_yy_globals )\n{\n    struct yyguts_t dummy_yyguts;\n    re_yyset_extra (yy_user_defined, &dummy_yyguts);\n    if (ptr_yy_globals == NULL){\n        errno = EINVAL;\n        return 1;\n    }\n    *ptr_yy_globals = (yyscan_t) re_yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );\n    if (*ptr_yy_globals == NULL){\n        errno = ENOMEM;\n        return 1;\n    }\n    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));\n    re_yyset_extra (yy_user_defined, *ptr_yy_globals);\n    return yy_init_globals ( *ptr_yy_globals );", "target": 1}
{"code": "static inline int pmd_none_or_trans_huge_or_clear_bad(pmd_t *pmd)\n{\n\tpmd_t pmdval = *pmd;\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tbarrier();\n#endif\n\tif (pmd_none(pmdval))\n\t\treturn 1;\n\tif (unlikely(pmd_bad(pmdval))) {\n\t\tif (!pmd_trans_huge(pmdval))\n\t\t\tpmd_clear_bad(pmd);\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int sanitize_ptr_alu(struct bpf_verifier_env *env,\n\t\t\t    struct bpf_insn *insn,\n\t\t\t    const struct bpf_reg_state *ptr_reg,\n\t\t\t    const struct bpf_reg_state *off_reg,\n\t\t\t    struct bpf_reg_state *dst_reg,\n\t\t\t    struct bpf_insn_aux_data *tmp_aux,\n\t\t\t    const bool commit_window)\n{\n\tstruct bpf_insn_aux_data *aux = commit_window ? cur_aux(env) : tmp_aux;\n\tstruct bpf_verifier_state *vstate = env->cur_state;\n\tbool off_is_imm = tnum_is_const(off_reg->var_off);\n\tbool off_is_neg = off_reg->smin_value < 0;\n\tbool ptr_is_dst_reg = ptr_reg == dst_reg;\n\tu8 opcode = BPF_OP(insn->code);\n\tu32 alu_state, alu_limit;\n\tstruct bpf_reg_state tmp;\n\tbool ret;\n\tint err;\n\tif (can_skip_alu_sanitation(env, insn))\n\t\treturn 0;\n\tif (vstate->speculative)\n\t\tgoto do_sim;\n\terr = retrieve_ptr_limit(ptr_reg, off_reg, &alu_limit, opcode);\n\tif (err < 0)\n\t\treturn err;\n\tif (commit_window) {\n\t\talu_state = tmp_aux->alu_state;\n\t\talu_limit = abs(tmp_aux->alu_limit - alu_limit);\n\t} else {\n\t\talu_state  = off_is_neg ? BPF_ALU_NEG_VALUE : 0;\n\t\talu_state |= off_is_imm ? BPF_ALU_IMMEDIATE : 0;\n\t\talu_state |= ptr_is_dst_reg ?\n\t\t\t     BPF_ALU_SANITIZE_SRC : BPF_ALU_SANITIZE_DST;\n\t}\n\terr = update_alu_sanitation_state(aux, alu_state, alu_limit);\n\tif (err < 0)\n\t\treturn err;\ndo_sim:\n\tif (commit_window)\n\t\treturn 0;\n\tif (!ptr_is_dst_reg) {\n\t\ttmp = *dst_reg;\n\t\t*dst_reg = *ptr_reg;\n\t}\n\tret = push_stack(env, env->insn_idx + 1, env->insn_idx, true);\n\tif (!ptr_is_dst_reg && ret)\n\t\t*dst_reg = tmp;\n\treturn !ret ? REASON_STACK : 0;\n}", "target": 0}
{"code": "int inet_sk_rebuild_header(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct rtable *rt = (struct rtable *)__sk_dst_check(sk, 0);\n\t__be32 daddr;\n\tint err;\n\tif (rt)\n\t\treturn 0;\n\tdaddr = inet->inet_daddr;\n\tif (inet->opt && inet->opt->srr)\n\t\tdaddr = inet->opt->faddr;\n\trt = ip_route_output_ports(sock_net(sk), sk, daddr, inet->inet_saddr,\n\t\t\t\t   inet->inet_dport, inet->inet_sport,\n\t\t\t\t   sk->sk_protocol, RT_CONN_FLAGS(sk),\n\t\t\t\t   sk->sk_bound_dev_if);\n\tif (!IS_ERR(rt)) {\n\t\terr = 0;\n\t\tsk_setup_caps(sk, &rt->dst);\n\t} else {\n\t\terr = PTR_ERR(rt);\n\t\tsk->sk_route_caps = 0;\n\t\tif (!sysctl_ip_dynaddr ||\n\t\t    sk->sk_state != TCP_SYN_SENT ||\n\t\t    (sk->sk_userlocks & SOCK_BINDADDR_LOCK) ||\n\t\t    (err = inet_sk_reselect_saddr(sk)) != 0)\n\t\t\tsk->sk_err_soft = -err;\n\t}\n\treturn err;\n}", "target": 1}
{"code": "static int snd_timer_user_tselect(struct file *file,\n\t\t\t\t  struct snd_timer_select __user *_tselect)\n{\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_select tselect;\n\tchar str[32];\n\tint err = 0;\n\ttu = file->private_data;\n\tmutex_lock(&tu->tread_sem);\n\tif (tu->timeri) {\n\t\tsnd_timer_close(tu->timeri);\n\t\ttu->timeri = NULL;\n\t}\n\tif (copy_from_user(&tselect, _tselect, sizeof(tselect))) {\n\t\terr = -EFAULT;\n\t\tgoto __err;\n\t}\n\tsprintf(str, \"application %i\", current->pid);\n\tif (tselect.id.dev_class != SNDRV_TIMER_CLASS_SLAVE)\n\t\ttselect.id.dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION;\n\terr = snd_timer_open(&tu->timeri, str, &tselect.id, current->pid);\n\tif (err < 0)\n\t\tgoto __err;\n\tkfree(tu->queue);\n\ttu->queue = NULL;\n\tkfree(tu->tqueue);\n\ttu->tqueue = NULL;\n\tif (tu->tread) {\n\t\ttu->tqueue = kmalloc(tu->queue_size * sizeof(struct snd_timer_tread),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (tu->tqueue == NULL)\n\t\t\terr = -ENOMEM;\n\t} else {\n\t\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t\t    GFP_KERNEL);\n\t\tif (tu->queue == NULL)\n\t\t\terr = -ENOMEM;\n\t}\n      \tif (err < 0) {\n\t\tsnd_timer_close(tu->timeri);\n      \t\ttu->timeri = NULL;\n      \t} else {\n\t\ttu->timeri->flags |= SNDRV_TIMER_IFLG_FAST;\n\t\ttu->timeri->callback = tu->tread\n\t\t\t? snd_timer_user_tinterrupt : snd_timer_user_interrupt;\n\t\ttu->timeri->ccallback = snd_timer_user_ccallback;\n\t\ttu->timeri->callback_data = (void *)tu;\n\t}\n      __err:\n      \tmutex_unlock(&tu->tread_sem);\n\treturn err;\n}", "target": 1}
{"code": "#else\n    static int input  (yyscan_t yyscanner)\n#endif\n{\n\tint c;\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\t*yyg->yy_c_buf_p = yyg->yy_hold_char;\n\tif ( *yyg->yy_c_buf_p == YY_END_OF_BUFFER_CHAR )\n\t\t{\n\t\tif ( yyg->yy_c_buf_p < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )\n\t\t\t*yyg->yy_c_buf_p = '\\0';\n\t\telse\n\t\t\t{ \n\t\t\tyy_size_t offset = yyg->yy_c_buf_p - yyg->yytext_ptr;\n\t\t\t++yyg->yy_c_buf_p;\n\t\t\tswitch ( yy_get_next_buffer( yyscanner ) )\n\t\t\t\t{\n\t\t\t\tcase EOB_ACT_LAST_MATCH:\n\t\t\t\t\tre_yyrestart(yyin ,yyscanner);\n\t\t\t\tcase EOB_ACT_END_OF_FILE:\n\t\t\t\t\t{\n\t\t\t\t\tif ( re_yywrap(yyscanner ) )\n\t\t\t\t\t\treturn EOF;\n\t\t\t\t\tif ( ! yyg->yy_did_buffer_switch_on_eof )\n\t\t\t\t\t\tYY_NEW_FILE;\n#ifdef __cplusplus\n\t\t\t\t\treturn yyinput(yyscanner);\n#else\n\t\t\t\t\treturn input(yyscanner);\n#endif\n\t\t\t\t\t}\n\t\t\t\tcase EOB_ACT_CONTINUE_SCAN:\n\t\t\t\t\tyyg->yy_c_buf_p = yyg->yytext_ptr + offset;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tc = *(unsigned char *) yyg->yy_c_buf_p;\t\n\t*yyg->yy_c_buf_p = '\\0';\t\n\tyyg->yy_hold_char = *++yyg->yy_c_buf_p;\n\tif ( c == '\\n' )\n    do{ yylineno++;\n        yycolumn=0;\n    }while(0)\n;\n\treturn c;", "target": 1}
{"code": "static int asf_read_marker(AVFormatContext *s, int64_t size)\n{\n    AVIOContext *pb = s->pb;\n    ASFContext *asf = s->priv_data;\n    int i, count, name_len, ret;\n    char name[1024];\n    avio_rl64(pb);            \n    avio_rl64(pb);            \n    count = avio_rl32(pb);    \n    avio_rl16(pb);            \n    name_len = avio_rl16(pb); \n    for (i = 0; i < name_len; i++)\n        avio_r8(pb); \n    for (i = 0; i < count; i++) {\n        int64_t pres_time;\n        int name_len;\n        avio_rl64(pb);             \n        pres_time = avio_rl64(pb); \n        pres_time -= asf->hdr.preroll * 10000;\n        avio_rl16(pb);             \n        avio_rl32(pb);             \n        avio_rl32(pb);             \n        name_len = avio_rl32(pb);  \n        if ((ret = avio_get_str16le(pb, name_len * 2, name,\n                                    sizeof(name))) < name_len)\n            avio_skip(pb, name_len - ret);\n        avpriv_new_chapter(s, i, (AVRational) { 1, 10000000 }, pres_time,\n                           AV_NOPTS_VALUE, name);\n    }\n    return 0;\n}", "target": 1}
{"code": "static unsigned int help(struct sk_buff *skb,\n\t\t\t enum ip_conntrack_info ctinfo,\n\t\t\t unsigned int protoff,\n\t\t\t unsigned int matchoff,\n\t\t\t unsigned int matchlen,\n\t\t\t struct nf_conntrack_expect *exp)\n{\n\tchar buffer[sizeof(\"4294967296 65635\")];\n\tu_int16_t port;\n\tunsigned int ret;\n\texp->saved_proto.tcp.port = exp->tuple.dst.u.tcp.port;\n\texp->dir = IP_CT_DIR_REPLY;\n\texp->expectfn = nf_nat_follow_master;\n\tfor (port = ntohs(exp->saved_proto.tcp.port); port != 0; port++) {\n\t\tint ret;\n\t\texp->tuple.dst.u.tcp.port = htons(port);\n\t\tret = nf_ct_expect_related(exp);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\telse if (ret != -EBUSY) {\n\t\t\tport = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (port == 0) {\n\t\tnf_ct_helper_log(skb, exp->master, \"all ports in use\");\n\t\treturn NF_DROP;\n\t}\n\tret = nf_nat_mangle_tcp_packet(skb, exp->master, ctinfo,\n\t\t\t\t       protoff, matchoff, matchlen, buffer,\n\t\t\t\t       strlen(buffer));\n\tif (ret != NF_ACCEPT) {\n\t\tnf_ct_helper_log(skb, exp->master, \"cannot mangle packet\");\n\t\tnf_ct_unexpect_related(exp);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static const char *sip_endpoint_identifier_type2str(enum ast_sip_endpoint_identifier_type method)\n{\n\tconst char *str = \"<unknown>\";\n\tswitch (method) {\n\tcase AST_SIP_ENDPOINT_IDENTIFY_BY_USERNAME:\n\t\tstr = \"username\";\n\t\tbreak;\n\tcase AST_SIP_ENDPOINT_IDENTIFY_BY_AUTH_USERNAME:\n\t\tstr = \"auth_username\";\n\t\tbreak;\n\tcase AST_SIP_ENDPOINT_IDENTIFY_BY_IP:\n\t\tstr = \"ip\";\n\t\tbreak;\n\tcase AST_SIP_ENDPOINT_IDENTIFY_BY_HEADER:\n\t\tstr = \"header\";\n\t\tbreak;\n\tcase AST_SIP_ENDPOINT_IDENTIFY_BY_REQUEST_URI:\n\t\tstr = \"request_uri\";\n\t\tbreak;\n\tcase AST_SIP_ENDPOINT_IDENTIFY_BY_TRANSPORT:\n\t\tstr = \"transport\";\n\t\tbreak;\n\t}\n\treturn str;\n}", "target": 1}
{"code": "CotpConnection_readToTpktBuffer(CotpConnection* self)\n{\n    uint8_t* buffer = self->readBuffer->buffer;\n    int bufferSize = self->readBuffer->maxSize;\n    int bufPos = self->readBuffer->size;\n    assert (bufferSize > 4);\n    int readBytes;\n    if (bufPos < 4) {\n        readBytes = readFromSocket(self, buffer + bufPos, 4 - bufPos);\n        if (readBytes < 0)\n            goto exit_closed;\n        if (DEBUG_COTP) {\n            if (readBytes > 0)\n                printf(\"TPKT: read %i bytes from socket\\n\", readBytes);\n        }\n        bufPos += readBytes;\n        if (bufPos == 4) {\n            if ((buffer[0] == 3) && (buffer[1] == 0)) {\n                self->packetSize = (buffer[2] * 0x100) + buffer[3];\n                if (DEBUG_COTP)\n                    printf(\"TPKT: header complete (msg size = %i)\\n\", self->packetSize);\n                if (self->packetSize > bufferSize) {\n                    if (DEBUG_COTP) printf(\"TPKT: packet too large\\n\");\n                    goto exit_error;\n                }\n            }\n            else {\n                if (DEBUG_COTP) printf(\"TPKT: failed to decode TPKT header.\\n\");\n                goto exit_error;\n            }\n        }\n        else\n            goto exit_waiting;\n    }\n    if (self->packetSize <= bufPos)\n        goto exit_error;\n    readBytes = readFromSocket(self, buffer + bufPos, self->packetSize - bufPos);\n    if (readBytes < 0)\n        goto exit_closed;\n    bufPos += readBytes;\n    if (bufPos < self->packetSize)\n       goto exit_waiting;\n    if (DEBUG_COTP) printf(\"TPKT: message complete (size = %i)\\n\", self->packetSize);\n    self->readBuffer->size = bufPos;\n    return TPKT_PACKET_COMPLETE;\nexit_closed:\n    if (DEBUG_COTP) printf(\"TPKT: socket closed or socket error\\n\");\n    return TPKT_ERROR;\nexit_error:\n    if (DEBUG_COTP) printf(\"TPKT: Error parsing message\\n\");\n    return TPKT_ERROR;\nexit_waiting:\n    if (DEBUG_COTP)\n        if (bufPos != 0)\n            printf(\"TPKT: waiting (read %i of %i)\\n\", bufPos, self->packetSize);\n    self->readBuffer->size = bufPos;\n    return TPKT_WAITING;\n}", "target": 0}
{"code": "GF_EXPORT\nGF_Err gf_isom_get_sidx_duration(GF_ISOFile *movie, u64 *sidx_dur, u32 *sidx_timescale)\n{\n\tu64 dur=0;\n\tu32 i;\n\tif (!movie || !movie->moov || !sidx_timescale || !sidx_dur)\n\t\treturn GF_BAD_PARAM;\n\tif (!movie->main_sidx) return GF_NOT_SUPPORTED;\n\t*sidx_timescale = movie->main_sidx->timescale;\n\tfor (i=0; i<movie->main_sidx->nb_refs; i++) {\n\t\tdur += movie->main_sidx->refs[i].subsegment_duration;\n\t}\n\t*sidx_dur = dur;\n\treturn GF_OK;", "target": 0}
{"code": "int install_user_keyrings(void)\n{\n\tstruct user_struct *user;\n\tconst struct cred *cred;\n\tstruct key *uid_keyring, *session_keyring;\n\tkey_perm_t user_keyring_perm;\n\tchar buf[20];\n\tint ret;\n\tuid_t uid;\n\tuser_keyring_perm = (KEY_POS_ALL & ~KEY_POS_SETATTR) | KEY_USR_ALL;\n\tcred = current_cred();\n\tuser = cred->user;\n\tuid = from_kuid(cred->user_ns, user->uid);\n\tkenter(\"%p{%u}\", user, uid);\n\tif (user->uid_keyring) {\n\t\tkleave(\" = 0 [exist]\");\n\t\treturn 0;\n\t}\n\tmutex_lock(&key_user_keyring_mutex);\n\tret = 0;\n\tif (!user->uid_keyring) {\n\t\tsprintf(buf, \"_uid.%u\", uid);\n\t\tuid_keyring = find_keyring_by_name(buf, true);\n\t\tif (IS_ERR(uid_keyring)) {\n\t\t\tuid_keyring = keyring_alloc(buf, user->uid, INVALID_GID,\n\t\t\t\t\t\t    cred, user_keyring_perm,\n\t\t\t\t\t\t    KEY_ALLOC_IN_QUOTA, NULL);\n\t\t\tif (IS_ERR(uid_keyring)) {\n\t\t\t\tret = PTR_ERR(uid_keyring);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tsprintf(buf, \"_uid_ses.%u\", uid);\n\t\tsession_keyring = find_keyring_by_name(buf, true);\n\t\tif (IS_ERR(session_keyring)) {\n\t\t\tsession_keyring =\n\t\t\t\tkeyring_alloc(buf, user->uid, INVALID_GID,\n\t\t\t\t\t      cred, user_keyring_perm,\n\t\t\t\t\t      KEY_ALLOC_IN_QUOTA, NULL);\n\t\t\tif (IS_ERR(session_keyring)) {\n\t\t\t\tret = PTR_ERR(session_keyring);\n\t\t\t\tgoto error_release;\n\t\t\t}\n\t\t\tret = key_link(session_keyring, uid_keyring);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error_release_both;\n\t\t}\n\t\tuser->uid_keyring = uid_keyring;\n\t\tuser->session_keyring = session_keyring;\n\t}\n\tmutex_unlock(&key_user_keyring_mutex);\n\tkleave(\" = 0\");\n\treturn 0;\nerror_release_both:\n\tkey_put(session_keyring);\nerror_release:\n\tkey_put(uid_keyring);\nerror:\n\tmutex_unlock(&key_user_keyring_mutex);\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}", "target": 1}
{"code": "Opal::Call::get_local_party_name () const\n{\n  return local_party_name;\n}", "target": 0}
{"code": "node_new(void)\n{\n  Node* node;\n  node = (Node* )xmalloc(sizeof(Node));\n  xmemset(node, 0, sizeof(*node));\n#ifdef DEBUG_NODE_FREE\n  fprintf(stderr, \"node_new: %p\\n\", node);\n#endif\n  return node;\n}", "target": 0}
{"code": "bool ParseAttrValueHelper_TensorNestsUnderLimit(int limit, string to_parse) {\n  int nests = 0;\n  int maxed_out = to_parse.length();\n  int open_curly = to_parse.find('{');\n  int open_bracket = to_parse.find('<');\n  int close_curly = to_parse.find('}');\n  int close_bracket = to_parse.find('>');\n  if (open_curly == -1) {\n    open_curly = maxed_out;\n  }\n  if (open_bracket == -1) {\n    open_bracket = maxed_out;\n  }\n  int min = std::min(open_curly, open_bracket);\n  do {\n    if (open_curly == maxed_out && open_bracket == maxed_out) {\n      return true;\n    }\n    if (min == open_curly) {\n      nests += 1;\n      open_curly = to_parse.find('{', open_curly + 1);\n      if (open_curly == -1) {\n        open_curly = maxed_out;\n      }\n    } else if (min == open_bracket) {\n      nests += 1;\n      open_bracket = to_parse.find('<', open_bracket + 1);\n      if (open_bracket == -1) {\n        open_bracket = maxed_out;\n      }\n    } else if (min == close_curly) {\n      nests -= 1;\n      close_curly = to_parse.find('}', close_curly + 1);\n      if (close_curly == -1) {\n        close_curly = maxed_out;\n      }\n    } else if (min == close_bracket) {\n      nests -= 1;\n      close_bracket = to_parse.find('>', close_bracket + 1);\n      if (close_bracket == -1) {\n        close_bracket = maxed_out;\n      }\n    }\n    min = std::min({open_curly, open_bracket, close_curly, close_bracket});\n  } while (nests < 100);\n  return false;\n}", "target": 0}
{"code": "    uint64_t Image::byteSwap(uint64_t value,bool bSwap) const\n    {\n        uint64_t result = 0;\n        byte* source_value = reinterpret_cast<byte *>(&value);\n        byte* destination_value = reinterpret_cast<byte *>(&result);\n        for (int i = 0; i < 8; i++)\n            destination_value[i] = source_value[8 - i - 1];\n        return bSwap ? result : value;\n    }", "target": 0}
{"code": "static inline struct rb_node *first_fair(struct cfs_rq *cfs_rq)\n{\n\treturn cfs_rq->rb_leftmost;\n}", "target": 0}
{"code": "static inline int init_new_context(struct task_struct *tsk,\n\t\t\t\t   struct mm_struct *mm)\n{\n\tcpumask_clear(&mm->context.cpu_attach_mask);\n\tatomic_set(&mm->context.attach_count, 0);\n\tmm->context.flush_mm = 0;\n\tmm->context.asce_bits = _ASCE_TABLE_LENGTH | _ASCE_USER_BITS;\n\tmm->context.asce_bits |= _ASCE_TYPE_REGION3;\n#ifdef CONFIG_PGSTE\n\tmm->context.alloc_pgste = page_table_allocate_pgste;\n\tmm->context.has_pgste = 0;\n\tmm->context.use_skey = 0;\n#endif\n\tmm->context.asce_limit = STACK_TOP_MAX;\n\tcrst_table_init((unsigned long *) mm->pgd, pgd_entry_type(mm));\n\treturn 0;\n}", "target": 1}
{"code": "void *hashtable_get(hashtable_t *hashtable, const char *key)\n{\n    pair_t *pair;\n    size_t hash;\n    bucket_t *bucket;\n    hash = hash_str(key);\n    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];\n    pair = hashtable_find_pair(hashtable, bucket, key, hash);\n    if(!pair)\n        return NULL;\n    return pair->value;\n}", "target": 1}
{"code": "void test_utimes(const char *path)\n{\n\tstruct utimbuf times;\n\ttimes.actime = 0;\n\ttimes.modtime = 0;\n\tif (utime(path, &times) == 0) {\n\t\tfprintf(stderr, \"leak at utime of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at utime of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "int ext4_filemap_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tint err;\n\tdown_read(&EXT4_I(inode)->i_mmap_sem);\n\terr = filemap_fault(vma, vmf);\n\tup_read(&EXT4_I(inode)->i_mmap_sem);\n\treturn err;\n}", "target": 0}
{"code": "  void writeSuccess() noexcept override {}", "target": 0}
{"code": "void schi_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}", "target": 0}
{"code": "cib_handle_remote_msg(cib_client_t *client, xmlNode *command)\n{\n    const char *value = NULL;\n    value = crm_element_name(command);\n    if (safe_str_neq(value, \"cib_command\")) {\n        crm_log_xml_trace(command, \"Bad command: \");\n        return;\n    }\n    if (client->name == NULL) {\n        value = crm_element_value(command, F_CLIENTNAME);\n        if (value == NULL) {\n            client->name = strdup(client->id);\n        } else {\n            client->name = strdup(value);\n        }\n    }\n    if (client->callback_id == NULL) {\n        value = crm_element_value(command, F_CIB_CALLBACK_TOKEN);\n        if (value != NULL) {\n            client->callback_id = strdup(value);\n            crm_trace(\"Callback channel for %s is %s\", client->id, client->callback_id);\n        } else {\n            client->callback_id = strdup(client->id);\n        }\n    }\n    xml_remove_prop(command, F_ORIG);\n    xml_remove_prop(command, F_CIB_HOST);\n    xml_remove_prop(command, F_CIB_GLOBAL_UPDATE);\n    crm_xml_add(command, F_TYPE, T_CIB);\n    crm_xml_add(command, F_CIB_CLIENTID, client->id);\n    crm_xml_add(command, F_CIB_CLIENTNAME, client->name);\n#if ENABLE_ACL\n    crm_xml_add(command, F_CIB_USER, client->user);\n#endif\n    if (crm_element_value(command, F_CIB_CALLID) == NULL) {\n        char *call_uuid = crm_generate_uuid();\n        crm_xml_add(command, F_CIB_CALLID, call_uuid);\n        free(call_uuid);\n    }\n    if (crm_element_value(command, F_CIB_CALLOPTS) == NULL) {\n        crm_xml_add_int(command, F_CIB_CALLOPTS, 0);\n    }\n    crm_log_xml_trace(command, \"Remote command: \");\n    cib_common_callback_worker(0, 0, command, client, TRUE);\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, IntersectCompoundInsteadThreeCompoundIndices) {\n    params.options = QueryPlannerParams::NO_TABLE_SCAN | QueryPlannerParams::INDEX_INTERSECTION;\n    addIndex(BSON(\"a\" << 1 << \"b\" << 1));\n    addIndex(BSON(\"c\" << 1 << \"d\" << 1));\n    addIndex(BSON(\"a\" << 1 << \"c\" << -1 << \"b\" << -1 << \"d\" << 1));\n    runQuery(fromjson(\"{a: 1, b: 1, c: 1, d: 1}\"));\n    assertNumSolutions(3U);\n    assertSolutionExists(\n        \"{fetch: {filter: {$and: [{c:1},{d:1}]}, node: \"\n        \"{ixscan: {filter: null, pattern: {a:1,b:1}}}}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: {$and:[{a:1},{b:1}]}, node: \"\n        \"{ixscan: {filter: null, pattern: {c:1,d:1}}}}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: null, node: \"\n        \"{ixscan: {filter: null, pattern: {a:1,c:-1,b:-1,d:1}}}}}\");\n}", "target": 0}
{"code": "static GF_Err mp4_mux_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)\n{\n\tGF_MP4MuxCtx *ctx = gf_filter_get_udta(filter);\n\tif (is_remove) {\n\t\tTrackWriter *tkw = gf_filter_pid_get_udta(pid);\n\t\tif (tkw) {\n\t\t\tgf_list_del_item(ctx->tracks, tkw);\n\t\t\tif (ctx->ref_tkw == tkw) ctx->ref_tkw = gf_list_get(ctx->tracks, 0);\n\t\t\tgf_free(tkw);\n\t\t}\n\t\tif (ctx->opid && !gf_list_count(ctx->tracks)) {\n\t\t\tif (ctx->file) {\n\t\t\t\tif (!ctx->init_movie_done) {\n\t\t\t\t\tmp4_mux_done(ctx, GF_TRUE);\n\t\t\t\t}\n\t\t\t} else {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\twhile (ctx->flush_size) {\n\t\t\t\t\tGF_Err e = mp4_mux_flush_fragmented(ctx);\n\t\t\t\t\tif (e) break;\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t\tgf_filter_pid_remove(ctx->opid);\n\t\t\tctx->opid = NULL;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\treturn mp4_mux_setup_pid(filter, pid, GF_TRUE);\n}", "target": 0}
{"code": "file_extension(const char *s)\t\n{\n  const char\t*extension;\t\n  static char\tbuf[1024];\t\n  if (s == NULL)\n    return (NULL);\n  else if (!strncmp(s, \"data:image/bmp;\", 15))\n    return (\"bmp\");\n  else if (!strncmp(s, \"data:image/gif;\", 15))\n    return (\"gif\");\n  else if (!strncmp(s, \"data:image/jpeg;\", 16))\n    return (\"jpg\");\n  else if (!strncmp(s, \"data:image/png;\", 15))\n    return (\"png\");\n  else if ((extension = strrchr(s, '/')) != NULL)\n    extension ++;\n  else if ((extension = strrchr(s, '\\\\')) != NULL)\n    extension ++;\n  else\n    extension = s;\n  if ((extension = strrchr(extension, '.')) == NULL)\n    return (\"\");\n  else\n    extension ++;\n  if (strchr(extension, '#') == NULL)\n    return (extension);\n  strlcpy(buf, extension, sizeof(buf));\n  *(char *)strchr(buf, '#') = '\\0';\n  return (buf);\n}", "target": 1}
{"code": "void nf_tables_unbind_set(const struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t  struct nft_set_binding *binding)\n{\n\tlist_del_rcu(&binding->list);\n\tif (list_empty(&set->bindings) && set->flags & NFT_SET_ANONYMOUS &&\n\t    !(set->flags & NFT_SET_INACTIVE))\n\t\tnf_tables_set_destroy(ctx, set);\n}", "target": 0}
{"code": "static void csi_K(struct vc_data *vc, int vpar)\n{\n\tunsigned int count;\n\tunsigned short *start = (unsigned short *)vc->vc_pos;\n\tint offset;\n\tswitch (vpar) {\n\t\tcase 0:\t\n\t\t\toffset = 0;\n\t\t\tcount = vc->vc_cols - vc->vc_x;\n\t\t\tbreak;\n\t\tcase 1:\t\n\t\t\toffset = -vc->vc_x;\n\t\t\tcount = vc->vc_x + 1;\n\t\t\tbreak;\n\t\tcase 2: \n\t\t\toffset = -vc->vc_x;\n\t\t\tcount = vc->vc_cols;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t}\n\tvc_uniscr_clear_line(vc, vc->vc_x + offset, count);\n\tscr_memsetw(start + offset, vc->vc_video_erase_char, 2 * count);\n\tvc->vc_need_wrap = 0;\n\tif (con_should_update(vc))\n\t\tdo_update_region(vc, (unsigned long)(start + offset), count);\n}", "target": 0}
{"code": "  double sessionTimeout() const { return _sessionTimeout; }", "target": 0}
{"code": "void pjsua_init_tpselector(pjsua_transport_id tp_id,\n\t\t\t   pjsip_tpselector *sel)\n{\n    pjsua_transport_data *tpdata;\n    unsigned flag;\n    pj_bzero(sel, sizeof(*sel));\n    if (tp_id == PJSUA_INVALID_ID)\n\treturn;\n    pj_assert(tp_id >= 0 && tp_id < (int)PJ_ARRAY_SIZE(pjsua_var.tpdata));\n    tpdata = &pjsua_var.tpdata[tp_id];\n    flag = pjsip_transport_get_flag_from_type(tpdata->type);\n    if (flag & PJSIP_TRANSPORT_DATAGRAM) {\n\tsel->type = PJSIP_TPSELECTOR_TRANSPORT;\n\tsel->u.transport = tpdata->data.tp;\n    } else {\n\tsel->type = PJSIP_TPSELECTOR_LISTENER;\n\tsel->u.listener = tpdata->data.factory;\n    }\n}", "target": 1}
{"code": "static int ReadHuffmanCode(int alphabet_size, VP8LDecoder* const dec,\n                           int* const code_lengths, HuffmanCode* const table) {\n  int ok = 0;\n  int size = 0;\n  VP8LBitReader* const br = &dec->br_;\n  const int simple_code = VP8LReadBits(br, 1);\n  memset(code_lengths, 0, alphabet_size * sizeof(*code_lengths));\n  if (simple_code) {  \n    const int num_symbols = VP8LReadBits(br, 1) + 1;\n    const int first_symbol_len_code = VP8LReadBits(br, 1);\n    int symbol = VP8LReadBits(br, (first_symbol_len_code == 0) ? 1 : 8);\n    code_lengths[symbol] = 1;\n    if (num_symbols == 2) {\n      symbol = VP8LReadBits(br, 8);\n      code_lengths[symbol] = 1;\n    }\n    ok = 1;\n  } else {  \n    int i;\n    int code_length_code_lengths[NUM_CODE_LENGTH_CODES] = { 0 };\n    const int num_codes = VP8LReadBits(br, 4) + 4;\n    assert(num_codes <= NUM_CODE_LENGTH_CODES);\n    for (i = 0; i < num_codes; ++i) {\n      code_length_code_lengths[kCodeLengthCodeOrder[i]] = VP8LReadBits(br, 3);\n    }\n    ok = ReadHuffmanCodeLengths(dec, code_length_code_lengths, alphabet_size,\n                                code_lengths);\n  }\n  ok = ok && !br->eos_;\n  if (ok) {\n    size = VP8LBuildHuffmanTable(table, HUFFMAN_TABLE_BITS,\n                                 code_lengths, alphabet_size);\n  }\n  if (!ok || size == 0) {\n    return VP8LSetError(dec, VP8_STATUS_BITSTREAM_ERROR);\n  }\n  return size;\n}", "target": 1}
{"code": "[[noreturn]] void TProtocolException::throwInvalidSkipType(TType type) {\n  throw TProtocolException(\n      TProtocolException::INVALID_DATA,\n      folly::sformat(\n          \"Encountered invalid field/element type ({}) during skipping\",\n          static_cast<uint8_t>(type)));\n}", "target": 0}
{"code": "authentic_emu_update_tokeninfo(struct sc_profile *profile, struct sc_pkcs15_card *p15card,\n\t\tstruct sc_pkcs15_tokeninfo *tinfo)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_file *file = NULL;\n\tstruct sc_path path;\n\tunsigned char buffer[8];\n\tint rv,len;\n\tsc_format_path(AUTHENTIC_CACHE_TIMESTAMP_PATH, &path);\n\trv = sc_select_file(p15card->card, &path, &file);\n\tif (!rv) {\n\t\trv = sc_get_challenge(p15card->card, buffer, sizeof(buffer));\n\t\tif (!rv) {\n\t\t\tsc_file_free(file);\n\t\t\tLOG_TEST_RET(ctx, rv, \"Get challenge error\");\n\t\t}\n\t\tlen = file->size > sizeof(buffer) ? sizeof(buffer) : file->size;\n\t\trv = sc_update_binary(p15card->card, 0, buffer, len, 0);\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, rv, \"Update binary error\");\n\t}\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}", "target": 1}
{"code": "    setSanMatchers(std::vector<envoy::type::matcher::v3::StringMatcher> san_matchers) {\n      san_matchers_ = san_matchers;\n      return *this;\n    }", "target": 1}
{"code": "struct key *find_keyring_by_name(const char *name, bool skip_perm_check)\n{\n\tstruct key *keyring;\n\tint bucket;\n\tif (!name)\n\t\treturn ERR_PTR(-EINVAL);\n\tbucket = keyring_hash(name);\n\tread_lock(&keyring_name_lock);\n\tif (keyring_name_hash[bucket].next) {\n\t\tlist_for_each_entry(keyring,\n\t\t\t\t    &keyring_name_hash[bucket],\n\t\t\t\t    name_link\n\t\t\t\t    ) {\n\t\t\tif (!kuid_has_mapping(current_user_ns(), keyring->user->uid))\n\t\t\t\tcontinue;\n\t\t\tif (test_bit(KEY_FLAG_REVOKED, &keyring->flags))\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(keyring->description, name) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (!skip_perm_check &&\n\t\t\t    key_permission(make_key_ref(keyring, 0),\n\t\t\t\t\t   KEY_NEED_SEARCH) < 0)\n\t\t\t\tcontinue;\n\t\t\tif (!refcount_inc_not_zero(&keyring->usage))\n\t\t\t\tcontinue;\n\t\t\tkeyring->last_used_at = current_kernel_time().tv_sec;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tkeyring = ERR_PTR(-ENOKEY);\nout:\n\tread_unlock(&keyring_name_lock);\n\treturn keyring;\n}", "target": 1}
{"code": "int prepareForShutdown() {\n    redisLog(REDIS_WARNING,\"User requested shutdown, saving DB...\");\n    if (server.bgsavechildpid != -1) {\n        redisLog(REDIS_WARNING,\"There is a live saving child. Killing it!\");\n        kill(server.bgsavechildpid,SIGKILL);\n        rdbRemoveTempFile(server.bgsavechildpid);\n    }\n    if (server.appendonly) {\n        aof_fsync(server.appendfd);\n        if (server.vm_enabled) unlink(server.vm_swap_file);\n    } else if (server.saveparamslen > 0) {\n        if (rdbSave(server.dbfilename) != REDIS_OK) {\n            redisLog(REDIS_WARNING,\"Error trying to save the DB, can't exit\");\n            return REDIS_ERR;\n        }\n    } else {\n        redisLog(REDIS_WARNING,\"Not saving DB.\");\n    }\n    if (server.daemonize) unlink(server.pidfile);\n    redisLog(REDIS_WARNING,\"Server exit now, bye bye...\");\n    return REDIS_OK;\n}", "target": 1}
{"code": "static int http_read_stream(URLContext *h, uint8_t *buf, int size)\n{\n    HTTPContext *s = h->priv_data;\n    int err, new_location, read_ret;\n    int64_t seek_ret;\n    if (!s->hd)\n        return AVERROR_EOF;\n    if (s->end_chunked_post && !s->end_header) {\n        err = http_read_header(h, &new_location);\n        if (err < 0)\n            return err;\n    }\n    if (s->chunksize >= 0) {\n        if (!s->chunksize) {\n            char line[32];\n                do {\n                    if ((err = http_get_line(s, line, sizeof(line))) < 0)\n                        return err;\n                } while (!*line);    \n                s->chunksize = strtoll(line, NULL, 16);\n                av_log(NULL, AV_LOG_TRACE, \"Chunked encoding data size: %\"PRId64\"'\\n\",\n                        s->chunksize);\n                if (!s->chunksize)\n                    return 0;\n        }\n        size = FFMIN(size, s->chunksize);\n    }\n#if CONFIG_ZLIB\n    if (s->compressed)\n        return http_buf_read_compressed(h, buf, size);\n#endif \n    read_ret = http_buf_read(h, buf, size);\n    if (   (read_ret  < 0 && s->reconnect        && (!h->is_streamed || s->reconnect_streamed) && s->filesize > 0 && s->off < s->filesize)\n        || (read_ret == 0 && s->reconnect_at_eof && (!h->is_streamed || s->reconnect_streamed))) {\n        int64_t target = h->is_streamed ? 0 : s->off;\n        if (s->reconnect_delay > s->reconnect_delay_max)\n            return AVERROR(EIO);\n        av_log(h, AV_LOG_INFO, \"Will reconnect at %\"PRId64\" error=%s.\\n\", s->off, av_err2str(read_ret));\n        av_usleep(1000U*1000*s->reconnect_delay);\n        s->reconnect_delay = 1 + 2*s->reconnect_delay;\n        seek_ret = http_seek_internal(h, target, SEEK_SET, 1);\n        if (seek_ret != target) {\n            av_log(h, AV_LOG_ERROR, \"Failed to reconnect at %\"PRId64\".\\n\", target);\n            return read_ret;\n        }\n        read_ret = http_buf_read(h, buf, size);\n    } else\n        s->reconnect_delay = 0;\n    return read_ret;\n}", "target": 1}
{"code": "deltas_head_add(struct deltas_head *deltas, unsigned long max_serial,\n    unsigned long serial, char *uri, unsigned char *hash, size_t hash_len)\n{\n\tstruct delta_head *elem;\n\tsize_t position;\n\tint error;\n\tposition = deltas->capacity - 1 - (max_serial - serial);\n\tif (position < 0 || position > deltas->capacity - 1)\n\t\treturn -EINVAL;\n\tif (deltas->array[position] != NULL)\n\t\treturn -EEXIST;\n\telem = NULL;\n\terror = delta_head_create(&elem);\n\tif (error)\n\t\treturn error;\n\telem->serial = serial;\n\telem->doc_data.uri = strdup(uri);\n\tif (elem->doc_data.uri == NULL) {\n\t\tfree(elem);\n\t\treturn pr_enomem();\n\t}\n\telem->doc_data.hash_len = hash_len;\n\telem->doc_data.hash = malloc(hash_len);\n\tif (elem->doc_data.hash == NULL) {\n\t\tfree(elem->doc_data.uri);\n\t\tfree(elem);\n\t\treturn pr_enomem();\n\t}\n\tmemcpy(elem->doc_data.hash, hash, hash_len);\n\tdeltas->array[position] = elem;\n\tdeltas->len++;\n\treturn 0;\n}", "target": 1}
{"code": "completion_glob_pattern (string)\n     char *string;\n{\n  register int c;\n  char *send;\n  int open;\n  DECLARE_MBSTATE;\n  open = 0;\n  send = string + strlen (string);\n  while (c = *string++)\n    {\n      switch (c)\n\t{\n\tcase '?':\n\tcase '*':\n\t  return (1);\n\tcase '[':\n\t  open++;\n\t  continue;\n\tcase ']':\n\t  if (open)\n\t    return (1);\n\t  continue;\n\tcase '+':\n\tcase '@':\n\tcase '!':\n\t  if (*string == '(')\t\n\t    return (1);\n\t  continue;\n\tcase '\\\\':\n\t  if (*string++ == 0)\n\t    return (0);\n\t}\n#ifdef HANDLE_MULTIBYTE\n      string--;\n      ADVANCE_CHAR_P (string, send - string);\n      string++;\n#else\n      ADVANCE_CHAR_P (string, send - string);\n#endif\n    }\n  return (0);\n}", "target": 1}
{"code": "int sock_present2network(const char *address, struct sockaddr_storage *sockaddr, int addr_family, char *errbuf, int errbuflen)\n{\n\tstruct addrinfo *addrinfo;\n\tstruct addrinfo hints;\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = addr_family;\n\tif (sock_initaddress(address, \"22222\" , &hints, &addrinfo, errbuf, errbuflen) == -1)\n\t\treturn 0;\n\tif (addrinfo->ai_family == PF_INET)\n\t\tmemcpy(sockaddr, addrinfo->ai_addr, sizeof(struct sockaddr_in));\n\telse\n\t\tmemcpy(sockaddr, addrinfo->ai_addr, sizeof(struct sockaddr_in6));\n\tif (addrinfo->ai_next != NULL)\n\t{\n\t\tfreeaddrinfo(addrinfo);\n\t\tif (errbuf)\n\t\t\tsnprintf(errbuf, errbuflen, \"More than one socket requested; using the first one returned\");\n\t\treturn -2;\n\t}\n\tfreeaddrinfo(addrinfo);\n\treturn -1;\n}", "target": 1}
{"code": "check(str, sub, should)\nchar *str;\nmy_regmatch_t sub;\nchar *should;\n{\n\tregister int len;\n\tregister int shlen;\n\tregister char *p;\n\tstatic char grump[500];\n\tregister char *at = NULL;\n\tif (should != NULL && strcmp(should, \"-\") == 0)\n\t\tshould = NULL;\n\tif (should != NULL && should[0] == '@') {\n\t\tat = should + 1;\n\t\tshould = (char*) \"\";\n\t}\n\tif (sub.rm_so > sub.rm_eo || (sub.rm_so == -1 && sub.rm_eo != -1) ||\n\t\t\t\t(sub.rm_so != -1 && sub.rm_eo == -1) ||\n\t\t\t\t(sub.rm_so != -1 && sub.rm_so < 0) ||\n\t\t\t\t(sub.rm_eo != -1 && sub.rm_eo < 0) ) {\n\t\tsprintf(grump, \"start %ld end %ld\", (long)sub.rm_so,\n\t\t\t\t\t\t\t(long)sub.rm_eo);\n\t\treturn(grump);\n\t}\n\tif (sub.rm_so == -1 && should == NULL)\n\t\treturn(NULL);\n\tif (sub.rm_so == -1)\n\t\treturn((char*) \"did not match\");\n\tif ((int) sub.rm_eo > (int) strlen(str)) {\n\t\tsprintf(grump, \"start %ld end %ld, past end of string\",\n\t\t\t\t\t(long)sub.rm_so, (long)sub.rm_eo);\n\t\treturn(grump);\n\t}\n\tlen = (int)(sub.rm_eo - sub.rm_so);\n\tshlen = (int)strlen(should);\n\tp = str + sub.rm_so;\n\tif (should == NULL) {\n\t\tsprintf(grump, \"matched `%.*s'\", len, p);\n\t\treturn(grump);\n\t}\n\tif (len != shlen || strncmp(p, should, (size_t)shlen) != 0) {\n\t\tsprintf(grump, \"matched `%.*s' instead\", len, p);\n\t\treturn(grump);\n\t}\n\tif (shlen > 0)\n\t\treturn(NULL);\n\tif (at == NULL)\n\t\treturn(NULL);\n\tshlen = strlen(at);\n\tif (shlen == 0)\n\t\tshlen = 1;\t\n\tif (strncmp(p, at, shlen) != 0) {\n\t\tsprintf(grump, \"matched null at `%.20s'\", p);\n\t\treturn(grump);\n\t}\n\treturn(NULL);\n}", "target": 1}
{"code": "OpLevelCostEstimator::OpDimensionsFromInputs(\n    const TensorShapeProto& original_image_shape, const OpInfo& op_info,\n    bool* found_unknown_shapes) {\n  VLOG(2) << \"op features: \" << op_info.DebugString();\n  VLOG(2) << \"Original image shape: \" << original_image_shape.DebugString();\n  auto image_shape =\n      MaybeGetMinimumShape(original_image_shape, 4, found_unknown_shapes);\n  VLOG(2) << \"Image shape: \" << image_shape.DebugString();\n  int x_index, y_index, channel_index;\n  const std::string& data_format = GetDataFormat(op_info);\n  if (data_format == \"NCHW\") {\n    channel_index = 1;\n    y_index = 2;\n    x_index = 3;\n  } else {\n    y_index = 1;\n    x_index = 2;\n    channel_index = 3;\n  }\n  int64_t batch = image_shape.dim(0).size();\n  int64_t ix = image_shape.dim(x_index).size();\n  int64_t iy = image_shape.dim(y_index).size();\n  int64_t iz = image_shape.dim(channel_index).size();\n  std::vector<int64_t> ksize = GetKernelSize(op_info);\n  int64_t kx = ksize[x_index];\n  int64_t ky = ksize[y_index];\n  int64_t kz = iz;\n  std::vector<int64_t> strides = GetStrides(op_info);\n  int64_t sx = strides[x_index];\n  int64_t sy = strides[y_index];\n  if (sx == 0 || sy == 0) {\n    return errors::InvalidArgument(\n        \"Stride must be > 0 for Height and Width, but got (\", sy, \", \", sx,\n        \")\");\n  }\n  const auto padding = GetPadding(op_info);\n  int64_t ox = GetOutputSize(ix, kx, sx, padding);\n  int64_t oy = GetOutputSize(iy, ky, sy, padding);\n  int64_t oz = iz;\n  OpLevelCostEstimator::ConvolutionDimensions conv_dims = {\n      batch, ix, iy, iz, kx, ky, kz, oz, ox, oy, sx, sy, padding};\n  return conv_dims;\n}", "target": 0}
{"code": "void test_symlink(const char *path)\n{\n\tchar *d = strdupa(path), *tmpname;\n\td = dirname(d);\n\tsize_t len = strlen(path) + 30;\n\ttmpname = alloca(len);\n\tsnprintf(tmpname, len, \"%s/%d\", d, (int)getpid());\n\tif (symlink(tmpname, path) == 0) {\n\t\tfprintf(stderr, \"leak at symlink of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at symlink of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n\tif (symlink(path, tmpname) == 0) {\n\t\tfprintf(stderr, \"leak at symlink (2) of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at symlink (2) of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "static int cypress_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct cypress_private *priv = usb_get_serial_port_data(port);\n\tstruct usb_serial *serial = port->serial;\n\tunsigned long flags;\n\tint result = 0;\n\tif (!priv->comm_is_ok)\n\t\treturn -EIO;\n\tusb_clear_halt(serial->dev, 0x81);\n\tusb_clear_halt(serial->dev, 0x02);\n\tspin_lock_irqsave(&priv->lock, flags);\n\tpriv->bytes_in = 0;\n\tpriv->bytes_out = 0;\n\tpriv->cmd_count = 0;\n\tpriv->rx_flags = 0;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\tcypress_send(port);\n\tif (tty)\n\t\tcypress_set_termios(tty, port, &priv->tmp_termios);\n\tif (!port->interrupt_in_urb) {\n\t\tdev_err(&port->dev, \"%s - interrupt_in_urb is empty!\\n\",\n\t\t\t__func__);\n\t\treturn -1;\n\t}\n\tusb_fill_int_urb(port->interrupt_in_urb, serial->dev,\n\t\tusb_rcvintpipe(serial->dev, port->interrupt_in_endpointAddress),\n\t\tport->interrupt_in_urb->transfer_buffer,\n\t\tport->interrupt_in_urb->transfer_buffer_length,\n\t\tcypress_read_int_callback, port, priv->read_urb_interval);\n\tresult = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\n\tif (result) {\n\t\tdev_err(&port->dev,\n\t\t\t\"%s - failed submitting read urb, error %d\\n\",\n\t\t\t\t\t\t\t__func__, result);\n\t\tcypress_set_dead(port);\n\t}\n\treturn result;\n} ", "target": 1}
{"code": "TEST_SUITE_CLEANUP(suite_cleanup)\n{\n    umock_c_deinit();\n    TEST_MUTEX_DESTROY(g_testByTest);\n}", "target": 0}
{"code": "void __mb2_cache_entry_free(struct mb2_cache_entry *entry)\n{\n\tkmem_cache_free(mb2_entry_cache, entry);\n}", "target": 0}
{"code": "static uint32_t mp_clzll(unsigned long long x) {\n    unsigned long lz = 0;\n    return _BitScanReverse64(&lz, x) ? (sizeof(x) * 8 - 1) - lz : 0;\n}", "target": 0}
{"code": "int is_valid_msg_type(const char *msg_id, const char *msg_type)\n{\n\tif (parse_msg_id(msg_id) < 0)\n\t\treturn 0;\n\tparse_msg_type(msg_type);\n\treturn 1;\n}", "target": 0}
{"code": "static void adpt_i2o_post_wait_complete(u32 context, int status)\n{\n\tstruct adpt_i2o_post_wait_data *p1 = NULL;\n\tcontext &= 0x7fff;\n\tspin_lock(&adpt_post_wait_lock);\n\tfor(p1 = adpt_post_wait_queue; p1; p1 = p1->next) {\n\t\tif(p1->id == context) {\n\t\t\tp1->status = status;\n\t\t\tspin_unlock(&adpt_post_wait_lock);\n\t\t\twake_up_interruptible(p1->wq);\n\t\t\treturn;\n\t\t}\n\t}\n\tspin_unlock(&adpt_post_wait_lock);\n\tprintk(KERN_DEBUG\"dpti: Could Not find task %d in wait queue\\n\",context);\n\tprintk(KERN_DEBUG\"      Tasks in wait queue:\\n\");\n\tfor(p1 = adpt_post_wait_queue; p1; p1 = p1->next) {\n\t\tprintk(KERN_DEBUG\"           %d\\n\",p1->id);\n\t}\n\treturn;\n}", "target": 1}
{"code": "__u32 secure_tcpv6_sequence_number(__be32 *saddr, __be32 *daddr,\n\t\t\t\t   __be16 sport, __be16 dport)\n{\n\t__u32 seq;\n\t__u32 hash[12];\n\tstruct keydata *keyptr = get_keyptr();\n\tmemcpy(hash, saddr, 16);\n\thash[4] = ((__force u16)sport << 16) + (__force u16)dport;\n\tmemcpy(&hash[5], keyptr->secret, sizeof(__u32) * 7);\n\tseq = twothirdsMD4Transform((const __u32 *)daddr, hash) & HASH_MASK;\n\tseq += keyptr->count;\n\tseq += ktime_to_ns(ktime_get_real());\n\treturn seq;\n}", "target": 1}
{"code": "static void free_user(struct kref *ref)\n{\n\tstruct ipmi_user *user = container_of(ref, struct ipmi_user, refcount);\n\tcleanup_srcu_struct(&user->release_barrier);\n\tkfree(user);\n}", "target": 0}
{"code": "bool ParseAttrValue(StringPiece type, StringPiece text, AttrValue* out) {\n  string field_name;\n  bool is_list = absl::ConsumePrefix(&type, \"list(\");\n  if (absl::ConsumePrefix(&type, \"string\")) {\n    field_name = \"s\";\n  } else if (absl::ConsumePrefix(&type, \"int\")) {\n    field_name = \"i\";\n  } else if (absl::ConsumePrefix(&type, \"float\")) {\n    field_name = \"f\";\n  } else if (absl::ConsumePrefix(&type, \"bool\")) {\n    field_name = \"b\";\n  } else if (absl::ConsumePrefix(&type, \"type\")) {\n    field_name = \"type\";\n  } else if (absl::ConsumePrefix(&type, \"shape\")) {\n    field_name = \"shape\";\n  } else if (absl::ConsumePrefix(&type, \"tensor\")) {\n    field_name = \"tensor\";\n  } else if (absl::ConsumePrefix(&type, \"func\")) {\n    field_name = \"func\";\n  } else if (absl::ConsumePrefix(&type, \"placeholder\")) {\n    field_name = \"placeholder\";\n  } else {\n    return false;\n  }\n  if (is_list && !absl::ConsumePrefix(&type, \")\")) {\n    return false;\n  }\n  string to_parse;\n  if (is_list) {\n    StringPiece cleaned = text;\n    str_util::RemoveLeadingWhitespace(&cleaned);\n    str_util::RemoveTrailingWhitespace(&cleaned);\n    if (cleaned.size() < 2 || cleaned[0] != '[' ||\n        cleaned[cleaned.size() - 1] != ']') {\n      return false;\n    }\n    cleaned.remove_prefix(1);\n    str_util::RemoveLeadingWhitespace(&cleaned);\n    if (cleaned.size() == 1) {\n      out->Clear();\n      out->mutable_list();\n      return true;\n    }\n    to_parse = strings::StrCat(\"list { \", field_name, \": \", text, \" }\");\n  } else {\n    to_parse = strings::StrCat(field_name, \": \", text);\n  }\n  return ProtoParseFromString(to_parse, out);\n}", "target": 1}
{"code": "  TestCertificateValidationContextConfig(\n      envoy::config::core::v3::TypedExtensionConfig config, bool allow_expired_certificate = false,\n      std::vector<envoy::type::matcher::v3::StringMatcher> san_matchers = {})\n      : allow_expired_certificate_(allow_expired_certificate), api_(Api::createApiForTest()),\n        custom_validator_config_(config), san_matchers_(san_matchers){};", "target": 1}
{"code": "STACK_OF(PKCS12_SAFEBAG) *PKCS12_unpack_p7data(PKCS7 *p7)\n{\n    if (!PKCS7_type_is_data(p7)) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_CONTENT_TYPE_NOT_DATA);\n        return NULL;\n    }\n    if (p7->d.data == NULL) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_DECODE_ERROR);\n        return NULL;\n    }\n    return ASN1_item_unpack_ex(p7->d.data, ASN1_ITEM_rptr(PKCS12_SAFEBAGS),\n                               ossl_pkcs7_ctx_get0_libctx(&p7->ctx),\n                               ossl_pkcs7_ctx_get0_propq(&p7->ctx));\n}", "target": 0}
{"code": "deltas_head_set_size(struct deltas_head *deltas, size_t capacity)\n{\n\tsize_t i;\n\tif (deltas->array != NULL)\n\t\tpr_crit(\"Size of this list can't be modified\");\n\tdeltas->capacity = capacity;\n\tif (capacity == 0)\n\t\treturn 0; \n\tdeltas->array = malloc(deltas->capacity\n\t    * sizeof(struct delta_head *));\n\tif (deltas->array == NULL)\n\t\treturn pr_enomem();\n\tfor (i = 0; i < deltas->capacity; i++)\n\t\tdeltas->array[i] = NULL;\n\treturn 0;\n}", "target": 1}
{"code": "static int xc2028_set_config(struct dvb_frontend *fe, void *priv_cfg)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tstruct xc2028_ctrl *p    = priv_cfg;\n\tint                 rc   = 0;\n\ttuner_dbg(\"%s called\\n\", __func__);\n\tmutex_lock(&priv->lock);\n\tkfree(priv->ctrl.fname);\n\tmemcpy(&priv->ctrl, p, sizeof(priv->ctrl));\n\tif (p->fname) {\n\t\tpriv->ctrl.fname = kstrdup(p->fname, GFP_KERNEL);\n\t\tif (priv->ctrl.fname == NULL)\n\t\t\trc = -ENOMEM;\n\t}\n\tif (!firmware_name[0] && p->fname &&\n\t    priv->fname && strcmp(p->fname, priv->fname))\n\t\tfree_firmware(priv);\n\tif (priv->ctrl.max_len < 9)\n\t\tpriv->ctrl.max_len = 13;\n\tif (priv->state == XC2028_NO_FIRMWARE) {\n\t\tif (!firmware_name[0])\n\t\t\tpriv->fname = priv->ctrl.fname;\n\t\telse\n\t\t\tpriv->fname = firmware_name;\n\t\trc = request_firmware_nowait(THIS_MODULE, 1,\n\t\t\t\t\t     priv->fname,\n\t\t\t\t\t     priv->i2c_props.adap->dev.parent,\n\t\t\t\t\t     GFP_KERNEL,\n\t\t\t\t\t     fe, load_firmware_cb);\n\t\tif (rc < 0) {\n\t\t\ttuner_err(\"Failed to request firmware %s\\n\",\n\t\t\t\t  priv->fname);\n\t\t\tpriv->state = XC2028_NODEV;\n\t\t} else\n\t\t\tpriv->state = XC2028_WAITING_FIRMWARE;\n\t}\n\tmutex_unlock(&priv->lock);\n\treturn rc;\n}", "target": 1}
{"code": "  void getReadBuffer(void** bufReturn, size_t* lenReturn) override {\n    *bufReturn = buf_.data();\n    *lenReturn = buf_.size();\n  }", "target": 0}
{"code": "void ip_send_reply(struct sock *sk, struct sk_buff *skb, struct ip_reply_arg *arg,\n\t\t   unsigned int len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct {\n\t\tstruct ip_options\topt;\n\t\tchar\t\t\tdata[40];\n\t} replyopts;\n\tstruct ipcm_cookie ipc;\n\t__be32 daddr;\n\tstruct rtable *rt = skb_rtable(skb);\n\tif (ip_options_echo(&replyopts.opt, skb))\n\t\treturn;\n\tdaddr = ipc.addr = rt->rt_src;\n\tipc.opt = NULL;\n\tipc.tx_flags = 0;\n\tif (replyopts.opt.optlen) {\n\t\tipc.opt = &replyopts.opt;\n\t\tif (ipc.opt->srr)\n\t\t\tdaddr = replyopts.opt.faddr;\n\t}\n\t{\n\t\tstruct flowi4 fl4;\n\t\tflowi4_init_output(&fl4, arg->bound_dev_if, 0,\n\t\t\t\t   RT_TOS(ip_hdr(skb)->tos),\n\t\t\t\t   RT_SCOPE_UNIVERSE, sk->sk_protocol,\n\t\t\t\t   ip_reply_arg_flowi_flags(arg),\n\t\t\t\t   daddr, rt->rt_spec_dst,\n\t\t\t\t   tcp_hdr(skb)->source, tcp_hdr(skb)->dest);\n\t\tsecurity_skb_classify_flow(skb, flowi4_to_flowi(&fl4));\n\t\trt = ip_route_output_key(sock_net(sk), &fl4);\n\t\tif (IS_ERR(rt))\n\t\t\treturn;\n\t}\n\tbh_lock_sock(sk);\n\tinet->tos = ip_hdr(skb)->tos;\n\tsk->sk_priority = skb->priority;\n\tsk->sk_protocol = ip_hdr(skb)->protocol;\n\tsk->sk_bound_dev_if = arg->bound_dev_if;\n\tip_append_data(sk, ip_reply_glue_bits, arg->iov->iov_base, len, 0,\n\t\t       &ipc, &rt, MSG_DONTWAIT);\n\tif ((skb = skb_peek(&sk->sk_write_queue)) != NULL) {\n\t\tif (arg->csumoffset >= 0)\n\t\t\t*((__sum16 *)skb_transport_header(skb) +\n\t\t\t  arg->csumoffset) = csum_fold(csum_add(skb->csum,\n\t\t\t\t\t\t\t\targ->csum));\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\tip_push_pending_frames(sk);\n\t}\n\tbh_unlock_sock(sk);\n\tip_rt_put(rt);\n}", "target": 1}
{"code": "l2tp_framing_type_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint32_t *ptr = (const uint32_t *)dat;\n\tif (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_TYPE_ASYNC_MASK) {\n\t\tND_PRINT((ndo, \"A\"));\n\t}\n\tif (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_TYPE_SYNC_MASK) {\n\t\tND_PRINT((ndo, \"S\"));\n\t}\n}", "target": 1}
{"code": "static inline struct ipv6_txoptions *txopt_get(const struct ipv6_pinfo *np)\n{\n\tstruct ipv6_txoptions *opt;\n\trcu_read_lock();\n\topt = rcu_dereference(np->opt);\n\tif (opt && !atomic_inc_not_zero(&opt->refcnt))\n\t\topt = NULL;\n\trcu_read_unlock();\n\treturn opt;\n}", "target": 0}
{"code": "static void br_multicast_del_pg(struct net_bridge *br,\n\t\t\t\tstruct net_bridge_port_group *pg)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tmdb = mlock_dereference(br->mdb, br);\n\tmp = br_mdb_ip_get(mdb, &pg->addr);\n\tif (WARN_ON(!mp))\n\t\treturn;\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (p != pg)\n\t\t\tcontinue;\n\t\trcu_assign_pointer(*pp, p->next);\n\t\thlist_del_init(&p->mglist);\n\t\tdel_timer(&p->timer);\n\t\tcall_rcu_bh(&p->rcu, br_multicast_free_pg);\n\t\tif (!mp->ports && !mp->mglist &&\n\t\t    netif_running(br->dev))\n\t\t\tmod_timer(&mp->timer, jiffies);\n\t\treturn;\n\t}\n\tWARN_ON(1);\n}", "target": 1}
{"code": "MOBI_RET mobi_search_links_kf7(MOBIResult *result, const unsigned char *data_start, const unsigned char *data_end) {\n    if (!result) {\n        debug_print(\"Result structure is null%s\", \"\\n\");\n        return MOBI_PARAM_ERR;\n    }\n    result->start = result->end = NULL;\n    *(result->value) = '\\0';\n    if (!data_start || !data_end) {\n        debug_print(\"Data is null%s\", \"\\n\");\n        return MOBI_PARAM_ERR;\n    }\n    const char *needle1 = \"filepos=\";\n    const char *needle2 = \"recindex=\";\n    const size_t needle1_length = strlen(needle1);\n    const size_t needle2_length = strlen(needle2);\n    const size_t needle_length = max(needle1_length,needle2_length);\n    if (data_start + needle_length > data_end) {\n        return MOBI_SUCCESS;\n    }\n    unsigned char *data = (unsigned char *) data_start;\n    const unsigned char tag_open = '<';\n    const unsigned char tag_close = '>';\n    unsigned char last_border = tag_open;\n    while (data <= data_end) {\n        if (*data == tag_open || *data == tag_close) {\n            last_border = *data;\n        }\n        if (data + needle_length <= data_end &&\n            (memcmp(data, needle1, needle1_length) == 0 ||\n             memcmp(data, needle2, needle2_length) == 0)) {\n                if (last_border != tag_open) {\n                    data += needle_length;\n                    continue;\n                }\n                while (data >= data_start && !isspace(*data) && *data != tag_open) {\n                    data--;\n                }\n                result->start = ++data;\n                int i = 0;\n                while (data <= data_end && !isspace(*data) && *data != tag_close && i < MOBI_ATTRVALUE_MAXSIZE) {\n                    result->value[i++] = (char) *data++;\n                }\n                if (*(data - 1) == '/' && *data == '>') {\n                    --data; --i;\n                }\n                result->end = data;\n                result->value[i] = '\\0';\n                return MOBI_SUCCESS;\n            }\n        data++;\n    }\n    return MOBI_SUCCESS;\n}", "target": 1}
{"code": "static char *create_output_name(unsigned char *fname, unsigned char *dir,\n\t\t\t int lower, int isunix, int utf8)\n{\n  unsigned char *p, *name, c, *fe, sep, slash;\n  unsigned int x;\n  sep   = (isunix) ? '/'  : '\\\\'; \n  slash = (isunix) ? '\\\\' : '/';  \n  x = strlen((char *) fname);\n  if (utf8) x *= 3;\n  if (dir) x += strlen((char *) dir);\n  if (!(name = (unsigned char *) malloc(x + 2))) {\n    fprintf(stderr, \"out of memory!\\n\");\n    return NULL;\n  }\n  *name = '\\0';\n  if (dir) {\n    strcpy((char *) name, (char *) dir);\n    strcat((char *) name, \"/\");\n  }\n  while (*fname == sep) fname++;\n  p = &name[strlen((char *)name)];\n  fe = &fname[strlen((char *)fname)];\n  if (utf8) {\n    do {\n      if (fname >= fe) {\n\tfree(name);\n\treturn NULL;\n      }\n      if ((c = *fname++) < 0x80) x = c;\n      else {\n\tif ((c >= 0xC0) && (c < 0xE0)) {\n\t  x = (c & 0x1F) << 6;\n\t  x |= *fname++ & 0x3F;\n\t}\n\telse if ((c >= 0xE0) && (c < 0xF0)) {\n\t  x = (c & 0xF) << 12;\n\t  x |= (*fname++ & 0x3F) << 6;\n\t  x |= *fname++ & 0x3F;\n\t}\n\telse x = '?';\n      }\n      if      (x == sep)   x = '/';\n      else if (x == slash) x = '\\\\';\n      else if (lower)      x = (unsigned int) tolower((int) x);\n      if (x < 0x80) {\n\t*p++ = (unsigned char) x;\n      }\n      else if (x < 0x800) {\n\t*p++ = 0xC0 | (x >> 6);   \n\t*p++ = 0x80 | (x & 0x3F);\n      }\n      else {\n\t*p++ = 0xE0 | (x >> 12);\n\t*p++ = 0x80 | ((x >> 6) & 0x3F);\n\t*p++ = 0x80 | (x & 0x3F);\n      }\n    } while (x);\n  }\n  else {\n    do {\n      c = *fname++;\n      if      (c == sep)   c = '/';\n      else if (c == slash) c = '\\\\';\n      else if (lower)      c = (unsigned char) tolower((int) c);\n    } while ((*p++ = c));\n  }\n  return (char *) name;\n}", "target": 1}
{"code": "MONGO_EXPORT void __mongo_set_error( mongo *conn, mongo_error_t err, const char *str,\n                                     int errcode ) {\n    int errstr_size, str_size;\n    conn->err = err;\n    conn->errcode = errcode;\n    if( str ) {\n        str_size = strlen( str ) + 1;\n        errstr_size = str_size > MONGO_ERR_LEN ? MONGO_ERR_LEN : str_size;\n        memcpy( conn->errstr, str, errstr_size );\n        conn->errstr[errstr_size-1] = '\\0';\n    }\n}", "target": 1}
{"code": "int main(void)\n{\n    size_t failedTestCount = 0;\n    RUN_TEST_SUITE(link_ut, failedTestCount);\n    return (int)failedTestCount;\n}", "target": 0}
{"code": "static bool anal_fcn_data (RCore *core, const char *input) {\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);\n\tut32 fcn_size = r_anal_function_size_from_entry (fcn);\n\tif (fcn) {\n\t\tint i;\n\t\tbool gap = false;\n\t\tut64 gap_addr = UT64_MAX;\n\t\tchar *bitmap = calloc (1, fcn_size);\n\t\tif (bitmap) {\n\t\t\tRAnalBlock *b;\n\t\t\tRListIter *iter;\n\t\t\tr_list_foreach (fcn->bbs, iter, b) {\n\t\t\t\tint f = b->addr - fcn->addr;\n\t\t\t\tint t = R_MIN (f + b->size, fcn_size);\n\t\t\t\tif (f >= 0) {\n\t\t\t\t\twhile (f < t) {\n\t\t\t\t\t\tbitmap[f++] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < fcn_size; i++) {\n\t\t\tut64 here = fcn->addr + i;\n\t\t\tif (bitmap && bitmap[i]) {\n\t\t\t\tif (gap) {\n\t\t\t\t\tr_cons_printf (\"Cd %d @ 0x%08\"PFMT64x\"\\n\", here - gap_addr, gap_addr);\n\t\t\t\t\tgap = false;\n\t\t\t\t}\n\t\t\t\tgap_addr = UT64_MAX;\n\t\t\t} else {\n\t\t\t\tif (!gap) {\n\t\t\t\t\tgap = true;\n\t\t\t\t\tgap_addr = here;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (gap) {\n\t\t\tr_cons_printf (\"Cd %d @ 0x%08\"PFMT64x\"\\n\", fcn->addr + fcn_size - gap_addr, gap_addr);\n\t\t}\n\t\tfree (bitmap);\n\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "static void update_bp_intercept(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tclr_exception_intercept(svm, BP_VECTOR);\n\tif (vcpu->guest_debug & KVM_GUESTDBG_ENABLE) {\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)\n\t\t\tset_exception_intercept(svm, BP_VECTOR);\n\t} else\n\t\tvcpu->guest_debug = 0;\n}", "target": 0}
{"code": "sctp_disposition_t sctp_sf_ootb(struct net *net,\n\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\tvoid *arg,\n\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sk_buff *skb = chunk->skb;\n\tsctp_chunkhdr_t *ch;\n\tsctp_errhdr_t *err;\n\t__u8 *ch_end;\n\tint ootb_shut_ack = 0;\n\tint ootb_cookie_ack = 0;\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\tch = (sctp_chunkhdr_t *) chunk->chunk_hdr;\n\tdo {\n\t\tif (ntohs(ch->length) < sizeof(sctp_chunkhdr_t))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\t\tif (SCTP_CID_SHUTDOWN_ACK == ch->type)\n\t\t\tootb_shut_ack = 1;\n\t\tif (SCTP_CID_ABORT == ch->type)\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\tif (SCTP_CID_COOKIE_ACK == ch->type)\n\t\t\tootb_cookie_ack = 1;\n\t\tif (SCTP_CID_ERROR == ch->type) {\n\t\t\tsctp_walk_errors(err, ch) {\n\t\t\t\tif (SCTP_ERROR_STALE_COOKIE == err->cause) {\n\t\t\t\t\tootb_cookie_ack = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tch_end = ((__u8 *)ch) + SCTP_PAD4(ntohs(ch->length));\n\t\tif (ch_end > skb_tail_pointer(skb))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\t\tch = (sctp_chunkhdr_t *) ch_end;\n\t} while (ch_end < skb_tail_pointer(skb));\n\tif (ootb_shut_ack)\n\t\treturn sctp_sf_shut_8_4_5(net, ep, asoc, type, arg, commands);\n\telse if (ootb_cookie_ack)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\telse\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n}", "target": 1}
{"code": "m_split(struct mbuf *m0, int len0, int wait)\n{\n\tstruct mbuf *m, *n;\n\tunsigned len = len0, remain, olen;\n\tfor (m = m0; m && len > m->m_len; m = m->m_next)\n\t\tlen -= m->m_len;\n\tif (m == NULL)\n\t\treturn (NULL);\n\tremain = m->m_len - len;\n\tif (m0->m_flags & M_PKTHDR) {\n\t\tMGETHDR(n, wait, m0->m_type);\n\t\tif (n == NULL)\n\t\t\treturn (NULL);\n\t\tif (m_dup_pkthdr(n, m0, wait)) {\n\t\t\tm_freem(n);\n\t\t\treturn (NULL);\n\t\t}\n\t\tn->m_pkthdr.len -= len0;\n\t\tolen = m0->m_pkthdr.len;\n\t\tm0->m_pkthdr.len = len0;\n\t\tif (remain == 0) {\n\t\t\tn->m_next = m->m_next;\n\t\t\tm->m_next = NULL;\n\t\t\tn->m_len = 0;\n\t\t\treturn (n);\n\t\t}\n\t\tif (m->m_flags & M_EXT)\n\t\t\tgoto extpacket;\n\t\tif (remain > MHLEN) {\n\t\t\tm_align(n, 0);\n\t\t\tn->m_next = m_split(m, len, wait);\n\t\t\tif (n->m_next == NULL) {\n\t\t\t\t(void) m_free(n);\n\t\t\t\tm0->m_pkthdr.len = olen;\n\t\t\t\treturn (NULL);\n\t\t\t} else {\n\t\t\t\tn->m_len = 0;\n\t\t\t\treturn (n);\n\t\t\t}\n\t\t} else\n\t\t\tm_align(n, remain);\n\t} else if (remain == 0) {\n\t\tn = m->m_next;\n\t\tm->m_next = NULL;\n\t\treturn (n);\n\t} else {\n\t\tMGET(n, wait, m->m_type);\n\t\tif (n == NULL)\n\t\t\treturn (NULL);\n\t\tm_align(n, remain);\n\t}\nextpacket:\n\tif (m->m_flags & M_EXT) {\n\t\tn->m_ext = m->m_ext;\n\t\tMCLADDREFERENCE(m, n);\n\t\tn->m_data = m->m_data + len;\n\t} else {\n\t\tmemcpy(mtod(n, caddr_t), mtod(m, caddr_t) + len, remain);\n\t}\n\tn->m_len = remain;\n\tm->m_len = len;\n\tn->m_next = m->m_next;\n\tm->m_next = NULL;\n\treturn (n);\n}", "target": 1}
{"code": "TEST_F(QueryPlannerTest, NonPrefixRegexOrCovering) {\n    addIndex(BSON(\"a\" << 1));\n    runQuerySortProj(\n        fromjson(\"{$or: [{a: /0/}, {a: /1/}]}\"), BSONObj(), fromjson(\"{_id: 0, a: 1}\"));\n    ASSERT_EQUALS(getNumSolutions(), 2U);\n    assertSolutionExists(\n        \"{proj: {spec: {_id: 0, a: 1}, node: \"\n        \"{cscan: {dir: 1, filter: {$or: [{a: /0/}, {a: /1/}]}}}}}\");\n    assertSolutionExists(\n        \"{proj: {spec: {_id: 0, a: 1}, node: \"\n        \"{ixscan: {filter: {$or: [{a: /0/}, {a: /1/}]}, pattern: {a: 1}}}}}\");\n}", "target": 0}
{"code": "int NCR_IsSyncPeer(NCR_Instance inst)\n{\n  return SRC_IsSyncPeer(inst->source);\n}", "target": 0}
{"code": "static int crypto_ablkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_blkcipher rblkcipher;\n\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"ablkcipher\");\n\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \"%s\",\n\t\t alg->cra_ablkcipher.geniv ?: \"<default>\");\n\trblkcipher.blocksize = alg->cra_blocksize;\n\trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;\n\trblkcipher.max_keysize = alg->cra_ablkcipher.max_keysize;\n\trblkcipher.ivsize = alg->cra_ablkcipher.ivsize;\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,\n\t\t    sizeof(struct crypto_report_blkcipher), &rblkcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "CONCRETE_IO_HANDLE socketio_create(void* io_create_parameters)\n{\n    SOCKETIO_CONFIG* socket_io_config = io_create_parameters;\n    SOCKET_IO_INSTANCE* result;\n    if (socket_io_config == NULL)\n    {\n        LogError(\"Invalid argument: socket_io_config is NULL\");\n        result = NULL;\n    }\n    else\n    {\n        result = malloc(sizeof(SOCKET_IO_INSTANCE));\n        if (result != NULL)\n        {\n            (void)memset(result, 0, sizeof(SOCKET_IO_INSTANCE));\n            result->address_type = ADDRESS_TYPE_IP;\n            result->pending_io_list = singlylinkedlist_create();\n            if (result->pending_io_list == NULL)\n            {\n                LogError(\"Failure: singlylinkedlist_create unable to create pending list.\");\n                destroy_socket_io_instance(result);\n                result = NULL;\n            }\n            else\n            {\n                if (socket_io_config->hostname != NULL)\n                {\n                    result->hostname = (char*)malloc(strlen(socket_io_config->hostname) + 1);\n                    if (result->hostname != NULL)\n                    {\n                        (void)strcpy(result->hostname, socket_io_config->hostname);\n                    }\n                    result->socket = INVALID_SOCKET;\n                }\n                else\n                {\n                    result->hostname = NULL;\n                    result->socket = *((int*)socket_io_config->accepted_socket);\n                }\n                if ((result->hostname == NULL) && (result->socket == INVALID_SOCKET))\n                {\n                    LogError(\"Failure: hostname == NULL and socket is invalid.\");\n                    destroy_socket_io_instance(result);\n                    result = NULL;\n                }\n                else\n                {\n                    result->port = socket_io_config->port;\n                    result->on_io_open_complete = NULL;\n                    result->dns_resolver = dns_resolver_create(result->hostname, socket_io_config->port, NULL);\n                    result->target_mac_address = NULL;\n                    result->on_bytes_received = NULL;\n                    result->on_io_error = NULL;\n                    result->on_bytes_received_context = NULL;\n                    result->on_io_error_context = NULL;\n                    result->io_state = IO_STATE_CLOSED;\n                }\n            }\n        }\n        else\n        {\n            LogError(\"Allocation Failure: SOCKET_IO_INSTANCE\");\n        }\n    }\n    return result;\n}", "target": 1}
{"code": "int main(int argc, char *argv[]) {\n  try {\n    for (int i = 1; i < argc; i++) {\n      string arg = argv[i];\n      if (arg == \"--extract\" && i < argc - 1) {\n        TarFileReader reader(argv[++i]);\n        while (reader.hasMore())\n          cout << reader.extract() << endl;\n      } else THROWS(\"Invalid arg '\" << arg << \"'\");\n    }\n    return 0;\n  } catch (const Exception &e) {cerr << e.getMessage();}\n  return 1;\n}", "target": 0}
{"code": "LibRaw_byte_buffer *LibRaw_abstract_datastream::make_byte_buffer(unsigned int sz)\n{\n  if(INT64(sz)>size())\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n    LibRaw_byte_buffer *ret = new LibRaw_byte_buffer(sz);\n    if(!ret) \n      throw LIBRAW_EXCEPTION_ALLOC;\n    read(ret->get_buffer(),sz,1);\n    return ret;\n}", "target": 0}
{"code": "ossl_cipher_update(int argc, VALUE *argv, VALUE self)\n{\n    EVP_CIPHER_CTX *ctx;\n    unsigned char *in;\n    long in_len, out_len;\n    VALUE data, str;\n    rb_scan_args(argc, argv, \"11\", &data, &str);\n    if (!RTEST(rb_attr_get(self, id_key_set)))\n\tossl_raise(eCipherError, \"key not set\");\n    StringValue(data);\n    in = (unsigned char *)RSTRING_PTR(data);\n    if ((in_len = RSTRING_LEN(data)) == 0)\n        ossl_raise(rb_eArgError, \"data must not be empty\");\n    GetCipher(self, ctx);\n    out_len = in_len+EVP_CIPHER_CTX_block_size(ctx);\n    if (out_len <= 0) {\n\tossl_raise(rb_eRangeError,\n\t\t   \"data too big to make output buffer: %ld bytes\", in_len);\n    }\n    if (NIL_P(str)) {\n        str = rb_str_new(0, out_len);\n    } else {\n        StringValue(str);\n        rb_str_resize(str, out_len);\n    }\n    if (!ossl_cipher_update_long(ctx, (unsigned char *)RSTRING_PTR(str), &out_len, in, in_len))\n\tossl_raise(eCipherError, NULL);\n    assert(out_len < RSTRING_LEN(str));\n    rb_str_set_len(str, out_len);\n    return str;\n}", "target": 0}
{"code": "static void nfs4_open_release(void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\tstruct nfs4_state *state = NULL;\n\tif (data->cancelled == 0)\n\t\tgoto out_free;\n\tif (data->rpc_status != 0 || !data->rpc_done)\n\t\tgoto out_free;\n\tif (data->o_res.rflags & NFS4_OPEN_RESULT_CONFIRM)\n\t\tgoto out_free;\n\tstate = nfs4_opendata_to_nfs4_state(data);\n\tif (!IS_ERR(state))\n\t\tnfs4_close_state(&data->path, state, data->o_arg.open_flags);\nout_free:\n\tnfs4_opendata_put(data);\n}", "target": 1}
{"code": "size_t compile_tree(struct filter_op **fop)\n{\n   int i = 1;\n   struct filter_op *array = NULL;\n   struct unfold_elm *ue;\n   BUG_IF(tree_root == NULL);\n   fprintf(stdout, \" Unfolding the meta-tree \");\n   fflush(stdout);\n   unfold_blk(&tree_root);\n   fprintf(stdout, \" done.\\n\\n\");\n   labels_to_offsets();\n   TAILQ_FOREACH(ue, &unfolded_tree, next) {\n      if (ue->label == 0) {\n         SAFE_REALLOC(array, i * sizeof(struct filter_op));\n         memcpy(&array[i - 1], &ue->fop, sizeof(struct filter_op));\n         i++;\n      }\n   }\n   SAFE_REALLOC(array, i * sizeof(struct filter_op));\n   array[i - 1].opcode = FOP_EXIT;\n   *fop = array;\n   return (i);\n}", "target": 1}
{"code": "static inline void __file_sb_list_add(struct file *file, struct super_block *sb)\n{\n\tstruct list_head *list;\n#ifdef CONFIG_SMP\n\tint cpu;\n\tcpu = smp_processor_id();\n\tfile->f_sb_list_cpu = cpu;\n\tlist = per_cpu_ptr(sb->s_files, cpu);\n#else\n\tlist = &sb->s_files;\n#endif\n\tlist_add(&file->f_u.fu_list, list);\n}", "target": 1}
{"code": "template <> HeaderMapImpl::StaticLookupTable<RequestHeaderMap>::StaticLookupTable() {\n#define REGISTER_DEFAULT_REQUEST_HEADER(name)                                                      \\\n  CustomInlineHeaderRegistry::registerInlineHeader<RequestHeaderMap::header_map_type>(             \\\n      Headers::get().name);\n  INLINE_REQ_HEADERS(REGISTER_DEFAULT_REQUEST_HEADER)\n  INLINE_REQ_RESP_HEADERS(REGISTER_DEFAULT_REQUEST_HEADER)\n  finalizeTable();\n  const auto handle =\n      CustomInlineHeaderRegistry::getInlineHeader<RequestHeaderMap::header_map_type>(\n          Headers::get().Host);\n  add(Headers::get().HostLegacy.get().c_str(), [handle](HeaderMapImpl& h) -> StaticLookupResponse {\n    return {&h.inlineHeaders()[handle.value().it_->second], &handle.value().it_->first};\n  });\n}", "target": 0}
{"code": "const char* sldns_get_errorstr_parse(int e)\n{\n\tsldns_lookup_table *lt;\n\tlt = sldns_lookup_by_id(sldns_wireparse_errors, LDNS_WIREPARSE_ERROR(e));\n\treturn lt?lt->name:\"unknown error\";\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& in0 = ctx->input(0);\n    const Tensor& in1 = ctx->input(1);\n    ValidateInputTensors(ctx, in0, in1);\n    if (!ctx->status().ok()) {\n      return;\n    }\n    MatMulBCast bcast(in0.shape().dim_sizes(), in1.shape().dim_sizes());\n    OP_REQUIRES(\n        ctx, bcast.IsValid(),\n        errors::InvalidArgument(\n            \"In[0] and In[1] must have compatible batch dimensions: \",\n            in0.shape().DebugString(), \" vs. \", in1.shape().DebugString()));\n    TensorShape out_shape = bcast.output_batch_shape();\n    auto batch_size = bcast.output_batch_size();\n    auto d0 = in0.dim_size(in0.dims() - 2);\n    auto d1 = in0.dim_size(in0.dims() - 1);\n    Tensor in0_reshaped;\n    OP_REQUIRES(\n        ctx,\n        in0_reshaped.CopyFrom(in0, TensorShape({bcast.x_batch_size(), d0, d1})),\n        errors::Internal(\"Failed to reshape In[0] from \",\n                         in0.shape().DebugString()));\n    auto d2 = in1.dim_size(in1.dims() - 2);\n    auto d3 = in1.dim_size(in1.dims() - 1);\n    Tensor in1_reshaped;\n    OP_REQUIRES(\n        ctx,\n        in1_reshaped.CopyFrom(in1, TensorShape({bcast.y_batch_size(), d2, d3})),\n        errors::Internal(\"Failed to reshape In[1] from \",\n                         in1.shape().DebugString()));\n    if (adjoint_) std::swap(d0, d1);\n    OP_REQUIRES(ctx, d1 == d2,\n                errors::InvalidArgument(\n                    \"In[0] mismatch In[1] shape: \", d1, \" vs. \", d2, \": \",\n                    in0.shape().DebugString(), \" \", in1.shape().DebugString(),\n                    \" \", lower_, \" \", adjoint_));\n    out_shape.AddDim(d0);\n    out_shape.AddDim(d3);\n    Tensor* out = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, out_shape, &out));\n    if (out->NumElements() == 0) {\n      return;\n    }\n    Tensor out_reshaped;\n    OP_REQUIRES(ctx,\n                out_reshaped.CopyFrom(*out, TensorShape({batch_size, d0, d3})),\n                errors::Internal(\"Failed to reshape output from \",\n                                 out->shape().DebugString()));\n    LaunchBatchMatrixTriangularSolve<Device, Scalar>::Launch(\n        ctx, in0_reshaped, in1_reshaped, adjoint_, lower_, bcast,\n        &out_reshaped);\n  }", "target": 0}
{"code": "bool WddxPacket::recursiveAddVar(const String& varName,\n                                 const Variant& varVariant,\n                                 bool hasVarTag) {\n  bool isArray = varVariant.isArray();\n  bool isObject = varVariant.isObject();\n  if (isArray || isObject) {\n    if (hasVarTag) {\n      m_packetString += \"<var name='\";\n      m_packetString += varName.data();\n      m_packetString += \"'>\";\n    }\n    Array varAsArray;\n    Object varAsObject = varVariant.toObject();\n    if (isArray) varAsArray = varVariant.toArray();\n    if (isObject) varAsArray = varAsObject.toArray();\n    int length = varAsArray.length();\n    if (length > 0) {\n      ArrayIter it = ArrayIter(varAsArray);\n      if (it.first().isString()) isObject = true;\n      if (isObject) {\n        m_packetString += \"<struct>\";\n        if (!isArray) {\n          m_packetString += \"<var name='php_class_name'><string>\";\n          m_packetString += varAsObject->o_getClassName().c_str();\n          m_packetString += \"</string></var>\";\n        }\n      } else {\n        m_packetString += \"<array length='\";\n        m_packetString += std::to_string(length);\n        m_packetString += \"'>\";\n      }\n      for (ArrayIter it(varAsArray); it; ++it) {\n        Variant key = it.first();\n        Variant value = it.second();\n        recursiveAddVar(key.toString(), value, isObject);\n      }\n      if (isObject) {\n        m_packetString += \"</struct>\";\n      }\n      else {\n        m_packetString += \"</array>\";\n      }\n    }\n    else {\n      if (isObject) {\n        m_packetString += \"<struct>\";\n        if (!isArray) {\n          m_packetString += \"<var name='php_class_name'><string>\";\n          m_packetString += varAsObject->o_getClassName().c_str();\n          m_packetString += \"</string></var>\";\n        }\n        m_packetString += \"</struct>\";\n      }\n    }\n    if (hasVarTag) {\n      m_packetString += \"</var>\";\n    }\n    return true;\n  }\n  std::string varType = getDataTypeString(varVariant.getType()).data();\n  if (!getWddxEncoded(varType, \"\", varName, false).empty()) {\n    std::string varValue = varVariant.toString().data();\n    if (varType.compare(\"boolean\") == 0) {\n      varValue = varVariant.toBoolean() ? \"true\" : \"false\";\n    }\n    m_packetString += getWddxEncoded(varType, varValue, varName, hasVarTag);\n    return true;\n  }\n  return false;\n}", "target": 1}
{"code": "static void svg_parse_preserveaspectratio(SVG_PreserveAspectRatio *par, char *attribute_content, GF_Err *out_e)\n{\n\tchar *content = attribute_content;\n\twhile (*content == ' ') content++;\n\tif (strstr(content, \"defer\")) {\n\t\tpar->defer = 1;\n\t\tcontent += 4;\n\t} else {\n\t\tcontent = attribute_content;\n\t}\n\twhile (*content == ' ') content++;\n\tif (strstr(content, \"none\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_NONE;\n\t\tcontent+=4;\n\t} else if (strstr(content, \"xMinYMin\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMINYMIN;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMidYMin\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMIDYMIN;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMaxYMin\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMAXYMIN;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMinYMid\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMINYMID;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMidYMid\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMIDYMID;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMaxYMid\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMAXYMID;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMinYMax\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMINYMAX;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMidYMax\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMIDYMAX;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMaxYMax\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMAXYMAX;\n\t\tcontent+=8;\n\t} else {\n\t\t*out_e = GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\twhile (*content == ' ') content++;\n\tif (*content == 0) return;\n\tif (strstr(content, \"meet\")) {\n\t\tpar->meetOrSlice = SVG_MEETORSLICE_MEET;\n\t} else if (strstr(content, \"slice\")) {\n\t\tpar->meetOrSlice = SVG_MEETORSLICE_SLICE;\n\t} else {\n\t\t*out_e = GF_NON_COMPLIANT_BITSTREAM;\n\t}\n}", "target": 1}
{"code": "void UncompressElementOp::Compute(OpKernelContext* ctx) {\n  Tensor tensor = ctx->input(0);\n  const Variant& variant = tensor.scalar<Variant>()();\n  const CompressedElement* compressed = variant.get<CompressedElement>();\n  OP_REQUIRES(\n      ctx, compressed != nullptr,\n      errors::InvalidArgument(\n          \"Input does not contain a compressed element. Instead got tensor \",\n          tensor.DebugString()));\n  std::vector<Tensor> components;\n  OP_REQUIRES_OK(ctx, UncompressElement(*compressed, &components));\n  OP_REQUIRES(ctx, components.size() == output_types_.size(),\n              errors::FailedPrecondition(\"Expected \", output_types_.size(),\n                                         \" outputs from uncompress, but got \",\n                                         components.size()));\n  for (int i = 0; i < components.size(); ++i) {\n    OP_REQUIRES(\n        ctx, components[i].dtype() == output_types_[i],\n        errors::FailedPrecondition(\"Expected a tensor of type \",\n                                   DataTypeString(output_types_[i]),\n                                   \" but got a tensor of type \",\n                                   DataTypeString(components[i].dtype())));\n    ctx->set_output(i, components[i]);\n  }\n}", "target": 0}
{"code": "header_put_le_8byte (SF_PRIVATE *psf, sf_count_t x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 8)\n\t{\tpsf->header [psf->headindex++] = x ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 24) ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\t} ;\n} ", "target": 1}
{"code": "static int get_query(struct MHD_Connection *connection, char **query, const char *separator)\n{\n\tint element_counter;\n\tchar **elements;\n\tchar *query_str;\n\tstruct collect_query collect_query;\n\tint i;\n\tint j;\n\tint length = 0;\n\tdebug(LOG_DEBUG, \" Getting query, separator is [%s].\", separator);\n\telement_counter = MHD_get_connection_values(connection, MHD_GET_ARGUMENT_KIND, counter_iterator, NULL);\n\tif (element_counter < 0) {\n\t\t*query = safe_strdup(\"\");\n\t\treturn MHD_NO;\n\t}\n\telements = calloc(element_counter, sizeof(char *));\n\tif (elements == NULL) {\n\t\treturn MHD_NO;\n\t}\n\tcollect_query.i = 0;\n\tcollect_query.elements = elements;\n\tMHD_get_connection_values(connection, MHD_GET_ARGUMENT_KIND, collect_query_string, &collect_query);\n\tfor (i = 0; i < element_counter; i++) {\n\t\tif (!elements[i])\n\t\t\tcontinue;\n\t\tlength += strlen(elements[i]);\n\t\tif (i > 0) \n\t\t\tlength++;\n\t}\n\tif (*query == NULL) {\n\t\tfor (i = 0; i < element_counter; i++) {\n\t\t\tfree(elements[i]);\n\t\t}\n\t\tfree(elements);\n\t\treturn 0;\n\t}\n\tquery_str = safe_calloc(QUERYMAXLEN);\n\tfor (i = 0, j = 0; i < element_counter; i++) {\n\t\tif (!elements[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tdebug(LOG_DEBUG, \" element [%d] is [%s]\", i, elements[i]);\n\t\tstrncpy(*query + j, elements[i], length - j);\n\t\tif (i == 0) {\n\t\t\tstrcpy(query_str, \"?\");\n\t\t} else {\n\t\t\tif (QUERYMAXLEN - strlen(query_str) > length - j + 1) {\n\t\t\t\tstrncat(query_str, separator, QUERYMAXLEN - strlen(query_str));\n\t\t\t}\n\t\t}\n\t\tif (QUERYMAXLEN - strlen(query_str) > length - j) {\n\t\t\tstrncat(query_str, *query, QUERYMAXLEN - strlen(query_str));\n\t\t} else {\n\t\t\tdebug(LOG_WARNING, \" Query string exceeds the maximum of %d bytes so has been truncated.\", QUERYMAXLEN/2);\n\t\t}\n\t\tfree(elements[i]);\n\t}\n\tdebug(LOG_DEBUG, \" query is [%s]\", query_str);\n\tstrncpy(*query, query_str, QUERYMAXLEN);\n\tfree(query_str);\n\tfree(elements);\n\treturn 0;\n}", "target": 1}
{"code": "int prepare_binprm(struct linux_binprm *bprm)\n{\n\tstruct inode *inode = file_inode(bprm->file);\n\tumode_t mode = inode->i_mode;\n\tint retval;\n\tbprm->cred->euid = current_euid();\n\tbprm->cred->egid = current_egid();\n\tif (!(bprm->file->f_path.mnt->mnt_flags & MNT_NOSUID) &&\n\t    !task_no_new_privs(current) &&\n\t    kuid_has_mapping(bprm->cred->user_ns, inode->i_uid) &&\n\t    kgid_has_mapping(bprm->cred->user_ns, inode->i_gid)) {\n\t\tif (mode & S_ISUID) {\n\t\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\t\tbprm->cred->euid = inode->i_uid;\n\t\t}\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\t\tbprm->cred->egid = inode->i_gid;\n\t\t}\n\t}\n\tretval = security_bprm_set_creds(bprm);\n\tif (retval)\n\t\treturn retval;\n\tbprm->cred_prepared = 1;\n\tmemset(bprm->buf, 0, BINPRM_BUF_SIZE);\n\treturn kernel_read(bprm->file, 0, bprm->buf, BINPRM_BUF_SIZE);\n}", "target": 1}
{"code": "static bool r_bin_mdmp_init_directory(struct r_bin_mdmp_obj *obj) {\n\tint i;\n\tut8 *directory_base;\n\tstruct minidump_directory *entry;\n\tdirectory_base = obj->b->buf + obj->hdr->stream_directory_rva;\n\tsdb_num_set (obj->kv, \"mdmp_directory.offset\",\n\t\t\tobj->hdr->stream_directory_rva, 0);\n\tsdb_set (obj->kv, \"mdmp_directory.format\", \"[4]E? \"\n\t\t\t\"(mdmp_stream_type)StreamType \"\n\t\t\t\"(mdmp_location_descriptor)Location\", 0);\n\tfor (i = 0; i < (int)obj->hdr->number_of_streams; i++) {\n\t\tentry = (struct minidump_directory *)(directory_base + (i * sizeof (struct minidump_directory)));\n\t\tr_bin_mdmp_init_directory_entry (obj, entry);\n\t}\n\treturn true;\n}", "target": 1}
{"code": "static void bnx2x_init_cyclecounter(struct bnx2x *bp)\n{\n\tmemset(&bp->cyclecounter, 0, sizeof(bp->cyclecounter));\n\tbp->cyclecounter.read = bnx2x_cyclecounter_read;\n\tbp->cyclecounter.mask = CYCLECOUNTER_MASK(64);\n\tbp->cyclecounter.shift = 0;\n\tbp->cyclecounter.mult = 1;\n}", "target": 0}
{"code": "    const std::unordered_map<std::string, std::string> &parameters()\n        const override\n    {\n        parseParametersOnce();\n        return parameters_;\n    }", "target": 1}
{"code": "koi8_u_mbc_case_fold(OnigCaseFoldType flag ARG_UNUSED,\n\t\t     const UChar** pp, const UChar* end ARG_UNUSED,\n\t\t     UChar* lower, OnigEncoding enc ARG_UNUSED)\n{\n  const UChar* p = *pp;\n  *lower = ENC_KOI8_U_TO_LOWER_CASE(*p);\n  (*pp)++;\n  return 1;\n}", "target": 0}
{"code": "void Statement::Work_AfterReset(napi_env e, napi_status status, void* data) {\n    std::unique_ptr<Baton> baton(static_cast<Baton*>(data));\n    Statement* stmt = baton->stmt;\n    Napi::Env env = stmt->Env();\n    Napi::HandleScope scope(env);\n    Napi::Function cb = baton->callback.Value();\n    if (!cb.IsUndefined() && cb.IsFunction()) {\n        Napi::Value argv[] = { env.Null() };\n        TRY_CATCH_CALL(stmt->Value(), cb, 1, argv);\n    }\n    STATEMENT_END();\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* c) override {\n    const Tensor& tag = c->input(0);\n    OP_REQUIRES(c, TensorShapeUtils::IsScalar(tag.shape()),\n                errors::InvalidArgument(\"tag must be scalar\"));\n    const Tensor& tensor = c->input(1);\n    const Tensor& serialized_summary_metadata_tensor = c->input(2);\n    OP_REQUIRES(\n        c,\n        TensorShapeUtils::IsScalar(serialized_summary_metadata_tensor.shape()),\n        errors::InvalidArgument(\"serialized_summary_metadata must be scalar\"));\n    Summary s;\n    Summary::Value* v = s.add_value();\n    v->set_tag(string(tag.scalar<tstring>()()));  \n    if (tensor.dtype() == DT_STRING) {\n      tensor.AsProtoField(v->mutable_tensor());\n    } else {\n      tensor.AsProtoTensorContent(v->mutable_tensor());\n    }\n    ParseFromTString(serialized_summary_metadata_tensor.scalar<tstring>()(),\n                     v->mutable_metadata());\n    Tensor* summary_tensor = nullptr;\n    OP_REQUIRES_OK(c, c->allocate_output(0, TensorShape({}), &summary_tensor));\n    CHECK(SerializeToTString(s, &summary_tensor->scalar<tstring>()()));\n  }", "target": 0}
{"code": "archive_read_format_cpio_read_data(struct archive_read *a,\n    const void **buff, size_t *size, int64_t *offset)\n{\n\tssize_t bytes_read;\n\tstruct cpio *cpio;\n\tcpio = (struct cpio *)(a->format->data);\n\tif (cpio->entry_bytes_unconsumed) {\n\t\t__archive_read_consume(a, cpio->entry_bytes_unconsumed);\n\t\tcpio->entry_bytes_unconsumed = 0;\n\t}\n\tif (cpio->entry_bytes_remaining > 0) {\n\t\t*buff = __archive_read_ahead(a, 1, &bytes_read);\n\t\tif (bytes_read <= 0)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tif (bytes_read > cpio->entry_bytes_remaining)\n\t\t\tbytes_read = (ssize_t)cpio->entry_bytes_remaining;\n\t\t*size = bytes_read;\n\t\tcpio->entry_bytes_unconsumed = bytes_read;\n\t\t*offset = cpio->entry_offset;\n\t\tcpio->entry_offset += bytes_read;\n\t\tcpio->entry_bytes_remaining -= bytes_read;\n\t\treturn (ARCHIVE_OK);\n\t} else {\n\t\tif (cpio->entry_padding !=\n\t\t\t__archive_read_consume(a, cpio->entry_padding)) {\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tcpio->entry_padding = 0;\n\t\t*buff = NULL;\n\t\t*size = 0;\n\t\t*offset = cpio->entry_offset;\n\t\treturn (ARCHIVE_EOF);\n\t}\n}", "target": 0}
{"code": "Jsi_Value *jsi_ValueObjKeyAssign(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *keyval, Jsi_Value *value, int flag)\n{\n    int arrayindex = -1;\n    if (keyval->vt == JSI_VT_NUMBER && Jsi_NumberIsInteger(keyval->d.num) && keyval->d.num >= 0) {\n        arrayindex = (int)keyval->d.num;\n    }\n    if (arrayindex >= 0 && arrayindex < MAX_ARRAY_LIST &&\n        target->vt == JSI_VT_OBJECT && target->d.obj->arr) {\n        return jsi_ObjArraySetDup(interp, target->d.obj, value, arrayindex);\n    }\n    const char *kstr = Jsi_ValueToString(interp, keyval, NULL);\n#if (defined(JSI_HAS___PROTO__) && JSI_HAS___PROTO__==2)\n    if (Jsi_Strcmp(kstr, \"__proto__\")==0) {\n        Jsi_Obj *obj = target->d.obj;\n        obj->__proto__ = Jsi_ValueDup(interp, value);\n        return obj->__proto__;\n    }\n#endif\n    Jsi_Value *v = Jsi_ValueNew1(interp);\n    if (value)\n        Jsi_ValueCopy(interp, v, value);\n    jsi_ValueObjSet(interp, target, kstr, v, flag, (Jsi_ValueIsStringKey(interp, keyval)? JSI_OM_ISSTRKEY:0));\n    Jsi_DecrRefCount(interp, v);\n    return v;\n}", "target": 1}
{"code": "static int open_url(AVFormatContext *s, AVIOContext **pb, const char *url,\n                    AVDictionary *opts, AVDictionary *opts2, int *is_http)\n{\n    HLSContext *c = s->priv_data;\n    AVDictionary *tmp = NULL;\n    const char *proto_name = NULL;\n    int ret;\n    av_dict_copy(&tmp, opts, 0);\n    av_dict_copy(&tmp, opts2, 0);\n    if (av_strstart(url, \"crypto\", NULL)) {\n        if (url[6] == '+' || url[6] == ':')\n            proto_name = avio_find_protocol_name(url + 7);\n    }\n    if (!proto_name)\n        proto_name = avio_find_protocol_name(url);\n    if (!proto_name)\n        return AVERROR_INVALIDDATA;\n    if (!av_strstart(proto_name, \"http\", NULL) && !av_strstart(proto_name, \"file\", NULL))\n        return AVERROR_INVALIDDATA;\n    if (!strncmp(proto_name, url, strlen(proto_name)) && url[strlen(proto_name)] == ':')\n        ;\n    else if (av_strstart(url, \"crypto\", NULL) && !strncmp(proto_name, url + 7, strlen(proto_name)) && url[7 + strlen(proto_name)] == ':')\n        ;\n    else if (strcmp(proto_name, \"file\") || !strncmp(url, \"file,\", 5))\n        return AVERROR_INVALIDDATA;\n    ret = s->io_open(s, pb, url, AVIO_FLAG_READ, &tmp);\n    if (ret >= 0) {\n        char *new_cookies = NULL;\n        if (!(s->flags & AVFMT_FLAG_CUSTOM_IO))\n            av_opt_get(*pb, \"cookies\", AV_OPT_SEARCH_CHILDREN, (uint8_t**)&new_cookies);\n        if (new_cookies) {\n            av_free(c->cookies);\n            c->cookies = new_cookies;\n        }\n        av_dict_set(&opts, \"cookies\", c->cookies, 0);\n    }\n    av_dict_free(&tmp);\n    if (is_http)\n        *is_http = av_strstart(proto_name, \"http\", NULL);\n    return ret;\n}", "target": 1}
{"code": "TEE_Result syscall_authenc_update_payload(unsigned long state,\n\t\t\tconst void *src_data, size_t src_len, void *dst_data,\n\t\t\tuint64_t *dst_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tsize_t dlen = 0;\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)\n\t\treturn TEE_ERROR_BAD_STATE;\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t) src_data, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = get_user_u64_as_size_t(&dlen, dst_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)dst_data, dlen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif (dlen < src_len) {\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\tres = crypto_authenc_update_payload(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\t    src_data, src_len, dst_data,\n\t\t\t\t\t    &dlen);\nout:\n\tif (res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) {\n\t\tTEE_Result res2 = put_user_u64(dst_len, dlen);\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\tres = res2;\n\t}\n\treturn res;\n}", "target": 0}
{"code": "bool IsRelativeSymlinkSafe(CommandData *Cmd,const wchar *SrcName,const wchar *PrepSrcName,const wchar *TargetName)\n{\n  if (IsFullRootPath(SrcName) || IsFullRootPath(TargetName))\n    return false;\n  int UpLevels=0;\n  for (int Pos=0;*TargetName!=0;Pos++)\n  {\n    bool Dot2=TargetName[0]=='.' && TargetName[1]=='.' && \n              (IsPathDiv(TargetName[2]) || TargetName[2]==0) &&\n              (Pos==0 || IsPathDiv(*(TargetName-1)));\n    if (Dot2)\n      UpLevels++;\n    TargetName++;\n  }\n  if (UpLevels>0 && LinkInPath(PrepSrcName))\n    return false;\n  int AllowedDepth=CalcAllowedDepth(SrcName); \n  size_t ExtrPathLength=wcslen(Cmd->ExtrPath);\n  if (ExtrPathLength>0 && wcsncmp(PrepSrcName,Cmd->ExtrPath,ExtrPathLength)==0)\n  {\n    PrepSrcName+=ExtrPathLength;\n    while (IsPathDiv(*PrepSrcName))\n      PrepSrcName++;\n  }\n  int PrepAllowedDepth=CalcAllowedDepth(PrepSrcName);\n  return AllowedDepth>=UpLevels && PrepAllowedDepth>=UpLevels;\n}", "target": 1}
{"code": "compat_kex_proposal(struct ssh *ssh, char *p)\n{\n\tif ((ssh->compat & (SSH_BUG_CURVE25519PAD|SSH_OLD_DHGEX)) == 0)\n\t\treturn p;\n\tdebug2_f(\"original KEX proposal: %s\", p);\n\tif ((ssh->compat & SSH_BUG_CURVE25519PAD) != 0)\n\t\tif ((p = match_filter_denylist(p,\n\t\t    \"curve25519-sha256@libssh.org\")) == NULL)\n\t\t\tfatal(\"match_filter_denylist failed\");\n\tif ((ssh->compat & SSH_OLD_DHGEX) != 0) {\n\t\tif ((p = match_filter_denylist(p,\n\t\t    \"diffie-hellman-group-exchange-sha256,\"\n\t\t    \"diffie-hellman-group-exchange-sha1\")) == NULL)\n\t\t\tfatal(\"match_filter_denylist failed\");\n\t}\n\tdebug2_f(\"compat KEX proposal: %s\", p);\n\tif (*p == '\\0')\n\t\tfatal(\"No supported key exchange algorithms found\");\n\treturn p;\n}", "target": 1}
{"code": "int mesg_make_query (u_char *qname, uint16_t qtype, uint16_t qclass,\n\t\t     uint32_t id, int rd, u_char *buf, int buflen) {\n\tchar *fn = \"mesg_make_query()\";\n\tu_char *ucp;\n\tint i, written_len;\n\tMesg_Hdr *hdr;\n\tif (T.debug > 4)\n\t\tsyslog (LOG_DEBUG, \"%s: (qtype: %s, id: %d): start\", fn,\n\t\t\tstring_rtype (qtype), id);\n\thdr = (Mesg_Hdr *) buf;\n\thdr->id = id;\n\thdr->opcode = OP_QUERY;\n\thdr->rcode = RC_OK;\n\thdr->rd = rd;\n\thdr->qr = hdr->aa = hdr->tc = hdr->ra = hdr->zero = 0;\n\thdr->qdcnt = ntohs (1);\n\thdr->ancnt = hdr->nscnt = hdr->arcnt = ntohs (0);\n\twritten_len = sizeof (Mesg_Hdr);\n\tucp = (u_char *) (hdr + 1);\n\tif (T.debug > 4)\n\t\tsyslog (LOG_DEBUG, \"%s: qname offset = %zd\", fn, ucp - buf);\n\ti = dname_copy (qname, ucp, buflen - written_len);\n\tif (i < 0)\n\t\treturn -1;\n\twritten_len += i;\n\tucp += i;\n\tif (T.debug > 4)\n\t\tsyslog (LOG_DEBUG, \"%s: qtype/qclass offset = %zd\",\n\t\t\tfn, ucp - buf);\n\twritten_len += sizeof (uint16_t) * 2;\n\tif (written_len > buflen)\n\t\treturn -1;\n\tPUTSHORT (qtype, ucp);\n\tPUTSHORT (qclass, ucp);\n\treturn written_len;\n}", "target": 1}
{"code": "DECLAREcpFunc(cpDecodedStrips)\n{\n\ttsize_t stripsize  = TIFFStripSize(in);\n\ttdata_t buf = _TIFFmalloc(stripsize);\n\t(void) imagewidth; (void) spp;\n\tif (buf) {\n\t\ttstrip_t s, ns = TIFFNumberOfStrips(in);\n\t\tuint32 row = 0;\n\t\t_TIFFmemset(buf, 0, stripsize);\n\t\tfor (s = 0; s < ns; s++) {\n\t\t\ttsize_t cc = (row + rowsperstrip > imagelength) ?\n\t\t\t    TIFFVStripSize(in, imagelength - row) : stripsize;\n\t\t\tif (TIFFReadEncodedStrip(in, s, buf, cc) < 0\n\t\t\t    && !ignore) {\n\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t    \"Error, can't read strip %lu\",\n\t\t\t\t    (unsigned long) s);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFWriteEncodedStrip(out, s, buf, cc) < 0) {\n\t\t\t\tTIFFError(TIFFFileName(out),\n\t\t\t\t    \"Error, can't write strip %lu\",\n\t\t\t\t    (unsigned long) s);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\trow += rowsperstrip;\n\t\t}\n\t\t_TIFFfree(buf);\n\t\treturn 1;\n\t} else {\n\t\tTIFFError(TIFFFileName(in),\n\t\t    \"Error, can't allocate memory buffer of size %lu \"\n\t\t    \"to read strips\", (unsigned long) stripsize);\n\t\treturn 0;\n\t}\nbad:\n\t_TIFFfree(buf);\n\treturn 0;\n}", "target": 1}
{"code": "GF_Err infe_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tchar *buf;\n\tu32 buf_len, i, string_len, string_start;\n\tGF_ItemInfoEntryBox *ptr = (GF_ItemInfoEntryBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->item_ID = gf_bs_read_u16(bs);\n\tptr->item_protection_index = gf_bs_read_u16(bs);\n\tif (ptr->version == 2) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->item_type = gf_bs_read_u32(bs);\n\t}\n\tbuf_len = (u32) (ptr->size);\n\tbuf = (char*)gf_malloc(buf_len);\n\tif (!buf) return GF_OUT_OF_MEM;\n\tif (buf_len != gf_bs_read_data(bs, buf, buf_len)) {\n\t\tgf_free(buf);\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tstring_len = 1;\n\tstring_start = 0;\n\tfor (i = 0; i < buf_len; i++) {\n\t\tif (buf[i] == 0) {\n\t\t\tif (!ptr->item_name) {\n\t\t\t\tptr->item_name = (char*)gf_malloc(sizeof(char)*string_len);\n\t\t\t\tif (!ptr->item_name) return GF_OUT_OF_MEM;\n\t\t\t\tmemcpy(ptr->item_name, buf+string_start, string_len);\n\t\t\t} else if (!ptr->content_type) {\n\t\t\t\tptr->content_type = (char*)gf_malloc(sizeof(char)*string_len);\n\t\t\t\tif (!ptr->content_type) return GF_OUT_OF_MEM;\n\t\t\t\tmemcpy(ptr->content_type, buf+string_start, string_len);\n\t\t\t} else {\n\t\t\t\tptr->content_encoding = (char*)gf_malloc(sizeof(char)*string_len);\n\t\t\t\tif (!ptr->content_encoding) return GF_OUT_OF_MEM;\n\t\t\t\tmemcpy(ptr->content_encoding, buf+string_start, string_len);\n\t\t\t}\n\t\t\tstring_start += string_len;\n\t\t\tstring_len = 0;\n\t\t\tif (ptr->content_encoding && ptr->version == 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tstring_len++;\n\t}\n\tgf_free(buf);\n\tif (!ptr->item_name || (!ptr->content_type && ptr->version < 2)) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isoff] Infe without name or content type !\\n\"));\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "static int fsmMkfile(rpmfi fi, const char *dest, rpmfiles files,\n\t\t     rpmpsm psm, int nodigest, int *setmeta,\n\t\t     int * firsthardlink)\n{\n    int rc = 0;\n    int numHardlinks = rpmfiFNlink(fi);\n    if (numHardlinks > 1) {\n\tif (*firsthardlink < 0) {\n\t    *firsthardlink = rpmfiFX(fi);\n\t    rc = expandRegular(fi, dest, psm, nodigest, 1);\n\t} else {\n\t    char *fn = rpmfilesFN(files, *firsthardlink);\n\t    rc = link(fn, dest);\n\t    if (rc < 0) {\n\t\trc = RPMERR_LINK_FAILED;\n\t    }\n\t    free(fn);\n\t}\n    }\n    if (numHardlinks<=1) {\n\tif (!rc)\n\t    rc = expandRegular(fi, dest, psm, nodigest, 0);\n    } else if (rpmfiArchiveHasContent(fi)) {\n\tif (!rc)\n\t    rc = expandRegular(fi, dest, psm, nodigest, 0);\n\t*firsthardlink = -1;\n    } else {\n\t*setmeta = 0;\n    }\n    return rc;\n}", "target": 1}
{"code": "l2tp_ppp_discon_cc_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\tND_PRINT((ndo, \"%04x, \", EXTRACT_16BITS(ptr))); ptr++;\t\n\tND_PRINT((ndo, \"%04x \",  EXTRACT_16BITS(ptr))); ptr++;\t\n\tND_PRINT((ndo, \"%s\", tok2str(l2tp_cc_direction2str,\n\t\t\t     \"Direction-#%u\", *((const u_char *)ptr++))));\n\tif (length > 5) {\n\t\tND_PRINT((ndo, \" \"));\n\t\tprint_string(ndo, (const u_char *)ptr, length-5);\n\t}\n}", "target": 1}
{"code": "free_link_refs(struct link_ref **references)\n{\n\tsize_t i;\n\tfor (i = 0; i < REF_TABLE_SIZE; ++i) {\n\t\tstruct link_ref *r = references[i];\n\t\tstruct link_ref *next;\n\t\twhile (r) {\n\t\t\tnext = r->next;\n\t\t\tbufrelease(r->label);\n\t\t\tbufrelease(r->link);\n\t\t\tbufrelease(r->title);\n\t\t\tfree(r);\n\t\t\tr = next;\n\t\t}\n\t}\n}", "target": 0}
{"code": "is_code_ctype(OnigCodePoint code, unsigned int ctype, OnigEncoding enc ARG_UNUSED)\n{\n  if (code < 256)\n    return ENC_IS_ISO_8859_6_CTYPE(code, ctype);\n  else\n    return FALSE;\n}", "target": 0}
{"code": "void btrfs_assign_next_active_device(struct btrfs_device *device,\n\t\t\t\t     struct btrfs_device *this_dev)\n{\n\tstruct btrfs_fs_info *fs_info = device->fs_info;\n\tstruct btrfs_device *next_device;\n\tif (this_dev)\n\t\tnext_device = this_dev;\n\telse\n\t\tnext_device = btrfs_find_next_active_device(fs_info->fs_devices,\n\t\t\t\t\t\t\t\tdevice);\n\tASSERT(next_device);\n\tif (fs_info->sb->s_bdev &&\n\t\t\t(fs_info->sb->s_bdev == device->bdev))\n\t\tfs_info->sb->s_bdev = next_device->bdev;\n\tif (fs_info->fs_devices->latest_bdev == device->bdev)\n\t\tfs_info->fs_devices->latest_bdev = next_device->bdev;\n}", "target": 0}
{"code": "static int mpeg4video_probe(AVProbeData *probe_packet)\n{\n    uint32_t temp_buffer = -1;\n    int VO = 0, VOL = 0, VOP = 0, VISO = 0, res = 0;\n    int i;\n    for (i = 0; i < probe_packet->buf_size; i++) {\n        temp_buffer = (temp_buffer << 8) + probe_packet->buf[i];\n        if ((temp_buffer & 0xffffff00) != 0x100)\n            continue;\n        if (temp_buffer == VOP_START_CODE)\n            VOP++;\n        else if (temp_buffer == VISUAL_OBJECT_START_CODE)\n            VISO++;\n        else if (temp_buffer < 0x120)\n            VO++;\n        else if (temp_buffer < 0x130)\n            VOL++;\n        else if (!(0x1AF < temp_buffer && temp_buffer < 0x1B7) &&\n                 !(0x1B9 < temp_buffer && temp_buffer < 0x1C4))\n            res++;\n    }\n    if (VOP >= VISO && VOP >= VOL && VO >= VOL && VOL > 0 && res == 0)\n        return AVPROBE_SCORE_EXTENSION;\n    return 0;\n}", "target": 1}
{"code": "static bool add_free_nid(struct f2fs_sb_info *sbi, nid_t nid, bool build)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\tstruct nat_entry *ne;\n\tint err;\n\tif (unlikely(nid == 0))\n\t\treturn false;\n\tif (build) {\n\t\tne = __lookup_nat_cache(nm_i, nid);\n\t\tif (ne && (!get_nat_flag(ne, IS_CHECKPOINTED) ||\n\t\t\t\tnat_get_blkaddr(ne) != NULL_ADDR))\n\t\t\treturn false;\n\t}\n\ti = f2fs_kmem_cache_alloc(free_nid_slab, GFP_NOFS);\n\ti->nid = nid;\n\ti->state = NID_NEW;\n\tif (radix_tree_preload(GFP_NOFS)) {\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn true;\n\t}\n\tspin_lock(&nm_i->nid_list_lock);\n\terr = __insert_nid_to_list(sbi, i, FREE_NID_LIST, true);\n\tspin_unlock(&nm_i->nid_list_lock);\n\tradix_tree_preload_end();\n\tif (err) {\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn true;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "EXPORTED const char *dlist_reserve_path(const char *part, int isarchive,\n                                        const struct message_guid *guid)\n{\n    static char buf[MAX_MAILBOX_PATH];\n    const char *base;\n    if (strchr(part, '/')) {\n        base = part;\n    }\n    else {\n        base = isarchive ? config_archivepartitiondir(part)\n                         : config_partitiondir(part);\n    }\n    assert(base != NULL);\n    snprintf(buf, MAX_MAILBOX_PATH, \"%s/sync./%lu/%s\",\n                  base, (unsigned long)getpid(),\n                  message_guid_encode(guid));\n    if (cyrus_mkdir(buf, 0755)) {\n        syslog(LOG_ERR, \"IOERROR: failed to create %s/sync./%lu/ for reserve: %m\",\n                        base, (unsigned long)getpid());\n    }\n    return buf;\n}", "target": 1}
{"code": "TfLiteStatus PrepareHashtableSize(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input_resource_id_tensor =\n      GetInput(context, node, kInputResourceIdTensor);\n  TF_LITE_ENSURE_EQ(context, input_resource_id_tensor->type, kTfLiteInt32);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input_resource_id_tensor), 1);\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(input_resource_id_tensor, 0), 1);\n  TfLiteTensor* output_tensor = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output_tensor != nullptr);\n  TF_LITE_ENSURE_EQ(context, output_tensor->type, kTfLiteInt64);\n  TfLiteIntArray* outputSize = TfLiteIntArrayCreate(1);\n  outputSize->data[0] = 1;\n  return context->ResizeTensor(context, output_tensor, outputSize);\n}", "target": 1}
{"code": "void processInputBuffer(client *c) {\n    server.current_client = c;\n    while(sdslen(c->querybuf)) {\n        if (!(c->flags & CLIENT_SLAVE) && clientsArePaused()) break;\n        if (c->flags & CLIENT_BLOCKED) break;\n        if (c->flags & CLIENT_CLOSE_AFTER_REPLY) break;\n        if (!c->reqtype) {\n            if (c->querybuf[0] == '*') {\n                c->reqtype = PROTO_REQ_MULTIBULK;\n            } else {\n                c->reqtype = PROTO_REQ_INLINE;\n            }\n        }\n        if (c->reqtype == PROTO_REQ_INLINE) {\n            if (processInlineBuffer(c) != C_OK) break;\n        } else if (c->reqtype == PROTO_REQ_MULTIBULK) {\n            if (processMultibulkBuffer(c) != C_OK) break;\n        } else {\n            serverPanic(\"Unknown request type\");\n        }\n        if (c->argc == 0) {\n            resetClient(c);\n        } else {\n            if (processCommand(c) == C_OK)\n                resetClient(c);\n            if (server.current_client == NULL) break;\n        }\n    }\n    server.current_client = NULL;\n}", "target": 1}
{"code": "static struct nfs4_state *nfs4_opendata_to_nfs4_state(struct nfs4_opendata *data)\n{\n\tstruct inode *inode;\n\tstruct nfs4_state *state = NULL;\n\tstruct nfs_delegation *delegation;\n\tint ret;\n\tif (!data->rpc_done) {\n\t\tstate = nfs4_try_open_cached(data);\n\t\tgoto out;\n\t}\n\tret = -EAGAIN;\n\tif (!(data->f_attr.valid & NFS_ATTR_FATTR))\n\t\tgoto err;\n\tinode = nfs_fhget(data->dir->d_sb, &data->o_res.fh, &data->f_attr);\n\tret = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto err;\n\tret = -ENOMEM;\n\tstate = nfs4_get_open_state(inode, data->owner);\n\tif (state == NULL)\n\t\tgoto err_put_inode;\n\tif (data->o_res.delegation_type != 0) {\n\t\tint delegation_flags = 0;\n\t\trcu_read_lock();\n\t\tdelegation = rcu_dereference(NFS_I(inode)->delegation);\n\t\tif (delegation)\n\t\t\tdelegation_flags = delegation->flags;\n\t\trcu_read_unlock();\n\t\tif ((delegation_flags & 1UL<<NFS_DELEGATION_NEED_RECLAIM) == 0)\n\t\t\tnfs_inode_set_delegation(state->inode,\n\t\t\t\t\tdata->owner->so_cred,\n\t\t\t\t\t&data->o_res);\n\t\telse\n\t\t\tnfs_inode_reclaim_delegation(state->inode,\n\t\t\t\t\tdata->owner->so_cred,\n\t\t\t\t\t&data->o_res);\n\t}\n\tupdate_open_stateid(state, &data->o_res.stateid, NULL,\n\t\t\tdata->o_arg.open_flags);\n\tiput(inode);\nout:\n\treturn state;\nerr_put_inode:\n\tiput(inode);\nerr:\n\treturn ERR_PTR(ret);\n}", "target": 1}
{"code": "\tvirtual ~CxFile() { };", "target": 1}
{"code": "ext2_xattr_cache_insert(struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(HDR(bh)->h_hash);\n\tstruct mb_cache_entry *ce;\n\tint error;\n\tce = mb_cache_entry_alloc(ext2_xattr_cache, GFP_NOFS);\n\tif (!ce)\n\t\treturn -ENOMEM;\n\terror = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);\n\tif (error) {\n\t\tmb_cache_entry_free(ce);\n\t\tif (error == -EBUSY) {\n\t\t\tea_bdebug(bh, \"already in cache (%d cache entries)\",\n\t\t\t\tatomic_read(&ext2_xattr_cache->c_entry_count));\n\t\t\terror = 0;\n\t\t}\n\t} else {\n\t\tea_bdebug(bh, \"inserting [%x] (%d cache entries)\", (int)hash,\n\t\t\t  atomic_read(&ext2_xattr_cache->c_entry_count));\n\t\tmb_cache_entry_release(ce);\n\t}\n\treturn error;\n}", "target": 1}
{"code": "static inline struct futex_hash_bucket *queue_lock(struct futex_q *q)\n{\n\tstruct futex_hash_bucket *hb;\n\tget_futex_key_refs(&q->key);\n\thb = hash_futex(&q->key);\n\tq->lock_ptr = &hb->lock;\n\tspin_lock(&hb->lock);\n\treturn hb;\n}", "target": 1}
{"code": "get_next_file(FILE *VFile, char *ptr)\n{\n\tchar *ret;\n\tret = fgets(ptr, PATH_MAX, VFile);\n\tif (!ret)\n\t\treturn NULL;\n\tif (ptr[strlen(ptr) - 1] == '\\n')\n\t\tptr[strlen(ptr) - 1] = '\\0';\n\treturn ret;\n}", "target": 1}
{"code": "static void dhcps_initialize_message(struct dhcp_msg *dhcp_message_repository)\n{\n        dhcp_message_repository->op = DHCP_MESSAGE_OP_REPLY;\n        dhcp_message_repository->htype = DHCP_MESSAGE_HTYPE;\n        dhcp_message_repository->hlen = DHCP_MESSAGE_HLEN; \n        dhcp_message_repository->hops = 0;\t\t\n        memcpy((char *)dhcp_recorded_xid, (char *) dhcp_message_repository->xid,\n\t\t\t\t\tsizeof(dhcp_message_repository->xid));\n        dhcp_message_repository->secs = 0;\n        dhcp_message_repository->flags = htons(BOOTP_BROADCAST);         \n\tmemcpy((char *)dhcp_message_repository->yiaddr,\n\t\t\t(char *)&dhcps_allocated_client_address,\n\t\t\t\tsizeof(dhcp_message_repository->yiaddr));\n\tmemset((char *)dhcp_message_repository->ciaddr, 0,\n\t\t\t\t\tsizeof(dhcp_message_repository->ciaddr));\n        memset((char *)dhcp_message_repository->siaddr, 0,\n\t\t\t\t\tsizeof(dhcp_message_repository->siaddr));\n        memset((char *)dhcp_message_repository->giaddr, 0,\n\t\t\t\t\tsizeof(dhcp_message_repository->giaddr));\n        memset((char *)dhcp_message_repository->sname,  0,\n\t\t\t\t\tsizeof(dhcp_message_repository->sname));\n        memset((char *)dhcp_message_repository->file,   0,\n\t\t\t\t\tsizeof(dhcp_message_repository->file));\n        memset((char *)dhcp_message_repository->options, 0,\n\t\t\t\t\tdhcp_message_total_options_lenth);\n        memcpy((char *)dhcp_message_repository->options, (char *)dhcp_magic_cookie,\n\t\t\t\t\tsizeof(dhcp_magic_cookie));\n}", "target": 1}
{"code": "static inline bool cpu_has_vmx_ept_mt_wb(void)\n{\n\treturn vmx_capability.ept & VMX_EPTP_WB_BIT;\n}", "target": 0}
{"code": "  virtual void AddCellularDataPlanObserver(CellularDataPlanObserver* observer) {\n    if (!data_plan_observers_.HasObserver(observer))\n      data_plan_observers_.AddObserver(observer);\n  }", "target": 0}
{"code": "directory_fetches_dir_info_later(const or_options_t *options)\n{\n  return options->UseBridges != 0;\n}", "target": 0}
{"code": "extract_one_file(EpubDocument* epub_document,GError ** error)\n{\n    GFile * outfile ;\n    gsize writesize = 0;\n    GString * gfilepath ;\n    unz_file_info64 info ;\n    gchar* directory;\n    GString* dir_create;\n    GFileOutputStream * outstream ;\n    if ( unzOpenCurrentFile(epub_document->epubDocument) != UNZ_OK )\n    {\n            return FALSE ;\n    }\n    gboolean result = TRUE;\n    gpointer currentfilename = g_malloc0(512);\n    unzGetCurrentFileInfo64(epub_document->epubDocument,&info,currentfilename,512,NULL,0,NULL,0) ;\n    directory = g_strrstr(currentfilename,\"/\") ;\n    if ( directory != NULL )\n        directory++;\n    gfilepath = g_string_new(epub_document->tmp_archive_dir) ;\n    g_string_append_printf(gfilepath,\"/%s\",(gchar*)currentfilename);\n    if (directory != NULL && *directory == '\\0')\n    {\n        g_mkdir(gfilepath->str,0777);\n        goto out;\n    }\n    else if (directory != NULL && *directory != '\\0' ) {\n        gchar* createdir = currentfilename;\n        gchar *createdirname = g_malloc0(strlen(currentfilename));\n        gchar *createdirnametemp = createdirname;\n        while ( createdir != directory ) {\n            (*createdirnametemp) = (*createdir);\n            createdirnametemp++;\n            createdir++;\n        }\n        (*createdirnametemp) = '\\0';\n        dir_create = g_string_new(epub_document->tmp_archive_dir);\n        g_string_append_printf(dir_create,\"/%s\",createdirname);\n        g_free(createdirname);\n        g_mkdir_with_parents(dir_create->str,0777);\n        g_string_free(dir_create,TRUE);\n    }\n    outfile = g_file_new_for_path(gfilepath->str);\n    outstream = g_file_create(outfile,G_FILE_CREATE_PRIVATE,NULL,error);\n    gpointer buffer = g_malloc0(512);\n    while ( (writesize = unzReadCurrentFile(epub_document->epubDocument,buffer,512) ) != 0 )\n    {\n        if ( g_output_stream_write((GOutputStream*)outstream,buffer,writesize,NULL,error) == -1 )\n        {\n            result = FALSE;\n            break;\n        }\n    }\n    g_free(buffer);\n    g_output_stream_close((GOutputStream*)outstream,NULL,error);\n    g_object_unref(outfile) ;\n    g_object_unref(outstream) ;\nout:\n    unzCloseCurrentFile (epub_document->epubDocument) ;\n    g_string_free(gfilepath,TRUE);\n    g_free(currentfilename);\n    return result;\n}", "target": 1}
{"code": "int main()\n{\n    check_file(\"heap_overflow_1.tga\");\n    check_file(\"heap_overflow_2.tga\");\n    return gdNumFailures();\n}", "target": 0}
{"code": "char *QuotedString::extractFrom(char *input, char **endPtr) {\n  char firstChar = *input;\n  if (!isQuote(firstChar)) {\n    return NULL;\n  }\n  char stopChar = firstChar;  \n  char *startPtr = input + 1;  \n  char *readPtr = startPtr;\n  char *writePtr = startPtr;\n  char c;\n  for (;;) {\n    c = *readPtr++;\n    if (c == '\\0') {\n      return NULL;\n    }\n    if (c == stopChar) {\n      break;\n    }\n    if (c == '\\\\') {\n      c = unescapeChar(*readPtr++);\n    }\n    *writePtr++ = c;\n  }\n  *writePtr = '\\0';\n  *endPtr = readPtr;\n  return startPtr;\n}", "target": 1}
{"code": "static int CFScanDump_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n    RedisModule_AutoMemory(ctx);\n    if (argc != 3) {\n        return RedisModule_WrongArity(ctx);\n    }\n    long long pos;\n    if (RedisModule_StringToLongLong(argv[2], &pos) != REDISMODULE_OK) {\n        return RedisModule_ReplyWithError(ctx, \"Invalid position\");\n    }\n    RedisModuleKey *key = RedisModule_OpenKey(ctx, argv[1], REDISMODULE_READ);\n    CuckooFilter *cf;\n    int status = cfGetFilter(key, &cf);\n    if (status != SB_OK) {\n        return RedisModule_ReplyWithError(ctx, statusStrerror(status));\n    }\n    RedisModule_ReplyWithArray(ctx, 2);\n    if (!cf->numItems) {\n        RedisModule_ReplyWithLongLong(ctx, 0);\n        RedisModule_ReplyWithNull(ctx);\n        return REDISMODULE_OK;\n    }\n    if (pos == 0) {\n        CFHeader header;\n        fillCFHeader(&header, cf);\n        RedisModule_ReplyWithLongLong(ctx, 1);\n        RedisModule_ReplyWithStringBuffer(ctx, (const char *)&header, sizeof header);\n        return REDISMODULE_OK;\n    }\n    size_t chunkLen = 0;\n    const char *chunk = CF_GetEncodedChunk(cf, &pos, &chunkLen, MAX_SCANDUMP_SIZE);\n    if (chunk == NULL) {\n        RedisModule_ReplyWithLongLong(ctx, 0);\n        RedisModule_ReplyWithNull(ctx);\n    } else {\n        RedisModule_ReplyWithLongLong(ctx, pos);\n        RedisModule_ReplyWithStringBuffer(ctx, chunk, chunkLen);\n    }\n    return REDISMODULE_OK;\n}", "target": 1}
{"code": "static int crypto_ahash_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_hash rhash;\n\tsnprintf(rhash.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"ahash\");\n\trhash.blocksize = alg->cra_blocksize;\n\trhash.digestsize = __crypto_hash_alg_common(alg)->digestsize;\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_HASH,\n\t\t    sizeof(struct crypto_report_hash), &rhash))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "static lbool must_quote(char c)\n{\n\treturn (c == '\\n'); \n}", "target": 0}
{"code": "static __be32 nfsd4_open_omfg(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate, struct nfsd4_op *op)\n{\n\tstruct nfsd4_open *open = &op->u.open;\n\tif (!seqid_mutating_err(ntohl(op->status)))\n\t\treturn op->status;\n\tif (nfsd4_has_session(cstate))\n\t\treturn op->status;\n\topen->op_xdr_error = op->status;\n\treturn nfsd4_open(rqstp, cstate, &op->u);\n}", "target": 0}
{"code": "static void ext2_put_super (struct super_block * sb)\n{\n\tint db_count;\n\tint i;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tdquot_disable(sb, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n\text2_xattr_put_super(sb);\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tstruct ext2_super_block *es = sbi->s_es;\n\t\tspin_lock(&sbi->s_lock);\n\t\tes->s_state = cpu_to_le16(sbi->s_mount_state);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\tdb_count = sbi->s_gdb_count;\n\tfor (i = 0; i < db_count; i++)\n\t\tif (sbi->s_group_desc[i])\n\t\t\tbrelse (sbi->s_group_desc[i]);\n\tkfree(sbi->s_group_desc);\n\tkfree(sbi->s_debts);\n\tpercpu_counter_destroy(&sbi->s_freeblocks_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tbrelse (sbi->s_sbh);\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\n\tkfree(sbi);\n}", "target": 1}
{"code": "static INLINE BOOL update_write_brush(wStream* s, rdpBrush* brush, BYTE fieldFlags)\n{\n\tif (fieldFlags & ORDER_FIELD_01)\n\t{\n\t\tStream_Write_UINT8(s, brush->x);\n\t}\n\tif (fieldFlags & ORDER_FIELD_02)\n\t{\n\t\tStream_Write_UINT8(s, brush->y);\n\t}\n\tif (fieldFlags & ORDER_FIELD_03)\n\t{\n\t\tStream_Write_UINT8(s, brush->style);\n\t}\n\tif (brush->style & CACHED_BRUSH)\n\t{\n\t\tbrush->hatch = brush->index;\n\t\tbrush->bpp = BMF_BPP[brush->style & 0x07];\n\t\tif (brush->bpp == 0)\n\t\t\tbrush->bpp = 1;\n\t}\n\tif (fieldFlags & ORDER_FIELD_04)\n\t{\n\t\tStream_Write_UINT8(s, brush->hatch);\n\t}\n\tif (fieldFlags & ORDER_FIELD_05)\n\t{\n\t\tbrush->data = (BYTE*)brush->p8x8;\n\t\tStream_Write_UINT8(s, brush->data[7]);\n\t\tStream_Write_UINT8(s, brush->data[6]);\n\t\tStream_Write_UINT8(s, brush->data[5]);\n\t\tStream_Write_UINT8(s, brush->data[4]);\n\t\tStream_Write_UINT8(s, brush->data[3]);\n\t\tStream_Write_UINT8(s, brush->data[2]);\n\t\tStream_Write_UINT8(s, brush->data[1]);\n\t\tbrush->data[0] = brush->hatch;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "ssh_packet_get_compress_state(struct sshbuf *m, struct ssh *ssh)\n{\n\tstruct session_state *state = ssh->state;\n\tstruct sshbuf *b;\n\tint r;\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (state->compression_in_started) {\n\t\tif ((r = sshbuf_put_string(b, &state->compression_in_stream,\n\t\t    sizeof(state->compression_in_stream))) != 0)\n\t\t\tgoto out;\n\t} else if ((r = sshbuf_put_string(b, NULL, 0)) != 0)\n\t\tgoto out;\n\tif (state->compression_out_started) {\n\t\tif ((r = sshbuf_put_string(b, &state->compression_out_stream,\n\t\t    sizeof(state->compression_out_stream))) != 0)\n\t\t\tgoto out;\n\t} else if ((r = sshbuf_put_string(b, NULL, 0)) != 0)\n\t\tgoto out;\n\tr = sshbuf_put_stringb(m, b);\n out:\n\tsshbuf_free(b);\n\treturn r;\n}", "target": 1}
{"code": "onigenc_always_false_is_allowed_reverse_match(const UChar* s   ARG_UNUSED,\n\t\t\t\t\t      const UChar* end ARG_UNUSED,\n\t\t\t\t\t      OnigEncoding enc ARG_UNUSED)\n{\n  return FALSE;\n}", "target": 0}
{"code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  OpContext op_context(context, node);\n    switch (op_context.output->type) {\n      case kTfLiteFloat32:\n        TFLiteOperation<kernel_type, float, OpType>(context, node, op_context);\n        break;\n      case kTfLiteUInt8:\n        TFLiteOperation<kernel_type, uint8_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      case kTfLiteInt8:\n        TFLiteOperation<kernel_type, int8_t, OpType>(context, node, op_context);\n        break;\n      case kTfLiteInt32:\n        TFLiteOperation<kernel_type, int32_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      case kTfLiteInt64:\n        TFLiteOperation<kernel_type, int64_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      case kTfLiteInt16:\n        TFLiteOperation<kernel_type, int16_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      default:\n        context->ReportError(context,\n                             \"Type %d is currently not supported by Maximum.\",\n                             op_context.output->type);\n        return kTfLiteError;\n    }\n  return kTfLiteOk;\n}", "target": 1}
{"code": "static void xen_cpu_init_eoi(unsigned int cpu)\n{\n\tstruct lateeoi_work *eoi = &per_cpu(lateeoi, cpu);\n\tINIT_DELAYED_WORK(&eoi->delayed, xen_irq_lateeoi_worker);\n\tspin_lock_init(&eoi->eoi_list_lock);\n\tINIT_LIST_HEAD(&eoi->eoi_list);\n}", "target": 0}
{"code": "TEST(format_timespan) {\n        test_format_timespan_accuracy(1);\n        test_format_timespan_accuracy(USEC_PER_MSEC);\n        test_format_timespan_accuracy(USEC_PER_SEC);\n        _cleanup_free_ char *buf;\n        assert_se(buf = new(char, 5));\n        assert_se(buf == format_timespan(buf, 5, 100005, 1000));\n}", "target": 0}
{"code": "id3_skip (SF_PRIVATE * psf)\n{\tunsigned char\tbuf [10] ;\n\tmemset (buf, 0, sizeof (buf)) ;\n\tpsf_binheader_readf (psf, \"pb\", 0, buf, 10) ;\n\tif (buf [0] == 'I' && buf [1] == 'D' && buf [2] == '3')\n\t{\tint\toffset = buf [6] & 0x7f ;\n\t\toffset = (offset << 7) | (buf [7] & 0x7f) ;\n\t\toffset = (offset << 7) | (buf [8] & 0x7f) ;\n\t\toffset = (offset << 7) | (buf [9] & 0x7f) ;\n\t\tpsf_log_printf (psf, \"ID3 length : %d\\n--------------------\\n\", offset) ;\n\t\tif (offset < 0)\n\t\t\treturn 0 ;\n\t\tpsf->fileoffset += offset + 10 ;\n\t\tpsf_binheader_readf (psf, \"p\", psf->fileoffset) ;\n\t\treturn 1 ;\n\t\t} ;\n\treturn 0 ;\n} ", "target": 1}
{"code": "qedi_dbg_warn(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t      const char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\tchar nfunc[32];\n\tmemset(nfunc, 0, sizeof(nfunc));\n\tmemcpy(nfunc, func, sizeof(nfunc) - 1);\n\tva_start(va, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\tif (!(qedi_dbg_log & QEDI_LOG_WARN))\n\t\tgoto ret;\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_warn(\"[%s]:[%s:%d]:%d: %pV\", dev_name(&qedi->pdev->dev),\n\t\t\tnfunc, line, qedi->host_no, &vaf);\n\telse\n\t\tpr_warn(\"[0000:00:00.0]:[%s:%d]: %pV\", nfunc, line, &vaf);\nret:\n\tva_end(va);\n}", "target": 1}
{"code": "mp_join_print(netdissect_options *ndo,\n              const u_char *opt, u_int opt_len, u_char flags)\n{\n        const struct mp_join *mpj = (const struct mp_join *) opt;\n        if (!(opt_len == 12 && flags & TH_SYN) &&\n            !(opt_len == 16 && (flags & (TH_SYN | TH_ACK)) == (TH_SYN | TH_ACK)) &&\n            !(opt_len == 24 && flags & TH_ACK))\n                return 0;\n        if (opt_len != 24) {\n                if (mpj->sub_b & MP_JOIN_B)\n                        ND_PRINT((ndo, \" backup\"));\n                ND_PRINT((ndo, \" id %u\", mpj->addr_id));\n        }\n        switch (opt_len) {\n        case 12: \n                ND_PRINT((ndo, \" token 0x%x\" \" nonce 0x%x\",\n                        EXTRACT_32BITS(mpj->u.syn.token),\n                        EXTRACT_32BITS(mpj->u.syn.nonce)));\n                break;\n        case 16: \n                ND_PRINT((ndo, \" hmac 0x%\" PRIx64 \" nonce 0x%x\",\n                        EXTRACT_64BITS(mpj->u.synack.mac),\n                        EXTRACT_32BITS(mpj->u.synack.nonce)));\n                break;\n        case 24: {\n                size_t i;\n                ND_PRINT((ndo, \" hmac 0x\"));\n                for (i = 0; i < sizeof(mpj->u.ack.mac); ++i)\n                        ND_PRINT((ndo, \"%02x\", mpj->u.ack.mac[i]));\n        }\n        default:\n                break;\n        }\n        return 1;\n}", "target": 1}
{"code": "static PixelChannels **AcquirePixelThreadSet(const Image *images)\n{\n  const Image\n    *next;\n  PixelChannels\n    **pixels;\n  register ssize_t\n    i;\n  size_t\n    columns,\n    rows;\n  rows=MagickMax(GetImageListLength(images),\n    (size_t) GetMagickResourceLimit(ThreadResource));\n  pixels=(PixelChannels **) AcquireQuantumMemory(rows,sizeof(*pixels));\n  if (pixels == (PixelChannels **) NULL)\n    return((PixelChannels **) NULL);\n  columns=MaxPixelChannels;\n  for (next=images; next != (Image *) NULL; next=next->next)\n    columns=MagickMax(next->columns,columns);\n  for (i=0; i < (ssize_t) rows; i++)\n  {\n    register ssize_t\n      j;\n    pixels[i]=(PixelChannels *) AcquireQuantumMemory(columns,sizeof(**pixels));\n    if (pixels[i] == (PixelChannels *) NULL)\n      return(DestroyPixelThreadSet(pixels));\n    for (j=0; j < (ssize_t) columns; j++)\n    {\n      register ssize_t\n        k;\n      for (k=0; k < MaxPixelChannels; k++)\n        pixels[i][j].channel[k]=0.0;\n    }\n  }\n  return(pixels);\n}", "target": 0}
{"code": "static int tga_readheader(FILE *fp, unsigned int *bits_per_pixel,\n                          unsigned int *width, unsigned int *height, int *flip_image)\n{\n    int palette_size;\n    unsigned char tga[TGA_HEADER_SIZE];\n    unsigned char id_len,  image_type;\n    unsigned char pixel_depth, image_desc;\n    unsigned short  cmap_len, cmap_entry_size;\n    unsigned short  image_w, image_h;\n    if (!bits_per_pixel || !width || !height || !flip_image) {\n        return 0;\n    }\n    if (fread(tga, TGA_HEADER_SIZE, 1, fp) != 1) {\n        fprintf(stderr,\n                \"\\nError: fread return a number of element different from the expected.\\n\");\n        return 0 ;\n    }\n    id_len = tga[0];\n    image_type = tga[2];\n    cmap_len = get_ushort(&tga[5]);\n    cmap_entry_size = tga[7];\n#if 0\n    x_origin = get_ushort(&tga[8]);\n    y_origin = get_ushort(&tga[10]);\n#endif\n    image_w = get_ushort(&tga[12]);\n    image_h = get_ushort(&tga[14]);\n    pixel_depth = tga[16];\n    image_desc  = tga[17];\n    *bits_per_pixel = (unsigned int)pixel_depth;\n    *width  = (unsigned int)image_w;\n    *height = (unsigned int)image_h;\n    if (id_len) {\n        unsigned char *id = (unsigned char *) malloc(id_len);\n        if (id == 0) {\n            fprintf(stderr, \"tga_readheader: memory out\\n\");\n            return 0;\n        }\n        if (!fread(id, id_len, 1, fp)) {\n            fprintf(stderr,\n                    \"\\nError: fread return a number of element different from the expected.\\n\");\n            free(id);\n            return 0 ;\n        }\n        free(id);\n    }\n    if (image_type > 8) {\n        fprintf(stderr, \"Sorry, compressed tga files are not currently supported.\\n\");\n        return 0 ;\n    }\n    *flip_image = !(image_desc & 32);\n    palette_size = cmap_len * (cmap_entry_size / 8);\n    if (palette_size > 0) {\n        fprintf(stderr, \"File contains a palette - not yet supported.\");\n        fseek(fp, palette_size, SEEK_CUR);\n    }\n    return 1;\n}", "target": 1}
{"code": "int sctp_verify_asconf(const struct sctp_association *asoc,\n\t\t       struct sctp_paramhdr *param_hdr, void *chunk_end,\n\t\t       struct sctp_paramhdr **errp) {\n\tsctp_addip_param_t *asconf_param;\n\tunion sctp_params param;\n\tint length, plen;\n\tparam.v = (sctp_paramhdr_t *) param_hdr;\n\twhile (param.v <= chunk_end - sizeof(sctp_paramhdr_t)) {\n\t\tlength = ntohs(param.p->length);\n\t\t*errp = param.p;\n\t\tif (param.v > chunk_end - length ||\n\t\t    length < sizeof(sctp_paramhdr_t))\n\t\t\treturn 0;\n\t\tswitch (param.p->type) {\n\t\tcase SCTP_PARAM_ADD_IP:\n\t\tcase SCTP_PARAM_DEL_IP:\n\t\tcase SCTP_PARAM_SET_PRIMARY:\n\t\t\tasconf_param = (sctp_addip_param_t *)param.v;\n\t\t\tplen = ntohs(asconf_param->param_hdr.length);\n\t\t\tif (plen < sizeof(sctp_addip_param_t) +\n\t\t\t    sizeof(sctp_paramhdr_t))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase SCTP_PARAM_SUCCESS_REPORT:\n\t\tcase SCTP_PARAM_ADAPTATION_LAYER_IND:\n\t\t\tif (length != sizeof(sctp_addip_param_t))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tparam.v += WORD_ROUND(length);\n\t}\n\tif (param.v != chunk_end)\n\t\treturn 0;\n\treturn 1;\n}", "target": 1}
{"code": "const TfLiteTensor* GetIntermediates(TfLiteContext* context,\n                                     const TfLiteNode* node, int index) {\n  const int tensor_index = ValidateTensorIndexing(\n      context, index, node->intermediates->size, node->intermediates->data);\n  if (tensor_index < 0) {\n    return nullptr;\n  }\n  return GetTensorAtIndex(context, tensor_index);\n}", "target": 0}
{"code": "htmlGetText(tree_t *t)\t\t\n{\n  uchar\t\t*s,\t\t\n\t\t*s2,\t\t\n\t\t*tdata = NULL,\t\n\t\t*talloc = NULL;\t\n  size_t\tslen,\t\t\n\t\ttlen;\t\t\n  slen = 0;\n  s    = NULL;\n  while (t != NULL)\n  {\n    if (t->child)\n      tdata = talloc = htmlGetText(t->child);\n    else\n      tdata = t->data;\n    if (tdata != NULL)\n    {\n      tlen = strlen((char *)tdata);\n      if (s)\n        s2 = (uchar *)realloc(s, 1 + slen + tlen);\n      else\n        s2 = (uchar *)malloc(1 + tlen);\n      if (!s2)\n        break;\n      s = s2;\n      memcpy((char *)s + slen, (char *)tdata, tlen);\n      slen += tlen;\n      if (talloc)\n      {\n\tfree(talloc);\n\ttalloc = NULL;\n      }\n    }\n    t = t->next;\n  }\n  if (slen)\n    s[slen] = '\\0';\n  if (talloc)\n    free(talloc);\n  return (s);\n}", "target": 1}
{"code": "static void test_bug17512527()\n{\n  MYSQL *conn1, *conn2;\n  MYSQL_STMT *stmt1, *stmt2;\n  const char *stmt1_txt= \"SELECT NOW();\";\n  const char *stmt2_txt= \"SELECT 1;\";\n  unsigned long thread_id;\n  char query[MAX_TEST_QUERY_LENGTH];\n  int rc;\n  conn1= client_connect(0, MYSQL_PROTOCOL_DEFAULT, 1);\n  conn2= client_connect(0, MYSQL_PROTOCOL_DEFAULT, 0);\n  stmt1 = mysql_stmt_init(conn1);\n  check_stmt(stmt1);\n  rc= mysql_stmt_prepare(stmt1, stmt1_txt, strlen(stmt1_txt));\n  check_execute(stmt1, rc);\n  thread_id= mysql_thread_id(conn1);\n  sprintf(query, \"KILL %lu\", thread_id);\n  if (thread_query(query))\n    exit(1);\n  stmt2 = mysql_stmt_init(conn1);\n  check_stmt(stmt2);\n  rc= mysql_stmt_prepare(stmt2, stmt2_txt, strlen(stmt2_txt));\n  check_execute(stmt1, rc);\n  mysql_stmt_close(stmt2);\n  mysql_stmt_close(stmt1);\n  mysql_close(conn1);\n  mysql_close(conn2);\n}", "target": 0}
{"code": "void CIRCSock::ReadLine(const CString& sData) {\n    CString sLine = sData;\n    sLine.TrimRight(\"\\n\\r\");\n    DEBUG(\"(\" << m_pNetwork->GetUser()->GetUserName() << \"/\"\n              << m_pNetwork->GetName() << \") IRC -> ZNC [\" << sLine << \"]\");\n    bool bReturn = false;\n    IRCSOCKMODULECALL(OnRaw(sLine), &bReturn);\n    if (bReturn) return;\n    CMessage Message(sLine);\n    Message.SetNetwork(m_pNetwork);\n    IRCSOCKMODULECALL(OnRawMessage(Message), &bReturn);\n    if (bReturn) return;\n    switch (Message.GetType()) {\n        case CMessage::Type::Account:\n            bReturn = OnAccountMessage(Message);\n            break;\n        case CMessage::Type::Action:\n            bReturn = OnActionMessage(Message);\n            break;\n        case CMessage::Type::Away:\n            bReturn = OnAwayMessage(Message);\n            break;\n        case CMessage::Type::Capability:\n            bReturn = OnCapabilityMessage(Message);\n            break;\n        case CMessage::Type::CTCP:\n            bReturn = OnCTCPMessage(Message);\n            break;\n        case CMessage::Type::Error:\n            bReturn = OnErrorMessage(Message);\n            break;\n        case CMessage::Type::Invite:\n            bReturn = OnInviteMessage(Message);\n            break;\n        case CMessage::Type::Join:\n            bReturn = OnJoinMessage(Message);\n            break;\n        case CMessage::Type::Kick:\n            bReturn = OnKickMessage(Message);\n            break;\n        case CMessage::Type::Mode:\n            bReturn = OnModeMessage(Message);\n            break;\n        case CMessage::Type::Nick:\n            bReturn = OnNickMessage(Message);\n            break;\n        case CMessage::Type::Notice:\n            bReturn = OnNoticeMessage(Message);\n            break;\n        case CMessage::Type::Numeric:\n            bReturn = OnNumericMessage(Message);\n            break;\n        case CMessage::Type::Part:\n            bReturn = OnPartMessage(Message);\n            break;\n        case CMessage::Type::Ping:\n            bReturn = OnPingMessage(Message);\n            break;\n        case CMessage::Type::Pong:\n            bReturn = OnPongMessage(Message);\n            break;\n        case CMessage::Type::Quit:\n            bReturn = OnQuitMessage(Message);\n            break;\n        case CMessage::Type::Text:\n            bReturn = OnTextMessage(Message);\n            break;\n        case CMessage::Type::Topic:\n            bReturn = OnTopicMessage(Message);\n            break;\n        case CMessage::Type::Wallops:\n            bReturn = OnWallopsMessage(Message);\n            break;\n        default:\n            break;\n    }\n    if (bReturn) return;\n    m_pNetwork->PutUser(Message);\n}", "target": 1}
{"code": "find_node_in_range(struct inode *inode, loff_t min, loff_t max)\n{\n\tstruct rb_node *n = uprobes_tree.rb_node;\n\twhile (n) {\n\t\tstruct uprobe *u = rb_entry(n, struct uprobe, rb_node);\n\t\tif (inode < u->inode) {\n\t\t\tn = n->rb_left;\n\t\t} else if (inode > u->inode) {\n\t\t\tn = n->rb_right;\n\t\t} else {\n\t\t\tif (max < u->offset)\n\t\t\t\tn = n->rb_left;\n\t\t\telse if (min > u->offset)\n\t\t\t\tn = n->rb_right;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn n;\n}", "target": 0}
{"code": "void test_chroot(const char *path)\n{\n\tif (chroot(path) == 0) {\n\t\tfprintf(stderr, \"leak at chroot of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at chroot of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "static void sctp_skb_set_owner_r_frag(struct sk_buff *skb, struct sock *sk)\n{\n\tstruct sk_buff *frag;\n\tif (!skb->data_len)\n\t\tgoto done;\n\tfor (frag = skb_shinfo(skb)->frag_list; frag; frag = frag->next)\n\t\tsctp_skb_set_owner_r_frag(frag, sk);\ndone:\n\tsctp_skb_set_owner_r(skb, sk);\n}", "target": 0}
{"code": "static WERROR dnsserver_complex_operate_zone(struct dnsserver_state *dsstate,\n\t\t\t\t\tTALLOC_CTX *mem_ctx,\n\t\t\t\t\tstruct dnsserver_zone *z,\n\t\t\t\t\tconst char *operation,\n\t\t\t\t\tconst unsigned int client_version,\n\t\t\t\t\tenum DNS_RPC_TYPEID typeid_in,\n\t\t\t\t\tunion DNSSRV_RPC_UNION *rin,\n\t\t\t\t\tenum DNS_RPC_TYPEID *typeid_out,\n\t\t\t\t\tunion DNSSRV_RPC_UNION *rout)\n{\n\tif (strcasecmp(operation, \"QueryDwordProperty\") == 0) {\n\t\tif (typeid_in == DNSSRV_TYPEID_LPSTR) {\n\t\t\treturn dnsserver_query_zone(dsstate, mem_ctx, z,\n\t\t\t\t\t\trin->String,\n\t\t\t\t\t\tclient_version,\n\t\t\t\t\t\ttypeid_out,\n\t\t\t\t\t\trout);\n\t\t}\n\t}\n\tDEBUG(0,(\"dnsserver: Invalid zone operation %s\", operation));\n\treturn WERR_DNS_ERROR_INVALID_PROPERTY;\n}", "target": 0}
{"code": "static int io_register_personality(struct io_ring_ctx *ctx)\n{\n\tconst struct cred *creds;\n\tu32 id;\n\tint ret;\n\tcreds = get_current_cred();\n\tret = xa_alloc_cyclic(&ctx->personalities, &id, (void *)creds,\n\t\t\tXA_LIMIT(0, USHRT_MAX), &ctx->pers_next, GFP_KERNEL);\n\tif (!ret)\n\t\treturn id;\n\tput_cred(creds);\n\treturn ret;", "target": 1}
{"code": "strncat_from_utf8_libarchive2(struct archive_string *as,\n    const void *_p, size_t len, struct archive_string_conv *sc)\n{\n\tconst char *s;\n\tint n;\n\tchar *p;\n\tchar *end;\n\tuint32_t unicode;\n#if HAVE_WCRTOMB\n\tmbstate_t shift_state;\n\tmemset(&shift_state, 0, sizeof(shift_state));\n#else\n\twctomb(NULL, L'\\0');\n#endif\n\t(void)sc; \n\tif (archive_string_ensure(as, as->length + len + 1) == NULL)\n\t\treturn (-1);\n\ts = (const char *)_p;\n\tp = as->s + as->length;\n\tend = as->s + as->buffer_length - MB_CUR_MAX -1;\n\twhile ((n = _utf8_to_unicode(&unicode, s, len)) != 0) {\n\t\twchar_t wc;\n\t\tif (p >= end) {\n\t\t\tas->length = p - as->s;\n\t\t\tif (archive_string_ensure(as,\n\t\t\t    as->length + len * 2 + 1) == NULL)\n\t\t\t\treturn (-1);\n\t\t\tp = as->s + as->length;\n\t\t\tend = as->s + as->buffer_length - MB_CUR_MAX -1;\n\t\t}\n\t\tif (n < 0) {\n\t\t\tn *= -1;\n\t\t\twc = L'?';\n\t\t} else\n\t\t\twc = (wchar_t)unicode;\n\t\ts += n;\n\t\tlen -= n;\n#if HAVE_WCRTOMB\n\t\tn = (int)wcrtomb(p, wc, &shift_state);\n#else\n\t\tn = (int)wctomb(p, wc);\n#endif\n\t\tif (n == -1)\n\t\t\treturn (-1);\n\t\tp += n;\n\t}\n\tas->length = p - as->s;\n\tas->s[as->length] = '\\0';\n\treturn (0);\n}", "target": 1}
{"code": "int utf8s_to_utf16s(const u8 *s, int len, wchar_t *pwcs)\n{\n\tu16 *op;\n\tint size;\n\tunicode_t u;\n\top = pwcs;\n\twhile (*s && len > 0) {\n\t\tif (*s & 0x80) {\n\t\t\tsize = utf8_to_utf32(s, len, &u);\n\t\t\tif (size < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (u >= PLANE_SIZE) {\n\t\t\t\tu -= PLANE_SIZE;\n\t\t\t\t*op++ = (wchar_t) (SURROGATE_PAIR |\n\t\t\t\t\t\t((u >> 10) & SURROGATE_BITS));\n\t\t\t\t*op++ = (wchar_t) (SURROGATE_PAIR |\n\t\t\t\t\t\tSURROGATE_LOW |\n\t\t\t\t\t\t(u & SURROGATE_BITS));\n\t\t\t} else {\n\t\t\t\t*op++ = (wchar_t) u;\n\t\t\t}\n\t\t\ts += size;\n\t\t\tlen -= size;\n\t\t} else {\n\t\t\t*op++ = *s++;\n\t\t\tlen--;\n\t\t}\n\t}\n\treturn op - pwcs;\n}", "target": 1}
{"code": "int nfc_llcp_data_received(struct nfc_dev *dev, struct sk_buff *skb)\n{\n\tstruct nfc_llcp_local *local;\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tkfree_skb(skb);\n\t\treturn -ENODEV;\n\t}\n\t__nfc_llcp_recv(local, skb);\n\tnfc_llcp_local_put(local);\n\treturn 0;\n}", "target": 0}
{"code": "    static CImg<T> get_load_camera(const unsigned int camera_index=0, const unsigned int skip_frames=0,\n                                   const bool release_camera=true,\n                                   const unsigned int capture_width=0, const unsigned int capture_height=0) {\n      return CImg<T>().load_camera(camera_index,skip_frames,release_camera,capture_width,capture_height);", "target": 0}
{"code": "static int asn1_find_indefinite_length(const unsigned char *data, size_t datalen,\n\t\t\t\t       size_t *_dp, size_t *_len,\n\t\t\t\t       const char **_errmsg)\n{\n\tunsigned char tag, tmp;\n\tsize_t dp = *_dp, len, n;\n\tint indef_level = 1;\nnext_tag:\n\tif (unlikely(datalen - dp < 2)) {\n\t\tif (datalen == dp)\n\t\t\tgoto missing_eoc;\n\t\tgoto data_overrun_error;\n\t}\n\ttag = data[dp++];\n\tif (tag == 0) {\n\t\tif (data[dp++] != 0)\n\t\t\tgoto invalid_eoc;\n\t\tif (--indef_level <= 0) {\n\t\t\t*_len = dp - *_dp;\n\t\t\t*_dp = dp;\n\t\t\treturn 0;\n\t\t}\n\t\tgoto next_tag;\n\t}\n\tif (unlikely((tag & 0x1f) == ASN1_LONG_TAG)) {\n\t\tdo {\n\t\t\tif (unlikely(datalen - dp < 2))\n\t\t\t\tgoto data_overrun_error;\n\t\t\ttmp = data[dp++];\n\t\t} while (tmp & 0x80);\n\t}\n\tlen = data[dp++];\n\tif (len <= 0x7f) {\n\t\tdp += len;\n\t\tgoto next_tag;\n\t}\n\tif (unlikely(len == ASN1_INDEFINITE_LENGTH)) {\n\t\tif (unlikely((tag & ASN1_CONS_BIT) == ASN1_PRIM << 5))\n\t\t\tgoto indefinite_len_primitive;\n\t\tindef_level++;\n\t\tgoto next_tag;\n\t}\n\tn = len - 0x80;\n\tif (unlikely(n > sizeof(size_t) - 1))\n\t\tgoto length_too_long;\n\tif (unlikely(n > datalen - dp))\n\t\tgoto data_overrun_error;\n\tfor (len = 0; n > 0; n--) {\n\t\tlen <<= 8;\n\t\tlen |= data[dp++];\n\t}\n\tdp += len;\n\tgoto next_tag;\nlength_too_long:\n\t*_errmsg = \"Unsupported length\";\n\tgoto error;\nindefinite_len_primitive:\n\t*_errmsg = \"Indefinite len primitive not permitted\";\n\tgoto error;\ninvalid_eoc:\n\t*_errmsg = \"Invalid length EOC\";\n\tgoto error;\ndata_overrun_error:\n\t*_errmsg = \"Data overrun error\";\n\tgoto error;\nmissing_eoc:\n\t*_errmsg = \"Missing EOC in indefinite len cons\";\nerror:\n\t*_dp = dp;\n\treturn -1;\n}", "target": 1}
{"code": "BGD_DECLARE(void) gdImageWBMPCtx(gdImagePtr image, int fg, gdIOCtx *out)\n{\n\tint x, y, pos;\n\tWbmp *wbmp;\n\tif((wbmp = createwbmp(gdImageSX(image), gdImageSY(image), WBMP_WHITE)) == NULL) {\n\t\tgd_error(\"Could not create WBMP\\n\");\n\t\treturn;\n\t}\n\tpos = 0;\n\tfor(y = 0; y < gdImageSY(image); y++) {\n\t\tfor(x = 0; x < gdImageSX(image); x++) {\n\t\t\tif(gdImageGetPixel(image, x, y) == fg) {\n\t\t\t\twbmp->bitmap[pos] = WBMP_BLACK;\n\t\t\t}\n\t\t\tpos++;\n\t\t}\n\t}\n\tif(writewbmp(wbmp, &gd_putout, out)) {\n\t\tgd_error(\"Could not save WBMP\\n\");\n\t}\n\tfreewbmp(wbmp);\n}", "target": 1}
{"code": "static int f_midi_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\n{\n\tstruct f_midi *midi = func_to_midi(f);\n\tunsigned i;\n\tint err;\n\tif (intf != midi->ms_id)\n\t\treturn 0;\n\terr = f_midi_start_ep(midi, f, midi->in_ep);\n\tif (err)\n\t\treturn err;\n\terr = f_midi_start_ep(midi, f, midi->out_ep);\n\tif (err)\n\t\treturn err;\n\twhile (kfifo_avail(&midi->in_req_fifo)) {\n\t\tstruct usb_request *req =\n\t\t\tmidi_alloc_ep_req(midi->in_ep, midi->buflen);\n\t\tif (req == NULL)\n\t\t\treturn -ENOMEM;\n\t\treq->length = 0;\n\t\treq->complete = f_midi_complete;\n\t\tkfifo_put(&midi->in_req_fifo, req);\n\t}\n\tfor (i = 0; i < midi->qlen && err == 0; i++) {\n\t\tstruct usb_request *req =\n\t\t\tmidi_alloc_ep_req(midi->out_ep, midi->buflen);\n\t\tif (req == NULL)\n\t\t\treturn -ENOMEM;\n\t\treq->complete = f_midi_complete;\n\t\terr = usb_ep_queue(midi->out_ep, req, GFP_ATOMIC);\n\t\tif (err) {\n\t\t\tERROR(midi, \"%s: couldn't enqueue request: %d\\n\",\n\t\t\t\t    midi->out_ep->name, err);\n\t\t\tfree_ep_req(midi->out_ep, req);\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void RuleMatchCandidateTxArrayFree(DetectEngineThreadCtx *det_ctx)\n{\n    SCFree(det_ctx->tx_candidates);\n    det_ctx->tx_candidates_size = 0;\n}", "target": 0}
{"code": "static void error_handler(int err, void *arg)\n{\n\terror(\"Engine just broken: %m.\\n\", err);\n}", "target": 0}
{"code": "process_open(u_int32_t id)\n{\n\tu_int32_t pflags;\n\tAttrib a;\n\tchar *name;\n\tint r, handle, fd, flags, mode, status = SSH2_FX_FAILURE;\n\tif ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(iqueue, &pflags)) != 0 || \n\t    (r = decode_attrib(iqueue, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tdebug3(\"request %u: open flags %d\", id, pflags);\n\tflags = flags_from_portable(pflags);\n\tmode = (a.flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ? a.perm : 0666;\n\tlogit(\"open \\\"%s\\\" flags %s mode 0%o\",\n\t    name, string_from_portable(pflags), mode);\n\tif (readonly &&\n\t    ((flags & O_ACCMODE) == O_WRONLY ||\n\t    (flags & O_ACCMODE) == O_RDWR)) {\n\t\tverbose(\"Refusing open request in read-only mode\");\n\t\tstatus = SSH2_FX_PERMISSION_DENIED;\n\t} else {\n\t\tfd = open(name, flags, mode);\n\t\tif (fd < 0) {\n\t\t\tstatus = errno_to_portable(errno);\n\t\t} else {\n\t\t\thandle = handle_new(HANDLE_FILE, name, fd, flags, NULL);\n\t\t\tif (handle < 0) {\n\t\t\t\tclose(fd);\n\t\t\t} else {\n\t\t\t\tsend_handle(id, handle);\n\t\t\t\tstatus = SSH2_FX_OK;\n\t\t\t}\n\t\t}\n\t}\n\tif (status != SSH2_FX_OK)\n\t\tsend_status(id, status);\n\tfree(name);\n}", "target": 1}
{"code": "create_separator(void)\n{\n\tstruct defer_node *result;\n\tresult = malloc(sizeof(struct defer_node));\n\tif (result == NULL)\n\t\treturn NULL;\n\tresult->type = DNT_SEPARATOR;\n\treturn result;\n}", "target": 0}
{"code": "int usb_cypress_load_firmware(struct usb_device *udev, const struct firmware *fw, int type)\n{\n\tstruct hexline *hx;\n\tu8 reset;\n\tint ret,pos=0;\n\thx = kmalloc(sizeof(*hx), GFP_KERNEL);\n\tif (!hx)\n\t\treturn -ENOMEM;\n\treset = 1;\n\tif ((ret = usb_cypress_writemem(udev,cypress[type].cpu_cs_register,&reset,1)) != 1)\n\t\terr(\"could not stop the USB controller CPU.\");\n\twhile ((ret = dvb_usb_get_hexline(fw, hx, &pos)) > 0) {\n\t\tdeb_fw(\"writing to address 0x%04x (buffer: 0x%02x %02x)\\n\", hx->addr, hx->len, hx->chk);\n\t\tret = usb_cypress_writemem(udev, hx->addr, hx->data, hx->len);\n\t\tif (ret != hx->len) {\n\t\t\terr(\"error while transferring firmware (transferred size: %d, block size: %d)\",\n\t\t\t\tret, hx->len);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ret < 0) {\n\t\terr(\"firmware download failed at %d with %d\",pos,ret);\n\t\tkfree(hx);\n\t\treturn ret;\n\t}\n\tif (ret == 0) {\n\t\treset = 0;\n\t\tif (ret || usb_cypress_writemem(udev,cypress[type].cpu_cs_register,&reset,1) != 1) {\n\t\t\terr(\"could not restart the USB controller CPU.\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else\n\t\tret = -EIO;\n\tkfree(hx);\n\treturn ret;\n}", "target": 1}
{"code": "static int l2cap_mode_supported(__u8 mode, __u32 feat_mask)\n{\n\tu32 local_feat_mask = l2cap_feat_mask;\n\tif (enable_ertm)\n\t\tlocal_feat_mask |= L2CAP_FEAT_ERTM;\n\tswitch (mode) {\n\tcase L2CAP_MODE_ERTM:\n\t\treturn L2CAP_FEAT_ERTM & feat_mask & local_feat_mask;\n\tcase L2CAP_MODE_STREAMING:\n\t\treturn L2CAP_FEAT_STREAMING & feat_mask & local_feat_mask;\n\tdefault:\n\t\treturn 0x00;\n\t}\n}", "target": 0}
{"code": "static int mxf_read_primer_pack(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFContext *mxf = arg;\n    int item_num = avio_rb32(pb);\n    int item_len = avio_rb32(pb);\n    if (item_len != 18) {\n        avpriv_request_sample(pb, \"Primer pack item length %d\", item_len);\n        return AVERROR_PATCHWELCOME;\n    }\n    if (item_num > 65536) {\n        av_log(mxf->fc, AV_LOG_ERROR, \"item_num %d is too large\\n\", item_num);\n        return AVERROR_INVALIDDATA;\n    }\n    mxf->local_tags = av_calloc(item_num, item_len);\n    if (!mxf->local_tags)\n        return AVERROR(ENOMEM);\n    mxf->local_tags_count = item_num;\n    avio_read(pb, mxf->local_tags, item_num*item_len);\n    return 0;\n}", "target": 1}
{"code": "find_entry2modify(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n\tback_txn *txn\n)\n{\n\treturn( find_entry_internal( pb, be, addr, 1, txn, 0 ) );\n}", "target": 1}
{"code": "static void cmd_anal_ucall_ref(RCore *core, ut64 addr) {\n\tRAnalFunction * fcn = r_anal_get_function_at (core->anal, addr);\n\tif (fcn) {\n\t\tr_cons_printf (\" ; %s\", fcn->name);\n\t} else {\n\t\tr_cons_printf (\" ; 0x%\" PFMT64x, addr);\n\t}\n}", "target": 1}
{"code": "static bool IsValidPermutation(const std::string& src, const std::string& dst) {\n  if (src.size() != dst.size()) {\n    return false;\n  }\n  std::map<char, bool> characters;\n  for (const auto c : src) {\n    if (characters[c]) {\n      return false;\n    }\n    characters[c] = true;\n  }\n  for (const auto c : dst) {\n    if (!characters[c]) {\n      return false;\n    }\n    characters[c] = false;\n  }\n  return true;\n}", "target": 0}
{"code": "EXPORTED int http_allow_noauth_get(struct transaction_t *txn)\n{\n    switch (txn->meth) {\n    case METH_GET:\n    case METH_HEAD:\n        return 0;\n    default:\n        return 1;\n    }\n}", "target": 0}
{"code": "static __be32 nfsacld_proc_setacl(struct svc_rqst * rqstp,\n\t\tstruct nfsd3_setaclargs *argp,\n\t\tstruct nfsd_attrstat *resp)\n{\n\tstruct inode *inode;\n\tsvc_fh *fh;\n\t__be32 nfserr = 0;\n\tint error;\n\tdprintk(\"nfsd: SETACL(2acl)   %s\\n\", SVCFH_fmt(&argp->fh));\n\tfh = fh_copy(&resp->fh, &argp->fh);\n\tnfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);\n\tif (nfserr)\n\t\tgoto out;\n\tinode = d_inode(fh->fh_dentry);\n\tif (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {\n\t\terror = -EOPNOTSUPP;\n\t\tgoto out_errno;\n\t}\n\terror = fh_want_write(fh);\n\tif (error)\n\t\tgoto out_errno;\n\terror = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);\n\tif (error)\n\t\tgoto out_drop_write;\n\terror = inode->i_op->set_acl(inode, argp->acl_default,\n\t\t\t\t     ACL_TYPE_DEFAULT);\n\tif (error)\n\t\tgoto out_drop_write;\n\tfh_drop_write(fh);\n\tnfserr = fh_getattr(fh, &resp->stat);\nout:\n\tposix_acl_release(argp->acl_access);\n\tposix_acl_release(argp->acl_default);\n\treturn nfserr;\nout_drop_write:\n\tfh_drop_write(fh);\nout_errno:\n\tnfserr = nfserrno(error);\n\tgoto out;\n}", "target": 1}
{"code": "int test(char *URL)\n{\n  int errors = 0;\n  (void)URL; \n  errors += test_weird_arguments();\n  errors += test_unsigned_short_formatting();\n  errors += test_signed_short_formatting();\n  errors += test_unsigned_int_formatting();\n  errors += test_signed_int_formatting();\n  errors += test_unsigned_long_formatting();\n  errors += test_signed_long_formatting();\n  errors += test_curl_off_t_formatting();\n  errors += test_string_formatting();\n  errors += test_float_formatting();\n  if(errors)\n    return TEST_ERR_MAJOR_BAD;\n  else\n    return 0;\n}", "target": 0}
{"code": "TEST(AsyncSSLSocketTest, EarlyCloseNotify) {\n  WriteOnEofReadCallback readCallback(nullptr);\n  HandshakeCallback handshakeCallback(&readCallback);\n  SSLServerAcceptCallback acceptCallback(&handshakeCallback);\n  TestSSLServer server(&acceptCallback);\n  EventBase eventBase;\n  CloseNotifyConnector cnc(&eventBase, server.getAddress());\n  eventBase.loop();\n}", "target": 0}
{"code": "cmnd_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct member *m, const char *runchroot, struct cmnd_info *info)\n{\n    struct alias *a;\n    struct sudo_command *c;\n    int rc, matched = UNSPEC;\n    debug_decl(cmnd_matches, SUDOERS_DEBUG_MATCH);\n    switch (m->type) {\n\tcase ALL:\n\tcase COMMAND:\n\t    c = (struct sudo_command *)m->name;\n\t    if (command_matches(parse_tree->ctx, c->cmnd, c->args, runchroot,\n\t\t    info, &c->digests))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase ALIAS:\n\t    a = alias_get(parse_tree, m->name, CMNDALIAS);\n\t    if (a != NULL) {\n\t\trc = cmndlist_matches(parse_tree, &a->members, runchroot, info);\n\t\tif (rc != UNSPEC) {\n\t\t    if (m->negated) {\n\t\t\tmatched = rc == ALLOW ? DENY : ALLOW;\n\t\t    } else {\n\t\t\tmatched = rc;\n\t\t    }\n\t\t}\n\t\talias_put(a);\n\t    }\n\t    break;\n    }\n    debug_return_int(matched);\n}", "target": 1}
{"code": "ext4_xattr_release_block(handle_t *handle, struct inode *inode,\n\t\t\t struct buffer_head *bh)\n{\n\tstruct mb_cache_entry *ce = NULL;\n\tint error = 0;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\tce = mb_cache_entry_get(ext4_mb_cache, bh->b_bdev, bh->b_blocknr);\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terror = ext4_journal_get_write_access(handle, bh);\n\tif (error)\n\t\tgoto out;\n\tlock_buffer(bh);\n\tif (BHDR(bh)->h_refcount == cpu_to_le32(1)) {\n\t\tea_bdebug(bh, \"refcount now=0; freeing\");\n\t\tif (ce)\n\t\t\tmb_cache_entry_free(ce);\n\t\tget_bh(bh);\n\t\tunlock_buffer(bh);\n\t\text4_free_blocks(handle, inode, bh, 0, 1,\n\t\t\t\t EXT4_FREE_BLOCKS_METADATA |\n\t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\t} else {\n\t\tle32_add_cpu(&BHDR(bh)->h_refcount, -1);\n\t\tif (ce)\n\t\t\tmb_cache_entry_release(ce);\n\t\tif (ext4_handle_valid(handle))\n\t\t\terror = ext4_handle_dirty_xattr_block(handle, inode,\n\t\t\t\t\t\t\t      bh);\n\t\tunlock_buffer(bh);\n\t\tif (!ext4_handle_valid(handle))\n\t\t\terror = ext4_handle_dirty_xattr_block(handle, inode,\n\t\t\t\t\t\t\t      bh);\n\t\tif (IS_SYNC(inode))\n\t\t\text4_handle_sync(handle);\n\t\tdquot_free_block(inode, EXT4_C2B(EXT4_SB(inode->i_sb), 1));\n\t\tea_bdebug(bh, \"refcount now=%d; releasing\",\n\t\t\t  le32_to_cpu(BHDR(bh)->h_refcount));\n\t}\nout:\n\text4_std_error(inode->i_sb, error);\n\treturn;\n}", "target": 1}
{"code": "static void print_vtable(vtableEntry* start, int len, outputStream* st) {\n  return print_vtable(reinterpret_cast<intptr_t*>(start), len, st);\n}", "target": 0}
{"code": "static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_comp rcomp;\n\tsnprintf(rcomp.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"compression\");\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n\t\t    sizeof(struct crypto_report_comp), &rcomp))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "exo_open_uri_known_category (const gchar  *uri,\n                             const gchar  *scheme,\n                             gboolean     *succeed)\n{\n  guint        i;\n  const gchar *category = NULL;\n  g_return_val_if_fail (uri != NULL, FALSE);\n  g_return_val_if_fail (scheme != NULL, FALSE);\n  for (i = 0; category == NULL && i < G_N_ELEMENTS (known_schemes); i++)\n    {\n      if (g_regex_match_simple (known_schemes[i].pattern, scheme, G_REGEX_CASELESS, 0))\n        {\n          *succeed = exo_open_launch_category (known_schemes[i].category, uri);\n          return TRUE;\n        }\n    }\n  return FALSE;\n}", "target": 0}
{"code": "static int seed_from_timestamp_and_pid(uint32_t *seed) {\n#ifdef HAVE_GETTIMEOFDAY\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    *seed = (uint32_t)tv.tv_sec ^ (uint32_t)tv.tv_usec;\n#else\n    *seed = (uint32_t)time(NULL);\n#endif\n#if defined(_WIN32)\n    *seed ^= (uint32_t)_getpid();\n#elif defined(HAVE_GETPID)\n    *seed ^= (uint32_t)getpid();\n#endif\n    return 0;\n}", "target": 0}
{"code": "archive_wstring_append_from_mbs(struct archive_wstring *dest,\n    const char *p, size_t len)\n{\n\tsize_t r;\n\tint ret_val = 0;\n\tsize_t wcs_length = len;\n\tsize_t mbs_length = len;\n\tconst char *mbs = p;\n\twchar_t *wcs;\n#if HAVE_MBRTOWC\n\tmbstate_t shift_state;\n\tmemset(&shift_state, 0, sizeof(shift_state));\n#endif\n\tif (NULL == archive_wstring_ensure(dest, dest->length + wcs_length + 1))\n\t\treturn (-1);\n\twcs = dest->s + dest->length;\n\twhile (*mbs && mbs_length > 0) {\n\t\tif (wcs_length == 0) {\n\t\t\tdest->length = wcs - dest->s;\n\t\t\tdest->s[dest->length] = L'\\0';\n\t\t\twcs_length = mbs_length;\n\t\t\tif (NULL == archive_wstring_ensure(dest,\n\t\t\t    dest->length + wcs_length + 1))\n\t\t\t\treturn (-1);\n\t\t\twcs = dest->s + dest->length;\n\t\t}\n#if HAVE_MBRTOWC\n\t\tr = mbrtowc(wcs, mbs, wcs_length, &shift_state);\n#else\n\t\tr = mbtowc(wcs, mbs, wcs_length);\n#endif\n\t\tif (r == (size_t)-1 || r == (size_t)-2) {\n\t\t\tret_val = -1;\n\t\t\tif (errno == EILSEQ) {\n\t\t\t\t++mbs;\n\t\t\t\t--mbs_length;\n\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t\tif (r == 0 || r > mbs_length)\n\t\t\tbreak;\n\t\twcs++;\n\t\twcs_length--;\n\t\tmbs += r;\n\t\tmbs_length -= r;\n\t}\n\tdest->length = wcs - dest->s;\n\tdest->s[dest->length] = L'\\0';\n\treturn (ret_val);\n}", "target": 1}
{"code": "std::string Url::DecodeUnsafe(string_view encoded) {\n  std::string raw;\n  if (Decode(encoded, &raw)) {\n    return raw;\n  }\n  return ToString(encoded);\n}", "target": 0}
{"code": "void bpf_map_inc(struct bpf_map *map, bool uref)\n{\n\tatomic_inc(&map->refcnt);\n\tif (uref)\n\t\tatomic_inc(&map->usercnt);\n}", "target": 1}
{"code": "void Item_cache_row::set_null()\n{\n  Item_cache::set_null();\n  if (!values)\n    return;\n  for (uint i= 0; i < item_count; i++)\n    values[i]->set_null();\n};", "target": 0}
{"code": "int BN_is_one(const BIGNUM *a)\n{\n    return BN_abs_is_word(a, 1) && !a->neg;\n}", "target": 0}
{"code": "mptctl_eventreport (unsigned long arg)\n{\n\tstruct mpt_ioctl_eventreport __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_eventreport\t karg;\n\tMPT_ADAPTER\t\t *ioc;\n\tint\t\t\t iocnum;\n\tint\t\t\t numBytes, maxEvents, max;\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_eventreport))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_eventreport - \"\n\t\t\t\"Unable to read in mpt_ioctl_eventreport struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_eventreport() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_eventreport called.\\n\",\n\t    ioc->name));\n\tnumBytes = karg.hdr.maxDataSize - sizeof(mpt_ioctl_header);\n\tmaxEvents = numBytes/sizeof(MPT_IOCTL_EVENTS);\n\tmax = MPTCTL_EVENT_LOG_SIZE < maxEvents ? MPTCTL_EVENT_LOG_SIZE : maxEvents;\n\tif ((max < 1) || !ioc->events)\n\t\treturn -ENODATA;\n\tioc->aen_event_read_flag=0;\n\tnumBytes = max * sizeof(MPT_IOCTL_EVENTS);\n\tif (copy_to_user(uarg->eventData, ioc->events, numBytes)) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_eventreport - \"\n\t\t\t\"Unable to write out mpt_ioctl_eventreport struct @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, ioc->events);\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static NTLM_AV_PAIR* ntlm_av_pair_next(NTLM_AV_PAIR* pAvPair, size_t* pcbAvPair)\n{\n\tsize_t offset;\n\tif (!pcbAvPair)\n\t\treturn NULL;\n\tif (!ntlm_av_pair_check(pAvPair, *pcbAvPair))\n\t\treturn NULL;\n\toffset = ntlm_av_pair_get_next_offset(pAvPair);\n\t*pcbAvPair -= offset;\n\treturn (NTLM_AV_PAIR*)((PBYTE)pAvPair + offset);\n}", "target": 1}
{"code": "isoclns_print(netdissect_options *ndo,\n              const uint8_t *p, u_int length, u_int caplen)\n{\n\tif (caplen <= 1) { \n\t\tND_PRINT((ndo, \"|OSI\"));\n\t\treturn;\n\t}\n\tif (ndo->ndo_eflag)\n\t\tND_PRINT((ndo, \"OSI NLPID %s (0x%02x): \", tok2str(nlpid_values, \"Unknown\", *p), *p));\n\tswitch (*p) {\n\tcase NLPID_CLNP:\n\t\tif (!clnp_print(ndo, p, length))\n\t\t\tprint_unknown_data(ndo, p, \"\\n\\t\", caplen);\n\t\tbreak;\n\tcase NLPID_ESIS:\n\t\tesis_print(ndo, p, length);\n\t\treturn;\n\tcase NLPID_ISIS:\n\t\tif (!isis_print(ndo, p, length))\n\t\t\tprint_unknown_data(ndo, p, \"\\n\\t\", caplen);\n\t\tbreak;\n\tcase NLPID_NULLNS:\n\t\tND_PRINT((ndo, \"%slength: %u\", ndo->ndo_eflag ? \"\" : \", \", length));\n\t\tbreak;\n\tcase NLPID_Q933:\n\t\tq933_print(ndo, p + 1, length - 1);\n\t\tbreak;\n\tcase NLPID_IP:\n\t\tip_print(ndo, p + 1, length - 1);\n\t\tbreak;\n\tcase NLPID_IP6:\n\t\tip6_print(ndo, p + 1, length - 1);\n\t\tbreak;\n\tcase NLPID_PPP:\n\t\tppp_print(ndo, p + 1, length - 1);\n\t\tbreak;\n\tdefault:\n\t\tif (!ndo->ndo_eflag)\n\t\t\tND_PRINT((ndo, \"OSI NLPID 0x%02x unknown\", *p));\n\t\tND_PRINT((ndo, \"%slength: %u\", ndo->ndo_eflag ? \"\" : \", \", length));\n\t\tif (caplen > 1)\n\t\t\tprint_unknown_data(ndo, p, \"\\n\\t\", caplen);\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "parse_wcc_attr(netdissect_options *ndo,\n               const uint32_t *dp)\n{\n\tND_PRINT((ndo, \" sz %\" PRIu64, EXTRACT_64BITS(&dp[0])));\n\tND_PRINT((ndo, \" mtime %u.%06u ctime %u.%06u\",\n\t       EXTRACT_32BITS(&dp[2]), EXTRACT_32BITS(&dp[3]),\n\t       EXTRACT_32BITS(&dp[4]), EXTRACT_32BITS(&dp[5])));\n\treturn (dp + 6);\n}", "target": 0}
{"code": "void LinearAlgebraOp<InputScalar, OutputScalar>::AnalyzeInputs(\n    OpKernelContext* context, TensorInputs* inputs,\n    TensorShapes* input_matrix_shapes, TensorShape* batch_shape) {\n  int input_rank = -1;\n  for (int i = 0; i < NumMatrixInputs(context); ++i) {\n    const Tensor& in = context->input(i);\n    if (i == 0) {\n      input_rank = in.dims();\n      OP_REQUIRES(\n          context, input_rank >= 2,\n          errors::InvalidArgument(\"Input tensor \", i,\n                                  \" must have rank >= 2, got \", input_rank));\n      for (int dim = 0; dim < input_rank - 2; ++dim) {\n        batch_shape->AddDim(in.dim_size(dim));\n      }\n    } else {\n      OP_REQUIRES(context, input_rank == in.dims(),\n                  errors::InvalidArgument(\n                      \"All input tensors must have the same rank.\"));\n      for (int dim = 0; dim < input_rank - 2; ++dim) {\n        OP_REQUIRES(\n            context, in.dim_size(dim) == batch_shape->dim_size(dim),\n            errors::InvalidArgument(\n                \"All input tensors must have the same outer dimensions.\"));\n      }\n    }\n    const int row_dimension = input_rank - 2;\n    const int col_dimension = input_rank - 1;\n    const int64_t num_rows = in.dim_size(row_dimension);\n    const int64_t num_cols = in.dim_size(col_dimension);\n    input_matrix_shapes->emplace_back(\n        std::initializer_list<int64_t>({num_rows, num_cols}));\n    inputs->emplace_back(&in);\n    OP_REQUIRES(\n        context, in.dtype() == DataTypeToEnum<InputScalar>::v(),\n        errors::InvalidArgument(\"Invalid input dtype \", in.dtype(), \" vs \",\n                                DataTypeToEnum<InputScalar>::v()));\n  }\n  ValidateInputMatrixShapes(context, *input_matrix_shapes);\n}", "target": 0}
{"code": "Status SparseReduceShapeFn(InferenceContext* c) {\n  bool keep_dims = false;\n  TF_RETURN_IF_ERROR(c->GetAttr(\"keep_dims\", &keep_dims));\n  const Tensor* shape_tensor = c->input_tensor(2);\n  const Tensor* axes_tensor = c->input_tensor(3);\n  if (shape_tensor != nullptr && axes_tensor != nullptr) {\n    auto shape_vec = shape_tensor->flat<int64>();\n    auto axes_vec = axes_tensor->flat<int32>();\n    int64_t ndims = shape_vec.size();\n    absl::flat_hash_set<int64> axes;\n    if (ndims == 0)\n      return errors::InvalidArgument(\n          \"Number of dims in shape tensor must not be 0\");\n    for (int i = 0; i < axes_vec.size(); i++) {\n      axes.insert((axes_vec(i) + ndims) % ndims);\n    }\n    std::vector<DimensionHandle> dims;\n    if (keep_dims) {\n      dims.reserve(ndims);\n      for (int d = 0; d < ndims; ++d) {\n        if (axes.find(d) == axes.end()) {\n          dims.push_back(c->MakeDim(shape_vec(d)));\n        } else {\n          dims.push_back(c->MakeDim(1));\n        }\n      }\n    } else {\n      for (int d = 0; d < ndims; ++d) {\n        if (axes.find(d) == axes.end()) {\n          dims.push_back(c->MakeDim(shape_vec(d)));\n        }\n      }\n    }\n    c->set_output(0, c->MakeShape(dims));\n    return Status::OK();\n  }\n  return UnknownShape(c);\n}", "target": 0}
{"code": "  void operator()(OpKernelContext* ctx, const Index num_segments,\n                  const TensorShape& segment_ids_shape,\n                  typename TTypes<Index>::ConstFlat segment_ids,\n                  const Index data_size, const T* data,\n                  typename TTypes<T, 2>::Tensor output) {\n    if (output.size() == 0) {\n      return;\n    }\n    GPUDevice d = ctx->template eigen_device<GPUDevice>();\n    GpuLaunchConfig config = GetGpuLaunchConfig(output.size(), d);\n    TF_CHECK_OK(GpuLaunchKernel(\n        SetToValue<T>, config.block_count, config.thread_per_block, 0,\n        d.stream(), output.size(), output.data(), InitialValueF()()));\n    if (data_size == 0 || segment_ids_shape.num_elements() == 0) {\n      return;\n    }\n    const Index input_outer_dim_size = segment_ids.dimension(0);\n    const Index input_inner_dim_size = data_size / input_outer_dim_size;\n    config = GetGpuLaunchConfig(data_size, d);\n    TF_CHECK_OK(\n        GpuLaunchKernel(UnsortedSegmentCustomKernel<T, Index, ReductionF>,\n                        config.block_count, config.thread_per_block, 0,\n                        d.stream(), input_outer_dim_size, input_inner_dim_size,\n                        num_segments, segment_ids.data(), data, output.data()));\n  }", "target": 1}
{"code": "static GF_Err av1dmx_parse_flush_sample(GF_Filter *filter, GF_AV1DmxCtx *ctx)\n{\n\tu32 pck_size;\n\tGF_FilterPacket *pck;\n\tu8 *output;\n\tif (!ctx->opid)\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\tgf_bs_get_content_no_truncate(ctx->state.bs, &ctx->state.frame_obus, &pck_size, &ctx->state.frame_obus_alloc);\n\tif (!pck_size) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1Dmx] no frame OBU, skipping OBU\\n\"));\n\t\treturn GF_OK;\n\t}\n\tpck = gf_filter_pck_new_alloc(ctx->opid, pck_size, &output);\n\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, pck);\n\tgf_filter_pck_set_cts(pck, ctx->cts);\n\tgf_filter_pck_set_sap(pck, ctx->state.frame_state.key_frame ? GF_FILTER_SAP_1 : 0);\n\tmemcpy(output, ctx->state.frame_obus, pck_size);\n\tif (ctx->deps) {\n\t\tu8 flags = 0;\n\t\tflags = ( ctx->state.frame_state.key_frame) ? 2 : 1;\n\t\tflags <<= 2;\n\t \tflags |= ctx->state.frame_state.refresh_frame_flags ? 1 : 2;\n\t\tflags <<= 2;\n\t \tgf_filter_pck_set_dependency_flags(pck, flags);\n\t}\n\tgf_filter_pck_send(pck);\n\tav1dmx_update_cts(ctx);\n\tgf_av1_reset_state(&ctx->state, GF_FALSE);\n\treturn GF_OK;\n}", "target": 0}
{"code": "static ssize_t oz_cdev_write(struct file *filp, const char __user *buf,\n\t\tsize_t count, loff_t *fpos)\n{\n\tstruct oz_pd *pd;\n\tstruct oz_elt_buf *eb;\n\tstruct oz_elt_info *ei;\n\tstruct oz_elt *elt;\n\tstruct oz_app_hdr *app_hdr;\n\tstruct oz_serial_ctx *ctx;\n\tif (count > sizeof(ei->data) - sizeof(*elt) - sizeof(*app_hdr))\n\t\treturn -EINVAL;\n\tspin_lock_bh(&g_cdev.lock);\n\tpd = g_cdev.active_pd;\n\tif (pd)\n\t\toz_pd_get(pd);\n\tspin_unlock_bh(&g_cdev.lock);\n\tif (pd == NULL)\n\t\treturn -ENXIO;\n\tif (!(pd->state & OZ_PD_S_CONNECTED))\n\t\treturn -EAGAIN;\n\teb = &pd->elt_buff;\n\tei = oz_elt_info_alloc(eb);\n\tif (ei == NULL) {\n\t\tcount = 0;\n\t\tgoto out;\n\t}\n\telt = (struct oz_elt *)ei->data;\n\tapp_hdr = (struct oz_app_hdr *)(elt+1);\n\telt->length = sizeof(struct oz_app_hdr) + count;\n\telt->type = OZ_ELT_APP_DATA;\n\tei->app_id = OZ_APPID_SERIAL;\n\tei->length = elt->length + sizeof(struct oz_elt);\n\tapp_hdr->app_id = OZ_APPID_SERIAL;\n\tif (copy_from_user(app_hdr+1, buf, count))\n\t\tgoto out;\n\tspin_lock_bh(&pd->app_lock[OZ_APPID_USB-1]);\n\tctx = (struct oz_serial_ctx *)pd->app_ctx[OZ_APPID_SERIAL-1];\n\tif (ctx) {\n\t\tapp_hdr->elt_seq_num = ctx->tx_seq_num++;\n\t\tif (ctx->tx_seq_num == 0)\n\t\t\tctx->tx_seq_num = 1;\n\t\tspin_lock(&eb->lock);\n\t\tif (oz_queue_elt_info(eb, 0, 0, ei) == 0)\n\t\t\tei = NULL;\n\t\tspin_unlock(&eb->lock);\n\t}\n\tspin_unlock_bh(&pd->app_lock[OZ_APPID_USB-1]);\nout:\n\tif (ei) {\n\t\tcount = 0;\n\t\tspin_lock_bh(&eb->lock);\n\t\toz_elt_info_free(eb, ei);\n\t\tspin_unlock_bh(&eb->lock);\n\t}\n\toz_pd_put(pd);\n\treturn count;\n}", "target": 0}
{"code": "void LibRaw::remove_caseSubstr(char *string, char *subStr) \n{\n  char *found;\n  while ((found = strcasestr(string,subStr))) {\n    if (!found) return;\n    int fill_len = strlen(subStr);\n    int p = found - string;\n    for (int i=p; i<p+fill_len; i++) {\n      string[i] = 32;\n    }\n  }\n  trimSpaces (string);\n}", "target": 0}
{"code": "static int scantag(const char* in, char* buffer, int* lenp) {\n    int len;\n    for (len = 0; len < 128; len++) {\n        const char c = *in++;\n        switch (c) {\n        case '\\0':\n            return 0;\n        case '<':\n            return 0;\n        case '>':\n            buffer[len] = '\\0';\n            *lenp = len+1;\n            return 1;\n        default:\n            break;\n        }\n        buffer[len] = c;\n    }\n    return 0;\n}", "target": 0}
{"code": "static void dbEvalSetColumn(DbEvalContext *p, int iCol, Jsi_DString *dStr) {\n    Jsi_Interp *interp = p->jdb->interp;\n    char nbuf[200];\n    sqlite3_stmt *pStmt = p->pPreStmt->pStmt;\n    switch( sqlite3_column_type(pStmt, iCol) ) {\n    case SQLITE_BLOB: {\n        int bytes = sqlite3_column_bytes(pStmt, iCol);\n        const char *zBlob = (char*)sqlite3_column_blob(pStmt, iCol);\n        if( !zBlob ) {\n            return;\n        }\n        Jsi_DSAppendLen(dStr, zBlob, bytes);\n        return;\n    }\n    case SQLITE_INTEGER: {\n        sqlite_int64 v = sqlite3_column_int64(pStmt, iCol);\n        if (v==0 || v==1) {\n            const char *dectyp = sqlite3_column_decltype(pStmt, iCol);\n            if (dectyp && !Jsi_Strncasecmp(dectyp,\"bool\", 4)) {\n                Jsi_DSAppend(dStr, (v?\"true\":\"false\"), NULL);\n                return;\n            }\n        }\n#ifdef __WIN32\n        snprintf(nbuf, sizeof(nbuf), \"%\" PRId64, (Jsi_Wide)v);\n#else\n        snprintf(nbuf, sizeof(nbuf), \"%lld\", v);\n#endif\n        Jsi_DSAppend(dStr, nbuf, NULL);\n        return;\n    }\n    case SQLITE_FLOAT: {\n        Jsi_NumberToString(interp, sqlite3_column_double(pStmt, iCol), nbuf, sizeof(nbuf));\n        Jsi_DSAppend(dStr, nbuf, NULL);\n        return;\n    }\n    case SQLITE_NULL: {\n        return;\n    }\n    }\n    const char *str = (char*)sqlite3_column_text(pStmt, iCol );\n    if (!str)\n        str = p->jdb->optPtr->nullvalue;\n    Jsi_DSAppend(dStr, str?str:\"\", NULL);\n}", "target": 1}
{"code": "date_s_new_bang(int argc, VALUE *argv, VALUE klass)\n{\n    VALUE ajd, of, sg, nth, sf;\n    int jd, df, rof;\n    double rsg;\n    rb_scan_args(argc, argv, \"03\", &ajd, &of, &sg);\n    switch (argc) {\n      case 0:\n\tajd = INT2FIX(0);\n      case 1:\n\tof = INT2FIX(0);\n      case 2:\n\tsg = INT2FIX(DEFAULT_SG);\n    }\n    old_to_new(ajd, of, sg,\n\t       &nth, &jd, &df, &sf, &rof, &rsg);\n    if (!df && f_zero_p(sf) && !rof)\n\treturn d_simple_new_internal(klass,\n\t\t\t\t     nth, jd,\n\t\t\t\t     rsg,\n\t\t\t\t     0, 0, 0,\n\t\t\t\t     HAVE_JD);\n    else\n\treturn d_complex_new_internal(klass,\n\t\t\t\t      nth, jd,\n\t\t\t\t      df, sf,\n\t\t\t\t      rof, rsg,\n\t\t\t\t      0, 0, 0,\n\t\t\t\t      0, 0, 0,\n\t\t\t\t      HAVE_JD | HAVE_DF);\n}", "target": 0}
{"code": "static int efi_capsule_flush(struct file *file, fl_owner_t id)\n{\n\tint ret = 0;\n\tstruct capsule_info *cap_info = file->private_data;\n\tif (cap_info->index > 0) {\n\t\tpr_err(\"capsule upload not complete\\n\");\n\t\tefi_free_all_buff_pages(cap_info);\n\t\tret = -ECANCELED;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static int xfrm_dump_policy(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];\n\tstruct xfrm_dump_info info;\n\tBUILD_BUG_ON(sizeof(struct xfrm_policy_walk) >\n\t\t     sizeof(cb->args) - sizeof(cb->args[0]));\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\tif (!cb->args[0]) {\n\t\tcb->args[0] = 1;\n\t\txfrm_policy_walk_init(walk, XFRM_POLICY_TYPE_ANY);\n\t}\n\t(void) xfrm_policy_walk(net, walk, dump_one_policy, &info);\n\treturn skb->len;\n}", "target": 1}
{"code": "void RenderView::OnFindReplyAck() {\n  if (queued_find_reply_message_.get()) {\n    Send(queued_find_reply_message_.release());\n  }\n}", "target": 0}
{"code": "int expand_downwards(struct vm_area_struct *vma,\n\t\t\t\t   unsigned long address)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct vm_area_struct *prev;\n\tint error;\n\taddress &= PAGE_MASK;\n\terror = security_mmap_addr(address);\n\tif (error)\n\t\treturn error;\n\tprev = vma->vm_prev;\n\tif (prev && !(prev->vm_flags & VM_GROWSDOWN) &&\n\t\t\t(prev->vm_flags & (VM_WRITE|VM_READ|VM_EXEC))) {\n\t\tif (address - prev->vm_end < stack_guard_gap)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\treturn -ENOMEM;\n\tanon_vma_lock_write(vma->anon_vma);\n\tif (address < vma->vm_start) {\n\t\tunsigned long size, grow;\n\t\tsize = vma->vm_end - address;\n\t\tgrow = (vma->vm_start - address) >> PAGE_SHIFT;\n\t\terror = -ENOMEM;\n\t\tif (grow <= vma->vm_pgoff) {\n\t\t\terror = acct_stack_growth(vma, size, grow);\n\t\t\tif (!error) {\n\t\t\t\tspin_lock(&mm->page_table_lock);\n\t\t\t\tif (vma->vm_flags & VM_LOCKED)\n\t\t\t\t\tmm->locked_vm += grow;\n\t\t\t\tvm_stat_account(mm, vma->vm_flags, grow);\n\t\t\t\tanon_vma_interval_tree_pre_update_vma(vma);\n\t\t\t\tvma->vm_start = address;\n\t\t\t\tvma->vm_pgoff -= grow;\n\t\t\t\tanon_vma_interval_tree_post_update_vma(vma);\n\t\t\t\tvma_gap_update(vma);\n\t\t\t\tspin_unlock(&mm->page_table_lock);\n\t\t\t\tperf_event_mmap(vma);\n\t\t\t}\n\t\t}\n\t}\n\tanon_vma_unlock_write(vma->anon_vma);\n\tkhugepaged_enter_vma_merge(vma, vma->vm_flags);\n\tvalidate_mm(mm);\n\treturn error;\n}", "target": 1}
{"code": "s_free(STREAM s)\n{\n\tfree(s->data);\n\tfree(s);\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, OrWithExactAndInexact3) {\n    addIndex(BSON(\"a\" << 1));\n    addIndex(BSON(\"b\" << 1));\n    runQuery(\n        fromjson(\"{$or: [{a: {$in: [/z/, /x/]}}, {a: 'w'},\"\n                 \"{b: {$exists: false}}, {b: {$in: ['p']}}]}\"));\n    assertNumSolutions(2U);\n    assertSolutionExists(\"{cscan: {dir: 1}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: null, node: {or: {nodes: [\"\n        \"{ixscan: {filter: {$or:[{a:{$in:[/z/, /x/]}}, {a:'w'}]}, \"\n        \"pattern: {a: 1}}}, \"\n        \"{fetch: {filter: {$or:[{b:{$exists:false}}, {b:{$eq:'p'}}]},\"\n        \"node: {ixscan: {filter: null, pattern: {b: 1}}}}}]}}}}\");\n}", "target": 0}
{"code": "DROGON_TEST(HttpFile)\n{\n    SUBSECTION(Save)\n    {\n        HttpFileImpl file;\n        file.setFileName(\"test_file_name\");\n        file.setFile(\"test\", 4);\n        auto out = file.save(\"./test_uploads_dir\");\n        CHECK(out == 0);\n        CHECK(filesystem::exists(\"./test_uploads_dir/test_file_name\"));\n        filesystem::remove_all(\"./test_uploads_dir\");\n    }\n    SUBSECTION(SavePathRelativeTraversal)\n    {\n        auto uploadPath = filesystem::current_path() / \"test_uploads_dir\";\n        HttpFileImpl file;\n        file.setFileName(\"../test_malicious_file_name\");\n        file.setFile(\"test\", 4);\n        auto out = file.save(uploadPath.string());\n        CHECK(out == -1);\n        CHECK(!filesystem::exists(uploadPath / \"../test_malicious_file_name\"));\n        filesystem::remove_all(uploadPath);\n        filesystem::remove(uploadPath / \"../test_malicious_file_name\");\n    }\n    SUBSECTION(SavePathAbsoluteTraversal)\n    {\n        HttpFileImpl file;\n        file.setFileName(\"/tmp/test_malicious_file_name\");\n        file.setFile(\"test\", 4);\n        auto out = file.save(\"./test_uploads_dir\");\n        CHECK(out == -1);\n        CHECK(!filesystem::exists(\"/tmp/test_malicious_file_name\"));\n        filesystem::remove_all(\"test_uploads_dir\");\n        filesystem::remove_all(\"/tmp/test_malicious_file_name\");\n    }\n}", "target": 0}
{"code": "static int rename_in_ns(int pid, char *oldname, char **newnamep)\n{\n\tint fd = -1, ofd = -1, ret, ifindex = -1;\n\tbool grab_newname = false;\n\tofd = lxc_preserve_ns(getpid(), \"net\");\n\tif (ofd < 0) {\n\t\tfprintf(stderr, \"Failed opening network namespace path for '%d'.\", getpid());\n\t\treturn -1;\n\t}\n\tfd = lxc_preserve_ns(pid, \"net\");\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Failed opening network namespace path for '%d'.\", pid);\n\t\treturn -1;\n\t}\n\tif (setns(fd, 0) < 0) {\n\t\tfprintf(stderr, \"setns to container network namespace\\n\");\n\t\tgoto out_err;\n\t}\n\tclose(fd); fd = -1;\n\tif (!*newnamep) {\n\t\tgrab_newname = true;\n\t\t*newnamep = VETH_DEF_NAME;\n\t\tif (!(ifindex = if_nametoindex(oldname))) {\n\t\t\tfprintf(stderr, \"failed to get netdev index\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\tif ((ret = lxc_netdev_rename_by_name(oldname, *newnamep)) < 0) {\n\t\tfprintf(stderr, \"Error %d renaming netdev %s to %s in container\\n\", ret, oldname, *newnamep);\n\t\tgoto out_err;\n\t}\n\tif (grab_newname) {\n\t\tchar ifname[IFNAMSIZ], *namep = ifname;\n\t\tif (!if_indextoname(ifindex, namep)) {\n\t\t\tfprintf(stderr, \"Failed to get new netdev name\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t\t*newnamep = strdup(namep);\n\t\tif (!*newnamep)\n\t\t\tgoto out_err;\n\t}\n\tif (setns(ofd, 0) < 0) {\n\t\tfprintf(stderr, \"Error returning to original netns\\n\");\n\t\tclose(ofd);\n\t\treturn -1;\n\t}\n\tclose(ofd);\n\treturn 0;\nout_err:\n\tif (ofd >= 0)\n\t\tclose(ofd);\n\tif (setns(ofd, 0) < 0)\n\t\tfprintf(stderr, \"Error returning to original network namespace\\n\");\n\tif (fd >= 0)\n\t\tclose(fd);\n\treturn -1;\n}", "target": 1}
{"code": "static int db_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_run *kvm_run = svm->vcpu.run;\n\tif (!(svm->vcpu.guest_debug &\n\t      (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) &&\n\t\t!svm->nmi_singlestep) {\n\t\tkvm_queue_exception(&svm->vcpu, DB_VECTOR);\n\t\treturn 1;\n\t}\n\tif (svm->nmi_singlestep) {\n\t\tsvm->nmi_singlestep = false;\n\t\tif (!(svm->vcpu.guest_debug & KVM_GUESTDBG_SINGLESTEP))\n\t\t\tsvm->vmcb->save.rflags &=\n\t\t\t\t~(X86_EFLAGS_TF | X86_EFLAGS_RF);\n\t\tupdate_db_bp_intercept(&svm->vcpu);\n\t}\n\tif (svm->vcpu.guest_debug &\n\t    (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) {\n\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\tkvm_run->debug.arch.pc =\n\t\t\tsvm->vmcb->save.cs.base + svm->vmcb->save.rip;\n\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\tkey_ref = lookup_user_key(keyid, 0, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n\tkey = key_ref_to_ptr(key_ref);\n\tret = key_permission(key_ref, KEY_NEED_READ);\n\tif (ret == 0)\n\t\tgoto can_read_key;\n\tif (ret != -EACCES)\n\t\tgoto error;\n\tif (!is_key_possessed(key_ref)) {\n\t\tret = -EACCES;\n\t\tgoto error2;\n\t}\ncan_read_key:\n\tret = key_validate(key);\n\tif (ret == 0) {\n\t\tret = -EOPNOTSUPP;\n\t\tif (key->type->read) {\n\t\t\tdown_read(&key->sem);\n\t\t\tret = key->type->read(key, buffer, buflen);\n\t\t\tup_read(&key->sem);\n\t\t}\n\t}\nerror2:\n\tkey_put(key);\nerror:\n\treturn ret;\n}", "target": 1}
{"code": "static bool malidp_check_pages_threshold(struct malidp_plane_state *ms,\n\t\t\t\t\t u32 pgsize)\n{\n\tint i;\n\tfor (i = 0; i < ms->n_planes; i++) {\n\t\tstruct drm_gem_object *obj;\n\t\tstruct drm_gem_cma_object *cma_obj;\n\t\tstruct sg_table *sgt;\n\t\tstruct scatterlist *sgl;\n\t\tobj = drm_gem_fb_get_obj(ms->base.fb, i);\n\t\tcma_obj = to_drm_gem_cma_obj(obj);\n\t\tif (cma_obj->sgt)\n\t\t\tsgt = cma_obj->sgt;\n\t\telse\n\t\t\tsgt = obj->funcs->get_sg_table(obj);\n\t\tif (!sgt)\n\t\t\treturn false;\n\t\tsgl = sgt->sgl;\n\t\twhile (sgl) {\n\t\t\tif (sgl->length < pgsize) {\n\t\t\t\tif (!cma_obj->sgt)\n\t\t\t\t\tkfree(sgt);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tsgl = sg_next(sgl);\n\t\t}\n\t\tif (!cma_obj->sgt)\n\t\t\tkfree(sgt);\n\t}\n\treturn true;\n}", "target": 1}
{"code": "static void perf_event_interrupt(struct pt_regs *regs)\n{\n\tint i;\n\tstruct cpu_hw_events *cpuhw = &__get_cpu_var(cpu_hw_events);\n\tstruct perf_event *event;\n\tunsigned long val;\n\tint found = 0;\n\tint nmi;\n\tif (cpuhw->n_limited)\n\t\tfreeze_limited_counters(cpuhw, mfspr(SPRN_PMC5),\n\t\t\t\t\tmfspr(SPRN_PMC6));\n\tperf_read_regs(regs);\n\tnmi = perf_intr_is_nmi(regs);\n\tif (nmi)\n\t\tnmi_enter();\n\telse\n\t\tirq_enter();\n\tfor (i = 0; i < cpuhw->n_events; ++i) {\n\t\tevent = cpuhw->event[i];\n\t\tif (!event->hw.idx || is_limited_pmc(event->hw.idx))\n\t\t\tcontinue;\n\t\tval = read_pmc(event->hw.idx);\n\t\tif ((int)val < 0) {\n\t\t\tfound = 1;\n\t\t\trecord_and_restart(event, val, regs, nmi);\n\t\t}\n\t}\n\tif (!found) {\n\t\tfor (i = 0; i < ppmu->n_counter; ++i) {\n\t\t\tif (is_limited_pmc(i + 1))\n\t\t\t\tcontinue;\n\t\t\tval = read_pmc(i + 1);\n\t\t\tif ((int)val < 0)\n\t\t\t\twrite_pmc(i + 1, 0);\n\t\t}\n\t}\n\twrite_mmcr0(cpuhw, cpuhw->mmcr[0]);\n\tif (nmi)\n\t\tnmi_exit();\n\telse\n\t\tirq_exit();\n}", "target": 1}
{"code": "int bind_ports(void) {\n    SERVICE_OPTIONS *opt;\n    int listening_section;\n#ifdef USE_LIBWRAP\n    libwrap_init();\n#endif \n    s_poll_init(fds, 1);\n    for(opt=service_options.next; opt; opt=opt->next) {\n        unsigned i;\n        for(i=0; i<opt->local_addr.num; ++i)\n            opt->local_fd[i]=INVALID_SOCKET;\n    }\n    listening_section=0;\n    for(opt=service_options.next; opt; opt=opt->next) {\n        opt->bound_ports=0;\n        if(opt->local_addr.num) { \n            unsigned i;\n            s_log(LOG_DEBUG, \"Binding service [%s]\", opt->servname);\n            for(i=0; i<opt->local_addr.num; ++i) {\n                SOCKET fd;\n                fd=bind_port(opt, listening_section, i);\n                opt->local_fd[i]=fd;\n                if(fd!=INVALID_SOCKET) {\n                    s_poll_add(fds, fd, 1, 0);\n                    ++opt->bound_ports;\n                }\n            }\n            if(!opt->bound_ports) {\n                s_log(LOG_ERR, \"Binding service [%s] failed\", opt->servname);\n                return 1;\n            }\n            ++listening_section;\n        } else if(opt->exec_name && opt->connect_addr.names) {\n            s_log(LOG_DEBUG, \"Skipped exec+connect service [%s]\", opt->servname);\n#ifndef OPENSSL_NO_TLSEXT\n        } else if(!opt->option.client && opt->sni) {\n            s_log(LOG_DEBUG, \"Skipped SNI slave service [%s]\", opt->servname);\n#endif\n        } else { \n            s_log(LOG_ERR, \"Invalid service [%s]\", opt->servname);\n            return 1;\n        }\n    }\n    if(listening_section<systemd_fds) {\n        s_log(LOG_ERR,\n            \"Too many listening file descriptors received from systemd, got %d\",\n            systemd_fds);\n        return 1;\n    }\n    return 0; \n}", "target": 1}
{"code": "static int save_dev(blkid_dev dev, FILE *file)\n{\n\tstruct list_head *p;\n\tif (!dev || dev->bid_name[0] != '/')\n\t\treturn 0;\n\tDBG(SAVE, ul_debug(\"device %s, type %s\", dev->bid_name, dev->bid_type ?\n\t\t   dev->bid_type : \"(null)\"));\n\tfprintf(file, \"<device DEVNO=\\\"0x%04lx\\\" TIME=\\\"%ld.%ld\\\"\",\n\t\t\t(unsigned long) dev->bid_devno,\n\t\t\t(long) dev->bid_time,\n\t\t\t(long) dev->bid_utime);\n\tif (dev->bid_pri)\n\t\tfprintf(file, \" PRI=\\\"%d\\\"\", dev->bid_pri);\n\tlist_for_each(p, &dev->bid_tags) {\n\t\tblkid_tag tag = list_entry(p, struct blkid_struct_tag, bit_tags);\n\t\tfprintf(file, \" %s=\\\"%s\\\"\", tag->bit_name,tag->bit_val);\n\t}\n\tfprintf(file, \">%s</device>\\n\", dev->bid_name);\n\treturn 0;\n}", "target": 1}
{"code": "gen8_emit_flush_coherentl3_wa(struct intel_engine_cs *engine, u32 *batch)\n{\n\t*batch++ = MI_STORE_REGISTER_MEM_GEN8 | MI_SRM_LRM_GLOBAL_GTT;\n\t*batch++ = i915_mmio_reg_offset(GEN8_L3SQCREG4);\n\t*batch++ = intel_gt_scratch_offset(engine->gt,\n\t\t\t\t\t   INTEL_GT_SCRATCH_FIELD_COHERENTL3_WA);\n\t*batch++ = 0;\n\t*batch++ = MI_LOAD_REGISTER_IMM(1);\n\t*batch++ = i915_mmio_reg_offset(GEN8_L3SQCREG4);\n\t*batch++ = 0x40400000 | GEN8_LQSC_FLUSH_COHERENT_LINES;\n\tbatch = gen8_emit_pipe_control(batch,\n\t\t\t\t       PIPE_CONTROL_CS_STALL |\n\t\t\t\t       PIPE_CONTROL_DC_FLUSH_ENABLE,\n\t\t\t\t       0);\n\t*batch++ = MI_LOAD_REGISTER_MEM_GEN8 | MI_SRM_LRM_GLOBAL_GTT;\n\t*batch++ = i915_mmio_reg_offset(GEN8_L3SQCREG4);\n\t*batch++ = intel_gt_scratch_offset(engine->gt,\n\t\t\t\t\t   INTEL_GT_SCRATCH_FIELD_COHERENTL3_WA);\n\t*batch++ = 0;\n\treturn batch;\n}", "target": 0}
{"code": "static int atalk_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n\t\t\t size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_at *sat = (struct sockaddr_at *)msg->msg_name;\n\tstruct ddpehdr *ddp;\n\tint copied = 0;\n\tint offset = 0;\n\tint err = 0;\n\tstruct sk_buff *skb;\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\t\t\tflags & MSG_DONTWAIT, &err);\n\tlock_sock(sk);\n\tif (!skb)\n\t\tgoto out;\n\tddp = ddp_hdr(skb);\n\tcopied = ntohs(ddp->deh_len_hops) & 1023;\n\tif (sk->sk_type != SOCK_RAW) {\n\t\toffset = sizeof(*ddp);\n\t\tcopied -= offset;\n\t}\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\terr = skb_copy_datagram_iovec(skb, offset, msg->msg_iov, copied);\n\tif (!err) {\n\t\tif (sat) {\n\t\t\tsat->sat_family      = AF_APPLETALK;\n\t\t\tsat->sat_port        = ddp->deh_sport;\n\t\t\tsat->sat_addr.s_node = ddp->deh_snode;\n\t\t\tsat->sat_addr.s_net  = ddp->deh_snet;\n\t\t}\n\t\tmsg->msg_namelen = sizeof(*sat);\n\t}\n\tskb_free_datagram(sk, skb);\t\nout:\n\trelease_sock(sk);\n\treturn err ? : copied;\n}", "target": 1}
{"code": "void FormatConverter<T>::Populate(const T* src_data, std::vector<int> indices,\n                                  int level, int prev_idx, int* src_data_ptr,\n                                  T* dest_data) {\n  if (level == indices.size()) {\n    int orig_rank = dense_shape_.size();\n    std::vector<int> orig_idx;\n    orig_idx.resize(orig_rank);\n    int i = 0;\n    for (; i < orig_idx.size(); i++) {\n      int orig_dim = traversal_order_[i];\n      orig_idx[orig_dim] = indices[i];\n    }\n    for (; i < indices.size(); i++) {\n      const int block_idx = traversal_order_[i] - orig_rank;\n      const int orig_dim = block_map_[block_idx];\n      orig_idx[orig_dim] =\n          orig_idx[orig_dim] * block_size_[block_idx] + indices[i];\n    }\n    dest_data[GetFlattenedIndex(orig_idx, dense_shape_)] =\n        src_data[*src_data_ptr];\n    *src_data_ptr = *src_data_ptr + 1;\n    return;\n  }\n  const int metadata_idx = 2 * level;\n  const int shape_of_level = dim_metadata_[metadata_idx][0];\n  if (format_[level] == kTfLiteDimDense) {\n    for (int i = 0; i < shape_of_level; i++) {\n      indices[level] = i;\n      Populate(src_data, indices, level + 1, prev_idx * shape_of_level + i,\n               src_data_ptr, dest_data);\n    }\n  } else {\n    const auto& array_segments = dim_metadata_[metadata_idx];\n    const auto& array_indices = dim_metadata_[metadata_idx + 1];\n    for (int i = array_segments[prev_idx]; i < array_segments[prev_idx + 1];\n         i++) {\n      indices[level] = array_indices[i];\n      Populate(src_data, indices, level + 1, i, src_data_ptr, dest_data);\n    }\n  }\n}", "target": 1}
{"code": "bool DecodeResourceHandleList(std::unique_ptr<port::StringListDecoder> d,\n                              ResourceHandle* ps, int64_t n) {\n  std::vector<uint32> sizes(n);\n  if (!d->ReadSizes(&sizes)) return false;\n  ResourceHandleProto proto;\n  for (int i = 0; i < n; ++i) {\n    if (!proto.ParseFromArray(d->Data(sizes[i]), sizes[i])) {\n      return false;\n    }\n    ps[i].FromProto(proto);\n  }\n  return true;\n}", "target": 1}
{"code": "ServerApp::help()\n{\n#if WINAPI_XWINDOWS\n#  define WINAPI_ARGS \\\n    \" [--display <display>] [--no-xinitthreads]\"\n#  define WINAPI_INFO \\\n    \"      --display <display>  connect to the X server at <display>\\n\" \\\n    \"      --no-xinitthreads    do not call XInitThreads()\\n\" \\\n    \"      --screen-change-script <path>\\n\" \\\n    \"                           full path to script to run on screen change\\n\" \\\n    \"                           first argument is the new screen name\\n\"\n#else\n#  define WINAPI_ARGS \"\"\n#  define WINAPI_INFO \"\"\n#endif\n    barrier::fs::path profile_path = argsBase().m_profileDirectory;\n    if (profile_path.empty()) {\n        profile_path = barrier::DataDirectories::profile();\n    }\n    auto usr_config_path = (profile_path / barrier::fs::u8path(USR_CONFIG_NAME)).u8string();\n    auto sys_config_path = (barrier::DataDirectories::systemconfig() /\n                            barrier::fs::u8path(SYS_CONFIG_NAME)).u8string();\n    std::ostringstream buffer;\n    buffer << \"Start the barrier server component.\\n\"\n           << \"\\n\"\n           << \"Usage: \" << args().m_exename\n           << \" [--address <address>]\"\n           << \" [--config <pathname>]\"\n           << WINAPI_ARGS << HELP_SYS_ARGS << HELP_COMMON_ARGS << \"\\n\"\n           << \"\\n\"\n           << \"Options:\\n\"\n           << \"  -a, --address <address>  listen for clients on the given address.\\n\"\n           << \"  -c, --config <pathname>  use the named configuration file instead.\\n\"\n           << HELP_COMMON_INFO_1 << WINAPI_INFO << HELP_SYS_INFO << HELP_COMMON_INFO_2 << \"\\n\"\n           << \"Default options are marked with a *\\n\"\n           << \"\\n\"\n           << \"The argument for --address is of the form: [<hostname>][:<port>].  The\\n\"\n           << \"hostname must be the address or hostname of an interface on the system.\\n\"\n           << \"Placing brackets around an IPv6 address is required when also specifying \\n\"\n           << \"a port number and optional otherwise. The default is to listen on all\\n\"\n           << \"interfaces using port number \" << kDefaultPort << \".\\n\"\n           << \"\\n\"\n           << \"If no configuration file pathname is provided then the first of the\\n\"\n           << \"following to load successfully sets the configuration:\\n\"\n           << \"  \" << usr_config_path << \"\\n\"\n           << \"  \" << sys_config_path << \"\\n\";\n    LOG((CLOG_PRINT \"%s\", buffer.str().c_str()));\n}", "target": 1}
{"code": "bool SpeechSynthesis::speaking() const\n{\n    return currentSpeechUtterance();\n}", "target": 0}
{"code": "static int uas_use_uas_driver(struct usb_interface *intf,\n\t\t\t      const struct usb_device_id *id,\n\t\t\t      unsigned long *flags_ret)\n{\n\tstruct usb_host_endpoint *eps[4] = { };\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\tunsigned long flags = id->driver_info;\n\tint r, alt;\n\talt = uas_find_uas_alt_setting(intf);\n\tif (alt < 0)\n\t\treturn 0;\n\tr = uas_find_endpoints(&intf->altsetting[alt], eps);\n\tif (r < 0)\n\t\treturn 0;\n\tif (le16_to_cpu(udev->descriptor.idVendor) == 0x174c &&\n\t\t\t(le16_to_cpu(udev->descriptor.idProduct) == 0x5106 ||\n\t\t\t le16_to_cpu(udev->descriptor.idProduct) == 0x55aa)) {\n\t\tif (udev->actconfig->desc.bMaxPower == 0) {\n\t\t} else if (udev->speed < USB_SPEED_SUPER) {\n\t\t\tflags |= US_FL_IGNORE_UAS;\n\t\t} else if (usb_ss_max_streams(&eps[1]->ss_ep_comp) == 32) {\n\t\t\tflags |= US_FL_IGNORE_UAS;\n\t\t} else {\n\t\t\tflags |= US_FL_MAX_SECTORS_240;\n\t\t}\n\t}\n\tusb_stor_adjust_quirks(udev, &flags);\n\tif (flags & US_FL_IGNORE_UAS) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\"UAS is blacklisted for this device, using usb-storage instead\\n\");\n\t\treturn 0;\n\t}\n\tif (udev->bus->sg_tablesize == 0) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\"The driver for the USB controller %s does not support scatter-gather which is\\n\",\n\t\t\thcd->driver->description);\n\t\tdev_warn(&udev->dev,\n\t\t\t\"required by the UAS driver. Please try an other USB controller if you wish to use UAS.\\n\");\n\t\treturn 0;\n\t}\n\tif (udev->speed >= USB_SPEED_SUPER && !hcd->can_do_streams) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\"USB controller %s does not support streams, which are required by the UAS driver.\\n\",\n\t\t\thcd_to_bus(hcd)->bus_name);\n\t\tdev_warn(&udev->dev,\n\t\t\t\"Please try an other USB controller if you wish to use UAS.\\n\");\n\t\treturn 0;\n\t}\n\tif (flags_ret)\n\t\t*flags_ret = flags;\n\treturn 1;\n}", "target": 1}
{"code": "void perf_bp_event(struct perf_event *bp, void *data)\n{\n\tstruct perf_sample_data sample;\n\tstruct pt_regs *regs = data;\n\tperf_sample_data_init(&sample, bp->attr.bp_addr, 0);\n\tif (!bp->hw.state && !perf_exclude_event(bp, regs))\n\t\tperf_swevent_event(bp, 1, &sample, regs);\n}", "target": 0}
{"code": "int RECORD_LAYER_data_present(const RECORD_LAYER *rl)\n{\n    if (rl->rstate == SSL_ST_READ_BODY)\n        return 1;\n    if (RECORD_LAYER_processed_read_pending(rl))\n        return 1;\n    return 0;\n}", "target": 0}
{"code": "void PDFiumEngine::Form_DoGoToAction(FPDF_FORMFILLINFO* param,\n                                     int page_index,\n                                     int zoom_mode,\n                                     float* position_array,\n                                     int size_of_array) {\n  PDFiumEngine* engine = static_cast<PDFiumEngine*>(param);\n  engine->ScrollToPage(page_index);\n}", "target": 0}
{"code": "int http_connect(int sockfd, const char *host, int port, AyProxyData *proxy)\n{\n\tchar cmd[512];\n\tchar *inputline = NULL;\n\tchar *proxy_auth = NULL;\n\tchar debug_buff[512];\n\tint remaining = sizeof(cmd) - 1;\n\tremaining -= snprintf(cmd, sizeof(cmd), \"CONNECT %s:%d HTTP/1.1\\r\\n\", host, port);\n\tif (proxy->username && proxy->username[0]) {\n\t\tproxy_auth = encode_proxy_auth_str(proxy);\n\t\tstrncat(cmd, \"Proxy-Authorization: Basic \", remaining);\n\t\tremaining -= 27;\n\t\tstrncat(cmd, proxy_auth, remaining);\n\t\tremaining -= strlen(proxy_auth);\n\t\tstrncat(cmd, \"\\r\\n\", remaining);\n\t\tremaining -= 2;\n\t}\n\tstrncat(cmd, \"\\r\\n\", remaining);\n#ifndef DEBUG\n\tsnprintf(debug_buff, sizeof(debug_buff), \"<%s>\\n\", cmd);\n\tdebug_print(debug_buff);\n#endif\n\tif (send(sockfd, cmd, strlen(cmd), 0) < 0)\n\t\treturn AY_CONNECTION_REFUSED;\n\tif (ay_recv_line(sockfd, &inputline) < 0)\n\t\treturn AY_CONNECTION_REFUSED;\n#ifndef DEBUG\n\tsnprintf(debug_buff, sizeof(debug_buff), \"<%s>\\n\", inputline);\n\tdebug_print(debug_buff);\n#endif\n\tif (!strstr(inputline, \"200\")) {\n\t\tif (strstr(inputline, \"407\")) {\n\t\t\twhile (ay_recv_line(sockfd, &inputline) > 0) {\n\t\t\t\tfree(inputline);\n\t\t\t}\n\t\t\treturn AY_PROXY_AUTH_REQUIRED;\n\t\t}\n\t\tif (strstr(inputline, \"403\")) {\n\t\t\twhile (ay_recv_line(sockfd, &inputline) > 0) {\n\t\t\t\tfree(inputline);\n\t\t\t}\n\t\t\treturn AY_PROXY_PERMISSION_DENIED;\n\t\t}\n\t\tfree(inputline);\n\t\treturn AY_CONNECTION_REFUSED;\n\t}\n\twhile (strlen(inputline) > 1) {\n\t\tfree(inputline);\n\t\tif (ay_recv_line(sockfd, &inputline) < 0) {\n\t\t\treturn AY_CONNECTION_REFUSED;\n\t\t}\n#ifndef DEBUG\n\t\tsnprintf(debug_buff, sizeof(debug_buff), \"<%s>\\n\", inputline);\n\t\tdebug_print(debug_buff);\n#endif\n\t}\n\tfree(inputline);\n\tg_free(proxy_auth);\n\treturn 0;\n}", "target": 1}
{"code": "void set_numabalancing_state(bool enabled)\n{\n\tif (enabled)\n\t\tstatic_branch_enable(&sched_numa_balancing);\n\telse\n\t\tstatic_branch_disable(&sched_numa_balancing);\n}", "target": 0}
{"code": "static ext3_fsblk_t get_sb_block(void **data, struct super_block *sb)\n{\n\text3_fsblk_t\tsb_block;\n\tchar\t\t*options = (char *) *data;\n\tif (!options || strncmp(options, \"sb=\", 3) != 0)\n\t\treturn 1;\t\n\toptions += 3;\n\tsb_block = simple_strtoul(options, &options, 0);\n\tif (*options && *options != ',') {\n\t\text3_msg(sb, \"error: invalid sb specification: %s\",\n\t\t       (char *) *data);\n\t\treturn 1;\n\t}\n\tif (*options == ',')\n\t\toptions++;\n\t*data = (void *) options;\n\treturn sb_block;\n}", "target": 1}
{"code": "void test_delta_apply__read_after_limit(void)\n{\n\tunsigned char base[16] = { 0 }, delta[] = { 0x10, 0x70, 0xff };\n\tvoid *out;\n\tsize_t outlen;\n\tcl_git_fail(git_delta_apply(&out, &outlen, base, sizeof(base), delta, sizeof(delta)));\n}", "target": 0}
{"code": "const char *luaG_findlocal (lua_State *L, CallInfo *ci, int n, StkId *pos) {\n  StkId base = ci->func + 1;\n  const char *name = NULL;\n  if (isLua(ci)) {\n    if (n < 0)  \n      return findvararg(ci, -n, pos);\n    else\n      name = luaF_getlocalname(ci_func(ci)->p, n, currentpc(ci));\n  }\n  if (name == NULL) {  \n    StkId limit = (ci == L->ci) ? L->top : ci->next->func;\n    if (limit - base >= n && n > 0) {  \n      name = isLua(ci) ? \"(temporary)\" : \"(C temporary)\";\n    }\n    else\n      return NULL;  \n  }\n  if (pos)\n    *pos = base + (n - 1);\n  return name;\n}", "target": 1}
{"code": "ArcMemory::ArcMemory()\n{\n  Loaded=false;\n  SeekPos=0;\n}", "target": 0}
{"code": "static int crypto_report_acomp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_acomp racomp;\n\tstrlcpy(racomp.type, \"acomp\", sizeof(racomp.type));\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_ACOMP,\n\t\t    sizeof(struct crypto_report_acomp), &racomp))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "RenderWidgetHostViewBase* RenderWidgetHostImpl::GetView() const {\n  return view_.get();\n}", "target": 0}
{"code": "static int br_multicast_add_group(struct net_bridge *br,\n\t\t\t\t  struct net_bridge_port *port,\n\t\t\t\t  struct br_ip *group)\n{\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tunsigned long now = jiffies;\n\tint err;\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) ||\n\t    (port && port->state == BR_STATE_DISABLED))\n\t\tgoto out;\n\tmp = br_multicast_new_group(br, port, group);\n\terr = PTR_ERR(mp);\n\tif (IS_ERR(mp))\n\t\tgoto err;\n\tif (!port) {\n\t\thlist_add_head(&mp->mglist, &br->mglist);\n\t\tmod_timer(&mp->timer, now + br->multicast_membership_interval);\n\t\tgoto out;\n\t}\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (p->port == port)\n\t\t\tgoto found;\n\t\tif ((unsigned long)p->port < (unsigned long)port)\n\t\t\tbreak;\n\t}\n\tp = kzalloc(sizeof(*p), GFP_ATOMIC);\n\terr = -ENOMEM;\n\tif (unlikely(!p))\n\t\tgoto err;\n\tp->addr = *group;\n\tp->port = port;\n\tp->next = *pp;\n\thlist_add_head(&p->mglist, &port->mglist);\n\tsetup_timer(&p->timer, br_multicast_port_group_expired,\n\t\t    (unsigned long)p);\n\tsetup_timer(&p->query_timer, br_multicast_port_group_query_expired,\n\t\t    (unsigned long)p);\n\trcu_assign_pointer(*pp, p);\nfound:\n\tmod_timer(&p->timer, now + br->multicast_membership_interval);\nout:\n\terr = 0;\nerr:\n\tspin_unlock(&br->multicast_lock);\n\treturn err;\n}", "target": 1}
{"code": "save_positions (GPtrArray *page_names)\n{\n\tguint i;\n\tGHashTable *ht;\n\tht = g_hash_table_new (g_str_hash, g_str_equal);\n\tfor (i = 0; i < page_names->len; i++)\n\t\tg_hash_table_insert (ht, page_names->pdata[i], GUINT_TO_POINTER(i + 1));\n\treturn ht;\n}", "target": 0}
{"code": "validate_group(struct perf_event *event)\n{\n\tstruct perf_event *sibling, *leader = event->group_leader;\n\tstruct pmu_hw_events fake_pmu;\n\tDECLARE_BITMAP(fake_used_mask, ARMPMU_MAX_HWEVENTS);\n\tmemset(fake_used_mask, 0, sizeof(fake_used_mask));\n\tfake_pmu.used_mask = fake_used_mask;\n\tif (!validate_event(&fake_pmu, leader))\n\t\treturn -EINVAL;\n\tlist_for_each_entry(sibling, &leader->sibling_list, group_entry) {\n\t\tif (!validate_event(&fake_pmu, sibling))\n\t\t\treturn -EINVAL;\n\t}\n\tif (!validate_event(&fake_pmu, event))\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 1}
{"code": "    GopherStateData(FwdState *aFwd) :\n        entry(aFwd->entry),\n        conversion(NORMAL),\n        HTML_header_added(0),\n        HTML_pre(0),\n        type_id(GOPHER_FILE ),\n        overflowed(false),\n        cso_recno(0),\n        len(0),\n        buf(nullptr),\n        fwd(aFwd)\n    {\n        *request = 0;\n        buf = (char *)memAllocate(MEM_4K_BUF);\n        entry->lock(\"gopherState\");\n        *replybuf = 0;\n    }", "target": 1}
{"code": "ssl3_free(SSL *s)\n{\n\tif (s == NULL)\n\t\treturn;\n\ttls1_cleanup_key_block(s);\n\tssl3_release_read_buffer(s);\n\tssl3_release_write_buffer(s);\n\ttls_content_free(s->s3->rcontent);\n\ttls_buffer_free(s->s3->alert_fragment);\n\ttls_buffer_free(s->s3->handshake_fragment);\n\tfreezero(s->s3->hs.sigalgs, s->s3->hs.sigalgs_len);\n\tsk_X509_pop_free(s->s3->hs.peer_certs, X509_free);\n\tsk_X509_pop_free(s->s3->hs.peer_certs_no_leaf, X509_free);\n\ttls_key_share_free(s->s3->hs.key_share);\n\ttls13_secrets_destroy(s->s3->hs.tls13.secrets);\n\tfreezero(s->s3->hs.tls13.cookie, s->s3->hs.tls13.cookie_len);\n\ttls13_clienthello_hash_clear(&s->s3->hs.tls13);\n\ttls_buffer_free(s->s3->hs.tls13.quic_read_buffer);\n\tsk_X509_NAME_pop_free(s->s3->hs.tls12.ca_names, X509_NAME_free);\n\tsk_X509_pop_free(s->verified_chain, X509_free);\n\ts->verified_chain = NULL;\n\ttls1_transcript_free(s);\n\ttls1_transcript_hash_free(s);\n\tfree(s->s3->alpn_selected);\n\tfreezero(s->s3->peer_quic_transport_params,\n\t    s->s3->peer_quic_transport_params_len);\n\tfreezero(s->s3, sizeof(*s->s3));\n\ts->s3 = NULL;\n}", "target": 0}
{"code": "static void bond_setup(struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\trwlock_init(&bond->lock);\n\trwlock_init(&bond->curr_slave_lock);\n\tbond->params = bonding_defaults;\n\tbond->dev = bond_dev;\n\tINIT_LIST_HEAD(&bond->vlan_list);\n\tether_setup(bond_dev);\n\tbond_dev->netdev_ops = &bond_netdev_ops;\n\tbond_dev->ethtool_ops = &bond_ethtool_ops;\n\tbond_set_mode_ops(bond, bond->params.mode);\n\tbond_dev->destructor = bond_destructor;\n\tbond_dev->tx_queue_len = 0;\n\tbond_dev->flags |= IFF_MASTER|IFF_MULTICAST;\n\tbond_dev->priv_flags |= IFF_BONDING;\n\tbond_dev->priv_flags &= ~IFF_XMIT_DST_RELEASE;\n\tbond_dev->features |= NETIF_F_VLAN_CHALLENGED;\n\tbond_dev->features |= NETIF_F_LLTX;\n\tbond_dev->hw_features = BOND_VLAN_FEATURES |\n\t\t\t\tNETIF_F_HW_VLAN_TX |\n\t\t\t\tNETIF_F_HW_VLAN_RX |\n\t\t\t\tNETIF_F_HW_VLAN_FILTER;\n\tbond_dev->hw_features &= ~(NETIF_F_ALL_CSUM & ~NETIF_F_NO_CSUM);\n\tbond_dev->features |= bond_dev->hw_features;\n}", "target": 1}
{"code": "int main()\n{\n\tgdImagePtr im, exp;\n\tint error = 0;\n\tim = gdImageCreate(50, 50);\n\tif (!im) {\n\t\tgdTestErrorMsg(\"gdImageCreate failed.\\n\");\n\t\treturn 1;\n\t}\n\tgdImageCropThreshold(im, 1337, 0);\n\tgdImageDestroy(im);\n\treturn 0;\n}", "target": 0}
{"code": "NOEXPORT char *base64(int encode, const char *in, int len) {\n    BIO *bio, *b64;\n    char *out;\n    int n;\n    b64=BIO_new(BIO_f_base64());\n    if(!b64)\n        return NULL;\n    BIO_set_flags(b64, BIO_FLAGS_BASE64_NO_NL);\n    bio=BIO_new(BIO_s_mem());\n    if(!bio) {\n        str_free(b64);\n        return NULL;\n    }\n    if(encode)\n        bio=BIO_push(b64, bio);\n    BIO_write(bio, in, len);\n    (void)BIO_flush(bio); \n    if(encode) {\n        bio=BIO_pop(bio);\n        BIO_free(b64);\n    } else {\n        bio=BIO_push(b64, bio);\n    }\n    n=BIO_pending(bio);\n    out=str_alloc(n<32?32:(size_t)n+1);\n    n=BIO_read(bio, out, n);\n    if(n<0) {\n        BIO_free_all(bio);\n        str_free(out);\n        return NULL;\n    }\n    BIO_free_all(bio);\n    return out;\n}", "target": 1}
{"code": "R_API RBinJavaAttrInfo *r_bin_java_constant_value_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut64 offset = 6;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\tif (attr) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_CONST_VALUE_ATTR;\n\t\tattr->info.constant_value_attr.constantvalue_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tattr->size = offset;\n\t}\n\treturn attr;\n}", "target": 1}
{"code": "static void kvm_unload_vcpu_mmu(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tr = vcpu_load(vcpu);\n\tBUG_ON(r);\n\tkvm_mmu_unload(vcpu);\n\tvcpu_put(vcpu);\n}", "target": 0}
{"code": "DWORD OmniboxViewWin::EditDropTarget::OnDragOver(IDataObject* data_object,\n                                                 DWORD key_state,\n                                                 POINT cursor_position,\n                                                 DWORD effect) {\n  if (drag_has_url_)\n    return CopyOrLinkDropEffect(effect);\n  if (drag_has_string_) {\n    UpdateDropHighlightPosition(cursor_position);\n    if (edit_->drop_highlight_position() == -1 && edit_->in_drag())\n      return DROPEFFECT_NONE;\n    if (edit_->in_drag()) {\n      DCHECK((effect & DROPEFFECT_COPY) && (effect & DROPEFFECT_MOVE));\n      return (key_state & MK_CONTROL) ? DROPEFFECT_COPY : DROPEFFECT_MOVE;\n    }\n    return CopyOrLinkDropEffect(effect);\n  }\n  return DROPEFFECT_NONE;\n}", "target": 0}
{"code": "void llc_conn_handler(struct llc_sap *sap, struct sk_buff *skb)\n{\n\tstruct llc_addr saddr, daddr;\n\tstruct sock *sk;\n\tllc_pdu_decode_sa(skb, saddr.mac);\n\tllc_pdu_decode_ssap(skb, &saddr.lsap);\n\tllc_pdu_decode_da(skb, daddr.mac);\n\tllc_pdu_decode_dsap(skb, &daddr.lsap);\n\tsk = __llc_lookup(sap, &saddr, &daddr);\n\tif (!sk)\n\t\tgoto drop;\n\tbh_lock_sock(sk);\n\tif (unlikely(sk->sk_state == TCP_LISTEN)) {\n\t\tstruct sock *newsk = llc_create_incoming_sock(sk, skb->dev,\n\t\t\t\t\t\t\t      &saddr, &daddr);\n\t\tif (!newsk)\n\t\t\tgoto drop_unlock;\n\t\tskb_set_owner_r(skb, newsk);\n\t} else {\n\t\tskb_orphan(skb);\n\t\tsock_hold(sk);\n\t\tskb->sk = sk;\n\t\tskb->destructor = sock_efree;\n\t}\n\tif (!sock_owned_by_user(sk))\n\t\tllc_conn_rcv(sk, skb);\n\telse {\n\t\tdprintk(\"%s: adding to backlog...\\n\", __func__);\n\t\tllc_set_backlog_type(skb, LLC_PACKET);\n\t\tif (sk_add_backlog(sk, skb, sk->sk_rcvbuf))\n\t\t\tgoto drop_unlock;\n\t}\nout:\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n\treturn;\ndrop:\n\tkfree_skb(skb);\n\treturn;\ndrop_unlock:\n\tkfree_skb(skb);\n\tgoto out;\n}", "target": 0}
{"code": "static int __mincore_unmapped_range(unsigned long addr, unsigned long end,\n\t\t\t\tstruct vm_area_struct *vma, unsigned char *vec)\n{\n\tunsigned long nr = (end - addr) >> PAGE_SHIFT;\n\tint i;\n\tif (vma->vm_file) {\n\t\tpgoff_t pgoff;\n\t\tpgoff = linear_page_index(vma, addr);\n\t\tfor (i = 0; i < nr; i++, pgoff++)\n\t\t\tvec[i] = mincore_page(vma->vm_file->f_mapping, pgoff);\n\t} else {\n\t\tfor (i = 0; i < nr; i++)\n\t\t\tvec[i] = 0;\n\t}\n\treturn nr;\n}", "target": 1}
{"code": "int ecall_start(struct ecall *ecall, enum icall_call_type call_type,\n\t\tbool audio_cbr)\n{\n\tint err;\n\tinfo(\"ecall(%p): start\\n\", ecall);\n\tif (!ecall)\n\t\treturn EINVAL;\n#ifdef ECALL_CBR_ALWAYS_ON\n\taudio_cbr = true;\n#endif\n\tif (ecall->econn) {\n\t\tif (ECONN_PENDING_INCOMING == econn_current_state(ecall->econn)) {\n\t\t\treturn ecall_answer(ecall, call_type, audio_cbr);\n\t\t}\n\t\telse {\n\t\t\twarning(\"ecall: start: already in progress (econn=%s)\\n\",\n\t\t\t\teconn_state_name(econn_current_state(ecall->econn)));\n\t\t\treturn EALREADY;\n\t\t}\n\t}\n#if 0\n\tif (ecall->turnc == 0) {\n\t\twarning(\"ecall: start: no TURN servers -- cannot start\\n\");\n\t\treturn EINTR;\n\t}\n#endif\n\tecall->call_type = call_type;\n\terr = ecall_create_econn(ecall);\n\tif (err) {\n\t\twarning(\"ecall: start: create_econn failed: %m\\n\", err);\n\t\treturn err;\n\t}\n\teconn_set_state(ecall_get_econn(ecall), ECONN_PENDING_OUTGOING);\n\terr = alloc_flow(ecall, ASYNC_OFFER, ecall->call_type, audio_cbr);\n\tif (err) {\n\t\twarning(\"ecall: start: alloc_flow failed: %m\\n\", err);\n\t\tgoto out;\n\t}\n\tIFLOW_CALL(ecall->flow, set_audio_cbr, audio_cbr);\n\tif (ecall->props_local &&\n\t    (call_type == ICALL_CALL_TYPE_VIDEO\n\t     && ecall->vstate == ICALL_VIDEO_STATE_STARTED)) {\n\t\tconst char *vstate_string = \"true\";\n\t\tint err2 = econn_props_update(ecall->props_local,\n\t\t\t\t\t      \"videosend\", vstate_string);\n\t\tif (err2) {\n\t\t\twarning(\"ecall(%p): econn_props_update(videosend)\",\n\t\t\t\t\" failed (%m)\\n\", ecall, err2);\n\t\t}\n\t}\n\tecall->sdp.async = ASYNC_NONE;\n\terr = generate_offer(ecall);\n\tif (err) {\n\t\twarning(\"ecall(%p): start: generate_offer\"\n\t\t\t\" failed (%m)\\n\", ecall, err);\n\t\tgoto out;\n\t}\n\tecall->ts_started = tmr_jiffies();\n\tecall->call_setup_time = -1;\n out:\n\treturn err;\n}", "target": 1}
{"code": "xfs_inode_ag_iterator(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\t(*execute)(struct xfs_inode *ip, int flags,\n\t\t\t\t\t   void *args),\n\tint\t\t\tflags,\n\tvoid\t\t\t*args)\n{\n\treturn xfs_inode_ag_iterator_flags(mp, execute, flags, args, 0);\n}", "target": 0}
{"code": "define_function(foobar)\n{\n  int64_t arg = integer_argument(1);\n  switch (arg)\n  {\n    case 1:\n      return_string(\"foo\");\n      break;\n    case 2:\n      return_string(\"bar\");\n      break;\n  }\n  return_string(\"oops\")\n}", "target": 0}
{"code": "GF_Err void_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tif (s->size) return GF_ISOM_INVALID_FILE;\n\treturn GF_OK;\n}", "target": 0}
{"code": "static void check_hostalias(request_rec *r)\n{\n    const char *host = r->hostname;\n    apr_port_t port;\n    server_rec *s;\n    server_rec *virthost_s;\n    server_rec *last_s;\n    name_chain *src;\n    virthost_s = NULL;\n    last_s = NULL;\n    port = r->connection->local_addr->port;\n    for (src = r->connection->vhost_lookup_data; src; src = src->next) {\n        server_addr_rec *sar;\n        sar = src->sar;\n        if (sar->host_port != 0 && port != sar->host_port) {\n            continue;\n        }\n        s = src->server;\n        if (s != last_s) {\n            if (matches_aliases(s, host)) {\n                goto found;\n            }\n        }\n        if (!strcasecmp(host, sar->virthost)) {\n            if (virthost_s == NULL) {\n                virthost_s = s;\n            }\n        }\n        last_s = s;\n    }\n    if (virthost_s) {\n        s = virthost_s;\n        goto found;\n    }\n    return;\nfound:\n    r->server = s;\n}", "target": 1}
{"code": "static int ipddp_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n        struct ipddp_route __user *rt = ifr->ifr_data;\n        struct ipddp_route rcp, rcp2, *rp;\n        if(!capable(CAP_NET_ADMIN))\n                return -EPERM;\n\tif(copy_from_user(&rcp, rt, sizeof(rcp)))\n\t\treturn -EFAULT;\n        switch(cmd)\n        {\n\t\tcase SIOCADDIPDDPRT:\n                        return ipddp_create(&rcp);\n                case SIOCFINDIPDDPRT:\n\t\t\tspin_lock_bh(&ipddp_route_lock);\n\t\t\trp = __ipddp_find_route(&rcp);\n\t\t\tif (rp)\n\t\t\t\tmemcpy(&rcp2, rp, sizeof(rcp2));\n\t\t\tspin_unlock_bh(&ipddp_route_lock);\n\t\t\tif (rp) {\n\t\t\t\tif (copy_to_user(rt, &rcp2,\n\t\t\t\t\t\t sizeof(struct ipddp_route)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn -ENOENT;\n                case SIOCDELIPDDPRT:\n                        return ipddp_delete(&rcp);\n                default:\n                        return -EINVAL;\n        }\n}", "target": 1}
{"code": "BGD_DECLARE(void) gdImageXbmCtx(gdImagePtr image, char* file_name, int fg, gdIOCtx * out)\n{\n\tint x, y, c, b, sx, sy, p;\n\tchar *name, *f;\n\tsize_t i, l;\n\tname = file_name;\n\tif ((f = strrchr(name, '/')) != NULL) name = f+1;\n\tif ((f = strrchr(name, '\\\\')) != NULL) name = f+1;\n\tname = strdup(name);\n\tif ((f = strrchr(name, '.')) != NULL && !strcasecmp(f, \".XBM\")) *f = '\\0';\n\tif ((l = strlen(name)) == 0) {\n\t\tfree(name);\n\t\tname = strdup(\"image\");\n\t} else {\n\t\tfor (i=0; i<l; i++) {\n\t\t\tif (!isupper(name[i]) && !islower(name[i]) && !isdigit(name[i])) {\n\t\t\t\tname[i] = '_';\n\t\t\t}\n\t\t}\n\t}\n\tgdCtxPrintf(out, \"#define %s_width %d\\n\", name, gdImageSX(image));\n\tgdCtxPrintf(out, \"#define %s_height %d\\n\", name, gdImageSY(image));\n\tgdCtxPrintf(out, \"static unsigned char %s_bits[] = {\\n  \", name);\n\tfree(name);\n\tb = 1;\n\tp = 0;\n\tc = 0;\n\tsx = gdImageSX(image);\n\tsy = gdImageSY(image);\n\tfor (y = 0; y < sy; y++) {\n\t\tfor (x = 0; x < sx; x++) {\n\t\t\tif (gdImageGetPixel(image, x, y) == fg) {\n\t\t\t\tc |= b;\n\t\t\t}\n\t\t\tif ((b == 128) || (x == sx && y == sy)) {\n\t\t\t\tb = 1;\n\t\t\t\tif (p) {\n\t\t\t\t\tgdCtxPrintf(out, \", \");\n\t\t\t\t\tif (!(p%12)) {\n\t\t\t\t\t\tgdCtxPrintf(out, \"\\n  \");\n\t\t\t\t\t\tp = 12;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t\tgdCtxPrintf(out, \"0x%02X\", c);\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\tb <<= 1;\n\t\t\t}\n\t\t}\n\t}\n\tgdCtxPrintf(out, \"};\\n\");\n}", "target": 1}
{"code": "static bool checkreturn pb_dec_bytes(pb_istream_t *stream, const pb_field_t *field, void *dest)\n{\n    uint32_t size;\n    pb_bytes_array_t *bdest;\n    if (!pb_decode_varint32(stream, &size))\n        return false;\n    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)\n    {\n#ifndef PB_ENABLE_MALLOC\n        PB_RETURN_ERROR(stream, \"no malloc support\");\n#else\n        if (!allocate_field(stream, dest, PB_BYTES_ARRAY_T_ALLOCSIZE(size), 1))\n            return false;\n        bdest = *(pb_bytes_array_t**)dest;\n#endif\n    }\n    else\n    {\n        if (PB_BYTES_ARRAY_T_ALLOCSIZE(size) > field->data_size)\n            PB_RETURN_ERROR(stream, \"bytes overflow\");\n        bdest = (pb_bytes_array_t*)dest;\n    }\n    if (size > PB_SIZE_MAX)\n    {\n        PB_RETURN_ERROR(stream, \"bytes overflow\");\n    }\n    bdest->size = (pb_size_t)size;\n    return pb_read(stream, bdest->bytes, size);\n}", "target": 1}
{"code": "mm_create(struct mm_master *mmalloc, size_t size)\n{\n\tvoid *address;\n\tstruct mm_master *mm;\n\tif (mmalloc == NULL)\n\t\tmm = xcalloc(1, sizeof(struct mm_master));\n\telse\n\t\tmm = mm_xmalloc(mmalloc, sizeof(struct mm_master));\n\tmm->mmalloc = mmalloc;\n\taddress = mmap(NULL, size, PROT_WRITE|PROT_READ, MAP_ANON|MAP_SHARED,\n\t    -1, 0);\n\tif (address == MAP_FAILED)\n\t\tfatal(\"mmap(%zu): %s\", size, strerror(errno));\n\tmm->address = address;\n\tmm->size = size;\n\tRB_INIT(&mm->rb_free);\n\tRB_INIT(&mm->rb_allocated);\n\tmm_make_entry(mm, &mm->rb_free, address, size);\n\treturn (mm);\n}", "target": 1}
{"code": "static void vmclear_local_loaded_vmcss(void)\n{\n\tint cpu = raw_smp_processor_id();\n\tstruct loaded_vmcs *v, *n;\n\tlist_for_each_entry_safe(v, n, &per_cpu(loaded_vmcss_on_cpu, cpu),\n\t\t\t\t loaded_vmcss_on_cpu_link)\n\t\t__loaded_vmcs_clear(v);\n}", "target": 0}
{"code": "test_validate_path_args (void)\n{\n  gsize idx;\n  for (idx = 0; idx < G_N_ELEMENTS (invalid_path_args); idx++)\n    {\n      g_autoptr(FlatpakContext) context = flatpak_context_new ();\n      g_autoptr(GError) local_error = NULL;\n      const char *path = invalid_path_args[idx];\n      context_parse_args (context, &local_error, path, NULL);\n      g_assert_error (local_error, G_IO_ERROR, G_IO_ERROR_INVALID_DATA);\n      g_assert (strstr (local_error->message, \"Non-graphical character\"));\n    }\n}", "target": 0}
{"code": "void HBCISel::generateHBCResolveEnvironment(\n    HBCResolveEnvironment *Inst,\n    BasicBlock *next) {\n  VariableScope *instScope = Inst->getScope();\n  Optional<int32_t> instScopeDepth = scopeAnalysis_.getScopeDepth(instScope);\n  Optional<int32_t> curScopeDepth =\n      scopeAnalysis_.getScopeDepth(F_->getFunctionScope());\n  if (!instScopeDepth || !curScopeDepth) {\n    emitUnreachableIfDebug();\n    return;\n  }\n  assert(\n      curScopeDepth && curScopeDepth.getValue() >= instScopeDepth.getValue() &&\n      \"Cannot access variables in inner scopes\");\n  int32_t delta = curScopeDepth.getValue() - instScopeDepth.getValue();\n  assert(delta > 0 && \"HBCResolveEnvironment for current scope\");\n  if (std::numeric_limits<uint8_t>::max() < delta) {\n    F_->getContext().getSourceErrorManager().error(\n        Inst->getLocation(), \"Variable environment is out-of-reach\");\n  }\n  BCFGen_->emitGetEnvironment(encodeValue(Inst), delta - 1);\n}", "target": 0}
{"code": "sg_fill_request_table(Sg_fd *sfp, sg_req_info_t *rinfo)\n{\n\tSg_request *srp;\n\tint val;\n\tunsigned int ms;\n\tval = 0;\n\tlist_for_each_entry(srp, &sfp->rq_list, entry) {\n\t\tif (val > SG_MAX_QUEUE)\n\t\t\tbreak;\n\t\tmemset(&rinfo[val], 0, SZ_SG_REQ_INFO);\n\t\trinfo[val].req_state = srp->done + 1;\n\t\trinfo[val].problem =\n\t\t\tsrp->header.masked_status &\n\t\t\tsrp->header.host_status &\n\t\t\tsrp->header.driver_status;\n\t\tif (srp->done)\n\t\t\trinfo[val].duration =\n\t\t\t\tsrp->header.duration;\n\t\telse {\n\t\t\tms = jiffies_to_msecs(jiffies);\n\t\t\trinfo[val].duration =\n\t\t\t\t(ms > srp->header.duration) ?\n\t\t\t\t(ms - srp->header.duration) : 0;\n\t\t}\n\t\trinfo[val].orphan = srp->orphan;\n\t\trinfo[val].sg_io_owned = srp->sg_io_owned;\n\t\trinfo[val].pack_id = srp->header.pack_id;\n\t\trinfo[val].usr_ptr = srp->header.usr_ptr;\n\t\tval++;\n\t}\n}", "target": 1}
{"code": "daemon_linux_lvm2_lv_remove_authorized_cb (Daemon *daemon,\n                                           Device *device,\n                                           DBusGMethodInvocation *context,\n                                           const gchar *action_id,\n                                           guint num_user_data,\n                                           gpointer *user_data_elements)\n{\n  const gchar *group_uuid = user_data_elements[0];\n  const gchar *uuid = user_data_elements[1];\n  gchar *lv_name;\n  guint n;\n  gchar *argv[10];\n  lv_name = find_lvm2_lv_name_for_uuids (daemon, group_uuid, uuid);\n  if (lv_name == NULL)\n    {\n      throw_error (context, ERROR_FAILED, \"Cannot find LV with UUID `%s'\", uuid);\n      goto out;\n    }\n  n = 0;\n  argv[n++] = \"lvremove\";\n  argv[n++] = lv_name;\n  argv[n++] = \"--force\";\n  argv[n++] = NULL;\n  if (!job_new (context, \"LinuxLvm2LVRemove\", TRUE, NULL, argv, NULL, linux_lvm2_lv_remove_completed_cb, FALSE, NULL, NULL))\n    {\n      goto out;\n    }\n out:\n  g_free (lv_name);\n}", "target": 0}
{"code": "build_config(char *prefix, struct server *server)\n{\n    char *path    = NULL;\n    int path_size = strlen(prefix) + strlen(server->port) + 20;\n    path = ss_malloc(path_size);\n    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n    FILE *f = fopen(path, \"w+\");\n    if (f == NULL) {\n        if (verbose) {\n            LOGE(\"unable to open config file\");\n        }\n        ss_free(path);\n        return;\n    }\n    fprintf(f, \"{\\n\");\n    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n    fprintf(f, \"\\n}\\n\");\n    fclose(f);\n    ss_free(path);\n}", "target": 1}
{"code": "static inline int mystrcmp(char **p, const char *sample)\n{\n    int len = strlen(sample);\n    if (strncmp(*p, sample, len) == 0) {\n        (*p) += len;\n        return 1;\n    } else\n        return 0;\n}", "target": 0}
{"code": "int main(void) {\n    if (siphash_test() == 0) {\n        printf(\"SipHash test: OK\\n\");\n        return 0;\n    } else {\n        printf(\"SipHash test: FAILED\\n\");\n        return 1;\n    }\n}", "target": 0}
{"code": "void Ppmd8_Construct(CPpmd8 *p)\n{\n  unsigned i, k, m;\n  p->Base = 0;\n  for (i = 0, k = 0; i < PPMD_NUM_INDEXES; i++)\n  {\n    unsigned step = (i >= 12 ? 4 : (i >> 2) + 1);\n    do { p->Units2Indx[k++] = (Byte)i; } while (--step);\n    p->Indx2Units[i] = (Byte)k;\n  }\n  p->NS2BSIndx[0] = (0 << 1);\n  p->NS2BSIndx[1] = (1 << 1);\n  memset(p->NS2BSIndx + 2, (2 << 1), 9);\n  memset(p->NS2BSIndx + 11, (3 << 1), 256 - 11);\n  for (i = 0; i < 5; i++)\n    p->NS2Indx[i] = (Byte)i;\n  for (m = i, k = 1; i < 260; i++)\n  {\n    p->NS2Indx[i] = (Byte)m;\n    if (--k == 0)\n      k = (++m) - 4;\n  }\n}", "target": 0}
{"code": "void sev_es_init_vmcb(struct vcpu_svm *svm)\n{\n\tstruct kvm_vcpu *vcpu = &svm->vcpu;\n\tsvm->vmcb->control.nested_ctl |= SVM_NESTED_CTL_SEV_ES_ENABLE;\n\tsvm->vmcb->control.virt_ext |= LBR_CTL_ENABLE_MASK;\n\tsvm->vmcb->control.vmsa_pa = __pa(svm->vmsa);\n\tsvm_clr_intercept(svm, INTERCEPT_CR0_READ);\n\tsvm_clr_intercept(svm, INTERCEPT_CR4_READ);\n\tsvm_clr_intercept(svm, INTERCEPT_CR8_READ);\n\tsvm_clr_intercept(svm, INTERCEPT_CR0_WRITE);\n\tsvm_clr_intercept(svm, INTERCEPT_CR4_WRITE);\n\tsvm_clr_intercept(svm, INTERCEPT_CR8_WRITE);\n\tsvm_clr_intercept(svm, INTERCEPT_SELECTIVE_CR0);\n\tsvm_set_intercept(svm, TRAP_EFER_WRITE);\n\tsvm_set_intercept(svm, TRAP_CR0_WRITE);\n\tsvm_set_intercept(svm, TRAP_CR4_WRITE);\n\tsvm_set_intercept(svm, TRAP_CR8_WRITE);\n\tclr_exception_intercept(svm, GP_VECTOR);\n\tsvm_clr_intercept(svm, INTERCEPT_XSETBV);\n\tset_msr_interception(vcpu, svm->msrpm, MSR_EFER, 1, 1);\n\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_CR_PAT, 1, 1);\n\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_LASTBRANCHFROMIP, 1, 1);\n\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_LASTBRANCHTOIP, 1, 1);\n\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_LASTINTFROMIP, 1, 1);\n\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_LASTINTTOIP, 1, 1);\n}", "target": 0}
{"code": "DU_getStringDOElement(DcmItem *obj, DcmTagKey t, char *s, size_t bufsize)\n{\n    DcmByteString *elem;\n    DcmStack stack;\n    OFCondition ec = EC_Normal;\n    char* aString;\n    ec = obj->search(t, stack);\n    elem = (DcmByteString*) stack.top();\n    if (ec == EC_Normal && elem != NULL) {\n        if (elem->getLength() == 0) {\n            s[0] = '\\0';\n        } else {\n            ec =  elem->getString(aString);\n            OFStandard::strlcpy(s, aString, bufsize);\n        }\n    }\n    return (ec == EC_Normal);\n}", "target": 1}
{"code": "void ParamTraits<FilePath>::Write(Message* m, const param_type& p) {\n  ParamTraits<FilePath::StringType>::Write(m, p.value());\n}", "target": 0}
{"code": "R_API char *r_cons_hud_file(const char *f) {\n\tchar *s = r_file_slurp (f, NULL);\n\tif (s) {\n\t\tr_str_ansi_strip (s);\n\t\tchar *ret = r_cons_hud_string (s);\n\t\tfree (s);\n\t\treturn ret;\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "static CURLcode error_init_writer(struct Curl_easy *data,\n                                  struct contenc_writer *writer)\n{\n  (void) data;\n  return writer->downstream? CURLE_OK: CURLE_WRITE_ERROR;\n}", "target": 0}
{"code": "static bool caller_is_in_ancestor(pid_t pid, const char *contrl, const char *cg, char **nextcg)\n{\n\tchar fnam[PROCLEN];\n\tFILE *f;\n\tbool answer = false;\n\tchar *line = NULL;\n\tsize_t len = 0;\n\tint ret;\n\tret = snprintf(fnam, PROCLEN, \"/proc/%d/cgroup\", pid);\n\tif (ret < 0 || ret >= PROCLEN)\n\t\treturn false;\n\tif (!(f = fopen(fnam, \"r\")))\n\t\treturn false;\n\twhile (getline(&line, &len, f) != -1) {\n\t\tchar *c1, *c2, *linecmp;\n\t\tif (!line[0])\n\t\t\tcontinue;\n\t\tc1 = strchr(line, ':');\n\t\tif (!c1)\n\t\t\tgoto out;\n\t\tc1++;\n\t\tc2 = strchr(c1, ':');\n\t\tif (!c2)\n\t\t\tgoto out;\n\t\t*c2 = '\\0';\n\t\tif (strcmp(c1, contrl) != 0)\n\t\t\tcontinue;\n\t\tc2++;\n\t\tstripnewline(c2);\n\t\tprune_init_slice(c2);\n\t\tlinecmp = *cg == '/' ? c2 : c2+1;\n\t\tif (strncmp(linecmp, cg, strlen(linecmp)) != 0) {\n\t\t\tif (nextcg)\n\t\t\t\t*nextcg = get_next_cgroup_dir(linecmp, cg);\n\t\t\tgoto out;\n\t\t}\n\t\tanswer = true;\n\t\tgoto out;\n\t}\nout:\n\tfclose(f);\n\tfree(line);\n\treturn answer;\n}", "target": 1}
{"code": "PROCESS_THREAD(snmp_process, ev, data)\n{\n  PROCESS_BEGIN();\n  snmp_udp_conn = udp_new(NULL, 0, NULL);\n  udp_bind(snmp_udp_conn, SNMP_SERVER_PORT);\n  LOG_DBG(\"Listening on port %u\\n\", uip_ntohs(snmp_udp_conn->lport));\n  while(1) {\n    PROCESS_YIELD();\n    if(ev == tcpip_event) {\n      if(uip_newdata()) {\n        snmp_process_data();\n      }\n    }\n  } \n  PROCESS_END();\n}", "target": 1}
{"code": "ECDSA_PrivateKey::create_signature_op(RandomNumberGenerator& ,\n                                      const std::string& params,\n                                      const std::string& provider) const\n   {\n#if defined(BOTAN_HAS_BEARSSL)\n   if(provider == \"bearssl\" || provider.empty())\n      {\n      try\n         {\n         return make_bearssl_ecdsa_sig_op(*this, params);\n         }\n      catch(Lookup_Error& e)\n         {\n         if(provider == \"bearssl\")\n            throw;\n         }\n      }\n#endif\n#if defined(BOTAN_HAS_OPENSSL)\n   if(provider == \"openssl\" || provider.empty())\n      {\n      try\n         {\n         return make_openssl_ecdsa_sig_op(*this, params);\n         }\n      catch(Lookup_Error& e)\n         {\n         if(provider == \"openssl\")\n            throw;\n         }\n      }\n#endif\n   if(provider == \"base\" || provider.empty())\n      return std::unique_ptr<PK_Ops::Signature>(new ECDSA_Signature_Operation(*this, params));\n   throw Provider_Not_Found(algo_name(), provider);\n   }", "target": 1}
{"code": "GIT_INLINE(bool) verify_dotgit_ntfs(git_repository *repo, const char *path, size_t len)\n{\n\tgit_buf *reserved = git_repository__reserved_names_win32;\n\tsize_t reserved_len = git_repository__reserved_names_win32_len;\n\tsize_t start = 0, i;\n\tif (repo)\n\t\tgit_repository__reserved_names(&reserved, &reserved_len, repo, true);\n\tfor (i = 0; i < reserved_len; i++) {\n\t\tgit_buf *r = &reserved[i];\n\t\tif (len >= r->size &&\n\t\t\tstrncasecmp(path, r->ptr, r->size) == 0) {\n\t\t\tstart = r->size;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!start)\n\t\treturn true;\n\tif (path[start] == '\\\\')\n\t\treturn false;\n\tfor (i = start; i < len; i++) {\n\t\tif (path[i] != ' ' && path[i] != '.')\n\t\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "noop_post_process (j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n                   JDIMENSION *in_row_group_ctr,\n                   JDIMENSION in_row_groups_avail, JSAMPARRAY output_buf,\n                   JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)\n{\n}", "target": 0}
{"code": "utf32be_mbc_to_code(const UChar* p, const UChar* end ARG_UNUSED)\n{\n  if (end - p < 4) return 0;\n  return (OnigCodePoint )(((p[0] * 256 + p[1]) * 256 + p[2]) * 256 + p[3]);\n}", "target": 0}
{"code": "lexer_check_arrow_param (parser_context_t *context_p) \n{\n  JERRY_ASSERT (context_p->token.flags & LEXER_NO_SKIP_SPACES);\n  if (context_p->source_p >= context_p->source_end_p)\n  {\n    return false;\n  }\n  if (context_p->source_p[0] == LIT_CHAR_COMMA)\n  {\n    return true;\n  }\n  if (context_p->source_p[0] != LIT_CHAR_EQUALS)\n  {\n    return false;\n  }\n  return (context_p->source_p + 1 >= context_p->source_end_p || context_p->source_p[1] != LIT_CHAR_EQUALS);\n} ", "target": 0}
{"code": "static bool kvm_vcpu_check_breakpoint(struct kvm_vcpu *vcpu, int *r)\n{\n\tif (unlikely(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) &&\n\t    (vcpu->arch.guest_debug_dr7 & DR7_BP_EN_MASK)) {\n\t\tstruct kvm_run *kvm_run = vcpu->run;\n\t\tunsigned long eip = kvm_get_linear_rip(vcpu);\n\t\tu32 dr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.guest_debug_dr7,\n\t\t\t\t\t   vcpu->arch.eff_db);\n\t\tif (dr6 != 0) {\n\t\t\tkvm_run->debug.arch.dr6 = dr6 | DR6_ACTIVE_LOW;\n\t\t\tkvm_run->debug.arch.pc = eip;\n\t\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\t\t*r = 0;\n\t\t\treturn true;\n\t\t}\n\t}\n\tif (unlikely(vcpu->arch.dr7 & DR7_BP_EN_MASK) &&\n\t    !(kvm_get_rflags(vcpu) & X86_EFLAGS_RF)) {\n\t\tunsigned long eip = kvm_get_linear_rip(vcpu);\n\t\tu32 dr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.dr7,\n\t\t\t\t\t   vcpu->arch.db);\n\t\tif (dr6 != 0) {\n\t\t\tkvm_queue_exception_p(vcpu, DB_VECTOR, dr6);\n\t\t\t*r = 1;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "target": 1}
{"code": "static inline void skb_reset_mac_header(struct sk_buff *skb)\n{\n\tskb->mac_header = skb->data - skb->head;\n}", "target": 0}
{"code": "get_case_fold_codes_by_str(OnigCaseFoldType flag,\n\t\t\t\t       const OnigUChar* p, const OnigUChar* end,\n\t\t\t\t       OnigCaseFoldCodeItem items[],\n\t\t\t\t       OnigEncoding enc ARG_UNUSED)\n{\n  return onigenc_get_case_fold_codes_by_str_with_map(\n\t     sizeof(CaseFoldMap)/sizeof(OnigPairCaseFoldCodes), CaseFoldMap, 1,\n\t     flag, p, end, items);\n}", "target": 0}
{"code": "char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n{\n  size_t alloc = (inlength?(size_t)inlength:strlen(string))+1;\n  char *ns;\n  char *testing_ptr = NULL;\n  unsigned char in; \n  size_t newlen = alloc;\n  int strindex=0;\n  size_t length;\n  CURLcode res;\n  ns = malloc(alloc);\n  if(!ns)\n    return NULL;\n  length = alloc-1;\n  while(length--) {\n    in = *string;\n    if(Curl_isunreserved(in))\n      ns[strindex++]=in;\n    else {\n      newlen += 2; \n      if(newlen > alloc) {\n        alloc *= 2;\n        testing_ptr = realloc(ns, alloc);\n        if(!testing_ptr) {\n          free( ns );\n          return NULL;\n        }\n        else {\n          ns = testing_ptr;\n        }\n      }\n      res = Curl_convert_to_network(handle, &in, 1);\n      if(res) {\n        free(ns);\n        return NULL;\n      }\n      snprintf(&ns[strindex], 4, \"%%%02X\", in);\n      strindex+=3;\n    }\n    string++;\n  }\n  ns[strindex]=0; \n  return ns;\n}", "target": 1}
{"code": "valid_ruser(const char *s)\n{\n\tsize_t i;\n\tif (*s == '-')\n\t\treturn 0;\n\tfor (i = 0; s[i] != 0; i++) {\n\t\tif (strchr(\"'`\\\";&<>|(){}\", s[i]) != NULL)\n\t\t\treturn 0;\n\t\tif (isspace((u_char)s[i]) && s[i + 1] == '-')\n\t\t\treturn 0;\n\t\tif (s[i] == '\\\\' && s[i + 1] == '\\0')\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "req_remote_addr(agooReq r) {\n    if (NULL == r) {\n\trb_raise(rb_eArgError, \"Request is no longer valid.\");\n    }\n    return rb_str_new(r->remote, strlen(r->remote));\n}", "target": 0}
{"code": "nvkm_vmm_node_remove(struct nvkm_vmm *vmm, struct nvkm_vma *vma)\n{\n\trb_erase(&vma->tree, &vmm->root);\n}", "target": 0}
{"code": "static s32 adpt_i2o_quiesce_hba(adpt_hba* pHba)\n{\n\tu32 msg[4];\n\tint ret;\n\tadpt_i2o_status_get(pHba);\n\tif((pHba->status_block->iop_state != ADAPTER_STATE_READY) &&\n   \t   (pHba->status_block->iop_state != ADAPTER_STATE_OPERATIONAL)){\n\t\treturn 0;\n\t}\n\tmsg[0] = FOUR_WORD_MSG_SIZE|SGL_OFFSET_0;\n\tmsg[1] = I2O_CMD_SYS_QUIESCE<<24|HOST_TID<<12|ADAPTER_TID;\n\tmsg[2] = 0;\n\tmsg[3] = 0;\n\tif((ret = adpt_i2o_post_wait(pHba, msg, sizeof(msg), 240))) {\n\t\tprintk(KERN_INFO\"dpti%d: Unable to quiesce (status=%#x).\\n\",\n\t\t\t\tpHba->unit, -ret);\n\t} else {\n\t\tprintk(KERN_INFO\"dpti%d: Quiesced.\\n\",pHba->unit);\n\t}\n\tadpt_i2o_status_get(pHba);\n\treturn ret;\n}", "target": 1}
{"code": "    void cleanup() { delete m_server; }", "target": 0}
{"code": "cmyk_to_rgb(JSAMPLE c, JSAMPLE m, JSAMPLE y, JSAMPLE k, JSAMPLE *r, JSAMPLE *g,\n            JSAMPLE *b)\n{\n  *r = (JSAMPLE)((double)c * (double)k / 255.0 + 0.5);\n  *g = (JSAMPLE)((double)m * (double)k / 255.0 + 0.5);\n  *b = (JSAMPLE)((double)y * (double)k / 255.0 + 0.5);\n}", "target": 0}
{"code": "void HTMLMediaElement::UpdatePlaybackRate() {\n  if (web_media_player_ && PotentiallyPlaying())\n    GetWebMediaPlayer()->SetRate(playbackRate());\n}", "target": 0}
{"code": "ftrace_regex_lseek(struct file *file, loff_t offset, int whence)\n{\n\tloff_t ret;\n\tif (file->f_mode & FMODE_READ)\n\t\tret = seq_lseek(file, offset, whence);\n\telse\n\t\tfile->f_pos = ret = 1;\n\treturn ret;\n}", "target": 1}
{"code": "Bool gf_sg_proto_field_is_sftime_offset(GF_Node *node, GF_FieldInfo *field)\n{\n\tu32 i;\n\tGF_Route *r;\n\tGF_ProtoInstance *inst;\n\tGF_FieldInfo inf;\n\tif (node->sgprivate->tag != TAG_ProtoNode) return 0;\n\tif (field->fieldType != GF_SG_VRML_SFTIME) return 0;\n\tinst = (GF_ProtoInstance *) node;\n\ti=0;\n\twhile ((r = (GF_Route*)gf_list_enum(inst->proto_interface->sub_graph->Routes, &i))) {\n\t\tif (!r->IS_route) continue;\n\t\tif (r->FromNode || (r->FromField.fieldIndex != field->fieldIndex)) continue;\n\t\tgf_node_get_field(r->ToNode, r->ToField.fieldIndex, &inf);\n\t\tif (r->ToNode->sgprivate->tag == TAG_ProtoNode) return gf_sg_proto_field_is_sftime_offset(r->ToNode, &inf);\n\t\tif (!stricmp(inf.name, \"startTime\") || !stricmp(inf.name, \"stopTime\")) return 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static RzList *classes_from_symbols(RzBinFile *bf) {\n\tRzBinSymbol *sym;\n\tRzListIter *iter;\n\trz_list_foreach (bf->o->symbols, iter, sym) {\n\t\tif (sym->name[0] != '_') {\n\t\t\tcontinue;\n\t\t}\n\t\tconst char *cn = sym->classname;\n\t\tif (cn) {\n\t\t\tRzBinClass *c = rz_bin_file_add_class(bf, sym->classname, NULL, 0);\n\t\t\tif (!c) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tchar *dn = sym->dname;\n\t\t\tchar *fn = swiftField(dn, cn);\n\t\t\tif (fn) {\n\t\t\t\tRzBinField *f = rz_bin_field_new(sym->paddr, sym->vaddr, sym->size, fn, NULL, NULL, false);\n\t\t\t\trz_list_append(c->fields, f);\n\t\t\t\tfree(fn);\n\t\t\t} else {\n\t\t\t\tchar *mn = strstr(dn, \"..\");\n\t\t\t\tif (!mn) {\n\t\t\t\t\tmn = strstr(dn, cn);\n\t\t\t\t\tif (mn && mn[strlen(cn)] == '.') {\n\t\t\t\t\t\trz_list_append(c->methods, sym);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn bf->o->classes;\n}", "target": 1}
{"code": "void ntlm_print_av_pair_list(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList)\n{\n\tsize_t cbAvPair = cbAvPairList;\n\tNTLM_AV_PAIR* pAvPair = pAvPairList;\n\tif (!ntlm_av_pair_check(pAvPair, cbAvPair))\n\t\treturn;\n\tWLog_INFO(TAG, \"AV_PAIRs =\");\n\twhile (pAvPair && ntlm_av_pair_get_id(pAvPair) != MsvAvEOL)\n\t{\n\t\tWLog_INFO(TAG, \"\\t%s AvId: %\" PRIu16 \" AvLen: %\" PRIu16 \"\",\n\t\t          AV_PAIR_STRINGS[ntlm_av_pair_get_id(pAvPair)], ntlm_av_pair_get_id(pAvPair),\n\t\t          ntlm_av_pair_get_len(pAvPair));\n\t\twinpr_HexDump(TAG, WLOG_INFO, ntlm_av_pair_get_value_pointer(pAvPair),\n\t\t              ntlm_av_pair_get_len(pAvPair));\n\t\tpAvPair = ntlm_av_pair_next(pAvPair, &cbAvPair);\n\t}\n}", "target": 1}
{"code": "static int serdes_probe(struct platform_device *pdev)\n{\n\tstruct phy_provider *provider;\n\tstruct serdes_ctrl *ctrl;\n\tunsigned int i;\n\tint ret;\n\tctrl = devm_kzalloc(&pdev->dev, sizeof(*ctrl), GFP_KERNEL);\n\tif (!ctrl)\n\t\treturn -ENOMEM;\n\tctrl->dev = &pdev->dev;\n\tctrl->regs = syscon_node_to_regmap(pdev->dev.parent->of_node);\n\tif (IS_ERR(ctrl->regs))\n\t\treturn PTR_ERR(ctrl->regs);\n\tfor (i = 0; i <= SERDES_MAX; i++) {\n\t\tret = serdes_phy_create(ctrl, i, &ctrl->phys[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tdev_set_drvdata(&pdev->dev, ctrl);\n\tprovider = devm_of_phy_provider_register(ctrl->dev,\n\t\t\t\t\t\t serdes_simple_xlate);\n\treturn PTR_ERR_OR_ZERO(provider);\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* c) override {\n    PartialTensorShape element_shape;\n    OP_REQUIRES_OK(c, TensorShapeFromTensor(c->input(0), &element_shape));\n    OP_REQUIRES(\n        c, TensorShapeUtils::IsScalar(c->input(1).shape()),\n        errors::InvalidArgument(\n            \"The num_elements to reserve must be a tensor size 1, but got \",\n            c->input(1).shape()));\n    int32_t num_elements = c->input(1).scalar<int32>()();\n    OP_REQUIRES(c, num_elements >= 0,\n                errors::InvalidArgument(\"The num_elements to reserve must be a \"\n                                        \"non negative number, but got \",\n                                        num_elements));\n    TensorList output;\n    output.element_shape = element_shape;\n    output.element_dtype = element_dtype_;\n    output.tensors().resize(num_elements, Tensor(DT_INVALID));\n    Tensor* result;\n    AllocatorAttributes attr;\n    attr.set_on_host(true);\n    OP_REQUIRES_OK(c, c->allocate_output(0, TensorShape{}, &result, attr));\n    result->scalar<Variant>()() = std::move(output);\n  }", "target": 0}
{"code": "static void ufs_mtk_init_va09_pwr_ctrl(struct ufs_hba *hba)\n{\n\tstruct ufs_mtk_host *host = ufshcd_get_variant(hba);\n\thost->reg_va09 = regulator_get(hba->dev, \"va09\");\n\tif (!host->reg_va09)\n\t\tdev_info(hba->dev, \"failed to get va09\");\n\telse\n\t\thost->caps |= UFS_MTK_CAP_VA09_PWR_CTRL;\n}", "target": 1}
{"code": "cp1250_mbc_case_fold(OnigCaseFoldType flag ARG_UNUSED,\n             const UChar** pp, const UChar* end ARG_UNUSED, UChar* lower, OnigEncoding enc ARG_UNUSED)\n{\n  const UChar* p = *pp;\n  *lower = ENC_CP1250_TO_LOWER_CASE(*p);\n  (*pp)++;\n  return 1;\n}", "target": 0}
{"code": " */\nstatic int wddx_stack_destroy(wddx_stack *stack)\n{\n\tregister int i;\n\tif (stack->elements) {\n\t\tfor (i = 0; i < stack->top; i++) {\n\t\t\tif (((st_entry *)stack->elements[i])->data)\t{\n\t\t\t\tzval_ptr_dtor(&((st_entry *)stack->elements[i])->data);\n\t\t\t}\n\t\t\tif (((st_entry *)stack->elements[i])->varname) {\n\t\t\t\tefree(((st_entry *)stack->elements[i])->varname);\n\t\t\t}\n\t\t\tefree(stack->elements[i]);\n\t\t}\n\t\tefree(stack->elements);\n\t}\n\treturn SUCCESS;", "target": 1}
{"code": "compare_orports_(const void **_a, const void **_b)\n{\n  const tor_addr_port_t *a = *_a, *b = *_b;\n  int r;\n  if ((r = tor_addr_compare(&a->addr, &b->addr, CMP_EXACT)))\n    return r;\n  if ((r = (((int) b->port) - ((int) a->port))))\n    return r;\n  return 0;\n}", "target": 0}
{"code": "R_API ut8 *r_bin_java_get_attr_buf(RBinJavaObj *bin, ut64 sz, const ut64 offset, const ut8 *buf, const ut64 len) {\n\tut8 *attr_buf = NULL;\n\tint pending = len - offset;\n\tconst ut8 *a_buf = offset + buf;\n\tattr_buf = (ut8 *) calloc (pending + 1, 1);\n\tif (!attr_buf) {\n\t\teprintf (\"Unable to allocate enough bytes (0x%04\"PFMT64x\n\t\t\t\") to read in the attribute.\\n\", sz);\n\t\treturn attr_buf;\n\t}\n\tmemcpy (attr_buf, a_buf, pending); \n\treturn attr_buf;\n}", "target": 1}
{"code": "    bool read(ReadonlyBytes buffer)\n    {\n        auto fields_size = sizeof(CentralDirectoryRecord) - (sizeof(u8*) * 3);\n        if (buffer.size() < fields_size)\n            return false;\n        if (memcmp(buffer.data(), central_directory_record_signature, sizeof(central_directory_record_signature)) != 0)\n            return false;\n        memcpy(reinterpret_cast<void*>(&made_by_version), buffer.data() + sizeof(central_directory_record_signature), fields_size);\n        name = buffer.data() + sizeof(central_directory_record_signature) + fields_size;\n        extra_data = name + name_length;\n        comment = extra_data + extra_data_length;\n        return true;\n    }", "target": 1}
{"code": "static int8_t parse_ext_option(uint16_t *dst, uint8_t **packet_data_pptr, uint8_t *packet_data_start_ptr, uint16_t packet_len, uint16_t *message_left)\n{\n    uint16_t option_number = *dst;\n    if (option_number == 13) {\n        uint8_t option_ext;\n        int8_t read_result = sn_coap_parser_read_packet_u8(&option_ext,\n                                                            *packet_data_pptr,\n                                                            packet_data_start_ptr,\n                                                            packet_len);\n        if (read_result != 0) {\n            tr_error(\"sn_coap_parser_options_parse - **packet_data_pptr overflow !\");\n            return -1;\n        }\n        else {\n                option_number += option_ext;\n                *message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr,\n                                                               packet_data_start_ptr,\n                                                               packet_len,\n                                                               1);\n        }\n    } else if (option_number == 14) {\n            int8_t read_result = sn_coap_parser_read_packet_u16(&option_number,\n                                                                *packet_data_pptr,\n                                                                packet_data_start_ptr,\n                                                                packet_len);\n            if (read_result != 0) {\n                tr_error(\"sn_coap_parser_options_parse - **packet_data_pptr overflow !\");\n                return -1;\n            }\n            else {\n            option_number += 269;\n            *message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr,\n                                                           packet_data_start_ptr,\n                                                           packet_len,\n                                                           2);\n            }\n    }\n    else if (option_number == 15) {\n        tr_error(\"sn_coap_parser_options_parse - invalid option number(15)!\");\n        return -1;\n    }\n    *dst = option_number;\n    return 0;\n}", "target": 1}
{"code": "static ssize_t driver_override_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\treturn sprintf(buf, \"%s\\n\", pdev->driver_override);\n}", "target": 1}
{"code": "R_API int r_socket_block_time(RSocket *s, int block, int sec, int usec) {\n#if __UNIX__\n\tint ret, flags;\n#endif\n\tif (!s) {\n\t\treturn false;\n\t}\n#if __UNIX__\n\tflags = fcntl (s->fd, F_GETFL, 0);\n\tif (flags < 0) {\n\t\treturn false;\n\t}\n\tret = fcntl (s->fd, F_SETFL, block?\n\t\t\t(flags & ~O_NONBLOCK):\n\t\t\t(flags | O_NONBLOCK));\n\tif (ret < 0) {\n\t\treturn false;\n\t}\n#elif __WINDOWS__\n\tioctlsocket (s->fd, FIONBIO, (u_long FAR*)&block);\n#endif\n\tif (sec > 0 || usec > 0) {\n\t\tstruct timeval tv = {0};\n\t\ttv.tv_sec = sec;\n\t\ttv.tv_usec = usec;\n\t\tif (setsockopt (s->fd, SOL_SOCKET, SO_RCVTIMEO, (char *)&tv, sizeof (tv)) < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "target": 1}
{"code": "int LayerTilerChromium::tileIndex(int i, int j) const\n{\n    ASSERT(i >= 0 && j >= 0 && i < m_layerTileSize.width() && j < m_layerTileSize.height());\n    return i + j * m_layerTileSize.width();\n}", "target": 0}
{"code": "static NETWORK_INTERFACE_DESCRIPTION* create_network_interface_description(struct ifreq *ifr, NETWORK_INTERFACE_DESCRIPTION* previous_nid)\n{\n    NETWORK_INTERFACE_DESCRIPTION* result;\n    if ((result = (NETWORK_INTERFACE_DESCRIPTION*)malloc(sizeof(NETWORK_INTERFACE_DESCRIPTION))) == NULL)\n    {\n        LogError(\"Failed allocating NETWORK_INTERFACE_DESCRIPTION\");\n    }\n    else if ((result->name = (char*)malloc(sizeof(char) * (strlen(ifr->ifr_name) + 1))) == NULL)\n    {\n        LogError(\"failed setting interface description name (malloc failed)\");\n        destroy_network_interface_descriptions(result);\n        result = NULL;\n    }\n    else\n    {\n        strcpy(result->name, ifr->ifr_name);\n        char* ip_address;\n        unsigned char* mac = (unsigned char*)ifr->ifr_hwaddr.sa_data;\n        if ((result->mac_address = (char*)malloc(sizeof(char) * MAC_ADDRESS_STRING_LENGTH)) == NULL)\n        {\n            LogError(\"failed formatting mac address (malloc failed)\");\n            destroy_network_interface_descriptions(result);\n            result = NULL;\n        }\n        else if (sprintf(result->mac_address, \"%02X:%02X:%02X:%02X:%02X:%02X\", mac[0],mac[1],mac[2],mac[3],mac[4],mac[5]) <= 0)\n        {\n            LogError(\"failed formatting mac address (sprintf failed)\");\n            destroy_network_interface_descriptions(result);\n            result = NULL;\n        }\n        else if ((ip_address = inet_ntoa(((struct sockaddr_in*)&ifr->ifr_addr)->sin_addr)) == NULL)\n        {\n            LogError(\"failed setting the ip address (inet_ntoa failed)\");\n            destroy_network_interface_descriptions(result);\n            result = NULL;\n        }\n        else if ((result->ip_address = (char*)malloc(sizeof(char) * (strlen(ip_address) + 1))) == NULL)\n        {\n            LogError(\"failed setting the ip address (malloc failed)\");\n            destroy_network_interface_descriptions(result);\n            result = NULL;\n        }\n        else\n        {\n            strcpy(result->ip_address, ip_address);\n            result->next = NULL;\n            if (previous_nid != NULL)\n            {\n                previous_nid->next = result;\n            }\n        }\n    }\n    return result;\n}", "target": 1}
{"code": "static int process_options(int argc, char *argv[], char *operation)\n{\n  int error= 0;\n  int i= 0;\n  if ((error= handle_options(&argc, &argv, my_long_options, get_one_option)))\n    goto exit;\n  if (opt_print_defaults)\n  {\n    error= -1;\n    goto exit;\n  }\n  if (opt_basedir)\n  {\n    i= (int)strlength(opt_basedir);\n    if (opt_basedir[i-1] != FN_LIBCHAR || opt_basedir[i-1] != FN_LIBCHAR2)\n    {\n      char buff[FN_REFLEN];\n      memset(buff, 0, sizeof(buff));\n      strncpy(buff, opt_basedir, sizeof(buff) - 1);\n#ifdef __WIN__\n      strncat(buff, \"/\", sizeof(buff) - strlen(buff) - 1);\n#else\n      strncat(buff, FN_DIRSEP, sizeof(buff) - strlen(buff) - 1);\n#endif\n      buff[sizeof(buff) - 1]= 0;\n      my_free(opt_basedir);\n      opt_basedir= my_strdup(buff, MYF(MY_FAE));\n    }\n  }\n  if (!opt_no_defaults && ((error= get_default_values())))\n  {\n    error= -1;\n    goto exit;\n  }\n  strcpy(operation, \"\");\n  if ((error = check_options(argc, argv, operation)))\n  {\n    goto exit;\n  }\n  if (opt_verbose)\n  {\n    printf(\"#    basedir = %s\\n\", opt_basedir);\n    printf(\"# plugin_dir = %s\\n\", opt_plugin_dir);\n    printf(\"#    datadir = %s\\n\", opt_datadir);\n    printf(\"# plugin_ini = %s\\n\", opt_plugin_ini);\n  }\nexit:\n  return error;\n}", "target": 0}
{"code": "void streamGetEdgeID(stream *s, int first, int skip_tombstones, streamID *edge_id)\n{\n    streamIterator si;\n    int64_t numfields;\n    streamIteratorStart(&si,s,NULL,NULL,!first);\n    si.skip_tombstones = skip_tombstones;\n    int found = streamIteratorGetID(&si,edge_id,&numfields);\n    if (!found) {\n        streamID min_id = {0, 0}, max_id = {UINT64_MAX, UINT64_MAX};\n        *edge_id = first ? max_id : min_id;\n    }\n}", "target": 1}
{"code": "    std::string& attrf(int ncid, int varId, const char * attrName, std::string& alloc)\n    {\n        alloc = \"\";\n        size_t len = 0;\n        nc_inq_attlen(ncid, varId, attrName, &len);\n        if(len < 1)\n        {\n            return alloc;\n        }\n        char attr_vals[NC_MAX_NAME + 1];\n        memset(attr_vals, 0, NC_MAX_NAME + 1);\n        if(nc_get_att_text(ncid, varId, attrName, attr_vals) != NC_NOERR)\n        {\n            return alloc;\n        }\n        alloc = std::string(attr_vals);\n        return alloc;\n    }", "target": 1}
{"code": "NavigatorServiceWorker* NavigatorServiceWorker::from(Document& document)\n{\n    if (!document.frame() || !document.frame()->domWindow())\n        return nullptr;\n    Navigator& navigator = *document.frame()->domWindow()->navigator();\n    return &from(navigator);\n}", "target": 0}
{"code": "static void sas_init_port(struct asd_sas_port *port,\n\t\t\t  struct sas_ha_struct *sas_ha, int i)\n{\n\tmemset(port, 0, sizeof(*port));\n\tport->id = i;\n\tINIT_LIST_HEAD(&port->dev_list);\n\tINIT_LIST_HEAD(&port->disco_list);\n\tINIT_LIST_HEAD(&port->destroy_list);\n\tINIT_LIST_HEAD(&port->sas_port_del_list);\n\tspin_lock_init(&port->phy_list_lock);\n\tINIT_LIST_HEAD(&port->phy_list);\n\tport->ha = sas_ha;\n\tspin_lock_init(&port->dev_list_lock);\n}", "target": 0}
{"code": "Mgr::IoActionData::operator += (const IoActionData& stats)\n{\n    http_reads += stats.http_reads;\n    for (int i = 0; i < IoStats::histSize; ++i)\n        http_read_hist[i] += stats.http_read_hist[i];\n    ftp_reads += stats.ftp_reads;\n    for (int i = 0; i < IoStats::histSize; ++i)\n        ftp_read_hist[i] += stats.ftp_read_hist[i];\n    gopher_reads += stats.gopher_reads;\n    for (int i = 0; i < IoStats::histSize; ++i)\n        gopher_read_hist[i] += stats.gopher_read_hist[i];\n    return *this;\n}", "target": 1}
{"code": "int ScriptController::contextDebugId(v8::Handle<v8::Context> context)\n{\n    return V8PerContextDebugData::contextDebugId(context);\n}", "target": 0}
{"code": "ahcp_time_print(netdissect_options *ndo,\n                const u_char *cp, uint8_t len)\n{\n\ttime_t t;\n\tstruct tm *tm;\n\tchar buf[BUFSIZE];\n\tif (len != 4)\n\t\tgoto invalid;\n\tt = GET_BE_U_4(cp);\n\tif (NULL == (tm = gmtime(&t)))\n\t\tND_PRINT(\": gmtime() error\");\n\telse if (0 == strftime(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\", tm))\n\t\tND_PRINT(\": strftime() error\");\n\telse\n\t\tND_PRINT(\": %s UTC\", buf);\n\treturn;\ninvalid:\n\tnd_print_invalid(ndo);\n\tND_TCHECK_LEN(cp, len);\n}", "target": 1}
{"code": "ciEnv::~ciEnv() {\n  CompilerThread* current_thread = CompilerThread::current();\n  _factory->remove_symbols();\n  GUARDED_VM_ENTRY(current_thread->set_env(NULL);)\n}", "target": 0}
{"code": "static int cp2112_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tunsigned long flags;\n\tint ret;\n\tspin_lock_irqsave(&dev->lock, flags);\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_CONFIG_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO config: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\tbuf[1] &= ~(1 << offset);\n\tbuf[2] = gpio_push_pull;\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"error setting GPIO config: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\tret = 0;\nexit:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\treturn ret <= 0 ? ret : -EIO;\n}", "target": 1}
{"code": "static bool __init is_skylake_era(void)\n{\n\tif (boot_cpu_data.x86_vendor == X86_VENDOR_INTEL &&\n\t    boot_cpu_data.x86 == 6) {\n\t\tswitch (boot_cpu_data.x86_model) {\n\t\tcase INTEL_FAM6_SKYLAKE_MOBILE:\n\t\tcase INTEL_FAM6_SKYLAKE_DESKTOP:\n\t\tcase INTEL_FAM6_SKYLAKE_X:\n\t\tcase INTEL_FAM6_KABYLAKE_MOBILE:\n\t\tcase INTEL_FAM6_KABYLAKE_DESKTOP:\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "target": 1}
{"code": "static int uvesafb_setcmap(struct fb_cmap *cmap, struct fb_info *info)\n{\n\tstruct uvesafb_pal_entry *entries;\n\tint shift = 16 - dac_width;\n\tint i, err = 0;\n\tif (info->var.bits_per_pixel == 8) {\n\t\tif (cmap->start + cmap->len > info->cmap.start +\n\t\t    info->cmap.len || cmap->start < info->cmap.start)\n\t\t\treturn -EINVAL;\n\t\tentries = kmalloc(sizeof(*entries) * cmap->len, GFP_KERNEL);\n\t\tif (!entries)\n\t\t\treturn -ENOMEM;\n\t\tfor (i = 0; i < cmap->len; i++) {\n\t\t\tentries[i].red   = cmap->red[i]   >> shift;\n\t\t\tentries[i].green = cmap->green[i] >> shift;\n\t\t\tentries[i].blue  = cmap->blue[i]  >> shift;\n\t\t\tentries[i].pad   = 0;\n\t\t}\n\t\terr = uvesafb_setpalette(entries, cmap->len, cmap->start, info);\n\t\tkfree(entries);\n\t} else {\n\t\tfor (i = 0; i < cmap->len; i++) {\n\t\t\terr |= uvesafb_setcolreg(cmap->start + i, cmap->red[i],\n\t\t\t\t\t\tcmap->green[i], cmap->blue[i],\n\t\t\t\t\t\t0, info);\n\t\t}\n\t}\n\treturn err;\n}", "target": 1}
{"code": "int bad_format_imginfo(\n    char *fmt)\n{\n    char     *ptr;\n    int       n = 0;\n    ptr = fmt;\n    while (*ptr != '\\0')\n        if (*ptr++ == '%') {\n            if (*ptr == '\\0')\n                return 1;\n            if (*ptr == '%')\n                ptr++;\n            else if (*ptr == 's' || *ptr == 'S') {\n                n = 1;\n                ptr++;\n            }\n            else {\n                if (*ptr == ' ')\n                    ptr++;\n                while (*ptr >= '0' && *ptr <= '9')\n                    ptr++;\n                if (*ptr++ != 'l')\n                    return 1;\n                if (*ptr == 'u')\n                    ptr++;\n                else\n                    return 1;\n                n++;\n            }\n        }\n    return (n != 3);\n}", "target": 1}
{"code": "Network::TransportSocketPtr ClientSslSocketFactory::createTransportSocket(\n    Network::TransportSocketOptionsConstSharedPtr transport_socket_options,\n    Upstream::HostDescriptionConstSharedPtr) const {\n  Envoy::Ssl::ClientContextSharedPtr ssl_ctx;\n  {\n    absl::ReaderMutexLock l(&ssl_ctx_mu_);\n    ssl_ctx = ssl_ctx_;\n  }\n  if (ssl_ctx) {\n    return std::make_unique<SslSocket>(std::move(ssl_ctx), InitialState::Client,\n                                       transport_socket_options, config_->createHandshaker());\n  } else {\n    ENVOY_LOG(debug, \"Create NotReadySslSocket\");\n    stats_.upstream_context_secrets_not_ready_.inc();\n    return std::make_unique<NotReadySslSocket>();\n  }\n}", "target": 1}
{"code": "ptaReadStream(FILE  *fp)\n{\nchar       typestr[128];\nl_int32    i, n, ix, iy, type, version;\nl_float32  x, y;\nPTA       *pta;\n    PROCNAME(\"ptaReadStream\");\n    if (!fp)\n        return (PTA *)ERROR_PTR(\"stream not defined\", procName, NULL);\n    if (fscanf(fp, \"\\n Pta Version %d\\n\", &version) != 1)\n        return (PTA *)ERROR_PTR(\"not a pta file\", procName, NULL);\n    if (version != PTA_VERSION_NUMBER)\n        return (PTA *)ERROR_PTR(\"invalid pta version\", procName, NULL);\n    if (fscanf(fp, \" Number of pts = %d; format = %s\\n\", &n, typestr) != 2)\n        return (PTA *)ERROR_PTR(\"not a pta file\", procName, NULL);\n    if (!strcmp(typestr, \"float\"))\n        type = 0;\n    else  \n        type = 1;\n    if ((pta = ptaCreate(n)) == NULL)\n        return (PTA *)ERROR_PTR(\"pta not made\", procName, NULL);\n    for (i = 0; i < n; i++) {\n        if (type == 0) {  \n            if (fscanf(fp, \"   (%f, %f)\\n\", &x, &y) != 2) {\n                ptaDestroy(&pta);\n                return (PTA *)ERROR_PTR(\"error reading floats\", procName, NULL);\n            }\n            ptaAddPt(pta, x, y);\n        } else {   \n            if (fscanf(fp, \"   (%d, %d)\\n\", &ix, &iy) != 2) {\n                ptaDestroy(&pta);\n                return (PTA *)ERROR_PTR(\"error reading ints\", procName, NULL);\n            }\n            ptaAddPt(pta, ix, iy);\n        }\n    }\n    return pta;\n}", "target": 1}
{"code": "static int su3000_power_ctrl(struct dvb_usb_device *d, int i)\n{\n\tstruct dw2102_state *state = (struct dw2102_state *)d->priv;\n\tu8 obuf[] = {0xde, 0};\n\tinfo(\"%s: %d, initialized %d\", __func__, i, state->initialized);\n\tif (i && !state->initialized) {\n\t\tstate->initialized = 1;\n\t\treturn dvb_usb_generic_rw(d, obuf, 2, NULL, 0, 0);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void net_tx_pkt_update_ip_hdr_checksum(struct NetTxPkt *pkt)\n{\n    uint16_t csum;\n    assert(pkt);\n    struct ip_header *ip_hdr;\n    ip_hdr = pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base;\n    ip_hdr->ip_len = cpu_to_be16(pkt->payload_len +\n        pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_len);\n    ip_hdr->ip_sum = 0;\n    csum = net_raw_checksum((uint8_t *)ip_hdr,\n        pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_len);\n    ip_hdr->ip_sum = cpu_to_be16(csum);\n}", "target": 0}
{"code": "void test_mknod(const char *path)\n{\n\tif (mknod(path, 0755, makedev(0, 0)) == 0) {\n\t\tfprintf(stderr, \"leak at mknod of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at mknod of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "fbFetchPixel_g1 (const FbBits *bits, int offset, miIndexedPtr indexed)\n{\n    CARD32 pixel = ((CARD32 *)bits)[offset >> 5];\n    CARD32 a;\n#if BITMAP_BIT_ORDER == MSBFirst\n    a = pixel >> (0x1f - (offset & 0x1f));\n#else\n    a = pixel >> (offset & 0x1f);\n#endif\n    a = a & 1;\n    return indexed->rgba[a];\n}", "target": 0}
{"code": "OJPEGDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)\n{\n        static const char module[]=\"OJPEGDecode\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\t(void)s;\n        if( !sp->decoder_ok )\n        {\n            TIFFErrorExt(tif->tif_clientdata,module,\"Cannot decode: decoder not correctly initialized\");\n            return 0;\n        }\n\tif (sp->libjpeg_jpeg_query_style==0)\n\t{\n\t\tif (OJPEGDecodeRaw(tif,buf,cc)==0)\n\t\t\treturn(0);\n\t}\n\telse\n\t{\n\t\tif (OJPEGDecodeScanlines(tif,buf,cc)==0)\n\t\t\treturn(0);\n\t}\n\treturn(1);\n}", "target": 0}
{"code": "void GLES2DecoderImpl::DoVertexAttrib1f(GLuint index, GLfloat v0) {\n  VertexAttribManager::VertexAttribInfo* info =\n      vertex_attrib_manager_->GetVertexAttribInfo(index);\n  if (!info) {\n    SetGLError(GL_INVALID_VALUE, \"glVertexAttrib1f: index out of range\");\n    return;\n  }\n  VertexAttribManager::VertexAttribInfo::Vec4 value;\n  value.v[0] = v0;\n  value.v[1] = 0.0f;\n  value.v[2] = 0.0f;\n  value.v[3] = 1.0f;\n  info->set_value(value);\n  glVertexAttrib1f(index, v0);\n}", "target": 0}
{"code": "static int update_prepare_order_info(rdpContext* context, ORDER_INFO* orderInfo, UINT32 orderType)\n{\n\tint length = 1;\n\torderInfo->fieldFlags = 0;\n\torderInfo->orderType = orderType;\n\torderInfo->controlFlags = ORDER_STANDARD;\n\torderInfo->controlFlags |= ORDER_TYPE_CHANGE;\n\tlength += 1;\n\tlength += PRIMARY_DRAWING_ORDER_FIELD_BYTES[orderInfo->orderType];\n\tlength += update_prepare_bounds(context, orderInfo);\n\treturn length;\n}", "target": 1}
{"code": "x509_vfy_callback_indicate_completion(X509_STORE_CTX *ctx)\n{\n\treturn x509_vfy_internal_verify(ctx, 1);\n}", "target": 0}
{"code": "int main()\n{\n    gdImagePtr im;\n    im = gdImageCreate(64970, 65111);\n    gdTestAssert(im == NULL);\n    return gdNumFailures();\n}", "target": 0}
{"code": "xfs_attr3_leaf_clearflag(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tint namelen;\n\tchar *name;\n#endif \n\ttrace_xfs_attr_leaf_clearflag(args);\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn(error);\n\tleaf = bp->b_addr;\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tASSERT(entry->flags & XFS_ATTR_INCOMPLETE);\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(args->index < ichdr.count);\n\tASSERT(args->index >= 0);\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tnamelen = name_loc->namelen;\n\t\tname = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tnamelen = name_rmt->namelen;\n\t\tname = (char *)name_rmt->name;\n\t}\n\tASSERT(be32_to_cpu(entry->hashval) == args->hashval);\n\tASSERT(namelen == args->namelen);\n\tASSERT(memcmp(name, args->name, namelen) == 0);\n#endif \n\tentry->flags &= ~XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\tif (args->rmtblkno) {\n\t\tASSERT((entry->flags & XFS_ATTR_LOCAL) == 0);\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tname_rmt->valueblk = cpu_to_be32(args->rmtblkno);\n\t\tname_rmt->valuelen = cpu_to_be32(args->valuelen);\n\t\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, name_rmt, sizeof(*name_rmt)));\n\t}\n\treturn xfs_trans_roll(&args->trans, args->dp);\n}", "target": 1}
{"code": "snmp_mib_find_next(uint32_t *oid)\n{\n  snmp_mib_resource_t *resource;\n  resource = NULL;\n  for(resource = list_head(snmp_mib);\n      resource; resource = resource->next) {\n    if(snmp_oid_cmp_oid(resource->oid, oid) > 0) {\n      return resource;\n    }\n  }\n  return NULL;\n}", "target": 1}
{"code": "bgp_auth_parse (struct peer *peer, u_char *pnt, size_t length)\n{\n  bgp_notify_send (peer, \n\t\t   BGP_NOTIFY_OPEN_ERR, \n\t\t   BGP_NOTIFY_OPEN_AUTH_FAILURE); \n  return -1;\n}", "target": 1}
{"code": "void RootWindowHostWin::OnPaint(HDC dc) {\n  root_window_->Draw();\n  ValidateRect(hwnd(), NULL);\n}", "target": 0}
{"code": "static void emulator_get_fpu(struct x86_emulate_ctxt *ctxt)\n{\n\tpreempt_disable();\n\tkvm_load_guest_fpu(emul_to_vcpu(ctxt));\n\tclts();\n}", "target": 0}
{"code": "static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len,\n        bigint *modulus, bigint *pub_exp)\n{\n    int i, size;\n    bigint *decrypted_bi, *dat_bi;\n    bigint *bir = NULL;\n    uint8_t *block = (uint8_t *)malloc(sig_len);\n    dat_bi = bi_import(ctx, sig, sig_len);\n    ctx->mod_offset = BIGINT_M_OFFSET;\n    decrypted_bi = bi_mod_power2(ctx, dat_bi, modulus, pub_exp);\n    bi_export(ctx, decrypted_bi, block, sig_len);\n    ctx->mod_offset = BIGINT_M_OFFSET;\n    i = 10; \n    while (block[i++] && i < sig_len);\n    size = sig_len - i;\n    if (size > 0)\n    {\n        int len;\n        const uint8_t *sig_ptr = get_signature(&block[i], &len);\n        if (sig_ptr)\n        {\n            bir = bi_import(ctx, sig_ptr, len);\n        }\n    }\n    free(block);\n    bi_clear_cache(ctx);\n    return bir;\n}", "target": 1}
{"code": "int ssl_init( ssl_context *ssl )\n{\n    int ret;\n    int len = SSL_BUFFER_LEN;\n    memset( ssl, 0, sizeof( ssl_context ) );\n    ssl->rsa_decrypt = ssl_rsa_decrypt;\n    ssl->rsa_sign = ssl_rsa_sign;\n    ssl->rsa_key_len = ssl_rsa_key_len;\n    ssl->min_major_ver = SSL_MAJOR_VERSION_3;\n    ssl->min_minor_ver = SSL_MINOR_VERSION_0;\n    ssl->ciphersuites = ssl_default_ciphersuites;\n#if defined(POLARSSL_DHM_C)\n    if( ( ret = mpi_read_string( &ssl->dhm_P, 16,\n                                 POLARSSL_DHM_RFC5114_MODP_1024_P) ) != 0 ||\n        ( ret = mpi_read_string( &ssl->dhm_G, 16,\n                                 POLARSSL_DHM_RFC5114_MODP_1024_G) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"mpi_read_string\", ret );\n        return( ret );\n    }\n#endif\n    ssl->in_ctr = (unsigned char *) malloc( len );\n    ssl->in_hdr = ssl->in_ctr +  8;\n    ssl->in_msg = ssl->in_ctr + 13;\n    if( ssl->in_ctr == NULL )\n    {\n        SSL_DEBUG_MSG( 1, ( \"malloc(%d bytes) failed\", len ) );\n        return( POLARSSL_ERR_SSL_MALLOC_FAILED );\n    }\n    ssl->out_ctr = (unsigned char *) malloc( len );\n    ssl->out_hdr = ssl->out_ctr +  8;\n    ssl->out_msg = ssl->out_ctr + 40;\n    if( ssl->out_ctr == NULL )\n    {\n        SSL_DEBUG_MSG( 1, ( \"malloc(%d bytes) failed\", len ) );\n        free( ssl-> in_ctr );\n        return( POLARSSL_ERR_SSL_MALLOC_FAILED );\n    }\n    memset( ssl-> in_ctr, 0, SSL_BUFFER_LEN );\n    memset( ssl->out_ctr, 0, SSL_BUFFER_LEN );\n    ssl->hostname = NULL;\n    ssl->hostname_len = 0;\n    if( ( ret = ssl_handshake_init( ssl ) ) != 0 )\n        return( ret );\n    return( 0 );\n}", "target": 0}
{"code": "beep_print(netdissect_options *ndo, const u_char *bp, u_int length)\n{\n\tif (l_strnstart(\"MSG\", 4, (const char *)bp, length)) \n\t\tND_PRINT((ndo, \" BEEP MSG\"));\n\telse if (l_strnstart(\"RPY \", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP RPY\"));\n\telse if (l_strnstart(\"ERR \", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP ERR\"));\n\telse if (l_strnstart(\"ANS \", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP ANS\"));\n\telse if (l_strnstart(\"NUL \", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP NUL\"));\n\telse if (l_strnstart(\"SEQ \", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP SEQ\"));\n\telse if (l_strnstart(\"END\", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP END\"));\n\telse\n\t\tND_PRINT((ndo, \" BEEP (payload or undecoded)\"));\n}", "target": 1}
{"code": "void nf_tables_activate_set(const struct nft_ctx *ctx, struct nft_set *set)\n{\n\tif (nft_set_is_anonymous(set))\n\t\tnft_clear(ctx->net, set);\n\tset->use++;\n}", "target": 0}
{"code": "privsep_preauth(Authctxt *authctxt)\n{\n\tint status, r;\n\tpid_t pid;\n\tstruct ssh_sandbox *box = NULL;\n\tpmonitor = monitor_init();\n\tpmonitor->m_pkex = &active_state->kex;\n\tif (use_privsep == PRIVSEP_ON)\n\t\tbox = ssh_sandbox_init();\n\tpid = fork();\n\tif (pid == -1) {\n\t\tfatal(\"fork of unprivileged child failed\");\n\t} else if (pid != 0) {\n\t\tdebug2(\"Network child is on pid %ld\", (long)pid);\n\t\tpmonitor->m_pid = pid;\n\t\tif (have_agent) {\n\t\t\tr = ssh_get_authentication_socket(&auth_sock);\n\t\t\tif (r != 0) {\n\t\t\t\terror(\"Could not get agent socket: %s\",\n\t\t\t\t    ssh_err(r));\n\t\t\t\thave_agent = 0;\n\t\t\t}\n\t\t}\n\t\tif (box != NULL)\n\t\t\tssh_sandbox_parent_preauth(box, pid);\n\t\tmonitor_child_preauth(authctxt, pmonitor);\n\t\tmonitor_sync(pmonitor);\n\t\twhile (waitpid(pid, &status, 0) < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tpmonitor->m_pid = -1;\n\t\t\tfatal(\"%s: waitpid: %s\", __func__, strerror(errno));\n\t\t}\n\t\tprivsep_is_preauth = 0;\n\t\tpmonitor->m_pid = -1;\n\t\tif (WIFEXITED(status)) {\n\t\t\tif (WEXITSTATUS(status) != 0)\n\t\t\t\tfatal(\"%s: preauth child exited with status %d\",\n\t\t\t\t    __func__, WEXITSTATUS(status));\n\t\t} else if (WIFSIGNALED(status))\n\t\t\tfatal(\"%s: preauth child terminated by signal %d\",\n\t\t\t    __func__, WTERMSIG(status));\n\t\tif (box != NULL)\n\t\t\tssh_sandbox_parent_finish(box);\n\t\treturn 1;\n\t} else {\n\t\tclose(pmonitor->m_sendfd);\n\t\tclose(pmonitor->m_log_recvfd);\n\t\tset_log_handler(mm_log_handler, pmonitor);\n\t\tprivsep_preauth_child();\n\t\tsetproctitle(\"%s\", \"[net]\");\n\t\tif (box != NULL)\n\t\t\tssh_sandbox_child(box);\n\t\treturn 0;\n\t}\n}", "target": 1}
{"code": "static inline uint16_t ok_inflater_can_write_total(const ok_inflater *inflater) {\n    return inflater->buffer_start_pos - inflater->buffer_end_pos - 1;\n}", "target": 0}
{"code": "\tSpawnPreparationInfo prepareSpawn(const Options &options) {\n\t\tTRACE_POINT();\n\t\tSpawnPreparationInfo info;\n\t\tprepareChroot(info, options);\n\t\tinfo.userSwitching = prepareUserSwitching(options);\n\t\tprepareSwitchingWorkingDirectory(info, options);\n\t\tinferApplicationInfo(info);\n\t\treturn info;\n\t}", "target": 1}
{"code": "read_nextline(void)\n{\nint len;\nuschar *p, *q;\nif (next_line != NULL)\n  {\n  uschar *yield = next_line;\n  next_line = NULL;\n  return yield;\n  }\nif (popto == 0)\n  {\n  pushstr *ps = pushed;\n  if (ps == NULL) error(12); else\n    {\n    popto = -1;\n    (void)sprintf(CS inbuffer, \"%s\\n\", ps->string);\n    pushed = ps->next;\n    free(ps);\n    return inbuffer;\n    }\n  }\nif (popto > 0)\n  {\n  pushstr *ps = pushed;\n  if (ps->letter == popto) popto = -1;  \n  (void)sprintf(CS inbuffer, \"%s\\n\", ps->string);\n  pushed = ps->next;\n  free(ps);\n  return inbuffer;\n  }\nif (from_type_ptr < 0) return NULL;\nfor (;;)\n  {\n  if (from_type[from_type_ptr] == FROM_MACRO)\n    {\n    if (macrocurrent->nextline == NULL)\n      {\n      macroexe *temp = macrocurrent;\n      macrocurrent = macrocurrent->prev;\n      macro_free(temp);\n      }\n    else\n      {\n      read_process_macroline(macrocurrent->nextline->string, inbuffer);\n      macrocurrent->nextline = macrocurrent->nextline->next;\n      break;\n      }\n    }\n  else\n    {\n    len = get_nextline(istack->file, inbuffer, INBUFFSIZE);\n    if (len < 0)\n      {\n      istackstr *prev = istack->prev;\n      fclose(istack->file);\n      free(istack);\n      istack = prev;\n      }\n    else\n      {\n      istack->linenumber++;\n      q = inbuffer;\n      for (;;)\n        {\n        p = q + len;\n        while (p > q && isspace(p[-1])) p--;\n        if (p - q < 3 || Ustrncmp(p - 3, \"&&&\", 3) != 0) break;\n        q = p - 3;\n        *q = 0;\n        if (istack == NULL) break;\n        len = get_nextline(istack->file, q, INBUFFSIZE - (q - inbuffer));\n        if (len < 0) break;\n        istack->linenumber++;\n        p = q;\n        while (*p == ' ' || *p == '\\t') { p++; len--; }\n        if (p > q) memmove(q, p, len + 1);\n        }\n      break;\n      }\n    }\n  if (--from_type_ptr < 0) return NULL;\n  }\nreturn inbuffer;\n}", "target": 1}
{"code": "PJ_DEF(void) pj_scan_skip_line( pj_scanner *scanner )\n{\n    char *s = pj_memchr(scanner->curptr, '\\n', scanner->end - scanner->curptr);\n    if (!s) {\n\tscanner->curptr = scanner->end;\n    } else {\n\tscanner->curptr = scanner->start_line = s+1;\n\tscanner->line++;\n   }\n}", "target": 1}
{"code": "int ssl_init(void) { \n#if OPENSSL_VERSION_NUMBER>=0x10100000L\n    OPENSSL_init_ssl(OPENSSL_INIT_LOAD_SSL_STRINGS |\n        OPENSSL_INIT_LOAD_CRYPTO_STRINGS | OPENSSL_INIT_LOAD_CONFIG, NULL);\n#else\n    OPENSSL_config(NULL);\n    SSL_load_error_strings();\n    SSL_library_init();\n#endif\n    index_ssl_cli=SSL_get_ex_new_index(0,\n        \"CLI pointer\", NULL, NULL, NULL);\n    index_ssl_ctx_opt=SSL_CTX_get_ex_new_index(0,\n        \"SERVICE_OPTIONS pointer\", NULL, NULL, NULL);\n    index_session_authenticated=SSL_SESSION_get_ex_new_index(0,\n        \"session authenticated\", NULL, NULL, NULL);\n    index_session_connect_address=SSL_SESSION_get_ex_new_index(0,\n        \"session connect address\", NULL, cb_dup_addr, cb_free_addr);\n    if(index_ssl_cli<0 || index_ssl_ctx_opt<0 ||\n            index_session_authenticated<0 ||\n            index_session_connect_address<0) {\n        s_log(LOG_ERR, \"Application specific data initialization failed\");\n        return 1;\n    }\n#ifndef OPENSSL_NO_ENGINE\n    ENGINE_load_builtin_engines();\n#endif\n#ifndef OPENSSL_NO_DH\n    dh_params=get_dh2048();\n    if(!dh_params) {\n        s_log(LOG_ERR, \"Failed to get default DH parameters\");\n        return 1;\n    }\n#endif \n    return 0;\n}", "target": 1}
{"code": "static int smb311_decode_neg_context(struct smb2_negotiate_rsp *rsp,\n\t\t\t\t     struct TCP_Server_Info *server,\n\t\t\t\t     unsigned int len_of_smb)\n{\n\tstruct smb2_neg_context *pctx;\n\tunsigned int offset = le32_to_cpu(rsp->NegotiateContextOffset);\n\tunsigned int ctxt_cnt = le16_to_cpu(rsp->NegotiateContextCount);\n\tunsigned int len_of_ctxts, i;\n\tint rc = 0;\n\tcifs_dbg(FYI, \"decoding %d negotiate contexts\\n\", ctxt_cnt);\n\tif (len_of_smb <= offset) {\n\t\tcifs_dbg(VFS, \"Invalid response: negotiate context offset\\n\");\n\t\treturn -EINVAL;\n\t}\n\tlen_of_ctxts = len_of_smb - offset;\n\tfor (i = 0; i < ctxt_cnt; i++) {\n\t\tint clen;\n\t\tif (len_of_ctxts == 0)\n\t\t\tbreak;\n\t\tif (len_of_ctxts < sizeof(struct smb2_neg_context))\n\t\t\tbreak;\n\t\tpctx = (struct smb2_neg_context *)(offset + (char *)rsp);\n\t\tclen = le16_to_cpu(pctx->DataLength);\n\t\tif (clen > len_of_ctxts)\n\t\t\tbreak;\n\t\tif (pctx->ContextType == SMB2_PREAUTH_INTEGRITY_CAPABILITIES)\n\t\t\tdecode_preauth_context(\n\t\t\t\t(struct smb2_preauth_neg_context *)pctx);\n\t\telse if (pctx->ContextType == SMB2_ENCRYPTION_CAPABILITIES)\n\t\t\trc = decode_encrypt_ctx(server,\n\t\t\t\t(struct smb2_encryption_neg_context *)pctx);\n\t\telse if (pctx->ContextType == SMB2_POSIX_EXTENSIONS_AVAILABLE)\n\t\t\tserver->posix_ext_supported = true;\n\t\telse\n\t\t\tcifs_dbg(VFS, \"unknown negcontext of type %d ignored\\n\",\n\t\t\t\tle16_to_cpu(pctx->ContextType));\n\t\tif (rc)\n\t\t\tbreak;\n\t\tclen = (clen + 7) & ~0x7;\n\t\toffset += clen + sizeof(struct smb2_neg_context);\n\t\tlen_of_ctxts -= clen;\n\t}\n\treturn rc;\n}", "target": 0}
{"code": "should_hex_escape (gunichar           c,\n                   FlatpakEscapeFlags flags)\n{\n  if ((flags & FLATPAK_ESCAPE_ALLOW_NEWLINES) && c == '\\n')\n    return FALSE;\n  return !is_char_safe (c);\n}", "target": 0}
{"code": "static bool isFloat(FormatCode code) { return code >= kFloat && code <= kDouble; }", "target": 0}
{"code": "static Jsi_RC jsi_ArrayFlatSub(Jsi_Interp *interp, Jsi_Obj* nobj, Jsi_Value *arr, int depth) {\n    int i, n = 0, len = Jsi_ObjGetLength(interp, arr->d.obj);\n    if (len <= 0) return JSI_OK;\n    Jsi_RC rc = JSI_OK;\n    int clen = Jsi_ObjGetLength(interp, nobj);\n    for (i = 0; i < len && rc == JSI_OK; i++) {\n        Jsi_Value *t = Jsi_ValueArrayIndex(interp, arr, i);\n        if (t && depth>0 && Jsi_ValueIsArray(interp, t))\n            rc = jsi_ArrayFlatSub(interp, nobj, t , depth-1);\n        else if (!Jsi_ValueIsUndef(interp, t))\n            Jsi_ObjArrayAdd(interp, nobj, t);\n        if ((++n + clen)>interp->maxArrayList)\n            return Jsi_LogError(\"array size exceeded\");\n    }\n    return rc;\n}", "target": 1}
{"code": "void ChromotingInstance::PostChromotingMessage(\n    const std::string& method,\n    scoped_ptr<base::DictionaryValue> data) {\n  scoped_ptr<base::DictionaryValue> message(new base::DictionaryValue());\n  message->SetString(\"method\", method);\n  message->Set(\"data\", data.release());\n  std::string message_json;\n  base::JSONWriter::Write(message.get(), &message_json);\n  PostMessage(pp::Var(message_json));\n}", "target": 0}
{"code": "static void *CFRdbLoad(RedisModuleIO *io, int encver) {\n    if (encver > CF_MIN_EXPANSION_VERSION) {\n        return NULL;\n    }\n    CuckooFilter *cf = RedisModule_Calloc(1, sizeof(*cf));\n    cf->numFilters = RedisModule_LoadUnsigned(io);\n    cf->numBuckets = RedisModule_LoadUnsigned(io);\n    cf->numItems = RedisModule_LoadUnsigned(io);\n    if (encver < CF_MIN_EXPANSION_VERSION) { \n        cf->numDeletes = 0;                  \n        cf->bucketSize = CF_DEFAULT_BUCKETSIZE;\n        cf->maxIterations = CF_MAX_ITERATIONS;\n        cf->expansion = CF_DEFAULT_EXPANSION;\n    } else {\n        cf->numDeletes = RedisModule_LoadUnsigned(io);\n        cf->bucketSize = RedisModule_LoadUnsigned(io);\n        cf->maxIterations = RedisModule_LoadUnsigned(io);\n        cf->expansion = RedisModule_LoadUnsigned(io);\n    }\n    cf->filters = RedisModule_Calloc(cf->numFilters, sizeof(*cf->filters));\n    for (size_t ii = 0, exp = 1; ii < cf->numFilters; ++ii, exp *= cf->expansion) {\n        cf->filters[ii].bucketSize = cf->bucketSize;\n        if (encver < CF_MIN_EXPANSION_VERSION) {\n            cf->filters[ii].numBuckets = cf->numBuckets;\n        } else {\n            cf->filters[ii].numBuckets = RedisModule_LoadUnsigned(io);\n        }\n        size_t lenDummy = 0;\n        cf->filters[ii].data = (MyCuckooBucket *)RedisModule_LoadStringBuffer(io, &lenDummy);\n        assert(cf->filters[ii].data != NULL && lenDummy == cf->filters[ii].bucketSize *\n                                                               cf->filters[ii].numBuckets *\n                                                               sizeof(*cf->filters[ii].data));\n    }\n    return cf;\n}", "target": 1}
{"code": "SslSocket::create(Envoy::Ssl::ContextSharedPtr ctx, InitialState state,\n                  const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options,\n                  Ssl::HandshakerFactoryCb handshaker_factory_cb) {\n  std::unique_ptr<SslSocket> socket(new SslSocket(ctx, transport_socket_options));\n  auto status = socket->initialize(state, handshaker_factory_cb);\n  if (status.ok()) {\n    return socket;\n  } else {\n    return status;\n  }\n}", "target": 0}
{"code": "static void lan78xx_disconnect(struct usb_interface *intf)\n{\n\tstruct lan78xx_net *dev;\n\tstruct usb_device *udev;\n\tstruct net_device *net;\n\tstruct phy_device *phydev;\n\tdev = usb_get_intfdata(intf);\n\tusb_set_intfdata(intf, NULL);\n\tif (!dev)\n\t\treturn;\n\tset_bit(EVENT_DEV_DISCONNECT, &dev->flags);\n\tnetif_napi_del(&dev->napi);\n\tudev = interface_to_usbdev(intf);\n\tnet = dev->net;\n\tunregister_netdev(net);\n\tcancel_delayed_work_sync(&dev->wq);\n\tphydev = net->phydev;\n\tphy_unregister_fixup_for_uid(PHY_KSZ9031RNX, 0xfffffff0);\n\tphy_unregister_fixup_for_uid(PHY_LAN8835, 0xfffffff0);\n\tphy_disconnect(net->phydev);\n\tif (phy_is_pseudo_fixed_link(phydev))\n\t\tfixed_phy_unregister(phydev);\n\tusb_scuttle_anchored_urbs(&dev->deferred);\n\tif (timer_pending(&dev->stat_monitor))\n\t\tdel_timer_sync(&dev->stat_monitor);\n\tlan78xx_unbind(dev, intf);\n\tlan78xx_free_tx_resources(dev);\n\tlan78xx_free_rx_resources(dev);\n\tusb_kill_urb(dev->urb_intr);\n\tusb_free_urb(dev->urb_intr);\n\tfree_netdev(net);\n\tusb_put_dev(udev);\n}", "target": 1}
{"code": "static int command_read(struct pci_dev *dev, int offset, u16 *value, void *data)\n{\n\tint i;\n\tint ret;\n\tret = xen_pcibk_read_config_word(dev, offset, value, data);\n\tif (!pci_is_enabled(dev))\n\t\treturn ret;\n\tfor (i = 0; i < PCI_ROM_RESOURCE; i++) {\n\t\tif (dev->resource[i].flags & IORESOURCE_IO)\n\t\t\t*value |= PCI_COMMAND_IO;\n\t\tif (dev->resource[i].flags & IORESOURCE_MEM)\n\t\t\t*value |= PCI_COMMAND_MEMORY;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static void mov_parse_stsd_subtitle(MOVContext *c, AVIOContext *pb,\n                                    AVStream *st, MOVStreamContext *sc,\n                                    int64_t size)\n{\n    MOVAtom fake_atom = { .size = size };\n    if (st->codecpar->codec_tag != AV_RL32(\"mp4s\"))\n        mov_read_glbl(c, pb, fake_atom);\n    st->codecpar->width  = sc->width;\n    st->codecpar->height = sc->height;\n}", "target": 0}
{"code": "void sqlite3SelectReset(Parse *pParse, Select *p){\n  if( ALWAYS(p) ){\n    clearSelect(pParse->db, p, 0);\n    memset(&p->iLimit, 0, sizeof(Select) - offsetof(Select,iLimit));\n    p->pEList = sqlite3ExprListAppend(pParse, 0,\n                     sqlite3ExprAlloc(pParse->db,TK_NULL,0,0));\n    p->pSrc = sqlite3DbMallocZero(pParse->db, sizeof(SrcList));\n  }\n}", "target": 0}
{"code": "static CACHE_BITMAP_V3_ORDER* update_read_cache_bitmap_v3_order(rdpUpdate* update, wStream* s,\n                                                                UINT16 flags)\n{\n\tBYTE bitsPerPixelId;\n\tBITMAP_DATA_EX* bitmapData;\n\tUINT32 new_len;\n\tBYTE* new_data;\n\tCACHE_BITMAP_V3_ORDER* cache_bitmap_v3;\n\tif (!update || !s)\n\t\treturn NULL;\n\tcache_bitmap_v3 = calloc(1, sizeof(CACHE_BITMAP_V3_ORDER));\n\tif (!cache_bitmap_v3)\n\t\tgoto fail;\n\tcache_bitmap_v3->cacheId = flags & 0x00000003;\n\tcache_bitmap_v3->flags = (flags & 0x0000FF80) >> 7;\n\tbitsPerPixelId = (flags & 0x00000078) >> 3;\n\tcache_bitmap_v3->bpp = CBR23_BPP[bitsPerPixelId];\n\tif (Stream_GetRemainingLength(s) < 21)\n\t\tgoto fail;\n\tStream_Read_UINT16(s, cache_bitmap_v3->cacheIndex); \n\tStream_Read_UINT32(s, cache_bitmap_v3->key1);       \n\tStream_Read_UINT32(s, cache_bitmap_v3->key2);       \n\tbitmapData = &cache_bitmap_v3->bitmapData;\n\tStream_Read_UINT8(s, bitmapData->bpp);\n\tif ((bitmapData->bpp < 1) || (bitmapData->bpp > 32))\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"invalid bpp value %\" PRIu32 \"\", bitmapData->bpp);\n\t\tgoto fail;\n\t}\n\tStream_Seek_UINT8(s);                      \n\tStream_Seek_UINT8(s);                      \n\tStream_Read_UINT8(s, bitmapData->codecID); \n\tStream_Read_UINT16(s, bitmapData->width);  \n\tStream_Read_UINT16(s, bitmapData->height); \n\tStream_Read_UINT32(s, new_len);            \n\tif (Stream_GetRemainingLength(s) < new_len)\n\t\tgoto fail;\n\tnew_data = (BYTE*)realloc(bitmapData->data, new_len);\n\tif (!new_data)\n\t\tgoto fail;\n\tbitmapData->data = new_data;\n\tbitmapData->length = new_len;\n\tStream_Read(s, bitmapData->data, bitmapData->length);\n\treturn cache_bitmap_v3;\nfail:\n\tfree_cache_bitmap_v3_order(update->context, cache_bitmap_v3);\n\treturn NULL;\n}", "target": 1}
{"code": "int ConnectionImpl::onHeadersCompleteBase() {\n  ENVOY_CONN_LOG(trace, \"headers complete\", connection_);\n  completeLastHeader();\n  ASSERT(current_header_map_->byteSize().has_value() &&\n         current_header_map_->byteSize() == current_header_map_->byteSizeInternal());\n  if (!(parser_.http_major == 1 && parser_.http_minor == 1)) {\n    protocol_ = Protocol::Http10;\n  }\n  if (Utility::isUpgrade(*current_header_map_)) {\n    if (current_header_map_->Upgrade() &&\n        absl::EqualsIgnoreCase(current_header_map_->Upgrade()->value().getStringView(),\n                               Http::Headers::get().UpgradeValues.H2c)) {\n      ENVOY_CONN_LOG(trace, \"removing unsupported h2c upgrade headers.\", connection_);\n      current_header_map_->removeUpgrade();\n      if (current_header_map_->Connection()) {\n        const auto& tokens_to_remove = caseUnorderdSetContainingUpgradeAndHttp2Settings();\n        std::string new_value = StringUtil::removeTokens(\n            current_header_map_->Connection()->value().getStringView(), \",\", tokens_to_remove, \",\");\n        if (new_value.empty()) {\n          current_header_map_->removeConnection();\n        } else {\n          current_header_map_->Connection()->value(new_value);\n        }\n      }\n      current_header_map_->remove(Headers::get().Http2Settings);\n    } else {\n      ENVOY_CONN_LOG(trace, \"codec entering upgrade mode.\", connection_);\n      handling_upgrade_ = true;\n    }\n  }\n  int rc = onHeadersComplete(std::move(current_header_map_));\n  current_header_map_.reset();\n  header_parsing_state_ = HeaderParsingState::Done;\n  return handling_upgrade_ ? 2 : rc;\n}", "target": 0}
{"code": "static BYTE get_bmf_bpp(UINT32 bmf, BOOL* pValid)\n{\n\tif (pValid)\n\t\t*pValid = TRUE;\n\tswitch (bmf)\n\t{\n\t\tcase 1:\n\t\t\treturn 1;\n\t\tcase 3:\n\t\t\treturn 8;\n\t\tcase 4:\n\t\t\treturn 16;\n\t\tcase 5:\n\t\t\treturn 24;\n\t\tcase 6:\n\t\t\treturn 32;\n\t\tdefault:\n\t\t\tWLog_WARN(TAG, \"Invalid bmf %\" PRIu32, bmf);\n\t\t\tif (pValid)\n\t\t\t\t*pValid = FALSE;\n\t\t\treturn 0;\n\t}\n}", "target": 0}
{"code": "Adaptation::Ecap::FirstLineRep::protocol() const\n{\n    switch (theMessage.http_ver.protocol) {\n    case AnyP::PROTO_HTTP:\n        return libecap::protocolHttp;\n    case AnyP::PROTO_HTTPS:\n        return libecap::protocolHttps;\n    case AnyP::PROTO_FTP:\n        return libecap::protocolFtp;\n    case AnyP::PROTO_GOPHER:\n        return libecap::protocolGopher;\n    case AnyP::PROTO_WAIS:\n        return libecap::protocolWais;\n    case AnyP::PROTO_WHOIS:\n        return libecap::protocolWhois;\n    case AnyP::PROTO_URN:\n        return libecap::protocolUrn;\n    case AnyP::PROTO_ICP:\n        return protocolIcp;\n#if USE_HTCP\n    case AnyP::PROTO_HTCP:\n        return protocolHtcp;\n#endif\n    case AnyP::PROTO_CACHE_OBJECT:\n        return protocolCacheObj;\n    case AnyP::PROTO_ICY:\n        return protocolIcy;\n    case AnyP::PROTO_COAP:\n    case AnyP::PROTO_COAPS: \n    case AnyP::PROTO_AUTHORITY_FORM:\n    case AnyP::PROTO_SSL:\n    case AnyP::PROTO_TLS:\n    case AnyP::PROTO_UNKNOWN:\n        return protocolUnknown; \n    case AnyP::PROTO_NONE:\n        return Name();\n    case AnyP::PROTO_MAX:\n        break; \n    }\n    Must(false); \n    return Name();\n}", "target": 1}
{"code": "GF_Err stbl_AppendTime(GF_SampleTableBox *stbl, u32 duration, u32 nb_pack)\n{\n\tGF_TimeToSampleBox *stts = stbl->TimeToSample;\n\tif (!nb_pack) nb_pack = 1;\n\tif (stts->nb_entries) {\n\t\tif (stts->entries[stts->nb_entries-1].sampleDelta == duration) {\n\t\t\tstts->entries[stts->nb_entries-1].sampleCount += nb_pack;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\tif (stts->nb_entries==stts->alloc_size) {\n\t\tALLOC_INC(stts->alloc_size);\n\t\tstts->entries = gf_realloc(stts->entries, sizeof(GF_SttsEntry)*stts->alloc_size);\n\t\tif (!stts->entries) return GF_OUT_OF_MEM;\n\t\tmemset(&stts->entries[stts->nb_entries], 0, sizeof(GF_SttsEntry)*(stts->alloc_size-stts->nb_entries) );\n\t}\n\tstts->entries[stts->nb_entries].sampleCount = nb_pack;\n\tstts->entries[stts->nb_entries].sampleDelta = duration;\n\tstts->nb_entries++;\n\tif (stts->max_ts_delta < duration ) stts->max_ts_delta = duration;\n\treturn GF_OK;\n}", "target": 1}
{"code": "static int snd_ctl_elem_user_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tint change;\n\tstruct user_element *ue = kcontrol->private_data;\n\tchange = memcmp(&ucontrol->value, ue->elem_data, ue->elem_data_size) != 0;\n\tif (change)\n\t\tmemcpy(ue->elem_data, &ucontrol->value, ue->elem_data_size);\n\treturn change;\n}", "target": 1}
{"code": "static long madvise_remove(struct vm_area_struct *vma,\n\t\t\t\tstruct vm_area_struct **prev,\n\t\t\t\tunsigned long start, unsigned long end)\n{\n\tloff_t offset;\n\tint error;\n\t*prev = NULL;\t\n\tif (vma->vm_flags & (VM_LOCKED|VM_NONLINEAR|VM_HUGETLB))\n\t\treturn -EINVAL;\n\tif (!vma->vm_file || !vma->vm_file->f_mapping\n\t\t|| !vma->vm_file->f_mapping->host) {\n\t\t\treturn -EINVAL;\n\t}\n\tif ((vma->vm_flags & (VM_SHARED|VM_WRITE)) != (VM_SHARED|VM_WRITE))\n\t\treturn -EACCES;\n\toffset = (loff_t)(start - vma->vm_start)\n\t\t\t+ ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n\tup_read(&current->mm->mmap_sem);\n\terror = do_fallocate(vma->vm_file,\n\t\t\t\tFALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE,\n\t\t\t\toffset, end - start);\n\tdown_read(&current->mm->mmap_sem);\n\treturn error;\n}", "target": 1}
{"code": "struct sk_buff **udp_gro_receive(struct sk_buff **head, struct sk_buff *skb,\n\t\t\t\t struct udphdr *uh)\n{\n\tstruct udp_offload_priv *uo_priv;\n\tstruct sk_buff *p, **pp = NULL;\n\tstruct udphdr *uh2;\n\tunsigned int off = skb_gro_offset(skb);\n\tint flush = 1;\n\tif (NAPI_GRO_CB(skb)->udp_mark ||\n\t    (skb->ip_summed != CHECKSUM_PARTIAL &&\n\t     NAPI_GRO_CB(skb)->csum_cnt == 0 &&\n\t     !NAPI_GRO_CB(skb)->csum_valid))\n\t\tgoto out;\n\tNAPI_GRO_CB(skb)->udp_mark = 1;\n\trcu_read_lock();\n\tuo_priv = rcu_dereference(udp_offload_base);\n\tfor (; uo_priv != NULL; uo_priv = rcu_dereference(uo_priv->next)) {\n\t\tif (net_eq(read_pnet(&uo_priv->net), dev_net(skb->dev)) &&\n\t\t    uo_priv->offload->port == uh->dest &&\n\t\t    uo_priv->offload->callbacks.gro_receive)\n\t\t\tgoto unflush;\n\t}\n\tgoto out_unlock;\nunflush:\n\tflush = 0;\n\tfor (p = *head; p; p = p->next) {\n\t\tif (!NAPI_GRO_CB(p)->same_flow)\n\t\t\tcontinue;\n\t\tuh2 = (struct udphdr   *)(p->data + off);\n\t\tif ((*(u32 *)&uh->source != *(u32 *)&uh2->source) ||\n\t\t    (!uh->check ^ !uh2->check)) {\n\t\t\tNAPI_GRO_CB(p)->same_flow = 0;\n\t\t\tcontinue;\n\t\t}\n\t}\n\tskb_gro_pull(skb, sizeof(struct udphdr)); \n\tskb_gro_postpull_rcsum(skb, uh, sizeof(struct udphdr));\n\tNAPI_GRO_CB(skb)->proto = uo_priv->offload->ipproto;\n\tpp = uo_priv->offload->callbacks.gro_receive(head, skb,\n\t\t\t\t\t\t     uo_priv->offload);\nout_unlock:\n\trcu_read_unlock();\nout:\n\tNAPI_GRO_CB(skb)->flush |= flush;\n\treturn pp;\n}", "target": 1}
{"code": "int snmp_helper(void *context, size_t hdrlen, unsigned char tag,\n\t\tconst void *data, size_t datalen)\n{\n\tstruct snmp_ctx *ctx = (struct snmp_ctx *)context;\n\t__be32 *pdata = (__be32 *)data;\n\tif (*pdata == ctx->from) {\n\t\tpr_debug(\"%s: %pI4 to %pI4\\n\", __func__,\n\t\t\t (void *)&ctx->from, (void *)&ctx->to);\n\t\tif (*ctx->check)\n\t\t\tfast_csum(ctx, (unsigned char *)data - ctx->begin);\n\t\t*pdata = ctx->to;\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "static int op_open1(OggOpusFile *_of,\n void *_stream,const OpusFileCallbacks *_cb,\n const unsigned char *_initial_data,size_t _initial_bytes){\n  ogg_page  og;\n  ogg_page *pog;\n  int       seekable;\n  int       ret;\n  memset(_of,0,sizeof(*_of));\n  if(OP_UNLIKELY(_initial_bytes>(size_t)LONG_MAX))return OP_EFAULT;\n  _of->end=-1;\n  _of->stream=_stream;\n  *&_of->callbacks=*_cb;\n  if(OP_UNLIKELY(_of->callbacks.read==NULL))return OP_EREAD;\n  ogg_sync_init(&_of->oy);\n  if(_initial_bytes>0){\n    char *buffer;\n    buffer=ogg_sync_buffer(&_of->oy,(long)_initial_bytes);\n    if(OP_UNLIKELY(buffer==NULL))return OP_EFAULT;\n    memcpy(buffer,_initial_data,_initial_bytes*sizeof(*buffer));\n    ogg_sync_wrote(&_of->oy,(long)_initial_bytes);\n  }\n  seekable=_cb->seek!=NULL&&(*_cb->seek)(_stream,0,SEEK_CUR)!=-1;\n  if(seekable){\n    opus_int64 pos;\n    if(OP_UNLIKELY(_of->callbacks.tell==NULL))return OP_EINVAL;\n    pos=(*_of->callbacks.tell)(_of->stream);\n    if(OP_UNLIKELY(pos!=(opus_int64)_initial_bytes))return OP_EINVAL;\n  }\n  _of->seekable=seekable;\n  _of->links=(OggOpusLink *)_ogg_malloc(sizeof(*_of->links));\n  ogg_stream_init(&_of->os,-1);\n  pog=NULL;\n  for(;;){\n    ret=op_fetch_headers(_of,&_of->links[0].head,&_of->links[0].tags,\n     &_of->serialnos,&_of->nserialnos,&_of->cserialnos,pog);\n    if(OP_UNLIKELY(ret<0))break;\n    _of->nlinks=1;\n    _of->links[0].offset=0;\n    _of->links[0].data_offset=_of->offset;\n    _of->links[0].pcm_end=-1;\n    _of->links[0].serialno=_of->os.serialno;\n    ret=op_find_initial_pcm_offset(_of,_of->links,&og);\n    if(seekable||OP_LIKELY(ret<=0))break;\n    opus_tags_clear(&_of->links[0].tags);\n    _of->nlinks=0;\n    if(!seekable)_of->cur_link++;\n    pog=&og;\n  }\n  if(OP_LIKELY(ret>=0))_of->ready_state=OP_PARTOPEN;\n  return ret;\n}", "target": 0}
{"code": "void Browser::RendererUnresponsive(\n    WebContents* source,\n    const content::WebContentsUnresponsiveState& unresponsive_state) {\n  int index = tab_strip_model_->GetIndexOfWebContents(source);\n  DCHECK_NE(TabStripModel::kNoTab, index);\n  if (tab_strip_model_->IsTabBlocked(index))\n    return;\n  TabDialogs::FromWebContents(source)->ShowHungRendererDialog(\n      unresponsive_state);\n}", "target": 0}
{"code": "segment_size (Elf_Internal_Phdr *segment)\n{\n  return (segment->p_memsz > segment->p_filesz\n\t  ? segment->p_memsz : segment->p_filesz);\n}", "target": 0}
{"code": "HTTP_HANDLE HTTPAPI_CreateConnection(const char* hostName)\n{\n    HTTP_HANDLE_DATA* result;\n    if (g_HTTPAPIState != HTTPAPI_INITIALIZED)\n    {\n        LogError(\"g_HTTPAPIState not HTTPAPI_INITIALIZED\");\n        result = NULL;\n    }\n    else\n    {\n        result = (HTTP_HANDLE_DATA*)malloc(sizeof(HTTP_HANDLE_DATA));\n        if (result == NULL)\n        {\n            LogError(\"malloc returned NULL.\");\n        }\n        else\n        {\n            memset(result, 0, sizeof(*result));\n            wchar_t* hostNameTemp;\n            size_t hostNameTemp_size = MultiByteToWideChar(CP_ACP, 0, hostName, -1, NULL, 0);\n            if (hostNameTemp_size == 0)\n            {\n                LogError(\"MultiByteToWideChar failed\");\n                free(result);\n                result = NULL;\n            }\n            else\n            {\n                hostNameTemp = (wchar_t*)malloc(sizeof(wchar_t) * hostNameTemp_size);\n                if (hostNameTemp == NULL)\n                {\n                    LogError(\"malloc failed\");\n                    free(result);\n                    result = NULL;\n                }\n                else\n                {\n                    if (MultiByteToWideChar(CP_ACP, 0, hostName, -1, hostNameTemp, (int)hostNameTemp_size) == 0)\n                    {\n                        LogError(\"MultiByteToWideChar failed\");\n                        free(result);\n                        result = NULL;\n                    }\n                    else\n                    {\n                        result->ConnectionHandle = WinHttpConnect(\n                            g_SessionHandle,\n                            hostNameTemp,\n                            INTERNET_DEFAULT_HTTPS_PORT,\n                            0);\n                        if (result->ConnectionHandle == NULL)\n                        {\n                            LogErrorWinHTTPWithGetLastErrorAsString(\"WinHttpConnect returned NULL.\");\n                            free(result);\n                            result = NULL;\n                        }\n                        else\n                        {\n                            result->timeout = 60000;\n                        }\n                    }\n                    free(hostNameTemp);\n                }\n            }\n        }\n    }\n    return (HTTP_HANDLE)result;\n}", "target": 1}
{"code": "static int pfkey_register(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\tstruct sk_buff *supp_skb;\n\tif (hdr->sadb_msg_satype > SADB_SATYPE_MAX)\n\t\treturn -EINVAL;\n\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC) {\n\t\tif (pfk->registered&(1<<hdr->sadb_msg_satype))\n\t\t\treturn -EEXIST;\n\t\tpfk->registered |= (1<<hdr->sadb_msg_satype);\n\t}\n\txfrm_probe_algs();\n\tsupp_skb = compose_sadb_supported(hdr, GFP_KERNEL);\n\tif (!supp_skb) {\n\t\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC)\n\t\t\tpfk->registered &= ~(1<<hdr->sadb_msg_satype);\n\t\treturn -ENOBUFS;\n\t}\n\tpfkey_broadcast(supp_skb, GFP_KERNEL, BROADCAST_REGISTERED, sk,\n\t\t\tsock_net(sk));\n\treturn 0;\n}", "target": 1}
{"code": "bool setCtbAddrFromTS(thread_context* tctx)\n{\n  const seq_parameter_set& sps = tctx->img->get_sps();\n  if (tctx->CtbAddrInTS < sps.PicSizeInCtbsY) {\n    tctx->CtbAddrInRS = tctx->img->get_pps().CtbAddrTStoRS[tctx->CtbAddrInTS];\n    tctx->CtbX = tctx->CtbAddrInRS % sps.PicWidthInCtbsY;\n    tctx->CtbY = tctx->CtbAddrInRS / sps.PicWidthInCtbsY;\n    return false;\n  }\n  else {\n    tctx->CtbAddrInRS = sps.PicSizeInCtbsY;\n    tctx->CtbX = tctx->CtbAddrInRS % sps.PicWidthInCtbsY;\n    tctx->CtbY = tctx->CtbAddrInRS / sps.PicWidthInCtbsY;\n    return true;\n  }\n}", "target": 0}
{"code": "int luaG_traceexec (lua_State *L, const Instruction *pc) {\n  CallInfo *ci = L->ci;\n  lu_byte mask = L->hookmask;\n  int counthook;\n  if (!(mask & (LUA_MASKLINE | LUA_MASKCOUNT))) {  \n    ci->u.l.trap = 0;  \n    return 0;  \n  }\n  pc++;  \n  ci->u.l.savedpc = pc;  \n  counthook = (--L->hookcount == 0 && (mask & LUA_MASKCOUNT));\n  if (counthook)\n    resethookcount(L);  \n  else if (!(mask & LUA_MASKLINE))\n    return 1;  \n  if (ci->callstatus & CIST_HOOKYIELD) {  \n    ci->callstatus &= ~CIST_HOOKYIELD;  \n    return 1;  \n  }\n  if (!isIT(*(ci->u.l.savedpc - 1)))\n    L->top = ci->top;  \n  if (counthook)\n    luaD_hook(L, LUA_HOOKCOUNT, -1, 0, 0);  \n  if (mask & LUA_MASKLINE) {\n    const Proto *p = ci_func(ci)->p;\n    int npci = pcRel(pc, p);\n    if (npci == 0 ||  \n        pc <= L->oldpc ||  \n        changedline(p, pcRel(L->oldpc, p), npci)) {  \n      int newline = luaG_getfuncline(p, npci);\n      luaD_hook(L, LUA_HOOKLINE, newline, 0, 0);  \n    }\n    L->oldpc = pc;  \n  }\n  if (L->status == LUA_YIELD) {  \n    if (counthook)\n      L->hookcount = 1;  \n    ci->u.l.savedpc--;  \n    ci->callstatus |= CIST_HOOKYIELD;  \n    luaD_throw(L, LUA_YIELD);\n  }\n  return 1;  \n}", "target": 1}
{"code": "InputMethodBase::~InputMethodBase() {\n}", "target": 0}
{"code": "bool AES_GCM_EncryptContext::Encrypt(\n\tconst void *pPlaintextData, size_t cbPlaintextData,\n\tconst void *pIV,\n\tvoid *pEncryptedDataAndTag, uint32 *pcbEncryptedDataAndTag,\n\tconst void *pAdditionalAuthenticationData, size_t cbAuthenticationData\n) {\n    unsigned long long pcbEncryptedDataAndTag_longlong = *pcbEncryptedDataAndTag;\n    crypto_aead_aes256gcm_encrypt_afternm(\n\t\tstatic_cast<unsigned char*>( pEncryptedDataAndTag ), &pcbEncryptedDataAndTag_longlong,\n\t\tstatic_cast<const unsigned char*>( pPlaintextData ), cbPlaintextData,\n\t\tstatic_cast<const unsigned char*>(pAdditionalAuthenticationData), cbAuthenticationData,\n\t\tnullptr,\n\t\tstatic_cast<const unsigned char*>( pIV ),\n\t\tstatic_cast<const crypto_aead_aes256gcm_state*>( m_ctx )\n\t);\n    *pcbEncryptedDataAndTag = pcbEncryptedDataAndTag_longlong;\n    return true;\n}", "target": 1}
{"code": "gfx::Size OverlayWindowViews::GetMinimumSize() const {\n  return min_size_;\n}", "target": 0}
{"code": "void headerMergeLegacySigs(Header h, Header sigh)\n{\n    HeaderIterator hi;\n    struct rpmtd_s td;\n    hi = headerInitIterator(sigh);\n    for (; headerNext(hi, &td); rpmtdFreeData(&td))\n    {\n\tswitch (td.tag) {\n\tcase RPMSIGTAG_SIZE:\n\t    td.tag = RPMTAG_SIGSIZE;\n\t    break;\n\tcase RPMSIGTAG_PGP:\n\t    td.tag = RPMTAG_SIGPGP;\n\t    break;\n\tcase RPMSIGTAG_MD5:\n\t    td.tag = RPMTAG_SIGMD5;\n\t    break;\n\tcase RPMSIGTAG_GPG:\n\t    td.tag = RPMTAG_SIGGPG;\n\t    break;\n\tcase RPMSIGTAG_PGP5:\n\t    td.tag = RPMTAG_SIGPGP5;\n\t    break;\n\tcase RPMSIGTAG_PAYLOADSIZE:\n\t    td.tag = RPMTAG_ARCHIVESIZE;\n\t    break;\n\tcase RPMSIGTAG_FILESIGNATURES:\n\t    td.tag = RPMTAG_FILESIGNATURES;\n\t    break;\n\tcase RPMSIGTAG_FILESIGNATURELENGTH:\n\t    td.tag = RPMTAG_FILESIGNATURELENGTH;\n\t    break;\n\tcase RPMSIGTAG_VERITYSIGNATURES:\n\tcase RPMSIGTAG_VERITYSIGNATUREALGO:\n\tcase RPMSIGTAG_SHA1:\n\tcase RPMSIGTAG_SHA256:\n\tcase RPMSIGTAG_DSA:\n\tcase RPMSIGTAG_RSA:\n\tdefault:\n\t    if (!(td.tag >= HEADER_SIGBASE && td.tag < HEADER_TAGBASE))\n\t\tcontinue;\n\t    break;\n\t}\n\tif (!headerIsEntry(h, td.tag)) {\n\t    switch (td.type) {\n\t    case RPM_NULL_TYPE:\n\t\tcontinue;\n\t\tbreak;\n\t    case RPM_CHAR_TYPE:\n\t    case RPM_INT8_TYPE:\n\t    case RPM_INT16_TYPE:\n\t    case RPM_INT32_TYPE:\n\t    case RPM_INT64_TYPE:\n\t\tif (td.count != 1)\n\t\t    continue;\n\t\tbreak;\n\t    case RPM_STRING_TYPE:\n\t    case RPM_STRING_ARRAY_TYPE:\n\t    case RPM_BIN_TYPE:\n\t\tif (td.count >= 16*1024)\n\t\t    continue;\n\t\tbreak;\n\t    case RPM_I18NSTRING_TYPE:\n\t\tcontinue;\n\t\tbreak;\n\t    }\n\t    (void) headerPut(h, &td, HEADERPUT_DEFAULT);\n\t}\n    }\n    headerFreeIterator(hi);\n}", "target": 1}
{"code": "bool AudioContext::isAudioThread() const\n{\n    return currentThread() == m_audioThread;\n}", "target": 0}
{"code": "u64 gf_net_get_ntp_ts()\n{\n\tu64 res;\n\tu32 sec, frac;\n\tgf_net_get_ntp(&sec, &frac);\n\tres = sec;\n\tres<<= 32;\n\tres |= frac;\n\treturn res;\n}", "target": 0}
{"code": "  void readEOF() noexcept override {\n    LOG(INFO) << \"Got EOF\";\n    auto chain = IOBuf::create(0);\n    for (size_t i = 0; i < 1000 * 1000; i++) {\n      auto buf = IOBuf::create(10);\n      buf->append(10);\n      memset(buf->writableData(), 'x', 10);\n      chain->prependChain(std::move(buf));\n    }\n    socket_->writeChain(&writeCallback_, std::move(chain));\n  }", "target": 0}
{"code": "void Document::FinishedParsing() {\n  DCHECK(!GetScriptableDocumentParser() || !parser_->IsParsing());\n  DCHECK(!GetScriptableDocumentParser() || ready_state_ != kLoading);\n  SetParsingState(kInDOMContentLoaded);\n  DocumentParserTiming::From(*this).MarkParserStop();\n  if (!document_timing_.DomContentLoadedEventStart())\n    document_timing_.MarkDomContentLoadedEventStart();\n  DispatchEvent(Event::CreateBubble(EventTypeNames::DOMContentLoaded));\n  if (!document_timing_.DomContentLoadedEventEnd())\n    document_timing_.MarkDomContentLoadedEventEnd();\n  SetParsingState(kFinishedParsing);\n  Microtask::PerformCheckpoint(V8PerIsolateData::MainThreadIsolate());\n  ScriptableDocumentParser* parser = GetScriptableDocumentParser();\n  well_formed_ = parser && parser->WellFormed();\n  if (LocalFrame* frame = GetFrame()) {\n    const bool main_resource_was_already_requested =\n        frame->Loader().StateMachine()->CommittedFirstRealDocumentLoad();\n    if (main_resource_was_already_requested)\n      UpdateStyleAndLayoutTree();\n    BeginLifecycleUpdatesIfRenderingReady();\n    frame->Loader().FinishedParsing();\n    TRACE_EVENT_INSTANT1(\"devtools.timeline\", \"MarkDOMContent\",\n                         TRACE_EVENT_SCOPE_THREAD, \"data\",\n                         InspectorMarkLoadEvent::Data(frame));\n    probe::domContentLoadedEventFired(frame);\n    frame->GetIdlenessDetector()->DomContentLoadedEventFired();\n  }\n  element_data_cache_clear_timer_.StartOneShot(10, BLINK_FROM_HERE);\n  fetcher_->ClearPreloads(ResourceFetcher::kClearSpeculativeMarkupPreloads);\n  if (!frame_ || frame_->GetSettings()->GetSavePreviousDocumentResources() ==\n                     SavePreviousDocumentResources::kUntilOnDOMContentLoaded) {\n    fetcher_->ClearResourcesFromPreviousFetcher();\n  }\n  if (IsPrefetchOnly())\n    WebPrerenderingSupport::Current()->PrefetchFinished();\n}", "target": 0}
{"code": "struct crypto_alg *crypto_larval_lookup(const char *name, u32 type, u32 mask)\n{\n\tstruct crypto_alg *alg;\n\tif (!name)\n\t\treturn ERR_PTR(-ENOENT);\n\tmask &= ~(CRYPTO_ALG_LARVAL | CRYPTO_ALG_DEAD);\n\ttype &= mask;\n\talg = crypto_alg_lookup(name, type, mask);\n\tif (!alg) {\n\t\trequest_module(\"%s\", name);\n\t\tif (!((type ^ CRYPTO_ALG_NEED_FALLBACK) & mask &\n\t\t      CRYPTO_ALG_NEED_FALLBACK))\n\t\t\trequest_module(\"%s-all\", name);\n\t\talg = crypto_alg_lookup(name, type, mask);\n\t}\n\tif (alg)\n\t\treturn crypto_is_larval(alg) ? crypto_larval_wait(alg) : alg;\n\treturn crypto_larval_add(name, type, mask);\n}", "target": 1}
{"code": "STATIC struct pollfd *poll_set_add_fd(poll_set_t *poll_set, int fd) {\n    struct pollfd *free_slot = NULL;\n    if (poll_set->used == poll_set->max_used) {\n        if (poll_set->max_used >= poll_set->alloc) {\n            poll_set->pollfds = m_renew(struct pollfd, poll_set->pollfds, poll_set->alloc, poll_set->alloc + 4);\n            poll_set->alloc += 4;\n        }\n        free_slot = &poll_set->pollfds[poll_set->max_used++];\n    } else {\n        for (unsigned int i = 0; i < poll_set->max_used; ++i) {\n            struct pollfd *slot = &poll_set->pollfds[i];\n            if (slot->fd == -1) {\n                free_slot = slot;\n                break;\n            }\n        }\n        assert(free_slot != NULL);\n    }\n    free_slot->fd = fd;\n    ++poll_set->used;\n    return free_slot;\n}", "target": 1}
{"code": "void WriteFromUrlOperation::GetDownloadTarget(\n    const base::Closure& continuation) {\n  DCHECK_CURRENTLY_ON(BrowserThread::FILE);\n  if (IsCancelled()) {\n    return;\n  }\n  if (url_.ExtractFileName().empty()) {\n    if (!base::CreateTemporaryFileInDir(temp_dir_.GetPath(), &image_path_)) {\n      Error(error::kTempFileError);\n      return;\n    }\n  } else {\n    base::FilePath file_name =\n        base::FilePath::FromUTF8Unsafe(url_.ExtractFileName());\n    image_path_ = temp_dir_.GetPath().Append(file_name);\n  }\n  BrowserThread::PostTask(BrowserThread::FILE, FROM_HERE, continuation);\n}", "target": 0}
{"code": "void lodepng_state_cleanup(LodePNGState* state)\n{\n  lodepng_color_mode_cleanup(&state->info_raw);\n  lodepng_info_cleanup(&state->info_png);\n}", "target": 0}
{"code": "flush_signal_handlers(struct task_struct *t, int force_default)\n{\n\tint i;\n\tstruct k_sigaction *ka = &t->sighand->action[0];\n\tfor (i = _NSIG ; i != 0 ; i--) {\n\t\tif (force_default || ka->sa.sa_handler != SIG_IGN)\n\t\t\tka->sa.sa_handler = SIG_DFL;\n\t\tka->sa.sa_flags = 0;\n#ifdef SA_RESTORER\n\t\tka->sa.sa_restorer = NULL;\n#endif\n\t\tsigemptyset(&ka->sa.sa_mask);\n\t\tka++;\n\t}\n}", "target": 0}
{"code": "static int get_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)\n{\n\tint ret;\n\tret = usb_control_msg(pegasus->usb, usb_rcvctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_GET_REGS, PEGASUS_REQT_READ, 0,\n\t\t\t      indx, data, size, 1000);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\treturn ret;\n}", "target": 1}
{"code": "static Status ValidateSavedTensors(const GraphDef& graph_def) {\n  for (const auto& node : graph_def.node()) {\n    TF_RETURN_IF_ERROR(ValidateNode(node));\n  }\n  if (graph_def.has_library()) {\n    const FunctionDefLibrary& library = graph_def.library();\n    for (const auto& function : library.function()) {\n      for (const auto& node : function.node_def()) {\n        TF_RETURN_IF_ERROR(ValidateNode(node));\n      }\n      TF_RETURN_IF_ERROR(ValidateFunctionNotRecursive(function));\n    }\n  }\n  return Status::OK();\n}", "target": 0}
{"code": "static inline bool ib_safe_file_access(struct file *filp)\n{\n\treturn filp->f_cred == current_cred() && segment_eq(get_fs(), USER_DS);\n}", "target": 0}
{"code": "static inline void show_node(struct zone *zone)\n{\n\tif (IS_ENABLED(CONFIG_NUMA))\n\t\tprintk(\"Node %d \", zone_to_nid(zone));\n}", "target": 0}
{"code": "void * calloc(size_t n, size_t lb)\n{\n    if ((lb | n) > GC_SQRT_SIZE_MAX \n        && lb && n > GC_SIZE_MAX / lb)\n      return NULL;\n#   if defined(GC_LINUX_THREADS) \n        {\n          static GC_bool lib_bounds_set = FALSE;\n          ptr_t caller = (ptr_t)__builtin_return_address(0);\n          if (!EXPECT(lib_bounds_set, TRUE)) {\n            GC_init_lib_bounds();\n            lib_bounds_set = TRUE;\n          }\n          if (((word)caller >= (word)GC_libpthread_start\n               && (word)caller < (word)GC_libpthread_end)\n              || ((word)caller >= (word)GC_libld_start\n                  && (word)caller < (word)GC_libld_end))\n            return GC_malloc_uncollectable(n*lb);\n        }\n#   endif\n    return((void *)REDIRECT_MALLOC(n*lb));\n}", "target": 0}
{"code": "static void r_bin_dwarf_dump_debug_info(FILE *f, const RBinDwarfDebugInfo *inf) {\n\tsize_t i, j, k;\n\tRBinDwarfDIE *dies;\n\tRBinDwarfAttrValue *values;\n\tif (!inf || !f) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < inf->length; i++) {\n\t\tfprintf (f, \"  Compilation Unit @ offset 0x%\"PFMT64x\":\\n\", inf->comp_units [i].offset);\n\t\tfprintf (f, \"   Length:        0x%x\\n\", inf->comp_units [i].hdr.length);\n\t\tfprintf (f, \"   Version:       %d\\n\", inf->comp_units [i].hdr.version);\n\t\tfprintf (f, \"   Abbrev Offset: 0x%x\\n\", inf->comp_units [i].hdr.abbrev_offset);\n\t\tfprintf (f, \"   Pointer Size:  %d\\n\", inf->comp_units [i].hdr.pointer_size);\n\t\tdies = inf->comp_units[i].dies;\n\t\tfor (j = 0; j < inf->comp_units[i].length; j++) {\n\t\t\tfprintf (f, \"    Abbrev Number: %\"PFMT64u\" \", dies[j].abbrev_code);\n\t\t\tif (dies[j].tag && dies[j].tag <= DW_TAG_volatile_type &&\n\t\t\t\t       dwarf_tag_name_encodings[dies[j].tag]) {\n\t\t\t\tfprintf (f, \"(%s)\\n\", dwarf_tag_name_encodings[dies[j].tag]);\n\t\t\t} else {\n\t\t\t\tfprintf (f, \"(Unknown abbrev tag)\\n\");\n\t\t\t}\n\t\t\tif (!dies[j].abbrev_code) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvalues = dies[j].attr_values;\n\t\t\tfor (k = 0; k < dies[j].length; k++) {\n\t\t\t\tif (!values[k].name)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (values[k].name < DW_AT_vtable_elem_location &&\n\t\t\t\t\t\tdwarf_attr_encodings[values[k].name]) {\n\t\t\t\t\tfprintf (f, \"     %-18s : \", dwarf_attr_encodings[values[k].name]);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf (f, \"     TODO\\t\");\n\t\t\t\t}\n\t\t\t\tr_bin_dwarf_dump_attr_value (&values[k], f);\n\t\t\t\tfprintf (f, \"\\n\");\n\t\t\t}\n\t\t}\n\t}\n}", "target": 1}
{"code": "static Jsi_RC WebSocketVersionCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    const char *verStr = NULL;\n    verStr = lws_get_library_version();\n    if (verStr) {\n        char buf[100], *cp;\n        snprintf(buf, sizeof(buf), \"%s\", verStr);\n        cp = Jsi_Strchr(buf, ' ');\n        if (cp) *cp = 0;\n        Jsi_ValueMakeStringDup(interp, ret, buf);\n    }\n    return JSI_OK;\n}", "target": 1}
{"code": "static int virtio_net_set_vnet_endian_one(VirtIODevice *vdev,\n                                          NetClientState *peer,\n                                          bool enable)\n{\n    if (virtio_is_big_endian(vdev)) {\n        return qemu_set_vnet_be(peer, enable);\n    } else {\n        return qemu_set_vnet_le(peer, enable);\n    }\n}", "target": 0}
{"code": "static int _nfs4_do_open(struct inode *dir, struct path *path, int flags, struct iattr *sattr, struct rpc_cred *cred, struct nfs4_state **res)\n{\n\tstruct nfs4_state_owner  *sp;\n\tstruct nfs4_state     *state = NULL;\n\tstruct nfs_server       *server = NFS_SERVER(dir);\n\tstruct nfs4_opendata *opendata;\n\tint status;\n\tstatus = -ENOMEM;\n\tif (!(sp = nfs4_get_state_owner(server, cred))) {\n\t\tdprintk(\"nfs4_do_open: nfs4_get_state_owner failed!\\n\");\n\t\tgoto out_err;\n\t}\n\tstatus = nfs4_recover_expired_lease(server);\n\tif (status != 0)\n\t\tgoto err_put_state_owner;\n\tif (path->dentry->d_inode != NULL)\n\t\tnfs4_return_incompatible_delegation(path->dentry->d_inode, flags & (FMODE_READ|FMODE_WRITE));\n\tstatus = -ENOMEM;\n\topendata = nfs4_opendata_alloc(path, sp, flags, sattr);\n\tif (opendata == NULL)\n\t\tgoto err_put_state_owner;\n\tif (path->dentry->d_inode != NULL)\n\t\topendata->state = nfs4_get_open_state(path->dentry->d_inode, sp);\n\tstatus = _nfs4_proc_open(opendata);\n\tif (status != 0)\n\t\tgoto err_opendata_put;\n\tif (opendata->o_arg.open_flags & O_EXCL)\n\t\tnfs4_exclusive_attrset(opendata, sattr);\n\tstate = nfs4_opendata_to_nfs4_state(opendata);\n\tstatus = PTR_ERR(state);\n\tif (IS_ERR(state))\n\t\tgoto err_opendata_put;\n\tnfs4_opendata_put(opendata);\n\tnfs4_put_state_owner(sp);\n\t*res = state;\n\treturn 0;\nerr_opendata_put:\n\tnfs4_opendata_put(opendata);\nerr_put_state_owner:\n\tnfs4_put_state_owner(sp);\nout_err:\n\t*res = NULL;\n\treturn status;\n}", "target": 1}
{"code": "mwifiex_set_uap_rates(struct mwifiex_uap_bss_param *bss_cfg,\n\t\t      struct cfg80211_ap_settings *params)\n{\n\tstruct ieee_types_header *rate_ie;\n\tint var_offset = offsetof(struct ieee80211_mgmt, u.beacon.variable);\n\tconst u8 *var_pos = params->beacon.head + var_offset;\n\tint len = params->beacon.head_len - var_offset;\n\tu8 rate_len = 0;\n\trate_ie = (void *)cfg80211_find_ie(WLAN_EID_SUPP_RATES, var_pos, len);\n\tif (rate_ie) {\n\t\tmemcpy(bss_cfg->rates, rate_ie + 1, rate_ie->len);\n\t\trate_len = rate_ie->len;\n\t}\n\trate_ie = (void *)cfg80211_find_ie(WLAN_EID_EXT_SUPP_RATES,\n\t\t\t\t\t   params->beacon.tail,\n\t\t\t\t\t   params->beacon.tail_len);\n\tif (rate_ie)\n\t\tmemcpy(bss_cfg->rates + rate_len, rate_ie + 1, rate_ie->len);\n\treturn;\n}", "target": 1}
{"code": "ikev1_vid_print(netdissect_options *ndo, u_char tpay _U_,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len _U_, const u_char *ep _U_,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_VID)));\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_VID)));\n\treturn NULL;\n}", "target": 0}
{"code": "static inline key_ref_t __key_update(key_ref_t key_ref,\n\t\t\t\t     struct key_preparsed_payload *prep)\n{\n\tstruct key *key = key_ref_to_ptr(key_ref);\n\tint ret;\n\tret = key_permission(key_ref, KEY_NEED_WRITE);\n\tif (ret < 0)\n\t\tgoto error;\n\tret = -EEXIST;\n\tif (!key->type->update)\n\t\tgoto error;\n\tdown_write(&key->sem);\n\tret = key->type->update(key, prep);\n\tif (ret == 0)\n\t\tclear_bit(KEY_FLAG_NEGATIVE, &key->flags);\n\tup_write(&key->sem);\n\tif (ret < 0)\n\t\tgoto error;\nout:\n\treturn key_ref;\nerror:\n\tkey_put(key);\n\tkey_ref = ERR_PTR(ret);\n\tgoto out;\n}", "target": 1}
{"code": "call_backend(char *uri,                 \n\t     int  argc,                 \n\t     char **argv,\t\t\n\t     char *filename)            \n{\n  const char\t*cups_serverbin;\t\n  char\t\tscheme[1024],           \n                *ptr,\t\t\t\n\t\tcmdline[65536];\t\t\n  int           retval;\n  strncpy(scheme, uri, sizeof(scheme) - 1);\n  if (strlen(uri) > 1023)\n    scheme[1023] = '\\0';\n  if ((ptr = strchr(scheme, ':')) != NULL)\n    *ptr = '\\0';\n  if ((cups_serverbin = getenv(\"CUPS_SERVERBIN\")) == NULL)\n    cups_serverbin = CUPS_SERVERBIN;\n  if (!strncasecmp(uri, \"file:\", 5) || uri[0] == '/')\n  {\n    fprintf(stderr,\n\t    \"ERROR: beh: Direct output into a file not supported.\\n\");\n    exit (CUPS_BACKEND_FAILED);\n  }\n  else\n    snprintf(cmdline, sizeof(cmdline),\n\t     \"%s/backend/%s '%s' '%s' '%s' '%s' '%s' %s\",\n\t     cups_serverbin, scheme, argv[1], argv[2], argv[3],\n\t     (argc == 6 ? \"1\" : argv[4]),\n\t     argv[5], filename);\n  setenv(\"DEVICE_URI\", uri, 1);\n  fprintf(stderr,\n\t  \"DEBUG: beh: Executing backend command line \\\"%s\\\"...\\n\",\n\t  cmdline);\n  fprintf(stderr,\n\t  \"DEBUG: beh: Using device URI: %s\\n\",\n\t  uri);\n  retval = system(cmdline) >> 8;\n  if (retval == -1)\n    fprintf(stderr, \"ERROR: Unable to execute backend command line: %s\\n\",\n\t    strerror(errno));\n  return (retval);\n}", "target": 1}
{"code": "lyd_new_output(struct lyd_node *parent, const struct lys_module *module, const char *name)\n{\n    const struct lys_node *snode = NULL, *siblings;\n    if ((!parent && !module) || !name) {\n        LOGARG;\n        return NULL;\n    }\n    siblings = lyd_new_find_schema(parent, module, 1);\n    if (!siblings) {\n        LOGARG;\n        return NULL;\n    }\n    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_CONTAINER | LYS_LIST | LYS_NOTIF\n                         | LYS_RPC | LYS_ACTION, &snode) || !snode) {\n        LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",\n               name, lys_node_module(siblings)->name, siblings->name);\n        return NULL;\n    }\n    return _lyd_new(parent, snode, 0);\n}", "target": 1}
{"code": "pidfile_write(const char *pid_file, int pid)\n{\n\tFILE *pidfile = NULL;\n\tint pidfd = creat(pid_file, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (pidfd != -1) pidfile = fdopen(pidfd, \"w\");\n\tif (!pidfile) {\n\t\tlog_message(LOG_INFO, \"pidfile_write : Cannot open %s pidfile\",\n\t\t       pid_file);\n\t\treturn 0;\n\t}\n\tfprintf(pidfile, \"%d\\n\", pid);\n\tfclose(pidfile);\n\treturn 1;\n}", "target": 1}
{"code": "void * pvPortMalloc( size_t xWantedSize )\n{\n    void * pvReturn = NULL;\n    static uint8_t * pucAlignedHeap = NULL;\n    #if ( portBYTE_ALIGNMENT != 1 )\n        {\n            if( xWantedSize & portBYTE_ALIGNMENT_MASK )\n            {\n                xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );\n            }\n        }\n    #endif\n    vTaskSuspendAll();\n    {\n        if( pucAlignedHeap == NULL )\n        {\n            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );\n        }\n        if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&\n            ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) \n        {\n            pvReturn = pucAlignedHeap + xNextFreeByte;\n            xNextFreeByte += xWantedSize;\n        }\n        traceMALLOC( pvReturn, xWantedSize );\n    }\n    ( void ) xTaskResumeAll();\n    #if ( configUSE_MALLOC_FAILED_HOOK == 1 )\n        {\n            if( pvReturn == NULL )\n            {\n                extern void vApplicationMallocFailedHook( void );\n                vApplicationMallocFailedHook();\n            }\n        }\n    #endif\n    return pvReturn;\n}", "target": 1}
{"code": "static void test_on_link_state_changed(void* context, LINK_STATE new_link_state, LINK_STATE previous_link_state)\n{\n    (void)context;\n    test_on_link_state_changed_new_link_state = new_link_state;\n    test_on_link_state_changed_previous_link_state = previous_link_state;\n}", "target": 0}
{"code": "void scramble(FILE* keyFile){\n\tfor (int j = 0; j < 16; ++j)\n\t{\n\t\tchar temp = 0;\n\t\tfor (int i = 0; i < 256; ++i)\n\t\t{\n\t\t\tscrambleAsciiTables[j][i] = i;\n\t\t}\n\t\tif (keyFile != NULL){\n\t\t\tint size;\n\t\t\tchar extractedString[BUFFER_SIZE] = \"\";\n\t\t\twhile((size = fread(extractedString, 1, BUFFER_SIZE, keyFile)) > 0){\n\t\t\t\tfor (int i = 0; i < size; ++i)\n\t\t\t\t{\n\t\t\t\t\ttemp = scrambleAsciiTables[j][i%256];\n\t\t\t\t\tscrambleAsciiTables[j][i%256] = scrambleAsciiTables[j][(unsigned char)(extractedString[i])];\n\t\t\t\t\tscrambleAsciiTables[j][(unsigned char)(extractedString[i])] = temp;\n\t\t\t\t}\n\t\t\t}\n\t\t\trewind(keyFile);\n\t\t} else {\n\t\t\tunsigned char random256;\n\t\t\tfor (int i = 0; i < 10 * 256; ++i)\n\t\t\t{\n\t\t\t\trandom256 = generateNumber() ^ passPhrase[passIndex];\n\t\t\t\tpassIndex++;\n\t\t\t\tpassIndex %= 16384;\n\t\t\t\ttemp = scrambleAsciiTables[j][i%256];\n\t\t\t\tscrambleAsciiTables[j][i%256] = scrambleAsciiTables[j][random256];\n\t\t\t\tscrambleAsciiTables[j][random256] = temp;\n\t\t\t}\n\t\t}\n\t}\n}", "target": 1}
{"code": "static void f2fs_swap_deactivate(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tclear_inode_flag(inode, FI_PIN_FILE);\n}", "target": 0}
{"code": "static int xc2028_sleep(struct dvb_frontend *fe)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tint rc;\n\trc = check_device_status(priv);\n\tif (rc < 0)\n\t\treturn rc;\n\tif (!rc)\n\t\treturn 0;\n\tif (no_poweroff || priv->ctrl.disable_power_mgmt)\n\t\treturn 0;\n\ttuner_dbg(\"Putting xc2028/3028 into poweroff mode.\\n\");\n\tif (debug > 1) {\n\t\ttuner_dbg(\"Printing sleep stack trace:\\n\");\n\t\tdump_stack();\n\t}\n\tmutex_lock(&priv->lock);\n\tif (priv->firm_version < 0x0202)\n\t\trc = send_seq(priv, {0x00, XREG_POWER_DOWN, 0x00, 0x00});\n\telse\n\t\trc = send_seq(priv, {0x80, XREG_POWER_DOWN, 0x00, 0x00});\n\tif (rc >= 0)\n\t\tpriv->state = XC2028_SLEEP;\n\tmutex_unlock(&priv->lock);\n\treturn rc;\n}", "target": 0}
{"code": "get_matching_model_microcode(int cpu, unsigned long start,\n\t\t\t     void *data, size_t size,\n\t\t\t     struct mc_saved_data *mc_saved_data,\n\t\t\t     unsigned long *mc_saved_in_initrd,\n\t\t\t     struct ucode_cpu_info *uci)\n{\n\tu8 *ucode_ptr = data;\n\tunsigned int leftover = size;\n\tenum ucode_state state = UCODE_OK;\n\tunsigned int mc_size;\n\tstruct microcode_header_intel *mc_header;\n\tstruct microcode_intel *mc_saved_tmp[MAX_UCODE_COUNT];\n\tunsigned int mc_saved_count = mc_saved_data->mc_saved_count;\n\tint i;\n\twhile (leftover) {\n\t\tmc_header = (struct microcode_header_intel *)ucode_ptr;\n\t\tmc_size = get_totalsize(mc_header);\n\t\tif (!mc_size || mc_size > leftover ||\n\t\t\tmicrocode_sanity_check(ucode_ptr, 0) < 0)\n\t\t\tbreak;\n\t\tleftover -= mc_size;\n\t\tif (matching_model_microcode(mc_header, uci->cpu_sig.sig) !=\n\t\t\t UCODE_OK) {\n\t\t\tucode_ptr += mc_size;\n\t\t\tcontinue;\n\t\t}\n\t\t_save_mc(mc_saved_tmp, ucode_ptr, &mc_saved_count);\n\t\tucode_ptr += mc_size;\n\t}\n\tif (leftover) {\n\t\tstate = UCODE_ERROR;\n\t\tgoto out;\n\t}\n\tif (mc_saved_count == 0) {\n\t\tstate = UCODE_NFOUND;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < mc_saved_count; i++)\n\t\tmc_saved_in_initrd[i] = (unsigned long)mc_saved_tmp[i] - start;\n\tmc_saved_data->mc_saved_count = mc_saved_count;\nout:\n\treturn state;\n}", "target": 1}
{"code": "static void do_waitpid(FILE *fin, FILE *fout) {\n  char buf[BUFFER_SIZE];\n  read_buf(fin, buf);\n  int64_t p = -1;\n  int options = 0;\n  int timeout = 0;\n  sscanf(buf, \"%\" PRId64 \" %d %d\", &p, &options, &timeout);\n  pid_t pid = (pid_t)p;\n  int stat;\n  if (timeout > 0) {\n    waited = pid;\n    signal(SIGALRM, kill_handler);\n    alarm(timeout);\n  }\n  pid_t ret = ::waitpid(pid, &stat, options);\n  alarm(0); \n  waited = 0;\n  fprintf(fout, \"%\" PRId64 \" %d\\n\", (int64_t)ret, stat);\n  if (ret < 0) {\n    fprintf(fout, \"%d\\n\", errno);\n  }\n  fflush(fout);\n}", "target": 1}
{"code": "  CloseNotifyConnector(EventBase* evb, const SocketAddress& addr) {\n    evb_ = evb;\n    ssl_ = AsyncSSLSocket::newSocket(std::make_shared<SSLContext>(), evb_);\n    ssl_->connect(this, addr);\n  }", "target": 0}
{"code": "my_bool STDCALL mysql_stmt_free_result(MYSQL_STMT *stmt)\n{\n  DBUG_ENTER(\"mysql_stmt_free_result\");\n  DBUG_RETURN(reset_stmt_handle(stmt, RESET_LONG_DATA | RESET_STORE_RESULT |\n                                RESET_CLEAR_ERROR));\n}", "target": 0}
{"code": "__u32 secure_ipv6_id(const __be32 daddr[4])\n{\n\t__u32 hash[4];\n\tmemcpy(hash, daddr, 16);\n\tmd5_transform(hash, net_secret);\n\treturn hash[0];\n}", "target": 0}
{"code": "static pj_status_t pjsip_auth_verify( const pjsip_authorization_hdr *hdr,\n\t\t\t\t      const pj_str_t *method,\n\t\t\t\t      const pjsip_cred_info *cred_info )\n{\n    if (pj_stricmp(&hdr->scheme, &pjsip_DIGEST_STR) == 0) {\n\tchar digest_buf[PJSIP_MD5STRLEN];\n\tpj_str_t digest;\n\tconst pjsip_digest_credential *dig = &hdr->credential.digest;\n\tPJ_ASSERT_RETURN(pj_strcmp(&dig->username, &cred_info->username) == 0,\n\t\t\t PJ_EINVALIDOP);\n\tPJ_ASSERT_RETURN(pj_strcmp(&dig->realm, &cred_info->realm) == 0,\n\t\t\t PJ_EINVALIDOP);\n\tdigest.ptr = digest_buf;\n\tdigest.slen = PJSIP_MD5STRLEN;\n\tpjsip_auth_create_digest(&digest, \n\t\t\t\t &hdr->credential.digest.nonce,\n\t\t\t\t &hdr->credential.digest.nc, \n\t\t\t\t &hdr->credential.digest.cnonce,\n\t\t\t\t &hdr->credential.digest.qop,\n\t\t\t\t &hdr->credential.digest.uri,\n\t\t\t\t &cred_info->realm,\n\t\t\t\t cred_info, \n\t\t\t\t method );\n\treturn (pj_stricmp(&digest, &hdr->credential.digest.response) == 0) ?\n\t       PJ_SUCCESS : PJSIP_EAUTHINVALIDDIGEST;\n    } else {\n\tpj_assert(!\"Unsupported authentication scheme\");\n\treturn PJSIP_EINVALIDAUTHSCHEME;\n    }\n}", "target": 1}
{"code": "static int xen_netbk_tx_check_gop(struct xen_netbk *netbk,\n\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t  struct gnttab_copy **gopp)\n{\n\tstruct gnttab_copy *gop = *gopp;\n\tu16 pending_idx = *((u16 *)skb->data);\n\tstruct pending_tx_info *pending_tx_info = netbk->pending_tx_info;\n\tstruct xenvif *vif = pending_tx_info[pending_idx].vif;\n\tstruct xen_netif_tx_request *txp;\n\tstruct skb_shared_info *shinfo = skb_shinfo(skb);\n\tint nr_frags = shinfo->nr_frags;\n\tint i, err, start;\n\terr = gop->status;\n\tif (unlikely(err)) {\n\t\tpending_ring_idx_t index;\n\t\tindex = pending_index(netbk->pending_prod++);\n\t\ttxp = &pending_tx_info[pending_idx].req;\n\t\tmake_tx_response(vif, txp, XEN_NETIF_RSP_ERROR);\n\t\tnetbk->pending_ring[index] = pending_idx;\n\t\txenvif_put(vif);\n\t}\n\tstart = (frag_get_pending_idx(&shinfo->frags[0]) == pending_idx);\n\tfor (i = start; i < nr_frags; i++) {\n\t\tint j, newerr;\n\t\tpending_ring_idx_t index;\n\t\tpending_idx = frag_get_pending_idx(&shinfo->frags[i]);\n\t\tnewerr = (++gop)->status;\n\t\tif (likely(!newerr)) {\n\t\t\tif (unlikely(err))\n\t\t\t\txen_netbk_idx_release(netbk, pending_idx);\n\t\t\tcontinue;\n\t\t}\n\t\ttxp = &netbk->pending_tx_info[pending_idx].req;\n\t\tmake_tx_response(vif, txp, XEN_NETIF_RSP_ERROR);\n\t\tindex = pending_index(netbk->pending_prod++);\n\t\tnetbk->pending_ring[index] = pending_idx;\n\t\txenvif_put(vif);\n\t\tif (err)\n\t\t\tcontinue;\n\t\tpending_idx = *((u16 *)skb->data);\n\t\txen_netbk_idx_release(netbk, pending_idx);\n\t\tfor (j = start; j < i; j++) {\n\t\t\tpending_idx = frag_get_pending_idx(&shinfo->frags[j]);\n\t\t\txen_netbk_idx_release(netbk, pending_idx);\n\t\t}\n\t\terr = newerr;\n\t}\n\t*gopp = gop + 1;\n\treturn err;\n}", "target": 1}
{"code": "Array& ObjectData::reserveProperties(int numDynamic ) {\n  if (getAttribute(HasDynPropArr)) {\n    return dynPropArray();\n  }\n  auto const allocsz = MixedArray::computeAllocBytesFromMaxElms(numDynamic);\n  if (UNLIKELY(allocsz > kMaxSmallSize && tl_heap->preAllocOOM(allocsz))) {\n    check_non_safepoint_surprise();\n  }\n  return setDynPropArray(\n      Array::attach(MixedArray::MakeReserveMixed(numDynamic))\n  );\n}", "target": 0}
{"code": "void InlineTextBox::paintCompositionUnderline(GraphicsContext* ctx, int tx, int ty, const CompositionUnderline& underline)\n{\n    tx += m_x;\n    ty += m_y;\n    if (m_truncation == cFullTruncation)\n        return;\n    int start = 0;                 \n    int width = m_logicalWidth;           \n    bool useWholeWidth = true;\n    unsigned paintStart = m_start;\n    unsigned paintEnd = end() + 1; \n    if (paintStart <= underline.startOffset) {\n        paintStart = underline.startOffset;\n        useWholeWidth = false;\n        start = toRenderText(renderer())->width(m_start, paintStart - m_start, textPos(), m_firstLine);\n    }\n    if (paintEnd != underline.endOffset) {      \n        paintEnd = min(paintEnd, (unsigned)underline.endOffset);\n        useWholeWidth = false;\n    }\n    if (m_truncation != cNoTruncation) {\n        paintEnd = min(paintEnd, (unsigned)m_start + m_truncation);\n        useWholeWidth = false;\n    }\n    if (!useWholeWidth) {\n        width = toRenderText(renderer())->width(paintStart, paintEnd - paintStart, textPos() + start, m_firstLine);\n    }\n    int lineThickness = 1;\n    int baseline = renderer()->style(m_firstLine)->font().ascent();\n    if (underline.thick && logicalHeight() - baseline >= 2)\n        lineThickness = 2;\n    start += 1;\n    width -= 2;\n    ctx->setStrokeColor(underline.color, renderer()->style()->colorSpace());\n    ctx->setStrokeThickness(lineThickness);\n    ctx->drawLineForText(IntPoint(tx + start, ty + logicalHeight() - lineThickness), width, textRenderer()->document()->printing());\n}", "target": 0}
{"code": "void end_read_record(READ_RECORD *info)\n{\n  free_cache(info);\n  if (info->table)\n  {\n    if (info->table->db_stat) \n      (void) info->table->file->extra(HA_EXTRA_NO_CACHE);\n    if (info->read_record != rr_quick) \n      (void) info->table->file->ha_index_or_rnd_end();\n    info->table=0;\n  }\n}", "target": 0}
{"code": "static int hashtable_do_del(hashtable_t *hashtable,\n                            const char *key, size_t hash)\n{\n    pair_t *pair;\n    bucket_t *bucket;\n    size_t index;\n    index = hash % num_buckets(hashtable);\n    bucket = &hashtable->buckets[index];\n    pair = hashtable_find_pair(hashtable, bucket, key, hash);\n    if(!pair)\n        return -1;\n    if(&pair->list == bucket->first && &pair->list == bucket->last)\n        bucket->first = bucket->last = &hashtable->list;\n    else if(&pair->list == bucket->first)\n        bucket->first = pair->list.next;\n    else if(&pair->list == bucket->last)\n        bucket->last = pair->list.prev;\n    list_remove(&pair->list);\n    json_decref(pair->value);\n    jsonp_free(pair);\n    hashtable->size--;\n    return 0;\n}", "target": 1}
{"code": "static int vt_kdsetmode(struct vc_data *vc, unsigned long mode)\n{\n\tswitch (mode) {\n\tcase KD_GRAPHICS:\n\t\tbreak;\n\tcase KD_TEXT0:\n\tcase KD_TEXT1:\n\t\tmode = KD_TEXT;\n\t\tfallthrough;\n\tcase KD_TEXT:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (vc->vc_mode == mode)\n\t\treturn 0;\n\tvc->vc_mode = mode;\n\tif (vc->vc_num != fg_console)\n\t\treturn 0;\n\tconsole_lock();\n\tif (mode == KD_TEXT)\n\t\tdo_unblank_screen(1);\n\telse\n\t\tdo_blank_screen(1);\n\tconsole_unlock();\n\treturn 0;\n}", "target": 1}
{"code": "  void initialize() override {\n    setMaxRequestHeadersKb(60);\n    setMaxRequestHeadersCount(100);\n    envoy::config::route::v3::RetryPolicy retry_policy;\n    auto pass_through = config_helper_.createVirtualHost(\"pass.through.internal.redirect\");\n    config_helper_.addVirtualHost(pass_through);\n    auto handle = config_helper_.createVirtualHost(\"handle.internal.redirect\");\n    handle.mutable_routes(0)->set_name(\"redirect\");\n    handle.mutable_routes(0)->mutable_route()->mutable_internal_redirect_policy();\n    config_helper_.addVirtualHost(handle);\n    auto handle_max_3_hop =\n        config_helper_.createVirtualHost(\"handle.internal.redirect.max.three.hop\");\n    handle_max_3_hop.mutable_routes(0)->set_name(\"max_three_hop\");\n    handle_max_3_hop.mutable_routes(0)->mutable_route()->mutable_internal_redirect_policy();\n    handle_max_3_hop.mutable_routes(0)\n        ->mutable_route()\n        ->mutable_internal_redirect_policy()\n        ->mutable_max_internal_redirects()\n        ->set_value(3);\n    config_helper_.addVirtualHost(handle_max_3_hop);\n    auto handle_by_direct_response = config_helper_.createVirtualHost(\"handle.direct.response\");\n    handle_by_direct_response.mutable_routes(0)->set_name(\"direct_response\");\n    handle_by_direct_response.mutable_routes(0)->mutable_direct_response()->set_status(204);\n    handle_by_direct_response.mutable_routes(0)\n        ->mutable_direct_response()\n        ->mutable_body()\n        ->set_inline_string(EMPTY_STRING);\n    config_helper_.addVirtualHost(handle_by_direct_response);\n    HttpProtocolIntegrationTest::initialize();\n  }", "target": 0}
{"code": "static const struct usb_cdc_union_desc *\nims_pcu_get_cdc_union_desc(struct usb_interface *intf)\n{\n\tconst void *buf = intf->altsetting->extra;\n\tsize_t buflen = intf->altsetting->extralen;\n\tstruct usb_cdc_union_desc *union_desc;\n\tif (!buf) {\n\t\tdev_err(&intf->dev, \"Missing descriptor data\\n\");\n\t\treturn NULL;\n\t}\n\tif (!buflen) {\n\t\tdev_err(&intf->dev, \"Zero length descriptor\\n\");\n\t\treturn NULL;\n\t}\n\twhile (buflen > 0) {\n\t\tunion_desc = (struct usb_cdc_union_desc *)buf;\n\t\tif (union_desc->bDescriptorType == USB_DT_CS_INTERFACE &&\n\t\t    union_desc->bDescriptorSubType == USB_CDC_UNION_TYPE) {\n\t\t\tdev_dbg(&intf->dev, \"Found union header\\n\");\n\t\t\treturn union_desc;\n\t\t}\n\t\tbuflen -= union_desc->bLength;\n\t\tbuf += union_desc->bLength;\n\t}\n\tdev_err(&intf->dev, \"Missing CDC union descriptor\\n\");\n\treturn NULL;", "target": 1}
{"code": "R_API void r_core_fini(RCore *c) {\n\tif (!c) {\n\t\treturn;\n\t}\n\tr_core_task_break_all (&c->tasks);\n\tr_core_task_join (&c->tasks, NULL, -1);\n\tr_core_wait (c);\n\tr_list_free (c->ropchain);\n\tr_event_free (c->ev);\n\tfree (c->cmdlog);\n\tfree (c->lastsearch);\n\tR_FREE (c->cons->pager);\n\tfree (c->cmdqueue);\n\tfree (c->lastcmd);\n\tfree (c->stkcmd);\n\tr_list_free (c->visual.tabs);\n\tfree (c->block);\n\tr_core_autocomplete_free (c->autocomplete);\n\tr_list_free (c->gadgets);\n\tr_list_free (c->undos);\n\tr_num_free (c->num);\n\tfree (c->table_query);\n\tr_list_free (c->files);\n\tr_list_free (c->watchers);\n\tr_list_free (c->scriptstack);\n\tr_core_task_scheduler_fini (&c->tasks);\n\tc->rcmd = r_cmd_free (c->rcmd);\n\tr_list_free (c->cmd_descriptors);\n\tc->anal = r_anal_free (c->anal);\n\tr_asm_free (c->assembler);\n\tc->assembler = NULL;\n\tc->print = r_print_free (c->print);\n\tc->bin = (r_bin_free (c->bin), NULL);\n\tc->lang = (r_lang_free (c->lang), NULL);\n\tc->dbg = (r_debug_free (c->dbg), NULL);\n\tr_io_free (c->io);\n\tr_config_free (c->config);\n\tr_cons_free ();\n\tr_cons_singleton ()->teefile = NULL; \n\tr_search_free (c->search);\n\tr_flag_free (c->flags);\n\tr_fs_free (c->fs);\n\tr_egg_free (c->egg);\n\tr_lib_free (c->lib);\n\tr_buf_free (c->yank_buf);\n\tr_agraph_free (c->graph);\n\tfree (c->asmqjmps);\n\tsdb_free (c->sdb);\n\tr_core_log_free (c->log);\n\tr_parse_free (c->parser);\n\tfree (c->times);\n}", "target": 1}
{"code": "void PasswordAutofillAgent::AJAXSucceeded() {\n  OnSamePageNavigationCompleted();\n}", "target": 0}
{"code": "partition_table_create_data_ref (CreatePartitionTableData *data)\n{\n  data->refcount++;\n  return data;\n}", "target": 0}
{"code": "static int af9005_identify_state(struct usb_device *udev,\n\t\t\t\t struct dvb_usb_device_properties *props,\n\t\t\t\t struct dvb_usb_device_description **desc,\n\t\t\t\t int *cold)\n{\n\tint ret;\n\tu8 reply, *buf;\n\tbuf = kmalloc(FW_BULKOUT_SIZE + 2, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tret = af9005_boot_packet(udev, FW_CONFIG, &reply,\n\t\t\t\t buf, FW_BULKOUT_SIZE + 2);\n\tif (ret)\n\t\tgoto err;\n\tdeb_info(\"result of FW_CONFIG in identify state %d\\n\", reply);\n\tif (reply == 0x01)\n\t\t*cold = 1;\n\telse if (reply == 0x02)\n\t\t*cold = 0;\n\telse\n\t\treturn -EIO;\n\tdeb_info(\"Identify state cold = %d\\n\", *cold);\nerr:\n\tkfree(buf);\n\treturn ret;\n}", "target": 1}
{"code": "    virtual void visit(const messages::result_message::prepared::cql& m) override {\n        _response.write_int(0x0004);\n        _response.write_short_bytes(m.get_id());\n        _response.write(m.metadata(), _version);\n        if (_version > 1) {\n            _response.write(*m.result_metadata());\n        }\n    }", "target": 0}
{"code": "static enum hrtimer_restart posix_timer_fn(struct hrtimer *timer)\n{\n\tstruct k_itimer *timr;\n\tunsigned long flags;\n\tint si_private = 0;\n\tenum hrtimer_restart ret = HRTIMER_NORESTART;\n\ttimr = container_of(timer, struct k_itimer, it.real.timer);\n\tspin_lock_irqsave(&timr->it_lock, flags);\n\ttimr->it_active = 0;\n\tif (timr->it_interval != 0)\n\t\tsi_private = ++timr->it_requeue_pending;\n\tif (posix_timer_event(timr, si_private)) {\n\t\tif (timr->it_interval != 0) {\n\t\t\tktime_t now = hrtimer_cb_get_time(timer);\n#ifdef CONFIG_HIGH_RES_TIMERS\n\t\t\t{\n\t\t\t\tktime_t kj = NSEC_PER_SEC / HZ;\n\t\t\t\tif (timr->it_interval < kj)\n\t\t\t\t\tnow = ktime_add(now, kj);\n\t\t\t}\n#endif\n\t\t\ttimr->it_overrun += (unsigned int)\n\t\t\t\thrtimer_forward(timer, now,\n\t\t\t\t\t\ttimr->it_interval);\n\t\t\tret = HRTIMER_RESTART;\n\t\t\t++timr->it_requeue_pending;\n\t\t\ttimr->it_active = 1;\n\t\t}\n\t}\n\tunlock_timer(timr, flags);\n\treturn ret;\n}", "target": 1}
{"code": "static char *get_object(\n    FILE         *fp,\n    int           obj_id,\n    const xref_t *xref,\n    size_t       *size,\n    int          *is_stream)\n{\n    static const int    blk_sz = 256;\n    int                 i, total_sz, read_sz, n_blks, search, stream;\n    size_t              obj_sz;\n    char               *c, *data;\n    long                start;\n    const xref_entry_t *entry;\n    if (size)\n      *size = 0;\n    if (is_stream)\n      *is_stream = 0;\n    start = ftell(fp);\n    entry = NULL;\n    for (i=0; i<xref->n_entries; i++)\n      if (xref->entries[i].obj_id == obj_id)\n      {\n          entry = &xref->entries[i];\n          break;\n      }\n    if (!entry)\n      return NULL;\n    fseek(fp, entry->offset, SEEK_SET);\n    obj_sz = 0;    \n    total_sz = 0;  \n    n_blks = 1;\n    data = malloc(blk_sz * n_blks);\n    memset(data, 0, blk_sz * n_blks);\n    stream = 0;\n    while ((read_sz = fread(data+total_sz, 1, blk_sz-1, fp)) && !ferror(fp))\n    {\n        total_sz += read_sz;\n        *(data + total_sz) = '\\0';\n        if (total_sz + blk_sz >= (blk_sz * n_blks))\n          data = realloc(data, blk_sz * (++n_blks));\n        search = total_sz - read_sz;\n        if (search < 0)\n          search = 0;\n        if ((c = strstr(data + search, \"endobj\")))\n        {\n            *(c + strlen(\"endobj\") + 1) = '\\0';\n            obj_sz = (void *)strstr(data + search, \"endobj\") - (void *)data;\n            obj_sz += strlen(\"endobj\") + 1;\n            break;\n        }\n        else if (strstr(data, \"stream\"))\n          stream = 1;\n    }\n    clearerr(fp);\n    fseek(fp, start, SEEK_SET);\n    if (size)\n      *size = obj_sz;\n    if (is_stream)\n      *is_stream = stream;\n    return data;\n}", "target": 1}
{"code": "static char *get_pid_environ_val(pid_t pid,char *val){\n  char temp[500];\n  int i=0;\n  int foundit=0;\n  FILE *fp;\n  sprintf(temp,\"/proc/%d/environ\",pid);\n  fp=fopen(temp,\"r\");\n  if(fp==NULL)\n    return NULL;\n  for(;;){\n    temp[i]=fgetc(fp);    \n    if(foundit==1 && (temp[i]==0 || temp[i]=='\\0' || temp[i]==EOF)){\n      char *ret;\n      temp[i]=0;\n      ret=malloc(strlen(temp)+10);\n      sprintf(ret,\"%s\",temp);\n      fclose(fp);\n      return ret;\n    }\n    switch(temp[i]){\n    case EOF:\n      fclose(fp);\n      return NULL;\n    case '=':\n      temp[i]=0;\n      if(!strcmp(temp,val)){\n\tfoundit=1;\n      }\n      i=0;\n      break;\n    case '\\0':\n      i=0;\n      break;\n    default:\n      i++;\n    }\n  }\n}", "target": 1}
{"code": "inline int TensorProtoDataSize<tstring>(const TensorProto& t) {\n  return t.string_val_size();\n}", "target": 0}
{"code": "MOBI_RET mobi_trie_insert_infl(MOBITrie **root, const MOBIIndx *indx, size_t i) {\n    MOBIIndexEntry e = indx->entries[i];\n    char *inflected = e.label;\n    for (size_t j = 0; j < e.tags_count; j++) {\n        MOBIIndexTag t = e.tags[j];\n        if (t.tagid == INDX_TAGARR_INFL_PARTS_V1) {\n            for (size_t k = 0; k < t.tagvalues_count - 1; k += 2) {\n                uint32_t len = t.tagvalues[k];\n                uint32_t offset = t.tagvalues[k + 1];\n                char *base = mobi_get_cncx_string_flat(indx->cncx_record, offset, len);\n                if (base == NULL) {\n                    return MOBI_MALLOC_FAILED;\n                }\n                MOBI_RET ret = mobi_trie_insert_reversed(root, base, inflected);\n                free(base);\n                if (ret != MOBI_SUCCESS) {\n                    return ret;\n                }\n            }\n        }\n    }\n    return MOBI_SUCCESS;\n}", "target": 1}
{"code": "void test_parser_hvi(void) {\n\ttest_parser_param(1);\n}", "target": 0}
{"code": "static int checkout_verify_paths(\n\tgit_repository *repo,\n\tint action,\n\tgit_diff_delta *delta)\n{\n\tunsigned int flags = GIT_PATH_REJECT_WORKDIR_DEFAULTS;\n\tif (action & CHECKOUT_ACTION__REMOVE) {\n\t\tif (!git_path_isvalid(repo, delta->old_file.path, delta->old_file.mode, flags)) {\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"cannot remove invalid path '%s'\", delta->old_file.path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (action & ~CHECKOUT_ACTION__REMOVE) {\n\t\tif (!git_path_isvalid(repo, delta->new_file.path, delta->new_file.mode, flags)) {\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"cannot checkout to invalid path '%s'\", delta->new_file.path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static Jsi_RC DebugAddCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (!interp->breakpointHash)\n        interp->breakpointHash = Jsi_HashNew(interp, JSI_KEYS_STRING, jsi_HashFree);\n    int argc = Jsi_ValueGetLength(interp, args);\n    jsi_BreakPoint *bptr, bp = {};\n    Jsi_Number vnum;\n    if (argc>1 && Jsi_ValueGetBoolean(interp, Jsi_ValueArrayIndex(interp, args, 1), &bp.temp) != JSI_OK) \n        return Jsi_LogError(\"bad boolean\");\n    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n    if (Jsi_ValueGetNumber(interp, v, &vnum) == JSI_OK) {\n        bp.line = (int)vnum;\n        bp.file = interp->curFile;\n    } else {\n        const char *val = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n        const char *cp;\n        if (isdigit(val[0])) {\n            if (Jsi_GetInt(interp, val, &bp.line, 0) != JSI_OK) \n                return Jsi_LogError(\"bad number\");\n            bp.file = interp->curFile;\n        } else if ((cp = Jsi_Strchr(val, ':'))) {\n            if (Jsi_GetInt(interp, cp+1, &bp.line, 0) != JSI_OK) \n                return Jsi_LogError(\"bad number\");\n            Jsi_DString dStr = {};\n            Jsi_DSAppendLen(&dStr, val, cp-val);\n            bp.file = Jsi_KeyAdd(interp, Jsi_DSValue(&dStr));\n            Jsi_DSFree(&dStr);\n        } else {\n            bp.func = Jsi_KeyAdd(interp, val);\n        }\n    }\n    if (bp.line<=0 && !bp.func) \n        return Jsi_LogError(\"bad number\");\n    char nbuf[100];\n    bp.id = ++interp->debugOpts.breakIdx;\n    bp.enabled = 1;\n    snprintf(nbuf, sizeof(nbuf), \"%d\", bp.id);\n    bptr = (jsi_BreakPoint*)Jsi_Malloc(sizeof(*bptr));\n    *bptr = bp;\n    Jsi_HashSet(interp->breakpointHash, (void*)nbuf, bptr);\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)bp.id);\n    return JSI_OK;\n}", "target": 1}
{"code": "static int mbochs_probe(struct mdev_device *mdev)\n{\n\tconst struct mbochs_type *type =\n\t\t&mbochs_types[mdev_get_type_group_id(mdev)];\n\tstruct device *dev = mdev_dev(mdev);\n\tstruct mdev_state *mdev_state;\n\tint ret = -ENOMEM;\n\tif (type->mbytes + mbochs_used_mbytes > max_mbytes)\n\t\treturn -ENOMEM;\n\tmdev_state = kzalloc(sizeof(struct mdev_state), GFP_KERNEL);\n\tif (mdev_state == NULL)\n\t\treturn -ENOMEM;\n\tvfio_init_group_dev(&mdev_state->vdev, &mdev->dev, &mbochs_dev_ops);\n\tmdev_state->vconfig = kzalloc(MBOCHS_CONFIG_SPACE_SIZE, GFP_KERNEL);\n\tif (mdev_state->vconfig == NULL)\n\t\tgoto err_mem;\n\tmdev_state->memsize = type->mbytes * 1024 * 1024;\n\tmdev_state->pagecount = mdev_state->memsize >> PAGE_SHIFT;\n\tmdev_state->pages = kcalloc(mdev_state->pagecount,\n\t\t\t\t    sizeof(struct page *),\n\t\t\t\t    GFP_KERNEL);\n\tif (!mdev_state->pages)\n\t\tgoto err_mem;\n\tdev_info(dev, \"%s: %s, %d MB, %ld pages\\n\", __func__,\n\t\t type->name, type->mbytes, mdev_state->pagecount);\n\tmutex_init(&mdev_state->ops_lock);\n\tmdev_state->mdev = mdev;\n\tINIT_LIST_HEAD(&mdev_state->dmabufs);\n\tmdev_state->next_id = 1;\n\tmdev_state->type = type;\n\tmdev_state->edid_regs.max_xres = type->max_x;\n\tmdev_state->edid_regs.max_yres = type->max_y;\n\tmdev_state->edid_regs.edid_offset = MBOCHS_EDID_BLOB_OFFSET;\n\tmdev_state->edid_regs.edid_max_size = sizeof(mdev_state->edid_blob);\n\tmbochs_create_config_space(mdev_state);\n\tmbochs_reset(mdev_state);\n\tmbochs_used_mbytes += type->mbytes;\n\tret = vfio_register_group_dev(&mdev_state->vdev);\n\tif (ret)\n\t\tgoto err_mem;\n\tdev_set_drvdata(&mdev->dev, mdev_state);\n\treturn 0;\nerr_mem:\n\tkfree(mdev_state->vconfig);\n\tkfree(mdev_state);\n\treturn ret;\n}", "target": 1}
{"code": "parse_user_name(char *user_input, char **ret_username)\n{\n\tregister char *ptr;\n\tregister int index = 0;\n\tchar username[PAM_MAX_RESP_SIZE];\n\t*ret_username = NULL;\n\tbzero((void *)username, PAM_MAX_RESP_SIZE);\n\tptr = user_input;\n\twhile ((*ptr == ' ') || (*ptr == '\\t'))\n\t\tptr++;\n\tif (*ptr == '\\0') {\n\t\treturn (PAM_BUF_ERR);\n\t}\n\twhile (*ptr != '\\0') {\n\t\tif ((*ptr == ' ') || (*ptr == '\\t'))\n\t\t\tbreak;\n\t\telse {\n\t\t\tusername[index] = *ptr;\n\t\t\tindex++;\n\t\t\tptr++;\n\t\t}\n\t}\n\tif ((*ret_username = malloc(index + 1)) == NULL)\n\t\treturn (PAM_BUF_ERR);\n\t(void) strcpy(*ret_username, username);\n\treturn (PAM_SUCCESS);\n}", "target": 1}
{"code": "rpl_dio_print(netdissect_options *ndo,\n              const u_char *bp, u_int length)\n{\n        const struct nd_rpl_dio *dio = (const struct nd_rpl_dio *)bp;\n        const char *dagid_str;\n        ND_TCHECK(*dio);\n        dagid_str = ip6addr_string (ndo, dio->rpl_dagid);\n        ND_PRINT((ndo, \" [dagid:%s,seq:%u,instance:%u,rank:%u,%smop:%s,prf:%u]\",\n                  dagid_str,\n                  dio->rpl_dtsn,\n                  dio->rpl_instanceid,\n                  EXTRACT_16BITS(&dio->rpl_dagrank),\n                  RPL_DIO_GROUNDED(dio->rpl_mopprf) ? \"grounded,\":\"\",\n                  tok2str(rpl_mop_values, \"mop%u\", RPL_DIO_MOP(dio->rpl_mopprf)),\n                  RPL_DIO_PRF(dio->rpl_mopprf)));\n        if(ndo->ndo_vflag > 1) {\n                const struct rpl_dio_genoption *opt = (const struct rpl_dio_genoption *)&dio[1];\n                rpl_dio_printopt(ndo, opt, length);\n        }\n\treturn;\ntrunc:\n\tND_PRINT((ndo,\" [|truncated]\"));\n\treturn;\n}", "target": 1}
{"code": "static void iwl_sta_ucode_activate(struct iwl_priv *priv, u8 sta_id)\n{\n\tif (!(priv->stations[sta_id].used & IWL_STA_DRIVER_ACTIVE))\n\t\tIWL_ERR(priv, \"ACTIVATE a non DRIVER active station id %u \"\n\t\t\t\"addr %pM\\n\",\n\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\tif (priv->stations[sta_id].used & IWL_STA_UCODE_ACTIVE) {\n\t\tIWL_DEBUG_ASSOC(priv,\n\t\t\t\t\"STA id %u addr %pM already present in uCode \"\n\t\t\t\t\"(according to driver)\\n\",\n\t\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\t} else {\n\t\tpriv->stations[sta_id].used |= IWL_STA_UCODE_ACTIVE;\n\t\tIWL_DEBUG_ASSOC(priv, \"Added STA id %u addr %pM to uCode\\n\",\n\t\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\t}\n}", "target": 1}
{"code": "static void __munlock_pagevec(struct pagevec *pvec, struct zone *zone)\n{\n\tint i;\n\tint nr = pagevec_count(pvec);\n\tint delta_munlocked;\n\tstruct pagevec pvec_putback;\n\tint pgrescued = 0;\n\tpagevec_init(&pvec_putback, 0);\n\tspin_lock_irq(zone_lru_lock(zone));\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct page *page = pvec->pages[i];\n\t\tif (TestClearPageMlocked(page)) {\n\t\t\tif (__munlock_isolate_lru_page(page, false))\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\t__munlock_isolation_failed(page);\n\t\t}\n\t\tpagevec_add(&pvec_putback, pvec->pages[i]);\n\t\tpvec->pages[i] = NULL;\n\t}\n\tdelta_munlocked = -nr + pagevec_count(&pvec_putback);\n\t__mod_zone_page_state(zone, NR_MLOCK, delta_munlocked);\n\tspin_unlock_irq(zone_lru_lock(zone));\n\tpagevec_release(&pvec_putback);\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct page *page = pvec->pages[i];\n\t\tif (page) {\n\t\t\tlock_page(page);\n\t\t\tif (!__putback_lru_fast_prepare(page, &pvec_putback,\n\t\t\t\t\t&pgrescued)) {\n\t\t\t\tget_page(page); \n\t\t\t\t__munlock_isolated_page(page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tput_page(page); \n\t\t\t}\n\t\t}\n\t}\n\tif (pagevec_count(&pvec_putback))\n\t\t__putback_lru_fast(&pvec_putback, pgrescued);\n}", "target": 1}
{"code": "struct se_portal_group *tcm_loop_make_naa_tpg(\n\tstruct se_wwn *wwn,\n\tstruct config_group *group,\n\tconst char *name)\n{\n\tstruct tcm_loop_hba *tl_hba = container_of(wwn,\n\t\t\tstruct tcm_loop_hba, tl_hba_wwn);\n\tstruct tcm_loop_tpg *tl_tpg;\n\tchar *tpgt_str, *end_ptr;\n\tint ret;\n\tunsigned short int tpgt;\n\ttpgt_str = strstr(name, \"tpgt_\");\n\tif (!tpgt_str) {\n\t\tprintk(KERN_ERR \"Unable to locate \\\"tpgt_#\\\" directory\"\n\t\t\t\t\" group\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\ttpgt_str += 5; \n\ttpgt = (unsigned short int) simple_strtoul(tpgt_str, &end_ptr, 0);\n\tif (tpgt > TL_TPGS_PER_HBA) {\n\t\tprintk(KERN_ERR \"Passed tpgt: %hu exceeds TL_TPGS_PER_HBA:\"\n\t\t\t\t\" %u\\n\", tpgt, TL_TPGS_PER_HBA);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\ttl_tpg = &tl_hba->tl_hba_tpgs[tpgt];\n\ttl_tpg->tl_hba = tl_hba;\n\ttl_tpg->tl_tpgt = tpgt;\n\tret = core_tpg_register(&tcm_loop_fabric_configfs->tf_ops,\n\t\t\twwn, &tl_tpg->tl_se_tpg, tl_tpg,\n\t\t\tTRANSPORT_TPG_TYPE_NORMAL);\n\tif (ret < 0)\n\t\treturn ERR_PTR(-ENOMEM);\n\tprintk(KERN_INFO \"TCM_Loop_ConfigFS: Allocated Emulated %s\"\n\t\t\" Target Port %s,t,0x%04x\\n\", tcm_loop_dump_proto_id(tl_hba),\n\t\tconfig_item_name(&wwn->wwn_group.cg_item), tpgt);\n\treturn &tl_tpg->tl_se_tpg;\n}", "target": 1}
{"code": "\t\tvoid Phase2() final {\n\t\t\tLocal<Context> context_handle = Deref(context);\n\t\t\tContext::Scope context_scope{context_handle};\n\t\t\tLocal<Value> key_inner = key->CopyInto();\n\t\t\tLocal<Object> object = Local<Object>::Cast(Deref(reference));\n\t\t\tUnmaybe(object->Delete(context_handle, key_inner));\n\t\t\tLocal<Value> val_inner = val->TransferIn();\n\t\t\tdid_set = Unmaybe(object->Set(context_handle, key_inner, val_inner));\n\t\t}", "target": 1}
{"code": "static int persist__subs_save_all(FILE *db_fptr)\n{\n\tstruct mosquitto__subhier *subhier, *subhier_tmp;\n\tHASH_ITER(hh, db.subs, subhier, subhier_tmp){\n\t\tif(subhier->children){\n\t\t\tpersist__subs_save(db_fptr, subhier->children, \"\", 0);\n\t\t}\n\t}\n\treturn MOSQ_ERR_SUCCESS;\n}", "target": 1}
{"code": "Http::FilterMetadataStatus Context::onRequestMetadata() {\n  if (!wasm_->onRequestMetadata_) {\n    return Http::FilterMetadataStatus::Continue;\n  }\n  if (wasm_->onRequestMetadata_(this, id_).u64_ == 0) {\n    return Http::FilterMetadataStatus::Continue;\n  }\n  return Http::FilterMetadataStatus::Continue; \n}", "target": 1}
{"code": "static int umocktypes_copy_bool_ptr(bool** destination, const bool** source)\n{\n    int result;\n    *destination = (bool*)my_gballoc_malloc(sizeof(bool));\n    if (*destination == NULL)\n    {\n        result = MU_FAILURE;\n    }\n    else\n    {\n        *(*destination) = *(*source);\n        result = 0;\n    }\n    return result;\n}", "target": 0}
{"code": "static int __init ipip_init(void)\n{\n\tint err;\n\tprintk(banner);\n\tif (xfrm4_tunnel_register(&ipip_handler, AF_INET)) {\n\t\tprintk(KERN_INFO \"ipip init: can't register tunnel\\n\");\n\t\treturn -EAGAIN;\n\t}\n\terr = register_pernet_device(&ipip_net_ops);\n\tif (err)\n\t\txfrm4_tunnel_deregister(&ipip_handler, AF_INET);\n\treturn err;\n}", "target": 1}
{"code": "static int do_i2c_write(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t\tchar *const argv[])\n{\n\tuint\tchip;\n\tuint\tdevaddr, length;\n\tint alen;\n\tu_char  *memaddr;\n\tint ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n\tstruct dm_i2c_chip *i2c_chip;\n#endif\n\tif ((argc < 5) || (argc > 6))\n\t\treturn cmd_usage(cmdtp);\n\tmemaddr = (u_char *)hextoul(argv[1], NULL);\n\tchip = hextoul(argv[2], NULL);\n\tdevaddr = hextoul(argv[3], NULL);\n\talen = get_alen(argv[3], DEFAULT_ADDR_LEN);\n\tif (alen > 3)\n\t\treturn cmd_usage(cmdtp);\n\tlength = hextoul(argv[4], NULL);\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret && alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n\ti2c_chip = dev_get_parent_plat(dev);\n\tif (!i2c_chip)\n\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n#endif\n\tif (argc == 6 && !strcmp(argv[5], \"-s\")) {\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\ti2c_chip->flags &= ~DM_I2C_CHIP_WR_ADDRESS;\n\t\tret = dm_i2c_write(dev, devaddr, memaddr, length);\n#else\n\t\tret = i2c_write(chip, devaddr, alen, memaddr, length);\n#endif\n\t\tif (ret)\n\t\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n\t} else {\n\t\twhile (length-- > 0) {\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\t\ti2c_chip->flags |= DM_I2C_CHIP_WR_ADDRESS;\n\t\t\tret = dm_i2c_write(dev, devaddr++, memaddr++, 1);\n#else\n\t\t\tret = i2c_write(chip, devaddr++, alen, memaddr++, 1);\n#endif\n\t\t\tif (ret)\n\t\t\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n#if !defined(CONFIG_SYS_I2C_FRAM)\n\t\t\tudelay(11000);\n#endif\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "nvkm_vmm_node_split(struct nvkm_vmm *vmm,\n\t\t    struct nvkm_vma *vma, u64 addr, u64 size)\n{\n\tstruct nvkm_vma *prev = NULL;\n\tif (vma->addr != addr) {\n\t\tprev = vma;\n\t\tif (!(vma = nvkm_vma_tail(vma, vma->size + vma->addr - addr)))\n\t\t\treturn NULL;\n\t\tvma->part = true;\n\t\tnvkm_vmm_node_insert(vmm, vma);\n\t}\n\tif (vma->size != size) {\n\t\tstruct nvkm_vma *tmp;\n\t\tif (!(tmp = nvkm_vma_tail(vma, vma->size - size))) {\n\t\t\tnvkm_vmm_node_merge(vmm, prev, vma, NULL, vma->size);\n\t\t\treturn NULL;\n\t\t}\n\t\ttmp->part = true;\n\t\tnvkm_vmm_node_insert(vmm, tmp);\n\t}\n\treturn vma;\n}", "target": 0}
{"code": "int LibRaw::parseLeicaLensName(unsigned len)\n{\n#define plln ilm.Lens\n  if (!len)\n  {\n    strcpy(plln, \"N/A\");\n    return 0;\n  }\n  stmread(plln, len, ifp);\n  if ((plln[0] == ' ') || !strncasecmp(plln, \"not \", 4) ||\n      !strncmp(plln, \"---\", 3) || !strncmp(plln, \"***\", 3))\n  {\n    strcpy(plln, \"N/A\");\n    return 0;\n  }\n  else\n    return 1;\n#undef plln\n}", "target": 0}
{"code": "void luaD_callnoyield (lua_State *L, StkId func, int nResults) {\n  incXCcalls(L);\n  if (getCcalls(L) <= CSTACKERR)  \n    luaE_freeCI(L);\n  luaD_call(L, func, nResults);\n  decXCcalls(L);\n}", "target": 1}
{"code": "void Document::ImplicitClose() {\n  DCHECK(!InStyleRecalc());\n  DCHECK(parser_);\n  load_event_progress_ = kLoadEventInProgress;\n  DetachParser();\n  if (SvgExtensions())\n    AccessSVGExtensions().DispatchSVGLoadEventToOutermostSVGElements();\n  if (domWindow())\n    domWindow()->DocumentWasClosed();\n  if (GetFrame()) {\n    GetFrame()->Client()->DispatchDidHandleOnloadEvents();\n    Loader()->GetApplicationCacheHost()->StopDeferringEvents();\n  }\n  if (!GetFrame()) {\n    load_event_progress_ = kLoadEventCompleted;\n    return;\n  }\n  if (GetFrame()->GetNavigationScheduler().LocationChangePending() &&\n      ElapsedTime() < kCLayoutScheduleThreshold) {\n    load_event_progress_ = kLoadEventCompleted;\n    return;\n  }\n  if (!LocalOwner() || (LocalOwner()->GetLayoutObject() &&\n                        !LocalOwner()->GetLayoutObject()->NeedsLayout())) {\n    UpdateStyleAndLayoutTree();\n    if (View() && !GetLayoutViewItem().IsNull() &&\n        (!GetLayoutViewItem().FirstChild() ||\n         GetLayoutViewItem().NeedsLayout()))\n      View()->UpdateLayout();\n  }\n  load_event_progress_ = kLoadEventCompleted;\n  if (GetFrame() && !GetLayoutViewItem().IsNull() &&\n      GetSettings()->GetAccessibilityEnabled()) {\n    if (AXObjectCache* cache = GetOrCreateAXObjectCache()) {\n      if (this == &AXObjectCacheOwner())\n        cache->HandleLoadComplete(this);\n      else\n        cache->HandleLayoutComplete(this);\n    }\n  }\n  if (SvgExtensions())\n    AccessSVGExtensions().StartAnimations();\n}", "target": 0}
{"code": "static int ieee80211_fragment(struct ieee80211_tx_data *tx,\n\t\t\t      struct sk_buff *skb, int hdrlen,\n\t\t\t      int frag_threshold)\n{\n\tstruct ieee80211_local *local = tx->local;\n\tstruct ieee80211_tx_info *info;\n\tstruct sk_buff *tmp;\n\tint per_fragm = frag_threshold - hdrlen - FCS_LEN;\n\tint pos = hdrlen + per_fragm;\n\tint rem = skb->len - hdrlen - per_fragm;\n\tif (WARN_ON(rem < 0))\n\t\treturn -EINVAL;\n\twhile (rem) {\n\t\tint fraglen = per_fragm;\n\t\tif (fraglen > rem)\n\t\t\tfraglen = rem;\n\t\trem -= fraglen;\n\t\ttmp = dev_alloc_skb(local->tx_headroom +\n\t\t\t\t    frag_threshold +\n\t\t\t\t    tx->sdata->encrypt_headroom +\n\t\t\t\t    IEEE80211_ENCRYPT_TAILROOM);\n\t\tif (!tmp)\n\t\t\treturn -ENOMEM;\n\t\t__skb_queue_tail(&tx->skbs, tmp);\n\t\tskb_reserve(tmp,\n\t\t\t    local->tx_headroom + tx->sdata->encrypt_headroom);\n\t\tmemcpy(tmp->cb, skb->cb, sizeof(tmp->cb));\n\t\tinfo = IEEE80211_SKB_CB(tmp);\n\t\tinfo->flags &= ~(IEEE80211_TX_CTL_CLEAR_PS_FILT |\n\t\t\t\t IEEE80211_TX_CTL_FIRST_FRAGMENT);\n\t\tif (rem)\n\t\t\tinfo->flags |= IEEE80211_TX_CTL_MORE_FRAMES;\n\t\tskb_copy_queue_mapping(tmp, skb);\n\t\ttmp->priority = skb->priority;\n\t\ttmp->dev = skb->dev;\n\t\tmemcpy(skb_put(tmp, hdrlen), skb->data, hdrlen);\n\t\tmemcpy(skb_put(tmp, fraglen), skb->data + pos, fraglen);\n\t\tpos += fraglen;\n\t}\n\tskb->len = hdrlen + per_fragm;\n\treturn 0;\n}", "target": 1}
{"code": "TEST_F(ZNCTest, StatusEchoMessage) {\n    auto znc = Run();\n    auto ircd = ConnectIRCd();\n    auto client = LoginClient();\n    client.Write(\"CAP REQ :echo-message\");\n    client.Write(\"PRIVMSG *status :blah\");\n    client.ReadUntil(\":nick!user@irc.znc.in PRIVMSG *status :blah\");\n    client.ReadUntil(\":*status!znc@znc.in PRIVMSG nick :Unknown command\");\n    client.Write(\"znc delnetwork test\");\n    client.ReadUntil(\"Network deleted\");\n    auto client2 = LoginClient();\n    client2.Write(\"PRIVMSG *status :blah2\");\n    client2.ReadUntil(\":*status!znc@znc.in PRIVMSG nick :Unknown command\");\n    auto client3 = LoginClient();\n    client3.Write(\"PRIVMSG *status :blah3\");\n    client3.ReadUntil(\":*status!znc@znc.in PRIVMSG nick :Unknown command\");\n}", "target": 0}
{"code": "void swallow_arg(int *argcp, char *argv[], char *which)\n{\n\tint i;\n\tfor (i = 1; argv[i]; i++) {\n\t\tif (strcmp(argv[i], which) != 0)\n\t\t\tcontinue;\n\t\tfor (; argv[i]; i++) {\n\t\t\targv[i] = argv[i+1];\n\t\t}\n\t\t(*argcp)--;\n\t\treturn;\n\t}\n}", "target": 0}
{"code": "int bad_format_axis(char *fmt){\n    return bad_format_check(\"^\" SAFE_STRING FLOAT_STRING SAFE_STRING \"$\",fmt);\n}", "target": 0}
{"code": "gss_delete_sec_context (minor_status,\n                        context_handle,\n                        output_token)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t *\t\tcontext_handle;\ngss_buffer_t\t\toutput_token;\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    status = val_del_sec_ctx_args(minor_status, context_handle, output_token);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n    ctx = (gss_union_ctx_id_t) *context_handle;\n    if (GSSINT_CHK_LOOP(ctx))\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n    status = gssint_delete_internal_sec_context(minor_status,\n\t\t\t\t\t\tctx->mech_type,\n\t\t\t\t\t\t&ctx->internal_ctx_id,\n\t\t\t\t\t\toutput_token);\n    if (status)\n\treturn status;\n    free(ctx->mech_type->elements);\n    free(ctx->mech_type);\n    free(*context_handle);\n    *context_handle = GSS_C_NO_CONTEXT;\n    return (GSS_S_COMPLETE);\n}", "target": 1}
{"code": "mm_share_sync(struct mm_master **pmm, struct mm_master **pmmalloc)\n{\n\tstruct mm_master *mm;\n\tstruct mm_master *mmalloc;\n\tstruct mm_master *mmold;\n\tstruct mmtree rb_free, rb_allocated;\n\tdebug3(\"%s: Share sync\", __func__);\n\tmm = *pmm;\n\tmmold = mm->mmalloc;\n\tmm_memvalid(mmold, mm, sizeof(*mm));\n\tmmalloc = mm_create(NULL, mm->size);\n\tmm = mm_xmalloc(mmalloc, sizeof(struct mm_master));\n\tmemcpy(mm, *pmm, sizeof(struct mm_master));\n\tmm->mmalloc = mmalloc;\n\trb_free = mm->rb_free;\n\trb_allocated = mm->rb_allocated;\n\tRB_INIT(&mm->rb_free);\n\tRB_INIT(&mm->rb_allocated);\n\tmm_sync_list(&rb_free, &mm->rb_free, mm, mmold);\n\tmm_sync_list(&rb_allocated, &mm->rb_allocated, mm, mmold);\n\tmm_destroy(mmold);\n\t*pmm = mm;\n\t*pmmalloc = mmalloc;\n\tdebug3(\"%s: Share sync end\", __func__);\n}", "target": 1}
{"code": "xmlIsStreaming(xmlValidCtxtPtr ctxt) {\n    xmlParserCtxtPtr pctxt;\n    if (ctxt == NULL)\n        return(0);\n    if ((ctxt->finishDtd != XML_CTXT_FINISH_DTD_0) &&\n        (ctxt->finishDtd != XML_CTXT_FINISH_DTD_1))\n        return(0);\n    pctxt = ctxt->userData;\n    return(pctxt->parseMode == XML_PARSE_READER);\n}", "target": 0}
{"code": "STACK_OF(PKCS12_SAFEBAG) *PKCS12_unpack_p7encdata(PKCS7 *p7, const char *pass,\n                                                  int passlen)\n{\n    if (!PKCS7_type_is_encrypted(p7))\n        return NULL;\n    if (p7->d.encrypted == NULL) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_DECODE_ERROR);\n        return NULL;\n    }\n    return PKCS12_item_decrypt_d2i_ex(p7->d.encrypted->enc_data->algorithm,\n                                   ASN1_ITEM_rptr(PKCS12_SAFEBAGS),\n                                   pass, passlen,\n                                   p7->d.encrypted->enc_data->enc_data, 1,\n                                   p7->ctx.libctx, p7->ctx.propq);\n}", "target": 0}
{"code": "\t\tGetRunner(\n\t\t\tconst ReferenceHandle& that,\n\t\t\tLocal<Value> key_handle,\n\t\t\tMaybeLocal<Object> maybe_options,\n\t\t\tbool inherit\n\t\t) :\n\t\t\t\tcontext{that.context},\n\t\t\t\treference{that.reference},\n\t\t\t\toptions{maybe_options, inherit ?\n\t\t\t\t\tTransferOptions::Type::DeepReference : TransferOptions::Type::Reference},\n\t\t\t\tinherit{inherit} {\n\t\t\tthat.CheckDisposed();\n\t\t\tkey = ExternalCopy::CopyIfPrimitive(key_handle);\n\t\t\tif (!key) {\n\t\t\t\tthrow RuntimeTypeError(\"Invalid `key`\");\n\t\t\t}\n\t\t}", "target": 1}
{"code": "static void tight_send_compact_size(VncState *vs, size_t len)\n{\n    int lpc = 0;\n    int bytes = 0;\n    char buf[3] = {0, 0, 0};\n    buf[bytes++] = len & 0x7F;\n    if (len > 0x7F) {\n        buf[bytes-1] |= 0x80;\n        buf[bytes++] = (len >> 7) & 0x7F;\n        if (len > 0x3FFF) {\n            buf[bytes-1] |= 0x80;\n            buf[bytes++] = (len >> 14) & 0xFF;\n        }\n    }\n    for (lpc = 0; lpc < bytes; lpc++) {\n        vnc_write_u8(vs, buf[lpc]);\n    }\n}", "target": 0}
{"code": "Pl_Count::write(unsigned char* buf, size_t len)\n{\n    if (len)\n    {\n\tthis->m->count += QIntC::to_offset(len);\n\tgetNext()->write(buf, len);\n\tthis->m->last_char = buf[len - 1];\n    }\n}", "target": 1}
{"code": "MONGO_EXPORT int mongo_insert_batch( mongo *conn, const char *ns,\n                                     const bson **bsons, int count, mongo_write_concern *custom_write_concern,\n                                     int flags ) {\n    mongo_message *mm;\n    mongo_write_concern *write_concern = NULL;\n    int i;\n    char *data;\n    int overhead =  16 + 4 + strlen( ns ) + 1;\n    int size = overhead;\n    if( mongo_validate_ns( conn, ns ) != MONGO_OK )\n        return MONGO_ERROR;\n    for( i=0; i<count; i++ ) {\n        size += bson_size( bsons[i] );\n        if( mongo_bson_valid( conn, bsons[i], 1 ) != MONGO_OK )\n            return MONGO_ERROR;\n    }\n    if( ( size - overhead ) > conn->max_bson_size ) {\n        conn->err = MONGO_BSON_TOO_LARGE;\n        return MONGO_ERROR;\n    }\n    if( mongo_choose_write_concern( conn, custom_write_concern,\n                                    &write_concern ) == MONGO_ERROR ) {\n        return MONGO_ERROR;\n    }\n    mm = mongo_message_create( size , 0 , 0 , MONGO_OP_INSERT );\n    data = &mm->data;\n    if( flags & MONGO_CONTINUE_ON_ERROR )\n        data = mongo_data_append32( data, &ONE );\n    else\n        data = mongo_data_append32( data, &ZERO );\n    data = mongo_data_append( data, ns, strlen( ns ) + 1 );\n    for( i=0; i<count; i++ ) {\n        data = mongo_data_append( data, bsons[i]->data, bson_size( bsons[i] ) );\n    }\n    if( write_concern ) {\n        if( mongo_message_send( conn, mm ) == MONGO_ERROR ) {\n            return MONGO_ERROR;\n        }\n        return mongo_check_last_error( conn, ns, write_concern );\n    }\n    else {\n        return mongo_message_send( conn, mm );\n    }\n}", "target": 1}
{"code": "static int lmf_header_load(lmf_header *lmfh, RBuffer *buf, Sdb *db) {\n\tif (r_buf_size (buf) < sizeof (lmf_header)) {\n\t\treturn false;\n\t}\n\tif (r_buf_fread_at (buf, QNX_HEADER_ADDR, (ut8 *) lmfh, \"iiiiiiiicccciiiicc\", 1) < QNX_HDR_SIZE) {\n\t\treturn false;\n\t}\n\tr_strf_buffer (32);\n\tsdb_set (db, \"qnx.version\", r_strf (\"0x%xH\", lmfh->version), 0);\n\tsdb_set (db, \"qnx.cflags\", r_strf (\"0x%xH\", lmfh->cflags), 0);\n\tsdb_set (db, \"qnx.cpu\", r_strf (\"0x%xH\", lmfh->cpu), 0);\n\tsdb_set (db, \"qnx.fpu\", r_strf (\"0x%xH\", lmfh->fpu), 0);\n\tsdb_set (db, \"qnx.code_index\", r_strf (\"0x%x\", lmfh->code_index), 0);\n\tsdb_set (db, \"qnx.stack_index\", r_strf (\"0x%x\", lmfh->stack_index), 0);\n\tsdb_set (db, \"qnx.heap_index\", r_strf (\"0x%x\", lmfh->heap_index), 0);\n\tsdb_set (db, \"qnx.argv_index\", r_strf (\"0x%x\", lmfh->argv_index), 0);\n\tsdb_set (db, \"qnx.code_offset\", r_strf (\"0x%x\", lmfh->code_offset), 0);\n\tsdb_set (db, \"qnx.stack_nbytes\", r_strf (\"0x%x\", lmfh->stack_nbytes), 0);\n\tsdb_set (db, \"qnx.heap_nbytes\", r_strf (\"0x%x\", lmfh->heap_nbytes), 0);\n\tsdb_set (db, \"qnx.image_base\", r_strf (\"0x%x\", lmfh->image_base), 0);\n\treturn true;\n}", "target": 1}
{"code": "static CACHE_BITMAP_V3_ORDER* update_read_cache_bitmap_v3_order(rdpUpdate* update, wStream* s,\n                                                                UINT16 flags)\n{\n\tBOOL rc;\n\tBYTE bitsPerPixelId;\n\tBITMAP_DATA_EX* bitmapData;\n\tUINT32 new_len;\n\tBYTE* new_data;\n\tCACHE_BITMAP_V3_ORDER* cache_bitmap_v3;\n\tif (!update || !s)\n\t\treturn NULL;\n\tcache_bitmap_v3 = calloc(1, sizeof(CACHE_BITMAP_V3_ORDER));\n\tif (!cache_bitmap_v3)\n\t\tgoto fail;\n\tcache_bitmap_v3->cacheId = flags & 0x00000003;\n\tcache_bitmap_v3->flags = (flags & 0x0000FF80) >> 7;\n\tbitsPerPixelId = (flags & 0x00000078) >> 3;\n\tcache_bitmap_v3->bpp = get_cbr2_bpp(bitsPerPixelId, &rc);\n\tif (!rc)\n\t\tgoto fail;\n\tif (Stream_GetRemainingLength(s) < 21)\n\t\tgoto fail;\n\tStream_Read_UINT16(s, cache_bitmap_v3->cacheIndex); \n\tStream_Read_UINT32(s, cache_bitmap_v3->key1);       \n\tStream_Read_UINT32(s, cache_bitmap_v3->key2);       \n\tbitmapData = &cache_bitmap_v3->bitmapData;\n\tStream_Read_UINT8(s, bitmapData->bpp);\n\tif ((bitmapData->bpp < 1) || (bitmapData->bpp > 32))\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"invalid bpp value %\" PRIu32 \"\", bitmapData->bpp);\n\t\tgoto fail;\n\t}\n\tStream_Seek_UINT8(s);                      \n\tStream_Seek_UINT8(s);                      \n\tStream_Read_UINT8(s, bitmapData->codecID); \n\tStream_Read_UINT16(s, bitmapData->width);  \n\tStream_Read_UINT16(s, bitmapData->height); \n\tStream_Read_UINT32(s, new_len);            \n\tif ((new_len == 0) || (Stream_GetRemainingLength(s) < new_len))\n\t\tgoto fail;\n\tnew_data = (BYTE*)realloc(bitmapData->data, new_len);\n\tif (!new_data)\n\t\tgoto fail;\n\tbitmapData->data = new_data;\n\tbitmapData->length = new_len;\n\tStream_Read(s, bitmapData->data, bitmapData->length);\n\treturn cache_bitmap_v3;\nfail:\n\tfree_cache_bitmap_v3_order(update->context, cache_bitmap_v3);\n\treturn NULL;\n}", "target": 0}
{"code": "fbFetchPixel_b8g8r8 (const FbBits *bits, int offset, miIndexedPtr indexed)\n{\n    CARD8   *pixel = ((CARD8 *) bits) + (offset*3);\n#if IMAGE_BYTE_ORDER == MSBFirst\n    return (0xff000000 |\n\t    (READ(pixel + 2) << 16) |\n\t    (READ(pixel + 1) << 8) |\n\t    (READ(pixel + 0)));\n#else\n    return (0xff000000 |\n\t    (READ(pixel + 0) << 16) |\n\t    (READ(pixel + 1) << 8) |\n\t    (READ(pixel + 2)));\n#endif\n}", "target": 0}
{"code": "  void libraw_recycle(libraw_data_t *lr)\n  {\n    if (!lr)\n      return;\n    LibRaw *ip = (LibRaw *)lr->parent_class;\n    ip->recycle();\n  }", "target": 0}
{"code": "static inline struct inode *vfs_select_inode(struct dentry *dentry,\n\t\t\t\t\t     unsigned open_flags)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tif (inode && unlikely(dentry->d_flags & DCACHE_OP_SELECT_INODE))\n\t\tinode = dentry->d_op->d_select_inode(dentry, open_flags);\n\treturn inode;\n}", "target": 0}
{"code": "const AtomicString& BaseAudioContext::InterfaceName() const {\n  return event_target_names::kAudioContext;\n}", "target": 0}
{"code": "irc_server_set_prefix_modes_chars (struct t_irc_server *server,\n                                   const char *prefix)\n{\n    char *pos;\n    int i, length_modes, length_chars;\n    if (!server || !prefix)\n        return;\n    if (server->prefix_modes)\n    {\n        free (server->prefix_modes);\n        server->prefix_modes = NULL;\n    }\n    if (server->prefix_chars)\n    {\n        free (server->prefix_chars);\n        server->prefix_chars = NULL;\n    }\n    pos = strchr (prefix, ')');\n    if (pos)\n    {\n        server->prefix_modes = weechat_strndup (prefix + 1,\n                                                pos - prefix - 1);\n        if (server->prefix_modes)\n        {\n            pos++;\n            length_modes = strlen (server->prefix_modes);\n            length_chars = strlen (pos);\n            server->prefix_chars = malloc (length_modes + 1);\n            if (server->prefix_chars)\n            {\n                for (i = 0; i < length_modes; i++)\n                {\n                    server->prefix_chars[i] = (i < length_chars) ? pos[i] : ' ';\n                }\n                server->prefix_chars[length_modes] = '\\0';\n            }\n            else\n            {\n                free (server->prefix_modes);\n                server->prefix_modes = NULL;\n            }\n        }\n    }\n}", "target": 1}
{"code": "static int em_sysenter(struct x86_emulate_ctxt *ctxt)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct cs, ss;\n\tu64 msr_data;\n\tu16 cs_sel, ss_sel;\n\tu64 efer = 0;\n\tops->get_msr(ctxt, MSR_EFER, &efer);\n\tif (ctxt->mode == X86EMUL_MODE_REAL)\n\t\treturn emulate_gp(ctxt, 0);\n\tif ((ctxt->mode == X86EMUL_MODE_PROT32) && (efer & EFER_LMA)\n\t    && !vendor_intel(ctxt))\n\t\treturn emulate_ud(ctxt);\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\tsetup_syscalls_segments(ctxt, &cs, &ss);\n\tops->get_msr(ctxt, MSR_IA32_SYSENTER_CS, &msr_data);\n\tswitch (ctxt->mode) {\n\tcase X86EMUL_MODE_PROT32:\n\t\tif ((msr_data & 0xfffc) == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tbreak;\n\tcase X86EMUL_MODE_PROT64:\n\t\tif (msr_data == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tctxt->eflags &= ~(EFLG_VM | EFLG_IF);\n\tcs_sel = (u16)msr_data;\n\tcs_sel &= ~SELECTOR_RPL_MASK;\n\tss_sel = cs_sel + 8;\n\tss_sel &= ~SELECTOR_RPL_MASK;\n\tif (ctxt->mode == X86EMUL_MODE_PROT64 || (efer & EFER_LMA)) {\n\t\tcs.d = 0;\n\t\tcs.l = 1;\n\t}\n\tops->set_segment(ctxt, cs_sel, &cs, 0, VCPU_SREG_CS);\n\tops->set_segment(ctxt, ss_sel, &ss, 0, VCPU_SREG_SS);\n\tops->get_msr(ctxt, MSR_IA32_SYSENTER_EIP, &msr_data);\n\tctxt->_eip = msr_data;\n\tops->get_msr(ctxt, MSR_IA32_SYSENTER_ESP, &msr_data);\n\t*reg_write(ctxt, VCPU_REGS_RSP) = msr_data;\n\treturn X86EMUL_CONTINUE;\n}", "target": 1}
{"code": "static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,\n\t\t\t\t     size_t count)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n\tunsigned long tmp;\n\tchar *p = (char *)page;\n\tssize_t ret;\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\ttmp = !!tmp; \n\tif (!test_bit(O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes) ||\n\t    !test_bit(O2NM_NODE_ATTR_NUM, &node->nd_set_attributes) ||\n\t    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))\n\t\treturn -EINVAL; \n\tif (tmp && tmp == cluster->cl_has_local &&\n\t    cluster->cl_local_node != node->nd_num)\n\t\treturn -EBUSY;\n\tif (tmp && !cluster->cl_has_local) {\n\t\tret = o2net_start_listening(node);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (!tmp && cluster->cl_has_local &&\n\t    cluster->cl_local_node == node->nd_num) {\n\t\to2net_stop_listening(node);\n\t\tcluster->cl_local_node = O2NM_INVALID_NODE_NUM;\n\t}\n\tnode->nd_local = tmp;\n\tif (node->nd_local) {\n\t\tcluster->cl_has_local = tmp;\n\t\tcluster->cl_local_node = node->nd_num;\n\t}\n\treturn count;\n}", "target": 1}
{"code": "wchar* ConvertPath(const wchar *SrcPath,wchar *DestPath,size_t DestSize)\n{\n  const wchar *DestPtr=SrcPath;\n  for (const wchar *s=DestPtr;*s!=0;s++)\n    if (IsPathDiv(s[0]) && s[1]=='.' && s[2]=='.' && IsPathDiv(s[3]))\n      DestPtr=s+4;\n  while (*DestPtr!=0)\n  {\n    const wchar *s=DestPtr;\n    if (s[0]!=0 && IsDriveDiv(s[1]))\n      s+=2;\n    if (s[0]=='\\\\' && s[1]=='\\\\')\n    {\n      const wchar *Slash=wcschr(s+2,'\\\\');\n      if (Slash!=NULL && (Slash=wcschr(Slash+1,'\\\\'))!=NULL)\n        s=Slash+1;\n    }\n    for (const wchar *t=s;*t!=0;t++)\n      if (IsPathDiv(*t))\n        s=t+1;\n      else\n        if (*t!='.')\n          break;\n    if (s==DestPtr)\n      break;\n    DestPtr=s;\n  }\n  if (DestPtr[0]=='.' && DestPtr[1]=='.' && DestPtr[2]==0)\n    DestPtr+=2;\n  if (DestPath!=NULL)\n  {\n    wchar TmpStr[NM];\n    wcsncpyz(TmpStr,DestPtr,ASIZE(TmpStr));\n    wcsncpyz(DestPath,TmpStr,DestSize);\n  }\n  return (wchar *)DestPtr;\n}", "target": 1}
{"code": "void Huff_transmit (huff_t *huff, int ch, byte *fout) {\n\tint i;\n\tif (huff->loc[ch] == NULL) { \n\t\tHuff_transmit(huff, NYT, fout);\n\t\tfor (i = 7; i >= 0; i--) {\n\t\t\tadd_bit((char)((ch >> i) & 0x1), fout);\n\t\t}\n\t} else {\n\t\tsend(huff->loc[ch], NULL, fout);\n\t}\n}", "target": 1}
{"code": "static int onChdir(rpmfi fi, void *data)\n{\n    struct diriter_s *di = data;\n    if (di->dirfd >= 0) {\n\tclose(di->dirfd);\n\tdi->dirfd = -1;\n    }\n    return 0;\n}", "target": 0}
{"code": "static void smb_set_posix_lock_done(struct tevent_req *subreq)\n{\n\tstruct smb_request *req = NULL;\n\tNTSTATUS status;\n\tbool ok;\n\tok = smbd_smb1_do_locks_extract_smbreq(subreq, talloc_tos(), &req);\n\tSMB_ASSERT(ok);\n\tstatus = smbd_smb1_do_locks_recv(subreq);\n\tTALLOC_FREE(subreq);\n\tif (NT_STATUS_IS_OK(status)) {\n\t\tchar params[2] = {0};\n\t\tsend_trans2_replies(\n\t\t\treq->conn,\n\t\t\treq,\n\t\t\tNT_STATUS_OK,\n\t\t\tparams,\n\t\t\t2,\n\t\t\tNULL,\n\t\t\t0,\n\t\t\t0xffff);\n\t} else {\n\t\treply_nterror(req, status);\n\t\tok = srv_send_smb(\n\t\t\treq->xconn,\n\t\t\t(char *)req->outbuf,\n\t\t\ttrue,\n\t\t\treq->seqnum+1,\n\t\t\tIS_CONN_ENCRYPTED(req->conn),\n\t\t\tNULL);\n\t\tif (!ok) {\n\t\t\texit_server_cleanly(\"smb_set_posix_lock_done: \"\n\t\t\t\t\t    \"srv_send_smb failed.\");\n\t\t}\n\t}\n\tTALLOC_FREE(req);\n\treturn;\n}", "target": 0}
{"code": "static INLINE BOOL update_read_brush(wStream* s, rdpBrush* brush, BYTE fieldFlags)\n{\n\tif (fieldFlags & ORDER_FIELD_01)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\t\tStream_Read_UINT8(s, brush->x);\n\t}\n\tif (fieldFlags & ORDER_FIELD_02)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\t\tStream_Read_UINT8(s, brush->y);\n\t}\n\tif (fieldFlags & ORDER_FIELD_03)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\t\tStream_Read_UINT8(s, brush->style);\n\t}\n\tif (fieldFlags & ORDER_FIELD_04)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\t\tStream_Read_UINT8(s, brush->hatch);\n\t}\n\tif (brush->style & CACHED_BRUSH)\n\t{\n\t\tbrush->index = brush->hatch;\n\t\tbrush->bpp = BMF_BPP[brush->style & 0x07];\n\t\tif (brush->bpp == 0)\n\t\t\tbrush->bpp = 1;\n\t}\n\tif (fieldFlags & ORDER_FIELD_05)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 7)\n\t\t\treturn FALSE;\n\t\tbrush->data = (BYTE*)brush->p8x8;\n\t\tStream_Read_UINT8(s, brush->data[7]);\n\t\tStream_Read_UINT8(s, brush->data[6]);\n\t\tStream_Read_UINT8(s, brush->data[5]);\n\t\tStream_Read_UINT8(s, brush->data[4]);\n\t\tStream_Read_UINT8(s, brush->data[3]);\n\t\tStream_Read_UINT8(s, brush->data[2]);\n\t\tStream_Read_UINT8(s, brush->data[1]);\n\t\tbrush->data[0] = brush->hatch;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "http_DissectRequest(struct sess *sp)\n{\n\tstruct http_conn *htc;\n\tstruct http *hp;\n\tuint16_t retval;\n\tCHECK_OBJ_NOTNULL(sp, SESS_MAGIC);\n\thtc = sp->htc;\n\tCHECK_OBJ_NOTNULL(htc, HTTP_CONN_MAGIC);\n\thp = sp->http;\n\tCHECK_OBJ_NOTNULL(hp, HTTP_MAGIC);\n\thp->logtag = HTTP_Rx;\n\tretval = http_splitline(sp->wrk, sp->fd, hp, htc,\n\t    HTTP_HDR_REQ, HTTP_HDR_URL, HTTP_HDR_PROTO);\n\tif (retval != 0) {\n\t\tWSPR(sp, SLT_HttpGarbage, htc->rxbuf);\n\t\treturn (retval);\n\t}\n\thttp_ProtoVer(hp);\n\tretval = htc_request_check_host_hdr(hp);\n\tif (retval != 0) {\n\t\tWSP(sp, SLT_Error, \"Duplicated Host header\");\n\t\treturn (retval);\n\t}\n\treturn (retval);\n}", "target": 1}
{"code": "void ParamTraits<ListValue>::Write(Message* m, const param_type& p) {\n  WriteValue(m, &p, 0);\n}", "target": 0}
{"code": "  DllDef int libraw_get_raw_height(libraw_data_t *lr)\n  {\n    if (!lr)\n      return EINVAL;\n    return lr->sizes.raw_height;\n  }", "target": 0}
{"code": "static int dnxhd_find_frame_end(DNXHDParserContext *dctx,\n                                const uint8_t *buf, int buf_size)\n{\n    ParseContext *pc = &dctx->pc;\n    uint64_t state = pc->state64;\n    int pic_found = pc->frame_start_found;\n    int i = 0;\n    if (!pic_found) {\n        for (i = 0; i < buf_size; i++) {\n            state = (state << 8) | buf[i];\n            if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {\n                i++;\n                pic_found = 1;\n                dctx->cur_byte = 0;\n                dctx->remaining = 0;\n                break;\n            }\n        }\n    }\n    if (pic_found && !dctx->remaining) {\n        if (!buf_size) \n            return 0;\n        for (; i < buf_size; i++) {\n            dctx->cur_byte++;\n            state = (state << 8) | buf[i];\n            if (dctx->cur_byte == 24) {\n                dctx->h = (state >> 32) & 0xFFFF;\n            } else if (dctx->cur_byte == 26) {\n                dctx->w = (state >> 32) & 0xFFFF;\n            } else if (dctx->cur_byte == 42) {\n                int cid = (state >> 32) & 0xFFFFFFFF;\n                if (cid <= 0)\n                    continue;\n                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);\n                if (dctx->remaining <= 0) {\n                    dctx->remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);\n                    if (dctx->remaining <= 0)\n                        return dctx->remaining;\n                }\n                if (buf_size - i + 47 >= dctx->remaining) {\n                    int remaining = dctx->remaining;\n                    pc->frame_start_found = 0;\n                    pc->state64 = -1;\n                    dctx->cur_byte = 0;\n                    dctx->remaining = 0;\n                    return remaining;\n                } else {\n                    dctx->remaining -= buf_size;\n                }\n            }\n        }\n    } else if (pic_found) {\n        if (dctx->remaining > buf_size) {\n            dctx->remaining -= buf_size;\n        } else {\n            int remaining = dctx->remaining;\n            pc->frame_start_found = 0;\n            pc->state64 = -1;\n            dctx->cur_byte = 0;\n            dctx->remaining = 0;\n            return remaining;\n        }\n    }\n    pc->frame_start_found = pic_found;\n    pc->state64 = state;\n    return END_NOT_FOUND;\n}", "target": 1}
{"code": "static inline Quantum ScaleLongLongToQuantum(const MagickSizeType value)\n{\n  return((Quantum) (value));\n}", "target": 0}
{"code": "static gboolean key_value_ok(gchar *key, gchar *value)\n{\n    char *i;\n    for (i = key; *i != 0; i++)\n    {\n        if (!isalpha(*i) && (*i != '-') && (*i != '_') && (*i != ' '))\n            return FALSE;\n    }\n    if (strcmp(key, \"basename\") == 0\n     || strcmp(key, FILENAME_TYPE) == 0\n    )\n    {\n        if (!str_is_correct_filename(value))\n        {\n            error_msg(\"Value of '%s' ('%s') is not a valid directory name\",\n                      key, value);\n            return FALSE;\n        }\n    }\n    return allowed_new_user_problem_entry(client_uid, key, value);\n}", "target": 0}
{"code": "static inline bool IsGlobbingPattern(const std::string& pattern) {\n  return (pattern.find_first_of(kGlobbingChars) != std::string::npos);\n}", "target": 0}
{"code": "static int cert_verify_ignore_callback(X509_STORE_CTX*, void*)\n{\n    return 1;\n}", "target": 0}
{"code": "static void ide_atapi_cmd_read(IDEState *s, int lba, int nb_sectors,\n                               int sector_size)\n{\n#ifdef DEBUG_IDE_ATAPI\n    printf(\"read %s: LBA=%d nb_sectors=%d\\n\", s->atapi_dma ? \"dma\" : \"pio\",\n        lba, nb_sectors);\n#endif\n    if (s->atapi_dma) {\n        ide_atapi_cmd_read_dma(s, lba, nb_sectors, sector_size);\n    } else {\n        ide_atapi_cmd_read_pio(s, lba, nb_sectors, sector_size);\n    }\n}", "target": 0}
{"code": "is_valid_filename (const char *p)\n{\n\tif (!*p)\n\t\treturn 0;\n\treturn strpbrk (p, \"\\\\\n}", "target": 0}
{"code": "static int vgacon_switch(struct vc_data *c)\n{\n\tint x = c->vc_cols * VGA_FONTWIDTH;\n\tint y = c->vc_rows * c->vc_font.height;\n\tint rows = screen_info.orig_video_lines * vga_default_font_height/\n\t\tc->vc_font.height;\n\tvga_video_num_columns = c->vc_cols;\n\tvga_video_num_lines = c->vc_rows;\n\tif (!vga_is_gfx) {\n\t\tscr_memcpyw((u16 *) c->vc_origin, (u16 *) c->vc_screenbuf,\n\t\t\t    c->vc_screenbuf_size > vga_vram_size ?\n\t\t\t\tvga_vram_size : c->vc_screenbuf_size);\n\t\tif ((vgacon_xres != x || vgacon_yres != y) &&\n\t\t    (!(vga_video_num_columns % 2) &&\n\t\t     vga_video_num_columns <= screen_info.orig_video_cols &&\n\t\t     vga_video_num_lines <= rows))\n\t\t\tvgacon_doresize(c, c->vc_cols, c->vc_rows);\n\t}\n\tvgacon_scrollback_switch(c->vc_num);\n\treturn 0;\t\t\n}", "target": 1}
{"code": "TEST(BCastTest, Basic_Tensor_Scalar) {\n  EXPECT_EQ(BCast({11, 7, 5, 3, 2}, {1}),\n            \"[2310][1][1][2310]\"\n            \"[2310]\"\n            \"[11,7,5,3,2]\"\n            \"[][0,1,2,3,4]\");\n  EXPECT_EQ(BCast({11, 7, 5, 3, 2}, {1}, false),\n            \"[11,7,5,3,2][1,1,1,1,1][1,1,1,1,1][11,7,5,3,2]\"\n            \"[11,7,5,3,2]\"\n            \"[11,7,5,3,2]\"\n            \"[][0,1,2,3,4]\");\n  EXPECT_EQ(BCast({1}, {11, 7, 5, 3, 2}),\n            \"[1][2310][2310][1]\"\n            \"[2310]\"\n            \"[11,7,5,3,2]\"\n            \"[0,1,2,3,4][]\");\n  EXPECT_EQ(BCast({1}, {11, 7, 5, 3, 2}, false),\n            \"[1,1,1,1,1][11,7,5,3,2][11,7,5,3,2][1,1,1,1,1]\"\n            \"[11,7,5,3,2]\"\n            \"[11,7,5,3,2]\"\n            \"[0,1,2,3,4][]\");\n  EXPECT_EQ(BCast({1, 2147483648}, {1}),\n            \"[2147483648][1][1][2147483648]\"\n            \"[2147483648]\"\n            \"[1,2147483648]\"\n            \"[0][0,1]\");\n}", "target": 0}
{"code": "static ssize_t generic_perform_write(struct file *file,\n\t\t\t\tstruct iov_iter *i, loff_t pos)\n{\n\tstruct address_space *mapping = file->f_mapping;\n\tconst struct address_space_operations *a_ops = mapping->a_ops;\n\tlong status = 0;\n\tssize_t written = 0;\n\tunsigned int flags = 0;\n\tif (segment_eq(get_fs(), KERNEL_DS))\n\t\tflags |= AOP_FLAG_UNINTERRUPTIBLE;\n\tdo {\n\t\tstruct page *page;\n\t\tpgoff_t index;\t\t\n\t\tunsigned long offset;\t\n\t\tunsigned long bytes;\t\n\t\tsize_t copied;\t\t\n\t\tvoid *fsdata;\n\t\toffset = (pos & (PAGE_CACHE_SIZE - 1));\n\t\tindex = pos >> PAGE_CACHE_SHIFT;\n\t\tbytes = min_t(unsigned long, PAGE_CACHE_SIZE - offset,\n\t\t\t\t\t\tiov_iter_count(i));\nagain:\n\t\tif (unlikely(iov_iter_fault_in_readable(i, bytes))) {\n\t\t\tstatus = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tstatus = a_ops->write_begin(file, mapping, pos, bytes, flags,\n\t\t\t\t\t\t&page, &fsdata);\n\t\tif (unlikely(status))\n\t\t\tbreak;\n\t\tpagefault_disable();\n\t\tcopied = iov_iter_copy_from_user_atomic(page, i, offset, bytes);\n\t\tpagefault_enable();\n\t\tflush_dcache_page(page);\n\t\tstatus = a_ops->write_end(file, mapping, pos, bytes, copied,\n\t\t\t\t\t\tpage, fsdata);\n\t\tif (unlikely(status < 0))\n\t\t\tbreak;\n\t\tcopied = status;\n\t\tcond_resched();\n\t\tif (unlikely(copied == 0)) {\n\t\t\tbytes = min_t(unsigned long, PAGE_CACHE_SIZE - offset,\n\t\t\t\t\t\tiov_iter_single_seg_count(i));\n\t\t\tgoto again;\n\t\t}\n\t\tiov_iter_advance(i, copied);\n\t\tpos += copied;\n\t\twritten += copied;\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\t} while (iov_iter_count(i));\n\treturn written ? written : status;\n}", "target": 1}
{"code": "static inline int mk_vhost_fdt_close(struct session_request *sr)\n{\n    int id;\n    unsigned int hash;\n    struct vhost_fdt_hash_table *ht = NULL;\n    struct vhost_fdt_hash_chain *hc;\n    if (config->fdt == MK_FALSE) {\n        return close(sr->fd_file);\n    }\n    id   = sr->vhost_fdt_id;\n    hash = sr->vhost_fdt_hash;\n    ht = mk_vhost_fdt_table_lookup(id, sr->host_conf);\n    if (mk_unlikely(!ht)) {\n        return close(sr->fd_file);\n    }\n    hc = mk_vhost_fdt_chain_lookup(hash, ht);\n    if (hc) {\n        hc->readers--;\n        if (hc->readers == 0) {\n            hc->fd   = -1;\n            hc->hash = 0;\n            ht->av_slots++;\n            return close(sr->fd_file);\n        }\n        else {\n            return 0;\n        }\n    }\n    return close(sr->fd_file);\n}", "target": 1}
{"code": "copy_thread(unsigned long clone_flags, unsigned long stack_start,\n\t    unsigned long stk_sz, struct task_struct *p)\n{\n\tstruct thread_info *thread = task_thread_info(p);\n\tstruct pt_regs *childregs = task_pt_regs(p);\n\tmemset(&thread->cpu_context, 0, sizeof(struct cpu_context_save));\n\tif (likely(!(p->flags & PF_KTHREAD))) {\n\t\t*childregs = *current_pt_regs();\n\t\tchildregs->ARM_r0 = 0;\n\t\tif (stack_start)\n\t\t\tchildregs->ARM_sp = stack_start;\n\t} else {\n\t\tmemset(childregs, 0, sizeof(struct pt_regs));\n\t\tthread->cpu_context.r4 = stk_sz;\n\t\tthread->cpu_context.r5 = stack_start;\n\t\tchildregs->ARM_cpsr = SVC_MODE;\n\t}\n\tthread->cpu_context.pc = (unsigned long)ret_from_fork;\n\tthread->cpu_context.sp = (unsigned long)childregs;\n\tclear_ptrace_hw_breakpoint(p);\n\tif (clone_flags & CLONE_SETTLS)\n\t\tthread->tp_value = childregs->ARM_r3;\n\tthread_notify(THREAD_NOTIFY_COPY, thread);\n\treturn 0;\n}", "target": 1}
{"code": "xml_unload_external_entity(const char *URI, xmlCharEncoding enc)    {\n    return NULL;\n}", "target": 0}
{"code": "smb_fdata(netdissect_options *ndo,\n          const u_char *buf, const char *fmt, const u_char *maxbuf,\n          int unicodestr)\n{\n    static int depth = 0;\n    char s[128];\n    char *p;\n    while (*fmt) {\n\tswitch (*fmt) {\n\tcase '*':\n\t    fmt++;\n\t    while (buf < maxbuf) {\n\t\tconst u_char *buf2;\n\t\tdepth++;\n\t\tbuf2 = smb_fdata(ndo, buf, fmt, maxbuf, unicodestr);\n\t\tdepth--;\n\t\tif (buf2 == NULL)\n\t\t    return(NULL);\n\t\tif (buf2 == buf)\n\t\t    return(buf);\n\t\tbuf = buf2;\n\t    }\n\t    return(buf);\n\tcase '|':\n\t    fmt++;\n\t    if (buf >= maxbuf)\n\t\treturn(buf);\n\t    break;\n\tcase '%':\n\t    fmt++;\n\t    buf = maxbuf;\n\t    break;\n\tcase '#':\n\t    fmt++;\n\t    return(buf);\n\t    break;\n\tcase '[':\n\t    fmt++;\n\t    if (buf >= maxbuf)\n\t\treturn(buf);\n\t    memset(s, 0, sizeof(s));\n\t    p = strchr(fmt, ']');\n\t    if ((size_t)(p - fmt + 1) > sizeof(s)) {\n\t\treturn(buf);\n\t    }\n\t    strncpy(s, fmt, p - fmt);\n\t    s[p - fmt] = '\\0';\n\t    fmt = p + 1;\n\t    buf = smb_fdata1(ndo, buf, s, maxbuf, unicodestr);\n\t    if (buf == NULL)\n\t\treturn(NULL);\n\t    break;\n\tdefault:\n\t    ND_PRINT((ndo, \"%c\", *fmt));\n\t    fmt++;\n\t    break;\n\t}\n    }\n    if (!depth && buf < maxbuf) {\n\tsize_t len = PTR_DIFF(maxbuf, buf);\n\tND_PRINT((ndo, \"Data: (%lu bytes)\\n\", (unsigned long)len));\n\tsmb_print_data(ndo, buf, len);\n\treturn(buf + len);\n    }\n    return(buf);\n}", "target": 1}
{"code": "    Curl()\n    {\n        requestHeaders = 0;\n        curl = curl_easy_init();\n        if (!curl) throw Error(\"unable to initialize curl\");\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n        curl_easy_setopt(curl, CURLOPT_CAINFO, getEnv(\"SSL_CERT_FILE\", \"/etc/ssl/certs/ca-certificates.crt\").c_str());\n        curl_easy_setopt(curl, CURLOPT_USERAGENT, (\"Nix/\" + nixVersion).c_str());\n        curl_easy_setopt(curl, CURLOPT_FAILONERROR, 1);\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeCallback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *) &curl);\n        curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, headerCallback);\n        curl_easy_setopt(curl, CURLOPT_HEADERDATA, (void *) &curl);\n        curl_easy_setopt(curl, CURLOPT_PROGRESSFUNCTION, progressCallback_);\n        curl_easy_setopt(curl, CURLOPT_PROGRESSDATA, (void *) &curl);\n        curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 0);\n        showProgress = isatty(STDERR_FILENO);\n    }", "target": 1}
{"code": "static int sanitize_val_alu(struct bpf_verifier_env *env,\n\t\t\t    struct bpf_insn *insn)\n{\n\tstruct bpf_insn_aux_data *aux = cur_aux(env);\n\tif (can_skip_alu_sanitation(env, insn))\n\t\treturn 0;\n\treturn update_alu_sanitation_state(aux, BPF_ALU_NON_POINTER, 0);\n}", "target": 0}
{"code": "static int ras_getdatastd(jas_stream_t *in, ras_hdr_t *hdr, ras_cmap_t *cmap,\n  jas_image_t *image)\n{\n\tint pad;\n\tint nz;\n\tint z;\n\tint c;\n\tint y;\n\tint x;\n\tint v;\n\tint i;\n\tjas_matrix_t *data[3];\n\tcmap = 0;\n\tfor (i = 0; i < jas_image_numcmpts(image); ++i) {\n\t\tdata[i] = jas_matrix_create(1, jas_image_width(image));\n\t\tassert(data[i]);\n\t}\n\tpad = RAS_ROWSIZE(hdr) - (hdr->width * hdr->depth + 7) / 8;\n\tfor (y = 0; y < hdr->height; y++) {\n\t\tnz = 0;\n\t\tz = 0;\n\t\tfor (x = 0; x < hdr->width; x++) {\n\t\t\twhile (nz < hdr->depth) {\n\t\t\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tz = (z << 8) | c;\n\t\t\t\tnz += 8;\n\t\t\t}\n\t\t\tv = (z >> (nz - hdr->depth)) & RAS_ONES(hdr->depth);\n\t\t\tz &= RAS_ONES(nz - hdr->depth);\n\t\t\tnz -= hdr->depth;\n\t\t\tif (jas_image_numcmpts(image) == 3) {\n\t\t\t\tjas_matrix_setv(data[0], x, (RAS_GETRED(v)));\n\t\t\t\tjas_matrix_setv(data[1], x, (RAS_GETGREEN(v)));\n\t\t\t\tjas_matrix_setv(data[2], x, (RAS_GETBLUE(v)));\n\t\t\t} else {\n\t\t\t\tjas_matrix_setv(data[0], x, (v));\n\t\t\t}\n\t\t}\n\t\tif (pad) {\n\t\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < jas_image_numcmpts(image); ++i) {\n\t\t\tif (jas_image_writecmpt(image, i, 0, y, hdr->width, 1,\n\t\t\t  data[i])) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i < jas_image_numcmpts(image); ++i) {\n\t\tjas_matrix_destroy(data[i]);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "\t\tauto Phase3() -> Local<Value> final {\n\t\t\treturn Boolean::New(Isolate::GetCurrent(), did_set);\n\t\t}", "target": 1}
{"code": "static inline int copy_regset_from_user(struct task_struct *target,\n\t\t\t\t\tconst struct user_regset_view *view,\n\t\t\t\t\tunsigned int setno,\n\t\t\t\t\tunsigned int offset, unsigned int size,\n\t\t\t\t\tconst void __user *data)\n{\n\tconst struct user_regset *regset = &view->regsets[setno];\n\tif (!regset->set)\n\t\treturn -EOPNOTSUPP;\n\tif (!access_ok(VERIFY_READ, data, size))\n\t\treturn -EIO;\n\treturn regset->set(target, regset, offset, size, NULL, data);\n}", "target": 0}
{"code": "update_notification_create(struct update_notification **file)\n{\n\tstruct update_notification *tmp;\n\tstruct deltas_head *list;\n\tint error;\n\ttmp = malloc(sizeof(struct update_notification));\n\tif (tmp == NULL)\n\t\treturn pr_enomem();\n\tlist = NULL;\n\terror = deltas_head_create(&list);\n\tif (error) {\n\t\tfree(tmp);\n\t\treturn error;\n\t}\n\ttmp->deltas_list = list;\n\ttmp->uri = NULL;\n\tglobal_data_init(&tmp->global_data);\n\tdoc_data_init(&tmp->snapshot);\n\t*file = tmp;\n\treturn 0;\n}", "target": 1}
{"code": "inline uint32_t mult_alpha(uint32_t a, uint32_t b)\n{\n    return 0xFF - (0xFF - a) * (0xFF - b) / 0xFF;\n}", "target": 0}
{"code": "mm_free(struct mm_master *mm, void *address)\n{\n\tstruct mm_share *mms, *prev, tmp;\n\ttmp.address = address;\n\tmms = RB_FIND(mmtree, &mm->rb_allocated, &tmp);\n\tif (mms == NULL)\n\t\tfatal(\"mm_free(%p): can not find %p\", mm, address);\n\tmemset(mms->address, 0xd0, mms->size);\n\tRB_REMOVE(mmtree, &mm->rb_allocated, mms);\n\tif (RB_INSERT(mmtree, &mm->rb_free, mms) != NULL)\n\t\tfatal(\"mm_free(%p): double address %p\", mm, address);\n\tprev = mms;\n\tif (RB_LEFT(prev, next)) {\n\t\tprev = RB_LEFT(prev, next);\n\t\twhile (RB_RIGHT(prev, next))\n\t\t\tprev = RB_RIGHT(prev, next);\n\t} else {\n\t\tif (RB_PARENT(prev, next) &&\n\t\t    (prev == RB_RIGHT(RB_PARENT(prev, next), next)))\n\t\t\tprev = RB_PARENT(prev, next);\n\t\telse {\n\t\t\twhile (RB_PARENT(prev, next) &&\n\t\t\t    (prev == RB_LEFT(RB_PARENT(prev, next), next)))\n\t\t\t\tprev = RB_PARENT(prev, next);\n\t\t\tprev = RB_PARENT(prev, next);\n\t\t}\n\t}\n\tif (prev != NULL && MM_ADDRESS_END(prev) > address)\n\t\tfatal(\"mm_free: memory corruption: %p(%zu) > %p\",\n\t\t    prev->address, prev->size, address);\n\tif (prev != NULL && MM_ADDRESS_END(prev) == address) {\n\t\tprev->size += mms->size;\n\t\tRB_REMOVE(mmtree, &mm->rb_free, mms);\n\t\tif (mm->mmalloc == NULL)\n\t\t\tfree(mms);\n\t\telse\n\t\t\tmm_free(mm->mmalloc, mms);\n\t} else\n\t\tprev = mms;\n\tif (prev == NULL)\n\t\treturn;\n\tmms = RB_NEXT(mmtree, &mm->rb_free, prev);\n\tif (mms == NULL)\n\t\treturn;\n\tif (MM_ADDRESS_END(prev) > mms->address)\n\t\tfatal(\"mm_free: memory corruption: %p < %p(%zu)\",\n\t\t    mms->address, prev->address, prev->size);\n\tif (MM_ADDRESS_END(prev) != mms->address)\n\t\treturn;\n\tprev->size += mms->size;\n\tRB_REMOVE(mmtree, &mm->rb_free, mms);\n\tif (mm->mmalloc == NULL)\n\t\tfree(mms);\n\telse\n\t\tmm_free(mm->mmalloc, mms);\n}", "target": 1}
{"code": "ExprCreateFloat(void)\n{\n    EXPR_CREATE(ExprFloat, expr, EXPR_VALUE, EXPR_TYPE_FLOAT);\n    return expr;\n}", "target": 0}
{"code": "static int asymmetric_key_match(const struct key *key,\n\t\t\t\tconst struct key_match_data *match_data)\n{\n\tconst struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);\n\tconst char *description = match_data->raw_data;\n\tconst char *spec = description;\n\tconst char *id;\n\tptrdiff_t speclen;\n\tif (!subtype || !spec || !*spec)\n\t\treturn 0;\n\tif (key->description && strcmp(key->description, description) == 0)\n\t\treturn 1;\n\tid = strchr(spec, ':');\n\tif (!id)\n\t\treturn 0;\n\tspeclen = id - spec;\n\tid++;\n\tif (speclen == 2 && memcmp(spec, \"id\", 2) == 0)\n\t\treturn asymmetric_keyid_match(asymmetric_key_id(key), id);\n\tif (speclen == subtype->name_len &&\n\t    memcmp(spec, subtype->name, speclen) == 0)\n\t\treturn 1;\n\treturn 0;\n}", "target": 1}
{"code": "quant::UniformQuantizedPerAxisType ResetAxisAndBroadcast(\n    ArrayRef<int64_t> shape, quant::UniformQuantizedPerAxisType qtype,\n    Type target, int quant_dim) {\n  auto shaped = target.dyn_cast<RankedTensorType>();\n  if (!shaped) return {};\n  ArrayRef<int64_t> new_shape = shaped.getShape();\n  SmallVector<double, 4> scales(qtype.getScales().begin(),\n                                qtype.getScales().end());\n  SmallVector<int64_t, 4> zero_points(qtype.getZeroPoints().begin(),\n                                      qtype.getZeroPoints().end());\n  if (new_shape.size() == shape.size()) {  \n    if (BroadcastVector<double>(shaped.getDimSize(quant_dim), scales) ||\n        BroadcastVector<int64_t>(shaped.getDimSize(quant_dim), zero_points)) {\n      return {};\n    }\n  } else if ((new_shape.size() == shape.size() + 1) && new_shape.back() == 1) {\n    if (std::equal(shape.begin(), shape.end(), new_shape.begin()) &&\n        quant_dim == -1) {\n      quant_dim = shape.size() + quant_dim;\n    } else {\n      return {};\n    }\n  } else {\n    return {};\n  }\n  return quant::UniformQuantizedPerAxisType::get(\n      qtype.getFlags(), qtype.getStorageType(), qtype.getExpressedType(),\n      scales, zero_points, quant_dim, qtype.getStorageTypeMin(),\n      qtype.getStorageTypeMax());\n}", "target": 1}
{"code": "static int nci_extract_activation_params_iso_dep(struct nci_dev *ndev,\n\t\t\tstruct nci_rf_intf_activated_ntf *ntf, __u8 *data)\n{\n\tstruct activation_params_nfca_poll_iso_dep *nfca_poll;\n\tstruct activation_params_nfcb_poll_iso_dep *nfcb_poll;\n\tswitch (ntf->activation_rf_tech_and_mode) {\n\tcase NCI_NFC_A_PASSIVE_POLL_MODE:\n\t\tnfca_poll = &ntf->activation_params.nfca_poll_iso_dep;\n\t\tnfca_poll->rats_res_len = *data++;\n\t\tpr_debug(\"rats_res_len %d\\n\", nfca_poll->rats_res_len);\n\t\tif (nfca_poll->rats_res_len > 0) {\n\t\t\tmemcpy(nfca_poll->rats_res,\n\t\t\t       data, nfca_poll->rats_res_len);\n\t\t}\n\t\tbreak;\n\tcase NCI_NFC_B_PASSIVE_POLL_MODE:\n\t\tnfcb_poll = &ntf->activation_params.nfcb_poll_iso_dep;\n\t\tnfcb_poll->attrib_res_len = *data++;\n\t\tpr_debug(\"attrib_res_len %d\\n\", nfcb_poll->attrib_res_len);\n\t\tif (nfcb_poll->attrib_res_len > 0) {\n\t\t\tmemcpy(nfcb_poll->attrib_res,\n\t\t\t       data, nfcb_poll->attrib_res_len);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unsupported activation_rf_tech_and_mode 0x%x\\n\",\n\t\t       ntf->activation_rf_tech_and_mode);\n\t\treturn NCI_STATUS_RF_PROTOCOL_ERROR;\n\t}\n\treturn NCI_STATUS_OK;\n}", "target": 1}
{"code": "static int init_die(RzBinDwarfDie *die, ut64 abbr_code, ut64 attr_count) {\n\tif (!die) {\n\t\treturn -1;\n\t}\n\tdie->attr_values = calloc(sizeof(RzBinDwarfAttrValue), attr_count);\n\tif (!die->attr_values) {\n\t\treturn -1;\n\t}\n\tdie->abbrev_code = abbr_code;\n\tdie->capacity = attr_count;\n\tdie->count = 0;\n\treturn 0;\n}", "target": 1}
{"code": "flatpak_run_get_cups_server_name_config (const char *path)\n{\n  g_autoptr(GFile) file = g_file_new_for_path (path);\n  g_autoptr(GError) my_error = NULL;\n  g_autoptr(GFileInputStream) input_stream = NULL;\n  g_autoptr(GDataInputStream) data_stream = NULL;\n  size_t len;\n  input_stream = g_file_read (file, NULL, &my_error);\n  if (my_error)\n    {\n      g_debug (\"CUPS configuration file '%s': %s\", path, my_error->message);\n      return NULL;\n    }\n  data_stream = g_data_input_stream_new (G_INPUT_STREAM (input_stream));\n  while (TRUE)\n    {\n      g_autofree char *line = g_data_input_stream_read_line (data_stream, &len, NULL, NULL);\n      if (line == NULL)\n        break;\n      g_strchug (line);\n      if ((*line  == '\\0') || (*line == '#'))\n        continue;\n      g_auto(GStrv) tokens = g_strsplit (line, \" \", 2);\n      if ((tokens[0] != NULL) && (tokens[1] != NULL))\n        {\n          if (strcmp (\"ServerName\", tokens[0]) == 0)\n            {\n              g_strchug (tokens[1]);\n              if (flatpak_run_cups_check_server_is_socket (tokens[1]))\n                return g_strdup (tokens[1]);\n            }\n        }\n    }\n    return NULL;\n}", "target": 0}
{"code": "static int sctp_sf_send_restart_abort(struct net *net, union sctp_addr *ssa,\n\t\t\t\t      struct sctp_chunk *init,\n\t\t\t\t      sctp_cmd_seq_t *commands)\n{\n\tint len;\n\tstruct sctp_packet *pkt;\n\tunion sctp_addr_param *addrparm;\n\tstruct sctp_errhdr *errhdr;\n\tstruct sctp_endpoint *ep;\n\tchar buffer[sizeof(struct sctp_errhdr)+sizeof(union sctp_addr_param)];\n\tstruct sctp_af *af = sctp_get_af_specific(ssa->v4.sin_family);\n\terrhdr = (struct sctp_errhdr *)buffer;\n\taddrparm = (union sctp_addr_param *)errhdr->variable;\n\tlen = af->to_addr_param(ssa, addrparm);\n\tlen += sizeof(sctp_errhdr_t);\n\terrhdr->cause = SCTP_ERROR_RESTART;\n\terrhdr->length = htons(len);\n\tep = sctp_sk(net->sctp.ctl_sock)->ep;\n\tpkt = sctp_abort_pkt_new(net, ep, NULL, init, errhdr, len);\n\tif (!pkt)\n\t\tgoto out;\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT, SCTP_PACKET(pkt));\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET, SCTP_NULL());\nout:\n\treturn 0;\n}", "target": 0}
{"code": "static int _strlen_check(int linenumber, char *buf, size_t len)\n{\n  size_t buflen = strlen(buf);\n  if(len != buflen) {\n    printf(\"sprintf strlen:%d failed:\\nwe '%d'\\nsystem: '%d'\\n\",\n           linenumber, buflen, len);\n    return 1;\n  }\n  return 0;\n}", "target": 0}
{"code": "static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)\n{\n\tstruct snd_seq_port_info *info = arg;\n\tstruct snd_seq_client_port *port;\n\tstruct snd_seq_port_callback *callback;\n\tif (info->addr.client != client->number)\n\t\treturn -EPERM;\n\tport = snd_seq_create_port(client, (info->flags & SNDRV_SEQ_PORT_FLG_GIVEN_PORT) ? info->addr.port : -1);\n\tif (port == NULL)\n\t\treturn -ENOMEM;\n\tif (client->type == USER_CLIENT && info->kernel) {\n\t\tsnd_seq_delete_port(client, port->addr.port);\n\t\treturn -EINVAL;\n\t}\n\tif (client->type == KERNEL_CLIENT) {\n\t\tif ((callback = info->kernel) != NULL) {\n\t\t\tif (callback->owner)\n\t\t\t\tport->owner = callback->owner;\n\t\t\tport->private_data = callback->private_data;\n\t\t\tport->private_free = callback->private_free;\n\t\t\tport->event_input = callback->event_input;\n\t\t\tport->c_src.open = callback->subscribe;\n\t\t\tport->c_src.close = callback->unsubscribe;\n\t\t\tport->c_dest.open = callback->use;\n\t\t\tport->c_dest.close = callback->unuse;\n\t\t}\n\t}\n\tinfo->addr = port->addr;\n\tsnd_seq_set_port_info(port, info);\n\tsnd_seq_system_client_ev_port_start(port->addr.client, port->addr.port);\n\treturn 0;\n}", "target": 1}
{"code": "static int op_get_data(OggOpusFile *_of,int _nbytes){\n  unsigned char *buffer;\n  int            nbytes;\n  OP_ASSERT(_nbytes>0);\n  buffer=(unsigned char *)ogg_sync_buffer(&_of->oy,_nbytes);\n  if(OP_UNLIKELY(buffer==NULL))return OP_EFAULT;\n  nbytes=(int)(*_of->callbacks.read)(_of->stream,buffer,_nbytes);\n  OP_ASSERT(nbytes<=_nbytes);\n  if(OP_LIKELY(nbytes>0))ogg_sync_wrote(&_of->oy,nbytes);\n  return nbytes;\n}", "target": 0}
{"code": "void SecurityManager::on_validation_failed(\n        const ParticipantProxyData& participant_data,\n        const SecurityException& exception) const\n{\n    if (participant_->security_attributes().allow_unauthenticated_participants)\n    {\n        participant_->pdp()->notifyAboveRemoteEndpoints(participant_data, false);\n    }\n    if (strlen(exception.what()) > 0)\n    {\n        EPROSIMA_LOG_ERROR(SECURITY_AUTHENTICATION, exception.what());\n    }\n    EPROSIMA_LOG_INFO(SECURITY, \"Authentication failed for participant \" <<\n            participant_data.m_guid);\n    if (participant_->getListener() != nullptr)\n    {\n        ParticipantAuthenticationInfo info;\n        info.status = ParticipantAuthenticationInfo::UNAUTHORIZED_PARTICIPANT;\n        info.guid = participant_data.m_guid;\n        participant_->getListener()->onParticipantAuthentication(\n            participant_->getUserRTPSParticipant(), std::move(info));\n    }\n}", "target": 0}
{"code": "static int ssl_parse_server_psk_hint( mbedtls_ssl_context *ssl,\n                                      unsigned char **p,\n                                      unsigned char *end )\n{\n    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;\n    size_t  len;\n    ((void) ssl);\n    if( (*p) > end - 2 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message \"\n                                    \"(psk_identity_hint length)\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n    len = (*p)[0] << 8 | (*p)[1];\n    *p += 2;\n    if( (*p) + len > end )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message \"\n                                    \"(psk_identity_hint length)\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n    *p += len;\n    ret = 0;\n    return( ret );\n}", "target": 0}
{"code": "fu_plugin_config_func(void)\n{\n\tGStatBuf statbuf = {0};\n\tgboolean ret;\n\tgint rc;\n\tg_autofree gchar *conf_dir = NULL;\n\tg_autofree gchar *conf_file = NULL;\n\tg_autofree gchar *fn = NULL;\n\tg_autofree gchar *testdatadir = NULL;\n\tg_autofree gchar *value = NULL;\n\tg_autoptr(FuPlugin) plugin = fu_plugin_new(NULL);\n\tg_autoptr(GError) error = NULL;\n\ttestdatadir = g_test_build_filename(G_TEST_BUILT, \"tests\", NULL);\n\t(void)g_setenv(\"FWUPD_SYSCONFDIR\", testdatadir, TRUE);\n\tconf_dir = fu_path_from_kind(FU_PATH_KIND_SYSCONFDIR_PKG);\n\tfu_plugin_set_name(plugin, \"test\");\n\tconf_file = g_strdup_printf(\"%s.conf\", fu_plugin_get_name(plugin));\n\tfn = g_build_filename(conf_dir, conf_file, NULL);\n\tret = fu_path_mkdir_parent(fn, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_remove(fn);\n\tret = g_file_set_contents(fn, \"\", -1, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tret = fu_plugin_set_config_value(plugin, \"Key\", \"True\", &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_true(g_file_test(fn, G_FILE_TEST_EXISTS));\n\trc = g_stat(fn, &statbuf);\n\tg_assert_cmpint(rc, ==, 0);\n\tg_assert_cmpint(statbuf.st_mode & 0777, ==, 0644);\n\tvalue = fu_plugin_get_config_value(plugin, \"Key\");\n\tg_assert_cmpstr(value, ==, \"True\");\n\tg_assert_true(fu_plugin_get_config_value_boolean(plugin, \"Key\"));\n\tret = fu_plugin_set_secure_config_value(plugin, \"Key\", \"False\", &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\trc = g_stat(fn, &statbuf);\n\tg_assert_cmpint(rc, ==, 0);\n\tg_assert_cmpint(statbuf.st_mode & 0777, ==, 0640);\n}", "target": 0}
{"code": "nfs4_state_set_mode_locked(struct nfs4_state *state, mode_t mode)\n{\n\tif (state->state == mode)\n\t\treturn;\n\tif ((mode & FMODE_WRITE) != (state->state & FMODE_WRITE)) {\n\t\tif (mode & FMODE_WRITE)\n\t\t\tlist_move(&state->open_states, &state->owner->so_states);\n\t\telse\n\t\t\tlist_move_tail(&state->open_states, &state->owner->so_states);\n\t}\n\tstate->state = mode;\n}", "target": 1}
{"code": "  void TearDown() override {\n    peparse::DestructParsedPE(pe);\n  }", "target": 0}
{"code": "static Jsi_RC DebugInfoCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (!interp->breakpointHash) {\n        Jsi_ValueMakeArrayObject(interp, ret, NULL);\n        return JSI_OK;\n    }\n    int argc = Jsi_ValueGetLength(interp, args);\n    if (argc == 0)\n        return Jsi_HashKeysDump(interp, interp->breakpointHash, ret, 0);\n    Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 0);\n    int num;\n    char nbuf[100];\n    if (Jsi_GetIntFromValue(interp, val, &num) != JSI_OK) \n        return Jsi_LogError(\"bad number\");\n    snprintf(nbuf, sizeof(nbuf), \"%d\", num);\n    Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->breakpointHash, nbuf);\n    if (!hPtr) \n        return Jsi_LogError(\"unknown breakpoint\");\n    jsi_BreakPoint* bp = (jsi_BreakPoint*)Jsi_HashValueGet(hPtr);\n    if (!bp) return JSI_ERROR;\n    Jsi_DString dStr = {};\n    if (bp->func)\n        Jsi_DSPrintf(&dStr, \"{id:%d, type:\\\"func\\\", func:\\\"%s\\\", hits:%d, enabled:%s, temporary:%s}\",\n         bp->id, bp->func, bp->hits, bp->enabled?\"true\":\"false\", bp->temp?\"true\":\"false\");\n    else\n        Jsi_DSPrintf(&dStr, \"{id:%d, type:\\\"line\\\", file:\\\"%s\\\", line:%d, hits:%d, enabled:%s}\",\n            bp->id, bp->file?bp->file:\"\", bp->line, bp->hits, bp->enabled?\"true\":\"false\");\n    Jsi_RC rc = Jsi_JSONParse(interp, Jsi_DSValue(&dStr), ret, 0);\n    Jsi_DSFree(&dStr);\n    return rc;\n}", "target": 1}
{"code": "jsi_wsGetHeaders(jsi_wsPss *pss, struct lws *wsi, Jsi_DString* dStr, int lens[], int hmax)\n{\n    int n = 0, i = 0, nlen;\n    char buf[1000];\n    const char *cp;\n    while ((cp = (char*)lws_token_to_string((enum lws_token_indexes)n))) {\n        int len = lws_hdr_copy(wsi, buf, sizeof(buf), ( enum lws_token_indexes)n);\n        n++;\n        if (i>=(n*2+2)) break;\n        if (len<=0) continue;\n        buf[sizeof(buf)-1] = 0;\n        if (!buf[0]) continue;\n        nlen = Jsi_Strlen(cp);\n        if (nlen>0 && cp[nlen-1]==' ') nlen--;\n        if (nlen>0 && cp[nlen-1]==':') nlen--;\n        Jsi_DSAppendLen(dStr, cp, nlen);\n        Jsi_DSAppend(dStr, \"=\", buf, \"\\n\", NULL);\n        if (lens) {\n            lens[i++] = nlen;\n            lens[i++] = Jsi_Strlen(buf);\n        }\n    }\n    return i;\n}", "target": 1}
{"code": "static int gup_huge_pud(pud_t orig, pud_t *pudp, unsigned long addr,\n\t\tunsigned long end, int write, struct page **pages, int *nr)\n{\n\tstruct page *head, *page;\n\tint refs;\n\tif (!pud_access_permitted(orig, write))\n\t\treturn 0;\n\tif (pud_devmap(orig))\n\t\treturn __gup_device_huge_pud(orig, pudp, addr, end, pages, nr);\n\trefs = 0;\n\tpage = pud_page(orig) + ((addr & ~PUD_MASK) >> PAGE_SHIFT);\n\tdo {\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\t\tpage++;\n\t\trefs++;\n\t} while (addr += PAGE_SIZE, addr != end);\n\thead = compound_head(pud_page(orig));\n\tif (!page_cache_add_speculative(head, refs)) {\n\t\t*nr -= refs;\n\t\treturn 0;\n\t}\n\tif (unlikely(pud_val(orig) != pud_val(*pudp))) {\n\t\t*nr -= refs;\n\t\twhile (refs--)\n\t\t\tput_page(head);\n\t\treturn 0;\n\t}\n\tSetPageReferenced(head);\n\treturn 1;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& image = context->input(0);\n    OP_REQUIRES(context, image.dims() == 3,\n                errors::InvalidArgument(\"image must be 3-dimensional\",\n                                        image.shape().DebugString()));\n    OP_REQUIRES(context, image.NumElements() > 0,\n                errors::Internal(\"Invalid image provided.\"));\n    OP_REQUIRES(\n        context,\n        FastBoundsCheck(image.NumElements(), std::numeric_limits<int32>::max()),\n        errors::InvalidArgument(\"image cannot have >= int32 max elements\"));\n    const int32 height = static_cast<int32>(image.dim_size(0));\n    const int32 width = static_cast<int32>(image.dim_size(1));\n    const int32 channels = static_cast<int32>(image.dim_size(2));\n    const int32 max_row_width = std::numeric_limits<int32>::max() / 2;\n    OP_REQUIRES(context, FastBoundsCheck(width * channels, max_row_width),\n                errors::InvalidArgument(\"image too wide to encode\"));\n    OP_REQUIRES(context, channels >= 1 && channels <= 4,\n                errors::InvalidArgument(\n                    \"image must have 1, 2, 3, or 4 channels, got \", channels));\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, TensorShape({}), &output));\n    if (desired_channel_bits_ == 8) {\n      OP_REQUIRES(context,\n                  png::WriteImageToBuffer(\n                      image.flat<uint8>().data(), width, height,\n                      width * channels, channels, desired_channel_bits_,\n                      compression_, &output->scalar<tstring>()(), nullptr),\n                  errors::Internal(\"PNG encoding failed\"));\n    } else {\n      OP_REQUIRES(context,\n                  png::WriteImageToBuffer(\n                      image.flat<uint16>().data(), width, height,\n                      width * channels * 2, channels, desired_channel_bits_,\n                      compression_, &output->scalar<tstring>()(), nullptr),\n                  errors::Internal(\"PNG encoding failed\"));\n    }\n  }", "target": 0}
{"code": "cib_connect(gboolean full)\n{\n    int rc = pcmk_ok;\n    static gboolean need_pass = TRUE;\n    CRM_CHECK(cib != NULL, return -EINVAL);\n    if (getenv(\"CIB_passwd\") != NULL) {\n        need_pass = FALSE;\n    }\n    if(watch_fencing && st == NULL) {\n        st = stonith_api_new();\n    }\n    if(watch_fencing && st->state == stonith_disconnected) {\n        crm_trace(\"Connecting to stonith\");\n        rc = st->cmds->connect(st, crm_system_name, NULL);\n        if(rc == pcmk_ok) {\n            crm_trace(\"Setting up stonith callbacks\");\n            st->cmds->register_notification(st, T_STONITH_NOTIFY_FENCE, mon_st_callback);\n        }\n    }\n    if (cib->state != cib_connected_query && cib->state != cib_connected_command) {\n        crm_trace(\"Connecting to the CIB\");\n        if (as_console && need_pass && cib->variant == cib_remote) {\n            need_pass = FALSE;\n            print_as(\"Password:\");\n        }\n        rc = cib->cmds->signon(cib, crm_system_name, cib_query);\n        if (rc != pcmk_ok) {\n            return rc;\n        }\n        current_cib = get_cib_copy(cib);\n        mon_refresh_display(NULL);\n        if (full) {\n            if (rc == pcmk_ok) {\n                rc = cib->cmds->set_connection_dnotify(cib, mon_cib_connection_destroy);\n                if (rc == -EPROTONOSUPPORT) {\n                    print_as(\"Notification setup failed, won't be able to reconnect after failure\");\n                    if (as_console) {\n                        sleep(2);\n                    }\n                    rc = pcmk_ok;\n                }\n            }\n            if (rc == pcmk_ok) {\n                cib->cmds->del_notify_callback(cib, T_CIB_DIFF_NOTIFY, crm_diff_update);\n                rc = cib->cmds->add_notify_callback(cib, T_CIB_DIFF_NOTIFY, crm_diff_update);\n            }\n            if (rc != pcmk_ok) {\n                print_as(\"Notification setup failed, could not monitor CIB actions\");\n                if (as_console) {\n                    sleep(2);\n                }\n                clean_up(-rc);\n            }\n        }\n    }\n    return rc;\n}", "target": 1}
{"code": "\t\tvoid Phase2() final {\n\t\t\tLocal<Context> context_handle = Deref(context);\n\t\t\tContext::Scope context_scope{context_handle};\n\t\t\tLocal<Value> key_inner = key->CopyInto();\n\t\t\tLocal<Object> object = Local<Object>::Cast(Deref(reference));\n\t\t\tbool allow = [&]() {\n\t\t\t\tif (!inherit) {\n\t\t\t\t\tif (key_inner->IsName()) {\n\t\t\t\t\t\treturn Unmaybe(object->HasRealNamedProperty(context_handle, key_inner.As<Name>()));\n\t\t\t\t\t} else if (key_inner->IsNumber()) {\n\t\t\t\t\t\treturn Unmaybe(object->HasRealIndexedProperty(context_handle, HandleCast<uint32_t>(key_inner)));\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}();\n\t\t\tLocal<Value> value = allow ?\n\t\t\t\tUnmaybe(object->Get(context_handle, key_inner)) :\n\t\t\t\tUndefined(Isolate::GetCurrent()).As<Value>();\n\t\t\tret = TransferOut(value, options);\n\t\t}", "target": 1}
{"code": "header_put_le_3byte (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 3)\n\t{\tpsf->header [psf->headindex++] = x ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\t} ;\n} ", "target": 1}
{"code": "static int bad_format_imginfo(\n    char *fmt)\n{\n    char     *ptr;\n    int       n = 0;\n    ptr = fmt;\n    while (*ptr != '\\0')\n        if (*ptr++ == '%') {\n            if (*ptr == '\\0')\n                return 1;\n            if (*ptr == '%')\n                ptr++;\n            else if (*ptr == 's' || *ptr == 'S') {\n                n = 1;\n                ptr++;\n            }\n            else {\n                if (*ptr == ' ')\n                    ptr++;\n                while (*ptr >= '0' && *ptr <= '9')\n                    ptr++;\n                if (*ptr++ != 'l')\n                    return 1;\n                if (*ptr == 'u')\n                    ptr++;\n                else\n                    return 1;\n                n++;\n            }\n        }\n    return (n != 3);\n}", "target": 1}
{"code": "void ChildProcessSecurityPolicy::GrantInspectElement(int renderer_id) {\n  AutoLock lock(lock_);\n  SecurityStateMap::iterator state = security_state_.find(renderer_id);\n  if (state == security_state_.end())\n    return;\n  state->second->GrantScheme(chrome::kChromeUIScheme);\n}", "target": 0}
{"code": "static int l2cap_sock_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\tBT_DBG(\"sk %p backlog %d\", sk, backlog);\n\tlock_sock(sk);\n\tif (sk->sk_state != BT_BOUND || sock->type != SOCK_SEQPACKET) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\tswitch (l2cap_pi(sk)->mode) {\n\tcase L2CAP_MODE_BASIC:\n\t\tbreak;\n\tcase L2CAP_MODE_ERTM:\n\tcase L2CAP_MODE_STREAMING:\n\t\tif (enable_ertm)\n\t\t\tbreak;\n\tdefault:\n\t\terr = -ENOTSUPP;\n\t\tgoto done;\n\t}\n\tif (!l2cap_pi(sk)->psm) {\n\t\tbdaddr_t *src = &bt_sk(sk)->src;\n\t\tu16 psm;\n\t\terr = -EINVAL;\n\t\twrite_lock_bh(&l2cap_sk_list.lock);\n\t\tfor (psm = 0x1001; psm < 0x1100; psm += 2)\n\t\t\tif (!__l2cap_get_sock_by_addr(cpu_to_le16(psm), src)) {\n\t\t\t\tl2cap_pi(sk)->psm   = cpu_to_le16(psm);\n\t\t\t\tl2cap_pi(sk)->sport = cpu_to_le16(psm);\n\t\t\t\terr = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\twrite_unlock_bh(&l2cap_sk_list.lock);\n\t\tif (err < 0)\n\t\t\tgoto done;\n\t}\n\tsk->sk_max_ack_backlog = backlog;\n\tsk->sk_ack_backlog = 0;\n\tsk->sk_state = BT_LISTEN;\ndone:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "static int sdp_parse_fmtp_config_h264(AVFormatContext *s,\n                                      AVStream *stream,\n                                      PayloadContext *h264_data,\n                                      const char *attr, const char *value)\n{\n    AVCodecParameters *par = stream->codecpar;\n    if (!strcmp(attr, \"packetization-mode\")) {\n        av_log(s, AV_LOG_DEBUG, \"RTP Packetization Mode: %d\\n\", atoi(value));\n        h264_data->packetization_mode = atoi(value);\n        if (h264_data->packetization_mode > 1)\n            av_log(s, AV_LOG_ERROR,\n                   \"Interleaved RTP mode is not supported yet.\\n\");\n    } else if (!strcmp(attr, \"profile-level-id\")) {\n        if (strlen(value) == 6)\n            parse_profile_level_id(s, h264_data, value);\n    } else if (!strcmp(attr, \"sprop-parameter-sets\")) {\n        int ret;\n        if (value[strlen(value) - 1] == ',') {\n            av_log(s, AV_LOG_WARNING, \"Missing PPS in sprop-parameter-sets, ignoring\\n\");\n            return 0;\n        }\n        par->extradata_size = 0;\n        av_freep(&par->extradata);\n        ret = ff_h264_parse_sprop_parameter_sets(s, &par->extradata,\n                                                 &par->extradata_size, value);\n        av_log(s, AV_LOG_DEBUG, \"Extradata set to %p (size: %d)\\n\",\n               par->extradata, par->extradata_size);\n        return ret;\n    }\n    return 0;\n}", "target": 1}
{"code": "int touch_file(const char *path, bool parents, usec_t stamp, uid_t uid, gid_t gid, mode_t mode) {\n        _cleanup_close_ int fd;\n        int r;\n        assert(path);\n        if (parents)\n                mkdir_parents(path, 0755);\n        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY,\n                        (mode == 0 || mode == MODE_INVALID) ? 0644 : mode);\n        if (fd < 0)\n                return -errno;\n        if (mode != MODE_INVALID) {\n                r = fchmod(fd, mode);\n                if (r < 0)\n                        return -errno;\n        }\n        if (uid != UID_INVALID || gid != GID_INVALID) {\n                r = fchown(fd, uid, gid);\n                if (r < 0)\n                        return -errno;\n        }\n        if (stamp != USEC_INFINITY) {\n                struct timespec ts[2];\n                timespec_store(&ts[0], stamp);\n                ts[1] = ts[0];\n                r = futimens(fd, ts);\n        } else\n                r = futimens(fd, NULL);\n        if (r < 0)\n                return -errno;\n        return 0;\n}", "target": 0}
{"code": "    long XmpValue::size() const\n    {\n        std::ostringstream os;\n        write(os);\n        return static_cast<long>(os.str().size());\n    }", "target": 0}
{"code": "static int override_release(char __user *release, int len)\n{\n\tint ret = 0;\n\tchar buf[65];\n\tif (current->personality & UNAME26) {\n\t\tchar *rest = UTS_RELEASE;\n\t\tint ndots = 0;\n\t\tunsigned v;\n\t\twhile (*rest) {\n\t\t\tif (*rest == '.' && ++ndots >= 3)\n\t\t\t\tbreak;\n\t\t\tif (!isdigit(*rest) && *rest != '.')\n\t\t\t\tbreak;\n\t\t\trest++;\n\t\t}\n\t\tv = ((LINUX_VERSION_CODE >> 8) & 0xff) + 40;\n\t\tsnprintf(buf, len, \"2.6.%u%s\", v, rest);\n\t\tret = copy_to_user(release, buf, len);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "void die_upon_dubious_ownership(const char *gitfile, const char *worktree,\n\t\t\t\tconst char *gitdir)\n{\n\tstruct strbuf report = STRBUF_INIT, quoted = STRBUF_INIT;\n\tconst char *path;\n\tif (ensure_valid_ownership(gitfile, worktree, gitdir, &report))\n\t\treturn;\n\tstrbuf_complete(&report, '\\n');\n\tpath = gitfile ? gitfile : gitdir;\n\tsq_quote_buf_pretty(&quoted, path);\n\tdie(_(\"detected dubious ownership in repository at '%s'\\n\"\n\t      \"%s\"\n\t      \"To add an exception for this directory, call:\\n\"\n\t      \"\\n\"\n\t      \"\\tgit config --global --add safe.directory %s\"),\n\t    path, report.buf, quoted.buf);\n}", "target": 0}
{"code": "mrb_proc_copy(mrb_state *mrb, struct RProc *a, struct RProc *b)\n{\n  if (a->body.irep) {\n    return;\n  }\n  if (!MRB_PROC_CFUNC_P(b) && b->body.irep) {\n    mrb_irep_incref(mrb, (mrb_irep*)b->body.irep);\n  }\n  a->flags = b->flags;\n  a->body = b->body;\n  a->upper = b->upper;\n  a->e.env = b->e.env;\n}", "target": 0}
{"code": "static int crypto_ccm_auth(struct aead_request *req, struct scatterlist *plain,\n\t\t\t   unsigned int cryptlen)\n{\n\tstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tstruct crypto_ccm_ctx *ctx = crypto_aead_ctx(aead);\n\tAHASH_REQUEST_ON_STACK(ahreq, ctx->mac);\n\tunsigned int assoclen = req->assoclen;\n\tstruct scatterlist sg[3];\n\tu8 odata[16];\n\tu8 idata[16];\n\tint ilen, err;\n\terr = format_input(odata, req, cryptlen);\n\tif (err)\n\t\tgoto out;\n\tsg_init_table(sg, 3);\n\tsg_set_buf(&sg[0], odata, 16);\n\tif (assoclen) {\n\t\tilen = format_adata(idata, assoclen);\n\t\tsg_set_buf(&sg[1], idata, ilen);\n\t\tsg_chain(sg, 3, req->src);\n\t} else {\n\t\tilen = 0;\n\t\tsg_chain(sg, 2, req->src);\n\t}\n\tahash_request_set_tfm(ahreq, ctx->mac);\n\tahash_request_set_callback(ahreq, pctx->flags, NULL, NULL);\n\tahash_request_set_crypt(ahreq, sg, NULL, assoclen + ilen + 16);\n\terr = crypto_ahash_init(ahreq);\n\tif (err)\n\t\tgoto out;\n\terr = crypto_ahash_update(ahreq);\n\tif (err)\n\t\tgoto out;\n\tilen = 16 - (assoclen + ilen) % 16;\n\tif (ilen < 16) {\n\t\tmemset(idata, 0, ilen);\n\t\tsg_init_table(sg, 2);\n\t\tsg_set_buf(&sg[0], idata, ilen);\n\t\tif (plain)\n\t\t\tsg_chain(sg, 2, plain);\n\t\tplain = sg;\n\t\tcryptlen += ilen;\n\t}\n\tahash_request_set_crypt(ahreq, plain, pctx->odata, cryptlen);\n\terr = crypto_ahash_finup(ahreq);\nout:\n\treturn err;\n}", "target": 1}
{"code": "Status CompressElement(const std::vector<Tensor>& element,\n                       CompressedElement* out) {\n  std::vector<TensorProto> non_memcpy_components;\n  int64 total_size = 0;\n  for (auto& component : element) {\n    if (DataTypeCanUseMemcpy(component.dtype())) {\n      total_size += DMAHelper::buffer(&component)->size();\n    } else {\n      non_memcpy_components.emplace_back();\n      component.AsProtoTensorContent(&non_memcpy_components.back());\n      total_size += non_memcpy_components.back().ByteSizeLong();\n    }\n  }\n  tstring uncompressed;\n  uncompressed.resize_uninitialized(total_size);\n  char* position = uncompressed.mdata();\n  int non_memcpy_component_index = 0;\n  for (auto& component : element) {\n    CompressedComponentMetadata* metadata =\n        out->mutable_component_metadata()->Add();\n    metadata->set_dtype(component.dtype());\n    component.shape().AsProto(metadata->mutable_tensor_shape());\n    if (DataTypeCanUseMemcpy(component.dtype())) {\n      const TensorBuffer* buffer = DMAHelper::buffer(&component);\n      memcpy(position, buffer->data(), buffer->size());\n      metadata->set_tensor_size_bytes(buffer->size());\n    } else {\n      TensorProto& proto = non_memcpy_components[non_memcpy_component_index++];\n      proto.SerializeToArray(position, proto.ByteSizeLong());\n      metadata->set_tensor_size_bytes(proto.ByteSizeLong());\n    }\n    position += metadata->tensor_size_bytes();\n  }\n  DCHECK_EQ(position, uncompressed.mdata() + total_size);\n  if (!port::Snappy_Compress(uncompressed.mdata(), total_size,\n                             out->mutable_data())) {\n    return errors::Internal(\"Failed to compress using snappy.\");\n  }\n  VLOG(3) << \"Compressed element from \" << total_size << \" bytes to \"\n          << out->data().size() << \" bytes\";\n  return Status::OK();\n}", "target": 1}
{"code": "void InterstitialPage::Focus() {\n  render_view_host_->view()->Focus();\n}", "target": 0}
{"code": "static void __net_random_once_deferred(struct work_struct *w)\n{\n\tstruct __net_random_once_work *work =\n\t\tcontainer_of(w, struct __net_random_once_work, work);\n\tif (!static_key_enabled(work->key))\n\t\tstatic_key_slow_inc(work->key);\n\tkfree(work);\n}", "target": 1}
{"code": "find_link_ref(struct link_ref **references, uint8_t *name, size_t length)\n{\n\tunsigned int hash = hash_link_ref(name, length);\n\tstruct link_ref *ref = NULL;\n\tref = references[hash % REF_TABLE_SIZE];\n\twhile (ref != NULL) {\n\t\tif (ref->id == hash)\n\t\t\treturn ref;\n\t\tref = ref->next;\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "static void bt_for_each(struct blk_mq_hw_ctx *hctx,\n\t\tstruct blk_mq_bitmap_tags *bt, unsigned int off,\n\t\tbusy_iter_fn *fn, void *data, bool reserved)\n{\n\tstruct request *rq;\n\tint bit, i;\n\tfor (i = 0; i < bt->map_nr; i++) {\n\t\tstruct blk_align_bitmap *bm = &bt->map[i];\n\t\tfor (bit = find_first_bit(&bm->word, bm->depth);\n\t\t     bit < bm->depth;\n\t\t     bit = find_next_bit(&bm->word, bm->depth, bit + 1)) {\n\t\t     \trq = blk_mq_tag_to_rq(hctx->tags, off + bit);\n\t\t\tif (rq->q == hctx->queue)\n\t\t\t\tfn(hctx, rq, data, reserved);\n\t\t}\n\t\toff += (1 << bt->bits_per_word);\n\t}\n}", "target": 1}
{"code": "init_pyfribidi (void)\n{\n        PyObject *module = Py_InitModule (\"_pyfribidi\", PyfribidiMethods);\n\tPyModule_AddIntConstant (module, \"RTL\", (long) FRIBIDI_TYPE_RTL);\n\tPyModule_AddIntConstant (module, \"LTR\", (long) FRIBIDI_TYPE_LTR);\n\tPyModule_AddIntConstant (module, \"ON\", (long) FRIBIDI_TYPE_ON);\n}", "target": 0}
{"code": "normalizeLines(XML_Char *s)\n{\n  XML_Char *p;\n  for (;; s++) {\n    if (*s == XML_T('\\0'))\n      return;\n    if (*s == 0xD)\n      break;\n  }\n  p = s;\n  do {\n    if (*s == 0xD) {\n      *p++ = 0xA;\n      if (*++s == 0xA)\n        s++;\n    }\n    else\n      *p++ = *s++;\n  } while (*s);\n  *p = XML_T('\\0');\n}", "target": 0}
{"code": "lyd_new_yangdata(const struct lys_module *module, const char *name_template, const char *name)\n{\n    const struct lys_node *schema = NULL, *snode;\n    if (!module || !name_template || !name) {\n        LOGARG;\n        return NULL;\n    }\n    schema = lyp_get_yang_data_template(module, name_template, strlen(name_template));\n    if (!schema) {\n        LOGERR(module->ctx, LY_EINVAL, \"Failed to find yang-data template \\\"%s\\\".\", name_template);\n        return NULL;\n    }\n    if (lys_getnext_data(module, schema, name, strlen(name), LYS_CONTAINER, &snode) || !snode) {\n        LOGERR(module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a container child of \\\"%s:%s\\\".\",\n               name, module->name, schema->name);\n        return NULL;\n    }\n    return _lyd_new(NULL, snode, 0);\n}", "target": 1}
{"code": "XML_SetCommentHandler(XML_Parser parser, XML_CommentHandler handler) {\n  if (parser != NULL)\n    parser->m_commentHandler = handler;\n}", "target": 0}
{"code": "GF_Box *vwid_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ViewIdentifierBox, GF_ISOM_BOX_TYPE_VWID);\n\treturn (GF_Box *)tmp;\n}", "target": 0}
{"code": "static void blk_mq_freeze_queue_wait(struct request_queue *q)\n{\n\twait_event(q->mq_freeze_wq, percpu_ref_is_zero(&q->mq_usage_counter));\n}", "target": 0}
{"code": "static void php_imagepolygon(INTERNAL_FUNCTION_PARAMETERS, int filled)\n{\n\tzval *IM, *POINTS;\n\tlong NPOINTS, COL;\n\tzval **var = NULL;\n\tgdImagePtr im;\n\tgdPointPtr points;\n\tint npoints, col, nelem, i;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rall\", &IM, &POINTS, &NPOINTS, &COL) == FAILURE) {\n\t\treturn;\n\t}\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\tnpoints = NPOINTS;\n\tcol = COL;\n\tnelem = zend_hash_num_elements(Z_ARRVAL_P(POINTS));\n\tif (nelem < 6) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"You must have at least 3 points in your array\");\n\t\tRETURN_FALSE;\n\t}\n\tif (npoints <= 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"You must give a positive number of points\");\n\t\tRETURN_FALSE;\n\t}\n\tif (nelem < npoints * 2) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Trying to use %d points in array with only %d points\", npoints, nelem/2);\n\t\tRETURN_FALSE;\n\t}\n\tpoints = (gdPointPtr) safe_emalloc(npoints, sizeof(gdPoint), 0);\n\tfor (i = 0; i < npoints; i++) {\n\t\tif (zend_hash_index_find(Z_ARRVAL_P(POINTS), (i * 2), (void **) &var) == SUCCESS) {\n\t\t\tSEPARATE_ZVAL((var));\n\t\t\tconvert_to_long(*var);\n\t\t\tpoints[i].x = Z_LVAL_PP(var);\n\t\t}\n\t\tif (zend_hash_index_find(Z_ARRVAL_P(POINTS), (i * 2) + 1, (void **) &var) == SUCCESS) {\n\t\t\tSEPARATE_ZVAL(var);\n\t\t\tconvert_to_long(*var);\n\t\t\tpoints[i].y = Z_LVAL_PP(var);\n\t\t}\n\t}\n\tif (filled) {\n\t\tgdImageFilledPolygon(im, points, npoints, col);\n\t} else {\n\t\tgdImagePolygon(im, points, npoints, col);\n\t}\n\tefree(points);\n\tRETURN_TRUE;\n}", "target": 1}
{"code": "ldbm_txn_ruv_modify_context( Slapi_PBlock *pb, modify_context *mc )\n{\n    char *uniqueid = NULL;\n    backend *be;\n    Slapi_Mods *smods = NULL;\n    struct backentry *bentry;\n    entry_address bentry_addr;\n    IFP fn = NULL;\n    int rc = 0;\n    back_txn txn = {NULL};\n    slapi_pblock_get(pb, SLAPI_TXN_RUV_MODS_FN, (void *)&fn);\n    slapi_pblock_get(pb, SLAPI_TXN, &txn.back_txn_txn);\n    if (NULL == fn) {\n        return (0);\n    }\n    rc = (*fn)(pb, &uniqueid, &smods);\n    if (1 != rc || NULL == smods || NULL == uniqueid) {\n        return (rc);\n    }\n    slapi_pblock_get( pb, SLAPI_BACKEND, &be);\n    bentry_addr.sdn = NULL;\n    bentry_addr.udn = NULL;\n    bentry_addr.uniqueid = uniqueid;\n    bentry = find_entry2modify_only( pb, be, &bentry_addr, &txn );\n    if (NULL == bentry) {\n        LDAPDebug( LDAP_DEBUG_ANY, \"Error: ldbm_txn_ruv_modify_context failed to retrieve and lock RUV entry\\n\",\n            0, 0, 0 );\n        rc = -1;\n        goto done;\n    }\n    modify_init( mc, bentry );\n    if (modify_apply_mods_ignore_error( mc, smods, LDAP_TYPE_OR_VALUE_EXISTS )) {\n        LDAPDebug( LDAP_DEBUG_ANY, \"Error: ldbm_txn_ruv_modify_context failed to apply updates to RUV entry\\n\",\n            0, 0, 0 );\n        rc = -1;\n        modify_term( mc, be );\n    }\ndone:\n    slapi_ch_free_string( &uniqueid );\n    return (rc);\n}", "target": 1}
{"code": "int fz_colorspace_is_gray(fz_context *ctx, const fz_colorspace *cs)\n{\n\treturn cs && cs->type == FZ_COLORSPACE_GRAY;\n}", "target": 0}
{"code": "static inline int route4_hash_to(u32 id)\n{\n\treturn id & 0xFF;\n}", "target": 0}
{"code": "static u8 adpt_read_blink_led(adpt_hba* host)\n{\n\tif (host->FwDebugBLEDflag_P) {\n\t\tif( readb(host->FwDebugBLEDflag_P) == 0xbc ){\n\t\t\treturn readb(host->FwDebugBLEDvalue_P);\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int tipc_nl_compat_link_dump(struct tipc_nl_compat_msg *msg,\n\t\t\t\t    struct nlattr **attrs)\n{\n\tstruct nlattr *link[TIPC_NLA_LINK_MAX + 1];\n\tstruct tipc_link_info link_info;\n\tint err;\n\tif (!attrs[TIPC_NLA_LINK])\n\t\treturn -EINVAL;\n\terr = nla_parse_nested(link, TIPC_NLA_LINK_MAX, attrs[TIPC_NLA_LINK],\n\t\t\t       NULL);\n\tif (err)\n\t\treturn err;\n\tlink_info.dest = nla_get_flag(link[TIPC_NLA_LINK_DEST]);\n\tlink_info.up = htonl(nla_get_flag(link[TIPC_NLA_LINK_UP]));\n\tstrcpy(link_info.str, nla_data(link[TIPC_NLA_LINK_NAME]));\n\treturn tipc_add_tlv(msg->rep, TIPC_TLV_LINK_INFO,\n\t\t\t    &link_info, sizeof(link_info));\n}", "target": 1}
{"code": "static int fastrpc_dma_buf_attach(struct dma_buf *dmabuf,\n\t\t\t\t  struct dma_buf_attachment *attachment)\n{\n\tstruct fastrpc_dma_buf_attachment *a;\n\tstruct fastrpc_buf *buffer = dmabuf->priv;\n\tint ret;\n\ta = kzalloc(sizeof(*a), GFP_KERNEL);\n\tif (!a)\n\t\treturn -ENOMEM;\n\tret = dma_get_sgtable(buffer->dev, &a->sgt, buffer->virt,\n\t\t\t      FASTRPC_PHYS(buffer->phys), buffer->size);\n\tif (ret < 0) {\n\t\tdev_err(buffer->dev, \"failed to get scatterlist from DMA API\\n\");\n\t\tkfree(a);\n\t\treturn -EINVAL;\n\t}\n\ta->dev = attachment->dev;\n\tINIT_LIST_HEAD(&a->node);\n\tattachment->priv = a;\n\tmutex_lock(&buffer->lock);\n\tlist_add(&a->node, &buffer->attachments);\n\tmutex_unlock(&buffer->lock);\n\treturn 0;\n}", "target": 0}
{"code": "u32 smm_get_cpu_smbase(unsigned int cpu_num)\n{\n\tif (cpu_num < CONFIG_MAX_CPUS) {\n\t\tif (cpus[cpu_num].active)\n\t\t\treturn cpus[cpu_num].smbase;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "    void WebPImage::writeMetadata()\n    {\n        if (io_->open() != 0) {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        BasicIo::UniquePtr tempIo(new MemIo);\n        assert (tempIo.get() != 0);\n        doWriteMetadata(*tempIo); \n        io_->close();\n        io_->transfer(*tempIo); \n    } ", "target": 0}
{"code": "jp2_box_t *jp2_box_create0()\n{\n\tjp2_box_t *box;\n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n\t\treturn 0;\n\t}\n\tmemset(box, 0, sizeof(jp2_box_t));\n\tbox->type = 0;\n\tbox->len = 0;\n\tbox->ops = &jp2_boxinfo_unk.ops;\n\treturn box;\n}", "target": 0}
{"code": "  Status FillCollectiveParams(CollectiveParams* col_params,\n                              CollectiveType collective_type,\n                              const Tensor& group_size, const Tensor& group_key,\n                              const Tensor& instance_key) {\n    if (group_size.dims() > 0) {\n      return errors::Internal(\"Unexpected dimensions on input group_size, got \",\n                              group_size.shape().DebugString());\n    }\n    if (group_key.dims() > 0) {\n      return errors::Internal(\"Unexpected dimensions on input group_key, got \",\n                              group_key.shape().DebugString());\n    }\n    if (instance_key.dims() > 0) {\n      return errors::Internal(\n          \"Unexpected dimensions on input instance_key, got \",\n          instance_key.shape().DebugString());\n    }\n    col_params->name = name_;\n    col_params->group.device_type = device_type_;\n    col_params->group.group_size = group_size.unaligned_flat<int32>()(0);\n    if (col_params->group.group_size <= 0) {\n      return errors::InvalidArgument(\n          \"group_size must be positive integer but got \",\n          col_params->group.group_size);\n    }\n    col_params->group.group_key = group_key.unaligned_flat<int32>()(0);\n    col_params->instance.type = collective_type;\n    col_params->instance.instance_key = instance_key.unaligned_flat<int32>()(0);\n    col_params->instance.data_type = data_type_;\n    col_params->instance.impl_details.communication_hint = communication_hint_;\n    col_params->instance.impl_details.timeout_seconds = timeout_seconds_;\n    return Status::OK();\n  }", "target": 1}
{"code": "int pdf_is_pdf(FILE *fp)\n{\n    int   is_pdf;\n    char *header;\n    header = get_header(fp);\n    if (header && strstr(header, \"%PDF-\"))\n      is_pdf = 1;\n    else \n      is_pdf = 0;\n    free(header);\n    return is_pdf;\n}", "target": 1}
{"code": "static int hci_uart_set_proto(struct hci_uart *hu, int id)\n{\n\tconst struct hci_uart_proto *p;\n\tint err;\n\tp = hci_uart_get_proto(id);\n\tif (!p)\n\t\treturn -EPROTONOSUPPORT;\n\thu->proto = p;\n\tset_bit(HCI_UART_PROTO_READY, &hu->flags);\n\terr = hci_uart_register_dev(hu);\n\tif (err) {\n\t\tclear_bit(HCI_UART_PROTO_READY, &hu->flags);\n\t\treturn err;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "archive_write_disk_set_acls(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode)\n{\n\tint\t\tret = ARCHIVE_OK;\n\t(void)mode;\t\n\tif ((archive_acl_types(abstract_acl)\n\t    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {\n\t\tif ((archive_acl_types(abstract_acl)\n\t\t    & ARCHIVE_ENTRY_ACL_TYPE_ACCESS) != 0) {\n\t\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_ACCESS, \"access\");\n\t\t\tif (ret != ARCHIVE_OK)\n\t\t\t\treturn (ret);\n\t\t}\n\t\tif ((archive_acl_types(abstract_acl)\n\t\t    & ARCHIVE_ENTRY_ACL_TYPE_DEFAULT) != 0)\n\t\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT, \"default\");\n\t\treturn (ret);\n\t}\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\telse if ((archive_acl_types(abstract_acl) &\n\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {\n\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4, \"nfs4\");\n\t}\n#endif\n\treturn (ret);\n}", "target": 1}
{"code": "extract_epub_from_container (const gchar* uri,\n                             EpubDocument *epub_document,\n                             GError ** error)\n{\n    GError *err = NULL;\n    epub_document->archivename = g_filename_from_uri(uri,NULL,error);\n    if ( !epub_document->archivename )\n    {\n        if (err) {\n            g_propagate_error (error, err);\n        }\n        else {\n            g_set_error_literal (error,\n                         EV_DOCUMENT_ERROR,\n                         EV_DOCUMENT_ERROR_INVALID,\n                         _(\"could not retrieve filename\"));\n        }\n        return FALSE;\n    }\n    gchar *epubfilename = g_strrstr(epub_document->archivename,\"/\");\n    if ( *epubfilename == '/' )\n        epubfilename++ ;\n    GString *temporary_sub_directory = g_string_new(epubfilename);\n    g_string_append(temporary_sub_directory,\"XXXXXX\") ;\n    epub_document->tmp_archive_dir = ev_mkdtemp(temporary_sub_directory->str, error);\n    g_string_free(temporary_sub_directory, TRUE);\n    if (!epub_document->tmp_archive_dir) {\n        return FALSE;\n    }\n    epub_document->epubDocument = unzOpen64(epub_document->archivename);\n    if ( epub_document->epubDocument == NULL )\n    {\n        if (err)    {\n            g_propagate_error (error, err);\n        }\n        else    {\n            g_set_error_literal (error,\n                         EV_DOCUMENT_ERROR,\n                         EV_DOCUMENT_ERROR_INVALID,\n                         _(\"could not open archive\"));\n        }\n        return FALSE;\n    }\n    gboolean result = FALSE;\n    if ( unzGoToFirstFile(epub_document->epubDocument) != UNZ_OK )\n    {\n        if (err) {\n            g_propagate_error (error, err);\n        }\n        else    {\n            g_set_error_literal (error,\n                         EV_DOCUMENT_ERROR,\n                         EV_DOCUMENT_ERROR_INVALID,\n                         _(\"could not extract archive\"));\n        }\n        goto out;\n    }\n    while ( TRUE )\n    {\n        if ( extract_one_file(epub_document,&err) == FALSE )\n        {\n            if (err) {\n                g_propagate_error (error, err);\n            }\n            else    {\n                g_set_error_literal (error,\n                             EV_DOCUMENT_ERROR,\n                             EV_DOCUMENT_ERROR_INVALID,\n                             _(\"could not extract archive\"));\n            }\n            goto out;\n        }\n        if ( unzGoToNextFile(epub_document->epubDocument) == UNZ_END_OF_LIST_OF_FILE ) {\n            result = TRUE;\n            break;\n        }\n    }\nout:\n    unzClose(epub_document->epubDocument);\n    return result;\n}", "target": 1}
{"code": "static GCObject **correctgraylist (GCObject **p) {\n  GCObject *curr;\n  while ((curr = *p) != NULL) {\n    switch (curr->tt) {\n      case LUA_VTABLE: case LUA_VUSERDATA: {\n        GCObject **next = getgclist(curr);\n        if (getage(curr) == G_TOUCHED1) {  \n          lua_assert(isgray(curr));\n          gray2black(curr);  \n          changeage(curr, G_TOUCHED1, G_TOUCHED2);\n          p = next;  \n        }\n        else {  \n          if (!iswhite(curr)) {  \n            lua_assert(isold(curr));\n            if (getage(curr) == G_TOUCHED2)  \n              changeage(curr, G_TOUCHED2, G_OLD);  \n            gray2black(curr);  \n          }\n          *p = *next;  \n        }\n        break;\n      }\n      case LUA_VTHREAD: {\n        lua_State *th = gco2th(curr);\n        lua_assert(!isblack(th));\n        if (iswhite(th))  \n          *p = th->gclist;  \n        else  \n          p = &th->gclist;  \n        break;\n      }\n      default: lua_assert(0);  \n    }\n  }\n  return p;\n}", "target": 1}
{"code": "ssize_t uv__idna_toascii(const char* s, const char* se, char* d, char* de) {\n  const char* si;\n  const char* st;\n  unsigned c;\n  char* ds;\n  int rc;\n  ds = d;\n  si = s;\n  while (si < se) {\n    st = si;\n    c = uv__utf8_decode1(&si, se);\n    if (c == UINT_MAX)\n      return UV_EINVAL;\n    if (c != '.')\n      if (c != 0x3002)  \n        if (c != 0xFF0E)  \n          if (c != 0xFF61)  \n            continue;\n    rc = uv__idna_toascii_label(s, st, &d, de);\n    if (rc < 0)\n      return rc;\n    if (d < de)\n      *d++ = '.';\n    s = si;\n  }\n  if (s < se) {\n    rc = uv__idna_toascii_label(s, se, &d, de);\n    if (rc < 0)\n      return rc;\n  }\n  if (d < de)\n    *d++ = '\\0';\n  return d - ds;  \n}", "target": 1}
{"code": "static inline void SetPSDPixel(Image *image,const size_t channels,\n  const ssize_t type,const size_t packet_size,const Quantum pixel,Quantum *q,\n  ExceptionInfo *exception)\n{\n  if (image->storage_class == PseudoClass)\n    {\n      if (packet_size == 1)\n        SetPixelIndex(image,ScaleQuantumToChar(pixel),q);\n      else\n        SetPixelIndex(image,ScaleQuantumToShort(pixel),q);\n      SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n        ConstrainColormapIndex(image,GetPixelIndex(image,q),exception),q);\n      return;\n    }\n  switch (type)\n  {\n    case -1:\n    {\n      SetPixelAlpha(image, pixel,q);\n      break;\n    }\n    case -2:\n    case 0:\n    {\n      SetPixelRed(image,pixel,q);\n      if (channels == 1 || type == -2)\n        SetPixelGray(image,pixel,q);\n      break;\n    }\n    case 1:\n    {\n      if (image->storage_class == PseudoClass)\n        SetPixelAlpha(image,pixel,q);\n      else\n        SetPixelGreen(image,pixel,q);\n      break;\n    }\n    case 2:\n    {\n      if (image->storage_class == PseudoClass)\n        SetPixelAlpha(image,pixel,q);\n      else\n        SetPixelBlue(image,pixel,q);\n      break;\n    }\n    case 3:\n    {\n      if (image->colorspace == CMYKColorspace)\n        SetPixelBlack(image,pixel,q);\n      else\n        if (image->alpha_trait != UndefinedPixelTrait)\n          SetPixelAlpha(image,pixel,q);\n      break;\n    }\n    case 4:\n    {\n      if ((IssRGBCompatibleColorspace(image->colorspace) != MagickFalse) &&\n          (channels > 3))\n        break;\n      if (image->alpha_trait != UndefinedPixelTrait)\n        SetPixelAlpha(image,pixel,q);\n      break;\n    }\n  }\n}", "target": 0}
{"code": "static void add_send_options(GDHCPClient *dhcp_client,\n\t\t\t\tstruct dhcp_packet *packet)\n{\n\tg_hash_table_foreach(dhcp_client->send_value_hash,\n\t\t\t\tadd_binary_option, packet);\n}", "target": 0}
{"code": "*/\nPHP_METHOD(DateTimeImmutable, __set_state)\n{\n\tphp_date_obj     *dateobj;\n\tzval             *array;\n\tHashTable        *myht;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"a\", &array) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tmyht = HASH_OF(array);\n\tphp_date_instantiate(date_ce_immutable, return_value TSRMLS_CC);\n\tdateobj = (php_date_obj *) zend_object_store_get_object(return_value TSRMLS_CC);\n\tif (!php_date_initialize_from_hash(&dateobj, myht TSRMLS_CC)) {\n\t\tphp_error(E_ERROR, \"Invalid serialization data for DateTimeImmutable object\");\n\t}", "target": 0}
{"code": "static int logi_dj_ll_raw_request(struct hid_device *hid,\n\t\t\t\t  unsigned char reportnum, __u8 *buf,\n\t\t\t\t  size_t count, unsigned char report_type,\n\t\t\t\t  int reqtype)\n{\n\tstruct dj_device *djdev = hid->driver_data;\n\tstruct dj_receiver_dev *djrcv_dev = djdev->dj_receiver_dev;\n\tu8 *out_buf;\n\tint ret;\n\tif (buf[0] != REPORT_TYPE_LEDS)\n\t\treturn -EINVAL;\n\tout_buf = kzalloc(DJREPORT_SHORT_LENGTH, GFP_ATOMIC);\n\tif (!out_buf)\n\t\treturn -ENOMEM;\n\tif (count < DJREPORT_SHORT_LENGTH - 2)\n\t\tcount = DJREPORT_SHORT_LENGTH - 2;\n\tout_buf[0] = REPORT_ID_DJ_SHORT;\n\tout_buf[1] = djdev->device_index;\n\tmemcpy(out_buf + 2, buf, count);\n\tret = hid_hw_raw_request(djrcv_dev->hdev, out_buf[0], out_buf,\n\t\tDJREPORT_SHORT_LENGTH, report_type, reqtype);\n\tkfree(out_buf);\n\treturn ret;\n}", "target": 1}
{"code": "PJ_DEF(void) pj_scan_get_n( pj_scanner *scanner,\n\t\t\t    unsigned N, pj_str_t *out)\n{\n    if (scanner->curptr + N > scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n    pj_strset(out, scanner->curptr, N);\n    scanner->curptr += N;\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*scanner->curptr) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);\n    }\n}", "target": 1}
{"code": "bool Decode(string_view encoded, std::string* raw) {\n  for (auto iter = encoded.begin(); iter != encoded.end(); ++iter) {\n    if (*iter == '%') {\n      if (++iter == encoded.end()) {\n        return false;\n      }\n      int h_decimal = 0;\n      if (!HexToDecimal(*iter, &h_decimal)) {\n        return false;\n      }\n      if (++iter == encoded.end()) {\n        return false;\n      }\n      int l_decimal = 0;\n      if (!HexToDecimal(*iter, &l_decimal)) {\n        return false;\n      }\n      raw->push_back(static_cast<char>((h_decimal << 4) + l_decimal));\n    } else if (*iter > 127 || *iter < 0) {\n      return false;\n    } else {\n      raw->push_back(*iter);\n    }\n  }\n  return true;\n}", "target": 1}
{"code": "relay_websocket_decode_frame (const unsigned char *buffer,\n                              unsigned long long buffer_length,\n                              unsigned char *decoded,\n                              unsigned long long *decoded_length)\n{\n    unsigned long long i, index_buffer, length_frame_size, length_frame;\n    unsigned char opcode;\n    *decoded_length = 0;\n    index_buffer = 0;\n    while (index_buffer + 2 <= buffer_length)\n    {\n        opcode = buffer[index_buffer] & 15;\n        if (!(buffer[index_buffer + 1] & 128))\n            return 0;\n        length_frame_size = 1;\n        length_frame = buffer[index_buffer + 1] & 127;\n        index_buffer += 2;\n        if ((length_frame == 126) || (length_frame == 127))\n        {\n            length_frame_size = (length_frame == 126) ? 2 : 8;\n            if (buffer_length < 1 + length_frame_size)\n                return 0;\n            length_frame = 0;\n            for (i = 0; i < length_frame_size; i++)\n            {\n                length_frame += (unsigned long long)buffer[index_buffer + i] << ((length_frame_size - i - 1) * 8);\n            }\n            index_buffer += length_frame_size;\n        }\n        if (buffer_length < 1 + length_frame_size + 4 + length_frame)\n            return 0;\n        int masks[4];\n        for (i = 0; i < 4; i++)\n        {\n            masks[i] = (int)((unsigned char)buffer[index_buffer + i]);\n        }\n        index_buffer += 4;\n        switch (opcode)\n        {\n            case WEBSOCKET_FRAME_OPCODE_PING:\n                decoded[*decoded_length] = RELAY_CLIENT_MSG_PING;\n                break;\n            case WEBSOCKET_FRAME_OPCODE_CLOSE:\n                decoded[*decoded_length] = RELAY_CLIENT_MSG_CLOSE;\n                break;\n            default:\n                decoded[*decoded_length] = RELAY_CLIENT_MSG_STANDARD;\n                break;\n        }\n        *decoded_length += 1;\n        for (i = 0; i < length_frame; i++)\n        {\n            decoded[*decoded_length + i] = (int)((unsigned char)buffer[index_buffer + i]) ^ masks[i % 4];\n        }\n        decoded[*decoded_length + length_frame] = '\\0';\n        *decoded_length += length_frame + 1;\n        index_buffer += length_frame;\n    }\n    return 1;\n}", "target": 1}
{"code": "static void sctp_generate_timeout_event(struct sctp_association *asoc,\n\t\t\t\t\tsctp_event_timeout_t timeout_type)\n{\n\tstruct net *net = sock_net(asoc->base.sk);\n\tint error = 0;\n\tbh_lock_sock(asoc->base.sk);\n\tif (sock_owned_by_user(asoc->base.sk)) {\n\t\tpr_debug(\"%s: sock is busy: timer %d\\n\", __func__,\n\t\t\t timeout_type);\n\t\tif (!mod_timer(&asoc->timers[timeout_type], jiffies + (HZ/20)))\n\t\t\tsctp_association_hold(asoc);\n\t\tgoto out_unlock;\n\t}\n\tif (asoc->base.dead)\n\t\tgoto out_unlock;\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(timeout_type),\n\t\t\t   asoc->state, asoc->ep, asoc,\n\t\t\t   (void *)timeout_type, GFP_ATOMIC);\n\tif (error)\n\t\tasoc->base.sk->sk_err = -error;\nout_unlock:\n\tbh_unlock_sock(asoc->base.sk);\n\tsctp_association_put(asoc);\n}", "target": 1}
{"code": "static BOOL zgfx_append(ZGFX_CONTEXT* zgfx, BYTE** ppConcatenated, size_t uncompressedSize,\n                        size_t* pUsed)\n{\n\tWINPR_ASSERT(zgfx);\n\tWINPR_ASSERT(ppConcatenated);\n\tWINPR_ASSERT(pUsed);\n\tconst size_t used = *pUsed;\n\tif (zgfx->OutputCount > UINT32_MAX - used)\n\t\treturn FALSE;\n\tif (used + zgfx->OutputCount > uncompressedSize)\n\t\treturn FALSE;\n\tBYTE* tmp = realloc(*ppConcatenated, used + zgfx->OutputCount + 64ull);\n\tif (!tmp)\n\t\treturn FALSE;\n\t*ppConcatenated = tmp;\n\tCopyMemory(&tmp[used], zgfx->OutputBuffer, zgfx->OutputCount);\n\t*pUsed = used + zgfx->OutputCount;\n\treturn TRUE;\n}", "target": 0}
{"code": "static int nfc_genl_llc_set_params(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tstruct nfc_llcp_local *local;\n\tu8 rw = 0;\n\tu16 miux = 0;\n\tu32 idx;\n\tint rc = 0;\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    (!info->attrs[NFC_ATTR_LLC_PARAM_LTO] &&\n\t     !info->attrs[NFC_ATTR_LLC_PARAM_RW] &&\n\t     !info->attrs[NFC_ATTR_LLC_PARAM_MIUX]))\n\t\treturn -EINVAL;\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_RW]) {\n\t\trw = nla_get_u8(info->attrs[NFC_ATTR_LLC_PARAM_RW]);\n\t\tif (rw > LLCP_MAX_RW)\n\t\t\treturn -EINVAL;\n\t}\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_MIUX]) {\n\t\tmiux = nla_get_u16(info->attrs[NFC_ATTR_LLC_PARAM_MIUX]);\n\t\tif (miux > LLCP_MAX_MIUX)\n\t\t\treturn -EINVAL;\n\t}\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\tdevice_lock(&dev->dev);\n\tlocal = nfc_llcp_find_local(dev);\n\tif (!local) {\n\t\trc = -ENODEV;\n\t\tgoto exit;\n\t}\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_LTO]) {\n\t\tif (dev->dep_link_up) {\n\t\t\trc = -EINPROGRESS;\n\t\t\tgoto exit;\n\t\t}\n\t\tlocal->lto = nla_get_u8(info->attrs[NFC_ATTR_LLC_PARAM_LTO]);\n\t}\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_RW])\n\t\tlocal->rw = rw;\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_MIUX])\n\t\tlocal->miux = cpu_to_be16(miux);\nexit:\n\tdevice_unlock(&dev->dev);\n\tnfc_put_device(dev);\n\treturn rc;\n}", "target": 1}
{"code": "GF_Box *subs_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SubSampleInformationBox, GF_ISOM_BOX_TYPE_SUBS);\n\ttmp->Samples = gf_list_new();\n\treturn (GF_Box *)tmp;\n}", "target": 0}
{"code": "int options_parse(CONF_TYPE type) {\n    SERVICE_OPTIONS *section;\n    options_defaults();\n    section=&new_service_options;\n    if(options_file(configuration_file, type, &section))\n        return 1;\n    if(init_section(1, &section))\n        return 1;\n    s_log(LOG_NOTICE, \"Configuration successful\");\n    return 0;\n}", "target": 1}
{"code": "void ext2_xattr_destroy_cache(struct mb2_cache *cache)\n{\n\tif (cache)\n\t\tmb2_cache_destroy(cache);\n}", "target": 0}
{"code": "void GfxState::shiftCTMAndClip(double tx, double ty)\n{\n    ctm[4] += tx;\n    ctm[5] += ty;\n    clipXMin += tx;\n    clipYMin += ty;\n    clipXMax += tx;\n    clipYMax += ty;\n}", "target": 0}
{"code": "check_entry_for_referral(Slapi_PBlock *pb, Slapi_Entry *entry, char *matched, const char *callingfn) \n{\n\tint rc=0, i=0, numValues=0;\n\tSlapi_Attr *attr;\n\tSlapi_Value *val=NULL;\t\n\tstruct berval **refscopy=NULL;\n\tstruct berval **url=NULL;\n\tif ( slapi_entry_attr_find( entry, \"ref\", &attr ) )\n\t{\n\t\tgoto out;\n\t}\n\tslapi_attr_get_numvalues(attr, &numValues );\n\tif(numValues == 0) {\n\t\tgoto out;\n\t}\n\turl=(struct berval **) slapi_ch_malloc((numValues + 1) * sizeof(struct berval*));\n\tif (!url) {\n\t\tLDAPDebug( LDAP_DEBUG_ANY,\n\t\t\t\"check_entry_for_referral: Out of memory\\n\",\n\t\t\t0, 0, 0);\n\t\tgoto out;\n\t}\n\tfor (i = slapi_attr_first_value(attr, &val); i != -1;\n\t     i = slapi_attr_next_value(attr, i, &val)) {\n\t\turl[i]=(struct berval*)slapi_value_get_berval(val);\n\t}\n\turl[numValues]=NULL;\t\t\n\trefscopy = ref_adjust( pb, url, slapi_entry_get_sdn(entry), 0 ); \n\tslapi_send_ldap_result( pb, LDAP_REFERRAL, matched, NULL, 0, refscopy );\n\trc= 1;\n\tLDAPDebug( LDAP_DEBUG_TRACE,\n\t\t\"<= %s sent referral to (%s) for (%s)\\n\",\n\t\tcallingfn,\n\t\trefscopy ? refscopy[0]->bv_val : \"\",\n\t\tslapi_entry_get_dn(entry));\nout:\n\tif ( refscopy != NULL )\n\t{\n\t\tber_bvecfree( refscopy );\n\t}\n\tif( url != NULL) {\n\t\tslapi_ch_free( (void **)&url );\t\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "fixExec2Error(int action,\n             u_char * var_val,\n             u_char var_val_type,\n             size_t var_val_len,\n             u_char * statP, oid * name, size_t name_len)\n{\n    netsnmp_old_extend *exten = NULL;\n    unsigned int idx;\n    idx = name[name_len-1] -1;\n    exten = &compatability_entries[ idx ];\n#ifndef NETSNMP_NO_WRITE_SUPPORT\n    switch (action) {\n    case MODE_SET_RESERVE1:\n        if (var_val_type != ASN_INTEGER) {\n            snmp_log(LOG_ERR, \"Wrong type != int\\n\");\n            return SNMP_ERR_WRONGTYPE;\n        }\n        idx = *((long *) var_val);\n        if (idx != 1) {\n            snmp_log(LOG_ERR, \"Wrong value != 1\\n\");\n            return SNMP_ERR_WRONGVALUE;\n        }\n        if (!exten || !exten->efix_entry) {\n            snmp_log(LOG_ERR, \"No command to run\\n\");\n            return SNMP_ERR_GENERR;\n        }\n        return SNMP_ERR_NOERROR;\n    case MODE_SET_COMMIT:\n        netsnmp_cache_check_and_reload( exten->efix_entry->cache );\n    }\n#endif \n    return SNMP_ERR_NOERROR;\n}", "target": 1}
{"code": "void arch_pick_mmap_layout(struct mm_struct *mm)\n{\n\tunsigned long random_factor = 0UL;\n\tif (current->flags & PF_RANDOMIZE)\n\t\trandom_factor = arch_mmap_rnd();\n\tmm->mmap_legacy_base = mmap_legacy_base(random_factor);\n\tif (mmap_is_legacy()) {\n\t\tmm->mmap_base = mm->mmap_legacy_base;\n\t\tmm->get_unmapped_area = arch_get_unmapped_area;\n\t} else {\n\t\tmm->mmap_base = mmap_base(random_factor);\n\t\tmm->get_unmapped_area = arch_get_unmapped_area_topdown;\n\t}\n}", "target": 1}
{"code": "update_bar_address(struct vmctx *ctx, struct pci_vdev *dev, uint64_t addr,\n\tint idx, int type, bool ignore_reg_unreg)\n{\n\tbool decode = false;\n\tuint64_t orig_addr = dev->bar[idx].addr;\n\tif (!ignore_reg_unreg) {\n\t\tif (dev->bar[idx].type == PCIBAR_IO)\n\t\t\tdecode = porten(dev);\n\t\telse\n\t\t\tdecode = memen(dev);\n\t}\n\tif (decode)\n\t\tunregister_bar(dev, idx);\n\tswitch (type) {\n\tcase PCIBAR_IO:\n\tcase PCIBAR_MEM32:\n\t\tdev->bar[idx].addr = addr;\n\t\tbreak;\n\tcase PCIBAR_MEM64:\n\t\tdev->bar[idx].addr &= ~0xffffffffUL;\n\t\tdev->bar[idx].addr |= addr;\n\t\tbreak;\n\tcase PCIBAR_MEMHI64:\n\t\tdev->bar[idx].addr &= 0xffffffff;\n\t\tdev->bar[idx].addr |= addr;\n\t\tbreak;\n\tdefault:\n\t\tassert(0);\n\t}\n\tif (decode)\n\t\tregister_bar(dev, idx);\n\tif (dev->dev_ops->vdev_update_bar_map && decode)\n\t\tdev->dev_ops->vdev_update_bar_map(ctx, dev, idx, orig_addr);\n}", "target": 1}
{"code": "int ZEXPORT deflatePrime (strm, bits, value)\n    z_streamp strm;\n    int bits;\n    int value;\n{\n    deflate_state *s;\n    int put;\n    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;\n    s = strm->state;\n    if ((Bytef *)(s->d_buf) < s->pending_out + ((Buf_size + 7) >> 3))\n        return Z_BUF_ERROR;\n    do {\n        put = Buf_size - s->bi_valid;\n        if (put > bits)\n            put = bits;\n        s->bi_buf |= (ush)((value & ((1 << put) - 1)) << s->bi_valid);\n        s->bi_valid += put;\n        _tr_flush_bits(s);\n        value >>= put;\n        bits -= put;\n    } while (bits);\n    return Z_OK;\n}", "target": 1}
{"code": "static int perf_swevent_init(struct perf_event *event)\n{\n\tint event_id = event->attr.config;\n\tif (event->attr.type != PERF_TYPE_SOFTWARE)\n\t\treturn -ENOENT;\n\tif (has_branch_stack(event))\n\t\treturn -EOPNOTSUPP;\n\tswitch (event_id) {\n\tcase PERF_COUNT_SW_CPU_CLOCK:\n\tcase PERF_COUNT_SW_TASK_CLOCK:\n\t\treturn -ENOENT;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (event_id >= PERF_COUNT_SW_MAX)\n\t\treturn -ENOENT;\n\tif (!event->parent) {\n\t\tint err;\n\t\terr = swevent_hlist_get(event);\n\t\tif (err)\n\t\t\treturn err;\n\t\tstatic_key_slow_inc(&perf_swevent_enabled[event_id]);\n\t\tevent->destroy = sw_perf_event_destroy;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct encrypted_key_payload *epayload = key->payload.data[0];\n\tstruct encrypted_key_payload *new_epayload;\n\tchar *buf;\n\tchar *new_master_desc = NULL;\n\tconst char *format = NULL;\n\tsize_t datalen = prep->datalen;\n\tint ret = 0;\n\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n\t\treturn -ENOKEY;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\tbuf = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tbuf[datalen] = 0;\n\tmemcpy(buf, prep->data, datalen);\n\tret = datablob_parse(buf, &format, &new_master_desc, NULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = valid_master_desc(new_master_desc, epayload->master_desc);\n\tif (ret < 0)\n\t\tgoto out;\n\tnew_epayload = encrypted_key_alloc(key, epayload->format,\n\t\t\t\t\t   new_master_desc, epayload->datalen);\n\tif (IS_ERR(new_epayload)) {\n\t\tret = PTR_ERR(new_epayload);\n\t\tgoto out;\n\t}\n\t__ekey_init(new_epayload, epayload->format, new_master_desc,\n\t\t    epayload->datalen);\n\tmemcpy(new_epayload->iv, epayload->iv, ivsize);\n\tmemcpy(new_epayload->payload_data, epayload->payload_data,\n\t       epayload->payload_datalen);\n\trcu_assign_keypointer(key, new_epayload);\n\tcall_rcu(&epayload->rcu, encrypted_rcu_free);\nout:\n\tkzfree(buf);\n\treturn ret;\n}", "target": 1}
{"code": "static int __init xfrm6_tunnel_spi_init(void)\n{\n\txfrm6_tunnel_spi_kmem = kmem_cache_create(\"xfrm6_tunnel_spi\",\n\t\t\t\t\t\t  sizeof(struct xfrm6_tunnel_spi),\n\t\t\t\t\t\t  0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t\t  NULL);\n\tif (!xfrm6_tunnel_spi_kmem)\n\t\treturn -ENOMEM;\n\treturn 0;\n}", "target": 1}
{"code": "xmlValidCtxtPtr xmlNewValidCtxt(void) {\n    xmlValidCtxtPtr ret;\n    if ((ret = xmlMalloc(sizeof (xmlValidCtxt))) == NULL) {\n\txmlVErrMemory(NULL, \"malloc failed\");\n\treturn (NULL);\n    }\n    (void) memset(ret, 0, sizeof (xmlValidCtxt));\n    return (ret);\n}", "target": 0}
{"code": "static int tiocgetd(struct tty_struct *tty, int __user *p)\n{\n\tstruct tty_ldisc *ld;\n\tint ret;\n\tld = tty_ldisc_ref_wait(tty);\n\tret = put_user(ld->ops->num, p);\n\ttty_ldisc_deref(ld);\n\treturn ret;\n}", "target": 0}
{"code": "int key_update(key_ref_t key_ref, const void *payload, size_t plen)\n{\n\tstruct key_preparsed_payload prep;\n\tstruct key *key = key_ref_to_ptr(key_ref);\n\tint ret;\n\tkey_check(key);\n\tret = key_permission(key_ref, KEY_NEED_WRITE);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!key->type->update)\n\t\treturn -EOPNOTSUPP;\n\tmemset(&prep, 0, sizeof(prep));\n\tprep.data = payload;\n\tprep.datalen = plen;\n\tprep.quotalen = key->type->def_datalen;\n\tprep.expiry = TIME_T_MAX;\n\tif (key->type->preparse) {\n\t\tret = key->type->preparse(&prep);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\tdown_write(&key->sem);\n\tret = key->type->update(key, &prep);\n\tif (ret == 0)\n\t\tclear_bit(KEY_FLAG_NEGATIVE, &key->flags);\n\tup_write(&key->sem);\nerror:\n\tif (key->type->preparse)\n\t\tkey->type->free_preparse(&prep);\n\treturn ret;\n}", "target": 1}
{"code": "void ImageLoader::DecodeRequest::Trace(blink::Visitor* visitor) {\n  visitor->Trace(resolver_);\n  visitor->Trace(loader_);\n}", "target": 0}
{"code": "log2vis_encoded_string (PyObject * string, const char *encoding,\n\t\t\tFriBidiParType base_direction, int clean, int reordernsm)\n{\n\tPyObject *logical = NULL;\t\n\tPyObject *result = NULL;\t\n\tlogical = PyUnicode_Decode (PyString_AS_STRING (string),\n\t\t\t\t    PyString_GET_SIZE (string),\n\t\t\t\t    encoding, \"strict\");\n\tif (logical == NULL)\n\t\treturn NULL;\n\tif (strcmp (encoding, \"utf-8\") == 0)\n\t\tresult = log2vis_utf8 (string,\n\t\t\t\t       PyUnicode_GET_SIZE (logical),\n\t\t\t\t       base_direction, clean, reordernsm);\n\telse\n\t{\n\t\tPyObject *visual = log2vis_unicode (logical, base_direction, clean, reordernsm);\n\t\tif (visual)\n\t\t{\n\t\t\tresult = PyUnicode_Encode (PyUnicode_AS_UNICODE\n\t\t\t\t\t\t   (visual),\n\t\t\t\t\t\t   PyUnicode_GET_SIZE (visual),\n\t\t\t\t\t\t   encoding, \"strict\");\n\t\t\tPy_DECREF (visual);\n\t\t}\n\t}\n\tPy_DECREF (logical);\n\treturn result;\n}", "target": 1}
{"code": "void LightProcess::ChangeUser(const std::string &username) {\n  if (username.empty()) return;\n  for (int i = 0; i < g_procsCount; i++) {\n    Lock lock(g_procs[i].m_procMutex);\n    fprintf(g_procs[i].m_fout, \"change_user\\n%s\\n\", username.c_str());\n    fflush(g_procs[i].m_fout);\n  }\n}", "target": 1}
{"code": "void LibRaw::read_shorts(ushort *pixel, unsigned count)\n{\n  if (fread(pixel, 2, count, ifp) < count)\n    derror();\n  if ((order == 0x4949) == (ntohs(0x1234) == 0x1234))\n    swab((char *)pixel, (char *)pixel, count * 2);\n}", "target": 0}
{"code": "static int crypto_shash_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_hash rhash;\n\tstruct shash_alg *salg = __crypto_shash_alg(alg);\n\tsnprintf(rhash.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"shash\");\n\trhash.blocksize = alg->cra_blocksize;\n\trhash.digestsize = salg->digestsize;\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_HASH,\n\t\t    sizeof(struct crypto_report_hash), &rhash))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "  void readDataAvailable(size_t len) noexcept override {\n    VLOG(3) << \"Read of size: \" << len;\n    s_->setReadCB(nullptr);\n    s_->getEventBase()->runInLoop([this]() { s_->setReadCB(this); });\n  }", "target": 0}
{"code": "\t\tvoid Phase2() final {\n\t\t\tLocal<Context> context_handle = Deref(context);\n\t\t\tContext::Scope context_scope{context_handle};\n\t\t\tLocal<Object> object = Local<Object>::Cast(Deref(reference));\n\t\t\tresult = Unmaybe(object->Delete(context_handle, key->CopyInto()));\n\t\t}", "target": 1}
{"code": "static bool comp_add_to_data(zckCtx *zck, zckComp *comp, const char *src,\n                             size_t src_size) {\n    VALIDATE_BOOL(zck);\n    ALLOCD_BOOL(zck, comp);\n    ALLOCD_BOOL(zck, src);\n    if((comp->data_size > comp->data_size + src_size) ||\n       (src_size > comp->data_size + src_size)) {\n        zck_log(ZCK_LOG_ERROR, \"Integer overflow when reading data\");\n        return false;\n    }\n    comp->data = zrealloc(comp->data, comp->data_size + src_size);\n    if (!comp->data) {\n        zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n        return false;\n    }\n    zck_log(ZCK_LOG_DEBUG, \"Adding %llu bytes to compressed buffer\",\n        (long long unsigned) src_size);\n    memcpy(comp->data + comp->data_size, src, src_size);\n    comp->data_size += src_size;\n    comp->data_loc += src_size;\n    return true;\n}", "target": 0}
{"code": "static void vmx_disable_intercept_msr_read_x2apic(u32 msr)\n{\n\t__vmx_disable_intercept_for_msr(vmx_msr_bitmap_legacy_x2apic,\n\t\t\tmsr, MSR_TYPE_R);\n\t__vmx_disable_intercept_for_msr(vmx_msr_bitmap_longmode_x2apic,\n\t\t\tmsr, MSR_TYPE_R);\n}", "target": 0}
{"code": "MakeFilename(char *buffer, char *orig_name, int cnt, int max_chars)\n{\n        char *filename = malloc(PATH_MAX + 1);\n        if (filename == NULL)\n            error(\"%s: malloc\", __func__);\n        if (Gflag != 0) {\n          struct tm *local_tm;\n          if ((local_tm = localtime(&Gflag_time)) == NULL) {\n                  error(\"%s: localtime\", __func__);\n          }\n          strftime(filename, PATH_MAX, orig_name, local_tm);\n        } else {\n          strncpy(filename, orig_name, PATH_MAX);\n        }\n\tif (cnt == 0 && max_chars == 0)\n\t\tstrncpy(buffer, filename, PATH_MAX + 1);\n\telse\n\t\tif (snprintf(buffer, PATH_MAX + 1, \"%s%0*d\", filename, max_chars, cnt) > PATH_MAX)\n                  error(\"too many output files or filename is too long (> %d)\", PATH_MAX);\n        free(filename);\n}", "target": 1}
{"code": "SYSCALL_DEFINE5(add_key, const char __user *, _type,\n\t\tconst char __user *, _description,\n\t\tconst void __user *, _payload,\n\t\tsize_t, plen,\n\t\tkey_serial_t, ringid)\n{\n\tkey_ref_t keyring_ref, key_ref;\n\tchar type[32], *description;\n\tvoid *payload;\n\tlong ret;\n\tret = -EINVAL;\n\tif (plen > 1024 * 1024 - 1)\n\t\tgoto error;\n\tret = key_get_type_from_user(type, _type, sizeof(type));\n\tif (ret < 0)\n\t\tgoto error;\n\tdescription = NULL;\n\tif (_description) {\n\t\tdescription = strndup_user(_description, KEY_MAX_DESC_SIZE);\n\t\tif (IS_ERR(description)) {\n\t\t\tret = PTR_ERR(description);\n\t\t\tgoto error;\n\t\t}\n\t\tif (!*description) {\n\t\t\tkfree(description);\n\t\t\tdescription = NULL;\n\t\t} else if ((description[0] == '.') &&\n\t\t\t   (strncmp(type, \"keyring\", 7) == 0)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto error2;\n\t\t}\n\t}\n\tpayload = NULL;\n\tif (_payload) {\n\t\tret = -ENOMEM;\n\t\tpayload = kvmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error2;\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(payload, _payload, plen) != 0)\n\t\t\tgoto error3;\n\t}\n\tkeyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error3;\n\t}\n\tkey_ref = key_create_or_update(keyring_ref, type, description,\n\t\t\t\t       payload, plen, KEY_PERM_UNDEF,\n\t\t\t\t       KEY_ALLOC_IN_QUOTA);\n\tif (!IS_ERR(key_ref)) {\n\t\tret = key_ref_to_ptr(key_ref)->serial;\n\t\tkey_ref_put(key_ref);\n\t}\n\telse {\n\t\tret = PTR_ERR(key_ref);\n\t}\n\tkey_ref_put(keyring_ref);\n error3:\n\tkvfree(payload);\n error2:\n\tkfree(description);\n error:\n\treturn ret;\n}", "target": 1}
{"code": "ecryptfs_decode_from_filename(unsigned char *dst, size_t *dst_size,\n\t\t\t      const unsigned char *src, size_t src_size)\n{\n\tu8 current_bit_offset = 0;\n\tsize_t src_byte_offset = 0;\n\tsize_t dst_byte_offset = 0;\n\tif (dst == NULL) {\n\t\t(*dst_size) = ecryptfs_max_decoded_size(src_size);\n\t\tgoto out;\n\t}\n\twhile (src_byte_offset < src_size) {\n\t\tunsigned char src_byte =\n\t\t\t\tfilename_rev_map[(int)src[src_byte_offset]];\n\t\tswitch (current_bit_offset) {\n\t\tcase 0:\n\t\t\tdst[dst_byte_offset] = (src_byte << 2);\n\t\t\tcurrent_bit_offset = 6;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tdst[dst_byte_offset++] |= (src_byte >> 4);\n\t\t\tdst[dst_byte_offset] = ((src_byte & 0xF)\n\t\t\t\t\t\t << 4);\n\t\t\tcurrent_bit_offset = 4;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdst[dst_byte_offset++] |= (src_byte >> 2);\n\t\t\tdst[dst_byte_offset] = (src_byte << 6);\n\t\t\tcurrent_bit_offset = 2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdst[dst_byte_offset++] |= (src_byte);\n\t\t\tdst[dst_byte_offset] = 0;\n\t\t\tcurrent_bit_offset = 0;\n\t\t\tbreak;\n\t\t}\n\t\tsrc_byte_offset++;\n\t}\n\t(*dst_size) = dst_byte_offset;\nout:\n\treturn;\n}", "target": 1}
{"code": " void RootWindowHostWin::UnConfineCursor() {\n   ClipCursor(NULL);\n }", "target": 0}
{"code": "static int stream_thunk(void *buf, size_t size, void *data)\n{\n\tint error = 0;\n\tstruct push_packbuilder_payload *payload = data;\n\tif ((error = payload->stream->write(payload->stream, (const char *)buf, size)) < 0)\n\t\treturn error;\n\tif (payload->cb) {\n\t\tdouble current_time = git__timer();\n\t\tpayload->last_bytes += size;\n\t\tif ((current_time - payload->last_progress_report_time) >= MIN_PROGRESS_UPDATE_INTERVAL) {\n\t\t\tpayload->last_progress_report_time = current_time;\n\t\t\terror = payload->cb(payload->pb->nr_written, payload->pb->nr_objects, payload->last_bytes, payload->cb_payload);\n\t\t}\n\t}\n\treturn error;\n}", "target": 0}
{"code": "rio_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tint phy_addr;\n\tstruct netdev_private *np = netdev_priv(dev);\n\tstruct mii_data *miidata = (struct mii_data *) &rq->ifr_ifru;\n\tstruct netdev_desc *desc;\n\tint i;\n\tphy_addr = np->phy_addr;\n\tswitch (cmd) {\n\tcase SIOCDEVPRIVATE:\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 1:\n\t\tmiidata->out_value = mii_read (dev, phy_addr, miidata->reg_num);\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 2:\n\t\tmii_write (dev, phy_addr, miidata->reg_num, miidata->in_value);\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 3:\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 4:\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 5:\n\t\tnetif_stop_queue (dev);\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 6:\n\t\tnetif_wake_queue (dev);\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 7:\n\t\tprintk\n\t\t    (\"tx_full=%x cur_tx=%lx old_tx=%lx cur_rx=%lx old_rx=%lx\\n\",\n\t\t     netif_queue_stopped(dev), np->cur_tx, np->old_tx, np->cur_rx,\n\t\t     np->old_rx);\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 8:\n\t\tprintk(\"TX ring:\\n\");\n\t\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\t\tdesc = &np->tx_ring[i];\n\t\t\tprintk\n\t\t\t    (\"%02x:cur:%08x next:%08x status:%08x frag1:%08x frag0:%08x\",\n\t\t\t     i,\n\t\t\t     (u32) (np->tx_ring_dma + i * sizeof (*desc)),\n\t\t\t     (u32)le64_to_cpu(desc->next_desc),\n\t\t\t     (u32)le64_to_cpu(desc->status),\n\t\t\t     (u32)(le64_to_cpu(desc->fraginfo) >> 32),\n\t\t\t     (u32)le64_to_cpu(desc->fraginfo));\n\t\t\tprintk (\"\\n\");\n\t\t}\n\t\tprintk (\"\\n\");\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void HTMLSelectElement::dispatchFocusEvent(Element* oldFocusedElement, FocusDirection direction)\n{\n    if (usesMenuList())\n        saveLastSelection();\n    HTMLFormControlElementWithState::dispatchFocusEvent(oldFocusedElement, direction);\n}", "target": 0}
{"code": "        unsigned int GetUVarBE(int nPos, int nSize, bool *pbSuccess)\n        {\n            if ( nPos < 0 || nPos + nSize > m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            unsigned int nRes = 0;\n            for ( int nIndex = 0; nIndex < nSize; ++nIndex )\n                nRes = (nRes << 8) + m_sFile[nPos + nIndex];\n            return nRes;\n        }", "target": 1}
{"code": "static struct vm_area_struct *vma_to_resize(unsigned long addr,\n\tunsigned long old_len, unsigned long new_len, unsigned long *p)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = find_vma(mm, addr);\n\tif (!vma || vma->vm_start > addr)\n\t\tgoto Efault;\n\tif (is_vm_hugetlb_page(vma))\n\t\tgoto Einval;\n\tif (old_len > vma->vm_end - addr)\n\t\tgoto Efault;\n\tif (vma->vm_flags & (VM_DONTEXPAND | VM_PFNMAP)) {\n\t\tif (new_len > old_len)\n\t\t\tgoto Efault;\n\t}\n\tif (vma->vm_flags & VM_LOCKED) {\n\t\tunsigned long locked, lock_limit;\n\t\tlocked = mm->locked_vm << PAGE_SHIFT;\n\t\tlock_limit = rlimit(RLIMIT_MEMLOCK);\n\t\tlocked += new_len - old_len;\n\t\tif (locked > lock_limit && !capable(CAP_IPC_LOCK))\n\t\t\tgoto Eagain;\n\t}\n\tif (!may_expand_vm(mm, (new_len - old_len) >> PAGE_SHIFT))\n\t\tgoto Enomem;\n\tif (vma->vm_flags & VM_ACCOUNT) {\n\t\tunsigned long charged = (new_len - old_len) >> PAGE_SHIFT;\n\t\tif (security_vm_enough_memory(charged))\n\t\t\tgoto Efault;\n\t\t*p = charged;\n\t}\n\treturn vma;\nEfault:\t\n\treturn ERR_PTR(-EFAULT);\nEinval:\n\treturn ERR_PTR(-EINVAL);\nEnomem:\n\treturn ERR_PTR(-ENOMEM);\nEagain:\n\treturn ERR_PTR(-EAGAIN);\n}", "target": 1}
{"code": "  erase_all_clients() {\n    map_id_client.clear();\n    cert_chain.clear();\n    save_state();\n  }", "target": 0}
{"code": "static int skcipher_accept_parent(void *private, struct sock *sk)\n{\n\tstruct skcipher_ctx *ctx;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tunsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(private);\n\tctx = sock_kmalloc(sk, len, GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\tctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(private),\n\t\t\t       GFP_KERNEL);\n\tif (!ctx->iv) {\n\t\tsock_kfree_s(sk, ctx, len);\n\t\treturn -ENOMEM;\n\t}\n\tmemset(ctx->iv, 0, crypto_skcipher_ivsize(private));\n\tINIT_LIST_HEAD(&ctx->tsgl);\n\tctx->len = len;\n\tctx->used = 0;\n\tctx->more = 0;\n\tctx->merge = 0;\n\tctx->enc = 0;\n\tatomic_set(&ctx->inflight, 0);\n\taf_alg_init_completion(&ctx->completion);\n\task->private = ctx;\n\tskcipher_request_set_tfm(&ctx->req, private);\n\tskcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t      af_alg_complete, &ctx->completion);\n\tsk->sk_destruct = skcipher_sock_destruct;\n\treturn 0;\n}", "target": 1}
{"code": "CACHE_BITMAP_V2_ORDER* copy_cache_bitmap_v2_order(rdpContext* context,\n                                                  const CACHE_BITMAP_V2_ORDER* order)\n{\n\tCACHE_BITMAP_V2_ORDER* dst = calloc(1, sizeof(CACHE_BITMAP_V2_ORDER));\n\tif (!dst || !order)\n\t\tgoto fail;\n\t*dst = *order;\n\tif (order->bitmapLength > 0)\n\t{\n\t\tdst->bitmapDataStream = malloc(order->bitmapLength);\n\t\tif (!dst->bitmapDataStream)\n\t\t\tgoto fail;\n\t\tmemcpy(dst->bitmapDataStream, order->bitmapDataStream, order->bitmapLength);\n\t}\n\treturn dst;\nfail:\n\tfree_cache_bitmap_v2_order(context, dst);\n\treturn NULL;\n}", "target": 0}
{"code": "static int __br_mdb_del(struct net_bridge *br, struct br_mdb_entry *entry)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tstruct br_ip ip;\n\tint err = -EINVAL;\n\tif (!netif_running(br->dev) || br->multicast_disabled)\n\t\treturn -EINVAL;\n\tif (timer_pending(&br->multicast_querier_timer))\n\t\treturn -EBUSY;\n\tip.proto = entry->addr.proto;\n\tif (ip.proto == htons(ETH_P_IP))\n\t\tip.u.ip4 = entry->addr.u.ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\telse\n\t\tip.u.ip6 = entry->addr.u.ip6;\n#endif\n\tspin_lock_bh(&br->multicast_lock);\n\tmdb = mlock_dereference(br->mdb, br);\n\tmp = br_mdb_ip_get(mdb, &ip);\n\tif (!mp)\n\t\tgoto unlock;\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (!p->port || p->port->dev->ifindex != entry->ifindex)\n\t\t\tcontinue;\n\t\tif (p->port->state == BR_STATE_DISABLED)\n\t\t\tgoto unlock;\n\t\trcu_assign_pointer(*pp, p->next);\n\t\thlist_del_init(&p->mglist);\n\t\tdel_timer(&p->timer);\n\t\tcall_rcu_bh(&p->rcu, br_multicast_free_pg);\n\t\terr = 0;\n\t\tif (!mp->ports && !mp->mglist &&\n\t\t    netif_running(br->dev))\n\t\t\tmod_timer(&mp->timer, jiffies);\n\t\tbreak;\n\t}\nunlock:\n\tspin_unlock_bh(&br->multicast_lock);\n\treturn err;\n}", "target": 1}
{"code": "void PdfXRefStreamParserObject::parseStream(const int64_t wArray[W_ARRAY_SIZE], const vector<int64_t>& indices)\n{\n    for (int64_t lengthSum = 0, i = 0; i < W_ARRAY_SIZE; i++)\n    {\n        if (wArray[i] < 0)\n        {\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef,\n                \"Negative field length in XRef stream\");\n        }\n        if (numeric_limits<int64_t>::max() - lengthSum < wArray[i])\n        {\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef,\n                \"Invalid entry length in XRef stream\");\n        }\n        else\n        {\n            lengthSum += wArray[i];\n        }\n    }\n    const size_t entryLen = static_cast<size_t>(wArray[0] + wArray[1] + wArray[2]);\n    charbuff buffer;\n    this->GetOrCreateStream().CopyTo(buffer);\n    vector<int64_t>::const_iterator it = indices.begin();\n    char* cursor = buffer.data();\n    while (it != indices.end())\n    {\n        int64_t firstObj = *it++;\n        int64_t count = *it++;\n        m_entries->Enlarge(firstObj + count);\n        for (unsigned index = 0; index < (unsigned)count; index++)\n        {\n            if ((size_t)(cursor - buffer.data()) >= buffer.size())\n                PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid count in XRef stream\");\n            unsigned objIndex = (unsigned)firstObj + index;\n            auto& entry = (*m_entries)[objIndex];\n            if (objIndex < m_entries->GetSize() && !entry.Parsed)\n                readXRefStreamEntry(entry, cursor, wArray);\n            cursor += entryLen;\n        }\n    }\n}", "target": 1}
{"code": "int xt_check_entry_offsets(const void *base,\n\t\t\t   const char *elems,\n\t\t\t   unsigned int target_offset,\n\t\t\t   unsigned int next_offset)\n{\n\tlong size_of_base_struct = elems - (const char *)base;\n\tconst struct xt_entry_target *t;\n\tconst char *e = base;\n\tif (target_offset < size_of_base_struct)\n\t\treturn -EINVAL;\n\tif (target_offset + sizeof(*t) > next_offset)\n\t\treturn -EINVAL;\n\tt = (void *)(e + target_offset);\n\tif (t->u.target_size < sizeof(*t))\n\t\treturn -EINVAL;\n\tif (target_offset + t->u.target_size > next_offset)\n\t\treturn -EINVAL;\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) == 0 &&\n\t    target_offset + sizeof(struct xt_standard_target) != next_offset)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 0}
{"code": "const int& getActiveId(const void* object, const StructInfo& info) {\n  return *reinterpret_cast<const int*>(\n      static_cast<const char*>(object) + info.unionExt->unionTypeOffset);\n}", "target": 0}
{"code": "ip_printts(netdissect_options *ndo,\n           register const u_char *cp, u_int length)\n{\n\tregister u_int ptr;\n\tregister u_int len;\n\tint hoplen;\n\tconst char *type;\n\tif (length < 4) {\n\t\tND_PRINT((ndo, \"[bad length %u]\", length));\n\t\treturn;\n\t}\n\tND_PRINT((ndo, \" TS{\"));\n\thoplen = ((cp[3]&0xF) != IPOPT_TS_TSONLY) ? 8 : 4;\n\tif ((length - 4) & (hoplen-1))\n\t\tND_PRINT((ndo, \"[bad length %u]\", length));\n\tptr = cp[2] - 1;\n\tlen = 0;\n\tif (ptr < 4 || ((ptr - 4) & (hoplen-1)) || ptr > length + 1)\n\t\tND_PRINT((ndo, \"[bad ptr %u]\", cp[2]));\n\tswitch (cp[3]&0xF) {\n\tcase IPOPT_TS_TSONLY:\n\t\tND_PRINT((ndo, \"TSONLY\"));\n\t\tbreak;\n\tcase IPOPT_TS_TSANDADDR:\n\t\tND_PRINT((ndo, \"TS+ADDR\"));\n\t\tbreak;\n\tcase 2:\n\t\tND_PRINT((ndo, \"PRESPEC2.0\"));\n\t\tbreak;\n\tcase 3:\t\t\t\n\t\tND_PRINT((ndo, \"PRESPEC\"));\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \"[bad ts type %d]\", cp[3]&0xF));\n\t\tgoto done;\n\t}\n\ttype = \" \";\n\tfor (len = 4; len < length; len += hoplen) {\n\t\tif (ptr == len)\n\t\t\ttype = \" ^ \";\n\t\tND_PRINT((ndo, \"%s%d@%s\", type, EXTRACT_32BITS(&cp[len+hoplen-4]),\n\t\t       hoplen!=8 ? \"\" : ipaddr_string(ndo, &cp[len])));\n\t\ttype = \" \";\n\t}\ndone:\n\tND_PRINT((ndo, \"%s\", ptr == len ? \" ^ \" : \"\"));\n\tif (cp[3]>>4)\n\t\tND_PRINT((ndo, \" [%d hops not recorded]} \", cp[3]>>4));\n\telse\n\t\tND_PRINT((ndo, \"}\"));\n}", "target": 1}
{"code": "GF_EXPORT\nBool gf_isom_get_oinf_info(GF_ISOFile *file, u32 trackNumber, GF_OperatingPointsInformation **ptr)\n{\n\tu32 oref_track, def_index=0;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(file, trackNumber);\n\tif (!ptr) return GF_FALSE;\n\toref_track=0;\n\tgf_isom_get_reference(file, trackNumber, GF_ISOM_REF_OREF, 1, &oref_track);\n\tif (oref_track) {\n\t\ttrak = gf_isom_get_track_from_file(file, oref_track);\n\t\tif (!trak) return GF_FALSE;\n\t}\n\t*ptr = (GF_OperatingPointsInformation *) gf_isom_get_sample_group_info_entry(file, trak, GF_ISOM_SAMPLE_GROUP_OINF, 1, &def_index, NULL);\n\treturn *ptr ? GF_TRUE : GF_FALSE;", "target": 0}
{"code": "void invalidate_lstat_cache(void)\n{\n\treset_lstat_cache(&default_cache);\n}", "target": 0}
{"code": "static inline int process_nested_data(UNSERIALIZE_PARAMETER, HashTable *ht, long elements, int objprops)\n{\n\twhile (elements-- > 0) {\n\t\tzval *key, *data, **old_data;\n\t\tALLOC_INIT_ZVAL(key);\n\t\tif (!php_var_unserialize(&key, p, max, NULL TSRMLS_CC)) {\n\t\t\tzval_dtor(key);\n\t\t\tFREE_ZVAL(key);\n\t\t\treturn 0;\n\t\t}\n\t\tif (Z_TYPE_P(key) != IS_LONG && Z_TYPE_P(key) != IS_STRING) {\n\t\t\tzval_dtor(key);\n\t\t\tFREE_ZVAL(key);\n\t\t\treturn 0;\n\t\t}\n\t\tALLOC_INIT_ZVAL(data);\n\t\tif (!php_var_unserialize(&data, p, max, var_hash TSRMLS_CC)) {\n\t\t\tzval_dtor(key);\n\t\t\tFREE_ZVAL(key);\n\t\t\tzval_dtor(data);\n\t\t\tFREE_ZVAL(data);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!objprops) {\n\t\t\tswitch (Z_TYPE_P(key)) {\n\t\t\tcase IS_LONG:\n\t\t\t\tif (zend_hash_index_find(ht, Z_LVAL_P(key), (void **)&old_data)==SUCCESS) {\n\t\t\t\t\tvar_push_dtor(var_hash, old_data);\n\t\t\t\t}\n\t\t\t\tzend_hash_index_update(ht, Z_LVAL_P(key), &data, sizeof(data), NULL);\n\t\t\t\tbreak;\n\t\t\tcase IS_STRING:\n\t\t\t\tif (zend_symtable_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) {\n\t\t\t\t\tvar_push_dtor(var_hash, old_data);\n\t\t\t\t}\n\t\t\t\tzend_symtable_update(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, &data, sizeof(data), NULL);\n\t\t\t\tbreak;\n\t\t\t}\n                } else {\n                        convert_to_string(key);\n                       if (zend_symtable_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) {\n                               var_push_dtor(var_hash, old_data);\n                       }\n                        zend_hash_update(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, &data,\n                                        sizeof data, NULL);\n                }\n\t\tif (elements && *(*p-1) != ';' && *(*p-1) != '}') {\n\t\t\t(*p)--;\n\t\t\treturn 0;\n\t\t}\n\t}", "target": 0}
{"code": "void options_apply() { \n    unsigned num=0;\n    SERVICE_OPTIONS *section;\n    CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_SECTIONS]);\n    memcpy(&global_options, &new_global_options, sizeof(GLOBAL_OPTIONS));\n    memset(&new_global_options, 0, sizeof(GLOBAL_OPTIONS));\n    for(section=new_service_options.next; section; section=section->next)\n        section->section_number=num++;\n    memcpy(&service_options, &new_service_options, sizeof(SERVICE_OPTIONS));\n    memset(&new_service_options, 0, sizeof(SERVICE_OPTIONS));\n    number_of_sections=num;\n    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_SECTIONS]);\n}", "target": 0}
{"code": "static int sd_isoc_nego(struct gspca_dev *gspca_dev)\n{\n\tint ret, packet_size, min_packet_size;\n\tstruct usb_host_interface *alt;\n\tswitch (gspca_dev->pixfmt.width) {\n\tcase 160:\n\t\tmin_packet_size = 200;\n\t\tbreak;\n\tcase 176:\n\t\tmin_packet_size = 266;\n\t\tbreak;\n\tdefault:\n\t\tmin_packet_size = 400;\n\t\tbreak;\n\t}\n\talt = &gspca_dev->dev->actconfig->intf_cache[0]->altsetting[1];\n\tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n\tif (packet_size <= min_packet_size)\n\t\treturn -EIO;\n\tpacket_size -= 100;\n\tif (packet_size < min_packet_size)\n\t\tpacket_size = min_packet_size;\n\talt->endpoint[0].desc.wMaxPacketSize = cpu_to_le16(packet_size);\n\tret = usb_set_interface(gspca_dev->dev, gspca_dev->iface, 1);\n\tif (ret < 0)\n\t\tpr_err(\"set alt 1 err %d\\n\", ret);\n\treturn ret;\n}", "target": 0}
{"code": "static int dsa_precheck_params(const DSA *dsa, int *ret)\n{\n    if (dsa->params.p == NULL || dsa->params.q == NULL) {\n        ERR_raise(ERR_LIB_DSA, DSA_R_BAD_FFC_PARAMETERS);\n        *ret = FFC_CHECK_INVALID_PQ;\n        return 0;\n    }\n    if (BN_num_bits(dsa->params.p) > OPENSSL_DSA_MAX_MODULUS_BITS) {\n        ERR_raise(ERR_LIB_DSA, DSA_R_MODULUS_TOO_LARGE);\n        *ret = FFC_CHECK_INVALID_PQ;\n        return 0;\n    }\n    if (BN_num_bits(dsa->params.q) >= BN_num_bits(dsa->params.p)) {\n        ERR_raise(ERR_LIB_DSA, DSA_R_BAD_Q_VALUE);\n        *ret = FFC_CHECK_INVALID_PQ;\n        return 0;\n    }\n    return 1;\n}", "target": 0}
{"code": "static inline int ok_jpg_peek_bits(ok_jpg_decoder *decoder, int num_bits) {\n    return (int)((decoder->input_buffer_bits >> (decoder->input_buffer_bit_count - num_bits)) &\n                 ((1 << num_bits) - 1));\n}", "target": 0}
{"code": "NTLM_AV_PAIR* ntlm_av_pair_get(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList, NTLM_AV_ID AvId,\n                               size_t* pcbAvPairListRemaining)\n{\n\tsize_t cbAvPair = cbAvPairList;\n\tNTLM_AV_PAIR* pAvPair = pAvPairList;\n\tif (!ntlm_av_pair_check(pAvPair, cbAvPair))\n\t\tpAvPair = NULL;\n\twhile (pAvPair)\n\t{\n\t\tUINT16 id = ntlm_av_pair_get_id(pAvPair);\n\t\tif (id == AvId)\n\t\t\tbreak;\n\t\tif (id == MsvAvEOL)\n\t\t{\n\t\t\tpAvPair = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tpAvPair = ntlm_av_pair_next(pAvPair, &cbAvPair);\n\t}\n\tif (!pAvPair)\n\t\tcbAvPair = 0;\n\tif (pcbAvPairListRemaining)\n\t\t*pcbAvPairListRemaining = cbAvPair;\n\treturn pAvPair;\n}", "target": 1}
{"code": "mm_answer_pam_init_ctx(int sock, Buffer *m)\n{\n\tdebug3(\"%s\", __func__);\n\tauthctxt->user = buffer_get_string(m, NULL);\n\tsshpam_ctxt = (sshpam_device.init_ctx)(authctxt);\n\tsshpam_authok = NULL;\n\tbuffer_clear(m);\n\tif (sshpam_ctxt != NULL) {\n\t\tmonitor_permit(mon_dispatch, MONITOR_REQ_PAM_FREE_CTX, 1);\n\t\tbuffer_put_int(m, 1);\n\t} else {\n\t\tbuffer_put_int(m, 0);\n\t}\n\tmm_request_send(sock, MONITOR_ANS_PAM_INIT_CTX, m);\n\treturn (0);\n}", "target": 1}
{"code": "TfLiteStatus ComputeDepthMultiplier(TfLiteContext* context,\n                                    const TfLiteTensor* input,\n                                    const TfLiteTensor* filter,\n                                    int16* depth_multiplier) {\n  int num_filter_channels = SizeOfDimension(filter, 3);\n  int num_input_channels = SizeOfDimension(input, 3);\n  TF_LITE_ENSURE_EQ(context, num_filter_channels % num_input_channels, 0);\n  *depth_multiplier = num_filter_channels / num_input_channels;\n  return kTfLiteOk;\n}", "target": 1}
{"code": "bool fixpath_ro(Computer *comp, const std::string& path) {\n    std::vector<std::string> elems = split(path, \"/\\\\\");\n    std::list<std::string> pathc;\n    for (std::string s : elems) {\n        if (s == \"..\") { if (pathc.empty()) return false; else pathc.pop_back(); }\n        else if (!s.empty() && !std::all_of(s.begin(), s.end(), [](const char c)->bool{return c == '.';})) {\n            s = s.substr(s.find_first_not_of(' '), s.find_last_not_of(' ') - s.find_first_not_of(' ') + 1);\n            s.erase(std::remove_if(s.begin(), s.end(), [](char c)->bool{return c=='\"'||c==':'||c=='<'||c=='>'||c=='?'||c=='|';}), s.end());\n            pathc.push_back(s);\n        }\n    }\n    while (!pathc.empty() && pathc.front().empty()) pathc.pop_front();\n    if (!pathc.empty() && pathc.back().size() > 255) {\n        std::string s = pathc.back().substr(0, 255);\n        pathc.pop_back();\n        s = s.substr(0, s.find_last_not_of(' '));\n        pathc.push_back(s);\n    }\n    std::pair<size_t, bool> max_path = std::make_pair(0, false);\n    for (const auto& m : comp->mounts)\n        if (pathc.size() >= std::get<0>(m).size() && std::get<0>(m).size() > max_path.first && std::equal(std::get<0>(m).begin(), std::get<0>(m).end(), pathc.begin()))\n            max_path = std::make_pair(std::get<0>(m).size(), std::get<2>(m));\n    return max_path.second;\n}", "target": 1}
{"code": "get_word_gray_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    register unsigned int temp;\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n    *ptr++ = rescale[temp];\n  }\n  return 1;\n}", "target": 1}
{"code": "static Exit_status safe_connect()\n{\n  mysql= mysql_init(NULL);\n  if (!mysql)\n  {\n    error(\"Failed on mysql_init.\");\n    return ERROR_STOP;\n  }\n#ifdef HAVE_OPENSSL\n  if (opt_use_ssl)\n  {\n    mysql_ssl_set(mysql, opt_ssl_key, opt_ssl_cert, opt_ssl_ca,\n                  opt_ssl_capath, opt_ssl_cipher);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRL, opt_ssl_crl);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRLPATH, opt_ssl_crlpath);\n  }\n  mysql_options(mysql, MYSQL_OPT_SSL_VERIFY_SERVER_CERT,\n                (char*) &opt_ssl_verify_server_cert);\n#endif\n  if (opt_plugin_dir && *opt_plugin_dir)\n    mysql_options(mysql, MYSQL_PLUGIN_DIR, opt_plugin_dir);\n  if (opt_default_auth && *opt_default_auth)\n    mysql_options(mysql, MYSQL_DEFAULT_AUTH, opt_default_auth);\n  if (opt_protocol)\n    mysql_options(mysql, MYSQL_OPT_PROTOCOL, (char*) &opt_protocol);\n  if (opt_bind_addr)\n    mysql_options(mysql, MYSQL_OPT_BIND, opt_bind_addr);\n#if defined (_WIN32) && !defined (EMBEDDED_LIBRARY)\n  if (shared_memory_base_name)\n    mysql_options(mysql, MYSQL_SHARED_MEMORY_BASE_NAME,\n                  shared_memory_base_name);\n#endif\n  mysql_options(mysql, MYSQL_OPT_CONNECT_ATTR_RESET, 0);\n  mysql_options4(mysql, MYSQL_OPT_CONNECT_ATTR_ADD,\n                 \"program_name\", \"mysqlbinlog\");\n  if (!mysql_real_connect(mysql, host, user, pass, 0, port, sock, 0))\n  {\n    error(\"Failed on connect: %s\", mysql_error(mysql));\n    return ERROR_STOP;\n  }\n  mysql->reconnect= 1;\n  return OK_CONTINUE;\n}", "target": 1}
{"code": "static void megasas_command_cancelled(SCSIRequest *req)\n{\n    MegasasCmd *cmd = req->hba_private;\n    if (!cmd) {\n        return;\n    }\n    cmd->frame->header.cmd_status = MFI_STAT_SCSI_IO_FAILED;\n    megasas_complete_command(cmd);\n}", "target": 0}
{"code": "int btrfs_check_dir_item_collision(struct btrfs_root *root, u64 dir,\n\t\t\t\t   const char *name, int name_len)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct btrfs_dir_item *di;\n\tint data_size;\n\tstruct extent_buffer *leaf;\n\tint slot;\n\tstruct btrfs_path *path;\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tkey.objectid = dir;\n\tbtrfs_set_key_type(&key, BTRFS_DIR_ITEM_KEY);\n\tkey.offset = btrfs_name_hash(name, name_len);\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tdi = btrfs_match_dir_item_name(root, path, name, name_len);\n\tif (di) {\n\t\tret = -EEXIST;\n\t\tgoto out;\n\t}\n\tdata_size = sizeof(*di) + name_len + sizeof(struct btrfs_item);\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\tif (data_size + btrfs_item_size_nr(leaf, slot) +\n\t    sizeof(struct btrfs_item) > BTRFS_LEAF_DATA_SIZE(root)) {\n\t\tret = -EOVERFLOW;\n\t} else {\n\t\tret = 0;\n\t}\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}", "target": 0}
{"code": "static int sh_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {\n\tut8 op_MSB,op_LSB;\n\tint ret;\n\tif (!data)\n\t\treturn 0;\n\tmemset (op, '\\0', sizeof (RAnalOp));\n\top->addr = addr;\n\top->type = R_ANAL_OP_TYPE_UNK;\n\top->jump = op->fail = -1;\n\top->ptr = op->val = -1;\n\top->size = 2;\n\top_MSB = anal->big_endian? data[0]: data[1];\n\top_LSB = anal->big_endian? data[1]: data[0];\n\tret =  first_nibble_decode[(op_MSB>>4) & 0x0F](anal, op, (ut16)(op_MSB<<8 | op_LSB));\n\treturn ret;\n}", "target": 1}
{"code": "START_TEST(test_deltas_head_sort)\n{\n\tstruct deltas_head deltas;\n\tdeltas_head_init(&deltas);\n\tck_assert_int_eq(0, deltas_head_sort(&deltas, 0));\n\tck_assert_int_eq(0, deltas_head_sort(&deltas, 1));\n\tck_assert_int_eq(0, deltas_head_sort(&deltas, 2));\n\tadd_serials(&deltas, 0, END);\n\tck_assert_int_eq(0, deltas_head_sort(&deltas, 0));\n\tvalidate_serials(&deltas, 0, END);\n\tck_assert_int_eq(-EINVAL, deltas_head_sort(&deltas, 2));\n\tck_assert_int_eq(-EINVAL, deltas_head_sort(&deltas, 1));\n\tadd_serials(&deltas, 1, 2, 3, END);\n\tck_assert_int_eq(0, deltas_head_sort(&deltas, 3));\n\tvalidate_serials(&deltas, 0, 1, 2, 3, END);\n\tck_assert_int_eq(-EINVAL, deltas_head_sort(&deltas, 4));\n\tck_assert_int_eq(-EINVAL, deltas_head_sort(&deltas, 2));\n\tdeltas_head_cleanup(&deltas, NULL);\n\tdeltas_head_init(&deltas);\n\tadd_serials(&deltas, 3, 0, 1, 2, END);\n\tck_assert_int_eq(0, deltas_head_sort(&deltas, 3));\n\tvalidate_serials(&deltas, 0, 1, 2, 3, END);\n\tdeltas_head_cleanup(&deltas, NULL);\n\tdeltas_head_init(&deltas);\n\tadd_serials(&deltas, 4, 3, 2, 1, 0, END);\n\tck_assert_int_eq(0, deltas_head_sort(&deltas, 4));\n\tvalidate_serials(&deltas, 0, 1, 2, 3, 4, END);\n\tck_assert_int_eq(-EINVAL, deltas_head_sort(&deltas, 5));\n\tck_assert_int_eq(-EINVAL, deltas_head_sort(&deltas, 3));\n\tdeltas_head_cleanup(&deltas, NULL);\n}", "target": 0}
{"code": "DECLAREContigPutFunc(put4bitbwtile)\n{\n    uint32** BWmap = img->BWmap;\n    (void) x; (void) y;\n    fromskew /= 2;\n    while (h-- > 0) {\n\tuint32* bw;\n\tUNROLL2(w, bw = BWmap[*pp++], *cp++ = *bw++);\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}", "target": 0}
{"code": "bittok2str_internal(register const struct tok *lp, register const char *fmt,\n\t   register u_int v, const char *sep)\n{\n        static char buf[256]; \n        int buflen=0;\n        register u_int rotbit; \n        register u_int tokval;\n        const char * sepstr = \"\";\n\twhile (lp != NULL && lp->s != NULL) {\n            tokval=lp->v;   \n            rotbit=1;\n            while (rotbit != 0) {\n\t\tif (tokval == (v&rotbit)) {\n                    buflen+=snprintf(buf+buflen, sizeof(buf)-buflen, \"%s%s\",\n                                     sepstr, lp->s);\n                    sepstr = sep;\n                    break;\n                }\n                rotbit=rotbit<<1; \n            }\n            lp++;\n\t}\n        if (buflen == 0)\n            (void)snprintf(buf, sizeof(buf), fmt == NULL ? \"#%08x\" : fmt, v);\n        return (buf);\n}", "target": 1}
{"code": "static void mark_verifier_state_clean(struct bpf_verifier_env *env)\n{\n\tenv->scratched_regs = 0U;\n\tenv->scratched_stack_slots = 0ULL;\n}", "target": 0}
{"code": "TEST(BasicFlatBufferModel, TestUnsupportedRecursion) {\n  const auto model_path =\n      \"tensorflow/lite/testdata/unsupported_recursion.bin\";\n  std::unique_ptr<tflite::FlatBufferModel> model =\n      FlatBufferModel::BuildFromFile(model_path);\n  ASSERT_NE(model, nullptr);\n  tflite::ops::builtin::BuiltinOpResolver resolver;\n  InterpreterBuilder builder(*model, resolver);\n  std::unique_ptr<Interpreter> interpreter;\n  ASSERT_EQ(builder(&interpreter), kTfLiteOk);\n  ASSERT_NE(interpreter, nullptr);\n  ASSERT_NE(interpreter->AllocateTensors(), kTfLiteOk);\n}", "target": 0}
{"code": "vips_utf8_strcasestr( const char *haystack_start, const char *needle_start, \n\tint len_bytes )\n{\n        int needle_len = g_utf8_strlen( needle_start, -1 );\n        int needle_len_bytes = strlen( needle_start );\n\tconst char *haystack;\n\tfor( haystack = haystack_start; \n\t\thaystack - haystack_start <= len_bytes - needle_len_bytes; \n\t\thaystack = g_utf8_find_next_char( haystack, NULL ) ) {\n                const char *needle_char;\n                const char *haystack_char;\n\t\tint i;\n                haystack_char = haystack;\n                needle_char = needle_start;\n                for( i = 0; i < needle_len; i++ ) {\n                        gunichar a = \n\t\t\t\tg_utf8_get_char_validated( haystack_char, \n\t\t\t\t\thaystack_start + len_bytes - haystack );\n                        gunichar b = \n\t\t\t\tg_utf8_get_char_validated( needle_char, -1 );\n                        if( a == (gunichar) -1 ||\n\t\t\t\ta == (gunichar) -2 ||\n\t\t\t\tb == (gunichar) -1 ||\n\t\t\t\tb == (gunichar) -2 )\n                                return( NULL );\n                        if( a == (gunichar) 0 )\n                                return( NULL );\n                        if( g_unichar_tolower( a ) != g_unichar_tolower( b ) )\n                                break;\n                        haystack_char = \n\t\t\t\tg_utf8_find_next_char( haystack_char, \n\t\t\t\t\thaystack_start + len_bytes );\n                        needle_char = \n\t\t\t\tg_utf8_find_next_char( needle_char, NULL );\n                }\n                if( i == needle_len )\n                        return( haystack );\n        }\n        return( NULL );\n}", "target": 1}
{"code": "_mibindex_add( const char *dirname, int i )\n{\n    const int old_mibindex_max = _mibindex_max;\n    DEBUGMSGTL((\"mibindex\", \"add: %s (%d)\\n\", dirname, i ));\n    if ( i == -1 )\n        i = _mibindex++;\n    if ( i >= _mibindex_max ) {\n        _mibindex_max = i + 10;\n        _mibindexes = realloc(_mibindexes,\n                              _mibindex_max * sizeof(_mibindexes[0]));\n        netsnmp_assert(_mibindexes);\n        memset(_mibindexes + old_mibindex_max, 0,\n               (_mibindex_max - old_mibindex_max) * sizeof(_mibindexes[0]));\n    }\n    _mibindexes[ i ] = strdup( dirname );\n    if ( i >= _mibindex )\n        _mibindex = i+1;\n    DEBUGMSGTL((\"mibindex\", \"add: %d/%d/%d\\n\", i, _mibindex, _mibindex_max ));\n    return i;\n}", "target": 1}
{"code": "static pfn_t kvm_pin_pages(struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t   unsigned long size)\n{\n\tgfn_t end_gfn;\n\tpfn_t pfn;\n\tpfn     = gfn_to_pfn_memslot(slot, gfn);\n\tend_gfn = gfn + (size >> PAGE_SHIFT);\n\tgfn    += 1;\n\tif (is_error_noslot_pfn(pfn))\n\t\treturn pfn;\n\twhile (gfn < end_gfn)\n\t\tgfn_to_pfn_memslot(slot, gfn++);\n\treturn pfn;\n}", "target": 1}
{"code": "static void xudc_getstatus(struct xusb_udc *udc)\n{\n\tstruct xusb_ep *ep0\t= &udc->ep[0];\n\tstruct xusb_req *req\t= udc->req;\n\tstruct xusb_ep *target_ep;\n\tu16 status = 0;\n\tu32 epcfgreg;\n\tint epnum;\n\tu32 halt;\n\tint ret;\n\tswitch (udc->setup.bRequestType & USB_RECIP_MASK) {\n\tcase USB_RECIP_DEVICE:\n\t\tstatus = 1 << USB_DEVICE_SELF_POWERED;\n\t\tif (udc->remote_wkp)\n\t\t\tstatus |= (1 << USB_DEVICE_REMOTE_WAKEUP);\n\t\tbreak;\n\tcase USB_RECIP_INTERFACE:\n\t\tbreak;\n\tcase USB_RECIP_ENDPOINT:\n\t\tepnum = udc->setup.wIndex & USB_ENDPOINT_NUMBER_MASK;\n\t\tif (epnum >= XUSB_MAX_ENDPOINTS)\n\t\t\tgoto stall;\n\t\ttarget_ep = &udc->ep[epnum];\n\t\tepcfgreg = udc->read_fn(udc->addr + target_ep->offset);\n\t\thalt = epcfgreg & XUSB_EP_CFG_STALL_MASK;\n\t\tif (udc->setup.wIndex & USB_DIR_IN) {\n\t\t\tif (!target_ep->is_in)\n\t\t\t\tgoto stall;\n\t\t} else {\n\t\t\tif (target_ep->is_in)\n\t\t\t\tgoto stall;\n\t\t}\n\t\tif (halt)\n\t\t\tstatus = 1 << USB_ENDPOINT_HALT;\n\t\tbreak;\n\tdefault:\n\t\tgoto stall;\n\t}\n\treq->usb_req.length = 2;\n\t*(u16 *)req->usb_req.buf = cpu_to_le16(status);\n\tret = __xudc_ep0_queue(ep0, req);\n\tif (ret == 0)\n\t\treturn;\nstall:\n\tdev_err(udc->dev, \"Can't respond to getstatus request\\n\");\n\txudc_ep0_stall(udc);\n}", "target": 0}
{"code": "    CImg<T>& RGBtoYUV() {\n      if (_spectrum!=3)\n        throw CImgInstanceException(_cimg_instance\n                                    \"RGBtoYUV(): Instance is not a RGB image.\",\n                                    cimg_instance);\n      T *p1 = data(0,0,0,0), *p2 = data(0,0,0,1), *p3 = data(0,0,0,2);\n      const ulongT whd = (ulongT)_width*_height*_depth;\n      cimg_pragma_openmp(parallel for cimg_openmp_if(whd>=16384))\n      for (ulongT N = 0; N<whd; ++N) {\n        const Tfloat\n          R = (Tfloat)p1[N]/255,\n          G = (Tfloat)p2[N]/255,\n          B = (Tfloat)p3[N]/255,\n          Y = 0.299f*R + 0.587f*G + 0.114f*B;\n        p1[N] = (T)Y;\n        p2[N] = (T)(0.492f*(B - Y));\n        p3[N] = (T)(0.877*(R - Y));\n      }\n      return *this;", "target": 0}
{"code": "list_session(char *log_dir, regex_t *re, const char *user, const char *tty)\n{\n    char idbuf[7], *idstr, *cp;\n    struct eventlog *evlog = NULL;\n    const char *timestr;\n    int ret = -1;\n    debug_decl(list_session, SUDO_DEBUG_UTIL);\n    if ((evlog = iolog_parse_loginfo(-1, log_dir)) == NULL)\n\tgoto done;\n    if (evlog->command == NULL || evlog->submituser == NULL ||\n\t    evlog->runuser == NULL) {\n\tgoto done;\n    }\n    if (!STAILQ_EMPTY(&search_expr) && !match_expr(&search_expr, evlog, true))\n\tgoto done;\n    cp = log_dir + strlen(session_dir) + 1;\n    if (IS_IDLOG(cp)) {\n\tidbuf[0] = cp[0];\n\tidbuf[1] = cp[1];\n\tidbuf[2] = cp[3];\n\tidbuf[3] = cp[4];\n\tidbuf[4] = cp[6];\n\tidbuf[5] = cp[7];\n\tidbuf[6] = '\\0';\n\tidstr = idbuf;\n    } else {\n\tidstr = cp;\n    }\n    timestr = get_timestr(evlog->submit_time.tv_sec, 1);\n    printf(\"%s : %s : \", timestr ? timestr : \"invalid date\", evlog->submituser);\n    if (evlog->submithost != NULL)\n\tprintf(\"HOST=%s ; \", evlog->submithost);\n    if (evlog->ttyname != NULL)\n\tprintf(\"TTY=%s ; \", evlog->ttyname);\n    if (evlog->runchroot != NULL)\n\tprintf(\"CHROOT=%s ; \", evlog->runchroot);\n    if (evlog->runcwd != NULL || evlog->cwd != NULL)\n\tprintf(\"CWD=%s ; \", evlog->runcwd ? evlog->runcwd : evlog->cwd);\n    printf(\"USER=%s ; \", evlog->runuser);\n    if (evlog->rungroup != NULL)\n\tprintf(\"GROUP=%s ; \", evlog->rungroup);\n    printf(\"TSID=%s ; COMMAND=%s\\n\", idstr, evlog->command);\n    ret = 0;\ndone:\n    eventlog_free(evlog);\n    debug_return_int(ret);\n}", "target": 1}
{"code": "static size_t exif_convert_any_to_int(void *value, int format, int motorola_intel TSRMLS_DC)\n{\n\tint \t\ts_den;\n\tunsigned \tu_den;\n\tswitch(format) {\n\t\tcase TAG_FMT_SBYTE:     return *(signed char *)value;\n\t\tcase TAG_FMT_BYTE:      return *(uchar *)value;\n\t\tcase TAG_FMT_USHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_ULONG:     return php_ifd_get32u(value, motorola_intel);\n\t\tcase TAG_FMT_URATIONAL:\n\t\t\tu_den = php_ifd_get32u(4+(char *)value, motorola_intel);\n\t\t\tif (u_den == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn php_ifd_get32u(value, motorola_intel) / u_den;\n\t\t\t}\n\t\tcase TAG_FMT_SRATIONAL:\n\t\t\ts_den = php_ifd_get32s(4+(char *)value, motorola_intel);\n\t\t\tif (s_den == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn php_ifd_get32s(value, motorola_intel) / s_den;\n\t\t\t}\n\t\tcase TAG_FMT_SSHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_SLONG:     return php_ifd_get32s(value, motorola_intel);\n\t\tcase TAG_FMT_SINGLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Found value of type single\");\n#endif\n\t\t\treturn (size_t)*(float *)value;\n\t\tcase TAG_FMT_DOUBLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Found value of type double\");\n#endif\n\t\t\treturn (size_t)*(double *)value;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "MagickExport int LocaleLowercase(const int c)\n{\n  if (c == EOF)\n    return(c);\n#if defined(MAGICKCORE_LOCALE_SUPPORT)\n  if (c_locale != (locale_t) NULL)\n    return(tolower_l((int) ((unsigned char) c),c_locale));\n#endif\n  return(tolower((int) ((unsigned char) c)));\n}", "target": 0}
{"code": "static int ext4_convert_unwritten_extents_endio(handle_t *handle,\n\t\t\t\t\t      struct inode *inode,\n\t\t\t\t\t      struct ext4_ext_path *path)\n{\n\tstruct ext4_extent *ex;\n\tint depth;\n\tint err = 0;\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\text_debug(\"ext4_convert_unwritten_extents_endio: inode %lu, logical\"\n\t\t\"block %llu, max_blocks %u\\n\", inode->i_ino,\n\t\t(unsigned long long)le32_to_cpu(ex->ee_block),\n\t\text4_ext_get_actual_len(ex));\n\terr = ext4_ext_get_access(handle, inode, path + depth);\n\tif (err)\n\t\tgoto out;\n\text4_ext_mark_initialized(ex);\n\text4_ext_try_to_merge(handle, inode, path, ex);\n\terr = ext4_ext_dirty(handle, inode, path + path->p_depth);\nout:\n\text4_ext_show_leaf(inode, path);\n\treturn err;\n}", "target": 1}
{"code": "set_bm_backward_skip(UChar* s, UChar* end, OnigEncoding enc ARG_UNUSED,\n\t\t     int** skip)\n{\n  int i, len;\n  if (IS_NULL(*skip)) {\n    *skip = (int* )xmalloc(sizeof(int) * ONIG_CHAR_TABLE_SIZE);\n    if (IS_NULL(*skip)) return ONIGERR_MEMORY;\n  }\n  len = (int )(end - s);\n  for (i = 0; i < ONIG_CHAR_TABLE_SIZE; i++)\n    (*skip)[i] = len;\n  for (i = len - 1; i > 0; i--)\n    (*skip)[s[i]] = i;\n  return 0;\n}", "target": 0}
{"code": "void out_string(conn *c, const char *str) {\n    size_t len;\n    mc_resp *resp = c->resp;\n    assert(c != NULL);\n    resp_reset(resp);\n    if (c->noreply) {\n        resp->skip = true;\n        if (settings.verbose > 1)\n            fprintf(stderr, \">%d NOREPLY %s\\n\", c->sfd, str);\n        conn_set_state(c, conn_new_cmd);\n        return;\n    }\n    if (settings.verbose > 1)\n        fprintf(stderr, \">%d %s\\n\", c->sfd, str);\n    len = strlen(str);\n    if ((len + 2) > WRITE_BUFFER_SIZE) {\n        str = \"SERVER_ERROR output line too long\";\n        len = strlen(str);\n    }\n    memcpy(resp->wbuf, str, len);\n    memcpy(resp->wbuf + len, \"\\r\\n\", 2);\n    resp_add_iov(resp, resp->wbuf, len + 2);\n    conn_set_state(c, conn_new_cmd);\n    return;\n}", "target": 1}
{"code": "static void sas_eh_finish_cmd(struct scsi_cmnd *cmd)\n{\n\tstruct sas_ha_struct *sas_ha = SHOST_TO_SAS_HA(cmd->device->host);\n\tstruct domain_device *dev = cmd_to_domain_dev(cmd);\n\tstruct sas_task *task = TO_SAS_TASK(cmd);\n\tsas_end_task(cmd, task);\n\tif (dev_is_sata(dev)) {\n\t\tlist_move_tail(&cmd->eh_entry, &sas_ha->eh_ata_q);\n\t\treturn;\n\t}\n\tscsi_eh_finish_cmd(cmd, &sas_ha->eh_done_q);\n}", "target": 0}
{"code": "void fx_DataView(txMachine* the)\n{\n\ttxSlot* slot;\n\ttxBoolean flag = 0;\n\ttxInteger offset, size;\n\ttxSlot* info;\n\ttxSlot* instance;\n\ttxSlot* view;\n\ttxSlot* buffer;\n\tif (mxIsUndefined(mxTarget))\n\t\tmxTypeError(\"call: DataView\");\n\tif ((mxArgc > 0) && (mxArgv(0)->kind == XS_REFERENCE_KIND)) {\n\t\tslot = mxArgv(0)->value.reference->next;\n\t\tif (slot && ((slot->kind == XS_ARRAY_BUFFER_KIND) || (slot->kind == XS_HOST_KIND))) {\n\t\t\tflag = 1;\n\t\t}\n\t}\n\tif (!flag)\n\t\tmxTypeError(\"buffer is no ArrayBuffer instance\");\n\toffset = fxArgToByteLength(the, 1, 0);\n\tinfo = fxGetBufferInfo(the, mxArgv(0));\n\tif (info->value.bufferInfo.length < offset)\n\t\tmxRangeError(\"out of range byteOffset %ld\", offset);\n\tsize = fxArgToByteLength(the, 2, -1);\n\tif (size >= 0) {\n\t\tif (info->value.bufferInfo.length < (offset + size))\n\t\t\tmxRangeError(\"out of range byteLength %ld\", size);\n\t}\n\telse {\n\t\tif (info->value.bufferInfo.maxLength < 0)\n\t\t\tsize = info->value.bufferInfo.length - offset;\n\t}\n\tmxPushSlot(mxTarget);\n\tfxGetPrototypeFromConstructor(the, &mxDataViewPrototype);\n\tinstance = fxNewDataViewInstance(the);\n\tmxPullSlot(mxResult);\n\tview = instance->next;\n\tbuffer = view->next;\n\tbuffer->kind = XS_REFERENCE_KIND;\n\tbuffer->value.reference = mxArgv(0)->value.reference;\n\tinfo = fxGetBufferInfo(the, buffer);\n\tif (info->value.bufferInfo.maxLength >= 0) {\n\t\tif (info->value.bufferInfo.length < offset)\n\t\t\tmxRangeError(\"out of range byteOffset %ld\", offset);\n\t\telse if (size >= 0) {\n\t\t\tif (info->value.bufferInfo.length < (offset + size))\n\t\t\t\tmxRangeError(\"out of range byteLength %ld\", size);\n\t\t}\n\t}\n\tview->value.dataView.offset = offset;\n\tview->value.dataView.size = size;\n}", "target": 1}
{"code": "static int read_new_config_info (WavpackContext *wpc, WavpackMetadata *wpmd)\n{\n    int bytecnt = wpmd->byte_length;\n    unsigned char *byteptr = wpmd->data;\n    wpc->version_five = 1;      \n    wpc->file_format = wpc->config.qmode = wpc->channel_layout = 0;\n    if (wpc->channel_reordering) {\n        free (wpc->channel_reordering);\n        wpc->channel_reordering = NULL;\n    }\n    if (bytecnt) {\n        wpc->file_format = *byteptr++;\n        wpc->config.qmode = (wpc->config.qmode & ~0xff) | *byteptr++;\n        bytecnt -= 2;\n        if (bytecnt) {\n            int nchans, i;\n            wpc->channel_layout = (int32_t) *byteptr++ << 16;\n            bytecnt--;\n            if (bytecnt) {\n                wpc->channel_layout += nchans = *byteptr++;\n                bytecnt--;\n                if (bytecnt) {\n                    if (bytecnt > nchans)\n                        return FALSE;\n                    wpc->channel_reordering = malloc (nchans);\n                    if (wpc->channel_reordering) {\n                        for (i = 0; i < nchans; ++i)\n                            if (bytecnt) {\n                                wpc->channel_reordering [i] = *byteptr++;\n                                bytecnt--;\n                            }\n                            else\n                                wpc->channel_reordering [i] = i;\n                    }\n                }\n            }\n            else\n                wpc->channel_layout += wpc->config.num_channels;\n        }\n    }\n    return TRUE;\n}", "target": 1}
{"code": "static int rds_loop_xmit(struct rds_connection *conn, struct rds_message *rm,\n\t\t\t unsigned int hdr_off, unsigned int sg,\n\t\t\t unsigned int off)\n{\n\tif (rm->m_inc.i_hdr.h_flags & RDS_FLAG_CONG_BITMAP) {\n\t\trds_cong_map_updated(conn->c_fcong, ~(u64) 0);\n\t\treturn sizeof(struct rds_header) + RDS_CONG_MAP_BYTES;\n\t}\n\tBUG_ON(hdr_off || sg || off);\n\trds_inc_init(&rm->m_inc, conn, conn->c_laddr);\n\trds_message_addref(rm);\n\trds_recv_incoming(conn, conn->c_laddr, conn->c_faddr, &rm->m_inc,\n\t\t\t  GFP_KERNEL, KM_USER0);\n\trds_send_drop_acked(conn, be64_to_cpu(rm->m_inc.i_hdr.h_sequence),\n\t\t\t    NULL);\n\trds_inc_put(&rm->m_inc);\n\treturn sizeof(struct rds_header) + be32_to_cpu(rm->m_inc.i_hdr.h_len);\n}", "target": 1}
{"code": "void invalidFunctionWasCalled() {}", "target": 0}
{"code": "std::wstring GetUniqueTempDirectoryPrefix()\n{\n    wchar_t tmpdir[MAX_PATH + 1];\n    if (GetTempPath(MAX_PATH + 1, tmpdir) == 0)\n        throw Win32Exception(\"Cannot create temporary directory\");\n    std::wstring dir(tmpdir);\n    dir += L\"Update-\";\n    return dir;\n}", "target": 0}
{"code": "static int crypto_rng_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_rng rrng;\n\tsnprintf(rrng.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"rng\");\n\trrng.seedsize = alg->cra_rng.seedsize;\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_RNG,\n\t\t    sizeof(struct crypto_report_rng), &rrng))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "        int          Read(void* pDestBuffer, int nSize)\n        {\n            if ( m_nPos + nSize >= m_nLen )\n                nSize = m_nLen - m_nPos - 1;\n            memcpy( pDestBuffer, (m_sFile + m_nPos), nSize );\n            m_nPos += nSize;\n            return nSize;\n        }", "target": 1}
{"code": "GtkTreeModel *bluetooth_client_get_model (BluetoothClient *client)\n{\n\tBluetoothClientPrivate *priv;\n\tGtkTreeModel *model;\n\tg_return_val_if_fail (BLUETOOTH_IS_CLIENT (client), NULL);\n\tpriv = BLUETOOTH_CLIENT_GET_PRIVATE(client);\n\tmodel = GTK_TREE_MODEL (g_object_ref(priv->store));\n\treturn model;\n}", "target": 0}
{"code": "AudioContext* AudioContext::create(Document& document, ExceptionState& exceptionState)\n{\n    ASSERT(isMainThread());\n    if (s_hardwareContextCount >= MaxHardwareContexts) {\n        exceptionState.throwDOMException(\n            SyntaxError,\n            \"number of hardware contexts reached maximum (\" + String::number(MaxHardwareContexts) + \").\");\n        return 0;\n    }\n    AudioContext* audioContext = new AudioContext(&document);\n    audioContext->suspendIfNeeded();\n    return audioContext;\n}", "target": 0}
{"code": "static ssize_t lbs_debugfs_write(struct file *f, const char __user *buf,\n\t\t\t    size_t cnt, loff_t *ppos)\n{\n\tint r, i;\n\tchar *pdata;\n\tchar *p;\n\tchar *p0;\n\tchar *p1;\n\tchar *p2;\n\tstruct debug_data *d = f->private_data;\n\tpdata = kmalloc(cnt, GFP_KERNEL);\n\tif (pdata == NULL)\n\t\treturn 0;\n\tif (copy_from_user(pdata, buf, cnt)) {\n\t\tlbs_deb_debugfs(\"Copy from user failed\\n\");\n\t\tkfree(pdata);\n\t\treturn 0;\n\t}\n\tp0 = pdata;\n\tfor (i = 0; i < num_of_items; i++) {\n\t\tdo {\n\t\t\tp = strstr(p0, d[i].name);\n\t\t\tif (p == NULL)\n\t\t\t\tbreak;\n\t\t\tp1 = strchr(p, '\\n');\n\t\t\tif (p1 == NULL)\n\t\t\t\tbreak;\n\t\t\tp0 = p1++;\n\t\t\tp2 = strchr(p, '=');\n\t\t\tif (!p2)\n\t\t\t\tbreak;\n\t\t\tp2++;\n\t\t\tr = simple_strtoul(p2, NULL, 0);\n\t\t\tif (d[i].size == 1)\n\t\t\t\t*((u8 *) d[i].addr) = (u8) r;\n\t\t\telse if (d[i].size == 2)\n\t\t\t\t*((u16 *) d[i].addr) = (u16) r;\n\t\t\telse if (d[i].size == 4)\n\t\t\t\t*((u32 *) d[i].addr) = (u32) r;\n\t\t\telse if (d[i].size == 8)\n\t\t\t\t*((u64 *) d[i].addr) = (u64) r;\n\t\t\tbreak;\n\t\t} while (1);\n\t}\n\tkfree(pdata);\n\treturn (ssize_t)cnt;\n}", "target": 1}
{"code": "static int udf_load_sparable_map(struct super_block *sb,\n\t\t\t\t struct udf_part_map *map,\n\t\t\t\t struct sparablePartitionMap *spm)\n{\n\tuint32_t loc;\n\tuint16_t ident;\n\tstruct sparingTable *st;\n\tstruct udf_sparing_data *sdata = &map->s_type_specific.s_sparing;\n\tint i;\n\tstruct buffer_head *bh;\n\tmap->s_partition_type = UDF_SPARABLE_MAP15;\n\tsdata->s_packet_len = le16_to_cpu(spm->packetLength);\n\tif (!is_power_of_2(sdata->s_packet_len)) {\n\t\tudf_err(sb, \"error loading logical volume descriptor: \"\n\t\t\t\"Invalid packet length %u\\n\",\n\t\t\t(unsigned)sdata->s_packet_len);\n\t\treturn -EIO;\n\t}\n\tif (spm->numSparingTables > 4) {\n\t\tudf_err(sb, \"error loading logical volume descriptor: \"\n\t\t\t\"Too many sparing tables (%d)\\n\",\n\t\t\t(int)spm->numSparingTables);\n\t\treturn -EIO;\n\t}\n\tfor (i = 0; i < spm->numSparingTables; i++) {\n\t\tloc = le32_to_cpu(spm->locSparingTable[i]);\n\t\tbh = udf_read_tagged(sb, loc, loc, &ident);\n\t\tif (!bh)\n\t\t\tcontinue;\n\t\tst = (struct sparingTable *)bh->b_data;\n\t\tif (ident != 0 ||\n\t\t    strncmp(st->sparingIdent.ident, UDF_ID_SPARING,\n\t\t\t    strlen(UDF_ID_SPARING)) ||\n\t\t    sizeof(*st) + le16_to_cpu(st->reallocationTableLen) >\n\t\t\t\t\t\t\tsb->s_blocksize) {\n\t\t\tbrelse(bh);\n\t\t\tcontinue;\n\t\t}\n\t\tsdata->s_spar_map[i] = bh;\n\t}\n\tmap->s_partition_func = udf_get_pblock_spar15;\n\treturn 0;\n}", "target": 0}
{"code": "gx_default_include_color_space(gx_device *pdev, gs_color_space *cspace,\n        const byte *res_name, int name_length)\n{\n    return 0;\n}", "target": 0}
{"code": "static int nfc_genl_deactivate_target(struct sk_buff *skb,\n\t\t\t\t      struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tu32 device_idx, target_idx;\n\tint rc;\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n\t\treturn -EINVAL;\n\tdevice_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tdev = nfc_get_device(device_idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\ttarget_idx = nla_get_u32(info->attrs[NFC_ATTR_TARGET_INDEX]);\n\trc = nfc_deactivate_target(dev, target_idx, NFC_TARGET_MODE_SLEEP);\n\tnfc_put_device(dev);\n\treturn rc;\n}", "target": 1}
{"code": "static int list_devices(struct file *filp, struct dm_ioctl *param, size_t param_size)\n{\n\tunsigned int i;\n\tstruct hash_cell *hc;\n\tsize_t len, needed = 0;\n\tstruct gendisk *disk;\n\tstruct dm_name_list *orig_nl, *nl, *old_nl = NULL;\n\tuint32_t *event_nr;\n\tdown_write(&_hash_lock);\n\tfor (i = 0; i < NUM_BUCKETS; i++) {\n\t\tlist_for_each_entry (hc, _name_buckets + i, name_list) {\n\t\t\tneeded += align_val(offsetof(struct dm_name_list, name) + strlen(hc->name) + 1);\n\t\t\tneeded += align_val(sizeof(uint32_t));\n\t\t}\n\t}\n\tnl = orig_nl = get_result_buffer(param, param_size, &len);\n\tif (len < needed) {\n\t\tparam->flags |= DM_BUFFER_FULL_FLAG;\n\t\tgoto out;\n\t}\n\tparam->data_size = param->data_start + needed;\n\tnl->dev = 0;\t\n\tfor (i = 0; i < NUM_BUCKETS; i++) {\n\t\tlist_for_each_entry (hc, _name_buckets + i, name_list) {\n\t\t\tif (old_nl)\n\t\t\t\told_nl->next = (uint32_t) ((void *) nl -\n\t\t\t\t\t\t\t   (void *) old_nl);\n\t\t\tdisk = dm_disk(hc->md);\n\t\t\tnl->dev = huge_encode_dev(disk_devt(disk));\n\t\t\tnl->next = 0;\n\t\t\tstrcpy(nl->name, hc->name);\n\t\t\told_nl = nl;\n\t\t\tevent_nr = align_ptr(nl->name + strlen(hc->name) + 1);\n\t\t\t*event_nr = dm_get_event_nr(hc->md);\n\t\t\tnl = align_ptr(event_nr + 1);\n\t\t}\n\t}\n\tBUG_ON((char *)nl - (char *)orig_nl != needed);\n out:\n\tup_write(&_hash_lock);\n\treturn 0;\n}", "target": 1}
{"code": "Napi::Object Statement::Init(Napi::Env env, Napi::Object exports) {\n    Napi::HandleScope scope(env);\n    Napi::Function t = DefineClass(env, \"Statement\", {\n      InstanceMethod(\"bind\", &Statement::Bind),\n      InstanceMethod(\"get\", &Statement::Get),\n      InstanceMethod(\"run\", &Statement::Run),\n      InstanceMethod(\"all\", &Statement::All),\n      InstanceMethod(\"each\", &Statement::Each),\n      InstanceMethod(\"reset\", &Statement::Reset),\n      InstanceMethod(\"finalize\", &Statement::Finalize_),\n    });\n    exports.Set(\"Statement\", t);\n    return exports;\n}", "target": 0}
{"code": "static uint jsi_SizeOfArray(Jsi_Interp *interp, Jsi_Obj *obj) {\n    if (!obj || !obj->arr)\n        return 0;\n    return obj->arrCnt;\n}", "target": 0}
{"code": "static inline void openOptimized(sqlite3*& db) {\n  sqlite3_open(\":memory:\", &db);\n  std::string settings;\n  for (const auto& setting : kMemoryDBSettings) {\n    settings += \"PRAGMA \" + setting.first + \"=\" + setting.second + \"; \";\n  }\n  sqlite3_exec(db, settings.c_str(), nullptr, nullptr, nullptr);\n  registerMathExtensions(db);\n#if !defined(FREEBSD)\n  registerStringExtensions(db);\n#endif\n#if !defined(SKIP_CARVER)\n  registerOperationExtensions(db);\n#endif\n  registerFilesystemExtensions(db);\n  registerHashingExtensions(db);\n  registerEncodingExtensions(db);\n  auto rc = sqlite3_set_authorizer(db, &sqliteAuthorizer, nullptr);\n  if (rc != SQLITE_OK) {\n    LOG(ERROR) << \"Failed to set sqlite authorizer: \" << sqlite3_errmsg(db);\n    requestShutdown(rc);\n  }\n}", "target": 0}
{"code": "static ssize_t environ_read(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar *page;\n\tunsigned long src = *ppos;\n\tint ret = 0;\n\tstruct mm_struct *mm = file->private_data;\n\tunsigned long env_start, env_end;\n\tif (!mm)\n\t\treturn 0;\n\tpage = (char *)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tret = 0;\n\tif (!atomic_inc_not_zero(&mm->mm_users))\n\t\tgoto free;\n\tdown_read(&mm->mmap_sem);\n\tenv_start = mm->env_start;\n\tenv_end = mm->env_end;\n\tup_read(&mm->mmap_sem);\n\twhile (count > 0) {\n\t\tsize_t this_len, max_len;\n\t\tint retval;\n\t\tif (src >= (env_end - env_start))\n\t\t\tbreak;\n\t\tthis_len = env_end - (env_start + src);\n\t\tmax_len = min_t(size_t, PAGE_SIZE, count);\n\t\tthis_len = min(max_len, this_len);\n\t\tretval = access_remote_vm(mm, (env_start + src),\n\t\t\tpage, this_len, 0);\n\t\tif (retval <= 0) {\n\t\t\tret = retval;\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_to_user(buf, page, retval)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tret += retval;\n\t\tsrc += retval;\n\t\tbuf += retval;\n\t\tcount -= retval;\n\t}\n\t*ppos = src;\n\tmmput(mm);\nfree:\n\tfree_page((unsigned long) page);\n\treturn ret;\n}", "target": 1}
{"code": "static void mdbEvalSetColumnJSON(MyDbEvalContext *p, int iCol, Jsi_DString *dStr) {\n    Jsi_Interp *interp = p->jdb->interp;\n    char nbuf[200];\n    MysqlPrep *prep = p->prep;\n    SqlFieldResults *field = prep->fieldResult+iCol;\n    if (field->isnull) {\n        Jsi_DSAppend(dStr, \"null\", NULL);\n        return;\n    }\n    const char *zBlob = \"\";\n    int bytes = 0;\n    switch(field->jsiTypeMap) {\n        case JSI_OPTION_BOOL: {\n            snprintf(nbuf, sizeof(nbuf), \"%s\", field->buffer.vchar?\"true\":\"false\");\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        case JSI_OPTION_INT64: {\n            snprintf(nbuf, sizeof(nbuf), \"%lld\", field->buffer.vlonglong);\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        case JSI_OPTION_DOUBLE: {\n            Jsi_NumberToString(interp, field->buffer.vdouble, nbuf, sizeof(nbuf));\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        case JSI_OPTION_TIME_D:\n        case JSI_OPTION_TIME_W: {\n            Jsi_Number jtime = mdbMyTimeToJS(&field->buffer.timestamp);\n            Jsi_NumberToString(interp, jtime, nbuf, sizeof(nbuf));\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        case JSI_OPTION_STRING:\n            zBlob = field->buffer.vstring;\n        default:\n        {\n            if( !zBlob ) {\n                Jsi_DSAppend(dStr, \"null\", NULL);\n                return;\n            }\n            Jsi_JSONQuote(interp, zBlob, bytes, dStr);\n            return;\n        }\n    }\n}", "target": 1}
{"code": "static int __init ipgre_init(void)\n{\n\tint err;\n\tprintk(KERN_INFO \"GRE over IPv4 tunneling driver\\n\");\n\tif (inet_add_protocol(&ipgre_protocol, IPPROTO_GRE) < 0) {\n\t\tprintk(KERN_INFO \"ipgre init: can't add protocol\\n\");\n\t\treturn -EAGAIN;\n\t}\n\terr = register_pernet_device(&ipgre_net_ops);\n\tif (err < 0)\n\t\tgoto gen_device_failed;\n\terr = rtnl_link_register(&ipgre_link_ops);\n\tif (err < 0)\n\t\tgoto rtnl_link_failed;\n\terr = rtnl_link_register(&ipgre_tap_ops);\n\tif (err < 0)\n\t\tgoto tap_ops_failed;\nout:\n\treturn err;\ntap_ops_failed:\n\trtnl_link_unregister(&ipgre_link_ops);\nrtnl_link_failed:\n\tunregister_pernet_device(&ipgre_net_ops);\ngen_device_failed:\n\tinet_del_protocol(&ipgre_protocol, IPPROTO_GRE);\n\tgoto out;\n}", "target": 1}
{"code": "static noinline void key_gc_unused_keys(struct list_head *keys)\n{\n\twhile (!list_empty(keys)) {\n\t\tstruct key *key =\n\t\t\tlist_entry(keys->next, struct key, graveyard_link);\n\t\tlist_del(&key->graveyard_link);\n\t\tkdebug(\"- %u\", key->serial);\n\t\tkey_check(key);\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&\n\t\t    !test_bit(KEY_FLAG_NEGATIVE, &key->flags) &&\n\t\t    key->type->destroy)\n\t\t\tkey->type->destroy(key);\n\t\tsecurity_key_free(key);\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\t\tatomic_dec(&key->user->nkeys);\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))\n\t\t\tatomic_dec(&key->user->nikeys);\n\t\tkey_user_put(key->user);\n\t\tkfree(key->description);\n\t\tmemzero_explicit(key, sizeof(*key));\n\t\tkmem_cache_free(key_jar, key);\n\t}\n}", "target": 1}
{"code": "int input_set_keycode(struct input_dev *dev,\n\t\t      const struct input_keymap_entry *ke)\n{\n\tunsigned long flags;\n\tunsigned int old_keycode;\n\tint retval;\n\tif (ke->keycode > KEY_MAX)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\tretval = dev->setkeycode(dev, ke, &old_keycode);\n\tif (retval)\n\t\tgoto out;\n\t__clear_bit(KEY_RESERVED, dev->keybit);\n\tif (test_bit(EV_KEY, dev->evbit) &&\n\t    !is_event_supported(old_keycode, dev->keybit, KEY_MAX) &&\n\t    __test_and_clear_bit(old_keycode, dev->key)) {\n\t\tstruct input_value vals[] =  {\n\t\t\t{ EV_KEY, old_keycode, 0 },\n\t\t\tinput_value_sync\n\t\t};\n\t\tinput_pass_values(dev, vals, ARRAY_SIZE(vals));\n\t}\n out:\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\treturn retval;\n}", "target": 1}
{"code": "void set_fat(DOS_FS * fs, uint32_t cluster, int32_t new)\n{\n    unsigned char *data = NULL;\n    int size;\n    loff_t offs;\n    if (new == -1)\n\tnew = FAT_EOF(fs);\n    else if ((long)new == -2)\n\tnew = FAT_BAD(fs);\n    switch (fs->fat_bits) {\n    case 12:\n\tdata = fs->fat + cluster * 3 / 2;\n\toffs = fs->fat_start + cluster * 3 / 2;\n\tif (cluster & 1) {\n\t    FAT_ENTRY prevEntry;\n\t    get_fat(&prevEntry, fs->fat, cluster - 1, fs);\n\t    data[0] = ((new & 0xf) << 4) | (prevEntry.value >> 8);\n\t    data[1] = new >> 4;\n\t} else {\n\t    FAT_ENTRY subseqEntry;\n\t    if (cluster != fs->clusters - 1)\n\t\tget_fat(&subseqEntry, fs->fat, cluster + 1, fs);\n\t    else\n\t\tsubseqEntry.value = 0;\n\t    data[0] = new & 0xff;\n\t    data[1] = (new >> 8) | ((0xff & subseqEntry.value) << 4);\n\t}\n\tsize = 2;\n\tbreak;\n    case 16:\n\tdata = fs->fat + cluster * 2;\n\toffs = fs->fat_start + cluster * 2;\n\t*(unsigned short *)data = htole16(new);\n\tsize = 2;\n\tbreak;\n    case 32:\n\t{\n\t    FAT_ENTRY curEntry;\n\t    get_fat(&curEntry, fs->fat, cluster, fs);\n\t    data = fs->fat + cluster * 4;\n\t    offs = fs->fat_start + cluster * 4;\n\t    *(uint32_t *)data = htole32((new & 0xfffffff) |\n\t\t\t\t\t     (curEntry.reserved << 28));\n\t    size = 4;\n\t}\n\tbreak;\n    default:\n\tdie(\"Bad FAT entry size: %d bits.\", fs->fat_bits);\n    }\n    fs_write(offs, size, data);\n    if (fs->nfats > 1) {\n\tfs_write(offs + fs->fat_size, size, data);\n    }\n}", "target": 1}
{"code": "AUpvlist _af_pv_pointer (void *val)\n{\n\tAUpvlist\tret = AUpvnew(1);\n\tAUpvsetparam(ret, 0, 0);\n\tAUpvsetvaltype(ret, 0, AU_PVTYPE_PTR);\n\tAUpvsetval(ret, 0, &val);\n\treturn ret;\n}", "target": 0}
{"code": "static const ut8 *parse_die(const ut8 *buf, const ut8 *buf_end, RBinDwarfAbbrevDecl *abbrev,\n\t\tRBinDwarfCompUnitHdr *hdr, RBinDwarfDie *die, const ut8 *debug_str, size_t debug_str_len, Sdb *sdb) {\n\tsize_t i;\n\tfor (i = 0; i < abbrev->count - 1; i++) {\n\t\tmemset (&die->attr_values[i], 0, sizeof (die->attr_values[i]));\n\t\tbuf = parse_attr_value (buf, buf_end - buf, &abbrev->defs[i],\n\t\t\t&die->attr_values[i], hdr, debug_str, debug_str_len);\n\t\tRBinDwarfAttrValue *attribute = &die->attr_values[i];\n\t\tbool is_valid_string_form = (attribute->attr_form == DW_FORM_strp ||\n\t\t\tattribute->attr_form == DW_FORM_string) &&\n\t\t\tattribute->string.content;\n\t\tif (attribute->attr_name == DW_AT_comp_dir && is_valid_string_form) {\n\t\t\tconst char *name = attribute->string.content;\n\t\t\tsdb_set (sdb, \"DW_AT_comp_dir\", name, 0);\n\t\t}\n\t\tdie->count++;\n\t}\n\treturn buf;\n}", "target": 1}
{"code": "char* _single_string_alloc_and_copy( LPCWSTR in )\n{\n    char *chr;\n    int len = 0;\n    if ( !in )\n    {\n        return in;\n    }\n    while ( in[ len ] != 0 )\n    {\n        len ++;\n    }\n    chr = malloc( len + 1 );\n    len = 0;\n    while ( in[ len ] != 0 )\n    {\n        chr[ len ] = 0xFF & in[ len ];\n        len ++;\n    }\n    chr[ len ++ ] = '\\0';\n    return chr;\n}", "target": 1}
{"code": "int rm_rf_children(\n                int fd,\n                RemoveFlags flags,\n                const struct stat *root_dev) {\n        _cleanup_closedir_ DIR *d = NULL;\n        int ret = 0, r;\n        assert(fd >= 0);\n        d = fdopendir(fd);\n        if (!d) {\n                safe_close(fd);\n                return -errno;\n        }\n        if (!(flags & REMOVE_PHYSICAL)) {\n                struct statfs sfs;\n                if (fstatfs(dirfd(d), &sfs) < 0)\n                        return -errno;\n                if (is_physical_fs(&sfs)) {\n                        _cleanup_free_ char *path = NULL;\n                        (void) fd_get_path(fd, &path);\n                        return log_error_errno(SYNTHETIC_ERRNO(EPERM),\n                                               \"Attempted to remove disk file system under \\\"%s\\\", and we can't allow that.\",\n                                               strna(path));\n                }\n        }\n        FOREACH_DIRENT_ALL(de, d, return -errno) {\n                int is_dir;\n                if (dot_or_dot_dot(de->d_name))\n                        continue;\n                is_dir =\n                        de->d_type == DT_UNKNOWN ? -1 :\n                        de->d_type == DT_DIR;\n                r = rm_rf_children_inner(dirfd(d), de->d_name, is_dir, flags, root_dev);\n                if (r < 0 && r != -ENOENT && ret == 0)\n                        ret = r;\n        }\n        if (FLAGS_SET(flags, REMOVE_SYNCFS) && syncfs(dirfd(d)) < 0 && ret >= 0)\n                ret = -errno;\n        return ret;\n}", "target": 1}
{"code": "char *M_fs_path_tmpdir(M_fs_system_t sys_type)\n{\n\tchar         *d   = NULL;\n\tchar         *out = NULL;\n\tM_fs_error_t  res;\n#ifdef _WIN32\n\tsize_t len = M_fs_path_get_path_max(M_FS_SYSTEM_WINDOWS)+1;\n\td = M_malloc_zero(len);\n\tif (GetTempPath((DWORD)len, d) >= len) {\n\t\tM_free(d);\n\t\td = NULL;\n\t}\n#elif defined(__APPLE__)\n\td = M_fs_path_mac_tmpdir();\n#else\n\tconst char *const_temp;\n#  ifdef HAVE_SECURE_GETENV\n\tconst_temp = secure_getenv(\"TMPDIR\");\n#  else\n\tconst_temp = getenv(\"TMPDIR\");\n#  endif\n\tif (!M_str_isempty(const_temp) && M_fs_perms_can_access(const_temp, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_WRITE) == M_FS_ERROR_SUCCESS) {\n\t\td = M_strdup(const_temp);\n\t}\n\tif (d == NULL) {\n\t\tconst_temp = \"/tmp\";\n\t\tif (!M_str_isempty(const_temp) && M_fs_perms_can_access(const_temp, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_WRITE) == M_FS_ERROR_SUCCESS) {\n\t\t\td = M_strdup(const_temp);\n\t\t}\n\t}\n\tif (d == NULL) {\n\t\tconst_temp = \"/var/tmp\";\n\t\tif (!M_str_isempty(const_temp) && M_fs_perms_can_access(const_temp, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_WRITE) == M_FS_ERROR_SUCCESS) {\n\t\t\td = M_strdup(const_temp);\n\t\t}\n\t}\n#endif\n\tif (d != NULL) {\n\t\tres = M_fs_path_norm(&out, d, M_FS_PATH_NORM_ABSOLUTE, sys_type);\n\t\tif (res != M_FS_ERROR_SUCCESS) {\n\t\t\tout = NULL;\n\t\t}\n\t}\n\tM_free(d);\n\treturn out;\n}", "target": 1}
{"code": "static void server_real_connect(SERVER_REC *server, IPADDR *ip,\n\t\t\t\tconst char *unix_socket)\n{\n\tGIOChannel *handle;\n\tIPADDR *own_ip = NULL;\n\tconst char *errmsg;\n\tchar *errmsg2;\n\tchar ipaddr[MAX_IP_LEN];\n        int port;\n\tg_return_if_fail(ip != NULL || unix_socket != NULL);\n\tsignal_emit(\"server connecting\", 2, server, ip);\n\tif (server->connrec->no_connect)\n\t\treturn;\n\tif (ip != NULL) {\n\t\town_ip = ip == NULL ? NULL :\n\t\t\t(IPADDR_IS_V6(ip) ? server->connrec->own_ip6 :\n\t\t\t server->connrec->own_ip4);\n\t\tport = server->connrec->proxy != NULL ?\n\t\t\tserver->connrec->proxy_port : server->connrec->port;\n\t\thandle = server->connrec->use_ssl ?\n\t\t\tnet_connect_ip_ssl(ip, port, own_ip, server->connrec->ssl_cert, server->connrec->ssl_pkey,\nserver->connrec->ssl_cafile, server->connrec->ssl_capath, server->connrec->ssl_verify) :\n\t\t\tnet_connect_ip(ip, port, own_ip);\n\t} else {\n\t\thandle = net_connect_unix(unix_socket);\n\t}\n\tif (handle == NULL) {\n\t\terrmsg = g_strerror(errno);\n\t\terrmsg2 = NULL;\n\t\tif (errno == EADDRNOTAVAIL) {\n\t\t\tif (own_ip != NULL) {\n\t\t\t\tnet_ip2host(own_ip, ipaddr);\n\t\t\t\terrmsg2 = g_strconcat(errmsg, \": \", ipaddr, NULL);\n\t\t\t}\n\t\t\tserver->no_reconnect = TRUE;\n\t\t}\n\t\tif (server->connrec->use_ssl && errno == ENOSYS)\n\t\t\tserver->no_reconnect = TRUE;\n\t\tserver->connection_lost = TRUE;\n\t\tserver_connect_failed(server, errmsg2 ? errmsg2 : errmsg);\n\t\tg_free(errmsg2);\n\t} else {\n\t\tserver->handle = net_sendbuffer_create(handle, 0);\n#ifdef HAVE_OPENSSL\n\t\tif (server->connrec->use_ssl)\n\t\t\tserver_connect_callback_init_ssl(server, handle);\n\t\telse\n#endif\n\t\tserver->connect_tag =\n\t\t\tg_input_add(handle, G_INPUT_WRITE | G_INPUT_READ,\n\t\t\t\t    (GInputFunction)\n\t\t\t\t    server_connect_callback_init,\n\t\t\t\t    server);\n\t}\n}", "target": 1}
{"code": "Jsi_RC Jsi_RegExpMatch(Jsi_Interp *interp, Jsi_Value *pattern, const char *v, int *rc, Jsi_DString *dStr)\n{\n    Jsi_Regex *re;\n    int regexec_flags = 0;\n    if (rc)\n        *rc = 0;\n    if (pattern == NULL || pattern->vt != JSI_VT_OBJECT || pattern->d.obj->ot != JSI_OT_REGEXP) \n        return Jsi_LogError(\"expected pattern\");\n    re = pattern->d.obj->d.robj;\n    regex_t *reg = &re->reg;\n    regmatch_t pos = {};\n    if (dStr)\n        Jsi_DSInit(dStr);\n    int r  = regexec(reg, v, 1, &pos, regexec_flags);\n    if (r >= REG_BADPAT) {\n        char buf[100];\n        regerror(r, reg, buf, sizeof(buf));\n        return Jsi_LogError(\"error while matching pattern: %s\", buf);\n    }\n    if (r != REG_NOMATCH) {\n        if (rc) *rc = 1;\n        if (dStr && pos.rm_so >= 0 && pos.rm_eo >= 0 &&  pos.rm_eo >= pos.rm_so)\n            Jsi_DSAppendLen(dStr, v + pos.rm_so, pos.rm_eo - pos.rm_so);\n    }\n    return JSI_OK;\n}", "target": 1}
{"code": "x509stack_pop(struct cert_stack *stack)\n{\n\tX509 *cert;\n\tstruct metadata_node *meta;\n\tstruct repo_level_node *repo;\n\tcert = sk_X509_pop(stack->x509s);\n\tif (cert == NULL)\n\t\tpr_crit(\"Attempted to pop empty X509 stack\");\n\tX509_free(cert);\n\tmeta = SLIST_FIRST(&stack->metas);\n\tif (meta == NULL)\n\t\tpr_crit(\"Attempted to pop empty metadata stack\");\n\tSLIST_REMOVE_HEAD(&stack->metas, next);\n\tmeta_destroy(meta);\n\trepo = SLIST_FIRST(&stack->levels);\n\tif (repo == NULL)\n\t\tpr_crit(\"Attempted to pop empty repo level stack\");\n\tSLIST_REMOVE_HEAD(&stack->levels, next);\n\tfree(repo);\n}", "target": 1}
{"code": "void test_rename(const char *path)\n{\n\tchar *d = strdupa(path), *tmpname;\n\td = dirname(d);\n\tsize_t len = strlen(path) + 30;\n\ttmpname = alloca(len);\n\tsnprintf(tmpname, len, \"%s/%d\", d, (int)getpid());\n\tif (rename(path, tmpname) == 0 || errno != ENOENT) {\n\t\tfprintf(stderr, \"leak at rename of %s\\n\", path);\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "static int open_port(struct inode *inode, struct file *filp)\n{\n\treturn capable(CAP_SYS_RAWIO) ? 0 : -EPERM;\n}", "target": 0}
{"code": "static void mark_key_instantiated(struct key *key, int reject_error)\n{\n\tsmp_store_release(&key->state,\n\t\t\t  (reject_error < 0) ? reject_error : KEY_IS_POSITIVE);\n}", "target": 0}
{"code": "static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)\n{\n\tstruct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;\n\tstruct tipc_aead_key *skey = NULL;\n\tu16 key_gen = msg_key_gen(hdr);\n\tu16 size = msg_data_sz(hdr);\n\tu8 *data = msg_data(hdr);\n\tspin_lock(&rx->lock);\n\tif (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {\n\t\tpr_err(\"%s: key existed <%p>, gen %d vs %d\\n\", rx->name,\n\t\t       rx->skey, key_gen, rx->key_gen);\n\t\tgoto exit;\n\t}\n\tskey = kmalloc(size, GFP_ATOMIC);\n\tif (unlikely(!skey)) {\n\t\tpr_err(\"%s: unable to allocate memory for skey\\n\", rx->name);\n\t\tgoto exit;\n\t}\n\tskey->keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));\n\tmemcpy(skey->alg_name, data, TIPC_AEAD_ALG_NAME);\n\tmemcpy(skey->key, data + TIPC_AEAD_ALG_NAME + sizeof(__be32),\n\t       skey->keylen);\n\tif (unlikely(size != tipc_aead_key_size(skey))) {\n\t\tkfree(skey);\n\t\tskey = NULL;\n\t\tgoto exit;\n\t}\n\trx->key_gen = key_gen;\n\trx->skey_mode = msg_key_mode(hdr);\n\trx->skey = skey;\n\trx->nokey = 0;\n\tmb(); \nexit:\n\tspin_unlock(&rx->lock);\n\tif (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))\n\t\treturn true;\n\treturn false;\n}", "target": 1}
{"code": "search_make_new(const struct search_state *const state, int n, const char *const base_name) {\n\tconst size_t base_len = strlen(base_name);\n\tconst char need_to_append_dot = base_name[base_len - 1] == '.' ? 0 : 1;\n\tstruct search_domain *dom;\n\tfor (dom = state->head; dom; dom = dom->next) {\n\t\tif (!n--) {\n\t\t\tconst u8 *const postfix = ((u8 *) dom) + sizeof(struct search_domain);\n\t\t\tconst int postfix_len = dom->len;\n\t\t\tchar *const newname = (char *) mm_malloc(base_len + need_to_append_dot + postfix_len + 1);\n\t\t\tif (!newname) return NULL;\n\t\t\tmemcpy(newname, base_name, base_len);\n\t\t\tif (need_to_append_dot) newname[base_len] = '.';\n\t\t\tmemcpy(newname + base_len + need_to_append_dot, postfix, postfix_len);\n\t\t\tnewname[base_len + need_to_append_dot + postfix_len] = 0;\n\t\t\treturn newname;\n\t\t}\n\t}\n\tEVUTIL_ASSERT(0);\n\treturn NULL; \n}", "target": 1}
{"code": "static int check_symlink(int fd)\n{\n\tstruct stat sb;\n\tint ret = fstat(fd, &sb);\n\tif (ret < 0)\n\t\treturn -ENOENT;\n\tif (S_ISLNK(sb.st_mode))\n\t\treturn -ELOOP;\n\treturn 0;\n}", "target": 0}
{"code": "static void process_constructors (RBinFile *bf, RList *ret, int bits) {\n\tRList *secs = sections (bf);\n\tRListIter *iter;\n\tRBinSection *sec;\n\tint i, type;\n\tr_list_foreach (secs, iter, sec) {\n\t\ttype = -1;\n\t\tif (!strcmp (sec->name, \".fini_array\")) {\n\t\t\ttype = R_BIN_ENTRY_TYPE_FINI;\n\t\t} else if (!strcmp (sec->name, \".init_array\")) {\n\t\t\ttype = R_BIN_ENTRY_TYPE_INIT;\n\t\t} else if (!strcmp (sec->name, \".preinit_array\")) {\n\t\t\ttype = R_BIN_ENTRY_TYPE_PREINIT;\n\t\t}\n\t\tif (type != -1) {\n\t\t\tut8 *buf = calloc (sec->size, 1);\n\t\t\tif (!buf) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t(void)r_buf_read_at (bf->buf, sec->paddr, buf, sec->size);\n\t\t\tif (bits == 32) {\n\t\t\t\tfor (i = 0; i < sec->size; i += 4) {\n\t\t\t\t\tut32 addr32 = r_read_le32 (buf + i);\n\t\t\t\t\tif (addr32) {\n\t\t\t\t\t\tRBinAddr *ba = newEntry (sec->paddr + i, (ut64)addr32, type, bits);\n\t\t\t\t\t\tr_list_append (ret, ba);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (i = 0; i < sec->size; i += 8) {\n\t\t\t\t\tut64 addr64 = r_read_le64 (buf + i);\n\t\t\t\t\tif (addr64) {\n\t\t\t\t\t\tRBinAddr *ba = newEntry (sec->paddr + i, addr64, type, bits);\n\t\t\t\t\t\tr_list_append (ret, ba);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree (buf);\n\t\t}\n\t}\n\tr_list_free (secs);\n}", "target": 1}
{"code": "int StreamInfoWrapper::luaDynamicMetadata(lua_State* state) {\n  if (dynamic_metadata_wrapper_.get() != nullptr) {\n    dynamic_metadata_wrapper_.pushStack();\n  } else {\n    dynamic_metadata_wrapper_.reset(DynamicMetadataMapWrapper::create(state, *this), true);\n  }\n  return 1;\n}", "target": 0}
{"code": "static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {\n\tRDyldCache *cache = R_NEW0 (RDyldCache);\n\tmemcpy (cache->magic, \"dyldcac\", 7);\n\tcache->buf = r_buf_ref (buf);\n\tpopulate_cache_headers (cache);\n\tif (!cache->hdr) {\n\t\tr_dyldcache_free (cache);\n\t\treturn false;\n\t}\n\tpopulate_cache_maps (cache);\n\tif (!cache->maps) {\n\t\tr_dyldcache_free (cache);\n\t\treturn false;\n\t}\n\tcache->accel = read_cache_accel (cache->buf, cache->hdr, cache->maps);\n\tcache->bins = create_cache_bins (bf, cache);\n\tif (!cache->bins) {\n\t\tr_dyldcache_free (cache);\n\t\treturn false;\n\t}\n\tcache->locsym = r_dyld_locsym_new (cache);\n\tcache->rebase_infos = get_rebase_infos (bf, cache);\n\tif (cache->rebase_infos) {\n\t\tif (!rebase_infos_get_slide (cache)) {\n\t\t\tif (!pending_bin_files) {\n\t\t\t\tpending_bin_files = r_list_new ();\n\t\t\t\tif (!pending_bin_files) {\n\t\t\t\t\tr_dyldcache_free (cache);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_list_push (pending_bin_files, bf);\n\t\t\tswizzle_io_read (cache, bf->rbin->iob.io);\n\t\t}\n\t}\n\t*bin_obj = cache;\n\treturn true;\n}", "target": 1}
{"code": "tegra_xusb_find_port_node(struct tegra_xusb_padctl *padctl, const char *type,\n\t\t\t  unsigned int index)\n{\n\tstruct device_node *ports, *np;\n\tchar *name;\n\tports = of_get_child_by_name(padctl->dev->of_node, \"ports\");\n\tif (!ports)\n\t\treturn NULL;\n\tname = kasprintf(GFP_KERNEL, \"%s-%u\", type, index);\n\tif (!name) {\n\t\tof_node_put(ports);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tnp = of_get_child_by_name(ports, name);\n\tkfree(name);\n\tof_node_put(ports);\n\treturn np;\n}", "target": 1}
{"code": "static void jsiDumpInstr(Jsi_Interp *interp, jsi_Pstate *ps, Jsi_Value *_this,\n    jsi_TryList *trylist, jsi_OpCode *ip, Jsi_OpCodes *opcodes)\n{\n    int i;\n    char buf[200];\n    jsi_code_decode(interp, ip, ip - opcodes->codes, buf, sizeof(buf));\n    Jsi_Printf(interp, jsi_Stderr, \"%p: %-30.200s : THIS=%s, STACK=[\", ip, buf, jsi_evalprint(_this));\n    for (i = 0; i < interp->framePtr->Sp; ++i) {\n        Jsi_Printf(interp, jsi_Stderr, \"%s%s\", (i>0?\", \":\"\"), jsi_evalprint(_jsi_STACKIDX(i)));\n    }\n    Jsi_Printf(interp, jsi_Stderr, \"]\");\n    if (ip->fname) {\n        const char *fn = ip->fname,  *cp = Jsi_Strrchr(fn, '/');\n        if (cp) fn = cp+1;\n        Jsi_Printf(interp, jsi_Stderr, \", %s:%d\", fn, ip->Line);\n    }\n    Jsi_Printf(interp, jsi_Stderr, \"\\n\");\n    jsi_TryList *tlt = trylist;\n    for (i = 0; tlt; tlt = tlt->next) i++;\n    if (ps->last_exception)\n        Jsi_Printf(interp, jsi_Stderr, \"TL: %d, excpt: %s\\n\", i, jsi_evalprint(ps->last_exception));\n}", "target": 1}
{"code": "opfunc_construct (vm_frame_ctx_t *frame_ctx_p) \n{\n  const uint8_t *byte_code_p = frame_ctx_p->byte_code_p + 1;\n  uint8_t opcode = byte_code_p[-1];\n  unsigned int arguments_list_len;\n  if (opcode >= CBC_NEW0)\n  {\n    arguments_list_len = (unsigned int) (opcode - CBC_NEW0);\n  }\n  else\n  {\n    arguments_list_len = *byte_code_p++;\n  }\n  ecma_value_t *stack_top_p = frame_ctx_p->stack_top_p - arguments_list_len;\n  ecma_value_t constructor_value = stack_top_p[-1];\n  ecma_value_t completion_value;\n  const char *constructor_message_p = ecma_check_constructor (constructor_value);\n  if (constructor_message_p != ECMA_IS_VALID_CONSTRUCTOR)\n  {\n    completion_value = ecma_raise_type_error (constructor_message_p);\n  }\n  else\n  {\n    ecma_object_t *constructor_obj_p = ecma_get_object_from_value (constructor_value);\n    completion_value = ecma_op_function_construct (constructor_obj_p,\n                                                   constructor_obj_p,\n                                                   stack_top_p,\n                                                   arguments_list_len);\n  }\n  for (uint32_t i = 0; i < arguments_list_len; i++)\n  {\n    ecma_fast_free_value (stack_top_p[i]);\n  }\n  if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (completion_value)))\n  {\n#if JERRY_DEBUGGER\n    JERRY_CONTEXT (debugger_exception_byte_code_p) = frame_ctx_p->byte_code_p;\n#endif \n    frame_ctx_p->byte_code_p = (uint8_t *) vm_error_byte_code_p;\n  }\n  else\n  {\n    ecma_free_value (stack_top_p[-1]);\n    frame_ctx_p->byte_code_p = byte_code_p;\n    stack_top_p[-1] = completion_value;\n  }\n  frame_ctx_p->stack_top_p = stack_top_p;\n} ", "target": 0}
{"code": "void CleanupOutput(char *str)\n{\n    char *s, *t;\n    int period = 0;\n    s = t = str;\n    while ( *s && *s != '}' ) {\n        if ( *s == '\\n' ) *s = ' ';\n        if ( ( *s == ' ' || *s == '\\n' ) && ( s[1] == ' ' || s[1] == '\\n' ) ) s++;\n        else *t++ = *s++;\n    }\n    while ( *s ) *t++ = *s++;\n    *t = 0;\n    s = t = str;\n    while ( *s ) {\n        if ( *s == '.' ) { period = 1; *t++ = *s++; }\n        else if ( *s == '-' && s[1] == '0' && s[2] == ' ' ) { s++; }\n        else if ( *s <= '9' && *s >= '0' ) { *t++ = *s++; }\n        else if ( *s == '\\n' && ( t > str && t[-1] == '\\n' ) ) { s++; }\n        else if ( period ) {\n            while ( t > str && t[-1] == '0' ) t--;\n            if ( t > str && t[-1] == '.' ) t--;\n            while ( *s == ' ' && s[1] == ' ' ) s++;\n            period = 0; *t++ = *s++;\n        }\n        else if ( *s == ' ' && s[1] == ' ' ) s++;\n        else {\n            period = 0; *t++ = *s++;\n        }\n    }\n    *t = 0;\n    s = t = str;\n    while ( *s ) {\n        if ( *s == '-' && s[1] == '0' && s[2] == ' ' ) { s++; }\n        else *t++ = *s++;\n    }\n    *t = 0;\n}", "target": 1}
{"code": "static int adpt_bios_param(struct scsi_device *sdev, struct block_device *dev,\n\t\tsector_t capacity, int geom[])\n{\n\tint heads=-1;\n\tint sectors=-1;\n\tint cylinders=-1;\n\tif (capacity < 0x2000 ) {\t\n\t\theads = 18;\n\t\tsectors = 2;\n\t} \n\telse if (capacity < 0x20000) {\n\t\theads = 64;\n\t\tsectors = 32;\n\t}\n\telse if (capacity < 0x40000) {\n\t\theads = 65;\n\t\tsectors = 63;\n\t}\n\telse if (capacity < 0x80000) {\n\t\theads = 128;\n\t\tsectors = 63;\n\t}\n\telse {\n\t\theads = 255;\n\t\tsectors = 63;\n\t}\n\tcylinders = sector_div(capacity, heads * sectors);\n\tif(sdev->type == 5) {  \n\t\theads = 252;\n\t\tsectors = 63;\n\t\tcylinders = 1111;\n\t}\n\tgeom[0] = heads;\n\tgeom[1] = sectors;\n\tgeom[2] = cylinders;\n\tPDEBUG(\"adpt_bios_param: exit\\n\");\n\treturn 0;\n}", "target": 1}
{"code": "MONGO_EXPORT gridfs_offset gridfile_read( gridfile *gfile, gridfs_offset size, char *buf ) {\n    mongo_cursor *chunks;\n    bson chunk;\n    int first_chunk;\n    int last_chunk;\n    int total_chunks;\n    gridfs_offset chunksize;\n    gridfs_offset contentlength;\n    gridfs_offset bytes_left;\n    int i;\n    bson_iterator it;\n    gridfs_offset chunk_len;\n    const char *chunk_data;\n    contentlength = gridfile_get_contentlength( gfile );\n    chunksize = gridfile_get_chunksize( gfile );\n    size = ( contentlength - gfile->pos < size )\n           ? contentlength - gfile->pos\n           : size;\n    bytes_left = size;\n    first_chunk = ( gfile->pos )/chunksize;\n    last_chunk = ( gfile->pos+size-1 )/chunksize;\n    total_chunks = last_chunk - first_chunk + 1;\n    chunks = gridfile_get_chunks( gfile, first_chunk, total_chunks );\n    for ( i = 0; i < total_chunks; i++ ) {\n        mongo_cursor_next( chunks );\n        chunk = chunks->current;\n        bson_find( &it, &chunk, \"data\" );\n        chunk_len = bson_iterator_bin_len( &it );\n        chunk_data = bson_iterator_bin_data( &it );\n        if ( i == 0 ) {\n            chunk_data += ( gfile->pos )%chunksize;\n            chunk_len -= ( gfile->pos )%chunksize;\n        }\n        if ( bytes_left > chunk_len ) {\n            memcpy( buf, chunk_data, chunk_len );\n            bytes_left -= chunk_len;\n            buf += chunk_len;\n        }\n        else {\n            memcpy( buf, chunk_data, bytes_left );\n        }\n    }\n    mongo_cursor_destroy( chunks );\n    gfile->pos = gfile->pos + size;\n    return size;\n}", "target": 1}
{"code": "int qemu_ram_resize(ram_addr_t base, ram_addr_t newsize, Error **errp)\n{\n    RAMBlock *block = find_ram_block(base);\n    assert(block);\n    newsize = TARGET_PAGE_ALIGN(newsize);\n    if (block->used_length == newsize) {\n        return 0;\n    }\n    if (!(block->flags & RAM_RESIZEABLE)) {\n        error_setg_errno(errp, EINVAL,\n                         \"Length mismatch: %s: 0x\" RAM_ADDR_FMT\n                         \" in != 0x\" RAM_ADDR_FMT, block->idstr,\n                         newsize, block->used_length);\n        return -EINVAL;\n    }\n    if (block->max_length < newsize) {\n        error_setg_errno(errp, EINVAL,\n                         \"Length too large: %s: 0x\" RAM_ADDR_FMT\n                         \" > 0x\" RAM_ADDR_FMT, block->idstr,\n                         newsize, block->max_length);\n        return -EINVAL;\n    }\n    cpu_physical_memory_clear_dirty_range(block->offset, block->used_length);\n    block->used_length = newsize;\n    cpu_physical_memory_set_dirty_range(block->offset, block->used_length,\n                                        DIRTY_CLIENTS_ALL);\n    memory_region_set_size(block->mr, newsize);\n    if (block->resized) {\n        block->resized(block->idstr, newsize, block->host);\n    }\n    return 0;\n}", "target": 0}
{"code": "int main(int argc, char **argv)\n{\n    gdImagePtr im;\n    FILE *fp = gdTestFileOpen(\"tga/bug00247a.tga\");\n    im = gdImageCreateFromTga(fp);\n    gdTestAssert(im == NULL);\n    fclose(fp);\n    return gdNumFailures();\n}", "target": 0}
{"code": "static unsigned int UTFCharLength(uint8 lead)\n{\n  if (lead < 0x80)\n    return 1;\n  else if ((lead >> 5) == 0x6)\n    return 2;\n  else if ((lead >> 4) == 0xe)\n    return 3;\n  else if ((lead >> 3) == 0x1e)\n    return 4;\n  else\n    return 0;\n}", "target": 0}
{"code": "static char* get_private_subtags(const char* loc_name)\n{\n\tchar* \tresult =NULL;\n\tint \tsingletonPos = 0;\n\tint \tlen =0; \n\tconst char* \tmod_loc_name =NULL;\n\tif( loc_name && (len = strlen(loc_name)>0 ) ){\n\t\tmod_loc_name = loc_name ; \n\t\tlen   = strlen(mod_loc_name);\n\t\twhile( (singletonPos = getSingletonPos(mod_loc_name))!= -1){\n\t\t\tif( singletonPos!=-1){ \n\t\t\t\tif( (*(mod_loc_name+singletonPos)=='x') || (*(mod_loc_name+singletonPos)=='X') ){\t\t\n\t\t\t\t\tif( singletonPos + 2 ==  len){\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tresult = estrndup(mod_loc_name + singletonPos+2  , (len -( singletonPos +2) ) );\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif( singletonPos + 1 >=  len){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmod_loc_name = mod_loc_name + singletonPos +1;\n\t\t\t\t\t\tlen = strlen(mod_loc_name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} \n\t}\n\treturn result;\n}", "target": 1}
{"code": "TEST(TensorSliceReaderTest, NegativeTensorShapeDimension) {\n  const string fname =\n      io::JoinPath(testing::TmpDir(), \"negative_dim_checkpoint\");\n  TensorSliceWriter writer(fname, CreateTableTensorSliceBuilder);\n  const int32 data[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n  TF_CHECK_OK(writer.Add(\"test\", TensorShape({4, 5}),\n                         TensorSlice::ParseOrDie(\"0,2:-\"), data));\n  TF_CHECK_OK(writer.Finish());\n  MutateSavedTensorSlices(fname, [](SavedTensorSlices sts) {\n    if (sts.has_meta()) {\n      for (auto& tensor : *sts.mutable_meta()->mutable_tensor()) {\n        for (auto& dim : *tensor.mutable_shape()->mutable_dim()) {\n          dim.set_size(-dim.size());\n        }\n      }\n    }\n    return sts.SerializeAsString();\n  });\n  TensorSliceReader reader(fname, OpenTableTensorSliceReader);\n  EXPECT_FALSE(reader.status().ok());\n}", "target": 0}
{"code": "static void __exit pf_exit(void)\n{\n\tstruct pf_unit *pf;\n\tint unit;\n\tunregister_blkdev(major, name);\n\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n\t\tif (!pf->disk)\n\t\t\tcontinue;\n\t\tif (pf->present)\n\t\t\tdel_gendisk(pf->disk);\n\t\tblk_cleanup_queue(pf->disk->queue);\n\t\tblk_mq_free_tag_set(&pf->tag_set);\n\t\tput_disk(pf->disk);\n\t\tif (pf->present)\n\t\t\tpi_release(pf->pi);\n\t}\n}", "target": 0}
{"code": "static int io_rw_init_file(struct io_kiocb *req, fmode_t mode)\n{\n\tstruct kiocb *kiocb = &req->rw.kiocb;\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct file *file = req->file;\n\tint ret;\n\tif (unlikely(!file || !(file->f_mode & mode)))\n\t\treturn -EBADF;\n\tif (!io_req_ffs_set(req))\n\t\treq->flags |= io_file_get_flags(file) << REQ_F_SUPPORT_NOWAIT_BIT;\n\tkiocb->ki_flags = iocb_flags(file);\n\tret = kiocb_set_rw_flags(kiocb, req->rw.flags);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tif ((kiocb->ki_flags & IOCB_NOWAIT) ||\n\t    ((file->f_flags & O_NONBLOCK) && !io_file_supports_nowait(req)))\n\t\treq->flags |= REQ_F_NOWAIT;\n\tif (ctx->flags & IORING_SETUP_IOPOLL) {\n\t\tif (!(kiocb->ki_flags & IOCB_DIRECT) || !file->f_op->iopoll)\n\t\t\treturn -EOPNOTSUPP;\n\t\tkiocb->private = NULL;\n\t\tkiocb->ki_flags |= IOCB_HIPRI | IOCB_ALLOC_CACHE;\n\t\tkiocb->ki_complete = io_complete_rw_iopoll;\n\t\treq->iopoll_completed = 0;\n\t} else {\n\t\tif (kiocb->ki_flags & IOCB_HIPRI)\n\t\t\treturn -EINVAL;\n\t\tkiocb->ki_complete = io_complete_rw;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "gerb_fclose(gerb_file_t *fd)\n{\n    if (fd) {\n        g_free(fd->filename);\n#ifdef HAVE_SYS_MMAN_H\n\tif (munmap(fd->data, fd->datalen) < 0)\n\t    GERB_FATAL_ERROR(\"munmap: %s\", strerror(errno));\n#else\n\tg_free(fd->data);\n#endif   \n\tif (fclose(fd->fd) == EOF)\n\t    GERB_FATAL_ERROR(\"fclose: %s\", strerror(errno));\n\tg_free(fd);\n    }\n    return;\n} ", "target": 0}
{"code": "int ecall_restore(const char *input, uint64_t input_len, char **output,\n                  uint64_t *output_len) {\n  if (!asylo::primitives::TrustedPrimitives::IsOutsideEnclave(input,\n                                                              input_len) ||\n      !asylo::primitives::TrustedPrimitives::IsOutsideEnclave(\n          output_len, sizeof(uint64_t)) ||\n      !asylo::primitives::TrustedPrimitives::IsOutsideEnclave(output,\n                                                              *output_len)) {\n    asylo::primitives::TrustedPrimitives::BestEffortAbort(\n        \"ecall_restore: input/output found to not be in untrusted memory.\");\n  }\n  int result = 0;\n  size_t tmp_output_len;\n  try {\n    result = asylo::Restore(input, static_cast<size_t>(input_len), output,\n                            &tmp_output_len);\n  } catch (...) {\n    LOG(FATAL) << \"Uncaught exception in enclave\";\n  }\n  if (output_len) {\n    *output_len = static_cast<uint64_t>(tmp_output_len);\n  }\n  return result;\n}", "target": 0}
{"code": "static int expandRegular(rpmfi fi, const char *dest, rpmpsm psm, int nodigest, int nocontent)\n{\n    FD_t wfd = NULL;\n    int rc = 0;\n    {\n\tmode_t old_umask = umask(0577);\n\twfd = Fopen(dest, \"w.ufdio\");\n\tumask(old_umask);\n    }\n    if (Ferror(wfd)) {\n\trc = RPMERR_OPEN_FAILED;\n\tgoto exit;\n    }\n    if (!nocontent)\n\trc = rpmfiArchiveReadToFilePsm(fi, wfd, nodigest, psm);\nexit:\n    if (wfd) {\n\tint myerrno = errno;\n\tFclose(wfd);\n\terrno = myerrno;\n    }\n    return rc;\n}", "target": 1}
{"code": "Status OpLevelCostEstimator::PredictMaxPool(const OpContext& op_context,\n                                            NodeCosts* node_costs) const {\n  bool found_unknown_shapes = false;\n  const auto& op_info = op_context.op_info;\n  ConvolutionDimensions dims = OpDimensionsFromInputs(\n      op_info.inputs(0).shape(), op_info, &found_unknown_shapes);\n  int per_output_ops = dims.kx * dims.ky == 1 ? 1 : dims.kx * dims.ky - 1;\n  int64_t ops = dims.batch * dims.ox * dims.oy * dims.oz * per_output_ops;\n  node_costs->num_compute_ops = ops;\n  int64_t input_size = 0;\n  if (dims.ky >= dims.sy) {\n    input_size = CalculateTensorSize(op_info.inputs(0), &found_unknown_shapes);\n  } else {  \n    const auto data_size = DataTypeSize(BaseType(op_info.inputs(0).dtype()));\n    input_size = data_size * dims.batch * dims.ix * dims.ky * dims.oy * dims.iz;\n  }\n  node_costs->num_input_bytes_accessed = {input_size};\n  const int64_t output_size =\n      CalculateOutputSize(op_info, &found_unknown_shapes);\n  node_costs->num_output_bytes_accessed = {output_size};\n  node_costs->max_memory = output_size;\n  if (found_unknown_shapes) {\n    node_costs->inaccurate = true;\n    node_costs->num_nodes_with_unknown_shapes = 1;\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "  Number_Ptr Parser::lexed_dimension(const ParserState& pstate, const std::string& parsed)\n  {\n    size_t L = parsed.length();\n    size_t num_pos = parsed.find_first_not_of(\" \\n\\r\\t\");\n    if (num_pos == std::string::npos) num_pos = L;\n    size_t unit_pos = parsed.find_first_not_of(\"-+0123456789.\", num_pos);\n    if (parsed[unit_pos] == 'e' && is_number(parsed[unit_pos+1]) ) {\n      unit_pos = parsed.find_first_not_of(\"-+0123456789.\", ++ unit_pos);\n    }\n    if (unit_pos == std::string::npos) unit_pos = L;\n    const std::string& num = parsed.substr(num_pos, unit_pos - num_pos);\n    Number_Ptr nr = SASS_MEMORY_NEW(Number,\n                                    pstate,\n                                    sass_strtod(num.c_str()),\n                                    Token(number(parsed.c_str())),\n                                    number_has_zero(parsed));\n    nr->is_interpolant(false);\n    nr->is_delayed(true);\n    return nr;\n  }", "target": 0}
{"code": "static int load_script(struct linux_binprm *bprm)\n{\n\tconst char *i_arg, *i_name;\n\tchar *cp;\n\tstruct file *file;\n\tchar interp[BINPRM_BUF_SIZE];\n\tint retval;\n\tif ((bprm->buf[0] != '#') || (bprm->buf[1] != '!'))\n\t\treturn -ENOEXEC;\n\tallow_write_access(bprm->file);\n\tfput(bprm->file);\n\tbprm->file = NULL;\n\tbprm->buf[BINPRM_BUF_SIZE - 1] = '\\0';\n\tif ((cp = strchr(bprm->buf, '\\n')) == NULL)\n\t\tcp = bprm->buf+BINPRM_BUF_SIZE-1;\n\t*cp = '\\0';\n\twhile (cp > bprm->buf) {\n\t\tcp--;\n\t\tif ((*cp == ' ') || (*cp == '\\t'))\n\t\t\t*cp = '\\0';\n\t\telse\n\t\t\tbreak;\n\t}\n\tfor (cp = bprm->buf+2; (*cp == ' ') || (*cp == '\\t'); cp++);\n\tif (*cp == '\\0') \n\t\treturn -ENOEXEC; \n\ti_name = cp;\n\ti_arg = NULL;\n\tfor ( ; *cp && (*cp != ' ') && (*cp != '\\t'); cp++)\n\t\t ;\n\twhile ((*cp == ' ') || (*cp == '\\t'))\n\t\t*cp++ = '\\0';\n\tif (*cp)\n\t\ti_arg = cp;\n\tstrcpy (interp, i_name);\n\tretval = remove_arg_zero(bprm);\n\tif (retval)\n\t\treturn retval;\n\tretval = copy_strings_kernel(1, &bprm->interp, bprm);\n\tif (retval < 0) return retval; \n\tbprm->argc++;\n\tif (i_arg) {\n\t\tretval = copy_strings_kernel(1, &i_arg, bprm);\n\t\tif (retval < 0) return retval; \n\t\tbprm->argc++;\n\t}\n\tretval = copy_strings_kernel(1, &i_name, bprm);\n\tif (retval) return retval; \n\tbprm->argc++;\n\tbprm->interp = interp;\n\tfile = open_exec(interp);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\tbprm->file = file;\n\tretval = prepare_binprm(bprm);\n\tif (retval < 0)\n\t\treturn retval;\n\treturn search_binary_handler(bprm);\n}", "target": 1}
{"code": "static int hashtable_do_rehash(hashtable_t *hashtable)\n{\n    list_t *list, *next;\n    pair_t *pair;\n    size_t i, index, new_size;\n    jsonp_free(hashtable->buckets);\n    hashtable->num_buckets++;\n    new_size = num_buckets(hashtable);\n    hashtable->buckets = jsonp_malloc(new_size * sizeof(bucket_t));\n    if(!hashtable->buckets)\n        return -1;\n    for(i = 0; i < num_buckets(hashtable); i++)\n    {\n        hashtable->buckets[i].first = hashtable->buckets[i].last =\n            &hashtable->list;\n    }\n    list = hashtable->list.next;\n    list_init(&hashtable->list);\n    for(; list != &hashtable->list; list = next) {\n        next = list->next;\n        pair = list_to_pair(list);\n        index = pair->hash % new_size;\n        insert_to_bucket(hashtable, &hashtable->buckets[index], &pair->list);\n    }\n    return 0;\n}", "target": 1}
{"code": "static int vmx_sync_pir_to_irr(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint max_irr;\n\tWARN_ON(!vcpu->arch.apicv_active);\n\tif (pi_test_on(&vmx->pi_desc)) {\n\t\tpi_clear_on(&vmx->pi_desc);\n\t\tsmp_mb__after_atomic();\n\t\tmax_irr = kvm_apic_update_irr(vcpu, vmx->pi_desc.pir);\n\t} else {\n\t\tmax_irr = kvm_lapic_find_highest_irr(vcpu);\n\t}\n\tvmx_hwapic_irr_update(vcpu, max_irr);\n\treturn max_irr;\n}", "target": 0}
{"code": "compute_O_value(std::string const& user_password,\n\t\tstd::string const& owner_password,\n\t\tQPDF::EncryptionData const& data)\n{\n    unsigned char O_key[OU_key_bytes_V4];\n    compute_O_rc4_key(user_password, owner_password, data, O_key);\n    char upass[key_bytes];\n    pad_or_truncate_password_V4(user_password, upass);\n    std::string k1(reinterpret_cast<char*>(O_key), OU_key_bytes_V4);\n    pad_short_parameter(k1, data.getLengthBytes());\n    iterate_rc4(QUtil::unsigned_char_pointer(upass), key_bytes,\n\t\tO_key, data.getLengthBytes(),\n                (data.getR() >= 3) ? 20 : 1, false);\n    return std::string(upass, key_bytes);\n}", "target": 0}
{"code": "static int nft_flush_table(struct nft_ctx *ctx)\n{\n\tint err;\n\tstruct nft_chain *chain, *nc;\n\tstruct nft_set *set, *ns;\n\tlist_for_each_entry_safe(chain, nc, &ctx->table->chains, list) {\n\t\tctx->chain = chain;\n\t\terr = nft_delrule_by_chain(ctx);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\terr = nft_delchain(ctx);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\tlist_for_each_entry_safe(set, ns, &ctx->table->sets, list) {\n\t\tif (set->flags & NFT_SET_ANONYMOUS &&\n\t\t    !list_empty(&set->bindings))\n\t\t\tcontinue;\n\t\terr = nft_delset(ctx, set);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\terr = nft_deltable(ctx);\nout:\n\treturn err;\n}", "target": 1}
{"code": "static int jsR_hasproperty(js_State *J, js_Object *obj, const char *name)\n{\n\tjs_Property *ref;\n\tint k;\n\tif (obj->type == JS_CARRAY) {\n\t\tif (!strcmp(name, \"length\")) {\n\t\t\tjs_pushnumber(J, obj->u.a.length);\n\t\t\treturn 1;\n\t\t}\n\t}\n\telse if (obj->type == JS_CSTRING) {\n\t\tif (!strcmp(name, \"length\")) {\n\t\t\tjs_pushnumber(J, obj->u.s.length);\n\t\t\treturn 1;\n\t\t}\n\t\tif (js_isarrayindex(J, name, &k)) {\n\t\t\tif (k >= 0 && k < obj->u.s.length) {\n\t\t\t\tjs_pushrune(J, js_runeat(J, obj->u.s.string, k));\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\telse if (obj->type == JS_CREGEXP) {\n\t\tif (!strcmp(name, \"source\")) {\n\t\t\tjs_pushliteral(J, obj->u.r.source);\n\t\t\treturn 1;\n\t\t}\n\t\tif (!strcmp(name, \"global\")) {\n\t\t\tjs_pushboolean(J, obj->u.r.flags & JS_REGEXP_G);\n\t\t\treturn 1;\n\t\t}\n\t\tif (!strcmp(name, \"ignoreCase\")) {\n\t\t\tjs_pushboolean(J, obj->u.r.flags & JS_REGEXP_I);\n\t\t\treturn 1;\n\t\t}\n\t\tif (!strcmp(name, \"multiline\")) {\n\t\t\tjs_pushboolean(J, obj->u.r.flags & JS_REGEXP_M);\n\t\t\treturn 1;\n\t\t}\n\t\tif (!strcmp(name, \"lastIndex\")) {\n\t\t\tjs_pushnumber(J, obj->u.r.last);\n\t\t\treturn 1;\n\t\t}\n\t}\n\telse if (obj->type == JS_CUSERDATA) {\n\t\tif (obj->u.user.has && obj->u.user.has(J, obj->u.user.data, name))\n\t\t\treturn 1;\n\t}\n\tref = jsV_getproperty(J, obj, name);\n\tif (ref) {\n\t\tif (ref->getter) {\n\t\t\tjs_pushobject(J, ref->getter);\n\t\t\tjs_pushobject(J, obj);\n\t\t\tjs_call(J, 0);\n\t\t} else {\n\t\t\tjs_pushvalue(J, ref->value);\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void HeaderMapImpl::removeInline(HeaderEntryImpl** ptr_to_entry) {\n  if (!*ptr_to_entry) {\n    return;\n  }\n  HeaderEntryImpl* entry = *ptr_to_entry;\n  const uint64_t size_to_subtract = entry->entry_->key().size() + entry->entry_->value().size();\n  subtractSize(size_to_subtract);\n  *ptr_to_entry = nullptr;\n  headers_.erase(entry->entry_);\n}", "target": 0}
{"code": "void PDFiumEngine::FinishPaint(int progressive_index,\n                               pp::ImageData* image_data) {\n  DCHECK_GE(progressive_index, 0);\n  DCHECK_LT(static_cast<size_t>(progressive_index), progressive_paints_.size());\n  DCHECK(image_data);\n  int page_index = progressive_paints_[progressive_index].page_index;\n  pp::Rect dirty_in_screen = progressive_paints_[progressive_index].rect;\n  FPDF_BITMAP bitmap = progressive_paints_[progressive_index].bitmap;\n  int start_x, start_y, size_x, size_y;\n  GetPDFiumRect(\n      page_index, dirty_in_screen, &start_x, &start_y, &size_x, &size_y);\n  FPDF_FFLDraw(\n      form_, bitmap, pages_[page_index]->GetPage(), start_x, start_y, size_x,\n      size_y, current_rotation_, GetRenderingFlags());\n  FillPageSides(progressive_index);\n  PaintPageShadow(progressive_index, image_data);\n  DrawSelections(progressive_index, image_data);\n  FPDF_RenderPage_Close(pages_[page_index]->GetPage());\n  FPDFBitmap_Destroy(bitmap);\n  progressive_paints_.erase(progressive_paints_.begin() + progressive_index);\n  client_->DocumentPaintOccurred();\n}", "target": 0}
{"code": "TEST_F(MissingEKUTest, SignedData_missing_codesigning_EKU) {\n  auto certs = uthenticode::read_certs(pe);\n  auto signed_data = certs[0].as_signed_data();\n  ASSERT_FALSE(signed_data->verify_signature());\n}", "target": 0}
{"code": "void _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_flags);\n\thook_del_nick_can_register(check_registration_keywords);\n\thook_del_user_can_register(check_registration_keywords);\n\tdel_conf_item(\"ANOPE_FLAGS_COMPAT\", &chansvs.me->conf_table);\n}", "target": 0}
{"code": "static MagickBooleanType load_tile(Image *image,Image *tile_image,\n  XCFDocInfo *inDocInfo,XCFLayerInfo *inLayerInfo,size_t data_length,\n  ExceptionInfo *exception)\n{\n  ssize_t\n    y;\n  register ssize_t\n    x;\n  register Quantum\n    *q;\n  ssize_t\n    count;\n  unsigned char\n    *graydata;\n  XCFPixelInfo\n    *xcfdata,\n    *xcfodata;\n  xcfdata=(XCFPixelInfo *) AcquireQuantumMemory(data_length,sizeof(*xcfdata));\n  if (xcfdata == (XCFPixelInfo *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  xcfodata=xcfdata;\n  graydata=(unsigned char *) xcfdata;  \n  count=ReadBlob(image,data_length,(unsigned char *) xcfdata);\n  if (count != (ssize_t) data_length)\n    ThrowBinaryException(CorruptImageError,\"NotEnoughPixelData\",\n      image->filename);\n  for (y=0; y < (ssize_t) tile_image->rows; y++)\n  {\n    q=GetAuthenticPixels(tile_image,0,y,tile_image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    if (inDocInfo->image_type == GIMP_GRAY)\n      {\n        for (x=0; x < (ssize_t) tile_image->columns; x++)\n        {\n          SetPixelGray(tile_image,ScaleCharToQuantum(*graydata),q);\n          SetPixelAlpha(tile_image,ScaleCharToQuantum((unsigned char)\n            inLayerInfo->alpha),q);\n          graydata++;\n          q+=GetPixelChannels(tile_image);\n        }\n      }\n    else\n      if (inDocInfo->image_type == GIMP_RGB)\n        {\n          for (x=0; x < (ssize_t) tile_image->columns; x++)\n          {\n            SetPixelRed(tile_image,ScaleCharToQuantum(xcfdata->red),q);\n            SetPixelGreen(tile_image,ScaleCharToQuantum(xcfdata->green),q);\n            SetPixelBlue(tile_image,ScaleCharToQuantum(xcfdata->blue),q);\n            SetPixelAlpha(tile_image,xcfdata->alpha == 255U ? TransparentAlpha :\n              ScaleCharToQuantum((unsigned char) inLayerInfo->alpha),q);\n            xcfdata++;\n            q+=GetPixelChannels(tile_image);\n          }\n        }\n     if (SyncAuthenticPixels(tile_image,exception) == MagickFalse)\n       break;\n  }\n  xcfodata=(XCFPixelInfo *) RelinquishMagickMemory(xcfodata);\n  return MagickTrue;\n}", "target": 1}
{"code": "void recovery_delete_character(void)\n{\n    if (!recovery_started) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_UnexpectedMessage, \"Not in Recovery mode\");\n        layoutHome();\n        return;\n    }\n    if(strlen(mnemonic) > 0)\n    {\n        mnemonic[strlen(mnemonic) - 1] = '\\0';\n    }\n    next_character();\n}", "target": 0}
{"code": "\tconsume_count(type)\n\t\tconst char **type;\n{\n\tint count = 0;\n\tif (!isdigit((unsigned char)**type))\n\t\treturn -1;\n\twhile (isdigit((unsigned char)**type)) {\n\t\tcount *= 10;\n\t\tif ((count % 10) != 0) {\n\t\t\twhile (isdigit((unsigned char)**type))\n\t\t\t\t(*type)++;\n\t\t\treturn -1;\n\t\t}\n\t\tcount += **type - '0';\n\t\t(*type)++;\n\t}\n\treturn (count);\n}", "target": 1}
{"code": "folly::Optional<TLSMessage> PlaintextReadRecordLayer::read(\n    folly::IOBufQueue& buf) {\n  while (true) {\n    folly::io::Cursor cursor(buf.front());\n    if (buf.empty() || !cursor.canAdvance(kPlaintextHeaderSize)) {\n      return folly::none;\n    }\n    TLSMessage msg;\n    msg.type = static_cast<ContentType>(cursor.readBE<ContentTypeType>());\n    if (skipEncryptedRecords_) {\n      if (msg.type == ContentType::application_data) {\n        cursor.skip(sizeof(ProtocolVersion));\n        auto length = cursor.readBE<uint16_t>();\n        if (buf.chainLength() < (cursor - buf.front()) + length) {\n          return folly::none;\n        }\n        length +=\n            sizeof(ContentType) + sizeof(ProtocolVersion) + sizeof(uint16_t);\n        buf.trimStart(length);\n        continue;\n      } else if (msg.type != ContentType::change_cipher_spec) {\n        skipEncryptedRecords_ = false;\n      }\n    }\n    switch (msg.type) {\n      case ContentType::handshake:\n      case ContentType::alert:\n        break;\n      case ContentType::change_cipher_spec:\n        break;\n      default:\n        throw std::runtime_error(folly::to<std::string>(\n            \"received plaintext content type \",\n            static_cast<ContentTypeType>(msg.type),\n            \", header: \",\n            folly::hexlify(buf.splitAtMost(10)->coalesce())));\n    }\n    receivedRecordVersion_ =\n        static_cast<ProtocolVersion>(cursor.readBE<ProtocolVersionType>());\n    auto length = cursor.readBE<uint16_t>();\n    if (length > kMaxPlaintextRecordSize) {\n      throw std::runtime_error(\"received too long plaintext record\");\n    }\n    if (length == 0) {\n      throw std::runtime_error(\"received empty plaintext record\");\n    }\n    if (buf.chainLength() < (cursor - buf.front()) + length) {\n      return folly::none;\n    }\n    cursor.clone(msg.fragment, length);\n    buf.trimStart(cursor - buf.front());\n    if (msg.type == ContentType::change_cipher_spec) {\n      msg.fragment->coalesce();\n      if (msg.fragment->length() == 1 && *msg.fragment->data() == 0x01) {\n        continue;\n      } else {\n        throw FizzException(\n            \"received ccs\", AlertDescription::illegal_parameter);\n      }\n    }\n    return std::move(msg);\n  }\n}", "target": 1}
{"code": "        int          GetU8    (int nPos, bool *pbSuccess)\n        {\n            if ( nPos < 0 || nPos >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            return m_sFile[ nPos ];\n        }", "target": 1}
{"code": "  HTTP_CB(on_message_begin) {\n    num_fields_ = num_values_ = 0;\n    url_.Reset();\n    return 0;\n  }", "target": 0}
{"code": "NCR_ModifyMaxdelay(NCR_Instance inst, double new_max_delay)\n{\n  inst->max_delay = new_max_delay;\n  LOG(LOGS_INFO, LOGF_NtpCore, \"Source %s new max delay %f\",\n      UTI_IPToString(&inst->remote_addr.ip_addr), new_max_delay);\n}", "target": 0}
{"code": "  void resizeTable(HeaderTable& table, uint32_t newCapacity, uint32_t newMax) {\n    table.setCapacity(newCapacity);\n    EXPECT_LE(table.size(), newMax);\n  }", "target": 0}
{"code": "ice_protocol_timeout (IceConn ice_conn)\n{\n        GsmIceConnectionWatch *data;\n        g_debug (\"GsmXsmpServer: ice_protocol_timeout for IceConn %p with status %d\",\n                 ice_conn, IceConnectionStatus (ice_conn));\n        data = ice_conn->context;\n        free_ice_connection_watch (data);\n        disconnect_ice_connection (ice_conn);\n        return FALSE;\n}", "target": 0}
{"code": "static int validate_code_challenge(json_t * j_result_code, const char * code_verifier) {\n  int ret;\n  unsigned char code_verifier_hash[32] = {0}, code_verifier_hash_b64[64] = {0};\n  size_t code_verifier_hash_len = 32, code_verifier_hash_b64_len = 0;\n  gnutls_datum_t key_data;\n  if (!json_string_null_or_empty(json_object_get(j_result_code, \"code_challenge\"))) {\n    if (is_pkce_char_valid(code_verifier)) {\n      if (0 == o_strncmp(GLEWLWYD_CODE_CHALLENGE_S256_PREFIX, json_string_value(json_object_get(j_result_code, \"code_challenge\")), o_strlen(GLEWLWYD_CODE_CHALLENGE_S256_PREFIX))) {\n        key_data.data = (unsigned char *)code_verifier;\n        key_data.size = (unsigned int)o_strlen(code_verifier);\n        if (gnutls_fingerprint(GNUTLS_DIG_SHA256, &key_data, code_verifier_hash, &code_verifier_hash_len) == GNUTLS_E_SUCCESS) {\n          if (o_base64url_encode(code_verifier_hash, code_verifier_hash_len, code_verifier_hash_b64, &code_verifier_hash_b64_len)) {\n            code_verifier_hash_b64[code_verifier_hash_b64_len] = '\\0';\n            if (0 == o_strcmp(json_string_value(json_object_get(j_result_code, \"code_challenge\"))+o_strlen(GLEWLWYD_CODE_CHALLENGE_S256_PREFIX), (const char *)code_verifier_hash_b64)) {\n              ret = G_OK;\n            } else {\n              ret = G_ERROR_UNAUTHORIZED;\n            }\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"validate_code_challenge - Error o_base64url_encode\");\n            ret = G_ERROR;\n          }\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"validate_code_challenge - Error gnutls_fingerprint\");\n          ret = G_ERROR;\n        }\n      } else {\n        if (0 == o_strcmp(json_string_value(json_object_get(j_result_code, \"code_challenge\")), code_verifier)) {\n          ret = G_OK;\n        } else {\n          ret = G_ERROR_PARAM;\n        }\n      }\n    } else {\n      ret = G_ERROR_PARAM;\n    }\n  } else {\n    ret = G_OK;\n  }\n  return ret;\n}", "target": 1}
{"code": "uint64_t siphash(const uint8_t *in, const size_t inlen, const uint8_t *k) {\n    uint64_t hash;\n    uint8_t *out = (uint8_t*) &hash;\n    uint64_t v0 = 0x736f6d6570736575ULL;\n    uint64_t v1 = 0x646f72616e646f6dULL;\n    uint64_t v2 = 0x6c7967656e657261ULL;\n    uint64_t v3 = 0x7465646279746573ULL;\n    uint64_t k0 = U8TO64_LE(k);\n    uint64_t k1 = U8TO64_LE(k + 8);\n    uint64_t m;\n    const uint8_t *end = in + inlen - (inlen % sizeof(uint64_t));\n    const int left = inlen & 7;\n    uint64_t b = ((uint64_t)inlen) << 56;\n    v3 ^= k1;\n    v2 ^= k0;\n    v1 ^= k1;\n    v0 ^= k0;\n    for (; in != end; in += 8) {\n        m = U8TO64_LE(in);\n        v3 ^= m;\n        SIPROUND;\n        SIPROUND;\n        v0 ^= m;\n    }\n    switch (left) {\n    case 7: b |= ((uint64_t)in[6]) << 48;\n    case 6: b |= ((uint64_t)in[5]) << 40;\n    case 5: b |= ((uint64_t)in[4]) << 32;\n    case 4: b |= ((uint64_t)in[3]) << 24;\n    case 3: b |= ((uint64_t)in[2]) << 16;\n    case 2: b |= ((uint64_t)in[1]) << 8;\n    case 1: b |= ((uint64_t)in[0]); break;\n    case 0: break;\n    }\n    v3 ^= b;\n    SIPROUND;\n    SIPROUND;\n    v0 ^= b;\n    v2 ^= 0xff;\n    SIPROUND;\n    SIPROUND;\n    SIPROUND;\n    SIPROUND;\n    b = v0 ^ v1 ^ v2 ^ v3;\n    U64TO8_LE(out, b);\n    return hash;\n}", "target": 0}
{"code": "PHPAPI int php_swoole_unserialize(void *buffer, size_t len, zval *return_value, zval *object_args, long flag)\n{\n    SBucketType type = *(SBucketType*) (buffer);\n    zend_uchar real_type = type.data_type;\n    buffer += sizeof (SBucketType);\n    switch (real_type)\n    {\n        case IS_NULL:\n        case IS_TRUE:\n        case IS_FALSE:\n            Z_TYPE_INFO_P(return_value) = real_type;\n            break;\n        case IS_LONG:\n            swoole_unserialize_long(buffer, return_value, type);\n            Z_TYPE_INFO_P(return_value) = real_type;\n            break;\n        case IS_DOUBLE:\n            swoole_unserialize_raw(buffer, return_value);\n            Z_TYPE_INFO_P(return_value) = real_type;\n            break;\n        case IS_STRING:\n            len -= sizeof (SBucketType);\n            zend_string *str = swoole_unserialize_string(buffer, len);\n            ZVAL_STR(return_value, str);\n            break;\n        case IS_ARRAY:\n        {\n            if (swoole_seria_check_eof(buffer, len) < 0)\n            {\n                  php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"detect the error eof\");\n                  return SW_FALSE;\n            }\n            unser_start = buffer - sizeof (SBucketType);\n            uint32_t num = 0;\n            buffer = get_array_real_len(buffer, type.data_len, &num);\n            if (!swoole_unserialize_arr(buffer, return_value, num, flag))\n            {\n                return SW_FALSE;\n            }\n            break;\n        }\n        case IS_UNDEF:\n            if (swoole_seria_check_eof(buffer, len) < 0)\n            {\n                  php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"detect the error eof\");\n                  return SW_FALSE;\n            }\n            unser_start = buffer - sizeof (SBucketType);\n            if (!swoole_unserialize_object(buffer, return_value, type.data_len, object_args, flag))\n            {\n                return SW_FALSE;\n            }\n            break;\n        default:\n            php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"the type is not supported by swoole serialize.\");\n            return SW_FALSE;\n    }\n    return SW_TRUE;\n}", "target": 1}
{"code": "static void configureIOD(EctEnhancedCT *ct)\n{\n    if (!ct)\n        return;\n}", "target": 0}
{"code": "static int adpt_i2o_online_hba(adpt_hba* pHba)\n{\n\tif (adpt_i2o_systab_send(pHba) < 0)\n\t\treturn -1;\n\tif (adpt_i2o_enable_hba(pHba) < 0)\n\t\treturn -1;\n\treturn 0;\n}", "target": 1}
{"code": "static int crypto_report_one(struct crypto_alg *alg,\n\t\t\t     struct crypto_user_alg *ualg, struct sk_buff *skb)\n{\n\tstrlcpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));\n\tstrlcpy(ualg->cru_driver_name, alg->cra_driver_name,\n\t\tsizeof(ualg->cru_driver_name));\n\tstrlcpy(ualg->cru_module_name, module_name(alg->cra_module),\n\t\tsizeof(ualg->cru_module_name));\n\tualg->cru_type = 0;\n\tualg->cru_mask = 0;\n\tualg->cru_flags = alg->cra_flags;\n\tualg->cru_refcnt = refcount_read(&alg->cra_refcnt);\n\tif (nla_put_u32(skb, CRYPTOCFGA_PRIORITY_VAL, alg->cra_priority))\n\t\tgoto nla_put_failure;\n\tif (alg->cra_flags & CRYPTO_ALG_LARVAL) {\n\t\tstruct crypto_report_larval rl;\n\t\tstrlcpy(rl.type, \"larval\", sizeof(rl.type));\n\t\tif (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,\n\t\t\t    sizeof(struct crypto_report_larval), &rl))\n\t\t\tgoto nla_put_failure;\n\t\tgoto out;\n\t}\n\tif (alg->cra_type && alg->cra_type->report) {\n\t\tif (alg->cra_type->report(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tgoto out;\n\t}\n\tswitch (alg->cra_flags & (CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL)) {\n\tcase CRYPTO_ALG_TYPE_CIPHER:\n\t\tif (crypto_report_cipher(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_COMPRESS:\n\t\tif (crypto_report_comp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_ACOMPRESS:\n\t\tif (crypto_report_acomp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_AKCIPHER:\n\t\tif (crypto_report_akcipher(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_KPP:\n\t\tif (crypto_report_kpp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\t}\nout:\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "TfLiteStatus GenericPrepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLitePoolParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input));\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  int batches = input->dims->data[0];\n  int height = input->dims->data[1];\n  int width = input->dims->data[2];\n  int channels_out = input->dims->data[3];\n  auto padding = params->padding;\n  int out_width, out_height;\n  TF_LITE_ENSURE(context, params->stride_height > 0);\n  TF_LITE_ENSURE(context, params->stride_width > 0);\n  data->padding = ComputePaddingHeightWidth(\n      params->stride_height, params->stride_width, 1, 1, height, width,\n      params->filter_height, params->filter_width, padding, &out_height,\n      &out_width);\n  if (input->type == kTfLiteUInt8 || input->type == kTfLiteInt8) {\n    if (pool_type == kAverage || pool_type == kMax) {\n      TFLITE_DCHECK_LE(std::abs(input->params.scale - output->params.scale),\n                       1.0e-6);\n      TFLITE_DCHECK_EQ(input->params.zero_point, output->params.zero_point);\n    }\n    if (pool_type == kL2) {\n      TF_LITE_ENSURE_TYPES_EQ(context, input->type, kTfLiteFloat32);\n    }\n  }\n  TfLiteIntArray* output_size = TfLiteIntArrayCreate(4);\n  output_size->data[0] = batches;\n  output_size->data[1] = out_height;\n  output_size->data[2] = out_width;\n  output_size->data[3] = channels_out;\n  return context->ResizeTensor(context, output, output_size);\n}", "target": 0}
{"code": "static void fuse_lib_init(void *data, struct fuse_conn_info *conn)\n{\n    struct fuse *f = (struct fuse *) data;\n    struct fuse_context_i *c = fuse_get_context_internal();\n    memset(c, 0, sizeof(*c));\n    c->ctx.fuse = f;\n    fuse_fs_init(f->fs, conn);\n}", "target": 0}
{"code": "static void pptp_ctx_switch(struct triton_context_t *ctx, void *arg)\n{\n\tif (arg) {\n\t\tstruct ap_session *s = arg;\n\t\tnet = s->net;\n\t} else\n\t\tnet = def_net;\n\tlog_switch(ctx, arg);\n}", "target": 0}
{"code": "spnego_gss_inquire_context(\n\t\t\tOM_uint32\t*minor_status,\n\t\t\tconst gss_ctx_id_t context_handle,\n\t\t\tgss_name_t\t*src_name,\n\t\t\tgss_name_t\t*targ_name,\n\t\t\tOM_uint32\t*lifetime_rec,\n\t\t\tgss_OID\t\t*mech_type,\n\t\t\tOM_uint32\t*ctx_flags,\n\t\t\tint\t\t*locally_initiated,\n\t\t\tint\t\t*opened)\n{\n\tOM_uint32 ret = GSS_S_COMPLETE;\n\tret = gss_inquire_context(minor_status,\n\t\t\t\tcontext_handle,\n\t\t\t\tsrc_name,\n\t\t\t\ttarg_name,\n\t\t\t\tlifetime_rec,\n\t\t\t\tmech_type,\n\t\t\t\tctx_flags,\n\t\t\t\tlocally_initiated,\n\t\t\t\topened);\n\treturn (ret);\n}", "target": 1}
{"code": "static int dccp_error(struct net *net, struct nf_conn *tmpl,\n\t\t      struct sk_buff *skb, unsigned int dataoff,\n\t\t      enum ip_conntrack_info *ctinfo,\n\t\t      u_int8_t pf, unsigned int hooknum)\n{\n\tstruct dccp_hdr _dh, *dh;\n\tunsigned int dccp_len = skb->len - dataoff;\n\tunsigned int cscov;\n\tconst char *msg;\n\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);\n\tif (dh == NULL) {\n\t\tmsg = \"nf_ct_dccp: short packet \";\n\t\tgoto out_invalid;\n\t}\n\tif (dh->dccph_doff * 4 < sizeof(struct dccp_hdr) ||\n\t    dh->dccph_doff * 4 > dccp_len) {\n\t\tmsg = \"nf_ct_dccp: truncated/malformed packet \";\n\t\tgoto out_invalid;\n\t}\n\tcscov = dccp_len;\n\tif (dh->dccph_cscov) {\n\t\tcscov = (dh->dccph_cscov - 1) * 4;\n\t\tif (cscov > dccp_len) {\n\t\t\tmsg = \"nf_ct_dccp: bad checksum coverage \";\n\t\t\tgoto out_invalid;\n\t\t}\n\t}\n\tif (net->ct.sysctl_checksum && hooknum == NF_INET_PRE_ROUTING &&\n\t    nf_checksum_partial(skb, hooknum, dataoff, cscov, IPPROTO_DCCP,\n\t\t\t\tpf)) {\n\t\tmsg = \"nf_ct_dccp: bad checksum \";\n\t\tgoto out_invalid;\n\t}\n\tif (dh->dccph_type >= DCCP_PKT_INVALID) {\n\t\tmsg = \"nf_ct_dccp: reserved packet type \";\n\t\tgoto out_invalid;\n\t}\n\treturn NF_ACCEPT;\nout_invalid:\n\tif (LOG_INVALID(net, IPPROTO_DCCP))\n\t\tnf_log_packet(net, pf, 0, skb, NULL, NULL, NULL, \"%s\", msg);\n\treturn -NF_ACCEPT;\n}", "target": 1}
{"code": "static int __init disable_acpi_irq(struct dmi_system_id *d)\n{\n\tif (!acpi_force) {\n\t\tprintk(KERN_NOTICE \"%s detected: force use of acpi=noirq\\n\",\n\t\t       d->ident);\n\t\tacpi_noirq_set();\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "int fz_colorspace_is_subtractive(fz_context *ctx, const fz_colorspace *cs)\n{\n\treturn cs && (cs->type == FZ_COLORSPACE_CMYK || cs->type == FZ_COLORSPACE_SEPARATION);\n}", "target": 0}
{"code": "vrrp_print_stats(void)\n{\n\tFILE *file;\n\tfile = fopen (stats_file, \"w\");\n\tif (!file) {\n\t\tlog_message(LOG_INFO, \"Can't open %s (%d: %s)\",\n\t\t\tstats_file, errno, strerror(errno));\n\t\treturn;\n\t}\n\tlist l = vrrp_data->vrrp;\n\telement e;\n\tvrrp_t *vrrp;\n\tfor (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) {\n\t\tvrrp = ELEMENT_DATA(e);\n\t\tfprintf(file, \"VRRP Instance: %s\\n\", vrrp->iname);\n\t\tfprintf(file, \"  Advertisements:\\n\");\n\t\tfprintf(file, \"    Received: %\" PRIu64 \"\\n\", vrrp->stats->advert_rcvd);\n\t\tfprintf(file, \"    Sent: %d\\n\", vrrp->stats->advert_sent);\n\t\tfprintf(file, \"  Became master: %d\\n\", vrrp->stats->become_master);\n\t\tfprintf(file, \"  Released master: %d\\n\",\n\t\t\tvrrp->stats->release_master);\n\t\tfprintf(file, \"  Packet Errors:\\n\");\n\t\tfprintf(file, \"    Length: %\" PRIu64 \"\\n\", vrrp->stats->packet_len_err);\n\t\tfprintf(file, \"    TTL: %\" PRIu64 \"\\n\", vrrp->stats->ip_ttl_err);\n\t\tfprintf(file, \"    Invalid Type: %\" PRIu64 \"\\n\",\n\t\t\tvrrp->stats->invalid_type_rcvd);\n\t\tfprintf(file, \"    Advertisement Interval: %\" PRIu64 \"\\n\",\n\t\t\tvrrp->stats->advert_interval_err);\n\t\tfprintf(file, \"    Address List: %\" PRIu64 \"\\n\",\n\t\t\tvrrp->stats->addr_list_err);\n\t\tfprintf(file, \"  Authentication Errors:\\n\");\n\t\tfprintf(file, \"    Invalid Type: %d\\n\",\n\t\t\tvrrp->stats->invalid_authtype);\n#ifdef _WITH_VRRP_AUTH_\n\t\tfprintf(file, \"    Type Mismatch: %d\\n\",\n\t\t\tvrrp->stats->authtype_mismatch);\n\t\tfprintf(file, \"    Failure: %d\\n\",\n\t\t\tvrrp->stats->auth_failure);\n#endif\n\t\tfprintf(file, \"  Priority Zero:\\n\");\n\t\tfprintf(file, \"    Received: %\" PRIu64 \"\\n\", vrrp->stats->pri_zero_rcvd);\n\t\tfprintf(file, \"    Sent: %\" PRIu64 \"\\n\", vrrp->stats->pri_zero_sent);\n\t}\n\tfclose(file);\n}", "target": 1}
{"code": "static int init_strtab(ELFOBJ *bin) {\n\tr_return_val_if_fail (!bin->strtab, false);\n\tif (!bin->shdr) {\n\t\treturn false;\n\t}\n\tElf_(Half) shstrndx = bin->ehdr.e_shstrndx;\n\tif (shstrndx != SHN_UNDEF && !is_shidx_valid (bin, shstrndx)) {\n\t\treturn false;\n\t}\n\tif (bin->shdr[shstrndx].sh_size > UT32_MAX) {\n\t\treturn false;\n\t}\n\tif (!bin->shdr[shstrndx].sh_size) {\n\t\treturn false;\n\t}\n\tbin->shstrtab_section = bin->strtab_section = &bin->shdr[shstrndx];\n\tbin->shstrtab_size = bin->shstrtab_section->sh_size;\n\tif (bin->shstrtab_size > bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->shstrtab_section->sh_offset > bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->shstrtab_section->sh_offset + bin->shstrtab_section->sh_size > bin->size) {\n\t\treturn false;\n\t}\n\tif (!(bin->shstrtab = calloc (1, bin->shstrtab_size + 1))) {\n\t\tr_sys_perror (\"malloc\");\n\t\tbin->shstrtab = NULL;\n\t\treturn false;\n\t}\n\tint res = r_buf_read_at (bin->b, bin->shstrtab_section->sh_offset, (ut8*)bin->shstrtab,\n\t\tbin->shstrtab_section->sh_size);\n\tif (res < 1) {\n\t\tR_LOG_ERROR (\"read (shstrtab) at 0x%\" PFMT64x, (ut64) bin->shstrtab_section->sh_offset);\n\t\tR_FREE (bin->shstrtab);\n\t\treturn false;\n\t}\n\tbin->shstrtab[bin->shstrtab_section->sh_size] = '\\0';\n\tsdb_num_set (bin->kv, \"elf_shstrtab.offset\", bin->shstrtab_section->sh_offset, 0);\n\tsdb_num_set (bin->kv, \"elf_shstrtab.size\", bin->shstrtab_section->sh_size, 0);\n\treturn true;\n}", "target": 1}
{"code": "static bool is_spilled_reg(const struct bpf_stack_state *stack)\n{\n\treturn stack->slot_type[BPF_REG_SIZE - 1] == STACK_SPILL;\n}", "target": 0}
{"code": "HttpStateData::continueAfterParsingHeader()\n{\n    if (flags.handling1xx) {\n        debugs(11, 5, HERE << \"wait for 1xx handling\");\n        Must(!flags.headers_parsed);\n        return false;\n    }\n    if (!flags.headers_parsed && !eof) {\n        debugs(11, 9, \"needs more at \" << inBuf.length());\n        flags.do_next_read = true;\n        maybeReadVirginBody(); \n        return false;\n    }\n    err_type error = ERR_NONE;\n    if (flags.headers_parsed) { \n        if (HttpReply *vrep = virginReply()) {\n            const Http::StatusCode s = vrep->sline.status();\n            const AnyP::ProtocolVersion &v = vrep->sline.version;\n            if (s == Http::scInvalidHeader && v != Http::ProtocolVersion(0,9)) {\n                debugs(11, DBG_IMPORTANT, \"WARNING: HTTP: Invalid Response: Bad header encountered from \" << entry->url() << \" AKA \" << request->url);\n                error = ERR_INVALID_RESP;\n            } else if (s == Http::scHeaderTooLarge) {\n                fwd->dontRetry(true);\n                error = ERR_TOO_BIG;\n            } else if (vrep->header.conflictingContentLength()) {\n                fwd->dontRetry(true);\n                error = ERR_INVALID_RESP;\n            } else if (vrep->header.unsupportedTe()) {\n                fwd->dontRetry(true);\n                error = ERR_INVALID_RESP;\n            } else {\n                return true; \n            }\n        } else {\n            debugs(11, DBG_IMPORTANT, \"WARNING: HTTP: Invalid Response: No reply at all for \" << entry->url() << \" AKA \" << request->url);\n            error = ERR_INVALID_RESP;\n        }\n    } else {\n        assert(eof);\n        if (inBuf.length()) {\n            error = ERR_INVALID_RESP;\n            debugs(11, DBG_IMPORTANT, \"WARNING: HTTP: Invalid Response: Headers did not parse at all for \" << entry->url() << \" AKA \" << request->url);\n        } else {\n            error = ERR_ZERO_SIZE_OBJECT;\n            debugs(11, (request->flags.accelerated?DBG_IMPORTANT:2), \"WARNING: HTTP: Invalid Response: No object data received for \" << entry->url() << \" AKA \" << request->url);\n        }\n    }\n    assert(error != ERR_NONE);\n    entry->reset();\n    fwd->fail(new ErrorState(error, Http::scBadGateway, fwd->request));\n    flags.do_next_read = false;\n    closeServer();\n    mustStop(\"HttpStateData::continueAfterParsingHeader\");\n    return false; \n}", "target": 0}
{"code": "check_entry_size_and_hooks(struct ip6t_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_err(\"Underflows must be unconditional and \"\n\t\t\t\t       \"use the STANDARD target with \"\n\t\t\t\t       \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 1}
{"code": "static void fuse_delete_context_key(void)\n{\n    pthread_mutex_lock(&fuse_context_lock);\n    fuse_context_ref--;\n    if (!fuse_context_ref) {\n        free(pthread_getspecific(fuse_context_key));\n        pthread_key_delete(fuse_context_key);\n    }\n    pthread_mutex_unlock(&fuse_context_lock);\n}", "target": 0}
{"code": "static int handle_vmptrst(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tu32 vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\tgva_t vmcs_gva;\n\tstruct x86_exception e;\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\tif (get_vmx_mem_address(vcpu, exit_qualification,\n\t\t\tvmx_instruction_info, true, &vmcs_gva))\n\t\treturn 1;\n\tif (kvm_write_guest_virt_system(&vcpu->arch.emulate_ctxt, vmcs_gva,\n\t\t\t\t (void *)&to_vmx(vcpu)->nested.current_vmptr,\n\t\t\t\t sizeof(u64), &e)) {\n\t\tkvm_inject_page_fault(vcpu, &e);\n\t\treturn 1;\n\t}\n\tnested_vmx_succeed(vcpu);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}", "target": 1}
{"code": "simple_upscale(j_decompress_ptr cinfo,\n               JDIFFROW diff_buf, _JSAMPROW output_buf, JDIMENSION width)\n{\n  do {\n#if BITS_IN_JSAMPLE == 12\n    *output_buf++ = (_JSAMPLE)((*diff_buf++ << cinfo->Al) & 0xFFF);\n#else\n    *output_buf++ = (_JSAMPLE)(*diff_buf++ << cinfo->Al);\n#endif\n  } while (--width);\n}", "target": 0}
{"code": "static void gf_dump_vrml_simple_field(GF_SceneDumper *sdump, GF_FieldInfo field, GF_Node *parent)\n{\n\tu32 i, sf_type;\n\tGF_ChildNodeItem *list;\n\tvoid *slot_ptr;\n\tswitch (field.fieldType) {\n\tcase GF_SG_VRML_SFNODE:\n\t\tgf_dump_vrml_node(sdump, field.far_ptr ? *(GF_Node **)field.far_ptr : NULL, 0, NULL);\n\t\treturn;\n\tcase GF_SG_VRML_MFNODE:\n\t\tlist = * ((GF_ChildNodeItem **) field.far_ptr);\n\t\tassert( list );\n\t\tsdump->indent++;\n\t\twhile (list) {\n\t\t\tgf_dump_vrml_node(sdump, list->node, 1, NULL);\n\t\t\tlist = list->next;\n\t\t}\n\t\tsdump->indent--;\n\t\treturn;\n\tcase GF_SG_VRML_SFCOMMANDBUFFER:\n\t\treturn;\n\t}\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) {\n\t\tif (sdump->XMLDump) StartAttribute(sdump, \"value\");\n\t\tgf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, parent);\n\t\tif (sdump->XMLDump) EndAttribute(sdump);\n\t} else {\n\t\tGenMFField *mffield;\n\t\tmffield = (GenMFField *) field.far_ptr;\n\t\tsf_type = gf_sg_vrml_get_sf_type(field.fieldType);\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"[\");\n\t\t} else if (sf_type==GF_SG_VRML_SFSTRING) {\n\t\t\tgf_fprintf(sdump->trace, \" value=\\'\");\n\t\t} else {\n\t\t\tStartAttribute(sdump, \"value\");\n\t\t}\n\t\tfor (i=0; mffield && (i<mffield->count); i++) {\n\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, parent);\n\t\t}\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"]\");\n\t\t} else if (sf_type==GF_SG_VRML_SFSTRING) {\n\t\t\tgf_fprintf(sdump->trace, \"\\'\");\n\t\t} else {\n\t\t\tEndAttribute(sdump);\n\t\t}\n\t}\n}", "target": 0}
{"code": "test_copy_to (const char *from, const char *to)\n{\n  char buf[TESTBUFSIZE];\n  int ret;\n  snprintf_func (buf, TESTBUFSIZE, \"cp -f %s %s\", from, to);\n  if ((ret = system (buf)) != 0)\n    {\n      return XD3_INTERNAL;\n    }\n  return 0;\n}", "target": 0}
{"code": "static int do_i2c_crc(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t      char *const argv[])\n{\n\tuint\tchip;\n\tulong\taddr;\n\tint\talen;\n\tint\tcount;\n\tuchar\tbyte;\n\tulong\tcrc;\n\tulong\terr;\n\tint ret = 0;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n#endif\n\tif (argc < 4)\n\t\treturn CMD_RET_USAGE;\n\tchip = hextoul(argv[1], NULL);\n\taddr = hextoul(argv[2], NULL);\n\talen = get_alen(argv[2], DEFAULT_ADDR_LEN);\n\tif (alen > 3)\n\t\treturn CMD_RET_USAGE;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret && alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_READ);\n#endif\n\tcount = hextoul(argv[3], NULL);\n\tprintf (\"CRC32 for %08lx ... %08lx ==> \", addr, addr + count - 1);\n\tcrc = 0;\n\terr = 0;\n\twhile (count-- > 0) {\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\tret = dm_i2c_read(dev, addr, &byte, 1);\n#else\n\t\tret = i2c_read(chip, addr, alen, &byte, 1);\n#endif\n\t\tif (ret)\n\t\t\terr++;\n\t\tcrc = crc32(crc, &byte, 1);\n\t\taddr++;\n\t}\n\tif (err > 0)\n\t\ti2c_report_err(ret, I2C_ERR_READ);\n\telse\n\t\tprintf (\"%08lx\\n\", crc);\n\treturn 0;\n}", "target": 1}
{"code": "void jpc_qmfb_split_col(jpc_fix_t *a, int numrows, int stride,\n  int parity)\n{\n\tint bufsize = JPC_CEILDIVPOW2(numrows, 1);\n\tjpc_fix_t splitbuf[QMFB_SPLITBUFSIZE];\n\tjpc_fix_t *buf = splitbuf;\n\tregister jpc_fix_t *srcptr;\n\tregister jpc_fix_t *dstptr;\n\tregister int n;\n\tregister int m;\n\tint hstartcol;\n\tif (bufsize > QMFB_SPLITBUFSIZE) {\n\t\tif (!(buf = jas_alloc2(bufsize, sizeof(jpc_fix_t)))) {\n\t\t\tabort();\n\t\t}\n\t}\n\tif (numrows >= 2) {\n\t\thstartcol = (numrows + 1 - parity) >> 1;\n\t\tm = numrows - hstartcol;\n\t\tn = m;\n\t\tdstptr = buf;\n\t\tsrcptr = &a[(1 - parity) * stride];\n\t\twhile (n-- > 0) {\n\t\t\t*dstptr = *srcptr;\n\t\t\t++dstptr;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\tdstptr = &a[(1 - parity) * stride];\n\t\tsrcptr = &a[(2 - parity) * stride];\n\t\tn = numrows - m - (!parity);\n\t\twhile (n-- > 0) {\n\t\t\t*dstptr = *srcptr;\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\tdstptr = &a[hstartcol * stride];\n\t\tsrcptr = buf;\n\t\tn = m;\n\t\twhile (n-- > 0) {\n\t\t\t*dstptr = *srcptr;\n\t\t\tdstptr += stride;\n\t\t\t++srcptr;\n\t\t}\n\t}\n\tif (buf != splitbuf) {\n\t\tjas_free(buf);\n\t}\n}", "target": 1}
{"code": "parse_CT_CLEAR(char *arg OVS_UNUSED, const struct ofpact_parse_params *pp)\n{\n    ofpact_put_CT_CLEAR(pp->ofpacts);\n    return NULL;\n}", "target": 0}
{"code": "static int f2fs_mpage_readpages(struct address_space *mapping,\n\t\t\tstruct list_head *pages, struct page *page,\n\t\t\tunsigned nr_pages, bool is_readahead)\n{\n\tstruct bio *bio = NULL;\n\tsector_t last_block_in_bio = 0;\n\tstruct inode *inode = mapping->host;\n\tstruct f2fs_map_blocks map;\n\tint ret = 0;\n\tmap.m_pblk = 0;\n\tmap.m_lblk = 0;\n\tmap.m_len = 0;\n\tmap.m_flags = 0;\n\tmap.m_next_pgofs = NULL;\n\tmap.m_next_extent = NULL;\n\tmap.m_seg_type = NO_CHECK_TYPE;\n\tmap.m_may_create = false;\n\tfor (; nr_pages; nr_pages--) {\n\t\tif (pages) {\n\t\t\tpage = list_last_entry(pages, struct page, lru);\n\t\t\tprefetchw(&page->flags);\n\t\t\tlist_del(&page->lru);\n\t\t\tif (add_to_page_cache_lru(page, mapping,\n\t\t\t\t\t\t  page->index,\n\t\t\t\t\t\t  readahead_gfp_mask(mapping)))\n\t\t\t\tgoto next_page;\n\t\t}\n\t\tret = f2fs_read_single_page(inode, page, nr_pages, &map, &bio,\n\t\t\t\t\t&last_block_in_bio, is_readahead);\n\t\tif (ret) {\n\t\t\tSetPageError(page);\n\t\t\tzero_user_segment(page, 0, PAGE_SIZE);\n\t\t\tunlock_page(page);\n\t\t}\nnext_page:\n\t\tif (pages)\n\t\t\tput_page(page);\n\t}\n\tBUG_ON(pages && !list_empty(pages));\n\tif (bio)\n\t\t__submit_bio(F2FS_I_SB(inode), bio, DATA);\n\treturn pages ? 0 : ret;\n}", "target": 1}
{"code": "nvkm_vmm_free_delete(struct nvkm_vmm *vmm, struct nvkm_vma *vma)\n{\n\tnvkm_vmm_free_remove(vmm, vma);\n\tlist_del(&vma->head);\n\tkfree(vma);\n}", "target": 0}
{"code": "static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_cipher rcipher;\n\tstrlcpy(rcipher.type, \"cipher\", sizeof(rcipher.type));\n\trcipher.blocksize = alg->cra_blocksize;\n\trcipher.min_keysize = alg->cra_cipher.cia_min_keysize;\n\trcipher.max_keysize = alg->cra_cipher.cia_max_keysize;\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_CIPHER,\n\t\t    sizeof(struct crypto_report_cipher), &rcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "        int          GetS8    (int nPos, bool *pbSuccess)\n        {\n            if ( nPos < 0 || nPos >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            int nRes = m_sFile[ nPos ];\n            if ( nRes & 0x80 )\n                nRes |= ~0xff;\n            return nRes;\n        }", "target": 1}
{"code": "MagickExport MagickBooleanType HeapOverflowSanityCheck(const size_t count,\n  const size_t quantum)\n{\n  size_t\n    size;\n  size=count*quantum;\n  if ((count == 0) || (quantum != (size/count)))\n    {\n      errno=ENOMEM;\n      return(MagickTrue);\n    }\n  return(MagickFalse);\n}", "target": 0}
{"code": "size_t EncodedSizeOfKey(HttpSchemeMetadata, HttpSchemeMetadata::ValueType x) {\n  switch (x) {\n    case HttpSchemeMetadata::kHttp:\n      return 4;\n    case HttpSchemeMetadata::kHttps:\n      return 5;\n    default:\n      return 0;\n  }\n}", "target": 0}
{"code": "  HistogramInfo* heap_histograms() { return heap_histograms_; }", "target": 0}
{"code": "ssh_packet_set_compress_hooks(struct ssh *ssh, void *ctx,\n    void *(*allocfunc)(void *, u_int, u_int),\n    void (*freefunc)(void *, void *))\n{\n\tssh->state->compression_out_stream.zalloc = (alloc_func)allocfunc;\n\tssh->state->compression_out_stream.zfree = (free_func)freefunc;\n\tssh->state->compression_out_stream.opaque = ctx;\n\tssh->state->compression_in_stream.zalloc = (alloc_func)allocfunc;\n\tssh->state->compression_in_stream.zfree = (free_func)freefunc;\n\tssh->state->compression_in_stream.opaque = ctx;\n}", "target": 1}
{"code": "bool allow_svhandler_flash_range(size_t start, size_t end) {\n  if (start > end) return false;\n  if (start < FLASH_ORIGIN || end > FLASH_END) return false;\n  bool startAllowed = false;\n  bool endAllowed = false;\n  for (const FlashSector* s = flash_sector_map; s->use != FLASH_INVALID; s++) {\n    if (allow_svhandler_flash_sector(s)) {\n      if (!startAllowed &&\n          start + 1 > start &&\n          do_memory_ranges_overlap(start, start + 1, s->start, s->start + s->len)) {\n        startAllowed = true;\n      }\n      if (!endAllowed &&\n          end - 1 < end &&\n          do_memory_ranges_overlap(end - 1, end, s->start, s->start + s->len)) {\n        endAllowed = true;\n      }\n    } else {\n      if (do_memory_ranges_overlap(start, end, s->start, s->start + s->len)) return false;\n    }\n  }\n  if (!startAllowed || !endAllowed) return false;\n  return true;\n}", "target": 0}
{"code": "PGTYPESinterval_from_asc(char *str, char **endptr)\n{\n\tinterval   *result = NULL;\n\tfsec_t\t\tfsec;\n\tstruct tm\ttt,\n\t\t\t   *tm = &tt;\n\tint\t\t\tdtype;\n\tint\t\t\tnf;\n\tchar\t   *field[MAXDATEFIELDS];\n\tint\t\t\tftype[MAXDATEFIELDS];\n\tchar\t\tlowstr[MAXDATELEN + MAXDATEFIELDS];\n\tchar\t   *realptr;\n\tchar\t  **ptr = (endptr != NULL) ? endptr : &realptr;\n\ttm->tm_year = 0;\n\ttm->tm_mon = 0;\n\ttm->tm_mday = 0;\n\ttm->tm_hour = 0;\n\ttm->tm_min = 0;\n\ttm->tm_sec = 0;\n\tfsec = 0;\n\tif (strlen(str) >= sizeof(lowstr))\n\t{\n\t\terrno = PGTYPES_INTVL_BAD_INTERVAL;\n\t\treturn NULL;\n\t}\n\tif (ParseDateTime(str, lowstr, field, ftype, &nf, ptr) != 0 ||\n\t\t(DecodeInterval(field, ftype, nf, &dtype, tm, &fsec) != 0 &&\n\t\t DecodeISO8601Interval(str, &dtype, tm, &fsec) != 0))\n\t{\n\t\terrno = PGTYPES_INTVL_BAD_INTERVAL;\n\t\treturn NULL;\n\t}\n\tresult = (interval *) pgtypes_alloc(sizeof(interval));\n\tif (!result)\n\t\treturn NULL;\n\tif (dtype != DTK_DELTA)\n\t{\n\t\terrno = PGTYPES_INTVL_BAD_INTERVAL;\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\tif (tm2interval(tm, fsec, result) != 0)\n\t{\n\t\terrno = PGTYPES_INTVL_BAD_INTERVAL;\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\terrno = 0;\n\treturn result;\n}", "target": 1}
{"code": "void stl_le_phys(AddressSpace *as, hwaddr addr, uint32_t val)\n{\n    address_space_stl_le(as, addr, val, MEMTXATTRS_UNSPECIFIED, NULL);\n}", "target": 0}
{"code": "static void opt_kfree_rcu(struct rcu_head *head)\n{\n\tkfree(container_of(head, struct ip_options_rcu, rcu));\n}", "target": 0}
{"code": "  StatusOr<std::vector<int64_t>> GetStride(XlaOpKernelContext* ctx) {\n    if (ctx->num_inputs() == 1) {\n      return stride_;\n    }\n    const TensorShape stride_shape = ctx->InputShape(2);\n    if (!TensorShapeUtils::IsVector(stride_shape)) {\n      return errors::InvalidArgument(\"stride must be a vector, not shape \",\n                                     stride_shape.DebugString());\n    }\n    if (stride_shape.num_elements() != num_dims()) {\n      return errors::InvalidArgument(\n          \"Sliding window stride field must \"\n          \"specify \",\n          num_dims(), \" dimensions\");\n    }\n    std::vector<int64_t> stride;\n    auto status = ctx->ConstantInputAsIntVector(2, &stride);\n    if (!status.ok()) {\n      return status;\n    }\n    return stride;\n  }", "target": 1}
{"code": "GF_Err gf_swf_read_header(SWFReader *read)\n{\n\tSWFRec rc;\n\tu8 sig[3];\n\tsig[0] = gf_bs_read_u8(read->bs);\n\tsig[1] = gf_bs_read_u8(read->bs);\n\tsig[2] = gf_bs_read_u8(read->bs);\n\tif ( ((sig[0] != 'F') && (sig[0] != 'C')) || (sig[1] != 'W') || (sig[2] != 'S') ) {\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tgf_bs_read_u8(read->bs);\n\tread->length = swf_get_32(read);\n\tif (sig[0] == 'C') {\n\t\tswf_init_decompress(read);\n\t\tif (!read->bs) return GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tswf_get_rec(read, &rc);\n\tread->width = rc.w;\n\tread->height = rc.h;\n\tswf_align(read);\n\tread->frame_rate = swf_get_16(read)>>8;\n\tread->frame_count = swf_get_16(read);\n\tGF_LOG(GF_LOG_INFO, GF_LOG_PARSER, (\"SWF Import - Scene Size %gx%g - %d frames @ %d FPS\\n\", read->width, read->height, read->frame_count, read->frame_rate));\n\tif (!read->frame_rate) read->frame_rate = 1;\n\treturn GF_OK;\n}", "target": 0}
{"code": "static void free_kvm_area(void)\n{\n\tint cpu;\n\tfor_each_possible_cpu(cpu) {\n\t\tfree_vmcs(per_cpu(vmxarea, cpu));\n\t\tper_cpu(vmxarea, cpu) = NULL;\n\t}\n}", "target": 0}
{"code": "static MagickBooleanType WritePTIFImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  Image\n    *images,\n    *next,\n    *pyramid_image;\n  ImageInfo\n    *write_info;\n  MagickBooleanType\n    status;\n  PointInfo\n    resolution;\n  size_t\n    columns,\n    rows;\n  images=NewImageList();\n  for (next=image; next != (Image *) NULL; next=GetNextImageInList(next))\n  {\n    Image\n      *clone_image;\n    clone_image=CloneImage(next,0,0,MagickFalse,exception);\n    if (clone_image == (Image *) NULL)\n      break;\n    clone_image->previous=NewImageList();\n    clone_image->next=NewImageList();\n    (void) SetImageProperty(clone_image,\"tiff:subfiletype\",\"none\",exception);\n    AppendImageToList(&images,clone_image);\n    columns=next->columns;\n    rows=next->rows;\n    resolution=next->resolution;\n    while ((columns > 64) && (rows > 64))\n    {\n      columns/=2;\n      rows/=2;\n      resolution.x/=2;\n      resolution.y/=2;\n      pyramid_image=ResizeImage(next,columns,rows,image->filter,exception);\n      if (pyramid_image == (Image *) NULL)\n        break;\n      pyramid_image->resolution=resolution;\n      (void) SetImageProperty(pyramid_image,\"tiff:subfiletype\",\"REDUCEDIMAGE\",\n        exception);\n      AppendImageToList(&images,pyramid_image);\n    }\n  }\n  if (images != (Image *) NULL)\n    {\n      images=GetFirstImageInList(images);\n      write_info=CloneImageInfo(image_info);\n      write_info->adjoin=MagickTrue;\n      (void) CopyMagickString(write_info->magick,\"TIFF\",MagickPathExtent);\n      (void) CopyMagickString(images->magick,\"TIFF\",MagickPathExtent);\n      status=WriteTIFFImage(write_info,images,exception);\n      images=DestroyImageList(images);\n      write_info=DestroyImageInfo(write_info);\n    }\n  return(status);\n}", "target": 0}
{"code": "dirserv_set_cached_directory(const char *directory, time_t published,\n                             int is_running_routers)\n{\n  time_t now = time(NULL);\n  if (is_running_routers) {\n    if (published >= now - MAX_V1_RR_AGE)\n      set_cached_dir(&cached_runningrouters, tor_strdup(directory), published);\n  } else {\n    if (published >= now - MAX_V1_DIRECTORY_AGE) {\n      cached_dir_decref(cached_directory);\n      cached_directory = new_cached_dir(tor_strdup(directory), published);\n    }\n  }\n}", "target": 0}
{"code": "void __detach_mounts(struct dentry *dentry)\n{\n\tstruct mountpoint *mp;\n\tstruct mount *mnt;\n\tnamespace_lock();\n\tmp = lookup_mountpoint(dentry);\n\tif (IS_ERR_OR_NULL(mp))\n\t\tgoto out_unlock;\n\tlock_mount_hash();\n\twhile (!hlist_empty(&mp->m_list)) {\n\t\tmnt = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list);\n\t\tif (mnt->mnt.mnt_flags & MNT_UMOUNT) {\n\t\t\tstruct mount *p, *tmp;\n\t\t\tlist_for_each_entry_safe(p, tmp, &mnt->mnt_mounts,  mnt_child) {\n\t\t\t\thlist_add_head(&p->mnt_umount.s_list, &unmounted);\n\t\t\t\tumount_mnt(p);\n\t\t\t}\n\t\t}\n\t\telse umount_tree(mnt, 0);\n\t}\n\tunlock_mount_hash();\n\tput_mountpoint(mp);\nout_unlock:\n\tnamespace_unlock();\n}", "target": 1}
{"code": "lyd_new_anydata(struct lyd_node *parent, const struct lys_module *module, const char *name,\n                void *value, LYD_ANYDATA_VALUETYPE value_type)\n{\n    const struct lys_node *siblings, *snode;\n    if ((!parent && !module) || !name) {\n        LOGARG;\n        return NULL;\n    }\n    siblings = lyd_new_find_schema(parent, module, 0);\n    if (!siblings) {\n        LOGARG;\n        return NULL;\n    }\n    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_ANYDATA, &snode) || !snode) {\n        LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",\n               name, lys_node_module(siblings)->name, siblings->name);\n        return NULL;\n    }\n    return lyd_create_anydata(parent, snode, value, value_type);\n}", "target": 1}
{"code": "poly_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\tPOLYGON    *poly;\n\tint\t\t\tnpts;\n\tint\t\t\tsize;\n\tint\t\t\tisopen;\n\tchar\t   *s;\n\tif ((npts = pair_count(str, ',')) <= 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t  errmsg(\"invalid input syntax for type polygon: \\\"%s\\\"\", str)));\n\tsize = offsetof(POLYGON, p[0]) +sizeof(poly->p[0]) * npts;\n\tpoly = (POLYGON *) palloc0(size);\t\n\tSET_VARSIZE(poly, size);\n\tpoly->npts = npts;\n\tif ((!path_decode(FALSE, npts, str, &isopen, &s, &(poly->p[0])))\n\t\t|| (*s != '\\0'))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t  errmsg(\"invalid input syntax for type polygon: \\\"%s\\\"\", str)));\n\tmake_bound_box(poly);\n\tPG_RETURN_POLYGON_P(poly);\n}", "target": 1}
{"code": "header_seek (SF_PRIVATE *psf, sf_count_t position, int whence)\n{\n\tswitch (whence)\n\t{\tcase SEEK_SET :\n\t\t\tif (position > SIGNED_SIZEOF (psf->header))\n\t\t\t{\t\n\t\t\t\tpsf_fseek (psf, position, whence) ;\n\t\t\t\treturn ;\n\t\t\t\t} ;\n\t\t\tif (position > psf->headend)\n\t\t\t\tpsf->headend += psf_fread (psf->header + psf->headend, 1, position - psf->headend, psf) ;\n\t\t\tpsf->headindex = position ;\n\t\t\tbreak ;\n\t\tcase SEEK_CUR :\n\t\t\tif (psf->headindex + position < 0)\n\t\t\t\tbreak ;\n\t\t\tif (psf->headindex >= SIGNED_SIZEOF (psf->header))\n\t\t\t{\tpsf_fseek (psf, position, whence) ;\n\t\t\t\treturn ;\n\t\t\t\t} ;\n\t\t\tif (psf->headindex + position <= psf->headend)\n\t\t\t{\tpsf->headindex += position ;\n\t\t\t\tbreak ;\n\t\t\t\t} ;\n\t\t\tif (psf->headindex + position > SIGNED_SIZEOF (psf->header))\n\t\t\t{\t\n\t\t\t\tpsf->headindex = psf->headend ;\n\t\t\t\tpsf_fseek (psf, position, SEEK_CUR) ;\n\t\t\t\tbreak ;\n\t\t\t\t} ;\n\t\t\tpsf->headend += psf_fread (psf->header + psf->headend, 1, position - (psf->headend - psf->headindex), psf) ;\n\t\t\tpsf->headindex = psf->headend ;\n\t\t\tbreak ;\n\t\tcase SEEK_END :\n\t\tdefault :\n\t\t\tpsf_log_printf (psf, \"Bad whence param in header_seek().\\n\") ;\n\t\t\tbreak ;\n\t\t} ;\n\treturn ;\n} ", "target": 1}
{"code": "static void test_on_link_flow_on(void* context)\n{\n    (void)context;\n}", "target": 0}
{"code": "static int wc_ecc_gen_k(WC_RNG* rng, int size, mp_int* k, mp_int* order)\n{\n    int err;\n#ifdef WOLFSSL_SMALL_STACK\n    byte* buf;\n#else\n    byte  buf[ECC_MAXSIZE_GEN];\n#endif\n#ifdef WOLFSSL_SMALL_STACK\n    buf = (byte*)XMALLOC(ECC_MAXSIZE_GEN, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n    if (buf == NULL)\n        return MEMORY_E;\n#endif\n    size += 8;\n    err = wc_RNG_GenerateBlock(rng, buf, size);\n    if (err == 0)\n        err = mp_read_unsigned_bin(k, (byte*)buf, size);\n    if (err == MP_OKAY) {\n        if (mp_iszero(k) == MP_YES)\n          err = MP_ZERO_E;\n    }\n    if (err == MP_OKAY) {\n        if (mp_cmp(k, order) != MP_LT) {\n            err = mp_mod(k, order, k);\n        }\n    }\n    ForceZero(buf, ECC_MAXSIZE);\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(buf, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n#endif\n    return err;\n}", "target": 1}
{"code": "static void nested_vmx_failInvalid(struct kvm_vcpu *vcpu)\n{\n\tvmx_set_rflags(vcpu, (vmx_get_rflags(vcpu)\n\t\t\t& ~(X86_EFLAGS_PF | X86_EFLAGS_AF | X86_EFLAGS_ZF |\n\t\t\t    X86_EFLAGS_SF | X86_EFLAGS_OF))\n\t\t\t| X86_EFLAGS_CF);\n}", "target": 0}
{"code": "agoo_http_init() {\n    const char\t**kp = header_keys;\n    memset(&key_cache, 0, sizeof(struct _cache));\n    for (; NULL != *kp; kp++) {\n\tkey_set(*kp);\n    }\n}", "target": 1}
{"code": "error::Error GLES2DecoderImpl::HandleDestroyStreamTextureCHROMIUM(\n    uint32 immediate_data_size,\n    const gles2::DestroyStreamTextureCHROMIUM& c) {\n  GLuint client_id = c.texture;\n  TextureManager::TextureInfo* info =\n      texture_manager()->GetTextureInfo(client_id);\n  if (info && info->IsStreamTexture()) {\n    if (!stream_texture_manager_)\n      return error::kInvalidArguments;\n    stream_texture_manager_->DestroyStreamTexture(info->service_id());\n    info->SetStreamTexture(false);\n    texture_manager()->SetInfoTarget(info, 0);\n  } else {\n    SetGLError(GL_INVALID_VALUE,\n               \"glDestroyStreamTextureCHROMIUM: bad texture id.\");\n  }\n  return error::kNoError;\n}", "target": 0}
{"code": "void gdImageSetThickness (gdImagePtr im, int thickness)\n{\n\tim->thick = thickness;\n}", "target": 0}
{"code": "static int irda_sendmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\tstruct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct irda_sock *self;\n\tstruct sk_buff *skb;\n\tint err = -EPIPE;\n\tIRDA_DEBUG(4, \"%s(), len=%zd\\n\", __func__, len);\n\tif (msg->msg_flags & ~(MSG_DONTWAIT | MSG_EOR | MSG_CMSG_COMPAT |\n\t\t\t       MSG_NOSIGNAL))\n\t\treturn -EINVAL;\n\tif (sk->sk_shutdown & SEND_SHUTDOWN)\n\t\tgoto out_err;\n\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\treturn -ENOTCONN;\n\tself = irda_sk(sk);\n\tif (wait_event_interruptible(*(sk->sk_sleep),\n\t    (self->tx_flow != FLOW_STOP  ||  sk->sk_state != TCP_ESTABLISHED)))\n\t\treturn -ERESTARTSYS;\n\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\treturn -ENOTCONN;\n\tif (len > self->max_data_size) {\n\t\tIRDA_DEBUG(2, \"%s(), Chopping frame from %zd to %d bytes!\\n\",\n\t\t\t   __func__, len, self->max_data_size);\n\t\tlen = self->max_data_size;\n\t}\n\tskb = sock_alloc_send_skb(sk, len + self->max_header_size + 16,\n\t\t\t\t  msg->msg_flags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\tgoto out_err;\n\tskb_reserve(skb, self->max_header_size + 16);\n\tskb_reset_transport_header(skb);\n\tskb_put(skb, len);\n\terr = memcpy_fromiovec(skb_transport_header(skb), msg->msg_iov, len);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\tgoto out_err;\n\t}\n\terr = irttp_data_request(self->tsap, skb);\n\tif (err) {\n\t\tIRDA_DEBUG(0, \"%s(), err=%d\\n\", __func__, err);\n\t\tgoto out_err;\n\t}\n\treturn len;\n out_err:\n\treturn sk_stream_error(sk, msg->msg_flags, err);\n}", "target": 0}
{"code": "find_entry(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n\tback_txn *txn\n)\n{\n\treturn( find_entry_internal( pb, be, addr, 0, txn, 0 ) );\n}", "target": 1}
{"code": "void json_object_seed(size_t seed) {\n    uint32_t new_seed = (uint32_t)seed;\n    if (hashtable_seed == 0) {\n        if (__atomic_test_and_set(&seed_initialized, __ATOMIC_RELAXED) == 0) {\n            if (new_seed == 0)\n                new_seed = generate_seed();\n            __atomic_store_n(&hashtable_seed, new_seed, __ATOMIC_ACQ_REL);\n        } else {\n            do {\n#ifdef HAVE_SCHED_YIELD\n                sched_yield();\n#endif\n            } while(__atomic_load_n(&hashtable_seed, __ATOMIC_ACQUIRE) == 0);\n        }\n    }\n}", "target": 0}
{"code": "spnego_gss_inquire_saslname_for_mech(OM_uint32 *minor_status,\n                                     const gss_OID desired_mech,\n                                     gss_buffer_t sasl_mech_name,\n                                     gss_buffer_t mech_name,\n                                     gss_buffer_t mech_description)\n{\n\t*minor_status = 0;\n\tif (!g_OID_equal(desired_mech, gss_mech_spnego))\n\t\treturn (GSS_S_BAD_MECH);\n\tif (!g_make_string_buffer(SPNEGO_SASL_NAME, sasl_mech_name) ||\n\t    !g_make_string_buffer(\"spnego\", mech_name) ||\n\t    !g_make_string_buffer(\"Simple and Protected GSS-API \"\n\t\t\t\t  \"Negotiation Mechanism\", mech_description))\n\t\tgoto fail;\n\treturn (GSS_S_COMPLETE);\nfail:\n\t*minor_status = ENOMEM;\n\treturn (GSS_S_FAILURE);\n}", "target": 0}
{"code": "static void ClearMetadata(VP8LMetadata* const hdr) {\n  assert(hdr != NULL);\n  WebPSafeFree(hdr->huffman_image_);\n  WebPSafeFree(hdr->huffman_tables_);\n  VP8LHtreeGroupsFree(hdr->htree_groups_);\n  VP8LColorCacheClear(&hdr->color_cache_);\n  VP8LColorCacheClear(&hdr->saved_color_cache_);\n  InitMetadata(hdr);\n}", "target": 1}
{"code": "static int sip_endpoint_identifier_str2type(const char *str)\n{\n\tint method;\n\tif (!strcasecmp(str, \"username\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_USERNAME;\n\t} else if (!strcasecmp(str, \"auth_username\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_AUTH_USERNAME;\n\t} else if (!strcasecmp(str, \"ip\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_IP;\n\t} else if (!strcasecmp(str, \"header\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_HEADER;\n\t} else if (!strcasecmp(str, \"request_uri\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_REQUEST_URI;\n\t} else if (!strcasecmp(str, \"transport\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_TRANSPORT;\n\t} else {\n\t\tmethod = -1;\n\t}\n\treturn method;\n}", "target": 1}
{"code": "static int ntlm_read_ntlm_v2_client_challenge(wStream* s, NTLMv2_CLIENT_CHALLENGE* challenge)\n{\n\tsize_t size;\n\tif (Stream_GetRemainingLength(s) < 28)\n\t\treturn -1;\n\tStream_Read_UINT8(s, challenge->RespType);\n\tStream_Read_UINT8(s, challenge->HiRespType);\n\tStream_Read_UINT16(s, challenge->Reserved1);\n\tStream_Read_UINT32(s, challenge->Reserved2);\n\tStream_Read(s, challenge->Timestamp, 8);\n\tStream_Read(s, challenge->ClientChallenge, 8);\n\tStream_Read_UINT32(s, challenge->Reserved3);\n\tsize = Stream_Length(s) - Stream_GetPosition(s);\n\tif (size > UINT32_MAX)\n\t\treturn -1;\n\tchallenge->cbAvPairs = size;\n\tchallenge->AvPairs = (NTLM_AV_PAIR*)malloc(challenge->cbAvPairs);\n\tif (!challenge->AvPairs)\n\t\treturn -1;\n\tStream_Read(s, challenge->AvPairs, size);\n\treturn 1;\n}", "target": 0}
{"code": "static inline void verify_event(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t void *event)\n{\n}", "target": 0}
{"code": "M_bool M_fs_path_ishidden(const char *path, M_fs_info_t *info)\n{\n\tM_list_str_t *path_parts;\n\tsize_t        len;\n\tM_bool        ret        = M_FALSE;\n\t(void)info;\n\tif (path == NULL || *path == '\\0') {\n\t\treturn M_FALSE;\n\t}\n\tpath_parts = M_fs_path_componentize_path(path, M_FS_SYSTEM_UNIX);\n\tlen = M_list_str_len(path_parts);\n\tif (len > 0) {\n\t\tif (*M_list_str_at(path_parts, len-1) == '.') {\n\t\t\tret = M_TRUE;\n\t\t}\n\t}\n\tM_list_str_destroy(path_parts);\n\treturn ret;\n}", "target": 1}
{"code": "static struct desc_struct *get_desc(unsigned short sel)\n{\n\tstruct desc_ptr gdt_desc = {0, 0};\n\tunsigned long desc_base;\n#ifdef CONFIG_MODIFY_LDT_SYSCALL\n\tif ((sel & SEGMENT_TI_MASK) == SEGMENT_LDT) {\n\t\tstruct desc_struct *desc = NULL;\n\t\tstruct ldt_struct *ldt;\n\t\tsel >>= 3;\n\t\tmutex_lock(&current->active_mm->context.lock);\n\t\tldt = current->active_mm->context.ldt;\n\t\tif (ldt && sel < ldt->nr_entries)\n\t\t\tdesc = &ldt->entries[sel];\n\t\tmutex_unlock(&current->active_mm->context.lock);\n\t\treturn desc;\n\t}\n#endif\n\tnative_store_gdt(&gdt_desc);\n\tdesc_base = sel & ~(SEGMENT_RPL_MASK | SEGMENT_TI_MASK);\n\tif (desc_base > gdt_desc.size)\n\t\treturn NULL;\n\treturn (struct desc_struct *)(gdt_desc.address + desc_base);\n}", "target": 1}
{"code": "static void xen_invalidate_io_bitmap(void)\n{\n\tstruct physdev_set_iobitmap iobitmap = {\n\t\t.bitmap = 0,\n\t\t.nr_ports = 0,\n\t};\n\tnative_tss_invalidate_io_bitmap();\n\tHYPERVISOR_physdev_op(PHYSDEVOP_set_iobitmap, &iobitmap);\n}", "target": 0}
{"code": "gen_values(codegen_scope *s, node *t, int val, int limit)\n{\n  int n = 0;\n  int first = 1;\n  int slimit = GEN_VAL_STACK_MAX;\n  if (limit == 0) limit = GEN_LIT_ARY_MAX;\n  if (cursp() >= slimit) slimit = INT16_MAX;\n  if (!val) {\n    while (t) {\n      codegen(s, t->car, NOVAL);\n      n++;\n      t = t->cdr;\n    }\n    return n;\n  }\n  while (t) {\n    int is_splat = nint(t->car->car) == NODE_SPLAT;\n    if (is_splat || n > limit || cursp() >= slimit) { \n      pop_n(n);\n      if (first) {\n        if (n == 0) {\n          genop_1(s, OP_LOADNIL, cursp());\n        }\n        else {\n          genop_2(s, OP_ARRAY, cursp(), n);\n        }\n        push();\n        first = 0;\n        limit = GEN_LIT_ARY_MAX;\n      }\n      else if (n > 0) {\n        pop();\n        genop_2(s, OP_ARYPUSH, cursp(), n);\n        push();\n      }\n      n = 0;\n    }\n    codegen(s, t->car, val);\n    if (is_splat) {\n      pop(); pop();\n      genop_1(s, OP_ARYCAT, cursp());\n      push();\n    }\n    else {\n      n++;\n    }\n    t = t->cdr;\n  }\n  if (!first) {\n    pop();\n    if (n > 0) {\n      pop_n(n);\n      genop_2(s, OP_ARYPUSH, cursp(), n);\n    }\n    return -1;                  \n  }\n  return n;\n}", "target": 1}
{"code": "int nntp_add_group(char *line, void *data)\n{\n  struct NntpServer *nserv = data;\n  struct NntpData *nntp_data = NULL;\n  char group[LONG_STRING];\n  char desc[HUGE_STRING] = \"\";\n  char mod;\n  anum_t first, last;\n  if (!nserv || !line)\n    return 0;\n  if (sscanf(line, \"%s \" ANUM \" \" ANUM \" %c %[^\\n]\", group, &last, &first, &mod, desc) < 4)\n    return 0;\n  nntp_data = nntp_data_find(nserv, group);\n  nntp_data->deleted = false;\n  nntp_data->first_message = first;\n  nntp_data->last_message = last;\n  nntp_data->allowed = (mod == 'y') || (mod == 'm');\n  mutt_str_replace(&nntp_data->desc, desc);\n  if (nntp_data->newsrc_ent || nntp_data->last_cached)\n    nntp_group_unread_stat(nntp_data);\n  else if (nntp_data->last_message && nntp_data->first_message <= nntp_data->last_message)\n    nntp_data->unread = nntp_data->last_message - nntp_data->first_message + 1;\n  else\n    nntp_data->unread = 0;\n  return 0;\n}", "target": 1}
{"code": "  void operator()(const CPUDevice& d, typename TTypes<T>::ConstVec input,\n                  const bool signed_input, const int num_bits,\n                  const bool range_given, Tensor* input_min_tensor,\n                  Tensor* input_max_tensor, QuantizerRoundMode round_mode,\n                  bool narrow_range, typename TTypes<T>::Vec out) {\n    QuantizeAndDequantizeOneScaleImpl<CPUDevice, T>::Compute(\n        d, input, signed_input, num_bits, range_given, input_min_tensor,\n        input_max_tensor, round_mode, narrow_range, out);\n  }", "target": 1}
{"code": "void PrintWebViewHelper::PrintPreviewContext::InitWithNode(\n    const WebKit::WebNode& web_node) {\n  DCHECK(!web_node.isNull());\n  DCHECK(!IsRendering());\n  state_ = INITIALIZED;\n  frame_ = web_node.document().frame();\n  node_ = web_node;\n}", "target": 0}
{"code": "void PDFiumEngine::ScrollToPage(int page) {\n  in_flight_visible_page_ = page;\n  client_->ScrollToPage(page);\n}", "target": 0}
{"code": "static inline zend_object_value date_object_new_date_ex(zend_class_entry *class_type, php_date_obj **ptr TSRMLS_DC)\n{\n\tphp_date_obj *intern;\n\tzend_object_value retval;\n\tintern = emalloc(sizeof(php_date_obj));\n\tmemset(intern, 0, sizeof(php_date_obj));\n\tif (ptr) {\n\t\t*ptr = intern;\n\t}\n\tzend_object_std_init(&intern->std, class_type TSRMLS_CC);\n\tobject_properties_init(&intern->std, class_type);\n\tretval.handle = zend_objects_store_put(intern, (zend_objects_store_dtor_t)zend_objects_destroy_object, (zend_objects_free_object_storage_t) date_object_free_storage_date, NULL TSRMLS_CC);\n\tretval.handlers = &date_object_handlers_date;\n\treturn retval;", "target": 0}
{"code": "init_resources(X509 *x509, enum rpki_policy policy, enum cert_type type,\n    struct resources **_result)\n{\n\tstruct resources *result;\n\tint error;\n\tresult = resources_create(false);\n\tif (result == NULL)\n\t\treturn pr_enomem();\n\tresources_set_policy(result, policy);\n\terror = certificate_get_resources(x509, result, type);\n\tif (error)\n\t\tgoto fail;\n\tif (type == TA && resources_empty(result)) {\n\t\terror = pr_val_err(\"Trust Anchor certificate does not define any number resources.\");\n\t\tgoto fail;\n\t}\n\t*_result = result;\n\treturn 0;\nfail:\n\tresources_destroy(result);\n\treturn error;\n}", "target": 0}
{"code": "  CrxImage() : memmgr(0){}", "target": 0}
{"code": "Http::FilterMetadataStatus Context::onResponseMetadata() {\n  if (!wasm_->onResponseMetadata_) {\n    return Http::FilterMetadataStatus::Continue;\n  }\n  if (wasm_->onResponseMetadata_(this, id_).u64_ == 0) {\n    return Http::FilterMetadataStatus::Continue;\n  }\n  return Http::FilterMetadataStatus::Continue; \n}", "target": 1}
{"code": "TEST(EqOp, ElemMatchKeyWithImplicitAndExplicitTraversal) {\n    BSONObj operand = BSON(\"a.0.b\" << 3);\n    BSONElement operandFirstElt = operand.firstElement();\n    EqualityMatchExpression eq(operandFirstElt.fieldName(), operandFirstElt);\n    MatchDetails details;\n    details.requestElemMatchKey();\n    BSONObj obj = fromjson(\"{a: [{b: [2, 3]}, {b: [4, 5]}]}\");\n    ASSERT(eq.matchesBSON(obj, &details));\n    ASSERT(details.hasElemMatchKey());\n    ASSERT_EQUALS(\"1\", details.elemMatchKey());\n}", "target": 0}
{"code": "static void _ewk_view_on_mouse_move(void* data, Evas* eventType, Evas_Object* callback, void* eventInfo)\n{\n    Evas_Event_Mouse_Move* moveEvent = static_cast<Evas_Event_Mouse_Move*>(eventInfo);\n    Ewk_View_Smart_Data* smartData = static_cast<Ewk_View_Smart_Data*>(data);\n    EINA_SAFETY_ON_NULL_RETURN(smartData->api);\n    EINA_SAFETY_ON_NULL_RETURN(smartData->api->mouse_move);\n    smartData->api->mouse_move(smartData, moveEvent);\n}", "target": 0}
{"code": "path_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\tPATH\t   *path;\n\tint\t\t\tisopen;\n\tchar\t   *s;\n\tint\t\t\tnpts;\n\tint\t\t\tsize;\n\tint\t\t\tdepth = 0;\n\tif ((npts = pair_count(str, ',')) <= 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type path: \\\"%s\\\"\", str)));\n\ts = str;\n\twhile (isspace((unsigned char) *s))\n\t\ts++;\n\tif ((*s == LDELIM) && (strrchr(s, LDELIM) == s))\n\t{\n\t\ts++;\n\t\tdepth++;\n\t}\n\tsize = offsetof(PATH, p[0]) +sizeof(path->p[0]) * npts;\n\tpath = (PATH *) palloc(size);\n\tSET_VARSIZE(path, size);\n\tpath->npts = npts;\n\tif ((!path_decode(TRUE, npts, s, &isopen, &s, &(path->p[0])))\n\t&& (!((depth == 0) && (*s == '\\0'))) && !((depth >= 1) && (*s == RDELIM)))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type path: \\\"%s\\\"\", str)));\n\tpath->closed = (!isopen);\n\tpath->dummy = 0;\n\tPG_RETURN_PATH_P(path);\n}", "target": 1}
{"code": "static void flush(AVCodecContext *avctx)\n{\n    AACContext *ac= avctx->priv_data;\n    int type, i, j;\n    for (type = 3; type >= 0; type--) {\n        for (i = 0; i < MAX_ELEM_ID; i++) {\n            ChannelElement *che = ac->che[type][i];\n            if (che) {\n                for (j = 0; j <= 1; j++) {\n                    memset(che->ch[j].saved, 0, sizeof(che->ch[j].saved));\n                }\n            }\n        }\n    }\n}", "target": 0}
{"code": "String string_chunk_split(const char *src, int srclen, const char *end,\n                          int endlen, int chunklen) {\n  int chunks = srclen / chunklen; \n  int restlen = srclen - chunks * chunklen; \n  int out_len = (chunks + 1) * endlen + srclen;\n  String ret(out_len, ReserveString);\n  char *dest = ret.bufferSlice().ptr;\n  const char *p; char *q;\n  const char *pMax = src + srclen - chunklen + 1;\n  for (p = src, q = dest; p < pMax; ) {\n    memcpy(q, p, chunklen);\n    q += chunklen;\n    memcpy(q, end, endlen);\n    q += endlen;\n    p += chunklen;\n  }\n  if (restlen) {\n    memcpy(q, p, restlen);\n    q += restlen;\n    memcpy(q, end, endlen);\n    q += endlen;\n  }\n  ret.setSize(q - dest);\n  return ret;\n}", "target": 1}
{"code": "int zmq::stream_engine_t::decode_and_push (msg_t *msg_)\n{\n    zmq_assert (mechanism != NULL);\n    if (mechanism->decode (msg_) == -1)\n        return -1;\n    if (metadata)\n        msg_->set_metadata (metadata);\n    if (session->push_msg (msg_) == -1) {\n        if (errno == EAGAIN)\n            process_msg = &stream_engine_t::push_one_then_decode_and_push;\n        return -1;\n    }\n    return 0;\n}", "target": 0}
{"code": "static inline ut8 r_read_le8(const void *src) {\n\tif (!src) {\n\t\treturn UT8_MAX;\n\t}\n\treturn r_read_ble8 (src);\n}", "target": 0}
{"code": "static CURLcode smtp_connect(struct connectdata *conn,\n                             bool *done) \n{\n  CURLcode result;\n  struct smtp_conn *smtpc = &conn->proto.smtpc;\n  struct SessionHandle *data = conn->data;\n  struct pingpong *pp = &smtpc->pp;\n  const char *path = conn->data->state.path;\n  int len;\n  char localhost[HOSTNAME_MAX + 1];\n  *done = FALSE; \n  Curl_reset_reqproto(conn);\n  result = smtp_init(conn);\n  if(CURLE_OK != result)\n    return result;\n  conn->bits.close = FALSE;\n  pp->response_time = RESP_TIMEOUT; \n  pp->statemach_act = smtp_statemach_act;\n  pp->endofresp = smtp_endofresp;\n  pp->conn = conn;\n  if(conn->bits.tunnel_proxy && conn->bits.httpproxy) {\n    struct HTTP http_proxy;\n    struct FTP *smtp_save;\n    smtp_save = data->state.proto.smtp;\n    memset(&http_proxy, 0, sizeof(http_proxy));\n    data->state.proto.http = &http_proxy;\n    result = Curl_proxyCONNECT(conn, FIRSTSOCKET,\n                               conn->host.name, conn->remote_port);\n    data->state.proto.smtp = smtp_save;\n    if(CURLE_OK != result)\n      return result;\n  }\n  if((conn->handler->protocol & CURLPROTO_SMTPS) &&\n      data->state.used_interface != Curl_if_multi) {\n    result = Curl_ssl_connect(conn, FIRSTSOCKET);\n    if(result)\n      return result;\n  }\n  Curl_pp_init(pp); \n  pp->response_time = RESP_TIMEOUT; \n  pp->statemach_act = smtp_statemach_act;\n  pp->endofresp = smtp_endofresp;\n  pp->conn = conn;\n  if(!*path) {\n    if(!Curl_gethostname(localhost, sizeof localhost))\n      path = localhost;\n    else\n      path = \"localhost\";\n  }\n  smtpc->domain = curl_easy_unescape(conn->data, path, 0, &len);\n  if(!smtpc->domain)\n    return CURLE_OUT_OF_MEMORY;\n  state(conn, SMTP_SERVERGREET);\n  if(data->state.used_interface == Curl_if_multi)\n    result = smtp_multi_statemach(conn, done);\n  else {\n    result = smtp_easy_statemach(conn);\n    if(!result)\n      *done = TRUE;\n  }\n  return result;\n}", "target": 1}
{"code": "_pyfribidi_log2vis (PyObject * self, PyObject * args, PyObject * kw)\n{\n\tPyObject *logical = NULL;\t\n\tFriBidiParType base = FRIBIDI_TYPE_RTL;\t\n\tconst char *encoding = \"utf-8\";\t\n\tint clean = 0; \n\tint reordernsm = 1; \n\tstatic char *kwargs[] =\n\t        { \"logical\", \"base_direction\", \"encoding\", \"clean\", \"reordernsm\", NULL };\n        if (!PyArg_ParseTupleAndKeywords (args, kw, \"O|isii\", kwargs,\n\t\t\t\t\t  &logical, &base, &encoding, &clean, &reordernsm))\n\t\treturn NULL;\n\tif (!(base == FRIBIDI_TYPE_RTL ||\n\t      base == FRIBIDI_TYPE_LTR || base == FRIBIDI_TYPE_ON))\n\t\treturn PyErr_Format (PyExc_ValueError,\n\t\t\t\t     \"invalid value %d: use either RTL, LTR or ON\",\n\t\t\t\t     base);\n\tif (PyUnicode_Check (logical))\n\t        return log2vis_unicode (logical, base, clean, reordernsm);\n\telse if (PyString_Check (logical))\n\t        return log2vis_encoded_string (logical, encoding, base, clean, reordernsm);\n\telse\n\t\treturn PyErr_Format (PyExc_TypeError,\n\t\t\t\t     \"expected unicode or str, not %s\",\n\t\t\t\t     logical->ob_type->tp_name);\n}", "target": 1}
{"code": "static void php_array_replace_recursive(PointerSet &seen, bool check,\n                                        Array &arr1, const Array& arr2) {\n  if (arr1.get() == arr2.get()) {\n    return;\n  }\n  if (check && !seen.insert((void*)arr1.get()).second) {\n    raise_warning(\"array_replace_recursive(): recursion detected\");\n    return;\n  }\n  for (ArrayIter iter(arr2); iter; ++iter) {\n    Variant key = iter.first();\n    const Variant& value = iter.secondRef();\n    if (arr1.exists(key, true) && value.isArray()) {\n      Variant &v = arr1.lvalAt(key, AccessFlags::Key);\n      if (v.isArray()) {\n        Array subarr1 = v.toArray();\n        const ArrNR& arr_value = value.toArrNR();\n        php_array_replace_recursive(seen, couldRecur(v, subarr1.get()),\n                                    subarr1, arr_value);\n        v = subarr1;\n      } else {\n        arr1.set(key, value, true);\n      }\n    } else {\n      arr1.setWithRef(key, value, true);\n    }\n  }\n  if (check) {\n    seen.erase((void*)arr1.get());\n  }\n}", "target": 0}
{"code": "static int xen_netbk_get_extras(struct xenvif *vif,\n\t\t\t\tstruct xen_netif_extra_info *extras,\n\t\t\t\tint work_to_do)\n{\n\tstruct xen_netif_extra_info extra;\n\tRING_IDX cons = vif->tx.req_cons;\n\tdo {\n\t\tif (unlikely(work_to_do-- <= 0)) {\n\t\t\tnetdev_dbg(vif->dev, \"Missing extra info\\n\");\n\t\t\treturn -EBADR;\n\t\t}\n\t\tmemcpy(&extra, RING_GET_REQUEST(&vif->tx, cons),\n\t\t       sizeof(extra));\n\t\tif (unlikely(!extra.type ||\n\t\t\t     extra.type >= XEN_NETIF_EXTRA_TYPE_MAX)) {\n\t\t\tvif->tx.req_cons = ++cons;\n\t\t\tnetdev_dbg(vif->dev,\n\t\t\t\t   \"Invalid extra type: %d\\n\", extra.type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmemcpy(&extras[extra.type - 1], &extra, sizeof(extra));\n\t\tvif->tx.req_cons = ++cons;\n\t} while (extra.flags & XEN_NETIF_EXTRA_FLAG_MORE);\n\treturn work_to_do;\n}", "target": 1}
{"code": "\t\tvoid PdfTranslator::setSource ( const std::string & source )\n\t\t{\n\t\t\tint dbg(0);\n\t\t\tstd::cerr<< ++dbg <<std::endl;\n\t\t\tif ( checkIsPDF ( source ) )\n\t\t\t{\n\t\t\t\tmultiSource.push_back ( source );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tifstream in ( source.c_str(), ifstream::in );\n\t\t\t\tif ( !in.good() )\n\t\t\t\t\tthrow runtime_error ( \"setSource() failed to open input file\" );\n\t\t\t\tchar *filenameBuffer = new char[1000];\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tin.getline ( filenameBuffer, 1000 );\n\t\t\t\t\tstd::string ts ( filenameBuffer, in.gcount() );\n\t\t\t\t\tif ( ts.size() > 4 ) \n\t\t\t\t\t{\n\t\t\t\t\t\tmultiSource.push_back ( ts );\n\t\t\t\t\t\tstd::cerr << \"Appending \"<< ts <<\" to source\" << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile ( !in.eof() );\n\t\t\t\tin.close();\n\t\t\t\tdelete [] filenameBuffer;\n\t\t\t}\n\t\t\tstd::cerr<< ++dbg <<std::endl;\n\t\t\tfor ( std::vector<std::string>::const_iterator ms = multiSource.begin(); ms != multiSource.end(); ++ms )\n\t\t\t{\n\t\t\t\tif ( ms == multiSource.begin() )\n\t\t\t\t{\n\t\t\t\t\ttry{\n\t\t\t\t\t\tsourceDoc = new PdfMemDocument ( ( *ms ).c_str() );\n\t\t\t\t\t}\n\t\t\t\t\tcatch(PdfError& e)\n\t\t\t\t\t{\n                        std::cerr << \"Unable to create Document: \" << PdfError::ErrorMessage( e.GetError() ) << std::endl;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tPdfMemDocument mdoc ( ( *ms ).c_str() );\n\t\t\t\t\tsourceDoc->InsertPages ( mdoc, 0, mdoc.GetPageCount() );\n\t\t\t\t}\n\t\t\t}\n\t\t\tpcount = sourceDoc->GetPageCount();\n\t\t\tif ( pcount > 0 ) \n\t\t\t{\n\t\t\t\tPoDoFo::PdfRect rect ( sourceDoc->GetPage ( 0 )->GetMediaBox() );\n\t\t\t\tsourceWidth =  rect.GetWidth() - rect.GetLeft();\n\t\t\t\tsourceHeight =  rect.GetHeight() - rect.GetBottom() ;\n\t\t\t}\n\t\t}", "target": 1}
{"code": "void LogOmniboxZeroSuggestRequest(\n    ZeroSuggestRequestsHistogramValue request_value) {\n  UMA_HISTOGRAM_ENUMERATION(\"Omnibox.ZeroSuggestRequests\", request_value,\n                            ZERO_SUGGEST_MAX_REQUEST_HISTOGRAM_VALUE);\n}", "target": 0}
{"code": "STACK_OF(PKCS12_SAFEBAG) *PKCS12_unpack_p7data(PKCS7 *p7)\n{\n    if (!PKCS7_type_is_data(p7)) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_CONTENT_TYPE_NOT_DATA);\n        return NULL;\n    }\n    if (p7->d.data == NULL) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_DECODE_ERROR);\n        return NULL;\n    }\n    return ASN1_item_unpack(p7->d.data, ASN1_ITEM_rptr(PKCS12_SAFEBAGS));\n}", "target": 0}
{"code": "find_entry_internal(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n    int\t\t\tlock,\n\tback_txn *txn,\n\tint flags\n)\n{\n\tif (addr->uniqueid!=NULL)\n\t{\n\t\tLDAPDebug( LDAP_DEBUG_TRACE, \"=> find_entry_internal (uniqueid=%s) lock %d\\n\",\n\t\t    addr->uniqueid, lock, 0 );\n\t\treturn (find_entry_internal_uniqueid (pb, be, addr->uniqueid, lock, txn));\n\t}\n\telse\n\t{\n\t\tstruct backentry *entry = NULL;\n\t\tLDAPDebug( LDAP_DEBUG_TRACE, \"=> find_entry_internal (dn=%s) lock %d\\n\",\n\t\t           slapi_sdn_get_dn(addr->sdn), lock, 0 );\n\t\tif (addr->sdn) {\n\t\t\tentry = find_entry_internal_dn (pb, be, addr->sdn, \n\t\t\t                                lock, txn, flags);\n\t\t} else {\n\t\t\tLDAPDebug0Args( LDAP_DEBUG_ANY,\n\t\t\t                \"find_entry_internal: Null target dn\\n\" );\n\t\t}\n\t\tLDAPDebug0Args( LDAP_DEBUG_TRACE, \"<= find_entry_internal\\n\" );\n\t\treturn entry;\n\t}\n}", "target": 1}
{"code": "uint WavInFile::getSampleRate() const\n{\n    return header.format.sample_rate;\n}", "target": 0}
{"code": "pq_buffer_has_data(void)\n{\n\treturn (PqRecvPointer < PqRecvLength);\n}", "target": 0}
{"code": "static bool max_queue_pairs_gt_1(void *opaque, int version_id)\n{\n    return VIRTIO_NET(opaque)->max_queue_pairs > 1;\n}", "target": 0}
{"code": "static void wipe_keys()\n{\n\tmemset(cmac_key, 0, sizeof(cmac_key));\n\tmemset(cipher_key, 0, sizeof(cipher_key));\n\tmemset(iv, 0, sizeof(iv));\n}", "target": 0}
{"code": "static gboolean has_internal_nul(const char* str, int len) {\n\twhile (len > 0 && str[len-1] == 0)\n\t\tlen--;\n\treturn strlen(str) != len;\n}", "target": 0}
{"code": "  void* GetData() { return embedder_data_; }", "target": 0}
{"code": "static int dnxhd_find_frame_end(DNXHDParserContext *dctx,\n                                const uint8_t *buf, int buf_size)\n{\n    ParseContext *pc = &dctx->pc;\n    uint64_t state = pc->state64;\n    int pic_found = pc->frame_start_found;\n    int i = 0;\n    if (!pic_found) {\n        for (i = 0; i < buf_size; i++) {\n            state = (state << 8) | buf[i];\n            if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {\n                i++;\n                pic_found = 1;\n                dctx->cur_byte = 0;\n                dctx->remaining = 0;\n                break;\n            }\n        }\n    }\n    if (pic_found && !dctx->remaining) {\n        if (!buf_size) \n            return 0;\n        for (; i < buf_size; i++) {\n            dctx->cur_byte++;\n            state = (state << 8) | buf[i];\n            if (dctx->cur_byte == 24) {\n                dctx->h = (state >> 32) & 0xFFFF;\n            } else if (dctx->cur_byte == 26) {\n                dctx->w = (state >> 32) & 0xFFFF;\n            } else if (dctx->cur_byte == 42) {\n                int cid = (state >> 32) & 0xFFFFFFFF;\n                if (cid <= 0)\n                    continue;\n                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);\n                if (dctx->remaining <= 0) {\n                    dctx->remaining = ff_dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);\n                    if (dctx->remaining <= 0)\n                        return dctx->remaining;\n                }\n                if (buf_size - i + 47 >= dctx->remaining) {\n                    int remaining = dctx->remaining;\n                    pc->frame_start_found = 0;\n                    pc->state64 = -1;\n                    dctx->cur_byte = 0;\n                    dctx->remaining = 0;\n                    return remaining;\n                } else {\n                    dctx->remaining -= buf_size;\n                }\n            }\n        }\n    } else if (pic_found) {\n        if (dctx->remaining > buf_size) {\n            dctx->remaining -= buf_size;\n        } else {\n            int remaining = dctx->remaining;\n            pc->frame_start_found = 0;\n            pc->state64 = -1;\n            dctx->cur_byte = 0;\n            dctx->remaining = 0;\n            return remaining;\n        }\n    }\n    pc->frame_start_found = pic_found;\n    pc->state64 = state;\n    return END_NOT_FOUND;\n}", "target": 1}
{"code": "queryin(char *buf)\n{\n\tQPRS_STATE\tstate;\n\tint32\t\ti;\n\tltxtquery  *query;\n\tint32\t\tcommonlen;\n\tITEM\t   *ptr;\n\tNODE\t   *tmp;\n\tint32\t\tpos = 0;\n#ifdef BS_DEBUG\n\tchar\t\tpbuf[16384],\n\t\t\t   *cur;\n#endif\n\tstate.buf = buf;\n\tstate.state = WAITOPERAND;\n\tstate.count = 0;\n\tstate.num = 0;\n\tstate.str = NULL;\n\tstate.sumlen = 0;\n\tstate.lenop = 64;\n\tstate.curop = state.op = (char *) palloc(state.lenop);\n\t*(state.curop) = '\\0';\n\tmakepol(&state);\n\tif (!state.num)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t errmsg(\"syntax error\"),\n\t\t\t\t errdetail(\"Empty query.\")));\n\tcommonlen = COMPUTESIZE(state.num, state.sumlen);\n\tquery = (ltxtquery *) palloc(commonlen);\n\tSET_VARSIZE(query, commonlen);\n\tquery->size = state.num;\n\tptr = GETQUERY(query);\n\tfor (i = 0; i < state.num; i++)\n\t{\n\t\tptr[i].type = state.str->type;\n\t\tptr[i].val = state.str->val;\n\t\tptr[i].distance = state.str->distance;\n\t\tptr[i].length = state.str->length;\n\t\tptr[i].flag = state.str->flag;\n\t\ttmp = state.str->next;\n\t\tpfree(state.str);\n\t\tstate.str = tmp;\n\t}\n\tmemcpy((void *) GETOPERAND(query), (void *) state.op, state.sumlen);\n\tpfree(state.op);\n\tpos = 0;\n\tfindoprnd(ptr, &pos);\n\treturn query;\n}", "target": 1}
{"code": "static const char *findvararg (CallInfo *ci, int n, StkId *pos) {\n  if (clLvalue(s2v(ci->func))->p->is_vararg) {\n    int nextra = ci->u.l.nextraargs;\n    if (n <= nextra) {\n      *pos = ci->func - nextra + (n - 1);\n      return \"(vararg)\";  \n    }\n  }\n  return NULL;  \n}", "target": 1}
{"code": "static int on_data_chunk_recv(nghttp2_session *session, uint8_t flags,\n                              int32_t stream_id, const uint8_t *data,\n                              size_t len, void *user_data)\n{\n    ogs_sbi_stream_t *stream = NULL;\n    ogs_sbi_request_t *request = NULL;\n    size_t offset = 0;\n    ogs_assert(session);\n    stream = nghttp2_session_get_stream_user_data(session, stream_id);\n    if (!stream) {\n        ogs_error(\"no stream [%d]\", stream_id);\n        return 0;\n    }\n    request = stream->request;\n    ogs_assert(request);\n    ogs_assert(data);\n    ogs_assert(len);\n    if (request->http.content == NULL) {\n        request->http.content_length = len;\n        request->http.content =\n            (char*)ogs_malloc(request->http.content_length + 1);\n        ogs_assert(request->http.content);\n    } else {\n        offset = request->http.content_length;\n        if ((request->http.content_length + len) > OGS_HUGE_LEN) {\n            ogs_error(\"Overflow : Content-Length[%d], len[%d]\",\n                        (int)request->http.content_length, (int)len);\n            ogs_assert_if_reached();\n        }\n        request->http.content_length += len;\n        request->http.content = (char *)ogs_realloc(\n                request->http.content, request->http.content_length + 1);\n        ogs_assert(request->http.content);\n    }\n    memcpy(request->http.content + offset, data, len);\n    request->http.content[request->http.content_length] = '\\0';\n    return 0;\n}", "target": 1}
{"code": "fbStore_a1 (FbBits *bits, const CARD32 *values, int x, int width, miIndexedPtr indexed)\n{\n    int i;\n    for (i = 0; i < width; ++i) {\n        CARD32  *pixel = ((CARD32 *) bits) + ((i+x) >> 5);\n        CARD32  mask = FbStipMask((i+x) & 0x1f, 1);\n        CARD32 v = READ(values + i) & 0x80000000 ? mask : 0;\n        WRITE(pixel, (READ(pixel) & ~mask) | v);\n    }\n}", "target": 0}
{"code": "size_t jsuGetFreeStack() {\n#ifdef ARM\n  void *frame = __builtin_frame_address(0);\n  size_t stackPos = (size_t)((char*)frame);\n  size_t stackEnd = (size_t)((char*)&LINKER_END_VAR);\n  if (stackPos < stackEnd) return 0; \n  return  stackPos - stackEnd;\n#elif defined(LINUX)\n  char ptr; \n  extern void *STACK_BASE;\n  uint32_t count =  (uint32_t)((size_t)STACK_BASE - (size_t)&ptr);\n  return 1000000 - count; \n#else\n  return 1000000; \n#endif\n}", "target": 1}
{"code": "static inline void add_sdb_addrline(Sdb *s, ut64 addr, const char *file, ut64 line, int mode, PrintfCallback print) {\n\tconst char *p;\n\tchar *fileline;\n\tchar offset[SDB_NUM_BUFSZ];\n\tchar *offset_ptr;\n\tif (!s || !file) {\n\t\treturn;\n\t}\n\tp = r_str_rchr (file, NULL, '/');\n\tif (p) {\n\t\tp++;\n\t} else {\n\t\tp = file;\n\t}\n\tswitch (mode) {\n\tcase 1:\n\tcase 'r':\n\tcase '*':\n\t\tprint (\"CL %s:%d 0x%08\"PFMT64x\"\\n\", p, (int)line, addr);\n\t\tbreak;\n\t}\n#if 0\n\tif (r_file_exists (file)) {\n\t\tp = file;\n\t}\n#else\n\tp = file;\n#endif\n\tfileline = r_str_newf (\"%s|%\"PFMT64d, p, line);\n\toffset_ptr = sdb_itoa (addr, 16, offset, sizeof (offset));\n\tsdb_add (s, offset_ptr, fileline, 0);\n\tsdb_add (s, fileline, offset_ptr, 0);\n\tfree (fileline);\n}", "target": 1}
{"code": "static inline bool nested_cpu_has_pml(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_ENABLE_PML);\n}", "target": 0}
{"code": "void Document::setCookie(const String& value, ExceptionState& exception_state) {\n  if (GetSettings() && !GetSettings()->GetCookieEnabled())\n    return;\n  UseCounter::Count(*this, WebFeature::kCookieSet);\n  if (!GetSecurityOrigin()->CanAccessCookies()) {\n    if (IsSandboxed(kSandboxOrigin))\n      exception_state.ThrowSecurityError(\n          \"The document is sandboxed and lacks the 'allow-same-origin' flag.\");\n    else if (Url().ProtocolIs(\"data\"))\n      exception_state.ThrowSecurityError(\n          \"Cookies are disabled inside 'data:' URLs.\");\n    else\n      exception_state.ThrowSecurityError(\"Access is denied for this document.\");\n    return;\n  }\n  if (GetSecurityOrigin()->HasSuborigin() &&\n      !GetSecurityOrigin()->GetSuborigin()->PolicyContains(\n          Suborigin::SuboriginPolicyOptions::kUnsafeCookies))\n    return;\n  KURL cookie_url = CookieURL();\n  if (cookie_url.IsEmpty())\n    return;\n  SetCookies(this, cookie_url, value);\n}", "target": 0}
{"code": "static Jsi_Value *jsi_hashFmtKey(Jsi_MapEntry* h, struct Jsi_MapOpts *opts, int flags)\n{\n    Jsi_HashEntry* hPtr = (Jsi_HashEntry*)h;\n    void *key = Jsi_HashKeyGet(hPtr);\n    if (opts->keyType == JSI_KEYS_ONEWORD)\n        return Jsi_ValueNewNumber(opts->interp, (Jsi_Number)(intptr_t)key);\n    char nbuf[100];\n    snprintf(nbuf, sizeof(nbuf), \"%p\", key);\n    return Jsi_ValueNewStringDup(opts->interp, nbuf);\n}", "target": 1}
{"code": "static void lwp_write_int32(FILE *fout, int32_t d) {\n  fwrite(&d, sizeof(d), 1, fout);\n  fflush(fout);\n}", "target": 0}
{"code": "static int dccp_v6_send_response(const struct sock *sk, struct request_sock *req)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sk_buff *skb;\n\tstruct in6_addr *final_p, final;\n\tstruct flowi6 fl6;\n\tint err = -1;\n\tstruct dst_entry *dst;\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.flowi6_proto = IPPROTO_DCCP;\n\tfl6.daddr = ireq->ir_v6_rmt_addr;\n\tfl6.saddr = ireq->ir_v6_loc_addr;\n\tfl6.flowlabel = 0;\n\tfl6.flowi6_oif = ireq->ir_iif;\n\tfl6.fl6_dport = ireq->ir_rmt_port;\n\tfl6.fl6_sport = htons(ireq->ir_num);\n\tsecurity_req_classify_flow(req, flowi6_to_flowi(&fl6));\n\tfinal_p = fl6_update_dst(&fl6, np->opt, &final);\n\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n\tif (IS_ERR(dst)) {\n\t\terr = PTR_ERR(dst);\n\t\tdst = NULL;\n\t\tgoto done;\n\t}\n\tskb = dccp_make_response(sk, dst, req);\n\tif (skb != NULL) {\n\t\tstruct dccp_hdr *dh = dccp_hdr(skb);\n\t\tdh->dccph_checksum = dccp_v6_csum_finish(skb,\n\t\t\t\t\t\t\t &ireq->ir_v6_loc_addr,\n\t\t\t\t\t\t\t &ireq->ir_v6_rmt_addr);\n\t\tfl6.daddr = ireq->ir_v6_rmt_addr;\n\t\terr = ip6_xmit(sk, skb, &fl6, np->opt, np->tclass);\n\t\terr = net_xmit_eval(err);\n\t}\ndone:\n\tdst_release(dst);\n\treturn err;\n}", "target": 1}
{"code": "static char* ConcatHttpHeaders(HTTP_HEADERS_HANDLE httpHeadersHandle, size_t toAlloc, size_t headersCount)\n{\n    char *result = (char*)malloc(toAlloc * sizeof(char) + 1);\n    size_t i;\n    if (result == NULL)\n    {\n        LogError(\"unable to malloc\");\n    }\n    else\n    {\n        result[0] = '\\0';\n        for (i = 0; i < headersCount; i++)\n        {\n            char* temp;\n            if (HTTPHeaders_GetHeader(httpHeadersHandle, i, &temp) != HTTP_HEADERS_OK)\n            {\n                LogError(\"unable to HTTPHeaders_GetHeader\");\n                break;\n            }\n            else\n            {\n                (void)strcat(result, temp);\n                (void)strcat(result, \"\\r\\n\");\n                free(temp);\n            }\n        }\n        if (i < headersCount)\n        {\n            free(result);\n            result = NULL;\n        }\n        else\n        {\n        }\n    }\n    return result;\n}", "target": 1}
{"code": "static int nfc_llcp_build_gb(struct nfc_llcp_local *local)\n{\n\tu8 *gb_cur, *version_tlv, version, version_length;\n\tu8 *lto_tlv, lto_length;\n\tu8 *wks_tlv, wks_length;\n\tu8 *miux_tlv, miux_length;\n\t__be16 wks = cpu_to_be16(local->local_wks);\n\tu8 gb_len = 0;\n\tint ret = 0;\n\tversion = LLCP_VERSION_11;\n\tversion_tlv = nfc_llcp_build_tlv(LLCP_TLV_VERSION, &version,\n\t\t\t\t\t 1, &version_length);\n\tgb_len += version_length;\n\tlto_tlv = nfc_llcp_build_tlv(LLCP_TLV_LTO, &local->lto, 1, &lto_length);\n\tgb_len += lto_length;\n\tpr_debug(\"Local wks 0x%lx\\n\", local->local_wks);\n\twks_tlv = nfc_llcp_build_tlv(LLCP_TLV_WKS, (u8 *)&wks, 2, &wks_length);\n\tgb_len += wks_length;\n\tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&local->miux, 0,\n\t\t\t\t      &miux_length);\n\tgb_len += miux_length;\n\tgb_len += ARRAY_SIZE(llcp_magic);\n\tif (gb_len > NFC_MAX_GT_LEN) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tgb_cur = local->gb;\n\tmemcpy(gb_cur, llcp_magic, ARRAY_SIZE(llcp_magic));\n\tgb_cur += ARRAY_SIZE(llcp_magic);\n\tmemcpy(gb_cur, version_tlv, version_length);\n\tgb_cur += version_length;\n\tmemcpy(gb_cur, lto_tlv, lto_length);\n\tgb_cur += lto_length;\n\tmemcpy(gb_cur, wks_tlv, wks_length);\n\tgb_cur += wks_length;\n\tmemcpy(gb_cur, miux_tlv, miux_length);\n\tgb_cur += miux_length;\n\tlocal->gb_len = gb_len;\nout:\n\tkfree(version_tlv);\n\tkfree(lto_tlv);\n\tkfree(wks_tlv);\n\tkfree(miux_tlv);\n\treturn ret;\n}", "target": 1}
{"code": "NativeModule::NativeModule(const std::string& filename) : init(nullptr) {\n\tif (!IsolateEnvironment::GetCurrent()->IsDefault()) {\n\t\tthrow RuntimeGenericError(\"NativeModule may only be instantiated from default nodejs isolate\");\n\t}\n\tif (uv_dlopen(filename.c_str(), &lib) != 0) {\n\t\tthrow RuntimeGenericError(\"Failed to load module\");\n\t}\n\tif (uv_dlsym(&lib, \"InitForContext\", reinterpret_cast<void**>(&init)) != 0 || init == nullptr) {\n\t\tuv_dlclose(&lib);\n\t\tthrow RuntimeGenericError(\"Module is not isolated-vm compatible\");\n\t}\n}", "target": 0}
{"code": "putstr(int d)\n{\n    addbufspc(1);\n    pputc(d);\n    return 0;\n}", "target": 0}
{"code": "static inline void CleanupPDFInfo(PDFInfo *pdf_info)\n{\n  if (pdf_info->profile != (StringInfo *) NULL)\n    pdf_info->profile=DestroyStringInfo(pdf_info->profile);\n}", "target": 0}
{"code": "init_remote_listener(int port, gboolean encrypted)\n{\n    int rc;\n    int *ssock = NULL;\n    struct sockaddr_in saddr;\n    int optval;\n    static struct mainloop_fd_callbacks remote_listen_fd_callbacks = \n        {\n            .dispatch = cib_remote_listen,\n            .destroy = remote_connection_destroy,\n        };\n    if (port <= 0) {\n        return 0;\n    }\n    if (encrypted) {\n#ifndef HAVE_GNUTLS_GNUTLS_H\n        crm_warn(\"TLS support is not available\");\n        return 0;\n#else\n        crm_notice(\"Starting a tls listener on port %d.\", port);\n        gnutls_global_init();\n        gnutls_global_set_log_function(debug_log);\n        gnutls_dh_params_init(&dh_params);\n        gnutls_dh_params_generate2(dh_params, DH_BITS);\n        gnutls_anon_allocate_server_credentials(&anon_cred_s);\n        gnutls_anon_set_server_dh_params(anon_cred_s, dh_params);\n#endif\n    } else {\n        crm_warn(\"Starting a plain_text listener on port %d.\", port);\n    }\n#ifndef HAVE_PAM\n    crm_warn(\"PAM is _not_ enabled!\");\n#endif\n    ssock = malloc(sizeof(int));\n    *ssock = socket(AF_INET, SOCK_STREAM, 0);\n    if (*ssock == -1) {\n        crm_perror(LOG_ERR, \"Can not create server socket.\" ERROR_SUFFIX);\n        free(ssock);\n        return -1;\n    }\n    optval = 1;\n    rc = setsockopt(*ssock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));\n    if(rc < 0) {\n        crm_perror(LOG_INFO, \"Couldn't allow the reuse of local addresses by our remote listener\");\n    }\n    memset(&saddr, '\\0', sizeof(saddr));\n    saddr.sin_family = AF_INET;\n    saddr.sin_addr.s_addr = INADDR_ANY;\n    saddr.sin_port = htons(port);\n    if (bind(*ssock, (struct sockaddr *)&saddr, sizeof(saddr)) == -1) {\n        crm_perror(LOG_ERR, \"Can not bind server socket.\" ERROR_SUFFIX);\n        close(*ssock);\n        free(ssock);\n        return -2;\n    }\n    if (listen(*ssock, 10) == -1) {\n        crm_perror(LOG_ERR, \"Can not start listen.\" ERROR_SUFFIX);\n        close(*ssock);\n        free(ssock);\n        return -3;\n    }\n    mainloop_add_fd(\"cib-remote\", G_PRIORITY_DEFAULT, *ssock, ssock, &remote_listen_fd_callbacks);\n    return *ssock;\n}", "target": 1}
{"code": "void CLua::init_libraries()\n{\n    lua_stack_cleaner clean(state());\n    lua_pushcfunction(_state, lua_loadstring);\n    lua_setglobal(_state, \"loadstring\");\n    lua_pushnil(_state);\n    lua_setglobal(_state, \"load\");\n    cluaopen_kills(_state);\n    cluaopen_you(_state);\n    cluaopen_item(_state);\n    cluaopen_food(_state);\n    cluaopen_crawl(_state);\n    cluaopen_file(_state);\n    cluaopen_moninf(_state);\n    cluaopen_options(_state);\n    cluaopen_travel(_state);\n    cluaopen_view(_state);\n    cluaopen_spells(_state);\n    cluaopen_globals(_state);\n    execfile(\"dlua/macro.lua\", true, true);\n    execstring(\"chk_startgame = { }\", \"base\");\n    lua_register(_state, \"loadfile\", _clua_loadfile);\n    lua_register(_state, \"dofile\", _clua_dofile);\n    lua_register(_state, \"crawl_require\", _clua_require);\n    execfile(\"dlua/util.lua\", true, true);\n    execfile(\"dlua/iter.lua\", true, true);\n    execfile(\"dlua/tags.lua\", true, true);\n    execfile(\"dlua/init.lua\", true, true);\n    if (managed_vm)\n    {\n        lua_register(_state, \"pcall\", _clua_guarded_pcall);\n        execfile(\"dlua/userbase.lua\", true, true);\n        execfile(\"dlua/persist.lua\", true, true);\n    }\n}", "target": 0}
{"code": "spnego_gss_wrap(\n\t\tOM_uint32 *minor_status,\n\t\tgss_ctx_id_t context_handle,\n\t\tint conf_req_flag,\n\t\tgss_qop_t qop_req,\n\t\tgss_buffer_t input_message_buffer,\n\t\tint *conf_state,\n\t\tgss_buffer_t output_message_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap(minor_status,\n\t\t    context_handle,\n\t\t    conf_req_flag,\n\t\t    qop_req,\n\t\t    input_message_buffer,\n\t\t    conf_state,\n\t\t    output_message_buffer);\n\treturn (ret);\n}", "target": 1}
{"code": "string handleGet(map<string, string>* reqHeaders) {\n  long long sessionId = -1;\n  long uid = -1;\n  string uri = (*reqHeaders)[\"uri\"];\n  string body;\n  if (reqHeaders->count(\"Cookie\") != 0) {\n    string cookies = (*reqHeaders)[\"Cookie\"];\n    string sessionIdString = cookies.substr(cookies.find(\"=\") + 1);\n    sessionId = stoll(sessionIdString, nullptr);\n    auto usersessionIt = sessionMap.find(sessionId);\n    if (usersessionIt == sessionMap.end()){\n      cout << \"Bad session ID, redirecting to login.\" << endl;\n      body = getLogin();\n    } else\n      uid = sessionMap[sessionId];\n  }\n  map<string, string> resHeaders;\n  resHeaders[\"Server\"] = \"CSE461\";\n  resHeaders[\"Content-Type\"] = \"text/html; charset=UTF-8\";\n  if (uri.compare(\"/cal\") == 0 && uid == -1) {\n    cout << \"login page\" << endl;\n    body = getLogin();\n  } else if (uri.compare(\"/cal\") == 0 && uid != -1) {\n    cout << \"cal page\" << endl;\n    string username = userNameById(uid);\n    body = getHeader(username);\n    body += getEmptyCalendar();\n    body += getFooter();\n  } else if (uri.compare(\"/getEvents\") == 0 && uid != -1) {\n    body = getEventsJson(uid);\n    resHeaders[\"Content-Type\"] = \"application/json; charset=UTF-8\";\n  } else {\n    cout << \"error page\" << endl;\n    string message = \"404 Page Not Found\";\n    return getResponseHeader(\"HTTP/1.1 404 Not Found\", &resHeaders, body.size())\n      + \"\\r\\n\" + message;\n  }\n  return getResponseHeader(\"HTTP/1.1 200 OK\", &resHeaders, body.size()) + \"\\r\\n\" + body;\n}", "target": 1}
{"code": "char *suhosin_decrypt_single_cookie(char *name, int name_len, char *value, int value_len, char *key, char **where TSRMLS_DC)\n{\n\tchar buffer[4096];\n    char buffer2[4096];\n    int o_name_len = name_len;\n\tchar *buf = buffer, *buf2 = buffer2, *d, *d_url;\n\tint l;\n\tif (name_len > sizeof(buffer)-2) {\n\t\tbuf = estrndup(name, name_len);\n\t} else {\n\t\tmemcpy(buf, name, name_len);\n\t\tbuf[name_len] = 0;\n\t}\n\tname_len = php_url_decode(buf, name_len);\n    normalize_varname(buf);\n    name_len = strlen(buf);\n\tif (SUHOSIN_G(cookie_plainlist)) {\n\t\tif (zend_hash_exists(SUHOSIN_G(cookie_plainlist), buf, name_len+1)) {\ndecrypt_return_plain:\n\t\t\tif (buf != buffer) {\n\t\t\t\tefree(buf);\n\t\t\t}\n            memcpy(*where, name, o_name_len);\n            *where += o_name_len;\n            **where = '='; *where +=1;\n\t        memcpy(*where, value, value_len);\n\t        *where += value_len;\n\t\t\treturn *where;\n\t\t}\n\t} else if (SUHOSIN_G(cookie_cryptlist)) {\n\t\tif (!zend_hash_exists(SUHOSIN_G(cookie_cryptlist), buf, name_len+1)) {\n\t\t\tgoto decrypt_return_plain;\n\t\t}\n\t}\n\tif (strlen(value) <= sizeof(buffer2)-2) {\n\t\tmemcpy(buf2, value, value_len);\n\t\tbuf2[value_len] = 0;\n\t} else {\n\t\tbuf2 = estrndup(value, value_len);\n\t}\n\tvalue_len = php_url_decode(buf2, value_len);\n\td = suhosin_decrypt_string(buf2, value_len, buf, name_len, key, &l, SUHOSIN_G(cookie_checkraddr) TSRMLS_CC);\n    if (d == NULL) {\n        goto skip_cookie;\n    }\n\td_url = php_url_encode(d, l, &l);\n\tefree(d);\n    memcpy(*where, name, o_name_len);\n    *where += o_name_len;\n    **where = '=';*where += 1;\n\tmemcpy(*where, d_url, l);\n\t*where += l;\n\tefree(d_url);\nskip_cookie:\n\tif (buf != buffer) {\n\t\tefree(buf);\n\t}\n\tif (buf2 != buffer2) {\n\t\tefree(buf2);\n\t}\n\treturn *where;\n}", "target": 1}
{"code": "    UNZIPLoadParseError(const std::string &msg) : std::runtime_error(msg) { };", "target": 0}
{"code": "find_entry2modify_only_ext(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n    int flags,\n    back_txn *txn\n)\n{\n\treturn( find_entry_internal( pb, be, addr, 1, txn, \n\t\t                         FE_REALLY_INTERNAL | flags ));\n}", "target": 1}
{"code": "      JpegInput( String filename ) : filename_( std::move( filename )) {\n         infile_ = std::fopen( filename_.c_str(), \"rb\" );\n         if( infile_ == nullptr ) {\n            if( !FileHasExtension( filename_ )) {\n               filename_ = FileAddExtension( filename_, \"jpg\" ); \n               infile_ = std::fopen( filename_.c_str(), \"rb\" );\n               if( infile_ == nullptr ) {\n                  filename_ = FileAddExtension( filename_, \"jpeg\" ); \n                  infile_ = std::fopen( filename_.c_str(), \"rb\" );\n               }\n            }\n         }\n         if( infile_ == nullptr ) {\n            DIP_THROW_RUNTIME( \"Could not open the specified JPEG file\" );\n         }\n         cinfo_.err = jpeg_std_error( &jerr_.pub );\n         jerr_.pub.error_exit = my_error_exit;\n         jerr_.pub.output_message = my_output_message;\n         if( setjmp( jerr_.setjmp_buffer )) {\n            DIP_THROW_RUNTIME( \"Error reading JPEG file.\" );\n         }\n         jpeg_create_decompress( &cinfo_ );\n         initialized_ = true;\n         jpeg_stdio_src( &cinfo_, infile_ );\n         jpeg_read_header( &cinfo_, TRUE );\n      }", "target": 1}
{"code": "void __init proc_root_init(void)\n{\n\tstruct vfsmount *mnt;\n\tint err;\n\tproc_init_inodecache();\n\terr = register_filesystem(&proc_fs_type);\n\tif (err)\n\t\treturn;\n\tmnt = kern_mount_data(&proc_fs_type, &init_pid_ns);\n\tif (IS_ERR(mnt)) {\n\t\tunregister_filesystem(&proc_fs_type);\n\t\treturn;\n\t}\n\tinit_pid_ns.proc_mnt = mnt;\n\tproc_symlink(\"mounts\", NULL, \"self/mounts\");\n\tproc_net_init();\n#ifdef CONFIG_SYSVIPC\n\tproc_mkdir(\"sysvipc\", NULL);\n#endif\n\tproc_mkdir(\"fs\", NULL);\n\tproc_mkdir(\"driver\", NULL);\n\tproc_mkdir(\"fs/nfsd\", NULL); \n#if defined(CONFIG_SUN_OPENPROMFS) || defined(CONFIG_SUN_OPENPROMFS_MODULE)\n\tproc_mkdir(\"openprom\", NULL);\n#endif\n\tproc_tty_init();\n#ifdef CONFIG_PROC_DEVICETREE\n\tproc_device_tree_init();\n#endif\n\tproc_mkdir(\"bus\", NULL);\n\tproc_sys_init();\n}", "target": 1}
{"code": "static gboolean prplcb_xfer_new_send_cb(gpointer data, gint fd, b_input_condition cond)\n{\n\tPurpleXfer *xfer = data;\n\tstruct im_connection *ic = purple_ic_by_pa(xfer->account);\n\tstruct prpl_xfer_data *px = xfer->ui_data;\n\tPurpleBuddy *buddy;\n\tconst char *who;\n\tbuddy = purple_find_buddy(xfer->account, xfer->who);\n\twho = buddy ? purple_buddy_get_name(buddy) : xfer->who;\n\tpx->ft = imcb_file_send_start(ic, (char *) who, xfer->filename, xfer->size);\n\tif (!px->ft) {\n\t\treturn FALSE;\n\t}\n\tpx->ft->data = px;\n\tpx->ft->accept = prpl_xfer_accept;\n\tpx->ft->canceled = prpl_xfer_canceled;\n\tpx->ft->free = prpl_xfer_free;\n\tpx->ft->write_request = prpl_xfer_write_request;\n\treturn FALSE;\n}", "target": 0}
{"code": "static inline int check_entry_size_and_hooks(struct arpt_entry *e,\n\t\t\t\t\t     struct xt_table_info *newinfo,\n\t\t\t\t\t     const unsigned char *base,\n\t\t\t\t\t     const unsigned char *limit,\n\t\t\t\t\t     const unsigned int *hook_entries,\n\t\t\t\t\t     const unsigned int *underflows,\n\t\t\t\t\t     unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct arpt_entry) >= limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_err(\"Underflows must be unconditional and \"\n\t\t\t\t       \"use the STANDARD target with \"\n\t\t\t\t       \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 1}
{"code": "    static size_t size() {\n      return ConstSingleton<StaticLookupTable>::get().size_;\n    }", "target": 0}
{"code": "static __u8 *nci_extract_rf_params_nfca_passive_poll(struct nci_dev *ndev,\n\t\t\tstruct rf_tech_specific_params_nfca_poll *nfca_poll,\n\t\t\t\t\t\t     __u8 *data)\n{\n\tnfca_poll->sens_res = __le16_to_cpu(*((__u16 *)data));\n\tdata += 2;\n\tnfca_poll->nfcid1_len = *data++;\n\tpr_debug(\"sens_res 0x%x, nfcid1_len %d\\n\",\n\t\t nfca_poll->sens_res, nfca_poll->nfcid1_len);\n\tmemcpy(nfca_poll->nfcid1, data, nfca_poll->nfcid1_len);\n\tdata += nfca_poll->nfcid1_len;\n\tnfca_poll->sel_res_len = *data++;\n\tif (nfca_poll->sel_res_len != 0)\n\t\tnfca_poll->sel_res = *data++;\n\tpr_debug(\"sel_res_len %d, sel_res 0x%x\\n\",\n\t\t nfca_poll->sel_res_len,\n\t\t nfca_poll->sel_res);\n\treturn data;\n}", "target": 1}
{"code": "UnicodeString::doAppend(const UChar *srcChars, int32_t srcStart, int32_t srcLength) {\n  if(!isWritable() || srcLength == 0 || srcChars == NULL) {\n    return *this;\n  }\n  srcChars += srcStart;\n  if(srcLength < 0) {\n    if((srcLength = u_strlen(srcChars)) == 0) {\n      return *this;\n    }\n  }\n  int32_t oldLength = length();\n  int32_t newLength = oldLength + srcLength;\n  const UChar* oldArray = getArrayStart();\n  if (isBufferWritable() &&\n      oldArray < srcChars + srcLength &&\n      srcChars < oldArray + oldLength) {\n    UnicodeString copy(srcChars, srcLength);\n    if (copy.isBogus()) {\n      setToBogus();\n      return *this;\n    }\n    return doAppend(copy.getArrayStart(), 0, srcLength);\n  }\n  if((newLength <= getCapacity() && isBufferWritable()) ||\n      cloneArrayIfNeeded(newLength, getGrowCapacity(newLength))) {\n    UChar *newArray = getArrayStart();\n    if(srcChars != newArray + oldLength) {\n      us_arrayCopy(srcChars, 0, newArray, oldLength, srcLength);\n    }\n    setLength(newLength);\n  }\n  return *this;\n}", "target": 1}
{"code": "bool Browser::CanCloseWithInProgressDownloads() {\n  if (cancel_download_confirmation_state_ != NOT_PROMPTED)\n    return cancel_download_confirmation_state_ != WAITING_FOR_RESPONSE;\n  int num_downloads_blocking;\n  Browser::DownloadClosePreventionType dialog_type =\n      OkToCloseWithInProgressDownloads(&num_downloads_blocking);\n  if (dialog_type == DOWNLOAD_CLOSE_OK)\n    return true;\n  cancel_download_confirmation_state_ = WAITING_FOR_RESPONSE;\n  window_->ConfirmBrowserCloseWithPendingDownloads(\n      num_downloads_blocking,\n      dialog_type,\n      false,\n      base::Bind(&Browser::InProgressDownloadResponse,\n                 weak_factory_.GetWeakPtr()));\n  return false;\n}", "target": 0}
{"code": "int avcodec_default_reget_buffer(AVCodecContext *s, AVFrame *pic)\n{\n    av_assert0(0);\n    return AVERROR_BUG;\n}", "target": 0}
{"code": "static ext4_io_end_t *ext4_init_io_end (struct inode *inode)\n{\n\text4_io_end_t *io = NULL;\n\tio = kmalloc(sizeof(*io), GFP_NOFS);\n\tif (io) {\n\t\tigrab(inode);\n\t\tio->inode = inode;\n\t\tio->flag = 0;\n\t\tio->offset = 0;\n\t\tio->size = 0;\n\t\tio->error = 0;\n\t\tINIT_WORK(&io->work, ext4_end_io_work);\n\t\tINIT_LIST_HEAD(&io->list);\n\t}\n\treturn io;\n}", "target": 1}
{"code": "static void timestamp(void)\n{\n    struct compile_time * const oct = &official_compile_time;\n    const struct tm *tp, *best_gm;\n    time(&oct->t);\n    best_gm = NULL;\n    tp = localtime(&oct->t);\n    if (tp) {\n        oct->local = *tp;\n        best_gm = &oct->local;\n        oct->have_local = true;\n    }\n    tp = gmtime(&oct->t);\n    if (tp) {\n        oct->gm = *tp;\n        best_gm = &oct->gm;\n        oct->have_gm = true;\n        if (!oct->have_local)\n            oct->local = oct->gm;\n    } else {\n        oct->gm = oct->local;\n    }\n    if (best_gm) {\n        oct->posix = make_posix_time(best_gm);\n        oct->have_posix = true;\n    }\n}", "target": 0}
{"code": "static void set_cpu_rq_start_time(void)\n{\n\tint cpu = smp_processor_id();\n\tstruct rq *rq = cpu_rq(cpu);\n\trq->age_stamp = sched_clock_cpu(cpu);\n}", "target": 0}
{"code": "int CLASS ljpeg_diff (ushort *huff)\n{\n  int len, diff;\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!huff)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  len = gethuff(huff);\n  if (len == 16 && (!dng_version || dng_version >= 0x1010000))\n    return -32768;\n  diff = getbits(len);\n  if ((diff & (1 << (len-1))) == 0)\n    diff -= (1 << len) - 1;\n  return diff;\n}", "target": 0}
{"code": "void jbd2_journal_lock_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\tjbd2_might_wait_for_commit(journal);\n\twrite_lock(&journal->j_state_lock);\n\t++journal->j_barrier_count;\n\tif (atomic_read(&journal->j_reserved_credits)) {\n\t\twrite_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_reserved,\n\t\t\t   atomic_read(&journal->j_reserved_credits) == 0);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\tjbd2_journal_wait_updates(journal);\n\twrite_unlock(&journal->j_state_lock);\n\tmutex_lock(&journal->j_barrier);\n}", "target": 1}
{"code": "void SetDashSize(double dashsize,double phase) {\n    if ( dashsize ) outpos += sprintf(outpos,\" [%12.3f] %12.3f d\",dashsize,phase);\n    else outpos += sprintf(outpos,\" [] 0 d\");\n}", "target": 1}
{"code": "mm_sshpam_init_ctx(Authctxt *authctxt)\n{\n\tBuffer m;\n\tint success;\n\tdebug3(\"%s\", __func__);\n\tbuffer_init(&m);\n\tbuffer_put_cstring(&m, authctxt->user);\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_PAM_INIT_CTX, &m);\n\tdebug3(\"%s: waiting for MONITOR_ANS_PAM_INIT_CTX\", __func__);\n\tmm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_PAM_INIT_CTX, &m);\n\tsuccess = buffer_get_int(&m);\n\tif (success == 0) {\n\t\tdebug3(\"%s: pam_init_ctx failed\", __func__);\n\t\tbuffer_free(&m);\n\t\treturn (NULL);\n\t}\n\tbuffer_free(&m);\n\treturn (authctxt);\n}", "target": 1}
{"code": "int f2fs_trim_fs(struct f2fs_sb_info *sbi, struct fstrim_range *range)\n{\n\t__u64 start = F2FS_BYTES_TO_BLK(range->start);\n\t__u64 end = start + F2FS_BYTES_TO_BLK(range->len) - 1;\n\tunsigned int start_segno, end_segno;\n\tstruct cp_control cpc;\n\tint err = 0;\n\tif (start >= MAX_BLKADDR(sbi) || range->len < sbi->blocksize)\n\t\treturn -EINVAL;\n\tcpc.trimmed = 0;\n\tif (end <= MAIN_BLKADDR(sbi))\n\t\tgoto out;\n\tif (is_sbi_flag_set(sbi, SBI_NEED_FSCK)) {\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t\"Found FS corruption, run fsck to fix.\");\n\t\tgoto out;\n\t}\n\tstart_segno = (start <= MAIN_BLKADDR(sbi)) ? 0 : GET_SEGNO(sbi, start);\n\tend_segno = (end >= MAX_BLKADDR(sbi)) ? MAIN_SEGS(sbi) - 1 :\n\t\t\t\t\t\tGET_SEGNO(sbi, end);\n\tcpc.reason = CP_DISCARD;\n\tcpc.trim_minlen = max_t(__u64, 1, F2FS_BYTES_TO_BLK(range->minlen));\n\tfor (; start_segno <= end_segno; start_segno = cpc.trim_end + 1) {\n\t\tcpc.trim_start = start_segno;\n\t\tif (sbi->discard_blks == 0)\n\t\t\tbreak;\n\t\telse if (sbi->discard_blks < BATCHED_TRIM_BLOCKS(sbi))\n\t\t\tcpc.trim_end = end_segno;\n\t\telse\n\t\t\tcpc.trim_end = min_t(unsigned int,\n\t\t\t\trounddown(start_segno +\n\t\t\t\tBATCHED_TRIM_SEGMENTS(sbi),\n\t\t\t\tsbi->segs_per_sec) - 1, end_segno);\n\t\tmutex_lock(&sbi->gc_mutex);\n\t\terr = write_checkpoint(sbi, &cpc);\n\t\tmutex_unlock(&sbi->gc_mutex);\n\t\tif (err)\n\t\t\tbreak;\n\t\tschedule();\n\t}\n\tmark_discard_range_all(sbi);\n\tf2fs_wait_discard_bios(sbi);\nout:\n\trange->len = F2FS_BLK_TO_BYTES(cpc.trimmed);\n\treturn err;\n}", "target": 1}
{"code": "static struct dump_dir *open_directory_for_modification_of_element(\n    GDBusMethodInvocation *invocation,\n    uid_t caller_uid,\n    const char *problem_id,\n    const char *element)\n{\n    static const char *const protected_elements[] = {\n        FILENAME_TIME,\n        FILENAME_UID,\n        NULL,\n    };\n    for (const char *const *protected = protected_elements; *protected; ++protected)\n    {\n        if (strcmp(*protected, element) == 0)\n        {\n            log_notice(\"'%s' element of '%s' can't be modified\", element, problem_id);\n            char *error = xasprintf(_(\"'%s' element can't be modified\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                        \"org.freedesktop.problems.ProtectedElement\",\n                                        error);\n            free(error);\n            return NULL;\n        }\n    }\n    if (!dump_dir_accessible_by_uid(problem_id, caller_uid))\n    {\n        if (errno == ENOTDIR)\n        {\n            log_notice(\"'%s' is not a valid problem directory\", problem_id);\n            return_InvalidProblemDir_error(invocation, problem_id);\n        }\n        else\n        {\n            log_notice(\"UID(%d) is not Authorized to access '%s'\", caller_uid, problem_id);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                \"org.freedesktop.problems.AuthFailure\",\n                                _(\"Not Authorized\"));\n        }\n        return NULL;\n    }\n    struct dump_dir *dd = dd_opendir(problem_id,  0);\n    if (!dd)\n    {   \n        log_notice(\"Can't access the problem '%s' for modification\", problem_id);\n        g_dbus_method_invocation_return_dbus_error(invocation,\n                                \"org.freedesktop.problems.Failure\",\n                                _(\"Can't access the problem for modification\"));\n        return NULL;\n    }\n    return dd;\n}", "target": 1}
{"code": "find_entry2modify_only(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n    back_txn *txn\n)\n{\n\treturn( find_entry_internal( pb, be, addr, 1, txn, FE_REALLY_INTERNAL ) );\n}", "target": 1}
{"code": "static inline bool key_is_positive(const struct key *key)\n{\n\treturn key_read_state(key) == KEY_IS_POSITIVE;\n}", "target": 0}
{"code": "bool IsConvolutionOpSupported(const TfLiteRegistration* registration,\n                              const TfLiteNode* node, TfLiteContext* context) {\n  if (node->builtin_data == nullptr) return false;\n  TfLiteFusedActivation activation;\n  if (registration->builtin_code == kTfLiteBuiltinConv2d) {\n    const auto* conv_params =\n        reinterpret_cast<const TfLiteConvParams*>(node->builtin_data);\n    activation = conv_params->activation;\n  } else if (registration->builtin_code == kTfLiteBuiltinDepthwiseConv2d) {\n    const auto* depthwise_conv_params =\n        reinterpret_cast<const TfLiteDepthwiseConvParams*>(node->builtin_data);\n    activation = depthwise_conv_params->activation;\n  } else if (registration->builtin_code == kTfLiteBuiltinTransposeConv) {\n    activation = kTfLiteActNone;\n  } else {\n    TF_LITE_KERNEL_LOG(\n        context,\n        \"Invalid op: op must be Conv2D, DepthwiseConv2D or TransposeConv.\");\n    return false;\n  }\n  if (activation == kTfLiteActSignBit) {\n    return false;\n  }\n  const int kOutputShapeTensor = 0;  \n  const int kWeightTensor = 1;\n  const int kBiasTensor = 2;  \n  const TfLiteTensor* weights = GetInput(context, node, kWeightTensor);\n  const int max_kernel_size = 16384;\n  if (!IsConstantTensor(weights)) {\n    return false;\n  }\n  if (weights->dims->data[1] > max_kernel_size ||\n      weights->dims->data[2] > max_kernel_size) {\n    return false;\n  }\n  if (registration->builtin_code == kTfLiteBuiltinTransposeConv) {\n    if (!IsConstantTensor(GetInput(context, node, kOutputShapeTensor))) {\n      return false;\n    }\n  } else {\n    if (node->inputs->size >= kBiasTensor &&\n        !IsConstantTensor(GetInput(context, node, kBiasTensor))) {\n      return false;\n    }\n  }\n  return true;\n}", "target": 1}
{"code": "static int shmem_remount_fs(struct super_block *sb, int *flags, char *data)\n{\n\tstruct shmem_sb_info *sbinfo = SHMEM_SB(sb);\n\tstruct shmem_sb_info config = *sbinfo;\n\tunsigned long inodes;\n\tint error = -EINVAL;\n\tif (shmem_parse_options(data, &config, true))\n\t\treturn error;\n\tspin_lock(&sbinfo->stat_lock);\n\tinodes = sbinfo->max_inodes - sbinfo->free_inodes;\n\tif (percpu_counter_compare(&sbinfo->used_blocks, config.max_blocks) > 0)\n\t\tgoto out;\n\tif (config.max_inodes < inodes)\n\t\tgoto out;\n\tif (config.max_blocks && !sbinfo->max_blocks)\n\t\tgoto out;\n\tif (config.max_inodes && !sbinfo->max_inodes)\n\t\tgoto out;\n\terror = 0;\n\tsbinfo->max_blocks  = config.max_blocks;\n\tsbinfo->max_inodes  = config.max_inodes;\n\tsbinfo->free_inodes = config.max_inodes - inodes;\n\tmpol_put(sbinfo->mpol);\n\tsbinfo->mpol        = config.mpol;\t\nout:\n\tspin_unlock(&sbinfo->stat_lock);\n\treturn error;\n}", "target": 1}
{"code": "MONGO_EXPORT int bson_append_binary( bson *b, const char *name, char type, const char *str, int len ) {\n    if ( type == BSON_BIN_BINARY_OLD ) {\n        int subtwolen = len + 4;\n        if ( bson_append_estart( b, BSON_BINDATA, name, 4+1+4+len ) == BSON_ERROR )\n            return BSON_ERROR;\n        bson_append32( b, &subtwolen );\n        bson_append_byte( b, type );\n        bson_append32( b, &len );\n        bson_append( b, str, len );\n    }\n    else {\n        if ( bson_append_estart( b, BSON_BINDATA, name, 4+1+len ) == BSON_ERROR )\n            return BSON_ERROR;\n        bson_append32( b, &len );\n        bson_append_byte( b, type );\n        bson_append( b, str, len );\n    }\n    return BSON_OK;\n}", "target": 1}
{"code": "AP_CORE_DECLARE(void) ap_parse_uri(request_rec *r, const char *uri)\n{\n    int status = HTTP_OK;\n    r->unparsed_uri = apr_pstrdup(r->pool, uri);\n    while ((uri[0] == '/') && (uri[1] == '/')) {\n        ++uri ;\n    }\n    if (r->method_number == M_CONNECT) {\n        status = apr_uri_parse_hostinfo(r->pool, uri, &r->parsed_uri);\n    }\n    else {\n        status = apr_uri_parse(r->pool, uri, &r->parsed_uri);\n    }\n    if (status == APR_SUCCESS) {\n        if (r->parsed_uri.scheme\n            && !ap_cstr_casecmp(r->parsed_uri.scheme, ap_http_scheme(r))) {\n            r->hostname = r->parsed_uri.hostname;\n        }\n        else if (r->method_number == M_CONNECT) {\n            r->hostname = r->parsed_uri.hostname;\n        }\n        r->args = r->parsed_uri.query;\n        r->uri = r->parsed_uri.path ? r->parsed_uri.path\n                 : apr_pstrdup(r->pool, \"/\");\n#if defined(OS2) || defined(WIN32)\n        {\n            char *x;\n            for (x = r->uri; (x = strchr(x, '\\\\')) != NULL; )\n                *x = '/';\n        }\n#endif \n    }\n    else {\n        r->args = NULL;\n        r->hostname = NULL;\n        r->status = HTTP_BAD_REQUEST;             \n        r->uri = apr_pstrdup(r->pool, uri);\n    }\n}", "target": 1}
{"code": "static int update_alu_sanitation_state(struct bpf_insn_aux_data *aux,\n\t\t\t\t       u32 alu_state, u32 alu_limit)\n{\n\tif (aux->alu_state &&\n\t    (aux->alu_state != alu_state ||\n\t     aux->alu_limit != alu_limit))\n\t\treturn -EACCES;\n\taux->alu_state = alu_state;\n\taux->alu_limit = alu_limit;\n\treturn 0;\n}", "target": 0}
{"code": "void exit_sem(struct task_struct *tsk)\n{\n\tstruct sem_undo_list *ulp;\n\tulp = tsk->sysvsem.undo_list;\n\tif (!ulp)\n\t\treturn;\n\ttsk->sysvsem.undo_list = NULL;\n\tif (!atomic_dec_and_test(&ulp->refcnt))\n\t\treturn;\n\tfor (;;) {\n\t\tstruct sem_array *sma;\n\t\tstruct sem_undo *un;\n\t\tstruct list_head tasks;\n\t\tint semid;\n\t\tint i;\n\t\trcu_read_lock();\n\t\tun = list_entry_rcu(ulp->list_proc.next,\n\t\t\t\t    struct sem_undo, list_proc);\n\t\tif (&un->list_proc == &ulp->list_proc)\n\t\t\tsemid = -1;\n\t\t else\n\t\t\tsemid = un->semid;\n\t\trcu_read_unlock();\n\t\tif (semid == -1)\n\t\t\tbreak;\n\t\tsma = sem_lock_check(tsk->nsproxy->ipc_ns, un->semid);\n\t\tif (IS_ERR(sma))\n\t\t\tcontinue;\n\t\tun = __lookup_undo(ulp, semid);\n\t\tif (un == NULL) {\n\t\t\tsem_unlock(sma);\n\t\t\tcontinue;\n\t\t}\n\t\tassert_spin_locked(&sma->sem_perm.lock);\n\t\tlist_del(&un->list_id);\n\t\tspin_lock(&ulp->lock);\n\t\tlist_del_rcu(&un->list_proc);\n\t\tspin_unlock(&ulp->lock);\n\t\tfor (i = 0; i < sma->sem_nsems; i++) {\n\t\t\tstruct sem * semaphore = &sma->sem_base[i];\n\t\t\tif (un->semadj[i]) {\n\t\t\t\tsemaphore->semval += un->semadj[i];\n\t\t\t\tif (semaphore->semval < 0)\n\t\t\t\t\tsemaphore->semval = 0;\n\t\t\t\tif (semaphore->semval > SEMVMX)\n\t\t\t\t\tsemaphore->semval = SEMVMX;\n\t\t\t\tsemaphore->sempid = task_tgid_vnr(current);\n\t\t\t}\n\t\t}\n\t\tINIT_LIST_HEAD(&tasks);\n\t\tdo_smart_update(sma, NULL, 0, 1, &tasks);\n\t\tsem_unlock(sma);\n\t\twake_up_sem_queue_do(&tasks);\n\t\tkfree_rcu(un, rcu);\n\t}\n\tkfree(ulp);\n}", "target": 1}
{"code": "static inline struct anon_vma *anon_vma_alloc(void)\n{\n\tstruct anon_vma *anon_vma;\n\tanon_vma = kmem_cache_alloc(anon_vma_cachep, GFP_KERNEL);\n\tif (anon_vma) {\n\t\tatomic_set(&anon_vma->refcount, 1);\n\t\tanon_vma->degree = 1;\t\n\t\tanon_vma->parent = anon_vma;\n\t\tanon_vma->root = anon_vma;\n\t}\n\treturn anon_vma;\n}", "target": 1}
{"code": "static ssize_t driver_override_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tchar *driver_override, *old = pdev->driver_override, *cp;\n\tif (count > PATH_MAX)\n\t\treturn -EINVAL;\n\tdriver_override = kstrndup(buf, count, GFP_KERNEL);\n\tif (!driver_override)\n\t\treturn -ENOMEM;\n\tcp = strchr(driver_override, '\\n');\n\tif (cp)\n\t\t*cp = '\\0';\n\tif (strlen(driver_override)) {\n\t\tpdev->driver_override = driver_override;\n\t} else {\n\t\tkfree(driver_override);\n\t\tpdev->driver_override = NULL;\n\t}\n\tkfree(old);\n\treturn count;\n}", "target": 1}
{"code": "int key_reject_and_link(struct key *key,\n\t\t\tunsigned timeout,\n\t\t\tunsigned error,\n\t\t\tstruct key *keyring,\n\t\t\tstruct key *authkey)\n{\n\tstruct assoc_array_edit *edit;\n\tstruct timespec now;\n\tint ret, awaken, link_ret = 0;\n\tkey_check(key);\n\tkey_check(keyring);\n\tawaken = 0;\n\tret = -EBUSY;\n\tif (keyring) {\n\t\tif (keyring->restrict_link)\n\t\t\treturn -EPERM;\n\t\tlink_ret = __key_link_begin(keyring, &key->index_key, &edit);\n\t}\n\tmutex_lock(&key_construction_mutex);\n\tif (!test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {\n\t\tatomic_inc(&key->user->nikeys);\n\t\tkey->reject_error = -error;\n\t\tsmp_wmb();\n\t\tset_bit(KEY_FLAG_NEGATIVE, &key->flags);\n\t\tset_bit(KEY_FLAG_INSTANTIATED, &key->flags);\n\t\tnow = current_kernel_time();\n\t\tkey->expiry = now.tv_sec + timeout;\n\t\tkey_schedule_gc(key->expiry + key_gc_delay);\n\t\tif (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags))\n\t\t\tawaken = 1;\n\t\tret = 0;\n\t\tif (keyring && link_ret == 0)\n\t\t\t__key_link(key, &edit);\n\t\tif (authkey)\n\t\t\tkey_revoke(authkey);\n\t}\n\tmutex_unlock(&key_construction_mutex);\n\tif (keyring)\n\t\t__key_link_end(keyring, &key->index_key, edit);\n\tif (awaken)\n\t\twake_up_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT);\n\treturn ret == 0 ? link_ret : ret;\n}", "target": 1}
{"code": "void UnicodeStringTest::runIndexedTest( int32_t index, UBool exec, const char* &name, char *par)\n{\n    if (exec) logln(\"TestSuite UnicodeStringTest: \");\n    TESTCASE_AUTO_BEGIN;\n    TESTCASE_AUTO_CREATE_CLASS(StringCaseTest);\n    TESTCASE_AUTO(TestBasicManipulation);\n    TESTCASE_AUTO(TestCompare);\n    TESTCASE_AUTO(TestExtract);\n    TESTCASE_AUTO(TestRemoveReplace);\n    TESTCASE_AUTO(TestSearching);\n    TESTCASE_AUTO(TestSpacePadding);\n    TESTCASE_AUTO(TestPrefixAndSuffix);\n    TESTCASE_AUTO(TestFindAndReplace);\n    TESTCASE_AUTO(TestBogus);\n    TESTCASE_AUTO(TestReverse);\n    TESTCASE_AUTO(TestMiscellaneous);\n    TESTCASE_AUTO(TestStackAllocation);\n    TESTCASE_AUTO(TestUnescape);\n    TESTCASE_AUTO(TestCountChar32);\n    TESTCASE_AUTO(TestStringEnumeration);\n    TESTCASE_AUTO(TestNameSpace);\n    TESTCASE_AUTO(TestUTF32);\n    TESTCASE_AUTO(TestUTF8);\n    TESTCASE_AUTO(TestReadOnlyAlias);\n    TESTCASE_AUTO(TestAppendable);\n    TESTCASE_AUTO(TestUnicodeStringImplementsAppendable);\n    TESTCASE_AUTO(TestSizeofUnicodeString);\n    TESTCASE_AUTO(TestStartsWithAndEndsWithNulTerminated);\n    TESTCASE_AUTO(TestMoveSwap);\n    TESTCASE_AUTO(TestUInt16Pointers);\n    TESTCASE_AUTO(TestWCharPointers);\n    TESTCASE_AUTO(TestNullPointers);\n    TESTCASE_AUTO(TestUnicodeStringInsertAppendToSelf);\n    TESTCASE_AUTO(TestLargeAppend);\n    TESTCASE_AUTO_END;\n}", "target": 0}
{"code": "mm_malloc(struct mm_master *mm, size_t size)\n{\n\tstruct mm_share *mms, *tmp;\n\tif (size == 0)\n\t\tfatal(\"mm_malloc: try to allocate 0 space\");\n\tif (size > SIZE_MAX - MM_MINSIZE + 1)\n\t\tfatal(\"mm_malloc: size too big\");\n\tsize = ((size + (MM_MINSIZE - 1)) / MM_MINSIZE) * MM_MINSIZE;\n\tRB_FOREACH(mms, mmtree, &mm->rb_free) {\n\t\tif (mms->size >= size)\n\t\t\tbreak;\n\t}\n\tif (mms == NULL)\n\t\treturn (NULL);\n\tmemset(mms->address, 0xd0, size);\n\ttmp = mm_make_entry(mm, &mm->rb_allocated, mms->address, size);\n\tmms->size -= size;\n\tmms->address = (char *)mms->address + size;\n\tif (mms->size == 0) {\n\t\tRB_REMOVE(mmtree, &mm->rb_free, mms);\n\t\tif (mm->mmalloc == NULL)\n\t\t\tfree(mms);\n\t\telse\n\t\t\tmm_free(mm->mmalloc, mms);\n\t}\n\treturn (tmp->address);\n}", "target": 1}
{"code": "void ZlibInStream::flushUnderlying()\n{\n  ptr = end = start;\n  while (bytesIn > 0) {\n    decompress(true);\n    end = start; \n  }\n  setUnderlying(NULL, 0);\n}", "target": 0}
{"code": "comics_remove_dir (gchar *path_name) \n{\n\tGDir  *content_dir;\n\tconst gchar *filename;\n\tgchar *filename_with_path;\n\tif (g_file_test (path_name, G_FILE_TEST_IS_DIR)) {\n\t\tcontent_dir = g_dir_open  (path_name, 0, NULL);\n\t\tfilename  = g_dir_read_name (content_dir);\n\t\twhile (filename) {\n\t\t\tfilename_with_path = \n\t\t\t\tg_build_filename (path_name, \n\t\t\t\t\t\t  filename, NULL);\n\t\t\tcomics_remove_dir (filename_with_path);\n\t\t\tg_free (filename_with_path);\n\t\t\tfilename = g_dir_read_name (content_dir);\n\t\t}\n\t\tg_dir_close (content_dir);\n\t}\n\treturn (g_remove (path_name));\n}", "target": 1}
{"code": "void put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\tif (atomic_dec_and_lock_irqsave(&ucounts->count, &ucounts_lock, flags)) {\n\t\thlist_del_init(&ucounts->node);\n\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\t\tput_user_ns(ucounts->ns);\n\t\tkfree(ucounts);\n\t}\n}", "target": 0}
{"code": "para_macro_process(uschar *p, uschar *q)\n{\nint length = q - p;\nargstr **pp;\nmacrodef *md;\nmacroexe *me;\nfor (md = macrolist; md != NULL; md = md->next)\n  {\n  if (length == md->namelength && Ustrncmp(p, md->name, length) == 0) break;\n  }\nif (md == NULL)\n  {\n  error(23, length, p);\n  (void)fprintf(outfile, \"&\");\n  return p;\n  }\nme = misc_malloc(sizeof(macroexe));\nme->prev = macrocurrent;\nmacrocurrent = me;\nme->macro = md;\nme->nextline = md->lines;\nif (from_type_ptr >= FROM_TYPE_STACKSIZE - 1) error(32);  \nfrom_type[++from_type_ptr] = FROM_MACRO;\nme->args = NULL;\npp = &(me->args);\nwhile (isspace(*(++q)));\nwhile (*q != 0 && *q != ')')\n  {\n  argstr *as = misc_malloc(sizeof(argstr));\n  as->next = NULL;\n  *pp = as;\n  pp = &(as->next);\n  as->string = misc_readitem(q, US\",)\", &length, NULL, 0);\n  q += length;\n  if (*q == ',') while (isspace(*(++q)));\n  }\nif (*q != ')')\n  {\n  error(24, p);\n  (void)fprintf(outfile, \"&\");\n  return p;\n  }\npara_inline_macro++;\nfor (;;)\n  {\n  uschar buffer[INBUFFSIZE];\n  read_process_macroline(macrocurrent->nextline->string, buffer);\n  if (*buffer == '.')\n    {\n    dot_process(buffer);\n    if (macrocurrent != me) break;\n    }\n  else\n    {\n    uschar *qq = buffer + Ustrlen(buffer);\n    while (qq > buffer && isspace(qq[-1])) qq--;\n    *qq = 0;\n    para_process(buffer);\n    }\n  macrocurrent->nextline = macrocurrent->nextline->next;\n  if (macrocurrent->nextline == NULL)\n    {\n    macroexe *temp = macrocurrent;\n    macrocurrent = macrocurrent->prev;\n    macro_free(temp);\n    from_type_ptr--;\n    break;\n    }\n  }\npara_inline_macro--;\nreturn q + 1;\n}", "target": 1}
{"code": "safe_add (int a, int b)\n{\n  if (a > INT_MAX/2 || b > INT_MAX/2)\n    return a > b ? a : b;\n  else\n    return a + b;\n}", "target": 0}
{"code": "static int __init big_key_crypto_init(void)\n{\n\tint ret = -EINVAL;\n\tbig_key_rng = crypto_alloc_rng(big_key_rng_name, 0, 0);\n\tif (IS_ERR(big_key_rng)) {\n\t\tbig_key_rng = NULL;\n\t\treturn -EFAULT;\n\t}\n\tret = crypto_rng_reset(big_key_rng, NULL, crypto_rng_seedsize(big_key_rng));\n\tif (ret)\n\t\tgoto error;\n\tbig_key_skcipher = crypto_alloc_skcipher(big_key_alg_name,\n\t\t\t\t\t\t 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(big_key_skcipher)) {\n\t\tbig_key_skcipher = NULL;\n\t\tret = -EFAULT;\n\t\tgoto error;\n\t}\n\treturn 0;\nerror:\n\tcrypto_free_rng(big_key_rng);\n\tbig_key_rng = NULL;\n\treturn ret;\n}", "target": 1}
{"code": "static int em_grp45(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc = X86EMUL_CONTINUE;\n\tswitch (ctxt->modrm_reg) {\n\tcase 2:  {\n\t\tlong int old_eip;\n\t\told_eip = ctxt->_eip;\n\t\tctxt->_eip = ctxt->src.val;\n\t\tctxt->src.val = old_eip;\n\t\trc = em_push(ctxt);\n\t\tbreak;\n\t}\n\tcase 4: \n\t\tctxt->_eip = ctxt->src.val;\n\t\tbreak;\n\tcase 5: \n\t\trc = em_jmp_far(ctxt);\n\t\tbreak;\n\tcase 6:\t\n\t\trc = em_push(ctxt);\n\t\tbreak;\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "SQLWCHAR* _single_string_alloc_and_expand( LPCSTR in )\n{\n    SQLWCHAR *chr;\n    int len = 0;\n    if ( !in )\n    {\n        return in;\n    }\n    while ( in[ len ] != 0 )\n    {\n        len ++;\n    }\n    chr = malloc( sizeof( SQLWCHAR ) * ( len + 1 ));\n    len = 0;\n    while ( in[ len ] != 0 )\n    {\n        chr[ len ] = in[ len ];\n        len ++;\n    }\n    chr[ len ++ ] = 0;\n    return chr;\n}", "target": 1}
{"code": "void UnbufferedAsioTlsStream::BeforeHandshake(handshake_type type)\n{\n\tnamespace ssl = boost::asio::ssl;\n\tif (!m_Hostname.IsEmpty()) {\n\t\tX509_VERIFY_PARAM_set1_host(SSL_get0_param(native_handle()), m_Hostname.CStr(), m_Hostname.GetLength());\n\t}\n\tset_verify_mode(ssl::verify_peer | ssl::verify_client_once);\n\tset_verify_callback([this](bool preverified, ssl::verify_context& ctx) {\n\t\tif (!preverified) {\n\t\t\tm_VerifyOK = false;\n\t\t\tstd::ostringstream msgbuf;\n\t\t\tint err = X509_STORE_CTX_get_error(ctx.native_handle());\n\t\t\tmsgbuf << \"code \" << err << \": \" << X509_verify_cert_error_string(err);\n\t\t\tm_VerifyError = msgbuf.str();\n\t\t}\n\t\treturn true;\n\t});\n#ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME\n\tif (type == client && !m_Hostname.IsEmpty()) {\n\t\tString environmentName = Application::GetAppEnvironment();\n\t\tString serverName = m_Hostname;\n\t\tif (!environmentName.IsEmpty())\n\t\t\tserverName += \":\" + environmentName;\n\t\tSSL_set_tlsext_host_name(native_handle(), serverName.CStr());\n\t}\n#endif \n}", "target": 1}
{"code": "raw_copy_from_user(void *dst, const void __user *src, unsigned long size)\n{\n\tint ret = 0;\n\tif (!__builtin_constant_p(size))\n\t\treturn copy_user_generic(dst, (__force void *)src, size);\n\tswitch (size) {\n\tcase 1:\n\t\t__uaccess_begin_nospec();\n\t\t__get_user_asm_nozero(*(u8 *)dst, (u8 __user *)src,\n\t\t\t      ret, \"b\", \"b\", \"=q\", 1);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 2:\n\t\t__uaccess_begin_nospec();\n\t\t__get_user_asm_nozero(*(u16 *)dst, (u16 __user *)src,\n\t\t\t      ret, \"w\", \"w\", \"=r\", 2);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 4:\n\t\t__uaccess_begin_nospec();\n\t\t__get_user_asm_nozero(*(u32 *)dst, (u32 __user *)src,\n\t\t\t      ret, \"l\", \"k\", \"=r\", 4);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 8:\n\t\t__uaccess_begin_nospec();\n\t\t__get_user_asm_nozero(*(u64 *)dst, (u64 __user *)src,\n\t\t\t      ret, \"q\", \"\", \"=r\", 8);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 10:\n\t\t__uaccess_begin_nospec();\n\t\t__get_user_asm_nozero(*(u64 *)dst, (u64 __user *)src,\n\t\t\t       ret, \"q\", \"\", \"=r\", 10);\n\t\tif (likely(!ret))\n\t\t\t__get_user_asm_nozero(*(u16 *)(8 + (char *)dst),\n\t\t\t\t       (u16 __user *)(8 + (char __user *)src),\n\t\t\t\t       ret, \"w\", \"w\", \"=r\", 2);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 16:\n\t\t__uaccess_begin_nospec();\n\t\t__get_user_asm_nozero(*(u64 *)dst, (u64 __user *)src,\n\t\t\t       ret, \"q\", \"\", \"=r\", 16);\n\t\tif (likely(!ret))\n\t\t\t__get_user_asm_nozero(*(u64 *)(8 + (char *)dst),\n\t\t\t\t       (u64 __user *)(8 + (char __user *)src),\n\t\t\t\t       ret, \"q\", \"\", \"=r\", 8);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tdefault:\n\t\treturn copy_user_generic(dst, (__force void *)src, size);\n\t}\n}", "target": 1}
{"code": "void IOBuf::allocExtBuffer(\n    std::size_t minCapacity,\n    uint8_t** bufReturn,\n    SharedInfo** infoReturn,\n    std::size_t* capacityReturn) {\n  if (minCapacity > kMaxIOBufSize) {\n    throw_exception<std::bad_alloc>();\n  }\n  size_t mallocSize = goodExtBufferSize(minCapacity);\n  auto buf = static_cast<uint8_t*>(checkedMalloc(mallocSize));\n  initExtBuffer(buf, mallocSize, infoReturn, capacityReturn);\n  (*infoReturn)->userData = reinterpret_cast<void*>(mallocSize);\n  if (io_buf_alloc_cb) {\n    io_buf_alloc_cb(buf, mallocSize);\n  }\n  *bufReturn = buf;\n}", "target": 0}
{"code": "static int snd_seq_device_dev_free(struct snd_device *device)\n{\n\tstruct snd_seq_device *dev = device->device_data;\n\tcancel_autoload_drivers();\n\tput_device(&dev->dev);\n\treturn 0;\n}", "target": 0}
{"code": "ciEnv::ciEnv(CompileTask* task)\n  : _ciEnv_arena(mtCompiler) {\n  VM_ENTRY_MARK;\n  thread->set_env(this);\n  assert(ciEnv::current() == this, \"sanity\");\n  _oop_recorder = NULL;\n  _debug_info = NULL;\n  _dependencies = NULL;\n  _failure_reason = NULL;\n  _inc_decompile_count_on_failure = true;\n  _compilable = MethodCompilable;\n  _break_at_compile = false;\n  _compiler_data = NULL;\n#ifndef PRODUCT\n  assert(!firstEnv, \"not initialized properly\");\n#endif \n  _num_inlined_bytecodes = 0;\n  assert(task == NULL || thread->task() == task, \"sanity\");\n  if (task != NULL) {\n    task->mark_started(os::elapsed_counter());\n  }\n  _task = task;\n  _log = NULL;\n  _name_buffer = NULL;\n  _name_buffer_len = 0;\n  _arena   = &_ciEnv_arena;\n  _factory = new (_arena) ciObjectFactory(_arena, 128);\n  assert(Universe::is_fully_initialized(), \"should be complete\");\n  oop o = Universe::null_ptr_exception_instance();\n  assert(o != NULL, \"should have been initialized\");\n  _NullPointerException_instance = get_object(o)->as_instance();\n  o = Universe::arithmetic_exception_instance();\n  assert(o != NULL, \"should have been initialized\");\n  _ArithmeticException_instance = get_object(o)->as_instance();\n  _ArrayIndexOutOfBoundsException_instance = NULL;\n  _ArrayStoreException_instance = NULL;\n  _ClassCastException_instance = NULL;\n  _the_null_string = NULL;\n  _the_min_jint_string = NULL;\n  _jvmti_redefinition_count = 0;\n  _jvmti_can_hotswap_or_post_breakpoint = false;\n  _jvmti_can_access_local_variables = false;\n  _jvmti_can_post_on_exceptions = false;\n  _jvmti_can_pop_frame = false;\n}", "target": 0}
{"code": "TEST(SerializerTest, DuplicateUnionData) {\n  const char data[] =\n      \"\\x0c\" \n      \"\\x00\\x01\" \n      \"\\x0b\" \n      \"\\x00\\x01\" \n      \"\\x00\\x00\\x00\\x00\" \n      \"\\x00\" \n      \"\\x0c\" \n      \"\\x00\\x01\" \n      \"\\x13\" \n      \"\\x00\\x02\"; \n  EXPECT_THROW(\n      BinarySerializer::deserialize<tablebased::TestStructWithUnion>(\n          folly::StringPiece(data, sizeof(data))),\n      std::out_of_range);\n}", "target": 0}
{"code": "static inline bool vm_need_virtualize_apic_accesses(struct kvm *kvm)\n{\n\treturn flexpriority_enabled && irqchip_in_kernel(kvm);\n}", "target": 0}
{"code": "static int kvm_ioctl_create_device(struct kvm *kvm,\n\t\t\t\t   struct kvm_create_device *cd)\n{\n\tstruct kvm_device_ops *ops = NULL;\n\tstruct kvm_device *dev;\n\tbool test = cd->flags & KVM_CREATE_DEVICE_TEST;\n\tint ret;\n\tif (cd->type >= ARRAY_SIZE(kvm_device_ops_table))\n\t\treturn -ENODEV;\n\tops = kvm_device_ops_table[cd->type];\n\tif (ops == NULL)\n\t\treturn -ENODEV;\n\tif (test)\n\t\treturn 0;\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tdev->ops = ops;\n\tdev->kvm = kvm;\n\tmutex_lock(&kvm->lock);\n\tret = ops->create(dev, cd->type);\n\tif (ret < 0) {\n\t\tmutex_unlock(&kvm->lock);\n\t\tkfree(dev);\n\t\treturn ret;\n\t}\n\tlist_add(&dev->vm_node, &kvm->devices);\n\tmutex_unlock(&kvm->lock);\n\tif (ops->init)\n\t\tops->init(dev);\n\tret = anon_inode_getfd(ops->name, &kvm_device_fops, dev, O_RDWR | O_CLOEXEC);\n\tif (ret < 0) {\n\t\tops->destroy(dev);\n\t\tmutex_lock(&kvm->lock);\n\t\tlist_del(&dev->vm_node);\n\t\tmutex_unlock(&kvm->lock);\n\t\treturn ret;\n\t}\n\tkvm_get_kvm(kvm);\n\tcd->fd = ret;\n\treturn 0;\n}", "target": 1}
{"code": "compat_pkalg_proposal(struct ssh *ssh, char *pkalg_prop)\n{\n\tif (!(ssh->compat & SSH_BUG_RSASIGMD5))\n\t\treturn pkalg_prop;\n\tdebug2_f(\"original public key proposal: %s\", pkalg_prop);\n\tif ((pkalg_prop = match_filter_denylist(pkalg_prop, \"ssh-rsa\")) == NULL)\n\t\tfatal(\"match_filter_denylist failed\");\n\tdebug2_f(\"compat public key proposal: %s\", pkalg_prop);\n\tif (*pkalg_prop == '\\0')\n\t\tfatal(\"No supported PK algorithms found\");\n\treturn pkalg_prop;\n}", "target": 1}
{"code": "ProcInstallColormap(ClientPtr client)\n{\n    ColormapPtr pcmp;\n    int rc;\n    REQUEST(xResourceReq);\n    REQUEST_SIZE_MATCH(xResourceReq);\n    rc = dixLookupResourceByType((void **) &pcmp, stuff->id, RT_COLORMAP,\n                                 client, DixInstallAccess);\n    if (rc != Success)\n        goto out;\n    rc = XaceHook(XACE_SCREEN_ACCESS, client, pcmp->pScreen, DixSetAttrAccess);\n    if (rc != Success) {\n        if (rc == BadValue)\n            rc = BadColor;\n        goto out;\n    }\n    (*(pcmp->pScreen->InstallColormap)) (pcmp);\n    return Success;\n out:\n    client->errorValue = stuff->id;\n    return rc;\n}", "target": 0}
{"code": "fp_read_object(CBORDecoderObject *self, const Py_ssize_t size)\n{\n    PyObject *ret = NULL;\n    PyObject *obj, *size_obj;\n    size_obj = PyLong_FromSsize_t(size);\n    if (size_obj) {\n        obj = PyObject_CallFunctionObjArgs(self->read, size_obj, NULL);\n        Py_DECREF(size_obj);\n        if (obj) {\n            assert(PyBytes_CheckExact(obj));\n            if (PyBytes_GET_SIZE(obj) == (Py_ssize_t) size) {\n                ret = obj;\n            } else {\n                Py_DECREF(obj);\n                PyErr_Format(\n                    _CBOR2_CBORDecodeEOF,\n                    \"premature end of stream (expected to read %zd bytes, \"\n                    \"got %zd instead)\", size, PyBytes_GET_SIZE(obj));\n            }\n        }\n    }\n    return ret;\n}", "target": 0}
{"code": "gss_wrap_size_limit(OM_uint32  *minor_status,\n                    gss_ctx_id_t context_handle,\n                    int conf_req_flag,\n                    gss_qop_t qop_req, OM_uint32 req_output_size, OM_uint32 *max_input_size)\n{\n    gss_union_ctx_id_t  ctx;\n    gss_mechanism       mech;\n    OM_uint32           major_status;\n    if (minor_status == NULL)\n        return (GSS_S_CALL_INACCESSIBLE_WRITE);\n    *minor_status = 0;\n    if (context_handle == GSS_C_NO_CONTEXT)\n        return (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n    if (max_input_size == NULL)\n        return (GSS_S_CALL_INACCESSIBLE_WRITE);\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n        return (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (!mech)\n        return (GSS_S_BAD_MECH);\n    if (mech->gss_wrap_size_limit)\n        major_status = mech->gss_wrap_size_limit(minor_status,\n                                                 ctx->internal_ctx_id,\n                                                 conf_req_flag, qop_req,\n                                                 req_output_size, max_input_size);\n    else if (mech->gss_wrap_iov_length)\n        major_status = gssint_wrap_size_limit_iov_shim(mech, minor_status,\n                                                       ctx->internal_ctx_id,\n                                                       conf_req_flag, qop_req,\n                                                       req_output_size, max_input_size);\n    else\n        major_status = GSS_S_UNAVAILABLE;\n    if (major_status != GSS_S_COMPLETE)\n        map_error(minor_status, mech);\n    return major_status;\n}", "target": 0}
{"code": "static int gup_huge_pgd(pgd_t orig, pgd_t *pgdp, unsigned long addr,\n\t\t\tunsigned long end, int write,\n\t\t\tstruct page **pages, int *nr)\n{\n\tint refs;\n\tstruct page *head, *page;\n\tif (!pgd_access_permitted(orig, write))\n\t\treturn 0;\n\tBUILD_BUG_ON(pgd_devmap(orig));\n\trefs = 0;\n\tpage = pgd_page(orig) + ((addr & ~PGDIR_MASK) >> PAGE_SHIFT);\n\tdo {\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\t\tpage++;\n\t\trefs++;\n\t} while (addr += PAGE_SIZE, addr != end);\n\thead = compound_head(pgd_page(orig));\n\tif (!page_cache_add_speculative(head, refs)) {\n\t\t*nr -= refs;\n\t\treturn 0;\n\t}\n\tif (unlikely(pgd_val(orig) != pgd_val(*pgdp))) {\n\t\t*nr -= refs;\n\t\twhile (refs--)\n\t\t\tput_page(head);\n\t\treturn 0;\n\t}\n\tSetPageReferenced(head);\n\treturn 1;\n}", "target": 1}
{"code": "auth_ice_connection (IceConn ice_conn)\n{\n        GIOChannel            *channel;\n        GsmIceConnectionWatch *data;\n        int                    fd;\n        g_debug (\"GsmXsmpServer: auth_ice_connection()\");\n        fd = IceConnectionNumber (ice_conn);\n        fcntl (fd, F_SETFD, fcntl (fd, F_GETFD, 0) | FD_CLOEXEC);\n        channel = g_io_channel_unix_new (fd);\n        data = g_new0 (GsmIceConnectionWatch, 1);\n        ice_conn->context = data;\n        data->protocol_timeout = g_timeout_add_seconds (5,\n                                                        (GSourceFunc)ice_protocol_timeout,\n                                                        ice_conn);\n        data->watch_id = g_io_add_watch (channel,\n                                         G_IO_IN | G_IO_ERR,\n                                         (GIOFunc)auth_iochannel_watch,\n                                         ice_conn);\n        g_io_channel_unref (channel);\n}", "target": 0}
{"code": "static unsigned long randomize_stack_top(unsigned long stack_top)\n{\n\tunsigned int random_variable = 0;\n\tif ((current->flags & PF_RANDOMIZE) &&\n\t\t!(current->personality & ADDR_NO_RANDOMIZE)) {\n\t\trandom_variable = get_random_int() & STACK_RND_MASK;\n\t\trandom_variable <<= PAGE_SHIFT;\n\t}\n#ifdef CONFIG_STACK_GROWSUP\n\treturn PAGE_ALIGN(stack_top) + random_variable;\n#else\n\treturn PAGE_ALIGN(stack_top) - random_variable;\n#endif\n}", "target": 1}
{"code": "mrb_f_send(mrb_state *mrb, mrb_value self)\n{\n  mrb_sym name;\n  mrb_value block, *regs;\n  mrb_method_t m;\n  struct RClass *c;\n  mrb_callinfo *ci = mrb->c->ci;\n  int n = ci->n;\n  if (ci->cci > CINFO_NONE) {\n  funcall:;\n    const mrb_value *argv;\n    mrb_int argc;\n    mrb_get_args(mrb, \"n*&\", &name, &argv, &argc, &block);\n    return mrb_funcall_with_block(mrb, self, name, argc, argv, block);\n  }\n  regs = mrb->c->ci->stack+1;\n  if (n == 0) {\n  argnum_error:\n    mrb_argnum_error(mrb, 0, 1, -1);\n  }\n  else if (n == 15) {\n    if (RARRAY_LEN(regs[0]) == 0) goto argnum_error;\n    name = mrb_obj_to_sym(mrb, RARRAY_PTR(regs[0])[0]);\n  }\n  else {\n    name = mrb_obj_to_sym(mrb, regs[0]);\n  }\n  c = mrb_class(mrb, self);\n  m = mrb_method_search_vm(mrb, &c, name);\n  if (MRB_METHOD_UNDEF_P(m)) {            \n    goto funcall;\n  }\n  ci->mid = name;\n  ci->u.target_class = c;\n  if (n == 15) {     \n    regs[0] = mrb_ary_subseq(mrb, regs[0], 1, RARRAY_LEN(regs[0]) - 1);\n  }\n  else { \n    for (int i=0; i<n; i++) {\n      regs[i] = regs[i+1];\n    }\n    regs[n] = regs[n+1];        \n    if (ci->nk > 0) {\n      regs[n+1] = regs[n+2];    \n    }\n    ci->n--;\n  }\n  if (MRB_METHOD_CFUNC_P(m)) {\n    if (MRB_METHOD_NOARG_P(m)) {\n      check_method_noarg(mrb, ci);\n    }\n    if (MRB_METHOD_PROC_P(m)) {\n      mrb_vm_ci_proc_set(ci, MRB_METHOD_PROC(m));\n    }\n    return MRB_METHOD_CFUNC(m)(mrb, self);\n  }\n  return exec_irep(mrb, self, MRB_METHOD_PROC(m));\n}", "target": 0}
{"code": "    StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes,\n                                                     size_t xTriggerLevelBytes,\n                                                     BaseType_t xIsMessageBuffer )\n    {\n        uint8_t * pucAllocatedMemory;\n        uint8_t ucFlags;\n        if( xIsMessageBuffer == pdTRUE )\n        {\n            ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;\n            configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );\n        }\n        else\n        {\n            ucFlags = 0;\n            configASSERT( xBufferSizeBytes > 0 );\n        }\n        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );\n        if( xTriggerLevelBytes == ( size_t ) 0 )\n        {\n            xTriggerLevelBytes = ( size_t ) 1;\n        }\n        xBufferSizeBytes++;\n        pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); \n        if( pucAllocatedMemory != NULL )\n        {\n            prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory,         \n                                          pucAllocatedMemory + sizeof( StreamBuffer_t ),  \n                                          xBufferSizeBytes,\n                                          xTriggerLevelBytes,\n                                          ucFlags );\n            traceSTREAM_BUFFER_CREATE( ( ( StreamBuffer_t * ) pucAllocatedMemory ), xIsMessageBuffer );\n        }\n        else\n        {\n            traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );\n        }\n        return ( StreamBufferHandle_t ) pucAllocatedMemory; \n    }", "target": 1}
{"code": "static int IsDigit(int enc ARG_UNUSED, int c)\n{\n  if (c >= 0x30 && c <= 0x39) return 1;\n  return 0;\n}", "target": 0}
{"code": "int __gfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error;\n\tint len;\n\tchar *data;\n\tconst char *name = gfs2_acl_name(type);\n\tif (acl && acl->a_count > GFS2_ACL_MAX_ENTRIES(GFS2_SB(inode)))\n\t\treturn -E2BIG;\n\tif (type == ACL_TYPE_ACCESS) {\n\t\tumode_t mode = inode->i_mode;\n\t\terror = posix_acl_equiv_mode(acl, &mode);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\tif (error == 0)\n\t\t\tacl = NULL;\n\t\tif (mode != inode->i_mode) {\n\t\t\tinode->i_mode = mode;\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t}\n\tif (acl) {\n\t\tlen = posix_acl_to_xattr(&init_user_ns, acl, NULL, 0);\n\t\tif (len == 0)\n\t\t\treturn 0;\n\t\tdata = kmalloc(len, GFP_NOFS);\n\t\tif (data == NULL)\n\t\t\treturn -ENOMEM;\n\t\terror = posix_acl_to_xattr(&init_user_ns, acl, data, len);\n\t\tif (error < 0)\n\t\t\tgoto out;\n\t} else {\n\t\tdata = NULL;\n\t\tlen = 0;\n\t}\n\terror = __gfs2_xattr_set(inode, name, data, len, 0, GFS2_EATYPE_SYS);\n\tif (error)\n\t\tgoto out;\n\tset_cached_acl(inode, type, acl);\nout:\n\tkfree(data);\n\treturn error;\n}", "target": 1}
{"code": "TEST(ModMatchExpression, MatchesScalar) {\n    ModMatchExpression mod(\"a\", 5, 2);\n    ASSERT(mod.matchesBSON(BSON(\"a\" << 7.0), NULL));\n    ASSERT(!mod.matchesBSON(BSON(\"a\" << 4), NULL));\n}", "target": 0}
