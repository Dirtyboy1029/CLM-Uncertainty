{"code": "static int backref_match_at_nested_level(regex_t* reg,\n\t OnigStackType* top, OnigStackType* stk_base,\n\t int ignore_case, int case_fold_flag,\n\t int nest, int mem_num, UChar* memp, UChar** s, const UChar* send)\n{\n  UChar *ss, *p, *pstart, *pend = NULL_UCHARP;\n  int level;\n  OnigStackType* k;\n  level = 0;\n  k = top;\n  k--;\n  while (k >= stk_base) {\n    if (k->type == STK_CALL_FRAME) {\n      level--;\n    }\n    else if (k->type == STK_RETURN) {\n      level++;\n    }\n    else if (level == nest) {\n      if (k->type == STK_MEM_START) {\n\tif (mem_is_in_memp(k->u.mem.num, mem_num, memp)) {\n\t  pstart = k->u.mem.pstr;\n\t  if (pend != NULL_UCHARP) {\n\t    if (pend - pstart > send - *s) return 0; \n\t    p  = pstart;\n\t    ss = *s;\n\t    if (ignore_case != 0) {\n\t      if (string_cmp_ic(reg->enc, case_fold_flag,\n\t\t\t\tpstart, &ss, pend - pstart, send) == 0)\n\t\treturn 0; \n\t    }\n\t    else {\n\t      while (p < pend) {\n\t\tif (*p++ != *ss++) return 0; \n\t      }\n\t    }\n\t    *s = ss;\n\t    return 1;\n\t  }\n\t}\n      }\n      else if (k->type == STK_MEM_END) {\n\tif (mem_is_in_memp(k->u.mem.num, mem_num, memp)) {\n\t  pend = k->u.mem.pstr;\n\t}\n      }\n    }\n    k--;\n  }\n  return 0;\n}", "target": 0}
{"code": "void LibRaw::nikon_coolscan_load_raw()\n{\n  if (!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  int bypp = tiff_bps <= 8 ? 1 : 2;\n  int bufsize = width * 3 * bypp;\n  unsigned char *buf = (unsigned char *)malloc(bufsize);\n  unsigned short *ubuf = (unsigned short *)buf;\n  if (tiff_bps <= 8)\n    gamma_curve(1.0 / imgdata.params.coolscan_nef_gamma, 0., 1, 255);\n  else\n    gamma_curve(1.0 / imgdata.params.coolscan_nef_gamma, 0., 1, 65535);\n  fseek(ifp, data_offset, SEEK_SET);\n  for (int row = 0; row < raw_height; row++)\n  {\n      if(tiff_bps <=8)\n        fread(buf, 1, bufsize, ifp);\n      else\n          read_shorts(ubuf,width*3);\n    unsigned short(*ip)[4] = (unsigned short(*)[4])image + row * width;\n    if (is_NikonTransfer == 2)\n    { \n      for (int col = 0; col < width; col++)\n      {\n        ip[col][0] = ((float)curve[buf[col * 3]]) / 255.0f;\n        ip[col][1] = ((float)curve[buf[col * 3 + 1]]) / 255.0f;\n        ip[col][2] = ((float)curve[buf[col * 3 + 2]]) / 255.0f;\n        ip[col][3] = 0;\n      }\n    }\n    else if (tiff_bps <= 8)\n    {\n      for (int col = 0; col < width; col++)\n      {\n        ip[col][0] = curve[buf[col * 3]];\n        ip[col][1] = curve[buf[col * 3 + 1]];\n        ip[col][2] = curve[buf[col * 3 + 2]];\n        ip[col][3] = 0;\n      }\n    }\n    else\n    {\n      for (int col = 0; col < width; col++)\n      {\n        ip[col][0] = curve[ubuf[col * 3]];\n        ip[col][1] = curve[ubuf[col * 3 + 1]];\n        ip[col][2] = curve[ubuf[col * 3 + 2]];\n        ip[col][3] = 0;\n      }\n    }\n  }\n  free(buf);\n}", "target": 0}
{"code": "static struct key *request_master_key(struct encrypted_key_payload *epayload,\n\t\t\t\t      const u8 **master_key, size_t *master_keylen)\n{\n\tstruct key *mkey = ERR_PTR(-EINVAL);\n\tif (!strncmp(epayload->master_desc, KEY_TRUSTED_PREFIX,\n\t\t     KEY_TRUSTED_PREFIX_LEN)) {\n\t\tmkey = request_trusted_key(epayload->master_desc +\n\t\t\t\t\t   KEY_TRUSTED_PREFIX_LEN,\n\t\t\t\t\t   master_key, master_keylen);\n\t} else if (!strncmp(epayload->master_desc, KEY_USER_PREFIX,\n\t\t\t    KEY_USER_PREFIX_LEN)) {\n\t\tmkey = request_user_key(epayload->master_desc +\n\t\t\t\t\tKEY_USER_PREFIX_LEN,\n\t\t\t\t\tmaster_key, master_keylen);\n\t} else\n\t\tgoto out;\n\tif (IS_ERR(mkey)) {\n\t\tint ret = PTR_ERR(mkey);\n\t\tif (ret == -ENOTSUPP)\n\t\t\tpr_info(\"encrypted_key: key %s not supported\",\n\t\t\t\tepayload->master_desc);\n\t\telse\n\t\t\tpr_info(\"encrypted_key: key %s not found\",\n\t\t\t\tepayload->master_desc);\n\t\tgoto out;\n\t}\n\tdump_master_key(*master_key, *master_keylen);\nout:\n\treturn mkey;\n}", "target": 0}
{"code": "process_mic(OM_uint32 *minor_status, gss_buffer_t mic_in,\n\t    spnego_gss_ctx_id_t sc, gss_buffer_t *mic_out,\n\t    OM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 ret, tmpmin;\n\tgss_qop_t qop_state;\n\tgss_buffer_desc tmpmic = GSS_C_EMPTY_BUFFER;\n\tret = GSS_S_FAILURE;\n\tif (mic_in != GSS_C_NO_BUFFER) {\n\t\tret = gss_verify_mic(minor_status, sc->ctx_handle,\n\t\t\t\t     &sc->DER_mechTypes,\n\t\t\t\t     mic_in, &qop_state);\n\t\tif (ret != GSS_S_COMPLETE) {\n\t\t\t*negState = REJECT;\n\t\t\t*tokflag = ERROR_TOKEN_SEND;\n\t\t\treturn ret;\n\t\t}\n\t\tsc->mic_reqd = 1;\n\t\tsc->mic_rcvd = 1;\n\t}\n\tif (sc->mic_reqd && !sc->mic_sent) {\n\t\tret = gss_get_mic(minor_status, sc->ctx_handle,\n\t\t\t\t  GSS_C_QOP_DEFAULT,\n\t\t\t\t  &sc->DER_mechTypes,\n\t\t\t\t  &tmpmic);\n\t\tif (ret != GSS_S_COMPLETE) {\n\t\t\tgss_release_buffer(&tmpmin, &tmpmic);\n\t\t\t*tokflag = NO_TOKEN_SEND;\n\t\t\treturn ret;\n\t\t}\n\t\t*mic_out = malloc(sizeof(gss_buffer_desc));\n\t\tif (*mic_out == GSS_C_NO_BUFFER) {\n\t\t\tgss_release_buffer(&tmpmin, &tmpmic);\n\t\t\t*tokflag = NO_TOKEN_SEND;\n\t\t\treturn GSS_S_FAILURE;\n\t\t}\n\t\t**mic_out = tmpmic;\n\t\tsc->mic_sent = 1;\n\t}\n\treturn GSS_S_COMPLETE;\n}", "target": 0}
{"code": "int RGWHandler_REST_S3Website::error_handler(int err_no,\n\t\t\t\t\t    string* error_content) {\n  int new_err_no = -1;\n  rgw_http_errors::const_iterator r = rgw_http_s3_errors.find(err_no > 0 ? err_no : -err_no);\n  int http_error_code = -1;\n  if (r != rgw_http_s3_errors.end()) {\n    http_error_code = r->second.first;\n  }\n  ldpp_dout(s, 10) << \"RGWHandler_REST_S3Website::error_handler err_no=\" << err_no << \" http_ret=\" << http_error_code << dendl;\n  RGWBWRoutingRule rrule;\n  bool should_redirect =\n    s->bucket_info.website_conf.should_redirect(original_object_name,\n                                                http_error_code, &rrule);\n  if (should_redirect) {\n    const string& hostname = s->info.env->get(\"HTTP_HOST\", \"\");\n    const string& protocol =\n      (s->info.env->get(\"SERVER_PORT_SECURE\") ? \"https\" : \"http\");\n    int redirect_code = 0;\n    rrule.apply_rule(protocol, hostname, original_object_name,\n                     &s->redirect, &redirect_code);\n    if (redirect_code > 0)\n      s->err.http_ret = redirect_code; \n    ldpp_dout(s, 10) << \"error handler redirect code=\" << redirect_code\n\t\t      << \" proto+host:\" << protocol << \":\n\t\t      << \" -> \" << s->redirect << dendl;\n    return -ERR_WEBSITE_REDIRECT;\n  } else if (err_no == -ERR_WEBSITE_REDIRECT) {\n  } else if (!s->bucket_info.website_conf.error_doc.empty()) {\n    new_err_no = RGWHandler_REST_S3Website::serve_errordoc(http_error_code, s->bucket_info.website_conf.error_doc);\n    if (new_err_no && new_err_no != -1) {\n      err_no = new_err_no;\n    }\n  } else {\n    ldpp_dout(s, 20) << \"No special error handling today!\" << dendl;\n  }\n  return err_no;\n}", "target": 0}
{"code": "static void free_nested(struct vcpu_vmx *vmx)\n{\n\tif (!vmx->nested.vmxon)\n\t\treturn;\n\tvmx->nested.vmxon = false;\n\tnested_release_vmcs12(vmx);\n\tif (enable_shadow_vmcs)\n\t\tfree_vmcs(vmx->nested.current_shadow_vmcs);\n\tif (vmx->nested.apic_access_page) {\n\t\tnested_release_page(vmx->nested.apic_access_page);\n\t\tvmx->nested.apic_access_page = NULL;\n\t}\n\tif (vmx->nested.virtual_apic_page) {\n\t\tnested_release_page(vmx->nested.virtual_apic_page);\n\t\tvmx->nested.virtual_apic_page = NULL;\n\t}\n\tnested_free_all_saved_vmcss(vmx);\n}", "target": 0}
{"code": "local block_state deflate_huff(s, flush)\n    deflate_state *s;\n    int flush;\n{\n    int bflush;             \n    for (;;) {\n        if (s->lookahead == 0) {\n            fill_window(s);\n            if (s->lookahead == 0) {\n                if (flush == Z_NO_FLUSH)\n                    return need_more;\n                break;      \n            }\n        }\n        s->match_length = 0;\n        Tracevv((stderr,\"%c\", s->window[s->strstart]));\n        _tr_tally_lit (s, s->window[s->strstart], bflush);\n        s->lookahead--;\n        s->strstart++;\n        if (bflush) FLUSH_BLOCK(s, 0);\n    }\n    s->insert = 0;\n    if (flush == Z_FINISH) {\n        FLUSH_BLOCK(s, 1);\n        return finish_done;\n    }\n    if (s->last_lit)\n        FLUSH_BLOCK(s, 0);\n    return block_done;\n}", "target": 1}
{"code": "ring_set_paused(const struct intel_engine_cs *engine, int state)\n{\n\tengine->status_page.addr[I915_GEM_HWS_PREEMPT] = state;\n\tif (state)\n\t\twmb();\n}", "target": 0}
{"code": "const EVP_MD *tls12_get_hash(unsigned char hash_alg)\n{\n    switch (hash_alg) {\n# ifndef OPENSSL_NO_MD5\n    case TLSEXT_hash_md5:\n#  ifdef OPENSSL_FIPS\n        if (FIPS_mode())\n            return NULL;\n#  endif\n        return EVP_md5();\n# endif\n# ifndef OPENSSL_NO_SHA\n    case TLSEXT_hash_sha1:\n        return EVP_sha1();\n# endif\n# ifndef OPENSSL_NO_SHA256\n    case TLSEXT_hash_sha224:\n        return EVP_sha224();\n    case TLSEXT_hash_sha256:\n        return EVP_sha256();\n# endif\n# ifndef OPENSSL_NO_SHA512\n    case TLSEXT_hash_sha384:\n        return EVP_sha384();\n    case TLSEXT_hash_sha512:\n        return EVP_sha512();\n# endif\n    default:\n        return NULL;\n    }\n}", "target": 0}
{"code": "static DBusConnection *si_dbus_get_system_bus(void)\n{\n    DBusConnection *connection;\n    DBusError error;\n    dbus_error_init(&error);\n    connection = dbus_bus_get_private(DBUS_BUS_SYSTEM, &error);\n    if (connection == NULL || dbus_error_is_set(&error)) {\n        if (dbus_error_is_set(&error)) {\n            syslog(LOG_WARNING, \"Unable to connect to system bus: %s\",\n                   error.message);\n            dbus_error_free(&error);\n        } else {\n            syslog(LOG_WARNING, \"Unable to connect to system bus\");\n        }\n        return NULL;\n    }\n    return connection;\n}", "target": 0}
{"code": "void html_url_path(const char *txt)\n{\n\tconst char *t = txt;\n\twhile (t && *t) {\n\t\tunsigned char c = *t;\n\t\tconst char *e = url_escape_table[c];\n\t\tif (e && c != '+' && c != '&') {\n\t\t\thtml_raw(txt, t - txt);\n\t\t\thtml(e);\n\t\t\ttxt = t + 1;\n\t\t}\n\t\tt++;\n\t}\n\tif (t != txt)\n\t\thtml(txt);\n}", "target": 0}
{"code": "static int su3000_power_ctrl(struct dvb_usb_device *d, int i)\n{\n\tstruct dw2102_state *state = (struct dw2102_state *)d->priv;\n\tu8 obuf[] = {0xde, 0};\n\tinfo(\"%s: %d, initialized %d\", __func__, i, state->initialized);\n\tif (i && !state->initialized) {\n\t\tstate->initialized = 1;\n\t\treturn dvb_usb_generic_rw(d, obuf, 2, NULL, 0, 0);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void TEMPLATE(process_block_dec)(decoder_info_t *decoder_info,int size,int yposY,int xposY,int sub)\n{\n  int width = decoder_info->width;\n  int height = decoder_info->height;\n  stream_t *stream = decoder_info->stream;\n  frame_type_t frame_type = decoder_info->frame_info.frame_type;\n  int split_flag = 0;\n  if (yposY >= height || xposY >= width)\n    return;\n  int decode_this_size = (yposY + size <= height) && (xposY + size <= width);\n  int decode_rectangular_size = !decode_this_size && frame_type != I_FRAME;\n  int bit_start = stream->bitcnt;\n  int mode = MODE_SKIP;\n  block_context_t block_context;\n  TEMPLATE(find_block_contexts)(yposY, xposY, height, width, size, decoder_info->deblock_data, &block_context, decoder_info->use_block_contexts);\n  decoder_info->block_context = &block_context;\n  split_flag = decode_super_mode(decoder_info,size,decode_this_size);\n  mode = decoder_info->mode;\n  if (size == (1<<decoder_info->log2_sb_size) && (split_flag || mode != MODE_SKIP) && decoder_info->max_delta_qp > 0) {\n    int delta_qp = read_delta_qp(stream);\n    int prev_qp;\n    if (yposY == 0 && xposY == 0)\n      prev_qp = decoder_info->frame_info.qp;\n    else\n      prev_qp = decoder_info->frame_info.qpb;\n    decoder_info->frame_info.qpb = prev_qp + delta_qp;\n  }\n  decoder_info->bit_count.super_mode[decoder_info->bit_count.stat_frame_type] += (stream->bitcnt - bit_start);\n  if (split_flag){\n    int new_size = size/2;\n    TEMPLATE(process_block_dec)(decoder_info,new_size,yposY+0*new_size,xposY+0*new_size,sub);\n    TEMPLATE(process_block_dec)(decoder_info,new_size,yposY+1*new_size,xposY+0*new_size,sub);\n    TEMPLATE(process_block_dec)(decoder_info,new_size,yposY+0*new_size,xposY+1*new_size,sub);\n    TEMPLATE(process_block_dec)(decoder_info,new_size,yposY+1*new_size,xposY+1*new_size,sub);\n  }\n  else if (decode_this_size || decode_rectangular_size){\n    decode_block(decoder_info,size,yposY,xposY,sub);\n  }\n}", "target": 1}
{"code": "monitor_allowed_key(u_char *blob, u_int bloblen)\n{\n\tif (key_blob == NULL || key_bloblen != bloblen ||\n\t    memcmp(key_blob, blob, key_bloblen))\n\t\treturn (0);\n\treturn (1);\n}", "target": 0}
{"code": "static int orinoco_ioctl_set_auth(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\thermes_t *hw = &priv->hw;\n\tstruct iw_param *param = &wrqu->param;\n\tunsigned long flags;\n\tint ret = -EINPROGRESS;\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\tswitch (param->flags & IW_AUTH_INDEX) {\n\tcase IW_AUTH_WPA_VERSION:\n\tcase IW_AUTH_CIPHER_PAIRWISE:\n\tcase IW_AUTH_CIPHER_GROUP:\n\tcase IW_AUTH_RX_UNENCRYPTED_EAPOL:\n\tcase IW_AUTH_PRIVACY_INVOKED:\n\tcase IW_AUTH_DROP_UNENCRYPTED:\n\t\tbreak;\n\tcase IW_AUTH_KEY_MGMT:\n\t\tpriv->key_mgmt = param->value;\n\t\tbreak;\n\tcase IW_AUTH_TKIP_COUNTERMEASURES:\n\t\tif (param->value) {\n\t\t\tpriv->tkip_cm_active = 1;\n\t\t\tret = hermes_enable_port(hw, 0);\n\t\t} else {\n\t\t\tpriv->tkip_cm_active = 0;\n\t\t\tret = hermes_disable_port(hw, 0);\n\t\t}\n\t\tbreak;\n\tcase IW_AUTH_80211_AUTH_ALG:\n\t\tif (param->value & IW_AUTH_ALG_SHARED_KEY)\n\t\t\tpriv->wep_restrict = 1;\n\t\telse if (param->value & IW_AUTH_ALG_OPEN_SYSTEM)\n\t\t\tpriv->wep_restrict = 0;\n\t\telse\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\tcase IW_AUTH_WPA_ENABLED:\n\t\tif (priv->has_wpa) {\n\t\t\tpriv->wpa_enabled = param->value ? 1 : 0;\n\t\t} else {\n\t\t\tif (param->value)\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\tpriv->wpa_enabled = 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t}\n\torinoco_unlock(priv, &flags);\n\treturn ret;\n}", "target": 1}
{"code": "x509_verify_ctx_add_chain(struct x509_verify_ctx *ctx,\n    struct x509_verify_chain *chain, char *name)\n{\n\tsize_t depth;\n\tX509 *last = x509_verify_chain_last(chain);\n\tX509 *leaf = x509_verify_chain_leaf(chain);\n\tdepth = sk_X509_num(chain->certs);\n\tif (depth > 0)\n\t\tdepth--;\n\tif (ctx->chains_count >= ctx->max_chains)\n\t\treturn x509_verify_cert_error(ctx, last, depth,\n\t\t    X509_V_ERR_CERT_CHAIN_TOO_LONG, 0);\n\tif (chain->cert_errors[depth] ==\n\t    X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY)\n\t\tchain->cert_errors[depth] = X509_V_OK;\n\tif (!x509_verify_ctx_validate_legacy_chain(ctx, chain, depth))\n\t\treturn 0;\n\tif ((ctx->chains[ctx->chains_count] = x509_verify_chain_dup(chain)) ==\n\t    NULL) {\n\t\treturn x509_verify_cert_error(ctx, last, depth,\n\t\t    X509_V_ERR_OUT_OF_MEM, 0);\n\t}\n\tif (!x509_verify_cert_valid(ctx, leaf, NULL))\n\t\treturn 0;\n\tif (!x509_verify_cert_hostname(ctx, leaf, name))\n\t\treturn 0;\n\tctx->chains_count++;\n\tctx->error = X509_V_OK;\n\tctx->error_depth = depth;\n\treturn 1;\n}", "target": 1}
{"code": "fbStore_b2g3r3 (FbBits *bits, const CARD32 *values, int x, int width, miIndexedPtr indexed)\n{\n    int i;\n    CARD8   *pixel = ((CARD8 *) bits) + x;\n    for (i = 0; i < width; ++i) {\n        Split(READ(values + i));\n        WRITE(pixel++, ((b     ) & 0xe0) |\n\t      ((g >> 3) & 0x1c) |\n\t      ((r >> 6)       ));\n    }\n}", "target": 0}
{"code": "unsigned int inet6_hash_frag(__be32 id, const struct in6_addr *saddr,\n\t\t\t     const struct in6_addr *daddr, u32 rnd)\n{\n\tu32 a, b, c;\n\ta = (__force u32)saddr->s6_addr32[0];\n\tb = (__force u32)saddr->s6_addr32[1];\n\tc = (__force u32)saddr->s6_addr32[2];\n\ta += JHASH_GOLDEN_RATIO;\n\tb += JHASH_GOLDEN_RATIO;\n\tc += rnd;\n\t__jhash_mix(a, b, c);\n\ta += (__force u32)saddr->s6_addr32[3];\n\tb += (__force u32)daddr->s6_addr32[0];\n\tc += (__force u32)daddr->s6_addr32[1];\n\t__jhash_mix(a, b, c);\n\ta += (__force u32)daddr->s6_addr32[2];\n\tb += (__force u32)daddr->s6_addr32[3];\n\tc += (__force u32)id;\n\t__jhash_mix(a, b, c);\n\treturn c & (INETFRAGS_HASHSZ - 1);\n}", "target": 0}
{"code": "static struct page *__page_frag_cache_refill(struct page_frag_cache *nc,\n\t\t\t\t\t     gfp_t gfp_mask)\n{\n\tstruct page *page = NULL;\n\tgfp_t gfp = gfp_mask;\n#if (PAGE_SIZE < PAGE_FRAG_CACHE_MAX_SIZE)\n\tgfp_mask |= __GFP_COMP | __GFP_NOWARN | __GFP_NORETRY |\n\t\t    __GFP_NOMEMALLOC;\n\tpage = alloc_pages_node(NUMA_NO_NODE, gfp_mask,\n\t\t\t\tPAGE_FRAG_CACHE_MAX_ORDER);\n\tnc->size = page ? PAGE_FRAG_CACHE_MAX_SIZE : PAGE_SIZE;\n#endif\n\tif (unlikely(!page))\n\t\tpage = alloc_pages_node(NUMA_NO_NODE, gfp, 0);\n\tnc->va = page ? page_address(page) : NULL;\n\treturn page;\n}", "target": 0}
{"code": "int mpol_parse_str(char *str, struct mempolicy **mpol)\n{\n\tstruct mempolicy *new = NULL;\n\tunsigned short mode_flags;\n\tnodemask_t nodes;\n\tchar *nodelist = strchr(str, ':');\n\tchar *flags = strchr(str, '=');\n\tint err = 1, mode;\n\tif (flags)\n\t\t*flags++ = '\\0';\t\n\tif (nodelist) {\n\t\t*nodelist++ = '\\0';\n\t\tif (nodelist_parse(nodelist, nodes))\n\t\t\tgoto out;\n\t\tif (!nodes_subset(nodes, node_states[N_MEMORY]))\n\t\t\tgoto out;\n\t} else\n\t\tnodes_clear(nodes);\n\tmode = match_string(policy_modes, MPOL_MAX, str);\n\tif (mode < 0)\n\t\tgoto out;\n\tswitch (mode) {\n\tcase MPOL_PREFERRED:\n\t\tif (nodelist) {\n\t\t\tchar *rest = nodelist;\n\t\t\twhile (isdigit(*rest))\n\t\t\t\trest++;\n\t\t\tif (*rest)\n\t\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase MPOL_INTERLEAVE:\n\t\tif (!nodelist)\n\t\t\tnodes = node_states[N_MEMORY];\n\t\tbreak;\n\tcase MPOL_LOCAL:\n\t\tif (nodelist)\n\t\t\tgoto out;\n\t\tmode = MPOL_PREFERRED;\n\t\tbreak;\n\tcase MPOL_DEFAULT:\n\t\tif (!nodelist)\n\t\t\terr = 0;\n\t\tgoto out;\n\tcase MPOL_BIND:\n\t\tif (!nodelist)\n\t\t\tgoto out;\n\t}\n\tmode_flags = 0;\n\tif (flags) {\n\t\tif (!strcmp(flags, \"static\"))\n\t\t\tmode_flags |= MPOL_F_STATIC_NODES;\n\t\telse if (!strcmp(flags, \"relative\"))\n\t\t\tmode_flags |= MPOL_F_RELATIVE_NODES;\n\t\telse\n\t\t\tgoto out;\n\t}\n\tnew = mpol_new(mode, mode_flags, &nodes);\n\tif (IS_ERR(new))\n\t\tgoto out;\n\tif (mode != MPOL_PREFERRED)\n\t\tnew->v.nodes = nodes;\n\telse if (nodelist)\n\t\tnew->v.preferred_node = first_node(nodes);\n\telse\n\t\tnew->flags |= MPOL_F_LOCAL;\n\tnew->w.user_nodemask = nodes;\n\terr = 0;\nout:\n\tif (nodelist)\n\t\t*--nodelist = ':';\n\tif (flags)\n\t\t*--flags = '=';\n\tif (!err)\n\t\t*mpol = new;\n\treturn err;\n}", "target": 1}
{"code": "static int kvm_vcpu_ioctl_set_cpuid2(struct kvm_vcpu *vcpu,\n\t\t\t\t     struct kvm_cpuid2 *cpuid,\n\t\t\t\t     struct kvm_cpuid_entry2 __user *entries)\n{\n\tint r;\n\tr = -E2BIG;\n\tif (cpuid->nent > KVM_MAX_CPUID_ENTRIES)\n\t\tgoto out;\n\tr = -EFAULT;\n\tif (copy_from_user(&vcpu->arch.cpuid_entries, entries,\n\t\t\t   cpuid->nent * sizeof(struct kvm_cpuid_entry2)))\n\t\tgoto out;\n\tvcpu->arch.cpuid_nent = cpuid->nent;\n\tkvm_apic_set_version(vcpu);\n\tkvm_x86_ops->cpuid_update(vcpu);\n\tupdate_cpuid(vcpu);\n\treturn 0;\nout:\n\treturn r;\n}", "target": 0}
{"code": "void OmniboxViewWin::OnKillFocus(HWND focus_wnd) {\n  if (m_hWnd == focus_wnd) {\n    SetMsgHandled(false);\n    return;\n  }\n  model_->OnWillKillFocus(focus_wnd);\n  ClosePopup();\n  GetSelection(saved_selection_for_focus_change_);\n  model_->OnKillFocus();\n  ScopedFreeze freeze(this, GetTextObjectModel());\n  DefWindowProc(WM_KILLFOCUS, reinterpret_cast<WPARAM>(focus_wnd), 0);\n  SelectAll(true);\n  PlaceCaretAt(0);\n}", "target": 0}
{"code": "_pyfribidi_log2vis (PyObject * self, PyObject * args, PyObject * kw)\n{\n\tPyObject *logical = NULL;\t\n\tFriBidiParType base = FRIBIDI_TYPE_RTL;\t\n\tconst char *encoding = \"utf-8\";\t\n\tint clean = 0; \n\tint reordernsm = 1; \n\tstatic char *kwargs[] =\n\t        { \"logical\", \"base_direction\", \"encoding\", \"clean\", \"reordernsm\", NULL };\n        if (!PyArg_ParseTupleAndKeywords (args, kw, \"O|isii\", kwargs,\n\t\t\t\t\t  &logical, &base, &encoding, &clean, &reordernsm))\n\t\treturn NULL;\n\tif (!(base == FRIBIDI_TYPE_RTL ||\n\t      base == FRIBIDI_TYPE_LTR || base == FRIBIDI_TYPE_ON))\n\t\treturn PyErr_Format (PyExc_ValueError,\n\t\t\t\t     \"invalid value %d: use either RTL, LTR or ON\",\n\t\t\t\t     base);\n\tif (PyUnicode_Check (logical))\n\t        return log2vis_unicode (logical, base, clean, reordernsm);\n\telse if (PyString_Check (logical))\n\t        return log2vis_encoded_string (logical, encoding, base, clean, reordernsm);\n\telse\n\t\treturn PyErr_Format (PyExc_TypeError,\n\t\t\t\t     \"expected unicode or str, not %s\",\n\t\t\t\t     logical->ob_type->tp_name);\n}", "target": 1}
{"code": "static void pptp_timeout(struct triton_timer_t *t)\n{\n\tstruct pptp_conn_t *conn = container_of(t, typeof(*conn), timeout_timer);\n\tdisconnect(conn);\n}", "target": 0}
{"code": "sudo_auth_cleanup(const struct sudoers_context *ctx, struct passwd *pw,\n    bool force)\n{\n    sudo_auth *auth;\n    debug_decl(sudo_auth_cleanup, SUDOERS_DEBUG_AUTH);\n    for (auth = auth_switch; auth->name; auth++) {\n\tif (auth->cleanup && !IS_DISABLED(auth)) {\n\t    int status = (auth->cleanup)(ctx, pw, auth, force);\n\t    if (status == AUTH_ERROR) {\n\t\tdebug_return_int(-1);\n\t    }\n\t}\n    }\n    debug_return_int(0);\n}", "target": 1}
{"code": "bool allow_svhandler_flash_sector(const FlashSector* sector) {\n  return sector->use == FLASH_STORAGE1 ||\n         sector->use == FLASH_STORAGE2 ||\n         sector->use == FLASH_STORAGE3 ||\n         sector->use == FLASH_UNUSED0 ||\n         sector->use == FLASH_APP;\n}", "target": 0}
{"code": "__acquires(bitlock)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tif (unlikely(ext4_forced_shutdown(EXT4_SB(sb))))\n\t\treturn;\n\ttrace_ext4_error(sb, function, line);\n\tes->s_last_error_ino = cpu_to_le32(ino);\n\tes->s_last_error_block = cpu_to_le64(block);\n\t__save_error_info(sb, function, line);\n\tif (ext4_error_ratelimit(sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: group %u, \",\n\t\t       sb->s_id, function, line, grp);\n\t\tif (ino)\n\t\t\tprintk(KERN_CONT \"inode %lu: \", ino);\n\t\tif (block)\n\t\t\tprintk(KERN_CONT \"block %llu:\",\n\t\t\t       (unsigned long long) block);\n\t\tprintk(KERN_CONT \"%pV\\n\", &vaf);\n\t\tva_end(args);\n\t}\n\tif (test_opt(sb, ERRORS_CONT)) {\n\t\text4_commit_super(sb, 0);\n\t\treturn;\n\t}\n\text4_unlock_group(sb, grp);\n\text4_commit_super(sb, 1);\n\text4_handle_error(sb);\n\text4_lock_group(sb, grp);\n\treturn;\n}", "target": 0}
{"code": "int TfLiteIntArrayGetSizeInBytes(int size) {\n  static TfLiteIntArray dummy;\n  int computed_size = sizeof(dummy) + sizeof(dummy.data[0]) * size;\n#if defined(_MSC_VER)\n  computed_size -= sizeof(dummy.data[0]);\n#endif\n  return computed_size;\n}", "target": 1}
{"code": "int tipc_node_get_mtu(struct net *net, u32 addr, u32 sel, bool connected)\n{\n\tstruct tipc_node *n;\n\tint bearer_id;\n\tunsigned int mtu = MAX_MSG_SIZE;\n\tn = tipc_node_find(net, addr);\n\tif (unlikely(!n))\n\t\treturn mtu;\n\tif (n->peer_net && connected) {\n\t\ttipc_node_put(n);\n\t\treturn mtu;\n\t}\n\tbearer_id = n->active_links[sel & 1];\n\tif (likely(bearer_id != INVALID_BEARER_ID))\n\t\tmtu = n->links[bearer_id].mtu;\n\ttipc_node_put(n);\n\treturn mtu;\n}", "target": 0}
{"code": "hyphenHashInsert (HyphenHashTab * hashTab, const CharsString * key, int val)\n{\n  int i, j;\n  HyphenHashEntry *e;\n  i = hyphenStringHash (key) % HYPHENHASHSIZE;\n  if (!(e = malloc (sizeof (HyphenHashEntry))))\n    outOfMemory ();\n  e->next = hashTab->entries[i];\n  e->key = malloc ((key->length + 1) * CHARSIZE);\n  if (!e->key)\n    outOfMemory ();\n  e->key->length = key->length;\n  for (j = 0; j < key->length; j++)\n    e->key->chars[j] = key->chars[j];\n  e->val = val;\n  hashTab->entries[i] = e;\n}", "target": 0}
{"code": "parse_memory(VALUE klass, VALUE data, VALUE encoding)\n{\n  htmlParserCtxtPtr ctxt;\n  if (NIL_P(data)) {\n    rb_raise(rb_eArgError, \"data cannot be nil\");\n  }\n  if (!(int)RSTRING_LEN(data)) {\n    rb_raise(rb_eRuntimeError, \"data cannot be empty\");\n  }\n  ctxt = htmlCreateMemoryParserCtxt(StringValuePtr(data),\n                                    (int)RSTRING_LEN(data));\n  if (ctxt->sax) {\n    xmlFree(ctxt->sax);\n    ctxt->sax = NULL;\n  }\n  if (RTEST(encoding)) {\n    xmlCharEncodingHandlerPtr enc = xmlFindCharEncodingHandler(StringValueCStr(encoding));\n    if (enc != NULL) {\n      xmlSwitchToEncoding(ctxt, enc);\n      if (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {\n        rb_raise(rb_eRuntimeError, \"Unsupported encoding %s\",\n                 StringValueCStr(encoding));\n      }\n    }\n  }\n  return Data_Wrap_Struct(klass, NULL, deallocate, ctxt);\n}", "target": 1}
{"code": "static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)\n{\n  unsigned result = 0;\n  size_t i;\n  for(i = nbits - 1; i < nbits; i--)\n  {\n    result += (unsigned)readBitFromReversedStream(bitpointer, bitstream) << i;\n  }\n  return result;\n}", "target": 0}
{"code": "sg_new_read(Sg_fd * sfp, char __user *buf, size_t count, Sg_request * srp)\n{\n\tsg_io_hdr_t *hp = &srp->header;\n\tint err = 0, err2;\n\tint len;\n\tif (in_compat_syscall()) {\n\t\tif (count < sizeof(struct compat_sg_io_hdr)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\t} else if (count < SZ_SG_IO_HDR) {\n\t\terr = -EINVAL;\n\t\tgoto err_out;\n\t}\n\thp->sb_len_wr = 0;\n\tif ((hp->mx_sb_len > 0) && hp->sbp) {\n\t\tif ((CHECK_CONDITION & hp->masked_status) ||\n\t\t    (DRIVER_SENSE & hp->driver_status)) {\n\t\t\tint sb_len = SCSI_SENSE_BUFFERSIZE;\n\t\t\tsb_len = (hp->mx_sb_len > sb_len) ? sb_len : hp->mx_sb_len;\n\t\t\tlen = 8 + (int) srp->sense_b[7];\t\n\t\t\tlen = (len > sb_len) ? sb_len : len;\n\t\t\tif (copy_to_user(hp->sbp, srp->sense_b, len)) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\thp->sb_len_wr = len;\n\t\t}\n\t}\n\tif (hp->masked_status || hp->host_status || hp->driver_status)\n\t\thp->info |= SG_INFO_CHECK;\n\terr = put_sg_io_hdr(hp, buf);\nerr_out:\n\terr2 = sg_finish_rem_req(srp);\n\tsg_remove_request(sfp, srp);\n\treturn err ? : err2 ? : count;\n}", "target": 0}
{"code": "void nl80211_send_mgmt_tx_status(struct cfg80211_registered_device *rdev,\n\t\t\t\t struct wireless_dev *wdev, u64 cookie,\n\t\t\t\t const u8 *buf, size_t len, bool ack,\n\t\t\t\t gfp_t gfp)\n{\n\tstruct net_device *netdev = wdev->netdev;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_FRAME_TX_STATUS);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    (netdev && nla_put_u32(msg, NL80211_ATTR_IFINDEX,\n\t\t\t\t   netdev->ifindex)) ||\n\t    nla_put(msg, NL80211_ATTR_FRAME, len, buf) ||\n\t    nla_put_u64(msg, NL80211_ATTR_COOKIE, cookie) ||\n\t    (ack && nla_put_flag(msg, NL80211_ATTR_ACK)))\n\t\tgoto nla_put_failure;\n\tgenlmsg_end(msg, hdr);\n\tgenlmsg_multicast(msg, 0, nl80211_mlme_mcgrp.id, gfp);\n\treturn;\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tnlmsg_free(msg);\n}", "target": 0}
{"code": "static size_t ntlm_av_pair_get_next_offset(NTLM_AV_PAIR* pAvPair)\n{\n\treturn ntlm_av_pair_get_len(pAvPair) + sizeof(NTLM_AV_PAIR);\n}", "target": 1}
{"code": "PHPAPI int php_execute_simple_script(zend_file_handle *primary_file, zval *ret)\n{\n\tchar *old_cwd;\n\tALLOCA_FLAG(use_heap)\n\tEG(exit_status) = 0;\n#define OLD_CWD_SIZE 4096\n\told_cwd = do_alloca(OLD_CWD_SIZE, use_heap);\n\told_cwd[0] = '\\0';\n\tzend_try {\n#ifdef PHP_WIN32\n\t\tif(primary_file->filename) {\n\t\t\tUpdateIniFromRegistry((char*)primary_file->filename);\n\t\t}\n#endif\n\t\tPG(during_request_startup) = 0;\n\t\tif (primary_file->filename && !(SG(options) & SAPI_OPTION_NO_CHDIR)) {\n\t\t\tphp_ignore_value(VCWD_GETCWD(old_cwd, OLD_CWD_SIZE-1));\n\t\t\tVCWD_CHDIR_FILE(primary_file->filename);\n\t\t}\n\t\tzend_execute_scripts(ZEND_REQUIRE, ret, 1, primary_file);\n\t} zend_end_try();\n\tif (old_cwd[0] != '\\0') {\n\t\tphp_ignore_value(VCWD_CHDIR(old_cwd));\n\t}\n\tfree_alloca(old_cwd, use_heap);\n\treturn EG(exit_status);\n}", "target": 0}
{"code": "MONGO_EXPORT int bson_append_regex( bson *b, const char *name, const char *pattern, const char *opts ) {\n    const int plen = strlen( pattern )+1;\n    const int olen = strlen( opts )+1;\n    if ( bson_append_estart( b, BSON_REGEX, name, plen + olen ) == BSON_ERROR )\n        return BSON_ERROR;\n    if ( bson_check_string( b, pattern, plen - 1 ) == BSON_ERROR )\n        return BSON_ERROR;\n    bson_append( b , pattern , plen );\n    bson_append( b , opts , olen );\n    return BSON_OK;\n}", "target": 1}
{"code": "comics_document_render (EvDocument      *document,\n\t\t\tEvRenderContext *rc)\n{\n\tGdkPixbuf       *pixbuf;\n\tcairo_surface_t *surface;\n\tpixbuf = comics_document_render_pixbuf (document, rc);\n\tsurface = ev_document_misc_surface_from_pixbuf (pixbuf);\n\tg_object_unref (pixbuf);\n\treturn surface;\n}", "target": 1}
{"code": "key_ref_t keyring_search(key_ref_t keyring,\n\t\t\t struct key_type *type,\n\t\t\t const char *description)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= type,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= type->match,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tkey_ref_t key;\n\tint ret;\n\tif (!ctx.match_data.cmp)\n\t\treturn ERR_PTR(-ENOKEY);\n\tif (type->match_preparse) {\n\t\tret = type->match_preparse(&ctx.match_data);\n\t\tif (ret < 0)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\tkey = keyring_search_aux(keyring, &ctx);\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\n\treturn key;\n}", "target": 1}
{"code": "static int xar_hash_check(int hash, const void * result, const void * expected)\n{\n    int len;\n    if (!result || !expected)\n        return 1;\n    switch (hash) {\n    case XAR_CKSUM_SHA1:\n        len = SHA1_HASH_SIZE;\n        break;\n    case XAR_CKSUM_MD5:\n        len = CLI_HASH_MD5;\n        break;\n    case XAR_CKSUM_OTHER:\n    case XAR_CKSUM_NONE:\n    default:\n        return 1;\n    }\n    return memcmp(result, expected, len);\n}", "target": 1}
{"code": "static int mincore_unmapped_range(unsigned long addr, unsigned long end,\n\t\t\t\t   struct mm_walk *walk)\n{\n\twalk->private += __mincore_unmapped_range(addr, end,\n\t\t\t\t\t\t  walk->vma, walk->private);\n\treturn 0;\n}", "target": 1}
{"code": "onigenc_property_list_add_property(UChar* name, const OnigCodePoint* prop,\n     hash_table_type **table, const OnigCodePoint*** plist, int *pnum,\n     int *psize)\n{\n#define PROP_INIT_SIZE     16\n  int r;\n  if (*psize <= *pnum) {\n    int new_size = (*psize == 0 ? PROP_INIT_SIZE : *psize * 2);\n    r = resize_property_list(new_size, plist, psize);\n    if (r != 0) return r;\n  }\n  (*plist)[*pnum] = prop;\n  if (ONIG_IS_NULL(*table)) {\n    *table = onig_st_init_strend_table_with_size(PROP_INIT_SIZE);\n    if (ONIG_IS_NULL(*table)) return ONIGERR_MEMORY;\n  }\n  *pnum = *pnum + 1;\n  onig_st_insert_strend(*table, name, name + strlen((char* )name),\n\t\t\t(hash_data_type )(*pnum + ONIGENC_MAX_STD_CTYPE));\n  return 0;\n}", "target": 0}
{"code": "static ssize_t ifalias_show(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tconst struct net_device *netdev = to_net_dev(dev);\n\tchar tmp[IFALIASZ];\n\tssize_t ret = 0;\n\tret = dev_get_alias(netdev, tmp, sizeof(tmp));\n\tif (ret > 0)\n\t\tret = sprintf(buf, \"%s\\n\", tmp);\n\treturn ret;", "target": 0}
{"code": "static void drop_sysctl_table(struct ctl_table_header *header)\n{\n\tstruct ctl_dir *parent = header->parent;\n\tif (--header->nreg)\n\t\treturn;\n\tif (parent)\n\t\tput_links(header);\n\tstart_unregistering(header);\n\tif (!--header->count)\n\t\tkfree_rcu(header, rcu);\n\tif (parent)\n\t\tdrop_sysctl_table(&parent->header);\n}", "target": 1}
{"code": "static void nodeConstruct(struct SaveNode* node, tr_variant const* v, bool sort_dicts)\n{\n    node->isVisited = false;\n    node->childIndex = 0;\n    if (sort_dicts && tr_variantIsDict(v))\n    {\n        size_t const n = v->val.l.count;\n        struct KeyIndex* tmp = tr_new(struct KeyIndex, n);\n        for (size_t i = 0; i < n; i++)\n        {\n            tmp[i].val = v->val.l.vals + i;\n            tmp[i].keystr = tr_quark_get_string(tmp[i].val->key, NULL);\n        }\n        qsort(tmp, n, sizeof(struct KeyIndex), compareKeyIndex);\n        tr_variantInitDict(&node->sorted, n);\n        for (size_t i = 0; i < n; ++i)\n        {\n            node->sorted.val.l.vals[i] = *tmp[i].val;\n        }\n        node->sorted.val.l.count = n;\n        tr_free(tmp);\n        node->v = &node->sorted;\n    }\n    else\n    {\n        node->v = v;\n    }\n}", "target": 1}
{"code": "static int rfcomm_sock_setsockopt(struct socket *sock, int level, int optname, char __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct bt_security sec;\n\tint err = 0;\n\tsize_t len;\n\tu32 opt;\n\tBT_DBG(\"sk %p\", sk);\n\tif (level == SOL_RFCOMM)\n\t\treturn rfcomm_sock_setsockopt_old(sock, optname, optval, optlen);\n\tif (level != SOL_BLUETOOTH)\n\t\treturn -ENOPROTOOPT;\n\tlock_sock(sk);\n\tswitch (optname) {\n\tcase BT_SECURITY:\n\t\tif (sk->sk_type != SOCK_STREAM) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tsec.level = BT_SECURITY_LOW;\n\t\tlen = min_t(unsigned int, sizeof(sec), optlen);\n\t\tif (copy_from_user((char *) &sec, optval, len)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (sec.level > BT_SECURITY_HIGH) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\trfcomm_pi(sk)->sec_level = sec.level;\n\t\tbreak;\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (get_user(opt, (u32 __user *) optval)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (opt)\n\t\t\tset_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags);\n\t\telse\n\t\t\tclear_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags);\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "spnego_gss_complete_auth_token(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tgss_buffer_t input_message_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_complete_auth_token(minor_status,\n\t\t\t\t      context_handle,\n\t\t\t\t      input_message_buffer);\n\treturn (ret);\n}", "target": 0}
{"code": "void TabSpecificContentSettings::OnContentBlocked(\n    ContentSettingsType type,\n     const std::string& resource_identifier) {\n   DCHECK(type != CONTENT_SETTINGS_TYPE_GEOLOCATION)\n       << \"Geolocation settings handled by OnGeolocationPermissionSet\";\n   content_accessed_[type] = true;\n  std::string identifier;\n  if (CommandLine::ForCurrentProcess()->HasSwitch(\n      switches::kEnableResourceContentSettings)) {\n    identifier = resource_identifier;\n  }\n  if (!identifier.empty())\n    AddBlockedResource(type, identifier);\n#if defined (OS_ANDROID)\n  if (type == CONTENT_SETTINGS_TYPE_POPUPS) {\n    content_blocked_[type] = false;\n    content_blockage_indicated_to_user_[type] = false;\n  }\n#endif\n  if (!content_blocked_[type]) {\n    content_blocked_[type] = true;\n    content::NotificationService::current()->Notify(\n        chrome::NOTIFICATION_WEB_CONTENT_SETTINGS_CHANGED,\n        content::Source<WebContents>(web_contents()),\n        content::NotificationService::NoDetails());\n  }\n}", "target": 1}
{"code": "  Attribute_Selector_Obj Parser::parse_attribute_selector()\n  {\n    ParserState p = pstate;\n    if (!lex_css< attribute_name >()) error(\"invalid attribute name in attribute selector\");\n    std::string name(lexed);\n    if (lex_css< re_attr_sensitive_close >()) {\n      return SASS_MEMORY_NEW(Attribute_Selector, p, name, \"\", {}, {});\n    }\n    else if (lex_css< re_attr_insensitive_close >()) {\n      char modifier = lexed.begin[0];\n      return SASS_MEMORY_NEW(Attribute_Selector, p, name, \"\", {}, modifier);\n    }\n    if (!lex_css< alternatives< exact_match, class_match, dash_match,\n                                prefix_match, suffix_match, substring_match > >()) {\n      error(\"invalid operator in attribute selector for \" + name);\n    }\n    std::string matcher(lexed);\n    String_Obj value;\n    if (lex_css< identifier >()) {\n      value = SASS_MEMORY_NEW(String_Constant, p, lexed);\n    }\n    else if (lex_css< quoted_string >()) {\n      value = parse_interpolated_chunk(lexed, true); \n    }\n    else {\n      error(\"expected a string constant or identifier in attribute selector for \" + name);\n    }\n    if (lex_css< re_attr_sensitive_close >()) {\n      return SASS_MEMORY_NEW(Attribute_Selector, p, name, matcher, value, 0);\n    }\n    else if (lex_css< re_attr_insensitive_close >()) {\n      char modifier = lexed.begin[0];\n      return SASS_MEMORY_NEW(Attribute_Selector, p, name, matcher, value, modifier);\n    }\n    error(\"unterminated attribute selector for \" + name);\n    return {}; \n  }", "target": 0}
{"code": "FILE *mingw_fopen (const char *filename, const char *otype)\n{\n\tint hide = needs_hiding(filename);\n\tFILE *file;\n\twchar_t wfilename[MAX_PATH], wotype[4];\n\tif (filename && !strcmp(filename, \"/dev/null\"))\n\t\tfilename = \"nul\";\n\tif (xutftowcs_path(wfilename, filename) < 0 ||\n\t\txutftowcs(wotype, otype, ARRAY_SIZE(wotype)) < 0)\n\t\treturn NULL;\n\tif (hide && !access(filename, F_OK) && set_hidden_flag(wfilename, 0)) {\n\t\terror(\"could not unhide %s\", filename);\n\t\treturn NULL;\n\t}\n\tfile = _wfopen(wfilename, wotype);\n\tif (!file && GetLastError() == ERROR_INVALID_NAME)\n\t\terrno = ENOENT;\n\tif (file && hide && set_hidden_flag(wfilename, 1))\n\t\twarning(\"could not mark '%s' as hidden.\", filename);\n\treturn file;\n}", "target": 0}
{"code": "static inline void ok_inflater_write_byte(ok_inflater *inflater, const uint8_t b) {\n    inflater->buffer[inflater->buffer_end_pos & BUFFER_SIZE_MASK] = b;\n    inflater->buffer_end_pos++;\n}", "target": 0}
{"code": "static bool checkreturn decode_static_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter)\n{\n    pb_type_t type;\n    pb_decoder_t func;\n    type = iter->pos->type;\n    func = PB_DECODERS[PB_LTYPE(type)];\n    switch (PB_HTYPE(type))\n    {\n        case PB_HTYPE_REQUIRED:\n            return func(stream, iter->pos, iter->pData);\n        case PB_HTYPE_OPTIONAL:\n            if (iter->pSize != iter->pData)\n                *(bool*)iter->pSize = true;\n            return func(stream, iter->pos, iter->pData);\n        case PB_HTYPE_REPEATED:\n            if (wire_type == PB_WT_STRING\n                && PB_LTYPE(type) <= PB_LTYPE_LAST_PACKABLE)\n            {\n                bool status = true;\n                pb_size_t *size = (pb_size_t*)iter->pSize;\n                pb_istream_t substream;\n                if (!pb_make_string_substream(stream, &substream))\n                    return false;\n                while (substream.bytes_left > 0 && *size < iter->pos->array_size)\n                {\n                    void *pItem = (char*)iter->pData + iter->pos->data_size * (*size);\n                    if (!func(&substream, iter->pos, pItem))\n                    {\n                        status = false;\n                        break;\n                    }\n                    (*size)++;\n                }\n                if (substream.bytes_left != 0)\n                    PB_RETURN_ERROR(stream, \"array overflow\");\n                if (!pb_close_string_substream(stream, &substream))\n                    return false;\n                return status;\n            }\n            else\n            {\n                pb_size_t *size = (pb_size_t*)iter->pSize;\n                char *pItem = (char*)iter->pData + iter->pos->data_size * (*size);\n                if ((*size)++ >= iter->pos->array_size)\n                    PB_RETURN_ERROR(stream, \"array overflow\");\n                return func(stream, iter->pos, pItem);\n            }\n        case PB_HTYPE_ONEOF:\n            *(pb_size_t*)iter->pSize = iter->pos->tag;\n            if (PB_LTYPE(type) == PB_LTYPE_SUBMESSAGE)\n            {\n                memset(iter->pData, 0, iter->pos->data_size);\n                pb_message_set_to_defaults((const pb_field_t*)iter->pos->ptr, iter->pData);\n            }\n            return func(stream, iter->pos, iter->pData);\n        default:\n            PB_RETURN_ERROR(stream, \"invalid field type\");\n    }\n}", "target": 1}
{"code": "static int16_t findOffset(const char* const* list, const char* key)\n{\n\tconst char* const* anchor = list;\n\twhile (*list != NULL) {\n\t\tif (strcmp(key, *list) == 0) {\n\t\t\treturn (int16_t)(list - anchor);\n\t\t}\n\t\tlist++;\n\t}\n\treturn -1;\n}", "target": 0}
{"code": "static void nvme_dsm_cb(void *opaque, int ret)\n{\n    NvmeDSMAIOCB *iocb = opaque;\n    NvmeRequest *req = iocb->req;\n    NvmeCtrl *n = nvme_ctrl(req);\n    NvmeNamespace *ns = req->ns;\n    NvmeDsmRange *range;\n    uint64_t slba;\n    uint32_t nlb;\n    if (ret < 0) {\n        iocb->ret = ret;\n        goto done;\n    }\nnext:\n    if (iocb->idx == iocb->nr) {\n        goto done;\n    }\n    range = &iocb->range[iocb->idx++];\n    slba = le64_to_cpu(range->slba);\n    nlb = le32_to_cpu(range->nlb);\n    trace_pci_nvme_dsm_deallocate(slba, nlb);\n    if (nlb > n->dmrsl) {\n        trace_pci_nvme_dsm_single_range_limit_exceeded(nlb, n->dmrsl);\n        goto next;\n    }\n    if (nvme_check_bounds(ns, slba, nlb)) {\n        trace_pci_nvme_err_invalid_lba_range(slba, nlb,\n                                             ns->id_ns.nsze);\n        goto next;\n    }\n    iocb->aiocb = blk_aio_pdiscard(ns->blkconf.blk, nvme_l2b(ns, slba),\n                                   nvme_l2b(ns, nlb),\n                                   nvme_dsm_md_cb, iocb);\n    return;\ndone:\n    iocb->aiocb = NULL;\n    qemu_bh_schedule(iocb->bh);\n}", "target": 0}
{"code": "int gnutls_x509_aki_set_cert_issuer(gnutls_x509_aki_t aki,\n\t\t\t\t    unsigned int san_type,\n\t\t\t\t    const gnutls_datum_t * san,\n\t\t\t\t    const char *othername_oid,\n\t\t\t\t    const gnutls_datum_t * serial)\n{\n\tint ret;\n\tgnutls_datum_t t_san, t_othername_oid = { NULL, 0 };\n\tret = _gnutls_set_datum(&aki->serial, serial->data, serial->size);\n\tif (ret < 0)\n\t\treturn gnutls_assert_val(ret);\n\taki->cert_issuer.names[aki->cert_issuer.size].type = san_type;\n\tret = _gnutls_set_datum(&t_san, san->data, san->size);\n\tif (ret < 0)\n\t\treturn gnutls_assert_val(ret);\n\tif (othername_oid) {\n\t\tt_othername_oid.data = (uint8_t *) gnutls_strdup(othername_oid);\n\t\tif (t_othername_oid.data == NULL) {\n\t\t\tgnutls_free(t_san.data);\n\t\t\treturn gnutls_assert_val(GNUTLS_E_MEMORY_ERROR);\n\t\t}\n\t\tt_othername_oid.size = strlen(othername_oid);\n\t}\n\tret =\n\t    subject_alt_names_set(&aki->cert_issuer.names,\n\t\t\t\t  &aki->cert_issuer.size, san_type, &t_san,\n\t\t\t\t  (char *)t_othername_oid.data);\n\tif (ret < 0) {\n\t\tgnutls_assert();\n\t\treturn ret;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "dn2ancestor(\n    Slapi_Backend *be,\n    const Slapi_DN\t*sdn,\n\tSlapi_DN *ancestordn,\n    back_txn\t\t*txn,\n    int\t\t\t*err\n)\n{\n\tstruct backentry *e = NULL;\n\tLDAPDebug( LDAP_DEBUG_TRACE, \"=> dn2ancestor \\\"%s\\\"\\n\", slapi_sdn_get_dn(sdn), 0, 0 );\n    if (!slapi_sdn_isempty(sdn) && !slapi_be_issuffix( be, sdn )) {\n        Slapi_DN ancestorndn;\n        const char *ptr;\n        ptr = slapi_dn_find_parent(slapi_sdn_get_dn(sdn));\n        slapi_sdn_set_normdn_byref(ancestordn, ptr); \n        ptr = slapi_dn_find_parent(slapi_sdn_get_ndn(sdn));\n        slapi_sdn_init_ndn_byref(&ancestorndn, ptr);\n        while (!e && !slapi_sdn_isempty(&ancestorndn) && !slapi_be_issuffix( be, &ancestorndn )) {\n            e= dn2entry(be,&ancestorndn,txn,err);\n            if (!e) {\n                ptr = slapi_dn_find_parent(slapi_sdn_get_ndn(&ancestorndn));\n                slapi_sdn_set_ndn_byref(&ancestorndn, ptr); \n                ptr = slapi_dn_find_parent(slapi_sdn_get_dn(ancestordn));\n                slapi_sdn_set_normdn_byref(ancestordn, ptr); \n            }\n        }\n        slapi_sdn_done(&ancestorndn);\n    }\n    LDAPDebug( LDAP_DEBUG_TRACE, \"<= dn2ancestor %p\\n\", e, 0, 0 );\n    return( e );\n}", "target": 1}
{"code": "static int nfc_genl_deactivate_target(struct sk_buff *skb,\n\t\t\t\t      struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tu32 device_idx, target_idx;\n\tint rc;\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n\t\treturn -EINVAL;\n\tdevice_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tdev = nfc_get_device(device_idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\ttarget_idx = nla_get_u32(info->attrs[NFC_ATTR_TARGET_INDEX]);\n\trc = nfc_deactivate_target(dev, target_idx, NFC_TARGET_MODE_SLEEP);\n\tnfc_put_device(dev);\n\treturn rc;\n}", "target": 1}
{"code": "static int midi_setup_channel_pressure(struct _mdi *mdi, uint8_t channel,\n                                       uint8_t pressure) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,channel, pressure);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_channel_pressure;\n    mdi->events[mdi->event_count].event_data.channel = channel;\n    mdi->events[mdi->event_count].event_data.data.value = pressure;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}", "target": 0}
{"code": "static void FNAME(pte_prefetch)(struct kvm_vcpu *vcpu, struct guest_walker *gw,\n\t\t\t\tu64 *sptep)\n{\n\tstruct kvm_mmu_page *sp;\n\tpt_element_t *gptep = gw->prefetch_ptes;\n\tu64 *spte;\n\tint i;\n\tsp = page_header(__pa(sptep));\n\tif (sp->role.level > PT_PAGE_TABLE_LEVEL)\n\t\treturn;\n\tif (sp->role.direct)\n\t\treturn __direct_pte_prefetch(vcpu, sp, sptep);\n\ti = (sptep - sp->spt) & ~(PTE_PREFETCH_NUM - 1);\n\tspte = sp->spt + i;\n\tfor (i = 0; i < PTE_PREFETCH_NUM; i++, spte++) {\n\t\tif (spte == sptep)\n\t\t\tcontinue;\n\t\tif (is_shadow_present_pte(*spte))\n\t\t\tcontinue;\n\t\tif (!FNAME(prefetch_gpte)(vcpu, sp, spte, gptep[i], true))\n\t\t\tbreak;\n\t}\n}", "target": 0}
{"code": "static int faultin_page(struct task_struct *tsk, struct vm_area_struct *vma,\n\t\tunsigned long address, unsigned int *flags, int *nonblocking)\n{\n\tunsigned int fault_flags = 0;\n\tint ret;\n\tif ((*flags & (FOLL_POPULATE | FOLL_MLOCK)) == FOLL_MLOCK)\n\t\treturn -ENOENT;\n\tif ((*flags & FOLL_POPULATE) &&\n\t\t\t(stack_guard_page_start(vma, address) ||\n\t\t\t stack_guard_page_end(vma, address + PAGE_SIZE)))\n\t\treturn -ENOENT;\n\tif (*flags & FOLL_WRITE)\n\t\tfault_flags |= FAULT_FLAG_WRITE;\n\tif (*flags & FOLL_REMOTE)\n\t\tfault_flags |= FAULT_FLAG_REMOTE;\n\tif (nonblocking)\n\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY;\n\tif (*flags & FOLL_NOWAIT)\n\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_RETRY_NOWAIT;\n\tif (*flags & FOLL_TRIED) {\n\t\tVM_WARN_ON_ONCE(fault_flags & FAULT_FLAG_ALLOW_RETRY);\n\t\tfault_flags |= FAULT_FLAG_TRIED;\n\t}\n\tret = handle_mm_fault(vma, address, fault_flags);\n\tif (ret & VM_FAULT_ERROR) {\n\t\tif (ret & VM_FAULT_OOM)\n\t\t\treturn -ENOMEM;\n\t\tif (ret & (VM_FAULT_HWPOISON | VM_FAULT_HWPOISON_LARGE))\n\t\t\treturn *flags & FOLL_HWPOISON ? -EHWPOISON : -EFAULT;\n\t\tif (ret & (VM_FAULT_SIGBUS | VM_FAULT_SIGSEGV))\n\t\t\treturn -EFAULT;\n\t\tBUG();\n\t}\n\tif (tsk) {\n\t\tif (ret & VM_FAULT_MAJOR)\n\t\t\ttsk->maj_flt++;\n\t\telse\n\t\t\ttsk->min_flt++;\n\t}\n\tif (ret & VM_FAULT_RETRY) {\n\t\tif (nonblocking)\n\t\t\t*nonblocking = 0;\n\t\treturn -EBUSY;\n\t}\n\tif ((ret & VM_FAULT_WRITE) && !(vma->vm_flags & VM_WRITE))\n\t\t*flags &= ~FOLL_WRITE;\n\treturn 0;\n}", "target": 1}
{"code": "static GF_Err BM_ParseGlobalQuantizer(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tGF_Node *node;\n\tGF_Command *com;\n\tGF_CommandField *inf;\n\tnode = gf_bifs_dec_node(codec, bs, NDT_SFWorldNode);\n\tif (!node) return GF_NON_COMPLIANT_BITSTREAM;\n\tif (codec->scenegraph->global_qp) {\n\t\tgf_node_unregister(codec->scenegraph->global_qp, NULL);\n\t}\n\tcodec->ActiveQP = NULL;\n\tcodec->scenegraph->global_qp = NULL;\n\tif (gf_node_get_tag(node) != TAG_MPEG4_QuantizationParameter) {\n\t\tgf_node_unregister(node, NULL);\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tcodec->ActiveQP = (M_QuantizationParameter *) node;\n\tcodec->ActiveQP->isLocal = 0;\n\tcodec->scenegraph->global_qp = node;\n\tnode->sgprivate->num_instances = 2;\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_GLOBAL_QUANTIZER);\n\tinf = gf_sg_command_field_new(com);\n\tinf->new_node = node;\n\tinf->field_ptr = &inf->new_node;\n\tinf->fieldType = GF_SG_VRML_SFNODE;\n\tgf_list_add(com_list, com);\n\treturn GF_OK;\n}", "target": 1}
{"code": "pci_lintr_route(struct pci_vdev *dev)\n{\n\tstruct businfo *bi;\n\tstruct intxinfo *ii;\n\tif (dev->lintr.pin == 0)\n\t\treturn;\n\tbi = pci_businfo[dev->bus];\n\tassert(bi != NULL);\n\tii = &bi->slotinfo[dev->slot].si_intpins[dev->lintr.pin - 1];\n\tif (ii->ii_ioapic_irq == 0)\n\t\tii->ii_ioapic_irq = ioapic_pci_alloc_irq(dev);\n\tassert(ii->ii_ioapic_irq > 0);\n\tif (ii->ii_pirq_pin == 0)\n\t\tii->ii_pirq_pin = pirq_alloc_pin(dev);\n\tassert(ii->ii_pirq_pin > 0);\n\tdev->lintr.ioapic_irq = ii->ii_ioapic_irq;\n\tdev->lintr.pirq_pin = ii->ii_pirq_pin;\n\tpci_set_cfgdata8(dev, PCIR_INTLINE, pirq_irq(ii->ii_pirq_pin));\n}", "target": 1}
{"code": "static CURLcode error_init_writer(struct Curl_easy *data,\n                                  struct contenc_writer *writer)\n{\n  (void) data;\n  return writer->downstream? CURLE_OK: CURLE_WRITE_ERROR;\n}", "target": 0}
{"code": "static MagickBooleanType ReadPSDChannelPixels(Image *image,\n  const size_t channels,const ssize_t row,const ssize_t type,\n  const unsigned char *pixels,ExceptionInfo *exception)\n{\n  Quantum\n    pixel;\n  const unsigned char\n    *p;\n  IndexPacket\n    *indexes;\n  PixelPacket\n    *q;\n  ssize_t\n    x;\n  size_t\n    packet_size;\n  unsigned short\n    nibble;\n  p=pixels;\n  q=GetAuthenticPixels(image,0,row,image->columns,1,exception);\n  if (q == (PixelPacket *) NULL)\n    return MagickFalse;\n  indexes=GetAuthenticIndexQueue(image);\n  packet_size=GetPSDPacketSize(image);\n  for (x=0; x < (ssize_t) image->columns; x++)\n  {\n    if (packet_size == 1)\n      pixel=ScaleCharToQuantum(*p++);\n    else\n      if (packet_size == 2)\n        {\n          p=PushShortPixel(MSBEndian,p,&nibble);\n          pixel=ScaleShortToQuantum(nibble);\n        }\n      else\n        {\n          MagickFloatType\n            nibble;\n          p=PushFloatPixel(MSBEndian,p,&nibble);\n          pixel=ClampToQuantum((MagickRealType)QuantumRange*nibble);\n        }\n    if (image->depth > 1)\n      {\n        SetPSDPixel(image,channels,type,packet_size,pixel,q,indexes,x);\n        q++;\n      }\n    else\n      {\n        ssize_t\n          bit,\n          number_bits;\n        number_bits=(ssize_t) image->columns-x;\n        if (number_bits > 8)\n          number_bits=8;\n        for (bit=0; bit < number_bits; bit++)\n        {\n          SetPSDPixel(image,channels,type,packet_size,(((unsigned char) pixel)\n            & (0x01 << (7-bit))) != 0 ? 0 : QuantumRange,q++,indexes,x++);\n        }\n        if (x != (ssize_t) image->columns)\n          x--;\n        continue;\n      }\n  }\n  return(SyncAuthenticPixels(image,exception));\n}", "target": 1}
{"code": "mm_answer_sessid(int socket, Buffer *m)\n{\n\tint i;\n\tdebug3(\"%s entering\", __func__);\n\tif (buffer_len(m) != 16)\n\t\tfatal(\"%s: bad ssh1 session id\", __func__);\n\tfor (i = 0; i < 16; i++)\n\t\tsession_id[i] = buffer_get_char(m);\n\tmonitor_permit(mon_dispatch, MONITOR_REQ_PWNAM, 1);\n\treturn (0);\n}", "target": 0}
{"code": "CURLcode Curl_urldecode(struct SessionHandle *data,\n                        const char *string, size_t length,\n                        char **ostring, size_t *olen,\n                        bool reject_ctrl)\n{\n  size_t alloc = (length?length:strlen(string))+1;\n  char *ns = malloc(alloc);\n  unsigned char in;\n  size_t strindex=0;\n  unsigned long hex;\n  CURLcode res;\n  if(!ns)\n    return CURLE_OUT_OF_MEMORY;\n  while(--alloc > 0) {\n    in = *string;\n    if(('%' == in) && (alloc > 2) &&\n       ISXDIGIT(string[1]) && ISXDIGIT(string[2])) {\n      char hexstr[3];\n      char *ptr;\n      hexstr[0] = string[1];\n      hexstr[1] = string[2];\n      hexstr[2] = 0;\n      hex = strtoul(hexstr, &ptr, 16);\n      in = curlx_ultouc(hex); \n      res = Curl_convert_from_network(data, &in, 1);\n      if(res) {\n        free(ns);\n        return res;\n      }\n      string+=2;\n      alloc-=2;\n    }\n    if(reject_ctrl && (in < 0x20)) {\n      free(ns);\n      return CURLE_URL_MALFORMAT;\n    }\n    ns[strindex++] = in;\n    string++;\n  }\n  ns[strindex]=0; \n  if(olen)\n    *olen = strindex;\n  if(ostring)\n    *ostring = ns;\n  return CURLE_OK;\n}", "target": 0}
{"code": "    bool Nikon3MnHeader::read(const byte* pData,\n                              uint32_t    size,\n                              ByteOrder   )\n    {\n        if (!pData || size < sizeOfSignature()) return false;\n        if (0 != memcmp(pData, signature_, 6)) return false;\n        buf_.alloc(sizeOfSignature());\n        std::memcpy(buf_.pData_, pData, buf_.size_);\n        TiffHeader th;\n        if (!th.read(buf_.pData_ + 10, 8)) return false;\n        byteOrder_ = th.byteOrder();\n        start_ = 10 + th.offset();\n        return true;\n    } ", "target": 0}
{"code": "Item_func_null_predicate::add_key_fields(JOIN *join, KEY_FIELD **key_fields,\n                                         uint *and_level,\n                                         table_map usable_tables,\n                                         SARGABLE_PARAM **sargables)\n{\n  if (is_local_field(args[0]) && !(used_tables() & OUTER_REF_TABLE_BIT))\n  {\n    Item *tmp= new (join->thd->mem_root) Item_null(join->thd);\n    if (unlikely(!tmp))                       \n      return;\n    add_key_equal_fields(join, key_fields, *and_level, this,\n                         (Item_field*) args[0]->real_item(),\n                         functype() == Item_func::ISNULL_FUNC,\n                         &tmp, 1, usable_tables, sargables);\n  }\n}", "target": 0}
{"code": "static int snd_timer_stop1(struct snd_timer_instance *timeri, bool stop)\n{\n\tstruct snd_timer *timer;\n\tint result = 0;\n\tunsigned long flags;\n\ttimer = timeri->timer;\n\tif (!timer)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&timer->lock, flags);\n\tif (!(timeri->flags & (SNDRV_TIMER_IFLG_RUNNING |\n\t\t\t       SNDRV_TIMER_IFLG_START))) {\n\t\tresult = -EBUSY;\n\t\tgoto unlock;\n\t}\n\tlist_del_init(&timeri->ack_list);\n\tlist_del_init(&timeri->active_list);\n\tif (timer->card && timer->card->shutdown)\n\t\tgoto unlock;\n\tif (stop) {\n\t\ttimeri->cticks = timeri->ticks;\n\t\ttimeri->pticks = 0;\n\t}\n\tif ((timeri->flags & SNDRV_TIMER_IFLG_RUNNING) &&\n\t    !(--timer->running)) {\n\t\ttimer->hw.stop(timer);\n\t\tif (timer->flags & SNDRV_TIMER_FLG_RESCHED) {\n\t\t\ttimer->flags &= ~SNDRV_TIMER_FLG_RESCHED;\n\t\t\tsnd_timer_reschedule(timer, 0);\n\t\t\tif (timer->flags & SNDRV_TIMER_FLG_CHANGE) {\n\t\t\t\ttimer->flags &= ~SNDRV_TIMER_FLG_CHANGE;\n\t\t\t\ttimer->hw.start(timer);\n\t\t\t}\n\t\t}\n\t}\n\ttimeri->flags &= ~(SNDRV_TIMER_IFLG_RUNNING | SNDRV_TIMER_IFLG_START);\n\tsnd_timer_notify1(timeri, stop ? SNDRV_TIMER_EVENT_STOP :\n\t\t\t  SNDRV_TIMER_EVENT_CONTINUE);\n unlock:\n\tspin_unlock_irqrestore(&timer->lock, flags);\n\treturn result;\n}", "target": 0}
{"code": "  UpstreamWrapper(const StreamInfo::StreamInfo& info) : info_(info) {}", "target": 0}
{"code": "static struct dentry *proc_pident_lookup(struct inode *dir, \n\t\t\t\t\t struct dentry *dentry,\n\t\t\t\t\t const struct pid_entry *ents,\n\t\t\t\t\t unsigned int nents)\n{\n\tstruct inode *inode;\n\tstruct dentry *error;\n\tstruct task_struct *task = get_proc_task(dir);\n\tconst struct pid_entry *p, *last;\n\terror = ERR_PTR(-ENOENT);\n\tinode = NULL;\n\tif (!task)\n\t\tgoto out_no_task;\n\tlast = &ents[nents - 1];\n\tfor (p = ents; p <= last; p++) {\n\t\tif (p->len != dentry->d_name.len)\n\t\t\tcontinue;\n\t\tif (!memcmp(dentry->d_name.name, p->name, p->len))\n\t\t\tbreak;\n\t}\n\tif (p > last)\n\t\tgoto out;\n\terror = proc_pident_instantiate(dir, dentry, task, p);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn error;\n}", "target": 0}
{"code": "  void SetInput(std::initializer_list<float> data) {\n    QuantizeAndPopulate<uint8_t>(input_, data);\n  }", "target": 0}
{"code": "static int mmap_kmem(struct file *file, struct vm_area_struct *vma)\n{\n\tunsigned long pfn;\n\tpfn = __pa((u64)vma->vm_pgoff << PAGE_SHIFT) >> PAGE_SHIFT;\n\tif (!pfn_valid(pfn))\n\t\treturn -EIO;\n\tvma->vm_pgoff = pfn;\n\treturn mmap_mem(file, vma);\n}", "target": 0}
{"code": "void scheduler_tick(void)\n{\n\tint cpu = smp_processor_id();\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct task_struct *curr = rq->curr;\n\tsched_clock_tick();\n\traw_spin_lock(&rq->lock);\n\tupdate_rq_clock(rq);\n\tcurr->sched_class->task_tick(rq, curr, 0);\n\tupdate_cpu_load_active(rq);\n\tcalc_global_load_tick(rq);\n\traw_spin_unlock(&rq->lock);\n\tperf_event_task_tick();\n#ifdef CONFIG_SMP\n\trq->idle_balance = idle_cpu(cpu);\n\ttrigger_load_balance(rq);\n#endif\n\trq_last_tick_reset(rq);\n}", "target": 0}
{"code": "snmp_ber_encode_string_len(unsigned char *out, uint32_t *out_len, const char *str, uint32_t length)\n{\n  uint32_t i;\n  str += length - 1;\n  for(i = 0; i < length; ++i) {\n    (*out_len)++;\n    *out-- = (uint8_t)*str--;\n  }\n  out = snmp_ber_encode_length(out, out_len, length);\n  out = snmp_ber_encode_type(out, out_len, BER_DATA_TYPE_OCTET_STRING);\n  return out;\n}", "target": 1}
{"code": "xfs_iunlink_insert_backref(\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_iunlink\t*iu)\n{\n\tint\t\t\terror;\n\terror = rhashtable_insert_fast(&pag->pagi_unlinked_hash,\n\t\t\t&iu->iu_rhash_head, xfs_iunlink_hash_params);\n\tif (error) {\n\t\tWARN(error != -ENOMEM, \"iunlink cache insert error %d\", error);\n\t\tkmem_free(iu);\n\t}\n\tif (error != 0 && error != -EEXIST)\n\t\terror = 0;\n\treturn error;\n}", "target": 0}
{"code": "static struct list_head *rb_list_head(struct list_head *list)\n{\n\tunsigned long val = (unsigned long)list;\n\treturn (struct list_head *)(val & ~RB_FLAG_MASK);\n}", "target": 0}
{"code": "ieee80211_tx_h_dynamic_ps(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_local *local = tx->local;\n\tstruct ieee80211_if_managed *ifmgd;\n\tif (!(local->hw.flags & IEEE80211_HW_SUPPORTS_PS))\n\t\treturn TX_CONTINUE;\n\tif (local->hw.flags & IEEE80211_HW_SUPPORTS_DYNAMIC_PS)\n\t\treturn TX_CONTINUE;\n\tif (local->hw.conf.dynamic_ps_timeout <= 0)\n\t\treturn TX_CONTINUE;\n\tif (local->scanning)\n\t\treturn TX_CONTINUE;\n\tif (!local->ps_sdata)\n\t\treturn TX_CONTINUE;\n\tif (local->quiescing)\n\t\treturn TX_CONTINUE;\n\tif (tx->sdata->vif.type != NL80211_IFTYPE_STATION)\n\t\treturn TX_CONTINUE;\n\tifmgd = &tx->sdata->u.mgd;\n\tif ((ifmgd->flags & IEEE80211_STA_UAPSD_ENABLED) &&\n\t    (ifmgd->uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_VO) &&\n\t    skb_get_queue_mapping(tx->skb) == IEEE80211_AC_VO)\n\t\treturn TX_CONTINUE;\n\tif (local->hw.conf.flags & IEEE80211_CONF_PS) {\n\t\tieee80211_stop_queues_by_reason(&local->hw,\n\t\t\t\t\t\tIEEE80211_MAX_QUEUE_MAP,\n\t\t\t\t\t\tIEEE80211_QUEUE_STOP_REASON_PS);\n\t\tifmgd->flags &= ~IEEE80211_STA_NULLFUNC_ACKED;\n\t\tieee80211_queue_work(&local->hw,\n\t\t\t\t     &local->dynamic_ps_disable_work);\n\t}\n\tif (!ifmgd->associated)\n\t\treturn TX_CONTINUE;\n\tmod_timer(&local->dynamic_ps_timer, jiffies +\n\t\t  msecs_to_jiffies(local->hw.conf.dynamic_ps_timeout));\n\treturn TX_CONTINUE;\n}", "target": 0}
{"code": "coolkey_get_public_key(sc_pkcs15_card_t *p15card, sc_cardctl_coolkey_object_t *obj, CK_KEY_TYPE key_type)\n{\n\tsc_pkcs15_pubkey_t *key;\n\tkey = coolkey_make_public_key(p15card->card, obj, key_type);\n\tif (key) {\n\t\treturn key;\n\t}\n\treturn coolkey_get_public_key_from_certificate(p15card, obj);\n}", "target": 0}
{"code": "static inline int http_parse_chunk_size(struct http_msg *msg)\n{\n\tconst struct buffer *buf = msg->chn->buf;\n\tconst char *ptr = b_ptr(buf, msg->next);\n\tconst char *ptr_old = ptr;\n\tconst char *end = buf->data + buf->size;\n\tconst char *stop = bi_end(buf);\n\tunsigned int chunk = 0;\n\twhile (1) {\n\t\tint c;\n\t\tif (ptr == stop)\n\t\t\treturn 0;\n\t\tc = hex2i(*ptr);\n\t\tif (c < 0) \n\t\t\tbreak;\n\t\tif (unlikely(++ptr >= end))\n\t\t\tptr = buf->data;\n\t\tif (chunk & 0xF8000000) \n\t\t\tgoto error;\n\t\tchunk = (chunk << 4) + c;\n\t}\n\tif (unlikely(ptr == ptr_old))\n\t\tgoto error;\n\twhile (http_is_spht[(unsigned char)*ptr]) {\n\t\tif (++ptr >= end)\n\t\t\tptr = buf->data;\n\t\tif (unlikely(ptr == stop))\n\t\t\treturn 0;\n\t}\n\twhile (1) {\n\t\tif (likely(HTTP_IS_CRLF(*ptr))) {\n\t\t\tif (likely(*ptr == '\\r')) {\n\t\t\t\tif (++ptr >= end)\n\t\t\t\t\tptr = buf->data;\n\t\t\t\tif (ptr == stop)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (*ptr != '\\n')\n\t\t\t\tgoto error;\n\t\t\tif (++ptr >= end)\n\t\t\t\tptr = buf->data;\n\t\t\tbreak;\n\t\t}\n\t\telse if (*ptr == ';') {\n\t\t\tif (++ptr >= end)\n\t\t\t\tptr = buf->data;\n\t\t\tif (ptr == stop)\n\t\t\t\treturn 0;\n\t\t\twhile (!HTTP_IS_CRLF(*ptr)) {\n\t\t\t\tif (++ptr >= end)\n\t\t\t\t\tptr = buf->data;\n\t\t\t\tif (ptr == stop)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\telse\n\t\t\tgoto error;\n\t}\n\tif (unlikely(ptr < ptr_old))\n\t\tmsg->sov += buf->size;\n\tmsg->sov += ptr - ptr_old;\n\tmsg->next = buffer_count(buf, buf->p, ptr);\n\tmsg->chunk_len = chunk;\n\tmsg->body_len += chunk;\n\tmsg->msg_state = chunk ? HTTP_MSG_DATA : HTTP_MSG_TRAILERS;\n\treturn 1;\n error:\n\tmsg->err_pos = buffer_count(buf, buf->p, ptr);\n\treturn -1;\n}", "target": 0}
{"code": "static ssize_t ext4_direct_IO(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tsize_t count = iov_iter_count(iter);\n\tloff_t offset = iocb->ki_pos;\n\tssize_t ret;\n#ifdef CONFIG_EXT4_FS_ENCRYPTION\n\tif (ext4_encrypted_inode(inode) && S_ISREG(inode->i_mode))\n\t\treturn 0;\n#endif\n\tif (ext4_should_journal_data(inode))\n\t\treturn 0;\n\tif (ext4_has_inline_data(inode))\n\t\treturn 0;\n\tif (WARN_ON_ONCE(IS_DAX(inode)))\n\t\treturn 0;\n\ttrace_ext4_direct_IO_enter(inode, offset, count, iov_iter_rw(iter));\n\tif (iov_iter_rw(iter) == READ)\n\t\tret = ext4_direct_IO_read(iocb, iter);\n\telse\n\t\tret = ext4_direct_IO_write(iocb, iter);\n\ttrace_ext4_direct_IO_exit(inode, offset, count, iov_iter_rw(iter), ret);\n\treturn ret;\n}", "target": 0}
{"code": "_SSL_match_hostname (const char *cert_hostname, const char *hostname)\n{\n\tconst char *cert_domain, *domain, *next_dot;\n\tif (g_ascii_strcasecmp (cert_hostname, hostname) == 0)\n\t\treturn 0;\n\tif (cert_hostname[0] == '*')\n\t{\n\t\tcert_domain = &cert_hostname[1];\n\t\tif (cert_domain[0] == '\\0')\n\t\t\treturn -1;\n\t\tif (cert_domain[0] != '.')\n\t\t\treturn -1;\n\t\tif (cert_domain[1] == '.')\n\t\t\treturn -1;\n\t\tnext_dot = strchr (&cert_domain[1], '.');\n\t\tif (next_dot == NULL)\n\t\t\treturn -1;\n\t\tif (next_dot[1] == '.')\n\t\t\treturn -1;\n\t\tdomain = strchr (hostname, '.');\n\t\tif (domain == NULL || strlen(domain) == 1)\n\t\t\treturn -1;\n\t\tif (g_ascii_strcasecmp (cert_domain, domain) == 0)\n\t\t\treturn 0;\n\t}\n\treturn -1;\n}", "target": 0}
{"code": "Http::Response AbstractWebApplication::processRequest(const Http::Request &request, const Http::Environment &env)\n{\n    session_ = 0;\n    request_ = request;\n    env_ = env;\n    clear(); \n    sessionInitialize();\n    if (!sessionActive() && !isAuthNeeded())\n        sessionStart();\n    if (isBanned()) {\n        status(403, \"Forbidden\");\n        print(QObject::tr(\"Your IP address has been banned after too many failed authentication attempts.\"), Http::CONTENT_TYPE_TXT);\n    }\n    else {\n        processRequest();\n    }\n    return response();\n}", "target": 1}
{"code": "static void power_pmu_disable(struct pmu *pmu)\n{\n\tstruct cpu_hw_events *cpuhw;\n\tunsigned long flags;\n\tif (!ppmu)\n\t\treturn;\n\tlocal_irq_save(flags);\n\tcpuhw = &__get_cpu_var(cpu_hw_events);\n\tif (!cpuhw->disabled) {\n\t\tcpuhw->disabled = 1;\n\t\tcpuhw->n_added = 0;\n\t\tif (!cpuhw->pmcs_enabled) {\n\t\t\tppc_enable_pmcs();\n\t\t\tcpuhw->pmcs_enabled = 1;\n\t\t}\n\t\tif (cpuhw->mmcr[2] & MMCRA_SAMPLE_ENABLE) {\n\t\t\tmtspr(SPRN_MMCRA,\n\t\t\t      cpuhw->mmcr[2] & ~MMCRA_SAMPLE_ENABLE);\n\t\t\tmb();\n\t\t}\n\t\twrite_mmcr0(cpuhw, mfspr(SPRN_MMCR0) | MMCR0_FC);\n\t\tmb();\n\t}\n\tlocal_irq_restore(flags);\n}", "target": 0}
{"code": "static int db_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_run *kvm_run = svm->vcpu.run;\n\tif (!(svm->vcpu.guest_debug &\n\t      (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) &&\n\t\t!svm->nmi_singlestep) {\n\t\tkvm_queue_exception(&svm->vcpu, DB_VECTOR);\n\t\treturn 1;\n\t}\n\tif (svm->nmi_singlestep) {\n\t\tsvm->nmi_singlestep = false;\n\t\tif (!(svm->vcpu.guest_debug & KVM_GUESTDBG_SINGLESTEP))\n\t\t\tsvm->vmcb->save.rflags &=\n\t\t\t\t~(X86_EFLAGS_TF | X86_EFLAGS_RF);\n\t\tupdate_db_bp_intercept(&svm->vcpu);\n\t}\n\tif (svm->vcpu.guest_debug &\n\t    (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) {\n\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\tkvm_run->debug.arch.pc =\n\t\t\tsvm->vmcb->save.cs.base + svm->vmcb->save.rip;\n\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "GF_Err hdlr_dump(GF_Box *a, FILE * trace)\n{\n\tGF_HandlerBox *p = (GF_HandlerBox *)a;\n\tgf_isom_box_dump_start(a, \"HandlerBox\", trace);\n\tif (p->nameUTF8 && (u32) p->nameUTF8[0] == strlen(p->nameUTF8+1)) {\n\t\tfprintf(trace, \"hdlrType=\\\"%s\\\" Name=\\\"%s\\\" \", gf_4cc_to_str(p->handlerType), p->nameUTF8+1);\n\t} else {\n\t\tfprintf(trace, \"hdlrType=\\\"%s\\\" Name=\\\"%s\\\" \", gf_4cc_to_str(p->handlerType), p->nameUTF8);\n\t}\n\tfprintf(trace, \"reserved1=\\\"%d\\\" reserved2=\\\"\", p->reserved1);\n\tdump_data(trace, (char *) p->reserved2, 12);\n\tfprintf(trace, \"\\\"\");\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"HandlerBox\", a, trace);\n\treturn GF_OK;\n}", "target": 1}
{"code": "juniper_mfr_print(netdissect_options *ndo,\n                  const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n        memset(&l2info, 0, sizeof(l2info));\n        l2info.pictype = DLT_JUNIPER_MFR;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n        p+=l2info.header_len;\n        if (l2info.cookie_len == 0) {\n            mfr_print(ndo, p, l2info.length);\n            return l2info.header_len;\n        }\n        if (l2info.cookie_len == AS_PIC_COOKIE_LEN) {\n            switch(l2info.proto) {\n            case JUNIPER_LSQ_L3_PROTO_IPV4:\n                ip_print(ndo, p, l2info.length);\n                return l2info.header_len;\n            case JUNIPER_LSQ_L3_PROTO_IPV6:\n                ip6_print(ndo, p,l2info.length);\n                return l2info.header_len;\n            case JUNIPER_LSQ_L3_PROTO_MPLS:\n                mpls_print(ndo, p, l2info.length);\n                return l2info.header_len;\n            case JUNIPER_LSQ_L3_PROTO_ISO:\n                isoclns_print(ndo, p, l2info.length, l2info.caplen);\n                return l2info.header_len;\n            default:\n                break;\n            }\n            return l2info.header_len;\n        }\n        if (ndo->ndo_eflag && EXTRACT_32BITS(l2info.cookie) != 1)\n            ND_PRINT((ndo, \"Bundle-ID %u, \", l2info.bundle));\n        switch (l2info.proto) {\n        case (LLCSAP_ISONS<<8 | LLCSAP_ISONS):\n            isoclns_print(ndo, p + 1, l2info.length - 1, l2info.caplen - 1);\n            break;\n        case (LLC_UI<<8 | NLPID_Q933):\n        case (LLC_UI<<8 | NLPID_IP):\n        case (LLC_UI<<8 | NLPID_IP6):\n            isoclns_print(ndo, p - 1, l2info.length + 1, l2info.caplen + 1);\n            break;\n        default:\n            ND_PRINT((ndo, \"unknown protocol 0x%04x, length %u\", l2info.proto, l2info.length));\n        }\n        return l2info.header_len;\n}", "target": 1}
{"code": "static void OneLineTransp(struct ico_progressive_state *context)\n{\n\tgint X;\n\tguchar *Pixels;\n\tif (context->Header.depth == 32)\n\t\treturn;\n\tX = 0;\n\tif (context->Header.Negative == 0)\n\t\tPixels = (context->pixbuf->pixels +\n\t\t\t  (gsize) context->pixbuf->rowstride *\n\t\t\t  (2*context->Header.height - context->Lines - 1));\n\telse\n\t\tPixels = (context->pixbuf->pixels +\n\t\t\t  (gsize) context->pixbuf->rowstride *\n\t\t\t  (context->Lines-context->Header.height));\n\twhile (X < context->Header.width) {\n\t\tint Bit;\n\t\tBit = (context->LineBuf[X / 8]) >> (7 - (X & 7));\n\t\tBit = Bit & 1;\n\t\tPixels[X * 4 + 3] = 255-Bit*255;\n#if 0\n\t\tif (Bit){\n\t\t  Pixels[X*4+0] = 255;\n\t\t  Pixels[X*4+1] = 255;\n\t\t} else {\n\t\t  Pixels[X*4+0] = 0;\n\t\t  Pixels[X*4+1] = 0;\n\t\t}\n#endif\t\t\n\t\tX++;\n\t}\n}", "target": 0}
{"code": "static Jsi_RC NumberToStringCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[500];\n    int radix = 10, skip = 0, argc = Jsi_ValueGetLength(interp, args);\n    Jsi_Number num;\n    Jsi_Value *v;\n    ChkStringN(_this, funcPtr, v);\n    Jsi_GetDoubleFromValue(interp, v, &num);\n    if (argc>skip && (Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, skip), &radix) != JSI_OK\n        || radix<2))\n        return JSI_ERROR;\n    if (argc==skip)\n        return jsi_ObjectToStringCmd(interp, args, _this, ret, funcPtr);\n    switch (radix) {\n        case 16: snprintf(buf, sizeof(buf), \"%\" PRIx64, (Jsi_Wide)num); break;\n        case 8: snprintf(buf, sizeof(buf), \"%\" PRIo64, (Jsi_Wide)num); break;\n        case 10: snprintf(buf, sizeof(buf), \"%\" PRId64, (Jsi_Wide)num); break;\n        default: return jsi_ObjectToStringCmd(interp, args, _this, ret, funcPtr);\n    }\n    Jsi_ValueMakeStringDup(interp, ret, buf);\n    return JSI_OK;\n}", "target": 1}
{"code": "spnego_gss_inquire_names_for_mech(\n\t\t\t\tOM_uint32\t*minor_status,\n\t\t\t\tgss_OID\t\tmechanism,\n\t\t\t\tgss_OID_set\t*name_types)\n{\n\tOM_uint32   major, minor;\n\tdsyslog(\"Entering inquire_names_for_mech\\n\");\n\tif ((mechanism != GSS_C_NULL_OID) &&\n\t    !g_OID_equal(gss_mech_spnego, mechanism)) {\n\t\t*minor_status = 0;\n\t\treturn (GSS_S_FAILURE);\n\t}\n\tmajor = gss_create_empty_oid_set(minor_status, name_types);\n\tif (major == GSS_S_COMPLETE) {\n\t\tif (((major = gss_add_oid_set_member(minor_status,\n\t\t\t\t(gss_OID) GSS_C_NT_USER_NAME,\n\t\t\t\tname_types)) == GSS_S_COMPLETE) &&\n\t\t    ((major = gss_add_oid_set_member(minor_status,\n\t\t\t\t(gss_OID) GSS_C_NT_MACHINE_UID_NAME,\n\t\t\t\tname_types)) == GSS_S_COMPLETE) &&\n\t\t    ((major = gss_add_oid_set_member(minor_status,\n\t\t\t\t(gss_OID) GSS_C_NT_STRING_UID_NAME,\n\t\t\t\tname_types)) == GSS_S_COMPLETE)) {\n\t\t\tmajor = gss_add_oid_set_member(minor_status,\n\t\t\t\t(gss_OID) GSS_C_NT_HOSTBASED_SERVICE,\n\t\t\t\tname_types);\n\t\t}\n\t\tif (major != GSS_S_COMPLETE)\n\t\t\t(void) gss_release_oid_set(&minor, name_types);\n\t}\n\tdsyslog(\"Leaving inquire_names_for_mech\\n\");\n\treturn (major);\n}", "target": 0}
{"code": "static inline int init_new_context(struct task_struct *tsk,\n\t\t\t\t   struct mm_struct *mm)\n{\n\t#ifdef CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS\n\tif (cpu_feature_enabled(X86_FEATURE_OSPKE)) {\n\t\tmm->context.pkey_allocation_map = 0x1;\n\t\tmm->context.execute_only_pkey = -1;\n\t}\n\t#endif\n\tinit_new_context_ldt(tsk, mm);\n\treturn 0;\n}", "target": 1}
{"code": "int rad_packet_add_ipv6prefix(struct rad_packet_t *pack, const char *vendor_name, const char *name, struct in6_addr *prefix, int len)\n{\n\tstruct rad_attr_t *ra;\n\tstruct rad_dict_attr_t *attr;\n\tstruct rad_dict_vendor_t *vendor;\n\tif (pack->len + (vendor_name ? 8 : 2) + 18 >= REQ_LENGTH_MAX)\n\t\treturn -1;\n\tif (vendor_name) {\n\t\tvendor = rad_dict_find_vendor_name(vendor_name);\n\t\tif (!vendor)\n\t\t\treturn -1;\n\t\tattr = rad_dict_find_vendor_attr(vendor, name);\n\t} else {\n\t\tvendor = NULL;\n\t\tattr = rad_dict_find_attr(name);\n\t}\n\tif (!attr)\n\t\treturn -1;\n\tra = mempool_alloc(attr_pool);\n\tif (!ra)\n\t\treturn -1;\n\tmemset(ra, 0, sizeof(*ra));\n\tra->vendor = vendor;\n\tra->attr = attr;\n\tra->len = 18;\n\tra->val.ipv6prefix.len = len;\n\tra->val.ipv6prefix.prefix = *prefix;\n\tra->raw = &ra->val;\n\tlist_add_tail(&ra->entry, &pack->attrs);\n\tpack->len += (vendor_name ? 8 : 2) + 18;\n\treturn 0;\n}", "target": 0}
{"code": "    void Modify::delMetadatum(Exiv2::Image* pImage, const ModifyCmd& modifyCmd)\n    {\n        if (Params::instance().verbose_) {\n            std::cout << _(\"Del\") << \" \" << modifyCmd.key_ << std::endl;\n        }\n        Exiv2::ExifData& exifData = pImage->exifData();\n        Exiv2::IptcData& iptcData = pImage->iptcData();\n        Exiv2::XmpData& xmpData = pImage->xmpData();\n        if (modifyCmd.metadataId_ == exif) {\n            Exiv2::ExifData::iterator pos;\n            Exiv2::ExifKey exifKey = Exiv2::ExifKey(modifyCmd.key_);\n            while ((pos = exifData.findKey(exifKey)) != exifData.end()) {\n                exifData.erase(pos);\n            }\n        }\n        if (modifyCmd.metadataId_ == iptc) {\n            Exiv2::IptcData::iterator pos;\n            Exiv2::IptcKey iptcKey = Exiv2::IptcKey(modifyCmd.key_);\n            while ((pos = iptcData.findKey(iptcKey)) != iptcData.end()) {\n                iptcData.erase(pos);\n            }\n        }\n        if (modifyCmd.metadataId_ == xmp) {\n            Exiv2::XmpData::iterator pos;\n            Exiv2::XmpKey xmpKey = Exiv2::XmpKey(modifyCmd.key_);\n            if ((pos = xmpData.findKey(xmpKey)) != xmpData.end()) {\n                xmpData.eraseFamily(pos);\n            }\n        }\n    }", "target": 0}
{"code": "int git_treebuilder_insert(\n\tconst git_tree_entry **entry_out,\n\tgit_treebuilder *bld,\n\tconst char *filename,\n\tconst git_oid *id,\n\tgit_filemode_t filemode)\n{\n\tgit_tree_entry *entry;\n\tsize_t pos;\n\tassert(bld && id && filename);\n\tif (!valid_filemode(filemode))\n\t\treturn tree_error(\"Failed to insert entry. Invalid filemode for file\", filename);\n\tif (!valid_entry_name(filename))\n\t\treturn tree_error(\"Failed to insert entry. Invalid name for a tree entry\", filename);\n\tif (!tree_key_search(&pos, &bld->entries, filename, strlen(filename))) {\n\t\tentry = git_vector_get(&bld->entries, pos);\n\t\tif (entry->removed) {\n\t\t\tentry->removed = 0;\n\t\t\tbld->entrycount++;\n\t\t}\n\t\tentry->attr = filemode;\n\t\tgit_oid_cpy(&entry->oid, id);\n\t} else {\n\t\tentry = alloc_entry(filename);\n\t\tGITERR_CHECK_ALLOC(entry);\n\t\tentry->attr = filemode;\n\t\tgit_oid_cpy(&entry->oid, id);\n\t\tif (git_vector_insert_sorted(&bld->entries, entry, NULL) < 0) {\n\t\t\tgit__free(entry);\n\t\t\treturn -1;\n\t\t}\n\t\tbld->entrycount++;\n\t}\n\tif (entry_out)\n\t\t*entry_out = entry;\n\treturn 0;\n}", "target": 0}
{"code": "static inline void x86_assign_hw_event(struct perf_event *event,\n\t\t\t\tstruct cpu_hw_events *cpuc, int i)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\thwc->idx = cpuc->assign[i];\n\thwc->last_cpu = smp_processor_id();\n\thwc->last_tag = ++cpuc->tags[i];\n\tif (hwc->idx == X86_PMC_IDX_FIXED_BTS) {\n\t\thwc->config_base = 0;\n\t\thwc->event_base\t= 0;\n\t} else if (hwc->idx >= X86_PMC_IDX_FIXED) {\n\t\thwc->config_base = MSR_ARCH_PERFMON_FIXED_CTR_CTRL;\n\t\thwc->event_base = MSR_ARCH_PERFMON_FIXED_CTR0;\n\t} else {\n\t\thwc->config_base = x86_pmu_config_addr(hwc->idx);\n\t\thwc->event_base  = x86_pmu_event_addr(hwc->idx);\n\t}\n}", "target": 1}
{"code": "service_info *FindServiceEventURLPath(\n\tservice_table *table, const char *eventURLPath)\n{\n\tservice_info *finger = NULL;\n\turi_type parsed_url;\n\turi_type parsed_url_in;\n\tif (table &&\n\t\tparse_uri(eventURLPath, strlen(eventURLPath), &parsed_url_in) ==\n\t\t\tHTTP_SUCCESS) {\n\t\tfinger = table->serviceList;\n\t\twhile (finger) {\n\t\t\tif (finger->eventURL) {\n\t\t\t\tif (parse_uri(finger->eventURL,\n\t\t\t\t\t    strlen(finger->eventURL),\n\t\t\t\t\t    &parsed_url) == HTTP_SUCCESS) {\n\t\t\t\t\tif (!token_cmp(&parsed_url.pathquery,\n\t\t\t\t\t\t    &parsed_url_in.pathquery)) {\n\t\t\t\t\t\treturn finger;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinger = finger->next;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "delta_head_destroy(struct delta_head *delta_head)\n{\n\tif (delta_head) {\n\t\tdoc_data_cleanup(&delta_head->doc_data);\n\t\tfree(delta_head);\n\t}\n}", "target": 1}
{"code": "static void vmx_set_msr_bitmap(struct kvm_vcpu *vcpu)\n{\n\tunsigned long *msr_bitmap;\n\tif (is_guest_mode(vcpu))\n\t\tmsr_bitmap = vmx_msr_bitmap_nested;\n\telse if (vcpu->arch.apic_base & X2APIC_ENABLE) {\n\t\tif (is_long_mode(vcpu))\n\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode_x2apic;\n\t\telse\n\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy_x2apic;\n\t} else {\n\t\tif (is_long_mode(vcpu))\n\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode;\n\t\telse\n\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy;\n\t}\n\tvmcs_write64(MSR_BITMAP, __pa(msr_bitmap));\n}", "target": 1}
{"code": "void CheckAuthTest::TestValidToken(const std::string &auth_token,\n                                   const std::string &user_info) {\n  EXPECT_CALL(*raw_request_, FindHeader(\"x-goog-iap-jwt-assertion\", _))\n      .WillOnce(Invoke([](const std::string &, std::string *token) {\n        *token = \"\";\n        return false;\n      }));\n  EXPECT_CALL(*raw_request_, FindHeader(kAuthHeader, _))\n      .WillOnce(Invoke([auth_token](const std::string &, std::string *token) {\n        *token = std::string(kBearer) + auth_token;\n        return true;\n      }));\n  EXPECT_CALL(*raw_request_, SetAuthToken(auth_token)).Times(1);\n  EXPECT_CALL(*raw_env_, DoRunHTTPRequest(_))\n      .Times(2)\n      .WillOnce(Invoke([](HTTPRequest *req) {\n        EXPECT_EQ(req->url(), kIssuer1OpenIdUrl);\n        std::string body(kOpenIdContent);\n        std::map<std::string, std::string> empty;\n        req->OnComplete(Status::OK, std::move(empty), std::move(body));\n      }))\n      .WillOnce(Invoke([](HTTPRequest *req) {\n        EXPECT_EQ(req->url(), kIssuer1PubkeyUrl);\n        std::string body(kPubkey);\n        std::map<std::string, std::string> empty;\n        req->OnComplete(Status::OK, std::move(empty), std::move(body));\n      }));\n  std::cout << \"need be replaced: \" << user_info << std::endl;\n  EXPECT_CALL(*raw_request_,\n              AddHeaderToBackend(kEndpointApiUserInfo, user_info))\n      .WillOnce(Return(utils::Status::OK));\n  CheckAuth(context_, [](Status status) { ASSERT_TRUE(status.ok()); });\n}", "target": 1}
{"code": "static int whiteheat_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tint retval;\n\tretval = start_command_port(port->serial);\n\tif (retval)\n\t\tgoto exit;\n\tretval = firm_open(port);\n\tif (retval) {\n\t\tstop_command_port(port->serial);\n\t\tgoto exit;\n\t}\n\tretval = firm_purge(port, WHITEHEAT_PURGE_RX | WHITEHEAT_PURGE_TX);\n\tif (retval) {\n\t\tfirm_close(port);\n\t\tstop_command_port(port->serial);\n\t\tgoto exit;\n\t}\n\tif (tty)\n\t\tfirm_setup_port(tty);\n\tusb_clear_halt(port->serial->dev, port->read_urb->pipe);\n\tusb_clear_halt(port->serial->dev, port->write_urb->pipe);\n\tretval = usb_serial_generic_open(tty, port);\n\tif (retval) {\n\t\tfirm_close(port);\n\t\tstop_command_port(port->serial);\n\t\tgoto exit;\n\t}\nexit:\n\treturn retval;\n}", "target": 0}
{"code": "Http::FilterDataStatus Context::onRequestBody(int body_buffer_length, bool end_of_stream) {\n  if (!wasm_->onRequestBody_) {\n    return Http::FilterDataStatus::Continue;\n  }\n  switch (wasm_\n              ->onRequestBody_(this, id_, static_cast<uint32_t>(body_buffer_length),\n                               static_cast<uint32_t>(end_of_stream))\n              .u64_) {\n  case 0:\n    return Http::FilterDataStatus::Continue;\n  case 1:\n    return Http::FilterDataStatus::StopIterationAndBuffer;\n  case 2:\n    return Http::FilterDataStatus::StopIterationAndWatermark;\n  default:\n    return Http::FilterDataStatus::StopIterationNoBuffer;\n  }\n}", "target": 1}
{"code": "option_persist_cb (const gchar *option_name,\n                   const gchar *value,\n                   gpointer     data,\n                   GError     **error)\n{\n  FlatpakContext *context = data;\n  flatpak_context_set_persistent (context, value);\n  return TRUE;\n}", "target": 1}
{"code": "chop(char *s)\n{\n\tchar *t = s;\n\twhile (*t) {\n\t\tif (*t == '\\n' || *t == '\\r') {\n\t\t\t*t = '\\0';\n\t\t\treturn s;\n\t\t}\n\t\tt++;\n\t}\n\treturn s;\n}", "target": 0}
{"code": "struct sock *dccp_v4_request_recv_sock(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t       struct request_sock *req,\n\t\t\t\t       struct dst_entry *dst)\n{\n\tstruct inet_request_sock *ireq;\n\tstruct inet_sock *newinet;\n\tstruct sock *newsk;\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto exit_overflow;\n\tif (dst == NULL && (dst = inet_csk_route_req(sk, req)) == NULL)\n\t\tgoto exit;\n\tnewsk = dccp_create_openreq_child(sk, req, skb);\n\tif (newsk == NULL)\n\t\tgoto exit_nonewsk;\n\tsk_setup_caps(newsk, dst);\n\tnewinet\t\t   = inet_sk(newsk);\n\tireq\t\t   = inet_rsk(req);\n\tnewinet->inet_daddr\t= ireq->rmt_addr;\n\tnewinet->inet_rcv_saddr = ireq->loc_addr;\n\tnewinet->inet_saddr\t= ireq->loc_addr;\n\tnewinet->opt\t   = ireq->opt;\n\tireq->opt\t   = NULL;\n\tnewinet->mc_index  = inet_iif(skb);\n\tnewinet->mc_ttl\t   = ip_hdr(skb)->ttl;\n\tnewinet->inet_id   = jiffies;\n\tdccp_sync_mss(newsk, dst_mtu(dst));\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tsock_put(newsk);\n\t\tgoto exit;\n\t}\n\t__inet_hash_nolisten(newsk, NULL);\n\treturn newsk;\nexit_overflow:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nexit_nonewsk:\n\tdst_release(dst);\nexit:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn NULL;\n}", "target": 1}
{"code": "resolve_superior_type_check(struct lys_type *type)\n{\n    uint32_t i;\n    if (type->base == LY_TYPE_DER) {\n        return EXIT_FAILURE;\n    } else if (type->base == LY_TYPE_UNION) {\n        for (i = 0; i < type->info.uni.count; ++i) {\n            if (resolve_superior_type_check(&type->info.uni.types[i])) {\n                return EXIT_FAILURE;\n            }\n        }\n    } else if (type->base == LY_TYPE_LEAFREF) {\n        while (!type->info.lref.path) {\n            assert(type->der);\n            type = &type->der->type;\n        }\n    }\n    return EXIT_SUCCESS;\n}", "target": 0}
{"code": "MagickExport void RemoveDuplicateLayers(Image **images,\n     ExceptionInfo *exception)\n{\n  register Image\n    *curr,\n    *next;\n  RectangleInfo\n    bounds;\n  assert((*images) != (const Image *) NULL);\n  assert((*images)->signature == MagickCoreSignature);\n  if ((*images)->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",(*images)->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  curr=GetFirstImageInList(*images);\n  for (; (next=GetNextImageInList(curr)) != (Image *) NULL; curr=next)\n  {\n    if ( curr->columns != next->columns || curr->rows != next->rows\n         || curr->page.x != next->page.x || curr->page.y != next->page.y )\n      continue;\n    bounds=CompareImagesBounds(curr,next,CompareAnyLayer,exception);\n    if ( bounds.x < 0 ) {\n      size_t time;\n      time = curr->delay*1000/curr->ticks_per_second;\n      time += next->delay*1000/next->ticks_per_second;\n      next->ticks_per_second = 100L;\n      next->delay = time*curr->ticks_per_second/1000;\n      next->iterations = curr->iterations;\n      *images = curr;\n      (void) DeleteImageFromList(images);\n    }\n  }\n  *images = GetFirstImageInList(*images);\n}", "target": 1}
{"code": "int kvm_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3)\n{\n\tif (cr3 == kvm_read_cr3(vcpu) && !pdptrs_changed(vcpu)) {\n\t\tkvm_mmu_sync_roots(vcpu);\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\treturn 0;\n\t}\n\tif (is_long_mode(vcpu)) {\n\t\tif (cr3 & CR3_L_MODE_RESERVED_BITS)\n\t\t\treturn 1;\n\t} else if (is_pae(vcpu) && is_paging(vcpu) &&\n\t\t   !load_pdptrs(vcpu, vcpu->arch.walk_mmu, cr3))\n\t\treturn 1;\n\tvcpu->arch.cr3 = cr3;\n\t__set_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail);\n\tkvm_mmu_new_cr3(vcpu);\n\treturn 0;\n}", "target": 0}
{"code": " cdf_file_summary_info(struct magic_set *ms, const cdf_header_t *h,\n    const cdf_stream_t *sst, const cdf_directory_t *root_storage)\n {\n         cdf_summary_info_header_t si;\n         cdf_property_info_t *info;\n        size_t count;\n        int m;\n        if (cdf_unpack_summary_info(sst, h, &si, &info, &count) == -1)\n                return -1;\n        if (NOTMIME(ms)) {\n\t\tconst char *str;\n                if (file_printf(ms, \"Composite Document File V2 Document\")\n\t\t    == -1)\n                        return -1;\n                if (file_printf(ms, \", %s Endian\",\n                    si.si_byte_order == 0xfffe ?  \"Little\" : \"Big\") == -1)\n                        return -2;\n                switch (si.si_os) {\n                case 2:\n                        if (file_printf(ms, \", Os: Windows, Version %d.%d\",\n                            si.si_os_version & 0xff,\n                            (uint32_t)si.si_os_version >> 8) == -1)\n                                return -2;\n                        break;\n                case 1:\n                        if (file_printf(ms, \", Os: MacOS, Version %d.%d\",\n                            (uint32_t)si.si_os_version >> 8,\n                            si.si_os_version & 0xff) == -1)\n                                return -2;\n                        break;\n                default:\n                        if (file_printf(ms, \", Os %d, Version: %d.%d\", si.si_os,\n                            si.si_os_version & 0xff,\n                            (uint32_t)si.si_os_version >> 8) == -1)\n                                 return -2;\n                         break;\n                 }\n\t\tif (root_storage) {\n\t\t\tstr = cdf_clsid_to_mime(root_storage->d_storage_uuid, clsid2desc);\n\t\t\tif (str)\n\t\t\t\tif (file_printf(ms, \", %s\", str) == -1)\n\t\t\t\t\treturn -2;\n\t\t\t}\n\t\t}\n        m = cdf_file_property_info(ms, info, count, root_storage);\n         free(info);\n         return m == -1 ? -2 : m;\n}", "target": 0}
{"code": "static int sco_sock_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t       char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint len, err = 0;\n\tstruct bt_voice voice;\n\tBT_DBG(\"sk %p\", sk);\n\tif (level == SOL_SCO)\n\t\treturn sco_sock_getsockopt_old(sock, optname, optval, optlen);\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tlock_sock(sk);\n\tswitch (optname) {\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (put_user(test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags),\n\t\t\t     (u32 __user *)optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase BT_VOICE:\n\t\tvoice.setting = sco_pi(sk)->setting;\n\t\tlen = min_t(unsigned int, len, sizeof(voice));\n\t\tif (copy_to_user(optval, (char *)&voice, len))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "find_link_ref(struct link_ref **references, uint8_t *name, size_t length)\n{\n\tunsigned int hash = hash_link_ref(name, length);\n\tstruct link_ref *ref = NULL;\n\tref = references[hash % REF_TABLE_SIZE];\n\twhile (ref != NULL) {\n\t\tif (ref->id == hash)\n\t\t\treturn ref;\n\t\tref = ref->next;\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "static void __exit ipgre_fini(void)\n{\n\trtnl_link_unregister(&ipgre_tap_ops);\n\trtnl_link_unregister(&ipgre_link_ops);\n\tunregister_pernet_device(&ipgre_net_ops);\n\tif (inet_del_protocol(&ipgre_protocol, IPPROTO_GRE) < 0)\n\t\tprintk(KERN_INFO \"ipgre close: can't remove protocol\\n\");\n}", "target": 1}
{"code": "int luaG_traceexec (lua_State *L, const Instruction *pc) {\n  CallInfo *ci = L->ci;\n  lu_byte mask = L->hookmask;\n  int counthook;\n  if (!(mask & (LUA_MASKLINE | LUA_MASKCOUNT))) {  \n    ci->u.l.trap = 0;  \n    return 0;  \n  }\n  pc++;  \n  ci->u.l.savedpc = pc;  \n  counthook = (--L->hookcount == 0 && (mask & LUA_MASKCOUNT));\n  if (counthook)\n    resethookcount(L);  \n  else if (!(mask & LUA_MASKLINE))\n    return 1;  \n  if (ci->callstatus & CIST_HOOKYIELD) {  \n    ci->callstatus &= ~CIST_HOOKYIELD;  \n    return 1;  \n  }\n  if (!isIT(*(ci->u.l.savedpc - 1)))\n    L->top = ci->top;  \n  if (counthook)\n    luaD_hook(L, LUA_HOOKCOUNT, -1, 0, 0);  \n  if (mask & LUA_MASKLINE) {\n    const Proto *p = ci_func(ci)->p;\n    int npci = pcRel(pc, p);\n    if (npci == 0 ||  \n        pc <= L->oldpc ||  \n        changedline(p, pcRel(L->oldpc, p), npci)) {  \n      int newline = luaG_getfuncline(p, npci);\n      luaD_hook(L, LUA_HOOKLINE, newline, 0, 0);  \n    }\n    L->oldpc = pc;  \n  }\n  if (L->status == LUA_YIELD) {  \n    if (counthook)\n      L->hookcount = 1;  \n    ci->u.l.savedpc--;  \n    ci->callstatus |= CIST_HOOKYIELD;  \n    luaD_throw(L, LUA_YIELD);\n  }\n  return 1;  \n}", "target": 1}
{"code": "void shm_exit_ns(struct ipc_namespace *ns)\n{\n\tfree_ipcs(ns, &shm_ids(ns), do_shm_rmid);\n\tidr_destroy(&ns->ids[IPC_SHM_IDS].ipcs_idr);\n}", "target": 0}
{"code": "mld6_print(netdissect_options *ndo, const u_char *bp)\n{\n\tconst struct mld6_hdr *mp = (const struct mld6_hdr *)bp;\n\tconst u_char *ep;\n\tep = ndo->ndo_snapend;\n\tif ((const u_char *)mp + sizeof(*mp) > ep)\n\t\treturn;\n\tND_PRINT((ndo,\"max resp delay: %d \", EXTRACT_16BITS(&mp->mld6_maxdelay)));\n\tND_PRINT((ndo,\"addr: %s\", ip6addr_string(ndo, &mp->mld6_addr)));\n}", "target": 0}
{"code": "MATCHER_P(RepeatedProtoEq, expected, \"\") {\n  const bool equal = TestUtility::repeatedPtrFieldEqual(arg, expected);\n  if (!equal) {\n    *result_listener << \"\\n\"\n                     << TestUtility::addLeftAndRightPadding(\"Expected repeated:\") << \"\\n\"\n                     << RepeatedPtrUtil::debugString(expected) << \"\\n\"\n                     << TestUtility::addLeftAndRightPadding(\"is not equal to actual repeated:\")\n                     << \"\\n\"\n                     << RepeatedPtrUtil::debugString(arg) << \"\\n\"\n                     << TestUtility::addLeftAndRightPadding(\"\") \n                     << \"\\n\";\n  }\n  return equal;\n}", "target": 0}
{"code": "static int cdc_ncm_bind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tint ret;\n\tif (cdc_ncm_select_altsetting(intf) != CDC_NCM_COMM_ALTSETTING_NCM)\n\t\treturn -ENODEV;\n\tret = cdc_ncm_bind_common(dev, intf, CDC_NCM_DATA_ALTSETTING_NCM, 0);\n\tusbnet_link_change(dev, 0, 0);\n\treturn ret;\n}", "target": 1}
{"code": "int git_treebuilder_write(git_oid *oid, git_repository *repo, git_treebuilder *bld)\n{\n\tint error = 0;\n\tsize_t i;\n\tgit_buf tree = GIT_BUF_INIT;\n\tgit_odb *odb;\n\tassert(bld);\n\tgit_vector_sort(&bld->entries);\n\terror = git_buf_grow(&tree, bld->entries.length * 72);\n\tfor (i = 0; i < bld->entries.length && !error; ++i) {\n\t\tgit_tree_entry *entry = git_vector_get(&bld->entries, i);\n\t\tif (entry->removed)\n\t\t\tcontinue;\n\t\tgit_buf_printf(&tree, \"%o \", entry->attr);\n\t\tgit_buf_put(&tree, entry->filename, entry->filename_len + 1);\n\t\tgit_buf_put(&tree, (char *)entry->oid.id, GIT_OID_RAWSZ);\n\t\tif (git_buf_oom(&tree))\n\t\t\terror = -1;\n\t}\n\tif (!error &&\n\t\t!(error = git_repository_odb__weakptr(&odb, repo)))\n\t\terror = git_odb_write(oid, odb, tree.ptr, tree.size, GIT_OBJ_TREE);\n\tgit_buf_free(&tree);\n\treturn error;\n}", "target": 0}
{"code": "static inline int qdisc_restart(struct net_device *dev)\n{\n\tstruct Qdisc *q = dev->qdisc;\n\tstruct sk_buff *skb;\n\tint ret = NETDEV_TX_BUSY;\n\tif (unlikely((skb = dev_dequeue_skb(dev, q)) == NULL))\n\t\treturn 0;\n\tspin_unlock(&dev->queue_lock);\n\tHARD_TX_LOCK(dev, smp_processor_id());\n\tif (!netif_subqueue_stopped(dev, skb))\n\t\tret = dev_hard_start_xmit(skb, dev);\n\tHARD_TX_UNLOCK(dev);\n\tspin_lock(&dev->queue_lock);\n\tq = dev->qdisc;\n\tswitch (ret) {\n\tcase NETDEV_TX_OK:\n\t\tret = qdisc_qlen(q);\n\t\tbreak;\n\tcase NETDEV_TX_LOCKED:\n\t\tret = handle_dev_cpu_collision(skb, dev, q);\n\t\tbreak;\n\tdefault:\n\t\tif (unlikely (ret != NETDEV_TX_BUSY && net_ratelimit()))\n\t\t\tprintk(KERN_WARNING \"BUG %s code %d qlen %d\\n\",\n\t\t\t       dev->name, ret, q->q.qlen);\n\t\tret = dev_requeue_skb(skb, dev, q);\n\t\tbreak;\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "static int cbs_av1_read_uvlc(CodedBitstreamContext *ctx, GetBitContext *gbc,\n                             const char *name, uint32_t *write_to,\n                             uint32_t range_min, uint32_t range_max)\n{\n    uint32_t value;\n    int position, zeroes, i, j;\n    char bits[65];\n    if (ctx->trace_enable)\n        position = get_bits_count(gbc);\n    zeroes = i = 0;\n    while (1) {\n        if (get_bits_left(gbc) < zeroes + 1) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid uvlc code at \"\n                   \"%s: bitstream ended.\\n\", name);\n            return AVERROR_INVALIDDATA;\n        }\n        if (get_bits1(gbc)) {\n            bits[i++] = '1';\n            break;\n        } else {\n            bits[i++] = '0';\n            ++zeroes;\n        }\n    }\n    if (zeroes >= 32) {\n        value = MAX_UINT_BITS(32);\n    } else {\n        value = get_bits_long(gbc, zeroes);\n        for (j = 0; j < zeroes; j++)\n            bits[i++] = (value >> (zeroes - j - 1) & 1) ? '1' : '0';\n        value += (1 << zeroes) - 1;\n    }\n    if (ctx->trace_enable) {\n        bits[i] = 0;\n        ff_cbs_trace_syntax_element(ctx, position, name, NULL,\n                                    bits, value);\n    }\n    if (value < range_min || value > range_max) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"%s out of range: \"\n               \"%\"PRIu32\", but must be in [%\"PRIu32\",%\"PRIu32\"].\\n\",\n               name, value, range_min, range_max);\n        return AVERROR_INVALIDDATA;\n    }\n    *write_to = value;\n    return 0;\n}", "target": 1}
{"code": "static int move_to_new_page(struct page *newpage, struct page *page)\n{\n\tstruct address_space *mapping;\n\tint rc;\n\tif (TestSetPageLocked(newpage))\n\t\tBUG();\n\tnewpage->index = page->index;\n\tnewpage->mapping = page->mapping;\n\tmapping = page_mapping(page);\n\tif (!mapping)\n\t\trc = migrate_page(mapping, newpage, page);\n\telse if (mapping->a_ops->migratepage)\n\t\trc = mapping->a_ops->migratepage(mapping,\n\t\t\t\t\t\tnewpage, page);\n\telse\n\t\trc = fallback_migrate_page(mapping, newpage, page);\n\tif (!rc) {\n\t\tmem_cgroup_page_migration(page, newpage);\n\t\tremove_migration_ptes(page, newpage);\n\t} else\n\t\tnewpage->mapping = NULL;\n\tunlock_page(newpage);\n\treturn rc;\n}", "target": 0}
{"code": " void InputMethodBase::OnInputMethodChanged() const {\n   TextInputClient* client = GetTextInputClient();\n  if (client && client->GetTextInputType() != TEXT_INPUT_TYPE_NONE)\n     client->OnInputMethodChanged();\n }", "target": 1}
{"code": "get_one_option(int optid, const struct my_option *opt,\n               char *argument)\n{\n  my_bool add_option= TRUE;\n  switch (optid) {\n  case '?':\n    printf(\"%s  Ver %s Distrib %s, for %s (%s)\\n\",\n           my_progname, VER, MYSQL_SERVER_VERSION, SYSTEM_TYPE, MACHINE_TYPE);\n    puts(ORACLE_WELCOME_COPYRIGHT_NOTICE(\"2000\"));\n    puts(\"MySQL utility for upgrading databases to new MySQL versions.\\n\");\n    my_print_help(my_long_options);\n    exit(0);\n    break;\n  case '#':\n    DBUG_PUSH(argument ? argument : default_dbug_option);\n    add_option= FALSE;\n    debug_check_flag= 1;\n    break;\n  case 'p':\n    if (argument == disabled_my_option)\n      argument= (char*) \"\";\t\t\t\n    tty_password= 1;\n    add_option= FALSE;\n    if (argument)\n    {\n      add_one_option(&ds_args, opt, argument);\n      while (*argument)\n        *argument++= 'x';                       \n      tty_password= 0;\n    }\n    break;\n  case 't':\n    my_stpnmov(opt_tmpdir, argument, sizeof(opt_tmpdir));\n    add_option= FALSE;\n    break;\n  case 'k':                                     \n  case 'v': \n  case 'f': \n  case 's':                                     \n  case OPT_WRITE_BINLOG:                        \n    add_option= FALSE;\n    break;\n  case 'h': \n  case 'W': \n  case 'P': \n  case 'S': \n  case OPT_MYSQL_PROTOCOL: \n  case OPT_SHARED_MEMORY_BASE_NAME: \n  case OPT_PLUGIN_DIR:                          \n  case OPT_DEFAULT_AUTH:                        \n    add_one_option(&conn_args, opt, argument);\n    break;\n  }\n  if (add_option)\n  {\n    add_one_option(&ds_args, opt, argument);\n  }\n  return 0;\n}", "target": 1}
{"code": "static void check_serverpath(request_rec *r)\n{\n    server_rec *s;\n    server_rec *last_s;\n    name_chain *src;\n    apr_port_t port;\n    port = r->connection->local_addr->port;\n    last_s = NULL;\n    for (src = r->connection->vhost_lookup_data; src; src = src->next) {\n        if (src->sar->host_port != 0 && port != src->sar->host_port) {\n            continue;\n        }\n        s = src->server;\n        if (s == last_s) {\n            continue;\n        }\n        last_s = s;\n        if (s->path && !strncmp(r->uri, s->path, s->pathlen) &&\n            (s->path[s->pathlen - 1] == '/' ||\n             r->uri[s->pathlen] == '/' ||\n             r->uri[s->pathlen] == '\\0')) {\n            r->server = s;\n            return;\n        }\n    }\n}", "target": 1}
{"code": "static void smp_task_timedout(struct timer_list *t)\n{\n\tstruct sas_task_slow *slow = from_timer(slow, t, timer);\n\tstruct sas_task *task = slow->task;\n\tunsigned long flags;\n\tspin_lock_irqsave(&task->task_state_lock, flags);\n\tif (!(task->task_state_flags & SAS_TASK_STATE_DONE))\n\t\ttask->task_state_flags |= SAS_TASK_STATE_ABORTED;\n\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\tcomplete(&task->slow_task->completion);\n}", "target": 1}
{"code": "static int bcm_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct net *net;\n\tstruct bcm_sock *bo;\n\tstruct bcm_op *op, *next;\n\tif (!sk)\n\t\treturn 0;\n\tnet = sock_net(sk);\n\tbo = bcm_sk(sk);\n\tspin_lock(&bcm_notifier_lock);\n\twhile (bcm_busy_notifier == bo) {\n\t\tspin_unlock(&bcm_notifier_lock);\n\t\tschedule_timeout_uninterruptible(1);\n\t\tspin_lock(&bcm_notifier_lock);\n\t}\n\tlist_del(&bo->notifier);\n\tspin_unlock(&bcm_notifier_lock);\n\tlock_sock(sk);\n\tlist_for_each_entry_safe(op, next, &bo->tx_ops, list)\n\t\tbcm_remove_op(op);\n\tlist_for_each_entry_safe(op, next, &bo->rx_ops, list) {\n\t\tif (op->ifindex) {\n\t\t\tif (op->rx_reg_dev) {\n\t\t\t\tstruct net_device *dev;\n\t\t\t\tdev = dev_get_by_index(net, op->ifindex);\n\t\t\t\tif (dev) {\n\t\t\t\t\tbcm_rx_unreg(dev, op);\n\t\t\t\t\tdev_put(dev);\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tcan_rx_unregister(net, NULL, op->can_id,\n\t\t\t\t\t  REGMASK(op->can_id),\n\t\t\t\t\t  bcm_rx_handler, op);\n\t\tbcm_remove_op(op);\n\t}\n#if IS_ENABLED(CONFIG_PROC_FS)\n\tif (net->can.bcmproc_dir && bo->bcm_proc_read)\n\t\tremove_proc_entry(bo->procname, net->can.bcmproc_dir);\n#endif \n\tif (bo->bound) {\n\t\tbo->bound   = 0;\n\t\tbo->ifindex = 0;\n\t}\n\tsock_orphan(sk);\n\tsock->sk = NULL;\n\trelease_sock(sk);\n\tsock_put(sk);\n\treturn 0;\n}", "target": 1}
{"code": "    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,\n                                       const UBaseType_t uxItemSize,\n                                       const uint8_t ucQueueType )\n    {\n        Queue_t * pxNewQueue;\n        size_t xQueueSizeInBytes;\n        uint8_t * pucQueueStorage;\n        configASSERT( uxQueueLength > ( UBaseType_t ) 0 );\n        xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); \n        configASSERT( ( uxItemSize == 0 ) || ( uxQueueLength == ( xQueueSizeInBytes / uxItemSize ) ) );\n        pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); \n        if( pxNewQueue != NULL )\n        {\n            pucQueueStorage = ( uint8_t * ) pxNewQueue;\n            pucQueueStorage += sizeof( Queue_t ); \n            #if ( configSUPPORT_STATIC_ALLOCATION == 1 )\n                {\n                    pxNewQueue->ucStaticallyAllocated = pdFALSE;\n                }\n            #endif \n            prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );\n        }\n        else\n        {\n            traceQUEUE_CREATE_FAILED( ucQueueType );\n            mtCOVERAGE_TEST_MARKER();\n        }\n        return pxNewQueue;\n    }", "target": 1}
{"code": "case_map(OnigCaseFoldType* flagP, const OnigUChar** pp,\n\t const OnigUChar* end, OnigUChar* to, OnigUChar* to_end,\n\t const struct OnigEncodingTypeST* enc)\n{\n  OnigCodePoint code;\n  OnigUChar *to_start = to;\n  OnigCaseFoldType flags = *flagP;\n  while (*pp < end && to < to_end) {\n    code = *(*pp)++;\n    if (code == SHARP_s) {\n      if (flags & ONIGENC_CASE_UPCASE) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\t*to++ = 'S';\n\tcode = (flags & ONIGENC_CASE_TITLECASE) ? 's' : 'S';\n      }\n      else if (flags & ONIGENC_CASE_FOLD) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\t*to++ = 's';\n\tcode = 's';\n      }\n    }\n    else if (code == 0xB5)\n      ;\n    else if ((EncCP1252_CtypeTable[code] & BIT_CTYPE_UPPER)\n\t     && (flags & (ONIGENC_CASE_DOWNCASE | ONIGENC_CASE_FOLD))) {\n      flags |= ONIGENC_CASE_MODIFIED;\n      if (code == 'I')\n\tcode = flags & ONIGENC_CASE_FOLD_TURKISH_AZERI ? DOTLESS_i : 'i';\n      else\n\tcode = ENC_CP1252_TO_LOWER_CASE(code);\n    }\n    else if ((EncCP1252_CtypeTable[code]&BIT_CTYPE_LOWER)\n\t     && (flags & ONIGENC_CASE_UPCASE)) {\n      flags |= ONIGENC_CASE_MODIFIED;\n      if (code == 'i')\n\tcode = flags & ONIGENC_CASE_FOLD_TURKISH_AZERI ? I_WITH_DOT_ABOVE : 'I';\n      else if (code == DOTLESS_i)\n\tcode = 'I';\n      else if (code >= 0xB0 && code <= 0xBF)\n\tcode -= 0x10;\n      else\n\tcode -= 0x20;\n    }\n    *to++ = code;\n    if (flags & ONIGENC_CASE_TITLECASE)  \n      flags ^= (ONIGENC_CASE_UPCASE | ONIGENC_CASE_DOWNCASE | ONIGENC_CASE_TITLECASE);\n  }\n  *flagP = flags;\n  return (int )(to - to_start);\n}", "target": 0}
{"code": "struct vfsmount *mnt_clone_internal(struct path *path)\n{\n\tstruct mount *p;\n\tp = clone_mnt(real_mount(path->mnt), path->dentry, CL_PRIVATE);\n\tif (IS_ERR(p))\n\t\treturn ERR_CAST(p);\n\tp->mnt.mnt_flags |= MNT_INTERNAL;\n\treturn &p->mnt;\n}", "target": 0}
{"code": "static int regex_match_front(char *str, struct regex *r, int len)\n{\n\tif (len && len < r->len)\n\t\treturn 0;\n\treturn strncmp(str, r->pattern, r->len) == 0;\n}", "target": 0}
{"code": "bool st_select_lex::setup_ref_array(THD *thd, uint order_group_num)\n{\n  if (!((options & SELECT_DISTINCT) && !group_list.elements))\n    hidden_bit_fields= 0;\n  order_group_num*= 2;\n  Query_arena *arena= thd->stmt_arena;\n  const uint n_elems= (n_sum_items +\n                       n_child_sum_items +\n                       item_list.elements +\n                       select_n_reserved +\n                       select_n_having_items +\n                       select_n_where_fields +\n                       order_group_num +\n                       hidden_bit_fields +\n                       fields_in_window_functions) * 5;\n  if (!ref_pointer_array.is_null())\n  {\n    if (ref_pointer_array.size() >= n_elems)\n      return false;\n   }\n  Item **array= static_cast<Item**>(arena->alloc(sizeof(Item*) * n_elems));\n  if (array != NULL)\n    ref_pointer_array= Ref_ptr_array(array, n_elems);\n  return array == NULL;\n}", "target": 1}
{"code": "int verify_compat_iovec(struct msghdr *kern_msg, struct iovec *kern_iov,\n\t\t   struct sockaddr_storage *kern_address, int mode)\n{\n\tint tot_len;\n\tif (kern_msg->msg_namelen) {\n\t\tif (mode == VERIFY_READ) {\n\t\t\tint err = move_addr_to_kernel(kern_msg->msg_name,\n\t\t\t\t\t\t      kern_msg->msg_namelen,\n\t\t\t\t\t\t      kern_address);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tkern_msg->msg_name = kern_address;\n\t} else\n\t\tkern_msg->msg_name = NULL;\n\ttot_len = iov_from_user_compat_to_kern(kern_iov,\n\t\t\t\t\t  (struct compat_iovec __user *)kern_msg->msg_iov,\n\t\t\t\t\t  kern_msg->msg_iovlen);\n\tif (tot_len >= 0)\n\t\tkern_msg->msg_iov = kern_iov;\n\treturn tot_len;\n}", "target": 1}
{"code": "rdp_process_general_caps(STREAM s)\n{\n\tuint16 pad2octetsB;\t\n\tin_uint8s(s, 10);\n\tin_uint16_le(s, pad2octetsB);\n\tif (!pad2octetsB)\n\t\tg_rdp_version = RDP_V4;\n}", "target": 0}
{"code": "parseuid(const char *s, uid_t *uid)\n{\n\tstruct passwd *pw;\n\tconst char *errstr;\n\tif ((pw = getpwnam(s)) != NULL) {\n\t\t*uid = pw->pw_uid;\n\t\treturn 0;\n\t}\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\t*uid = strtonum(s, 0, UID_MAX, &errstr);\n\t#else\n\tsscanf(s, \"%d\", uid);\n\t#endif\n\tif (errstr)\n\t\treturn -1;\n\treturn 0;\n}", "target": 1}
{"code": "int __split_vma(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long addr, int new_below)\n{\n\tstruct vm_area_struct *new;\n\tint err;\n\tif (is_vm_hugetlb_page(vma) && (addr &\n\t\t\t\t\t~(huge_page_mask(hstate_vma(vma)))))\n\t\treturn -EINVAL;\n\tnew = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL);\n\tif (!new)\n\t\treturn -ENOMEM;\n\t*new = *vma;\n\tINIT_LIST_HEAD(&new->anon_vma_chain);\n\tif (new_below)\n\t\tnew->vm_end = addr;\n\telse {\n\t\tnew->vm_start = addr;\n\t\tnew->vm_pgoff += ((addr - vma->vm_start) >> PAGE_SHIFT);\n\t}\n\terr = vma_dup_policy(vma, new);\n\tif (err)\n\t\tgoto out_free_vma;\n\terr = anon_vma_clone(new, vma);\n\tif (err)\n\t\tgoto out_free_mpol;\n\tif (new->vm_file)\n\t\tget_file(new->vm_file);\n\tif (new->vm_ops && new->vm_ops->open)\n\t\tnew->vm_ops->open(new);\n\tif (new_below)\n\t\terr = vma_adjust(vma, addr, vma->vm_end, vma->vm_pgoff +\n\t\t\t((addr - new->vm_start) >> PAGE_SHIFT), new);\n\telse\n\t\terr = vma_adjust(vma, vma->vm_start, addr, vma->vm_pgoff, new);\n\tif (!err)\n\t\treturn 0;\n\tif (new->vm_ops && new->vm_ops->close)\n\t\tnew->vm_ops->close(new);\n\tif (new->vm_file)\n\t\tfput(new->vm_file);\n\tunlink_anon_vmas(new);\n out_free_mpol:\n\tmpol_put(vma_policy(new));\n out_free_vma:\n\tkmem_cache_free(vm_area_cachep, new);\n\treturn err;\n}", "target": 0}
{"code": "static void free_kmem_cache_nodes(struct kmem_cache *s)\n{\n\tint node;\n\tfor_each_node_state(node, N_NORMAL_MEMORY) {\n\t\tstruct kmem_cache_node *n = s->node[node];\n\t\tif (n && n != &s->local_node)\n\t\t\tkmem_cache_free(kmalloc_caches, n);\n\t\ts->node[node] = NULL;\n\t}\n}", "target": 0}
{"code": "ResolveStateAndPredicate(ExprDef *expr, enum xkb_match_operation *pred_rtrn,\n                         xkb_mod_mask_t *mods_rtrn, CompatInfo *info)\n{\n    if (expr == NULL) {\n        *pred_rtrn = MATCH_ANY_OR_NONE;\n        *mods_rtrn = MOD_REAL_MASK_ALL;\n        return true;\n    }\n    *pred_rtrn = MATCH_EXACTLY;\n    if (expr->expr.op == EXPR_ACTION_DECL) {\n        const char *pred_txt = xkb_atom_text(info->ctx, expr->action.name);\n        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn)) {\n            log_err(info->ctx,\n                    \"Illegal modifier predicate \\\"%s\\\"; Ignored\\n\", pred_txt);\n            return false;\n        }\n        expr = expr->action.args;\n    }\n    else if (expr->expr.op == EXPR_IDENT) {\n        const char *pred_txt = xkb_atom_text(info->ctx, expr->ident.ident);\n        if (pred_txt && istreq(pred_txt, \"any\")) {\n            *pred_rtrn = MATCH_ANY;\n            *mods_rtrn = MOD_REAL_MASK_ALL;\n            return true;\n        }\n    }\n    return ExprResolveModMask(info->ctx, expr, MOD_REAL, &info->mods,\n                              mods_rtrn);\n}", "target": 1}
{"code": "ssh_scp ssh_scp_new(ssh_session session, int mode, const char *location)\n{\n    ssh_scp scp = NULL;\n    if (session == NULL) {\n        goto error;\n    }\n    scp = (ssh_scp)calloc(1, sizeof(struct ssh_scp_struct));\n    if (scp == NULL) {\n        ssh_set_error(session, SSH_FATAL,\n                      \"Error allocating memory for ssh_scp\");\n        goto error;\n    }\n    if ((mode & ~SSH_SCP_RECURSIVE) != SSH_SCP_WRITE &&\n        (mode & ~SSH_SCP_RECURSIVE) != SSH_SCP_READ)\n    {\n        ssh_set_error(session, SSH_FATAL,\n                      \"Invalid mode %d for ssh_scp_new()\", mode);\n        goto error;\n    }\n    scp->location = strdup(location);\n    if (scp->location == NULL) {\n        ssh_set_error(session, SSH_FATAL,\n                      \"Error allocating memory for ssh_scp\");\n        goto error;\n    }\n    scp->session = session;\n    scp->mode = mode & ~SSH_SCP_RECURSIVE;\n    scp->recursive = (mode & SSH_SCP_RECURSIVE) != 0;\n    scp->channel = NULL;\n    scp->state = SSH_SCP_NEW;\n    return scp;\nerror:\n    ssh_scp_free(scp);\n    return NULL;\n}", "target": 1}
{"code": "  void initialize() override {\n    use_lds_ = false;\n    test_skipped_ = false;\n    setUpstreamCount(1);                         \n    setUpstreamProtocol(Http::CodecType::HTTP2); \n    defer_listener_finalization_ = true;\n    HttpIntegrationTest::initialize();\n    addFakeUpstream(Http::CodecType::HTTP2);\n    addFakeUpstream(Http::CodecType::HTTP2);\n    cluster1_ = ConfigHelper::buildStaticCluster(\n        ClusterName1, fake_upstreams_[UpstreamIndex1]->localAddress()->ip()->port(),\n        Network::Test::getLoopbackAddressString(ipVersion()));\n    cluster2_ = ConfigHelper::buildStaticCluster(\n        ClusterName2, fake_upstreams_[UpstreamIndex2]->localAddress()->ip()->port(),\n        Network::Test::getLoopbackAddressString(ipVersion()));\n    acceptXdsConnection();\n    EXPECT_TRUE(compareDiscoveryRequest(Config::TypeUrl::get().Cluster, \"\", {}, {}, {}, true));\n    sendDiscoveryResponse<envoy::config::cluster::v3::Cluster>(Config::TypeUrl::get().Cluster,\n                                                               {cluster1_}, {cluster1_}, {}, \"55\");\n    test_server_->waitForGaugeGe(\"cluster_manager.active_clusters\", 2);\n    test_server_->waitUntilListenersReady();\n    registerTestServerPorts({\"http\"});\n  }", "target": 1}
{"code": "static void irda_connect_confirm(void *instance, void *sap,\n\t\t\t\t struct qos_info *qos,\n\t\t\t\t __u32 max_sdu_size, __u8 max_header_size,\n\t\t\t\t struct sk_buff *skb)\n{\n\tstruct irda_sock *self;\n\tstruct sock *sk;\n\tself = instance;\n\tIRDA_DEBUG(2, \"%s(%p)\\n\", __func__, self);\n\tsk = instance;\n\tif (sk == NULL) {\n\t\tdev_kfree_skb(skb);\n\t\treturn;\n\t}\n\tdev_kfree_skb(skb);\n\tself->max_header_size = max_header_size;\n\tself->max_sdu_size_tx = max_sdu_size;\n\tswitch (sk->sk_type) {\n\tcase SOCK_STREAM:\n\t\tif (max_sdu_size != 0) {\n\t\t\tIRDA_ERROR(\"%s: max_sdu_size must be 0\\n\",\n\t\t\t\t   __func__);\n\t\t\treturn;\n\t\t}\n\t\tself->max_data_size = irttp_get_max_seg_size(self->tsap);\n\t\tbreak;\n\tcase SOCK_SEQPACKET:\n\t\tif (max_sdu_size == 0) {\n\t\t\tIRDA_ERROR(\"%s: max_sdu_size cannot be 0\\n\",\n\t\t\t\t   __func__);\n\t\t\treturn;\n\t\t}\n\t\tself->max_data_size = max_sdu_size;\n\t\tbreak;\n\tdefault:\n\t\tself->max_data_size = irttp_get_max_seg_size(self->tsap);\n\t}\n\tIRDA_DEBUG(2, \"%s(), max_data_size=%d\\n\", __func__,\n\t\t   self->max_data_size);\n\tmemcpy(&self->qos_tx, qos, sizeof(struct qos_info));\n\tsk->sk_state = TCP_ESTABLISHED;\n\tsk->sk_state_change(sk);\n}", "target": 0}
{"code": "int ocfs2_set_acl(handle_t *handle,\n\t\t\t struct inode *inode,\n\t\t\t struct buffer_head *di_bh,\n\t\t\t int type,\n\t\t\t struct posix_acl *acl,\n\t\t\t struct ocfs2_alloc_context *meta_ac,\n\t\t\t struct ocfs2_alloc_context *data_ac)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint ret;\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tumode_t mode = inode->i_mode;\n\t\t\tret = posix_acl_equiv_mode(acl, &mode);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (ret == 0)\n\t\t\t\tacl = NULL;\n\t\t\tret = ocfs2_acl_set_mode(inode, di_bh,\n\t\t\t\t\t\t handle, mode);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tvalue = ocfs2_acl_to_xattr(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\tif (handle)\n\t\tret = ocfs2_xattr_set_handle(handle, inode, di_bh, name_index,\n\t\t\t\t\t     \"\", value, size, 0,\n\t\t\t\t\t     meta_ac, data_ac);\n\telse\n\t\tret = ocfs2_xattr_set(inode, name_index, \"\", value, size, 0);\n\tkfree(value);\n\treturn ret;\n}", "target": 1}
{"code": "int snd_card_register(struct snd_card *card)\n{\n\tint err;\n\tif (snd_BUG_ON(!card))\n\t\treturn -EINVAL;\n\tif (!card->registered) {\n\t\terr = device_add(&card->card_dev);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tcard->registered = true;\n\t}\n\tif ((err = snd_device_register_all(card)) < 0)\n\t\treturn err;\n\tmutex_lock(&snd_card_mutex);\n\tif (snd_cards[card->number]) {\n\t\tmutex_unlock(&snd_card_mutex);\n\t\treturn 0;\n\t}\n\tif (*card->id) {\n\t\tchar tmpid[sizeof(card->id)];\n\t\tmemcpy(tmpid, card->id, sizeof(card->id));\n\t\tsnd_card_set_id_no_lock(card, tmpid, tmpid);\n\t} else {\n\t\tconst char *src;\n\t\tsrc = *card->shortname ? card->shortname : card->longname;\n\t\tsnd_card_set_id_no_lock(card, src,\n\t\t\t\t\tretrieve_id_from_card_name(src));\n\t}\n\tsnd_cards[card->number] = card;\n\tmutex_unlock(&snd_card_mutex);\n\tinit_info_for_card(card);\n#if IS_ENABLED(CONFIG_SND_MIXER_OSS)\n\tif (snd_mixer_oss_notify_callback)\n\t\tsnd_mixer_oss_notify_callback(card, SND_MIXER_OSS_NOTIFY_REGISTER);\n#endif\n\treturn 0;\n}", "target": 0}
{"code": "std::map<string, AttrValue> GetSetAttrs(const FunctionDef& fdef) {\n  std::map<string, AttrValue> set_attrs;\n  for (const auto& pair : fdef.attr()) {\n    if (pair.second.value_case() != AttrValue::VALUE_NOT_SET) {\n      set_attrs[pair.first] = pair.second;\n    }\n  }\n  return set_attrs;\n}", "target": 0}
{"code": "NTSTATUS ldapsrv_queue_reply(struct ldapsrv_call *call, struct ldapsrv_reply *reply)\n{\n\tNTSTATUS status = ldapsrv_encode(call, reply);\n\tif (!NT_STATUS_IS_OK(status)) {\n\t\treturn status;\n\t}\n\tif (call->reply_size > call->reply_size + reply->blob.length\n\t    || call->reply_size + reply->blob.length > LDAP_SERVER_MAX_REPLY_SIZE) {\n\t\tDBG_WARNING(\"Refusing to queue LDAP search response size \"\n\t\t\t    \"of more than %zu bytes\\n\",\n\t\t\t    LDAP_SERVER_MAX_REPLY_SIZE);\n\t\tTALLOC_FREE(reply->blob.data);\n\t\treturn NT_STATUS_FILE_TOO_LARGE;\n\t}\n\tcall->reply_size += reply->blob.length;\n\tDLIST_ADD_END(call->replies, reply);\n\treturn status;\n}", "target": 0}
{"code": "    inline EndpointSecurityAttributesMask mask() const\n    {\n        EndpointSecurityAttributesMask rv = ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_VALID;\n        if (is_read_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_READ_PROTECTED;\n        if (is_write_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_WRITE_PROTECTED;\n        if (is_discovery_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_DISCOVERY_PROTECTED;\n        if (is_liveliness_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_LIVELINESS_PROTECTED;\n        if (is_submessage_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_SUBMESSAGE_PROTECTED;\n        if (is_payload_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_PAYLOAD_PROTECTED;\n        if (is_key_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_KEY_PROTECTED;\n        return rv;\n    }", "target": 1}
{"code": "static void make_response(struct xen_blkif_ring *ring, u64 id,\n\t\t\t  unsigned short op, int st)\n{\n\tstruct blkif_response  resp;\n\tunsigned long     flags;\n\tunion blkif_back_rings *blk_rings;\n\tint notify;\n\tresp.id        = id;\n\tresp.operation = op;\n\tresp.status    = st;\n\tspin_lock_irqsave(&ring->blk_ring_lock, flags);\n\tblk_rings = &ring->blk_rings;\n\tswitch (ring->blkif->blk_protocol) {\n\tcase BLKIF_PROTOCOL_NATIVE:\n\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->native, blk_rings->native.rsp_prod_pvt),\n\t\t       &resp, sizeof(resp));\n\t\tbreak;\n\tcase BLKIF_PROTOCOL_X86_32:\n\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->x86_32, blk_rings->x86_32.rsp_prod_pvt),\n\t\t       &resp, sizeof(resp));\n\t\tbreak;\n\tcase BLKIF_PROTOCOL_X86_64:\n\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->x86_64, blk_rings->x86_64.rsp_prod_pvt),\n\t\t       &resp, sizeof(resp));\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tblk_rings->common.rsp_prod_pvt++;\n\tRING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&blk_rings->common, notify);\n\tspin_unlock_irqrestore(&ring->blk_ring_lock, flags);\n\tif (notify)\n\t\tnotify_remote_via_irq(ring->irq);\n}", "target": 1}
{"code": "coolkey_attribute_start(const u8 *obj, u8 object_record_type, size_t buf_len)\n{\n\tsize_t offset = object_record_type == COOLKEY_V1_OBJECT ? sizeof(coolkey_object_header_t) :\n\t\t\tsizeof(coolkey_v0_object_header_t);\n\tif ((object_record_type != COOLKEY_V1_OBJECT) && (object_record_type != COOLKEY_V0_OBJECT)) {\n\t\treturn NULL;\n\t}\n\tif (offset > buf_len) {\n\t\treturn NULL;\n\t}\n\treturn obj + offset;\n}", "target": 0}
{"code": "void sk_free(struct sock *sk)\n{\n\tif (atomic_dec_and_test(&sk->sk_wmem_alloc))\n\t\t__sk_free(sk);\n}", "target": 0}
{"code": "void vmacache_flush_all(struct mm_struct *mm)\n{\n\tstruct task_struct *g, *p;\n\tcount_vm_vmacache_event(VMACACHE_FULL_FLUSHES);\n\tif (atomic_read(&mm->mm_users) == 1)\n\t\treturn;\n\trcu_read_lock();\n\tfor_each_process_thread(g, p) {\n\t\tif (mm == p->mm)\n\t\t\tvmacache_flush(p);\n\t}\n\trcu_read_unlock();\n}", "target": 1}
{"code": "lyd_new_output_anydata(struct lyd_node *parent, const struct lys_module *module, const char *name,\n                       void *value, LYD_ANYDATA_VALUETYPE value_type)\n{\n    const struct lys_node *siblings, *snode;\n    if ((!parent && !module) || !name) {\n        LOGARG;\n        return NULL;\n    }\n    siblings = lyd_new_find_schema(parent, module, 1);\n    if (!siblings) {\n        LOGARG;\n        return NULL;\n    }\n    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_ANYDATA, &snode) || !snode) {\n        LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",\n               name, lys_node_module(siblings)->name, siblings->name);\n        return NULL;\n    }\n    return lyd_create_anydata(parent, snode, value, value_type);\n}", "target": 1}
{"code": "process_bitmap_updates(STREAM s)\n{\n\tuint16 num_updates;\n\tint i;\n\tin_uint16_le(s, num_updates);\t\n\tfor (i = 0; i < num_updates; i++)\n\t{\n\t\tprocess_bitmap_data(s);\n\t}\n}", "target": 0}
{"code": "static inline void SMTPTransactionComplete(SMTPState *state)\n{\n    DEBUG_VALIDATE_BUG_ON(state->curr_tx == NULL);\n    if (state->curr_tx)\n        state->curr_tx->done = 1;\n}", "target": 1}
{"code": "static int nf_tables_set_alloc_name(struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t\t    const char *name)\n{\n\tconst struct nft_set *i;\n\tconst char *p;\n\tunsigned long *inuse;\n\tunsigned int n = 0, min = 0;\n\tp = strnchr(name, IFNAMSIZ, '%');\n\tif (p != NULL) {\n\t\tif (p[1] != 'd' || strchr(p + 2, '%'))\n\t\t\treturn -EINVAL;\n\t\tinuse = (unsigned long *)get_zeroed_page(GFP_KERNEL);\n\t\tif (inuse == NULL)\n\t\t\treturn -ENOMEM;\ncont:\n\t\tlist_for_each_entry(i, &ctx->table->sets, list) {\n\t\t\tint tmp;\n\t\t\tif (!sscanf(i->name, name, &tmp))\n\t\t\t\tcontinue;\n\t\t\tif (tmp < min || tmp >= min + BITS_PER_BYTE * PAGE_SIZE)\n\t\t\t\tcontinue;\n\t\t\tset_bit(tmp - min, inuse);\n\t\t}\n\t\tn = find_first_zero_bit(inuse, BITS_PER_BYTE * PAGE_SIZE);\n\t\tif (n >= BITS_PER_BYTE * PAGE_SIZE) {\n\t\t\tmin += BITS_PER_BYTE * PAGE_SIZE;\n\t\t\tmemset(inuse, 0, PAGE_SIZE);\n\t\t\tgoto cont;\n\t\t}\n\t\tfree_page((unsigned long)inuse);\n\t}\n\tsnprintf(set->name, sizeof(set->name), name, min + n);\n\tlist_for_each_entry(i, &ctx->table->sets, list) {\n\t\tif (!strcmp(set->name, i->name))\n\t\t\treturn -ENFILE;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": " void LayerWebKitThread::setNeedsCommit()\n {\n     if (m_owner)\n        m_owner->notifySyncRequired();\n }", "target": 1}
{"code": "void grubfs_free (GrubFS *gf) {\n\tif (gf) {\n\t\tif (gf->file && gf->file->device)\n\t\t\tfree (gf->file->device->disk);\n\t\tfree (gf->file);\n\t\tfree (gf);\n\t}\n}", "target": 1}
{"code": "static inline void map_to_unicode(unsigned code, const enc_to_uni *table, unsigned *res)\n{\n\t*res = table->inner[ENT_ENC_TO_UNI_STAGE1(code)]->uni_cp[ENT_ENC_TO_UNI_STAGE2(code)];\n}", "target": 0}
{"code": "static void *skcipher_bind(const char *name, u32 type, u32 mask)\n{\n\tstruct skcipher_tfm *tfm;\n\tstruct crypto_ablkcipher *skcipher;\n\ttfm = kzalloc(sizeof(*tfm), GFP_KERNEL);\n\tif (!tfm)\n\t\treturn ERR_PTR(-ENOMEM);\n\tskcipher = crypto_alloc_ablkcipher(name, type, mask);\n\tif (IS_ERR(skcipher)) {\n\t\tkfree(tfm);\n\t\treturn ERR_CAST(skcipher);\n\t}\n\ttfm->skcipher = skcipher;\n\treturn tfm;\n}", "target": 0}
{"code": "void bnx2x__init_func_obj(struct bnx2x *bp)\n{\n\tbnx2x_setup_dmae(bp);\n\tbnx2x_init_func_obj(bp, &bp->func_obj,\n\t\t\t    bnx2x_sp(bp, func_rdata),\n\t\t\t    bnx2x_sp_mapping(bp, func_rdata),\n\t\t\t    bnx2x_sp(bp, func_afex_rdata),\n\t\t\t    bnx2x_sp_mapping(bp, func_afex_rdata),\n\t\t\t    &bnx2x_func_sp_drv);\n}", "target": 0}
{"code": "static void fuse_lib_init(void *data, struct fuse_conn_info *conn)\n{\n    struct fuse *f = (struct fuse *) data;\n    struct fuse_context_i *c = fuse_get_context_internal();\n    memset(c, 0, sizeof(*c));\n    c->ctx.fuse = f;\n    fuse_fs_init(f->fs, conn);\n}", "target": 0}
{"code": "date_s__valid_nth_kday_p(int argc, VALUE *argv, VALUE klass)\n{\n    VALUE vy, vm, vn, vk, vsg;\n    VALUE argv2[5];\n    rb_scan_args(argc, argv, \"41\", &vy, &vm, &vn, &vk, &vsg);\n    argv2[0] = vy;\n    argv2[1] = vm;\n    argv2[2] = vn;\n    argv2[3] = vk;\n    if (argc < 5)\n\targv2[4] = DBL2NUM(GREGORIAN);\n    else\n\targv2[4] = vsg;\n    return valid_nth_kday_sub(5, argv2, klass, 1);\n}", "target": 0}
{"code": "int unlinkat_harder(int dfd, const char *filename, int unlink_flags, RemoveFlags remove_flags) {\n        mode_t old_mode;\n        int r;\n        if (unlinkat(dfd, filename, unlink_flags) >= 0)\n                return 0;\n        if (errno != EACCES || !FLAGS_SET(remove_flags, REMOVE_CHMOD))\n                return -errno;\n        r = patch_dirfd_mode(dfd, &old_mode);\n        if (r < 0)\n                return r;\n        if (unlinkat(dfd, filename, unlink_flags) < 0) {\n                r = -errno;\n                (void) fchmod(dfd, old_mode);\n                return r;\n        }\n        if (FLAGS_SET(remove_flags, REMOVE_CHMOD_RESTORE) && fchmod(dfd, old_mode) < 0)\n                return -errno;\n        return 0;\n}", "target": 1}
{"code": "static void update_open_stateflags(struct nfs4_state *state, mode_t open_flags)\n{\n\tswitch (open_flags) {\n\t\tcase FMODE_WRITE:\n\t\t\tstate->n_wronly++;\n\t\t\tbreak;\n\t\tcase FMODE_READ:\n\t\t\tstate->n_rdonly++;\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tstate->n_rdwr++;\n\t}\n\tnfs4_state_set_mode_locked(state, state->state | open_flags);\n}", "target": 1}
{"code": "static int __execlists_context_alloc(struct intel_context *ce,\n\t\t\t\t     struct intel_engine_cs *engine)\n{\n\tstruct drm_i915_gem_object *ctx_obj;\n\tstruct intel_ring *ring;\n\tstruct i915_vma *vma;\n\tu32 context_size;\n\tint ret;\n\tGEM_BUG_ON(ce->state);\n\tcontext_size = round_up(engine->context_size, I915_GTT_PAGE_SIZE);\n\tif (IS_ENABLED(CONFIG_DRM_I915_DEBUG_GEM))\n\t\tcontext_size += I915_GTT_PAGE_SIZE; \n\tctx_obj = i915_gem_object_create_shmem(engine->i915, context_size);\n\tif (IS_ERR(ctx_obj))\n\t\treturn PTR_ERR(ctx_obj);\n\tvma = i915_vma_instance(ctx_obj, &engine->gt->ggtt->vm, NULL);\n\tif (IS_ERR(vma)) {\n\t\tret = PTR_ERR(vma);\n\t\tgoto error_deref_obj;\n\t}\n\tif (!ce->timeline) {\n\t\tstruct intel_timeline *tl;\n\t\ttl = intel_timeline_create(engine->gt, NULL);\n\t\tif (IS_ERR(tl)) {\n\t\t\tret = PTR_ERR(tl);\n\t\t\tgoto error_deref_obj;\n\t\t}\n\t\tce->timeline = tl;\n\t}\n\tring = intel_engine_create_ring(engine, (unsigned long)ce->ring);\n\tif (IS_ERR(ring)) {\n\t\tret = PTR_ERR(ring);\n\t\tgoto error_deref_obj;\n\t}\n\tret = populate_lr_context(ce, ctx_obj, engine, ring);\n\tif (ret) {\n\t\tDRM_DEBUG_DRIVER(\"Failed to populate LRC: %d\\n\", ret);\n\t\tgoto error_ring_free;\n\t}\n\tce->ring = ring;\n\tce->state = vma;\n\treturn 0;\nerror_ring_free:\n\tintel_ring_put(ring);\nerror_deref_obj:\n\ti915_gem_object_put(ctx_obj);\n\treturn ret;\n}", "target": 0}
{"code": "nwfilterConnectNumOfNWFilters(virConnectPtr conn)\n{\n    if (virConnectNumOfNWFiltersEnsureACL(conn) < 0)\n        return -1;\n    return virNWFilterObjListNumOfNWFilters(driver->nwfilters, conn,\n                                        virConnectNumOfNWFiltersCheckACL);\n}", "target": 1}
{"code": "static int nfc_genl_llc_set_params(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tstruct nfc_llcp_local *local;\n\tu8 rw = 0;\n\tu16 miux = 0;\n\tu32 idx;\n\tint rc = 0;\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    (!info->attrs[NFC_ATTR_LLC_PARAM_LTO] &&\n\t     !info->attrs[NFC_ATTR_LLC_PARAM_RW] &&\n\t     !info->attrs[NFC_ATTR_LLC_PARAM_MIUX]))\n\t\treturn -EINVAL;\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_RW]) {\n\t\trw = nla_get_u8(info->attrs[NFC_ATTR_LLC_PARAM_RW]);\n\t\tif (rw > LLCP_MAX_RW)\n\t\t\treturn -EINVAL;\n\t}\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_MIUX]) {\n\t\tmiux = nla_get_u16(info->attrs[NFC_ATTR_LLC_PARAM_MIUX]);\n\t\tif (miux > LLCP_MAX_MIUX)\n\t\t\treturn -EINVAL;\n\t}\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\tdevice_lock(&dev->dev);\n\tlocal = nfc_llcp_find_local(dev);\n\tif (!local) {\n\t\trc = -ENODEV;\n\t\tgoto exit;\n\t}\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_LTO]) {\n\t\tif (dev->dep_link_up) {\n\t\t\trc = -EINPROGRESS;\n\t\t\tgoto exit;\n\t\t}\n\t\tlocal->lto = nla_get_u8(info->attrs[NFC_ATTR_LLC_PARAM_LTO]);\n\t}\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_RW])\n\t\tlocal->rw = rw;\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_MIUX])\n\t\tlocal->miux = cpu_to_be16(miux);\nexit:\n\tdevice_unlock(&dev->dev);\n\tnfc_put_device(dev);\n\treturn rc;\n}", "target": 1}
{"code": "void ACLosslessScan::ParseMCU(struct Line **prev,struct Line **top)\n{ \n#if ACCUSOFT_CODE\n  UBYTE c;\n  for(c = 0;c < m_ucCount;c++) {\n    struct QMContextSet &contextset = m_Context[m_ucContext[c]];\n    struct Line *line = top[c];\n    struct Line *pline= prev[c];\n    UBYTE ym = m_ucMCUHeight[c];\n    ULONG  x = m_ulX[c];\n    class PredictorBase *mcupred = m_pPredict[c];\n    LONG *lp = line->m_pData + x;\n    LONG *pp = (pline)?(pline->m_pData + x):(NULL);\n    do {\n      class PredictorBase *pred = mcupred;\n      UBYTE xm = m_ucMCUWidth[c];\n      do {\n        LONG v;\n        struct QMContextSet::ContextZeroSet &zset = contextset.ClassifySignZero(m_plDa[c][ym-1],m_plDb[c][x],\n                                                                                m_ucSmall[c],m_ucLarge[c]);\n        if (m_Coder.Get(zset.S0)) {\n          LONG sz   = 0;\n          bool sign = m_Coder.Get(zset.SS); \n          if (m_Coder.Get((sign)?(zset.SN):(zset.SP))) {\n            struct QMContextSet::MagnitudeSet &mset = contextset.ClassifyMagnitude(m_plDb[c][x],m_ucLarge[c]);\n            int  i = 0;\n            LONG m = 2;\n            while(m_Coder.Get(mset.X[i])) {\n              m <<= 1;\n              i++;\n            }\n            m >>= 1;\n            sz  = m;\n            while((m >>= 1)) {\n              if (m_Coder.Get(mset.M[i])) {\n                sz |= m;\n              }\n            }\n          }\n          if (sign) {\n            v = -sz - 1;\n          } else {\n            v =  sz + 1;\n          }\n        } else {\n          v = 0;\n        }\n        lp[0] = pred->DecodeSample(v,lp,pp);\n        m_plDb[c][x]    = v;\n        m_plDa[c][ym-1] = v;\n      } while(--xm && (lp++,pp++,x++,pred = pred->MoveRight(),true));\n    } while(--ym && (pp = line->m_pData + (x = m_ulX[c]),line = (line->m_pNext)?(line->m_pNext):(line),\n                     lp = line->m_pData + x,mcupred = mcupred->MoveDown(),true));\n  }\n#else\n  NOREF(prev);\n  NOREF(top);\n#endif\n}", "target": 1}
{"code": "void imap_munge_mbox_name(struct ImapData *idata, char *dest, size_t dlen, const char *src)\n{\n  char *buf = mutt_str_strdup(src);\n  imap_utf_encode(idata, &buf);\n  imap_quote_string(dest, dlen, buf);\n  FREE(&buf);\n}", "target": 1}
{"code": "static IHEVCD_ERROR_T ihevcd_parse_profile_tier_level_layer(bitstrm_t *ps_bitstrm,\n profile_tier_lvl_t *ps_ptl)\n{\n    WORD32 value;\n    WORD32 i;\n    IHEVCD_ERROR_T ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;\n    BITS_PARSE(\"XXX_profile_space[]\", value, ps_bitstrm, 2);\n    ps_ptl->i1_profile_space = value;\n    BITS_PARSE(\"XXX_tier_flag[]\", value, ps_bitstrm, 1);\n    ps_ptl->i1_tier_flag = value;\n    BITS_PARSE(\"XXX_profile_idc[]\", value, ps_bitstrm, 5);\n    ps_ptl->i1_profile_idc = value;\n for(i = 0; i < MAX_PROFILE_COMPATBLTY; i++)\n {\n        BITS_PARSE(\"XXX_profile_compatibility_flag[][j]\", value, ps_bitstrm, 1);\n        ps_ptl->ai1_profile_compatibility_flag[i] = value;\n }\n    BITS_PARSE(\"general_progressive_source_flag\", value, ps_bitstrm, 1);\n    ps_ptl->i1_general_progressive_source_flag = value;\n    BITS_PARSE(\"general_interlaced_source_flag\", value, ps_bitstrm, 1);\n    ps_ptl->i1_general_interlaced_source_flag = value;\n    BITS_PARSE(\"general_non_packed_constraint_flag\", value, ps_bitstrm, 1);\n    ps_ptl->i1_general_non_packed_constraint_flag = value;\n    BITS_PARSE(\"general_frame_only_constraint_flag\", value, ps_bitstrm, 1);\n    ps_ptl->i1_frame_only_constraint_flag = value;\n    BITS_PARSE(\"XXX_reserved_zero_44bits[0..15]\", value, ps_bitstrm, 16);\n    BITS_PARSE(\"XXX_reserved_zero_44bits[16..31]\", value, ps_bitstrm, 16);\n    BITS_PARSE(\"XXX_reserved_zero_44bits[32..43]\", value, ps_bitstrm, 12);\n return ret;\n}", "target": 0}
{"code": "test_function (char * (*my_asnprintf) (char *, size_t *, const char *, ...))\n{\n  char buf[8];\n  int size;\n  for (size = 0; size <= 8; size++)\n    {\n      size_t length = size;\n      char *result = my_asnprintf (NULL, &length, \"%d\", 12345);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"12345\") == 0);\n      ASSERT (length == 5);\n      free (result);\n    }\n  for (size = 0; size <= 8; size++)\n    {\n      size_t length;\n      char *result;\n      memcpy (buf, \"DEADBEEF\", 8);\n      length = size;\n      result = my_asnprintf (buf, &length, \"%d\", 12345);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"12345\") == 0);\n      ASSERT (length == 5);\n      if (size < 6)\n        ASSERT (result != buf);\n      ASSERT (memcmp (buf + size, &\"DEADBEEF\"[size], 8 - size) == 0);\n      if (result != buf)\n        free (result);\n    }\n}", "target": 1}
{"code": "static void blk_mq_exit_hw_queues(struct request_queue *q,\n\t\tstruct blk_mq_tag_set *set, int nr_queue)\n{\n\tstruct blk_mq_hw_ctx *hctx;\n\tunsigned int i;\n\tqueue_for_each_hw_ctx(q, hctx, i) {\n\t\tif (i == nr_queue)\n\t\t\tbreak;\n\t\tblk_mq_exit_hctx(q, set, hctx, i);\n\t}\n}", "target": 0}
{"code": "static void cmv_decode_intra(CmvContext * s, AVFrame *frame,\n                             const uint8_t *buf, const uint8_t *buf_end)\n{\n    unsigned char *dst = frame->data[0];\n    int i;\n    for (i=0; i < s->avctx->height && buf_end - buf >= s->avctx->width; i++) {\n        memcpy(dst, buf, s->avctx->width);\n        dst += frame->linesize[0];\n        buf += s->avctx->width;\n    }\n}", "target": 0}
{"code": "static bool kvm_vcpu_check_breakpoint(struct kvm_vcpu *vcpu, int *r)\n{\n\tif (unlikely(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) &&\n\t    (vcpu->arch.guest_debug_dr7 & DR7_BP_EN_MASK)) {\n\t\tstruct kvm_run *kvm_run = vcpu->run;\n\t\tunsigned long eip = kvm_get_linear_rip(vcpu);\n\t\tu32 dr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.guest_debug_dr7,\n\t\t\t\t\t   vcpu->arch.eff_db);\n\t\tif (dr6 != 0) {\n\t\t\tkvm_run->debug.arch.dr6 = dr6 | DR6_ACTIVE_LOW;\n\t\t\tkvm_run->debug.arch.pc = eip;\n\t\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\t\t*r = 0;\n\t\t\treturn true;\n\t\t}\n\t}\n\tif (unlikely(vcpu->arch.dr7 & DR7_BP_EN_MASK) &&\n\t    !(kvm_get_rflags(vcpu) & X86_EFLAGS_RF)) {\n\t\tunsigned long eip = kvm_get_linear_rip(vcpu);\n\t\tu32 dr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.dr7,\n\t\t\t\t\t   vcpu->arch.db);\n\t\tif (dr6 != 0) {\n\t\t\tkvm_queue_exception_p(vcpu, DB_VECTOR, dr6);\n\t\t\t*r = 1;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "target": 1}
{"code": "ProcQueryTree(ClientPtr client)\n{\n    xQueryTreeReply reply;\n    int rc, numChildren = 0;\n    WindowPtr pChild, pWin, pHead;\n    Window *childIDs = (Window *) NULL;\n    REQUEST(xResourceReq);\n    REQUEST_SIZE_MATCH(xResourceReq);\n    rc = dixLookupWindow(&pWin, stuff->id, client, DixListAccess);\n    if (rc != Success)\n        return rc;\n    reply = (xQueryTreeReply) {\n        .type = X_Reply,\n        .sequenceNumber = client->sequence,\n        .root = pWin->drawable.pScreen->root->drawable.id,\n        .parent = (pWin->parent) ? pWin->parent->drawable.id : (Window) None\n    };\n    pHead = RealChildHead(pWin);\n    for (pChild = pWin->lastChild; pChild != pHead; pChild = pChild->prevSib)\n        numChildren++;\n    if (numChildren) {\n        int curChild = 0;\n        childIDs = malloc(numChildren * sizeof(Window));\n        if (!childIDs)\n            return BadAlloc;\n        for (pChild = pWin->lastChild; pChild != pHead;\n             pChild = pChild->prevSib)\n            childIDs[curChild++] = pChild->drawable.id;\n    }\n    reply.nChildren = numChildren;\n    reply.length = bytes_to_int32(numChildren * sizeof(Window));\n    WriteReplyToClient(client, sizeof(xQueryTreeReply), &reply);\n    if (numChildren) {\n        client->pSwapReplyFunc = (ReplySwapPtr) Swap32Write;\n        WriteSwappedDataToClient(client, numChildren * sizeof(Window),\n                                 childIDs);\n        free(childIDs);\n    }\n    return Success;\n}", "target": 0}
{"code": "static inline int init_new_context(struct task_struct *tsk,\n\t\t\t\t   struct mm_struct *mm)\n{\n\tcpumask_clear(&mm->context.cpu_attach_mask);\n\tatomic_set(&mm->context.attach_count, 0);\n\tmm->context.flush_mm = 0;\n\tmm->context.asce_bits = _ASCE_TABLE_LENGTH | _ASCE_USER_BITS;\n\tmm->context.asce_bits |= _ASCE_TYPE_REGION3;\n#ifdef CONFIG_PGSTE\n\tmm->context.alloc_pgste = page_table_allocate_pgste;\n\tmm->context.has_pgste = 0;\n\tmm->context.use_skey = 0;\n#endif\n\tmm->context.asce_limit = STACK_TOP_MAX;\n\tcrst_table_init((unsigned long *) mm->pgd, pgd_entry_type(mm));\n\treturn 0;\n}", "target": 1}
{"code": "static int mxf_uid_to_str(UID uid, char **str)\n{\n    int i;\n    char *p;\n    p = *str = av_mallocz(sizeof(UID) * 2 + 4 + 1);\n    if (!p)\n        return AVERROR(ENOMEM);\n    for (i = 0; i < sizeof(UID); i++) {\n        snprintf(p, 2 + 1, \"%.2x\", uid[i]);\n        p += 2;\n        if (i == 3 || i == 5 || i == 7 || i == 9) {\n            snprintf(p, 1 + 1, \"-\");\n            p++;\n        }\n    }\n    return 0;\n}", "target": 0}
{"code": "digest_hex(unsigned char *p)\n{\n    char *h = \"0123456789abcdef\";\n    Str tmp = Strnew_size(MD5_DIGEST_LENGTH * 2 + 1);\n    int i;\n    for (i = 0; i < MD5_DIGEST_LENGTH; i++, p++) {\n\tStrcat_char(tmp, h[(*p >> 4) & 0x0f]);\n\tStrcat_char(tmp, h[*p & 0x0f]);\n    }\n    return tmp;\n}", "target": 0}
{"code": "static handler_t mod_wstunnel_check_extension(request_st * const r, void *p_d) {\n    plugin_data *p = p_d;\n    handler_t rc;\n    if (NULL != r->handler_module)\n        return HANDLER_GO_ON;\n  if (r->http_version > HTTP_VERSION_1_1) {\n    if (!r->h2_connect_ext)\n        return HANDLER_GO_ON;\n  }\n  else {\n    if (r->http_method != HTTP_METHOD_GET)\n        return HANDLER_GO_ON;\n    if (r->http_version != HTTP_VERSION_1_1)\n        return HANDLER_GO_ON;\n    const buffer *vb;\n    vb = http_header_request_get(r, HTTP_HEADER_UPGRADE, CONST_STR_LEN(\"Upgrade\"));\n    if (NULL == vb\n        || !http_header_str_contains_token(BUF_PTR_LEN(vb), CONST_STR_LEN(\"websocket\")))\n        return HANDLER_GO_ON;\n    vb = http_header_request_get(r, HTTP_HEADER_CONNECTION, CONST_STR_LEN(\"Connection\"));\n    if (NULL == vb\n        || !http_header_str_contains_token(BUF_PTR_LEN(vb), CONST_STR_LEN(\"upgrade\")))\n        return HANDLER_GO_ON;\n  }\n    mod_wstunnel_patch_config(r, p);\n    if (NULL == p->conf.gw.exts) return HANDLER_GO_ON;\n    rc = gw_check_extension(r, (gw_plugin_data *)p, 1, sizeof(handler_ctx));\n    return (HANDLER_GO_ON == rc && r->handler_module == p->self)\n      ? wstunnel_handler_setup(r, p)\n      : rc;\n}", "target": 0}
{"code": "static inline struct old_rng_alg *crypto_old_rng_alg(struct crypto_rng *tfm)\n{\n\treturn &crypto_rng_tfm(tfm)->__crt_alg->cra_rng;\n}", "target": 1}
{"code": "static inline int quic_token_validate(struct quic_rx_packet *pkt,\n                                      struct quic_dgram *dgram,\n                                      struct listener *l, struct quic_conn *qc,\n                                      struct quic_cid *odcid)\n{\n\tint ret = 0;\n\tTRACE_ENTER(QUIC_EV_CONN_LPKT, qc);\n\tswitch (*pkt->token) {\n\tcase QUIC_TOKEN_FMT_RETRY:\n\t\tret = quic_retry_token_check(pkt, dgram, l, qc, odcid);\n\t\tbreak;\n\tcase QUIC_TOKEN_FMT_NEW:\n\t\tret = quic_token_check(pkt, dgram, qc);\n\t\tif (!ret) {\n\t\t\tdgram->flags |= QUIC_DGRAM_FL_SEND_RETRY;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tTRACE_PROTO(\"Packet dropped\", QUIC_EV_CONN_LPKT, qc, NULL, NULL, pkt->version);\n\t\tbreak;\n\t}\n\tif (!ret)\n\t\tgoto err;\n\tret = 1;\n leave:\n\tTRACE_LEAVE(QUIC_EV_CONN_LPKT, qc);\n\treturn ret;\n err:\n\tTRACE_DEVEL(\"leaving in error\", QUIC_EV_CONN_LPKT, qc);\n\tgoto leave;\n}", "target": 0}
{"code": "static int unlock_full_stripe(struct btrfs_fs_info *fs_info, u64 bytenr,\n\t\t\t      bool locked)\n{\n\tstruct btrfs_block_group_cache *bg_cache;\n\tstruct btrfs_full_stripe_locks_tree *locks_root;\n\tstruct full_stripe_lock *fstripe_lock;\n\tu64 fstripe_start;\n\tbool freeit = false;\n\tint ret = 0;\n\tif (!locked)\n\t\treturn 0;\n\tbg_cache = btrfs_lookup_block_group(fs_info, bytenr);\n\tif (!bg_cache) {\n\t\tASSERT(0);\n\t\treturn -ENOENT;\n\t}\n\tif (!(bg_cache->flags & BTRFS_BLOCK_GROUP_RAID56_MASK))\n\t\tgoto out;\n\tlocks_root = &bg_cache->full_stripe_locks_root;\n\tfstripe_start = get_full_stripe_logical(bg_cache, bytenr);\n\tmutex_lock(&locks_root->lock);\n\tfstripe_lock = search_full_stripe_lock(locks_root, fstripe_start);\n\tif (!fstripe_lock) {\n\t\tWARN_ON(1);\n\t\tret = -ENOENT;\n\t\tmutex_unlock(&locks_root->lock);\n\t\tgoto out;\n\t}\n\tif (fstripe_lock->refs == 0) {\n\t\tWARN_ON(1);\n\t\tbtrfs_warn(fs_info, \"full stripe lock at %llu refcount underflow\",\n\t\t\tfstripe_lock->logical);\n\t} else {\n\t\tfstripe_lock->refs--;\n\t}\n\tif (fstripe_lock->refs == 0) {\n\t\trb_erase(&fstripe_lock->node, &locks_root->root);\n\t\tfreeit = true;\n\t}\n\tmutex_unlock(&locks_root->lock);\n\tmutex_unlock(&fstripe_lock->mutex);\n\tif (freeit)\n\t\tkfree(fstripe_lock);\nout:\n\tbtrfs_put_block_group(bg_cache);\n\treturn ret;\n}", "target": 0}
{"code": "static int do_devinfo_ioctl(struct comedi_device *dev,\n\t\t\t    struct comedi_devinfo __user *arg,\n\t\t\t    struct file *file)\n{\n\tstruct comedi_devinfo devinfo;\n\tconst unsigned minor = iminor(file->f_dentry->d_inode);\n\tstruct comedi_device_file_info *dev_file_info =\n\t    comedi_get_device_file_info(minor);\n\tstruct comedi_subdevice *read_subdev =\n\t    comedi_get_read_subdevice(dev_file_info);\n\tstruct comedi_subdevice *write_subdev =\n\t    comedi_get_write_subdevice(dev_file_info);\n\tmemset(&devinfo, 0, sizeof(devinfo));\n\tdevinfo.version_code = COMEDI_VERSION_CODE;\n\tdevinfo.n_subdevs = dev->n_subdevices;\n\tmemcpy(devinfo.driver_name, dev->driver->driver_name, COMEDI_NAMELEN);\n\tmemcpy(devinfo.board_name, dev->board_name, COMEDI_NAMELEN);\n\tif (read_subdev)\n\t\tdevinfo.read_subdevice = read_subdev - dev->subdevices;\n\telse\n\t\tdevinfo.read_subdevice = -1;\n\tif (write_subdev)\n\t\tdevinfo.write_subdevice = write_subdev - dev->subdevices;\n\telse\n\t\tdevinfo.write_subdevice = -1;\n\tif (copy_to_user(arg, &devinfo, sizeof(struct comedi_devinfo)))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1}
{"code": "int vfs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tint error = may_delete(dir, dentry, 0);\n\tif (error)\n\t\treturn error;\n\tif (!dir->i_op->unlink)\n\t\treturn -EPERM;\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\tif (d_mountpoint(dentry))\n\t\terror = -EBUSY;\n\telse {\n\t\terror = security_inode_unlink(dir, dentry);\n\t\tif (!error) {\n\t\t\terror = dir->i_op->unlink(dir, dentry);\n\t\t\tif (!error)\n\t\t\t\tdont_mount(dentry);\n\t\t}\n\t}\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\tif (!error && !(dentry->d_flags & DCACHE_NFSFS_RENAMED)) {\n\t\tfsnotify_link_count(dentry->d_inode);\n\t\td_delete(dentry);\n\t}\n\treturn error;\n}", "target": 0}
{"code": "eval0_retarg(\n    char_u\t*arg,\n    typval_T\t*rettv,\n    exarg_T\t*eap,\n    evalarg_T\t*evalarg,\n    char_u\t**retarg)\n{\n    int\t\tret;\n    char_u\t*p;\n    char_u\t*expr_end;\n    int\t\tdid_emsg_before = did_emsg;\n    int\t\tcalled_emsg_before = called_emsg;\n    int\t\tflags = evalarg == NULL ? 0 : evalarg->eval_flags;\n    int\t\tcheck_for_end = retarg == NULL;\n    int\t\tend_error = FALSE;\n    p = skipwhite(arg);\n    ret = eval1(&p, rettv, evalarg);\n    expr_end = p;\n    p = skipwhite(p);\n    if (in_vim9script() && p > expr_end && retarg == NULL)\n\twhile (*p == '#')\n\t{\n\t    char_u *nl = vim_strchr(p, NL);\n\t    if (nl == NULL)\n\t\tbreak;\n\t    p = skipwhite(nl + 1);\n\t    if (eap != NULL && *p != NUL)\n\t\teap->nextcmd = p;\n\t    check_for_end = FALSE;\n\t}\n    if (ret != FAIL && check_for_end)\n\tend_error = !ends_excmd2(arg, p);\n    if (ret == FAIL || end_error)\n    {\n\tif (ret != FAIL)\n\t    clear_tv(rettv);\n\tif (!aborting()\n\t\t&& did_emsg == did_emsg_before\n\t\t&& called_emsg == called_emsg_before\n\t\t&& (flags & EVAL_CONSTANT) == 0\n\t\t&& (!in_vim9script() || !vim9_bad_comment(p)))\n\t{\n\t    if (end_error)\n\t\tsemsg(_(e_trailing_characters_str), p);\n\t    else\n\t\tsemsg(_(e_invalid_expression_str), arg);\n\t}\n\tif (eap != NULL && skipwhite(p)[0] == '|' && skipwhite(p)[1] != '|')\n\t    eap->nextcmd = check_nextcmd(p);\n\treturn FAIL;\n    }\n    if (retarg != NULL)\n\t*retarg = p;\n    else if (check_for_end && eap != NULL)\n\tset_nextcmd(eap, p);\n    return ret;\n}", "target": 1}
{"code": "GF_Err ohdr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu16 cid_len, ri_len;\n\tGF_OMADRMCommonHeaderBox *ptr = (GF_OMADRMCommonHeaderBox*)s;\n\tISOM_DECREASE_SIZE(ptr, (1+1+8+2+2+2) );\n\tptr->EncryptionMethod = gf_bs_read_u8(bs);\n\tptr->PaddingScheme = gf_bs_read_u8(bs);\n\tptr->PlaintextLength = gf_bs_read_u64(bs);\n\tcid_len = gf_bs_read_u16(bs);\n\tri_len = gf_bs_read_u16(bs);\n\tptr->TextualHeadersLen = gf_bs_read_u16(bs);\n\tif (ptr->size<cid_len+ri_len+ptr->TextualHeadersLen) return GF_ISOM_INVALID_FILE;\n\tif (cid_len) {\n\t\tptr->ContentID = (char *)gf_malloc(sizeof(char)*(cid_len+1));\n\t\tif (!ptr->ContentID) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->ContentID, cid_len);\n\t\tptr->ContentID[cid_len]=0;\n\t}\n\tif (ri_len) {\n\t\tptr->RightsIssuerURL = (char *)gf_malloc(sizeof(char)*(ri_len+1));\n\t\tif (!ptr->RightsIssuerURL) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->RightsIssuerURL, ri_len);\n\t\tptr->RightsIssuerURL[ri_len]=0;\n\t}\n\tif (ptr->TextualHeadersLen) {\n\t\tptr->TextualHeaders = (char *)gf_malloc(sizeof(char)*(ptr->TextualHeadersLen+1));\n\t\tif (!ptr->TextualHeaders) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->TextualHeaders, ptr->TextualHeadersLen);\n\t\tptr->TextualHeaders[ptr->TextualHeadersLen] = 0;\n\t}\n\tISOM_DECREASE_SIZE(ptr, (cid_len+ri_len+ptr->TextualHeadersLen) );\n\treturn gf_isom_box_array_read(s, bs);\n}", "target": 0}
{"code": "static int llc_ui_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t     char __user *optval, int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tint rc = -EINVAL, opt;\n\tlock_sock(sk);\n\tif (unlikely(level != SOL_LLC || optlen != sizeof(int)))\n\t\tgoto out;\n\trc = get_user(opt, (int __user *)optval);\n\tif (rc)\n\t\tgoto out;\n\trc = -EINVAL;\n\tswitch (optname) {\n\tcase LLC_OPT_RETRY:\n\t\tif (opt > LLC_OPT_MAX_RETRY)\n\t\t\tgoto out;\n\t\tllc->n2 = opt;\n\t\tbreak;\n\tcase LLC_OPT_SIZE:\n\t\tif (opt > LLC_OPT_MAX_SIZE)\n\t\t\tgoto out;\n\t\tllc->n1 = opt;\n\t\tbreak;\n\tcase LLC_OPT_ACK_TMR_EXP:\n\t\tif (opt > LLC_OPT_MAX_ACK_TMR_EXP)\n\t\t\tgoto out;\n\t\tllc->ack_timer.expire = opt * HZ;\n\t\tbreak;\n\tcase LLC_OPT_P_TMR_EXP:\n\t\tif (opt > LLC_OPT_MAX_P_TMR_EXP)\n\t\t\tgoto out;\n\t\tllc->pf_cycle_timer.expire = opt * HZ;\n\t\tbreak;\n\tcase LLC_OPT_REJ_TMR_EXP:\n\t\tif (opt > LLC_OPT_MAX_REJ_TMR_EXP)\n\t\t\tgoto out;\n\t\tllc->rej_sent_timer.expire = opt * HZ;\n\t\tbreak;\n\tcase LLC_OPT_BUSY_TMR_EXP:\n\t\tif (opt > LLC_OPT_MAX_BUSY_TMR_EXP)\n\t\t\tgoto out;\n\t\tllc->busy_state_timer.expire = opt * HZ;\n\t\tbreak;\n\tcase LLC_OPT_TX_WIN:\n\t\tif (opt > LLC_OPT_MAX_WIN)\n\t\t\tgoto out;\n\t\tllc->k = opt;\n\t\tbreak;\n\tcase LLC_OPT_RX_WIN:\n\t\tif (opt > LLC_OPT_MAX_WIN)\n\t\t\tgoto out;\n\t\tllc->rw = opt;\n\t\tbreak;\n\tdefault:\n\t\trc = -ENOPROTOOPT;\n\t\tgoto out;\n\t}\n\trc = 0;\nout:\n\trelease_sock(sk);\n\treturn rc;\n}", "target": 0}
{"code": "static void xfrm6_tunnel_spi_fini(void)\n{\n\tkmem_cache_destroy(xfrm6_tunnel_spi_kmem);\n}", "target": 1}
{"code": "static void getPixelColorRGBA16(unsigned short* r, unsigned short* g, unsigned short* b, unsigned short* a,\n                                const unsigned char* in, size_t i, const LodePNGColorMode* mode)\n{\n  if(mode->colortype == LCT_GREY)\n  {\n    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];\n    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;\n    else *a = 65535;\n  }\n  else if(mode->colortype == LCT_RGB)\n  {\n    *r = 256 * in[i * 6 + 0] + in[i * 6 + 1];\n    *g = 256 * in[i * 6 + 2] + in[i * 6 + 3];\n    *b = 256 * in[i * 6 + 4] + in[i * 6 + 5];\n    if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r\n       && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g\n       && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;\n    else *a = 65535;\n  }\n  else if(mode->colortype == LCT_GREY_ALPHA)\n  {\n    *r = *g = *b = 256 * in[i * 4 + 0] + in[i * 4 + 1];\n    *a = 256 * in[i * 4 + 2] + in[i * 4 + 3];\n  }\n  else if(mode->colortype == LCT_RGBA)\n  {\n    *r = 256 * in[i * 8 + 0] + in[i * 8 + 1];\n    *g = 256 * in[i * 8 + 2] + in[i * 8 + 3];\n    *b = 256 * in[i * 8 + 4] + in[i * 8 + 5];\n    *a = 256 * in[i * 8 + 6] + in[i * 8 + 7];\n  }\n}", "target": 0}
{"code": "bool SPIFFEValidator::matchSubjectAltName(X509& leaf_cert) {\n  bssl::UniquePtr<GENERAL_NAMES> san_names(static_cast<GENERAL_NAMES*>(\n      X509_get_ext_d2i(&leaf_cert, NID_subject_alt_name, nullptr, nullptr)));\n  ASSERT(san_names != nullptr,\n         \"san_names should have at least one name after SPIFFE cert validation\");\n  for (const GENERAL_NAME* general_name : san_names.get()) {\n    if (general_name->type == GEN_URI) {\n      const std::string san = Utility::generalNameAsString(general_name);\n      for (const auto& config_san_matcher : subject_alt_name_matchers_) {\n        if (config_san_matcher.match(san)) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}", "target": 1}
{"code": "allocateCharacterClasses ()\n{\n  int k = 0;\n  characterClasses = NULL;\n  characterClassAttribute = 1;\n  while (characterClassNames[k])\n    {\n      widechar wname[MAXSTRING];\n      int length = strlen (characterClassNames[k]);\n      int kk;\n      for (kk = 0; kk < length; kk++)\n\twname[kk] = (widechar) characterClassNames[k][kk];\n      if (!addCharacterClass (NULL, wname, length))\n\t{\n\t  deallocateCharacterClasses ();\n\t  return 0;\n\t}\n      k++;\n    }\n  return 1;\n}", "target": 0}
{"code": "IW_IMPL(unsigned int) iw_get_ui16be(const iw_byte *b)\n{\n\treturn (b[0]<<8) | b[1];\n}", "target": 1}
{"code": "static __init int efivar_ssdt_load(void)\n{\n\tLIST_HEAD(entries);\n\tstruct efivar_entry *entry, *aux;\n\tunsigned long size;\n\tvoid *data;\n\tint ret;\n\tret = efivar_init(efivar_ssdt_iter, &entries, true, &entries);\n\tlist_for_each_entry_safe(entry, aux, &entries, list) {\n\t\tpr_info(\"loading SSDT from variable %s-%pUl\\n\", efivar_ssdt,\n\t\t\t&entry->var.VendorGuid);\n\t\tlist_del(&entry->list);\n\t\tret = efivar_entry_size(entry, &size);\n\t\tif (ret) {\n\t\t\tpr_err(\"failed to get var size\\n\");\n\t\t\tgoto free_entry;\n\t\t}\n\t\tdata = kmalloc(size, GFP_KERNEL);\n\t\tif (!data) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_entry;\n\t\t}\n\t\tret = efivar_entry_get(entry, NULL, &size, data);\n\t\tif (ret) {\n\t\t\tpr_err(\"failed to get var data\\n\");\n\t\t\tgoto free_data;\n\t\t}\n\t\tret = acpi_load_table(data);\n\t\tif (ret) {\n\t\t\tpr_err(\"failed to load table: %d\\n\", ret);\n\t\t\tgoto free_data;\n\t\t}\n\t\tgoto free_entry;\nfree_data:\n\t\tkfree(data);\nfree_entry:\n\t\tkfree(entry);\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "static bool tailmatch(const char *little, const char *bigone)\n{\n  size_t littlelen = strlen(little);\n  size_t biglen = strlen(bigone);\n  if(littlelen > biglen)\n    return FALSE;\n  return Curl_raw_equal(little, bigone+biglen-littlelen) ? TRUE : FALSE;\n}", "target": 1}
{"code": "void ntlm_write_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (fields->MaxLen < 1)\n\t\tfields->MaxLen = fields->Len;\n\tStream_Write_UINT16(s, fields->Len); \n\tStream_Write_UINT16(s, fields->MaxLen); \n\tStream_Write_UINT32(s, fields->BufferOffset); \n}", "target": 1}
{"code": "int __pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address)\n{\n\tpmd_t *new = pmd_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\tsmp_wmb(); \n\tspin_lock(&mm->page_table_lock);\n#ifndef __ARCH_HAS_4LEVEL_HACK\n\tif (pud_present(*pud))\t\t\n\t\tpmd_free(mm, new);\n\telse\n\t\tpud_populate(mm, pud, new);\n#else\n\tif (pgd_present(*pud))\t\t\n\t\tpmd_free(mm, new);\n\telse\n\t\tpgd_populate(mm, pud, new);\n#endif \n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}", "target": 0}
{"code": "static void ndpi_reset_packet_line_info(struct ndpi_packet_struct *packet) {\n  packet->parsed_lines = 0, packet->empty_line_position_set = 0, packet->host_line.ptr = NULL,\n    packet->host_line.len = 0, packet->referer_line.ptr = NULL, packet->referer_line.len = 0,\n    packet->content_line.ptr = NULL, packet->content_line.len = 0, packet->accept_line.ptr = NULL,\n    packet->accept_line.len = 0, packet->user_agent_line.ptr = NULL, packet->user_agent_line.len = 0,\n    packet->http_url_name.ptr = NULL, packet->http_url_name.len = 0, packet->http_encoding.ptr = NULL,\n    packet->http_encoding.len = 0, packet->http_transfer_encoding.ptr = NULL, packet->http_transfer_encoding.len = 0,\n    packet->http_contentlen.ptr = NULL, packet->http_contentlen.len = 0, packet->http_cookie.ptr = NULL,\n    packet->http_cookie.len = 0, packet->http_origin.len = 0, packet->http_origin.ptr = NULL,\n    packet->http_x_session_type.ptr = NULL, packet->http_x_session_type.len = 0, packet->server_line.ptr = NULL,\n    packet->server_line.len = 0, packet->http_method.ptr = NULL, packet->http_method.len = 0,\n    packet->http_response.ptr = NULL, packet->http_response.len = 0, packet->http_num_headers = 0;\n}", "target": 1}
{"code": "static int neigh_fill_info(struct sk_buff *skb, struct neighbour *n,\n\t\t\t   u32 pid, u32 seq, int event, unsigned int flags)\n{\n\tunsigned long now = jiffies;\n\tunsigned char *b = skb->tail;\n\tstruct nda_cacheinfo ci;\n\tint locked = 0;\n\tu32 probes;\n\tstruct nlmsghdr *nlh = NLMSG_NEW(skb, pid, seq, event,\n\t\t\t\t\t sizeof(struct ndmsg), flags);\n\tstruct ndmsg *ndm = NLMSG_DATA(nlh);\n\tndm->ndm_family\t = n->ops->family;\n\tndm->ndm_flags\t = n->flags;\n\tndm->ndm_type\t = n->type;\n\tndm->ndm_ifindex = n->dev->ifindex;\n\tRTA_PUT(skb, NDA_DST, n->tbl->key_len, n->primary_key);\n\tread_lock_bh(&n->lock);\n\tlocked\t\t = 1;\n\tndm->ndm_state\t = n->nud_state;\n\tif (n->nud_state & NUD_VALID)\n\t\tRTA_PUT(skb, NDA_LLADDR, n->dev->addr_len, n->ha);\n\tci.ndm_used\t = now - n->used;\n\tci.ndm_confirmed = now - n->confirmed;\n\tci.ndm_updated\t = now - n->updated;\n\tci.ndm_refcnt\t = atomic_read(&n->refcnt) - 1;\n\tprobes = atomic_read(&n->probes);\n\tread_unlock_bh(&n->lock);\n\tlocked\t\t = 0;\n\tRTA_PUT(skb, NDA_CACHEINFO, sizeof(ci), &ci);\n\tRTA_PUT(skb, NDA_PROBES, sizeof(probes), &probes);\n\tnlh->nlmsg_len\t = skb->tail - b;\n\treturn skb->len;\nnlmsg_failure:\nrtattr_failure:\n\tif (locked)\n\t\tread_unlock_bh(&n->lock);\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}", "target": 1}
{"code": "static int ext4_iomap_end(struct inode *inode, loff_t offset, loff_t length,\n\t\t\t  ssize_t written, unsigned flags, struct iomap *iomap)\n{\n\tint ret = 0;\n\thandle_t *handle;\n\tint blkbits = inode->i_blkbits;\n\tbool truncate = false;\n\tif (!(flags & IOMAP_WRITE) || (flags & IOMAP_FAULT))\n\t\treturn 0;\n\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 2);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto orphan_del;\n\t}\n\tif (ext4_update_inode_size(inode, offset + written))\n\t\text4_mark_inode_dirty(handle, inode);\n\tif (iomap->offset + iomap->length > \n\t    ALIGN(inode->i_size, 1 << blkbits)) {\n\t\text4_lblk_t written_blk, end_blk;\n\t\twritten_blk = (offset + written) >> blkbits;\n\t\tend_blk = (offset + length) >> blkbits;\n\t\tif (written_blk < end_blk && ext4_can_truncate(inode))\n\t\t\ttruncate = true;\n\t}\n\tif (!truncate && inode->i_nlink &&\n\t    !list_empty(&EXT4_I(inode)->i_orphan))\n\t\text4_orphan_del(handle, inode);\n\text4_journal_stop(handle);\n\tif (truncate) {\n\t\text4_truncate_failed_write(inode);\norphan_del:\n\t\tif (inode->i_nlink)\n\t\t\text4_orphan_del(NULL, inode);\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "static int nf_tables_table_notify(const struct nft_ctx *ctx, int event)\n{\n\tstruct sk_buff *skb;\n\tint err;\n\tif (!ctx->report &&\n\t    !nfnetlink_has_listeners(ctx->net, NFNLGRP_NFTABLES))\n\t\treturn 0;\n\terr = -ENOBUFS;\n\tskb = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (skb == NULL)\n\t\tgoto err;\n\terr = nf_tables_fill_table_info(skb, ctx->net, ctx->portid, ctx->seq,\n\t\t\t\t\tevent, 0, ctx->afi->family, ctx->table);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto err;\n\t}\n\terr = nfnetlink_send(skb, ctx->net, ctx->portid, NFNLGRP_NFTABLES,\n\t\t\t     ctx->report, GFP_KERNEL);\nerr:\n\tif (err < 0) {\n\t\tnfnetlink_set_err(ctx->net, ctx->portid, NFNLGRP_NFTABLES,\n\t\t\t\t  err);\n\t}\n\treturn err;\n}", "target": 0}
{"code": "asmlinkage long compat_sys_epoll_pwait(int epfd,\n\t\t\tstruct compat_epoll_event __user *events,\n\t\t\tint maxevents, int timeout,\n\t\t\tconst compat_sigset_t __user *sigmask,\n\t\t\tcompat_size_t sigsetsize)\n{\n\tlong err;\n\tcompat_sigset_t csigmask;\n\tsigset_t ksigmask, sigsaved;\n\tif (sigmask) {\n\t\tif (sigsetsize != sizeof(compat_sigset_t))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&csigmask, sigmask, sizeof(csigmask)))\n\t\t\treturn -EFAULT;\n\t\tsigset_from_compat(&ksigmask, &csigmask);\n\t\tsigdelsetmask(&ksigmask, sigmask(SIGKILL) | sigmask(SIGSTOP));\n\t\tsigprocmask(SIG_SETMASK, &ksigmask, &sigsaved);\n\t}\n#ifdef CONFIG_HAS_COMPAT_EPOLL_EVENT\n\terr = compat_sys_epoll_wait(epfd, events, maxevents, timeout);\n#else\n\terr = sys_epoll_wait(epfd, events, maxevents, timeout);\n#endif\n\tif (sigmask) {\n\t\tif (err == -EINTR) {\n\t\t\tmemcpy(&current->saved_sigmask, &sigsaved,\n\t\t\t       sizeof(sigsaved));\n\t\t\tset_thread_flag(TIF_RESTORE_SIGMASK);\n\t\t} else\n\t\t\tsigprocmask(SIG_SETMASK, &sigsaved, NULL);\n\t}\n\treturn err;\n}", "target": 0}
{"code": "static void free_segment_list(struct playlist *pls)\n{\n    int i;\n    for (i = 0; i < pls->n_segments; i++) {\n        av_free(pls->segments[i]->key);\n        av_free(pls->segments[i]->url);\n        av_free(pls->segments[i]);\n    }\n    av_freep(&pls->segments);\n    pls->n_segments = 0;\n}", "target": 0}
{"code": "bool DependencyOptimizer::SafeToRemoveIdentity(const NodeDef& node) const {\n  if (!IsIdentity(node) && !IsIdentityN(node)) {\n    return true;\n  }\n  if (nodes_to_preserve_.find(node.name()) != nodes_to_preserve_.end()) {\n    return false;\n  }\n  if (!fetch_nodes_known_) {\n    return false;\n  }\n  if (node.input_size() < 1) {\n    return false;\n  }\n  const NodeDef* input = node_map_->GetNode(NodeName(node.input(0)));\n  if (input == nullptr) {\n    VLOG(1) << \"node = \" << node.name() << \" input = \" << node.input(0);\n    return false;\n  }\n  if (IsVariable(*input) || IsRecv(*input)) {\n    return false;\n  }\n  for (const auto& consumer : node_map_->GetOutputs(node.name())) {\n    if (node.input_size() > 1 && (IsRetval(*consumer) || IsMerge(*consumer))) {\n      return false;\n    }\n    if (IsSwitch(*input)) {\n      for (const string& consumer_input : consumer->input()) {\n        if (consumer_input == AsControlDependency(node.name())) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}", "target": 0}
{"code": "static void ax25_kill_by_device(struct net_device *dev)\n{\n\tax25_dev *ax25_dev;\n\tax25_cb *s;\n\tstruct sock *sk;\n\tif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\n\t\treturn;\n\tspin_lock_bh(&ax25_list_lock);\nagain:\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->ax25_dev == ax25_dev) {\n\t\t\tsk = s->sk;\n\t\t\tsock_hold(sk);\n\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\tlock_sock(sk);\n\t\t\ts->ax25_dev = NULL;\n\t\t\tax25_dev_put(ax25_dev);\n\t\t\trelease_sock(sk);\n\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\tspin_lock_bh(&ax25_list_lock);\n\t\t\tsock_put(sk);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock_bh(&ax25_list_lock);\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& filter = context->input(1);\n    const TensorShape& filter_shape = filter.shape();\n    const Tensor& out_backprop = context->input(2);\n    const TensorShape& out_backprop_shape = out_backprop.shape();\n    TensorShape input_shape;\n    if (takes_shape_) {\n      const Tensor& input_sizes = context->input(0);\n      OP_REQUIRES_OK(context, tensor::MakeShape(input_sizes, &input_shape));\n    } else {\n      input_shape = context->input(0).shape();\n    }\n    OP_REQUIRES(\n        context, input_shape.dim_size(4) == filter_shape.dim_size(3),\n        errors::InvalidArgument(\"input and filter_sizes must have the same \"\n                                \"number of channels. Got \",\n                                input_shape.dim_size(4), \" for input and \",\n                                filter_shape.dim_size(3), \" for filter_sizes\"));\n    OP_REQUIRES(\n        context, out_backprop_shape.dim_size(4) == filter_shape.dim_size(4),\n        errors::InvalidArgument(\"out_backprop and filter_sizes must have the \"\n                                \"same number of channels. Got \",\n                                out_backprop_shape.dim_size(4),\n                                \" for out_backprop and \",\n                                filter_shape.dim_size(4), \" for filter_sizes\"));\n    ConvBackpropDimensions dims;\n    OP_REQUIRES_OK(context, ConvBackpropComputeDimensions(\n                                \"Conv3DBackpropInputOp\", 3,\n                                input_shape, filter_shape, out_backprop_shape,\n                                stride_, padding_, data_format_, &dims));\n    Tensor* in_backprop;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input_shape, &in_backprop));\n    functor::CuboidConvolutionBackwardInput<Device, T>()(\n        context->eigen_device<Device>(),\n        in_backprop->tensor<T, 5>(),                     \n        filter.tensor<T, 5>(),                           \n        out_backprop.tensor<T, 5>(),                     \n        static_cast<int>(dims.spatial_dims[0].stride),   \n        static_cast<int>(dims.spatial_dims[1].stride),   \n        static_cast<int>(dims.spatial_dims[2].stride));  \n  }", "target": 0}
{"code": "R_API RBinJavaAttrInfo *r_bin_java_synthetic_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut64 offset = 0;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\toffset += 6;\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_SYNTHETIC_ATTR;\n\tattr->size = offset;\n\treturn attr;\n}", "target": 1}
{"code": "static void smp_update_key_mask(tSMP_CB* p_cb, uint8_t key_type, bool recv) {\n  SMP_TRACE_DEBUG(\n \"%s before update role=%d recv=%d local_i_key = %02x, local_r_key = %02x\",\n      __func__, p_cb->role, recv, p_cb->local_i_key, p_cb->local_r_key);\n if (((p_cb->le_secure_connections_mode_is_used) || (p_cb->smp_over_br)) &&\n ((key_type == SMP_SEC_KEY_TYPE_ENC) ||\n (key_type == SMP_SEC_KEY_TYPE_LK))) {\n    p_cb->local_i_key &= ~key_type;\n    p_cb->local_r_key &= ~key_type;\n } else if (p_cb->role == HCI_ROLE_SLAVE) {\n if (recv)\n      p_cb->local_i_key &= ~key_type;\n else\n      p_cb->local_r_key &= ~key_type;\n } else {\n if (recv)\n      p_cb->local_r_key &= ~key_type;\n else\n      p_cb->local_i_key &= ~key_type;\n }\n  SMP_TRACE_DEBUG(\"updated local_i_key = %02x, local_r_key = %02x\",\n                  p_cb->local_i_key, p_cb->local_r_key);\n}", "target": 0}
{"code": "static int stimer_set_count(struct kvm_vcpu_hv_stimer *stimer, u64 count,\n\t\t\t    bool host)\n{\n\tstruct kvm_vcpu *vcpu = hv_stimer_to_vcpu(stimer);\n\tstruct kvm_vcpu_hv_synic *synic = to_hv_synic(vcpu);\n\tif (!synic->active && !host)\n\t\treturn 1;\n\ttrace_kvm_hv_stimer_set_count(hv_stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t      stimer->index, count, host);\n\tstimer_cleanup(stimer);\n\tstimer->count = count;\n\tif (stimer->count == 0)\n\t\tstimer->config.enable = 0;\n\telse if (stimer->config.auto_enable)\n\t\tstimer->config.enable = 1;\n\tif (stimer->config.enable)\n\t\tstimer_mark_pending(stimer, false);\n\treturn 0;\n}", "target": 1}
{"code": "dirvote_get_vote(const char *fp, int flags)\n{\n  int by_id = flags & DGV_BY_ID;\n  const int include_pending = flags & DGV_INCLUDE_PENDING;\n  const int include_previous = flags & DGV_INCLUDE_PREVIOUS;\n  if (!pending_vote_list && !previous_vote_list)\n    return NULL;\n  if (fp == NULL) {\n    authority_cert_t *c = get_my_v3_authority_cert();\n    if (c) {\n      fp = c->cache_info.identity_digest;\n      by_id = 1;\n    } else\n      return NULL;\n  }\n  if (by_id) {\n    if (pending_vote_list && include_pending) {\n      SMARTLIST_FOREACH(pending_vote_list, pending_vote_t *, pv,\n        if (fast_memeq(get_voter(pv->vote)->identity_digest, fp, DIGEST_LEN))\n          return pv->vote_body);\n    }\n    if (previous_vote_list && include_previous) {\n      SMARTLIST_FOREACH(previous_vote_list, pending_vote_t *, pv,\n        if (fast_memeq(get_voter(pv->vote)->identity_digest, fp, DIGEST_LEN))\n          return pv->vote_body);\n    }\n  } else {\n    if (pending_vote_list && include_pending) {\n      SMARTLIST_FOREACH(pending_vote_list, pending_vote_t *, pv,\n        if (fast_memeq(pv->vote->digests.d[DIGEST_SHA1], fp, DIGEST_LEN))\n          return pv->vote_body);\n    }\n    if (previous_vote_list && include_previous) {\n      SMARTLIST_FOREACH(previous_vote_list, pending_vote_t *, pv,\n        if (fast_memeq(pv->vote->digests.d[DIGEST_SHA1], fp, DIGEST_LEN))\n          return pv->vote_body);\n    }\n  }\n  return NULL;\n}", "target": 0}
{"code": "static authz_status oidc_handle_unauthorized_user24(request_rec *r) {\n\toidc_debug(r, \"enter\");\n\toidc_cfg *c = ap_get_module_config(r->server->module_config, &auth_openidc_module);\n\tif (apr_strnatcasecmp((const char*) ap_auth_type(r),\n\t\t\t\t\t\t  OIDC_AUTH_TYPE_OPENID_OAUTH20) == 0) {\n\t\toidc_debug(r, \"setting environment variable %s to \\\"%s\\\" for usage in mod_headers\", OIDC_OAUTH_BEARER_SCOPE_ERROR, OIDC_OAUTH_BEARER_SCOPE_ERROR_VALUE);\n\t\tapr_table_set(r->subprocess_env, OIDC_OAUTH_BEARER_SCOPE_ERROR, OIDC_OAUTH_BEARER_SCOPE_ERROR_VALUE);\n\t\treturn AUTHZ_DENIED;\n\t}\n\tswitch (oidc_dir_cfg_unautz_action(r)) {\n\t\tcase OIDC_UNAUTZ_RETURN403:\n\t\tcase OIDC_UNAUTZ_RETURN401:\n\t\t\treturn AUTHZ_DENIED;\n\t\t\tbreak;\n\t\tcase OIDC_UNAUTZ_AUTHENTICATE:\n\t\t\tif (oidc_is_xml_http_request(r) == TRUE)\n\t\t\t\treturn AUTHZ_DENIED;\n\t\t\tbreak;\n\t}\n\toidc_authenticate_user(r, c, NULL, oidc_get_current_url(r), NULL,\n\t\t\tNULL, NULL, oidc_dir_cfg_path_auth_request_params(r), oidc_dir_cfg_path_scope(r));\n\tconst char *location = oidc_util_hdr_out_location_get(r);\n\tif (location != NULL) {\n\t\toidc_debug(r, \"send HTML refresh with authorization redirect: %s\", location);\n\t\tchar *html_head =\n\t\t\t\tapr_psprintf(r->pool, \"<meta http-equiv=\\\"refresh\\\" content=\\\"0; url=%s\\\">\", location);\n\t\toidc_util_html_send(r, \"Stepup Authentication\", html_head, NULL, NULL,\n\t\t\t\tHTTP_UNAUTHORIZED);\n\t\tr->header_only = 1;\n\t}\n\treturn AUTHZ_DENIED;\n}", "target": 0}
{"code": "static s32 adpt_i2o_post_this(adpt_hba* pHba, u32* data, int len)\n{\n\tu32 m = EMPTY_QUEUE;\n\tu32 __iomem *msg;\n\tulong timeout = jiffies + 30*HZ;\n\tdo {\n\t\trmb();\n\t\tm = readl(pHba->post_port);\n\t\tif (m != EMPTY_QUEUE) {\n\t\t\tbreak;\n\t\t}\n\t\tif(time_after(jiffies,timeout)){\n\t\t\tprintk(KERN_WARNING\"dpti%d: Timeout waiting for message frame!\\n\", pHba->unit);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tschedule_timeout_uninterruptible(1);\n\t} while(m == EMPTY_QUEUE);\n\tmsg = pHba->msg_addr_virt + m;\n\tmemcpy_toio(msg, data, len);\n\twmb();\n\twritel(m, pHba->post_port);\n\twmb();\n\treturn 0;\n}", "target": 1}
{"code": "int sysctl_numa_balancing(struct ctl_table *table, int write,\n\t\t\t void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct ctl_table t;\n\tint err;\n\tint state = static_branch_likely(&sched_numa_balancing);\n\tif (write && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tt = *table;\n\tt.data = &state;\n\terr = proc_dointvec_minmax(&t, write, buffer, lenp, ppos);\n\tif (err < 0)\n\t\treturn err;\n\tif (write)\n\t\tset_numabalancing_state(state);\n\treturn err;\n}", "target": 0}
{"code": "void fuse_fs_destroy(struct fuse_fs *fs)\n{\n    fuse_get_context()->private_data = fs->user_data;\n    if (fs->op.destroy)\n        fs->op.destroy(fs->user_data);\n#ifdef __SOLARIS__\n    if (fs->m)\n        fuse_put_module(fs->m);\n#endif \n    free(fs);\n}", "target": 0}
{"code": "bool BlobURLRequestJob::ReadFile(const BlobData::Item& item) {\n  DCHECK(stream_.get());\n  DCHECK(stream_->IsOpen());\n  DCHECK(read_buf_remaining_bytes_ >= bytes_to_read_);\n  int rv = stream_->Read(read_buf_->data() + read_buf_offset_,\n                         bytes_to_read_,\n                         &io_callback_);\n  if (rv == net::ERR_IO_PENDING) {\n    SetStatus(net::URLRequestStatus(net::URLRequestStatus::IO_PENDING, 0));\n    return false;\n  }\n  if (rv < 0) {\n    NotifyFailure(net::ERR_FAILED);\n    return false;\n  }\n  if (GetStatus().is_io_pending())\n    DidRead(rv);\n  else\n    AdvanceBytesRead(rv);\n  return true;\n}", "target": 0}
{"code": "static void xgmac_enet_send(XgmacState *s)\n{\n    struct desc bd;\n    int frame_size;\n    int len;\n    uint8_t frame[8192];\n    uint8_t *ptr;\n    ptr = frame;\n    frame_size = 0;\n    while (1) {\n        xgmac_read_desc(s, &bd, 0);\n        if ((bd.ctl_stat & 0x80000000) == 0) {\n            break;\n        }\n        len = (bd.buffer1_size & 0xfff) + (bd.buffer2_size & 0xfff);\n        if ((bd.buffer1_size & 0xfff) > 2048) {\n            DEBUGF_BRK(\"qemu:%s:ERROR...ERROR...ERROR... -- \"\n                        \"xgmac buffer 1 len on send > 2048 (0x%x)\\n\",\n                         __func__, bd.buffer1_size & 0xfff);\n        }\n        if ((bd.buffer2_size & 0xfff) != 0) {\n            DEBUGF_BRK(\"qemu:%s:ERROR...ERROR...ERROR... -- \"\n                        \"xgmac buffer 2 len on send != 0 (0x%x)\\n\",\n                        __func__, bd.buffer2_size & 0xfff);\n        }\n        if (len >= sizeof(frame)) {\n            DEBUGF_BRK(\"qemu:%s: buffer overflow %d read into %zu \"\n                        \"buffer\\n\" , __func__, len, sizeof(frame));\n            DEBUGF_BRK(\"qemu:%s: buffer1.size=%d; buffer2.size=%d\\n\",\n                        __func__, bd.buffer1_size, bd.buffer2_size);\n        }\n        cpu_physical_memory_read(bd.buffer1_addr, ptr, len);\n        ptr += len;\n        frame_size += len;\n        if (bd.ctl_stat & 0x20000000) {\n            qemu_send_packet(qemu_get_queue(s->nic), frame, len);\n            ptr = frame;\n            frame_size = 0;\n            s->regs[DMA_STATUS] |= DMA_STATUS_TI | DMA_STATUS_NIS;\n        }\n        bd.ctl_stat &= ~0x80000000;\n        xgmac_write_desc(s, &bd, 0);\n    }\n}", "target": 1}
{"code": "KCleanup::itemDir( const KFileInfo *item ) const\n{\n    QString dir = item->url();\n    if ( ! item->isDir() && ! item->isDotEntry() )\n    {\n\tdir.replace ( QRegExp ( \"/[^/]*$\" ), \"\" );\n    }\n    return dir;\n}", "target": 0}
{"code": "static int digi_startup(struct usb_serial *serial)\n{\n\tstruct device *dev = &serial->interface->dev;\n\tstruct digi_serial *serial_priv;\n\tint ret;\n\tint i;\n\tif (serial->num_port_pointers < serial->type->num_ports + 1) {\n\t\tdev_err(dev, \"OOB endpoints missing\\n\");\n\t\treturn -ENODEV;\n\t}\n\tfor (i = 0; i < serial->type->num_ports + 1 ; i++) {\n\t\tif (!serial->port[i]->read_urb) {\n\t\t\tdev_err(dev, \"bulk-in endpoint missing\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tif (!serial->port[i]->write_urb) {\n\t\t\tdev_err(dev, \"bulk-out endpoint missing\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\tserial_priv = kzalloc(sizeof(*serial_priv), GFP_KERNEL);\n\tif (!serial_priv)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&serial_priv->ds_serial_lock);\n\tserial_priv->ds_oob_port_num = serial->type->num_ports;\n\tserial_priv->ds_oob_port = serial->port[serial_priv->ds_oob_port_num];\n\tret = digi_port_init(serial_priv->ds_oob_port,\n\t\t\t\t\t\tserial_priv->ds_oob_port_num);\n\tif (ret) {\n\t\tkfree(serial_priv);\n\t\treturn ret;\n\t}\n\tusb_set_serial_data(serial, serial_priv);\n\treturn 0;\n}", "target": 0}
{"code": "TEST_P(RBACIntegrationTest, RouteOverride) {\n  config_helper_.addConfigModifier(\n      [](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n             cfg) {\n        envoy::extensions::filters::http::rbac::v3::RBACPerRoute per_route_config;\n        TestUtility::loadFromJson(\"{}\", per_route_config);\n        auto* config = cfg.mutable_route_config()\n                           ->mutable_virtual_hosts()\n                           ->Mutable(0)\n                           ->mutable_typed_per_filter_config();\n        (*config)[Extensions::HttpFilters::HttpFilterNames::get().Rbac].PackFrom(per_route_config);\n      });\n  config_helper_.addFilter(RBAC_CONFIG);\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response = codec_client_->makeRequestWithBody(\n      Http::TestRequestHeaderMapImpl{\n          {\":method\", \"POST\"},\n          {\":path\", \"/\"},\n          {\":scheme\", \"http\"},\n          {\":authority\", \"host\"},\n          {\"x-forwarded-for\", \"10.0.0.1\"},\n      },\n      1024);\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}}, true);\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().getStatusValue());\n}", "target": 0}
{"code": "int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)\n{\n\tunsigned int offset = sizeof(struct ipv6hdr);\n\tunsigned int packet_len = skb_tail_pointer(skb) -\n\t\tskb_network_header(skb);\n\tint found_rhdr = 0;\n\t*nexthdr = &ipv6_hdr(skb)->nexthdr;\n\twhile (offset <= packet_len) {\n\t\tstruct ipv6_opt_hdr *exthdr;\n\t\tunsigned int len;\n\t\tswitch (**nexthdr) {\n\t\tcase NEXTHDR_HOP:\n\t\t\tbreak;\n\t\tcase NEXTHDR_ROUTING:\n\t\t\tfound_rhdr = 1;\n\t\t\tbreak;\n\t\tcase NEXTHDR_DEST:\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\t\tif (ipv6_find_tlv(skb, offset, IPV6_TLV_HAO) >= 0)\n\t\t\t\tbreak;\n#endif\n\t\t\tif (found_rhdr)\n\t\t\t\treturn offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn offset;\n\t\t}\n\t\tif (offset + sizeof(struct ipv6_opt_hdr) > packet_len)\n\t\t\treturn -EINVAL;\n\t\texthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +\n\t\t\t\t\t\t offset);\n\t\tlen = ipv6_optlen(exthdr);\n\t\tif (len + offset >= IPV6_MAXPLEN)\n\t\t\treturn -EINVAL;\n\t\toffset += len;\n\t\t*nexthdr = &exthdr->nexthdr;\n\t}\n\treturn -EINVAL;\n}", "target": 0}
{"code": "static int ext4_split_extent(handle_t *handle,\n\t\t\t      struct inode *inode,\n\t\t\t      struct ext4_ext_path *path,\n\t\t\t      struct ext4_map_blocks *map,\n\t\t\t      int split_flag,\n\t\t\t      int flags)\n{\n\text4_lblk_t ee_block;\n\tstruct ext4_extent *ex;\n\tunsigned int ee_len, depth;\n\tint err = 0;\n\tint uninitialized;\n\tint split_flag1, flags1;\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\tee_block = le32_to_cpu(ex->ee_block);\n\tee_len = ext4_ext_get_actual_len(ex);\n\tuninitialized = ext4_ext_is_uninitialized(ex);\n\tif (map->m_lblk + map->m_len < ee_block + ee_len) {\n\t\tsplit_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ?\n\t\t\t      EXT4_EXT_MAY_ZEROOUT : 0;\n\t\tflags1 = flags | EXT4_GET_BLOCKS_PRE_IO;\n\t\tif (uninitialized)\n\t\t\tsplit_flag1 |= EXT4_EXT_MARK_UNINIT1 |\n\t\t\t\t       EXT4_EXT_MARK_UNINIT2;\n\t\terr = ext4_split_extent_at(handle, inode, path,\n\t\t\t\tmap->m_lblk + map->m_len, split_flag1, flags1);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\text4_ext_drop_refs(path);\n\tpath = ext4_ext_find_extent(inode, map->m_lblk, path);\n\tif (IS_ERR(path))\n\t\treturn PTR_ERR(path);\n\tif (map->m_lblk >= ee_block) {\n\t\tsplit_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ?\n\t\t\t      EXT4_EXT_MAY_ZEROOUT : 0;\n\t\tif (uninitialized)\n\t\t\tsplit_flag1 |= EXT4_EXT_MARK_UNINIT1;\n\t\tif (split_flag & EXT4_EXT_MARK_UNINIT2)\n\t\t\tsplit_flag1 |= EXT4_EXT_MARK_UNINIT2;\n\t\terr = ext4_split_extent_at(handle, inode, path,\n\t\t\t\tmap->m_lblk, split_flag1, flags);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\text4_ext_show_leaf(inode, path);\nout:\n\treturn err ? err : map->m_len;\n}", "target": 1}
{"code": "void cql_server::response::write_byte(uint8_t b)\n{\n    auto s = reinterpret_cast<const int8_t*>(&b);\n    _body.write(bytes_view(s, sizeof(b)));\n}", "target": 0}
{"code": "static inline int check_entry_size_and_hooks(struct arpt_entry *e,\n\t\t\t\t\t     struct xt_table_info *newinfo,\n\t\t\t\t\t     const unsigned char *base,\n\t\t\t\t\t     const unsigned char *limit,\n\t\t\t\t\t     const unsigned int *hook_entries,\n\t\t\t\t\t     const unsigned int *underflows,\n\t\t\t\t\t     unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct arpt_entry) >= limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_err(\"Underflows must be unconditional and \"\n\t\t\t\t       \"use the STANDARD target with \"\n\t\t\t\t       \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 1}
{"code": "int nfs_initiate_commit(struct rpc_clnt *clnt, struct nfs_commit_data *data,\n\t\t\tconst struct rpc_call_ops *call_ops,\n\t\t\tint how, int flags)\n{\n\tstruct rpc_task *task;\n\tint priority = flush_task_priority(how);\n\tstruct rpc_message msg = {\n\t\t.rpc_argp = &data->args,\n\t\t.rpc_resp = &data->res,\n\t\t.rpc_cred = data->cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.task = &data->task,\n\t\t.rpc_client = clnt,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = call_ops,\n\t\t.callback_data = data,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC | flags,\n\t\t.priority = priority,\n\t};\n\tNFS_PROTO(data->inode)->commit_setup(data, &msg);\n\tdprintk(\"NFS: %5u initiated commit call\\n\", data->task.tk_pid);\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tif (how & FLUSH_SYNC)\n\t\trpc_wait_for_completion_task(task);\n\trpc_put_task(task);\n\treturn 0;\n}", "target": 0}
{"code": "void sctp_assoc_set_primary(struct sctp_association *asoc,\n\t\t\t    struct sctp_transport *transport)\n{\n\tint changeover = 0;\n\tif (asoc->peer.primary_path != NULL &&\n\t    asoc->peer.primary_path != transport)\n\t\tchangeover = 1 ;\n\tasoc->peer.primary_path = transport;\n\tmemcpy(&asoc->peer.primary_addr, &transport->ipaddr,\n\t       sizeof(union sctp_addr));\n\tif ((transport->state == SCTP_ACTIVE) ||\n\t    (transport->state == SCTP_UNKNOWN))\n\t\tasoc->peer.active_path = transport;\n\tif (!asoc->outqueue.outstanding_bytes && !asoc->outqueue.out_qlen)\n\t\treturn;\n\tif (transport->cacc.changeover_active)\n\t\ttransport->cacc.cycling_changeover = changeover;\n\ttransport->cacc.changeover_active = changeover;\n\ttransport->cacc.next_tsn_at_change = asoc->next_tsn;\n}", "target": 0}
{"code": "error::Error GLES2DecoderImpl::HandleGetActiveAttrib(\n    uint32 immediate_data_size, const gles2::GetActiveAttrib& c) {\n  GLuint program = c.program;\n  GLuint index = c.index;\n  uint32 name_bucket_id = c.name_bucket_id;\n  typedef gles2::GetActiveAttrib::Result Result;\n  Result* result = GetSharedMemoryAs<Result*>(\n      c.result_shm_id, c.result_shm_offset, sizeof(*result));\n  if (!result) {\n    return error::kOutOfBounds;\n  }\n  if (result->success != 0) {\n    return error::kInvalidArguments;\n  }\n  ProgramManager::ProgramInfo* info = GetProgramInfoNotShader(\n      program, \"glGetActiveAttrib\");\n  if (!info) {\n    return error::kNoError;\n  }\n  const ProgramManager::ProgramInfo::VertexAttribInfo* attrib_info =\n      info->GetAttribInfo(index);\n  if (!attrib_info) {\n    SetGLError(GL_INVALID_VALUE, \"glGetActiveAttrib: index out of range\");\n    return error::kNoError;\n  }\n  result->success = 1;  \n  result->size = attrib_info->size;\n  result->type = attrib_info->type;\n  Bucket* bucket = CreateBucket(name_bucket_id);\n  bucket->SetFromString(attrib_info->name);\n  return error::kNoError;\n}", "target": 0}
{"code": "PHP_FUNCTION(pg_lo_write)\n{\n  \tzval *pgsql_id;\n  \tchar *str;\n  \tlong z_len;\n\tint str_len, nbytes;\n\tint len;\n\tpgLofp *pgsql;\n\tint argc = ZEND_NUM_ARGS();\n\tif (zend_parse_parameters(argc TSRMLS_CC, \"rs|l\", &pgsql_id, &str, &str_len, &z_len) == FAILURE) {\n\t\treturn;\n\t}\n\tif (argc > 2) {\n\t\tif (z_len > str_len) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Cannot write more than buffer size %d. Tried to write %ld\", str_len, z_len);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tif (z_len < 0) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Buffer size must be larger than 0, but %ld was specified\", z_len);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tlen = z_len;\n\t}\n\telse {\n\t\tlen = str_len;\n\t}\n\tZEND_FETCH_RESOURCE(pgsql, pgLofp *, &pgsql_id, -1, \"PostgreSQL large object\", le_lofp);\n\tif ((nbytes = lo_write((PGconn *)pgsql->conn, pgsql->lofd, str, len)) == -1) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_LONG(nbytes);\n}", "target": 0}
{"code": "static int old_dsa_priv_encode(const EVP_PKEY *pkey, unsigned char **pder)\n{\n    return i2d_DSAPrivateKey(pkey->pkey.dsa, pder);\n}", "target": 0}
{"code": "static int changedline (const Proto *p, int oldpc, int newpc) {\n  while (oldpc++ < newpc) {\n    if (p->lineinfo[oldpc] != 0)\n      return (luaG_getfuncline(p, oldpc - 1) != luaG_getfuncline(p, newpc));\n  }\n  return 0;  \n}", "target": 1}
{"code": "static inline void __file_sb_list_add(struct file *file, struct super_block *sb)\n{\n\tstruct list_head *list;\n#ifdef CONFIG_SMP\n\tint cpu;\n\tcpu = smp_processor_id();\n\tfile->f_sb_list_cpu = cpu;\n\tlist = per_cpu_ptr(sb->s_files, cpu);\n#else\n\tlist = &sb->s_files;\n#endif\n\tlist_add(&file->f_u.fu_list, list);\n}", "target": 1}
{"code": "ngx_gmtime(time_t t, ngx_tm_t *tp)\n{\n    ngx_int_t   yday;\n    ngx_uint_t  sec, min, hour, mday, mon, year, wday, days, leap;\n    if (t < 0) {\n        t = 0;\n    }\n    days = t / 86400;\n    sec = t % 86400;\n    wday = (4 + days) % 7;\n    hour = sec / 3600;\n    sec %= 3600;\n    min = sec / 60;\n    sec %= 60;\n    days = days - (31 + 28) + 719527;\n    year = (days + 2) * 400 / (365 * 400 + 100 - 4 + 1);\n    yday = days - (365 * year + year / 4 - year / 100 + year / 400);\n    if (yday < 0) {\n        leap = (year % 4 == 0) && (year % 100 || (year % 400 == 0));\n        yday = 365 + leap + yday;\n        year--;\n    }\n    mon = (yday + 31) * 10 / 306;\n    mday = yday - (367 * mon / 12 - 30) + 1;\n    if (yday >= 306) {\n        year++;\n        mon -= 10;\n    } else {\n        mon += 2;\n    }\n    tp->ngx_tm_sec = (ngx_tm_sec_t) sec;\n    tp->ngx_tm_min = (ngx_tm_min_t) min;\n    tp->ngx_tm_hour = (ngx_tm_hour_t) hour;\n    tp->ngx_tm_mday = (ngx_tm_mday_t) mday;\n    tp->ngx_tm_mon = (ngx_tm_mon_t) mon;\n    tp->ngx_tm_year = (ngx_tm_year_t) year;\n    tp->ngx_tm_wday = (ngx_tm_wday_t) wday;\n}", "target": 1}
{"code": "void *_zend_shared_memdup(void *source, size_t size, zend_bool free_source TSRMLS_DC)\n{\n\tvoid **old_p, *retval;\n\tif (zend_hash_index_find(&xlat_table, (ulong)source, (void **)&old_p) == SUCCESS) {\n\t\treturn *old_p;\n\t}\n\tretval = ZCG(mem);;\n\tZCG(mem) = (void*)(((char*)ZCG(mem)) + ZEND_ALIGNED_SIZE(size));\n\tmemcpy(retval, source, size);\n\tif (free_source) {\n\t\tinterned_efree((char*)source);\n\t}\n\tzend_shared_alloc_register_xlat_entry(source, retval);\n\treturn retval;\n}", "target": 1}
{"code": "\tvirtual void describe()\n\t{\n\t\tgetDefaultPCMMapping(m_outChunk->f.sampleWidth,\n\t\t\tm_outChunk->f.pcm.slope,\n\t\t\tm_outChunk->f.pcm.intercept,\n\t\t\tm_outChunk->f.pcm.minClip,\n\t\t\tm_outChunk->f.pcm.maxClip);\n\t}", "target": 0}
{"code": "av_cold void ff_vc2enc_free_transforms(VC2TransformContext *s)\n{\n    av_freep(&s->buffer);\n}", "target": 1}
{"code": "static enum AVPixelFormat h263_get_format(AVCodecContext *avctx)\n{\n    if (avctx->bits_per_raw_sample > 8) {\n        av_assert1(avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);\n        return avctx->pix_fmt;\n    }\n    if (avctx->codec->id == AV_CODEC_ID_MSS2)\n        return AV_PIX_FMT_YUV420P;\n    if (CONFIG_GRAY && (avctx->flags & AV_CODEC_FLAG_GRAY)) {\n        if (avctx->color_range == AVCOL_RANGE_UNSPECIFIED)\n            avctx->color_range = AVCOL_RANGE_MPEG;\n        return AV_PIX_FMT_GRAY8;\n    }\n    return avctx->pix_fmt = ff_get_format(avctx, avctx->codec->pix_fmts);\n}", "target": 1}
{"code": "void SpeechSynthesis::voicesDidChange()\n{\n    m_voiceList.clear();\n    if (!executionContext()->activeDOMObjectsAreStopped())\n        dispatchEvent(Event::create(EventTypeNames::voiceschanged));\n}", "target": 0}
{"code": "int hns_ppe_get_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn ETH_PPE_STATIC_NUM;\n\treturn 0;\n}", "target": 1}
{"code": "static void SVGStripString(const MagickBooleanType trim,char *message)\n{\n  register char\n    *p,\n    *q;\n  size_t\n    length;\n  assert(message != (char *) NULL);\n  if (*message == '\\0')\n    return;\n  q=message;\n  for (p=message; *p != '\\0'; p++)\n  {\n    if ((*p == '/') && (*(p+1) == '*'))\n      {\n        for ( ; *p != '\\0'; p++)\n          if ((*p == '*') && (*(p+1) == '/'))\n            break;\n        if (*p == '\\0')\n          break;\n        p+=2;\n      }\n    *q++=(*p);\n  }\n  *q='\\0';\n  if (trim != MagickFalse)\n    {\n      length=strlen(message);\n      p=message;\n      while (isspace((int) ((unsigned char) *p)) != 0)\n        p++;\n      if ((*p == '\\'') || (*p == '\"'))\n        p++;\n      q=message+length-1;\n      while ((isspace((int) ((unsigned char) *q)) != 0) && (q > p))\n        q--;\n      if (q > p)\n        if ((*q == '\\'') || (*q == '\"'))\n          q--;\n      (void) memmove(message,p,(size_t) (q-p+1));\n      message[q-p+1]='\\0';\n    }\n  for (p=message; *p != '\\0'; p++)\n    if (*p == '\\n')\n      *p=' ';\n}", "target": 1}
{"code": "MagickExport void *AcquireQuantumMemory(const size_t count,const size_t quantum)\n{\n  size_t\n    extent;\n  if (CheckMemoryOverflow(count,quantum) != MagickFalse)\n    return((void *) NULL);\n  extent=count*quantum;\n  return(AcquireMagickMemory(extent));\n}", "target": 1}
{"code": "void cql_server::response::serialize(const event::schema_change& event, uint8_t version)\n{\n    if (version >= 3) {\n        write_string(to_string(event.change));\n        write_string(to_string(event.target));\n        write_string(event.keyspace);\n        switch (event.target) {\n        case event::schema_change::target_type::KEYSPACE:\n            break;\n        case event::schema_change::target_type::TYPE:\n        case event::schema_change::target_type::TABLE:\n            write_string(event.arguments[0]);\n            break;\n        case event::schema_change::target_type::FUNCTION:\n        case event::schema_change::target_type::AGGREGATE:\n            write_string(event.arguments[0]);\n            write_string_list(std::vector<sstring>(event.arguments.begin() + 1, event.arguments.end()));\n            break;\n        }\n    } else {\n        switch (event.target) {\n        case event::schema_change::target_type::TYPE:\n        case event::schema_change::target_type::FUNCTION:\n        case event::schema_change::target_type::AGGREGATE:\n            write_string(to_string(event::schema_change::change_type::UPDATED));\n            write_string(event.keyspace);\n            write_string(\"\");\n            break;\n        case event::schema_change::target_type::TABLE:\n        case event::schema_change::target_type::KEYSPACE:\n            write_string(to_string(event.change));\n            write_string(event.keyspace);\n            if (event.target == event::schema_change::target_type::TABLE) {\n                write_string(event.arguments[0]);\n            } else {\n                write_string(\"\");\n            }\n        }\n    }\n}", "target": 0}
{"code": "static struct nfs4_state *nfs4_do_open(struct inode *dir, struct path *path, int flags, struct iattr *sattr, struct rpc_cred *cred)\n{\n\tstruct nfs4_exception exception = { };\n\tstruct nfs4_state *res;\n\tint status;\n\tdo {\n\t\tstatus = _nfs4_do_open(dir, path, flags, sattr, cred, &res);\n\t\tif (status == 0)\n\t\t\tbreak;\n\t\tif (status == -NFS4ERR_BAD_SEQID) {\n\t\t\tprintk(KERN_WARNING \"NFS: v4 server %s \"\n\t\t\t\t\t\" returned a bad sequence-id error!\\n\",\n\t\t\t\t\tNFS_SERVER(dir)->nfs_client->cl_hostname);\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (status == -NFS4ERR_BAD_STATEID) {\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (status == -EAGAIN) {\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tres = ERR_PTR(nfs4_handle_exception(NFS_SERVER(dir),\n\t\t\t\t\tstatus, &exception));\n\t} while (exception.retry);\n\treturn res;\n}", "target": 1}
{"code": "static int kvp_process_ip_address(void *addrp,\n\t\t\t\tint family, char *buffer,\n\t\t\t\tint length,  int *offset)\n{\n\tstruct sockaddr_in *addr;\n\tstruct sockaddr_in6 *addr6;\n\tint addr_length;\n\tchar tmp[50];\n\tconst char *str;\n\tif (family == AF_INET) {\n\t\taddr = (struct sockaddr_in *)addrp;\n\t\tstr = inet_ntop(family, &addr->sin_addr, tmp, 50);\n\t\taddr_length = INET_ADDRSTRLEN;\n\t} else {\n\t\taddr6 = (struct sockaddr_in6 *)addrp;\n\t\tstr = inet_ntop(family, &addr6->sin6_addr.s6_addr, tmp, 50);\n\t\taddr_length = INET6_ADDRSTRLEN;\n\t}\n\tif ((length - *offset) < addr_length + 2)\n\t\treturn HV_E_FAIL;\n\tif (str == NULL) {\n\t\tstrcpy(buffer, \"inet_ntop failed\\n\");\n\t\treturn HV_E_FAIL;\n\t}\n\tif (*offset == 0)\n\t\tstrcpy(buffer, tmp);\n\telse {\n\t\tstrcat(buffer, \";\");\n\t\tstrcat(buffer, tmp);\n\t}\n\t*offset += strlen(str) + 1;\n\treturn 0;\n}", "target": 0}
{"code": "static apr_status_t lua_websocket_readbytes(conn_rec* c, char* buffer, \n        apr_off_t len) \n{\n    apr_bucket_brigade *brigade = apr_brigade_create(c->pool, c->bucket_alloc);\n    apr_status_t rv;\n    rv = ap_get_brigade(c->input_filters, brigade, AP_MODE_READBYTES, \n            APR_BLOCK_READ, len);\n    if (rv == APR_SUCCESS) {\n        if (!APR_BRIGADE_EMPTY(brigade)) {\n            apr_bucket* bucket = APR_BRIGADE_FIRST(brigade);\n            const char* data = NULL;\n            apr_size_t data_length = 0;\n            rv = apr_bucket_read(bucket, &data, &data_length, APR_BLOCK_READ);\n            if (rv == APR_SUCCESS) {\n                memcpy(buffer, data, len);\n            }\n            apr_bucket_delete(bucket);\n        }\n    }\n    apr_brigade_cleanup(brigade);\n    return rv;\n}", "target": 0}
{"code": "static int propagate_liveness(struct bpf_verifier_env *env,\n\t\t\t      const struct bpf_verifier_state *vstate,\n\t\t\t      struct bpf_verifier_state *vparent)\n{\n\tstruct bpf_reg_state *state_reg, *parent_reg;\n\tstruct bpf_func_state *state, *parent;\n\tint i, frame, err = 0;\n\tif (vparent->curframe != vstate->curframe) {\n\t\tWARN(1, \"propagate_live: parent frame %d current frame %d\\n\",\n\t\t     vparent->curframe, vstate->curframe);\n\t\treturn -EFAULT;\n\t}\n\tBUILD_BUG_ON(BPF_REG_FP + 1 != MAX_BPF_REG);\n\tfor (frame = 0; frame <= vstate->curframe; frame++) {\n\t\tparent = vparent->frame[frame];\n\t\tstate = vstate->frame[frame];\n\t\tparent_reg = parent->regs;\n\t\tstate_reg = state->regs;\n\t\tfor (i = frame < vstate->curframe ? BPF_REG_6 : 0; i < BPF_REG_FP; i++) {\n\t\t\terr = propagate_liveness_reg(env, &state_reg[i],\n\t\t\t\t\t\t     &parent_reg[i]);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tif (err == REG_LIVE_READ64)\n\t\t\t\tmark_insn_zext(env, &parent_reg[i]);\n\t\t}\n\t\tfor (i = 0; i < state->allocated_stack / BPF_REG_SIZE &&\n\t\t\t    i < parent->allocated_stack / BPF_REG_SIZE; i++) {\n\t\t\tparent_reg = &parent->stack[i].spilled_ptr;\n\t\t\tstate_reg = &state->stack[i].spilled_ptr;\n\t\t\terr = propagate_liveness_reg(env, state_reg,\n\t\t\t\t\t\t     parent_reg);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int uas_find_uas_alt_setting(struct usb_interface *intf)\n{\n\tint i;\n\tfor (i = 0; i < intf->num_altsetting; i++) {\n\t\tstruct usb_host_interface *alt = &intf->altsetting[i];\n\t\tif (uas_is_interface(alt))\n\t\t\treturn alt->desc.bAlternateSetting;\n\t}\n\treturn -ENODEV;\n}", "target": 1}
{"code": "pci_emul_capwrite(struct pci_vdev *dev, int offset, int bytes, uint32_t val)\n{\n\tint capid;\n\tuint8_t capoff, nextoff;\n\tif ((offset & (bytes - 1)) != 0)\n\t\treturn;\n\tcapoff = CAP_START_OFFSET;\n\twhile (1) {\n\t\tnextoff = pci_get_cfgdata8(dev, capoff + 1);\n\t\tif (nextoff == 0)\n\t\t\tbreak;\n\t\tif (offset >= capoff && offset < nextoff)\n\t\t\tbreak;\n\t\tcapoff = nextoff;\n\t}\n\tassert(offset >= capoff);\n\tif (offset == capoff || offset == capoff + 1) {\n\t\tif (offset == capoff && bytes == 4) {\n\t\t\tbytes = 2;\n\t\t\toffset += 2;\n\t\t\tval >>= 16;\n\t\t} else\n\t\t\treturn;\n\t}\n\tcapid = pci_get_cfgdata8(dev, capoff);\n\tswitch (capid) {\n\tcase PCIY_MSI:\n\t\tmsicap_cfgwrite(dev, capoff, offset, bytes, val);\n\t\tbreak;\n\tcase PCIY_MSIX:\n\t\tmsixcap_cfgwrite(dev, capoff, offset, bytes, val);\n\t\tbreak;\n\tcase PCIY_EXPRESS:\n\t\tpciecap_cfgwrite(dev, capoff, offset, bytes, val);\n\t\tbreak;\n\tdefault:\n\t\tCFGWRITE(dev, offset, val, bytes);\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "pim_print(netdissect_options *ndo,\n          register const u_char *bp, register u_int len, const u_char *bp2)\n{\n\tregister const u_char *ep;\n\tregister const struct pim *pim = (const struct pim *)bp;\n\tep = (const u_char *)ndo->ndo_snapend;\n\tif (bp >= ep)\n\t\treturn;\n#ifdef notyet\t\t\t\n\tND_TCHECK(pim->pim_rsv);\n#endif\n\tswitch (PIM_VER(pim->pim_typever)) {\n\tcase 2:\n\t\tif (!ndo->ndo_vflag) {\n\t\t\tND_PRINT((ndo, \"PIMv%u, %s, length %u\",\n\t\t\t          PIM_VER(pim->pim_typever),\n\t\t\t          tok2str(pimv2_type_values,\"Unknown Type\",PIM_TYPE(pim->pim_typever)),\n\t\t\t          len));\n\t\t\treturn;\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"PIMv%u, length %u\\n\\t%s\",\n\t\t\t          PIM_VER(pim->pim_typever),\n\t\t\t          len,\n\t\t\t          tok2str(pimv2_type_values,\"Unknown Type\",PIM_TYPE(pim->pim_typever))));\n\t\t\tpimv2_print(ndo, bp, len, bp2);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \"PIMv%u, length %u\",\n\t\t          PIM_VER(pim->pim_typever),\n\t\t          len));\n\t\tbreak;\n\t}\n\treturn;\n}", "target": 1}
{"code": "int wmi_set_ie(struct wil6210_priv *wil, u8 type, u16 ie_len, const void *ie)\n{\n\tstatic const char *const names[] = {\n\t\t[WMI_FRAME_BEACON]\t= \"BEACON\",\n\t\t[WMI_FRAME_PROBE_REQ]\t= \"PROBE_REQ\",\n\t\t[WMI_FRAME_PROBE_RESP]\t= \"WMI_FRAME_PROBE_RESP\",\n\t\t[WMI_FRAME_ASSOC_REQ]\t= \"WMI_FRAME_ASSOC_REQ\",\n\t\t[WMI_FRAME_ASSOC_RESP]\t= \"WMI_FRAME_ASSOC_RESP\",\n\t};\n\tint rc;\n\tu16 len = sizeof(struct wmi_set_appie_cmd) + ie_len;\n\tstruct wmi_set_appie_cmd *cmd = kzalloc(len, GFP_KERNEL);\n\tif (!cmd) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tif (!ie)\n\t\tie_len = 0;\n\tcmd->mgmt_frm_type = type;\n\tcmd->ie_len = cpu_to_le16(ie_len);\n\tmemcpy(cmd->ie_info, ie, ie_len);\n\trc = wmi_send(wil, WMI_SET_APPIE_CMDID, cmd, len);\n\tkfree(cmd);\nout:\n\tif (rc) {\n\t\tconst char *name = type < ARRAY_SIZE(names) ?\n\t\t\t\t   names[type] : \"??\";\n\t\twil_err(wil, \"set_ie(%d %s) failed : %d\\n\", type, name, rc);\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "uint32_t enc_untrusted_qe_get_quote_size(uint32_t *quote_size) {\n  uint32_t result;\n  CHECK_OCALL(ocall_enc_untrusted_qe_get_quote_size(&result, quote_size));\n  return result;\n}", "target": 0}
{"code": "struct file *file_open_name(struct filename *name, int flags, umode_t mode)\n{\n\tstruct open_flags op;\n\tint err = build_open_flags(flags, mode, &op);\n\treturn err ? ERR_PTR(err) : do_filp_open(AT_FDCWD, name, &op);\n}", "target": 0}
{"code": "MagickExport MagickBooleanType SubstituteString(char **string,\n  const char *search,const char *replace)\n{\n  MagickBooleanType\n    status;\n  register char\n    *p;\n  size_t\n    extent,\n    replace_extent,\n    search_extent;\n  ssize_t\n    offset;\n  status=MagickFalse;\n  search_extent=0,\n  replace_extent=0;\n  for (p=strchr(*string,*search); p != (char *) NULL; p=strchr(p+1,*search))\n  {\n    if (search_extent == 0)\n      search_extent=strlen(search);\n    if (strncmp(p,search,search_extent) != 0)\n      continue;\n    status=MagickTrue;\n    if (replace_extent == 0)\n      replace_extent=strlen(replace);\n    if (replace_extent > search_extent)\n      {\n        offset=(ssize_t) (p-(*string));\n        extent=strlen(*string)+replace_extent-search_extent+1;\n        *string=(char *) ResizeQuantumMemory(*string,extent+MagickPathExtent,\n          sizeof(*p));\n        if (*string == (char *) NULL)\n          ThrowFatalException(ResourceLimitFatalError,\"UnableToAcquireString\");\n        p=(*string)+offset;\n      }\n    if (search_extent != replace_extent)\n      (void) memmove(p+replace_extent,p+search_extent,\n        strlen(p+search_extent)+1);\n    (void) memcpy(p,replace,replace_extent);\n    p+=replace_extent-1;\n  }\n  return(status);\n}", "target": 1}
{"code": "    void resize (std::size_t new_size_) { _buf_size = new_size_; }", "target": 1}
{"code": "  bool ms_verify_authorizer(Connection *con, int peer_type, int protocol,\n                            bufferlist& authorizer, bufferlist& authorizer_reply,\n                            bool& isvalid, CryptoKey& session_key) override {\n    isvalid = true;\n    return true;\n  }", "target": 1}
{"code": "static inline int xrstor_state_booting(struct xsave_struct *fx, u64 mask)\n{\n\tu32 lmask = mask;\n\tu32 hmask = mask >> 32;\n\tint err = 0;\n\tWARN_ON(system_state != SYSTEM_BOOTING);\n\tif (boot_cpu_has(X86_FEATURE_XSAVES))\n\t\tasm volatile(\"1:\"XRSTORS\"\\n\\t\"\n\t\t\t\"2:\\n\\t\"\n\t\t\t: : \"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t\t:   \"memory\");\n\telse\n\t\tasm volatile(\"1:\"XRSTOR\"\\n\\t\"\n\t\t\t\"2:\\n\\t\"\n\t\t\t: : \"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t\t:   \"memory\");\n\tasm volatile(xstate_fault\n\t\t     : \"0\" (0)\n\t\t     : \"memory\");\n\treturn err;\n}", "target": 1}
{"code": "static MagickBooleanType WriteMSLImage(const ImageInfo *image_info,Image *image)\n{\n  Image\n    *msl_image;\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  msl_image=CloneImage(image,0,0,MagickTrue,&image->exception);\n  return(ProcessMSLScript(image_info,&msl_image,&image->exception));\n}", "target": 1}
{"code": "static void lsr_read_extend_class(GF_LASeRCodec *lsr, char **out_data, u32 *out_len, const char *name)\n{\n\tu32 len;\n\tGF_LSR_READ_INT(lsr, len, lsr->info->cfg.extensionIDBits, \"reserved\");\n\tlen = lsr_read_vluimsbf5(lsr, \"len\");\n\tgf_bs_read_long_int(lsr->bs, len);\n\tif (out_data) *out_data = NULL;\n\tif (out_len) *out_len = 0;\n}", "target": 1}
{"code": "static unsigned int floppy_check_events(struct gendisk *disk,\n\t\t\t\t\tunsigned int clearing)\n{\n\tint drive = (long)disk->private_data;\n\tif (test_bit(FD_DISK_CHANGED_BIT, &UDRS->flags) ||\n\t    test_bit(FD_VERIFY_BIT, &UDRS->flags))\n\t\treturn DISK_EVENT_MEDIA_CHANGE;\n\tif (time_after(jiffies, UDRS->last_checked + UDP->checkfreq)) {\n\t\tif (lock_fdc(drive))\n\t\t\treturn 0;\n\t\tpoll_drive(false, 0);\n\t\tprocess_fd_request();\n\t}\n\tif (test_bit(FD_DISK_CHANGED_BIT, &UDRS->flags) ||\n\t    test_bit(FD_VERIFY_BIT, &UDRS->flags) ||\n\t    test_bit(drive, &fake_change) ||\n\t    drive_no_geom(drive))\n\t\treturn DISK_EVENT_MEDIA_CHANGE;\n\treturn 0;\n}", "target": 0}
{"code": "Value ExpressionDateFromParts::evaluate(const Document& root, Variables* variables) const {\n    long long hour, minute, second, millisecond;\n    if (!evaluateNumberWithDefaultAndBounds(root, _hour.get(), \"hour\"_sd, 0, &hour, variables) ||\n        !evaluateNumberWithDefaultAndBounds(\n            root, _minute.get(), \"minute\"_sd, 0, &minute, variables) ||\n        !evaluateNumberWithDefault(root, _second.get(), \"second\"_sd, 0, &second, variables) ||\n        !evaluateNumberWithDefault(\n            root, _millisecond.get(), \"millisecond\"_sd, 0, &millisecond, variables)) {\n        return Value(BSONNULL);\n    }\n    auto timeZone =\n        makeTimeZone(getExpressionContext()->timeZoneDatabase, root, _timeZone.get(), variables);\n    if (!timeZone) {\n        return Value(BSONNULL);\n    }\n    if (_year) {\n        long long year, month, day;\n        if (!evaluateNumberWithDefault(root, _year.get(), \"year\"_sd, 1970, &year, variables) ||\n            !evaluateNumberWithDefaultAndBounds(\n                root, _month.get(), \"month\"_sd, 1, &month, variables) ||\n            !evaluateNumberWithDefaultAndBounds(root, _day.get(), \"day\"_sd, 1, &day, variables)) {\n            return Value(BSONNULL);\n        }\n        uassert(40523,\n                str::stream() << \"'year' must evaluate to an integer in the range \" << 1 << \" to \"\n                              << 9999 << \", found \" << year,\n                year >= 1 && year <= 9999);\n        return Value(\n            timeZone->createFromDateParts(year, month, day, hour, minute, second, millisecond));\n    }\n    if (_isoWeekYear) {\n        long long isoWeekYear, isoWeek, isoDayOfWeek;\n        if (!evaluateNumberWithDefault(\n                root, _isoWeekYear.get(), \"isoWeekYear\"_sd, 1970, &isoWeekYear, variables) ||\n            !evaluateNumberWithDefaultAndBounds(\n                root, _isoWeek.get(), \"isoWeek\"_sd, 1, &isoWeek, variables) ||\n            !evaluateNumberWithDefaultAndBounds(\n                root, _isoDayOfWeek.get(), \"isoDayOfWeek\"_sd, 1, &isoDayOfWeek, variables)) {\n            return Value(BSONNULL);\n        }\n        uassert(31095,\n                str::stream() << \"'isoWeekYear' must evaluate to an integer in the range \" << 1\n                              << \" to \" << 9999 << \", found \" << isoWeekYear,\n                isoWeekYear >= 1 && isoWeekYear <= 9999);\n        return Value(timeZone->createFromIso8601DateParts(\n            isoWeekYear, isoWeek, isoDayOfWeek, hour, minute, second, millisecond));\n    }\n    MONGO_UNREACHABLE;\n}", "target": 0}
{"code": "static int decode_trns_chunk(AVCodecContext *avctx, PNGDecContext *s,\n                             uint32_t length)\n{\n    int v, i;\n    if (s->color_type == PNG_COLOR_TYPE_PALETTE) {\n        if (length > 256 || !(s->state & PNG_PLTE))\n            return AVERROR_INVALIDDATA;\n        for (i = 0; i < length; i++) {\n            v = bytestream2_get_byte(&s->gb);\n            s->palette[i] = (s->palette[i] & 0x00ffffff) | (v << 24);\n        }\n    } else if (s->color_type == PNG_COLOR_TYPE_GRAY || s->color_type == PNG_COLOR_TYPE_RGB) {\n        if ((s->color_type == PNG_COLOR_TYPE_GRAY && length != 2) ||\n            (s->color_type == PNG_COLOR_TYPE_RGB && length != 6))\n            return AVERROR_INVALIDDATA;\n        for (i = 0; i < length / 2; i++) {\n            v = av_mod_uintp2(bytestream2_get_be16(&s->gb), s->bit_depth);\n            if (s->bit_depth > 8)\n                AV_WB16(&s->transparent_color_be[2 * i], v);\n            else\n                s->transparent_color_be[i] = v;\n        }\n    } else {\n        return AVERROR_INVALIDDATA;\n    }\n    bytestream2_skip(&s->gb, 4); \n    s->has_trns = 1;\n    return 0;\n}", "target": 1}
{"code": "sanitize_filename (const char *file_name)\n{\n\tsize_t      prefix_len;\n\tchar const *p;\n\tif (file_name == NULL)\n\t\treturn NULL;\n\tprefix_len = 0;\n\tfor (p = file_name; *p; ) {\n\t\tif (ISDOT (p[0]) && ISDOT (p[1]) && (ISSLASH (p[2]) || !p[2]))\n\t\t\tprefix_len = p + 2 - file_name;\n\t\tdo {\n\t\t\tchar c = *p++;\n\t\t\tif (ISSLASH (c))\n\t\t\t\tbreak;\n\t\t}\n\t\twhile (*p);\n\t}\n\tp = file_name + prefix_len;\n\twhile (ISSLASH (*p))\n\t\tp++;\n\treturn p;\n}", "target": 1}
{"code": "mwifiex_cmd_append_vsie_tlv(struct mwifiex_private *priv,\n\t\t\t    u16 vsie_mask, u8 **buffer)\n{\n\tint id, ret_len = 0;\n\tstruct mwifiex_ie_types_vendor_param_set *vs_param_set;\n\tif (!buffer)\n\t\treturn 0;\n\tif (!(*buffer))\n\t\treturn 0;\n\tfor (id = 0; id < MWIFIEX_MAX_VSIE_NUM; id++) {\n\t\tif (priv->vs_ie[id].mask & vsie_mask) {\n\t\t\tvs_param_set =\n\t\t\t\t(struct mwifiex_ie_types_vendor_param_set *)\n\t\t\t\t*buffer;\n\t\t\tvs_param_set->header.type =\n\t\t\t\tcpu_to_le16(TLV_TYPE_PASSTHROUGH);\n\t\t\tvs_param_set->header.len =\n\t\t\t\tcpu_to_le16((((u16) priv->vs_ie[id].ie[1])\n\t\t\t\t& 0x00FF) + 2);\n\t\t\tmemcpy(vs_param_set->ie, priv->vs_ie[id].ie,\n\t\t\t       le16_to_cpu(vs_param_set->header.len));\n\t\t\t*buffer += le16_to_cpu(vs_param_set->header.len) +\n\t\t\t\t   sizeof(struct mwifiex_ie_types_header);\n\t\t\tret_len += le16_to_cpu(vs_param_set->header.len) +\n\t\t\t\t   sizeof(struct mwifiex_ie_types_header);\n\t\t}\n\t}\n\treturn ret_len;\n}", "target": 1}
{"code": "smb2_create_lease_buf(u8 *lease_key, u8 oplock)\n{\n\tstruct create_lease *buf;\n\tbuf = kzalloc(sizeof(struct create_lease), GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\tmemcpy(&buf->lcontext.LeaseKey, lease_key, SMB2_LEASE_KEY_SIZE);\n\tbuf->lcontext.LeaseState = map_oplock_to_lease(oplock);\n\tbuf->ccontext.DataOffset = cpu_to_le16(offsetof\n\t\t\t\t\t(struct create_lease, lcontext));\n\tbuf->ccontext.DataLength = cpu_to_le32(sizeof(struct lease_context));\n\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof\n\t\t\t\t(struct create_lease, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\tbuf->Name[0] = 'R';\n\tbuf->Name[1] = 'q';\n\tbuf->Name[2] = 'L';\n\tbuf->Name[3] = 's';\n\treturn (char *)buf;\n}", "target": 0}
{"code": "static int vidioc_try_fmt_out(struct file *file, void *priv, struct v4l2_format *fmt)\n{\n\tstruct v4l2_loopback_device *dev;\n\tMARK();\n\tdev = v4l2loopback_getdevice(file);\n\tif (dev->ready_for_capture) {\n\t\tfmt->fmt.pix = dev->pix_format;\n\t} else {\n\t\t__u32 w = fmt->fmt.pix.width;\n\t\t__u32 h = fmt->fmt.pix.height;\n\t\t__u32 pixfmt = fmt->fmt.pix.pixelformat;\n\t\tconst struct v4l2l_format *format = format_by_fourcc(pixfmt);\n\t\tif (w > max_width)\n\t\t\tw = max_width;\n\t\tif (h > max_height)\n\t\t\th = max_height;\n\t\tdprintk(\"trying image %dx%d\\n\", w, h);\n\t\tif (w < 1)\n\t\t\tw = V4L2LOOPBACK_SIZE_DEFAULT_WIDTH;\n\t\tif (h < 1)\n\t\t\th = V4L2LOOPBACK_SIZE_DEFAULT_HEIGHT;\n\t\tif (NULL == format)\n\t\t\tformat = &formats[0];\n\t\tpix_format_set_size(&fmt->fmt.pix, format, w, h);\n\t\tfmt->fmt.pix.pixelformat = format->fourcc;\n\t\tfmt->fmt.pix.colorspace = V4L2_COLORSPACE_SRGB;\n\t\tif (V4L2_FIELD_ANY == fmt->fmt.pix.field)\n\t\t\tfmt->fmt.pix.field = V4L2_FIELD_NONE;\n\t\tdev->pix_format = fmt->fmt.pix;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void __do_SAK(struct tty_struct *tty)\n{\n#ifdef TTY_SOFT_SAK\n\ttty_hangup(tty);\n#else\n\tstruct task_struct *g, *p;\n\tstruct pid *session;\n\tint\t\ti;\n\tif (!tty)\n\t\treturn;\n\tsession = tty->session;\n\ttty_ldisc_flush(tty);\n\ttty_driver_flush_buffer(tty);\n\tread_lock(&tasklist_lock);\n\tdo_each_pid_task(session, PIDTYPE_SID, p) {\n\t\ttty_notice(tty, \"SAK: killed process %d (%s): by session\\n\",\n\t\t\t   task_pid_nr(p), p->comm);\n\t\tgroup_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_SID);\n\t} while_each_pid_task(session, PIDTYPE_SID, p);\n\tdo_each_thread(g, p) {\n\t\tif (p->signal->tty == tty) {\n\t\t\ttty_notice(tty, \"SAK: killed process %d (%s): by controlling tty\\n\",\n\t\t\t\t   task_pid_nr(p), p->comm);\n\t\t\tgroup_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_SID);\n\t\t\tcontinue;\n\t\t}\n\t\ttask_lock(p);\n\t\ti = iterate_fd(p->files, 0, this_tty, tty);\n\t\tif (i != 0) {\n\t\t\ttty_notice(tty, \"SAK: killed process %d (%s): by fd#%d\\n\",\n\t\t\t\t   task_pid_nr(p), p->comm, i - 1);\n\t\t\tgroup_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_SID);\n\t\t}\n\t\ttask_unlock(p);\n\t} while_each_thread(g, p);\n\tread_unlock(&tasklist_lock);\n#endif\n}", "target": 1}
{"code": "static inline void pmd_free(struct mm_struct *mm, pmd_t *pmd)\n{\n\tpgtable_pmd_page_dtor(virt_to_page(pmd));\n\tcrst_table_free(mm, (unsigned long *) pmd);\n}", "target": 0}
{"code": "rgb2bgr16(UINT8 *out_, const UINT8 *in, int xsize) {\n    int x;\n    for (x = 0; x < xsize; x++, in += 4, out_ += 2) {\n        UINT16 v = ((((UINT16)in[0]) << 8) & 0xf800) +\n                   ((((UINT16)in[1]) << 3) & 0x07e0) +\n                   ((((UINT16)in[2]) >> 3) & 0x001f);\n        memcpy(out_, &v, sizeof(v));\n    }\n}", "target": 0}
{"code": "string DebugString(gtl::ArraySlice<NodeDef> instantiated_func_nodes) {\n  std::vector<const NodeDef*> ptrs;\n  for (const NodeDef& n : instantiated_func_nodes) {\n    ptrs.push_back(&n);\n  }\n  return Print(ptrs);\n}", "target": 0}
{"code": "ssize_t enc_untrusted_read(int fd, void *buf, size_t count) {\n  return static_cast<ssize_t>(EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_read, fd, buf, count));\n}", "target": 1}
{"code": "send_userauth_info_request(Authctxt *authctxt)\n{\n\tKbdintAuthctxt *kbdintctxt;\n\tchar *name, *instr, **prompts;\n\tint i;\n\tu_int *echo_on;\n\tkbdintctxt = authctxt->kbdintctxt;\n\tif (kbdintctxt->device->query(kbdintctxt->ctxt,\n\t    &name, &instr, &kbdintctxt->nreq, &prompts, &echo_on))\n\t\treturn 0;\n\tpacket_start(SSH2_MSG_USERAUTH_INFO_REQUEST);\n\tpacket_put_cstring(name);\n\tpacket_put_cstring(instr);\n\tpacket_put_cstring(\"\");\t\t\n\tpacket_put_int(kbdintctxt->nreq);\n\tfor (i = 0; i < kbdintctxt->nreq; i++) {\n\t\tpacket_put_cstring(prompts[i]);\n\t\tpacket_put_char(echo_on[i]);\n\t}\n\tpacket_send();\n\tpacket_write_wait();\n\tfor (i = 0; i < kbdintctxt->nreq; i++)\n\t\txfree(prompts[i]);\n\txfree(prompts);\n\txfree(echo_on);\n\txfree(name);\n\txfree(instr);\n\treturn 1;\n}", "target": 0}
{"code": "videobuf_vm_open(struct vm_area_struct *vma)\n{\n\tstruct videobuf_mapping *map = vma->vm_private_data;\n\tdprintk(2,\"vm_open %p [count=%d,vma=%08lx-%08lx]\\n\",map,\n\t\tmap->count,vma->vm_start,vma->vm_end);\n\tmap->count++;\n}", "target": 1}
{"code": "static void session_init_control(struct avrcp *session)\n{\n\tsession->passthrough_id = avctp_register_passthrough_handler(\n\t\t\t\t\t\t\tsession->conn,\n\t\t\t\t\t\t\thandle_passthrough,\n\t\t\t\t\t\t\tsession);\n\tsession->passthrough_handlers = passthrough_handlers;\n\tsession->control_id = avctp_register_pdu_handler(session->conn,\n\t\t\t\t\t\t\tAVC_OP_VENDORDEP,\n\t\t\t\t\t\t\thandle_vendordep_pdu,\n\t\t\t\t\t\t\tsession);\n\tsession->control_handlers = control_handlers;\n\tif (btd_device_get_service(session->dev, AVRCP_TARGET_UUID) != NULL)\n\t\tcontroller_init(session);\n\tif (btd_device_get_service(session->dev, AVRCP_REMOTE_UUID) != NULL)\n\t\ttarget_init(session);\n}", "target": 0}
{"code": "void license_decrypt_platform_challenge(rdpLicense* license)\n{\n\tCryptoRc4 rc4;\n\tlicense->PlatformChallenge->data = (BYTE*) malloc(license->EncryptedPlatformChallenge->length);\n\tlicense->PlatformChallenge->length = license->EncryptedPlatformChallenge->length;\n\trc4 = crypto_rc4_init(license->LicensingEncryptionKey, LICENSING_ENCRYPTION_KEY_LENGTH);\n\tcrypto_rc4(rc4, license->EncryptedPlatformChallenge->length,\n\t\t\tlicense->EncryptedPlatformChallenge->data,\n\t\t\tlicense->PlatformChallenge->data);\n\tcrypto_rc4_free(rc4);\n}", "target": 0}
{"code": "static void unmask_payload(handler_ctx *hctx) {\n    buffer * const b = hctx->frame.payload;\n    for (size_t i = 0, used = buffer_clen(b); i < used; ++i) {\n        b->ptr[i] ^= hctx->frame.ctl.mask[hctx->frame.ctl.mask_cnt];\n        hctx->frame.ctl.mask_cnt = (hctx->frame.ctl.mask_cnt + 1) % 4;\n    }\n}", "target": 0}
{"code": "static GF_Err BM_ParseGlobalQuantizer(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tGF_Node *node;\n\tGF_Command *com;\n\tGF_CommandField *inf;\n\tnode = gf_bifs_dec_node(codec, bs, NDT_SFWorldNode);\n\tif (!node) return GF_NON_COMPLIANT_BITSTREAM;\n\tif (codec->scenegraph->global_qp) {\n\t\tgf_node_unregister(codec->scenegraph->global_qp, NULL);\n\t}\n\tcodec->ActiveQP = NULL;\n\tcodec->scenegraph->global_qp = NULL;\n\tif (gf_node_get_tag(node) != TAG_MPEG4_QuantizationParameter) {\n\t\tgf_node_unregister(node, NULL);\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tcodec->ActiveQP = (M_QuantizationParameter *) node;\n\tcodec->ActiveQP->isLocal = 0;\n\tcodec->scenegraph->global_qp = node;\n\tnode->sgprivate->num_instances = 2;\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_GLOBAL_QUANTIZER);\n\tinf = gf_sg_command_field_new(com);\n\tinf->new_node = node;\n\tinf->field_ptr = &inf->new_node;\n\tinf->fieldType = GF_SG_VRML_SFNODE;\n\tgf_list_add(com_list, com);\n\treturn GF_OK;\n}", "target": 1}
{"code": "compile_string_node(Node* node, regex_t* reg)\n{\n  int r, len, prev_len, slen, ambig;\n  OnigEncoding enc = reg->enc;\n  UChar *p, *prev, *end;\n  StrNode* sn;\n  sn = NSTR(node);\n  if (sn->end <= sn->s)\n    return 0;\n  end = sn->end;\n  ambig = NSTRING_IS_AMBIG(node);\n  p = prev = sn->s;\n  prev_len = enclen(enc, p);\n  p += prev_len;\n  slen = 1;\n  for (; p < end; ) {\n    len = enclen(enc, p);\n    if (len == prev_len) {\n      slen++;\n    }\n    else {\n      r = add_compile_string(prev, prev_len, slen, reg, ambig);\n      if (r) return r;\n      prev  = p;\n      slen  = 1;\n      prev_len = len;\n    }\n    p += len;\n  }\n  return add_compile_string(prev, prev_len, slen, reg, ambig);\n}", "target": 1}
{"code": "int nsim_bpf(struct net_device *dev, struct netdev_bpf *bpf)\n{\n\tstruct netdevsim *ns = netdev_priv(dev);\n\tint err;\n\tASSERT_RTNL();\n\tswitch (bpf->command) {\n\tcase XDP_SETUP_PROG:\n\t\terr = nsim_setup_prog_checks(ns, bpf);\n\t\tif (err)\n\t\t\treturn err;\n\t\treturn nsim_xdp_set_prog(ns, bpf, &ns->xdp);\n\tcase XDP_SETUP_PROG_HW:\n\t\terr = nsim_setup_prog_hw_checks(ns, bpf);\n\t\tif (err)\n\t\t\treturn err;\n\t\treturn nsim_xdp_set_prog(ns, bpf, &ns->xdp_hw);\n\tcase BPF_OFFLOAD_MAP_ALLOC:\n\t\tif (!ns->bpf_map_accept)\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn nsim_bpf_map_alloc(ns, bpf->offmap);\n\tcase BPF_OFFLOAD_MAP_FREE:\n\t\tnsim_bpf_map_free(bpf->offmap);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}", "target": 0}
{"code": "dissect_spoolss_uint16uni(tvbuff_t *tvb, int offset, packet_info *pinfo _U_,\n\t\t\t  proto_tree *tree, guint8 *drep _U_, char **data,\n\t\t\t  int hf_name)\n{\n\tgint len, remaining;\n\tchar *text;\n\tif (offset % 2)\n\t\toffset += 2 - (offset % 2);\n\tremaining = tvb_captured_length_remaining(tvb, offset);\n\tif (remaining <= 0) {\n\t\tif (data)\n\t\t\t*data = g_strdup(\"\");\n\t\treturn offset;\n\t}\n\ttext = tvb_get_string_enc(NULL, tvb, offset, remaining, ENC_UTF_16|ENC_LITTLE_ENDIAN);\n\tlen = (int)strlen(text);\n\tproto_tree_add_string(tree, hf_name, tvb, offset, len * 2, text);\n\tif (data)\n\t\t*data = text;\n\telse\n\t\tg_free(text);\n\treturn offset + (len + 1) * 2;\n}", "target": 1}
{"code": "_gnutls_server_name_recv_params (gnutls_session_t session,\n\t\t\t\t const opaque * data, size_t _data_size)\n{\n  int i;\n  const unsigned char *p;\n  uint16_t len, type;\n  ssize_t data_size = _data_size;\n  int server_names = 0;\n  if (session->security_parameters.entity == GNUTLS_SERVER)\n    {\n      DECR_LENGTH_RET (data_size, 2, 0);\n      len = _gnutls_read_uint16 (data);\n      if (len != data_size)\n\t{\n\t  gnutls_assert ();\n\t  return 0;\n\t}\n      p = data + 2;\n      while (data_size > 0)\n\t{\n\t  DECR_LENGTH_RET (data_size, 1, 0);\n\t  p++;\n\t  DECR_LEN (data_size, 2);\n\t  len = _gnutls_read_uint16 (p);\n\t  p += 2;\n\t  DECR_LENGTH_RET (data_size, len, 0);\n\t  server_names++;\n\t  p += len;\n\t}\n      session->security_parameters.extensions.server_names_size =\n\tserver_names;\n      if (server_names == 0)\n\treturn 0;\t\t\n      if (server_names > MAX_SERVER_NAME_EXTENSIONS)\n\tserver_names = MAX_SERVER_NAME_EXTENSIONS;\n      p = data + 2;\n      for (i = 0; i < server_names; i++)\n\t{\n\t  type = *p;\n\t  p++;\n\t  len = _gnutls_read_uint16 (p);\n\t  p += 2;\n\t  switch (type)\n\t    {\n\t    case 0:\t\t\n\t      if (len <= MAX_SERVER_NAME_SIZE)\n\t\t{\n\t\t  memcpy (session->security_parameters.extensions.\n\t\t\t  server_names[i].name, p, len);\n\t\t  session->security_parameters.extensions.\n\t\t    server_names[i].name_length = len;\n\t\t  session->security_parameters.extensions.\n\t\t    server_names[i].type = GNUTLS_NAME_DNS;\n\t\t  break;\n\t\t}\n\t    }\n\t  p += len;\n\t}\n    }\n  return 0;\n}", "target": 1}
{"code": "  const std::string& get_id() const {\n    ceph_assert(t != Wildcard && t != Tenant);\n    return u.id;\n  }", "target": 1}
{"code": "void ipmi_unregister_smi(struct ipmi_smi *intf)\n{\n\tstruct ipmi_smi_watcher *w;\n\tint intf_num = intf->intf_num, index;\n\tmutex_lock(&ipmi_interfaces_mutex);\n\tintf->intf_num = -1;\n\tintf->in_shutdown = true;\n\tlist_del_rcu(&intf->link);\n\tmutex_unlock(&ipmi_interfaces_mutex);\n\tsynchronize_srcu(&ipmi_interfaces_srcu);\n\tmutex_lock(&smi_watchers_mutex);\n\tlist_for_each_entry(w, &smi_watchers, link)\n\t\tw->smi_gone(intf_num);\n\tmutex_unlock(&smi_watchers_mutex);\n\tindex = srcu_read_lock(&intf->users_srcu);\n\twhile (!list_empty(&intf->users)) {\n\t\tstruct ipmi_user *user =\n\t\t\tcontainer_of(list_next_rcu(&intf->users),\n\t\t\t\t     struct ipmi_user, link);\n\t\t_ipmi_destroy_user(user);\n\t}\n\tsrcu_read_unlock(&intf->users_srcu, index);\n\tif (intf->handlers->shutdown)\n\t\tintf->handlers->shutdown(intf->send_info);\n\tcleanup_smi_msgs(intf);\n\tipmi_bmc_unregister(intf);\n\tcleanup_srcu_struct(&intf->users_srcu);\n\tkref_put(&intf->refcount, intf_free);\n}", "target": 0}
{"code": "static int hashtable_do_rehash(hashtable_t *hashtable)\n{\n    list_t *list, *next;\n    pair_t *pair;\n    size_t i, index, new_size;\n    jsonp_free(hashtable->buckets);\n    hashtable->num_buckets++;\n    new_size = num_buckets(hashtable);\n    hashtable->buckets = jsonp_malloc(new_size * sizeof(bucket_t));\n    if(!hashtable->buckets)\n        return -1;\n    for(i = 0; i < num_buckets(hashtable); i++)\n    {\n        hashtable->buckets[i].first = hashtable->buckets[i].last =\n            &hashtable->list;\n    }\n    list = hashtable->list.next;\n    list_init(&hashtable->list);\n    for(; list != &hashtable->list; list = next) {\n        next = list->next;\n        pair = list_to_pair(list);\n        index = pair->hash % new_size;\n        insert_to_bucket(hashtable, &hashtable->buckets[index], &pair->list);\n    }\n    return 0;\n}", "target": 1}
{"code": "map_oplock_to_lease(u8 oplock)\n{\n\tif (oplock == SMB2_OPLOCK_LEVEL_EXCLUSIVE)\n\t\treturn SMB2_LEASE_WRITE_CACHING_LE | SMB2_LEASE_READ_CACHING_LE;\n\telse if (oplock == SMB2_OPLOCK_LEVEL_II)\n\t\treturn SMB2_LEASE_READ_CACHING_LE;\n\telse if (oplock == SMB2_OPLOCK_LEVEL_BATCH)\n\t\treturn SMB2_LEASE_HANDLE_CACHING_LE | SMB2_LEASE_READ_CACHING_LE |\n\t\t       SMB2_LEASE_WRITE_CACHING_LE;\n\treturn 0;\n}", "target": 0}
{"code": "static void logi_dj_recv_destroy_djhid_device(struct dj_receiver_dev *djrcv_dev,\n\t\t\t\t\t\tstruct dj_report *dj_report)\n{\n\tstruct dj_device *dj_dev;\n\tunsigned long flags;\n\tspin_lock_irqsave(&djrcv_dev->lock, flags);\n\tdj_dev = djrcv_dev->paired_dj_devices[dj_report->device_index];\n\tdjrcv_dev->paired_dj_devices[dj_report->device_index] = NULL;\n\tspin_unlock_irqrestore(&djrcv_dev->lock, flags);\n\tif (dj_dev != NULL) {\n\t\thid_destroy_device(dj_dev->hdev);\n\t\tkfree(dj_dev);\n\t} else {\n\t\tdev_err(&djrcv_dev->hdev->dev, \"%s: can't destroy a NULL device\\n\",\n\t\t\t__func__);\n\t}\n}", "target": 0}
{"code": "comics_document_document_thumbnails_iface_init (EvDocumentThumbnailsInterface *iface)\n{\n\tiface->get_thumbnail = comics_document_thumbnails_get_thumbnail;\n\tiface->get_dimensions = comics_document_thumbnails_get_dimensions;\n}", "target": 1}
{"code": "int crxFreeImageData(CrxImage *img)\n{\n  CrxTile *tile = img->tiles;\n  int nTiles = img->tileRows * img->tileCols;\n  if (img->tiles)\n  {\n    for (int32_t curTile = 0; curTile < nTiles; curTile++, tile++)\n      if (tile[curTile].comps)\n        for (int32_t curPlane = 0; curPlane < img->nPlanes; curPlane++)\n          crxFreeSubbandData(img, tile[curTile].comps + curPlane);\n    free(img->tiles);\n    img->tiles = 0;\n  }\n  if (img->planeBuf)\n  {\n    free(img->planeBuf);\n    img->planeBuf = 0;\n  }\n  return 0;\n}", "target": 1}
{"code": "static inline void sem_getref(struct sem_array *sma)\n{\n\tspin_lock(&(sma)->sem_perm.lock);\n\tipc_rcu_getref(sma);\n\tipc_unlock(&(sma)->sem_perm);\n}", "target": 1}
{"code": "TEST_F(ExprMatchTest, ConstantFalseValueExpressionMatchesCorrectly) {\n    createMatcher(fromjson(\"{$expr: false}\"));\n    ASSERT_FALSE(matches(BSON(\"x\" << 2)));\n}", "target": 0}
{"code": "    bool wc2mb(UINT cp, std::string& str)\n    {\n        if (str.empty())\n            return true;\n        if (str.size() & 1) {\n#ifdef DEBUG\n            EXV_DEBUG << \"wc2mb: Size \" << str.size() << \" of input string is not even.\\n\";\n#endif\n            return false;\n        }\n        int len = WideCharToMultiByte(cp, 0, (LPCWSTR)str.data(), (int)str.size() / 2, 0, 0, 0, 0);\n        if (len == 0) {\n#ifdef DEBUG\n            EXV_DEBUG << \"wc2mb: Failed to determine required size of output buffer.\\n\";\n#endif\n            return false;\n        }\n        std::vector<std::string::value_type> out;\n        out.reserve(len);\n        int ret = WideCharToMultiByte(cp, 0, (LPCWSTR)str.data(), (int)str.size() / 2, (LPSTR)out.data(), len, 0, 0);\n        if (ret == 0) {\n#ifdef DEBUG\n            EXV_DEBUG << \"wc2mb: Failed to convert the input string to a multi byte string.\\n\";\n#endif\n            return false;\n        }\n        str.assign(out.data(), static_cast<size_t>(len));\n        return true;\n    }", "target": 0}
{"code": "struct request *blk_mq_tag_to_rq(struct blk_mq_tags *tags, unsigned int tag)\n{\n\tstruct request *rq = tags->rqs[tag];\n\tstruct blk_flush_queue *fq = blk_get_flush_queue(rq->q, rq->mq_ctx);\n\tif (!is_flush_request(rq, fq, tag))\n\t\treturn rq;\n\treturn fq->flush_rq;\n}", "target": 1}
{"code": "asmlinkage long compat_sys_ptrace(compat_long_t request, compat_long_t pid,\n\t\t\t\t  compat_long_t addr, compat_long_t data)\n{\n\tstruct task_struct *child;\n\tlong ret;\n\tif (request == PTRACE_TRACEME) {\n\t\tret = ptrace_traceme();\n\t\tgoto out;\n\t}\n\tchild = ptrace_get_task_struct(pid);\n\tif (IS_ERR(child)) {\n\t\tret = PTR_ERR(child);\n\t\tgoto out;\n\t}\n\tif (request == PTRACE_ATTACH || request == PTRACE_SEIZE) {\n\t\tret = ptrace_attach(child, request, addr, data);\n\t\tif (!ret)\n\t\t\tarch_ptrace_attach(child);\n\t\tgoto out_put_task_struct;\n\t}\n\tret = ptrace_check_attach(child, request == PTRACE_KILL ||\n\t\t\t\t  request == PTRACE_INTERRUPT);\n\tif (!ret)\n\t\tret = compat_arch_ptrace(child, request, addr, data);\n out_put_task_struct:\n\tput_task_struct(child);\n out:\n\treturn ret;\n}", "target": 1}
{"code": "void __qdisc_run(struct net_device *dev)\n{\n\tdo {\n\t\tif (!qdisc_restart(dev))\n\t\t\tbreak;\n\t} while (!netif_queue_stopped(dev));\n\tclear_bit(__LINK_STATE_QDISC_RUNNING, &dev->state);\n}", "target": 1}
{"code": "static void sixpack_close(struct tty_struct *tty)\n{\n\tstruct sixpack *sp;\n\twrite_lock_irq(&disc_data_lock);\n\tsp = tty->disc_data;\n\ttty->disc_data = NULL;\n\twrite_unlock_irq(&disc_data_lock);\n\tif (!sp)\n\t\treturn;\n\tif (!refcount_dec_and_test(&sp->refcnt))\n\t\twait_for_completion(&sp->dead);\n\tnetif_stop_queue(sp->dev);\n\tdel_timer_sync(&sp->tx_t);\n\tdel_timer_sync(&sp->resync_t);\n\tkfree(sp->rbuff);\n\tkfree(sp->xbuff);\n\tunregister_netdev(sp->dev);\n}", "target": 1}
{"code": "    const std::unordered_map<std::string, std::string> &getHeaders() const\n    {\n        return headers();\n    }", "target": 1}
{"code": "bool IsBlacklistedArg(const base::CommandLine::CharType* arg) {\n#if defined(OS_WIN)\n  const auto converted = base::WideToUTF8(arg);\n  const char* a = converted.c_str();\n#else\n  const char* a = arg;\n#endif\n  static const char* prefixes[] = {\"--\", \"-\", \"/\"};\n  int prefix_length = 0;\n  for (auto& prefix : prefixes) {\n    if (base::StartsWith(a, prefix, base::CompareCase::SENSITIVE)) {\n      prefix_length = strlen(prefix);\n      break;\n    }\n  }\n  if (prefix_length > 0) {\n    a += prefix_length;\n    std::string switch_name(a, strcspn(a, \"=\"));\n    auto* iter = std::lower_bound(std::begin(kBlacklist), std::end(kBlacklist),\n                                  switch_name);\n    if (iter != std::end(kBlacklist) && switch_name == *iter) {\n      return true;\n    }\n  }\n  return false;\n}", "target": 1}
{"code": "static int decode_fill(AACContext *ac, GetBitContext *gb, int len) {\n    uint8_t buf[256];\n    int i, major, minor;\n    if (len < 13+7*8)\n        goto unknown;\n    get_bits(gb, 13); len -= 13;\n    for(i=0; i+1<sizeof(buf) && len>=8; i++, len-=8)\n        buf[i] = get_bits(gb, 8);\n    buf[i] = 0;\n    if (ac->avctx->debug & FF_DEBUG_PICT_INFO)\n        av_log(ac->avctx, AV_LOG_DEBUG, \"FILL:%s\\n\", buf);\n    if (sscanf(buf, \"libfaac %d.%d\", &major, &minor) == 2){\n        ac->avctx->internal->skip_samples = 1024;\n    }\nunknown:\n    skip_bits_long(gb, len);\n    return 0;\n}", "target": 0}
{"code": "put_mech_oid(unsigned char **buf_out, gss_OID_const mech, unsigned int buflen)\n{\n\tif (buflen < mech->length + 2)\n\t\treturn (-1);\n\t*(*buf_out)++ = MECH_OID;\n\t*(*buf_out)++ = (unsigned char) mech->length;\n\tmemcpy(*buf_out, mech->elements, mech->length);\n\t*buf_out += mech->length;\n\treturn (0);\n}", "target": 0}
{"code": "bool PackLinuxElf32::calls_crt1(Elf32_Rel const *rel, int sz)\n{\n    if (!dynsym || !dynstr) {\n        return false;\n    }\n    for (unsigned relnum= 0; 0 < sz; (sz -= sizeof(Elf32_Rel)), ++rel, ++relnum) {\n        unsigned const symnum = get_te32(&rel->r_info) >> 8;\n        char const *const symnam = get_dynsym_name(symnum, relnum);\n        if (0==strcmp(symnam, \"__libc_start_main\")  \n        ||  0==strcmp(symnam, \"__libc_init\")  \n        ||  0==strcmp(symnam, \"__uClibc_main\")\n        ||  0==strcmp(symnam, \"__uClibc_start_main\"))\n            return true;\n    }\n    return false;\n}", "target": 1}
{"code": "get_u32_le(const void *vp)\n{\n\tconst u_char *p = (const u_char *)vp;\n\tu_int32_t v;\n\tv  = (u_int32_t)p[0];\n\tv |= (u_int32_t)p[1] << 8;\n\tv |= (u_int32_t)p[2] << 16;\n\tv |= (u_int32_t)p[3] << 24;\n\treturn (v);\n}", "target": 0}
{"code": "static void *my_malloc(size_t size)\n{\n    malloc_called += 1;\n    return malloc(size);\n}", "target": 1}
{"code": "static int gup_huge_pgd(pgd_t orig, pgd_t *pgdp, unsigned long addr,\n\t\t\tunsigned long end, int write,\n\t\t\tstruct page **pages, int *nr)\n{\n\tint refs;\n\tstruct page *head, *page;\n\tif (!pgd_access_permitted(orig, write))\n\t\treturn 0;\n\tBUILD_BUG_ON(pgd_devmap(orig));\n\trefs = 0;\n\tpage = pgd_page(orig) + ((addr & ~PGDIR_MASK) >> PAGE_SHIFT);\n\tdo {\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\t\tpage++;\n\t\trefs++;\n\t} while (addr += PAGE_SIZE, addr != end);\n\thead = compound_head(pgd_page(orig));\n\tif (!page_cache_add_speculative(head, refs)) {\n\t\t*nr -= refs;\n\t\treturn 0;\n\t}\n\tif (unlikely(pgd_val(orig) != pgd_val(*pgdp))) {\n\t\t*nr -= refs;\n\t\twhile (refs--)\n\t\t\tput_page(head);\n\t\treturn 0;\n\t}\n\tSetPageReferenced(head);\n\treturn 1;\n}", "target": 1}
{"code": "  virtual void SetUpCommandLine(CommandLine* command_line) {\n    GpuFeatureTest::SetUpCommandLine(command_line);\n    command_line->AppendSwitch(switches::kEnableThreadedCompositing);\n  }", "target": 1}
{"code": "static ssize_t ppp_read(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct ppp_file *pf = file->private_data;\n\tDECLARE_WAITQUEUE(wait, current);\n\tssize_t ret;\n\tstruct sk_buff *skb = NULL;\n\tstruct iovec iov;\n\tstruct iov_iter to;\n\tret = count;\n\tif (!pf)\n\t\treturn -ENXIO;\n\tadd_wait_queue(&pf->rwait, &wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tskb = skb_dequeue(&pf->rq);\n\t\tif (skb)\n\t\t\tbreak;\n\t\tret = 0;\n\t\tif (pf->dead)\n\t\t\tbreak;\n\t\tif (pf->kind == INTERFACE) {\n\t\t\tstruct ppp *ppp = PF_TO_PPP(pf);\n\t\t\tif (ppp->n_channels == 0 &&\n\t\t\t    (ppp->flags & SC_LOOP_TRAFFIC) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = -EAGAIN;\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\tbreak;\n\t\tret = -ERESTARTSYS;\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\tschedule();\n\t}\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(&pf->rwait, &wait);\n\tif (!skb)\n\t\tgoto out;\n\tret = -EOVERFLOW;\n\tif (skb->len > count)\n\t\tgoto outf;\n\tret = -EFAULT;\n\tiov.iov_base = buf;\n\tiov.iov_len = count;\n\tiov_iter_init(&to, READ, &iov, 1, count);\n\tif (skb_copy_datagram_iter(skb, 0, &to, skb->len))\n\t\tgoto outf;\n\tret = skb->len;\n outf:\n\tkfree_skb(skb);\n out:\n\treturn ret;\n}", "target": 0}
{"code": "TIFFOpenW(const wchar_t* name, const char* mode)\n{\n\tstatic const char module[] = \"TIFFOpenW\";\n\tthandle_t fd;\n\tint m;\n\tDWORD dwMode;\n\tint mbsize;\n\tchar *mbname;\n\tTIFF *tif;\n\tm = _TIFFgetMode(mode, module);\n\tswitch(m) {\n\t\tcase O_RDONLY:\t\t\tdwMode = OPEN_EXISTING; break;\n\t\tcase O_RDWR:\t\t\tdwMode = OPEN_ALWAYS;   break;\n\t\tcase O_RDWR|O_CREAT:\t\tdwMode = OPEN_ALWAYS;   break;\n\t\tcase O_RDWR|O_TRUNC:\t\tdwMode = CREATE_ALWAYS; break;\n\t\tcase O_RDWR|O_CREAT|O_TRUNC:\tdwMode = CREATE_ALWAYS; break;\n\t\tdefault:\t\t\treturn ((TIFF*)0);\n\t}\n\tfd = (thandle_t)CreateFileW(name,\n\t\t(m == O_RDONLY)?GENERIC_READ:(GENERIC_READ|GENERIC_WRITE),\n\t\tFILE_SHARE_READ | FILE_SHARE_WRITE, NULL, dwMode,\n\t\t(m == O_RDONLY)?FILE_ATTRIBUTE_READONLY:FILE_ATTRIBUTE_NORMAL,\n\t\tNULL);\n\tif (fd == INVALID_HANDLE_VALUE) {\n\t\tTIFFErrorExt(0, module, \"%S: Cannot open\", name);\n\t\treturn ((TIFF *)0);\n\t}\n\tmbname = NULL;\n\tmbsize = WideCharToMultiByte(CP_ACP, 0, name, -1, NULL, 0, NULL, NULL);\n\tif (mbsize > 0) {\n\t\tmbname = (char *)_TIFFmalloc(mbsize);\n\t\tif (!mbname) {\n\t\t\tTIFFErrorExt(0, module,\n\t\t\t\"Can't allocate space for filename conversion buffer\");\n\t\t\treturn ((TIFF*)0);\n\t\t}\n\t\tWideCharToMultiByte(CP_ACP, 0, name, -1, mbname, mbsize,\n\t\t\t\t    NULL, NULL);\n\t}\n\ttif = TIFFFdOpen((int)fd,    \n\t\t\t (mbname != NULL) ? mbname : \"<unknown>\", mode);\n\tif(!tif)\n\t\tCloseHandle(fd);\n\t_TIFFfree(mbname);\n\treturn tif;\n}", "target": 0}
{"code": "bool CModules::GetModInfo(CModInfo& ModInfo, const CString& sModule,\n                          CString& sRetMsg) {\n    if (!ValidateModuleName(sModule, sRetMsg)) {\n        return false;\n    }\n    CString sModPath, sTmp;\n    bool bSuccess;\n    bool bHandled = false;\n    GLOBALMODULECALL(OnGetModInfo(ModInfo, sModule, bSuccess, sRetMsg),\n                     &bHandled);\n    if (bHandled) return bSuccess;\n    if (!FindModPath(sModule, sModPath, sTmp)) {\n        sRetMsg = t_f(\"Unable to find module {1}.\")(sModule);\n        return false;\n    }\n    return GetModPathInfo(ModInfo, sModule, sModPath, sRetMsg);\n}", "target": 0}
{"code": "static void _cmd_window_show_opt(const char *data, int right)\n{\n\tMAIN_WINDOW_REC *parent;\n\tWINDOW_REC *window;\n\tif (*data == '\\0') cmd_return_error(CMDERR_NOT_ENOUGH_PARAMS);\n\tif (is_numeric(data, '\\0')) {\n\t\twindow = window_find_refnum(atoi(data));\n\t\tif (window == NULL) {\n\t\t\tprintformat_window(active_win, MSGLEVEL_CLIENTERROR,\n\t\t\t\t\t   TXT_REFNUM_NOT_FOUND, data);\n\t\t}\n\t} else {\n\t\twindow = window_find_item(active_win->active_server, data);\n\t}\n\tif (window == NULL || is_window_visible(window))\n\t\treturn;\n\tif (WINDOW_GUI(window)->sticky) {\n\t\tif (!settings_get_bool(\"autounstick_windows\")) {\n\t\t\tprintformat_window(active_win, MSGLEVEL_CLIENTERROR,\n\t\t\t\t\t   TXT_CANT_SHOW_STICKY_WINDOWS);\n\t\t\treturn;\n\t\t}\n\t}\n\tparent = mainwindow_create(right);\n\tparent->active = window;\n\tgui_window_reparent(window, parent);\n\tif (settings_get_bool(\"autostick_split_windows\"))\n\t\tgui_window_set_sticky(window);\n\tactive_mainwin = NULL;\n\twindow_set_active(window);\n}", "target": 1}
{"code": "ospf_header_dump (struct ospf_header *ospfh)\n{\n  char buf[9];\n  u_int16_t auth_type = ntohs (ospfh->auth_type);\n  zlog_debug (\"Header\");\n  zlog_debug (\"  Version %d\", ospfh->version);\n  zlog_debug (\"  Type %d (%s)\", ospfh->type,\n\t     LOOKUP (ospf_packet_type_str, ospfh->type));\n  zlog_debug (\"  Packet Len %d\", ntohs (ospfh->length));\n  zlog_debug (\"  Router ID %s\", inet_ntoa (ospfh->router_id));\n  zlog_debug (\"  Area ID %s\", inet_ntoa (ospfh->area_id));\n  zlog_debug (\"  Checksum 0x%x\", ntohs (ospfh->checksum));\n  zlog_debug (\"  AuType %s\", LOOKUP (ospf_auth_type_str, auth_type));\n  switch (auth_type)\n    {\n    case OSPF_AUTH_NULL:\n      break;\n    case OSPF_AUTH_SIMPLE:\n      memset (buf, 0, 9);\n      strncpy (buf, (char *) ospfh->u.auth_data, 8);\n      zlog_debug (\"  Simple Password %s\", buf);\n      break;\n    case OSPF_AUTH_CRYPTOGRAPHIC:\n      zlog_debug (\"  Cryptographic Authentication\");\n      zlog_debug (\"  Key ID %d\", ospfh->u.crypt.key_id);\n      zlog_debug (\"  Auth Data Len %d\", ospfh->u.crypt.auth_data_len);\n      zlog_debug (\"  Sequence number %ld\",\n\t\t (u_long)ntohl (ospfh->u.crypt.crypt_seqnum));\n      break;\n    default:\n      zlog_debug (\"* This is not supported authentication type\");\n      break;\n    }\n}", "target": 0}
{"code": "print_optimize_info(FILE* f, regex_t* reg)\n{\n  static const char* on[] = { \"NONE\", \"EXACT\", \"EXACT_BM\", \"EXACT_BM_NOT_REV\",\n                              \"EXACT_IC\", \"MAP\" };\n  fprintf(f, \"optimize: %s\\n\", on[reg->optimize]);\n  fprintf(f, \"  anchor: \"); print_anchor(f, reg->anchor);\n  if ((reg->anchor & ANCHOR_END_BUF_MASK) != 0)\n    print_distance_range(f, reg->anchor_dmin, reg->anchor_dmax);\n  fprintf(f, \"\\n\");\n  if (reg->optimize) {\n    fprintf(f, \"  sub anchor: \"); print_anchor(f, reg->sub_anchor);\n    fprintf(f, \"\\n\");\n  }\n  fprintf(f, \"\\n\");\n  if (reg->exact) {\n    UChar *p;\n    fprintf(f, \"exact: [\");\n    for (p = reg->exact; p < reg->exact_end; p++) {\n      fputc(*p, f);\n    }\n    fprintf(f, \"]: length: %ld\\n\", (reg->exact_end - reg->exact));\n  }\n  else if (reg->optimize & ONIG_OPTIMIZE_MAP) {\n    int c, i, n = 0;\n    for (i = 0; i < ONIG_CHAR_TABLE_SIZE; i++)\n      if (reg->map[i]) n++;\n    fprintf(f, \"map: n=%d\\n\", n);\n    if (n > 0) {\n      c = 0;\n      fputc('[', f);\n      for (i = 0; i < ONIG_CHAR_TABLE_SIZE; i++) {\n\tif (reg->map[i] != 0) {\n          if (c > 0)  fputs(\", \", f);\n          c++;\n          if (ONIGENC_MBC_MAXLEN(reg->enc) == 1 &&\n              ONIGENC_IS_CODE_PRINT(reg->enc, (OnigCodePoint )i))\n            fputc(i, f);\n          else\n            fprintf(f, \"%d\", i);\n        }\n      }\n      fprintf(f, \"]\\n\");\n    }\n  }\n}", "target": 0}
{"code": "static int bufp_alloc(USBRedirDevice *dev, uint8_t *data, uint16_t len,\n    uint8_t status, uint8_t ep, void *free_on_destroy)\n{\n    struct buf_packet *bufp;\n    if (!dev->endpoint[EP2I(ep)].bufpq_dropping_packets &&\n        dev->endpoint[EP2I(ep)].bufpq_size >\n            2 * dev->endpoint[EP2I(ep)].bufpq_target_size) {\n        DPRINTF(\"bufpq overflow, dropping packets ep %02X\\n\", ep);\n        dev->endpoint[EP2I(ep)].bufpq_dropping_packets = 1;\n    }\n    if (dev->endpoint[EP2I(ep)].bufpq_dropping_packets) {\n        if (dev->endpoint[EP2I(ep)].bufpq_size >\n                dev->endpoint[EP2I(ep)].bufpq_target_size) {\n            free(data);\n            return -1;\n        }\n        dev->endpoint[EP2I(ep)].bufpq_dropping_packets = 0;\n    }\n    bufp = g_new(struct buf_packet, 1);\n    bufp->data   = data;\n    bufp->len    = len;\n    bufp->offset = 0;\n    bufp->status = status;\n    bufp->free_on_destroy = free_on_destroy;\n    QTAILQ_INSERT_TAIL(&dev->endpoint[EP2I(ep)].bufpq, bufp, next);\n    dev->endpoint[EP2I(ep)].bufpq_size++;\n    return 0;\n}", "target": 1}
{"code": "void l2tp_packet_print(const struct l2tp_packet_t *pack,\n\t\t       void (*print)(const char *fmt, ...))\n{\n\tconst struct l2tp_attr_t *attr;\n\tconst struct l2tp_dict_value_t *val;\n\tif (pack->hdr.ver == 2) {\n\t\tprint(\"[L2TP tid=%u sid=%u\", ntohs(pack->hdr.tid), ntohs(pack->hdr.sid));\n\t\tlog_ppp_debug(\" Ns=%u Nr=%u\", ntohs(pack->hdr.Ns), ntohs(pack->hdr.Nr));\n\t} else {\n\t\tprint(\"[L2TP cid=%u\", pack->hdr.cid);\n\t\tlog_ppp_debug(\" Ns=%u Nr=%u\", ntohs(pack->hdr.Ns), ntohs(pack->hdr.Nr));\n\t}\n\tlist_for_each_entry(attr, &pack->attrs, entry) {\n\t\tprint(\" <%s\", attr->attr->name);\n\t\tval = l2tp_dict_find_value(attr->attr, attr->val);\n\t\tif (val)\n\t\t\tprint(\" %s\", val->name);\n\t\telse if (attr->H)\n\t\t\tprint(\" (hidden, %hu bytes)\", attr->length);\n\t\telse {\n\t\t\tswitch (attr->attr->type) {\n\t\t\t\tcase ATTR_TYPE_INT16:\n\t\t\t\t\tprint(\" %i\", attr->val.int16);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE_INT32:\n\t\t\t\t\tprint(\" %i\", attr->val.int32);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE_STRING:\n\t\t\t\t\tprint(\" %s\", attr->val.string);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprint(\">\");\n\t}\n\tprint(\"]\\n\");\n}", "target": 1}
{"code": "void nego_process_negotiation_response(rdpNego* nego, wStream* s)\n{\n\tUINT16 length;\n\tWLog_DBG(TAG, \"RDP_NEG_RSP\");\n\tif (Stream_GetRemainingLength(s) < 7)\n\t{\n\t\tWLog_ERR(TAG, \"Invalid RDP_NEG_RSP\");\n\t\tnego->state = NEGO_STATE_FAIL;\n\t\treturn;\n\t}\n\tStream_Read_UINT8(s, nego->flags);\n\tStream_Read_UINT16(s, length);\n\tStream_Read_UINT32(s, nego->SelectedProtocol);\n\tnego->state = NEGO_STATE_FINAL;\n}", "target": 1}
{"code": "static int snd_ctl_elem_user_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\tmutex_lock(&ue->card->user_ctl_lock);\n\tmemcpy(&ucontrol->value, ue->elem_data, ue->elem_data_size);\n\tmutex_unlock(&ue->card->user_ctl_lock);\n\treturn 0;\n}", "target": 0}
{"code": "static AVFrame *get_video_buffer(AVFilterLink *inlink, int w, int h)\n{\n    PadContext *s = inlink->dst->priv;\n    AVFrame *frame = ff_get_video_buffer(inlink->dst->outputs[0],\n                                         w + (s->w - s->in_w),\n                                         h + (s->h - s->in_h));\n    int plane;\n    if (!frame)\n        return NULL;\n    frame->width  = w;\n    frame->height = h;\n    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {\n        int hsub = s->draw.hsub[plane];\n        int vsub = s->draw.vsub[plane];\n        frame->data[plane] += (s->x >> hsub) * s->draw.pixelstep[plane] +\n                              (s->y >> vsub) * frame->linesize[plane];\n    }\n    return frame;\n}", "target": 1}
{"code": "static void virtio_blk_handle_read(VirtIOBlockReq *req)\n{\n    BlockDriverAIOCB *acb;\n    uint64_t sector;\n    sector = ldq_p(&req->out->sector);\n    if (sector & req->dev->sector_mask) {\n        virtio_blk_rw_complete(req, -EIO);\n        return;\n    }\n    acb = bdrv_aio_readv(req->dev->bs, sector, &req->qiov,\n                         req->qiov.size / BDRV_SECTOR_SIZE,\n                         virtio_blk_rw_complete, req);\n    if (!acb) {\n        virtio_blk_rw_complete(req, -EIO);\n    }\n}", "target": 1}
{"code": "mountpoint_last(struct nameidata *nd, struct path *path)\n{\n\tint error = 0;\n\tstruct dentry *dentry;\n\tstruct dentry *dir = nd->path.dentry;\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tif (unlazy_walk(nd, NULL)) {\n\t\t\terror = -ECHILD;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tnd->flags &= ~LOOKUP_PARENT;\n\tif (unlikely(nd->last_type != LAST_NORM)) {\n\t\terror = handle_dots(nd, nd->last_type);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tdentry = dget(nd->path.dentry);\n\t\tgoto done;\n\t}\n\tmutex_lock(&dir->d_inode->i_mutex);\n\tdentry = d_lookup(dir, &nd->last);\n\tif (!dentry) {\n\t\tdentry = d_alloc(dir, &nd->last);\n\t\tif (!dentry) {\n\t\t\terror = -ENOMEM;\n\t\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\t\tgoto out;\n\t\t}\n\t\tdentry = lookup_real(dir->d_inode, dentry, nd->flags);\n\t\terror = PTR_ERR(dentry);\n\t\tif (IS_ERR(dentry)) {\n\t\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmutex_unlock(&dir->d_inode->i_mutex);\ndone:\n\tif (!dentry->d_inode || d_is_negative(dentry)) {\n\t\terror = -ENOENT;\n\t\tdput(dentry);\n\t\tgoto out;\n\t}\n\tpath->dentry = dentry;\n\tpath->mnt = mntget(nd->path.mnt);\n\tif (should_follow_link(dentry, nd->flags & LOOKUP_FOLLOW))\n\t\treturn 1;\n\tfollow_mount(path);\n\terror = 0;\nout:\n\tterminate_walk(nd);\n\treturn error;\n}", "target": 1}
{"code": "bool BlobURLRequestJob::ReadItem() {\n  if (remaining_bytes_ == 0)\n    return true;\n  if (item_index_ >= blob_data_->items().size()) {\n    NotifyFailure(net::ERR_FAILED);\n    return false;\n  }\n  bytes_to_read_ = ComputeBytesToRead();\n  if (bytes_to_read_ == 0) {\n    AdvanceItem();\n    return ReadItem();\n  }\n  const BlobData::Item& item = blob_data_->items().at(item_index_);\n  switch (item.type()) {\n    case BlobData::TYPE_DATA:\n      return ReadBytes(item);\n    case BlobData::TYPE_FILE:\n      return DispatchReadFile(item);\n    default:\n      DCHECK(false);\n      return false;\n  }\n}", "target": 0}
{"code": "  String_Obj Parser::parse_url_function_string()\n  {\n    std::string prefix(\"\");\n    if (lex< uri_prefix >()) {\n      prefix = std::string(lexed);\n    }\n    lex < optional_spaces >();\n    String_Obj url_string = parse_url_function_argument();\n    std::string suffix(\"\");\n    if (lex< real_uri_suffix >()) {\n      suffix = std::string(lexed);\n    }\n    std::string uri(\"\");\n    if (url_string) {\n      uri = url_string->to_string({ NESTED, 5 });\n    }\n    if (String_Schema* schema = Cast<String_Schema>(url_string)) {\n      String_Schema_Obj res = SASS_MEMORY_NEW(String_Schema, pstate);\n      res->append(SASS_MEMORY_NEW(String_Constant, pstate, prefix));\n      res->append(schema);\n      res->append(SASS_MEMORY_NEW(String_Constant, pstate, suffix));\n      return res;\n    } else {\n      std::string res = prefix + uri + suffix;\n      return SASS_MEMORY_NEW(String_Constant, pstate, res);\n    }\n  }", "target": 0}
{"code": "util_write_callback(int flags, char *ptr, size_t size, size_t nmemb, void *stream)\n{\n    CurlObject *self;\n    PyObject *arglist;\n    PyObject *result = NULL;\n    size_t ret = 0;     \n    PyObject *cb;\n    int total_size;\n    PYCURL_DECLARE_THREAD_STATE;\n    self = (CurlObject *)stream;\n    if (!PYCURL_ACQUIRE_THREAD())\n        return ret;\n    cb = flags ? self->h_cb : self->w_cb;\n    if (cb == NULL)\n        goto silent_error;\n    if (size <= 0 || nmemb <= 0)\n        goto done;\n    total_size = (int)(size * nmemb);\n    if (total_size < 0 || (size_t)total_size / size != nmemb) {\n        PyErr_SetString(ErrorObject, \"integer overflow in write callback\");\n        goto verbose_error;\n    }\n#if PY_MAJOR_VERSION >= 3\n    arglist = Py_BuildValue(\"(y#)\", ptr, total_size);\n#else\n    arglist = Py_BuildValue(\"(s#)\", ptr, total_size);\n#endif\n    if (arglist == NULL)\n        goto verbose_error;\n    result = PyEval_CallObject(cb, arglist);\n    Py_DECREF(arglist);\n    if (result == NULL)\n        goto verbose_error;\n    if (result == Py_None) {\n        ret = total_size;           \n    }\n    else if (PyInt_Check(result) || PyLong_Check(result)) {\n        ret = (size_t) PyLong_AsLong(result);\n    }\n    else {\n        PyErr_SetString(ErrorObject, \"write callback must return int or None\");\n        goto verbose_error;\n    }\ndone:\nsilent_error:\n    Py_XDECREF(result);\n    PYCURL_RELEASE_THREAD();\n    return ret;\nverbose_error:\n    PyErr_Print();\n    goto silent_error;\n}", "target": 0}
{"code": "QMimeData *ServerItem::toMimeData() const {\n\tQMimeData *mime = ServerItem::toMimeData(qsName, qsHostname, usPort);\n\tif (itType == FavoriteType)\n\t\tmime->setData(QLatin1String(\"OriginatedInMumble\"), QByteArray());\n\treturn mime;\n}", "target": 0}
{"code": "auto ReferenceHandle::New(Local<Value> value, MaybeLocal<Object> options) -> unique_ptr<ReferenceHandle> {\n\tauto inherit = ReadOption<bool>(options, StringTable::Get().inheritUnsafe, false);\n\treturn std::make_unique<ReferenceHandle>(value, inherit);\n}", "target": 1}
{"code": "static int sctp_setsockopt_partial_delivery_point(struct sock *sk,\n\t\t\t\t\t\t  char __user *optval,\n\t\t\t\t\t\t  int optlen)\n{\n\tu32 val;\n\tif (optlen != sizeof(u32))\n\t\treturn -EINVAL;\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\tsctp_sk(sk)->pd_point = val;\n\treturn 0; \n}", "target": 0}
{"code": "static int32_t virtio_net_rsc_coalesce4(VirtioNetRscChain *chain,\n                                        VirtioNetRscSeg *seg,\n                                        const uint8_t *buf, size_t size,\n                                        VirtioNetRscUnit *unit)\n{\n    struct ip_header *ip1, *ip2;\n    ip1 = (struct ip_header *)(unit->ip);\n    ip2 = (struct ip_header *)(seg->unit.ip);\n    if ((ip1->ip_src ^ ip2->ip_src) || (ip1->ip_dst ^ ip2->ip_dst)\n        || (unit->tcp->th_sport ^ seg->unit.tcp->th_sport)\n        || (unit->tcp->th_dport ^ seg->unit.tcp->th_dport)) {\n        chain->stat.no_match++;\n        return RSC_NO_MATCH;\n    }\n    return virtio_net_rsc_coalesce_data(chain, seg, buf, unit);\n}", "target": 0}
{"code": "void rose_stop_timer(struct sock *sk)\n{\n\tdel_timer(&rose_sk(sk)->timer);\n}", "target": 1}
{"code": "int avrcp_set_volume(struct btd_device *dev, int8_t volume, bool notify)\n{\n\tstruct avrcp_server *server;\n\tstruct avrcp *session;\n\tuint8_t buf[AVRCP_HEADER_LENGTH + 1];\n\tstruct avrcp_header *pdu = (void *) buf;\n\tif (volume < 0)\n\t\treturn -EINVAL;\n\tserver = find_server(servers, device_get_adapter(dev));\n\tif (server == NULL)\n\t\treturn -EINVAL;\n\tsession = find_session(server->sessions, dev);\n\tif (session == NULL)\n\t\treturn -ENOTCONN;\n\tif (notify) {\n\t\tif (!session->target)\n\t\t\treturn -ENOTSUP;\n\t\treturn avrcp_event(session, AVRCP_EVENT_VOLUME_CHANGED,\n\t\t\t\t\t\t\t\t&volume);\n\t}\n\tif (!session->controller && !avrcp_event_registered(session,\n\t\t\t\t\tAVRCP_EVENT_VOLUME_CHANGED))\n\t\treturn -ENOTSUP;\n\tmemset(buf, 0, sizeof(buf));\n\tset_company_id(pdu->company_id, IEEEID_BTSIG);\n\tpdu->pdu_id = AVRCP_SET_ABSOLUTE_VOLUME;\n\tpdu->params[0] = volume;\n\tpdu->params_len = htons(1);\n\treturn avctp_send_vendordep_req(session->conn,\n\t\t\t\t\tAVC_CTYPE_CONTROL, AVC_SUBUNIT_PANEL,\n\t\t\t\t\tbuf, sizeof(buf),\n\t\t\t\t\tavrcp_handle_set_volume, session);\n}", "target": 0}
{"code": "int yr_object_copy(\n    YR_OBJECT* object,\n    YR_OBJECT** object_copy)\n{\n  YR_OBJECT* copy;\n  YR_OBJECT* o;\n  YR_STRUCTURE_MEMBER* structure_member;\n  YR_OBJECT_FUNCTION* func;\n  YR_OBJECT_FUNCTION* func_copy;\n  int i;\n  *object_copy = NULL;\n  FAIL_ON_ERROR(yr_object_create(\n      object->type,\n      object->identifier,\n      NULL,\n      &copy));\n  switch(object->type)\n  {\n    case OBJECT_TYPE_INTEGER:\n      ((YR_OBJECT_INTEGER*) copy)->value = UNDEFINED;\n      break;\n    case OBJECT_TYPE_STRING:\n      ((YR_OBJECT_STRING*) copy)->value = NULL;\n      break;\n    case OBJECT_TYPE_FUNCTION:\n      func = (YR_OBJECT_FUNCTION*) object;\n      func_copy = (YR_OBJECT_FUNCTION*) copy;\n      FAIL_ON_ERROR_WITH_CLEANUP(\n        yr_object_copy(func->return_obj, &func_copy->return_obj),\n        yr_object_destroy(copy));\n      for (i = 0; i < MAX_OVERLOADED_FUNCTIONS; i++)\n        func_copy->prototypes[i] = func->prototypes[i];\n      break;\n    case OBJECT_TYPE_STRUCTURE:\n      structure_member = ((YR_OBJECT_STRUCTURE*) object)->members;\n      while (structure_member != NULL)\n      {\n        FAIL_ON_ERROR_WITH_CLEANUP(\n            yr_object_copy(structure_member->object, &o),\n            yr_object_destroy(copy));\n        FAIL_ON_ERROR_WITH_CLEANUP(\n            yr_object_structure_set_member(copy, o),\n            yr_free(o);\n            yr_object_destroy(copy));\n        structure_member = structure_member->next;\n      }\n      break;\n    case OBJECT_TYPE_ARRAY:\n      yr_object_copy(\n        ((YR_OBJECT_ARRAY *) object)->prototype_item,\n        &o);\n      ((YR_OBJECT_ARRAY *)copy)->prototype_item = o;\n      break;\n    case OBJECT_TYPE_DICTIONARY:\n      yr_object_copy(\n        ((YR_OBJECT_DICTIONARY *) object)->prototype_item,\n        &o);\n      ((YR_OBJECT_DICTIONARY *)copy)->prototype_item = o;\n      break;\n    default:\n      assert(FALSE);\n  }\n  *object_copy = copy;\n  return ERROR_SUCCESS;\n}", "target": 1}
{"code": "static bool imap_client_input_next_cmd(struct client *_client)\n{\n\tstruct imap_client *client = (struct imap_client *)_client;\n\tconst struct imap_arg *args;\n\tbool parsed;\n\tint ret;\n\tif (strcasecmp(client->cmd_name, \"AUTHENTICATE\") == 0) {\n\t\tret = cmd_authenticate(client, &parsed);\n\t\tif (ret == 0 && !parsed)\n\t\t\treturn FALSE;\n\t} else if (strcasecmp(client->cmd_name, \"ID\") == 0) {\n\t\tret = cmd_id(client);\n\t\tif (ret == 0)\n\t\t\treturn FALSE;\n\t\tif (ret < 0)\n\t\t\tret = 1; \n\t} else {\n\t\tret = client_parse_command(client, &args);\n\t\tif (ret < 0)\n\t\t\treturn TRUE;\n\t\tif (ret == 0)\n\t\t\treturn FALSE;\n\t\tret = *client->cmd_tag == '\\0' ? -1 :\n\t\t\tclient_command_execute(client, client->cmd_name, args);\n\t}\n\tclient->cmd_finished = TRUE;\n\tif (ret == -2 && strcasecmp(client->cmd_tag, \"LOGIN\") == 0) {\n\t\tclient_send_reply(&client->common, IMAP_CMD_REPLY_BAD,\n\t\t\t\"First parameter in line is IMAP's command tag, \"\n\t\t\t\"not the command name. Add that before the command, \"\n\t\t\t\"like: a login user pass\");\n\t} else if (ret < 0) {\n\t\tif (!client_invalid_command(client))\n\t\t\treturn FALSE;\n\t}\n\treturn ret != 0 && !client->common.destroyed;\n}", "target": 0}
{"code": "njs_json_parse(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    njs_int_t             ret;\n    njs_value_t           *text, value, lvalue;\n    const u_char          *p, *end;\n    njs_json_parse_t      *parse, json_parse;\n    const njs_value_t     *reviver;\n    njs_string_prop_t     string;\n    njs_json_parse_ctx_t  ctx;\n    parse = &json_parse;\n    text = njs_lvalue_arg(&lvalue, args, nargs, 1);\n    if (njs_slow_path(!njs_is_string(text))) {\n        ret = njs_value_to_string(vm, text, text);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n    }\n    (void) njs_string_prop(&string, text);\n    p = string.start;\n    end = p + string.size;\n    ctx.vm = vm;\n    ctx.pool = vm->mem_pool;\n    ctx.depth = NJS_JSON_MAX_DEPTH;\n    ctx.start = string.start;\n    ctx.end = end;\n    p = njs_json_skip_space(p, end);\n    if (njs_slow_path(p == end)) {\n        njs_json_parse_exception(&ctx, \"Unexpected end of input\", p);\n        return NJS_ERROR;\n    }\n    p = njs_json_parse_value(&ctx, &value, p);\n    if (njs_slow_path(p == NULL)) {\n        return NJS_ERROR;\n    }\n    p = njs_json_skip_space(p, end);\n    if (njs_slow_path(p != end)) {\n        njs_json_parse_exception(&ctx, \"Unexpected token\", p);\n        return NJS_ERROR;\n    }\n    reviver = njs_arg(args, nargs, 2);\n    if (njs_slow_path(njs_is_function(reviver) && njs_is_object(&value))) {\n        parse->function = njs_function(reviver);\n        parse->depth = 0;\n        return njs_json_parse_iterator(vm, parse, &value);\n    }\n    vm->retval = value;\n    return NJS_OK;\n}", "target": 1}
{"code": "void ntlm_free_message_fields_buffer(NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (fields)\n\t{\n\t\tif (fields->Buffer)\n\t\t{\n\t\t\tfree(fields->Buffer);\n\t\t\tfields->Len = 0;\n\t\t\tfields->MaxLen = 0;\n\t\t\tfields->Buffer = NULL;\n\t\t\tfields->BufferOffset = 0;\n\t\t}\n\t}\n}", "target": 1}
{"code": "static void xen_free_irq(unsigned irq)\n{\n\tstruct irq_info *info = info_for_irq(irq);\n\tunsigned long flags;\n\tif (WARN_ON(!info))\n\t\treturn;\n\twrite_lock_irqsave(&evtchn_rwlock, flags);\n\tif (!list_empty(&info->eoi_list))\n\t\tlateeoi_list_del(info);\n\tlist_del(&info->list);\n\tset_info_for_irq(irq, NULL);\n\tWARN_ON(info->refcnt > 0);\n\twrite_unlock_irqrestore(&evtchn_rwlock, flags);\n\tkfree(info);\n\tif (irq < nr_legacy_irqs())\n\t\treturn;\n\tirq_free_desc(irq);\n}", "target": 0}
{"code": "int gru_handle_user_call_os(unsigned long cb)\n{\n\tstruct gru_tlb_fault_handle *tfh;\n\tstruct gru_thread_state *gts;\n\tvoid *cbk;\n\tint ucbnum, cbrnum, ret = -EINVAL;\n\tSTAT(call_os);\n\tucbnum = get_cb_number((void *)cb);\n\tif ((cb & (GRU_HANDLE_STRIDE - 1)) || ucbnum >= GRU_NUM_CB)\n\t\treturn -EINVAL;\n\tgts = gru_find_lock_gts(cb);\n\tif (!gts)\n\t\treturn -EINVAL;\n\tgru_dbg(grudev, \"address 0x%lx, gid %d, gts 0x%p\\n\", cb, gts->ts_gru ? gts->ts_gru->gs_gid : -1, gts);\n\tif (ucbnum >= gts->ts_cbr_au_count * GRU_CBR_AU_SIZE)\n\t\tgoto exit;\n\tgru_check_context_placement(gts);\n\tif (gts->ts_gru && gts->ts_force_cch_reload) {\n\t\tgts->ts_force_cch_reload = 0;\n\t\tgru_update_cch(gts);\n\t}\n\tret = -EAGAIN;\n\tcbrnum = thread_cbr_number(gts, ucbnum);\n\tif (gts->ts_gru) {\n\t\ttfh = get_tfh_by_index(gts->ts_gru, cbrnum);\n\t\tcbk = get_gseg_base_address_cb(gts->ts_gru->gs_gru_base_vaddr,\n\t\t\t\tgts->ts_ctxnum, ucbnum);\n\t\tret = gru_user_dropin(gts, tfh, cbk);\n\t}\nexit:\n\tgru_unlock_gts(gts);\n\treturn ret;\n}", "target": 1}
{"code": "AP_CORE_DECLARE(void) ap_parse_uri(request_rec *r, const char *uri)\n{\n    int status = HTTP_OK;\n    r->unparsed_uri = apr_pstrdup(r->pool, uri);\n    while ((uri[0] == '/') && (uri[1] == '/')) {\n        ++uri ;\n    }\n    if (r->method_number == M_CONNECT) {\n        status = apr_uri_parse_hostinfo(r->pool, uri, &r->parsed_uri);\n    }\n    else {\n        status = apr_uri_parse(r->pool, uri, &r->parsed_uri);\n    }\n    if (status == APR_SUCCESS) {\n        if (r->parsed_uri.scheme\n            && !ap_cstr_casecmp(r->parsed_uri.scheme, ap_http_scheme(r))) {\n            r->hostname = r->parsed_uri.hostname;\n        }\n        else if (r->method_number == M_CONNECT) {\n            r->hostname = r->parsed_uri.hostname;\n        }\n        r->args = r->parsed_uri.query;\n        r->uri = r->parsed_uri.path ? r->parsed_uri.path\n                 : apr_pstrdup(r->pool, \"/\");\n#if defined(OS2) || defined(WIN32)\n        {\n            char *x;\n            for (x = r->uri; (x = strchr(x, '\\\\')) != NULL; )\n                *x = '/';\n        }\n#endif \n    }\n    else {\n        r->args = NULL;\n        r->hostname = NULL;\n        r->status = HTTP_BAD_REQUEST;             \n        r->uri = apr_pstrdup(r->pool, uri);\n    }\n}", "target": 1}
{"code": "check_vim9_unlet(char_u *name)\n{\n    if (name[1] != ':' || vim_strchr((char_u *)\"gwtb\", *name) == NULL)\n    {\n\tif (*name == 's' && !script_is_vim9())\n\t    return OK;\n\tsemsg(_(e_cannot_unlet_str), name);\n\treturn FAIL;\n    }\n    return OK;\n}", "target": 1}
{"code": "static int wrmsr_interception(struct vcpu_svm *svm)\n{\n\tstruct msr_data msr;\n\tu32 ecx = svm->vcpu.arch.regs[VCPU_REGS_RCX];\n\tu64 data = (svm->vcpu.arch.regs[VCPU_REGS_RAX] & -1u)\n\t\t| ((u64)(svm->vcpu.arch.regs[VCPU_REGS_RDX] & -1u) << 32);\n\tmsr.data = data;\n\tmsr.index = ecx;\n\tmsr.host_initiated = false;\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 2;\n\tif (svm_set_msr(&svm->vcpu, &msr)) {\n\t\ttrace_kvm_msr_write_ex(ecx, data);\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t} else {\n\t\ttrace_kvm_msr_write(ecx, data);\n\t\tskip_emulated_instruction(&svm->vcpu);\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "extractDirName(const StaticString &path) {\n\tchar *path_copy = strdup(path.c_str());\n\tchar *result = dirname(path_copy);\n\tstring result_string(result);\n\tfree(path_copy);\n\treturn result_string;\n}", "target": 0}
{"code": "yang_free_import(struct ly_ctx *ctx, struct lys_import *imp, uint8_t start, uint8_t size)\n{\n    uint8_t i;\n    for (i = start; i < size; ++i){\n        free((char *)imp[i].module);\n        lydict_remove(ctx, imp[i].prefix);\n        lydict_remove(ctx, imp[i].dsc);\n        lydict_remove(ctx, imp[i].ref);\n        lys_extension_instances_free(ctx, imp[i].ext, imp[i].ext_size, NULL);\n    }\n}", "target": 0}
{"code": "static int legacy_get_tree(struct fs_context *fc)\n{\n\tstruct legacy_fs_context *ctx = fc->fs_private;\n\tstruct super_block *sb;\n\tstruct dentry *root;\n\troot = fc->fs_type->mount(fc->fs_type, fc->sb_flags,\n\t\t\t\t      fc->source, ctx->legacy_data);\n\tif (IS_ERR(root))\n\t\treturn PTR_ERR(root);\n\tsb = root->d_sb;\n\tBUG_ON(!sb);\n\tfc->root = root;\n\treturn 0;\n}", "target": 0}
{"code": "static void override_ssh_variant(enum ssh_variant *ssh_variant)\n{\n\tconst char *variant = getenv(\"GIT_SSH_VARIANT\");\n\tif (!variant && git_config_get_string_const(\"ssh.variant\", &variant))\n\t\treturn;\n\tif (!strcmp(variant, \"auto\"))\n\t\t*ssh_variant = VARIANT_AUTO;\n\telse if (!strcmp(variant, \"plink\"))\n\t\t*ssh_variant = VARIANT_PLINK;\n\telse if (!strcmp(variant, \"putty\"))\n\t\t*ssh_variant = VARIANT_PUTTY;\n\telse if (!strcmp(variant, \"tortoiseplink\"))\n\t\t*ssh_variant = VARIANT_TORTOISEPLINK;\n\telse if (!strcmp(variant, \"simple\"))\n\t\t*ssh_variant = VARIANT_SIMPLE;\n\telse\n\t\t*ssh_variant = VARIANT_SSH;\n}", "target": 0}
{"code": "static int MVGMacroCompare(const void *target,const void *source)\n{\n  const char\n    *p,\n    *q;\n  p=(const char *) target;\n  q=(const char *) source;\n  return(strcmp(p,q));\n}", "target": 0}
{"code": "void tipc_node_stop(struct net *net)\n{\n\tstruct tipc_net *tn = tipc_net(net);\n\tstruct tipc_node *node, *t_node;\n\tspin_lock_bh(&tn->node_list_lock);\n\tlist_for_each_entry_safe(node, t_node, &tn->node_list, list)\n\t\ttipc_node_delete(node);\n\tspin_unlock_bh(&tn->node_list_lock);\n}", "target": 0}
{"code": "static av_always_inline float flt16_even(float pf)\n{\n    union av_intfloat32 tmp;\n    tmp.f = pf;\n    tmp.i = (tmp.i + 0x00007FFFU + (tmp.i & 0x00010000U >> 16)) & 0xFFFF0000U;\n    return tmp.f;\n}", "target": 0}
{"code": "static void usb_xhci_exit(PCIDevice *dev)\n{\n    int i;\n    XHCIState *xhci = XHCI(dev);\n    trace_usb_xhci_exit();\n    for (i = 0; i < xhci->numslots; i++) {\n        xhci_disable_slot(xhci, i + 1);\n    }\n    if (xhci->mfwrap_timer) {\n        timer_del(xhci->mfwrap_timer);\n        timer_free(xhci->mfwrap_timer);\n        xhci->mfwrap_timer = NULL;\n    }\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_cap);\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_oper);\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_runtime);\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_doorbell);\n    for (i = 0; i < xhci->numports; i++) {\n        XHCIPort *port = &xhci->ports[i];\n        memory_region_del_subregion(&xhci->mem, &port->mem);\n    }\n    if (dev->msix_table && dev->msix_pba\n        && dev->msix_entry_used) {\n        memory_region_del_subregion(&xhci->mem, &dev->msix_table_mmio);\n        memory_region_del_subregion(&xhci->mem, &dev->msix_pba_mmio);\n    }\n    usb_bus_release(&xhci->bus);\n}", "target": 1}
{"code": "plugin_init (Ekiga::KickStart& kickstart)\n{\n#ifdef DEBUG\n  gchar* path = g_build_path (G_DIR_SEPARATOR_S,\n\t\t\t      g_get_tmp_dir (), \"ekiga_debug_plugins\", NULL);\n  plugin_parse_directory (kickstart, path);\n  g_free (path);\n#else\n  plugin_parse_directory (kickstart,\n\t\t\t  EKIGA_PLUGIN_DIR);\n#endif\n}", "target": 1}
{"code": "RegexMatchExpression::RegexMatchExpression(StringData path, StringData regex, StringData options)\n    : LeafMatchExpression(REGEX, path),\n      _regex(regex.toString()),\n      _flags(options.toString()),\n      _re(new pcrecpp::RE(_regex.c_str(), flags2options(_flags.c_str()))) {\n    _init();\n}", "target": 0}
{"code": "struct extent_map *btrfs_get_chunk_map(struct btrfs_fs_info *fs_info,\n\t\t\t\t       u64 logical, u64 length)\n{\n\tstruct extent_map_tree *em_tree;\n\tstruct extent_map *em;\n\tem_tree = &fs_info->mapping_tree.map_tree;\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, logical, length);\n\tread_unlock(&em_tree->lock);\n\tif (!em) {\n\t\tbtrfs_crit(fs_info, \"unable to find logical %llu length %llu\",\n\t\t\t   logical, length);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tif (em->start > logical || em->start + em->len < logical) {\n\t\tbtrfs_crit(fs_info,\n\t\t\t   \"found a bad mapping, wanted %llu-%llu, found %llu-%llu\",\n\t\t\t   logical, length, em->start, em->start + em->len);\n\t\tfree_extent_map(em);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\treturn em;\n}", "target": 0}
{"code": "_gnutls_x509_encode_and_copy_PKI_params(ASN1_TYPE dst,\n\t\t\t\t\tconst char *dst_name,\n\t\t\t\t\tgnutls_pk_algorithm_t\n\t\t\t\t\tpk_algorithm,\n\t\t\t\t\tgnutls_pk_params_st * params)\n{\n\tconst char *pk;\n\tgnutls_datum_t der = { NULL, 0 };\n\tint result;\n\tchar name[128];\n\tpk = _gnutls_x509_pk_to_oid(pk_algorithm);\n\tif (pk == NULL) {\n\t\tgnutls_assert();\n\t\treturn GNUTLS_E_UNKNOWN_PK_ALGORITHM;\n\t}\n\t_asnstr_append_name(name, sizeof(name), dst_name,\n\t\t\t    \".algorithm.algorithm\");\n\tresult = asn1_write_value(dst, name, pk, 1);\n\tif (result != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\treturn _gnutls_asn2err(result);\n\t}\n\tresult =\n\t    _gnutls_x509_write_pubkey_params(pk_algorithm, params, &der);\n\tif (result < 0) {\n\t\tgnutls_assert();\n\t\treturn result;\n\t}\n\t_asnstr_append_name(name, sizeof(name), dst_name,\n\t\t\t    \".algorithm.parameters\");\n\tresult = asn1_write_value(dst, name, der.data, der.size);\n\t_gnutls_free_datum(&der);\n\tif (result != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\treturn _gnutls_asn2err(result);\n\t}\n\tresult = _gnutls_x509_write_pubkey(pk_algorithm, params, &der);\n\tif (result < 0) {\n\t\tgnutls_assert();\n\t\treturn result;\n\t}\n\t_asnstr_append_name(name, sizeof(name), dst_name,\n\t\t\t    \".subjectPublicKey\");\n\tresult = asn1_write_value(dst, name, der.data, der.size * 8);\n\t_gnutls_free_datum(&der);\n\tif (result != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\treturn _gnutls_asn2err(result);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void cql_server::response::write_string(std::string_view s)\n{\n    write_short(cast_if_fits<uint16_t>(s.size()));\n    _body.write(bytes_view(reinterpret_cast<const int8_t*>(s.data()), s.size()));\n}", "target": 0}
{"code": "ldbm_txn_ruv_modify_context( Slapi_PBlock *pb, modify_context *mc )\n{\n    char *uniqueid = NULL;\n    backend *be;\n    Slapi_Mods *smods = NULL;\n    struct backentry *bentry;\n    entry_address bentry_addr;\n    IFP fn = NULL;\n    int rc = 0;\n    back_txn txn = {NULL};\n    slapi_pblock_get(pb, SLAPI_TXN_RUV_MODS_FN, (void *)&fn);\n    slapi_pblock_get(pb, SLAPI_TXN, &txn.back_txn_txn);\n    if (NULL == fn) {\n        return (0);\n    }\n    rc = (*fn)(pb, &uniqueid, &smods);\n    if (1 != rc || NULL == smods || NULL == uniqueid) {\n        return (rc);\n    }\n    slapi_pblock_get( pb, SLAPI_BACKEND, &be);\n    bentry_addr.sdn = NULL;\n    bentry_addr.udn = NULL;\n    bentry_addr.uniqueid = uniqueid;\n    bentry = find_entry2modify_only( pb, be, &bentry_addr, &txn );\n    if (NULL == bentry) {\n        LDAPDebug( LDAP_DEBUG_ANY, \"Error: ldbm_txn_ruv_modify_context failed to retrieve and lock RUV entry\\n\",\n            0, 0, 0 );\n        rc = -1;\n        goto done;\n    }\n    modify_init( mc, bentry );\n    if (modify_apply_mods_ignore_error( mc, smods, LDAP_TYPE_OR_VALUE_EXISTS )) {\n        LDAPDebug( LDAP_DEBUG_ANY, \"Error: ldbm_txn_ruv_modify_context failed to apply updates to RUV entry\\n\",\n            0, 0, 0 );\n        rc = -1;\n        modify_term( mc, be );\n    }\ndone:\n    slapi_ch_free_string( &uniqueid );\n    return (rc);\n}", "target": 1}
{"code": "static inline void map_qs_metadata(struct req_state* s)\n{\n  const auto& params = const_cast<RGWHTTPArgs&>(s->info.args).get_params();\n  for (const auto& elt : params) {\n    std::string k = boost::algorithm::to_lower_copy(elt.first);\n    if (k.find(\"x-amz-meta-\") ==  0) {\n      add_amz_meta_header(s->info.x_meta_map, k, elt.second);\n    }\n  }\n}", "target": 0}
{"code": "bool Scanner::fill(size_t need)\n{\n    if (eof) return false;\n    pop_finished_files();\n    DASSERT(bot <= tok && tok <= lim);\n    size_t free = static_cast<size_t>(tok - bot);\n    size_t copy = static_cast<size_t>(lim - tok);\n    if (free >= need) {\n        memmove(bot, tok, copy);\n        shift_ptrs_and_fpos(-static_cast<ptrdiff_t>(free));\n    }\n    else {\n        BSIZE += std::max(BSIZE, need);\n        char * buf = new char[BSIZE + YYMAXFILL];\n        if (!buf) fatal(\"out of memory\");\n        memmove(buf, tok, copy);\n        shift_ptrs_and_fpos(buf - bot);\n        delete [] bot;\n        bot = buf;\n        free = BSIZE - copy;\n    }\n    if (!read(free)) {\n        eof = lim;\n        memset(lim, 0, YYMAXFILL);\n        lim += YYMAXFILL;\n    }\n    return true;\n}", "target": 1}
{"code": "static int sco_send_frame(struct sock *sk, struct msghdr *msg, int len)\n{\n\tstruct sco_conn *conn = sco_pi(sk)->conn;\n\tstruct sk_buff *skb;\n\tint err;\n\tif (len > conn->mtu)\n\t\treturn -EINVAL;\n\tBT_DBG(\"sk %p len %d\", sk, len);\n\tskb = bt_skb_send_alloc(sk, len, msg->msg_flags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\treturn err;\n\tif (memcpy_from_msg(skb_put(skb, len), msg, len)) {\n\t\tkfree_skb(skb);\n\t\treturn -EFAULT;\n\t}\n\thci_send_sco(conn->hcon, skb);\n\treturn len;\n}", "target": 1}
{"code": "static inline int check_sticky(struct inode *dir, struct inode *inode)\n{\n\tkuid_t fsuid = current_fsuid();\n\tif (!(dir->i_mode & S_ISVTX))\n\t\treturn 0;\n\tif (uid_eq(inode->i_uid, fsuid))\n\t\treturn 0;\n\tif (uid_eq(dir->i_uid, fsuid))\n\t\treturn 0;\n\treturn !inode_capable(inode, CAP_FOWNER);\n}", "target": 1}
{"code": "static uint8_t avrcp_handle_set_absolute_volume(struct avrcp *session,\n\t\t\t\t\t\tstruct avrcp_header *pdu,\n\t\t\t\t\t\tuint8_t transaction)\n{\n\tuint16_t len = ntohs(pdu->params_len);\n\tint8_t volume;\n\tif (len != 1)\n\t\tgoto err;\n\tvolume = pdu->params[0] & 0x7F;\n\tmedia_transport_update_device_volume(session->dev, volume);\n\treturn AVC_CTYPE_ACCEPTED;\nerr:\n\tpdu->params_len = htons(1);\n\tpdu->params[0] = AVRCP_STATUS_INVALID_PARAM;\n\treturn AVC_CTYPE_REJECTED;\n}", "target": 0}
{"code": "decode_labeled_vpn_clnp_prefix(netdissect_options *ndo,\n                               const u_char *pptr, char *buf, u_int buflen)\n{\n        uint8_t addr[19];\n\tu_int plen;\n\tND_TCHECK(pptr[0]);\n\tplen = pptr[0];   \n\tif ((24+64) > plen)\n\t\treturn -1;\n        plen-=(24+64); \n\tif (152 < plen)\n\t\treturn -1;\n\tmemset(&addr, 0, sizeof(addr));\n\tND_TCHECK2(pptr[12], (plen + 7) / 8);\n\tmemcpy(&addr, &pptr[12], (plen + 7) / 8);\n\tif (plen % 8) {\n\t\taddr[(plen + 7) / 8 - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n\tsnprintf(buf, buflen, \"RD: %s, %s/%d, label:%u %s\",\n                 bgp_vpn_rd_print(ndo, pptr+4),\n                 isonsap_string(ndo, addr,(plen + 7) / 8),\n                 plen,\n                 EXTRACT_24BITS(pptr+1)>>4,\n                 ((pptr[3]&1)==0) ? \"(BOGUS: Bottom of Stack NOT set!)\" : \"(bottom)\" );\n\treturn 12 + (plen + 7) / 8;\ntrunc:\n\treturn -2;\n}", "target": 0}
{"code": "static void drive_file_fix_path(WCHAR* path)\n{\n\tsize_t i;\n\tsize_t length = _wcslen(path);\n\tfor (i = 0; i < length; i++)\n\t{\n\t\tif (path[i] == L'\\\\')\n\t\t\tpath[i] = L'/';\n\t}\n#ifdef WIN32\n\tif ((length == 3) && (path[1] == L':') && (path[2] == L'/'))\n\t\treturn;\n#else\n\tif ((length == 1) && (path[0] == L'/'))\n\t\treturn;\n#endif\n\tif ((length > 0) && (path[length - 1] == L'/'))\n\t\tpath[length - 1] = L'\\0';\n}", "target": 1}
{"code": "xfs_attr_shortform_addname(xfs_da_args_t *args)\n{\n\tint newsize, forkoff, retval;\n\ttrace_xfs_attr_sf_addname(args);\n\tretval = xfs_attr_shortform_lookup(args);\n\tif ((args->flags & ATTR_REPLACE) && (retval == -ENOATTR)) {\n\t\treturn retval;\n\t} else if (retval == -EEXIST) {\n\t\tif (args->flags & ATTR_CREATE)\n\t\t\treturn retval;\n\t\tretval = xfs_attr_shortform_remove(args);\n\t\tASSERT(retval == 0);\n\t}\n\tif (args->namelen >= XFS_ATTR_SF_ENTSIZE_MAX ||\n\t    args->valuelen >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\treturn -ENOSPC;\n\tnewsize = XFS_ATTR_SF_TOTSIZE(args->dp);\n\tnewsize += XFS_ATTR_SF_ENTSIZE_BYNAME(args->namelen, args->valuelen);\n\tforkoff = xfs_attr_shortform_bytesfit(args->dp, newsize);\n\tif (!forkoff)\n\t\treturn -ENOSPC;\n\txfs_attr_shortform_add(args, forkoff);\n\treturn 0;\n}", "target": 1}
{"code": "static int do_nonlinear_fault(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long address, pte_t *page_table, pmd_t *pmd,\n\t\tint write_access, pte_t orig_pte)\n{\n\tunsigned int flags = FAULT_FLAG_NONLINEAR |\n\t\t\t\t(write_access ? FAULT_FLAG_WRITE : 0);\n\tpgoff_t pgoff;\n\tif (!pte_unmap_same(mm, pmd, page_table, orig_pte))\n\t\treturn 0;\n\tif (unlikely(!(vma->vm_flags & VM_NONLINEAR) ||\n\t\t\t!(vma->vm_flags & VM_CAN_NONLINEAR))) {\n\t\tprint_bad_pte(vma, orig_pte, address);\n\t\treturn VM_FAULT_OOM;\n\t}\n\tpgoff = pte_to_pgoff(orig_pte);\n\treturn __do_fault(mm, vma, address, pmd, pgoff, flags, orig_pte);\n}", "target": 0}
{"code": "static int present_and_same_family(const struct sadb_address *src,\n\t\t\t\t   const struct sadb_address *dst)\n{\n\tconst struct sockaddr *s_addr, *d_addr;\n\tif (!src || !dst)\n\t\treturn 0;\n\ts_addr = (const struct sockaddr *)(src + 1);\n\td_addr = (const struct sockaddr *)(dst + 1);\n\tif (s_addr->sa_family != d_addr->sa_family)\n\t\treturn 0;\n\tif (s_addr->sa_family != AF_INET\n#if IS_ENABLED(CONFIG_IPV6)\n\t    && s_addr->sa_family != AF_INET6\n#endif\n\t\t)\n\t\treturn 0;\n\treturn 1;\n}", "target": 0}
{"code": "ext4_xattr_release_block(handle_t *handle, struct inode *inode,\n\t\t\t struct buffer_head *bh)\n{\n\tstruct mb_cache_entry *ce = NULL;\n\tint error = 0;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\tce = mb_cache_entry_get(ext4_mb_cache, bh->b_bdev, bh->b_blocknr);\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terror = ext4_journal_get_write_access(handle, bh);\n\tif (error)\n\t\tgoto out;\n\tlock_buffer(bh);\n\tif (BHDR(bh)->h_refcount == cpu_to_le32(1)) {\n\t\tea_bdebug(bh, \"refcount now=0; freeing\");\n\t\tif (ce)\n\t\t\tmb_cache_entry_free(ce);\n\t\tget_bh(bh);\n\t\tunlock_buffer(bh);\n\t\text4_free_blocks(handle, inode, bh, 0, 1,\n\t\t\t\t EXT4_FREE_BLOCKS_METADATA |\n\t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\t} else {\n\t\tle32_add_cpu(&BHDR(bh)->h_refcount, -1);\n\t\tif (ce)\n\t\t\tmb_cache_entry_release(ce);\n\t\tif (ext4_handle_valid(handle))\n\t\t\terror = ext4_handle_dirty_xattr_block(handle, inode,\n\t\t\t\t\t\t\t      bh);\n\t\tunlock_buffer(bh);\n\t\tif (!ext4_handle_valid(handle))\n\t\t\terror = ext4_handle_dirty_xattr_block(handle, inode,\n\t\t\t\t\t\t\t      bh);\n\t\tif (IS_SYNC(inode))\n\t\t\text4_handle_sync(handle);\n\t\tdquot_free_block(inode, EXT4_C2B(EXT4_SB(inode->i_sb), 1));\n\t\tea_bdebug(bh, \"refcount now=%d; releasing\",\n\t\t\t  le32_to_cpu(BHDR(bh)->h_refcount));\n\t}\nout:\n\text4_std_error(inode->i_sb, error);\n\treturn;\n}", "target": 1}
{"code": "_dl_dst_substitute (struct link_map *l, const char *name, char *result,\n\t\t    int is_path)\n{\n  char *last_elem, *wp;\n  last_elem = wp = result;\n  do\n    {\n      if (*name == '$')\n\t{\n\t  const char *repl;\n\t  size_t len;\n\t  if ((((strncmp (&name[1], \"ORIGIN\", 6) == 0 && (len = 7) != 0)\n\t\t|| (strncmp (&name[1], \"PLATFORM\", 8) == 0 && (len = 9) != 0))\n\t       && (name[len] == '\\0' || name[len] == '/'\n\t\t   || (is_path && name[len] == ':')))\n\t      || (name[1] == '{'\n\t\t  && ((strncmp (&name[2], \"ORIGIN}\", 7) == 0 && (len = 9) != 0)\n\t\t      || (strncmp (&name[2], \"PLATFORM}\", 9) == 0\n\t\t\t  && (len = 11) != 0))))\n\t    {\n\t      repl = ((len == 7 || name[2] == 'O')\n\t\t      ? (__libc_enable_secure ? NULL : l->l_origin)\n\t\t      : _dl_platform);\n\t      if (repl != NULL && repl != (const char *) -1)\n\t\t{\n\t\t  wp = __stpcpy (wp, repl);\n\t\t  name += len;\n\t\t}\n\t      else\n\t\t{\n\t\t  wp = last_elem;\n\t\t  name += len;\n\t\t  while (*name != '\\0' && (!is_path || *name != ':'))\n\t\t    ++name;\n\t\t}\n\t    }\n\t  else\n\t    *wp++ = *name++;\n\t}\n      else if (is_path && *name == ':')\n\t{\n\t  *wp++ = *name++;\n\t  last_elem = wp;\n\t}\n      else\n\t*wp++ = *name++;\n    }\n  while (*name != '\\0');\n  *wp = '\\0';\n  return result;\n}", "target": 1}
{"code": "struct sctp_chunk *sctp_make_strreset_req(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\t__u16 stream_num, __be16 *stream_list,\n\t\t\t\t\tbool out, bool in)\n{\n\t__u16 stream_len = stream_num * sizeof(__u16);\n\tstruct sctp_strreset_outreq outreq;\n\tstruct sctp_strreset_inreq inreq;\n\tstruct sctp_chunk *retval;\n\t__u16 outlen, inlen;\n\toutlen = (sizeof(outreq) + stream_len) * out;\n\tinlen = (sizeof(inreq) + stream_len) * in;\n\tretval = sctp_make_reconf(asoc, outlen + inlen);\n\tif (!retval)\n\t\treturn NULL;\n\tif (outlen) {\n\t\toutreq.param_hdr.type = SCTP_PARAM_RESET_OUT_REQUEST;\n\t\toutreq.param_hdr.length = htons(outlen);\n\t\toutreq.request_seq = htonl(asoc->strreset_outseq);\n\t\toutreq.response_seq = htonl(asoc->strreset_inseq - 1);\n\t\toutreq.send_reset_at_tsn = htonl(asoc->next_tsn - 1);\n\t\tsctp_addto_chunk(retval, sizeof(outreq), &outreq);\n\t\tif (stream_len)\n\t\t\tsctp_addto_chunk(retval, stream_len, stream_list);\n\t}\n\tif (inlen) {\n\t\tinreq.param_hdr.type = SCTP_PARAM_RESET_IN_REQUEST;\n\t\tinreq.param_hdr.length = htons(inlen);\n\t\tinreq.request_seq = htonl(asoc->strreset_outseq + out);\n\t\tsctp_addto_chunk(retval, sizeof(inreq), &inreq);\n\t\tif (stream_len)\n\t\t\tsctp_addto_chunk(retval, stream_len, stream_list);\n\t}\n\treturn retval;\n}", "target": 1}
{"code": "sg_fill_request_table(Sg_fd *sfp, sg_req_info_t *rinfo)\n{\n\tSg_request *srp;\n\tint val;\n\tunsigned int ms;\n\tval = 0;\n\tlist_for_each_entry(srp, &sfp->rq_list, entry) {\n\t\tif (val > SG_MAX_QUEUE)\n\t\t\tbreak;\n\t\tmemset(&rinfo[val], 0, SZ_SG_REQ_INFO);\n\t\trinfo[val].req_state = srp->done + 1;\n\t\trinfo[val].problem =\n\t\t\tsrp->header.masked_status &\n\t\t\tsrp->header.host_status &\n\t\t\tsrp->header.driver_status;\n\t\tif (srp->done)\n\t\t\trinfo[val].duration =\n\t\t\t\tsrp->header.duration;\n\t\telse {\n\t\t\tms = jiffies_to_msecs(jiffies);\n\t\t\trinfo[val].duration =\n\t\t\t\t(ms > srp->header.duration) ?\n\t\t\t\t(ms - srp->header.duration) : 0;\n\t\t}\n\t\trinfo[val].orphan = srp->orphan;\n\t\trinfo[val].sg_io_owned = srp->sg_io_owned;\n\t\trinfo[val].pack_id = srp->header.pack_id;\n\t\trinfo[val].usr_ptr = srp->header.usr_ptr;\n\t\tval++;\n\t}\n}", "target": 1}
{"code": " */\nint re_yyget_column  (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n        if (! YY_CURRENT_BUFFER)\n            return 0;\n    return yycolumn;", "target": 1}
{"code": "mm_append_debug(Buffer *m)\n{\n\tif (auth_debug_init && buffer_len(&auth_debug)) {\n\t\tdebug3(\"%s: Appending debug messages for child\", __func__);\n\t\tbuffer_append(m, buffer_ptr(&auth_debug),\n\t\t    buffer_len(&auth_debug));\n\t\tbuffer_clear(&auth_debug);\n\t}\n}", "target": 0}
{"code": "static void ifb_setup(struct net_device *dev)\n{\n\tdev->destructor = free_netdev;\n\tdev->netdev_ops = &ifb_netdev_ops;\n\tether_setup(dev);\n\tdev->tx_queue_len = TX_Q_LIMIT;\n\tdev->features |= IFB_FEATURES;\n\tdev->vlan_features |= IFB_FEATURES;\n\tdev->flags |= IFF_NOARP;\n\tdev->flags &= ~IFF_MULTICAST;\n\tdev->priv_flags &= ~IFF_XMIT_DST_RELEASE;\n\trandom_ether_addr(dev->dev_addr);\n}", "target": 1}
{"code": "static struct dst_entry *inet6_csk_route_socket(struct sock *sk,\n\t\t\t\t\t\tstruct flowi6 *fl6)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct in6_addr *final_p, final;\n\tstruct dst_entry *dst;\n\tmemset(fl6, 0, sizeof(*fl6));\n\tfl6->flowi6_proto = sk->sk_protocol;\n\tfl6->daddr = sk->sk_v6_daddr;\n\tfl6->saddr = np->saddr;\n\tfl6->flowlabel = np->flow_label;\n\tIP6_ECN_flow_xmit(sk, fl6->flowlabel);\n\tfl6->flowi6_oif = sk->sk_bound_dev_if;\n\tfl6->flowi6_mark = sk->sk_mark;\n\tfl6->fl6_sport = inet->inet_sport;\n\tfl6->fl6_dport = inet->inet_dport;\n\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(fl6));\n\tfinal_p = fl6_update_dst(fl6, np->opt, &final);\n\tdst = __inet6_csk_dst_check(sk, np->dst_cookie);\n\tif (!dst) {\n\t\tdst = ip6_dst_lookup_flow(sk, fl6, final_p);\n\t\tif (!IS_ERR(dst))\n\t\t\t__inet6_csk_dst_store(sk, dst, NULL, NULL);\n\t}\n\treturn dst;\n}", "target": 1}
{"code": "z_jbig2decode(i_ctx_t * i_ctx_p)\n{\n    os_ptr op = osp;\n    ref *sop = NULL;\n    s_jbig2_global_data_t *gref;\n    stream_jbig2decode_state state;\n    s_jbig2decode_set_global_data((stream_state*)&state, NULL);\n    if (r_has_type(op, t_dictionary)) {\n        check_dict_read(*op);\n        if ( dict_find_string(op, \".jbig2globalctx\", &sop) > 0) {\n            gref = r_ptr(sop, s_jbig2_global_data_t);\n            s_jbig2decode_set_global_data((stream_state*)&state, gref);\n        }\n    }\n    return filter_read(i_ctx_p, 0, &s_jbig2decode_template,\n                       (stream_state *) & state, (sop ? r_space(sop) : 0));\n}", "target": 1}
{"code": "vhost_user_set_req_fd(struct virtio_net **pdev, struct VhostUserMsg *msg,\n\t\t\tint main_fd __rte_unused)\n{\n\tstruct virtio_net *dev = *pdev;\n\tint fd = msg->fds[0];\n\tif (validate_msg_fds(msg, 1) != 0)\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\tif (fd < 0) {\n\t\tVHOST_LOG_CONFIG(ERR,\n\t\t\t\t\"Invalid file descriptor for slave channel (%d)\\n\",\n\t\t\t\tfd);\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t}\n\tif (dev->slave_req_fd >= 0)\n\t\tclose(dev->slave_req_fd);\n\tdev->slave_req_fd = fd;\n\treturn RTE_VHOST_MSG_RESULT_OK;\n}", "target": 0}
{"code": "void RenderWidgetHostImpl::SetScreenOrientationForTesting(\n    uint16_t angle,\n    ScreenOrientationValues type) {\n  screen_orientation_angle_for_testing_ = angle;\n  screen_orientation_type_for_testing_ = type;\n  WasResized();\n}", "target": 0}
{"code": "static void ax25_kill_by_device(struct net_device *dev)\n{\n\tax25_dev *ax25_dev;\n\tax25_cb *s;\n\tstruct sock *sk;\n\tif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\n\t\treturn;\n\tspin_lock_bh(&ax25_list_lock);\nagain:\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->ax25_dev == ax25_dev) {\n\t\t\tsk = s->sk;\n\t\t\tsock_hold(sk);\n\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\tlock_sock(sk);\n\t\t\ts->ax25_dev = NULL;\n\t\t\tax25_dev_put(ax25_dev);\n\t\t\trelease_sock(sk);\n\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\tspin_lock_bh(&ax25_list_lock);\n\t\t\tsock_put(sk);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock_bh(&ax25_list_lock);\n}", "target": 1}
{"code": "xmlParseElementEnd(xmlParserCtxtPtr ctxt) {\n    xmlParserNodeInfo node_info;\n    xmlNodePtr ret = ctxt->node;\n    if (ctxt->nameNr <= 0)\n        return;\n    if (ctxt->sax2) {\n        const xmlChar *prefix = ctxt->pushTab[ctxt->nameNr * 3 - 3];\n        const xmlChar *URI = ctxt->pushTab[ctxt->nameNr * 3 - 2];\n        int nsNr = (ptrdiff_t) ctxt->pushTab[ctxt->nameNr * 3 - 1];\n\txmlParseEndTag2(ctxt, prefix, URI, 0, nsNr, 0);\n\tnamePop(ctxt);\n    }\n#ifdef LIBXML_SAX1_ENABLED\n    else\n\txmlParseEndTag1(ctxt, 0);\n#endif \n    if ( ret != NULL && ctxt->record_info ) {\n       node_info.end_pos = ctxt->input->consumed +\n                          (CUR_PTR - ctxt->input->base);\n       node_info.end_line = ctxt->input->line;\n       node_info.node = ret;\n       xmlParserAddNodeInfo(ctxt, &node_info);\n    }\n}", "target": 0}
{"code": "static unsigned long unmap_page_range(struct mmu_gather *tlb,\n\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tlong *zap_work, struct zap_details *details)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\tif (details && !details->check_mapping && !details->nonlinear_vma)\n\t\tdetails = NULL;\n\tBUG_ON(addr >= end);\n\ttlb_start_vma(tlb, vma);\n\tpgd = pgd_offset(vma->vm_mm, addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none_or_clear_bad(pgd)) {\n\t\t\t(*zap_work)--;\n\t\t\tcontinue;\n\t\t}\n\t\tnext = zap_pud_range(tlb, vma, pgd, addr, next,\n\t\t\t\t\t\tzap_work, details);\n\t} while (pgd++, addr = next, (addr != end && *zap_work > 0));\n\ttlb_end_vma(tlb, vma);\n\treturn addr;\n}", "target": 0}
{"code": "ciKlass* ciEnv::get_klass_by_index(const constantPoolHandle& cpool,\n                                   int index,\n                                   bool& is_accessible,\n                                   ciInstanceKlass* accessor) {\n  GUARDED_VM_ENTRY(return get_klass_by_index_impl(cpool, index, is_accessible, accessor);)\n}", "target": 0}
{"code": "static void set_env( char* penv, const char* name )\n{\n    if( penv && *penv )\n        g_setenv( name, penv, TRUE);\n    else\n        g_unsetenv( name );\n}", "target": 0}
{"code": "void ring_buffer_record_disable_cpu(struct ring_buffer *buffer, int cpu)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tif (!cpumask_test_cpu(cpu, buffer->cpumask))\n\t\treturn;\n\tcpu_buffer = buffer->buffers[cpu];\n\tatomic_inc(&cpu_buffer->record_disabled);\n}", "target": 0}
{"code": "int64_t LineBasedFrameDecoder::findEndOfLine(IOBufQueue& buf) {\n  Cursor c(buf.front());\n  for (uint32_t i = 0; i < maxLength_ && i < buf.chainLength(); i++) {\n    auto b = c.read<char>();\n    if (b == '\\n' && terminatorType_ != TerminatorType::CARRIAGENEWLINE) {\n      return i;\n    } else if (terminatorType_ != TerminatorType::NEWLINE &&\n               b == '\\r' && !c.isAtEnd() && c.read<char>() == '\\n') {\n      return i;\n    }\n  }\n  return -1;\n}", "target": 1}
{"code": "struct task_struct * __cpuinit fork_idle(int cpu)\n{\n\tstruct task_struct *task;\n\tstruct pt_regs regs;\n\ttask = copy_process(CLONE_VM, 0, idle_regs(&regs), 0, NULL,\n\t\t\t    &init_struct_pid, 0);\n\tif (!IS_ERR(task))\n\t\tinit_idle(task, cpu);\n\treturn task;\n}", "target": 1}
{"code": "TIFFReadRGBAStrip(TIFF* tif, uint32 row, uint32 * raster )\n{\n    char \temsg[1024] = \"\";\n    TIFFRGBAImage img;\n    int \tok;\n    uint32\trowsperstrip, rows_to_read;\n    if( TIFFIsTiled( tif ) )\n    {\n\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif),\n                  \"Can't use TIFFReadRGBAStrip() with tiled file.\");\n\treturn (0);\n    }\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    if( (row % rowsperstrip) != 0 )\n    {\n\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif),\n\t\t\t\t\"Row passed to TIFFReadRGBAStrip() must be first in a strip.\");\n\t\treturn (0);\n    }\n    if (TIFFRGBAImageOK(tif, emsg) && TIFFRGBAImageBegin(&img, tif, 0, emsg)) {\n        img.row_offset = row;\n        img.col_offset = 0;\n        if( row + rowsperstrip > img.height )\n            rows_to_read = img.height - row;\n        else\n            rows_to_read = rowsperstrip;\n\tok = TIFFRGBAImageGet(&img, raster, img.width, rows_to_read );\n\tTIFFRGBAImageEnd(&img);\n    } else {\n\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"%s\", emsg);\n\t\tok = 0;\n    }\n    return (ok);\n}", "target": 0}
{"code": "int kvm_inject_realmode_interrupt(struct kvm_vcpu *vcpu, int irq, int inc_eip)\n{\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tint ret;\n\tinit_emulate_ctxt(vcpu);\n\tctxt->op_bytes = 2;\n\tctxt->ad_bytes = 2;\n\tctxt->_eip = ctxt->eip + inc_eip;\n\tret = emulate_int_real(ctxt, irq);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn EMULATE_FAIL;\n\tctxt->eip = ctxt->_eip;\n\tkvm_rip_write(vcpu, ctxt->eip);\n\tkvm_set_rflags(vcpu, ctxt->eflags);\n\tif (irq == NMI_VECTOR)\n\t\tvcpu->arch.nmi_pending = 0;\n\telse\n\t\tvcpu->arch.interrupt.pending = false;\n\treturn EMULATE_DONE;\n}", "target": 0}
{"code": "static void cil_reset_perm(struct cil_perm *perm)\n{\n\tcil_reset_classperms_list(perm->classperms);\n}", "target": 1}
{"code": "static int ioapic_mmio_read(struct kvm_io_device *this, gpa_t addr, int len,\n\t\t\t    void *val)\n{\n\tstruct kvm_ioapic *ioapic = to_ioapic(this);\n\tu32 result;\n\tif (!ioapic_in_range(ioapic, addr))\n\t\treturn -EOPNOTSUPP;\n\tioapic_debug(\"addr %lx\\n\", (unsigned long)addr);\n\tASSERT(!(addr & 0xf));\t\n\taddr &= 0xff;\n\tspin_lock(&ioapic->lock);\n\tswitch (addr) {\n\tcase IOAPIC_REG_SELECT:\n\t\tresult = ioapic->ioregsel;\n\t\tbreak;\n\tcase IOAPIC_REG_WINDOW:\n\t\tresult = ioapic_read_indirect(ioapic, addr, len);\n\t\tbreak;\n\tdefault:\n\t\tresult = 0;\n\t\tbreak;\n\t}\n\tspin_unlock(&ioapic->lock);\n\tswitch (len) {\n\tcase 8:\n\t\t*(u64 *) val = result;\n\t\tbreak;\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\t\tmemcpy(val, (char *)&result, len);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"ioapic: wrong length %d\\n\", len);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int ogm_chapter(AVFormatContext *as, uint8_t *key, uint8_t *val)\n{\n    int i, cnum, h, m, s, ms, keylen = strlen(key);\n    AVChapter *chapter = NULL;\n    if (keylen < 9 || sscanf(key, \"CHAPTER%03d\", &cnum) != 1)\n        return 0;\n    if (keylen <= 10) {\n        if (sscanf(val, \"%02d:%02d:%02d.%03d\", &h, &m, &s, &ms) < 4)\n            return 0;\n        avpriv_new_chapter(as, cnum, (AVRational) { 1, 1000 },\n                           ms + 1000 * (s + 60 * (m + 60 * h)),\n                           AV_NOPTS_VALUE, NULL);\n        av_free(val);\n    } else if (!strcmp(key + keylen - 4, \"NAME\")) {\n        for (i = 0; i < as->nb_chapters; i++)\n            if (as->chapters[i]->id == cnum) {\n                chapter = as->chapters[i];\n                break;\n            }\n        if (!chapter)\n            return 0;\n        av_dict_set(&chapter->metadata, \"title\", val, AV_DICT_DONT_STRDUP_VAL);\n    } else\n        return 0;\n    av_free(key);\n    return 1;\n}", "target": 0}
{"code": "static void ssl_write_renegotiation_ext( mbedtls_ssl_context *ssl,\n                                         unsigned char *buf,\n                                         size_t *olen )\n{\n    unsigned char *p = buf;\n    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;\n    *olen = 0;\n    if( ssl->renego_status != MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )\n        return;\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, adding renegotiation extension\" ) );\n    if( end < p || (size_t)( end - p ) < 5 + ssl->verify_data_len )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n        return;\n    }\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_RENEGOTIATION_INFO >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_RENEGOTIATION_INFO      ) & 0xFF );\n    *p++ = 0x00;\n    *p++ = ( ssl->verify_data_len + 1 ) & 0xFF;\n    *p++ = ssl->verify_data_len & 0xFF;\n    memcpy( p, ssl->own_verify_data, ssl->verify_data_len );\n    *olen = 5 + ssl->verify_data_len;\n}", "target": 0}
{"code": "static CURLcode transfer_per_config(struct GlobalConfig *global,\n                                    struct OperationConfig *config,\n                                    CURLSH *share,\n                                    bool *added)\n{\n  CURLcode result = CURLE_OK;\n  bool capath_from_env;\n  *added = FALSE;\n  if(!config->url_list || !config->url_list->url) {\n    helpf(global->errors, \"no URL specified!\\n\");\n    return CURLE_FAILED_INIT;\n  }\n  capath_from_env = false;\n  if(!config->cacert &&\n     !config->capath &&\n     (!config->insecure_ok || (config->doh_url && !config->doh_insecure_ok))) {\n    CURL *curltls = curl_easy_init();\n    struct curl_tlssessioninfo *tls_backend_info = NULL;\n    result = curl_easy_getinfo(curltls, CURLINFO_TLS_SSL_PTR,\n                               &tls_backend_info);\n    if(result)\n      return result;\n    if(tls_backend_info->backend != CURLSSLBACKEND_SCHANNEL) {\n      char *env;\n      env = curlx_getenv(\"CURL_CA_BUNDLE\");\n      if(env) {\n        config->cacert = strdup(env);\n        if(!config->cacert) {\n          curl_free(env);\n          errorf(global, \"out of memory\\n\");\n          return CURLE_OUT_OF_MEMORY;\n        }\n      }\n      else {\n        env = curlx_getenv(\"SSL_CERT_DIR\");\n        if(env) {\n          config->capath = strdup(env);\n          if(!config->capath) {\n            curl_free(env);\n            helpf(global->errors, \"out of memory\\n\");\n            return CURLE_OUT_OF_MEMORY;\n          }\n          capath_from_env = true;\n        }\n        else {\n          env = curlx_getenv(\"SSL_CERT_FILE\");\n          if(env) {\n            config->cacert = strdup(env);\n            if(!config->cacert) {\n              curl_free(env);\n              errorf(global, \"out of memory\\n\");\n              return CURLE_OUT_OF_MEMORY;\n            }\n          }\n        }\n      }\n      if(env)\n        curl_free(env);\n#ifdef WIN32\n      else {\n        result = FindWin32CACert(config, tls_backend_info->backend,\n                                 TEXT(\"curl-ca-bundle.crt\"));\n      }\n#endif\n    }\n    curl_easy_cleanup(curltls);\n  }\n  if(!result)\n    result = single_transfer(global, config, share, capath_from_env, added);\n  return result;\n}", "target": 0}
{"code": "hb_buffer_destroy (hb_buffer_t *buffer)\n{\n  HB_OBJECT_DO_DESTROY (buffer);\n  hb_unicode_funcs_destroy (buffer->unicode);\n  free (buffer->info);\n  free (buffer->pos);\n  free (buffer);\n}", "target": 0}
{"code": "int nfc_data_exchange(struct nfc_dev *dev, u32 target_idx, struct sk_buff *skb,\n\t\t      data_exchange_cb_t cb, void *cb_context)\n{\n\tint rc;\n\tpr_debug(\"dev_name=%s target_idx=%u skb->len=%u\\n\",\n\t\t dev_name(&dev->dev), target_idx, skb->len);\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tkfree_skb(skb);\n\t\tgoto error;\n\t}\n\tif (dev->rf_mode == NFC_RF_INITIATOR && dev->active_target != NULL) {\n\t\tif (dev->active_target->idx != target_idx) {\n\t\t\trc = -EADDRNOTAVAIL;\n\t\t\tkfree_skb(skb);\n\t\t\tgoto error;\n\t\t}\n\t\tif (dev->ops->check_presence)\n\t\t\tdel_timer_sync(&dev->check_pres_timer);\n\t\trc = dev->ops->im_transceive(dev, dev->active_target, skb, cb,\n\t\t\t\t\t     cb_context);\n\t\tif (!rc && dev->ops->check_presence && !dev->shutting_down)\n\t\t\tmod_timer(&dev->check_pres_timer, jiffies +\n\t\t\t\t  msecs_to_jiffies(NFC_CHECK_PRES_FREQ_MS));\n\t} else if (dev->rf_mode == NFC_RF_TARGET && dev->ops->tm_send != NULL) {\n\t\trc = dev->ops->tm_send(dev, skb);\n\t} else {\n\t\trc = -ENOTCONN;\n\t\tkfree_skb(skb);\n\t\tgoto error;\n\t}\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "njs_chb_write_byte_as_utf8(njs_chb_t *chain, u_char byte)\n{\n    njs_utf8_encode(njs_chb_current(chain), byte);\n    njs_chb_written(chain, njs_utf8_size(byte));\n}", "target": 0}
{"code": "void  opj_j2k_write_float_to_float64 (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n        OPJ_BYTE * l_dest_data = (OPJ_BYTE *) p_dest_data;\n        OPJ_FLOAT32 * l_src_data = (OPJ_FLOAT32 *) p_src_data;\n        OPJ_UINT32 i;\n        OPJ_FLOAT64 l_temp;\n        for (i=0;i<p_nb_elem;++i) {\n                l_temp = (OPJ_FLOAT64) *(l_src_data++);\n                opj_write_double(l_dest_data,l_temp);\n                l_dest_data+=sizeof(OPJ_FLOAT64);\n        }\n}", "target": 0}
{"code": "NOEXPORT int verify_callback(int preverify_ok, X509_STORE_CTX *callback_ctx) {\n    SSL *ssl;\n    CLI *c;\n    ssl=X509_STORE_CTX_get_ex_data(callback_ctx,\n        SSL_get_ex_data_X509_STORE_CTX_idx());\n    c=SSL_get_ex_data(ssl, index_ssl_cli);\n    if(!c->opt->option.verify_chain && !c->opt->option.verify_peer) {\n        s_log(LOG_INFO, \"Certificate verification disabled\");\n        return 1; \n    }\n    if(verify_checks(c, preverify_ok, callback_ctx)) {\n        SSL_SESSION *sess=SSL_get1_session(c->ssl);\n        if(sess) {\n            int ok=SSL_SESSION_set_ex_data(sess, index_session_authenticated,\n                (void *)(-1));\n            SSL_SESSION_free(sess);\n            if(!ok) {\n                sslerror(\"SSL_SESSION_set_ex_data\");\n                return 0; \n            }\n        }\n        return 1; \n    }\n    if(c->opt->option.client || c->opt->protocol)\n        return 0; \n    if(c->opt->redirect_addr.names)\n        return 1; \n    return 0; \n}", "target": 1}
{"code": "static int selinux_netlink_send(struct sock *sk, struct sk_buff *skb)\n{\n\tint err = 0;\n\tu32 perm;\n\tstruct nlmsghdr *nlh;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tif (skb->len < NLMSG_HDRLEN) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\tnlh = nlmsg_hdr(skb);\n\terr = selinux_nlmsg_lookup(sksec->sclass, nlh->nlmsg_type, &perm);\n\tif (err) {\n\t\tif (err == -EINVAL) {\n\t\t\tpr_warn_ratelimited(\"SELinux: unrecognized netlink\"\n\t\t\t       \" message: protocol=%hu nlmsg_type=%hu sclass=%s\"\n\t\t\t       \" pid=%d comm=%s\\n\",\n\t\t\t       sk->sk_protocol, nlh->nlmsg_type,\n\t\t\t       secclass_map[sksec->sclass - 1].name,\n\t\t\t       task_pid_nr(current), current->comm);\n\t\t\tif (!enforcing_enabled(&selinux_state) ||\n\t\t\t    security_get_allow_unknown(&selinux_state))\n\t\t\t\terr = 0;\n\t\t}\n\t\tif (err == -ENOENT)\n\t\t\terr = 0;\n\t\tgoto out;\n\t}\n\terr = sock_has_perm(sk, perm);\nout:\n\treturn err;\n}", "target": 1}
{"code": "comics_document_thumbnails_get_thumbnail (EvDocumentThumbnails *document,\n\t\t\t\t\t  EvRenderContext      *rc,\n\t\t\t\t\t  gboolean              border)\n{\n\tGdkPixbuf *thumbnail;\n\tthumbnail = comics_document_render_pixbuf (EV_DOCUMENT (document), rc);\n\tif (border) {\n\t      GdkPixbuf *tmp_pixbuf = thumbnail;\n\t      thumbnail = ev_document_misc_get_thumbnail_frame (-1, -1, tmp_pixbuf);\n\t      g_object_unref (tmp_pixbuf);\n\t}\n\treturn thumbnail;\n}", "target": 1}
{"code": "Http::FilterTrailersStatus Context::onRequestTrailers() {\n  if (!wasm_->onRequestTrailers_) {\n    return Http::FilterTrailersStatus::Continue;\n  }\n  if (wasm_->onRequestTrailers_(this, id_).u64_ == 0) {\n    return Http::FilterTrailersStatus::Continue;\n  }\n  return Http::FilterTrailersStatus::StopIteration;\n}", "target": 1}
{"code": "static int prealloc_elems_and_freelist(struct bpf_stack_map *smap)\n{\n\tu32 elem_size = sizeof(struct stack_map_bucket) + smap->map.value_size;\n\tint err;\n\tsmap->elems = bpf_map_area_alloc(elem_size * smap->map.max_entries,\n\t\t\t\t\t smap->map.numa_node);\n\tif (!smap->elems)\n\t\treturn -ENOMEM;\n\terr = pcpu_freelist_init(&smap->freelist);\n\tif (err)\n\t\tgoto free_elems;\n\tpcpu_freelist_populate(&smap->freelist, smap->elems, elem_size,\n\t\t\t       smap->map.max_entries);\n\treturn 0;\nfree_elems:\n\tbpf_map_area_free(smap->elems);\n\treturn err;\n}", "target": 1}
{"code": "make_absent_engine(Node** node, int pre_save_right_id, Node* absent,\n                   Node* step_one, int lower, int upper, int possessive,\n                   int is_range_cutter, ScanEnv* env)\n{\n  int r;\n  int i;\n  int id;\n  Node* x;\n  Node* ns[4];\n  for (i = 0; i < 4; i++) ns[i] = NULL_NODE;\n  ns[1] = absent;\n  ns[3] = step_one; \n  r = node_new_save_gimmick(&ns[0], SAVE_S, env);\n  if (r != 0) goto err;\n  id = GIMMICK_(ns[0])->id;\n  r = node_new_update_var_gimmick(&ns[2], UPDATE_VAR_RIGHT_RANGE_FROM_S_STACK,\n                                  id, env);\n  if (r != 0) goto err;\n  r = node_new_fail(&ns[3], env);\n  if (r != 0) goto err;\n  x = make_list(4, ns);\n  if (IS_NULL(x)) goto err0;\n  ns[0] = x;\n  ns[1] = step_one;\n  ns[2] = ns[3] = NULL_NODE;\n  x = make_alt(2, ns);\n  if (IS_NULL(x)) goto err0;\n  ns[0] = x;\n  x = node_new_quantifier(lower, upper, 0);\n  if (IS_NULL(x)) goto err0;\n  NODE_BODY(x) = ns[0];\n  ns[0] = x;\n  if (possessive != 0) {\n    x = node_new_enclosure(ENCLOSURE_STOP_BACKTRACK);\n    if (IS_NULL(x)) goto err0;\n    NODE_BODY(x) = ns[0];\n    ns[0] = x;\n  }\n  r = node_new_update_var_gimmick(&ns[1], UPDATE_VAR_RIGHT_RANGE_FROM_STACK,\n                                  pre_save_right_id, env);\n  if (r != 0) goto err;\n  r = node_new_fail(&ns[2], env);\n  if (r != 0) goto err;\n  x = make_list(2, ns + 1);\n  if (IS_NULL(x)) goto err0;\n  ns[1] = x; ns[2] = NULL_NODE;\n  x = make_alt(2, ns);\n  if (IS_NULL(x)) goto err0;\n  if (is_range_cutter != 0)\n    NODE_STATUS_ADD(x, NST_SUPER);\n  *node = x;\n  return ONIG_NORMAL;\n err0:\n  r = ONIGERR_MEMORY;\n err:\n  for (i = 0; i < 4; i++) onig_node_free(ns[i]);\n  return r;\n}", "target": 0}
{"code": "static int http1_on_request(http1_parser_s *parser) {\n  http1pr_s *p = parser2http(parser);\n  http_on_request_handler______internal(&http1_pr2handle(p), p->p.settings);\n  if (p->request.method && !p->stop)\n    http_finish(&p->request);\n  h1_reset(p);\n  return !p->close && fio_is_closed(p->p.uuid);\n}", "target": 1}
{"code": "comics_decompress_temp_dir (const gchar *command_decompress_tmp,\n\t\t\t    const gchar *command,\n\t\t\t    GError      **error)\n{\n\tgboolean success;\n\tgchar *std_out, *basename;\n\tGError *err = NULL;\n\tgint retval;\n\tsuccess = g_spawn_command_line_sync (command_decompress_tmp, &std_out,\n\t\t\t\t\t     NULL, &retval, &err);\n\tbasename = g_path_get_basename (command);\n\tif (!success) {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"Error launching the command %s in order to \"\n\t\t\t     \"decompress the comic book: %s\"),\n\t\t\t     basename,\n\t\t\t     err->message);\n\t\tg_error_free (err);\n\t} else if (WIFEXITED (retval)) {\n\t\tif (WEXITSTATUS (retval) == EXIT_SUCCESS) {\n\t\t\tg_free (std_out);\n\t\t\tg_free (basename);\n\t\t\treturn TRUE;\n\t\t} else {\n\t\t\tg_set_error (error,\n\t\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t\t     _(\"The command %s failed at \"\n\t\t\t\t     \"decompressing the comic book.\"),\n\t\t\t\t     basename);\n\t\t\tg_free (std_out);\n\t\t}\n\t} else {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"The command %s did not end normally.\"),\n\t\t\t     basename);\n\t\tg_free (std_out);\n\t}\n\tg_free (basename);\n\treturn FALSE;\n}", "target": 1}
{"code": "RequestHandler::RequestHandler(\n    std::shared_ptr<CheckWorkflow> check_workflow,\n    std::shared_ptr<context::ServiceContext> service_context,\n    std::unique_ptr<Request> request_data)\n    : context_(new context::RequestContext(service_context,\n                                           std::move(request_data))),\n      check_workflow_(check_workflow) {\n  std::string buffer;\n  if (context_->request()->FindHeader(\n          google::api_manager::auth::kEndpointApiUserInfo, &buffer)) {\n    context_->request()->AddHeaderToBackend(\n        google::api_manager::auth::kEndpointApiUserInfo, \"\");\n  }\n}", "target": 1}
{"code": "static OPJ_BOOL opj_j2k_add_tlmarker(OPJ_UINT32 tileno, opj_codestream_index_t *cstr_index, OPJ_UINT32 type, OPJ_OFF_T pos, OPJ_UINT32 len)\n{\n        assert(cstr_index != 00);\n        assert(cstr_index->tile_index != 00);\n        if ((cstr_index->tile_index[tileno].marknum + 1) > cstr_index->tile_index[tileno].maxmarknum) {\n                opj_marker_info_t *new_marker;\n                cstr_index->tile_index[tileno].maxmarknum = (OPJ_UINT32)(100 + (OPJ_FLOAT32) cstr_index->tile_index[tileno].maxmarknum);\n                new_marker = (opj_marker_info_t *) opj_realloc(\n                                cstr_index->tile_index[tileno].marker,\n                                cstr_index->tile_index[tileno].maxmarknum *sizeof(opj_marker_info_t));\n                if (! new_marker) {\n                        opj_free(cstr_index->tile_index[tileno].marker);\n                        cstr_index->tile_index[tileno].marker = NULL;\n                        cstr_index->tile_index[tileno].maxmarknum = 0;\n                        cstr_index->tile_index[tileno].marknum = 0;\n                        return OPJ_FALSE;\n                }\n                cstr_index->tile_index[tileno].marker = new_marker;\n        }\n        cstr_index->tile_index[tileno].marker[cstr_index->tile_index[tileno].marknum].type = (OPJ_UINT16)type;\n        cstr_index->tile_index[tileno].marker[cstr_index->tile_index[tileno].marknum].pos = (OPJ_INT32)pos;\n        cstr_index->tile_index[tileno].marker[cstr_index->tile_index[tileno].marknum].len = (OPJ_INT32)len;\n        cstr_index->tile_index[tileno].marknum++;\n        if (type == J2K_MS_SOT) {\n                OPJ_UINT32 l_current_tile_part = cstr_index->tile_index[tileno].current_tpsno;\n                if (cstr_index->tile_index[tileno].tp_index)\n                        cstr_index->tile_index[tileno].tp_index[l_current_tile_part].start_pos = pos;\n        }\n        return OPJ_TRUE;\n}", "target": 0}
{"code": "static WebGestureEvent fatTap(int x, int y)\n{\n    WebGestureEvent event;\n    event.type = WebInputEvent::GestureTap;\n    event.x = x;\n    event.y = y;\n    event.data.tap.width = 50;\n    event.data.tap.height = 50;\n    return event;\n}", "target": 0}
{"code": "JANET_CORE_FN(cfun_array_new_filled,\n              \"(array/new-filled count &opt value)\",\n              \"Creates a new array of `count` elements, all set to `value`, which defaults to nil. Returns the new array.\") {\n    janet_arity(argc, 1, 2);\n    int32_t count = janet_getinteger(argv, 0);\n    if (count < 0) janet_panic(\"expected positive integer\");\n    Janet x = (argc == 2) ? argv[1] : janet_wrap_nil();\n    JanetArray *array = janet_array(count);\n    for (int32_t i = 0; i < count; i++) {\n        array->data[i] = x;\n    }\n    array->count = count;\n    return janet_wrap_array(array);\n}", "target": 0}
{"code": "static inline unsigned long do_div_llr(const long long dividend,\n\t\t\t\t       const long divisor, long *remainder)\n{\n\tu64 result = dividend;\n\t*(remainder) = do_div(result, divisor);\n\treturn (unsigned long) result;\n}", "target": 1}
{"code": "static int ptrace_setoptions(struct task_struct *child, unsigned long data)\n{\n\tunsigned flags;\n\tif (data & ~(unsigned long)PTRACE_O_MASK)\n\t\treturn -EINVAL;\n\tif (unlikely(data & PTRACE_O_SUSPEND_SECCOMP)) {\n\t\tif (!IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) ||\n\t\t    !IS_ENABLED(CONFIG_SECCOMP))\n\t\t\treturn -EINVAL;\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (seccomp_mode(&current->seccomp) != SECCOMP_MODE_DISABLED ||\n\t\t    current->ptrace & PT_SUSPEND_SECCOMP)\n\t\t\treturn -EPERM;\n\t}\n\tflags = child->ptrace;\n\tflags &= ~(PTRACE_O_MASK << PT_OPT_FLAG_SHIFT);\n\tflags |= (data << PT_OPT_FLAG_SHIFT);\n\tchild->ptrace = flags;\n\treturn 0;\n}", "target": 1}
{"code": "void *TrustedPrimitives::UntrustedLocalMemcpy(void *dest, const void *src,\n                                              size_t size) noexcept {\n  return memcpy(dest, src, size);\n}", "target": 0}
{"code": "frag6_print(netdissect_options *ndo, register const u_char *bp, register const u_char *bp2)\n{\n\tregister const struct ip6_frag *dp;\n\tregister const struct ip6_hdr *ip6;\n\tdp = (const struct ip6_frag *)bp;\n\tip6 = (const struct ip6_hdr *)bp2;\n\tND_TCHECK(dp->ip6f_offlg);\n\tif (ndo->ndo_vflag) {\n\t\tND_PRINT((ndo, \"frag (0x%08x:%d|%ld)\",\n\t\t       EXTRACT_32BITS(&dp->ip6f_ident),\n\t\t       EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK,\n\t\t       sizeof(struct ip6_hdr) + EXTRACT_16BITS(&ip6->ip6_plen) -\n\t\t\t       (long)(bp - bp2) - sizeof(struct ip6_frag)));\n\t} else {\n\t\tND_PRINT((ndo, \"frag (%d|%ld)\",\n\t\t       EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK,\n\t\t       sizeof(struct ip6_hdr) + EXTRACT_16BITS(&ip6->ip6_plen) -\n\t\t\t       (long)(bp - bp2) - sizeof(struct ip6_frag)));\n\t}\n\tif ((EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK) != 0)\n\t\treturn -1;\n\telse\n\t{\n\t\tND_PRINT((ndo, \" \"));\n\t\treturn sizeof(struct ip6_frag);\n\t}\ntrunc:\n\tND_PRINT((ndo, \"[|frag]\"));\n\treturn -1;\n}", "target": 1}
{"code": "unsigned long perf_instruction_pointer(struct pt_regs *regs)\n{\n\tbool use_siar = regs_use_siar(regs);\n\tunsigned long siar = mfspr(SPRN_SIAR);\n\tif (ppmu->flags & PPMU_P10_DD1) {\n\t\tif (siar)\n\t\t\treturn siar;\n\t\telse\n\t\t\treturn regs->nip;\n\t} else if (use_siar && siar_valid(regs))\n\t\treturn mfspr(SPRN_SIAR) + perf_ip_adjust(regs);\n\telse if (use_siar)\n\t\treturn 0;\t\t\n\telse\n\t\treturn regs->nip;\n}", "target": 1}
{"code": "lexer_scan_identifier (parser_context_t *context_p, \n                       bool propety_name) \n{\n  skip_spaces (context_p);\n  context_p->token.line = context_p->line;\n  context_p->token.column = context_p->column;\n  if (context_p->source_p < context_p->source_end_p\n      && (lit_char_is_identifier_start (context_p->source_p) || context_p->source_p[0] == LIT_CHAR_BACKSLASH))\n  {\n    lexer_parse_identifier (context_p, false);\n    if (propety_name && context_p->token.lit_location.length == 3)\n    {\n      skip_spaces (context_p);\n      if (context_p->source_p < context_p->source_end_p\n          && context_p->source_p[0] != LIT_CHAR_COLON)\n      {\n        if (lexer_compare_identifier_to_current (context_p, &lexer_get_literal))\n        {\n          context_p->token.type = LEXER_PROPERTY_GETTER;\n        }\n        else if (lexer_compare_identifier_to_current (context_p, &lexer_set_literal))\n        {\n          context_p->token.type = LEXER_PROPERTY_SETTER;\n        }\n      }\n    }\n    return;\n  }\n  if (propety_name)\n  {\n    lexer_next_token (context_p);\n    if (context_p->token.type == LEXER_LITERAL\n        || context_p->token.type == LEXER_RIGHT_BRACE)\n    {\n      return;\n    }\n  }\n  parser_raise_error (context_p, PARSER_ERR_IDENTIFIER_EXPECTED);\n} ", "target": 0}
{"code": "void InstanceKlass::release_C_heap_structures_internal() {\n  Klass::release_C_heap_structures();\n  if (_oop_map_cache != NULL) {\n    delete _oop_map_cache;\n    _oop_map_cache = NULL;\n  }\n  JNIid::deallocate(jni_ids());\n  set_jni_ids(NULL);\n  jmethodID* jmeths = methods_jmethod_ids_acquire();\n  if (jmeths != (jmethodID*)NULL) {\n    release_set_methods_jmethod_ids(NULL);\n    FreeHeap(jmeths);\n  }\n  assert(_dep_context == NULL,\n         \"dependencies should already be cleaned\");\n#if INCLUDE_JVMTI\n  if (breakpoints() != 0x0) {\n    methods_do(clear_all_breakpoints);\n    assert(breakpoints() == 0x0, \"should have cleared breakpoints\");\n  }\n  if (_cached_class_file != NULL) {\n    os::free(_cached_class_file);\n    _cached_class_file = NULL;\n  }\n#endif\n  FREE_C_HEAP_ARRAY(char, _source_debug_extension);\n}", "target": 0}
{"code": "static int ax25_getname(struct socket *sock, struct sockaddr *uaddr,\n\tint *uaddr_len, int peer)\n{\n\tstruct full_sockaddr_ax25 *fsa = (struct full_sockaddr_ax25 *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tunsigned char ndigi, i;\n\tax25_cb *ax25;\n\tint err = 0;\n\tmemset(fsa, 0, sizeof(*fsa));\n\tlock_sock(sk);\n\tax25 = ax25_sk(sk);\n\tif (peer != 0) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tgoto out;\n\t\t}\n\t\tfsa->fsa_ax25.sax25_family = AF_AX25;\n\t\tfsa->fsa_ax25.sax25_call   = ax25->dest_addr;\n\t\tif (ax25->digipeat != NULL) {\n\t\t\tndigi = ax25->digipeat->ndigi;\n\t\t\tfsa->fsa_ax25.sax25_ndigis = ndigi;\n\t\t\tfor (i = 0; i < ndigi; i++)\n\t\t\t\tfsa->fsa_digipeater[i] =\n\t\t\t\t\t\tax25->digipeat->calls[i];\n\t\t}\n\t} else {\n\t\tfsa->fsa_ax25.sax25_family = AF_AX25;\n\t\tfsa->fsa_ax25.sax25_call   = ax25->source_addr;\n\t\tfsa->fsa_ax25.sax25_ndigis = 1;\n\t\tif (ax25->ax25_dev != NULL) {\n\t\t\tmemcpy(&fsa->fsa_digipeater[0],\n\t\t\t       ax25->ax25_dev->dev->dev_addr, AX25_ADDR_LEN);\n\t\t} else {\n\t\t\tfsa->fsa_digipeater[0] = null_ax25_address;\n\t\t}\n\t}\n\t*uaddr_len = sizeof (struct full_sockaddr_ax25);\nout:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "_tiffSizeProc(thandle_t fd)\n{\n\t_TIFF_stat_s sb;\n\tfd_as_handle_union_t fdh;\n\tfdh.h = fd;\n\tif (_TIFF_fstat_f(fdh.fd,&sb)<0)\n\t\treturn(0);\n\telse\n\t\treturn((uint64)sb.st_size);\n}", "target": 0}
{"code": "read_pbm_integer(j_compress_ptr cinfo, FILE *infile, unsigned int maxval)\n{\n  register int ch;\n  register unsigned int val;\n  do {\n    ch = pbm_getc(infile);\n    if (ch == EOF)\n      ERREXIT(cinfo, JERR_INPUT_EOF);\n  } while (ch == ' ' || ch == '\\t' || ch == '\\n' || ch == '\\r');\n  if (ch < '0' || ch > '9')\n    ERREXIT(cinfo, JERR_PPM_NONNUMERIC);\n  val = ch - '0';\n  while ((ch = pbm_getc(infile)) >= '0' && ch <= '9') {\n    val *= 10;\n    val += ch - '0';\n  }\n  if (val > maxval)\n    ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n  return val;\n}", "target": 1}
{"code": "static CubeInfo *GetCubeInfo(const QuantizeInfo *quantize_info,\n  const size_t depth,const size_t maximum_colors)\n{\n  CubeInfo\n    *cube_info;\n  double\n    sum,\n    weight;\n  register ssize_t\n    i;\n  size_t\n    length;\n  cube_info=(CubeInfo *) AcquireMagickMemory(sizeof(*cube_info));\n  if (cube_info == (CubeInfo *) NULL)\n    return((CubeInfo *) NULL);\n  (void) memset(cube_info,0,sizeof(*cube_info));\n  cube_info->depth=depth;\n  if (cube_info->depth > MaxTreeDepth)\n    cube_info->depth=MaxTreeDepth;\n  if (cube_info->depth < 2)\n    cube_info->depth=2;\n  cube_info->maximum_colors=maximum_colors;\n  cube_info->root=GetNodeInfo(cube_info,0,0,(NodeInfo *) NULL);\n  if (cube_info->root == (NodeInfo *) NULL)\n    return((CubeInfo *) NULL);\n  cube_info->root->parent=cube_info->root;\n  cube_info->quantize_info=CloneQuantizeInfo(quantize_info);\n  if (cube_info->quantize_info->dither_method == NoDitherMethod)\n    return(cube_info);\n  length=(size_t) (1UL << (4*(8-CacheShift)));\n  cube_info->memory_info=AcquireVirtualMemory(length,sizeof(*cube_info->cache));\n  if (cube_info->memory_info == (MemoryInfo *) NULL)\n    return((CubeInfo *) NULL);\n  cube_info->cache=(ssize_t *) GetVirtualMemoryBlob(cube_info->memory_info);\n  (void) memset(cube_info->cache,(-1),sizeof(*cube_info->cache)*\n    length);\n  weight=1.0;\n  for (i=0; i < ErrorQueueLength; i++)\n  {\n    cube_info->weights[ErrorQueueLength-i-1]=PerceptibleReciprocal(weight);\n    weight*=exp(log(((double) QuantumRange+1.0))/(ErrorQueueLength-1.0));\n  }\n  weight=0.0;\n  for (i=0; i < ErrorQueueLength; i++)\n    weight+=cube_info->weights[i];\n  sum=0.0;\n  for (i=0; i < ErrorQueueLength; i++)\n  {\n    cube_info->weights[i]/=weight;\n    sum+=cube_info->weights[i];\n  }\n  cube_info->weights[0]+=1.0-sum;\n  return(cube_info);\n}", "target": 0}
{"code": "  absl::optional<uint64_t> evaluate(const Network::Address::Instance*,\n                                    const RequestHeaderMap& headers,\n                                    const HashPolicy::AddCookieCallback add_cookie,\n                                    const StreamInfo::FilterStateSharedPtr) const override {\n    absl::optional<uint64_t> hash;\n    std::string value = Utility::parseCookieValue(headers, key_);\n    if (value.empty() && ttl_.has_value()) {\n      value = add_cookie(key_, path_, ttl_.value(), attributes_);\n      hash = HashUtil::xxHash64(value);\n    } else if (!value.empty()) {\n      hash = HashUtil::xxHash64(value);\n    }\n    return hash;\n  }", "target": 1}
{"code": "static int __init ipip_init(void)\n{\n\tint err;\n\tprintk(banner);\n\tif (xfrm4_tunnel_register(&ipip_handler, AF_INET)) {\n\t\tprintk(KERN_INFO \"ipip init: can't register tunnel\\n\");\n\t\treturn -EAGAIN;\n\t}\n\terr = register_pernet_device(&ipip_net_ops);\n\tif (err)\n\t\txfrm4_tunnel_deregister(&ipip_handler, AF_INET);\n\treturn err;\n}", "target": 1}
{"code": "static void clear_evtchn_to_irq_row(unsigned row)\n{\n\tunsigned col;\n\tfor (col = 0; col < EVTCHN_PER_ROW; col++)\n\t\tevtchn_to_irq[row][col] = -1;\n}", "target": 1}
{"code": "static unsigned rb_calculate_event_length(unsigned length)\n{\n\tstruct ring_buffer_event event; \n\tif (!length)\n\t\tlength++;\n\tif (length > RB_MAX_SMALL_DATA || RB_FORCE_8BYTE_ALIGNMENT)\n\t\tlength += sizeof(event.array[0]);\n\tlength += RB_EVNT_HDR_SIZE;\n\tlength = ALIGN(length, RB_ARCH_ALIGNMENT);\n\tif (length == RB_LEN_TIME_EXTEND + RB_ALIGNMENT)\n\t\tlength += RB_ALIGNMENT;\n\treturn length;\n}", "target": 0}
{"code": "Error ImageOverlay::parse(size_t num_images, const std::vector<uint8_t>& data)\n{\n  Error eofError(heif_error_Invalid_input,\n                 heif_suberror_Invalid_grid_data,\n                 \"Overlay image data incomplete\");\n  if (data.size() < 2 + 4 * 2) {\n    return eofError;\n  }\n  m_version = data[0];\n  m_flags = data[1];\n  if (m_version != 0) {\n    std::stringstream sstr;\n    sstr << \"Overlay image data version \" << ((int) m_version) << \" is not implemented yet\";\n    return Error(heif_error_Unsupported_feature,\n                 heif_suberror_Unsupported_data_version,\n                 sstr.str());\n  }\n  int field_len = ((m_flags & 1) ? 4 : 2);\n  int ptr = 2;\n  if (ptr + 4 * 2 + 2 * field_len + num_images * 2 * field_len > data.size()) {\n    return eofError;\n  }\n  for (int i = 0; i < 4; i++) {\n    uint16_t color = static_cast<uint16_t>(readvec(data, ptr, 2));\n    m_background_color[i] = color;\n  }\n  m_width = readvec(data, ptr, field_len);\n  m_height = readvec(data, ptr, field_len);\n  m_offsets.resize(num_images);\n  for (size_t i = 0; i < num_images; i++) {\n    m_offsets[i].x = readvec_signed(data, ptr, field_len);\n    m_offsets[i].y = readvec_signed(data, ptr, field_len);\n  }\n  return Error::Ok;\n}", "target": 1}
{"code": "static int spk_ttyio_out(struct spk_synth *in_synth, const char ch)\n{\n\tmutex_lock(&speakup_tty_mutex);\n\tif (in_synth->alive && speakup_tty && speakup_tty->ops->write) {\n\t\tint ret = speakup_tty->ops->write(speakup_tty, &ch, 1);\n\t\tmutex_unlock(&speakup_tty_mutex);\n\t\tif (ret == 0)\n\t\t\treturn 0;\n\t\tif (ret < 0) {\n\t\t\tpr_warn(\"%s: I/O error, deactivating speakup\\n\",\n\t\t\t\tin_synth->long_name);\n\t\t\tin_synth->alive = 0;\n\t\t\tspeakup_start_ttys();\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\tmutex_unlock(&speakup_tty_mutex);\n\treturn 0;\n}", "target": 0}
{"code": "static void ff_layout_write_release(void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\tff_layout_write_record_layoutstats_done(&hdr->task, hdr);\n\tif (test_bit(NFS_IOHDR_RESEND_PNFS, &hdr->flags)) {\n\t\tff_layout_send_layouterror(hdr->lseg);\n\t\tff_layout_reset_write(hdr, true);\n\t} else if (test_bit(NFS_IOHDR_RESEND_MDS, &hdr->flags))\n\t\tff_layout_reset_write(hdr, false);\n\tpnfs_generic_rw_release(data);\n}", "target": 0}
{"code": "void SimpleModule::runPull()\n{\n\tpull(m_outChunk->frameCount);\n\trun(*m_inChunk, *m_outChunk);\n}", "target": 1}
{"code": "std::string Utf16ToUtf8(const std::wstring& utf16_string) {\n  return WC2MB(utf16_string, CP_UTF8);\n}", "target": 1}
{"code": "PartitionInstallUdfChildHandles (\n  IN  EFI_DRIVER_BINDING_PROTOCOL  *This,\n  IN  EFI_HANDLE                   Handle,\n  IN  EFI_DISK_IO_PROTOCOL         *DiskIo,\n  IN  EFI_DISK_IO2_PROTOCOL        *DiskIo2,\n  IN  EFI_BLOCK_IO_PROTOCOL        *BlockIo,\n  IN  EFI_BLOCK_IO2_PROTOCOL       *BlockIo2,\n  IN  EFI_DEVICE_PATH_PROTOCOL     *DevicePath\n  )\n{\n  UINT32                       RemainderByMediaBlockSize;\n  EFI_STATUS                   Status;\n  EFI_BLOCK_IO_MEDIA           *Media;\n  EFI_PARTITION_INFO_PROTOCOL  PartitionInfo;\n  EFI_LBA                      StartingLBA;\n  EFI_LBA                      EndingLBA;\n  BOOLEAN                      ChildCreated;\n  Media = BlockIo->Media;\n  ChildCreated = FALSE;\n  DivU64x32Remainder (\n    UDF_LOGICAL_SECTOR_SIZE,   \n    Media->BlockSize,          \n    &RemainderByMediaBlockSize \n    );\n  if (RemainderByMediaBlockSize != 0) {\n    return EFI_NOT_FOUND;\n  }\n  Status = PartitionInstallElToritoChildHandles (\n             This,\n             Handle,\n             DiskIo,\n             DiskIo2,\n             BlockIo,\n             BlockIo2,\n             DevicePath\n             );\n  if (!EFI_ERROR (Status)) {\n    DEBUG ((DEBUG_INFO, \"PartitionDxe: El Torito standard found on handle 0x%p.\\n\", Handle));\n    ChildCreated = TRUE;\n  }\n  Status = FindUdfFileSystem (BlockIo, DiskIo, &StartingLBA, &EndingLBA);\n  if (EFI_ERROR (Status)) {\n    return (ChildCreated ? EFI_SUCCESS : EFI_NOT_FOUND);\n  }\n  ZeroMem (&PartitionInfo, sizeof (EFI_PARTITION_INFO_PROTOCOL));\n  PartitionInfo.Revision = EFI_PARTITION_INFO_PROTOCOL_REVISION;\n  PartitionInfo.Type = PARTITION_TYPE_OTHER;\n  Status = PartitionInstallChildHandle (\n    This,\n    Handle,\n    DiskIo,\n    DiskIo2,\n    BlockIo,\n    BlockIo2,\n    DevicePath,\n    (EFI_DEVICE_PATH_PROTOCOL *)&gUdfDevicePath,\n    &PartitionInfo,\n    StartingLBA,\n    EndingLBA,\n    Media->BlockSize,\n    NULL\n    );\n  if (EFI_ERROR (Status)) {\n    return (ChildCreated ? EFI_SUCCESS : Status);\n  }\n  return EFI_SUCCESS;\n}", "target": 0}
{"code": " void PageClickTracker::handleEvent(const WebDOMEvent& event) {\n   last_node_clicked_.reset();\n  if (!event.isMouseEvent())\n    return;\n   const WebDOMMouseEvent mouse_event = event.toConst<WebDOMMouseEvent>();\n   DCHECK(mouse_event.buttonDown());\n   if (mouse_event.button() != 0)\n    return;  \n  last_node_clicked_ = mouse_event.target();\n  was_focused_ = (GetFocusedNode() == last_node_clicked_);\n}", "target": 0}
{"code": "generate_spc_string(cms_context *cms, SECItem *ssp, char *str, int len)\n{\n\tSpcString ss;\n\tmemset(&ss, '\\0', sizeof (ss));\n\tSECITEM_AllocItem(cms->arena, &ss.unicode, len);\n\tif (len != 0) {\n\t\tif (!ss.unicode.data)\n\t\t\tcmsreterr(-1, cms, \"could not allocate memory\");\n\t\tmemcpy(ss.unicode.data, str, len);\n\t}\n\tss.unicode.type = siBMPString;\n\tif (SEC_ASN1EncodeItem(cms->arena, ssp, &ss, SpcStringTemplate) == NULL)\n\t\tcmsreterr(-1, cms, \"could not encode SpcString\");\n\treturn 0;\n}", "target": 0}
{"code": "handle_action(netdissect_options *ndo,\n              const uint8_t *src, const u_char *p, u_int length)\n{\n\tif (!ND_TTEST2(*p, 2))\n\t\treturn 0;\n\tif (length < 2)\n\t\treturn 0;\n\tif (ndo->ndo_eflag) {\n\t\tND_PRINT((ndo, \": \"));\n\t} else {\n\t\tND_PRINT((ndo, \" (%s): \", etheraddr_string(ndo, src)));\n\t}\n\tswitch (p[0]) {\n\tcase 0: ND_PRINT((ndo, \"Spectrum Management Act#%d\", p[1])); break;\n\tcase 1: ND_PRINT((ndo, \"QoS Act#%d\", p[1])); break;\n\tcase 2: ND_PRINT((ndo, \"DLS Act#%d\", p[1])); break;\n\tcase 3: ND_PRINT((ndo, \"BA \")); PRINT_BA_ACTION(p[1]); break;\n\tcase 7: ND_PRINT((ndo, \"HT \")); PRINT_HT_ACTION(p[1]); break;\n\tcase 13: ND_PRINT((ndo, \"MeshAction \")); PRINT_MESH_ACTION(p[1]); break;\n\tcase 14:\n\t\tND_PRINT((ndo, \"MultiohopAction \"));\n\t\tPRINT_MULTIHOP_ACTION(p[1]); break;\n\tcase 15:\n\t\tND_PRINT((ndo, \"SelfprotectAction \"));\n\t\tPRINT_SELFPROT_ACTION(p[1]); break;\n\tcase 127: ND_PRINT((ndo, \"Vendor Act#%d\", p[1])); break;\n\tdefault:\n\t\tND_PRINT((ndo, \"Reserved(%d) Act#%d\", p[0], p[1]));\n\t\tbreak;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "static int srpt_rx_mgmt_fn_tag(struct srpt_send_ioctx *ioctx, u64 tag)\n{\n\tstruct srpt_device *sdev;\n\tstruct srpt_rdma_ch *ch;\n\tstruct srpt_send_ioctx *target;\n\tint ret, i;\n\tret = -EINVAL;\n\tch = ioctx->ch;\n\tBUG_ON(!ch);\n\tBUG_ON(!ch->sport);\n\tsdev = ch->sport->sdev;\n\tBUG_ON(!sdev);\n\tspin_lock_irq(&sdev->spinlock);\n\tfor (i = 0; i < ch->rq_size; ++i) {\n\t\ttarget = ch->ioctx_ring[i];\n\t\tif (target->cmd.se_lun == ioctx->cmd.se_lun &&\n\t\t    target->cmd.tag == tag &&\n\t\t    srpt_get_cmd_state(target) != SRPT_STATE_DONE) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irq(&sdev->spinlock);\n\treturn ret;\n}", "target": 1}
{"code": "str2special(\n    char_u\t**sp,\n    int\t\tfrom)\t\n{\n    int\t\t\tc;\n    static char_u\tbuf[7];\n    char_u\t\t*str = *sp;\n    int\t\t\tmodifiers = 0;\n    int\t\t\tspecial = FALSE;\n    if (has_mbyte)\n    {\n\tchar_u\t*p;\n\tp = mb_unescape(sp);\n\tif (p != NULL)\n\t    return p;\n    }\n    c = *str;\n    if (c == K_SPECIAL && str[1] != NUL && str[2] != NUL)\n    {\n\tif (str[1] == KS_MODIFIER)\n\t{\n\t    modifiers = str[2];\n\t    str += 3;\n\t    c = *str;\n\t}\n\tif (c == K_SPECIAL && str[1] != NUL && str[2] != NUL)\n\t{\n\t    c = TO_SPECIAL(str[1], str[2]);\n\t    str += 2;\n\t}\n\tif (IS_SPECIAL(c) || modifiers)\t\n\t    special = TRUE;\n    }\n    if (has_mbyte && !IS_SPECIAL(c) && MB_BYTE2LEN(c) > 1)\n    {\n\tchar_u\t*p;\n\t*sp = str;\n\tp = mb_unescape(sp);\n\tif (p != NULL)\n\t    c = (*mb_ptr2char)(p);\n\telse\n\t    *sp = str + 1;\n    }\n    else\n\t*sp = str + 1;\n    if (special || c < ' ' || (from && c == ' '))\n\treturn get_special_key_name(c, modifiers);\n    buf[0] = c;\n    buf[1] = NUL;\n    return buf;\n}", "target": 1}
{"code": "static int ax_close(struct net_device *dev)\n{\n\tstruct mkiss *ax = netdev_priv(dev);\n\tif (ax->tty)\n\t\tclear_bit(TTY_DO_WRITE_WAKEUP, &ax->tty->flags);\n\tnetif_stop_queue(dev);\n\treturn 0;\n}", "target": 0}
{"code": "extract_option(uschar **name, uschar **value)\n{\nuschar *n;\nuschar *v = smtp_cmd_data + Ustrlen(smtp_cmd_data) - 1;\nwhile (isspace(*v)) v--;\nv[1] = 0;\nwhile (v > smtp_cmd_data && *v != '=' && !isspace(*v))\n  {\n  if (*v == '\"') do v--; while (*v != '\"' && v > smtp_cmd_data+1);\n  v--;\n  }\nn = v;\nif (*v == '=')\n  {\n  while(isalpha(n[-1])) n--;\n  if (!isspace(n[-1])) return FALSE;\n  n[-1] = 0;\n  }\nelse\n  {\n  n++;\n  if (v == smtp_cmd_data) return FALSE;\n  }\n*v++ = 0;\n*name = n;\n*value = v;\nreturn TRUE;\n}", "target": 0}
{"code": "htp_param_t *htp_tx_req_get_param_ex(htp_tx_t *tx, enum htp_data_source_t source, const char *name, size_t name_len) {\n    if ((tx == NULL) || (name == NULL)) return NULL;\n    htp_param_t *p = NULL;\n    for (size_t i = 0, n = htp_table_size(tx->request_params); i < n; i++) {\n        p = htp_table_get_index(tx->request_params, i, NULL);\n        if (p->source != source) continue;\n        if (bstr_cmp_mem_nocase(p->name, name, name_len) == 0) return p;\n    }\n    return NULL;\n}", "target": 0}
{"code": "pci_msix_table_init(struct pci_vdev *dev, int table_entries)\n{\n\tint i, table_size;\n\tassert(table_entries > 0);\n\tassert(table_entries <= MAX_MSIX_TABLE_ENTRIES);\n\ttable_size = table_entries * MSIX_TABLE_ENTRY_SIZE;\n\tdev->msix.table = calloc(1, table_size);\n\tassert(dev->msix.table != NULL);\n\tfor (i = 0; i < table_entries; i++)\n\t\tdev->msix.table[i].vector_control |= PCIM_MSIX_VCTRL_MASK;\n}", "target": 1}
{"code": "static int ssl_write_certificate_verify( mbedtls_ssl_context *ssl )\n{\n    const mbedtls_ssl_ciphersuite_t *ciphersuite_info =\n        ssl->transform_negotiate->ciphersuite_info;\n    int ret;\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> write certificate verify\" ) );\n    if( ( ret = mbedtls_ssl_derive_keys( ssl ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_derive_keys\", ret );\n        return( ret );\n    }\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= skip write certificate verify\" ) );\n        ssl->state++;\n        return( 0 );\n    }\n    MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n    return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n}", "target": 0}
{"code": "struct mapped_device *dm_get_from_kobject(struct kobject *kobj)\n{\n\tstruct mapped_device *md;\n\tmd = container_of(kobj, struct mapped_device, kobj_holder.kobj);\n\tif (test_bit(DMF_FREEING, &md->flags) ||\n\t    dm_deleting_md(md))\n\t\treturn NULL;\n\tdm_get(md);\n\treturn md;\n}", "target": 1}
{"code": "static void check_hostalias(request_rec *r)\n{\n    const char *host = r->hostname;\n    apr_port_t port;\n    server_rec *s;\n    server_rec *virthost_s;\n    server_rec *last_s;\n    name_chain *src;\n    virthost_s = NULL;\n    last_s = NULL;\n    port = r->connection->local_addr->port;\n    for (src = r->connection->vhost_lookup_data; src; src = src->next) {\n        server_addr_rec *sar;\n        sar = src->sar;\n        if (sar->host_port != 0 && port != sar->host_port) {\n            continue;\n        }\n        s = src->server;\n        if (s != last_s) {\n            if (matches_aliases(s, host)) {\n                goto found;\n            }\n        }\n        if (!strcasecmp(host, sar->virthost)) {\n            if (virthost_s == NULL) {\n                virthost_s = s;\n            }\n        }\n        last_s = s;\n    }\n    if (virthost_s) {\n        s = virthost_s;\n        goto found;\n    }\n    return;\nfound:\n    r->server = s;\n}", "target": 1}
{"code": "virSecuritySELinuxMCSGetProcessRange(char **sens,\n                                     int *catMin,\n                                     int *catMax)\n{\n    char *ourSecContext = NULL;\n    context_t ourContext = NULL;\n    char *cat = NULL;\n    char *tmp;\n    const char *contextRange;\n    int ret = -1;\n    if (getcon_raw(&ourSecContext) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to get current process SELinux context\"));\n        goto cleanup;\n    }\n    if (!(ourContext = context_new(ourSecContext))) {\n        virReportSystemError(errno,\n                             _(\"Unable to parse current SELinux context '%s'\"),\n                             ourSecContext);\n        goto cleanup;\n    }\n    if (!(contextRange = context_range_get(ourContext)))\n        contextRange = \"s0\";\n    *sens = g_strdup(contextRange);\n    tmp = strchr(*sens, ':');\n    if (tmp) {\n        *tmp = '\\0';\n        cat = tmp + 1;\n    }\n    if ((tmp = strchr(*sens, '-')))\n        *tmp = '\\0';\n    if (!cat) {\n        *catMin = 0;\n        *catMax = 1023;\n        ret = 0;\n        goto cleanup;\n    }\n    tmp = cat;\n    if (tmp[0] != 'c') {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse category in %s\"),\n                       cat);\n        goto cleanup;\n    }\n    tmp++;\n    if (virStrToLong_i(tmp, &tmp, 10, catMin) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse category in %s\"),\n                       cat);\n        goto cleanup;\n    }\n    if (!tmp[0]) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"No category range available\"));\n        goto cleanup;\n    }\n    if (tmp[0] != '.') {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse category in %s\"),\n                       cat);\n        goto cleanup;\n    }\n    tmp++;\n    if (tmp[0] != 'c') {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse category in %s\"),\n                       cat);\n        goto cleanup;\n    }\n    tmp++;\n    if (virStrToLong_i(tmp, &tmp, 10, catMax) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse category in %s\"),\n                       cat);\n        goto cleanup;\n    }\n    ret = 0;\n cleanup:\n    if (ret < 0)\n        VIR_FREE(*sens);\n    freecon(ourSecContext);\n    context_free(ourContext);\n    return ret;\n}", "target": 0}
{"code": "user_local_save_to_keyfile (User     *user,\n                            GKeyFile *keyfile)\n{\n        if (user->email)\n                g_key_file_set_string (keyfile, \"User\", \"Email\", user->email);\n        if (user->language)\n                g_key_file_set_string (keyfile, \"User\", \"Language\", user->language);\n        if (user->x_session)\n                g_key_file_set_string (keyfile, \"User\", \"XSession\", user->x_session);\n        if (user->location)\n                g_key_file_set_string (keyfile, \"User\", \"Location\", user->location);\n        if (user->password_hint)\n                g_key_file_set_string (keyfile, \"User\", \"PasswordHint\", user->password_hint);\n        if (user->icon_file)\n                g_key_file_set_string (keyfile, \"User\", \"Icon\", user->icon_file);\n}", "target": 0}
{"code": "int jpc_ppxstab_insert(jpc_ppxstab_t *tab, jpc_ppxstabent_t *ent)\n{\n\tint inspt;\n\tint i;\n\tfor (i = 0; i < tab->numents; ++i) {\n\t\tif (tab->ents[i]->ind > ent->ind) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tinspt = i;\n\tif (tab->numents >= tab->maxents) {\n\t\tif (jpc_ppxstab_grow(tab, tab->maxents + 128)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tfor (i = tab->numents; i > inspt; --i) {\n\t\ttab->ents[i] = tab->ents[i - 1];\n\t}\n\ttab->ents[i] = ent;\n\t++tab->numents;\n\treturn 0;\n}", "target": 1}
{"code": "void SetBackgroundColor(int par)\n{\n    if ( par == STROKING ) { outpos += sprintf(outpos,\" 0 0 0 0 K\"); }\n    else                   { outpos += sprintf(outpos,\" 0 0 0 0 k\"); }\n}", "target": 1}
{"code": "asmlinkage long compat_sys_recvmmsg(int fd, struct compat_mmsghdr __user *mmsg,\n\t\t\t\t    unsigned int vlen, unsigned int flags,\n\t\t\t\t    struct compat_timespec __user *timeout)\n{\n\tint datagrams;\n\tstruct timespec ktspec;\n\tif (flags & MSG_CMSG_COMPAT)\n\t\treturn -EINVAL;\n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t      flags | MSG_CMSG_COMPAT,\n\t\t\t\t      (struct timespec *) timeout);\n\tif (timeout == NULL)\n\t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t      flags | MSG_CMSG_COMPAT, NULL);\n\tif (get_compat_timespec(&ktspec, timeout))\n\t\treturn -EFAULT;\n\tdatagrams = __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t   flags | MSG_CMSG_COMPAT, &ktspec);\n\tif (datagrams > 0 && put_compat_timespec(&ktspec, timeout))\n\t\tdatagrams = -EFAULT;\n\treturn datagrams;\n}", "target": 1}
{"code": "static void *conncache_add_bundle(struct conncache *connc,\n                                  char *key,\n                                  struct connectbundle *bundle)\n{\n  return Curl_hash_add(&connc->hash, key, strlen(key), bundle);\n}", "target": 0}
{"code": "int mongo_env_read_socket( mongo *conn, void *buf, int len ) {\n    char *cbuf = buf;\n    while ( len ) {\n        int sent = recv( conn->sock, cbuf, len, 0 );\n        if ( sent == 0 || sent == -1 ) {\n            __mongo_set_error( conn, MONGO_IO_ERROR, NULL, WSAGetLastError() );\n            return MONGO_ERROR;\n        }\n        cbuf += sent;\n        len -= sent;\n    }\n    return MONGO_OK;\n}", "target": 1}
{"code": "ospf_router_lsa_links_examin\n(\n  struct router_lsa_link * link,\n  u_int16_t linkbytes,\n  const u_int16_t num_links\n)\n{\n  unsigned counted_links = 0, thislinklen;\n  while (linkbytes)\n  {\n    thislinklen = OSPF_ROUTER_LSA_LINK_SIZE + 4 * link->m[0].tos_count;\n    if (thislinklen > linkbytes)\n    {\n      if (IS_DEBUG_OSPF_PACKET (0, RECV))\n        zlog_debug (\"%s: length error in link block #%u\", __func__, counted_links);\n      return MSG_NG;\n    }\n    link = (struct router_lsa_link *)((caddr_t) link + thislinklen);\n    linkbytes -= thislinklen;\n    counted_links++;\n  }\n  if (counted_links != num_links)\n  {\n    if (IS_DEBUG_OSPF_PACKET (0, RECV))\n      zlog_debug (\"%s: %u link blocks declared, %u present\",\n                  __func__, num_links, counted_links);\n    return MSG_NG;\n  }\n  return MSG_OK;\n}", "target": 0}
{"code": "TIFFNumberOfStrips(TIFF* tif)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint32 nstrips;\n    if( td->td_nstrips )\n        return td->td_nstrips;\n\tnstrips = (td->td_rowsperstrip == (uint32) -1 ? 1 :\n\t     TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip));\n\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE)\n\t\tnstrips = _TIFFMultiply32(tif, nstrips, (uint32)td->td_samplesperpixel,\n\t\t    \"TIFFNumberOfStrips\");\n\treturn (nstrips);\n}", "target": 1}
{"code": "    Classifier (const char *&ptr, int size)\n    {\n        if (size <= 0) \n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (truncated rule).\");\n        {\n            char suffix[Name::SIZE+1];\n            memset (suffix, 0, Name::SIZE+1);\n            Xdr::read<CharPtrIO> (ptr, std::min(size, Name::SIZE-1), suffix);\n            _suffix = std::string(suffix);\n        }\n        if (static_cast<size_t>(size) < _suffix.length() + 1 + 2*Xdr::size<char>()) \n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (truncated rule).\");\n        char value;\n        Xdr::read<CharPtrIO> (ptr, value);\n        _cscIdx = (int)(value >> 4) - 1;\n        if (_cscIdx < -1 || _cscIdx >= 3) \n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (corrupt cscIdx rule).\");\n        _scheme = (CompressorScheme)((value >> 2) & 3);\n        if (_scheme < 0 || _scheme >= NUM_COMPRESSOR_SCHEMES) \n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (corrupt scheme rule).\");\n        _caseInsensitive = (value & 1 ? true : false);\n        Xdr::read<CharPtrIO> (ptr, value);\n        if (value < 0 || value >= NUM_PIXELTYPES) \n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (corrupt rule).\");\n        _type = (PixelType)value;\n    }", "target": 0}
{"code": "static struct ast_sip_endpoint *ip_identify(pjsip_rx_data *rdata)\n{\n\tstruct ast_sockaddr_with_tp addr_with_tp = { { { 0, } }, };\n\tpj_ansi_strxcpy(addr_with_tp.tp, rdata->tp_info.transport->type_name, sizeof(addr_with_tp.tp));\n\tast_sockaddr_parse(&addr_with_tp.addr, rdata->pkt_info.src_name, PARSE_PORT_FORBID);\n\tast_sockaddr_set_port(&addr_with_tp.addr, rdata->pkt_info.src_port);\n\treturn common_identify(ip_identify_match_check, &addr_with_tp);\n}", "target": 1}
{"code": "void ssl_update_cache(SSL *s, int mode)\n{\n    int i;\n    if (s->session->session_id_length == 0)\n        return;\n    if (s->server && s->session->sid_ctx_length == 0\n            && (s->verify_mode & SSL_VERIFY_PEER) != 0)\n        return;\n    i = s->session_ctx->session_cache_mode;\n    if ((i & mode) != 0\n        && (!s->hit || SSL_IS_TLS13(s))) {\n        if ((i & SSL_SESS_CACHE_NO_INTERNAL_STORE) == 0\n                && (!SSL_IS_TLS13(s)\n                    || !s->server\n                    || (s->max_early_data > 0\n                        && (s->options & SSL_OP_NO_ANTI_REPLAY) == 0)\n                    || s->session_ctx->remove_session_cb != NULL\n                    || (s->options & SSL_OP_NO_TICKET) != 0))\n            SSL_CTX_add_session(s->session_ctx, s->session);\n        if (s->session_ctx->new_session_cb != NULL) {\n            SSL_SESSION_up_ref(s->session);\n            if (!s->session_ctx->new_session_cb(s, s->session))\n                SSL_SESSION_free(s->session);\n        }\n    }\n    if ((!(i & SSL_SESS_CACHE_NO_AUTO_CLEAR)) && ((i & mode) == mode)) {\n        TSAN_QUALIFIER int *stat;\n        if (mode & SSL_SESS_CACHE_CLIENT)\n            stat = &s->session_ctx->stats.sess_connect_good;\n        else\n            stat = &s->session_ctx->stats.sess_accept_good;\n        if ((ssl_tsan_load(s->session_ctx, stat) & 0xff) == 0xff)\n            SSL_CTX_flush_sessions(s->session_ctx, (unsigned long)time(NULL));\n    }\n}", "target": 1}
{"code": "void common_timer_get(struct k_itimer *timr, struct itimerspec64 *cur_setting)\n{\n\tconst struct k_clock *kc = timr->kclock;\n\tktime_t now, remaining, iv;\n\tstruct timespec64 ts64;\n\tbool sig_none;\n\tsig_none = timr->it_sigev_notify == SIGEV_NONE;\n\tiv = timr->it_interval;\n\tif (iv) {\n\t\tcur_setting->it_interval = ktime_to_timespec64(iv);\n\t} else if (!timr->it_active) {\n\t\tif (!sig_none)\n\t\t\treturn;\n\t}\n\tkc->clock_get(timr->it_clock, &ts64);\n\tnow = timespec64_to_ktime(ts64);\n\tif (iv && (timr->it_requeue_pending & REQUEUE_PENDING || sig_none))\n\t\ttimr->it_overrun += (int)kc->timer_forward(timr, now);\n\tremaining = kc->timer_remaining(timr, now);\n\tif (remaining <= 0) {\n\t\tif (!sig_none)\n\t\t\tcur_setting->it_value.tv_nsec = 1;\n\t} else {\n\t\tcur_setting->it_value = ktime_to_timespec64(remaining);\n\t}\n}", "target": 1}
{"code": "FileSpec::FileSpec(const Object *fileSpecA)\n{\n  ok = true;\n  fileName = nullptr;\n  platformFileName = nullptr;\n  embFile = nullptr;\n  desc = nullptr;\n  fileSpec = fileSpecA->copy();\n  Object obj1 = getFileSpecName(fileSpecA);\n  if (!obj1.isString()) {\n    ok = false;\n    error(errSyntaxError, -1, \"Invalid FileSpec\");\n    return;\n  }\n  fileName = obj1.getString()->copy();\n  if (fileSpec.isDict()) {\n    obj1 = fileSpec.dictLookup(\"EF\");\n    if (obj1.isDict()) {\n      fileStream = obj1.dictLookupNF(\"F\");\n      if (!fileStream.isRef()) {\n        ok = false;\n        fileStream.setToNull();\n        error(errSyntaxError, -1, \"Invalid FileSpec: Embedded file stream is not an indirect reference\");\n        return;\n      }\n    }\n  }\n  obj1 = fileSpec.dictLookup(\"Desc\");\n  if (obj1.isString())\n    desc = obj1.getString()->copy();\n}", "target": 1}
{"code": "otError Commissioner::AddJoiner(const Mac::ExtAddress *aEui64, const char *aPskd, uint32_t aTimeout)\n{\n    otError error = OT_ERROR_NO_BUFS;\n    VerifyOrExit(mState == OT_COMMISSIONER_STATE_ACTIVE, error = OT_ERROR_INVALID_STATE);\n    VerifyOrExit(strlen(aPskd) <= Dtls::kPskMaxLength, error = OT_ERROR_INVALID_ARGS);\n    RemoveJoiner(aEui64, 0); \n    for (Joiner *joiner = &mJoiners[0]; joiner < OT_ARRAY_END(mJoiners); joiner++)\n    {\n        if (joiner->mValid)\n        {\n            continue;\n        }\n        if (aEui64 != NULL)\n        {\n            joiner->mEui64 = *aEui64;\n            joiner->mAny   = false;\n        }\n        else\n        {\n            joiner->mAny = true;\n        }\n        (void)strlcpy(joiner->mPsk, aPskd, sizeof(joiner->mPsk));\n        joiner->mValid          = true;\n        joiner->mExpirationTime = TimerMilli::GetNow() + Time::SecToMsec(aTimeout);\n        UpdateJoinerExpirationTimer();\n        SendCommissionerSet();\n        otLogInfoMeshCoP(\"Added Joiner (%s, %s)\", (aEui64 != NULL) ? aEui64->ToString().AsCString() : \"*\", aPskd);\n        ExitNow(error = OT_ERROR_NONE);\n    }\nexit:\n    return error;\n}", "target": 1}
{"code": "ssh_packet_set_compress_state(struct ssh *ssh, struct sshbuf *m)\n{\n\tstruct session_state *state = ssh->state;\n\tstruct sshbuf *b = NULL;\n\tint r;\n\tconst u_char *inblob, *outblob;\n\tsize_t inl, outl;\n\tif ((r = sshbuf_froms(m, &b)) != 0)\n\t\tgoto out;\n\tif ((r = sshbuf_get_string_direct(b, &inblob, &inl)) != 0 ||\n\t    (r = sshbuf_get_string_direct(b, &outblob, &outl)) != 0)\n\t\tgoto out;\n\tif (inl == 0)\n\t\tstate->compression_in_started = 0;\n\telse if (inl != sizeof(state->compression_in_stream)) {\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t} else {\n\t\tstate->compression_in_started = 1;\n\t\tmemcpy(&state->compression_in_stream, inblob, inl);\n\t}\n\tif (outl == 0)\n\t\tstate->compression_out_started = 0;\n\telse if (outl != sizeof(state->compression_out_stream)) {\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t} else {\n\t\tstate->compression_out_started = 1;\n\t\tmemcpy(&state->compression_out_stream, outblob, outl);\n\t}\n\tr = 0;\n out:\n\tsshbuf_free(b);\n\treturn r;\n}", "target": 1}
{"code": "SECURITY_STATUS SEC_ENTRY DeleteSecurityContext(PCtxtHandle phContext)\n{\n\tchar* Name;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableA* table;\n\tName = (char*) sspi_SecureHandleGetUpperPointer(phContext);\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\ttable = sspi_GetSecurityFunctionTableAByNameA(Name);\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\tif (table->DeleteSecurityContext == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\tstatus = table->DeleteSecurityContext(phContext);\n\treturn status;\n}", "target": 1}
{"code": "init_ccline(int firstc, int indent)\n{\n    ccline.overstrike = FALSE;\t\t    \n    ccline.cmdfirstc = (firstc == '@' ? 0 : firstc);\n    ccline.cmdindent = (firstc > 0 ? indent : 0);\n    alloc_cmdbuff(exmode_active ? 250 : indent + 1);\n    if (ccline.cmdbuff == NULL)\n\treturn FAIL;\n    ccline.cmdlen = ccline.cmdpos = 0;\n    ccline.cmdbuff[0] = NUL;\n    sb_text_start_cmdline();\n    if (firstc <= 0)\n    {\n\tvim_memset(ccline.cmdbuff, ' ', indent);\n\tccline.cmdbuff[indent] = NUL;\n\tccline.cmdpos = indent;\n\tccline.cmdspos = indent;\n\tccline.cmdlen = indent;\n    }\n    return OK;\n}", "target": 1}
{"code": "int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n{\n#ifndef WITH_BROKER\n\tchar sockpair_data = 0;\n#endif\n\tassert(mosq);\n\tassert(packet);\n\tpacket->pos = 0;\n\tpacket->to_process = packet->packet_length;\n\tpacket->next = NULL;\n\tpthread_mutex_lock(&mosq->out_packet_mutex);\n#ifdef WITH_BROKER\n\tif(mosq->out_packet_count >= db.config->max_queued_messages){\n\t\tmosquitto__free(packet);\n\t\tif(mosq->is_dropping == false){\n\t\t\tmosq->is_dropping = true;\n\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n\t\t\t\t\t\"Outgoing messages are being dropped for client %s.\",\n\t\t\t\t\tmosq->id);\n\t\t}\n\t\tG_MSGS_DROPPED_INC();\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}\n#endif\n\tif(mosq->out_packet){\n\t\tmosq->out_packet_last->next = packet;\n\t}else{\n\t\tmosq->out_packet = packet;\n\t}\n\tmosq->out_packet_last = packet;\n\tmosq->out_packet_count++;\n\tpthread_mutex_unlock(&mosq->out_packet_mutex);\n#ifdef WITH_BROKER\n#  ifdef WITH_WEBSOCKETS\n\tif(mosq->wsi){\n\t\tlws_callback_on_writable(mosq->wsi);\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}else{\n\t\treturn packet__write(mosq);\n\t}\n#  else\n\treturn packet__write(mosq);\n#  endif\n#else\n\tif(mosq->sockpairW != INVALID_SOCKET){\n#ifndef WIN32\n\t\tif(write(mosq->sockpairW, &sockpair_data, 1)){\n\t\t}\n#else\n\t\tsend(mosq->sockpairW, &sockpair_data, 1, 0);\n#endif\n\t}\n\tif(mosq->in_callback == false && mosq->threaded == mosq_ts_none){\n\t\treturn packet__write(mosq);\n\t}else{\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}\n#endif\n}", "target": 0}
{"code": "static int core_upgrade_handler(request_rec *r)\n{\n    conn_rec *c = r->connection;\n    const char *upgrade;\n    if (c->master) {\n        return DECLINED;\n    }\n    upgrade = apr_table_get(r->headers_in, \"Upgrade\");\n    if (upgrade && *upgrade) {\n        const char *conn = apr_table_get(r->headers_in, \"Connection\");\n        if (ap_find_token(r->pool, conn, \"upgrade\")) {\n            apr_array_header_t *offers = NULL;\n            const char *err;\n            err = ap_parse_token_list_strict(r->pool, upgrade, &offers, 0);\n            if (err) {\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02910)\n                              \"parsing Upgrade header: %s\", err);\n                return DECLINED;\n            }\n            if (offers && offers->nelts > 0) {\n                const char *protocol = ap_select_protocol(c, r, NULL, offers);\n                if (protocol && strcmp(protocol, ap_get_protocol(c))) {\n                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02909)\n                                  \"Upgrade selects '%s'\", protocol);\n                    apr_table_clear(r->headers_out);\n                    apr_table_setn(r->headers_out, \"Upgrade\", protocol);\n                    apr_table_setn(r->headers_out, \"Connection\", \"Upgrade\");\n                    r->status = HTTP_SWITCHING_PROTOCOLS;\n                    r->status_line = ap_get_status_line(r->status);\n                    ap_send_interim_response(r, 1);\n                    ap_switch_protocol(c, r, r->server, protocol);\n                    c->keepalive = AP_CONN_CLOSE;\n                    return DONE;\n                }\n            }\n        }\n    }\n    else if (!c->keepalives) {\n        const apr_array_header_t *upgrades;\n        ap_get_protocol_upgrades(c, r, NULL, 0, &upgrades);\n        if (upgrades && upgrades->nelts > 0) {\n            char *protocols = apr_array_pstrcat(r->pool, upgrades, ',');\n            apr_table_setn(r->headers_out, \"Upgrade\", protocols);\n            apr_table_setn(r->headers_out, \"Connection\", \"Upgrade\");\n        }\n    }\n    return DECLINED;\n}", "target": 0}
{"code": "static int fetch_setup_walk(git_revwalk **out, git_repository *repo)\n{\n\tgit_revwalk *walk = NULL;\n\tgit_strarray refs;\n\tunsigned int i;\n\tgit_reference *ref;\n\tint error;\n\tif ((error = git_reference_list(&refs, repo)) < 0)\n\t\treturn error;\n\tif ((error = git_revwalk_new(&walk, repo)) < 0)\n\t\treturn error;\n\tgit_revwalk_sorting(walk, GIT_SORT_TIME);\n\tfor (i = 0; i < refs.count; ++i) {\n\t\tif (!git__prefixcmp(refs.strings[i], GIT_REFS_TAGS_DIR))\n\t\t\tcontinue;\n\t\tif ((error = git_reference_lookup(&ref, repo, refs.strings[i])) < 0)\n\t\t\tgoto on_error;\n\t\tif (git_reference_type(ref) == GIT_REF_SYMBOLIC)\n\t\t\tcontinue;\n\t\tif ((error = git_revwalk_push(walk, git_reference_target(ref))) < 0)\n\t\t\tgoto on_error;\n\t\tgit_reference_free(ref);\n\t}\n\tgit_strarray_free(&refs);\n\t*out = walk;\n\treturn 0;\non_error:\n\tgit_revwalk_free(walk);\n\tgit_reference_free(ref);\n\tgit_strarray_free(&refs);\n\treturn error;\n}", "target": 0}
{"code": "  explicit ReverseSequenceOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"batch_dim\", &batch_dim_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seq_dim\", &seq_dim_));\n  }", "target": 1}
{"code": "void RGWSetBucketWebsite_ObjStore_S3::send_response()\n{\n  if (op_ret < 0)\n    set_req_state_err(s, op_ret);\n  dump_errno(s);\n  end_header(s, this, \"application/xml\");\n}", "target": 0}
{"code": "static void unix_release_sock(struct sock *sk, int embrion)\n{\n\tstruct unix_sock *u = unix_sk(sk);\n\tstruct path path;\n\tstruct sock *skpair;\n\tstruct sk_buff *skb;\n\tint state;\n\tunix_remove_socket(sk);\n\tunix_state_lock(sk);\n\tsock_orphan(sk);\n\tsk->sk_shutdown = SHUTDOWN_MASK;\n\tpath\t     = u->path;\n\tu->path.dentry = NULL;\n\tu->path.mnt = NULL;\n\tstate = sk->sk_state;\n\tsk->sk_state = TCP_CLOSE;\n\tunix_state_unlock(sk);\n\twake_up_interruptible_all(&u->peer_wait);\n\tskpair = unix_peer(sk);\n\tif (skpair != NULL) {\n\t\tif (sk->sk_type == SOCK_STREAM || sk->sk_type == SOCK_SEQPACKET) {\n\t\t\tunix_state_lock(skpair);\n\t\t\tskpair->sk_shutdown = SHUTDOWN_MASK;\n\t\t\tif (!skb_queue_empty(&sk->sk_receive_queue) || embrion)\n\t\t\t\tskpair->sk_err = ECONNRESET;\n\t\t\tunix_state_unlock(skpair);\n\t\t\tskpair->sk_state_change(skpair);\n\t\t\tsk_wake_async(skpair, SOCK_WAKE_WAITD, POLL_HUP);\n\t\t}\n\t\tunix_dgram_peer_wake_disconnect(sk, skpair);\n\t\tsock_put(skpair); \n\t\tunix_peer(sk) = NULL;\n\t}\n\twhile ((skb = skb_dequeue(&sk->sk_receive_queue)) != NULL) {\n\t\tif (state == TCP_LISTEN)\n\t\t\tunix_release_sock(skb->sk, 1);\n\t\tUNIXCB(skb).consumed = skb->len;\n\t\tkfree_skb(skb);\n\t}\n\tif (path.dentry)\n\t\tpath_put(&path);\n\tsock_put(sk);\n\tif (unix_tot_inflight)\n\t\tunix_gc();\t\t\n}", "target": 0}
{"code": "ahcp_time_print(netdissect_options *ndo,\n                const u_char *cp, uint8_t len)\n{\n\ttime_t t;\n\tstruct tm *tm;\n\tchar buf[BUFSIZE];\n\tif (len != 4)\n\t\tgoto invalid;\n\tt = GET_BE_U_4(cp);\n\tif (NULL == (tm = gmtime(&t)))\n\t\tND_PRINT(\": gmtime() error\");\n\telse if (0 == strftime(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\", tm))\n\t\tND_PRINT(\": strftime() error\");\n\telse\n\t\tND_PRINT(\": %s UTC\", buf);\n\treturn;\ninvalid:\n\tnd_print_invalid(ndo);\n\tND_TCHECK_LEN(cp, len);\n}", "target": 1}
{"code": "void closeFile(PlatformFileHandle& handle)\n{\n    if (isHandleValid(handle)) {\n        ::CloseHandle(handle);\n        handle = invalidPlatformFileHandle;\n    }\n}", "target": 0}
{"code": "netsnmp_mibindex_load( void )\n{\n    DIR *dir;\n    struct dirent *file;\n    FILE *fp;\n    char tmpbuf[ 300];\n    char tmpbuf2[300];\n    int  i;\n    char *cp;\n    snprintf( tmpbuf, sizeof(tmpbuf), \"%s/mib_indexes\",\n              get_persistent_directory());\n    tmpbuf[sizeof(tmpbuf)-1] = 0;\n    dir = opendir( tmpbuf );\n    if ( dir == NULL ) {\n        DEBUGMSGTL((\"mibindex\", \"load: (new)\\n\"));\n        mkdirhier( tmpbuf, NETSNMP_AGENT_DIRECTORY_MODE, 0);\n        return;\n    }\n    while ((file = readdir( dir ))) {\n        if ( !isdigit((unsigned char)(file->d_name[0])))\n            continue;\n        i = atoi( file->d_name );\n        snprintf( tmpbuf, sizeof(tmpbuf), \"%s/mib_indexes/%d\",\n              get_persistent_directory(), i );\n        tmpbuf[sizeof(tmpbuf)-1] = 0;\n        fp = fopen( tmpbuf, \"r\" );\n        if (!fp)\n            continue;\n        cp = fgets( tmpbuf2, sizeof(tmpbuf2), fp );\n        fclose( fp );\n        if ( !cp ) {\n            DEBUGMSGTL((\"mibindex\", \"Empty MIB index (%d)\\n\", i));\n            continue;\n        }\n        if ( strncmp( tmpbuf2, \"DIR \", 4 ) != 0 ) {\n            DEBUGMSGTL((\"mibindex\", \"Malformed MIB index (%d)\\n\", i));\n            continue;\n        }\n        tmpbuf2[strlen(tmpbuf2)-1] = 0;\n        DEBUGMSGTL((\"mibindex\", \"load: (%d) %s\\n\", i, tmpbuf2));\n        (void)_mibindex_add( tmpbuf2+4, i );  \n    }\n    closedir( dir );\n}", "target": 1}
{"code": "static void get_info_from_frame (mpeg2ps_stream_t *sptr,\n                                 u8 *buffer,\n                                 u32 buflen)\n{\n\tif (sptr->is_video) {\n\t\tif (MPEG12_ParseSeqHdr(buffer, buflen,\n\t\t                       &sptr->have_mpeg2,\n\t\t                       &sptr->h,\n\t\t                       &sptr->w,\n\t\t                       &sptr->frame_rate,\n\t\t                       &sptr->bit_rate,\n\t\t                       &sptr->par) < 0) {\n\t\t\tsptr->m_stream_id = 0;\n\t\t\tsptr->m_fd = FDNULL;\n\t\t\treturn;\n\t\t}\n\t\tsptr->ticks_per_frame = (u64)(90000.0 / sptr->frame_rate);\n\t\treturn;\n\t}\n\tif (sptr->m_stream_id >= 0xc0) {\n\t\tu32 hdr = GF_4CC((u32)buffer[0],buffer[1],buffer[2],buffer[3]);\n\t\tsptr->channels = gf_mp3_num_channels(hdr);\n\t\tsptr->freq = gf_mp3_sampling_rate(hdr);\n\t\tsptr->samples_per_frame = gf_mp3_window_size(hdr);\n\t\tsptr->bitrate = gf_mp3_bit_rate(hdr) * 1000; \n\t\tsptr->layer = gf_mp3_layer(hdr);\n\t} else if (sptr->m_stream_id == 0xbd) {\n\t\tif (sptr->m_substream_id >= 0xa0) {\n\t\t} else if (sptr->m_substream_id >= 0x80) {\n\t\t\tu32 pos;\n\t\t\tGF_AC3Config hdr;\n\t\t\tmemset(&hdr, 0, sizeof(GF_AC3Config));\n\t\t\tgf_ac3_parser(buffer, buflen, &pos, &hdr, 0);\n\t\t\tsptr->bitrate = gf_ac3_get_bitrate(hdr.brcode);\n\t\t\tsptr->freq = hdr.sample_rate;\n\t\t\tsptr->channels = hdr.streams[0].channels;\n\t\t\tsptr->samples_per_frame = 256 * 6;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\treturn;\n\t}\n}", "target": 0}
{"code": "int nfc_dev_down(struct nfc_dev *dev)\n{\n\tint rc = 0;\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (!dev->dev_up) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\tif (dev->polling || dev->active_target) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\tif (dev->ops->dev_down)\n\t\tdev->ops->dev_down(dev);\n\tdev->dev_up = false;\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "void LibRaw::process_Sony_0x0116(uchar *buf, ushort len, unsigned long long id)\n{\n  int i = 0;\n  if (((id == 0x101ULL) || \n       (id == 0x106ULL) || \n       (id == 0x10dULL) || \n       (id == 0x10eULL)    \n       ) &&\n      (len >= 2))\n    i = 1;\n  else if ((id >= 0x111ULL) && (len >= 3))\n    i = 2;\n  else\n    return;\n  imgdata.makernotes.common.BatteryTemperature = (float)(buf[i] - 32) / 1.8f;\n}", "target": 0}
{"code": " void DelegatedFrameHost::ClearDelegatedFrame() {\n   EvictDelegatedFrame();\n }", "target": 1}
{"code": "static inline int cipso_v4_validate(const struct sk_buff *skb,\n\t\t\t\t    unsigned char **option)\n{\n\tunsigned char *opt = *option;\n\tunsigned char err_offset = 0;\n\tu8 opt_len = opt[1];\n\tu8 opt_iter;\n\tif (opt_len < 8) {\n\t\terr_offset = 1;\n\t\tgoto out;\n\t}\n\tif (get_unaligned_be32(&opt[2]) == 0) {\n\t\terr_offset = 2;\n\t\tgoto out;\n\t}\n\tfor (opt_iter = 6; opt_iter < opt_len;) {\n\t\tif (opt[opt_iter + 1] > (opt_len - opt_iter)) {\n\t\t\terr_offset = opt_iter + 1;\n\t\t\tgoto out;\n\t\t}\n\t\topt_iter += opt[opt_iter + 1];\n\t}\nout:\n\t*option = opt + err_offset;\n\treturn err_offset;\n}", "target": 1}
{"code": "ble_hs_conn_timer(void)\n{\n#if MYNEWT_VAL(BLE_L2CAP_RX_FRAG_TIMEOUT) == 0 && \\\n    BLE_HS_ATT_SVR_QUEUED_WRITE_TMO == 0\n    return BLE_HS_FOREVER;\n#endif\n    struct ble_hs_conn *conn;\n    ble_npl_time_t now;\n    int32_t next_exp_in;\n    int32_t time_diff;\n    uint16_t conn_handle;\n    for (;;) {\n        conn_handle = BLE_HS_CONN_HANDLE_NONE;\n        next_exp_in = BLE_HS_FOREVER;\n        now = ble_npl_time_get();\n        ble_hs_lock();\n        SLIST_FOREACH(conn, &ble_hs_conns, bhc_next) {\n            if (!(conn->bhc_flags & BLE_HS_CONN_F_TERMINATING)) {\n#if MYNEWT_VAL(BLE_L2CAP_RX_FRAG_TIMEOUT) != 0\n                if (conn->bhc_rx_chan != NULL) {\n                    time_diff = conn->bhc_rx_timeout - now;\n                    if (time_diff <= 0) {\n                        conn_handle = conn->bhc_handle;\n                        break;\n                    }\n                    if (time_diff < next_exp_in) {\n                        next_exp_in = time_diff;\n                    }\n                }\n#endif\n#if BLE_HS_ATT_SVR_QUEUED_WRITE_TMO\n                time_diff = ble_att_svr_ticks_until_tmo(&conn->bhc_att_svr, now);\n                if (time_diff <= 0) {\n                    conn_handle = conn->bhc_handle;\n                    break;\n                }\n                if (time_diff < next_exp_in) {\n                    next_exp_in = time_diff;\n                }\n#endif\n            }\n        }\n        ble_hs_unlock();\n        if (conn_handle != BLE_HS_CONN_HANDLE_NONE) {\n            ble_gap_terminate(conn_handle, BLE_ERR_REM_USER_CONN_TERM);\n            continue;\n        }\n        return next_exp_in;\n    }\n}", "target": 1}
{"code": "static int bson_validate_string( bson *b, const unsigned char *string,\n                                 const int length, const char check_utf8, const char check_dot,\n                                 const char check_dollar ) {\n    int position = 0;\n    int sequence_length = 1;\n    if( check_dollar && string[0] == '$' ) {\n        if( !bson_string_is_db_ref( string, length ) )\n            b->err |= BSON_FIELD_INIT_DOLLAR;\n    }\n    while ( position < length ) {\n        if ( check_dot && *( string + position ) == '.' ) {\n            b->err |= BSON_FIELD_HAS_DOT;\n        }\n        if ( check_utf8 ) {\n            sequence_length = trailingBytesForUTF8[*( string + position )] + 1;\n            if ( ( position + sequence_length ) > length ) {\n                b->err |= BSON_NOT_UTF8;\n                return BSON_ERROR;\n            }\n            if ( !isLegalUTF8( string + position, sequence_length ) ) {\n                b->err |= BSON_NOT_UTF8;\n                return BSON_ERROR;\n            }\n        }\n        position += sequence_length;\n    }\n    return BSON_OK;\n}", "target": 1}
{"code": "void html_link_open(const char *url, const char *title, const char *class)\n{\n\thtml(\"<a href='\");\n\thtml_attr(url);\n\tif (title) {\n\t\thtml(\"' title='\");\n\t\thtml_attr(title);\n\t}\n\tif (class) {\n\t\thtml(\"' class='\");\n\t\thtml_attr(class);\n\t}\n\thtml(\"'>\");\n}", "target": 0}
{"code": "void Jsi_ValueArrayShift(Jsi_Interp *interp, Jsi_Value *v)\n{\n    if (v->vt != JSI_VT_OBJECT) {\n        Jsi_LogBug(\"Jsi_ValueArrayShift, target is not object\");\n        return;\n    }\n    Jsi_Obj *o = v->d.obj;\n    if (o->isarrlist) {\n        uint i;\n        if (!o->arrCnt)\n            return;\n        if (o->arr[0])\n            Jsi_DecrRefCount(interp, o->arr[0]);\n        for (i=1; i<o->arrCnt; i++) {\n            o->arr[i-1] = o->arr[i];\n        }\n        o->arr[o->arrCnt--] = NULL;\n        return;\n    }\n    int len = Jsi_ObjGetLength(interp, v->d.obj);\n    if (len <= 0) return;\n    Jsi_Value *v0 = Jsi_ValueArrayIndex(interp, v, 0);\n    if (!v0) return;\n    Jsi_ValueReset(interp, &v0);\n    int i;\n    Jsi_Value *last = v0;\n    for (i = 1; i < len; ++i) {\n        Jsi_Value *t = Jsi_ValueArrayIndex(interp, v, i);\n        if (!t) return;\n        Jsi_ValueCopy(interp, last, t);\n        Jsi_ValueReset(interp, &t);\n        last = t;\n    }\n    Jsi_ObjSetLength(interp, v->d.obj, len - 1);\n}", "target": 1}
{"code": "static void bump_cpu_timer(struct k_itimer *timer, u64 now)\n{\n\tint i;\n\tu64 delta, incr;\n\tif (timer->it.cpu.incr == 0)\n\t\treturn;\n\tif (now < timer->it.cpu.expires)\n\t\treturn;\n\tincr = timer->it.cpu.incr;\n\tdelta = now + incr - timer->it.cpu.expires;\n\tfor (i = 0; incr < delta - incr; i++)\n\t\tincr = incr << 1;\n\tfor (; i >= 0; incr >>= 1, i--) {\n\t\tif (delta < incr)\n\t\t\tcontinue;\n\t\ttimer->it.cpu.expires += incr;\n\t\ttimer->it_overrun += 1 << i;\n\t\tdelta -= incr;\n\t}\n}", "target": 1}
{"code": "void luaC_fix (lua_State *L, GCObject *o) {\n  global_State *g = G(L);\n  lua_assert(g->allgc == o);  \n  white2gray(o);  \n  setage(o, G_OLD);  \n  g->allgc = o->next;  \n  o->next = g->fixedgc;  \n  g->fixedgc = o;\n}", "target": 0}
{"code": "long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\tkey_ref = lookup_user_key(keyid, 0, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n\tkey = key_ref_to_ptr(key_ref);\n\tret = key_permission(key_ref, KEY_NEED_READ);\n\tif (ret == 0)\n\t\tgoto can_read_key;\n\tif (ret != -EACCES)\n\t\tgoto error;\n\tif (!is_key_possessed(key_ref)) {\n\t\tret = -EACCES;\n\t\tgoto error2;\n\t}\ncan_read_key:\n\tret = key_validate(key);\n\tif (ret == 0) {\n\t\tret = -EOPNOTSUPP;\n\t\tif (key->type->read) {\n\t\t\tdown_read(&key->sem);\n\t\t\tret = key->type->read(key, buffer, buflen);\n\t\t\tup_read(&key->sem);\n\t\t}\n\t}\nerror2:\n\tkey_put(key);\nerror:\n\treturn ret;\n}", "target": 1}
{"code": "static int perf_swevent_add(struct perf_event *event, int flags)\n{\n\tstruct swevent_htable *swhash = this_cpu_ptr(&swevent_htable);\n\tstruct hw_perf_event *hwc = &event->hw;\n\tstruct hlist_head *head;\n\tif (is_sampling_event(event)) {\n\t\thwc->last_period = hwc->sample_period;\n\t\tperf_swevent_set_period(event);\n\t}\n\thwc->state = !(flags & PERF_EF_START);\n\thead = find_swevent_head(swhash, event);\n\tif (!head) {\n\t\tWARN_ON_ONCE(swhash->online);\n\t\treturn -EINVAL;\n\t}\n\thlist_add_head_rcu(&event->hlist_entry, head);\n\tperf_event_update_userpage(event);\n\treturn 0;\n}", "target": 1}
{"code": "void *bson_realloc( void *ptr, int size ) {\n    void *p;\n    p = bson_realloc_func( ptr, size );\n    bson_fatal_msg( !!p, \"realloc() failed\" );\n    return p;\n}", "target": 1}
{"code": "bgp_attr_cluster_list (struct bgp_attr_parser_args *args)\n{\n  struct peer *const peer = args->peer; \n  struct attr *const attr = args->attr;\n  const bgp_size_t length = args->length;\n  if (length % 4)\n    {\n      zlog (peer->log, LOG_ERR, \"Bad cluster list length %d\", length);\n      return bgp_attr_malformed (args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n                                 args->total);\n    }\n  (bgp_attr_extra_get (attr))->cluster \n    = cluster_parse ((struct in_addr *)stream_pnt (peer->ibuf), length);\n  stream_forward_getp (peer->ibuf, length);\n  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_CLUSTER_LIST);\n  return BGP_ATTR_PARSE_PROCEED;\n}", "target": 0}
{"code": "CotpConnection_readToTpktBuffer(CotpConnection* self)\n{\n    uint8_t* buffer = self->readBuffer->buffer;\n    int bufferSize = self->readBuffer->maxSize;\n    int bufPos = self->readBuffer->size;\n    assert (bufferSize > 4);\n    int readBytes;\n    if (bufPos < 4) {\n        readBytes = readFromSocket(self, buffer + bufPos, 4 - bufPos);\n        if (readBytes < 0)\n            goto exit_closed;\n        if (DEBUG_COTP) {\n            if (readBytes > 0)\n                printf(\"TPKT: read %i bytes from socket\\n\", readBytes);\n        }\n        bufPos += readBytes;\n        if (bufPos == 4) {\n            if ((buffer[0] == 3) && (buffer[1] == 0)) {\n                self->packetSize = (buffer[2] * 0x100) + buffer[3];\n                if (DEBUG_COTP)\n                    printf(\"TPKT: header complete (msg size = %i)\\n\", self->packetSize);\n                if (self->packetSize > bufferSize) {\n                    if (DEBUG_COTP) printf(\"TPKT: packet too large\\n\");\n                    goto exit_error;\n                }\n            }\n            else {\n                if (DEBUG_COTP) printf(\"TPKT: failed to decode TPKT header.\\n\");\n                goto exit_error;\n            }\n        }\n        else\n            goto exit_waiting;\n    }\n    readBytes = readFromSocket(self, buffer + bufPos, self->packetSize - bufPos);\n    if (readBytes < 0)\n        goto exit_closed;\n    bufPos += readBytes;\n    if (bufPos < self->packetSize)\n       goto exit_waiting;\n    if (DEBUG_COTP) printf(\"TPKT: message complete (size = %i)\\n\", self->packetSize);\n    self->readBuffer->size = bufPos;\n    return TPKT_PACKET_COMPLETE;\nexit_closed:\n    if (DEBUG_COTP) printf(\"TPKT: socket closed or socket error\\n\");\n    return TPKT_ERROR;\nexit_error:\n    if (DEBUG_COTP) printf(\"TPKT: Error parsing message\\n\");\n    return TPKT_ERROR;\nexit_waiting:\n    if (DEBUG_COTP)\n        if (bufPos != 0)\n            printf(\"TPKT: waiting (read %i of %i)\\n\", bufPos, self->packetSize);\n    self->readBuffer->size = bufPos;\n    return TPKT_WAITING;\n}", "target": 1}
{"code": "    const CImgList<T>& save_gzip_external(const char *const filename) const {\n      if (!filename)\n        throw CImgIOException(_cimglist_instance\n                              \"save_gzip_external(): Specified filename is (null).\",\n                              cimglist_instance);\n      CImg<charT> command(1024), filename_tmp(256), body(256);\n      const char\n        *ext = cimg::split_filename(filename,body),\n        *ext2 = cimg::split_filename(body,0);\n      std::FILE *file;\n      do {\n        if (!cimg::strcasecmp(ext,\"gz\")) {\n          if (*ext2) cimg_snprintf(filename_tmp,filename_tmp._width,\"%s%c%s.%s\",\n                                   cimg::temporary_path(),cimg_file_separator,cimg::filenamerand(),ext2);\n          else cimg_snprintf(filename_tmp,filename_tmp._width,\"%s%c%s.cimg\",\n                             cimg::temporary_path(),cimg_file_separator,cimg::filenamerand());\n        } else {\n          if (*ext) cimg_snprintf(filename_tmp,filename_tmp._width,\"%s%c%s.%s\",\n                                  cimg::temporary_path(),cimg_file_separator,cimg::filenamerand(),ext);\n          else cimg_snprintf(filename_tmp,filename_tmp._width,\"%s%c%s.cimg\",\n                             cimg::temporary_path(),cimg_file_separator,cimg::filenamerand());\n        }\n        if ((file=std_fopen(filename_tmp,\"rb\"))!=0) cimg::fclose(file);\n      } while (file);\n      if (is_saveable(body)) {\n        save(filename_tmp);\n        cimg_snprintf(command,command._width,\"%s -c \\\"%s\\\" > \\\"%s\\\"\",\n                      cimg::gzip_path(),\n                      CImg<charT>::string(filename_tmp)._system_strescape().data(),\n                      CImg<charT>::string(filename)._system_strescape().data());\n        cimg::system(command);\n        file = std_fopen(filename,\"rb\");\n        if (!file)\n          throw CImgIOException(_cimglist_instance\n                                \"save_gzip_external(): Failed to save file '%s' with external command 'gzip'.\",\n                                cimglist_instance,\n                                filename);\n        else cimg::fclose(file);\n        std::remove(filename_tmp);\n      } else {\n        CImg<charT> nfilename(1024);\n        cimglist_for(*this,l) {\n          cimg::number_filename(body,l,6,nfilename);\n          if (*ext) cimg_sprintf(nfilename._data + std::strlen(nfilename),\".%s\",ext);\n          _data[l].save_gzip_external(nfilename);", "target": 0}
{"code": "static void __dvb_frontend_free(struct dvb_frontend *fe)\n{\n\tstruct dvb_frontend_private *fepriv = fe->frontend_priv;\n\tif (fepriv)\n\t\tdvb_free_device(fepriv->dvbdev);\n\tdvb_frontend_invoke_release(fe, fe->ops.release);\n\tif (!fepriv)\n\t\treturn;\n\tkfree(fepriv);\n\tfe->frontend_priv = NULL;\n}", "target": 1}
{"code": "list_table_status(MYSQL *mysql,const char *db,const char *wild)\n{\n  char query[1024],*end;\n  MYSQL_RES *result;\n  MYSQL_ROW row;\n  end=strxmov(query,\"show table status from `\",db,\"`\",NullS);\n  if (wild && wild[0])\n    strxmov(end,\" like '\",wild,\"'\",NullS);\n  if (mysql_query(mysql,query) || !(result=mysql_store_result(mysql)))\n  {\n    fprintf(stderr,\"%s: Cannot get status for db: %s, table: %s: %s\\n\",\n\t    my_progname,db,wild ? wild : \"\",mysql_error(mysql));\n    if (mysql_errno(mysql) == ER_PARSE_ERROR)\n      fprintf(stderr,\"This error probably means that your MySQL server doesn't support the\\n\\'show table status' command.\\n\");\n    return 1;\n  }\n  printf(\"Database: %s\",db);\n  if (wild)\n    printf(\"  Wildcard: %s\",wild);\n  putchar('\\n');\n  print_res_header(result);\n  while ((row=mysql_fetch_row(result)))\n    print_res_row(result,row);\n  print_res_top(result);\n  mysql_free_result(result);\n  return 0;\n}", "target": 1}
{"code": "static void ClearMetadata(VP8LMetadata* const hdr) {\n  assert(hdr != NULL);\n  WebPSafeFree(hdr->huffman_image_);\n  WebPSafeFree(hdr->huffman_tables_);\n  VP8LHtreeGroupsFree(hdr->htree_groups_);\n  VP8LColorCacheClear(&hdr->color_cache_);\n  VP8LColorCacheClear(&hdr->saved_color_cache_);\n  InitMetadata(hdr);\n}", "target": 1}
{"code": "static ssize_t tx_maxrate_store(struct netdev_queue *queue,\n\t\t\t\tconst char *buf, size_t len)\n{\n\tstruct net_device *dev = queue->dev;\n\tint err, index = get_netdev_queue_index(queue);\n\tu32 rate = 0;\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\terr = kstrtou32(buf, 10, &rate);\n\tif (err < 0)\n\t\treturn err;\n\tif (!rtnl_trylock())\n\t\treturn restart_syscall();\n\terr = -EOPNOTSUPP;\n\tif (dev->netdev_ops->ndo_set_tx_maxrate)\n\t\terr = dev->netdev_ops->ndo_set_tx_maxrate(dev, index, rate);\n\trtnl_unlock();\n\tif (!err) {\n\t\tqueue->tx_maxrate = rate;\n\t\treturn len;\n\t}\n\treturn err;", "target": 0}
{"code": "static ssize_t _nfsd_copy_file_range(struct nfsd4_copy *copy)\n{\n\tssize_t bytes_copied = 0;\n\tsize_t bytes_total = copy->cp_count;\n\tu64 src_pos = copy->cp_src_pos;\n\tu64 dst_pos = copy->cp_dst_pos;\n\tdo {\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\t\tbytes_copied = nfsd_copy_file_range(copy->file_src, src_pos,\n\t\t\t\tcopy->file_dst, dst_pos, bytes_total);\n\t\tif (bytes_copied <= 0)\n\t\t\tbreak;\n\t\tbytes_total -= bytes_copied;\n\t\tcopy->cp_res.wr_bytes_written += bytes_copied;\n\t\tsrc_pos += bytes_copied;\n\t\tdst_pos += bytes_copied;\n\t} while (bytes_total > 0 && !copy->cp_synchronous);\n\treturn bytes_copied;\n}", "target": 0}
{"code": "  void connectErr(const AsyncSocketException& ex) noexcept override {\n    FAIL() << ex.what();\n  }", "target": 0}
{"code": "static void FNAME(update_model)(CommonState *state, s_bucket * const bucket,\n                                const BYTE curval)\n{\n    SPICE_VERIFY(BPC >= 1);\n    spice_return_if_fail (bucket != NULL);\n    const unsigned int bpp = BPC;\n    COUNTER * const pcounters = bucket->pcounters;\n    unsigned int i;\n    unsigned int bestcode;\n    unsigned int bestcodelen;\n    bestcode = bpp - 1;\n    bestcodelen = (pcounters[bestcode] += FNAME(golomb_code_len)(curval, bestcode));\n    for (i = bpp - 2; i < bpp; i--) { \n        const unsigned int ithcodelen = (pcounters[i] += FNAME(golomb_code_len)(curval, i));\n        if (ithcodelen < bestcodelen) {\n            bestcode = i;\n            bestcodelen = ithcodelen;\n        }\n    }\n    bucket->bestcode = bestcode; \n    if (bestcodelen > state->wm_trigger) { \n        for (i = 0; i < bpp; i++) {\n            pcounters[i] >>= 1;\n        }\n    }\n}", "target": 0}
{"code": "void generic_pipe_buf_get(struct pipe_inode_info *pipe, struct pipe_buffer *buf)\n{\n\tget_page(buf->page);\n}", "target": 1}
{"code": "int sc_path_set(sc_path_t *path, int type, const u8 *id, size_t id_len,\n\tint idx, int count)\n{\n\tif (path == NULL || id == NULL || id_len == 0 || id_len > SC_MAX_PATH_SIZE)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\tmemset(path, 0, sizeof(*path));\n\tmemcpy(path->value, id, id_len);\n\tpath->len   = id_len;\n\tpath->type  = type;\n\tpath->index = idx;\n\tpath->count = count;\n\treturn SC_SUCCESS;\n}", "target": 0}
{"code": "static int tc_fill_tclass(struct sk_buff *skb, struct Qdisc *q,\n\t\t\t  unsigned long cl,\n\t\t\t  u32 pid, u32 seq, u16 flags, int event)\n{\n\tstruct tcmsg *tcm;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct gnet_dump d;\n\tconst struct Qdisc_class_ops *cl_ops = q->ops->cl_ops;\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*tcm), flags);\n\ttcm = NLMSG_DATA(nlh);\n\ttcm->tcm_family = AF_UNSPEC;\n\ttcm->tcm_ifindex = qdisc_dev(q)->ifindex;\n\ttcm->tcm_parent = q->handle;\n\ttcm->tcm_handle = q->handle;\n\ttcm->tcm_info = 0;\n\tNLA_PUT_STRING(skb, TCA_KIND, q->ops->id);\n\tif (cl_ops->dump && cl_ops->dump(q, cl, skb, tcm) < 0)\n\t\tgoto nla_put_failure;\n\tif (gnet_stats_start_copy_compat(skb, TCA_STATS2, TCA_STATS, TCA_XSTATS,\n\t\t\t\t\t qdisc_root_sleeping_lock(q), &d) < 0)\n\t\tgoto nla_put_failure;\n\tif (cl_ops->dump_stats && cl_ops->dump_stats(q, cl, &d) < 0)\n\t\tgoto nla_put_failure;\n\tif (gnet_stats_finish_copy(&d) < 0)\n\t\tgoto nla_put_failure;\n\tnlh->nlmsg_len = skb_tail_pointer(skb) - b;\n\treturn skb->len;\nnlmsg_failure:\nnla_put_failure:\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}", "target": 1}
{"code": "static int skip_boxes(JXLParseContext *ctx, const uint8_t *buf, int buf_size)\n{\n    GetByteContext gb;\n    if (ctx->skip > buf_size)\n        return AVERROR_BUFFER_TOO_SMALL;\n    buf += ctx->skip;\n    buf_size -= ctx->skip;\n    bytestream2_init(&gb, buf, buf_size);\n    while (1) {\n        uint64_t size;\n        int head_size = 4;\n        if (bytestream2_peek_le16(&gb) == FF_JPEGXL_CODESTREAM_SIGNATURE_LE)\n            break;\n        if (bytestream2_peek_le64(&gb) == FF_JPEGXL_CONTAINER_SIGNATURE_LE)\n            break;\n        if (bytestream2_get_bytes_left(&gb) < 8)\n            return AVERROR_BUFFER_TOO_SMALL;\n        size = bytestream2_get_be32(&gb);\n        if (size == 1) {\n            if (bytestream2_get_bytes_left(&gb) < 12)\n                return AVERROR_BUFFER_TOO_SMALL;\n            size = bytestream2_get_be64(&gb);\n            head_size = 12;\n        }\n        if (!size)\n            return AVERROR_INVALIDDATA;\n        if (size <= head_size + 4)\n            return AVERROR_INVALIDDATA;\n        ctx->skip += size;\n        bytestream2_skip(&gb, size - head_size);\n        if (bytestream2_get_bytes_left(&gb) <= 0)\n            return AVERROR_BUFFER_TOO_SMALL;\n    }\n    return 0;\n}", "target": 1}
{"code": "void tcp_rcv_space_adjust(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint time;\n\tint space;\n\tif (tp->rcvq_space.time == 0)\n\t\tgoto new_measure;\n\ttime = tcp_time_stamp - tp->rcvq_space.time;\n\tif (time < (tp->rcv_rtt_est.rtt >> 3) || tp->rcv_rtt_est.rtt == 0)\n\t\treturn;\n\tspace = 2 * (tp->copied_seq - tp->rcvq_space.seq);\n\tspace = max(tp->rcvq_space.space, space);\n\tif (tp->rcvq_space.space != space) {\n\t\tint rcvmem;\n\t\ttp->rcvq_space.space = space;\n\t\tif (sysctl_tcp_moderate_rcvbuf &&\n\t\t    !(sk->sk_userlocks & SOCK_RCVBUF_LOCK)) {\n\t\t\tint new_clamp = space;\n\t\t\tspace /= tp->advmss;\n\t\t\tif (!space)\n\t\t\t\tspace = 1;\n\t\t\trcvmem = SKB_TRUESIZE(tp->advmss + MAX_TCP_HEADER);\n\t\t\twhile (tcp_win_from_space(rcvmem) < tp->advmss)\n\t\t\t\trcvmem += 128;\n\t\t\tspace *= rcvmem;\n\t\t\tspace = min(space, sysctl_tcp_rmem[2]);\n\t\t\tif (space > sk->sk_rcvbuf) {\n\t\t\t\tsk->sk_rcvbuf = space;\n\t\t\t\ttp->window_clamp = new_clamp;\n\t\t\t}\n\t\t}\n\t}\nnew_measure:\n\ttp->rcvq_space.seq = tp->copied_seq;\n\ttp->rcvq_space.time = tcp_time_stamp;\n}", "target": 0}
{"code": "static inline int get_b_cbp(MpegEncContext *s, int16_t block[6][64],\n                            int motion_x, int motion_y, int mb_type)\n{\n    int cbp = 0, i;\n    if (s->mpv_flags & FF_MPV_FLAG_CBP_RD) {\n        int score        = 0;\n        const int lambda = s->lambda2 >> (FF_LAMBDA_SHIFT - 6);\n        for (i = 0; i < 6; i++) {\n            if (s->coded_score[i] < 0) {\n                score += s->coded_score[i];\n                cbp   |= 1 << (5 - i);\n            }\n        }\n        if (cbp) {\n            int zero_score = -6;\n            if ((motion_x | motion_y | s->dquant | mb_type) == 0)\n                zero_score -= 4;  \n            zero_score *= lambda;\n            if (zero_score <= score)\n                cbp = 0;\n        }\n        for (i = 0; i < 6; i++) {\n            if (s->block_last_index[i] >= 0 && ((cbp >> (5 - i)) & 1) == 0) {\n                s->block_last_index[i] = -1;\n                s->bdsp.clear_block(s->block[i]);\n            }\n        }\n    } else {\n        for (i = 0; i < 6; i++) {\n            if (s->block_last_index[i] >= 0)\n                cbp |= 1 << (5 - i);\n        }\n    }\n    return cbp;\n}", "target": 0}
{"code": "    template<typename t, typename tc>\n    CImg<T>& draw_axis(const int x, const CImg<t>& values_y,\n                       const tc *const color, const float opacity=1,\n                       const unsigned int pattern=~0U, const unsigned int font_height=13,\n                       const bool allow_zero=true) {\n      if (is_empty()) return *this;\n      int siz = (int)values_y.size() - 1;\n      CImg<charT> txt(32);\n      CImg<T> label;\n      if (siz<=0) { \n        draw_line(x,0,x,_height - 1,color,opacity,pattern);\n        if (!siz) {\n          cimg_snprintf(txt,txt._width,\"%g\",(double)*values_y);\n          label.assign().draw_text(0,0,txt,color,(tc*)0,opacity,font_height);\n          const int\n            _yt = (height() - label.height())/2,\n            yt = _yt<0?0:_yt + label.height()>=height()?height() - 1-label.height():_yt,\n            _xt = x - 2 - label.width(),\n            xt = _xt>=0?_xt:x + 3;\n          draw_point(x - 1,height()/2,color,opacity).draw_point(x + 1,height()/2,color,opacity);\n          if (allow_zero || *txt!='0' || txt[1]!=0)\n            draw_text(xt,yt,txt,color,(tc*)0,opacity,font_height);\n        }\n      } else { \n        if (values_y[0]<values_y[siz]) draw_arrow(x,0,x,_height - 1,color,opacity,30,5,pattern);\n        else draw_arrow(x,_height - 1,x,0,color,opacity,30,5,pattern);\n        cimg_foroff(values_y,y) {\n          cimg_snprintf(txt,txt._width,\"%g\",(double)values_y(y));\n          label.assign().draw_text(0,0,txt,color,(tc*)0,opacity,font_height);\n          const int\n            yi = (int)(y*(_height - 1)/siz),\n            _yt = yi - label.height()/2,\n            yt = _yt<0?0:_yt + label.height()>=height()?height() - 1-label.height():_yt,\n            _xt = x - 2 - label.width(),\n            xt = _xt>=0?_xt:x + 3;\n          draw_point(x - 1,yi,color,opacity).draw_point(x + 1,yi,color,opacity);\n          if (allow_zero || *txt!='0' || txt[1]!=0)\n            draw_text(xt,yt,txt,color,(tc*)0,opacity,font_height);\n        }\n      }\n      return *this;", "target": 0}
{"code": "RSAES_PKCS1v1_5Encode(\n\t\t      TPM2B       *padded,        \n\t\t      TPM2B       *message,       \n\t\t      RAND_STATE  *rand\n\t\t      )\n{\n    UINT32      ps = padded->size - message->size - 3;\n    if(message->size > padded->size - 11)\n\treturn TPM_RC_VALUE;\n    memcpy(&padded->buffer[padded->size - message->size], message->buffer,\n\t   message->size);\n    padded->buffer[0] = 0;\n    padded->buffer[1] = 2;\n    DRBG_Generate(rand, &padded->buffer[2], (UINT16)ps);\n    padded->buffer[2 + ps] = 0;\n    for(ps++; ps > 1; ps--)\n\t{\n\t    if(padded->buffer[ps] == 0)\n\t\tpadded->buffer[ps] = 0x55;  \n\t}\n    return TPM_RC_SUCCESS;\n}", "target": 0}
{"code": "void *UntrustedCacheMalloc::GetBuffer() {\n  void **buffers = nullptr;\n  void *buffer;\n  bool is_pool_empty;\n  {\n    LockGuard spin_lock(&lock_);\n    is_pool_empty = buffer_pool_.empty();\n    if (is_pool_empty) {\n      buffers =\n          primitives::AllocateUntrustedBuffers(kPoolIncrement, kPoolEntrySize);\n      for (int i = 0; i < kPoolIncrement; i++) {\n        if (!buffers[i] ||\n            !TrustedPrimitives::IsOutsideEnclave(buffers[i], kPoolEntrySize)) {\n          abort();\n        }\n        buffer_pool_.push(buffers[i]);\n      }\n    }\n    buffer = buffer_pool_.top();\n    buffer_pool_.pop();\n    busy_buffers_.insert(buffer);\n  }\n  if (is_pool_empty) {\n    Free(buffers);\n  }\n  return buffer;\n}", "target": 1}
{"code": "static void mkiss_put(struct mkiss *ax)\n{\n\tif (refcount_dec_and_test(&ax->refcnt))\n\t\tcomplete(&ax->dead);\n}", "target": 0}
{"code": "static int allocDynamic(dynamicPtr *dp, int initialSize, void *data)\n{\n\tif(data == NULL) {\n\t\tdp->logicalSize = 0;\n\t\tdp->dataGood = FALSE;\n\t\tdp->data = gdMalloc(initialSize);\n\t} else {\n\t\tdp->logicalSize = initialSize;\n\t\tdp->dataGood = TRUE;\n\t\tdp->data = data;\n\t}\n\tif(dp->data != NULL) {\n\t\tdp->realSize = initialSize;\n\t\tdp->dataGood = TRUE;\n\t\tdp->pos = 0;\n\t\treturn TRUE;\n\t} else {\n\t\tdp->realSize = 0;\n\t\treturn FALSE;\n\t}\n}", "target": 0}
{"code": "static int __init init_ext2_fs(void)\n{\n\tint err = init_ext2_xattr();\n\tif (err)\n\t\treturn err;\n\terr = init_inodecache();\n\tif (err)\n\t\tgoto out1;\n        err = register_filesystem(&ext2_fs_type);\n\tif (err)\n\t\tgoto out;\n\treturn 0;\nout:\n\tdestroy_inodecache();\nout1:\n\texit_ext2_xattr();\n\treturn err;\n}", "target": 1}
{"code": "static ssize_t hid_debug_events_read(struct file *file, char __user *buffer,\n\t\tsize_t count, loff_t *ppos)\n{\n\tstruct hid_debug_list *list = file->private_data;\n\tint ret = 0, len;\n\tDECLARE_WAITQUEUE(wait, current);\n\tmutex_lock(&list->read_mutex);\n\twhile (ret == 0) {\n\t\tif (list->head == list->tail) {\n\t\t\tadd_wait_queue(&list->hdev->debug_wait, &wait);\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\twhile (list->head == list->tail) {\n\t\t\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\t\t\tret = -EAGAIN;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (signal_pending(current)) {\n\t\t\t\t\tret = -ERESTARTSYS;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!list->hdev || !list->hdev->debug) {\n\t\t\t\t\tret = -EIO;\n\t\t\t\t\tset_current_state(TASK_RUNNING);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tmutex_unlock(&list->read_mutex);\n\t\t\t\tschedule();\n\t\t\t\tmutex_lock(&list->read_mutex);\n\t\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\t}\n\t\t\tset_current_state(TASK_RUNNING);\n\t\t\tremove_wait_queue(&list->hdev->debug_wait, &wait);\n\t\t}\n\t\tif (ret)\n\t\t\tgoto out;\ncopy_rest:\n\t\tif (list->tail == list->head)\n\t\t\tgoto out;\n\t\tif (list->tail > list->head) {\n\t\t\tlen = list->tail - list->head;\n\t\t\tif (len > count)\n\t\t\t\tlen = count;\n\t\t\tif (copy_to_user(buffer + ret, &list->hid_debug_buf[list->head], len)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret += len;\n\t\t\tlist->head += len;\n\t\t} else {\n\t\t\tlen = HID_DEBUG_BUFSIZE - list->head;\n\t\t\tif (len > count)\n\t\t\t\tlen = count;\n\t\t\tif (copy_to_user(buffer, &list->hid_debug_buf[list->head], len)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tlist->head = 0;\n\t\t\tret += len;\n\t\t\tcount -= len;\n\t\t\tif (count > 0)\n\t\t\t\tgoto copy_rest;\n\t\t}\n\t}\nout:\n\tmutex_unlock(&list->read_mutex);\n\treturn ret;\n}", "target": 1}
{"code": "static int decode_attr_fsid(struct xdr_stream *xdr, uint32_t *bitmap, struct nfs_fsid *fsid)\n{\n\t__be32 *p;\n\tint ret = 0;\n\tfsid->major = 0;\n\tfsid->minor = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_FSID - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_FSID)) {\n\t\tp = xdr_inline_decode(xdr, 16);\n\t\tif (unlikely(!p))\n\t\t\tgoto out_overflow;\n\t\tp = xdr_decode_hyper(p, &fsid->major);\n\t\txdr_decode_hyper(p, &fsid->minor);\n\t\tbitmap[0] &= ~FATTR4_WORD0_FSID;\n\t\tret = NFS_ATTR_FATTR_FSID;\n\t}\n\tdprintk(\"%s: fsid=(0x%Lx/0x%Lx)\\n\", __func__,\n\t\t\t(unsigned long long)fsid->major,\n\t\t\t(unsigned long long)fsid->minor);\n\treturn ret;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}", "target": 0}
{"code": "static unsigned etag_match(const char *hdr[], const char *etag)\n{\n    unsigned i, match = 0;\n    tok_t tok;\n    char *token;\n    for (i = 0; !match && hdr[i]; i++) {\n        tok_init(&tok, hdr[i], \",\", TOK_TRIMLEFT|TOK_TRIMRIGHT);\n        while (!match && (token = tok_next(&tok))) {\n            if (!etagcmp(token, etag)) match = 1;\n        }\n        tok_fini(&tok);\n    }\n    return match;\n}", "target": 0}
{"code": "sysName_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  snmp_api_set_string(varbind, oid, \"Contiki-NG - \"CONTIKI_TARGET_STRING);\n}", "target": 1}
{"code": "static void cfg_free_opt_array(cfg_opt_t *opts)\n{\n\tint i;\n\tfor (i = 0; opts[i].name; ++i) {\n\t\tfree((void *)opts[i].name);\n\t\tif (opts[i].comment)\n\t\t\tfree(opts[i].comment);\n\t\tif (opts[i].def.parsed)\n\t\t\tfree(opts[i].def.parsed);\n\t\tif (opts[i].def.string)\n\t\t\tfree((void *)opts[i].def.string);\n\t\tif (opts[i].subopts)\n\t\t\tcfg_free_opt_array(opts[i].subopts);\n\t}\n\tfree(opts);\n}", "target": 0}
{"code": "mark_trusted_task_done (GObject      *source_object,\n                        GAsyncResult *res,\n                        gpointer      user_data)\n{\n    MarkTrustedJob *job = user_data;\n    g_object_unref (job->file);\n    if (job->done_callback)\n    {\n        job->done_callback (!job_aborted ((CommonJob *) job),\n                            job->done_callback_data);\n    }\n    finalize_common ((CommonJob *) job);\n}", "target": 1}
{"code": "Server::clientWriteDone(const CommIoCbParams &io)\n{\n    debugs(33,5, io.conn);\n    Must(writer != nullptr);\n    writer = nullptr;\n    if (io.flag == Comm::ERR_CLOSING || !Comm::IsConnOpen(clientConnection)) {\n        debugs(33,5, io.conn << \" closing Bailout.\");\n        return;\n    }\n    Must(io.conn->fd == clientConnection->fd);\n    if (io.flag && pipeline.front())\n        pipeline.front()->initiateClose(\"write failure\");\n    afterClientWrite(io.size); \n    writeSomeData(); \n}", "target": 1}
{"code": "merge_public_with_secret (KBNODE pubblock, KBNODE secblock)\n{\n  KBNODE pub;\n  assert (pubblock->pkt->pkttype == PKT_PUBLIC_KEY);\n  assert (secblock->pkt->pkttype == PKT_SECRET_KEY);\n  for (pub = pubblock; pub; pub = pub->next)\n    {\n      if (pub->pkt->pkttype == PKT_PUBLIC_KEY)\n\t{\n\t  PKT_public_key *pk = pub->pkt->pkt.public_key;\n\t  PKT_secret_key *sk = secblock->pkt->pkt.secret_key;\n\t  assert (pub == pubblock); \n\t  copy_public_parts_to_secret_key (pk, sk);\n\t  free_public_key (pk);\n\t  pub->pkt->pkttype = PKT_SECRET_KEY;\n\t  pub->pkt->pkt.secret_key = copy_secret_key (NULL, sk);\n\t}\n      else if (pub->pkt->pkttype == PKT_PUBLIC_SUBKEY)\n\t{\n\t  KBNODE sec;\n\t  PKT_public_key *pk = pub->pkt->pkt.public_key;\n\t  for (sec = secblock->next; sec; sec = sec->next)\n\t    {\n\t      if (sec->pkt->pkttype == PKT_SECRET_SUBKEY)\n\t\t{\n\t\t  PKT_secret_key *sk = sec->pkt->pkt.secret_key;\n\t\t  if (!cmp_public_secret_key (pk, sk))\n\t\t    {\n\t\t      copy_public_parts_to_secret_key (pk, sk);\n\t\t      free_public_key (pk);\n\t\t      pub->pkt->pkttype = PKT_SECRET_SUBKEY;\n\t\t      pub->pkt->pkt.secret_key = copy_secret_key (NULL, sk);\n\t\t      break;\n\t\t    }\n\t\t}\n\t    }\n\t  if (!sec)\n\t    BUG (); \n\t}\n    }\n}", "target": 0}
{"code": "void usb_serial_console_disconnect(struct usb_serial *serial)\n{\n\tif (serial->port[0] == usbcons_info.port) {\n\t\tusb_serial_console_exit();\n\t\tusb_serial_put(serial);\n\t}\n}", "target": 1}
{"code": "static int em_ret_far(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tunsigned long eip, cs;\n\tu16 old_cs;\n\tint cpl = ctxt->ops->cpl(ctxt);\n\tstruct desc_struct old_desc, new_desc;\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tops->get_segment(ctxt, &old_cs, &old_desc, NULL,\n\t\t\t\t VCPU_SREG_CS);\n\trc = emulate_pop(ctxt, &eip, ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = emulate_pop(ctxt, &cs, ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tif (ctxt->mode >= X86EMUL_MODE_PROT16 && (cs & 3) > cpl)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\trc = __load_segment_descriptor(ctxt, (u16)cs, VCPU_SREG_CS, cpl,\n\t\t\t\t       X86_TRANSFER_RET,\n\t\t\t\t       &new_desc);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = assign_eip_far(ctxt, eip, &new_desc);\n\tif (rc != X86EMUL_CONTINUE) {\n\t\tWARN_ON(ctxt->mode != X86EMUL_MODE_PROT64);\n\t\tops->set_segment(ctxt, old_cs, &old_desc, 0, VCPU_SREG_CS);\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "cdf_check_stream_offset(const cdf_stream_t *sst, const cdf_header_t *h,\n    const void *p, size_t tail, int line)\n{\n\tconst char *b = (const char *)sst->sst_tab;\n\tconst char *e = ((const char *)p) + tail;\n\tsize_t ss = sst->sst_dirlen < h->h_min_size_standard_stream ?\n\t    CDF_SHORT_SEC_SIZE(h) : CDF_SEC_SIZE(h);\n\t(void)&line;\n\tif (e >= b && (size_t)(e - b) <= ss * sst->sst_len)\n\t\treturn 0;\n\tDPRINTF((\"%d: offset begin %p < end %p || %\" SIZE_T_FORMAT \"u\"\n\t    \" > %\" SIZE_T_FORMAT \"u [%\" SIZE_T_FORMAT \"u %\"\n\t    SIZE_T_FORMAT \"u]\\n\", line, b, e, (size_t)(e - b),\n\t    ss * sst->sst_len, ss, sst->sst_len));\n\terrno = EFTYPE;\n\treturn -1;\n}", "target": 0}
{"code": "SSL_SESSION *SSL_SESSION_dup(const SSL_SESSION *src)\n{\n    return ssl_session_dup(src, 1);\n}", "target": 1}
{"code": "static ssize_t do_iter_readv_writev(struct file *filp, struct iov_iter *iter,\n\t\tloff_t *ppos, iter_fn_t fn)\n{\n\tstruct kiocb kiocb;\n\tssize_t ret;\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tret = fn(&kiocb, iter);\n\tBUG_ON(ret == -EIOCBQUEUED);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}", "target": 0}
{"code": "static uint8_t avrcp_handle_displayable_charset(struct avrcp *session,\n\t\t\t\t\t\tstruct avrcp_header *pdu,\n\t\t\t\t\t\tuint8_t transaction)\n{\n\tuint16_t len = ntohs(pdu->params_len);\n\tif (len < 3) {\n\t\tpdu->params_len = htons(1);\n\t\tpdu->params[0] = AVRCP_STATUS_INVALID_PARAM;\n\t\treturn AVC_CTYPE_REJECTED;\n\t}\n\tpdu->params_len = 0;\n\treturn AVC_CTYPE_STABLE;\n}", "target": 0}
{"code": "xmlValidGetElemDecl(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\n\t            xmlNodePtr elem, int *extsubset) {\n    xmlElementPtr elemDecl = NULL;\n    const xmlChar *prefix = NULL;\n    if ((ctxt == NULL) || (doc == NULL) ||\n        (elem == NULL) || (elem->name == NULL))\n        return(NULL);\n    if (extsubset != NULL)\n\t*extsubset = 0;\n    if ((elem->ns != NULL) && (elem->ns->prefix != NULL))\n\tprefix = elem->ns->prefix;\n    if (prefix != NULL) {\n\telemDecl = xmlGetDtdQElementDesc(doc->intSubset,\n\t\t                         elem->name, prefix);\n\tif ((elemDecl == NULL) && (doc->extSubset != NULL)) {\n\t    elemDecl = xmlGetDtdQElementDesc(doc->extSubset,\n\t\t                             elem->name, prefix);\n\t    if ((elemDecl != NULL) && (extsubset != NULL))\n\t\t*extsubset = 1;\n\t}\n    }\n    if (elemDecl == NULL) {\n\telemDecl = xmlGetDtdElementDesc(doc->intSubset, elem->name);\n\tif ((elemDecl == NULL) && (doc->extSubset != NULL)) {\n\t    elemDecl = xmlGetDtdElementDesc(doc->extSubset, elem->name);\n\t    if ((elemDecl != NULL) && (extsubset != NULL))\n\t\t*extsubset = 1;\n\t}\n    }\n    if (elemDecl == NULL) {\n\txmlErrValidNode(ctxt, elem,\n\t\t\tXML_DTD_UNKNOWN_ELEM,\n\t       \"No declaration for element %s\\n\",\n\t       elem->name, NULL, NULL);\n    }\n    return(elemDecl);\n}", "target": 0}
{"code": "Status FunctionCallFrame::ConsumeRetvals(std::vector<Tensor>* rets,\n                                         bool allow_dead_tensors) {\n  rets->clear();\n  rets->reserve(rets_.size());\n  for (size_t i = 0; i < rets_.size(); ++i) {\n    if (rets_[i].has_val) {\n      rets->emplace_back(std::move(rets_[i].val));\n    } else if (allow_dead_tensors) {\n      rets->emplace_back();\n    } else {\n      return errors::Internal(\"Retval[\", i, \"] does not have value\");\n    }\n  }\n  return Status::OK();\n}", "target": 0}
{"code": "static bool cma_protocol_roce(const struct rdma_cm_id *id)\n{\n\tstruct ib_device *device = id->device;\n\tconst u32 port_num = id->port_num ?: rdma_start_port(device);\n\treturn rdma_protocol_roce(device, port_num);\n}", "target": 0}
{"code": "_dbus_daemon_unpublish_session_bus_address (void)\n{\n}", "target": 0}
{"code": "void sw_crypto_acipher_free_rsa_public_key(struct rsa_public_key *s)\n{\n\tif (!s)\n\t\treturn;\n\tcrypto_bignum_free(s->n);\n\tcrypto_bignum_free(s->e);\n}", "target": 1}
{"code": "static uint16_t nvme_tx(NvmeCtrl *n, NvmeSg *sg, uint8_t *ptr, uint32_t len,\n                        NvmeTxDirection dir)\n{\n    assert(sg->flags & NVME_SG_ALLOC);\n    if (sg->flags & NVME_SG_DMA) {\n        const MemTxAttrs attrs = MEMTXATTRS_UNSPECIFIED;\n        dma_addr_t residual;\n        if (dir == NVME_TX_DIRECTION_TO_DEVICE) {\n            dma_buf_write(ptr, len, &residual, &sg->qsg, attrs);\n        } else {\n            dma_buf_read(ptr, len, &residual, &sg->qsg, attrs);\n        }\n        if (unlikely(residual)) {\n            trace_pci_nvme_err_invalid_dma();\n            return NVME_INVALID_FIELD | NVME_DNR;\n        }\n    } else {\n        size_t bytes;\n        if (dir == NVME_TX_DIRECTION_TO_DEVICE) {\n            bytes = qemu_iovec_to_buf(&sg->iov, 0, ptr, len);\n        } else {\n            bytes = qemu_iovec_from_buf(&sg->iov, 0, ptr, len);\n        }\n        if (unlikely(bytes != len)) {\n            trace_pci_nvme_err_invalid_dma();\n            return NVME_INVALID_FIELD | NVME_DNR;\n        }\n    }\n    return NVME_SUCCESS;\n}", "target": 0}
{"code": "static void containerKeysIntersectHelper(const req::ptr<c_Set>& st,\n                                         TypedValue* containers,\n                                         int count) {\n  assert(count >= 2);\n  auto mp = req::make<c_Map>();\n  Variant strHolder(empty_string_variant());\n  TypedValue* strTv = strHolder.asTypedValue();\n  TypedValue intOneTv = make_tv<KindOfInt64>(1);\n  bool isKey = isArrayType(containers[0].m_type);\n  for (ArrayIter iter(tvAsCVarRef(&containers[0])); iter; ++iter) {\n    auto key = iter.first();\n    const auto& c = *key.asCell();\n    addToIntersectMapHelper(mp, c, &intOneTv, strTv, !isKey);\n  }\n  for (int pos = 1; pos < count; ++pos) {\n    isKey = isArrayType(containers[pos].m_type);\n    for (ArrayIter iter(tvAsCVarRef(&containers[pos])); iter; ++iter) {\n      auto key = iter.first();\n      const auto& c = *key.asCell();\n      updateIntersectMapHelper(mp, c, pos, strTv, !isKey);\n    }\n  }\n  for (ArrayIter iter(mp.get()); iter; ++iter) {\n    const auto& val = *iter.secondRefPlus().asCell();\n    assert(val.m_type == KindOfInt64);\n    if (val.m_data.num == count) {\n      st->add(iter.first().asCell());\n    }\n  }\n}", "target": 0}
{"code": "void file_sb_list_del(struct file *file)\n{\n\tif (!list_empty(&file->f_u.fu_list)) {\n\t\tlg_local_lock_cpu(&files_lglock, file_list_cpu(file));\n\t\tlist_del_init(&file->f_u.fu_list);\n\t\tlg_local_unlock_cpu(&files_lglock, file_list_cpu(file));\n\t}\n}", "target": 1}
{"code": "int st21nfca_connectivity_event_received(struct nfc_hci_dev *hdev, u8 host,\n\t\t\t\tu8 event, struct sk_buff *skb)\n{\n\tint r = 0;\n\tstruct device *dev = &hdev->ndev->dev;\n\tstruct nfc_evt_transaction *transaction;\n\tpr_debug(\"connectivity gate event: %x\\n\", event);\n\tswitch (event) {\n\tcase ST21NFCA_EVT_CONNECTIVITY:\n\t\tr = nfc_se_connectivity(hdev->ndev, host);\n\tbreak;\n\tcase ST21NFCA_EVT_TRANSACTION:\n\t\tif (skb->len < NFC_MIN_AID_LENGTH + 2 &&\n\t\t    skb->data[0] != NFC_EVT_TRANSACTION_AID_TAG)\n\t\t\treturn -EPROTO;\n\t\ttransaction = devm_kzalloc(dev, skb->len - 2, GFP_KERNEL);\n\t\tif (!transaction)\n\t\t\treturn -ENOMEM;\n\t\ttransaction->aid_len = skb->data[1];\n\t\tif (transaction->aid_len > sizeof(transaction->aid))\n\t\t\treturn -EINVAL;\n\t\tmemcpy(transaction->aid, &skb->data[2],\n\t\t       transaction->aid_len);\n\t\tif (skb->data[transaction->aid_len + 2] !=\n\t\t    NFC_EVT_TRANSACTION_PARAMS_TAG)\n\t\t\treturn -EPROTO;\n\t\ttransaction->params_len = skb->data[transaction->aid_len + 3];\n\t\tif (transaction->params_len > ((skb->len - 2) - sizeof(struct nfc_evt_transaction)))\n\t\t\treturn -EINVAL;\n\t\tmemcpy(transaction->params, skb->data +\n\t\t       transaction->aid_len + 4, transaction->params_len);\n\t\tr = nfc_se_transaction(hdev->ndev, host, transaction);\n\tbreak;\n\tdefault:\n\t\tnfc_err(&hdev->ndev->dev, \"Unexpected event on connectivity gate\\n\");\n\t\treturn 1;\n\t}\n\tkfree_skb(skb);\n\treturn r;\n}", "target": 0}
{"code": "lexer_compare_identifier_to_current (parser_context_t *context_p,        \n                                     const lexer_lit_location_t *right)  \n{\n  lexer_lit_location_t *left = &context_p->token.lit_location;\n  const uint8_t *left_p;\n  const uint8_t *right_p;\n  size_t count;\n  JERRY_ASSERT (left->length > 0 && right->length > 0);\n  if (left->length != right->length)\n  {\n    return 0;\n  }\n  if (!left->has_escape && !right->has_escape)\n  {\n    return memcmp (left->char_p, right->char_p, left->length) == 0;\n  }\n  left_p = left->char_p;\n  right_p = right->char_p;\n  count = left->length;\n  do\n  {\n    uint8_t utf8_buf[3];\n    size_t utf8_len, offset;\n    if (*left_p != LIT_CHAR_BACKSLASH && *right_p != LIT_CHAR_BACKSLASH)\n    {\n      if (*left_p++ != *right_p++)\n      {\n        return false;\n      }\n      count--;\n      continue;\n    }\n    if (*left_p == LIT_CHAR_BACKSLASH && *right_p == LIT_CHAR_BACKSLASH)\n    {\n      uint16_t left_chr = lexer_hex_to_character (context_p, left_p, 6);\n      if (left_chr != lexer_hex_to_character (context_p, right_p, 6))\n      {\n        return false;\n      }\n      left_p += 6;\n      right_p += 6;\n      count += lit_char_get_utf8_length (left_chr);\n      continue;\n    }\n    if (*right_p == LIT_CHAR_BACKSLASH)\n    {\n      const uint8_t *swap_p = left_p;\n      left_p = right_p;\n      right_p = swap_p;\n    }\n    utf8_len = lit_char_to_utf8_bytes (utf8_buf, lexer_hex_to_character (context_p, left_p, 6));\n    JERRY_ASSERT (utf8_len > 0);\n    count -= utf8_len;\n    offset = 0;\n    do\n    {\n      if (utf8_buf[offset] != *right_p++)\n      {\n        return false;\n      }\n      offset++;\n    }\n    while (offset < utf8_len);\n    left_p += 6;\n  }\n  while (count > 0);\n  return true;\n} ", "target": 0}
{"code": "static int sg_proc_seq_show_debug(struct seq_file *s, void *v)\n{\n\tstruct sg_proc_deviter * it = (struct sg_proc_deviter *) v;\n\tSg_device *sdp;\n\tunsigned long iflags;\n\tif (it && (0 == it->index))\n\t\tseq_printf(s, \"max_active_device=%d  def_reserved_size=%d\\n\",\n\t\t\t   (int)it->max, sg_big_buff);\n\tread_lock_irqsave(&sg_index_lock, iflags);\n\tsdp = it ? sg_lookup_dev(it->index) : NULL;\n\tif (NULL == sdp)\n\t\tgoto skip;\n\tread_lock(&sdp->sfd_lock);\n\tif (!list_empty(&sdp->sfds)) {\n\t\tseq_printf(s, \" >>> device=%s \", sdp->disk->disk_name);\n\t\tif (atomic_read(&sdp->detaching))\n\t\t\tseq_puts(s, \"detaching pending close \");\n\t\telse if (sdp->device) {\n\t\t\tstruct scsi_device *scsidp = sdp->device;\n\t\t\tseq_printf(s, \"%d:%d:%d:%llu   em=%d\",\n\t\t\t\t   scsidp->host->host_no,\n\t\t\t\t   scsidp->channel, scsidp->id,\n\t\t\t\t   scsidp->lun,\n\t\t\t\t   scsidp->host->hostt->emulated);\n\t\t}\n\t\tseq_printf(s, \" sg_tablesize=%d excl=%d open_cnt=%d\\n\",\n\t\t\t   sdp->sg_tablesize, sdp->exclude, sdp->open_cnt);\n\t\tsg_proc_debug_helper(s, sdp);\n\t}\n\tread_unlock(&sdp->sfd_lock);\nskip:\n\tread_unlock_irqrestore(&sg_index_lock, iflags);\n\treturn 0;\n}", "target": 0}
{"code": "static uint64_t unpack_timestamp(const struct efi_time *timestamp)\n{\n\tuint64_t val = 0;\n\tuint16_t year = le32_to_cpu(timestamp->year);\n\tval |= ((uint64_t) timestamp->pad1 & 0xFF) << 0;\n\tval |= ((uint64_t) timestamp->second & 0xFF) << (1*8);\n\tval |= ((uint64_t) timestamp->minute & 0xFF) << (2*8);\n\tval |= ((uint64_t) timestamp->hour & 0xFF) << (3*8);\n\tval |= ((uint64_t) timestamp->day & 0xFF) << (4*8);\n\tval |= ((uint64_t) timestamp->month & 0xFF) << (5*8);\n\tval |= ((uint64_t) year) << (6*8);\n\treturn val;\n}", "target": 1}
{"code": "char *_q_makeword(char *str, char stop)\n{\n    char *word;\n    int  len, i;\n    for (len = 0; ((str[len] != stop) && (str[len])); len++);\n    word = (char *)malloc(sizeof(char) * (len + 1));\n    for (i = 0; i < len; i++) word[i] = str[i];\n    word[i] = '\\0';\n    if (str[len])len++;\n    for (i = len; str[i]; i++) str[i - len] = str[i];\n    str[i - len] = '\\0';\n    return word;\n}", "target": 0}
{"code": "static TPM_RESULT SWTPM_NVRAM_GetFilenameForName(char *filename,        \n                                                 size_t bufsize,\n                                                 uint32_t tpm_number,\n                                                 const char *name,      \n                                                 bool is_tempfile)      \n{\n    TPM_RESULT res = TPM_SUCCESS;\n    int n;\n    const char *suffix = \"\";\n    TPM_DEBUG(\" SWTPM_NVRAM_GetFilenameForName: For name %s\\n\", name);\n    switch (tpmversion) {\n    case TPMLIB_TPM_VERSION_1_2:\n        break;\n    case TPMLIB_TPM_VERSION_2:\n        suffix = \"2\";\n        break;\n    }\n    if (is_tempfile) {\n        n = snprintf(filename, bufsize, \"%s/TMP%s-%02lx.%s\",\n                     state_directory, suffix, (unsigned long)tpm_number, name);\n    } else {\n        n = snprintf(filename, bufsize, \"%s/tpm%s-%02lx.%s\",\n                     state_directory, suffix, (unsigned long)tpm_number, name);\n    }\n    if ((size_t)n > bufsize) {\n        res = TPM_FAIL;\n    }\n    TPM_DEBUG(\"  SWTPM_NVRAM_GetFilenameForName: File name %s\\n\", filename);\n    return res;\n}", "target": 0}
{"code": "pango_glyph_string_set_size (PangoGlyphString *string, gint new_len)\n{\n  g_return_if_fail (new_len >= 0);\n  while (new_len > string->space)\n    {\n      if (string->space == 0)\n\tstring->space = 1;\n      else\n\tstring->space *= 2;\n      if (string->space < 0)\n\t{\n\t  g_warning (\"glyph string length overflows maximum integer size, truncated\");\n\t  new_len = string->space = G_MAXINT - 8;\n\t}\n    }\n  string->glyphs = g_realloc (string->glyphs, string->space * sizeof (PangoGlyphInfo));\n  string->log_clusters = g_realloc (string->log_clusters, string->space * sizeof (gint));\n  string->num_glyphs = new_len;\n}", "target": 1}
{"code": "  explicit BoostedTreesMakeStatsSummaryOp(OpKernelConstruction* const context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"max_splits\", &max_splits_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_buckets\", &num_buckets_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_features\", &num_features_));\n  }", "target": 0}
{"code": "usage(void)\n{\n\tfprintf(stderr,\n\t    \"usage: ssh-agent [-c | -s] [-Dd] [-a bind_address] [-E fingerprint_hash]\\n\"\n\t    \"                 [-t life] [command [arg ...]]\\n\"\n\t    \"       ssh-agent [-c | -s] -k\\n\");\n\texit(1);\n}", "target": 1}
{"code": "cmd_getinfo (assuan_context_t ctx, char *line)\n{\n  int rc = 0;\n  if (!strcmp (line, \"version\"))\n    {\n      const char *s = VERSION;\n      rc = assuan_send_data (ctx, s, strlen (s));\n    }\n  else if (!strcmp (line, \"pid\"))\n    {\n      char numbuf[50];\n      snprintf (numbuf, sizeof numbuf, \"%lu\", (unsigned long)getpid ());\n      rc = assuan_send_data (ctx, numbuf, strlen (numbuf));\n    }\n  else if (!strcmp (line, \"socket_name\"))\n    {\n      const char *s = scd_get_socket_name ();\n      if (s)\n        rc = assuan_send_data (ctx, s, strlen (s));\n      else\n        rc = gpg_error (GPG_ERR_NO_DATA);\n    }\n  else if (!strcmp (line, \"status\"))\n    {\n      ctrl_t ctrl = assuan_get_pointer (ctx);\n      int vrdr = ctrl->server_local->vreader_idx;\n      char flag = 'r';\n      if (!ctrl->server_local->card_removed && vrdr != -1)\n\t{\n\t  struct vreader_s *vr;\n\t  if (!(vrdr >= 0 && vrdr < DIM(vreader_table)))\n\t    BUG ();\n\t  vr = &vreader_table[vrdr];\n\t  if (vr->valid && vr->any && (vr->status & 1))\n\t    flag = 'u';\n\t}\n      rc = assuan_send_data (ctx, &flag, 1);\n    }\n  else if (!strcmp (line, \"reader_list\"))\n    {\n#ifdef HAVE_LIBUSB\n      char *s = ccid_get_reader_list ();\n#else\n      char *s = NULL;\n#endif\n      if (s)\n        rc = assuan_send_data (ctx, s, strlen (s));\n      else\n        rc = gpg_error (GPG_ERR_NO_DATA);\n      xfree (s);\n    }\n  else if (!strcmp (line, \"deny_admin\"))\n    rc = opt.allow_admin? gpg_error (GPG_ERR_GENERAL) : 0;\n  else if (!strcmp (line, \"app_list\"))\n    {\n      char *s = get_supported_applications ();\n      if (s)\n        rc = assuan_send_data (ctx, s, strlen (s));\n      else\n        rc = 0;\n      xfree (s);\n    }\n  else\n    rc = set_error (GPG_ERR_ASS_PARAMETER, \"unknown value for WHAT\");\n  return rc;\n}", "target": 0}
{"code": "sudo_auth_end_session(void)\n{\n    sudo_auth *auth;\n    int status;\n    debug_decl(sudo_auth_end_session, SUDOERS_DEBUG_AUTH);\n    for (auth = auth_switch; auth->name; auth++) {\n\tif (auth->end_session && !IS_DISABLED(auth)) {\n\t    status = (auth->end_session)(auth);\n\t    if (status == AUTH_ERROR) {\n\t\tdebug_return_int(-1);\n\t    }\n\t}\n    }\n    debug_return_int(1);\n}", "target": 1}
{"code": "videobuf_vm_close(struct vm_area_struct *vma)\n{\n\tstruct videobuf_mapping *map = vma->vm_private_data;\n\tstruct videobuf_queue *q = map->q;\n\tint i;\n\tdprintk(2,\"vm_close %p [count=%d,vma=%08lx-%08lx]\\n\",map,\n\t\tmap->count,vma->vm_start,vma->vm_end);\n\tmap->count--;\n\tif (0 == map->count) {\n\t\tdprintk(1,\"munmap %p q=%p\\n\",map,q);\n\t\tmutex_lock(&q->lock);\n\t\tfor (i = 0; i < VIDEO_MAX_FRAME; i++) {\n\t\t\tif (NULL == q->bufs[i])\n\t\t\t\tcontinue;\n\t\t\tif (q->bufs[i]->map != map)\n\t\t\t\tcontinue;\n\t\t\tq->ops->buf_release(q,q->bufs[i]);\n\t\t\tq->bufs[i]->map   = NULL;\n\t\t\tq->bufs[i]->baddr = 0;\n\t\t}\n\t\tmutex_unlock(&q->lock);\n\t\tkfree(map);\n\t}\n\treturn;\n}", "target": 1}
{"code": "void fill_luma_motion_vector_predictors(base_context* ctx,\n                                        const slice_segment_header* shdr,\n                                        de265_image* img,\n                                        int xC,int yC,int nCS,int xP,int yP,\n                                        int nPbW,int nPbH, int l,\n                                        int refIdx, int partIdx,\n                                        MotionVector out_mvpList[2])\n{\n  uint8_t availableFlagLXN[2];\n  MotionVector mvLXN[2];\n  derive_spatial_luma_vector_prediction(ctx, img, shdr, xC,yC, nCS, xP,yP,\n                                        nPbW,nPbH, l, refIdx, partIdx,\n                                        availableFlagLXN, mvLXN);\n  uint8_t availableFlagLXCol;\n  MotionVector mvLXCol;\n  if (availableFlagLXN[0] &&\n      availableFlagLXN[1] &&\n      (mvLXN[0].x != mvLXN[1].x || mvLXN[0].y != mvLXN[1].y)) {\n    availableFlagLXCol = 0;\n  }\n  else {\n    derive_temporal_luma_vector_prediction(ctx, img, shdr,\n                                           xP,yP, nPbW,nPbH, refIdx,l,\n                                           &mvLXCol, &availableFlagLXCol);\n  }\n  int numMVPCandLX=0;\n  if (availableFlagLXN[0])\n    {\n      out_mvpList[numMVPCandLX++] = mvLXN[0];\n    }\n  if (availableFlagLXN[1] &&\n      (!availableFlagLXN[0] || \n       (mvLXN[0].x != mvLXN[1].x || mvLXN[0].y != mvLXN[1].y)))\n    {\n      out_mvpList[numMVPCandLX++] = mvLXN[1];\n    }\n  if (availableFlagLXCol)\n    {\n      out_mvpList[numMVPCandLX++] = mvLXCol;\n    }\n  while (numMVPCandLX<2) {\n    out_mvpList[numMVPCandLX].x = 0;\n    out_mvpList[numMVPCandLX].y = 0;\n    numMVPCandLX++;\n  }\n  assert(numMVPCandLX==2);\n}", "target": 0}
{"code": "find_entry_only(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n\tback_txn *txn\n)\n{\n\treturn( find_entry_internal( pb, be, addr, 0, txn, FE_REALLY_INTERNAL ) );\n}", "target": 1}
{"code": "void ntlm_populate_message_header(NTLM_MESSAGE_HEADER* header, UINT32 MessageType)\n{\n\tCopyMemory(header->Signature, NTLM_SIGNATURE, sizeof(NTLM_SIGNATURE));\n\theader->MessageType = MessageType;\n}", "target": 1}
{"code": "int sc_file_set_sec_attr(sc_file_t *file, const u8 *sec_attr,\n\t\t\t size_t sec_attr_len)\n{\n\tu8 *tmp;\n\tif (!sc_file_valid(file)) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\tif (sec_attr == NULL || sec_attr_len) {\n\t\tif (file->sec_attr != NULL)\n\t\t\tfree(file->sec_attr);\n\t\tfile->sec_attr = NULL;\n\t\tfile->sec_attr_len = 0;\n\t\treturn 0;\n\t }\n\ttmp = (u8 *) realloc(file->sec_attr, sec_attr_len);\n\tif (!tmp) {\n\t\tif (file->sec_attr)\n\t\t\tfree(file->sec_attr);\n\t\tfile->sec_attr     = NULL;\n\t\tfile->sec_attr_len = 0;\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t}\n\tfile->sec_attr = tmp;\n\tmemcpy(file->sec_attr, sec_attr, sec_attr_len);\n\tfile->sec_attr_len = sec_attr_len;\n\treturn 0;\n}", "target": 0}
{"code": "void gf_isom_delete(GF_ISOFile *movie)\n{\n\tgf_isom_delete_movie(movie);\n}", "target": 0}
{"code": "static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)\n{\n\tstruct mmu_gather tlb;\n\tstruct vm_area_struct *vma;\n\tbool ret = true;\n\tmutex_lock(&oom_lock);\n\tif (!down_read_trylock(&mm->mmap_sem)) {\n\t\tret = false;\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\tgoto unlock_oom;\n\t}\n\tif (mm_has_notifiers(mm)) {\n\t\tup_read(&mm->mmap_sem);\n\t\tschedule_timeout_idle(HZ);\n\t\tgoto unlock_oom;\n\t}\n\tif (test_bit(MMF_OOM_SKIP, &mm->flags)) {\n\t\tup_read(&mm->mmap_sem);\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\tgoto unlock_oom;\n\t}\n\ttrace_start_task_reaping(tsk->pid);\n\tset_bit(MMF_UNSTABLE, &mm->flags);\n\ttlb_gather_mmu(&tlb, mm, 0, -1);\n\tfor (vma = mm->mmap ; vma; vma = vma->vm_next) {\n\t\tif (!can_madv_dontneed_vma(vma))\n\t\t\tcontinue;\n\t\tif (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED))\n\t\t\tunmap_page_range(&tlb, vma, vma->vm_start, vma->vm_end,\n\t\t\t\t\t NULL);\n\t}\n\ttlb_finish_mmu(&tlb, 0, -1);\n\tpr_info(\"oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\",\n\t\t\ttask_pid_nr(tsk), tsk->comm,\n\t\t\tK(get_mm_counter(mm, MM_ANONPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_FILEPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_SHMEMPAGES)));\n\tup_read(&mm->mmap_sem);\n\ttrace_finish_task_reaping(tsk->pid);\nunlock_oom:\n\tmutex_unlock(&oom_lock);\n\treturn ret;\n}", "target": 1}
{"code": "concat_opt_exact_str(OptStr* to, UChar* s, UChar* end, OnigEncoding enc)\n{\n  int i, j, len;\n  UChar *p;\n  for (i = to->len, p = s; p < end && i < OPT_EXACT_MAXLEN; ) {\n    len = enclen(enc, p);\n    if (i + len > OPT_EXACT_MAXLEN) break;\n    for (j = 0; j < len && p < end; j++)\n      to->s[i++] = *p++;\n  }\n  to->len = i;\n  if (p >= end)\n    to->reach_end = 1;\n}", "target": 1}
{"code": "static void show_object(struct object *object, struct strbuf *path,\n\t\t\tconst char *last, void *data)\n{\n\tstruct bitmap *base = data;\n\tint bitmap_pos;\n\tbitmap_pos = bitmap_position(object->oid.hash);\n\tif (bitmap_pos < 0) {\n\t\tchar *name = path_name(path, last);\n\t\tbitmap_pos = ext_index_add_object(object, name);\n\t\tfree(name);\n\t}\n\tbitmap_set(base, bitmap_pos);\n}", "target": 1}
{"code": "static struct kvm_vcpu_hv_synic *synic_get(struct kvm *kvm, u32 vpidx)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vcpu_hv_synic *synic;\n\tvcpu = get_vcpu_by_vpidx(kvm, vpidx);\n\tif (!vcpu)\n\t\treturn NULL;\n\tsynic = to_hv_synic(vcpu);\n\treturn (synic->active) ? synic : NULL;\n}", "target": 1}
{"code": "Http::FilterMetadataStatus Context::onResponseMetadata() {\n  if (!wasm_->onResponseMetadata_) {\n    return Http::FilterMetadataStatus::Continue;\n  }\n  if (wasm_->onResponseMetadata_(this, id_).u64_ == 0) {\n    return Http::FilterMetadataStatus::Continue;\n  }\n  return Http::FilterMetadataStatus::Continue; \n}", "target": 1}
{"code": "static void array_cleanup( char* arr[] , int arr_size)\n{\n\tint i=0;\n\tfor( i=0; i< arr_size; i++ ){\n\t\tif( arr[i*2] ){\n\t\t\tefree( arr[i*2]);\n\t\t}\n\t}\n\tefree(arr);\n}", "target": 0}
{"code": "mm_request_send(int socket, enum monitor_reqtype type, Buffer *m)\n{\n\tu_int mlen = buffer_len(m);\n\tu_char buf[5];\n\tdebug3(\"%s entering: type %d\", __func__, type);\n\tPUT_32BIT(buf, mlen + 1);\n\tbuf[4] = (u_char) type;\t\t\n\tif (atomicio(write, socket, buf, sizeof(buf)) != sizeof(buf))\n\t\tfatal(\"%s: write\", __func__);\n\tif (atomicio(write, socket, buffer_ptr(m), mlen) != mlen)\n\t\tfatal(\"%s: write\", __func__);\n}", "target": 0}
{"code": "getSystemTempDir() {\n\tconst char *temp_dir = getenv(\"PASSENGER_TEMP_DIR\");\n\tif (temp_dir == NULL || *temp_dir == '\\0') {\n\t\ttemp_dir = getenv(\"PASSENGER_TMPDIR\");\n\t\tif (temp_dir == NULL || *temp_dir == '\\0') {\n\t\t\ttemp_dir = \"/tmp\";\n\t\t}\n\t}\n\treturn temp_dir;\n}", "target": 0}
{"code": "    const std::unordered_map<std::string, Cookie> &getCookies() const\n    {\n        return cookies();\n    }", "target": 1}
{"code": "static void oidc_authz_get_claims_and_idtoken(request_rec *r, json_t **claims,\n\t\tjson_t **id_token) {\n\tconst char *s_claims = oidc_request_state_get(r,\n\t\t\tOIDC_REQUEST_STATE_KEY_CLAIMS);\n\tif (s_claims != NULL)\n\t\toidc_util_decode_json_object(r, s_claims, claims);\n\tconst char *s_id_token = oidc_request_state_get(r,\n\t\t\tOIDC_REQUEST_STATE_KEY_IDTOKEN);\n\tif (s_id_token != NULL)\n\t\toidc_util_decode_json_object(r, s_id_token, id_token);\n}", "target": 0}
{"code": "static int activate(AVFilterContext *ctx)\n{\n    AVFilterLink *inlink = ctx->inputs[0];\n    AVFilterLink *outlink = ctx->outputs[0];\n    AudioFWTDNContext *s = ctx->priv;\n    AVFrame *in = NULL;\n    int ret, status;\n    int64_t pts;\n    FF_FILTER_FORWARD_STATUS_BACK(outlink, inlink);\n    ret = ff_inlink_consume_samples(inlink, s->nb_samples, s->nb_samples, &in);\n    if (ret < 0)\n        return ret;\n    if (ret > 0)\n        return filter_frame(inlink, in);\n    if (ff_inlink_acknowledge_status(inlink, &status, &pts)) {\n        if (status == AVERROR_EOF) {\n            while (s->padd_samples != 0) {\n                ret = filter_frame(inlink, NULL);\n                if (ret < 0)\n                    return ret;\n            }\n            ff_outlink_set_status(outlink, status, pts);\n            return ret;\n        }\n    }\n    FF_FILTER_FORWARD_WANTED(outlink, inlink);\n    return FFERROR_NOT_READY;\n}", "target": 1}
{"code": "static void test_bug17309863()\n{\n  MYSQL *lmysql;\n  unsigned long thread_id;\n  char query[MAX_TEST_QUERY_LENGTH];\n  int rc;\n  myheader(\"test_bug17309863\");\n  if (!opt_silent)\n    fprintf(stdout, \"\\n Establishing a test connection ...\");\n  if (!(lmysql= mysql_client_init(NULL)))\n  {\n    myerror(\"mysql_client_init() failed\");\n    exit(1);\n  }\n  lmysql->reconnect= 1;\n  if (!(mysql_real_connect(lmysql, opt_host, opt_user,\n                           opt_password, current_db, opt_port,\n                           opt_unix_socket, 0)))\n  {\n    myerror(\"connection failed\");\n    exit(1);\n  }\n  if (!opt_silent)\n    fprintf(stdout, \"OK\");\n  thread_id= mysql_thread_id(lmysql);\n  sprintf(query, \"KILL %lu\", thread_id);\n  if (thread_query(query))\n    exit(1);\n  rc= mysql_query(lmysql, \"SELECT 'bug17309863'\");\n  myquery(rc);\n  mysql_close(lmysql);\n}", "target": 0}
{"code": "setContext(XML_Parser parser, const XML_Char *context) {\n  DTD *const dtd = parser->m_dtd; \n  const XML_Char *s = context;\n  while (*context != XML_T('\\0')) {\n    if (*s == CONTEXT_SEP || *s == XML_T('\\0')) {\n      ENTITY *e;\n      if (! poolAppendChar(&parser->m_tempPool, XML_T('\\0')))\n        return XML_FALSE;\n      e = (ENTITY *)lookup(parser, &dtd->generalEntities,\n                           poolStart(&parser->m_tempPool), 0);\n      if (e)\n        e->open = XML_TRUE;\n      if (*s != XML_T('\\0'))\n        s++;\n      context = s;\n      poolDiscard(&parser->m_tempPool);\n    } else if (*s == XML_T(ASCII_EQUALS)) {\n      PREFIX *prefix;\n      if (poolLength(&parser->m_tempPool) == 0)\n        prefix = &dtd->defaultPrefix;\n      else {\n        if (! poolAppendChar(&parser->m_tempPool, XML_T('\\0')))\n          return XML_FALSE;\n        prefix\n            = (PREFIX *)lookup(parser, &dtd->prefixes,\n                               poolStart(&parser->m_tempPool), sizeof(PREFIX));\n        if (! prefix)\n          return XML_FALSE;\n        if (prefix->name == poolStart(&parser->m_tempPool)) {\n          prefix->name = poolCopyString(&dtd->pool, prefix->name);\n          if (! prefix->name)\n            return XML_FALSE;\n        }\n        poolDiscard(&parser->m_tempPool);\n      }\n      for (context = s + 1; *context != CONTEXT_SEP && *context != XML_T('\\0');\n           context++)\n        if (! poolAppendChar(&parser->m_tempPool, *context))\n          return XML_FALSE;\n      if (! poolAppendChar(&parser->m_tempPool, XML_T('\\0')))\n        return XML_FALSE;\n      if (addBinding(parser, prefix, NULL, poolStart(&parser->m_tempPool),\n                     &parser->m_inheritedBindings)\n          != XML_ERROR_NONE)\n        return XML_FALSE;\n      poolDiscard(&parser->m_tempPool);\n      if (*context != XML_T('\\0'))\n        ++context;\n      s = context;\n    } else {\n      if (! poolAppendChar(&parser->m_tempPool, *s))\n        return XML_FALSE;\n      s++;\n    }\n  }\n  return XML_TRUE;\n}", "target": 0}
{"code": "static inline void *packet_current_rx_frame(struct packet_sock *po,\n\t\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t\t    int status, unsigned int len)\n{\n\tchar *curr = NULL;\n\tswitch (po->tp_version) {\n\tcase TPACKET_V1:\n\tcase TPACKET_V2:\n\t\tcurr = packet_lookup_frame(po, &po->rx_ring,\n\t\t\t\t\tpo->rx_ring.head, status);\n\t\treturn curr;\n\tcase TPACKET_V3:\n\t\treturn __packet_lookup_frame_in_block(po, skb, status, len);\n\tdefault:\n\t\tWARN(1, \"TPACKET version not supported\\n\");\n\t\tBUG();\n\t\treturn 0;\n\t}\n}", "target": 0}
{"code": "ReadReason(rfbClient* client)\n{\n    uint32_t reasonLen;\n    char *reason;\n    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;\n    reasonLen = rfbClientSwap32IfLE(reasonLen);\n    reason = malloc((uint64_t)reasonLen+1);\n    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }\n    reason[reasonLen]=0;\n    rfbClientLog(\"VNC connection failed: %s\\n\",reason);\n    free(reason);\n}", "target": 1}
{"code": "getHostName() {\n\tlong hostNameMax = HOST_NAME_MAX;\n\tif (hostNameMax < 255) {\n\t\thostNameMax = 255;\n\t}\n\tstring buf(hostNameMax + 1, '\\0');\n\tif (gethostname(&buf[0], hostNameMax + 1) == 0) {\n\t\tbuf[hostNameMax] = '\\0';\n\t\treturn string(buf.c_str());\n\t} else {\n\t\tint e = errno;\n\t\tthrow SystemException(\"Unable to query the system's host name\", e);\n\t}\n}", "target": 0}
{"code": "static int __br_mdb_del(struct net_bridge *br, struct br_mdb_entry *entry)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tstruct br_ip ip;\n\tint err = -EINVAL;\n\tif (!netif_running(br->dev) || br->multicast_disabled)\n\t\treturn -EINVAL;\n\tif (timer_pending(&br->multicast_querier_timer))\n\t\treturn -EBUSY;\n\tip.proto = entry->addr.proto;\n\tif (ip.proto == htons(ETH_P_IP))\n\t\tip.u.ip4 = entry->addr.u.ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\telse\n\t\tip.u.ip6 = entry->addr.u.ip6;\n#endif\n\tspin_lock_bh(&br->multicast_lock);\n\tmdb = mlock_dereference(br->mdb, br);\n\tmp = br_mdb_ip_get(mdb, &ip);\n\tif (!mp)\n\t\tgoto unlock;\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (!p->port || p->port->dev->ifindex != entry->ifindex)\n\t\t\tcontinue;\n\t\tif (p->port->state == BR_STATE_DISABLED)\n\t\t\tgoto unlock;\n\t\trcu_assign_pointer(*pp, p->next);\n\t\thlist_del_init(&p->mglist);\n\t\tdel_timer(&p->timer);\n\t\tcall_rcu_bh(&p->rcu, br_multicast_free_pg);\n\t\terr = 0;\n\t\tif (!mp->ports && !mp->mglist &&\n\t\t    netif_running(br->dev))\n\t\t\tmod_timer(&mp->timer, jiffies);\n\t\tbreak;\n\t}\nunlock:\n\tspin_unlock_bh(&br->multicast_lock);\n\treturn err;\n}", "target": 1}
{"code": "njs_string_decode_base64_core(njs_vm_t *vm, njs_value_t *value,\n    const njs_str_t *src, njs_bool_t url)\n{\n    size_t     length;\n    const u_char *basis;\n    njs_str_t  dst;\n    basis = (url) ? njs_basis64url : njs_basis64;\n    length = njs_decode_base64_length_core(src, basis, &dst.length);\n    if (njs_slow_path(dst.length == 0)) {\n        vm->retval = njs_string_empty;\n        return NJS_OK;\n    }\n    dst.start = njs_string_alloc(vm, value, dst.length, length);\n    if (njs_slow_path(dst.start == NULL)) {\n        return NJS_ERROR;\n    }\n    njs_decode_base64_core(&dst, src, basis);\n    return NJS_OK;\n}", "target": 0}
{"code": "scrypt_SHA256_Final(unsigned char digest[32], struct SHA256_CTX * ctx)\n{\n  SHA256_Pad(ctx);\n  be32enc_vect(digest, ctx->state, 32);\n  memset((void *)ctx, 0, sizeof(*ctx));\n}", "target": 1}
{"code": "coolkey_v1_get_attribute_record_len(const u8 *attr, size_t buf_len)\n{\n\tsize_t attribute_len = sizeof(coolkey_attribute_header_t);\n\tsize_t len = 0;\n\tint r;\n\tr = coolkey_v1_get_attribute_len(attr, buf_len, &len, 1);\n\tif (r < 0) {\n\t\treturn buf_len; \n\t}\n\treturn MIN(buf_len,attribute_len+len);\n}", "target": 0}
{"code": "struct vfsmount *collect_mounts(struct path *path)\n{\n\tstruct mount *tree;\n\tnamespace_lock();\n\ttree = copy_tree(real_mount(path->mnt), path->dentry,\n\t\t\t CL_COPY_ALL | CL_PRIVATE);\n\tnamespace_unlock();\n\tif (IS_ERR(tree))\n\t\treturn ERR_CAST(tree);\n\treturn &tree->mnt;\n}", "target": 1}
{"code": "static struct sk_buff *noop_dequeue(struct Qdisc * qdisc)\n{\n\treturn NULL;\n}", "target": 0}
{"code": "deltas_head_cleanup(struct deltas_head *list)\n{\n\tsize_t i;\n\tfor (i = 0; i < list->capacity; i++)\n\t\tdelta_head_destroy(list->array[i]);\n\tif (list->array)\n\t\tfree(list->array);\n}", "target": 1}
{"code": "static void msf2_dma_tx(MSF2EmacState *s)\n{\n    NetClientState *nc = qemu_get_queue(s->nic);\n    hwaddr desc = s->regs[R_DMA_TX_DESC];\n    uint8_t buf[MAX_PKT_SIZE];\n    EmacDesc d;\n    int size;\n    uint8_t pktcnt;\n    uint32_t status;\n    if (!(s->regs[R_CFG1] & R_CFG1_TX_EN_MASK)) {\n        return;\n    }\n    while (1) {\n        emac_load_desc(s, &d, desc);\n        if (d.pktsize & EMPTY_MASK) {\n            break;\n        }\n        size = d.pktsize & PKT_SIZE;\n        address_space_read(&s->dma_as, d.pktaddr, MEMTXATTRS_UNSPECIFIED,\n                           buf, size);\n        if (s->regs[R_CFG1] & R_CFG1_LB_EN_MASK) {\n            nc->info->receive(nc, buf, size);\n        } else {\n            qemu_send_packet(nc, buf, size);\n        }\n        d.pktsize |= EMPTY_MASK;\n        emac_store_desc(s, &d, desc);\n        status = s->regs[R_DMA_TX_STATUS];\n        pktcnt = FIELD_EX32(status, DMA_TX_STATUS, PKTCNT);\n        pktcnt++;\n        s->regs[R_DMA_TX_STATUS] = FIELD_DP32(status, DMA_TX_STATUS,\n                                              PKTCNT, pktcnt);\n        s->regs[R_DMA_TX_STATUS] |= R_DMA_TX_STATUS_PKT_SENT_MASK;\n        desc = d.next;\n    }\n    s->regs[R_DMA_TX_STATUS] |= R_DMA_TX_STATUS_UNDERRUN_MASK;\n    s->regs[R_DMA_TX_CTL] &= ~R_DMA_TX_CTL_EN_MASK;\n}", "target": 1}
{"code": "kadm5_ret_t kadm5_decrypt_key(void *server_handle,\n                              kadm5_principal_ent_t entry, krb5_int32\n                              ktype, krb5_int32 stype, krb5_int32\n                              kvno, krb5_keyblock *keyblock,\n                              krb5_keysalt *keysalt, int *kvnop)\n{\n    kadm5_server_handle_t handle = server_handle;\n    krb5_db_entry dbent;\n    krb5_key_data *key_data;\n    krb5_keyblock *mkey_ptr;\n    int ret;\n    CHECK_HANDLE(server_handle);\n    if (entry->n_key_data == 0 || entry->key_data == NULL)\n        return EINVAL;\n    dbent.n_key_data = entry->n_key_data;\n    dbent.key_data = entry->key_data;\n    if ((ret = krb5_dbe_find_enctype(handle->context, &dbent, ktype,\n                                     stype, kvno, &key_data)))\n        return ret;\n    dbent.tl_data = entry->tl_data;\n    if ((ret = krb5_dbe_find_mkey(handle->context, &dbent, &mkey_ptr))) {\n        if (krb5_db_fetch_mkey_list(handle->context, master_princ,\n                                    &master_keyblock) == 0) {\n            if ((ret = krb5_dbe_find_mkey(handle->context, &dbent,\n                                          &mkey_ptr))) {\n                return ret;\n            }\n        } else {\n            return ret;\n        }\n    }\n    if ((ret = krb5_dbe_decrypt_key_data(handle->context, NULL, key_data,\n                                         keyblock, keysalt)))\n        return ret;\n    if (ktype != -1)\n        keyblock->enctype = ktype;\n    if (kvnop)\n        *kvnop = key_data->key_data_kvno;\n    return KADM5_OK;\n}", "target": 0}
{"code": "static void *proc_pid_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error = -EACCES;\n\tpath_put(&nd->path);\n\tif (!proc_fd_access_allowed(inode))\n\t\tgoto out;\n\terror = PROC_I(inode)->op.proc_get_link(dentry, &nd->path);\nout:\n\treturn ERR_PTR(error);\n}", "target": 0}
{"code": "static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next,\n\t\t\t     struct task_struct *tsk)\n{\n\tunsigned cpu = smp_processor_id();\n\tif (likely(prev != next)) {\n#ifdef CONFIG_SMP\n\t\tthis_cpu_write(cpu_tlbstate.state, TLBSTATE_OK);\n\t\tthis_cpu_write(cpu_tlbstate.active_mm, next);\n#endif\n\t\tcpumask_set_cpu(cpu, mm_cpumask(next));\n\t\tload_cr3(next->pgd);\n\t\ttrace_tlb_flush(TLB_FLUSH_ON_TASK_SWITCH, TLB_FLUSH_ALL);\n\t\tcpumask_clear_cpu(cpu, mm_cpumask(prev));\n\t\tload_mm_cr4(next);\n#ifdef CONFIG_MODIFY_LDT_SYSCALL\n\t\tif (unlikely(prev->context.ldt != next->context.ldt))\n\t\t\tload_mm_ldt(next);\n#endif\n\t}\n#ifdef CONFIG_SMP\n\t  else {\n\t\tthis_cpu_write(cpu_tlbstate.state, TLBSTATE_OK);\n\t\tBUG_ON(this_cpu_read(cpu_tlbstate.active_mm) != next);\n\t\tif (!cpumask_test_cpu(cpu, mm_cpumask(next))) {\n\t\t\tcpumask_set_cpu(cpu, mm_cpumask(next));\n\t\t\tload_cr3(next->pgd);\n\t\t\ttrace_tlb_flush(TLB_FLUSH_ON_TASK_SWITCH, TLB_FLUSH_ALL);\n\t\t\tload_mm_cr4(next);\n\t\t\tload_mm_ldt(next);\n\t\t}\n\t}\n#endif\n}", "target": 1}
{"code": "static int addrconf_ifid_eui64(u8 *eui, struct net_device *dev)\n{\n\tif (dev->addr_len != IEEE802154_ADDR_LEN)\n\t\treturn -1;\n\tmemcpy(eui, dev->dev_addr, 8);\n\teui[0] ^= 2;\n\treturn 0;\n}", "target": 0}
{"code": "perf_event_set_output(struct perf_event *event, struct perf_event *output_event)\n{\n\tstruct ring_buffer *rb = NULL, *old_rb = NULL;\n\tint ret = -EINVAL;\n\tif (!output_event)\n\t\tgoto set;\n\tif (event == output_event)\n\t\tgoto out;\n\tif (output_event->cpu != event->cpu)\n\t\tgoto out;\n\tif (output_event->cpu == -1 && output_event->ctx != event->ctx)\n\t\tgoto out;\nset:\n\tmutex_lock(&event->mmap_mutex);\n\tif (atomic_read(&event->mmap_count))\n\t\tgoto unlock;\n\tif (output_event) {\n\t\trb = ring_buffer_get(output_event);\n\t\tif (!rb)\n\t\t\tgoto unlock;\n\t}\n\told_rb = event->rb;\n\trcu_assign_pointer(event->rb, rb);\n\tif (old_rb)\n\t\tring_buffer_detach(event, old_rb);\n\tret = 0;\nunlock:\n\tmutex_unlock(&event->mmap_mutex);\n\tif (old_rb)\n\t\tring_buffer_put(old_rb);\nout:\n\treturn ret;\n}", "target": 0}
{"code": "static struct rpmsg_device *rpmsg_virtio_add_ctrl_dev(struct virtio_device *vdev)\n{\n\tstruct virtproc_info *vrp = vdev->priv;\n\tstruct virtio_rpmsg_channel *vch;\n\tstruct rpmsg_device *rpdev_ctrl;\n\tint err = 0;\n\tvch = kzalloc(sizeof(*vch), GFP_KERNEL);\n\tif (!vch)\n\t\treturn ERR_PTR(-ENOMEM);\n\tvch->vrp = vrp;\n\trpdev_ctrl = &vch->rpdev;\n\trpdev_ctrl->ops = &virtio_rpmsg_ops;\n\trpdev_ctrl->dev.parent = &vrp->vdev->dev;\n\trpdev_ctrl->dev.release = virtio_rpmsg_release_device;\n\trpdev_ctrl->little_endian = virtio_is_little_endian(vrp->vdev);\n\terr = rpmsg_ctrldev_register_device(rpdev_ctrl);\n\tif (err) {\n\t\tkfree(vch);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn rpdev_ctrl;\n}", "target": 1}
{"code": "mm_answer_sign(int socket, Buffer *m)\n{\n\tKey *key;\n\tu_char *p;\n\tu_char *signature;\n\tu_int siglen, datlen;\n\tint keyid;\n\tdebug3(\"%s\", __func__);\n\tkeyid = buffer_get_int(m);\n\tp = buffer_get_string(m, &datlen);\n\tif (datlen != 20)\n\t\tfatal(\"%s: data length incorrect: %u\", __func__, datlen);\n\tif (session_id2_len == 0) {\n\t\tsession_id2_len = datlen;\n\t\tsession_id2 = xmalloc(session_id2_len);\n\t\tmemcpy(session_id2, p, session_id2_len);\n\t}\n\tif ((key = get_hostkey_by_index(keyid)) == NULL)\n\t\tfatal(\"%s: no hostkey from index %d\", __func__, keyid);\n\tif (key_sign(key, &signature, &siglen, p, datlen) < 0)\n\t\tfatal(\"%s: key_sign failed\", __func__);\n\tdebug3(\"%s: signature %p(%u)\", __func__, signature, siglen);\n\tbuffer_clear(m);\n\tbuffer_put_string(m, signature, siglen);\n\txfree(p);\n\txfree(signature);\n\tmm_request_send(socket, MONITOR_ANS_SIGN, m);\n\tmonitor_permit(mon_dispatch, MONITOR_REQ_PWNAM, 1);\n\treturn (0);\n}", "target": 0}
{"code": "static int md_domain_init(struct dmar_domain *domain, int guest_width)\n{\n\tint adjust_width;\n\tinit_iova_domain(&domain->iovad, VTD_PAGE_SIZE, IOVA_START_PFN);\n\tdomain_reserve_special_ranges(domain);\n\tdomain->gaw = guest_width;\n\tadjust_width = guestwidth_to_adjustwidth(guest_width);\n\tdomain->agaw = width_to_agaw(adjust_width);\n\tdomain->iommu_coherency = 0;\n\tdomain->iommu_snooping = 0;\n\tdomain->iommu_superpage = 0;\n\tdomain->max_addr = 0;\n\tdomain->pgd = (struct dma_pte *)alloc_pgtable_page(domain->nid);\n\tif (!domain->pgd)\n\t\treturn -ENOMEM;\n\tdomain_flush_cache(domain, domain->pgd, PAGE_SIZE);\n\treturn 0;\n}", "target": 0}
{"code": "static void fts3ReversePoslist(char *pStart, char **ppPoslist){\n  char *p = &(*ppPoslist)[-2];\n  char c = 0;\n  while( p>pStart && (c=*p--)==0 );\n  while( p>pStart && (*p & 0x80) | c ){ \n    c = *p--; \n  }\n  if( p>pStart ){ p = &p[2]; }\n  while( *p++&0x80 );\n  *ppPoslist = p;\n}", "target": 0}
{"code": "static int aspeed_lpc_ctrl_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct aspeed_lpc_ctrl *lpc_ctrl = file_aspeed_lpc_ctrl(file);\n\tunsigned long vsize = vma->vm_end - vma->vm_start;\n\tpgprot_t prot = vma->vm_page_prot;\n\tif (vma->vm_pgoff + vma_pages(vma) > lpc_ctrl->mem_size >> PAGE_SHIFT)\n\t\treturn -EINVAL;\n\tprot = pgprot_noncached(prot);\n\tif (remap_pfn_range(vma, vma->vm_start,\n\t\t(lpc_ctrl->mem_base >> PAGE_SHIFT) + vma->vm_pgoff,\n\t\tvsize, prot))\n\t\treturn -EAGAIN;\n\treturn 0;\n}", "target": 0}
{"code": "void HTTPSession::onCertificate(uint16_t certId,\n                                std::unique_ptr<IOBuf> authenticator) {\n  DestructorGuard dg(this);\n  VLOG(4) << \"CERTIFICATE on\" << *this << \", certId=\" << certId;\n  if (!secondAuthManager_) {\n    return;\n  }\n  bool isValid = false;\n  auto fizzBase = getTransport()->getUnderlyingTransport<AsyncFizzBase>();\n  if (fizzBase) {\n    if (isUpstream()) {\n      isValid = secondAuthManager_->validateAuthenticator(\n          *fizzBase,\n          TransportDirection::UPSTREAM,\n          certId,\n          std::move(authenticator));\n    } else {\n      isValid = secondAuthManager_->validateAuthenticator(\n          *fizzBase,\n          TransportDirection::DOWNSTREAM,\n          certId,\n          std::move(authenticator));\n    }\n  } else {\n    VLOG(4) << \"Underlying transport does not support secondary \"\n               \"authentication.\";\n    return;\n  }\n  if (isValid) {\n    VLOG(4) << \"Successfully validated the authenticator provided by the peer.\";\n  } else {\n    VLOG(4) << \"Failed to validate the authenticator provided by the peer\";\n  }\n}", "target": 0}
{"code": "static int xfrm6_tunnel_rcv(struct sk_buff *skb)\n{\n\tstruct ipv6hdr *iph = ipv6_hdr(skb);\n\t__be32 spi;\n\tspi = xfrm6_tunnel_spi_lookup((xfrm_address_t *)&iph->saddr);\n\treturn xfrm6_rcv_spi(skb, spi);\n}", "target": 1}
{"code": "  void forget_ptr(void *ptr)\n  {\n    if (ptr)\n      for (int i = 0; i < LIBRAW_MSIZE; i++)\n        if (mems[i] == ptr)\n        {\n          mems[i] = NULL;\n          break;\n        }\n  }", "target": 0}
{"code": "static int nl80211_put_iftypes(struct sk_buff *msg, u32 attr, u16 ifmodes)\n{\n\tstruct nlattr *nl_modes = nla_nest_start(msg, attr);\n\tint i;\n\tif (!nl_modes)\n\t\tgoto nla_put_failure;\n\ti = 0;\n\twhile (ifmodes) {\n\t\tif ((ifmodes & 1) && nla_put_flag(msg, i))\n\t\t\tgoto nla_put_failure;\n\t\tifmodes >>= 1;\n\t\ti++;\n\t}\n\tnla_nest_end(msg, nl_modes);\n\treturn 0;\nnla_put_failure:\n\treturn -ENOBUFS;\n}", "target": 0}
{"code": "static int burl_normalize_2F_to_slash_fix (buffer *b, int qs, int i)\n{\n    char * const s = b->ptr;\n    const int blen = (int)buffer_string_length(b);\n    const int used = qs < 0 ? blen : qs;\n    int j = i;\n    for (; i < used; ++i, ++j) {\n        s[j] = s[i];\n        if (s[i] == '%' && s[i+1] == '2' && s[i+2] == 'F') {\n            s[j] = '/';\n            i+=2;\n        }\n    }\n    if (qs >= 0) {\n        memmove(s+j, s+qs, blen - qs);\n        j += blen - qs;\n    }\n    buffer_string_set_length(b, j);\n    return qs;\n}", "target": 1}
{"code": "int ath9k_wmi_cmd(struct wmi *wmi, enum wmi_cmd_id cmd_id,\n\t\t  u8 *cmd_buf, u32 cmd_len,\n\t\t  u8 *rsp_buf, u32 rsp_len,\n\t\t  u32 timeout)\n{\n\tstruct ath_hw *ah = wmi->drv_priv->ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tu16 headroom = sizeof(struct htc_frame_hdr) +\n\t\t       sizeof(struct wmi_cmd_hdr);\n\tstruct sk_buff *skb;\n\tunsigned long time_left;\n\tint ret = 0;\n\tif (ah->ah_flags & AH_UNPLUGGED)\n\t\treturn 0;\n\tskb = alloc_skb(headroom + cmd_len, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\tskb_reserve(skb, headroom);\n\tif (cmd_len != 0 && cmd_buf != NULL) {\n\t\tskb_put_data(skb, cmd_buf, cmd_len);\n\t}\n\tmutex_lock(&wmi->op_mutex);\n\tif (unlikely(wmi->stopped)) {\n\t\tret = -EPROTO;\n\t\tgoto out;\n\t}\n\twmi->cmd_rsp_buf = rsp_buf;\n\twmi->cmd_rsp_len = rsp_len;\n\tret = ath9k_wmi_cmd_issue(wmi, skb, cmd_id, cmd_len);\n\tif (ret)\n\t\tgoto out;\n\ttime_left = wait_for_completion_timeout(&wmi->cmd_wait, timeout);\n\tif (!time_left) {\n\t\tath_dbg(common, WMI, \"Timeout waiting for WMI command: %s\\n\",\n\t\t\twmi_cmd_to_name(cmd_id));\n\t\tmutex_unlock(&wmi->op_mutex);\n\t\treturn -ETIMEDOUT;\n\t}\n\tmutex_unlock(&wmi->op_mutex);\n\treturn 0;\nout:\n\tath_dbg(common, WMI, \"WMI failure for: %s\\n\", wmi_cmd_to_name(cmd_id));\n\tmutex_unlock(&wmi->op_mutex);\n\tkfree_skb(skb);\n\treturn ret;\n}", "target": 1}
{"code": "static void DecodeFPDelta(unsigned char *input, unsigned char *output, int cols,\n                          int channels, int bytesPerSample)\n{\n  DecodeDeltaBytes(input, cols * bytesPerSample, channels);\n  int32_t rowIncrement = cols * channels;\n  if (bytesPerSample == 2)\n  {\n#if LibRawBigEndian\n    const unsigned char *input0 = input;\n    const unsigned char *input1 = input + rowIncrement;\n#else\n    const unsigned char *input1 = input;\n    const unsigned char *input0 = input + rowIncrement;\n#endif\n    for (int col = 0; col < rowIncrement; ++col)\n    {\n      output[0] = input0[col];\n      output[1] = input1[col];\n      output += 2;\n    }\n  }\n  else if (bytesPerSample == 3)\n  {\n    const unsigned char *input0 = input;\n    const unsigned char *input1 = input + rowIncrement;\n    const unsigned char *input2 = input + rowIncrement * 2;\n    for (int col = 0; col < rowIncrement; ++col)\n    {\n      output[0] = input0[col];\n      output[1] = input1[col];\n      output[2] = input2[col];\n      output += 3;\n    }\n  }\n  else\n  {\n#if LibRawBigEndian\n    const unsigned char *input0 = input;\n    const unsigned char *input1 = input + rowIncrement;\n    const unsigned char *input2 = input + rowIncrement * 2;\n    const unsigned char *input3 = input + rowIncrement * 3;\n#else\n    const unsigned char *input3 = input;\n    const unsigned char *input2 = input + rowIncrement;\n    const unsigned char *input1 = input + rowIncrement * 2;\n    const unsigned char *input0 = input + rowIncrement * 3;\n#endif\n    for (int col = 0; col < rowIncrement; ++col)\n    {\n      output[0] = input0[col];\n      output[1] = input1[col];\n      output[2] = input2[col];\n      output[3] = input3[col];\n      output += 4;\n    }\n  }\n}", "target": 0}
{"code": "void ap_lua_rstack_dump(lua_State *L, request_rec *r, const char *msg)\n{\n    int i;\n    int top = lua_gettop(L);\n    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(01484) \"Lua Stack Dump: [%s]\", msg);\n    for (i = 1; i <= top; i++) {\n        int t = lua_type(L, i);\n        switch (t) {\n        case LUA_TSTRING:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                              \"%d:  '%s'\", i, lua_tostring(L, i));\n                break;\n            }\n        case LUA_TUSERDATA:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, \"%d:  userdata\",\n                              i);\n                break;\n            }\n        case LUA_TLIGHTUSERDATA:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                              \"%d:  lightuserdata\", i);\n                break;\n            }\n        case LUA_TNIL:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, \"%d:  NIL\", i);\n                break;\n            }\n        case LUA_TNONE:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, \"%d:  None\", i);\n                break;\n            }\n        case LUA_TBOOLEAN:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                              \"%d:  %s\", i, lua_toboolean(L,\n                                                          i) ? \"true\" :\n                              \"false\");\n                break;\n            }\n        case LUA_TNUMBER:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                              \"%d:  %g\", i, lua_tonumber(L, i));\n                break;\n            }\n        case LUA_TTABLE:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                              \"%d:  <table>\", i);\n                break;\n            }\n        case LUA_TFUNCTION:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                              \"%d:  <function>\", i);\n                break;\n            }\n        default:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                              \"%d:  unknown: -[%s]-\", i, lua_typename(L, i));\n                break;\n            }\n        }\n    }\n}", "target": 0}
{"code": "copy_creds_except(krb5_context context, krb5_ccache incc,\n                  krb5_ccache outcc, krb5_principal princ)\n{\n    krb5_error_code ret, ret2;\n    krb5_cc_cursor cur;\n    krb5_creds creds;\n    ret = krb5_cc_set_flags(context, incc, 0);\n    if (ret)\n        return ret;\n    ret = krb5_cc_start_seq_get(context, incc, &cur);\n    if (ret)\n        goto cleanup;\n    while (!(ret = krb5_cc_next_cred(context, incc, &cur, &creds))) {\n        if (krb5_principal_compare(context, princ, creds.server))\n            continue;\n        ret = krb5_cc_store_cred(context, outcc, &creds);\n        krb5_free_cred_contents(context, &creds);\n        if (ret)\n            goto cleanup;\n    }\n    if (ret != KRB5_CC_END)\n        goto cleanup;\n    ret = 0;\ncleanup:\n    ret2 = krb5_cc_set_flags(context, incc, KRB5_TC_OPENCLOSE);\n    return (ret == 0) ? ret2 : ret;\n}", "target": 0}
{"code": "static int handle_vmread(struct kvm_vcpu *vcpu)\n{\n\tunsigned long field;\n\tu64 field_value;\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tu32 vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\tgva_t gva = 0;\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\tif (!nested_vmx_check_vmcs12(vcpu))\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\tfield = kvm_register_readl(vcpu, (((vmx_instruction_info) >> 28) & 0xf));\n\tif (vmcs12_read_any(vcpu, field, &field_value) < 0) {\n\t\tnested_vmx_failValid(vcpu, VMXERR_UNSUPPORTED_VMCS_COMPONENT);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\tif (vmx_instruction_info & (1u << 10)) {\n\t\tkvm_register_writel(vcpu, (((vmx_instruction_info) >> 3) & 0xf),\n\t\t\tfield_value);\n\t} else {\n\t\tif (get_vmx_mem_address(vcpu, exit_qualification,\n\t\t\t\tvmx_instruction_info, true, &gva))\n\t\t\treturn 1;\n\t\tkvm_write_guest_virt_system(&vcpu->arch.emulate_ctxt, gva,\n\t\t\t     &field_value, (is_long_mode(vcpu) ? 8 : 4), NULL);\n\t}\n\tnested_vmx_succeed(vcpu);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}", "target": 1}
{"code": "static struct page *special_mapping_nopage(struct vm_area_struct *vma,\n\t\t\t\t\t   unsigned long address, int *type)\n{\n\tstruct page **pages;\n\tBUG_ON(address < vma->vm_start || address >= vma->vm_end);\n\taddress -= vma->vm_start;\n\tfor (pages = vma->vm_private_data; address > 0 && *pages; ++pages)\n\t\taddress -= PAGE_SIZE;\n\tif (*pages) {\n\t\tstruct page *page = *pages;\n\t\tget_page(page);\n\t\treturn page;\n\t}\n\treturn NOPAGE_SIGBUS;\n}", "target": 0}
{"code": "    void CiffComponent::doPrint(std::ostream&      os,\n                                ByteOrder          byteOrder,\n                                const std::string& prefix) const\n    {\n        os << prefix\n           << _(\"tag\") << \" = 0x\" << std::setw(4) << std::setfill('0')\n           << std::hex << std::right << tagId()\n           << \", \" << _(\"dir\") << \" = 0x\" << std::setw(4) << std::setfill('0')\n           << std::hex << std::right << dir()\n           << \", \" << _(\"type\") << \" = \" << TypeInfo::typeName(typeId())\n           << \", \" << _(\"size\") << \" = \" << std::dec << size_\n           << \", \" << _(\"offset\") << \" = \" << offset_ << \"\\n\";\n        Value::UniquePtr value;\n        if (typeId() != directory) {\n            value = Value::create(typeId());\n            value->read(pData_, size_, byteOrder);\n            if (value->size() < 100) {\n                os << prefix << *value << \"\\n\";\n            }\n        }\n    } ", "target": 0}
{"code": "static NTSTATUS smb_file_position_information(connection_struct *conn,\n\t\t\t\tconst char *pdata,\n\t\t\t\tint total_data,\n\t\t\t\tfiles_struct *fsp)\n{\n\tuint64_t position_information;\n\tif (total_data < 8) {\n\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t}\n\tif (fsp == NULL) {\n\t\treturn NT_STATUS_OK;\n\t}\n\tposition_information = (uint64_t)IVAL(pdata,0);\n\tposition_information |= (((uint64_t)IVAL(pdata,4)) << 32);\n\tDEBUG(10,(\"smb_file_position_information: Set file position \"\n\t\t  \"information for file %s to %.0f\\n\", fsp_str_dbg(fsp),\n\t\t  (double)position_information));\n\tfh_set_position_information(fsp->fh, position_information);\n\treturn NT_STATUS_OK;\n}", "target": 0}
{"code": "l2tp_framing_cap_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint32_t *ptr = (const uint32_t *)dat;\n\tif (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_CAP_ASYNC_MASK) {\n\t\tND_PRINT((ndo, \"A\"));\n\t}\n\tif (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_CAP_SYNC_MASK) {\n\t\tND_PRINT((ndo, \"S\"));\n\t}\n}", "target": 1}
{"code": "static int task_clock_event_init(struct perf_event *event)\n{\n\tif (event->attr.type != PERF_TYPE_SOFTWARE)\n\t\treturn -ENOENT;\n\tif (event->attr.config != PERF_COUNT_SW_TASK_CLOCK)\n\t\treturn -ENOENT;\n\tif (has_branch_stack(event))\n\t\treturn -EOPNOTSUPP;\n\tperf_swevent_init_hrtimer(event);\n\treturn 0;\n}", "target": 0}
{"code": "PerformanceNavigationTiming::PerformanceNavigationTiming(\n    LocalFrame* frame,\n     ResourceTimingInfo* info,\n     TimeTicks time_origin,\n     const WebVector<WebServerTimingInfo>& server_timing)\n    : PerformanceResourceTiming(info ? info->InitialURL().GetString() : \"\",\n                                \"navigation\",\n                                time_origin,\n                                server_timing),\n       ContextClient(frame),\n       resource_timing_info_(info) {\n   DCHECK(frame);\n  DCHECK(info);\n}", "target": 1}
{"code": "void CefLayeredWindowUpdaterOSR::OnAllocatedSharedMemory(\n    const gfx::Size& pixel_size,\n    base::UnsafeSharedMemoryRegion region) {\n  size_t expected_bytes;\n  bool size_result = viz::ResourceSizes::MaybeSizeInBytes(\n      pixel_size, viz::SinglePlaneFormat::kRGBA_8888, &expected_bytes);\n  if (!size_result) {\n    return;\n  }\n  pixel_size_ = pixel_size;\n  shared_memory_ = region.Map();\n  DCHECK(shared_memory_.IsValid());\n}", "target": 1}
{"code": "address_space_translate_for_iotlb(CPUState *cpu, int asidx, hwaddr addr,\n                                  hwaddr *xlat, hwaddr *plen,\n                                  MemTxAttrs attrs, int *prot)\n{\n    MemoryRegionSection *section;\n    IOMMUMemoryRegion *iommu_mr;\n    IOMMUMemoryRegionClass *imrc;\n    IOMMUTLBEntry iotlb;\n    int iommu_idx;\n    AddressSpaceDispatch *d =\n        qatomic_rcu_read(&cpu->cpu_ases[asidx].memory_dispatch);\n    for (;;) {\n        section = address_space_translate_internal(d, addr, &addr, plen, false);\n        iommu_mr = memory_region_get_iommu(section->mr);\n        if (!iommu_mr) {\n            break;\n        }\n        imrc = memory_region_get_iommu_class_nocheck(iommu_mr);\n        iommu_idx = imrc->attrs_to_index(iommu_mr, attrs);\n        tcg_register_iommu_notifier(cpu, iommu_mr, iommu_idx);\n        iotlb = imrc->translate(iommu_mr, addr, IOMMU_NONE, iommu_idx);\n        addr = ((iotlb.translated_addr & ~iotlb.addr_mask)\n                | (addr & iotlb.addr_mask));\n        if (!(iotlb.perm & IOMMU_RO)) {\n            *prot &= ~(PAGE_READ | PAGE_EXEC);\n        }\n        if (!(iotlb.perm & IOMMU_WO)) {\n            *prot &= ~PAGE_WRITE;\n        }\n        if (!*prot) {\n            goto translate_fail;\n        }\n        d = flatview_to_dispatch(address_space_to_flatview(iotlb.target_as));\n    }\n    assert(!memory_region_is_iommu(section->mr));\n    *xlat = addr;\n    return section;\ntranslate_fail:\n    return &d->map.sections[PHYS_SECTION_UNASSIGNED];\n}", "target": 1}
{"code": "mrb_obj_clone(mrb_state *mrb, mrb_value self)\n{\n  struct RObject *p;\n  mrb_value clone;\n  if (mrb_immediate_p(self)) {\n    mrb_raisef(mrb, E_TYPE_ERROR, \"can't clone %S\", self);\n  }\n  if (mrb_type(self) == MRB_TT_SCLASS) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't clone singleton class\");\n  }\n  p = (struct RObject*)mrb_obj_alloc(mrb, mrb_type(self), mrb_obj_class(mrb, self));\n  p->c = mrb_singleton_class_clone(mrb, self);\n  mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)p->c);\n  clone = mrb_obj_value(p);\n  init_copy(mrb, clone, self);\n  p->flags = mrb_obj_ptr(self)->flags;\n  return clone;\n}", "target": 1}
{"code": "spnego_gss_complete_auth_token(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tgss_buffer_t input_message_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_complete_auth_token(minor_status,\n\t\t\t\t      context_handle,\n\t\t\t\t      input_message_buffer);\n\treturn (ret);\n}", "target": 1}
{"code": "ikev2_vid_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len _U_, const u_char *ep _U_,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\tconst u_char *vid;\n\tint i, len;\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tikev2_pay_print(ndo, NPSTR(tpay), e.critical);\n\tND_PRINT((ndo,\" len=%d vid=\", ntohs(e.len) - 4));\n\tvid = (const u_char *)(ext+1);\n\tlen = ntohs(e.len) - 4;\n\tND_TCHECK2(*vid, len);\n\tfor(i=0; i<len; i++) {\n\t\tif(ND_ISPRINT(vid[i])) ND_PRINT((ndo, \"%c\", vid[i]));\n\t\telse ND_PRINT((ndo, \".\"));\n\t}\n\tif (2 < ndo->ndo_vflag && 4 < len) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}", "target": 0}
{"code": "MagickExport ChannelPerceptualHash *GetImagePerceptualHash(const Image *image,\n  ExceptionInfo *exception)\n{\n  ChannelPerceptualHash\n    *perceptual_hash;\n  char\n    *colorspaces,\n    *p,\n    *q;\n  const char\n    *artifact;\n  MagickBooleanType\n    status;\n  ssize_t\n    i;\n  perceptual_hash=(ChannelPerceptualHash *) AcquireQuantumMemory(\n    MaxPixelChannels+1UL,sizeof(*perceptual_hash));\n  if (perceptual_hash == (ChannelPerceptualHash *) NULL)\n    return((ChannelPerceptualHash *) NULL);\n  artifact=GetImageArtifact(image,\"phash:colorspaces\");\n  if (artifact != NULL)\n    colorspaces=AcquireString(artifact);\n  else\n    colorspaces=AcquireString(\"sRGB,HCLp\");\n  perceptual_hash[0].number_colorspaces=0;\n  perceptual_hash[0].number_channels=0;\n  q=colorspaces;\n  for (i=0; (p=StringToken(\",\",&q)) != (char *) NULL; i++)\n  {\n    ChannelMoments\n      *moments;\n    Image\n      *hash_image;\n    size_t\n      j;\n    ssize_t\n      channel,\n      colorspace;\n    if (i >= MaximumNumberOfPerceptualColorspaces)\n      break;\n    colorspace=ParseCommandOption(MagickColorspaceOptions,MagickFalse,p);\n    if (colorspace < 0)\n      break;\n    perceptual_hash[0].colorspace[i]=(ColorspaceType) colorspace;\n    hash_image=BlurImage(image,0.0,1.0,exception);\n    if (hash_image == (Image *) NULL)\n      break;\n    hash_image->depth=8;\n    status=TransformImageColorspace(hash_image,(ColorspaceType) colorspace,\n      exception);\n    if (status == MagickFalse)\n      break;\n    moments=GetImageMoments(hash_image,exception);\n    perceptual_hash[0].number_colorspaces++;\n    perceptual_hash[0].number_channels+=GetImageChannels(hash_image);\n    hash_image=DestroyImage(hash_image);\n    if (moments == (ChannelMoments *) NULL)\n      break;\n    for (channel=0; channel <= MaxPixelChannels; channel++)\n      for (j=0; j < MaximumNumberOfImageMoments; j++)\n        perceptual_hash[channel].phash[i][j]=\n          (-MagickLog10(moments[channel].invariant[j]));\n    moments=(ChannelMoments *) RelinquishMagickMemory(moments);\n  }\n  colorspaces=DestroyString(colorspaces);\n  return(perceptual_hash);\n}", "target": 0}
{"code": "static void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t      struct userfaultfd_wait_queue *ewq)\n{\n\tstruct userfaultfd_ctx *release_new_ctx;\n\tif (WARN_ON_ONCE(current->flags & PF_EXITING))\n\t\tgoto out;\n\tewq->ctx = ctx;\n\tinit_waitqueue_entry(&ewq->wq, current);\n\trelease_new_ctx = NULL;\n\tspin_lock(&ctx->event_wqh.lock);\n\t__add_wait_queue(&ctx->event_wqh, &ewq->wq);\n\tfor (;;) {\n\t\tset_current_state(TASK_KILLABLE);\n\t\tif (ewq->msg.event == 0)\n\t\t\tbreak;\n\t\tif (READ_ONCE(ctx->released) ||\n\t\t    fatal_signal_pending(current)) {\n\t\t\t__remove_wait_queue(&ctx->event_wqh, &ewq->wq);\n\t\t\tif (ewq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tstruct userfaultfd_ctx *new;\n\t\t\t\tnew = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tewq->msg.arg.reserved.reserved1;\n\t\t\t\trelease_new_ctx = new;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\t\twake_up_poll(&ctx->fd_wqh, EPOLLIN);\n\t\tschedule();\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->event_wqh.lock);\n\tif (release_new_ctx) {\n\t\tstruct vm_area_struct *vma;\n\t\tstruct mm_struct *mm = release_new_ctx->mm;\n\t\tdown_write(&mm->mmap_sem);\n\t\tVM_WARN_ON(!mmget_still_valid(mm));\n\t\tfor (vma = mm->mmap; vma; vma = vma->vm_next)\n\t\t\tif (vma->vm_userfaultfd_ctx.ctx == release_new_ctx) {\n\t\t\t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n\t\t\t\tvma->vm_flags &= ~(VM_UFFD_WP | VM_UFFD_MISSING);\n\t\t\t}\n\t\tup_write(&mm->mmap_sem);\n\t\tuserfaultfd_ctx_put(release_new_ctx);\n\t}\nout:\n\tWRITE_ONCE(ctx->mmap_changing, false);\n\tuserfaultfd_ctx_put(ctx);\n}", "target": 0}
{"code": "int X509_REQ_add_extensions_nid(X509_REQ *req, STACK_OF(X509_EXTENSION) *exts,\n                                int nid)\n{\n    ASN1_TYPE *at = NULL;\n    X509_ATTRIBUTE *attr = NULL;\n    if (!(at = ASN1_TYPE_new()) || !(at->value.sequence = ASN1_STRING_new()))\n        goto err;\n    at->type = V_ASN1_SEQUENCE;\n    at->value.sequence->length =\n        ASN1_item_i2d((ASN1_VALUE *)exts,\n                      &at->value.sequence->data,\n                      ASN1_ITEM_rptr(X509_EXTENSIONS));\n    if (!(attr = X509_ATTRIBUTE_new()))\n        goto err;\n    if (!(attr->value.set = sk_ASN1_TYPE_new_null()))\n        goto err;\n    if (!sk_ASN1_TYPE_push(attr->value.set, at))\n        goto err;\n    at = NULL;\n    attr->single = 0;\n    attr->object = OBJ_nid2obj(nid);\n    if (!req->req_info->attributes) {\n        if (!(req->req_info->attributes = sk_X509_ATTRIBUTE_new_null()))\n            goto err;\n    }\n    if (!sk_X509_ATTRIBUTE_push(req->req_info->attributes, attr))\n        goto err;\n    return 1;\n err:\n    X509_ATTRIBUTE_free(attr);\n    ASN1_TYPE_free(at);\n    return 0;\n}", "target": 0}
{"code": "static int domain_update_iommu_superpage(struct intel_iommu *skip)\n{\n\tstruct dmar_drhd_unit *drhd;\n\tstruct intel_iommu *iommu;\n\tint mask = 0xf;\n\tif (!intel_iommu_superpage) {\n\t\treturn 0;\n\t}\n\trcu_read_lock();\n\tfor_each_active_iommu(iommu, drhd) {\n\t\tif (iommu != skip) {\n\t\t\tmask &= cap_super_page_val(iommu->cap);\n\t\t\tif (!mask)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn fls(mask);\n}", "target": 0}
{"code": "smp_fetch_url_port(struct proxy *px, struct session *l4, void *l7, unsigned int opt,\n                   const struct arg *args, struct sample *smp)\n{\n\tstruct http_txn *txn = l7;\n\tCHECK_HTTP_MESSAGE_FIRST();\n\turl2sa(txn->req.chn->buf->p + txn->req.sl.rq.u, txn->req.sl.rq.u_l, &l4->req->cons->conn->addr.to);\n\tsmp->type = SMP_T_UINT;\n\tsmp->data.uint = ntohs(((struct sockaddr_in *)&l4->req->cons->conn->addr.to)->sin_port);\n\tif (px->options & PR_O_HTTP_PROXY)\n\t\tl4->flags |= SN_ADDR_SET;\n\tsmp->flags = 0;\n\treturn 1;\n}", "target": 0}
{"code": "DLLEXPORT unsigned long DLLCALL tjBufSize(int width, int height,\n\tint jpegSubsamp)\n{\n\tunsigned long retval=0;  int mcuw, mcuh, chromasf;\n\tif(width<1 || height<1 || jpegSubsamp<0 || jpegSubsamp>=NUMSUBOPT)\n\t\t_throwg(\"tjBufSize(): Invalid argument\");\n\tmcuw=tjMCUWidth[jpegSubsamp];\n\tmcuh=tjMCUHeight[jpegSubsamp];\n\tchromasf=jpegSubsamp==TJSAMP_GRAY? 0: 4*64/(mcuw*mcuh);\n\tretval=PAD(width, mcuw) * PAD(height, mcuh) * (2 + chromasf) + 2048;\n\tbailout:\n\treturn retval;\n}", "target": 0}
{"code": "static void http1_on_ready(intptr_t uuid, fio_protocol_s *protocol) {\n  http1pr_s *p = (http1pr_s *)protocol;\n  if ((p->stop & 4)) {\n    p->stop ^= 4;\n    fio_force_event(uuid, FIO_EVENT_ON_DATA);\n  }\n  (void)protocol;\n}", "target": 1}
{"code": "SYSCALL_DEFINE1(time, time_t __user *, tloc)\n{\n\ttime_t i = get_seconds();\n\tif (tloc) {\n\t\tif (put_user(i,tloc))\n\t\t\treturn -EFAULT;\n\t}\n\tforce_successful_syscall_return();\n\treturn i;\n}", "target": 0}
{"code": "static int http_read_header(URLContext *h, int *new_location)\n{\n    HTTPContext *s = h->priv_data;\n    char line[MAX_URL_SIZE];\n    int err = 0;\n    s->chunksize = -1;\n    for (;;) {\n        if ((err = http_get_line(s, line, sizeof(line))) < 0)\n            return err;\n        av_log(h, AV_LOG_TRACE, \"header='%s'\\n\", line);\n        err = process_line(h, line, s->line_count, new_location);\n        if (err < 0)\n            return err;\n        if (err == 0)\n            break;\n        s->line_count++;\n    }\n    if (s->seekable == -1 && s->is_mediagateway && s->filesize == 2000000000)\n        h->is_streamed = 1; \n    cookie_string(s->cookie_dict, &s->cookies);\n    av_dict_free(&s->cookie_dict);\n    return err;\n}", "target": 1}
{"code": "static void vmci_transport_peer_attach_cb(u32 sub_id,\n\t\t\t\t\t  const struct vmci_event_data *e_data,\n\t\t\t\t\t  void *client_data)\n{\n\tstruct sock *sk = client_data;\n\tconst struct vmci_event_payload_qp *e_payload;\n\tstruct vsock_sock *vsk;\n\te_payload = vmci_event_data_const_payload(e_data);\n\tvsk = vsock_sk(sk);\n\tlocal_bh_disable();\n\tbh_lock_sock(sk);\n\tif (vmci_handle_is_equal(vmci_trans(vsk)->qp_handle,\n\t\t\t\t e_payload->handle)) {\n\t\tgoto out;\n\t}\nout:\n\tbh_unlock_sock(sk);\n\tlocal_bh_enable();\n}", "target": 0}
{"code": "RawTile OpenJPEGImage::getRegion( int ha, int va, unsigned int res, int layers, int x, int y, unsigned int w, unsigned int h ){\n  unsigned int obpc = bpc;\n  if( bpc <= 16 && bpc > 8 ) obpc = 16;\n  else if( bpc <= 8 ) obpc = 8;\n#ifdef DEBUG\n  Timer timer;\n  timer.start();\n#endif\n  RawTile rawtile( 0, res, ha, va, w, h, channels, obpc );\n  if( obpc == 16 ) rawtile.data = new unsigned short[w * h * channels];\n  else if( obpc == 8 ) rawtile.data = new unsigned char[w * h * channels];\n  else throw file_error( \"OpenJPEG :: Unsupported number of bits\" );\n  rawtile.dataLength = w*h*channels*(obpc/8);\n  rawtile.filename = getImagePath();\n  rawtile.timestamp = timestamp;\n  process( res, layers, x, y, w, h, rawtile.data );\n#ifdef DEBUG\n  logfile << \"OpenJPEG :: getRegion() :: \" << timer.getTime() << \" microseconds\" << endl;\n#endif\n  return rawtile;\n}", "target": 1}
{"code": "static int scantag(const char* in, char* buffer, int* lenp) {\n    int len;\n    for (len = 0; len < 128; len++) {\n        const char c = *in++;\n        switch (c) {\n        case '\\0':\n            return 0;\n        case '<':\n            return 0;\n        case '>':\n            buffer[len] = '\\0';\n            *lenp = len+1;\n            return 1;\n        default:\n            break;\n        }\n        buffer[len] = c;\n    }\n    return 0;\n}", "target": 0}
{"code": "static int ref_pic_list_struct(GetBitContext *gb, RefPicListStruct *rpl)\n{\n    uint32_t delta_poc_st, strp_entry_sign_flag = 0;\n    rpl->ref_pic_num = get_ue_golomb_long(gb);\n    if (rpl->ref_pic_num > 0) {\n        delta_poc_st = get_ue_golomb_long(gb);\n        rpl->ref_pics[0] = delta_poc_st;\n        if (rpl->ref_pics[0] != 0) {\n            strp_entry_sign_flag = get_bits(gb, 1);\n            rpl->ref_pics[0] *= 1 - (strp_entry_sign_flag << 1);\n        }\n    }\n    for (int i = 1; i < rpl->ref_pic_num; ++i) {\n        delta_poc_st = get_ue_golomb_long(gb);\n        if (delta_poc_st != 0)\n            strp_entry_sign_flag = get_bits(gb, 1);\n        rpl->ref_pics[i] = rpl->ref_pics[i - 1] + delta_poc_st * (1 - (strp_entry_sign_flag << 1));\n    }\n    return 0;\n}", "target": 1}
{"code": "int LibarchivePlugin::extractionFlags() const\n{\n    int result = ARCHIVE_EXTRACT_TIME;\n    result |= ARCHIVE_EXTRACT_SECURE_NODOTDOT;\n    return result;\n}", "target": 1}
{"code": "node_new_ctype(int type, int not, OnigOptionType options)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n  NODE_SET_TYPE(node, NODE_CTYPE);\n  CTYPE_(node)->ctype   = type;\n  CTYPE_(node)->not     = not;\n  CTYPE_(node)->options = options;\n  CTYPE_(node)->ascii_mode = IS_ASCII_MODE_CTYPE_OPTION(type, options);\n  return node;\n}", "target": 0}
{"code": "  QInt32() {}", "target": 1}
{"code": "static void flush_tmregs_to_thread(struct task_struct *tsk)\n{\n\tif (tsk != current)\n\t\treturn;\n\tif (MSR_TM_SUSPENDED(mfmsr())) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t} else {\n\t\ttm_enable();\n\t\ttm_save_sprs(&(tsk->thread));\n\t}\n}", "target": 1}
{"code": "int nfc_dev_up(struct nfc_dev *dev)\n{\n\tint rc = 0;\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->rfkill && rfkill_blocked(dev->rfkill)) {\n\t\trc = -ERFKILL;\n\t\tgoto error;\n\t}\n\tif (dev->fw_download_in_progress) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\tif (dev->dev_up) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\tif (dev->ops->dev_up)\n\t\trc = dev->ops->dev_up(dev);\n\tif (!rc)\n\t\tdev->dev_up = true;\n\tif (dev->ops->discover_se && dev->ops->discover_se(dev))\n\t\tpr_err(\"SE discovery failed\\n\");\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "static void decode_rgb_frame(FFV1Context *s, uint8_t *src[3], int w, int h, int stride[3])\n{\n    int x, y, p;\n    int16_t *sample[4][2];\n    int lbd    = s->avctx->bits_per_raw_sample <= 8;\n    int bits   = s->avctx->bits_per_raw_sample > 0 ? s->avctx->bits_per_raw_sample : 8;\n    int offset = 1 << bits;\n    for (x = 0; x < 4; x++) {\n        sample[x][0] = s->sample_buffer +  x * 2      * (w + 6) + 3;\n        sample[x][1] = s->sample_buffer + (x * 2 + 1) * (w + 6) + 3;\n    }\n    s->run_index = 0;\n    memset(s->sample_buffer, 0, 8 * (w + 6) * sizeof(*s->sample_buffer));\n    for (y = 0; y < h; y++) {\n        for (p = 0; p < 3 + s->transparency; p++) {\n            int16_t *temp = sample[p][0]; \n            sample[p][0] = sample[p][1];\n            sample[p][1] = temp;\n            sample[p][1][-1]= sample[p][0][0  ];\n            sample[p][0][ w]= sample[p][0][w-1];\n            if (lbd && s->slice_coding_mode == 0)\n                decode_line(s, w, sample[p], (p + 1)/2, 9);\n            else\n                decode_line(s, w, sample[p], (p + 1)/2, bits + (s->slice_coding_mode != 1));\n        }\n        for (x = 0; x < w; x++) {\n            int g = sample[0][1][x];\n            int b = sample[1][1][x];\n            int r = sample[2][1][x];\n            int a = sample[3][1][x];\n            if (s->slice_coding_mode != 1) {\n                b -= offset;\n                r -= offset;\n                g -= (b * s->slice_rct_by_coef + r * s->slice_rct_ry_coef) >> 2;\n                b += g;\n                r += g;\n            }\n            if (lbd)\n                *((uint32_t*)(src[0] + x*4 + stride[0]*y)) = b + (g<<8) + (r<<16) + (a<<24);\n            else {\n                *((uint16_t*)(src[0] + x*2 + stride[0]*y)) = b;\n                *((uint16_t*)(src[1] + x*2 + stride[1]*y)) = g;\n                *((uint16_t*)(src[2] + x*2 + stride[2]*y)) = r;\n            }\n        }\n    }\n}", "target": 0}
{"code": "static inline u32 nfsd4_readdir_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\tu32 maxcount = 0, rlen = 0;\n\tmaxcount = svc_max_payload(rqstp);\n\trlen = min(op->u.readdir.rd_maxcount, maxcount);\n\treturn (op_encode_hdr_size + op_encode_verifier_maxsz +\n\t\tXDR_QUADLEN(rlen)) * sizeof(__be32);\n}", "target": 0}
{"code": "TEST(HeaderDataConstructorTest, RegexMatchSpecifier) {\n  const std::string yaml = R\"EOF(\nname: test-header\nregex_match: value\n  )EOF\";\n  HeaderUtility::HeaderData header_data =\n      HeaderUtility::HeaderData(parseHeaderMatcherFromYaml(yaml));\n  EXPECT_EQ(\"test-header\", header_data.name_.get());\n  EXPECT_EQ(HeaderUtility::HeaderMatchType::Regex, header_data.header_match_type_);\n  EXPECT_EQ(\"\", header_data.value_);\n}", "target": 0}
{"code": "get_AT_name (unsigned long attribute)\n{\n  const char *name;\n  if (attribute == 0)\n    return \"DW_AT value: 0\";\n  if (attribute == DW_AT_MIPS_fde)\n    return \"DW_AT_MIPS_fde or DW_AT_HP_unmodifiable\";\n  name = get_DW_AT_name (attribute);\n  if (name == NULL)\n    {\n      static char buffer[100];\n      snprintf (buffer, sizeof (buffer), _(\"Unknown AT value: %lx\"),\n\t\tattribute);\n      return buffer;\n    }\n  return name;\n}", "target": 0}
{"code": "static void maybe_add_creds(struct sk_buff *skb, const struct socket *sock,\n\t\t\t    const struct sock *other)\n{\n\tif (UNIXCB(skb).pid)\n\t\treturn;\n\tif (unix_passcred_enabled(sock, other)) {\n\t\tUNIXCB(skb).pid  = get_pid(task_tgid(current));\n\t\tcurrent_uid_gid(&UNIXCB(skb).uid, &UNIXCB(skb).gid);\n\t}\n}", "target": 0}
{"code": "rndset(unsigned long v)\n{\n\tregister uint32_t h;\n#if defined(arc4random_pushb_fast) || defined(MKSH_A4PB)\n\tregister uint32_t t;\n#endif\n\tstruct {\n\t\tstruct timeval tv;\n\t\tvoid *sp;\n\t\tuint32_t qh;\n\t\tpid_t pp;\n\t\tshort r;\n\t} z;\n#ifdef DEBUG\n\tmemset(&z, 0, sizeof(z));\n#endif\n\th = lcg_state;\n\tBAFHFinish_reg(h);\n\tBAFHUpdateMem_reg(h, &v, sizeof(v));\n\tmksh_TIME(z.tv);\n\tz.sp = &lcg_state;\n\tz.pp = procpid;\n\tz.r = (short)rndget();\n#if defined(arc4random_pushb_fast) || defined(MKSH_A4PB)\n\tt = qh_state;\n\tBAFHFinish_reg(t);\n\tz.qh = (t & 0xFFFF8000) | rndget();\n\tlcg_state = (t << 15) | rndget();\n\tt = h;\n\tBAFHUpdateMem_reg(t, &lcg_state, sizeof(lcg_state));\n\tBAFHFinish_reg(t);\n\tlcg_state = t;\n#if defined(arc4random_pushb_fast)\n\tarc4random_pushb_fast(&lcg_state, sizeof(lcg_state));\n\tlcg_state = arc4random();\n#else\n\tlcg_state = arc4random_pushb(&lcg_state, sizeof(lcg_state));\n#endif\n\tBAFHUpdateMem_reg(h, &lcg_state, sizeof(lcg_state));\n#else\n\tz.qh = qh_state;\n#endif\n\tBAFHUpdateMem_reg(h, &z, sizeof(z));\n\tBAFHFinish_reg(h);\n\tlcg_state = h;\n}", "target": 0}
{"code": "LibRaw_windows_datastream::LibRaw_windows_datastream(const TCHAR *sFile)\n    : LibRaw_buffer_datastream(NULL, 0), hMap_(0), pView_(NULL)\n{\n  HANDLE hFile = CreateFile(sFile, GENERIC_READ, 0, 0, OPEN_EXISTING,\n                            FILE_ATTRIBUTE_NORMAL, 0);\n  if (hFile == INVALID_HANDLE_VALUE)\n    throw std::runtime_error(\"failed to open the file\");\n  try\n  {\n    Open(hFile);\n  }\n  catch (...)\n  {\n    CloseHandle(hFile);\n    throw;\n  }\n  CloseHandle(hFile); \n  reconstruct_base();\n}", "target": 0}
{"code": "static int memory_access_ok(struct vhost_dev *d, struct vhost_memory *mem,\n\t\t\t    int log_all)\n{\n\tint i;\n\tfor (i = 0; i < d->nvqs; ++i) {\n\t\tint ok;\n\t\tmutex_lock(&d->vqs[i].mutex);\n\t\tif (d->vqs[i].private_data)\n\t\t\tok = vq_memory_access_ok(d->vqs[i].log_base, mem,\n\t\t\t\t\t\t log_all);\n\t\telse\n\t\t\tok = 1;\n\t\tmutex_unlock(&d->vqs[i].mutex);\n\t\tif (!ok)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "    const std::unordered_map<std::string, std::string> &headers() const override\n    {\n        return headers_;\n    }", "target": 1}
{"code": "rad_get_vendor_attr(u_int32_t *vendor, const void **data, size_t *len)\n{\n\tstruct vendor_attribute *attr;\n\tattr = (struct vendor_attribute *)*data;\n\t*vendor = ntohl(attr->vendor_value);\n\t*data = attr->attrib_data;\n\t*len = attr->attrib_len - 2;\n\treturn (attr->attrib_type);\n}", "target": 1}
{"code": "static inline loff_t ext4_isize(struct ext4_inode *raw_inode)\n{\n\treturn ((loff_t)le32_to_cpu(raw_inode->i_size_high) << 32) |\n\t\tle32_to_cpu(raw_inode->i_size_lo);", "target": 1}
{"code": "_cdf_tole2(uint16_t sv)\n{\n\tuint16_t rv;\n\tuint8_t *s = (uint8_t *)(void *)&sv;\n\tuint8_t *d = (uint8_t *)(void *)&rv;\n\td[0] = s[1];\n\td[1] = s[0];\n\treturn rv;\n}", "target": 0}
{"code": "static int bson_string_is_db_ref( const unsigned char *string, const int length ) {\n    int result = 0;\n    if( length >= 4 ) {\n        if( string[1] == 'r' && string[2] == 'e' && string[3] == 'f' )\n            result = 1;\n    }\n    else if( length >= 3 ) {\n        if( string[1] == 'i' && string[2] == 'd' )\n            result = 1;\n        else if( string[1] == 'd' && string[2] == 'b' )\n            result = 1;\n    }\n    return result;\n}", "target": 1}
{"code": "SYSCALL_DEFINE3(sched_setattr, pid_t, pid, struct sched_attr __user *, uattr,\n\t\t\t       unsigned int, flags)\n{\n\tstruct sched_attr attr;\n\tstruct task_struct *p;\n\tint retval;\n\tif (!uattr || pid < 0 || flags)\n\t\treturn -EINVAL;\n\tretval = sched_copy_attr(uattr, &attr);\n\tif (retval)\n\t\treturn retval;\n\tif ((int)attr.sched_policy < 0)\n\t\treturn -EINVAL;\n\trcu_read_lock();\n\tretval = -ESRCH;\n\tp = find_process_by_pid(pid);\n\tif (p != NULL)\n\t\tretval = sched_setattr(p, &attr);\n\trcu_read_unlock();\n\treturn retval;\n}", "target": 0}
{"code": "static unsigned char *oidc_cache_hash_passphrase(request_rec *r,\n\t\tconst char *passphrase) {\n\tunsigned char *key = NULL;\n\tunsigned int key_len = 0;\n\toidc_jose_error_t err;\n\tif (oidc_jose_hash_bytes(r->pool, OIDC_JOSE_ALG_SHA256,\n\t\t\t(const unsigned char *) passphrase, strlen(passphrase), &key,\n\t\t\t&key_len, &err) == FALSE) {\n\t\toidc_error(r, \"oidc_jose_hash_bytes returned an error: %s\", err.text);\n\t\treturn NULL;\n\t}\n\treturn key;\n}", "target": 1}
{"code": "void read_user_name(char *name)\n{\n  char *str=getenv(\"USER\");\t\t\n  strmake(name,str ? str : \"ODBC\", USERNAME_LENGTH);\n}", "target": 0}
{"code": "static void alloc_stmt_fields(MYSQL_STMT *stmt)\n{\n  MYSQL_FIELD *fields, *field, *end;\n  MEM_ROOT *fields_mem_root= &stmt->extension->fields_mem_root;\n  MYSQL *mysql= stmt->mysql;\n  DBUG_ASSERT(stmt->field_count);\n  free_root(fields_mem_root, MYF(0));\n  if (!(stmt->fields= (MYSQL_FIELD *) alloc_root(fields_mem_root,\n\t\t\t\t\t\t sizeof(MYSQL_FIELD) *\n\t\t\t\t\t\t stmt->field_count)) ||\n      !(stmt->bind= (MYSQL_BIND *) alloc_root(fields_mem_root,\n\t\t\t\t\t      sizeof(MYSQL_BIND) *\n\t\t\t\t\t      stmt->field_count)))\n  {\n    set_stmt_error(stmt, CR_OUT_OF_MEMORY, unknown_sqlstate, NULL);\n    return;\n  }\n  for (fields= mysql->fields, end= fields+stmt->field_count,\n\t field= stmt->fields;\n       field && fields < end; fields++, field++)\n  {\n    *field= *fields; \n    field->catalog=   strmake_root(fields_mem_root,\n                                   fields->catalog,\n                                   fields->catalog_length);\n    field->db=        strmake_root(fields_mem_root,\n                                   fields->db,\n                                   fields->db_length);\n    field->table=     strmake_root(fields_mem_root,\n                                   fields->table,\n                                   fields->table_length);\n    field->org_table= strmake_root(fields_mem_root,\n                                   fields->org_table,\n                                   fields->org_table_length);\n    field->name=      strmake_root(fields_mem_root,\n                                   fields->name,\n                                   fields->name_length);\n    field->org_name=  strmake_root(fields_mem_root,\n                                   fields->org_name,\n                                   fields->org_name_length);\n    if (fields->def)\n    {\n      field->def= strmake_root(fields_mem_root,\n                               fields->def,\n                               fields->def_length);\n      field->def_length= fields->def_length;\n    }\n    else\n    {\n      field->def= NULL;\n      field->def_length= 0;\n    }\n    field->extension= 0; \n    field->max_length= 0; \n  }\n}", "target": 0}
{"code": "blockmix_salsa8(__m128i * Bin, __m128i * Bout, __m128i * X, size_t r)\n{\n  size_t i;\n  blkcpy(X, &Bin[8 * r - 4], 64);\n  for (i = 0; i < r; i++) {\n    blkxor(X, &Bin[i * 8], 64);\n    salsa20_8(X);\n    blkcpy(&Bout[i * 4], X, 64);\n    blkxor(X, &Bin[i * 8 + 4], 64);\n    salsa20_8(X);\n    blkcpy(&Bout[(r + i) * 4], X, 64);\n  }\n}", "target": 1}
{"code": "static int set_msr_mce(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tu64 mcg_cap = vcpu->arch.mcg_cap;\n\tunsigned bank_num = mcg_cap & 0xff;\n\tswitch (msr) {\n\tcase MSR_IA32_MCG_STATUS:\n\t\tvcpu->arch.mcg_status = data;\n\t\tbreak;\n\tcase MSR_IA32_MCG_CTL:\n\t\tif (!(mcg_cap & MCG_CTL_P))\n\t\t\treturn 1;\n\t\tif (data != 0 && data != ~(u64)0)\n\t\t\treturn -1;\n\t\tvcpu->arch.mcg_ctl = data;\n\t\tbreak;\n\tdefault:\n\t\tif (msr >= MSR_IA32_MC0_CTL &&\n\t\t    msr < MSR_IA32_MCx_CTL(bank_num)) {\n\t\t\tu32 offset = msr - MSR_IA32_MC0_CTL;\n\t\t\tif ((offset & 0x3) == 0 &&\n\t\t\t    data != 0 && (data | (1 << 10)) != ~(u64)0)\n\t\t\t\treturn -1;\n\t\t\tvcpu->arch.mce_banks[offset] = data;\n\t\t\tbreak;\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static void llcp_sock_destruct(struct sock *sk)\n{\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tpr_debug(\"%p\\n\", sk);\n\tif (sk->sk_state == LLCP_CONNECTED)\n\t\tnfc_put_device(llcp_sock->dev);\n\tskb_queue_purge(&sk->sk_receive_queue);\n\tnfc_llcp_sock_free(llcp_sock);\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tpr_err(\"Freeing alive NFC LLCP socket %p\\n\", sk);\n\t\treturn;\n\t}\n}", "target": 0}
{"code": "static JSON_INLINE size_t num_buckets(hashtable_t *hashtable)\n{\n    return primes[hashtable->num_buckets];\n}", "target": 1}
{"code": " MagickExport int LocaleLowercase(const int c)\n {\n #if defined(MAGICKCORE_LOCALE_SUPPORT)\n   if (c_locale != (locale_t) NULL)\n     return(tolower_l((int) ((unsigned char) c),c_locale));\n#endif\n  return(tolower((int) ((unsigned char) c)));\n}", "target": 1}
{"code": "fetch_alt_indirect_string (dwarf_vma offset)\n{\n  separate_info * i;\n  if (! do_follow_links)\n    return \"\";\n  if (first_separate_info == NULL)\n    return _(\"<no links available>\");\n  for (i = first_separate_info; i != NULL; i = i->next)\n    {\n      struct dwarf_section * section;\n      const char *           ret;\n      if (! load_debug_section (separate_debug_str, i->handle))\n\tcontinue;\n      section = &debug_displays [separate_debug_str].section;\n      if (section->start == NULL)\n\tcontinue;\n      if (offset >= section->size)\n\tcontinue;\n      ret = (const char *) (section->start + offset);\n      if (strnlen ((const char *) ret, section->size - offset)\n\t  == section->size - offset)\n\treturn _(\"<no NUL byte at end of alt .debug_str section>\");\n      return ret;\n    }\n  warn (_(\"DW_FORM_GNU_strp_alt offset (%s) too big or no string sections available\\n\"),\n\tdwarf_vmatoa (\"x\", offset));\n  return _(\"<offset is too big>\");\n}", "target": 0}
{"code": "static int audit_match_perm(struct audit_context *ctx, int mask)\n{\n\tunsigned n = ctx->major;\n\tswitch (audit_classify_syscall(ctx->arch, n)) {\n\tcase 0:\t\n\t\tif ((mask & AUDIT_PERM_WRITE) &&\n\t\t     audit_match_class(AUDIT_CLASS_WRITE, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_READ) &&\n\t\t     audit_match_class(AUDIT_CLASS_READ, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_ATTR) &&\n\t\t     audit_match_class(AUDIT_CLASS_CHATTR, n))\n\t\t\treturn 1;\n\t\treturn 0;\n\tcase 1: \n\t\tif ((mask & AUDIT_PERM_WRITE) &&\n\t\t     audit_match_class(AUDIT_CLASS_WRITE_32, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_READ) &&\n\t\t     audit_match_class(AUDIT_CLASS_READ_32, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_ATTR) &&\n\t\t     audit_match_class(AUDIT_CLASS_CHATTR_32, n))\n\t\t\treturn 1;\n\t\treturn 0;\n\tcase 2: \n\t\treturn mask & ACC_MODE(ctx->argv[1]);\n\tcase 3: \n\t\treturn mask & ACC_MODE(ctx->argv[2]);\n\tcase 4: \n\t\treturn ((mask & AUDIT_PERM_WRITE) && ctx->argv[0] == SYS_BIND);\n\tcase 5: \n\t\treturn mask & AUDIT_PERM_EXEC;\n\tdefault:\n\t\treturn 0;\n\t}\n}", "target": 0}
{"code": "luks_unlock_start_waiting_for_cleartext_device (UnlockEncryptionData *data)\n{\n  Device *cleartext_device;\n  cleartext_device = find_cleartext_device (data->device);\n  if (cleartext_device != NULL)\n    {\n      update_info (data->device);\n      drain_pending_changes (data->device, FALSE);\n      if (data->hook_func != NULL)\n        {\n          data->hook_func (data->context, cleartext_device, data->hook_user_data);\n        }\n      else\n        {\n          dbus_g_method_return (data->context, cleartext_device->priv->object_path);\n        }\n      unlock_encryption_data_unref (data);\n    }\n  else\n    {\n      data->device_added_signal_handler_id = g_signal_connect_after (data->device->priv->daemon,\n                                                                     \"device-added\",\n                                                                     (GCallback) luks_unlock_device_added_cb,\n                                                                     data);\n      data->device_changed_signal_handler_id = g_signal_connect_after (data->device->priv->daemon,\n                                                                       \"device-changed\",\n                                                                       (GCallback) luks_unlock_device_added_cb,\n                                                                       data);\n      data->device_added_timeout_id = g_timeout_add (15 * 1000, luks_unlock_device_not_seen_cb, data);\n    }\n}", "target": 0}
{"code": "static int __init memory_tier_init(void)\n{\n\tint ret, node;\n\tstruct memory_tier *memtier;\n\tret = subsys_virtual_register(&memory_tier_subsys, NULL);\n\tif (ret)\n\t\tpanic(\"%s() failed to register memory tier subsystem\\n\", __func__);\n#ifdef CONFIG_MIGRATION\n\tnode_demotion = kcalloc(nr_node_ids, sizeof(struct demotion_nodes),\n\t\t\t\tGFP_KERNEL);\n\tWARN_ON(!node_demotion);\n#endif\n\tmutex_lock(&memory_tier_lock);\n\tdefault_dram_type = alloc_memory_type(MEMTIER_ADISTANCE_DRAM);\n\tif (!default_dram_type)\n\t\tpanic(\"%s() failed to allocate default DRAM tier\\n\", __func__);\n\tfor_each_node_state(node, N_MEMORY) {\n\t\tmemtier = set_node_memory_tier(node);\n\t\tif (IS_ERR(memtier))\n\t\t\tbreak;\n\t}\n\testablish_demotion_targets();\n\tmutex_unlock(&memory_tier_lock);\n\thotplug_memory_notifier(memtier_hotplug_callback, MEMTIER_HOTPLUG_PRI);\n\treturn 0;\n}", "target": 1}
{"code": "zisofs_free(struct archive_write *a)\n{\n\tstruct iso9660 *iso9660 = a->format_data;\n\tint ret = ARCHIVE_OK;\n\tfree(iso9660->zisofs.block_pointers);\n\tif (iso9660->zisofs.stream_valid &&\n\t    deflateEnd(&(iso9660->zisofs.stream)) != Z_OK) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"Failed to clean up compressor\");\n\t\tret = ARCHIVE_FATAL;\n\t}\n\tiso9660->zisofs.block_pointers = NULL;\n\tiso9660->zisofs.stream_valid = 0;\n\treturn (ret);\n}", "target": 0}
{"code": "static dma_addr_t __intel_map_single(struct device *dev, phys_addr_t paddr,\n\t\t\t\t     size_t size, int dir, u64 dma_mask)\n{\n\tstruct dmar_domain *domain;\n\tphys_addr_t start_paddr;\n\tunsigned long iova_pfn;\n\tint prot = 0;\n\tint ret;\n\tstruct intel_iommu *iommu;\n\tunsigned long paddr_pfn = paddr >> PAGE_SHIFT;\n\tBUG_ON(dir == DMA_NONE);\n\tif (iommu_no_mapping(dev))\n\t\treturn paddr;\n\tdomain = get_valid_domain_for_dev(dev);\n\tif (!domain)\n\t\treturn DMA_MAPPING_ERROR;\n\tiommu = domain_get_iommu(domain);\n\tsize = aligned_nrpages(paddr, size);\n\tiova_pfn = intel_alloc_iova(dev, domain, dma_to_mm_pfn(size), dma_mask);\n\tif (!iova_pfn)\n\t\tgoto error;\n\tif (dir == DMA_TO_DEVICE || dir == DMA_BIDIRECTIONAL || \\\n\t\t\t!cap_zlr(iommu->cap))\n\t\tprot |= DMA_PTE_READ;\n\tif (dir == DMA_FROM_DEVICE || dir == DMA_BIDIRECTIONAL)\n\t\tprot |= DMA_PTE_WRITE;\n\tret = domain_pfn_mapping(domain, mm_to_dma_pfn(iova_pfn),\n\t\t\t\t mm_to_dma_pfn(paddr_pfn), size, prot);\n\tif (ret)\n\t\tgoto error;\n\tstart_paddr = (phys_addr_t)iova_pfn << PAGE_SHIFT;\n\tstart_paddr += paddr & ~PAGE_MASK;\n\treturn start_paddr;\nerror:\n\tif (iova_pfn)\n\t\tfree_iova_fast(&domain->iovad, iova_pfn, dma_to_mm_pfn(size));\n\tdev_err(dev, \"Device request: %zx@%llx dir %d --- failed\\n\",\n\t\tsize, (unsigned long long)paddr, dir);\n\treturn DMA_MAPPING_ERROR;\n}", "target": 0}
{"code": "int simple_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error;\n\tif (type == ACL_TYPE_ACCESS) {\n\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\tif (error < 0)\n\t\t\treturn 0;\n\t\tif (error == 0)\n\t\t\tacl = NULL;\n\t}\n\tinode->i_ctime = current_time(inode);\n\tset_cached_acl(inode, type, acl);\n\treturn 0;\n}", "target": 1}
{"code": "bool timerqueue_add(struct timerqueue_head *head, struct timerqueue_node *node)\n{\n\tstruct rb_node **p = &head->head.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct timerqueue_node  *ptr;\n\tWARN_ON_ONCE(!RB_EMPTY_NODE(&node->node));\n\twhile (*p) {\n\t\tparent = *p;\n\t\tptr = rb_entry(parent, struct timerqueue_node, node);\n\t\tif (node->expires < ptr->expires)\n\t\t\tp = &(*p)->rb_left;\n\t\telse\n\t\t\tp = &(*p)->rb_right;\n\t}\n\trb_link_node(&node->node, parent, p);\n\trb_insert_color(&node->node, &head->head);\n\tif (!head->next || node->expires < head->next->expires) {\n\t\thead->next = node;\n\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "bgp_auth_parse (struct peer *peer, u_char *pnt, size_t length)\n{\n  bgp_notify_send (peer, \n\t\t   BGP_NOTIFY_OPEN_ERR, \n\t\t   BGP_NOTIFY_OPEN_AUTH_FAILURE); \n  return -1;\n}", "target": 1}
{"code": "int SafeMulDims(const matvar_t *matvar, size_t* nelems)\n{\n    int i;\n    for ( i = 0; i < matvar->rank; i++ ) {\n        if ( !psnip_safe_size_mul(nelems, *nelems, matvar->dims[i]) ) {\n            *nelems = 0;\n            return 1;\n        }\n    }\n    return 0;\n}", "target": 1}
{"code": "static int io_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_vcpu *vcpu = &svm->vcpu;\n\tu32 io_info = svm->vmcb->control.exit_info_1; \n\tint size, in, string;\n\tunsigned port;\n\t++svm->vcpu.stat.io_exits;\n\tstring = (io_info & SVM_IOIO_STR_MASK) != 0;\n\tin = (io_info & SVM_IOIO_TYPE_MASK) != 0;\n\tif (string || in)\n\t\treturn emulate_instruction(vcpu, 0) == EMULATE_DONE;\n\tport = io_info >> 16;\n\tsize = (io_info & SVM_IOIO_SIZE_MASK) >> SVM_IOIO_SIZE_SHIFT;\n\tsvm->next_rip = svm->vmcb->control.exit_info_2;\n\tskip_emulated_instruction(&svm->vcpu);\n\treturn kvm_fast_pio_out(vcpu, size, port);\n}", "target": 0}
{"code": " int CLASS ljpeg_start (struct jhead *jh, int info_only)\n {\n  int c, tag, len;\n   uchar data[0x10000];\n   const uchar *dp;\n  memset (jh, 0, sizeof *jh);\n  jh->restart = INT_MAX;\n  fread (data, 2, 1, ifp);\n  if (data[1] != 0xd8) return 0;\n  do {\n    fread (data, 2, 2, ifp);\n    tag =  data[0] << 8 | data[1];\n    len = (data[2] << 8 | data[3]) - 2;\n    if (tag <= 0xff00) return 0;\n    fread (data, 1, len, ifp);\n    switch (tag) {\n      case 0xffc3:\n\tjh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;\n      case 0xffc0:\n\tjh->bits = data[0];\n\tjh->high = data[1] << 8 | data[2];\n\tjh->wide = data[3] << 8 | data[4];\n\tjh->clrs = data[5] + jh->sraw;\n\tif (len == 9 && !dng_version) getc(ifp);\n\tbreak;\n      case 0xffc4:\n\tif (info_only) break;\n\tfor (dp = data; dp < data+len && (c = *dp++) < 4; )\n\t  jh->free[c] = jh->huff[c] = make_decoder_ref (&dp);\n\tbreak;\n      case 0xffda:\n\tjh->psv = data[1+data[0]*2];\n\tjh->bits -= data[3+data[0]*2] & 15;\n\tbreak;\n      case 0xffdd:\n\tjh->restart = data[0] << 8 | data[1];\n    }\n  } while (tag != 0xffda);\n  if (info_only) return 1;\n  FORC(5) if (!jh->huff[c+1]) jh->huff[c+1] = jh->huff[c];\n  if (jh->sraw) {\n    FORC(4)        jh->huff[2+c] = jh->huff[1];\n    FORC(jh->sraw) jh->huff[1+c] = jh->huff[0];\n  }\n  jh->row = (ushort *) calloc (jh->wide*jh->clrs, 4);\n  merror (jh->row, \"ljpeg_start()\");\n  return zero_after_ff = 1;\n}", "target": 1}
{"code": "static void prefetch_table(const volatile byte *tab, size_t len)\n{\n  size_t i;\n  for (i = 0; i < len; i += 8 * 32)\n    {\n      (void)tab[i + 0 * 32];\n      (void)tab[i + 1 * 32];\n      (void)tab[i + 2 * 32];\n      (void)tab[i + 3 * 32];\n      (void)tab[i + 4 * 32];\n      (void)tab[i + 5 * 32];\n      (void)tab[i + 6 * 32];\n      (void)tab[i + 7 * 32];\n    }\n  (void)tab[len - 1];\n}", "target": 1}
{"code": "static WERROR dcesrv_DnssrvComplexOperation(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, struct DnssrvComplexOperation *r)\n{\n\tstruct dnsserver_state *dsstate;\n\tstruct dnsserver_zone *z;\n\tWERROR ret;\n\tZERO_STRUCTP(r->out.pdwTypeOut);\n\tZERO_STRUCTP(r->out.ppDataOut);\n\tif ((dsstate = dnsserver_connect(dce_call)) == NULL) {\n\t\treturn WERR_DNS_ERROR_DS_UNAVAILABLE;\n\t}\n\tif (r->in.pszZone == NULL) {\n\t\tret = dnsserver_complex_operate_server(dsstate, mem_ctx,\n\t\t\t\t\t\t\tr->in.pszOperation,\n\t\t\t\t\t\t\tDNS_CLIENT_VERSION_W2K,\n\t\t\t\t\t\t\tr->in.dwTypeIn,\n\t\t\t\t\t\t\t&r->in.pDataIn,\n\t\t\t\t\t\t\tr->out.pdwTypeOut,\n\t\t\t\t\t\t\tr->out.ppDataOut);\n\t} else {\n\t\tz = dnsserver_find_zone(dsstate->zones, r->in.pszZone);\n\t\tif (z == NULL) {\n\t\t\treturn WERR_DNS_ERROR_ZONE_DOES_NOT_EXIST;\n\t\t}\n\t\tret = dnsserver_complex_operate_zone(dsstate, mem_ctx, z,\n\t\t\t\t\t\t\tr->in.pszOperation,\n\t\t\t\t\t\t\tDNS_CLIENT_VERSION_W2K,\n\t\t\t\t\t\t\tr->in.dwTypeIn,\n\t\t\t\t\t\t\t&r->in.pDataIn,\n\t\t\t\t\t\t\tr->out.pdwTypeOut,\n\t\t\t\t\t\t\tr->out.ppDataOut);\n\t}\n\tif (W_ERROR_EQUAL(ret, WERR_CALL_NOT_IMPLEMENTED)) {\n\t\tNDR_PRINT_FUNCTION_DEBUG(DnssrvComplexOperation, NDR_IN, r);\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "struct file *do_file_open_root(struct dentry *dentry, struct vfsmount *mnt,\n\t\tconst char *name, const struct open_flags *op)\n{\n\tstruct nameidata nd;\n\tstruct file *file;\n\tstruct filename filename = { .name = name };\n\tint flags = op->lookup_flags | LOOKUP_ROOT;\n\tnd.root.mnt = mnt;\n\tnd.root.dentry = dentry;\n\tif (dentry->d_inode->i_op->follow_link && op->intent & LOOKUP_OPEN)\n\t\treturn ERR_PTR(-ELOOP);\n\tfile = path_openat(-1, &filename, &nd, op, flags | LOOKUP_RCU);\n\tif (unlikely(file == ERR_PTR(-ECHILD)))\n\t\tfile = path_openat(-1, &filename, &nd, op, flags);\n\tif (unlikely(file == ERR_PTR(-ESTALE)))\n\t\tfile = path_openat(-1, &filename, &nd, op, flags | LOOKUP_REVAL);\n\treturn file;\n}", "target": 0}
{"code": "void Http2Stream::SubmitRstStream(const uint32_t code) {\n  CHECK(!this->is_destroyed());\n  code_ = code;\n  if (session_->is_in_scope() &&\n      !is_writable() && is_reading()) {\n    session_->AddPendingRstStream(id_);\n    return;\n  }\n  if (session_->SendPendingData() != 0) {\n    session_->AddPendingRstStream(id_);\n    return;\n  }\n  FlushRstStream();\n}", "target": 1}
{"code": "CLua::~CLua()\n{\n    const vector<lua_shutdown_listener*> slisteners = shutdown_listeners;\n    for (lua_shutdown_listener *listener : slisteners)\n        listener->shutdown(*this);\n    shutting_down = true;\n    if (_state)\n        lua_close(_state);\n}", "target": 0}
{"code": "static inline pte_t pte_file_mksoft_dirty(pte_t pte)\n{\n       return pte;\n}", "target": 0}
{"code": "int gnutls_x509_ext_import_basic_constraints(const gnutls_datum_t * ext,\n\t\t\t\t\t  unsigned int *ca, int *pathlen)\n{\n\tASN1_TYPE c2 = ASN1_TYPE_EMPTY;\n\tchar str[128]=\"\";\n\tint len, result;\n\tif ((result = asn1_create_element\n\t     (_gnutls_get_pkix(), \"PKIX1.BasicConstraints\",\n\t      &c2)) != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\treturn _gnutls_asn2err(result);\n\t}\n\tresult = asn1_der_decoding(&c2, ext->data, ext->size, NULL);\n\tif (result != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\tresult = _gnutls_asn2err(result);\n\t\tgoto cleanup;\n\t}\n\tif (pathlen) {\n\t\tresult = _gnutls_x509_read_uint(c2, \"pathLenConstraint\",\n\t\t\t\t\t\t(unsigned int *)\n\t\t\t\t\t\tpathlen);\n\t\tif (result == GNUTLS_E_ASN1_ELEMENT_NOT_FOUND)\n\t\t\t*pathlen = -1;\n\t\telse if (result != GNUTLS_E_SUCCESS) {\n\t\t\tgnutls_assert();\n\t\t\tresult = _gnutls_asn2err(result);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tlen = sizeof(str) - 1;\n\tresult = asn1_read_value(c2, \"cA\", str, &len);\n\tif (result == ASN1_SUCCESS && strcmp(str, \"TRUE\") == 0)\n\t\t*ca = 1;\n\telse\n\t\t*ca = 0;\n\tresult = 0;\n cleanup:\n\tasn1_delete_structure(&c2);\n\treturn result;\n}", "target": 0}
{"code": "_eddsa_hash (const struct ecc_modulo *m,\n\t     mp_limb_t *rp, size_t digest_size, const uint8_t *digest)\n{\n  mp_size_t nlimbs = (8*digest_size + GMP_NUMB_BITS - 1) / GMP_NUMB_BITS;\n  mpn_set_base256_le (rp, nlimbs, digest, digest_size);\n  if (nlimbs > 2*m->size)\n    {\n      mp_limb_t hi = rp[2*m->size];\n      assert (nlimbs == 2*m->size + 1);\n      hi = mpn_addmul_1 (rp + m->size, m->B, m->size, hi);\n      assert (hi <= 1);\n      hi = mpn_cnd_add_n (hi, rp + m->size, rp + m->size, m->B, m->size);\n      assert (hi == 0);\n    }\n  m->mod (m, rp, rp);\n}", "target": 1}
{"code": "pci_lintr_assert(struct pci_vdev *dev)\n{\n\tassert(dev->lintr.pin > 0);\n\tpthread_mutex_lock(&dev->lintr.lock);\n\tif (dev->lintr.state == IDLE) {\n\t\tif (pci_lintr_permitted(dev)) {\n\t\t\tdev->lintr.state = ASSERTED;\n\t\t\tpci_irq_assert(dev);\n\t\t} else\n\t\t\tdev->lintr.state = PENDING;\n\t}\n\tpthread_mutex_unlock(&dev->lintr.lock);\n}", "target": 1}
{"code": "DCTStream::DCTStream(Stream *strA, int colorXformA, Dict *dict, int recursion) : FilterStream(strA)\n{\n    colorXform = colorXformA;\n    if (dict != nullptr) {\n        Object obj = dict->lookup(\"Width\", recursion);\n        err.width = (obj.isInt() && obj.getInt() <= JPEG_MAX_DIMENSION) ? obj.getInt() : 0;\n        obj = dict->lookup(\"Height\", recursion);\n        err.height = (obj.isInt() && obj.getInt() <= JPEG_MAX_DIMENSION) ? obj.getInt() : 0;\n    } else\n        err.height = err.width = 0;\n    init();\n}", "target": 0}
{"code": "void ConnectDialog::on_qaUrl_triggered() {\n\tServerItem *si = static_cast<ServerItem *>(qtwServers->currentItem());\n\tif (! si || si->qsUrl.isEmpty())\n\t\treturn;\n\tQDesktopServices::openUrl(QUrl(si->qsUrl));\n}", "target": 1}
{"code": "static irqreturn_t acpi_irq(int irq, void *dev_id)\n{\n\tu32 handled;\n\thandled = (*acpi_irq_handler) (acpi_irq_context);\n\tif (handled) {\n\t\tacpi_irq_handled++;\n\t\treturn IRQ_HANDLED;\n\t} else {\n\t\tacpi_irq_not_handled++;\n\t\treturn IRQ_NONE;\n\t}\n}", "target": 0}
{"code": "SMB2_flush(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\n\t   u64 volatile_fid)\n{\n\tstruct smb_rqst rqst;\n\tstruct smb2_flush_req *req;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov;\n\tint resp_buftype;\n\tint rc = 0;\n\tint flags = 0;\n\tunsigned int total_len;\n\tcifs_dbg(FYI, \"Flush\\n\");\n\tif (!ses || !(ses->server))\n\t\treturn -EIO;\n\trc = smb2_plain_req_init(SMB2_FLUSH, tcon, (void **) &req, &total_len);\n\tif (rc)\n\t\treturn rc;\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\tiov[0].iov_base = (char *)req;\n\tiov[0].iov_len = total_len;\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = 1;\n\trc = cifs_send_recv(xid, ses, &rqst, &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_FLUSH_HE);\n\t\ttrace_smb3_flush_err(xid, persistent_fid, tcon->tid, ses->Suid,\n\t\t\t\t     rc);\n\t}\n\tfree_rsp_buf(resp_buftype, rsp_iov.iov_base);\n\treturn rc;\n}", "target": 0}
{"code": "static void __spin_time_accum(u64 delta, u32 *array)\n{\n\tunsigned index;\n\tindex = ilog2(delta);\n\tcheck_zero();\n\tif (index < HISTO_BUCKETS)\n\t\tarray[index]++;\n\telse\n\t\tarray[HISTO_BUCKETS]++;\n}", "target": 0}
{"code": "PHP_PGSQL_API int php_pgsql_delete(PGconn *pg_link, const char *table, zval *ids_array, zend_ulong opt, zend_string **sql) \n{\n\tzval ids_converted;\n\tsmart_str querystr = {0};\n\tint ret = FAILURE;\n\tassert(pg_link != NULL);\n\tassert(table != NULL);\n\tassert(Z_TYPE_P(ids_array) == IS_ARRAY);\n\tassert(!(opt & ~(PGSQL_CONV_FORCE_NULL|PGSQL_DML_EXEC|PGSQL_DML_STRING|PGSQL_DML_ESCAPE)));\n\tif (zend_hash_num_elements(Z_ARRVAL_P(ids_array)) == 0) {\n\t\treturn FAILURE;\n\t}\n\tZVAL_UNDEF(&ids_converted);\n\tif (!(opt & (PGSQL_DML_NO_CONV|PGSQL_DML_ESCAPE))) {\n\t\tarray_init(&ids_converted);\n\t\tif (php_pgsql_convert(pg_link, table, ids_array, &ids_converted, (opt & PGSQL_CONV_OPTS)) == FAILURE) {\n\t\t\tgoto cleanup;\n\t\t}\n\t\tids_array = &ids_converted;\n\t}\n\tsmart_str_appends(&querystr, \"DELETE FROM \");\n\tbuild_tablename(&querystr, pg_link, table);\n\tsmart_str_appends(&querystr, \" WHERE \");\n\tif (build_assignment_string(pg_link, &querystr, Z_ARRVAL_P(ids_array), 1, \" AND \", sizeof(\" AND \")-1, opt))\n\t\tgoto cleanup;\n\tsmart_str_appendc(&querystr, ';');\n\tsmart_str_0(&querystr);\n\tif ((opt & PGSQL_DML_EXEC) && do_exec(&querystr, PGRES_COMMAND_OK, pg_link, opt) == 0) {\n\t\tret = SUCCESS;\n\t} else if (opt & PGSQL_DML_STRING) {\n\t\tret = SUCCESS;\n\t}\ncleanup:\n\tzval_ptr_dtor(&ids_converted);\n\tif (ret == SUCCESS && (opt & PGSQL_DML_STRING)) {\n\t\t*sql = querystr.s;\n\t}\n\telse {\n\t\tsmart_str_free(&querystr);\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "fmtint(int64 value, char type, int forcesign, int leftjust,\n\t   int minlen, int zpad, int precision, int pointflag,\n\t   PrintfTarget *target)\n{\n\tuint64\t\tbase;\n\tint\t\t\tdosign;\n\tconst char *cvt = \"0123456789abcdef\";\n\tint\t\t\tsignvalue = 0;\n\tchar\t\tconvert[64];\n\tint\t\t\tvallen = 0;\n\tint\t\t\tpadlen = 0;\t\t\n\tint\t\t\tzeropad;\t\t\n\tswitch (type)\n\t{\n\t\tcase 'd':\n\t\tcase 'i':\n\t\t\tbase = 10;\n\t\t\tdosign = 1;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tbase = 8;\n\t\t\tdosign = 0;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tbase = 10;\n\t\t\tdosign = 0;\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\tbase = 16;\n\t\t\tdosign = 0;\n\t\t\tbreak;\n\t\tcase 'X':\n\t\t\tcvt = \"0123456789ABCDEF\";\n\t\t\tbase = 16;\n\t\t\tdosign = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\t\t\t\t\n\t}\n\tif (dosign && adjust_sign((value < 0), forcesign, &signvalue))\n\t\tvalue = -value;\n\tif (value == 0 && pointflag && precision == 0)\n\t\tvallen = 0;\n\telse\n\t{\n\t\tuint64\t\tuvalue = (uint64) value;\n\t\tdo\n\t\t{\n\t\t\tconvert[vallen++] = cvt[uvalue % base];\n\t\t\tuvalue = uvalue / base;\n\t\t} while (uvalue);\n\t}\n\tzeropad = Max(0, precision - vallen);\n\tadjust_padlen(minlen, vallen + zeropad, leftjust, &padlen);\n\tleading_pad(zpad, &signvalue, &padlen, target);\n\twhile (zeropad-- > 0)\n\t\tdopr_outch('0', target);\n\twhile (vallen > 0)\n\t\tdopr_outch(convert[--vallen], target);\n\ttrailing_pad(&padlen, target);\n}", "target": 0}
{"code": "static int ext4_get_block_write(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create)\n{\n\thandle_t *handle = NULL;\n\tint ret = 0;\n\tunsigned max_blocks = bh_result->b_size >> inode->i_blkbits;\n\tint dio_credits;\n\text4_debug(\"ext4_get_block_write: inode %lu, create flag %d\\n\",\n\t\t   inode->i_ino, create);\n\tcreate = EXT4_GET_BLOCKS_IO_CREATE_EXT;\n\tif (max_blocks > DIO_MAX_BLOCKS)\n\t\tmax_blocks = DIO_MAX_BLOCKS;\n\tdio_credits = ext4_chunk_trans_blocks(inode, max_blocks);\n\thandle = ext4_journal_start(inode, dio_credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto out;\n\t}\n\tret = ext4_get_blocks(handle, inode, iblock, max_blocks, bh_result,\n\t\t\t      create);\n\tif (ret > 0) {\n\t\tbh_result->b_size = (ret << inode->i_blkbits);\n\t\tret = 0;\n\t}\n\text4_journal_stop(handle);\nout:\n\treturn ret;\n}", "target": 1}
{"code": "resp_new (const char *head)\n{\n  const char *hdr;\n  int count, size;\n  struct response *resp = xnew0 (struct response);\n  resp->data = head;\n  if (*head == '\\0')\n    {\n      return resp;\n    }\n  size = count = 0;\n  hdr = head;\n  while (1)\n    {\n      DO_REALLOC (resp->headers, size, count + 1, const char *);\n      resp->headers[count++] = hdr;\n      if (!hdr[0] || (hdr[0] == '\\r' && hdr[1] == '\\n') || hdr[0] == '\\n')\n        break;\n      do\n        {\n          const char *end = strchr (hdr, '\\n');\n          if (end)\n            hdr = end + 1;\n          else\n            hdr += strlen (hdr);\n        }\n      while (*hdr == ' ' || *hdr == '\\t');\n    }\n  DO_REALLOC (resp->headers, size, count + 1, const char *);\n  resp->headers[count] = NULL;\n  return resp;\n}", "target": 1}
{"code": "static StkId rethook (lua_State *L, CallInfo *ci, StkId firstres, int nres) {\n  ptrdiff_t oldtop = savestack(L, L->top);  \n  int delta = 0;\n  if (isLuacode(ci)) {\n    Proto *p = clLvalue(s2v(ci->func))->p;\n    if (p->is_vararg)\n      delta = ci->u.l.nextraargs + p->numparams + 1;\n    if (L->top < ci->top)\n      L->top = ci->top;  \n  }\n  if (L->hookmask & LUA_MASKRET) {  \n    int ftransfer;\n    ci->func += delta;  \n    ftransfer = cast(unsigned short, firstres - ci->func);\n    luaD_hook(L, LUA_HOOKRET, -1, ftransfer, nres);  \n    ci->func -= delta;\n  }\n  if (isLua(ci->previous))\n    L->oldpc = ci->previous->u.l.savedpc;  \n  return restorestack(L, oldtop);\n}", "target": 1}
{"code": "Eina_Bool ewk_view_setting_caret_browsing_set(Evas_Object* ewkView, Eina_Bool enable)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv, false);\n    enable = !!enable;\n    if (priv->settings.caretBrowsing != enable) {\n        priv->pageSettings->setCaretBrowsingEnabled(enable);\n        priv->settings.caretBrowsing = enable;\n    }\n    return true;\n}", "target": 0}
{"code": "static int snd_disconnect_release(struct inode *inode, struct file *file)\n{\n\tstruct snd_monitor_file *df = NULL, *_df;\n\tspin_lock(&shutdown_lock);\n\tlist_for_each_entry(_df, &shutdown_files, shutdown_list) {\n\t\tif (_df->file == file) {\n\t\t\tdf = _df;\n\t\t\tlist_del_init(&df->shutdown_list);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&shutdown_lock);\n\tif (likely(df)) {\n\t\tif ((file->f_flags & FASYNC) && df->disconnected_f_op->fasync)\n\t\t\tdf->disconnected_f_op->fasync(-1, file, 0);\n\t\treturn df->disconnected_f_op->release(inode, file);\n\t}\n\tpanic(\"%s(%p, %p) failed!\", __func__, inode, file);\n}", "target": 0}
{"code": "get_cdtext_generic (void *p_user_data)\n{\n  generic_img_private_t *p_env = p_user_data;\n  uint8_t *p_cdtext_data = NULL;\n  size_t  len;\n  if (!p_env) return NULL;\n  if (p_env->b_cdtext_error) return NULL;\n  if (NULL == p_env->cdtext) {\n    p_cdtext_data = read_cdtext_generic (p_env);\n    if (NULL != p_cdtext_data) {\n      len = CDIO_MMC_GET_LEN16(p_cdtext_data)-2;\n      p_env->cdtext = cdtext_init();\n      if(len <= 0 || 0 != cdtext_data_init (p_env->cdtext, &p_cdtext_data[4], len)) {\n        p_env->b_cdtext_error = true;\n        free(p_env->cdtext);\n        p_env->cdtext = NULL;\n      }\n      free(p_cdtext_data);\n    }\n  }\n  return p_env->cdtext;\n}", "target": 1}
{"code": "void MultiplySum(const size_t xsize,\n                 const pixel_type* const JXL_RESTRICT row_in,\n                 const pixel_type* const JXL_RESTRICT row_in_Y,\n                 const float factor, float* const JXL_RESTRICT row_out) {\n  const HWY_FULL(float) df;\n  const Rebind<pixel_type, HWY_FULL(float)> di;  \n  const auto factor_v = Set(df, factor);\n  for (size_t x = 0; x < xsize; x += Lanes(di)) {\n    const auto in = Load(di, row_in + x) + Load(di, row_in_Y + x);\n    const auto out = ConvertTo(df, in) * factor_v;\n    Store(out, df, row_out + x);\n  }\n}", "target": 0}
{"code": "int regset_tls_set(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count,\n\t\t   const void *kbuf, const void __user *ubuf)\n{\n\tstruct user_desc infobuf[GDT_ENTRY_TLS_ENTRIES];\n\tconst struct user_desc *info;\n\tint i;\n\tif (pos >= GDT_ENTRY_TLS_ENTRIES * sizeof(struct user_desc) ||\n\t    (pos % sizeof(struct user_desc)) != 0 ||\n\t    (count % sizeof(struct user_desc)) != 0)\n\t\treturn -EINVAL;\n\tif (kbuf)\n\t\tinfo = kbuf;\n\telse if (__copy_from_user(infobuf, ubuf, count))\n\t\treturn -EFAULT;\n\telse\n\t\tinfo = infobuf;\n\tfor (i = 0; i < count / sizeof(struct user_desc); i++)\n\t\tif (!tls_desc_okay(info + i))\n\t\t\treturn -EINVAL;\n\tset_tls_desc(target,\n\t\t     GDT_ENTRY_TLS_MIN + (pos / sizeof(struct user_desc)),\n\t\t     info, count / sizeof(struct user_desc));\n\treturn 0;\n}", "target": 0}
{"code": "TEE_Result crypto_acipher_alloc_dsa_keypair(struct dsa_keypair *s,\n\t\t\t\t\t    size_t key_size_bits __unused)\n{\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->g))\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tif (!bn_alloc_max(&s->p))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->q))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->y))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->x))\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(s->g);\n\tcrypto_bignum_free(s->p);\n\tcrypto_bignum_free(s->q);\n\tcrypto_bignum_free(s->y);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "static u32 rd_release_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,\n\t\t\t\t u32 sg_table_count)\n{\n\tstruct page *pg;\n\tstruct scatterlist *sg;\n\tu32 i, j, page_count = 0, sg_per_table;\n\tfor (i = 0; i < sg_table_count; i++) {\n\t\tsg = sg_table[i].sg_table;\n\t\tsg_per_table = sg_table[i].rd_sg_count;\n\t\tfor (j = 0; j < sg_per_table; j++) {\n\t\t\tpg = sg_page(&sg[j]);\n\t\t\tif (pg) {\n\t\t\t\t__free_page(pg);\n\t\t\t\tpage_count++;\n\t\t\t}\n\t\t}\n\t\tkfree(sg);\n\t}\n\tkfree(sg_table);\n\treturn page_count;\n}", "target": 0}
{"code": "static char *make_filename_safe(const char *filename TSRMLS_DC)\n{\n\tif (*filename && strncmp(filename, \":memory:\", sizeof(\":memory:\")-1)) {\n\t\tchar *fullpath = expand_filepath(filename, NULL TSRMLS_CC);\n\t\tif (!fullpath) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (PG(safe_mode) && (!php_checkuid(fullpath, NULL, CHECKUID_CHECK_FILE_AND_DIR))) {\n\t\t\tefree(fullpath);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (php_check_open_basedir(fullpath TSRMLS_CC)) {\n\t\t\tefree(fullpath);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn fullpath;\n\t}\n\treturn estrdup(filename);\n}", "target": 1}
{"code": "SSLNetVConnection::select_next_protocol(SSL *ssl, const unsigned char **out, unsigned char *outlen,\n                                        const unsigned char *in ATS_UNUSED, unsigned inlen ATS_UNUSED, void *)\n{\n  SSLNetVConnection *netvc = SSLNetVCAccess(ssl);\n  const unsigned char *npn = nullptr;\n  unsigned npnsz           = 0;\n  ink_release_assert(netvc != nullptr);\n  if (netvc->npnSet && netvc->npnSet->advertiseProtocols(&npn, &npnsz)) {\n#if HAVE_SSL_SELECT_NEXT_PROTO\n    if (SSL_select_next_proto((unsigned char **)out, outlen, npn, npnsz, in, inlen) == OPENSSL_NPN_NEGOTIATED) {\n      Debug(\"ssl\", \"selected ALPN protocol %.*s\", (int)(*outlen), *out);\n      return SSL_TLSEXT_ERR_OK;\n    }\n#endif \n  }\n  *out    = nullptr;\n  *outlen = 0;\n  return SSL_TLSEXT_ERR_NOACK;\n}", "target": 0}
{"code": "find_extend_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma, *prev;\n\taddr &= PAGE_MASK;\n\tvma = find_vma_prev(mm, addr, &prev);\n\tif (vma && (vma->vm_start <= addr))\n\t\treturn vma;\n\tif (!prev || expand_stack(prev, addr))\n\t\treturn NULL;\n\tif (prev->vm_flags & VM_LOCKED)\n\t\tmake_pages_present(addr, prev->vm_end);\n\treturn prev;\n}", "target": 0}
{"code": "    void PsdImage::readMetadata()\n    {\n#ifdef DEBUG\n        std::cerr << \"Exiv2::PsdImage::readMetadata: Reading Photoshop file \" << io_->path() << \"\\n\";\n#endif\n        if (io_->open() != 0)\n        {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        if (!isPsdType(*io_, false))\n        {\n            if (io_->error() || io_->eof()) throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n        clearMetadata();\n        byte buf[26];\n        if (io_->read(buf, 26) != 26)\n        {\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n        pixelWidth_ = getLong(buf + 18, bigEndian);\n        pixelHeight_ = getLong(buf + 14, bigEndian);\n        if (io_->read(buf, 4) != 4)\n        {\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n        uint32_t colorDataLength = getULong(buf, bigEndian);\n        if (io_->seek(colorDataLength, BasicIo::cur))\n        {\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n        if (io_->read(buf, 4) != 4)\n        {\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n        uint32_t resourcesLength = getULong(buf, bigEndian);\n        while (resourcesLength > 0)\n        {\n            if (io_->read(buf, 8) != 8)\n            {\n                throw Error(kerNotAnImage, \"Photoshop\");\n            }\n            if (!Photoshop::isIrb(buf, 4))\n            {\n                break; \n            }\n            uint16_t resourceId = getUShort(buf + 4, bigEndian);\n            uint32_t resourceNameLength = buf[6] & ~1;\n            io_->seek(resourceNameLength, BasicIo::cur);\n            if (io_->read(buf, 4) != 4)\n            {\n                throw Error(kerNotAnImage, \"Photoshop\");\n            }\n            uint32_t resourceSize = getULong(buf, bigEndian);\n            uint32_t curOffset = io_->tell();\n#ifdef DEBUG\n        std::cerr << std::hex << \"resourceId: \" << resourceId << std::dec << \" length: \" << resourceSize << std::hex << \"\\n\";\n#endif\n            readResourceBlock(resourceId, resourceSize);\n            resourceSize = (resourceSize + 1) & ~1;        \n            io_->seek(curOffset + resourceSize, BasicIo::beg);\n            resourcesLength -= Safe::add(Safe::add(static_cast<uint32_t>(12), resourceNameLength),\n                                         resourceSize);\n        }\n    } ", "target": 1}
{"code": "unsigned FAST_FUNC udhcp_option_idx(const char *name)\n{\n\tint n = index_in_strings(dhcp_option_strings, name);\n\tif (n >= 0)\n\t\treturn n;\n\t{\n\t\tchar buf[sizeof(dhcp_option_strings)];\n\t\tchar *d = buf;\n\t\tconst char *s = dhcp_option_strings;\n\t\twhile (s < dhcp_option_strings + sizeof(dhcp_option_strings) - 2) {\n\t\t\t*d++ = (*s == '\\0' ? ' ' : *s);\n\t\t\ts++;\n\t\t}\n\t\t*d = '\\0';\n\t\tbb_error_msg_and_die(\"unknown option '%s', known options: %s\", name, buf);\n\t}\n}", "target": 0}
{"code": "struct key *rxrpc_get_null_key(const char *keyname)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct key *key;\n\tint ret;\n\tkey = key_alloc(&key_type_rxrpc, keyname,\n\t\t\tGLOBAL_ROOT_UID, GLOBAL_ROOT_GID, cred,\n\t\t\tKEY_POS_SEARCH, KEY_ALLOC_NOT_IN_QUOTA);\n\tif (IS_ERR(key))\n\t\treturn key;\n\tret = key_instantiate_and_link(key, NULL, 0, NULL, NULL);\n\tif (ret < 0) {\n\t\tkey_revoke(key);\n\t\tkey_put(key);\n\t\treturn ERR_PTR(ret);\n\t}\n\treturn key;\n}", "target": 0}
{"code": "HttpStateData::getMoreRequestBody(MemBuf &buf)\n{\n    if (!flags.chunked_request)\n        return Client::getMoreRequestBody(buf);\n    MemBuf raw;\n    Must(requestBodySource != NULL);\n    if (!requestBodySource->getMoreData(raw))\n        return false; \n    const mb_size_t rawDataSize = raw.contentSize();\n    buf.init(16 + 2 + rawDataSize + 2 + 5, raw.max_capacity);\n    buf.appendf(\"%x\\r\\n\", static_cast<unsigned int>(rawDataSize));\n    buf.append(raw.content(), rawDataSize);\n    buf.append(\"\\r\\n\", 2);\n    Must(rawDataSize > 0); \n    if (receivedWholeRequestBody) {\n        Must(!flags.sentLastChunk);\n        flags.sentLastChunk = true;\n        buf.append(\"0\\r\\n\\r\\n\", 5);\n    }\n    return true;\n}", "target": 0}
{"code": "const FieldID& activeUnionMemberId(const void* object, ptrdiff_t offset) {\n  return *reinterpret_cast<const FieldID*>(\n      offset + static_cast<const char*>(object));\n}", "target": 1}
{"code": "static int timer_start(Unit *u) {\n        Timer *t = TIMER(u);\n        TimerValue *v;\n        assert(t);\n        assert(t->state == TIMER_DEAD || t->state == TIMER_FAILED);\n        if (UNIT_TRIGGER(u)->load_state != UNIT_LOADED)\n                return -ENOENT;\n        t->last_trigger = DUAL_TIMESTAMP_NULL;\n        LIST_FOREACH(value, v, t->values)\n                if (v->base == TIMER_ACTIVE)\n                        v->disabled = false;\n        if (t->stamp_path) {\n                struct stat st;\n                if (stat(t->stamp_path, &st) >= 0)\n                        t->last_trigger.realtime = timespec_load(&st.st_atim);\n                else if (errno == ENOENT)\n                        touch_file(t->stamp_path, true, USEC_INFINITY, UID_INVALID, GID_INVALID, 0);\n        }\n        t->result = TIMER_SUCCESS;\n        timer_enter_waiting(t, true);\n        return 1;\n}", "target": 1}
{"code": "static inline key_ref_t __key_update(key_ref_t key_ref,\n\t\t\t\t     struct key_preparsed_payload *prep)\n{\n\tstruct key *key = key_ref_to_ptr(key_ref);\n\tint ret;\n\tret = key_permission(key_ref, KEY_NEED_WRITE);\n\tif (ret < 0)\n\t\tgoto error;\n\tret = -EEXIST;\n\tif (!key->type->update)\n\t\tgoto error;\n\tdown_write(&key->sem);\n\tret = key->type->update(key, prep);\n\tif (ret == 0)\n\t\tclear_bit(KEY_FLAG_NEGATIVE, &key->flags);\n\tup_write(&key->sem);\n\tif (ret < 0)\n\t\tgoto error;\nout:\n\treturn key_ref;\nerror:\n\tkey_put(key);\n\tkey_ref = ERR_PTR(ret);\n\tgoto out;\n}", "target": 1}
{"code": "GBool Splash::pathAllOutside(SplashPath *path) {\n  SplashCoord xMin1, yMin1, xMax1, yMax1;\n  SplashCoord xMin2, yMin2, xMax2, yMax2;\n  SplashCoord x, y;\n  int xMinI, yMinI, xMaxI, yMaxI;\n  int i;\n  xMin1 = xMax1 = path->pts[0].x;\n  yMin1 = yMax1 = path->pts[0].y;\n  for (i = 1; i < path->length; ++i) {\n    if (path->pts[i].x < xMin1) {\n      xMin1 = path->pts[i].x;\n    } else if (path->pts[i].x > xMax1) {\n      xMax1 = path->pts[i].x;\n    }\n    if (path->pts[i].y < yMin1) {\n      yMin1 = path->pts[i].y;\n    } else if (path->pts[i].y > yMax1) {\n      yMax1 = path->pts[i].y;\n    }\n  }\n  transform(state->matrix, xMin1, yMin1, &x, &y);\n  xMin2 = xMax2 = x;\n  yMin2 = yMax2 = y;\n  transform(state->matrix, xMin1, yMax1, &x, &y);\n  if (x < xMin2) {\n    xMin2 = x;\n  } else if (x > xMax2) {\n    xMax2 = x;\n  }\n  if (y < yMin2) {\n    yMin2 = y;\n  } else if (y > yMax2) {\n    yMax2 = y;\n  }\n  transform(state->matrix, xMax1, yMin1, &x, &y);\n  if (x < xMin2) {\n    xMin2 = x;\n  } else if (x > xMax2) {\n    xMax2 = x;\n  }\n  if (y < yMin2) {\n    yMin2 = y;\n  } else if (y > yMax2) {\n    yMax2 = y;\n  }\n  transform(state->matrix, xMax1, yMax1, &x, &y);\n  if (x < xMin2) {\n    xMin2 = x;\n  } else if (x > xMax2) {\n    xMax2 = x;\n  }\n  if (y < yMin2) {\n    yMin2 = y;\n  } else if (y > yMax2) {\n    yMax2 = y;\n  }\n  xMinI = splashFloor(xMin2);\n  yMinI = splashFloor(yMin2);\n  xMaxI = splashFloor(xMax2);\n  yMaxI = splashFloor(yMax2);\n  return state->clip->testRect(xMinI, yMinI, xMaxI, yMaxI) ==\n         splashClipAllOutside;\n}", "target": 0}
{"code": "hash_findi_add(struct hash_table *hash, const char *str)\n{\n    struct hash_insert hi;\n    void **r;\n    char *strx;\n    size_t l = strlen(str) + 1;\n    r = hash_findib(hash, str, l, &hi);\n    if (r)\n        return r;\n    strx = nasm_malloc(l);  \n    memcpy(strx, str, l);\n    return hash_add(&hi, strx, NULL);\n}", "target": 0}
{"code": "cursor_up(\n    long\tn,\n    int\t\tupd_topline)\t    \n{\n    linenr_T\tlnum;\n    if (n > 0)\n    {\n\tlnum = curwin->w_cursor.lnum;\n\tif (lnum <= 1 || (n >= lnum && vim_strchr(p_cpo, CPO_MINUS) != NULL))\n\t    return FAIL;\n\tif (n >= lnum)\n\t    lnum = 1;\n\telse\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t{\n\t    (void)hasFolding(lnum, &lnum, NULL);\n\t    while (n--)\n\t    {\n\t\t--lnum;\n\t\tif (lnum <= 1)\n\t\t    break;\n\t\tif (n > 0 || !((State & INSERT) || (fdo_flags & FDO_ALL)))\n\t\t    (void)hasFolding(lnum, &lnum, NULL);\n\t    }\n\t    if (lnum < 1)\n\t\tlnum = 1;\n\t}\n\telse\n#endif\n\t    lnum -= n;\n\tcurwin->w_cursor.lnum = lnum;\n    }\n    coladvance(curwin->w_curswant);\n    if (upd_topline)\n\tupdate_topline();\t\n    return OK;\n}", "target": 0}
{"code": "static inline long div_long_long_rem_signed(const long long dividend,\n\t\t\t\t\t    const long divisor, long *remainder)\n{\n\tlong res;\n\tif (unlikely(dividend < 0)) {\n\t\tres = -div_long_long_rem(-dividend, divisor, remainder);\n\t\t*remainder = -(*remainder);\n\t} else\n\t\tres = div_long_long_rem(dividend, divisor, remainder);\n\treturn res;\n}", "target": 1}
{"code": "static void copy_fields(const FieldMatchContext *fm, AVFrame *dst,\n                        const AVFrame *src, int field)\n{\n    int plane;\n    for (plane = 0; plane < 4 && src->data[plane]; plane++)\n        av_image_copy_plane(dst->data[plane] + field*dst->linesize[plane], dst->linesize[plane] << 1,\n                            src->data[plane] + field*src->linesize[plane], src->linesize[plane] << 1,\n                            get_width(fm, src, plane), get_height(fm, src, plane) / 2);\n}", "target": 1}
{"code": "populate_lr_context(struct intel_context *ce,\n\t\t    struct drm_i915_gem_object *ctx_obj,\n\t\t    struct intel_engine_cs *engine,\n\t\t    struct intel_ring *ring)\n{\n\tbool inhibit = true;\n\tvoid *vaddr;\n\tu32 *regs;\n\tint ret;\n\tvaddr = i915_gem_object_pin_map(ctx_obj, I915_MAP_WB);\n\tif (IS_ERR(vaddr)) {\n\t\tret = PTR_ERR(vaddr);\n\t\tDRM_DEBUG_DRIVER(\"Could not map object pages! (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tset_redzone(vaddr, engine);\n\tif (engine->default_state) {\n\t\tvoid *defaults;\n\t\tdefaults = i915_gem_object_pin_map(engine->default_state,\n\t\t\t\t\t\t   I915_MAP_WB);\n\t\tif (IS_ERR(defaults)) {\n\t\t\tret = PTR_ERR(defaults);\n\t\t\tgoto err_unpin_ctx;\n\t\t}\n\t\tmemcpy(vaddr, defaults, engine->context_size);\n\t\ti915_gem_object_unpin_map(engine->default_state);\n\t\tinhibit = false;\n\t}\n\tregs = vaddr + LRC_STATE_PN * PAGE_SIZE;\n\texeclists_init_reg_state(regs, ce, engine, ring, inhibit);\n\tif (inhibit)\n\t\tregs[CTX_CONTEXT_CONTROL] |=\n\t\t\t_MASKED_BIT_ENABLE(CTX_CTRL_ENGINE_CTX_RESTORE_INHIBIT);\n\tret = 0;\nerr_unpin_ctx:\n\t__i915_gem_object_flush_map(ctx_obj, 0, engine->context_size);\n\ti915_gem_object_unpin_map(ctx_obj);\n\treturn ret;\n}", "target": 0}
{"code": "isdn_ppp_poll(struct file *file, poll_table *wait)\n{\n\tu_int mask;\n\tstruct ippp_buf_queue *bf, *bl;\n\tu_long flags;\n\tstruct ippp_struct *is;\n\tis = file->private_data;\n\tif (is->debug & 0x2)\n\t\tprintk(KERN_DEBUG \"isdn_ppp_poll: minor: %d\\n\",\n\t\t       iminor(file_inode(file)));\n\tpoll_wait(file, &is->wq, wait);\n\tif (!(is->state & IPPP_OPEN)) {\n\t\tif (is->state == IPPP_CLOSEWAIT)\n\t\t\treturn POLLHUP;\n\t\tprintk(KERN_DEBUG \"isdn_ppp: device not open\\n\");\n\t\treturn POLLERR;\n\t}\n\tmask = POLLOUT | POLLWRNORM;\n\tspin_lock_irqsave(&is->buflock, flags);\n\tbl = is->last;\n\tbf = is->first;\n\tif (bf->next != bl || (is->state & IPPP_NOBLOCK)) {\n\t\tis->state &= ~IPPP_NOBLOCK;\n\t\tmask |= POLLIN | POLLRDNORM;\n\t}\n\tspin_unlock_irqrestore(&is->buflock, flags);\n\treturn mask;\n}", "target": 0}
{"code": "parse_notification(struct rpki_uri *uri, struct update_notification **file)\n{\n\tstruct rdr_notification_ctx ctx;\n\tstruct update_notification *tmp;\n\tchar *dup;\n\tint error;\n\tdup = strdup(uri_get_global(uri));\n\tif (dup == NULL)\n\t\treturn pr_enomem();\n\terror = update_notification_create(&tmp);\n\tif (error)\n\t\treturn error;\n\ttmp->uri = dup;\n\tctx.notification = tmp;\n\terror = relax_ng_parse(uri_get_local(uri), xml_read_notification,\n\t    &ctx);\n\tif (error) {\n\t\tupdate_notification_destroy(tmp);\n\t\treturn error;\n\t}\n\t*file = tmp;\n\treturn 0;\n}", "target": 1}
{"code": "int is_ntfs_dotgit(const char *name)\n{\n\tint len;\n\tfor (len = 0; ; len++)\n\t\tif (!name[len] || name[len] == '\\\\' || is_dir_sep(name[len])) {\n\t\t\tif (only_spaces_and_periods(name, len, 4) &&\n\t\t\t\t\t!strncasecmp(name, \".git\", 4))\n\t\t\t\treturn 1;\n\t\t\tif (only_spaces_and_periods(name, len, 5) &&\n\t\t\t\t\t!strncasecmp(name, \"git~1\", 5))\n\t\t\t\treturn 1;\n\t\t\tif (name[len] != '\\\\')\n\t\t\t\treturn 0;\n\t\t\tname += len + 1;\n\t\t\tlen = -1;\n\t\t}\n}", "target": 1}
{"code": "static void free_pcppages_bulk(struct zone *zone, int count,\n\t\t\t\t\tstruct per_cpu_pages *pcp)\n{\n\tint migratetype = 0;\n\tint batch_free = 0;\n\tbool isolated_pageblocks;\n\tspin_lock(&zone->lock);\n\tisolated_pageblocks = has_isolate_pageblock(zone);\n\twhile (count) {\n\t\tstruct page *page;\n\t\tstruct list_head *list;\n\t\tdo {\n\t\t\tbatch_free++;\n\t\t\tif (++migratetype == MIGRATE_PCPTYPES)\n\t\t\t\tmigratetype = 0;\n\t\t\tlist = &pcp->lists[migratetype];\n\t\t} while (list_empty(list));\n\t\tif (batch_free == MIGRATE_PCPTYPES)\n\t\t\tbatch_free = count;\n\t\tdo {\n\t\t\tint mt;\t\n\t\t\tpage = list_last_entry(list, struct page, lru);\n\t\t\tlist_del(&page->lru);\n\t\t\tmt = get_pcppage_migratetype(page);\n\t\t\tVM_BUG_ON_PAGE(is_migrate_isolate(mt), page);\n\t\t\tif (unlikely(isolated_pageblocks))\n\t\t\t\tmt = get_pageblock_migratetype(page);\n\t\t\tif (bulkfree_pcp_prepare(page))\n\t\t\t\tcontinue;\n\t\t\t__free_one_page(page, page_to_pfn(page), zone, 0, mt);\n\t\t\ttrace_mm_page_pcpu_drain(page, 0, mt);\n\t\t} while (--count && --batch_free && !list_empty(list));\n\t}\n\tspin_unlock(&zone->lock);\n}", "target": 0}
{"code": " */\nint re_yyget_lineno  (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n        if (! YY_CURRENT_BUFFER)\n            return 0;\n    return yylineno;", "target": 1}
{"code": "static int cp2112_gpio_get_all(struct gpio_chip *chip)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tunsigned long flags;\n\tint ret;\n\tspin_lock_irqsave(&dev->lock, flags);\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_GET, buf,\n\t\t\t\t CP2112_GPIO_GET_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_GET_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO values: %d\\n\", ret);\n\t\tret = ret < 0 ? ret : -EIO;\n\t\tgoto exit;\n\t}\n\tret = buf[1];\nexit:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\treturn ret;\n}", "target": 1}
{"code": "void big_key_describe(const struct key *key, struct seq_file *m)\n{\n\tsize_t datalen = (size_t)key->payload.data[big_key_len];\n\tseq_puts(m, key->description);\n\tif (key_is_instantiated(key))\n\t\tseq_printf(m, \": %zu [%s]\",\n\t\t\t   datalen,\n\t\t\t   datalen > BIG_KEY_FILE_THRESHOLD ? \"file\" : \"buff\");\n}", "target": 1}
{"code": "void WasmBinaryBuilder::readGlobals() {\n  BYN_TRACE(\"== readGlobals\\n\");\n  size_t num = getU32LEB();\n  BYN_TRACE(\"num: \" << num << std::endl);\n  for (size_t i = 0; i < num; i++) {\n    BYN_TRACE(\"read one\\n\");\n    auto type = getConcreteType();\n    auto mutable_ = getU32LEB();\n    if (mutable_ & ~1) {\n      throwError(\"Global mutability must be 0 or 1\");\n    }\n    auto* init = readExpression();\n    globals.push_back(\n      Builder::makeGlobal(\"global$\" + std::to_string(i),\n                          type,\n                          init,\n                          mutable_ ? Builder::Mutable : Builder::Immutable));\n  }\n}", "target": 0}
{"code": "TEST_F(QuantizeDownAndShrinkRangeTest, HandCrafted) {\n  TF_ASSERT_OK(NodeDefBuilder(\"quantize_down_and_shrink_range_op\",\n                              \"QuantizeDownAndShrinkRange\")\n                   .Input(FakeInput(DT_QINT32))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Attr(\"Tinput\", DataTypeToEnum<qint32>::v())\n                   .Attr(\"out_type\", DataTypeToEnum<quint8>::v())\n                   .Finalize(node_def()));\n  TF_ASSERT_OK(InitOp());\n  const int value_count = 3;\n  AddInputFromArray<qint32>(TensorShape({value_count}),\n                            {-(1 << 23), 0, (1 << 23)});\n  AddInputFromArray<float>(TensorShape({1}), {-256.0f});\n  AddInputFromArray<float>(TensorShape({1}), {256.0f});\n  TF_ASSERT_OK(RunOpKernel());\n  Tensor expected(allocator(), DT_QUINT8, TensorShape({value_count}));\n  test::FillValues<quint8>(&expected, {0, 128, 255});\n  test::ExpectTensorEqual<quint8>(expected, *GetOutput(0));\n  Tensor expected_min(allocator(), DT_FLOAT, TensorShape({}));\n  test::FillValues<float>(&expected_min, {-1.0f});\n  test::ExpectTensorEqual<float>(expected_min, *GetOutput(1));\n  Tensor expected_max(allocator(), DT_FLOAT, TensorShape({}));\n  test::FillValues<float>(&expected_max, {1.0f});\n  test::ExpectTensorEqual<float>(expected_max, *GetOutput(2));\n}", "target": 1}
{"code": "GF_Err stbl_AppendTime(GF_SampleTableBox *stbl, u32 duration, u32 nb_pack)\n{\n\tGF_TimeToSampleBox *stts = stbl->TimeToSample;\n\tif (!nb_pack) nb_pack = 1;\n\tif (stts->nb_entries) {\n\t\tif (stts->entries[stts->nb_entries-1].sampleDelta == duration) {\n\t\t\tstts->entries[stts->nb_entries-1].sampleCount += nb_pack;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\tif (stts->nb_entries==stts->alloc_size) {\n\t\tALLOC_INC(stts->alloc_size);\n\t\tstts->entries = gf_realloc(stts->entries, sizeof(GF_SttsEntry)*stts->alloc_size);\n\t\tif (!stts->entries) return GF_OUT_OF_MEM;\n\t\tmemset(&stts->entries[stts->nb_entries], 0, sizeof(GF_SttsEntry)*(stts->alloc_size-stts->nb_entries) );\n\t}\n\tstts->entries[stts->nb_entries].sampleCount = nb_pack;\n\tstts->entries[stts->nb_entries].sampleDelta = duration;\n\tstts->nb_entries++;\n\tif (stts->max_ts_delta < duration ) stts->max_ts_delta = duration;\n\treturn GF_OK;\n}", "target": 1}
{"code": "  const std::string& get_tenant() const {\n    ceph_assert(t != Wildcard);\n    return u.tenant;\n  }", "target": 1}
{"code": "authDigestNonceLinks(digest_nonce_h * nonce)\n{\n    if (!nonce)\n        return -1;\n    return nonce->references;\n}", "target": 1}
{"code": "static int rtnl_dump_all(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint idx;\n\tint s_idx = cb->family;\n\tif (s_idx == 0)\n\t\ts_idx = 1;\n\tfor (idx = 1; idx <= RTNL_FAMILY_MAX; idx++) {\n\t\tint type = cb->nlh->nlmsg_type-RTM_BASE;\n\t\tif (idx < s_idx || idx == PF_PACKET)\n\t\t\tcontinue;\n\t\tif (rtnl_msg_handlers[idx] == NULL ||\n\t\t    rtnl_msg_handlers[idx][type].dumpit == NULL)\n\t\t\tcontinue;\n\t\tif (idx > s_idx) {\n\t\t\tmemset(&cb->args[0], 0, sizeof(cb->args));\n\t\t\tcb->prev_seq = 0;\n\t\t\tcb->seq = 0;\n\t\t}\n\t\tif (rtnl_msg_handlers[idx][type].dumpit(skb, cb))\n\t\t\tbreak;\n\t}\n\tcb->family = idx;\n\treturn skb->len;\n}", "target": 0}
{"code": "int soft_offline_page(struct page *page, int flags)\n{\n\tint ret;\n\tunsigned long pfn = page_to_pfn(page);\n\tif (PageHWPoison(page)) {\n\t\tpr_info(\"soft offline: %#lx page already poisoned\\n\", pfn);\n\t\tif (flags & MF_COUNT_INCREASED)\n\t\t\tput_hwpoison_page(page);\n\t\treturn -EBUSY;\n\t}\n\tget_online_mems();\n\tret = get_any_page(page, pfn, flags);\n\tput_online_mems();\n\tif (ret > 0)\n\t\tret = soft_offline_in_use_page(page, flags);\n\telse if (ret == 0)\n\t\tsoft_offline_free_page(page);\n\treturn ret;\n}", "target": 0}
{"code": "uint32_t virtio_config_readw(VirtIODevice *vdev, uint32_t addr)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint16_t val;\n    k->get_config(vdev, vdev->config);\n    if (addr > (vdev->config_len - sizeof(val)))\n        return (uint32_t)-1;\n    val = lduw_p(vdev->config + addr);\n    return val;\n}", "target": 1}
{"code": "int test(char *URL)\n{\n  int errors = 0;\n  (void)URL; \n  errors += test_weird_arguments();\n  errors += test_unsigned_short_formatting();\n  errors += test_signed_short_formatting();\n  errors += test_unsigned_int_formatting();\n  errors += test_signed_int_formatting();\n  errors += test_unsigned_long_formatting();\n  errors += test_signed_long_formatting();\n  errors += test_curl_off_t_formatting();\n  errors += test_string_formatting();\n  errors += test_float_formatting();\n  if(errors)\n    return TEST_ERR_MAJOR_BAD;\n  else\n    return 0;\n}", "target": 0}
{"code": "PHP_FUNCTION(locale_parse)\n{\n    const char* loc_name        = NULL;\n    int         loc_name_len    = 0;\n    int         grOffset    \t= 0;\n    intl_error_reset( NULL TSRMLS_CC );\n    if(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, \"s\",\n        &loc_name, &loc_name_len ) == FAILURE)\n    {\n        intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n             \"locale_parse: unable to parse input params\", 0 TSRMLS_CC );\n        RETURN_FALSE;\n    }\n    if(loc_name_len == 0) {\n        loc_name = intl_locale_get_default(TSRMLS_C);\n    }\n\tarray_init( return_value );\n\tgrOffset =  findOffset( LOC_GRANDFATHERED , loc_name );\n\tif( grOffset >= 0 ){\n\t\tadd_assoc_string( return_value , LOC_GRANDFATHERED_LANG_TAG , estrdup(loc_name) ,FALSE );\n\t}\n\telse{\n\t\tadd_array_entry( loc_name , return_value , LOC_LANG_TAG TSRMLS_CC);\n\t\tadd_array_entry( loc_name , return_value , LOC_SCRIPT_TAG TSRMLS_CC);\n\t\tadd_array_entry( loc_name , return_value , LOC_REGION_TAG TSRMLS_CC);\n\t\tadd_array_entry( loc_name , return_value , LOC_VARIANT_TAG TSRMLS_CC);\n\t\tadd_array_entry( loc_name , return_value , LOC_PRIVATE_TAG TSRMLS_CC);\n\t}\n}", "target": 0}
{"code": "entityValueInitProcessor(XML_Parser parser, const char *s, const char *end,\n                         const char **nextPtr) {\n  int tok;\n  const char *start = s;\n  const char *next = start;\n  parser->m_eventPtr = start;\n  for (;;) {\n    tok = XmlPrologTok(parser->m_encoding, start, end, &next);\n    parser->m_eventEndPtr = next;\n    if (tok <= 0) {\n      if (! parser->m_parsingStatus.finalBuffer && tok != XML_TOK_INVALID) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      switch (tok) {\n      case XML_TOK_INVALID:\n        return XML_ERROR_INVALID_TOKEN;\n      case XML_TOK_PARTIAL:\n        return XML_ERROR_UNCLOSED_TOKEN;\n      case XML_TOK_PARTIAL_CHAR:\n        return XML_ERROR_PARTIAL_CHAR;\n      case XML_TOK_NONE: \n      default:\n        break;\n      }\n      return storeEntityValue(parser, parser->m_encoding, s, end,\n                              XML_ACCOUNT_DIRECT);\n    } else if (tok == XML_TOK_XML_DECL) {\n      enum XML_Error result;\n      result = processXmlDecl(parser, 0, start, next);\n      if (result != XML_ERROR_NONE)\n        return result;\n      if (parser->m_parsingStatus.parsing == XML_FINISHED)\n        return XML_ERROR_ABORTED;\n      *nextPtr = next;\n      parser->m_processor = entityValueProcessor;\n      return entityValueProcessor(parser, next, end, nextPtr);\n    }\n    else if (tok == XML_TOK_BOM) {\n#  ifdef XML_DTD\n      if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                    XML_ACCOUNT_DIRECT)) {\n        accountingOnAbort(parser);\n        return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n      }\n#  endif\n      *nextPtr = next;\n      s = next;\n    }\n    else if (tok == XML_TOK_INSTANCE_START) {\n      *nextPtr = next;\n      return XML_ERROR_SYNTAX;\n    }\n    start = next;\n    parser->m_eventPtr = start;\n  }\n}", "target": 1}
{"code": "createFile(const string &filename, const StaticString &contents, mode_t permissions, uid_t owner,\n\tgid_t group, bool overwrite)\n{\n\tFileDescriptor fd;\n\tint ret, e, options;\n\toptions = O_WRONLY | O_CREAT | O_TRUNC;\n\tif (!overwrite) {\n\t\toptions |= O_EXCL;\n\t}\n\tdo {\n\t\tfd = open(filename.c_str(), options, permissions);\n\t} while (fd == -1 && errno == EINTR);\n\tif (fd != -1) {\n\t\tFileGuard guard(filename);\n\t\tdo {\n\t\t\tret = fchmod(fd, permissions);\n\t\t} while (ret == -1 && errno == EINTR);\n\t\tif (ret == -1) {\n\t\t\te = errno;\n\t\t\tthrow FileSystemException(\"Cannot set permissions on \" + filename,\n\t\t\t\te, filename);\n\t\t}\n\t\tif (owner != USER_NOT_GIVEN && group != GROUP_NOT_GIVEN) {\n\t\t\tif (owner == USER_NOT_GIVEN) {\n\t\t\t\towner = (uid_t) -1; \n\t\t\t}\n\t\t\tif (group == GROUP_NOT_GIVEN) {\n\t\t\t\tgroup = (gid_t) -1; \n\t\t\t}\n\t\t\tdo {\n\t\t\t\tret = fchown(fd, owner, group);\n\t\t\t} while (ret == -1 && errno == EINTR);\n\t\t\tif (ret == -1) {\n\t\t\t\te = errno;\n\t\t\t\tthrow FileSystemException(\"Cannot set ownership for \" + filename,\n\t\t\t\t\te, filename);\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\twriteExact(fd, contents);\n\t\t\tfd.close();\n\t\t} catch (const SystemException &e) {\n\t\t\tthrow FileSystemException(\"Cannot write to file \" + filename,\n\t\t\t\te.code(), filename);\n\t\t}\n\t\tguard.commit();\n\t} else {\n\t\te = errno;\n\t\tif (overwrite || e != EEXIST) {\n\t\t\tthrow FileSystemException(\"Cannot create file \" + filename,\n\t\t\t\te, filename);\n\t\t}\n\t}\n}", "target": 0}
{"code": "process_request_identities(SocketEntry *e)\n{\n\tIdentity *id;\n\tstruct sshbuf *msg, *keys;\n\tint r;\n\tu_int nentries = 0;\n\tdebug2_f(\"entering\");\n\tif ((msg = sshbuf_new()) == NULL || (keys = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tTAILQ_FOREACH(id, &idtab->idlist, next) {\n\t\tif (identity_permitted(id, e, NULL, NULL, NULL) != 0)\n\t\t\tcontinue;\n\t\tif ((r = sshkey_puts_opts(id->key, keys,\n\t\t    SSHKEY_SERIALIZE_INFO)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(keys, id->comment)) != 0) {\n\t\t\terror_fr(r, \"compose key/comment\");\n\t\t\tcontinue;\n\t\t}\n\t\tnentries++;\n\t}\n\tdebug2_f(\"replying with %u allowed of %u available keys\",\n\t    nentries, idtab->nentries);\n\tif ((r = sshbuf_put_u8(msg, SSH2_AGENT_IDENTITIES_ANSWER)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, nentries)) != 0 ||\n\t    (r = sshbuf_putb(msg, keys)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\tif ((r = sshbuf_put_stringb(e->output, msg)) != 0)\n\t\tfatal_fr(r, \"enqueue\");\n\tsshbuf_free(msg);\n\tsshbuf_free(keys);\n}", "target": 1}
{"code": "inline int nci_request(struct nci_dev *ndev,\n\t\t       void (*req)(struct nci_dev *ndev,\n\t\t\t\t   const void *opt),\n\t\t       const void *opt, __u32 timeout)\n{\n\tint rc;\n\tif (!test_bit(NCI_UP, &ndev->flags))\n\t\treturn -ENETDOWN;\n\tmutex_lock(&ndev->req_lock);\n\trc = __nci_request(ndev, req, opt, timeout);\n\tmutex_unlock(&ndev->req_lock);\n\treturn rc;\n}", "target": 1}
{"code": "static inline u32 dma_low(dma_addr_t addr)\n{\n\treturn (u32)addr;\n}", "target": 1}
{"code": "static void follow_dotdot(struct nameidata *nd)\n{\n\tif (!nd->root.mnt)\n\t\tset_root(nd);\n\twhile(1) {\n\t\tstruct dentry *old = nd->path.dentry;\n\t\tif (nd->path.dentry == nd->root.dentry &&\n\t\t    nd->path.mnt == nd->root.mnt) {\n\t\t\tbreak;\n\t\t}\n\t\tif (nd->path.dentry != nd->path.mnt->mnt_root) {\n\t\t\tnd->path.dentry = dget_parent(nd->path.dentry);\n\t\t\tdput(old);\n\t\t\tbreak;\n\t\t}\n\t\tif (!follow_up(&nd->path))\n\t\t\tbreak;\n\t}\n\tfollow_mount(&nd->path);\n\tnd->inode = nd->path.dentry->d_inode;\n}", "target": 1}
{"code": "int send_sigqueue(struct sigqueue *q, struct task_struct *t, int group)\n{\n\tint sig = q->info.si_signo;\n\tstruct sigpending *pending;\n\tunsigned long flags;\n\tint ret;\n\tBUG_ON(!(q->flags & SIGQUEUE_PREALLOC));\n\tret = -1;\n\tif (!likely(lock_task_sighand(t, &flags)))\n\t\tgoto ret;\n\tret = 1; \n\tif (!prepare_signal(sig, t, 0))\n\t\tgoto out;\n\tret = 0;\n\tif (unlikely(!list_empty(&q->list))) {\n\t\tBUG_ON(q->info.si_code != SI_TIMER);\n\t\tq->info.si_overrun++;\n\t\tgoto out;\n\t}\n\tq->info.si_overrun = 0;\n\tsignalfd_notify(t, sig);\n\tpending = group ? &t->signal->shared_pending : &t->pending;\n\tlist_add_tail(&q->list, &pending->list);\n\tsigaddset(&pending->signal, sig);\n\tcomplete_signal(sig, t, group);\nout:\n\tunlock_task_sighand(t, &flags);\nret:\n\treturn ret;\n}", "target": 0}
{"code": "void recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h, *g;\n\tunsigned int i;\n\tvmcb_mark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\tc = &svm->vmcb->control;\n\th = &svm->vmcb01.ptr->control;\n\tg = &svm->nested.ctl;\n\tfor (i = 0; i < MAX_INTERCEPT; i++)\n\t\tc->intercepts[i] = h->intercepts[i];\n\tif (g->int_ctl & V_INTR_MASKING_MASK) {\n\t\tvmcb_clr_intercept(c, INTERCEPT_CR8_READ);\n\t\tvmcb_clr_intercept(c, INTERCEPT_CR8_WRITE);\n\t\tvmcb_clr_intercept(c, INTERCEPT_VINTR);\n\t}\n\tvmcb_clr_intercept(c, INTERCEPT_VMMCALL);\n\tfor (i = 0; i < MAX_INTERCEPT; i++)\n\t\tc->intercepts[i] |= g->intercepts[i];\n\tif (!intercept_smi)\n\t\tvmcb_clr_intercept(c, INTERCEPT_SMI);\n}", "target": 1}
{"code": "zend_op_array *compile_string(zval *source_string, char *filename TSRMLS_DC)\n{\n\tzend_lex_state original_lex_state;\n\tzend_op_array *op_array = (zend_op_array *) emalloc(sizeof(zend_op_array));\n\tzend_op_array *original_active_op_array = CG(active_op_array);\n\tzend_op_array *retval;\n\tzval tmp;\n\tint compiler_result;\n\tzend_bool original_in_compilation = CG(in_compilation);\n\tif (source_string->value.str.len==0) {\n\t\tefree(op_array);\n\t\treturn NULL;\n\t}\n\tCG(in_compilation) = 1;\n\ttmp = *source_string;\n\tzval_copy_ctor(&tmp);\n\tconvert_to_string(&tmp);\n\tsource_string = &tmp;\n\tzend_save_lexical_state(&original_lex_state TSRMLS_CC);\n\tif (zend_prepare_string_for_scanning(source_string, filename TSRMLS_CC)==FAILURE) {\n\t\tefree(op_array);\n\t\tretval = NULL;\n\t} else {\n\t\tzend_bool orig_interactive = CG(interactive);\n\t\tCG(interactive) = 0;\n\t\tinit_op_array(op_array, ZEND_EVAL_CODE, INITIAL_OP_ARRAY_SIZE TSRMLS_CC);\n\t\tCG(interactive) = orig_interactive;\n\t\tCG(active_op_array) = op_array;\n\t\tzend_stack_push(&CG(context_stack), (void *) &CG(context), sizeof(CG(context)));\n\t\tzend_init_compiler_context(TSRMLS_C);\n\t\tBEGIN(ST_IN_SCRIPTING);\n\t\tcompiler_result = zendparse(TSRMLS_C);\n\t\tif (SCNG(script_filtered)) {\n\t\t\tefree(SCNG(script_filtered));\n\t\t\tSCNG(script_filtered) = NULL;\n\t\t}\n\t\tif (compiler_result==1) {\n\t\t\tCG(active_op_array) = original_active_op_array;\n\t\t\tCG(unclean_shutdown)=1;\n\t\t\tdestroy_op_array(op_array TSRMLS_CC);\n\t\t\tefree(op_array);\n\t\t\tretval = NULL;\n\t\t} else {\n\t\t\tzend_do_return(NULL, 0 TSRMLS_CC);\n\t\t\tCG(active_op_array) = original_active_op_array;\n\t\t\tpass_two(op_array TSRMLS_CC);\n\t\t\tzend_release_labels(0 TSRMLS_CC);\n\t\t\tretval = op_array;\n\t\t}\n\t}\n\tzend_restore_lexical_state(&original_lex_state TSRMLS_CC);\n\tzval_dtor(&tmp);\n\tCG(in_compilation) = original_in_compilation;\n\treturn retval;\n}", "target": 1}
{"code": "pcx_write_rle(const byte * from, const byte * end, int step, gp_file * file)\n{\t\t\t\t\n#define MAX_RUN_COUNT 15\n    int max_run = step * MAX_RUN_COUNT;\n    while (from < end) {\n        byte data = *from;\n        from += step;\n        if (data != *from || from == end) {\n            if (data >= 0xc0)\n                gp_fputc(0xc1, file);\n        } else {\n            const byte *start = from;\n            while ((from < end) && (*from == data))\n                from += step;\n            while (from - start >= max_run) {\n                gp_fputc(0xc0 + MAX_RUN_COUNT, file);\n                gp_fputc(data, file);\n                start += max_run;\n            }\n            if (from > start || data >= 0xc0)\n                gp_fputc((from - start) / step + 0xc1, file);\n        }\n        gp_fputc(data, file);\n    }\n#undef MAX_RUN_COUNT\n}", "target": 1}
{"code": "_XimEncodeSavedPreeditValue(\n    Xic\t\t\t  ic,\n    XIMResourceList\t  res,\n    XPointer\t\t  value)\n{\n    int\t\t\t  list_ret;\n    XFontStruct\t\t**struct_list;\n    char\t\t**name_list;\n    char\t\t *tmp;\n    int\t\t\t  len;\n    register int\t  i;\n    if (res->xrm_name == XrmStringToQuark(XNFontSet)) {\n\tif (!value)\n\t    return False;\n\tif (ic->private.proto.preedit_font)\n\t    Xfree(ic->private.proto.preedit_font);\n\tlist_ret = XFontsOfFontSet((XFontSet)value,\n\t\t\t\t\t\t&struct_list, &name_list);\n\tfor(i = 0, len = 0; i < list_ret; i++) {\n\t    len += (strlen(name_list[i]) + sizeof(char));\n\t}\n\tif(!(tmp = Xmalloc(len + 1))) {\n\t    ic->private.proto.preedit_font = NULL;\n\t    return False;\n\t}\n\ttmp[0] = '\\0';\n\tfor(i = 0; i < list_ret; i++) {\n\t    strcat(tmp, name_list[i]);\n\t    strcat(tmp, \",\");\n\t}\n\ttmp[len - 1] = 0;\n\tic->private.proto.preedit_font        = tmp;\n\tic->private.proto.preedit_font_length = len - 1;\n    }\n    return True;\n}", "target": 0}
{"code": "void smp_send_pair_rsp(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n  SMP_TRACE_DEBUG(\"%s\", __func__);\n  p_cb->local_i_key &= p_cb->peer_i_key;\n  p_cb->local_r_key &= p_cb->peer_r_key;\n if (smp_send_cmd(SMP_OPCODE_PAIRING_RSP, p_cb)) {\n if (p_cb->selected_association_model == SMP_MODEL_SEC_CONN_OOB)\n      smp_use_oob_private_key(p_cb, NULL);\n else\n      smp_decide_association_model(p_cb, NULL);\n }\n}", "target": 0}
{"code": "bool GLSurfaceOzoneSurfaceless::IsOffscreen() {\n  return false;\n}", "target": 0}
{"code": "static int dnxhd_write_header(AVCodecContext *avctx, uint8_t *buf)\n{\n    DNXHDEncContext *ctx = avctx->priv_data;\n    static const uint8_t header_prefix[5] = { 0x00,0x00,0x02,0x80,0x01 };\n    memset(buf, 0, 640);\n    memcpy(buf, header_prefix, 5);\n    buf[5] = ctx->interlaced ? ctx->cur_field+2 : 0x01;\n    buf[6] = 0x80; \n    buf[7] = 0xa0; \n    AV_WB16(buf + 0x18, avctx->height>>ctx->interlaced); \n    AV_WB16(buf + 0x1a, avctx->width);  \n    AV_WB16(buf + 0x1d, avctx->height>>ctx->interlaced); \n    buf[0x21] = ctx->cid_table->bit_depth == 10 ? 0x58 : 0x38;\n    buf[0x22] = 0x88 + (ctx->interlaced<<2);\n    AV_WB32(buf + 0x28, ctx->cid); \n    buf[0x2c] = ctx->interlaced ? 0 : 0x80;\n    buf[0x5f] = 0x01; \n    buf[0x167] = 0x02; \n    AV_WB16(buf + 0x16a, ctx->m.mb_height * 4 + 4); \n    buf[0x16d] = ctx->m.mb_height; \n    buf[0x16f] = 0x10; \n    ctx->msip = buf + 0x170;\n    return 0;\n}", "target": 0}
{"code": "static void snd_timer_proc_read(struct snd_info_entry *entry,\n\t\t\t\tstruct snd_info_buffer *buffer)\n{\n\tstruct snd_timer *timer;\n\tstruct snd_timer_instance *ti;\n\tmutex_lock(&register_mutex);\n\tlist_for_each_entry(timer, &snd_timer_list, device_list) {\n\t\tif (timer->card && timer->card->shutdown)\n\t\t\tcontinue;\n\t\tswitch (timer->tmr_class) {\n\t\tcase SNDRV_TIMER_CLASS_GLOBAL:\n\t\t\tsnd_iprintf(buffer, \"G%i: \", timer->tmr_device);\n\t\t\tbreak;\n\t\tcase SNDRV_TIMER_CLASS_CARD:\n\t\t\tsnd_iprintf(buffer, \"C%i-%i: \",\n\t\t\t\t    timer->card->number, timer->tmr_device);\n\t\t\tbreak;\n\t\tcase SNDRV_TIMER_CLASS_PCM:\n\t\t\tsnd_iprintf(buffer, \"P%i-%i-%i: \", timer->card->number,\n\t\t\t\t    timer->tmr_device, timer->tmr_subdevice);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnd_iprintf(buffer, \"?%i-%i-%i-%i: \", timer->tmr_class,\n\t\t\t\t    timer->card ? timer->card->number : -1,\n\t\t\t\t    timer->tmr_device, timer->tmr_subdevice);\n\t\t}\n\t\tsnd_iprintf(buffer, \"%s :\", timer->name);\n\t\tif (timer->hw.resolution)\n\t\t\tsnd_iprintf(buffer, \" %lu.%03luus (%lu ticks)\",\n\t\t\t\t    timer->hw.resolution / 1000,\n\t\t\t\t    timer->hw.resolution % 1000,\n\t\t\t\t    timer->hw.ticks);\n\t\tif (timer->hw.flags & SNDRV_TIMER_HW_SLAVE)\n\t\t\tsnd_iprintf(buffer, \" SLAVE\");\n\t\tsnd_iprintf(buffer, \"\\n\");\n\t\tlist_for_each_entry(ti, &timer->open_list_head, open_list)\n\t\t\tsnd_iprintf(buffer, \"  Client %s : %s\\n\",\n\t\t\t\t    ti->owner ? ti->owner : \"unknown\",\n\t\t\t\t    ti->flags & (SNDRV_TIMER_IFLG_START |\n\t\t\t\t\t\t SNDRV_TIMER_IFLG_RUNNING)\n\t\t\t\t    ? \"running\" : \"stopped\");\n\t}\n\tmutex_unlock(&register_mutex);\n}", "target": 0}
{"code": "bool ResourceHandle::ParseFromString(const string& s) {\n  ResourceHandleProto proto;\n  const bool status = proto.ParseFromString(s);\n  if (status) FromProto(proto);\n  return status;\n}", "target": 1}
{"code": "PHP_XML_API zend_string *xml_utf8_encode(const char *s, size_t len, const XML_Char *encoding)\n{\n\tsize_t pos = len;\n\tzend_string *str;\n\tunsigned int c;\n\tunsigned short (*encoder)(unsigned char) = NULL;\n\txml_encoding *enc = xml_get_encoding(encoding);\n\tif (enc) {\n\t\tencoder = enc->encoding_function;\n\t} else {\n\t\treturn NULL;\n\t}\n\tif (encoder == NULL) {\n\t\tstr = zend_string_init(s, len, 0);\n\t\treturn str;\n\t}\n\tstr = zend_string_alloc(len * 4, 0);\n\tZSTR_LEN(str) = 0;\n\twhile (pos > 0) {\n\t\tc = encoder ? encoder((unsigned char)(*s)) : (unsigned short)(*s);\n\t\tif (c < 0x80) {\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (char) c;\n\t\t} else if (c < 0x800) {\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (0xc0 | (c >> 6));\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (0x80 | (c & 0x3f));\n\t\t} else if (c < 0x10000) {\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (0xe0 | (c >> 12));\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (0xc0 | ((c >> 6) & 0x3f));\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (0x80 | (c & 0x3f));\n\t\t} else if (c < 0x200000) {\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (0xf0 | (c >> 18));\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (0xe0 | ((c >> 12) & 0x3f));\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (0xc0 | ((c >> 6) & 0x3f));\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (0x80 | (c & 0x3f));\n\t\t}\n\t\tpos--;\n\t\ts++;\n\t}\n\tZSTR_VAL(str)[ZSTR_LEN(str)] = '\\0';\n\tstr = zend_string_truncate(str, ZSTR_LEN(str), 0);\n\treturn str;\n}", "target": 1}
{"code": "static int spk_ttyio_ldisc_open(struct tty_struct *tty)\n{\n\tstruct spk_ldisc_data *ldisc_data;\n\tif (!tty->ops->write)\n\t\treturn -EOPNOTSUPP;\n\tspeakup_tty = tty;\n\tldisc_data = kmalloc(sizeof(*ldisc_data), GFP_KERNEL);\n\tif (!ldisc_data)\n\t\treturn -ENOMEM;\n\tinit_completion(&ldisc_data->completion);\n\tldisc_data->buf_free = true;\n\tspeakup_tty->disc_data = ldisc_data;\n\treturn 0;\n}", "target": 1}
{"code": "  Status CalculateOutputIndex(OpKernelContext* context, int dimension,\n                              const vector<INDEX_TYPE>& parent_output_index,\n                              INDEX_TYPE output_index_multiplier,\n                              INDEX_TYPE output_size,\n                              vector<INDEX_TYPE>* result) {\n    const RowPartitionTensor row_partition_tensor =\n        GetRowPartitionTensor(context, dimension);\n    auto partition_type = GetRowPartitionTypeByDimension(dimension);\n    switch (partition_type) {\n      case RowPartitionType::VALUE_ROWIDS:\n        return CalculateOutputIndexValueRowID(\n            row_partition_tensor, parent_output_index, output_index_multiplier,\n            output_size, result);\n      case RowPartitionType::ROW_SPLITS:\n        if (row_partition_tensor.size() - 1 > parent_output_index.size()) {\n          return errors::InvalidArgument(\n              \"Row partition size is greater than output size: \",\n              row_partition_tensor.size() - 1, \" > \",\n              parent_output_index.size());\n        }\n        return CalculateOutputIndexRowSplit(\n            row_partition_tensor, parent_output_index, output_index_multiplier,\n            output_size, result);\n      default:\n        return errors::InvalidArgument(\n            \"Unsupported partition type:\",\n            RowPartitionTypeToString(partition_type));\n    }\n  }", "target": 0}
{"code": "static void do_free_publickey(struct rsa_public_key *key)\n{\n\tcrypto_bignum_free(key->e);\n\tcrypto_bignum_free(key->n);\n}", "target": 1}
{"code": "isdn_net_force_hangup(char *name)\n{\n\tisdn_net_dev *p = isdn_net_findif(name);\n\tstruct net_device *q;\n\tif (p) {\n\t\tif (p->local->isdn_device < 0)\n\t\t\treturn 1;\n\t\tq = p->local->slave;\n\t\twhile (q) {\n\t\t\tisdn_net_hangup(q);\n\t\t\tq = MASTER_TO_SLAVE(q);\n\t\t}\n\t\tisdn_net_hangup(p->dev);\n\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}", "target": 0}
{"code": "int x86_decode_emulated_instruction(struct kvm_vcpu *vcpu, int emulation_type,\n\t\t\t\t    void *insn, int insn_len)\n{\n\tint r = EMULATION_OK;\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\tinit_emulate_ctxt(vcpu);\n\tif (!(emulation_type & EMULTYPE_SKIP) &&\n\t    kvm_vcpu_check_breakpoint(vcpu, &r))\n\t\treturn r;\n\tr = x86_decode_insn(ctxt, insn, insn_len, emulation_type);\n\ttrace_kvm_emulate_insn_start(vcpu);\n\t++vcpu->stat.insn_emulation;\n\treturn r;\n}", "target": 1}
{"code": "static struct page *hugetlbfs_pagecache_page(struct hstate *h,\n\t\t\tstruct vm_area_struct *vma, unsigned long address)\n{\n\tstruct address_space *mapping;\n\tpgoff_t idx;\n\tmapping = vma->vm_file->f_mapping;\n\tidx = vma_hugecache_offset(h, vma, address);\n\treturn find_lock_page(mapping, idx);\n}", "target": 0}
{"code": "void CE_WideToChar(unsigned short *w_str, char *str)\n{\n\tWideCharToMultiByte(CP_ACP, 0, w_str, -1, str, GF_MAX_PATH, NULL, NULL);\n}", "target": 0}
{"code": "TEST_F(EncryptedRecordTest, TestAllPaddingHandshake) {\n  addToQueue(\"17030100050123456789\");\n  EXPECT_CALL(*readAead_, _decrypt(_, _, 0))\n      .WillOnce(Invoke([](std::unique_ptr<IOBuf>& buf, const IOBuf*, uint64_t) {\n        expectSame(buf, \"0123456789\");\n        return getBuf(\"16000000\");\n      }));\n  EXPECT_NO_THROW(read_.read(queue_));\n}", "target": 1}
{"code": "static int get_vdev_port_node_info(struct mdesc_handle *md, u64 node,\n\t\t\t\t   union md_node_info *node_info)\n{\n\tconst u64 *parent_cfg_hdlp;\n\tconst char *name;\n\tconst u64 *idp;\n\tidp = mdesc_get_property(md, node, \"id\", NULL);\n\tname = mdesc_get_property(md, node, \"name\", NULL);\n\tparent_cfg_hdlp = parent_cfg_handle(md, node);\n\tif (!idp || !name || !parent_cfg_hdlp)\n\t\treturn -1;\n\tnode_info->vdev_port.id = *idp;\n\tnode_info->vdev_port.name = kstrdup_const(name, GFP_KERNEL);\n\tnode_info->vdev_port.parent_cfg_hdl = *parent_cfg_hdlp;\n\treturn 0;\n}", "target": 1}
{"code": "static void __mcheck_cpu_init_generic(void)\n{\n\tenum mcp_flags m_fl = 0;\n\tmce_banks_t all_banks;\n\tu64 cap;\n\tif (!mca_cfg.bootlog)\n\t\tm_fl = MCP_DONTLOG;\n\tbitmap_fill(all_banks, MAX_NR_BANKS);\n\tmachine_check_poll(MCP_UC | m_fl, &all_banks);\n\tcr4_set_bits(X86_CR4_MCE);\n\trdmsrl(MSR_IA32_MCG_CAP, cap);\n\tif (cap & MCG_CTL_P)\n\t\twrmsr(MSR_IA32_MCG_CTL, 0xffffffff, 0xffffffff);\n}", "target": 0}
{"code": "_XimEncodeStatusValue(\n    Xic\t\t\t ic,\n    XIMResourceList\t res,\n    XIMArg\t\t*p)\n{\n    if (res->xrm_name == XrmStringToQuark(XNStdColormap)) {\n\tXStandardColormap\t*colormap_ret = NULL;\n\tint\t\t\t count;\n\tif (!(XGetRGBColormaps(ic->core.im->core.display,\n\t\t\t\tic->core.focus_window, &colormap_ret,\n\t\t\t\t&count, (Atom)p->value)))\n\t    return False;\n\tXFree(colormap_ret);\n    } else if (res->xrm_name == XrmStringToQuark(XNFontSet)) {\n\tint\t\t  list_ret;\n\tXFontStruct\t**struct_list;\n\tchar\t\t**name_list;\n\tchar\t\t *tmp;\n\tint\t\t  len;\n\tregister int\t  i;\n\tif (!p->value)\n\t    return False;\n\tXfree(ic->private.proto.status_font);\n\tlist_ret = XFontsOfFontSet((XFontSet)p->value,\n\t\t\t\t\t\t &struct_list, &name_list);\n\tfor (i = 0, len = 0; i < list_ret; i++) {\n\t     len += (strlen(name_list[i]) + sizeof(char));\n\t}\n\tif (!(tmp = Xmalloc(len+1))) {\n\t    ic->private.proto.status_font = NULL;\n\t    return False;\n\t}\n\ttmp[0] = '\\0';\n\tfor(i = 0; i < list_ret; i++) {\n\t    strcat(tmp, name_list[i]);\n\t    strcat(tmp, \",\");\n\t}\n\ttmp[len - 1] = 0;\n\tic->private.proto.status_font        = tmp;\n\tic->private.proto.status_font_length = len - 1;\n    }\n    return True;\n}", "target": 0}
{"code": "void virtio_config_writel(VirtIODevice *vdev, uint32_t addr, uint32_t data)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint32_t val = data;\n    if (addr > (vdev->config_len - sizeof(val)))\n        return;\n    stl_p(vdev->config + addr, val);\n    if (k->set_config) {\n        k->set_config(vdev, vdev->config);\n    }\n}", "target": 1}
{"code": "FunctionDef FunctionDefHelper::Create(\n    const string& function_name, gtl::ArraySlice<string> in_def,\n    gtl::ArraySlice<string> out_def, gtl::ArraySlice<string> attr_def,\n    gtl::ArraySlice<Node> node_def,\n    gtl::ArraySlice<std::pair<string, string>> ret_def) {\n  return Create(function_name, in_def, out_def, attr_def, node_def, ret_def,\n                {});\n}", "target": 0}
{"code": "int flush_completed_IO(struct inode *inode)\n{\n\text4_io_end_t *io;\n\tint ret = 0;\n\tint ret2 = 0;\n\tif (list_empty(&EXT4_I(inode)->i_completed_io_list))\n\t\treturn ret;\n\tdump_completed_IO(inode);\n\twhile (!list_empty(&EXT4_I(inode)->i_completed_io_list)){\n\t\tio = list_entry(EXT4_I(inode)->i_completed_io_list.next,\n\t\t\t\text4_io_end_t, list);\n\t\tret = ext4_end_io_nolock(io);\n\t\tif (ret < 0)\n\t\t\tret2 = ret;\n\t\telse\n\t\t\tlist_del_init(&io->list);\n\t}\n\treturn (ret2 < 0) ? ret2 : 0;\n}", "target": 1}
{"code": "static struct nfc_dev *__get_device_from_cb(struct netlink_callback *cb)\n{\n\tconst struct genl_dumpit_info *info = genl_dumpit_info(cb);\n\tstruct nfc_dev *dev;\n\tu32 idx;\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n\t\treturn ERR_PTR(-EINVAL);\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENODEV);\n\treturn dev;\n}", "target": 0}
{"code": "static int route4_init(struct tcf_proto *tp)\n{\n\tstruct route4_head *head;\n\thead = kzalloc(sizeof(struct route4_head), GFP_KERNEL);\n\tif (head == NULL)\n\t\treturn -ENOBUFS;\n\trcu_assign_pointer(tp->root, head);\n\treturn 0;\n}", "target": 0}
{"code": "static int wrap_nettle_hash_fast(gnutls_digest_algorithm_t algo,\n\t\t\t\t const void *text, size_t text_size,\n\t\t\t\t void *digest)\n{\n\tstruct nettle_hash_ctx ctx;\n\tint ret;\n\tret = _ctx_init(algo, &ctx);\n\tif (ret < 0)\n\t\treturn gnutls_assert_val(ret);\n\tctx.update(&ctx, text_size, text);\n\tctx.digest(&ctx, ctx.length, digest);\n\treturn 0;\n}", "target": 1}
{"code": "vg_get_config(VuDev *dev, uint8_t *config, uint32_t len)\n{\n    VuGpu *g = container_of(dev, VuGpu, dev.parent);\n    if (len > sizeof(struct virtio_gpu_config)) {\n        return -1;\n    }\n    if (opt_virgl) {\n        g->virtio_config.num_capsets = vg_virgl_get_num_capsets();\n    }\n    memcpy(config, &g->virtio_config, len);\n    return 0;\n}", "target": 0}
{"code": "void Browser::SetWebContentsBlocked(content::WebContents* web_contents,\n                                    bool blocked) {\n  int index = tab_strip_model_->GetIndexOfWebContents(web_contents);\n  if (index == TabStripModel::kNoTab) {\n     return;\n   }\n   tab_strip_model_->SetTabBlocked(index, blocked);\n   bool browser_active = BrowserList::GetInstance()->GetLastActive() == this;\n  bool contents_is_active =\n      tab_strip_model_->GetActiveWebContents() == web_contents;\n  if (!blocked && contents_is_active && browser_active)\n    web_contents->Focus();\n}", "target": 1}
{"code": "static int ip_setup_cork(struct sock *sk, struct inet_cork *cork,\n\t\t\t struct ipcm_cookie *ipc, struct rtable **rtp)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_options *opt;\n\tstruct rtable *rt;\n\topt = ipc->opt;\n\tif (opt) {\n\t\tif (cork->opt == NULL) {\n\t\t\tcork->opt = kmalloc(sizeof(struct ip_options) + 40,\n\t\t\t\t\t    sk->sk_allocation);\n\t\t\tif (unlikely(cork->opt == NULL))\n\t\t\t\treturn -ENOBUFS;\n\t\t}\n\t\tmemcpy(cork->opt, opt, sizeof(struct ip_options) + opt->optlen);\n\t\tcork->flags |= IPCORK_OPT;\n\t\tcork->addr = ipc->addr;\n\t}\n\trt = *rtp;\n\tif (unlikely(!rt))\n\t\treturn -EFAULT;\n\t*rtp = NULL;\n\tcork->fragsize = inet->pmtudisc == IP_PMTUDISC_PROBE ?\n\t\t\t rt->dst.dev->mtu : dst_mtu(rt->dst.path);\n\tcork->dst = &rt->dst;\n\tcork->length = 0;\n\tcork->tx_flags = ipc->tx_flags;\n\tcork->page = NULL;\n\tcork->off = 0;\n\treturn 0;\n}", "target": 1}
{"code": "static int fts3DoclistCountDocids(char *aList, int nList){\n  int nDoc = 0;                   \n  if( aList ){\n    char *aEnd = &aList[nList];   \n    char *p = aList;              \n    while( p<aEnd ){\n      nDoc++;\n      while( (*p++)&0x80 );     \n      fts3PoslistCopy(0, &p);   \n    }\n  }\n  return nDoc;\n}", "target": 0}
{"code": "void RGWCORSRule::format_exp_headers(string& s) {\n  s = \"\";\n  for(list<string>::iterator it = exposable_hdrs.begin();\n      it != exposable_hdrs.end(); ++it) {\n      if (s.length() > 0)\n        s.append(\",\");\n      s.append((*it));\n  }\n}", "target": 1}
{"code": "nfsd4_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tstruct nfs4_acl *acl)\n{\n\t__be32 error;\n\tint host_error;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tstruct posix_acl *pacl = NULL, *dpacl = NULL;\n\tunsigned int flags = 0;\n\terror = fh_verify(rqstp, fhp, 0, NFSD_MAY_SATTR);\n\tif (error)\n\t\treturn error;\n\tdentry = fhp->fh_dentry;\n\tinode = d_inode(dentry);\n\tif (!inode->i_op->set_acl || !IS_POSIXACL(inode))\n\t\treturn nfserr_attrnotsupp;\n\tif (S_ISDIR(inode->i_mode))\n\t\tflags = NFS4_ACL_DIR;\n\thost_error = nfs4_acl_nfsv4_to_posix(acl, &pacl, &dpacl, flags);\n\tif (host_error == -EINVAL)\n\t\treturn nfserr_attrnotsupp;\n\tif (host_error < 0)\n\t\tgoto out_nfserr;\n\thost_error = inode->i_op->set_acl(inode, pacl, ACL_TYPE_ACCESS);\n\tif (host_error < 0)\n\t\tgoto out_release;\n\tif (S_ISDIR(inode->i_mode)) {\n\t\thost_error = inode->i_op->set_acl(inode, dpacl,\n\t\t\t\t\t\t  ACL_TYPE_DEFAULT);\n\t}\nout_release:\n\tposix_acl_release(pacl);\n\tposix_acl_release(dpacl);\nout_nfserr:\n\tif (host_error == -EOPNOTSUPP)\n\t\treturn nfserr_attrnotsupp;\n\telse\n\t\treturn nfserrno(host_error);\n}", "target": 1}
{"code": "static inline struct keydata *get_keyptr(void)\n{\n\tstruct keydata *keyptr = &ip_keydata[ip_cnt & 1];\n\tsmp_rmb();\n\treturn keyptr;\n}", "target": 1}
{"code": "static int atusb_get_and_show_build(struct atusb *atusb)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tchar build[ATUSB_BUILD_SIZE + 1];\n\tint ret;\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_BUILD, ATUSB_REQ_FROM_DEV, 0, 0,\n\t\t\t\tbuild, ATUSB_BUILD_SIZE, 1000);\n\tif (ret >= 0) {\n\t\tbuild[ret] = 0;\n\t\tdev_info(&usb_dev->dev, \"Firmware: build %s\\n\", build);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "UnicodeString DecimalQuantity::toScientificString() const {\n    U_ASSERT(!isApproximate);\n    UnicodeString result;\n    if (isNegative()) {\n        result.append(u'-');\n    }\n    if (precision == 0) {\n        result.append(u\"0E+0\", -1);\n        return result;\n    }\n    int32_t upperPos = std::min(precision + scale, lOptPos) - scale - 1;\n    int32_t lowerPos = std::max(scale, rOptPos) - scale;\n    int32_t p = upperPos;\n    result.append(u'0' + getDigitPos(p));\n    if ((--p) >= lowerPos) {\n        result.append(u'.');\n        for (; p >= lowerPos; p--) {\n            result.append(u'0' + getDigitPos(p));\n        }\n    }\n    result.append(u'E');\n    int32_t _scale = upperPos + scale;\n    if (_scale < 0) {\n        _scale *= -1;\n        result.append(u'-');\n    } else {\n        result.append(u'+');\n    }\n    if (_scale == 0) {\n        result.append(u'0');\n    }\n    int32_t insertIndex = result.length();\n    while (_scale > 0) {\n        std::div_t res = std::div(_scale, 10);\n        result.insert(insertIndex, u'0' + res.rem);\n        _scale = res.quot;\n    }\n    return result;\n}", "target": 1}
{"code": "void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n\t{\n#ifdef BN_LLONG\n\tBN_ULLONG t;\n#else\n\tBN_ULONG bl,bh;\n#endif\n\tBN_ULONG t1,t2;\n\tBN_ULONG c1,c2,c3;\n\tc1=0;\n\tc2=0;\n\tc3=0;\n\tmul_add_c(a[0],b[0],c1,c2,c3);\n\tr[0]=c1;\n\tc1=0;\n\tmul_add_c(a[0],b[1],c2,c3,c1);\n\tmul_add_c(a[1],b[0],c2,c3,c1);\n\tr[1]=c2;\n\tc2=0;\n\tmul_add_c(a[2],b[0],c3,c1,c2);\n\tmul_add_c(a[1],b[1],c3,c1,c2);\n\tmul_add_c(a[0],b[2],c3,c1,c2);\n\tr[2]=c3;\n\tc3=0;\n\tmul_add_c(a[0],b[3],c1,c2,c3);\n\tmul_add_c(a[1],b[2],c1,c2,c3);\n\tmul_add_c(a[2],b[1],c1,c2,c3);\n\tmul_add_c(a[3],b[0],c1,c2,c3);\n\tr[3]=c1;\n\tc1=0;\n\tmul_add_c(a[3],b[1],c2,c3,c1);\n\tmul_add_c(a[2],b[2],c2,c3,c1);\n\tmul_add_c(a[1],b[3],c2,c3,c1);\n\tr[4]=c2;\n\tc2=0;\n\tmul_add_c(a[2],b[3],c3,c1,c2);\n\tmul_add_c(a[3],b[2],c3,c1,c2);\n\tr[5]=c3;\n\tc3=0;\n\tmul_add_c(a[3],b[3],c1,c2,c3);\n\tr[6]=c1;\n\tr[7]=c2;\n\t}", "target": 1}
{"code": "static void do_client_disconnect(void)\n{\n    if (client_connected) {\n        udscs_server_write_all(server, VDAGENTD_CLIENT_DISCONNECTED, 0, 0,\n                               NULL, 0);\n        client_connected = false;\n    }\n}", "target": 1}
{"code": "BGD_DECLARE(void *) gdImageBmpPtr(gdImagePtr im, int *size, int compression)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) return NULL;\n\tgdImageBmpCtx(im, out, compression);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\treturn rv;\n}", "target": 1}
{"code": "    void CrwMap::decodeArray(const CiffComponent& ciffComponent,\n                             const CrwMapping*    pCrwMapping,\n                                   Image&         image,\n                                   ByteOrder      byteOrder)\n    {\n        if (ciffComponent.typeId() != unsignedShort) {\n            return decodeBasic(ciffComponent, pCrwMapping, image, byteOrder);\n        }\n        long aperture = 0;\n        long shutterSpeed = 0;\n        IfdId ifdId = ifdIdNotSet;\n        switch (pCrwMapping->tag_) {\n        case 0x0001: ifdId = canonCsId; break;\n        case 0x0004: ifdId = canonSiId; break;\n        case 0x000f: ifdId = canonCfId; break;\n        case 0x0012: ifdId = canonPiId; break;\n        }\n        assert(ifdId != ifdIdNotSet);\n        std::string groupName(Internal::groupName(ifdId));\n        uint16_t c = 1;\n        while (uint32_t(c)*2 < ciffComponent.size()) {\n            uint16_t n = 1;\n            ExifKey key(c, groupName);\n            UShortValue value;\n            if (ifdId == canonCsId && c == 23 && ciffComponent.size() > 50) n = 3;\n            value.read(ciffComponent.pData() + c*2, n*2, byteOrder);\n            image.exifData().add(key, &value);\n            if (ifdId == canonSiId && c == 21) aperture = value.toLong();\n            if (ifdId == canonSiId && c == 22) shutterSpeed = value.toLong();\n            c += n;\n        }\n        if (ifdId == canonSiId) {\n            float f = fnumber(canonEv(aperture));\n            Rational r = floatToRationalCast(f);\n            URational ur(r.first, r.second);\n            URationalValue fn;\n            fn.value_.push_back(ur);\n            image.exifData().add(ExifKey(\"Exif.Photo.FNumber\"), &fn);\n            ur = exposureTime(canonEv(shutterSpeed));\n            URationalValue et;\n            et.value_.push_back(ur);\n            image.exifData().add(ExifKey(\"Exif.Photo.ExposureTime\"), &et);\n        }\n    } ", "target": 0}
{"code": "static void buffer_pipe_buf_get(struct pipe_inode_info *pipe,\n\t\t\t\tstruct pipe_buffer *buf)\n{\n\tstruct buffer_ref *ref = (struct buffer_ref *)buf->private;\n\tref->ref++;\n}", "target": 1}
{"code": "_XcursorAddPathElt (char *path, const char *elt, int len)\n{\n    size_t    pathlen = strlen (path);\n    if (path[0] == '\\0' || path[pathlen - 1] != '/')\n    {\n\tstrcat (path, \"/\");\n\tpathlen++;\n    }\n    if (len == -1)\n\tlen = strlen (elt);\n    while (len && elt[0] == '/')\n    {\n\telt++;\n\tlen--;\n    }\n    strncpy (path + pathlen, elt, len);\n    path[pathlen + len] = '\\0';\n}", "target": 0}
{"code": "static void nfs_set_open_stateid_locked(struct nfs4_state *state, nfs4_stateid *stateid, int open_flags)\n{\n\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) == 0)\n\t\tmemcpy(state->stateid.data, stateid->data, sizeof(state->stateid.data));\n\tmemcpy(state->open_stateid.data, stateid->data, sizeof(state->open_stateid.data));\n\tswitch (open_flags) {\n\t\tcase FMODE_READ:\n\t\t\tset_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tset_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tset_bit(NFS_O_RDWR_STATE, &state->flags);\n\t}\n}", "target": 1}
{"code": "static void irda_connect_indication(void *instance, void *sap,\n\t\t\t\t    struct qos_info *qos, __u32 max_sdu_size,\n\t\t\t\t    __u8 max_header_size, struct sk_buff *skb)\n{\n\tstruct irda_sock *self;\n\tstruct sock *sk;\n\tself = instance;\n\tIRDA_DEBUG(2, \"%s(%p)\\n\", __func__, self);\n\tsk = instance;\n\tif (sk == NULL) {\n\t\tdev_kfree_skb(skb);\n\t\treturn;\n\t}\n\tself->max_header_size = max_header_size;\n\tself->max_sdu_size_tx = max_sdu_size;\n\tswitch (sk->sk_type) {\n\tcase SOCK_STREAM:\n\t\tif (max_sdu_size != 0) {\n\t\t\tIRDA_ERROR(\"%s: max_sdu_size must be 0\\n\",\n\t\t\t\t   __func__);\n\t\t\tkfree_skb(skb);\n\t\t\treturn;\n\t\t}\n\t\tself->max_data_size = irttp_get_max_seg_size(self->tsap);\n\t\tbreak;\n\tcase SOCK_SEQPACKET:\n\t\tif (max_sdu_size == 0) {\n\t\t\tIRDA_ERROR(\"%s: max_sdu_size cannot be 0\\n\",\n\t\t\t\t   __func__);\n\t\t\tkfree_skb(skb);\n\t\t\treturn;\n\t\t}\n\t\tself->max_data_size = max_sdu_size;\n\t\tbreak;\n\tdefault:\n\t\tself->max_data_size = irttp_get_max_seg_size(self->tsap);\n\t}\n\tIRDA_DEBUG(2, \"%s(), max_data_size=%d\\n\", __func__,\n\t\t   self->max_data_size);\n\tmemcpy(&self->qos_tx, qos, sizeof(struct qos_info));\n\tskb_queue_tail(&sk->sk_receive_queue, skb);\n\tsk->sk_state_change(sk);\n}", "target": 0}
{"code": "static long __snd_timer_user_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct snd_timer_user *tu;\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *p = argp;\n\ttu = file->private_data;\n\tswitch (cmd) {\n\tcase SNDRV_TIMER_IOCTL_PVERSION:\n\t\treturn put_user(SNDRV_TIMER_VERSION, p) ? -EFAULT : 0;\n\tcase SNDRV_TIMER_IOCTL_NEXT_DEVICE:\n\t\treturn snd_timer_user_next_device(argp);\n\tcase SNDRV_TIMER_IOCTL_TREAD:\n\t{\n\t\tint xarg;\n\t\tif (tu->timeri)\t\n\t\t\treturn -EBUSY;\n\t\tif (get_user(xarg, p))\n\t\t\treturn -EFAULT;\n\t\ttu->tread = xarg ? 1 : 0;\n\t\treturn 0;\n\t}\n\tcase SNDRV_TIMER_IOCTL_GINFO:\n\t\treturn snd_timer_user_ginfo(file, argp);\n\tcase SNDRV_TIMER_IOCTL_GPARAMS:\n\t\treturn snd_timer_user_gparams(file, argp);\n\tcase SNDRV_TIMER_IOCTL_GSTATUS:\n\t\treturn snd_timer_user_gstatus(file, argp);\n\tcase SNDRV_TIMER_IOCTL_SELECT:\n\t\treturn snd_timer_user_tselect(file, argp);\n\tcase SNDRV_TIMER_IOCTL_INFO:\n\t\treturn snd_timer_user_info(file, argp);\n\tcase SNDRV_TIMER_IOCTL_PARAMS:\n\t\treturn snd_timer_user_params(file, argp);\n\tcase SNDRV_TIMER_IOCTL_STATUS:\n\t\treturn snd_timer_user_status(file, argp);\n\tcase SNDRV_TIMER_IOCTL_START:\n\tcase SNDRV_TIMER_IOCTL_START_OLD:\n\t\treturn snd_timer_user_start(file);\n\tcase SNDRV_TIMER_IOCTL_STOP:\n\tcase SNDRV_TIMER_IOCTL_STOP_OLD:\n\t\treturn snd_timer_user_stop(file);\n\tcase SNDRV_TIMER_IOCTL_CONTINUE:\n\tcase SNDRV_TIMER_IOCTL_CONTINUE_OLD:\n\t\treturn snd_timer_user_continue(file);\n\tcase SNDRV_TIMER_IOCTL_PAUSE:\n\tcase SNDRV_TIMER_IOCTL_PAUSE_OLD:\n\t\treturn snd_timer_user_pause(file);\n\t}\n\treturn -ENOTTY;\n}", "target": 0}
{"code": "vips_foreign_load_gif_scan_image( VipsForeignLoadGif *gif ) \n{\n\tVipsObjectClass *class = VIPS_OBJECT_GET_CLASS( gif );\n\tGifFileType *file = gif->file;\n\tColorMapObject *map = file->Image.ColorMap ?\n\t\tfile->Image.ColorMap : file->SColorMap;\n\tGifByteType *extension;\n\tif( DGifGetImageDesc( gif->file ) == GIF_ERROR ) {\n\t\tvips_foreign_load_gif_error( gif ); \n\t\treturn( -1 );\n\t}\n\tif( file->Image.Left < 0 ||\n\t\tfile->Image.Width < 1 ||\n\t\tfile->Image.Width > 10000 ||\n\t\tfile->Image.Left + file->Image.Width > file->SWidth ||\n\t\tfile->Image.Top < 0 ||\n\t\tfile->Image.Height < 1 ||\n\t\tfile->Image.Height > 10000 ||\n\t\tfile->Image.Top + file->Image.Height > file->SHeight ) {\n\t\tvips_error( class->nickname, \"%s\", _( \"bad frame size\" ) ); \n\t\treturn( -1 ); \n\t}\n\tif( !gif->has_colour &&\n\t\tmap ) {\n\t\tint i;\n\t\tfor( i = 0; i < map->ColorCount; i++ ) \n\t\t\tif( map->Colors[i].Red != map->Colors[i].Green ||\n\t\t\t\tmap->Colors[i].Green != map->Colors[i].Blue ) {\n\t\t\t\tgif->has_colour = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\tdo {\n\t\tif( vips_foreign_load_gif_code_next( gif, &extension ) ) \n\t\t\treturn( -1 );\n\t} while( extension != NULL );\n\treturn( 0 );\n}", "target": 1}
{"code": "reg_match_pos(VALUE re, VALUE *strp, long pos)\n{\n    VALUE str = *strp;\n    if (NIL_P(str)) {\n\trb_backref_set(Qnil);\n\treturn -1;\n    }\n    *strp = str = reg_operand(str, TRUE);\n    if (pos != 0) {\n\tif (pos < 0) {\n\t    VALUE l = rb_str_length(str);\n\t    pos += NUM2INT(l);\n\t    if (pos < 0) {\n\t\treturn pos;\n\t    }\n\t}\n\tpos = rb_str_offset(str, pos);\n    }\n    return rb_reg_search(re, str, pos, 0);\n}", "target": 0}
{"code": "tiff12_print_page(gx_device_printer * pdev, gp_file * file)\n{\n    gx_device_tiff *const tfdev = (gx_device_tiff *)pdev;\n    int code;\n    if (gdev_prn_file_is_new(pdev)) {\n        tfdev->tif = tiff_from_filep(pdev, pdev->dname, file, tfdev->BigEndian, tfdev->UseBigTIFF);\n        if (!tfdev->tif)\n            return_error(gs_error_invalidfileaccess);\n    }\n    code = gdev_tiff_begin_page(tfdev, file);\n    if (code < 0)\n        return code;\n    TIFFSetField(tfdev->tif, TIFFTAG_BITSPERSAMPLE, 4);\n    tiff_set_rgb_fields(tfdev);\n    TIFFCheckpointDirectory(tfdev->tif);\n    {\n        int y;\n        int size = gdev_prn_raster(pdev);\n        byte *data = gs_alloc_bytes(pdev->memory, size, \"tiff12_print_page\");\n        if (data == 0)\n            return_error(gs_error_VMerror);\n        memset(data, 0, size);\n        for (y = 0; y < pdev->height; ++y) {\n            const byte *src;\n            byte *dest;\n            int x;\n            code = gdev_prn_copy_scan_lines(pdev, y, data, size);\n            if (code < 0)\n                break;\n            for (src = data, dest = data, x = 0; x < size;\n                 src += 6, dest += 3, x += 6\n                ) {\n                dest[0] = (src[0] & 0xf0) | (src[1] >> 4);\n                dest[1] = (src[2] & 0xf0) | (src[3] >> 4);\n                dest[2] = (src[4] & 0xf0) | (src[5] >> 4);\n            }\n            TIFFWriteScanline(tfdev->tif, data, y, 0);\n        }\n        gs_free_object(pdev->memory, data, \"tiff12_print_page\");\n        TIFFWriteDirectory(tfdev->tif);\n    }\n    return code;\n}", "target": 1}
{"code": "static int set_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)\n{\n\treturn usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),\n\t\t\t       RTL8150_REQ_SET_REGS, RTL8150_REQT_WRITE,\n\t\t\t       indx, 0, data, size, 500);\n}", "target": 1}
{"code": "int db__close(void)\n{\n\tsubhier_clean(&db.subs);\n\tretain__clean(&db.retains);\n\tdb__msg_store_clean();\n\treturn MOSQ_ERR_SUCCESS;\n}", "target": 1}
{"code": "int mbedtls_ssl_resend( mbedtls_ssl_context *ssl )\n{\n    int ret = 0;\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> mbedtls_ssl_resend\" ) );\n    ret = mbedtls_ssl_flight_transmit( ssl );\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= mbedtls_ssl_resend\" ) );\n    return( ret );\n}", "target": 0}
{"code": "static bool pb_release_union_field(pb_istream_t *stream, pb_field_iter_t *field)\n{\n    pb_field_iter_t old_field = *field;\n    pb_size_t old_tag = *(pb_size_t*)field->pSize; \n    pb_size_t new_tag = field->tag; \n    if (old_tag == 0)\n        return true; \n    if (old_tag == new_tag)\n        return true; \n    if (!pb_field_iter_find(&old_field, old_tag))\n        PB_RETURN_ERROR(stream, \"invalid union tag\");\n    pb_release_single_field(&old_field);\n    return true;\n}", "target": 1}
{"code": "    int MemIo::seek(int64 offset, Position pos )\n    {\n        int64 newIdx = 0;\n        switch (pos) {\n            case BasicIo::cur:\n                newIdx = p_->idx_ + offset;\n                break;\n            case BasicIo::beg:\n                newIdx = offset;\n                break;\n            case BasicIo::end:\n                newIdx = p_->size_ + offset;\n                break;\n        }\n        if (newIdx < 0)\n            return 1;\n        p_->idx_ = static_cast<long>(newIdx);   \n        p_->eof_ = false;\n        return 0;\n    }", "target": 1}
{"code": "void blk_cleanup_queue(struct request_queue *q)\n{\n\tmutex_lock(&q->sysfs_lock);\n\tblk_set_queue_dying(q);\n\tblk_queue_flag_set(QUEUE_FLAG_NOMERGES, q);\n\tblk_queue_flag_set(QUEUE_FLAG_NOXMERGES, q);\n\tblk_queue_flag_set(QUEUE_FLAG_DYING, q);\n\tmutex_unlock(&q->sysfs_lock);\n\tblk_freeze_queue(q);\n\trq_qos_exit(q);\n\tblk_queue_flag_set(QUEUE_FLAG_DEAD, q);\n\tblk_flush_integrity();\n\tdel_timer_sync(&q->backing_dev_info->laptop_mode_wb_timer);\n\tblk_sync_queue(q);\n\tif (queue_is_mq(q))\n\t\tblk_mq_exit_queue(q);\n\tpercpu_ref_exit(&q->q_usage_counter);\n\tblk_put_queue(q);\n}", "target": 1}
{"code": "static void slab_bug(struct kmem_cache *s, char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_err(\"=============================================================================\\n\");\n\tpr_err(\"BUG %s (%s): %pV\\n\", s->name, print_tainted(), &vaf);\n\tpr_err(\"-----------------------------------------------------------------------------\\n\\n\");\n\tadd_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);\n\tva_end(args);\n}", "target": 0}
{"code": "xsltNewKeyDef(const xmlChar *name, const xmlChar *nameURI) {\n    xsltKeyDefPtr cur;\n    cur = (xsltKeyDefPtr) xmlMalloc(sizeof(xsltKeyDef));\n    if (cur == NULL) {\n\txsltTransformError(NULL, NULL, NULL,\n\t\t\"xsltNewKeyDef : malloc failed\\n\");\n\treturn(NULL);\n    }\n    memset(cur, 0, sizeof(xsltKeyDef));\n    if (name != NULL)\n\tcur->name = xmlStrdup(name);\n    if (nameURI != NULL)\n\tcur->nameURI = xmlStrdup(nameURI);\n    cur->nsList = NULL;\n    return(cur);\n}", "target": 0}
{"code": "static void m_stop(struct seq_file *m, void *v)\n{\n\tstruct proc_maps_private *priv = m->private;\n\tstruct vm_area_struct *vma = v;\n\tvma_stop(priv, vma);\n\tif (priv->task)\n\t\tput_task_struct(priv->task);\n}", "target": 1}
{"code": "static int calcstepsizes(uint_fast16_t refstepsize, int numrlvls,\n  uint_fast16_t *stepsizes)\n{\n\tint bandno;\n\tint numbands;\n\tuint_fast16_t expn;\n\tuint_fast16_t mant;\n\texpn = JPC_QCX_GETEXPN(refstepsize);\n\tmant = JPC_QCX_GETMANT(refstepsize);\n\tnumbands = 3 * numrlvls - 2;\n\tfor (bandno = 0; bandno < numbands; ++bandno) {\n\t\tstepsizes[bandno] = JPC_QCX_MANT(mant) | JPC_QCX_EXPN(expn + (bandno + 2) / 3);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int convertCompoundSelectToSubquery(Walker *pWalker, Select *p){\n  int i;\n  Select *pNew;\n  Select *pX;\n  sqlite3 *db;\n  struct ExprList_item *a;\n  SrcList *pNewSrc;\n  Parse *pParse;\n  Token dummy;\n  if( p->pPrior==0 ) return WRC_Continue;\n  if( p->pOrderBy==0 ) return WRC_Continue;\n  for(pX=p; pX && (pX->op==TK_ALL || pX->op==TK_SELECT); pX=pX->pPrior){}\n  if( pX==0 ) return WRC_Continue;\n  a = p->pOrderBy->a;\n  for(i=p->pOrderBy->nExpr-1; i>=0; i--){\n    if( a[i].pExpr->flags & EP_Collate ) break;\n  }\n  if( i<0 ) return WRC_Continue;\n  pParse = pWalker->pParse;\n  db = pParse->db;\n  pNew = sqlite3DbMallocZero(db, sizeof(*pNew) );\n  if( pNew==0 ) return WRC_Abort;\n  memset(&dummy, 0, sizeof(dummy));\n  pNewSrc = sqlite3SrcListAppendFromTerm(pParse,0,0,0,&dummy,pNew,0,0);\n  if( pNewSrc==0 ) return WRC_Abort;\n  *pNew = *p;\n  p->pSrc = pNewSrc;\n  p->pEList = sqlite3ExprListAppend(pParse, 0, sqlite3Expr(db, TK_ASTERISK, 0));\n  p->op = TK_SELECT;\n  p->pWhere = 0;\n  pNew->pGroupBy = 0;\n  pNew->pHaving = 0;\n  pNew->pOrderBy = 0;\n  p->pPrior = 0;\n  p->pNext = 0;\n  p->pWith = 0;\n  p->selFlags &= ~SF_Compound;\n  assert( (p->selFlags & SF_Converted)==0 );\n  p->selFlags |= SF_Converted;\n  assert( pNew->pPrior!=0 );\n  pNew->pPrior->pNext = pNew;\n  pNew->pLimit = 0;\n  return WRC_Continue;\n}", "target": 0}
{"code": "static inline int pmd_none_or_trans_huge_or_clear_bad(pmd_t *pmd)\n{\n\tpmd_t pmdval = pmd_read_atomic(pmd);\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tbarrier();\n#endif\n\tif (pmd_none(pmdval))\n\t\treturn 1;\n\tif (unlikely(pmd_bad(pmdval))) {\n\t\tif (!pmd_trans_huge(pmdval))\n\t\t\tpmd_clear_bad(pmd);\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int cipso_v4_delopt(struct ip_options **opt_ptr)\n{\n\tint hdr_delta = 0;\n\tstruct ip_options *opt = *opt_ptr;\n\tif (opt->srr || opt->rr || opt->ts || opt->router_alert) {\n\t\tu8 cipso_len;\n\t\tu8 cipso_off;\n\t\tunsigned char *cipso_ptr;\n\t\tint iter;\n\t\tint optlen_new;\n\t\tcipso_off = opt->cipso - sizeof(struct iphdr);\n\t\tcipso_ptr = &opt->__data[cipso_off];\n\t\tcipso_len = cipso_ptr[1];\n\t\tif (opt->srr > opt->cipso)\n\t\t\topt->srr -= cipso_len;\n\t\tif (opt->rr > opt->cipso)\n\t\t\topt->rr -= cipso_len;\n\t\tif (opt->ts > opt->cipso)\n\t\t\topt->ts -= cipso_len;\n\t\tif (opt->router_alert > opt->cipso)\n\t\t\topt->router_alert -= cipso_len;\n\t\topt->cipso = 0;\n\t\tmemmove(cipso_ptr, cipso_ptr + cipso_len,\n\t\t\topt->optlen - cipso_off - cipso_len);\n\t\titer = 0;\n\t\toptlen_new = 0;\n\t\twhile (iter < opt->optlen)\n\t\t\tif (opt->__data[iter] != IPOPT_NOP) {\n\t\t\t\titer += opt->__data[iter + 1];\n\t\t\t\toptlen_new = iter;\n\t\t\t} else\n\t\t\t\titer++;\n\t\thdr_delta = opt->optlen;\n\t\topt->optlen = (optlen_new + 3) & ~3;\n\t\thdr_delta -= opt->optlen;\n\t} else {\n\t\t*opt_ptr = NULL;\n\t\thdr_delta = opt->optlen;\n\t\tkfree(opt);\n\t}\n\treturn hdr_delta;\n}", "target": 1}
{"code": "static int IntensityCompare(const void *x,const void *y)\n{\n  double\n    intensity;\n  PixelInfo\n    *color_1,\n    *color_2;\n  color_1=(PixelInfo *) x;\n  color_2=(PixelInfo *) y;\n  intensity=GetPixelInfoIntensity((const Image *) NULL,color_1)-\n    GetPixelInfoIntensity((const Image *) NULL,color_2);\n  return((int) intensity);\n}", "target": 1}
{"code": "static int hash_setkey(void *private, const u8 *key, unsigned int keylen)\n{\n\treturn crypto_ahash_setkey(private, key, keylen);\n}", "target": 0}
{"code": "ByteVector ByteVector::mid(uint index, uint length) const\n{\n  ByteVector v;\n  if(index > size())\n    return v;\n  ConstIterator endIt;\n  if(length < 0xffffffff && length + index < size())\n    endIt = d->data.begin() + index + length;\n  else\n    endIt = d->data.end();\n  v.d->data.insert(v.d->data.begin(), ConstIterator(d->data.begin() + index), endIt);\n  v.d->size = v.d->data.size();\n  return v;\n}", "target": 1}
{"code": "cdf_read_header(const cdf_info_t *info, cdf_header_t *h)\n{\n\tchar buf[512];\n\t(void)memcpy(cdf_bo.s, \"\\01\\02\\03\\04\", 4);\n\tif (cdf_read(info, (off_t)0, buf, sizeof(buf)) == -1)\n\t\treturn -1;\n\tcdf_unpack_header(h, buf);\n\tcdf_swap_header(h);\n\tif (h->h_magic != CDF_MAGIC) {\n\t\tDPRINTF((\"Bad magic 0x%\" INT64_T_FORMAT \"x != 0x%\"\n\t\t    INT64_T_FORMAT \"x\\n\",\n\t\t    (unsigned long long)h->h_magic,\n\t\t    (unsigned long long)CDF_MAGIC));\n\t\tgoto out;\n\t}\n\tif (h->h_sec_size_p2 > 20) {\n\t\tDPRINTF((\"Bad sector size 0x%u\\n\", h->h_sec_size_p2));\n\t\tgoto out;\n\t}\n\tif (h->h_short_sec_size_p2 > 20) {\n\t\tDPRINTF((\"Bad short sector size 0x%u\\n\",\n\t\t    h->h_short_sec_size_p2));\n\t\tgoto out;\n\t}\n\treturn 0;\nout:\n\terrno = EFTYPE;\n\treturn -1;\n}", "target": 0}
{"code": "static zend_long firebird_handle_doer(pdo_dbh_t *dbh, const char *sql, size_t sql_len) \n{\n\tpdo_firebird_db_handle *H = (pdo_firebird_db_handle *)dbh->driver_data;\n\tisc_stmt_handle stmt = PDO_FIREBIRD_HANDLE_INITIALIZER;\n\tstatic char const info_count[] = { isc_info_sql_records };\n\tchar result[64];\n\tint ret = 0;\n\tXSQLDA in_sqlda, out_sqlda;\n\tin_sqlda.version = out_sqlda.version = PDO_FB_SQLDA_VERSION;\n\tin_sqlda.sqld = out_sqlda.sqld = 0;\n\tout_sqlda.sqln = 1;\n\tif (!firebird_alloc_prepare_stmt(dbh, sql, sql_len, &out_sqlda, &stmt, 0)) {\n\t\treturn -1;\n\t}\n\tif (isc_dsql_execute2(H->isc_status, &H->tr, &stmt, PDO_FB_SQLDA_VERSION, &in_sqlda, &out_sqlda)) {\n\t\tRECORD_ERROR(dbh);\n\t\tret = -1;\n\t\tgoto free_statement;\n\t}\n\tif (isc_dsql_sql_info(H->isc_status, &stmt, sizeof(info_count), const_cast(info_count),\n\t\t\tsizeof(result),\tresult)) {\n\t\tRECORD_ERROR(dbh);\n\t\tret = -1;\n\t\tgoto free_statement;\n\t}\n\tif (result[0] == isc_info_sql_records) {\n\t\tunsigned i = 3, result_size = isc_vax_integer(&result[1],2);\n\t\twhile (result[i] != isc_info_end && i < result_size) {\n\t\t\tshort len = (short)isc_vax_integer(&result[i+1],2);\n\t\t\tif (result[i] != isc_info_req_select_count) {\n\t\t\t\tret += isc_vax_integer(&result[i+3],len);\n\t\t\t}\n\t\t\ti += len+3;\n\t\t}\n\t}\n\tif (dbh->auto_commit && isc_commit_retaining(H->isc_status, &H->tr)) {\n\t\tRECORD_ERROR(dbh);\n\t}\nfree_statement:\n\tif (isc_dsql_free_statement(H->isc_status, &stmt, DSQL_drop)) {\n\t\tRECORD_ERROR(dbh);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "void RemoteFsDevice::saveProperties(const DeviceOptions &newOpts, const Details &nd)\n{\n    bool connected=isConnected();\n    if (configured && (!connected || opts==newOpts) && (connected || details==nd)) {\n        return;\n    }\n    bool isLocal=details.isLocalFile();\n    if (connected) {\n        if (!configured) {\n            details.configured=configured=true;\n            details.save();\n        }\n        if (opts.useCache!=newOpts.useCache) {\n            if (opts.useCache) {\n                saveCache();\n            } else if (opts.useCache && !newOpts.useCache) {\n                removeCache();\n            }\n        }\n        opts=newOpts;\n        writeOpts(settingsFileName(), opts, true);\n    }\n    if (!connected || isLocal) {\n        Details newDetails=nd;\n        Details oldDetails=details;\n        bool newName=!oldDetails.name.isEmpty() && oldDetails.name!=newDetails.name;\n        bool newDir=oldDetails.url.path()!=newDetails.url.path();\n        if (isLocal && newDir && opts.useCache) {\n            removeCache();\n        }\n        details=newDetails;\n        details.configured=configured=true;\n        details.save();\n        if (newName) {\n            if (!details.isLocalFile()) {\n                QString oldMount=mountPoint(oldDetails, false);\n                if (!oldMount.isEmpty() && QDir(oldMount).exists()) {\n                    ::rmdir(QFile::encodeName(oldMount).constData());\n                }\n            }\n            setData(details.name);\n            renamed(oldDetails.name, details.name);\n            deviceId=createUdi(details.name);\n            emit udiChanged();\n            m_itemData=details.name;\n            setStatusMessage(QString());\n        }\n        if (isLocal && newDir && scanned) {\n            rescan(true);\n        }\n    }\n    emit configurationChanged();\n}", "target": 0}
{"code": "  char *strndup(const char *str, size_t size)\n  {\n    char *copy;\n    size_t len = strlen(str);\n    if (len > size)\n      len = size;\n    copy = (char *)REDIRECT_MALLOC(len + 1);\n    if (copy == NULL) {\n      errno = ENOMEM;\n      return NULL;\n    }\n    BCOPY(str, copy, len);\n    copy[len] = '\\0';\n    return copy;\n  }", "target": 0}
{"code": "static int may_create_in_sticky(struct dentry * const dir,\n\t\t\t\tstruct inode * const inode)\n{\n\tif ((!sysctl_protected_fifos && S_ISFIFO(inode->i_mode)) ||\n\t    (!sysctl_protected_regular && S_ISREG(inode->i_mode)) ||\n\t    likely(!(dir->d_inode->i_mode & S_ISVTX)) ||\n\t    uid_eq(inode->i_uid, dir->d_inode->i_uid) ||\n\t    uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn 0;\n\tif (likely(dir->d_inode->i_mode & 0002) ||\n\t    (dir->d_inode->i_mode & 0020 &&\n\t     ((sysctl_protected_fifos >= 2 && S_ISFIFO(inode->i_mode)) ||\n\t      (sysctl_protected_regular >= 2 && S_ISREG(inode->i_mode))))) {\n\t\tconst char *operation = S_ISFIFO(inode->i_mode) ?\n\t\t\t\t\t\"sticky_create_fifo\" :\n\t\t\t\t\t\"sticky_create_regular\";\n\t\taudit_log_path_denied(AUDIT_ANOM_CREAT, operation);\n\t\treturn -EACCES;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "set_range(bitstr_t *bits, int low, int high, int start, int stop, int step) {\n\tDebug(DPARS|DEXT, (\"set_range(?,%d,%d,%d,%d,%d)\\n\",\n\t\t\t   low, high, start, stop, step))\n\tif (start < low || stop > high)\n\t\treturn (EOF);\n\tstart -= low;\n\tstop -= low;\n\tif (step == 1) {\n\t\tbit_nset(bits, start, stop);\n\t} else {\n\t\tfor (int i = start; i <= stop; i += step)\n\t\t\tbit_set(bits, i);\n\t}\n\treturn (OK);\n}", "target": 1}
{"code": "RedVDIReadBuf::~RedVDIReadBuf()\n{\n    dev->priv->num_read_buf--;\n    if (dev->priv->agent_attached) {\n       dev->wakeup();\n    }\n}", "target": 0}
{"code": "static size_t vnc_client_read_plain(VncState *vs)\n{\n    size_t ret;\n    VNC_DEBUG(\"Read plain %p size %zd offset %zd\\n\",\n              vs->input.buffer, vs->input.capacity, vs->input.offset);\n    buffer_reserve(&vs->input, 4096);\n    ret = vnc_client_read_buf(vs, buffer_end(&vs->input), 4096);\n    if (!ret)\n        return 0;\n    vs->input.offset += ret;\n    return ret;\n}", "target": 0}
{"code": "int __isolate_free_page(struct page *page, unsigned int order)\n{\n\tunsigned long watermark;\n\tstruct zone *zone;\n\tint mt;\n\tBUG_ON(!PageBuddy(page));\n\tzone = page_zone(page);\n\tmt = get_pageblock_migratetype(page);\n\tif (!is_migrate_isolate(mt)) {\n\t\twatermark = min_wmark_pages(zone) + (1UL << order);\n\t\tif (!zone_watermark_ok(zone, 0, watermark, 0, ALLOC_CMA))\n\t\t\treturn 0;\n\t\t__mod_zone_freepage_state(zone, -(1UL << order), mt);\n\t}\n\tlist_del(&page->lru);\n\tzone->free_area[order].nr_free--;\n\trmv_page_order(page);\n\tif (order >= pageblock_order - 1) {\n\t\tstruct page *endpage = page + (1 << order) - 1;\n\t\tfor (; page < endpage; page += pageblock_nr_pages) {\n\t\t\tint mt = get_pageblock_migratetype(page);\n\t\t\tif (!is_migrate_isolate(mt) && !is_migrate_cma(mt)\n\t\t\t    && !is_migrate_highatomic(mt))\n\t\t\t\tset_pageblock_migratetype(page,\n\t\t\t\t\t\t\t  MIGRATE_MOVABLE);\n\t\t}\n\t}\n\treturn 1UL << order;\n}", "target": 0}
{"code": "static int ep_loop_check_proc(void *priv, void *cookie, int call_nests)\n{\n\tint error = 0;\n\tstruct file *file = priv;\n\tstruct eventpoll *ep = file->private_data;\n\tstruct eventpoll *ep_tovisit;\n\tstruct rb_node *rbp;\n\tstruct epitem *epi;\n\tmutex_lock_nested(&ep->mtx, call_nests + 1);\n\tep->visited = 1;\n\tlist_add(&ep->visited_list_link, &visited_list);\n\tfor (rbp = rb_first_cached(&ep->rbr); rbp; rbp = rb_next(rbp)) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\t\tif (unlikely(is_file_epoll(epi->ffd.file))) {\n\t\t\tep_tovisit = epi->ffd.file->private_data;\n\t\t\tif (ep_tovisit->visited)\n\t\t\t\tcontinue;\n\t\t\terror = ep_call_nested(&poll_loop_ncalls,\n\t\t\t\t\tep_loop_check_proc, epi->ffd.file,\n\t\t\t\t\tep_tovisit, current);\n\t\t\tif (error != 0)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (list_empty(&epi->ffd.file->f_tfile_llink))\n\t\t\t\tlist_add(&epi->ffd.file->f_tfile_llink,\n\t\t\t\t\t &tfile_check_list);\n\t\t}\n\t}\n\tmutex_unlock(&ep->mtx);\n\treturn error;\n}", "target": 1}
{"code": "uint32_t read32(uint8_t* arr, int pos,  int swapBytes)\n{\n    if(!swapBytes) {\n        return (arr[pos]   << 24) |\n               (arr[pos+1] << 16) |\n               (arr[pos+2] << 8) |\n                arr[pos+3];\n    }\n    return arr[pos] |\n           (arr[pos+1] << 8) |\n           (arr[pos+2] << 16) |\n           (arr[pos+3] << 24);\n}", "target": 0}
{"code": "static void check_preempt_wakeup(struct rq *rq, struct task_struct *p)\n{\n\tstruct task_struct *curr = rq->curr;\n\tstruct cfs_rq *cfs_rq = task_cfs_rq(curr);\n\tstruct sched_entity *se = &curr->se, *pse = &p->se;\n\tunsigned long gran;\n\tif (unlikely(rt_prio(p->prio))) {\n\t\tupdate_rq_clock(rq);\n\t\tupdate_curr(cfs_rq);\n\t\tresched_task(curr);\n\t\treturn;\n\t}\n\tcfs_rq_of(pse)->next = pse;\n\tif (unlikely(p->policy == SCHED_BATCH))\n\t\treturn;\n\tif (!sched_feat(WAKEUP_PREEMPT))\n\t\treturn;\n\twhile (!is_same_group(se, pse)) {\n\t\tse = parent_entity(se);\n\t\tpse = parent_entity(pse);\n\t}\n\tgran = sysctl_sched_wakeup_granularity;\n\tif (unlikely(se->load.weight > NICE_0_LOAD))\n\t\tgran = calc_delta_fair(gran, &se->load);\n\tif (pse->vruntime + gran < se->vruntime)\n\t\tresched_task(curr);\n}", "target": 0}
{"code": " void PrintWebViewHelper::OnPrintingDone(bool success) {\n  CHECK_LE(ipc_nesting_level_, 1);\n   notify_browser_of_print_failure_ = false;\n   if (!success)\n     LOG(ERROR) << \"Failure in OnPrintingDone\";\n  DidFinishPrinting(success ? OK : FAIL_PRINT);\n}", "target": 0}
{"code": "int ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d,\n                                 int n)\n{\n    int al = -1;\n    unsigned char *ptmp = *p;\n    if (ssl_scan_clienthello_tlsext(s, p, d, n, &al) <= 0) {\n        ssl3_send_alert(s, SSL3_AL_FATAL, al);\n        return 0;\n    }\n    if (ssl_check_clienthello_tlsext_early(s) <= 0) {\n        SSLerr(SSL_F_SSL_PARSE_CLIENTHELLO_TLSEXT, SSL_R_CLIENTHELLO_TLSEXT);\n        return 0;\n    }\n    custom_ext_init(&s->cert->srv_ext);\n    if (ssl_scan_clienthello_custom_tlsext(s, ptmp, d + n, &al) <= 0) {\n        ssl3_send_alert(s, SSL3_AL_FATAL, al);\n        return 0;\n    }\n    return 1;\n}", "target": 0}
{"code": "static uint8_t avrcp_handle_get_play_status(struct avrcp *session,\n\t\t\t\t\t\tstruct avrcp_header *pdu,\n\t\t\t\t\t\tuint8_t transaction)\n{\n\tstruct avrcp_player *player = target_get_player(session);\n\tuint16_t len = ntohs(pdu->params_len);\n\tuint32_t position;\n\tuint32_t duration;\n\tif (len != 0) {\n\t\tpdu->params_len = htons(1);\n\t\tpdu->params[0] = AVRCP_STATUS_INVALID_PARAM;\n\t\treturn AVC_CTYPE_REJECTED;\n\t}\n\tposition = player_get_position(player);\n\tduration = player_get_duration(player);\n\tposition = htonl(position);\n\tduration = htonl(duration);\n\tmemcpy(&pdu->params[0], &duration, 4);\n\tmemcpy(&pdu->params[4], &position, 4);\n\tpdu->params[8] = player_get_status(player);\n\tpdu->params_len = htons(9);\n\treturn AVC_CTYPE_STABLE;\n}", "target": 0}
{"code": "LuaSettings::LuaSettings(const std::string &filename, bool write_allowed) :\n\tm_filename(filename),\n\tm_is_own_settings(true),\n\tm_write_allowed(write_allowed)\n{\n\tm_settings = new Settings();\n\tm_settings->readConfigFile(filename.c_str());\n}", "target": 0}
{"code": "ftrace_regex_lseek(struct file *file, loff_t offset, int whence)\n{\n\tloff_t ret;\n\tif (file->f_mode & FMODE_READ)\n\t\tret = seq_lseek(file, offset, whence);\n\telse\n\t\tfile->f_pos = ret = 1;\n\treturn ret;\n}", "target": 1}
{"code": "static int handle_rdmsr(struct kvm_vcpu *vcpu)\n{\n\tu32 ecx = vcpu->arch.regs[VCPU_REGS_RCX];\n\tu64 data;\n\tif (vmx_get_msr(vcpu, ecx, &data)) {\n\t\ttrace_kvm_msr_read_ex(ecx);\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\ttrace_kvm_msr_read(ecx, data);\n\tvcpu->arch.regs[VCPU_REGS_RAX] = data & -1u;\n\tvcpu->arch.regs[VCPU_REGS_RDX] = (data >> 32) & -1u;\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}", "target": 0}
{"code": "static void nfs4_open_confirm_release(void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\tstruct nfs4_state *state = NULL;\n\tif (data->cancelled == 0)\n\t\tgoto out_free;\n\tif (!data->rpc_done)\n\t\tgoto out_free;\n\tstate = nfs4_opendata_to_nfs4_state(data);\n\tif (!IS_ERR(state))\n\t\tnfs4_close_state(&data->path, state, data->o_arg.open_flags);\nout_free:\n\tnfs4_opendata_put(data);\n}", "target": 1}
{"code": "static int inet6_fill_ifaddr(struct sk_buff *skb, struct inet6_ifaddr *ifa,\n\t\t\t     u32 portid, u32 seq, int event, unsigned int flags)\n{\n\tstruct nlmsghdr  *nlh;\n\tu32 preferred, valid;\n\tnlh = nlmsg_put(skb, portid, seq, event, sizeof(struct ifaddrmsg), flags);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\tput_ifaddrmsg(nlh, ifa->prefix_len, ifa->flags, rt_scope(ifa->scope),\n\t\t      ifa->idev->dev->ifindex);\n\tif (!(ifa->flags&IFA_F_PERMANENT)) {\n\t\tpreferred = ifa->prefered_lft;\n\t\tvalid = ifa->valid_lft;\n\t\tif (preferred != INFINITY_LIFE_TIME) {\n\t\t\tlong tval = (jiffies - ifa->tstamp)/HZ;\n\t\t\tif (preferred > tval)\n\t\t\t\tpreferred -= tval;\n\t\t\telse\n\t\t\t\tpreferred = 0;\n\t\t\tif (valid != INFINITY_LIFE_TIME) {\n\t\t\t\tif (valid > tval)\n\t\t\t\t\tvalid -= tval;\n\t\t\t\telse\n\t\t\t\t\tvalid = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tpreferred = INFINITY_LIFE_TIME;\n\t\tvalid = INFINITY_LIFE_TIME;\n\t}\n\tif (!ipv6_addr_any(&ifa->peer_addr)) {\n\t\tif (nla_put(skb, IFA_LOCAL, 16, &ifa->addr) < 0 ||\n\t\t    nla_put(skb, IFA_ADDRESS, 16, &ifa->peer_addr) < 0)\n\t\t\tgoto error;\n\t} else\n\t\tif (nla_put(skb, IFA_ADDRESS, 16, &ifa->addr) < 0)\n\t\t\tgoto error;\n\tif (put_cacheinfo(skb, ifa->cstamp, ifa->tstamp, preferred, valid) < 0)\n\t\tgoto error;\n\treturn nlmsg_end(skb, nlh);\nerror:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}", "target": 0}
{"code": "NO_INLINE JsVar *jspeFactorDelete() {\n  JSP_ASSERT_MATCH(LEX_R_DELETE);\n  JsVar *parent = 0;\n  JsVar *a = jspeFactorMember(jspeFactor(), &parent);\n  JsVar *result = 0;\n  if (JSP_SHOULD_EXECUTE) {\n    bool ok = false;\n    if (jsvIsName(a) && !jsvIsNewChild(a)) {\n      if (!parent && jsvIsChild(execInfo.root, a))\n        parent = jsvLockAgain(execInfo.root);\n      if (jsvHasChildren(parent)) {\n        if (jsvIsArray(parent)) {\n          JsVarInt l = jsvGetArrayLength(parent);\n          jsvRemoveChild(parent, a);\n          jsvSetArrayLength(parent, l, false);\n        } else {\n          jsvRemoveChild(parent, a);\n        }\n        ok = true;\n      }\n    }\n    result = jsvNewFromBool(ok);\n  }\n  jsvUnLock2(a, parent);\n  return result;\n}", "target": 1}
{"code": "bool Sampler::operator==(const Sampler &other) const {\n  return this->extensions == other.extensions && this->extras == other.extras &&\n         this->magFilter == other.magFilter &&\n         this->minFilter == other.minFilter && this->name == other.name &&\n         this->wrapS == other.wrapS &&\n         this->wrapT == other.wrapT;\n}", "target": 1}
{"code": "void smp_idle_terminate(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n if (p_cb->flags & SMP_PAIR_FLAGS_WE_STARTED_DD) {\n    SMP_TRACE_DEBUG(\"Pairing terminated at IDLE state.\");\n    p_cb->status = SMP_FAIL;\n    smp_proc_pairing_cmpl(p_cb);\n }\n}", "target": 0}
{"code": "static int rawsock_create(struct net *net, struct socket *sock,\n\t\t\t  const struct nfc_protocol *nfc_proto, int kern)\n{\n\tstruct sock *sk;\n\tpr_debug(\"sock=%p\\n\", sock);\n\tif ((sock->type != SOCK_SEQPACKET) && (sock->type != SOCK_RAW))\n\t\treturn -ESOCKTNOSUPPORT;\n\tif (sock->type == SOCK_RAW)\n\t\tsock->ops = &rawsock_raw_ops;\n\telse\n\t\tsock->ops = &rawsock_ops;\n\tsk = sk_alloc(net, PF_NFC, GFP_ATOMIC, nfc_proto->proto, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\tsock_init_data(sock, sk);\n\tsk->sk_protocol = nfc_proto->id;\n\tsk->sk_destruct = rawsock_destruct;\n\tsock->state = SS_UNCONNECTED;\n\tif (sock->type == SOCK_RAW)\n\t\tnfc_sock_link(&raw_sk_list, sk);\n\telse {\n\t\tINIT_WORK(&nfc_rawsock(sk)->tx_work, rawsock_tx_work);\n\t\tnfc_rawsock(sk)->tx_work_scheduled = false;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void SparseFillEmptyRowsOpImpl(OpKernelContext* context,\n                               AsyncOpKernel::DoneCallback done = nullptr) {\n  if (!done) {\n    done = [] {};\n  }\n  const int kIndicesInput = 0;\n  const int kValuesInput = 1;\n  const int kDenseShapeInput = 2;\n  const int kDefaultValueInput = 3;\n  const Tensor& indices_t = context->input(kIndicesInput);\n  const Tensor& values_t = context->input(kValuesInput);\n  const Tensor& dense_shape_t = context->input(kDenseShapeInput);\n  const Tensor& default_value_t = context->input(kDefaultValueInput);\n  OP_REQUIRES_ASYNC(\n      context, TensorShapeUtils::IsVector(dense_shape_t.shape()),\n      errors::InvalidArgument(\"dense_shape must be a vector, saw: \",\n                              dense_shape_t.shape().DebugString()),\n      done);\n  OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsMatrix(indices_t.shape()),\n                    errors::InvalidArgument(\"indices must be a matrix, saw: \",\n                                            indices_t.shape().DebugString()),\n                    done);\n  OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsVector(values_t.shape()),\n                    errors::InvalidArgument(\"values must be a vector, saw: \",\n                                            values_t.shape().DebugString()),\n                    done);\n  OP_REQUIRES_ASYNC(\n      context, TensorShapeUtils::IsScalar(default_value_t.shape()),\n      errors::InvalidArgument(\"default_value must be a scalar, saw: \",\n                              default_value_t.shape().DebugString()),\n      done);\n  OP_REQUIRES_ASYNC(context, dense_shape_t.NumElements() != 0,\n                    errors::InvalidArgument(\"Dense shape cannot be empty.\"),\n                    done);\n  using FunctorType = functor::SparseFillEmptyRows<Device, T, Tindex>;\n  OP_REQUIRES_OK_ASYNC(context,\n                       FunctorType()(context, default_value_t, indices_t,\n                                     values_t, dense_shape_t, done),\n                       done);\n}", "target": 1}
{"code": "static int samldb_spn_uniqueness_check(struct samldb_ctx *ac,\n\t\t\t\t       struct ldb_message_element *spn_el)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tint ret;\n\tconst char *spn = NULL;\n\tsize_t i;\n\tTALLOC_CTX *tmp_ctx = talloc_new(ac->msg);\n\tif (tmp_ctx == NULL) {\n\t\treturn ldb_oom(ldb);\n\t}\n\tfor (i = 0; i < spn_el->num_values; i++) {\n\t\tint n_components;\n\t\tspn = (char *)spn_el->values[i].data;\n\t\tn_components = count_spn_components(spn_el->values[i]);\n\t\tif (n_components > 3 || n_components < 2) {\n\t\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\t       \"samldb: spn[%s] invalid with %u components\",\n\t\t\t\t\t       spn, n_components);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t\t}\n\t\tret = check_spn_direct_collision(ldb,\n\t\t\t\t\t\t tmp_ctx,\n\t\t\t\t\t\t spn,\n\t\t\t\t\t\t ac->msg->dn);\n\t\tif (ret == LDB_ERR_COMPARE_TRUE) {\n\t\t\tDBG_INFO(\"SPN %s re-added to the same object\\n\", spn);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn LDB_SUCCESS;\n\t\t}\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\tDBG_ERR(\"SPN %s failed direct uniqueness check\\n\", spn);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn ret;\n\t\t}\n\t\tret = check_spn_alias_collision(ldb,\n\t\t\t\t\t\ttmp_ctx,\n\t\t\t\t\t\tspn,\n\t\t\t\t\t\tac->msg->dn);\n\t\tif (ret == LDB_ERR_NO_SUCH_OBJECT) {\n\t\t\tbreak;\n\t\t}\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\tDBG_ERR(\"SPN %s failed alias uniqueness check\\n\", spn);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn ret;\n\t\t}\n\t\tDBG_INFO(\"SPN %s seems to be unique\\n\", spn);\n\t}\n\ttalloc_free(tmp_ctx);\n\treturn LDB_SUCCESS;\n}", "target": 1}
{"code": "connection *connection_accept(server *srv, server_socket *srv_socket) {\n\tint cnt;\n\tsock_addr cnt_addr;\n\tsize_t cnt_len = sizeof(cnt_addr); \n\tif (srv->conns.used >= srv->max_conns) {\n\t\treturn NULL;\n\t}\n\tcnt = fdevent_accept_listenfd(srv_socket->fd, (struct sockaddr *) &cnt_addr, &cnt_len);\n\tif (-1 == cnt) {\n\t\tswitch (errno) {\n\t\tcase EAGAIN:\n#if EWOULDBLOCK != EAGAIN\n\t\tcase EWOULDBLOCK:\n#endif\n\t\tcase EINTR:\n\t\tcase ECONNABORTED: \n\t\t\tbreak;\n\t\tcase EMFILE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_perror(srv->errh, __FILE__, __LINE__, \"accept failed\");\n\t\t}\n\t\treturn NULL;\n\t} else {\n\t\tif (sock_addr_get_family(&cnt_addr) != AF_UNIX) {\n\t\t\tnetwork_accept_tcp_nagle_disable(cnt);\n\t\t}\n\t\treturn connection_accepted(srv, srv_socket, &cnt_addr, cnt);\n\t}\n}", "target": 0}
{"code": "int32_t CxImage::GetSize()\n{\n\treturn head.biSize + head.biSizeImage + GetPaletteSize();\n}", "target": 1}
{"code": "static int createFromTiffRgba(TIFF * tif, gdImagePtr im)\n{\n\tint a;\n\tint x, y;\n\tint alphaBlendingFlag = 0;\n\tint color;\n\tint width = im->sx;\n\tint height = im->sy;\n\tuint32 *buffer;\n\tuint32 rgba;\n\talphaBlendingFlag = im->alphaBlendingFlag;\n\tgdImageAlphaBlending(im, 0);\n\tbuffer = (uint32 *) gdCalloc(sizeof(uint32), width * height);\n\tif (!buffer) {\n\t\treturn GD_FAILURE;\n\t}\n\tTIFFReadRGBAImage(tif, width, height, buffer, 0);\n\tfor(y = 0; y < height; y++) {\n\t\tfor(x = 0; x < width; x++) {\n\t\t\trgba = buffer[(y * width + x)];\n\t\t\ta = (0xff - TIFFGetA(rgba)) / 2;\n\t\t\tcolor = gdTrueColorAlpha(TIFFGetR(rgba), TIFFGetG(rgba), TIFFGetB(rgba), a);\n\t\t\tgdImageSetPixel(im, x, height - y - 1, color);\n\t\t}\n\t}\n\tgdFree(buffer);\n\tgdImageAlphaBlending(im, alphaBlendingFlag);\n\treturn GD_SUCCESS;\n}", "target": 1}
{"code": "long do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t *info)\n{\n\tif (pid <= 0 || tgid <= 0)\n\t\treturn -EINVAL;\n\tif (info->si_code >= 0)\n\t\treturn -EPERM;\n\tinfo->si_signo = sig;\n\treturn do_send_specific(tgid, pid, sig, info);\n}", "target": 1}
{"code": "static bool io_wq_for_each_worker(struct io_wqe *wqe,\n\t\t\t\t  bool (*func)(struct io_worker *, void *),\n\t\t\t\t  void *data)\n{\n\tstruct io_worker *worker;\n\tbool ret = false;\n\tlist_for_each_entry_rcu(worker, &wqe->all_list, all_list) {\n\t\tif (io_worker_get(worker)) {\n\t\t\tif (worker->task)\n\t\t\t\tret = func(worker, data);\n\t\t\tio_worker_release(worker);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "mm_zfree(struct mm_master *mm, void *address)\n{\n\tmm_free(mm, address);\n}", "target": 1}
{"code": "build_cert_bag (unsigned char *buffer, size_t buflen, char *salt,\n                size_t *r_length)\n{\n  size_t len[9], needed;\n  unsigned char *p, *certbag;\n  size_t certbaglen;\n  needed = compute_tag_length (buflen);\n  needed += buflen;\n  needed += DIM (data_rc2iter2048);\n  needed += 2 + DIM (oid_data);\n  len[5] = needed;\n  needed += compute_tag_length ( needed);\n  needed += 3;\n  len[3] = needed;\n  needed += compute_tag_length (needed);\n  len[2] = needed;\n  needed += compute_tag_length (needed);\n  needed += 2 + DIM (oid_encryptedData);\n  len[0] = needed;\n  needed += compute_tag_length (needed);\n  p = certbag = gcry_malloc (needed);\n  if (!certbag)\n    {\n      log_error (\"error allocating buffer\\n\");\n      return NULL;\n    }\n  p = store_tag_length (p, TAG_SEQUENCE, len[0]);\n  p = store_tag_length (p, TAG_OBJECT_ID, DIM (oid_encryptedData));\n  memcpy (p, oid_encryptedData, DIM (oid_encryptedData));\n  p += DIM (oid_encryptedData);\n  p = store_tag_length (p, 0xa0, len[2]);\n  p = store_tag_length (p, TAG_SEQUENCE, len[3]);\n  *p++ = TAG_INTEGER;\n  *p++ = 1;\n  *p++ = 0;\n  p = store_tag_length (p, TAG_SEQUENCE, len[5]);\n  p = store_tag_length (p, TAG_OBJECT_ID, DIM (oid_data));\n  memcpy (p, oid_data, DIM (oid_data));\n  p += DIM (oid_data);\n  memcpy (p, data_rc2iter2048, DIM (data_rc2iter2048));\n  memcpy (p + DATA_RC2ITER2048_SALT_OFF, salt, 8);\n  p += DIM (data_rc2iter2048);\n  p = store_tag_length (p, 0x80, buflen);\n  memcpy (p, buffer, buflen);\n  p += buflen;\n  certbaglen = p - certbag;\n  if (needed != certbaglen)\n    log_debug (\"length mismatch: %lu, %lu\\n\",\n               (unsigned long)needed, (unsigned long)certbaglen);\n  *r_length = certbaglen;\n  return certbag;\n}", "target": 0}
{"code": "der_to_ldap_BitString (struct berval *berValue,\n                                   struct berval *ldapValue)\n{\n\tber_len_t bitPadding=0;\n\tber_len_t bits, maxBits;\n\tchar *tmpStr;\n\tunsigned char byte;\n\tber_len_t bitLength;\n\tber_len_t valLen;\n\tunsigned char* valPtr;\n\tldapValue->bv_len=0;\n\tldapValue->bv_val=NULL;\n\tvalLen=berValue->bv_len;\n\tvalPtr=(unsigned char*)berValue->bv_val;\n\tif (valLen) {\n\t\tbitPadding=(ber_len_t)(valPtr[0]);\n\t\tvalLen--;\n\t\tvalPtr++;\n\t}\n\tif (bitPadding >= BITS_PER_BYTE) {\n\t\tif (valLen*BITS_PER_BYTE > bitPadding ) {\n\t\t\tvalLen-=(bitPadding/BITS_PER_BYTE);\n\t\t\tbitPadding%=BITS_PER_BYTE;\n\t\t} else {\n\t\t\tvalLen=0;\n\t\t\tbitPadding=0;\n\t\t}\n\t}\n\tif (valLen*BITS_PER_BYTE < bitPadding ) {\n\t\tbitPadding=0;\n\t\tvalLen=0;\n\t}\n\tbitLength=valLen*BITS_PER_BYTE-bitPadding;\n\ttmpStr=LDAP_MALLOC(bitLength + STR_OVERHEAD + 1);\n\tif (!tmpStr)\n\t\treturn LDAP_NO_MEMORY;\n\tldapValue->bv_val=tmpStr;\n\tldapValue->bv_len=bitLength + STR_OVERHEAD;\n\tmaxBits=BITS_PER_BYTE;\n\t*tmpStr++ ='\\'';\n\twhile(valLen) {\n\t\tbyte=*valPtr;\n\t\tif (valLen==1)\n\t\t\tmaxBits-=bitPadding;\n\t\tfor (bits=0; bits<maxBits; bits++) {\n\t\t\tif (0x80 & byte)\n\t\t\t\t*tmpStr='1';\n\t\t\telse\n\t\t\t\t*tmpStr='0';\n\t\t\ttmpStr++;\n\t\t\tbyte<<=1;\n\t\t}\n\t\tvalPtr++;\n\t\tvalLen--;\n\t}\n\t*tmpStr++ ='\\'';\n\t*tmpStr++ ='B';\n\t*tmpStr=0;\n\treturn LDAP_SUCCESS;\n}", "target": 0}
{"code": "void kvm_arch_vcpu_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\tif (need_emulate_wbinvd(vcpu)) {\n\t\tif (kvm_x86_ops->has_wbinvd_exit())\n\t\t\tcpumask_set_cpu(cpu, vcpu->arch.wbinvd_dirty_mask);\n\t\telse if (vcpu->cpu != -1 && vcpu->cpu != cpu)\n\t\t\tsmp_call_function_single(vcpu->cpu,\n\t\t\t\t\twbinvd_ipi, NULL, 1);\n\t}\n\tkvm_x86_ops->vcpu_load(vcpu, cpu);\n\tif (unlikely(vcpu->arch.tsc_offset_adjustment)) {\n\t\tadjust_tsc_offset_host(vcpu, vcpu->arch.tsc_offset_adjustment);\n\t\tvcpu->arch.tsc_offset_adjustment = 0;\n\t\tset_bit(KVM_REQ_CLOCK_UPDATE, &vcpu->requests);\n\t}\n\tif (unlikely(vcpu->cpu != cpu) || check_tsc_unstable()) {\n\t\ts64 tsc_delta = !vcpu->arch.last_host_tsc ? 0 :\n\t\t\t\tnative_read_tsc() - vcpu->arch.last_host_tsc;\n\t\tif (tsc_delta < 0)\n\t\t\tmark_tsc_unstable(\"KVM discovered backwards TSC\");\n\t\tif (check_tsc_unstable()) {\n\t\t\tu64 offset = kvm_x86_ops->compute_tsc_offset(vcpu,\n\t\t\t\t\t\tvcpu->arch.last_guest_tsc);\n\t\t\tkvm_x86_ops->write_tsc_offset(vcpu, offset);\n\t\t\tvcpu->arch.tsc_catchup = 1;\n\t\t}\n\t\tif (!vcpu->kvm->arch.use_master_clock || vcpu->cpu == -1)\n\t\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\t\tif (vcpu->cpu != cpu)\n\t\t\tkvm_migrate_timers(vcpu);\n\t\tvcpu->cpu = cpu;\n\t}\n\taccumulate_steal_time(vcpu);\n\tkvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);\n}", "target": 0}
{"code": "readpw(PK11SlotInfo *slot UNUSED,\n       PRBool retry UNUSED,\n       void *arg UNUSED)\n{\n\tstruct termios sio, tio;\n\tchar line[LINE_MAX], *p;\n\tchar *ret;\n\tingress();\n\tmemset(line, '\\0', sizeof (line));\n\tif (tcgetattr(fileno(stdin), &sio) < 0) {\n\t\twarnx(\"Could not read password from standard input.\");\n\t\treturn NULL;\n\t}\n\ttio = sio;\n\ttio.c_lflag &= ~ECHO;\n\tif (tcsetattr(fileno(stdin), 0, &tio) < 0) {\n\t\twarnx(\"Could not read password from standard input.\");\n\t\treturn NULL;\n\t}\n\tfprintf(stdout, \"Enter passphrase for private key: \");\n\tfflush(stdout);\n\tret = fgets(line, sizeof(line), stdin);\n\tset_errno_guard();\n\ttcsetattr(fileno(stdin), 0, &sio);\n\tfprintf(stdout, \"\\n\");\n\tfflush(stdout);\n\tif (ret == NULL)\n\t\treturn NULL;\n\tp = line + strcspn(line, \"\\r\\n\");\n\tif (p == NULL)\n\t\tp = line + strcspn(line, \"\\n\");\n\tif (p != NULL)\n\t\t*p = '\\0';\n\tret = strdup(line);\n\tmemset(line, '\\0', sizeof (line));\n\tif (!ret) {\n\t\twarnx(\"Could not read passphrase.\");\n\t\treturn NULL;\n\t}\n\tegress();\n\treturn ret;\n}", "target": 0}
{"code": "static inline bool cfs_rq_is_decayed(struct cfs_rq *cfs_rq)\n{\n\tif (cfs_rq->load.weight)\n\t\treturn false;\n\tif (cfs_rq->avg.load_sum)\n\t\treturn false;\n\tif (cfs_rq->avg.util_sum)\n\t\treturn false;\n\tif (cfs_rq->avg.runnable_load_sum)\n\t\treturn false;\n\treturn true;\n}", "target": 1}
{"code": "static void youngcollection (lua_State *L, global_State *g) {\n  GCObject **psurvival;  \n  lua_assert(g->gcstate == GCSpropagate);\n  markold(g, g->survival, g->reallyold);\n  markold(g, g->finobj, g->finobjrold);\n  atomic(L);\n  psurvival = sweepgen(L, g, &g->allgc, g->survival);\n  sweepgen(L, g, psurvival, g->reallyold);\n  g->reallyold = g->old;\n  g->old = *psurvival;  \n  g->survival = g->allgc;  \n  psurvival = sweepgen(L, g, &g->finobj, g->finobjsur);\n  sweepgen(L, g, psurvival, g->finobjrold);\n  g->finobjrold = g->finobjold;\n  g->finobjold = *psurvival;  \n  g->finobjsur = g->finobj;  \n  sweepgen(L, g, &g->tobefnz, NULL);\n  finishgencycle(L, g);\n}", "target": 1}
{"code": "socks_request_free(socks_request_t *req)\n{\n  if (!req)\n    return;\n  if (req->username) {\n    memwipe(req->username, 0x10, req->usernamelen);\n    tor_free(req->username);\n  }\n  if (req->password) {\n    memwipe(req->password, 0x04, req->passwordlen);\n    tor_free(req->password);\n  }\n  memwipe(req, 0xCC, sizeof(socks_request_t));\n  tor_free(req);\n}", "target": 0}
{"code": "static int may_delete(struct inode *dir,struct dentry *victim,int isdir)\n{\n\tint error;\n\tif (!victim->d_inode)\n\t\treturn -ENOENT;\n\tBUG_ON(victim->d_parent->d_inode != dir);\n\taudit_inode_child(dir, victim, AUDIT_TYPE_CHILD_DELETE);\n\terror = inode_permission(dir, MAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\treturn error;\n\tif (IS_APPEND(dir))\n\t\treturn -EPERM;\n\tif (check_sticky(dir, victim->d_inode)||IS_APPEND(victim->d_inode)||\n\t    IS_IMMUTABLE(victim->d_inode) || IS_SWAPFILE(victim->d_inode))\n\t\treturn -EPERM;\n\tif (isdir) {\n\t\tif (!S_ISDIR(victim->d_inode->i_mode))\n\t\t\treturn -ENOTDIR;\n\t\tif (IS_ROOT(victim))\n\t\t\treturn -EBUSY;\n\t} else if (S_ISDIR(victim->d_inode->i_mode))\n\t\treturn -EISDIR;\n\tif (IS_DEADDIR(dir))\n\t\treturn -ENOENT;\n\tif (victim->d_flags & DCACHE_NFSFS_RENAMED)\n\t\treturn -EBUSY;\n\treturn 0;\n}", "target": 0}
{"code": "DNSRequest::DNSRequest(DNS* dns, int rid, const std::string &original) : dnsobj(dns)\n{\n\tres = new unsigned char[sizeof(DNSHeader) * 2];\n\t*res = 0;\n\torig = original;\n\tRequestTimeout* RT = new RequestTimeout(ServerInstance->Config->dns_timeout ? ServerInstance->Config->dns_timeout : 5, this, rid);\n\tServerInstance->Timers->AddTimer(RT); \n}", "target": 0}
{"code": "void _WM_do_control_channel_sound_off(struct _mdi *mdi,\n                                      struct _event_data *data) {\n    struct _note *note_data = mdi->note;\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n    if (note_data) {\n        do {\n            if ((note_data->noteid >> 8) == ch) {\n                note_data->active = 0;\n                if (note_data->replay) {\n                    note_data->replay = NULL;\n                }\n            }\n            note_data = note_data->next;\n        } while (note_data);\n    }\n}", "target": 0}
{"code": "match_aref(int argc, VALUE *argv, VALUE match)\n{\n    VALUE idx, length;\n    match_check(match);\n    rb_scan_args(argc, argv, \"11\", &idx, &length);\n    if (NIL_P(length)) {\n\tif (FIXNUM_P(idx)) {\n\t    return rb_reg_nth_match(FIX2INT(idx), match);\n\t}\n\telse {\n\t    int num = namev_to_backref_number(RMATCH_REGS(match), RMATCH(match)->regexp, idx);\n\t    if (num >= 0) {\n\t\treturn rb_reg_nth_match(num, match);\n\t    }\n\t    else {\n\t\treturn match_ary_aref(match, idx, Qnil);\n\t    }\n\t}\n    }\n    else {\n\tlong beg = NUM2LONG(idx);\n\tlong len = NUM2LONG(length);\n\tlong num_regs = RMATCH_REGS(match)->num_regs;\n\tif (len < 0) {\n\t    return Qnil;\n\t}\n\tif (beg < 0) {\n\t    beg += num_regs;\n\t    if (beg < 0) return Qnil;\n\t}\n\telse if (beg > num_regs) {\n\t    return Qnil;\n\t}\n\telse if (beg+len > num_regs) {\n\t    len = num_regs - beg;\n\t}\n\treturn match_ary_subseq(match, beg, len, Qnil);\n    }\n}", "target": 0}
{"code": "render_pixbuf_size_prepared_cb (GdkPixbufLoader *loader,\n\t\t\t\tgint             width,\n\t\t\t\tgint             height,\n\t\t\t\tgpointer         data)\n{\n\tdouble *scale = data;\n\tint w = (width  * (*scale) + 0.5);\n\tint h = (height * (*scale) + 0.5);\n\tgdk_pixbuf_loader_set_size (loader, w, h);\n}", "target": 1}
{"code": "uint32_t virtio_config_readb(VirtIODevice *vdev, uint32_t addr)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint8_t val;\n    k->get_config(vdev, vdev->config);\n    if (addr > (vdev->config_len - sizeof(val)))\n        return (uint32_t)-1;\n    val = ldub_p(vdev->config + addr);\n    return val;\n}", "target": 1}
{"code": "static void exif_process_TIFF_in_JPEG(image_info_type *ImageInfo, char *CharBuf, size_t length, size_t displacement)\n{\n\tunsigned exif_value_2a, offset_of_ifd;\n\tif (memcmp(CharBuf, \"II\", 2) == 0) {\n\t\tImageInfo->motorola_intel = 0;\n\t} else if (memcmp(CharBuf, \"MM\", 2) == 0) {\n\t\tImageInfo->motorola_intel = 1;\n\t} else {\n\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Invalid TIFF alignment marker\");\n\t\treturn;\n\t}\n\tif (length < 8) {\n\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Invalid TIFF start (1)\");\n\t\treturn;\n\t}\n\texif_value_2a = php_ifd_get16u(CharBuf+2, ImageInfo->motorola_intel);\n\toffset_of_ifd = php_ifd_get32u(CharBuf+4, ImageInfo->motorola_intel);\n\tif (exif_value_2a != 0x2a || offset_of_ifd < 0x08) {\n\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Invalid TIFF start (1)\");\n\t\treturn;\n\t}\n\tif (offset_of_ifd > length) {\n\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Invalid IFD start\");\n\t\treturn;\n\t}\n\tImageInfo->sections_found |= FOUND_IFD0;\n\texif_process_IFD_in_JPEG(ImageInfo, CharBuf+offset_of_ifd, CharBuf, length, displacement, SECTION_IFD0, 0);\n#ifdef EXIF_DEBUG\n\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Process TIFF in JPEG done\");\n#endif\n\tif (ImageInfo->FocalplaneXRes != 0) {\n\t\tImageInfo->CCDWidth = (float)(ImageInfo->ExifImageWidth * ImageInfo->FocalplaneUnits / ImageInfo->FocalplaneXRes);\n\t}\n}", "target": 0}
{"code": "static void aes_ctr_cleanup(struct ssh_cipher_struct *cipher){\n    explicit_bzero(cipher->aes_key, sizeof(*cipher->aes_key));\n    SAFE_FREE(cipher->aes_key);\n}", "target": 1}
{"code": "static int ptrace_check_attach(struct task_struct *child, bool ignore_state)\n{\n\tint ret = -ESRCH;\n\tread_lock(&tasklist_lock);\n\tif ((child->ptrace & PT_PTRACED) && child->parent == current) {\n\t\tspin_lock_irq(&child->sighand->siglock);\n\t\tWARN_ON_ONCE(task_is_stopped(child));\n\t\tif (ignore_state || (task_is_traced(child) &&\n\t\t\t\t     !(child->jobctl & JOBCTL_LISTENING)))\n\t\t\tret = 0;\n\t\tspin_unlock_irq(&child->sighand->siglock);\n\t}\n\tread_unlock(&tasklist_lock);\n\tif (!ret && !ignore_state)\n\t\tret = wait_task_inactive(child, TASK_TRACED) ? 0 : -ESRCH;\n\treturn ret;\n}", "target": 1}
{"code": "void SavePackage::StartSave(const SaveFileCreateInfo* info) {\n  DCHECK(info && !info->url.is_empty());\n  SaveUrlItemMap::iterator it = in_progress_items_.find(info->url.spec());\n  if (it == in_progress_items_.end()) {\n    DCHECK(canceled());\n    return;\n  }\n  SaveItem* save_item = it->second;\n  DCHECK(!saved_main_file_path_.empty());\n  save_item->SetSaveId(info->save_id);\n  save_item->SetTotalBytes(info->total_bytes);\n  DCHECK(!save_item->has_final_name());\n  if (info->url != page_url_) {\n    FilePath::StringType generated_name;\n    bool need_html_ext =\n        info->save_source == SaveFileCreateInfo::SAVE_FILE_FROM_DOM;\n    if (!GenerateFileName(info->content_disposition,\n                          GURL(info->url),\n                          need_html_ext,\n                          &generated_name)) {\n      if (info->save_source == SaveFileCreateInfo::SAVE_FILE_FROM_DOM)\n        Cancel(true);\n      else\n        SaveFinished(save_item->save_id(), 0, false);\n      return;\n    }\n    DCHECK(save_type_ == SAVE_PAGE_TYPE_AS_COMPLETE_HTML);\n    DCHECK(!saved_main_directory_path_.empty());\n    FilePath final_name = saved_main_directory_path_.Append(generated_name);\n    save_item->Rename(final_name);\n  } else {\n    save_item->Rename(saved_main_file_path_);\n  }\n  if (info->save_source == SaveFileCreateInfo::SAVE_FILE_FROM_FILE) {\n    BrowserThread::PostTask(\n        BrowserThread::FILE, FROM_HERE,\n        base::Bind(&SaveFileManager::SaveLocalFile,\n                   file_manager_,\n                   save_item->url(),\n                   save_item->save_id(),\n                   contents_id()));\n    return;\n  }\n  if (save_type_ == SAVE_PAGE_TYPE_AS_COMPLETE_HTML &&\n      wait_state_ == HTML_DATA) {\n    GetSerializedHtmlDataForCurrentPageWithLocalLinks();\n  }\n}", "target": 0}
{"code": "static double util_pointsize( wmfAPI* API, wmfFont* font, char* str, double font_height, ExceptionInfo *exception)\n{\n  wmf_magick_t\n    *ddata = WMF_MAGICK_GetData(API);\n  Image\n    *image = ddata->image;\n  TypeMetric\n    metrics;\n  DrawInfo\n    *draw_info;\n  double\n    pointsize = 0;\n  draw_info=ddata->draw_info;\n  if (draw_info == (const DrawInfo *) NULL)\n    return 0;\n  draw_info->font=WMF_FONT_PSNAME(font);\n  draw_info->pointsize=font_height;\n  draw_info->text=str;\n  if (GetTypeMetrics(image, draw_info, &metrics, exception) != MagickFalse)\n    {\n      if (strlen(str) == 1)\n        {\n          pointsize = (font_height *\n                       ( font_height / (metrics.ascent + fabs(metrics.descent))));\n          draw_info->pointsize = pointsize;\n          if (GetTypeMetrics(image, draw_info, &metrics, exception) != MagickFalse)\n            pointsize *= (font_height / ( metrics.ascent + fabs(metrics.descent)));\n        }\n      else\n        {\n          pointsize = (font_height * (font_height / (metrics.height)));\n          draw_info->pointsize = pointsize;\n          if (GetTypeMetrics(image, draw_info, &metrics, exception) != MagickFalse)\n            pointsize *= (font_height / metrics.height);\n        }\n#if 0\n      draw_info.pointsize = pointsize;\n      if (GetTypeMetrics(image, &draw_info, &metrics, exception) != MagickFalse)\n        pointsize *= (font_height / (metrics.ascent + fabs(metrics.descent)));\n      pointsize *= 1.114286; \n#endif\n    }\n  draw_info->font=NULL;\n  draw_info->text=NULL;\n#if 0\n  printf(\"String    = %s\\n\", str);\n  printf(\"Font      = %s\\n\", WMF_FONT_PSNAME(font));\n  printf(\"lfHeight  = %g\\n\", font_height);\n  printf(\"bounds    = %g,%g %g,%g\\n\", metrics.bounds.x1, metrics.bounds.y1,\n         metrics.bounds.x2,metrics.bounds.y2);\n  printf(\"ascent    = %g\\n\", metrics.ascent);\n  printf(\"descent   = %g\\n\", metrics.descent);\n  printf(\"height    = %g\\n\", metrics.height);\n  printf(\"Pointsize = %g\\n\", pointsize);\n#endif\n  return floor(pointsize);\n}", "target": 0}
{"code": "static int pfkey_register(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\tstruct sk_buff *supp_skb;\n\tif (hdr->sadb_msg_satype > SADB_SATYPE_MAX)\n\t\treturn -EINVAL;\n\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC) {\n\t\tif (pfk->registered&(1<<hdr->sadb_msg_satype))\n\t\t\treturn -EEXIST;\n\t\tpfk->registered |= (1<<hdr->sadb_msg_satype);\n\t}\n\txfrm_probe_algs();\n\tsupp_skb = compose_sadb_supported(hdr, GFP_KERNEL | __GFP_ZERO);\n\tif (!supp_skb) {\n\t\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC)\n\t\t\tpfk->registered &= ~(1<<hdr->sadb_msg_satype);\n\t\treturn -ENOBUFS;\n\t}\n\tpfkey_broadcast(supp_skb, GFP_KERNEL, BROADCAST_REGISTERED, sk,\n\t\t\tsock_net(sk));\n\treturn 0;\n}", "target": 1}
{"code": "call_qftf_func(qf_list_T *qfl, int qf_winid, long start_idx, long end_idx)\n{\n    callback_T\t*cb = &qftf_cb;\n    list_T\t*qftf_list = NULL;\n    if (qfl->qf_qftf_cb.cb_name != NULL)\n\tcb = &qfl->qf_qftf_cb;\n    if (cb->cb_name != NULL)\n    {\n\ttypval_T\targs[1];\n\tdict_T\t\t*d;\n\ttypval_T\trettv;\n\tif ((d = dict_alloc_lock(VAR_FIXED)) == NULL)\n\t    return NULL;\n\tdict_add_number(d, \"quickfix\", (long)IS_QF_LIST(qfl));\n\tdict_add_number(d, \"winid\", (long)qf_winid);\n\tdict_add_number(d, \"id\", (long)qfl->qf_id);\n\tdict_add_number(d, \"start_idx\", start_idx);\n\tdict_add_number(d, \"end_idx\", end_idx);\n\t++d->dv_refcount;\n\targs[0].v_type = VAR_DICT;\n\targs[0].vval.v_dict = d;\n\tqftf_list = NULL;\n\tif (call_callback(cb, 0, &rettv, 1, args) != FAIL)\n\t{\n\t    if (rettv.v_type == VAR_LIST)\n\t    {\n\t\tqftf_list = rettv.vval.v_list;\n\t\tqftf_list->lv_refcount++;\n\t    }\n\t    clear_tv(&rettv);\n\t}\n\tdict_unref(d);\n    }\n    return qftf_list;\n}", "target": 1}
{"code": "handle_bap(netdissect_options *ndo _U_,\n           const u_char *p _U_, int length _U_)\n{\n}", "target": 0}
{"code": "sysObjectID_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  OID(sysObjectID_oid, 1, 3, 6, 1, 4, 1, 54352);\n  snmp_api_set_oid(varbind, oid, sysObjectID_oid);\n}", "target": 1}
{"code": "TEST_F(SecretManagerImplTest, DeprecatedSanMatcher) {\n  envoy::extensions::transport_sockets::tls::v3::Secret secret_config;\n  const std::string yaml =\n      R\"EOF(\n      name: \"abc.com\"\n      validation_context:\n        trusted_ca: { filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\" }\n        allow_expired_certificate: true\n        match_subject_alt_names:\n          exact: \"example.foo\"\n      )EOF\";\n  TestUtility::loadFromYaml(TestEnvironment::substitute(yaml), secret_config);\n  std::unique_ptr<SecretManager> secret_manager(new SecretManagerImpl(config_tracker_));\n  secret_manager->addStaticSecret(secret_config);\n  ASSERT_EQ(secret_manager->findStaticCertificateValidationContextProvider(\"undefined\"), nullptr);\n  ASSERT_NE(secret_manager->findStaticCertificateValidationContextProvider(\"abc.com\"), nullptr);\n  Ssl::CertificateValidationContextConfigImpl cvc_config(\n      *secret_manager->findStaticCertificateValidationContextProvider(\"abc.com\")->secret(), *api_);\n  EXPECT_EQ(cvc_config.subjectAltNameMatchers().size(), 4);\n  EXPECT_EQ(\"example.foo\", cvc_config.subjectAltNameMatchers()[0].matcher().exact());\n  EXPECT_EQ(envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::DNS,\n            cvc_config.subjectAltNameMatchers()[0].san_type());\n  EXPECT_EQ(\"example.foo\", cvc_config.subjectAltNameMatchers()[1].matcher().exact());\n  EXPECT_EQ(envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::URI,\n            cvc_config.subjectAltNameMatchers()[1].san_type());\n  EXPECT_EQ(\"example.foo\", cvc_config.subjectAltNameMatchers()[2].matcher().exact());\n  EXPECT_EQ(envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::EMAIL,\n            cvc_config.subjectAltNameMatchers()[2].san_type());\n  EXPECT_EQ(\"example.foo\", cvc_config.subjectAltNameMatchers()[3].matcher().exact());\n  EXPECT_EQ(envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::IP_ADDRESS,\n            cvc_config.subjectAltNameMatchers()[3].san_type());\n}", "target": 0}
{"code": "ModHandle CModules::OpenModule(const CString& sModule, const CString& sModPath,\n                               CModInfo& Info, CString& sRetMsg) {\n    sRetMsg.clear();\n    for (unsigned int a = 0; a < sModule.length(); a++) {\n        if (((sModule[a] < '0') || (sModule[a] > '9')) &&\n            ((sModule[a] < 'a') || (sModule[a] > 'z')) &&\n            ((sModule[a] < 'A') || (sModule[a] > 'Z')) && (sModule[a] != '_')) {\n            sRetMsg =\n                t_f(\"Module names can only contain letters, numbers and \"\n                    \"underscores, [{1}] is invalid\")(sModule);\n            return nullptr;\n        }\n    }\n    ModHandle p = dlopen((sModPath).c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (!p) {\n        const char* cDlError = dlerror();\n        CString sDlError = cDlError ? cDlError : t_s(\"Unknown error\");\n        sRetMsg = t_f(\"Unable to open module {1}: {2}\")(sModule, sDlError);\n        return nullptr;\n    }\n    const CModuleEntry* (*fpZNCModuleEntry)() = nullptr;\n    *reinterpret_cast<void**>(&fpZNCModuleEntry) = dlsym(p, \"ZNCModuleEntry\");\n    if (!fpZNCModuleEntry) {\n        dlclose(p);\n        sRetMsg = t_f(\"Could not find ZNCModuleEntry in module {1}\")(sModule);\n        return nullptr;\n    }\n    const CModuleEntry* pModuleEntry = fpZNCModuleEntry();\n    if (std::strcmp(pModuleEntry->pcVersion, VERSION_STR) ||\n        std::strcmp(pModuleEntry->pcVersionExtra, VERSION_EXTRA)) {\n        sRetMsg = t_f(\n            \"Version mismatch for module {1}: core is {2}, module is built for \"\n            \"{3}. Recompile this module.\")(\n            sModule, VERSION_STR VERSION_EXTRA,\n            CString(pModuleEntry->pcVersion) + pModuleEntry->pcVersionExtra);\n        dlclose(p);\n        return nullptr;\n    }\n    if (std::strcmp(pModuleEntry->pcCompileOptions,\n                    ZNC_COMPILE_OPTIONS_STRING)) {\n        sRetMsg = t_f(\n            \"Module {1} is built incompatibly: core is '{2}', module is '{3}'. \"\n            \"Recompile this module.\")(sModule, ZNC_COMPILE_OPTIONS_STRING,\n                                      pModuleEntry->pcCompileOptions);\n        dlclose(p);\n        return nullptr;\n    }\n    CTranslationDomainRefHolder translation(\"znc-\" + sModule);\n    pModuleEntry->fpFillModInfo(Info);\n    sRetMsg = \"\";\n    return p;\n}", "target": 1}
{"code": "static int fixup_call_args(struct bpf_verifier_env *env)\n{\n#ifndef CONFIG_BPF_JIT_ALWAYS_ON\n\tstruct bpf_prog *prog = env->prog;\n\tstruct bpf_insn *insn = prog->insnsi;\n\tint i, depth;\n#endif\n\tint err = 0;\n\tif (env->prog->jit_requested &&\n\t    !bpf_prog_is_dev_bound(env->prog->aux)) {\n\t\terr = jit_subprogs(env);\n\t\tif (err == 0)\n\t\t\treturn 0;\n\t\tif (err == -EFAULT)\n\t\t\treturn err;\n\t}\n#ifndef CONFIG_BPF_JIT_ALWAYS_ON\n\tfor (i = 0; i < prog->len; i++, insn++) {\n\t\tif (insn->code != (BPF_JMP | BPF_CALL) ||\n\t\t    insn->src_reg != BPF_PSEUDO_CALL)\n\t\t\tcontinue;\n\t\tdepth = get_callee_stack_depth(env, insn, i);\n\t\tif (depth < 0)\n\t\t\treturn depth;\n\t\tbpf_patch_call_args(insn, depth);\n\t}\n\terr = 0;\n#endif\n\treturn err;\n}", "target": 0}
{"code": "xfs_da3_fixhashpath(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_path *path)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_node_entry *btree;\n\txfs_dahash_t\t\tlasthash=0;\n\tint\t\t\tlevel;\n\tint\t\t\tcount;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\ttrace_xfs_da_fixhashpath(state->args);\n\tlevel = path->active-1;\n\tblk = &path->blk[ level ];\n\tswitch (blk->magic) {\n\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tlasthash = xfs_attr_leaf_lasthash(blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tlasthash = xfs_dir2_leafn_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DA_NODE_MAGIC:\n\t\tlasthash = xfs_da3_node_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\t}\n\tfor (blk--, level--; level >= 0; blk--, level--) {\n\t\tstruct xfs_da3_icnode_hdr nodehdr;\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\t\tif (be32_to_cpu(btree->hashval) == lasthash)\n\t\t\tbreak;\n\t\tblk->hashval = lasthash;\n\t\tbtree[blk->index].hashval = cpu_to_be32(lasthash);\n\t\txfs_trans_log_buf(state->args->trans, blk->bp,\n\t\t\t\t  XFS_DA_LOGRANGE(node, &btree[blk->index],\n\t\t\t\t\t\t  sizeof(*btree)));\n\t\tlasthash = be32_to_cpu(btree[nodehdr.count - 1].hashval);\n\t}\n}", "target": 1}
{"code": "void qemu_ram_free(struct uc_struct *uc, RAMBlock *block)\n{\n    if (!block) {\n        return;\n    }\n    QLIST_REMOVE(block, next);\n    uc->ram_list.mru_block = NULL;\n    reclaim_ramblock(uc, block);\n}", "target": 1}
{"code": "pci_emul_dinit(struct vmctx *ctx, struct pci_vdev *dev, char *opts)\n{\n\tint error;\n\tstruct pci_emul_dummy *dummy;\n\tdummy = calloc(1, sizeof(struct pci_emul_dummy));\n\tdev->arg = dummy;\n\tpci_set_cfgdata16(dev, PCIR_DEVICE, 0x0001);\n\tpci_set_cfgdata16(dev, PCIR_VENDOR, 0x10DD);\n\tpci_set_cfgdata8(dev, PCIR_CLASS, 0x02);\n\terror = pci_emul_add_msicap(dev, PCI_EMUL_MSI_MSGS);\n\tassert(error == 0);\n\terror = pci_emul_alloc_bar(dev, 0, PCIBAR_IO, DIOSZ);\n\tassert(error == 0);\n\terror = pci_emul_alloc_bar(dev, 1, PCIBAR_MEM32, DMEMSZ);\n\tassert(error == 0);\n\terror = pci_emul_alloc_bar(dev, 2, PCIBAR_MEM32, DMEMSZ);\n\tassert(error == 0);\n\treturn 0;\n}", "target": 1}
{"code": "void FormatConverter<T>::InitSparseToDenseConverter(\n    std::vector<int> shape, std::vector<int> traversal_order,\n    std::vector<TfLiteDimensionType> format, std::vector<int> dense_size,\n    std::vector<std::vector<int>> segments,\n    std::vector<std::vector<int>> indices, std::vector<int> block_map) {\n  dense_shape_ = std::move(shape);\n  traversal_order_ = std::move(traversal_order);\n  block_map_ = std::move(block_map);\n  format_ = std::move(format);\n  dense_size_ = 1;\n  for (int i = 0; i < dense_shape_.size(); i++) {\n    dense_size_ *= dense_shape_[i];\n  }\n  dim_metadata_.resize(2 * format_.size());\n  for (int i = 0; i < format_.size(); i++) {\n    if (format_[i] == kTfLiteDimDense) {\n      dim_metadata_[2 * i] = {dense_size[i]};\n    } else {\n      dim_metadata_[2 * i] = std::move(segments[i]);\n      dim_metadata_[2 * i + 1] = std::move(indices[i]);\n    }\n  }\n  int original_rank = dense_shape_.size();\n  int block_dim = 0;\n  blocked_shape_.resize(original_rank);\n  block_size_.resize(block_map_.size());\n  for (int i = 0; i < original_rank; i++) {\n    if (block_dim < block_map_.size() && block_map_[block_dim] == i) {\n      int orig_dim = traversal_order_[original_rank + block_dim];\n      block_size_[block_dim] = dense_size[orig_dim];\n      blocked_shape_[i] = dense_shape_[i] / dense_size[orig_dim];\n      block_dim++;\n    } else {\n      blocked_shape_[i] = dense_shape_[i];\n    }\n  }\n}", "target": 1}
{"code": "x509stack_pop(struct cert_stack *stack)\n{\n\tX509 *cert;\n\tstruct metadata_node *meta;\n\tstruct repo_level_node *repo;\n\tcert = sk_X509_pop(stack->x509s);\n\tif (cert == NULL)\n\t\tpr_crit(\"Attempted to pop empty X509 stack\");\n\tX509_free(cert);\n\tmeta = SLIST_FIRST(&stack->metas);\n\tif (meta == NULL)\n\t\tpr_crit(\"Attempted to pop empty metadata stack\");\n\tSLIST_REMOVE_HEAD(&stack->metas, next);\n\tmeta_destroy(meta);\n\trepo = SLIST_FIRST(&stack->levels);\n\tif (repo == NULL)\n\t\tpr_crit(\"Attempted to pop empty repo level stack\");\n\tSLIST_REMOVE_HEAD(&stack->levels, next);\n\tfree(repo);\n}", "target": 1}
{"code": "ssh_packet_set_postauth(struct ssh *ssh)\n{\n\tstruct sshcomp *comp;\n\tint r, mode;\n\tdebug(\"%s: called\", __func__);\n\tssh->state->after_authentication = 1;\n\tssh->state->rekeying = 0;\n\tfor (mode = 0; mode < MODE_MAX; mode++) {\n\t\tif (ssh->state->newkeys[mode] == NULL)\n\t\t\tcontinue;\n\t\tcomp = &ssh->state->newkeys[mode]->comp;\n\t\tif (comp && comp->enabled &&\n\t\t    (r = ssh_packet_init_compression(ssh)) != 0)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "bool CTransaction::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs, bool* pfMissingInputs)\n{\n    return mempool.accept(txdb, *this, fCheckInputs, pfMissingInputs);\n}", "target": 1}
{"code": "scrypt_SHA256_Update(struct SHA256_CTX * ctx, const void *in, size_t len)\n{\n  uint32_t bitlen[2];\n  uint32_t r;\n  const unsigned char *src = (unsigned char *) in;\n  r = (ctx->count[1] >> 3) & 0x3f;\n  bitlen[1] = ((uint32_t)len) << 3;\n  bitlen[0] = (uint32_t)(len >> 29);\n  if ((ctx->count[1] += bitlen[1]) < bitlen[1])\n    ctx->count[0]++;\n  ctx->count[0] += bitlen[0];\n  if (len < 64 - r) {\n    memcpy(&ctx->buf[r], src, len);\n    return;\n  }\n  memcpy(&ctx->buf[r], src, 64 - r);\n  SHA256_Transform(ctx->state, ctx->buf);\n  src += 64 - r;\n  len -= 64 - r;\n  while (len >= 64) {\n    SHA256_Transform(ctx->state, src);\n    src += 64;\n    len -= 64;\n  }\n  memcpy(ctx->buf, src, len);\n}", "target": 1}
{"code": "static struct nft_stats __percpu *nft_stats_alloc(const struct nlattr *attr)\n{\n\tstruct nlattr *tb[NFTA_COUNTER_MAX+1];\n\tstruct nft_stats __percpu *newstats;\n\tstruct nft_stats *stats;\n\tint err;\n\terr = nla_parse_nested(tb, NFTA_COUNTER_MAX, attr, nft_counter_policy);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\tif (!tb[NFTA_COUNTER_BYTES] || !tb[NFTA_COUNTER_PACKETS])\n\t\treturn ERR_PTR(-EINVAL);\n\tnewstats = netdev_alloc_pcpu_stats(struct nft_stats);\n\tif (newstats == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tstats = this_cpu_ptr(newstats);\n\tstats->bytes = be64_to_cpu(nla_get_be64(tb[NFTA_COUNTER_BYTES]));\n\tstats->pkts = be64_to_cpu(nla_get_be64(tb[NFTA_COUNTER_PACKETS]));\n\treturn newstats;\n}", "target": 0}
{"code": "static int i8042_start(struct serio *serio)\n{\n\tstruct i8042_port *port = serio->port_data;\n\tport->exists = true;\n\tmb();\n\treturn 0;\n}", "target": 1}
{"code": "void exit_io_context(void)\n{\n\tstruct io_context *ioc;\n\ttask_lock(current);\n\tioc = current->io_context;\n\tcurrent->io_context = NULL;\n\ttask_unlock(current);\n\tif (atomic_dec_and_test(&ioc->nr_tasks)) {\n\t\tif (ioc->aic && ioc->aic->exit)\n\t\t\tioc->aic->exit(ioc->aic);\n\t\tcfq_exit(ioc);\n\t\tput_io_context(ioc);\n\t}\n}", "target": 1}
{"code": "TEST(Context, EmptyHeadersAttributes) {\n  Protobuf::Arena arena;\n  HeadersWrapper<Http::RequestHeaderMap> headers(arena, nullptr);\n  auto header = headers[CelValue::CreateStringView(Referer)];\n  EXPECT_FALSE(header.has_value());\n  EXPECT_EQ(0, headers.size());\n  EXPECT_TRUE(headers.empty());\n}", "target": 0}
{"code": "__alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order, int preferred_nid,\n\t\t\t\t\t\t\tnodemask_t *nodemask)\n{\n\tstruct page *page;\n\tunsigned int alloc_flags = ALLOC_WMARK_LOW;\n\tgfp_t alloc_mask; \n\tstruct alloc_context ac = { };\n\tgfp_mask &= gfp_allowed_mask;\n\talloc_mask = gfp_mask;\n\tif (!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, &ac, &alloc_mask, &alloc_flags))\n\t\treturn NULL;\n\tfinalise_ac(gfp_mask, order, &ac);\n\tpage = get_page_from_freelist(alloc_mask, order, alloc_flags, &ac);\n\tif (likely(page))\n\t\tgoto out;\n\talloc_mask = current_gfp_context(gfp_mask);\n\tac.spread_dirty_pages = false;\n\tif (unlikely(ac.nodemask != nodemask))\n\t\tac.nodemask = nodemask;\n\tpage = __alloc_pages_slowpath(alloc_mask, order, &ac);\nout:\n\tif (memcg_kmem_enabled() && (gfp_mask & __GFP_ACCOUNT) && page &&\n\t    unlikely(memcg_kmem_charge(page, gfp_mask, order) != 0)) {\n\t\t__free_pages(page, order);\n\t\tpage = NULL;\n\t}\n\ttrace_mm_page_alloc(page, order, alloc_mask, ac.migratetype);\n\treturn page;\n}", "target": 0}
{"code": "static __u8 *pl_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 60 && rdesc[39] == 0x2a && rdesc[40] == 0xf5 &&\n\t\t\trdesc[41] == 0x00 && rdesc[59] == 0x26 &&\n\t\t\trdesc[60] == 0xf9 && rdesc[61] == 0x00) {\n\t\thid_info(hdev, \"fixing up Petalynx Maxter Remote report descriptor\\n\");\n\t\trdesc[60] = 0xfa;\n\t\trdesc[40] = 0xfa;\n\t}\n\treturn rdesc;\n}", "target": 1}
{"code": "static int rm_rf_inner_child(\n                int fd,\n                const char *fname,\n                int is_dir,\n                RemoveFlags flags,\n                const struct stat *root_dev,\n                bool allow_recursion) {\n        struct stat st;\n        int r, q = 0;\n        assert(fd >= 0);\n        assert(fname);\n        if (is_dir < 0 ||\n            root_dev ||\n            (is_dir > 0 && (root_dev || (flags & REMOVE_SUBVOLUME)))) {\n                r = fstatat_harder(fd, fname, &st, AT_SYMLINK_NOFOLLOW, flags);\n                if (r < 0)\n                        return r;\n                is_dir = S_ISDIR(st.st_mode);\n        }\n        if (is_dir) {\n                if (root_dev && st.st_dev != root_dev->st_dev)\n                        return 0;\n                r = fd_is_mount_point(fd, fname, 0);\n                if (r < 0)\n                        return r;\n                if (r > 0)\n                        return 0;\n                if ((flags & REMOVE_SUBVOLUME) && btrfs_might_be_subvol(&st)) {\n                        r = btrfs_subvol_remove_fd(fd, fname, BTRFS_REMOVE_RECURSIVE|BTRFS_REMOVE_QUOTA);\n                        if (r < 0) {\n                                if (!IN_SET(r, -ENOTTY, -EINVAL))\n                                        return r;\n                        } else\n                                return 1;\n                }\n                if (!allow_recursion)\n                        return -EISDIR;\n                int subdir_fd = openat(fd, fname, O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);\n                if (subdir_fd < 0)\n                        return -errno;\n                q = rm_rf_children(subdir_fd, flags | REMOVE_PHYSICAL, root_dev);\n        } else if (flags & REMOVE_ONLY_DIRECTORIES)\n                return 0;\n        r = unlinkat_harder(fd, fname, is_dir ? AT_REMOVEDIR : 0, flags);\n        if (r < 0)\n                return r;\n        if (q < 0)\n                return q;\n        return 1;\n}", "target": 0}
{"code": "parse_atxheader(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size)\n{\n\tsize_t level = 0;\n\tsize_t i, end, skip;\n\twhile (level < size && level < 6 && data[level] == '#')\n\t\tlevel++;\n\tfor (i = level; i < size && data[i] == ' '; i++);\n\tfor (end = i; end < size && data[end] != '\\n'; end++);\n\tskip = end;\n\twhile (end && data[end - 1] == '#')\n\t\tend--;\n\twhile (end && data[end - 1] == ' ')\n\t\tend--;\n\tif (end > i) {\n\t\tstruct buf *work = rndr_newbuf(rndr, BUFFER_SPAN);\n\t\tparse_inline(work, rndr, data + i, end - i);\n\t\tif (rndr->cb.header)\n\t\t\trndr->cb.header(ob, work, (int)level, rndr->opaque);\n\t\trndr_popbuf(rndr, BUFFER_SPAN);\n\t}\n\treturn skip;\n}", "target": 0}
{"code": "rdr_notification_ctx_cleanup(struct rdr_notification_ctx *ctx)\n{\n\tif (ctx->deltas.array != NULL)\n\t\tdeltas_parsed_cleanup(&ctx->deltas, __delta_head_destroy);\n}", "target": 1}
{"code": "static uint8_t nvme_sq_empty(NvmeSQueue *sq)\n{\n    return sq->head == sq->tail;\n}", "target": 0}
{"code": "void dvb_usbv2_disconnect(struct usb_interface *intf)\n{\n\tstruct dvb_usb_device *d = usb_get_intfdata(intf);\n\tconst char *name = d->name;\n\tstruct device dev = d->udev->dev;\n\tdev_dbg(&d->udev->dev, \"%s: bInterfaceNumber=%d\\n\", __func__,\n\t\t\tintf->cur_altsetting->desc.bInterfaceNumber);\n\tif (d->props->exit)\n\t\td->props->exit(d);\n\tdvb_usbv2_exit(d);\n\tdev_info(&dev, \"%s: '%s' successfully deinitialized and disconnected\\n\",\n\t\t\tKBUILD_MODNAME, name);\n}", "target": 1}
{"code": "sg_vma_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tSg_fd *sfp;\n\tunsigned long offset, len, sa;\n\tSg_scatter_hold *rsv_schp;\n\tint k, length;\n\tif ((NULL == vma) || (!(sfp = (Sg_fd *) vma->vm_private_data)))\n\t\treturn VM_FAULT_SIGBUS;\n\trsv_schp = &sfp->reserve;\n\toffset = vmf->pgoff << PAGE_SHIFT;\n\tif (offset >= rsv_schp->bufflen)\n\t\treturn VM_FAULT_SIGBUS;\n\tSCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t\t      \"sg_vma_fault: offset=%lu, scatg=%d\\n\",\n\t\t\t\t      offset, rsv_schp->k_use_sg));\n\tsa = vma->vm_start;\n\tlength = 1 << (PAGE_SHIFT + rsv_schp->page_order);\n\tfor (k = 0; k < rsv_schp->k_use_sg && sa < vma->vm_end; k++) {\n\t\tlen = vma->vm_end - sa;\n\t\tlen = (len < length) ? len : length;\n\t\tif (offset < len) {\n\t\t\tstruct page *page = nth_page(rsv_schp->pages[k],\n\t\t\t\t\t\t     offset >> PAGE_SHIFT);\n\t\t\tget_page(page);\t\n\t\t\tvmf->page = page;\n\t\t\treturn 0; \n\t\t}\n\t\tsa += len;\n\t\toffset -= len;\n\t}\n\treturn VM_FAULT_SIGBUS;\n}", "target": 0}
{"code": "GetNumWrongData(const byte * curPtr, const int maxnum)\n{\n    int count = 0;\n    if (1 == maxnum) {\n        return (1);\n    }\n    while (*(curPtr + count) != *(curPtr + count + 1) && maxnum > count) {\n        count++;\n    }\n    return (count);\n}", "target": 1}
{"code": "static void __tcp_ack_snd_check(struct sock *sk, int ofo_possible)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tif (((tp->rcv_nxt - tp->rcv_wup) > inet_csk(sk)->icsk_ack.rcv_mss &&\n\t     __tcp_select_window(sk) >= tp->rcv_wnd) ||\n\t    tcp_in_quickack_mode(sk) ||\n\t    (ofo_possible && skb_peek(&tp->out_of_order_queue))) {\n\t\ttcp_send_ack(sk);\n\t} else {\n\t\ttcp_send_delayed_ack(sk);\n\t}\n}", "target": 0}
{"code": "static void b43_request_firmware(struct work_struct *work)\n{\n\tstruct b43_wl *wl = container_of(work,\n\t\t\t    struct b43_wl, firmware_load);\n\tstruct b43_wldev *dev = wl->current_dev;\n\tstruct b43_request_fw_context *ctx;\n\tunsigned int i;\n\tint err;\n\tconst char *errmsg;\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn;\n\tctx->dev = dev;\n\tctx->req_type = B43_FWTYPE_PROPRIETARY;\n\terr = b43_try_request_fw(ctx);\n\tif (!err)\n\t\tgoto start_ieee80211; \n\tif (ctx->fatal_failure)\n\t\tgoto out;\n\tctx->req_type = B43_FWTYPE_OPENSOURCE;\n\terr = b43_try_request_fw(ctx);\n\tif (!err)\n\t\tgoto start_ieee80211; \n\tif(ctx->fatal_failure)\n\t\tgoto out;\n\tfor (i = 0; i < B43_NR_FWTYPES; i++) {\n\t\terrmsg = ctx->errors[i];\n\t\tif (strlen(errmsg))\n\t\t\tb43err(dev->wl, errmsg);\n\t}\n\tb43_print_fw_helptext(dev->wl, 1);\n\tgoto out;\nstart_ieee80211:\n\twl->hw->queues = B43_QOS_QUEUE_NUM;\n\tif (!modparam_qos || dev->fw.opensource)\n\t\twl->hw->queues = 1;\n\terr = ieee80211_register_hw(wl->hw);\n\tif (err)\n\t\tgoto err_one_core_detach;\n\twl->hw_registred = true;\n\tb43_leds_register(wl->current_dev);\n\tgoto out;\nerr_one_core_detach:\n\tb43_one_core_detach(dev->dev);\nout:\n\tkfree(ctx);\n}", "target": 1}
{"code": "static inline ut64 dwarf_read_offset(bool is_64bit, const ut8 **buf, const ut8 *buf_end) {\n\tut64 result;\n\tif (is_64bit) {\n\t\tresult = READ64 (*buf);\n\t} else {\n\t\tresult = READ32 (*buf);\n\t}\n\treturn result;\n}", "target": 1}
{"code": "try_flatedecode(unsigned char *buf, off_t real_len, off_t calculated_len, int fout, cli_ctx *ctx)\n{\n\tint ret = cli_checklimits(\"cli_pdf\", ctx, real_len, 0, 0);\n\tif (ret==CL_CLEAN && flatedecode(buf, real_len, fout, ctx) == CL_SUCCESS)\n\t\treturn CL_CLEAN;\n\tif(real_len == calculated_len) {\n\t\tcli_dbgmsg(\"cli_pdf: Bad compression in flate stream\\n\");\n\t\treturn CL_CLEAN;\n\t}\n\tif(cli_checklimits(\"cli_pdf\", ctx, calculated_len, 0, 0)!=CL_CLEAN)\n\t\treturn CL_CLEAN;\n\tret = flatedecode(buf, calculated_len, fout, ctx);\n\tif(ret == CL_CLEAN)\n\t\treturn CL_CLEAN;\n\tcli_dbgmsg(\"cli_pdf: Bad compressed block length in flate stream\\n\");\n\treturn ret;\n}", "target": 0}
{"code": "gen_muldiv(codegen_scope *s, uint8_t op, uint16_t dst)\n{\n  if (no_peephole(s)) {\n  normal:\n    genop_1(s, op, dst);\n    return;\n  }\n  else {\n    struct mrb_insn_data data = mrb_last_insn(s);\n    mrb_int n, n0;\n    if (addr_pc(s, data.addr) == s->lastlabel || !get_int_operand(s, &data, &n)) {\n      goto normal;\n    }\n    struct mrb_insn_data data0 = mrb_decode_insn(mrb_prev_pc(s, data.addr));\n    if (!get_int_operand(s, &data0, &n0) || n == 0) {\n      goto normal;\n    }\n    if (op == OP_MUL) {\n      if (mrb_int_mul_overflow(n0, n, &n)) goto normal;\n    }\n    else { \n      if (n0 == MRB_INT_MIN && n == -1) goto normal;\n      n = n0 / n;\n    }\n    s->pc = addr_pc(s, data0.addr);\n    gen_int(s, dst, n);\n  }\n}", "target": 0}
{"code": "ts_date_hmsfrac_print(netdissect_options *ndo, long sec, long usec,\n\t\t      enum date_flag date_flag, enum time_flag time_flag)\n{\n\ttime_t Time = sec;\n\tstruct tm *tm;\n\tchar timestr[32];\n\tif ((unsigned)sec & 0x80000000) {\n\t\tND_PRINT(\"[Error converting time]\");\n\t\treturn;\n\t}\n\tif (time_flag == LOCAL_TIME)\n\t\ttm = localtime(&Time);\n\telse\n\t\ttm = gmtime(&Time);\n\tif (!tm) {\n\t\tND_PRINT(\"[Error converting time]\");\n\t\treturn;\n\t}\n\tif (date_flag == WITH_DATE)\n\t\tstrftime(timestr, sizeof(timestr), \"%Y-%m-%d %H:%M:%S\", tm);\n\telse\n\t\tstrftime(timestr, sizeof(timestr), \"%H:%M:%S\", tm);\n\tND_PRINT(\"%s\", timestr);\n\tts_frac_print(ndo, usec);\n}", "target": 1}
{"code": "spnego_gss_unwrap_iov(OM_uint32 *minor_status,\n\t\t      gss_ctx_id_t context_handle,\n\t\t      int *conf_state,\n\t\t      gss_qop_t *qop_state,\n\t\t      gss_iov_buffer_desc *iov,\n\t\t      int iov_count)\n{\n\tOM_uint32 ret;\n\tret = gss_unwrap_iov(minor_status,\n\t\t\t     context_handle,\n\t\t\t     conf_state,\n\t\t\t     qop_state,\n\t\t\t     iov,\n\t\t\t     iov_count);\n\treturn (ret);\n}", "target": 0}
{"code": "krb5_gss_process_context_token(minor_status, context_handle,\n                               token_buffer)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    gss_buffer_t token_buffer;\n{\n    krb5_gss_ctx_id_rec *ctx;\n    OM_uint32 majerr;\n    ctx = (krb5_gss_ctx_id_t) context_handle;\n    if (! ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n    if (GSS_ERROR(majerr = kg_unseal(minor_status, context_handle,\n                                     token_buffer,\n                                     GSS_C_NO_BUFFER, NULL, NULL,\n                                     KG_TOK_DEL_CTX)))\n        return(majerr);\n    return(krb5_gss_delete_sec_context(minor_status, &context_handle,\n                                       GSS_C_NO_BUFFER));\n}", "target": 1}
{"code": "static void *bpf_obj_do_get(const struct filename *pathname,\n\t\t\t    enum bpf_type *type)\n{\n\tstruct inode *inode;\n\tstruct path path;\n\tvoid *raw;\n\tint ret;\n\tret = kern_path(pathname->name, LOOKUP_FOLLOW, &path);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\tinode = d_backing_inode(path.dentry);\n\tret = inode_permission(inode, MAY_WRITE);\n\tif (ret)\n\t\tgoto out;\n\tret = bpf_inode_type(inode, type);\n\tif (ret)\n\t\tgoto out;\n\traw = bpf_any_get(inode->i_private, *type);\n\ttouch_atime(&path);\n\tpath_put(&path);\n\treturn raw;\nout:\n\tpath_put(&path);\n\treturn ERR_PTR(ret);\n}", "target": 1}
{"code": "static int __init efi_load_efivars(void)\n{\n\tstruct platform_device *pdev;\n\tif (!efi_enabled(EFI_RUNTIME_SERVICES))\n\t\treturn 0;\n\tpdev = platform_device_register_simple(\"efivars\", 0, NULL, 0);\n\treturn PTR_ERR_OR_ZERO(pdev);\n}", "target": 0}
{"code": "static int nft_delrule(struct nft_ctx *ctx, struct nft_rule *rule)\n{\n\tstruct nft_trans *trans;\n\tint err;\n\ttrans = nft_trans_rule_add(ctx, NFT_MSG_DELRULE, rule);\n\tif (trans == NULL)\n\t\treturn -ENOMEM;\n\terr = nf_tables_delrule_deactivate(ctx, rule);\n\tif (err < 0) {\n\t\tnft_trans_destroy(trans);\n\t\treturn err;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "newVar_N2(char *var,char *var2, char *var3,char *var4,int pop_counter,char *final)\n{\n\tstruct SWF_ACTIONPUSHPARAM *v;\n\tint psize=PARAM_STRSIZE;\n\tint i;\n\tint slen=strlen(var)+strlen(var2)+strlen(var3)+strlen(var4)+strlen(final);\n\tv=malloc(sizeof(struct SWF_ACTIONPUSHPARAM));\n\tv->p.String = malloc(psize + slen);\n\tv->Type = PUSH_VARIABLE; \n\tstrcpy(v->p.String,var);\n\tstrcat(v->p.String,var2);\n\tstrcat(v->p.String,var3);\n\tstrcat(v->p.String,var4);\n\tfor(i=0;i<pop_counter;i++) \n\t{\n\t\tchar *pops1=getString(pop());\n\t\tchar *pops2=getName  (pop());\n\t\twhile ( strlen(v->p.String)+ 3 + strlen(pops1)+ strlen(pops2) +slen >= psize)\n\t\t{\n\t\t\tpsize += PARAM_STRSIZE;\n\t\t\tv->p.String = realloc( v->p.String, psize);\n\t\t}\n\t\tstrcat(v->p.String,pops2);\n\t\tstrcat(v->p.String,\":\");\n\t\tstrcat(v->p.String,pops1);\n\t\tif( i < pop_counter-1 ) \n\t\t\tstrcat(v->p.String,\",\");\n\t}\n\tstrcat(v->p.String,final);\n\treturn v;\n}", "target": 0}
{"code": "static void vcpu_scan_ioapic(struct kvm_vcpu *vcpu)\n{\n\tif (!kvm_apic_hw_enabled(vcpu->arch.apic))\n\t\treturn;\n\tbitmap_zero(vcpu->arch.ioapic_handled_vectors, 256);\n\tif (irqchip_split(vcpu->kvm))\n\t\tkvm_scan_ioapic_routes(vcpu, vcpu->arch.ioapic_handled_vectors);\n\telse {\n\t\tif (vcpu->arch.apicv_active)\n\t\t\tkvm_x86_ops->sync_pir_to_irr(vcpu);\n\t\tkvm_ioapic_scan_entry(vcpu, vcpu->arch.ioapic_handled_vectors);\n\t}\n\tif (is_guest_mode(vcpu))\n\t\tvcpu->arch.load_eoi_exitmap_pending = true;\n\telse\n\t\tkvm_make_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu);\n}", "target": 1}
{"code": "void in6_dev_finish_destroy(struct inet6_dev *idev)\n{\n\tstruct net_device *dev = idev->dev;\n\tWARN_ON(!list_empty(&idev->addr_list));\n\tWARN_ON(idev->mc_list != NULL);\n\tWARN_ON(timer_pending(&idev->rs_timer));\n#ifdef NET_REFCNT_DEBUG\n\tpr_debug(\"%s: %s\\n\", __func__, dev ? dev->name : \"NIL\");\n#endif\n\tdev_put(dev);\n\tif (!idev->dead) {\n\t\tpr_warn(\"Freeing alive inet6 device %p\\n\", idev);\n\t\treturn;\n\t}\n\tsnmp6_free_dev(idev);\n\tkfree_rcu(idev, rcu);\n}", "target": 0}
{"code": "static int orinoco_ioctl_setpower(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  struct iw_param *prq,\n\t\t\t\t  char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint err = -EINPROGRESS;\t\t\n\tunsigned long flags;\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\tif (prq->disabled) {\n\t\tpriv->pm_on = 0;\n\t} else {\n\t\tswitch (prq->flags & IW_POWER_MODE) {\n\t\tcase IW_POWER_UNICAST_R:\n\t\t\tpriv->pm_mcast = 0;\n\t\t\tpriv->pm_on = 1;\n\t\t\tbreak;\n\t\tcase IW_POWER_ALL_R:\n\t\t\tpriv->pm_mcast = 1;\n\t\t\tpriv->pm_on = 1;\n\t\t\tbreak;\n\t\tcase IW_POWER_ON:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (prq->flags & IW_POWER_TIMEOUT) {\n\t\t\tpriv->pm_on = 1;\n\t\t\tpriv->pm_timeout = prq->value / 1000;\n\t\t}\n\t\tif (prq->flags & IW_POWER_PERIOD) {\n\t\t\tpriv->pm_on = 1;\n\t\t\tpriv->pm_period = prq->value / 1000;\n\t\t}\n\t\tif (!priv->pm_on) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n out:\n\torinoco_unlock(priv, &flags);\n\treturn err;\n}", "target": 0}
{"code": "static void nft_objref_map_activate(const struct nft_ctx *ctx,\n\t\t\t\t    const struct nft_expr *expr)\n{\n\tstruct nft_objref_map *priv = nft_expr_priv(expr);\n\tpriv->set->use++;\n}", "target": 1}
{"code": "static inline pgd_t *pgd_alloc(struct mm_struct *mm)\n{\n\tspin_lock_init(&mm->context.list_lock);\n\tINIT_LIST_HEAD(&mm->context.pgtable_list);\n\tINIT_LIST_HEAD(&mm->context.gmap_list);\n\treturn (pgd_t *) crst_table_alloc(mm);\n}", "target": 1}
{"code": "int ff_init_buffer_info(AVCodecContext *avctx, AVFrame *frame)\n{\n    if (avctx->internal->pkt) {\n        frame->pkt_pts = avctx->internal->pkt->pts;\n        av_frame_set_pkt_pos     (frame, avctx->internal->pkt->pos);\n        av_frame_set_pkt_duration(frame, avctx->internal->pkt->duration);\n        av_frame_set_pkt_size    (frame, avctx->internal->pkt->size);\n    } else {\n        frame->pkt_pts = AV_NOPTS_VALUE;\n        av_frame_set_pkt_pos     (frame, -1);\n        av_frame_set_pkt_duration(frame, 0);\n        av_frame_set_pkt_size    (frame, -1);\n    }\n    frame->reordered_opaque = avctx->reordered_opaque;\n    switch (avctx->codec->type) {\n    case AVMEDIA_TYPE_VIDEO:\n        frame->format              = avctx->pix_fmt;\n        if (!frame->sample_aspect_ratio.num)\n            frame->sample_aspect_ratio = avctx->sample_aspect_ratio;\n        if (av_frame_get_colorspace(frame) == AVCOL_SPC_UNSPECIFIED)\n            av_frame_set_colorspace(frame, avctx->colorspace);\n        if (av_frame_get_color_range(frame) == AVCOL_RANGE_UNSPECIFIED)\n            av_frame_set_color_range(frame, avctx->color_range);\n        break;\n    case AVMEDIA_TYPE_AUDIO:\n        if (!frame->sample_rate)\n            frame->sample_rate    = avctx->sample_rate;\n        if (frame->format < 0)\n            frame->format         = avctx->sample_fmt;\n        if (!frame->channel_layout) {\n            if (avctx->channel_layout) {\n                 if (av_get_channel_layout_nb_channels(avctx->channel_layout) !=\n                     avctx->channels) {\n                     av_log(avctx, AV_LOG_ERROR, \"Inconsistent channel \"\n                            \"configuration.\\n\");\n                     return AVERROR(EINVAL);\n                 }\n                frame->channel_layout = avctx->channel_layout;\n            } else {\n                if (avctx->channels > FF_SANE_NB_CHANNELS) {\n                    av_log(avctx, AV_LOG_ERROR, \"Too many channels: %d.\\n\",\n                           avctx->channels);\n                    return AVERROR(ENOSYS);\n                }\n            }\n        }\n        av_frame_set_channels(frame, avctx->channels);\n        break;\n    }\n    return 0;\n}", "target": 0}
{"code": "de265_error decoder_context::decode(int* more)\n{\n  decoder_context* ctx = this;\n  if (ctx->nal_parser.get_NAL_queue_length() == 0 &&\n      (ctx->nal_parser.is_end_of_stream() || ctx->nal_parser.is_end_of_frame()) &&\n      ctx->image_units.empty()) {\n    ctx->dpb.flush_reorder_buffer();\n    if (more) { *more = ctx->dpb.num_pictures_in_output_queue(); }\n    return DE265_OK;\n  }\n  if (ctx->nal_parser.is_end_of_stream() == false &&\n      ctx->nal_parser.is_end_of_frame() == false &&\n      ctx->nal_parser.get_NAL_queue_length() == 0) {\n    if (more) { *more=1; }\n    return DE265_ERROR_WAITING_FOR_INPUT_DATA;\n  }\n  if (!ctx->dpb.has_free_dpb_picture(false)) {\n    if (more) *more = 1;\n    return DE265_ERROR_IMAGE_BUFFER_FULL;\n  }\n  de265_error err = DE265_OK;\n  bool did_work = false;\n  if (ctx->nal_parser.get_NAL_queue_length()) { \n    NAL_unit* nal = ctx->nal_parser.pop_from_NAL_queue();\n    assert(nal);\n    err = ctx->decode_NAL(nal);\n    did_work=true;\n  }\n  else if (ctx->nal_parser.is_end_of_frame() == true &&\n      ctx->image_units.empty()) {\n    if (more) { *more=1; }\n    return DE265_ERROR_WAITING_FOR_INPUT_DATA;\n  }\n  else {\n    err = decode_some(&did_work);\n  }\n  if (more) {\n    *more = (err==DE265_OK && did_work);\n  }\n  return err;\n}", "target": 0}
{"code": "static int snd_ctl_elem_read(struct snd_card *card,\n\t\t\t     struct snd_ctl_elem_value *control)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int index_offset;\n\tstruct snd_ctl_elem_info info;\n\tconst u32 pattern = 0xdeadbeef;\n\tint ret;\n\tkctl = snd_ctl_find_id(card, &control->id);\n\tif (kctl == NULL)\n\t\treturn -ENOENT;\n\tindex_offset = snd_ctl_get_ioff(kctl, &control->id);\n\tvd = &kctl->vd[index_offset];\n\tif (!(vd->access & SNDRV_CTL_ELEM_ACCESS_READ) || kctl->get == NULL)\n\t\treturn -EPERM;\n\tsnd_ctl_build_ioff(&control->id, kctl, index_offset);\n#ifdef CONFIG_SND_CTL_DEBUG\n\tmemset(&info, 0, sizeof(info));\n\tinfo.id = control->id;\n\tret = __snd_ctl_elem_info(card, kctl, &info, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n#endif\n\tif (!snd_ctl_skip_validation(&info))\n\t\tfill_remaining_elem_value(control, &info, pattern);\n\tret = snd_power_ref_and_wait(card);\n\tif (!ret)\n\t\tret = kctl->get(kctl, control);\n\tsnd_power_unref(card);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!snd_ctl_skip_validation(&info) &&\n\t    sanity_check_elem_value(card, control, &info, pattern) < 0) {\n\t\tdev_err(card->dev,\n\t\t\t\"control %i:%i:%i:%s:%i: access overflow\\n\",\n\t\t\tcontrol->id.iface, control->id.device,\n\t\t\tcontrol->id.subdevice, control->id.name,\n\t\t\tcontrol->id.index);\n\t\treturn -EINVAL;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "int dns_HTTPS_add_ipv6hint(struct dns_rr_nested *svcparam, unsigned char addr[][DNS_RR_AAAA_LEN], int addr_num)\n{\n\tif (_dns_left_len(&svcparam->context) < 4 + addr_num * DNS_RR_AAAA_LEN) {\n\t\treturn -1;\n\t}\n\tunsigned short value = DNS_HTTPS_T_IPV6HINT;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\tvalue = addr_num * DNS_RR_AAAA_LEN;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\tfor (int i = 0; i < addr_num; i++) {\n\t\tdns_add_rr_nested_memcpy(svcparam, addr[i], DNS_RR_AAAA_LEN);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "bool IsIdentityConsumingSwitch(const MutableGraphView& graph,\n                               const NodeDef& node) {\n  if ((IsIdentity(node) || IsIdentityNSingleInput(node)) &&\n      node.input_size() > 0) {\n    TensorId tensor_id = ParseTensorName(node.input(0));\n    if (IsTensorIdControlling(tensor_id)) {\n      return false;\n    }\n    NodeDef* input_node = graph.GetNode(tensor_id.node());\n    return IsSwitch(*input_node);\n  }\n  return false;\n}", "target": 1}
{"code": "static ssize_t aio_setup_vectored_rw(struct kiocb *kiocb,\n\t\t\t\t     int rw, char __user *buf,\n\t\t\t\t     unsigned long *nr_segs,\n\t\t\t\t     size_t *len,\n\t\t\t\t     struct iovec **iovec,\n\t\t\t\t     bool compat)\n{\n\tssize_t ret;\n\t*nr_segs = *len;\n#ifdef CONFIG_COMPAT\n\tif (compat)\n\t\tret = compat_rw_copy_check_uvector(rw,\n\t\t\t\t(struct compat_iovec __user *)buf,\n\t\t\t\t*nr_segs, UIO_FASTIOV, *iovec, iovec);\n\telse\n#endif\n\t\tret = rw_copy_check_uvector(rw,\n\t\t\t\t(struct iovec __user *)buf,\n\t\t\t\t*nr_segs, UIO_FASTIOV, *iovec, iovec);\n\tif (ret < 0)\n\t\treturn ret;\n\t*len = ret;\n\treturn 0;\n}", "target": 1}
{"code": "static s64 cpu_cfs_quota_read_s64(struct cgroup_subsys_state *css,\n\t\t\t\t  struct cftype *cft)\n{\n\treturn tg_get_cfs_quota(css_tg(css));\n}", "target": 0}
{"code": "void ConnectDialog::on_qtwServers_customContextMenuRequested(const QPoint &mpos) {\n\tServerItem *si = static_cast<ServerItem *>(qtwServers->itemAt(mpos));\n\tqmPopup->clear();\n\tif (si != NULL && si->bParent) {\n\t\tsi = NULL;\n\t}\n\tif (si != NULL) {\n\t\tif (!g.s.disableConnectDialogEditing) {\n\t\t\tif (si->itType == ServerItem::FavoriteType) {\n\t\t\t\tqmPopup->addAction(qaFavoriteEdit);\n\t\t\t\tqmPopup->addAction(qaFavoriteRemove);\n\t\t\t} else {\n\t\t\t\tqmPopup->addAction(qaFavoriteAdd);\n\t\t\t}\n\t\t}\n\t\tif (!si->qsUrl.isEmpty()) {\n\t\t\tqmPopup->addAction(qaUrl);\n\t\t}\n\t}\n\tif (! qmPopup->isEmpty()) {\n\t\tqmPopup->addSeparator();\n\t}\n\tqmPopup->addMenu(qmFilters);\n\tqmPopup->popup(qtwServers->viewport()->mapToGlobal(mpos), NULL);\n}", "target": 0}
{"code": "swallow_until_crlf(int fd, uschar *base, int already, int capacity)\n{\nuschar *to = base + already;\nuschar *cr;\nint have = 0;\nint ret;\nint last = 0;\ncr = memchr(base, '\\r', already);\nif (cr != NULL)\n  {\n  if ((cr - base) < already - 1)\n    {\n    return 0;\n    }\n  last = 1;\n  }\nwhile (capacity > 0)\n  {\n  do { ret = recv(fd, to, 1, 0); } while (ret == -1 && errno == EINTR);\n  if (ret == -1)\n    return -1;\n  have++;\n  if (last)\n    return have;\n  if (*to == '\\r')\n    last = 1;\n  capacity--;\n  to++;\n  }\nerrno = EOVERFLOW;\nreturn -1;\n}", "target": 0}
{"code": "static u16 swf_get_16(SWFReader *read)\n{\n\tu16 val, res;\n\tval = swf_read_int(read, 16);\n\tres = (val&0xFF);\n\tres <<=8;\n\tres |= ((val>>8)&0xFF);\n\treturn res;\n}", "target": 1}
{"code": "archive_read_support_format_zip_streamable(struct archive *_a)\n{\n\tstruct archive_read *a = (struct archive_read *)_a;\n\tstruct zip *zip;\n\tint r;\n\tarchive_check_magic(_a, ARCHIVE_READ_MAGIC,\n\t    ARCHIVE_STATE_NEW, \"archive_read_support_format_zip\");\n\tzip = (struct zip *)calloc(1, sizeof(*zip));\n\tif (zip == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"Can't allocate zip data\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tzip->process_mac_extensions = 0;\n\tzip->has_encrypted_entries = ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW;\n\tzip->crc32func = real_crc32;\n\tr = __archive_read_register_format(a,\n\t    zip,\n\t    \"zip\",\n\t    archive_read_format_zip_streamable_bid,\n\t    archive_read_format_zip_options,\n\t    archive_read_format_zip_streamable_read_header,\n\t    archive_read_format_zip_read_data,\n\t    archive_read_format_zip_read_data_skip_streamable,\n\t    NULL,\n\t    archive_read_format_zip_cleanup,\n\t    archive_read_support_format_zip_capabilities_streamable,\n\t    archive_read_format_zip_has_encrypted_entries);\n\tif (r != ARCHIVE_OK)\n\t\tfree(zip);\n\treturn (ARCHIVE_OK);\n}", "target": 0}
{"code": "CLua &CLua::get_vm(lua_State *ls)\n{\n    lua_stack_cleaner clean(ls);\n    _getregistry(ls, \"__clua\");\n    CLua *vm = clua_get_lightuserdata<CLua>(ls, -1);\n    if (!vm)\n        luaL_error(ls, \"Could not find matching clua for lua state\");\n    return *vm;\n}", "target": 0}
{"code": "Network::FilterStatus Context::onDownstreamData(int data_length, bool end_of_stream) {\n  if (!wasm_->onDownstreamData_) {\n    return Network::FilterStatus::Continue;\n  }\n  auto result = wasm_->onDownstreamData_(this, id_, static_cast<uint32_t>(data_length),\n                                         static_cast<uint32_t>(end_of_stream));\n  return result.u64_ == 0 ? Network::FilterStatus::Continue : Network::FilterStatus::StopIteration;\n}", "target": 1}
{"code": "sigalrm_handler(int sig)\n{\nsig = sig;            \nsigalrm_seen = TRUE;\n}", "target": 0}
{"code": "file_printable(char *buf, size_t bufsiz, const char *str)\n{\n\tchar *ptr, *eptr;\n\tconst unsigned char *s = (const unsigned char *)str;\n\tfor (ptr = buf, eptr = ptr + bufsiz - 1; ptr < eptr && *s; s++) {\n\t\tif (isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr + 4)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((*s >> 6) & 7) + '0';\n\t\t*ptr++ = ((*s >> 3) & 7) + '0';\n\t\t*ptr++ = ((*s >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}", "target": 1}
{"code": "void sc_pkcs15emu_sc_hsm_free_cvc(sc_cvc_t *cvc)\n{\n\tif (cvc->signature) {\n\t\tfree(cvc->signature);\n\t\tcvc->signature = NULL;\n\t}\n\tif (cvc->primeOrModulus) {\n\t\tfree(cvc->primeOrModulus);\n\t\tcvc->primeOrModulus = NULL;\n\t}\n\tif (cvc->coefficientAorExponent) {\n\t\tfree(cvc->coefficientAorExponent);\n\t\tcvc->coefficientAorExponent = NULL;\n\t}\n\tif (cvc->coefficientB) {\n\t\tfree(cvc->coefficientB);\n\t\tcvc->coefficientB = NULL;\n\t}\n\tif (cvc->basePointG) {\n\t\tfree(cvc->basePointG);\n\t\tcvc->basePointG = NULL;\n\t}\n\tif (cvc->order) {\n\t\tfree(cvc->order);\n\t\tcvc->order = NULL;\n\t}\n\tif (cvc->publicPoint) {\n\t\tfree(cvc->publicPoint);\n\t\tcvc->publicPoint = NULL;\n\t}\n\tif (cvc->cofactor) {\n\t\tfree(cvc->cofactor);\n\t\tcvc->cofactor = NULL;\n\t}\n}", "target": 0}
{"code": "static void OneLine(struct bmp_progressive_state *context)\n{\n\tcontext->BufferDone = 0;\n\tif (context->Lines >= context->Header.height)\n\t\treturn;\n\tif (context->Type == 32)\n\t\tOneLine32(context);\n\telse if (context->Type == 24)\n\t\tOneLine24(context);\n\telse if (context->Type == 16)\n\t\tOneLine16(context);\n\telse if (context->Type == 8)\n\t\tOneLine8(context);\n\telse if (context->Type == 4)\n\t\tOneLine4(context);\n\telse if (context->Type == 1)\n\t\tOneLine1(context);\n\telse\n\t\tg_assert_not_reached ();\n\tcontext->Lines++;\n\tif (context->updated_func != NULL) {\n\t\t(*context->updated_func) (context->pixbuf,\n\t\t\t\t\t  0,\n\t\t\t\t\t  (context->Header.Negative ?\n\t\t\t\t\t   (context->Lines - 1) :\n\t\t\t\t\t   (context->Header.height - context->Lines)),\n\t\t\t\t\t  context->Header.width,\n\t\t\t\t\t  1,\n\t\t\t\t\t  context->user_data);\n\t}\n}", "target": 0}
{"code": "static void sev_es_sync_from_ghcb(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tstruct kvm_vcpu *vcpu = &svm->vcpu;\n\tstruct ghcb *ghcb = svm->ghcb;\n\tu64 exit_code;\n\tmemset(vcpu->arch.regs, 0, sizeof(vcpu->arch.regs));\n\tvcpu->arch.regs[VCPU_REGS_RAX] = ghcb_get_rax_if_valid(ghcb);\n\tvcpu->arch.regs[VCPU_REGS_RBX] = ghcb_get_rbx_if_valid(ghcb);\n\tvcpu->arch.regs[VCPU_REGS_RCX] = ghcb_get_rcx_if_valid(ghcb);\n\tvcpu->arch.regs[VCPU_REGS_RDX] = ghcb_get_rdx_if_valid(ghcb);\n\tvcpu->arch.regs[VCPU_REGS_RSI] = ghcb_get_rsi_if_valid(ghcb);\n\tsvm->vmcb->save.cpl = ghcb_get_cpl_if_valid(ghcb);\n\tif (ghcb_xcr0_is_valid(ghcb)) {\n\t\tvcpu->arch.xcr0 = ghcb_get_xcr0(ghcb);\n\t\tkvm_update_cpuid_runtime(vcpu);\n\t}\n\texit_code = ghcb_get_sw_exit_code(ghcb);\n\tcontrol->exit_code = lower_32_bits(exit_code);\n\tcontrol->exit_code_hi = upper_32_bits(exit_code);\n\tcontrol->exit_info_1 = ghcb_get_sw_exit_info_1(ghcb);\n\tcontrol->exit_info_2 = ghcb_get_sw_exit_info_2(ghcb);\n\tmemset(ghcb->save.valid_bitmap, 0, sizeof(ghcb->save.valid_bitmap));\n}", "target": 0}
{"code": "StreamWriteResult StreamBase::Write(\n    uv_buf_t* bufs,\n    size_t count,\n    uv_stream_t* send_handle,\n    v8::Local<v8::Object> req_wrap_obj) {\n  Environment* env = stream_env();\n  int err;\n  size_t total_bytes = 0;\n  for (size_t i = 0; i < count; ++i)\n    total_bytes += bufs[i].len;\n  bytes_written_ += total_bytes;\n  if (send_handle == nullptr) {\n    err = DoTryWrite(&bufs, &count);\n    if (err != 0 || count == 0) {\n      return StreamWriteResult { false, err, nullptr, total_bytes };\n    }\n  }\n  v8::HandleScope handle_scope(env->isolate());\n  if (req_wrap_obj.IsEmpty()) {\n    if (!env->write_wrap_template()\n             ->NewInstance(env->context())\n             .ToLocal(&req_wrap_obj)) {\n      return StreamWriteResult { false, UV_EBUSY, nullptr, 0 };\n    }\n    StreamReq::ResetObject(req_wrap_obj);\n  }\n  AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(GetAsyncWrap());\n  WriteWrap* req_wrap = CreateWriteWrap(req_wrap_obj);\n  err = DoWrite(req_wrap, bufs, count, send_handle);\n  bool async = err == 0;\n  if (!async) {\n    req_wrap->Dispose();\n    req_wrap = nullptr;\n  }\n  const char* msg = Error();\n  if (msg != nullptr) {\n    req_wrap_obj->Set(env->context(),\n                      env->error_string(),\n                      OneByteString(env->isolate(), msg)).Check();\n    ClearError();\n  }\n  return StreamWriteResult { async, err, req_wrap, total_bytes };\n}", "target": 1}
{"code": "static void evdev_cleanup(struct evdev *evdev)\n{\n\tstruct input_handle *handle = &evdev->handle;\n\tevdev_mark_dead(evdev);\n\tevdev_hangup(evdev);\n\tcdev_del(&evdev->cdev);\n\tif (evdev->open) {\n\t\tinput_flush_device(handle, NULL);\n\t\tinput_close_device(handle);\n\t}\n}", "target": 0}
{"code": "static ssize_t aio_setup_single_vector(struct kiocb *kiocb,\n\t\t\t\t       int rw, char __user *buf,\n\t\t\t\t       unsigned long *nr_segs,\n\t\t\t\t       size_t len,\n\t\t\t\t       struct iovec *iovec)\n{\n\tif (unlikely(!access_ok(!rw, buf, len)))\n\t\treturn -EFAULT;\n\tiovec->iov_base = buf;\n\tiovec->iov_len = len;\n\t*nr_segs = 1;\n\treturn 0;\n}", "target": 1}
{"code": "void options_free() {\n    parse_global_option(CMD_FREE, NULL, NULL);\n}", "target": 1}
{"code": "int hci_req_sync(struct hci_dev *hdev, int (*req)(struct hci_request *req,\n\t\t\t\t\t\t  unsigned long opt),\n\t\t unsigned long opt, u32 timeout, u8 *hci_status)\n{\n\tint ret;\n\tif (!test_bit(HCI_UP, &hdev->flags))\n\t\treturn -ENETDOWN;\n\thci_req_sync_lock(hdev);\n\tret = __hci_req_sync(hdev, req, opt, timeout, hci_status);\n\thci_req_sync_unlock(hdev);\n\treturn ret;\n}", "target": 1}
{"code": "AudioFlinger::EffectChain::EffectChain(ThreadBase *thread,\n int sessionId)\n : mThread(thread), mSessionId(sessionId), mActiveTrackCnt(0), mTrackCnt(0), mTailBufferCount(0),\n      mOwnInBuffer(false), mVolumeCtrlIdx(-1), mLeftVolume(UINT_MAX), mRightVolume(UINT_MAX),\n      mNewLeftVolume(UINT_MAX), mNewRightVolume(UINT_MAX), mForceVolume(false)\n{\n    mStrategy = AudioSystem::getStrategyForStream(AUDIO_STREAM_MUSIC);\n if (thread == NULL) {\n return;\n }\n    mMaxTailBuffers = ((kProcessTailDurationMs * thread->sampleRate()) / 1000) /\n                                    thread->frameCount();\n}", "target": 0}
{"code": "server_request_direct_streamlocal(void)\n{\n\tChannel *c = NULL;\n\tchar *target, *originator;\n\tu_short originator_port;\n\ttarget = packet_get_string(NULL);\n\toriginator = packet_get_string(NULL);\n\toriginator_port = packet_get_int();\n\tpacket_check_eom();\n\tdebug(\"server_request_direct_streamlocal: originator %s port %d, target %s\",\n\t    originator, originator_port, target);\n\tif ((options.allow_streamlocal_forwarding & FORWARD_LOCAL) != 0 &&\n\t    !no_port_forwarding_flag && !options.disable_forwarding) {\n\t\tc = channel_connect_to_path(target,\n\t\t    \"direct-streamlocal@openssh.com\", \"direct-streamlocal\");\n\t} else {\n\t\tlogit(\"refused streamlocal port forward: \"\n\t\t    \"originator %s port %d, target %s\",\n\t\t    originator, originator_port, target);\n\t}\n\tfree(originator);\n\tfree(target);\n\treturn c;\n}", "target": 1}
{"code": "static bool rbuf_switch_to_malloc(conn *c) {\n    size_t size = c->rsize * 2;\n    char *tmp = malloc(size);\n    if (!tmp)\n        return false;\n    do_cache_free(c->thread->rbuf_cache, c->rbuf);\n    memcpy(tmp, c->rcurr, c->rbytes);\n    c->rcurr = c->rbuf = tmp;\n    c->rsize = size;\n    c->rbuf_malloced = true;\n    return true;\n}", "target": 0}
{"code": "static bool shouldOpenInNewWindow(Frame* targetFrame, const FrameLoadRequest& request, const NavigationAction& action)\n{\n    if (!targetFrame && !request.frameName().isEmpty())\n        return true;\n    if (!request.formState())\n        return false;\n    NavigationPolicy navigationPolicy = NavigationPolicyCurrentTab;\n    if (!action.specifiesNavigationPolicy(&navigationPolicy))\n        return false;\n    return navigationPolicy != NavigationPolicyCurrentTab;\n}", "target": 0}
{"code": "void CtcpParser::packedReply(CoreNetwork *net, const QString &bufname, const QList<QByteArray> &replies) {\n  QList<QByteArray> params;\n  int answerSize = 0;\n  for(int i = 0; i < replies.count(); i++) {\n    answerSize += replies.at(i).size();\n  }\n  QByteArray quotedReply(answerSize, 0);\n  int nextPos = 0;\n  QByteArray &reply = quotedReply;\n  for(int i = 0; i < replies.count(); i++) {\n    reply = replies.at(i);\n    quotedReply.replace(nextPos, reply.size(), reply);\n    nextPos += reply.size();\n  }\n  params << net->serverEncode(bufname) << quotedReply;\n  net->putCmd(\"NOTICE\", params);\n}", "target": 1}
{"code": "cmsBool  CMSEXPORT cmsAppendNamedColor(cmsNAMEDCOLORLIST* NamedColorList,\n                                       const char* Name,\n                                       cmsUInt16Number PCS[3], cmsUInt16Number Colorant[cmsMAXCHANNELS])\n{\n    cmsUInt32Number i;\n    if (NamedColorList == NULL) return FALSE;\n    if (NamedColorList ->nColors + 1 > NamedColorList ->Allocated) {\n        if (!GrowNamedColorList(NamedColorList)) return FALSE;\n    }\n    for (i=0; i < NamedColorList ->ColorantCount; i++)\n        NamedColorList ->List[NamedColorList ->nColors].DeviceColorant[i] = Colorant == NULL? 0 : Colorant[i];\n    for (i=0; i < 3; i++)\n        NamedColorList ->List[NamedColorList ->nColors].PCS[i] = PCS == NULL ? 0 : PCS[i];\n    if (Name != NULL) {\n        strncpy(NamedColorList ->List[NamedColorList ->nColors].Name, Name,\n                    sizeof(NamedColorList ->List[NamedColorList ->nColors].Name));\n        NamedColorList ->List[NamedColorList ->nColors].Name[cmsMAX_PATH-1] = 0;\n    }\n    else\n        NamedColorList ->List[NamedColorList ->nColors].Name[0] = 0;\n    NamedColorList ->nColors++;\n    return TRUE;\n}", "target": 1}
{"code": "static int llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t  int *uaddrlen, int peer)\n{\n\tstruct sockaddr_llc sllc;\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tint rc = 0;\n\tmemset(&sllc, 0, sizeof(sllc));\n\tlock_sock(sk);\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\t*uaddrlen = sizeof(sllc);\n\tmemset(uaddr, 0, *uaddrlen);\n\tif (peer) {\n\t\trc = -ENOTCONN;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\t\tif(llc->dev)\n\t\t\tsllc.sllc_arphrd = llc->dev->type;\n\t\tsllc.sllc_sap = llc->daddr.lsap;\n\t\tmemcpy(&sllc.sllc_mac, &llc->daddr.mac, IFHWADDRLEN);\n\t} else {\n\t\trc = -EINVAL;\n\t\tif (!llc->sap)\n\t\t\tgoto out;\n\t\tsllc.sllc_sap = llc->sap->laddr.lsap;\n\t\tif (llc->dev) {\n\t\t\tsllc.sllc_arphrd = llc->dev->type;\n\t\t\tmemcpy(&sllc.sllc_mac, llc->dev->dev_addr,\n\t\t\t       IFHWADDRLEN);\n\t\t}\n\t}\n\trc = 0;\n\tsllc.sllc_family = AF_LLC;\n\tmemcpy(uaddr, &sllc, sizeof(sllc));\nout:\n\trelease_sock(sk);\n\treturn rc;\n}", "target": 1}
{"code": "static inline struct rt6_info *ip6_dst_alloc(struct net *net,\n\t\t\t\t\t     struct net_device *dev,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct fib6_table *table)\n{\n\tstruct rt6_info *rt = dst_alloc(&net->ipv6.ip6_dst_ops, dev,\n\t\t\t\t\t0, DST_OBSOLETE_FORCE_CHK, flags);\n\tif (rt) {\n\t\tstruct dst_entry *dst = &rt->dst;\n\t\tmemset(dst + 1, 0, sizeof(*rt) - sizeof(*dst));\n\t\trt6_init_peer(rt, table ? &table->tb6_peers : net->ipv6.peers);\n\t\trt->rt6i_genid = rt_genid(net);\n\t\tINIT_LIST_HEAD(&rt->rt6i_siblings);\n\t\trt->rt6i_nsiblings = 0;\n\t}\n\treturn rt;\n}", "target": 0}
{"code": "PgUser *add_user(const char *name, const char *passwd)\n{\n\tPgUser *user = find_user(name);\n\tif (user == NULL) {\n\t\tuser = slab_alloc(user_cache);\n\t\tif (!user)\n\t\t\treturn NULL;\n\t\tlist_init(&user->head);\n\t\tlist_init(&user->pool_list);\n\t\tsafe_strcpy(user->name, name, sizeof(user->name));\n\t\tput_in_order(&user->head, &user_list, cmp_user);\n\t\taatree_insert(&user_tree, (uintptr_t)user->name, &user->tree_node);\n\t}\n\tsafe_strcpy(user->passwd, passwd, sizeof(user->passwd));\n\treturn user;\n}", "target": 0}
{"code": "spnego_gss_set_sec_context_option(\n\t\tOM_uint32 *minor_status,\n\t\tgss_ctx_id_t *context_handle,\n\t\tconst gss_OID desired_object,\n\t\tconst gss_buffer_t value)\n{\n\tOM_uint32 ret;\n\tret = gss_set_sec_context_option(minor_status,\n\t\t\t    context_handle,\n\t\t\t    desired_object,\n\t\t\t    value);\n\treturn (ret);\n}", "target": 1}
{"code": "static int compareNumbersForQSort(const void* a, const void* b)\n{\n    double da = static_cast<const JSValue*>(a)->uncheckedGetNumber();\n    double db = static_cast<const JSValue*>(b)->uncheckedGetNumber();\n    return (da > db) - (da < db);\n}", "target": 0}
{"code": "static void prepare_attr_stack(const char *path, int dirlen)\n{\n\tstruct attr_stack *elem, *info;\n\tint len;\n\tstruct strbuf pathbuf;\n\tstrbuf_init(&pathbuf, dirlen+2+strlen(GITATTRIBUTES_FILE));\n\tif (!attr_stack)\n\t\tbootstrap_attr_stack();\n\tinfo = attr_stack;\n\tattr_stack = info->prev;\n\twhile (attr_stack && attr_stack->origin) {\n\t\tint namelen = strlen(attr_stack->origin);\n\t\telem = attr_stack;\n\t\tif (namelen <= dirlen &&\n\t\t    !strncmp(elem->origin, path, namelen))\n\t\t\tbreak;\n\t\tdebug_pop(elem);\n\t\tattr_stack = elem->prev;\n\t\tfree_attr_elem(elem);\n\t}\n\tif (!is_bare_repository()) {\n\t\twhile (1) {\n\t\t\tchar *cp;\n\t\t\tlen = strlen(attr_stack->origin);\n\t\t\tif (dirlen <= len)\n\t\t\t\tbreak;\n\t\t\tstrbuf_reset(&pathbuf);\n\t\t\tstrbuf_add(&pathbuf, path, dirlen);\n\t\t\tstrbuf_addch(&pathbuf, '/');\n\t\t\tcp = strchr(pathbuf.buf + len + 1, '/');\n\t\t\tstrcpy(cp + 1, GITATTRIBUTES_FILE);\n\t\t\telem = read_attr(pathbuf.buf, 0);\n\t\t\t*cp = '\\0';\n\t\t\telem->origin = strdup(pathbuf.buf);\n\t\t\telem->prev = attr_stack;\n\t\t\tattr_stack = elem;\n\t\t\tdebug_push(elem);\n\t\t}\n\t}\n\tinfo->prev = attr_stack;\n\tattr_stack = info;\n}", "target": 0}
{"code": "krb5_encode_histkey(osa_princ_ent_rec *princ_ent)\n{\n    unsigned int i;\n    krb5_error_code err = 0;\n    struct berval **ret = NULL;\n    if (princ_ent->old_key_len <= 0)\n        return NULL;\n    ret = k5calloc(princ_ent->old_key_len + 1, sizeof(struct berval *), &err);\n    if (ret == NULL)\n        goto cleanup;\n    for (i = 0; i < princ_ent->old_key_len; i++) {\n        if (princ_ent->old_keys[i].n_key_data <= 0) {\n            err = EINVAL;\n            goto cleanup;\n        }\n        err = encode_keys(princ_ent->old_keys[i].key_data,\n                          princ_ent->old_keys[i].n_key_data,\n                          princ_ent->admin_history_kvno, &ret[i]);\n        if (err)\n            goto cleanup;\n    }\n    ret[princ_ent->old_key_len] = NULL;\ncleanup:\n    if (err != 0) {\n        free_berdata(ret);\n        ret = NULL;\n    }\n    return ret;\n}", "target": 0}
{"code": "void CUser::SetClientEncoding(const CString& s) {\n    m_sClientEncoding = s;\n    for (CClient* pClient : GetAllClients()) {\n        pClient->SetEncoding(s);\n    }\n}", "target": 1}
{"code": "  bool CanUploadFile(const FilePath& file) {\n    return uploadable_files_.find(file) != uploadable_files_.end();\n  }", "target": 0}
{"code": "void rds_inc_init(struct rds_incoming *inc, struct rds_connection *conn,\n\t\t  __be32 saddr)\n{\n\tatomic_set(&inc->i_refcount, 1);\n\tINIT_LIST_HEAD(&inc->i_item);\n\tinc->i_conn = conn;\n\tinc->i_saddr = saddr;\n\tinc->i_rdma_cookie = 0;\n\tinc->i_rx_tstamp.tv_sec = 0;\n\tinc->i_rx_tstamp.tv_usec = 0;\n}", "target": 0}
{"code": "static bool r_bin_mdmp_init_directory(struct r_bin_mdmp_obj *obj) {\n\tint i;\n\tstruct minidump_directory entry;\n\tsdb_num_set (obj->kv, \"mdmp_directory.offset\",\n\t\t\tobj->hdr->stream_directory_rva, 0);\n\tsdb_set (obj->kv, \"mdmp_directory.format\", \"[4]E? \"\n\t\t\t\"(mdmp_stream_type)StreamType \"\n\t\t\t\"(mdmp_location_descriptor)Location\", 0);\n\tut64 rvadir = obj->hdr->stream_directory_rva;\n\tfor (i = 0; i < (int)obj->hdr->number_of_streams; i++) {\n\t\tut32 delta = i * sizeof (struct minidump_directory);\n\t\tint r = r_buf_read_at (obj->b, rvadir + delta, (ut8*) &entry, sizeof (struct minidump_directory));\n\t\tif (r) {\n\t\t\tr_bin_mdmp_init_directory_entry (obj, &entry);\n\t\t}\n\t}\n\treturn true;\n}", "target": 0}
{"code": "static int er_supported(ERContext *s)\n{\n    if(s->avctx->hwaccel && s->avctx->hwaccel->decode_slice           ||\n       !s->cur_pic.f                                                  ||\n       s->cur_pic.field_picture                                       ||\n       s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO\n    )\n        return 0;\n    return 1;\n}", "target": 1}
{"code": "charactersDefined (FileInfo * nested)\n{\n  int noErrors = 1;\n  int k;\n  if ((newRule->opcode >= CTO_Space && newRule->opcode <= CTO_LitDigit)\n      || newRule->opcode == CTO_SwapDd\n      ||\n      newRule->opcode == CTO_Replace || newRule->opcode == CTO_MultInd\n      || newRule->opcode == CTO_Repeated ||\n      ((newRule->opcode >= CTO_Context && newRule->opcode <=\n\tCTO_Pass4) && newRule->opcode != CTO_Correct))\n    return 1;\n  for (k = 0; k < newRule->charslen; k++)\n    if (!compile_findCharOrDots (newRule->charsdots[k], 0))\n      {\n\tcompileError (nested, \"Character %s is not defined\", showString\n\t\t      (&newRule->charsdots[k], 1));\n\tnoErrors = 0;\n      }\n  if (!(newRule->opcode == CTO_Correct || newRule->opcode ==\n\tCTO_NoBreak || newRule->opcode == CTO_SwapCc || newRule->opcode ==\n\tCTO_SwapCd))\n    {\n      for (k = newRule->charslen; k < newRule->charslen + newRule->dotslen;\n\t   k++)\n\tif (!compile_findCharOrDots (newRule->charsdots[k], 1))\n\t  {\n\t    compileError (nested, \"Dot pattern %s is not defined.\",\n\t\t\t  unknownDots (newRule->charsdots[k]));\n\t    noErrors = 0;\n\t  }\n    }\n  return noErrors;\n}", "target": 0}
{"code": "unsigned get_next_char(ASS_Renderer *render_priv, char **str)\n{\n    char *p = *str;\n    unsigned chr;\n    if (*p == '\\t') {\n        ++p;\n        *str = p;\n        return ' ';\n    }\n    if (*p == '\\\\') {\n        if ((p[1] == 'N') || ((p[1] == 'n') &&\n                              (render_priv->state.wrap_style == 2))) {\n            p += 2;\n            *str = p;\n            return '\\n';\n        } else if (p[1] == 'n') {\n            p += 2;\n            *str = p;\n            return ' ';\n        } else if (p[1] == 'h') {\n            p += 2;\n            *str = p;\n            return NBSP;\n        } else if (p[1] == '{') {\n            p += 2;\n            *str = p;\n            return '{';\n        } else if (p[1] == '}') {\n            p += 2;\n            *str = p;\n            return '}';\n        }\n    }\n    chr = ass_utf8_get_char((char **) &p);\n    *str = p;\n    return chr;\n}", "target": 0}
{"code": "static int nut_read_header(AVFormatContext *s)\n{\n    NUTContext *nut = s->priv_data;\n    AVIOContext *bc = s->pb;\n    int64_t pos;\n    int initialized_stream_count;\n    nut->avf = s;\n    pos = 0;\n    do {\n        pos = find_startcode(bc, MAIN_STARTCODE, pos) + 1;\n        if (pos < 0 + 1) {\n            av_log(s, AV_LOG_ERROR, \"No main startcode found.\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    } while (decode_main_header(nut) < 0);\n    pos = 0;\n    for (initialized_stream_count = 0; initialized_stream_count < s->nb_streams;) {\n        pos = find_startcode(bc, STREAM_STARTCODE, pos) + 1;\n        if (pos < 0 + 1) {\n            av_log(s, AV_LOG_ERROR, \"Not all stream headers found.\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        if (decode_stream_header(nut) >= 0)\n            initialized_stream_count++;\n    }\n    pos = 0;\n    for (;;) {\n        uint64_t startcode = find_any_startcode(bc, pos);\n        pos = avio_tell(bc);\n        if (startcode == 0) {\n            av_log(s, AV_LOG_ERROR, \"EOF before video frames\\n\");\n            return AVERROR_INVALIDDATA;\n        } else if (startcode == SYNCPOINT_STARTCODE) {\n            nut->next_startcode = startcode;\n            break;\n        } else if (startcode != INFO_STARTCODE) {\n            continue;\n        }\n        decode_info_header(nut);\n    }\n    ffformatcontext(s)->data_offset = pos - 8;\n    if (bc->seekable & AVIO_SEEKABLE_NORMAL) {\n        int64_t orig_pos = avio_tell(bc);\n        find_and_decode_index(nut);\n        avio_seek(bc, orig_pos, SEEK_SET);\n    }\n    av_assert0(nut->next_startcode == SYNCPOINT_STARTCODE);\n    ff_metadata_conv_ctx(s, NULL, ff_nut_metadata_conv);\n    return 0;\n}", "target": 1}
{"code": "int socket_accept(int fd, uint16_t port)\n{\n#ifdef WIN32\n\tint addr_len;\n#else\n\tsocklen_t addr_len;\n#endif\n\tint result;\n\tstruct sockaddr_in addr;\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\taddr.sin_port = htons(port);\n\taddr_len = sizeof(addr);\n\tresult = accept(fd, (struct sockaddr*)&addr, &addr_len);\n\treturn result;\n}", "target": 1}
{"code": "static char sctp_tietags_compare(struct sctp_association *new_asoc,\n\t\t\t\t const struct sctp_association *asoc)\n{\n\tif ((asoc->c.my_vtag != new_asoc->c.my_vtag) &&\n\t    (asoc->c.peer_vtag != new_asoc->c.peer_vtag) &&\n\t    (asoc->c.my_vtag == new_asoc->c.my_ttag) &&\n\t    (asoc->c.peer_vtag == new_asoc->c.peer_ttag))\n\t\treturn 'A';\n\tif ((asoc->c.my_vtag == new_asoc->c.my_vtag) &&\n\t    ((asoc->c.peer_vtag != new_asoc->c.peer_vtag) ||\n\t     (0 == asoc->c.peer_vtag))) {\n\t\treturn 'B';\n\t}\n\tif ((asoc->c.my_vtag == new_asoc->c.my_vtag) &&\n\t    (asoc->c.peer_vtag == new_asoc->c.peer_vtag))\n\t\treturn 'D';\n\tif ((asoc->c.my_vtag != new_asoc->c.my_vtag) &&\n\t    (asoc->c.peer_vtag == new_asoc->c.peer_vtag) &&\n\t    (0 == new_asoc->c.my_ttag) &&\n\t    (0 == new_asoc->c.peer_ttag))\n\t\treturn 'C';\n\treturn 'E';\n}", "target": 0}
{"code": "*/\nPHP_METHOD(DateTimeImmutable, setDate)\n{\n\tzval *object, *new_object;\n\tlong  y, m, d;\n\tif (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), \"Olll\", &object, date_ce_immutable, &y, &m, &d) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tnew_object = date_clone_immutable(object TSRMLS_CC);\n\tphp_date_date_set(new_object, y, m, d, return_value TSRMLS_CC);\n\tRETURN_ZVAL(new_object, 0, 1);", "target": 0}
{"code": "int snd_card_disconnect(struct snd_card *card)\n{\n\tstruct snd_monitor_file *mfile;\n\tif (!card)\n\t\treturn -EINVAL;\n\tspin_lock(&card->files_lock);\n\tif (card->shutdown) {\n\t\tspin_unlock(&card->files_lock);\n\t\treturn 0;\n\t}\n\tcard->shutdown = 1;\n\tspin_unlock(&card->files_lock);\n\tmutex_lock(&snd_card_mutex);\n\tsnd_cards[card->number] = NULL;\n\tclear_bit(card->number, snd_cards_lock);\n\tmutex_unlock(&snd_card_mutex);\n\tspin_lock(&card->files_lock);\n\tlist_for_each_entry(mfile, &card->files_list, list) {\n\t\tmfile->disconnected_f_op = mfile->file->f_op;\n\t\tspin_lock(&shutdown_lock);\n\t\tlist_add(&mfile->shutdown_list, &shutdown_files);\n\t\tspin_unlock(&shutdown_lock);\n\t\tmfile->file->f_op = &snd_shutdown_f_ops;\n\t\tfops_get(mfile->file->f_op);\n\t}\n\tspin_unlock(&card->files_lock);\t\n#if IS_ENABLED(CONFIG_SND_MIXER_OSS)\n\tif (snd_mixer_oss_notify_callback)\n\t\tsnd_mixer_oss_notify_callback(card, SND_MIXER_OSS_NOTIFY_DISCONNECT);\n#endif\n\tsnd_device_disconnect_all(card);\n\tsnd_info_card_disconnect(card);\n\tif (card->registered) {\n\t\tdevice_del(&card->card_dev);\n\t\tcard->registered = false;\n\t}\n#ifdef CONFIG_PM\n\twake_up(&card->power_sleep);\n#endif\n\treturn 0;\t\n}", "target": 1}
{"code": "static void cpia2_usb_disconnect(struct usb_interface *intf)\n{\n\tstruct camera_data *cam = usb_get_intfdata(intf);\n\tusb_set_intfdata(intf, NULL);\n\tDBG(\"Stopping stream\\n\");\n\tcpia2_usb_stream_stop(cam);\n\tmutex_lock(&cam->v4l2_lock);\n\tDBG(\"Unregistering camera\\n\");\n\tcpia2_unregister_camera(cam);\n\tv4l2_device_disconnect(&cam->v4l2_dev);\n\tmutex_unlock(&cam->v4l2_lock);\n\tv4l2_device_put(&cam->v4l2_dev);\n\tif(cam->buffers) {\n\t\tDBG(\"Wakeup waiting processes\\n\");\n\t\tcam->curbuff->status = FRAME_READY;\n\t\tcam->curbuff->length = 0;\n\t\twake_up_interruptible(&cam->wq_stream);\n\t}\n\tLOG(\"CPiA2 camera disconnected.\\n\");\n}", "target": 1}
{"code": "static void svm_set_cr3(struct kvm_vcpu *vcpu, unsigned long root)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tsvm->vmcb->save.cr3 = root;\n\tmark_dirty(svm->vmcb, VMCB_CR);\n\tsvm_flush_tlb(vcpu);\n}", "target": 0}
{"code": "void SocketLineReader::dataReceived()\n{\n    while (m_socket->canReadLine()) {\n        const QByteArray line = m_socket->readLine();\n        if (line.length() > 1) { \n            m_packets.enqueue(line);\n        }\n    }\n    if (m_socket->bytesAvailable() > 0) {\n        QMetaObject::invokeMethod(this, \"dataReceived\", Qt::QueuedConnection);\n        return;\n    }\n    if (!m_packets.isEmpty()) {\n        Q_EMIT readyRead();\n    }\n}", "target": 1}
{"code": "mark_context_stack(mrb_state *mrb, struct mrb_context *c)\n{\n  size_t i;\n  size_t e;\n  if (c->stack == NULL) return;\n  e = c->stack - c->stbase;\n  if (c->ci) e += c->ci->nregs;\n  if (c->stbase + e > c->stend) e = c->stend - c->stbase;\n  for (i=0; i<e; i++) {\n    mrb_value v = c->stbase[i];\n    if (!mrb_immediate_p(v)) {\n      if (mrb_basic_ptr(v)->tt == MRB_TT_FREE) {\n        c->stbase[i] = mrb_nil_value();\n      }\n      else {\n        mrb_gc_mark(mrb, mrb_basic_ptr(v));\n      }\n    }\n  }\n}", "target": 1}
{"code": "SWFInput_readSBits(SWFInput input, int number)\n{\n\tint num = SWFInput_readBits(input, number);\n\tif ( num & (1<<(number-1)) )\n\t\treturn num - (1<<number);\n\telse\n\t\treturn num;\n}", "target": 1}
{"code": "UINT rdpgfx_read_rect16(wStream* s, RECTANGLE_16* rect16)\n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t{\n\t\tWLog_ERR(TAG, \"not enough data!\");\n\t\treturn ERROR_INVALID_DATA;\n\t}\n\tStream_Read_UINT16(s, rect16->left);   \n\tStream_Read_UINT16(s, rect16->top);    \n\tStream_Read_UINT16(s, rect16->right);  \n\tStream_Read_UINT16(s, rect16->bottom); \n\treturn CHANNEL_RC_OK;\n}", "target": 1}
{"code": "static inline int pmd_present(pmd_t pmd)\n{\n\treturn pmd_flags(pmd) & _PAGE_PRESENT;\n}", "target": 1}
{"code": "static int __feat_register_sp(struct list_head *fn, u8 feat, u8 is_local,\n\t\t\t      u8 mandatory, u8 const *sp_val, u8 sp_len)\n{\n\tdccp_feat_val fval;\n\tif (dccp_feat_type(feat) != FEAT_SP ||\n\t    !dccp_feat_sp_list_ok(feat, sp_val, sp_len))\n\t\treturn -EINVAL;\n\tif (feat == DCCPF_CCID && !ccid_support_check(sp_val, sp_len))\n\t\treturn -EOPNOTSUPP;\n\tif (dccp_feat_clone_sp_val(&fval, sp_val, sp_len))\n\t\treturn -ENOMEM;\n\treturn dccp_feat_push_change(fn, feat, is_local, mandatory, &fval);\n}", "target": 1}
{"code": "RGB_to_HWB (RGBType RGB, HWBType * HWB)\n{\n\tfloat R = RGB.R, G = RGB.G, B = RGB.B, w, v, b, f;\n\tint i;\n\tw = MIN3 (R, G, B);\n\tv = MAX3 (R, G, B);\n\tb = 1 - v;\n\tif (v == w)\n\t\tRETURN_HWB (HWB_UNDEFINED, w, b);\n\tf = (R == w) ? G - B : ((G == w) ? B - R : R - G);\n\ti = (R == w) ? 3 : ((G == w) ? 5 : 1);\n\tRETURN_HWB (i - f / (v - w), w, b);\n}", "target": 0}
{"code": "static void fuse_lib_getxattr(fuse_req_t req, fuse_ino_t ino, const char *name,\n                              size_t size)\n{\n    struct fuse *f = req_fuse_prepare(req);\n    int res;\n    if (size) {\n        char *value = (char *) malloc(size);\n        if (value == NULL) {\n            reply_err(req, -ENOMEM);\n            return;\n        }\n        res = common_getxattr(f, req, ino, name, value, size);\n        if (res > 0)\n            fuse_reply_buf(req, value, res);\n        else\n            reply_err(req, res);\n        free(value);\n    } else {\n        res = common_getxattr(f, req, ino, name, NULL, 0);\n        if (res >= 0)\n            fuse_reply_xattr(req, res);\n        else\n            reply_err(req, res);\n    }\n}", "target": 0}
{"code": "static int seed_from_urandom(uint32_t *seed) {\n    char data[sizeof(uint32_t)];\n    int ok;\n#if defined(HAVE_OPEN) && defined(HAVE_CLOSE) && defined(HAVE_READ)\n    int urandom;\n    urandom = open(\"/dev/urandom\", O_RDONLY);\n    if (urandom == -1)\n        return 1;\n    ok = read(urandom, data, sizeof(uint32_t)) == sizeof(uint32_t);\n    close(urandom);\n#else\n    FILE *urandom;\n    urandom = fopen(\"/dev/urandom\", \"rb\");\n    if (!urandom)\n        return 1;\n    ok = fread(data, 1, sizeof(uint32_t), urandom) == sizeof(uint32_t);\n    fclose(urandom);\n#endif\n    if (!ok)\n        return 1;\n    *seed = buf_to_uint32(data);\n    return 0;\n}", "target": 0}
{"code": "static int input_default_setkeycode(struct input_dev *dev,\n\t\t\t\t    const struct input_keymap_entry *ke,\n\t\t\t\t    unsigned int *old_keycode)\n{\n\tunsigned int index;\n\tint error;\n\tint i;\n\tif (!dev->keycodesize)\n\t\treturn -EINVAL;\n\tif (ke->flags & INPUT_KEYMAP_BY_INDEX) {\n\t\tindex = ke->index;\n\t} else {\n\t\terror = input_scancode_to_scalar(ke, &index);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (index >= dev->keycodemax)\n\t\treturn -EINVAL;\n\tif (dev->keycodesize < sizeof(ke->keycode) &&\n\t\t\t(ke->keycode >> (dev->keycodesize * 8)))\n\t\treturn -EINVAL;\n\tswitch (dev->keycodesize) {\n\t\tcase 1: {\n\t\t\tu8 *k = (u8 *)dev->keycode;\n\t\t\t*old_keycode = k[index];\n\t\t\tk[index] = ke->keycode;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2: {\n\t\t\tu16 *k = (u16 *)dev->keycode;\n\t\t\t*old_keycode = k[index];\n\t\t\tk[index] = ke->keycode;\n\t\t\tbreak;\n\t\t}\n\t\tdefault: {\n\t\t\tu32 *k = (u32 *)dev->keycode;\n\t\t\t*old_keycode = k[index];\n\t\t\tk[index] = ke->keycode;\n\t\t\tbreak;\n\t\t}\n\t}\n\t__clear_bit(*old_keycode, dev->keybit);\n\t__set_bit(ke->keycode, dev->keybit);\n\tfor (i = 0; i < dev->keycodemax; i++) {\n\t\tif (input_fetch_keycode(dev, i) == *old_keycode) {\n\t\t\t__set_bit(*old_keycode, dev->keybit);\n\t\t\tbreak; \n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static inline void phar_set_inode(phar_entry_info *entry TSRMLS_DC) \n{\n\tchar tmp[MAXPATHLEN];\n\tint tmp_len;\n\ttmp_len = entry->filename_len + entry->phar->fname_len;\n\tmemcpy(tmp, entry->phar->fname, entry->phar->fname_len);\n\tmemcpy(tmp + entry->phar->fname_len, entry->filename, entry->filename_len);\n\tentry->inode = (unsigned short)zend_get_hash_value(tmp, tmp_len);\n}", "target": 1}
{"code": "static PHP_GINIT_FUNCTION(date)\n{\n\tdate_globals->default_timezone = NULL;\n\tdate_globals->timezone = NULL;\n\tdate_globals->tzcache = NULL;\n\tdate_globals->timezone_valid = 0;", "target": 0}
{"code": "static int store_icy(URLContext *h, int size)\n{\n    HTTPContext *s = h->priv_data;\n    int remaining = s->icy_metaint - s->icy_data_read;\n    if (remaining < 0)\n        return AVERROR_INVALIDDATA;\n    if (!remaining) {\n        uint8_t ch;\n        int len = http_read_stream_all(h, &ch, 1);\n        if (len < 0)\n            return len;\n        if (ch > 0) {\n            char data[255 * 16 + 1];\n            int ret;\n            len = ch * 16;\n            ret = http_read_stream_all(h, data, len);\n            if (ret < 0)\n                return ret;\n            data[len + 1] = 0;\n            if ((ret = av_opt_set(s, \"icy_metadata_packet\", data, 0)) < 0)\n                return ret;\n            update_metadata(s, data);\n        }\n        s->icy_data_read = 0;\n        remaining        = s->icy_metaint;\n    }\n    return FFMIN(size, remaining);\n}", "target": 1}
{"code": "onig_node_str_clear(Node* node)\n{\n  if (STR_(node)->capa != 0 &&\n      IS_NOT_NULL(STR_(node)->s) && STR_(node)->s != STR_(node)->buf) {\n    xfree(STR_(node)->s);\n  }\n  STR_(node)->capa = 0;\n  STR_(node)->flag = 0;\n  STR_(node)->s    = STR_(node)->buf;\n  STR_(node)->end  = STR_(node)->buf;\n}", "target": 0}
{"code": "static int set_next_request(void)\n{\n\tcurrent_req = list_first_entry_or_null(&floppy_reqs, struct request,\n\t\t\t\t\t       queuelist);\n\tif (current_req) {\n\t\tcurrent_req->error_count = 0;\n\t\tlist_del_init(&current_req->queuelist);\n\t}\n\treturn current_req != NULL;\n}", "target": 0}
{"code": "static int ssl_flight_append( mbedtls_ssl_context *ssl )\n{\n    mbedtls_ssl_flight_item *msg;\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> ssl_flight_append\" ) );\n    MBEDTLS_SSL_DEBUG_BUF( 4, \"message appended to flight\",\n                           ssl->out_msg, ssl->out_msglen );\n    if( ( msg = mbedtls_calloc( 1, sizeof(  mbedtls_ssl_flight_item ) ) ) == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"alloc %\" MBEDTLS_PRINTF_SIZET \" bytes failed\",\n                            sizeof( mbedtls_ssl_flight_item ) ) );\n        return( MBEDTLS_ERR_SSL_ALLOC_FAILED );\n    }\n    if( ( msg->p = mbedtls_calloc( 1, ssl->out_msglen ) ) == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"alloc %\" MBEDTLS_PRINTF_SIZET \" bytes failed\",\n                                    ssl->out_msglen ) );\n        mbedtls_free( msg );\n        return( MBEDTLS_ERR_SSL_ALLOC_FAILED );\n    }\n    memcpy( msg->p, ssl->out_msg, ssl->out_msglen );\n    msg->len = ssl->out_msglen;\n    msg->type = ssl->out_msgtype;\n    msg->next = NULL;\n    if( ssl->handshake->flight == NULL )\n        ssl->handshake->flight = msg;\n    else\n    {\n        mbedtls_ssl_flight_item *cur = ssl->handshake->flight;\n        while( cur->next != NULL )\n            cur = cur->next;\n        cur->next = msg;\n    }\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= ssl_flight_append\" ) );\n    return( 0 );\n}", "target": 0}
{"code": "static long mem_seek(jas_stream_obj_t *obj, long offset, int origin)\n{\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tlong newpos;\n\tJAS_DBGLOG(100, (\"mem_seek(%p, %ld, %d)\\n\", obj, offset, origin));\n\tswitch (origin) {\n\tcase SEEK_SET:\n\t\tnewpos = offset;\n\t\tbreak;\n\tcase SEEK_END:\n\t\tnewpos = m->len_ - offset;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tnewpos = m->pos_ + offset;\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t\tbreak;\n\t}\n\tif (newpos < 0) {\n\t\treturn -1;\n\t}\n\tm->pos_ = newpos;\n\treturn m->pos_;\n}", "target": 1}
{"code": "void Context::onDownstreamConnectionClose(PeerType peer_type) {\n  if (wasm_->onDownstreamConnectionClose_) {\n    wasm_->onDownstreamConnectionClose_(this, id_, static_cast<uint32_t>(peer_type));\n  }\n}", "target": 1}
{"code": "struct file *fget(unsigned int fd)\n{\n\treturn __fget(fd, FMODE_PATH, 1);\n}", "target": 0}
{"code": "static int16_t decodeSample(ms_adpcm_state &state,\n\tuint8_t code, const int16_t *coefficient)\n{\n\tint linearSample = (state.sample1 * coefficient[0] +\n\t\tstate.sample2 * coefficient[1]) >> 8;\n\tlinearSample += ((code & 0x08) ? (code - 0x10) : code) * state.delta;\n\tlinearSample = clamp(linearSample, MIN_INT16, MAX_INT16);\n\tint delta = (state.delta * adaptationTable[code]) >> 8;\n\tif (delta < 16)\n\t\tdelta = 16;\n\tstate.delta = delta;\n\tstate.sample2 = state.sample1;\n\tstate.sample1 = linearSample;\n\treturn static_cast<int16_t>(linearSample);\n}", "target": 1}
{"code": "static bool is_maintenance_mode_cmd(struct kernel_ipmi_msg *msg)\n{\n\treturn (((msg->netfn == IPMI_NETFN_APP_REQUEST)\n\t\t && ((msg->cmd == IPMI_COLD_RESET_CMD)\n\t\t     || (msg->cmd == IPMI_WARM_RESET_CMD)))\n\t\t|| (msg->netfn == IPMI_NETFN_FIRMWARE_REQUEST));\n}", "target": 0}
{"code": "static unsigned int count_acl_entries(connection_struct *conn, SMB_ACL_T posix_acl)\n{\n\tunsigned int ace_count = 0;\n\tint entry_id = SMB_ACL_FIRST_ENTRY;\n\tSMB_ACL_ENTRY_T entry;\n\twhile ( posix_acl && (sys_acl_get_entry(posix_acl, entry_id, &entry) == 1)) {\n\t\tif (entry_id == SMB_ACL_FIRST_ENTRY) {\n\t\t\tentry_id = SMB_ACL_NEXT_ENTRY;\n\t\t}\n\t\tace_count++;\n\t}\n\treturn ace_count;\n}", "target": 0}
{"code": "void RenderFrameHostImpl::ExecuteJavaScript(\n     const base::string16& javascript,\n     const JavaScriptResultCallback& callback) {\n  static int next_id = 1;\n  int key = next_id++;\n  Send(new FrameMsg_JavaScriptExecuteRequest(routing_id_,\n                                             javascript,\n                                             key, true));\n  javascript_callbacks_.insert(std::make_pair(key, callback));\n}", "target": 0}
{"code": "void Clipboard::WriteText(const char* text_data, size_t text_len) {\n  char* data = new char[text_len];\n  memcpy(data, text_data, text_len);\n  InsertMapping(kMimeTypeText, data, text_len);\n  InsertMapping(\"TEXT\", data, text_len);\n  InsertMapping(\"STRING\", data, text_len);\n  InsertMapping(\"UTF8_STRING\", data, text_len);\n  InsertMapping(\"COMPOUND_TEXT\", data, text_len);\n}", "target": 0}
{"code": "pci_lintr_deassert(struct pci_vdev *dev)\n{\n\tassert(dev->lintr.pin > 0);\n\tpthread_mutex_lock(&dev->lintr.lock);\n\tif (dev->lintr.state == ASSERTED) {\n\t\tdev->lintr.state = IDLE;\n\t\tpci_irq_deassert(dev);\n\t} else if (dev->lintr.state == PENDING)\n\t\tdev->lintr.state = IDLE;\n\tpthread_mutex_unlock(&dev->lintr.lock);\n}", "target": 1}
{"code": "int bnx2x_set_int_mode(struct bnx2x *bp)\n{\n\tint rc = 0;\n\tif (IS_VF(bp) && int_mode != BNX2X_INT_MODE_MSIX) {\n\t\tBNX2X_ERR(\"VF not loaded since interrupt mode not msix\\n\");\n\t\treturn -EINVAL;\n\t}\n\tswitch (int_mode) {\n\tcase BNX2X_INT_MODE_MSIX:\n\t\trc = bnx2x_enable_msix(bp);\n\t\tif (!rc)\n\t\t\treturn 0;\n\t\tif (rc && IS_VF(bp))\n\t\t\treturn rc;\n\t\tBNX2X_DEV_INFO(\"Failed to enable multiple MSI-X (%d), set number of queues to %d\\n\",\n\t\t\t       bp->num_queues,\n\t\t\t       1 + bp->num_cnic_queues);\n\tcase BNX2X_INT_MODE_MSI:\n\t\tbnx2x_enable_msi(bp);\n\tcase BNX2X_INT_MODE_INTX:\n\t\tbp->num_ethernet_queues = 1;\n\t\tbp->num_queues = bp->num_ethernet_queues + bp->num_cnic_queues;\n\t\tBNX2X_DEV_INFO(\"set number of queues to 1\\n\");\n\t\tbreak;\n\tdefault:\n\t\tBNX2X_DEV_INFO(\"unknown value in int_mode module parameter\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "juniper_mlppp_print(netdissect_options *ndo,\n                    const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n        l2info.pictype = DLT_JUNIPER_MLPPP;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n        if (ndo->ndo_eflag &&\n            EXTRACT_16BITS(&l2info.cookie) != PPP_OSI &&\n            EXTRACT_16BITS(&l2info.cookie) !=  (PPP_ADDRESS << 8 | PPP_CONTROL))\n            ND_PRINT((ndo, \"Bundle-ID %u: \", l2info.bundle));\n        p+=l2info.header_len;\n        switch(l2info.proto) {\n        case JUNIPER_LSQ_L3_PROTO_IPV4:\n            if (l2info.cookie[4] == (JUNIPER_LSQ_COOKIE_RE|JUNIPER_LSQ_COOKIE_DIR))\n                ppp_print(ndo, p, l2info.length);\n            else\n                ip_print(ndo, p, l2info.length);\n            return l2info.header_len;\n        case JUNIPER_LSQ_L3_PROTO_IPV6:\n            ip6_print(ndo, p,l2info.length);\n            return l2info.header_len;\n        case JUNIPER_LSQ_L3_PROTO_MPLS:\n            mpls_print(ndo, p, l2info.length);\n            return l2info.header_len;\n        case JUNIPER_LSQ_L3_PROTO_ISO:\n            isoclns_print(ndo, p, l2info.length, l2info.caplen);\n            return l2info.header_len;\n        default:\n            break;\n        }\n        switch (EXTRACT_16BITS(&l2info.cookie)) {\n        case PPP_OSI:\n            ppp_print(ndo, p - 2, l2info.length + 2);\n            break;\n        case (PPP_ADDRESS << 8 | PPP_CONTROL): \n        default:\n            ppp_print(ndo, p, l2info.length);\n            break;\n        }\n        return l2info.header_len;\n}", "target": 1}
{"code": "    bool read(ReadonlyBytes buffer)\n    {\n        auto fields_size = sizeof(EndOfCentralDirectory) - sizeof(u8*);\n        if (buffer.size() < fields_size)\n            return false;\n        if (memcmp(buffer.data(), end_of_central_directory_signature, sizeof(end_of_central_directory_signature)) != 0)\n            return false;\n        memcpy(reinterpret_cast<void*>(&disk_number), buffer.data() + sizeof(end_of_central_directory_signature), fields_size);\n        comment = buffer.data() + sizeof(end_of_central_directory_signature) + fields_size;\n        return true;\n    }", "target": 1}
{"code": "xfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error = 0;\n\tif (!acl)\n\t\tgoto set_acl;\n\terror = -E2BIG;\n\tif (acl->a_count > XFS_ACL_MAX_ENTRIES(XFS_M(inode->i_sb)))\n\t\treturn error;\n\tif (type == ACL_TYPE_ACCESS) {\n\t\tumode_t mode = inode->i_mode;\n\t\terror = posix_acl_equiv_mode(acl, &mode);\n\t\tif (error <= 0) {\n\t\t\tacl = NULL;\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t}\n\t\terror = xfs_set_mode(inode, mode);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n set_acl:\n\treturn __xfs_set_acl(inode, type, acl);\n}", "target": 1}
{"code": "static void mysql_prune_stmt_list(MYSQL *mysql)\n{\n  LIST *element= mysql->stmts;\n  LIST *pruned_list= 0;\n  for (; element; element= element->next)\n  {\n    MYSQL_STMT *stmt= (MYSQL_STMT *) element->data;\n    if (stmt->state != MYSQL_STMT_INIT_DONE)\n    {\n      stmt->mysql= 0;\n      stmt->last_errno= CR_SERVER_LOST;\n      strmov(stmt->last_error, ER(CR_SERVER_LOST));\n      strmov(stmt->sqlstate, unknown_sqlstate);\n    }\n    else\n    {\n      pruned_list= list_add(pruned_list, element);\n    }\n  }\n  mysql->stmts= pruned_list;\n}", "target": 1}
{"code": "shiftAnchorPosition(AnchorList *al, HmarkerList *hl, int line, int pos,\n\t\t    int shift)\n{\n    Anchor *a;\n    size_t b, e, s = 0;\n    int cmp;\n    if (al == NULL || al->nanchor == 0)\n\treturn;\n    s = al->nanchor / 2;\n    for (b = 0, e = al->nanchor - 1; b <= e; s = (b + e + 1) / 2) {\n\ta = &al->anchors[s];\n\tcmp = onAnchor(a, line, pos);\n\tif (cmp == 0)\n\t    break;\n\telse if (cmp > 0)\n\t    b = s + 1;\n\telse if (s == 0)\n\t    break;\n\telse\n\t    e = s - 1;\n    }\n    for (; s < al->nanchor; s++) {\n\ta = &al->anchors[s];\n\tif (a->start.line > line)\n\t    break;\n\tif (a->start.pos > pos) {\n\t    a->start.pos += shift;\n\t    if (hl->marks[a->hseq].line == line)\n\t\thl->marks[a->hseq].pos = a->start.pos;\n\t}\n\tif (a->end.pos >= pos)\n\t    a->end.pos += shift;\n    }\n}", "target": 1}
{"code": "gen_k( gcry_mpi_t p, int small_k )\n{\n  gcry_mpi_t k = mpi_alloc_secure( 0 );\n  gcry_mpi_t temp = mpi_alloc( mpi_get_nlimbs(p) );\n  gcry_mpi_t p_1 = mpi_copy(p);\n  unsigned int orig_nbits = mpi_get_nbits(p);\n  unsigned int nbits, nbytes;\n  char *rndbuf = NULL;\n  if (small_k)\n    {\n      nbits = wiener_map( orig_nbits ) * 3 / 2;\n      if( nbits >= orig_nbits )\n        BUG();\n    }\n  else\n    nbits = orig_nbits;\n  nbytes = (nbits+7)/8;\n  if( DBG_CIPHER )\n    log_debug(\"choosing a random k\\n\");\n  mpi_sub_ui( p_1, p, 1);\n  for(;;)\n    {\n      if( !rndbuf || nbits < 32 )\n        {\n          xfree(rndbuf);\n          rndbuf = _gcry_random_bytes_secure( nbytes, GCRY_STRONG_RANDOM );\n        }\n      else\n        {\n          char *pp = _gcry_random_bytes_secure( 4, GCRY_STRONG_RANDOM );\n          memcpy( rndbuf, pp, 4 );\n          xfree(pp);\n\t}\n      _gcry_mpi_set_buffer( k, rndbuf, nbytes, 0 );\n      for(;;)\n        {\n          if( !(mpi_cmp( k, p_1 ) < 0) )  \n            {\n              if( DBG_CIPHER )\n                progress('+');\n              break; \n            }\n          if( !(mpi_cmp_ui( k, 0 ) > 0) )  \n            {\n              if( DBG_CIPHER )\n                progress('-');\n              break; \n            }\n          if (mpi_gcd( temp, k, p_1 ))\n            goto found;  \n          mpi_add_ui( k, k, 1 );\n          if( DBG_CIPHER )\n            progress('.');\n\t}\n    }\n found:\n  xfree (rndbuf);\n  if( DBG_CIPHER )\n    progress('\\n');\n  mpi_free(p_1);\n  mpi_free(temp);\n  return k;\n}", "target": 0}
{"code": "pci_get_cfgdata16(struct pci_vdev *dev, int offset)\n{\n\tassert(offset <= (PCI_REGMAX - 1) && (offset & 1) == 0);\n\treturn (*(uint16_t *)(dev->cfgdata + offset));\n}", "target": 1}
{"code": "GIT_INLINE(bool) only_spaces_and_dots(const char *path)\n{\n\tconst char *c = path;\n\tfor (;; c++) {\n\t\tif (*c == '\\0')\n\t\t\treturn true;\n\t\tif (*c != ' ' && *c != '.')\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "struct rad_packet_t *rad_packet_alloc(int code)\n{\n\tstruct rad_packet_t *pack;\n\tpack = mempool_alloc(packet_pool);\n\tif (!pack) {\n\t\tlog_emerg(\"radius:packet: out of memory\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(pack, 0, sizeof(*pack));\n\tpack->code = code;\n\tpack->len = 20;\n\tpack->id = 1;\n\tINIT_LIST_HEAD(&pack->attrs);\n\treturn pack;\n}", "target": 0}
{"code": "static int dump_suid_policy()\n{\n    int c;\n    int suid_dump_policy = 0;\n    const char *filename = \"/proc/sys/fs/suid_dumpable\";\n    FILE *f  = fopen(filename, \"r\");\n    if (!f)\n    {\n        log(\"Can't open %s\", filename);\n        return suid_dump_policy;\n    }\n    c = fgetc(f);\n    fclose(f);\n    if (c != EOF)\n        suid_dump_policy = c - '0';\n    return suid_dump_policy;\n}", "target": 0}
{"code": "void dvb_usb_device_exit(struct usb_interface *intf)\n{\n\tstruct dvb_usb_device *d = usb_get_intfdata(intf);\n\tconst char *name = \"generic DVB-USB module\";\n\tusb_set_intfdata(intf, NULL);\n\tif (d != NULL && d->desc != NULL) {\n\t\tname = d->desc->name;\n\t\tdvb_usb_exit(d);\n\t}\n\tinfo(\"%s successfully deinitialized and disconnected.\", name);\n}", "target": 1}
{"code": "static sctp_disposition_t sctp_sf_do_dupcook_b(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_chunk *chunk,\n\t\t\t\t\tsctp_cmd_seq_t *commands,\n\t\t\t\t\tstruct sctp_association *new_asoc)\n{\n\tsctp_init_chunk_t *peer_init;\n\tstruct sctp_chunk *repl;\n\tpeer_init = &chunk->subh.cookie_hdr->c.peer_init[0];\n\tif (!sctp_process_init(new_asoc, chunk, sctp_source(chunk), peer_init,\n\t\t\t       GFP_ATOMIC))\n\t\tgoto nomem;\n\tsctp_add_cmd_sf(commands, SCTP_CMD_UPDATE_ASSOC, SCTP_ASOC(new_asoc));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_ESTABLISHED));\n\tSCTP_INC_STATS(net, SCTP_MIB_CURRESTAB);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_START, SCTP_NULL());\n\trepl = sctp_make_cookie_ack(new_asoc, chunk);\n\tif (!repl)\n\t\tgoto nomem;\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_CHANGE, SCTP_U8(SCTP_COMM_UP));\n\tif (asoc->peer.adaptation_ind)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ADAPTATION_IND, SCTP_NULL());\n\treturn SCTP_DISPOSITION_CONSUME;\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}", "target": 0}
{"code": "static s32 adpt_send_nop(adpt_hba*pHba,u32 m)\n{\n\tu32 __iomem *msg;\n\tulong timeout = jiffies + 5*HZ;\n\twhile(m == EMPTY_QUEUE){\n\t\trmb();\n\t\tm = readl(pHba->post_port);\n\t\tif(m != EMPTY_QUEUE){\n\t\t\tbreak;\n\t\t}\n\t\tif(time_after(jiffies,timeout)){\n\t\t\tprintk(KERN_ERR \"%s: Timeout waiting for message frame!\\n\",pHba->name);\n\t\t\treturn 2;\n\t\t}\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n\tmsg = (u32 __iomem *)(pHba->msg_addr_virt + m);\n\twritel( THREE_WORD_MSG_SIZE | SGL_OFFSET_0,&msg[0]);\n\twritel( I2O_CMD_UTIL_NOP << 24 | HOST_TID << 12 | 0,&msg[1]);\n\twritel( 0,&msg[2]);\n\twmb();\n\twritel(m, pHba->post_port);\n\twmb();\n\treturn 0;\n}", "target": 1}
{"code": "read_yin_subnode(struct ly_ctx *ctx, struct lyxml_elem *node, const char *name)\n{\n    int len;\n    if (!node->child || !node->child->name || strcmp(node->child->name, name)) {\n        LOGERR(ctx, LY_EVALID, \"Expected \\\"%s\\\" element in \\\"%s\\\" element.\", name, node->name);\n        LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, name, node->name);\n        return NULL;\n    } else if (node->child->content) {\n        len = strlen(node->child->content);\n        return lydict_insert(ctx, node->child->content, len);\n    } else {\n        return lydict_insert(ctx, \"\", 0);\n    }\n}", "target": 0}
{"code": "        int          GetU16BE (int nPos, bool *pbSuccess)\n        {\n            if ( nPos < 0 || nPos + 1 >= m_nLen)\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            int nRes = m_sFile[ nPos ];\n            nRes = (nRes << 8) + m_sFile[ nPos + 1 ];\n            return nRes;\n        }", "target": 1}
{"code": "TEST_P(ResizeRealtimeTest, DISABLED_TestExternalResizeSmallerWidthBiggerSize) {\n  ResizingVideoSource video;\n  video.flag_codec_ = true;\n  video.smaller_width_larger_size_ = true;\n  DefaultConfig();\n  cfg_.rc_resize_allowed = 0;\n  change_bitrate_ = false;\n  mismatch_psnr_ = 0.0;\n  mismatch_nframes_ = 0;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  for (std::vector<FrameInfo>::const_iterator info = frame_info_list_.begin();\n       info != frame_info_list_.end(); ++info) {\n    const unsigned int frame = static_cast<unsigned>(info->pts);\n    unsigned int expected_w;\n    unsigned int expected_h;\n    ScaleForFrameNumber(frame, kInitialWidth, kInitialHeight, &expected_w,\n                        &expected_h, video.flag_codec_,\n                        video.smaller_width_larger_size_);\n    EXPECT_EQ(expected_w, info->w)\n        << \"Frame \" << frame << \" had unexpected width\";\n    EXPECT_EQ(expected_h, info->h)\n        << \"Frame \" << frame << \" had unexpected height\";\n    EXPECT_EQ(static_cast<unsigned int>(0), GetMismatchFrames());\n  }\n}", "target": 1}
{"code": "static int packet_snd_vnet_gso(struct sk_buff *skb,\n\t\t\t       struct virtio_net_hdr *vnet_hdr)\n{\n\tif (vnet_hdr->flags & VIRTIO_NET_HDR_F_NEEDS_CSUM) {\n\t\tu16 s = __virtio16_to_cpu(vio_le(), vnet_hdr->csum_start);\n\t\tu16 o = __virtio16_to_cpu(vio_le(), vnet_hdr->csum_offset);\n\t\tif (!skb_partial_csum_set(skb, s, o))\n\t\t\treturn -EINVAL;\n\t}\n\tskb_shinfo(skb)->gso_size =\n\t\t__virtio16_to_cpu(vio_le(), vnet_hdr->gso_size);\n\tskb_shinfo(skb)->gso_type = vnet_hdr->gso_type;\n\tskb_shinfo(skb)->gso_type |= SKB_GSO_DODGY;\n\tskb_shinfo(skb)->gso_segs = 0;\n\treturn 0;\n}", "target": 0}
{"code": "static inline RBinWasmCustomNameLocalName *parse_local_name(RBuffer *b, ut64 bound) {\n\tRBinWasmCustomNameLocalName *local_name = R_NEW0 (RBinWasmCustomNameLocalName);\n\tif (local_name) {\n\t\tif (!consume_u32_r (b, bound, &local_name->index)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tlocal_name->names = r_id_storage_new (0, UT32_MAX);\n\t\tif (!local_name->names) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (!parse_namemap (b, bound, local_name->names, &local_name->names_count)) {\n\t\t\tgoto beach;\n\t\t}\n\t\treturn local_name;\n\t}\nbeach:\n\twasm_custom_name_local_free (local_name);\n\treturn NULL;\n}", "target": 0}
{"code": "static int proc_pid_io_accounting(struct task_struct *task, char *buffer)\n{\n\treturn sprintf(buffer,\n#ifdef CONFIG_TASK_XACCT\n\t\t\t\"rchar: %llu\\n\"\n\t\t\t\"wchar: %llu\\n\"\n\t\t\t\"syscr: %llu\\n\"\n\t\t\t\"syscw: %llu\\n\"\n#endif\n\t\t\t\"read_bytes: %llu\\n\"\n\t\t\t\"write_bytes: %llu\\n\"\n\t\t\t\"cancelled_write_bytes: %llu\\n\",\n#ifdef CONFIG_TASK_XACCT\n\t\t\t(unsigned long long)task->rchar,\n\t\t\t(unsigned long long)task->wchar,\n\t\t\t(unsigned long long)task->syscr,\n\t\t\t(unsigned long long)task->syscw,\n#endif\n\t\t\t(unsigned long long)task->ioac.read_bytes,\n\t\t\t(unsigned long long)task->ioac.write_bytes,\n\t\t\t(unsigned long long)task->ioac.cancelled_write_bytes);\n}", "target": 0}
{"code": "  void getReadBuffer(void** bufReturn, size_t* lenReturn) override {\n    *bufReturn = buf_.data();\n    *lenReturn = buf_.size();\n  }", "target": 0}
{"code": "static int find_length(struct pdf_struct *pdf,\n\t\t       struct pdf_obj *obj,\n\t\t       const char *start, off_t len)\n{\n    int length;\n    const char *q;\n    q = cli_memstr(start, len, \"/Length\", 7);\n    if (!q)\n\treturn 0;\n    q++;\n    len -= q - start;\n    start = pdf_nextobject(q, len);\n    if (!start)\n\treturn 0;\n    q = start;\n    length = atoi(q);\n    while (isdigit(*q)) q++;\n    if (*q == ' ') {\n\tint genid;\n\tq++;\n\tgenid = atoi(q);\n\twhile(isdigit(*q)) q++;\n\tif (q[0] == ' ' && q[1] == 'R') {\n\t    cli_dbgmsg(\"cli_pdf: length is in indirect object %u %u\\n\", length, genid);\n\t    obj = find_obj(pdf, obj, (length << 8) | (genid&0xff));\n\t    if (!obj) {\n\t\tcli_dbgmsg(\"cli_pdf: indirect object not found\\n\");\n\t\treturn 0;\n\t    }\n\t    q = pdf_nextobject(pdf->map+obj->start, pdf->size - obj->start);\n\t    length = atoi(q);\n\t}\n    }\n    if (start - pdf->map + length+5 > pdf->size) {\n\tlength = pdf->size - (start - pdf->map)-5;\n    }\n    return length;\n}", "target": 0}
{"code": "SampleEncrypter::Create(const AP4_UI08* key, const AP4_UI08* iv, SampleEncrypter*& encrypter) {\n    encrypter = NULL;\n    AP4_BlockCipher* block_cipher = NULL;\n    AP4_Result result = AP4_DefaultBlockCipherFactory::Instance.CreateCipher(AP4_BlockCipher::AES_128,\n                                                                             AP4_BlockCipher::ENCRYPT,\n                                                                             AP4_BlockCipher::CBC,\n                                                                             NULL,\n                                                                             key,\n                                                                             16,\n                                                                             block_cipher);\n    if (AP4_FAILED(result)) return result;\n    AP4_CbcStreamCipher* stream_cipher = new AP4_CbcStreamCipher(block_cipher);\n    encrypter = new SampleEncrypter(stream_cipher, iv);\n    return AP4_SUCCESS;\n}", "target": 0}
{"code": "l2tp_q931_cc_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\n\tprint_16bits_val(ndo, (const uint16_t *)dat);\n\tND_PRINT((ndo, \", %02x\", dat[2]));\n\tif (length > 3) {\n\t\tND_PRINT((ndo, \" \"));\n\t\tprint_string(ndo, dat+3, length-3);\n\t}\n}", "target": 1}
{"code": "RawTile KakaduImage::getRegion( int seq, int ang, unsigned int res, int layers, int x, int y, unsigned int w, unsigned int h )\n{\n  unsigned int obpc = bpc;\n  if( bpc <= 16 && bpc > 8 ) obpc = 16;\n  else if( bpc <= 8 ) obpc = 8;\n#ifdef DEBUG\n  Timer timer;\n  timer.start();\n#endif\n  RawTile rawtile( 0, res, seq, ang, w, h, channels, obpc );\n  if( obpc == 16 ) rawtile.data = new unsigned short[w*h*channels];\n  else if( obpc == 8 ) rawtile.data = new unsigned char[w*h*channels];\n  else throw file_error( \"Kakadu :: Unsupported number of bits\" );\n  rawtile.dataLength = w*h*channels*(obpc/8);\n  rawtile.filename = getImagePath();\n  rawtile.timestamp = timestamp;\n  process( res, layers, x, y, w, h, rawtile.data );\n#ifdef DEBUG\n  logfile << \"Kakadu :: getRegion() :: \" << timer.getTime() << \" microseconds\" << endl;\n#endif\n  return rawtile;\n}", "target": 1}
{"code": "void set_cached_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tstruct posix_acl **p = acl_by_type(inode, type);\n\tstruct posix_acl *old;\n\told = xchg(p, posix_acl_dup(acl));\n\tif (!is_uncached_acl(old))\n\t\tposix_acl_release(old);\n}", "target": 0}
{"code": "PLIST_API void plist_from_xml(const char *plist_xml, uint32_t length, plist_t * plist)\n{\n    xmlDocPtr plist_doc = xmlParseMemory(plist_xml, length);\n    xmlNodePtr root_node = xmlDocGetRootElement(plist_doc);\n    xml_to_node(root_node, plist);\n    xmlFreeDoc(plist_doc);\n}", "target": 1}
{"code": "validate_commit_metadata (GVariant   *commit_data,\n                          const char *ref,\n                          const char *required_metadata,\n                          gsize       required_metadata_size,\n                          GError   **error)\n{\n  g_autoptr(GVariant) commit_metadata = NULL;\n  g_autoptr(GVariant) xa_metadata_v = NULL;\n  const char *xa_metadata = NULL;\n  gsize xa_metadata_size = 0;\n  commit_metadata = g_variant_get_child_value (commit_data, 0);\n  if (commit_metadata != NULL)\n    {\n      xa_metadata_v = g_variant_lookup_value (commit_metadata,\n                                              \"xa.metadata\",\n                                              G_VARIANT_TYPE_STRING);\n      if (xa_metadata_v)\n        xa_metadata = g_variant_get_string (xa_metadata_v, &xa_metadata_size);\n    }\n  if (xa_metadata == NULL ||\n      xa_metadata_size != required_metadata_size ||\n      memcmp (xa_metadata, required_metadata, xa_metadata_size) != 0)\n    {\n      g_set_error (error, G_IO_ERROR, G_IO_ERROR_PERMISSION_DENIED,\n                   _(\"Commit metadata for %s not matching expected metadata\"), ref);\n      return FALSE;\n    }\n  return TRUE;\n}", "target": 0}
{"code": "void kvm_get_pfn(pfn_t pfn)\n{\n\tif (!kvm_is_mmio_pfn(pfn))\n\t\tget_page(pfn_to_page(pfn));\n}", "target": 0}
{"code": "ref_param_read_float_array(gs_param_list * plist, gs_param_name pkey,\n                           gs_param_float_array * pvalue)\n{\n    iparam_list *const iplist = (iparam_list *) plist;\n    iparam_loc loc;\n    ref aref, elt;\n    int code = ref_param_read_array(iplist, pkey, &loc);\n    float *pfv;\n    uint size;\n    long i;\n    if (code != 0)\n        return code;\n    size = r_size(loc.pvalue);\n    pfv = (float *)gs_alloc_byte_array(plist->memory, size, sizeof(float),\n                                       \"ref_param_read_float_array\");\n    if (pfv == 0)\n        return_error(gs_error_VMerror);\n    aref = *loc.pvalue;\n    loc.pvalue = &elt;\n    for (i = 0; code >= 0 && i < size; i++) {\n        array_get(plist->memory, &aref, i, &elt);\n        code = float_param(&elt, pfv + i);\n    }\n    if (code < 0) {\n        gs_free_object(plist->memory, pfv, \"ref_read_float_array_param\");\n        return (*loc.presult = code);\n    }\n    pvalue->data = pfv;\n    pvalue->size = size;\n    pvalue->persistent = true;\n    return 0;\n}", "target": 0}
{"code": "parse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree, *branch = NULL;\n  tree = parse_branch (regexp, preg, token, syntax, nest, err);\n  if (BE (*err != REG_NOERROR && tree == NULL, 0))\n    return NULL;\n  while (token->type == OP_ALT)\n    {\n      fetch_token (token, regexp, syntax | RE_CARET_ANCHORS_HERE);\n      if (token->type != OP_ALT && token->type != END_OF_RE\n\t  && (nest == 0 || token->type != OP_CLOSE_SUBEXP))\n\t{\n\t  branch = parse_branch (regexp, preg, token, syntax, nest, err);\n\t  if (BE (*err != REG_NOERROR && branch == NULL, 0))\n\t    {\n\t      if (tree != NULL)\n\t\tpostorder (tree, free_tree, NULL);\n\t      return NULL;\n\t    }\n\t}\n      else\n\tbranch = NULL;\n      tree = create_tree (dfa, tree, branch, OP_ALT);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n    }\n  return tree;\n}", "target": 1}
{"code": "ModuleExport size_t RegisterWMFImage(void)\n{\n  MagickInfo\n    *entry;\n  entry = AcquireMagickInfo(\"WMF\",\"WMZ\",\"Compressed Windows Meta File\");\n#if defined(MAGICKCORE_SANS_DELEGATE) || defined(MAGICKCORE_WMF_DELEGATE)\n  entry->decoder=ReadWMFImage;\n#endif\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"WMF\",\"WMF\",\"Windows Meta File\");\n#if defined(MAGICKCORE_SANS_DELEGATE) || defined(MAGICKCORE_WMF_DELEGATE)\n  entry->decoder=ReadWMFImage;\n#endif\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}", "target": 0}
{"code": "static int install_thread_keyring(void)\n{\n\tstruct cred *new;\n\tint ret;\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\tBUG_ON(new->thread_keyring);\n\tret = install_thread_keyring_to_cred(new);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\treturn ret;\n\t}\n\treturn commit_creds(new);\n}", "target": 1}
{"code": "gtime2generalTime(time_t gtime, char *str_time, size_t str_time_size)\n{\n\tsize_t ret;\n\tstruct tm _tm;\n\tif (gtime == (time_t)-1\n#if SIZEOF_LONG == 8\n\t\t|| gtime >= 253402210800\n#endif\n\t ) {\n        \tsnprintf(str_time, str_time_size, \"99991231235959Z\");\n        \treturn 0;\n\t}\n\tif (!gmtime_r(&gtime, &_tm)) {\n\t\tgnutls_assert();\n\t\treturn GNUTLS_E_INTERNAL_ERROR;\n\t}\n\tret = strftime(str_time, str_time_size, \"%Y%m%d%H%M%SZ\", &_tm);\n\tif (!ret) {\n\t\tgnutls_assert();\n\t\treturn GNUTLS_E_SHORT_MEMORY_BUFFER;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "transientObjectPutErrorMessage(Runtime *runtime, Handle<> base, SymbolID id) {\n  StringView propName =\n      runtime->getIdentifierTable().getStringView(runtime, id);\n  Handle<StringPrimitive> baseType =\n      runtime->makeHandle(vmcast<StringPrimitive>(typeOf(runtime, base)));\n  StringView baseTypeAsString =\n      StringPrimitive::createStringView(runtime, baseType);\n  MutableHandle<StringPrimitive> valueAsString{runtime};\n  if (base->isSymbol()) {\n    auto str = symbolDescriptiveString(runtime, Handle<SymbolID>::vmcast(base));\n    if (str != ExecutionStatus::EXCEPTION) {\n      valueAsString = *str;\n    } else {\n      runtime->clearThrownValue();\n      valueAsString = StringPrimitive::createNoThrow(\n          runtime, \"<<Exception occurred getting the value>>\");\n    }\n  } else {\n    auto str = toString_RJS(runtime, base);\n    assert(\n        str != ExecutionStatus::EXCEPTION &&\n        \"Primitives should be convertible to string without exceptions\");\n    valueAsString = std::move(*str);\n  }\n  StringView valueAsStringPrintable =\n      StringPrimitive::createStringView(runtime, valueAsString);\n  SmallU16String<32> tmp;\n  return runtime->raiseTypeError(\n      TwineChar16(\"Cannot create property '\") + propName + \"' on \" +\n      baseTypeAsString.getUTF16Ref(tmp) + \" '\" +\n      valueAsStringPrintable.getUTF16Ref(tmp) + \"'\");\n}", "target": 1}
{"code": "static int x25_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_x25 *addr = (struct sockaddr_x25 *)uaddr;\n\tint len, i, rc = 0;\n\tif (addr_len != sizeof(struct sockaddr_x25) ||\n\t    addr->sx25_family != AF_X25 ||\n\t    strnlen(addr->sx25_addr.x25_addr, X25_ADDR_LEN) == X25_ADDR_LEN) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (strcmp(addr->sx25_addr.x25_addr, null_x25_address.x25_addr)) {\n\t\tlen = strlen(addr->sx25_addr.x25_addr);\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!isdigit(addr->sx25_addr.x25_addr[i])) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\tlock_sock(sk);\n\tif (sock_flag(sk, SOCK_ZAPPED)) {\n\t\tx25_sk(sk)->source_addr = addr->sx25_addr;\n\t\tx25_insert_socket(sk);\n\t\tsock_reset_flag(sk, SOCK_ZAPPED);\n\t} else {\n\t\trc = -EINVAL;\n\t}\n\trelease_sock(sk);\n\tSOCK_DEBUG(sk, \"x25_bind: socket is bound\\n\");\nout:\n\treturn rc;\n}", "target": 0}
{"code": " void OmniboxEditModel::RestoreState(const State* state) {\n   controller_->GetToolbarModel()->set_url_replacement_enabled(\n      !state || state->url_replacement_enabled);\n   permanent_text_ = controller_->GetToolbarModel()->GetText();\n  view_->RevertWithoutResettingSearchTermReplacement();\n  input_ = state ? state->autocomplete_input : AutocompleteInput();\n  if (!state)\n    return;\n  SetFocusState(state->focus_state, OMNIBOX_FOCUS_CHANGE_TAB_SWITCH);\n  focus_source_ = state->focus_source;\n  if (state->user_input_in_progress) {\n    keyword_ = state->keyword;\n    is_keyword_hint_ = state->is_keyword_hint;\n    view_->SetUserText(state->user_text,\n        DisplayTextFromUserText(state->user_text), false);\n    view_->SetGrayTextAutocompletion(state->gray_text);\n  }\n}", "target": 1}
{"code": "virgl_cmd_resource_flush(VuGpu *g,\n                         struct virtio_gpu_ctrl_command *cmd)\n{\n    struct virtio_gpu_resource_flush rf;\n    int i;\n    VUGPU_FILL_CMD(rf);\n    glFlush();\n    if (!rf.resource_id) {\n        g_debug(\"bad resource id for flush..?\");\n        return;\n    }\n    for (i = 0; i < VIRTIO_GPU_MAX_SCANOUTS; i++) {\n        if (g->scanout[i].resource_id != rf.resource_id) {\n            continue;\n        }\n        VhostUserGpuMsg msg = {\n            .request = VHOST_USER_GPU_DMABUF_UPDATE,\n            .size = sizeof(VhostUserGpuUpdate),\n            .payload.update.scanout_id = i,\n            .payload.update.x = rf.r.x,\n            .payload.update.y = rf.r.y,\n            .payload.update.width = rf.r.width,\n            .payload.update.height = rf.r.height\n        };\n        vg_send_msg(g, &msg, -1);\n        vg_wait_ok(g);\n    }\n}", "target": 0}
{"code": "static inline void __clear_open_fd(unsigned int fd, struct fdtable *fdt)\n{\n\t__clear_bit(fd, fdt->open_fds);\n\t__clear_bit(fd / BITS_PER_LONG, fdt->full_fds_bits);\n}", "target": 0}
{"code": "static void hci_sock_cmsg(struct sock *sk, struct msghdr *msg,\n\t\t\t  struct sk_buff *skb)\n{\n\t__u32 mask = hci_pi(sk)->cmsg_mask;\n\tif (mask & HCI_CMSG_DIR) {\n\t\tint incoming = bt_cb(skb)->incoming;\n\t\tput_cmsg(msg, SOL_HCI, HCI_CMSG_DIR, sizeof(incoming),\n\t\t\t &incoming);\n\t}\n\tif (mask & HCI_CMSG_TSTAMP) {\n#ifdef CONFIG_COMPAT\n\t\tstruct compat_timeval ctv;\n#endif\n\t\tstruct timeval tv;\n\t\tvoid *data;\n\t\tint len;\n\t\tskb_get_timestamp(skb, &tv);\n\t\tdata = &tv;\n\t\tlen = sizeof(tv);\n#ifdef CONFIG_COMPAT\n\t\tif (!COMPAT_USE_64BIT_TIME &&\n\t\t    (msg->msg_flags & MSG_CMSG_COMPAT)) {\n\t\t\tctv.tv_sec = tv.tv_sec;\n\t\t\tctv.tv_usec = tv.tv_usec;\n\t\t\tdata = &ctv;\n\t\t\tlen = sizeof(ctv);\n\t\t}\n#endif\n\t\tput_cmsg(msg, SOL_HCI, HCI_CMSG_TSTAMP, len, data);\n\t}\n}", "target": 0}
{"code": "struct pipe_inode_info *alloc_pipe_info(void)\n{\n\tstruct pipe_inode_info *pipe;\n\tpipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL);\n\tif (pipe) {\n\t\tpipe->bufs = kzalloc(sizeof(struct pipe_buffer) * PIPE_DEF_BUFFERS, GFP_KERNEL);\n\t\tif (pipe->bufs) {\n\t\t\tinit_waitqueue_head(&pipe->wait);\n\t\t\tpipe->r_counter = pipe->w_counter = 1;\n\t\t\tpipe->buffers = PIPE_DEF_BUFFERS;\n\t\t\tmutex_init(&pipe->mutex);\n\t\t\treturn pipe;\n\t\t}\n\t\tkfree(pipe);\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "vhost_user_set_owner(struct virtio_net **pdev __rte_unused,\n\t\t\tstruct VhostUserMsg *msg,\n\t\t\tint main_fd __rte_unused)\n{\n\tif (validate_msg_fds(msg, 0) != 0)\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\treturn RTE_VHOST_MSG_RESULT_OK;\n}", "target": 0}
{"code": "static int fsmMkdir(const char *path, mode_t mode)\n{\n    int rc = mkdir(path, (mode & 07777));\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, 0%04o) %s\\n\", __func__,\n\t       path, (unsigned)(mode & 07777),\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\trc = RPMERR_MKDIR_FAILED;\n    return rc;\n}", "target": 1}
{"code": "get_chainname_rulenum(const struct ipt_entry *s, const struct ipt_entry *e,\n\t\t      const char *hookname, const char **chainname,\n\t\t      const char **comment, unsigned int *rulenum)\n{\n\tconst struct xt_standard_target *t = (void *)ipt_get_target_c(s);\n\tif (strcmp(t->target.u.kernel.target->name, XT_ERROR_TARGET) == 0) {\n\t\t*chainname = t->target.data;\n\t\t(*rulenum) = 0;\n\t} else if (s == e) {\n\t\t(*rulenum)++;\n\t\tif (s->target_offset == sizeof(struct ipt_entry) &&\n\t\t    strcmp(t->target.u.kernel.target->name,\n\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t   t->verdict < 0 &&\n\t\t   unconditional(&s->ip)) {\n\t\t\t*comment = *chainname == hookname\n\t\t\t\t? comments[NF_IP_TRACE_COMMENT_POLICY]\n\t\t\t\t: comments[NF_IP_TRACE_COMMENT_RETURN];\n\t\t}\n\t\treturn 1;\n\t} else\n\t\t(*rulenum)++;\n\treturn 0;\n}", "target": 1}
{"code": "delta_head_create(struct delta_head **result)\n{\n\tstruct delta_head *tmp;\n\ttmp = malloc(sizeof(struct delta_head));\n\tif (tmp == NULL)\n\t\treturn pr_enomem();\n\tdoc_data_init(&tmp->doc_data);\n\t*result = tmp;\n\treturn 0;\n}", "target": 1}
{"code": "static int mov_read_rtmd_track(AVFormatContext *s, AVStream *st)\n{\n    MOVStreamContext *sc = st->priv_data;\n    FFStream *const sti = ffstream(st);\n    char buf[AV_TIMECODE_STR_SIZE];\n    int64_t cur_pos = avio_tell(sc->pb);\n    int hh, mm, ss, ff, drop;\n    if (!sti->nb_index_entries)\n        return -1;\n    avio_seek(sc->pb, sti->index_entries->pos, SEEK_SET);\n    avio_skip(s->pb, 13);\n    hh = avio_r8(s->pb);\n    mm = avio_r8(s->pb);\n    ss = avio_r8(s->pb);\n    drop = avio_r8(s->pb);\n    ff = avio_r8(s->pb);\n    snprintf(buf, AV_TIMECODE_STR_SIZE, \"%02d:%02d:%02d%c%02d\",\n             hh, mm, ss, drop ? ';' : ':', ff);\n    av_dict_set(&st->metadata, \"timecode\", buf, 0);\n    avio_seek(sc->pb, cur_pos, SEEK_SET);\n    return 0;\n}", "target": 0}
{"code": "OpTypeConstructor UnaryTensorContainer(FullTypeId t, FullTypeId dtype) {\n  return [t, dtype](OpDef* op_def) {\n    FullTypeDef* tdef =\n        op_def->mutable_output_arg(0)->mutable_experimental_full_type();\n    tdef->set_type_id(t);\n    FullTypeDef* arg = tdef->add_args();\n    arg->set_type_id(TFT_TENSOR);\n    FullTypeDef* targ = arg->add_args();\n    targ->set_type_id(dtype);\n    return Status::OK();\n  };\n}", "target": 0}
{"code": "static void ip6_dst_ifdown(struct dst_entry *dst, struct net_device *dev,\n\t\t\t   int how)\n{\n\tstruct rt6_info *rt = (struct rt6_info *)dst;\n\tstruct inet6_dev *idev = rt->rt6i_idev;\n\tstruct net_device *loopback_dev =\n\t\tdev_net(dev)->loopback_dev;\n\tif (dev != loopback_dev) {\n\t\tif (idev && idev->dev == dev) {\n\t\t\tstruct inet6_dev *loopback_idev =\n\t\t\t\tin6_dev_get(loopback_dev);\n\t\t\tif (loopback_idev) {\n\t\t\t\trt->rt6i_idev = loopback_idev;\n\t\t\t\tin6_dev_put(idev);\n\t\t\t}\n\t\t}\n\t\tif (rt->n && rt->n->dev == dev) {\n\t\t\trt->n->dev = loopback_dev;\n\t\t\tdev_hold(loopback_dev);\n\t\t\tdev_put(dev);\n\t\t}\n\t}\n}", "target": 0}
{"code": "    OVS_REQUIRES(ofproto_mutex)\n{\n    const struct rule_actions *actions = rule_get_actions(rule);\n    ovs_assert(rule->state == RULE_INITIALIZED);\n    if (rule->hard_timeout || rule->idle_timeout) {\n        ovs_list_insert(&ofproto->expirable, &rule->expirable);\n    }\n    cookies_insert(ofproto, rule);\n    eviction_group_add_rule(rule);\n    if (actions->has_meter) {\n        meter_insert_rule(rule);\n    }\n    if (actions->has_groups) {\n        const struct ofpact_group *a;\n        OFPACT_FOR_EACH_TYPE_FLATTENED (a, GROUP, actions->ofpacts,\n                                        actions->ofpacts_len) {\n            struct ofgroup *group;\n            group = ofproto_group_lookup(ofproto, a->group_id, OVS_VERSION_MAX,\n                                         false);\n            ovs_assert(group != NULL);\n            group_add_rule(group, rule);\n        }\n    }\n    rule->state = RULE_INSERTED;\n}", "target": 1}
{"code": "ecryptfs_decode_from_filename(unsigned char *dst, size_t *dst_size,\n\t\t\t      const unsigned char *src, size_t src_size)\n{\n\tu8 current_bit_offset = 0;\n\tsize_t src_byte_offset = 0;\n\tsize_t dst_byte_offset = 0;\n\tif (dst == NULL) {\n\t\t(*dst_size) = ecryptfs_max_decoded_size(src_size);\n\t\tgoto out;\n\t}\n\twhile (src_byte_offset < src_size) {\n\t\tunsigned char src_byte =\n\t\t\t\tfilename_rev_map[(int)src[src_byte_offset]];\n\t\tswitch (current_bit_offset) {\n\t\tcase 0:\n\t\t\tdst[dst_byte_offset] = (src_byte << 2);\n\t\t\tcurrent_bit_offset = 6;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tdst[dst_byte_offset++] |= (src_byte >> 4);\n\t\t\tdst[dst_byte_offset] = ((src_byte & 0xF)\n\t\t\t\t\t\t << 4);\n\t\t\tcurrent_bit_offset = 4;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdst[dst_byte_offset++] |= (src_byte >> 2);\n\t\t\tdst[dst_byte_offset] = (src_byte << 6);\n\t\t\tcurrent_bit_offset = 2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdst[dst_byte_offset++] |= (src_byte);\n\t\t\tdst[dst_byte_offset] = 0;\n\t\t\tcurrent_bit_offset = 0;\n\t\t\tbreak;\n\t\t}\n\t\tsrc_byte_offset++;\n\t}\n\t(*dst_size) = dst_byte_offset;\nout:\n\treturn;\n}", "target": 1}
{"code": "update_ldap_mod_auth_ind(krb5_context context, krb5_db_entry *entry,\n                         LDAPMod ***mods)\n{\n    int i = 0;\n    krb5_error_code ret;\n    char *auth_ind = NULL;\n    char *strval[10] = {};\n    char *ai, *ai_save = NULL;\n    int sv_num = sizeof(strval) / sizeof(*strval);\n    ret = krb5_dbe_get_string(context, entry, KRB5_KDB_SK_REQUIRE_AUTH,\n                              &auth_ind);\n    if (ret || auth_ind == NULL)\n        goto cleanup;\n    ai = strtok_r(auth_ind, \" \", &ai_save);\n    while (ai != NULL && i < sv_num) {\n        strval[i++] = ai;\n        ai = strtok_r(NULL, \" \", &ai_save);\n    }\n    ret = krb5_add_str_mem_ldap_mod(mods, \"krbPrincipalAuthInd\",\n                                    LDAP_MOD_REPLACE, strval);\ncleanup:\n    krb5_dbe_free_string(context, auth_ind);\n    return ret;\n}", "target": 0}
{"code": "compat_cipher_proposal(struct ssh *ssh, char *cipher_prop)\n{\n\tif (!(ssh->compat & SSH_BUG_BIGENDIANAES))\n\t\treturn cipher_prop;\n\tdebug2_f(\"original cipher proposal: %s\", cipher_prop);\n\tif ((cipher_prop = match_filter_denylist(cipher_prop, \"aes*\")) == NULL)\n\t\tfatal(\"match_filter_denylist failed\");\n\tdebug2_f(\"compat cipher proposal: %s\", cipher_prop);\n\tif (*cipher_prop == '\\0')\n\t\tfatal(\"No supported ciphers found\");\n\treturn cipher_prop;\n}", "target": 1}
{"code": "ConfirmInfoBar::ConfirmInfoBar(std::unique_ptr<ConfirmInfoBarDelegate> delegate)\n     : InfoBarView(std::move(delegate)) {\n   auto* delegate_ptr = GetDelegate();\n   label_ = CreateLabel(delegate_ptr->GetMessageText());\n   AddChildView(label_);\n   const auto buttons = delegate_ptr->GetButtons();\n  if (buttons & ConfirmInfoBarDelegate::BUTTON_OK) {\n    ok_button_ = CreateButton(ConfirmInfoBarDelegate::BUTTON_OK);\n    ok_button_->SetProminent(true);\n    if (delegate_ptr->OKButtonTriggersUACPrompt()) {\n      elevation_icon_setter_.reset(new ElevationIconSetter(\n          ok_button_,\n          base::BindOnce(&ConfirmInfoBar::Layout, base::Unretained(this))));\n    }\n  }\n  if (buttons & ConfirmInfoBarDelegate::BUTTON_CANCEL) {\n    cancel_button_ = CreateButton(ConfirmInfoBarDelegate::BUTTON_CANCEL);\n    if (buttons == ConfirmInfoBarDelegate::BUTTON_CANCEL)\n      cancel_button_->SetProminent(true);\n  }\n  link_ = CreateLink(delegate_ptr->GetLinkText(), this);\n  AddChildView(link_);\n}", "target": 1}
{"code": "handle_keywordonly_args(struct compiling *c, const node *n, int start,\n                        asdl_seq *kwonlyargs, asdl_seq *kwdefaults)\n{\n    PyObject *argname;\n    node *ch;\n    expr_ty expression, annotation;\n    arg_ty arg = NULL;\n    int i = start;\n    int j = 0; \n    if (kwonlyargs == NULL) {\n        ast_error(c, CHILD(n, start), \"named arguments must follow bare *\");\n        return -1;\n    }\n    assert(kwdefaults != NULL);\n    while (i < NCH(n)) {\n        ch = CHILD(n, i);\n        switch (TYPE(ch)) {\n            case vfpdef:\n            case tfpdef:\n                if (i + 1 < NCH(n) && TYPE(CHILD(n, i + 1)) == EQUAL) {\n                    expression = ast_for_expr(c, CHILD(n, i + 2));\n                    if (!expression)\n                        goto error;\n                    asdl_seq_SET(kwdefaults, j, expression);\n                    i += 2; \n                }\n                else { \n                    asdl_seq_SET(kwdefaults, j, NULL);\n                }\n                if (NCH(ch) == 3) {\n                    annotation = ast_for_expr(c, CHILD(ch, 2));\n                    if (!annotation)\n                        goto error;\n                }\n                else {\n                    annotation = NULL;\n                }\n                ch = CHILD(ch, 0);\n                argname = NEW_IDENTIFIER(ch);\n                if (!argname)\n                    goto error;\n                if (forbidden_name(c, argname, ch, 0))\n                    goto error;\n                arg = arg(argname, annotation, NULL, LINENO(ch), ch->n_col_offset,\n                          c->c_arena);\n                if (!arg)\n                    goto error;\n                asdl_seq_SET(kwonlyargs, j++, arg);\n                i += 1; \n                if (TYPE(CHILD(n, i)) == COMMA)\n                    i += 1; \n                break;\n            case TYPE_COMMENT:\n                arg->type_comment = NEW_TYPE_COMMENT(ch);\n                if (!arg->type_comment)\n                    goto error;\n                i += 1;\n                break;\n            case DOUBLESTAR:\n                return i;\n            default:\n                ast_error(c, ch, \"unexpected node\");\n                goto error;\n        }\n    }\n    return i;\n error:\n    return -1;\n}", "target": 1}
{"code": "static int search_old_relocation(struct reloc_struct_t *reloc_table, ut32 addr_to_patch, int n_reloc) {\n\tint i;\n\tfor (i = 0; i < n_reloc; i++) {\n\t\tif (addr_to_patch == reloc_table[i].data_offset) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}", "target": 1}
{"code": "    void CrwMap::decode0x180e(const CiffComponent& ciffComponent,\n                              const CrwMapping*    pCrwMapping,\n                                    Image&         image,\n                                    ByteOrder      byteOrder)\n    {\n        if (ciffComponent.size() < 8 || ciffComponent.typeId() != unsignedLong) {\n            return decodeBasic(ciffComponent, pCrwMapping, image, byteOrder);\n        }\n        assert(pCrwMapping != 0);\n        ULongValue v;\n        v.read(ciffComponent.pData(), 8, byteOrder);\n        time_t t = v.value_[0];\n#ifdef EXV_HAVE_GMTIME_R\n        struct tm tms;\n        struct tm* tm = &tms;\n        tm = gmtime_r(&t, tm);\n#else\n        struct tm* tm = std::gmtime(&t);\n#endif\n        if (tm) {\n            const size_t m = 20;\n            char s[m];\n            std::strftime(s, m, \"%Y:%m:%d %H:%M:%S\", tm);\n            ExifKey key(pCrwMapping->tag_, Internal::groupName(pCrwMapping->ifdId_));\n            AsciiValue value;\n            value.read(std::string(s));\n            image.exifData().add(key, &value);\n        }\n    } ", "target": 0}
{"code": "static int __tail_onwire_len(int front_len, int middle_len, int data_len,\n\t\t\t     bool secure)\n{\n\tBUG_ON(front_len < 0 || front_len > CEPH_MSG_MAX_FRONT_LEN ||\n\t       middle_len < 0 || middle_len > CEPH_MSG_MAX_MIDDLE_LEN ||\n\t       data_len < 0 || data_len > CEPH_MSG_MAX_DATA_LEN);\n\tif (!front_len && !middle_len && !data_len)\n\t\treturn 0;\n\tif (!secure)\n\t\treturn front_len + middle_len + data_len +\n\t\t       CEPH_EPILOGUE_PLAIN_LEN;\n\treturn padded_len(front_len) + padded_len(middle_len) +\n\t       padded_len(data_len) + CEPH_EPILOGUE_SECURE_LEN;\n}", "target": 0}
{"code": "static int dns_stream_complete(DnsStream *s, int error) {\n        assert(s);\n#if ENABLE_DNS_OVER_TLS\n        if (s->encrypted) {\n                int r;\n                r = dnstls_stream_shutdown(s, error);\n                if (r != -EAGAIN)\n                        dns_stream_stop(s);\n        } else\n#endif\n                dns_stream_stop(s);\n        if (s->complete)\n                s->complete(s, error);\n        else \n                dns_stream_unref(s);\n        return 0;\n}", "target": 1}
{"code": "PackLinuxElf32::elf_find_dynamic(unsigned int key) const\n{\n    Elf32_Dyn const *dynp= dynseg;\n    if (dynp)\n    for (; (unsigned)((char const *)dynp - (char const *)dynseg) < sz_dynseg\n            && Elf32_Dyn::DT_NULL!=dynp->d_tag; ++dynp) if (get_te32(&dynp->d_tag)==key) {\n        unsigned const t= elf_get_offset_from_address(get_te32(&dynp->d_val));\n        if (t) {\n            return t + file_image;\n        }\n        break;\n    }\n    return 0;\n}", "target": 1}
{"code": "  SaveContext* save_context() {return thread_local_top_.save_context_; }", "target": 0}
{"code": "BGD_DECLARE(void *) gdImageGifPtr(gdImagePtr im, int *size)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) return NULL;\n\tgdImageGifCtx(im, out);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\treturn rv;\n}", "target": 1}
{"code": "static void outbound_phy_packet_callback(struct fw_packet *packet,\n\t\t\t\t\t struct fw_card *card, int status)\n{\n\tstruct outbound_phy_packet_event *e =\n\t\tcontainer_of(packet, struct outbound_phy_packet_event, p);\n\tswitch (status) {\n\tcase ACK_COMPLETE:\te->phy_packet.rcode = RCODE_COMPLETE;\tbreak;\n\tcase ACK_PENDING:\te->phy_packet.rcode = RCODE_COMPLETE;\tbreak;\n\tcase ACK_BUSY_X:\n\tcase ACK_BUSY_A:\n\tcase ACK_BUSY_B:\te->phy_packet.rcode = RCODE_BUSY;\tbreak;\n\tcase ACK_DATA_ERROR:\te->phy_packet.rcode = RCODE_DATA_ERROR;\tbreak;\n\tcase ACK_TYPE_ERROR:\te->phy_packet.rcode = RCODE_TYPE_ERROR;\tbreak;\n\tdefault:\t\te->phy_packet.rcode = status;\t\tbreak;\n\t}\n\te->phy_packet.data[0] = packet->timestamp;\n\tqueue_event(e->client, &e->event, &e->phy_packet,\n\t\t    sizeof(e->phy_packet) + e->phy_packet.length, NULL, 0);\n\tclient_put(e->client);\n}", "target": 1}
{"code": "static struct key *request_user_key(const char *master_desc, const u8 **master_key,\n\t\t\t\t    size_t *master_keylen)\n{\n\tconst struct user_key_payload *upayload;\n\tstruct key *ukey;\n\tukey = request_key(&key_type_user, master_desc, NULL);\n\tif (IS_ERR(ukey))\n\t\tgoto error;\n\tdown_read(&ukey->sem);\n\tupayload = user_key_payload_locked(ukey);\n\t*master_key = upayload->data;\n\t*master_keylen = upayload->datalen;\nerror:\n\treturn ukey;\n}", "target": 0}
{"code": "bool WebContents::SendIPCMessageToFrame(bool internal,\n                                        int32_t frame_id,\n                                        const std::string& channel,\n                                        v8::Local<v8::Value> args) {\n  v8::Isolate* isolate = JavascriptEnvironment::GetIsolate();\n  blink::CloneableMessage message;\n  if (!gin::ConvertFromV8(isolate, args, &message)) {\n    isolate->ThrowException(v8::Exception::Error(\n        gin::StringToV8(isolate, \"Failed to serialize arguments\")));\n    return false;\n  }\n  auto frames = web_contents()->GetAllFrames();\n  auto iter = std::find_if(frames.begin(), frames.end(), [frame_id](auto* f) {\n    return f->GetRoutingID() == frame_id;\n  });\n  if (iter == frames.end())\n    return false;\n  if (!(*iter)->IsRenderFrameLive())\n    return false;\n  mojo::AssociatedRemote<mojom::ElectronRenderer> electron_renderer;\n  (*iter)->GetRemoteAssociatedInterfaces()->GetInterface(&electron_renderer);\n  electron_renderer->Message(internal, channel, std::move(message),\n                             0 );\n  return true;\n}", "target": 1}
{"code": "gdImagePtr gdImageScaleTwoPass(const gdImagePtr src, const unsigned int src_width, const unsigned int src_height, const unsigned int new_width, const unsigned int new_height)\n{\n\tgdImagePtr tmp_im;\n\tgdImagePtr dst;\n\tif (!src->trueColor) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\ttmp_im = gdImageCreateTrueColor(new_width, src_height);\n\tif (tmp_im == NULL) {\n\t\treturn NULL;\n\t}\n\tgdImageSetInterpolationMethod(tmp_im, src->interpolation_id);\n\t_gdScaleHoriz(src, src_width, src_height, tmp_im, new_width, src_height);\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (dst == NULL) {\n\t\tgdFree(tmp_im);\n\t\treturn NULL;\n\t}\n\tgdImageSetInterpolationMethod(dst, src->interpolation_id);\n\t_gdScaleVert(tmp_im, new_width, src_height, dst, new_width, new_height);\n\tgdFree(tmp_im);\n\treturn dst;\n}", "target": 1}
{"code": "static inline void native_set_ldt(const void *addr, unsigned int entries)\n{\n\tif (likely(entries == 0))\n\t\tasm volatile(\"lldt %w0\"::\"q\" (0));\n\telse {\n\t\tunsigned cpu = smp_processor_id();\n\t\tldt_desc ldt;\n\t\tset_tssldt_descriptor(&ldt, (unsigned long)addr,\n\t\t\t\t      DESC_LDT, entries * sizeof(ldt) - 1);\n\t\twrite_gdt_entry(get_cpu_gdt_table(cpu), GDT_ENTRY_LDT,\n\t\t\t\t&ldt, DESC_LDT);\n\t\tasm volatile(\"lldt %w0\"::\"q\" (GDT_ENTRY_LDT*8));\n\t}\n}", "target": 1}
{"code": "append_wild(char *to, char *end, const char *wild)\n{\n  end-=5;\t\t\t\t\t\n  if (wild && wild[0])\n  {\n    to=strmov(to,\" like '\");\n    while (*wild && to < end)\n    {\n      if (*wild == '\\\\' || *wild == '\\'')\n\t*to++='\\\\';\n      *to++= *wild++;\n    }\n    if (*wild)\t\t\t\t\t\n      *to++='%';\t\t\t\t\n    to[0]='\\'';\n    to[1]=0;\n  }\n}", "target": 0}
{"code": "GfxShading *GfxShading::parse(GfxResources *res, Object *obj, OutputDev *out, GfxState *state)\n{\n    GfxShading *shading;\n    Dict *dict;\n    int typeA;\n    Object obj1;\n    if (obj->isDict()) {\n        dict = obj->getDict();\n    } else if (obj->isStream()) {\n        dict = obj->streamGetDict();\n    } else {\n        return nullptr;\n    }\n    obj1 = dict->lookup(\"ShadingType\");\n    if (!obj1.isInt()) {\n        error(errSyntaxWarning, -1, \"Invalid ShadingType in shading dictionary\");\n        return nullptr;\n    }\n    typeA = obj1.getInt();\n    switch (typeA) {\n    case 1:\n        shading = GfxFunctionShading::parse(res, dict, out, state);\n        break;\n    case 2:\n        shading = GfxAxialShading::parse(res, dict, out, state);\n        break;\n    case 3:\n        shading = GfxRadialShading::parse(res, dict, out, state);\n        break;\n    case 4:\n        if (obj->isStream()) {\n            shading = GfxGouraudTriangleShading::parse(res, 4, dict, obj->getStream(), out, state);\n        } else {\n            error(errSyntaxWarning, -1, \"Invalid Type 4 shading object\");\n            goto err1;\n        }\n        break;\n    case 5:\n        if (obj->isStream()) {\n            shading = GfxGouraudTriangleShading::parse(res, 5, dict, obj->getStream(), out, state);\n        } else {\n            error(errSyntaxWarning, -1, \"Invalid Type 5 shading object\");\n            goto err1;\n        }\n        break;\n    case 6:\n        if (obj->isStream()) {\n            shading = GfxPatchMeshShading::parse(res, 6, dict, obj->getStream(), out, state);\n        } else {\n            error(errSyntaxWarning, -1, \"Invalid Type 6 shading object\");\n            goto err1;\n        }\n        break;\n    case 7:\n        if (obj->isStream()) {\n            shading = GfxPatchMeshShading::parse(res, 7, dict, obj->getStream(), out, state);\n        } else {\n            error(errSyntaxWarning, -1, \"Invalid Type 7 shading object\");\n            goto err1;\n        }\n        break;\n    default:\n        error(errSyntaxWarning, -1, \"Unimplemented shading type {0:d}\", typeA);\n        goto err1;\n    }\n    return shading;\nerr1:\n    return nullptr;\n}", "target": 0}
{"code": "static void update_ple_window_actual_max(void)\n{\n\tple_window_actual_max =\n\t\t\t__shrink_ple_window(max(ple_window_max, ple_window),\n\t\t\t                    ple_window_grow, INT_MIN);\n}", "target": 0}
{"code": "static int _nfs4_proc_readdir(struct dentry *dentry, struct rpc_cred *cred,\n\t\tu64 cookie, struct page **pages, unsigned int count, int plus)\n{\n\tstruct inode\t\t*dir = dentry->d_inode;\n\tstruct nfs4_readdir_arg args = {\n\t\t.fh = NFS_FH(dir),\n\t\t.pages = pages,\n\t\t.pgbase = 0,\n\t\t.count = count,\n\t\t.bitmask = NFS_SERVER(dentry->d_inode)->attr_bitmask,\n\t\t.plus = plus,\n\t};\n\tstruct nfs4_readdir_res res;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_READDIR],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t\t.rpc_cred = cred,\n\t};\n\tint\t\t\tstatus;\n\tdprintk(\"%s: dentry = %s/%s, cookie = %Lu\\n\", __func__,\n\t\t\tdentry->d_parent->d_name.name,\n\t\t\tdentry->d_name.name,\n\t\t\t(unsigned long long)cookie);\n\tnfs4_setup_readdir(cookie, NFS_I(dir)->cookieverf, dentry, &args);\n\tres.pgbase = args.pgbase;\n\tstatus = nfs4_call_sync(NFS_SERVER(dir)->client, NFS_SERVER(dir), &msg, &args.seq_args, &res.seq_res, 0);\n\tif (status >= 0) {\n\t\tmemcpy(NFS_I(dir)->cookieverf, res.verifier.data, NFS4_VERIFIER_SIZE);\n\t\tstatus += args.pgbase;\n\t}\n\tnfs_invalidate_atime(dir);\n\tdprintk(\"%s: returns %d\\n\", __func__, status);\n\treturn status;\n}", "target": 0}
{"code": "virNodeDeviceGetMdevTypesCaps(const char *sysfspath,\n                              virMediatedDeviceTypePtr **mdev_types,\n                              size_t *nmdev_types)\n{\n    virMediatedDeviceTypePtr *types = NULL;\n    size_t ntypes = 0;\n    size_t i;\n    for (i = 0; i < *nmdev_types; i++)\n       virMediatedDeviceTypeFree(*mdev_types[i]);\n    VIR_FREE(*mdev_types);\n    *nmdev_types = 0;\n    if (virMediatedDeviceGetMdevTypes(sysfspath, &types, &ntypes) < 0)\n        return -1;\n    *mdev_types = g_steal_pointer(&types);\n    *nmdev_types = ntypes;\n    return 0;\n}", "target": 1}
{"code": "allocate_trace_buffer(struct trace_array *tr, struct trace_buffer *buf, int size)\n{\n\tenum ring_buffer_flags rb_flags;\n\trb_flags = tr->trace_flags & TRACE_ITER_OVERWRITE ? RB_FL_OVERWRITE : 0;\n\tbuf->tr = tr;\n\tbuf->buffer = ring_buffer_alloc(size, rb_flags);\n\tif (!buf->buffer)\n\t\treturn -ENOMEM;\n\tbuf->data = alloc_percpu(struct trace_array_cpu);\n\tif (!buf->data) {\n\t\tring_buffer_free(buf->buffer);\n\t\treturn -ENOMEM;\n\t}\n\tset_buffer_entries(&tr->trace_buffer,\n\t\t\t   ring_buffer_size(tr->trace_buffer.buffer, 0));\n\treturn 0;\n}", "target": 1}
{"code": "static void vmx_complete_atomic_exit(struct vcpu_vmx *vmx)\n{\n\tu32 exit_intr_info;\n\tif (!(vmx->exit_reason == EXIT_REASON_MCE_DURING_VMENTRY\n\t      || vmx->exit_reason == EXIT_REASON_EXCEPTION_NMI))\n\t\treturn;\n\tvmx->exit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\texit_intr_info = vmx->exit_intr_info;\n\tif (is_machine_check(exit_intr_info))\n\t\tkvm_machine_check();\n\tif ((exit_intr_info & INTR_INFO_INTR_TYPE_MASK) == INTR_TYPE_NMI_INTR &&\n\t    (exit_intr_info & INTR_INFO_VALID_MASK)) {\n\t\tkvm_before_handle_nmi(&vmx->vcpu);\n\t\tasm(\"int $2\");\n\t\tkvm_after_handle_nmi(&vmx->vcpu);\n\t}\n}", "target": 1}
{"code": "static void build_probe_list(struct inode *inode,\n\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\tunsigned long start, unsigned long end,\n\t\t\t\tstruct list_head *head)\n{\n\tloff_t min, max;\n\tstruct rb_node *n, *t;\n\tstruct uprobe *u;\n\tINIT_LIST_HEAD(head);\n\tmin = vaddr_to_offset(vma, start);\n\tmax = min + (end - start) - 1;\n\tspin_lock(&uprobes_treelock);\n\tn = find_node_in_range(inode, min, max);\n\tif (n) {\n\t\tfor (t = n; t; t = rb_prev(t)) {\n\t\t\tu = rb_entry(t, struct uprobe, rb_node);\n\t\t\tif (u->inode != inode || u->offset < min)\n\t\t\t\tbreak;\n\t\t\tlist_add(&u->pending_list, head);\n\t\t\tget_uprobe(u);\n\t\t}\n\t\tfor (t = n; (t = rb_next(t)); ) {\n\t\t\tu = rb_entry(t, struct uprobe, rb_node);\n\t\t\tif (u->inode != inode || u->offset > max)\n\t\t\t\tbreak;\n\t\t\tlist_add(&u->pending_list, head);\n\t\t\tget_uprobe(u);\n\t\t}\n\t}\n\tspin_unlock(&uprobes_treelock);\n}", "target": 0}
{"code": "static int crypto_report_akcipher(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_akcipher rakcipher;\n\tstrlcpy(rakcipher.type, \"akcipher\", sizeof(rakcipher.type));\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_AKCIPHER,\n\t\t    sizeof(struct crypto_report_akcipher), &rakcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": " OPJ_BOOL opj_j2k_write_rgn(opj_j2k_t *p_j2k,\n                            OPJ_UINT32 p_tile_no,\n                            OPJ_UINT32 p_comp_no,\n                            OPJ_UINT32 nb_comps,\n                            opj_stream_private_t *p_stream,\n                            opj_event_mgr_t * p_manager\n                            )\n{\n        OPJ_BYTE * l_current_data = 00;\n        OPJ_UINT32 l_rgn_size;\n        opj_cp_t *l_cp = 00;\n        opj_tcp_t *l_tcp = 00;\n        opj_tccp_t *l_tccp = 00;\n        OPJ_UINT32 l_comp_room;\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n        l_cp = &(p_j2k->m_cp);\n        l_tcp = &l_cp->tcps[p_tile_no];\n        l_tccp = &l_tcp->tccps[p_comp_no];\n        if (nb_comps <= 256) {\n                l_comp_room = 1;\n        }\n        else {\n                l_comp_room = 2;\n        }\n        l_rgn_size = 6 + l_comp_room;\n        l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n        opj_write_bytes(l_current_data,J2K_MS_RGN,2);                                   \n        l_current_data += 2;\n        opj_write_bytes(l_current_data,l_rgn_size-2,2);                                 \n        l_current_data += 2;\n        opj_write_bytes(l_current_data,p_comp_no,l_comp_room);                          \n        l_current_data+=l_comp_room;\n        opj_write_bytes(l_current_data, 0,1);                                           \n        ++l_current_data;\n        opj_write_bytes(l_current_data, (OPJ_UINT32)l_tccp->roishift,1);                            \n        ++l_current_data;\n        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_rgn_size,p_manager) != l_rgn_size) {\n                return OPJ_FALSE;\n        }\n        return OPJ_TRUE;\n}", "target": 0}
{"code": "int blkcg_init_queue(struct request_queue *q)\n{\n\tstruct blkcg_gq *new_blkg, *blkg;\n\tbool preloaded;\n\tint ret;\n\tnew_blkg = blkg_alloc(&blkcg_root, q, GFP_KERNEL);\n\tif (!new_blkg)\n\t\treturn -ENOMEM;\n\tpreloaded = !radix_tree_preload(GFP_KERNEL);\n\trcu_read_lock();\n\tspin_lock_irq(q->queue_lock);\n\tblkg = blkg_create(&blkcg_root, q, new_blkg);\n\tspin_unlock_irq(q->queue_lock);\n\trcu_read_unlock();\n\tif (preloaded)\n\t\tradix_tree_preload_end();\n\tif (IS_ERR(blkg)) {\n\t\tblkg_free(new_blkg);\n\t\treturn PTR_ERR(blkg);\n\t}\n\tq->root_blkg = blkg;\n\tq->root_rl.blkg = blkg;\n\tret = blk_throtl_init(q);\n\tif (ret) {\n\t\tspin_lock_irq(q->queue_lock);\n\t\tblkg_destroy_all(q);\n\t\tspin_unlock_irq(q->queue_lock);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "xfs_file_splice_write(\n\tstruct pipe_inode_info\t*pipe,\n\tstruct file\t\t*outfilp,\n\tloff_t\t\t\t*ppos,\n\tsize_t\t\t\tcount,\n\tunsigned int\t\tflags)\n{\n\tstruct inode\t\t*inode = outfilp->f_mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tint\t\t\tioflags = 0;\n\tssize_t\t\t\tret;\n\tXFS_STATS_INC(xs_write_calls);\n\tif (outfilp->f_mode & FMODE_NOCMTIME)\n\t\tioflags |= IO_INVIS;\n\tif (XFS_FORCED_SHUTDOWN(ip->i_mount))\n\t\treturn -EIO;\n\txfs_ilock(ip, XFS_IOLOCK_EXCL);\n\ttrace_xfs_file_splice_write(ip, count, *ppos, ioflags);\n\tret = generic_file_splice_write(pipe, outfilp, ppos, count, flags);\n\tif (ret > 0)\n\t\tXFS_STATS_ADD(xs_write_bytes, ret);\n\txfs_iunlock(ip, XFS_IOLOCK_EXCL);\n\treturn ret;\n}", "target": 1}
{"code": "static int netsnmp_session_gen_sec_key(struct snmp_session *s, char *pass)\n{\n\tint snmp_errno;\n\ts->securityPrivKeyLen = USM_PRIV_KU_LEN;\n\tif ((snmp_errno = generate_Ku(s->securityAuthProto, s->securityAuthProtoLen,\n\t\t\t(u_char *)pass, strlen(pass),\n\t\t\ts->securityPrivKey, &(s->securityPrivKeyLen)))) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Error generating a key for privacy pass phrase '%s': %s\", pass, snmp_api_errstring(snmp_errno));\n\t\treturn (-2);\n\t}\n\treturn (0);\n}", "target": 0}
{"code": "HMAC_SHA256_Update(struct HMAC_SHA256_CTX * ctx, const void *in, size_t len)\n{\n  scrypt_SHA256_Update(&ctx->ictx, in, len);\n}", "target": 1}
{"code": "compile_lock_unlock(\n    lval_T  *lvp,\n    char_u  *name_end,\n    exarg_T *eap,\n    int\t    deep,\n    void    *coookie)\n{\n    cctx_T\t*cctx = coookie;\n    int\t\tcc = *name_end;\n    char_u\t*p = lvp->ll_name;\n    int\t\tret = OK;\n    size_t\tlen;\n    char_u\t*buf;\n    isntype_T\tisn = ISN_EXEC;\n    if (cctx->ctx_skip == SKIP_YES)\n\treturn OK;\n    if (p[1] != ':')\n    {\n\tchar_u *end = find_name_end(p, NULL, NULL, FNE_CHECK_START);\n\tif (lookup_local(p, end - p, NULL, cctx) == OK)\n\t{\n\t    char_u *s = p;\n\t    if (*end != '.' && *end != '[')\n\t    {\n\t\temsg(_(e_cannot_lock_unlock_local_variable));\n\t\treturn FAIL;\n\t    }\n\t    if (compile_load(&s, end, cctx, FALSE, FALSE) == FAIL)\n\t\treturn FAIL;\n\t    isn = ISN_LOCKUNLOCK;\n\t}\n    }\n    *name_end = NUL;\n    len = name_end - p + 20;\n    buf = alloc(len);\n    if (buf == NULL)\n\tret = FAIL;\n    else\n    {\n\tchar *cmd = eap->cmdidx == CMD_lockvar ? \"lockvar\" : \"unlockvar\";\n\tif (deep < 0)\n\t    vim_snprintf((char *)buf, len, \"%s! %s\", cmd, p);\n\telse\n\t    vim_snprintf((char *)buf, len, \"%s %d %s\", cmd, deep, p);\n\tret = generate_EXEC_copy(cctx, isn, buf);\n\tvim_free(buf);\n\t*name_end = cc;\n    }\n    return ret;\n}", "target": 1}
{"code": "static int cens_scheme_decrypt(MOVContext *c, MOVStreamContext *sc, AVEncryptionInfo *sample, uint8_t *input, int size)\n{\n    int i, ret, rem_bytes;\n    uint8_t *data;\n    if (!sc->cenc.aes_ctr) {\n        sc->cenc.aes_ctr = av_aes_ctr_alloc();\n        if (!sc->cenc.aes_ctr) {\n            return AVERROR(ENOMEM);\n        }\n        ret = av_aes_ctr_init(sc->cenc.aes_ctr, c->decryption_key);\n        if (ret < 0) {\n            return ret;\n        }\n    }\n    av_aes_ctr_set_full_iv(sc->cenc.aes_ctr, sample->iv);\n    if (!sample->subsample_count) {\n        av_aes_ctr_crypt(sc->cenc.aes_ctr, input, input, size);\n        return 0;\n    } else if (!sample->crypt_byte_block && !sample->skip_byte_block) {\n        av_log(c->fc, AV_LOG_ERROR, \"pattern encryption is not present in 'cens' scheme\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    for (i = 0; i < sample->subsample_count; i++) {\n        if (sample->subsamples[i].bytes_of_clear_data + sample->subsamples[i].bytes_of_protected_data > size) {\n            av_log(c->fc, AV_LOG_ERROR, \"subsample size exceeds the packet size left\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        input += sample->subsamples[i].bytes_of_clear_data;\n        size -= sample->subsamples[i].bytes_of_clear_data;\n        data = input;\n        rem_bytes = sample->subsamples[i].bytes_of_protected_data;\n        while (rem_bytes > 0) {\n            if (rem_bytes < 16*sample->crypt_byte_block) {\n                break;\n            }\n            av_aes_ctr_crypt(sc->cenc.aes_ctr, data, data, 16*sample->crypt_byte_block);\n            data += 16*sample->crypt_byte_block;\n            rem_bytes -= 16*sample->crypt_byte_block;\n            data += FFMIN(16*sample->skip_byte_block, rem_bytes);\n            rem_bytes -= FFMIN(16*sample->skip_byte_block, rem_bytes);\n        }\n        input += sample->subsamples[i].bytes_of_protected_data;\n        size -= sample->subsamples[i].bytes_of_protected_data;\n    }\n    if (size > 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"leftover packet bytes after subsample processing\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    return 0;\n}", "target": 0}
{"code": "vhost_user_check_and_alloc_queue_pair(struct virtio_net *dev, VhostUserMsg *msg)\n{\n\tuint16_t vring_idx;\n\tswitch (msg->request.master) {\n\tcase VHOST_USER_SET_VRING_KICK:\n\tcase VHOST_USER_SET_VRING_CALL:\n\tcase VHOST_USER_SET_VRING_ERR:\n\t\tvring_idx = msg->payload.u64 & VHOST_USER_VRING_IDX_MASK;\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_NUM:\n\tcase VHOST_USER_SET_VRING_BASE:\n\tcase VHOST_USER_SET_VRING_ENABLE:\n\t\tvring_idx = msg->payload.state.index;\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_ADDR:\n\t\tvring_idx = msg->payload.addr.index;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tif (vring_idx >= VHOST_MAX_VRING) {\n\t\tRTE_LOG(ERR, VHOST_CONFIG,\n\t\t\t\"invalid vring index: %u\\n\", vring_idx);\n\t\treturn -1;\n\t}\n\tif (dev->virtqueue[vring_idx])\n\t\treturn 0;\n\treturn alloc_vring_queue(dev, vring_idx);\n}", "target": 0}
{"code": "static int acl_parse_ver(const char **text, struct acl_pattern *pattern, int *opaque)\n{\n\tpattern->ptr.str = strdup(*text);\n\tif (!pattern->ptr.str)\n\t\treturn 0;\n\tpattern->len = strlen(*text);\n\treturn 1;\n}", "target": 0}
{"code": "static struct btrfs_device *find_device(struct btrfs_fs_devices *fs_devices,\n\t\tu64 devid, const u8 *uuid)\n{\n\tstruct btrfs_device *dev;\n\tlist_for_each_entry(dev, &fs_devices->devices, dev_list) {\n\t\tif (dev->devid == devid &&\n\t\t    (!uuid || !memcmp(dev->uuid, uuid, BTRFS_UUID_SIZE))) {\n\t\t\treturn dev;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "static gboolean printable_str(const char *str)\n{\n    do {\n        if ((unsigned char)(*str) < ' ' || *str == 0x7f)\n            return FALSE;\n        str++;\n    } while (*str);\n    return TRUE;\n}", "target": 1}
{"code": "void cred_to_ucred(struct pid *pid, const struct cred *cred,\n\t\t   struct ucred *ucred)\n{\n\tucred->pid = pid_vnr(pid);\n\tucred->uid = ucred->gid = -1;\n\tif (cred) {\n\t\tstruct user_namespace *current_ns = current_user_ns();\n\t\tucred->uid = from_kuid(current_ns, cred->euid);\n\t\tucred->gid = from_kgid(current_ns, cred->egid);\n\t}\n}", "target": 0}
{"code": "static void __exit exit_ext2_fs(void)\n{\n\tunregister_filesystem(&ext2_fs_type);\n\tdestroy_inodecache();\n\texit_ext2_xattr();\n}", "target": 1}
{"code": "Adaptation::Ecap::FirstLineRep::protocol() const\n{\n    switch (theMessage.http_ver.protocol) {\n    case AnyP::PROTO_HTTP:\n        return libecap::protocolHttp;\n    case AnyP::PROTO_HTTPS:\n        return libecap::protocolHttps;\n    case AnyP::PROTO_FTP:\n        return libecap::protocolFtp;\n    case AnyP::PROTO_GOPHER:\n        return libecap::protocolGopher;\n    case AnyP::PROTO_WAIS:\n        return libecap::protocolWais;\n    case AnyP::PROTO_WHOIS:\n        return libecap::protocolWhois;\n    case AnyP::PROTO_URN:\n        return libecap::protocolUrn;\n    case AnyP::PROTO_ICP:\n        return protocolIcp;\n#if USE_HTCP\n    case AnyP::PROTO_HTCP:\n        return protocolHtcp;\n#endif\n    case AnyP::PROTO_CACHE_OBJECT:\n        return protocolCacheObj;\n    case AnyP::PROTO_ICY:\n        return protocolIcy;\n    case AnyP::PROTO_COAP:\n    case AnyP::PROTO_COAPS: \n    case AnyP::PROTO_AUTHORITY_FORM:\n    case AnyP::PROTO_SSL:\n    case AnyP::PROTO_TLS:\n    case AnyP::PROTO_UNKNOWN:\n        return protocolUnknown; \n    case AnyP::PROTO_NONE:\n        return Name();\n    case AnyP::PROTO_MAX:\n        break; \n    }\n    Must(false); \n    return Name();\n}", "target": 1}
{"code": "static int find_uid(struct posix_acl_state *state, struct posix_ace_state_array *a, uid_t uid)\n{\n\tint i;\n\tfor (i = 0; i < a->n; i++)\n\t\tif (a->aces[i].uid == uid)\n\t\t\treturn i;\n\ta->n++;\n\ta->aces[i].uid = uid;\n\ta->aces[i].perms.allow = state->everyone.allow;\n\ta->aces[i].perms.deny  = state->everyone.deny;\n\treturn i;\n}", "target": 0}
{"code": "mm_sync_list(struct mmtree *oldtree, struct mmtree *newtree,\n    struct mm_master *mm, struct mm_master *mmold)\n{\n\tstruct mm_master *mmalloc = mm->mmalloc;\n\tstruct mm_share *mms, *new;\n\tRB_FOREACH(mms, mmtree, oldtree) {\n\t\tmm_memvalid(mmold, mms, sizeof(struct mm_share));\n\t\tmm_memvalid(mm, mms->address, mms->size);\n\t\tnew = mm_xmalloc(mmalloc, sizeof(struct mm_share));\n\t\tmemcpy(new, mms, sizeof(struct mm_share));\n\t\tRB_INSERT(mmtree, newtree, new);\n\t}\n}", "target": 1}
{"code": "int http_skip_chunk_crlf(struct buffer *buf, struct http_msg *msg)\n{\n\tchar *ptr;\n\tint bytes;\n\tbytes = 1;\n\tptr = buf->lr;\n\tif (*ptr == '\\r') {\n\t\tbytes++;\n\t\tptr++;\n\t\tif (ptr >= buf->data + buf->size)\n\t\t\tptr = buf->data;\n\t}\n\tif (bytes > buf->l - buf->send_max)\n\t\treturn 0;\n\tif (*ptr != '\\n') {\n\t\tmsg->err_pos = ptr - buf->data;\n\t\treturn -1;\n\t}\n\tptr++;\n\tif (ptr >= buf->data + buf->size)\n\t\tptr = buf->data;\n\tbuf->lr = ptr;\n\tmsg->sov = ptr - buf->data;\n\tmsg->som = msg->sov - bytes;\n\tmsg->msg_state = HTTP_MSG_CHUNK_SIZE;\n\treturn 1;\n}", "target": 0}
{"code": "int fscrypt_get_encryption_info(struct inode *inode)\n{\n\tstruct fscrypt_info *ci = inode->i_crypt_info;\n\tif (!ci ||\n\t\t(ci->ci_keyring_key &&\n\t\t (ci->ci_keyring_key->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t\t\t       (1 << KEY_FLAG_REVOKED) |\n\t\t\t\t\t       (1 << KEY_FLAG_DEAD)))))\n\t\treturn fscrypt_get_crypt_info(inode);\n\treturn 0;\n}", "target": 1}
{"code": "void my_error_exit( j_common_ptr cinfo ) {\n   my_error_ptr myerr = reinterpret_cast<my_error_ptr>(cinfo->err);\n   longjmp( myerr->setjmp_buffer, 1 );\n}", "target": 1}
{"code": "static inline void get_page(struct page *page)\n{\n\tpage = compound_head(page);\n\tVM_BUG_ON_PAGE(page_ref_count(page) <= 0, page);\n\tpage_ref_inc(page);\n}", "target": 1}
{"code": "static int asn1_d2i_ex_primitive(ASN1_VALUE **pval,\n static int asn1_template_ex_d2i(ASN1_VALUE **pval,\n                                 const unsigned char **in, long len,\n                                 const ASN1_TEMPLATE *tt, char opt,\n                                ASN1_TLC *ctx);\n static int asn1_template_noexp_d2i(ASN1_VALUE **val,\n                                    const unsigned char **in, long len,\n                                    const ASN1_TEMPLATE *tt, char opt,\n                                   ASN1_TLC *ctx);\n static int asn1_d2i_ex_primitive(ASN1_VALUE **pval,\n                                  const unsigned char **in, long len,\n                                  const ASN1_ITEM *it,\n    B_ASN1_OCTET_STRING, 0, 0, B_ASN1_UNKNOWN,\n    B_ASN1_UNKNOWN, B_ASN1_UNKNOWN, B_ASN1_UNKNOWN, B_ASN1_UNKNOWN,\n    B_ASN1_UTF8STRING, B_ASN1_UNKNOWN, B_ASN1_UNKNOWN, B_ASN1_UNKNOWN,\n    B_ASN1_SEQUENCE, 0, B_ASN1_NUMERICSTRING, B_ASN1_PRINTABLESTRING,\n    B_ASN1_T61STRING, B_ASN1_VIDEOTEXSTRING, B_ASN1_IA5STRING,\n    B_ASN1_UTCTIME, B_ASN1_GENERALIZEDTIME,\n    B_ASN1_GRAPHICSTRING, B_ASN1_ISO64STRING, B_ASN1_GENERALSTRING,\n    B_ASN1_UNIVERSALSTRING, B_ASN1_UNKNOWN, B_ASN1_BMPSTRING, B_ASN1_UNKNOWN,\n};\nunsigned long ASN1_tag2bit(int tag)\n{", "target": 1}
{"code": "int ossl_dsa_check_pairwise(const DSA *dsa)\n{\n    int ret = 0;\n    BN_CTX *ctx = NULL;\n    BIGNUM *pub_key = NULL;\n    if (dsa->params.p == NULL\n        || dsa->params.g == NULL\n        || dsa->priv_key == NULL\n        || dsa->pub_key == NULL)\n        return 0;\n    ctx = BN_CTX_new_ex(dsa->libctx);\n    if (ctx == NULL)\n        goto err;\n    pub_key = BN_new();\n    if (pub_key == NULL)\n        goto err;\n    if (!ossl_dsa_generate_public_key(ctx, dsa, dsa->priv_key, pub_key))\n        goto err;\n    ret = BN_cmp(pub_key, dsa->pub_key) == 0;\nerr:\n    BN_free(pub_key);\n    BN_CTX_free(ctx);\n    return ret;\n}", "target": 1}
{"code": "input_parse(struct window_pane *wp)\n{\n\tstruct input_ctx\t\t*ictx = wp->ictx;\n\tconst struct input_transition\t*itr;\n\tstruct evbuffer\t\t\t*evb = wp->event->input;\n\tu_char\t\t\t\t*buf;\n\tsize_t\t\t\t\t len, off;\n\tif (EVBUFFER_LENGTH(evb) == 0)\n\t\treturn;\n\twp->window->flags |= WINDOW_ACTIVITY;\n\twp->window->flags &= ~WINDOW_SILENCE;\n\tif (gettimeofday(&wp->window->activity_time, NULL) != 0)\n\t\tfatal(\"gettimeofday failed\");\n\tif (wp->mode == NULL)\n\t\tscreen_write_start(&ictx->ctx, wp, &wp->base);\n\telse\n\t\tscreen_write_start(&ictx->ctx, NULL, &wp->base);\n\tictx->wp = wp;\n\tbuf = EVBUFFER_DATA(evb);\n\tlen = EVBUFFER_LENGTH(evb);\n\tnotify_input(wp, evb);\n\toff = 0;\n\twhile (off < len) {\n\t\tictx->ch = buf[off++];\n\t\tlog_debug(\"%s: '%c' %s\", __func__, ictx->ch, ictx->state->name);\n\t\titr = ictx->state->transitions;\n\t\twhile (itr->first != -1 && itr->last != -1) {\n\t\t\tif (ictx->ch >= itr->first && ictx->ch <= itr->last)\n\t\t\t\tbreak;\n\t\t\titr++;\n\t\t}\n\t\tif (itr->first == -1 || itr->last == -1) {\n\t\t\tfatalx(\"No transition from state!\");\n\t\t}\n\t\tif (itr->handler != NULL && itr->handler(ictx) != 0)\n\t\t\tcontinue;\n\t\tif (itr->state != NULL)\n\t\t\tinput_set_state(wp, itr);\n\t\tif (ictx->state != &input_state_ground)\n\t\t\tevbuffer_add(ictx->since_ground, &ictx->ch, 1);\n\t}\n\tscreen_write_stop(&ictx->ctx);\n\tevbuffer_drain(evb, len);\n}", "target": 0}
{"code": "uip_nd6_init()\n{\n#if UIP_ND6_SEND_NA\n  uip_icmp6_register_input_handler(&ns_input_handler);\n#endif\n#if UIP_ND6_SEND_NS\n  uip_icmp6_register_input_handler(&na_input_handler);\n#endif\n#if UIP_CONF_ROUTER && UIP_ND6_SEND_RA\n  uip_icmp6_register_input_handler(&rs_input_handler);\n#endif\n#if !UIP_CONF_ROUTER\n  uip_icmp6_register_input_handler(&ra_input_handler);\n#endif\n}", "target": 0}
{"code": "void free_key_material(key_material_t* pkey)\n{\n\tint i;\n\tif (!pkey)\n\t{\n\t\treturn;\n\t}\n\tfor (i = 0; i < TAG_MAX; i++)\n\t{\n\t\tif (pkey[i].big)\n\t\t{\n\t\t\tfree(pkey[i].big);\n\t\t}\n\t}\n}", "target": 0}
{"code": "GF_EXPORT\nGF_Err gf_isom_box_write(GF_Box *a, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu64 pos = gf_bs_get_position(bs);\n\tif (!a) return GF_BAD_PARAM;\n\tif (!a->size) return GF_OK;\n\tif (a->registry->disabled) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box %s disabled registry, skip write\\n\", gf_4cc_to_str(a->type)));\n\t\treturn GF_OK;\n\t}\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box %s size %d write\\n\", gf_4cc_to_str(a->type), a->size));\n\te = gf_isom_box_write_listing(a, bs);\n\tif (e) return e;\n\tif (a->child_boxes) {\n\t\te = gf_isom_box_array_write(a, a->child_boxes, bs);\n\t}\n\tpos = gf_bs_get_position(bs) - pos;\n\tif (pos != a->size) {\n\t\tif (a->type != GF_ISOM_BOX_TYPE_MDAT) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box %s wrote \"LLU\" bytes but size is \"LLU\"\\n\", gf_4cc_to_str(a->type), pos, a->size ));\n\t\t}\n\t}\n\treturn e;", "target": 1}
{"code": "static int pptp_getname(struct socket *sock, struct sockaddr *uaddr,\n\tint *usockaddr_len, int peer)\n{\n\tint len = sizeof(struct sockaddr_pppox);\n\tstruct sockaddr_pppox sp;\n\tmemset(&sp.sa_addr, 0, sizeof(sp.sa_addr));\n\tsp.sa_family    = AF_PPPOX;\n\tsp.sa_protocol  = PX_PROTO_PPTP;\n\tsp.sa_addr.pptp = pppox_sk(sock->sk)->proto.pptp.src_addr;\n\tmemcpy(uaddr, &sp, len);\n\t*usockaddr_len = len;\n\treturn 0;\n}", "target": 0}
{"code": "static void rekey_seq_generator(struct work_struct *work)\n{\n\tstruct keydata *keyptr = &ip_keydata[1 ^ (ip_cnt & 1)];\n\tget_random_bytes(keyptr->secret, sizeof(keyptr->secret));\n\tkeyptr->count = (ip_cnt & COUNT_MASK) << HASH_BITS;\n\tsmp_wmb();\n\tip_cnt++;\n\tschedule_delayed_work(&rekey_work,\n\t\t\t      round_jiffies_relative(REKEY_INTERVAL));\n}", "target": 1}
{"code": "  template<typename T>\n  inline CImg<_cimg_Tfloat> tanh(const CImg<T>& instance) {\n    return instance.get_tanh();", "target": 0}
{"code": "STATIC void\nS_dump_regex_sets_structures(pTHX_ RExC_state_t *pRExC_state,\n                             AV * stack, const IV fence, AV * fence_stack)\n{   \n    const SSize_t stack_top = av_tindex_skip_len_mg(stack);\n    const SSize_t fence_stack_top = av_tindex_skip_len_mg(fence_stack);\n    SSize_t i;\n    PERL_ARGS_ASSERT_DUMP_REGEX_SETS_STRUCTURES;\n    PerlIO_printf(Perl_debug_log, \"\\nParse position is:%s\\n\", RExC_parse);\n    if (stack_top < 0) {\n        PerlIO_printf(Perl_debug_log, \"Nothing on stack\\n\");\n    }\n    else {\n        PerlIO_printf(Perl_debug_log, \"Stack: (fence=%d)\\n\", (int) fence);\n        for (i = stack_top; i >= 0; i--) {\n            SV ** element_ptr = av_fetch(stack, i, FALSE);\n            if (! element_ptr) {\n            }\n            if (IS_OPERATOR(*element_ptr)) {\n                PerlIO_printf(Perl_debug_log, \"[%d]: %c\\n\",\n                                            (int) i, (int) SvIV(*element_ptr));\n            }\n            else {\n                PerlIO_printf(Perl_debug_log, \"[%d] \", (int) i);\n                sv_dump(*element_ptr);\n            }\n        }\n    }\n    if (fence_stack_top < 0) {\n        PerlIO_printf(Perl_debug_log, \"Nothing on fence_stack\\n\");\n    }\n    else {\n        PerlIO_printf(Perl_debug_log, \"Fence_stack: \\n\");\n        for (i = fence_stack_top; i >= 0; i--) {\n            SV ** element_ptr = av_fetch(fence_stack, i, FALSE);\n            if (! element_ptr) {\n            }\n            PerlIO_printf(Perl_debug_log, \"[%d]: %d\\n\",\n                                            (int) i, (int) SvIV(*element_ptr));\n        }\n    }", "target": 0}
{"code": "static CustomStreamInfo *TIFFAcquireCustomStreamForWriting(\n  PhotoshopProfile *profile,ExceptionInfo *exception)\n{\n  CustomStreamInfo\n    *custom_stream;\n  custom_stream=AcquireCustomStreamInfo(exception);\n  if (custom_stream == (CustomStreamInfo *) NULL)\n    return(custom_stream);\n  SetCustomStreamData(custom_stream,(void *) profile);\n  SetCustomStreamWriter(custom_stream,TIFFWriteCustomStream);\n  SetCustomStreamSeeker(custom_stream,TIFFSeekCustomStream);\n  SetCustomStreamTeller(custom_stream,TIFFTellCustomStream);\n  return(custom_stream);\n}", "target": 0}
{"code": "unescape_single_char (char *str, char chr)\n{\n  const char c1 = XNUM_TO_DIGIT (chr >> 4);\n  const char c2 = XNUM_TO_DIGIT (chr & 0xf);\n  char *h = str;                \n  char *t = str;                \n  for (; *h; h++, t++)\n    {\n      if (h[0] == '%' && h[1] == c1 && h[2] == c2)\n        {\n          *t = chr;\n          h += 2;\n        }\n      else\n        *t = *h;\n    }\n  *t = '\\0';\n}", "target": 0}
{"code": "static inline void snow_set_blocks(SnowContext *s, int level, int x, int y, int l, int cb, int cr, int mx, int my, int ref, int type){\n    const int w= s->b_width << s->block_max_depth;\n    const int rem_depth= s->block_max_depth - level;\n    const int index= (x + y*w) << rem_depth;\n    const int block_w= 1<<rem_depth;\n    BlockNode block;\n    int i,j;\n    block.color[0]= l;\n    block.color[1]= cb;\n    block.color[2]= cr;\n    block.mx= mx;\n    block.my= my;\n    block.ref= ref;\n    block.type= type;\n    block.level= level;\n    for(j=0; j<block_w; j++){\n        for(i=0; i<block_w; i++){\n            s->block[index + i + j*w]= block;\n        }\n    }\n}", "target": 0}
{"code": "static int __init xfrm6_tunnel_spi_init(void)\n{\n\txfrm6_tunnel_spi_kmem = kmem_cache_create(\"xfrm6_tunnel_spi\",\n\t\t\t\t\t\t  sizeof(struct xfrm6_tunnel_spi),\n\t\t\t\t\t\t  0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t\t  NULL);\n\tif (!xfrm6_tunnel_spi_kmem)\n\t\treturn -ENOMEM;\n\treturn 0;\n}", "target": 1}
{"code": "polkit_system_bus_name_get_creds_sync (PolkitSystemBusName           *system_bus_name,\n\t\t\t\t       guint32                       *out_uid,\n\t\t\t\t       guint32                       *out_pid,\n\t\t\t\t       GCancellable                  *cancellable,\n\t\t\t\t       GError                       **error)\n{\n  gboolean ret = FALSE;\n  AsyncGetBusNameCredsData data = { 0, };\n  GDBusConnection *connection = NULL;\n  GMainContext *tmp_context = NULL;\n  connection = g_bus_get_sync (G_BUS_TYPE_SYSTEM, cancellable, error);\n  if (connection == NULL)\n    goto out;\n  data.error = error;\n  tmp_context = g_main_context_new ();\n  g_main_context_push_thread_default (tmp_context);\n  g_dbus_connection_call (connection,\n\t\t\t  \"org.freedesktop.DBus\",       \n\t\t\t  \"/org/freedesktop/DBus\",      \n\t\t\t  \"org.freedesktop.DBus\",       \n\t\t\t  \"GetConnectionUnixUser\",      \n\t\t\t  g_variant_new (\"(s)\", system_bus_name->name),\n\t\t\t  G_VARIANT_TYPE (\"(u)\"),\n\t\t\t  G_DBUS_CALL_FLAGS_NONE,\n\t\t\t  -1,\n\t\t\t  cancellable,\n\t\t\t  on_retrieved_unix_uid_pid,\n\t\t\t  &data);\n  g_dbus_connection_call (connection,\n\t\t\t  \"org.freedesktop.DBus\",       \n\t\t\t  \"/org/freedesktop/DBus\",      \n\t\t\t  \"org.freedesktop.DBus\",       \n\t\t\t  \"GetConnectionUnixProcessID\", \n\t\t\t  g_variant_new (\"(s)\", system_bus_name->name),\n\t\t\t  G_VARIANT_TYPE (\"(u)\"),\n\t\t\t  G_DBUS_CALL_FLAGS_NONE,\n\t\t\t  -1,\n\t\t\t  cancellable,\n\t\t\t  on_retrieved_unix_uid_pid,\n\t\t\t  &data);\n  while (!((data.retrieved_uid && data.retrieved_pid) || data.caught_error))\n    g_main_context_iteration (tmp_context, TRUE);\n  if (out_uid)\n    *out_uid = data.uid;\n  if (out_pid)\n    *out_pid = data.pid;\n  ret = TRUE;\n out:\n  if (tmp_context)\n    {\n      g_main_context_pop_thread_default (tmp_context);\n      g_main_context_unref (tmp_context);\n    }\n  if (connection != NULL)\n    g_object_unref (connection);\n  return ret;\n}", "target": 1}
{"code": "static struct mobj *alloc_ta_mem(size_t size)\n{\n#ifdef CFG_PAGED_USER_TA\n\treturn mobj_paged_alloc(size);\n#else\n\tstruct mobj *mobj = mobj_mm_alloc(mobj_sec_ddr, size, &tee_mm_sec_ddr);\n\tif (mobj)\n\t\tmemset(mobj_get_va(mobj, 0), 0, size);\n\treturn mobj;\n#endif\n}", "target": 1}
{"code": "k5_asn1_full_decode(const krb5_data *code, const struct atype_info *a,\n                    void **retrep)\n{\n    krb5_error_code ret;\n    const uint8_t *contents, *remainder;\n    size_t clen, rlen;\n    taginfo t;\n    *retrep = NULL;\n    ret = get_tag((uint8_t *)code->data, code->length, &t, &contents,\n                  &clen, &remainder, &rlen);\n    if (ret)\n        return ret;\n    if (!check_atype_tag(a, &t))\n        return ASN1_BAD_ID;\n    return decode_atype_to_ptr(&t, contents, clen, a, retrep);\n}", "target": 1}
{"code": "RecordFlushReplyBuffer(RecordContextPtr pContext,\n                       void *data1, int len1, void *data2, int len2)\n{\n    if (!pContext->pRecordingClient || pContext->pRecordingClient->clientGone ||\n        pContext->inFlush)\n        return;\n    ++pContext->inFlush;\n    if (pContext->numBufBytes)\n        WriteToClient(pContext->pRecordingClient, pContext->numBufBytes,\n                      pContext->replyBuffer);\n    pContext->numBufBytes = 0;\n    if (len1)\n        WriteToClient(pContext->pRecordingClient, len1, data1);\n    if (len2)\n        WriteToClient(pContext->pRecordingClient, len2, data2);\n    --pContext->inFlush;\n}                               ", "target": 0}
{"code": "static int elf_dump_thread_status(long signr, struct elf_thread_status *t)\n{\n\tint sz = 0;\n\tstruct task_struct *p = t->thread;\n\tt->num_notes = 0;\n\tfill_prstatus(&t->prstatus, p, signr);\n\telf_core_copy_task_regs(p, &t->prstatus.pr_reg);\t\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS, sizeof(t->prstatus),\n\t\t  &(t->prstatus));\n\tt->num_notes++;\n\tsz += notesize(&t->notes[0]);\n\tif ((t->prstatus.pr_fpvalid = elf_core_copy_task_fpregs(p, NULL,\n\t\t\t\t\t\t\t\t&t->fpu))) {\n\t\tfill_note(&t->notes[1], \"CORE\", NT_PRFPREG, sizeof(t->fpu),\n\t\t\t  &(t->fpu));\n\t\tt->num_notes++;\n\t\tsz += notesize(&t->notes[1]);\n\t}\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(p, &t->xfpu)) {\n\t\tfill_note(&t->notes[2], \"LINUX\", NT_PRXFPREG, sizeof(t->xfpu),\n\t\t\t  &t->xfpu);\n\t\tt->num_notes++;\n\t\tsz += notesize(&t->notes[2]);\n\t}\n#endif\t\n\treturn sz;\n}", "target": 0}
{"code": "bool Item_param::set_from_user_var(THD *thd, const user_var_entry *entry)\n{\n  DBUG_ENTER(\"Item_param::set_from_user_var\");\n  if (entry && entry->value)\n  {\n    item_result_type= entry->type;\n    unsigned_flag= entry->unsigned_flag;\n    if (limit_clause_param)\n    {\n      bool unused;\n      set_int(entry->val_int(&unused), MY_INT64_NUM_DECIMAL_DIGITS);\n      item_type= Item::INT_ITEM;\n      DBUG_RETURN(!unsigned_flag && value.integer < 0 ? 1 : 0);\n    }\n    switch (item_result_type) {\n    case REAL_RESULT:\n      set_double(*(double*)entry->value);\n      item_type= Item::REAL_ITEM;\n      param_type= MYSQL_TYPE_DOUBLE;\n      break;\n    case INT_RESULT:\n      set_int(*(longlong*)entry->value, MY_INT64_NUM_DECIMAL_DIGITS);\n      item_type= Item::INT_ITEM;\n      param_type= MYSQL_TYPE_LONGLONG;\n      break;\n    case STRING_RESULT:\n    {\n      CHARSET_INFO *fromcs= entry->collation.collation;\n      CHARSET_INFO *tocs= thd->variables.collation_connection;\n      uint32 dummy_offset;\n      value.cs_info.character_set_of_placeholder= fromcs;\n      value.cs_info.character_set_client= thd->variables.character_set_client;\n      value.cs_info.final_character_set_of_str_value=\n        String::needs_conversion(0, fromcs, tocs, &dummy_offset) ?\n        tocs : fromcs;\n      item_type= Item::STRING_ITEM;\n      param_type= MYSQL_TYPE_VARCHAR;\n      if (set_str((const char *)entry->value, entry->length))\n        DBUG_RETURN(1);\n      break;\n    }\n    case DECIMAL_RESULT:\n    {\n      const my_decimal *ent_value= (const my_decimal *)entry->value;\n      my_decimal2decimal(ent_value, &decimal_value);\n      state= DECIMAL_VALUE;\n      decimals= ent_value->frac;\n      max_length=\n        my_decimal_precision_to_length_no_truncation(ent_value->precision(),\n                                                     decimals, unsigned_flag);\n      item_type= Item::DECIMAL_ITEM;\n      param_type= MYSQL_TYPE_NEWDECIMAL;\n      break;\n    }\n    case ROW_RESULT:\n    case TIME_RESULT:\n    case IMPOSSIBLE_RESULT:\n      DBUG_ASSERT(0);\n      set_null();\n    }\n  }\n  else\n    set_null();\n  DBUG_RETURN(0);\n}", "target": 0}
{"code": "is_valid_mbc_string(const UChar* p, const UChar* end)\n{\n  const UChar* end1 = end - 1;\n  while (p < end1) {\n    p += utf16le_mbc_enc_len(p);\n  }\n  if (p != end)\n    return FALSE;\n  else\n    return TRUE;\n}", "target": 0}
{"code": "  Status CalculateOutputIndex(OpKernelContext* context, int dimension,\n                              const vector<INDEX_TYPE>& parent_output_index,\n                              INDEX_TYPE output_index_multiplier,\n                              INDEX_TYPE output_size,\n                              vector<INDEX_TYPE>* result) {\n    const RowPartitionTensor row_partition_tensor =\n        GetRowPartitionTensor(context, dimension);\n    auto partition_type = GetRowPartitionTypeByDimension(dimension);\n    switch (partition_type) {\n      case RowPartitionType::VALUE_ROWIDS:\n        CalculateOutputIndexValueRowID(\n            context, row_partition_tensor, parent_output_index,\n            output_index_multiplier, output_size, result);\n        return tensorflow::Status::OK();\n      case RowPartitionType::ROW_SPLITS:\n        CalculateOutputIndexRowSplit(\n            context, row_partition_tensor, parent_output_index,\n            output_index_multiplier, output_size, result);\n        return tensorflow::Status::OK();\n      default:\n        return errors::InvalidArgument(\n            \"Unsupported partition type:\",\n            RowPartitionTypeToString(partition_type));\n    }\n  }", "target": 1}
{"code": "write_os2_header (j_decompress_ptr cinfo, bmp_dest_ptr dest)\n{\n  char bmpfileheader[14];\n  char bmpcoreheader[12];\n  long headersize, bfSize;\n  int bits_per_pixel, cmap_entries;\n  if (cinfo->out_color_space == JCS_RGB ||\n      (cinfo->out_color_space >= JCS_EXT_RGB &&\n       cinfo->out_color_space <= JCS_EXT_ARGB)) {\n    if (cinfo->quantize_colors) {\n      bits_per_pixel = 8;\n      cmap_entries = 256;\n    } else {\n      bits_per_pixel = 24;\n      cmap_entries = 0;\n    }\n  } else if (cinfo->out_color_space == JCS_RGB565 ||\n             cinfo->out_color_space == JCS_CMYK) {\n    bits_per_pixel = 24;\n    cmap_entries   = 0;\n  } else {\n    bits_per_pixel = 8;\n    cmap_entries = 256;\n  }\n  headersize = 14 + 12 + cmap_entries * 3; \n  bfSize = headersize + (long) dest->row_width * (long) cinfo->output_height;\n  MEMZERO(bmpfileheader, sizeof(bmpfileheader));\n  MEMZERO(bmpcoreheader, sizeof(bmpcoreheader));\n  bmpfileheader[0] = 0x42;      \n  bmpfileheader[1] = 0x4D;\n  PUT_4B(bmpfileheader, 2, bfSize); \n  PUT_4B(bmpfileheader, 10, headersize); \n  PUT_2B(bmpcoreheader, 0, 12); \n  PUT_2B(bmpcoreheader, 4, cinfo->output_width); \n  PUT_2B(bmpcoreheader, 6, cinfo->output_height); \n  PUT_2B(bmpcoreheader, 8, 1);  \n  PUT_2B(bmpcoreheader, 10, bits_per_pixel); \n  if (JFWRITE(dest->pub.output_file, bmpfileheader, 14) != (size_t) 14)\n    ERREXIT(cinfo, JERR_FILE_WRITE);\n  if (JFWRITE(dest->pub.output_file, bmpcoreheader, 12) != (size_t) 12)\n    ERREXIT(cinfo, JERR_FILE_WRITE);\n  if (cmap_entries > 0)\n    write_colormap(cinfo, dest, cmap_entries, 3);\n}", "target": 0}
{"code": "static void nfs4_xdr_enc_getacl(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\tstruct nfs_getaclargs *args)\n{\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\tuint32_t replen;\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\treplen = hdr.replen + op_decode_hdr_maxsz + 1;\n\tencode_getattr_two(xdr, FATTR4_WORD0_ACL, 0, &hdr);\n\txdr_inline_pages(&req->rq_rcv_buf, replen << 2,\n\t\targs->acl_pages, args->acl_pgbase, args->acl_len);\n\tencode_nops(&hdr);\n}", "target": 0}
{"code": "l2tp_bearer_cap_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint32_t *ptr = (const uint32_t *)dat;\n\tif (EXTRACT_32BITS(ptr) &  L2TP_BEARER_CAP_ANALOG_MASK) {\n\t\tND_PRINT((ndo, \"A\"));\n\t}\n\tif (EXTRACT_32BITS(ptr) &  L2TP_BEARER_CAP_DIGITAL_MASK) {\n\t\tND_PRINT((ndo, \"D\"));\n\t}\n}", "target": 1}
{"code": "user_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct passwd *pw, const struct member *m)\n{\n    const struct sudoers_context *ctx = parse_tree->ctx;\n    const char *lhost = parse_tree->lhost ? parse_tree->lhost : ctx->runas.host;\n    const char *shost = parse_tree->shost ? parse_tree->shost : ctx->runas.shost;\n    int matched = UNSPEC;\n    struct alias *a;\n    debug_decl(user_matches, SUDOERS_DEBUG_MATCH);\n    switch (m->type) {\n\tcase ALL:\n\t    matched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase NETGROUP:\n\t    if (netgr_matches(parse_tree->nss, m->name,\n\t\tdef_netgroup_tuple ? lhost : NULL,\n\t\tdef_netgroup_tuple ? shost : NULL, pw->pw_name))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase USERGROUP:\n\t    if (usergr_matches(m->name, pw->pw_name, pw))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase ALIAS:\n\t    if ((a = alias_get(parse_tree, m->name, USERALIAS)) != NULL) {\n\t\tconst int rc = userlist_matches(parse_tree, pw, &a->members);\n\t\tif (rc != UNSPEC) {\n\t\t    if (m->negated) {\n\t\t\tmatched = rc == ALLOW ? DENY : ALLOW;\n\t\t    } else {\n\t\t\tmatched = rc;\n\t\t    }\n\t\t}\n\t\talias_put(a);\n\t\tbreak;\n\t    }\n\t    FALLTHROUGH;\n\tcase WORD:\n\t    if (userpw_matches(m->name, pw->pw_name, pw))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n    }\n    debug_return_int(matched);\n}", "target": 1}
{"code": "v8::Local<v8::Object> CreateNativeEvent(\n    v8::Isolate* isolate,\n    v8::Local<v8::Object> sender,\n    content::RenderFrameHost* frame,\n    electron::mojom::ElectronBrowser::MessageSyncCallback callback) {\n  v8::Local<v8::Object> event;\n  if (frame && callback) {\n    gin::Handle<Event> native_event = Event::Create(isolate);\n    native_event->SetCallback(std::move(callback));\n    event = v8::Local<v8::Object>::Cast(native_event.ToV8());\n  } else {\n    event = CreateEvent(isolate);\n  }\n  Dictionary dict(isolate, event);\n  dict.Set(\"sender\", sender);\n  if (frame)\n    dict.Set(\"frameId\", frame->GetRoutingID());\n  return event;\n}", "target": 1}
{"code": "static void __exit pptp_exit_module(void)\n{\n\tunregister_pppox_proto(PX_PROTO_PPTP);\n\tproto_unregister(&pptp_sk_proto);\n\tgre_del_protocol(&gre_pptp_protocol, GREPROTO_PPTP);\n\tvfree(callid_sock);\n}", "target": 0}
{"code": "int snd_ctl_add(struct snd_card *card, struct snd_kcontrol *kcontrol)\n{\n\tstruct snd_ctl_elem_id id;\n\tunsigned int idx;\n\tunsigned int count;\n\tint err = -EINVAL;\n\tif (! kcontrol)\n\t\treturn err;\n\tif (snd_BUG_ON(!card || !kcontrol->info))\n\t\tgoto error;\n\tid = kcontrol->id;\n\tif (id.index > UINT_MAX - kcontrol->count)\n\t\tgoto error;\n\tdown_write(&card->controls_rwsem);\n\tif (snd_ctl_find_id(card, &id)) {\n\t\tup_write(&card->controls_rwsem);\n\t\tdev_err(card->dev, \"control %i:%i:%i:%s:%i is already present\\n\",\n\t\t\t\t\tid.iface,\n\t\t\t\t\tid.device,\n\t\t\t\t\tid.subdevice,\n\t\t\t\t\tid.name,\n\t\t\t\t\tid.index);\n\t\terr = -EBUSY;\n\t\tgoto error;\n\t}\n\tif (snd_ctl_find_hole(card, kcontrol->count) < 0) {\n\t\tup_write(&card->controls_rwsem);\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\tlist_add_tail(&kcontrol->list, &card->controls);\n\tcard->controls_count += kcontrol->count;\n\tkcontrol->id.numid = card->last_numid + 1;\n\tcard->last_numid += kcontrol->count;\n\tcount = kcontrol->count;\n\tup_write(&card->controls_rwsem);\n\tfor (idx = 0; idx < count; idx++, id.index++, id.numid++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_ADD, &id);\n\treturn 0;\n error:\n\tsnd_ctl_free_one(kcontrol);\n\treturn err;\n}", "target": 0}
{"code": "static uint32_t get_lease(struct dhcp_packet *packet, uint16_t packet_len)\n{\n\tuint8_t *option;\n\tuint32_t lease_seconds;\n\toption = dhcp_get_option(packet, packet_len, DHCP_LEASE_TIME);\n\tif (!option)\n\t\treturn 3600;\n\tlease_seconds = get_be32(option);\n\tif (lease_seconds < 10)\n\t\tlease_seconds = 10;\n\treturn lease_seconds;\n}", "target": 0}
{"code": "static GF_Err gf_isom_svc_mvc_config_del(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, Bool is_mvc)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return GF_BAD_PARAM;\n\tentry = (GF_MPEGVisualSampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\tif (!entry) return GF_BAD_PARAM;\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_AVC1:\n\tcase GF_ISOM_BOX_TYPE_AVC2:\n\tcase GF_ISOM_BOX_TYPE_AVC3:\n\tcase GF_ISOM_BOX_TYPE_AVC4:\n\tcase GF_ISOM_BOX_TYPE_SVC1:\n\tcase GF_ISOM_BOX_TYPE_MVC1:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\tif (is_mvc && entry->mvc_config) {\n\t\tgf_isom_box_del_parent(&entry->child_boxes, (GF_Box*)entry->mvc_config);\n\t\tentry->mvc_config = NULL;\n\t}\n\telse if (!is_mvc && entry->svc_config) {\n\t\tgf_isom_box_del_parent(&entry->child_boxes, (GF_Box*)entry->svc_config);\n\t\tentry->svc_config = NULL;\n\t}\n\tAVC_RewriteESDescriptor(entry);\n\treturn GF_OK;\n}", "target": 0}
{"code": "void InferenceContext::PreInputInit(\n    const OpDef& op_def, const std::vector<const Tensor*>& input_tensors,\n    const std::vector<ShapeHandle>& input_tensors_as_shapes) {\n  const auto ret = full_type::SpecializeType(attrs_, op_def);\n  DCHECK(ret.status().ok()) << \"while instantiating types: \" << ret.status();\n  ret_types_ = ret.ValueOrDie();\n  input_tensors_ = input_tensors;\n  input_tensors_as_shapes_ = input_tensors_as_shapes;\n  construction_status_ =\n      NameRangesForNode(attrs_, op_def, &input_name_map_, &output_name_map_);\n  if (!construction_status_.ok()) return;\n  int num_outputs = 0;\n  for (const auto& e : output_name_map_) {\n    num_outputs = std::max(num_outputs, e.second.second);\n  }\n  outputs_.assign(num_outputs, nullptr);\n  output_handle_shapes_and_types_.resize(num_outputs);\n}", "target": 1}
{"code": "static void request_key_auth_describe(const struct key *key,\n\t\t\t\t      struct seq_file *m)\n{\n\tstruct request_key_auth *rka = key->payload.data[0];\n\tseq_puts(m, \"key:\");\n\tseq_puts(m, key->description);\n\tif (key_is_instantiated(key))\n\t\tseq_printf(m, \" pid:%d ci:%zu\", rka->pid, rka->callout_len);\n}", "target": 1}
{"code": "match_named_captures_iter(const OnigUChar *name, const OnigUChar *name_end,\n\tint back_num, int *back_refs, OnigRegex regex, void *arg) {\n    struct MEMO *memo = MEMO_CAST(arg);\n    VALUE hash = memo->v1;\n    VALUE match = memo->v2;\n    VALUE key = rb_enc_str_new((const char *)name, name_end-name, regex->enc);\n    VALUE value;\n    int i;\n    int found = 0;\n    for (i = 0; i < back_num; i++) {\n\tvalue = rb_reg_nth_match(back_refs[i], match);\n\tif (RTEST(value)) {\n\t    rb_hash_aset(hash, key, value);\n\t    found = 1;\n\t}\n    }\n    if (found == 0) {\n\trb_hash_aset(hash, key, Qnil);\n    }\n    return 0;\n}", "target": 0}
{"code": "static OPJ_BOOL opj_j2k_read_qcd (  opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager\n                                    )\n{\n        assert(p_header_data != 00);\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        if (! opj_j2k_read_SQcd_SQcc(p_j2k,0,p_header_data,&p_header_size,p_manager)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading QCD marker\\n\");\n                return OPJ_FALSE;\n        }\n        if (p_header_size != 0) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading QCD marker\\n\");\n                return OPJ_FALSE;\n        }\n        opj_j2k_copy_tile_quantization_parameters(p_j2k);\n        return OPJ_TRUE;\n}", "target": 0}
{"code": "sctp_disposition_t sctp_sf_t4_timer_expire(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = asoc->addip_last_asconf;\n\tstruct sctp_transport *transport = chunk->transport;\n\tSCTP_INC_STATS(net, SCTP_MIB_T4_RTO_EXPIREDS);\n\tif (transport)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_STRIKE,\n\t\t\t\tSCTP_TRANSPORT(transport));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T4, SCTP_CHUNK(chunk));\n\tif (asoc->overall_error_count >= asoc->max_retrans) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_DISPOSITION_ABORT;\n\t}\n\tsctp_chunk_hold(asoc->addip_last_asconf);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\tSCTP_CHUNK(asoc->addip_last_asconf));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\treturn SCTP_DISPOSITION_CONSUME;\n}", "target": 0}
{"code": "static void disk_del_events(struct gendisk *disk)\n{\n\tif (!disk->ev)\n\t\treturn;\n\tdisk_block_events(disk);\n\tmutex_lock(&disk_events_mutex);\n\tlist_del_init(&disk->ev->node);\n\tmutex_unlock(&disk_events_mutex);\n\tsysfs_remove_files(&disk_to_dev(disk)->kobj, disk_events_attrs);\n}", "target": 0}
{"code": "static void voutf(struct GlobalConfig *config,\n                  const char *prefix,\n                  const char *fmt,\n                  va_list ap)\n{\n  size_t width = (79 - strlen(prefix));\n  if(!config->mute) {\n    size_t len;\n    char *ptr;\n    char *print_buffer;\n    print_buffer = curlx_mvaprintf(fmt, ap);\n    if(!print_buffer)\n      return;\n    len = strlen(print_buffer);\n    ptr = print_buffer;\n    while(len > 0) {\n      fputs(prefix, config->errors);\n      if(len > width) {\n        size_t cut = width-1;\n        while(!ISSPACE(ptr[cut]) && cut) {\n          cut--;\n        }\n        if(0 == cut)\n          cut = width-1;\n        (void)fwrite(ptr, cut + 1, 1, config->errors);\n        fputs(\"\\n\", config->errors);\n        ptr += cut + 1; \n        len -= cut;\n      }\n      else {\n        fputs(ptr, config->errors);\n        len = 0;\n      }\n    }\n    curl_free(print_buffer);\n  }\n}", "target": 1}
{"code": "ossl_cipher_update(int argc, VALUE *argv, VALUE self)\n{\n    EVP_CIPHER_CTX *ctx;\n    unsigned char *in;\n    long in_len, out_len;\n    VALUE data, str;\n    rb_scan_args(argc, argv, \"11\", &data, &str);\n    if (!RTEST(rb_attr_get(self, id_key_set)))\n\tossl_raise(eCipherError, \"key not set\");\n    StringValue(data);\n    in = (unsigned char *)RSTRING_PTR(data);\n    if ((in_len = RSTRING_LEN(data)) == 0)\n        ossl_raise(rb_eArgError, \"data must not be empty\");\n    GetCipher(self, ctx);\n    out_len = in_len+EVP_CIPHER_CTX_block_size(ctx);\n    if (out_len <= 0) {\n\tossl_raise(rb_eRangeError,\n\t\t   \"data too big to make output buffer: %ld bytes\", in_len);\n    }\n    if (NIL_P(str)) {\n        str = rb_str_new(0, out_len);\n    } else {\n        StringValue(str);\n        rb_str_resize(str, out_len);\n    }\n    if (!ossl_cipher_update_long(ctx, (unsigned char *)RSTRING_PTR(str), &out_len, in, in_len))\n\tossl_raise(eCipherError, NULL);\n    assert(out_len < RSTRING_LEN(str));\n    rb_str_set_len(str, out_len);\n    return str;\n}", "target": 0}
{"code": "get_manuf_name_if_known(const guint8 *addr)\n{\n    hashmanuf_t *manuf_value;\n    guint manuf_key;\n    guint8 oct;\n    manuf_key = addr[0];\n    manuf_key = manuf_key<<8;\n    oct = addr[1];\n    manuf_key = manuf_key | oct;\n    manuf_key = manuf_key<<8;\n    oct = addr[2];\n    manuf_key = manuf_key | oct;\n    manuf_value = (hashmanuf_t *)wmem_map_lookup(manuf_hashtable, GUINT_TO_POINTER(manuf_key));\n    if (manuf_value != NULL && manuf_value->status != HASHETHER_STATUS_UNRESOLVED) {\n        return manuf_value->resolved_longname;\n    }\n    const char *short_name, *long_name;\n    short_name = ws_manuf_lookup_str(addr, &long_name);\n    if (short_name != NULL) {\n        return long_name;\n    }\n    return NULL;\n} ", "target": 1}
{"code": "static int inet6_netconf_get_devconf(struct sk_buff *in_skb,\n\t\t\t\t     struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct nlattr *tb[NETCONFA_MAX+1];\n\tstruct netconfmsg *ncm;\n\tstruct sk_buff *skb;\n\tstruct ipv6_devconf *devconf;\n\tstruct inet6_dev *in6_dev;\n\tstruct net_device *dev;\n\tint ifindex;\n\tint err;\n\terr = nlmsg_parse(nlh, sizeof(*ncm), tb, NETCONFA_MAX,\n\t\t\t  devconf_ipv6_policy);\n\tif (err < 0)\n\t\tgoto errout;\n\terr = EINVAL;\n\tif (!tb[NETCONFA_IFINDEX])\n\t\tgoto errout;\n\tifindex = nla_get_s32(tb[NETCONFA_IFINDEX]);\n\tswitch (ifindex) {\n\tcase NETCONFA_IFINDEX_ALL:\n\t\tdevconf = net->ipv6.devconf_all;\n\t\tbreak;\n\tcase NETCONFA_IFINDEX_DEFAULT:\n\t\tdevconf = net->ipv6.devconf_dflt;\n\t\tbreak;\n\tdefault:\n\t\tdev = __dev_get_by_index(net, ifindex);\n\t\tif (dev == NULL)\n\t\t\tgoto errout;\n\t\tin6_dev = __in6_dev_get(dev);\n\t\tif (in6_dev == NULL)\n\t\t\tgoto errout;\n\t\tdevconf = &in6_dev->cnf;\n\t\tbreak;\n\t}\n\terr = -ENOBUFS;\n\tskb = nlmsg_new(inet6_netconf_msgsize_devconf(-1), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\tgoto errout;\n\terr = inet6_netconf_fill_devconf(skb, ifindex, devconf,\n\t\t\t\t\t NETLINK_CB(in_skb).portid,\n\t\t\t\t\t nlh->nlmsg_seq, RTM_NEWNETCONF, 0,\n\t\t\t\t\t -1);\n\tif (err < 0) {\n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\terr = rtnl_unicast(skb, net, NETLINK_CB(in_skb).portid);\nerrout:\n\treturn err;\n}", "target": 0}
{"code": "static int wcd9335_probe(struct wcd9335_codec *wcd)\n{\n\tstruct device *dev = wcd->dev;\n\tmemcpy(wcd->rx_chs, wcd9335_rx_chs, sizeof(wcd9335_rx_chs));\n\tmemcpy(wcd->tx_chs, wcd9335_tx_chs, sizeof(wcd9335_tx_chs));\n\twcd->sido_input_src = SIDO_SOURCE_INTERNAL;\n\twcd->sido_voltage = SIDO_VOLTAGE_NOMINAL_MV;\n\treturn devm_snd_soc_register_component(dev, &wcd9335_component_drv,\n\t\t\t\t\t       wcd9335_slim_dais,\n\t\t\t\t\t       ARRAY_SIZE(wcd9335_slim_dais));\n}", "target": 0}
{"code": "static int pit_get_out(struct kvm *kvm, int channel)\n{\n\tstruct kvm_kpit_channel_state *c =\n\t\t&kvm->arch.vpit->pit_state.channels[channel];\n\ts64 d, t;\n\tint out;\n\tWARN_ON(!mutex_is_locked(&kvm->arch.vpit->pit_state.lock));\n\tt = kpit_elapsed(kvm, c, channel);\n\td = muldiv64(t, KVM_PIT_FREQ, NSEC_PER_SEC);\n\tswitch (c->mode) {\n\tdefault:\n\tcase 0:\n\t\tout = (d >= c->count);\n\t\tbreak;\n\tcase 1:\n\t\tout = (d < c->count);\n\t\tbreak;\n\tcase 2:\n\t\tout = ((mod_64(d, c->count) == 0) && (d != 0));\n\t\tbreak;\n\tcase 3:\n\t\tout = (mod_64(d, c->count) < ((c->count + 1) >> 1));\n\t\tbreak;\n\tcase 4:\n\tcase 5:\n\t\tout = (d == c->count);\n\t\tbreak;\n\t}\n\treturn out;\n}", "target": 0}
{"code": "cmndlist_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct member_list *list, const char *runchroot,\n    struct cmnd_info *info)\n{\n    struct member *m;\n    int matched = UNSPEC;\n    debug_decl(cmndlist_matches, SUDOERS_DEBUG_MATCH);\n    TAILQ_FOREACH_REVERSE(m, list, member_list, entries) {\n\tmatched = cmnd_matches(parse_tree, m, runchroot, info);\n\tif (matched != UNSPEC)\n\t    break;\n    }\n    debug_return_int(matched);\n}", "target": 1}
{"code": "ebt_basic_match(const struct ebt_entry *e, const struct sk_buff *skb,\n                const struct net_device *in, const struct net_device *out)\n{\n\tconst struct ethhdr *h = eth_hdr(skb);\n\tconst struct net_bridge_port *p;\n\t__be16 ethproto;\n\tint verdict, i;\n\tif (vlan_tx_tag_present(skb))\n\t\tethproto = htons(ETH_P_8021Q);\n\telse\n\t\tethproto = h->h_proto;\n\tif (e->bitmask & EBT_802_3) {\n\t\tif (FWINV2(ntohs(ethproto) >= 1536, EBT_IPROTO))\n\t\t\treturn 1;\n\t} else if (!(e->bitmask & EBT_NOPROTO) &&\n\t   FWINV2(e->ethproto != ethproto, EBT_IPROTO))\n\t\treturn 1;\n\tif (FWINV2(ebt_dev_check(e->in, in), EBT_IIN))\n\t\treturn 1;\n\tif (FWINV2(ebt_dev_check(e->out, out), EBT_IOUT))\n\t\treturn 1;\n\tif (in && (p = br_port_get_rcu(in)) != NULL &&\n\t    FWINV2(ebt_dev_check(e->logical_in, p->br->dev), EBT_ILOGICALIN))\n\t\treturn 1;\n\tif (out && (p = br_port_get_rcu(out)) != NULL &&\n\t    FWINV2(ebt_dev_check(e->logical_out, p->br->dev), EBT_ILOGICALOUT))\n\t\treturn 1;\n\tif (e->bitmask & EBT_SOURCEMAC) {\n\t\tverdict = 0;\n\t\tfor (i = 0; i < 6; i++)\n\t\t\tverdict |= (h->h_source[i] ^ e->sourcemac[i]) &\n\t\t\t   e->sourcemsk[i];\n\t\tif (FWINV2(verdict != 0, EBT_ISOURCE) )\n\t\t\treturn 1;\n\t}\n\tif (e->bitmask & EBT_DESTMAC) {\n\t\tverdict = 0;\n\t\tfor (i = 0; i < 6; i++)\n\t\t\tverdict |= (h->h_dest[i] ^ e->destmac[i]) &\n\t\t\t   e->destmsk[i];\n\t\tif (FWINV2(verdict != 0, EBT_IDEST) )\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void free_pgtables(struct mmu_gather **tlb, struct vm_area_struct *vma,\n\t\tunsigned long floor, unsigned long ceiling)\n{\n\twhile (vma) {\n\t\tstruct vm_area_struct *next = vma->vm_next;\n\t\tunsigned long addr = vma->vm_start;\n\t\tanon_vma_unlink(vma);\n\t\tunlink_file_vma(vma);\n\t\tif (is_vm_hugetlb_page(vma)) {\n\t\t\thugetlb_free_pgd_range(tlb, addr, vma->vm_end,\n\t\t\t\tfloor, next? next->vm_start: ceiling);\n\t\t} else {\n\t\t\twhile (next && next->vm_start <= vma->vm_end + PMD_SIZE\n\t\t\t       && !is_vm_hugetlb_page(next)) {\n\t\t\t\tvma = next;\n\t\t\t\tnext = vma->vm_next;\n\t\t\t\tanon_vma_unlink(vma);\n\t\t\t\tunlink_file_vma(vma);\n\t\t\t}\n\t\t\tfree_pgd_range(tlb, addr, vma->vm_end,\n\t\t\t\tfloor, next? next->vm_start: ceiling);\n\t\t}\n\t\tvma = next;\n\t}\n}", "target": 0}
{"code": "rfbSetClientColourMapBGR233(rfbClientPtr cl)\n{\n    char buf[sz_rfbSetColourMapEntriesMsg + 256 * 3 * 2];\n    rfbSetColourMapEntriesMsg *scme = (rfbSetColourMapEntriesMsg *)buf;\n    uint16_t *rgb = (uint16_t *)(&buf[sz_rfbSetColourMapEntriesMsg]);\n    int i, len;\n    int r, g, b;\n    if (cl->format.bitsPerPixel != 8 ) {\n        rfbErr(\"%s: client not 8 bits per pixel\\n\",\n                \"rfbSetClientColourMapBGR233\");\n        rfbCloseClient(cl);\n        return FALSE;\n    }\n    scme->type = rfbSetColourMapEntries;\n    scme->firstColour = Swap16IfLE(0);\n    scme->nColours = Swap16IfLE(256);\n    len = sz_rfbSetColourMapEntriesMsg;\n    i = 0;\n    for (b = 0; b < 4; b++) {\n        for (g = 0; g < 8; g++) {\n            for (r = 0; r < 8; r++) {\n                rgb[i++] = Swap16IfLE(r * 65535 / 7);\n                rgb[i++] = Swap16IfLE(g * 65535 / 7);\n                rgb[i++] = Swap16IfLE(b * 65535 / 3);\n            }\n        }\n    }\n    len += 256 * 3 * 2;\n    if (rfbWriteExact(cl, buf, len) < 0) {\n        rfbLogPerror(\"rfbSetClientColourMapBGR233: write\");\n        rfbCloseClient(cl);\n        return FALSE;\n    }\n    return TRUE;\n}", "target": 1}
{"code": "static struct timespec fio_timer_calc_due(size_t interval) {\n  struct timespec now = fio_last_tick();\n  if (interval > 1000) {\n    now.tv_sec += interval / 1000;\n    interval -= interval / 1000;\n  }\n  now.tv_nsec += (interval * 1000000UL);\n  if (now.tv_nsec > 1000000000L) {\n    now.tv_nsec -= 1000000000L;\n    now.tv_sec += 1;\n  }\n  return now;\n}", "target": 1}
{"code": "  bool HasOverflowed() const {\n    StackGuard* stack_guard = isolate_->stack_guard();\n    return (reinterpret_cast<uintptr_t>(this) < stack_guard->climit()) &&\n           stack_guard->IsStackOverflow();\n  }", "target": 1}
{"code": "  Compound_Selector_Obj Parser::parse_compound_selector()\n  {\n    Compound_Selector_Obj seq = SASS_MEMORY_NEW(Compound_Selector, pstate);\n    seq->media_block(last_media_block);\n    lex< css_whitespace >();\n    while (true)\n    {\n      lex< delimited_by< slash_star, star_slash, false > >(false);\n      if (match < re_pseudo_selector >())\n      {\n        seq->append(parse_simple_selector());\n      }\n      else if (lex< exactly<'&'> >(false))\n      {\n        if (!allow_parent) error(\"Parent selectors aren't allowed here.\");\n        seq->has_parent_reference(true);\n        seq->append(SASS_MEMORY_NEW(Parent_Selector, pstate));\n        if (seq->length() > 1) {\n          ParserState state(pstate);\n          Simple_Selector_Obj cur = (*seq)[seq->length()-1];\n          Simple_Selector_Obj prev = (*seq)[seq->length()-2];\n          std::string sel(prev->to_string({ NESTED, 5 }));\n          std::string found(cur->to_string({ NESTED, 5 }));\n          if (lex < identifier >()) { found += std::string(lexed); }\n          error(\"Invalid CSS after \\\"\" + sel + \"\\\": expected \\\"{\\\", was \\\"\" + found + \"\\\"\\n\\n\"\n            \"\\\"\" + found + \"\\\" may only be used at the beginning of a compound selector.\", state);\n        }\n      }\n      else if (lex< re_type_selector >(false))\n      {\n        seq->append(SASS_MEMORY_NEW(Type_Selector, pstate, lexed));\n      }\n      else if (peek< spaces >()) break;\n      else if (peek< end_of_file >()) { break; }\n      else if (peek_css < class_char < selector_combinator_ops > >()) break;\n      else if (peek_css < class_char < complex_selector_delims > >()) break;\n      else {\n        Simple_Selector_Obj sel = parse_simple_selector();\n        if (!sel) return {};\n        seq->append(sel);\n      }\n    }\n    if (seq && !peek_css<alternatives<end_of_file,exactly<'{'>>>()) {\n      seq->has_line_break(peek_newline());\n    }\n    return seq;\n  }", "target": 0}
{"code": "op_reindent(oparg_T *oap, int (*how)(void))\n{\n    long\ti = 0;\n    char_u\t*l;\n    int\t\tamount;\n    linenr_T\tfirst_changed = 0;\n    linenr_T\tlast_changed = 0;\n    linenr_T\tstart_lnum = curwin->w_cursor.lnum;\n    if (!curbuf->b_p_ma)\n    {\n\temsg(_(e_cannot_make_changes_modifiable_is_off));\n\treturn;\n    }\n    if (u_savecommon(start_lnum - 1, start_lnum + oap->line_count,\n\t\t\t\t     start_lnum + oap->line_count, FALSE) == OK)\n\tfor (i = oap->line_count; --i >= 0 && !got_int; )\n\t{\n\t    if (i > 1\n\t\t    && (i % 50 == 0 || i == oap->line_count - 1)\n\t\t    && oap->line_count > p_report)\n\t\tsmsg(_(\"%ld lines to indent... \"), i);\n\t    if (i != oap->line_count - 1 || oap->line_count == 1\n\t\t\t\t\t\t     || how != get_lisp_indent)\n\t    {\n\t\tl = skipwhite(ml_get_curline());\n\t\tif (*l == NUL)\t\t    \n\t\t    amount = 0;\n\t\telse\n\t\t    amount = how();\t    \n\t\tif (amount >= 0 && set_indent(amount, 0))\n\t\t{\n\t\t    if (first_changed == 0)\n\t\t\tfirst_changed = curwin->w_cursor.lnum;\n\t\t    last_changed = curwin->w_cursor.lnum;\n\t\t}\n\t    }\n\t    ++curwin->w_cursor.lnum;\n\t    curwin->w_cursor.col = 0;  \n\t}\n    curwin->w_cursor.lnum = start_lnum;\n    beginline(BL_SOL | BL_FIX);\n    if (last_changed != 0)\n\tchanged_lines(first_changed, 0,\n\t\toap->is_VIsual ? start_lnum + oap->line_count :\n\t\tlast_changed + 1, 0L);\n    else if (oap->is_VIsual)\n\tredraw_curbuf_later(INVERTED);\n    if (oap->line_count > p_report)\n    {\n\ti = oap->line_count - (i + 1);\n\tsmsg(NGETTEXT(\"%ld line indented \",\n\t\t\t\t\t\t \"%ld lines indented \", i), i);\n    }\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\tcurbuf->b_op_start = oap->start;\n\tcurbuf->b_op_end = oap->end;\n    }\n}", "target": 0}
{"code": "void common_timer_get(struct k_itimer *timr, struct itimerspec64 *cur_setting)\n{\n\tconst struct k_clock *kc = timr->kclock;\n\tktime_t now, remaining, iv;\n\tstruct timespec64 ts64;\n\tbool sig_none;\n\tsig_none = (timr->it_sigev_notify & ~SIGEV_THREAD_ID) == SIGEV_NONE;\n\tiv = timr->it_interval;\n\tif (iv) {\n\t\tcur_setting->it_interval = ktime_to_timespec64(iv);\n\t} else if (!timr->it_active) {\n\t\tif (!sig_none)\n\t\t\treturn;\n\t}\n\tkc->clock_get(timr->it_clock, &ts64);\n\tnow = timespec64_to_ktime(ts64);\n\tif (iv && (timr->it_requeue_pending & REQUEUE_PENDING || sig_none))\n\t\ttimr->it_overrun += kc->timer_forward(timr, now);\n\tremaining = kc->timer_remaining(timr, now);\n\tif (remaining <= 0) {\n\t\tif (!sig_none)\n\t\t\tcur_setting->it_value.tv_nsec = 1;\n\t} else {\n\t\tcur_setting->it_value = ktime_to_timespec64(remaining);\n\t}\n}", "target": 1}
{"code": "static inline bool nested_cpu_has_vid(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n}", "target": 0}
{"code": "static int zipfileSerializeLFH(ZipfileEntry *pEntry, u8 *aBuf){\n  ZipfileCDS *pCds = &pEntry->cds;\n  u8 *a = aBuf;\n  pCds->nExtra = 9;\n  zipfileWrite32(a, ZIPFILE_SIGNATURE_LFH);\n  zipfileWrite16(a, pCds->iVersionExtract);\n  zipfileWrite16(a, pCds->flags);\n  zipfileWrite16(a, pCds->iCompression);\n  zipfileWrite16(a, pCds->mTime);\n  zipfileWrite16(a, pCds->mDate);\n  zipfileWrite32(a, pCds->crc32);\n  zipfileWrite32(a, pCds->szCompressed);\n  zipfileWrite32(a, pCds->szUncompressed);\n  zipfileWrite16(a, (u16)pCds->nFile);\n  zipfileWrite16(a, pCds->nExtra);\n  assert( a==&aBuf[ZIPFILE_LFH_FIXED_SZ] );\n  memcpy(a, pCds->zFile, (int)pCds->nFile);\n  a += (int)pCds->nFile;\n  zipfileWrite16(a, ZIPFILE_EXTRA_TIMESTAMP);\n  zipfileWrite16(a, 5);\n  *a++ = 0x01;\n  zipfileWrite32(a, pEntry->mUnixTime);\n  return a-aBuf;\n}", "target": 0}
{"code": "static int raw_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t       int *len, int peer)\n{\n\tstruct sockaddr_can *addr = (struct sockaddr_can *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct raw_sock *ro = raw_sk(sk);\n\tif (peer)\n\t\treturn -EOPNOTSUPP;\n\taddr->can_family  = AF_CAN;\n\taddr->can_ifindex = ro->ifindex;\n\t*len = sizeof(*addr);\n\treturn 0;\n}", "target": 1}
{"code": "void OmniboxViewWin::SetUserText(const string16& text,\n                                 const string16& display_text,\n                                 bool update_popup) {\n  ScopedFreeze freeze(this, GetTextObjectModel());\n  model_->SetUserText(text);\n  saved_selection_for_focus_change_.cpMin = -1;\n  SetWindowTextAndCaretPos(display_text, display_text.length());\n  if (update_popup)\n    UpdatePopup();\n  TextChanged();\n}", "target": 0}
{"code": "String UnbufferedAsioTlsStream::GetVerifyError() const\n{\n\treturn m_VerifyError;\n}", "target": 1}
{"code": "read_line (FILE         *fp,\n           guchar       *row,\n           guchar       *buf,\n           tga_info     *info,\n           gint          bpp,\n           const guchar *convert_cmap)\n{\n  if (info->imageCompression == TGA_COMP_RLE)\n    {\n      rle_read (fp, buf, info);\n    }\n  else\n    {\n      fread (buf, info->bytes, info->width, fp);\n    }\n  if (info->flipHoriz)\n    {\n      flip_line (buf, info);\n    }\n  if (info->imageType == TGA_TYPE_COLOR)\n    {\n      if (info->bpp == 16 || info->bpp == 15)\n        {\n          upsample (row, buf, info->width, info->bytes, info->alphaBits);\n        }\n      else\n        {\n          bgr2rgb (row, buf, info->width, info->bytes, info->alphaBits);\n        }\n    }\n  else if (convert_cmap)\n    {\n      gboolean has_alpha = (info->alphaBits > 0);\n      apply_colormap (row, buf, info->width, convert_cmap, has_alpha,\n                      info->colorMapIndex);\n    }\n  else if (info->imageType == TGA_TYPE_MAPPED)\n    {\n      g_assert(bpp == 1);\n      apply_index (row, buf, info->width, info->colorMapIndex);\n    }\n  else\n    {\n      memcpy (row, buf, info->width * bpp);\n    }\n}", "target": 0}
{"code": "int phar_is_tar(char *buf, char *fname) \n{\n\ttar_header *header = (tar_header *) buf;\n\tphp_uint32 checksum = phar_tar_number(header->checksum, sizeof(header->checksum));\n\tphp_uint32 ret;\n\tchar save[sizeof(header->checksum)], *bname;\n\tif (!strncmp(buf, \"<?php\", sizeof(\"<?php\")-1)) {\n\t\treturn 0;\n\t}\n\tmemcpy(save, header->checksum, sizeof(header->checksum));\n\tmemset(header->checksum, ' ', sizeof(header->checksum));\n\tret = (checksum == phar_tar_checksum(buf, 512));\n\tmemcpy(header->checksum, save, sizeof(header->checksum));\n\tif ((bname = strrchr(fname, PHP_DIR_SEPARATOR))) {\n\t\tfname = bname;\n\t}\n\tif (!ret && (bname = strstr(fname, \".tar\")) && (bname[4] == '\\0' || bname[4] == '.')) {\n\t\treturn 1;\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "mm_compare(struct mm_share *a, struct mm_share *b)\n{\n\tptrdiff_t diff = (char *)a->address - (char *)b->address;\n\tif (diff == 0)\n\t\treturn (0);\n\telse if (diff < 0)\n\t\treturn (-1);\n\telse\n\t\treturn (1);\n}", "target": 1}
{"code": "_pam_parse (const pam_handle_t *pamh, int argc, const char **argv,\n\t    const char **conffile, const char **envfile, int *readenv,\n\t    const char **user_envfile, int *user_readenv)\n{\n    int ctrl=0;\n    *user_envfile = DEFAULT_USER_ENVFILE;\n    *envfile = DEFAULT_ETC_ENVFILE;\n    *readenv = DEFAULT_READ_ENVFILE;\n    *user_readenv = DEFAULT_USER_READ_ENVFILE;\n    *conffile = DEFAULT_CONF_FILE;\n    for (; argc-- > 0; ++argv) {\n\tif (!strcmp(*argv,\"debug\"))\n\t    ctrl |= PAM_DEBUG_ARG;\n\telse if (!strncmp(*argv,\"conffile=\",9)) {\n\t  if ((*argv)[9] == '\\0') {\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"conffile= specification missing argument - ignored\");\n\t  } else {\n\t    *conffile = 9+*argv;\n\t    D((\"new Configuration File: %s\", *conffile));\n\t  }\n\t} else if (!strncmp(*argv,\"envfile=\",8)) {\n\t  if ((*argv)[8] == '\\0') {\n\t    pam_syslog (pamh, LOG_ERR,\n\t\t\t\"envfile= specification missing argument - ignored\");\n\t  } else {\n\t    *envfile = 8+*argv;\n\t    D((\"new Env File: %s\", *envfile));\n\t  }\n\t} else if (!strncmp(*argv,\"user_envfile=\",13)) {\n\t  if ((*argv)[13] == '\\0') {\n\t    pam_syslog (pamh, LOG_ERR,\n\t\t\t\"user_envfile= specification missing argument - ignored\");\n\t  } else {\n\t    *user_envfile = 13+*argv;\n\t    D((\"new User Env File: %s\", *user_envfile));\n\t  }\n\t} else if (!strncmp(*argv,\"readenv=\",8))\n\t  *readenv = atoi(8+*argv);\n\telse if (!strncmp(*argv,\"user_readenv=\",13))\n\t  *user_readenv = atoi(13+*argv);\n\telse\n\t  pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n    }\n    return ctrl;\n}", "target": 0}
{"code": "static int avrcp_target_server_probe(struct btd_profile *p,\n\t\t\t\t\t\tstruct btd_adapter *adapter)\n{\n\tsdp_record_t *record;\n\tstruct avrcp_server *server;\n\tDBG(\"path %s\", adapter_get_path(adapter));\n\tserver = find_server(servers, adapter);\n\tif (server != NULL)\n\t\tgoto done;\n\tserver = avrcp_server_register(adapter);\n\tif (server == NULL)\n\t\treturn -EPROTONOSUPPORT;\ndone:\n\trecord = avrcp_tg_record();\n\tif (!record) {\n\t\terror(\"Unable to allocate new service record\");\n\t\tavrcp_target_server_remove(p, adapter);\n\t\treturn -1;\n\t}\n\tif (adapter_service_add(adapter, record) < 0) {\n\t\terror(\"Unable to register AVRCP target service record\");\n\t\tavrcp_target_server_remove(p, adapter);\n\t\tsdp_record_free(record);\n\t\treturn -1;\n\t}\n\tserver->tg_record_id = record->handle;\n\treturn 0;\n}", "target": 0}
{"code": "static void __net_exit pfkey_net_exit(struct net *net)\n{\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\tpfkey_exit_proc(net);\n\tWARN_ON(!hlist_empty(&net_pfkey->table));\n}", "target": 0}
{"code": "static void load_creator_from_buf(\n    FILE       *fp,\n    xref_t     *xref,\n    const char *buf,\n    size_t      buf_size)\n{\n    int   is_xml;\n    char *c;\n    if (!buf)\n      return;\n    if ((c = strstr(buf, \"/Type\")))\n      while (*c && !isspace(*c))\n        ++c;\n    is_xml = 0;\n    if (c && (*c == 'M'))\n      is_xml = 1;\n    if (is_xml)\n      load_creator_from_xml(xref, buf);\n    else\n      load_creator_from_old_format(fp, xref, buf, buf_size);\n}", "target": 0}
{"code": "static int check_line_charstring(void)\n{\n  char *p = line;\n  while (isspace(*p))\n    p++;\n  return (*p == '/' || (p[0] == 'd' && p[1] == 'u' && p[2] == 'p'));\n}", "target": 1}
{"code": "static struct xol_area *__create_xol_area(unsigned long vaddr)\n{\n\tstruct mm_struct *mm = current->mm;\n\tuprobe_opcode_t insn = UPROBE_SWBP_INSN;\n\tstruct xol_area *area;\n\tarea = kmalloc(sizeof(*area), GFP_KERNEL);\n\tif (unlikely(!area))\n\t\tgoto out;\n\tarea->bitmap = kzalloc(BITS_TO_LONGS(UINSNS_PER_PAGE) * sizeof(long), GFP_KERNEL);\n\tif (!area->bitmap)\n\t\tgoto free_area;\n\tarea->xol_mapping.name = \"[uprobes]\";\n\tarea->xol_mapping.fault = NULL;\n\tarea->xol_mapping.pages = area->pages;\n\tarea->pages[0] = alloc_page(GFP_HIGHUSER);\n\tif (!area->pages[0])\n\t\tgoto free_bitmap;\n\tarea->pages[1] = NULL;\n\tarea->vaddr = vaddr;\n\tinit_waitqueue_head(&area->wq);\n\tset_bit(0, area->bitmap);\n\tatomic_set(&area->slot_count, 1);\n\tarch_uprobe_copy_ixol(area->pages[0], 0, &insn, UPROBE_SWBP_INSN_SIZE);\n\tif (!xol_add_vma(mm, area))\n\t\treturn area;\n\t__free_page(area->pages[0]);\n free_bitmap:\n\tkfree(area->bitmap);\n free_area:\n\tkfree(area);\n out:\n\treturn NULL;\n}", "target": 0}
{"code": "find_sig8_target_as_global_offset(Dwarf_Attribute attr,\n    Dwarf_Sig8  *sig8,\n    Dwarf_Bool  *is_info,\n    Dwarf_Off   *targoffset,\n    Dwarf_Error *error)\n{\n    Dwarf_Die  targdie = 0;\n    Dwarf_Bool targ_is_info = 0;\n    Dwarf_Off  localoff = 0;\n    int res = 0;\n    targ_is_info = attr->ar_cu_context->cc_is_info;\n    memcpy(sig8,attr->ar_debug_ptr,sizeof(*sig8));\n    res = dwarf_find_die_given_sig8(attr->ar_dbg,\n        sig8,&targdie,&targ_is_info,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    res = dwarf_die_offsets(targdie,targoffset,&localoff,error);\n    if (res != DW_DLV_OK) {\n        dwarf_dealloc_die(targdie);\n        return res;\n    }\n    *is_info = targdie->di_cu_context->cc_is_info;\n    dwarf_dealloc_die(targdie);\n    return DW_DLV_OK;\n}", "target": 1}
{"code": "bool IsConstantFoldable(\n    const Node* n,\n    const std::unordered_map<string, std::vector<PartialTensorShape>>*\n        shape_map,\n    const std::function<bool(const Node*)>& consider,\n    int64_t max_constant_size_in_bytes,\n    std::unordered_map<const Node*, std::vector<Tensor>>*\n        shape_replacement_map) {\n  if (n->IsConstant()) {\n    return true;\n  }\n  if (MaybeReplaceShapeOp(n, shape_map, shape_replacement_map)) {\n    return true;\n  }\n  if (n->op_def().is_stateful()) {\n    return false;\n  }\n  if (consider && !consider(n)) {\n    return false;\n  }\n  if (shape_map != nullptr) {\n    auto shape_it = shape_map->find(n->name());\n    if (shape_it != shape_map->end()) {\n      for (int64_t i = 0; i < shape_it->second.size(); ++i) {\n        const auto& out_shape = shape_it->second[i];\n        if (out_shape.IsFullyDefined() &&\n            out_shape.num_elements() * DataTypeSize(n->output_type(i)) >\n                max_constant_size_in_bytes) {\n          return false;\n        }\n      }\n    }\n  }\n  if (n->IsControlFlow() || n->IsSend() || n->IsRecv()) {\n    return false;\n  }\n  if (n->IsGetSessionHandle() || n->IsGetSessionTensor() ||\n      n->IsDeleteSessionTensor()) {\n    return false;\n  }\n  if (n->IsSource()) {\n    return false;\n  }\n  if (n->IsSink()) {\n    return false;\n  }\n  if (n->IsFakeParam()) {\n    return false;\n  }\n  if (!KernelDefAvailable(DeviceType(DEVICE_CPU), n->def())) {\n    return false;\n  }\n  if (n->attrs().Find(kScopedAllocatorAttrName) != nullptr) {\n    VLOG(2) << \"Skip node [\" << n->DebugString()\n            << \"] for constant folding due to scoped allocator\";\n    return false;\n  }\n  return true;\n}", "target": 1}
{"code": "static inline void kvm_memslot_delete(struct kvm_memslots *slots,\n\t\t\t\t      struct kvm_memory_slot *memslot)\n{\n\tstruct kvm_memory_slot *mslots = slots->memslots;\n\tint i;\n\tif (WARN_ON(slots->id_to_index[memslot->id] == -1))\n\t\treturn;\n\tslots->used_slots--;\n\tfor (i = slots->id_to_index[memslot->id]; i < slots->used_slots; i++) {\n\t\tmslots[i] = mslots[i + 1];\n\t\tslots->id_to_index[mslots[i].id] = i;\n\t}\n\tmslots[i] = *memslot;\n\tslots->id_to_index[memslot->id] = -1;\n}", "target": 1}
{"code": "    bool PamBackend::start(const QString &user) {\n        bool result;\n        QString service = QStringLiteral(\"sddm\");\n        if (user == QStringLiteral(\"sddm\") && m_greeter)\n            service = QStringLiteral(\"sddm-greeter\");\n        else if (m_app->session()->path().isEmpty())\n            service = QStringLiteral(\"sddm-check\");\n        else if (m_autologin)\n            service = QStringLiteral(\"sddm-autologin\");\n        result = m_pam->start(service, user);\n        if (!result)\n            m_app->error(m_pam->errorString(), Auth::ERROR_INTERNAL);\n        return result;\n    }", "target": 1}
{"code": "static int sched_read_attr(struct sched_attr __user *uattr,\n\t\t\t   struct sched_attr *attr,\n\t\t\t   unsigned int usize)\n{\n\tint ret;\n\tif (!access_ok(VERIFY_WRITE, uattr, usize))\n\t\treturn -EFAULT;\n\tif (usize < sizeof(*attr)) {\n\t\tunsigned char *addr;\n\t\tunsigned char *end;\n\t\taddr = (void *)attr + usize;\n\t\tend  = (void *)attr + sizeof(*attr);\n\t\tfor (; addr < end; addr++) {\n\t\t\tif (*addr)\n\t\t\t\tgoto err_size;\n\t\t}\n\t\tattr->size = usize;\n\t}\n\tret = copy_to_user(uattr, attr, usize);\n\tif (ret)\n\t\treturn -EFAULT;\nout:\n\treturn ret;\nerr_size:\n\tret = -E2BIG;\n\tgoto out;\n}", "target": 1}
{"code": "struct SWF_ACTIONPUSHPARAM * peek()\n{\n#ifdef DEBUG\n\tprintf(\"*peek*\\n\");\n#endif\n#ifdef DEBUGSTACK\t\t\n\tif( Stack == NULL ) push(newVar(\"\n#else\n\tif( Stack == NULL ) SWF_error(\"Stack blown!! - peek\");\n#endif\n\treturn Stack->val;\n}", "target": 0}
{"code": "static struct sctp_transport *sctp_trans_elect_tie(struct sctp_transport *trans1,\n\t\t\t\t\t\t   struct sctp_transport *trans2)\n{\n\tif (trans1->error_count > trans2->error_count) {\n\t\treturn trans2;\n\t} else if (trans1->error_count == trans2->error_count &&\n\t\t   ktime_after(trans2->last_time_heard,\n\t\t\t       trans1->last_time_heard)) {\n\t\treturn trans2;\n\t} else {\n\t\treturn trans1;\n\t}\n}", "target": 0}
{"code": "static unsigned int tun_chr_poll(struct file *file, poll_table * wait)\n{\n\tstruct tun_file *tfile = file->private_data;\n\tstruct tun_struct *tun = __tun_get(tfile);\n\tstruct sock *sk = tun->sk;\n\tunsigned int mask = 0;\n\tif (!tun)\n\t\treturn POLLERR;\n\tDBG(KERN_INFO \"%s: tun_chr_poll\\n\", tun->dev->name);\n\tpoll_wait(file, &tun->socket.wait, wait);\n\tif (!skb_queue_empty(&tun->readq))\n\t\tmask |= POLLIN | POLLRDNORM;\n\tif (sock_writeable(sk) ||\n\t    (!test_and_set_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags) &&\n\t     sock_writeable(sk)))\n\t\tmask |= POLLOUT | POLLWRNORM;\n\tif (tun->dev->reg_state != NETREG_REGISTERED)\n\t\tmask = POLLERR;\n\ttun_put(tun);\n\treturn mask;\n}", "target": 1}
{"code": "static inline void set_pte_at(struct mm_struct *mm, unsigned long addr,\n\t\t\t      pte_t *ptep, pte_t pte)\n{\n\tif (pte_valid_ng(pte)) {\n\t\tif (!pte_special(pte) && pte_exec(pte))\n\t\t\t__sync_icache_dcache(pte, addr);\n\t\tif (pte_dirty(pte) && pte_write(pte))\n\t\t\tpte_val(pte) &= ~PTE_RDONLY;\n\t\telse\n\t\t\tpte_val(pte) |= PTE_RDONLY;\n\t}\n\tset_pte(ptep, pte);\n}", "target": 1}
{"code": "TfLiteTensor* GetVariableInput(TfLiteContext* context, const TfLiteNode* node,\n                               int index) {\n  TfLiteTensor* tensor = GetMutableInput(context, node, index);\n  return tensor->is_variable ? tensor : nullptr;\n}", "target": 1}
{"code": "int do_truncate(struct dentry *dentry, loff_t length, unsigned int time_attrs,\n\tstruct file *filp)\n{\n\tint err;\n\tstruct iattr newattrs;\n\tif (length < 0)\n\t\treturn -EINVAL;\n\tnewattrs.ia_size = length;\n\tnewattrs.ia_valid = ATTR_SIZE | time_attrs;\n\tif (filp) {\n\t\tnewattrs.ia_file = filp;\n\t\tnewattrs.ia_valid |= ATTR_FILE;\n\t}\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\terr = notify_change(dentry, &newattrs);\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\treturn err;\n}", "target": 1}
{"code": "void __refill_cfs_bandwidth_runtime(struct cfs_bandwidth *cfs_b)\n{\n\tu64 now;\n\tif (cfs_b->quota == RUNTIME_INF)\n\t\treturn;\n\tnow = sched_clock_cpu(smp_processor_id());\n\tcfs_b->runtime = cfs_b->quota;\n\tcfs_b->runtime_expires = now + ktime_to_ns(cfs_b->period);\n\tcfs_b->expires_seq++;\n}", "target": 1}
{"code": "static int komeda_wb_connector_add(struct komeda_kms_dev *kms,\n\t\t\t\t   struct komeda_crtc *kcrtc)\n{\n\tstruct komeda_dev *mdev = kms->base.dev_private;\n\tstruct komeda_wb_connector *kwb_conn;\n\tstruct drm_writeback_connector *wb_conn;\n\tu32 *formats, n_formats = 0;\n\tint err;\n\tif (!kcrtc->master->wb_layer)\n\t\treturn 0;\n\tkwb_conn = kzalloc(sizeof(*kwb_conn), GFP_KERNEL);\n\tif (!kwb_conn)\n\t\treturn -ENOMEM;\n\tkwb_conn->wb_layer = kcrtc->master->wb_layer;\n\twb_conn = &kwb_conn->base;\n\twb_conn->encoder.possible_crtcs = BIT(drm_crtc_index(&kcrtc->base));\n\tformats = komeda_get_layer_fourcc_list(&mdev->fmt_tbl,\n\t\t\t\t\t       kwb_conn->wb_layer->layer_type,\n\t\t\t\t\t       &n_formats);\n\terr = drm_writeback_connector_init(&kms->base, wb_conn,\n\t\t\t\t\t   &komeda_wb_connector_funcs,\n\t\t\t\t\t   &komeda_wb_encoder_helper_funcs,\n\t\t\t\t\t   formats, n_formats);\n\tkomeda_put_fourcc_list(formats);\n\tif (err)\n\t\treturn err;\n\tdrm_connector_helper_add(&wb_conn->base, &komeda_wb_conn_helper_funcs);\n\tkcrtc->wb_conn = kwb_conn;\n\treturn 0;\n}", "target": 1}
{"code": "int read_file(struct sc_card *card, char *str_path, unsigned char **data, size_t *data_len)\n{\n\tstruct sc_path path;\n\tstruct sc_file *file;\n\tunsigned char *p;\n\tint ok = 0;\n\tint r;\n\tsize_t len;\n\tsc_format_path(str_path, &path);\n\tif (SC_SUCCESS != sc_select_file(card, &path, &file)) {\n\t\tgoto err;\n\t}\n\tlen = file && file->size > 0 ? file->size : 4096;\n\tp = realloc(*data, len);\n\tif (!p) {\n\t\tgoto err;\n\t}\n\t*data = p;\n\t*data_len = len;\n\tr = sc_read_binary(card, 0, p, len, 0);\n\tif (r < 0)\n\t\tgoto err;\n\t*data_len = r;\n\tok = 1;\nerr:\n\tsc_file_free(file);\n\treturn ok;\n}", "target": 0}
{"code": "int install_process_keyring_to_cred(struct cred *new)\n{\n\tstruct key *keyring;\n\tif (new->process_keyring)\n\t\treturn -EEXIST;\n\tkeyring = keyring_alloc(\"_pid\", new->uid, new->gid, new,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN,\n\t\t\t\tNULL, NULL);\n\tif (IS_ERR(keyring))\n\t\treturn PTR_ERR(keyring);\n\tnew->process_keyring = keyring;\n\treturn 0;\n}", "target": 1}
{"code": "static int decode_secinfo_common(struct xdr_stream *xdr, struct nfs4_secinfo_res *res)\n{\n\tstruct nfs4_secinfo_flavor *sec_flavor;\n\tint status;\n\t__be32 *p;\n\tint i, num_flavors;\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\tgoto out_overflow;\n\tres->flavors->num_flavors = 0;\n\tnum_flavors = be32_to_cpup(p);\n\tfor (i = 0; i < num_flavors; i++) {\n\t\tsec_flavor = &res->flavors->flavors[i];\n\t\tif ((char *)&sec_flavor[1] - (char *)res->flavors > PAGE_SIZE)\n\t\t\tbreak;\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\tgoto out_overflow;\n\t\tsec_flavor->flavor = be32_to_cpup(p);\n\t\tif (sec_flavor->flavor == RPC_AUTH_GSS) {\n\t\t\tstatus = decode_secinfo_gss(xdr, sec_flavor);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t}\n\t\tres->flavors->num_flavors++;\n\t}\n\tstatus = 0;\nout:\n\treturn status;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}", "target": 0}
{"code": "find_extend_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma, *prev;\n\taddr &= PAGE_MASK;\n\tvma = find_vma_prev(mm, addr, &prev);\n\tif (vma && (vma->vm_start <= addr))\n\t\treturn vma;\n\tif (!prev || expand_stack(prev, addr))\n\t\treturn NULL;\n\tif (prev->vm_flags & VM_LOCKED)\n\t\tpopulate_vma_page_range(prev, addr, prev->vm_end, NULL);\n\treturn prev;\n}", "target": 1}
{"code": "gopherHTMLFooter(StoreEntry * e)\n{\n    storeAppendPrintf(e, \"<HR noshade size=\\\"1px\\\">\\n\");\n    storeAppendPrintf(e, \"<ADDRESS>\\n\");\n    storeAppendPrintf(e, \"Generated %s by %s (%s)\\n\",\n                      Time::FormatRfc1123(squid_curtime),\n                      getMyHostname(),\n                      visible_appname_string);\n    storeAppendPrintf(e, \"</ADDRESS></BODY></HTML>\\n\");\n}", "target": 1}
{"code": "__attribute__((__always_inline__)) static inline void create_v4_hdr(\n    struct iphdr* iph,\n    __u8 tos,\n    __u32 saddr,\n    __u32 daddr,\n    __u16 pkt_bytes,\n    __u8 proto) {\n  __u64 csum = 0;\n  iph->version = 4;\n  iph->ihl = 5;\n  iph->frag_off = 0;\n  iph->protocol = proto;\n  iph->check = 0;\n#ifdef COPY_INNER_PACKET_TOS\n  iph->tos = tos;\n#else\n  iph->tos = DEFAULT_TOS;\n#endif\n  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));\n  iph->id = 0;\n  iph->daddr = daddr;\n  iph->saddr = saddr;\n  iph->ttl = DEFAULT_TTL;\n  ipv4_csum_inline(iph, &csum);\n  iph->check = csum;\n}", "target": 0}
{"code": "long keyctl_describe_key(key_serial_t keyid,\n\t\t\t char __user *buffer,\n\t\t\t size_t buflen)\n{\n\tstruct key *key, *instkey;\n\tkey_ref_t key_ref;\n\tchar *infobuf;\n\tlong ret;\n\tint desclen, infolen;\n\tkey_ref = lookup_user_key(keyid, KEY_LOOKUP_PARTIAL, KEY_NEED_VIEW);\n\tif (IS_ERR(key_ref)) {\n\t\tif (PTR_ERR(key_ref) == -EACCES) {\n\t\t\tinstkey = key_get_instantiation_authkey(keyid);\n\t\t\tif (!IS_ERR(instkey)) {\n\t\t\t\tkey_put(instkey);\n\t\t\t\tkey_ref = lookup_user_key(keyid,\n\t\t\t\t\t\t\t  KEY_LOOKUP_PARTIAL,\n\t\t\t\t\t\t\t  0);\n\t\t\t\tif (!IS_ERR(key_ref))\n\t\t\t\t\tgoto okay;\n\t\t\t}\n\t\t}\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\nokay:\n\tkey = key_ref_to_ptr(key_ref);\n\tdesclen = strlen(key->description);\n\tret = -ENOMEM;\n\tinfobuf = kasprintf(GFP_KERNEL,\n\t\t\t    \"%s;%d;%d;%08x;\",\n\t\t\t    key->type->name,\n\t\t\t    from_kuid_munged(current_user_ns(), key->uid),\n\t\t\t    from_kgid_munged(current_user_ns(), key->gid),\n\t\t\t    key->perm);\n\tif (!infobuf)\n\t\tgoto error2;\n\tinfolen = strlen(infobuf);\n\tret = infolen + desclen + 1;\n\tif (buffer && buflen >= ret) {\n\t\tif (copy_to_user(buffer, infobuf, infolen) != 0 ||\n\t\t    copy_to_user(buffer + infolen, key->description,\n\t\t\t\t desclen + 1) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tkfree(infobuf);\nerror2:\n\tkey_ref_put(key_ref);\nerror:\n\treturn ret;\n}", "target": 0}
{"code": "static void flush_change(H264Context *h)\n{\n    int i, j;\n    h->outputed_poc          = h->next_outputed_poc = INT_MIN;\n    h->prev_interlaced_frame = 1;\n    idr(h);\n    h->prev_frame_num = -1;\n    if (h->cur_pic_ptr) {\n        h->cur_pic_ptr->reference = 0;\n        for (j=i=0; h->delayed_pic[i]; i++)\n            if (h->delayed_pic[i] != h->cur_pic_ptr)\n                h->delayed_pic[j++] = h->delayed_pic[i];\n        h->delayed_pic[j] = NULL;\n    }\n    h->first_field = 0;\n    memset(h->ref_list[0], 0, sizeof(h->ref_list[0]));\n    memset(h->ref_list[1], 0, sizeof(h->ref_list[1]));\n    memset(h->default_ref_list[0], 0, sizeof(h->default_ref_list[0]));\n    memset(h->default_ref_list[1], 0, sizeof(h->default_ref_list[1]));\n    ff_h264_reset_sei(h);\n    h->recovery_frame = -1;\n    h->frame_recovered = 0;\n    h->list_count = 0;\n    h->current_slice = 0;\n    h->mmco_reset = 1;\n}", "target": 0}
{"code": "static int chdir_to_parent(char *copy, const char **lastp)\n{\n\tchar *tmp;\n\tconst char *parent;\n\tchar buf[65536];\n\tint res;\n\ttmp = strrchr(copy, '/');\n\tif (tmp == NULL || tmp[1] == '\\0') {\n\t\tfprintf(stderr, \"%s: internal error: invalid abs path: <%s>\\n\",\n\t\t\tprogname, copy);\n\t\treturn -1;\n\t}\n\tif (tmp != copy) {\n\t\t*tmp = '\\0';\n\t\tparent = copy;\n\t\t*lastp = tmp + 1;\n\t} else if (tmp[1] != '\\0') {\n\t\t*lastp = tmp + 1;\n\t\tparent = \"/\";\n\t} else {\n\t\t*lastp = \".\";\n\t\tparent = \"/\";\n\t}\n\tres = chdir(parent);\n\tif (res == -1) {\n\t\tfprintf(stderr, \"%s: failed to chdir to %s: %s\\n\",\n\t\t\tprogname, parent, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (getcwd(buf, sizeof(buf)) == NULL) {\n\t\tfprintf(stderr, \"%s: failed to obtain current directory: %s\\n\",\n\t\t\tprogname, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (strcmp(buf, parent) != 0) {\n\t\tfprintf(stderr, \"%s: mountpoint moved (%s -> %s)\\n\", progname,\n\t\t\tparent, buf);\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int verify_newpolicy_info(struct xfrm_userpolicy_info *p)\n{\n\tint ret;\n\tswitch (p->share) {\n\tcase XFRM_SHARE_ANY:\n\tcase XFRM_SHARE_SESSION:\n\tcase XFRM_SHARE_USER:\n\tcase XFRM_SHARE_UNIQUE:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tswitch (p->action) {\n\tcase XFRM_POLICY_ALLOW:\n\tcase XFRM_POLICY_BLOCK:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tswitch (p->sel.family) {\n\tcase AF_INET:\n\t\tif (p->sel.prefixlen_d > 32 || p->sel.prefixlen_s > 32)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AF_INET6:\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tif (p->sel.prefixlen_d > 128 || p->sel.prefixlen_s > 128)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n#else\n\t\treturn  -EAFNOSUPPORT;\n#endif\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tret = verify_policy_dir(p->dir);\n\tif (ret)\n\t\treturn ret;\n\tif (p->index && ((p->index & XFRM_POLICY_MAX) != p->dir))\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 1}
{"code": "_gnutls_x509_decode_string(unsigned int etype,\n\t\t\t   const uint8_t * der, size_t der_size,\n\t\t\t   gnutls_datum_t * output, unsigned allow_ber)\n{\n\tint ret;\n\tuint8_t *str;\n\tunsigned int str_size, len;\n\tgnutls_datum_t td;\n#ifdef HAVE_ASN1_DECODE_SIMPLE_BER\n\tif (allow_ber)\n\t\tret =\n\t\t    asn1_decode_simple_ber(etype, der, der_size, &str, &str_size, NULL);\n\telse\n#endif\n\t\tret =\n\t\t    asn1_decode_simple_der(etype, der, der_size, (const uint8_t**)&str, &str_size);\n\tif (ret != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\tret = _gnutls_asn2err(ret);\n\t\treturn ret;\n\t}\n\ttd.size = str_size;\n\ttd.data = gnutls_malloc(str_size + 1);\n\tif (td.data == NULL)\n\t\treturn gnutls_assert_val(GNUTLS_E_MEMORY_ERROR);\n\tmemcpy(td.data, str, str_size);\n\ttd.data[str_size] = 0;\n#ifdef HAVE_ASN1_DECODE_SIMPLE_BER\n\tif (allow_ber)\n\t\tfree(str);\n#endif\n\tret = make_printable_string(etype, &td, output);\n\tif (ret == GNUTLS_E_INVALID_REQUEST) {\t\n\t\toutput->data = td.data;\n\t\toutput->size = td.size;\n\t\tret = 0;\n\t} else if (ret <= 0) {\n\t\t_gnutls_free_datum(&td);\n\t}\n\tif (etype != ASN1_ETYPE_OCTET_STRING) {\n\t\tif (output->data)\n\t\t\tlen = strlen((void *) output->data);\n\t\telse\n\t\t\tlen = 0;\n\t\tif (len != (size_t) output->size) {\n\t\t\t_gnutls_free_datum(output);\n\t\t\tret = gnutls_assert_val(GNUTLS_E_ASN1_DER_ERROR);\n\t\t}\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "completion_glob_pattern (string)\n     char *string;\n{\n  register int c;\n  char *send;\n  int open;\n  DECLARE_MBSTATE;\n  open = 0;\n  send = string + strlen (string);\n  while (c = *string++)\n    {\n      switch (c)\n\t{\n\tcase '?':\n\tcase '*':\n\t  return (1);\n\tcase '[':\n\t  open++;\n\t  continue;\n\tcase ']':\n\t  if (open)\n\t    return (1);\n\t  continue;\n\tcase '+':\n\tcase '@':\n\tcase '!':\n\t  if (*string == '(')\t\n\t    return (1);\n\t  continue;\n\tcase '\\\\':\n\t  if (*string++ == 0)\n\t    return (0);\n\t}\n#ifdef HANDLE_MULTIBYTE\n      string--;\n      ADVANCE_CHAR_P (string, send - string);\n      string++;\n#else\n      ADVANCE_CHAR_P (string, send - string);\n#endif\n    }\n  return (0);\n}", "target": 1}
{"code": "void put_filp(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tsecurity_file_free(file);\n\t\tfile_sb_list_del(file);\n\t\tfile_free(file);\n\t}\n}", "target": 1}
{"code": "authdir_wants_to_reject_router(routerinfo_t *ri, const char **msg,\n                               int complain, int *valid_out)\n{\n  time_t now;\n  int severity = (complain && ri->contact_info) ? LOG_NOTICE : LOG_INFO;\n  uint32_t status = dirserv_router_get_status(ri, msg, severity);\n  tor_assert(msg);\n  if (status & FP_REJECT)\n    return -1; \n  now = time(NULL);\n  if (ri->cache_info.published_on > now+ROUTER_ALLOW_SKEW) {\n    log_fn(severity, LD_DIRSERV, \"Publication time for %s is too \"\n           \"far (%d minutes) in the future; possible clock skew. Not adding \"\n           \"(%s)\",\n           router_describe(ri),\n           (int)((ri->cache_info.published_on-now)/60),\n           esc_router_info(ri));\n    *msg = \"Rejected: Your clock is set too far in the future, or your \"\n      \"timezone is not correct.\";\n    return -1;\n  }\n  if (ri->cache_info.published_on < now-ROUTER_MAX_AGE_TO_PUBLISH) {\n    log_fn(severity, LD_DIRSERV,\n           \"Publication time for %s is too far \"\n           \"(%d minutes) in the past. Not adding (%s)\",\n           router_describe(ri),\n           (int)((now-ri->cache_info.published_on)/60),\n           esc_router_info(ri));\n    *msg = \"Rejected: Server is expired, or your clock is too far in the past,\"\n      \" or your timezone is not correct.\";\n    return -1;\n  }\n  if (dirserv_router_has_valid_address(ri) < 0) {\n    log_fn(severity, LD_DIRSERV,\n           \"Router %s has invalid address. Not adding (%s).\",\n           router_describe(ri),\n           esc_router_info(ri));\n    *msg = \"Rejected: Address is a private address.\";\n    return -1;\n  }\n  *valid_out = ! (status & FP_INVALID);\n  return 0;\n}", "target": 0}
{"code": "http_DissectRequest(struct sess *sp)\n{\n\tstruct http_conn *htc;\n\tstruct http *hp;\n\tuint16_t retval;\n\tCHECK_OBJ_NOTNULL(sp, SESS_MAGIC);\n\thtc = sp->htc;\n\tCHECK_OBJ_NOTNULL(htc, HTTP_CONN_MAGIC);\n\thp = sp->http;\n\tCHECK_OBJ_NOTNULL(hp, HTTP_MAGIC);\n\thp->logtag = HTTP_Rx;\n\tretval = http_splitline(sp->wrk, sp->fd, hp, htc,\n\t    HTTP_HDR_REQ, HTTP_HDR_URL, HTTP_HDR_PROTO);\n\tif (retval != 0) {\n\t\tWSPR(sp, SLT_HttpGarbage, htc->rxbuf);\n\t\treturn (retval);\n\t}\n\thttp_ProtoVer(hp);\n\tretval = htc_request_check_host_hdr(hp);\n\tif (retval != 0) {\n\t\tWSP(sp, SLT_Error, \"Duplicated Host header\");\n\t\treturn (retval);\n\t}\n\treturn (retval);\n}", "target": 1}
{"code": "void fib6_run_gc(unsigned long expires, struct net *net)\n{\n\tif (expires != ~0UL) {\n\t\tspin_lock_bh(&fib6_gc_lock);\n\t\tgc_args.timeout = expires ? (int)expires :\n\t\t\tnet->ipv6.sysctl.ip6_rt_gc_interval;\n\t} else {\n\t\tif (!spin_trylock_bh(&fib6_gc_lock)) {\n\t\t\tmod_timer(&net->ipv6.ip6_fib_timer, jiffies + HZ);\n\t\t\treturn;\n\t\t}\n\t\tgc_args.timeout = net->ipv6.sysctl.ip6_rt_gc_interval;\n\t}\n\tgc_args.more = icmp6_dst_gc();\n\tfib6_clean_all(net, fib6_age, 0, NULL);\n\tif (gc_args.more)\n\t\tmod_timer(&net->ipv6.ip6_fib_timer,\n\t\t\t  round_jiffies(jiffies\n\t\t\t\t\t+ net->ipv6.sysctl.ip6_rt_gc_interval));\n\telse\n\t\tdel_timer(&net->ipv6.ip6_fib_timer);\n\tspin_unlock_bh(&fib6_gc_lock);\n}", "target": 0}
{"code": "BGD_DECLARE(void *) gdImageWebpPtr (gdImagePtr im, int *size)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) {\n\t\treturn NULL;\n\t}\n\tgdImageWebpCtx(im, out, -1);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\treturn rv;\n}", "target": 1}
{"code": "void PacketReader::copyRecord(unsigned char* dest, uint16_t len)\n{\n  if(d_pos + len > d_content.size())\n    throw std::out_of_range(\"Attempt to copy outside of packet\");\n  memcpy(dest, &d_content.at(d_pos), len);\n  d_pos+=len;\n}", "target": 0}
{"code": "agoo_http_init() {\n    const char\t**kp = header_keys;\n    memset(&key_cache, 0, sizeof(struct _cache));\n    for (; NULL != *kp; kp++) {\n\tkey_set(*kp);\n    }\n}", "target": 1}
{"code": "void setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !inode_capable(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}", "target": 1}
{"code": "register_commands (assuan_context_t ctx)\n{\n  static struct {\n    const char *name;\n    assuan_handler_t handler;\n    const char * const help;\n  } table[] = {\n    { \"SERIALNO\",     cmd_serialno, hlp_serialno },\n    { \"LEARN\",        cmd_learn,    hlp_learn },\n    { \"READCERT\",     cmd_readcert, hlp_readcert },\n    { \"READKEY\",      cmd_readkey,  hlp_readkey },\n    { \"SETDATA\",      cmd_setdata,  hlp_setdata },\n    { \"PKSIGN\",       cmd_pksign,   hlp_pksign },\n    { \"PKAUTH\",       cmd_pkauth,   hlp_pkauth },\n    { \"PKDECRYPT\",    cmd_pkdecrypt,hlp_pkdecrypt },\n    { \"INPUT\",        NULL },\n    { \"OUTPUT\",       NULL },\n    { \"GETATTR\",      cmd_getattr,  hlp_getattr },\n    { \"SETATTR\",      cmd_setattr,  hlp_setattr },\n    { \"WRITECERT\",    cmd_writecert,hlp_writecert },\n    { \"WRITEKEY\",     cmd_writekey, hlp_writekey },\n    { \"GENKEY\",       cmd_genkey,   hlp_genkey },\n    { \"RANDOM\",       cmd_random,   hlp_random },\n    { \"PASSWD\",       cmd_passwd,   hlp_passwd },\n    { \"CHECKPIN\",     cmd_checkpin, hlp_checkpin },\n    { \"LOCK\",         cmd_lock,     hlp_lock },\n    { \"UNLOCK\",       cmd_unlock,   hlp_unlock },\n    { \"GETINFO\",      cmd_getinfo,  hlp_getinfo },\n    { \"RESTART\",      cmd_restart,  hlp_restart },\n    { \"DISCONNECT\",   cmd_disconnect,hlp_disconnect },\n    { \"APDU\",         cmd_apdu,     hlp_apdu },\n    { \"KILLSCD\",      cmd_killscd,  hlp_killscd },\n    { NULL }\n  };\n  int i, rc;\n  for (i=0; table[i].name; i++)\n    {\n      rc = assuan_register_command (ctx, table[i].name, table[i].handler,\n                                    table[i].help);\n      if (rc)\n        return rc;\n    }\n  assuan_set_hello_line (ctx, \"GNU Privacy Guard's Smartcard server ready\");\n  assuan_register_reset_notify (ctx, reset_notify);\n  assuan_register_option_handler (ctx, option_handler);\n  return 0;\n}", "target": 0}
{"code": "parse_emph1(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size, uint8_t c)\n{\n\tsize_t i = 0, len;\n\tstruct buf *work = 0;\n\tint r;\n\tif (size > 1 && data[0] == c && data[1] == c) i = 1;\n\twhile (i < size) {\n\t\tlen = find_emph_char(data + i, size - i, c);\n\t\tif (!len) return 0;\n\t\ti += len;\n\t\tif (i >= size) return 0;\n\t\tif (data[i] == c && !_isspace(data[i - 1])) {\n\t\t\tif (rndr->ext_flags & MKDEXT_NO_INTRA_EMPHASIS) {\n\t\t\t\tif (i + i < size && _isalnum(data[i + 1]))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twork = rndr_newbuf(rndr, BUFFER_SPAN);\n\t\t\tparse_inline(work, rndr, data, i);\n\t\t\tif (rndr->ext_flags & MKDEXT_UNDERLINE && c == '_')\n\t\t\t\tr = rndr->cb.underline(ob, work, rndr->opaque);\n\t\t\telse\n\t\t\t\tr = rndr->cb.emphasis(ob, work, rndr->opaque);\n\t\t\trndr_popbuf(rndr, BUFFER_SPAN);\n\t\t\treturn r ? i + 1 : 0;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int gdAlphaOverlayColor (int src, int dst, int max )\n{\n\tdst = dst << 1;\n\tif( dst > max ) {\n\t\treturn dst + (src << 1) - (dst * src / max) - max;\n\t} else {\n\t\treturn dst * src / max;\n\t}\n}", "target": 0}
{"code": "static cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)\n{\n    cJSON *current_element = NULL;\n    if ((object == NULL) || (name == NULL))\n    {\n        return NULL;\n    }\n    current_element = object->child;\n    if (case_sensitive)\n    {\n        while ((current_element != NULL) && (strcmp(name, current_element->string) != 0))\n        {\n            current_element = current_element->next;\n        }\n    }\n    else\n    {\n        while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))\n        {\n            current_element = current_element->next;\n        }\n    }\n    return current_element;\n}", "target": 1}
{"code": "static inline bool is_exception(u32 intr_info)\n{\n\treturn (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VALID_MASK))\n\t\t== (INTR_TYPE_HARD_EXCEPTION | INTR_INFO_VALID_MASK);\n}", "target": 1}
{"code": "static int vsock_create(struct net *net, struct socket *sock,\n\t\t\tint protocol, int kern)\n{\n\tif (!sock)\n\t\treturn -EINVAL;\n\tif (protocol && protocol != PF_VSOCK)\n\t\treturn -EPROTONOSUPPORT;\n\tswitch (sock->type) {\n\tcase SOCK_DGRAM:\n\t\tsock->ops = &vsock_dgram_ops;\n\t\tbreak;\n\tcase SOCK_STREAM:\n\t\tsock->ops = &vsock_stream_ops;\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\tsock->state = SS_UNCONNECTED;\n\treturn __vsock_create(net, sock, NULL, GFP_KERNEL, 0) ? 0 : -ENOMEM;\n}", "target": 0}
{"code": "static void do_tx_packet(lan9118_state *s)\n{\n    int n;\n    uint32_t status;\n    if (s->phy_control & 0x4000)  {\n        lan9118_receive(qemu_get_queue(s->nic), s->txp->data, s->txp->len);\n    } else {\n        qemu_send_packet(qemu_get_queue(s->nic), s->txp->data, s->txp->len);\n    }\n    s->txp->fifo_used = 0;\n    if (s->tx_status_fifo_used == 512) {\n        return;\n    }\n    status = s->txp->cmd_b & 0xffff0000u;\n    DPRINTF(\"Sent packet tag:%04x len %d\\n\", status >> 16, s->txp->len);\n    n = (s->tx_status_fifo_head + s->tx_status_fifo_used) & 511;\n    s->tx_status_fifo[n] = status;\n    s->tx_status_fifo_used++;\n    if (s->tx_status_fifo_used == 512) {\n        s->int_sts |= TSFF_INT;\n    }\n}", "target": 1}
{"code": "Status ImportNodes(ValueMapManager value_manager,\n                   const RepeatedPtrField<NodeDef>& nodes, OpBuilder& builder) {\n  Location unknown_loc = builder.getUnknownLoc();\n  MLIRContext* context = builder.getContext();\n  Type placeholder_ty = OpaqueTensorType::get(context);\n  Type control_ty = ControlType::get(context);\n  TFGraphDialect* tfgDialect =\n      cast<TFGraphDialect>(context->getLoadedDialect(\"tfg\"));\n  StringAttr device_attr = tfgDialect->getDeviceAttrIdentifier();\n  StringAttr name_attr = tfgDialect->getNameAttrIdentifier();\n  StringAttr fulltype_attr = tfgDialect->getFullTypeAttrIdentifier();\n  for (const NodeDef& node : nodes) {\n    DVLOG(1) << \"Processing node \" << node.name() << \"\\n\";\n    if (node.op().empty()) return InvalidArgument(\"empty op type\");\n    OperationState state(unknown_loc, absl::StrCat(\"tfg.\", node.op()));\n    for (const std::string& input : node.input()) {\n      if (input.empty())\n        return InvalidArgument(\"Node '\", node.name(), \"' has an empty input\");\n      state.operands.push_back(\n          value_manager.GetValueOrCreatePlaceholder(input));\n    }\n    state.types.push_back(placeholder_ty);\n    state.types.push_back(control_ty);\n    for (const auto& namedAttr : node.attr()) {\n      const std::string& name = namedAttr.first;\n      const AttrValue& tf_attr = namedAttr.second;\n      TF_ASSIGN_OR_RETURN(Attribute attr,\n                          ConvertAttributeValue(tf_attr, builder));\n      state.addAttribute(name, attr);\n    }\n    if (!node.device().empty())\n      state.addAttribute(device_attr, StringAttr::get(context, node.device()));\n    if (!node.name().empty())\n      state.addAttribute(name_attr, StringAttr::get(context, node.name()));\n    if (node.has_experimental_type()) {\n      TF_ASSIGN_OR_RETURN(tf_type::FullTypeAttr type,\n                          ConvertAttribute(node.experimental_type(), builder));\n      state.addAttribute(fulltype_attr, type);\n    }\n    Operation* op = builder.create(state);\n    StringRef node_name = node.name();\n    {\n      size_t colon_sep = node_name.find_first_of(':');\n      if (colon_sep != StringRef::npos)\n        node_name = node_name.take_front(colon_sep);\n    }\n    TF_RETURN_IF_ERROR(value_manager.DefineOperation(op, node_name));\n  }\n  for (Operation& op : *builder.getInsertionBlock()) {\n    if (op.getName().getStringRef() == \"tfg.__mlir_placeholder\") {\n      return InvalidArgument(absl::StrCat(\n          \"Couldn't import graph: placeholder left \",\n          op.getAttrOfType<StringAttr>(name_attr).getValue().str()));\n    }\n  }\n  return ::tensorflow::OkStatus();\n}", "target": 1}
{"code": "DataObjectItem::DataObjectItem(ItemKind kind,\n                               const String& type,\n                               uint64_t sequence_number)\n    : source_(kClipboardSource),\n      kind_(kind),\n      type_(type),\n      sequence_number_(sequence_number) {}", "target": 0}
{"code": "    inline bool match(const EndpointSecurityAttributesMask remoteMask,\n        const PluginEndpointSecurityAttributesMask remotePluginMask) const\n    {\n        return security_mask_matches(mask(), remoteMask) &&\n            security_mask_matches(plugin_endpoint_attributes, remotePluginMask);\n    }", "target": 1}
{"code": "static int rtnl_group_dellink(const struct net *net, int group)\n{\n\tstruct net_device *dev, *aux;\n\tLIST_HEAD(list_kill);\n\tbool found = false;\n\tif (!group)\n\t\treturn -EPERM;\n\tfor_each_netdev(net, dev) {\n\t\tif (dev->group == group) {\n\t\t\tconst struct rtnl_link_ops *ops;\n\t\t\tfound = true;\n\t\t\tops = dev->rtnl_link_ops;\n\t\t\tif (!ops || !ops->dellink)\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\tif (!found)\n\t\treturn -ENODEV;\n\tfor_each_netdev_safe(net, dev, aux) {\n\t\tif (dev->group == group) {\n\t\t\tconst struct rtnl_link_ops *ops;\n\t\t\tops = dev->rtnl_link_ops;\n\t\t\tops->dellink(dev, &list_kill);\n\t\t}\n\t}\n\tunregister_netdevice_many(&list_kill);\n\treturn 0;\n}", "target": 0}
{"code": "void fmtutil_macbitmap_read_pixmap_only_fields(deark *c, dbuf *f, struct fmtutil_macbitmap_info *bi,\n\ti64 pos)\n{\n\ti64 pixmap_version;\n\ti64 pack_size;\n\ti64 plane_bytes;\n\ti64 n;\n\tde_dbg(c, \"additional PixMap header fields, at %d\", (int)pos);\n\tde_dbg_indent(c, 1);\n\tpixmap_version = dbuf_getu16be(f, pos+0);\n\tde_dbg(c, \"pixmap version: %d\", (int)pixmap_version);\n\tbi->packing_type = dbuf_getu16be(f, pos+2);\n\tde_dbg(c, \"packing type: %d\", (int)bi->packing_type);\n\tpack_size = dbuf_getu32be(f, pos+4);\n\tde_dbg(c, \"pixel data length: %d\", (int)pack_size);\n\tbi->hdpi = pict_read_fixed(f, pos+8);\n\tbi->vdpi = pict_read_fixed(f, pos+12);\n\tde_dbg(c, \"dpi: %.2f\"DE_CHAR_TIMES\"%.2f\", bi->hdpi, bi->vdpi);\n\tbi->pixeltype = dbuf_getu16be(f, pos+16);\n\tbi->pixelsize = dbuf_getu16be(f, pos+18);\n\tbi->cmpcount = dbuf_getu16be(f, pos+20);\n\tbi->cmpsize = dbuf_getu16be(f, pos+22);\n\tde_dbg(c, \"pixel type=%d, bits/pixel=%d, components/pixel=%d, bits/comp=%d\",\n\t\t(int)bi->pixeltype, (int)bi->pixelsize, (int)bi->cmpcount, (int)bi->cmpsize);\n\tbi->pdwidth = (bi->rowbytes*8)/bi->pixelsize;\n\tif(bi->pdwidth < bi->npwidth) {\n\t\tbi->pdwidth = bi->npwidth;\n\t}\n\tplane_bytes = dbuf_getu32be(f, pos+24);\n\tde_dbg(c, \"plane bytes: %d\", (int)plane_bytes);\n\tbi->pmTable = (u32)dbuf_getu32be(f, pos+28);\n\tde_dbg(c, \"pmTable: 0x%08x\", (unsigned int)bi->pmTable);\n\tn = dbuf_getu32be(f, pos+32);\n\tde_dbg(c, \"pmReserved: 0x%08x\", (unsigned int)n);\n\tde_dbg_indent(c, -1);\n}", "target": 1}
{"code": "void nf_tables_activate_set(const struct nft_ctx *ctx, struct nft_set *set)\n{\n\tif (nft_set_is_anonymous(set))\n\t\tnft_clear(ctx->net, set);\n\tset->use++;\n}", "target": 0}
{"code": "size_t zmalloc_size(void *ptr) {\n    void *realptr = (char*)ptr-PREFIX_SIZE;\n    size_t size = *((size_t*)realptr);\n    if (size&(sizeof(long)-1)) size += sizeof(long)-(size&(sizeof(long)-1));\n    return size+PREFIX_SIZE;\n}", "target": 1}
{"code": "snmp_ber_decode_type(unsigned char *buff, uint32_t *buff_len, uint8_t *type)\n{\n  if(*buff_len == 0) {\n    return NULL;\n  }\n  *type = *buff++;\n  (*buff_len)--;\n  return buff;\n}", "target": 1}
{"code": "static int asf_build_simple_index(AVFormatContext *s, int stream_index)\n{\n    ff_asf_guid g;\n    ASFContext *asf     = s->priv_data;\n    int64_t current_pos = avio_tell(s->pb);\n    int64_t ret;\n    if((ret = avio_seek(s->pb, asf->data_object_offset + asf->data_object_size, SEEK_SET)) < 0) {\n        return ret;\n    }\n    if ((ret = ff_get_guid(s->pb, &g)) < 0)\n        goto end;\n    while (ff_guidcmp(&g, &ff_asf_simple_index_header)) {\n        int64_t gsize = avio_rl64(s->pb);\n        if (gsize < 24 || avio_feof(s->pb)) {\n            goto end;\n        }\n        avio_skip(s->pb, gsize - 24);\n        if ((ret = ff_get_guid(s->pb, &g)) < 0)\n            goto end;\n    }\n    {\n        int64_t itime, last_pos = -1;\n        int pct, ict;\n        int i;\n        int64_t av_unused gsize = avio_rl64(s->pb);\n        if ((ret = ff_get_guid(s->pb, &g)) < 0)\n            goto end;\n        itime = avio_rl64(s->pb);\n        pct   = avio_rl32(s->pb);\n        ict   = avio_rl32(s->pb);\n        av_log(s, AV_LOG_DEBUG,\n               \"itime:0x%\"PRIx64\", pct:%d, ict:%d\\n\", itime, pct, ict);\n        for (i = 0; i < ict; i++) {\n            int pktnum        = avio_rl32(s->pb);\n            int pktct         = avio_rl16(s->pb);\n            int64_t pos       = s->internal->data_offset + s->packet_size * (int64_t)pktnum;\n            int64_t index_pts = FFMAX(av_rescale(itime, i, 10000) - asf->hdr.preroll, 0);\n            if (pos != last_pos) {\n                av_log(s, AV_LOG_DEBUG, \"pktnum:%d, pktct:%d  pts: %\"PRId64\"\\n\",\n                       pktnum, pktct, index_pts);\n                av_add_index_entry(s->streams[stream_index], pos, index_pts,\n                                   s->packet_size, 0, AVINDEX_KEYFRAME);\n                last_pos = pos;\n            }\n        }\n        asf->index_read = ict > 1;\n    }\nend:\n    avio_seek(s->pb, current_pos, SEEK_SET);\n    return ret;\n}", "target": 1}
{"code": "void LibRaw::get_mem_image_format(int *width, int *height, int *colors,\n                                  int *bps) const\n{\n  if (S.flip & 4)\n  {\n    *width = S.height;\n    *height = S.width;\n  }\n  else\n  {\n    *width = S.width;\n    *height = S.height;\n  }\n  *colors = P1.colors;\n  *bps = O.output_bps;\n}", "target": 0}
{"code": "op_format(\n    oparg_T\t*oap,\n    int\t\tkeep_cursor)\t\t\n{\n    long\told_line_count = curbuf->b_ml.ml_line_count;\n    curwin->w_cursor = oap->cursor_start;\n    if (u_save((linenr_T)(oap->start.lnum - 1),\n\t\t\t\t       (linenr_T)(oap->end.lnum + 1)) == FAIL)\n\treturn;\n    curwin->w_cursor = oap->start;\n    if (oap->is_VIsual)\n\tredraw_curbuf_later(INVERTED);\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\tcurbuf->b_op_start = oap->start;\n    if (keep_cursor)\n\tsaved_cursor = oap->cursor_start;\n    format_lines(oap->line_count, keep_cursor);\n    if (oap->end_adjusted && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t++curwin->w_cursor.lnum;\n    beginline(BL_WHITE | BL_FIX);\n    old_line_count = curbuf->b_ml.ml_line_count - old_line_count;\n    msgmore(old_line_count);\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\tcurbuf->b_op_end = curwin->w_cursor;\n    if (keep_cursor)\n    {\n\tcurwin->w_cursor = saved_cursor;\n\tsaved_cursor.lnum = 0;\n    }\n    if (oap->is_VIsual)\n    {\n\twin_T\t*wp;\n\tFOR_ALL_WINDOWS(wp)\n\t{\n\t    if (wp->w_old_cursor_lnum != 0)\n\t    {\n\t\tif (wp->w_old_cursor_lnum > wp->w_old_visual_lnum)\n\t\t    wp->w_old_cursor_lnum += old_line_count;\n\t\telse\n\t\t    wp->w_old_visual_lnum += old_line_count;\n\t    }\n\t}\n    }\n}", "target": 1}
{"code": "static int __init cmdline_parse_core(char *p, unsigned long *core)\n{\n\tunsigned long long coremem;\n\tif (!p)\n\t\treturn -EINVAL;\n\tcoremem = memparse(p, &p);\n\t*core = coremem >> PAGE_SHIFT;\n\tWARN_ON((coremem >> PAGE_SHIFT) > ULONG_MAX);\n\treturn 0;\n}", "target": 0}
{"code": "  void AddInput(int node_index, int output_node, int output_index) {\n    CHECK_LT(node_index, nodes_.size());\n    nodes_[node_index].data_inputs.push_back(\n        std::make_pair(output_node, output_index));\n  }", "target": 0}
{"code": "static const char *req_canonical_filename_field(request_rec *r)\n{\n    return r->canonical_filename;\n}", "target": 0}
{"code": "static void* OGRExpatRealloc( void *ptr, size_t size )\n{\n    if( CanAlloc(size) )\n        return realloc(ptr, size);\n    free(ptr);\n    return nullptr;\n}", "target": 1}
{"code": "BufferedRandomDevice::BufferedRandomDevice(size_t bufferSize)\n  : bufferSize_(bufferSize),\n    buffer_(new unsigned char[bufferSize]),\n    ptr_(buffer_.get() + bufferSize) {  \n}", "target": 1}
{"code": "static void __account_cfs_rq_runtime(struct cfs_rq *cfs_rq, u64 delta_exec)\n{\n\tcfs_rq->runtime_remaining -= delta_exec;\n\texpire_cfs_rq_runtime(cfs_rq);\n\tif (likely(cfs_rq->runtime_remaining > 0))\n\t\treturn;\n\tif (!assign_cfs_rq_runtime(cfs_rq) && likely(cfs_rq->curr))\n\t\tresched_curr(rq_of(cfs_rq));\n}", "target": 1}
{"code": "int vp9_alloc_context_buffers(VP9_COMMON *cm, int width, int height) {\n  int new_mi_size;\n  vp9_set_mb_mi(cm, width, height);\n  new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);\n  if (cm->mi_alloc_size < new_mi_size) {\n    cm->free_mi(cm);\n    if (cm->alloc_mi(cm, new_mi_size)) goto fail;\n  }\n  if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {\n    free_seg_map(cm);\n    if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols)) goto fail;\n  }\n  if (cm->above_context_alloc_cols < cm->mi_cols) {\n    vpx_free(cm->above_context);\n    cm->above_context = (ENTROPY_CONTEXT *)vpx_calloc(\n        2 * mi_cols_aligned_to_sb(cm->mi_cols) * MAX_MB_PLANE,\n        sizeof(*cm->above_context));\n    if (!cm->above_context) goto fail;\n    vpx_free(cm->above_seg_context);\n    cm->above_seg_context = (PARTITION_CONTEXT *)vpx_calloc(\n        mi_cols_aligned_to_sb(cm->mi_cols), sizeof(*cm->above_seg_context));\n    if (!cm->above_seg_context) goto fail;\n    cm->above_context_alloc_cols = cm->mi_cols;\n  }\n  if (vp9_alloc_loop_filter(cm)) goto fail;\n  return 0;\nfail:\n  vp9_set_mb_mi(cm, 0, 0);\n  vp9_free_context_buffers(cm);\n  return 1;\n}", "target": 1}
{"code": "static int iommu_init_domains(struct intel_iommu *iommu)\n{\n\tu32 ndomains, nlongs;\n\tsize_t size;\n\tndomains = cap_ndoms(iommu->cap);\n\tpr_debug(\"%s: Number of Domains supported <%d>\\n\",\n\t\t iommu->name, ndomains);\n\tnlongs = BITS_TO_LONGS(ndomains);\n\tspin_lock_init(&iommu->lock);\n\tiommu->domain_ids = kcalloc(nlongs, sizeof(unsigned long), GFP_KERNEL);\n\tif (!iommu->domain_ids) {\n\t\tpr_err(\"%s: Allocating domain id array failed\\n\",\n\t\t       iommu->name);\n\t\treturn -ENOMEM;\n\t}\n\tsize = (ALIGN(ndomains, 256) >> 8) * sizeof(struct dmar_domain **);\n\tiommu->domains = kzalloc(size, GFP_KERNEL);\n\tif (iommu->domains) {\n\t\tsize = 256 * sizeof(struct dmar_domain *);\n\t\tiommu->domains[0] = kzalloc(size, GFP_KERNEL);\n\t}\n\tif (!iommu->domains || !iommu->domains[0]) {\n\t\tpr_err(\"%s: Allocating domain array failed\\n\",\n\t\t       iommu->name);\n\t\tkfree(iommu->domain_ids);\n\t\tkfree(iommu->domains);\n\t\tiommu->domain_ids = NULL;\n\t\tiommu->domains    = NULL;\n\t\treturn -ENOMEM;\n\t}\n\tset_bit(0, iommu->domain_ids);\n\treturn 0;\n}", "target": 0}
{"code": "static inline struct timespec ep_set_mstimeout(long ms)\n{\n\tstruct timespec now, ts = {\n\t\t.tv_sec = ms / MSEC_PER_SEC,\n\t\t.tv_nsec = NSEC_PER_MSEC * (ms % MSEC_PER_SEC),\n\t};\n\tktime_get_ts(&now);\n\treturn timespec_add_safe(now, ts);\n}", "target": 0}
{"code": "yy_symbol_print (FILE *yyo,\n                 yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep, YYLTYPE const * const yylocationp, void *parm)\n{\n  YYFPRINTF (yyo, \"%s %s (\",\n             yykind < YYNTOKENS ? \"token\" : \"nterm\", yysymbol_name (yykind));\n  YY_LOCATION_PRINT (yyo, *yylocationp);\n  YYFPRINTF (yyo, \": \");\n  yy_symbol_value_print (yyo, yykind, yyvaluep, yylocationp, parm);\n  YYFPRINTF (yyo, \")\");\n}", "target": 1}
{"code": "MOBI_RET mobi_trie_insert_infl(MOBITrie **root, const MOBIIndx *indx, size_t i) {\n    MOBIIndexEntry e = indx->entries[i];\n    char *inflected = e.label;\n    for (size_t j = 0; j < e.tags_count; j++) {\n        MOBIIndexTag t = e.tags[j];\n        if (t.tagid == INDX_TAGARR_INFL_PARTS_V1) {\n            for (size_t k = 0; k < t.tagvalues_count - 1; k += 2) {\n                uint32_t len = t.tagvalues[k];\n                uint32_t offset = t.tagvalues[k + 1];\n                char *base = mobi_get_cncx_string_flat(indx->cncx_record, offset, len);\n                if (base == NULL) {\n                    return MOBI_MALLOC_FAILED;\n                }\n                MOBI_RET ret = mobi_trie_insert_reversed(root, base, inflected);\n                free(base);\n                if (ret != MOBI_SUCCESS) {\n                    return ret;\n                }\n            }\n        }\n    }\n    return MOBI_SUCCESS;\n}", "target": 1}
{"code": "struct nfs_open_context *nfs_find_open_context(struct inode *inode, struct rpc_cred *cred, int mode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_open_context *pos, *ctx = NULL;\n\tspin_lock(&inode->i_lock);\n\tlist_for_each_entry(pos, &nfsi->open_files, list) {\n\t\tif (cred != NULL && pos->cred != cred)\n\t\t\tcontinue;\n\t\tif ((pos->mode & mode) == mode) {\n\t\t\tctx = get_nfs_open_context(pos);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn ctx;\n}", "target": 1}
{"code": "std::string GdkAtomToString(const GdkAtom& atom) {\n  gchar* name = gdk_atom_name(atom);\n  std::string rv(name);\n  g_free(name);\n  return rv;\n}", "target": 0}
{"code": "g_opendir(Char *str, glob_t *pglob)\n{\n    char buf[PATH_MAX];\n    if (!*str) {\n        buf[0] = '.';\n        buf[1] = 0;\n    } else {\n        if (g_Ctoc(str, buf, sizeof(buf))) {\n            return NULL;\n        }\n    }\n    if (pglob->gl_flags & GLOB_ALTDIRFUNC) {\n        return (*pglob->gl_opendir)(buf);\n    }\n    return opendir(buf);\n}", "target": 0}
{"code": "int pid_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct task_struct *task;\n\tconst struct cred *cred;\n\tstruct pid_namespace *pid = dentry->d_sb->s_fs_info;\n\tgeneric_fillattr(inode, stat);\n\trcu_read_lock();\n\tstat->uid = 0;\n\tstat->gid = 0;\n\ttask = pid_task(proc_pid(inode), PIDTYPE_PID);\n\tif (task) {\n\t\tif (!has_pid_permissions(pid, task, 2)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tif ((inode->i_mode == (S_IFDIR|S_IRUGO|S_IXUGO)) ||\n\t\t    task_dumpable(task)) {\n\t\t\tcred = __task_cred(task);\n\t\t\tstat->uid = cred->euid;\n\t\t\tstat->gid = cred->egid;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}", "target": 0}
{"code": "parsegid(const char *s, gid_t *gid)\n{\n\tstruct group *gr;\n\tconst char *errstr;\n\tif ((gr = getgrnam(s)) != NULL) {\n\t\t*gid = gr->gr_gid;\n\t\treturn 0;\n\t}\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\t*gid = strtonum(s, 0, GID_MAX, &errstr);\n\t#else\n\tsscanf(s, \"%d\", gid);\n\t#endif\n\tif (errstr)\n\t\treturn -1;\n\treturn 0;\n}", "target": 1}
{"code": "CharString *Formattable::internalGetCharString(UErrorCode &status) {\n    if(fDecimalStr == NULL) {\n      if (fDecimalQuantity == NULL) {\n        LocalPointer<DecimalQuantity> dq(new DecimalQuantity(), status);\n        if (U_FAILURE(status)) { return nullptr; }\n        populateDecimalQuantity(*dq, status);\n        if (U_FAILURE(status)) { return nullptr; }\n        fDecimalQuantity = dq.orphan();\n      }\n      fDecimalStr = new CharString();\n      if (fDecimalStr == NULL) {\n        status = U_MEMORY_ALLOCATION_ERROR;\n        return NULL;\n      }\n      if (fDecimalQuantity->isZero()) {\n        fDecimalStr->append(\"0\", -1, status);\n      } else if (std::abs(fDecimalQuantity->getMagnitude()) < 5) {\n        fDecimalStr->appendInvariantChars(fDecimalQuantity->toPlainString(), status);\n      } else {\n        fDecimalStr->appendInvariantChars(fDecimalQuantity->toScientificString(), status);\n      }\n    }\n    return fDecimalStr;\n}", "target": 1}
{"code": "static int ssl_get_remaining_space_in_datagram( mbedtls_ssl_context const *ssl )\n{\n    size_t const bytes_written = ssl->out_left;\n    size_t const mtu           = ssl_get_maximum_datagram_size( ssl );\n    if( bytes_written > mtu )\n    {\n        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n    }\n    return( (int) ( mtu - bytes_written ) );\n}", "target": 0}
{"code": "static int af9005_identify_state(struct usb_device *udev,\n\t\t\t\t struct dvb_usb_device_properties *props,\n\t\t\t\t struct dvb_usb_device_description **desc,\n\t\t\t\t int *cold)\n{\n\tint ret;\n\tu8 reply, *buf;\n\tbuf = kmalloc(FW_BULKOUT_SIZE + 2, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tret = af9005_boot_packet(udev, FW_CONFIG, &reply,\n\t\t\t\t buf, FW_BULKOUT_SIZE + 2);\n\tif (ret)\n\t\tgoto err;\n\tdeb_info(\"result of FW_CONFIG in identify state %d\\n\", reply);\n\tif (reply == 0x01)\n\t\t*cold = 1;\n\telse if (reply == 0x02)\n\t\t*cold = 0;\n\telse\n\t\treturn -EIO;\n\tdeb_info(\"Identify state cold = %d\\n\", *cold);\nerr:\n\tkfree(buf);\n\treturn ret;\n}", "target": 1}
{"code": "comics_decompress_temp_dir (const gchar *command_decompress_tmp,\n\t\t\t    const gchar *command, \n\t\t\t    GError      **error)\n{\n\tgboolean success;\n\tgchar *std_out, *basename;\n\tGError *err = NULL;\n\tgint retval;\n\tsuccess = g_spawn_command_line_sync (command_decompress_tmp, &std_out, \n\t\t\t\t\t     NULL, &retval, &err);\n\tbasename = g_path_get_basename (command);\n\tif (!success) {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR, \n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"Error launching the command %s in order to \"\n\t\t\t     \"decompress the comic book: %s\"),\n\t\t\t     basename,\n\t\t\t     err->message);\n\t\tg_error_free (err);\n\t} else if (WIFEXITED (retval)) {\n\t\tif (WEXITSTATUS (retval) == EXIT_SUCCESS) {\n\t\t\tg_free (std_out);\n\t\t\tg_free (basename);\n\t\t\treturn TRUE;\n\t\t} else {\n\t\t\tg_set_error (error,\n\t\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t\t     _(\"The command %s failed at \"\n\t\t\t\t     \"decompressing the comic book.\"),\n\t\t\t\t     basename);\n\t\t\tg_free (std_out);\n\t\t}\n\t} else {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"The command %s did not end normally.\"),\n\t\t\t     basename);\n\t\tg_free (std_out);\n\t}\n\tg_free (basename);\n\treturn FALSE;\n}", "target": 0}
{"code": "MagickExport MagickBooleanType DrawPatternPath(Image *image,\n  const DrawInfo *draw_info,const char *name,Image **pattern,\n  ExceptionInfo *exception)\n{\n  char\n    property[MagickPathExtent];\n  const char\n    *geometry,\n    *path,\n    *type;\n  DrawInfo\n    *clone_info;\n  ImageInfo\n    *image_info;\n  MagickBooleanType\n    status;\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(draw_info != (const DrawInfo *) NULL);\n  assert(name != (const char *) NULL);\n  (void) FormatLocaleString(property,MagickPathExtent,\"%s\",name);\n  path=GetImageArtifact(image,property);\n  if (path == (const char *) NULL)\n    return(MagickFalse);\n  (void) FormatLocaleString(property,MagickPathExtent,\"%s-geometry\",name);\n  geometry=GetImageArtifact(image,property);\n  if (geometry == (const char *) NULL)\n    return(MagickFalse);\n  if ((*pattern) != (Image *) NULL)\n    *pattern=DestroyImage(*pattern);\n  image_info=AcquireImageInfo();\n  image_info->size=AcquireString(geometry);\n  *pattern=AcquireImage(image_info,exception);\n  image_info=DestroyImageInfo(image_info);\n  (void) QueryColorCompliance(\"#00000000\",AllCompliance,\n    &(*pattern)->background_color,exception);\n  (void) SetImageBackgroundColor(*pattern,exception);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n      \"begin pattern-path %s %s\",name,geometry);\n  clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  if (clone_info->fill_pattern != (Image *) NULL)\n    clone_info->fill_pattern=DestroyImage(clone_info->fill_pattern);\n  if (clone_info->stroke_pattern != (Image *) NULL)\n    clone_info->stroke_pattern=DestroyImage(clone_info->stroke_pattern);\n  (void) FormatLocaleString(property,MagickPathExtent,\"%s-type\",name);\n  type=GetImageArtifact(image,property);\n  if (type != (const char *) NULL)\n    clone_info->gradient.type=(GradientType) ParseCommandOption(\n      MagickGradientOptions,MagickFalse,type);\n  (void) CloneString(&clone_info->primitive,path);\n  status=RenderMVGContent(*pattern,clone_info,0,exception);\n  clone_info=DestroyDrawInfo(clone_info);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"end pattern-path\");\n  return(status);\n}", "target": 0}
{"code": "Map1toN(SDL_PixelFormat * src, Uint8 Rmod, Uint8 Gmod, Uint8 Bmod, Uint8 Amod,\n        SDL_PixelFormat * dst)\n{\n    Uint8 *map;\n    int i;\n    int bpp;\n    SDL_Palette *pal = src->palette;\n    bpp = ((dst->BytesPerPixel == 3) ? 4 : dst->BytesPerPixel);\n    map = (Uint8 *) SDL_malloc(pal->ncolors * bpp);\n    if (map == NULL) {\n        SDL_OutOfMemory();\n        return (NULL);\n    }\n    for (i = 0; i < pal->ncolors; ++i) {\n        Uint8 R = (Uint8) ((pal->colors[i].r * Rmod) / 255);\n        Uint8 G = (Uint8) ((pal->colors[i].g * Gmod) / 255);\n        Uint8 B = (Uint8) ((pal->colors[i].b * Bmod) / 255);\n        Uint8 A = (Uint8) ((pal->colors[i].a * Amod) / 255);\n        ASSEMBLE_RGBA(&map[i * bpp], dst->BytesPerPixel, dst, (Uint32)R, (Uint32)G, (Uint32)B, (Uint32)A);\n    }\n    return (map);\n}", "target": 1}
{"code": "static void unix_detach_fds(struct scm_cookie *scm, struct sk_buff *skb)\n{\n\tint i;\n\tscm->fp = UNIXCB(skb).fp;\n\tUNIXCB(skb).fp = NULL;\n\tfor (i = scm->fp->count-1; i >= 0; i--)\n\t\tunix_notinflight(scm->fp->fp[i]);\n}", "target": 1}
{"code": "static int spl_ptr_heap_zval_max_cmp(spl_ptr_heap_element a, spl_ptr_heap_element b, void* object TSRMLS_DC) { \n\tzval result;\n\tif (EG(exception)) {\n\t\treturn 0;\n\t}\n\tif (object) {\n\t\tspl_heap_object *heap_object = (spl_heap_object*)zend_object_store_get_object((zval *)object TSRMLS_CC);\n\t\tif (heap_object->fptr_cmp) {\n\t\t\tlong lval = 0;\n\t\t\tif (spl_ptr_heap_cmp_cb_helper((zval *)object, heap_object, (zval *)a, (zval *)b, &lval TSRMLS_CC) == FAILURE) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn lval;\n\t\t}\n\t}\n\tINIT_ZVAL(result);\n\tcompare_function(&result, (zval *)a, (zval *)b TSRMLS_CC);\n\treturn Z_LVAL(result);\n}", "target": 0}
{"code": "static void register_page_bootmem_info_section(unsigned long start_pfn)\n{\n\tunsigned long *usemap, mapsize, section_nr, i;\n\tstruct mem_section *ms;\n\tstruct page *page, *memmap;\n\tif (!pfn_valid(start_pfn))\n\t\treturn;\n\tsection_nr = pfn_to_section_nr(start_pfn);\n\tms = __nr_to_section(section_nr);\n\tmemmap = sparse_decode_mem_map(ms->section_mem_map, section_nr);\n\tpage = virt_to_page(memmap);\n\tmapsize = sizeof(struct page) * PAGES_PER_SECTION;\n\tmapsize = PAGE_ALIGN(mapsize) >> PAGE_SHIFT;\n\tfor (i = 0; i < mapsize; i++, page++)\n\t\tget_page_bootmem(section_nr, page, SECTION_INFO);\n\tusemap = __nr_to_section(section_nr)->pageblock_flags;\n\tpage = virt_to_page(usemap);\n\tmapsize = PAGE_ALIGN(usemap_size()) >> PAGE_SHIFT;\n\tfor (i = 0; i < mapsize; i++, page++)\n\t\tget_page_bootmem(section_nr, page, MIX_SECTION_INFO);\n}", "target": 0}
{"code": "static void __exit xfrm6_tunnel_fini(void)\n{\n\tunregister_pernet_subsys(&xfrm6_tunnel_net_ops);\n\txfrm6_tunnel_spi_fini();\n\txfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);\n\txfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);\n\txfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);\n}", "target": 1}
{"code": "static int install_permanent_handler(int num_cpus, uintptr_t smbase,\n\t\t\t\t\tsize_t smsize, size_t save_state_size)\n{\n\tstruct smm_loader_params smm_params = {\n\t\t.per_cpu_stack_size = CONFIG_SMM_MODULE_STACK_SIZE,\n\t\t.num_concurrent_stacks = num_cpus,\n\t\t.per_cpu_save_state_size = save_state_size,\n\t\t.num_concurrent_save_states = num_cpus,\n\t};\n\tif (mp_state.ops.adjust_smm_params != NULL)\n\t\tmp_state.ops.adjust_smm_params(&smm_params, 1);\n\tprintk(BIOS_DEBUG, \"Installing SMM handler to 0x%08lx\\n\", smbase);\n\tif (smm_load_module((void *)smbase, smsize, &smm_params))\n\t\treturn -1;\n\tadjust_smm_apic_id_map(&smm_params);\n\treturn 0;\n}", "target": 1}
{"code": "void exit_mmap(struct mm_struct *mm)\n{\n\tstruct mmu_gather tlb;\n\tstruct vm_area_struct *vma;\n\tunsigned long nr_accounted = 0;\n\tmmu_notifier_release(mm);\n\tif (mm->locked_vm) {\n\t\tvma = mm->mmap;\n\t\twhile (vma) {\n\t\t\tif (vma->vm_flags & VM_LOCKED)\n\t\t\t\tmunlock_vma_pages_all(vma);\n\t\t\tvma = vma->vm_next;\n\t\t}\n\t}\n\tarch_exit_mmap(mm);\n\tvma = mm->mmap;\n\tif (!vma)\t\n\t\treturn;\n\tlru_add_drain();\n\tflush_cache_mm(mm);\n\ttlb_gather_mmu(&tlb, mm, 0, -1);\n\tunmap_vmas(&tlb, vma, 0, -1);\n\tif (unlikely(mm_is_oom_victim(mm))) {\n\t\tset_bit(MMF_OOM_SKIP, &mm->flags);\n\t\tdown_write(&mm->mmap_sem);\n\t\tup_write(&mm->mmap_sem);\n\t}\n\tfree_pgtables(&tlb, vma, FIRST_USER_ADDRESS, USER_PGTABLES_CEILING);\n\ttlb_finish_mmu(&tlb, 0, -1);\n\twhile (vma) {\n\t\tif (vma->vm_flags & VM_ACCOUNT)\n\t\t\tnr_accounted += vma_pages(vma);\n\t\tvma = remove_vma(vma);\n\t}\n\tvm_unacct_memory(nr_accounted);\n}", "target": 1}
{"code": "static VALUE from_document(VALUE klass, VALUE document)\n{\n  xmlDocPtr doc;\n  xmlRelaxNGParserCtxtPtr ctx;\n  xmlRelaxNGPtr schema;\n  VALUE errors;\n  VALUE rb_schema;\n  Data_Get_Struct(document, xmlDoc, doc);\n  doc = doc->doc;\n  ctx = xmlRelaxNGNewDocParserCtxt(doc);\n  errors = rb_ary_new();\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n#ifdef HAVE_XMLRELAXNGSETPARSERSTRUCTUREDERRORS\n  xmlRelaxNGSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n  schema = xmlRelaxNGParse(ctx);\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlRelaxNGFreeParserCtxt(ctx);\n  if(NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if(error)\n      Nokogiri_error_raise(NULL, error);\n    else\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n    return Qnil;\n  }\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n  return rb_schema;\n}", "target": 1}
{"code": "static bool blit_is_unsafe(struct CirrusVGAState *s)\n{\n    assert(s->cirrus_blt_width > 0);\n    assert(s->cirrus_blt_height > 0);\n    if (blit_region_is_unsafe(s, s->cirrus_blt_dstpitch,\n                              s->cirrus_blt_dstaddr & s->cirrus_addr_mask)) {\n        return true;\n    }\n    if (blit_region_is_unsafe(s, s->cirrus_blt_srcpitch,\n                              s->cirrus_blt_srcaddr & s->cirrus_addr_mask)) {\n        return true;\n    }\n    return false;\n}", "target": 1}
{"code": "int input_set_keycode(struct input_dev *dev,\n\t\t      const struct input_keymap_entry *ke)\n{\n\tunsigned long flags;\n\tunsigned int old_keycode;\n\tint retval;\n\tif (ke->keycode > KEY_MAX)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\tretval = dev->setkeycode(dev, ke, &old_keycode);\n\tif (retval)\n\t\tgoto out;\n\t__clear_bit(KEY_RESERVED, dev->keybit);\n\tif (test_bit(EV_KEY, dev->evbit) &&\n\t    !is_event_supported(old_keycode, dev->keybit, KEY_MAX) &&\n\t    __test_and_clear_bit(old_keycode, dev->key)) {\n\t\tstruct input_value vals[] =  {\n\t\t\t{ EV_KEY, old_keycode, 0 },\n\t\t\tinput_value_sync\n\t\t};\n\t\tinput_pass_values(dev, vals, ARRAY_SIZE(vals));\n\t}\n out:\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\treturn retval;\n}", "target": 1}
{"code": " void HTMLFormControlElement::updateVisibleValidationMessage() {\n   Page* page = document().page();\n  if (!page)\n     return;\n   String message;\n   if (layoutObject() && willValidate())\n    message = validationMessage().stripWhiteSpace();\n  m_hasValidationMessage = true;\n  ValidationMessageClient* client = &page->validationMessageClient();\n  TextDirection messageDir = LTR;\n  TextDirection subMessageDir = LTR;\n  String subMessage = validationSubMessage().stripWhiteSpace();\n  if (message.isEmpty())\n    client->hideValidationMessage(*this);\n  else\n    findCustomValidationMessageTextDirection(message, messageDir, subMessage,\n                                             subMessageDir);\n  client->showValidationMessage(*this, message, messageDir, subMessage,\n                                subMessageDir);\n}", "target": 1}
{"code": "writefile(const char *name, struct string *s)\n{\n\tFILE *f;\n\tint ret;\n\tf = fopen(name, \"w\");\n\tif (!f) {\n\t\twarn(\"open %s:\", name);\n\t\treturn -1;\n\t}\n\tret = 0;\n\tif (fwrite(s->s, 1, s->n, f) != s->n || fflush(f) != 0) {\n\t\twarn(\"write %s:\", name);\n\t\tret = -1;\n\t}\n\tfclose(f);\n\treturn ret;\n}", "target": 1}
{"code": "ospf_make_md5_digest (struct ospf_interface *oi, struct ospf_packet *op)\n{\n  struct ospf_header *ospfh;\n  unsigned char digest[OSPF_AUTH_MD5_SIZE];\n  MD5_CTX ctx;\n  void *ibuf;\n  u_int32_t t;\n  struct crypt_key *ck;\n  const u_int8_t *auth_key;\n  ibuf = STREAM_DATA (op->s);\n  ospfh = (struct ospf_header *) ibuf;\n  if (ntohs (ospfh->auth_type) != OSPF_AUTH_CRYPTOGRAPHIC)\n    return 0;\n  t = (time(NULL) & 0xFFFFFFFF);\n  if (t > oi->crypt_seqnum)\n    oi->crypt_seqnum = t;\n  else\n    oi->crypt_seqnum++;\n  ospfh->u.crypt.crypt_seqnum = htonl (oi->crypt_seqnum); \n  if (list_isempty (OSPF_IF_PARAM (oi, auth_crypt)))\n    auth_key = (const u_int8_t *) \"\";\n  else\n    {\n      ck = listgetdata (listtail(OSPF_IF_PARAM (oi, auth_crypt)));\n      auth_key = ck->auth_key;\n    }\n  memset(&ctx, 0, sizeof(ctx));\n  MD5Init(&ctx);\n  MD5Update(&ctx, ibuf, ntohs (ospfh->length));\n  MD5Update(&ctx, auth_key, OSPF_AUTH_MD5_SIZE);\n  MD5Final(digest, &ctx);\n  stream_put (op->s, digest, OSPF_AUTH_MD5_SIZE);\n  op->length = ntohs (ospfh->length) + OSPF_AUTH_MD5_SIZE;\n  if (stream_get_endp(op->s) != op->length)\n    zlog_warn(\"ospf_make_md5_digest: length mismatch stream %lu ospf_packet %u\",\n\t      (u_long)stream_get_endp(op->s), op->length);\n  return OSPF_AUTH_MD5_SIZE;\n}", "target": 0}
{"code": "static int em_jcxz(struct x86_emulate_ctxt *ctxt)\n{\n\tif (address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) == 0)\n\t\tjmp_rel(ctxt, ctxt->src.val);\n\treturn X86EMUL_CONTINUE;\n}", "target": 1}
{"code": "static bool dccp_new(struct nf_conn *ct, const struct sk_buff *skb,\n\t\t     unsigned int dataoff, unsigned int *timeouts)\n{\n\tstruct net *net = nf_ct_net(ct);\n\tstruct dccp_net *dn;\n\tstruct dccp_hdr _dh, *dh;\n\tconst char *msg;\n\tu_int8_t state;\n\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);\n\tBUG_ON(dh == NULL);\n\tstate = dccp_state_table[CT_DCCP_ROLE_CLIENT][dh->dccph_type][CT_DCCP_NONE];\n\tswitch (state) {\n\tdefault:\n\t\tdn = dccp_pernet(net);\n\t\tif (dn->dccp_loose == 0) {\n\t\t\tmsg = \"nf_ct_dccp: not picking up existing connection \";\n\t\t\tgoto out_invalid;\n\t\t}\n\tcase CT_DCCP_REQUEST:\n\t\tbreak;\n\tcase CT_DCCP_INVALID:\n\t\tmsg = \"nf_ct_dccp: invalid state transition \";\n\t\tgoto out_invalid;\n\t}\n\tct->proto.dccp.role[IP_CT_DIR_ORIGINAL] = CT_DCCP_ROLE_CLIENT;\n\tct->proto.dccp.role[IP_CT_DIR_REPLY] = CT_DCCP_ROLE_SERVER;\n\tct->proto.dccp.state = CT_DCCP_NONE;\n\tct->proto.dccp.last_pkt = DCCP_PKT_REQUEST;\n\tct->proto.dccp.last_dir = IP_CT_DIR_ORIGINAL;\n\tct->proto.dccp.handshake_seq = 0;\n\treturn true;\nout_invalid:\n\tif (LOG_INVALID(net, IPPROTO_DCCP))\n\t\tnf_log_packet(net, nf_ct_l3num(ct), 0, skb, NULL, NULL,\n\t\t\t      NULL, \"%s\", msg);\n\treturn false;\n}", "target": 1}
{"code": "static void *intel_alloc_coherent(struct device *dev, size_t size,\n\t\t\t\t  dma_addr_t *dma_handle, gfp_t flags,\n\t\t\t\t  unsigned long attrs)\n{\n\tstruct page *page = NULL;\n\tint order;\n\tsize = PAGE_ALIGN(size);\n\torder = get_order(size);\n\tif (!iommu_no_mapping(dev))\n\t\tflags &= ~(GFP_DMA | GFP_DMA32);\n\telse if (dev->coherent_dma_mask < dma_get_required_mask(dev)) {\n\t\tif (dev->coherent_dma_mask < DMA_BIT_MASK(32))\n\t\t\tflags |= GFP_DMA;\n\t\telse\n\t\t\tflags |= GFP_DMA32;\n\t}\n\tif (gfpflags_allow_blocking(flags)) {\n\t\tunsigned int count = size >> PAGE_SHIFT;\n\t\tpage = dma_alloc_from_contiguous(dev, count, order,\n\t\t\t\t\t\t flags & __GFP_NOWARN);\n\t\tif (page && iommu_no_mapping(dev) &&\n\t\t    page_to_phys(page) + size > dev->coherent_dma_mask) {\n\t\t\tdma_release_from_contiguous(dev, page, count);\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\tif (!page)\n\t\tpage = alloc_pages(flags, order);\n\tif (!page)\n\t\treturn NULL;\n\tmemset(page_address(page), 0, size);\n\t*dma_handle = __intel_map_single(dev, page_to_phys(page), size,\n\t\t\t\t\t DMA_BIDIRECTIONAL,\n\t\t\t\t\t dev->coherent_dma_mask);\n\tif (*dma_handle)\n\t\treturn page_address(page);\n\tif (!dma_release_from_contiguous(dev, page, size >> PAGE_SHIFT))\n\t\t__free_pages(page, order);\n\treturn NULL;\n}", "target": 0}
{"code": "newVar5(char *var,char *var2, char *var3,char *var4,char *var5)\n{\n\tstruct SWF_ACTIONPUSHPARAM *v;\n\tv=malloc(sizeof(struct SWF_ACTIONPUSHPARAM));\n\tv->Type = PUSH_VARIABLE; \n\tv->p.String = malloc(strlen(var)+strlen(var2)+strlen(var3)+strlen(var4)+strlen(var5)+1);\n\tstrcpy(v->p.String,var);\n\tstrcat(v->p.String,var2);\n\tstrcat(v->p.String,var3);\n\tstrcat(v->p.String,var4);\n\tstrcat(v->p.String,var5);\n\treturn v;\n}", "target": 0}
{"code": "passIsKeyword (const char *token)\n{\n  int k;\n  int length = strlen (token);\n  int ch = passLine.chars[passLinepos + length + 1];\n  if (((ch | 32) >= 'a' && (ch | 32) <= 'z') || (ch >= '0' && ch <= '9'))\n    return 0;\n  for (k = 0; k < length && passLine.chars[passLinepos + k + 1]\n       == (widechar) token[k]; k++);\n  if (k == length)\n    {\n      passLinepos += length + 1;\n      return 1;\n    }\n  return 0;\n}", "target": 0}
{"code": "static void vmx_set_constant_host_state(struct vcpu_vmx *vmx)\n{\n\tu32 low32, high32;\n\tunsigned long tmpl;\n\tstruct desc_ptr dt;\n\tunsigned long cr4;\n\tvmcs_writel(HOST_CR0, read_cr0() & ~X86_CR0_TS);  \n\tvmcs_writel(HOST_CR3, read_cr3());  \n\tcr4 = read_cr4();\n\tvmcs_writel(HOST_CR4, cr4);\t\t\t\n\tvmx->host_state.vmcs_host_cr4 = cr4;\n\tvmcs_write16(HOST_CS_SELECTOR, __KERNEL_CS);  \n#ifdef CONFIG_X86_64\n\tvmcs_write16(HOST_DS_SELECTOR, 0);\n\tvmcs_write16(HOST_ES_SELECTOR, 0);\n#else\n\tvmcs_write16(HOST_DS_SELECTOR, __KERNEL_DS);  \n\tvmcs_write16(HOST_ES_SELECTOR, __KERNEL_DS);  \n#endif\n\tvmcs_write16(HOST_SS_SELECTOR, __KERNEL_DS);  \n\tvmcs_write16(HOST_TR_SELECTOR, GDT_ENTRY_TSS*8);  \n\tnative_store_idt(&dt);\n\tvmcs_writel(HOST_IDTR_BASE, dt.address);   \n\tvmx->host_idt_base = dt.address;\n\tvmcs_writel(HOST_RIP, vmx_return); \n\trdmsr(MSR_IA32_SYSENTER_CS, low32, high32);\n\tvmcs_write32(HOST_IA32_SYSENTER_CS, low32);\n\trdmsrl(MSR_IA32_SYSENTER_EIP, tmpl);\n\tvmcs_writel(HOST_IA32_SYSENTER_EIP, tmpl);   \n\tif (vmcs_config.vmexit_ctrl & VM_EXIT_LOAD_IA32_PAT) {\n\t\trdmsr(MSR_IA32_CR_PAT, low32, high32);\n\t\tvmcs_write64(HOST_IA32_PAT, low32 | ((u64) high32 << 32));\n\t}\n}", "target": 0}
{"code": "cdf_dump_catalog(const cdf_header_t *h, const cdf_stream_t *sst)\n{\n\tcdf_catalog_t *cat;\n\tcdf_unpack_catalog(h, sst, &cat);\n\tconst cdf_catalog_entry_t *ce = cat->cat_e;\n\tstruct timespec ts;\n\tchar tbuf[64], sbuf[256];\n\tsize_t i;\n\tprintf(\"Catalog:\\n\");\n\tfor (i = 0; i < cat->cat_num; i++) {\n\t\tcdf_timestamp_to_timespec(&ts, ce[i].ce_timestamp);\n\t\tprintf(\"\\t%d %s %s\", ce[i].ce_num,\n\t\t    cdf_u16tos8(sbuf, ce[i].ce_namlen, ce[i].ce_name),\n\t\t    cdf_ctime(&ts.tv_sec, tbuf));\n\t}\n\tfree(cat);\n}", "target": 0}
{"code": "initialize(int argc, VALUE argv[], VALUE self)\n{\n    ffi_cif * cif;\n    ffi_type **arg_types;\n    ffi_status result;\n    VALUE ptr, args, ret_type, abi, kwds;\n    long i;\n    rb_scan_args(argc, argv, \"31:\", &ptr, &args, &ret_type, &abi, &kwds);\n    if(NIL_P(abi)) abi = INT2NUM(FFI_DEFAULT_ABI);\n    Check_Type(args, T_ARRAY);\n    Check_Max_Args(\"args\", RARRAY_LENINT(args));\n    rb_iv_set(self, \"@ptr\", ptr);\n    rb_iv_set(self, \"@args\", args);\n    rb_iv_set(self, \"@return_type\", ret_type);\n    rb_iv_set(self, \"@abi\", abi);\n    if (!NIL_P(kwds)) rb_hash_foreach(kwds, parse_keyword_arg_i, self);\n    TypedData_Get_Struct(self, ffi_cif, &function_data_type, cif);\n    arg_types = xcalloc(RARRAY_LEN(args) + 1, sizeof(ffi_type *));\n    for (i = 0; i < RARRAY_LEN(args); i++) {\n\tint type = NUM2INT(RARRAY_AREF(args, i));\n\targ_types[i] = INT2FFI_TYPE(type);\n    }\n    arg_types[RARRAY_LEN(args)] = NULL;\n    result = ffi_prep_cif (\n\t    cif,\n\t    NUM2INT(abi),\n\t    RARRAY_LENINT(args),\n\t    INT2FFI_TYPE(NUM2INT(ret_type)),\n\t    arg_types);\n    if (result)\n\trb_raise(rb_eRuntimeError, \"error creating CIF %d\", result);\n    return self;\n}", "target": 1}
{"code": "static void xen_netbk_fill_frags(struct xen_netbk *netbk, struct sk_buff *skb)\n{\n\tstruct skb_shared_info *shinfo = skb_shinfo(skb);\n\tint nr_frags = shinfo->nr_frags;\n\tint i;\n\tfor (i = 0; i < nr_frags; i++) {\n\t\tskb_frag_t *frag = shinfo->frags + i;\n\t\tstruct xen_netif_tx_request *txp;\n\t\tstruct page *page;\n\t\tu16 pending_idx;\n\t\tpending_idx = frag_get_pending_idx(frag);\n\t\ttxp = &netbk->pending_tx_info[pending_idx].req;\n\t\tpage = virt_to_page(idx_to_kaddr(netbk, pending_idx));\n\t\t__skb_fill_page_desc(skb, i, page, txp->offset, txp->size);\n\t\tskb->len += txp->size;\n\t\tskb->data_len += txp->size;\n\t\tskb->truesize += txp->size;\n\t\tget_page(netbk->mmap_pages[pending_idx]);\n\t\txen_netbk_idx_release(netbk, pending_idx);\n\t}\n}", "target": 1}
{"code": "mrb_remove_method(mrb_state *mrb, struct RClass *c, mrb_sym mid)\n{\n  mt_tbl *h;\n  MRB_CLASS_ORIGIN(c);\n  h = c->mt;\n  if (h && mt_del(mrb, h, mid)) return;\n  mrb_name_error(mrb, mid, \"method '%n' not defined in %C\", mid, c);\n}", "target": 1}
{"code": "static void _WM_CheckEventMemoryPool(struct _mdi *mdi) {\n    if ((mdi->event_count + 1) >= mdi->events_size) {\n        mdi->events_size += MEM_CHUNK;\n        mdi->events = realloc(mdi->events,\n                              (mdi->events_size * sizeof(struct _event)));\n    }\n}", "target": 0}
{"code": "static void ff_layout_put_mirror(struct nfs4_ff_layout_mirror *mirror)\n{\n\tif (mirror != NULL && refcount_dec_and_test(&mirror->ref))\n\t\tff_layout_free_mirror(mirror);\n}", "target": 0}
{"code": "static int mxf_read_primer_pack(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFContext *mxf = arg;\n    int item_num = avio_rb32(pb);\n    int item_len = avio_rb32(pb);\n    if (item_len != 18) {\n        avpriv_request_sample(pb, \"Primer pack item length %d\", item_len);\n        return AVERROR_PATCHWELCOME;\n    }\n    if (item_num > 65536) {\n        av_log(mxf->fc, AV_LOG_ERROR, \"item_num %d is too large\\n\", item_num);\n        return AVERROR_INVALIDDATA;\n    }\n    if (mxf->local_tags)\n        av_log(mxf->fc, AV_LOG_VERBOSE, \"Multiple primer packs\\n\");\n    av_free(mxf->local_tags);\n    mxf->local_tags_count = 0;\n    mxf->local_tags = av_calloc(item_num, item_len);\n    if (!mxf->local_tags)\n        return AVERROR(ENOMEM);\n    mxf->local_tags_count = item_num;\n    avio_read(pb, mxf->local_tags, item_num*item_len);\n    return 0;\n}", "target": 1}
{"code": "char* _multi_string_alloc_and_copy( LPCWSTR in )\n{\n    char *chr;\n    int len = 0;\n    if ( !in )\n    {\n        return NULL;\n    }\n    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )\n    {\n        len ++;\n    }\n    chr = malloc( len + 2 );\n    len = 0;\n    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )\n    {\n        chr[ len ] = 0xFF & in[ len ];\n        len ++;\n    }\n    chr[ len ++ ] = '\\0';\n    chr[ len ++ ] = '\\0';\n    return chr;\n}", "target": 0}
{"code": "void CLASS panasonic_load_raw()\n{\n  int row, col, i, j, sh = 0, pred[2], nonz[2];\n  pana_bits(0);\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < raw_width; col++)\n    {\n      if ((i = col % 14) == 0)\n        pred[0] = pred[1] = nonz[0] = nonz[1] = 0;\n      if (i % 3 == 2)\n        sh = 4 >> (3 - pana_bits(2));\n      if (nonz[i & 1])\n      {\n        if ((j = pana_bits(8)))\n        {\n          if ((pred[i & 1] -= 0x80 << sh) < 0 || sh == 4)\n            pred[i & 1] &= ~((~0u) << sh);\n          pred[i & 1] += j << sh;\n        }\n      }\n      else if ((nonz[i & 1] = pana_bits(8)) || i > 11)\n        pred[i & 1] = nonz[i & 1] << 4 | pana_bits(4);\n      if ((RAW(row, col) = pred[col & 1]) > 4098 && col < width)\n        derror();\n    }\n  }\n}", "target": 1}
{"code": "snmp_ber_encode_length(unsigned char *out, uint32_t *out_len, uint8_t length)\n{\n  *out-- = length;\n  (*out_len)++;\n  return out;\n}", "target": 1}
{"code": "static struct nft_chain *nf_tables_chain_lookup(const struct nft_table *table,\n\t\t\t\t\t\tconst struct nlattr *nla)\n{\n\tstruct nft_chain *chain;\n\tif (nla == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\tlist_for_each_entry(chain, &table->chains, list) {\n\t\tif (!nla_strcmp(nla, chain->name))\n\t\t\treturn chain;\n\t}\n\treturn ERR_PTR(-ENOENT);\n}", "target": 0}
{"code": "resolve_op_from_commit (FlatpakTransaction *self,\n                        FlatpakTransactionOperation *op,\n                        const char *checksum,\n                        GFile *sideload_path,\n                        GVariant *commit_data,\n                        GError **error)\n{\n  g_autoptr(GBytes) metadata_bytes = NULL;\n  g_autoptr(GVariant) commit_metadata = NULL;\n  const char *xa_metadata = NULL;\n  guint64 download_size = 0;\n  guint64 installed_size = 0;\n  commit_metadata = g_variant_get_child_value (commit_data, 0);\n  g_variant_lookup (commit_metadata, \"xa.metadata\", \"&s\", &xa_metadata);\n  if (xa_metadata == NULL)\n    return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA,\n                               \"No xa.metadata in local commit %s ref %s\",\n                               checksum, flatpak_decomposed_get_ref (op->ref));\n  metadata_bytes = g_bytes_new (xa_metadata, strlen (xa_metadata));\n  if (g_variant_lookup (commit_metadata, \"xa.download-size\", \"t\", &download_size))\n    op->download_size = GUINT64_FROM_BE (download_size);\n  if (g_variant_lookup (commit_metadata, \"xa.installed-size\", \"t\", &installed_size))\n    op->installed_size = GUINT64_FROM_BE (installed_size);\n  g_variant_lookup (commit_metadata, OSTREE_COMMIT_META_KEY_ENDOFLIFE, \"s\", &op->eol);\n  g_variant_lookup (commit_metadata, OSTREE_COMMIT_META_KEY_ENDOFLIFE_REBASE, \"s\", &op->eol_rebase);\n  return resolve_op_end (self, op, checksum, sideload_path, metadata_bytes, error);\n}", "target": 0}
{"code": "BnGeneratePrimeForRSA(\n\t\t      bigNum          prime,\n\t\t      UINT32          bits,\n\t\t      UINT32          exponent,\n\t\t      RAND_STATE      *rand\n\t\t      )\n{\n    BOOL            found = FALSE;\n    pAssert(prime->allocated >= BITS_TO_CRYPT_WORDS(bits));\n    pAssert((bits % 32) == 0);\n    prime->size = BITS_TO_CRYPT_WORDS(bits);\n    while(!found)\n\t{\n\t    DRBG_Generate(rand, (BYTE *)prime->d, (UINT16)BITS_TO_BYTES(bits));\n\t    RsaAdjustPrimeCandidate(prime);\n\t    found = RsaCheckPrime(prime, exponent, rand) == TPM_RC_SUCCESS;\n\t}\n}", "target": 0}
{"code": "sort_page_names (gconstpointer a,\n                 gconstpointer b)\n{\n\tconst char *name_1, *name_2;\n\tgchar *key_1, *key_2;\n\tgboolean sort_last_1, sort_last_2;\n\tint compare;\n\tname_1 = * (const char **) a;\n\tname_2 = * (const char **) b;\n\t#define SORT_LAST_CHAR1 '.'\n\t#define SORT_LAST_CHAR2 '#'\n\tsort_last_1 = name_1[0] == SORT_LAST_CHAR1 || name_1[0] == SORT_LAST_CHAR2;\n\tsort_last_2 = name_2[0] == SORT_LAST_CHAR1 || name_2[0] == SORT_LAST_CHAR2;\n\t#undef SORT_LAST_CHAR1\n\t#undef SORT_LAST_CHAR2\n\tif (sort_last_1 && !sort_last_2)\n\t{\n\t\tcompare = +1;\n\t}\n\telse if (!sort_last_1 && sort_last_2)\n\t{\n\t\tcompare = -1;\n\t} \n\telse\n\t{\n\t\tkey_1 = g_utf8_collate_key_for_filename (name_1, -1);\n\t\tkey_2 = g_utf8_collate_key_for_filename (name_2, -1);\n\t\tcompare = strcmp (key_1, key_2);\n\t\tg_free (key_1);\n\t\tg_free (key_2);\n\t}\n\treturn compare;\n}", "target": 0}
{"code": "static u64 sched_clock_local(struct sched_clock_data *scd)\n{\n\tu64 now, clock, old_clock, min_clock, max_clock;\n\ts64 delta;\nagain:\n\tnow = sched_clock();\n\tdelta = now - scd->tick_raw;\n\tif (unlikely(delta < 0))\n\t\tdelta = 0;\n\told_clock = scd->clock;\n\tclock = scd->tick_gtod + delta;\n\tmin_clock = wrap_max(scd->tick_gtod, old_clock);\n\tmax_clock = wrap_max(old_clock, scd->tick_gtod + TICK_NSEC);\n\tclock = wrap_max(clock, min_clock);\n\tclock = wrap_min(clock, max_clock);\n\tif (cmpxchg64(&scd->clock, old_clock, clock) != old_clock)\n\t\tgoto again;\n\treturn clock;\n}", "target": 0}
{"code": "static int __init si_domain_init(int hw)\n{\n\tint nid, ret;\n\tsi_domain = alloc_domain(DOMAIN_FLAG_STATIC_IDENTITY);\n\tif (!si_domain)\n\t\treturn -EFAULT;\n\tif (md_domain_init(si_domain, DEFAULT_DOMAIN_ADDRESS_WIDTH)) {\n\t\tdomain_exit(si_domain);\n\t\treturn -EFAULT;\n\t}\n\tpr_debug(\"Identity mapping domain allocated\\n\");\n\tif (hw)\n\t\treturn 0;\n\tfor_each_online_node(nid) {\n\t\tunsigned long start_pfn, end_pfn;\n\t\tint i;\n\t\tfor_each_mem_pfn_range(i, nid, &start_pfn, &end_pfn, NULL) {\n\t\t\tret = iommu_domain_identity_map(si_domain,\n\t\t\t\t\tPFN_PHYS(start_pfn), PFN_PHYS(end_pfn));\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static inline u32 net_hash_mix(const struct net *net)\n{\n#ifdef CONFIG_NET_NS\n\treturn (u32)(((unsigned long)net) >> ilog2(sizeof(*net)));\n#else\n\treturn 0;\n#endif\n}", "target": 1}
{"code": "        int    ReadDoubleArray(unsigned char *sString, int nLen, double (&pArray)[nMax])\n        {\n            int nStart = 0;\n            while( sString[nStart] != '[' )\n            {\n                nStart++;\n                if ( nStart >= nLen )\n                    return 0;\n            }\n            int nEnd = ++nStart;\n            while ( sString[nEnd] != ']' )\n            {\n                nEnd++;\n                if ( nEnd >= nLen )\n                    return 0;\n            }\n            sString = sString + nStart;\n            nLen    = nEnd - nStart;\n            int nCount = 0;\n            const int c_nNumLimit = 32;\n            unsigned char sBuffer[c_nNumLimit];\n            int nBufPos = 0;\n            bool bNewItem = true;\n            for ( int nIndex = 0; nIndex < nLen; ++nIndex )\n            {\n                unsigned char unChar = sString[nIndex];\n                if ( ' ' == unChar )\n                {\n                    if ( !bNewItem )\n                        bNewItem = true;\n                    continue;\n                }\n                if ( bNewItem )\n                {\n                    if ( nCount >= nMax )\n                        break;\n                    if ( nCount > 0 )\n                        pArray[nCount - 1] = Utils::GetDouble( (const char *)sBuffer );\n                    memset( sBuffer, 0x00, c_nNumLimit );\n                    nBufPos = 0;\n                    bNewItem = false;\n                    nCount++;\n                }\n                sBuffer[nBufPos++] = unChar;\n                if (nBufPos >= c_nNumLimit)\n                    break;\n            }\n            if ( 0 != sBuffer[0] && nCount > 0 )\n                pArray[nCount - 1] = Utils::GetDouble( (const char *)sBuffer );\n            return nCount;\n        }", "target": 0}
{"code": "void luaT_adjustvarargs (lua_State *L, int nfixparams, CallInfo *ci,\n                         const Proto *p) {\n  int i;\n  int actual = cast_int(L->top - ci->func) - 1;  \n  int nextra = actual - nfixparams;  \n  ci->u.l.nextraargs = nextra;\n  checkstackGC(L, p->maxstacksize + 1);\n  setobjs2s(L, L->top++, ci->func);\n  for (i = 1; i <= nfixparams; i++) {\n    setobjs2s(L, L->top++, ci->func + i);\n    setnilvalue(s2v(ci->func + i));  \n  }\n  ci->func += actual + 1;\n  ci->top += actual + 1;\n  lua_assert(L->top <= ci->top && ci->top <= L->stack_last);\n}", "target": 1}
{"code": "static int rt6_bind_neighbour(struct rt6_info *rt, struct net_device *dev)\n{\n\tstruct neighbour *n = __ipv6_neigh_lookup(&nd_tbl, dev, &rt->rt6i_gateway);\n\tif (!n) {\n\t\tn = neigh_create(&nd_tbl, &rt->rt6i_gateway, dev);\n\t\tif (IS_ERR(n))\n\t\t\treturn PTR_ERR(n);\n\t}\n\trt->n = n;\n\treturn 0;\n}", "target": 0}
{"code": "ikev1_nonce_print(netdissect_options *ndo, u_char tpay _U_,\n\t\t  const struct isakmp_gen *ext,\n\t\t  u_int item_len _U_,\n\t\t  const u_char *ep,\n\t\t  uint32_t phase _U_, uint32_t doi _U_,\n\t\t  uint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_NONCE)));\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" n len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t} else if (1 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!ike_show_somedata(ndo, (const u_char *)(const uint8_t *)(ext + 1), ep))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_NONCE)));\n\treturn NULL;\n}", "target": 1}
{"code": "static int xfrm_dump_policy(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];\n\tstruct xfrm_dump_info info;\n\tBUILD_BUG_ON(sizeof(struct xfrm_policy_walk) >\n\t\t     sizeof(cb->args) - sizeof(cb->args[0]));\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\tif (!cb->args[0]) {\n\t\tcb->args[0] = 1;\n\t\txfrm_policy_walk_init(walk, XFRM_POLICY_TYPE_ANY);\n\t}\n\t(void) xfrm_policy_walk(net, walk, dump_one_policy, &info);\n\treturn skb->len;\n}", "target": 1}
{"code": "MagickExport Quantum *QueueAuthenticPixels(Image *image,const ssize_t x,\n  const ssize_t y,const size_t columns,const size_t rows,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n  const int\n    id = GetOpenMPThreadId();\n  Quantum\n    *magick_restrict pixels;\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->methods.queue_authentic_pixels_handler !=\n      (QueueAuthenticPixelsHandler) NULL)\n    {\n      pixels=cache_info->methods.queue_authentic_pixels_handler(image,x,y,\n        columns,rows,exception);\n      return(pixels);\n    }\n  assert(id < (int) cache_info->number_threads);\n  pixels=QueueAuthenticPixelCacheNexus(image,x,y,columns,rows,MagickFalse,\n    cache_info->nexus_info[id],exception);\n  return(pixels);\n}", "target": 0}
{"code": "static int handle_pte_fault(struct mm_struct *mm,\n\t\t     struct vm_area_struct *vma, unsigned long address,\n\t\t     pte_t *pte, pmd_t *pmd, unsigned int flags)\n{\n\tpte_t entry;\n\tspinlock_t *ptl;\n\tentry = *pte;\n\tbarrier();\n\tif (!pte_present(entry)) {\n\t\tif (pte_none(entry)) {\n\t\t\tif (vma->vm_ops) {\n\t\t\t\tif (likely(vma->vm_ops->fault))\n\t\t\t\t\treturn do_fault(mm, vma, address, pte,\n\t\t\t\t\t\t\tpmd, flags, entry);\n\t\t\t}\n\t\t\treturn do_anonymous_page(mm, vma, address,\n\t\t\t\t\t\t pte, pmd, flags);\n\t\t}\n\t\treturn do_swap_page(mm, vma, address,\n\t\t\t\t\tpte, pmd, flags, entry);\n\t}\n\tif (pte_protnone(entry))\n\t\treturn do_numa_page(mm, vma, address, entry, pte, pmd);\n\tptl = pte_lockptr(mm, pmd);\n\tspin_lock(ptl);\n\tif (unlikely(!pte_same(*pte, entry)))\n\t\tgoto unlock;\n\tif (flags & FAULT_FLAG_WRITE) {\n\t\tif (!pte_write(entry))\n\t\t\treturn do_wp_page(mm, vma, address,\n\t\t\t\t\tpte, pmd, ptl, entry);\n\t\tentry = pte_mkdirty(entry);\n\t}\n\tentry = pte_mkyoung(entry);\n\tif (ptep_set_access_flags(vma, address, pte, entry, flags & FAULT_FLAG_WRITE)) {\n\t\tupdate_mmu_cache(vma, address, pte);\n\t} else {\n\t\tif (flags & FAULT_FLAG_WRITE)\n\t\t\tflush_tlb_fix_spurious_fault(vma, address);\n\t}\nunlock:\n\tpte_unmap_unlock(pte, ptl);\n\treturn 0;\n}", "target": 1}
{"code": "int PackLinuxElf32::canUnpack()\n{\n    if (super::canUnpack()) {\n        return true;\n    }\n    if (Elf32_Ehdr::ET_DYN==get_te16(&ehdri.e_type)) {\n        PackLinuxElf32help1(fi);\n    }\n    return false;\n}", "target": 1}
{"code": "static int vp8_lossy_decode_frame(AVCodecContext *avctx, AVFrame *p,\n                                  int *got_frame, uint8_t *data_start,\n                                  unsigned int data_size)\n{\n    WebPContext *s = avctx->priv_data;\n    AVPacket pkt;\n    int ret;\n    if (!s->initialized) {\n        ff_vp8_decode_init(avctx);\n        s->initialized = 1;\n        if (s->has_alpha)\n            avctx->pix_fmt = AV_PIX_FMT_YUVA420P;\n    }\n    s->lossless = 0;\n    if (data_size > INT_MAX) {\n        av_log(avctx, AV_LOG_ERROR, \"unsupported chunk size\\n\");\n        return AVERROR_PATCHWELCOME;\n    }\n    av_init_packet(&pkt);\n    pkt.data = data_start;\n    pkt.size = data_size;\n    ret = ff_vp8_decode_frame(avctx, p, got_frame, &pkt);\n    if (ret < 0)\n        return ret;\n    update_canvas_size(avctx, avctx->width, avctx->height);\n    if (s->has_alpha) {\n        ret = vp8_lossy_decode_alpha(avctx, p, s->alpha_data,\n                                     s->alpha_data_size);\n        if (ret < 0)\n            return ret;\n    }\n    return ret;\n}", "target": 1}
{"code": "NEDMALLOCNOALIASATTR NEDMALLOCPTRATTR void * nedpcalloc(nedpool *p, size_t no, size_t size) THROWSPEC\n{\n\tunsigned flags=NEDMALLOC_FORCERESERVE(p, 0, no*size);\n\treturn nedpmalloc2(p, size*no, 0, M2_ZERO_MEMORY|flags);\n}", "target": 1}
{"code": "static int fsck_tag(struct tag *tag, const char *data,\n\tunsigned long size, struct fsck_options *options)\n{\n\tstruct object *tagged = tag->tagged;\n\tif (!tagged)\n\t\treturn report(options, &tag->object, FSCK_MSG_BAD_TAG_OBJECT, \"could not load tagged object\");\n\treturn fsck_tag_buffer(tag, data, size, options);\n}", "target": 0}
{"code": " */\nstatic int wddx_stack_destroy(wddx_stack *stack)\n{\n\tregister int i;\n\tif (stack->elements) {\n\t\tfor (i = 0; i < stack->top; i++) {\n\t\t\tif (((st_entry *)stack->elements[i])->data)\t{\n\t\t\t\tzval_ptr_dtor(&((st_entry *)stack->elements[i])->data);\n\t\t\t}\n\t\t\tif (((st_entry *)stack->elements[i])->varname) {\n\t\t\t\tefree(((st_entry *)stack->elements[i])->varname);\n\t\t\t}\n\t\t\tefree(stack->elements[i]);\n\t\t}\n\t\tefree(stack->elements);\n\t}\n\treturn SUCCESS;", "target": 1}
{"code": "FILE *mingw_freopen (const char *filename, const char *otype, FILE *stream)\n{\n\tint hide = needs_hiding(filename);\n\tFILE *file;\n\twchar_t wfilename[MAX_PATH], wotype[4];\n\tif (filename && !strcmp(filename, \"/dev/null\"))\n\t\tfilename = \"nul\";\n\tif (xutftowcs_path(wfilename, filename) < 0 ||\n\t\txutftowcs(wotype, otype, ARRAY_SIZE(wotype)) < 0)\n\t\treturn NULL;\n\tif (hide && !access(filename, F_OK) && set_hidden_flag(wfilename, 0)) {\n\t\terror(\"could not unhide %s\", filename);\n\t\treturn NULL;\n\t}\n\tfile = _wfreopen(wfilename, wotype, stream);\n\tif (file && hide && set_hidden_flag(wfilename, 1))\n\t\twarning(\"could not mark '%s' as hidden.\", filename);\n\treturn file;\n}", "target": 0}
{"code": "cdf_read_short_sector(const cdf_stream_t *sst, void *buf, size_t offs,\n    size_t len, const cdf_header_t *h, cdf_secid_t id)\n{\n\tassert((size_t)CDF_SHORT_SEC_SIZE(h) == len);\n\t(void)memcpy(((char *)buf) + offs,\n\t    ((const char *)sst->sst_tab) + CDF_SHORT_SEC_POS(h, id), len);\n\treturn len;\n}", "target": 1}
{"code": "static void date_period_it_invalidate_current(zend_object_iterator *iter TSRMLS_DC)\n{\n\tdate_period_it *iterator = (date_period_it *)iter;\n\tif (iterator->current) {\n\t\tzval_ptr_dtor(&iterator->current);\n\t\titerator->current = NULL;\n\t}", "target": 0}
{"code": "static int _strlen_check(int linenumber, char *buf, size_t len)\n{\n  size_t buflen = strlen(buf);\n  if(len != buflen) {\n    printf(\"sprintf strlen:%d failed:\\nwe '%d'\\nsystem: '%d'\\n\",\n           linenumber, buflen, len);\n    return 1;\n  }\n  return 0;\n}", "target": 0}
{"code": "split_der(asn1buf *buf, uint8_t *const *der, size_t len, taginfo *tag_out)\n{\n    krb5_error_code ret;\n    const uint8_t *contents, *remainder;\n    size_t clen, rlen;\n    ret = get_tag(*der, len, tag_out, &contents, &clen, &remainder, &rlen);\n    if (ret)\n        return ret;\n    if (rlen != 0)\n        return ASN1_BAD_LENGTH;\n    insert_bytes(buf, contents, clen);\n    return 0;\n}", "target": 1}
{"code": "njs_json_parse_iterator_call(njs_vm_t *vm, njs_json_parse_t *parse,\n    njs_json_state_t *state)\n{\n    njs_int_t          ret;\n    njs_value_t        arguments[3], *value;\n    njs_object_prop_t  *prop;\n    prop = state->prop;\n    arguments[0] = state->value;\n    arguments[1] = state->keys->start[state->index++];\n    switch (prop->type) {\n    case NJS_PROPERTY:\n        arguments[2] = prop->value;\n        ret = njs_function_apply(vm, parse->function, arguments, 3,\n                                 &parse->retval);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n        if (njs_is_undefined(&parse->retval)) {\n            prop->type = NJS_WHITEOUT;\n        } else {\n            prop->value = parse->retval;\n        }\n        break;\n    case NJS_PROPERTY_REF:\n        value = prop->value.data.u.value;\n        arguments[2] = *value;\n        ret = njs_function_apply(vm, parse->function, arguments, 3,\n                                 &parse->retval);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n        if (njs_is_undefined(&parse->retval)) {\n            ret = njs_value_property_i64_delete(vm, &state->value,\n                                                state->index - 1, NULL);\n        } else {\n            ret = njs_value_property_i64_set(vm, &state->value,\n                                             state->index - 1, &parse->retval);\n        }\n        if (njs_slow_path(ret == NJS_ERROR)) {\n            return NJS_ERROR;\n        }\n        break;\n    default:\n        njs_internal_error(vm, \"njs_json_parse_iterator_call() unexpected \"\n                         \"property type:%s\", njs_prop_type_string(prop->type));\n    }\n    return NJS_OK;\n}", "target": 1}
{"code": "static ssize_t stream_ssl_write_cb(RedStream *s, const void *buf, size_t size)\n{\n    int return_code;\n    return_code = SSL_write(s->priv->ssl, buf, size);\n    if (return_code < 0) {\n        return stream_ssl_error(s, return_code);\n    }\n    return return_code;\n}", "target": 0}
{"code": "String UTF16BEDecoder::to_utf8(const StringView& input)\n{\n    StringBuilder builder(input.length() / 2);\n    for (size_t i = 0; i < input.length(); i += 2) {\n        u16 code_point = (input[i] << 8) | input[i + 1];\n        builder.append_code_point(code_point);\n    }\n    return builder.to_string();\n}", "target": 1}
{"code": "method_invocation_get_uid (GDBusMethodInvocation *context)\n{\n  const gchar *sender;\n  PolkitSubject *busname;\n  PolkitSubject *process;\n  uid_t uid;\n  sender = g_dbus_method_invocation_get_sender (context);\n  busname = polkit_system_bus_name_new (sender);\n  process = polkit_system_bus_name_get_process_sync (POLKIT_SYSTEM_BUS_NAME (busname), NULL, NULL);\n  uid = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (process));\n  g_object_unref (busname);\n  g_object_unref (process);\n  return uid;\n}", "target": 1}
{"code": "pfkey_proto2satype(uint16_t proto)\n{\n\tswitch (proto) {\n\tcase IPPROTO_AH:\n\t\treturn SADB_SATYPE_AH;\n\tcase IPPROTO_ESP:\n\t\treturn SADB_SATYPE_ESP;\n\tcase IPPROTO_COMP:\n\t\treturn SADB_X_SATYPE_IPCOMP;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n}", "target": 0}
{"code": "static int check_reg_arg(struct bpf_verifier_env *env, u32 regno,\n\t\t\t enum reg_arg_type t)\n{\n\tstruct bpf_verifier_state *vstate = env->cur_state;\n\tstruct bpf_func_state *state = vstate->frame[vstate->curframe];\n\tstruct bpf_insn *insn = env->prog->insnsi + env->insn_idx;\n\tstruct bpf_reg_state *reg, *regs = state->regs;\n\tbool rw64;\n\tif (regno >= MAX_BPF_REG) {\n\t\tverbose(env, \"R%d is invalid\\n\", regno);\n\t\treturn -EINVAL;\n\t}\n\tmark_reg_scratched(env, regno);\n\treg = &regs[regno];\n\trw64 = is_reg64(env, insn, regno, reg, t);\n\tif (t == SRC_OP) {\n\t\tif (reg->type == NOT_INIT) {\n\t\t\tverbose(env, \"R%d !read_ok\\n\", regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (regno == BPF_REG_FP)\n\t\t\treturn 0;\n\t\tif (rw64)\n\t\t\tmark_insn_zext(env, reg);\n\t\treturn mark_reg_read(env, reg, reg->parent,\n\t\t\t\t     rw64 ? REG_LIVE_READ64 : REG_LIVE_READ32);\n\t} else {\n\t\tif (regno == BPF_REG_FP) {\n\t\t\tverbose(env, \"frame pointer is read only\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\treg->live |= REG_LIVE_WRITTEN;\n\t\treg->subreg_def = rw64 ? DEF_NOT_SUBREG : env->insn_idx + 1;\n\t\tif (t == DST_OP)\n\t\t\tmark_reg_unknown(env, regs, regno);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static PHP_GINIT_FUNCTION(libxml)\n{\n        libxml_globals->stream_context = NULL;\n        libxml_globals->error_buffer.c = NULL;\n        libxml_globals->error_list = NULL;\n }", "target": 1}
{"code": "static int sco_connect(struct sock *sk)\n{\n\tbdaddr_t *src = &bt_sk(sk)->src;\n\tbdaddr_t *dst = &bt_sk(sk)->dst;\n\tstruct sco_conn *conn;\n\tstruct hci_conn *hcon;\n\tstruct hci_dev  *hdev;\n\tint err, type;\n\tBT_DBG(\"%s -> %s\", batostr(src), batostr(dst));\n\thdev = hci_get_route(dst, src);\n\tif (!hdev)\n\t\treturn -EHOSTUNREACH;\n\thci_dev_lock_bh(hdev);\n\terr = -ENOMEM;\n\tif (lmp_esco_capable(hdev) && !disable_esco)\n\t\ttype = ESCO_LINK;\n\telse\n\t\ttype = SCO_LINK;\n\thcon = hci_connect(hdev, type, dst, BT_SECURITY_LOW, HCI_AT_NO_BONDING);\n\tif (!hcon)\n\t\tgoto done;\n\tconn = sco_conn_add(hcon, 0);\n\tif (!conn) {\n\t\thci_conn_put(hcon);\n\t\tgoto done;\n\t}\n\tbacpy(src, conn->src);\n\terr = sco_chan_add(conn, sk, NULL);\n\tif (err)\n\t\tgoto done;\n\tif (hcon->state == BT_CONNECTED) {\n\t\tsco_sock_clear_timer(sk);\n\t\tsk->sk_state = BT_CONNECTED;\n\t} else {\n\t\tsk->sk_state = BT_CONNECT;\n\t\tsco_sock_set_timer(sk, sk->sk_sndtimeo);\n\t}\ndone:\n\thci_dev_unlock_bh(hdev);\n\thci_dev_put(hdev);\n\treturn err;\n}", "target": 0}
{"code": "static const char* jvp_literal_number_literal(jv n) {\n  assert(JVP_HAS_FLAGS(n, JVP_FLAGS_NUMBER_LITERAL));\n  decNumber *pdec = jvp_dec_number_ptr(n);\n  jvp_literal_number* plit = jvp_literal_number_ptr(n);\n  if (decNumberIsNaN(pdec)) {\n    return \"null\";\n  }\n  if (decNumberIsInfinite(pdec)) {\n    return NULL;\n  }\n  if (plit->literal_data == NULL) {\n    int len = jvp_dec_number_ptr(n)->digits + 14;\n    plit->literal_data = jv_mem_alloc(len);\n    decNumberToString(pdec, plit->literal_data);\n  }\n  return plit->literal_data;\n}", "target": 1}
{"code": "void CarbonProtocolReader::skip(const FieldType ft) {\n  switch (ft) {\n    case FieldType::True:\n    case FieldType::False: {\n      break;\n    }\n    case FieldType::Int8: {\n      readRaw<int8_t>();\n      break;\n    }\n    case FieldType::Int16: {\n      readRaw<int16_t>();\n      break;\n    }\n    case FieldType::Int32: {\n      readRaw<int32_t>();\n      break;\n    }\n    case FieldType::Int64: {\n      readRaw<int64_t>();\n      break;\n    }\n    case FieldType::Double: {\n      readRaw<double>();\n      break;\n    }\n    case FieldType::Float: {\n      readRaw<float>();\n      break;\n    }\n    case FieldType::Binary: {\n      readRaw<std::string>();\n      break;\n    }\n    case FieldType::List: {\n      skipLinearContainer();\n      break;\n    }\n    case FieldType::Struct: {\n      readStructBegin();\n      while (true) {\n        const auto fieldType = readFieldHeader().first;\n        if (fieldType == FieldType::Stop) {\n          break;\n        }\n        skip(fieldType);\n      }\n      readStructEnd();\n      break;\n    }\n    case FieldType::Set: {\n      skipLinearContainer();\n      break;\n    }\n    case FieldType::Map: {\n      skipKVContainer();\n      break;\n    }\n    default: { break; }\n  }\n}", "target": 1}
{"code": "static int find_high_bit(unsigned int x)\n{\n\tint i;\n\tfor(i=31;i>=0;i--) {\n\t\tif(x&(1<<i)) return i;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int nfc_genl_dump_devices_done(struct netlink_callback *cb)\n{\n\tstruct class_dev_iter *iter = (struct class_dev_iter *) cb->args[0];\n\tif (iter) {\n\t\tnfc_device_iter_exit(iter);\n\t\tkfree(iter);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void key_gc_keytype(struct key_type *ktype)\n{\n\tkenter(\"%s\", ktype->name);\n\tkey_gc_dead_keytype = ktype;\n\tset_bit(KEY_GC_REAPING_KEYTYPE, &key_gc_flags);\n\tsmp_mb();\n\tset_bit(KEY_GC_REAP_KEYTYPE, &key_gc_flags);\n\tkdebug(\"schedule\");\n\tschedule_work(&key_gc_work);\n\tkdebug(\"sleep\");\n\twait_on_bit(&key_gc_flags, KEY_GC_REAPING_KEYTYPE,\n\t\t    TASK_UNINTERRUPTIBLE);\n\tkey_gc_dead_keytype = NULL;\n\tkleave(\"\");\n}", "target": 0}
{"code": "bool HeaderToMetadataFilter::addMetadata(StructMap& map, const std::string& meta_namespace,\n                                         const std::string& key, std::string value, ValueType type,\n                                         ValueEncode encode) const {\n  ProtobufWkt::Value val;\n  ASSERT(!value.empty());\n  if (value.size() >= MAX_HEADER_VALUE_LEN) {\n    ENVOY_LOG(debug, \"metadata value is too long\");\n    return false;\n  }\n  if (encode == envoy::extensions::filters::http::header_to_metadata::v3::Config::BASE64) {\n    value = Base64::decodeWithoutPadding(value);\n    if (value.empty()) {\n      ENVOY_LOG(debug, \"Base64 decode failed\");\n      return false;\n    }\n  }\n  switch (type) {\n  case envoy::extensions::filters::http::header_to_metadata::v3::Config::STRING:\n    val.set_string_value(std::move(value));\n    break;\n  case envoy::extensions::filters::http::header_to_metadata::v3::Config::NUMBER: {\n    double dval;\n    if (absl::SimpleAtod(StringUtil::trim(value), &dval)) {\n      val.set_number_value(dval);\n    } else {\n      ENVOY_LOG(debug, \"value to number conversion failed\");\n      return false;\n    }\n    break;\n  }\n  case envoy::extensions::filters::http::header_to_metadata::v3::Config::PROTOBUF_VALUE: {\n    if (!val.ParseFromString(value)) {\n      ENVOY_LOG(debug, \"parse from decoded string failed\");\n      return false;\n    }\n    break;\n  }\n  default:\n    NOT_REACHED_GCOVR_EXCL_LINE;\n  }\n  auto namespace_iter = map.find(meta_namespace);\n  if (namespace_iter == map.end()) {\n    map[meta_namespace] = ProtobufWkt::Struct();\n    namespace_iter = map.find(meta_namespace);\n  }\n  auto& keyval = namespace_iter->second;\n  (*keyval.mutable_fields())[key] = val;\n  return true;\n}", "target": 0}
{"code": "static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)\n{\n    long i;\n    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {\n        long a = *(long *)(src1 + i);\n        long b = *(long *)(src2 + i);\n        *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);\n    }\n    for (; i < w; i++)\n        dst[i] = src1[i] + src2[i];\n}", "target": 1}
{"code": "const SSL_CIPHER *dtls1_get_cipher(unsigned int u)\n{\n    const SSL_CIPHER *ciph = ssl3_get_cipher(u);\n    if (ciph != NULL) {\n        if (ciph->algorithm_enc == SSL_RC4)\n            return NULL;\n    }\n    return ciph;\n}", "target": 0}
{"code": "static inline void write_desc(struct intel_engine_execlists *execlists, u64 desc, u32 port)\n{\n\tif (execlists->ctrl_reg) {\n\t\twritel(lower_32_bits(desc), execlists->submit_reg + port * 2);\n\t\twritel(upper_32_bits(desc), execlists->submit_reg + port * 2 + 1);\n\t} else {\n\t\twritel(upper_32_bits(desc), execlists->submit_reg);\n\t\twritel(lower_32_bits(desc), execlists->submit_reg);\n\t}\n}", "target": 0}
{"code": "void ip4_datagram_release_cb(struct sock *sk)\n{\n\tconst struct inet_sock *inet = inet_sk(sk);\n\tconst struct ip_options_rcu *inet_opt;\n\t__be32 daddr = inet->inet_daddr;\n\tstruct flowi4 fl4;\n\tstruct rtable *rt;\n\tif (! __sk_dst_get(sk) || __sk_dst_check(sk, 0))\n\t\treturn;\n\trcu_read_lock();\n\tinet_opt = rcu_dereference(inet->inet_opt);\n\tif (inet_opt && inet_opt->opt.srr)\n\t\tdaddr = inet_opt->opt.faddr;\n\trt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,\n\t\t\t\t   inet->inet_saddr, inet->inet_dport,\n\t\t\t\t   inet->inet_sport, sk->sk_protocol,\n\t\t\t\t   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);\n\tif (!IS_ERR(rt))\n\t\t__sk_dst_set(sk, &rt->dst);\n\trcu_read_unlock();\n}", "target": 1}
{"code": "uipbuf_get_len_field(struct uip_ip_hdr *hdr)\n{\n  return ((uint16_t)(hdr->len[0]) << 8) + hdr->len[1];\n}", "target": 0}
{"code": "cdf_timespec_to_timestamp(cdf_timestamp_t *t, const struct timeval *ts)\n{\n#ifndef __lint__\n\t(void)&t;\n\t(void)&ts;\n#endif\n#ifdef notyet\n\tstruct tm tm;\n\tif (gmtime_r(&ts->ts_sec, &tm) == NULL) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\t*t = (ts->ts_usec / CDF_TIME_PREC) * CDF_TIME_PREC;\n\t*t = tm.tm_sec;\n\t*t += tm.tm_min * 60;\n\t*t += tm.tm_hour * 60 * 60;\n\t*t += tm.tm_mday * 60 * 60 * 24;\n#endif\n\treturn 0;\n}", "target": 0}
{"code": "FLAC__bool write_bitbuffer_(FLAC__StreamEncoder *encoder, uint32_t samples, FLAC__bool is_last_block)\n{\n\tconst FLAC__byte *buffer;\n\tsize_t bytes;\n\tFLAC__ASSERT(FLAC__bitwriter_is_byte_aligned(encoder->private_->frame));\n\tif(!FLAC__bitwriter_get_buffer(encoder->private_->frame, &buffer, &bytes)) {\n\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_MEMORY_ALLOCATION_ERROR;\n\t\treturn false;\n\t}\n\tif(encoder->protected_->verify) {\n\t\tencoder->private_->verify.output.data = buffer;\n\t\tencoder->private_->verify.output.bytes = bytes;\n\t\tif(encoder->private_->verify.state_hint == ENCODER_IN_MAGIC) {\n\t\t\tencoder->private_->verify.needs_magic_hack = true;\n\t\t}\n\t\telse {\n\t\t\tif(!FLAC__stream_decoder_process_single(encoder->private_->verify.decoder)) {\n\t\t\t\tFLAC__bitwriter_release_buffer(encoder->private_->frame);\n\t\t\t\tFLAC__bitwriter_clear(encoder->private_->frame);\n\t\t\t\tif(encoder->protected_->state != FLAC__STREAM_ENCODER_VERIFY_MISMATCH_IN_AUDIO_DATA)\n\t\t\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\tif(write_frame_(encoder, buffer, bytes, samples, is_last_block) != FLAC__STREAM_ENCODER_WRITE_STATUS_OK) {\n\t\tFLAC__bitwriter_release_buffer(encoder->private_->frame);\n\t\tFLAC__bitwriter_clear(encoder->private_->frame);\n\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;\n\t\treturn false;\n\t}\n\tFLAC__bitwriter_release_buffer(encoder->private_->frame);\n\tFLAC__bitwriter_clear(encoder->private_->frame);\n\tif(samples > 0) {\n\t\tencoder->private_->streaminfo.data.stream_info.min_framesize = flac_min(bytes, encoder->private_->streaminfo.data.stream_info.min_framesize);\n\t\tencoder->private_->streaminfo.data.stream_info.max_framesize = flac_max(bytes, encoder->private_->streaminfo.data.stream_info.max_framesize);\n\t}\n\treturn true;\n}", "target": 1}
{"code": "debug_print_string(uschar *debug_string)\n{\nif (!debug_string) return;\nHDEBUG(D_any|D_v)\n  {\n  uschar *s = expand_string(debug_string);\n  if (!s)\n    debug_printf(\"failed to expand debug_output \\\"%s\\\": %s\\n\", debug_string,\n      expand_string_message);\n  else if (s[0] != 0)\n    debug_printf(\"%s%s\", s, (s[Ustrlen(s)-1] == '\\n')? \"\" : \"\\n\");\n  }\n}", "target": 0}
{"code": "  bool const_item() const { return used_tables() == 0; }", "target": 1}
{"code": "const char* NavigatorServiceWorker::supplementName()\n{\n     return \"NavigatorServiceWorker\";\n }", "target": 0}
{"code": "static int openssl_static_locks_install(void)\n{\n    int result;\n    if (openssl_locks != NULL)\n    {\n        LogInfo(\"Locks already initialized\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        openssl_locks = malloc(CRYPTO_num_locks() * sizeof(LOCK_HANDLE));\n        if (openssl_locks == NULL)\n        {\n            LogError(\"Failed to allocate locks\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            int i;\n            for (i = 0; i < CRYPTO_num_locks(); i++)\n            {\n                openssl_locks[i] = Lock_Init();\n                if (openssl_locks[i] == NULL)\n                {\n                    LogError(\"Failed to allocate lock %d\", i);\n                    break;\n                }\n            }\n            if (i != CRYPTO_num_locks())\n            {\n                int j;\n                for (j = 0; j < i; j++)\n                {\n                    Lock_Deinit(openssl_locks[j]);\n                }\n                result = MU_FAILURE;\n            }\n            else\n            {\n                CRYPTO_set_locking_callback(openssl_static_locks_lock_unlock_cb);\n                result = 0;\n            }\n        }\n    }\n    return result;\n}", "target": 1}
{"code": "\tSilenceMessage(const std::string& mask, const std::string& flags)\n\t\t: ClientProtocol::Message(\"SILENCE\")\n\t{\n\t\tPushParam(mask);\n\t\tPushParamRef(flags);\n\t}", "target": 1}
{"code": "static int ieee802154_create(struct net *net, struct socket *sock,\n\t\t\t     int protocol, int kern)\n{\n\tstruct sock *sk;\n\tint rc;\n\tstruct proto *proto;\n\tconst struct proto_ops *ops;\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\tswitch (sock->type) {\n\tcase SOCK_RAW:\n\t\tproto = &ieee802154_raw_prot;\n\t\tops = &ieee802154_raw_ops;\n\t\tbreak;\n\tcase SOCK_DGRAM:\n\t\tproto = &ieee802154_dgram_prot;\n\t\tops = &ieee802154_dgram_ops;\n\t\tbreak;\n\tdefault:\n\t\trc = -ESOCKTNOSUPPORT;\n\t\tgoto out;\n\t}\n\trc = -ENOMEM;\n\tsk = sk_alloc(net, PF_IEEE802154, GFP_KERNEL, proto, kern);\n\tif (!sk)\n\t\tgoto out;\n\trc = 0;\n\tsock->ops = ops;\n\tsock_init_data(sock, sk);\n\tsk->sk_family = PF_IEEE802154;\n\tsock_set_flag(sk, SOCK_ZAPPED);\n\tif (sk->sk_prot->hash) {\n\t\trc = sk->sk_prot->hash(sk);\n\t\tif (rc) {\n\t\t\tsk_common_release(sk);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (sk->sk_prot->init) {\n\t\trc = sk->sk_prot->init(sk);\n\t\tif (rc)\n\t\t\tsk_common_release(sk);\n\t}\nout:\n\treturn rc;\n}", "target": 1}
{"code": "GF_HEVCConfig *gf_isom_hevc_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tif (gf_isom_get_reference_count(the_file, trackNumber, GF_ISOM_REF_TBAS)) {\n\t\tu32 ref_track;\n\t\tGF_Err e = gf_isom_get_reference(the_file, trackNumber, GF_ISOM_REF_TBAS, 1, &ref_track);\n\t\tif (e == GF_OK) {\n\t\t\ttrackNumber = ref_track;\n\t\t}\n\t}\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tif (gf_isom_get_hevc_lhvc_type(the_file, trackNumber, DescriptionIndex)==GF_ISOM_HEVCTYPE_NONE)\n\t\treturn NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\tif (!entry) return NULL;\n\tif (!entry->hevc_config) return NULL;\n\treturn HEVC_DuplicateConfig(entry->hevc_config->config);\n}", "target": 0}
{"code": "rb_insert_pages(struct ring_buffer_per_cpu *cpu_buffer)\n{\n\tstruct list_head *pages = &cpu_buffer->new_pages;\n\tint retries, success;\n\traw_spin_lock_irq(&cpu_buffer->reader_lock);\n\tretries = 10;\n\tsuccess = 0;\n\twhile (retries--) {\n\t\tstruct list_head *head_page, *prev_page, *r;\n\t\tstruct list_head *last_page, *first_page;\n\t\tstruct list_head *head_page_with_bit;\n\t\thead_page = &rb_set_head_page(cpu_buffer)->list;\n\t\tif (!head_page)\n\t\t\tbreak;\n\t\tprev_page = head_page->prev;\n\t\tfirst_page = pages->next;\n\t\tlast_page  = pages->prev;\n\t\thead_page_with_bit = (struct list_head *)\n\t\t\t\t     ((unsigned long)head_page | RB_PAGE_HEAD);\n\t\tlast_page->next = head_page_with_bit;\n\t\tfirst_page->prev = prev_page;\n\t\tr = cmpxchg(&prev_page->next, head_page_with_bit, first_page);\n\t\tif (r == head_page_with_bit) {\n\t\t\thead_page->prev = last_page;\n\t\t\tsuccess = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (success)\n\t\tINIT_LIST_HEAD(pages);\n\tRB_WARN_ON(cpu_buffer, !success);\n\traw_spin_unlock_irq(&cpu_buffer->reader_lock);\n\tif (!success) {\n\t\tstruct buffer_page *bpage, *tmp;\n\t\tlist_for_each_entry_safe(bpage, tmp, &cpu_buffer->new_pages,\n\t\t\t\t\t list) {\n\t\t\tlist_del_init(&bpage->list);\n\t\t\tfree_buffer_page(bpage);\n\t\t}\n\t}\n\treturn success;\n}", "target": 0}
{"code": "  void DefaultEnv::Initialize()\n  {\n    sLog           = new Log();\n    SetUpLog();\n    sEnv           = new DefaultEnv();\n    sForkHandler   = new ForkHandler();\n    sFileTimer     = new FileTimer();\n    sPlugInManager = new PlugInManager();\n    sPlugInManager->ProcessEnvironmentSettings();\n    sForkHandler->RegisterFileTimer( sFileTimer );\n#ifdef __APPLE__\n    char *errBuff = new char[1024];\n    const char *libs[] =\n    {\n      \"libXrdSeckrb5.so\",\n      \"libXrdSecgsi.so\",\n      \"libXrdSecgsiAuthzVO.so\",\n      \"libXrdSecgsiGMAPDN.so\",\n      \"libXrdSecgsiGMAPLDAP.so\",\n      \"libXrdSecpwd.so\",\n      \"libXrdSecsss.so\",\n      \"libXrdSecunix.so\",\n      0\n    };\n    for( int i = 0; libs[i]; ++i )\n    {\n      sLog->Debug( UtilityMsg, \"Attempting to pre-load: %s\", libs[i] );\n      bool ok = XrdOucPreload( libs[i], errBuff, 1024 );\n      if( !ok )\n        sLog->Error( UtilityMsg, \"Unable to pre-load %s: %s\", libs[i], errBuff );\n    }\n    delete [] errBuff;\n#endif\n  }", "target": 1}
{"code": "void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tunsigned long flags;\n\tif (PCM_RUNTIME_CHECK(substream))\n\t\treturn;\n\truntime = substream->runtime;\n\tsnd_pcm_stream_lock_irqsave(substream, flags);\n\tif (!snd_pcm_running(substream) ||\n\t    snd_pcm_update_hw_ptr0(substream, 1) < 0)\n\t\tgoto _end;\n#ifdef CONFIG_SND_PCM_TIMER\n\tif (substream->timer_running)\n\t\tsnd_timer_interrupt(substream->timer, 1);\n#endif\n _end:\n\tsnd_pcm_stream_unlock_irqrestore(substream, flags);\n\tkill_fasync(&runtime->fasync, SIGIO, POLL_IN);\n}", "target": 1}
{"code": "void calc_group_buffer(TMP_TABLE_PARAM *param, ORDER *group)\n{\n  uint key_length=0, parts=0, null_parts=0;\n  for (; group ; group=group->next)\n  {\n    Item *group_item= *group->item;\n    Field *field= group_item->get_tmp_table_field();\n    if (field)\n    {\n      enum_field_types type;\n      if ((type= field->type()) == MYSQL_TYPE_BLOB)\n\tkey_length+=MAX_BLOB_WIDTH;\t\t\n      else if (type == MYSQL_TYPE_VARCHAR || type == MYSQL_TYPE_VAR_STRING)\n        key_length+= field->field_length + HA_KEY_BLOB_LENGTH;\n      else if (type == MYSQL_TYPE_BIT)\n      {\n        key_length+= 8;                         \n      }\n      else\n\tkey_length+= field->pack_length();\n    }\n    else\n    { \n      switch (group_item->cmp_type()) {\n      case REAL_RESULT:\n        key_length+= sizeof(double);\n        break;\n      case INT_RESULT:\n        key_length+= sizeof(longlong);\n        break;\n      case DECIMAL_RESULT:\n        key_length+= my_decimal_get_binary_size(group_item->max_length - \n                                                (group_item->decimals ? 1 : 0),\n                                                group_item->decimals);\n        break;\n      case TIME_RESULT:\n      {\n        key_length+= 8;\n        break;\n      }\n      case STRING_RESULT:\n      {\n        enum enum_field_types type= group_item->field_type();\n        if (type == MYSQL_TYPE_BLOB)\n          key_length+= MAX_BLOB_WIDTH;\t\t\n        else\n        {\n          key_length+= group_item->max_length + HA_KEY_BLOB_LENGTH;\n        }\n        break;\n      }\n      default:\n        DBUG_ASSERT(0);\n        my_error(ER_OUT_OF_RESOURCES, MYF(ME_FATAL));\n      }\n    }\n    parts++;\n    if (group_item->maybe_null)\n      null_parts++;\n  }\n  param->group_length= key_length + null_parts;\n  param->group_parts= parts;\n  param->group_null_parts= null_parts;\n}", "target": 0}
{"code": "GF_Err trak_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_TrackBox *ptr = (GF_TrackBox *)s;\n\tif (ptr->sample_encryption && ptr->sample_encryption->load_needed) {\n\t\tif (!ptr->moov || !!ptr->moov->mov || !ptr->moov->mov->movieFileMap)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tGF_Err e = senc_Parse(ptr->moov->mov->movieFileMap->bs, ptr, NULL, ptr->sample_encryption);\n\t\tif (e) return e;\n\t}\n\tgf_isom_check_position(s, (GF_Box *)ptr->Header, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->Aperture, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->References, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->editBox, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->Media, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->meta, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->groups, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->udta, &pos);\n\treturn GF_OK;", "target": 0}
{"code": "spnego_gss_unwrap_aead(OM_uint32 *minor_status,\n\t\t       gss_ctx_id_t context_handle,\n\t\t       gss_buffer_t input_message_buffer,\n\t\t       gss_buffer_t input_assoc_buffer,\n\t\t       gss_buffer_t output_payload_buffer,\n\t\t       int *conf_state,\n\t\t       gss_qop_t *qop_state)\n{\n\tOM_uint32 ret;\n\tret = gss_unwrap_aead(minor_status,\n\t\t\t      context_handle,\n\t\t\t      input_message_buffer,\n\t\t\t      input_assoc_buffer,\n\t\t\t      output_payload_buffer,\n\t\t\t      conf_state,\n\t\t\t      qop_state);\n\treturn (ret);\n}", "target": 1}
{"code": "static int vhost_worker(void *data)\n{\n\tstruct vhost_dev *dev = data;\n\tstruct vhost_work *work = NULL;\n\tunsigned uninitialized_var(seq);\n\tmm_segment_t oldfs = get_fs();\n\tset_fs(USER_DS);\n\tuse_mm(dev->mm);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tspin_lock_irq(&dev->work_lock);\n\t\tif (work) {\n\t\t\twork->done_seq = seq;\n\t\t\tif (work->flushing)\n\t\t\t\twake_up_all(&work->done);\n\t\t}\n\t\tif (kthread_should_stop()) {\n\t\t\tspin_unlock_irq(&dev->work_lock);\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t\tbreak;\n\t\t}\n\t\tif (!list_empty(&dev->work_list)) {\n\t\t\twork = list_first_entry(&dev->work_list,\n\t\t\t\t\t\tstruct vhost_work, node);\n\t\t\tlist_del_init(&work->node);\n\t\t\tseq = work->queue_seq;\n\t\t} else\n\t\t\twork = NULL;\n\t\tspin_unlock_irq(&dev->work_lock);\n\t\tif (work) {\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t\twork->fn(work);\n\t\t\tif (need_resched())\n\t\t\t\tschedule();\n\t\t} else\n\t\t\tschedule();\n\t}\n\tunuse_mm(dev->mm);\n\tset_fs(oldfs);\n\treturn 0;\n}", "target": 0}
{"code": "int parse_sa_P_opt(char *argv[], int *opt, unsigned int *flags, struct activity *act[])\n{\n\tint p;\n\tp = get_activity_position(act, A_CPU, EXIT_IF_NOT_FOUND);\n\tif (argv[++(*opt)]) {\n\t\tif (parse_values(argv[*opt], act[p]->bitmap->b_array,\n\t\t\t     act[p]->bitmap->b_size, K_LOWERALL))\n\t\t\treturn 1;\n\t\t(*opt)++;\n\t\t*flags |= S_F_OPTION_P;\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "unsigned long insn_get_seg_base(struct pt_regs *regs, int seg_reg_idx)\n{\n\tstruct desc_struct *desc;\n\tshort sel;\n\tsel = get_segment_selector(regs, seg_reg_idx);\n\tif (sel < 0)\n\t\treturn -1L;\n\tif (v8086_mode(regs))\n\t\treturn (unsigned long)(sel << 4);\n\tif (user_64bit_mode(regs)) {\n\t\tunsigned long base;\n\t\tif (seg_reg_idx == INAT_SEG_REG_FS)\n\t\t\trdmsrl(MSR_FS_BASE, base);\n\t\telse if (seg_reg_idx == INAT_SEG_REG_GS)\n\t\t\trdmsrl(MSR_KERNEL_GS_BASE, base);\n\t\telse\n\t\t\tbase = 0;\n\t\treturn base;\n\t}\n\tif (!sel)\n\t\treturn -1L;\n\tdesc = get_desc(sel);\n\tif (!desc)\n\t\treturn -1L;\n\treturn get_desc_base(desc);\n}", "target": 1}
{"code": "AsyncSocket::WriteResult AsyncSSLSocket::interpretSSLError(int rc, int error) {\n  if (error == SSL_ERROR_WANT_READ) {\n    LOG(ERROR) << \"AsyncSSLSocket(fd=\" << fd_ << \", state=\" << int(state_)\n               << \", sslState=\" << sslState_ << \", events=\" << eventFlags_\n               << \"): \"\n               << \"unsupported SSL renegotiation during write\";\n    return WriteResult(\n        WRITE_ERROR,\n        std::make_unique<SSLException>(SSLError::INVALID_RENEGOTIATION));\n  } else {\n    if (zero_return(error, rc, errno)) {\n      return WriteResult(0);\n    }\n    auto errError = ERR_get_error();\n    VLOG(3) << \"ERROR: AsyncSSLSocket(fd=\" << fd_ << \", state=\" << int(state_)\n            << \", sslState=\" << sslState_ << \", events=\" << eventFlags_ << \"): \"\n            << \"SSL error: \" << error << \", errno: \" << errno\n            << \", func: \" << ERR_func_error_string(errError)\n            << \", reason: \" << ERR_reason_error_string(errError);\n    return WriteResult(\n        WRITE_ERROR,\n        std::make_unique<SSLException>(error, errError, rc, errno));\n  }\n}", "target": 1}
{"code": "static void init_skiplist(struct fsck_options *options, const char *path)\n{\n\tstatic struct oid_array skiplist = OID_ARRAY_INIT;\n\tint sorted, fd;\n\tchar buffer[GIT_MAX_HEXSZ + 1];\n\tstruct object_id oid;\n\tif (options->skiplist)\n\t\tsorted = options->skiplist->sorted;\n\telse {\n\t\tsorted = 1;\n\t\toptions->skiplist = &skiplist;\n\t}\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0)\n\t\tdie(\"Could not open skip list: %s\", path);\n\tfor (;;) {\n\t\tconst char *p;\n\t\tint result = read_in_full(fd, buffer, sizeof(buffer));\n\t\tif (result < 0)\n\t\t\tdie_errno(\"Could not read '%s'\", path);\n\t\tif (!result)\n\t\t\tbreak;\n\t\tif (parse_oid_hex(buffer, &oid, &p) || *p != '\\n')\n\t\t\tdie(\"Invalid SHA-1: %s\", buffer);\n\t\toid_array_append(&skiplist, &oid);\n\t\tif (sorted && skiplist.nr > 1 &&\n\t\t\t\toidcmp(&skiplist.oid[skiplist.nr - 2],\n\t\t\t\t       &oid) > 0)\n\t\t\tsorted = 0;\n\t}\n\tclose(fd);\n\tif (sorted)\n\t\tskiplist.sorted = 1;\n}", "target": 0}
{"code": "static int em_popa(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc = X86EMUL_CONTINUE;\n\tint reg = VCPU_REGS_RDI;\n\twhile (reg >= VCPU_REGS_RAX) {\n\t\tif (reg == VCPU_REGS_RSP) {\n\t\t\tregister_address_increment(ctxt, &ctxt->regs[VCPU_REGS_RSP],\n\t\t\t\t\t\t\tctxt->op_bytes);\n\t\t\t--reg;\n\t\t}\n\t\trc = emulate_pop(ctxt, &ctxt->regs[reg], ctxt->op_bytes);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tbreak;\n\t\t--reg;\n\t}\n\treturn rc;\n}", "target": 0}
{"code": "inline typename V::VectorType FBUnserializer<V>::unserializeList() {\n  p_ += CODE_SIZE;\n  unserializeInt64();\n  typename V::VectorType ret = V::createVector();\n  size_t code = nextCode();\n  while (code != FB_SERIALIZE_STOP) {\n    V::vectorAppend(ret, unserializeThing());\n    code = nextCode();\n  }\n  p_ += CODE_SIZE;\n  return ret;\n}", "target": 1}
{"code": "static int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)\n{\n\tint r = 0, start = 0;\n\tu32 prev_legacy, cur_legacy;\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tprev_legacy = kvm->arch.vpit->pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY;\n\tcur_legacy = ps->flags & KVM_PIT_FLAGS_HPET_LEGACY;\n\tif (!prev_legacy && cur_legacy)\n\t\tstart = 1;\n\tmemcpy(&kvm->arch.vpit->pit_state.channels, &ps->channels,\n\t       sizeof(kvm->arch.vpit->pit_state.channels));\n\tkvm->arch.vpit->pit_state.flags = ps->flags;\n\tkvm_pit_load_count(kvm, 0, kvm->arch.vpit->pit_state.channels[0].count, start);\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\treturn r;\n}", "target": 0}
{"code": "static enum hrtimer_restart posix_timer_fn(struct hrtimer *timer)\n{\n\tstruct k_itimer *timr;\n\tunsigned long flags;\n\tint si_private = 0;\n\tenum hrtimer_restart ret = HRTIMER_NORESTART;\n\ttimr = container_of(timer, struct k_itimer, it.real.timer);\n\tspin_lock_irqsave(&timr->it_lock, flags);\n\ttimr->it_active = 0;\n\tif (timr->it_interval != 0)\n\t\tsi_private = ++timr->it_requeue_pending;\n\tif (posix_timer_event(timr, si_private)) {\n\t\tif (timr->it_interval != 0) {\n\t\t\tktime_t now = hrtimer_cb_get_time(timer);\n#ifdef CONFIG_HIGH_RES_TIMERS\n\t\t\t{\n\t\t\t\tktime_t kj = NSEC_PER_SEC / HZ;\n\t\t\t\tif (timr->it_interval < kj)\n\t\t\t\t\tnow = ktime_add(now, kj);\n\t\t\t}\n#endif\n\t\t\ttimr->it_overrun += (unsigned int)\n\t\t\t\thrtimer_forward(timer, now,\n\t\t\t\t\t\ttimr->it_interval);\n\t\t\tret = HRTIMER_RESTART;\n\t\t\t++timr->it_requeue_pending;\n\t\t\ttimr->it_active = 1;\n\t\t}\n\t}\n\tunlock_timer(timr, flags);\n\treturn ret;\n}", "target": 1}
{"code": "static int decode_sequence(struct xdr_stream *xdr,\n\t\t\t   struct nfs4_sequence_res *res,\n\t\t\t   struct rpc_rqst *rqstp)\n{\n#if defined(CONFIG_NFS_V4_1)\n\tstruct nfs4_sessionid id;\n\tu32 dummy;\n\tint status;\n\t__be32 *p;\n\tif (!res->sr_session)\n\t\treturn 0;\n\tstatus = decode_op_hdr(xdr, OP_SEQUENCE);\n\tif (!status)\n\t\tstatus = decode_sessionid(xdr, &id);\n\tif (unlikely(status))\n\t\tgoto out_err;\n\tstatus = -EREMOTEIO;\n\tif (memcmp(id.data, res->sr_session->sess_id.data,\n\t\t   NFS4_MAX_SESSIONID_LEN)) {\n\t\tdprintk(\"%s Invalid session id\\n\", __func__);\n\t\tgoto out_err;\n\t}\n\tp = xdr_inline_decode(xdr, 20);\n\tif (unlikely(!p))\n\t\tgoto out_overflow;\n\tdummy = be32_to_cpup(p++);\n\tif (dummy != res->sr_slot->seq_nr) {\n\t\tdprintk(\"%s Invalid sequence number\\n\", __func__);\n\t\tgoto out_err;\n\t}\n\tdummy = be32_to_cpup(p++);\n\tif (dummy != res->sr_slot - res->sr_session->fc_slot_table.slots) {\n\t\tdprintk(\"%s Invalid slot id\\n\", __func__);\n\t\tgoto out_err;\n\t}\n\tdummy = be32_to_cpup(p++);\n\tdummy = be32_to_cpup(p++);\n\tres->sr_status_flags = be32_to_cpup(p);\n\tstatus = 0;\nout_err:\n\tres->sr_status = status;\n\treturn status;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\tstatus = -EIO;\n\tgoto out_err;\n#else  \n\treturn 0;\n#endif \n}", "target": 0}
{"code": "TEST_P(RBACIntegrationTest, DeniedWithPrefixRule) {\n  config_helper_.addConfigModifier(\n      [](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n             cfg) { cfg.mutable_normalize_path()->set_value(false); });\n  config_helper_.addFilter(RBAC_CONFIG_WITH_PREFIX_MATCH);\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response = codec_client_->makeRequestWithBody(\n      Http::TestRequestHeaderMapImpl{\n          {\":method\", \"POST\"},\n          {\":path\", \"/foo/../bar\"},\n          {\":scheme\", \"http\"},\n          {\":authority\", \"host\"},\n          {\"x-forwarded-for\", \"10.0.0.1\"},\n      },\n      1024);\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}}, true);\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().getStatusValue());\n}", "target": 0}
{"code": "LCN ntfs_attr_vcn_to_lcn(ntfs_attr *na, const VCN vcn)\n{\n\tLCN lcn;\n\tBOOL is_retry = FALSE;\n\tif (!na || !NAttrNonResident(na) || vcn < 0)\n\t\treturn (LCN)LCN_EINVAL;\n\tntfs_log_trace(\"Entering for inode 0x%llx, attr 0x%x.\\n\", (unsigned long\n\t\t\tlong)na->ni->mft_no, le32_to_cpu(na->type));\nretry:\n\tlcn = ntfs_rl_vcn_to_lcn(na->rl, vcn);\n\tif (lcn >= 0)\n\t\treturn lcn;\n\tif (!is_retry && !ntfs_attr_map_runlist(na, vcn)) {\n\t\tis_retry = TRUE;\n\t\tgoto retry;\n\t}\n\tif (!is_retry || lcn == (LCN)LCN_RL_NOT_MAPPED)\n\t\treturn (LCN)LCN_EIO;\n\treturn lcn;\n}", "target": 0}
{"code": "static int fuse_push_module(struct fuse *f, const char *module,\n                            struct fuse_args *args)\n{\n    struct fuse_fs *newfs;\n    struct fuse_module *m = fuse_get_module(module);\n    struct fuse_fs *fs[2];\n    fs[0] = f->fs;\n    fs[1] = NULL;\n    if (!m)\n        return -1;\n    newfs = m->factory(args, fs);\n    if (!newfs) {\n        fuse_put_module(m);\n        return -1;\n    }\n    newfs->m = m;\n    f->fs = newfs;\n    return 0;\n}", "target": 0}
{"code": "gpg_ctx_add_recipient (struct _GpgCtx *gpg,\n                       const gchar *keyid)\n{\n\tif (gpg->mode != GPG_CTX_MODE_ENCRYPT && gpg->mode != GPG_CTX_MODE_EXPORT)\n\t\treturn;\n\tif (!gpg->recipients)\n\t\tgpg->recipients = g_ptr_array_new ();\n\tg_ptr_array_add (gpg->recipients, g_strdup (keyid));\n}", "target": 1}
{"code": "void ext4_xattr_destroy_cache(struct mb_cache *cache)\n{\n\tif (cache)\n\t\tmb_cache_destroy(cache);\n}", "target": 1}
{"code": "static inline int get_len(LZOContext *c, int x, int mask)\n{\n    int cnt = x & mask;\n    if (!cnt) {\n        while (!(x = get_byte(c)))\n            cnt += 255;\n        cnt += mask + x;\n    }\n    return cnt;\n}", "target": 1}
{"code": "static __init int seqgen_init(void)\n{\n\trekey_seq_generator(NULL);\n\treturn 0;\n}", "target": 1}
{"code": "njs_string_prototype_match(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    njs_str_t             string;\n    njs_int_t             ret;\n    njs_value_t           arguments[2];\n    njs_regexp_pattern_t  *pattern;\n    ret = njs_string_object_validate(vm, njs_argument(args, 0));\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    arguments[1] = args[0];\n    string.start = NULL;\n    string.length = 0;\n    if (nargs > 1) {\n        if (njs_is_regexp(&args[1])) {\n            pattern = njs_regexp_pattern(&args[1]);\n            if (pattern->global) {\n                return njs_string_match_multiple(vm, args, pattern);\n            }\n            arguments[0] = args[1];\n            goto match;\n        }\n        if (!njs_is_string(&args[1])) {\n            if (!njs_is_undefined(&args[1])) {\n                ret = njs_value_to_string(vm, &args[1], &args[1]);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    return ret;\n                }\n                njs_string_get(&args[1], &string);\n            }\n        } else {\n            njs_string_get(&args[1], &string);\n        }\n    }\n    ret = njs_regexp_create(vm, &arguments[0], string.start, string.length, 0);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\nmatch:\n    return njs_regexp_prototype_exec(vm, arguments, nargs, unused);\n}", "target": 0}
{"code": "coolkey_get_attribute_data_fixed(CK_ATTRIBUTE_TYPE attr_type, unsigned long fixed_attributes,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsc_cardctl_coolkey_attribute_t *attr_out) {\n\tunsigned long cka_id = fixed_attributes & 0xf;\n\tunsigned long cka_class = ((fixed_attributes) >> 4) & 0x7;\n\tunsigned long mask, bit;\n\tif (attr_type == CKA_ID) {\n\t\tattr_out->attribute_length = 1;\n\t\tattr_out->attribute_value= &coolkey_static_cka_id[cka_id];\n\t\treturn SC_SUCCESS;\n\t}\n\tif (attr_type == CKA_CLASS) {\n\t\tattr_out->attribute_data_type = SC_CARDCTL_COOLKEY_ATTR_TYPE_ULONG;\n\t\tattr_out->attribute_length = 4;\n\t\tattr_out->attribute_value = coolkey_static_cka_class[cka_class].class_value;\n\t\treturn SC_SUCCESS;\n\t}\n\tmask = coolkey_static_cka_class[cka_class].boolean_mask;\n\tbit = coolkey_get_fixed_boolean_bit(attr_type);\n\tif ((bit & mask) == 0) {\n\t\treturn SC_ERROR_DATA_OBJECT_NOT_FOUND;\n\t}\n\tattr_out->attribute_length = 1;\n\tattr_out->attribute_value = bit & fixed_attributes ? &coolkey_static_true : &coolkey_static_false;\n\treturn SC_SUCCESS;\n}", "target": 0}
{"code": "static u32 bnx2x_reg_rd_ind(struct bnx2x *bp, u32 addr)\n{\n\tu32 val;\n\tpci_write_config_dword(bp->pdev, PCICFG_GRC_ADDRESS, addr);\n\tpci_read_config_dword(bp->pdev, PCICFG_GRC_DATA, &val);\n\tpci_write_config_dword(bp->pdev, PCICFG_GRC_ADDRESS,\n\t\t\t       PCICFG_VENDOR_ID_OFFSET);\n\treturn val;\n}", "target": 0}
{"code": "static inline long put_compat_itimerval(struct compat_itimerval __user *o,\n\t\tstruct itimerval *i)\n{\n\treturn (!access_ok(VERIFY_WRITE, o, sizeof(*o)) ||\n\t\t(__put_user(i->it_interval.tv_sec, &o->it_interval.tv_sec) |\n\t\t __put_user(i->it_interval.tv_usec, &o->it_interval.tv_usec) |\n\t\t __put_user(i->it_value.tv_sec, &o->it_value.tv_sec) |\n\t\t __put_user(i->it_value.tv_usec, &o->it_value.tv_usec)));\n}", "target": 0}
{"code": "static enum count_type __read_io_type(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tif (mapping) {\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\t\tif (inode->i_ino == F2FS_META_INO(sbi))\n\t\t\treturn F2FS_RD_META;\n\t\tif (inode->i_ino == F2FS_NODE_INO(sbi))\n\t\t\treturn F2FS_RD_NODE;\n\t}\n\treturn F2FS_RD_DATA;\n}", "target": 1}
{"code": "        int          GetS32BE (int nPos, bool *pbSuccess)\n        {\n            if ( nPos < 0 || nPos + 3 >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            int nRes = m_sFile[ nPos ];\n            nRes = (nRes << 8) + m_sFile[nPos + 1];\n            nRes = (nRes << 8) + m_sFile[nPos + 2];\n            nRes = (nRes << 8) + m_sFile[nPos + 3];\n            if ( nRes & 0x80000000 )\n                nRes |= ~0xffffffff;\n            return nRes;\n        }", "target": 1}
{"code": "void ping_unhash(struct sock *sk)\n{\n\tstruct inet_sock *isk = inet_sk(sk);\n\tpr_debug(\"ping_unhash(isk=%p,isk->num=%u)\\n\", isk, isk->inet_num);\n\twrite_lock_bh(&ping_table.lock);\n\tif (sk_hashed(sk)) {\n\t\thlist_nulls_del(&sk->sk_nulls_node);\n\t\tsk_nulls_node_init(&sk->sk_nulls_node);\n\t\tsock_put(sk);\n\t\tisk->inet_num = 0;\n\t\tisk->inet_sport = 0;\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\t}\n\twrite_unlock_bh(&ping_table.lock);\n}", "target": 0}
{"code": " static OPJ_BOOL bmp_read_rle8_data(FILE* IN, OPJ_UINT8* pData,\n                                    OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)\n {\n    OPJ_UINT32 x, y;\n     OPJ_UINT8 *pix;\n     const OPJ_UINT8 *beyond;\n     beyond = pData + stride * height;\n     pix = pData;\n    x = y = 0U;\n     while (y < height) {\n         int c = getc(IN);\n         if (c == EOF) {\n            return OPJ_FALSE;\n        }\n        if (c) {\n            int j, c1_int;\n            OPJ_UINT8 c1;\n            c1_int = getc(IN);\n            if (c1_int == EOF) {\n                return OPJ_FALSE;\n            }\n            c1 = (OPJ_UINT8)c1_int;\n             for (j = 0; (j < c) && (x < width) &&\n                     ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n                 *pix = c1;\n             }\n         } else {\n             c = getc(IN);\n            if (c == EOF) {\n                return OPJ_FALSE;\n            }\n            if (c == 0x00) { \n                x = 0;\n                ++y;\n                pix = pData + y * stride + x;\n            } else if (c == 0x01) { \n                break;\n            } else if (c == 0x02) { \n                c = getc(IN);\n                if (c == EOF) {\n                    return OPJ_FALSE;\n                }\n                x += (OPJ_UINT32)c;\n                c = getc(IN);\n                if (c == EOF) {\n                    return OPJ_FALSE;\n                }\n                y += (OPJ_UINT32)c;\n                pix = pData + y * stride + x;\n            } else { \n                int j;\n                for (j = 0; (j < c) && (x < width) &&\n                        ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n                    int c1_int;\n                    OPJ_UINT8 c1;\n                    c1_int = getc(IN);\n                    if (c1_int == EOF) {\n                        return OPJ_FALSE;\n                     }\n                     c1 = (OPJ_UINT8)c1_int;\n                     *pix = c1;\n                 }\n                 if ((OPJ_UINT32)c & 1U) { \n                     c = getc(IN);\n                    if (c == EOF) {\n                        return OPJ_FALSE;\n                    }\n                }\n             }\n         }\n     }\n     return OPJ_TRUE;\n }", "target": 1}
{"code": "RoleName RoleName::parseFromBSON(const BSONElement& elem) {\n    auto obj = elem.embeddedObjectUserCheck();\n    std::array<BSONElement, 2> fields;\n    obj.getFields(\n        {AuthorizationManager::ROLE_NAME_FIELD_NAME, AuthorizationManager::ROLE_DB_FIELD_NAME},\n        &fields);\n    const auto& nameField = fields[0];\n    uassert(ErrorCodes::BadValue,\n            str::stream() << \"user name must contain a string field named: \"\n                          << AuthorizationManager::ROLE_NAME_FIELD_NAME,\n            nameField.type() == String);\n    const auto& dbField = fields[1];\n    uassert(ErrorCodes::BadValue,\n            str::stream() << \"role name must contain a string field named: \"\n                          << AuthorizationManager::ROLE_DB_FIELD_NAME,\n            nameField.type() == String);\n    return RoleName(nameField.valueStringData(), dbField.valueStringData());\n}", "target": 1}
{"code": "int ping_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct inet_sock *isk = inet_sk(sk);\n\tunsigned short snum;\n\tint err;\n\tint dif = sk->sk_bound_dev_if;\n\terr = ping_check_bind_addr(sk, isk, uaddr, addr_len);\n\tif (err)\n\t\treturn err;\n\tlock_sock(sk);\n\terr = -EINVAL;\n\tif (isk->inet_num != 0)\n\t\tgoto out;\n\terr = -EADDRINUSE;\n\tping_set_saddr(sk, uaddr);\n\tsnum = ntohs(((struct sockaddr_in *)uaddr)->sin_port);\n\tif (ping_get_port(sk, snum) != 0) {\n\t\tping_clear_saddr(sk, dif);\n\t\tgoto out;\n\t}\n\tpr_debug(\"after bind(): num = %hu, dif = %d\\n\",\n\t\t isk->inet_num,\n\t\t sk->sk_bound_dev_if);\n\terr = 0;\n\tif (sk->sk_family == AF_INET && isk->inet_rcv_saddr)\n\t\tsk->sk_userlocks |= SOCK_BINDADDR_LOCK;\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (sk->sk_family == AF_INET6 && !ipv6_addr_any(&sk->sk_v6_rcv_saddr))\n\t\tsk->sk_userlocks |= SOCK_BINDADDR_LOCK;\n#endif\n\tif (snum)\n\t\tsk->sk_userlocks |= SOCK_BINDPORT_LOCK;\n\tisk->inet_sport = htons(isk->inet_num);\n\tisk->inet_daddr = 0;\n\tisk->inet_dport = 0;\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (sk->sk_family == AF_INET6)\n\t\tmemset(&sk->sk_v6_daddr, 0, sizeof(sk->sk_v6_daddr));\n#endif\n\tsk_dst_reset(sk);\nout:\n\trelease_sock(sk);\n\tpr_debug(\"ping_v4_bind -> %d\\n\", err);\n\treturn err;\n}", "target": 0}
{"code": "    template<typename t>\n    T& max_min(t& min_val) {\n      if (is_empty())\n        throw CImgInstanceException(_cimglist_instance\n                                    \"max_min(): Empty instance.\",\n                                    cimglist_instance);\n      T *ptr_max = _data->_data;\n      T min_value = *ptr_max, max_value = min_value;\n      cimglist_for(*this,l) {\n        const CImg<T>& img = _data[l];\n        cimg_for(img,ptrs,T) {\n          const T val = *ptrs;\n          if (val>max_value) { max_value = val; ptr_max = ptrs; }\n          if (val<min_value) min_value = val;\n        }", "target": 0}
{"code": "scrollback_get_filename (session *sess)\n{\n\tchar *net, *chan, *buf, *ret = NULL;\n\tnet = server_get_network (sess->server, FALSE);\n\tif (!net)\n\t\treturn NULL;\n\tbuf = g_strdup_printf (\"%s\" G_DIR_SEPARATOR_S \"scrollback\" G_DIR_SEPARATOR_S \"%s\" G_DIR_SEPARATOR_S \"%s.txt\", get_xdir (), net, \"\");\n\tmkdir_p (buf);\n\tg_free (buf);\n\tchan = log_create_filename (sess->channel);\n\tif (chan[0])\n\t\tbuf = g_strdup_printf (\"%s\" G_DIR_SEPARATOR_S \"scrollback\" G_DIR_SEPARATOR_S \"%s\" G_DIR_SEPARATOR_S \"%s.txt\", get_xdir (), net, chan);\n\telse\n\t\tbuf = NULL;\n\tg_free (chan);\n\tif (buf)\n\t{\n\t\tret = g_filename_from_utf8 (buf, -1, NULL, NULL, NULL);\n\t\tg_free (buf);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "void usbredirparser_init(struct usbredirparser *parser_pub,\n    const char *version, uint32_t *caps, int caps_len, int flags)\n{\n    struct usbredirparser_priv *parser =\n        (struct usbredirparser_priv *)parser_pub;\n    struct usb_redir_hello_header hello = { { 0 }, };\n    parser->flags = (flags & ~usbredirparser_fl_no_hello);\n    if (parser->callb.alloc_lock_func) {\n        parser->lock = parser->callb.alloc_lock_func();\n    }\n    snprintf(hello.version, sizeof(hello.version), \"%s\", version);\n    if (caps_len > USB_REDIR_CAPS_SIZE) {\n        caps_len = USB_REDIR_CAPS_SIZE;\n    }\n    memcpy(parser->our_caps, caps, caps_len * sizeof(uint32_t));\n    if (!(flags & usbredirparser_fl_usb_host))\n        usbredirparser_caps_set_cap(parser->our_caps,\n                                    usb_redir_cap_device_disconnect_ack);\n    usbredirparser_verify_caps(parser, parser->our_caps, \"our\");\n    if (!(flags & usbredirparser_fl_no_hello))\n        usbredirparser_queue(parser_pub, usb_redir_hello, 0, &hello,\n                             (uint8_t *)parser->our_caps,\n                             USB_REDIR_CAPS_SIZE * sizeof(uint32_t));\n}", "target": 0}
{"code": "static struct tipc_node *tipc_node_find_by_name(struct net *net,\n\t\t\t\t\t\tconst char *link_name,\n\t\t\t\t\t\tunsigned int *bearer_id)\n{\n\tstruct tipc_net *tn = net_generic(net, tipc_net_id);\n\tstruct tipc_link *l;\n\tstruct tipc_node *n;\n\tstruct tipc_node *found_node = NULL;\n\tint i;\n\t*bearer_id = 0;\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(n, &tn->node_list, list) {\n\t\ttipc_node_read_lock(n);\n\t\tfor (i = 0; i < MAX_BEARERS; i++) {\n\t\t\tl = n->links[i].link;\n\t\t\tif (l && !strcmp(tipc_link_name(l), link_name)) {\n\t\t\t\t*bearer_id = i;\n\t\t\t\tfound_node = n;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ttipc_node_read_unlock(n);\n\t\tif (found_node)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\treturn found_node;\n}", "target": 0}
{"code": "  void createDebugInfo() override {\n    llvm_unreachable(\"Accessing debug info from a lazy module\");\n  }", "target": 1}
{"code": "EC_GROUP *d2i_ECPKParameters(EC_GROUP **a, const unsigned char **in, long len)\n{\n    EC_GROUP *group = NULL;\n    ECPKPARAMETERS *params = NULL;\n    if ((params = d2i_ECPKPARAMETERS(NULL, in, len)) == NULL) {\n        ECerr(EC_F_D2I_ECPKPARAMETERS, EC_R_D2I_ECPKPARAMETERS_FAILURE);\n        ECPKPARAMETERS_free(params);\n        return NULL;\n    }\n    if ((group = ec_asn1_pkparameters2group(params)) == NULL) {\n        ECerr(EC_F_D2I_ECPKPARAMETERS, EC_R_PKPARAMETERS2GROUP_FAILURE);\n        return NULL;\n    }\n    if (a && *a)\n        EC_GROUP_clear_free(*a);\n    if (a)\n        *a = group;\n    ECPKPARAMETERS_free(params);\n    return (group);\n}", "target": 0}
{"code": "static int hashtable_do_del(hashtable_t *hashtable,\n                            const char *key, size_t hash)\n{\n    pair_t *pair;\n    bucket_t *bucket;\n    size_t index;\n    index = hash % num_buckets(hashtable);\n    bucket = &hashtable->buckets[index];\n    pair = hashtable_find_pair(hashtable, bucket, key, hash);\n    if(!pair)\n        return -1;\n    if(&pair->list == bucket->first && &pair->list == bucket->last)\n        bucket->first = bucket->last = &hashtable->list;\n    else if(&pair->list == bucket->first)\n        bucket->first = pair->list.next;\n    else if(&pair->list == bucket->last)\n        bucket->last = pair->list.prev;\n    list_remove(&pair->list);\n    json_decref(pair->value);\n    jsonp_free(pair);\n    hashtable->size--;\n    return 0;\n}", "target": 1}
{"code": "int git_treebuilder_create(git_treebuilder **builder_p, const git_tree *source)\n{\n\tgit_treebuilder *bld;\n\tsize_t i, source_entries = DEFAULT_TREE_SIZE;\n\tassert(builder_p);\n\tbld = git__calloc(1, sizeof(git_treebuilder));\n\tGITERR_CHECK_ALLOC(bld);\n\tif (source != NULL)\n\t\tsource_entries = source->entries.length;\n\tif (git_vector_init(&bld->entries, source_entries, entry_sort_cmp) < 0)\n\t\tgoto on_error;\n\tif (source != NULL) {\n\t\tgit_tree_entry *entry_src;\n\t\tgit_vector_foreach(&source->entries, i, entry_src) {\n\t\t\tif (append_entry(\n\t\t\t\tbld, entry_src->filename,\n\t\t\t\t&entry_src->oid,\n\t\t\t\tentry_src->attr) < 0)\n\t\t\t\tgoto on_error;\n\t\t}\n\t}\n\t*builder_p = bld;\n\treturn 0;\non_error:\n\tgit_treebuilder_free(bld);\n\treturn -1;\n}", "target": 0}
{"code": "static __inline__ int cbq_dump_ovl(struct sk_buff *skb, struct cbq_class *cl)\n{\n\tunsigned char\t *b = skb->tail;\n\tstruct tc_cbq_ovl opt;\n\topt.strategy = cl->ovl_strategy;\n\topt.priority2 = cl->priority2+1;\n\topt.penalty = (cl->penalty*1000)/HZ;\n\tRTA_PUT(skb, TCA_CBQ_OVL_STRATEGY, sizeof(opt), &opt);\n\treturn skb->len;\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}", "target": 1}
{"code": "static size_t exif_convert_any_to_int(void *value, int format, int motorola_intel)\n{\n\tint \t\ts_den;\n\tunsigned \tu_den;\n\tswitch(format) {\n\t\tcase TAG_FMT_SBYTE:     return *(signed char *)value;\n\t\tcase TAG_FMT_BYTE:      return *(uchar *)value;\n\t\tcase TAG_FMT_USHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_ULONG:     return php_ifd_get32u(value, motorola_intel);\n\t\tcase TAG_FMT_URATIONAL:\n\t\t\tu_den = php_ifd_get32u(4+(char *)value, motorola_intel);\n\t\t\tif (u_den == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn php_ifd_get32u(value, motorola_intel) / u_den;\n\t\t\t}\n\t\tcase TAG_FMT_SRATIONAL:\n\t\t\ts_den = php_ifd_get32s(4+(char *)value, motorola_intel);\n\t\t\tif (s_den == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn (size_t)((double)php_ifd_get32s(value, motorola_intel) / s_den);\n\t\t\t}\n\t\tcase TAG_FMT_SSHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_SLONG:     return php_ifd_get32s(value, motorola_intel);\n\t\tcase TAG_FMT_SINGLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL, E_NOTICE, \"Found value of type single\");\n#endif\n\t\t\treturn (size_t)*(float *)value;\n\t\tcase TAG_FMT_DOUBLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL, E_NOTICE, \"Found value of type double\");\n#endif\n\t\t\treturn (size_t)*(double *)value;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "router_append_dirobj_signature(char *buf, size_t buf_len, const char *digest,\n                               size_t digest_len, crypto_pk_t *private_key)\n{\n  size_t sig_len, s_len;\n  char *sig = router_get_dirobj_signature(digest, digest_len, private_key);\n  if (!sig) {\n    log_warn(LD_BUG, \"No signature generated\");\n    return -1;\n  }\n  sig_len = strlen(sig);\n  s_len = strlen(buf);\n  if (sig_len + s_len + 1 > buf_len) {\n    log_warn(LD_BUG, \"Not enough room for signature\");\n    tor_free(sig);\n    return -1;\n  }\n  memcpy(buf+s_len, sig, sig_len+1);\n  return 0;\n}", "target": 0}
{"code": "void NetworkActionPredictor::ClearTransitionalMatches() {\n  transitional_matches_.clear();\n}", "target": 0}
{"code": "static inline int init_new_context(struct task_struct *tsk,\n\t\t\t\t   struct mm_struct *mm)\n{\n\t#ifdef CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS\n\tif (cpu_feature_enabled(X86_FEATURE_OSPKE)) {\n\t\tmm->context.pkey_allocation_map = 0x1;\n\t\tmm->context.execute_only_pkey = -1;\n\t}\n\t#endif\n\tinit_new_context_ldt(tsk, mm);\n\treturn 0;\n}", "target": 1}
{"code": "static int wcd9335_slim_status(struct slim_device *sdev,\n\t\t\t       enum slim_device_status status)\n{\n\tstruct device *dev = &sdev->dev;\n\tstruct device_node *ifc_dev_np;\n\tstruct wcd9335_codec *wcd;\n\tint ret;\n\twcd = dev_get_drvdata(dev);\n\tifc_dev_np = of_parse_phandle(dev->of_node, \"slim-ifc-dev\", 0);\n\tif (!ifc_dev_np) {\n\t\tdev_err(dev, \"No Interface device found\\n\");\n\t\treturn -EINVAL;\n\t}\n\twcd->slim = sdev;\n\twcd->slim_ifc_dev = of_slim_get_device(sdev->ctrl, ifc_dev_np);\n\tof_node_put(ifc_dev_np);\n\tif (!wcd->slim_ifc_dev) {\n\t\tdev_err(dev, \"Unable to get SLIM Interface device\\n\");\n\t\treturn -EINVAL;\n\t}\n\tslim_get_logical_addr(wcd->slim_ifc_dev);\n\twcd->regmap = regmap_init_slimbus(sdev, &wcd9335_regmap_config);\n\tif (IS_ERR(wcd->regmap)) {\n\t\tdev_err(dev, \"Failed to allocate slim register map\\n\");\n\t\treturn PTR_ERR(wcd->regmap);\n\t}\n\twcd->if_regmap = regmap_init_slimbus(wcd->slim_ifc_dev,\n\t\t\t\t\t\t  &wcd9335_ifc_regmap_config);\n\tif (IS_ERR(wcd->if_regmap)) {\n\t\tdev_err(dev, \"Failed to allocate ifc register map\\n\");\n\t\treturn PTR_ERR(wcd->if_regmap);\n\t}\n\tret = wcd9335_bring_up(wcd);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to bringup WCD9335\\n\");\n\t\treturn ret;\n\t}\n\tret = wcd9335_irq_init(wcd);\n\tif (ret)\n\t\treturn ret;\n\twcd9335_probe(wcd);\n\treturn ret;\n}", "target": 0}
{"code": "static void *adpt_ioctl_from_context(adpt_hba *pHba, u32 context)\n{\n#if BITS_PER_LONG == 32\n\treturn (void *)(unsigned long)context;\n#else\n\tvoid *p = pHba->ioctl_reply_context[context];\n\tpHba->ioctl_reply_context[context] = NULL;\n\treturn p;\n#endif\n}", "target": 1}
{"code": "static int get_tp_trap(struct pt_regs *regs, unsigned int instr)\n{\n\tint reg = (instr >> 12) & 15;\n\tif (reg == 15)\n\t\treturn 1;\n\tregs->uregs[reg] = current_thread_info()->tp_value;\n\tregs->ARM_pc += 4;\n\treturn 0;\n}", "target": 1}
{"code": "gdk_pixbuf__bmp_image_begin_load(GdkPixbufModuleSizeFunc size_func,\n                                 GdkPixbufModulePreparedFunc prepared_func,\n\t\t\t\t GdkPixbufModuleUpdatedFunc updated_func,\n                                 gpointer user_data,\n                                 GError **error)\n{\n\tstruct bmp_progressive_state *context;\n\tcontext = g_new0(struct bmp_progressive_state, 1);\n\tcontext->size_func = size_func;\n\tcontext->prepared_func = prepared_func;\n\tcontext->updated_func = updated_func;\n\tcontext->user_data = user_data;\n\tcontext->read_state = READ_STATE_HEADERS;\n\tcontext->BufferSize = 26;\n\tcontext->BufferPadding = 0;\n\tcontext->buff = g_malloc(26);\n\tcontext->BufferDone = 0;\n\tcontext->Colormap = NULL;\n\tcontext->Lines = 0;\n\tcontext->Type = 0;\n\tmemset(&context->Header, 0, sizeof(struct headerpair));\n\tmemset(&context->compr, 0, sizeof(struct bmp_compression_state));\n\tcontext->pixbuf = NULL;\n\treturn (gpointer) context;\n}", "target": 0}
{"code": "bool PackLinuxElf64::calls_crt1(Elf64_Rela const *rela, int sz)\n{\n    if (!dynsym || !dynstr) {\n        return false;\n    }\n    for (unsigned relnum= 0; 0 < sz; (sz -= sizeof(Elf64_Rela)), ++rela, ++relnum) {\n        unsigned const symnum = get_te64(&rela->r_info) >> 32;\n        char const *const symnam = get_dynsym_name(symnum, relnum);\n        if (0==strcmp(symnam, \"__libc_start_main\")  \n        ||  0==strcmp(symnam, \"__libc_init\")  \n        ||  0==strcmp(symnam, \"__uClibc_main\")\n        ||  0==strcmp(symnam, \"__uClibc_start_main\"))\n            return true;\n    }\n    return false;\n}", "target": 1}
{"code": "lsquic_qeh_settings (struct qpack_enc_hdl *qeh, unsigned max_table_size,\n             unsigned dyn_table_size, unsigned max_risked_streams, int server)\n{\n    enum lsqpack_enc_opts enc_opts;\n    assert(qeh->qeh_flags & QEH_INITIALIZED);\n    if (qeh->qeh_flags & QEH_HAVE_SETTINGS)\n    {\n        LSQ_WARN(\"settings already set\");\n        return -1;\n    }\n    enc_opts = LSQPACK_ENC_OPT_STAGE_2\n             | (server ? LSQPACK_ENC_OPT_SERVER : 0);\n    qeh->qeh_tsu_sz = sizeof(qeh->qeh_tsu_buf);\n    if (0 != lsqpack_enc_init(&qeh->qeh_encoder, (void *) qeh->qeh_conn,\n                max_table_size, dyn_table_size, max_risked_streams, enc_opts,\n                qeh->qeh_tsu_buf, &qeh->qeh_tsu_sz))\n    {\n        LSQ_INFO(\"could not initialize QPACK encoder\");\n        return -1;\n    }\n    LSQ_DEBUG(\"%zu-byte post-init TSU\", qeh->qeh_tsu_sz);\n    qeh->qeh_flags |= QEH_HAVE_SETTINGS;\n    qeh->qeh_max_prefix_size =\n                        lsqpack_enc_header_block_prefix_size(&qeh->qeh_encoder);\n    LSQ_DEBUG(\"have settings: max table size=%u; dyn table size=%u; max risked \"\n        \"streams=%u\", max_table_size, dyn_table_size, max_risked_streams);\n    if (qeh->qeh_enc_sm_out)\n        qeh_begin_out(qeh);\n    return 0;\n}", "target": 1}
{"code": "static int shmem_remount_fs(struct super_block *sb, int *flags, char *data)\n{\n\tstruct shmem_sb_info *sbinfo = SHMEM_SB(sb);\n\tstruct shmem_sb_info config = *sbinfo;\n\tunsigned long inodes;\n\tint error = -EINVAL;\n\tif (shmem_parse_options(data, &config, true))\n\t\treturn error;\n\tspin_lock(&sbinfo->stat_lock);\n\tinodes = sbinfo->max_inodes - sbinfo->free_inodes;\n\tif (percpu_counter_compare(&sbinfo->used_blocks, config.max_blocks) > 0)\n\t\tgoto out;\n\tif (config.max_inodes < inodes)\n\t\tgoto out;\n\tif (config.max_blocks && !sbinfo->max_blocks)\n\t\tgoto out;\n\tif (config.max_inodes && !sbinfo->max_inodes)\n\t\tgoto out;\n\terror = 0;\n\tsbinfo->max_blocks  = config.max_blocks;\n\tsbinfo->max_inodes  = config.max_inodes;\n\tsbinfo->free_inodes = config.max_inodes - inodes;\n\tmpol_put(sbinfo->mpol);\n\tsbinfo->mpol        = config.mpol;\t\nout:\n\tspin_unlock(&sbinfo->stat_lock);\n\treturn error;\n}", "target": 1}
{"code": "static GCObject **correctgraylist (GCObject **p) {\n  GCObject *curr;\n  while ((curr = *p) != NULL) {\n    switch (curr->tt) {\n      case LUA_VTABLE: case LUA_VUSERDATA: {\n        GCObject **next = getgclist(curr);\n        if (getage(curr) == G_TOUCHED1) {  \n          lua_assert(isgray(curr));\n          gray2black(curr);  \n          changeage(curr, G_TOUCHED1, G_TOUCHED2);\n          p = next;  \n        }\n        else {  \n          if (!iswhite(curr)) {  \n            lua_assert(isold(curr));\n            if (getage(curr) == G_TOUCHED2)  \n              changeage(curr, G_TOUCHED2, G_OLD);  \n            gray2black(curr);  \n          }\n          *p = *next;  \n        }\n        break;\n      }\n      case LUA_VTHREAD: {\n        lua_State *th = gco2th(curr);\n        lua_assert(!isblack(th));\n        if (iswhite(th))  \n          *p = th->gclist;  \n        else  \n          p = &th->gclist;  \n        break;\n      }\n      default: lua_assert(0);  \n    }\n  }\n  return p;\n}", "target": 1}
{"code": "STATIC int\nS_edit_distance(const UV* src,\n                const UV* tgt,\n                const STRLEN x,             \n                const STRLEN y,             \n                const SSize_t maxDistance\n)\n{\n    item *head = NULL;\n    UV swapCount, swapScore, targetCharCount, i, j;\n    UV *scores;\n    UV score_ceil = x + y;\n    PERL_ARGS_ASSERT_EDIT_DISTANCE;\n    Newx(scores, ( (x + 2) * (y + 2)), UV);\n    scores[0] = score_ceil;\n    scores[1 * (y + 2) + 0] = score_ceil;\n    scores[0 * (y + 2) + 1] = score_ceil;\n    scores[1 * (y + 2) + 1] = 0;\n    head = uniquePush(uniquePush(head, src[0]), tgt[0]);\n    for (i=1;i<=x;i++) {\n        if (i < x)\n            head = uniquePush(head, src[i]);\n        scores[(i+1) * (y + 2) + 1] = i;\n        scores[(i+1) * (y + 2) + 0] = score_ceil;\n        swapCount = 0;\n        for (j=1;j<=y;j++) {\n            if (i == 1) {\n                if(j < y)\n                head = uniquePush(head, tgt[j]);\n                scores[1 * (y + 2) + (j + 1)] = j;\n                scores[0 * (y + 2) + (j + 1)] = score_ceil;\n            }\n            targetCharCount = find(head, tgt[j-1])->value;\n            swapScore = scores[targetCharCount * (y + 2) + swapCount] + i - targetCharCount - 1 + j - swapCount;\n            if (src[i-1] != tgt[j-1]){\n                scores[(i+1) * (y + 2) + (j + 1)] = MIN(swapScore,(MIN(scores[i * (y + 2) + j], MIN(scores[(i+1) * (y + 2) + j], scores[i * (y + 2) + (j + 1)])) + 1));\n            }\n            else {\n                swapCount = j;\n                scores[(i+1) * (y + 2) + (j + 1)] = MIN(scores[i * (y + 2) + j], swapScore);\n            }\n        }\n        find(head, src[i-1])->value = i;\n    }\n    {\n        IV score = scores[(x+1) * (y + 2) + (y + 1)];\n        dict_free(head);\n        Safefree(scores);\n        return (maxDistance != 0 && maxDistance < score)?(-1):score;\n    }", "target": 0}
{"code": "gs_heap_enable_free(gs_memory_t * mem, bool enable)\n{\n    if (enable)\n        mem->procs.free_object = gs_heap_free_object,\n            mem->procs.free_string = gs_heap_free_string;\n    else\n        mem->procs.free_object = gs_ignore_free_object,\n            mem->procs.free_string = gs_ignore_free_string;\n}", "target": 0}
{"code": "static int TraceLineTo(FT_Vector *to,DrawInfo *draw_info)\n{\n  AffineMatrix\n    affine;\n  char\n    path[MagickPathExtent];\n  affine=draw_info->affine;\n  (void) FormatLocaleString(path,MagickPathExtent,\"L%g,%g\",affine.tx+to->x/64.0,\n    affine.ty-to->y/64.0);\n  (void) ConcatenateString(&draw_info->primitive,path);\n  return(0);\n}", "target": 0}
{"code": "static void sctp_destroy_sock(struct sock *sk)\n{\n\tstruct sctp_sock *sp;\n\tpr_debug(\"%s: sk:%p\\n\", __func__, sk);\n\tsp = sctp_sk(sk);\n\tif (sp->ep == NULL)\n\t\treturn;\n\tif (sp->do_auto_asconf) {\n\t\tsp->do_auto_asconf = 0;\n\t\tlist_del(&sp->auto_asconf_list);\n\t}\n\tsctp_endpoint_free(sp->ep);\n\tlocal_bh_disable();\n\tsk_sockets_allocated_dec(sk);\n\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\tlocal_bh_enable();\n}", "target": 1}
{"code": "static int __get_data_block(struct inode *inode, sector_t iblock,\n\t\t\tstruct buffer_head *bh, int create, int flag,\n\t\t\tpgoff_t *next_pgofs)\n{\n\tstruct f2fs_map_blocks map;\n\tint err;\n\tmap.m_lblk = iblock;\n\tmap.m_len = bh->b_size >> inode->i_blkbits;\n\tmap.m_next_pgofs = next_pgofs;\n\terr = f2fs_map_blocks(inode, &map, create, flag);\n\tif (!err) {\n\t\tmap_bh(bh, inode->i_sb, map.m_pblk);\n\t\tbh->b_state = (bh->b_state & ~F2FS_MAP_FLAGS) | map.m_flags;\n\t\tbh->b_size = map.m_len << inode->i_blkbits;\n\t}\n\treturn err;\n}", "target": 1}
{"code": "check_secret_key( ELG_secret_key *sk )\n{\n    int rc;\n    MPI y = mpi_alloc( mpi_get_nlimbs(sk->y) );\n    mpi_powm( y, sk->g, sk->x, sk->p );\n    rc = !mpi_cmp( y, sk->y );\n    mpi_free( y );\n    return rc;\n}", "target": 0}
{"code": "nosy_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct client *client = file->private_data;\n\tspinlock_t *client_list_lock = &client->lynx->client_list_lock;\n\tstruct nosy_stats stats;\n\tswitch (cmd) {\n\tcase NOSY_IOC_GET_STATS:\n\t\tspin_lock_irq(client_list_lock);\n\t\tstats.total_packet_count = client->buffer.total_packet_count;\n\t\tstats.lost_packet_count  = client->buffer.lost_packet_count;\n\t\tspin_unlock_irq(client_list_lock);\n\t\tif (copy_to_user((void __user *) arg, &stats, sizeof stats))\n\t\t\treturn -EFAULT;\n\t\telse\n\t\t\treturn 0;\n\tcase NOSY_IOC_START:\n\t\tspin_lock_irq(client_list_lock);\n\t\tlist_add_tail(&client->link, &client->lynx->client_list);\n\t\tspin_unlock_irq(client_list_lock);\n\t\treturn 0;\n\tcase NOSY_IOC_STOP:\n\t\tspin_lock_irq(client_list_lock);\n\t\tlist_del_init(&client->link);\n\t\tspin_unlock_irq(client_list_lock);\n\t\treturn 0;\n\tcase NOSY_IOC_FILTER:\n\t\tspin_lock_irq(client_list_lock);\n\t\tclient->tcode_mask = arg;\n\t\tspin_unlock_irq(client_list_lock);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}", "target": 1}
{"code": "static int wcd9335_codec_enable_ear_pa(struct snd_soc_dapm_widget *w,\n\t\t\t\t       struct snd_kcontrol *kc, int event)\n{\n\tstruct snd_soc_component *comp = snd_soc_dapm_to_component(w->dapm);\n\tint ret = 0;\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tusleep_range(5000, 5500);\n\t\tsnd_soc_component_update_bits(comp,\n\t\t\t\t\tWCD9335_CDC_RX0_RX_PATH_CTL,\n\t\t\t\t\tWCD9335_CDC_RX_PGA_MUTE_EN_MASK,\n\t\t\t\t\tWCD9335_CDC_RX_PGA_MUTE_DISABLE);\n\t\tif ((snd_soc_component_read32(comp,\n\t\t\t\t\tWCD9335_CDC_RX0_RX_PATH_MIX_CTL)) &\n\t\t\t\t\tWCD9335_CDC_RX_PGA_MUTE_EN_MASK)\n\t\t\tsnd_soc_component_update_bits(comp,\n\t\t\t\t\tWCD9335_CDC_RX0_RX_PATH_MIX_CTL,\n\t\t\t\t\tWCD9335_CDC_RX_PGA_MUTE_EN_MASK,\n\t\t\t\t\tWCD9335_CDC_RX_PGA_MUTE_DISABLE);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tusleep_range(5000, 5500);\n\t\tbreak;\n\t};\n\treturn ret;\n}", "target": 0}
{"code": "static bool FNAME(gpte_changed)(struct kvm_vcpu *vcpu,\n\t\t\t\tstruct guest_walker *gw, int level)\n{\n\tpt_element_t curr_pte;\n\tgpa_t base_gpa, pte_gpa = gw->pte_gpa[level - 1];\n\tu64 mask;\n\tint r, index;\n\tif (level == PT_PAGE_TABLE_LEVEL) {\n\t\tmask = PTE_PREFETCH_NUM * sizeof(pt_element_t) - 1;\n\t\tbase_gpa = pte_gpa & ~mask;\n\t\tindex = (pte_gpa - base_gpa) / sizeof(pt_element_t);\n\t\tr = kvm_vcpu_read_guest_atomic(vcpu, base_gpa,\n\t\t\t\tgw->prefetch_ptes, sizeof(gw->prefetch_ptes));\n\t\tcurr_pte = gw->prefetch_ptes[index];\n\t} else\n\t\tr = kvm_vcpu_read_guest_atomic(vcpu, pte_gpa,\n\t\t\t\t  &curr_pte, sizeof(curr_pte));\n\treturn r || curr_pte != gw->ptes[level - 1];\n}", "target": 0}
{"code": "static int vmx_set_msr(struct kvm_vcpu *vcpu, u32 msr_index, u64 data)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct kvm_msr_entry *msr;\n\tu64 host_tsc;\n\tint ret = 0;\n\tswitch (msr_index) {\n#ifdef CONFIG_X86_64\n\tcase MSR_EFER:\n\t\tvmx_load_host_state(vmx);\n\t\tret = kvm_set_msr_common(vcpu, msr_index, data);\n\t\tbreak;\n\tcase MSR_FS_BASE:\n\t\tvmcs_writel(GUEST_FS_BASE, data);\n\t\tbreak;\n\tcase MSR_GS_BASE:\n\t\tvmcs_writel(GUEST_GS_BASE, data);\n\t\tbreak;\n#endif\n\tcase MSR_IA32_SYSENTER_CS:\n\t\tvmcs_write32(GUEST_SYSENTER_CS, data);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\t\tvmcs_writel(GUEST_SYSENTER_EIP, data);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\tvmcs_writel(GUEST_SYSENTER_ESP, data);\n\t\tbreak;\n\tcase MSR_IA32_TIME_STAMP_COUNTER:\n\t\trdtscll(host_tsc);\n\t\tguest_write_tsc(data, host_tsc);\n\t\tbreak;\n\tcase MSR_P6_PERFCTR0:\n\tcase MSR_P6_PERFCTR1:\n\tcase MSR_P6_EVNTSEL0:\n\tcase MSR_P6_EVNTSEL1:\n\t\tpr_unimpl(vcpu, \"unimplemented perfctr wrmsr: 0x%x data 0x%llx\\n\", msr_index, data);\n\t\tbreak;\n\tcase MSR_IA32_CR_PAT:\n\t\tif (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PAT) {\n\t\t\tvmcs_write64(GUEST_IA32_PAT, data);\n\t\t\tvcpu->arch.pat = data;\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\tvmx_load_host_state(vmx);\n\t\tmsr = find_msr_entry(vmx, msr_index);\n\t\tif (msr) {\n\t\t\tmsr->data = data;\n\t\t\tbreak;\n\t\t}\n\t\tret = kvm_set_msr_common(vcpu, msr_index, data);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "int tcp_ctl(struct socket *so)\n{\n    Slirp *slirp = so->slirp;\n    struct sbuf *sb = &so->so_snd;\n    struct gfwd_list *ex_ptr;\n    DEBUG_CALL(\"tcp_ctl\");\n    DEBUG_ARG(\"so = %p\", so);\n    if (so->so_faddr.s_addr != slirp->vhost_addr.s_addr) {\n        for (ex_ptr = slirp->guestfwd_list; ex_ptr; ex_ptr = ex_ptr->ex_next) {\n            if (ex_ptr->ex_fport == so->so_fport &&\n                so->so_faddr.s_addr == ex_ptr->ex_addr.s_addr) {\n                if (ex_ptr->write_cb) {\n                    so->s = -1;\n                    so->guestfwd = ex_ptr;\n                    return 1;\n                }\n                DEBUG_MISC(\" executing %s\", ex_ptr->ex_exec);\n                if (ex_ptr->ex_unix)\n                    return open_unix(so, ex_ptr->ex_unix);\n                else\n                    return fork_exec(so, ex_ptr->ex_exec);\n            }\n        }\n    }\n    sb->sb_cc =\n        snprintf(sb->sb_wptr, sb->sb_datalen - (sb->sb_wptr - sb->sb_data),\n                 \"Error: No application configured.\\r\\n\");\n    sb->sb_wptr += sb->sb_cc;\n    return 0;\n}", "target": 0}
{"code": "static int em_grp45(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc = X86EMUL_CONTINUE;\n\tswitch (ctxt->modrm_reg) {\n\tcase 2:  {\n\t\tlong int old_eip;\n\t\told_eip = ctxt->_eip;\n\t\tctxt->_eip = ctxt->src.val;\n\t\tctxt->src.val = old_eip;\n\t\trc = em_push(ctxt);\n\t\tbreak;\n\t}\n\tcase 4: \n\t\tctxt->_eip = ctxt->src.val;\n\t\tbreak;\n\tcase 5: \n\t\trc = em_jmp_far(ctxt);\n\t\tbreak;\n\tcase 6:\t\n\t\trc = em_push(ctxt);\n\t\tbreak;\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "bool JOIN::save_explain_data(Explain_query *output, bool can_overwrite,\n                             bool need_tmp_table, bool need_order, \n                             bool distinct)\n{\n  DBUG_ENTER(\"JOIN::save_explain_data\");\n  DBUG_PRINT(\"enter\", (\"Save explain Select_lex: %u (%p)  parent lex: %p  stmt_lex: %p  present select: %u (%p)\",\n                        select_lex->select_number, select_lex,\n                        select_lex->parent_lex, thd->lex->stmt_lex,\n                        (output->get_select(select_lex->select_number) ?\n                         select_lex->select_number : 0),\n                        (output->get_select(select_lex->select_number) ?\n                         output->get_select(select_lex->select_number)\n                         ->select_lex : NULL)));\n  DBUG_SLOW_ASSERT(select_lex->select_number == UINT_MAX ||\n              select_lex->select_number == INT_MAX ||\n              !output ||\n              !output->get_select(select_lex->select_number) ||\n              output->get_select(select_lex->select_number)->select_lex ==\n                select_lex);\n  if (select_lex->select_number != UINT_MAX && \n      select_lex->select_number != INT_MAX  && \n      have_query_plan != JOIN::QEP_NOT_PRESENT_YET && \n      have_query_plan != JOIN::QEP_DELETED &&  \n      output && \n      (can_overwrite? true: !output->get_select(select_lex->select_number)))\n  {\n    const char *message= NULL;\n    if (!table_count || !tables_list || zero_result_cause)\n    {\n      message= zero_result_cause ? zero_result_cause : \"No tables used\";\n    }\n    bool rc= save_explain_data_intern(thd->lex->explain, need_tmp_table,\n                                      need_order, distinct, message);\n    DBUG_RETURN(rc);\n  }\n  if (select_lex == select_lex->master_unit()->fake_select_lex && join_tab)\n  {\n    uint nr= select_lex->master_unit()->first_select()->select_number;\n    Explain_union *eu= output->get_union(nr);\n    explain= &eu->fake_select_lex_explain;\n    join_tab[0].tracker= eu->get_fake_select_lex_tracker();\n    for (uint i=0 ; i < exec_join_tab_cnt() + aggr_tables; i++)\n    {\n      if (join_tab[i].filesort)\n      {\n        if (!(join_tab[i].filesort->tracker=\n              new Filesort_tracker(thd->lex->analyze_stmt)))\n          DBUG_RETURN(1);\n      }\n    }\n  }\n  DBUG_RETURN(0);\n}", "target": 0}
{"code": "static int amdgpu_cs_wait_all_fences(struct amdgpu_device *adev,\n\t\t\t\t     struct drm_file *filp,\n\t\t\t\t     union drm_amdgpu_wait_fences *wait,\n\t\t\t\t     struct drm_amdgpu_fence *fences)\n{\n\tuint32_t fence_count = wait->in.fence_count;\n\tunsigned int i;\n\tlong r = 1;\n\tfor (i = 0; i < fence_count; i++) {\n\t\tstruct dma_fence *fence;\n\t\tunsigned long timeout = amdgpu_gem_timeout(wait->in.timeout_ns);\n\t\tfence = amdgpu_cs_get_fence(adev, filp, &fences[i]);\n\t\tif (IS_ERR(fence))\n\t\t\treturn PTR_ERR(fence);\n\t\telse if (!fence)\n\t\t\tcontinue;\n\t\tr = dma_fence_wait_timeout(fence, true, timeout);\n\t\tdma_fence_put(fence);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t\tif (r == 0)\n\t\t\tbreak;\n\t\tif (fence->error)\n\t\t\treturn fence->error;\n\t}\n\tmemset(wait, 0, sizeof(*wait));\n\twait->out.status = (r > 0);\n\treturn 0;\n}", "target": 1}
{"code": "int gdAlphaBlend (int dst, int src) {\n    int src_alpha = gdTrueColorGetAlpha(src);\n    int dst_alpha, alpha, red, green, blue;\n    int src_weight, dst_weight, tot_weight;\n    if( src_alpha == gdAlphaOpaque )\n        return src;\n    dst_alpha = gdTrueColorGetAlpha(dst);\n    if( src_alpha == gdAlphaTransparent )\n        return dst;\n    if( dst_alpha == gdAlphaTransparent )\n        return src;\n    src_weight = gdAlphaTransparent - src_alpha;\n    dst_weight = (gdAlphaTransparent - dst_alpha) * src_alpha / gdAlphaMax;\n    tot_weight = src_weight + dst_weight;\n    alpha = src_alpha * dst_alpha / gdAlphaMax;\n    red = (gdTrueColorGetRed(src) * src_weight\n           + gdTrueColorGetRed(dst) * dst_weight) / tot_weight;\n    green = (gdTrueColorGetGreen(src) * src_weight\n           + gdTrueColorGetGreen(dst) * dst_weight) / tot_weight;\n    blue = (gdTrueColorGetBlue(src) * src_weight\n           + gdTrueColorGetBlue(dst) * dst_weight) / tot_weight;\n    return ((alpha << 24) + (red << 16) + (green << 8) + blue);\n}", "target": 1}
{"code": "static void bluetooth_client_finalize(GObject *object)\n{\n\tBluetoothClient *client = BLUETOOTH_CLIENT (object);\n\tBluetoothClientPrivate *priv = BLUETOOTH_CLIENT_GET_PRIVATE (client);\n\tif (priv->cancellable != NULL) {\n\t\tg_cancellable_cancel (priv->cancellable);\n\t\tg_clear_object (&priv->cancellable);\n\t}\n\tg_clear_object (&priv->manager);\n\tg_object_unref (priv->store);\n\tg_clear_pointer (&priv->default_adapter, gtk_tree_row_reference_free);\n\tG_OBJECT_CLASS(bluetooth_client_parent_class)->finalize (object);\n}", "target": 0}
{"code": "static noinline void __schedule_bug(struct task_struct *prev)\n{\n\tif (oops_in_progress)\n\t\treturn;\n\tprintk(KERN_ERR \"BUG: scheduling while atomic: %s/%d/0x%08x\\n\",\n\t\tprev->comm, prev->pid, preempt_count());\n\tdebug_show_held_locks(prev);\n\tprint_modules();\n\tif (irqs_disabled())\n\t\tprint_irqtrace_events(prev);\n#ifdef CONFIG_DEBUG_PREEMPT\n\tif (in_atomic_preempt_off()) {\n\t\tpr_err(\"Preemption disabled at:\");\n\t\tprint_ip_sym(current->preempt_disable_ip);\n\t\tpr_cont(\"\\n\");\n\t}\n#endif\n\tdump_stack();\n\tadd_taint(TAINT_WARN, LOCKDEP_STILL_OK);\n}", "target": 0}
{"code": "    bool load_face(Face & face, unsigned int options)\n    {\n#ifdef GRAPHITE2_TELEMETRY\n        telemetry::category _misc_cat(face.tele.misc);\n#endif\n        Face::Table silf(face, Tag::Silf, 0x00050000);\n        if (silf)   options &= ~gr_face_dumbRendering;\n        else if (!(options &  gr_face_dumbRendering))\n            return false;\n        if (!face.readGlyphs(options))\n            return false;\n        if (silf)\n        {\n            if (!face.readFeatures() || !face.readGraphite(silf))\n            {\n#if !defined GRAPHITE2_NTRACING\n                if (global_log)\n                {\n                    *global_log << json::object\n                        << \"type\" << \"fontload\"\n                        << \"failure\" << face.error()\n                        << \"context\" << face.error_context()\n                    << json::close;\n                }\n#endif\n                return false;\n            }\n            else\n                return true;\n        }\n        else\n            return options & gr_face_dumbRendering;\n    }", "target": 1}
{"code": "static pj_status_t STATUS_FROM_SSL_ERR(char *action, pj_ssl_sock_t *ssock,\n\t\t\t\t       unsigned long err)\n{\n    int level = 0;\n    int len = 0; \n    ERROR_LOG(\"STATUS_FROM_SSL_ERR\", err, ssock);\n    level++;\n    if (err == SSL_ERROR_SSL) {\n\terr = ERR_get_error();\n\tERROR_LOG(\"STATUS_FROM_SSL_ERR\", err, ssock);\n    }\n    ssock->last_err = err;\n    return GET_STATUS_FROM_SSL_ERR(err);\n}", "target": 1}
{"code": "int __nla_parse(struct nlattr **tb, int maxtype,\n\t\tconst struct nlattr *head, int len,\n\t\tconst struct nla_policy *policy, unsigned int validate,\n\t\tstruct netlink_ext_ack *extack)\n{\n\treturn __nla_validate_parse(head, len, maxtype, policy, validate,\n\t\t\t\t    extack, tb);\n}", "target": 1}
{"code": "static struct ip_options *ip_options_get_alloc(const int optlen)\n{\n\treturn kzalloc(sizeof(struct ip_options) + ((optlen + 3) & ~3),\n\t\t       GFP_KERNEL);\n}", "target": 1}
{"code": "static void ide_atapi_cmd_reply(IDEState *s, int size, int max_size)\n{\n    if (size > max_size)\n        size = max_size;\n    s->lba = -1; \n    s->packet_transfer_size = size;\n    s->io_buffer_size = size;    \n    s->elementary_transfer_size = 0;\n    s->io_buffer_index = 0;\n    if (s->atapi_dma) {\n        bdrv_acct_start(s->bs, &s->acct, size, BDRV_ACCT_READ);\n        s->status = READY_STAT | SEEK_STAT | DRQ_STAT;\n        s->bus->dma->ops->start_dma(s->bus->dma, s,\n                                   ide_atapi_cmd_read_dma_cb);\n    } else {\n        s->status = READY_STAT | SEEK_STAT;\n        ide_atapi_cmd_reply_end(s);\n    }\n}", "target": 0}
{"code": "static void nvme_format_bh(void *opaque)\n{\n    NvmeFormatAIOCB *iocb = opaque;\n    NvmeRequest *req = iocb->req;\n    NvmeCtrl *n = nvme_ctrl(req);\n    uint32_t dw10 = le32_to_cpu(req->cmd.cdw10);\n    uint8_t lbaf = dw10 & 0xf;\n    uint8_t pi = (dw10 >> 5) & 0x7;\n    uint16_t status;\n    int i;\n    if (iocb->ret < 0) {\n        goto done;\n    }\n    if (iocb->broadcast) {\n        for (i = iocb->nsid + 1; i <= NVME_MAX_NAMESPACES; i++) {\n            iocb->ns = nvme_ns(n, i);\n            if (iocb->ns) {\n                iocb->nsid = i;\n                break;\n            }\n        }\n    }\n    if (!iocb->ns) {\n        goto done;\n    }\n    status = nvme_format_check(iocb->ns, lbaf, pi);\n    if (status) {\n        req->status = status;\n        goto done;\n    }\n    iocb->ns->status = NVME_FORMAT_IN_PROGRESS;\n    nvme_format_ns_cb(iocb, 0);\n    return;\ndone:\n    qemu_bh_delete(iocb->bh);\n    iocb->bh = NULL;\n    iocb->common.cb(iocb->common.opaque, iocb->ret);\n    qemu_aio_unref(iocb);\n}", "target": 0}
{"code": "test_append_uri_pathel(void)\n{\n  unsigned i;\n  static const struct {\n    const char *original_url;\n    const char *input;\n    bool escaped;\n    const char *expected_result;\n  } test_array[] = {\n    { \"http:\n  };\n  for (i = 0; i < countof(test_array); ++i)\n    {\n      struct growable dest;\n      const char *p = test_array[i].input;\n      memset (&dest, 0, sizeof (dest));\n      append_string (test_array[i].original_url, &dest);\n      append_uri_pathel (p, p + strlen(p), test_array[i].escaped, &dest);\n      mu_assert (\"test_append_uri_pathel: wrong result\",\n                 strcmp (dest.base, test_array[i].expected_result) == 0);\n      xfree (dest.base);\n    }\n  return NULL;\n}", "target": 0}
{"code": "SPL_API int spl_hash_verify_pos(spl_array_object * intern TSRMLS_DC) \n{\n\tHashTable *ht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);\n\treturn spl_hash_verify_pos_ex(intern, ht TSRMLS_CC);\n}", "target": 0}
{"code": "memcmp_constant_time (const void *a, const void *b, size_t size) {\n  const uint8_t * a1 = a;\n  const uint8_t * b1 = b;\n  int ret = 0;\n  size_t i;\n  for (i = 0; i < size; i++) {\n      ret |= *a1++ ^ *b1++;\n  }\n  return ret;\n}", "target": 0}
{"code": "int LibarchivePlugin::extractionFlags() const\n{\n    int result = ARCHIVE_EXTRACT_TIME;\n    result |= ARCHIVE_EXTRACT_SECURE_NODOTDOT;\n    return result;\n}", "target": 1}
{"code": "static void umocktypes_free_bool_ptr(bool** value)\n{\n    if (*value != NULL)\n    {\n        my_gballoc_free(*value);\n    }\n}", "target": 0}
{"code": "void V8Window::namedPropertyGetterCustom(v8::Local<v8::Name> name, const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    if (!name->IsString())\n        return;\n    auto nameString = name.As<v8::String>();\n    LocalDOMWindow* window = toLocalDOMWindow(V8Window::toImpl(info.Holder()));\n    if (!window)\n        return;\n    LocalFrame* frame = window->frame();\n    if (!frame)\n        return;\n    AtomicString propName = toCoreAtomicString(nameString);\n    Frame* child = frame->tree().scopedChild(propName);\n    if (child) {\n        v8SetReturnValueFast(info, child->domWindow(), window);\n        return;\n    }\n     if (!info.Holder()->GetRealNamedProperty(nameString).IsEmpty())\n         return;\n    frame = window->frame();\n    if (!frame)\n        return;\n     Document* doc = frame->document();\n    if (doc && doc->isHTMLDocument()) {\n        if (toHTMLDocument(doc)->hasNamedItem(propName) || doc->hasElementWithId(propName)) {\n            RefPtrWillBeRawPtr<HTMLCollection> items = doc->windowNamedItems(propName);\n            if (!items->isEmpty()) {\n                if (items->hasExactlyOneItem()) {\n                    v8SetReturnValueFast(info, items->item(0), window);\n                    return;\n                }\n                v8SetReturnValueFast(info, items.release(), window);\n                return;\n            }\n        }\n    }\n}", "target": 0}
{"code": "die(uschar *s1, uschar *s2)\n{\nif (s1)\n  {\n  write_syslog(LOG_CRIT, s1);\n  if (debug_file) debug_printf(\"%s\\n\", s1);\n  if (log_stderr && log_stderr != debug_file)\n    fprintf(log_stderr, \"%s\\n\", s1);\n  }\nif (f.receive_call_bombout) receive_bomb_out(NULL, s2);  \nif (smtp_input) smtp_closedown(s2);\nexim_exit(EXIT_FAILURE, NULL);\n}", "target": 0}
{"code": "int service_init(int argc __attribute__((unused)),\n\t\t char **argv __attribute__((unused)),\n\t\t char **envp __attribute__((unused)))\n{\n    int opt;\n    const char *prefix;\n    initialize_nntp_error_table();\n    if (geteuid() == 0) fatal(\"must run as the Cyrus user\", EC_USAGE);\n    setproctitle_init(argc, argv, envp);\n    signals_set_shutdown(&shut_down);\n    signal(SIGPIPE, SIG_IGN);\n    global_sasl_init(1, 1, mysasl_cb);\n    if ((prefix = config_getstring(IMAPOPT_NEWSPREFIX)))\n\tsnprintf(newsprefix, sizeof(newsprefix), \"%s.\", prefix);\n    newsgroups = split_wildmats((char *) config_getstring(IMAPOPT_NEWSGROUPS));\n    if (duplicate_init(NULL, 0) != 0) {\n\tsyslog(LOG_ERR, \n\t       \"unable to init duplicate delivery database\\n\");\n\tfatal(\"unable to init duplicate delivery database\", EC_SOFTWARE);\n    }\n    mboxlist_init(0);\n    mboxlist_open(NULL);\n    quotadb_init(0);\n    quotadb_open(NULL);\n    denydb_init(0);\n    denydb_open(NULL);\n    idle_enabled();\n    while ((opt = getopt(argc, argv, \"srfp:\")) != EOF) {\n\tswitch(opt) {\n\tcase 's': \n\t    nntps = 1;\n\t    if (!tls_enabled()) {\n\t\tsyslog(LOG_ERR, \"nntps: required OpenSSL options not present\");\n\t\tfatal(\"nntps: required OpenSSL options not present\",\n\t\t      EC_CONFIG);\n\t    }\n\t    break;\n\tcase 'r': \n\t    nntp_capa = MODE_READ;\n\t    break;\n\tcase 'f': \n\t    nntp_capa = MODE_FEED;\n\t    break;\n\tcase 'p': \n\t    extprops_ssf = atoi(optarg);\n\t    break;\n\tdefault:\n\t    usage();\n\t}\n    }\n    annotatemore_init(NULL, NULL);\n    annotatemore_open();\n    newsmaster = (char *) config_getstring(IMAPOPT_NEWSMASTER);\n    newsmaster_authstate = auth_newstate(newsmaster);\n    singleinstance = config_getswitch(IMAPOPT_SINGLEINSTANCESTORE);\n    protin = protgroup_new(2);\n    return 0;\n}", "target": 0}
{"code": "static int fuse_get_user_pages(struct fuse_req *req, const char __user *buf,\n\t\t\t       size_t *nbytesp, int write)\n{\n\tsize_t nbytes = *nbytesp;\n\tunsigned long user_addr = (unsigned long) buf;\n\tunsigned offset = user_addr & ~PAGE_MASK;\n\tint npages;\n\tif (segment_eq(get_fs(), KERNEL_DS)) {\n\t\tif (write)\n\t\t\treq->in.args[1].value = (void *) user_addr;\n\t\telse\n\t\t\treq->out.args[0].value = (void *) user_addr;\n\t\treturn 0;\n\t}\n\tnbytes = min_t(size_t, nbytes, FUSE_MAX_PAGES_PER_REQ << PAGE_SHIFT);\n\tnpages = (nbytes + offset + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tnpages = clamp(npages, 1, FUSE_MAX_PAGES_PER_REQ);\n\tdown_read(&current->mm->mmap_sem);\n\tnpages = get_user_pages(current, current->mm, user_addr, npages, !write,\n\t\t\t\t0, req->pages, NULL);\n\tup_read(&current->mm->mmap_sem);\n\tif (npages < 0)\n\t\treturn npages;\n\treq->num_pages = npages;\n\treq->page_offset = offset;\n\tif (write)\n\t\treq->in.argpages = 1;\n\telse\n\t\treq->out.argpages = 1;\n\tnbytes = (req->num_pages << PAGE_SHIFT) - req->page_offset;\n\t*nbytesp = min(*nbytesp, nbytes);\n\treturn 0;\n}", "target": 0}
{"code": "int hns_rcb_get_ring_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn HNS_RING_STATIC_REG_NUM;\n\treturn 0;\n}", "target": 1}
{"code": "bool RenderView::CaptureSnapshot(WebView* view, SkBitmap* snapshot) {\n  base::TimeTicks beginning_time = base::TimeTicks::Now();\n  skia::PlatformCanvas canvas;\n  if (!PaintViewIntoCanvas(view, canvas))\n    return false;\n  skia::BitmapPlatformDevice& device =\n      static_cast<skia::BitmapPlatformDevice&>(canvas.getTopPlatformDevice());\n  const SkBitmap& bitmap = device.accessBitmap(false);\n  if (!bitmap.copyTo(snapshot, SkBitmap::kARGB_8888_Config))\n    return false;\n  HISTOGRAM_TIMES(\"Renderer4.Snapshot\",\n                  base::TimeTicks::Now() - beginning_time);\n  return true;\n}", "target": 0}
{"code": "static int lsm_set_label_at(int lsm_labelfd, int on_exec, char *lsm_label)\n{\n\tint fret = -1;\n\tconst char* name;\n\tchar *command = NULL;\n\tname = lsm_name();\n\tif (strcmp(name, \"nop\") == 0)\n\t\treturn 0;\n\tif (strcmp(name, \"none\") == 0)\n\t\treturn 0;\n\tif (strcmp(name, \"AppArmor\") == 0)\n\t\ton_exec = 0;\n\tif (strcmp(name, \"AppArmor\") == 0) {\n\t\tint size;\n\t\tcommand = malloc(strlen(lsm_label) + strlen(\"changeprofile \") + 1);\n\t\tif (!command) {\n\t\t\tSYSERROR(\"Failed to write apparmor profile\");\n\t\t\tgoto out;\n\t\t}\n\t\tsize = sprintf(command, \"changeprofile %s\", lsm_label);\n\t\tif (size < 0) {\n\t\t\tSYSERROR(\"Failed to write apparmor profile\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (write(lsm_labelfd, command, size + 1) < 0) {\n\t\t\tSYSERROR(\"Unable to set LSM label: %s.\", command);\n\t\t\tgoto out;\n\t\t}\n\t\tINFO(\"Set LSM label to: %s.\", command);\n\t} else if (strcmp(name, \"SELinux\") == 0) {\n\t\tif (write(lsm_labelfd, lsm_label, strlen(lsm_label) + 1) < 0) {\n\t\t\tSYSERROR(\"Unable to set LSM label\");\n\t\t\tgoto out;\n\t\t}\n\t\tINFO(\"Set LSM label to: %s.\", lsm_label);\n\t} else {\n\t\tERROR(\"Unable to restore label for unknown LSM: %s\", name);\n\t\tgoto out;\n\t}\n\tfret = 0;\nout:\n\tfree(command);\n\tif (lsm_labelfd != -1)\n\t\tclose(lsm_labelfd);\n\treturn fret;\n}", "target": 0}
{"code": "static inline struct shmid_kernel *shm_lock(struct ipc_namespace *ns, int id)\n{\n\tstruct kern_ipc_perm *ipcp = ipc_lock(&shm_ids(ns), id);\n\tif (IS_ERR(ipcp))\n\t\treturn (void *)ipcp;\n\treturn container_of(ipcp, struct shmid_kernel, shm_perm);\n}", "target": 0}
{"code": "static int sgi_clock_get(clockid_t clockid, struct timespec *tp)\n{\n\tu64 nsec;\n\tnsec = rtc_time() * sgi_clock_period\n\t\t\t+ sgi_clock_offset.tv_nsec;\n\ttp->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &tp->tv_nsec)\n\t\t\t+ sgi_clock_offset.tv_sec;\n\treturn 0;\n};", "target": 1}
{"code": "poly_path(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *poly = PG_GETARG_POLYGON_P(0);\n\tPATH\t   *path;\n\tint\t\t\tsize;\n\tint\t\t\ti;\n\tsize = offsetof(PATH, p[0]) +sizeof(path->p[0]) * poly->npts;\n\tpath = (PATH *) palloc(size);\n\tSET_VARSIZE(path, size);\n\tpath->npts = poly->npts;\n\tpath->closed = TRUE;\n\tpath->dummy = 0;\n\tfor (i = 0; i < poly->npts; i++)\n\t{\n\t\tpath->p[i].x = poly->p[i].x;\n\t\tpath->p[i].y = poly->p[i].y;\n\t}\n\tPG_RETURN_PATH_P(path);\n}", "target": 0}
{"code": "static int midi_setup_trackname(struct _mdi *mdi, char * text) {\n    MIDI_EVENT_SDEBUG(__FUNCTION__,0, text);\n    strip_text(text);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_meta_trackname;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.string = text;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}", "target": 0}
{"code": "my_pipe_sig_handler(int sig __attribute__((unused)))\n{\n  DBUG_PRINT(\"info\",(\"Hit by signal %d\",sig));\n#ifdef SIGNAL_HANDLER_RESET_ON_DELIVERY\n  (void) signal(SIGPIPE, my_pipe_sig_handler);\n#endif\n}", "target": 0}
{"code": "static cfg_opt_t *cfg_dupopt_array(cfg_opt_t *opts)\n{\n\tint i;\n\tcfg_opt_t *dupopts;\n\tint n = cfg_numopts(opts);\n\tdupopts = calloc(n + 1, sizeof(cfg_opt_t));\n\tif (!dupopts)\n\t\treturn NULL;\n\tmemcpy(dupopts, opts, n * sizeof(cfg_opt_t));\n\tfor (i = 0; i < n; i++) {\n\t\tdupopts[i].name = NULL;\n\t\tdupopts[i].subopts = NULL;\n\t\tdupopts[i].def.parsed = NULL;\n\t\tdupopts[i].def.string = NULL;\n\t\tdupopts[i].comment = NULL;\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tdupopts[i].name = strdup(opts[i].name);\n\t\tif (!dupopts[i].name)\n\t\t\tgoto err;\n\t\tif (opts[i].subopts) {\n\t\t\tdupopts[i].subopts = cfg_dupopt_array(opts[i].subopts);\n\t\t\tif (!dupopts[i].subopts)\n\t\t\t\tgoto err;\n\t\t}\n\t\tif (opts[i].def.parsed) {\n\t\t\tdupopts[i].def.parsed = strdup(opts[i].def.parsed);\n\t\t\tif (!dupopts[i].def.parsed)\n\t\t\t\tgoto err;\n\t\t}\n\t\tif (opts[i].def.string) {\n\t\t\tdupopts[i].def.string = strdup(opts[i].def.string);\n\t\t\tif (!dupopts[i].def.string)\n\t\t\t\tgoto err;\n\t\t}\n\t\tif (opts[i].comment) {\n\t\t\tdupopts[i].comment = strdup(opts[i].comment);\n\t\t\tif (!dupopts[i].comment)\n\t\t\t\tgoto err;\n\t\t}\n\t}\n\treturn dupopts;\nerr:\n\tcfg_free_opt_array(dupopts);\n\treturn NULL;\n}", "target": 0}
{"code": "struct nfc_llcp_local *nfc_llcp_find_local(struct nfc_dev *dev)\n{\n\tstruct nfc_llcp_local *local;\n\tlist_for_each_entry(local, &llcp_devices, list)\n\t\tif (local->dev == dev)\n\t\t\treturn local;\n\tpr_debug(\"No device found\\n\");\n\treturn NULL;\n}", "target": 1}
{"code": "static int br_multicast_add_group(struct net_bridge *br,\n\t\t\t\t  struct net_bridge_port *port,\n\t\t\t\t  struct br_ip *group)\n{\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tunsigned long now = jiffies;\n\tint err;\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) ||\n\t    (port && port->state == BR_STATE_DISABLED))\n\t\tgoto out;\n\tmp = br_multicast_new_group(br, port, group);\n\terr = PTR_ERR(mp);\n\tif (IS_ERR(mp))\n\t\tgoto err;\n\tif (!port) {\n\t\thlist_add_head(&mp->mglist, &br->mglist);\n\t\tmod_timer(&mp->timer, now + br->multicast_membership_interval);\n\t\tgoto out;\n\t}\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (p->port == port)\n\t\t\tgoto found;\n\t\tif ((unsigned long)p->port < (unsigned long)port)\n\t\t\tbreak;\n\t}\n\tp = kzalloc(sizeof(*p), GFP_ATOMIC);\n\terr = -ENOMEM;\n\tif (unlikely(!p))\n\t\tgoto err;\n\tp->addr = *group;\n\tp->port = port;\n\tp->next = *pp;\n\thlist_add_head(&p->mglist, &port->mglist);\n\tsetup_timer(&p->timer, br_multicast_port_group_expired,\n\t\t    (unsigned long)p);\n\tsetup_timer(&p->query_timer, br_multicast_port_group_query_expired,\n\t\t    (unsigned long)p);\n\trcu_assign_pointer(*pp, p);\nfound:\n\tmod_timer(&p->timer, now + br->multicast_membership_interval);\nout:\n\terr = 0;\nerr:\n\tspin_unlock(&br->multicast_lock);\n\treturn err;\n}", "target": 1}
{"code": "static void ptirq_free_irte(const struct ptirq_remapping_info *entry)\n{\n\tstruct intr_source intr_src;\n\tif (entry->irte_idx < CONFIG_MAX_IR_ENTRIES) {\n\t\tif (entry->intr_type == PTDEV_INTR_MSI) {\n\t\t\tintr_src.is_msi = true;\n\t\t\tintr_src.src.msi.value = entry->phys_sid.msi_id.bdf;\n\t\t} else {\n\t\t\tintr_src.is_msi = false;\n\t\t\tintr_src.src.ioapic_id = ioapic_irq_to_ioapic_id(entry->allocated_pirq);\n\t\t}\n\t\tdmar_free_irte(&intr_src, entry->irte_idx);\n\t}\n}", "target": 1}
{"code": "compileWarning(FileInfo *nested, char *format, ...) {\n#ifndef __SYMBIAN32__\n\tchar buffer[MAXSTRING];\n\tva_list arguments;\n\tva_start(arguments, format);\n\tvsnprintf(buffer, sizeof(buffer), format, arguments);\n\tva_end(arguments);\n\tif (nested)\n\t\t_lou_logMessage(LOG_WARN, \"%s:%d: warning: %s\", nested->fileName,\n\t\t\t\tnested->lineNumber, buffer);\n\telse\n\t\t_lou_logMessage(LOG_WARN, \"warning: %s\", buffer);\n\twarningCount++;\n#endif\n}", "target": 0}
{"code": "static inline void mpeg4_encode_dc(PutBitContext *s, int level, int n)\n{\n#if 1\n    level += 256;\n    if (n < 4) {\n        put_bits(s, uni_DCtab_lum_len[level], uni_DCtab_lum_bits[level]);\n    } else {\n        put_bits(s, uni_DCtab_chrom_len[level], uni_DCtab_chrom_bits[level]);\n    }\n#else\n    int size, v;\n    size = 0;\n    v    = abs(level);\n    while (v) {\n        v >>= 1;\n        size++;\n    }\n    if (n < 4) {\n        put_bits(s, ff_mpeg4_DCtab_lum[size][1], ff_mpeg4_DCtab_lum[size][0]);\n    } else {\n        put_bits(s, ff_mpeg4_DCtab_chrom[size][1], ff_mpeg4_DCtab_chrom[size][0]);\n    }\n    if (size > 0) {\n        if (level < 0)\n            level = (-level) ^ ((1 << size) - 1);\n        put_bits(s, size, level);\n        if (size > 8)\n            put_bits(s, 1, 1);\n    }\n#endif\n}", "target": 0}
{"code": "   Send an email message */\nPHP_FUNCTION(imap_mail)\n{\n\tchar *to=NULL, *message=NULL, *headers=NULL, *subject=NULL, *cc=NULL, *bcc=NULL, *rpath=NULL;\n\tint to_len, message_len, headers_len, subject_len, cc_len, bcc_len, rpath_len, argc = ZEND_NUM_ARGS();\n\tif (zend_parse_parameters(argc TSRMLS_CC, \"sss|ssss\", &to, &to_len, &subject, &subject_len, &message, &message_len,\n\t\t&headers, &headers_len, &cc, &cc_len, &bcc, &bcc_len, &rpath, &rpath_len) == FAILURE) {\n\t\treturn;\n\t}\n\tif (!to_len) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"No to field in mail command\");\n\t\tRETURN_FALSE;\n\t}\n\tif (!subject_len) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"No subject field in mail command\");\n\t\tRETURN_FALSE;\n\t}\n\tif (!message_len) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"No message string in mail command\");\n\t\tmessage = NULL;\n\t}\n\tif (_php_imap_mail(to, subject, message, headers, cc, bcc, rpath TSRMLS_CC)) {\n\t\tRETURN_TRUE;\n\t} else {\n\t\tRETURN_FALSE;\n\t}", "target": 1}
{"code": "bool ItemStackMetadata::setString(const std::string &name, const std::string &var)\n{\n\tbool result = Metadata::setString(name, var);\n\tif (name == TOOLCAP_KEY)\n\t\tupdateToolCapabilities();\n\treturn result;\n}", "target": 1}
{"code": "static int mem_read(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tint n;\n\tassert(cnt >= 0);\n\tassert(buf);\n\tJAS_DBGLOG(100, (\"mem_read(%p, %p, %d)\\n\", obj, buf, cnt));\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tn = m->len_ - m->pos_;\n\tcnt = JAS_MIN(n, cnt);\n\tmemcpy(buf, &m->buf_[m->pos_], cnt);\n\tm->pos_ += cnt;\n\treturn cnt;\n}", "target": 1}
{"code": "grub_password_get (char buf[], unsigned buf_size)\n{\n  unsigned cur_len = 0;\n  int key;\n  while (1)\n    {\n      key = grub_getkey (); \n      if (key == '\\n' || key == '\\r')\n\tbreak;\n      if (key == '\\e')\n\t{\n\t  cur_len = 0;\n\t  break;\n\t}\n      if (key == '\\b')\n\t{\n\t  cur_len--;\n\t  continue;\n\t}\n      if (!grub_isprint (key))\n\tcontinue;\n      if (cur_len + 2 < buf_size)\n\tbuf[cur_len++] = key;\n    }\n  grub_memset (buf + cur_len, 0, buf_size - cur_len);\n  grub_xputs (\"\\n\");\n  grub_refresh ();\n  return (key != '\\e');\n}", "target": 1}
{"code": "grub_username_get (char buf[], unsigned buf_size)\n{\n  unsigned cur_len = 0;\n  int key;\n  while (1)\n    {\n      key = grub_getkey (); \n      if (key == '\\n' || key == '\\r')\n\tbreak;\n      if (key == '\\e')\n\t{\n\t  cur_len = 0;\n\t  break;\n\t}\n      if (key == '\\b')\n\t{\n\t  cur_len--;\n\t  grub_printf (\"\\b\");\n\t  continue;\n\t}\n      if (!grub_isprint (key))\n\tcontinue;\n      if (cur_len + 2 < buf_size)\n\t{\n\t  buf[cur_len++] = key;\n\t  grub_printf (\"%c\", key);\n\t}\n    }\n  grub_memset (buf + cur_len, 0, buf_size - cur_len);\n  grub_xputs (\"\\n\");\n  grub_refresh ();\n  return (key != '\\e');\n}", "target": 1}
{"code": "void nego_process_negotiation_request(rdpNego* nego, wStream* s)\n{\n\tBYTE flags;\n\tUINT16 length;\n\tStream_Read_UINT8(s, flags);\n\tStream_Read_UINT16(s, length);\n\tStream_Read_UINT32(s, nego->RequestedProtocols);\n\tWLog_DBG(TAG, \"RDP_NEG_REQ: RequestedProtocol: 0x%08\" PRIX32 \"\", nego->RequestedProtocols);\n\tnego->state = NEGO_STATE_FINAL;\n}", "target": 1}
{"code": "  inline Eigen::IndexList<int, Eigen::type2index<1>> NByOne(int n) {\n    Eigen::IndexList<int, Eigen::type2index<1>> ret;\n    ret.set(0, n);\n    return ret;\n  }", "target": 1}
{"code": "CreateMultiStringPopUp (\n  IN  UINTN                       RequestedWidth,\n  IN  UINTN                       NumberOfLines,\n  ...\n  )\n{\n  VA_LIST Marker;\n  VA_START (Marker, NumberOfLines);\n  CreateSharedPopUp (RequestedWidth, NumberOfLines, Marker);\n  VA_END (Marker);\n}", "target": 0}
{"code": "static int rm_sync(AVFormatContext *s, int64_t *timestamp, int *flags, int *stream_index, int64_t *pos){\n    RMDemuxContext *rm = s->priv_data;\n    AVIOContext *pb = s->pb;\n    AVStream *st;\n    uint32_t state=0xFFFFFFFF;\n    while(!avio_feof(pb)){\n        int len, num, i;\n        int mlti_id;\n        *pos= avio_tell(pb) - 3;\n        if(rm->remaining_len > 0){\n            num= rm->current_stream;\n            mlti_id = 0;\n            len= rm->remaining_len;\n            *timestamp = AV_NOPTS_VALUE;\n            *flags= 0;\n        }else{\n            state= (state<<8) + avio_r8(pb);\n            if(state == MKBETAG('I', 'N', 'D', 'X')){\n                int n_pkts, expected_len;\n                len = avio_rb32(pb);\n                avio_skip(pb, 2);\n                n_pkts = avio_rb32(pb);\n                expected_len = 20 + n_pkts * 14;\n                if (len == 20)\n                    len = expected_len;\n                else if (len != expected_len)\n                    av_log(s, AV_LOG_WARNING,\n                           \"Index size %d (%d pkts) is wrong, should be %d.\\n\",\n                           len, n_pkts, expected_len);\n                len -= 14; \n                if(len<0)\n                    continue;\n                goto skip;\n            } else if (state == MKBETAG('D','A','T','A')) {\n                av_log(s, AV_LOG_WARNING,\n                       \"DATA tag in middle of chunk, file may be broken.\\n\");\n            }\n            if(state > (unsigned)0xFFFF || state <= 12)\n                continue;\n            len=state - 12;\n            state= 0xFFFFFFFF;\n            num = avio_rb16(pb);\n            *timestamp = avio_rb32(pb);\n            mlti_id = (avio_r8(pb)>>1)-1<<16;\n            mlti_id = FFMAX(mlti_id, 0);\n            *flags = avio_r8(pb); \n        }\n        for(i=0;i<s->nb_streams;i++) {\n            st = s->streams[i];\n            if (mlti_id + num == st->id)\n                break;\n        }\n        if (i == s->nb_streams) {\nskip:\n            avio_skip(pb, len);\n            rm->remaining_len = 0;\n            continue;\n        }\n        *stream_index= i;\n        return len;\n    }\n    return -1;\n}", "target": 0}
{"code": "bool VBRISeeker::getOffsetForTime(int64_t *timeUs, off64_t *pos) {\n if (mDurationUs < 0 || mSegments.size() == 0) {\n return false;\n }\n int64_t segmentDurationUs = mDurationUs / mSegments.size();\n int64_t nowUs = 0;\n *pos = mBasePos;\n size_t segmentIndex = 0;\n while (segmentIndex < mSegments.size() && nowUs < *timeUs) {\n        nowUs += segmentDurationUs;\n *pos += mSegments.itemAt(segmentIndex++);\n }\n    ALOGV(\"getOffsetForTime %lld us => 0x%016llx\", (long long)*timeUs, (long long)*pos);\n *timeUs = nowUs;\n return true;\n}", "target": 0}
{"code": "double Item_cache_str::val_real()\n{\n  DBUG_ASSERT(fixed == 1);\n  int err_not_used;\n  char *end_not_used;\n  if (!has_value())\n    return 0.0;\n  if (value)\n    return my_strntod(value->charset(), (char*) value->ptr(),\n\t\t      value->length(), &end_not_used, &err_not_used);\n  return (double) 0;\n}", "target": 0}
{"code": "cdf_read_user_stream(const cdf_info_t *info, const cdf_header_t *h,\n    const cdf_sat_t *sat, const cdf_sat_t *ssat, const cdf_stream_t *sst,\n    const cdf_dir_t *dir, const char *name, cdf_stream_t *scn)\n{\n\tsize_t i;\n\tconst cdf_directory_t *d;\n\tsize_t name_len = strlen(name) + 1;\n\tfor (i = dir->dir_len; i > 0; i--)\n\t\tif (dir->dir_tab[i - 1].d_type == CDF_DIR_TYPE_USER_STREAM &&\n\t\t    cdf_namecmp(name, dir->dir_tab[i - 1].d_name, name_len)\n\t\t    == 0)\n\t\t\tbreak;\n\tif (i == 0) {\n\t\tDPRINTF((\"Cannot find user stream `%s'\\n\", name));\n\t\terrno = ESRCH;\n\t\treturn -1;\n\t}\n\td = &dir->dir_tab[i - 1];\n\treturn cdf_read_sector_chain(info, h, sat, ssat, sst,\n\t    d->d_stream_first_sector, d->d_size, scn);\n}", "target": 0}
{"code": "static pj_status_t decode_uint_attr(pj_pool_t *pool, \n                                    const pj_uint8_t *buf, \n                                    const pj_stun_msg_hdr *msghdr, \n                                    void **p_attr)\n{\n    pj_stun_uint_attr *attr;\n    PJ_UNUSED_ARG(msghdr);\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_uint_attr);\n    GETATTRHDR(buf, &attr->hdr);\n    attr->value = GETVAL32H(buf, 4);\n    if (attr->hdr.length != 4)\n        return PJNATH_ESTUNINATTRLEN;\n    *p_attr = attr;\n    return PJ_SUCCESS;\n}", "target": 1}
{"code": "static __init int vdso_fixup_datapage(struct lib32_elfinfo *v32,\n\t\t\t\t       struct lib64_elfinfo *v64)\n{\n\tElf32_Sym *sym32;\n#ifdef CONFIG_PPC64\n\tElf64_Sym *sym64;\n       \tsym64 = find_symbol64(v64, \"__kernel_datapage_offset\");\n\tif (sym64 == NULL) {\n\t\tprintk(KERN_ERR \"vDSO64: Can't find symbol \"\n\t\t       \"__kernel_datapage_offset !\\n\");\n\t\treturn -1;\n\t}\n\t*((int *)(vdso64_kbase + sym64->st_value - VDSO64_LBASE)) =\n\t\t(vdso64_pages << PAGE_SHIFT) -\n\t\t(sym64->st_value - VDSO64_LBASE);\n#endif \n\tsym32 = find_symbol32(v32, \"__kernel_datapage_offset\");\n\tif (sym32 == NULL) {\n\t\tprintk(KERN_ERR \"vDSO32: Can't find symbol \"\n\t\t       \"__kernel_datapage_offset !\\n\");\n\t\treturn -1;\n\t}\n\t*((int *)(vdso32_kbase + (sym32->st_value - VDSO32_LBASE))) =\n\t\t(vdso32_pages << PAGE_SHIFT) -\n\t\t(sym32->st_value - VDSO32_LBASE);\n\treturn 0;\n}", "target": 0}
{"code": "png_crc_error(png_structp png_ptr)\n{\n   png_byte crc_bytes[4];\n   png_uint_32 crc;\n   int need_crc = 1;\n   if (png_ptr->chunk_name[0] & 0x20)                     \n   {\n      if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_MASK) ==\n          (PNG_FLAG_CRC_ANCILLARY_USE | PNG_FLAG_CRC_ANCILLARY_NOWARN))\n         need_crc = 0;\n   }\n   else                                                    \n   {\n      if (png_ptr->flags & PNG_FLAG_CRC_CRITICAL_IGNORE)\n         need_crc = 0;\n   }\n   png_read_data(png_ptr, crc_bytes, 4);\n   if (need_crc)\n   {\n      crc = png_get_uint_32(crc_bytes);\n      return ((int)(crc != png_ptr->crc));\n   }\n   else\n      return (0);\n}", "target": 0}
{"code": "int jsi_PstateSetFile(jsi_Pstate *ps, Jsi_Channel fp, int skipbang)\n{\n    jsi_Lexer *l = ps->lexer;\n    jsi_PstateClear(ps);\n    l->ltype = LT_FILE;\n    l->d.fp = fp;\n    Jsi_Rewind(ps->interp, fp);\n    if (skipbang) {\n        char buf[1000];\n        if (Jsi_Gets(ps->interp, fp, buf, 1000) && (buf[0] != '#' || buf[1] != '!')) {\n            Jsi_Rewind(ps->interp, fp);\n        }\n    }\n    return JSI_OK;\n}", "target": 1}
{"code": "static void edge_heartbeat_schedule(struct edgeport_serial *edge_serial)\n{\n\tif (!edge_serial->use_heartbeat)\n\t\treturn;\n\tschedule_delayed_work(&edge_serial->heartbeat_work,\n\t\t\tFW_HEARTBEAT_SECS * HZ);\n}", "target": 0}
{"code": "static ssize_t exitcode_proc_write(struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\tchar *end, buf[sizeof(\"nnnnn\\0\")];\n\tint tmp;\n\tif (copy_from_user(buf, buffer, count))\n\t\treturn -EFAULT;\n\ttmp = simple_strtol(buf, &end, 0);\n\tif ((*end != '\\0') && !isspace(*end))\n\t\treturn -EINVAL;\n\tuml_exitcode = tmp;\n\treturn count;\n}", "target": 1}
{"code": "HttpStateData::finishingBrokenPost()\n{\n#if USE_HTTP_VIOLATIONS\n    if (!Config.accessList.brokenPosts) {\n        debugs(11, 5, HERE << \"No brokenPosts list\");\n        return false;\n    }\n    ACLFilledChecklist ch(Config.accessList.brokenPosts, originalRequest(), NULL);\n    ch.al = fwd->al;\n    ch.syncAle(originalRequest(), nullptr);\n    if (!ch.fastCheck().allowed()) {\n        debugs(11, 5, HERE << \"didn't match brokenPosts\");\n        return false;\n    }\n    if (!Comm::IsConnOpen(serverConnection)) {\n        debugs(11, 3, HERE << \"ignoring broken POST for closed \" << serverConnection);\n        assert(closeHandler != NULL);\n        return true; \n    }\n    debugs(11, 3, \"finishingBrokenPost: fixing broken POST\");\n    typedef CommCbMemFunT<HttpStateData, CommIoCbParams> Dialer;\n    requestSender = JobCallback(11,5,\n                                Dialer, this, HttpStateData::wroteLast);\n    Comm::Write(serverConnection, \"\\r\\n\", 2, requestSender, NULL);\n    return true;\n#else\n    return false;\n#endif \n}", "target": 0}
{"code": "_parse_config_file(pam_handle_t *pamh, int ctrl, const char *file)\n{\n    int retval;\n    char buffer[BUF_SIZE];\n    FILE *conf;\n    VAR Var, *var=&Var;\n    D((\"Called.\"));\n    var->name=NULL; var->defval=NULL; var->override=NULL;\n    D((\"Config file name is: %s\", file));\n    if ((conf = fopen(file,\"r\")) == NULL) {\n      pam_syslog(pamh, LOG_ERR, \"Unable to open config file: %s: %m\", file);\n      return PAM_IGNORE;\n    }\n    while (( retval = _assemble_line(conf, buffer, BUF_SIZE)) > 0) {\n      D((\"Read line: %s\", buffer));\n      if ((retval = _parse_line(pamh, buffer, var)) == GOOD_LINE) {\n\tretval = _check_var(pamh, var);\n\tif (DEFINE_VAR == retval) {\n\t  retval = _define_var(pamh, ctrl, var);\n\t} else if (UNDEFINE_VAR == retval) {\n\t  retval = _undefine_var(pamh, ctrl, var);\n\t}\n      }\n      if (PAM_SUCCESS != retval && ILLEGAL_VAR != retval\n\t  && BAD_LINE != retval && PAM_BAD_ITEM != retval) break;\n      _clean_var(var);\n    }  \n    (void) fclose(conf);\n    _clean_var(var);        \n    D((\"Exit.\"));\n    return (retval != 0 ? PAM_ABORT : PAM_SUCCESS);\n}", "target": 0}
{"code": "static void sp_setup(struct net_device *dev)\n{\n\tdev->netdev_ops\t\t= &sp_netdev_ops;\n\tdev->needs_free_netdev\t= true;\n\tdev->mtu\t\t= SIXP_MTU;\n\tdev->hard_header_len\t= AX25_MAX_HEADER_LEN;\n\tdev->header_ops \t= &ax25_header_ops;\n\tdev->addr_len\t\t= AX25_ADDR_LEN;\n\tdev->type\t\t= ARPHRD_AX25;\n\tdev->tx_queue_len\t= 10;\n\tmemcpy(dev->broadcast, &ax25_bcast, AX25_ADDR_LEN);\n\tdev_addr_set(dev, (u8 *)&ax25_defaddr);\n\tdev->flags\t\t= 0;\n}", "target": 1}
{"code": "int HeaderMapWrapper::luaPairs(lua_State* state) {\n  if (iterator_.get() != nullptr) {\n    luaL_error(state, \"cannot create a second iterator before completing the first\");\n  }\n  iterator_.reset(HeaderMapIterator::create(state, *this), true);\n  lua_pushcclosure(state, HeaderMapIterator::static_luaPairsIterator, 1);\n  return 1;\n}", "target": 0}
{"code": "static bool add_free_nid(struct f2fs_sb_info *sbi, nid_t nid, bool build)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\tstruct nat_entry *ne;\n\tint err;\n\tif (unlikely(nid == 0))\n\t\treturn false;\n\tif (build) {\n\t\tne = __lookup_nat_cache(nm_i, nid);\n\t\tif (ne && (!get_nat_flag(ne, IS_CHECKPOINTED) ||\n\t\t\t\tnat_get_blkaddr(ne) != NULL_ADDR))\n\t\t\treturn false;\n\t}\n\ti = f2fs_kmem_cache_alloc(free_nid_slab, GFP_NOFS);\n\ti->nid = nid;\n\ti->state = NID_NEW;\n\tif (radix_tree_preload(GFP_NOFS)) {\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn true;\n\t}\n\tspin_lock(&nm_i->nid_list_lock);\n\terr = __insert_nid_to_list(sbi, i, FREE_NID_LIST, true);\n\tspin_unlock(&nm_i->nid_list_lock);\n\tradix_tree_preload_end();\n\tif (err) {\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn true;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "is_link_trusted (NautilusFile *file,\n                 gboolean      is_launcher)\n{\n    GFile *location;\n    gboolean res;\n    if (!is_launcher)\n    {\n        return TRUE;\n    }\n    if (nautilus_file_can_execute (file))\n    {\n        return TRUE;\n    }\n    res = FALSE;\n    if (nautilus_file_is_local (file))\n    {\n        location = nautilus_file_get_location (file);\n        res = nautilus_is_in_system_dir (location);\n        g_object_unref (location);\n    }\n    return res;\n}", "target": 1}
{"code": "int fit_image_verify(const void *fit, int image_noffset)\n{\n\tconst void\t*data;\n\tsize_t\t\tsize;\n\tint\t\tnoffset = 0;\n\tchar\t\t*err_msg = \"\";\n\tif (fit_image_get_data_and_size(fit, image_noffset, &data, &size)) {\n\t\terr_msg = \"Can't get image data/size\";\n\t\tprintf(\"error!\\n%s for '%s' hash node in '%s' image node\\n\",\n\t\t       err_msg, fit_get_name(fit, noffset, NULL),\n\t\t       fit_get_name(fit, image_noffset, NULL));\n\t\treturn 0;\n\t}\n\treturn fit_image_verify_with_data(fit, image_noffset, data, size);\n}", "target": 1}
{"code": "void kvm_lapic_sync_to_vapic(struct kvm_vcpu *vcpu)\n{\n\tu32 data, tpr;\n\tint max_irr, max_isr;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tvoid *vapic;\n\tapic_sync_pv_eoi_to_guest(vcpu, apic);\n\tif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\n\t\treturn;\n\ttpr = kvm_apic_get_reg(apic, APIC_TASKPRI) & 0xff;\n\tmax_irr = apic_find_highest_irr(apic);\n\tif (max_irr < 0)\n\t\tmax_irr = 0;\n\tmax_isr = apic_find_highest_isr(apic);\n\tif (max_isr < 0)\n\t\tmax_isr = 0;\n\tdata = (tpr & 0xff) | ((max_isr & 0xf0) << 8) | (max_irr << 24);\n\tvapic = kmap_atomic(vcpu->arch.apic->vapic_page);\n\t*(u32 *)(vapic + offset_in_page(vcpu->arch.apic->vapic_addr)) = data;\n\tkunmap_atomic(vapic);\n}", "target": 1}
{"code": "Variant HHVM_FUNCTION(mcrypt_get_block_size, const String& cipher,\n                                    const Variant& module ) {\n  MCRYPT td = mcrypt_module_open((char*)cipher.data(),\n                                 (char*)MCG(algorithms_dir).data(),\n                                 (char*)module.asCStrRef().data(),\n                                 (char*)MCG(modes_dir).data());\n  if (td == MCRYPT_FAILED) {\n    MCRYPT_OPEN_MODULE_FAILED(\"mcrypt_get_block_size\");\n    return false;\n  }\n  int64_t ret = mcrypt_enc_get_block_size(td);\n  mcrypt_module_close(td);\n  return ret;\n}", "target": 1}
{"code": "TEE_Result crypto_acipher_alloc_dsa_public_key(struct dsa_public_key *s,\n\t\t\t\t\t       size_t key_size_bits __unused)\n{\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->g))\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tif (!bn_alloc_max(&s->p))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->q))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->y))\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(s->g);\n\tcrypto_bignum_free(s->p);\n\tcrypto_bignum_free(s->q);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "mm_skey_query(void *ctx, char **name, char **infotxt,\n   u_int *numprompts, char ***prompts, u_int **echo_on)\n{\n\tBuffer m;\n\tint len;\n\tu_int success;\n\tchar *p, *challenge;\n\tdebug3(\"%s: entering\", __func__);\n\tbuffer_init(&m);\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_SKEYQUERY, &m);\n\tmm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_SKEYQUERY,\n\t    &m);\n\tsuccess = buffer_get_int(&m);\n\tif (success == 0) {\n\t\tdebug3(\"%s: no challenge\", __func__);\n\t\tbuffer_free(&m);\n\t\treturn (-1);\n\t}\n\tchallenge  = buffer_get_string(&m, NULL);\n\tbuffer_free(&m);\n\tdebug3(\"%s: received challenge: %s\", __func__, challenge);\n\tmm_chall_setup(name, infotxt, numprompts, prompts, echo_on);\n\tlen = strlen(challenge) + strlen(SKEY_PROMPT) + 1;\n\tp = xmalloc(len);\n\tstrlcpy(p, challenge, len);\n\tstrlcat(p, SKEY_PROMPT, len);\n\t(*prompts)[0] = p;\n\txfree(challenge);\n\treturn (0);\n}", "target": 0}
{"code": "GF_Err url_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s;\n\tif (ptr->size) {\n\t\tptr->location = (char*)gf_malloc((u32) ptr->size);\n\t\tif (! ptr->location) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->location, (u32)ptr->size);\n\t\tif (ptr->location[ptr->size-1]) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] url box location is not 0-terminated\\n\" ));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "Status ArrayFromMemory(int dim_size, npy_intp* dims, void* data, DataType dtype,\n                       std::function<void()> destructor, PyObject** result) {\n  if (dtype == DT_STRING || dtype == DT_RESOURCE) {\n    return errors::FailedPrecondition(\n        \"Cannot convert string or resource Tensors.\");\n  }\n  int type_num = -1;\n  Status s =\n      TF_DataType_to_PyArray_TYPE(static_cast<TF_DataType>(dtype), &type_num);\n  if (!s.ok()) {\n    return s;\n  }\n  if (dim_size > NPY_MAXDIMS) {\n    return errors::InvalidArgument(\n        \"Cannot convert tensor with \", dim_size,\n        \" dimensions to NumPy array. NumPy arrays can have at most \",\n        NPY_MAXDIMS, \" dimensions\");\n  }\n  auto* np_array = reinterpret_cast<PyArrayObject*>(\n      PyArray_SimpleNewFromData(dim_size, dims, type_num, data));\n  if (np_array == nullptr) {\n    string shape_str = absl::StrJoin(\n        absl::Span<npy_intp>{dims, static_cast<size_t>(dim_size)}, \", \");\n    if (PyErr_Occurred()) {\n      string exception_str = PyExceptionFetch();\n      PyErr_Clear();\n      return errors::InvalidArgument(\n          \"Failed to create numpy array from tensor of shape [\", shape_str,\n          \"]. Numpy error: \", exception_str);\n    }\n    return errors::Internal(\n        \"Failed to create numpy array from tensor of shape [\", shape_str, \"]\");\n  }\n  PyArray_CLEARFLAGS(np_array, NPY_ARRAY_OWNDATA);\n  if (PyType_Ready(&TensorReleaserType) == -1) {\n    return errors::Unknown(\"Python type initialization failed.\");\n  }\n  auto* releaser = reinterpret_cast<TensorReleaser*>(\n      TensorReleaserType.tp_alloc(&TensorReleaserType, 0));\n  releaser->destructor = new std::function<void()>(std::move(destructor));\n  if (PyArray_SetBaseObject(np_array, reinterpret_cast<PyObject*>(releaser)) ==\n      -1) {\n    Py_DECREF(releaser);\n    return errors::Unknown(\"Python array refused to use memory.\");\n  }\n  *result = reinterpret_cast<PyObject*>(np_array);\n  return OkStatus();\n}", "target": 0}
{"code": "static void recalculate_apic_map(struct kvm *kvm)\n{\n\tstruct kvm_apic_map *new, *old = NULL;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\tnew = kzalloc(sizeof(struct kvm_apic_map), GFP_KERNEL);\n\tmutex_lock(&kvm->arch.apic_map_lock);\n\tif (!new)\n\t\tgoto out;\n\tnew->ldr_bits = 8;\n\tnew->cid_shift = 8;\n\tnew->cid_mask = 0;\n\tnew->lid_mask = 0xff;\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\t\tu16 cid, lid;\n\t\tu32 ldr;\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tnew->ldr_bits = 32;\n\t\t\tnew->cid_shift = 16;\n\t\t\tnew->cid_mask = new->lid_mask = 0xffff;\n\t\t} else if (kvm_apic_sw_enabled(apic) &&\n\t\t\t\t!new->cid_mask  &&\n\t\t\t\tkvm_apic_get_reg(apic, APIC_DFR) == APIC_DFR_CLUSTER) {\n\t\t\tnew->cid_shift = 4;\n\t\t\tnew->cid_mask = 0xf;\n\t\t\tnew->lid_mask = 0xf;\n\t\t}\n\t\tnew->phys_map[kvm_apic_id(apic)] = apic;\n\t\tldr = kvm_apic_get_reg(apic, APIC_LDR);\n\t\tcid = apic_cluster_id(new, ldr);\n\t\tlid = apic_logical_id(new, ldr);\n\t\tif (lid)\n\t\t\tnew->logical_map[cid][ffs(lid) - 1] = apic;\n\t}\nout:\n\told = rcu_dereference_protected(kvm->arch.apic_map,\n\t\t\tlockdep_is_held(&kvm->arch.apic_map_lock));\n\trcu_assign_pointer(kvm->arch.apic_map, new);\n\tmutex_unlock(&kvm->arch.apic_map_lock);\n\tif (old)\n\t\tkfree_rcu(old, rcu);\n\tkvm_vcpu_request_scan_ioapic(kvm);\n}", "target": 1}
{"code": "DLLIMPORT int cfg_setnstr(cfg_t *cfg, const char *name, const char *value, unsigned int index)\n{\n\tcfg_opt_t *opt;\n\topt = cfg_getopt(cfg, name);\n\tif (opt && opt->validcb2 && (*opt->validcb2)(cfg, opt, (void *)value) != 0)\n\t\treturn CFG_FAIL;\n\treturn cfg_opt_setnstr(opt, value, index);\n}", "target": 0}
{"code": "static inline s16 fixp_mult(s16 a, s16 b)\n{\n\ta = ((s32)a * 0x100) / 0x7fff;\n\treturn ((s32)(a * b)) >> FRAC_N;\n}", "target": 0}
{"code": "static inline QString toString(bool b)\n{\n    return b ? QLatin1String(\"true\") : QLatin1String(\"false\");\n}", "target": 0}
{"code": "static void bnx2x_handle_classification_eqe(struct bnx2x *bp,\n\t\t\t\t\t    union event_ring_elem *elem)\n{\n\tunsigned long ramrod_flags = 0;\n\tint rc = 0;\n\tu32 echo = le32_to_cpu(elem->message.data.eth_event.echo);\n\tu32 cid = echo & BNX2X_SWCID_MASK;\n\tstruct bnx2x_vlan_mac_obj *vlan_mac_obj;\n\t__set_bit(RAMROD_CONT, &ramrod_flags);\n\tswitch (echo >> BNX2X_SWCID_SHIFT) {\n\tcase BNX2X_FILTER_MAC_PENDING:\n\t\tDP(BNX2X_MSG_SP, \"Got SETUP_MAC completions\\n\");\n\t\tif (CNIC_LOADED(bp) && (cid == BNX2X_ISCSI_ETH_CID(bp)))\n\t\t\tvlan_mac_obj = &bp->iscsi_l2_mac_obj;\n\t\telse\n\t\t\tvlan_mac_obj = &bp->sp_objs[cid].mac_obj;\n\t\tbreak;\n\tcase BNX2X_FILTER_VLAN_PENDING:\n\t\tDP(BNX2X_MSG_SP, \"Got SETUP_VLAN completions\\n\");\n\t\tvlan_mac_obj = &bp->sp_objs[cid].vlan_obj;\n\t\tbreak;\n\tcase BNX2X_FILTER_MCAST_PENDING:\n\t\tDP(BNX2X_MSG_SP, \"Got SETUP_MCAST completions\\n\");\n\t\tbnx2x_handle_mcast_eqe(bp);\n\t\treturn;\n\tdefault:\n\t\tBNX2X_ERR(\"Unsupported classification command: 0x%x\\n\", echo);\n\t\treturn;\n\t}\n\trc = vlan_mac_obj->complete(bp, vlan_mac_obj, elem, &ramrod_flags);\n\tif (rc < 0)\n\t\tBNX2X_ERR(\"Failed to schedule new commands: %d\\n\", rc);\n\telse if (rc > 0)\n\t\tDP(BNX2X_MSG_SP, \"Scheduled next pending commands...\\n\");\n}", "target": 0}
{"code": "static void free_clt(struct rtrs_clt_sess *clt)\n{\n\tfree_permits(clt);\n\tfree_percpu(clt->pcpu_path);\n\tmutex_destroy(&clt->paths_ev_mutex);\n\tmutex_destroy(&clt->paths_mutex);\n\tdevice_unregister(&clt->dev);\n}", "target": 1}
{"code": "void start_cfs_bandwidth(struct cfs_bandwidth *cfs_b)\n{\n\tu64 overrun;\n\tlockdep_assert_held(&cfs_b->lock);\n\tif (cfs_b->period_active)\n\t\treturn;\n\tcfs_b->period_active = 1;\n\toverrun = hrtimer_forward_now(&cfs_b->period_timer, cfs_b->period);\n\tcfs_b->runtime_expires += (overrun + 1) * ktime_to_ns(cfs_b->period);\n\tcfs_b->expires_seq++;\n\thrtimer_start_expires(&cfs_b->period_timer, HRTIMER_MODE_ABS_PINNED);\n}", "target": 1}
{"code": "static int jpc_dec_process_eoc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tint tileno;\n\tjpc_dec_tile_t *tile;\n\tms = 0;\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,\n\t  ++tile) {\n\t\tif (tile->state == JPC_TILE_ACTIVE) {\n\t\t\tif (jpc_dec_tiledecode(dec, tile)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (tile->state != JPC_TILE_DONE) {\n\t\t\tjpc_dec_tilefini(dec, tile);\n\t\t}\n\t}\n\tdec->state = JPC_MT;\n\treturn 1;\n}", "target": 0}
{"code": "static void exif_process_CME (image_info_type *image_info, char *value, size_t length)\n{\n\tif (length>3) {\n\t\tswitch(value[2]) {\n\t\t\tcase 0:\n\t\t\t\texif_iif_add_tag(image_info, SECTION_COMMENT, \"Comment\", TAG_COMPUTED_VALUE, TAG_FMT_UNDEFINED, length, value, length);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\texif_iif_add_tag(image_info, SECTION_COMMENT, \"Comment\", TAG_COMPUTED_VALUE, TAG_FMT_STRING, length, value, length);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tphp_error_docref(NULL, E_NOTICE, \"Undefined JPEG2000 comment encoding\");\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\texif_iif_add_tag(image_info, SECTION_COMMENT, \"Comment\", TAG_COMPUTED_VALUE, TAG_FMT_UNDEFINED, 0, NULL, 0);\n\t\tphp_error_docref(NULL, E_NOTICE, \"JPEG2000 comment section too small\");\n\t}\n}", "target": 0}
{"code": "void RenderWidgetHostImpl::AddMouseEventCallback(\n    const MouseEventCallback& callback) {\n  mouse_event_callbacks_.push_back(callback);\n}", "target": 0}
{"code": "int sctp_ulpq_tail_data(struct sctp_ulpq *ulpq, struct sctp_chunk *chunk,\n\t\t\tgfp_t gfp)\n{\n\tstruct sk_buff_head temp;\n\tsctp_data_chunk_t *hdr;\n\tstruct sctp_ulpevent *event;\n\thdr = (sctp_data_chunk_t *) chunk->chunk_hdr;\n\tevent = sctp_ulpevent_make_rcvmsg(chunk->asoc, chunk, gfp);\n\tif (!event)\n\t\treturn -ENOMEM;\n\tevent = sctp_ulpq_reasm(ulpq, event);\n\tif ((event) && (event->msg_flags & MSG_EOR)){\n\t\tskb_queue_head_init(&temp);\n\t\t__skb_queue_tail(&temp, sctp_event2skb(event));\n\t\tevent = sctp_ulpq_order(ulpq, event);\n\t}\n\tif (event)\n\t\tsctp_ulpq_tail_event(ulpq, event);\n\treturn 0;\n}", "target": 0}
{"code": "static int exif_file_sections_add(image_info_type *ImageInfo, int type, size_t size, uchar *data)\n{\n\tfile_section    *tmp;\n\tint             count = ImageInfo->file.count;\n\ttmp = safe_erealloc(ImageInfo->file.list, (count+1), sizeof(file_section), 0);\n\tImageInfo->file.list = tmp;\n\tImageInfo->file.list[count].type = 0xFFFF;\n\tImageInfo->file.list[count].data = NULL;\n\tImageInfo->file.list[count].size = 0;\n\tImageInfo->file.count = count+1;\n\tif (!size) {\n\t\tdata = NULL;\n\t} else if (data == NULL) {\n\t\tdata = safe_emalloc(size, 1, 0);\n\t}\n\tImageInfo->file.list[count].type = type;\n\tImageInfo->file.list[count].data = data;\n\tImageInfo->file.list[count].size = size;\n\treturn count;\n}", "target": 0}
{"code": "static Image *RenderHoughLines(const ImageInfo *image_info,const size_t columns,\n  const size_t rows,ExceptionInfo *exception)\n{\n#define BoundingBox  \"viewbox\"\n  DrawInfo\n    *draw_info;\n  Image\n    *image;\n  MagickBooleanType\n    status;\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  image->columns=columns;\n  image->rows=rows;\n  draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);\n  draw_info->affine.sx=image->resolution.x == 0.0 ? 1.0 : image->resolution.x/\n    DefaultResolution;\n  draw_info->affine.sy=image->resolution.y == 0.0 ? 1.0 : image->resolution.y/\n    DefaultResolution;\n  image->columns=(size_t) (draw_info->affine.sx*image->columns);\n  image->rows=(size_t) (draw_info->affine.sy*image->rows);\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  if (SetImageBackgroundColor(image,exception) == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (GetBlobStreamData(image) == (unsigned char *) NULL)\n    draw_info->primitive=FileToString(image->filename,~0UL,exception);\n  else\n    {\n      draw_info->primitive=(char *) AcquireMagickMemory((size_t)\n        GetBlobSize(image)+1);\n      if (draw_info->primitive != (char *) NULL)\n        {\n          (void) memcpy(draw_info->primitive,GetBlobStreamData(image),\n            (size_t) GetBlobSize(image));\n          draw_info->primitive[GetBlobSize(image)]='\\0';\n        }\n     }\n  (void) DrawImage(image,draw_info,exception);\n  draw_info=DestroyDrawInfo(draw_info);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}", "target": 0}
{"code": "int Archive::Read(void *Data,size_t Size)\n{\n  size_t Result;\n  if (QOpen.Read(Data,Size,Result))\n    return (int)Result;\n  return File::Read(Data,Size);\n}", "target": 1}
{"code": "int ImagingLibTiffEncodeInit(ImagingCodecState state, char *filename, int fp) {\n    TIFFSTATE *clientstate = (TIFFSTATE *)state->context;\n    int bufsize = 64*1024;\n    char *mode = \"w\";\n    TRACE((\"initing libtiff\\n\"));\n    TRACE((\"Filename %s, filepointer: %d \\n\", filename,  fp));\n    TRACE((\"State: count %d, state %d, x %d, y %d, ystep %d\\n\", state->count, state->state,\n           state->x, state->y, state->ystep));\n    TRACE((\"State: xsize %d, ysize %d, xoff %d, yoff %d \\n\", state->xsize, state->ysize,\n           state->xoff, state->yoff));\n    TRACE((\"State: bits %d, bytes %d \\n\", state->bits, state->bytes));\n    TRACE((\"State: context %p \\n\", state->context));\n    clientstate->loc = 0;\n    clientstate->size = 0;\n    clientstate->eof =0;\n    clientstate->data = 0;\n    clientstate->flrealloc = 0;\n    clientstate->fp = fp;\n    state->state = 0;\n    if (fp) {\n        TRACE((\"Opening using fd: %d for writing \\n\",clientstate->fp));\n        clientstate->tiff = TIFFFdOpen(clientstate->fp, filename, mode);\n    } else {\n        TRACE((\"Opening a buffer for writing \\n\"));\n        clientstate->data = malloc(bufsize);\n        clientstate->size = bufsize;\n        clientstate->flrealloc=1;\n        if (!clientstate->data) {\n            TRACE((\"Error, couldn't allocate a buffer of size %d\\n\", bufsize));\n            return 0;\n        }\n        clientstate->tiff = TIFFClientOpen(filename, mode,\n                                           (thandle_t) clientstate,\n                                           _tiffReadProc, _tiffWriteProc,\n                                           _tiffSeekProc, _tiffCloseProc, _tiffSizeProc,\n                                           _tiffNullMapProc, _tiffUnmapProc); \n    }\n    if (!clientstate->tiff) {\n        TRACE((\"Error, couldn't open tiff file\\n\"));\n        return 0;\n    }\n    return 1;\n}", "target": 0}
{"code": "new_httpd(isc_httpdmgr_t *httpdmgr, isc_nmhandle_t *handle) {\n\tisc_httpd_t *httpd = NULL;\n\tchar *headerdata = NULL;\n\tREQUIRE(VALID_HTTPDMGR(httpdmgr));\n\thttpd = isc_nmhandle_getdata(handle);\n\tif (httpd == NULL) {\n\t\thttpd = isc_nmhandle_getextra(handle);\n\t\t*httpd = (isc_httpd_t){ .handle = NULL };\n\t\thttpdmgr_attach(httpdmgr, &httpd->mgr);\n\t}\n\tif (httpd->handle == NULL) {\n\t\tisc_nmhandle_setdata(handle, httpd, httpd_reset, httpd_put);\n\t\thttpd->handle = handle;\n\t} else {\n\t\tINSIST(httpd->handle == handle);\n\t}\n\theaderdata = isc_mem_get(httpdmgr->mctx, HTTP_SENDGROW);\n\tisc_buffer_init(&httpd->headerbuffer, headerdata, HTTP_SENDGROW);\n\tisc_buffer_clear(&httpd->headerbuffer);\n\tisc_buffer_initnull(&httpd->compbuffer);\n\tisc_buffer_clear(&httpd->compbuffer);\n\tisc_buffer_initnull(&httpd->bodybuffer);\n\tISC_LINK_INIT(httpd, link);\n\thttpd->magic = HTTPD_MAGIC;\n\thttpd->state = RECV;\n\tLOCK(&httpdmgr->lock);\n\tISC_LIST_APPEND(httpdmgr->running, httpd, link);\n\tUNLOCK(&httpdmgr->lock);\n\tisc_nmhandle_attach(httpd->handle, &httpd->readhandle);\n\tisc_nm_read(handle, httpd_request, httpdmgr);\n}", "target": 0}
{"code": "xmlValidNormalizeAttributeValue(xmlDocPtr doc, xmlNodePtr elem,\n\t\t\t        const xmlChar *name, const xmlChar *value) {\n    xmlChar *ret, *dst;\n    const xmlChar *src;\n    xmlAttributePtr attrDecl = NULL;\n    if (doc == NULL) return(NULL);\n    if (elem == NULL) return(NULL);\n    if (name == NULL) return(NULL);\n    if (value == NULL) return(NULL);\n    if ((elem->ns != NULL) && (elem->ns->prefix != NULL)) {\n\txmlChar fn[50];\n\txmlChar *fullname;\n\tfullname = xmlBuildQName(elem->name, elem->ns->prefix, fn, 50);\n\tif (fullname == NULL)\n\t    return(NULL);\n\tif ((fullname != fn) && (fullname != elem->name))\n\t    xmlFree(fullname);\n    }\n    attrDecl = xmlGetDtdAttrDesc(doc->intSubset, elem->name, name);\n    if ((attrDecl == NULL) && (doc->extSubset != NULL))\n\tattrDecl = xmlGetDtdAttrDesc(doc->extSubset, elem->name, name);\n    if (attrDecl == NULL)\n\treturn(NULL);\n    if (attrDecl->atype == XML_ATTRIBUTE_CDATA)\n\treturn(NULL);\n    ret = xmlStrdup(value);\n    if (ret == NULL)\n\treturn(NULL);\n    src = value;\n    dst = ret;\n    while (*src == 0x20) src++;\n    while (*src != 0) {\n\tif (*src == 0x20) {\n\t    while (*src == 0x20) src++;\n\t    if (*src != 0)\n\t\t*dst++ = 0x20;\n\t} else {\n\t    *dst++ = *src++;\n\t}\n    }\n    *dst = 0;\n    return(ret);\n}", "target": 1}
{"code": "static int http_open(URLContext *h, const char *uri, int flags,\n                     AVDictionary **options)\n{\n    HTTPContext *s = h->priv_data;\n    int ret;\n    if( s->seekable == 1 )\n        h->is_streamed = 0;\n    else\n        h->is_streamed = 1;\n    s->filesize = -1;\n    s->location = av_strdup(uri);\n    if (!s->location)\n        return AVERROR(ENOMEM);\n    if (options)\n        av_dict_copy(&s->chained_options, *options, 0);\n    if (s->headers) {\n        int len = strlen(s->headers);\n        if (len < 2 || strcmp(\"\\r\\n\", s->headers + len - 2)) {\n            av_log(h, AV_LOG_WARNING,\n                   \"No trailing CRLF found in HTTP header.\\n\");\n            ret = av_reallocp(&s->headers, len + 3);\n            if (ret < 0)\n                return ret;\n            s->headers[len]     = '\\r';\n            s->headers[len + 1] = '\\n';\n            s->headers[len + 2] = '\\0';\n        }\n    }\n    if (s->listen) {\n        return http_listen(h, uri, flags, options);\n    }\n    ret = http_open_cnx(h, options);\n    if (ret < 0)\n        av_dict_free(&s->chained_options);\n    return ret;\n}", "target": 1}
{"code": "void InstanceKlass::check_prohibited_package(Symbol* class_name,\n                                             ClassLoaderData* loader_data,\n                                             TRAPS) {\n  if (!loader_data->is_boot_class_loader_data() &&\n      !loader_data->is_platform_class_loader_data() &&\n      class_name != NULL && class_name->utf8_length() >= 5) {\n    ResourceMark rm(THREAD);\n    bool prohibited;\n    const u1* base = class_name->base();\n    if ((base[0] | base[1] | base[2] | base[3] | base[4]) & 0x80) {\n      prohibited = is_prohibited_package_slow(class_name);\n    } else {\n      char* name = class_name->as_C_string();\n      prohibited = (strncmp(name, JAVAPKG, JAVAPKG_LEN) == 0 && name[JAVAPKG_LEN] == '/');\n    }\n    if (prohibited) {\n      TempNewSymbol pkg_name = ClassLoader::package_from_class_name(class_name);\n      assert(pkg_name != NULL, \"Error in parsing package name starting with 'java/'\");\n      char* name = pkg_name->as_C_string();\n      const char* class_loader_name = loader_data->loader_name_and_id();\n      StringUtils::replace_no_expand(name, \"/\", \".\");\n      const char* msg_text1 = \"Class loader (instance of): \";\n      const char* msg_text2 = \" tried to load prohibited package name: \";\n      size_t len = strlen(msg_text1) + strlen(class_loader_name) + strlen(msg_text2) + strlen(name) + 1;\n      char* message = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, len);\n      jio_snprintf(message, len, \"%s%s%s%s\", msg_text1, class_loader_name, msg_text2, name);\n      THROW_MSG(vmSymbols::java_lang_SecurityException(), message);\n    }\n  }\n  return;\n}", "target": 0}
{"code": "void ZydisFormatterBufferInit(ZydisFormatterBuffer* buffer, char* user_buffer,\n    ZyanUSize length)\n{\n    ZYAN_ASSERT(buffer);\n    ZYAN_ASSERT(user_buffer);\n    ZYAN_ASSERT(length);\n    buffer->is_token_list              = ZYAN_FALSE;\n    buffer->string.flags               = ZYAN_STRING_HAS_FIXED_CAPACITY;\n    buffer->string.vector.allocator    = ZYAN_NULL;\n    buffer->string.vector.element_size = sizeof(char);\n    buffer->string.vector.size         = 1;\n    buffer->string.vector.capacity     = length;\n    buffer->string.vector.data         = user_buffer;\n    *user_buffer = '\\0';\n}", "target": 1}
{"code": "htc_request_check_host_hdr(struct http *hp)\n{\n\tint u;\n\tint seen_host = 0;\n\tfor (u = HTTP_HDR_FIRST; u < hp->nhd; u++) {\n\t\tif (hp->hd[u].b == NULL)\n\t\t\tcontinue;\n\t\tAN(hp->hd[u].b);\n\t\tAN(hp->hd[u].e);\n\t\tif (http_IsHdr(&hp->hd[u], H_Host)) {\n\t\t\tif (seen_host) {\n\t\t\t\treturn (400);\n\t\t\t}\n\t\t\tseen_host = 1;\n\t\t}\n\t}\n\treturn (0);\n}", "target": 1}
{"code": "psf_d2i_clip_array (const double *src, int *dest, int count, int normalize)\n{\tdouble\t\t\tnormfact, scaled_value ;\n\tnormfact = normalize ? (8.0 * 0x10000000) : 1.0 ;\n\twhile (--count >= 0)\n\t{\tscaled_value = src [count] * normfact ;\n\t\tif (CPU_CLIPS_POSITIVE == 0 && scaled_value >= (1.0 * 0x7FFFFFFF))\n\t\t{\tdest [count] = 0x7FFFFFFF ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\t\tif (CPU_CLIPS_NEGATIVE == 0 && scaled_value <= (-8.0 * 0x10000000))\n\t\t{\tdest [count] = 0x80000000 ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\t\tdest [count] = lrint (scaled_value) ;\n\t\t} ;\n\treturn ;\n} ", "target": 0}
{"code": "    virtual AP4_Result WritePartial(const void* buffer,\n                                    AP4_Size    bytes_to_write, \n                                    AP4_Size&   bytes_written) {\n        AP4_UI08* out = new AP4_UI08[bytes_to_write+16];\n        AP4_Size  out_size = bytes_to_write+16;\n        AP4_Result result = m_StreamCipher->ProcessBuffer((const AP4_UI08*)buffer,\n                                                          bytes_to_write,\n                                                          out,\n                                                          &out_size);\n        if (AP4_SUCCEEDED(result)) {\n            result = m_Output->Write(out, out_size);\n            bytes_written = bytes_to_write;\n            m_Size       += bytes_to_write;\n        } else {\n            bytes_written = 0;\n        }\n        delete[] out;\n        return result;\n    }", "target": 0}
{"code": "static void bnx2x_oem_event(struct bnx2x *bp, u32 event)\n{\n\tu32 cmd_ok, cmd_fail;\n\tif (event & DRV_STATUS_DCC_EVENT_MASK &&\n\t    event & DRV_STATUS_OEM_EVENT_MASK) {\n\t\tBNX2X_ERR(\"Received simultaneous events %08x\\n\", event);\n\t\treturn;\n\t}\n\tif (event & DRV_STATUS_DCC_EVENT_MASK) {\n\t\tcmd_fail = DRV_MSG_CODE_DCC_FAILURE;\n\t\tcmd_ok = DRV_MSG_CODE_DCC_OK;\n\t} else  {\n\t\tcmd_fail = DRV_MSG_CODE_OEM_FAILURE;\n\t\tcmd_ok = DRV_MSG_CODE_OEM_OK;\n\t}\n\tDP(BNX2X_MSG_MCP, \"oem_event 0x%x\\n\", event);\n\tif (event & (DRV_STATUS_DCC_DISABLE_ENABLE_PF |\n\t\t     DRV_STATUS_OEM_DISABLE_ENABLE_PF)) {\n\t\tif (bp->mf_config[BP_VN(bp)] & FUNC_MF_CFG_FUNC_DISABLED) {\n\t\t\tDP(BNX2X_MSG_MCP, \"mf_cfg function disabled\\n\");\n\t\t\tbp->flags |= MF_FUNC_DIS;\n\t\t\tbnx2x_e1h_disable(bp);\n\t\t} else {\n\t\t\tDP(BNX2X_MSG_MCP, \"mf_cfg function enabled\\n\");\n\t\t\tbp->flags &= ~MF_FUNC_DIS;\n\t\t\tbnx2x_e1h_enable(bp);\n\t\t}\n\t\tevent &= ~(DRV_STATUS_DCC_DISABLE_ENABLE_PF |\n\t\t\t   DRV_STATUS_OEM_DISABLE_ENABLE_PF);\n\t}\n\tif (event & (DRV_STATUS_DCC_BANDWIDTH_ALLOCATION |\n\t\t     DRV_STATUS_OEM_BANDWIDTH_ALLOCATION)) {\n\t\tbnx2x_config_mf_bw(bp);\n\t\tevent &= ~(DRV_STATUS_DCC_BANDWIDTH_ALLOCATION |\n\t\t\t   DRV_STATUS_OEM_BANDWIDTH_ALLOCATION);\n\t}\n\tif (event)\n\t\tbnx2x_fw_command(bp, cmd_fail, 0);\n\telse\n\t\tbnx2x_fw_command(bp, cmd_ok, 0);\n}", "target": 0}
{"code": "void WriteValue(Message* m, const Value* value, int recursion) {\n  bool result;\n  if (recursion > kMaxRecursionDepth) {\n    LOG(WARNING) << \"Max recursion depth hit in WriteValue.\";\n    return;\n  }\n  m->WriteInt(value->GetType());\n  switch (value->GetType()) {\n    case Value::TYPE_NULL:\n    break;\n    case Value::TYPE_BOOLEAN: {\n      bool val;\n      result = value->GetAsBoolean(&val);\n      DCHECK(result);\n      WriteParam(m, val);\n      break;\n    }\n    case Value::TYPE_INTEGER: {\n      int val;\n      result = value->GetAsInteger(&val);\n      DCHECK(result);\n      WriteParam(m, val);\n      break;\n    }\n    case Value::TYPE_DOUBLE: {\n      double val;\n      result = value->GetAsDouble(&val);\n      DCHECK(result);\n      WriteParam(m, val);\n      break;\n    }\n    case Value::TYPE_STRING: {\n      std::string val;\n      result = value->GetAsString(&val);\n      DCHECK(result);\n      WriteParam(m, val);\n      break;\n    }\n    case Value::TYPE_BINARY: {\n      const base::BinaryValue* binary =\n          static_cast<const base::BinaryValue*>(value);\n      m->WriteData(binary->GetBuffer(), static_cast<int>(binary->GetSize()));\n      break;\n    }\n    case Value::TYPE_DICTIONARY: {\n      const DictionaryValue* dict = static_cast<const DictionaryValue*>(value);\n      WriteParam(m, static_cast<int>(dict->size()));\n      for (DictionaryValue::key_iterator it = dict->begin_keys();\n           it != dict->end_keys(); ++it) {\n        const Value* subval;\n        if (dict->GetWithoutPathExpansion(*it, &subval)) {\n          WriteParam(m, *it);\n          WriteValue(m, subval, recursion + 1);\n        } else {\n          NOTREACHED() << \"DictionaryValue iterators are filthy liars.\";\n        }\n      }\n      break;\n    }\n    case Value::TYPE_LIST: {\n      const ListValue* list = static_cast<const ListValue*>(value);\n      WriteParam(m, static_cast<int>(list->GetSize()));\n      for (size_t i = 0; i < list->GetSize(); ++i) {\n        const Value* subval;\n        if (list->Get(i, &subval)) {\n          WriteValue(m, subval, recursion + 1);\n        } else {\n          NOTREACHED() << \"ListValue::GetSize is a filthy liar.\";\n        }\n      }\n      break;\n    }\n  }\n}", "target": 0}
{"code": "int hfsplus_find_cat(struct super_block *sb, u32 cnid,\n\t\t     struct hfs_find_data *fd)\n{\n\thfsplus_cat_entry tmp;\n\tint err;\n\tu16 type;\n\thfsplus_cat_build_key(sb, fd->search_key, cnid, NULL);\n\terr = hfs_brec_read(fd, &tmp, sizeof(hfsplus_cat_entry));\n\tif (err)\n\t\treturn err;\n\ttype = be16_to_cpu(tmp.type);\n\tif (type != HFSPLUS_FOLDER_THREAD && type != HFSPLUS_FILE_THREAD) {\n\t\tprintk(KERN_ERR \"hfs: found bad thread record in catalog\\n\");\n\t\treturn -EIO;\n\t}\n\thfsplus_cat_build_key_uni(fd->search_key, be32_to_cpu(tmp.thread.parentID),\n\t\t\t\t &tmp.thread.nodeName);\n\treturn hfs_brec_find(fd);\n}", "target": 1}
{"code": "  bool handleBackslash(signed char& out) {\n    char ch = *p++;\n    switch (ch) {\n      case 0: return false;\n      case '\"': out = ch; return true;\n      case '\\\\': out = ch; return true;\n      case '/': out = ch; return true;\n      case 'b': out = '\\b'; return true;\n      case 'f': out = '\\f'; return true;\n      case 'n': out = '\\n'; return true;\n      case 'r': out = '\\r'; return true;\n      case 't': out = '\\t'; return true;\n      case 'u': {\n        if (UNLIKELY(is_tsimplejson)) {\n          auto const ch1 = *p++;\n          auto const ch2 = *p++;\n          auto const dch3 = dehexchar(*p++);\n          auto const dch4 = dehexchar(*p++);\n          if (UNLIKELY(ch1 != '0' || ch2 != '0' || dch3 < 0 || dch4 < 0)) {\n            return false;\n          }\n          out = (dch3 << 4) | dch4;\n          return true;\n        } else {\n          uint16_t u16cp = 0;\n          for (int i = 0; i < 4; i++) {\n            auto const hexv = dehexchar(*p++);\n            if (hexv < 0) return false; \n            u16cp <<= 4;\n            u16cp |= hexv;\n          }\n          if (u16cp > 0x7f) {\n            return false;\n          } else {\n            out = u16cp;\n            return true;\n          }\n        }\n      }\n      default: return false;\n    }\n  }", "target": 1}
{"code": "static inline void switch_to_bitmap(unsigned long tifp)\n{\n\tif (tifp & _TIF_IO_BITMAP)\n\t\ttss_invalidate_io_bitmap(this_cpu_ptr(&cpu_tss_rw));\n}", "target": 1}
{"code": "GF_Box *mp4s_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGSampleEntryBox, GF_ISOM_BOX_TYPE_MP4S);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\ttmp->internal_type = GF_ISOM_SAMPLE_ENTRY_MP4S;\n\treturn (GF_Box *)tmp;\n}", "target": 1}
{"code": "static struct btrfs_device *find_device(struct btrfs_fs_devices *fs_devices,\n\t\tu64 devid, const u8 *uuid)\n{\n\tstruct btrfs_device *dev;\n\tlist_for_each_entry(dev, &fs_devices->devices, dev_list) {\n\t\tif (dev->devid == devid &&\n\t\t    (!uuid || !memcmp(dev->uuid, uuid, BTRFS_UUID_SIZE))) {\n\t\t\treturn dev;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "merged_2v_upsample(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n                   JDIMENSION *in_row_group_ctr,\n                   JDIMENSION in_row_groups_avail, JSAMPARRAY output_buf,\n                   JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)\n{\n  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n  JSAMPROW work_ptrs[2];\n  JDIMENSION num_rows;          \n  if (upsample->spare_full) {\n    JDIMENSION size = upsample->out_row_width;\n    if (cinfo->out_color_space == JCS_RGB565)\n      size = cinfo->output_width * 2;\n    jcopy_sample_rows(&upsample->spare_row, 0, output_buf + *out_row_ctr, 0, 1,\n                      size);\n    num_rows = 1;\n    upsample->spare_full = FALSE;\n  } else {\n    num_rows = 2;\n    if (num_rows > upsample->rows_to_go)\n      num_rows = upsample->rows_to_go;\n    out_rows_avail -= *out_row_ctr;\n    if (num_rows > out_rows_avail)\n      num_rows = out_rows_avail;\n    work_ptrs[0] = output_buf[*out_row_ctr];\n    if (num_rows > 1) {\n      work_ptrs[1] = output_buf[*out_row_ctr + 1];\n    } else {\n      work_ptrs[1] = upsample->spare_row;\n      upsample->spare_full = TRUE;\n    }\n    (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr, work_ptrs);\n  }\n  *out_row_ctr += num_rows;\n  upsample->rows_to_go -= num_rows;\n  if (!upsample->spare_full)\n    (*in_row_group_ctr)++;\n}", "target": 1}
{"code": "static int nl80211_dump_interface(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint wp_idx = 0;\n\tint if_idx = 0;\n\tint wp_start = cb->args[0];\n\tint if_start = cb->args[1];\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\tmutex_lock(&cfg80211_mutex);\n\tlist_for_each_entry(rdev, &cfg80211_rdev_list, list) {\n\t\tif (!net_eq(wiphy_net(&rdev->wiphy), sock_net(skb->sk)))\n\t\t\tcontinue;\n\t\tif (wp_idx < wp_start) {\n\t\t\twp_idx++;\n\t\t\tcontinue;\n\t\t}\n\t\tif_idx = 0;\n\t\tmutex_lock(&rdev->devlist_mtx);\n\t\tlist_for_each_entry(wdev, &rdev->wdev_list, list) {\n\t\t\tif (if_idx < if_start) {\n\t\t\t\tif_idx++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (nl80211_send_iface(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t       cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t\t       rdev, wdev) < 0) {\n\t\t\t\tmutex_unlock(&rdev->devlist_mtx);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif_idx++;\n\t\t}\n\t\tmutex_unlock(&rdev->devlist_mtx);\n\t\twp_idx++;\n\t}\n out:\n\tmutex_unlock(&cfg80211_mutex);\n\tcb->args[0] = wp_idx;\n\tcb->args[1] = if_idx;\n\treturn skb->len;\n}", "target": 0}
{"code": "void altivec_unavailable_exception(struct pt_regs *regs)\n{\n#if !defined(CONFIG_ALTIVEC)\n\tif (user_mode(regs)) {\n\t\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n\t\treturn;\n\t}\n#endif\n\tprintk(KERN_EMERG \"Unrecoverable VMX/Altivec Unavailable Exception \"\n\t\t\t\"%lx at %lx\\n\", regs->trap, regs->nip);\n\tdie(\"Unrecoverable VMX/Altivec Unavailable Exception\", regs, SIGABRT);\n}", "target": 1}
{"code": "TEST_F(QueryPlannerTest, NegatedRangeIntGTE) {\n    addIndex(BSON(\"i\" << 1));\n    runQuery(fromjson(\"{i: {$not: {$gte: 5}}}\"));\n    assertNumSolutions(2U);\n    assertSolutionExists(\"{cscan: {dir: 1}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: null, node: {ixscan: {pattern: {i:1}, \"\n        \"bounds: {i: [['MinKey',5,true,false], \"\n        \"[Infinity,'MaxKey',false,true]]}}}}}\");\n}", "target": 0}
{"code": "static bool io_wq_worker_affinity(struct io_worker *worker, void *data)\n{\n\tstruct online_data *od = data;\n\tif (od->online)\n\t\tcpumask_set_cpu(od->cpu, worker->wqe->cpu_mask);\n\telse\n\t\tcpumask_clear_cpu(od->cpu, worker->wqe->cpu_mask);\n\treturn false;\n}", "target": 0}
{"code": "decode_sequence(const uint8_t *asn1, size_t len, const struct seq_info *seq,\n                void *val)\n{\n    krb5_error_code ret;\n    const uint8_t *contents;\n    size_t i, j, clen;\n    taginfo t;\n    assert(seq->n_fields > 0);\n    for (i = 0; i < seq->n_fields; i++) {\n        if (len == 0)\n            break;\n        ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len);\n        if (ret)\n            goto error;\n        for (; i < seq->n_fields; i++) {\n            if (check_atype_tag(seq->fields[i], &t))\n                break;\n            ret = omit_atype(seq->fields[i], val);\n            if (ret)\n                goto error;\n        }\n        if (i == seq->n_fields)\n            break;\n        ret = decode_atype(&t, contents, clen, seq->fields[i], val);\n        if (ret)\n            goto error;\n    }\n    for (; i < seq->n_fields; i++) {\n        ret = omit_atype(seq->fields[i], val);\n        if (ret)\n            goto error;\n    }\n    return 0;\nerror:\n    for (j = 0; j < i; j++)\n        free_atype(seq->fields[j], val);\n    for (j = 0; j < i; j++)\n        free_atype_ptr(seq->fields[j], val);\n    return ret;\n}", "target": 1}
{"code": "create_llao(uint8_t *llao, uint8_t type)\n{\n  llao[UIP_ND6_OPT_TYPE_OFFSET] = type;\n  llao[UIP_ND6_OPT_LEN_OFFSET] = UIP_ND6_OPT_LLAO_LEN >> 3;\n  memcpy(&llao[UIP_ND6_OPT_DATA_OFFSET], &uip_lladdr, UIP_LLADDR_LEN);\n  memset(&llao[UIP_ND6_OPT_DATA_OFFSET + UIP_LLADDR_LEN], 0,\n         UIP_ND6_OPT_LLAO_LEN - 2 - UIP_LLADDR_LEN);\n}", "target": 0}
{"code": "hb_set_invert (hb_set_t *set)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n  set->invert ();\n}", "target": 1}
{"code": "static int sctp_setsockopt_auth_key(struct sock *sk,\n\t\t\t\t    char __user *optval,\n\t\t\t\t    int optlen)\n{\n\tstruct sctp_authkey *authkey;\n\tstruct sctp_association *asoc;\n\tint ret;\n\tif (!sctp_auth_enable)\n\t\treturn -EACCES;\n\tif (optlen <= sizeof(struct sctp_authkey))\n\t\treturn -EINVAL;\n\tauthkey = kmalloc(optlen, GFP_KERNEL);\n\tif (!authkey)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(authkey, optval, optlen)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\tasoc = sctp_id2assoc(sk, authkey->sca_assoc_id);\n\tif (!asoc && authkey->sca_assoc_id && sctp_style(sk, UDP)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = sctp_auth_set_key(sctp_sk(sk)->ep, asoc, authkey);\nout:\n\tkfree(authkey);\n\treturn ret;\n}", "target": 1}
{"code": "static int xar_hash_check(int hash, const void * result, const void * expected)\n{\n    int len;\n    if (!result || !expected)\n        return 1;\n    switch (hash) {\n    case XAR_CKSUM_SHA1:\n        len = SHA1_HASH_SIZE;\n        break;\n    case XAR_CKSUM_MD5:\n        len = CLI_HASH_MD5;\n        break;\n    case XAR_CKSUM_OTHER:\n    case XAR_CKSUM_NONE:\n    default:\n        return 1;\n    }\n    return memcmp(result, expected, len);\n}", "target": 1}
{"code": "static void tcp_send_challenge_ack(struct sock *sk, const struct sk_buff *skb)\n{\n\tstatic u32 challenge_timestamp;\n\tstatic unsigned int challenge_count;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 count, now;\n\tif (tcp_oow_rate_limited(sock_net(sk), skb,\n\t\t\t\t LINUX_MIB_TCPACKSKIPPEDCHALLENGE,\n\t\t\t\t &tp->last_oow_ack_time))\n\t\treturn;\n\tnow = jiffies / HZ;\n\tif (now != challenge_timestamp) {\n\t\tu32 half = (sysctl_tcp_challenge_ack_limit + 1) >> 1;\n\t\tchallenge_timestamp = now;\n\t\tWRITE_ONCE(challenge_count, half +\n\t\t\t   prandom_u32_max(sysctl_tcp_challenge_ack_limit));\n\t}\n\tcount = READ_ONCE(challenge_count);\n\tif (count > 0) {\n\t\tWRITE_ONCE(challenge_count, count - 1);\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPCHALLENGEACK);\n\t\ttcp_send_ack(sk);\n\t}\n}", "target": 0}
{"code": "            Status readCString( StringData* out ) {\n                const void* x = memchr( _buffer + _position, 0, _maxLength - _position );\n                if ( !x )\n                    return makeError(\"no end of c-string\", _idElem);\n                uint64_t len = static_cast<uint64_t>( static_cast<const char*>(x) - ( _buffer + _position ) );\n                StringData data( _buffer + _position, len );\n                _position += len + 1;\n                if ( out ) {\n                    *out = data;\n                }\n                return Status::OK();\n            }", "target": 0}
{"code": "static GList *player_list_metadata(struct avrcp_player *player)\n{\n\tGList *l, *attrs = NULL;\n\tif (player == NULL)\n\t\treturn g_list_prepend(NULL,\n\t\t\t\tGUINT_TO_POINTER(AVRCP_MEDIA_ATTRIBUTE_TITLE));\n\tl = player->cb->list_metadata(player->user_data);\n\tfor (; l; l = l->next) {\n\t\tconst char *key = l->data;\n\t\tattrs = g_list_append(attrs,\n\t\t\t\t\tGUINT_TO_POINTER(str_to_metadata(key)));\n\t}\n\treturn attrs;\n}", "target": 0}
{"code": "static void ip6_append_data_mtu(int *mtu,\n\t\t\t\tint *maxfraglen,\n\t\t\t\tunsigned int fragheaderlen,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tstruct rt6_info *rt)\n{\n\tif (!(rt->dst.flags & DST_XFRM_TUNNEL)) {\n\t\tif (skb == NULL) {\n\t\t\t*mtu = *mtu - rt->dst.header_len;\n\t\t} else {\n\t\t\t*mtu = dst_mtu(rt->dst.path);\n\t\t}\n\t\t*maxfraglen = ((*mtu - fragheaderlen) & ~7)\n\t\t\t      + fragheaderlen - sizeof(struct frag_hdr);\n\t}\n}", "target": 1}
{"code": "KeyInfo *sqlite3KeyInfoAlloc(sqlite3 *db, int N, int X){\n  int nExtra = (N+X)*(sizeof(CollSeq*)+1) - sizeof(CollSeq*);\n  KeyInfo *p = sqlite3DbMallocRawNN(db, sizeof(KeyInfo) + nExtra);\n  if( p ){\n    p->aSortFlags = (u8*)&p->aColl[N+X];\n    p->nKeyField = (u16)N;\n    p->nAllField = (u16)(N+X);\n    p->enc = ENC(db);\n    p->db = db;\n    p->nRef = 1;\n    memset(&p[1], 0, nExtra);\n  }else{\n    sqlite3OomFault(db);\n  }\n  return p;\n}", "target": 0}
{"code": "void Shell::DoInitialWorkspaceAnimation() {\n  return GetPrimaryRootWindowController()->workspace_controller()->\n      DoInitialAnimation();\n}", "target": 0}
{"code": "aspath_filter_exclude (struct aspath * source, struct aspath * exclude_list)\n{\n  struct assegment * srcseg, * exclseg, * lastseg;\n  struct aspath * newpath;\n  newpath = aspath_new();\n  lastseg = NULL;\n  for (srcseg = source->segments; srcseg; srcseg = srcseg->next)\n  {\n    unsigned i, y, newlen = 0, done = 0, skip_as;\n    struct assegment * newseg;\n    for (i = 0; i < srcseg->length; i++)\n    {\n      skip_as = 0;\n      for (exclseg = exclude_list->segments; exclseg && !skip_as; exclseg = exclseg->next)\n        for (y = 0; y < exclseg->length; y++)\n          if (srcseg->as[i] == exclseg->as[y])\n          {\n            skip_as = 1;\n            break;\n          }\n      if (!skip_as)\n        newlen++;\n    }\n    if (!newlen)\n      continue;\n    newseg = assegment_new (srcseg->type, newlen);\n    for (i = 0; i < srcseg->length; i++)\n    {\n      skip_as = 0;\n      for (exclseg = exclude_list->segments; exclseg && !skip_as; exclseg = exclseg->next)\n        for (y = 0; y < exclseg->length; y++)\n          if (srcseg->as[i] == exclseg->as[y])\n          {\n            skip_as = 1;\n            break;\n          }\n      if (skip_as)\n        continue;\n      newseg->as[done++] = srcseg->as[i];\n    }\n    if (!lastseg)\n      newpath->segments = newseg;\n    else\n      lastseg->next = newseg;\n    lastseg = newseg;\n  }\n  aspath_str_update (newpath);\n  aspath_free (source);\n  return newpath;\n}", "target": 0}
{"code": "bool IsBlacklistedArg(const base::CommandLine::CharType* arg) {\n#if defined(OS_WIN)\n  const auto converted = base::WideToUTF8(arg);\n  const char* a = converted.c_str();\n#else\n  const char* a = arg;\n#endif\n  static const char* prefixes[] = {\"--\", \"-\", \"/\"};\n  int prefix_length = 0;\n  for (auto& prefix : prefixes) {\n    if (base::StartsWith(a, prefix, base::CompareCase::SENSITIVE)) {\n      prefix_length = strlen(prefix);\n      break;\n    }\n  }\n  if (prefix_length > 0) {\n    a += prefix_length;\n    std::string switch_name(a, strcspn(a, \"=\"));\n    auto* iter = std::lower_bound(std::begin(kBlacklist), std::end(kBlacklist),\n                                  switch_name);\n    if (iter != std::end(kBlacklist) && switch_name == *iter) {\n      return true;\n    }\n  }\n  return false;\n}", "target": 1}
{"code": "static void fanout_release_data(struct packet_fanout *f)\n{\n\tswitch (f->type) {\n\tcase PACKET_FANOUT_CBPF:\n\tcase PACKET_FANOUT_EBPF:\n\t\t__fanout_set_data_bpf(f, NULL);\n\t};\n}", "target": 0}
{"code": "char *url_canonize2(char *d, char const * const s, size_t n,\n\t\t    unsigned syn33,\n\t\t    unsigned m32, unsigned m64, unsigned m96)\n{\n  size_t i = 0;\n  if (d == s)\n    for (;s[i] && i < n; d++, i++)\n      if (s[i] == '%')\n\tbreak;\n  for (;s[i] && i < n; d++, i++) {\n    unsigned char c = s[i], h1, h2;\n    if (c != '%') {\n      if (!IS_SYN33(syn33, c) && IS_EXCLUDED(c, m32, m64, m96))\n\treturn NULL;\n      *d = c;\n      continue;\n    }\n    h1 = s[i + 1];\n    if (!h1) {\n        *d = '\\0';\n        return NULL;\n    }\n    h2 = s[i + 2];\n    if (!IS_HEX(h1) || !IS_HEX(h2)) {\n      *d = '\\0';\n      return NULL;\n    }\n#define UNHEX(a) (a - (a >= 'a' ? 'a' - 10 : (a >= 'A' ? 'A' - 10 : '0')))\n    c = (UNHEX(h1) << 4) | UNHEX(h2);\n    if (!IS_EXCLUDED(c, m32, m64, m96)) {\n      *d = c, i += 2;\n      continue;\n    }\n    if (h1 >= 'a' )\n      h1 = h1 - 'a' + 'A';\n    if (h2 >= 'a' )\n      h2 = h2 - 'a' + 'A';\n    d[0] = '%', d[1] = h1, d[2] = h2;\n    d +=2, i += 2;\n#undef    UNHEX\n  }\n  *d = '\\0';\n  return d;\n}", "target": 0}
{"code": "set_num_712(unsigned char *p, char value)\n{\n\t*((char *)p) = value;\n}", "target": 0}
{"code": "cmsBool OpenOutput(const char* FileName)\n{\n\tOutFile = fopen(FileName, \"wb\");\n\tif (OutFile == NULL) {\n\t\tFatalError(\"Cannot create '%s'\", FileName);\n\t}\n\tCompressor.err                   = jpeg_std_error(&ErrorHandler.pub);\n\tErrorHandler.pub.error_exit      = my_error_exit;\n\tErrorHandler.pub.output_message  = my_error_exit;\n\tCompressor.input_components = Compressor.num_components = 4;\n\tjpeg_create_compress(&Compressor);\n\tjpeg_stdio_dest(&Compressor, OutFile);\n\treturn TRUE;\n}", "target": 0}
{"code": "static int xfrm_dump_sa(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_state_walk *walk = (struct xfrm_state_walk *) &cb->args[1];\n\tstruct xfrm_dump_info info;\n\tBUILD_BUG_ON(sizeof(struct xfrm_state_walk) >\n\t\t     sizeof(cb->args) - sizeof(cb->args[0]));\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\tif (!cb->args[0]) {\n\t\tstruct nlattr *attrs[XFRMA_MAX+1];\n\t\tstruct xfrm_address_filter *filter = NULL;\n\t\tu8 proto = 0;\n\t\tint err;\n\t\tcb->args[0] = 1;\n\t\terr = nlmsg_parse(cb->nlh, 0, attrs, XFRMA_MAX,\n\t\t\t\t  xfrma_policy);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (attrs[XFRMA_ADDRESS_FILTER]) {\n\t\t\tfilter = kmemdup(nla_data(attrs[XFRMA_ADDRESS_FILTER]),\n\t\t\t\t\t sizeof(*filter), GFP_KERNEL);\n\t\t\tif (filter == NULL)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (attrs[XFRMA_PROTO])\n\t\t\tproto = nla_get_u8(attrs[XFRMA_PROTO]);\n\t\txfrm_state_walk_init(walk, proto, filter);\n\t}\n\t(void) xfrm_state_walk(net, walk, dump_one_state, &info);\n\treturn skb->len;\n}", "target": 1}
{"code": "static int er_supported(ERContext *s)\n{\n    if(s->avctx->hwaccel && s->avctx->hwaccel->decode_slice           ||\n       !s->cur_pic.f                                                  ||\n       s->cur_pic.field_picture                                       ||\n       s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO\n    )\n        return 0;\n    return 1;\n}", "target": 1}
{"code": "httpd_compress(isc_httpd_t *httpd) {\n\tz_stream zstr;\n\tisc_region_t r;\n\tint ret;\n\tint inputlen;\n\tinputlen = isc_buffer_usedlength(&httpd->bodybuffer);\n\talloc_compspace(httpd, inputlen);\n\tisc_buffer_region(&httpd->compbuffer, &r);\n\tmemset(&zstr, 0, sizeof(zstr));\n\tzstr.total_in = zstr.avail_in = zstr.total_out = zstr.avail_out =\n\t\tinputlen;\n\tzstr.next_in = isc_buffer_base(&httpd->bodybuffer);\n\tzstr.next_out = r.base;\n\tret = deflateInit(&zstr, Z_DEFAULT_COMPRESSION);\n\tif (ret == Z_OK) {\n\t\tret = deflate(&zstr, Z_FINISH);\n\t}\n\tdeflateEnd(&zstr);\n\tif (ret == Z_STREAM_END) {\n\t\tisc_buffer_add(&httpd->compbuffer, inputlen - zstr.avail_out);\n\t\treturn (ISC_R_SUCCESS);\n\t} else {\n\t\treturn (ISC_R_FAILURE);\n\t}\n}", "target": 0}
{"code": "    void PsdImage::readMetadata()\n    {\n#ifdef DEBUG\n        std::cerr << \"Exiv2::PsdImage::readMetadata: Reading Photoshop file \" << io_->path() << \"\\n\";\n#endif\n        if (io_->open() != 0)\n        {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        if (!isPsdType(*io_, false))\n        {\n            if (io_->error() || io_->eof()) throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n        clearMetadata();\n        byte buf[26];\n        if (io_->read(buf, 26) != 26)\n        {\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n        pixelWidth_ = getLong(buf + 18, bigEndian);\n        pixelHeight_ = getLong(buf + 14, bigEndian);\n        if (io_->read(buf, 4) != 4)\n        {\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n        uint32_t colorDataLength = getULong(buf, bigEndian);\n        if (io_->seek(colorDataLength, BasicIo::cur))\n        {\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n        if (io_->read(buf, 4) != 4)\n        {\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n        uint32_t resourcesLength = getULong(buf, bigEndian);\n        while (resourcesLength > 0)\n        {\n            if (io_->read(buf, 8) != 8)\n            {\n                throw Error(kerNotAnImage, \"Photoshop\");\n            }\n            if (!Photoshop::isIrb(buf, 4))\n            {\n                break; \n            }\n            uint16_t resourceId = getUShort(buf + 4, bigEndian);\n            uint32_t resourceNameLength = buf[6] & ~1;\n            io_->seek(resourceNameLength, BasicIo::cur);\n            if (io_->read(buf, 4) != 4)\n            {\n                throw Error(kerNotAnImage, \"Photoshop\");\n            }\n            uint32_t resourceSize = getULong(buf, bigEndian);\n            uint32_t curOffset = io_->tell();\n#ifdef DEBUG\n        std::cerr << std::hex << \"resourceId: \" << resourceId << std::dec << \" length: \" << resourceSize << std::hex << \"\\n\";\n#endif\n            readResourceBlock(resourceId, resourceSize);\n            resourceSize = (resourceSize + 1) & ~1;        \n            io_->seek(curOffset + resourceSize, BasicIo::beg);\n            resourcesLength -= (12 + resourceNameLength + resourceSize);\n        }\n    } ", "target": 1}
{"code": "copy_ciphersuites(gnutls_session_t session,\n\t\t  gnutls_buffer_st * cdata, int add_scsv)\n{\n\tint ret;\n\tuint8_t cipher_suites[MAX_CIPHERSUITE_SIZE + 2]; \n\tint cipher_suites_size;\n\tsize_t init_length = cdata->length;\n\tret =\n\t    _gnutls_supported_ciphersuites(session, cipher_suites,\n\t\t\t\t\t   sizeof(cipher_suites) - 2);\n\tif (ret < 0)\n\t\treturn gnutls_assert_val(ret);\n\tret =\n\t    _gnutls_remove_unwanted_ciphersuites(session, cipher_suites,\n\t\t\t\t\t\t ret, NULL, 0);\n\tif (ret < 0)\n\t\treturn gnutls_assert_val(ret);\n\tif (ret == 0)\n\t\treturn\n\t\t    gnutls_assert_val(GNUTLS_E_INSUFFICIENT_CREDENTIALS);\n\tcipher_suites_size = ret;\n\tif (add_scsv) {\n\t\tcipher_suites[cipher_suites_size] = 0x00;\n\t\tcipher_suites[cipher_suites_size + 1] = 0xff;\n\t\tcipher_suites_size += 2;\n\t\tret = _gnutls_ext_sr_send_cs(session);\n\t\tif (ret < 0)\n\t\t\treturn gnutls_assert_val(ret);\n\t}\n\tret =\n\t    _gnutls_buffer_append_data_prefix(cdata, 16, cipher_suites,\n\t\t\t\t\t      cipher_suites_size);\n\tif (ret < 0)\n\t\treturn gnutls_assert_val(ret);\n\tret = cdata->length - init_length;\n\treturn ret;\n}", "target": 1}
{"code": "static int em_bsf(struct x86_emulate_ctxt *ctxt)\n{\n\tu8 zf;\n\t__asm__ (\"bsf %2, %0; setz %1\"\n\t\t : \"=r\"(ctxt->dst.val), \"=q\"(zf)\n\t\t : \"r\"(ctxt->src.val));\n\tctxt->eflags &= ~X86_EFLAGS_ZF;\n\tif (zf) {\n\t\tctxt->eflags |= X86_EFLAGS_ZF;\n\t\tctxt->dst.type = OP_NONE;\n\t}\n\treturn X86EMUL_CONTINUE;\n}", "target": 0}
{"code": "static int nfs4_open_recover_helper(struct nfs4_opendata *opendata, mode_t openflags, struct nfs4_state **res)\n{\n\tstruct nfs4_state *newstate;\n\tint ret;\n\topendata->o_arg.open_flags = openflags;\n\tmemset(&opendata->o_res, 0, sizeof(opendata->o_res));\n\tmemset(&opendata->c_res, 0, sizeof(opendata->c_res));\n\tnfs4_init_opendata_res(opendata);\n\tret = _nfs4_proc_open(opendata);\n\tif (ret != 0)\n\t\treturn ret; \n\tnewstate = nfs4_opendata_to_nfs4_state(opendata);\n\tif (IS_ERR(newstate))\n\t\treturn PTR_ERR(newstate);\n\tnfs4_close_state(&opendata->path, newstate, openflags);\n\t*res = newstate;\n\treturn 0;\n}", "target": 1}
{"code": "void ZlibInStream::removeUnderlying()\n{\n  ptr = end = start;\n  if (!underlying) return;\n  while (bytesIn > 0) {\n    decompress(true);\n    end = start; \n  }\n  underlying = 0;\n}", "target": 1}
{"code": "        std::string PngChunk::makeUtf8TxtChunk(const std::string& keyword, const std::string& text, bool compress)\n        {\n            std::string chunkData = keyword;\n            if (compress) {\n                static const char flags[] = {0x00, 0x01, 0x00, 0x00, 0x00};\n                chunkData += std::string(flags, 5) + zlibCompress(text);\n            } else {\n                static const char flags[] = {0x00, 0x00, 0x00, 0x00, 0x00};\n                chunkData += std::string(flags, 5) + text;\n            }\n            byte length[4];\n            ul2Data(length, static_cast<uint32_t>(chunkData.size()), bigEndian);\n            std::string chunkType = \"iTXt\";\n            std::string crcData = chunkType + chunkData;\n            uLong tmp = crc32(0L, Z_NULL, 0);\n            tmp = crc32(tmp, (const Bytef*)crcData.data(), static_cast<uInt>(crcData.size()));\n            byte crc[4];\n            ul2Data(crc, tmp, bigEndian);\n            return std::string((const char*)length, 4) + chunkType + chunkData + std::string((const char*)crc, 4);\n        }  ", "target": 0}
{"code": "nfssvc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_writeargs *args)\n{\n\tunsigned int len, hdr, dlen;\n\tstruct kvec *head = rqstp->rq_arg.head;\n\tint v;\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp++;\t\t\t\t\n\targs->offset = ntohl(*p++);\t\n\tp++;\t\t\t\t\n\tlen = args->len = ntohl(*p++);\n\tif (len > NFSSVC_MAXBLKSIZE_V2)\n\t\treturn 0;\n\thdr = (void*)p - head->iov_base;\n\tif (hdr > head->iov_len)\n\t\treturn 0;\n\tdlen = head->iov_len + rqstp->rq_arg.page_len - hdr;\n\tif (dlen < XDR_QUADLEN(len)*4)\n\t\treturn 0;\n\trqstp->rq_vec[0].iov_base = (void*)p;\n\trqstp->rq_vec[0].iov_len = head->iov_len - hdr;\n\tv = 0;\n\twhile (len > rqstp->rq_vec[v].iov_len) {\n\t\tlen -= rqstp->rq_vec[v].iov_len;\n\t\tv++;\n\t\trqstp->rq_vec[v].iov_base = page_address(rqstp->rq_pages[v]);\n\t\trqstp->rq_vec[v].iov_len = PAGE_SIZE;\n\t}\n\trqstp->rq_vec[v].iov_len = len;\n\targs->vlen = v + 1;\n\treturn 1;\n}", "target": 0}
{"code": "static int em_jmp_far(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tunsigned short sel, old_sel;\n\tstruct desc_struct old_desc, new_desc;\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tu8 cpl = ctxt->ops->cpl(ctxt);\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tops->get_segment(ctxt, &old_sel, &old_desc, NULL,\n\t\t\t\t VCPU_SREG_CS);\n\tmemcpy(&sel, ctxt->src.valptr + ctxt->op_bytes, 2);\n\trc = __load_segment_descriptor(ctxt, sel, VCPU_SREG_CS, cpl,\n\t\t\t\t       X86_TRANSFER_CALL_JMP,\n\t\t\t\t       &new_desc);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = assign_eip_far(ctxt, ctxt->src.val, &new_desc);\n\tif (rc != X86EMUL_CONTINUE) {\n\t\tWARN_ON(ctxt->mode != X86EMUL_MODE_PROT64);\n\t\tops->set_segment(ctxt, old_sel, &old_desc, 0, VCPU_SREG_CS);\n\t\treturn rc;\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "const char *who_am_i(void)\n{\n\tif (am_starting_up)\n\t\treturn am_server ? \"server\" : \"client\";\n\treturn am_sender ? \"sender\"\n\t     : am_generator ? \"generator\"\n\t     : am_receiver ? \"receiver\"\n\t     : \"Receiver\"; \n}", "target": 0}
{"code": "static int checkout_verify_paths(\n\tgit_repository *repo,\n\tint action,\n\tgit_diff_delta *delta)\n{\n\tunsigned int flags = GIT_PATH_REJECT_WORKDIR_DEFAULTS;\n\tif (action & CHECKOUT_ACTION__REMOVE) {\n\t\tif (!git_path_isvalid(repo, delta->old_file.path, delta->old_file.mode, flags)) {\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"cannot remove invalid path '%s'\", delta->old_file.path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (action & ~CHECKOUT_ACTION__REMOVE) {\n\t\tif (!git_path_isvalid(repo, delta->new_file.path, delta->new_file.mode, flags)) {\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"cannot checkout to invalid path '%s'\", delta->new_file.path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static void handleOutputMode(void* data, struct wl_output* wl_output, uint32_t flags, int32_t width, int32_t height, int32_t refresh) {\n    const auto POUTPUT = (SOutput*)data;\n    POUTPUT->refreshRate = std::round(refresh / 1000.0);\n}", "target": 1}
{"code": "clientHierarchical(ClientHttpRequest * http)\n{\n    HttpRequest *request = http->request;\n    HttpRequestMethod method = request->method;\n    if (!request->flags.hostVerified && (request->flags.intercepted || request->flags.interceptTproxy))\n        return 0;\n    if (request->flags.ims && !neighbors_do_private_keys)\n        return 0;\n    if (request->flags.auth)\n        return 0;\n    if (method == Http::METHOD_TRACE)\n        return 1;\n    if (method != Http::METHOD_GET)\n        return 0;\n    if (request->flags.loopDetected)\n        return 0;\n    if (request->url.getScheme() == AnyP::PROTO_HTTP)\n        return method.respMaybeCacheable();\n    if (request->url.getScheme() == AnyP::PROTO_GOPHER)\n        return gopherCachable(request);\n    if (request->url.getScheme() == AnyP::PROTO_CACHE_OBJECT)\n        return 0;\n    return 1;\n}", "target": 1}
{"code": "static void ram_block_add(struct uc_struct *uc, RAMBlock *new_block)\n{\n    RAMBlock *block;\n    RAMBlock *last_block = NULL;\n    new_block->offset = find_ram_offset(uc, new_block->max_length);\n    if (!new_block->host) {\n        new_block->host = phys_mem_alloc(uc, new_block->max_length,\n                &new_block->mr->align);\n        if (!new_block->host) {\n            return;\n        }\n    }\n    RAMBLOCK_FOREACH(block) {\n        last_block = block;\n        if (block->max_length < new_block->max_length) {\n            break;\n        }\n    }\n    if (block) {\n        QLIST_INSERT_BEFORE(block, new_block, next);\n    } else if (last_block) {\n        QLIST_INSERT_AFTER(last_block, new_block, next);\n    } else { \n        QLIST_INSERT_HEAD(&uc->ram_list.blocks, new_block, next);\n    }\n    uc->ram_list.mru_block = NULL;\n    cpu_physical_memory_set_dirty_range(new_block->offset,\n                                        new_block->used_length,\n                                        DIRTY_CLIENTS_ALL);\n}", "target": 1}
{"code": "static const char *findvararg (CallInfo *ci, int n, StkId *pos) {\n  if (clLvalue(s2v(ci->func))->p->is_vararg) {\n    int nextra = ci->u.l.nextraargs;\n    if (n <= nextra) {\n      *pos = ci->func - nextra + (n - 1);\n      return \"(vararg)\";  \n    }\n  }\n  return NULL;  \n}", "target": 1}
{"code": "void zsetConvertToZiplistIfNeeded(robj *zobj, size_t maxelelen) {\n    if (zobj->encoding == OBJ_ENCODING_ZIPLIST) return;\n    zset *zset = zobj->ptr;\n    if (zset->zsl->length <= server.zset_max_ziplist_entries &&\n        maxelelen <= server.zset_max_ziplist_value)\n            zsetConvert(zobj,OBJ_ENCODING_ZIPLIST);\n}", "target": 1}
{"code": "static int hardware_enable_all(void)\n{\n\tint r = 0;\n\traw_spin_lock(&kvm_lock);\n\tkvm_usage_count++;\n\tif (kvm_usage_count == 1) {\n\t\tatomic_set(&hardware_enable_failed, 0);\n\t\ton_each_cpu(hardware_enable_nolock, NULL, 1);\n\t\tif (atomic_read(&hardware_enable_failed)) {\n\t\t\thardware_disable_all_nolock();\n\t\t\tr = -EBUSY;\n\t\t}\n\t}\n\traw_spin_unlock(&kvm_lock);\n\treturn r;\n}", "target": 0}
{"code": "void ntlm_print_negotiate_flags(UINT32 flags)\n{\n\tint i;\n\tconst char* str;\n\tWLog_INFO(TAG, \"negotiateFlags \\\"0x%08\"PRIX32\"\\\"\", flags);\n\tfor (i = 31; i >= 0; i--)\n\t{\n\t\tif ((flags >> i) & 1)\n\t\t{\n\t\t\tstr = NTLM_NEGOTIATE_STRINGS[(31 - i)];\n\t\t\tWLog_INFO(TAG, \"\\t%s (%d),\", str, (31 - i));\n\t\t}\n\t}\n}", "target": 1}
{"code": "int options_parse(CONF_TYPE type) {\n    SERVICE_OPTIONS *section;\n    options_defaults();\n    section=&new_service_options;\n    if(options_file(configuration_file, type, &section))\n        return 1;\n    if(init_section(1, &section))\n        return 1;\n    s_log(LOG_NOTICE, \"Configuration successful\");\n    return 0;\n}", "target": 1}
{"code": "static inline void *packet_previous_frame(struct packet_sock *po,\n\t\tstruct packet_ring_buffer *rb,\n\t\tint status)\n{\n\tunsigned int previous = rb->head ? rb->head - 1 : rb->frame_max;\n\treturn packet_lookup_frame(po, rb, previous, status);\n}", "target": 0}
{"code": "void inet_sock_destruct(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\t__skb_queue_purge(&sk->sk_receive_queue);\n\t__skb_queue_purge(&sk->sk_error_queue);\n\tsk_mem_reclaim(sk);\n\tif (sk->sk_type == SOCK_STREAM && sk->sk_state != TCP_CLOSE) {\n\t\tpr_err(\"Attempt to release TCP socket in state %d %p\\n\",\n\t\t       sk->sk_state, sk);\n\t\treturn;\n\t}\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tpr_err(\"Attempt to release alive inet socket %p\\n\", sk);\n\t\treturn;\n\t}\n\tWARN_ON(atomic_read(&sk->sk_rmem_alloc));\n\tWARN_ON(atomic_read(&sk->sk_wmem_alloc));\n\tWARN_ON(sk->sk_wmem_queued);\n\tWARN_ON(sk->sk_forward_alloc);\n\tkfree(inet->opt);\n\tdst_release(rcu_dereference_check(sk->sk_dst_cache, 1));\n\tsk_refcnt_debug_dec(sk);\n}", "target": 1}
{"code": "static int host_start(struct ci13xxx *ci)\n{\n\tstruct usb_hcd *hcd;\n\tstruct ehci_hcd *ehci;\n\tint ret;\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\thcd = usb_create_hcd(&ci_ehci_hc_driver, ci->dev, dev_name(ci->dev));\n\tif (!hcd)\n\t\treturn -ENOMEM;\n\tdev_set_drvdata(ci->dev, ci);\n\thcd->rsrc_start = ci->hw_bank.phys;\n\thcd->rsrc_len = ci->hw_bank.size;\n\thcd->regs = ci->hw_bank.abs;\n\thcd->has_tt = 1;\n\thcd->power_budget = ci->platdata->power_budget;\n\thcd->phy = ci->transceiver;\n\tehci = hcd_to_ehci(hcd);\n\tehci->caps = ci->hw_bank.cap;\n\tehci->has_hostpc = ci->hw_bank.lpm;\n\tret = usb_add_hcd(hcd, 0, 0);\n\tif (ret)\n\t\tusb_put_hcd(hcd);\n\telse\n\t\tci->hcd = hcd;\n\tif (ci->platdata->flags & CI13XXX_DISABLE_STREAMING)\n\t\thw_write(ci, OP_USBMODE, USBMODE_CI_SDIS, USBMODE_CI_SDIS);\n\treturn ret;\n}", "target": 0}
{"code": "static void WritePackbitsLength(const PSDInfo *psd_info,\n  const ImageInfo *image_info,Image *image,Image *next_image,\n  unsigned char *compact_pixels,const QuantumType quantum_type,\n  ExceptionInfo *exception)\n{\n  QuantumInfo\n    *quantum_info;\n  register const Quantum\n    *p;\n  size_t\n    length,\n    packet_size;\n  ssize_t\n    y;\n  unsigned char\n    *pixels;\n  if (next_image->depth > 8)\n    next_image->depth=16;\n  packet_size=next_image->depth > 8UL ? 2UL : 1UL;\n  (void) packet_size;\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n  for (y=0; y < (ssize_t) next_image->rows; y++)\n  {\n    p=GetVirtualPixels(next_image,0,y,next_image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    length=ExportQuantumPixels(next_image,(CacheView *) NULL,quantum_info,\n      quantum_type,pixels,exception);\n    length=PSDPackbitsEncodeImage(image,length,pixels,compact_pixels,\n      exception);\n    (void) SetPSDOffset(psd_info,image,length);\n  }\n  quantum_info=DestroyQuantumInfo(quantum_info);\n}", "target": 0}
{"code": "static int sc_pkcs15emu_sc_hsm_add_dcod(sc_pkcs15_card_t * p15card, u8 id) {\n\tsc_card_t *card = p15card->card;\n\tsc_pkcs15_data_info_t *data_info;\n\tsc_pkcs15_object_t data_obj;\n\tu8 fid[2];\n\tu8 efbin[512];\n\tconst u8 *ptr;\n\tsize_t len;\n\tint r;\n\tfid[0] = DCOD_PREFIX;\n\tfid[1] = id;\n\tlen = sizeof efbin;\n\tr = read_file(p15card, fid, efbin, &len, 1);\n\tLOG_TEST_RET(card->ctx, r, \"Skipping optional EF.DCOD\");\n\tptr = efbin;\n\tmemset(&data_obj, 0, sizeof(data_obj));\n\tr = sc_pkcs15_decode_dodf_entry(p15card, &data_obj, &ptr, &len);\n\tLOG_TEST_RET(card->ctx, r, \"Could not decode optional EF.DCOD\");\n\tdata_info = (sc_pkcs15_data_info_t *)data_obj.data;\n\tr = sc_pkcs15emu_add_data_object(p15card, &data_obj, data_info);\n\tLOG_TEST_RET(card->ctx, r, \"Could not add data object to framework\");\n\treturn SC_SUCCESS;\n}", "target": 0}
{"code": "static void jpc_undo_roi(jas_matrix_t *x, int roishift, int bgshift, int numbps)\n{\n\tint i;\n\tint j;\n\tint thresh;\n\tjpc_fix_t val;\n\tjpc_fix_t mag;\n\tbool warn;\n\tuint_fast32_t mask;\n\tif (roishift == 0 && bgshift == 0) {\n\t\treturn;\n\t}\n\tthresh = 1 << roishift;\n\twarn = false;\n\tfor (i = 0; i < jas_matrix_numrows(x); ++i) {\n\t\tfor (j = 0; j < jas_matrix_numcols(x); ++j) {\n\t\t\tval = jas_matrix_get(x, i, j);\n\t\t\tmag = JAS_ABS(val);\n\t\t\tif (mag >= thresh) {\n\t\t\t\tmag >>= roishift;\n\t\t\t\tval = (val < 0) ? (-mag) : mag;\n\t\t\t\tjas_matrix_set(x, i, j, val);\n\t\t\t} else {\n\t\t\t\tmag <<= bgshift;\n\t\t\t\tmask = (1 << numbps) - 1;\n\t\t\t\tif (mag & (~mask)) {\n\t\t\t\t\tif (!warn) {\n\t\t\t\t\t\tjas_eprintf(\"warning: possibly corrupt code stream\\n\");\n\t\t\t\t\t\twarn = true;\n\t\t\t\t\t}\n\t\t\t\t\tmag &= mask;\n\t\t\t\t}\n\t\t\t\tval = (val < 0) ? (-mag) : mag;\n\t\t\t\tjas_matrix_set(x, i, j, val);\n\t\t\t}\n\t\t}\n\t}\n}", "target": 0}
{"code": "struct nft_flow_rule *nft_flow_rule_create(struct net *net,\n\t\t\t\t\t   const struct nft_rule *rule)\n{\n\tstruct nft_offload_ctx *ctx;\n\tstruct nft_flow_rule *flow;\n\tint num_actions = 0, err;\n\tstruct nft_expr *expr;\n\texpr = nft_expr_first(rule);\n\twhile (nft_expr_more(rule, expr)) {\n\t\tif (expr->ops->offload_flags & NFT_OFFLOAD_F_ACTION)\n\t\t\tnum_actions++;\n\t\texpr = nft_expr_next(expr);\n\t}\n\tif (num_actions == 0)\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\tflow = nft_flow_rule_alloc(num_actions);\n\tif (!flow)\n\t\treturn ERR_PTR(-ENOMEM);\n\texpr = nft_expr_first(rule);\n\tctx = kzalloc(sizeof(struct nft_offload_ctx), GFP_KERNEL);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\tctx->net = net;\n\tctx->dep.type = NFT_OFFLOAD_DEP_UNSPEC;\n\twhile (nft_expr_more(rule, expr)) {\n\t\tif (!expr->ops->offload) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err_out;\n\t\t}\n\t\terr = expr->ops->offload(ctx, flow, expr);\n\t\tif (err < 0)\n\t\t\tgoto err_out;\n\t\texpr = nft_expr_next(expr);\n\t}\n\tnft_flow_rule_transfer_vlan(ctx, flow);\n\tflow->proto = ctx->dep.l3num;\n\tkfree(ctx);\n\treturn flow;\nerr_out:\n\tkfree(ctx);\n\tnft_flow_rule_destroy(flow);\n\treturn ERR_PTR(err);\n}", "target": 1}
{"code": "cdf_read_sector(const cdf_info_t *info, void *buf, size_t offs, size_t len,\n    const cdf_header_t *h, cdf_secid_t id)\n{\n\tassert((size_t)CDF_SEC_SIZE(h) == len);\n\treturn cdf_read(info, (off_t)CDF_SEC_POS(h, id),\n\t    ((char *)buf) + offs, len);\n}", "target": 1}
{"code": "bool OmniboxViewWin::IsCommandIdChecked(int command_id) const {\n  return false;\n}", "target": 0}
{"code": "MODULE_ENTRY (fill_vtable) (GdkPixbufModule *module)\n{\n\tmodule->begin_load = gdk_pixbuf__bmp_image_begin_load;\n\tmodule->stop_load = gdk_pixbuf__bmp_image_stop_load;\n\tmodule->load_increment = gdk_pixbuf__bmp_image_load_increment;\n\tmodule->save = gdk_pixbuf__bmp_image_save;\n\tmodule->save_to_callback = gdk_pixbuf__bmp_image_save_to_callback;\n}", "target": 0}
{"code": "static void perf_event_comm_event(struct perf_comm_event *comm_event)\n{\n\tstruct perf_cpu_context *cpuctx;\n\tstruct perf_event_context *ctx;\n\tchar comm[TASK_COMM_LEN];\n\tunsigned int size;\n\tstruct pmu *pmu;\n\tint ctxn;\n\tmemset(comm, 0, sizeof(comm));\n\tstrlcpy(comm, comm_event->task->comm, sizeof(comm));\n\tsize = ALIGN(strlen(comm)+1, sizeof(u64));\n\tcomm_event->comm = comm;\n\tcomm_event->comm_size = size;\n\tcomm_event->event_id.header.size = sizeof(comm_event->event_id) + size;\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pmu, &pmus, entry) {\n\t\tcpuctx = get_cpu_ptr(pmu->pmu_cpu_context);\n\t\tif (cpuctx->unique_pmu != pmu)\n\t\t\tgoto next;\n\t\tperf_event_comm_ctx(&cpuctx->ctx, comm_event);\n\t\tctxn = pmu->task_ctx_nr;\n\t\tif (ctxn < 0)\n\t\t\tgoto next;\n\t\tctx = rcu_dereference(current->perf_event_ctxp[ctxn]);\n\t\tif (ctx)\n\t\t\tperf_event_comm_ctx(ctx, comm_event);\nnext:\n\t\tput_cpu_ptr(pmu->pmu_cpu_context);\n\t}\n\trcu_read_unlock();\n}", "target": 0}
{"code": "uint16_t read16(uint8_t* arr, int pos,  int swapBytes)\n{\n    uint8_t b1 = arr[pos];\n    uint8_t b2 = arr[pos+1];\n    return (swapBytes) ?  ((b2 << 8) | b1) : ((b1 << 8) | b2);\n}", "target": 0}
{"code": "static struct nfs4_state *nfs4_try_open_cached(struct nfs4_opendata *opendata)\n{\n\tstruct nfs4_state *state = opendata->state;\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tstruct nfs_delegation *delegation;\n\tint open_mode = opendata->o_arg.open_flags & (FMODE_READ|FMODE_WRITE|O_EXCL);\n\tnfs4_stateid stateid;\n\tint ret = -EAGAIN;\n\tfor (;;) {\n\t\tif (can_open_cached(state, open_mode)) {\n\t\t\tspin_lock(&state->owner->so_lock);\n\t\t\tif (can_open_cached(state, open_mode)) {\n\t\t\t\tupdate_open_stateflags(state, open_mode);\n\t\t\t\tspin_unlock(&state->owner->so_lock);\n\t\t\t\tgoto out_return_state;\n\t\t\t}\n\t\t\tspin_unlock(&state->owner->so_lock);\n\t\t}\n\t\trcu_read_lock();\n\t\tdelegation = rcu_dereference(nfsi->delegation);\n\t\tif (delegation == NULL ||\n\t\t    !can_open_delegated(delegation, open_mode)) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(stateid.data, delegation->stateid.data, sizeof(stateid.data));\n\t\trcu_read_unlock();\n\t\tret = nfs_may_open(state->inode, state->owner->so_cred, open_mode);\n\t\tif (ret != 0)\n\t\t\tgoto out;\n\t\tret = -EAGAIN;\n\t\tif (update_open_stateid(state, NULL, &stateid, open_mode))\n\t\t\tgoto out_return_state;\n\t}\nout:\n\treturn ERR_PTR(ret);\nout_return_state:\n\tatomic_inc(&state->count);\n\treturn state;\n}", "target": 1}
{"code": "bool Item_singlerow_subselect::fix_length_and_dec()\n{\n  if ((max_columns= engine->cols()) == 1)\n  {\n    if (engine->fix_length_and_dec(row= &value))\n      return TRUE;\n  }\n  else\n  {\n    if (!(row= (Item_cache**) current_thd->alloc(sizeof(Item_cache*) *\n                                                 max_columns)) ||\n        engine->fix_length_and_dec(row))\n      return TRUE;\n    value= *row;\n  }\n  unsigned_flag= value->unsigned_flag;\n  if (engine->no_tables())\n    maybe_null= engine->may_be_null();\n  else\n  {\n    for (uint i= 0; i < max_columns; i++)\n      row[i]->maybe_null= TRUE;\n  }\n  return FALSE;\n}", "target": 1}
{"code": "bool sctp_verify_asconf(const struct sctp_association *asoc,\n\t\t\tstruct sctp_chunk *chunk, bool addr_param_needed,\n\t\t\tstruct sctp_paramhdr **errp)\n{\n\tsctp_addip_chunk_t *addip = (sctp_addip_chunk_t *) chunk->chunk_hdr;\n\tunion sctp_params param;\n\tbool addr_param_seen = false;\n\tsctp_walk_params(param, addip, addip_hdr.params) {\n\t\tsize_t length = ntohs(param.p->length);\n\t\t*errp = param.p;\n\t\tswitch (param.p->type) {\n\t\tcase SCTP_PARAM_ERR_CAUSE:\n\t\t\tbreak;\n\t\tcase SCTP_PARAM_IPV4_ADDRESS:\n\t\t\tif (length != sizeof(sctp_ipv4addr_param_t))\n\t\t\t\treturn false;\n\t\t\taddr_param_seen = true;\n\t\t\tbreak;\n\t\tcase SCTP_PARAM_IPV6_ADDRESS:\n\t\t\tif (length != sizeof(sctp_ipv6addr_param_t))\n\t\t\t\treturn false;\n\t\t\taddr_param_seen = true;\n\t\t\tbreak;\n\t\tcase SCTP_PARAM_ADD_IP:\n\t\tcase SCTP_PARAM_DEL_IP:\n\t\tcase SCTP_PARAM_SET_PRIMARY:\n\t\t\tif (addr_param_needed && !addr_param_seen)\n\t\t\t\treturn false;\n\t\t\tlength = ntohs(param.addip->param_hdr.length);\n\t\t\tif (length < sizeof(sctp_addip_param_t) +\n\t\t\t\t     sizeof(sctp_paramhdr_t))\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tcase SCTP_PARAM_SUCCESS_REPORT:\n\t\tcase SCTP_PARAM_ADAPTATION_LAYER_IND:\n\t\t\tif (length != sizeof(sctp_addip_param_t))\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (addr_param_needed && !addr_param_seen)\n\t\treturn false;\n\tif (!addr_param_needed && addr_param_seen)\n\t\treturn false;\n\tif (param.v != chunk->chunk_end)\n\t\treturn false;\n\treturn true;\n}", "target": 0}
{"code": "int bson_check_field_name( bson *b, const char *string,\n                           const int length ) {\n    return bson_validate_string( b, ( const unsigned char * )string, length, 1, 1, 1 );\n}", "target": 1}
{"code": "void traverse_commit_list(struct rev_info *revs,\n\t\t\t  show_commit_fn show_commit,\n\t\t\t  show_object_fn show_object,\n\t\t\t  void *data)\n{\n\tint i;\n\tstruct commit *commit;\n\tstruct strbuf base;\n\tstrbuf_init(&base, PATH_MAX);\n\twhile ((commit = get_revision(revs)) != NULL) {\n\t\tif (commit->tree)\n\t\t\tadd_pending_tree(revs, commit->tree);\n\t\tshow_commit(commit, data);\n\t}\n\tfor (i = 0; i < revs->pending.nr; i++) {\n\t\tstruct object_array_entry *pending = revs->pending.objects + i;\n\t\tstruct object *obj = pending->item;\n\t\tconst char *name = pending->name;\n\t\tconst char *path = pending->path;\n\t\tif (obj->flags & (UNINTERESTING | SEEN))\n\t\t\tcontinue;\n\t\tif (obj->type == OBJ_TAG) {\n\t\t\tobj->flags |= SEEN;\n\t\t\tshow_object(obj, NULL, name, data);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!path)\n\t\t\tpath = \"\";\n\t\tif (obj->type == OBJ_TREE) {\n\t\t\tprocess_tree(revs, (struct tree *)obj, show_object,\n\t\t\t\t     &base, path, data);\n\t\t\tcontinue;\n\t\t}\n\t\tif (obj->type == OBJ_BLOB) {\n\t\t\tprocess_blob(revs, (struct blob *)obj, show_object,\n\t\t\t\t     NULL, path, data);\n\t\t\tcontinue;\n\t\t}\n\t\tdie(\"unknown pending object %s (%s)\",\n\t\t    oid_to_hex(&obj->oid), name);\n\t}\n\tobject_array_clear(&revs->pending);\n\tstrbuf_release(&base);\n}", "target": 1}
{"code": "void set_task_comm(struct task_struct *tsk, char *buf)\n{\n\ttask_lock(tsk);\n\tstrlcpy(tsk->comm, buf, sizeof(tsk->comm));\n\ttask_unlock(tsk);\n}", "target": 0}
{"code": "check_packet_auth(NTP_Packet *pkt, int length, int *has_auth, uint32_t *key_id)\n{\n  int i, remainder, ext_length;\n  unsigned char *data;\n  uint32_t id;\n  i = NTP_NORMAL_PACKET_LENGTH;\n  data = (void *)pkt;\n  while (1) {\n    remainder = length - i;\n    if (remainder >= NTP_MIN_MAC_LENGTH && remainder <= NTP_MAX_MAC_LENGTH) {\n      id = ntohl(*(uint32_t *)(data + i));\n      if (KEY_CheckAuth(id, (void *)pkt, i, (void *)(data + i + 4),\n                        remainder - 4)) {\n        if (key_id)\n          *key_id = id;\n        if (has_auth)\n          *has_auth = 1;\n        return 1;\n      }\n    }\n    if (remainder >= NTP_MIN_EXTENSION_LENGTH) {\n      ext_length = ntohs(*(uint16_t *)(data + i + 2));\n      if (ext_length >= NTP_MIN_EXTENSION_LENGTH &&\n          ext_length <= remainder && ext_length % 4 == 0) {\n        i += ext_length;\n        continue;\n      }\n    }\n    break;\n  }\n  if (has_auth)\n    *has_auth = remainder >= NTP_MIN_MAC_LENGTH;\n  return 0;\n}", "target": 0}
{"code": "ext4_xattr_cache_insert(struct mb_cache *ext4_mb_cache, struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(BHDR(bh)->h_hash);\n\tstruct mb_cache_entry *ce;\n\tint error;\n\tce = mb_cache_entry_alloc(ext4_mb_cache, GFP_NOFS);\n\tif (!ce) {\n\t\tea_bdebug(bh, \"out of memory\");\n\t\treturn;\n\t}\n\terror = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);\n\tif (error) {\n\t\tmb_cache_entry_free(ce);\n\t\tif (error == -EBUSY) {\n\t\t\tea_bdebug(bh, \"already in cache\");\n\t\t\terror = 0;\n\t\t}\n\t} else {\n\t\tea_bdebug(bh, \"inserting [%x]\", (int)hash);\n\t\tmb_cache_entry_release(ce);\n\t}\n}", "target": 1}
{"code": "compat_sys_writev(unsigned long fd, const struct compat_iovec __user *vec, unsigned long vlen)\n{\n\tstruct file *file;\n\tssize_t ret = -EBADF;\n\tfile = fget(fd);\n\tif (!file)\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\tgoto out;\n\tret = -EINVAL;\n\tif (!file->f_op || (!file->f_op->aio_write && !file->f_op->write))\n\t\tgoto out;\n\tret = compat_do_readv_writev(WRITE, file, vec, vlen, &file->f_pos);\nout:\n\tfput(file);\n\treturn ret;\n}", "target": 0}
{"code": "void InstanceKlass::set_package(ClassLoaderData* loader_data, PackageEntry* pkg_entry, TRAPS) {\n  if (!is_shared()) {\n    check_prohibited_package(name(), loader_data, CHECK);\n  }\n  if (is_shared() && _package_entry != NULL) {\n    if (MetaspaceShared::use_full_module_graph() && _package_entry == pkg_entry) {\n      assert(MetaspaceShared::is_in_shared_metaspace(_package_entry), \"must be\");\n      return;\n    } else {\n      _package_entry = NULL;\n    }\n  }\n  TempNewSymbol from_class_name =\n      (pkg_entry != NULL) ? NULL : ClassLoader::package_from_class_name(name());\n  Symbol* pkg_name;\n  if (pkg_entry != NULL) {\n    pkg_name = pkg_entry->name();\n  } else {\n    pkg_name = from_class_name;\n  }\n  if (pkg_name != NULL && loader_data != NULL) {\n    _package_entry = pkg_entry != NULL ? pkg_entry : loader_data->packages()->lookup_only(pkg_name);\n    if (_package_entry == NULL) {\n      if (!ModuleEntryTable::javabase_defined()) {\n        assert(ModuleEntryTable::javabase_moduleEntry() != NULL, JAVA_BASE_NAME \" module is NULL\");\n        _package_entry = loader_data->packages()->lookup(pkg_name, ModuleEntryTable::javabase_moduleEntry());\n      } else {\n        assert(loader_data->unnamed_module() != NULL, \"unnamed module is NULL\");\n        _package_entry = loader_data->packages()->lookup(pkg_name,\n                                                         loader_data->unnamed_module());\n      }\n      DEBUG_ONLY(ResourceMark rm(THREAD));\n      assert(_package_entry != NULL, \"Package entry for class %s not found, loader %s\",\n             name()->as_C_string(), loader_data->loader_name_and_id());\n    }\n    if (log_is_enabled(Debug, module)) {\n      ResourceMark rm(THREAD);\n      ModuleEntry* m = _package_entry->module();\n      log_trace(module)(\"Setting package: class: %s, package: %s, loader: %s, module: %s\",\n                        external_name(),\n                        pkg_name->as_C_string(),\n                        loader_data->loader_name_and_id(),\n                        (m->is_named() ? m->name()->as_C_string() : UNNAMED_MODULE));\n    }\n  } else {\n    ResourceMark rm(THREAD);\n    log_trace(module)(\"Setting package: class: %s, package: unnamed, loader: %s, module: %s\",\n                      external_name(),\n                      (loader_data != NULL) ? loader_data->loader_name_and_id() : \"NULL\",\n                      UNNAMED_MODULE);\n  }\n}", "target": 0}
{"code": "static void n_tty_close(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tif (tty->link)\n\t\tn_tty_packet_mode_flush(tty);\n\tvfree(ldata);\n\ttty->disc_data = NULL;\n}", "target": 0}
{"code": "do_sched_setscheduler(pid_t pid, int policy, struct sched_param __user *param)\n{\n\tstruct sched_param lparam;\n\tstruct task_struct *p;\n\tint retval;\n\tif (!param || pid < 0)\n\t\treturn -EINVAL;\n\tif (copy_from_user(&lparam, param, sizeof(struct sched_param)))\n\t\treturn -EFAULT;\n\trcu_read_lock();\n\tretval = -ESRCH;\n\tp = find_process_by_pid(pid);\n\tif (p != NULL)\n\t\tretval = sched_setscheduler(p, policy, &lparam);\n\trcu_read_unlock();\n\treturn retval;\n}", "target": 0}
{"code": "void dtls1_reset_seq_numbers(SSL *s, int rw)\n{\n    unsigned char *seq;\n    unsigned int seq_bytes = sizeof(s->s3->read_sequence);\n    if (rw & SSL3_CC_READ) {\n        seq = s->s3->read_sequence;\n        s->d1->r_epoch++;\n        memcpy(&(s->d1->bitmap), &(s->d1->next_bitmap), sizeof(DTLS1_BITMAP));\n        memset(&(s->d1->next_bitmap), 0x00, sizeof(DTLS1_BITMAP));\n    } else {\n        seq = s->s3->write_sequence;\n        memcpy(s->d1->last_write_sequence, seq,\n               sizeof(s->s3->write_sequence));\n        s->d1->w_epoch++;\n    }\n    memset(seq, 0x00, seq_bytes);\n}", "target": 1}
{"code": "    PreviewImage::PreviewImage(const PreviewImage& rhs)\n    {\n        properties_ = rhs.properties_;\n        pData_ = new byte[rhs.size_];\n        memcpy(pData_, rhs.pData_, rhs.size_);\n        size_ = rhs.size_;\n    }", "target": 0}
{"code": "decode_string(CBORDecoderObject *self, uint8_t subtype)\n{\n    uint64_t length = 0;\n    bool indefinite = true;\n    PyObject *ret;\n    char length_hex[17];\n    if (decode_length(self, subtype, &length, &indefinite) == -1)\n        return NULL;\n    if (length > (uint64_t)PY_SSIZE_T_MAX - (uint64_t)PyBytesObject_SIZE) {\n        sprintf(length_hex, \"%llX\", length);\n        PyErr_Format(\n                _CBOR2_CBORDecodeValueError,\n                \"excessive string size 0x%s\", length_hex);\n        return NULL;\n    }\n    if (indefinite)\n        ret = decode_indefinite_strings(self);\n    else\n        ret = decode_definite_string(self, (Py_ssize_t)length);\n    set_shareable(self, ret);\n    return ret;\n}", "target": 1}
{"code": "static int zipfileComparePath(const char *zA, const char *zB, int nB){\n  int nA = (int)strlen(zA);\n  if( zA[nA-1]=='/' ) nA--;\n  if( zB[nB-1]=='/' ) nB--;\n  if( nA==nB && memcmp(zA, zB, nA)==0 ) return 0;\n  return 1;\n}", "target": 0}
{"code": "static void php_snmp_error(zval *object, const char *docref, int type, const char *format, ...)\n{\n\tva_list args;\n\tphp_snmp_object *snmp_object = NULL;\n\tif (object) {\n\t\tsnmp_object = Z_SNMP_P(object);\n\t\tif (type == PHP_SNMP_ERRNO_NOERROR) {\n\t\t\tmemset(snmp_object->snmp_errstr, 0, sizeof(snmp_object->snmp_errstr));\n\t\t} else {\n\t\t\tva_start(args, format);\n\t\t\tvsnprintf(snmp_object->snmp_errstr, sizeof(snmp_object->snmp_errstr) - 1, format, args);\n\t\t\tva_end(args);\n\t\t}\n\t\tsnmp_object->snmp_errno = type;\n\t}\n\tif (type == PHP_SNMP_ERRNO_NOERROR) {\n\t\treturn;\n        }\n        if (object && (snmp_object->exceptions_enabled & type)) {\n               zend_throw_exception_ex(php_snmp_exception_ce, type, snmp_object->snmp_errstr);\n        } else {\n                va_start(args, format);\n                php_verror(docref, \"\", E_WARNING, format, args);\n\t\tva_end(args);\n\t}\n}", "target": 1}
{"code": "service_info *FindServiceEventURLPath(\n\tservice_table *table, const char *eventURLPath)\n{\n\tservice_info *finger = NULL;\n\turi_type parsed_url;\n\turi_type parsed_url_in;\n\tif (table &&\n\t\tparse_uri(eventURLPath, strlen(eventURLPath), &parsed_url_in) ==\n\t\t\tHTTP_SUCCESS) {\n\t\tfinger = table->serviceList;\n\t\twhile (finger) {\n\t\t\tif (finger->eventURL) {\n\t\t\t\tif (parse_uri(finger->eventURL,\n\t\t\t\t\t    strlen(finger->eventURL),\n\t\t\t\t\t    &parsed_url) == HTTP_SUCCESS) {\n\t\t\t\t\tif (!token_cmp(&parsed_url.pathquery,\n\t\t\t\t\t\t    &parsed_url_in.pathquery)) {\n\t\t\t\t\t\treturn finger;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinger = finger->next;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "static gboolean udscs_server_accept_cb(GSocketService    *service,\n                                       GSocketConnection *socket_conn,\n                                       GObject           *source_object,\n                                       gpointer           user_data)\n{\n    struct udscs_server *server = user_data;\n    UdscsConnection *new_conn;\n    new_conn = g_object_new(UDSCS_TYPE_CONNECTION, NULL);\n    new_conn->debug = server->debug;\n    new_conn->read_callback = server->read_callback;\n    g_object_ref(socket_conn);\n    vdagent_connection_setup(VDAGENT_CONNECTION(new_conn),\n                             G_IO_STREAM(socket_conn),\n                             FALSE,\n                             sizeof(struct udscs_message_header),\n                             server->error_cb);\n    server->connections = g_list_prepend(server->connections, new_conn);\n    if (server->debug)\n        syslog(LOG_DEBUG, \"new client accepted: %p\", new_conn);\n    if (server->connect_callback)\n        server->connect_callback(new_conn);\n    return TRUE;\n}", "target": 1}
{"code": "void undefer_input(__G)\n    __GDEF\n{\n    if (G.incnt > 0)\n        G.csize += G.incnt;\n    if (G.incnt_leftover > 0) {\n        G.incnt = G.incnt_leftover + (int)G.csize;\n        G.inptr = G.inptr_leftover - (int)G.csize;\n        G.incnt_leftover = 0;\n    } else if (G.incnt < 0)\n        G.incnt = 0;\n} ", "target": 1}
{"code": "void RequestContext::SetApiKeyHeader() {\n  request_->AddHeaderToBackend(kDefaultApiKeyHeaderName, api_key_);\n}", "target": 1}
{"code": "spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n\t\t       int iov_count)\n{\n    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,\n\t\t\t   iov_count);\n}", "target": 1}
{"code": "accept_ice_connection (GIOChannel           *source,\n                       GIOCondition          condition,\n                       GsmIceConnectionData *data)\n{\n        IceListenObj    listener;\n        IceConn         ice_conn;\n        IceAcceptStatus status;\n        GsmClient      *client;\n        GsmXsmpServer  *server;\n        listener = data->listener;\n        server = data->server;\n        g_debug (\"GsmXsmpServer: accept_ice_connection()\");\n        ice_conn = IceAcceptConnection (listener, &status);\n        if (status != IceAcceptSuccess) {\n                g_debug (\"GsmXsmpServer: IceAcceptConnection returned %d\", status);\n                return TRUE;\n        }\n        client = gsm_xsmp_client_new (ice_conn);\n        ice_conn->context = client;\n        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));\n        g_object_unref (client);\n        return TRUE;\n}", "target": 1}
{"code": "static int dbConnect(char *host, char *user, char *passwd)\n{\n  DBUG_ENTER(\"dbConnect\");\n  if (verbose)\n  {\n    fprintf(stderr, \"# Connecting to %s...\\n\", host ? host : \"localhost\");\n  }\n  mysql_init(&mysql_connection);\n  if (opt_compress)\n    mysql_options(&mysql_connection, MYSQL_OPT_COMPRESS, NullS);\n#ifdef HAVE_OPENSSL\n  if (opt_use_ssl)\n  {\n    mysql_ssl_set(&mysql_connection, opt_ssl_key, opt_ssl_cert, opt_ssl_ca,\n\t\t  opt_ssl_capath, opt_ssl_cipher);\n    mysql_options(&mysql_connection, MYSQL_OPT_SSL_CRL, opt_ssl_crl);\n    mysql_options(&mysql_connection, MYSQL_OPT_SSL_CRLPATH, opt_ssl_crlpath);\n  }\n#endif\n  if (opt_protocol)\n    mysql_options(&mysql_connection,MYSQL_OPT_PROTOCOL,(char*)&opt_protocol);\n  if (opt_bind_addr)\n    mysql_options(&mysql_connection, MYSQL_OPT_BIND, opt_bind_addr);\n#if defined (_WIN32) && !defined (EMBEDDED_LIBRARY)\n  if (shared_memory_base_name)\n    mysql_options(&mysql_connection,MYSQL_SHARED_MEMORY_BASE_NAME,shared_memory_base_name);\n#endif\n  if (opt_plugin_dir && *opt_plugin_dir)\n    mysql_options(&mysql_connection, MYSQL_PLUGIN_DIR, opt_plugin_dir);\n  if (opt_default_auth && *opt_default_auth)\n    mysql_options(&mysql_connection, MYSQL_DEFAULT_AUTH, opt_default_auth);\n  mysql_options(&mysql_connection, MYSQL_SET_CHARSET_NAME, default_charset);\n  mysql_options(&mysql_connection, MYSQL_OPT_CONNECT_ATTR_RESET, 0);\n  mysql_options4(&mysql_connection, MYSQL_OPT_CONNECT_ATTR_ADD,\n                 \"program_name\", \"mysqlcheck\");\n  if (!(sock = mysql_real_connect(&mysql_connection, host, user, passwd,\n         NULL, opt_mysql_port, opt_mysql_unix_port, 0)))\n  {\n    DBerror(&mysql_connection, \"when trying to connect\");\n    DBUG_RETURN(1);\n  }\n  mysql_connection.reconnect= 1;\n  DBUG_RETURN(0);\n} ", "target": 1}
{"code": "static void cp2112_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tunsigned long flags;\n\tint ret;\n\tspin_lock_irqsave(&dev->lock, flags);\n\tbuf[0] = CP2112_GPIO_SET;\n\tbuf[1] = value ? 0xff : 0;\n\tbuf[2] = 1 << offset;\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_SET, buf,\n\t\t\t\t CP2112_GPIO_SET_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0)\n\t\thid_err(hdev, \"error setting GPIO values: %d\\n\", ret);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n}", "target": 1}
{"code": "  const uint8_t *getBytecode(uint32_t) const override {\n    llvm_unreachable(\"Accessing bytecode from a lazy module\");\n  }", "target": 1}
{"code": "void jsP_dumpsyntax(js_State *J, js_Ast *prog, int dominify)\n{\n\tminify = dominify;\n\tif (prog->type == AST_LIST)\n\t\tpstmlist(-1, prog);\n\telse {\n\t\tpstm(0, prog);\n\t\tnl();\n\t}\n\tif (minify > 1)\n\t\tputchar('\\n');\n}", "target": 1}
{"code": "static int fscrypt_d_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct dentry *dir;\n\tstruct fscrypt_info *ci;\n\tint dir_has_key, cached_with_key;\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\tdir = dget_parent(dentry);\n\tif (!d_inode(dir)->i_sb->s_cop->is_encrypted(d_inode(dir))) {\n\t\tdput(dir);\n\t\treturn 0;\n\t}\n\tci = d_inode(dir)->i_crypt_info;\n\tif (ci && ci->ci_keyring_key &&\n\t    (ci->ci_keyring_key->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t\t\t  (1 << KEY_FLAG_REVOKED) |\n\t\t\t\t\t  (1 << KEY_FLAG_DEAD))))\n\t\tci = NULL;\n\tspin_lock(&dentry->d_lock);\n\tcached_with_key = dentry->d_flags & DCACHE_ENCRYPTED_WITH_KEY;\n\tspin_unlock(&dentry->d_lock);\n\tdir_has_key = (ci != NULL);\n\tdput(dir);\n\tif ((!cached_with_key && d_is_negative(dentry)) ||\n\t\t\t(!cached_with_key && dir_has_key) ||\n\t\t\t(cached_with_key && !dir_has_key))\n\t\treturn 0;\n\treturn 1;\n}", "target": 1}
{"code": "static inline bool xfs_bmap_wants_extents(struct xfs_inode *ip, int whichfork)\n{\n\treturn whichfork != XFS_COW_FORK &&\n\t\tXFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE &&\n\t\tXFS_IFORK_NEXTENTS(ip, whichfork) <=\n\t\t\tXFS_IFORK_MAXEXT(ip, whichfork);\n}", "target": 0}
{"code": "sysServices_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  snmp_api_set_time_ticks(varbind, oid, clock_seconds() * 100);\n}", "target": 1}
{"code": "static void handle_irq_for_port(evtchn_port_t port)\n{\n\tint irq;\n\tirq = get_evtchn_to_irq(port);\n\tif (irq != -1)\n\t\tgeneric_handle_irq(irq);\n}", "target": 1}
{"code": "static inline pgd_t *pgd_alloc(struct mm_struct *mm)\n{\n\tspin_lock_init(&mm->context.list_lock);\n\tINIT_LIST_HEAD(&mm->context.pgtable_list);\n\tINIT_LIST_HEAD(&mm->context.gmap_list);\n\treturn (pgd_t *) crst_table_alloc(mm);\n}", "target": 1}
{"code": "static void __reg_deduce_bounds(struct bpf_reg_state *reg)\n{\n\t__reg32_deduce_bounds(reg);\n\t__reg64_deduce_bounds(reg);\n}", "target": 0}
{"code": "int posix_cpu_clock_get(const clockid_t which_clock, struct timespec *tp)\n{\n\tconst pid_t pid = CPUCLOCK_PID(which_clock);\n\tint error = -EINVAL;\n\tunion cpu_time_count rtn;\n\tif (pid == 0) {\n\t\tif (CPUCLOCK_PERTHREAD(which_clock)) {\n\t\t\terror = cpu_clock_sample(which_clock,\n\t\t\t\t\t\t current, &rtn);\n\t\t} else {\n\t\t\tread_lock(&tasklist_lock);\n\t\t\terror = cpu_clock_sample_group(which_clock,\n\t\t\t\t\t\t       current, &rtn);\n\t\t\tread_unlock(&tasklist_lock);\n\t\t}\n\t} else {\n\t\tstruct task_struct *p;\n\t\trcu_read_lock();\n\t\tp = find_task_by_vpid(pid);\n\t\tif (p) {\n\t\t\tif (CPUCLOCK_PERTHREAD(which_clock)) {\n\t\t\t\tif (same_thread_group(p, current)) {\n\t\t\t\t\terror = cpu_clock_sample(which_clock,\n\t\t\t\t\t\t\t\t p, &rtn);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tread_lock(&tasklist_lock);\n\t\t\t\tif (thread_group_leader(p) && p->signal) {\n\t\t\t\t\terror =\n\t\t\t\t\t    cpu_clock_sample_group(which_clock,\n\t\t\t\t\t\t\t           p, &rtn);\n\t\t\t\t}\n\t\t\t\tread_unlock(&tasklist_lock);\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\tif (error)\n\t\treturn error;\n\tsample_to_timespec(which_clock, rtn, tp);\n\treturn 0;\n}", "target": 0}
{"code": "MemoryRegion *memory_map(struct uc_struct *uc, hwaddr begin, size_t size, uint32_t perms)\n{\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n    memory_region_init_ram(uc, ram, size, perms);\n    if (ram->addr == -1) {\n        return NULL;\n    }\n    memory_region_add_subregion(uc->system_memory, begin, ram);\n    if (uc->cpu) {\n        tlb_flush(uc->cpu);\n    }\n    return ram;\n}", "target": 1}
{"code": "unsigned long ossl_lh_strcasehash(const char *c)\n{\n    unsigned long ret = 0;\n    long n;\n    unsigned long v;\n    int r;\n    if (c == NULL || *c == '\\0')\n        return ret;\n    for (n = 0x100; *c != '\\0'; n += 0x100) {\n        v = n | ossl_tolower(*c);\n        r = (int)((v >> 2) ^ v) & 0x0f;\n        ret = (ret << r) | (unsigned long)((uint64_t)ret >> (32 - r));\n        ret &= 0xFFFFFFFFL;\n        ret ^= v * v;\n        c++;\n    }\n    return (ret >> 16) ^ ret;\n}", "target": 0}
{"code": "  static bool TryParse(const char* inp, int length,\n                       TypedValue* buf, Variant& out,\n                       JSONContainerType container_type, bool is_tsimplejson) {\n    SimpleParser parser(inp, length, buf, container_type, is_tsimplejson);\n    bool ok = parser.parseValue();\n    parser.skipSpace();\n    if (!ok || parser.p != inp + length) {\n      tvDecRefRange(buf, parser.top);\n      return false;\n    }\n    out = Variant::attach(*--parser.top);\n    return true;\n  }", "target": 1}
{"code": "static gint conv_sjistoeuc(gchar *outbuf, gint outlen, const gchar *inbuf)\n{\n\tconst guchar *in = inbuf;\n\tguchar *out = outbuf;\n\twhile (*in != '\\0') {\n\t\tif (IS_ASCII(*in)) {\n\t\t\t*out++ = *in++;\n\t\t} else if (issjiskanji1(*in)) {\n\t\t\tif (issjiskanji2(*(in + 1))) {\n\t\t\t\tguchar out1 = *in;\n\t\t\t\tguchar out2 = *(in + 1);\n\t\t\t\tguchar row;\n\t\t\t\trow = out1 < 0xa0 ? 0x70 : 0xb0;\n\t\t\t\tif (out2 < 0x9f) {\n\t\t\t\t\tout1 = (out1 - row) * 2 - 1;\n\t\t\t\t\tout2 -= out2 > 0x7f ? 0x20 : 0x1f;\n\t\t\t\t} else {\n\t\t\t\t\tout1 = (out1 - row) * 2;\n\t\t\t\t\tout2 -= 0x7e;\n\t\t\t\t}\n\t\t\t\t*out++ = out1 | 0x80;\n\t\t\t\t*out++ = out2 | 0x80;\n\t\t\t\tin += 2;\n\t\t\t} else {\n\t\t\t\t*out++ = SUBST_CHAR;\n\t\t\t\tin++;\n\t\t\t\tif (*in != '\\0' && !IS_ASCII(*in)) {\n\t\t\t\t\t*out++ = SUBST_CHAR;\n\t\t\t\t\tin++;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (issjishwkana(*in)) {\n\t\t\t*out++ = 0x8e;\n\t\t\t*out++ = *in++;\n\t\t} else {\n\t\t\t*out++ = SUBST_CHAR;\n\t\t\tin++;\n\t\t}\n\t}\n\t*out = '\\0';\n\treturn 0;\n}", "target": 1}
{"code": "gmtime_r(const time_t *t, struct tm *tm)\n{\n    auto struct tm *tmp = gmtime(t);\n    if (tmp)\n\t*tm = *tmp;\n    return tmp;\n}", "target": 0}
{"code": "static void compact(VarEnv* v, Array &ret, const Variant& var) {\n  if (var.isArray()) {\n    for (ArrayIter iter(var.getArrayData()); iter; ++iter) {\n      compact(v, ret, iter.second());\n    }\n  } else {\n    String varname = var.toString();\n    if (!varname.empty() && v->lookup(varname.get()) != NULL) {\n      ret.set(varname, *reinterpret_cast<Variant*>(v->lookup(varname.get())));\n    }\n  }\n}", "target": 1}
{"code": "static SCSIRequest *scsi_new_request(SCSIDevice *d, uint32_t tag,\n                                     uint32_t lun, void *hba_private)\n{\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);\n    SCSIRequest *req;\n    SCSIDiskReq *r;\n    req = scsi_req_alloc(&scsi_disk_reqops, &s->qdev, tag, lun, hba_private);\n    r = DO_UPCAST(SCSIDiskReq, req, req);\n    r->iov.iov_base = qemu_blockalign(s->bs, SCSI_DMA_BUF_SIZE);\n    return req;\n}", "target": 1}
{"code": "void RemoteFrame::ScheduleNavigation(Document& origin_document,\n                                      const KURL& url,\n                                      WebFrameLoadType frame_load_type,\n                                      UserGestureStatus user_gesture_status) {\n   FrameLoadRequest frame_request(&origin_document, ResourceRequest(url));\n   frame_request.GetResourceRequest().SetHasUserGesture(\n       user_gesture_status == UserGestureStatus::kActive);\n  frame_request.GetResourceRequest().SetFrameType(\n      IsMainFrame() ? network::mojom::RequestContextFrameType::kTopLevel\n                    : network::mojom::RequestContextFrameType::kNested);\n  Navigate(frame_request, frame_load_type);\n}", "target": 1}
{"code": "static int getSingletonPos(const char* str)\n{\n\tint result =-1;\n\tint i=0;\n\tint len = 0;\n\tif( str && ((len=strlen(str))>0) ){\n\t\tfor( i=0; i<len ; i++){\n\t\t\tif( isIDSeparator(*(str+i)) ){\n\t\t\t\tif( i==1){\n\t\t\t\t\tresult =0;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tif( isIDSeparator(*(str+i+2)) ){\n\t\t\t\t\t\tresult = i+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "target": 1}
{"code": "compile_length_string_raw_node(StrNode* sn, regex_t* reg)\n{\n  if (sn->end <= sn->s)\n    return 0;\n  return add_compile_string_length(sn->s, 1 , sn->end - sn->s, reg, 0);\n}", "target": 0}
{"code": "static inline void var_push(php_unserialize_data_t *var_hashx, zval *rval)\n{\n\tvar_entries *var_hash = (*var_hashx)->last;\n#if VAR_ENTRIES_DBG\n\tfprintf(stderr, \"var_push(%ld): %d\\n\", var_hash?var_hash->used_slots:-1L, Z_TYPE_P(rval));\n#endif\n\tif (!var_hash || var_hash->used_slots == VAR_ENTRIES_MAX) {\n\t\tvar_hash = emalloc(sizeof(var_entries));\n\t\tvar_hash->used_slots = 0;\n\t\tvar_hash->next = 0;\n\t\tif (!(*var_hashx)->first) {\n\t\t\t(*var_hashx)->first = var_hash;\n\t\t} else {\n\t\t\t((var_entries *) (*var_hashx)->last)->next = var_hash;\n\t\t}\n\t\t(*var_hashx)->last = var_hash;\n\t}\n\tvar_hash->data[var_hash->used_slots++] = rval;\n}", "target": 0}
{"code": "pad_compress_skb(struct ppp *ppp, struct sk_buff *skb)\n{\n\tstruct sk_buff *new_skb;\n\tint len;\n\tint new_skb_size = ppp->dev->mtu +\n\t\tppp->xcomp->comp_extra + ppp->dev->hard_header_len;\n\tint compressor_skb_size = ppp->dev->mtu +\n\t\tppp->xcomp->comp_extra + PPP_HDRLEN;\n\tnew_skb = alloc_skb(new_skb_size, GFP_ATOMIC);\n\tif (!new_skb) {\n\t\tif (net_ratelimit())\n\t\t\tprintk(KERN_ERR \"PPP: no memory (comp pkt)\\n\");\n\t\treturn NULL;\n\t}\n\tif (ppp->dev->hard_header_len > PPP_HDRLEN)\n\t\tskb_reserve(new_skb,\n\t\t\t    ppp->dev->hard_header_len - PPP_HDRLEN);\n\tlen = ppp->xcomp->compress(ppp->xc_state, skb->data - 2,\n\t\t\t\t   new_skb->data, skb->len + 2,\n\t\t\t\t   compressor_skb_size);\n\tif (len > 0 && (ppp->flags & SC_CCP_UP)) {\n\t\tkfree_skb(skb);\n\t\tskb = new_skb;\n\t\tskb_put(skb, len);\n\t\tskb_pull(skb, 2);\t\n\t} else if (len == 0) {\n\t\tkfree_skb(new_skb);\n\t\tnew_skb = skb;\n\t} else {\n\t\tif (net_ratelimit())\n\t\t\tprintk(KERN_ERR \"ppp: compressor dropped pkt\\n\");\n\t\tkfree_skb(skb);\n\t\tkfree_skb(new_skb);\n\t\tnew_skb = NULL;\n\t}\n\treturn new_skb;\n}", "target": 0}
{"code": "stl_update_connects_remove_1(stl_file *stl, int facet_num) {\n  int j;\n  if (stl->error) return;\n  j = ((stl->neighbors_start[facet_num].neighbor[0] == -1) +\n       (stl->neighbors_start[facet_num].neighbor[1] == -1) +\n       (stl->neighbors_start[facet_num].neighbor[2] == -1));\n  if(j == 0) {\t\t       \n    stl->stats.connected_facets_3_edge -= 1;\n  } else if(j == 1) {\t     \n    stl->stats.connected_facets_2_edge -= 1;\n  } else if(j == 2) {\t     \n    stl->stats.connected_facets_1_edge -= 1;\n  }\n}", "target": 1}
{"code": "void Context::onUpstreamConnectionClose(PeerType peer_type) {\n  if (wasm_->onUpstreamConnectionClose_) {\n    wasm_->onUpstreamConnectionClose_(this, id_, static_cast<uint32_t>(peer_type));\n  }\n}", "target": 1}
{"code": "AP4_AvccAtom::AP4_AvccAtom(AP4_UI32 size, const AP4_UI08* payload) :\n    AP4_Atom(AP4_ATOM_TYPE_AVCC, size)\n{\n    unsigned int payload_size = size-AP4_ATOM_HEADER_SIZE;\n    m_RawBytes.SetData(payload, payload_size);\n    m_ConfigurationVersion = payload[0];\n    m_Profile              = payload[1];\n    m_ProfileCompatibility = payload[2];\n    m_Level                = payload[3];\n    m_NaluLengthSize       = 1+(payload[4]&3);\n    AP4_UI08 num_seq_params = payload[5]&31;\n    m_SequenceParameters.EnsureCapacity(num_seq_params);\n    unsigned int cursor = 6;\n    for (unsigned int i=0; i<num_seq_params; i++) {\n        m_SequenceParameters.Append(AP4_DataBuffer());\n        AP4_UI16 param_length = AP4_BytesToInt16BE(&payload[cursor]);\n        m_SequenceParameters[i].SetData(&payload[cursor]+2, param_length);\n        cursor += 2+param_length;\n    }\n    AP4_UI08 num_pic_params = payload[cursor++];\n    m_PictureParameters.EnsureCapacity(num_pic_params);\n    for (unsigned int i=0; i<num_pic_params; i++) {\n        m_PictureParameters.Append(AP4_DataBuffer());\n        AP4_UI16 param_length = AP4_BytesToInt16BE(&payload[cursor]);\n        m_PictureParameters[i].SetData(&payload[cursor]+2, param_length);\n        cursor += 2+param_length;\n    }\n}", "target": 1}
{"code": "void dtls1_stop_timer(SSL *s)\n{\n    memset(&(s->d1->timeout), 0, sizeof(struct dtls1_timeout_st));\n    memset(&(s->d1->next_timeout), 0, sizeof(struct timeval));\n    s->d1->timeout_duration = 1;\n    BIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT, 0,\n             &(s->d1->next_timeout));\n    dtls1_clear_record_buffer(s);\n}", "target": 0}
{"code": "process_colour_pointer_common(STREAM s, int bpp)\n{\n\tuint16 width, height, cache_idx, masklen, datalen;\n\tuint16 x, y;\n\tuint8 *mask;\n\tuint8 *data;\n\tRD_HCURSOR cursor;\n\tin_uint16_le(s, cache_idx);\n\tin_uint16_le(s, x);\n\tin_uint16_le(s, y);\n\tin_uint16_le(s, width);\n\tin_uint16_le(s, height);\n\tin_uint16_le(s, masklen);\n\tin_uint16_le(s, datalen);\n\tin_uint8p(s, data, datalen);\n\tin_uint8p(s, mask, masklen);\n\tif ((width != 32) || (height != 32))\n\t{\n\t\twarning(\"process_colour_pointer_common: \" \"width %d height %d\\n\", width, height);\n\t}\n\tx = MIN(x, width - 1);\n\ty = MIN(y, height - 1);\n\tcursor = ui_create_cursor(x, y, width, height, mask, data, bpp);\n\tui_set_cursor(cursor);\n\tcache_put_cursor(cache_idx, cursor);\n}", "target": 0}
{"code": "int touch(const char *path) {\n        return touch_file(path, false, USEC_INFINITY, UID_INVALID, GID_INVALID, 0);\n}", "target": 1}
{"code": "vg_resource_attach_backing(VuGpu *g,\n                           struct virtio_gpu_ctrl_command *cmd)\n{\n    struct virtio_gpu_simple_resource *res;\n    struct virtio_gpu_resource_attach_backing ab;\n    int ret;\n    VUGPU_FILL_CMD(ab);\n    virtio_gpu_bswap_32(&ab, sizeof(ab));\n    res = virtio_gpu_find_resource(g, ab.resource_id);\n    if (!res) {\n        g_critical(\"%s: illegal resource specified %d\",\n                   __func__, ab.resource_id);\n        cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID;\n        return;\n    }\n    if (res->iov) {\n        cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;\n        return;\n    }\n    ret = vg_create_mapping_iov(g, &ab, cmd, &res->iov);\n    if (ret != 0) {\n        cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;\n        return;\n    }\n    res->iov_cnt = ab.nr_entries;\n}", "target": 0}
{"code": "void __blk_mq_tag_idle(struct blk_mq_hw_ctx *hctx)\n{\n\tstruct blk_mq_tags *tags = hctx->tags;\n\tif (!test_and_clear_bit(BLK_MQ_S_TAG_ACTIVE, &hctx->state))\n\t\treturn;\n\tatomic_dec(&tags->active_queues);\n\tblk_mq_tag_wakeup_all(tags, false);\n}", "target": 0}
{"code": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\tif (inode_capable(inode, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}", "target": 1}
{"code": "void gf_isom_check_position(GF_Box *s, GF_Box *child, u32 *pos)\n{\n\tif (!s || !s->child_boxes || !child || !pos) return;\n\tif (s->internal_flags & GF_ISOM_ORDER_FREEZE)\n\t\treturn;\n\ts32 cur_pos = gf_list_find(s->child_boxes, child);\n\tif (cur_pos < 0) return;\n\tif (cur_pos != (s32) *pos) {\n\t\tgf_list_del_item(s->child_boxes, child);\n\t\tgf_list_insert(s->child_boxes, child, *pos);\n\t}\n\t(*pos)++;", "target": 1}
{"code": "std::string CanonicalizeHost(const std::wstring& host,\n                             url_canon::CanonHostInfo* host_info) {\n  std::string converted_host;\n  WideToUTF8(host.c_str(), host.length(), &converted_host);\n  return CanonicalizeHost(converted_host, host_info);\n}", "target": 0}
{"code": "static inline void nft_reg_store64(u32 *dreg, u64 val)\n{\n\tput_unaligned(val, (u64 *)dreg);\n}", "target": 1}
{"code": "int nfc_enable_se(struct nfc_dev *dev, u32 se_idx)\n{\n\tstruct nfc_se *se;\n\tint rc;\n\tpr_debug(\"%s se index %d\\n\", dev_name(&dev->dev), se_idx);\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (!dev->dev_up) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->polling) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\tif (!dev->ops->enable_se || !dev->ops->disable_se) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto error;\n\t}\n\tse = nfc_find_se(dev, se_idx);\n\tif (!se) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\tif (se->state == NFC_SE_ENABLED) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\trc = dev->ops->enable_se(dev, se_idx);\n\tif (rc >= 0)\n\t\tse->state = NFC_SE_ENABLED;\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "deltas_head_init(struct deltas_head *list)\n{\n\tlist->array = NULL;\n\tlist->len = 0;\n\tlist->capacity = 0;\n}", "target": 1}
{"code": "static int crypto_skcipher_init_tfm(struct crypto_tfm *tfm)\n{\n\tstruct crypto_skcipher *skcipher = __crypto_skcipher_cast(tfm);\n\tstruct skcipher_alg *alg = crypto_skcipher_alg(skcipher);\n\tif (tfm->__crt_alg->cra_type == &crypto_blkcipher_type)\n\t\treturn crypto_init_skcipher_ops_blkcipher(tfm);\n\tif (tfm->__crt_alg->cra_type == &crypto_ablkcipher_type ||\n\t    tfm->__crt_alg->cra_type == &crypto_givcipher_type)\n\t\treturn crypto_init_skcipher_ops_ablkcipher(tfm);\n\tskcipher->setkey = alg->setkey;\n\tskcipher->encrypt = alg->encrypt;\n\tskcipher->decrypt = alg->decrypt;\n\tskcipher->ivsize = alg->ivsize;\n\tskcipher->keysize = alg->max_keysize;\n\tif (alg->exit)\n\t\tskcipher->base.exit = crypto_skcipher_exit_tfm;\n\tif (alg->init)\n\t\treturn alg->init(skcipher);\n\treturn 0;\n}", "target": 1}
{"code": "static int atusb_read_reg(struct atusb *atusb, uint8_t reg)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tint ret;\n\tuint8_t value;\n\tdev_dbg(&usb_dev->dev, \"atusb: reg = 0x%x\\n\", reg);\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_REG_READ, ATUSB_REQ_FROM_DEV,\n\t\t\t\t0, reg, &value, 1, 1000);\n\treturn ret >= 0 ? value : ret;\n}", "target": 1}
{"code": "void CScreencopyPortal::queueNextShareFrame(CScreencopyPortal::SSession* pSession) {\n    const auto PSTREAM = m_pPipewire->streamFromSession(pSession);\n    if (PSTREAM && !PSTREAM->streamState)\n        return;\n    const auto FRAMETOOKMS           = std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::system_clock::now() - pSession->sharingData.begunFrame).count() / 1000.0;\n    const auto MSTILNEXTREFRESH      = 1000.0 / (pSession->sharingData.framerate) - FRAMETOOKMS;\n    pSession->sharingData.begunFrame = std::chrono::system_clock::now();\n    Debug::log(TRACE, \"[screencopy] set fps {}, frame took {:.2f}ms, ms till next refresh {:.2f}, estimated actual fps: {:.2f}\", pSession->sharingData.framerate, FRAMETOOKMS,\n               MSTILNEXTREFRESH, std::clamp(1000.0 / FRAMETOOKMS, 1.0, (double)pSession->sharingData.framerate));\n    g_pPortalManager->addTimer({std::clamp(MSTILNEXTREFRESH - 1.0 , 6.0, 1000.0), [pSession]() { g_pPortalManager->m_sPortals.screencopy->startFrameCopy(pSession); }});\n}", "target": 1}
{"code": "static BOOL update_gdi_mem3blt(rdpContext* context, MEM3BLT_ORDER* mem3blt)\n{\n\tBYTE style;\n\trdpBitmap* bitmap;\n\trdpCache* cache = context->cache;\n\trdpBrush* brush = &mem3blt->brush;\n\tBOOL ret = TRUE;\n\tif (mem3blt->cacheId == 0xFF)\n\t\tbitmap = offscreen_cache_get(cache->offscreen, mem3blt->cacheIndex);\n\telse\n\t\tbitmap = bitmap_cache_get(cache->bitmap, (BYTE)mem3blt->cacheId, mem3blt->cacheIndex);\n\tif (!bitmap)\n\t\treturn TRUE;\n\tstyle = brush->style;\n\tif (brush->style & CACHED_BRUSH)\n\t{\n\t\tbrush->data = brush_cache_get(cache->brush, brush->index, &brush->bpp);\n\t\tif (!brush->data)\n\t\t\treturn FALSE;\n\t\tbrush->style = 0x03;\n\t}\n\tmem3blt->bitmap = bitmap;\n\tIFCALLRET(cache->bitmap->Mem3Blt, ret, context, mem3blt);\n\tbrush->style = style;\n\treturn ret;\n}", "target": 0}
{"code": "int prepareForShutdown() {\n    redisLog(REDIS_WARNING,\"User requested shutdown, saving DB...\");\n    if (server.bgsavechildpid != -1) {\n        redisLog(REDIS_WARNING,\"There is a live saving child. Killing it!\");\n        kill(server.bgsavechildpid,SIGKILL);\n        rdbRemoveTempFile(server.bgsavechildpid);\n    }\n    if (server.appendonly) {\n        aof_fsync(server.appendfd);\n        if (server.vm_enabled) unlink(server.vm_swap_file);\n    } else if (server.saveparamslen > 0) {\n        if (rdbSave(server.dbfilename) != REDIS_OK) {\n            redisLog(REDIS_WARNING,\"Error trying to save the DB, can't exit\");\n            return REDIS_ERR;\n        }\n    } else {\n        redisLog(REDIS_WARNING,\"Not saving DB.\");\n    }\n    if (server.daemonize) unlink(server.pidfile);\n    redisLog(REDIS_WARNING,\"Server exit now, bye bye...\");\n    return REDIS_OK;\n}", "target": 1}
{"code": "struct bpf_prog *bpf_patch_insn_single(struct bpf_prog *prog, u32 off,\n\t\t\t\t       const struct bpf_insn *patch, u32 len)\n{\n\tu32 insn_adj_cnt, insn_rest, insn_delta = len - 1;\n\tstruct bpf_prog *prog_adj;\n\tif (insn_delta == 0) {\n\t\tmemcpy(prog->insnsi + off, patch, sizeof(*patch));\n\t\treturn prog;\n\t}\n\tinsn_adj_cnt = prog->len + insn_delta;\n\tprog_adj = bpf_prog_realloc(prog, bpf_prog_size(insn_adj_cnt),\n\t\t\t\t    GFP_USER);\n\tif (!prog_adj)\n\t\treturn NULL;\n\tprog_adj->len = insn_adj_cnt;\n\tinsn_rest = insn_adj_cnt - off - len;\n\tmemmove(prog_adj->insnsi + off + len, prog_adj->insnsi + off + 1,\n\t\tsizeof(*patch) * insn_rest);\n\tmemcpy(prog_adj->insnsi + off, patch, sizeof(*patch) * len);\n\tbpf_adj_branches(prog_adj, off, insn_delta);\n\treturn prog_adj;\n}", "target": 1}
{"code": "enum io_wq_cancel io_wq_cancel_cb(struct io_wq *wq, work_cancel_fn *cancel,\n\t\t\t\t  void *data, bool cancel_all)\n{\n\tstruct io_cb_cancel_data match = {\n\t\t.fn\t\t= cancel,\n\t\t.data\t\t= data,\n\t\t.cancel_all\t= cancel_all,\n\t};\n\tint node;\n\tfor_each_node(node) {\n\t\tstruct io_wqe *wqe = wq->wqes[node];\n\t\tio_wqe_cancel_pending_work(wqe, &match);\n\t\tif (match.nr_pending && !match.cancel_all)\n\t\t\treturn IO_WQ_CANCEL_OK;\n\t}\n\tfor_each_node(node) {\n\t\tstruct io_wqe *wqe = wq->wqes[node];\n\t\tio_wqe_cancel_running_work(wqe, &match);\n\t\tif (match.nr_running && !match.cancel_all)\n\t\t\treturn IO_WQ_CANCEL_RUNNING;\n\t}\n\tif (match.nr_running)\n\t\treturn IO_WQ_CANCEL_RUNNING;\n\tif (match.nr_pending)\n\t\treturn IO_WQ_CANCEL_OK;\n\treturn IO_WQ_CANCEL_NOTFOUND;\n}", "target": 0}
{"code": "bool PrintMsg_Print_Params_IsEqual(\n    const PrintMsg_PrintPages_Params& oldParams,\n    const PrintMsg_PrintPages_Params& newParams) {\n  return PageLayoutIsEqual(oldParams, newParams) &&\n         oldParams.params.max_shrink == newParams.params.max_shrink &&\n         oldParams.params.min_shrink == newParams.params.min_shrink &&\n         oldParams.params.selection_only == newParams.params.selection_only &&\n         oldParams.params.supports_alpha_blend ==\n             newParams.params.supports_alpha_blend &&\n         oldParams.pages.size() == newParams.pages.size() &&\n         oldParams.params.display_header_footer ==\n             newParams.params.display_header_footer &&\n         oldParams.params.date == newParams.params.date &&\n         oldParams.params.title == newParams.params.title &&\n         oldParams.params.url == newParams.params.url &&\n         std::equal(oldParams.pages.begin(), oldParams.pages.end(),\n             newParams.pages.begin());\n}", "target": 0}
{"code": "  static void NetworkManagerStatusChangedHandler(void* object,\n                                                 const char* path,\n                                                 const char* key,\n                                                 const Value* value) {\n    NetworkLibraryImpl* networklib = static_cast<NetworkLibraryImpl*>(object);\n    DCHECK(networklib);\n    networklib->UpdateNetworkManagerStatus();\n  }", "target": 0}
{"code": "void print_cfs_stats(struct seq_file *m, int cpu)\n{\n\tstruct cfs_rq *cfs_rq, *pos;\n\trcu_read_lock();\n\tfor_each_leaf_cfs_rq_safe(cpu_rq(cpu), cfs_rq, pos)\n\t\tprint_cfs_rq(m, cpu, cfs_rq);\n\trcu_read_unlock();\n}", "target": 1}
{"code": "bfad_im_get_stats(struct Scsi_Host *shost)\n{\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s         *bfad = im_port->bfad;\n\tstruct bfad_hal_comp fcomp;\n\tunion bfa_port_stats_u *fcstats;\n\tstruct fc_host_statistics *hstats;\n\tbfa_status_t    rc;\n\tunsigned long   flags;\n\tfcstats = kzalloc(sizeof(union bfa_port_stats_u), GFP_KERNEL);\n\tif (fcstats == NULL)\n\t\treturn NULL;\n\thstats = &bfad->link_stats;\n\tinit_completion(&fcomp.comp);\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\tmemset(hstats, 0, sizeof(struct fc_host_statistics));\n\trc = bfa_port_get_stats(BFA_FCPORT(&bfad->bfa),\n\t\t\t\tfcstats, bfad_hcb_comp, &fcomp);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\tif (rc != BFA_STATUS_OK)\n\t\treturn NULL;\n\twait_for_completion(&fcomp.comp);\n\thstats->seconds_since_last_reset = fcstats->fc.secs_reset;\n\thstats->tx_frames = fcstats->fc.tx_frames;\n\thstats->tx_words  = fcstats->fc.tx_words;\n\thstats->rx_frames = fcstats->fc.rx_frames;\n\thstats->rx_words  = fcstats->fc.rx_words;\n\thstats->lip_count = fcstats->fc.lip_count;\n\thstats->nos_count = fcstats->fc.nos_count;\n\thstats->error_frames = fcstats->fc.error_frames;\n\thstats->dumped_frames = fcstats->fc.dropped_frames;\n\thstats->link_failure_count = fcstats->fc.link_failures;\n\thstats->loss_of_sync_count = fcstats->fc.loss_of_syncs;\n\thstats->loss_of_signal_count = fcstats->fc.loss_of_signals;\n\thstats->prim_seq_protocol_err_count = fcstats->fc.primseq_errs;\n\thstats->invalid_crc_count = fcstats->fc.invalid_crcs;\n\tkfree(fcstats);\n\treturn hstats;\n}", "target": 1}
{"code": "  void dumpState(std::ostream& os, int indent_level = 0) const override {\n    header_map_->dumpState(os, indent_level);\n  }", "target": 0}
{"code": "static SQInteger thread_call(HSQUIRRELVM v)\n{\n    SQObjectPtr o = stack_get(v,1);\n    if(sq_type(o) == OT_THREAD) {\n        SQInteger nparams = sq_gettop(v);\n        _thread(o)->Push(_thread(o)->_roottable);\n        for(SQInteger i = 2; i<(nparams+1); i++)\n            sq_move(_thread(o),v,i);\n        if(SQ_SUCCEEDED(sq_call(_thread(o),nparams,SQTrue,SQTrue))) {\n            sq_move(v,_thread(o),-1);\n            sq_pop(_thread(o),1);\n            return 1;\n        }\n        v->_lasterror = _thread(o)->_lasterror;\n        return SQ_ERROR;\n    }\n    return sq_throwerror(v,_SC(\"wrong parameter\"));\n}", "target": 1}
{"code": "resolve_list_keys(struct lys_node_list *list, const char *keys_str)\n{\n    int i, len, rc;\n    const char *value;\n    char *s = NULL;\n    struct ly_ctx *ctx = list->module->ctx;\n    for (i = 0; i < list->keys_size; ++i) {\n        assert(keys_str);\n        if (!list->child) {\n            LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_LYS, list, \"list keys\", keys_str);\n            return EXIT_FAILURE;\n        }\n        if ((value = strpbrk(keys_str, \" \\t\\n\"))) {\n            len = value - keys_str;\n            while (isspace(value[0])) {\n                value++;\n            }\n        } else {\n            len = strlen(keys_str);\n        }\n        rc = lys_getnext_data(lys_node_module((struct lys_node *)list), (struct lys_node *)list, keys_str, len, LYS_LEAF,\n                              (const struct lys_node **)&list->keys[i]);\n        if (rc) {\n            LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_LYS, list, \"list key\", keys_str);\n            return EXIT_FAILURE;\n        }\n        if (check_key(list, i, keys_str, len)) {\n            return -1;\n        }\n        if (lyp_check_status(list->flags, list->module, list->name,\n                             list->keys[i]->flags, list->keys[i]->module, list->keys[i]->name,\n                             (struct lys_node *)list->keys[i])) {\n            return -1;\n        }\n        if (list->keys[i]->dflt) {\n            assert(log_opt == ILO_STORE);\n            log_opt = ILO_LOG;\n            LOGWRN(ctx, \"Default value \\\"%s\\\" in the list key \\\"%s\\\" is ignored. (%s)\", list->keys[i]->dflt,\n                   list->keys[i]->name, s = lys_path((struct lys_node*)list, LYS_PATH_FIRST_PREFIX));\n            log_opt = ILO_STORE;\n            free(s);\n        }\n        while (value && isspace(value[0])) {\n            value++;\n        }\n        keys_str = value;\n    }\n    return EXIT_SUCCESS;\n}", "target": 1}
{"code": "static void free_nested(struct vcpu_vmx *vmx)\n{\n\tif (!vmx->nested.vmxon)\n\t\treturn;\n\tvmx->nested.vmxon = false;\n\tfree_vpid(vmx->nested.vpid02);\n\tnested_release_vmcs12(vmx);\n\tif (enable_shadow_vmcs)\n\t\tfree_vmcs(vmx->nested.current_shadow_vmcs);\n\tif (vmx->nested.apic_access_page) {\n\t\tnested_release_page(vmx->nested.apic_access_page);\n\t\tvmx->nested.apic_access_page = NULL;\n\t}\n\tif (vmx->nested.virtual_apic_page) {\n\t\tnested_release_page(vmx->nested.virtual_apic_page);\n\t\tvmx->nested.virtual_apic_page = NULL;\n\t}\n\tif (vmx->nested.pi_desc_page) {\n\t\tkunmap(vmx->nested.pi_desc_page);\n\t\tnested_release_page(vmx->nested.pi_desc_page);\n\t\tvmx->nested.pi_desc_page = NULL;\n\t\tvmx->nested.pi_desc = NULL;\n\t}\n\tnested_free_all_saved_vmcss(vmx);\n}", "target": 0}
{"code": "static int changedline (const Proto *p, int oldpc, int newpc) {\n  while (oldpc++ < newpc) {\n    if (p->lineinfo[oldpc] != 0)\n      return (luaG_getfuncline(p, oldpc - 1) != luaG_getfuncline(p, newpc));\n  }\n  return 0;  \n}", "target": 1}
{"code": "static inline void tcp_check_send_head(struct sock *sk, struct sk_buff *skb_unlinked)\n{\n\tif (sk->sk_send_head == skb_unlinked)\n\t\tsk->sk_send_head = NULL;\n}", "target": 1}
{"code": "void sk_setup_caps(struct sock *sk, struct dst_entry *dst)\n{\n\t__sk_dst_set(sk, dst);\n\tsk->sk_route_caps = dst->dev->features;\n\tif (sk->sk_route_caps & NETIF_F_GSO)\n\t\tsk->sk_route_caps |= NETIF_F_GSO_SOFTWARE;\n\tsk->sk_route_caps &= ~sk->sk_route_nocaps;\n\tif (sk_can_gso(sk)) {\n\t\tif (dst->header_len) {\n\t\t\tsk->sk_route_caps &= ~NETIF_F_GSO_MASK;\n\t\t} else {\n\t\t\tsk->sk_route_caps |= NETIF_F_SG | NETIF_F_HW_CSUM;\n\t\t\tsk->sk_gso_max_size = dst->dev->gso_max_size;\n\t\t}\n\t}\n}", "target": 0}
{"code": "static inline int ReadPropertyByte(const unsigned char **p,size_t *length)\n{\n  int\n    c;\n  if (*length < 1)\n    return(EOF);\n  c=(int) (*(*p)++);\n  (*length)--;\n  return(c);\n}", "target": 0}
{"code": "int luaD_pretailcall (lua_State *L, CallInfo *ci, StkId func,\n                                    int narg1, int delta) {\n retry:\n  switch (ttypetag(s2v(func))) {\n    case LUA_VCCL:  \n      return precallC(L, func, LUA_MULTRET, clCvalue(s2v(func))->f);\n    case LUA_VLCF:  \n      return precallC(L, func, LUA_MULTRET, fvalue(s2v(func)));\n    case LUA_VLCL: {  \n      Proto *p = clLvalue(s2v(func))->p;\n      int fsize = p->maxstacksize;  \n      int nfixparams = p->numparams;\n      int i;\n      ci->func -= delta;  \n      for (i = 0; i < narg1; i++)  \n        setobjs2s(L, ci->func + i, func + i);\n      checkstackGC(L, fsize);\n      func = ci->func;  \n      for (; narg1 <= nfixparams; narg1++)\n        setnilvalue(s2v(func + narg1));  \n      ci->top = func + 1 + fsize;  \n      lua_assert(ci->top <= L->stack_last);\n      ci->u.l.savedpc = p->code;  \n      ci->callstatus |= CIST_TAIL;\n      L->top = func + narg1;  \n      return -1;\n    }\n    default: {  \n      func = luaD_tryfuncTM(L, func);  \n      narg1++;\n      goto retry;  \n    }\n  }\n}", "target": 1}
{"code": "static bool ieee80211_tx_prep_agg(struct ieee80211_tx_data *tx,\n\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t  struct ieee80211_tx_info *info,\n\t\t\t\t  struct tid_ampdu_tx *tid_tx,\n\t\t\t\t  int tid)\n{\n\tbool queued = false;\n\tbool reset_agg_timer = false;\n\tstruct sk_buff *purge_skb = NULL;\n\tif (test_bit(HT_AGG_STATE_OPERATIONAL, &tid_tx->state)) {\n\t\tinfo->flags |= IEEE80211_TX_CTL_AMPDU;\n\t\treset_agg_timer = true;\n\t} else if (test_bit(HT_AGG_STATE_WANT_START, &tid_tx->state)) {\n\t} else {\n\t\tspin_lock(&tx->sta->lock);\n\t\ttid_tx = rcu_dereference_protected_tid_tx(tx->sta, tid);\n\t\tif (!tid_tx) {\n\t\t} else if (test_bit(HT_AGG_STATE_OPERATIONAL, &tid_tx->state)) {\n\t\t\tinfo->flags |= IEEE80211_TX_CTL_AMPDU;\n\t\t\treset_agg_timer = true;\n\t\t} else {\n\t\t\tqueued = true;\n\t\t\tinfo->control.vif = &tx->sdata->vif;\n\t\t\tinfo->flags |= IEEE80211_TX_INTFL_NEED_TXPROCESSING;\n\t\t\tinfo->flags &= ~IEEE80211_TX_TEMPORARY_FLAGS;\n\t\t\t__skb_queue_tail(&tid_tx->pending, skb);\n\t\t\tif (skb_queue_len(&tid_tx->pending) > STA_MAX_TX_BUFFER)\n\t\t\t\tpurge_skb = __skb_dequeue(&tid_tx->pending);\n\t\t}\n\t\tspin_unlock(&tx->sta->lock);\n\t\tif (purge_skb)\n\t\t\tieee80211_free_txskb(&tx->local->hw, purge_skb);\n\t}\n\tif (reset_agg_timer && tid_tx->timeout)\n\t\ttid_tx->last_tx = jiffies;\n\treturn queued;\n}", "target": 0}
{"code": "format_nstime_as_iso8601(gchar *buf, size_t buflen, const nstime_t *ns,\n    char *decimal_point, gboolean local, int precision)\n{\n\tstruct tm tm, *tmp;\n\tgchar *ptr;\n\tsize_t buf_remaining;\n\tint num_chars;\n\tif (local)\n\t\ttmp = ws_localtime_r(&ns->secs, &tm);\n\telse\n\t\ttmp = ws_gmtime_r(&ns->secs, &tm);\n\tif (tmp == NULL) {\n\t\tsnprintf(buf, buflen, \"Not representable\");\n\t\treturn;\n\t}\n\tptr = buf;\n\tbuf_remaining = buflen;\n\tnum_chars = snprintf(ptr, buf_remaining,\n\t    \"%04d-%02d-%02d %02d:%02d:%02d\",\n\t    tmp->tm_year + 1900,\n\t    tmp->tm_mon + 1,\n\t    tmp->tm_mday,\n\t    tmp->tm_hour,\n\t    tmp->tm_min,\n\t    tmp->tm_sec);\n\tif (num_chars < 0) {\n\t\tsnprintf(buf, buflen, \"snprintf() failed\");\n\t\treturn;\n\t}\n\tif ((unsigned int)num_chars >= buf_remaining) {\n\t\treturn;\n\t}\n\tptr += num_chars;\n\tbuf_remaining -= num_chars;\n\tif (precision == 0) {\n\t\treturn;\n\t}\n\tformat_fractional_part_nsecs(ptr, buf_remaining, (guint32)ns->nsecs, decimal_point, precision);\n}", "target": 1}
{"code": "static UINT ExtractRunLengthRegularFgBg(const BYTE* pbOrderHdr, const BYTE* pbEnd, UINT32* advance)\n{\n\tUINT runLength = 0;\n\tWINPR_ASSERT(pbOrderHdr);\n\tWINPR_ASSERT(pbEnd);\n\tWINPR_ASSERT(advance);\n\trunLength = (*pbOrderHdr) & g_MaskRegularRunLength;\n\tif (runLength == 0)\n\t{\n\t\tif (!buffer_within_range(pbOrderHdr, 1, pbEnd))\n\t\t{\n\t\t\t*advance = 0;\n\t\t\treturn 0;\n\t\t}\n\t\trunLength = *(pbOrderHdr + 1) + 1;\n\t\t(*advance)++;\n\t}\n\telse\n\t\trunLength = runLength * 8;\n\treturn runLength;\n}", "target": 1}
{"code": "int pam_sm_close_session (pam_handle_t * pamh, int flags,\n    int argc, const char **argv) {\n    return _pam_account(pamh, argc, argv, TAC_PLUS_ACCT_FLAG_STOP, NULL);\n}    ", "target": 0}
{"code": "pci_set_cfgdata32(struct pci_vdev *dev, int offset, uint32_t val)\n{\n\tassert(offset <= (PCI_REGMAX - 3) && (offset & 3) == 0);\n\t*(uint32_t *)(dev->cfgdata + offset) = val;\n}", "target": 1}
{"code": "static inline void packet_increment_rx_head(struct packet_sock *po,\n\t\t\t\t\t    struct packet_ring_buffer *rb)\n{\n\tswitch (po->tp_version) {\n\tcase TPACKET_V1:\n\tcase TPACKET_V2:\n\t\treturn packet_increment_head(rb);\n\tcase TPACKET_V3:\n\tdefault:\n\t\tWARN(1, \"TPACKET version not supported.\\n\");\n\t\tBUG();\n\t\treturn;\n\t}\n}", "target": 0}
{"code": "static void ati_cursor_define(ATIVGAState *s)\n{\n    uint8_t data[1024];\n    uint8_t *src;\n    int i, j, idx = 0;\n    if ((s->regs.cur_offset & BIT(31)) || s->cursor_guest_mode) {\n        return; \n    }\n    src = s->vga.vram_ptr + s->regs.cur_offset -\n          (s->regs.cur_hv_offs >> 16) - (s->regs.cur_hv_offs & 0xffff) * 16;\n    for (i = 0; i < 64; i++) {\n        for (j = 0; j < 8; j++, idx++) {\n            data[idx] = src[i * 16 + j];\n            data[512 + idx] = src[i * 16 + j + 8];\n        }\n    }\n    if (!s->cursor) {\n        s->cursor = cursor_alloc(64, 64);\n    }\n    cursor_set_mono(s->cursor, s->regs.cur_color1, s->regs.cur_color0,\n                    &data[512], 1, &data[0]);\n    dpy_cursor_define(s->vga.con, s->cursor);\n}", "target": 1}
{"code": "struct resource_pool *dcn10_create_resource_pool(\n\t\tconst struct dc_init_data *init_data,\n\t\tstruct dc *dc)\n{\n\tstruct dcn10_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dcn10_resource_pool), GFP_KERNEL);\n\tif (!pool)\n\t\treturn NULL;\n\tif (construct(init_data->num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 1}
{"code": "static inline void sem_lock_and_putref(struct sem_array *sma)\n{\n\tipc_lock_by_ptr(&sma->sem_perm);\n\tipc_rcu_putref(sma);\n}", "target": 1}
{"code": "_gnutls_ecc_ansi_x963_export (gnutls_ecc_curve_t curve, bigint_t x, bigint_t y,\n                              gnutls_datum_t * out)\n{\n  int numlen = gnutls_ecc_curve_get_size (curve);\n  int byte_size, ret;\n  size_t size;\n  if (numlen == 0)\n    return gnutls_assert_val (GNUTLS_E_INVALID_REQUEST);\n  out->size = 1 + 2 * numlen;\n  out->data = gnutls_malloc (out->size);\n  if (out->data == NULL)\n    return gnutls_assert_val (GNUTLS_E_MEMORY_ERROR);\n  memset (out->data, 0, out->size);\n  out->data[0] = 0x04;\n  byte_size = (_gnutls_mpi_get_nbits (x) + 7) / 8;\n  size = out->size - (1 + (numlen - byte_size));\n  ret = _gnutls_mpi_print (x, &out->data[1 + (numlen - byte_size)], &size);\n  if (ret < 0)\n    return gnutls_assert_val (ret);\n  byte_size = (_gnutls_mpi_get_nbits (y) + 7) / 8;\n  size = out->size - (1 + (numlen + numlen - byte_size));\n  ret =\n    _gnutls_mpi_print (y, &out->data[1 + numlen + numlen - byte_size], &size);\n  if (ret < 0)\n    return gnutls_assert_val (ret);\n  return 0;\n}", "target": 1}
{"code": "static void blk_mq_insert_requests(struct request_queue *q,\n\t\t\t\t     struct blk_mq_ctx *ctx,\n\t\t\t\t     struct list_head *list,\n\t\t\t\t     int depth,\n\t\t\t\t     bool from_schedule)\n{\n\tstruct blk_mq_hw_ctx *hctx;\n\tstruct blk_mq_ctx *current_ctx;\n\ttrace_block_unplug(q, depth, !from_schedule);\n\tcurrent_ctx = blk_mq_get_ctx(q);\n\tif (!cpu_online(ctx->cpu))\n\t\tctx = current_ctx;\n\thctx = q->mq_ops->map_queue(q, ctx->cpu);\n\tspin_lock(&ctx->lock);\n\twhile (!list_empty(list)) {\n\t\tstruct request *rq;\n\t\trq = list_first_entry(list, struct request, queuelist);\n\t\tlist_del_init(&rq->queuelist);\n\t\trq->mq_ctx = ctx;\n\t\t__blk_mq_insert_request(hctx, rq, false);\n\t}\n\tspin_unlock(&ctx->lock);\n\tblk_mq_run_hw_queue(hctx, from_schedule);\n\tblk_mq_put_ctx(current_ctx);\n}", "target": 0}
{"code": "static int iscleared (global_State *g, const GCObject *o) {\n  if (o == NULL) return 0;  \n  else if (novariant(o->tt) == LUA_TSTRING) {\n    markobject(g, o);  \n    return 0;\n  }\n  else return iswhite(o);\n}", "target": 0}
{"code": "static void dump_thread32(struct pt_regs * regs, struct user32 * dump)\n{\n\tu32 fs,gs;\n\tdump->magic = CMAGIC;\n\tdump->start_code = 0;\n\tdump->start_stack = regs->rsp & ~(PAGE_SIZE - 1);\n\tdump->u_tsize = ((unsigned long) current->mm->end_code) >> PAGE_SHIFT;\n\tdump->u_dsize = ((unsigned long) (current->mm->brk + (PAGE_SIZE-1))) >> PAGE_SHIFT;\n\tdump->u_dsize -= dump->u_tsize;\n\tdump->u_ssize = 0;\n\tdump->u_debugreg[0] = current->thread.debugreg0;  \n\tdump->u_debugreg[1] = current->thread.debugreg1;  \n\tdump->u_debugreg[2] = current->thread.debugreg2;  \n\tdump->u_debugreg[3] = current->thread.debugreg3;  \n\tdump->u_debugreg[4] = 0;  \n\tdump->u_debugreg[5] = 0;  \n\tdump->u_debugreg[6] = current->thread.debugreg6;  \n\tdump->u_debugreg[7] = current->thread.debugreg7;  \n\tif (dump->start_stack < 0xc0000000)\n\t\tdump->u_ssize = ((unsigned long) (0xc0000000 - dump->start_stack)) >> PAGE_SHIFT;\n\tdump->regs.ebx = regs->rbx;\n\tdump->regs.ecx = regs->rcx;\n\tdump->regs.edx = regs->rdx;\n\tdump->regs.esi = regs->rsi;\n\tdump->regs.edi = regs->rdi;\n\tdump->regs.ebp = regs->rbp;\n\tdump->regs.eax = regs->rax;\n\tdump->regs.ds = current->thread.ds;\n\tdump->regs.es = current->thread.es;\n\tasm(\"movl %%fs,%0\" : \"=r\" (fs)); dump->regs.fs = fs;\n\tasm(\"movl %%gs,%0\" : \"=r\" (gs)); dump->regs.gs = gs; \n\tdump->regs.orig_eax = regs->orig_rax;\n\tdump->regs.eip = regs->rip;\n\tdump->regs.cs = regs->cs;\n\tdump->regs.eflags = regs->eflags;\n\tdump->regs.esp = regs->rsp;\n\tdump->regs.ss = regs->ss;\n#if 1 \n\tdump->u_fpvalid = 0;\n#else\n\tdump->u_fpvalid = dump_fpu (regs, &dump->i387);\n#endif\n}", "target": 0}
{"code": "static int inotify_release(struct inode *ignored, struct file *file)\n{\n\tstruct fsnotify_group *group = file->private_data;\n\tstruct user_struct *user = group->inotify_data.user;\n\tpr_debug(\"%s: group=%p\\n\", __func__, group);\n\tfsnotify_clear_marks_by_group(group);\n\tfsnotify_put_group(group);\n\tatomic_dec(&user->inotify_devs);\n\treturn 0;\n}", "target": 1}
{"code": "irqreturn_t bnx2x_msix_sp_int(int irq, void *dev_instance)\n{\n\tstruct net_device *dev = dev_instance;\n\tstruct bnx2x *bp = netdev_priv(dev);\n\tbnx2x_ack_sb(bp, bp->igu_dsb_id, USTORM_ID, 0,\n\t\t     IGU_INT_DISABLE, 0);\n#ifdef BNX2X_STOP_ON_ERROR\n\tif (unlikely(bp->panic))\n\t\treturn IRQ_HANDLED;\n#endif\n\tif (CNIC_LOADED(bp)) {\n\t\tstruct cnic_ops *c_ops;\n\t\trcu_read_lock();\n\t\tc_ops = rcu_dereference(bp->cnic_ops);\n\t\tif (c_ops)\n\t\t\tc_ops->cnic_handler(bp->cnic_data, NULL);\n\t\trcu_read_unlock();\n\t}\n\tbnx2x_schedule_sp_task(bp);\n\treturn IRQ_HANDLED;\n}", "target": 0}
{"code": "ppp_mp_insert(struct ppp *ppp, struct sk_buff *skb)\n{\n\tstruct sk_buff *p;\n\tstruct sk_buff_head *list = &ppp->mrq;\n\tu32 seq = skb->sequence;\n\tskb_queue_walk(list, p) {\n\t\tif (seq_before(seq, p->sequence))\n\t\t\tbreak;\n\t}\n\t__skb_queue_before(list, p, skb);\n}", "target": 0}
{"code": "devzvol_create(struct vnode *dvp, char *nm, struct vattr *vap, vcexcl_t excl,\n    int mode, struct vnode **vpp, struct cred *cred, int flag,\n    caller_context_t *ct, vsecattr_t *vsecp)\n{\n\tint error;\n\tstruct vnode *vp;\n\t*vpp = NULL;\n\terror = devzvol_lookup(dvp, nm, &vp, NULL, 0, NULL, cred, ct, NULL,\n\t    NULL);\n\tif (error == 0) {\n\t\tif (excl == EXCL)\n\t\t\terror = EEXIST;\n\t\telse if (vp->v_type == VDIR && (mode & VWRITE))\n\t\t\terror = EISDIR;\n\t\telse\n\t\t\terror = VOP_ACCESS(vp, mode, 0, cred, ct);\n\t\tif (error) {\n\t\t\tVN_RELE(vp);\n\t\t} else\n\t\t\t*vpp = vp;\n\t} else if (error == ENOENT) {\n\t\terror = EROFS;\n\t}\n\treturn (error);\n}", "target": 0}
{"code": "static void tty_ldisc_close(struct tty_struct *tty, struct tty_ldisc *ld)\n{\n\tWARN_ON(!test_bit(TTY_LDISC_OPEN, &tty->flags));\n\tclear_bit(TTY_LDISC_OPEN, &tty->flags);\n\tif (ld->ops->close)\n\t\tld->ops->close(tty);\n\ttty_ldisc_debug(tty, \"%p: closed\\n\", tty->ldisc);\n}", "target": 0}
{"code": "void sctp_generate_t3_rtx_event(unsigned long peer)\n{\n\tint error;\n\tstruct sctp_transport *transport = (struct sctp_transport *) peer;\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct net *net = sock_net(asoc->base.sk);\n\tbh_lock_sock(asoc->base.sk);\n\tif (sock_owned_by_user(asoc->base.sk)) {\n\t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n\t\tif (!mod_timer(&transport->T3_rtx_timer, jiffies + (HZ/20)))\n\t\t\tsctp_transport_hold(transport);\n\t\tgoto out_unlock;\n\t}\n\tif (transport->dead)\n\t\tgoto out_unlock;\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(SCTP_EVENT_TIMEOUT_T3_RTX),\n\t\t\t   asoc->state,\n\t\t\t   asoc->ep, asoc,\n\t\t\t   transport, GFP_ATOMIC);\n\tif (error)\n\t\tasoc->base.sk->sk_err = -error;\nout_unlock:\n\tbh_unlock_sock(asoc->base.sk);\n\tsctp_transport_put(transport);\n}", "target": 1}
{"code": "static void header(RBinFile *bf) {\n\tr_return_if_fail (bf && bf->o);\n\tRCoreSymCacheElement *element = bf->o->bin_obj;\n\tif (!element) {\n\t\treturn;\n\t}\n\tRBin *bin = bf->rbin;\n\tPrintfCallback p = bin->cb_printf;\n\tPJ *pj = pj_new ();\n\tif (!pj) {\n\t\treturn;\n\t}\n\tpj_o (pj);\n\tpj_kn (pj, \"cs_version\", element->hdr->version);\n\tpj_kn (pj, \"size\", element->hdr->size);\n\tif (element->file_name) {\n\t\tpj_ks (pj, \"name\", element->file_name);\n\t}\n\tif (element->binary_version) {\n\t\tpj_ks (pj, \"version\", element->binary_version);\n\t}\n\tchar uuidstr[R_UUID_LENGTH];\n\tr_hex_bin2str (element->hdr->uuid, 16, uuidstr);\n\tpj_ks (pj, \"uuid\", uuidstr);\n\tpj_kn (pj, \"segments\", element->hdr->n_segments);\n\tpj_kn (pj, \"sections\", element->hdr->n_sections);\n\tpj_kn (pj, \"symbols\", element->hdr->n_symbols);\n\tpj_kn (pj, \"lined_symbols\", element->hdr->n_lined_symbols);\n\tpj_kn (pj, \"line_info\", element->hdr->n_line_info);\n\tpj_end (pj);\n\tp (\"%s\\n\", pj_string (pj));\n\tpj_free (pj);\n}", "target": 0}
{"code": "  SubgraphGuard(TfLiteContext* context, bool* is_subgraph_in_use)\n      : is_subgraph_in_use_(is_subgraph_in_use) {\n    if (*is_subgraph_in_use_) {\n      TF_LITE_KERNEL_LOG(\n          context,\n          \"Subgraph is already in use. Using an interpreter or a subgraph in \"\n          \"multiple threads is not supported. Recursion in the graph is not \"\n          \"supported.\");\n      status_ = kTfLiteError;\n    } else {\n      *is_subgraph_in_use_ = true;\n    }\n  }", "target": 0}
{"code": "cib_timeout_handler(gpointer data)\n{\n    struct timer_rec_s *timer = data;\n    timer_expired = TRUE;\n    crm_err(\"Call %d timed out after %ds\", timer->call_id, timer->timeout);\n    return TRUE;\n}", "target": 1}
{"code": "int ldb_match_message(struct ldb_context *ldb,\n\t\t      const struct ldb_message *msg,\n\t\t      const struct ldb_parse_tree *tree,\n\t\t      enum ldb_scope scope, bool *matched)\n{\n\tunsigned int i;\n\tint ret;\n\t*matched = false;\n\tif (scope != LDB_SCOPE_BASE && ldb_dn_is_special(msg->dn)) {\n\t\treturn LDB_SUCCESS;\n\t}\n\tswitch (tree->operation) {\n\tcase LDB_OP_AND:\n\t\tfor (i=0;i<tree->u.list.num_elements;i++) {\n\t\t\tret = ldb_match_message(ldb, msg, tree->u.list.elements[i], scope, matched);\n\t\t\tif (ret != LDB_SUCCESS) return ret;\n\t\t\tif (!*matched) return LDB_SUCCESS;\n\t\t}\n\t\t*matched = true;\n\t\treturn LDB_SUCCESS;\n\tcase LDB_OP_OR:\n\t\tfor (i=0;i<tree->u.list.num_elements;i++) {\n\t\t\tret = ldb_match_message(ldb, msg, tree->u.list.elements[i], scope, matched);\n\t\t\tif (ret != LDB_SUCCESS) return ret;\n\t\t\tif (*matched) return LDB_SUCCESS;\n\t\t}\n\t\t*matched = false;\n\t\treturn LDB_SUCCESS;\n\tcase LDB_OP_NOT:\n\t\tret = ldb_match_message(ldb, msg, tree->u.isnot.child, scope, matched);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\t\t*matched = ! *matched;\n\t\treturn LDB_SUCCESS;\n\tcase LDB_OP_EQUALITY:\n\t\treturn ldb_match_equality(ldb, msg, tree, scope, matched);\n\tcase LDB_OP_SUBSTRING:\n\t\treturn ldb_match_substring(ldb, msg, tree, scope, matched);\n\tcase LDB_OP_GREATER:\n\t\treturn ldb_match_comparison(ldb, msg, tree, scope, LDB_OP_GREATER, matched);\n\tcase LDB_OP_LESS:\n\t\treturn ldb_match_comparison(ldb, msg, tree, scope, LDB_OP_LESS, matched);\n\tcase LDB_OP_PRESENT:\n\t\treturn ldb_match_present(ldb, msg, tree, scope, matched);\n\tcase LDB_OP_APPROX:\n\t\treturn ldb_match_comparison(ldb, msg, tree, scope, LDB_OP_APPROX, matched);\n\tcase LDB_OP_EXTENDED:\n\t\treturn ldb_match_extended(ldb, msg, tree, scope, matched);\n\t}\n\treturn LDB_ERR_INAPPROPRIATE_MATCHING;\n}", "target": 0}
{"code": "Value ExpressionDateToString::evaluate(const Document& root, Variables* variables) const {\n    const Value date = _date->evaluate(root, variables);\n    Value formatValue;\n    if (_format) {\n        formatValue = _format->evaluate(root, variables);\n        if (!formatValue.nullish()) {\n            uassert(18533,\n                    str::stream() << \"$dateToString requires that 'format' be a string, found: \"\n                                  << typeName(formatValue.getType()) << \" with value \"\n                                  << formatValue.toString(),\n                    formatValue.getType() == BSONType::String);\n            TimeZone::validateToStringFormat(formatValue.getStringData());\n        }\n    }\n    auto timeZone =\n        makeTimeZone(getExpressionContext()->timeZoneDatabase, root, _timeZone.get(), variables);\n    if (date.nullish()) {\n        return _onNull ? _onNull->evaluate(root, variables) : Value(BSONNULL);\n    }\n    if (!timeZone) {\n        return Value(BSONNULL);\n    }\n    if (_format) {\n        if (formatValue.nullish()) {\n            return Value(BSONNULL);\n        }\n        return Value(uassertStatusOK(\n            timeZone->formatDate(formatValue.getStringData(), date.coerceToDate())));\n    }\n    return Value(\n        uassertStatusOK(timeZone->formatDate(Value::kISOFormatString, date.coerceToDate())));\n}", "target": 0}
{"code": "inline bool operator ==(const MaskedIP& l, const MaskedIP& r) {\n  auto shift = std::max((l.v6 ? 128 : 32) - l.prefix,\n\t\t\t(r.v6 ? 128 : 32) - r.prefix);\n  ceph_assert(shift > 0);\n  return (l.addr >> shift) == (r.addr >> shift);\n}", "target": 1}
{"code": "return_enc_padata(krb5_context context, krb5_data *req_pkt,\n                  krb5_kdc_req *request, krb5_keyblock *reply_key,\n                  krb5_db_entry *server, krb5_enc_kdc_rep_part *reply_encpart,\n                  krb5_boolean is_referral)\n{\n    krb5_error_code code = 0;\n    assert(reply_encpart->enc_padata == NULL);\n    if (is_referral) {\n        code = return_referral_enc_padata(context, reply_encpart, server);\n        if (code)\n            return code;\n    }\n    code = kdc_handle_protected_negotiation(context, req_pkt, request, reply_key,\n                                            &reply_encpart->enc_padata);\n    if (code)\n        goto cleanup;\ncleanup:\n    return code;\n}", "target": 1}
{"code": "static int cenc_scheme_decrypt(MOVContext *c, MOVStreamContext *sc, AVEncryptionInfo *sample, uint8_t *input, int size)\n{\n    int i, ret;\n    int bytes_of_protected_data;\n    if (!sc->cenc.aes_ctr) {\n        sc->cenc.aes_ctr = av_aes_ctr_alloc();\n        if (!sc->cenc.aes_ctr) {\n            return AVERROR(ENOMEM);\n        }\n        ret = av_aes_ctr_init(sc->cenc.aes_ctr, c->decryption_key);\n        if (ret < 0) {\n            return ret;\n        }\n    }\n    av_aes_ctr_set_full_iv(sc->cenc.aes_ctr, sample->iv);\n    if (!sample->subsample_count) {\n        av_aes_ctr_crypt(sc->cenc.aes_ctr, input, input, size);\n        return 0;\n    }\n    for (i = 0; i < sample->subsample_count; i++) {\n        if (sample->subsamples[i].bytes_of_clear_data + sample->subsamples[i].bytes_of_protected_data > size) {\n            av_log(c->fc, AV_LOG_ERROR, \"subsample size exceeds the packet size left\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        input += sample->subsamples[i].bytes_of_clear_data;\n        size -= sample->subsamples[i].bytes_of_clear_data;\n        bytes_of_protected_data = sample->subsamples[i].bytes_of_protected_data;\n        av_aes_ctr_crypt(sc->cenc.aes_ctr, input, input, bytes_of_protected_data);\n        input += bytes_of_protected_data;\n        size -= bytes_of_protected_data;\n    }\n    if (size > 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"leftover packet bytes after subsample processing\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    return 0;\n}", "target": 0}
{"code": "static void rfc2231_decode_one (char *dest, char *src)\n{\n  char *d;\n  for (d = dest; *src; src++)\n  {\n    if (*src == '%' &&\n        isxdigit ((unsigned char) *(src + 1)) &&\n        isxdigit ((unsigned char) *(src + 2)))\n    {\n      *d++ = (hexval (*(src + 1)) << 4) | (hexval (*(src + 2)));\n      src += 2;\n    }\n    else\n      *d++ = *src;\n  }\n  *d = '\\0';\n}", "target": 0}
{"code": "\tTEST_METHOD(8) {\n\t\tServerInstanceDir dir(parentDir + \"/passenger-test.1234\");\n\t\tServerInstanceDir::GenerationPtr generation0 = dir.newGeneration(true, \"nobody\", nobodyGroup, 0, 0);\n\t\tServerInstanceDir::GenerationPtr generation1 = dir.newGeneration(true, \"nobody\", nobodyGroup, 0, 0);\n\t\tServerInstanceDir::GenerationPtr generation2 = dir.newGeneration(true, \"nobody\", nobodyGroup, 0, 0);\n\t\tServerInstanceDir::GenerationPtr generation3 = dir.newGeneration(true, \"nobody\", nobodyGroup, 0, 0);\n\t\tgeneration2.reset();\n\t\tensure_equals(dir.getNewestGeneration()->getNumber(), 3u);\n\t\tgeneration3.reset();\n\t\tensure_equals(dir.getNewestGeneration()->getNumber(), 1u);\n\t}", "target": 0}
{"code": "ErrorCode HTTP2Codec::checkNewStream(uint32_t streamId, bool trailersAllowed) {\n  if (streamId == 0) {\n    goawayErrorMessage_ = folly::to<string>(\n        \"GOAWAY error: received streamID=\", streamId,\n        \" as invalid new stream for lastStreamID_=\", lastStreamID_);\n    VLOG(4) << goawayErrorMessage_;\n    return ErrorCode::PROTOCOL_ERROR;\n  }\n  parsingDownstreamTrailers_ = trailersAllowed && (streamId <= lastStreamID_);\n  if (parsingDownstreamTrailers_) {\n    VLOG(4) << \"Parsing downstream trailers streamId=\" << streamId;\n  }\n  if (sessionClosing_ != ClosingState::CLOSED) {\n    lastStreamID_ = streamId;\n  }\n  if (isInitiatedStream(streamId)) {\n    goawayErrorMessage_ = folly::to<string>(\n        \"GOAWAY error: invalid new stream received with streamID=\", streamId);\n    VLOG(4) << goawayErrorMessage_;\n    return ErrorCode::PROTOCOL_ERROR;\n  } else {\n    return ErrorCode::NO_ERROR;\n  }\n}", "target": 1}
{"code": "ServiceWorkerContainer* NavigatorServiceWorker::serviceWorker(Navigator& navigator, ExceptionState& exceptionState)\n {\n     return NavigatorServiceWorker::from(navigator).serviceWorker(exceptionState);\n }", "target": 1}
{"code": "static __exit void sctp_exit(void)\n{\n\tsctp_v6_del_protocol();\n\tsctp_v4_del_protocol();\n\tunregister_pernet_subsys(&sctp_net_ops);\n\tsctp_v6_protosw_exit();\n\tsctp_v4_protosw_exit();\n\tsctp_v6_pf_exit();\n\tsctp_v4_pf_exit();\n\tsctp_sysctl_unregister();\n\tfree_pages((unsigned long)sctp_assoc_hashtable,\n\t\t   get_order(sctp_assoc_hashsize *\n\t\t\t     sizeof(struct sctp_hashbucket)));\n\tkfree(sctp_ep_hashtable);\n\tfree_pages((unsigned long)sctp_port_hashtable,\n\t\t   get_order(sctp_port_hashsize *\n\t\t\t     sizeof(struct sctp_bind_hashbucket)));\n\tpercpu_counter_destroy(&sctp_sockets_allocated);\n\trcu_barrier(); \n\tkmem_cache_destroy(sctp_chunk_cachep);\n\tkmem_cache_destroy(sctp_bucket_cachep);\n}", "target": 1}
{"code": "int _WM_midi_setup_noteoff(struct _mdi *mdi, uint8_t channel,\n                           uint8_t note, uint8_t velocity) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,channel, note);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_note_off;\n    mdi->events[mdi->event_count].event_data.channel = channel;\n    mdi->events[mdi->event_count].event_data.data.value = (note << 8) | velocity;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}", "target": 0}
{"code": "_dbus_lookup_launchd_socket (DBusString *socket_path,\n                             const char *launchd_env_var,\n                             DBusError  *error)\n{\n#ifdef DBUS_ENABLE_LAUNCHD\n  char *argv[4];\n  int i;\n  _DBUS_ASSERT_ERROR_IS_CLEAR (error);\n  if (_dbus_check_setuid ())\n    {\n      dbus_set_error_const (error, DBUS_ERROR_NOT_SUPPORTED,\n                            \"Unable to find launchd socket when setuid\");\n      return FALSE;\n    }\n  i = 0;\n  argv[i] = \"launchctl\";\n  ++i;\n  argv[i] = \"getenv\";\n  ++i;\n  argv[i] = (char*)launchd_env_var;\n  ++i;\n  argv[i] = NULL;\n  ++i;\n  _dbus_assert (i == _DBUS_N_ELEMENTS (argv));\n  if (!_read_subprocess_line_argv(argv[0], TRUE, argv, socket_path, error))\n    {\n      return FALSE;\n    }\n  if (_dbus_string_get_length(socket_path) == 0)\n    {\n      return FALSE;\n    }\n  _dbus_string_shorten(socket_path, 1);\n  return TRUE;\n#else \n  dbus_set_error(error, DBUS_ERROR_NOT_SUPPORTED,\n                \"can't lookup socket from launchd; launchd support not compiled in\");\n  return FALSE;\n#endif\n}", "target": 0}
{"code": "cr_input_read_byte (CRInput * a_this, guchar * a_byte)\n{\n        g_return_val_if_fail (a_this && PRIVATE (a_this)\n                              && a_byte, CR_BAD_PARAM_ERROR);\n        g_return_val_if_fail (PRIVATE (a_this)->next_byte_index <=\n                              PRIVATE (a_this)->nb_bytes, CR_BAD_PARAM_ERROR);\n        if (PRIVATE (a_this)->end_of_input == TRUE)\n                return CR_END_OF_INPUT_ERROR;\n        *a_byte = PRIVATE (a_this)->in_buf[PRIVATE (a_this)->next_byte_index];\n        if (PRIVATE (a_this)->nb_bytes -\n            PRIVATE (a_this)->next_byte_index < 2) {\n                PRIVATE (a_this)->end_of_input = TRUE;\n        } else {\n                PRIVATE (a_this)->next_byte_index++;\n        }\n        return CR_OK;\n}", "target": 1}
{"code": "static int selinux_key_permission(key_ref_t key_ref,\n\t\t\t\t  const struct cred *cred,\n\t\t\t\t  unsigned perm)\n{\n\tstruct key *key;\n\tstruct key_security_struct *ksec;\n\tu32 sid;\n\tif (perm == 0)\n\t\treturn 0;\n\tsid = cred_sid(cred);\n\tkey = key_ref_to_ptr(key_ref);\n\tksec = key->security;\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    sid, ksec->sid, SECCLASS_KEY, perm, NULL);\n}", "target": 0}
{"code": "ExecuteSoapAction(struct upnphttp * h, const char * action, int n)\n{\n\tchar * p;\n\tchar * p2;\n\tint i, len, methodlen;\n\tchar namespace[256];\n\tp = strchr(action, '#');\n\tif(p && (p - action) < n) {\n\t\tfor(i = 0; i < ((int)sizeof(namespace) - 1) && (action + i) < p; i++)\n\t\t\tnamespace[i] = action[i];\n\t\tnamespace[i] = '\\0';\n\t\tp++;\n\t\tp2 = strchr(p, '\"');\n\t\tif(p2 && (p2 - action) <= n)\n\t\t\tmethodlen = p2 - p;\n\t\telse\n\t\t\tmethodlen = n - (p - action);\n\t\tfor(i = 0; soapMethods[i].methodName; i++) {\n\t\t\tlen = strlen(soapMethods[i].methodName);\n\t\t\tif((len == methodlen) && memcmp(p, soapMethods[i].methodName, len) == 0) {\n#ifdef DEBUG\n\t\t\t\tsyslog(LOG_DEBUG, \"Remote Call of SoapMethod '%s' %s\",\n\t\t\t\t       soapMethods[i].methodName, namespace);\n#endif \n\t\t\t\tsoapMethods[i].methodImpl(h, soapMethods[i].methodName, namespace);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tsyslog(LOG_NOTICE, \"SoapMethod: Unknown: %.*s %s\", methodlen, p, namespace);\n\t} else {\n\t\tsyslog(LOG_NOTICE, \"cannot parse SoapAction\");\n\t}\n\tSoapError(h, 401, \"Invalid Action\");\n}", "target": 0}
{"code": "ssh_packet_get_compress_state(struct sshbuf *m, struct ssh *ssh)\n{\n\tstruct session_state *state = ssh->state;\n\tstruct sshbuf *b;\n\tint r;\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (state->compression_in_started) {\n\t\tif ((r = sshbuf_put_string(b, &state->compression_in_stream,\n\t\t    sizeof(state->compression_in_stream))) != 0)\n\t\t\tgoto out;\n\t} else if ((r = sshbuf_put_string(b, NULL, 0)) != 0)\n\t\tgoto out;\n\tif (state->compression_out_started) {\n\t\tif ((r = sshbuf_put_string(b, &state->compression_out_stream,\n\t\t    sizeof(state->compression_out_stream))) != 0)\n\t\t\tgoto out;\n\t} else if ((r = sshbuf_put_string(b, NULL, 0)) != 0)\n\t\tgoto out;\n\tr = sshbuf_put_stringb(m, b);\n out:\n\tsshbuf_free(b);\n\treturn r;\n}", "target": 1}
{"code": "void TableLookUp::setTable(int ntable, const std::vector<ushort16>& table) {\n  assert(!table.empty());\n  const int nfilled = table.size();\n  if (ntable > ntables) {\n    ThrowRDE(\"Table lookup with number greater than number of tables.\");\n  }\n  ushort16* t = &tables[ntable * TABLE_SIZE];\n  if (!dither) {\n    for (int i = 0; i < 65536; i++) {\n      t[i] = (i < nfilled) ? table[i] : table[nfilled - 1];\n    }\n    return;\n  }\n  for (int i = 0; i < nfilled; i++) {\n    int center = table[i];\n    int lower = i > 0 ? table[i - 1] : center;\n    int upper = i < (nfilled - 1) ? table[i + 1] : center;\n    int delta = upper - lower;\n    t[i * 2] = center - ((upper - lower + 2) / 4);\n    t[i * 2 + 1] = delta;\n  }\n  for (int i = nfilled; i < 65536; i++) {\n    t[i * 2] = table[nfilled - 1];\n    t[i * 2 + 1] = 0;\n  }\n  t[0] = t[1];\n  t[TABLE_SIZE - 1] = t[TABLE_SIZE - 2];\n}", "target": 1}
{"code": "static TValue *trace_exit_cp(lua_State *L, lua_CFunction dummy, void *ud)\n{\n  ExitDataCP *exd = (ExitDataCP *)ud;\n  cframe_errfunc(L->cframe) = -1;  \n  exd->pc = lj_snap_restore(exd->J, exd->exptr);\n  UNUSED(dummy);\n  return NULL;\n}", "target": 1}
{"code": "int tls1_cbc_remove_padding(const SSL* s,\n\t\t\t    SSL3_RECORD *rec,\n\t\t\t    unsigned block_size,\n\t\t\t    unsigned mac_size)\n\t{\n\tunsigned padding_length, good, to_check, i;\n\tconst char has_explicit_iv =\n\t\ts->version >= TLS1_1_VERSION || s->version == DTLS1_VERSION;\n\tconst unsigned overhead = 1  +\n\t\t\t\t  mac_size +\n\t\t\t\t  (has_explicit_iv ? block_size : 0);\n\tif (overhead > rec->length)\n\t\treturn 0;\n\tif (has_explicit_iv)\n\t\t{\n\t\trec->data += block_size;\n\t\trec->input += block_size;\n\t\trec->length -= block_size;\n\t\t}\n\tpadding_length = rec->data[rec->length-1];\n\tif ( (s->options&SSL_OP_TLS_BLOCK_PADDING_BUG) && !s->expand)\n\t\t{\n\t\tif ((memcmp(s->s3->read_sequence, \"\\0\\0\\0\\0\\0\\0\\0\\0\",8) == 0) &&\n\t\t    !(padding_length & 1))\n\t\t\t{\n\t\t\ts->s3->flags|=TLS1_FLAGS_TLS_PADDING_BUG;\n\t\t\t}\n\t\tif ((s->s3->flags & TLS1_FLAGS_TLS_PADDING_BUG) &&\n\t\t    padding_length > 0)\n\t\t\t{\n\t\t\tpadding_length--;\n\t\t\t}\n\t\t}\n\tif (EVP_CIPHER_flags(s->enc_read_ctx->cipher)&EVP_CIPH_FLAG_AEAD_CIPHER)\n\t\t{\n\t\trec->length -= padding_length;\n\t\treturn 1;\n\t\t}\n\tgood = constant_time_ge(rec->length, overhead+padding_length);\n\tto_check = 255; \n\tif (to_check > rec->length-1)\n\t\tto_check = rec->length-1;\n\tfor (i = 0; i < to_check; i++)\n\t\t{\n\t\tunsigned char mask = constant_time_ge(padding_length, i);\n\t\tunsigned char b = rec->data[rec->length-1-i];\n\t\tgood &= ~(mask&(padding_length ^ b));\n\t\t}\n\tgood &= good >> 4;\n\tgood &= good >> 2;\n\tgood &= good >> 1;\n\tgood <<= sizeof(good)*8-1;\n\tgood = DUPLICATE_MSB_TO_ALL(good);\n\tpadding_length = good & (padding_length+1);\n\trec->length -= padding_length;\n\trec->type |= padding_length<<8;\t\n\treturn (int)((good & 1) | (~good & -1));\n\t}", "target": 1}
{"code": "static ZIPARCHIVE_METHOD(addFromString)\n{\n\tstruct zip *intern;\n\tzval *this = getThis();\n\tchar *buffer, *name;\n\tint buffer_len, name_len;\n\tze_zip_object *ze_obj;\n\tstruct zip_source *zs;\n\tint pos = 0;\n\tint cur_idx;\n\tif (!this) {\n\t\tRETURN_FALSE;\n\t}\n\tZIP_FROM_OBJECT(intern, this);\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ss\",\n\t\t\t&name, &name_len, &buffer, &buffer_len) == FAILURE) {\n\t\treturn;\n\t}\n\tze_obj = (ze_zip_object*) zend_object_store_get_object(this TSRMLS_CC);\n\tif (ze_obj->buffers_cnt) {\n\t\tze_obj->buffers = (char **)erealloc(ze_obj->buffers, sizeof(char *) * (ze_obj->buffers_cnt+1));\n\t\tpos = ze_obj->buffers_cnt++;\n\t} else {\n\t\tze_obj->buffers = (char **)emalloc(sizeof(char *));\n\t\tze_obj->buffers_cnt++;\n\t\tpos = 0;\n\t}\n\tze_obj->buffers[pos] = (char *)emalloc(buffer_len + 1);\n\tmemcpy(ze_obj->buffers[pos], buffer, buffer_len + 1);\n\tzs = zip_source_buffer(intern, ze_obj->buffers[pos], buffer_len, 0);\n\tif (zs == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tcur_idx = zip_name_locate(intern, (const char *)name, 0);\n\tif (cur_idx >= 0) {\n\t\tif (zip_delete(intern, cur_idx) == -1) {\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (zip_add(intern, name, zs) != -1) {\n\t\tRETURN_TRUE;\n\t}\nfail:\n\tzip_source_free(zs);\n\tRETURN_FALSE;\n}", "target": 0}
{"code": "static void reset_buffer_flags(struct n_tty_data *ldata)\n{\n\tldata->read_head = ldata->canon_head = ldata->read_tail = 0;\n\tldata->echo_head = ldata->echo_tail = ldata->echo_commit = 0;\n\tldata->echo_mark = 0;\n\tldata->line_start = 0;\n\tldata->erasing = 0;\n\tbitmap_zero(ldata->read_flags, N_TTY_BUF_SIZE);\n\tldata->push = 0;\n}", "target": 0}
{"code": "void *HtpGetTxForH2(void *alstate)\n{\n    HtpState *http_state = (HtpState *)alstate;\n    if (http_state != NULL && http_state->conn != NULL) {\n        size_t txid = htp_list_array_size(http_state->conn->transactions);\n        if (txid > 0) {\n            return htp_list_get(http_state->conn->transactions, txid - 1);\n        }\n    }\n    return NULL;\n}", "target": 1}
{"code": "static uint8_t avrcp_handle_list_player_values(struct avrcp *session,\n\t\t\t\t\t\tstruct avrcp_header *pdu,\n\t\t\t\t\t\tuint8_t transaction)\n{\n\tstruct avrcp_player *player = target_get_player(session);\n\tuint16_t len = ntohs(pdu->params_len);\n\tunsigned int i;\n\tif (len != 1)\n\t\tgoto err;\n\tif (player_get_setting(player, pdu->params[0]) < 0)\n\t\tgoto err;\n\tlen = attr_get_max_val(pdu->params[0]);\n\tfor (i = 1; i <= len; i++)\n\t\tpdu->params[i] = i;\n\tpdu->params[0] = len;\n\tpdu->params_len = htons(len + 1);\n\treturn AVC_CTYPE_STABLE;\nerr:\n\tpdu->params_len = htons(1);\n\tpdu->params[0] = AVRCP_STATUS_INVALID_PARAM;\n\treturn AVC_CTYPE_REJECTED;\n}", "target": 0}
{"code": "static int file_lshift(STANZA *s)\n{\n    BIGNUM *a = NULL, *lshift = NULL, *ret = NULL;\n    int n = 0, st = 0;\n    if (!TEST_ptr(a = getBN(s, \"A\"))\n            || !TEST_ptr(lshift = getBN(s, \"LShift\"))\n            || !TEST_ptr(ret = BN_new())\n            || !getint(s, &n, \"N\"))\n        goto err;\n    if (!TEST_true(BN_lshift(ret, a, n))\n            || !equalBN(\"A << N\", lshift, ret)\n            || !TEST_true(BN_rshift(ret, lshift, n))\n            || !equalBN(\"A >> N\", a, ret))\n        goto err;\n    st = 1;\n err:\n    BN_free(a);\n    BN_free(lshift);\n    BN_free(ret);\n    return st;\n}", "target": 0}
{"code": "static av_always_inline void snow_horizontal_compose_lift_lead_out(int i, IDWTELEM * dst, IDWTELEM * src, IDWTELEM * ref, int width, int w, int lift_high, int mul, int add, int shift){\n    for(; i<w; i++){\n        dst[i] = src[i] - ((mul * (ref[i] + ref[i + 1]) + add) >> shift);\n    }\n    if((width^lift_high)&1){\n        dst[w] = src[w] - ((mul * 2 * ref[w] + add) >> shift);\n    }\n}", "target": 0}
{"code": "void gdImageColorDeallocate (gdImagePtr im, int color)\n{\n\tif (im->trueColor) {\n\t\treturn;\n\t}\n\tim->open[color] = 1;\n}", "target": 0}
{"code": "static void TIFFIgnoreTags(TIFF *tiff)\n{\n  char\n    *q;\n  const char\n    *p,\n    *tags;\n  Image\n   *image;\n  register ssize_t\n    i;\n  size_t\n    count;\n  TIFFFieldInfo\n    *ignore;\n  if (TIFFGetReadProc(tiff) != TIFFReadBlob)\n    return;\n  image=(Image *)TIFFClientdata(tiff);\n  tags=GetImageArtifact(image,\"tiff:ignore-tags\");\n  if (tags == (const char *) NULL)\n    return;\n  count=0;\n  p=tags;\n  while (*p != '\\0')\n  {\n    while ((isspace((int) ((unsigned char) *p)) != 0))\n      p++;\n    (void) strtol(p,&q,10);\n    if (p == q)\n      return;\n    p=q;\n    count++;\n    while ((isspace((int) ((unsigned char) *p)) != 0) || (*p == ','))\n      p++;\n  }\n  if (count == 0)\n    return;\n  i=0;\n  p=tags;\n  ignore=(TIFFFieldInfo *) AcquireQuantumMemory(count,sizeof(*ignore));\n  if (ignore == (TIFFFieldInfo *) NULL)\n    return;\n  memset(ignore,0,count*sizeof(*ignore));\n  while (*p != '\\0')\n  {\n    while ((isspace((int) ((unsigned char) *p)) != 0))\n      p++;\n    ignore[i].field_tag=(ttag_t) strtol(p,&q,10);\n    p=q;\n    i++;\n    while ((isspace((int) ((unsigned char) *p)) != 0) || (*p == ','))\n      p++;\n  }\n  (void) TIFFMergeFieldInfo(tiff,ignore,(uint32) count);\n  ignore=(TIFFFieldInfo *) RelinquishMagickMemory(ignore);\n}", "target": 0}
{"code": "void ContainerNode::notifyNodeRemoved(Node& root)\n{\n    ScriptForbiddenScope forbidScript;\n    EventDispatchForbiddenScope assertNoEventDispatch;\n    for (Node& node : NodeTraversal::inclusiveDescendantsOf(root)) {\n        if (!node.isContainerNode() && !node.isInTreeScope())\n            continue;\n        node.removedFrom(this);\n        for (ShadowRoot* shadowRoot = node.youngestShadowRoot(); shadowRoot; shadowRoot = shadowRoot->olderShadowRoot())\n            notifyNodeRemoved(*shadowRoot);\n    }\n}", "target": 0}
{"code": "static void vmx_queue_exception(struct kvm_vcpu *vcpu, unsigned nr,\n\t\t\t\tbool has_error_code, u32 error_code,\n\t\t\t\tbool reinject)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 intr_info = nr | INTR_INFO_VALID_MASK;\n\tif (!reinject && is_guest_mode(vcpu) &&\n\t    nested_vmx_check_exception(vcpu, nr))\n\t\treturn;\n\tif (has_error_code) {\n\t\tvmcs_write32(VM_ENTRY_EXCEPTION_ERROR_CODE, error_code);\n\t\tintr_info |= INTR_INFO_DELIVER_CODE_MASK;\n\t}\n\tif (vmx->rmode.vm86_active) {\n\t\tint inc_eip = 0;\n\t\tif (kvm_exception_is_soft(nr))\n\t\t\tinc_eip = vcpu->arch.event_exit_inst_len;\n\t\tif (kvm_inject_realmode_interrupt(vcpu, nr, inc_eip) != EMULATE_DONE)\n\t\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\treturn;\n\t}\n\tif (kvm_exception_is_soft(nr)) {\n\t\tvmcs_write32(VM_ENTRY_INSTRUCTION_LEN,\n\t\t\t     vmx->vcpu.arch.event_exit_inst_len);\n\t\tintr_info |= INTR_TYPE_SOFT_EXCEPTION;\n\t} else\n\t\tintr_info |= INTR_TYPE_HARD_EXCEPTION;\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD, intr_info);\n}", "target": 0}
{"code": "gopherSendComplete(const Comm::ConnectionPointer &conn, char *, size_t size, Comm::Flag errflag, int xerrno, void *data)\n{\n    GopherStateData *gopherState = (GopherStateData *) data;\n    StoreEntry *entry = gopherState->entry;\n    debugs(10, 5, conn << \" size: \" << size << \" errflag: \" << errflag);\n    if (size > 0) {\n        fd_bytes(conn->fd, size, FD_WRITE);\n        statCounter.server.all.kbytes_out += size;\n        statCounter.server.other.kbytes_out += size;\n    }\n    if (!entry->isAccepting()) {\n        debugs(10, 3, \"terminating due to bad \" << *entry);\n        gopherState->serverConn->close();\n        return;\n    }\n    if (errflag) {\n        const auto err = new ErrorState(ERR_WRITE_ERROR, Http::scServiceUnavailable, gopherState->fwd->request, gopherState->fwd->al);\n        err->xerrno = xerrno;\n        err->port = gopherState->fwd->request->url.port();\n        err->url = xstrdup(entry->url());\n        gopherState->fwd->fail(err);\n        gopherState->serverConn->close();\n        return;\n    }\n    entry->buffer();\n    gopherMimeCreate(gopherState);\n    switch (gopherState->type_id) {\n    case GOPHER_DIRECTORY:\n        gopherState->conversion = GopherStateData::HTML_DIR;\n        gopherState->HTML_header_added = 0;\n        break;\n    case GOPHER_INDEX:\n        gopherState->conversion = GopherStateData::HTML_INDEX_RESULT;\n        gopherState->HTML_header_added = 0;\n        break;\n    case GOPHER_CSO:\n        gopherState->conversion = GopherStateData::HTML_CSO_RESULT;\n        gopherState->cso_recno = 0;\n        gopherState->HTML_header_added = 0;\n        break;\n    default:\n        gopherState->conversion = GopherStateData::NORMAL;\n        entry->flush();\n    }\n    GopherStateData::DelayAwareRead(gopherState);\n}", "target": 1}
{"code": "cifs_find_smb_ses(struct TCP_Server_Info *server, char *username)\n{\n\tstruct list_head *tmp;\n\tstruct cifsSesInfo *ses;\n\twrite_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &server->smb_ses_list) {\n\t\tses = list_entry(tmp, struct cifsSesInfo, smb_ses_list);\n\t\tif (strncmp(ses->userName, username, MAX_USERNAME_SIZE))\n\t\t\tcontinue;\n\t\t++ses->ses_count;\n\t\twrite_unlock(&cifs_tcp_ses_lock);\n\t\treturn ses;\n\t}\n\twrite_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}", "target": 1}
{"code": "merged_1v_upsample(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n                   JDIMENSION *in_row_group_ctr,\n                   JDIMENSION in_row_groups_avail, JSAMPARRAY output_buf,\n                   JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)\n{\n  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n  (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr,\n                         output_buf + *out_row_ctr);\n  (*out_row_ctr)++;\n  (*in_row_group_ctr)++;\n}", "target": 1}
{"code": "cluster_hash_key_make (void *p)\n{\n  const struct cluster_list *cluster = p;\n  return jhash(cluster->list, cluster->length, 0);\n}", "target": 0}
{"code": "LUA_API void lua_upvaluejoin (lua_State *L, int fidx1, int n1,\n                                            int fidx2, int n2) {\n  LClosure *f1;\n  UpVal **up1 = getupvalref(L, fidx1, n1, &f1);\n  UpVal **up2 = getupvalref(L, fidx2, n2, NULL);\n  luaC_upvdeccount(L, *up1);\n  *up1 = *up2;\n  (*up1)->refcount++;\n  if (upisopen(*up1)) (*up1)->u.open.touched = 1;\n  luaC_upvalbarrier(L, *up1);\n}", "target": 1}
{"code": "void recovery_cipher_init(bool passphrase_protection, bool pin_protection,\n                          const char *language, const char *label, bool _enforce_wordlist,\n                          uint32_t _auto_lock_delay_ms, uint32_t _u2f_counter, bool _dry_run)\n{\n    enforce_wordlist = _enforce_wordlist;\n    dry_run = _dry_run;\n    if (!dry_run) {\n        if (pin_protection) {\n            if (!change_pin()) {\n                recovery_abort();\n                fsm_sendFailure(FailureType_Failure_ActionCancelled, \"PINs do not match\");\n                layoutHome();\n                return;\n            }\n        } else {\n            storage_setPin(\"\");\n        }\n        storage_setPassphraseProtected(passphrase_protection);\n        storage_setLanguage(language);\n        storage_setLabel(label);\n        storage_setAutoLockDelayMs(_auto_lock_delay_ms);\n        storage_setU2FCounter(_u2f_counter);\n    } else if (!pin_protect(\"Enter Your PIN\")) {\n        layoutHome();\n        return;\n    }\n    if (!confirm(ButtonRequestType_ButtonRequest_Other,\n                 dry_run ? \"Recovery Dry Run\" : \"Recovery\",\n                 \"When entering your recovery seed, use the substitution cipher \"\n                 \"and check that each word shows up correctly on the screen.\")) {\n        fsm_sendFailure(FailureType_Failure_ActionCancelled, \"Recovery cancelled\");\n        if (!dry_run)\n            storage_reset();\n        layoutHome();\n        return;\n    }\n    memset(mnemonic, 0, sizeof(mnemonic) / sizeof(char));\n    awaiting_character = true;\n    recovery_started = true;\n    next_character();\n}", "target": 0}
{"code": "GopherStateData::DelayAwareRead(GopherStateData *gopherState)\n{\n    const auto &conn = gopherState->serverConn;\n    if (!Comm::IsConnOpen(conn) || fd_table[conn->fd].closing()) {\n        debugs(10, 3, \"will not read from \" << conn);\n        return;\n    }\n    const auto amountToRead = gopherState->entry->bytesWanted(Range<size_t>(0, BUFSIZ));\n    if (amountToRead <= 0) {\n        AsyncCall::Pointer delayCall = asyncCall(10, 3, \"GopherStateData::DelayAwareRead\",\n                                       cbdataDialer(&GopherStateData::DelayAwareRead, gopherState));\n        gopherState->entry->mem().delayRead(delayCall);\n        return;\n    }\n    AsyncCall::Pointer readCall = commCbCall(5, 5, \"gopherReadReply\", CommIoCbPtrFun(gopherReadReply, gopherState));\n    comm_read(conn, gopherState->replybuf, amountToRead, readCall);\n}", "target": 1}
{"code": "cfm_network_addr_print(netdissect_options *ndo,\n                       register const u_char *tptr)\n{\n    u_int network_addr_type;\n    u_int hexdump =  FALSE;\n    network_addr_type = *tptr;\n    ND_PRINT((ndo, \"\\n\\t  Network Address Type %s (%u)\",\n           tok2str(af_values, \"Unknown\", network_addr_type),\n           network_addr_type));\n    switch(network_addr_type) {\n    case AFNUM_INET:\n        ND_PRINT((ndo, \", %s\", ipaddr_string(ndo, tptr + 1)));\n        break;\n    case AFNUM_INET6:\n        ND_PRINT((ndo, \", %s\", ip6addr_string(ndo, tptr + 1)));\n        break;\n    default:\n        hexdump = TRUE;\n        break;\n    }\n    return hexdump;\n}", "target": 1}
{"code": "be32enc_vect(unsigned char *dst, const uint32_t *src, size_t len)\n{\n  size_t i;\n  uint32_t *d;\n  for (i = 0; i < len / 4; i++) {\n    d = (uint32_t *) (dst + i * 4);\n    *d = folly::Endian::big32(src[i]);\n  }\n}", "target": 1}
{"code": "_isBidi (const uint32_t *label, size_t llen)\n{\n  while (llen-- > 0) {\n    int bc = uc_bidi_category (*label++);\n    if (bc == UC_BIDI_R || bc == UC_BIDI_AL || bc == UC_BIDI_AN)\n      return 1;\n  }\n  return 0;\n}", "target": 1}
{"code": "void Archive::Seek(int64 Offset,int Method)\n{\n  if (!QOpen.Seek(Offset,Method))\n    File::Seek(Offset,Method);\n}", "target": 1}
{"code": "void hincrbyfloatCommand(client *c) {\n    long double value, incr;\n    long long ll;\n    robj *o;\n    sds new;\n    unsigned char *vstr;\n    unsigned int vlen;\n    if (getLongDoubleFromObjectOrReply(c,c->argv[3],&incr,NULL) != C_OK) return;\n    if (isnan(incr) || isinf(incr)) {\n        addReplyError(c,\"value is NaN or Infinity\");\n        return;\n    }\n    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;\n    if (hashTypeGetValue(o,c->argv[2]->ptr,&vstr,&vlen,&ll) == C_OK) {\n        if (vstr) {\n            if (string2ld((char*)vstr,vlen,&value) == 0) {\n                addReplyError(c,\"hash value is not a float\");\n                return;\n            }\n        } else {\n            value = (long double)ll;\n        }\n    } else {\n        value = 0;\n    }\n    value += incr;\n    if (isnan(value) || isinf(value)) {\n        addReplyError(c,\"increment would produce NaN or Infinity\");\n        return;\n    }\n    char buf[MAX_LONG_DOUBLE_CHARS];\n    int len = ld2string(buf,sizeof(buf),value,LD_STR_HUMAN);\n    new = sdsnewlen(buf,len);\n    hashTypeSet(o,c->argv[2]->ptr,new,HASH_SET_TAKE_VALUE);\n    addReplyBulkCBuffer(c,buf,len);\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_HASH,\"hincrbyfloat\",c->argv[1],c->db->id);\n    server.dirty++;\n    robj *newobj;\n    newobj = createRawStringObject(buf,len);\n    rewriteClientCommandArgument(c,0,shared.hset);\n    rewriteClientCommandArgument(c,3,newobj);\n    decrRefCount(newobj);\n}", "target": 0}
{"code": "void LIRGenerator::do_If(If* x) {\n  assert(x->number_of_sux() == 2, \"inconsistency\");\n  ValueTag tag = x->x()->type()->tag();\n  bool is_safepoint = x->is_safepoint();\n  If::Condition cond = x->cond();\n  LIRItem xitem(x->x(), this);\n  LIRItem yitem(x->y(), this);\n  LIRItem* xin = &xitem;\n  LIRItem* yin = &yitem;\n  if (tag == longTag) {\n    if (cond == If::gtr || cond == If::leq) {\n      cond = Instruction::mirror(cond);\n      xin = &yitem;\n      yin = &xitem;\n    }\n    xin->set_destroys_register();\n  }\n  xin->load_item();\n  if (tag == longTag && yin->is_constant() && yin->get_jlong_constant() == 0 && (cond == If::eql || cond == If::neq)) {\n    yin->dont_load_item();\n  } else if (tag == longTag || tag == floatTag || tag == doubleTag) {\n    yin->load_item();\n  } else {\n    yin->dont_load_item();\n  }\n  LIR_Opr left = xin->result();\n  LIR_Opr right = yin->result();\n  set_no_result(x);\n  if (x->is_safepoint()) {\n    increment_backedge_counter_conditionally(lir_cond(cond), left, right, state_for(x, x->state_before()),\n        x->tsux()->bci(), x->fsux()->bci(), x->profiled_bci());\n    __ safepoint(safepoint_poll_register(), state_for(x, x->state_before()));\n  }\n  __ cmp(lir_cond(cond), left, right);\n  profile_branch(x, cond);\n  move_to_phi(x->state());\n  if (x->x()->type()->is_float_kind()) {\n    __ branch(lir_cond(cond), right->type(), x->tsux(), x->usux());\n  } else {\n    __ branch(lir_cond(cond), right->type(), x->tsux());\n  }\n  assert(x->default_sux() == x->fsux(), \"wrong destination above\");\n  __ jump(x->default_sux());\n}", "target": 0}
{"code": "void bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)\n\t{\n\tBN_ULONG t1,t2;\n\tBN_ULONG c1,c2,c3;\n\tc1=0;\n\tc2=0;\n\tc3=0;\n\tsqr_add_c(a,0,c1,c2,c3);\n\tr[0]=c1;\n\tc1=0;\n\tsqr_add_c2(a,1,0,c2,c3,c1);\n\tr[1]=c2;\n\tc2=0;\n\tsqr_add_c(a,1,c3,c1,c2);\n\tsqr_add_c2(a,2,0,c3,c1,c2);\n\tr[2]=c3;\n\tc3=0;\n\tsqr_add_c2(a,3,0,c1,c2,c3);\n\tsqr_add_c2(a,2,1,c1,c2,c3);\n\tr[3]=c1;\n\tc1=0;\n\tsqr_add_c(a,2,c2,c3,c1);\n\tsqr_add_c2(a,3,1,c2,c3,c1);\n\tr[4]=c2;\n\tc2=0;\n\tsqr_add_c2(a,3,2,c3,c1,c2);\n\tr[5]=c3;\n\tc3=0;\n\tsqr_add_c(a,3,c1,c2,c3);\n\tr[6]=c1;\n\tr[7]=c2;\n\t}", "target": 1}
{"code": "static int hclge_tm_schd_mode_vnet_base_cfg(struct hclge_vport *vport)\n{\n\tstruct hnae3_knic_private_info *kinfo = &vport->nic.kinfo;\n\tstruct hclge_dev *hdev = vport->back;\n\tint ret;\n\tu8 i;\n\tret = hclge_tm_pri_schd_mode_cfg(hdev, vport->vport_id);\n\tif (ret)\n\t\treturn ret;\n\tfor (i = 0; i < kinfo->num_tc; i++) {\n\t\tu8 sch_mode = hdev->tm_info.tc_info[i].tc_sch_mode;\n\t\tret = hclge_tm_qs_schd_mode_cfg(hdev, vport->qs_offset + i,\n\t\t\t\t\t\tsch_mode);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "GF_Err dac3_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DEC3;\n\te = gf_isom_box_write_header(s, bs);\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DAC3;\n\tif (e) return e;\n\te = gf_odf_ac3_cfg_write_bs(&ptr->cfg, bs);\n\tif (e) return e;\n\tif (ptr->cfg.atmos_ec3_ext || ptr->cfg.complexity_index_type) {\n\t\tgf_bs_write_int(bs, 0, 7);\n\t\tgf_bs_write_int(bs, ptr->cfg.atmos_ec3_ext, 1);\n\t\tgf_bs_write_u8(bs, ptr->cfg.complexity_index_type);\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "int remove_file(struct augeas *aug, struct tree *tree) {\n    char *path = NULL;\n    const char *filename = NULL;\n    const char *err_status = NULL;\n    char *dyn_err_status = NULL;\n    char *augsave = NULL, *augorig = NULL, *augorig_canon = NULL;\n    int r;\n    path = path_of_tree(tree);\n    if (path == NULL) {\n        err_status = \"path_of_tree\";\n        goto error;\n    }\n    filename = path + strlen(AUGEAS_META_FILES);\n    if ((augorig = strappend(aug->root, filename + 1)) == NULL) {\n        err_status = \"root_file\";\n        goto error;\n    }\n    augorig_canon = canonicalize_file_name(augorig);\n    if (augorig_canon == NULL) {\n        if (errno == ENOENT) {\n            goto done;\n        } else {\n            err_status = \"canon_augorig\";\n            goto error;\n        }\n    }\n    r = file_saved_event(aug, path + strlen(AUGEAS_META_TREE));\n    if (r < 0) {\n        err_status = \"saved_event\";\n        goto error;\n    }\n    if (aug->flags & AUG_SAVE_NOOP)\n        goto done;\n    if (aug->flags & AUG_SAVE_BACKUP) {\n        r = asprintf(&augsave, \"%s\" EXT_AUGSAVE, augorig_canon);\n        if (r == -1) {\n            augsave = NULL;\n                goto error;\n        }\n        r = clone_file(augorig_canon, augsave, &err_status, 1, 1);\n        if (r != 0) {\n            dyn_err_status = strappend(err_status, \"_augsave\");\n            goto error;\n        }\n    } else {\n        r = unlink(augorig_canon);\n        if (r < 0) {\n            err_status = \"unlink_orig\";\n            goto error;\n        }\n    }\n    tree_unlink(tree);\n done:\n    free(path);\n    free(augorig);\n    free(augorig_canon);\n    free(augsave);\n    return 0;\n error:\n    {\n        const char *emsg =\n            dyn_err_status == NULL ? err_status : dyn_err_status;\n        store_error(aug, filename, path, emsg, errno, NULL, NULL);\n    }\n    free(path);\n    free(augorig);\n    free(augorig_canon);\n    free(augsave);\n    free(dyn_err_status);\n    return -1;\n}", "target": 0}
{"code": "static int snd_timer_dev_disconnect(struct snd_device *device)\n{\n\tstruct snd_timer *timer = device->device_data;\n\tstruct snd_timer_instance *ti;\n\tmutex_lock(&register_mutex);\n\tlist_del_init(&timer->device_list);\n\tlist_for_each_entry(ti, &timer->open_list_head, open_list) {\n\t\tif (ti->disconnect)\n\t\t\tti->disconnect(ti);\n\t}\n\tmutex_unlock(&register_mutex);\n\treturn 0;\n}", "target": 0}
{"code": "static int nl80211_netlink_notify(struct notifier_block * nb,\n\t\t\t\t  unsigned long state,\n\t\t\t\t  void *_notify)\n{\n\tstruct netlink_notify *notify = _notify;\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\tstruct cfg80211_beacon_registration *reg, *tmp;\n\tif (state != NETLINK_URELEASE)\n\t\treturn NOTIFY_DONE;\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(rdev, &cfg80211_rdev_list, list) {\n\t\tlist_for_each_entry_rcu(wdev, &rdev->wdev_list, list)\n\t\t\tcfg80211_mlme_unregister_socket(wdev, notify->portid);\n\t\tspin_lock_bh(&rdev->beacon_registrations_lock);\n\t\tlist_for_each_entry_safe(reg, tmp, &rdev->beacon_registrations,\n\t\t\t\t\t list) {\n\t\t\tif (reg->nlportid == notify->portid) {\n\t\t\t\tlist_del(&reg->list);\n\t\t\t\tkfree(reg);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_bh(&rdev->beacon_registrations_lock);\n\t}\n\trcu_read_unlock();\n\treturn NOTIFY_DONE;\n}", "target": 0}
{"code": "void LibRaw::adjust_bl()\n{\n  int clear_repeat=0;\n   if (O.user_black >= 0) \n     {\n       C.black = O.user_black;\n       clear_repeat = 1;\n     }\n   for(int i=0; i<4; i++)\n     if(O.user_cblack[i]>-1000000)\n       {\n         C.cblack[i] = O.user_cblack[i];\n         clear_repeat  = 1;\n       }\n   if(clear_repeat)\n     C.cblack[4]=C.cblack[5]=0;\n   if (imgdata.idata.filters > 1000 && (C.cblack[4]+1)/2 == 1 && (C.cblack[5]+1)/2 == 1) \n   {\n\t   for(int c=0; c<4; c++)\n\t\t   C.cblack[c] += C.cblack[6 + c/2 % C.cblack[4] * C.cblack[5] + c%2 % C.cblack[5]];\n\t   C.cblack[4]=C.cblack[5]=0;\n   }\n   else if(imgdata.idata.filters <= 1000 && C.cblack[4]==1 && C.cblack[5]==1) \n   {\n\t   for(int c=0; c<4; c++)\n\t\t   C.cblack[c] += C.cblack[6];\n\t   C.cblack[4]=C.cblack[5]=0;\n   }\n  int i = C.cblack[3];\n  int c;\n  for(c=0;c<3;c++) if (i > C.cblack[c]) i = C.cblack[c];\n  for(c=0;c<4;c++) C.cblack[c] -= i; \n  C.black += i;\n  if(C.cblack[4] && C.cblack[5])\n    {\n      i = C.cblack[6];\n      for(c=1; c<C.cblack[4]*C.cblack[5]; c++)\n        if(i>C.cblack[6+c]) i = C.cblack[6+c];\n      int nonz=0;\n      for(c=0; c<C.cblack[4]*C.cblack[5]; c++)\n        {\n          C.cblack[6+c]-=i;\n          if(C.cblack[6+c])nonz++;\n        }\n      C.black +=i;\n      if(!nonz)\n        C.cblack[4] = C.cblack[5] = 0;\n    }\n  for(c=0;c<4;c++) C.cblack[c] += C.black; \n}", "target": 0}
{"code": "vhost_user_check_and_alloc_queue_pair(struct virtio_net *dev,\n\t\t\tstruct vhu_msg_context *ctx)\n{\n\tuint32_t vring_idx;\n\tswitch (ctx->msg.request.master) {\n\tcase VHOST_USER_SET_VRING_KICK:\n\tcase VHOST_USER_SET_VRING_CALL:\n\tcase VHOST_USER_SET_VRING_ERR:\n\t\tvring_idx = ctx->msg.payload.u64 & VHOST_USER_VRING_IDX_MASK;\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_NUM:\n\tcase VHOST_USER_SET_VRING_BASE:\n\tcase VHOST_USER_GET_VRING_BASE:\n\tcase VHOST_USER_SET_VRING_ENABLE:\n\t\tvring_idx = ctx->msg.payload.state.index;\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_ADDR:\n\t\tvring_idx = ctx->msg.payload.addr.index;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tif (vring_idx >= VHOST_MAX_VRING) {\n\t\tVHOST_LOG_CONFIG(ERR, \"(%s) invalid vring index: %u\\n\", dev->ifname, vring_idx);\n\t\treturn -1;\n\t}\n\tif (dev->virtqueue[vring_idx])\n\t\treturn 0;\n\treturn alloc_vring_queue(dev, vring_idx);\n}", "target": 1}
{"code": "mp_join_print(netdissect_options *ndo,\n              const u_char *opt, u_int opt_len, u_char flags)\n{\n        const struct mp_join *mpj = (const struct mp_join *) opt;\n        if (!(opt_len == 12 && flags & TH_SYN) &&\n            !(opt_len == 16 && (flags & (TH_SYN | TH_ACK)) == (TH_SYN | TH_ACK)) &&\n            !(opt_len == 24 && flags & TH_ACK))\n                return 0;\n        if (opt_len != 24) {\n                if (mpj->sub_b & MP_JOIN_B)\n                        ND_PRINT((ndo, \" backup\"));\n                ND_PRINT((ndo, \" id %u\", mpj->addr_id));\n        }\n        switch (opt_len) {\n        case 12: \n                ND_PRINT((ndo, \" token 0x%x\" \" nonce 0x%x\",\n                        EXTRACT_32BITS(mpj->u.syn.token),\n                        EXTRACT_32BITS(mpj->u.syn.nonce)));\n                break;\n        case 16: \n                ND_PRINT((ndo, \" hmac 0x%\" PRIx64 \" nonce 0x%x\",\n                        EXTRACT_64BITS(mpj->u.synack.mac),\n                        EXTRACT_32BITS(mpj->u.synack.nonce)));\n                break;\n        case 24: {\n                size_t i;\n                ND_PRINT((ndo, \" hmac 0x\"));\n                for (i = 0; i < sizeof(mpj->u.ack.mac); ++i)\n                        ND_PRINT((ndo, \"%02x\", mpj->u.ack.mac[i]));\n        }\n        default:\n                break;\n        }\n        return 1;\n}", "target": 1}
{"code": "  CdsIntegrationTest()\n      : HttpIntegrationTest(Http::CodecType::HTTP2, ipVersion(),\n                            ConfigHelper::discoveredClustersBootstrap(\n                                sotwOrDelta() == Grpc::SotwOrDelta::Sotw ||\n                                        sotwOrDelta() == Grpc::SotwOrDelta::UnifiedSotw\n                                    ? \"GRPC\"\n                                    : \"DELTA_GRPC\")) {\n    if (sotwOrDelta() == Grpc::SotwOrDelta::UnifiedSotw ||\n        sotwOrDelta() == Grpc::SotwOrDelta::UnifiedDelta) {\n      config_helper_.addRuntimeOverride(\"envoy.reloadable_features.unified_mux\", \"true\");\n    }\n    use_lds_ = false;\n    sotw_or_delta_ = sotwOrDelta();\n  }", "target": 1}
{"code": "void RGWGetObjTags_ObjStore_S3::send_response_data(bufferlist& bl)\n{\n  dump_errno(s);\n  end_header(s, this, \"application/xml\");\n  dump_start(s);\n  s->formatter->open_object_section_in_ns(\"Tagging\", XMLNS_AWS_S3);\n  s->formatter->open_object_section(\"TagSet\");\n  if (has_tags){\n    RGWObjTagSet_S3 tagset;\n    auto iter = bl.cbegin();\n    try {\n      tagset.decode(iter);\n    } catch (buffer::error& err) {\n      ldout(s->cct,0) << \"ERROR: caught buffer::error, couldn't decode TagSet\" << dendl;\n      op_ret= -EIO;\n      return;\n    }\n    tagset.dump_xml(s->formatter);\n  }\n  s->formatter->close_section();\n  s->formatter->close_section();\n  rgw_flush_formatter_and_reset(s, s->formatter);\n}", "target": 0}
{"code": "atoi_err(const char *nptr, int *val)\n{\n\tconst char *errstr = NULL;\n\tlong long num;\n\tif (nptr == NULL || *nptr == '\\0')\n\t\treturn \"missing\";\n\tnum = strtonum(nptr, 0, INT_MAX, &errstr);\n\tif (errstr == NULL)\n\t\t*val = (int)num;\n\treturn errstr;\n}", "target": 0}
{"code": "__delta_head_destroy(struct delta_head **delta_head)\n{\n\tdelta_head_destroy(*delta_head);\n}", "target": 1}
{"code": "static void *proc_pid_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error = -EACCES;\n\tpath_put(&nd->path);\n\tif (!proc_fd_access_allowed(inode))\n\t\tgoto out;\n\terror = PROC_I(inode)->op.proc_get_link(inode, &nd->path);\n\tnd->last_type = LAST_BIND;\nout:\n\treturn ERR_PTR(error);\n}", "target": 1}
{"code": "irc_server_sasl_enabled (struct t_irc_server *server)\n{\n    int sasl_mechanism, rc;\n    char *sasl_username, *sasl_password;\n    const char *sasl_key;\n    sasl_mechanism = IRC_SERVER_OPTION_INTEGER(\n        server, IRC_SERVER_OPTION_SASL_MECHANISM);\n    sasl_username = irc_server_eval_expression (\n        server,\n        IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_SASL_USERNAME));\n    sasl_password = irc_server_eval_expression (\n        server,\n        IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_SASL_PASSWORD));\n    sasl_key = IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_SASL_KEY);\n    rc = ((sasl_mechanism == IRC_SASL_MECHANISM_EXTERNAL)\n          || ((sasl_mechanism == IRC_SASL_MECHANISM_ECDSA_NIST256P_CHALLENGE)\n              && sasl_username && sasl_username[0]\n              && sasl_key && sasl_key[0])\n          || (sasl_username && sasl_username[0]\n              && sasl_password && sasl_password[0])) ? 1 : 0;\n    if (sasl_username)\n        free (sasl_username);\n    if (sasl_password)\n        free (sasl_password);\n    return rc;\n}", "target": 0}
{"code": "sctp_disposition_t sctp_sf_ootb(struct net *net,\n\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\tvoid *arg,\n\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sk_buff *skb = chunk->skb;\n\tsctp_chunkhdr_t *ch;\n\tsctp_errhdr_t *err;\n\t__u8 *ch_end;\n\tint ootb_shut_ack = 0;\n\tint ootb_cookie_ack = 0;\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\tch = (sctp_chunkhdr_t *) chunk->chunk_hdr;\n\tdo {\n\t\tif (ntohs(ch->length) < sizeof(sctp_chunkhdr_t))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\t\tif (SCTP_CID_SHUTDOWN_ACK == ch->type)\n\t\t\tootb_shut_ack = 1;\n\t\tif (SCTP_CID_ABORT == ch->type)\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\tif (SCTP_CID_COOKIE_ACK == ch->type)\n\t\t\tootb_cookie_ack = 1;\n\t\tif (SCTP_CID_ERROR == ch->type) {\n\t\t\tsctp_walk_errors(err, ch) {\n\t\t\t\tif (SCTP_ERROR_STALE_COOKIE == err->cause) {\n\t\t\t\t\tootb_cookie_ack = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tch_end = ((__u8 *)ch) + SCTP_PAD4(ntohs(ch->length));\n\t\tif (ch_end > skb_tail_pointer(skb))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\t\tch = (sctp_chunkhdr_t *) ch_end;\n\t} while (ch_end < skb_tail_pointer(skb));\n\tif (ootb_shut_ack)\n\t\treturn sctp_sf_shut_8_4_5(net, ep, asoc, type, arg, commands);\n\telse if (ootb_cookie_ack)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\telse\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n}", "target": 1}
{"code": "_zip_u2d_time(time_t time, unsigned short *dtime, unsigned short *ddate)\n{\n    struct tm *tm;\n    tm = localtime(&time);\n    *ddate = ((tm->tm_year+1900-1980)<<9) + ((tm->tm_mon+1)<<5)\n\t+ tm->tm_mday;\n    *dtime = ((tm->tm_hour)<<11) + ((tm->tm_min)<<5)\n\t+ ((tm->tm_sec)>>1);\n    return;\n}", "target": 0}
{"code": "find_next_quote(\n    char_u\t*line,\n    int\t\tcol,\n    int\t\tquotechar,\n    char_u\t*escape)\t\n{\n    int\t\tc;\n    for (;;)\n    {\n\tc = line[col];\n\tif (c == NUL)\n\t    return -1;\n\telse if (escape != NULL && vim_strchr(escape, c))\n\t    ++col;\n\telse if (c == quotechar)\n\t    break;\n\tif (has_mbyte)\n\t    col += (*mb_ptr2len)(line + col);\n\telse\n\t    ++col;\n    }\n    return col;\n}", "target": 1}
{"code": "bool UnbufferedAsioTlsStream::IsVerifyOK() const\n{\n\treturn m_VerifyOK;\n}", "target": 1}
{"code": "void PCM::runPull()\n{\n\tAFframecount framesToRead = m_outChunk->frameCount;\n\tif (m_track->totalfframes != -1 &&\n\t\tm_track->nextfframe + framesToRead > m_track->totalfframes)\n\t{\n\t\tframesToRead = m_track->totalfframes - m_track->nextfframe;\n\t}\n\tssize_t bytesRead = read(m_outChunk->buffer, m_bytesPerFrame * framesToRead);\n\tAFframecount framesRead = bytesRead >= 0 ? bytesRead / m_bytesPerFrame : 0;\n\tCHNK(printf(\"reading %\" AF_FRAMECOUNT_PRINT_FMT \" frames from pcm file \"\n\t\t\"(got %\" AF_FRAMECOUNT_PRINT_FMT \")\\n\",\n\t\tframesToRead, framesRead));\n\tm_track->nextfframe += framesRead;\n\tm_track->fpos_next_frame += (framesRead>0) ? framesRead * m_bytesPerFrame : 0;\n\tassert(!canSeek() || (tell() == m_track->fpos_next_frame));\n\tif (framesRead != framesToRead && m_track->totalfframes != -1)\n\t{\n\t\tif (m_track->filemodhappy)\n\t\t{\n\t\t\t_af_error(AF_BAD_READ,\n\t\t\t\t\"file missing data -- read %d frames, \"\n\t\t\t\t\"should be %d\",\n\t\t\t\tm_track->nextfframe,\n\t\t\t\tm_track->totalfframes);\n\t\t\tm_track->filemodhappy = false;\n\t\t}\n\t}\n\tm_outChunk->frameCount = framesRead;\n}", "target": 0}
{"code": "url_escape_1 (const char *s, unsigned char mask, bool allow_passthrough)\n{\n  const char *p1;\n  char *p2, *newstr;\n  int newlen;\n  int addition = 0;\n  for (p1 = s; *p1; p1++)\n    if (urlchr_test (*p1, mask))\n      addition += 2;            \n  if (!addition)\n    return allow_passthrough ? (char *)s : xstrdup (s);\n  newlen = (p1 - s) + addition;\n  newstr = xmalloc (newlen + 1);\n  p1 = s;\n  p2 = newstr;\n  while (*p1)\n    {\n      if (urlchr_test (*p1, mask))\n        {\n          unsigned char c = *p1++;\n          *p2++ = '%';\n          *p2++ = XNUM_TO_DIGIT (c >> 4);\n          *p2++ = XNUM_TO_DIGIT (c & 0xf);\n        }\n      else\n        *p2++ = *p1++;\n    }\n  assert (p2 - newstr == newlen);\n  *p2 = '\\0';\n  return newstr;\n}", "target": 0}
{"code": "void RGWPutObj_ObjStore_S3::send_response()\n{\n  if (op_ret) {\n    set_req_state_err(s, op_ret);\n    dump_errno(s);\n  } else {\n    if (s->cct->_conf->rgw_s3_success_create_obj_status) {\n      op_ret = get_success_retcode(\n\ts->cct->_conf->rgw_s3_success_create_obj_status);\n      set_req_state_err(s, op_ret);\n    }\n    if (copy_source.empty()) {\n      dump_errno(s);\n      dump_etag(s, etag);\n      dump_content_length(s, 0);\n      dump_header_if_nonempty(s, \"x-amz-version-id\", version_id);\n      for (auto &it : crypt_http_responses)\n        dump_header(s, it.first, it.second);\n    } else {\n      dump_errno(s);\n      dump_header_if_nonempty(s, \"x-amz-version-id\", version_id);\n      end_header(s, this, \"application/xml\");\n      dump_start(s);\n      struct tm tmp;\n      utime_t ut(mtime);\n      time_t secs = (time_t)ut.sec();\n      gmtime_r(&secs, &tmp);\n      char buf[TIME_BUF_SIZE];\n      s->formatter->open_object_section_in_ns(\"CopyPartResult\",\n          \"http:\n      if (strftime(buf, sizeof(buf), \"%Y-%m-%dT%T.000Z\", &tmp) > 0) {\n        s->formatter->dump_string(\"LastModified\", buf);\n      }\n      s->formatter->dump_string(\"ETag\", etag);\n      s->formatter->close_section();\n      rgw_flush_formatter_and_reset(s, s->formatter);\n      return;\n    }\n  }\n  if (append) {\n    if (op_ret == 0 || op_ret == -ERR_POSITION_NOT_EQUAL_TO_LENGTH) {\n      dump_header(s, \"x-rgw-next-append-position\", cur_accounted_size);\n    }\n  }\n  if (s->system_request && !real_clock::is_zero(mtime)) {\n    dump_epoch_header(s, \"Rgwx-Mtime\", mtime);\n  }\n  end_header(s, this);\n}", "target": 0}
{"code": "void PDPClient::perform_builtin_endpoints_matching(\n        const ParticipantProxyData& pdata)\n{\n    if (mp_builtin->mp_WLP != nullptr)\n    {\n        mp_builtin->mp_WLP->assignRemoteEndpoints(pdata);\n    }\n}", "target": 1}
{"code": "cardos_put_data_oci(sc_card_t *card,\n\t\t\tstruct sc_cardctl_cardos_obj_info *args)\n{\n\tsc_apdu_t\tapdu;\n\tint\t\tr;\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tmemset(&apdu, 0, sizeof(apdu));\n\tapdu.cse = SC_APDU_CASE_3_SHORT;\n\tapdu.cla = 0x00;\n\tapdu.ins = 0xda;\n\tapdu.p1  = 0x01;\n\tapdu.p2  = 0x6e;\n\tapdu.lc  = args->len;\n\tapdu.data = args->data;\n\tapdu.datalen = args->len;\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r, \"Card returned error\");\n\tLOG_FUNC_RETURN(card->ctx, r);\n}", "target": 0}
{"code": "njs_string_prototype_char_at(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    size_t             length;\n    int64_t            start;\n    njs_int_t          ret;\n    njs_slice_prop_t   slice;\n    njs_string_prop_t  string;\n    ret = njs_string_object_validate(vm, njs_argument(args, 0));\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    slice.string_length = njs_string_prop(&string, njs_argument(args, 0));\n    ret = njs_value_to_integer(vm, njs_arg(args, nargs, 1), &start);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    length = 1;\n    if (start < 0 || start >= (int64_t) slice.string_length) {\n        start = 0;\n        length = 0;\n    }\n    slice.start = start;\n    slice.length = length;\n    return njs_string_slice(vm, &vm->retval, &string, &slice);\n}", "target": 0}
{"code": "static inline struct sem_array *sem_lock_check(struct ipc_namespace *ns,\n\t\t\t\t\t\tint id)\n{\n\tstruct kern_ipc_perm *ipcp = ipc_lock_check(&sem_ids(ns), id);\n\tif (IS_ERR(ipcp))\n\t\treturn ERR_CAST(ipcp);\n\treturn container_of(ipcp, struct sem_array, sem_perm);\n}", "target": 1}
{"code": "static void vnc_display_close(VncDisplay *vd)\n{\n    if (!vd) {\n        return;\n    }\n    vd->is_unix = false;\n    if (vd->listener) {\n        qio_net_listener_disconnect(vd->listener);\n        object_unref(OBJECT(vd->listener));\n    }\n    vd->listener = NULL;\n    if (vd->wslistener) {\n        qio_net_listener_disconnect(vd->wslistener);\n        object_unref(OBJECT(vd->wslistener));\n    }\n    vd->wslistener = NULL;\n    vd->auth = VNC_AUTH_INVALID;\n    vd->subauth = VNC_AUTH_INVALID;\n    if (vd->tlscreds) {\n        object_unparent(OBJECT(vd->tlscreds));\n        vd->tlscreds = NULL;\n    }\n    if (vd->tlsauthz) {\n        object_unparent(OBJECT(vd->tlsauthz));\n        vd->tlsauthz = NULL;\n    }\n    g_free(vd->tlsauthzid);\n    vd->tlsauthzid = NULL;\n    if (vd->lock_key_sync) {\n        qemu_remove_led_event_handler(vd->led);\n        vd->led = NULL;\n    }\n#ifdef CONFIG_VNC_SASL\n    if (vd->sasl.authz) {\n        object_unparent(OBJECT(vd->sasl.authz));\n        vd->sasl.authz = NULL;\n    }\n    g_free(vd->sasl.authzid);\n    vd->sasl.authzid = NULL;\n#endif\n}", "target": 0}
{"code": "int wait_for_key_construction(struct key *key, bool intr)\n{\n\tint ret;\n\tret = wait_on_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT,\n\t\t\t  intr ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE);\n\tif (ret)\n\t\treturn -ERESTARTSYS;\n\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags)) {\n\t\tsmp_rmb();\n\t\treturn key->reject_error;\n\t}\n\treturn key_validate(key);\n}", "target": 1}
{"code": "static void csi_X(struct vc_data *vc, int vpar) \n{\t\t\t\t\t  \n\tint count;\n\tif (!vpar)\n\t\tvpar++;\n\tcount = (vpar > vc->vc_cols - vc->vc_x) ? (vc->vc_cols - vc->vc_x) : vpar;\n\tvc_uniscr_clear_line(vc, vc->vc_x, count);\n\tscr_memsetw((unsigned short *)vc->vc_pos, vc->vc_video_erase_char, 2 * count);\n\tif (con_should_update(vc))\n\t\tvc->vc_sw->con_clear(vc, vc->vc_y, vc->vc_x, 1, count);\n\tvc->vc_need_wrap = 0;\n}", "target": 0}
{"code": "selaGetCombName(SELA    *sela,\n                l_int32  size,\n                l_int32  direction)\n{\nchar    *selname;\nchar     combname[L_BUF_SIZE];\nl_int32  i, nsels, sx, sy, found;\nSEL     *sel;\n    PROCNAME(\"selaGetCombName\");\n    if (!sela)\n        return (char *)ERROR_PTR(\"sela not defined\", procName, NULL);\n    if (direction != L_HORIZ && direction != L_VERT)\n        return (char *)ERROR_PTR(\"invalid direction\", procName, NULL);\n    if (direction == L_HORIZ)\n        snprintf(combname, L_BUF_SIZE, \"sel_comb_%dh\", size);\n    else  \n        snprintf(combname, L_BUF_SIZE, \"sel_comb_%dv\", size);\n    found = FALSE;\n    nsels = selaGetCount(sela);\n    for (i = 0; i < nsels; i++) {\n        sel = selaGetSel(sela, i);\n        selGetParameters(sel, &sy, &sx, NULL, NULL);\n        if (sy != 1 && sx != 1)  \n            continue;\n        selname = selGetName(sel);\n        if (!strcmp(selname, combname)) {\n            found = TRUE;\n            break;\n        }\n    }\n    if (found)\n        return stringNew(selname);\n    else\n        return (char *)ERROR_PTR(\"sel not found\", procName, NULL);\n}", "target": 1}
{"code": "void *address_space_map(AddressSpace *as,\n                        hwaddr addr,\n                        hwaddr *plen,\n                        bool is_write)\n{\n    hwaddr len = *plen;\n    hwaddr done = 0;\n    hwaddr l, xlat, base;\n    MemoryRegion *mr, *this_mr;\n    ram_addr_t raddr;\n    if (len == 0) {\n        return NULL;\n    }\n    l = len;\n    rcu_read_lock();\n    mr = address_space_translate(as, addr, &xlat, &l, is_write);\n    if (!memory_access_is_direct(mr, is_write)) {\n        if (atomic_xchg(&bounce.in_use, true)) {\n            rcu_read_unlock();\n            return NULL;\n        }\n        l = MIN(l, TARGET_PAGE_SIZE);\n        bounce.buffer = qemu_memalign(TARGET_PAGE_SIZE, l);\n        bounce.addr = addr;\n        bounce.len = l;\n        memory_region_ref(mr);\n        bounce.mr = mr;\n        if (!is_write) {\n            address_space_read(as, addr, MEMTXATTRS_UNSPECIFIED,\n                               bounce.buffer, l);\n        }\n        rcu_read_unlock();\n        *plen = l;\n        return bounce.buffer;\n    }\n    base = xlat;\n    raddr = memory_region_get_ram_addr(mr);\n    for (;;) {\n        len -= l;\n        addr += l;\n        done += l;\n        if (len == 0) {\n            break;\n        }\n        l = len;\n        this_mr = address_space_translate(as, addr, &xlat, &l, is_write);\n        if (this_mr != mr || xlat != base + done) {\n            break;\n        }\n    }\n    memory_region_ref(mr);\n    rcu_read_unlock();\n    *plen = done;\n    return qemu_ram_ptr_length(raddr + base, plen);\n}", "target": 0}
{"code": "trad_enc_update_keys(struct trad_enc_ctx *ctx, uint8_t c)\n{\n\tuint8_t t;\n#define CRC32(c, b) (crc32(c ^ 0xffffffffUL, &b, 1) ^ 0xffffffffUL)\n\tctx->keys[0] = CRC32(ctx->keys[0], c);\n\tctx->keys[1] = (ctx->keys[1] + (ctx->keys[0] & 0xff)) * 134775813L + 1;\n\tt = (ctx->keys[1] >> 24) & 0xff;\n\tctx->keys[2] = CRC32(ctx->keys[2], t);\n#undef CRC32\n}", "target": 0}
{"code": "bool CSPSource::schemeMatches(const KURL& url) const\n {\n     if (m_scheme.isEmpty())\n         return m_policy->protocolMatchesSelf(url);\n     return equalIgnoringCase(url.protocol(), m_scheme);\n }", "target": 1}
{"code": "GF_Err fdpa_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_FDpacketBox *ptr = (GF_FDpacketBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, ptr->info.sender_current_time_present, 1);\n\tgf_bs_write_int(bs, ptr->info.expected_residual_time_present, 1);\n\tgf_bs_write_int(bs, ptr->info.session_close_bit, 1);\n\tgf_bs_write_int(bs, ptr->info.object_close_bit, 1);\n\tgf_bs_write_int(bs, 0, 4);\n\tgf_bs_write_u16(bs, ptr->info.transport_object_identifier);\n\tgf_bs_write_u16(bs, ptr->header_ext_count);\n\tfor (i=0; i<ptr->header_ext_count; i++) {\n\t\tgf_bs_write_u8(bs, ptr->headers[i].header_extension_type);\n\t\tif (ptr->headers[i].header_extension_type > 127) {\n\t\t\tgf_bs_write_data(bs, (const char *) ptr->headers[i].content, 3);\n\t\t} else {\n\t\t\tgf_bs_write_u8(bs, ptr->headers[i].data_length ? (ptr->headers[i].data_length+2)/4 : 0);\n\t\t\tif (ptr->headers[i].data_length) {\n\t\t\t\tgf_bs_write_data(bs, ptr->headers[i].data, ptr->headers[i].data_length);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "int64_t BZ2File::readImpl(char * buf, int64_t length) {\n  if (length == 0) {\n    return 0;\n  }\n  assertx(m_bzFile);\n  int len = BZ2_bzread(m_bzFile, buf, length);\n  if (len <= 0) {\n    setEof(true);\n    if (len < 0) {\n      return -1;\n    }\n  }\n  return len;\n}", "target": 1}
{"code": "static void wait_for_child_to_die(void *ctx)\n{\n\tREQUEST *request = ctx;\n\trad_assert(request->magic == REQUEST_MAGIC);\n\tif ((request->child_state == REQUEST_QUEUED) ||\n\t    ((request->child_state == REQUEST_RUNNING) &&\n\t     (pthread_equal(request->child_pid, NO_SUCH_CHILD_PID) == 0))) {\n\t\tif (request->delay < (USEC * 60 * 5)) {\n\t\t\trequest->delay += (request->delay >> 1);\n\t\t\tradlog(L_INFO, \"WARNING: Child is hung for request %u in component %s module %s.\",\n\t\t\t       request->number, request->component, request->module);\n\t\t} else {\n\t\t\tRDEBUG2(\"Child is still stuck for request %u\",\n\t\t\t\trequest->number);\n\t\t}\n\t\ttv_add(&request->when, request->delay);\n\t\tINSERT_EVENT(wait_for_child_to_die, request);\n\t\treturn;\n\t}\n\tRDEBUG2(\"Child is finally responsive for request %u\", request->number);\n\tremove_from_request_hash(request);\n#ifdef WITH_PROXY\n\tif (request->proxy) {\n\t\twait_for_proxy_id_to_expire(request);\n\t\treturn;\n\t}\n#endif\n\tev_request_free(&request);\n}", "target": 1}
{"code": "acl_fetch_proto_http(struct proxy *px, struct session *s, void *l7, int dir,\n\t\t     struct acl_expr *expr, struct acl_test *test)\n{\n\tstruct buffer *req = s->req;\n\tstruct http_txn *txn = &s->txn;\n\tstruct http_msg *msg = &txn->req;\n\tif (!s || !req)\n\t\treturn 0;\n\tif (unlikely(msg->msg_state >= HTTP_MSG_BODY)) {\n\t\ttest->flags |= ACL_TEST_F_SET_RES_PASS;\n\t\treturn 1;\n\t}\n\tif (unlikely(req->lr > req->data &&\n\t    (req->r < req->lr || req->r > req->data + req->size - global.tune.maxrewrite)) &&\n\t    (req->l <= req->size - global.tune.maxrewrite))\n\t\thttp_buffer_heavy_realign(req, msg);\n\tif (likely(req->lr < req->r))\n\t\thttp_msg_analyzer(req, msg, &txn->hdr_idx);\n\tif (unlikely(msg->msg_state < HTTP_MSG_BODY)) {\n\t\tif ((msg->msg_state == HTTP_MSG_ERROR) || (req->flags & BF_FULL)) {\n\t\t\ttest->flags |= ACL_TEST_F_SET_RES_FAIL;\n\t\t\treturn 1;\n\t\t}\n\t\ttest->flags |= ACL_TEST_F_MAY_CHANGE;\n\t\treturn 0;\n\t}\n\tif (unlikely(req->lr > req->data &&\n\t    (req->r < req->lr || req->l > req->size - global.tune.maxrewrite ||\n\t     req->r > req->data + req->size - global.tune.maxrewrite))) {\n\t\tmsg->msg_state = HTTP_MSG_ERROR;\n\t\ttest->flags |= ACL_TEST_F_SET_RES_PASS;\n\t\treturn 1;\n\t}\n\ttxn->meth = find_http_meth(msg->sol, msg->sl.rq.m_l);\n\tif (txn->meth == HTTP_METH_GET || txn->meth == HTTP_METH_HEAD)\n\t\ts->flags |= SN_REDIRECTABLE;\n\tif (unlikely(msg->sl.rq.v_l == 0) && !http_upgrade_v09_to_v10(req, msg, txn)) {\n\t\ttest->flags |= ACL_TEST_F_SET_RES_FAIL;\n\t\treturn 1;\n\t}\n\ttest->flags |= ACL_TEST_F_SET_RES_PASS;\n\treturn 1;\n}", "target": 0}
{"code": "void gitn_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *)s;\n\tif (ptr == NULL) return;\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tif (ptr->entries[i].name) gf_free(ptr->entries[i].name);\n\t}\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);", "target": 1}
{"code": "int kvm_read_guest_page(struct kvm *kvm, gfn_t gfn, void *data, int offset,\n\t\t\tint len)\n{\n\tint r;\n\tunsigned long addr;\n\taddr = gfn_to_hva(kvm, gfn);\n\tif (kvm_is_error_hva(addr))\n\t\treturn -EFAULT;\n\tr = copy_from_user(data, (void __user *)addr + offset, len);\n\tif (r)\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1}
{"code": "  int get_request_payment_payer(bool *requester_pays) {\n    XMLObj *config = find_first(\"RequestPaymentConfiguration\");\n    if (!config)\n      return -EINVAL;\n    *requester_pays = false;\n    XMLObj *field = config->find_first(\"Payer\");\n    if (!field)\n      return 0;\n    string& s = field->get_data();\n    if (stringcasecmp(s, \"Requester\") == 0) {\n      *requester_pays = true;\n    } else if (stringcasecmp(s, \"BucketOwner\") != 0) {\n      return -EINVAL;\n    }\n    return 0;\n  }", "target": 0}
{"code": " int __glXDispSwap_CreateContext(__GLXclientState *cl, GLbyte *pc)\n {\n     xGLXCreateContextReq *req = (xGLXCreateContextReq *) pc;\n     __GLX_DECLARE_SWAP_VARIABLES;\n     __GLX_SWAP_SHORT(&req->length);\n     __GLX_SWAP_INT(&req->context);\n     __GLX_SWAP_INT(&req->visual);\n    return __glXDisp_CreateContext(cl, pc);\n}", "target": 1}
{"code": "static int kvp_get_value(int pool, __u8 *key, int key_size, __u8 *value,\n\t\t\tint value_size)\n{\n\tint i;\n\tint num_records;\n\tstruct kvp_record *record;\n\tif ((key_size > HV_KVP_EXCHANGE_MAX_KEY_SIZE) ||\n\t\t(value_size > HV_KVP_EXCHANGE_MAX_VALUE_SIZE))\n\t\treturn 1;\n\tkvp_update_mem_state(pool);\n\tnum_records = kvp_file_info[pool].num_records;\n\trecord = kvp_file_info[pool].records;\n\tfor (i = 0; i < num_records; i++) {\n\t\tif (memcmp(key, record[i].key, key_size))\n\t\t\tcontinue;\n\t\tmemcpy(value, record[i].value, value_size);\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "int rds_get_mr_for_dest(struct rds_sock *rs, char __user *optval, int optlen)\n{\n\tstruct rds_get_mr_for_dest_args args;\n\tstruct rds_get_mr_args new_args;\n\tif (optlen != sizeof(struct rds_get_mr_for_dest_args))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&args, (struct rds_get_mr_for_dest_args __user *)optval,\n\t\t\t   sizeof(struct rds_get_mr_for_dest_args)))\n\t\treturn -EFAULT;\n\tnew_args.vec = args.vec;\n\tnew_args.cookie_addr = args.cookie_addr;\n\tnew_args.flags = args.flags;\n\treturn __rds_rdma_map(rs, &new_args, NULL, NULL);\n}", "target": 0}
{"code": "  tt_size_reset( TT_Size  size,\n                 FT_Bool  only_height )\n  {\n    TT_Face           face;\n     FT_Size_Metrics*  metrics;\n    size->ttmetrics.valid = FALSE;\n     face = (TT_Face)size->root.face;\n     metrics = &size->metrics;\n    if ( face->header.Flags & 8 )\n    {\n      metrics->ascender =\n        FT_PIX_ROUND( FT_MulFix( face->root.ascender, metrics->y_scale ) );\n      metrics->descender =\n        FT_PIX_ROUND( FT_MulFix( face->root.descender, metrics->y_scale ) );\n      metrics->height =\n        FT_PIX_ROUND( FT_MulFix( face->root.height, metrics->y_scale ) );\n    }\n    size->ttmetrics.valid = TRUE;\n    if ( only_height )\n      return FT_Err_Ok;\n    if ( face->header.Flags & 8 )\n    {\n      metrics->x_scale = FT_DivFix( metrics->x_ppem << 6,\n                                    face->root.units_per_EM );\n      metrics->y_scale = FT_DivFix( metrics->y_ppem << 6,\n                                    face->root.units_per_EM );\n      metrics->max_advance =\n        FT_PIX_ROUND( FT_MulFix( face->root.max_advance_width,\n                                 metrics->x_scale ) );\n    }\n    if ( metrics->x_ppem >= metrics->y_ppem )\n    {\n      size->ttmetrics.scale   = metrics->x_scale;\n      size->ttmetrics.ppem    = metrics->x_ppem;\n      size->ttmetrics.x_ratio = 0x10000L;\n      size->ttmetrics.y_ratio = FT_DivFix( metrics->y_ppem,\n                                           metrics->x_ppem );\n    }\n    else\n    {\n      size->ttmetrics.scale   = metrics->y_scale;\n      size->ttmetrics.ppem    = metrics->y_ppem;\n      size->ttmetrics.x_ratio = FT_DivFix( metrics->x_ppem,\n                                           metrics->y_ppem );\n      size->ttmetrics.y_ratio = 0x10000L;\n    }\n#ifdef TT_USE_BYTECODE_INTERPRETER\n    size->cvt_ready = -1;\n#endif \n    return FT_Err_Ok;\n  }", "target": 1}
{"code": "TEE_Result tee_mmu_check_access_rights(const struct user_ta_ctx *utc,\n\t\t\t\t       uint32_t flags, uaddr_t uaddr,\n\t\t\t\t       size_t len)\n{\n\tuaddr_t a;\n\tsize_t addr_incr = MIN(CORE_MMU_USER_CODE_SIZE,\n\t\t\t       CORE_MMU_USER_PARAM_SIZE);\n\tif (ADD_OVERFLOW(uaddr, len, &a))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t    (flags & TEE_MEMORY_ACCESS_SECURE))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\tif (!(flags & TEE_MEMORY_ACCESS_ANY_OWNER) &&\n\t   !tee_mmu_is_vbuf_inside_ta_private(utc, (void *)uaddr, len))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\tfor (a = uaddr; a < (uaddr + len); a += addr_incr) {\n\t\tuint32_t attr;\n\t\tTEE_Result res;\n\t\tres = tee_mmu_user_va2pa_attr(utc, (void *)a, NULL, &attr);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t\t    (attr & TEE_MATTR_SECURE))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t\tif ((flags & TEE_MEMORY_ACCESS_SECURE) &&\n\t\t    !(attr & TEE_MATTR_SECURE))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t\tif ((flags & TEE_MEMORY_ACCESS_WRITE) && !(attr & TEE_MATTR_UW))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t\tif ((flags & TEE_MEMORY_ACCESS_READ) && !(attr & TEE_MATTR_UR))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t}\n\treturn TEE_SUCCESS;\n}", "target": 1}
{"code": "l2tp_framing_type_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint32_t *ptr = (const uint32_t *)dat;\n\tif (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_TYPE_ASYNC_MASK) {\n\t\tND_PRINT((ndo, \"A\"));\n\t}\n\tif (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_TYPE_SYNC_MASK) {\n\t\tND_PRINT((ndo, \"S\"));\n\t}\n}", "target": 1}
{"code": "static const char *req_path_info_field(request_rec *r)\n{\n    return r->path_info;\n}", "target": 0}
{"code": "get_supported_image_extensions(void)\n{\n\tGSList *extensions = NULL;\n\tGSList *formats = gdk_pixbuf_get_formats ();\n\tGSList *l;\n\tfor (l = formats; l != NULL; l = l->next) {\n\t\tint i;\n\t\tgchar **ext = gdk_pixbuf_format_get_extensions (l->data);\n\t\tfor (i = 0; ext[i] != NULL; i++) {\n\t\t\textensions = g_slist_append (extensions,\n\t\t\t\t\t\t     g_strdup (ext[i]));\n\t\t}\n\t\tg_strfreev (ext);\n\t}\n\tg_slist_free (formats);\n\treturn extensions;\n}", "target": 1}
{"code": "rb_remove_pages(struct ring_buffer_per_cpu *cpu_buffer, unsigned long nr_pages)\n{\n\tstruct list_head *tail_page, *to_remove, *next_page;\n\tstruct buffer_page *to_remove_page, *tmp_iter_page;\n\tstruct buffer_page *last_page, *first_page;\n\tunsigned long nr_removed;\n\tunsigned long head_bit;\n\tint page_entries;\n\thead_bit = 0;\n\traw_spin_lock_irq(&cpu_buffer->reader_lock);\n\tatomic_inc(&cpu_buffer->record_disabled);\n\ttail_page = &cpu_buffer->tail_page->list;\n\tif (cpu_buffer->tail_page == cpu_buffer->reader_page)\n\t\ttail_page = rb_list_head(tail_page->next);\n\tto_remove = tail_page;\n\tfirst_page = list_entry(rb_list_head(to_remove->next),\n\t\t\t\tstruct buffer_page, list);\n\tfor (nr_removed = 0; nr_removed < nr_pages; nr_removed++) {\n\t\tto_remove = rb_list_head(to_remove)->next;\n\t\thead_bit |= (unsigned long)to_remove & RB_PAGE_HEAD;\n\t}\n\tnext_page = rb_list_head(to_remove)->next;\n\ttail_page->next = (struct list_head *)((unsigned long)next_page |\n\t\t\t\t\t\thead_bit);\n\tnext_page = rb_list_head(next_page);\n\tnext_page->prev = tail_page;\n\tcpu_buffer->pages = next_page;\n\tif (head_bit)\n\t\tcpu_buffer->head_page = list_entry(next_page,\n\t\t\t\t\t\tstruct buffer_page, list);\n\tcpu_buffer->read = 0;\n\tatomic_dec(&cpu_buffer->record_disabled);\n\traw_spin_unlock_irq(&cpu_buffer->reader_lock);\n\tRB_WARN_ON(cpu_buffer, list_empty(cpu_buffer->pages));\n\tlast_page = list_entry(rb_list_head(to_remove), struct buffer_page,\n\t\t\t\tlist);\n\ttmp_iter_page = first_page;\n\tdo {\n\t\tcond_resched();\n\t\tto_remove_page = tmp_iter_page;\n\t\trb_inc_page(&tmp_iter_page);\n\t\tpage_entries = rb_page_entries(to_remove_page);\n\t\tif (page_entries) {\n\t\t\tlocal_add(page_entries, &cpu_buffer->overrun);\n\t\t\tlocal_sub(BUF_PAGE_SIZE, &cpu_buffer->entries_bytes);\n\t\t}\n\t\tfree_buffer_page(to_remove_page);\n\t\tnr_removed--;\n\t} while (to_remove_page != last_page);\n\tRB_WARN_ON(cpu_buffer, nr_removed);\n\treturn nr_removed == 0;\n}", "target": 0}
{"code": "void FastCGITransport::onHeader(std::unique_ptr<folly::IOBuf> key_chain,\n                                std::unique_ptr<folly::IOBuf> value_chain) {\n  Cursor keyCur(key_chain.get());\n  auto key = keyCur.readFixedString(key_chain->computeChainDataLength());\n  Cursor valCur(value_chain.get());\n  auto value = valCur.readFixedString(value_chain->computeChainDataLength());\n  m_requestParams[key] = value;\n}", "target": 1}
{"code": "int mutt_seqset_iterator_next(struct SeqsetIterator *iter, unsigned int *next)\n{\n  if (!iter || !next)\n    return -1;\n  if (iter->in_range)\n  {\n    if ((iter->down && (iter->range_cur == (iter->range_end - 1))) ||\n        (!iter->down && (iter->range_cur == (iter->range_end + 1))))\n    {\n      iter->in_range = 0;\n    }\n  }\n  if (!iter->in_range)\n  {\n    iter->substr_cur = iter->substr_end;\n    if (iter->substr_cur == iter->eostr)\n      return 1;\n    while (!*(iter->substr_cur))\n      iter->substr_cur++;\n    iter->substr_end = strchr(iter->substr_cur, ',');\n    if (!iter->substr_end)\n      iter->substr_end = iter->eostr;\n    else\n      *(iter->substr_end) = '\\0';\n    char *range_sep = strchr(iter->substr_cur, ':');\n    if (range_sep)\n      *range_sep++ = '\\0';\n    if (mutt_str_atoui(iter->substr_cur, &iter->range_cur) != 0)\n      return -1;\n    if (range_sep)\n    {\n      if (mutt_str_atoui(range_sep, &iter->range_end) != 0)\n        return -1;\n    }\n    else\n      iter->range_end = iter->range_cur;\n    iter->down = (iter->range_end < iter->range_cur);\n    iter->in_range = 1;\n  }\n  *next = iter->range_cur;\n  if (iter->down)\n    iter->range_cur--;\n  else\n    iter->range_cur++;\n  return 0;\n}", "target": 1}
{"code": " Node::InsertionNotificationRequest HTMLBodyElement::insertedInto(ContainerNode* insertionPoint)\n {\n     HTMLElement::insertedInto(insertionPoint);\n    return InsertionShouldCallDidNotifySubtreeInsertions;\n}\nvoid HTMLBodyElement::didNotifySubtreeInsertionsToDocument()\n{\n    Element* ownerElement = document().ownerElement();\n    if (!isHTMLFrameElementBase(ownerElement))\n        return;\n    HTMLFrameElementBase& ownerFrameElement = toHTMLFrameElementBase(*ownerElement);\n    int marginWidth = ownerFrameElement.marginWidth();\n    int marginHeight = ownerFrameElement.marginHeight();\n    if (marginWidth != -1)\n        setIntegralAttribute(marginwidthAttr, marginWidth);\n    if (marginHeight != -1)\n        setIntegralAttribute(marginheightAttr, marginHeight);\n }", "target": 0}
{"code": "static int update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_stateid, nfs4_stateid *delegation, int open_flags)\n{\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tstruct nfs_delegation *deleg_cur;\n\tint ret = 0;\n\topen_flags &= (FMODE_READ|FMODE_WRITE);\n\trcu_read_lock();\n\tdeleg_cur = rcu_dereference(nfsi->delegation);\n\tif (deleg_cur == NULL)\n\t\tgoto no_delegation;\n\tspin_lock(&deleg_cur->lock);\n\tif (nfsi->delegation != deleg_cur ||\n\t    (deleg_cur->type & open_flags) != open_flags)\n\t\tgoto no_delegation_unlock;\n\tif (delegation == NULL)\n\t\tdelegation = &deleg_cur->stateid;\n\telse if (memcmp(deleg_cur->stateid.data, delegation->data, NFS4_STATEID_SIZE) != 0)\n\t\tgoto no_delegation_unlock;\n\tnfs_mark_delegation_referenced(deleg_cur);\n\t__update_open_stateid(state, open_stateid, &deleg_cur->stateid, open_flags);\n\tret = 1;\nno_delegation_unlock:\n\tspin_unlock(&deleg_cur->lock);\nno_delegation:\n\trcu_read_unlock();\n\tif (!ret && open_stateid != NULL) {\n\t\t__update_open_stateid(state, open_stateid, NULL, open_flags);\n\t\tret = 1;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static int lodepng_add32bitInt(ucvector* buffer, unsigned value)\n{\n  if (!ucvector_resize(buffer, buffer->size + 4)) return 0;\n  lodepng_set32bitInt(&buffer->data[buffer->size - 4], value);\n  return 1;\n}", "target": 0}
{"code": "static int __tipc_nl_add_monitor_prop(struct net *net, struct tipc_nl_msg *msg)\n{\n\tstruct nlattr *attrs;\n\tvoid *hdr;\n\tu32 val;\n\thdr = genlmsg_put(msg->skb, msg->portid, msg->seq, &tipc_genl_family,\n\t\t\t  0, TIPC_NL_MON_GET);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\tattrs = nla_nest_start_noflag(msg->skb, TIPC_NLA_MON);\n\tif (!attrs)\n\t\tgoto msg_full;\n\tval = tipc_nl_monitor_get_threshold(net);\n\tif (nla_put_u32(msg->skb, TIPC_NLA_MON_ACTIVATION_THRESHOLD, val))\n\t\tgoto attr_msg_full;\n\tnla_nest_end(msg->skb, attrs);\n\tgenlmsg_end(msg->skb, hdr);\n\treturn 0;\nattr_msg_full:\n\tnla_nest_cancel(msg->skb, attrs);\nmsg_full:\n\tgenlmsg_cancel(msg->skb, hdr);\n\treturn -EMSGSIZE;\n}", "target": 0}
{"code": "sec_connect(char *server, char *username, char *domain, char *password, RD_BOOL reconnect)\n{\n\tuint32 selected_proto;\n\tstruct stream mcs_data;\n\tif (!mcs_connect_start(server, username, domain, password, reconnect, &selected_proto))\n\t\treturn False;\n\tmcs_data.size = 512;\n\tmcs_data.p = mcs_data.data = (uint8 *) xmalloc(mcs_data.size);\n\tsec_out_mcs_data(&mcs_data, selected_proto);\n\tif (!mcs_connect_finalize(&mcs_data))\n\t\treturn False;\n\tif (g_encryption)\n\t\tsec_establish_key();\n\txfree(mcs_data.data);\n\treturn True;\n}", "target": 0}
{"code": "do_encrypt (const RIJNDAEL_context *ctx,\n            unsigned char *bx, const unsigned char *ax)\n{\n#ifdef USE_AMD64_ASM\n  return _gcry_aes_amd64_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds,\n\t\t\t\t       encT);\n#elif defined(USE_ARM_ASM)\n  return _gcry_aes_arm_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds, encT);\n#else\n  return do_encrypt_fn (ctx, bx, ax);\n#endif \n}", "target": 1}
{"code": "AP_DECLARE(const char *) ap_get_useragent_host(request_rec *r,\n                                               int type, int *str_is_ip)\n{\n    conn_rec *conn = r->connection;\n    int hostname_lookups;\n    int ignored_str_is_ip;\n    if (!r->useragent_addr || (r->useragent_addr == conn->client_addr)) {\n        return ap_get_remote_host(conn, r->per_dir_config, type, str_is_ip);\n    }\n    if (!str_is_ip) { \n        str_is_ip = &ignored_str_is_ip;\n    }\n    *str_is_ip = 0;\n    hostname_lookups = ((core_dir_config *)\n                        ap_get_core_module_config(r->per_dir_config))\n                            ->hostname_lookups;\n    if (hostname_lookups == HOSTNAME_LOOKUP_UNSET) {\n        hostname_lookups = HOSTNAME_LOOKUP_OFF;\n    }\n    if (type != REMOTE_NOLOOKUP\n        && r->useragent_host == NULL\n        && (type == REMOTE_DOUBLE_REV\n        || hostname_lookups != HOSTNAME_LOOKUP_OFF)) {\n        if (apr_getnameinfo(&r->useragent_host, r->useragent_addr, 0)\n            == APR_SUCCESS) {\n            ap_str_tolower(r->useragent_host);\n            if (hostname_lookups == HOSTNAME_LOOKUP_DOUBLE) {\n                r->double_reverse = do_double_reverse(r->double_reverse,\n                                                      r->useragent_host,\n                                                      r->useragent_addr,\n                                                      r->pool);\n                if (r->double_reverse != 1) {\n                    r->useragent_host = NULL;\n                }\n            }\n        }\n        if (r->useragent_host == NULL) {\n            r->useragent_host = \"\";\n        }\n    }\n    if (type == REMOTE_DOUBLE_REV) {\n        r->double_reverse = do_double_reverse(r->double_reverse,\n                                              r->useragent_host,\n                                              r->useragent_addr, r->pool);\n        if (r->double_reverse == -1) {\n            return NULL;\n        }\n    }\n    if (r->useragent_host != NULL && r->useragent_host[0] != '\\0') {\n        return r->useragent_host;\n    }\n    else {\n        if (type == REMOTE_HOST || type == REMOTE_DOUBLE_REV) {\n            return NULL;\n        }\n        else {\n            *str_is_ip = 1;\n            return r->useragent_ip;\n        }\n    }\n}", "target": 0}
{"code": "void RestAuthHandler::shutdownExecute(bool isFinalized) noexcept {\n  try {\n    if (_isValid) {\n      events::LoggedIn(*_request, _username);\n    } else {\n      events::CredentialsBad(*_request, _username);\n    }\n  } catch (...) {\n  }\n  RestVocbaseBaseHandler::shutdownExecute(isFinalized);\n}", "target": 1}
{"code": "static void destroy_pit_timer(struct kvm_pit *pit)\n{\n\thrtimer_cancel(&pit->pit_state.timer);\n\tflush_kthread_work(&pit->expired);\n}", "target": 0}
{"code": "static void put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\tif (atomic_dec_and_test(&ucounts->count)) {\n\t\tspin_lock_irqsave(&ucounts_lock, flags);\n\t\thlist_del_init(&ucounts->node);\n\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\t\tkfree(ucounts);\n\t}\n}", "target": 1}
{"code": "int nfc_stop_poll(struct nfc_dev *dev)\n{\n\tint rc = 0;\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (!dev->polling) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\tdev->ops->stop_poll(dev);\n\tdev->polling = false;\n\tdev->rf_mode = NFC_RF_NONE;\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "IW_IMPL(unsigned int) iw_get_ui32le(const iw_byte *b)\n{\n\treturn b[0] | (b[1]<<8) | (b[2]<<16) | (b[3]<<24);\n}", "target": 1}
{"code": "validate_event(struct pmu_hw_events *hw_events,\n\t       struct perf_event *event)\n{\n\tstruct arm_pmu *armpmu = to_arm_pmu(event->pmu);\n\tstruct hw_perf_event fake_event = event->hw;\n\tstruct pmu *leader_pmu = event->group_leader->pmu;\n\tif (is_software_event(event))\n\t\treturn 1;\n\tif (event->pmu != leader_pmu || event->state < PERF_EVENT_STATE_OFF)\n\t\treturn 1;\n\tif (event->state == PERF_EVENT_STATE_OFF && !event->attr.enable_on_exec)\n\t\treturn 1;\n\treturn armpmu->get_event_idx(hw_events, &fake_event) >= 0;\n}", "target": 1}
{"code": "GF_AV1Config *gf_isom_av1_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tif (gf_isom_get_reference_count(the_file, trackNumber, GF_ISOM_REF_TBAS)) {\n\t\tu32 ref_track;\n\t\tGF_Err e = gf_isom_get_reference(the_file, trackNumber, GF_ISOM_REF_TBAS, 1, &ref_track);\n\t\tif (e == GF_OK) {\n\t\t\ttrackNumber = ref_track;\n\t\t}\n\t}\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex - 1);\n\tif (!entry || !entry->av1_config) return NULL;\n\treturn AV1_DuplicateConfig(entry->av1_config->config);\n}", "target": 1}
{"code": "static void credential_write_item(FILE *fp, const char *key, const char *value)\n{\n\tif (!value)\n\t\treturn;\n\tfprintf(fp, \"%s=%s\\n\", key, value);\n}", "target": 1}
{"code": "static void ndpi_reset_packet_line_info(struct ndpi_packet_struct *packet) {\n  packet->parsed_lines = 0, packet->empty_line_position_set = 0, packet->host_line.ptr = NULL,\n    packet->host_line.len = 0, packet->referer_line.ptr = NULL, packet->referer_line.len = 0,\n    packet->content_line.ptr = NULL, packet->content_line.len = 0, packet->accept_line.ptr = NULL,\n    packet->accept_line.len = 0, packet->user_agent_line.ptr = NULL, packet->user_agent_line.len = 0,\n    packet->http_url_name.ptr = NULL, packet->http_url_name.len = 0, packet->http_encoding.ptr = NULL,\n    packet->http_encoding.len = 0, packet->http_transfer_encoding.ptr = NULL, packet->http_transfer_encoding.len = 0,\n    packet->http_contentlen.ptr = NULL, packet->http_contentlen.len = 0, packet->http_cookie.ptr = NULL,\n    packet->http_cookie.len = 0, packet->http_origin.len = 0, packet->http_origin.ptr = NULL,\n    packet->http_x_session_type.ptr = NULL, packet->http_x_session_type.len = 0, packet->server_line.ptr = NULL,\n    packet->server_line.len = 0, packet->http_method.ptr = NULL, packet->http_method.len = 0,\n    packet->http_response.ptr = NULL, packet->http_response.len = 0, packet->http_num_headers = 0;\n}", "target": 1}
{"code": "GF_Err diST_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tchar str[1024];\n\tGF_DIMSScriptTypesBox *p = (GF_DIMSScriptTypesBox *)s;\n\ti=0;\n\tstr[0]=0;\n\twhile (1) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tif (!str[i]) break;\n\t\ti++;\n\t}\n\tISOM_DECREASE_SIZE(p, i);\n\tp->content_script_types = gf_strdup(str);\n\treturn GF_OK;\n}", "target": 1}
{"code": "static void timerfd_remove_cancel(struct timerfd_ctx *ctx)\n{\n\tif (ctx->might_cancel) {\n\t\tctx->might_cancel = false;\n\t\tspin_lock(&cancel_lock);\n\t\tlist_del_rcu(&ctx->clist);\n\t\tspin_unlock(&cancel_lock);\n\t}\n}", "target": 1}
{"code": "static int firm_set_rts(struct usb_serial_port *port, __u8 onoff)\n{\n\tstruct whiteheat_set_rdb rts_command;\n\trts_command.port = port->port_number + 1;\n\trts_command.state = onoff;\n\treturn firm_send_command(port, WHITEHEAT_SET_RTS,\n\t\t\t(__u8 *)&rts_command, sizeof(rts_command));\n}", "target": 0}
{"code": "static bool hva_to_pfn_fast(unsigned long addr, bool atomic, bool *async,\n\t\t\t    bool write_fault, bool *writable, kvm_pfn_t *pfn)\n{\n\tstruct page *page[1];\n\tint npages;\n\tif (!(async || atomic))\n\t\treturn false;\n\tif (!(write_fault || writable))\n\t\treturn false;\n\tnpages = __get_user_pages_fast(addr, 1, 1, page);\n\tif (npages == 1) {\n\t\t*pfn = page_to_pfn(page[0]);\n\t\tif (writable)\n\t\t\t*writable = true;\n\t\treturn true;\n\t}\n\treturn false;\n}", "target": 0}
{"code": "static int hog_init(void)\n{\n\tint err;\n\terr = suspend_init(suspend_callback, resume_callback);\n\tif (err < 0)\n\t\terror(\"Loading suspend plugin failed: %s (%d)\", strerror(-err),\n\t\t\t\t\t\t\t\t\t-err);\n\telse\n\t\tsuspend_supported = TRUE;\n\treturn btd_profile_register(&hog_profile);\n}", "target": 0}
{"code": "int af_alg_release(struct socket *sock)\n{\n\tif (sock->sk)\n\t\tsock_put(sock->sk);\n\treturn 0;\n}", "target": 1}
{"code": "get_auth_param(struct auth_param *auth, char *name)\n{\n    struct auth_param *ap;\n    for (ap = auth; ap->name != NULL; ap++) {\n\tif (strcasecmp(name, ap->name) == 0)\n\t    return ap->val;\n    }\n    return NULL;\n}", "target": 0}
{"code": "static int verify_ee(const gnutls_datum_t *raw_crt, gnutls_certificate_type_t crt_type,\n\t\t dane_cert_type_t ctype, dane_match_type_t match, gnutls_datum_t * data,\n\t\t unsigned int *verify)\n{\ngnutls_datum_t pubkey = {NULL, 0};\nint ret;\n\tif (ctype == DANE_CERT_X509 && crt_type == GNUTLS_CRT_X509) {\n\t\tif (!matches(raw_crt, data, match)) {\n\t\t        gnutls_assert();\n\t\t\t*verify |= DANE_VERIFY_CERT_DIFFERS;\n                }\n\t} else if (ctype == DANE_CERT_PK && crt_type == GNUTLS_CRT_X509) {\n\t\tret = crt_to_pubkey(raw_crt, &pubkey);\n\t\tif (ret < 0) {\n        \t        gnutls_assert();\n\t\t\tgoto cleanup;\n                }\n\t\tif (!matches(&pubkey, data, match)) {\n\t\t        gnutls_assert();\n\t\t\t*verify |= DANE_VERIFY_CERT_DIFFERS;\n                }\n\t} else {\n\t\tret = gnutls_assert_val(DANE_E_UNKNOWN_DANE_DATA);\n\t\tgoto cleanup;\n\t}\n\tret = 0;\ncleanup:\n\tfree(pubkey.data);\n\treturn ret;\n}", "target": 0}
{"code": "TEST(LteOp, MatchesMaxKey) {\n    BSONObj operand = BSON(\"a\" << MaxKey);\n    LTEMatchExpression lte(\"a\", operand[\"a\"]);\n    BSONObj minKeyObj = BSON(\"a\" << MinKey);\n    BSONObj maxKeyObj = BSON(\"a\" << MaxKey);\n    BSONObj numObj = BSON(\"a\" << 4);\n    ASSERT(lte.matchesBSON(minKeyObj, NULL));\n    ASSERT(lte.matchesBSON(maxKeyObj, NULL));\n    ASSERT(lte.matchesBSON(numObj, NULL));\n    ASSERT(lte.matchesSingleElement(minKeyObj.firstElement()));\n    ASSERT(lte.matchesSingleElement(maxKeyObj.firstElement()));\n    ASSERT(lte.matchesSingleElement(numObj.firstElement()));\n}", "target": 0}
{"code": "cmdline_insert_reg(int *gotesc UNUSED)\n{\n    int\t\ti;\n    int\t\tc;\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = TRUE;\t\n#endif\n    putcmdline('\"', TRUE);\n    ++no_mapping;\n    ++allow_keys;\n    i = c = plain_vgetc();\t\n    if (i == Ctrl_O)\n\ti = Ctrl_R;\t\t\n    if (i == Ctrl_R)\n\tc = plain_vgetc();\t\n    extra_char = NUL;\n    --no_mapping;\n    --allow_keys;\n#ifdef FEAT_EVAL\n    new_cmdpos = -1;\n    if (c == '=')\n    {\n\tif (ccline.cmdfirstc == '='  \n\t\t|| cmdline_star > 0) \n\t{\n\t    beep_flush();\n\t    c = ESC;\n\t}\n\telse\n\t    c = get_expr_register();\n    }\n#endif\n    if (c != ESC)\t    \n    {\n\tcmdline_paste(c, i == Ctrl_R, FALSE);\n#ifdef FEAT_EVAL\n\tif (aborting())\n\t{\n\t    *gotesc = TRUE;  \n\t    return GOTO_NORMAL_MODE;\n\t}\n#endif\n\tKeyTyped = FALSE;\t\n#ifdef FEAT_EVAL\n\tif (new_cmdpos >= 0)\n\t{\n\t    if (new_cmdpos > ccline.cmdlen)\n\t\tccline.cmdpos = ccline.cmdlen;\n\t    else\n\t\tccline.cmdpos = new_cmdpos;\n\t}\n#endif\n    }\n    redrawcmd();\n    return CMDLINE_NOT_CHANGED;\n}", "target": 1}
{"code": "static int target_xcopy_locate_se_dev_e4(const unsigned char *dev_wwn,\n\t\t\t\t\tstruct se_device **found_dev)\n{\n\tstruct xcopy_dev_search_info info;\n\tint ret;\n\tmemset(&info, 0, sizeof(info));\n\tinfo.dev_wwn = dev_wwn;\n\tret = target_for_each_device(target_xcopy_locate_se_dev_e4_iter, &info);\n\tif (ret == 1) {\n\t\t*found_dev = info.found_dev;\n\t\treturn 0;\n\t} else {\n\t\tpr_debug_ratelimited(\"Unable to locate 0xe4 descriptor for EXTENDED_COPY\\n\");\n\t\treturn -EINVAL;\n\t}\n}", "target": 1}
{"code": "get_manuf_name(const guint8 *addr)\n{\n    hashmanuf_t *manuf_value;\n    manuf_value = manuf_name_lookup(addr);\n    if (gbl_resolv_flags.mac_name && manuf_value->status != HASHETHER_STATUS_UNRESOLVED)\n        return manuf_value->resolved_name;\n    return manuf_value->hexaddr;\n} ", "target": 1}
{"code": "static void sycc444_to_rgb(opj_image_t *img)\n{\n\tint *d0, *d1, *d2, *r, *g, *b;\n\tconst int *y, *cb, *cr;\n\tunsigned int maxw, maxh, max, i;\n\tint offset, upb;\n\tupb = (int)img->comps[0].prec;\n\toffset = 1<<(upb - 1); upb = (1<<upb)-1;\n\tmaxw = (unsigned int)img->comps[0].w; maxh = (unsigned int)img->comps[0].h;\n\tmax = maxw * maxh;\n\ty = img->comps[0].data;\n\tcb = img->comps[1].data;\n\tcr = img->comps[2].data;\n\td0 = r = (int*)malloc(sizeof(int) * (size_t)max);\n\td1 = g = (int*)malloc(sizeof(int) * (size_t)max);\n\td2 = b = (int*)malloc(sizeof(int) * (size_t)max);\n\tif(r == NULL || g == NULL || b == NULL) goto fails;\n\tfor(i = 0U; i < max; ++i)\n\t{\n\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t++y; ++cb; ++cr; ++r; ++g; ++b;\n\t}\n\tfree(img->comps[0].data); img->comps[0].data = d0;\n\tfree(img->comps[1].data); img->comps[1].data = d1;\n\tfree(img->comps[2].data); img->comps[2].data = d2;\n\treturn;\nfails:\n\tif(r) free(r);\n\tif(g) free(g);\n\tif(b) free(b);\n}", "target": 1}
{"code": "comics_document_init (ComicsDocument *comics_document)\n{\n\tcomics_document->archive = NULL;\n\tcomics_document->page_names = NULL;\n\tcomics_document->extract_command = NULL;\n}", "target": 1}
{"code": "onig_scan(regex_t* reg, const UChar* str, const UChar* end,\n\t  OnigRegion* region, OnigOptionType option,\n\t  int (*scan_callback)(OnigPosition, OnigPosition, OnigRegion*, void*),\n\t  void* callback_arg)\n{\n  OnigPosition r;\n  OnigPosition n;\n  int rs;\n  const UChar* start;\n  n = 0;\n  start = str;\n  while (1) {\n    r = onig_search(reg, str, end, start, end, region, option);\n    if (r >= 0) {\n      rs = scan_callback(n, r, region, callback_arg);\n      n++;\n      if (rs != 0)\n\treturn rs;\n      if (region->end[0] == start - str)\n\tstart++;\n      else\n\tstart = str + region->end[0];\n      if (start > end)\n\tbreak;\n    }\n    else if (r == ONIG_MISMATCH) {\n      break;\n    }\n    else { \n      return r;\n    }\n  }\n  return n;\n}", "target": 0}
{"code": "static int __init cpia2_init(void)\n{\n\tLOG(\"%s v%s\\n\",\n\t    ABOUT, CPIA_VERSION);\n\tcheck_parameters();\n\tcpia2_usb_init();\n\treturn 0;\n}", "target": 1}
{"code": "static void Sp_search(js_State *J)\n{\n\tjs_Regexp *re;\n\tconst char *text;\n\tResub m;\n\ttext = checkstring(J, 0);\n\tif (js_isregexp(J, 1))\n\t\tjs_copy(J, 1);\n\telse if (js_isundefined(J, 1))\n\t\tjs_newregexp(J, \"\", 0);\n\telse\n\t\tjs_newregexp(J, js_tostring(J, 1), 0);\n\tre = js_toregexp(J, -1);\n\tif (!js_regexec(re->prog, text, &m, 0))\n\t\tjs_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));\n\telse\n\t\tjs_pushnumber(J, -1);\n}", "target": 1}
{"code": "LUA_API void *lua_upvalueid (lua_State *L, int fidx, int n) {\n  StkId fi = index2addr(L, fidx);\n  switch (ttype(fi)) {\n    case LUA_TLCL: {  \n      return *getupvalref(L, fidx, n, NULL);\n    }\n    case LUA_TCCL: {  \n      CClosure *f = clCvalue(fi);\n      api_check(L, 1 <= n && n <= f->nupvalues, \"invalid upvalue index\");\n      return &f->upvalue[n - 1];\n    }\n    default: {\n      api_check(L, 0, \"closure expected\");\n      return NULL;\n    }\n  }\n}", "target": 1}
{"code": "has_undead_caller_from_outside_scc_p (struct cgraph_node *node,\n\t\t\t\t      void *data ATTRIBUTE_UNUSED)\n{\n  struct cgraph_edge *cs;\n  for (cs = node->callers; cs; cs = cs->next_caller)\n    if (cs->caller->thunk.thunk_p\n\t&& cs->caller->call_for_symbol_thunks_and_aliases\n\t  (has_undead_caller_from_outside_scc_p, NULL, true))\n      return true;\n    else if (!ipa_edge_within_scc (cs)\n\t     && !IPA_NODE_REF (cs->caller)->node_dead)\n      return true;\n  return false;\n}", "target": 0}
{"code": "int btrfs_get_dev_stats(struct btrfs_fs_info *fs_info,\n\t\t\tstruct btrfs_ioctl_get_dev_stats *stats)\n{\n\tstruct btrfs_device *dev;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tint i;\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(fs_info->fs_devices, stats->devid, NULL, NULL);\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\tif (!dev) {\n\t\tbtrfs_warn(fs_info, \"get dev_stats failed, device not found\");\n\t\treturn -ENODEV;\n\t} else if (!dev->dev_stats_valid) {\n\t\tbtrfs_warn(fs_info, \"get dev_stats failed, not yet valid\");\n\t\treturn -ENODEV;\n\t} else if (stats->flags & BTRFS_DEV_STATS_RESET) {\n\t\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++) {\n\t\t\tif (stats->nr_items > i)\n\t\t\t\tstats->values[i] =\n\t\t\t\t\tbtrfs_dev_stat_read_and_reset(dev, i);\n\t\t\telse\n\t\t\t\tbtrfs_dev_stat_reset(dev, i);\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++)\n\t\t\tif (stats->nr_items > i)\n\t\t\t\tstats->values[i] = btrfs_dev_stat_read(dev, i);\n\t}\n\tif (stats->nr_items > BTRFS_DEV_STAT_VALUES_MAX)\n\t\tstats->nr_items = BTRFS_DEV_STAT_VALUES_MAX;\n\treturn 0;\n}", "target": 1}
{"code": "static int isdn_ppp_skip_ac(struct ippp_struct *is, struct sk_buff *skb)\n{\n\tif (skb->len < 1)\n\t\treturn -1;\n\tif (skb->data[0] == 0xff) {\n\t\tif (skb->len < 2)\n\t\t\treturn -1;\n\t\tif (skb->data[1] != 0x03)\n\t\t\treturn -1;\n\t\tskb_pull(skb, 2);\n\t} else {\n\t\tif (is->pppcfg & SC_REJ_COMP_AC)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "ikev1_cert_print(netdissect_options *ndo, u_char tpay _U_,\n\t\t const struct isakmp_gen *ext, u_int item_len,\n\t\t const u_char *ep _U_, uint32_t phase _U_,\n\t\t uint32_t doi0 _U_,\n\t\t uint32_t proto0 _U_, int depth _U_)\n{\n\tconst struct ikev1_pl_cert *p;\n\tstruct ikev1_pl_cert cert;\n\tstatic const char *certstr[] = {\n\t\t\"none\",\t\"pkcs7\", \"pgp\", \"dns\",\n\t\t\"x509sign\", \"x509ke\", \"kerberos\", \"crl\",\n\t\t\"arl\", \"spki\", \"x509attr\",\n\t};\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_CERT)));\n\tp = (const struct ikev1_pl_cert *)ext;\n\tND_TCHECK(*p);\n\tUNALIGNED_MEMCPY(&cert, ext, sizeof(cert));\n\tND_PRINT((ndo,\" len=%d\", item_len - 4));\n\tND_PRINT((ndo,\" type=%s\", STR_OR_ID((cert.encode), certstr)));\n\tif (2 < ndo->ndo_vflag && 4 < item_len) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), item_len - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + item_len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_CERT)));\n\treturn NULL;\n}", "target": 0}
{"code": "static void mce_start_timer(struct timer_list *t)\n{\n\tunsigned long iv = check_interval * HZ;\n\tif (mca_cfg.ignore_ce || !iv)\n\t\treturn;\n\tthis_cpu_write(mce_next_interval, iv);\n\t__start_timer(t, iv);\n}", "target": 0}
{"code": "daemon_linux_lvm2_vg_set_name_authorized_cb (Daemon *daemon,\n                                             Device *device,\n                                             DBusGMethodInvocation *context,\n                                             const gchar *action_id,\n                                             guint num_user_data,\n                                             gpointer *user_data_elements)\n{\n  const gchar *uuid = user_data_elements[0];\n  const gchar *new_name = user_data_elements[1];\n  const gchar *vg_name;\n  guint n;\n  gchar *argv[10];\n  vg_name = find_lvm2_vg_name_for_uuid (daemon, uuid);\n  if (vg_name == NULL)\n    {\n      throw_error (context, ERROR_FAILED, \"Cannot find VG with UUID `%s'\", uuid);\n      goto out;\n    }\n  n = 0;\n  argv[n++] = \"vgrename\";\n  argv[n++] = (gchar *) vg_name;\n  argv[n++] = (gchar *) new_name;\n  argv[n++] = NULL;\n  if (!job_new (context, \"LinuxLvm2VGSetName\", TRUE, NULL, argv, NULL, linux_lvm2_vg_set_name_completed_cb, FALSE, NULL, NULL))\n    {\n      goto out;\n    }\n out:\n  ;\n}", "target": 0}
{"code": "static void nodeDestruct(struct SaveNode* node)\n{\n    if (node->v == &node->sorted)\n    {\n        tr_free(node->sorted.val.l.vals);\n    }\n}", "target": 1}
{"code": "bool CMerkleTx::AcceptToMemoryPool(CTxDB &txdb, bool fCheckInputs) {\n    return(CTransaction::AcceptToMemoryPool(txdb, fCheckInputs));\n}", "target": 1}
{"code": "void Item_ref::update_used_tables()\n{\n  if (!get_depended_from())\n    (*ref)->update_used_tables();\n}", "target": 0}
{"code": "void gru_check_context_placement(struct gru_thread_state *gts)\n{\n\tstruct gru_state *gru;\n\tgru = gts->ts_gru;\n\tif (!gru || gts->ts_tgid_owner != current->tgid)\n\t\treturn;\n\tif (!gru_check_chiplet_assignment(gru, gts)) {\n\t\tSTAT(check_context_unload);\n\t\tgru_unload_context(gts, 1);\n\t} else if (gru_retarget_intr(gts)) {\n\t\tSTAT(check_context_retarget_intr);\n\t}\n}", "target": 1}
{"code": "  TextureManager::TextureInfo* GetTextureInfoForTarget(GLenum target) {\n    TextureUnit& unit = texture_units_[active_texture_unit_];\n    TextureManager::TextureInfo* info = NULL;\n    switch (target) {\n      case GL_TEXTURE_2D:\n        info = unit.bound_texture_2d;\n        break;\n      case GL_TEXTURE_CUBE_MAP:\n      case GL_TEXTURE_CUBE_MAP_POSITIVE_X:\n      case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:\n      case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:\n      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:\n      case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:\n      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:\n        info = unit.bound_texture_cube_map;\n        break;\n      default:\n        NOTREACHED();\n        return NULL;\n    }\n    return (info && !info->IsDeleted()) ? info : NULL;\n  }", "target": 0}
{"code": "  void Inspect::operator()(Complex_Selector_Ptr c)\n  {\n    Compound_Selector_Obj      head = c->head();\n    Complex_Selector_Obj            tail = c->tail();\n    Complex_Selector::Combinator comb = c->combinator();\n    if (comb == Complex_Selector::ANCESTOR_OF && (!head || head->empty())) {\n      if (tail) tail->perform(this);\n      return;\n    }\n    if (c->has_line_feed()) {\n      if (!(c->has_parent_ref())) {\n        append_optional_linefeed();\n        append_indentation();\n      }\n    }\n    if (head && head->length() != 0) head->perform(this);\n    bool is_empty = !head || head->length() == 0 || head->is_empty_reference();\n    bool is_tail = head && !head->is_empty_reference() && tail;\n    if (output_style() == COMPRESSED && comb != Complex_Selector::ANCESTOR_OF) scheduled_space = 0;\n    switch (comb) {\n      case Complex_Selector::ANCESTOR_OF:\n        if (is_tail) append_mandatory_space();\n      break;\n      case Complex_Selector::PARENT_OF:\n        append_optional_space();\n        append_string(\">\");\n        append_optional_space();\n      break;\n      case Complex_Selector::ADJACENT_TO:\n        append_optional_space();\n        append_string(\"+\");\n        append_optional_space();\n      break;\n      case Complex_Selector::REFERENCE:\n        append_mandatory_space();\n        append_string(\"/\");\n        c->reference()->perform(this);\n        append_string(\"/\");\n        append_mandatory_space();\n      break;\n      case Complex_Selector::PRECEDES:\n        if (is_empty) append_optional_space();\n        else append_mandatory_space();\n        append_string(\"~\");\n        if (tail) append_mandatory_space();\n        else append_optional_space();\n      break;\n      default: break;\n    }\n    if (tail && comb != Complex_Selector::ANCESTOR_OF) {\n      if (c->has_line_break()) append_optional_linefeed();\n    }\n    if (tail) tail->perform(this);\n    if (!tail && c->has_line_break()) {\n      if (output_style() == COMPACT) {\n        append_mandatory_space();\n      }\n    }\n  }", "target": 1}
{"code": "dtls1_process_buffered_records(SSL *s)\n    {\n    pitem *item;\n    item = pqueue_peek(s->d1->unprocessed_rcds.q);\n    if (item)\n        {\n        if (s->d1->unprocessed_rcds.epoch != s->d1->r_epoch)\n            return(1);  \n        while (pqueue_peek(s->d1->unprocessed_rcds.q))\n            {\n            dtls1_get_unprocessed_record(s);\n            if ( ! dtls1_process_record(s))\n                return(0);\n            dtls1_buffer_record(s, &(s->d1->processed_rcds), \n                s->s3->rrec.seq_num);\n            }\n        }\n    s->d1->processed_rcds.epoch = s->d1->r_epoch;\n    s->d1->unprocessed_rcds.epoch = s->d1->r_epoch + 1;\n    return(1);\n    }", "target": 1}
{"code": "njs_function_frame_save(njs_vm_t *vm, njs_frame_t *frame, u_char *pc)\n{\n    size_t              value_count, n;\n    njs_value_t         *start, *end, *p, **new, *value, **local;\n    njs_function_t      *function;\n    njs_native_frame_t  *active, *native;\n    *frame = *vm->active_frame;\n    frame->previous_active_frame = NULL;\n    native = &frame->native;\n    native->size = 0;\n    native->free = NULL;\n    native->free_size = 0;\n    active = &vm->active_frame->native;\n    value_count = njs_function_frame_value_count(active);\n    function = active->function;\n    new = (njs_value_t **) ((u_char *) native + NJS_FRAME_SIZE);\n    value = (njs_value_t *) (new + value_count\n                             + function->u.lambda->temp);\n    native->arguments = value;\n    native->arguments_offset = value + (function->args_offset - 1);\n    native->local = new + njs_function_frame_args_count(active);\n    native->temp = new + value_count;\n    native->pc = pc;\n    start = njs_function_frame_values(active, &end);\n    p = native->arguments;\n    while (start < end) {\n        *p = *start++;\n        *new++ = p++;\n    }\n    p = native->arguments;\n    local = native->local + function->args_offset;\n    for (n = 0; n < function->args_count; n++) {\n        if (!njs_is_valid(p)) {\n            njs_set_undefined(p);\n        }\n        *local++ = p++;\n    }\n    return NJS_OK;\n}", "target": 0}
{"code": "int read_record_hdr(int ifd, void *buffer, struct record_header *record_hdr,\n\t\t    struct file_header *file_hdr, int arch_64, int endian_mismatch,\n\t\t    int oneof, size_t b_size)\n{\n\tint rc;\n\tdo {\n\t\tif ((rc = sa_fread(ifd, buffer, (size_t) file_hdr->rec_size, SOFT_SIZE, oneof)) != 0)\n\t\t\treturn rc;\n\t\tif (remap_struct(rec_types_nr, file_hdr->rec_types_nr, buffer,\n\t\t\t\t file_hdr->rec_size, RECORD_HEADER_SIZE, b_size) < 0)\n\t\t\treturn 2;\n\t\tmemcpy(record_hdr, buffer, RECORD_HEADER_SIZE);\n\t\tif (endian_mismatch) {\n\t\t\tswap_struct(rec_types_nr, record_hdr, arch_64);\n\t\t}\n\t\tif ((record_hdr->record_type != R_COMMENT) && (record_hdr->record_type != R_RESTART) &&\n\t\t    record_hdr->extra_next && (skip_extra_struct(ifd, endian_mismatch, arch_64) < 0))\n\t\t\treturn 2;\n\t}\n\twhile (record_hdr->record_type == R_EXTRA);\n\treturn 0;\n}", "target": 0}
{"code": "status_t Parcel::write(const FlattenableHelperInterface& val)\n{\n status_t err;\n const size_t len = val.getFlattenedSize();\n const size_t fd_count = val.getFdCount();\n if ((len > INT32_MAX) || (fd_count > INT32_MAX)) {\n return BAD_VALUE;\n }\n    err = this->writeInt32(len);\n if (err) return err;\n    err = this->writeInt32(fd_count);\n if (err) return err;\n void* const buf = this->writeInplace(pad_size(len));\n if (buf == NULL)\n return BAD_VALUE;\n int* fds = NULL;\n if (fd_count) {\n        fds = new int[fd_count];\n }\n    err = val.flatten(buf, len, fds, fd_count);\n for (size_t i=0 ; i<fd_count && err==NO_ERROR ; i++) {\n        err = this->writeDupFileDescriptor( fds[i] );\n }\n if (fd_count) {\n delete [] fds;\n }\n return err;\n}", "target": 0}
{"code": "static void __net_exit ip6_route_net_exit(struct net *net)\n{\n\tkfree(net->ipv6.ip6_null_entry);\n#ifdef CONFIG_IPV6_MULTIPLE_TABLES\n\tkfree(net->ipv6.ip6_prohibit_entry);\n\tkfree(net->ipv6.ip6_blk_hole_entry);\n#endif\n\tdst_entries_destroy(&net->ipv6.ip6_dst_ops);\n}", "target": 0}
{"code": "display_debug_links (struct dwarf_section *  section,\n\t\t     void *                  file ATTRIBUTE_UNUSED)\n{\n  const unsigned char * filename;\n  unsigned int          filelen;\n  introduce (section, false);\n  filename =  section->start;\n  filelen = strnlen ((const char *) filename, section->size);\n  if (filelen == section->size)\n    {\n      warn (_(\"The debuglink filename is corrupt/missing\\n\"));\n      return 0;\n    }\n  printf (_(\"  Separate debug info file: %s\\n\"), filename);\n  if (startswith (section->name, \".gnu_debuglink\"))\n    {\n      unsigned int          crc32;\n      unsigned int          crc_offset;\n      crc_offset = filelen + 1;\n      crc_offset = (crc_offset + 3) & ~3;\n      if (crc_offset + 4 > section->size)\n\t{\n\t  warn (_(\"CRC offset missing/truncated\\n\"));\n\t  return 0;\n\t}\n      crc32 = byte_get (filename + crc_offset, 4);\n      printf (_(\"  CRC value: %#x\\n\"), crc32);\n      if (crc_offset + 4 < section->size)\n\t{\n\t  warn (_(\"There are %#lx extraneous bytes at the end of the section\\n\"),\n\t\t(long)(section->size - (crc_offset + 4)));\n\t  return 0;\n\t}\n    }\n  else \n    {\n      const unsigned char * build_id = section->start + filelen + 1;\n      bfd_size_type         build_id_len = section->size - (filelen + 1);\n      bfd_size_type         printed;\n      if (build_id_len < 0x14)\n\t{\n\t  warn (_(\"Build-ID is too short (%#lx bytes)\\n\"), (long) build_id_len);\n\t  return 0;\n\t}\n      printed = printf (_(\"  Build-ID (%#lx bytes):\"), (long) build_id_len);\n      display_data (printed, build_id, build_id_len);\n      putchar ('\\n');\n    }\n  putchar ('\\n');\n  return 1;\n}", "target": 0}
{"code": "de265_error decoder_context::read_pps_NAL(bitreader& reader)\n{\n  logdebug(LogHeaders,\"----> read PPS\\n\");\n  std::shared_ptr<pic_parameter_set> new_pps = std::make_shared<pic_parameter_set>();\n  bool success = new_pps->read(&reader,this);\n  if (param_pps_headers_fd>=0) {\n    new_pps->dump(param_pps_headers_fd);\n  }\n  if (success) {\n    pps[ (int)new_pps->pic_parameter_set_id ] = new_pps;\n  }\n  return success ? DE265_OK : DE265_WARNING_PPS_HEADER_INVALID;\n}", "target": 1}
{"code": "zrenamefile(i_ctx_t *i_ctx_p)\n{\n    int code;\n    os_ptr op = osp;\n    gs_parsed_file_name_t pname1, pname2;\n    code = parse_real_file_name(op, &pname2, imemory, \"renamefile(to)\");\n    if (code < 0)\n        return code;\n    pname1.fname = 0;\n    code = parse_real_file_name(op - 1, &pname1, imemory, \"renamefile(from)\");\n    if (code >= 0) {\n        gx_io_device *iodev_dflt = iodev_default(imemory);\n        if (pname1.iodev != pname2.iodev ) {\n            if (pname1.iodev == iodev_dflt)\n                pname1.iodev = pname2.iodev;\n            if (pname2.iodev == iodev_dflt)\n                pname2.iodev = pname1.iodev;\n        }\n        if (pname1.iodev != pname2.iodev ||\n            (pname1.iodev == iodev_dflt &&\n              ((check_file_permissions(i_ctx_p, pname1.fname, pname1.len,\n                                        pname1.iodev, \"PermitFileControl\") < 0 &&\n                  !file_is_tempfile(i_ctx_p, op[-1].value.bytes, r_size(op - 1))) ||\n              (check_file_permissions(i_ctx_p, pname2.fname, pname2.len,\n                                        pname2.iodev, \"PermitFileControl\") < 0 ||\n              check_file_permissions(i_ctx_p, pname2.fname, pname2.len,\n                                        pname2.iodev, \"PermitFileWriting\") < 0 )))) {\n            code = gs_note_error(gs_error_invalidfileaccess);\n        } else {\n            code = (*pname1.iodev->procs.rename_file)(pname1.iodev,\n                            pname1.fname, pname2.fname);\n        }\n    }\n    gs_free_file_name(&pname2, \"renamefile(to)\");\n    gs_free_file_name(&pname1, \"renamefile(from)\");\n    if (code < 0)\n        return code;\n    pop(2);\n    return 0;\n}", "target": 0}
{"code": "int nfc_deactivate_target(struct nfc_dev *dev, u32 target_idx, u8 mode)\n{\n\tint rc = 0;\n\tpr_debug(\"dev_name=%s target_idx=%u\\n\",\n\t\t dev_name(&dev->dev), target_idx);\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->active_target == NULL) {\n\t\trc = -ENOTCONN;\n\t\tgoto error;\n\t}\n\tif (dev->active_target->idx != target_idx) {\n\t\trc = -ENOTCONN;\n\t\tgoto error;\n\t}\n\tif (dev->ops->check_presence)\n\t\tdel_timer_sync(&dev->check_pres_timer);\n\tdev->ops->deactivate_target(dev, dev->active_target, mode);\n\tdev->active_target = NULL;\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "static int log_access_ok(void __user *log_base, u64 addr, unsigned long sz)\n{\n\tu64 a = addr / VHOST_PAGE_SIZE / 8;\n\tif (a > ULONG_MAX - (unsigned long)log_base ||\n\t    a + (unsigned long)log_base > ULONG_MAX)\n\t\treturn 0;\n\treturn access_ok(VERIFY_WRITE, log_base + a,\n\t\t\t (sz + VHOST_PAGE_SIZE * 8 - 1) / VHOST_PAGE_SIZE / 8);\n}", "target": 0}
{"code": "base64_decode(packet_info *pinfo, tvbuff_t *b64_tvb, char *name)\n{\n    char *data;\n    tvbuff_t *tvb;\n    data = tvb_get_string_enc(wmem_packet_scope(), b64_tvb, 0, tvb_reported_length(b64_tvb), ENC_ASCII);\n    tvb = base64_to_tvb(b64_tvb, data);\n    add_new_data_source(pinfo, tvb, name);\n    return tvb;\n}", "target": 0}
{"code": "xsltGetKey(xsltTransformContextPtr ctxt, const xmlChar *name,\n\t   const xmlChar *nameURI, const xmlChar *value) {\n    xmlNodeSetPtr ret;\n    xsltKeyTablePtr table;\n    int init_table = 0;\n    if ((ctxt == NULL) || (name == NULL) || (value == NULL) ||\n\t(ctxt->document == NULL))\n\treturn(NULL);\n#ifdef WITH_XSLT_DEBUG_KEYS\n    xsltGenericDebug(xsltGenericDebugContext,\n\t\"Get key %s, value %s\\n\", name, value);\n#endif\n    if ((ctxt->document->nbKeysComputed < ctxt->nbKeys) &&\n        (ctxt->keyInitLevel == 0)) {\n\tif (xsltInitAllDocKeys(ctxt))\n\t    return(NULL);\n    }\nretry:\n    table = (xsltKeyTablePtr) ctxt->document->keys;\n    while (table != NULL) {\n\tif (((nameURI != NULL) == (table->nameURI != NULL)) &&\n\t    xmlStrEqual(table->name, name) &&\n\t    xmlStrEqual(table->nameURI, nameURI))\n\t{\n\t    ret = (xmlNodeSetPtr)xmlHashLookup(table->keys, value);\n\t    return(ret);\n\t}\n\ttable = table->next;\n    }\n    if ((ctxt->keyInitLevel != 0) && (init_table == 0)) {\n        xsltInitDocKeyTable(ctxt, name, nameURI);\n\tinit_table = 1;\n\tgoto retry;\n    }\n    return(NULL);\n}", "target": 0}
{"code": "static int scrub_extent_for_parity(struct scrub_parity *sparity,\n\t\t\t\t   u64 logical, u64 len,\n\t\t\t\t   u64 physical, struct btrfs_device *dev,\n\t\t\t\t   u64 flags, u64 gen, int mirror_num)\n{\n\tstruct scrub_ctx *sctx = sparity->sctx;\n\tint ret;\n\tu8 csum[BTRFS_CSUM_SIZE];\n\tu32 blocksize;\n\tif (test_bit(BTRFS_DEV_STATE_MISSING, &dev->dev_state)) {\n\t\tscrub_parity_mark_sectors_error(sparity, logical, len);\n\t\treturn 0;\n\t}\n\tif (flags & BTRFS_EXTENT_FLAG_DATA) {\n\t\tblocksize = sparity->stripe_len;\n\t} else if (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK) {\n\t\tblocksize = sparity->stripe_len;\n\t} else {\n\t\tblocksize = sctx->fs_info->sectorsize;\n\t\tWARN_ON(1);\n\t}\n\twhile (len) {\n\t\tu64 l = min_t(u64, len, blocksize);\n\t\tint have_csum = 0;\n\t\tif (flags & BTRFS_EXTENT_FLAG_DATA) {\n\t\t\thave_csum = scrub_find_csum(sctx, logical, csum);\n\t\t\tif (have_csum == 0)\n\t\t\t\tgoto skip;\n\t\t}\n\t\tret = scrub_pages_for_parity(sparity, logical, l, physical, dev,\n\t\t\t\t\t     flags, gen, mirror_num,\n\t\t\t\t\t     have_csum ? csum : NULL);\n\t\tif (ret)\n\t\t\treturn ret;\nskip:\n\t\tlen -= l;\n\t\tlogical += l;\n\t\tphysical += l;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": " PPB_URLLoader_Impl::~PPB_URLLoader_Impl() {\n }", "target": 1}
{"code": "jmethodID InstanceKlass::get_jmethod_id_fetch_or_update(\n            size_t idnum, jmethodID new_id,\n            jmethodID* new_jmeths, jmethodID* to_dealloc_id_p,\n            jmethodID** to_dealloc_jmeths_p) {\n  assert(new_id != NULL, \"sanity check\");\n  assert(to_dealloc_id_p != NULL, \"sanity check\");\n  assert(to_dealloc_jmeths_p != NULL, \"sanity check\");\n  assert(Threads::number_of_threads() == 0 ||\n         SafepointSynchronize::is_at_safepoint() ||\n         JmethodIdCreation_lock->owned_by_self(), \"sanity check\");\n  jmethodID* jmeths = methods_jmethod_ids_acquire();\n  jmethodID  id     = NULL;\n  size_t     length = 0;\n  if (jmeths == NULL ||                         \n      (length = (size_t)jmeths[0]) <= idnum) {  \n    if (jmeths != NULL) {\n      for (size_t index = 0; index < length; index++) {\n        new_jmeths[index+1] = jmeths[index+1];\n      }\n      *to_dealloc_jmeths_p = jmeths;  \n    }\n    release_set_methods_jmethod_ids(jmeths = new_jmeths);\n  } else {\n    id = jmeths[idnum+1];\n    *to_dealloc_jmeths_p = new_jmeths;  \n  }\n  if (id == NULL) {\n    id = new_id;\n    OrderAccess::release_store(&jmeths[idnum+1], id);\n  } else {\n    *to_dealloc_id_p = new_id; \n  }\n  return id;\n}", "target": 0}
{"code": "static int transfer_size(int ssize, int max_sector, int max_size)\n{\n\tSUPBOUND(max_sector, fsector_t + max_size);\n\tmax_sector -= (max_sector % _floppy->sect) % ssize;\n\tcurrent_count_sectors = max_sector - fsector_t;\n\treturn max_sector;\n}", "target": 0}
{"code": "FramebufferModel::~FramebufferModel()\n{\n    delete[] m_pixelBuffer;\n}", "target": 1}
{"code": "void kvm_arch_vcpu_uninit(struct kvm_vcpu *vcpu)\n{\n\tint idx;\n\tkvm_pmu_destroy(vcpu);\n\tkfree(vcpu->arch.mce_banks);\n\tkvm_free_lapic(vcpu);\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tkvm_mmu_destroy(vcpu);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\tfree_page((unsigned long)vcpu->arch.pio_data);\n\tif (!irqchip_in_kernel(vcpu->kvm))\n\t\tstatic_key_slow_dec(&kvm_no_apic_vcpu);\n}", "target": 0}
{"code": "static int g2m_init_buffers(G2MContext *c)\n{\n    int aligned_height;\n    if (!c->framebuf || c->old_width < c->width || c->old_height < c->height) {\n        c->framebuf_stride = FFALIGN(c->width * 3, 16);\n        aligned_height     = FFALIGN(c->height,    16);\n        av_free(c->framebuf);\n        c->framebuf = av_mallocz(c->framebuf_stride * aligned_height);\n        if (!c->framebuf)\n            return AVERROR(ENOMEM);\n    }\n    if (!c->synth_tile || !c->jpeg_tile ||\n        c->old_tile_w < c->tile_width ||\n        c->old_tile_h < c->tile_height) {\n        c->tile_stride = FFALIGN(c->tile_width * 3, 16);\n        aligned_height = FFALIGN(c->tile_height,    16);\n        av_free(c->synth_tile);\n        av_free(c->jpeg_tile);\n        av_free(c->kempf_buf);\n        av_free(c->kempf_flags);\n        c->synth_tile  = av_mallocz(c->tile_stride      * aligned_height);\n        c->jpeg_tile   = av_mallocz(c->tile_stride      * aligned_height);\n        c->kempf_buf   = av_mallocz((c->tile_width + 1) * aligned_height\n                                    + FF_INPUT_BUFFER_PADDING_SIZE);\n        c->kempf_flags = av_mallocz( c->tile_width      * aligned_height);\n        if (!c->synth_tile || !c->jpeg_tile ||\n            !c->kempf_buf || !c->kempf_flags)\n            return AVERROR(ENOMEM);\n    }\n    return 0;\n}", "target": 1}
{"code": "static int gup_huge_pud(pud_t orig, pud_t *pudp, unsigned long addr,\n\t\tunsigned long end, int write, struct page **pages, int *nr)\n{\n\tstruct page *head, *page;\n\tint refs;\n\tif (!pud_access_permitted(orig, write))\n\t\treturn 0;\n\tif (pud_devmap(orig))\n\t\treturn __gup_device_huge_pud(orig, pudp, addr, end, pages, nr);\n\trefs = 0;\n\tpage = pud_page(orig) + ((addr & ~PUD_MASK) >> PAGE_SHIFT);\n\tdo {\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\t\tpage++;\n\t\trefs++;\n\t} while (addr += PAGE_SIZE, addr != end);\n\thead = compound_head(pud_page(orig));\n\tif (!page_cache_add_speculative(head, refs)) {\n\t\t*nr -= refs;\n\t\treturn 0;\n\t}\n\tif (unlikely(pud_val(orig) != pud_val(*pudp))) {\n\t\t*nr -= refs;\n\t\twhile (refs--)\n\t\t\tput_page(head);\n\t\treturn 0;\n\t}\n\tSetPageReferenced(head);\n\treturn 1;\n}", "target": 1}
{"code": "static bool get_user_list(struct torture_context *torture, char ***users)\n{\n\tstruct winbindd_request req;\n\tstruct winbindd_response rep;\n\tchar **u = NULL;\n\tuint32_t count;\n\tchar name[256];\n\tconst char *extra_data;\n\tZERO_STRUCT(req);\n\tZERO_STRUCT(rep);\n\tDO_STRUCT_REQ_REP(WINBINDD_LIST_USERS, &req, &rep);\n\textra_data = (char *)rep.extra_data.data;\n\ttorture_assert(torture, extra_data, \"NULL extra data\");\n\tfor(count = 0;\n\t    next_token(&extra_data, name, \",\", sizeof(name));\n\t    count++)\n\t{\n\t\tu = talloc_realloc(torture, u, char *, count + 2);\n\t\tu[count+1] = NULL;\n\t\tu[count] = talloc_strdup(u, name);\n\t}\n\tSAFE_FREE(rep.extra_data.data);\n\t*users = u;\n\treturn true;\n}", "target": 0}
{"code": "void http_capture_bad_message(struct error_snapshot *es, struct session *s,\n                              struct buffer *buf, struct http_msg *msg,\n\t\t\t      int state, struct proxy *other_end)\n{\n\tif (buf->r <= (buf->data + msg->som)) { \n\t\tint len1 = buf->size - msg->som;\n\t\tes->len = buf->r - (buf->data + msg->som) + buf->size;\n\t\tmemcpy(es->buf, buf->data + msg->som, MIN(len1, sizeof(es->buf)));\n\t\tif (es->len > len1 && len1 < sizeof(es->buf))\n\t\t\tmemcpy(es->buf + len1, buf->data, MIN(es->len, sizeof(es->buf)) - len1);\n\t}\n\telse {\n\t\tes->len = buf->r - (buf->data + msg->som);\n\t\tmemcpy(es->buf, buf->data + msg->som, MIN(es->len, sizeof(es->buf)));\n\t}\n\tif (msg->err_pos >= 0)\n\t\tes->pos  = msg->err_pos - msg->som;\n\telse if (buf->lr >= (buf->data + msg->som))\n\t\tes->pos  = buf->lr - (buf->data + msg->som);\n\telse\n\t\tes->pos  = buf->lr - (buf->data + msg->som) + buf->size;\n\tes->when = date; \n\tes->sid  = s->uniq_id;\n\tes->srv  = s->srv;\n\tes->oe   = other_end;\n\tes->src  = s->cli_addr;\n\tes->state = state;\n\tes->flags = buf->flags;\n\tes->ev_id = error_snapshot_id++;\n}", "target": 0}
{"code": "static void openssl_thread_setup(void)\n{\n    int i;\n    if (CRYPTO_get_locking_callback() != NULL) {\n        red_dump_openssl_errors();\n        return;\n    }\n    lock_cs = (pthread_mutex_t*) OPENSSL_malloc(CRYPTO_num_locks() * sizeof(pthread_mutex_t));\n    for (i = 0; i < CRYPTO_num_locks(); i++) {\n        pthread_mutex_init(&(lock_cs[i]), NULL);\n    }\n    CRYPTO_THREADID_set_callback(pthreads_thread_id);\n    CRYPTO_set_locking_callback(pthreads_locking_callback);\n}", "target": 0}
{"code": "void bootp_input(struct mbuf *m)\n{\n    struct bootp_t *bp = mtod_check(m, sizeof(struct bootp_t));\n    if (bp && bp->bp_op == BOOTP_REQUEST) {\n        bootp_reply(m->slirp, bp, m_end(m));\n    }\n}", "target": 0}
{"code": "static int tls1_check_sig_alg(SSL *s, X509 *x, int default_nid)\n{\n    int sig_nid, use_pc_sigalgs = 0;\n    size_t i;\n    const SIGALG_LOOKUP *sigalg;\n    size_t sigalgslen;\n    if (default_nid == -1)\n        return 1;\n    sig_nid = X509_get_signature_nid(x);\n    if (default_nid)\n        return sig_nid == default_nid ? 1 : 0;\n    if (SSL_IS_TLS13(s) && s->s3.tmp.peer_cert_sigalgs != NULL) {\n        sigalgslen = s->s3.tmp.peer_cert_sigalgslen;\n        use_pc_sigalgs = 1;\n    } else {\n        sigalgslen = s->shared_sigalgslen;\n    }\n    for (i = 0; i < sigalgslen; i++) {\n        sigalg = use_pc_sigalgs\n                 ? tls1_lookup_sigalg(s->s3.tmp.peer_cert_sigalgs[i])\n                 : s->shared_sigalgs[i];\n        if (sig_nid == sigalg->sigandhash)\n            return 1;\n    }\n    return 0;\n}", "target": 1}
{"code": "\t__must_hold(&ctx->completion_lock)\n{\n\tu32 seq = ctx->cached_cq_tail - atomic_read(&ctx->cq_timeouts);\n\tspin_lock_irq(&ctx->timeout_lock);\n\twhile (!list_empty(&ctx->timeout_list)) {\n\t\tu32 events_needed, events_got;\n\t\tstruct io_kiocb *req = list_first_entry(&ctx->timeout_list,\n\t\t\t\t\t\tstruct io_kiocb, timeout.list);\n\t\tif (io_is_timeout_noseq(req))\n\t\t\tbreak;\n\t\tevents_needed = req->timeout.target_seq - ctx->cq_last_tm_flush;\n\t\tevents_got = seq - ctx->cq_last_tm_flush;\n\t\tif (events_got < events_needed)\n\t\t\tbreak;\n\t\tlist_del_init(&req->timeout.list);\n\t\tio_kill_timeout(req, 0);\n\t}\n\tctx->cq_last_tm_flush = seq;\n\tspin_unlock_irq(&ctx->timeout_lock);\n}", "target": 1}
{"code": " static blink::WebScreenOrientations stringToOrientations(const AtomicString& orientationString)\n {\n     DEFINE_STATIC_LOCAL(const AtomicString, portrait, (\"portrait\", AtomicString::ConstructFromLiteral));\n     DEFINE_STATIC_LOCAL(const AtomicString, landscape, (\"landscape\", AtomicString::ConstructFromLiteral));\n     if (orientationString == portrait)\n         return blink::WebScreenOrientationPortraitPrimary | blink::WebScreenOrientationPortraitSecondary;\n     if (orientationString == landscape)\n        return blink::WebScreenOrientationLandscapePrimary | blink::WebScreenOrientationLandscapeSecondary;\n    unsigned length = 0;\n    ScreenOrientationInfo* orientationMap = orientationsMap(length);\n    for (unsigned i = 0; i < length; ++i) {\n        if (orientationMap[i].name == orientationString)\n            return orientationMap[i].orientation;\n    }\n    return 0;\n}", "target": 1}
{"code": "static int tcf_fill_node(struct sk_buff *skb, struct tcf_proto *tp,\n\t\t\t unsigned long fh, u32 pid, u32 seq, u16 flags, int event)\n{\n\tstruct tcmsg *tcm;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char *b = skb_tail_pointer(skb);\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*tcm), flags);\n\ttcm = NLMSG_DATA(nlh);\n\ttcm->tcm_family = AF_UNSPEC;\n\ttcm->tcm__pad1 = 0;\n\ttcm->tcm__pad1 = 0;\n\ttcm->tcm_ifindex = qdisc_dev(tp->q)->ifindex;\n\ttcm->tcm_parent = tp->classid;\n\ttcm->tcm_info = TC_H_MAKE(tp->prio, tp->protocol);\n\tNLA_PUT_STRING(skb, TCA_KIND, tp->ops->kind);\n\ttcm->tcm_handle = fh;\n\tif (RTM_DELTFILTER != event) {\n\t\ttcm->tcm_handle = 0;\n\t\tif (tp->ops->dump && tp->ops->dump(tp, fh, skb, tcm) < 0)\n\t\t\tgoto nla_put_failure;\n\t}\n\tnlh->nlmsg_len = skb_tail_pointer(skb) - b;\n\treturn skb->len;\nnlmsg_failure:\nnla_put_failure:\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}", "target": 1}
{"code": "xmlParseCheckTransition(xmlParserCtxtPtr ctxt, const char *chunk, int size) {\n    if ((ctxt == NULL) || (chunk == NULL) || (size < 0))\n        return(-1);\n    if (ctxt->instate == XML_PARSER_START_TAG) {\n        if (memchr(chunk, '>', size) != NULL)\n            return(1);\n        return(0);\n    }\n    if (ctxt->progressive == XML_PARSER_COMMENT) {\n        if (memchr(chunk, '>', size) != NULL)\n            return(1);\n        return(0);\n    }\n    if (ctxt->instate == XML_PARSER_CDATA_SECTION) {\n        if (memchr(chunk, '>', size) != NULL)\n            return(1);\n        return(0);\n    }\n    if (ctxt->progressive == XML_PARSER_PI) {\n        if (memchr(chunk, '>', size) != NULL)\n            return(1);\n        return(0);\n    }\n    if (ctxt->instate == XML_PARSER_END_TAG) {\n        if (memchr(chunk, '>', size) != NULL)\n            return(1);\n        return(0);\n    }\n    if ((ctxt->progressive == XML_PARSER_DTD) ||\n        (ctxt->instate == XML_PARSER_DTD)) {\n        if (memchr(chunk, '>', size) != NULL)\n            return(1);\n        return(0);\n    }\n    return(1);\n}", "target": 0}
{"code": "bool IsIDNComponentInSingleScript(const char16* str, int str_len) {\n  UScriptCode first_script = USCRIPT_INVALID_CODE;\n  bool is_first = true;\n  int i = 0;\n  while (i < str_len) {\n    unsigned code_point;\n    U16_NEXT(str, i, str_len, code_point);\n    UErrorCode err = U_ZERO_ERROR;\n    UScriptCode cur_script = uscript_getScript(code_point, &err);\n    if (err != U_ZERO_ERROR)\n      return false;  \n    cur_script = NormalizeScript(cur_script);\n    if (is_first && cur_script != USCRIPT_COMMON) {\n      first_script = cur_script;\n      is_first = false;\n    } else {\n      if (cur_script != USCRIPT_COMMON && cur_script != first_script)\n        return false;\n    }\n  }\n  return true;\n}", "target": 0}
{"code": "int re_yylex_init_extra(YY_EXTRA_TYPE yy_user_defined,yyscan_t* ptr_yy_globals )\n{\n    struct yyguts_t dummy_yyguts;\n    re_yyset_extra (yy_user_defined, &dummy_yyguts);\n    if (ptr_yy_globals == NULL){\n        errno = EINVAL;\n        return 1;\n    }\n    *ptr_yy_globals = (yyscan_t) re_yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );\n    if (*ptr_yy_globals == NULL){\n        errno = ENOMEM;\n        return 1;\n    }\n    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));\n    re_yyset_extra (yy_user_defined, *ptr_yy_globals);\n    return yy_init_globals ( *ptr_yy_globals );", "target": 1}
{"code": "MONGO_EXPORT int bson_append_element( bson *b, const char *name_or_null, const bson_iterator *elem ) {\n    bson_iterator next = *elem;\n    int size;\n    bson_iterator_next( &next );\n    size = next.cur - elem->cur;\n    if ( name_or_null == NULL ) {\n        if( bson_ensure_space( b, size ) == BSON_ERROR )\n            return BSON_ERROR;\n        bson_append( b, elem->cur, size );\n    }\n    else {\n        int data_size = size - 2 - strlen( bson_iterator_key( elem ) );\n        bson_append_estart( b, elem->cur[0], name_or_null, data_size );\n        bson_append( b, bson_iterator_value( elem ), data_size );\n    }\n    return BSON_OK;\n}", "target": 1}
{"code": "static void __init check_tylersburg_isoch(void)\n{\n\tstruct pci_dev *pdev;\n\tuint32_t vtisochctrl;\n\tpdev = pci_get_device(PCI_VENDOR_ID_INTEL, 0x3a3e, NULL);\n\tif (!pdev)\n\t\treturn;\n\tpci_dev_put(pdev);\n\tpdev = pci_get_device(PCI_VENDOR_ID_INTEL, 0x342e, NULL);\n\tif (!pdev)\n\t\treturn;\n\tif (pci_read_config_dword(pdev, 0x188, &vtisochctrl)) {\n\t\tpci_dev_put(pdev);\n\t\treturn;\n\t}\n\tpci_dev_put(pdev);\n\tif (vtisochctrl & 1)\n\t\treturn;\n\tvtisochctrl &= 0x1c;\n\tif (vtisochctrl == 0x10)\n\t\treturn;\n\tif (!vtisochctrl) {\n\t\tWARN(1, \"Your BIOS is broken; DMA routed to ISOCH DMAR unit but no TLB space.\\n\"\n\t\t     \"BIOS vendor: %s; Ver: %s; Product Version: %s\\n\",\n\t\t     dmi_get_system_info(DMI_BIOS_VENDOR),\n\t\t     dmi_get_system_info(DMI_BIOS_VERSION),\n\t\t     dmi_get_system_info(DMI_PRODUCT_VERSION));\n\t\tiommu_identity_mapping |= IDENTMAP_AZALIA;\n\t\treturn;\n\t}\n\tpr_warn(\"Recommended TLB entries for ISOCH unit is 16; your BIOS set %d\\n\",\n\t       vtisochctrl);\n}", "target": 0}
{"code": "TEST(MatchHeadersTest, HeaderContainsInverseMatch) {\n  TestRequestHeaderMapImpl matching_headers{{\"match-header\", \"123onevalue456\"}};\n  TestRequestHeaderMapImpl unmatching_headers{{\"match-header\", \"123anothervalue456\"}};\n  const std::string yaml = R\"EOF(\nname: match-header\ncontains_match: onevalue\ninvert_match: true\n  )EOF\";\n  std::vector<HeaderUtility::HeaderDataPtr> header_data;\n  header_data.push_back(\n      std::make_unique<HeaderUtility::HeaderData>(parseHeaderMatcherFromYaml(yaml)));\n  EXPECT_TRUE(HeaderUtility::matchHeaders(unmatching_headers, header_data));\n  EXPECT_FALSE(HeaderUtility::matchHeaders(matching_headers, header_data));\n}", "target": 0}
{"code": "static bool msr_mtrr_valid(unsigned msr)\n{\n\tswitch (msr) {\n\tcase 0x200 ... 0x200 + 2 * KVM_NR_VAR_MTRR - 1:\n\tcase MSR_MTRRfix64K_00000:\n\tcase MSR_MTRRfix16K_80000:\n\tcase MSR_MTRRfix16K_A0000:\n\tcase MSR_MTRRfix4K_C0000:\n\tcase MSR_MTRRfix4K_C8000:\n\tcase MSR_MTRRfix4K_D0000:\n\tcase MSR_MTRRfix4K_D8000:\n\tcase MSR_MTRRfix4K_E0000:\n\tcase MSR_MTRRfix4K_E8000:\n\tcase MSR_MTRRfix4K_F0000:\n\tcase MSR_MTRRfix4K_F8000:\n\tcase MSR_MTRRdefType:\n\tcase MSR_IA32_CR_PAT:\n\t\treturn true;\n\tcase 0x2f8:\n\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "PixarLogClose(TIFF* tif)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\ttd->td_bitspersample = 8;\n\ttd->td_sampleformat = SAMPLEFORMAT_UINT;\n}", "target": 1}
{"code": "int main(int ac, char *av[])\n{\n  int i, max_threads = 2;\n  pthread_t *threads;\n  if (ac < 2)\n    usage(av[0]);\n  queue = calloc(ac - 1, sizeof(queue[0]));\n  for (i = 1; i < ac; i++)\n  {\n    if (av[i][0] == '-')\n    {\n      if (av[i][1] == 'w')\n        use_camera_wb = 1;\n      if (av[i][1] == 'a')\n        use_auto_wb = 1;\n      if (av[i][1] == 'v')\n        verbose = 1;\n      if (av[i][1] == 'T')\n        tiff_mode = 1;\n      if (av[i][1] == 'J')\n      {\n        max_threads = atoi(av[++i]);\n        if (max_threads < 1)\n        {\n          fprintf(stderr, \"Job count should be at least 1\\n\");\n          exit(1);\n        }\n      }\n    }\n    else\n      queue[qsize++] = av[i];\n  }\n  pthread_mutex_init(&qm, NULL);\n  threads = calloc(max_threads, sizeof(threads[0]));\n  for (i = 0; i < max_threads; i++)\n    pthread_create(&threads[i], NULL, process_files, NULL);\n  for (i = 0; i < max_threads; i++)\n  {\n    int *iptr;\n    if (threads[i])\n    {\n      pthread_join(threads[i], (void *)&iptr);\n    }\n  }\n  return 0;\n}", "target": 0}
{"code": "static freelist_idx_t next_random_slot(union freelist_init_state *state)\n{\n\treturn (state->list[state->pos++] + state->rand) % state->count;\n}", "target": 1}
{"code": "uint8_t smb2cli_session_security_mode(struct smbXcli_session *session)\n{\n\tstruct smbXcli_conn *conn = session->conn;\n\tuint8_t security_mode = 0;\n\tif (conn == NULL) {\n\t\treturn security_mode;\n\t}\n\tsecurity_mode = SMB2_NEGOTIATE_SIGNING_ENABLED;\n        if (conn->mandatory_signing) {\n                security_mode |= SMB2_NEGOTIATE_SIGNING_REQUIRED;\n        }\n        return security_mode;\n }", "target": 1}
{"code": "AP_DECLARE(void) ap_send_interim_response(request_rec *r, int send_headers)\n{\n    hdr_ptr x;\n    char *status_line = NULL;\n    request_rec *rr;\n    if (r->proto_num < HTTP_VERSION(1,1)) {\n        return;\n    }\n    if (!ap_is_HTTP_INFO(r->status)) {\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00575)\n                      \"Status is %d - not sending interim response\", r->status);\n        return;\n    }\n    if ((r->status == HTTP_CONTINUE) && !r->expecting_100) {\n        return;\n    }\n    for (rr = r; rr != NULL; rr = rr->main) {\n        rr->expecting_100 = 0;\n    }\n    status_line = apr_pstrcat(r->pool, AP_SERVER_PROTOCOL, \" \", r->status_line, CRLF, NULL);\n    ap_xlate_proto_to_ascii(status_line, strlen(status_line));\n    x.f = r->connection->output_filters;\n    x.bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);\n    ap_fputs(x.f, x.bb, status_line);\n    if (send_headers) {\n        apr_table_do(send_header, &x, r->headers_out, NULL);\n        apr_table_clear(r->headers_out);\n    }\n    ap_fputs(x.f, x.bb, CRLF_ASCII);\n    ap_fflush(x.f, x.bb);\n    apr_brigade_destroy(x.bb);\n}", "target": 0}
{"code": "_polkit_subject_get_cmdline (PolkitSubject *subject, gint *pid, gint *uid)\n{\n  PolkitSubject *process;\n  gchar *ret;\n  gchar *filename;\n  gchar *contents;\n  gsize contents_len;\n  GError *error;\n  guint n;\n  g_return_val_if_fail (subject != NULL, NULL);\n  error = NULL;\n  ret = NULL;\n  process = NULL;\n  filename = NULL;\n  contents = NULL;\n  if (POLKIT_IS_UNIX_PROCESS (subject))\n   {\n      process = g_object_ref (subject);\n    }\n  else if (POLKIT_IS_SYSTEM_BUS_NAME (subject))\n    {\n      process = polkit_system_bus_name_get_process_sync (POLKIT_SYSTEM_BUS_NAME (subject),\n                                                         NULL,\n                                                         &error);\n      if (process == NULL)\n        {\n          g_warning (\"Error getting process for system bus name `%s': %s\",\n                     polkit_system_bus_name_get_name (POLKIT_SYSTEM_BUS_NAME (subject)),\n                     error->message);\n          g_error_free (error);\n          goto out;\n        }\n    }\n  else\n    {\n      g_warning (\"Unknown subject type passed to guess_program_name()\");\n      goto out;\n    }\n  *pid = polkit_unix_process_get_pid (POLKIT_UNIX_PROCESS (process));\n  *uid = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (process));\n  filename = g_strdup_printf (\"/proc/%d/cmdline\", *pid);\n  if (!g_file_get_contents (filename,\n                            &contents,\n                            &contents_len,\n                            &error))\n    {\n      g_warning (\"Error openeing `%s': %s\",\n                 filename,\n                 error->message);\n      g_error_free (error);\n      goto out;\n    }\n  for (n = 0; n < contents_len - 1; n++)\n    {\n      if (contents[n] == '\\0')\n        contents[n] = ' ';\n    }\n  ret = g_strdup (contents);\n  g_strstrip (ret);\n out:\n  g_free (filename);\n  g_free (contents);\n  if (process != NULL)\n    g_object_unref (process);\n  return ret;\n}", "target": 0}
{"code": "static void exif_process_APP12(image_info_type *ImageInfo,\n                               char *buffer, size_t length) {\n  size_t l1, l2=0;\n  if ((l1 = php_strnlen(buffer+2, length-2)) > 0) {\n    exif_iif_add_tag(ImageInfo, SECTION_APP12, \"Company\",\n                     TAG_NONE, TAG_FMT_STRING, l1, buffer+2);\n    if (length > 2+l1+1) {\n      l2 = php_strnlen(buffer+2+l1+1, length-2-l1+1);\n      exif_iif_add_tag(ImageInfo, SECTION_APP12, \"Info\",\n                       TAG_NONE, TAG_FMT_STRING, l2, buffer+2+l1+1);\n    }\n  }\n}", "target": 1}
{"code": "int jas_stream_printf(jas_stream_t *stream, const char *fmt, ...)\n{\n\tva_list ap;\n\tchar buf[4096];\n\tint ret;\n\tva_start(ap, fmt);\n\tret = vsprintf(buf, fmt, ap);\n\tjas_stream_puts(stream, buf);\n\tva_end(ap);\n\treturn ret;\n}", "target": 1}
{"code": "static int __vhost_add_used_n(struct vhost_virtqueue *vq,\n\t\t\t    struct vring_used_elem *heads,\n\t\t\t    unsigned count)\n{\n\tstruct vring_used_elem __user *used;\n\tu16 old, new;\n\tint start;\n\tstart = vq->last_used_idx % vq->num;\n\tused = vq->used->ring + start;\n\tif (__copy_to_user(used, heads, count * sizeof *used)) {\n\t\tvq_err(vq, \"Failed to write used\");\n\t\treturn -EFAULT;\n\t}\n\tif (unlikely(vq->log_used)) {\n\t\tsmp_wmb();\n\t\tlog_write(vq->log_base,\n\t\t\t  vq->log_addr +\n\t\t\t   ((void __user *)used - (void __user *)vq->used),\n\t\t\t  count * sizeof *used);\n\t}\n\told = vq->last_used_idx;\n\tnew = (vq->last_used_idx += count);\n\tif (unlikely((u16)(new - vq->signalled_used) < (u16)(new - old)))\n\t\tvq->signalled_used_valid = false;\n\treturn 0;\n}", "target": 0}
{"code": "static ssize_t ext4_direct_IO_read(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct address_space *mapping = iocb->ki_filp->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tsize_t count = iov_iter_count(iter);\n\tssize_t ret;\n\tinode_lock_shared(inode);\n\tret = filemap_write_and_wait_range(mapping, iocb->ki_pos,\n\t\t\t\t\t   iocb->ki_pos + count - 1);\n\tif (ret)\n\t\tgoto out_unlock;\n\tret = __blockdev_direct_IO(iocb, inode, inode->i_sb->s_bdev,\n\t\t\t\t   iter, ext4_dio_get_block, NULL, NULL, 0);\nout_unlock:\n\tinode_unlock_shared(inode);\n\treturn ret;\n}", "target": 0}
{"code": "void __init shm_init(void)\n{\n\tipc_init_proc_interface(\"sysvipc/shm\",\n#if BITS_PER_LONG <= 32\n\t\t\t\t\"       key      shmid perms       size  cpid  lpid nattch   uid   gid  cuid  cgid      atime      dtime      ctime        rss       swap\\n\",\n#else\n\t\t\t\t\"       key      shmid perms                  size  cpid  lpid nattch   uid   gid  cuid  cgid      atime      dtime      ctime                   rss                  swap\\n\",\n#endif\n\t\t\t\tIPC_SHM_IDS, sysvipc_shm_proc_show);\n}", "target": 0}
{"code": "  static void launch(OpKernelContext* context, const PoolParameters& params,\n                     const Tensor& grad_in, const Tensor& argmax,\n                     Tensor* grad_out, const bool include_batch_in_index) {\n    const DeviceBase::CpuWorkerThreads& worker_threads =\n        *(context->device()->tensorflow_cpu_worker_threads());\n    auto shard = [&grad_in, &argmax, &grad_out, include_batch_in_index](\n                     int64 start, int64 limit) {\n      const int64 batch_size =\n          GetTensorDim(grad_out->shape(), FORMAT_NHWC, 'N');\n      const int64 output_size_per_batch = grad_out->NumElements() / batch_size;\n      const int64 input_size_per_batch = grad_in.NumElements() / batch_size;\n      {\n        auto grad_out_flat = grad_out->flat<T>();\n        auto argmax_flat = argmax.flat<int64>();\n        auto grad_in_flat = grad_in.flat<T>();\n        const int64 output_start = start * output_size_per_batch;\n        const int64 output_end = limit * output_size_per_batch;\n        EigenMatrixMap inputShard(grad_out_flat.data() + output_start, 1,\n                                  output_end - output_start);\n        inputShard.setConstant(T(0));\n        const int input_start = start * input_size_per_batch;\n        const int input_end = limit * input_size_per_batch;\n        for (int64 index = input_start; index < input_end; index++) {\n          if (index >= argmax.NumElements()) {\n            break;\n          }\n          int64 grad_out_index = argmax_flat(index);\n          if (!include_batch_in_index) {\n            const int64 cur_batch = index / input_size_per_batch;\n            grad_out_index += cur_batch * output_size_per_batch;\n          }\n          CHECK(grad_out_index >= output_start && grad_out_index < output_end)\n              << \"Invalid output gradient index: \" << grad_out_index << \", \"\n              << output_start << \", \" << output_end;\n          grad_out_flat(grad_out_index) += grad_in_flat(index);\n        }\n      }\n    };\n    const int64 batch_size = GetTensorDim(grad_out->shape(), FORMAT_NHWC, 'N');\n    const int64 shard_cost = grad_out->NumElements() / batch_size;\n    Shard(worker_threads.num_threads, worker_threads.workers, batch_size,\n          shard_cost, shard);\n  }", "target": 0}
{"code": "resize_property_list(int new_size, const OnigCodePoint*** plist, int* psize)\n{\n  size_t size;\n  const OnigCodePoint **list = *plist;\n  size = sizeof(OnigCodePoint*) * new_size;\n  if (IS_NULL(list)) {\n    list = (const OnigCodePoint** )xmalloc(size);\n    if (IS_NULL(list)) return ONIGERR_MEMORY;\n  }\n  else {\n    const OnigCodePoint **tmp;\n    tmp = (const OnigCodePoint** )xrealloc((void* )list, size);\n    if (IS_NULL(tmp)) return ONIGERR_MEMORY;\n    list = tmp;\n  }\n  *plist = list;\n  *psize = new_size;\n  return 0;\n}", "target": 0}
{"code": "static int is_branch32_taken(struct bpf_reg_state *reg, u32 val, u8 opcode)\n{\n\tstruct tnum subreg = tnum_subreg(reg->var_off);\n\ts32 sval = (s32)val;\n\tswitch (opcode) {\n\tcase BPF_JEQ:\n\t\tif (tnum_is_const(subreg))\n\t\t\treturn !!tnum_equals_const(subreg, val);\n\t\tbreak;\n\tcase BPF_JNE:\n\t\tif (tnum_is_const(subreg))\n\t\t\treturn !tnum_equals_const(subreg, val);\n\t\tbreak;\n\tcase BPF_JSET:\n\t\tif ((~subreg.mask & subreg.value) & val)\n\t\t\treturn 1;\n\t\tif (!((subreg.mask | subreg.value) & val))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JGT:\n\t\tif (reg->u32_min_value > val)\n\t\t\treturn 1;\n\t\telse if (reg->u32_max_value <= val)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JSGT:\n\t\tif (reg->s32_min_value > sval)\n\t\t\treturn 1;\n\t\telse if (reg->s32_max_value <= sval)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JLT:\n\t\tif (reg->u32_max_value < val)\n\t\t\treturn 1;\n\t\telse if (reg->u32_min_value >= val)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JSLT:\n\t\tif (reg->s32_max_value < sval)\n\t\t\treturn 1;\n\t\telse if (reg->s32_min_value >= sval)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JGE:\n\t\tif (reg->u32_min_value >= val)\n\t\t\treturn 1;\n\t\telse if (reg->u32_max_value < val)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JSGE:\n\t\tif (reg->s32_min_value >= sval)\n\t\t\treturn 1;\n\t\telse if (reg->s32_max_value < sval)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JLE:\n\t\tif (reg->u32_max_value <= val)\n\t\t\treturn 1;\n\t\telse if (reg->u32_min_value > val)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JSLE:\n\t\tif (reg->s32_max_value <= sval)\n\t\t\treturn 1;\n\t\telse if (reg->s32_min_value > sval)\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\treturn -1;\n}", "target": 0}
{"code": "extract_one_file(EpubDocument* epub_document,GError ** error)\n{\n    GFile * outfile ;\n    gsize writesize = 0;\n    GString * gfilepath ;\n    unz_file_info64 info ;\n    gchar* directory;\n    GString* dir_create;\n    GFileOutputStream * outstream ;\n    if ( unzOpenCurrentFile(epub_document->epubDocument) != UNZ_OK )\n    {\n            return FALSE ;\n    }\n    gboolean result = TRUE;\n    gpointer currentfilename = g_malloc0(512);\n    unzGetCurrentFileInfo64(epub_document->epubDocument,&info,currentfilename,512,NULL,0,NULL,0) ;\n    directory = g_strrstr(currentfilename,\"/\") ;\n    if ( directory != NULL )\n        directory++;\n    gfilepath = g_string_new(epub_document->tmp_archive_dir) ;\n    g_string_append_printf(gfilepath,\"/%s\",(gchar*)currentfilename);\n    if (directory != NULL && *directory == '\\0')\n    {\n        g_mkdir(gfilepath->str,0777);\n        goto out;\n    }\n    else if (directory != NULL && *directory != '\\0' ) {\n        gchar* createdir = currentfilename;\n        gchar *createdirname = g_malloc0(strlen(currentfilename));\n        gchar *createdirnametemp = createdirname;\n        while ( createdir != directory ) {\n            (*createdirnametemp) = (*createdir);\n            createdirnametemp++;\n            createdir++;\n        }\n        (*createdirnametemp) = '\\0';\n        dir_create = g_string_new(epub_document->tmp_archive_dir);\n        g_string_append_printf(dir_create,\"/%s\",createdirname);\n        g_free(createdirname);\n        g_mkdir_with_parents(dir_create->str,0777);\n        g_string_free(dir_create,TRUE);\n    }\n    outfile = g_file_new_for_path(gfilepath->str);\n    outstream = g_file_create(outfile,G_FILE_CREATE_PRIVATE,NULL,error);\n    gpointer buffer = g_malloc0(512);\n    while ( (writesize = unzReadCurrentFile(epub_document->epubDocument,buffer,512) ) != 0 )\n    {\n        if ( g_output_stream_write((GOutputStream*)outstream,buffer,writesize,NULL,error) == -1 )\n        {\n            result = FALSE;\n            break;\n        }\n    }\n    g_free(buffer);\n    g_output_stream_close((GOutputStream*)outstream,NULL,error);\n    g_object_unref(outfile) ;\n    g_object_unref(outstream) ;\nout:\n    unzCloseCurrentFile (epub_document->epubDocument) ;\n    g_string_free(gfilepath,TRUE);\n    g_free(currentfilename);\n    return result;\n}", "target": 1}
{"code": "static void handle_swbp(struct pt_regs *regs)\n{\n\tstruct uprobe *uprobe;\n\tunsigned long bp_vaddr;\n\tint uninitialized_var(is_swbp);\n\tbp_vaddr = uprobe_get_swbp_addr(regs);\n\tif (bp_vaddr == get_trampoline_vaddr())\n\t\treturn handle_trampoline(regs);\n\tuprobe = find_active_uprobe(bp_vaddr, &is_swbp);\n\tif (!uprobe) {\n\t\tif (is_swbp > 0) {\n\t\t\tsend_sig(SIGTRAP, current, 0);\n\t\t} else {\n\t\t\tinstruction_pointer_set(regs, bp_vaddr);\n\t\t}\n\t\treturn;\n\t}\n\tinstruction_pointer_set(regs, bp_vaddr);\n\tsmp_rmb(); \n\tif (unlikely(!test_bit(UPROBE_COPY_INSN, &uprobe->flags)))\n\t\tgoto out;\n\tif (!get_utask())\n\t\tgoto out;\n\tif (arch_uprobe_ignore(&uprobe->arch, regs))\n\t\tgoto out;\n\thandler_chain(uprobe, regs);\n\tif (arch_uprobe_skip_sstep(&uprobe->arch, regs))\n\t\tgoto out;\n\tif (!pre_ssout(uprobe, regs, bp_vaddr))\n\t\treturn;\nout:\n\tput_uprobe(uprobe);\n}", "target": 0}
{"code": "static unsigned long get_unmapped_area_zero(struct file *file,\n\t\t\t\tunsigned long addr, unsigned long len,\n\t\t\t\tunsigned long pgoff, unsigned long flags)\n{\n#ifdef CONFIG_MMU\n\tif (flags & MAP_SHARED) {\n\t\treturn shmem_get_unmapped_area(NULL, addr, len, pgoff, flags);\n\t}\n\treturn current->mm->get_unmapped_area(file, addr, len, pgoff, flags);\n#else\n\treturn -ENOSYS;\n#endif\n}", "target": 0}
{"code": "rdpdr_handle_ok(int device, int handle)\n{\n\tswitch (g_rdpdr_device[device].device_type)\n\t{\n\t\tcase DEVICE_TYPE_PARALLEL:\n\t\tcase DEVICE_TYPE_SERIAL:\n\t\tcase DEVICE_TYPE_PRINTER:\n\t\tcase DEVICE_TYPE_SCARD:\n\t\t\tif (g_rdpdr_device[device].handle != handle)\n\t\t\t\treturn False;\n\t\t\tbreak;\n\t\tcase DEVICE_TYPE_DISK:\n\t\t\tif (g_fileinfo[handle].device_id != device)\n\t\t\t\treturn False;\n\t\t\tbreak;\n\t}\n\treturn True;\n}", "target": 0}
{"code": "int ossl_dsa_check_priv_key(const DSA *dsa, const BIGNUM *priv_key, int *ret)\n{\n    *ret = 0;\n    return (dsa->params.q != NULL\n            && ossl_ffc_validate_private_key(dsa->params.q, priv_key, ret));\n}", "target": 1}
{"code": "static inline int ccid_hc_tx_getsockopt(struct ccid *ccid, struct sock *sk,\n\t\t\t\t\tconst int optname, int len,\n\t\t\t\t\tu32 __user *optval, int __user *optlen)\n{\n\tint rc = -ENOPROTOOPT;\n\tif (ccid->ccid_ops->ccid_hc_tx_getsockopt != NULL)\n\t\trc = ccid->ccid_ops->ccid_hc_tx_getsockopt(sk, optname, len,\n\t\t\t\t\t\t optval, optlen);\n\treturn rc;\n}", "target": 1}
{"code": "bool Archive::Close()\n{\n#ifdef USE_ARCMEM\n  if (ArcMem.Unload())\n    return true;\n#endif\n  return File::Close();\n}", "target": 0}
{"code": "static void vhost_vdpa_config_put(struct vhost_vdpa *v)\n{\n\tif (v->config_ctx)\n\t\teventfd_ctx_put(v->config_ctx);\n}", "target": 1}
{"code": "  bool Messageheader::Parser::state_fieldbody_crlf(char ch)\n  {\n    if (ch == '\\r')\n      SET_STATE(state_end_cr);\n    else if (ch == '\\n')\n    {\n      log_debug(\"header \" << fieldnamePtr << \": \" << fieldbodyPtr);\n      switch (header.onField(fieldnamePtr, fieldbodyPtr))\n      {\n        case OK:\n        case END:  return true;\n                   break;\n        case FAIL: failedFlag = true;\n                   log_warn(\"invalid character \" << chartoprint(ch) << \" in fieldbody\");\n                   break;\n      }\n      *headerdataPtr = '\\0';\n      return true;\n    }\n    else if (std::isspace(ch))\n    {\n      checkHeaderspace(1);\n      *(headerdataPtr - 1) = '\\n';\n      *headerdataPtr++ = ch;\n      SET_STATE(state_fieldbody);\n    }\n    else if (ch >= 33 && ch <= 126)\n    {\n      switch (header.onField(fieldnamePtr, fieldbodyPtr))\n      {\n        case OK:   SET_STATE(state_fieldname);\n                   break;\n        case FAIL: failedFlag = true;\n                   log_warn(\"invalid character \" << chartoprint(ch) << \" in fieldbody\");\n                   break;\n        case END:  return true;\n                   break;\n      }\n      fieldnamePtr = headerdataPtr;\n      checkHeaderspace(1);\n      *headerdataPtr++ = ch;\n    }\n    return false;\n  }", "target": 1}
{"code": "static u32 swf_get_32(SWFReader *read)\n{\n\tu32 val, res;\n\tval = swf_read_int(read, 32);\n\tres = (val&0xFF);\n\tres <<=8;\n\tres |= ((val>>8)&0xFF);\n\tres<<=8;\n\tres |= ((val>>16)&0xFF);\n\tres<<=8;\n\tres|= ((val>>24)&0xFF);\n\treturn res;\n}", "target": 1}
{"code": "static inline struct sk_buff *__skb_dequeue(struct sk_buff_head *list)\n{\n\tstruct sk_buff *skb = skb_peek(list);\n\tif (skb)\n\t\t__skb_unlink(skb, list);\n\treturn skb;\n}", "target": 0}
{"code": "void nfs4_close_sync(struct path *path, struct nfs4_state *state, mode_t mode)\n{\n\t__nfs4_close(path, state, mode, 1);\n}", "target": 1}
{"code": "void rose_stop_idletimer(struct sock *sk)\n{\n\tdel_timer(&rose_sk(sk)->idletimer);\n}", "target": 1}
{"code": "static int write_empty_blocks(struct page *page, unsigned from, unsigned to,\n\t\t\t      int mode)\n{\n\tstruct inode *inode = page->mapping->host;\n\tunsigned start, end, next, blksize;\n\tsector_t block = page->index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\tint ret;\n\tblksize = 1 << inode->i_blkbits;\n\tnext = end = 0;\n\twhile (next < from) {\n\t\tnext += blksize;\n\t\tblock++;\n\t}\n\tstart = next;\n\tdo {\n\t\tnext += blksize;\n\t\tret = needs_empty_write(block, inode);\n\t\tif (unlikely(ret < 0))\n\t\t\treturn ret;\n\t\tif (ret == 0) {\n\t\t\tif (end) {\n\t\t\t\tret = __block_write_begin(page, start, end - start,\n\t\t\t\t\t\t\t  gfs2_block_map);\n\t\t\t\tif (unlikely(ret))\n\t\t\t\t\treturn ret;\n\t\t\t\tret = empty_write_end(page, start, end, mode);\n\t\t\t\tif (unlikely(ret))\n\t\t\t\t\treturn ret;\n\t\t\t\tend = 0;\n\t\t\t}\n\t\t\tstart = next;\n\t\t}\n\t\telse\n\t\t\tend = next;\n\t\tblock++;\n\t} while (next < to);\n\tif (end) {\n\t\tret = __block_write_begin(page, start, end - start, gfs2_block_map);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t\tret = empty_write_end(page, start, end, mode);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int af9005_identify_state(struct usb_device *udev,\n\t\t\t\t struct dvb_usb_device_properties *props,\n\t\t\t\t struct dvb_usb_device_description **desc,\n\t\t\t\t int *cold)\n{\n\tint ret;\n\tu8 reply, *buf;\n\tbuf = kmalloc(FW_BULKOUT_SIZE + 2, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tret = af9005_boot_packet(udev, FW_CONFIG, &reply,\n\t\t\t\t buf, FW_BULKOUT_SIZE + 2);\n\tif (ret)\n\t\tgoto err;\n\tdeb_info(\"result of FW_CONFIG in identify state %d\\n\", reply);\n\tif (reply == 0x01)\n\t\t*cold = 1;\n\telse if (reply == 0x02)\n\t\t*cold = 0;\n\telse\n\t\treturn -EIO;\n\tdeb_info(\"Identify state cold = %d\\n\", *cold);\nerr:\n\tkfree(buf);\n\treturn ret;\n}", "target": 1}
{"code": "get_blk_size(int fd)\n{\n\tstruct stat stat;\n\tint ret;\n\tret = fstat(fd, &stat);\n\treturn ret == -1 ? (uint64_t)-1 : (uint64_t)stat.st_blksize;\n}", "target": 0}
{"code": "context_parse_args (FlatpakContext *context,\n                    ...)\n{\n  g_autoptr(GError) local_error = NULL;\n  g_autoptr(GOptionContext) oc = NULL;\n  g_autoptr(GOptionGroup) group = NULL;\n  g_autoptr(GPtrArray) args = g_ptr_array_new_with_free_func (g_free);\n  g_auto(GStrv) argv = NULL;\n  const char *arg;\n  va_list ap;\n  g_ptr_array_add (args, g_strdup (\"argv[0]\"));\n  va_start (ap, context);\n  while ((arg = va_arg (ap, const char *)) != NULL)\n    g_ptr_array_add (args, g_strdup (arg));\n  va_end (ap);\n  g_ptr_array_add (args, NULL);\n  argv = (GStrv) g_ptr_array_free (g_steal_pointer (&args), FALSE);\n  oc = g_option_context_new (\"\");\n  group = flatpak_context_get_options (context);\n  g_option_context_add_group (oc, group);\n  g_option_context_parse_strv (oc, &argv, &local_error);\n  g_assert_no_error (local_error);\n}", "target": 1}
{"code": "static CURLcode cookie_output(struct Curl_easy *data,\n                              struct CookieInfo *c, const char *filename)\n{\n  struct Cookie *co;\n  FILE *out = NULL;\n  bool use_stdout = FALSE;\n  char *tempstore = NULL;\n  CURLcode error = CURLE_OK;\n  if(!c)\n    return CURLE_OK;\n  remove_expired(c);\n  if(!strcmp(\"-\", filename)) {\n    out = stdout;\n    use_stdout = TRUE;\n  }\n  else {\n    error = Curl_fopen(data, filename, &out, &tempstore);\n    if(error)\n      goto error;\n  }\n  fputs(\"# Netscape HTTP Cookie File\\n\"\n        \"# https:\n        \"# This file was generated by libcurl! Edit at your own risk.\\n\\n\",\n        out);\n  if(c->numcookies) {\n    unsigned int i;\n    size_t nvalid = 0;\n    struct Cookie **array;\n    array = calloc(1, sizeof(struct Cookie *) * c->numcookies);\n    if(!array) {\n      error = CURLE_OUT_OF_MEMORY;\n      goto error;\n    }\n    for(i = 0; i < COOKIE_HASH_SIZE; i++) {\n      for(co = c->cookies[i]; co; co = co->next) {\n        if(!co->domain)\n          continue;\n        array[nvalid++] = co;\n      }\n    }\n    qsort(array, nvalid, sizeof(struct Cookie *), cookie_sort_ct);\n    for(i = 0; i < nvalid; i++) {\n      char *format_ptr = get_netscape_format(array[i]);\n      if(!format_ptr) {\n        free(array);\n        error = CURLE_OUT_OF_MEMORY;\n        goto error;\n      }\n      fprintf(out, \"%s\\n\", format_ptr);\n      free(format_ptr);\n    }\n    free(array);\n  }\n  if(!use_stdout) {\n    fclose(out);\n    out = NULL;\n    if(tempstore && Curl_rename(tempstore, filename)) {\n      unlink(tempstore);\n      error = CURLE_WRITE_ERROR;\n      goto error;\n    }\n  }\n  free(tempstore);\n  return CURLE_OK;\nerror:\n  if(out && !use_stdout)\n    fclose(out);\n  free(tempstore);\n  return error;\n}", "target": 0}
{"code": "int GamutSampler(register const cmsUInt16Number In[], register cmsUInt16Number Out[], register void* Cargo)\n{\n    GAMUTCHAIN*  t = (GAMUTCHAIN* ) Cargo;\n    cmsCIELab LabIn1, LabOut1;\n    cmsCIELab LabIn2, LabOut2;\n    cmsUInt16Number Proof[cmsMAXCHANNELS], Proof2[cmsMAXCHANNELS];\n    cmsFloat64Number dE1, dE2, ErrorRatio;\n    ErrorRatio = 1.0;\n    cmsDoTransform(t -> hInput, In, &LabIn1, 1);\n    cmsDoTransform(t -> hForward, &LabIn1, Proof, 1);\n    cmsDoTransform(t -> hReverse, Proof, &LabOut1, 1);\n    memmove(&LabIn2, &LabOut1, sizeof(cmsCIELab));\n    cmsDoTransform(t -> hForward, &LabOut1, Proof2, 1);\n    cmsDoTransform(t -> hReverse, Proof2, &LabOut2, 1);\n    dE1 = cmsDeltaE(&LabIn1, &LabOut1);\n    dE2 = cmsDeltaE(&LabIn2, &LabOut2);\n    if (dE1 < t->Thereshold && dE2 < t->Thereshold)\n        Out[0] = 0;\n    else {\n        if (dE1 < t->Thereshold && dE2 > t->Thereshold)\n            Out[0] = 0;\n        else\n            if (dE1 > t->Thereshold && dE2 < t->Thereshold)\n                Out[0] = (cmsUInt16Number) _cmsQuickFloor((dE1 - t->Thereshold) + .5);\n            else  {\n                if (dE2 == 0.0)\n                    ErrorRatio = dE1;\n                else\n                    ErrorRatio = dE1 / dE2;\n                if (ErrorRatio > t->Thereshold)\n                    Out[0] = (cmsUInt16Number)  _cmsQuickFloor((ErrorRatio - t->Thereshold) + .5);\n                else\n                    Out[0] = 0;\n            }\n    }\n    return TRUE;\n}", "target": 0}
{"code": "void kvm_lapic_set_vapic_addr(struct kvm_vcpu *vcpu, gpa_t vapic_addr)\n{\n\tvcpu->arch.apic->vapic_addr = vapic_addr;\n\tif (vapic_addr)\n\t\t__set_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n\telse\n\t\t__clear_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n}", "target": 1}
{"code": "int PDFiumEngine::GetMostVisiblePage() {\n   if (in_flight_visible_page_)\n     return *in_flight_visible_page_;\n   CalculateVisiblePages();\n   return most_visible_page_;\n }", "target": 1}
{"code": "static void rtc_irq_eoi_tracking_reset(struct kvm_ioapic *ioapic)\n{\n\tioapic->rtc_status.pending_eoi = 0;\n\tbitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPUS);\n}", "target": 1}
{"code": "gss_wrap_iov (minor_status,\n              context_handle,\n              conf_req_flag,\n              qop_req,\n              conf_state,\n              iov,\n              iov_count)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\nint\t\t\tconf_req_flag;\ngss_qop_t\t\tqop_req;\nint *\t\t\tconf_state;\ngss_iov_buffer_desc  *\tiov;\nint\t\t\tiov_count;\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n    status = val_wrap_iov_args(minor_status, context_handle,\n\t\t\t       conf_req_flag, qop_req,\n\t\t\t       conf_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (mech) {\n\tif (mech->gss_wrap_iov) {\n\t    status = mech->gss_wrap_iov(\n\t\t\t\t\tminor_status,\n\t\t\t\t\tctx->internal_ctx_id,\n\t\t\t\t\tconf_req_flag,\n\t\t\t\t\tqop_req,\n\t\t\t\t\tconf_state,\n\t\t\t\t\tiov,\n\t\t\t\t\tiov_count);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\treturn(status);\n    }\n    return (GSS_S_BAD_MECH);\n}", "target": 0}
{"code": "const unsigned char* lodepng_chunk_next_const(const unsigned char* chunk)\n{\n  unsigned total_chunk_length = lodepng_chunk_length(chunk) + 12;\n  return &chunk[total_chunk_length];\n}", "target": 0}
{"code": "static void __exit packet_exit(void)\n{\n\tunregister_netdevice_notifier(&packet_netdev_notifier);\n\tunregister_pernet_subsys(&packet_net_ops);\n\tsock_unregister(PF_PACKET);\n\tproto_unregister(&packet_proto);\n}", "target": 0}
{"code": "xfs_inode_free_callback(\n\tstruct rcu_head\t\t*head)\n{\n\tstruct inode\t\t*inode = container_of(head, struct inode, i_rcu);\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tswitch (VFS_I(ip)->i_mode & S_IFMT) {\n\tcase S_IFREG:\n\tcase S_IFDIR:\n\tcase S_IFLNK:\n\t\txfs_idestroy_fork(ip, XFS_DATA_FORK);\n\t\tbreak;\n\t}\n\tif (ip->i_afp)\n\t\txfs_idestroy_fork(ip, XFS_ATTR_FORK);\n\tif (ip->i_cowfp)\n\t\txfs_idestroy_fork(ip, XFS_COW_FORK);\n\tif (ip->i_itemp) {\n\t\tASSERT(!(ip->i_itemp->ili_item.li_flags & XFS_LI_IN_AIL));\n\t\txfs_inode_item_destroy(ip);\n\t\tip->i_itemp = NULL;\n\t}\n\tkmem_zone_free(xfs_inode_zone, ip);\n}", "target": 0}
{"code": "static int handle_wrmsr(struct kvm_vcpu *vcpu)\n{\n\tstruct msr_data msr;\n\tu32 ecx = vcpu->arch.regs[VCPU_REGS_RCX];\n\tu64 data = (vcpu->arch.regs[VCPU_REGS_RAX] & -1u)\n\t\t| ((u64)(vcpu->arch.regs[VCPU_REGS_RDX] & -1u) << 32);\n\tmsr.data = data;\n\tmsr.index = ecx;\n\tmsr.host_initiated = false;\n\tif (vmx_set_msr(vcpu, &msr) != 0) {\n\t\ttrace_kvm_msr_write_ex(ecx, data);\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\ttrace_kvm_msr_write(ecx, data);\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}", "target": 1}
{"code": "static int qrtr_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t\tsize_t size, int flags)\n{\n\tDECLARE_SOCKADDR(struct sockaddr_qrtr *, addr, msg->msg_name);\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tstruct qrtr_cb *cb;\n\tint copied, rc;\n\tlock_sock(sk);\n\tif (sock_flag(sk, SOCK_ZAPPED)) {\n\t\trelease_sock(sk);\n\t\treturn -EADDRNOTAVAIL;\n\t}\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &rc);\n\tif (!skb) {\n\t\trelease_sock(sk);\n\t\treturn rc;\n\t}\n\tcb = (struct qrtr_cb *)skb->cb;\n\tcopied = skb->len;\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\trc = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (rc < 0)\n\t\tgoto out;\n\trc = copied;\n\tif (addr) {\n\t\taddr->sq_family = AF_QIPCRTR;\n\t\taddr->sq_node = cb->src_node;\n\t\taddr->sq_port = cb->src_port;\n\t\tmsg->msg_namelen = sizeof(*addr);\n\t}\nout:\n\tif (cb->confirm_rx)\n\t\tqrtr_send_resume_tx(cb);\n\tskb_free_datagram(sk, skb);\n\trelease_sock(sk);\n\treturn rc;\n}", "target": 1}
{"code": "static void ext4_end_io_work(struct work_struct *work)\n{\n\text4_io_end_t *io  = container_of(work, ext4_io_end_t, work);\n\tstruct inode *inode = io->inode;\n\tint ret = 0;\n\tmutex_lock(&inode->i_mutex);\n\tret = ext4_end_io_nolock(io);\n\tif (ret >= 0) {\n\t\tif (!list_empty(&io->list))\n\t\t\tlist_del_init(&io->list);\n\t\text4_free_io_end(io);\n\t}\n\tmutex_unlock(&inode->i_mutex);\n}", "target": 1}
{"code": "CString CWebSock::GetSkinPath(const CString& sSkinName) {\n    CString sRet = CZNC::Get().GetZNCPath() + \"/webskins/\" + sSkinName;\n    if (!CFile::IsDir(sRet)) {\n        sRet = CZNC::Get().GetCurPath() + \"/webskins/\" + sSkinName;\n        if (!CFile::IsDir(sRet)) {\n            sRet = CString(_SKINDIR_) + \"/\" + sSkinName;\n        }\n    }\n    return sRet + \"/\";\n}", "target": 1}
{"code": "static void __ref adjust_range_page_size_mask(struct map_range *mr,\n\t\t\t\t\t\t\t int nr_range)\n{\n\tint i;\n\tfor (i = 0; i < nr_range; i++) {\n\t\tif ((page_size_mask & (1<<PG_LEVEL_2M)) &&\n\t\t    !(mr[i].page_size_mask & (1<<PG_LEVEL_2M))) {\n\t\t\tunsigned long start = round_down(mr[i].start, PMD_SIZE);\n\t\t\tunsigned long end = round_up(mr[i].end, PMD_SIZE);\n#ifdef CONFIG_X86_32\n\t\t\tif ((end >> PAGE_SHIFT) > max_low_pfn)\n\t\t\t\tcontinue;\n#endif\n\t\t\tif (memblock_is_region_memory(start, end - start))\n\t\t\t\tmr[i].page_size_mask |= 1<<PG_LEVEL_2M;\n\t\t}\n\t\tif ((page_size_mask & (1<<PG_LEVEL_1G)) &&\n\t\t    !(mr[i].page_size_mask & (1<<PG_LEVEL_1G))) {\n\t\t\tunsigned long start = round_down(mr[i].start, PUD_SIZE);\n\t\t\tunsigned long end = round_up(mr[i].end, PUD_SIZE);\n\t\t\tif (memblock_is_region_memory(start, end - start))\n\t\t\t\tmr[i].page_size_mask |= 1<<PG_LEVEL_1G;\n\t\t}\n\t}\n}", "target": 0}
{"code": "nfs_idmap_new(struct nfs_client *clp)\n{\n\tstruct idmap *idmap;\n\tstruct rpc_pipe *pipe;\n\tint error;\n\tidmap = kzalloc(sizeof(*idmap), GFP_KERNEL);\n\tif (idmap == NULL)\n\t\treturn -ENOMEM;\n\trpc_init_pipe_dir_object(&idmap->idmap_pdo,\n\t\t\t&nfs_idmap_pipe_dir_object_ops,\n\t\t\tidmap);\n\tpipe = rpc_mkpipe_data(&idmap_upcall_ops, 0);\n\tif (IS_ERR(pipe)) {\n\t\terror = PTR_ERR(pipe);\n\t\tgoto err;\n\t}\n\tidmap->idmap_pipe = pipe;\n\tmutex_init(&idmap->idmap_mutex);\n\terror = rpc_add_pipe_dir_object(clp->cl_net,\n\t\t\t&clp->cl_rpcclient->cl_pipedir_objects,\n\t\t\t&idmap->idmap_pdo);\n\tif (error)\n\t\tgoto err_destroy_pipe;\n\tclp->cl_idmap = idmap;\n\treturn 0;\nerr_destroy_pipe:\n\trpc_destroy_pipe_data(idmap->idmap_pipe);\nerr:\n\tkfree(idmap);\n\treturn error;\n}", "target": 0}
{"code": "static void smp_task_done(struct sas_task *task)\n{\n\tif (!del_timer(&task->slow_task->timer))\n\t\treturn;\n\tcomplete(&task->slow_task->completion);\n}", "target": 1}
{"code": "static int x509_info_subject_alt_name( char **buf, size_t *size,\n                                       const mbedtls_x509_sequence *subject_alt_name )\n{\n    size_t i;\n    size_t n = *size;\n    char *p = *buf;\n    const mbedtls_x509_sequence *cur = subject_alt_name;\n    const char *sep = \"\";\n    size_t sep_len = 0;\n    while( cur != NULL )\n    {\n        if( cur->buf.len + sep_len >= n )\n        {\n            *p = '\\0';\n            return( MBEDTLS_ERR_X509_BUFFER_TOO_SMALL );\n        }\n        n -= cur->buf.len + sep_len;\n        for( i = 0; i < sep_len; i++ )\n            *p++ = sep[i];\n        for( i = 0; i < cur->buf.len; i++ )\n            *p++ = cur->buf.p[i];\n        sep = \", \";\n        sep_len = 2;\n        cur = cur->next;\n    }\n    *p = '\\0';\n    *size = n;\n    *buf = p;\n    return( 0 );\n}", "target": 0}
{"code": "comics_document_finalize (GObject *object)\n{\n\tComicsDocument *comics_document = COMICS_DOCUMENT (object);\n\tif (comics_document->decompress_tmp) {\n\t\tif (comics_remove_dir (comics_document->dir) == -1)\n\t\t\tg_warning (_(\"There was an error deleting %s.\"),\n\t\t\t\t   comics_document->dir);\n\t\tg_free (comics_document->dir);\n\t}\n\tif (comics_document->page_names) {\n                g_ptr_array_foreach (comics_document->page_names, (GFunc) g_free, NULL);\n                g_ptr_array_free (comics_document->page_names, TRUE);\n\t}\n\tg_free (comics_document->archive);\n\tg_free (comics_document->selected_command);\n\tg_free (comics_document->alternative_command);\n\tg_free (comics_document->extract_command);\n\tg_free (comics_document->list_command);\n\tG_OBJECT_CLASS (comics_document_parent_class)->finalize (object);\n}", "target": 1}
{"code": "static size_t send_control_msg(VirtIOSerial *vser, void *buf, size_t len)\n{\n    VirtQueueElement elem;\n    VirtQueue *vq;\n    vq = vser->c_ivq;\n    if (!virtio_queue_ready(vq)) {\n        return 0;\n    }\n    if (!virtqueue_pop(vq, &elem)) {\n        return 0;\n    }\n    memcpy(elem.in_sg[0].iov_base, buf, len);\n    virtqueue_push(vq, &elem, len);\n    virtio_notify(VIRTIO_DEVICE(vser), vq);\n    return len;\n}", "target": 1}
{"code": "MONGO_EXPORT int bson_append_code_w_scope_n( bson *b, const char *name,\n        const char *code, int len, const bson *scope ) {\n    int sl, size;\n    if ( !scope ) return BSON_ERROR;\n    sl = len + 1;\n    size = 4 + 4 + sl + bson_size( scope );\n    if ( bson_append_estart( b, BSON_CODEWSCOPE, name, size ) == BSON_ERROR )\n        return BSON_ERROR;\n    bson_append32( b, &size );\n    bson_append32( b, &sl );\n    bson_append( b, code, sl );\n    bson_append( b, scope->data, bson_size( scope ) );\n    return BSON_OK;\n}", "target": 1}
{"code": "int udp_lib_setsockopt(struct sock *sk, int level, int optname,\n\t\t       char __user *optval, unsigned int optlen,\n\t\t       int (*push_pending_frames)(struct sock *))\n{\n\tstruct udp_sock *up = udp_sk(sk);\n\tint val, valbool;\n\tint err = 0;\n\tint is_udplite = IS_UDPLITE(sk);\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\tvalbool = val ? 1 : 0;\n\tswitch (optname) {\n\tcase UDP_CORK:\n\t\tif (val != 0) {\n\t\t\tup->corkflag = 1;\n\t\t} else {\n\t\t\tup->corkflag = 0;\n\t\t\tlock_sock(sk);\n\t\t\tpush_pending_frames(sk);\n\t\t\trelease_sock(sk);\n\t\t}\n\t\tbreak;\n\tcase UDP_ENCAP:\n\t\tswitch (val) {\n\t\tcase 0:\n\t\tcase UDP_ENCAP_ESPINUDP:\n\t\tcase UDP_ENCAP_ESPINUDP_NON_IKE:\n\t\t\tup->encap_rcv = xfrm4_udp_encap_rcv;\n\t\tcase UDP_ENCAP_L2TPINUDP:\n\t\t\tup->encap_type = val;\n\t\t\tudp_encap_enable();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -ENOPROTOOPT;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase UDP_NO_CHECK6_TX:\n\t\tup->no_check6_tx = valbool;\n\t\tbreak;\n\tcase UDP_NO_CHECK6_RX:\n\t\tup->no_check6_rx = valbool;\n\t\tbreak;\n\tcase UDPLITE_SEND_CSCOV:\n\t\tif (!is_udplite)         \n\t\t\treturn -ENOPROTOOPT;\n\t\tif (val != 0 && val < 8) \n\t\t\tval = 8;\n\t\telse if (val > USHRT_MAX)\n\t\t\tval = USHRT_MAX;\n\t\tup->pcslen = val;\n\t\tup->pcflag |= UDPLITE_SEND_CC;\n\t\tbreak;\n\tcase UDPLITE_RECV_CSCOV:\n\t\tif (!is_udplite)         \n\t\t\treturn -ENOPROTOOPT;\n\t\tif (val != 0 && val < 8) \n\t\t\tval = 8;\n\t\telse if (val > USHRT_MAX)\n\t\t\tval = USHRT_MAX;\n\t\tup->pcrlen = val;\n\t\tup->pcflag |= UDPLITE_RECV_CC;\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\treturn err;\n}", "target": 0}
{"code": "bluetooth_client_get_connectable(const char **uuids)\n{\n\tint i, j;\n\tfor (i = 0; uuids && uuids[i] != NULL; i++) {\n\t\tfor (j = 0; j < G_N_ELEMENTS (connectable_uuids); j++) {\n\t\t\tif (g_str_equal (connectable_uuids[j], uuids[i]))\n\t\t\t\treturn TRUE;\n\t\t}\n\t}\n\treturn FALSE;\n}", "target": 0}
{"code": "static struct nfs4_ff_layout_mirror *ff_layout_alloc_mirror(gfp_t gfp_flags)\n{\n\tstruct nfs4_ff_layout_mirror *mirror;\n\tmirror = kzalloc(sizeof(*mirror), gfp_flags);\n\tif (mirror != NULL) {\n\t\tspin_lock_init(&mirror->lock);\n\t\trefcount_set(&mirror->ref, 1);\n\t\tINIT_LIST_HEAD(&mirror->mirrors);\n\t}\n\treturn mirror;\n}", "target": 0}
{"code": "dns_stricmp(const char* str1, const char* str2)\n{\n  char c1, c2;\n  *----------------------------------------------------------------------------*/\nstatic struct udp_pcb        *dns_pcb;\n static u8_t                   dns_seqno;\n static struct dns_table_entry dns_table[DNS_TABLE_SIZE];\n static struct dns_req_entry   dns_requests[DNS_MAX_REQUESTS];\n        if (c1_upc != c2_upc) {\n          return 1;\n        }\n      } else {\n        return 1;\n      }", "target": 1}
{"code": "void nl80211_send_disconnected(struct cfg80211_registered_device *rdev,\n\t\t\t       struct net_device *netdev, u16 reason,\n\t\t\t       const u8 *ie, size_t ie_len, bool from_ap)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_DISCONNECT);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    (from_ap && reason &&\n\t     nla_put_u16(msg, NL80211_ATTR_REASON_CODE, reason)) ||\n\t    (from_ap &&\n\t     nla_put_flag(msg, NL80211_ATTR_DISCONNECTED_BY_AP)) ||\n\t    (ie && nla_put(msg, NL80211_ATTR_IE, ie_len, ie)))\n\t\tgoto nla_put_failure;\n\tgenlmsg_end(msg, hdr);\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_mlme_mcgrp.id, GFP_KERNEL);\n\treturn;\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tnlmsg_free(msg);\n}", "target": 0}
{"code": "static void vgacon_scrollback_switch(int vc_num)\n{\n\tif (!scrollback_persistent)\n\t\tvc_num = 0;\n\tif (!vgacon_scrollbacks[vc_num].data) {\n\t\tvgacon_scrollback_init(vc_num);\n\t} else {\n\t\tif (scrollback_persistent) {\n\t\t\tvgacon_scrollback_cur = &vgacon_scrollbacks[vc_num];\n\t\t} else {\n\t\t\tsize_t size = CONFIG_VGACON_SOFT_SCROLLBACK_SIZE * 1024;\n\t\t\tvgacon_scrollback_reset(vc_num, size);\n\t\t}\n\t}\n}", "target": 1}
{"code": "static inline void CheckEventLogging()\n{\n  if (IsLinkedListEmpty(log_cache) != MagickFalse)\n    event_logging=MagickFalse;\n  else\n    {\n      LogInfo\n        *p;\n      ResetLinkedListIterator(log_cache);\n      p=(LogInfo *) GetNextValueInLinkedList(log_cache);\n      event_logging=p->event_mask != NoEvents ? MagickTrue: MagickFalse;\n    }\n}", "target": 1}
{"code": "MONGO_EXPORT int bson_append_symbol_n( bson *b, const char *name, const char *value, int len ) {\n    return bson_append_string_base( b, name, value, len, BSON_SYMBOL );\n}", "target": 1}
{"code": "static CPINLINE zend_class_entry* swoole_try_get_ce(zend_string *class_name)\n{\n    zend_class_entry *ce = zend_lookup_class(class_name);\n    if (ce)\n    {\n        return ce;\n    }\n    zval user_func, args[1], retval;\n    if ((PG(unserialize_callback_func) == NULL) || (PG(unserialize_callback_func)[0] == '\\0'))\n    {\n        zend_throw_exception_ex(NULL, 0, \"can not find class %s\", class_name->val TSRMLS_CC);\n        return NULL;\n    }\n    zend_string *fname = swoole_string_init(ZEND_STRL(PG(unserialize_callback_func)));\n    Z_STR(user_func) = fname;\n    Z_TYPE_INFO(user_func) = IS_STRING_EX;\n    ZVAL_STR(&args[0], class_name);\n    call_user_function_ex(CG(function_table), NULL, &user_func, &retval, 1, args, 0, NULL);\n    swoole_string_release(fname);\n    ce = zend_lookup_class(class_name);\n    if (!ce)\n    {\n        zend_throw_exception_ex(NULL, 0, \"can not find class %s\", class_name->val TSRMLS_CC);\n        return NULL;\n    }\n    else\n    {\n        return ce;\n    }\n}", "target": 1}
{"code": "void Context::onStart(absl::string_view root_id, absl::string_view vm_configuration) {\n  if (wasm_->onStart_) {\n    auto root_id_addr = wasm_->copyString(root_id);\n    auto config_addr = wasm_->copyString(vm_configuration);\n    wasm_->onStart_(this, id_, root_id_addr, root_id.size(), config_addr, vm_configuration.size());\n  }\n  in_vm_context_created_ = true;\n}", "target": 0}
{"code": "wsemul_sun_output_control(struct wsemul_sun_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tint oargs;\n\tint rc;\n\tswitch (instate->inchar) {\n\tcase '0': case '1': case '2': case '3': case '4': \n\tcase '5': case '6': case '7': case '8': case '9':\n\t\tif (edp->nargs > SUN_EMUL_NARGS - 1) {\n\t\t\tbcopy(edp->args + 1, edp->args,\n\t\t\t    (SUN_EMUL_NARGS - 1) * sizeof(edp->args[0]));\n\t\t\tedp->args[edp->nargs = SUN_EMUL_NARGS - 1] = 0;\n\t\t}\n\t\tedp->args[edp->nargs] = (edp->args[edp->nargs] * 10) +\n\t\t    (instate->inchar - '0');\n\t\tbreak;\n\tcase ';':\t\t\n\t\tedp->nargs++;\n\t\tbreak;\n\tdefault:\t\t\n\t\toargs = edp->nargs++;\n\t\tif (edp->nargs > SUN_EMUL_NARGS)\n\t\t\tedp->nargs = SUN_EMUL_NARGS;\n\t\trc = wsemul_sun_control(edp, instate);\n\t\tif (rc != 0) {\n\t\t\tedp->nargs = oargs;\n\t\t\treturn rc;\n\t\t}\n\t\tedp->state = SUN_EMUL_STATE_NORMAL;\n\t\tbreak;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "  bool handleBackslash(signed char& out) {\n    char ch = *p++;\n    switch (ch) {\n      case 0: return false;\n      case '\"': out = ch; return true;\n      case '\\\\': out = ch; return true;\n      case '/': out = ch; return true;\n      case 'b': out = '\\b'; return true;\n      case 'f': out = '\\f'; return true;\n      case 'n': out = '\\n'; return true;\n      case 'r': out = '\\r'; return true;\n      case 't': out = '\\t'; return true;\n      case 'u': {\n        if (UNLIKELY(is_tsimplejson)) {\n          auto const ch1 = *p++;\n          auto const ch2 = *p++;\n          auto const dch3 = dehexchar(*p++);\n          auto const dch4 = dehexchar(*p++);\n          if (UNLIKELY(ch1 != '0' || ch2 != '0' || dch3 < 0 || dch4 < 0)) {\n            return false;\n          }\n          out = (dch3 << 4) | dch4;\n          return true;\n        } else {\n          uint16_t u16cp = 0;\n          for (int i = 0; i < 4; i++) {\n            auto const hexv = dehexchar(*p++);\n            if (hexv < 0) return false; \n            u16cp <<= 4;\n            u16cp |= hexv;\n          }\n          if (u16cp > 0x7f) {\n            return false;\n          } else {\n            out = u16cp;\n            return true;\n          }\n        }\n      }\n      default: return false;\n    }\n  }", "target": 1}
{"code": "  explicit BoostedTreesAggregateStatsOp(OpKernelConstruction* const context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"max_splits\", &max_splits_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_buckets\", &num_buckets_));\n  }", "target": 0}
{"code": "send_client_notifications (void)\n{\n  struct {\n    pid_t pid;\n#ifdef HAVE_W32_SYSTEM\n    HANDLE handle;\n#else\n    int signo;\n#endif\n  } killed[50];\n  int killidx = 0;\n  int kidx;\n  struct server_local_s *sl;\n  for (sl=session_list; sl; sl = sl->next_session)\n    {\n      if (sl->event_signal && sl->assuan_ctx)\n        {\n          pid_t pid = assuan_get_pid (sl->assuan_ctx);\n#ifdef HAVE_W32_SYSTEM\n          HANDLE handle = (void *)sl->event_signal;\n          for (kidx=0; kidx < killidx; kidx++)\n            if (killed[kidx].pid == pid\n                && killed[kidx].handle == handle)\n              break;\n          if (kidx < killidx)\n            log_info (\"event %lx (%p) already triggered for client %d\\n\",\n                      sl->event_signal, handle, (int)pid);\n          else\n            {\n              log_info (\"triggering event %lx (%p) for client %d\\n\",\n                        sl->event_signal, handle, (int)pid);\n              if (!SetEvent (handle))\n                log_error (\"SetEvent(%lx) failed: %s\\n\",\n                           sl->event_signal, w32_strerror (-1));\n              if (killidx < DIM (killed))\n                {\n                  killed[killidx].pid = pid;\n                  killed[killidx].handle = handle;\n                  killidx++;\n                }\n            }\n#else \n          int signo = sl->event_signal;\n          if (pid != (pid_t)(-1) && pid && signo > 0)\n            {\n              for (kidx=0; kidx < killidx; kidx++)\n                if (killed[kidx].pid == pid\n                    && killed[kidx].signo == signo)\n                  break;\n              if (kidx < killidx)\n                log_info (\"signal %d already sent to client %d\\n\",\n                          signo, (int)pid);\n              else\n                {\n                  log_info (\"sending signal %d to client %d\\n\",\n                            signo, (int)pid);\n                  kill (pid, signo);\n                  if (killidx < DIM (killed))\n                    {\n                      killed[killidx].pid = pid;\n                      killed[killidx].signo = signo;\n                      killidx++;\n                    }\n                }\n            }\n#endif \n        }\n    }\n}", "target": 0}
{"code": " ImageLoader::ImageLoader(Element* element)\n     : m_element(element),\n      m_derefElementTimer(TaskRunnerHelper::get(TaskType::Networking,\n                                                element->document().frame()),\n                          this,\n                          &ImageLoader::timerFired),\n       m_hasPendingLoadEvent(false),\n       m_hasPendingErrorEvent(false),\n       m_imageComplete(true),\n      m_loadingImageDocument(false),\n      m_elementIsProtected(false),\n      m_suppressErrorEvents(false) {\n  RESOURCE_LOADING_DVLOG(1) << \"new ImageLoader \" << this;\n}", "target": 0}
{"code": "static bool tailmatch(const char *cooke_domain, const char *hostname)\n{\n  size_t cookie_domain_len = strlen(cooke_domain);\n  size_t hostname_len = strlen(hostname);\n  if(hostname_len < cookie_domain_len)\n    return FALSE;\n  if(!strcasecompare(cooke_domain, hostname + hostname_len-cookie_domain_len))\n    return FALSE;\n  if(hostname_len == cookie_domain_len)\n    return TRUE;\n  if('.' == *(hostname + hostname_len - cookie_domain_len - 1))\n    return TRUE;\n  return FALSE;\n}", "target": 0}
{"code": "static int ext4_dax_pmd_fault(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\t\t\tpmd_t *pmd, unsigned int flags)\n{\n\tint result;\n\thandle_t *handle = NULL;\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tstruct super_block *sb = inode->i_sb;\n\tbool write = flags & FAULT_FLAG_WRITE;\n\tif (write) {\n\t\tsb_start_pagefault(sb);\n\t\tfile_update_time(vma->vm_file);\n\t\thandle = ext4_journal_start_sb(sb, EXT4_HT_WRITE_PAGE,\n\t\t\t\text4_chunk_trans_blocks(inode,\n\t\t\t\t\t\t\tPMD_SIZE / PAGE_SIZE));\n\t}\n\tif (IS_ERR(handle))\n\t\tresult = VM_FAULT_SIGBUS;\n\telse\n\t\tresult = __dax_pmd_fault(vma, addr, pmd, flags,\n\t\t\t\text4_get_block_dax, ext4_end_io_unwritten);\n\tif (write) {\n\t\tif (!IS_ERR(handle))\n\t\t\text4_journal_stop(handle);\n\t\tsb_end_pagefault(sb);\n\t}\n\treturn result;\n}", "target": 1}
{"code": "static u32 udp6_portaddr_hash(const struct net *net,\n\t\t\t      const struct in6_addr *addr6,\n\t\t\t      unsigned int port)\n{\n\tunsigned int hash, mix = net_hash_mix(net);\n\tif (ipv6_addr_any(addr6))\n\t\thash = jhash_1word(0, mix);\n\telse if (ipv6_addr_v4mapped(addr6))\n\t\thash = jhash_1word((__force u32)addr6->s6_addr32[3], mix);\n\telse\n\t\thash = jhash2((__force u32 *)addr6->s6_addr32, 4, mix);\n\treturn hash ^ port;\n}", "target": 0}
{"code": "ExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)\n{\n    unsigned nSyms = darray_size(expr->keysym_list.syms);\n    unsigned numEntries = darray_size(append->keysym_list.syms);\n    darray_append(expr->keysym_list.symsMapIndex, nSyms);\n    darray_append(expr->keysym_list.symsNumEntries, numEntries);\n    darray_concat(expr->keysym_list.syms, append->keysym_list.syms);\n    FreeStmt((ParseCommon *) &append);\n    return expr;\n}", "target": 1}
{"code": "static Array HHVM_METHOD(Memcache, getextendedstats,\n                         const String&  ,\n                         int  , int  ) {\n  auto data = Native::data<MemcacheData>(this_);\n  memcached_return_t ret;\n  memcached_stat_st *stats;\n  stats = memcached_stat(&data->m_memcache, nullptr, &ret);\n  if (ret != MEMCACHED_SUCCESS) {\n    return Array();\n  }\n  int server_count = memcached_server_count(&data->m_memcache);\n  Array return_val;\n  for (int server_id = 0; server_id < server_count; server_id++) {\n    memcached_stat_st *stat;\n    char stats_key[30] = {0};\n    size_t key_len;\n    LMCD_SERVER_POSITION_INSTANCE_TYPE instance =\n      memcached_server_instance_by_position(&data->m_memcache, server_id);\n    const char *hostname = LMCD_SERVER_HOSTNAME(instance);\n    in_port_t port = LMCD_SERVER_PORT(instance);\n    stat = stats + server_id;\n    Array server_stats = memcache_build_stats(&data->m_memcache, stat, &ret);\n    if (ret != MEMCACHED_SUCCESS) {\n      continue;\n    }\n    key_len = snprintf(stats_key, sizeof(stats_key), \"%s:%d\", hostname, port);\n    return_val.set(String(stats_key, key_len, CopyString), server_stats);\n  }\n  free(stats);\n  return return_val;\n}", "target": 1}
{"code": "get_pw_flags (NMSettingVpn *s_vpn, const char *secret_name, const char *type_name)\n{\n\tconst char *val;\n\tNMSettingSecretFlags flags = NM_SETTING_SECRET_FLAG_NONE;\n\tif (nm_setting_get_secret_flags (NM_SETTING (s_vpn), secret_name, &flags, NULL))\n\t\treturn flags;\n\tval = nm_setting_vpn_get_data_item (s_vpn, type_name);\n\tif (val) {\n\t\tif (g_strcmp0 (val, NM_VPNC_PW_TYPE_ASK) == 0)\n\t\t\treturn NM_SETTING_SECRET_FLAG_NOT_SAVED;\n\t\telse if (g_strcmp0 (val, NM_VPNC_PW_TYPE_UNUSED) == 0)\n\t\t\treturn NM_SETTING_SECRET_FLAG_NOT_REQUIRED;\n\t}\n\treturn NM_SETTING_SECRET_FLAG_NONE;\n}", "target": 0}
{"code": "void iov_iter_advance(struct iov_iter *i, size_t bytes)\n{\n\tBUG_ON(i->count < bytes);\n\tif (likely(i->nr_segs == 1)) {\n\t\ti->iov_offset += bytes;\n\t\ti->count -= bytes;\n\t} else {\n\t\tconst struct iovec *iov = i->iov;\n\t\tsize_t base = i->iov_offset;\n\t\twhile (bytes || unlikely(!iov->iov_len && i->count)) {\n\t\t\tint copy;\n\t\t\tcopy = min(bytes, iov->iov_len - base);\n\t\t\tBUG_ON(!i->count || i->count < copy);\n\t\t\ti->count -= copy;\n\t\t\tbytes -= copy;\n\t\t\tbase += copy;\n\t\t\tif (iov->iov_len == base) {\n\t\t\t\tiov++;\n\t\t\t\tbase = 0;\n\t\t\t}\n\t\t}\n\t\ti->iov = iov;\n\t\ti->iov_offset = base;\n\t}\n}", "target": 1}
{"code": "buflist_match(\n    regmatch_T\t*rmp,\n    buf_T\t*buf,\n    int\t\tignore_case)  \n{\n    char_u\t*match;\n    match = fname_match(rmp, buf->b_sfname, ignore_case);\n    if (match == NULL)\n\tmatch = fname_match(rmp, buf->b_ffname, ignore_case);\n    return match;\n}", "target": 1}
{"code": "static void php_mcrypt_module_dtor(zend_rsrc_list_entry *rsrc TSRMLS_DC) \n{\n\tphp_mcrypt *pm = (php_mcrypt *) rsrc->ptr;\n\tif (pm) {\t\n\t\tmcrypt_generic_deinit(pm->td);\n\t\tmcrypt_module_close(pm->td);\n\t\tefree(pm);\n\t\tpm = NULL;\n\t}", "target": 1}
{"code": "bgp_attr_finish (void)\n{\n  aspath_finish ();\n  attrhash_finish ();\n  community_finish ();\n  ecommunity_finish ();\n  cluster_finish ();\n  transit_finish ();\n}", "target": 0}
{"code": "void bio_trim(struct bio *bio, int offset, int size)\n{\n\tsize <<= 9;\n\tif (offset == 0 && size == bio->bi_iter.bi_size)\n\t\treturn;\n\tbio_clear_flag(bio, BIO_SEG_VALID);\n\tbio_advance(bio, offset << 9);\n\tbio->bi_iter.bi_size = size;\n\tif (bio_integrity(bio))\n\t\tbio_integrity_trim(bio);\n}", "target": 0}
{"code": "static void hugetlb_vm_op_open(struct vm_area_struct *vma)\n{\n\tstruct resv_map *resv = vma_resv_map(vma);\n\tif (resv && is_vma_resv_set(vma, HPAGE_RESV_OWNER)) {\n\t\tresv_map_dup_hugetlb_cgroup_uncharge_info(resv);\n\t\tkref_get(&resv->refs);\n\t}\n}", "target": 0}
{"code": "rb_reserve_next_event(struct ring_buffer *buffer,\n\t\t      struct ring_buffer_per_cpu *cpu_buffer,\n\t\t      unsigned long length)\n{\n\tstruct ring_buffer_event *event;\n\tstruct rb_event_info info;\n\tint nr_loops = 0;\n\tu64 diff;\n\trb_start_commit(cpu_buffer);\n#ifdef CONFIG_RING_BUFFER_ALLOW_SWAP\n\tbarrier();\n\tif (unlikely(ACCESS_ONCE(cpu_buffer->buffer) != buffer)) {\n\t\tlocal_dec(&cpu_buffer->committing);\n\t\tlocal_dec(&cpu_buffer->commits);\n\t\treturn NULL;\n\t}\n#endif\n\tinfo.length = rb_calculate_event_length(length);\n again:\n\tinfo.add_timestamp = 0;\n\tinfo.delta = 0;\n\tif (RB_WARN_ON(cpu_buffer, ++nr_loops > 1000))\n\t\tgoto out_fail;\n\tinfo.ts = rb_time_stamp(cpu_buffer->buffer);\n\tdiff = info.ts - cpu_buffer->write_stamp;\n\tbarrier();\n\tif (likely(info.ts >= cpu_buffer->write_stamp)) {\n\t\tinfo.delta = diff;\n\t\tif (unlikely(test_time_stamp(info.delta)))\n\t\t\trb_handle_timestamp(cpu_buffer, &info);\n\t}\n\tevent = __rb_reserve_next(cpu_buffer, &info);\n\tif (unlikely(PTR_ERR(event) == -EAGAIN)) {\n\t\tif (info.add_timestamp)\n\t\t\tinfo.length -= RB_LEN_TIME_EXTEND;\n\t\tgoto again;\n\t}\n\tif (!event)\n\t\tgoto out_fail;\n\treturn event;\n out_fail:\n\trb_end_commit(cpu_buffer);\n\treturn NULL;\n}", "target": 0}
{"code": "static inline Quantum GetPixelChannel(const Image *magick_restrict image,\n  const PixelChannel channel,const Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[channel].traits == UndefinedPixelTrait)\n    return((Quantum) 0);\n  return(pixel[image->channel_map[channel].offset]);\n}", "target": 1}
{"code": "static int complete_emulated_mmio(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *run = vcpu->run;\n\tstruct kvm_mmio_fragment *frag;\n\tunsigned len;\n\tBUG_ON(!vcpu->mmio_needed);\n\tfrag = &vcpu->mmio_fragments[vcpu->mmio_cur_fragment];\n\tlen = min(8u, frag->len);\n\tif (!vcpu->mmio_is_write)\n\t\tmemcpy(frag->data, run->mmio.data, len);\n\tif (frag->len <= 8) {\n\t\tfrag++;\n\t\tvcpu->mmio_cur_fragment++;\n\t} else {\n\t\tfrag->data += len;\n\t\tfrag->gpa += len;\n\t\tfrag->len -= len;\n\t}\n\tif (vcpu->mmio_cur_fragment == vcpu->mmio_nr_fragments) {\n\t\tvcpu->mmio_needed = 0;\n\t\tif (vcpu->mmio_is_write)\n\t\t\treturn 1;\n\t\tvcpu->mmio_read_completed = 1;\n\t\treturn complete_emulated_io(vcpu);\n\t}\n\trun->exit_reason = KVM_EXIT_MMIO;\n\trun->mmio.phys_addr = frag->gpa;\n\tif (vcpu->mmio_is_write)\n\t\tmemcpy(run->mmio.data, frag->data, min(8u, frag->len));\n\trun->mmio.len = min(8u, frag->len);\n\trun->mmio.is_write = vcpu->mmio_is_write;\n\tvcpu->arch.complete_userspace_io = complete_emulated_mmio;\n\treturn 0;\n}", "target": 0}
{"code": "static int io_wqe_worker(void *data)\n{\n\tstruct io_worker *worker = data;\n\tstruct io_wqe_acct *acct = io_wqe_get_acct(worker);\n\tstruct io_wqe *wqe = worker->wqe;\n\tstruct io_wq *wq = wqe->wq;\n\tbool last_timeout = false;\n\tchar buf[TASK_COMM_LEN];\n\tworker->flags |= (IO_WORKER_F_UP | IO_WORKER_F_RUNNING);\n\tsnprintf(buf, sizeof(buf), \"iou-wrk-%d\", wq->task->pid);\n\tset_task_comm(current, buf);\n\twhile (!test_bit(IO_WQ_BIT_EXIT, &wq->state)) {\n\t\tlong ret;\n\t\tset_current_state(TASK_INTERRUPTIBLE);\nloop:\n\t\traw_spin_lock(&wqe->lock);\n\t\tif (io_acct_run_queue(acct)) {\n\t\t\tio_worker_handle_work(worker);\n\t\t\tgoto loop;\n\t\t}\n\t\tif (last_timeout && acct->nr_workers > 1) {\n\t\t\traw_spin_unlock(&wqe->lock);\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t\tbreak;\n\t\t}\n\t\tlast_timeout = false;\n\t\t__io_worker_idle(wqe, worker);\n\t\traw_spin_unlock(&wqe->lock);\n\t\tif (io_flush_signals())\n\t\t\tcontinue;\n\t\tret = schedule_timeout(WORKER_IDLE_TIMEOUT);\n\t\tif (signal_pending(current)) {\n\t\t\tstruct ksignal ksig;\n\t\t\tif (!get_signal(&ksig))\n\t\t\t\tcontinue;\n\t\t\tif (fatal_signal_pending(current))\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tlast_timeout = !ret;\n\t}\n\tif (test_bit(IO_WQ_BIT_EXIT, &wq->state)) {\n\t\traw_spin_lock(&wqe->lock);\n\t\tio_worker_handle_work(worker);\n\t}\n\tio_worker_exit(worker);\n\treturn 0;\n}", "target": 0}
{"code": "gif_main_loop (GifContext *context)\n{\n\tgint retval = 0;\n\tdo {\n\t\tswitch (context->state) {\n\t\tcase GIF_START:\n                        LOG(\"start\\n\");\n\t\t\tretval = gif_init (context);\n\t\t\tbreak;\n\t\tcase GIF_GET_COLORMAP:\n                        LOG(\"get_colormap\\n\");\n\t\t\tretval = gif_get_colormap (context);\n\t\t\tif (retval == 0)\n\t\t\t\tcontext->state = GIF_GET_NEXT_STEP;\n\t\t\tbreak;\n\t\tcase GIF_GET_NEXT_STEP:\n                        LOG(\"next_step\\n\");\n\t\t\tretval = gif_get_next_step (context);\n\t\t\tbreak;\n\t\tcase GIF_GET_FRAME_INFO:\n                        LOG(\"frame_info\\n\");\n\t\t\tretval = gif_get_frame_info (context);\n\t\t\tbreak;\n\t\tcase GIF_GET_EXTENSION:\n                        LOG(\"get_extension\\n\");\n\t\t\tretval = gif_get_extension (context);\n\t\t\tif (retval == 0)\n\t\t\t\tcontext->state = GIF_GET_NEXT_STEP;\n\t\t\tbreak;\n\t\tcase GIF_GET_COLORMAP2:\n                        LOG(\"get_colormap2\\n\");\n\t\t\tretval = gif_get_colormap2 (context);\n\t\t\tif (retval == 0)\n\t\t\t\tgif_set_prepare_lzw (context);\n\t\t\tbreak;\n\t\tcase GIF_PREPARE_LZW:\n                        LOG(\"prepare_lzw\\n\");\n\t\t\tretval = gif_prepare_lzw (context);\n\t\t\tbreak;\n\t\tcase GIF_LZW_FILL_BUFFER:\n                        LOG(\"fill_buffer\\n\");\n\t\t\tretval = gif_lzw_fill_buffer (context);\n\t\t\tbreak;\n\t\tcase GIF_LZW_CLEAR_CODE:\n                        LOG(\"clear_code\\n\");\n\t\t\tretval = gif_lzw_clear_code (context);\n\t\t\tbreak;\n\t\tcase GIF_GET_LZW:\n                        LOG(\"get_lzw\\n\");\n\t\t\tretval = gif_get_lzw (context);\n\t\t\tbreak;\n\t\tcase GIF_DONE:\n                        LOG(\"done\\n\");\n\t\tdefault:\n\t\t\tretval = 0;\n\t\t\tgoto done;\n\t\t};\n\t} while ((retval == 0) || (retval == -3));\n done:\n\treturn retval;\n}", "target": 0}
{"code": "mysql_field_seek(MYSQL_RES *result, MYSQL_FIELD_OFFSET field_offset)\n{\n  MYSQL_FIELD_OFFSET return_value=result->current_field;\n  result->current_field=field_offset;\n  return return_value;\n}", "target": 0}
{"code": "QPDF::resolve(int objid, int generation)\n{\n    QPDFObjGen og(objid, generation);\n    if (! this->obj_cache.count(og))\n    {\n\tif (! this->xref_table.count(og))\n\t{\n\t    return new QPDF_Null;\n\t}\n\tQPDFXRefEntry const& entry = this->xref_table[og];\n\tswitch (entry.getType())\n\t{\n\t  case 1:\n\t    {\n\t\tqpdf_offset_t offset = entry.getOffset();\n\t\tint aobjid;\n\t\tint ageneration;\n\t\tQPDFObjectHandle oh =\n\t\t    readObjectAtOffset(true, offset, \"\", objid, generation,\n\t\t\t\t       aobjid, ageneration);\n\t    }\n\t    break;\n\t  case 2:\n\t    resolveObjectsInStream(entry.getObjStreamNumber());\n\t    break;\n\t  default:\n\t    throw QPDFExc(qpdf_e_damaged_pdf, this->file->getName(), \"\", 0,\n\t\t\t  \"object \" +\n\t\t\t  QUtil::int_to_string(objid) + \"/\" +\n\t\t\t  QUtil::int_to_string(generation) +\n\t\t\t  \" has unexpected xref entry type\");\n\t}\n    }\n    return this->obj_cache[og].object;\n}", "target": 1}
{"code": "void kvm_mmu_invpcid_gva(struct kvm_vcpu *vcpu, gva_t gva, unsigned long pcid)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.mmu;\n\tbool tlb_flush = false;\n\tuint i;\n\tif (pcid == kvm_get_active_pcid(vcpu)) {\n\t\tmmu->invlpg(vcpu, gva, mmu->root.hpa);\n\t\ttlb_flush = true;\n\t}\n\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++) {\n\t\tif (VALID_PAGE(mmu->prev_roots[i].hpa) &&\n\t\t    pcid == kvm_get_pcid(vcpu, mmu->prev_roots[i].pgd)) {\n\t\t\tmmu->invlpg(vcpu, gva, mmu->prev_roots[i].hpa);\n\t\t\ttlb_flush = true;\n\t\t}\n\t}\n\tif (tlb_flush)\n\t\tstatic_call(kvm_x86_flush_tlb_gva)(vcpu, gva);\n\t++vcpu->stat.invlpg;\n}", "target": 1}
{"code": "static int kvaser_usb_leaf_simple_cmd_async(struct kvaser_usb_net_priv *priv,\n\t\t\t\t\t    u8 cmd_id)\n{\n\tstruct kvaser_cmd *cmd;\n\tint err;\n\tcmd = kmalloc(sizeof(*cmd), GFP_ATOMIC);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\tcmd->len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_simple);\n\tcmd->id = cmd_id;\n\tcmd->u.simple.channel = priv->channel;\n\terr = kvaser_usb_send_cmd_async(priv, cmd, cmd->len);\n\tif (err)\n\t\tkfree(cmd);\n\treturn err;\n}", "target": 1}
{"code": "split_path (const char *path, char **dir, char **file)\n{\n  char *last_slash = strrchr (path, '/');\n  if (!last_slash)\n    {\n      *dir = xstrdup (\"\");\n      *file = xstrdup (path);\n    }\n  else\n    {\n      *dir = strdupdelim (path, last_slash);\n      *file = xstrdup (last_slash + 1);\n    }\n  url_unescape (*dir);\n  url_unescape (*file);\n}", "target": 0}
{"code": "static int check_stack_write_var_off(struct bpf_verifier_env *env,\n\t\t\t\t     struct bpf_func_state *state,\n\t\t\t\t     int ptr_regno, int off, int size,\n\t\t\t\t     int value_regno, int insn_idx)\n{\n\tstruct bpf_func_state *cur; \n\tint min_off, max_off;\n\tint i, err;\n\tstruct bpf_reg_state *ptr_reg = NULL, *value_reg = NULL;\n\tbool writing_zero = false;\n\tbool zero_used = false;\n\tcur = env->cur_state->frame[env->cur_state->curframe];\n\tptr_reg = &cur->regs[ptr_regno];\n\tmin_off = ptr_reg->smin_value + off;\n\tmax_off = ptr_reg->smax_value + off + size;\n\tif (value_regno >= 0)\n\t\tvalue_reg = &cur->regs[value_regno];\n\tif (value_reg && register_is_null(value_reg))\n\t\twriting_zero = true;\n\terr = grow_stack_state(state, round_up(-min_off, BPF_REG_SIZE));\n\tif (err)\n\t\treturn err;\n\tfor (i = min_off; i < max_off; i++) {\n\t\tu8 new_type, *stype;\n\t\tint slot, spi;\n\t\tslot = -i - 1;\n\t\tspi = slot / BPF_REG_SIZE;\n\t\tstype = &state->stack[spi].slot_type[slot % BPF_REG_SIZE];\n\t\tif (!env->allow_ptr_leaks\n\t\t\t\t&& *stype != NOT_INIT\n\t\t\t\t&& *stype != SCALAR_VALUE) {\n\t\t\tverbose(env, \"spilled ptr in range of var-offset stack write; insn %d, ptr off: %d\",\n\t\t\t\tinsn_idx, i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tstate->stack[spi].spilled_ptr.type = NOT_INIT;\n\t\tnew_type = STACK_MISC;\n\t\tif (writing_zero && *stype == STACK_ZERO) {\n\t\t\tnew_type = STACK_ZERO;\n\t\t\tzero_used = true;\n\t\t}\n\t\tif (*stype == STACK_INVALID && !env->allow_uninit_stack) {\n\t\t\tverbose(env, \"uninit stack in range of var-offset write prohibited for !root; insn %d, off: %d\",\n\t\t\t\t\tinsn_idx, i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*stype = new_type;\n\t}\n\tif (zero_used) {\n\t\terr = mark_chain_precision(env, value_regno);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "Function *ESTreeIRGen::genGeneratorFunction(\n    Identifier originalName,\n    Variable *lazyClosureAlias,\n    ESTree::FunctionLikeNode *functionNode) {\n  assert(functionNode && \"Function AST cannot be null\");\n  auto *outerFn = Builder.createGeneratorFunction(\n      originalName,\n      Function::DefinitionKind::ES5Function,\n      ESTree::isStrict(functionNode->strictness),\n       nullptr);\n  auto *innerFn = genES5Function(\n      genAnonymousLabelName(originalName.isValid() ? originalName.str() : \"\"),\n      lazyClosureAlias,\n      functionNode,\n      true);\n  {\n    FunctionContext outerFnContext{this, outerFn, functionNode->getSemInfo()};\n    emitFunctionPrologue(\n        functionNode,\n        Builder.createBasicBlock(outerFn),\n        InitES5CaptureState::Yes,\n        DoEmitParameters::No);\n    auto *gen = Builder.createCreateGeneratorInst(innerFn);\n    if (!hasSimpleParams(functionNode)) {\n      Value *next = Builder.createLoadPropertyInst(gen, \"next\");\n      Builder.createCallInst(next, gen, {});\n    }\n    emitFunctionEpilogue(gen);\n  }\n  return outerFn;\n}", "target": 1}
{"code": "static inline struct page *__skb_alloc_pages(gfp_t gfp_mask,\n\t\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t\t      unsigned int order)\n{\n\tstruct page *page;\n\tgfp_mask |= __GFP_COLD;\n\tif (!(gfp_mask & __GFP_NOMEMALLOC))\n\t\tgfp_mask |= __GFP_MEMALLOC;\n\tpage = alloc_pages_node(NUMA_NO_NODE, gfp_mask, order);\n\tif (skb && page && page->pfmemalloc)\n\t\tskb->pfmemalloc = true;\n\treturn page;\n}", "target": 0}
{"code": "int sctp_auth_ep_set_hmacs(struct sctp_endpoint *ep,\n\t\t\t   struct sctp_hmacalgo *hmacs)\n{\n\tint has_sha1 = 0;\n\t__u16 id;\n\tint i;\n\tfor (i = 0; i < hmacs->shmac_num_idents; i++) {\n\t\tid = hmacs->shmac_idents[i];\n\t\tif (SCTP_AUTH_HMAC_ID_SHA1 == id)\n\t\t\thas_sha1 = 1;\n\t\tif (!sctp_hmac_list[id].hmac_name)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\tif (!has_sha1)\n\t\treturn -EINVAL;\n\tmemcpy(ep->auth_hmacs_list->hmac_ids, &hmacs->shmac_idents[0],\n\t\thmacs->shmac_num_idents * sizeof(__u16));\n\tep->auth_hmacs_list->param_hdr.length = htons(sizeof(sctp_paramhdr_t) +\n\t\t\t\thmacs->shmac_num_idents * sizeof(__u16));\n\treturn 0;\n}", "target": 1}
{"code": "int NETSCAPE_SPKI_print(BIO *out, NETSCAPE_SPKI *spki)\n{\n    EVP_PKEY *pkey;\n    ASN1_IA5STRING *chal;\n    ASN1_OBJECT *spkioid;\n    int i, n;\n    char *s;\n    BIO_printf(out, \"Netscape SPKI:\\n\");\n    X509_PUBKEY_get0_param(&spkioid, NULL, NULL, NULL, spki->spkac->pubkey);\n    i = OBJ_obj2nid(spkioid);\n    BIO_printf(out, \"  Public Key Algorithm: %s\\n\",\n               (i == NID_undef) ? \"UNKNOWN\" : OBJ_nid2ln(i));\n    pkey = X509_PUBKEY_get(spki->spkac->pubkey);\n    if (!pkey)\n        BIO_printf(out, \"  Unable to load public key\\n\");\n    else {\n        EVP_PKEY_print_public(out, pkey, 4, NULL);\n        EVP_PKEY_free(pkey);\n    }\n    chal = spki->spkac->challenge;\n    if (chal->length)\n        BIO_printf(out, \"  Challenge String: %s\\n\", chal->data);\n    i = OBJ_obj2nid(spki->sig_algor.algorithm);\n    BIO_printf(out, \"  Signature Algorithm: %s\",\n               (i == NID_undef) ? \"UNKNOWN\" : OBJ_nid2ln(i));\n    n = spki->signature->length;\n    s = (char *)spki->signature->data;\n    for (i = 0; i < n; i++) {\n        if ((i % 18) == 0)\n            BIO_write(out, \"\\n      \", 7);\n        BIO_printf(out, \"%02x%s\", (unsigned char)s[i],\n                   ((i + 1) == n) ? \"\" : \":\");\n    }\n    BIO_write(out, \"\\n\", 1);\n    return 1;\n}", "target": 1}
{"code": "static bool fib6_rule_suppress(struct fib_rule *rule, struct fib_lookup_arg *arg)\n{\n\tstruct fib6_result *res = arg->result;\n\tstruct rt6_info *rt = res->rt6;\n\tstruct net_device *dev = NULL;\n\tif (!rt)\n\t\treturn false;\n\tif (rt->rt6i_idev)\n\t\tdev = rt->rt6i_idev->dev;\n\tif (rt->rt6i_dst.plen <= rule->suppress_prefixlen)\n\t\tgoto suppress_route;\n\tif (rule->suppress_ifgroup != -1 && dev && dev->group == rule->suppress_ifgroup)\n\t\tgoto suppress_route;\n\treturn false;\nsuppress_route:\n\tip6_rt_put(rt);\n\treturn true;\n}", "target": 1}
{"code": "static struct pid *good_sigevent(sigevent_t * event)\n{\n\tstruct task_struct *rtn = current->group_leader;\n\tif ((event->sigev_notify & SIGEV_THREAD_ID ) &&\n\t\t(!(rtn = find_task_by_vpid(event->sigev_notify_thread_id)) ||\n\t\t !same_thread_group(rtn, current) ||\n\t\t (event->sigev_notify & ~SIGEV_THREAD_ID) != SIGEV_SIGNAL))\n\t\treturn NULL;\n\tif (((event->sigev_notify & ~SIGEV_THREAD_ID) != SIGEV_NONE) &&\n\t    ((event->sigev_signo <= 0) || (event->sigev_signo > SIGRTMAX)))\n\t\treturn NULL;\n\treturn task_pid(rtn);\n}", "target": 1}
{"code": "static int keyring_detect_cycle_iterator(const void *object,\n\t\t\t\t\t void *iterator_data)\n{\n\tstruct keyring_search_context *ctx = iterator_data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\tkenter(\"{%d}\", key->serial);\n\tBUG_ON(key != ctx->match_data);\n\tctx->result = ERR_PTR(-EDEADLK);\n\treturn 1;\n}", "target": 1}
{"code": "static void perf_event_init_cpu(int cpu)\n{\n\tstruct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);\n\tmutex_lock(&swhash->hlist_mutex);\n\tswhash->online = true;\n\tif (swhash->hlist_refcount > 0) {\n\t\tstruct swevent_hlist *hlist;\n\t\thlist = kzalloc_node(sizeof(*hlist), GFP_KERNEL, cpu_to_node(cpu));\n\t\tWARN_ON(!hlist);\n\t\trcu_assign_pointer(swhash->swevent_hlist, hlist);\n\t}\n\tmutex_unlock(&swhash->hlist_mutex);\n}", "target": 1}
{"code": "static void mark_commit(struct commit *c, void *data)\n{\n\tmark_object(&c->object, NULL, NULL, data);\n}", "target": 1}
{"code": "static inline void find_entity_for_char_basic(\n\tunsigned int k,\n\tconst entity_stage3_row *table,\n\tconst unsigned char **entity,\n\tsize_t *entity_len)\n{\n\tif (k >= 64U) {\n\t\t*entity     = NULL;\n\t\t*entity_len = 0;\n\t\treturn;\n\t}\n\t*entity     = table[k].data.ent.entity;\n\t*entity_len = table[k].data.ent.entity_len;\n}", "target": 0}
{"code": "HIDDEN void *zstd_init()\n{\n    ZSTD_CCtx *cctx = ZSTD_createCCtx();\n    if (cctx) {\n        ZSTD_CCtx_setParameter(cctx, ZSTD_c_compressionLevel,\n                               ZSTD_CLEVEL_DEFAULT);\n        ZSTD_CCtx_setParameter(cctx, ZSTD_c_checksumFlag, 1);\n    }\n    return cctx;\n}", "target": 0}
{"code": "GIT_INLINE(bool) verify_dotgit_ntfs(git_repository *repo, const char *path, size_t len)\n{\n\tgit_buf *reserved = git_repository__reserved_names_win32;\n\tsize_t reserved_len = git_repository__reserved_names_win32_len;\n\tsize_t start = 0, i;\n\tif (repo)\n\t\tgit_repository__reserved_names(&reserved, &reserved_len, repo, true);\n\tfor (i = 0; i < reserved_len; i++) {\n\t\tgit_buf *r = &reserved[i];\n\t\tif (len >= r->size &&\n\t\t\tstrncasecmp(path, r->ptr, r->size) == 0) {\n\t\t\tstart = r->size;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!start)\n\t\treturn true;\n\tif (path[start] == '\\\\')\n\t\treturn false;\n\tfor (i = start; i < len; i++) {\n\t\tif (path[i] != ' ' && path[i] != '.')\n\t\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "static int synic_set_irq(struct kvm_vcpu_hv_synic *synic, u32 sint)\n{\n\tstruct kvm_vcpu *vcpu = hv_synic_to_vcpu(synic);\n\tstruct kvm_lapic_irq irq;\n\tint ret, vector;\n\tif (sint >= ARRAY_SIZE(synic->sint))\n\t\treturn -EINVAL;\n\tvector = synic_get_sint_vector(synic_read_sint(synic, sint));\n\tif (vector < 0)\n\t\treturn -ENOENT;\n\tmemset(&irq, 0, sizeof(irq));\n\tirq.shorthand = APIC_DEST_SELF;\n\tirq.dest_mode = APIC_DEST_PHYSICAL;\n\tirq.delivery_mode = APIC_DM_FIXED;\n\tirq.vector = vector;\n\tirq.level = 1;\n\tret = kvm_irq_delivery_to_apic(vcpu->kvm, vcpu->arch.apic, &irq, NULL);\n\ttrace_kvm_hv_synic_set_irq(vcpu->vcpu_id, sint, irq.vector, ret);\n\treturn ret;\n}", "target": 1}
{"code": "TEST_F(HeaderToMetadataTest, BasicRequestDoubleHeadersTest) {\n  initializeFilter(request_config_yaml);\n  Http::TestRequestHeaderMapImpl incoming_headers{{\"X-VERSION\", \"foo\"}, {\"X-VERSION\", \"bar\"}};\n  std::map<std::string, std::string> expected = {{\"version\", \"foo,bar\"}};\n  EXPECT_CALL(decoder_callbacks_, streamInfo()).WillRepeatedly(ReturnRef(req_info_));\n  EXPECT_CALL(req_info_, setDynamicMetadata(\"envoy.lb\", MapEq(expected)));\n  EXPECT_EQ(Http::FilterHeadersStatus::Continue, filter_->decodeHeaders(incoming_headers, false));\n  Http::MetadataMap metadata_map{{\"metadata\", \"metadata\"}};\n  EXPECT_EQ(Http::FilterMetadataStatus::Continue, filter_->decodeMetadata(metadata_map));\n  Buffer::OwnedImpl data(\"data\");\n  EXPECT_EQ(Http::FilterDataStatus::Continue, filter_->decodeData(data, false));\n  Http::TestRequestTrailerMapImpl incoming_trailers;\n  EXPECT_EQ(Http::FilterTrailersStatus::Continue, filter_->decodeTrailers(incoming_trailers));\n  filter_->onDestroy();\n}", "target": 0}
{"code": "void rdma_unlock_handler(struct rdma_cm_id *id)\n{\n\tstruct rdma_id_private *id_priv =\n\t\tcontainer_of(id, struct rdma_id_private, id);\n\tmutex_unlock(&id_priv->handler_mutex);\n}", "target": 0}
{"code": "void HistoryController::UpdateForCommit(RenderFrameImpl* frame,\n                                        const WebHistoryItem& item,\n                                        WebHistoryCommitType commit_type,\n                                        bool navigation_within_page) {\n  switch (commit_type) {\n     case blink::WebBackForwardCommit:\n       if (!provisional_entry_)\n         return;\n      current_entry_.reset(provisional_entry_.release());\n       if (HistoryEntry::HistoryNode* node =\n               current_entry_->GetHistoryNodeForFrame(frame)) {\n         node->set_item(item);\n      }\n      break;\n    case blink::WebStandardCommit:\n      CreateNewBackForwardItem(frame, item, navigation_within_page);\n      break;\n    case blink::WebInitialCommitInChildFrame:\n      UpdateForInitialLoadInChildFrame(frame, item);\n      break;\n    case blink::WebHistoryInertCommit:\n      if (current_entry_) {\n        if (HistoryEntry::HistoryNode* node =\n                current_entry_->GetHistoryNodeForFrame(frame)) {\n          if (!navigation_within_page)\n            node->RemoveChildren();\n          node->set_item(item);\n        }\n      }\n      break;\n    default:\n      NOTREACHED() << \"Invalid commit type: \" << commit_type;\n  }\n}", "target": 1}
{"code": "void sco_recv_scodata(struct hci_conn *hcon, struct sk_buff *skb)\n{\n\tstruct sco_conn *conn = hcon->sco_data;\n\tif (!conn)\n\t\tgoto drop;\n\tBT_DBG(\"conn %p len %u\", conn, skb->len);\n\tif (skb->len) {\n\t\tsco_recv_frame(conn, skb);\n\t\treturn;\n\t}\ndrop:\n\tkfree_skb(skb);\n}", "target": 0}
{"code": "static void bfq_idle_slice_timer_body(struct bfq_queue *bfqq)\n{\n\tstruct bfq_data *bfqd = bfqq->bfqd;\n\tenum bfqq_expiration reason;\n\tunsigned long flags;\n\tspin_lock_irqsave(&bfqd->lock, flags);\n\tbfq_clear_bfqq_wait_request(bfqq);\n\tif (bfqq != bfqd->in_service_queue) {\n\t\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\t\treturn;\n\t}\n\tif (bfq_bfqq_budget_timeout(bfqq))\n\t\treason = BFQQE_BUDGET_TIMEOUT;\n\telse if (bfqq->queued[0] == 0 && bfqq->queued[1] == 0)\n\t\treason = BFQQE_TOO_IDLE;\n\telse\n\t\tgoto schedule_dispatch;\n\tbfq_bfqq_expire(bfqd, bfqq, true, reason);\nschedule_dispatch:\n\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\tbfq_schedule_dispatch(bfqd);", "target": 1}
{"code": "set_cs_start(char *line)\n{\n  char *p, *q, *r;\n  if ((p = strstr(line, \"string currentfile\"))) {\n    if (!strstr(line, \"readstring\"))\n      return;\n    *p = '\\0';\t\t\t\t\t  \n    q = strrchr(line, '/');\n    if (q) {\n      r = cs_start;\n      ++q;\n      while (!isspace(*q) && *q != '{')\n\t*r++ = *q++;\n      *r = '\\0';\n    }\n    *p = 's';\t\t\t\t\t  \n  }\n}", "target": 1}
{"code": "static void *create_core_server_config(apr_pool_t *a, server_rec *s)\n{\n    core_server_config *conf;\n    int is_virtual = s->is_virtual;\n    conf = (core_server_config *)apr_pcalloc(a, sizeof(core_server_config));\n    if (!is_virtual) {\n        conf->ap_document_root = DOCUMENT_LOCATION;\n        conf->access_name = DEFAULT_ACCESS_FNAME;\n        conf->accf_map = apr_table_make(a, 5);\n#if APR_HAS_SO_ACCEPTFILTER\n        apr_table_setn(conf->accf_map, \"http\", ACCEPT_FILTER_NAME);\n        apr_table_setn(conf->accf_map, \"https\", \"dataready\");\n#elif defined(WIN32)\n        apr_table_setn(conf->accf_map, \"http\", \"connect\");\n        apr_table_setn(conf->accf_map, \"https\", \"connect\");\n#else\n        apr_table_setn(conf->accf_map, \"http\", \"data\");\n        apr_table_setn(conf->accf_map, \"https\", \"data\");\n#endif\n    }\n    conf->sec_dir = apr_array_make(a, 40, sizeof(ap_conf_vector_t *));\n    conf->sec_url = apr_array_make(a, 40, sizeof(ap_conf_vector_t *));\n    conf->trace_enable = AP_TRACE_UNSET;\n    conf->protocols = apr_array_make(a, 5, sizeof(const char *));\n    conf->protocols_honor_order = -1;\n    conf->async_filter = 0;\n    return (void *)conf;\n}", "target": 0}
{"code": "sysUpTime_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  snmp_api_set_time_ticks(varbind, oid, clock_seconds() * 100);\n}", "target": 1}
{"code": "vhost_user_set_features(struct virtio_net *dev, uint64_t features)\n{\n\tuint64_t vhost_features = 0;\n\trte_vhost_driver_get_features(dev->ifname, &vhost_features);\n\tif (features & ~vhost_features) {\n\t\tRTE_LOG(ERR, VHOST_CONFIG,\n\t\t\t\"(%d) received invalid negotiated features.\\n\",\n\t\t\tdev->vid);\n\t\treturn -1;\n\t}\n\tif (dev->flags & VIRTIO_DEV_RUNNING) {\n\t\tif (dev->features == features)\n\t\t\treturn 0;\n\t\tif ((dev->features ^ features) & ~(1ULL << VHOST_F_LOG_ALL)) {\n\t\t\tRTE_LOG(ERR, VHOST_CONFIG,\n\t\t\t\t\"(%d) features changed while device is running.\\n\",\n\t\t\t\tdev->vid);\n\t\t\treturn -1;\n\t\t}\n\t\tif (dev->notify_ops->features_changed)\n\t\t\tdev->notify_ops->features_changed(dev->vid, features);\n\t}\n\tdev->features = features;\n\tif (dev->features &\n\t\t((1 << VIRTIO_NET_F_MRG_RXBUF) | (1ULL << VIRTIO_F_VERSION_1))) {\n\t\tdev->vhost_hlen = sizeof(struct virtio_net_hdr_mrg_rxbuf);\n\t} else {\n\t\tdev->vhost_hlen = sizeof(struct virtio_net_hdr);\n\t}\n\tLOG_DEBUG(VHOST_CONFIG,\n\t\t\"(%d) mergeable RX buffers %s, virtio 1 %s\\n\",\n\t\tdev->vid,\n\t\t(dev->features & (1 << VIRTIO_NET_F_MRG_RXBUF)) ? \"on\" : \"off\",\n\t\t(dev->features & (1ULL << VIRTIO_F_VERSION_1)) ? \"on\" : \"off\");\n\tif ((dev->flags & VIRTIO_DEV_BUILTIN_VIRTIO_NET) &&\n\t    !(dev->features & (1ULL << VIRTIO_NET_F_MQ))) {\n\t\twhile (dev->nr_vring > 2) {\n\t\t\tstruct vhost_virtqueue *vq;\n\t\t\tvq = dev->virtqueue[--dev->nr_vring];\n\t\t\tif (!vq)\n\t\t\t\tcontinue;\n\t\t\tdev->virtqueue[dev->nr_vring] = NULL;\n\t\t\tcleanup_vq(vq, 1);\n\t\t\tfree_vq(vq);\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static bool vtable_is_value_in_text_section(RVTableContext *context, ut64 curAddress, ut64 *value) {\n\tut64 curAddressValue;\n\tif (!context->read_addr (context->anal, curAddress, &curAddressValue)) {\n\t\treturn false;\n\t}\n\tbool ret = vtable_addr_in_text_section (context, curAddressValue);\n\tif (value) {\n\t\t*value = curAddressValue;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "fixExec2Error(int action,\n             u_char * var_val,\n             u_char var_val_type,\n             size_t var_val_len,\n             u_char * statP, oid * name, size_t name_len)\n{\n    netsnmp_old_extend *exten = NULL;\n    unsigned int idx;\n    idx = name[name_len-1] -1;\n    exten = &compatability_entries[ idx ];\n#ifndef NETSNMP_NO_WRITE_SUPPORT\n    switch (action) {\n    case MODE_SET_RESERVE1:\n        if (var_val_type != ASN_INTEGER) {\n            snmp_log(LOG_ERR, \"Wrong type != int\\n\");\n            return SNMP_ERR_WRONGTYPE;\n        }\n        idx = *((long *) var_val);\n        if (idx != 1) {\n            snmp_log(LOG_ERR, \"Wrong value != 1\\n\");\n            return SNMP_ERR_WRONGVALUE;\n        }\n        if (!exten || !exten->efix_entry) {\n            snmp_log(LOG_ERR, \"No command to run\\n\");\n            return SNMP_ERR_GENERR;\n        }\n        return SNMP_ERR_NOERROR;\n    case MODE_SET_COMMIT:\n        netsnmp_cache_check_and_reload( exten->efix_entry->cache );\n    }\n#endif \n    return SNMP_ERR_NOERROR;\n}", "target": 1}
{"code": "int snd_dma_alloc_pages_fallback(int type, struct device *device, size_t size,\n\t\t\t\t struct snd_dma_buffer *dmab)\n{\n\tint err;\n\tsnd_assert(size > 0, return -ENXIO);\n\tsnd_assert(dmab != NULL, return -ENXIO);\n\twhile ((err = snd_dma_alloc_pages(type, device, size, dmab)) < 0) {\n\t\tif (err != -ENOMEM)\n\t\t\treturn err;\n\t\tsize >>= 1;\n\t\tif (size <= PAGE_SIZE)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (! dmab->area)\n\t\treturn -ENOMEM;\n\treturn 0;\n}", "target": 0}
{"code": "ldap_pvt_tls_get_peer_dn( void *s, struct berval *dn,\n\tLDAPDN_rewrite_dummy *func, unsigned flags )\n{\n\ttls_session *session = s;\n\tstruct berval bvdn;\n\tint rc;\n\trc = tls_imp->ti_session_peer_dn( session, &bvdn );\n\tif ( rc ) return rc;\n\trc = ldap_X509dn2bv( &bvdn, dn, \n\t\t\t    (LDAPDN_rewrite_func *)func, flags);\n\treturn rc;\n}", "target": 0}
{"code": "static const char *cmd_hash_engine(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n    if (strcasecmp(p1, \"on\") == 0)  {\n        dcfg->hash_is_enabled = HASH_ENABLED;\n        dcfg->hash_enforcement = HASH_ENABLED;\n    }\n    else if (strcasecmp(p1, \"off\") == 0)    {\n        dcfg->hash_is_enabled = HASH_DISABLED;\n        dcfg->hash_enforcement = HASH_DISABLED;\n    }\n    else return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecRuleEngine: %s\", p1);\n    return NULL;\n}", "target": 1}
{"code": "static inline struct sk_buff *dev_dequeue_skb(struct net_device *dev,\n\t\t\t\t\t      struct Qdisc *q)\n{\n\tstruct sk_buff *skb;\n\tif ((skb = dev->gso_skb))\n\t\tdev->gso_skb = NULL;\n\telse\n\t\tskb = q->dequeue(q);\n\treturn skb;\n}", "target": 0}
{"code": "static int nl80211_parse_key_new(struct nlattr *key, struct key_parse *k)\n{\n\tstruct nlattr *tb[NL80211_KEY_MAX + 1];\n\tint err = nla_parse_nested(tb, NL80211_KEY_MAX, key,\n\t\t\t\t   nl80211_key_policy);\n\tif (err)\n\t\treturn err;\n\tk->def = !!tb[NL80211_KEY_DEFAULT];\n\tk->defmgmt = !!tb[NL80211_KEY_DEFAULT_MGMT];\n\tif (k->def) {\n\t\tk->def_uni = true;\n\t\tk->def_multi = true;\n\t}\n\tif (k->defmgmt)\n\t\tk->def_multi = true;\n\tif (tb[NL80211_KEY_IDX])\n\t\tk->idx = nla_get_u8(tb[NL80211_KEY_IDX]);\n\tif (tb[NL80211_KEY_DATA]) {\n\t\tk->p.key = nla_data(tb[NL80211_KEY_DATA]);\n\t\tk->p.key_len = nla_len(tb[NL80211_KEY_DATA]);\n\t}\n\tif (tb[NL80211_KEY_SEQ]) {\n\t\tk->p.seq = nla_data(tb[NL80211_KEY_SEQ]);\n\t\tk->p.seq_len = nla_len(tb[NL80211_KEY_SEQ]);\n\t}\n\tif (tb[NL80211_KEY_CIPHER])\n\t\tk->p.cipher = nla_get_u32(tb[NL80211_KEY_CIPHER]);\n\tif (tb[NL80211_KEY_TYPE]) {\n\t\tk->type = nla_get_u32(tb[NL80211_KEY_TYPE]);\n\t\tif (k->type < 0 || k->type >= NUM_NL80211_KEYTYPES)\n\t\t\treturn -EINVAL;\n\t}\n\tif (tb[NL80211_KEY_DEFAULT_TYPES]) {\n\t\tstruct nlattr *kdt[NUM_NL80211_KEY_DEFAULT_TYPES];\n\t\terr = nla_parse_nested(kdt, NUM_NL80211_KEY_DEFAULT_TYPES - 1,\n\t\t\t\t       tb[NL80211_KEY_DEFAULT_TYPES],\n\t\t\t\t       nl80211_key_default_policy);\n\t\tif (err)\n\t\t\treturn err;\n\t\tk->def_uni = kdt[NL80211_KEY_DEFAULT_TYPE_UNICAST];\n\t\tk->def_multi = kdt[NL80211_KEY_DEFAULT_TYPE_MULTICAST];\n\t}\n\treturn 0;\n}", "target": 0}
{"code": " bool PasswordAutofillAgent::TryToShowTouchToFill(\n     const WebFormControlElement& control_element) {\n   const WebInputElement* element = ToWebInputElement(&control_element);\n  if (!element || (!base::Contains(web_input_to_password_info_, *element) &&\n                   !base::Contains(password_to_username_, *element))) {\n     return false;\n   }\n   if (was_touch_to_fill_ui_shown_)\n    return false;\n  was_touch_to_fill_ui_shown_ = true;\n  GetPasswordManagerDriver()->ShowTouchToFill();\n  return true;\n}", "target": 1}
{"code": "static int _assemble_line(FILE *f, char *buffer, int buf_len)\n{\n    char *p = buffer;\n    char *s, *os;\n    int used = 0;\n    D((\"called.\"));\n    for (;;) {\n\tif (used >= buf_len) {\n\t    D((\"_assemble_line: overflow\"));\n\t    return -1;\n\t}\n\tif (fgets(p, buf_len - used, f) == NULL) {\n\t    if (used) {\n\t\treturn -1;\n\t    } else {\n\t\treturn 0;\n\t    }\n\t}\n\ts = p + strspn(p, \" \\n\\t\");\n\tif (*s && (*s != '#')) {\n\t    os = s;\n\t    while (*s && *s != '#')\n\t\t ++s;\n\t    if (*s == '#') {\n\t\t *s = '\\0';\n\t\t used += strlen(os);\n\t\t break;                \n\t    }\n\t    s = os;\n\t    s += strlen(s);\n\t    while (s > os && ((*--s == ' ') || (*s == '\\t')\n\t\t\t      || (*s == '\\n')));\n\t    if (*s == '\\\\') {\n\t\t*s = '\\0';              \n\t\tused += strlen(os);\n\t\tp = s;                  \n\t    } else {\n\t\tused += strlen(os);\n\t\tbreak;                  \n\t    }\n\t} else {\n\t}\n    }\n    return used;\n}", "target": 0}
{"code": "hb_ot_layout_build_glyph_classes (hb_face_t      *face,\n\t\t\t\t  uint16_t        num_total_glyphs,\n\t\t\t\t  hb_codepoint_t *glyphs,\n\t\t\t\t  unsigned char  *klasses,\n\t\t\t\t  uint16_t        count)\n{\n  if (HB_OBJECT_IS_INERT (face))\n    return;\n  hb_ot_layout_t *layout = &face->ot_layout;\n  if (HB_UNLIKELY (!count || !glyphs || !klasses))\n    return;\n  if (layout->new_gdef.len == 0) {\n    layout->new_gdef.klasses = (unsigned char *) calloc (num_total_glyphs, sizeof (unsigned char));\n    layout->new_gdef.len = count;\n  }\n  for (unsigned int i = 0; i < count; i++)\n    _hb_ot_layout_set_glyph_class (face, glyphs[i], (hb_ot_layout_glyph_class_t) klasses[i]);\n}", "target": 1}
{"code": "static int intel_iommu_add_device(struct device *dev)\n{\n\tstruct intel_iommu *iommu;\n\tstruct iommu_group *group;\n\tu8 bus, devfn;\n\tiommu = device_to_iommu(dev, &bus, &devfn);\n\tif (!iommu)\n\t\treturn -ENODEV;\n\tiommu_device_link(&iommu->iommu, dev);\n\tgroup = iommu_group_get_for_dev(dev);\n\tif (IS_ERR(group))\n\t\treturn PTR_ERR(group);\n\tiommu_group_put(group);\n\treturn 0;\n}", "target": 0}
{"code": "spnego_gss_import_sec_context(\n\tOM_uint32\t\t*minor_status,\n\tconst gss_buffer_t\tinterprocess_token,\n\tgss_ctx_id_t\t\t*context_handle)\n{\n\tOM_uint32 ret;\n\tret = gss_import_sec_context(minor_status,\n\t\t\t\t    interprocess_token,\n\t\t\t\t    context_handle);\n\treturn (ret);\n}", "target": 1}
{"code": "struct page *vm_normal_page(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\tpte_t pte)\n{\n\tunsigned long pfn;\n\tif (HAVE_PTE_SPECIAL) {\n\t\tif (likely(!pte_special(pte))) {\n\t\t\tVM_BUG_ON(!pfn_valid(pte_pfn(pte)));\n\t\t\treturn pte_page(pte);\n\t\t}\n\t\tVM_BUG_ON(!(vma->vm_flags & (VM_PFNMAP | VM_MIXEDMAP)));\n\t\treturn NULL;\n\t}\n\tpfn = pte_pfn(pte);\n\tif (unlikely(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP))) {\n\t\tif (vma->vm_flags & VM_MIXEDMAP) {\n\t\t\tif (!pfn_valid(pfn))\n\t\t\t\treturn NULL;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tunsigned long off;\n\t\t\toff = (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\t\tif (pfn == vma->vm_pgoff + off)\n\t\t\t\treturn NULL;\n\t\t\tif (!is_cow_mapping(vma->vm_flags))\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\tVM_BUG_ON(!pfn_valid(pfn));\nout:\n\treturn pfn_to_page(pfn);\n}", "target": 0}
{"code": "skipString(const xmlChar *cur, int end) {\n    xmlChar limit;\n    if ((cur == NULL) || (end < 0)) return(-1);\n    if ((cur[end] == '\\'') || (cur[end] == '\"')) limit = cur[end];\n    else return(end);\n    end++;\n    while (cur[end] != 0) {\n        if (cur[end] == limit)\n\t    return(end + 1);\n\tend++;\n    }\n    return(-1);\n}", "target": 0}
{"code": "struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned int flags,\n\t\t\t\t    int *peeked, int *off, int *err)\n{\n\tstruct sk_buff *skb;\n\tlong timeo;\n\tint error = sock_error(sk);\n\tif (error)\n\t\tgoto no_packet;\n\ttimeo = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n\tdo {\n\t\tunsigned long cpu_flags;\n\t\tstruct sk_buff_head *queue = &sk->sk_receive_queue;\n\t\tspin_lock_irqsave(&queue->lock, cpu_flags);\n\t\tskb_queue_walk(queue, skb) {\n\t\t\t*peeked = skb->peeked;\n\t\t\tif (flags & MSG_PEEK) {\n\t\t\t\tif (*off >= skb->len) {\n\t\t\t\t\t*off -= skb->len;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tskb->peeked = 1;\n\t\t\t\tatomic_inc(&skb->users);\n\t\t\t} else\n\t\t\t\t__skb_unlink(skb, queue);\n\t\t\tspin_unlock_irqrestore(&queue->lock, cpu_flags);\n\t\t\treturn skb;\n\t\t}\n\t\tspin_unlock_irqrestore(&queue->lock, cpu_flags);\n\t\terror = -EAGAIN;\n\t\tif (!timeo)\n\t\t\tgoto no_packet;\n\t} while (!wait_for_packet(sk, err, &timeo));\n\treturn NULL;\nno_packet:\n\t*err = error;\n\treturn NULL;\n}", "target": 1}
{"code": "void FoFiTrueType::cvtCharStrings(char **encoding,\n\t\t\t\t  int *codeToGID,\n\t\t\t\t  FoFiOutputFunc outputFunc,\n\t\t\t\t  void *outputStream) {\n  char *name;\n  GooString *buf;\n  char buf2[16];\n  int i, k;\n  (*outputFunc)(outputStream, \"/CharStrings 256 dict dup begin\\n\", 32);\n  (*outputFunc)(outputStream, \"/.notdef 0 def\\n\", 15);\n  if (nCmaps == 0) {\n    goto err;\n  }\n  k = 0; \n  for (i = 255; i >= 0; --i) {\n    if (encoding) {\n      name = encoding[i];\n    } else {\n      sprintf(buf2, \"c%02x\", i);\n      name = buf2;\n    }\n    if (name && strcmp(name, \".notdef\")) {\n      k = codeToGID[i];\n      if (k > 0 && k < nGlyphs) {\n\t(*outputFunc)(outputStream, \"/\", 1);\n\t(*outputFunc)(outputStream, name, strlen(name));\n\tbuf = GooString::format(\" {0:d} def\\n\", k);\n\t(*outputFunc)(outputStream, buf->getCString(), buf->getLength());\n\tdelete buf;\n      }\n    }\n  }\n err:\n  (*outputFunc)(outputStream, \"end readonly def\\n\", 17);\n}", "target": 0}
{"code": "static int ne2000_buffer_full(NE2000State *s)\n {\n     int avail, index, boundary;\n     index = s->curpag << 8;\n     boundary = s->boundary << 8;\n     if (index < boundary)\n        return 1;\n    return 0;\n}", "target": 1}
{"code": "int PpapiPluginMain(const content::MainFunctionParams& parameters) {\n  const CommandLine& command_line = parameters.command_line;\n#if defined(OS_WIN)\n  g_target_services = parameters.sandbox_info->target_services;\n#endif\n  if (command_line.HasSwitch(switches::kPpapiStartupDialog)) {\n    if (g_target_services)\n      base::debug::WaitForDebugger(2*60, false);\n    else\n       ChildProcess::WaitForDebugger(\"Ppapi\");\n   }\n  if (command_line.HasSwitch(switches::kLang)) {\n    std::string locale = command_line.GetSwitchValueASCII(switches::kLang);\n    base::i18n::SetICUDefaultLocale(locale);\n  }\n   MessageLoop main_message_loop;\n   base::PlatformThread::SetName(\"CrPPAPIMain\");\n#if defined(OS_LINUX)\n  content::InitializeSandbox();\n#endif\n  ChildProcess ppapi_process;\n  ppapi_process.set_main_thread(\n      new PpapiThread(parameters.command_line, false));  \n  main_message_loop.Run();\n  return 0;\n}", "target": 0}
{"code": "int ext4_mark_iloc_dirty(handle_t *handle,\n\t\t\t struct inode *inode, struct ext4_iloc *iloc)\n{\n\tint err = 0;\n\tif (unlikely(ext4_forced_shutdown(EXT4_SB(inode->i_sb))))\n\t\treturn -EIO;\n\tif (IS_I_VERSION(inode))\n\t\tinode_inc_iversion(inode);\n\tget_bh(iloc->bh);\n\terr = ext4_do_update_inode(handle, inode, iloc);\n\tput_bh(iloc->bh);\n\treturn err;\n}", "target": 0}
{"code": "void mnt_set_mountpoint(struct mount *mnt,\n\t\t\tstruct mountpoint *mp,\n\t\t\tstruct mount *child_mnt)\n{\n\tmp->m_count++;\n\tmnt_add_count(mnt, 1);\t\n\tchild_mnt->mnt_mountpoint = dget(mp->m_dentry);\n\tchild_mnt->mnt_parent = mnt;\n\tchild_mnt->mnt_mp = mp;\n}", "target": 0}
{"code": "static void nvme_mmio_write(void *opaque, hwaddr addr, uint64_t data,\n                            unsigned size)\n{\n    NvmeCtrl *n = (NvmeCtrl *)opaque;\n    trace_pci_nvme_mmio_write(addr, data, size);\n    if (addr < sizeof(n->bar)) {\n        nvme_write_bar(n, addr, data, size);\n    } else {\n        nvme_process_db(n, addr, data);\n    }\n}", "target": 0}
{"code": "static int thread_cpu_clock_get(const clockid_t which_clock,\n\t\t\t\tstruct timespec *tp)\n{\n\treturn posix_cpu_clock_get(THREAD_CLOCK, tp);\n}", "target": 0}
{"code": "    bool IsOpened() {return hFile!=FILE_BAD_HANDLE;};", "target": 1}
{"code": "Bool gf_sys_get_battery_state(Bool *onBattery, u32 *onCharge, u32*level, u32 *batteryLifeTime, u32 *batteryFullLifeTime)\n{\n#if defined(_WIN32_WCE)\n\tSYSTEM_POWER_STATUS_EX sps;\n\tGetSystemPowerStatusEx(&sps, 0);\n\tif (onBattery) *onBattery = sps.ACLineStatus ? 0 : 1;\n\tif (onCharge) *onCharge = (sps.BatteryFlag & BATTERY_FLAG_CHARGING) ? 1 : 0;\n\tif (level) *level = sps.BatteryLifePercent;\n\tif (batteryLifeTime) *batteryLifeTime = sps.BatteryLifeTime;\n\tif (batteryFullLifeTime) *batteryFullLifeTime = sps.BatteryFullLifeTime;\n#elif defined(WIN32)\n\tSYSTEM_POWER_STATUS sps;\n\tGetSystemPowerStatus(&sps);\n\tif (onBattery) *onBattery = sps.ACLineStatus ? GF_FALSE : GF_TRUE;\n\tif (onCharge) *onCharge = (sps.BatteryFlag & BATTERY_FLAG_CHARGING) ? 1 : 0;\n\tif (level) *level = sps.BatteryLifePercent;\n\tif (batteryLifeTime) *batteryLifeTime = sps.BatteryLifeTime;\n\tif (batteryFullLifeTime) *batteryFullLifeTime = sps.BatteryFullLifeTime;\n#endif\n\treturn GF_TRUE;\n}", "target": 0}
{"code": "static int oidc_check_max_session_duration(request_rec *r, oidc_cfg *cfg,\n\t\toidc_session_t *session) {\n\tapr_time_t session_expires = oidc_session_get_session_expires(r, session);\n\tif (apr_time_now() > session_expires) {\n\t\toidc_warn(r, \"maximum session duration exceeded for user: %s\",\n\t\t\t\tsession->remote_user);\n\t\toidc_session_kill(r, session);\n\t\treturn oidc_handle_unauthenticated_user(r, cfg);\n\t}\n\toidc_log_session_expires(r, \"session max lifetime\", session_expires);\n\treturn OK;\n}", "target": 0}
{"code": "static void nfs_set_open_stateid(struct nfs4_state *state, nfs4_stateid *stateid, int open_flags)\n{\n\twrite_seqlock(&state->seqlock);\n\tnfs_set_open_stateid_locked(state, stateid, open_flags);\n\twrite_sequnlock(&state->seqlock);\n}", "target": 1}
{"code": "spnego_gss_delete_sec_context(\n\t\t\t    OM_uint32 *minor_status,\n\t\t\t    gss_ctx_id_t *context_handle,\n\t\t\t    gss_buffer_t output_token)\n{\n\tOM_uint32 ret = GSS_S_COMPLETE;\n\tspnego_gss_ctx_id_t *ctx =\n\t\t    (spnego_gss_ctx_id_t *)context_handle;\n\t*minor_status = 0;\n\tif (context_handle == NULL)\n\t\treturn (GSS_S_FAILURE);\n\tif (*ctx == NULL)\n\t\treturn (GSS_S_COMPLETE);\n\tif ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {\n\t\t(void) gss_delete_sec_context(minor_status,\n\t\t\t\t    &(*ctx)->ctx_handle,\n\t\t\t\t    output_token);\n\t\t(void) release_spnego_ctx(ctx);\n\t} else {\n\t\tret = gss_delete_sec_context(minor_status,\n\t\t\t\t    context_handle,\n\t\t\t\t    output_token);\n\t}\n\treturn (ret);\n}", "target": 1}
{"code": "static unsigned char mincore_page(struct address_space *mapping, pgoff_t pgoff)\n{\n\tunsigned char present = 0;\n\tstruct page *page;\n#ifdef CONFIG_SWAP\n\tif (shmem_mapping(mapping)) {\n\t\tpage = find_get_entry(mapping, pgoff);\n\t\tif (xa_is_value(page)) {\n\t\t\tswp_entry_t swp = radix_to_swp_entry(page);\n\t\t\tpage = find_get_page(swap_address_space(swp),\n\t\t\t\t\t     swp_offset(swp));\n\t\t}\n\t} else\n\t\tpage = find_get_page(mapping, pgoff);\n#else\n\tpage = find_get_page(mapping, pgoff);\n#endif\n\tif (page) {\n\t\tpresent = PageUptodate(page);\n\t\tput_page(page);\n\t}\n\treturn present;\n}", "target": 1}
{"code": "delete_buff_tail(buffheader_T *buf, int slen)\n{\n    int len = (int)STRLEN(buf->bh_curr->b_str);\n    if (len >= slen)\n    {\n\tbuf->bh_curr->b_str[len - slen] = NUL;\n\tbuf->bh_space += slen;\n    }\n}", "target": 1}
{"code": "void limit_output_verbosity(int level)\n{\n\tshort info_limits[COUNT_INFO], debug_limits[COUNT_DEBUG];\n\tint j;\n\tif (level > MAX_VERBOSITY)\n\t\treturn;\n\tmemset(info_limits, 0, sizeof info_limits);\n\tmemset(debug_limits, 0, sizeof debug_limits);\n\tfor (j = 1; j <= level; j++) {\n\t\tparse_output_words(info_words, info_limits, info_verbosity[j], LIMIT_PRIORITY);\n\t\tparse_output_words(debug_words, debug_limits, debug_verbosity[j], LIMIT_PRIORITY);\n\t}\n\tfor (j = 0; j < COUNT_INFO; j++) {\n\t\tif (info_levels[j] > info_limits[j])\n\t\t\tinfo_levels[j] = info_limits[j];\n\t}\n\tfor (j = 0; j < COUNT_DEBUG; j++) {\n\t\tif (debug_levels[j] > debug_limits[j])\n\t\t\tdebug_levels[j] = debug_limits[j];\n\t}\n}", "target": 0}
{"code": "static int nfs4_find_root_sec(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t\t      struct nfs_fsinfo *info)\n{\n\tint i, len, status = 0;\n\trpc_authflavor_t flav_array[NFS_MAX_SECFLAVORS];\n\tlen = rpcauth_list_flavors(flav_array, ARRAY_SIZE(flav_array));\n\tBUG_ON(len < 0);\n\tfor (i = 0; i < len; i++) {\n\t\tif (flav_array[i] == RPC_AUTH_UNIX)\n\t\t\tcontinue;\n\t\tstatus = nfs4_lookup_root_sec(server, fhandle, info, flav_array[i]);\n\t\tif (status == -NFS4ERR_WRONGSEC || status == -EACCES)\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\tif (status == -EACCES)\n\t\tstatus = -EPERM;\n\treturn status;\n}", "target": 0}
{"code": "char * gf_get_default_cache_directory() {\n\tchar szPath[GF_MAX_PATH];\n\tchar* root_tmp;\n\tsize_t len;\n#ifdef _WIN32_WCE\n\tstrcpy(szPath, \"\\\\windows\\\\temp\" );\n#elif defined(WIN32)\n\tGetTempPath(GF_MAX_PATH, szPath);\n#else\n\tstrcpy(szPath, \"/tmp\");\n#endif\n\troot_tmp = gf_strdup(szPath);\n\tlen = strlen(szPath);\n\tif (szPath[len-1] != GF_PATH_SEPARATOR) {\n\t\tszPath[len] = GF_PATH_SEPARATOR;\n\t\tszPath[len+1] = 0;\n\t}\n\tstrcat(szPath, \"gpac_cache\");\n\tif ( !gf_dir_exists(szPath) && gf_mkdir(szPath)!=GF_OK ) {\n\t\treturn root_tmp;\n\t}\n\tgf_free(root_tmp);\n\treturn gf_strdup(szPath);\n}", "target": 0}
{"code": "static int asymmetric_key_match(const struct key *key,\n\t\t\t\tconst struct key_match_data *match_data)\n{\n\tconst struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);\n\tconst char *description = match_data->raw_data;\n\tconst char *spec = description;\n\tconst char *id;\n\tptrdiff_t speclen;\n\tif (!subtype || !spec || !*spec)\n\t\treturn 0;\n\tif (key->description && strcmp(key->description, description) == 0)\n\t\treturn 1;\n\tid = strchr(spec, ':');\n\tif (!id)\n\t\treturn 0;\n\tspeclen = id - spec;\n\tid++;\n\tif (speclen == 2 && memcmp(spec, \"id\", 2) == 0)\n\t\treturn asymmetric_keyid_match(asymmetric_key_id(key), id);\n\tif (speclen == subtype->name_len &&\n\t    memcmp(spec, subtype->name, speclen) == 0)\n\t\treturn 1;\n\treturn 0;\n}", "target": 1}
{"code": "static int metachar(char c)\n{\n\treturn (strchr(metachars(), c) != NULL);\n}", "target": 1}
{"code": "static int iommu_no_mapping(struct device *dev)\n{\n\tint found;\n\tif (iommu_dummy(dev))\n\t\treturn 1;\n\tif (!iommu_identity_mapping)\n\t\treturn 0;\n\tfound = identity_mapping(dev);\n\tif (found) {\n\t\tif (iommu_should_identity_map(dev, 0))\n\t\t\treturn 1;\n\t\telse {\n\t\t\tdmar_remove_one_dev_info(si_domain, dev);\n\t\t\tpr_info(\"32bit %s uses non-identity mapping\\n\",\n\t\t\t\tdev_name(dev));\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (iommu_should_identity_map(dev, 0)) {\n\t\t\tint ret;\n\t\t\tret = domain_add_dev_info(si_domain, dev);\n\t\t\tif (!ret) {\n\t\t\t\tpr_info(\"64bit %s uses identity mapping\\n\",\n\t\t\t\t\tdev_name(dev));\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static void k_ascii(struct vc_data *vc, unsigned char value, char up_flag)\n{\n\tint base;\n\tif (up_flag)\n\t\treturn;\n\tif (value < 10) {\n\t\tbase = 10;\n\t} else {\n\t\tvalue -= 10;\n\t\tbase = 16;\n\t}\n\tif (npadch == -1)\n\t\tnpadch = value;\n\telse\n\t\tnpadch = npadch * base + value;\n}", "target": 1}
{"code": "static int create_srq_ring(PCIDevice *pci_dev, PvrdmaRing **ring,\n                           uint64_t pdir_dma, uint32_t max_wr,\n                           uint32_t max_sge, uint32_t nchunks)\n{\n    uint64_t *dir = NULL, *tbl = NULL;\n    PvrdmaRing *r;\n    int rc = -EINVAL;\n    char ring_name[MAX_RING_NAME_SZ];\n    uint32_t wqe_sz;\n    if (!nchunks || nchunks > PVRDMA_MAX_FAST_REG_PAGES) {\n        rdma_error_report(\"Got invalid page count for SRQ ring: %d\",\n                          nchunks);\n        return rc;\n    }\n    dir = rdma_pci_dma_map(pci_dev, pdir_dma, TARGET_PAGE_SIZE);\n    if (!dir) {\n        rdma_error_report(\"Failed to map to SRQ page directory\");\n        goto out;\n    }\n    tbl = rdma_pci_dma_map(pci_dev, dir[0], TARGET_PAGE_SIZE);\n    if (!tbl) {\n        rdma_error_report(\"Failed to map to SRQ page table\");\n        goto out;\n    }\n    r = g_malloc(sizeof(*r));\n    *ring = r;\n    r->ring_state = (PvrdmaRingState *)\n            rdma_pci_dma_map(pci_dev, tbl[0], TARGET_PAGE_SIZE);\n    if (!r->ring_state) {\n        rdma_error_report(\"Failed to map tp SRQ ring state\");\n        goto out_free_ring_mem;\n    }\n    wqe_sz = pow2ceil(sizeof(struct pvrdma_rq_wqe_hdr) +\n                      sizeof(struct pvrdma_sge) * max_sge - 1);\n    sprintf(ring_name, \"srq_ring_%\" PRIx64, pdir_dma);\n    rc = pvrdma_ring_init(r, ring_name, pci_dev, &r->ring_state[1], max_wr,\n                          wqe_sz, (dma_addr_t *)&tbl[1], nchunks - 1);\n    if (rc) {\n        goto out_unmap_ring_state;\n    }\n    goto out;\nout_unmap_ring_state:\n    rdma_pci_dma_unmap(pci_dev, r->ring_state, TARGET_PAGE_SIZE);\nout_free_ring_mem:\n    g_free(r);\nout:\n    rdma_pci_dma_unmap(pci_dev, tbl, TARGET_PAGE_SIZE);\n    rdma_pci_dma_unmap(pci_dev, dir, TARGET_PAGE_SIZE);\n    return rc;\n}", "target": 0}
{"code": "GF_Err iKMS_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ISMAKMSBox *ptr = (GF_ISMAKMSBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n    if (ptr->URI)\n        gf_bs_write_data(bs, ptr->URI, (u32) strlen(ptr->URI));\n    gf_bs_write_u8(bs, 0);\n\treturn GF_OK;\n}", "target": 0}
{"code": "int hugetlb_report_node_meminfo(char *buf, int len, int nid)\n{\n\tstruct hstate *h = &default_hstate;\n\tif (!hugepages_supported())\n\t\treturn 0;\n\treturn sysfs_emit_at(buf, len,\n\t\t\t     \"Node %d HugePages_Total: %5u\\n\"\n\t\t\t     \"Node %d HugePages_Free:  %5u\\n\"\n\t\t\t     \"Node %d HugePages_Surp:  %5u\\n\",\n\t\t\t     nid, h->nr_huge_pages_node[nid],\n\t\t\t     nid, h->free_huge_pages_node[nid],\n\t\t\t     nid, h->surplus_huge_pages_node[nid]);\n}", "target": 0}
{"code": "set_string (char **strp, const char *value)\n{\n\tif (*strp)\n\t\tfree (*strp);\n\t*strp = value ? strdup (value) : NULL;\n}", "target": 0}
{"code": "static int sr9700_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\n{\n\tstruct sk_buff *sr_skb;\n\tint len;\n\tif (unlikely(skb->len < SR_RX_OVERHEAD)) {\n\t\tnetdev_err(dev->net, \"unexpected tiny rx frame\\n\");\n\t\treturn 0;\n\t}\n\twhile (skb->len > SR_RX_OVERHEAD) {\n\t\tif (skb->data[0] != 0x40)\n\t\t\treturn 0;\n\t\tlen = (skb->data[1] | (skb->data[2] << 8)) - 4;\n\t\tif (len > ETH_FRAME_LEN || len > skb->len)\n\t\t\treturn 0;\n\t\tif (skb->len == (len + SR_RX_OVERHEAD))\t{\n\t\t\tskb_pull(skb, 3);\n\t\t\tskb->len = len;\n\t\t\tskb_set_tail_pointer(skb, len);\n\t\t\tskb->truesize = len + sizeof(struct sk_buff);\n\t\t\treturn 2;\n\t\t}\n\t\tsr_skb = skb_clone(skb, GFP_ATOMIC);\n\t\tif (!sr_skb)\n\t\t\treturn 0;\n\t\tsr_skb->len = len;\n\t\tsr_skb->data = skb->data + 3;\n\t\tskb_set_tail_pointer(sr_skb, len);\n\t\tsr_skb->truesize = len + sizeof(struct sk_buff);\n\t\tusbnet_skb_return(dev, sr_skb);\n\t\tskb_pull(skb, len + SR_RX_OVERHEAD);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int result(void)\n{\n\tint i;\n\tint status = 0;\n\tfor (i = 0; i < MAX_REPLIES; i++) {\n\t\tstatus = wait_til_ready();\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus &= STATUS_DIR | STATUS_READY | STATUS_BUSY | STATUS_DMA;\n\t\tif ((status & ~STATUS_BUSY) == STATUS_READY) {\n\t\t\tresultjiffies = jiffies;\n\t\t\tresultsize = i;\n\t\t\treturn i;\n\t\t}\n\t\tif (status == (STATUS_DIR | STATUS_READY | STATUS_BUSY))\n\t\t\treply_buffer[i] = fd_inb(FD_DATA);\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (initialized) {\n\t\tDPRINT(\"get result error. Fdc=%d Last status=%x Read bytes=%d\\n\",\n\t\t       fdc, status, i);\n\t\tshow_floppy();\n\t}\n\tFDCS->reset = 1;\n\treturn -1;\n}", "target": 0}
{"code": "SPICE_GNUC_VISIBLE int spice_server_migrate_switch(SpiceServer *reds)\n{\n    spice_debug(\"trace\");\n    if (reds->clients.empty()) {\n       return 0;\n    }\n    reds->expect_migrate = FALSE;\n    if (!reds->config->mig_spice) {\n        spice_warning(\"spice_server_migrate_switch called without migrate_info set\");\n        return 0;\n    }\n    reds->main_channel->migrate_switch(reds->config->mig_spice);\n    reds_mig_release(reds->config);\n    return 0;\n}", "target": 0}
{"code": "snd_seq_oss_synth_make_info(struct seq_oss_devinfo *dp, int dev, struct synth_info *inf)\n{\n\tstruct seq_oss_synth *rec;\n\tif (dp->synths[dev].is_midi) {\n\t\tstruct midi_info minf;\n\t\tsnd_seq_oss_midi_make_info(dp, dp->synths[dev].midi_mapped, &minf);\n\t\tinf->synth_type = SYNTH_TYPE_MIDI;\n\t\tinf->synth_subtype = 0;\n\t\tinf->nr_voices = 16;\n\t\tinf->device = dev;\n\t\tstrlcpy(inf->name, minf.name, sizeof(inf->name));\n\t} else {\n\t\tif ((rec = get_synthdev(dp, dev)) == NULL)\n\t\t\treturn -ENXIO;\n\t\tinf->synth_type = rec->synth_type;\n\t\tinf->synth_subtype = rec->synth_subtype;\n\t\tinf->nr_voices = rec->nr_voices;\n\t\tinf->device = dev;\n\t\tstrlcpy(inf->name, rec->name, sizeof(inf->name));\n\t\tsnd_use_lock_free(&rec->use_lock);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static size_t hash_str(const void *ptr)\n{\n    const char *str = (const char *)ptr;\n    size_t hash = 5381;\n    size_t c;\n    while((c = (size_t)*str))\n    {\n        hash = ((hash << 5) + hash) + c;\n        str++;\n    }\n    return hash;\n}", "target": 1}
{"code": "static void kvm_pv_disable_apf(void)\n{\n\tif (!__this_cpu_read(apf_reason.enabled))\n\t\treturn;\n\twrmsrl(MSR_KVM_ASYNC_PF_EN, 0);\n\t__this_cpu_write(apf_reason.enabled, 0);\n\tprintk(KERN_INFO\"Unregister pv shared memory for cpu %d\\n\",\n\t       smp_processor_id());\n}", "target": 0}
{"code": "    Image::UniquePtr ImageFactory::create(ImageType type,\n                                        const std::wstring& wpath)\n    {\n        std::unique_ptr<FileIo> fileIo(new FileIo(wpath));\n        if (fileIo->open(\"w+b\") != 0) {\n            throw WError(kerFileOpenFailed, wpath, \"w+b\", strError().c_str());\n        }\n        fileIo->close();\n        BasicIo::UniquePtr io(std::move(fileIo));\n        Image::UniquePtr image = create(type, std::move(io));\n        if (image.get() == 0) throw Error(kerUnsupportedImageType, static_cast<int>(type));\n        return image;\n    }", "target": 0}
{"code": "static void sigchld_reaper(void) {\n\tWAIT_T waiter;\n\tPID_T pid;\n\tdo {\n\t\tpid = waitpid(-1, &waiter, WNOHANG);\n\t\tswitch (pid) {\n\t\tcase -1:\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tDebug(DPROC, (\"[%ld] sigchld...no children\\n\", (long) getpid()))\n\t\t\t\tbreak;\n\t\tcase 0:\n\t\t\tDebug(DPROC, (\"[%ld] sigchld...no dead kids\\n\", (long) getpid()))\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\tDebug(DPROC,\n\t\t\t\t(\"[%ld] sigchld...pid #%ld died, stat=%d\\n\",\n\t\t\t\t\t(long) getpid(), (long) pid, WEXITSTATUS(waiter)))\n\t\t\t\tbreak;\n\t\t}\n\t} while (pid > 0);\n}", "target": 0}
{"code": "void sctp_association_free(struct sctp_association *asoc)\n{\n\tstruct sock *sk = asoc->base.sk;\n\tstruct sctp_transport *transport;\n\tstruct list_head *pos, *temp;\n\tint i;\n\tif (!asoc->temp) {\n\t\tlist_del(&asoc->asocs);\n\t\tif (sctp_style(sk, TCP) && sctp_sstate(sk, LISTENING))\n\t\t\tsk->sk_ack_backlog--;\n\t}\n\tasoc->base.dead = true;\n\tsctp_outq_free(&asoc->outqueue);\n\tsctp_ulpq_free(&asoc->ulpq);\n\tsctp_inq_free(&asoc->base.inqueue);\n\tsctp_tsnmap_free(&asoc->peer.tsn_map);\n\tsctp_ssnmap_free(asoc->ssnmap);\n\tsctp_bind_addr_free(&asoc->base.bind_addr);\n\tfor (i = SCTP_EVENT_TIMEOUT_NONE; i < SCTP_NUM_TIMEOUT_TYPES; ++i) {\n\t\tif (del_timer(&asoc->timers[i]))\n\t\t\tsctp_association_put(asoc);\n\t}\n\tkfree(asoc->peer.cookie);\n\tkfree(asoc->peer.peer_random);\n\tkfree(asoc->peer.peer_chunks);\n\tkfree(asoc->peer.peer_hmacs);\n\tlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {\n\t\ttransport = list_entry(pos, struct sctp_transport, transports);\n\t\tlist_del_rcu(pos);\n\t\tsctp_transport_free(transport);\n\t}\n\tasoc->peer.transport_count = 0;\n\tsctp_asconf_queue_teardown(asoc);\n\tif (asoc->asconf_addr_del_pending != NULL)\n\t\tkfree(asoc->asconf_addr_del_pending);\n\tsctp_auth_destroy_keys(&asoc->endpoint_shared_keys);\n\tsctp_auth_key_put(asoc->asoc_shared_key);\n\tsctp_association_put(asoc);\n}", "target": 1}
{"code": "GF_Err diST_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tchar str[1024];\n\tGF_DIMSScriptTypesBox *p = (GF_DIMSScriptTypesBox *)s;\n\ti=0;\n\tstr[0]=0;\n\twhile (1) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tif (!str[i]) break;\n\t\ti++;\n\t}\n\tISOM_DECREASE_SIZE(p, i);\n\tp->content_script_types = gf_strdup(str);\n\treturn GF_OK;\n}", "target": 1}
{"code": "static MagickBooleanType load_tile(Image *image,Image *tile_image,\n  XCFDocInfo *inDocInfo,XCFLayerInfo *inLayerInfo,size_t data_length,\n  ExceptionInfo *exception)\n{\n  ssize_t\n    y;\n  register ssize_t\n    x;\n  register Quantum\n    *q;\n  ssize_t\n    count;\n  unsigned char\n    *graydata;\n  XCFPixelInfo\n    *xcfdata,\n    *xcfodata;\n  xcfdata=(XCFPixelInfo *) AcquireQuantumMemory(data_length,sizeof(*xcfdata));\n  if (xcfdata == (XCFPixelInfo *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  xcfodata=xcfdata;\n  graydata=(unsigned char *) xcfdata;  \n  count=ReadBlob(image,data_length,(unsigned char *) xcfdata);\n  if (count != (ssize_t) data_length)\n    ThrowBinaryException(CorruptImageError,\"NotEnoughPixelData\",\n      image->filename);\n  for (y=0; y < (ssize_t) tile_image->rows; y++)\n  {\n    q=GetAuthenticPixels(tile_image,0,y,tile_image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    if (inDocInfo->image_type == GIMP_GRAY)\n      {\n        for (x=0; x < (ssize_t) tile_image->columns; x++)\n        {\n          SetPixelGray(tile_image,ScaleCharToQuantum(*graydata),q);\n          SetPixelAlpha(tile_image,ScaleCharToQuantum((unsigned char)\n            inLayerInfo->alpha),q);\n          graydata++;\n          q+=GetPixelChannels(tile_image);\n        }\n      }\n    else\n      if (inDocInfo->image_type == GIMP_RGB)\n        {\n          for (x=0; x < (ssize_t) tile_image->columns; x++)\n          {\n            SetPixelRed(tile_image,ScaleCharToQuantum(xcfdata->red),q);\n            SetPixelGreen(tile_image,ScaleCharToQuantum(xcfdata->green),q);\n            SetPixelBlue(tile_image,ScaleCharToQuantum(xcfdata->blue),q);\n            SetPixelAlpha(tile_image,xcfdata->alpha == 255U ? TransparentAlpha :\n              ScaleCharToQuantum((unsigned char) inLayerInfo->alpha),q);\n            xcfdata++;\n            q+=GetPixelChannels(tile_image);\n          }\n        }\n     if (SyncAuthenticPixels(tile_image,exception) == MagickFalse)\n       break;\n  }\n  xcfodata=(XCFPixelInfo *) RelinquishMagickMemory(xcfodata);\n  return MagickTrue;\n}", "target": 1}
{"code": "_client_protocol_timeout (GsmXSMPClient *client)\n{\n        g_debug (\"GsmXSMPClient: client_protocol_timeout for client '%s' in ICE status %d\",\n                 client->priv->description,\n                 IceConnectionStatus (client->priv->ice_connection));\n        gsm_client_set_status (GSM_CLIENT (client), GSM_CLIENT_FAILED);\n        gsm_client_disconnected (GSM_CLIENT (client));\n        return FALSE;\n}", "target": 1}
{"code": "ZEND_API void zend_object_store_ctor_failed(zval *zobject TSRMLS_DC)\n{\n\tzend_object_handle handle = Z_OBJ_HANDLE_P(zobject);\n\tzend_object_store_bucket *obj_bucket = &EG(objects_store).object_buckets[handle];\n\tobj_bucket->bucket.obj.handlers = Z_OBJ_HT_P(zobject);;\n\tobj_bucket->destructor_called = 1;\n}", "target": 1}
{"code": "static inline void RelinquishDCMMemory(DCMInfo *info,DCMMap *map,\n  DCMStreamInfo *stream_info,LinkedListInfo *stack,unsigned char *data)\n{\n  if (info->scale != (Quantum *) NULL)\n    info->scale=(Quantum *) RelinquishMagickMemory(info->scale);\n  if (map->gray != (int *) NULL)\n    map->gray=(int *) RelinquishMagickMemory(map->gray);\n  if (map->blue != (int *) NULL)\n    map->blue=(int *) RelinquishMagickMemory(map->blue);\n  if (map->green != (int *) NULL)\n    map->green=(int *) RelinquishMagickMemory(map->green);\n  if (map->red != (int *) NULL)\n    map->red=(int *) RelinquishMagickMemory(map->red);\n  if (stream_info->offsets != (ssize_t *) NULL)\n    stream_info->offsets=(ssize_t *) RelinquishMagickMemory(\n      stream_info->offsets);\n  if (stream_info != (DCMStreamInfo *) NULL)\n    stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info);\n  if (stack != (LinkedListInfo *) NULL)\n    stack=DestroyLinkedList(stack,RelinquishDCMInfo);\n  if (data != (unsigned char *) NULL)\n    data=(unsigned char *) RelinquishMagickMemory(data);\n}", "target": 0}
{"code": "  TfLiteRegistration CancelOpRegistration() {\n    TfLiteRegistration reg = {nullptr, nullptr, nullptr, nullptr};\n    reg.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n      const TfLiteTensor* in_tensor = GetInput(context, node, 0);\n      TfLiteTensor* out_tensor = GetOutput(context, node, 0);\n      TfLiteIntArray* new_size = TfLiteIntArrayCopy(in_tensor->dims);\n      return context->ResizeTensor(context, out_tensor, new_size);\n    };\n    reg.invoke = [](TfLiteContext* context, TfLiteNode* node) {\n      cancellation_data_.is_cancelled = true;\n      return kTfLiteOk;\n    };\n    return reg;\n  }", "target": 1}
{"code": "mark_op_resolved (FlatpakTransactionOperation *op,\n                  const char                  *commit,\n                  GFile                       *sideload_path,\n                  GBytes                      *metadata,\n                  GBytes                      *old_metadata)\n{\n  g_debug (\"marking op %s:%s resolved to %s\", kind_to_str (op->kind), flatpak_decomposed_get_ref (op->ref), commit ? commit : \"-\");\n  g_assert (op != NULL);\n  g_assert (commit != NULL);\n  op->resolved = TRUE;\n  if (op->resolved_commit != commit)\n    {\n      g_free (op->resolved_commit); \n      op->resolved_commit = g_strdup (commit);\n    }\n  if (sideload_path)\n    op->resolved_sideload_path = g_object_ref (sideload_path);\n  if (metadata)\n    {\n      g_autoptr(GKeyFile) metakey = g_key_file_new ();\n      if (g_key_file_load_from_bytes (metakey, metadata, G_KEY_FILE_NONE, NULL))\n        {\n          op->resolved_metadata = g_bytes_ref (metadata);\n          op->resolved_metakey = g_steal_pointer (&metakey);\n        }\n      else\n        g_message (\"Warning: Failed to parse metadata for %s\\n\", flatpak_decomposed_get_ref (op->ref));\n    }\n  if (old_metadata)\n    {\n      g_autoptr(GKeyFile) metakey = g_key_file_new ();\n      if (g_key_file_load_from_bytes (metakey, old_metadata, G_KEY_FILE_NONE, NULL))\n        {\n          op->resolved_old_metadata = g_bytes_ref (old_metadata);\n          op->resolved_old_metakey = g_steal_pointer (&metakey);\n        }\n      else\n        g_message (\"Warning: Failed to parse old metadata for %s\\n\", flatpak_decomposed_get_ref (op->ref));\n    }\n}", "target": 1}
{"code": "hb_map_clear (hb_map_t *map)\n{\n  if (unlikely (hb_object_is_immutable (map)))\n    return;\n  return map->clear ();\n}", "target": 1}
{"code": "char_codespan(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)\n{\n\tsize_t end, nb = 0, i, f_begin, f_end;\n\twhile (nb < size && data[nb] == '`')\n\t\tnb++;\n\ti = 0;\n\tfor (end = nb; end < size && i < nb; end++) {\n\t\tif (data[end] == '`') i++;\n\t\telse i = 0;\n\t}\n\tif (i < nb && end >= size)\n\t\treturn 0; \n\tf_begin = nb;\n\twhile (f_begin < end && data[f_begin] == ' ')\n\t\tf_begin++;\n\tf_end = end - nb;\n\twhile (f_end > nb && data[f_end-1] == ' ')\n\t\tf_end--;\n\tif (f_begin < f_end) {\n\t\tstruct buf work = { data + f_begin, f_end - f_begin, 0, 0 };\n\t\tif (!rndr->cb.codespan(ob, &work, rndr->opaque))\n\t\t\tend = 0;\n\t} else {\n\t\tif (!rndr->cb.codespan(ob, 0, rndr->opaque))\n\t\t\tend = 0;\n\t}\n\treturn end;\n}", "target": 0}
{"code": "static s16 swf_get_s16(SWFReader *read)\n{\n\ts16 val;\n\tu8 v1;\n\tv1 = swf_read_int(read, 8);\n\tval = swf_read_sint(read, 8);\n\tval = (val<<8)&0xFF00;\n\tval |= (v1&0xFF);\n\treturn val;\n}", "target": 1}
{"code": "static cfg_value_t *cfg_opt_getval(cfg_opt_t *opt, unsigned int index)\n{\n\tcfg_value_t *val = NULL;\n\tif (index != 0 && !is_set(CFGF_LIST, opt->flags) && !is_set(CFGF_MULTI, opt->flags)) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\tif (opt->simple_value.ptr)\n\t\tval = (cfg_value_t *)opt->simple_value.ptr;\n\telse {\n\t\tif (is_set(CFGF_RESET, opt->flags)) {\n\t\t\tcfg_free_value(opt);\n\t\t\topt->flags &= ~CFGF_RESET;\n\t\t}\n\t\tif (index >= opt->nvalues)\n\t\t\tval = cfg_addval(opt);\n\t\telse\n\t\t\tval = opt->values[index];\n\t}\n\treturn val;\n}", "target": 0}
{"code": "CallResult<HermesValue> Runtime::interpretFunctionImpl(\n    CodeBlock *newCodeBlock) {\n  newCodeBlock->lazyCompile(*this);\n#if defined(HERMES_MEMORY_INSTRUMENTATION) || !defined(NDEBUG)\n  const inst::Inst *ip = getCurrentIP();\n  (void)ip;\n#endif\n#ifdef HERMES_MEMORY_INSTRUMENTATION\n  if (ip) {\n    const CodeBlock *codeBlock;\n    std::tie(codeBlock, ip) = getCurrentInterpreterLocation(ip);\n    if (codeBlock) {\n      pushCallStack(codeBlock, ip);\n    } else {\n      pushCallStack(newCodeBlock, (const Inst *)newCodeBlock->begin());\n    }\n  } else {\n    pushCallStack(newCodeBlock, (const Inst *)newCodeBlock->begin());\n  }\n#endif\n  InterpreterState state{newCodeBlock, 0};\n  if (HERMESVM_CRASH_TRACE &&\n      (getVMExperimentFlags() & experiments::CrashTrace)) {\n    return Interpreter::interpretFunction<false, true>(*this, state);\n  } else {\n    return Interpreter::interpretFunction<false, false>(*this, state);\n  }\n}", "target": 1}
{"code": "xmlNodePtr SimpleXMLElement_exportNode(const Object& sxe) {\n  assert(sxe->instanceof(SimpleXMLElement_classof()));\n  auto data = Native::data<SimpleXMLElement>(sxe.get());\n  return php_sxe_get_first_node(data, data->nodep());\n}", "target": 1}
{"code": "static const char* getenv_harder(pam_handle_t *handle, const char *key, const char *fallback) {\n        const char *v;\n        assert(handle);\n        assert(key);\n        v = pam_getenv(handle, key);\n        if (!isempty(v))\n                return v;\n        v = getenv(key);\n        if (!isempty(v))\n                return v;\n        return fallback;\n}", "target": 1}
{"code": "static int transmit_skb(struct sk_buff *skb, struct caifsock *cf_sk,\n\t\t\tint noblock, long timeo)\n{\n\tstruct cfpkt *pkt;\n\tpkt = cfpkt_fromnative(CAIF_DIR_OUT, skb);\n\tmemset(skb->cb, 0, sizeof(struct caif_payload_info));\n\tcfpkt_set_prio(pkt, cf_sk->sk.sk_priority);\n\tif (cf_sk->layer.dn == NULL) {\n\t\tkfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\treturn cf_sk->layer.dn->transmit(cf_sk->layer.dn, pkt);\n}", "target": 0}
{"code": "void ipc_rcu_getref(void *ptr)\n{\n\tcontainer_of(ptr, struct ipc_rcu_hdr, data)->refcount++;\n}", "target": 1}
{"code": "int SMIME_write_PKCS7(BIO *bio, PKCS7 *p7, BIO *data, int flags)\n{\n    STACK_OF(X509_ALGOR) *mdalgs;\n    int ctype_nid = OBJ_obj2nid(p7->type);\n    const PKCS7_CTX *ctx = ossl_pkcs7_get0_ctx(p7);\n    if (ctype_nid == NID_pkcs7_signed)\n        mdalgs = p7->d.sign->md_algs;\n    else\n        mdalgs = NULL;\n    flags ^= SMIME_OLDMIME;\n    return SMIME_write_ASN1_ex(bio, (ASN1_VALUE *)p7, data, flags, ctype_nid,\n                               NID_undef, mdalgs, ASN1_ITEM_rptr(PKCS7),\n                               ossl_pkcs7_ctx_get0_libctx(ctx),\n                               ossl_pkcs7_ctx_get0_propq(ctx));\n}", "target": 1}
{"code": "static int xen_net_read_mac(struct xenbus_device *dev, u8 mac[])\n{\n\tchar *s, *e, *macstr;\n\tint i;\n\tmacstr = s = xenbus_read(XBT_NIL, dev->nodename, \"mac\", NULL);\n\tif (IS_ERR(macstr))\n\t\treturn PTR_ERR(macstr);\n\tfor (i = 0; i < ETH_ALEN; i++) {\n\t\tmac[i] = simple_strtoul(s, &e, 16);\n\t\tif ((s == e) || (*e != ((i == ETH_ALEN-1) ? '\\0' : ':'))) {\n\t\t\tkfree(macstr);\n\t\t\treturn -ENOENT;\n\t\t}\n\t\ts = e+1;\n\t}\n\tkfree(macstr);\n\treturn 0;\n}", "target": 0}
{"code": "static inline QuantumAny ScaleQuantumToAny(const Quantum quantum,\n  const QuantumAny range)\n{\n  return((QuantumAny) (((double) range*quantum)/QuantumRange+0.5));\n}", "target": 1}
{"code": "GF_Err video_sample_entry_box_size(GF_Box *s)\n{\n\tGF_Box *b;\n\tu32 pos=0;\n\tGF_MPEGVisualSampleEntryBox *ptr = (GF_MPEGVisualSampleEntryBox *)s;\n\tgf_isom_video_sample_entry_size((GF_VisualSampleEntryBox *)s);\n\tgf_isom_check_position(s, (GF_Box *)ptr->esd, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_3gpp, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->avc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->svc_config, &pos);\n\tif (ptr->mvc_config) {\n\t\tgf_isom_check_position(s, gf_isom_box_find_child(s->child_boxes, GF_ISOM_BOX_TYPE_VWID), &pos);\n\t\tgf_isom_check_position(s, (GF_Box *)ptr->mvc_config, &pos);\n\t}\n\tgf_isom_check_position(s, (GF_Box *)ptr->hevc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->lhvc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->vvc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->av1_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->vp_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->jp2h, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->dovi_config, &pos);\n\tb = gf_isom_box_find_child(ptr->child_boxes, GF_ISOM_BOX_TYPE_ST3D);\n\tif (b) gf_isom_check_position(s, b, &pos);\n\tb = gf_isom_box_find_child(ptr->child_boxes, GF_ISOM_BOX_TYPE_SV3D);\n\tif (b) gf_isom_check_position(s, b, &pos);\n\treturn GF_OK;\n}", "target": 1}
{"code": "static int propagateConstantExprRewrite(Walker *pWalker, Expr *pExpr){\n  int i;\n  WhereConst *pConst;\n  if( pExpr->op!=TK_COLUMN ) return WRC_Continue;\n  if( ExprHasProperty(pExpr, EP_FixedCol) ) return WRC_Continue;\n  pConst = pWalker->u.pConst;\n  for(i=0; i<pConst->nConst; i++){\n    Expr *pColumn = pConst->apExpr[i*2];\n    if( pColumn==pExpr ) continue;\n    if( pColumn->iTable!=pExpr->iTable ) continue;\n    if( pColumn->iColumn!=pExpr->iColumn ) continue;\n    pConst->nChng++;\n    ExprClearProperty(pExpr, EP_Leaf);\n    ExprSetProperty(pExpr, EP_FixedCol);\n    assert( pExpr->pLeft==0 );\n    pExpr->pLeft = sqlite3ExprDup(pConst->pParse->db, pConst->apExpr[i*2+1], 0);\n    break;\n  }\n  return WRC_Prune;\n}", "target": 1}
{"code": "u32 gf_isom_get_avg_sample_size(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleSize) return 0;\n\tif ( trak->Media->information->sampleTable->SampleSize->sampleSize)\n\t\treturn trak->Media->information->sampleTable->SampleSize->sampleSize;\n\tif (!trak->Media->information->sampleTable->SampleSize->total_samples) return 0;\n\treturn (u32) (trak->Media->information->sampleTable->SampleSize->total_size / trak->Media->information->sampleTable->SampleSize->total_samples);\n}", "target": 0}
{"code": "FIO_FUNC inline void fio_throttle_thread(size_t nano_sec) {\n  const struct timespec tm = {.tv_nsec = (nano_sec % 1000000000),\n                              .tv_sec = (nano_sec / 1000000000)};\n  nanosleep(&tm, NULL);\n}", "target": 1}
{"code": "int rm_rf_child(int fd, const char *name, RemoveFlags flags) {\n        if (fd < 0)\n                return -EBADF;\n        if (!filename_is_valid(name))\n                return -EINVAL;\n        if ((flags & (REMOVE_ROOT|REMOVE_MISSING_OK)) != 0) \n                return -EINVAL;\n        if (FLAGS_SET(flags, REMOVE_ONLY_DIRECTORIES|REMOVE_SUBVOLUME))\n                return -EINVAL;\n        return rm_rf_children_inner(fd, name, -1, flags, NULL);\n}", "target": 1}
{"code": "BOOL CSoundFile::GetPatternName(UINT nPat, LPSTR lpszName, UINT cbSize) const\n{\n\tif ((!lpszName) || (!cbSize)) return FALSE;\n\tlpszName[0] = 0;\n\tif (cbSize > MAX_PATTERNNAME) cbSize = MAX_PATTERNNAME;\n\tif ((m_lpszPatternNames) && (nPat < m_nPatternNames))\n\t{\n\t\tmemcpy(lpszName, m_lpszPatternNames + nPat * MAX_PATTERNNAME, cbSize);\n\t\tlpszName[cbSize-1] = 0;\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}", "target": 0}
{"code": "static int svm_cpu_init(int cpu)\n{\n\tstruct svm_cpu_data *sd;\n\tint r;\n\tsd = kzalloc(sizeof(struct svm_cpu_data), GFP_KERNEL);\n\tif (!sd)\n\t\treturn -ENOMEM;\n\tsd->cpu = cpu;\n\tr = -ENOMEM;\n\tsd->save_area = alloc_page(GFP_KERNEL);\n\tif (!sd->save_area)\n\t\tgoto err_1;\n\tif (svm_sev_enabled()) {\n\t\tr = -ENOMEM;\n\t\tsd->sev_vmcbs = kmalloc_array(max_sev_asid + 1,\n\t\t\t\t\t      sizeof(void *),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!sd->sev_vmcbs)\n\t\t\tgoto err_1;\n\t}\n\tper_cpu(svm_data, cpu) = sd;\n\treturn 0;\nerr_1:\n\tkfree(sd);\n\treturn r;\n}", "target": 1}
{"code": "__nlmsg_put(struct sk_buff *skb, u32 pid, u32 seq, int type, int len, int flags)\n{\n\tstruct nlmsghdr *nlh;\n\tint size = NLMSG_LENGTH(len);\n\tnlh = (struct nlmsghdr*)skb_put(skb, NLMSG_ALIGN(size));\n\tnlh->nlmsg_type = type;\n\tnlh->nlmsg_len = size;\n\tnlh->nlmsg_flags = flags;\n\tnlh->nlmsg_pid = pid;\n\tnlh->nlmsg_seq = seq;\n\treturn nlh;\n}", "target": 1}
{"code": "print_timer(struct seq_file *m, struct hrtimer *taddr, struct hrtimer *timer,\n\t    int idx, u64 now)\n{\n#ifdef CONFIG_TIMER_STATS\n\tchar tmp[TASK_COMM_LEN + 1];\n#endif\n\tSEQ_printf(m, \" #%d: \", idx);\n\tprint_name_offset(m, taddr);\n\tSEQ_printf(m, \", \");\n\tprint_name_offset(m, timer->function);\n\tSEQ_printf(m, \", S:%02x\", timer->state);\n#ifdef CONFIG_TIMER_STATS\n\tSEQ_printf(m, \", \");\n\tprint_name_offset(m, timer->start_site);\n\tmemcpy(tmp, timer->start_comm, TASK_COMM_LEN);\n\ttmp[TASK_COMM_LEN] = 0;\n\tSEQ_printf(m, \", %s/%d\", tmp, timer->start_pid);\n#endif\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \" # expires at %Lu-%Lu nsecs [in %Ld to %Ld nsecs]\\n\",\n\t\t(unsigned long long)ktime_to_ns(hrtimer_get_softexpires(timer)),\n\t\t(unsigned long long)ktime_to_ns(hrtimer_get_expires(timer)),\n\t\t(long long)(ktime_to_ns(hrtimer_get_softexpires(timer)) - now),\n\t\t(long long)(ktime_to_ns(hrtimer_get_expires(timer)) - now));\n}", "target": 1}
{"code": "static void n_tty_receive_break(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tif (I_IGNBRK(tty))\n\t\treturn;\n\tif (I_BRKINT(tty)) {\n\t\tisig(SIGINT, tty);\n\t\tif (!L_NOFLSH(tty)) {\n\t\t\tup_read(&tty->termios_rwsem);\n\t\t\tn_tty_flush_buffer(tty);\n\t\t\ttty_driver_flush_buffer(tty);\n\t\t\tdown_read(&tty->termios_rwsem);\n\t\t}\n\t\treturn;\n\t}\n\tif (I_PARMRK(tty)) {\n\t\tput_tty_queue('\\377', ldata);\n\t\tput_tty_queue('\\0', ldata);\n\t}\n\tput_tty_queue('\\0', ldata);\n\tif (waitqueue_active(&tty->read_wait))\n\t\twake_up_interruptible(&tty->read_wait);\n}", "target": 0}
{"code": "parse_field(netdissect_options *ndo, const char **pptr, int *len)\n{\n    const char *s;\n    if (*len <= 0 || !pptr || !*pptr)\n\treturn NULL;\n    if (*pptr > (const char *) ndo->ndo_snapend)\n\treturn NULL;\n    s = *pptr;\n    while (*pptr <= (const char *) ndo->ndo_snapend && *len >= 0 && **pptr) {\n\t(*pptr)++;\n\t(*len)--;\n    }\n    (*pptr)++;\n    (*len)--;\n    if (*len < 0 || *pptr > (const char *) ndo->ndo_snapend)\n\treturn NULL;\n    return s;\n}", "target": 1}
{"code": "test_appheader (xd3_stream *stream, int ignore)\n{\n  int i;\n  int ret;\n  char buf[TESTBUFSIZE];\n  char bogus[TESTBUFSIZE];\n  xoff_t ssize, tsize;\n  test_setup ();\n  if ((ret = test_make_inputs (stream, &ssize, &tsize))) { return ret; }\n  snprintf_func (buf, TESTBUFSIZE, \"%s -q -f -e -s %s %s %s\", program_name,\n\t\t TEST_SOURCE_FILE, TEST_TARGET_FILE, TEST_DELTA_FILE);\n  if ((ret = do_cmd (stream, buf))) { return ret; }\n  if ((ret = test_copy_to (program_name, TEST_RECON2_FILE))) { return ret; }\n  snprintf_func (buf, TESTBUFSIZE, \"chmod 0700 %s\", TEST_RECON2_FILE);\n  if ((ret = do_cmd (stream, buf))) { return ret; }\n  if ((ret = test_save_copy (TEST_TARGET_FILE))) { return ret; }\n  if ((ret = test_copy_to (TEST_SOURCE_FILE, TEST_TARGET_FILE))) { return ret; }\n  if ((ret = test_compare_files (TEST_TARGET_FILE, TEST_COPY_FILE)) == 0)\n    {\n      return XD3_INVALID;  \n    }\n  snprintf_func (buf, TESTBUFSIZE, \"(cd /tmp && %s -q -f -d %s)\",\n\t\t TEST_RECON2_FILE,\n\t\t TEST_DELTA_FILE);\n  if ((ret = do_cmd (stream, buf))) { return ret; }\n  if ((ret = test_compare_files (TEST_TARGET_FILE, TEST_COPY_FILE)) != 0)\n    {\n      return ret;\n    }\n  for (i = 0; i < TESTBUFSIZE / 4; ++i)\n    {\n      bogus[2*i] = 'G';\n      bogus[2*i+1] = '/';\n    }\n  bogus[TESTBUFSIZE/2-1] = 0;\n  snprintf_func (buf, TESTBUFSIZE, \n\t\t \"%s -q -f -A=%s -e -s %s %s %s\", program_name, bogus,\n\t\t TEST_SOURCE_FILE, TEST_TARGET_FILE, TEST_DELTA_FILE);\n  if ((ret = do_cmd (stream, buf))) { return ret; }\n  snprintf_func (buf, TESTBUFSIZE, \"(cd /tmp && %s -q -f -d %s)\",\n\t\t TEST_RECON2_FILE,\n\t\t TEST_DELTA_FILE);\n  if ((ret = do_cmd (stream, buf)) == 0) \n    { \n      return XD3_INVALID;  \n    }\n  if (!WIFEXITED(ret))\n    {\n      return XD3_INVALID;  \n    }\n  return 0;\n}", "target": 0}
{"code": "RPVector *r_bin_wasm_get_functions(RBinWasmObj *bin) {\n\tr_return_val_if_fail (bin && bin->g_sections, NULL);\n\treturn bin->g_funcs? bin->g_funcs: parse_unique_subsec_vec_by_id (bin, R_BIN_WASM_SECTION_FUNCTION);\n}", "target": 0}
{"code": "static int skcipher_wait_for_wmem(struct sock *sk, unsigned flags)\n{\n\tlong timeout;\n\tDEFINE_WAIT(wait);\n\tint err = -ERESTARTSYS;\n\tif (flags & MSG_DONTWAIT)\n\t\treturn -EAGAIN;\n\tsk_set_bit(SOCKWQ_ASYNC_NOSPACE, sk);\n\tfor (;;) {\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\tprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\t\ttimeout = MAX_SCHEDULE_TIMEOUT;\n\t\tif (sk_wait_event(sk, &timeout, skcipher_writable(sk))) {\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfinish_wait(sk_sleep(sk), &wait);\n\treturn err;\n}", "target": 0}
{"code": "  Address pending_message_obj_address() {\n    return reinterpret_cast<Address>(&thread_local_top_.pending_message_obj_);\n  }", "target": 0}
{"code": "static int ext4_fill_flex_info(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_group_desc *gdp = NULL;\n\text4_group_t flex_group_count;\n\text4_group_t flex_group;\n\tint groups_per_flex = 0;\n\tsize_t size;\n\tint i;\n\tsbi->s_log_groups_per_flex = sbi->s_es->s_log_groups_per_flex;\n\tgroups_per_flex = 1 << sbi->s_log_groups_per_flex;\n\tif (groups_per_flex < 2) {\n\t\tsbi->s_log_groups_per_flex = 0;\n\t\treturn 1;\n\t}\n\tflex_group_count = ((sbi->s_groups_count + groups_per_flex - 1) +\n\t\t\t((le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) + 1) <<\n\t\t\t      EXT4_DESC_PER_BLOCK_BITS(sb))) / groups_per_flex;\n\tsize = flex_group_count * sizeof(struct flex_groups);\n\tsbi->s_flex_groups = ext4_kvzalloc(size, GFP_KERNEL);\n\tif (sbi->s_flex_groups == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory for %u flex groups\",\n\t\t\t flex_group_count);\n\t\tgoto failed;\n\t}\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\t\tflex_group = ext4_flex_group(sbi, i);\n\t\tatomic_add(ext4_free_inodes_count(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].free_inodes);\n\t\tatomic_add(ext4_free_group_clusters(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].free_clusters);\n\t\tatomic_add(ext4_used_dirs_count(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].used_dirs);\n\t}\n\treturn 1;\nfailed:\n\treturn 0;\n}", "target": 1}
{"code": "int nfc_activate_target(struct nfc_dev *dev, u32 target_idx, u32 protocol)\n{\n\tint rc;\n\tstruct nfc_target *target;\n\tpr_debug(\"dev_name=%s target_idx=%u protocol=%u\\n\",\n\t\t dev_name(&dev->dev), target_idx, protocol);\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->active_target) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\ttarget = nfc_find_target(dev, target_idx);\n\tif (target == NULL) {\n\t\trc = -ENOTCONN;\n\t\tgoto error;\n\t}\n\trc = dev->ops->activate_target(dev, target, protocol);\n\tif (!rc) {\n\t\tdev->active_target = target;\n\t\tdev->rf_mode = NFC_RF_INITIATOR;\n\t\tif (dev->ops->check_presence && !dev->shutting_down)\n\t\t\tmod_timer(&dev->check_pres_timer, jiffies +\n\t\t\t\t  msecs_to_jiffies(NFC_CHECK_PRES_FREQ_MS));\n\t}\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "bgp_afi_safi_valid_indices (afi_t afi, safi_t *safi)\n{\n  if ((afi == AFI_IP6 && *safi == BGP_SAFI_VPNV4)\n      || (afi == AFI_IP && *safi == BGP_SAFI_VPNV6))\n    {\n      zlog_warn (\"Invalid afi/safi combination (%u/%u)\", afi, *safi);\n      return 0;\n    }\n  switch (afi)\n    {\n      case AFI_IP:\n#ifdef HAVE_IPV6\n      case AFI_IP6:\n#endif\n        switch (*safi)\n          {\n            case BGP_SAFI_VPNV4:\n            case BGP_SAFI_VPNV6:\n              *safi = SAFI_MPLS_VPN;\n            case SAFI_UNICAST:\n            case SAFI_MULTICAST:\n            case SAFI_MPLS_VPN:\n              return 1;\n          }\n    }\n  zlog_debug (\"unknown afi/safi (%u/%u)\", afi, *safi);\n  return 0;\n}", "target": 0}
{"code": "struct resource_pool *dce110_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc,\n\tstruct hw_asic_id asic_id)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\tif (!pool)\n\t\treturn NULL;\n\tif (construct(num_virtual_links, dc, pool, asic_id))\n\t\treturn &pool->base;\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 1}
{"code": "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur)\n{\n\tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t\t(cur->addr.sin_port == sin->sin_port)) {\n\t\tif ((cur->peercallno == callno) ||\n\t\t\t((dcallno == cur->callno) && !cur->peercallno)) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t    (cur->transfer.sin_port == sin->sin_port) && (cur->transferring)) {\n\t\tif ((dcallno == cur->callno) || (cur->transferring == TRANSFER_MEDIAPASS && cur->transfercallno == callno))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "OverscrollControllerAndroid::~OverscrollControllerAndroid() {\n}", "target": 0}
{"code": "static int get_bitmap_file(struct mddev *mddev, void __user * arg)\n{\n\tmdu_bitmap_file_t *file = NULL; \n\tchar *ptr;\n\tint err;\n\tfile = kmalloc(sizeof(*file), GFP_NOIO);\n\tif (!file)\n\t\treturn -ENOMEM;\n\terr = 0;\n\tspin_lock(&mddev->lock);\n\tif (!mddev->bitmap_info.file)\n\t\tfile->pathname[0] = '\\0';\n\telse if ((ptr = file_path(mddev->bitmap_info.file,\n\t\t\t       file->pathname, sizeof(file->pathname))),\n\t\t IS_ERR(ptr))\n\t\terr = PTR_ERR(ptr);\n\telse\n\t\tmemmove(file->pathname, ptr,\n\t\t\tsizeof(file->pathname)-(ptr-file->pathname));\n\tspin_unlock(&mddev->lock);\n\tif (err == 0 &&\n\t    copy_to_user(arg, file, sizeof(*file)))\n\t\terr = -EFAULT;\n\tkfree(file);\n\treturn err;\n}", "target": 1}
{"code": "static int pfkey_get(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\t__u8 proto;\n\tstruct sk_buff *out_skb;\n\tstruct sadb_msg *out_hdr;\n\tstruct xfrm_state *x;\n\tif (!ext_hdrs[SADB_EXT_SA-1] ||\n\t    !present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC-1],\n\t\t\t\t     ext_hdrs[SADB_EXT_ADDRESS_DST-1]))\n\t\treturn -EINVAL;\n\tx = pfkey_xfrm_state_lookup(net, hdr, ext_hdrs);\n\tif (x == NULL)\n\t\treturn -ESRCH;\n\tout_skb = pfkey_xfrm_state2msg(x);\n\tproto = x->id.proto;\n\txfrm_state_put(x);\n\tif (IS_ERR(out_skb))\n\t\treturn  PTR_ERR(out_skb);\n\tout_hdr = (struct sadb_msg *) out_skb->data;\n\tout_hdr->sadb_msg_version = hdr->sadb_msg_version;\n\tout_hdr->sadb_msg_type = SADB_GET;\n\tout_hdr->sadb_msg_satype = pfkey_proto2satype(proto);\n\tout_hdr->sadb_msg_errno = 0;\n\tout_hdr->sadb_msg_reserved = 0;\n\tout_hdr->sadb_msg_seq = hdr->sadb_msg_seq;\n\tout_hdr->sadb_msg_pid = hdr->sadb_msg_pid;\n\tpfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_ONE, sk, sock_net(sk));\n\treturn 0;\n}", "target": 0}
{"code": "static int curl_fnmatch(void *ctx, const char *pattern, const char *string)\n{\n\tphp_curl *ch = (php_curl *) ctx;\n\tphp_curl_fnmatch *t = ch->handlers->fnmatch;\n\tint rval = CURL_FNMATCHFUNC_FAIL;\n\tswitch (t->method) {\n\t\tcase PHP_CURL_USER: {\n\t\t\tzval argv[3];\n\t\t\tzval retval;\n\t\t\tint  error;\n\t\t\tzend_fcall_info fci;\n\t\t\tZVAL_RES(&argv[0], ch->res);\n\t\t\tZ_ADDREF(argv[0]);\n\t\t\tZVAL_STRING(&argv[1], pattern);\n\t\t\tZVAL_STRING(&argv[2], string);\n\t\t\tfci.size = sizeof(fci);\n\t\t\tfci.function_table = EG(function_table);\n\t\t\tZVAL_COPY_VALUE(&fci.function_name, &t->func_name);\n\t\t\tfci.object = NULL;\n\t\t\tfci.retval = &retval;\n\t\t\tfci.param_count = 3;\n\t\t\tfci.params = argv;\n\t\t\tfci.no_separation = 0;\n\t\t\tfci.symbol_table = NULL;\n\t\t\tch->in_callback = 1;\n\t\t\terror = zend_call_function(&fci, &t->fci_cache);\n\t\t\tch->in_callback = 0;\n\t\t\tif (error == FAILURE) {\n\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Cannot call the CURLOPT_FNMATCH_FUNCTION\");\n\t\t\t} else if (!Z_ISUNDEF(retval)) {\n\t\t\t\tif (Z_TYPE(retval) != IS_LONG) {\n\t\t\t\t\tconvert_to_long_ex(&retval);\n\t\t\t\t}\n\t\t\t\trval = Z_LVAL(retval);\n\t\t\t}\n\t\t\tzval_ptr_dtor(&argv[0]);\n\t\t\tzval_ptr_dtor(&argv[1]);\n\t\t\tzval_ptr_dtor(&argv[2]);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn rval;\n}", "target": 0}
{"code": "static int proc_uptime_read(char *buf, size_t size, off_t offset,\n\t\tstruct fuse_file_info *fi)\n{\n\tstruct fuse_context *fc = fuse_get_context();\n\tstruct file_info *d = (struct file_info *)fi->fh;\n\tlong int reaperage = getreaperage(fc->pid);;\n\tunsigned long int busytime = get_reaper_busy(fc->pid), idletime;\n\tchar *cache = d->buf;\n\tsize_t total_len = 0;\n\tif (offset){\n\t\tif (offset > d->size)\n\t\t\treturn -EINVAL;\n\t\tif (!d->cached)\n\t\t\treturn 0;\n\t\tint left = d->size - offset;\n\t\ttotal_len = left > size ? size: left;\n\t\tmemcpy(buf, cache + offset, total_len);\n\t\treturn total_len;\n\t}\n\tidletime = reaperage - busytime;\n\tif (idletime > reaperage)\n\t\tidletime = reaperage;\n\ttotal_len = snprintf(d->buf, d->size, \"%ld.0 %lu.0\\n\", reaperage, idletime);\n\tif (total_len < 0){\n\t\tperror(\"Error writing to cache\");\n\t\treturn 0;\n\t}\n\td->size = (int)total_len;\n\td->cached = 1;\n\tif (total_len > size) total_len = size;\n\tmemcpy(buf, d->buf, total_len);\n\treturn total_len;\n}", "target": 0}
{"code": "libxlDomainDefNamespaceParse(xmlXPathContextPtr ctxt,\n                             void **data)\n{\n    libxlDomainXmlNsDef *nsdata = NULL;\n    g_autofree xmlNodePtr *nodes = NULL;\n    ssize_t nnodes;\n    size_t i;\n    int ret = -1;\n    if ((nnodes = virXPathNodeSet(\"./xen:commandline/xen:arg\", ctxt, &nodes)) < 0)\n        return -1;\n    if (nnodes == 0)\n        return 0;\n    nsdata = g_new0(libxlDomainXmlNsDef, 1);\n    nsdata->args = g_new0(char *, nnodes + 1);\n    for (i = 0; i < nnodes; i++) {\n        if (!(nsdata->args[nsdata->num_args++] = virXMLPropString(nodes[i], \"value\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"No device model command-line argument specified\"));\n            goto cleanup;\n        }\n    }\n    *data = g_steal_pointer(&nsdata);\n    ret = 0;\n cleanup:\n    libxlDomainDefNamespaceFree(nsdata);\n    return ret;\n}", "target": 0}
{"code": "read_response_line(smtp_inblock *inblock, uschar *buffer, int size, int timeout)\n{\nuschar *p = buffer;\nuschar *ptr = inblock->ptr;\nuschar *ptrend = inblock->ptrend;\nclient_conn_ctx * cctx = inblock->cctx;\nfor (;;)\n  {\n  int rc;\n  while (ptr < ptrend)\n    {\n    int c = *ptr++;\n    if (c == '\\n')\n      {\n      while (p > buffer && isspace(p[-1])) p--;\n      *p = 0;\n      inblock->ptr = ptr;\n      return p - buffer;\n      }\n    *p++ = c;\n    if (--size < 4)\n      {\n      *p = 0;                     \n      errno = ERRNO_SMTPFORMAT;\n      return -1;\n      }\n    }\n  if((rc = ip_recv(cctx, inblock->buffer, inblock->buffersize, timeout)) <= 0)\n    {\n    DEBUG(D_deliver|D_transport|D_acl)\n      debug_printf_indent(errno ? \"  SMTP(%s)<<\\n\" : \"  SMTP(closed)<<\\n\",\n\tstrerror(errno));\n    break;\n    }\n  ptrend = inblock->ptrend = inblock->buffer + rc;\n  ptr = inblock->buffer;\n  DEBUG(D_transport|D_acl) debug_printf_indent(\"read response data: size=%d\\n\", rc);\n  }\n*buffer = 0;\nreturn -1;\n}", "target": 0}
{"code": "static void rm_read_metadata(AVFormatContext *s, AVIOContext *pb, int wide)\n{\n    char buf[1024];\n    int i;\n    for (i=0; i<FF_ARRAY_ELEMS(ff_rm_metadata); i++) {\n        int len = wide ? avio_rb16(pb) : avio_r8(pb);\n        get_strl(pb, buf, sizeof(buf), len);\n        av_dict_set(&s->metadata, ff_rm_metadata[i], buf, 0);\n    }\n}", "target": 0}
{"code": "static void phys_map_node_reserve(PhysPageMap *map, unsigned nodes)\n{\n    if (map->nodes_nb + nodes > map->nodes_nb_alloc) {\n        map->nodes_nb_alloc = MAX(map->nodes_nb_alloc * 2, 16);\n        map->nodes_nb_alloc = MAX(map->nodes_nb_alloc, map->nodes_nb + nodes);\n        map->nodes = g_renew(Node, map->nodes, map->nodes_nb_alloc);\n    }\n}", "target": 0}
{"code": "    void CFontFileType1::DecryptEexec(unsigned char** ppEexecBuffer, int nLen)\n    {\n        unsigned char *sCur = (unsigned char*)(*ppEexecBuffer);\n        while( sCur < (unsigned char*)(*ppEexecBuffer) + nLen && ( ' ' == *sCur || '\\t' == *sCur || '\\r' == *sCur || '\\n' == *sCur ) )\n            ++sCur;\n        bool bASCII = false;\n        if ( isxdigit( sCur[0] ) && isxdigit( sCur[1] ) && isxdigit( sCur[2] ) && isxdigit( sCur[3] ) )\n            bASCII = true;\n        if ( bASCII )\n            ASCIIHexDecode( &sCur, sCur + nLen, sCur, nLen );\n        unsigned short ushKey = 55665U;\n        EexecDecode( &sCur, *ppEexecBuffer + nLen, sCur, nLen, &ushKey );\n    }", "target": 1}
{"code": "static void __skb_complete_tx_timestamp(struct sk_buff *skb,\n\t\t\t\t\tstruct sock *sk,\n\t\t\t\t\tint tstype)\n{\n\tstruct sock_exterr_skb *serr;\n\tint err;\n\tserr = SKB_EXT_ERR(skb);\n\tmemset(serr, 0, sizeof(*serr));\n\tserr->ee.ee_errno = ENOMSG;\n\tserr->ee.ee_origin = SO_EE_ORIGIN_TIMESTAMPING;\n\tserr->ee.ee_info = tstype;\n\tif (sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID) {\n\t\tserr->ee.ee_data = skb_shinfo(skb)->tskey;\n\t\tif (sk->sk_protocol == IPPROTO_TCP &&\n\t\t    sk->sk_type == SOCK_STREAM)\n\t\t\tserr->ee.ee_data -= sk->sk_tskey;\n\t}\n\terr = sock_queue_err_skb(sk, skb);\n\tif (err)\n\t\tkfree_skb(skb);", "target": 1}
{"code": "  Definition_Obj Parser::parse_definition(Definition::Type which_type)\n  {\n    std::string which_str(lexed);\n    if (!lex< identifier >()) error(\"invalid name in \" + which_str + \" definition\");\n    std::string name(Util::normalize_underscores(lexed));\n    if (which_type == Definition::FUNCTION && (name == \"and\" || name == \"or\" || name == \"not\"))\n    { error(\"Invalid function name \\\"\" + name + \"\\\".\"); }\n    ParserState source_position_of_def = pstate;\n    Parameters_Obj params = parse_parameters();\n    if (which_type == Definition::MIXIN) stack.push_back(Scope::Mixin);\n    else stack.push_back(Scope::Function);\n    Block_Obj body = parse_block();\n    stack.pop_back();\n    return SASS_MEMORY_NEW(Definition, source_position_of_def, name, params, body, which_type);\n  }", "target": 0}
{"code": "void usb_ep_combine_input_packets(USBEndpoint *ep)\n{\n    USBPacket *p, *u, *next, *prev = NULL, *first = NULL;\n    USBPort *port = ep->dev->port;\n    int totalsize;\n    assert(ep->pipeline);\n    assert(ep->pid == USB_TOKEN_IN);\n    QTAILQ_FOREACH_SAFE(p, &ep->queue, queue, next) {\n        if (ep->halted) {\n            p->status = USB_RET_REMOVE_FROM_QUEUE;\n            port->ops->complete(port, p);\n            continue;\n        }\n        if (p->state == USB_PACKET_ASYNC) {\n            prev = p;\n            continue;\n        }\n        usb_packet_check_state(p, USB_PACKET_QUEUED);\n        if (prev && prev->short_not_ok) {\n            break;\n        }\n        if (first) {\n            if (first->combined == NULL) {\n                USBCombinedPacket *combined = g_new0(USBCombinedPacket, 1);\n                combined->first = first;\n                QTAILQ_INIT(&combined->packets);\n                qemu_iovec_init(&combined->iov, 2);\n                usb_combined_packet_add(combined, first);\n            }\n            usb_combined_packet_add(first->combined, p);\n        } else {\n            first = p;\n        }\n        totalsize = (p->combined) ? p->combined->iov.size : p->iov.size;\n        if ((p->iov.size % ep->max_packet_size) != 0 || !p->short_not_ok ||\n                next == NULL ||\n                (totalsize == (16 * KiB - 36) && p->int_req)) {\n            usb_device_handle_data(ep->dev, first);\n            assert(first->status == USB_RET_ASYNC);\n            if (first->combined) {\n                QTAILQ_FOREACH(u, &first->combined->packets, combined_entry) {\n                    usb_packet_set_state(u, USB_PACKET_ASYNC);\n                }\n            } else {\n                usb_packet_set_state(first, USB_PACKET_ASYNC);\n            }\n            first = NULL;\n            prev = p;\n        }\n    }\n}", "target": 1}
{"code": "  Mixin_Call_Obj Parser::parse_include_directive()\n  {\n    lex_identifier(); \n    std::string name(Util::normalize_underscores(lexed));\n    Mixin_Call_Obj call = SASS_MEMORY_NEW(Mixin_Call, pstate, name, {}, {}, {});\n    call->arguments(parse_arguments());\n    bool has_parameters = lex< kwd_using >() != nullptr;\n    if (has_parameters) {\n      if (!peek< exactly<'('> >()) css_error(\"Invalid CSS\", \" after \", \": expected \\\"(\\\", was \");\n    } else {\n      if (peek< exactly<'('> >()) css_error(\"Invalid CSS\", \" after \", \": expected \\\";\\\", was \");\n    }\n    if (has_parameters) call->block_parameters(parse_parameters());\n    if (peek < exactly <'{'> >()) {\n      call->block(parse_block());\n    }\n    else if (has_parameters)  {\n      css_error(\"Invalid CSS\", \" after \", \": expected \\\"{\\\", was \");\n    }\n    return call.detach();\n  }", "target": 0}
{"code": "exif_data_load_data_thumbnail (ExifData *data, const unsigned char *d,\n\t\t\t       unsigned int ds, ExifLong o, ExifLong s)\n{\n\tif (o >= ds) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\", \"Bogus thumbnail offset (%u).\", o);\n\t\treturn;\n\t}\n\tif (s > ds - o) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\", \"Bogus thumbnail size (%u), max would be %u.\", s, ds-o);\n\t\treturn;\n\t}\n\tif (data->data) \n\t\texif_mem_free (data->priv->mem, data->data);\n\tif (!(data->data = exif_data_alloc (data, s))) {\n\t\tEXIF_LOG_NO_MEMORY (data->priv->log, \"ExifData\", s);\n\t\tdata->size = 0;\n\t\treturn;\n\t}\n\tdata->size = s;\n\tmemcpy (data->data, d + o, s);\n}", "target": 1}
{"code": "asmlinkage long compat_sys_ppoll(struct pollfd __user *ufds,\n\tunsigned int nfds, struct compat_timespec __user *tsp,\n\tconst compat_sigset_t __user *sigmask, compat_size_t sigsetsize)\n{\n\tcompat_sigset_t ss32;\n\tsigset_t ksigmask, sigsaved;\n\tstruct compat_timespec ts;\n\ts64 timeout = -1;\n\tint ret;\n\tif (tsp) {\n\t\tif (copy_from_user(&ts, tsp, sizeof(ts)))\n\t\t\treturn -EFAULT;\n\t\ttimeout = ROUND_UP(ts.tv_nsec, 1000000000/HZ);\n\t\ttimeout += ts.tv_sec * HZ;\n\t}\n\tif (sigmask) {\n\t\tif (sigsetsize != sizeof(compat_sigset_t))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&ss32, sigmask, sizeof(ss32)))\n\t\t\treturn -EFAULT;\n\t\tsigset_from_compat(&ksigmask, &ss32);\n\t\tsigdelsetmask(&ksigmask, sigmask(SIGKILL)|sigmask(SIGSTOP));\n\t\tsigprocmask(SIG_SETMASK, &ksigmask, &sigsaved);\n\t}\n\tret = do_sys_poll(ufds, nfds, &timeout);\n\tif (ret == -EINTR) {\n\t\tif (sigmask) {\n\t\t\tmemcpy(&current->saved_sigmask, &sigsaved,\n\t\t\t\tsizeof(sigsaved));\n\t\t\tset_thread_flag(TIF_RESTORE_SIGMASK);\n\t\t}\n\t\tret = -ERESTARTNOHAND;\n\t} else if (sigmask)\n\t\tsigprocmask(SIG_SETMASK, &sigsaved, NULL);\n\tif (tsp && timeout >= 0) {\n\t\tstruct compat_timespec rts;\n\t\tif (current->personality & STICKY_TIMEOUTS)\n\t\t\tgoto sticky;\n\t\trts.tv_nsec = jiffies_to_usecs(do_div((*(u64*)&timeout), HZ)) *\n\t\t\t\t\t1000;\n\t\trts.tv_sec = timeout;\n\t\tif (compat_timespec_compare(&rts, &ts) >= 0)\n\t\t\trts = ts;\n\t\tif (copy_to_user(tsp, &rts, sizeof(rts))) {\nsticky:\n\t\t\tif (ret == -ERESTARTNOHAND && timeout >= 0)\n\t\t\t\tret = -EINTR;\n\t\t}\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "static int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_cdef_t *cdef = &box->data.cdef;\n\tjp2_cdefchan_t *chan;\n\tunsigned int channo;\n\tcdef->ents = 0;\n\tif (jp2_getuint16(in, &cdef->numchans)) {\n\t\treturn -1;\n\t}\n\tif (!(cdef->ents = jas_alloc2(cdef->numchans, sizeof(jp2_cdefchan_t)))) {\n\t\treturn -1;\n\t}\n\tfor (channo = 0; channo < cdef->numchans; ++channo) {\n\t\tchan = &cdef->ents[channo];\n\t\tif (jp2_getuint16(in, &chan->channo) || jp2_getuint16(in, &chan->type) ||\n\t\t  jp2_getuint16(in, &chan->assoc)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static struct socket *get_raw_socket(int fd)\n{\n\tstruct {\n\t\tstruct sockaddr_ll sa;\n\t\tchar  buf[MAX_ADDR_LEN];\n\t} uaddr;\n\tint r;\n\tstruct socket *sock = sockfd_lookup(fd, &r);\n\tif (!sock)\n\t\treturn ERR_PTR(-ENOTSOCK);\n\tif (sock->sk->sk_type != SOCK_RAW) {\n\t\tr = -ESOCKTNOSUPPORT;\n\t\tgoto err;\n\t}\n\tr = sock->ops->getname(sock, (struct sockaddr *)&uaddr.sa, 0);\n\tif (r < 0)\n\t\tgoto err;\n\tif (uaddr.sa.sll_family != AF_PACKET) {\n\t\tr = -EPFNOSUPPORT;\n\t\tgoto err;\n\t}\n\treturn sock;\nerr:\n\tsockfd_put(sock);\n\treturn ERR_PTR(r);\n}", "target": 1}
{"code": "static int rxrpc_preparse_s(struct key_preparsed_payload *prep)\n{\n\tstruct crypto_blkcipher *ci;\n\t_enter(\"%zu\", prep->datalen);\n\tif (prep->datalen != 8)\n\t\treturn -EINVAL;\n\tmemcpy(&prep->type_data, prep->data, 8);\n\tci = crypto_alloc_blkcipher(\"pcbc(des)\", 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(ci)) {\n\t\t_leave(\" = %ld\", PTR_ERR(ci));\n\t\treturn PTR_ERR(ci);\n\t}\n\tif (crypto_blkcipher_setkey(ci, prep->data, 8) < 0)\n\t\tBUG();\n\tprep->payload[0] = ci;\n\t_leave(\" = 0\");\n\treturn 0;\n}", "target": 0}
{"code": "void __init files_init(unsigned long mempages)\n{ \n\tunsigned long n;\n\tfilp_cachep = kmem_cache_create(\"filp\", sizeof(struct file), 0,\n\t\t\tSLAB_HWCACHE_ALIGN | SLAB_PANIC, NULL);\n\tn = (mempages * (PAGE_SIZE / 1024)) / 10;\n\tfiles_stat.max_files = max_t(unsigned long, n, NR_FILE);\n\tfiles_defer_init();\n\tlg_lock_init(&files_lglock, \"files_lglock\");\n\tpercpu_counter_init(&nr_files, 0);\n} ", "target": 1}
{"code": "\tEventReturn OnPreCommand(CommandSource &source, Command *command, std::vector<Anope::string> &params) anope_override\n\t{\n\t\tif (command->name == \"nickserv/confirm\" && params.size() > 1)\n\t\t{\n\t\t\tif (Anope::ReadOnly)\n\t\t\t{\n\t\t\t\tsource.Reply(READ_ONLY_MODE);\n\t\t\t\treturn EVENT_STOP;\n\t\t\t}\n\t\t\tNickAlias *na = NickAlias::Find(params[0]);\n\t\t\tResetInfo *ri = na ? reset.Get(na->nc) : NULL;\n\t\t\tif (na && ri)\n\t\t\t{\n\t\t\t\tNickCore *nc = na->nc;\n\t\t\t\tif (nc->HasExt(\"NS_SUSPENDED\"))\n\t\t\t\t{\n\t\t\t\t\tsource.Reply(NICK_X_SUSPENDED, nc->display.c_str());\n\t\t\t\t\treturn EVENT_STOP;\n\t\t\t\t}\n\t\t\t\tconst Anope::string &passcode = params[1];\n\t\t\t\tif (ri->time < Anope::CurTime - 3600)\n\t\t\t\t{\n\t\t\t\t\treset.Unset(nc);\n\t\t\t\t\tsource.Reply(_(\"Your password reset request has expired.\"));\n\t\t\t\t}\n\t\t\t\telse if (passcode.equals_cs(ri->code))\n\t\t\t\t{\n\t\t\t\t\treset.Unset(nc);\n\t\t\t\t\tnc->Shrink<bool>(\"UNCONFIRMED\");\n\t\t\t\t\tLog(LOG_COMMAND, source, &commandnsresetpass) << \"to confirm RESETPASS and forcefully identify as \" << na->nick;\n\t\t\t\t\tif (source.GetUser())\n\t\t\t\t\t{\n\t\t\t\t\t\tsource.GetUser()->Identify(na);\n\t\t\t\t\t}\n\t\t\t\t\tsource.Reply(_(\"You are now identified for your nick. Change your password now.\"));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\treturn EVENT_CONTINUE;\n\t\t\t\treturn EVENT_STOP;\n\t\t\t}\n\t\t}\n\t\treturn EVENT_CONTINUE;\n\t}", "target": 0}
{"code": "static BOOL ntlm_av_pair_check(NTLM_AV_PAIR* pAvPair, size_t cbAvPair)\n{\n\tif (!pAvPair || cbAvPair < sizeof(NTLM_AV_PAIR))\n\t\treturn FALSE;\n\treturn cbAvPair >= ntlm_av_pair_get_next_offset(pAvPair);\n}", "target": 1}
{"code": "static struct tipc_node *tipc_node_find_by_id(struct net *net, u8 *id)\n{\n\tstruct tipc_net *tn = tipc_net(net);\n\tstruct tipc_node *n;\n\tbool found = false;\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(n, &tn->node_list, list) {\n\t\tread_lock_bh(&n->lock);\n\t\tif (!memcmp(id, n->peer_id, 16) &&\n\t\t    kref_get_unless_zero(&n->kref))\n\t\t\tfound = true;\n\t\tread_unlock_bh(&n->lock);\n\t\tif (found)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\treturn found ? n : NULL;\n}", "target": 0}
{"code": "git_otype git_tree_entry_type(const git_tree_entry *entry)\n{\n\tassert(entry);\n\tif (S_ISGITLINK(entry->attr))\n\t\treturn GIT_OBJ_COMMIT;\n\telse if (S_ISDIR(entry->attr))\n\t\treturn GIT_OBJ_TREE;\n\telse\n\t\treturn GIT_OBJ_BLOB;\n}", "target": 0}
{"code": "int kvm_emulate_hypercall(struct kvm_vcpu *vcpu)\n{\n\tunsigned long nr, a0, a1, a2, a3, ret;\n\tint r = 1;\n\tif (kvm_hv_hypercall_enabled(vcpu->kvm))\n\t\treturn kvm_hv_hypercall(vcpu);\n\tnr = kvm_register_read(vcpu, VCPU_REGS_RAX);\n\ta0 = kvm_register_read(vcpu, VCPU_REGS_RBX);\n\ta1 = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\ta2 = kvm_register_read(vcpu, VCPU_REGS_RDX);\n\ta3 = kvm_register_read(vcpu, VCPU_REGS_RSI);\n\ttrace_kvm_hypercall(nr, a0, a1, a2, a3);\n\tif (!is_long_mode(vcpu)) {\n\t\tnr &= 0xFFFFFFFF;\n\t\ta0 &= 0xFFFFFFFF;\n\t\ta1 &= 0xFFFFFFFF;\n\t\ta2 &= 0xFFFFFFFF;\n\t\ta3 &= 0xFFFFFFFF;\n\t}\n\tif (kvm_x86_ops->get_cpl(vcpu) != 0) {\n\t\tret = -KVM_EPERM;\n\t\tgoto out;\n\t}\n\tswitch (nr) {\n\tcase KVM_HC_VAPIC_POLL_IRQ:\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -KVM_ENOSYS;\n\t\tbreak;\n\t}\nout:\n\tkvm_register_write(vcpu, VCPU_REGS_RAX, ret);\n\t++vcpu->stat.hypercalls;\n\treturn r;\n}", "target": 0}
{"code": "void recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h, *g;\n\tunsigned int i;\n\tvmcb_mark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\tc = &svm->vmcb->control;\n\th = &svm->vmcb01.ptr->control;\n\tg = &svm->nested.ctl;\n\tfor (i = 0; i < MAX_INTERCEPT; i++)\n\t\tc->intercepts[i] = h->intercepts[i];\n\tif (g->int_ctl & V_INTR_MASKING_MASK) {\n\t\tvmcb_clr_intercept(c, INTERCEPT_CR8_READ);\n\t\tvmcb_clr_intercept(c, INTERCEPT_CR8_WRITE);\n\t\tvmcb_clr_intercept(c, INTERCEPT_VINTR);\n\t}\n\tvmcb_clr_intercept(c, INTERCEPT_VMMCALL);\n\tfor (i = 0; i < MAX_INTERCEPT; i++)\n\t\tc->intercepts[i] |= g->intercepts[i];\n\tif (!intercept_smi)\n\t\tvmcb_clr_intercept(c, INTERCEPT_SMI);\n\tvmcb_set_intercept(c, INTERCEPT_VMLOAD);\n\tvmcb_set_intercept(c, INTERCEPT_VMSAVE);\n}", "target": 0}
{"code": "static int pcan_usb_pro_drv_loaded(struct peak_usb_device *dev, int loaded)\n{\n\tu8 *buffer;\n\tint err;\n\tbuffer = kmalloc(PCAN_USBPRO_FCT_DRVLD_REQ_LEN, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\tbuffer[0] = 0;\n\tbuffer[1] = !!loaded;\n\terr = pcan_usb_pro_send_req(dev, PCAN_USBPRO_REQ_FCT,\n\t\t\t\t    PCAN_USBPRO_FCT_DRVLD, buffer,\n\t\t\t\t    PCAN_USBPRO_FCT_DRVLD_REQ_LEN);\n\tkfree(buffer);\n\treturn err;\n}", "target": 1}
{"code": "void html_link_open(char *url, char *title, char *class)\n{\n\thtml(\"<a href='\");\n\thtml_attr(url);\n\tif (title) {\n\t\thtml(\"' title='\");\n\t\thtml_attr(title);\n\t}\n\tif (class) {\n\t\thtml(\"' class='\");\n\t\thtml_attr(class);\n\t}\n\thtml(\"'>\");\n}", "target": 0}
{"code": "bgp_capability_receive (struct peer *peer, bgp_size_t size)\n{\n  u_char *pnt;\n  int ret;\n  pnt = stream_pnt (peer->ibuf);\n  if (BGP_DEBUG (normal, NORMAL))\n    zlog_debug (\"%s rcv CAPABILITY\", peer->host);\n  if (! CHECK_FLAG (peer->cap, PEER_CAP_DYNAMIC_ADV))\n    {\n      plog_err (peer->log, \"%s [Error] BGP dynamic capability is not enabled\",\n\t\tpeer->host);\n      bgp_notify_send (peer,\n\t\t       BGP_NOTIFY_HEADER_ERR,\n\t\t       BGP_NOTIFY_HEADER_BAD_MESTYPE);\n      return;\n    }\n  if (peer->status != Established)\n    {\n      plog_err (peer->log,\n\t\t\"%s [Error] Dynamic capability packet received under status %s\", peer->host, LOOKUP (bgp_status_msg, peer->status));\n      bgp_notify_send (peer, BGP_NOTIFY_FSM_ERR, 0);\n      return;\n    }\n  ret = bgp_capability_msg_parse (peer, pnt, size);\n}", "target": 1}
{"code": "isdn_net_getphones(isdn_net_ioctl_phone *phone, char __user *phones)\n{\n\tisdn_net_dev *p = isdn_net_findif(phone->name);\n\tint inout = phone->outgoing & 1;\n\tint more = 0;\n\tint count = 0;\n\tisdn_net_phone *n;\n\tif (!p)\n\t\treturn -ENODEV;\n\tinout &= 1;\n\tfor (n = p->local->phone[inout]; n; n = n->next) {\n\t\tif (more) {\n\t\t\tput_user(' ', phones++);\n\t\t\tcount++;\n\t\t}\n\t\tif (copy_to_user(phones, n->num, strlen(n->num) + 1)) {\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tphones += strlen(n->num);\n\t\tcount += strlen(n->num);\n\t\tmore = 1;\n\t}\n\tput_user(0, phones);\n\tcount++;\n\treturn count;\n}", "target": 0}
{"code": "static int apparmor_setprocattr(struct task_struct *task, char *name,\n\t\t\t\tvoid *value, size_t size)\n {\n \tstruct common_audit_data sa;\n \tstruct apparmor_audit_data aad = {0,};\n\tchar *command, *args = value;\n \tsize_t arg_size;\n \tint error;\n \tif (size == 0)\n \t\treturn -EINVAL;\n\tif (args[size - 1] != '\\0') {\n\t\tif (size == PAGE_SIZE)\n\t\t\treturn -EINVAL;\n\t\targs[size] = '\\0';\n\t}\n \tif (current != task)\n \t\treturn -EACCES;\n\targs = value;\n \targs = strim(args);\n \tcommand = strsep(&args, \" \");\n \tif (!args)\n\t\treturn -EINVAL;\n \targs = skip_spaces(args);\n \tif (!*args)\n\t\treturn -EINVAL;\n \targ_size = size - (args - (char *) value);\n \tif (strcmp(name, \"current\") == 0) {\n\t\tif (strcmp(command, \"changehat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permhat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t AA_DO_TEST);\n\t\t} else if (strcmp(command, \"changeprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     AA_DO_TEST);\n\t\t} else\n\t\t\tgoto fail;\n\t} else if (strcmp(name, \"exec\") == 0) {\n\t\tif (strcmp(command, \"exec\") == 0)\n\t\t\terror = aa_setprocattr_changeprofile(args, AA_ONEXEC,\n\t\t\t\t\t\t\t     !AA_DO_TEST);\n\t\telse\n \t\t\tgoto fail;\n \t} else\n\t\treturn -EINVAL;\n \tif (!error)\n \t\terror = size;\n \treturn error;\n fail:\n\tsa.type = LSM_AUDIT_DATA_NONE;\n\tsa.aad = &aad;\n \taad.profile = aa_current_profile();\n \taad.op = OP_SETPROCATTR;\n \taad.info = name;\n\taad.error = -EINVAL;\n \taa_audit_msg(AUDIT_APPARMOR_DENIED, &sa, NULL);\n\treturn -EINVAL;\n }", "target": 1}
{"code": "void Splash::pipeRunAAMono8(SplashPipe *pipe) {\n  Guchar aSrc, aDest, alpha2, aResult;\n  SplashColor cDest;\n  Guchar cResult0;\n  cDest[0] = *pipe->destColorPtr;\n  aDest = *pipe->destAlphaPtr;\n  aSrc = div255(pipe->aInput * pipe->shape);\n  aResult = aSrc + aDest - div255(aSrc * aDest);\n  alpha2 = aResult;\n  if (alpha2 == 0) {\n    cResult0 = 0;\n  } else {\n    cResult0 = state->grayTransfer[(Guchar)(((alpha2 - aSrc) * cDest[0] +\n\t\t\t\t\t     aSrc * pipe->cSrc[0]) / alpha2)];\n  }\n  *pipe->destColorPtr++ = cResult0;\n  *pipe->destAlphaPtr++ = aResult;\n  ++pipe->x;\n}", "target": 0}
{"code": "static const char *kernel_type_name(const struct btf* btf, u32 id)\n{\n\treturn btf_name_by_offset(btf, btf_type_by_id(btf, id)->name_off);\n}", "target": 0}
{"code": "struct sock *ax25_get_socket(ax25_address *my_addr, ax25_address *dest_addr,\n\tint type)\n{\n\tstruct sock *sk = NULL;\n\tax25_cb *s;\n\tspin_lock(&ax25_list_lock);\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->sk && !ax25cmp(&s->source_addr, my_addr) &&\n\t\t    !ax25cmp(&s->dest_addr, dest_addr) &&\n\t\t    s->sk->sk_type == type) {\n\t\t\tsk = s->sk;\n\t\t\tsock_hold(sk);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&ax25_list_lock);\n\treturn sk;\n}", "target": 0}
{"code": "void sock_init_data(struct socket *sock, struct sock *sk)\n{\n\tskb_queue_head_init(&sk->sk_receive_queue);\n\tskb_queue_head_init(&sk->sk_write_queue);\n\tskb_queue_head_init(&sk->sk_error_queue);\n#ifdef CONFIG_NET_DMA\n\tskb_queue_head_init(&sk->sk_async_wait_queue);\n#endif\n\tsk->sk_send_head\t=\tNULL;\n\tinit_timer(&sk->sk_timer);\n\tsk->sk_allocation\t=\tGFP_KERNEL;\n\tsk->sk_rcvbuf\t\t=\tsysctl_rmem_default;\n\tsk->sk_sndbuf\t\t=\tsysctl_wmem_default;\n\tsk->sk_state\t\t=\tTCP_CLOSE;\n\tsk_set_socket(sk, sock);\n\tsock_set_flag(sk, SOCK_ZAPPED);\n\tif (sock) {\n\t\tsk->sk_type\t=\tsock->type;\n\t\tsk->sk_wq\t=\tsock->wq;\n\t\tsock->sk\t=\tsk;\n\t} else\n\t\tsk->sk_wq\t=\tNULL;\n\tspin_lock_init(&sk->sk_dst_lock);\n\trwlock_init(&sk->sk_callback_lock);\n\tlockdep_set_class_and_name(&sk->sk_callback_lock,\n\t\t\taf_callback_keys + sk->sk_family,\n\t\t\taf_family_clock_key_strings[sk->sk_family]);\n\tsk->sk_state_change\t=\tsock_def_wakeup;\n\tsk->sk_data_ready\t=\tsock_def_readable;\n\tsk->sk_write_space\t=\tsock_def_write_space;\n\tsk->sk_error_report\t=\tsock_def_error_report;\n\tsk->sk_destruct\t\t=\tsock_def_destruct;\n\tsk->sk_sndmsg_page\t=\tNULL;\n\tsk->sk_sndmsg_off\t=\t0;\n\tsk->sk_peek_off\t\t=\t-1;\n\tsk->sk_peer_pid \t=\tNULL;\n\tsk->sk_peer_cred\t=\tNULL;\n\tsk->sk_write_pending\t=\t0;\n\tsk->sk_rcvlowat\t\t=\t1;\n\tsk->sk_rcvtimeo\t\t=\tMAX_SCHEDULE_TIMEOUT;\n\tsk->sk_sndtimeo\t\t=\tMAX_SCHEDULE_TIMEOUT;\n\tsk->sk_stamp = ktime_set(-1L, 0);\n\tsmp_wmb();\n\tatomic_set(&sk->sk_refcnt, 1);\n\tatomic_set(&sk->sk_drops, 0);\n}", "target": 0}
{"code": "Status ValidateInputs(const Tensor *a_indices, const Tensor *a_values,\n                      const Tensor *a_shape, const Tensor *b) {\n  if (!TensorShapeUtils::IsMatrix(a_indices->shape())) {\n    return errors::InvalidArgument(\n        \"Input a_indices should be a matrix but received shape: \",\n        a_indices->shape().DebugString());\n  }\n  if (!TensorShapeUtils::IsVector(a_values->shape()) ||\n      !TensorShapeUtils::IsVector(a_shape->shape())) {\n    return errors::InvalidArgument(\n        \"Inputs a_values and a_shape should be vectors \"\n        \"but received shapes: \",\n        a_values->shape().DebugString(), \" and \",\n        a_shape->shape().DebugString());\n  }\n  int64_t nnz = a_indices->dim_size(0);\n  int64_t ndims = a_indices->dim_size(1);\n  if (a_values->dim_size(0) != nnz) {\n    return errors::InvalidArgument(\"Dimensions \", nnz, \" and \",\n                                   a_values->dim_size(0),\n                                   \" are not compatible\");\n  }\n  if (a_shape->dim_size(0) != ndims) {\n    return errors::InvalidArgument(\"Dimensions \", ndims, \" and \",\n                                   a_shape->dim_size(0), \" are not compatible\");\n  }\n  if (a_shape->NumElements() != b->dims()) {\n    return errors::InvalidArgument(\n        \"Two operands have different ranks; received: \", a_shape->NumElements(),\n        \" and \", b->dims());\n  }\n  const auto a_shape_flat = a_shape->flat<Index>();\n  for (int i = 0; i < b->dims(); ++i) {\n    if (a_shape_flat(i) != b->dim_size(i)) {\n      return errors::InvalidArgument(\n          \"Dimension \", i,\n          \" does not equal (no broadcasting is supported): sparse side \",\n          a_shape_flat(i), \" vs dense side \", b->dim_size(i));\n    }\n  }\n  const auto a_indices_mat = a_indices->flat_inner_dims<Index>();\n  for (int64_t zidx = 0; zidx < nnz; ++zidx) {\n    for (int64_t didx = 0; didx < ndims; ++didx) {\n      const Index idx = a_indices_mat(zidx, didx);\n      if (idx < 0 || idx >= a_shape_flat(didx)) {\n        return errors::InvalidArgument(\n            \"Sparse tensor has an invalid index on dimension \", didx,\n            \": \"\n            \"a_indices(\",\n            zidx, \",\", didx, \") = \", idx,\n            \", dense tensor shape: \", a_shape_flat);\n      }\n    }\n  }\n  return Status::OK();\n}", "target": 0}
{"code": "bool ping_rcv(struct sk_buff *skb)\n{\n\tstruct sock *sk;\n\tstruct net *net = dev_net(skb->dev);\n\tstruct icmphdr *icmph = icmp_hdr(skb);\n\tpr_debug(\"ping_rcv(skb=%p,id=%04x,seq=%04x)\\n\",\n\t\t skb, ntohs(icmph->un.echo.id), ntohs(icmph->un.echo.sequence));\n\tskb_push(skb, skb->data - (u8 *)icmph);\n\tsk = ping_lookup(net, skb, ntohs(icmph->un.echo.id));\n\tif (sk) {\n\t\tstruct sk_buff *skb2 = skb_clone(skb, GFP_ATOMIC);\n\t\tpr_debug(\"rcv on socket %p\\n\", sk);\n\t\tif (skb2)\n\t\t\tping_queue_rcv_skb(sk, skb2);\n\t\tsock_put(sk);\n\t\treturn true;\n\t}\n\tpr_debug(\"no socket, dropping\\n\");\n\treturn false;\n}", "target": 0}
{"code": "static int __udp_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)\n{\n\tint rc;\n\tif (inet_sk(sk)->inet_daddr) {\n\t\tsock_rps_save_rxhash(sk, skb);\n\t\tsk_mark_napi_id(sk, skb);\n\t\tsk_incoming_cpu_update(sk);\n\t}\n\trc = sock_queue_rcv_skb(sk, skb);\n\tif (rc < 0) {\n\t\tint is_udplite = IS_UDPLITE(sk);\n\t\tif (rc == -ENOMEM)\n\t\t\tUDP_INC_STATS_BH(sock_net(sk), UDP_MIB_RCVBUFERRORS,\n\t\t\t\t\t is_udplite);\n\t\tUDP_INC_STATS_BH(sock_net(sk), UDP_MIB_INERRORS, is_udplite);\n\t\tkfree_skb(skb);\n\t\ttrace_udp_fail_queue_rcv_skb(rc, sk);\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "ex_open(exarg_T *eap)\n{\n    regmatch_T\tregmatch;\n    char_u\t*p;\n#ifdef FEAT_EVAL\n    if (not_in_vim9(eap) == FAIL)\n\treturn;\n#endif\n    curwin->w_cursor.lnum = eap->line2;\n    beginline(BL_SOL | BL_FIX);\n    if (*eap->arg == '/')\n    {\n\t++eap->arg;\n\tp = skip_regexp(eap->arg, '/', magic_isset());\n\t*p = NUL;\n\tregmatch.regprog = vim_regcomp(eap->arg, magic_isset() ? RE_MAGIC : 0);\n\tif (regmatch.regprog != NULL)\n\t{\n\t    regmatch.rm_ic = p_ic;\n\t    p = ml_get_curline();\n\t    if (vim_regexec(&regmatch, p, (colnr_T)0))\n\t\tcurwin->w_cursor.col = (colnr_T)(regmatch.startp[0] - p);\n\t    else\n\t\temsg(_(e_nomatch));\n\t    vim_regfree(regmatch.regprog);\n\t}\n\teap->arg += STRLEN(eap->arg);\n    }\n    check_cursor();\n    eap->cmdidx = CMD_visual;\n    do_exedit(eap, NULL);\n}", "target": 1}
{"code": "static struct media_item *parse_media_folder(struct avrcp *session,\n\t\t\t\t\tuint8_t *operands, uint16_t len)\n{\n\tstruct avrcp_player *player = session->controller->player;\n\tstruct media_player *mp = player->user_data;\n\tstruct media_item *item;\n\tuint16_t namelen;\n\tchar name[255];\n\tuint64_t uid;\n\tuint8_t type;\n\tuint8_t playable;\n\tif (len < 12)\n\t\treturn NULL;\n\tuid = get_be64(&operands[0]);\n\ttype = operands[8];\n\tplayable = operands[9];\n\tnamelen = MIN(get_be16(&operands[12]), sizeof(name) - 1);\n\tif (namelen > 0) {\n\t\tmemcpy(name, &operands[14], namelen);\n\t\tname[namelen] = '\\0';\n\t}\n\titem = media_player_create_folder(mp, name, type, uid);\n\tif (!item)\n\t\treturn NULL;\n\tmedia_item_set_playable(item, playable & 0x01);\n\treturn item;\n}", "target": 0}
{"code": "static inline void fill_elf_note_phdr(struct elf_phdr *phdr, int sz, loff_t offset)\n{\n\tphdr->p_type = PT_NOTE;\n\tphdr->p_offset = offset;\n\tphdr->p_vaddr = 0;\n\tphdr->p_paddr = 0;\n\tphdr->p_filesz = sz;\n\tphdr->p_memsz = 0;\n\tphdr->p_flags = 0;\n\tphdr->p_align = 0;\n\treturn;\n}", "target": 0}
{"code": "bool safeCreateFile(const String& path, CFDataRef data)\n{\n    WCHAR tempDirPath[MAX_PATH];\n    if (!GetTempPathW(WTF_ARRAY_LENGTH(tempDirPath), tempDirPath))\n        return false;\n    WCHAR tempPath[MAX_PATH];\n    if (!GetTempFileNameW(tempDirPath, L\"WEBKIT\", 0, tempPath))\n        return false;\n    HANDLE tempFileHandle = CreateFileW(tempPath, GENERIC_READ | GENERIC_WRITE, 0, 0, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);\n    if (tempFileHandle == INVALID_HANDLE_VALUE)\n        return false;\n    DWORD written;\n    if (!WriteFile(tempFileHandle, CFDataGetBytePtr(data), static_cast<DWORD>(CFDataGetLength(data)), &written, 0))\n        return false;\n    CloseHandle(tempFileHandle);\n    String destination = path;\n    if (!MoveFileExW(tempPath, destination.charactersWithNullTermination(), MOVEFILE_REPLACE_EXISTING | MOVEFILE_COPY_ALLOWED))\n        return false;\n    return true;\n}", "target": 0}
{"code": "rpa_read_buffer(pool_t pool, const unsigned char **data,\n\t\tconst unsigned char *end, unsigned char **buffer)\n{\n\tconst unsigned char *p = *data;\n\tunsigned int len;\n\tif (p > end)\n\t\treturn 0;\n\tlen = *p++;\n\tif (p + len > end)\n\t\treturn 0;\n\t*buffer = p_malloc(pool, len);\n\tmemcpy(*buffer, p, len);\n\t*data += 1 + len;\n\treturn len;\n}", "target": 1}
{"code": "SMB2_auth_kerberos(struct SMB2_sess_data *sess_data)\n{\n\tint rc;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct cifs_spnego_msg *msg;\n\tstruct key *spnego_key = NULL;\n\tstruct smb2_sess_setup_rsp *rsp = NULL;\n\trc = SMB2_sess_alloc_buffer(sess_data);\n\tif (rc)\n\t\tgoto out;\n\tspnego_key = cifs_get_spnego_key(ses);\n\tif (IS_ERR(spnego_key)) {\n\t\trc = PTR_ERR(spnego_key);\n\t\tspnego_key = NULL;\n\t\tgoto out;\n\t}\n\tmsg = spnego_key->payload.data[0];\n\tif (msg->version != CIFS_SPNEGO_UPCALL_VERSION) {\n\t\tcifs_dbg(VFS,\n\t\t\t  \"bad cifs.upcall version. Expected %d got %d\",\n\t\t\t  CIFS_SPNEGO_UPCALL_VERSION, msg->version);\n\t\trc = -EKEYREJECTED;\n\t\tgoto out_put_spnego_key;\n\t}\n\tses->auth_key.response = kmemdup(msg->data, msg->sesskey_len,\n\t\t\t\t\t GFP_KERNEL);\n\tif (!ses->auth_key.response) {\n\t\tcifs_dbg(VFS,\n\t\t\t\"Kerberos can't allocate (%u bytes) memory\",\n\t\t\tmsg->sesskey_len);\n\t\trc = -ENOMEM;\n\t\tgoto out_put_spnego_key;\n\t}\n\tses->auth_key.len = msg->sesskey_len;\n\tsess_data->iov[1].iov_base = msg->data + msg->sesskey_len;\n\tsess_data->iov[1].iov_len = msg->secblob_len;\n\trc = SMB2_sess_sendreceive(sess_data);\n\tif (rc)\n\t\tgoto out_put_spnego_key;\n\trsp = (struct smb2_sess_setup_rsp *)sess_data->iov[0].iov_base;\n\tses->Suid = rsp->sync_hdr.SessionId;\n\tses->session_flags = le16_to_cpu(rsp->SessionFlags);\n\trc = SMB2_sess_establish_session(sess_data);\nout_put_spnego_key:\n\tkey_invalidate(spnego_key);\n\tkey_put(spnego_key);\nout:\n\tsess_data->result = rc;\n\tsess_data->func = NULL;\n\tSMB2_sess_free_buffer(sess_data);\n}", "target": 0}
{"code": "static int xfrm_expand_policies(const struct flowi *fl, u16 family,\n\t\t\t\tstruct xfrm_policy **pols,\n\t\t\t\tint *num_pols, int *num_xfrms)\n{\n\tint i;\n\tif (*num_pols == 0 || !pols[0]) {\n\t\t*num_pols = 0;\n\t\t*num_xfrms = 0;\n\t\treturn 0;\n\t}\n\tif (IS_ERR(pols[0]))\n\t\treturn PTR_ERR(pols[0]);\n\t*num_xfrms = pols[0]->xfrm_nr;\n#ifdef CONFIG_XFRM_SUB_POLICY\n\tif (pols[0]->action == XFRM_POLICY_ALLOW &&\n\t    pols[0]->type != XFRM_POLICY_TYPE_MAIN) {\n\t\tpols[1] = xfrm_policy_lookup_bytype(xp_net(pols[0]),\n\t\t\t\t\t\t    XFRM_POLICY_TYPE_MAIN,\n\t\t\t\t\t\t    fl, family,\n\t\t\t\t\t\t    XFRM_POLICY_OUT,\n\t\t\t\t\t\t    pols[0]->if_id);\n\t\tif (pols[1]) {\n\t\t\tif (IS_ERR(pols[1])) {\n\t\t\t\txfrm_pols_put(pols, *num_pols);\n\t\t\t\treturn PTR_ERR(pols[1]);\n\t\t\t}\n\t\t\t(*num_pols)++;\n\t\t\t(*num_xfrms) += pols[1]->xfrm_nr;\n\t\t}\n\t}\n#endif\n\tfor (i = 0; i < *num_pols; i++) {\n\t\tif (pols[i]->action != XFRM_POLICY_ALLOW) {\n\t\t\t*num_xfrms = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "mrb_proc_copy(mrb_state *mrb, struct RProc *a, struct RProc *b)\n{\n  if (a->body.irep) {\n    return;\n  }\n  a->flags = b->flags;\n  a->body = b->body;\n  a->upper = b->upper;\n  if (!MRB_PROC_CFUNC_P(a) && a->body.irep) {\n    mrb_irep_incref(mrb, (mrb_irep*)a->body.irep);\n  }\n  a->e.env = b->e.env;\n}", "target": 1}
{"code": "cdf_dump_stream(const cdf_header_t *h, const cdf_stream_t *sst)\n{\n\tsize_t ss = sst->sst_dirlen < h->h_min_size_standard_stream ?\n\t    CDF_SHORT_SEC_SIZE(h) : CDF_SEC_SIZE(h);\n\tcdf_dump(sst->sst_tab, ss * sst->sst_len);\n}", "target": 0}
{"code": "enum ImapAuthRes imap_auth_login(struct ImapData *idata, const char *method)\n{\n  char q_user[SHORT_STRING], q_pass[SHORT_STRING];\n  char buf[STRING];\n  int rc;\n  if (mutt_bit_isset(idata->capabilities, LOGINDISABLED))\n  {\n    mutt_message(_(\"LOGIN disabled on this server.\"));\n    return IMAP_AUTH_UNAVAIL;\n  }\n  if (mutt_account_getuser(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n  if (mutt_account_getpass(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n  mutt_message(_(\"Logging in...\"));\n  imap_quote_string(q_user, sizeof(q_user), idata->conn->account.user);\n  imap_quote_string(q_pass, sizeof(q_pass), idata->conn->account.pass);\n  if (DebugLevel < IMAP_LOG_PASS)\n    mutt_debug(2, \"Sending LOGIN command for %s...\\n\", idata->conn->account.user);\n  snprintf(buf, sizeof(buf), \"LOGIN %s %s\", q_user, q_pass);\n  rc = imap_exec(idata, buf, IMAP_CMD_FAIL_OK | IMAP_CMD_PASS);\n  if (!rc)\n  {\n    mutt_clear_error(); \n    return IMAP_AUTH_SUCCESS;\n  }\n  mutt_error(_(\"Login failed.\"));\n  return IMAP_AUTH_FAILURE;\n}", "target": 1}
{"code": "static struct fdtable *close_files(struct files_struct * files)\n{\n\tstruct fdtable *fdt = rcu_dereference_raw(files->fdt);\n\tunsigned int i, j = 0;\n\tfor (;;) {\n\t\tunsigned long set;\n\t\ti = j * BITS_PER_LONG;\n\t\tif (i >= fdt->max_fds)\n\t\t\tbreak;\n\t\tset = fdt->open_fds[j++];\n\t\twhile (set) {\n\t\t\tif (set & 1) {\n\t\t\t\tstruct file * file = xchg(&fdt->fd[i], NULL);\n\t\t\t\tif (file) {\n\t\t\t\t\tfilp_close(file, files);\n\t\t\t\t\tcond_resched();\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t\tset >>= 1;\n\t\t}\n\t}\n\treturn fdt;\n}", "target": 0}
{"code": "void __skb_tstamp_tx(struct sk_buff *orig_skb,\n\t\t     struct skb_shared_hwtstamps *hwtstamps,\n\t\t     struct sock *sk, int tstype)\n{\n\tstruct sk_buff *skb;\n\tbool tsonly;\n\tif (!sk)\n\t\treturn;\n\ttsonly = sk->sk_tsflags & SOF_TIMESTAMPING_OPT_TSONLY;\n\tif (!skb_may_tx_timestamp(sk, tsonly))\n\t\treturn;\n\tif (tsonly) {\n#ifdef CONFIG_INET\n\t\tif ((sk->sk_tsflags & SOF_TIMESTAMPING_OPT_STATS) &&\n\t\t    sk->sk_protocol == IPPROTO_TCP &&\n\t\t    sk->sk_type == SOCK_STREAM)\n\t\t\tskb = tcp_get_timestamping_opt_stats(sk);\n\t\telse\n#endif\n\t\t\tskb = alloc_skb(0, GFP_ATOMIC);\n\t} else {\n\t\tskb = skb_clone(orig_skb, GFP_ATOMIC);\n\t}\n\tif (!skb)\n\t\treturn;\n\tif (tsonly) {\n\t\tskb_shinfo(skb)->tx_flags = skb_shinfo(orig_skb)->tx_flags;\n\t\tskb_shinfo(skb)->tskey = skb_shinfo(orig_skb)->tskey;\n\t}\n\tif (hwtstamps)\n\t\t*skb_hwtstamps(skb) = *hwtstamps;\n\telse\n\t\tskb->tstamp = ktime_get_real();\n\t__skb_complete_tx_timestamp(skb, sk, tstype);", "target": 1}
{"code": "void gd_stderr_error(int priority, const char *format, va_list args)\n{\n\tswitch (priority) {\n\tcase GD_ERROR:\n\t\tfputs(\"GD Error: \", stderr);\n\t\tbreak;\n\tcase GD_WARNING:\n\t\tfputs(\"GD Warning: \", stderr);\n\t\tbreak;\n\tcase GD_NOTICE:\n\t\tfputs(\"GD Notice: \", stderr);\n\t\tbreak;\n\tcase GD_INFO:\n\t\tfputs(\"GD Info: \", stderr);\n\t\tbreak;\n\tcase GD_DEBUG:\n\t\tfputs(\"GD Debug: \", stderr);\n\t\tbreak;\n\t}\n\tvfprintf(stderr, format, args);\n\tfflush(stderr);\n}", "target": 0}
{"code": "void build_ntlmssp_negotiate_blob(unsigned char *pbuffer,\n\t\t\t\t\t struct cifs_ses *ses)\n{\n\tNEGOTIATE_MESSAGE *sec_blob = (NEGOTIATE_MESSAGE *)pbuffer;\n\t__u32 flags;\n\tmemset(pbuffer, 0, sizeof(NEGOTIATE_MESSAGE));\n\tmemcpy(sec_blob->Signature, NTLMSSP_SIGNATURE, 8);\n\tsec_blob->MessageType = NtLmNegotiate;\n\tflags = NTLMSSP_NEGOTIATE_56 |\tNTLMSSP_REQUEST_TARGET |\n\t\tNTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |\n\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;\n\tif (ses->server->sign) {\n\t\tflags |= NTLMSSP_NEGOTIATE_SIGN;\n\t\tif (!ses->server->session_estab ||\n\t\t\t\tses->ntlmssp->sesskey_per_smbsess)\n\t\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n\t}\n\tsec_blob->NegotiateFlags = cpu_to_le32(flags);\n\tsec_blob->WorkstationName.BufferOffset = 0;\n\tsec_blob->WorkstationName.Length = 0;\n\tsec_blob->WorkstationName.MaximumLength = 0;\n\tsec_blob->DomainName.BufferOffset = 0;\n\tsec_blob->DomainName.Length = 0;\n\tsec_blob->DomainName.MaximumLength = 0;\n}", "target": 1}
{"code": "static void CopyRectangleFromRectangle(rfbClient* client, int src_x, int src_y, int w, int h, int dest_x, int dest_y) {\n  int i,j;\n#define COPY_RECT_FROM_RECT(BPP) \\\n  { \\\n    uint##BPP##_t* _buffer=((uint##BPP##_t*)client->frameBuffer)+(src_y-dest_y)*client->width+src_x-dest_x; \\\n    if (dest_y < src_y) { \\\n      for(j = dest_y*client->width; j < (dest_y+h)*client->width; j += client->width) { \\\n        if (dest_x < src_x) { \\\n          for(i = dest_x; i < dest_x+w; i++) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } else { \\\n          for(i = dest_x+w-1; i >= dest_x; i--) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } \\\n      } \\\n    } else { \\\n      for(j = (dest_y+h-1)*client->width; j >= dest_y*client->width; j-=client->width) { \\\n        if (dest_x < src_x) { \\\n          for(i = dest_x; i < dest_x+w; i++) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } else { \\\n          for(i = dest_x+w-1; i >= dest_x; i--) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } \\\n      } \\\n    } \\\n  }\n  switch(client->format.bitsPerPixel) {\n  case  8: COPY_RECT_FROM_RECT(8);  break;\n  case 16: COPY_RECT_FROM_RECT(16); break;\n  case 32: COPY_RECT_FROM_RECT(32); break;\n  default:\n    rfbClientLog(\"Unsupported bitsPerPixel: %d\\n\",client->format.bitsPerPixel);\n  }\n}", "target": 0}
{"code": "xmalloc (size_t size)\n{\n    void *ptr = malloc (size);\n    if (!ptr \n        && (size != 0))         \n    {\n        perror (\"xmalloc: Memory allocation failure\");\n        abort();\n    }\n    return ptr;\n}", "target": 1}
{"code": "PHPAPI size_t php_printf(const char *format, ...)\n{\n\tva_list args;\n\tsize_t ret;\n\tchar *buffer;\n\tsize_t size;\n\tva_start(args, format);\n\tsize = vspprintf(&buffer, 0, format, args);\n\tret = PHPWRITE(buffer, size);\n\tefree(buffer);\n\tva_end(args);\n\treturn ret;\n}", "target": 0}
{"code": "hermesBuiltinApply(void *, Runtime *runtime, NativeArgs args) {\n  GCScopeMarkerRAII marker{runtime};\n  Handle<Callable> fn = args.dyncastArg<Callable>(0);\n  if (LLVM_UNLIKELY(!fn)) {\n    return runtime->raiseTypeErrorForValue(\n        args.getArgHandle(0), \" is not a function\");\n  }\n  Handle<JSArray> argArray = args.dyncastArg<JSArray>(1);\n  if (LLVM_UNLIKELY(!argArray)) {\n    return runtime->raiseTypeError(\"args must be an array\");\n  }\n  uint32_t len = JSArray::getLength(*argArray);\n  bool isConstructor = args.getArgCount() == 2;\n  MutableHandle<> thisVal{runtime};\n  if (isConstructor) {\n    auto thisValRes = Callable::createThisForConstruct(fn, runtime);\n    if (LLVM_UNLIKELY(thisValRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    thisVal = *thisValRes;\n  } else {\n    thisVal = args.getArg(2);\n  }\n  ScopedNativeCallFrame newFrame{\n      runtime, len, *fn, isConstructor, thisVal.getHermesValue()};\n  for (uint32_t i = 0; i < len; ++i) {\n    newFrame->getArgRef(i) = argArray->at(runtime, i);\n  }\n  return isConstructor ? Callable::construct(fn, runtime, thisVal)\n                       : Callable::call(fn, runtime);\n}", "target": 1}
{"code": "sctp_disposition_t sctp_sf_ootb(struct net *net,\n\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\tvoid *arg,\n\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sk_buff *skb = chunk->skb;\n\tsctp_chunkhdr_t *ch;\n\tsctp_errhdr_t *err;\n\t__u8 *ch_end;\n\tint ootb_shut_ack = 0;\n\tint ootb_cookie_ack = 0;\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\tch = (sctp_chunkhdr_t *) chunk->chunk_hdr;\n\tdo {\n\t\tif (ntohs(ch->length) < sizeof(sctp_chunkhdr_t))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\t\tif (SCTP_CID_SHUTDOWN_ACK == ch->type)\n\t\t\tootb_shut_ack = 1;\n\t\tif (SCTP_CID_ABORT == ch->type)\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\tif (SCTP_CID_COOKIE_ACK == ch->type)\n\t\t\tootb_cookie_ack = 1;\n\t\tif (SCTP_CID_ERROR == ch->type) {\n\t\t\tsctp_walk_errors(err, ch) {\n\t\t\t\tif (SCTP_ERROR_STALE_COOKIE == err->cause) {\n\t\t\t\t\tootb_cookie_ack = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tch_end = ((__u8 *)ch) + WORD_ROUND(ntohs(ch->length));\n\t\tif (ch_end > skb_tail_pointer(skb))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\t\tch = (sctp_chunkhdr_t *) ch_end;\n\t} while (ch_end < skb_tail_pointer(skb));\n\tif (ootb_shut_ack)\n\t\treturn sctp_sf_shut_8_4_5(net, ep, asoc, type, arg, commands);\n\telse if (ootb_cookie_ack)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\telse\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n}", "target": 0}
{"code": "bool btrfs_check_rw_degradable(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tstruct btrfs_device *failing_dev)\n{\n\tstruct btrfs_mapping_tree *map_tree = &fs_info->mapping_tree;\n\tstruct extent_map *em;\n\tu64 next_start = 0;\n\tbool ret = true;\n\tread_lock(&map_tree->map_tree.lock);\n\tem = lookup_extent_mapping(&map_tree->map_tree, 0, (u64)-1);\n\tread_unlock(&map_tree->map_tree.lock);\n\tif (!em) {\n\t\tret = false;\n\t\tgoto out;\n\t}\n\twhile (em) {\n\t\tstruct map_lookup *map;\n\t\tint missing = 0;\n\t\tint max_tolerated;\n\t\tint i;\n\t\tmap = em->map_lookup;\n\t\tmax_tolerated =\n\t\t\tbtrfs_get_num_tolerated_disk_barrier_failures(\n\t\t\t\t\tmap->type);\n\t\tfor (i = 0; i < map->num_stripes; i++) {\n\t\t\tstruct btrfs_device *dev = map->stripes[i].dev;\n\t\t\tif (!dev || !dev->bdev ||\n\t\t\t    test_bit(BTRFS_DEV_STATE_MISSING, &dev->dev_state) ||\n\t\t\t    dev->last_flush_error)\n\t\t\t\tmissing++;\n\t\t\telse if (failing_dev && failing_dev == dev)\n\t\t\t\tmissing++;\n\t\t}\n\t\tif (missing > max_tolerated) {\n\t\t\tif (!failing_dev)\n\t\t\t\tbtrfs_warn(fs_info,\n\t\"chunk %llu missing %d devices, max tolerance is %d for writable mount\",\n\t\t\t\t   em->start, missing, max_tolerated);\n\t\t\tfree_extent_map(em);\n\t\t\tret = false;\n\t\t\tgoto out;\n\t\t}\n\t\tnext_start = extent_map_end(em);\n\t\tfree_extent_map(em);\n\t\tread_lock(&map_tree->map_tree.lock);\n\t\tem = lookup_extent_mapping(&map_tree->map_tree, next_start,\n\t\t\t\t\t   (u64)(-1) - next_start);\n\t\tread_unlock(&map_tree->map_tree.lock);\n\t}\nout:\n\treturn ret;\n}", "target": 0}
{"code": "static int hci_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t len, int flags)\n{\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint copied, err;\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\tif (flags & (MSG_OOB))\n\t\treturn -EOPNOTSUPP;\n\tif (sk->sk_state == BT_CLOSED)\n\t\treturn 0;\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\treturn err;\n\tmsg->msg_namelen = 0;\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tswitch (hci_pi(sk)->channel) {\n\tcase HCI_CHANNEL_RAW:\n\t\thci_sock_cmsg(sk, msg, skb);\n\t\tbreak;\n\tcase HCI_CHANNEL_USER:\n\tcase HCI_CHANNEL_CONTROL:\n\tcase HCI_CHANNEL_MONITOR:\n\t\tsock_recv_timestamp(msg, sk, skb);\n\t\tbreak;\n\t}\n\tskb_free_datagram(sk, skb);\n\treturn err ? : copied;\n}", "target": 1}
{"code": "  inline Eigen::IndexList<Eigen::type2index<1>, int> OneByM(int m) {\n    Eigen::IndexList<Eigen::type2index<1>, int> ret;\n    ret.set(1, m);\n    return ret;\n  }", "target": 1}
{"code": "calculateNumTiles (int *numTiles,\n\t\t   int numLevels,\n\t\t   int min, int max,\n\t\t   int size,\n\t\t   LevelRoundingMode rmode)\n{\n    for (int i = 0; i < numLevels; i++)\n    {\n        int l = levelSize (min, max, i, rmode);\n        if (l > std::numeric_limits<int>::max() - size + 1)\n            throw IEX_NAMESPACE::ArgExc (\"Invalid size.\");\n        numTiles[i] = (l + size - 1) / size;\n    }\n}", "target": 1}
{"code": "int nft_validate_output_register(enum nft_registers reg)\n{\n\tif (reg < NFT_REG_VERDICT)\n\t\treturn -EINVAL;\n\tif (reg > NFT_REG_MAX)\n\t\treturn -ERANGE;\n\treturn 0;\n}", "target": 0}
{"code": "static unsigned addChunk_iTXt(ucvector* out, unsigned compressed, const char* keyword, const char* langtag,\n                              const char* transkey, const char* textstring, LodePNGCompressSettings* zlibsettings)\n{\n  unsigned error = 0;\n  ucvector data;\n  size_t i, textsize = strlen(textstring);\n  ucvector_init(&data);\n  for(i = 0; keyword[i] != 0; i++) ucvector_push_back(&data, (unsigned char)keyword[i]);\n  if(i < 1 || i > 79) return 89; \n  ucvector_push_back(&data, 0); \n  ucvector_push_back(&data, compressed ? 1 : 0); \n  ucvector_push_back(&data, 0); \n  for(i = 0; langtag[i] != 0; i++) ucvector_push_back(&data, (unsigned char)langtag[i]);\n  ucvector_push_back(&data, 0); \n  for(i = 0; transkey[i] != 0; i++) ucvector_push_back(&data, (unsigned char)transkey[i]);\n  ucvector_push_back(&data, 0); \n  if(compressed)\n  {\n    ucvector compressed_data;\n    ucvector_init(&compressed_data);\n    error = zlib_compress(&compressed_data.data, &compressed_data.size,\n                          (unsigned char*)textstring, textsize, zlibsettings);\n    if(!error)\n    {\n      for(i = 0; i < compressed_data.size; i++) ucvector_push_back(&data, compressed_data.data[i]);\n    }\n    ucvector_cleanup(&compressed_data);\n  }\n  else \n  {\n    for(i = 0; textstring[i] != 0; i++) ucvector_push_back(&data, (unsigned char)textstring[i]);\n  }\n  if(!error) error = addChunk(out, \"iTXt\", data.data, data.size);\n  ucvector_cleanup(&data);\n  return error;\n}", "target": 0}
{"code": "unsigned lodepng_decode32(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize)\n{\n  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGBA, 8);\n}", "target": 0}
{"code": "static void interface_release_resource(QXLInstance *sin,\n                                       QXLReleaseInfoExt ext)\n{\n    PCIQXLDevice *qxl = container_of(sin, PCIQXLDevice, ssd.qxl);\n    QXLReleaseRing *ring;\n    uint64_t *item, id;\n    if (ext.group_id == MEMSLOT_GROUP_HOST) {\n        QXLCommandExt *cmdext = (void *)(intptr_t)(ext.info->id);\n        SimpleSpiceUpdate *update;\n        g_assert(cmdext->cmd.type == QXL_CMD_DRAW);\n        update = container_of(cmdext, SimpleSpiceUpdate, ext);\n        qemu_spice_destroy_update(&qxl->ssd, update);\n        return;\n    }\n    ring = &qxl->ram->release_ring;\n    SPICE_RING_PROD_ITEM(qxl, ring, item);\n    if (!item) {\n        return;\n    }\n    if (*item == 0) {\n        id = ext.info->id;\n        ext.info->next = 0;\n        qxl_ram_set_dirty(qxl, &ext.info->next);\n        *item = id;\n        qxl_ring_set_dirty(qxl);\n    } else {\n        qxl->last_release->next = ext.info->id;\n        qxl_ram_set_dirty(qxl, &qxl->last_release->next);\n        ext.info->next = 0;\n        qxl_ram_set_dirty(qxl, &ext.info->next);\n    }\n    qxl->last_release = ext.info;\n    qxl->num_free_res++;\n    trace_qxl_ring_res_put(qxl->id, qxl->num_free_res);\n    qxl_push_free_res(qxl, 0);\n}", "target": 1}
{"code": "ZEND_API void ZEND_FASTCALL convert_to_object(zval *op) \n{\ntry_again:\n\tswitch (Z_TYPE_P(op)) {\n\t\tcase IS_ARRAY:\n\t\t\t{\n\t\t\t\tHashTable *ht = zend_symtable_to_proptable(Z_ARR_P(op));\n\t\t\t\tzend_object *obj;\n\t\t\t\tif (GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE) {\n\t\t\t\t\tht = zend_array_dup(ht);\n\t\t\t\t} else if (ht != Z_ARR_P(op)) {\n\t\t\t\t\tzval_ptr_dtor(op);\n\t\t\t\t} else {\n\t\t\t\t\tGC_DELREF(ht);\n\t\t\t\t}\n\t\t\t\tobj = zend_objects_new(zend_standard_class_def);\n\t\t\t\tobj->properties = ht;\n\t\t\t\tZVAL_OBJ(op, obj);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase IS_OBJECT:\n\t\t\tbreak;\n\t\tcase IS_NULL:\n\t\t\tobject_init(op);\n\t\t\tbreak;\n\t\tcase IS_REFERENCE:\n\t\t\tzend_unwrap_reference(op);\n\t\t\tgoto try_again;\n\t\tdefault: {\n\t\t\tzval tmp;\n\t\t\tZVAL_COPY_VALUE(&tmp, op);\n\t\t\tobject_init(op);\n\t\t\tzend_hash_add_new(Z_OBJPROP_P(op), ZSTR_KNOWN(ZEND_STR_SCALAR), &tmp);\n\t\t\tbreak;\n\t\t}\n\t}\n}", "target": 0}
{"code": "static struct dentry *__d_obtain_alias(struct inode *inode, int disconnected)\n{\n\tstatic const struct qstr anonstring = QSTR_INIT(\"/\", 1);\n\tstruct dentry *tmp;\n\tstruct dentry *res;\n\tunsigned add_flags;\n\tif (!inode)\n\t\treturn ERR_PTR(-ESTALE);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\tres = d_find_any_alias(inode);\n\tif (res)\n\t\tgoto out_iput;\n\ttmp = __d_alloc(inode->i_sb, &anonstring);\n\tif (!tmp) {\n\t\tres = ERR_PTR(-ENOMEM);\n\t\tgoto out_iput;\n\t}\n\tspin_lock(&inode->i_lock);\n\tres = __d_find_any_alias(inode);\n\tif (res) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tdput(tmp);\n\t\tgoto out_iput;\n\t}\n\tadd_flags = d_flags_for_inode(inode);\n\tif (disconnected)\n\t\tadd_flags |= DCACHE_DISCONNECTED;\n\tspin_lock(&tmp->d_lock);\n\t__d_set_inode_and_type(tmp, inode, add_flags);\n\thlist_add_head(&tmp->d_u.d_alias, &inode->i_dentry);\n\thlist_bl_lock(&tmp->d_sb->s_anon);\n\thlist_bl_add_head(&tmp->d_hash, &tmp->d_sb->s_anon);\n\thlist_bl_unlock(&tmp->d_sb->s_anon);\n\tspin_unlock(&tmp->d_lock);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(tmp, inode);\n\treturn tmp;\n out_iput:\n\tif (res && !IS_ERR(res))\n\t\tsecurity_d_instantiate(res, inode);\n\tiput(inode);\n\treturn res;\n}", "target": 0}
{"code": "static ssize_t stream_writev_cb(RedStream *s, const struct iovec *iov, int iovcnt)\n{\n    ssize_t ret = 0;\n    do {\n        int tosend;\n        ssize_t n, expected = 0;\n        int i;\n#ifdef IOV_MAX\n        tosend = MIN(iovcnt, IOV_MAX);\n#else\n        tosend = iovcnt;\n#endif\n        for (i = 0; i < tosend; i++) {\n            expected += iov[i].iov_len;\n        }\n        n = socket_writev(s->socket, iov, tosend);\n        if (n <= expected) {\n            if (n > 0)\n                ret += n;\n            return ret == 0 ? n : ret;\n        }\n        ret += n;\n        iov += tosend;\n        iovcnt -= tosend;\n    } while(iovcnt > 0);\n    return ret;\n}", "target": 0}
{"code": "\t__must_hold(wqe->lock)\n{\n\tstruct io_wqe_acct *acct = io_wqe_get_acct(worker);\n\tstruct io_wqe *wqe = worker->wqe;\n\tif (!(worker->flags & IO_WORKER_F_UP))\n\t\treturn;\n\tif (atomic_dec_and_test(&acct->nr_running) && io_acct_run_queue(acct)) {\n\t\tatomic_inc(&acct->nr_running);\n\t\tatomic_inc(&wqe->wq->worker_refs);\n\t\tio_queue_worker_create(worker, acct, create_worker_cb);\n\t}\n}", "target": 0}
{"code": "static void stmt_update_metadata(MYSQL_STMT *stmt, MYSQL_ROWS *data)\n{\n  MYSQL_BIND  *my_bind, *end;\n  MYSQL_FIELD *field;\n  uchar *null_ptr, bit;\n  uchar *row= (uchar*) data->data;\n#ifndef DBUG_OFF\n  uchar *row_end= row + data->length;\n#endif\n  null_ptr= row;\n  row+= (stmt->field_count+9)/8;\t\t\n  bit= 4;\t\t\t\t\t\n  for (my_bind= stmt->bind, end= my_bind + stmt->field_count, field= stmt->fields ;\n       my_bind < end ;\n       my_bind++, field++)\n  {\n    if (!(*null_ptr & bit))\n      (*my_bind->skip_result)(my_bind, field, &row);\n    DBUG_ASSERT(row <= row_end);\n    if (!((bit<<=1) & 255))\n    {\n      bit= 1;\t\t\t\t\t\n      null_ptr++;\n    }\n  }\n}", "target": 0}
{"code": "void FIFOSampleBuffer::setChannels(int numChannels)\n{\n    uint usedBytes;\n    assert(numChannels > 0);\n    usedBytes = channels * samplesInBuffer;\n    channels = (uint)numChannels;\n    samplesInBuffer = usedBytes / channels;\n}", "target": 1}
{"code": "static int lua_websocket_peek(lua_State *L) \n{\n    apr_status_t rv;\n    apr_bucket_brigade *brigade;\n    request_rec *r = ap_lua_check_request_rec(L, 1);\n    brigade = apr_brigade_create(r->connection->pool, \n            r->connection->bucket_alloc);\n    rv = ap_get_brigade(r->connection->input_filters, brigade, \n            AP_MODE_READBYTES, APR_NONBLOCK_READ, 1);\n    if (rv == APR_SUCCESS) {\n        lua_pushboolean(L, 1);\n    }\n    else {\n        lua_pushboolean(L, 0);\n    }\n    apr_brigade_cleanup(brigade);\n    return 1;\n}", "target": 0}
{"code": "int ssh_scp_accept_request(ssh_scp scp)\n{\n    char buffer[] = {0x00};\n    int rc;\n    if (scp == NULL) {\n        return SSH_ERROR;\n    }\n    if (scp->state != SSH_SCP_READ_REQUESTED) {\n        ssh_set_error(scp->session, SSH_FATAL,\n                      \"ssh_scp_deny_request called under invalid state\");\n        return SSH_ERROR;\n    }\n    rc = ssh_channel_write(scp->channel, buffer, 1);\n    if (rc == SSH_ERROR) {\n        return SSH_ERROR;\n    }\n    if (scp->request_type == SSH_SCP_REQUEST_NEWFILE) {\n        scp->state = SSH_SCP_READ_READING;\n    } else {\n        scp->state = SSH_SCP_READ_INITED;\n    }\n    return SSH_OK;\n}", "target": 0}
{"code": "make_outerjoin_info(JOIN *join)\n{\n  DBUG_ENTER(\"make_outerjoin_info\");\n  JOIN_TAB *tab;\n  for (tab= first_linear_tab(join, WITH_BUSH_ROOTS, WITHOUT_CONST_TABLES);\n       tab; \n       tab= next_linear_tab(join, tab, WITH_BUSH_ROOTS))\n  {\n    if (tab->bush_children)\n    {\n      if (setup_sj_materialization_part1(tab))\n        DBUG_RETURN(TRUE);\n      tab->table->reginfo.join_tab= tab;\n    }\n  }\n  for (tab= first_linear_tab(join, WITH_BUSH_ROOTS, WITHOUT_CONST_TABLES);\n       tab; \n       tab= next_linear_tab(join, tab, WITH_BUSH_ROOTS))\n  {\n    TABLE *table= tab->table;\n    TABLE_LIST *tbl= table->pos_in_table_list;\n    TABLE_LIST *embedding= tbl->embedding;\n    if (tbl->outer_join & (JOIN_TYPE_LEFT | JOIN_TYPE_RIGHT))\n    {\n      tab->last_inner= tab->first_inner= tab;\n      tab->on_expr_ref= &tbl->on_expr;\n      tab->cond_equal= tbl->cond_equal;\n      if (embedding && !embedding->is_active_sjm())\n        tab->first_upper= embedding->nested_join->first_nested;\n    }\n    else if (!embedding)\n      tab->table->reginfo.not_exists_optimize= 0;\n    for ( ; embedding ; embedding= embedding->embedding)\n    {\n      if (embedding->is_active_sjm())\n      {\n        break;\n      }\n      if (!(embedding->on_expr && embedding->outer_join))\n      {\n        tab->table->reginfo.not_exists_optimize= 0;\n        continue;\n      }\n      NESTED_JOIN *nested_join= embedding->nested_join;\n      if (!nested_join->counter)\n      {\n        nested_join->first_nested= tab;\n        tab->on_expr_ref= &embedding->on_expr;\n        tab->cond_equal= tbl->cond_equal;\n        if (embedding->embedding)\n          tab->first_upper= embedding->embedding->nested_join->first_nested;\n      }\n      if (!tab->first_inner)  \n        tab->first_inner= nested_join->first_nested;\n      if (++nested_join->counter < nested_join->n_tables)\n        break;\n      nested_join->first_nested->last_inner= tab;\n    }\n  }\n  DBUG_RETURN(FALSE);\n}", "target": 0}
{"code": "static int fts3EvalPhraseNext(\n  Fts3Cursor *pCsr,               \n  Fts3Phrase *p,                  \n  u8 *pbEof                       \n){\n  int rc = SQLITE_OK;\n  Fts3Doclist *pDL = &p->doclist;\n  Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;\n  if( p->bIncr ){\n    rc = fts3EvalIncrPhraseNext(pCsr, p, pbEof);\n  }else if( pCsr->bDesc!=pTab->bDescIdx && pDL->nAll ){\n    sqlite3Fts3DoclistPrev(pTab->bDescIdx, pDL->aAll, pDL->nAll, \n        &pDL->pNextDocid, &pDL->iDocid, &pDL->nList, pbEof\n    );\n    pDL->pList = pDL->pNextDocid;\n  }else{\n    fts3EvalDlPhraseNext(pTab, pDL, pbEof);\n  }\n  return rc;\n}", "target": 0}
{"code": "TfLiteStatus StoreAllDecodedSequences(\n    TfLiteContext* context,\n    const std::vector<std::vector<std::vector<int>>>& sequences,\n    TfLiteNode* node, int top_paths) {\n  const int32_t batch_size = sequences.size();\n  std::vector<int32_t> num_entries(top_paths, 0);\n  for (const auto& batch_s : sequences) {\n    TF_LITE_ENSURE_EQ(context, batch_s.size(), top_paths);\n    for (int p = 0; p < top_paths; ++p) {\n      num_entries[p] += batch_s[p].size();\n    }\n  }\n  for (int p = 0; p < top_paths; ++p) {\n    const int32_t p_num = num_entries[p];\n    TfLiteTensor* indices = GetOutput(context, node, p);\n    TF_LITE_ENSURE_OK(context, Resize(context, {p_num, 2}, indices));\n    TfLiteTensor* values = GetOutput(context, node, p + top_paths);\n    TF_LITE_ENSURE_OK(context, Resize(context, {p_num}, values));\n    TfLiteTensor* decoded_shape = GetOutput(context, node, p + 2 * top_paths);\n    TF_LITE_ENSURE_OK(context, Resize(context, {2}, decoded_shape));\n    int32_t max_decoded = 0;\n    int32_t offset = 0;\n    int32_t* indices_data = GetTensorData<int32_t>(indices);\n    int32_t* values_data = GetTensorData<int32_t>(values);\n    int32_t* decoded_shape_data = GetTensorData<int32_t>(decoded_shape);\n    for (int b = 0; b < batch_size; ++b) {\n      auto& p_batch = sequences[b][p];\n      int32_t num_decoded = p_batch.size();\n      max_decoded = std::max(max_decoded, num_decoded);\n      std::copy_n(p_batch.begin(), num_decoded, values_data + offset);\n      for (int32_t t = 0; t < num_decoded; ++t, ++offset) {\n        indices_data[offset * 2] = b;\n        indices_data[offset * 2 + 1] = t;\n      }\n    }\n    decoded_shape_data[0] = batch_size;\n    decoded_shape_data[1] = max_decoded;\n  }\n  return kTfLiteOk;\n}", "target": 1}
{"code": "static int dsa_pub_decode(EVP_PKEY *pkey, X509_PUBKEY *pubkey)\n{\n    const unsigned char *p, *pm;\n    int pklen, pmlen;\n    int ptype;\n    void *pval;\n    ASN1_STRING *pstr;\n    X509_ALGOR *palg;\n    ASN1_INTEGER *public_key = NULL;\n    DSA *dsa = NULL;\n    if (!X509_PUBKEY_get0_param(NULL, &p, &pklen, &palg, pubkey))\n        return 0;\n    X509_ALGOR_get0(NULL, &ptype, &pval, palg);\n    if (ptype == V_ASN1_SEQUENCE) {\n        pstr = pval;\n        pm = pstr->data;\n        pmlen = pstr->length;\n        if (!(dsa = d2i_DSAparams(NULL, &pm, pmlen))) {\n            DSAerr(DSA_F_DSA_PUB_DECODE, DSA_R_DECODE_ERROR);\n            goto err;\n        }\n    } else if ((ptype == V_ASN1_NULL) || (ptype == V_ASN1_UNDEF)) {\n        if (!(dsa = DSA_new())) {\n            DSAerr(DSA_F_DSA_PUB_DECODE, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n    } else {\n        DSAerr(DSA_F_DSA_PUB_DECODE, DSA_R_PARAMETER_ENCODING_ERROR);\n        goto err;\n    }\n    if (!(public_key = d2i_ASN1_INTEGER(NULL, &p, pklen))) {\n        DSAerr(DSA_F_DSA_PUB_DECODE, DSA_R_DECODE_ERROR);\n        goto err;\n    }\n    if (!(dsa->pub_key = ASN1_INTEGER_to_BN(public_key, NULL))) {\n        DSAerr(DSA_F_DSA_PUB_DECODE, DSA_R_BN_DECODE_ERROR);\n        goto err;\n    }\n    ASN1_INTEGER_free(public_key);\n    EVP_PKEY_assign_DSA(pkey, dsa);\n    return 1;\n err:\n    if (public_key)\n        ASN1_INTEGER_free(public_key);\n    if (dsa)\n        DSA_free(dsa);\n    return 0;\n}", "target": 0}
{"code": "static Jsi_RC jsi_ArrayFlatSub(Jsi_Interp *interp, Jsi_Obj* nobj, Jsi_Value *arr, int depth) {\n    int i, n = 0, len = jsi_SizeOfArray(interp, arr->d.obj);\n    if (len <= 0) return JSI_OK;\n    Jsi_RC rc = JSI_OK;\n    int clen = jsi_SizeOfArray(interp, nobj);\n    for (i = 0; i < len && rc == JSI_OK; i++) {\n        Jsi_Value *t = Jsi_ValueArrayIndex(interp, arr, i);\n        if (t && depth>0 && Jsi_ValueIsArray(interp, t))\n            rc = jsi_ArrayFlatSub(interp, nobj, t , depth-1);\n        else if (!Jsi_ValueIsUndef(interp, t))\n            Jsi_ObjArrayAdd(interp, nobj, t);\n        if ((uint)(++n + clen)>interp->maxArrayList)\n            return Jsi_LogError(\"array size exceeded\");\n    }\n    return rc;\n}", "target": 0}
{"code": "static long vhost_net_ioctl(struct file *f, unsigned int ioctl,\n\t\t\t    unsigned long arg)\n{\n\tstruct vhost_net *n = f->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tu64 __user *featurep = argp;\n\tstruct vhost_vring_file backend;\n\tu64 features;\n\tint r;\n\tswitch (ioctl) {\n\tcase VHOST_NET_SET_BACKEND:\n\t\tif (copy_from_user(&backend, argp, sizeof backend))\n\t\t\treturn -EFAULT;\n\t\treturn vhost_net_set_backend(n, backend.index, backend.fd);\n\tcase VHOST_GET_FEATURES:\n\t\tfeatures = VHOST_NET_FEATURES;\n\t\tif (copy_to_user(featurep, &features, sizeof features))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase VHOST_SET_FEATURES:\n\t\tif (copy_from_user(&features, featurep, sizeof features))\n\t\t\treturn -EFAULT;\n\t\tif (features & ~VHOST_NET_FEATURES)\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn vhost_net_set_features(n, features);\n\tcase VHOST_RESET_OWNER:\n\t\treturn vhost_net_reset_owner(n);\n\tdefault:\n\t\tmutex_lock(&n->dev.mutex);\n\t\tr = vhost_dev_ioctl(&n->dev, ioctl, argp);\n\t\tif (r == -ENOIOCTLCMD)\n\t\t\tr = vhost_vring_ioctl(&n->dev, ioctl, argp);\n\t\telse\n\t\t\tvhost_net_flush(n);\n\t\tmutex_unlock(&n->dev.mutex);\n\t\treturn r;\n\t}\n}", "target": 0}
{"code": "static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)\n{\n\tstruct snd_seq_port_info *info = arg;\n\tstruct snd_seq_client_port *port;\n\tstruct snd_seq_port_callback *callback;\n\tif (info->addr.client != client->number)\n\t\treturn -EPERM;\n\tport = snd_seq_create_port(client, (info->flags & SNDRV_SEQ_PORT_FLG_GIVEN_PORT) ? info->addr.port : -1);\n\tif (port == NULL)\n\t\treturn -ENOMEM;\n\tif (client->type == USER_CLIENT && info->kernel) {\n\t\tsnd_seq_delete_port(client, port->addr.port);\n\t\treturn -EINVAL;\n\t}\n\tif (client->type == KERNEL_CLIENT) {\n\t\tif ((callback = info->kernel) != NULL) {\n\t\t\tif (callback->owner)\n\t\t\t\tport->owner = callback->owner;\n\t\t\tport->private_data = callback->private_data;\n\t\t\tport->private_free = callback->private_free;\n\t\t\tport->event_input = callback->event_input;\n\t\t\tport->c_src.open = callback->subscribe;\n\t\t\tport->c_src.close = callback->unsubscribe;\n\t\t\tport->c_dest.open = callback->use;\n\t\t\tport->c_dest.close = callback->unuse;\n\t\t}\n\t}\n\tinfo->addr = port->addr;\n\tsnd_seq_set_port_info(port, info);\n\tsnd_seq_system_client_ev_port_start(port->addr.client, port->addr.port);\n\treturn 0;\n}", "target": 1}
{"code": "static void *bpf_any_get(void *raw, enum bpf_type type)\n{\n\tswitch (type) {\n\tcase BPF_TYPE_PROG:\n\t\tatomic_inc(&((struct bpf_prog *)raw)->aux->refcnt);\n\t\tbreak;\n\tcase BPF_TYPE_MAP:\n\t\tbpf_map_inc(raw, true);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\treturn raw;\n}", "target": 1}
{"code": "static int do_new_mount(struct path *path, const char *fstype, int flags,\n\t\t\tint mnt_flags, const char *name, void *data)\n{\n\tstruct file_system_type *type;\n\tstruct user_namespace *user_ns = current->nsproxy->mnt_ns->user_ns;\n\tstruct vfsmount *mnt;\n\tint err;\n\tif (!fstype)\n\t\treturn -EINVAL;\n\ttype = get_fs_type(fstype);\n\tif (!type)\n\t\treturn -ENODEV;\n\tif (user_ns != &init_user_ns) {\n\t\tif (!(type->fs_flags & FS_USERNS_MOUNT)) {\n\t\t\tput_filesystem(type);\n\t\t\treturn -EPERM;\n\t\t}\n\t\tif (!(type->fs_flags & FS_USERNS_DEV_MOUNT)) {\n\t\t\tflags |= MS_NODEV;\n\t\t\tmnt_flags |= MNT_NODEV;\n\t\t}\n\t}\n\tmnt = vfs_kern_mount(type, flags, name, data);\n\tif (!IS_ERR(mnt) && (type->fs_flags & FS_HAS_SUBTYPE) &&\n\t    !mnt->mnt_sb->s_subtype)\n\t\tmnt = fs_set_subtype(mnt, fstype);\n\tput_filesystem(type);\n\tif (IS_ERR(mnt))\n\t\treturn PTR_ERR(mnt);\n\terr = do_add_mount(real_mount(mnt), path, mnt_flags);\n\tif (err)\n\t\tmntput(mnt);\n\treturn err;\n}", "target": 1}
{"code": "check_offset(char *memory, int total_size, char *name, void *offset, int size)\n{\n\tint need_size = (int) ((char *) offset - memory + size);\n\tif (need_size < 0 || need_size > total_size) {\n\t\twarn(_(\"%s: premature end\"), name);\n\t\treturn false;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "        int          GetS8    (int nPos, bool *pbSuccess)\n        {\n            if ( nPos < 0 || nPos >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            int nRes = m_sFile[ nPos ];\n            if ( nRes & 0x80 )\n                nRes |= ~0xff;\n            return nRes;\n        }", "target": 1}
{"code": "xfs_bmap_add_free(\n\tstruct xfs_mount\t\t*mp,\n\tstruct xfs_defer_ops\t\t*dfops,\n\txfs_fsblock_t\t\t\tbno,\n\txfs_filblks_t\t\t\tlen,\n\tstruct xfs_owner_info\t\t*oinfo)\n{\n\tstruct xfs_extent_free_item\t*new;\t\t\n#ifdef DEBUG\n\txfs_agnumber_t\t\tagno;\n\txfs_agblock_t\t\tagbno;\n\tASSERT(bno != NULLFSBLOCK);\n\tASSERT(len > 0);\n\tASSERT(len <= MAXEXTLEN);\n\tASSERT(!isnullstartblock(bno));\n\tagno = XFS_FSB_TO_AGNO(mp, bno);\n\tagbno = XFS_FSB_TO_AGBNO(mp, bno);\n\tASSERT(agno < mp->m_sb.sb_agcount);\n\tASSERT(agbno < mp->m_sb.sb_agblocks);\n\tASSERT(len < mp->m_sb.sb_agblocks);\n\tASSERT(agbno + len <= mp->m_sb.sb_agblocks);\n#endif\n\tASSERT(xfs_bmap_free_item_zone != NULL);\n\tnew = kmem_zone_alloc(xfs_bmap_free_item_zone, KM_SLEEP);\n\tnew->xefi_startblock = bno;\n\tnew->xefi_blockcount = (xfs_extlen_t)len;\n\tif (oinfo)\n\t\tnew->xefi_oinfo = *oinfo;\n\telse\n\t\txfs_rmap_skip_owner_update(&new->xefi_oinfo);\n\ttrace_xfs_bmap_free_defer(mp, XFS_FSB_TO_AGNO(mp, bno), 0,\n\t\t\tXFS_FSB_TO_AGBNO(mp, bno), len);\n\txfs_defer_add(dfops, XFS_DEFER_OPS_TYPE_FREE, &new->xefi_list);\n}", "target": 0}
{"code": "AirPDcapRsnaPwd2PskStep(\n    const guint8 *ppBytes,\n    const guint ppLength,\n    const CHAR *ssid,\n    const size_t ssidLength,\n    const INT iterations,\n    const INT count,\n    UCHAR *output)\n{\n    UCHAR digest[MAX_SSID_LENGTH+4];  \n    UCHAR digest1[SHA1_DIGEST_LEN];\n    INT i, j;\n    if (ssidLength > MAX_SSID_LENGTH) {\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n    memset(digest, 0, sizeof digest);\n    memset(digest1, 0, sizeof digest1);\n    memcpy(digest, ssid, ssidLength);\n    digest[ssidLength] = (UCHAR)((count>>24) & 0xff);\n    digest[ssidLength+1] = (UCHAR)((count>>16) & 0xff);\n    digest[ssidLength+2] = (UCHAR)((count>>8) & 0xff);\n    digest[ssidLength+3] = (UCHAR)(count & 0xff);\n    sha1_hmac(ppBytes, ppLength, digest, (guint32) ssidLength+4, digest1);\n    memcpy(output, digest1, SHA1_DIGEST_LEN);\n    for (i = 1; i < iterations; i++) {\n        sha1_hmac(ppBytes, ppLength, digest1, SHA1_DIGEST_LEN, digest);\n        memcpy(digest1, digest, SHA1_DIGEST_LEN);\n        for (j = 0; j < SHA1_DIGEST_LEN; j++) {\n            output[j] ^= digest[j];\n        }\n    }\n    return AIRPDCAP_RET_SUCCESS;\n}", "target": 0}
{"code": "chdlc_print(netdissect_options *ndo, register const u_char *p, u_int length)\n{\n\tu_int proto;\n\tconst u_char *bp = p;\n\tif (length < CHDLC_HDRLEN)\n\t\tgoto trunc;\n\tND_TCHECK2(*p, CHDLC_HDRLEN);\n\tproto = EXTRACT_16BITS(&p[2]);\n\tif (ndo->ndo_eflag) {\n                ND_PRINT((ndo, \"%s, ethertype %s (0x%04x), length %u: \",\n                       tok2str(chdlc_cast_values, \"0x%02x\", p[0]),\n                       tok2str(ethertype_values, \"Unknown\", proto),\n                       proto,\n                       length));\n\t}\n\tlength -= CHDLC_HDRLEN;\n\tp += CHDLC_HDRLEN;\n\tswitch (proto) {\n\tcase ETHERTYPE_IP:\n\t\tip_print(ndo, p, length);\n\t\tbreak;\n\tcase ETHERTYPE_IPV6:\n\t\tip6_print(ndo, p, length);\n\t\tbreak;\n\tcase CHDLC_TYPE_SLARP:\n\t\tchdlc_slarp_print(ndo, p, length);\n\t\tbreak;\n#if 0\n\tcase CHDLC_TYPE_CDP:\n\t\tchdlc_cdp_print(p, length);\n\t\tbreak;\n#endif\n        case ETHERTYPE_MPLS:\n        case ETHERTYPE_MPLS_MULTI:\n                mpls_print(ndo, p, length);\n\t\tbreak;\n        case ETHERTYPE_ISO:\n                if (length < 2)\n                    goto trunc;\n                ND_TCHECK_16BITS(p);\n                if (*(p+1) == 0x81 ||\n                    *(p+1) == 0x82 ||\n                    *(p+1) == 0x83)\n                    isoclns_print(ndo, p + 1, length - 1, ndo->ndo_snapend - p - 1);\n                else\n                    isoclns_print(ndo, p, length, ndo->ndo_snapend - p);\n                break;\n\tdefault:\n                if (!ndo->ndo_eflag)\n                        ND_PRINT((ndo, \"unknown CHDLC protocol (0x%04x)\", proto));\n                break;\n\t}\n\treturn (CHDLC_HDRLEN);\ntrunc:\n\tND_PRINT((ndo, \"[|chdlc]\"));\n\treturn ndo->ndo_snapend - bp;\n}", "target": 0}
{"code": "unsigned lodepng_auto_choose_color(LodePNGColorMode* mode_out,\n                                   const unsigned char* image, unsigned w, unsigned h,\n                                   const LodePNGColorMode* mode_in)\n{\n  LodePNGColorProfile prof;\n  unsigned error = 0;\n  unsigned i, n, palettebits, grey_ok, palette_ok;\n  lodepng_color_profile_init(&prof);\n  error = get_color_profile(&prof, image, w, h, mode_in);\n  if(error) return error;\n  mode_out->key_defined = 0;\n  if(prof.key && w * h <= 16) prof.alpha = 1; \n  grey_ok = !prof.colored && !prof.alpha; \n  n = prof.numcolors;\n  palettebits = n <= 2 ? 1 : (n <= 4 ? 2 : (n <= 16 ? 4 : 8));\n  palette_ok = n <= 256 && (n * 2 < w * h) && prof.bits <= 8;\n  if(w * h < n * 2) palette_ok = 0; \n  if(grey_ok && prof.bits <= palettebits) palette_ok = 0; \n  if(palette_ok)\n  {\n    unsigned char* p = prof.palette;\n    lodepng_palette_clear(mode_out); \n    for(i = 0; i < prof.numcolors; i++)\n    {\n      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);\n      if(error) break;\n    }\n    mode_out->colortype = LCT_PALETTE;\n    mode_out->bitdepth = palettebits;\n    if(mode_in->colortype == LCT_PALETTE && mode_in->palettesize >= mode_out->palettesize\n        && mode_in->bitdepth == mode_out->bitdepth)\n    {\n      lodepng_color_mode_cleanup(mode_out);\n      lodepng_color_mode_copy(mode_out, mode_in);\n    }\n  }\n  else \n  {\n    mode_out->bitdepth = prof.bits;\n    mode_out->colortype = prof.alpha ? (prof.colored ? LCT_RGBA : LCT_GREY_ALPHA)\n                                     : (prof.colored ? LCT_RGB : LCT_GREY);\n    if(prof.key && !prof.alpha)\n    {\n      unsigned mask = (1u << mode_out->bitdepth) - 1u; \n      mode_out->key_r = prof.key_r & mask;\n      mode_out->key_g = prof.key_g & mask;\n      mode_out->key_b = prof.key_b & mask;\n      mode_out->key_defined = 1;\n    }\n  }\n  return error;\n}", "target": 0}
{"code": "static unsigned short muscle_parse_singleAcl(const sc_acl_entry_t* acl)\n{\n\tunsigned short acl_entry = 0;\n\twhile(acl) {\n\t\tint key = acl->key_ref;\n\t\tint method = acl->method;\n\t\tswitch(method) {\n\t\tcase SC_AC_NEVER:\n\t\t\treturn 0xFFFF;\n\t\tcase SC_AC_NONE:\n\t\tcase SC_AC_UNKNOWN:\n\t\t\tbreak;\n\t\tcase SC_AC_CHV:\n\t\t\tacl_entry |= (1 << key); \n\t\t\tbreak;\n\t\tcase SC_AC_AUT:\n\t\tcase SC_AC_TERM:\n\t\tcase SC_AC_PRO:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tacl = acl->next;\n\t}\n\treturn acl_entry;\n}", "target": 0}
{"code": "GF_Err dinf_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e = gf_isom_box_array_read(s, bs, dinf_AddBox);\n\tif (e) {\n\t\treturn e;\n\t}\n\tif (!((GF_DataInformationBox *)s)->dref) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing dref box in dinf\\n\"));\n\t\t((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "static int read_private_key(RSA *rsa)\n{\n\tint r;\n\tsc_path_t path;\n\tsc_file_t *file;\n\tconst sc_acl_entry_t *e;\n\tu8 buf[2048], *p = buf;\n\tsize_t bufsize, keysize;\n\tr = select_app_df();\n\tif (r)\n\t\treturn 1;\n\tsc_format_path(\"I0012\", &path);\n\tr = sc_select_file(card, &path, &file);\n\tif (r) {\n\t\tfprintf(stderr, \"Unable to select private key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\te = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n\tif (e == NULL || e->method == SC_AC_NEVER)\n\t\treturn 10;\n\tbufsize = MIN(file->size, sizeof buf);\n\tsc_file_free(file);\n\tr = sc_read_binary(card, 0, buf, bufsize, 0);\n\tif (r < 0) {\n\t\tfprintf(stderr, \"Unable to read private key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\tbufsize = r;\n\tdo {\n\t\tif (bufsize < 4)\n\t\t\treturn 3;\n\t\tkeysize = (p[0] << 8) | p[1];\n\t\tif (keysize == 0)\n\t\t\tbreak;\n\t\tif (keysize < 3)\n\t\t\treturn 3;\n\t\tif (p[2] == opt_key_num)\n\t\t\tbreak;\n\t\tp += keysize;\n\t\tbufsize -= keysize;\n\t} while (1);\n\tif (keysize == 0) {\n\t\tprintf(\"Key number %d not found.\\n\", opt_key_num);\n\t\treturn 2;\n\t}\n\treturn parse_private_key(p, keysize, rsa);\n}", "target": 0}
{"code": "static bool ParseSampler(Sampler *sampler, std::string *err, const json &o,\n                         bool store_original_json_for_extras_and_extensions) {\n  ParseStringProperty(&sampler->name, err, o, \"name\", false);\n  int minFilter = -1;\n  int magFilter = -1;\n  int wrapS = TINYGLTF_TEXTURE_WRAP_REPEAT;\n  int wrapT = TINYGLTF_TEXTURE_WRAP_REPEAT;\n  ParseIntegerProperty(&minFilter, err, o, \"minFilter\", false);\n  ParseIntegerProperty(&magFilter, err, o, \"magFilter\", false);\n  ParseIntegerProperty(&wrapS, err, o, \"wrapS\", false);\n  ParseIntegerProperty(&wrapT, err, o, \"wrapT\", false);\n  sampler->minFilter = minFilter;\n  sampler->magFilter = magFilter;\n  sampler->wrapS = wrapS;\n  sampler->wrapT = wrapT;\n  ParseExtensionsProperty(&(sampler->extensions), err, o);\n  ParseExtrasProperty(&(sampler->extras), o);\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        sampler->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        sampler->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n  return true;\n}", "target": 1}
{"code": "static RBinElfSymbol *Elf_(r_bin_elf_get_phdr_imports)(ELFOBJ *bin) {\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tif (bin->phdr_imports) {\n\t\treturn bin->phdr_imports;\n\t}\n\tbin->phdr_imports = get_symbols_from_phdr (bin, R_BIN_ELF_IMPORTS);\n\treturn bin->phdr_imports;\n}", "target": 0}
{"code": "static bool open_match_attributes(connection_struct *conn,\n\t\t\t\t  uint32 old_dos_attr,\n\t\t\t\t  uint32 new_dos_attr,\n\t\t\t\t  mode_t existing_unx_mode,\n\t\t\t\t  mode_t new_unx_mode,\n\t\t\t\t  mode_t *returned_unx_mode)\n{\n\tuint32 noarch_old_dos_attr, noarch_new_dos_attr;\n\tnoarch_old_dos_attr = (old_dos_attr & ~FILE_ATTRIBUTE_ARCHIVE);\n\tnoarch_new_dos_attr = (new_dos_attr & ~FILE_ATTRIBUTE_ARCHIVE);\n\tif((noarch_old_dos_attr == 0 && noarch_new_dos_attr != 0) || \n\t   (noarch_old_dos_attr != 0 && ((noarch_old_dos_attr & noarch_new_dos_attr) == noarch_old_dos_attr))) {\n\t\t*returned_unx_mode = new_unx_mode;\n\t} else {\n\t\t*returned_unx_mode = (mode_t)0;\n\t}\n\tDEBUG(10,(\"open_match_attributes: old_dos_attr = 0x%x, \"\n\t\t  \"existing_unx_mode = 0%o, new_dos_attr = 0x%x \"\n\t\t  \"returned_unx_mode = 0%o\\n\",\n\t\t  (unsigned int)old_dos_attr,\n\t\t  (unsigned int)existing_unx_mode,\n\t\t  (unsigned int)new_dos_attr,\n\t\t  (unsigned int)*returned_unx_mode ));\n\tif (lp_map_system(SNUM(conn)) || lp_store_dos_attributes(SNUM(conn))) {\n\t\tif ((old_dos_attr & FILE_ATTRIBUTE_SYSTEM) &&\n\t\t    !(new_dos_attr & FILE_ATTRIBUTE_SYSTEM)) {\n\t\t\treturn False;\n\t\t}\n\t}\n\tif (lp_map_hidden(SNUM(conn)) || lp_store_dos_attributes(SNUM(conn))) {\n\t\tif ((old_dos_attr & FILE_ATTRIBUTE_HIDDEN) &&\n\t\t    !(new_dos_attr & FILE_ATTRIBUTE_HIDDEN)) {\n\t\t\treturn False;\n\t\t}\n\t}\n\treturn True;\n}", "target": 0}
{"code": "static unsigned char ttyio_in(int timeout)\n{\n\tstruct spk_ldisc_data *ldisc_data = speakup_tty->disc_data;\n\tchar rv;\n\tif (wait_for_completion_timeout(&ldisc_data->completion,\n\t\t\t\t\tusecs_to_jiffies(timeout)) == 0) {\n\t\tif (timeout)\n\t\t\tpr_warn(\"spk_ttyio: timeout (%d)  while waiting for input\\n\",\n\t\t\t\ttimeout);\n\t\treturn 0xff;\n\t}\n\trv = ldisc_data->buf;\n\tmb();\n\tldisc_data->buf_free = true;\n\ttty_schedule_flip(speakup_tty->port);\n\treturn rv;\n}", "target": 0}
{"code": "void luaD_callnoyield (lua_State *L, StkId func, int nResults) {\n  incXCcalls(L);\n  if (getCcalls(L) <= CSTACKERR)  \n    luaE_freeCI(L);\n  luaD_call(L, func, nResults);\n  decXCcalls(L);\n}", "target": 1}
{"code": "_asn1_set_value (asn1_node node, const void *value, unsigned int len)\n{\n  if (node == NULL)\n    return node;\n  if (node->value)\n    {\n      if (node->value != node->small_value)\n\tfree (node->value);\n      node->value = NULL;\n      node->value_len = 0;\n    }\n  if (!len)\n    return node;\n  if (len < sizeof (node->small_value))\n    {\n      node->value = node->small_value;\n    }\n  else\n    {\n      node->value = malloc (len);\n      if (node->value == NULL)\n\treturn NULL;\n    }\n  node->value_len = len;\n  memcpy (node->value, value, len);\n  return node;\n}", "target": 0}
{"code": "PHP_FUNCTION(enchant_broker_request_dict)\n{\n\tzval *broker;\n\tenchant_broker *pbroker;\n\tenchant_dict *dict;\n\tEnchantDict *d;\n\tchar *tag;\n\tint taglen;\n\tint pos;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rs\", &broker, &tag, &taglen) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tPHP_ENCHANT_GET_BROKER;\n\tif (taglen == 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Tag cannot be empty\");\n\t\tRETURN_FALSE;\n\t}\n\td = enchant_broker_request_dict(pbroker->pbroker, (const char *)tag);\n\tif (d) {\n\t\tif (pbroker->dictcnt) {\n\t\t\tpbroker->dict = (enchant_dict **)erealloc(pbroker->dict, sizeof(enchant_dict *) * pbroker->dictcnt);\n\t\t\tpos = pbroker->dictcnt++;\n\t\t} else {\n\t\t\tpbroker->dict = (enchant_dict **)emalloc(sizeof(enchant_dict *));\n\t\t\tpos = 0;\n\t\t\tpbroker->dictcnt++;\n\t\t}\n\t\tdict = pbroker->dict[pos] = (enchant_dict *)emalloc(sizeof(enchant_dict));\n\t\tdict->id = pos;\n\t\tdict->pbroker = pbroker;\n\t\tdict->pdict = d;\n\t\tdict->prev = pos ? pbroker->dict[pos-1] : NULL;\n\t\tdict->next = NULL;\n\t\tpbroker->dict[pos] = dict;\n\t\tif (pos) {\n\t\t\tpbroker->dict[pos-1]->next = dict;\n\t\t}\n\t\tdict->rsrc_id = ZEND_REGISTER_RESOURCE(return_value, dict, le_enchant_dict);\n\t\tzend_list_addref(pbroker->rsrc_id);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}", "target": 1}
{"code": "static void WriteBinaryGltfStream(std::ostream &stream,\n                                  const std::string &content,\n                                  const std::vector<unsigned char> &binBuffer) {\n  const std::string header = \"glTF\";\n  const int version = 2;\n  const uint32_t content_size = uint32_t(content.size());\n  const uint32_t binBuffer_size = uint32_t(binBuffer.size());\n  const uint32_t content_padding_size = content_size % 4 == 0 ? 0 : 4 - content_size % 4;\n  const uint32_t bin_padding_size = binBuffer_size % 4 == 0 ? 0 : 4 - binBuffer_size % 4;\n  const uint32_t length =\n      12 + 8 + content_size + content_padding_size +\n      (binBuffer_size ? (8 + binBuffer_size + bin_padding_size) : 0);\n  stream.write(header.c_str(), std::streamsize(header.size()));\n  stream.write(reinterpret_cast<const char *>(&version), sizeof(version));\n  stream.write(reinterpret_cast<const char *>(&length), sizeof(length));\n  const uint32_t model_length = uint32_t(content.size()) + content_padding_size;\n  const uint32_t model_format = 0x4E4F534A;\n  stream.write(reinterpret_cast<const char *>(&model_length),\n               sizeof(model_length));\n  stream.write(reinterpret_cast<const char *>(&model_format),\n               sizeof(model_format));\n  stream.write(content.c_str(), std::streamsize(content.size()));\n  if (content_padding_size > 0) {\n    const std::string padding = std::string(size_t(content_padding_size), ' ');\n    stream.write(padding.c_str(), std::streamsize(padding.size()));\n  }\n  if (binBuffer.size() > 0) {\n    const uint32_t bin_length = uint32_t(binBuffer.size()) + bin_padding_size;\n    const uint32_t bin_format = 0x004e4942;\n    stream.write(reinterpret_cast<const char *>(&bin_length),\n                 sizeof(bin_length));\n    stream.write(reinterpret_cast<const char *>(&bin_format),\n                 sizeof(bin_format));\n    stream.write(reinterpret_cast<const char *>(binBuffer.data()),\n                 std::streamsize(binBuffer.size()));\n    if (bin_padding_size > 0) {\n      const std::vector<unsigned char> padding =\n          std::vector<unsigned char>(size_t(bin_padding_size), 0);\n      stream.write(reinterpret_cast<const char *>(padding.data()),\n                   std::streamsize(padding.size()));\n    }\n  }\n}", "target": 1}
{"code": "static void timerfd_setup_cancel(struct timerfd_ctx *ctx, int flags)\n{\n\tif ((ctx->clockid == CLOCK_REALTIME ||\n\t     ctx->clockid == CLOCK_REALTIME_ALARM) &&\n\t    (flags & TFD_TIMER_ABSTIME) && (flags & TFD_TIMER_CANCEL_ON_SET)) {\n\t\tif (!ctx->might_cancel) {\n\t\t\tctx->might_cancel = true;\n\t\t\tspin_lock(&cancel_lock);\n\t\t\tlist_add_rcu(&ctx->clist, &cancel_list);\n\t\t\tspin_unlock(&cancel_lock);\n\t\t}\n\t} else if (ctx->might_cancel) {\n\t\ttimerfd_remove_cancel(ctx);\n\t}\n}", "target": 1}
{"code": "void PDPServer::notifyAboveRemoteEndpoints(\n        const ParticipantProxyData& pdata)\n{\n    static_cast<void>(pdata);\n#if HAVE_SECURITY\n    match_reliable_pdp_endpoints(pdata);\n#endif \n}", "target": 1}
{"code": "static void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n{\n\tLIST_HEAD(tmp_list);\n\tstruct mount *p;\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_mount_unlock(mnt);\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tp->mnt.mnt_flags |= MNT_UMOUNT;\n\t\tlist_move(&p->mnt_list, &tmp_list);\n\t}\n\tlist_for_each_entry(p, &tmp_list, mnt_list) {\n\t\tlist_del_init(&p->mnt_child);\n\t}\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_umount(&tmp_list);\n\twhile (!list_empty(&tmp_list)) {\n\t\tbool disconnect;\n\t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n\t\tlist_del_init(&p->mnt_expire);\n\t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n\t\tif (how & UMOUNT_SYNC)\n\t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\t\tdisconnect = disconnect_mount(p, how);\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,\n\t\t\t\t disconnect ? &unmounted : NULL);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tif (!disconnect) {\n\t\t\t\tlist_add_tail(&p->mnt_child, &p->mnt_parent->mnt_mounts);\n\t\t\t} else {\n\t\t\t\tumount_mnt(p);\n\t\t\t}\n\t\t}\n\t\tchange_mnt_propagation(p, MS_PRIVATE);\n\t}\n}", "target": 1}
{"code": "static inline unsigned char *PopLongPixel(const EndianType endian,\n  const unsigned int pixel,unsigned char *pixels)\n{\n  register unsigned int\n    quantum;\n  quantum=(unsigned int) pixel;\n  if (endian == LSBEndian)\n    {\n      *pixels++=(unsigned char) (quantum);\n      *pixels++=(unsigned char) (quantum >> 8);\n      *pixels++=(unsigned char) (quantum >> 16);\n      *pixels++=(unsigned char) (quantum >> 24);\n      return(pixels);\n    }\n  *pixels++=(unsigned char) (quantum >> 24);\n  *pixels++=(unsigned char) (quantum >> 16);\n  *pixels++=(unsigned char) (quantum >> 8);\n  *pixels++=(unsigned char) (quantum);\n  return(pixels);\n}", "target": 0}
{"code": "auto ReferenceHandle::Get(Local<Value> key_handle, MaybeLocal<Object> maybe_options) -> Local<Value> {\n\treturn ThreePhaseTask::Run<async, GetRunner>(*isolate, *this, key_handle, maybe_options, inherit);\n}", "target": 1}
{"code": "__mem_cgroup_commit_charge_swapin(struct page *page, struct mem_cgroup *memcg,\n\t\t\t\t\tenum charge_type ctype)\n{\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\tif (!memcg)\n\t\treturn;\n\tcgroup_exclude_rmdir(&memcg->css);\n\t__mem_cgroup_commit_charge_lrucare(page, memcg, ctype);\n\tif (do_swap_account && PageSwapCache(page)) {\n\t\tswp_entry_t ent = {.val = page_private(page)};\n\t\tstruct mem_cgroup *swap_memcg;\n\t\tunsigned short id;\n\t\tid = swap_cgroup_record(ent, 0);\n\t\trcu_read_lock();\n\t\tswap_memcg = mem_cgroup_lookup(id);\n\t\tif (swap_memcg) {\n\t\t\tif (!mem_cgroup_is_root(swap_memcg))\n\t\t\t\tres_counter_uncharge(&swap_memcg->memsw,\n\t\t\t\t\t\t     PAGE_SIZE);\n\t\t\tmem_cgroup_swap_statistics(swap_memcg, false);\n\t\t\tmem_cgroup_put(swap_memcg);\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\tcgroup_release_and_wakeup_rmdir(&memcg->css);\n}", "target": 0}
{"code": "static inline void fsnotify_oldname_free(const unsigned char *old_name)\n{\n\tkfree(old_name);\n}", "target": 1}
{"code": "long pipe_fcntl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct pipe_inode_info *pipe;\n\tlong ret;\n\tpipe = get_pipe_info(file);\n\tif (!pipe)\n\t\treturn -EBADF;\n\t__pipe_lock(pipe);\n\tswitch (cmd) {\n\tcase F_SETPIPE_SZ: {\n\t\tunsigned int size, nr_pages;\n\t\tsize = round_pipe_size(arg);\n\t\tnr_pages = size >> PAGE_SHIFT;\n\t\tret = -EINVAL;\n\t\tif (!nr_pages)\n\t\t\tgoto out;\n\t\tif (!capable(CAP_SYS_RESOURCE) && size > pipe_max_size) {\n\t\t\tret = -EPERM;\n\t\t\tgoto out;\n\t\t} else if ((too_many_pipe_buffers_hard(pipe->user) ||\n\t\t\t    too_many_pipe_buffers_soft(pipe->user)) &&\n\t\t           !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = pipe_set_size(pipe, nr_pages);\n\t\tbreak;\n\t\t}\n\tcase F_GETPIPE_SZ:\n\t\tret = pipe->buffers * PAGE_SIZE;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\nout:\n\t__pipe_unlock(pipe);\n\treturn ret;\n}", "target": 0}
{"code": "vmod_append(VRT_CTX, VCL_HEADER hdr, VCL_STRANDS s)\n{\n\tstruct http *hp;\n\tstruct strands st[1];\n\tconst char *p[s->n + 2];\n\tconst char *b;\n\tCHECK_OBJ_NOTNULL(ctx, VRT_CTX_MAGIC);\n\tp[0] = hdr->what + 1;\n\tp[1] = \" \";\n\tAN(memcpy(p + 2, s->p, s->n * sizeof *s->p));\n\tst->n = s->n + 2;\n\tst->p = p;\n\tb = VRT_StrandsWS(ctx->ws, NULL, st);\n\thp = VRT_selecthttp(ctx, hdr->where);\n\thttp_SetHeader(hp, b);\n}", "target": 1}
{"code": "dirserv_set_router_is_running(routerinfo_t *router, time_t now)\n{\n  int answer;\n  if (router_is_me(router)) {\n    answer = ! we_are_hibernating();\n  } else if (router->is_hibernating &&\n             (router->cache_info.published_on +\n              HIBERNATION_PUBLICATION_SKEW) > router->last_reachable) {\n    answer = 0;\n  } else if (get_options()->AssumeReachable) {\n    answer = 1;\n  } else {\n    answer = (now < router->last_reachable + REACHABLE_TIMEOUT);\n  }\n  if (!answer && running_long_enough_to_decide_unreachable()) {\n    time_t when = now;\n    if (router->last_reachable &&\n        router->last_reachable + REACHABILITY_TEST_CYCLE_PERIOD < now)\n      when = router->last_reachable + REACHABILITY_TEST_CYCLE_PERIOD;\n    rep_hist_note_router_unreachable(router->cache_info.identity_digest, when);\n  }\n  router->is_running = answer;\n}", "target": 0}
{"code": "yang_fill_include(struct lys_module *trg, char *value, struct lys_include *inc,\n                  struct unres_schema *unres)\n{\n    const char *str;\n    int rc;\n    int ret = 0;\n    str = lydict_insert_zc(trg->ctx, value);\n    rc = lyp_check_include(trg, str, inc, unres);\n    if (!rc) {\n        memcpy(&trg->inc[trg->inc_size], inc, sizeof *inc);\n        if (yang_check_ext_instance(trg, &trg->inc[trg->inc_size].ext, trg->inc[trg->inc_size].ext_size,\n                                    &trg->inc[trg->inc_size], unres)) {\n            ret = -1;\n        }\n        trg->inc_size++;\n    } else if (rc == -1) {\n        lys_extension_instances_free(trg->ctx, inc->ext, inc->ext_size, NULL);\n        ret = -1;\n    }\n    lydict_remove(trg->ctx, str);\n    return ret;\n}", "target": 0}
{"code": "arista_print_date_hms_time(netdissect_options *ndo, uint32_t seconds,\n\t\tuint32_t nanoseconds)\n{\n\ttime_t ts;\n\tstruct tm *tm;\n\tchar buf[BUFSIZE];\n\tts = seconds + (nanoseconds / 1000000000);\n\tnanoseconds %= 1000000000;\n\tif (NULL == (tm = gmtime(&ts)))\n\t\tND_PRINT(\"gmtime() error\");\n\telse if (0 == strftime(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\", tm))\n\t\tND_PRINT(\"strftime() error\");\n\telse\n\t\tND_PRINT(\"%s.%09u\", buf, nanoseconds);\n}", "target": 1}
{"code": "static struct snd_kcontrol *snd_ctl_new(struct snd_kcontrol *control,\n\t\t\t\t\tunsigned int access)\n{\n\tstruct snd_kcontrol *kctl;\n\tunsigned int idx;\n\tif (snd_BUG_ON(!control || !control->count))\n\t\treturn NULL;\n\tif (control->count > MAX_CONTROL_COUNT)\n\t\treturn NULL;\n\tkctl = kzalloc(sizeof(*kctl) + sizeof(struct snd_kcontrol_volatile) * control->count, GFP_KERNEL);\n\tif (kctl == NULL) {\n\t\tpr_err(\"ALSA: Cannot allocate control instance\\n\");\n\t\treturn NULL;\n\t}\n\t*kctl = *control;\n\tfor (idx = 0; idx < kctl->count; idx++)\n\t\tkctl->vd[idx].access = access;\n\treturn kctl;\n}", "target": 0}
{"code": "void tcp_valid_rtt_meas(struct sock *sk, u32 seq_rtt)\n{\n\ttcp_rtt_estimator(sk, seq_rtt);\n\ttcp_set_rto(sk);\n\tinet_csk(sk)->icsk_backoff = 0;\n}", "target": 0}
{"code": "static Jsi_RC NumberToFixedCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[100];\n    int prec = 0, skip = 0;\n    Jsi_Number num;\n    Jsi_Value *v;\n    ChkStringN(_this, funcPtr, v);\n    Jsi_Value *pa = Jsi_ValueArrayIndex(interp, args, skip);\n    if (pa && Jsi_GetIntFromValue(interp, pa, &prec) != JSI_OK)\n        return JSI_ERROR;\n    if (prec<0) prec = 0;\n    Jsi_GetDoubleFromValue(interp, v, &num);\n    snprintf(buf, sizeof(buf), \"%.*\" JSI_NUMFFMT, prec, num);\n    Jsi_ValueMakeStringDup(interp, ret, buf);\n    return JSI_OK;\n}", "target": 1}
{"code": "static uint_fast32_t jpc_abstorelstepsize(jpc_fix_t absdelta, int scaleexpn)\n{\n\tint p;\n\tuint_fast32_t mant;\n\tuint_fast32_t expn;\n\tint n;\n\tif (absdelta < 0) {\n\t\tabort();\n\t}\n\tp = jpc_fix_firstone(absdelta) - JPC_FIX_FRACBITS;\n\tn = 11 - jpc_fix_firstone(absdelta);\n\tmant = ((n < 0) ? (absdelta >> (-n)) : (absdelta << n)) & 0x7ff;\n\texpn = scaleexpn - p;\n\tif (scaleexpn < p) {\n\t\tabort();\n\t}\n\treturn JPC_QCX_EXPN(expn) | JPC_QCX_MANT(mant);\n}", "target": 1}
{"code": "int jvp_number_cmp(jv a, jv b) {\n  assert(JVP_HAS_KIND(a, JV_KIND_NUMBER));\n  assert(JVP_HAS_KIND(b, JV_KIND_NUMBER));\n#ifdef USE_DECNUM\n  if (JVP_HAS_FLAGS(a, JVP_FLAGS_NUMBER_LITERAL) && JVP_HAS_FLAGS(b, JVP_FLAGS_NUMBER_LITERAL)) {\n    decNumber res;\n    decNumberCompare(&res,\n                     jvp_dec_number_ptr(a),\n                     jvp_dec_number_ptr(b),\n                     DEC_CONTEXT()\n                     );\n    if (decNumberIsZero(&res)) {\n      return 0;\n    } else if (decNumberIsNegative(&res)) {\n      return -1;\n    } else {\n      return 1;\n    }\n  }\n#endif\n  double da = jv_number_value(a), db = jv_number_value(b);\n  if (da < db) {\n    return -1;\n  } else if (da == db) {\n    return 0;\n  } else {\n    return 1;\n  }\n}", "target": 1}
{"code": "void sctp_assoc_sync_pmtu(struct sock *sk, struct sctp_association *asoc)\n{\n\tstruct sctp_transport *t;\n\t__u32 pmtu = 0;\n\tif (!asoc)\n\t\treturn;\n\tlist_for_each_entry(t, &asoc->peer.transport_addr_list,\n\t\t\t\ttransports) {\n\t\tif (t->pmtu_pending && t->dst) {\n\t\t\tsctp_transport_update_pmtu(sk, t, dst_mtu(t->dst));\n\t\t\tt->pmtu_pending = 0;\n\t\t}\n\t\tif (!pmtu || (t->pathmtu < pmtu))\n\t\t\tpmtu = t->pathmtu;\n\t}\n\tif (pmtu) {\n\t\tasoc->pathmtu = pmtu;\n\t\tasoc->frag_point = sctp_frag_point(asoc, pmtu);\n\t}\n\tpr_debug(\"%s: asoc:%p, pmtu:%d, frag_point:%d\\n\", __func__, asoc,\n\t\t asoc->pathmtu, asoc->frag_point);\n}", "target": 0}
{"code": "static void lag_pred_line(LagarithContext *l, uint8_t *buf,\n                          int width, int stride, int line)\n{\n    int L, TL;\n    if (!line) {\n        int i, align_width = (width - 1) & ~31;\n        L = l->dsp.add_hfyu_left_prediction(buf + 1, buf + 1,\n                                            align_width, buf[0]);\n        for (i = align_width + 1; i < width; i++)\n            buf[i] += buf[i - 1];\n    } else {\n        L = buf[width - stride - 1];\n        if (line == 1) {\n            TL = l->avctx->pix_fmt == AV_PIX_FMT_YUV420P ? buf[-stride] : L;\n        } else {\n            TL = buf[width - (2 * stride) - 1];\n        }\n        add_lag_median_prediction(buf, buf - stride, buf,\n                                  width, &L, &TL);\n    }\n}", "target": 0}
{"code": "void ConnectDialog::lookedUp() {\n\tServerResolver *sr = qobject_cast<ServerResolver *>(QObject::sender());\n\tsr->deleteLater();\n\tQString hostname = sr->hostname().toLower();\n\tunsigned short port = sr->port();\n\tUnresolvedServerAddress unresolved(hostname, port);\n\tqsDNSActive.remove(unresolved);\n\tif (sr->records().size() == 0) {\n\t\treturn;\n\t}\n\tQSet<ServerAddress> qs;\n\tforeach (ServerResolverRecord record, sr->records()) {\n\t\tforeach(const HostAddress &ha, record.addresses()) {\n\t\t\tqs.insert(ServerAddress(ha, record.port()));\n\t\t}\n\t}\n\tQSet<ServerItem *> waiting = qhDNSWait[unresolved];\n\tforeach(ServerItem *si, waiting) {\n\t\tforeach (const ServerAddress &addr, qs) {\n\t\t\tqhPings[addr].insert(si);\n\t\t}\n\t\tsi->qlAddresses = qs.toList();\n\t}\n\tqlDNSLookup.removeAll(unresolved);\n\tqhDNSCache.insert(unresolved, qs.toList());\n\tqhDNSWait.remove(unresolved);\n\tforeach(ServerItem *si, waiting) {\n\t\tif (si == qtwServers->currentItem()) {\n\t\t\ton_qtwServers_currentItemChanged(si, si);\n\t\t\tif (si == siAutoConnect)\n\t\t\t\taccept();\n\t\t}\n\t}\n\tif (bAllowPing) {\n\t\tforeach(const ServerAddress &addr, qs) {\n\t\t\tsendPing(addr.host.toAddress(), addr.port);\n\t\t}\n\t}\n}", "target": 0}
{"code": "static int sctp_bindx_rem(struct sock *sk, struct sockaddr *addrs, int addrcnt)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_endpoint *ep = sp->ep;\n\tint cnt;\n\tstruct sctp_bind_addr *bp = &ep->base.bind_addr;\n\tint retval = 0;\n\tvoid *addr_buf;\n\tunion sctp_addr *sa_addr;\n\tstruct sctp_af *af;\n\tSCTP_DEBUG_PRINTK(\"sctp_bindx_rem (sk: %p, addrs: %p, addrcnt: %d)\\n\",\n\t\t\t  sk, addrs, addrcnt);\n\taddr_buf = addrs;\n\tfor (cnt = 0; cnt < addrcnt; cnt++) {\n\t\tif (list_empty(&bp->address_list) ||\n\t\t    (sctp_list_single_entry(&bp->address_list))) {\n\t\t\tretval = -EBUSY;\n\t\t\tgoto err_bindx_rem;\n\t\t}\n\t\tsa_addr = (union sctp_addr *)addr_buf;\n\t\taf = sctp_get_af_specific(sa_addr->sa.sa_family);\n\t\tif (!af) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto err_bindx_rem;\n\t\t}\n\t\tif (!af->addr_valid(sa_addr, sp, NULL)) {\n\t\t\tretval = -EADDRNOTAVAIL;\n\t\t\tgoto err_bindx_rem;\n\t\t}\n\t\tif (sa_addr->v4.sin_port != htons(bp->port)) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto err_bindx_rem;\n\t\t}\n\t\tretval = sctp_del_bind_addr(bp, sa_addr);\n\t\taddr_buf += af->sockaddr_len;\nerr_bindx_rem:\n\t\tif (retval < 0) {\n\t\t\tif (cnt > 0)\n\t\t\t\tsctp_bindx_add(sk, addrs, cnt);\n\t\t\treturn retval;\n\t\t}\n\t}\n\treturn retval;\n}", "target": 0}
{"code": "void __init psi_init(void)\n{\n\tif (!psi_enable) {\n\t\tstatic_branch_enable(&psi_disabled);\n\t\treturn;\n\t}\n\tpsi_period = jiffies_to_nsecs(PSI_FREQ);\n\tgroup_init(&psi_system);\n}", "target": 0}
{"code": "static bool reds_send_link_error(RedLinkInfo *link, uint32_t error)\n{\n    struct {\n        SpiceLinkHeader header;\n        SpiceLinkReply reply;\n    } msg;\n    SPICE_VERIFY(sizeof(msg) == sizeof(SpiceLinkHeader) + sizeof(SpiceLinkReply));\n    msg.header.magic = SPICE_MAGIC;\n    msg.header.size = GUINT32_TO_LE(sizeof(msg.reply));\n    msg.header.major_version = GUINT32_TO_LE(SPICE_VERSION_MAJOR);\n    msg.header.minor_version = GUINT32_TO_LE(SPICE_VERSION_MINOR);\n    memset(&msg.reply, 0, sizeof(msg.reply));\n    msg.reply.error = GUINT32_TO_LE(error);\n    return red_stream_write_all(link->stream, &msg, sizeof(msg));\n}", "target": 0}
{"code": "Expr *sqlite3CreateColumnExpr(sqlite3 *db, SrcList *pSrc, int iSrc, int iCol){\n  Expr *p = sqlite3ExprAlloc(db, TK_COLUMN, 0, 0);\n  if( p ){\n    struct SrcList_item *pItem = &pSrc->a[iSrc];\n    p->y.pTab = pItem->pTab;\n    p->iTable = pItem->iCursor;\n    if( p->y.pTab->iPKey==iCol ){\n      p->iColumn = -1;\n    }else{\n      p->iColumn = (ynVar)iCol;\n      testcase( iCol==BMS );\n      testcase( iCol==BMS-1 );\n      pItem->colUsed |= ((Bitmask)1)<<(iCol>=BMS ? BMS-1 : iCol);\n    }\n  }\n  return p;\n}", "target": 1}
{"code": "int STDCALL mysql_server_init(int argc __attribute__((unused)),\n\t\t\t      char **argv __attribute__((unused)),\n\t\t\t      char **groups __attribute__((unused)))\n{\n  int result= 0;\n  if (!mysql_client_init)\n  {\n    mysql_client_init=1;\n    org_my_init_done=my_init_done;\n    if (my_init())\t\t\t\t\n      return 1;\n    init_client_errs();\n    if (mysql_client_plugin_init())\n      return 1;\n    if (!mysql_port)\n    {\n      char *env;\n      struct servent *serv_ptr __attribute__((unused));\n      mysql_port = MYSQL_PORT;\n#if MYSQL_PORT_DEFAULT == 0\n      if ((serv_ptr= getservbyname(\"mysql\", \"tcp\")))\n        mysql_port= (uint) ntohs((ushort) serv_ptr->s_port);\n#endif\n      if ((env= getenv(\"MYSQL_TCP_PORT\")))\n        mysql_port=(uint) atoi(env);\n    }\n    if (!mysql_unix_port)\n    {\n      char *env;\n#ifdef __WIN__\n      mysql_unix_port = (char*) MYSQL_NAMEDPIPE;\n#else\n      mysql_unix_port = (char*) MYSQL_UNIX_ADDR;\n#endif\n      if ((env = getenv(\"MYSQL_UNIX_PORT\")))\n\tmysql_unix_port = env;\n    }\n    mysql_debug(NullS);\n#if defined(SIGPIPE) && !defined(__WIN__)\n    (void) signal(SIGPIPE, SIG_IGN);\n#endif\n#ifdef EMBEDDED_LIBRARY\n    if (argc > -1)\n       result= init_embedded_server(argc, argv, groups);\n#endif\n  }\n  else\n    result= (int)my_thread_init();         \n  return result;\n}", "target": 0}
{"code": "void AllocateDataSet(cmsIT8* it8)\n{\n    TABLE* t = GetTable(it8);\n    if (t -> Data) return;    \n    t-> nSamples   = atoi(cmsIT8GetProperty(it8, \"NUMBER_OF_FIELDS\"));\n    t-> nPatches   = atoi(cmsIT8GetProperty(it8, \"NUMBER_OF_SETS\"));\n    t-> Data = (char**)AllocChunk (it8, ((cmsUInt32Number) t->nSamples + 1) * ((cmsUInt32Number) t->nPatches + 1) *sizeof (char*));\n    if (t->Data == NULL) {\n        SynError(it8, \"AllocateDataSet: Unable to allocate data array\");\n    }\n}", "target": 1}
{"code": "static bool manager_get_show_status(Manager *m, StatusType type) {\n        assert(m);\n        if (m->running_as != SYSTEMD_SYSTEM)\n                return false;\n        if (m->no_console_output)\n                return false;\n        if (!IN_SET(manager_state(m), MANAGER_INITIALIZING, MANAGER_STARTING, MANAGER_STOPPING))\n                return false;\n        if (type != STATUS_TYPE_EMERGENCY && manager_check_ask_password(m) > 0)\n                return false;\n        if (m->show_status > 0)\n                return true;\n        return plymouth_running();\n}", "target": 0}
{"code": "cmsUInt32Number  GenerateCRD(cmsContext ContextID,\n                             cmsHPROFILE hProfile,\n                             cmsUInt32Number Intent, cmsUInt32Number dwFlags,\n                             cmsIOHANDLER* mem)\n{\n    cmsUInt32Number dwBytesUsed;\n    if (!(dwFlags & cmsFLAGS_NODEFAULTRESOURCEDEF)) {\n        EmitHeader(mem, \"Color Rendering Dictionary (CRD)\", hProfile);\n    }\n    if (cmsGetDeviceClass(hProfile) == cmsSigNamedColorClass) {\n        if (!WriteNamedColorCRD(mem, hProfile, Intent, dwFlags)) {\n            return 0;\n        }\n    }\n    else {\n        if (!WriteOutputLUT(mem, hProfile, Intent, dwFlags)) {\n            return 0;\n        }\n    }\n    if (!(dwFlags & cmsFLAGS_NODEFAULTRESOURCEDEF)) {\n        _cmsIOPrintf(mem, \"%%%%EndResource\\n\");\n        _cmsIOPrintf(mem, \"\\n%% CRD End\\n\");\n    }\n    dwBytesUsed = mem ->UsedSpace;\n    return dwBytesUsed;\n    cmsUNUSED_PARAMETER(ContextID);\n}", "target": 0}
{"code": "static int crypto_rng_init_tfm(struct crypto_tfm *tfm)\n{\n\tstruct crypto_rng *rng = __crypto_rng_cast(tfm);\n\tstruct rng_alg *alg = crypto_rng_alg(rng);\n\tstruct old_rng_alg *oalg = crypto_old_rng_alg(rng);\n\tif (oalg->rng_make_random) {\n\t\trng->generate = generate;\n\t\trng->seed = rngapi_reset;\n\t\trng->seedsize = oalg->seedsize;\n\t\treturn 0;\n\t}\n\trng->generate = alg->generate;\n\trng->seed = alg->seed;\n\trng->seedsize = alg->seedsize;\n\treturn 0;\n}", "target": 1}
{"code": "static void move_huge_pte(struct vm_area_struct *vma, unsigned long old_addr,\n\t\t\t  unsigned long new_addr, pte_t *src_pte)\n{\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpte_t *dst_pte, pte;\n\tspinlock_t *src_ptl, *dst_ptl;\n\tdst_pte = huge_pte_offset(mm, new_addr, huge_page_size(h));\n\tdst_ptl = huge_pte_lock(h, mm, dst_pte);\n\tsrc_ptl = huge_pte_lockptr(h, mm, src_pte);\n\tif (src_ptl != dst_ptl)\n\t\tspin_lock_nested(src_ptl, SINGLE_DEPTH_NESTING);\n\tpte = huge_ptep_get_and_clear(mm, old_addr, src_pte);\n\tset_huge_pte_at(mm, new_addr, dst_pte, pte);\n\tif (src_ptl != dst_ptl)\n\t\tspin_unlock(src_ptl);\n\tspin_unlock(dst_ptl);\n}", "target": 0}
{"code": "long keyctl_join_session_keyring(const char __user *_name)\n{\n\tchar *name;\n\tlong ret;\n\tname = NULL;\n\tif (_name) {\n\t\tname = strndup_user(_name, KEY_MAX_DESC_SIZE);\n\t\tif (IS_ERR(name)) {\n\t\t\tret = PTR_ERR(name);\n\t\t\tgoto error;\n\t\t}\n\t\tret = -EPERM;\n\t\tif (name[0] == '.')\n\t\t\tgoto error_name;\n\t}\n\tret = join_session_keyring(name);\nerror_name:\n\tkfree(name);\nerror:\n\treturn ret;\n}", "target": 0}
{"code": "void ogs_nas_5gs_mobile_identity_guti_to_nas_guti(\n        ogs_nas_5gs_mobile_identity_guti_t *mobile_identity_guti,\n        ogs_nas_5gs_guti_t *nas_guti)\n{\n    ogs_assert(mobile_identity_guti);\n    ogs_assert(nas_guti);\n    memset(nas_guti, 0, sizeof(*nas_guti));\n    memcpy(&nas_guti->nas_plmn_id,\n            &mobile_identity_guti->nas_plmn_id, OGS_PLMN_ID_LEN);\n    memcpy(&nas_guti->amf_id,\n            &mobile_identity_guti->amf_id, sizeof(ogs_amf_id_t));\n    nas_guti->m_tmsi = be32toh(mobile_identity_guti->m_tmsi);\n}", "target": 0}
{"code": "char *path_name(struct strbuf *path, const char *name)\n{\n\tstruct strbuf ret = STRBUF_INIT;\n\tif (path)\n\t\tstrbuf_addbuf(&ret, path);\n\tstrbuf_addstr(&ret, name);\n\treturn strbuf_detach(&ret, NULL);\n}", "target": 1}
{"code": "string PacketReader::getLabel(unsigned int recurs)\n{\n  string ret;\n  ret.reserve(40);\n  getLabelFromContent(d_content, d_pos, ret, recurs++);\n  return ret;\n}", "target": 1}
{"code": "static int ax25_create(struct net *net, struct socket *sock, int protocol,\n\t\t       int kern)\n{\n \tstruct sock *sk;\n \tax25_cb *ax25;\n\tif (protocol < 0 || protocol > SK_PROTOCOL_MAX)\n\t\treturn -EINVAL;\n \tif (!net_eq(net, &init_net))\n \t\treturn -EAFNOSUPPORT;\n\tswitch (sock->type) {\n\tcase SOCK_DGRAM:\n\t\tif (protocol == 0 || protocol == PF_AX25)\n\t\t\tprotocol = AX25_P_TEXT;\n\t\tbreak;\n\tcase SOCK_SEQPACKET:\n\t\tswitch (protocol) {\n\t\tcase 0:\n\t\tcase PF_AX25:\t\n\t\t\tprotocol = AX25_P_TEXT;\n\t\t\tbreak;\n\t\tcase AX25_P_SEGMENT:\n#ifdef CONFIG_INET\n\t\tcase AX25_P_ARP:\n\t\tcase AX25_P_IP:\n#endif\n#ifdef CONFIG_NETROM\n\t\tcase AX25_P_NETROM:\n#endif\n#ifdef CONFIG_ROSE\n\t\tcase AX25_P_ROSE:\n#endif\n\t\t\treturn -ESOCKTNOSUPPORT;\n#ifdef CONFIG_NETROM_MODULE\n\t\tcase AX25_P_NETROM:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_NETROM))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_ROSE_MODULE\n\t\tcase AX25_P_ROSE:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_ROSE))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SOCK_RAW:\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\tsk = sk_alloc(net, PF_AX25, GFP_ATOMIC, &ax25_proto, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\tax25 = ax25_sk(sk)->cb = ax25_create_cb();\n\tif (!ax25) {\n\t\tsk_free(sk);\n\t\treturn -ENOMEM;\n\t}\n\tsock_init_data(sock, sk);\n\tsk->sk_destruct = ax25_free_sock;\n\tsock->ops    = &ax25_proto_ops;\n\tsk->sk_protocol = protocol;\n\tax25->sk    = sk;\n\treturn 0;\n}", "target": 0}
{"code": "gb18030_code_to_mbclen(OnigCodePoint code)\n{\n       if ((code & 0xff000000) != 0) return 4;\n  else if ((code &   0xff0000) != 0) return ONIGERR_INVALID_CODE_POINT_VALUE;\n  else if ((code &     0xff00) != 0) return 2;\n  else {\n    if (GB18030_MAP[(int )(code & 0xff)] == CM)\n      return ONIGERR_INVALID_CODE_POINT_VALUE;\n    return 1;\n  }\n}", "target": 0}
{"code": "static int test_signed_mod_replace_ba(int n)\n{\n    BIGNUM *a = NULL, *b = NULL, *c = NULL, *d = NULL;\n    int st = 0;\n    if (!TEST_ptr(a = set_signed_bn(signed_mod_tests[n].n))\n            || !TEST_ptr(b = set_signed_bn(signed_mod_tests[n].divisor))\n            || !TEST_ptr(c = set_signed_bn(signed_mod_tests[n].result))\n            || !TEST_ptr(d = set_signed_bn(signed_mod_tests[n].remainder)))\n        goto err;\n    if (TEST_true(BN_div(b, a, a, b, ctx))\n            && TEST_BN_eq(b, c)\n            && TEST_BN_eq(a, d))\n        st = 1;\n err:\n    BN_free(a);\n    BN_free(b);\n    BN_free(c);\n    BN_free(d);\n    return st;\n}", "target": 0}
{"code": "unsigned int X509v3_addr_get_afi(const IPAddressFamily *f)\n{\n    return ((f != NULL &&\n             f->addressFamily != NULL && f->addressFamily->data != NULL)\n            ? ((f->addressFamily->data[0] << 8) | (f->addressFamily->data[1]))\n            : 0);\n}", "target": 1}
{"code": "int dyn_string_cmp(DYNAMIC_STRING* ds, const char *fname)\n{\n  int error;\n  File fd;\n  char temp_file_path[FN_REFLEN];\n  DBUG_ENTER(\"dyn_string_cmp\");\n  DBUG_PRINT(\"enter\", (\"fname: %s\", fname));\n  if ((fd= create_temp_file(temp_file_path, TMPDIR,\n                            \"tmp\", O_CREAT | O_SHARE | O_RDWR,\n                            MYF(MY_WME))) < 0)\n    die(\"Failed to create temporary file for ds\");\n  if (my_write(fd, (uchar *) ds->str, ds->length,\n               MYF(MY_FNABP | MY_WME)) ||\n      my_seek(fd, 0, SEEK_SET, MYF(0)) == MY_FILEPOS_ERROR)\n  {\n    my_close(fd, MYF(0));\n    my_delete(temp_file_path, MYF(MY_WME));\n    die(\"Failed to write file '%s'\", temp_file_path);\n  }\n  error= compare_files2(fd, fname);\n  my_close(fd, MYF(0));\n  my_delete(temp_file_path, MYF(MY_WME));\n  DBUG_RETURN(error);\n}", "target": 0}
{"code": "void hashTypeTryConversion(robj *o, robj **argv, int start, int end) {\n    int i;\n    if (o->encoding != OBJ_ENCODING_ZIPLIST) return;\n    for (i = start; i <= end; i++) {\n        if (sdsEncodedObject(argv[i]) &&\n            sdslen(argv[i]->ptr) > server.hash_max_ziplist_value)\n        {\n            hashTypeConvert(o, OBJ_ENCODING_HT);\n            break;\n        }\n    }\n}", "target": 1}
{"code": "static noinline_for_stack int ethtool_get_rxnfc(struct net_device *dev,\n\t\t\t\t\t\tvoid __user *useraddr)\n{\n\tstruct ethtool_rxnfc info;\n\tconst struct ethtool_ops *ops = dev->ethtool_ops;\n\tint ret;\n\tvoid *rule_buf = NULL;\n\tif (!ops->get_rxnfc)\n\t\treturn -EOPNOTSUPP;\n\tif (copy_from_user(&info, useraddr, sizeof(info)))\n\t\treturn -EFAULT;\n\tif (info.cmd == ETHTOOL_GRXCLSRLALL) {\n\t\tif (info.rule_cnt > 0) {\n\t\t\trule_buf = kmalloc(info.rule_cnt * sizeof(u32),\n\t\t\t\t\t   GFP_USER);\n\t\t\tif (!rule_buf)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tret = ops->get_rxnfc(dev, &info, rule_buf);\n\tif (ret < 0)\n\t\tgoto err_out;\n\tret = -EFAULT;\n\tif (copy_to_user(useraddr, &info, sizeof(info)))\n\t\tgoto err_out;\n\tif (rule_buf) {\n\t\tuseraddr += offsetof(struct ethtool_rxnfc, rule_locs);\n\t\tif (copy_to_user(useraddr, rule_buf,\n\t\t\t\t info.rule_cnt * sizeof(u32)))\n\t\t\tgoto err_out;\n\t}\n\tret = 0;\nerr_out:\n\tkfree(rule_buf);\n\treturn ret;\n}", "target": 1}
{"code": "void print_2fun(FILE* outfile, LibRaw& MyCoolRawProcessor, std::string& fn)\n{\n\tfprintf(outfile, \"\n\tif (C.cam_mul[0] > 0)\n\t{\n\t\tfprintf(outfile, \"\\n'As shot' WB:\");\n\t\tfor (int c = 0; c < 4; c++)\n\t\t\tfprintf(outfile, \" %.3f\", C.cam_mul[c]);\n\t}\n\tif (C.WB_Coeffs[LIBRAW_WBI_Auto][0] > 0)\n\t{\n\t\tfprintf(outfile, \"\\n'Camera Auto' WB:\");\n\t\tfor (int c = 0; c < 4; c++)\n\t\t\tfprintf(outfile, \" %d\", C.WB_Coeffs[LIBRAW_WBI_Auto][c]);\n\t}\n\tif (C.WB_Coeffs[LIBRAW_WBI_Measured][0] > 0)\n\t{\n\t\tfprintf(outfile, \"\\n'Camera Measured' WB:\");\n\t\tfor (int c = 0; c < 4; c++)\n\t\t\tfprintf(outfile, \" %d\", C.WB_Coeffs[LIBRAW_WBI_Measured][c]);\n\t}\n\tfprintf(outfile, \"\\n\\n\");\n}", "target": 0}
{"code": "static inline int tty_put_user(struct tty_struct *tty, unsigned char x,\n\t\t\t       unsigned char __user *ptr)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\ttty_audit_add_data(tty, &x, 1, ldata->icanon);\n\treturn put_user(x, ptr);\n}", "target": 0}
{"code": "static void logi_dj_recv_queue_notification(struct dj_receiver_dev *djrcv_dev,\n\t\t\t\t\t   struct dj_report *dj_report)\n{\n\tkfifo_in(&djrcv_dev->notif_fifo, dj_report, sizeof(struct dj_report));\n\tif (schedule_work(&djrcv_dev->work) == 0) {\n\t\tdbg_hid(\"%s: did not schedule the work item, was already \"\n\t\t\t\"queued\\n\", __func__);\n\t}\n}", "target": 0}
{"code": "add_header (char *name, char *value, int mode)\n{\n  struct add_header *hp;\n  if (!add_header_list)\n    {\n      int rc = mu_list_create (&add_header_list);\n      if (rc)\n\t{\n\t  mu_error (_(\"Cannot create header list: %s\"), mu_strerror (rc));\n\t  exit (1);\n\t}\n    }\n  hp = mu_alloc (sizeof (*hp));\n  hp->mode = mode;\n  hp->name = name;\n  hp->value = value;\n  mu_list_append (add_header_list, hp);\n}", "target": 0}
{"code": "zzip_disk_entry_fopen (ZZIP_DISK* disk, ZZIP_DISK_ENTRY* entry)\n{\n    ZZIP_DISK_FILE* file = malloc(sizeof(ZZIP_DISK_FILE));\n    if (! file) return file;\n    file->buffer = disk->buffer;\n    file->endbuf = disk->endbuf;\n    file->header = zzip_disk_entry_to_file_header (disk, entry);\n    if (! file->header) { free (file); return 0; }\n    file->avail = zzip_file_header_usize (file->header);\n    if (! file->avail || zzip_file_header_data_stored (file->header))\n    { file->stored = zzip_file_header_to_data (file->header); return file; }\n    file->stored = 0;\n    file->zlib.opaque = 0;\n    file->zlib.zalloc = Z_NULL;\n    file->zlib.zfree = Z_NULL;\n    file->zlib.avail_in = zzip_file_header_csize (file->header);\n    file->zlib.next_in = zzip_file_header_to_data (file->header);\n    if (! zzip_file_header_data_deflated (file->header) ||\n\tinflateInit2 (& file->zlib, -MAX_WBITS) != Z_OK)\n    { free (file); return 0; }\n    return file;\n}", "target": 1}
{"code": "int git_pkt_buffer_wants(\n\tconst git_remote_head * const *refs,\n\tsize_t count,\n\ttransport_smart_caps *caps,\n\tgit_buf *buf)\n{\n\tsize_t i = 0;\n\tconst git_remote_head *head;\n\tif (caps->common) {\n\t\tfor (; i < count; ++i) {\n\t\t\thead = refs[i];\n\t\t\tif (!head->local)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (buffer_want_with_caps(refs[i], caps, buf) < 0)\n\t\t\treturn -1;\n\t\ti++;\n\t}\n\tfor (; i < count; ++i) {\n\t\tchar oid[GIT_OID_HEXSZ];\n\t\thead = refs[i];\n\t\tif (head->local)\n\t\t\tcontinue;\n\t\tgit_oid_fmt(oid, &head->oid);\n\t\tgit_buf_put(buf, pkt_want_prefix, strlen(pkt_want_prefix));\n\t\tgit_buf_put(buf, oid, GIT_OID_HEXSZ);\n\t\tgit_buf_putc(buf, '\\n');\n\t\tif (git_buf_oom(buf))\n\t\t\treturn -1;\n\t}\n\treturn git_pkt_buffer_flush(buf);\n}", "target": 0}
{"code": "Value ExpressionRegex::nextMatch(RegexExecutionState* regexState) const {\n    int execResult = execute(regexState);\n    if (execResult < 0) {\n        return Value(BSONNULL);\n    }\n    StringData input = *(regexState->input);\n    auto verifyBounds = [&input, this](auto startPos, auto limitPos, auto isCapture) {\n        if (startPos == -1 || limitPos == -1) {\n            massert(31304,\n                    str::stream() << \"Unexpected error occurred while executing \" << _opName\n                                  << \". startPos: \" << startPos << \", limitPos: \" << limitPos,\n                    isCapture && startPos == -1 && limitPos == -1);\n            return;\n        }\n        massert(31305,\n                str::stream() << \"Unexpected error occurred while executing \" << _opName\n                              << \". startPos: \" << startPos,\n                (startPos >= 0 && static_cast<size_t>(startPos) <= input.size()));\n        massert(31306,\n                str::stream() << \"Unexpected error occurred while executing \" << _opName\n                              << \". limitPos: \" << limitPos,\n                (limitPos >= 0 && static_cast<size_t>(limitPos) <= input.size()));\n        massert(31307,\n                str::stream() << \"Unexpected error occurred while executing \" << _opName\n                              << \". startPos: \" << startPos << \", limitPos: \" << limitPos,\n                startPos <= limitPos);\n    };\n    verifyBounds(regexState->capturesBuffer[0], regexState->capturesBuffer[1], false);\n    const int matchStartByteIndex = regexState->capturesBuffer[0];\n    StringData matchedStr =\n        input.substr(matchStartByteIndex, regexState->capturesBuffer[1] - matchStartByteIndex);\n    for (int byteIx = regexState->startBytePos; byteIx < matchStartByteIndex;\n         ++(regexState->startCodePointPos)) {\n        byteIx += getCodePointLength(input[byteIx]);\n    }\n    regexState->startBytePos = matchStartByteIndex;\n    std::vector<Value> captures;\n    captures.reserve(regexState->numCaptures);\n    for (int i = 0; i < regexState->numCaptures; ++i) {\n        const int start = regexState->capturesBuffer[2 * (i + 1)];\n        const int limit = regexState->capturesBuffer[2 * (i + 1) + 1];\n        verifyBounds(start, limit, true);\n        captures.push_back(start == -1 && limit == -1 ? Value(BSONNULL)\n                                                      : Value(input.substr(start, limit - start)));\n    }\n    MutableDocument match;\n    match.addField(\"match\", Value(matchedStr));\n    match.addField(\"idx\", Value(regexState->startCodePointPos));\n    match.addField(\"captures\", Value(captures));\n    return match.freezeToValue();\n}", "target": 0}
{"code": "static struct phy *serdes_simple_xlate(struct device *dev,\n\t\t\t\t       struct of_phandle_args *args)\n{\n\tstruct serdes_ctrl *ctrl = dev_get_drvdata(dev);\n\tunsigned int port, idx, i;\n\tif (args->args_count != 2)\n\t\treturn ERR_PTR(-EINVAL);\n\tport = args->args[0];\n\tidx = args->args[1];\n\tfor (i = 0; i <= SERDES_MAX; i++) {\n\t\tstruct serdes_macro *macro = phy_get_drvdata(ctrl->phys[i]);\n\t\tif (idx != macro->idx)\n\t\t\tcontinue;\n\t\tif (idx != SERDES6G(0) && macro->port >= 0)\n\t\t\treturn ERR_PTR(-EBUSY);\n\t\tmacro->port = port;\n\t\treturn ctrl->phys[i];\n\t}\n\treturn ERR_PTR(-ENODEV);\n}", "target": 1}
{"code": "njs_json_push_parse_state(njs_vm_t *vm, njs_json_parse_t *parse,\n    njs_value_t *value)\n{\n    njs_json_state_t  *state;\n    if (njs_slow_path(parse->depth >= NJS_JSON_MAX_DEPTH)) {\n        njs_type_error(vm, \"Nested too deep or a cyclic structure\");\n        return NULL;\n    }\n    state = &parse->states[parse->depth++];\n    state->value = *value;\n    state->index = 0;\n    state->prop = NULL;\n    state->keys = njs_value_own_enumerate(vm, value, NJS_ENUM_KEYS,\n                                          NJS_ENUM_STRING, 0);\n    if (state->keys == NULL) {\n        return NULL;\n    }\n    return state;\n}", "target": 1}
{"code": "void mk_request_free(struct session_request *sr)\n{\n    if (sr->fd_file > 0) {\n        mk_vhost_close(sr);\n    }\n    if (sr->headers.location) {\n        mk_mem_free(sr->headers.location);\n    }\n    if (sr->uri_processed.data != sr->uri.data) {\n        mk_ptr_free(&sr->uri_processed);\n    }\n    if (sr->real_path.data != sr->real_path_static) {\n        mk_ptr_free(&sr->real_path);\n    }\n}", "target": 1}
{"code": "static int count_fuse_fs(void)\n{\n\tstruct mntent *entp;\n\tint count = 0;\n\tconst char *mtab = _PATH_MOUNTED;\n\tFILE *fp = setmntent(mtab, \"r\");\n\tif (fp == NULL) {\n\t\tfprintf(stderr, \"%s: failed to open %s: %s\\n\", progname, mtab,\n\t\t\tstrerror(errno));\n\t\treturn -1;\n\t}\n\twhile ((entp = getmntent(fp)) != NULL) {\n\t\tif (strcmp(entp->mnt_type, \"fuse\") == 0 ||\n\t\t    strncmp(entp->mnt_type, \"fuse.\", 5) == 0)\n\t\t\tcount ++;\n\t}\n\tendmntent(fp);\n\treturn count;\n}", "target": 0}
{"code": "rdpsnd_register_drivers(char *options)\n{\n\tstruct audio_driver **reg;\n\treg = &drivers;\n#if defined(RDPSND_ALSA)\n\t*reg = alsa_register(options);\n\tassert(*reg);\n\treg = &((*reg)->next);\n#endif\n#if defined(RDPSND_SUN)\n\t*reg = sun_register(options);\n\tassert(*reg);\n\treg = &((*reg)->next);\n#endif\n#if defined(RDPSND_OSS)\n\t*reg = oss_register(options);\n\tassert(*reg);\n\treg = &((*reg)->next);\n#endif\n#if defined(RDPSND_SGI)\n\t*reg = sgi_register(options);\n\tassert(*reg);\n\treg = &((*reg)->next);\n#endif\n#if defined(RDPSND_LIBAO)\n\t*reg = libao_register(options);\n\tassert(*reg);\n\treg = &((*reg)->next);\n#endif\n\t*reg = NULL;\n}", "target": 0}
{"code": "static inline unsigned long copy_shmid_to_user(void __user *buf, struct shmid64_ds *in, int version)\n{\n\tswitch (version) {\n\tcase IPC_64:\n\t\treturn copy_to_user(buf, in, sizeof(*in));\n\tcase IPC_OLD:\n\t    {\n\t\tstruct shmid_ds out;\n\t\tmemset(&out, 0, sizeof(out));\n\t\tipc64_perm_to_ipc_perm(&in->shm_perm, &out.shm_perm);\n\t\tout.shm_segsz\t= in->shm_segsz;\n\t\tout.shm_atime\t= in->shm_atime;\n\t\tout.shm_dtime\t= in->shm_dtime;\n\t\tout.shm_ctime\t= in->shm_ctime;\n\t\tout.shm_cpid\t= in->shm_cpid;\n\t\tout.shm_lpid\t= in->shm_lpid;\n\t\tout.shm_nattch\t= in->shm_nattch;\n\t\treturn copy_to_user(buf, &out, sizeof(out));\n\t    }\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}", "target": 0}
{"code": "int mbedtls_asn1_write_null( unsigned char **p, unsigned char *start )\n{\n    int ret;\n    size_t len = 0;\n    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_len( p, start, 0) );\n    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_tag( p, start, MBEDTLS_ASN1_NULL ) );\n    return( (int) len );\n}", "target": 0}
{"code": "static void vhost_vsock_common_send_transport_reset(VHostVSockCommon *vvc)\n{\n    VirtQueueElement *elem;\n    VirtQueue *vq = vvc->event_vq;\n    struct virtio_vsock_event event = {\n        .id = cpu_to_le32(VIRTIO_VSOCK_EVENT_TRANSPORT_RESET),\n    };\n    elem = virtqueue_pop(vq, sizeof(VirtQueueElement));\n    if (!elem) {\n        error_report(\"vhost-vsock missed transport reset event\");\n        return;\n    }\n    if (elem->out_num) {\n        error_report(\"invalid vhost-vsock event virtqueue element with \"\n                     \"out buffers\");\n        goto out;\n    }\n    if (iov_from_buf(elem->in_sg, elem->in_num, 0,\n                     &event, sizeof(event)) != sizeof(event)) {\n        error_report(\"vhost-vsock event virtqueue element is too short\");\n        goto out;\n    }\n    virtqueue_push(vq, elem, sizeof(event));\n    virtio_notify(VIRTIO_DEVICE(vvc), vq);\nout:\n    g_free(elem);\n}", "target": 1}
{"code": "isdn_net_newslave(char *parm)\n{\n\tchar *p = strchr(parm, ',');\n\tisdn_net_dev *n;\n\tchar newname[10];\n\tif (p) {\n\t\tif (!strlen(p + 1))\n\t\t\treturn NULL;\n\t\tstrcpy(newname, p + 1);\n\t\t*p = 0;\n\t\tif (!(n = isdn_net_findif(parm)))\n\t\t\treturn NULL;\n\t\tif (n->local->master)\n\t\t\treturn NULL;\n\t\tif (isdn_net_device_started(n)) \n\t\t\treturn NULL;\n\t\treturn (isdn_net_new(newname, n->dev));\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "vhost_scsi_send_evt(struct vhost_scsi *vs,\n\t\t   struct vhost_scsi_tpg *tpg,\n\t\t   struct se_lun *lun,\n\t\t   u32 event,\n\t\t   u32 reason)\n{\n\tstruct vhost_scsi_evt *evt;\n\tevt = vhost_scsi_allocate_evt(vs, event, reason);\n\tif (!evt)\n\t\treturn;\n\tif (tpg && lun) {\n\t\tevt->event.lun[0] = 0x01;\n\t\tevt->event.lun[1] = tpg->tport_tpgt & 0xFF;\n\t\tif (lun->unpacked_lun >= 256)\n\t\t\tevt->event.lun[2] = lun->unpacked_lun >> 8 | 0x40 ;\n\t\tevt->event.lun[3] = lun->unpacked_lun & 0xFF;\n\t}\n\tllist_add(&evt->list, &vs->vs_event_list);\n\tvhost_work_queue(&vs->dev, &vs->vs_event_work);\n}", "target": 1}
{"code": "void __init acpi_debugfs_init(void)\n{\n\tacpi_debugfs_dir = debugfs_create_dir(\"acpi\", NULL);\n\tacpi_custom_method_init();\n}", "target": 1}
{"code": "static int netbk_count_requests(struct xenvif *vif,\n\t\t\t\tstruct xen_netif_tx_request *first,\n\t\t\t\tstruct xen_netif_tx_request *txp,\n\t\t\t\tint work_to_do)\n{\n\tRING_IDX cons = vif->tx.req_cons;\n\tint frags = 0;\n\tif (!(first->flags & XEN_NETTXF_more_data))\n\t\treturn 0;\n\tdo {\n\t\tif (frags >= work_to_do) {\n\t\t\tnetdev_dbg(vif->dev, \"Need more frags\\n\");\n\t\t\treturn -frags;\n\t\t}\n\t\tif (unlikely(frags >= MAX_SKB_FRAGS)) {\n\t\t\tnetdev_dbg(vif->dev, \"Too many frags\\n\");\n\t\t\treturn -frags;\n\t\t}\n\t\tmemcpy(txp, RING_GET_REQUEST(&vif->tx, cons + frags),\n\t\t       sizeof(*txp));\n\t\tif (txp->size > first->size) {\n\t\t\tnetdev_dbg(vif->dev, \"Frags galore\\n\");\n\t\t\treturn -frags;\n\t\t}\n\t\tfirst->size -= txp->size;\n\t\tfrags++;\n\t\tif (unlikely((txp->offset + txp->size) > PAGE_SIZE)) {\n\t\t\tnetdev_dbg(vif->dev, \"txp->offset: %x, size: %u\\n\",\n\t\t\t\t txp->offset, txp->size);\n\t\t\treturn -frags;\n\t\t}\n\t} while ((txp++)->flags & XEN_NETTXF_more_data);\n\treturn frags;\n}", "target": 1}
{"code": "static void virtqueue_map_desc(unsigned int *p_num_sg, hwaddr *addr, struct iovec *iov,\n                               unsigned int max_num_sg, bool is_write,\n                               hwaddr pa, size_t sz)\n{\n    unsigned num_sg = *p_num_sg;\n    assert(num_sg <= max_num_sg);\n    while (sz) {\n        hwaddr len = sz;\n        if (num_sg == max_num_sg) {\n            error_report(\"virtio: too many write descriptors in indirect table\");\n            exit(1);\n        }\n        iov[num_sg].iov_base = cpu_physical_memory_map(pa, &len, is_write);\n        iov[num_sg].iov_len = len;\n        addr[num_sg] = pa;\n        sz -= len;\n        pa += len;\n        num_sg++;\n    }\n    *p_num_sg = num_sg;\n}", "target": 1}
{"code": "void ArcMemory::Load(const byte *Data,size_t Size)\n{\n  ArcData.Alloc(Size);\n  memcpy(&ArcData[0],Data,Size);\n  Loaded=true;\n  SeekPos=0;\n}", "target": 0}
{"code": "  explicit FractionalMaxPoolOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"pooling_ratio\", &pooling_ratio_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"pseudo_random\", &pseudo_random_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"overlapping\", &overlapping_));\n    OP_REQUIRES(context, pooling_ratio_.size() == 4,\n                errors::InvalidArgument(\"pooling_ratio field must \"\n                                        \"specify 4 dimensions\"));\n    for (std::size_t i = 0; i < pooling_ratio_.size(); ++i) {\n      OP_REQUIRES(context, pooling_ratio_[i] >= 1,\n                  errors::InvalidArgument(\n                      \"pooling_ratio cannot be smaller than 1, got: \",\n                      pooling_ratio_[i]));\n    }\n    OP_REQUIRES(\n        context, pooling_ratio_[0] == 1 && pooling_ratio_[3] == 1,\n        errors::Unimplemented(\"Fractional max pooling is not yet \"\n                              \"supported on the batch nor channel dimension.\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"deterministic\", &deterministic_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed\", &seed_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed2\", &seed2_));\n    if (deterministic_) {\n      if ((seed_ == 0) && (seed2_ == 0)) {\n        seed_ = random::New64();\n        seed2_ = random::New64();\n      }\n    } else {\n      OP_REQUIRES(\n          context, (seed_ == 0) && (seed2_ == 0),\n          errors::InvalidArgument(\n              \"Both seed and seed2 should be 0 if deterministic is false.\"));\n    }\n  }", "target": 0}
{"code": "jpeg_getc (j_decompress_ptr cinfo)\n{\n  struct jpeg_source_mgr *datasrc = cinfo->src;\n  if (datasrc->bytes_in_buffer == 0) {\n    if (! (*datasrc->fill_input_buffer) (cinfo))\n      ERREXIT(cinfo, JERR_CANT_SUSPEND);\n  }\n  datasrc->bytes_in_buffer--;\n  return GETJOCTET(*datasrc->next_input_byte++);\n}", "target": 0}
{"code": "buf_add_chunk_with_capacity(buf_t *buf, size_t capacity, int capped)\n{\n  chunk_t *chunk;\n  struct timeval now;\n  if (CHUNK_ALLOC_SIZE(capacity) < buf->default_chunk_size) {\n    chunk = chunk_new_with_alloc_size(buf->default_chunk_size);\n  } else if (capped && CHUNK_ALLOC_SIZE(capacity) > MAX_CHUNK_ALLOC) {\n    chunk = chunk_new_with_alloc_size(MAX_CHUNK_ALLOC);\n  } else {\n    chunk = chunk_new_with_alloc_size(preferred_chunk_size(capacity));\n  }\n  tor_gettimeofday_cached_monotonic(&now);\n  chunk->inserted_time = (uint32_t)tv_to_msec(&now);\n  if (buf->tail) {\n    tor_assert(buf->head);\n    buf->tail->next = chunk;\n    buf->tail = chunk;\n  } else {\n    tor_assert(!buf->head);\n    buf->head = buf->tail = chunk;\n  }\n  check();\n  return chunk;\n}", "target": 0}
{"code": "int btrfs_grow_device(struct btrfs_trans_handle *trans,\n\t\t      struct btrfs_device *device, u64 new_size)\n{\n\tstruct btrfs_fs_info *fs_info = device->fs_info;\n\tstruct btrfs_super_block *super_copy = fs_info->super_copy;\n\tstruct btrfs_fs_devices *fs_devices;\n\tu64 old_total;\n\tu64 diff;\n\tif (!test_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state))\n\t\treturn -EACCES;\n\tnew_size = round_down(new_size, fs_info->sectorsize);\n\tmutex_lock(&fs_info->chunk_mutex);\n\told_total = btrfs_super_total_bytes(super_copy);\n\tdiff = round_down(new_size - device->total_bytes, fs_info->sectorsize);\n\tif (new_size <= device->total_bytes ||\n\t    test_bit(BTRFS_DEV_STATE_REPLACE_TGT, &device->dev_state)) {\n\t\tmutex_unlock(&fs_info->chunk_mutex);\n\t\treturn -EINVAL;\n\t}\n\tfs_devices = fs_info->fs_devices;\n\tbtrfs_set_super_total_bytes(super_copy,\n\t\t\tround_down(old_total + diff, fs_info->sectorsize));\n\tdevice->fs_devices->total_rw_bytes += diff;\n\tbtrfs_device_set_total_bytes(device, new_size);\n\tbtrfs_device_set_disk_total_bytes(device, new_size);\n\tbtrfs_clear_space_info_full(device->fs_info);\n\tif (list_empty(&device->resized_list))\n\t\tlist_add_tail(&device->resized_list,\n\t\t\t      &fs_devices->resized_devices);\n\tmutex_unlock(&fs_info->chunk_mutex);\n\treturn btrfs_update_device(trans, device);\n}", "target": 0}
{"code": "l2tp_bearer_type_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint32_t *ptr = (const uint32_t *)dat;\n\tif (EXTRACT_32BITS(ptr) &  L2TP_BEARER_TYPE_ANALOG_MASK) {\n\t\tND_PRINT((ndo, \"A\"));\n\t}\n\tif (EXTRACT_32BITS(ptr) &  L2TP_BEARER_TYPE_DIGITAL_MASK) {\n\t\tND_PRINT((ndo, \"D\"));\n\t}\n}", "target": 1}
{"code": "static char *exif_get_sectionlist(int sectionlist)\n{\n\tint i, len, ml = 0;\n\tchar *sections;\n\tfor(i=0; i<SECTION_COUNT; i++) {\n\t\tml += strlen(exif_get_sectionname(i))+2;\n\t}\n\tsections = safe_emalloc(ml, 1, 1);\n\tsections[0] = '\\0';\n\tlen = 0;\n\tfor(i=0; i<SECTION_COUNT; i++) {\n\t\tif (sectionlist&(1<<i)) {\n\t\t\tsnprintf(sections+len, ml-len, \"%s, \", exif_get_sectionname(i));\n\t\t\tlen = strlen(sections);\n\t\t}\n\t}\n\tif (len>2)\n\t\tsections[len-2] = '\\0';\n\treturn sections;\n}", "target": 0}
{"code": "int git_config_perm(const char *var, const char *value)\n{\n\tif (value) {\n\t\tint i;\n\t\tif (!strcmp(value, \"umask\"))\n\t\t\treturn PERM_UMASK;\n\t\tif (!strcmp(value, \"group\"))\n\t\t\treturn PERM_GROUP;\n\t\tif (!strcmp(value, \"all\") ||\n\t\t    !strcmp(value, \"world\") ||\n\t\t    !strcmp(value, \"everybody\"))\n\t\t\treturn PERM_EVERYBODY;\n\t\ti = atoi(value);\n\t\tif (i > 1)\n\t\t\treturn i;\n\t}\n\treturn git_config_bool(var, value);\n}", "target": 0}
{"code": "print_address_information(address_item *addr, FILE *f, uschar *si, uschar *sc,\n  uschar *se)\n{\nBOOL yield = TRUE;\nuschar *printed = US\"\";\naddress_item *ancestor = addr;\nwhile (ancestor->parent) ancestor = ancestor->parent;\nfprintf(f, \"%s\", CS si);\nif (addr->parent && testflag(addr, af_hide_child))\n  {\n  printed = US\"an undisclosed address\";\n  yield = FALSE;\n  }\nelse if (!testflag(addr, af_pfr) || !addr->parent)\n  printed = addr->address;\nelse\n  {\n  uschar *s = addr->address;\n  uschar *ss;\n  if (addr->address[0] == '>') { ss = US\"mail\"; s++; }\n  else if (addr->address[0] == '|') ss = US\"pipe\";\n  else ss = US\"save\";\n  fprintf(f, \"%s to %s%sgenerated by \", ss, s, sc);\n  printed = addr->parent->address;\n  }\nfprintf(f, \"%s\", CS string_printing(printed));\nif (ancestor != addr)\n  {\n  uschar *original = ancestor->onetime_parent;\n  if (!original) original= ancestor->address;\n  if (strcmpic(original, printed) != 0)\n    fprintf(f, \"%s(%sgenerated from %s)\", sc,\n      ancestor != addr->parent ? \"ultimately \" : \"\",\n      string_printing(original));\n  }\nif (addr->host_used)\n  fprintf(f, \"\\n    host %s [%s]\",\n\t  addr->host_used->name, addr->host_used->address);\nfprintf(f, \"%s\", CS se);\nreturn yield;\n}", "target": 0}
{"code": "void hrandfieldCommand(client *c) {\n    long l;\n    int withvalues = 0;\n    robj *hash;\n    listpackEntry ele;\n    if (c->argc >= 3) {\n        if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;\n        if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"withvalues\"))) {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return;\n        } else if (c->argc == 4)\n            withvalues = 1;\n        hrandfieldWithCountCommand(c, l, withvalues);\n        return;\n    }\n    if ((hash = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp]))== NULL ||\n        checkType(c,hash,OBJ_HASH)) {\n        return;\n    }\n    hashTypeRandomElement(hash,hashTypeLength(hash),&ele,NULL);\n    hashReplyFromListpackEntry(c, &ele);\n}", "target": 1}
{"code": "init_ctx_nego(OM_uint32 *minor_status, spnego_gss_ctx_id_t sc,\n\t      OM_uint32 acc_negState, gss_OID supportedMech,\n\t      gss_buffer_t *responseToken, gss_buffer_t *mechListMIC,\n\t      OM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 ret;\n\t*negState = REJECT;\n\t*tokflag = ERROR_TOKEN_SEND;\n\tret = GSS_S_DEFECTIVE_TOKEN;\n\tif (supportedMech == GSS_C_NO_OID) {\n\t\t*minor_status = ERR_SPNEGO_NO_MECH_FROM_ACCEPTOR;\n\t\tmap_errcode(minor_status);\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t}\n\tif (acc_negState == ACCEPT_DEFECTIVE_TOKEN) {\n\t\t*minor_status = ERR_SPNEGO_NEGOTIATION_FAILED;\n\t\tmap_errcode(minor_status);\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t}\n\tif (!(is_kerb_mech(supportedMech) &&\n\t      is_kerb_mech(sc->internal_mech)) &&\n\t    !g_OID_equal(supportedMech, sc->internal_mech)) {\n\t\tret = init_ctx_reselect(minor_status, sc,\n\t\t\t\t\tacc_negState, supportedMech,\n\t\t\t\t\tresponseToken, mechListMIC,\n\t\t\t\t\tnegState, tokflag);\n\t} else if (*responseToken == GSS_C_NO_BUFFER) {\n\t\tif (sc->mech_complete) {\n\t\t\t*negState = ACCEPT_COMPLETE;\n\t\t\t*tokflag = NO_TOKEN_SEND;\n\t\t\tret = GSS_S_COMPLETE;\n\t\t} else {\n\t\t\t*minor_status = ERR_SPNEGO_NO_TOKEN_FROM_ACCEPTOR;\n\t\t\tmap_errcode(minor_status);\n\t\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\t}\n\t} else if ((*responseToken)->length == 0 && sc->mech_complete) {\n\t\t*negState = ACCEPT_COMPLETE;\n\t\t*tokflag = NO_TOKEN_SEND;\n\t\tret = GSS_S_COMPLETE;\n\t} else if (sc->mech_complete) {\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t} else {\n\t\t*negState = ACCEPT_INCOMPLETE;\n\t\t*tokflag = CONT_TOKEN_SEND;\n\t\tret = GSS_S_CONTINUE_NEEDED;\n\t}\n\tsc->nego_done = 1;\n\treturn ret;\n}", "target": 0}
{"code": "int expand_upwards(struct vm_area_struct *vma, unsigned long address)\n{\n\tint error;\n\tif (!(vma->vm_flags & VM_GROWSUP))\n\t\treturn -EFAULT;\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\treturn -ENOMEM;\n\tanon_vma_lock(vma);\n\tif (address < PAGE_ALIGN(address+4))\n\t\taddress = PAGE_ALIGN(address+4);\n\telse {\n\t\tanon_vma_unlock(vma);\n\t\treturn -ENOMEM;\n\t}\n\terror = 0;\n\tif (address > vma->vm_end) {\n\t\tunsigned long size, grow;\n\t\tsize = address - vma->vm_start;\n\t\tgrow = (address - vma->vm_end) >> PAGE_SHIFT;\n\t\terror = acct_stack_growth(vma, size, grow);\n\t\tif (!error)\n\t\t\tvma->vm_end = address;\n\t}\n\tanon_vma_unlock(vma);\n\treturn error;\n}", "target": 0}
{"code": "static inline struct sctp_ulpevent *sctp_ulpq_retrieve_partial(struct sctp_ulpq *ulpq)\n{\n\tstruct sk_buff *pos, *last_frag, *first_frag;\n\tstruct sctp_ulpevent *cevent;\n\t__u32 ctsn, next_tsn;\n\tint is_last;\n\tstruct sctp_ulpevent *retval;\n\tif (skb_queue_empty(&ulpq->reasm))\n\t\treturn NULL;\n\tlast_frag = first_frag = NULL;\n\tretval = NULL;\n\tnext_tsn = 0;\n\tis_last = 0;\n\tskb_queue_walk(&ulpq->reasm, pos) {\n\t\tcevent = sctp_skb2event(pos);\n\t\tctsn = cevent->tsn;\n\t\tswitch (cevent->msg_flags & SCTP_DATA_FRAG_MASK) {\n\t\tcase SCTP_DATA_MIDDLE_FRAG:\n\t\t\tif (!first_frag) {\n\t\t\t\tfirst_frag = pos;\n\t\t\t\tnext_tsn = ctsn + 1;\n\t\t\t\tlast_frag = pos;\n\t\t\t} else if (next_tsn == ctsn)\n\t\t\t\tnext_tsn++;\n\t\t\telse\n\t\t\t\tgoto done;\n\t\t\tbreak;\n\t\tcase SCTP_DATA_LAST_FRAG:\n\t\t\tif (!first_frag)\n\t\t\t\tfirst_frag = pos;\n\t\t\telse if (ctsn != next_tsn)\n\t\t\t\tgoto done;\n\t\t\tlast_frag = pos;\n\t\t\tis_last = 1;\n\t\t\tgoto done;\n\t\tdefault:\n\t\t\treturn NULL;\n\t\t};\n\t}\ndone:\n\tretval = sctp_make_reassembled_event(&ulpq->reasm, first_frag, last_frag);\n\tif (retval && is_last)\n\t\tretval->msg_flags |= MSG_EOR;\n\treturn retval;\n}", "target": 0}
{"code": "void qemu_ram_free(struct uc_struct *uc, RAMBlock *block)\n{\n    if (!block) {\n        return;\n    }\n    QLIST_REMOVE(block, next);\n    uc->ram_list.mru_block = NULL;\n    reclaim_ramblock(uc, block);\n}", "target": 1}
{"code": "set_tagstack(win_T *wp, dict_T *d, int action)\n{\n    dictitem_T\t*di;\n    list_T\t*l = NULL;\n#ifdef FEAT_EVAL\n    if (tfu_in_use)\n    {\n\temsg(_(e_cannot_modify_tag_stack_within_tagfunc));\n\treturn FAIL;\n    }\n#endif\n    if ((di = dict_find(d, (char_u *)\"items\", -1)) != NULL)\n    {\n\tif (di->di_tv.v_type != VAR_LIST)\n\t{\n\t    emsg(_(e_list_required));\n\t    return FAIL;\n\t}\n\tl = di->di_tv.vval.v_list;\n    }\n    if ((di = dict_find(d, (char_u *)\"curidx\", -1)) != NULL)\n\ttagstack_set_curidx(wp, (int)tv_get_number(&di->di_tv) - 1);\n    if (action == 't')\t\t    \n    {\n\ttaggy_T\t*tagstack = wp->w_tagstack;\n\tint\ttagstackidx = wp->w_tagstackidx;\n\tint\ttagstacklen = wp->w_tagstacklen;\n\twhile (tagstackidx < tagstacklen)\n\t    tagstack_clear_entry(&tagstack[--tagstacklen]);\n\twp->w_tagstacklen = tagstacklen;\n    }\n    if (l != NULL)\n    {\n\tif (action == 'r')\t\t\n\t    tagstack_clear(wp);\n\ttagstack_push_items(wp, l);\n\twp->w_tagstackidx = wp->w_tagstacklen;\n    }\n    return OK;\n}", "target": 0}
{"code": "void sctp_generate_heartbeat_event(unsigned long data)\n{\n\tint error = 0;\n\tstruct sctp_transport *transport = (struct sctp_transport *) data;\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct net *net = sock_net(asoc->base.sk);\n\tbh_lock_sock(asoc->base.sk);\n\tif (sock_owned_by_user(asoc->base.sk)) {\n\t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n\t\tif (!mod_timer(&transport->hb_timer, jiffies + (HZ/20)))\n\t\t\tsctp_transport_hold(transport);\n\t\tgoto out_unlock;\n\t}\n\tif (transport->dead)\n\t\tgoto out_unlock;\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(SCTP_EVENT_TIMEOUT_HEARTBEAT),\n\t\t\t   asoc->state, asoc->ep, asoc,\n\t\t\t   transport, GFP_ATOMIC);\n\tif (error)\n\t\tasoc->base.sk->sk_err = -error;\nout_unlock:\n\tbh_unlock_sock(asoc->base.sk);\n\tsctp_transport_put(transport);\n}", "target": 1}
{"code": "int ext4_group_add(struct super_block *sb, struct ext4_new_group_data *input)\n{\n\tstruct ext4_new_flex_group_data flex_gd;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tint reserved_gdb = ext4_bg_has_super(sb, input->group) ?\n\t\tle16_to_cpu(es->s_reserved_gdt_blocks) : 0;\n\tstruct inode *inode = NULL;\n\tint gdb_off, gdb_num;\n\tint err;\n\t__u16 bg_flags = 0;\n\tgdb_num = input->group / EXT4_DESC_PER_BLOCK(sb);\n\tgdb_off = input->group % EXT4_DESC_PER_BLOCK(sb);\n\tif (gdb_off == 0 && !EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER)) {\n\t\text4_warning(sb, \"Can't resize non-sparse filesystem further\");\n\t\treturn -EPERM;\n\t}\n\tif (ext4_blocks_count(es) + input->blocks_count <\n\t    ext4_blocks_count(es)) {\n\t\text4_warning(sb, \"blocks_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\tif (le32_to_cpu(es->s_inodes_count) + EXT4_INODES_PER_GROUP(sb) <\n\t    le32_to_cpu(es->s_inodes_count)) {\n\t\text4_warning(sb, \"inodes_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\tif (reserved_gdb || gdb_off == 0) {\n\t\tif (!EXT4_HAS_COMPAT_FEATURE(sb,\n\t\t\t\t\t     EXT4_FEATURE_COMPAT_RESIZE_INODE)\n\t\t    || !le16_to_cpu(es->s_reserved_gdt_blocks)) {\n\t\t\text4_warning(sb,\n\t\t\t\t     \"No reserved GDT blocks, can't resize\");\n\t\t\treturn -EPERM;\n\t\t}\n\t\tinode = ext4_iget(sb, EXT4_RESIZE_INO);\n\t\tif (IS_ERR(inode)) {\n\t\t\text4_warning(sb, \"Error opening resize inode\");\n\t\t\treturn PTR_ERR(inode);\n\t\t}\n\t}\n\terr = verify_group_input(sb, input);\n\tif (err)\n\t\tgoto out;\n\tflex_gd.count = 1;\n\tflex_gd.groups = input;\n\tflex_gd.bg_flags = &bg_flags;\n\terr = ext4_flex_group_add(sb, inode, &flex_gd);\nout:\n\tiput(inode);\n\treturn err;\n} ", "target": 0}
{"code": "asmlinkage void bad_mode(struct pt_regs *regs, int reason, unsigned int esr)\n{\n\tconsole_verbose();\n\tpr_crit(\"Bad mode in %s handler detected, code 0x%08x\\n\",\n\t\thandler[reason], esr);\n\tdie(\"Oops - bad mode\", regs, 0);\n\tlocal_irq_disable();\n\tpanic(\"bad mode\");\n}", "target": 1}
{"code": "device_linux_md_check_authorized_cb (Daemon *daemon,\n                                     Device *device,\n                                     DBusGMethodInvocation *context,\n                                     const gchar *action_id,\n                                     guint num_user_data,\n                                     gpointer *user_data_elements)\n{\n  gchar **options = user_data_elements[0];\n  gchar *filename;\n  int n, m;\n  char *argv[128];\n  const gchar *job_name;\n  filename = NULL;\n  if (!device->priv->device_is_linux_md)\n    {\n      throw_error (context, ERROR_FAILED, \"Device is not a Linux md drive\");\n      goto out;\n    }\n  if (g_strcmp0 (device->priv->linux_md_sync_action, \"idle\") != 0)\n    {\n      throw_error (context, ERROR_FAILED, \"Array is not idle\");\n      goto out;\n    }\n  n = 0;\n  argv[n++] = \"udisks-helper-linux-md-check\";\n  argv[n++] = device->priv->device_file;\n  argv[n++] = device->priv->native_path;\n  for (m = 0; options[m] != NULL; m++)\n    {\n      if (n >= (int) sizeof(argv) - 1)\n        {\n          throw_error (context, ERROR_FAILED, \"Too many options\");\n          goto out;\n        }\n      argv[n++] = (char *) options[m];\n    }\n  argv[n++] = NULL;\n  job_name = \"LinuxMdCheck\";\n  for (n = 0; options != NULL && options[n] != NULL; n++)\n    if (strcmp (options[n], \"repair\") == 0)\n      job_name = \"LinuxMdRepair\";\n  if (!job_new (context, job_name, TRUE, device, argv, NULL, linux_md_check_completed_cb, FALSE, NULL, NULL))\n    {\n      goto out;\n    }\n out:\n  ;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const auto splits = ctx->input(0).flat<int64_t>();\n    const auto values = ctx->input(1).flat<Tidx>();\n    const Tensor& size_t = ctx->input(2);\n    const auto weights = ctx->input(3).flat<T>();\n    const int64_t weights_size = weights.size();\n    OP_REQUIRES(ctx, size_t.dims() == 0,\n                errors::InvalidArgument(\"Shape must be rank 0 but is rank \",\n                                        size_t.dims()));\n    Tidx size = size_t.scalar<Tidx>()();\n    OP_REQUIRES(\n        ctx, size >= 0,\n        errors::InvalidArgument(\"size (\", size, \") must be non-negative\"));\n    int num_rows = splits.size() - 1;\n    int num_values = values.size();\n    int batch_idx = 0;\n    OP_REQUIRES(ctx, splits.size() > 0,\n                errors::InvalidArgument(\"Splits must be non-empty\"));\n    OP_REQUIRES(ctx, splits(0) == 0,\n                errors::InvalidArgument(\"Splits must start with 0, not with \",\n                                        splits(0)));\n    OP_REQUIRES(ctx, splits(num_rows) == num_values,\n                errors::InvalidArgument(\n                    \"Splits must end with the number of values, got \",\n                    splits(num_rows), \" instead of \", num_values));\n    Tensor* out_t;\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_output(0, TensorShape({num_rows, size}), &out_t));\n    functor::SetZeroFunctor<Device, T> fill;\n    fill(ctx->eigen_device<Device>(), out_t->flat<T>());\n    const auto out = out_t->matrix<T>();\n    for (int idx = 0; idx < num_values; ++idx) {\n      while (idx >= splits(batch_idx)) {\n        batch_idx++;\n      }\n      Tidx bin = values(idx);\n      OP_REQUIRES(ctx, bin >= 0,\n                  errors::InvalidArgument(\"Input must be non-negative\"));\n      if (bin < size) {\n        if (binary_output_) {\n          out(batch_idx - 1, bin) = T(1);\n        } else {\n          T value = (weights_size > 0) ? weights(idx) : T(1);\n          out(batch_idx - 1, bin) += value;\n        }\n      }\n    }\n  }", "target": 0}
{"code": "static int nested_vmx_store_msr(struct kvm_vcpu *vcpu, u64 gpa, u32 count)\n{\n\tu32 i;\n\tstruct vmx_msr_entry e;\n\tfor (i = 0; i < count; i++) {\n\t\tstruct msr_data msr_info;\n\t\tif (kvm_vcpu_read_guest(vcpu,\n\t\t\t\t\tgpa + i * sizeof(e),\n\t\t\t\t\t&e, 2 * sizeof(u32))) {\n\t\t\tpr_warn_ratelimited(\n\t\t\t\t\"%s cannot read MSR entry (%u, 0x%08llx)\\n\",\n\t\t\t\t__func__, i, gpa + i * sizeof(e));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (nested_vmx_store_msr_check(vcpu, &e)) {\n\t\t\tpr_warn_ratelimited(\n\t\t\t\t\"%s check failed (%u, 0x%x, 0x%x)\\n\",\n\t\t\t\t__func__, i, e.index, e.reserved);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmsr_info.host_initiated = false;\n\t\tmsr_info.index = e.index;\n\t\tif (kvm_get_msr(vcpu, &msr_info)) {\n\t\t\tpr_warn_ratelimited(\n\t\t\t\t\"%s cannot read MSR (%u, 0x%x)\\n\",\n\t\t\t\t__func__, i, e.index);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (kvm_vcpu_write_guest(vcpu,\n\t\t\t\t\t gpa + i * sizeof(e) +\n\t\t\t\t\t     offsetof(struct vmx_msr_entry, value),\n\t\t\t\t\t &msr_info.data, sizeof(msr_info.data))) {\n\t\t\tpr_warn_ratelimited(\n\t\t\t\t\"%s cannot write MSR (%u, 0x%x, 0x%llx)\\n\",\n\t\t\t\t__func__, i, e.index, msr_info.data);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "  static const char* ConvertScalar(PyObject* v, Eigen::half* out) {\n    Safe_PyObjectPtr as_float = make_safe(PyNumber_Float(v));\n    double v_double = PyFloat_AS_DOUBLE(as_float.get());\n    *out = Eigen::half(v_double);\n    return nullptr;\n  }", "target": 1}
{"code": "int IniParser::write()\n{\n    int bugs = 0;\n    if (!inifile.isDirty())\n    {\n        y2debug (\"File %s did not change. Not saving.\", multiple_files ? files[0].c_str () : file.c_str ());\n\treturn 0;\n    }\n    if (read_only)\n    {\n        y2debug (\"Attempt to write file %s that was mounted read-only. Not saving.\", multiple_files ? files[0].c_str () : file.c_str ());\n\treturn 0;\n    }\n    UpdateIfModif ();\n    if (multiple_files)\n    {\n\tIniIterator\n\t    ci = inifile.getContainerBegin (),\n\t    ce = inifile.getContainerEnd ();\n\tfor (;ci != ce; ++ci)\n\t    {\n\t\tif (ci->t () == SECTION)\n\t\t    {\n\t\t\tIniSection&s = ci->s ();\n\t\t\tint wb = s.getRewriteBy (); \n\t\t\tstring filename = getFileName (s.getName (), wb);\n\t\t\tdeleted_sections.erase (filename);\n\t\t\tif (!s.isDirty ()) {\n\t\t\t    y2debug (\"Skipping file %s that was not changed.\", filename.c_str());\n\t\t\t    continue;\n\t\t\t}\n\t\t\ts.initReadBy ();\n\t\t\tPathname pn (filename);\n\t\t\tPathInfo::assert_dir (pn.dirname ());\n\t\t\tofstream of(filename.c_str());\n\t\t\tif (!of.good())\n\t\t\t{\n\t\t\t    bugs++;\n\t\t\t    y2error (\"Can not open file %s for write\", filename.c_str());\n\t\t\t    continue;\n\t\t\t}\n\t\t\twrite_helper (s, of, 0);\n\t\t\ts.clean();\n\t\t\tof.close ();\n\t\t    }\n\t\telse\n\t\t    {\n\t\t\ty2error (\"Value %s encountered at multifile top level\",\n\t\t\t\t ci->e ().getName ());\n\t\t    }\n\t    }\n\tfor (set<string>::iterator i = deleted_sections.begin (); i!=deleted_sections.end();i++)\n\t    if (multi_files.find (*i) != multi_files.end ()) {\n\t\ty2debug (\"Removing file %s\\n\", (*i).c_str());\n\t\tunlink ((*i).c_str());\n\t    }\n    }\n    else\n    {\n\tPathname pn (file);\n\tPathInfo::assert_dir (pn.dirname ());\n\tofstream of(file.c_str());\n\tif (!of.good())\n\t{\n\t    y2error (\"Can not open file %s for write\", file.c_str());\n\t    return -1;\n\t}\n\twrite_helper (inifile, of, 0);\n\tof.close();\n\ttimestamp = getTimeStamp ();\n    }\n    inifile.clean ();\n    return bugs ? -1 : 0;\n}", "target": 1}
{"code": "comics_regex_quote (const gchar *unquoted_string)\n{\n\tconst gchar *p;\n\tGString *dest;\n\tdest = g_string_new (\"'\");\n\tp = unquoted_string;\n\twhile (*p) {\n\t\tswitch (*p) {\n\t\t\tcase ('*'):\n\t\t\tcase ('?'):\n\t\t\tcase ('['):\n\t\t\t\tg_string_append (dest, \"[\");\n\t\t\t\tg_string_append_c (dest, *p);\n\t\t\t\tg_string_append (dest, \"]\");\n\t\t\t\tbreak;\n\t\t\tcase ('\\\\'):\n\t\t\t\tg_string_append (dest, \"[\\\\\\\\]\");\n\t\t\t\tbreak;\n\t\t\tcase ('\\''):\n\t\t\t\tg_string_append (dest, \"'\\\\''\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tg_string_append_c (dest, *p);\n\t\t\t\tbreak;\n\t\t}\n\t\t++p;\n\t}\n\tg_string_append_c (dest, '\\'');\n\treturn g_string_free (dest, FALSE);\n}", "target": 1}
{"code": "static pid_t get_task_reaper_pid(pid_t task)\n{\n\tint sock[2];\n\tpid_t pid;\n\tpid_t ret = -1;\n\tchar v = '0';\n\tstruct ucred cred;\n\tif (socketpair(AF_UNIX, SOCK_DGRAM, 0, sock) < 0) {\n\t\tperror(\"socketpair\");\n\t\treturn -1;\n\t}\n\tpid = fork();\n\tif (pid < 0)\n\t\tgoto out;\n\tif (!pid) {\n\t\tclose(sock[1]);\n\t\twrite_task_init_pid_exit(sock[0], task);\n\t}\n\tif (!recv_creds(sock[1], &cred, &v))\n\t\tgoto out;\n\tret = cred.pid;\nout:\n\tclose(sock[0]);\n\tclose(sock[1]);\n\treturn ret;\n}", "target": 0}
{"code": "case_map(OnigCaseFoldType* flagP, const OnigUChar** pp,\n\t const OnigUChar* end, OnigUChar* to, OnigUChar* to_end,\n\t const struct OnigEncodingTypeST* enc)\n{\n  OnigCodePoint code;\n  OnigUChar *to_start = to;\n  OnigCaseFoldType flags = *flagP;\n  while (*pp < end && to < to_end) {\n    code = *(*pp)++;\n    if (code == 0xF2) {\n      if (flags & ONIGENC_CASE_UPCASE) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\tcode = 0xD3;\n      }\n      else if (flags & ONIGENC_CASE_FOLD) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\tcode = 0xF3;\n      }\n    }\n    else if (code == 0xB5) {\n      if (flags & ONIGENC_CASE_UPCASE) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\tcode = 0xCC;\n      }\n      else if (flags & ONIGENC_CASE_FOLD) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\tcode = 0xEC;\n      }\n    }\n    else if (code == 0xC0 || code == 0xE0 || code == 0xB6)\n      ;\n    else if ((EncCP1253_CtypeTable[code] & BIT_CTYPE_UPPER)\n\t     && (flags & (ONIGENC_CASE_DOWNCASE | ONIGENC_CASE_FOLD))) {\n      flags |= ONIGENC_CASE_MODIFIED;\n      code = ENC_CP1253_TO_LOWER_CASE(code);\n    }\n    else if ((EncCP1253_CtypeTable[code] & BIT_CTYPE_LOWER)\n\t     && (flags & ONIGENC_CASE_UPCASE)) {\n      flags |= ONIGENC_CASE_MODIFIED;\n      if (code == 0xDC)\n\tcode = 0xA2;\n      else if (code >= 0xDD && code <= 0xDF)\n\tcode -= 0x25;\n      else if (code == 0xFC)\n\tcode = 0xBC;\n      else if (code == 0xFD || code == 0xFE)\n\tcode -= 0x3F;\n      else\n\tcode -= 0x20;\n    }\n    *to++ = code;\n    if (flags & ONIGENC_CASE_TITLECASE)  \n      flags ^= (ONIGENC_CASE_UPCASE | ONIGENC_CASE_DOWNCASE | ONIGENC_CASE_TITLECASE);\n  }\n  *flagP = flags;\n  return (int )(to - to_start);\n}", "target": 0}
{"code": "static void init_reg_state(struct bpf_verifier_env *env,\n\t\t\t   struct bpf_func_state *state)\n{\n\tstruct bpf_reg_state *regs = state->regs;\n\tint i;\n\tfor (i = 0; i < MAX_BPF_REG; i++) {\n\t\tmark_reg_not_init(env, regs, i);\n\t\tregs[i].live = REG_LIVE_NONE;\n\t\tregs[i].parent = NULL;\n\t\tregs[i].subreg_def = DEF_NOT_SUBREG;\n\t}\n\tregs[BPF_REG_FP].type = PTR_TO_STACK;\n\tmark_reg_known_zero(env, regs, BPF_REG_FP);\n\tregs[BPF_REG_FP].frameno = state->frameno;\n}", "target": 0}
{"code": "static int switch_listening_mode(GDHCPClient *dhcp_client,\n\t\t\t\t\tListenMode listen_mode)\n{\n\tGIOChannel *listener_channel;\n\tint listener_sockfd;\n\tif (dhcp_client->listen_mode == listen_mode)\n\t\treturn 0;\n\tdebug(dhcp_client, \"switch listening mode (%d ==> %d)\",\n\t\t\t\tdhcp_client->listen_mode, listen_mode);\n\tif (dhcp_client->listen_mode != L_NONE) {\n\t\tif (dhcp_client->listener_watch > 0)\n\t\t\tg_source_remove(dhcp_client->listener_watch);\n\t\tdhcp_client->listen_mode = L_NONE;\n\t\tdhcp_client->listener_sockfd = -1;\n\t\tdhcp_client->listener_watch = 0;\n\t}\n\tif (listen_mode == L_NONE)\n\t\treturn 0;\n\tif (listen_mode == L2)\n\t\tlistener_sockfd = dhcp_l2_socket(dhcp_client->ifindex);\n\telse if (listen_mode == L3) {\n\t\tif (dhcp_client->type == G_DHCP_IPV6)\n\t\t\tlistener_sockfd = dhcp_l3_socket(DHCPV6_CLIENT_PORT,\n\t\t\t\t\t\t\tdhcp_client->interface,\n\t\t\t\t\t\t\tAF_INET6);\n\t\telse\n\t\t\tlistener_sockfd = dhcp_l3_socket(CLIENT_PORT,\n\t\t\t\t\t\t\tdhcp_client->interface,\n\t\t\t\t\t\t\tAF_INET);\n\t} else if (listen_mode == L_ARP)\n\t\tlistener_sockfd = arp_socket(dhcp_client->ifindex);\n\telse\n\t\treturn -EIO;\n\tif (listener_sockfd < 0)\n\t\treturn -EIO;\n\tlistener_channel = g_io_channel_unix_new(listener_sockfd);\n\tif (!listener_channel) {\n\t\tclose(listener_sockfd);\n\t\treturn -EIO;\n\t}\n\tdhcp_client->listen_mode = listen_mode;\n\tdhcp_client->listener_sockfd = listener_sockfd;\n\tg_io_channel_set_close_on_unref(listener_channel, TRUE);\n\tdhcp_client->listener_watch =\n\t\t\tg_io_add_watch_full(listener_channel, G_PRIORITY_HIGH,\n\t\t\t\tG_IO_IN | G_IO_NVAL | G_IO_ERR | G_IO_HUP,\n\t\t\t\t\t\tlistener_event, g_dhcp_client_ref(dhcp_client),\n\t\t\t\t\t\t\t\tlistener_watch_destroy);\n\tg_io_channel_unref(listener_channel);\n\treturn 0;\n}", "target": 0}
{"code": "static bool generic_new(struct nf_conn *ct, const struct sk_buff *skb,\n\t\t\tunsigned int dataoff, unsigned int *timeouts)\n{\n\treturn true;\n}", "target": 1}
{"code": "static int xfrm_dump_policy(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];\n\tstruct xfrm_dump_info info;\n\tBUILD_BUG_ON(sizeof(struct xfrm_policy_walk) >\n\t\t     sizeof(cb->args) - sizeof(cb->args[0]));\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\tif (!cb->args[0]) {\n\t\tcb->args[0] = 1;\n\t\txfrm_policy_walk_init(walk, XFRM_POLICY_TYPE_ANY);\n\t}\n\t(void) xfrm_policy_walk(net, walk, dump_one_policy, &info);\n\treturn skb->len;\n}", "target": 1}
{"code": "static u32 adpt_ioctl_to_context(adpt_hba * pHba, void *reply)\n{\n#if BITS_PER_LONG == 32\n\treturn (u32)(unsigned long)reply;\n#else\n\tulong flags = 0;\n\tu32 nr, i;\n\tspin_lock_irqsave(pHba->host->host_lock, flags);\n\tnr = ARRAY_SIZE(pHba->ioctl_reply_context);\n\tfor (i = 0; i < nr; i++) {\n\t\tif (pHba->ioctl_reply_context[i] == NULL) {\n\t\t\tpHba->ioctl_reply_context[i] = reply;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(pHba->host->host_lock, flags);\n\tif (i >= nr) {\n\t\tprintk(KERN_WARNING\"%s: Too many outstanding \"\n\t\t\t\t\"ioctl commands\\n\", pHba->name);\n\t\treturn (u32)-1;\n\t}\n\treturn i;\n#endif\n}", "target": 1}
{"code": "static void FNAME_DECL(compress_row0)(const PIXEL *cur_row, unsigned int width)\n{\n    DECLARE_STATE_VARIABLES;\n    const unsigned int bpc_mask = BPC_MASK;\n    int pos = 0;\n    while ((DEFwmimax > (int)state->wmidx) && (state->wmileft <= width)) {\n        if (state->wmileft) {\n            FNAME_CALL(compress_row0_seg)(pos, cur_row, pos + state->wmileft,\n                                          bppmask[state->wmidx], bpc_mask);\n            width -= state->wmileft;\n            pos += state->wmileft;\n        }\n        state->wmidx++;\n        set_wm_trigger(state);\n        state->wmileft = DEFwminext;\n    }\n    if (width) {\n        FNAME_CALL(compress_row0_seg)(pos, cur_row, pos + width,\n                                      bppmask[state->wmidx], bpc_mask);\n        if (DEFwmimax > (int)state->wmidx) {\n            state->wmileft -= width;\n        }\n    }\n    spice_assert((int)state->wmidx <= DEFwmimax);\n    spice_assert(state->wmidx <= 32);\n    spice_assert(DEFwminext > 0);\n}", "target": 0}
{"code": " bool RenderFrameHostImpl::OnMessageReceived(const IPC::Message &msg) {\n  if (render_view_host_->IsSwappedOut()) {\n    if (!SwappedOutMessages::CanHandleWhileSwappedOut(msg)) {\n      if (msg.is_sync()) {\n        IPC::Message* reply = IPC::SyncMessage::GenerateReply(&msg);\n        reply->set_reply_error();\n        Send(reply);\n      }\n      return true;\n    }\n  }\n   if (delegate_->OnMessageReceived(this, msg))\n     return true;\n  if (cross_process_frame_connector_ &&\n      cross_process_frame_connector_->OnMessageReceived(msg))\n    return true;\n  bool handled = true;\n  bool msg_is_ok = true;\n  IPC_BEGIN_MESSAGE_MAP_EX(RenderFrameHostImpl, msg, msg_is_ok)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_Detach, OnDetach)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_FrameFocused, OnFrameFocused)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidStartProvisionalLoadForFrame,\n                        OnDidStartProvisionalLoadForFrame)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidFailProvisionalLoadWithError,\n                        OnDidFailProvisionalLoadWithError)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidRedirectProvisionalLoad,\n                        OnDidRedirectProvisionalLoad)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidFailLoadWithError,\n                        OnDidFailLoadWithError)\n    IPC_MESSAGE_HANDLER_GENERIC(FrameHostMsg_DidCommitProvisionalLoad,\n                                OnNavigate(msg))\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidStartLoading, OnDidStartLoading)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidStopLoading, OnDidStopLoading)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_OpenURL, OnOpenURL)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_BeforeUnload_ACK, OnBeforeUnloadACK)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_SwapOut_ACK, OnSwapOutACK)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_ContextMenu, OnContextMenu)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_JavaScriptExecuteResponse,\n                        OnJavaScriptExecuteResponse)\n  IPC_END_MESSAGE_MAP_EX()\n  if (!msg_is_ok) {\n    RecordAction(base::UserMetricsAction(\"BadMessageTerminate_RFH\"));\n    GetProcess()->ReceivedBadMessage();\n  }\n  return handled;\n}", "target": 0}
{"code": "static void terminate(int sig)\n{\n    unlink(socket_file);\n    exit(0);\n}", "target": 0}
{"code": "SYSCALL_DEFINE5(waitid, int, which, pid_t, upid, struct siginfo __user *,\n\t\tinfop, int, options, struct rusage __user *, ru)\n{\n\tstruct rusage r;\n\tstruct waitid_info info = {.status = 0};\n\tlong err = kernel_waitid(which, upid, &info, options, ru ? &r : NULL);\n\tint signo = 0;\n\tif (err > 0) {\n\t\tsigno = SIGCHLD;\n\t\terr = 0;\n\t}\n\tif (!err) {\n\t\tif (ru && copy_to_user(ru, &r, sizeof(struct rusage)))\n\t\t\treturn -EFAULT;\n\t}\n\tif (!infop)\n\t\treturn err;\n\tuser_access_begin();\n\tunsafe_put_user(signo, &infop->si_signo, Efault);\n\tunsafe_put_user(0, &infop->si_errno, Efault);\n\tunsafe_put_user(info.cause, &infop->si_code, Efault);\n\tunsafe_put_user(info.pid, &infop->si_pid, Efault);\n\tunsafe_put_user(info.uid, &infop->si_uid, Efault);\n\tunsafe_put_user(info.status, &infop->si_status, Efault);\n\tuser_access_end();\n\treturn err;\nEfault:\n\tuser_access_end();\n\treturn -EFAULT;\n}", "target": 1}
{"code": "static unsigned long get_seg_limit(struct pt_regs *regs, int seg_reg_idx)\n{\n\tstruct desc_struct *desc;\n\tunsigned long limit;\n\tshort sel;\n\tsel = get_segment_selector(regs, seg_reg_idx);\n\tif (sel < 0)\n\t\treturn 0;\n\tif (user_64bit_mode(regs) || v8086_mode(regs))\n\t\treturn -1L;\n\tif (!sel)\n\t\treturn 0;\n\tdesc = get_desc(sel);\n\tif (!desc)\n\t\treturn 0;\n\tlimit = get_desc_limit(desc);\n\tif (desc->g)\n\t\tlimit = (limit << 12) + 0xfff;\n\treturn limit;\n}", "target": 1}
{"code": "OFCondition DcmSCP::listen()\n{\n  dcmEnableAutomaticInputDataCorrection.set( OFFalse );\n  OFCondition cond = EC_Normal;\n  if( !dcmDataDict.isDictionaryLoaded() )\n    DCMNET_WARN(\"No data dictionary loaded, check environment variable: \" << DCM_DICT_ENVIRONMENT_VARIABLE);\n#ifndef DISABLE_PORT_PERMISSION_CHECK\n#ifdef HAVE_GETEUID\n  if( m_cfg->getPort() < 1024 && geteuid() != 0 )\n  {\n    DCMNET_ERROR(\"No privileges to open this network port (\" << m_cfg->getPort() << \")\");\n    return NET_EC_InsufficientPortPrivileges;\n  }\n#endif\n#endif\n  T_ASC_Network *network = NULL;\n  cond = ASC_initializeNetwork( NET_ACCEPTOR, OFstatic_cast(int, m_cfg->getPort()), m_cfg->getACSETimeout(), &network );\n  if( cond.bad() )\n    return cond;\n#if defined(HAVE_SETUID) && defined(HAVE_GETUID)\n  setuid( getuid() );\n#endif\n  while( cond.good() && !stopAfterCurrentAssociation() )\n  {\n    cond = waitForAssociationRQ(network);\n  }\n  cond = ASC_dropNetwork( &network );\n  network = NULL;\n  return cond;\n}", "target": 1}
{"code": "u32 GetHintFormat(GF_TrackBox *trak)\n{\n\tGF_HintMediaHeaderBox *hmhd = (GF_HintMediaHeaderBox *)trak->Media->information->InfoHeader;\n\tif (hmhd->type != GF_ISOM_BOX_TYPE_HMHD)\n\t\treturn 0;\n\tif (!hmhd || !hmhd->subType) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\t\tif (!hmhd) return a ? a->type : 0;\n\t\tif (a) hmhd->subType = a->type;\n\t\treturn hmhd->subType;\n\t}\n\treturn hmhd->subType;\n}", "target": 1}
{"code": "exo_open_find_scheme (const gchar *string)\n{\n  gchar *current_dir;\n  gchar *uri;\n  gchar *path;\n  if (g_path_is_absolute (string))\n    return exo_open_get_path (string);\n  current_dir = g_get_current_dir ();\n  path = g_build_filename (current_dir, string, NULL);\n  g_free (current_dir);\n  if (g_file_test (path, G_FILE_TEST_EXISTS))\n    {\n       uri = exo_open_get_path (path);\n       g_free (path);\n       return uri;\n    }\n  g_free (path);\n  if (g_regex_match_simple (MATCH_PATTERN_EMAIL, string, G_REGEX_CASELESS, 0))\n    return g_strconcat (\"mailto:\", string, NULL);\n  if (g_regex_match_simple (MATCH_PATTERN_HTTP, string, G_REGEX_CASELESS, 0))\n    return g_strconcat (\"http:\n  return NULL;\n}", "target": 0}
{"code": "static int __io_sync_cancel(struct io_uring_task *tctx,\n\t\t\t    struct io_cancel_data *cd, int fd)\n{\n\tstruct io_ring_ctx *ctx = cd->ctx;\n\tif ((cd->flags & IORING_ASYNC_CANCEL_FD) &&\n\t    (cd->flags & IORING_ASYNC_CANCEL_FD_FIXED)) {\n\t\tunsigned long file_ptr;\n\t\tif (unlikely(fd > ctx->nr_user_files))\n\t\t\treturn -EBADF;\n\t\tfd = array_index_nospec(fd, ctx->nr_user_files);\n\t\tfile_ptr = io_fixed_file_slot(&ctx->file_table, fd)->file_ptr;\n\t\tcd->file = (struct file *) (file_ptr & FFS_MASK);\n\t\tif (!cd->file)\n\t\t\treturn -EBADF;\n\t}\n\treturn __io_async_cancel(cd, tctx, 0);\n}", "target": 1}
{"code": "isdn_statstr(void)\n{\n\tstatic char istatbuf[2048];\n\tchar *p;\n\tint i;\n\tsprintf(istatbuf, \"idmap:\\t\");\n\tp = istatbuf + strlen(istatbuf);\n\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\tsprintf(p, \"%s \", (dev->drvmap[i] < 0) ? \"-\" : dev->drvid[dev->drvmap[i]]);\n\t\tp = istatbuf + strlen(istatbuf);\n\t}\n\tsprintf(p, \"\\nchmap:\\t\");\n\tp = istatbuf + strlen(istatbuf);\n\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\tsprintf(p, \"%d \", dev->chanmap[i]);\n\t\tp = istatbuf + strlen(istatbuf);\n\t}\n\tsprintf(p, \"\\ndrmap:\\t\");\n\tp = istatbuf + strlen(istatbuf);\n\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\tsprintf(p, \"%d \", dev->drvmap[i]);\n\t\tp = istatbuf + strlen(istatbuf);\n\t}\n\tsprintf(p, \"\\nusage:\\t\");\n\tp = istatbuf + strlen(istatbuf);\n\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\tsprintf(p, \"%d \", dev->usage[i]);\n\t\tp = istatbuf + strlen(istatbuf);\n\t}\n\tsprintf(p, \"\\nflags:\\t\");\n\tp = istatbuf + strlen(istatbuf);\n\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++) {\n\t\tif (dev->drv[i]) {\n\t\t\tsprintf(p, \"%ld \", dev->drv[i]->online);\n\t\t\tp = istatbuf + strlen(istatbuf);\n\t\t} else {\n\t\t\tsprintf(p, \"? \");\n\t\t\tp = istatbuf + strlen(istatbuf);\n\t\t}\n\t}\n\tsprintf(p, \"\\nphone:\\t\");\n\tp = istatbuf + strlen(istatbuf);\n\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\tsprintf(p, \"%s \", dev->num[i]);\n\t\tp = istatbuf + strlen(istatbuf);\n\t}\n\tsprintf(p, \"\\n\");\n\treturn istatbuf;\n}", "target": 0}
{"code": "ffi_prep_closure_loc (ffi_closure *closure,\n                      ffi_cif* cif,\n                      void (*fun)(ffi_cif*,void*,void**,void*),\n                      void *user_data,\n                      void *codeloc)\n{\n  if (cif->abi != FFI_SYSV)\n    return FFI_BAD_ABI;\n  void (*start)(void);\n  if (cif->flags & AARCH64_FLAG_ARG_V)\n    start = ffi_closure_SYSV_V;\n  else\n    start = ffi_closure_SYSV;\n#if FFI_EXEC_TRAMPOLINE_TABLE\n#ifdef __MACH__\n  void **config = (void **)((uint8_t *)codeloc - PAGE_MAX_SIZE);\n  config[0] = closure;\n  config[1] = start;\n#endif\n#else\n  static const unsigned char trampoline[16] = {\n    0x90, 0x00, 0x00, 0x58,\t\n    0xf1, 0xff, 0xff, 0x10,\t\n    0x00, 0x02, 0x1f, 0xd6\t\n  };\n  char *tramp = closure->tramp;\n  memcpy (tramp, trampoline, sizeof(trampoline));\n  *(UINT64 *)(tramp + 16) = (uintptr_t)start;\n  ffi_clear_cache(tramp, tramp + FFI_TRAMPOLINE_SIZE);\n#endif\n  closure->cif = cif;\n  closure->fun = fun;\n  closure->user_data = user_data;\n  return FFI_OK;\n}", "target": 1}
{"code": "ECPKPARAMETERS *ec_asn1_group2pkparameters(const EC_GROUP *group,\n                                           ECPKPARAMETERS *params)\n{\n    int ok = 1, tmp;\n    ECPKPARAMETERS *ret = params;\n    if (ret == NULL) {\n        if ((ret = ECPKPARAMETERS_new()) == NULL) {\n            ECerr(EC_F_EC_ASN1_GROUP2PKPARAMETERS, ERR_R_MALLOC_FAILURE);\n            return NULL;\n        }\n    } else {\n        if (ret->type == 0 && ret->value.named_curve)\n            ASN1_OBJECT_free(ret->value.named_curve);\n        else if (ret->type == 1 && ret->value.parameters)\n            ECPARAMETERS_free(ret->value.parameters);\n    }\n    if (EC_GROUP_get_asn1_flag(group)) {\n        tmp = EC_GROUP_get_curve_name(group);\n        if (tmp) {\n            ret->type = 0;\n            if ((ret->value.named_curve = OBJ_nid2obj(tmp)) == NULL)\n                ok = 0;\n        } else\n            ok = 0;\n    } else {\n        ret->type = 1;\n        if ((ret->value.parameters =\n             ec_asn1_group2parameters(group, NULL)) == NULL)\n            ok = 0;\n    }\n    if (!ok) {\n        ECPKPARAMETERS_free(ret);\n        return NULL;\n    }\n    return ret;\n}", "target": 0}
{"code": "static INLINE UINT16 ntlm_av_pair_get_id(const NTLM_AV_PAIR* pAvPair)\n{\n\tUINT16 AvId;\n\tData_Read_UINT16(&pAvPair->AvId, AvId);\n\treturn AvId;\n}", "target": 1}
{"code": "QPDF::QPDF() :\n    encrypted(false),\n    encryption_initialized(false),\n    ignore_xref_streams(false),\n    suppress_warnings(false),\n    out_stream(&std::cout),\n    err_stream(&std::cerr),\n    attempt_recovery(true),\n    encryption_V(0),\n    encryption_R(0),\n    encrypt_metadata(true),\n    cf_stream(e_none),\n    cf_string(e_none),\n    cf_file(e_none),\n    cached_key_objid(0),\n    cached_key_generation(0),\n    pushed_inherited_attributes_to_pages(false),\n    copied_stream_data_provider(0),\n    first_xref_item_offset(0),\n    uncompressed_after_compressed(false)\n{\n}", "target": 1}
{"code": "spnego_gss_wrap_iov(OM_uint32 *minor_status,\n\t\t    gss_ctx_id_t context_handle,\n\t\t    int conf_req_flag,\n\t\t    gss_qop_t qop_req,\n\t\t    int *conf_state,\n\t\t    gss_iov_buffer_desc *iov,\n\t\t    int iov_count)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_iov(minor_status,\n\t\t\t   context_handle,\n\t\t\t   conf_req_flag,\n\t\t\t   qop_req,\n\t\t\t   conf_state,\n\t\t\t   iov,\n\t\t\t   iov_count);\n\treturn (ret);\n}", "target": 1}
{"code": "static char *get_header(FILE *fp)\n{\n    long start;\n    char *header;\n    header = calloc(1, 1024);\n    start = ftell(fp);\n    fseek(fp, 0, SEEK_SET);\n    SAFE_E(fread(header, 1, 1023, fp), 1023, \"Failed to load PDF header.\\n\");\n    fseek(fp, start, SEEK_SET);\n    return header;\n}", "target": 1}
{"code": "int do_remount_sb(struct super_block *sb, int flags, void *data, int force)\n{\n\tint retval;\n\tint remount_ro;\n\tif (sb->s_writers.frozen != SB_UNFROZEN)\n\t\treturn -EBUSY;\n#ifdef CONFIG_BLOCK\n\tif (!(flags & MS_RDONLY) && bdev_read_only(sb->s_bdev))\n\t\treturn -EACCES;\n#endif\n\tif (flags & MS_RDONLY)\n\t\tacct_auto_close(sb);\n\tshrink_dcache_sb(sb);\n\tsync_filesystem(sb);\n\tremount_ro = (flags & MS_RDONLY) && !(sb->s_flags & MS_RDONLY);\n\tif (remount_ro) {\n\t\tif (force) {\n\t\t\tmark_files_ro(sb);\n\t\t} else {\n\t\t\tretval = sb_prepare_remount_readonly(sb);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t}\n\t}\n\tif (sb->s_op->remount_fs) {\n\t\tretval = sb->s_op->remount_fs(sb, &flags, data);\n\t\tif (retval) {\n\t\t\tif (!force)\n\t\t\t\tgoto cancel_readonly;\n\t\t\tWARN(1, \"forced remount of a %s fs returned %i\\n\",\n\t\t\t     sb->s_type->name, retval);\n\t\t}\n\t}\n\tsb->s_flags = (sb->s_flags & ~MS_RMT_MASK) | (flags & MS_RMT_MASK);\n\tsmp_wmb();\n\tsb->s_readonly_remount = 0;\n\tif (remount_ro && sb->s_bdev)\n\t\tinvalidate_bdev(sb->s_bdev);\n\treturn 0;\ncancel_readonly:\n\tsb->s_readonly_remount = 0;\n\treturn retval;\n}", "target": 1}
{"code": "static int rds_loop_xmit(struct rds_connection *conn, struct rds_message *rm,\n\t\t\t unsigned int hdr_off, unsigned int sg,\n\t\t\t unsigned int off)\n{\n\tif (rm->m_inc.i_hdr.h_flags & RDS_FLAG_CONG_BITMAP) {\n\t\trds_cong_map_updated(conn->c_fcong, ~(u64) 0);\n\t\treturn sizeof(struct rds_header) + RDS_CONG_MAP_BYTES;\n\t}\n\tBUG_ON(hdr_off || sg || off);\n\trds_inc_init(&rm->m_inc, conn, conn->c_laddr);\n\trds_message_addref(rm);\n\trds_recv_incoming(conn, conn->c_laddr, conn->c_faddr, &rm->m_inc,\n\t\t\t  GFP_KERNEL, KM_USER0);\n\trds_send_drop_acked(conn, be64_to_cpu(rm->m_inc.i_hdr.h_sequence),\n\t\t\t    NULL);\n\trds_inc_put(&rm->m_inc);\n\treturn sizeof(struct rds_header) + be32_to_cpu(rm->m_inc.i_hdr.h_len);\n}", "target": 1}
{"code": "bgp_attr_get_as_size(netdissect_options *ndo,\n                     uint8_t bgpa_type, const u_char *pptr, int len)\n{\n    const u_char *tptr = pptr;\n    if (bgpa_type == BGPTYPE_AS4_PATH) {\n        return 4;\n    }\n    while (tptr < pptr + len) {\n        ND_TCHECK(tptr[0]);\n        if (tptr[0] < BGP_AS_SEG_TYPE_MIN || tptr[0] > BGP_AS_SEG_TYPE_MAX) {\n            goto trunc;\n        }\n        ND_TCHECK(tptr[1]);\n        tptr += 2 + tptr[1] * 2;\n    }\n    if (tptr == pptr + len) {\n        return 2;\n    }\ntrunc:\n   return 4;\n}", "target": 0}
{"code": "static int tls12_sigalg_allowed(SSL *s, int op, const unsigned char *ptmp)\n\t{\n\tconst tls12_hash_info *hinf = tls12_get_hash_info(ptmp[0]);\n\tif (!hinf || !hinf->mfunc)\n\t\treturn 0;\n\tif (tls12_get_pkey_idx(ptmp[1]) == -1)\n\t\treturn 0;\n\treturn ssl_security(s, op, hinf->secbits, hinf->nid, (void *)ptmp);\n\t}", "target": 0}
{"code": "static struct sock *x25_make_new(struct sock *osk)\n{\n\tstruct sock *sk = NULL;\n\tstruct x25_sock *x25, *ox25;\n\tif (osk->sk_type != SOCK_SEQPACKET)\n\t\tgoto out;\n\tif ((sk = x25_alloc_socket(sock_net(osk), 0)) == NULL)\n\t\tgoto out;\n\tx25 = x25_sk(sk);\n\tsk->sk_type        = osk->sk_type;\n\tsk->sk_priority    = osk->sk_priority;\n\tsk->sk_protocol    = osk->sk_protocol;\n\tsk->sk_rcvbuf      = osk->sk_rcvbuf;\n\tsk->sk_sndbuf      = osk->sk_sndbuf;\n\tsk->sk_state       = TCP_ESTABLISHED;\n\tsk->sk_backlog_rcv = osk->sk_backlog_rcv;\n\tsock_copy_flags(sk, osk);\n\tox25 = x25_sk(osk);\n\tx25->t21        = ox25->t21;\n\tx25->t22        = ox25->t22;\n\tx25->t23        = ox25->t23;\n\tx25->t2         = ox25->t2;\n\tx25->flags\t= ox25->flags;\n\tx25->facilities = ox25->facilities;\n\tx25->dte_facilities = ox25->dte_facilities;\n\tx25->cudmatchlength = ox25->cudmatchlength;\n\tclear_bit(X25_INTERRUPT_FLAG, &x25->flags);\n\tx25_init_timers(sk);\nout:\n\treturn sk;\n}", "target": 0}
{"code": "int emulate_int_real(struct x86_emulate_ctxt *ctxt, int irq)\n{\n\tstruct x86_emulate_ops *ops = ctxt->ops;\n\tint rc;\n\tstruct desc_ptr dt;\n\tgva_t cs_addr;\n\tgva_t eip_addr;\n\tu16 cs, eip;\n\tctxt->src.val = ctxt->eflags;\n\trc = em_push(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tctxt->eflags &= ~(EFLG_IF | EFLG_TF | EFLG_AC);\n\tctxt->src.val = get_segment_selector(ctxt, VCPU_SREG_CS);\n\trc = em_push(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tctxt->src.val = ctxt->_eip;\n\trc = em_push(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tops->get_idt(ctxt, &dt);\n\teip_addr = dt.address + (irq << 2);\n\tcs_addr = dt.address + (irq << 2) + 2;\n\trc = ops->read_std(ctxt, cs_addr, &cs, 2, &ctxt->exception);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = ops->read_std(ctxt, eip_addr, &eip, 2, &ctxt->exception);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = load_segment_descriptor(ctxt, cs, VCPU_SREG_CS);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tctxt->_eip = eip;\n\treturn rc;\n}", "target": 0}
{"code": "clear_cached_dir(cached_dir_t *d)\n{\n  tor_free(d->dir);\n  tor_free(d->dir_z);\n  memset(d, 0, sizeof(cached_dir_t));\n}", "target": 0}
{"code": "boost::optional<SaplingOutgoingPlaintext> SaplingOutgoingPlaintext::decrypt(\n    const SaplingOutCiphertext &ciphertext,\n    const uint256& ovk,\n    const uint256& cv,\n    const uint256& cm,\n    const uint256& epk\n)\n{\n    auto pt = AttemptSaplingOutDecryption(ciphertext, ovk, cv, cm, epk);\n    if (!pt) {\n        return boost::none;\n    }\n    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n    ss << pt.get();\n    SaplingOutgoingPlaintext ret;\n    ss >> ret;\n    assert(ss.size() == 0);\n    return ret;\n}", "target": 1}
{"code": "SMB2_sess_establish_session(struct SMB2_sess_data *sess_data)\n{\n\tint rc = 0;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tmutex_lock(&ses->server->srv_mutex);\n\tif (ses->server->sign && ses->server->ops->generate_signingkey) {\n\t\trc = ses->server->ops->generate_signingkey(ses);\n\t\tkfree(ses->auth_key.response);\n\t\tses->auth_key.response = NULL;\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI,\n\t\t\t\t\"SMB3 session key generation failed\\n\");\n\t\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t\tgoto keygen_exit;\n\t\t}\n\t}\n\tif (!ses->server->session_estab) {\n\t\tses->server->sequence_number = 0x2;\n\t\tses->server->session_estab = true;\n\t}\n\tmutex_unlock(&ses->server->srv_mutex);\n\tcifs_dbg(FYI, \"SMB2/3 session established successfully\\n\");\n\tspin_lock(&GlobalMid_Lock);\n\tses->status = CifsGood;\n\tses->need_reconnect = false;\n\tspin_unlock(&GlobalMid_Lock);\nkeygen_exit:\n\tif (!ses->server->sign) {\n\t\tkfree(ses->auth_key.response);\n\t\tses->auth_key.response = NULL;\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "nfs4_open_revalidate(struct inode *dir, struct dentry *dentry, int openflags, struct nameidata *nd)\n{\n\tstruct path path = {\n\t\t.mnt = nd->path.mnt,\n\t\t.dentry = dentry,\n\t};\n\tstruct rpc_cred *cred;\n\tstruct nfs4_state *state;\n\tcred = rpc_lookup_cred();\n\tif (IS_ERR(cred))\n\t\treturn PTR_ERR(cred);\n\tstate = nfs4_do_open(dir, &path, openflags, NULL, cred);\n\tput_rpccred(cred);\n\tif (IS_ERR(state)) {\n\t\tswitch (PTR_ERR(state)) {\n\t\t\tcase -EPERM:\n\t\t\tcase -EACCES:\n\t\t\tcase -EDQUOT:\n\t\t\tcase -ENOSPC:\n\t\t\tcase -EROFS:\n\t\t\t\tlookup_instantiate_filp(nd, (struct dentry *)state, NULL);\n\t\t\t\treturn 1;\n\t\t\tdefault:\n\t\t\t\tgoto out_drop;\n\t\t}\n\t}\n\tif (state->inode == dentry->d_inode) {\n\t\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\t\tnfs4_intent_set_file(nd, &path, state);\n\t\treturn 1;\n\t}\n\tnfs4_close_sync(&path, state, openflags);\nout_drop:\n\td_drop(dentry);\n\treturn 0;\n}", "target": 1}
{"code": "jiffies_to_timespec(const unsigned long jiffies, struct timespec *value)\n{\n\tu64 nsec = (u64)jiffies * TICK_NSEC;\n\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &value->tv_nsec);\n}", "target": 1}
{"code": "static void _ltc_ecc_free_public_key(struct ecc_public_key *s)\n{\n\tif (!s)\n\t\treturn;\n\tcrypto_bignum_free(s->x);\n\tcrypto_bignum_free(s->y);\n}", "target": 1}
{"code": "StatusOr<FullTypeDef> SpecializeType(const AttrSlice& attrs,\n                                     const OpDef& op_def) {\n  FullTypeDef ft;\n  ft.set_type_id(TFT_PRODUCT);\n  for (int i = 0; i < op_def.output_arg_size(); i++) {\n    auto* t = ft.add_args();\n    *t = op_def.output_arg(i).experimental_full_type();\n    for (int j = 0; j < t->args_size(); j++) {\n      auto* arg = t->mutable_args(i);\n      if (arg->type_id() == TFT_VAR) {\n        const auto* attr = attrs.Find(arg->s());\n        if (attr == nullptr) {\n          return Status(\n              error::INVALID_ARGUMENT,\n              absl::StrCat(\"Could not find an attribute for key \", arg->s()));\n        }\n        if (attr->value_case() == AttrValue::kList) {\n          const auto& attr_list = attr->list();\n          arg->set_type_id(TFT_PRODUCT);\n          for (int i = 0; i < attr_list.type_size(); i++) {\n            map_dtype_to_tensor(attr_list.type(i), arg->add_args());\n          }\n        } else if (attr->value_case() == AttrValue::kType) {\n          map_dtype_to_tensor(attr->type(), arg);\n        } else {\n          return Status(error::UNIMPLEMENTED,\n                        absl::StrCat(\"unknown attribute type\",\n                                     attrs.DebugString(), \" key=\", arg->s()));\n        }\n        arg->clear_s();\n      }\n    }\n  }\n  return ft;\n}", "target": 1}
{"code": "monitor_init(void)\n{\n\tstruct ssh *ssh = active_state;\t\t\t\n\tstruct monitor *mon;\n\tmon = xcalloc(1, sizeof(*mon));\n\tmonitor_openfds(mon, 1);\n\tif (options.compression) {\n\t\tmon->m_zback = mm_create(NULL, MM_MEMSIZE);\n\t\tmon->m_zlib = mm_create(mon->m_zback, 20 * MM_MEMSIZE);\n\t\tssh_packet_set_compress_hooks(ssh, mon->m_zlib,\n\t\t    (ssh_packet_comp_alloc_func *)mm_zalloc,\n\t\t    (ssh_packet_comp_free_func *)mm_zfree);\n\t}\n\treturn mon;\n}", "target": 1}
{"code": "static void *skcipher_bind(const char *name, u32 type, u32 mask)\n{\n\treturn crypto_alloc_skcipher(name, type, mask);\n}", "target": 1}
{"code": "static int mwifiex_pcie_alloc_cmdrsp_buf(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct sk_buff *skb;\n\tskb = dev_alloc_skb(MWIFIEX_UPLD_SIZE);\n\tif (!skb) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Unable to allocate skb for command response data.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_put(skb, MWIFIEX_UPLD_SIZE);\n\tif (mwifiex_map_pci_memory(adapter, skb, MWIFIEX_UPLD_SIZE,\n\t\t\t\t   PCI_DMA_FROMDEVICE))\n\t\treturn -1;\n\tcard->cmdrsp_buf = skb;\n\treturn 0;\n}", "target": 1}
{"code": "static void lo_release(struct gendisk *disk, fmode_t mode)\n{\n\tstruct loop_device *lo = disk->private_data;\n\tint err;\n\tif (atomic_dec_return(&lo->lo_refcnt))\n\t\treturn;\n\tmutex_lock(&lo->lo_ctl_mutex);\n\tif (lo->lo_flags & LO_FLAGS_AUTOCLEAR) {\n\t\terr = loop_clr_fd(lo);\n\t\tif (!err)\n\t\t\treturn;\n\t} else if (lo->lo_state == Lo_bound) {\n\t\tblk_mq_freeze_queue(lo->lo_queue);\n\t\tblk_mq_unfreeze_queue(lo->lo_queue);\n\t}\n\tmutex_unlock(&lo->lo_ctl_mutex);\n}", "target": 1}
{"code": "static inline void tlb_end_vma(struct mmu_gather *tlb, struct vm_area_struct *vma)\n{\n\tif (tlb->fullmm || IS_ENABLED(CONFIG_MMU_GATHER_MERGE_VMAS))\n\t\treturn;\n\ttlb_flush_mmu_tlbonly(tlb);\n}", "target": 1}
{"code": "int TS_OBJ_print_bio(BIO *bio, const ASN1_OBJECT *obj)\n{\n    char obj_txt[128];\n    int len = OBJ_obj2txt(obj_txt, sizeof(obj_txt), obj, 0);\n    BIO_write(bio, obj_txt, len);\n    BIO_write(bio, \"\\n\", 1);\n    return 1;\n}", "target": 1}
{"code": "CellularNetwork::CellularNetwork(const ServiceInfo* service)\n    : WirelessNetwork(service) {\n  service_name_ = SafeString(service->name);\n  activation_state_ = service->activation_state;\n  network_technology_ = service->network_technology;\n  roaming_state_ = service->roaming_state;\n  restricted_pool_ = service->restricted_pool;\n  if (service->carrier_info) {\n    operator_name_ = SafeString(service->carrier_info->operator_name);\n    operator_code_ = SafeString(service->carrier_info->operator_code);\n    payment_url_ = SafeString(service->carrier_info->payment_url);\n  }\n  if (service->device_info) {\n    meid_ = SafeString(service->device_info->MEID);\n    imei_ = SafeString(service->device_info->IMEI);\n    imsi_ = SafeString(service->device_info->IMSI);\n    esn_ = SafeString(service->device_info->ESN);\n    mdn_ = SafeString(service->device_info->MDN);\n    min_ = SafeString(service->device_info->MIN);\n    model_id_ = SafeString(service->device_info->model_id);\n    manufacturer_ = SafeString(service->device_info->manufacturer);\n    firmware_revision_ = SafeString(service->device_info->firmware_revision);\n    hardware_revision_ = SafeString(service->device_info->hardware_revision);\n    last_update_ = SafeString(service->device_info->last_update);\n    prl_version_ = service->device_info->PRL_version;\n  }\n  type_ = TYPE_CELLULAR;\n}", "target": 0}
{"code": "static Token *make_tok_num(Token *next, int64_t val)\n{\n    char numbuf[32];\n    int len = snprintf(numbuf, sizeof(numbuf), \"%\"PRId64\"\", val);\n    return new_Token(next, TOK_NUMBER, numbuf, len);\n}", "target": 0}
{"code": "static void FillRectangle(rfbClient* client, int x, int y, int w, int h, uint32_t colour) {\n  int i,j;\n#define FILL_RECT(BPP) \\\n    for(j=y*client->width;j<(y+h)*client->width;j+=client->width) \\\n      for(i=x;i<x+w;i++) \\\n\t((uint##BPP##_t*)client->frameBuffer)[j+i]=colour;\n  switch(client->format.bitsPerPixel) {\n  case  8: FILL_RECT(8);  break;\n  case 16: FILL_RECT(16); break;\n  case 32: FILL_RECT(32); break;\n  default:\n    rfbClientLog(\"Unsupported bitsPerPixel: %d\\n\",client->format.bitsPerPixel);\n  }\n}", "target": 0}
{"code": "xsltFreePrincipalStylesheetData(xsltPrincipalStylesheetDataPtr data)\n{\n    if (data == NULL)\n\treturn;\n    if (data->inScopeNamespaces != NULL) {\n\tint i;\n\txsltNsListContainerPtr nsi;\n\txsltPointerListPtr list =\n\t    (xsltPointerListPtr) data->inScopeNamespaces;\n\tfor (i = 0; i < list->number; i++) {\n\t    nsi = (xsltNsListContainerPtr) list->items[i];\n\t    if (nsi->list != NULL)\n\t\txmlFree(nsi->list);\n\t    xmlFree(nsi);\n\t}\n\txsltPointerListFree(list);\n\tdata->inScopeNamespaces = NULL;\n    }\n    if (data->exclResultNamespaces != NULL) {\n\tint i;\n\txsltPointerListPtr list = (xsltPointerListPtr)\n\t    data->exclResultNamespaces;\t\n\tfor (i = 0; i < list->number; i++)\n\t    xsltPointerListFree((xsltPointerListPtr) list->items[i]);\n\txsltPointerListFree(list);\n\tdata->exclResultNamespaces = NULL;\n    }\n    if (data->extElemNamespaces != NULL) {\n\txsltPointerListPtr list = (xsltPointerListPtr)\n\t    data->extElemNamespaces;\n\tint i;\n\tfor (i = 0; i < list->number; i++)\n\t    xsltPointerListFree((xsltPointerListPtr) list->items[i]);\n\txsltPointerListFree(list);\n\tdata->extElemNamespaces = NULL;\n    }\n    if (data->effectiveNs) {\n\txsltLREEffectiveNsNodesFree(data->effectiveNs);\n\tdata->effectiveNs = NULL;\n    }\n#ifdef XSLT_REFACTORED_XSLT_NSCOMP\n    xsltFreeNamespaceMap(data->nsMap);\n#endif\n    xmlFree(data);\n}", "target": 0}
{"code": "GF_Err text_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu16 pSize;\n\tGF_TextSampleEntryBox *ptr = (GF_TextSampleEntryBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\tgf_bs_write_u32(bs, ptr->displayFlags);\t\t\t\n\tgf_bs_write_u32(bs, ptr->textJustification);\t\n\tgf_bs_write_data(bs, ptr->background_color, 6);\t\n\tgpp_write_box(bs, &ptr->default_box);\t\t\t\n\tgf_bs_write_data(bs, ptr->reserved1, 8);\t\t\n\tgf_bs_write_u16(bs, ptr->fontNumber);\t\t\t\n\tgf_bs_write_u16(bs, ptr->fontFace);\t\t\t\t\n\tgf_bs_write_u8(bs, ptr->reserved2);\t\t\t\t\n\tgf_bs_write_u16(bs, ptr->reserved3);\t\t\t\n\tgf_bs_write_data(bs, ptr->foreground_color, 6);\t\n\tif (ptr->textName && (pSize = (u16) strlen(ptr->textName))) {\n\t\tgf_bs_write_u8(bs, pSize);\t\t\t\t\t\n\t\tgf_bs_write_data(bs, ptr->textName, pSize);\t\n\t} else {\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "int BN_hex2bn(BIGNUM **bn, const char *a)\n{\n    BIGNUM *ret = NULL;\n    BN_ULONG l = 0;\n    int neg = 0, h, m, i, j, k, c;\n    int num;\n    if ((a == NULL) || (*a == '\\0'))\n        return (0);\n    if (*a == '-') {\n        neg = 1;\n        a++;\n    }\n    for (i = 0; i <= (INT_MAX/4) && isxdigit((unsigned char)a[i]); i++)\n        continue;\n    if (i > INT_MAX/4)\n        goto err;\n    num = i + neg;\n    if (bn == NULL)\n        return (num);\n    if (*bn == NULL) {\n        if ((ret = BN_new()) == NULL)\n            return (0);\n    } else {\n        ret = *bn;\n        BN_zero(ret);\n    }\n    if (bn_expand(ret, i * 4) == NULL)\n        goto err;\n    j = i;                      \n    m = 0;\n    h = 0;\n    while (j > 0) {\n        m = ((BN_BYTES * 2) <= j) ? (BN_BYTES * 2) : j;\n        l = 0;\n        for (;;) {\n            c = a[j - m];\n            if ((c >= '0') && (c <= '9'))\n                k = c - '0';\n            else if ((c >= 'a') && (c <= 'f'))\n                k = c - 'a' + 10;\n            else if ((c >= 'A') && (c <= 'F'))\n                k = c - 'A' + 10;\n            else\n                k = 0;          \n            l = (l << 4) | k;\n            if (--m <= 0) {\n                ret->d[h++] = l;\n                break;\n            }\n        }\n        j -= (BN_BYTES * 2);\n    }\n    ret->top = h;\n    bn_correct_top(ret);\n    ret->neg = neg;\n    *bn = ret;\n    bn_check_top(ret);\n    return (num);\n err:\n    if (*bn == NULL)\n        BN_free(ret);\n    return (0);\n}", "target": 0}
{"code": "ctnetlink_parse_tuple_filter(const struct nlattr * const cda[],\n\t\t\t      struct nf_conntrack_tuple *tuple, u32 type,\n\t\t\t      u_int8_t l3num, struct nf_conntrack_zone *zone,\n\t\t\t      u_int32_t flags)\n{\n\tstruct nlattr *tb[CTA_TUPLE_MAX+1];\n\tint err;\n\tmemset(tuple, 0, sizeof(*tuple));\n\terr = nla_parse_nested_deprecated(tb, CTA_TUPLE_MAX, cda[type],\n\t\t\t\t\t  tuple_nla_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\ttuple->src.l3num = l3num;\n\tif (flags & CTA_FILTER_FLAG(CTA_IP_DST) ||\n\t    flags & CTA_FILTER_FLAG(CTA_IP_SRC)) {\n\t\tif (!tb[CTA_TUPLE_IP])\n\t\t\treturn -EINVAL;\n\t\terr = ctnetlink_parse_tuple_ip(tb[CTA_TUPLE_IP], tuple, flags);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (flags & CTA_FILTER_FLAG(CTA_PROTO_NUM)) {\n\t\tif (!tb[CTA_TUPLE_PROTO])\n\t\t\treturn -EINVAL;\n\t\terr = ctnetlink_parse_tuple_proto(tb[CTA_TUPLE_PROTO], tuple, flags);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else if (flags & CTA_FILTER_FLAG(ALL_CTA_PROTO)) {\n\t\treturn -EINVAL;\n\t}\n\tif ((flags & CTA_FILTER_FLAG(CTA_TUPLE_ZONE)) && tb[CTA_TUPLE_ZONE]) {\n\t\tif (!zone)\n\t\t\treturn -EINVAL;\n\t\terr = ctnetlink_parse_tuple_zone(tb[CTA_TUPLE_ZONE],\n\t\t\t\t\t\t type, zone);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (type == CTA_TUPLE_REPLY)\n\t\ttuple->dst.dir = IP_CT_DIR_REPLY;\n\telse\n\t\ttuple->dst.dir = IP_CT_DIR_ORIGINAL;\n\treturn 0;\n}", "target": 1}
{"code": "void rfc_send_rls(tRFC_MCB* p_mcb, uint8_t dlci, bool is_command,\n uint8_t status) {\n uint8_t* p_data;\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(RFCOMM_CMD_BUF_SIZE);\n  p_buf->offset = L2CAP_MIN_OFFSET + RFCOMM_CTRL_FRAME_LEN;\n  p_data = (uint8_t*)(p_buf + 1) + p_buf->offset;\n *p_data++ = RFCOMM_EA | RFCOMM_I_CR(is_command) | RFCOMM_MX_RLS;\n *p_data++ = RFCOMM_EA | (RFCOMM_MX_RLS_LEN << 1);\n *p_data++ = RFCOMM_EA | RFCOMM_CR_MASK | (dlci << RFCOMM_SHIFT_DLCI);\n *p_data++ = RFCOMM_RLS_ERROR | status;\n  p_buf->len = RFCOMM_MX_RLS_LEN + 2;\n  rfc_send_buf_uih(p_mcb, RFCOMM_MX_DLCI, p_buf);\n}", "target": 0}
{"code": "efind(name)\nchar *name;\n{\n\tstatic char efbuf[100];\n\tmy_regex_t re;\n\tsprintf(efbuf, \"REG_%s\", name);\n\tassert(strlen(efbuf) < sizeof(efbuf));\n\tre.re_endp = efbuf;\n\t(void) my_regerror(REG_ATOI, &re, efbuf, sizeof(efbuf));\n\treturn(atoi(efbuf));\n}", "target": 1}
{"code": "cdf_read_short_sector_chain(const cdf_header_t *h,\n    const cdf_sat_t *ssat, const cdf_stream_t *sst,\n    cdf_secid_t sid, size_t len, cdf_stream_t *scn)\n{\n\tsize_t ss = CDF_SHORT_SEC_SIZE(h), i, j;\n\tscn->sst_tab = NULL;\n\tscn->sst_len = cdf_count_chain(ssat, sid, CDF_SEC_SIZE(h));\n\tscn->sst_dirlen = len;\n\tscn->sst_ss = ss;\n\tif (scn->sst_len == (size_t)-1)\n\t\tgoto out;\n\tscn->sst_tab = calloc(scn->sst_len, ss);\n\tif (scn->sst_tab == NULL)\n\t\treturn cdf_zero_stream(scn);\n\tfor (j = i = 0; sid >= 0; i++, j++) {\n\t\tif (j >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Read short sector chain loop limit\"));\n\t\t\tgoto out;\n\t\t}\n\t\tif (i >= scn->sst_len) {\n\t\t\tDPRINTF((\"Out of bounds reading short sector chain \"\n\t\t\t    \"%\" SIZE_T_FORMAT \"u > %\" SIZE_T_FORMAT \"u\\n\",\n\t\t\t    i, scn->sst_len));\n\t\t\tgoto out;\n\t\t}\n\t\tif (cdf_read_short_sector(sst, scn->sst_tab, i * ss, ss, h,\n\t\t    sid) != (ssize_t)ss) {\n\t\t\tDPRINTF((\"Reading short sector chain %d\", sid));\n\t\t\tgoto out;\n\t\t}\n\t\tsid = CDF_TOLE4((uint32_t)ssat->sat_tab[sid]);\n\t}\n\treturn 0;\nout:\n\terrno = EFTYPE;\n\treturn cdf_zero_stream(scn);\n}", "target": 0}
{"code": "static bool php_mb_parse_encoding(const Variant& encoding,\n                                  mbfl_encoding ***return_list,\n                                  int *return_size, bool persistent) {\n  bool ret;\n  if (encoding.isArray()) {\n    ret = php_mb_parse_encoding_array(encoding.toArray(),\n                                      return_list, return_size,\n                                      persistent ? 1 : 0);\n  } else {\n    String enc = encoding.toString();\n    ret = php_mb_parse_encoding_list(enc.data(), enc.size(),\n                                     return_list, return_size,\n                                     persistent ? 1 : 0);\n  }\n  if (!ret) {\n    if (return_list && *return_list) {\n      free(*return_list);\n      *return_list = nullptr;\n    }\n    return_size = 0;\n  }\n  return ret;\n}", "target": 1}
{"code": "exim_nullstd(void)\n{\nint i;\nint devnull = -1;\nstruct stat statbuf;\nfor (i = 0; i <= 2; i++)\n  {\n  if (fstat(i, &statbuf) < 0 && errno == EBADF)\n    {\n    if (devnull < 0) devnull = open(\"/dev/null\", O_RDWR);\n    if (devnull < 0) log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"%s\",\n      string_open_failed(errno, \"/dev/null\"));\n    if (devnull != i) (void)dup2(devnull, i);\n    }\n  }\nif (devnull > 2) (void)close(devnull);\n}", "target": 0}
{"code": "get_smb2_acl_by_path(struct cifs_sb_info *cifs_sb,\n\t\t     const char *path, u32 *pacllen, u32 info)\n{\n\tstruct cifs_ntsd *pntsd = NULL;\n\tu8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tunsigned int xid;\n\tint rc;\n\tstruct cifs_tcon *tcon;\n\tstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\t__le16 *utf16_path;\n\tcifs_dbg(FYI, \"get smb3 acl for path %s\\n\", path);\n\tif (IS_ERR(tlink))\n\t\treturn ERR_CAST(tlink);\n\ttcon = tlink_tcon(tlink);\n\txid = get_xid();\n\tutf16_path = cifs_convert_path_to_utf16(path, cifs_sb);\n\tif (!utf16_path) {\n\t\trc = -ENOMEM;\n\t\tfree_xid(xid);\n\t\treturn ERR_PTR(rc);\n\t}\n\toparms.tcon = tcon;\n\toparms.desired_access = READ_CONTROL;\n\toparms.disposition = FILE_OPEN;\n\toparms.create_options = cifs_create_options(cifs_sb, 0) | OPEN_REPARSE_POINT;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\tif (info & SACL_SECINFO)\n\t\toparms.desired_access |= SYSTEM_SECURITY;\n\trc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, NULL, NULL,\n\t\t       NULL);\n\tkfree(utf16_path);\n\tif (!rc) {\n\t\trc = SMB2_query_acl(xid, tlink_tcon(tlink), fid.persistent_fid,\n\t\t\t\t    fid.volatile_fid, (void **)&pntsd, pacllen,\n\t\t\t\t    info);\n\t\tSMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\n\t}\n\tcifs_put_tlink(tlink);\n\tfree_xid(xid);\n\tcifs_dbg(FYI, \"%s: rc = %d ACL len %d\\n\", __func__, rc, *pacllen);\n\tif (rc)\n\t\treturn ERR_PTR(rc);\n\treturn pntsd;\n}", "target": 0}
{"code": "strncmpic(uschar *s, uschar *t, int n)\n{\nwhile (n--)\n  {\n  int c = tolower(*s++) - tolower(*t++);\n  if (c) return c;\n  }\nreturn 0;\n}", "target": 0}
{"code": "bool CSPSource::schemeMatches(const KURL& url) const\n {\n     if (m_scheme.isEmpty())\n         return m_policy->protocolMatchesSelf(url);\n    if (equalIgnoringCase(m_scheme, \"http\"))\n        return equalIgnoringCase(url.protocol(), \"http\") || equalIgnoringCase(url.protocol(), \"https\");\n    if (equalIgnoringCase(m_scheme, \"ws\"))\n        return equalIgnoringCase(url.protocol(), \"ws\") || equalIgnoringCase(url.protocol(), \"wss\");\n     return equalIgnoringCase(url.protocol(), m_scheme);\n }", "target": 0}
{"code": "void ConnectDialog::accept() {\n\tServerItem *si = static_cast<ServerItem *>(qtwServers->currentItem());\n\tif (! si || (bAllowHostLookup && si->qlAddresses.isEmpty()) || si->qsHostname.isEmpty()) {\n\t\tqWarning() << \"Invalid server\";\n\t\treturn;\n\t}\n\tqsPassword = si->qsPassword;\n\tqsServer = si->qsHostname;\n\tusPort = si->usPort;\n\tif (si->qsUsername.isEmpty()) {\n\t\tbool ok;\n\t\tQString defUserName = QInputDialog::getText(this, tr(\"Connecting to %1\").arg(si->qsName), tr(\"Enter username\"), QLineEdit::Normal, g.s.qsUsername, &ok).trimmed();\n\t\tif (! ok)\n\t\t\treturn;\n\t\tg.s.qsUsername = si->qsUsername = defUserName;\n\t}\n\tqsUsername = si->qsUsername;\n\tg.s.qsLastServer = si->qsName;\n\tQDialog::accept();\n}", "target": 0}
{"code": "static long cec_adap_g_log_addrs(struct cec_adapter *adap,\n\t\t\t\t struct cec_log_addrs __user *parg)\n{\n\tstruct cec_log_addrs log_addrs;\n\tmutex_lock(&adap->lock);\n\tlog_addrs = adap->log_addrs;\n\tif (!adap->is_configured)\n\t\tmemset(log_addrs.log_addr, CEC_LOG_ADDR_INVALID,\n\t\t       sizeof(log_addrs.log_addr));\n\tmutex_unlock(&adap->lock);\n\tif (copy_to_user(parg, &log_addrs, sizeof(log_addrs)))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1}
{"code": "inline Result ClientImpl::Delete(const std::string &path,\n                                 const Headers &headers, const char *body,\n                                 size_t content_length,\n                                 const std::string &content_type) {\n  Request req;\n  req.method = \"DELETE\";\n  req.headers = headers;\n  req.path = path;\n  if (!content_type.empty()) {\n    req.headers.emplace(\"Content-Type\", content_type);\n  }\n  req.body.assign(body, content_length);\n  return send_(std::move(req));\n}", "target": 1}
{"code": "void jbd2_journal_lock_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\tjbd2_might_wait_for_commit(journal);\n\twrite_lock(&journal->j_state_lock);\n\t++journal->j_barrier_count;\n\tif (atomic_read(&journal->j_reserved_credits)) {\n\t\twrite_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_reserved,\n\t\t\t   atomic_read(&journal->j_reserved_credits) == 0);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\tjbd2_journal_wait_updates(journal);\n\twrite_unlock(&journal->j_state_lock);\n\tmutex_lock(&journal->j_barrier);\n}", "target": 1}
{"code": "static int append_key_value(smart_str* loc_name, HashTable* hash_arr, char* key_name)\n{\n\tzval**\tele_value\t= NULL;\n\tif(zend_hash_find(hash_arr , key_name , strlen(key_name) + 1 ,(void **)&ele_value ) == SUCCESS ) {\n\t\tif(Z_TYPE_PP(ele_value)!= IS_STRING ){\n\t\t\treturn FAILURE;\n\t\t}\n\t\tif(strcmp(key_name, LOC_LANG_TAG) != 0 && \n\t\t   strcmp(key_name, LOC_GRANDFATHERED_LANG_TAG)!=0 ) {\n\t\t\tsmart_str_appendl(loc_name, SEPARATOR , sizeof(SEPARATOR)-1);\n\t\t}\n\t\tsmart_str_appendl(loc_name, Z_STRVAL_PP(ele_value) , Z_STRLEN_PP(ele_value));\n\t\treturn SUCCESS;\n\t}\n\treturn LOC_NOT_FOUND;\n}", "target": 1}
{"code": "static int __packet_get_status(struct packet_sock *po, void *frame)\n{\n\tunion {\n\t\tstruct tpacket_hdr *h1;\n\t\tstruct tpacket2_hdr *h2;\n\t\tvoid *raw;\n\t} h;\n\tsmp_rmb();\n\th.raw = frame;\n\tswitch (po->tp_version) {\n\tcase TPACKET_V1:\n\t\tflush_dcache_page(pgv_to_page(&h.h1->tp_status));\n\t\treturn h.h1->tp_status;\n\tcase TPACKET_V2:\n\t\tflush_dcache_page(pgv_to_page(&h.h2->tp_status));\n\t\treturn h.h2->tp_status;\n\tcase TPACKET_V3:\n\tdefault:\n\t\tWARN(1, \"TPACKET version not supported.\\n\");\n\t\tBUG();\n\t\treturn 0;\n\t}\n}", "target": 0}
{"code": "  bool AddCallback(GetUsageAndQuotaCallback* callback, bool unlimited) {\n    if (unlimited)\n      unlimited_callbacks_.push_back(callback);\n    else\n      callbacks_.push_back(callback);\n    return (callbacks_.size() + unlimited_callbacks_.size() == 1);\n  }", "target": 0}
{"code": "static Bigint * Balloc(int k)\n{\n\tint x;\n\tBigint *rv;\n\t_THREAD_PRIVATE_MUTEX_LOCK(dtoa_mutex);\n\tif ((rv = freelist[k])) {\n\t\tfreelist[k] = rv->next;\n\t} else {\n\t\tx = 1 << k;\n\t\trv = (Bigint *)MALLOC(sizeof(Bigint) + (x-1)*sizeof(Long));\n\t\trv->k = k;\n\t\trv->maxwds = x;\n\t}\n\t_THREAD_PRIVATE_MUTEX_UNLOCK(dtoa_mutex);\n\trv->sign = rv->wds = 0;\n\treturn rv;\n}", "target": 1}
{"code": "void Document::ProcessBaseElement() {\n  UseCounter::Count(*this, WebFeature::kBaseElement);\n  const AtomicString* href = nullptr;\n  const AtomicString* target = nullptr;\n  for (HTMLBaseElement* base = Traversal<HTMLBaseElement>::FirstWithin(*this);\n       base && (!href || !target);\n       base = Traversal<HTMLBaseElement>::Next(*base)) {\n    if (!href) {\n      const AtomicString& value = base->FastGetAttribute(hrefAttr);\n      if (!value.IsNull())\n        href = &value;\n    }\n    if (!target) {\n      const AtomicString& value = base->FastGetAttribute(targetAttr);\n      if (!value.IsNull())\n        target = &value;\n    }\n    if (GetContentSecurityPolicy()->IsActive()) {\n      UseCounter::Count(*this,\n                        WebFeature::kContentSecurityPolicyWithBaseElement);\n    }\n  }\n  KURL base_element_url;\n  if (href) {\n    String stripped_href = StripLeadingAndTrailingHTMLSpaces(*href);\n    if (!stripped_href.IsEmpty())\n      base_element_url = KURL(FallbackBaseURL(), stripped_href);\n  }\n  if (!base_element_url.IsEmpty()) {\n    if (base_element_url.ProtocolIsData()) {\n      UseCounter::Count(*this, WebFeature::kBaseWithDataHref);\n      AddConsoleMessage(ConsoleMessage::Create(\n          kSecurityMessageSource, kErrorMessageLevel,\n          \"'data:' URLs may not be used as base URLs for a document.\"));\n    }\n    if (!GetSecurityOrigin()->CanRequest(base_element_url))\n      UseCounter::Count(*this, WebFeature::kBaseWithCrossOriginHref);\n  }\n  if (base_element_url != base_element_url_ &&\n      !base_element_url.ProtocolIsData() &&\n      GetContentSecurityPolicy()->AllowBaseURI(base_element_url)) {\n    base_element_url_ = base_element_url;\n    UpdateBaseURL();\n  }\n  if (target) {\n    if (target->Contains('\\n') || target->Contains('\\r'))\n      UseCounter::Count(*this, WebFeature::kBaseWithNewlinesInTarget);\n    if (target->Contains('<'))\n      UseCounter::Count(*this, WebFeature::kBaseWithOpenBracketInTarget);\n    base_target_ = *target;\n  } else {\n    base_target_ = g_null_atom;\n  }\n}", "target": 0}
{"code": "nfsd4_setattr(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t      union nfsd4_op_u *u)\n{\n\tstruct nfsd4_setattr *setattr = &u->setattr;\n\t__be32 status = nfs_ok;\n\tint err;\n\tif (setattr->sa_iattr.ia_valid & ATTR_SIZE) {\n\t\tstatus = nfs4_preprocess_stateid_op(rqstp, cstate,\n\t\t\t\t&cstate->current_fh, &setattr->sa_stateid,\n\t\t\t\tWR_STATE, NULL, NULL);\n\t\tif (status) {\n\t\t\tdprintk(\"NFSD: nfsd4_setattr: couldn't process stateid!\\n\");\n\t\t\treturn status;\n\t\t}\n\t}\n\terr = fh_want_write(&cstate->current_fh);\n\tif (err)\n\t\treturn nfserrno(err);\n\tstatus = nfs_ok;\n\tstatus = check_attr_support(rqstp, cstate, setattr->sa_bmval,\n\t\t\t\t    nfsd_attrmask);\n\tif (status)\n\t\tgoto out;\n\tif (setattr->sa_acl != NULL)\n\t\tstatus = nfsd4_set_nfs4_acl(rqstp, &cstate->current_fh,\n\t\t\t\t\t    setattr->sa_acl);\n\tif (status)\n\t\tgoto out;\n\tif (setattr->sa_label.len)\n\t\tstatus = nfsd4_set_nfs4_label(rqstp, &cstate->current_fh,\n\t\t\t\t&setattr->sa_label);\n\tif (status)\n\t\tgoto out;\n\tstatus = nfsd_setattr(rqstp, &cstate->current_fh, &setattr->sa_iattr,\n\t\t\t\t0, (time_t)0);\nout:\n\tfh_drop_write(&cstate->current_fh);\n\treturn status;\n}", "target": 0}
{"code": "flush_chunk(tor_socket_t s, buf_t *buf, chunk_t *chunk, size_t sz,\n            size_t *buf_flushlen)\n{\n  ssize_t write_result;\n  if (sz > chunk->datalen)\n    sz = chunk->datalen;\n  write_result = tor_socket_send(s, chunk->data, sz, 0);\n  if (write_result < 0) {\n    int e = tor_socket_errno(s);\n    if (!ERRNO_IS_EAGAIN(e)) { \n#ifdef _WIN32\n      if (e == WSAENOBUFS)\n        log_warn(LD_NET,\"write() failed: WSAENOBUFS. Not enough ram?\");\n#endif\n      return -1;\n    }\n    log_debug(LD_NET,\"write() would block, returning.\");\n    return 0;\n  } else {\n    *buf_flushlen -= write_result;\n    buf_remove_from_front(buf, write_result);\n    tor_assert(write_result < INT_MAX);\n    return (int)write_result;\n  }\n}", "target": 0}
{"code": "static inline item* limited_get(char *key, size_t nkey, conn *c) {\n    item *it = item_get(key, nkey, c, DO_UPDATE);\n    if (it && it->refcount > IT_REFCOUNT_LIMIT) {\n        item_remove(it);\n        it = NULL;\n    }\n    return it;\n}", "target": 0}
{"code": "static int add_seccomp_syscall_filter(scmp_filter_ctx seccomp,\n                                      uint32_t arch,\n                                      int nr,\n                                      unsigned int arg_cnt,\n                                      const struct scmp_arg_cmp arg) {\n        int r;\n        r = seccomp_rule_add_exact(seccomp, SCMP_ACT_ERRNO(EPERM), nr, arg_cnt, arg);\n        if (r < 0) {\n                _cleanup_free_ char *n = NULL;\n                n = seccomp_syscall_resolve_num_arch(arch, nr);\n                log_debug_errno(r, \"Failed to add %s() rule for architecture %s, skipping: %m\",\n                                strna(n),\n                                seccomp_arch_to_string(arch));\n        }\n        return r;\n}", "target": 0}
{"code": "static long sock_wait_for_wmem(struct sock * sk, long timeo)\n{\n\tDEFINE_WAIT(wait);\n\tclear_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags);\n\tfor (;;) {\n\t\tif (!timeo)\n\t\t\tbreak;\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\tset_bit(SOCK_NOSPACE, &sk->sk_socket->flags);\n\t\tprepare_to_wait(sk->sk_sleep, &wait, TASK_INTERRUPTIBLE);\n\t\tif (atomic_read(&sk->sk_wmem_alloc) < sk->sk_sndbuf)\n\t\t\tbreak;\n\t\tif (sk->sk_shutdown & SEND_SHUTDOWN)\n\t\t\tbreak;\n\t\tif (sk->sk_err)\n\t\t\tbreak;\n\t\ttimeo = schedule_timeout(timeo);\n\t}\n\tfinish_wait(sk->sk_sleep, &wait);\n\treturn timeo;\n}", "target": 0}
{"code": "status _af_set_sample_format (_AudioFormat *f, int sampleFormat, int sampleWidth)\n{\n\tswitch (sampleFormat)\n\t{\n\t\tcase AF_SAMPFMT_UNSIGNED:\n\t\tcase AF_SAMPFMT_TWOSCOMP:\n\t\tif (sampleWidth < 1 || sampleWidth > 32)\n\t\t{\n\t\t\t_af_error(AF_BAD_SAMPFMT,\n\t\t\t\t\"illegal sample width %d for integer data\",\n\t\t\t\tsampleWidth);\n\t\t\treturn AF_FAIL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint bytes;\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = sampleWidth;\n\t\t\tbytes = _af_format_sample_size_uncompressed(f, false);\n\t\t\tif (sampleFormat == AF_SAMPFMT_TWOSCOMP)\n\t\t\t\tf->pcm = _af_default_signed_integer_pcm_mappings[bytes];\n\t\t\telse\n\t\t\t\tf->pcm = _af_default_unsigned_integer_pcm_mappings[bytes];\n\t\t}\n\t\tbreak;\n\t\tcase AF_SAMPFMT_FLOAT:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 32;\n\t\t\tf->pcm = _af_default_float_pcm_mapping;\n\t\t\tbreak;\n\t\tcase AF_SAMPFMT_DOUBLE:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 64;      \n\t\t\tf->pcm = _af_default_double_pcm_mapping;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t_af_error(AF_BAD_SAMPFMT, \"unknown sample format %d\",\n\t\t\t\tsampleFormat);\n\t\t\treturn AF_FAIL;\n\t}\n\treturn AF_SUCCEED;\n}", "target": 0}
{"code": "search_impl(i_ctx_t *i_ctx_p, bool forward)\n{\n    os_ptr op = osp;\n    os_ptr op1 = op - 1;\n    uint size = r_size(op);\n    uint count;\n    byte *pat;\n    byte *ptr;\n    byte ch;\n    int incr = forward ? 1 : -1;\n    check_read_type(*op1, t_string);\n    check_read_type(*op, t_string);\n    if (size > r_size(op1)) {\t\n        make_false(op);\n        return 0;\n    }\n    count = r_size(op1) - size;\n    ptr = op1->value.bytes;\n    if (size == 0)\n        goto found;\n    if (!forward)\n        ptr += count;\n    pat = op->value.bytes;\n    ch = pat[0];\n    do {\n        if (*ptr == ch && (size == 1 || !memcmp(ptr, pat, size)))\n            goto found;\n        ptr += incr;\n    }\n    while (count--);\n    make_false(op);\n    return 0;\nfound:\n    op->tas.type_attrs = op1->tas.type_attrs;\n    op->value.bytes = ptr;\n    r_set_size(op, size);\n    push(2);\n    op[-1] = *op1;\n    r_set_size(op - 1, ptr - op[-1].value.bytes);\n    op1->value.bytes = ptr + size;\n    r_set_size(op1, count + (!forward ? (size - 1) : 0));\n    make_true(op);\n    return 0;\n}", "target": 1}
{"code": "static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo){\n  Vdbe *v = pParse->pVdbe;\n  int i;\n  struct AggInfo_func *pFunc;\n  int nReg = pAggInfo->nFunc + pAggInfo->nColumn;\n  if( nReg==0 ) return;\n#ifdef SQLITE_DEBUG\n  assert( nReg==pAggInfo->mxReg-pAggInfo->mnReg+1 );\n  for(i=0; i<pAggInfo->nColumn; i++){\n    assert( pAggInfo->aCol[i].iMem>=pAggInfo->mnReg\n         && pAggInfo->aCol[i].iMem<=pAggInfo->mxReg );\n  }\n  for(i=0; i<pAggInfo->nFunc; i++){\n    assert( pAggInfo->aFunc[i].iMem>=pAggInfo->mnReg\n         && pAggInfo->aFunc[i].iMem<=pAggInfo->mxReg );\n  }\n#endif\n  sqlite3VdbeAddOp3(v, OP_Null, 0, pAggInfo->mnReg, pAggInfo->mxReg);\n  for(pFunc=pAggInfo->aFunc, i=0; i<pAggInfo->nFunc; i++, pFunc++){\n    if( pFunc->iDistinct>=0 ){\n      Expr *pE = pFunc->pExpr;\n      assert( !ExprHasProperty(pE, EP_xIsSelect) );\n      if( pE->x.pList==0 || pE->x.pList->nExpr!=1 ){\n        sqlite3ErrorMsg(pParse, \"DISTINCT aggregates must have exactly one \"\n           \"argument\");\n        pFunc->iDistinct = -1;\n      }else{\n        KeyInfo *pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pE->x.pList,0,0);\n        sqlite3VdbeAddOp4(v, OP_OpenEphemeral, pFunc->iDistinct, 0, 0,\n                          (char*)pKeyInfo, P4_KEYINFO);\n      }\n    }\n  }\n}", "target": 0}
{"code": "static void io_async_task_func(struct callback_head *cb)\n{\n\tstruct io_kiocb *req = container_of(cb, struct io_kiocb, task_work);\n\tstruct async_poll *apoll = req->apoll;\n\tstruct io_ring_ctx *ctx = req->ctx;\n\ttrace_io_uring_task_run(req->ctx, req->opcode, req->user_data);\n\tif (io_poll_rewait(req, &apoll->poll)) {\n\t\tspin_unlock_irq(&ctx->completion_lock);\n\t\treturn;\n\t}\n\tif (hash_hashed(&req->hash_node))\n\t\thash_del(&req->hash_node);\n\tio_poll_remove_double(req, apoll->double_poll);\n\tspin_unlock_irq(&ctx->completion_lock);\n\tif (!READ_ONCE(apoll->poll.canceled))\n\t\t__io_req_task_submit(req);\n\telse\n\t\t__io_req_task_cancel(req, -ECANCELED);\n\tkfree(apoll->double_poll);\n\tkfree(apoll);\n}", "target": 1}
{"code": "static void\nS_regdump_extflags(pTHX_ const char *lead, const U32 flags)\n{\n    int bit;\n    int set=0;\n    regex_charset cs;\n    ASSUME(REG_EXTFLAGS_NAME_SIZE <= sizeof(flags)*8);\n    for (bit=0; bit<REG_EXTFLAGS_NAME_SIZE; bit++) {\n        if (flags & (1<<bit)) {\n\t    if ((1<<bit) & RXf_PMf_CHARSET) {\t\n\t\tcontinue;\n\t    }\n            if (!set++ && lead)\n                Perl_re_printf( aTHX_  \"%s\", lead);\n            Perl_re_printf( aTHX_  \"%s \", PL_reg_extflags_name[bit]);\n        }\n    }\n    if ((cs = get_regex_charset(flags)) != REGEX_DEPENDS_CHARSET) {\n            if (!set++ && lead) {\n                Perl_re_printf( aTHX_  \"%s\", lead);\n            }\n            switch (cs) {\n                case REGEX_UNICODE_CHARSET:\n                    Perl_re_printf( aTHX_  \"UNICODE\");\n                    break;\n                case REGEX_LOCALE_CHARSET:\n                    Perl_re_printf( aTHX_  \"LOCALE\");\n                    break;\n                case REGEX_ASCII_RESTRICTED_CHARSET:\n                    Perl_re_printf( aTHX_  \"ASCII-RESTRICTED\");\n                    break;\n                case REGEX_ASCII_MORE_RESTRICTED_CHARSET:\n                    Perl_re_printf( aTHX_  \"ASCII-MORE_RESTRICTED\");\n                    break;\n                default:\n                    Perl_re_printf( aTHX_  \"UNKNOWN CHARACTER SET\");\n                    break;\n            }\n    }\n    if (lead)  {\n        if (set)\n            Perl_re_printf( aTHX_  \"\\n\");\n        else\n            Perl_re_printf( aTHX_  \"%s[none-set]\\n\", lead);\n    }", "target": 0}
{"code": "DECLAREContigPutFunc(putagreytile)\n{\n    int samplesperpixel = img->samplesperpixel;\n    uint32** BWmap = img->BWmap;\n    (void) y;\n    while (h-- > 0) {\n\tfor (x = w; x-- > 0;)\n        {\n            *cp++ = BWmap[*pp][0] & (*(pp+1) << 24 | ~A1);\n            pp += samplesperpixel;\n        }\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}", "target": 1}
{"code": "static void HeaderMapImplGetByteSize(benchmark::State& state) {\n  HeaderMapImpl headers;\n  addDummyHeaders(headers, state.range(0));\n  uint64_t size = 0;\n  for (auto _ : state) {\n    size += headers.byteSize();\n  }\n  benchmark::DoNotOptimize(size);\n}", "target": 1}
{"code": "CompileResult generateBytecodeForExecution(\n    Module &M,\n    const BytecodeGenerationOptions &genOptions) {\n  std::shared_ptr<Context> context = M.shareContext();\n  CompileResult result{Success};\n  if (cl::BytecodeFormat == cl::BytecodeFormatKind::HBC) {\n    result.bytecodeProvider = hbc::BCProviderFromSrc::createBCProviderFromSrc(\n        hbc::generateBytecodeModule(&M, M.getTopLevelFunction(), genOptions));\n  } else {\n    llvm_unreachable(\"Invalid bytecode kind for execution\");\n    result = InvalidFlags;\n  }\n  return result;\n}", "target": 1}
{"code": "static size_t exif_convert_any_to_int(void *value, int format, int motorola_intel TSRMLS_DC)\n{\n\tint \t\ts_den;\n\tunsigned \tu_den;\n\tswitch(format) {\n\t\tcase TAG_FMT_SBYTE:     return *(signed char *)value;\n\t\tcase TAG_FMT_BYTE:      return *(uchar *)value;\n\t\tcase TAG_FMT_USHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_ULONG:     return php_ifd_get32u(value, motorola_intel);\n\t\tcase TAG_FMT_URATIONAL:\n\t\t\tu_den = php_ifd_get32u(4+(char *)value, motorola_intel);\n\t\t\tif (u_den == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn php_ifd_get32u(value, motorola_intel) / u_den;\n\t\t\t}\n\t\tcase TAG_FMT_SRATIONAL:\n\t\t\ts_den = php_ifd_get32s(4+(char *)value, motorola_intel);\n\t\t\tif (s_den == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn php_ifd_get32s(value, motorola_intel) / s_den;\n\t\t\t}\n\t\tcase TAG_FMT_SSHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_SLONG:     return php_ifd_get32s(value, motorola_intel);\n\t\tcase TAG_FMT_SINGLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Found value of type single\");\n#endif\n\t\t\treturn (size_t)*(float *)value;\n\t\tcase TAG_FMT_DOUBLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Found value of type double\");\n#endif\n\t\t\treturn (size_t)*(double *)value;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "compile_length_string_node(Node* node, regex_t* reg)\n{\n  int rlen, r, len, prev_len, slen, ambig;\n  OnigEncoding enc = reg->enc;\n  UChar *p, *prev;\n  StrNode* sn;\n  sn = NSTR(node);\n  if (sn->end <= sn->s)\n    return 0;\n  ambig = NSTRING_IS_AMBIG(node);\n  p = prev = sn->s;\n  prev_len = enclen(enc, p, sn->end);\n  p += prev_len;\n  slen = 1;\n  rlen = 0;\n  for (; p < sn->end; ) {\n    len = enclen(enc, p, sn->end);\n    if (len == prev_len) {\n      slen++;\n    }\n    else {\n      r = add_compile_string_length(prev, prev_len, slen, reg, ambig);\n      rlen += r;\n      prev = p;\n      slen = 1;\n      prev_len = len;\n    }\n    p += len;\n  }\n  r = add_compile_string_length(prev, prev_len, slen, reg, ambig);\n  rlen += r;\n  return rlen;\n}", "target": 0}
{"code": "void flush_tlb_page(struct vm_area_struct *vma, unsigned long start)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpreempt_disable();\n\tif (current->active_mm == mm) {\n\t\tif (current->mm)\n\t\t\t__flush_tlb_one(start);\n\t\telse\n\t\t\tleave_mm(smp_processor_id());\n\t}\n\tif (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) < nr_cpu_ids)\n\t\tflush_tlb_others(mm_cpumask(mm), mm, start, 0UL);\n\tpreempt_enable();\n}", "target": 1}
{"code": "pci_lintr_release(struct pci_vdev *dev)\n{\n\tstruct businfo *bi;\n\tstruct slotinfo *si;\n\tint pin;\n\tbi = pci_businfo[dev->bus];\n\tassert(bi != NULL);\n\tsi = &bi->slotinfo[dev->slot];\n\tfor (pin = 1; pin < 4; pin++) {\n\t\tsi->si_intpins[pin].ii_count = 0;\n\t\tsi->si_intpins[pin].ii_pirq_pin = 0;\n\t\tsi->si_intpins[pin].ii_ioapic_irq = 0;\n\t}\n}", "target": 1}
{"code": "static void nfs_fattr_free_owner_name(struct nfs_fattr *fattr)\n{\n\tfattr->valid &= ~NFS_ATTR_FATTR_OWNER_NAME;\n\tkfree(fattr->owner_name->data);\n}", "target": 0}
{"code": "static int nested_svm_intercept(struct vcpu_svm *svm)\n{\n\tu32 exit_code = svm->vmcb->control.exit_code;\n\tint vmexit = NESTED_EXIT_HOST;\n\tswitch (exit_code) {\n\tcase SVM_EXIT_MSR:\n\t\tvmexit = nested_svm_exit_handled_msr(svm);\n\t\tbreak;\n\tcase SVM_EXIT_IOIO:\n\t\tvmexit = nested_svm_intercept_ioio(svm);\n\t\tbreak;\n\tcase SVM_EXIT_READ_CR0 ... SVM_EXIT_WRITE_CR8: {\n\t\tu32 bit = 1U << (exit_code - SVM_EXIT_READ_CR0);\n\t\tif (svm->nested.intercept_cr & bit)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t\tbreak;\n\t}\n\tcase SVM_EXIT_READ_DR0 ... SVM_EXIT_WRITE_DR7: {\n\t\tu32 bit = 1U << (exit_code - SVM_EXIT_READ_DR0);\n\t\tif (svm->nested.intercept_dr & bit)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t\tbreak;\n\t}\n\tcase SVM_EXIT_EXCP_BASE ... SVM_EXIT_EXCP_BASE + 0x1f: {\n\t\tu32 excp_bits = 1 << (exit_code - SVM_EXIT_EXCP_BASE);\n\t\tif (svm->nested.intercept_exceptions & excp_bits)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t\telse if ((exit_code == SVM_EXIT_EXCP_BASE + PF_VECTOR) &&\n\t\t\t svm->apf_reason != 0)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t\tbreak;\n\t}\n\tcase SVM_EXIT_ERR: {\n\t\tvmexit = NESTED_EXIT_DONE;\n\t\tbreak;\n\t}\n\tdefault: {\n\t\tu64 exit_bits = 1ULL << (exit_code - SVM_EXIT_INTR);\n\t\tif (svm->nested.intercept & exit_bits)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t}\n\t}\n\treturn vmexit;\n}", "target": 0}
{"code": "void jiffies_to_timeval(const unsigned long jiffies, struct timeval *value)\n{\n\tu64 nsec = (u64)jiffies * TICK_NSEC;\n\tlong tv_usec;\n\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &tv_usec);\n\ttv_usec /= NSEC_PER_USEC;\n\tvalue->tv_usec = tv_usec;\n}", "target": 1}
{"code": "vips_foreign_load_start( VipsImage *out, void *a, void *b )\n{\n\tVipsForeignLoad *load = VIPS_FOREIGN_LOAD( b );\n\tVipsForeignLoadClass *class = VIPS_FOREIGN_LOAD_GET_CLASS( load );\n\tif( !load->real ) {\n\t\tif( !(load->real = vips_foreign_load_temp( load )) )\n\t\t\treturn( NULL );\n#ifdef DEBUG\n\t\tprintf( \"vips_foreign_load_start: triggering ->load()\\n\" );\n#endif \n\t\tload->real->progress_signal = load->out;\n\t\tg_object_set_qdata( G_OBJECT( load->real ), \n\t\t\tvips__foreign_load_operation, load ); \n\t\tif( class->load( load ) ||\n\t\t\tvips_image_pio_input( load->real ) ) \n\t\t\treturn( NULL );\n\t\tif( !vips_foreign_load_iscompat( load->real, out ) )\n\t\t\treturn( NULL );\n\t\tvips_image_pipelinev( load->out, load->out->dhint, \n\t\t\tload->real, NULL );\n\t}\n\treturn( vips_region_new( load->real ) );\n}", "target": 1}
{"code": "void __init proc_root_init(void)\n{\n\tstruct vfsmount *mnt;\n\tint err;\n\tproc_init_inodecache();\n\terr = register_filesystem(&proc_fs_type);\n\tif (err)\n\t\treturn;\n\tmnt = kern_mount_data(&proc_fs_type, &init_pid_ns);\n\tif (IS_ERR(mnt)) {\n\t\tunregister_filesystem(&proc_fs_type);\n\t\treturn;\n\t}\n\tinit_pid_ns.proc_mnt = mnt;\n\tproc_symlink(\"mounts\", NULL, \"self/mounts\");\n\tproc_net_init();\n#ifdef CONFIG_SYSVIPC\n\tproc_mkdir(\"sysvipc\", NULL);\n#endif\n\tproc_mkdir(\"fs\", NULL);\n\tproc_mkdir(\"driver\", NULL);\n\tproc_mkdir(\"fs/nfsd\", NULL); \n#if defined(CONFIG_SUN_OPENPROMFS) || defined(CONFIG_SUN_OPENPROMFS_MODULE)\n\tproc_mkdir(\"openprom\", NULL);\n#endif\n\tproc_tty_init();\n#ifdef CONFIG_PROC_DEVICETREE\n\tproc_device_tree_init();\n#endif\n\tproc_mkdir(\"bus\", NULL);\n\tproc_sys_init();\n}", "target": 1}
{"code": "isakmp_rfc3948_print(netdissect_options *ndo,\n\t\t     const u_char *bp, u_int length,\n\t\t     const u_char *bp2)\n{\n\tif(length == 1 && bp[0]==0xff) {\n\t\tND_PRINT((ndo, \"isakmp-nat-keep-alive\"));\n\t\treturn;\n\t}\n\tif(length < 4) {\n\t\tgoto trunc;\n\t}\n\tif(bp[0]==0 && bp[1]==0 && bp[2]==0 && bp[3]==0) {\n\t\tND_PRINT((ndo, \"NONESP-encap: \"));\n\t\tisakmp_print(ndo, bp+4, length-4, bp2);\n\t\treturn;\n\t}\n\t{\n\t\tint nh, enh, padlen;\n\t\tint advance;\n\t\tND_PRINT((ndo, \"UDP-encap: \"));\n\t\tadvance = esp_print(ndo, bp, length, bp2, &enh, &padlen);\n\t\tif(advance <= 0)\n\t\t\treturn;\n\t\tbp += advance;\n\t\tlength -= advance + padlen;\n\t\tnh = enh & 0xff;\n\t\tip_print_inner(ndo, bp, length, nh, bp2);\n\t\treturn;\n\t}\ntrunc:\n\tND_PRINT((ndo,\"[|isakmp]\"));\n\treturn;\n}", "target": 1}
{"code": "void snd_usb_mixer_disconnect(struct usb_mixer_interface *mixer)\n{\n\tusb_kill_urb(mixer->urb);\n\tusb_kill_urb(mixer->rc_urb);\n}", "target": 1}
{"code": "HttpRequest::maybeCacheable()\n{\n    if (!flags.hostVerified && (flags.intercepted || flags.interceptTproxy))\n        return false;\n    switch (url.getScheme()) {\n    case AnyP::PROTO_HTTP:\n    case AnyP::PROTO_HTTPS:\n        if (!method.respMaybeCacheable())\n            return false;\n        if (!flags.ignoreCc && cache_control && cache_control->hasNoStore())\n            return false;\n        break;\n    case AnyP::PROTO_GOPHER:\n        if (!gopherCachable(this))\n            return false;\n        break;\n    case AnyP::PROTO_CACHE_OBJECT:\n        return false;\n    default:\n        break;\n    }\n    return true;\n}", "target": 1}
{"code": "nfsd4_copy(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_copy *copy)\n{\n\tstruct file *src, *dst;\n\t__be32 status;\n\tssize_t bytes;\n\tstatus = nfsd4_verify_copy(rqstp, cstate, &copy->cp_src_stateid, &src,\n\t\t\t\t   &copy->cp_dst_stateid, &dst);\n\tif (status)\n\t\tgoto out;\n\tbytes = nfsd_copy_file_range(src, copy->cp_src_pos,\n\t\t\tdst, copy->cp_dst_pos, copy->cp_count);\n\tif (bytes < 0)\n\t\tstatus = nfserrno(bytes);\n\telse {\n\t\tcopy->cp_res.wr_bytes_written = bytes;\n\t\tcopy->cp_res.wr_stable_how = NFS_UNSTABLE;\n\t\tcopy->cp_consecutive = 1;\n\t\tcopy->cp_synchronous = 1;\n\t\tgen_boot_verifier(&copy->cp_res.wr_verifier, SVC_NET(rqstp));\n\t\tstatus = nfs_ok;\n\t}\n\tfput(src);\n\tfput(dst);\nout:\n\treturn status;\n}", "target": 0}
{"code": "int ConnectionImpl::saveHeader(const nghttp2_frame* frame, HeaderString&& name,\n                               HeaderString&& value) {\n  StreamImpl* stream = getStream(frame->hd.stream_id);\n  if (!stream) {\n    stats_.headers_cb_no_stream_.inc();\n    return 0;\n  }\n  stream->saveHeader(std::move(name), std::move(value));\n  if (stream->headers_->byteSize() > max_request_headers_kb_ * 1024) {\n    stats_.header_overflow_.inc();\n    return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;\n  } else {\n    return 0;\n  }\n}", "target": 1}
{"code": "AP_CORE_DECLARE(void) ap_parse_uri(request_rec *r, const char *uri)\n{\n    int status = HTTP_OK;\n    r->unparsed_uri = apr_pstrdup(r->pool, uri);\n    while ((uri[0] == '/') && (uri[1] == '/')) {\n        ++uri ;\n    }\n    if (r->method_number == M_CONNECT) {\n        status = apr_uri_parse_hostinfo(r->pool, uri, &r->parsed_uri);\n    }\n    else {\n        status = apr_uri_parse(r->pool, uri, &r->parsed_uri);\n    }\n    if (status == APR_SUCCESS) {\n        if (r->parsed_uri.scheme\n            && !strcasecmp(r->parsed_uri.scheme, ap_http_scheme(r))) {\n            r->hostname = r->parsed_uri.hostname;\n        }\n        else if (r->method_number == M_CONNECT) {\n            r->hostname = r->parsed_uri.hostname;\n        }\n        r->args = r->parsed_uri.query;\n        r->uri = r->parsed_uri.path ? r->parsed_uri.path\n                 : apr_pstrdup(r->pool, \"/\");\n#if defined(OS2) || defined(WIN32)\n        {\n            char *x;\n            for (x = r->uri; (x = strchr(x, '\\\\')) != NULL; )\n                *x = '/';\n        }\n#endif \n    }\n    else {\n        r->args = NULL;\n        r->hostname = NULL;\n        r->status = HTTP_BAD_REQUEST;             \n        r->uri = apr_pstrdup(r->pool, uri);\n    }\n}", "target": 0}
{"code": "ram_addr_t qemu_ram_alloc_internal(ram_addr_t size, ram_addr_t max_size,\n                                   void (*resized)(const char*,\n                                                   uint64_t length,\n                                                   void *host),\n                                   void *host, bool resizeable,\n                                   MemoryRegion *mr, Error **errp)\n{\n    RAMBlock *new_block;\n    ram_addr_t addr;\n    Error *local_err = NULL;\n    size = TARGET_PAGE_ALIGN(size);\n    max_size = TARGET_PAGE_ALIGN(max_size);\n    new_block = g_malloc0(sizeof(*new_block));\n    new_block->mr = mr;\n    new_block->resized = resized;\n    new_block->used_length = size;\n    new_block->max_length = max_size;\n    assert(max_size >= size);\n    new_block->fd = -1;\n    new_block->host = host;\n    if (host) {\n        new_block->flags |= RAM_PREALLOC;\n    }\n    if (resizeable) {\n        new_block->flags |= RAM_RESIZEABLE;\n    }\n    addr = ram_block_add(new_block, &local_err);\n    if (local_err) {\n        g_free(new_block);\n        error_propagate(errp, local_err);\n        return -1;\n    }\n    return addr;\n}", "target": 0}
{"code": "int sas_ex_revalidate_domain(struct domain_device *port_dev)\n{\n\tint res;\n\tstruct domain_device *dev = NULL;\n\tres = sas_find_bcast_dev(port_dev, &dev);\n\twhile (res == 0 && dev) {\n\t\tstruct expander_device *ex = &dev->ex_dev;\n\t\tint i = 0, phy_id;\n\t\tdo {\n\t\t\tphy_id = -1;\n\t\t\tres = sas_find_bcast_phy(dev, &phy_id, i, true);\n\t\t\tif (phy_id == -1)\n\t\t\t\tbreak;\n\t\t\tres = sas_rediscover(dev, phy_id);\n\t\t\ti = phy_id + 1;\n\t\t} while (i < ex->num_phys);\n\t\tdev = NULL;\n\t\tres = sas_find_bcast_dev(port_dev, &dev);\n\t}\n\treturn res;\n}", "target": 1}
{"code": "static int get_pipe(struct stub_device *sdev, int epnum, int dir)\n{\n\tstruct usb_device *udev = sdev->udev;\n\tstruct usb_host_endpoint *ep;\n\tstruct usb_endpoint_descriptor *epd = NULL;\n\tif (dir == USBIP_DIR_IN)\n\t\tep = udev->ep_in[epnum & 0x7f];\n\telse\n\t\tep = udev->ep_out[epnum & 0x7f];\n\tif (!ep) {\n\t\tdev_err(&sdev->udev->dev, \"no such endpoint?, %d\\n\",\n\t\t\tepnum);\n\t\tBUG();\n\t}\n\tepd = &ep->desc;\n\tif (usb_endpoint_xfer_control(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndctrlpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvctrlpipe(udev, epnum);\n\t}\n\tif (usb_endpoint_xfer_bulk(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndbulkpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvbulkpipe(udev, epnum);\n\t}\n\tif (usb_endpoint_xfer_int(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndintpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvintpipe(udev, epnum);\n\t}\n\tif (usb_endpoint_xfer_isoc(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndisocpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvisocpipe(udev, epnum);\n\t}\n\tdev_err(&sdev->udev->dev, \"get pipe, epnum %d\\n\", epnum);\n\treturn 0;\n}", "target": 1}
{"code": "n_start_visual_mode(int c)\n{\n#ifdef FEAT_CONCEAL\n    int cursor_line_was_concealed = curwin->w_p_cole > 0\n\t\t\t\t\t\t&& conceal_cursor_line(curwin);\n#endif\n    VIsual_mode = c;\n    VIsual_active = TRUE;\n    VIsual_reselect = TRUE;\n    trigger_modechanged();\n    if (c == Ctrl_V && (get_ve_flags() & VE_BLOCK) && gchar_cursor() == TAB)\n    {\n\tvalidate_virtcol();\n\tcoladvance(curwin->w_virtcol);\n    }\n    VIsual = curwin->w_cursor;\n#ifdef FEAT_FOLDING\n    foldAdjustVisual();\n#endif\n    setmouse();\n#ifdef FEAT_CONCEAL\n    conceal_check_cursor_line(cursor_line_was_concealed);\n#endif\n    if (p_smd && msg_silent == 0)\n\tredraw_cmdline = TRUE;\t\n#ifdef FEAT_CLIPBOARD\n    clip_star.vmode = NUL;\n#endif\n    if (curwin->w_redr_type < INVERTED)\n    {\n\tcurwin->w_old_cursor_lnum = curwin->w_cursor.lnum;\n\tcurwin->w_old_visual_lnum = curwin->w_cursor.lnum;\n    }\n}", "target": 1}
{"code": "int __nla_validate(const struct nlattr *head, int len, int maxtype,\n\t\t   const struct nla_policy *policy, unsigned int validate,\n\t\t   struct netlink_ext_ack *extack)\n{\n\treturn __nla_validate_parse(head, len, maxtype, policy, validate,\n\t\t\t\t    extack, NULL);\n}", "target": 1}
{"code": "bool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, int *r, struct dest_map *dest_map)\n{\n\tstruct kvm_apic_map *map;\n\tunsigned long bitmap;\n\tstruct kvm_lapic **dst = NULL;\n\tint i;\n\tbool ret;\n\t*r = -1;\n\tif (irq->shorthand == APIC_DEST_SELF) {\n\t\t*r = kvm_apic_set_irq(src->vcpu, irq, dest_map);\n\t\treturn true;\n\t}\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\tret = kvm_apic_map_get_dest_lapic(kvm, &src, irq, map, &dst, &bitmap);\n\tif (ret) {\n\t\t*r = 0;\n\t\tfor_each_set_bit(i, &bitmap, 16) {\n\t\t\tif (!dst[i])\n\t\t\t\tcontinue;\n\t\t\t*r += kvm_apic_set_irq(dst[i]->vcpu, irq, dest_map);\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}", "target": 1}
{"code": "static int skcipher_check_key(struct socket *sock)\n{\n\tint err = 0;\n\tstruct sock *psk;\n\tstruct alg_sock *pask;\n\tstruct skcipher_tfm *tfm;\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tlock_sock(sk);\n\tif (ask->refcnt)\n\t\tgoto unlock_child;\n\tpsk = ask->parent;\n\tpask = alg_sk(ask->parent);\n\ttfm = pask->private;\n\terr = -ENOKEY;\n\tlock_sock_nested(psk, SINGLE_DEPTH_NESTING);\n\tif (!tfm->has_key)\n\t\tgoto unlock;\n\tif (!pask->refcnt++)\n\t\tsock_hold(psk);\n\task->refcnt = 1;\n\tsock_put(psk);\n\terr = 0;\nunlock:\n\trelease_sock(psk);\nunlock_child:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "int sc_compare_oid(const struct sc_object_id *oid1, const struct sc_object_id *oid2)\n{\n\tint i;\n\tif (oid1 == NULL || oid2 == NULL) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\tfor (i = 0; i < SC_MAX_OBJECT_ID_OCTETS; i++)   {\n\t\tif (oid1->value[i] != oid2->value[i])\n\t\t\treturn 0;\n\t\tif (oid1->value[i] == -1)\n\t\t\tbreak;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "int seccomp_lock_personality(unsigned long personality) {\n        uint32_t arch;\n        int r;\n        if (personality >= PERSONALITY_INVALID)\n                return -EINVAL;\n        SECCOMP_FOREACH_LOCAL_ARCH(arch) {\n                _cleanup_(seccomp_releasep) scmp_filter_ctx seccomp = NULL;\n                r = seccomp_init_for_arch(&seccomp, arch, SCMP_ACT_ALLOW);\n                if (r < 0)\n                        return r;\n                r = seccomp_rule_add_exact(\n                                seccomp,\n                                SCMP_ACT_ERRNO(EPERM),\n                                SCMP_SYS(personality),\n                                1,\n                                SCMP_A0(SCMP_CMP_NE, personality));\n                if (r < 0) {\n                        log_debug_errno(r, \"Failed to add scheduler rule for architecture %s, skipping: %m\", seccomp_arch_to_string(arch));\n                        continue;\n                }\n                r = seccomp_load(seccomp);\n                if (IN_SET(r, -EPERM, -EACCES))\n                        return r;\n                if (r < 0)\n                        log_debug_errno(r, \"Failed to enable personality lock for architecture %s, skipping: %m\", seccomp_arch_to_string(arch));\n        }\n        return 0;\n}", "target": 0}
{"code": "BufferedRandomDevice::BufferedRandomDevice(size_t bufferSize)\n  : bufferSize_(bufferSize),\n    buffer_(new unsigned char[bufferSize]),\n    ptr_(buffer_.get() + bufferSize) {  \n  call_once(flag, [this]() {\n    detail::AtFork::registerHandler(\n        this,\n         []() { return true; },\n         []() {},\n        []() {\n          using Single = SingletonThreadLocal<BufferedRandomDevice, RandomTag>;\n          auto& t = Single::get();\n          t.ptr_ = t.buffer_.get() + t.bufferSize_;\n        });\n  });\n}", "target": 0}
{"code": "PJ_DEF(void) pj_scan_get_until_ch( pj_scanner *scanner, \n\t\t\t\t   int until_char, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n    if (s >= scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n    while (PJ_SCAN_CHECK_EOF(s) && *s != until_char) {\n\t++s;\n    }\n    pj_strset3(out, scanner->curptr, s);\n    scanner->curptr = s;\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*s) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);\n    }\n}", "target": 1}
{"code": "static char* guess_timezone(const timelib_tzdb *tzdb TSRMLS_DC)\n{\n\tif (DATEG(timezone) && (strlen(DATEG(timezone))) > 0) {\n\t\treturn DATEG(timezone);\n\t}\n\tif (!DATEG(default_timezone)) {\n\t\tzval ztz;\n\t\tif (SUCCESS == zend_get_configuration_directive(\"date.timezone\", sizeof(\"date.timezone\"), &ztz)\n\t\t\t&& Z_TYPE(ztz) == IS_STRING && Z_STRLEN(ztz) > 0 && timelib_timezone_id_is_valid(Z_STRVAL(ztz), tzdb)) {\n\t\t\treturn Z_STRVAL(ztz);\n\t\t}\n\t} else if (*DATEG(default_timezone)) {\n\t\tif (DATEG(timezone_valid) == 1) {\n\t\t\treturn DATEG(default_timezone);\n\t\t}\n\t\tif (!timelib_timezone_id_is_valid(DATEG(default_timezone), tzdb)) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid date.timezone value '%s', we selected the timezone 'UTC' for now.\", DATEG(default_timezone));\n\t\t\treturn \"UTC\";\n\t\t}\n\t\tDATEG(timezone_valid) = 1;\n\t\treturn DATEG(default_timezone);\n\t}\n\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, DATE_TZ_ERRMSG \"We selected the timezone 'UTC' for now, but please set date.timezone to select your timezone.\");\n\treturn \"UTC\";", "target": 0}
{"code": "void OpenURL(const char *url)\n{\n    if (strchr(url, '\\'') != NULL)\n    {\n        TRACELOG(LOG_WARNING, \"SYSTEM: Provided URL is not valid\");\n    }\n    else\n    {\n#if defined(PLATFORM_DESKTOP)\n        char *cmd = (char *)RL_CALLOC(strlen(url) + 32, sizeof(char));\n    #if defined(_WIN32)\n        sprintf(cmd, \"explorer \\\"%s\\\"\", url);\n    #endif\n    #if defined(__linux__) || defined(__FreeBSD__) || defined(__OpenBSD__)\n        sprintf(cmd, \"xdg-open '%s'\", url); \n    #endif\n    #if defined(__APPLE__)\n        sprintf(cmd, \"open '%s'\", url);\n    #endif\n        int result = system(cmd);\n        if (result == -1) TRACELOG(LOG_WARNING, \"OpenURL() child process could not be created\");\n        RL_FREE(cmd);\n#endif\n#if defined(PLATFORM_WEB)\n        emscripten_run_script(TextFormat(\"window.open('%s', '_blank')\", url));\n#endif\n#if defined(PLATFORM_ANDROID)\n        JNIEnv *env = NULL;\n        JavaVM *vm = CORE.Android.app->activity->vm;\n        (*vm)->AttachCurrentThread(vm, &env, NULL);\n        jstring urlString = (*env)->NewStringUTF(env, url);\n        jclass uriClass = (*env)->FindClass(env, \"android/net/Uri\");\n        jmethodID uriParse = (*env)->GetStaticMethodID(env, uriClass, \"parse\", \"(Ljava/lang/String;)Landroid/net/Uri;\");\n        jobject uri = (*env)->CallStaticObjectMethod(env, uriClass, uriParse, urlString);\n        jclass intentClass = (*env)->FindClass(env, \"android/content/Intent\");\n        jfieldID actionViewId = (*env)->GetStaticFieldID(env, intentClass, \"ACTION_VIEW\", \"Ljava/lang/String;\");\n        jobject actionView = (*env)->GetStaticObjectField(env, intentClass, actionViewId);\n        jmethodID newIntent = (*env)->GetMethodID(env, intentClass, \"<init>\", \"(Ljava/lang/String;Landroid/net/Uri;)V\");\n        jobject intent = (*env)->AllocObject(env, intentClass);\n        (*env)->CallVoidMethod(env, intent, newIntent, actionView, uri);\n        jclass activityClass = (*env)->FindClass(env, \"android/app/Activity\");\n        jmethodID startActivity = (*env)->GetMethodID(env, activityClass, \"startActivity\", \"(Landroid/content/Intent;)V\");\n        (*env)->CallVoidMethod(env, CORE.Android.app->activity->clazz, startActivity, intent);\n        (*vm)->DetachCurrentThread(vm);\n#endif\n    }\n}", "target": 1}
{"code": "static bool disconnect_cb(struct io *io, void *user_data)\n{\n\tstruct bt_att_chan *chan = user_data;\n\tstruct bt_att *att = chan->att;\n\tint err;\n\tsocklen_t len;\n\tlen = sizeof(err);\n\tif (getsockopt(chan->fd, SOL_SOCKET, SO_ERROR, &err, &len) < 0) {\n\t\tutil_debug(chan->att->debug_callback, chan->att->debug_data,\n\t\t\t\t\t\"(chan %p) Failed to obtain disconnect\"\n\t\t\t\t\t\" error: %s\", chan, strerror(errno));\n\t\terr = 0;\n\t}\n\tutil_debug(chan->att->debug_callback, chan->att->debug_data,\n\t\t\t\t\t\"Channel %p disconnected: %s\",\n\t\t\t\t\tchan, strerror(err));\n\tqueue_remove(att->chans, chan);\n\tqueue_remove_all(att->req_queue, NULL, NULL, disc_att_send_op);\n\tqueue_remove_all(att->ind_queue, NULL, NULL, disc_att_send_op);\n\tqueue_remove_all(att->write_queue, NULL, NULL, disc_att_send_op);\n\tif (chan->pending_req) {\n\t\tdisc_att_send_op(chan->pending_req);\n\t\tchan->pending_req = NULL;\n\t}\n\tif (chan->pending_ind) {\n\t\tdisc_att_send_op(chan->pending_ind);\n\t\tchan->pending_ind = NULL;\n\t}\n\tbt_att_chan_free(chan);\n\tif (!queue_isempty(att->chans))\n\t\treturn false;\n\tbt_att_ref(att);\n\tqueue_foreach(att->disconn_list, disconn_handler, INT_TO_PTR(err));\n\tbt_att_unregister_all(att);\n\tbt_att_unref(att);\n\treturn false;\n}", "target": 1}
{"code": "static uint64_t pit_ioport_read(void *opaque, hwaddr addr,\n                                unsigned size)\n{\n    PITCommonState *pit = opaque;\n    int ret, count;\n    PITChannelState *s;\n    addr &= 3;\n    s = &pit->channels[addr];\n    if (s->status_latched) {\n        s->status_latched = 0;\n        ret = s->status;\n    } else if (s->count_latched) {\n        switch(s->count_latched) {\n        default:\n        case RW_STATE_LSB:\n            ret = s->latched_count & 0xff;\n            s->count_latched = 0;\n            break;\n        case RW_STATE_MSB:\n            ret = s->latched_count >> 8;\n            s->count_latched = 0;\n            break;\n        case RW_STATE_WORD0:\n            ret = s->latched_count & 0xff;\n            s->count_latched = RW_STATE_MSB;\n            break;\n        }\n    } else {\n        switch(s->read_state) {\n        default:\n        case RW_STATE_LSB:\n            count = pit_get_count(s);\n            ret = count & 0xff;\n            break;\n        case RW_STATE_MSB:\n            count = pit_get_count(s);\n            ret = (count >> 8) & 0xff;\n            break;\n        case RW_STATE_WORD0:\n            count = pit_get_count(s);\n            ret = count & 0xff;\n            s->read_state = RW_STATE_WORD1;\n            break;\n        case RW_STATE_WORD1:\n            count = pit_get_count(s);\n            ret = (count >> 8) & 0xff;\n            s->read_state = RW_STATE_WORD0;\n            break;\n        }\n    }\n    return ret;\n}", "target": 1}
{"code": "dissect_header_lens_v2_large(tvbuff_t *tvb, wtap_syscall_header* syscall_header, int offset, proto_tree *tree, int encoding)\n{\n    guint32 param_count;\n    proto_item *ti;\n    proto_tree *len_tree;\n    ti = proto_tree_add_item(tree, hf_se_param_lens, tvb, offset, syscall_header->nparams * SYSDIG_PARAM_SIZE_V2_LARGE, ENC_NA);\n    len_tree = proto_item_add_subtree(ti, ett_sysdig_parm_lens);\n    for (param_count = 0; param_count < syscall_header->nparams; param_count++) {\n        proto_tree_add_item(len_tree, hf_se_param_len, tvb, offset + (param_count * SYSDIG_PARAM_SIZE_V2_LARGE), SYSDIG_PARAM_SIZE_V2_LARGE, encoding);\n    }\n    proto_item_set_len(ti, syscall_header->nparams * SYSDIG_PARAM_SIZE_V2_LARGE);\n    return syscall_header->nparams * SYSDIG_PARAM_SIZE_V2_LARGE;\n}", "target": 0}
{"code": "static void iwl_sta_ucode_activate(struct iwl_priv *priv, u8 sta_id)\n{\n\tif (!(priv->stations[sta_id].used & IWL_STA_DRIVER_ACTIVE))\n\t\tIWL_ERR(priv, \"ACTIVATE a non DRIVER active station id %u \"\n\t\t\t\"addr %pM\\n\",\n\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\tif (priv->stations[sta_id].used & IWL_STA_UCODE_ACTIVE) {\n\t\tIWL_DEBUG_ASSOC(priv,\n\t\t\t\t\"STA id %u addr %pM already present in uCode \"\n\t\t\t\t\"(according to driver)\\n\",\n\t\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\t} else {\n\t\tpriv->stations[sta_id].used |= IWL_STA_UCODE_ACTIVE;\n\t\tIWL_DEBUG_ASSOC(priv, \"Added STA id %u addr %pM to uCode\\n\",\n\t\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\t}\n}", "target": 1}
{"code": "static int update_write_order_info(rdpContext* context, wStream* s, ORDER_INFO* orderInfo,\n                                   size_t offset)\n{\n\tsize_t position;\n\tWINPR_UNUSED(context);\n\tposition = Stream_GetPosition(s);\n\tStream_SetPosition(s, offset);\n\tStream_Write_UINT8(s, orderInfo->controlFlags); \n\tif (orderInfo->controlFlags & ORDER_TYPE_CHANGE)\n\t\tStream_Write_UINT8(s, orderInfo->orderType); \n\tupdate_write_field_flags(s, orderInfo->fieldFlags, orderInfo->controlFlags,\n\t                         PRIMARY_DRAWING_ORDER_FIELD_BYTES[orderInfo->orderType]);\n\tupdate_write_bounds(s, orderInfo);\n\tStream_SetPosition(s, position);\n\treturn 0;\n}", "target": 1}
{"code": "      CImg<boolT> is_inside_string(CImg<charT>& expr) const {\n        bool is_escaped = false, next_is_escaped = false;\n        unsigned int mode = 0, next_mode = 0; \n        CImg<boolT> res = CImg<charT>::string(expr);\n        bool *pd = res._data;\n        for (const char *ps = expr._data; *ps; ++ps) {\n          if (!next_is_escaped && *ps=='\\\\') next_is_escaped = true;\n          if (!is_escaped && *ps=='\\'') { \n            if (!mode && ps>expr._data && *(ps - 1)=='[') next_mode = mode = 2; \n            else if (mode==2 && *(ps + 1)==']') next_mode = !mode; \n            else if (mode<2) next_mode = mode?(mode = 0):1; \n          }\n          *(pd++) = mode>=1 || is_escaped;\n          mode = next_mode;\n          is_escaped = next_is_escaped;\n          next_is_escaped = false;\n        }\n        return res;", "target": 0}
{"code": "static int tight_compress_data(VncState *vs, int stream_id, size_t bytes,\n                               int level, int strategy)\n{\n    z_streamp zstream = &vs->tight->stream[stream_id];\n    int previous_out;\n    if (bytes < VNC_TIGHT_MIN_TO_COMPRESS) {\n        vnc_write(vs, vs->tight->tight.buffer, vs->tight->tight.offset);\n        return bytes;\n    }\n    if (tight_init_stream(vs, stream_id, level, strategy)) {\n        return -1;\n    }\n    buffer_reserve(&vs->tight->zlib, bytes + 64);\n    zstream->next_in = vs->tight->tight.buffer;\n    zstream->avail_in = vs->tight->tight.offset;\n    zstream->next_out = vs->tight->zlib.buffer + vs->tight->zlib.offset;\n    zstream->avail_out = vs->tight->zlib.capacity - vs->tight->zlib.offset;\n    previous_out = zstream->avail_out;\n    zstream->data_type = Z_BINARY;\n    if (deflate(zstream, Z_SYNC_FLUSH) != Z_OK) {\n        fprintf(stderr, \"VNC: error during tight compression\\n\");\n        return -1;\n    }\n    vs->tight->zlib.offset = vs->tight->zlib.capacity - zstream->avail_out;\n    bytes = previous_out - zstream->avail_out;\n    tight_send_compact_size(vs, bytes);\n    vnc_write(vs, vs->tight->zlib.buffer, bytes);\n    buffer_reset(&vs->tight->zlib);\n    return bytes;\n}", "target": 0}
{"code": "static struct dump_dir *open_directory_for_modification_of_element(\n    GDBusMethodInvocation *invocation,\n    uid_t caller_uid,\n    const char *problem_id,\n    const char *element)\n{\n    static const char *const protected_elements[] = {\n        FILENAME_TIME,\n        FILENAME_UID,\n        NULL,\n    };\n    for (const char *const *protected = protected_elements; *protected; ++protected)\n    {\n        if (strcmp(*protected, element) == 0)\n        {\n            log_notice(\"'%s' element of '%s' can't be modified\", element, problem_id);\n            char *error = xasprintf(_(\"'%s' element can't be modified\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                        \"org.freedesktop.problems.ProtectedElement\",\n                                        error);\n            free(error);\n            return NULL;\n        }\n    }\n    if (!dump_dir_accessible_by_uid(problem_id, caller_uid))\n    {\n        if (errno == ENOTDIR)\n        {\n            log_notice(\"'%s' is not a valid problem directory\", problem_id);\n            return_InvalidProblemDir_error(invocation, problem_id);\n        }\n        else\n        {\n            log_notice(\"UID(%d) is not Authorized to access '%s'\", caller_uid, problem_id);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                \"org.freedesktop.problems.AuthFailure\",\n                                _(\"Not Authorized\"));\n        }\n        return NULL;\n    }\n    struct dump_dir *dd = dd_opendir(problem_id,  0);\n    if (!dd)\n    {   \n        log_notice(\"Can't access the problem '%s' for modification\", problem_id);\n        g_dbus_method_invocation_return_dbus_error(invocation,\n                                \"org.freedesktop.problems.Failure\",\n                                _(\"Can't access the problem for modification\"));\n        return NULL;\n    }\n    return dd;\n}", "target": 1}
{"code": "display_debug_macinfo (struct dwarf_section *section,\n\t\t       void *file ATTRIBUTE_UNUSED)\n{\n  unsigned char *start = section->start;\n  unsigned char *end = start + section->size;\n  unsigned char *curr = start;\n  enum dwarf_macinfo_record_type op;\n  introduce (section, false);\n  while (curr < end)\n    {\n      unsigned int lineno;\n      const unsigned char *string;\n      op = (enum dwarf_macinfo_record_type) *curr;\n      curr++;\n      switch (op)\n\t{\n\tcase DW_MACINFO_start_file:\n\t  {\n\t    unsigned int filenum;\n\t    READ_ULEB (lineno, curr, end);\n\t    READ_ULEB (filenum, curr, end);\n\t    printf (_(\" DW_MACINFO_start_file - lineno: %d filenum: %d\\n\"),\n\t\t    lineno, filenum);\n\t  }\n\t  break;\n\tcase DW_MACINFO_end_file:\n\t  printf (_(\" DW_MACINFO_end_file\\n\"));\n\t  break;\n\tcase DW_MACINFO_define:\n\t  READ_ULEB (lineno, curr, end);\n\t  string = curr;\n\t  curr += strnlen ((char *) string, end - string);\n\t  printf (_(\" DW_MACINFO_define - lineno : %d macro : %*s\\n\"),\n\t\t  lineno, (int) (curr - string), string);\n\t  if (curr < end)\n\t    curr++;\n\t  break;\n\tcase DW_MACINFO_undef:\n\t  READ_ULEB (lineno, curr, end);\n\t  string = curr;\n\t  curr += strnlen ((char *) string, end - string);\n\t  printf (_(\" DW_MACINFO_undef - lineno : %d macro : %*s\\n\"),\n\t\t  lineno, (int) (curr - string), string);\n\t  if (curr < end)\n\t    curr++;\n\t  break;\n\tcase DW_MACINFO_vendor_ext:\n\t  {\n\t    unsigned int constant;\n\t    READ_ULEB (constant, curr, end);\n\t    string = curr;\n\t    curr += strnlen ((char *) string, end - string);\n\t    printf (_(\" DW_MACINFO_vendor_ext - constant : %d string : %*s\\n\"),\n\t\t    constant, (int) (curr - string), string);\n\t    if (curr < end)\n\t      curr++;\n\t  }\n\t  break;\n\t}\n    }\n  return 1;\n}", "target": 0}
{"code": "TfLiteStatus GatherNd(const TfLiteTensor* params, const TfLiteTensor* indices,\n                      TfLiteTensor* output) {\n  reference_ops::GatherNd(\n      GetTensorShape(params), GetTensorData<ParamsT>(params),\n      GetTensorShape(indices), GetTensorData<IndicesT>(indices),\n      GetTensorShape(output), GetTensorData<ParamsT>(output));\n  return kTfLiteOk;\n}", "target": 1}
{"code": "ptp_unpack_OPL (PTPParams *params, unsigned char* data, MTPProperties **pprops, unsigned int len)\n{ \n\tuint32_t prop_count = dtoh32a(data);\n\tMTPProperties *props = NULL;\n\tunsigned int offset = 0, i;\n\t*pprops = NULL;\n\tif (prop_count == 0)\n\t\treturn 0;\n\tif (prop_count >= INT_MAX/sizeof(MTPProperties)) {\n\t\tptp_debug (params ,\"prop_count %d is too large\", prop_count);\n\t\treturn 0;\n\t}\n\tptp_debug (params ,\"Unpacking MTP OPL, size %d (prop_count %d)\", len, prop_count);\n\tdata += sizeof(uint32_t);\n\tlen -= sizeof(uint32_t);\n\tprops = malloc(prop_count * sizeof(MTPProperties));\n\tif (!props) return 0;\n\tfor (i = 0; i < prop_count; i++) {\n\t\tif (len <= 0) {\n\t\t\tptp_debug (params ,\"short MTP Object Property List at property %d (of %d)\", i, prop_count);\n\t\t\tptp_debug (params ,\"device probably needs DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL\");\n\t\t\tptp_debug (params ,\"or even DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST\", i);\n\t\t\tqsort (props, i, sizeof(MTPProperties),_compare_func);\n\t\t\t*pprops = props;\n\t\t\treturn i;\n\t\t}\n\t\tprops[i].ObjectHandle = dtoh32a(data);\n\t\tdata += sizeof(uint32_t);\n\t\tlen -= sizeof(uint32_t);\n\t\tprops[i].property = dtoh16a(data);\n\t\tdata += sizeof(uint16_t);\n\t\tlen -= sizeof(uint16_t);\n\t\tprops[i].datatype = dtoh16a(data);\n\t\tdata += sizeof(uint16_t);\n\t\tlen -= sizeof(uint16_t);\n\t\toffset = 0;\n\t\tif (!ptp_unpack_DPV(params, data, &offset, len, &props[i].propval, props[i].datatype)) {\n\t\t\tptp_debug (params ,\"unpacking DPV of property %d encountered insufficient buffer. attack?\", i);\n\t\t\tqsort (props, i, sizeof(MTPProperties),_compare_func);\n\t\t\t*pprops = props;\n\t\t\treturn i;\n\t\t}\n\t\tdata += offset;\n\t\tlen -= offset;\n\t}\n\tqsort (props, prop_count, sizeof(MTPProperties),_compare_func);\n\t*pprops = props;\n\treturn prop_count;\n}", "target": 1}
{"code": "struct file_list *flist_for_ndx(int ndx, const char *fatal_error_loc)\n{\n\tstruct file_list *flist = cur_flist;\n\tif (!flist && !(flist = first_flist))\n\t\tgoto not_found;\n\twhile (ndx < flist->ndx_start-1) {\n\t\tif (flist == first_flist)\n\t\t\tgoto not_found;\n\t\tflist = flist->prev;\n\t}\n\twhile (ndx >= flist->ndx_start + flist->used) {\n\t\tif (!(flist = flist->next))\n\t\t\tgoto not_found;\n\t}\n\treturn flist;\n  not_found:\n\tif (fatal_error_loc) {\n\t\tint first, last;\n\t\tif (first_flist) {\n\t\t\tfirst = first_flist->ndx_start - 1;\n\t\t\tlast = first_flist->prev->ndx_start + first_flist->prev->used - 1;\n\t\t} else {\n\t\t\tfirst = 0;\n\t\t\tlast = -1;\n\t\t}\n\t\trprintf(FERROR,\n\t\t\t\"File-list index %d not in %d - %d (%s) [%s]\\n\",\n\t\t\tndx, first, last, fatal_error_loc, who_am_i());\n\t\texit_cleanup(RERR_PROTOCOL);\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "gxps_images_guess_content_type (GXPSArchive *zip,\n\t\t\t\tconst gchar *image_uri)\n{\n\tGInputStream *stream;\n\tguchar        buffer[1024];\n\tgssize        bytes_read;\n\tgchar        *mime_type;\n\tstream = gxps_archive_open (zip, image_uri);\n\tif (!stream)\n\t\treturn NULL;\n\tbytes_read = g_input_stream_read (stream, buffer, 1024, NULL, NULL);\n\tmime_type = g_content_type_guess (NULL, buffer, bytes_read, NULL);\n\tg_object_unref (stream);\n\treturn mime_type;\n}", "target": 0}
{"code": "fill_yin_revision(struct lys_module *module, struct lyxml_elem *yin, struct lys_revision *rev,\n                  struct unres_schema *unres)\n{\n    struct ly_ctx *ctx = module->ctx;\n    struct lyxml_elem *next, *child;\n    const char *value;\n    GETVAL(ctx, value, yin, \"date\");\n    if (lyp_check_date(ctx, value)) {\n        goto error;\n    }\n    memcpy(rev->date, value, LY_REV_SIZE - 1);\n    LY_TREE_FOR_SAFE(yin->child, next, child) {\n        if (!child->ns) {\n            continue;\n        } else if (strcmp(child->ns->value, LY_NSYIN)) {\n            if (lyp_yin_parse_subnode_ext(module, rev, LYEXT_PAR_REVISION,\n                                          child, LYEXT_SUBSTMT_SELF, 0, unres)) {\n                goto error;\n            }\n        } else if (!strcmp(child->name, \"description\")) {\n            if (rev->dsc) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, child->name, yin->name);\n                goto error;\n            }\n            if (lyp_yin_parse_subnode_ext(module, rev, LYEXT_PAR_REVISION,\n                                          child, LYEXT_SUBSTMT_DESCRIPTION, 0, unres)) {\n                goto error;\n            }\n            rev->dsc = read_yin_subnode(ctx, child, \"text\");\n            if (!rev->dsc) {\n                goto error;\n            }\n        } else if (!strcmp(child->name, \"reference\")) {\n            if (rev->ref) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, child->name, yin->name);\n                goto error;\n            }\n            if (lyp_yin_parse_subnode_ext(module, rev, LYEXT_PAR_REVISION,\n                                          child, LYEXT_SUBSTMT_REFERENCE, 0, unres)) {\n                goto error;\n            }\n            rev->ref = read_yin_subnode(ctx, child, \"text\");\n            if (!rev->ref) {\n                goto error;\n            }\n        } else {\n            LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, child->name);\n            goto error;\n        }\n    }\n    return EXIT_SUCCESS;\nerror:\n    return EXIT_FAILURE;\n}", "target": 0}
{"code": "static int fastrpc_dma_buf_attach(struct dma_buf *dmabuf,\n\t\t\t\t  struct dma_buf_attachment *attachment)\n{\n\tstruct fastrpc_dma_buf_attachment *a;\n\tstruct fastrpc_buf *buffer = dmabuf->priv;\n\tint ret;\n\ta = kzalloc(sizeof(*a), GFP_KERNEL);\n\tif (!a)\n\t\treturn -ENOMEM;\n\tret = dma_get_sgtable(buffer->dev, &a->sgt, buffer->virt,\n\t\t\t      FASTRPC_PHYS(buffer->phys), buffer->size);\n\tif (ret < 0) {\n\t\tdev_err(buffer->dev, \"failed to get scatterlist from DMA API\\n\");\n\t\treturn -EINVAL;\n\t}\n\ta->dev = attachment->dev;\n\tINIT_LIST_HEAD(&a->node);\n\tattachment->priv = a;\n\tmutex_lock(&buffer->lock);\n\tlist_add(&a->node, &buffer->attachments);\n\tmutex_unlock(&buffer->lock);\n\treturn 0;\n}", "target": 1}
{"code": "static void umd_cleanup(struct subprocess_info *info)\n{\n\tstruct umd_info *umd_info = info->data;\n\tif (info->retval) {\n\t\tfput(umd_info->pipe_to_umh);\n\t\tfput(umd_info->pipe_from_umh);\n\t\tput_pid(umd_info->tgid);\n\t\tumd_info->tgid = NULL;\n\t}\n}", "target": 1}
{"code": "static int snd_timer_register_system(void)\n{\n\tstruct snd_timer *timer;\n\tstruct snd_timer_system_private *priv;\n\tint err;\n\terr = snd_timer_global_new(\"system\", SNDRV_TIMER_GLOBAL_SYSTEM, &timer);\n\tif (err < 0)\n\t\treturn err;\n\tstrcpy(timer->name, \"system timer\");\n\ttimer->hw = snd_timer_system;\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (priv == NULL) {\n\t\tsnd_timer_free(timer);\n\t\treturn -ENOMEM;\n\t}\n\tsetup_timer(&priv->tlist, snd_timer_s_function, (unsigned long) timer);\n\ttimer->private_data = priv;\n\ttimer->private_free = snd_timer_free_system;\n\treturn snd_timer_global_register(timer);\n}", "target": 0}
{"code": "Network::TransportSocketPtr ClientSslSocketFactory::createTransportSocket(\n    Network::TransportSocketOptionsConstSharedPtr transport_socket_options,\n    Upstream::HostDescriptionConstSharedPtr) const {\n  Envoy::Ssl::ClientContextSharedPtr ssl_ctx;\n  {\n    absl::ReaderMutexLock l(&ssl_ctx_mu_);\n    ssl_ctx = ssl_ctx_;\n  }\n  if (ssl_ctx) {\n    return std::make_unique<SslSocket>(std::move(ssl_ctx), InitialState::Client,\n                                       transport_socket_options, config_->createHandshaker());\n  } else {\n    ENVOY_LOG(debug, \"Create NotReadySslSocket\");\n    stats_.upstream_context_secrets_not_ready_.inc();\n    return std::make_unique<NotReadySslSocket>();\n  }\n}", "target": 1}
{"code": "static MagickBooleanType TIFFGetProfiles(TIFF *tiff,Image *image,\n  ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n  uint32\n    length = 0;\n  unsigned char\n    *profile = (unsigned char *) NULL;\n  status=MagickTrue;\n#if defined(TIFFTAG_ICCPROFILE)\n  if ((TIFFGetField(tiff,TIFFTAG_ICCPROFILE,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    status=ReadProfile(image,\"icc\",profile,(ssize_t) length,exception);\n#endif\n#if defined(TIFFTAG_PHOTOSHOP)\n  if ((TIFFGetField(tiff,TIFFTAG_PHOTOSHOP,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    status=ReadProfile(image,\"8bim\",profile,(ssize_t) length,exception);\n#endif\n#if defined(TIFFTAG_RICHTIFFIPTC)\n  if ((TIFFGetField(tiff,TIFFTAG_RICHTIFFIPTC,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    {\n      if (TIFFIsByteSwapped(tiff) != 0)\n        TIFFSwabArrayOfLong((uint32 *) profile,(size_t) length);\n      status=ReadProfile(image,\"iptc\",profile,4L*length,exception);\n    }\n#endif\n#if defined(TIFFTAG_XMLPACKET)\n  if ((TIFFGetField(tiff,TIFFTAG_XMLPACKET,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    {\n      StringInfo\n        *dng;\n      status=ReadProfile(image,\"xmp\",profile,(ssize_t) length,exception);\n      dng=BlobToStringInfo(profile,length);\n      if (dng != (StringInfo *) NULL)\n        {\n          const char\n            *target = \"dc:format=\\\"image/dng\\\"\";\n          if (strstr((char *) GetStringInfoDatum(dng),target) != (char *) NULL)\n            (void) CopyMagickString(image->magick,\"DNG\",MagickPathExtent);\n          dng=DestroyStringInfo(dng);\n        }\n    }\n#endif\n  if ((TIFFGetField(tiff,34118,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    status=ReadProfile(image,\"tiff:34118\",profile,(ssize_t) length,\n      exception);\n  if ((TIFFGetField(tiff,37724,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    status=ReadProfile(image,\"tiff:37724\",profile,(ssize_t) length,exception);\n  return(status);\n}", "target": 1}
{"code": "LIBOPENMPT_MODPLUG_API unsigned int ModPlug_InstrumentName(ModPlugFile* file, unsigned int qual, char* buff)\n{\n\tconst char* str;\n\tunsigned int retval;\n\tsize_t tmpretval;\n\tif(!file) return 0;\n\tstr = openmpt_module_get_instrument_name(file->mod,qual-1);\n\tif(!str){\n\t\tif(buff){\n\t\t\t*buff = '\\0';\n\t\t}\n\t\treturn 0;\n\t}\n\ttmpretval = strlen(str);\n\tif(tmpretval>=INT_MAX){\n\t\ttmpretval = INT_MAX-1;\n\t}\n\tretval = (int)tmpretval;\n\tif(buff){\n\t\tmemcpy(buff,str,retval+1);\n\t\tbuff[retval] = '\\0';\n\t}\n\topenmpt_free_string(str);\n\treturn retval;\n}", "target": 1}
{"code": "Tss2_RC_Decode(TSS2_RC rc)\n{\n    static __thread char buf[TSS2_ERR_LAYER_NAME_MAX + TSS2_ERR_LAYER_ERROR_STR_MAX + 1];\n    clearbuf(buf);\n    UINT8 layer = tss2_rc_layer_number_get(rc);\n    TSS2_RC_HANDLER handler = layer_handler[layer].handler;\n    const char *lname = layer_handler[layer].name;\n    if (lname[0]) {\n        catbuf(buf, \"%s:\", lname);\n    } else {\n        catbuf(buf, \"%u:\", layer);\n    }\n    handler = !handler ? unknown_layer_handler : handler;\n    UINT16 err_bits = tpm2_error_get(rc);\n    const char *e = err_bits ? handler(err_bits) : \"success\";\n    if (e) {\n        catbuf(buf, \"%s\", e);\n    } else {\n        catbuf(buf, \"0x%X\", err_bits);\n    }\n    return buf;\n}", "target": 1}
{"code": "static void kiss_unesc(struct mkiss *ax, unsigned char s)\n{\n\tswitch (s) {\n\tcase END:\n\t\tif (test_bit(AXF_KEEPTEST, &ax->flags))\n\t\t\tclear_bit(AXF_KEEPTEST, &ax->flags);\n\t\tif (!test_and_clear_bit(AXF_ERROR, &ax->flags) && (ax->rcount > 2))\n\t\t\tax_bump(ax);\n\t\tclear_bit(AXF_ESCAPE, &ax->flags);\n\t\tax->rcount = 0;\n\t\treturn;\n\tcase ESC:\n\t\tset_bit(AXF_ESCAPE, &ax->flags);\n\t\treturn;\n\tcase ESC_ESC:\n\t\tif (test_and_clear_bit(AXF_ESCAPE, &ax->flags))\n\t\t\ts = ESC;\n\t\tbreak;\n\tcase ESC_END:\n\t\tif (test_and_clear_bit(AXF_ESCAPE, &ax->flags))\n\t\t\ts = END;\n\t\tbreak;\n\t}\n\tspin_lock_bh(&ax->buflock);\n\tif (!test_bit(AXF_ERROR, &ax->flags)) {\n\t\tif (ax->rcount < ax->buffsize) {\n\t\t\tax->rbuff[ax->rcount++] = s;\n\t\t\tspin_unlock_bh(&ax->buflock);\n\t\t\treturn;\n\t\t}\n\t\tax->dev->stats.rx_over_errors++;\n\t\tset_bit(AXF_ERROR, &ax->flags);\n\t}\n\tspin_unlock_bh(&ax->buflock);\n}", "target": 0}
{"code": "    StringValue::StringValue(const std::string& buf)\n        : StringValueBase(string, buf)\n    {\n    }", "target": 0}
{"code": "receive_carbon(void **state)\n{\n    prof_input(\"/carbons on\");\n    prof_connect();\n    assert_true(stbbr_received(\n        \"<iq id='*' type='set'><enable xmlns='urn:xmpp:carbons:2'/></iq>\"\n    ));\n    stbbr_send(\n        \"<presence to='stabber@localhost' from='buddy1@localhost/mobile'>\"\n            \"<priority>10</priority>\"\n            \"<status>On my mobile</status>\"\n        \"</presence>\"\n    );\n    assert_true(prof_output_exact(\"Buddy1 (mobile) is online, \\\"On my mobile\\\"\"));\n    prof_input(\"/msg Buddy1\");\n    assert_true(prof_output_exact(\"unencrypted\"));\n    stbbr_send(\n        \"<message type='chat' to='stabber@localhost/profanity' from='buddy1@localhost'>\"\n            \"<received xmlns='urn:xmpp:carbons:2'>\"\n                \"<forwarded xmlns='urn:xmpp:forward:0'>\"\n                    \"<message id='prof_msg_7' xmlns='jabber:client' type='chat' lang='en' to='stabber@localhost/profanity' from='buddy1@localhost/mobile'>\"\n                        \"<body>test carbon from recipient</body>\"\n                    \"</message>\"\n                \"</forwarded>\"\n            \"</received>\"\n        \"</message>\"\n    );\n    assert_true(prof_output_regex(\"Buddy1/mobile: .+test carbon from recipient\"));\n}", "target": 1}
{"code": "xface2xpm(char *xface)\n{\n    Image image;\n    ImageCache *cache;\n    FILE *f;\n    struct stat st;\n    SKIP_BLANKS(xface);\n    image.url = xface;\n    image.ext = \".xpm\";\n    image.width = 48;\n    image.height = 48;\n    image.cache = NULL;\n    cache = getImage(&image, NULL, IMG_FLAG_AUTO);\n    if (cache->loaded & IMG_FLAG_LOADED && !stat(cache->file, &st))\n\treturn cache->file;\n    cache->loaded = IMG_FLAG_ERROR;\n    f = popen(Sprintf(\"%s > %s\", shell_quote(auxbinFile(XFACE2XPM)),\n\t\t      shell_quote(cache->file))->ptr, \"w\");\n    if (!f)\n\treturn NULL;\n    fputs(xface, f);\n    pclose(f);\n    if (stat(cache->file, &st) || !st.st_size)\n\treturn NULL;\n    cache->loaded = IMG_FLAG_LOADED | IMG_FLAG_DONT_REMOVE;\n    cache->index = 0;\n    return cache->file;\n}", "target": 0}
{"code": "static int adpt_reset(struct scsi_cmnd* cmd)\n{\n\tint rc;\n\tspin_lock_irq(cmd->device->host->host_lock);\n\trc = __adpt_reset(cmd);\n\tspin_unlock_irq(cmd->device->host->host_lock);\n\treturn rc;\n}", "target": 1}
{"code": "bool ChildProcessSecurityPolicy::CanReadRawCookies(int renderer_id) {\n  AutoLock lock(lock_);\n  SecurityStateMap::iterator state = security_state_.find(renderer_id);\n  if (state == security_state_.end())\n    return false;\n  return state->second->can_read_raw_cookies();\n}", "target": 0}
{"code": "\t__releases(rq->lock)\n{\n\tstruct rq *rq = this_rq();\n\tstruct mm_struct *mm = rq->prev_mm;\n\tlong prev_state;\n\tif (WARN_ONCE(preempt_count() != 2*PREEMPT_DISABLE_OFFSET,\n\t\t      \"corrupted preempt_count: %s/%d/0x%x\\n\",\n\t\t      current->comm, current->pid, preempt_count()))\n\t\tpreempt_count_set(FORK_PREEMPT_COUNT);\n\trq->prev_mm = NULL;\n\tprev_state = prev->state;\n\tvtime_task_switch(prev);\n\tperf_event_task_sched_in(prev, current);\n\tfinish_lock_switch(rq, prev);\n\tfinish_arch_post_lock_switch();\n\tfire_sched_in_preempt_notifiers(current);\n\tif (mm)\n\t\tmmdrop(mm);\n\tif (unlikely(prev_state == TASK_DEAD)) {\n\t\tif (prev->sched_class->task_dead)\n\t\t\tprev->sched_class->task_dead(prev);\n\t\tkprobe_flush_task(prev);\n\t\tput_task_struct(prev);\n\t}\n\ttick_nohz_task_switch();\n\treturn rq;\n}", "target": 0}
{"code": "writefile(const char *name, struct string *s)\n{\n\tFILE *f;\n\tint ret;\n\tf = fopen(name, \"w\");\n\tif (!f) {\n\t\twarn(\"open %s:\", name);\n\t\treturn -1;\n\t}\n\tret = 0;\n\tif (fwrite(s->s, 1, s->n, f) != s->n || fflush(f) != 0) {\n\t\twarn(\"write %s:\", name);\n\t\tret = -1;\n\t}\n\tfclose(f);\n\treturn ret;\n}", "target": 1}
{"code": "oftrace_add_recirc_node(struct ovs_list *recirc_queue,\n                        enum oftrace_recirc_type type, const struct flow *flow,\n                        const struct dp_packet *packet, uint32_t recirc_id,\n                        const uint16_t zone)\n{\n    if (!recirc_id_node_find_and_ref(recirc_id)) {\n        return false;\n    }\n    struct oftrace_recirc_node *node = xmalloc(sizeof *node);\n    ovs_list_push_back(recirc_queue, &node->node);\n    node->type = type;\n    node->recirc_id = recirc_id;\n    node->flow = *flow;\n    node->flow.recirc_id = recirc_id;\n    node->flow.ct_zone = zone;\n    node->packet = packet ? dp_packet_clone(packet) : NULL;\n    return true;\n}", "target": 0}
{"code": "int sldns_str2wire_eui48_buf(const char* str, uint8_t* rd, size_t* len)\n{\n\tunsigned int a, b, c, d, e, f;\n\tint l;\n\tif(*len < 6)\n\t\treturn LDNS_WIREPARSE_ERR_BUFFER_TOO_SMALL;\n\tif (sscanf(str, \"%2x-%2x-%2x-%2x-%2x-%2x%n\",\n\t\t\t&a, &b, &c, &d, &e, &f, &l) != 6 ||\n\t\t\tl != (int)strlen(str))\n\t\treturn LDNS_WIREPARSE_ERR_SYNTAX_EUI48;\n\trd[0] = a;\n\trd[1] = b;\n\trd[2] = c;\n\trd[3] = d;\n\trd[4] = e;\n\trd[5] = f;\n\t*len = 6;\n\treturn LDNS_WIREPARSE_ERR_OK;\n}", "target": 0}
{"code": "inline int MatchingDim(const RuntimeShape& shape1, int index1,\n                       const RuntimeShape& shape2, int index2) {\n  TFLITE_DCHECK_EQ(shape1.Dims(index1), shape2.Dims(index2));\n  return shape1.Dims(index1);\n}", "target": 1}
{"code": "static void __init clear_bss(void)\n{\n\tmemset(__bss_start, 0,\n\t       (unsigned long) __bss_stop - (unsigned long) __bss_start);\n}", "target": 1}
{"code": "int i915_gem_context_destroy_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t   struct drm_file *file)\n{\n\tstruct drm_i915_gem_context_destroy *args = data;\n\tstruct drm_i915_file_private *file_priv = file->driver_priv;\n\tstruct i915_gem_context *ctx;\n\tint ret;\n\tif (args->pad != 0)\n\t\treturn -EINVAL;\n\tif (args->ctx_id == DEFAULT_CONTEXT_HANDLE)\n\t\treturn -ENOENT;\n\tctx = i915_gem_context_lookup(file_priv, args->ctx_id);\n\tif (!ctx)\n\t\treturn -ENOENT;\n\tret = mutex_lock_interruptible(&dev->struct_mutex);\n\tif (ret)\n\t\tgoto out;\n\tidr_remove(&file_priv->context_idr, ctx->user_handle);\n\tcontext_close(ctx);\n\tmutex_unlock(&dev->struct_mutex);\nout:\n\ti915_gem_context_put(ctx);\n\treturn 0;\n}", "target": 1}
{"code": "defbackend_bind( Slapi_PBlock *pb )\n{\n    int\t\t\trc;\n    ber_tag_t\t\tmethod;\n    struct berval\t*cred;\n    LDAPDebug( LDAP_DEBUG_TRACE, \"defbackend_bind\\n\", 0, 0, 0 );\n    slapi_pblock_get( pb, SLAPI_BIND_METHOD, &method );\n    slapi_pblock_get( pb, SLAPI_BIND_CREDENTIALS, &cred );\n    if ( method == LDAP_AUTH_SIMPLE && cred->bv_len == 0 ) {\n\tslapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsAnonymousBinds);\n\trc = SLAPI_BIND_ANONYMOUS;\n    } else {\n\tsend_nobackend_ldap_result( pb );\n\trc = SLAPI_BIND_FAIL;\n    }\n    return( rc );\n}", "target": 1}
{"code": "restore_page_device(i_ctx_t *i_ctx_p, const gs_gstate * pgs_old, const gs_gstate * pgs_new)\n{\n    gx_device *dev_old = gs_currentdevice(pgs_old);\n    gx_device *dev_new;\n    gx_device *dev_t1;\n    gx_device *dev_t2;\n    bool samepagedevice = obj_eq(dev_old->memory, &gs_int_gstate(pgs_old)->pagedevice,\n        &gs_int_gstate(pgs_new)->pagedevice);\n    bool LockSafetyParams = dev_old->LockSafetyParams;\n    if ((dev_t1 = (*dev_proc(dev_old, get_page_device)) (dev_old)) == 0)\n        return 0;\n    if (!samepagedevice)\n        dev_old->LockSafetyParams = false;\n    dev_new = gs_currentdevice(pgs_new);\n    if (dev_old != dev_new) {\n        if ((dev_t2 = (*dev_proc(dev_new, get_page_device)) (dev_new)) == 0)\n            samepagedevice = true;\n        else if (dev_t1 != dev_t2)\n            samepagedevice = false;\n    }\n    if (LockSafetyParams) {\n        const int required_ops = 512;\n        const int required_es = 32;\n        if (required_ops + ref_stack_count(&o_stack) >= ref_stack_max_count(&o_stack)) {\n           gs_currentdevice(pgs_old)->LockSafetyParams = LockSafetyParams;\n           return_error(gs_error_stackoverflow);\n        }\n        if (required_es + ref_stack_count(&e_stack) >= ref_stack_max_count(&e_stack)) {\n           gs_currentdevice(pgs_old)->LockSafetyParams = LockSafetyParams;\n           return_error(gs_error_execstackoverflow);\n        }\n    }\n    return samepagedevice ? 0 : 1;\n}", "target": 0}
{"code": "SPL_METHOD(SplDoublyLinkedList, unserialize)\n{\n\tspl_dllist_object     *intern   = (spl_dllist_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tzval                  *flags, *elem;\n\tchar *buf;\n\tint buf_len;\n\tconst unsigned char *p, *s;\n\tphp_unserialize_data_t var_hash;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &buf, &buf_len) == FAILURE) {\n\t\treturn;\n\t}\n\tif (buf_len == 0) {\n\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Serialized string cannot be empty\");\n\t\treturn;\n\t}\n\ts = p = (const unsigned char*)buf;\n\tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n\tALLOC_INIT_ZVAL(flags);\n\tif (!php_var_unserialize(&flags, &p, s + buf_len, &var_hash TSRMLS_CC) || Z_TYPE_P(flags) != IS_LONG) {\n\t\tzval_ptr_dtor(&flags);\n\t\tgoto error;\n\t}\n\tintern->flags = Z_LVAL_P(flags);\n\tzval_ptr_dtor(&flags);\n\twhile(*p == ':') {\n\t\t++p;\n\t\tALLOC_INIT_ZVAL(elem);\n\t\tif (!php_var_unserialize(&elem, &p, s + buf_len, &var_hash TSRMLS_CC)) {\n\t\t\tzval_ptr_dtor(&elem);\n\t\t\tgoto error;\n\t\t}\n\t\tspl_ptr_llist_push(intern->llist, elem TSRMLS_CC);\n\t}\n\tif (*p != '\\0') {\n\t\tgoto error;\n\t}\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\treturn;\nerror:\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Error at offset %ld of %d bytes\", (long)((char*)p - buf), buf_len);\n\treturn;\n} ", "target": 1}
{"code": "inline int32_t byteswap(int32_t value) { return _af_byteswap_int32(value); }", "target": 0}
{"code": "static int nbd_receive_option_reply(QIOChannel *ioc, uint32_t opt,\n                                    nbd_opt_reply *reply, Error **errp)\n{\n    QEMU_BUILD_BUG_ON(sizeof(*reply) != 20);\n    if (read_sync(ioc, reply, sizeof(*reply)) != sizeof(*reply)) {\n        error_setg(errp, \"failed to read option reply\");\n        nbd_send_opt_abort(ioc);\n        return -1;\n    }\n    be64_to_cpus(&reply->magic);\n    be32_to_cpus(&reply->option);\n    be32_to_cpus(&reply->type);\n    be32_to_cpus(&reply->length);\n    TRACE(\"Received option reply %\" PRIx32\", type %\" PRIx32\", len %\" PRIu32,\n          reply->option, reply->type, reply->length);\n    if (reply->magic != NBD_REP_MAGIC) {\n        error_setg(errp, \"Unexpected option reply magic\");\n        nbd_send_opt_abort(ioc);\n        return -1;\n    }\n    if (reply->option != opt) {\n        error_setg(errp, \"Unexpected option type %x expected %x\",\n                   reply->option, opt);\n        nbd_send_opt_abort(ioc);\n        return -1;\n    }\n    return 0;\n}", "target": 0}
{"code": "int ping_init_sock(struct sock *sk)\n{\n\tstruct net *net = sock_net(sk);\n\tkgid_t group = current_egid();\n\tstruct group_info *group_info;\n\tint i, j, count;\n\tkgid_t low, high;\n\tint ret = 0;\n\tinet_get_ping_group_range_net(net, &low, &high);\n\tif (gid_lte(low, group) && gid_lte(group, high))\n\t\treturn 0;\n\tgroup_info = get_current_groups();\n\tcount = group_info->ngroups;\n\tfor (i = 0; i < group_info->nblocks; i++) {\n\t\tint cp_count = min_t(int, NGROUPS_PER_BLOCK, count);\n\t\tfor (j = 0; j < cp_count; j++) {\n\t\t\tkgid_t gid = group_info->blocks[i][j];\n\t\t\tif (gid_lte(low, gid) && gid_lte(gid, high))\n\t\t\t\tgoto out_release_group;\n\t\t}\n\t\tcount -= cp_count;\n\t}\n\tret = -EACCES;\nout_release_group:\n\tput_group_info(group_info);\n\treturn ret;\n}", "target": 0}
{"code": "static void __init config_types(void)\n{\n\tbool has_drive = false;\n\tint drive;\n\tdrive = 0;\n\tif (!UDP->cmos)\n\t\tUDP->cmos = FLOPPY0_TYPE;\n\tdrive = 1;\n\tif (!UDP->cmos)\n\t\tUDP->cmos = FLOPPY1_TYPE;\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tunsigned int type = UDP->cmos;\n\t\tstruct floppy_drive_params *params;\n\t\tconst char *name = NULL;\n\t\tchar temparea[32];\n\t\tif (type < ARRAY_SIZE(default_drive_params)) {\n\t\t\tparams = &default_drive_params[type].params;\n\t\t\tif (type) {\n\t\t\t\tname = default_drive_params[type].name;\n\t\t\t\tallowed_drive_mask |= 1 << drive;\n\t\t\t} else\n\t\t\t\tallowed_drive_mask &= ~(1 << drive);\n\t\t} else {\n\t\t\tparams = &default_drive_params[0].params;\n\t\t\tsnprintf(temparea, sizeof(temparea),\n\t\t\t\t \"unknown type %d (usb?)\", type);\n\t\t\tname = temparea;\n\t\t}\n\t\tif (name) {\n\t\t\tconst char *prepend;\n\t\t\tif (!has_drive) {\n\t\t\t\tprepend = \"\";\n\t\t\t\thas_drive = true;\n\t\t\t\tpr_info(\"Floppy drive(s):\");\n\t\t\t} else {\n\t\t\t\tprepend = \",\";\n\t\t\t}\n\t\t\tpr_cont(\"%s fd%d is %s\", prepend, drive, name);\n\t\t}\n\t\t*UDP = *params;\n\t}\n\tif (has_drive)\n\t\tpr_cont(\"\\n\");\n}", "target": 0}
{"code": "void sock_update_classid(struct sock *sk)\n{\n\tu32 classid;\n\trcu_read_lock();  \n\tclassid = task_cls_classid(current);\n\trcu_read_unlock();\n\tif (classid && classid != sk->sk_classid)\n\t\tsk->sk_classid = classid;\n}", "target": 0}
{"code": "int jpc_tsfb_synthesize(jpc_tsfb_t *tsfb, jas_seq2d_t *a)\n{\n\treturn (tsfb->numlvls > 0) ? jpc_tsfb_synthesize2(tsfb,\n\t  jas_seq2d_getref(a, jas_seq2d_xstart(a), jas_seq2d_ystart(a)),\n\t  jas_seq2d_xstart(a), jas_seq2d_ystart(a), jas_seq2d_width(a),\n\t  jas_seq2d_height(a), jas_seq2d_rowstep(a), tsfb->numlvls - 1) : 0;\n}", "target": 1}
{"code": "void read(Protocol_* iprot, const StructInfo& structInfo, void* object) {\n  DCHECK(object);\n  ProtocolReaderStructReadState<Protocol_> readState;\n  readState.readStructBegin(iprot);\n  if (UNLIKELY(structInfo.unionExt != nullptr)) {\n    readState.fieldId = 0;\n    readState.readFieldBegin(iprot);\n    if (readState.atStop()) {\n      structInfo.unionExt->clear(object);\n      readState.readStructEnd(iprot);\n      return;\n    }\n    const auto* fieldInfo = findFieldInfo(iprot, readState, structInfo);\n    if (fieldInfo) {\n      void* unionVal = getMember(*fieldInfo, object);\n      structInfo.unionExt->initMember[fieldInfo - structInfo.fieldInfos](\n          unionVal);\n      read(iprot, *fieldInfo->typeInfo, readState, unionVal);\n      const_cast<FieldID&>(activeUnionMemberId(\n          object, structInfo.unionExt->unionTypeOffset)) = fieldInfo->id;\n    } else {\n      skip(iprot, readState);\n    }\n    readState.readFieldEnd(iprot);\n    readState.readFieldBegin(iprot);\n    if (UNLIKELY(!readState.atStop())) {\n      TProtocolException::throwUnionMissingStop();\n    }\n    readState.readStructEnd(iprot);\n    return;\n  }\n  FieldID prevFieldId = 0;\n  std::int16_t index = 0;\n  for (;; ++index) {\n    auto* fieldInfo = index < structInfo.numFields\n        ? &structInfo.fieldInfos[index]\n        : &kStopMarker;\n    if (UNLIKELY(!readState.advanceToNextField(\n            iprot, prevFieldId, fieldInfo->id, fieldInfo->typeInfo->type))) {\n      for (;;) {\n        readState.afterAdvanceFailure(iprot);\n        if (readState.atStop()) {\n          readState.readStructEnd(iprot);\n          return;\n        }\n        fieldInfo = findFieldInfo(iprot, readState, structInfo);\n        if (fieldInfo) {\n          index = fieldInfo - structInfo.fieldInfos;\n          break;\n        }\n        skip(iprot, readState);\n      }\n    } else if (UNLIKELY(index >= structInfo.numFields)) {\n      readState.readStructEnd(iprot);\n      return;\n    }\n    prevFieldId = fieldInfo->id;\n    read(iprot, *fieldInfo->typeInfo, readState, getMember(*fieldInfo, object));\n    if (fieldInfo->issetOffset > 0) {\n      const_cast<bool&>(fieldIsSet(object, fieldInfo->issetOffset)) = true;\n    }\n  }\n}", "target": 1}
{"code": "blkxor(void * dest, void * src, size_t len)\n{\n  __m128i * D = (__m128i *) dest;\n  __m128i * S = (__m128i *) src;\n  size_t L = len / 16;\n  size_t i;\n  for (i = 0; i < L; i++)\n    D[i] = _mm_xor_si128(D[i], S[i]);\n}", "target": 1}
{"code": "int nfc_dep_link_up(struct nfc_dev *dev, int target_index, u8 comm_mode)\n{\n\tint rc = 0;\n\tu8 *gb;\n\tsize_t gb_len;\n\tstruct nfc_target *target;\n\tpr_debug(\"dev_name=%s comm %d\\n\", dev_name(&dev->dev), comm_mode);\n\tif (!dev->ops->dep_link_up)\n\t\treturn -EOPNOTSUPP;\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->dep_link_up == true) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\tgb = nfc_llcp_general_bytes(dev, &gb_len);\n\tif (gb_len > NFC_MAX_GT_LEN) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\ttarget = nfc_find_target(dev, target_index);\n\tif (target == NULL) {\n\t\trc = -ENOTCONN;\n\t\tgoto error;\n\t}\n\trc = dev->ops->dep_link_up(dev, target, comm_mode, gb, gb_len);\n\tif (!rc) {\n\t\tdev->active_target = target;\n\t\tdev->rf_mode = NFC_RF_INITIATOR;\n\t}\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "buf_find_string_offset(const buf_t *buf, const char *s, size_t n)\n{\n  buf_pos_t pos;\n  buf_pos_init(buf, &pos);\n  while (buf_find_pos_of_char(*s, &pos) >= 0) {\n    if (buf_matches_at_pos(&pos, s, n)) {\n      tor_assert(pos.chunk_pos + pos.pos < INT_MAX);\n      return (int)(pos.chunk_pos + pos.pos);\n    } else {\n      if (buf_pos_inc(&pos)<0)\n        return -1;\n    }\n  }\n  return -1;\n}", "target": 0}
{"code": "build_ycc_rgb_table(j_decompress_ptr cinfo)\n{\n  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n  int i;\n  JLONG x;\n  SHIFT_TEMPS\n  upsample->Cr_r_tab = (int *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (MAXJSAMPLE + 1) * sizeof(int));\n  upsample->Cb_b_tab = (int *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (MAXJSAMPLE + 1) * sizeof(int));\n  upsample->Cr_g_tab = (JLONG *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (MAXJSAMPLE + 1) * sizeof(JLONG));\n  upsample->Cb_g_tab = (JLONG *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (MAXJSAMPLE + 1) * sizeof(JLONG));\n  for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {\n    upsample->Cr_r_tab[i] = (int)\n                    RIGHT_SHIFT(FIX(1.40200) * x + ONE_HALF, SCALEBITS);\n    upsample->Cb_b_tab[i] = (int)\n                    RIGHT_SHIFT(FIX(1.77200) * x + ONE_HALF, SCALEBITS);\n    upsample->Cr_g_tab[i] = (-FIX(0.71414)) * x;\n    upsample->Cb_g_tab[i] = (-FIX(0.34414)) * x + ONE_HALF;\n  }\n}", "target": 1}
{"code": "mrb_remove_method(mrb_state *mrb, struct RClass *c, mrb_sym mid)\n{\n  mt_tbl *h;\n  MRB_CLASS_ORIGIN(c);\n  h = c->mt;\n  if (h && mt_del(mrb, h, mid)) return;\n  mrb_name_error(mrb, mid, \"method '%n' not defined in %C\", mid, c);\n}", "target": 1}
{"code": "static int zpff_init(struct hid_device *hid)\n{\n\tstruct zpff_device *zpff;\n\tstruct hid_report *report;\n\tstruct hid_input *hidinput = list_entry(hid->inputs.next,\n\t\t\t\t\t\tstruct hid_input, list);\n\tstruct input_dev *dev = hidinput->input;\n\tint i, error;\n\tfor (i = 0; i < 4; i++) {\n\t\treport = hid_validate_values(hid, HID_OUTPUT_REPORT, 0, i, 1);\n\t\tif (!report)\n\t\t\treturn -ENODEV;\n\t}\n\tzpff = kzalloc(sizeof(struct zpff_device), GFP_KERNEL);\n\tif (!zpff)\n\t\treturn -ENOMEM;\n\tset_bit(FF_RUMBLE, dev->ffbit);\n\terror = input_ff_create_memless(dev, zpff, zpff_play);\n\tif (error) {\n\t\tkfree(zpff);\n\t\treturn error;\n\t}\n\tzpff->report = report;\n\tzpff->report->field[0]->value[0] = 0x00;\n\tzpff->report->field[1]->value[0] = 0x02;\n\tzpff->report->field[2]->value[0] = 0x00;\n\tzpff->report->field[3]->value[0] = 0x00;\n\thid_hw_request(hid, zpff->report, HID_REQ_SET_REPORT);\n\thid_info(hid, \"force feedback for Zeroplus based devices by Anssi Hannula <anssi.hannula@gmail.com>\\n\");\n\treturn 0;\n}", "target": 1}
{"code": "void test_checkout_nasty__git_tilde1(void)\n{\n#ifdef GIT_WIN32\n\ttest_checkout_fails(\"refs/heads/git_tilde1\", \".git/foobar\");\n#endif\n}", "target": 1}
{"code": "static u_int mp_dss_len(const  struct mp_dss *m, int csum)\n{\n        u_int len;\n        len = 4;\n        if (m->flags & MP_DSS_A) {\n                len += (m->flags & MP_DSS_a) ? 8 : 4;\n        }\n        if (m->flags & MP_DSS_M) {\n                len += (m->flags & MP_DSS_m) ? 14 : 10;\n                if (csum)\n                        len += 2;\n\t}\n\treturn len;\n}", "target": 1}
{"code": "static inline int dpt_dma64(adpt_hba *pHba)\n{\n\treturn (sizeof(dma_addr_t) > 4 && (pHba)->dma64);\n}", "target": 1}
{"code": "key_ref_t search_process_keyrings(struct key_type *type,\n\t\t\t\t  const void *description,\n\t\t\t\t  key_match_func_t match,\n\t\t\t\t  const struct cred *cred)\n{\n\tstruct request_key_auth *rka;\n\tkey_ref_t key_ref, ret = ERR_PTR(-EACCES), err;\n\tmight_sleep();\n\tkey_ref = search_my_process_keyrings(type, description, match,\n\t\t\t\t\t     false, cred);\n\tif (!IS_ERR(key_ref))\n\t\tgoto found;\n\terr = key_ref;\n\tif (cred->request_key_auth &&\n\t    cred == current_cred() &&\n\t    type != &key_type_request_key_auth\n\t    ) {\n\t\tdown_read(&cred->request_key_auth->sem);\n\t\tif (key_validate(cred->request_key_auth) == 0) {\n\t\t\trka = cred->request_key_auth->payload.data;\n\t\t\tkey_ref = search_process_keyrings(type, description,\n\t\t\t\t\t\t\t  match, rka->cred);\n\t\t\tup_read(&cred->request_key_auth->sem);\n\t\t\tif (!IS_ERR(key_ref))\n\t\t\t\tgoto found;\n\t\t\tret = key_ref;\n\t\t} else {\n\t\t\tup_read(&cred->request_key_auth->sem);\n\t\t}\n\t}\n\tif (err == ERR_PTR(-ENOKEY) || ret == ERR_PTR(-ENOKEY))\n\t\tkey_ref = ERR_PTR(-ENOKEY);\n\telse if (err == ERR_PTR(-EACCES))\n\t\tkey_ref = ret;\n\telse\n\t\tkey_ref = err;\nfound:\n\treturn key_ref;\n}", "target": 0}
{"code": "seamless_line_handler(const char *line, void *data)\n{\n\tif (!seamless_process_line(line, data))\n\t{\n\t\twarning(\"SeamlessRDP: Invalid request:%s\\n\", line);\n\t}\n\treturn True;\n}", "target": 0}
{"code": "hb_set_set (hb_set_t       *set,\n\t    const hb_set_t *other)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n  set->set (*other);\n}", "target": 1}
{"code": "static unsigned char *AcquireCompactPixels(const Image *image,\n  ExceptionInfo *exception)\n{\n  size_t\n    packet_size;\n  unsigned char\n    *compact_pixels;\n  packet_size=image->depth > 8UL ? 2UL : 1UL;\n  compact_pixels=(unsigned char *) AcquireQuantumMemory((9*\n    image->columns)+1,packet_size*sizeof(*compact_pixels));\n  if (compact_pixels == (unsigned char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n        image->filename);\n    }\n  return(compact_pixels);\n}", "target": 1}
{"code": "sort_page_names (gconstpointer a,\n                 gconstpointer b)\n{\n\tconst char *name_1, *name_2;\n\tgchar *key_1, *key_2;\n\tgboolean sort_last_1, sort_last_2;\n\tint compare;\n\tname_1 = * (const char **) a;\n\tname_2 = * (const char **) b;\n\t#define SORT_LAST_CHAR1 '.'\n\t#define SORT_LAST_CHAR2 '#'\n\tsort_last_1 = name_1[0] == SORT_LAST_CHAR1 || name_1[0] == SORT_LAST_CHAR2;\n\tsort_last_2 = name_2[0] == SORT_LAST_CHAR1 || name_2[0] == SORT_LAST_CHAR2;\n\t#undef SORT_LAST_CHAR1\n\t#undef SORT_LAST_CHAR2\n\tif (sort_last_1 && !sort_last_2)\n\t{\n\t\tcompare = +1;\n\t}\n\telse if (!sort_last_1 && sort_last_2)\n\t{\n\t\tcompare = -1;\n\t}\n\telse\n\t{\n\t\tkey_1 = g_utf8_collate_key_for_filename (name_1, -1);\n\t\tkey_2 = g_utf8_collate_key_for_filename (name_2, -1);\n\t\tcompare = strcmp (key_1, key_2);\n\t\tg_free (key_1);\n\t\tg_free (key_2);\n\t}\n\treturn compare;\n}", "target": 1}
{"code": "convert_protocol_address(struct sockaddr* saddr, unsigned int saddrlen)\n{\n    PyObject *res_obj = NULL;\n    switch (saddr->sa_family)\n    {\n    case AF_INET:\n        {\n            struct sockaddr_in* sin = (struct sockaddr_in*)saddr;\n            char *addr_str = (char *)PyMem_Malloc(INET_ADDRSTRLEN);\n            if (addr_str == NULL) {\n                PyErr_SetString(ErrorObject, \"Out of memory\");\n                goto error;\n            }\n            if (inet_ntop(saddr->sa_family, &sin->sin_addr, addr_str, INET_ADDRSTRLEN) == NULL) {\n                PyErr_SetFromErrno(ErrorObject);\n                PyMem_Free(addr_str);\n                goto error;\n            }\n            res_obj = Py_BuildValue(\"(si)\", addr_str, ntohs(sin->sin_port));\n            PyMem_Free(addr_str);\n       }\n        break;\n    case AF_INET6:\n        {\n            struct sockaddr_in6* sin6 = (struct sockaddr_in6*)saddr;\n            char *addr_str = (char *)PyMem_Malloc(INET6_ADDRSTRLEN);\n            if (addr_str == NULL) {\n                PyErr_SetString(ErrorObject, \"Out of memory\");\n                goto error;\n            }\n            if (inet_ntop(saddr->sa_family, &sin6->sin6_addr, addr_str, INET6_ADDRSTRLEN) == NULL) {\n                PyErr_SetFromErrno(ErrorObject);\n                PyMem_Free(addr_str);\n                goto error;\n            }\n            res_obj = Py_BuildValue(\"(si)\", addr_str, ntohs(sin6->sin6_port));\n            PyMem_Free(addr_str);\n        }\n        break;\n    default:\n        PyErr_SetString(ErrorObject, \"Unsupported address family.\");\n    }\nerror:\n    return res_obj;\n}", "target": 0}
{"code": "    DWORD FileIo::Impl::winNumberOfLinks() const\n    {\n        DWORD nlink = 1;\n        HANDLE hFd = (HANDLE)_get_osfhandle(fileno(fp_));\n        if (hFd != INVALID_HANDLE_VALUE) {\n            typedef BOOL (WINAPI * GetFileInformationByHandle_t)(HANDLE, LPBY_HANDLE_FILE_INFORMATION);\n            HMODULE hKernel = ::GetModuleHandleA(\"kernel32.dll\");\n            if (hKernel) {\n                GetFileInformationByHandle_t pfcn_GetFileInformationByHandle = (GetFileInformationByHandle_t)GetProcAddress(hKernel, \"GetFileInformationByHandle\");\n                if (pfcn_GetFileInformationByHandle) {\n                    BY_HANDLE_FILE_INFORMATION fi = {0,0,0,0,0,0,0,0,0,0,0,0,0};\n                    if (pfcn_GetFileInformationByHandle(hFd, &fi)) {\n                        nlink = fi.nNumberOfLinks;\n                    }\n#ifdef DEBUG\n                    else EXV_DEBUG << \"GetFileInformationByHandle failed\\n\";\n#endif\n                }\n#ifdef DEBUG\n                else EXV_DEBUG << \"GetProcAddress(hKernel, \\\"GetFileInformationByHandle\\\") failed\\n\";\n#endif\n            }\n#ifdef DEBUG\n            else EXV_DEBUG << \"GetModuleHandleA(\\\"kernel32.dll\\\") failed\\n\";\n#endif\n        }\n#ifdef DEBUG\n        else EXV_DEBUG << \"_get_osfhandle failed: INVALID_HANDLE_VALUE\\n\";\n#endif\n        return nlink;\n    } ", "target": 0}
{"code": "void RenderSVGImage::paint(PaintInfo& paintInfo, const LayoutPoint&)\n{\n    ANNOTATE_GRAPHICS_CONTEXT(paintInfo, this);\n    if (paintInfo.context->paintingDisabled() || style()->visibility() == HIDDEN || !m_imageResource->hasImage())\n        return;\n    FloatRect boundingBox = repaintRectInLocalCoordinates();\n    if (!SVGRenderSupport::paintInfoIntersectsRepaintRect(boundingBox, m_localTransform, paintInfo))\n        return;\n    PaintInfo childPaintInfo(paintInfo);\n    bool drawsOutline = style()->outlineWidth() && (childPaintInfo.phase == PaintPhaseOutline || childPaintInfo.phase == PaintPhaseSelfOutline);\n    if (drawsOutline || childPaintInfo.phase == PaintPhaseForeground) {\n         GraphicsContextStateSaver stateSaver(*childPaintInfo.context);\n         childPaintInfo.applyTransform(m_localTransform);\n        if (childPaintInfo.phase == PaintPhaseForeground) {\n             SVGRenderingContext renderingContext(this, childPaintInfo);\n             if (renderingContext.isRenderingPrepared()) {\n                if (style()->svgStyle()->bufferedRendering() == BR_STATIC  && renderingContext.bufferForeground(m_bufferedForeground))\n                     return;\n                 paintForeground(childPaintInfo);\n            }\n        }\n        if (drawsOutline)\n            paintOutline(childPaintInfo, IntRect(boundingBox));\n    }\n}", "target": 1}
{"code": "    void publish(Topic *iterator, size_t start, size_t stop, std::string_view topic, std::pair<std::string_view, std::string_view> message) {\n        if (numTriggeredTopics == 64) {\n            drain();\n        }\n        for (; stop != std::string::npos; start = stop + 1) {\n            stop = topic.find('/', start);\n            std::string_view segment = topic.substr(start, stop - start);\n            if (segment.length() == 1) {\n                if (segment[0] == '+' || segment[0] == '#') {\n                    return;\n                }\n            }\n            if (iterator->terminatingWildcardChild) {\n                iterator->terminatingWildcardChild->messages[messageId] = message;\n                if (!iterator->terminatingWildcardChild->triggered) {\n                    triggeredTopics[numTriggeredTopics++] = iterator->terminatingWildcardChild;\n                    iterator->terminatingWildcardChild->triggered = true;\n                }\n            }\n            if (iterator->wildcardChild) {\n                publish(iterator->wildcardChild, stop + 1, stop, topic, message);\n            }\n            std::map<std::string_view, Topic *>::iterator it = iterator->children.find(segment);\n            if (it == iterator->children.end()) {\n                return;\n            }\n            iterator = it->second;\n        }\n        iterator->messages[messageId] = message;\n        if (!iterator->triggered) {\n            triggeredTopics[numTriggeredTopics++] = iterator;\n            iterator->triggered = true;\n        }\n    }", "target": 1}
{"code": "onig_node_str_cat(Node* node, const UChar* s, const UChar* end)\n{\n  ptrdiff_t addlen = end - s;\n  if (addlen > 0) {\n    ptrdiff_t len  = NSTR(node)->end - NSTR(node)->s;\n    if (NSTR(node)->capa > 0 || (len + addlen > NODE_STR_BUF_SIZE - 1)) {\n      UChar* p;\n      ptrdiff_t capa = len + addlen + NODE_STR_MARGIN;\n      if (capa <= NSTR(node)->capa) {\n\tonig_strcpy(NSTR(node)->s + len, s, end);\n      }\n      else {\n\tif (NSTR(node)->s == NSTR(node)->buf)\n\t  p = strcat_capa_from_static(NSTR(node)->s, NSTR(node)->end,\n\t\t\t\t      s, end, capa);\n\telse\n\t  p = strcat_capa(NSTR(node)->s, NSTR(node)->end, s, end, capa);\n\tCHECK_NULL_RETURN_MEMERR(p);\n\tNSTR(node)->s    = p;\n\tNSTR(node)->capa = (int )capa;\n      }\n    }\n    else {\n      onig_strcpy(NSTR(node)->s + len, s, end);\n    }\n    NSTR(node)->end = NSTR(node)->s + len + addlen;\n  }\n  return 0;\n}", "target": 0}
{"code": "txid_snapshot_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tTxidSnapshot *snap;\n\ttxid\t\tlast = 0;\n\tint\t\t\tnxip;\n\tint\t\t\ti;\n\tint\t\t\tavail;\n\tint\t\t\texpect;\n\ttxid\t\txmin,\n\t\t\t\txmax;\n\tnxip = pq_getmsgint(buf, 4);\n\tavail = buf->len - buf->cursor;\n\texpect = 8 + 8 + nxip * 8;\n\tif (nxip < 0 || nxip > avail || expect > avail)\n\t\tgoto bad_format;\n\txmin = pq_getmsgint64(buf);\n\txmax = pq_getmsgint64(buf);\n\tif (xmin == 0 || xmax == 0 || xmin > xmax || xmax > MAX_TXID)\n\t\tgoto bad_format;\n\tsnap = palloc(TXID_SNAPSHOT_SIZE(nxip));\n\tsnap->xmin = xmin;\n\tsnap->xmax = xmax;\n\tsnap->nxip = nxip;\n\tSET_VARSIZE(snap, TXID_SNAPSHOT_SIZE(nxip));\n\tfor (i = 0; i < nxip; i++)\n\t{\n\t\ttxid\t\tcur = pq_getmsgint64(buf);\n\t\tif (cur <= last || cur < xmin || cur >= xmax)\n\t\t\tgoto bad_format;\n\t\tsnap->xip[i] = cur;\n\t\tlast = cur;\n\t}\n\tPG_RETURN_POINTER(snap);\nbad_format:\n\telog(ERROR, \"invalid snapshot data\");\n\treturn (Datum) NULL;\n}", "target": 1}
{"code": "static struct btrfs_dir_item *btrfs_match_dir_item_name(struct btrfs_root *root,\n\t\t\t      struct btrfs_path *path,\n\t\t\t      const char *name, int name_len)\n{\n\tstruct btrfs_dir_item *dir_item;\n\tunsigned long name_ptr;\n\tu32 total_len;\n\tu32 cur = 0;\n\tu32 this_len;\n\tstruct extent_buffer *leaf;\n\tleaf = path->nodes[0];\n\tdir_item = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_dir_item);\n\tif (verify_dir_item(root, leaf, dir_item))\n\t\treturn NULL;\n\ttotal_len = btrfs_item_size_nr(leaf, path->slots[0]);\n\twhile (cur < total_len) {\n\t\tthis_len = sizeof(*dir_item) +\n\t\t\tbtrfs_dir_name_len(leaf, dir_item) +\n\t\t\tbtrfs_dir_data_len(leaf, dir_item);\n\t\tname_ptr = (unsigned long)(dir_item + 1);\n\t\tif (btrfs_dir_name_len(leaf, dir_item) == name_len &&\n\t\t    memcmp_extent_buffer(leaf, name, name_ptr, name_len) == 0)\n\t\t\treturn dir_item;\n\t\tcur += this_len;\n\t\tdir_item = (struct btrfs_dir_item *)((char *)dir_item +\n\t\t\t\t\t\t     this_len);\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "void PDPServer::perform_builtin_endpoints_matching(\n        const ParticipantProxyData& pdata)\n{\n    if (mp_EDP != nullptr)\n    {\n        mp_EDP->assignRemoteEndpoints(pdata);\n    }\n    if (mp_builtin->mp_WLP != nullptr)\n    {\n        mp_builtin->mp_WLP->assignRemoteEndpoints(pdata);\n    }\n}", "target": 1}
{"code": "static int ssl_verify_server_cert(Vio *vio, const char* server_hostname, const char **errptr)\n{\n  SSL *ssl;\n  X509 *server_cert;\n  char *cp1, *cp2;\n  char *buf;\n  DBUG_ENTER(\"ssl_verify_server_cert\");\n  DBUG_PRINT(\"enter\", (\"server_hostname: %s\", server_hostname));\n  if (!(ssl= (SSL*)vio->ssl_arg))\n  {\n    *errptr= \"No SSL pointer found\";\n    DBUG_RETURN(1);\n  }\n  if (!server_hostname)\n  {\n    *errptr= \"No server hostname supplied\";\n    DBUG_RETURN(1);\n  }\n  if (!(server_cert= SSL_get_peer_certificate(ssl)))\n  {\n    *errptr= \"Could not get server certificate\";\n    DBUG_RETURN(1);\n  }\n  if (X509_V_OK != SSL_get_verify_result(ssl))\n  {\n    *errptr= \"Failed to verify the server certificate\";\n    X509_free(server_cert);\n    DBUG_RETURN(1);\n  }\n  buf= X509_NAME_oneline(X509_get_subject_name(server_cert), 0, 0);\n  X509_free (server_cert);\n  if (!buf)\n  {\n    *errptr= \"Out of memory\";\n    DBUG_RETURN(1);\n  }\n  DBUG_PRINT(\"info\", (\"hostname in cert: %s\", buf));\n  cp1= strstr(buf, \"/CN=\");\n  if (cp1)\n  {\n    cp1+= 4; \n    cp2= strchr(cp1, '/');\n    if (cp2)\n      *cp2= '\\0';\n    DBUG_PRINT(\"info\", (\"Server hostname in cert: %s\", cp1));\n    if (!strcmp(cp1, server_hostname))\n    {\n      free(buf);\n      DBUG_RETURN(0);\n    }\n  }\n  *errptr= \"SSL certificate validation failure\";\n  free(buf);\n  DBUG_RETURN(1);\n}", "target": 1}
{"code": "AWSEngine::authenticate(const req_state* const s) const\n{\n  const auto auth_data = ver_abstractor.get_auth_data(s);\n  if (auth_data.access_key_id.empty() || auth_data.client_signature.empty()) {\n    return result_t::deny(-EINVAL);\n  } else {\n    return authenticate(auth_data.access_key_id,\n\t\t        auth_data.client_signature,\n\t\t\tauth_data.string_to_sign,\n                        auth_data.signature_factory,\n\t\t\tauth_data.completer_factory,\n\t\t\ts);\n  }\n}", "target": 0}
{"code": "void add_interrupt_randomness(int irq, int irq_flags)\n{\n\tstruct entropy_store\t*r;\n\tstruct fast_pool\t*fast_pool = this_cpu_ptr(&irq_randomness);\n\tstruct pt_regs\t\t*regs = get_irq_regs();\n\tunsigned long\t\tnow = jiffies;\n\tcycles_t\t\tcycles = random_get_entropy();\n\t__u32\t\t\tc_high, j_high;\n\t__u64\t\t\tip;\n\tunsigned long\t\tseed;\n\tint\t\t\tcredit = 0;\n\tif (cycles == 0)\n\t\tcycles = get_reg(fast_pool, regs);\n\tc_high = (sizeof(cycles) > 4) ? cycles >> 32 : 0;\n\tj_high = (sizeof(now) > 4) ? now >> 32 : 0;\n\tfast_pool->pool[0] ^= cycles ^ j_high ^ irq;\n\tfast_pool->pool[1] ^= now ^ c_high;\n\tip = regs ? instruction_pointer(regs) : _RET_IP_;\n\tfast_pool->pool[2] ^= ip;\n\tfast_pool->pool[3] ^= (sizeof(ip) > 4) ? ip >> 32 :\n\t\tget_reg(fast_pool, regs);\n\tfast_mix(fast_pool);\n\tadd_interrupt_bench(cycles);\n\tif (unlikely(crng_init == 0)) {\n\t\tif ((fast_pool->count >= 64) &&\n\t\t    crng_fast_load((char *) fast_pool->pool,\n\t\t\t\t   sizeof(fast_pool->pool))) {\n\t\t\tfast_pool->count = 0;\n\t\t\tfast_pool->last = now;\n\t\t}\n\t\treturn;\n\t}\n\tif ((fast_pool->count < 64) &&\n\t    !time_after(now, fast_pool->last + HZ))\n\t\treturn;\n\tr = &input_pool;\n\tif (!spin_trylock(&r->lock))\n\t\treturn;\n\tfast_pool->last = now;\n\t__mix_pool_bytes(r, &fast_pool->pool, sizeof(fast_pool->pool));\n\tif (arch_get_random_seed_long(&seed)) {\n\t\t__mix_pool_bytes(r, &seed, sizeof(seed));\n\t\tcredit = 1;\n\t}\n\tspin_unlock(&r->lock);\n\tfast_pool->count = 0;\n\tcredit_entropy_bits(r, credit + 1);\n}", "target": 1}
{"code": "normalizeLines(XML_Char *s)\n{\n  XML_Char *p;\n  for (;; s++) {\n    if (*s == XML_T('\\0'))\n      return;\n    if (*s == 0xD)\n      break;\n  }\n  p = s;\n  do {\n    if (*s == 0xD) {\n      *p++ = 0xA;\n      if (*++s == 0xA)\n        s++;\n    }\n    else\n      *p++ = *s++;\n  } while (*s);\n  *p = XML_T('\\0');\n}", "target": 0}
{"code": "  String_Obj Parser::parse_ie_property()\n  {\n    lex< ie_property >();\n    Token str(lexed);\n    const char* i = str.begin;\n    const char* p = find_first_in_interval< exactly<hash_lbrace>, block_comment >(str.begin, str.end);\n    if (!p) {\n      return SASS_MEMORY_NEW(String_Quoted, pstate, std::string(str.begin, str.end));\n    }\n    String_Schema* schema = SASS_MEMORY_NEW(String_Schema, pstate);\n    while (i < str.end) {\n      p = find_first_in_interval< exactly<hash_lbrace>, block_comment >(i, str.end);\n      if (p) {\n        if (i < p) {\n          schema->append(SASS_MEMORY_NEW(String_Constant, pstate, std::string(i, p))); \n        }\n        if (peek < sequence < optional_spaces, exactly<rbrace> > >(p+2)) { position = p+2;\n          css_error(\"Invalid CSS\", \" after \", \": expected expression (e.g. 1px, bold), was \");\n        }\n        const char* j = skip_over_scopes< exactly<hash_lbrace>, exactly<rbrace> >(p+2, str.end); \n        if (j) {\n          Expression_Obj interp_node = Parser::from_token(Token(p+2, j), ctx, traces, pstate, source).parse_list();\n          interp_node->is_interpolant(true);\n          schema->append(interp_node);\n          i = j;\n        }\n        else {\n          error(\"unterminated interpolant inside IE function \" + str.to_string());\n        }\n      }\n      else { \n        if (i < str.end) {\n          schema->append(SASS_MEMORY_NEW(String_Constant, pstate, std::string(i, str.end)));\n        }\n        break;\n      }\n    }\n    return schema;\n  }", "target": 0}
{"code": "void __netdev_watchdog_up(struct net_device *dev)\n{\n\tif (dev->tx_timeout) {\n\t\tif (dev->watchdog_timeo <= 0)\n\t\t\tdev->watchdog_timeo = 5*HZ;\n\t\tif (!mod_timer(&dev->watchdog_timer,\n\t\t\t       round_jiffies(jiffies + dev->watchdog_timeo)))\n\t\t\tdev_hold(dev);\n\t}\n}", "target": 0}
{"code": "static uint64_t HTPStateGetTxCnt(void *alstate)\n{\n    HtpState *http_state = (HtpState *)alstate;\n    if (http_state != NULL && http_state->conn != NULL) {\n        const int64_t size = (int64_t)htp_list_size(http_state->conn->transactions);\n        if (size < 0)\n            return 0ULL;\n        SCLogDebug(\"size %\"PRIu64, size);\n        return (uint64_t)size;\n    } else {\n        return 0ULL;\n    }\n}", "target": 1}
{"code": "decode_sequence_of(const uint8_t *asn1, size_t len,\n                   const struct atype_info *elemtype, void **seq_out,\n                   size_t *count_out)\n{\n    krb5_error_code ret;\n    void *seq = NULL, *elem, *newseq;\n    const uint8_t *contents;\n    size_t clen, count = 0;\n    taginfo t;\n    *seq_out = NULL;\n    *count_out = 0;\n    while (len > 0) {\n        ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len);\n        if (ret)\n            goto error;\n        if (!check_atype_tag(elemtype, &t)) {\n            ret = ASN1_BAD_ID;\n            goto error;\n        }\n        newseq = realloc(seq, (count + 1) * elemtype->size);\n        if (newseq == NULL) {\n            ret = ENOMEM;\n            goto error;\n        }\n        seq = newseq;\n        elem = (char *)seq + count * elemtype->size;\n        memset(elem, 0, elemtype->size);\n        ret = decode_atype(&t, contents, clen, elemtype, elem);\n        if (ret)\n            goto error;\n        count++;\n    }\n    *seq_out = seq;\n    *count_out = count;\n    return 0;\nerror:\n    free_sequence_of(elemtype, seq, count);\n    free(seq);\n    return ret;\n}", "target": 1}
{"code": "int wvlan_set_station_nickname(struct net_device *dev,\n\t\t      struct iw_request_info *info,\n\t\t      union iwreq_data *wrqu,\n\t\t      char *extra)\n{\n\tstruct wl_private *lp = wl_priv(dev);\n\tunsigned long flags;\n\tint         ret = 0;\n\tDBG_FUNC(\"wvlan_set_station_nickname\");\n\tDBG_ENTER(DbgInfo);\n\twl_lock(lp, &flags);\n\tmemset(lp->StationName, 0, sizeof(lp->StationName));\n\tmemcpy(lp->StationName, extra, wrqu->data.length);\n\twl_apply(lp);\n\twl_unlock(lp, &flags);\n\tDBG_LEAVE(DbgInfo);\n\treturn ret;\n} ", "target": 1}
{"code": "static size_t send_control_msg(VirtIOSerial *vser, void *buf, size_t len)\n{\n    VirtQueueElement elem;\n    VirtQueue *vq;\n    vq = vser->c_ivq;\n    if (!virtio_queue_ready(vq)) {\n        return 0;\n    }\n    if (!virtqueue_pop(vq, &elem)) {\n        return 0;\n    }\n    memcpy(elem.in_sg[0].iov_base, buf, len);\n    virtqueue_push(vq, &elem, len);\n    virtio_notify(VIRTIO_DEVICE(vser), vq);\n    return len;\n}", "target": 1}
{"code": "static struct ip_options *tcp_v4_save_options(struct sock *sk,\n\t\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct ip_options *opt = &(IPCB(skb)->opt);\n\tstruct ip_options *dopt = NULL;\n\tif (opt && opt->optlen) {\n\t\tint opt_size = optlength(opt);\n\t\tdopt = kmalloc(opt_size, GFP_ATOMIC);\n\t\tif (dopt) {\n\t\t\tif (ip_options_echo(dopt, skb)) {\n\t\t\t\tkfree(dopt);\n\t\t\t\tdopt = NULL;\n\t\t\t}\n\t\t}\n\t}\n\treturn dopt;\n}", "target": 1}
{"code": "comics_generate_command_lines (ComicsDocument *comics_document, \n\t\t\t       GError         **error)\n{\n\tgchar *quoted_file, *quoted_file_aux;\n\tgchar *quoted_command;\n\tComicBookDecompressType type;\n\ttype = comics_document->command_usage;\n\tcomics_document->regex_arg = command_usage_def[type].regex_arg;\n\tquoted_command = g_shell_quote (comics_document->selected_command);\n\tif (comics_document->regex_arg) {\n\t\tquoted_file = comics_regex_quote (comics_document->archive);\n\t\tquoted_file_aux = g_shell_quote (comics_document->archive);\n\t\tcomics_document->list_command =\n\t\t\t   g_strdup_printf (command_usage_def[type].list,\n\t\t\t                    comics_document->alternative_command,\n\t\t\t                    quoted_file_aux);\n\t\tg_free (quoted_file_aux);\n\t} else {\n\t\tquoted_file = g_shell_quote (comics_document->archive);\n\t\tcomics_document->list_command =\n\t\t\t\tg_strdup_printf (command_usage_def[type].list,\n\t\t\t\t                 quoted_command, quoted_file);\n\t}\n\tcomics_document->extract_command =\n\t\t\t    g_strdup_printf (command_usage_def[type].extract,\n\t\t\t\t             quoted_command);\n\tcomics_document->offset = command_usage_def[type].offset;\n\tif (command_usage_def[type].decompress_tmp) {\n\t\tcomics_document->dir = ev_mkdtemp (\"atril-comics-XXXXXX\", error);\n                if (comics_document->dir == NULL)\n                        return FALSE;\n\t\tcomics_document->decompress_tmp =\n\t\t\tg_strdup_printf (command_usage_def[type].decompress_tmp, \n\t\t\t\t\t quoted_command, quoted_file,\n\t\t\t\t\t comics_document->dir);\n\t\tg_free (quoted_file);\n\t\tg_free (quoted_command);\n\t\tif (!comics_decompress_temp_dir (comics_document->decompress_tmp,\n\t\t    comics_document->selected_command, error))\n\t\t\treturn FALSE;\n\t\telse\n\t\t\treturn TRUE;\n\t} else {\n\t\tg_free (quoted_file);\n\t\tg_free (quoted_command);\n\t\treturn TRUE;\n\t}\n}", "target": 0}
{"code": "static OPJ_BOOL opj_j2k_write_sot(opj_j2k_t *p_j2k,\n                                  OPJ_BYTE * p_data,\n                                  OPJ_UINT32 p_total_data_size,\n                                  OPJ_UINT32 * p_data_written,\n                                  const opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager\n                                 )\n{\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n    OPJ_UNUSED(p_stream);\n    OPJ_UNUSED(p_manager);\n    if (p_total_data_size < 12) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Not enough bytes in output buffer to write SOT marker\\n\");\n        return OPJ_FALSE;\n    }\n    opj_write_bytes(p_data, J2K_MS_SOT,\n                    2);                                 \n    p_data += 2;\n    opj_write_bytes(p_data, 10,\n                    2);                                                   \n    p_data += 2;\n    opj_write_bytes(p_data, p_j2k->m_current_tile_number,\n                    2);                        \n    p_data += 2;\n    p_data += 4;\n    opj_write_bytes(p_data,\n                    p_j2k->m_specific_param.m_encoder.m_current_tile_part_number,\n                    1);                        \n    ++p_data;\n    opj_write_bytes(p_data,\n                    p_j2k->m_cp.tcps[p_j2k->m_current_tile_number].m_nb_tile_parts,\n                    1);                      \n    ++p_data;\n#ifdef USE_JPWL\n    assert(0 && \"TODO\");\n#endif \n    * p_data_written = 12;\n    return OPJ_TRUE;\n}", "target": 0}
{"code": "void SetClipboardText(const char *text)\n{\n#if defined(PLATFORM_DESKTOP)\n    glfwSetClipboardString(CORE.Window.handle, text);\n#endif\n#if defined(PLATFORM_WEB)\n    emscripten_run_script(TextFormat(\"navigator.clipboard.writeText('%s')\", text));\n#endif\n}", "target": 1}
{"code": "append_command(char_u *cmd)\n{\n    char_u *s = cmd;\n    char_u *d;\n    STRCAT(IObuff, \": \");\n    d = IObuff + STRLEN(IObuff);\n    while (*s != NUL && d - IObuff + 5 < IOSIZE)\n    {\n\tif (enc_utf8 ? (s[0] == 0xc2 && s[1] == 0xa0) : *s == 0xa0)\n\t{\n\t    s += enc_utf8 ? 2 : 1;\n\t    STRCPY(d, \"<a0>\");\n\t    d += 4;\n\t}\n\telse if (d - IObuff + (*mb_ptr2len)(s) + 1 >= IOSIZE)\n\t    break;\n\telse\n\t    MB_COPY_CHAR(s, d);\n    }\n    *d = NUL;\n}", "target": 1}
{"code": "void LIRGenerator::do_ArrayCopy(Intrinsic* x) {\n  assert(x->number_of_arguments() == 5, \"wrong type\");\n  CodeEmitInfo* info = state_for(x, x->state());\n  LIRItem src(x->argument_at(0), this);\n  LIRItem src_pos(x->argument_at(1), this);\n  LIRItem dst(x->argument_at(2), this);\n  LIRItem dst_pos(x->argument_at(3), this);\n  LIRItem length(x->argument_at(4), this);\n#ifndef _LP64\n  src.load_item_force     (FrameMap::rcx_oop_opr);\n  src_pos.load_item_force (FrameMap::rdx_opr);\n  dst.load_item_force     (FrameMap::rax_oop_opr);\n  dst_pos.load_item_force (FrameMap::rbx_opr);\n  length.load_item_force  (FrameMap::rdi_opr);\n  LIR_Opr tmp =           (FrameMap::rsi_opr);\n#else\n  src.load_item_force     (FrameMap::as_oop_opr(j_rarg0));\n  src_pos.load_item_force (FrameMap::as_opr(j_rarg1));\n  dst.load_item_force     (FrameMap::as_oop_opr(j_rarg2));\n  dst_pos.load_item_force (FrameMap::as_opr(j_rarg3));\n  length.load_item_force  (FrameMap::as_opr(j_rarg4));\n  LIR_Opr tmp =           FrameMap::as_opr(j_rarg5);\n#endif \n  set_no_result(x);\n  int flags;\n  ciArrayKlass* expected_type;\n  arraycopy_helper(x, &flags, &expected_type);\n  __ arraycopy(src.result(), src_pos.result(), dst.result(), dst_pos.result(), length.result(), tmp, expected_type, flags, info); \n}", "target": 0}
{"code": "int xt_compat_check_entry_offsets(const void *base,\n\t\t\t\t  unsigned int target_offset,\n\t\t\t\t  unsigned int next_offset)\n{\n\tconst struct compat_xt_entry_target *t;\n\tconst char *e = base;\n\tif (target_offset + sizeof(*t) > next_offset)\n\t\treturn -EINVAL;\n\tt = (void *)(e + target_offset);\n\tif (t->u.target_size < sizeof(*t))\n\t\treturn -EINVAL;\n\tif (target_offset + t->u.target_size > next_offset)\n\t\treturn -EINVAL;\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) == 0 &&\n\t    target_offset + sizeof(struct compat_xt_standard_target) != next_offset)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 1}
{"code": "static int __init parse_acpi(char *arg)\n{\n\tif (!arg)\n\t\treturn -EINVAL;\n\tif (strcmp(arg, \"off\") == 0) {\n\t\tdisable_acpi();\n\t}\n\telse if (strcmp(arg, \"force\") == 0) {\n\t\tacpi_force = 1;\n\t\tacpi_ht = 1;\n\t\tacpi_disabled = 0;\n\t}\n\telse if (strcmp(arg, \"strict\") == 0) {\n\t\tacpi_strict = 1;\n\t}\n\telse if (strcmp(arg, \"ht\") == 0) {\n\t\tif (!acpi_force)\n\t\t\tdisable_acpi();\n\t\tacpi_ht = 1;\n\t}\n\telse if (strcmp(arg, \"noirq\") == 0) {\n\t\tacpi_noirq_set();\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int econet_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t  int *uaddr_len, int peer)\n{\n\tstruct sock *sk;\n\tstruct econet_sock *eo;\n\tstruct sockaddr_ec *sec = (struct sockaddr_ec *)uaddr;\n\tif (peer)\n\t\treturn -EOPNOTSUPP;\n\tmutex_lock(&econet_mutex);\n\tsk = sock->sk;\n\teo = ec_sk(sk);\n\tsec->sec_family\t  = AF_ECONET;\n\tsec->port\t  = eo->port;\n\tsec->addr.station = eo->station;\n\tsec->addr.net\t  = eo->net;\n\tmutex_unlock(&econet_mutex);\n\t*uaddr_len = sizeof(*sec);\n\treturn 0;\n}", "target": 1}
{"code": "static int ntlm_decode_field(struct wire_field_hdr *hdr,\n                             struct ntlm_buffer *buffer,\n                             size_t payload_offs,\n                             struct ntlm_buffer *field)\n{\n    struct ntlm_buffer b = { NULL, 0 };\n    uint32_t offs;\n    uint16_t len;\n    len = le16toh(hdr->len);\n    if (len == 0) goto done;\n    offs = le32toh(hdr->offset);\n    if ((offs < payload_offs) ||\n        (offs > buffer->length) ||\n        (UINT32_MAX - offs < len) ||\n        (offs + len > buffer->length)) {\n        return ERR_DECODE;\n    }\n    b.data = malloc(len);\n    if (!b.data) return ENOMEM;\n    b.length = len;\n    memcpy(b.data, &buffer->data[offs], b.length);\ndone:\n    *field = b;\n    return 0;\n}", "target": 0}
{"code": "static void tipc_node_link_failover(struct tipc_node *n, struct tipc_link *l,\n\t\t\t\t    struct tipc_link *tnl,\n\t\t\t\t    struct sk_buff_head *xmitq)\n{\n\tif (!tipc_link_is_up(tnl))\n\t\treturn;\n\tif (l && !tipc_link_is_reset(l))\n\t\treturn;\n\ttipc_link_fsm_evt(tnl, LINK_SYNCH_END_EVT);\n\ttipc_node_fsm_evt(n, NODE_SYNCH_END_EVT);\n\tn->sync_point = tipc_link_rcv_nxt(tnl) + (U16_MAX / 2 - 1);\n\ttipc_link_failover_prepare(l, tnl, xmitq);\n\tif (l)\n\t\ttipc_link_fsm_evt(l, LINK_FAILOVER_BEGIN_EVT);\n\ttipc_node_fsm_evt(n, NODE_FAILOVER_BEGIN_EVT);\n}", "target": 0}
{"code": "bool unit_suffix_is_valid(const char *s) {\n        if (isempty(s))\n                return false;\n        if (s[0] != '.')\n                return false;\n        if (unit_type_from_string(s + 1) < 0)\n                return false;\n        return true;\n}", "target": 0}
{"code": "    uint32_t PsdImage::writeExifData(const ExifData& exifData, BasicIo& out)\n    {\n        uint32_t resLength = 0;\n        byte buf[8];\n        if (exifData.count() > 0) {\n            Blob blob;\n            ByteOrder bo = byteOrder();\n            if (bo == invalidByteOrder) {\n                bo = littleEndian;\n                setByteOrder(bo);\n            }\n            ExifParser::encode(blob, bo, exifData);\n            if (blob.size() > 0) {\n#ifdef DEBUG\n                std::cerr << std::hex << \"write: resourceId: \" << kPhotoshopResourceID_ExifInfo << \"\\n\";\n                std::cerr << std::dec << \"Writing ExifInfo: size: \" << blob.size() << \"\\n\";\n#endif\n                if (out.write(reinterpret_cast<const byte*>(Photoshop::irbId_[0]), 4) != 4) throw Error(kerImageWriteFailed);\n                us2Data(buf, kPhotoshopResourceID_ExifInfo, bigEndian);\n                if (out.write(buf, 2) != 2) throw Error(kerImageWriteFailed);\n                us2Data(buf, 0, bigEndian);                      \n                if (out.write(buf, 2) != 2) throw Error(kerImageWriteFailed);\n                ul2Data(buf, static_cast<uint32_t>(blob.size()), bigEndian);\n                if (out.write(buf, 4) != 4) throw Error(kerImageWriteFailed);\n                if (out.write(&blob[0], static_cast<long>(blob.size())) != static_cast<long>(blob.size())) throw Error(kerImageWriteFailed);\n                resLength += static_cast<long>(blob.size()) + 12;\n                if (blob.size() & 1)    \n                {\n                    buf[0] = 0;\n                    if (out.write(buf, 1) != 1) throw Error(kerImageWriteFailed);\n                    resLength++;\n                }\n            }\n        }\n        return resLength;\n    } ", "target": 0}
{"code": "write_to_temp(struct archive_write *a, const void *buff, size_t s)\n{\n\tstruct iso9660 *iso9660 = a->format_data;\n\tssize_t written;\n\tconst unsigned char *b;\n\tb = (const unsigned char *)buff;\n\twhile (s) {\n\t\twritten = write(iso9660->temp_fd, b, s);\n\t\tif (written < 0) {\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t    \"Can't write to temporary file\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\ts -= written;\n\t\tb += written;\n\t}\n\treturn (ARCHIVE_OK);\n}", "target": 0}
{"code": "unquoted_glob_pattern_p (string)\n     register char *string;\n{\n  register int c;\n  char *send;\n  int open, bsquote;\n  DECLARE_MBSTATE;\n  open = bsquote = 0;\n  send = string + strlen (string);\n  while (c = *string++)\n    {\n      switch (c)\n\t{\n\tcase '?':\n\tcase '*':\n\t  return (1);\n\tcase '[':\n\t  open++;\n\t  continue;\n\tcase ']':\n\t  if (open)\n\t    return (1);\n\t  continue;\n\tcase '+':\n\tcase '@':\n\tcase '!':\n\t  if (*string == '(')\t\n\t    return (1);\n\t  continue;\n\tcase '\\\\':\n\t  if (*string != '\\0' && *string != '/')\n\t    {\n\t      bsquote = 1;\n\t      string++;\n\t      continue;\n\t    }\n\t  else if (*string == 0)\n\t    return (0);\n\tcase CTLESC:\n\t  if (*string++ == '\\0')\n\t    return (0);\n\t}\n#ifdef HANDLE_MULTIBYTE\n      string--;\n      ADVANCE_CHAR_P (string, send - string);\n      string++;\n#else\n      ADVANCE_CHAR_P (string, send - string);\n#endif\n    }\n  return ((bsquote && posix_glob_backslash) ? 2 : 0);\n}", "target": 1}
{"code": "static int clear_refs_pte_range(pmd_t *pmd, unsigned long addr,\n\t\t\t\tunsigned long end, struct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->private;\n\tpte_t *pte, ptent;\n\tspinlock_t *ptl;\n\tstruct page *page;\n\tsplit_huge_page_pmd(walk->mm, pmd);\n\tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n\tfor (; addr != end; pte++, addr += PAGE_SIZE) {\n\t\tptent = *pte;\n\t\tif (!pte_present(ptent))\n\t\t\tcontinue;\n\t\tpage = vm_normal_page(vma, addr, ptent);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tptep_test_and_clear_young(vma, addr, pte);\n\t\tClearPageReferenced(page);\n\t}\n\tpte_unmap_unlock(pte - 1, ptl);\n\tcond_resched();\n\treturn 0;\n}", "target": 0}
{"code": "GIT_INLINE(bool) only_spaces_and_dots(const char *path)\n{\n\tconst char *c = path;\n\tfor (;; c++) {\n\t\tif (*c == '\\0')\n\t\t\treturn true;\n\t\tif (*c != ' ' && *c != '.')\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "static int mwifiex_pcie_init_evt_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct mwifiex_evt_buf_desc *desc;\n\tstruct sk_buff *skb;\n\tdma_addr_t buf_pa;\n\tint i;\n\tfor (i = 0; i < MWIFIEX_MAX_EVT_BD; i++) {\n\t\tskb = dev_alloc_skb(MAX_EVENT_SIZE);\n\t\tif (!skb) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Unable to allocate skb for EVENT buf.\\n\");\n\t\t\tkfree(card->evtbd_ring_vbase);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tskb_put(skb, MAX_EVENT_SIZE);\n\t\tif (mwifiex_map_pci_memory(adapter, skb, MAX_EVENT_SIZE,\n\t\t\t\t\t   PCI_DMA_FROMDEVICE))\n\t\t\treturn -1;\n\t\tbuf_pa = MWIFIEX_SKB_DMA_ADDR(skb);\n\t\tmwifiex_dbg(adapter, EVENT,\n\t\t\t    \"info: EVT ring: skb=%p len=%d data=%p buf_pa=%#x:%x\\n\",\n\t\t\t    skb, skb->len, skb->data, (u32)buf_pa,\n\t\t\t    (u32)((u64)buf_pa >> 32));\n\t\tcard->evt_buf_list[i] = skb;\n\t\tcard->evtbd_ring[i] = (void *)(card->evtbd_ring_vbase +\n\t\t\t\t      (sizeof(*desc) * i));\n\t\tdesc = card->evtbd_ring[i];\n\t\tdesc->paddr = buf_pa;\n\t\tdesc->len = (u16)skb->len;\n\t\tdesc->flags = 0;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "MagickExport MagickBooleanType IsOptionMember(const char *option,\n  const char *options)\n{\n  char\n    **option_list,\n    *string;\n  int\n    number_options;\n  MagickBooleanType\n    member;\n  register ssize_t\n    i;\n  if (options == (const char *) NULL)\n    return(MagickFalse);\n  string=ConstantString(options);\n  (void) SubstituteString(&string,\",\",\" \");\n  option_list=StringToArgv(string,&number_options);\n  string=DestroyString(string);\n  if (option_list == (char **) NULL)\n    return(MagickFalse);\n  member=MagickFalse;\n  for (i=1; i < (ssize_t) number_options; i++)\n  {\n    if ((*option_list[i] == '!') &&\n        (LocaleCompare(option,option_list[i]+1) == 0))\n      break;\n    if (GlobExpression(option,option_list[i],MagickTrue) != MagickFalse)\n      {\n        member=MagickTrue;\n        break;\n      }\n    option_list[i]=DestroyString(option_list[i]);\n  }\n  for ( ; i < (ssize_t) number_options; i++)\n    option_list[i]=DestroyString(option_list[i]);\n  option_list=(char **) RelinquishMagickMemory(option_list);\n  return(member);\n}", "target": 1}
{"code": "NOEXPORT int init_section(int eof, SERVICE_OPTIONS **section_ptr) {\n    char *errstr;\n#ifndef USE_WIN32\n    (*section_ptr)->option.log_stderr=new_global_options.option.log_stderr;\n#endif \n    if(*section_ptr==&new_service_options) {\n        errstr=parse_global_option(CMD_INITIALIZE, NULL, NULL);\n        if(errstr) {\n            s_log(LOG_ERR, \"Global options: %s\", errstr);\n            return 1;\n        }\n    }\n    if(*section_ptr!=&new_service_options || eof) {\n        if(*section_ptr==&new_service_options)\n            s_log(LOG_INFO, \"Initializing inetd mode configuration\");\n        else\n            s_log(LOG_INFO, \"Initializing service [%s]\",\n                (*section_ptr)->servname);\n        errstr=parse_service_option(CMD_INITIALIZE, section_ptr, NULL, NULL);\n        if(errstr) {\n            if(*section_ptr==&new_service_options)\n                s_log(LOG_ERR, \"Inetd mode: %s\", errstr);\n            else\n                s_log(LOG_ERR, \"Service [%s]: %s\",\n                    (*section_ptr)->servname, errstr);\n            return 1;\n        }\n    }\n    return 0;\n}", "target": 1}
{"code": "int cfg80211_mgd_wext_giwessid(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       struct iw_point *data, char *ssid)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tif (WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION))\n\t\treturn -EINVAL;\n\tdata->flags = 0;\n\twdev_lock(wdev);\n\tif (wdev->current_bss) {\n\t\tconst u8 *ie;\n\t\trcu_read_lock();\n\t\tie = ieee80211_bss_get_ie(&wdev->current_bss->pub,\n\t\t\t\t\t  WLAN_EID_SSID);\n\t\tif (ie) {\n\t\t\tdata->flags = 1;\n\t\t\tdata->length = ie[1];\n\t\t\tmemcpy(ssid, ie + 2, data->length);\n\t\t}\n\t\trcu_read_unlock();\n\t} else if (wdev->wext.connect.ssid && wdev->wext.connect.ssid_len) {\n\t\tdata->flags = 1;\n\t\tdata->length = wdev->wext.connect.ssid_len;\n\t\tmemcpy(ssid, wdev->wext.connect.ssid, data->length);\n\t}\n\twdev_unlock(wdev);\n\treturn 0;\n}", "target": 1}
{"code": "static MagickBooleanType SkipRGBMipmaps(Image *image,DDSInfo *dds_info,\n  int pixel_size,ExceptionInfo *exception)\n{\n  MagickOffsetType\n    offset;\n  register ssize_t\n    i;\n  size_t\n    h,\n    w;\n  if (EOFBlob(image) != MagickFalse)\n    {\n      ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n        image->filename);\n      return(MagickFalse);\n    }\n  if (dds_info->ddscaps1 & DDSCAPS_MIPMAP\n      && (dds_info->ddscaps1 & DDSCAPS_TEXTURE\n          || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))\n    {\n      w = DIV2(dds_info->width);\n      h = DIV2(dds_info->height);\n      for (i=1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)\n      {\n        offset = (MagickOffsetType) w * h * pixel_size;\n        (void) SeekBlob(image, offset, SEEK_CUR);\n        w = DIV2(w);\n        h = DIV2(h);\n      }\n    }\n  return(MagickTrue);\n}", "target": 1}
{"code": "MenuCache* menu_cache_lookup( const char* menu_name )\n{\n    MenuCache* cache;\n    MENU_CACHE_LOCK;\n#if !GLIB_CHECK_VERSION(2, 32, 0)\n    if(!sync_run_mutex)\n        sync_run_mutex = g_mutex_new();\n    if(!sync_run_cond)\n        sync_run_cond = g_cond_new();\n#endif\n    if( G_UNLIKELY( ! hash ) )\n        hash = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, NULL );\n    else\n    {\n        cache = (MenuCache*)g_hash_table_lookup(hash, menu_name);\n        if( cache )\n        {\n            menu_cache_ref(cache);\n            MENU_CACHE_UNLOCK;\n            return cache;\n        }\n    }\n    MENU_CACHE_UNLOCK;\n    cache = menu_cache_create(menu_name);\n    cache->cancellable = g_cancellable_new();\n#if GLIB_CHECK_VERSION(2, 32, 0)\n    cache->thr = g_thread_new(menu_name, menu_cache_loader_thread, cache);\n#else\n    cache->thr = g_thread_create(menu_cache_loader_thread, cache, TRUE, NULL);\n#endif\n    return cache;\n}", "target": 0}
{"code": "static void mark_object(struct object *obj, struct strbuf *path,\n\t\t\tconst char *name, void *data)\n{\n\tupdate_progress(data);\n}", "target": 1}
{"code": "int RGWHandler_REST_S3::init(RGWRados *store, struct req_state *s,\n                             rgw::io::BasicClient *cio)\n{\n  int ret;\n  s->dialect = \"s3\";\n  ret = rgw_validate_tenant_name(s->bucket_tenant);\n  if (ret)\n    return ret;\n  bool relaxed_names = s->cct->_conf->rgw_relaxed_s3_bucket_names;\n  if (!s->bucket_name.empty()) {\n    ret = valid_s3_bucket_name(s->bucket_name, relaxed_names);\n    if (ret)\n      return ret;\n    ret = validate_object_name(s->object.name);\n    if (ret)\n      return ret;\n  }\n  const char *cacl = s->info.env->get(\"HTTP_X_AMZ_ACL\");\n  if (cacl)\n    s->canned_acl = cacl;\n  s->has_acl_header = s->info.env->exists_prefix(\"HTTP_X_AMZ_GRANT\");\n  const char *copy_source = s->info.env->get(\"HTTP_X_AMZ_COPY_SOURCE\");\n  if (copy_source &&\n      (! s->info.env->get(\"HTTP_X_AMZ_COPY_SOURCE_RANGE\")) &&\n      (! s->info.args.exists(\"uploadId\"))) {\n    ret = RGWCopyObj::parse_copy_location(copy_source,\n                                          s->init_state.src_bucket,\n                                          s->src_object);\n    if (!ret) {\n      ldout(s->cct, 0) << \"failed to parse copy location\" << dendl;\n      return -EINVAL; \n    }\n  }\n  return RGWHandler_REST::init(store, s, cio);\n}", "target": 0}
{"code": "set_text_distance(gs_point *pdist, double dx, double dy, const gs_matrix *pmat)\n{\n    int code = gs_distance_transform_inverse(dx, dy, pmat, pdist);\n    double rounded;\n    if (code == gs_error_undefinedresult) {\n        pdist->x = pdist->y = 0;\n    } else if (code < 0)\n        return code;\n    if (fabs(pdist->x - (rounded = floor(pdist->x + 0.5))) < 0.0005)\n        pdist->x = rounded;\n    if (fabs(pdist->y - (rounded = floor(pdist->y + 0.5))) < 0.0005)\n        pdist->y = rounded;\n    return 0;\n}", "target": 1}
{"code": "\tvirtual ~CxFile() { };", "target": 1}
{"code": "int pipe_resize_ring(struct pipe_inode_info *pipe, unsigned int nr_slots)\n{\n\tstruct pipe_buffer *bufs;\n\tunsigned int head, tail, mask, n;\n\tmask = pipe->ring_size - 1;\n\thead = pipe->head;\n\ttail = pipe->tail;\n\tn = pipe_occupancy(pipe->head, pipe->tail);\n\tif (nr_slots < n)\n\t\treturn -EBUSY;\n\tbufs = kcalloc(nr_slots, sizeof(*bufs),\n\t\t       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);\n\tif (unlikely(!bufs))\n\t\treturn -ENOMEM;\n\tif (n > 0) {\n\t\tunsigned int h = head & mask;\n\t\tunsigned int t = tail & mask;\n\t\tif (h > t) {\n\t\t\tmemcpy(bufs, pipe->bufs + t,\n\t\t\t       n * sizeof(struct pipe_buffer));\n\t\t} else {\n\t\t\tunsigned int tsize = pipe->ring_size - t;\n\t\t\tif (h > 0)\n\t\t\t\tmemcpy(bufs + tsize, pipe->bufs,\n\t\t\t\t       h * sizeof(struct pipe_buffer));\n\t\t\tmemcpy(bufs, pipe->bufs + t,\n\t\t\t       tsize * sizeof(struct pipe_buffer));\n\t\t}\n\t}\n\thead = n;\n\ttail = 0;\n\tkfree(pipe->bufs);\n\tpipe->bufs = bufs;\n\tpipe->ring_size = nr_slots;\n\tif (pipe->max_usage > nr_slots)\n\t\tpipe->max_usage = nr_slots;\n\tpipe->tail = tail;\n\tpipe->head = head;\n\twake_up_interruptible(&pipe->wr_wait);\n\treturn 0;\n}", "target": 1}
{"code": "pa2ycbcr(UINT8 *out, const UINT8 *in, int xsize, const UINT8 *palette) {\n    pa2rgb(out, in, xsize, palette);\n    ImagingConvertRGB2YCbCr(out, out, xsize);\n}", "target": 0}
{"code": "jas_iccprof_t *jas_iccprof_createfrombuf(uchar *buf, int len)\n{\n\tjas_stream_t *in;\n\tjas_iccprof_t *prof;\n\tif (!(in = jas_stream_memopen(JAS_CAST(char *, buf), len)))\n\t\tgoto error;\n\tif (!(prof = jas_iccprof_load(in)))\n\t\tgoto error;\n\tjas_stream_close(in);\n\treturn prof;\nerror:\n\treturn 0;\n}", "target": 1}
{"code": "int RGWPutObj_ObjStore_S3::get_decrypt_filter(\n    std::unique_ptr<RGWGetObj_Filter>* filter,\n    RGWGetObj_Filter* cb,\n    map<string, bufferlist>& attrs,\n    bufferlist* manifest_bl)\n{\n  std::map<std::string, std::string> crypt_http_responses_unused;\n  int res = 0;\n  std::unique_ptr<BlockCrypt> block_crypt;\n  res = rgw_s3_prepare_decrypt(s, attrs, &block_crypt, crypt_http_responses_unused);\n  if (res == 0) {\n    if (block_crypt != nullptr) {\n      auto f = std::unique_ptr<RGWGetObj_BlockDecrypt>(new RGWGetObj_BlockDecrypt(s->cct, cb, std::move(block_crypt)));\n      if (f != nullptr) {\n        if (manifest_bl != nullptr) {\n          res = f->read_manifest(*manifest_bl);\n          if (res == 0) {\n            *filter = std::move(f);\n          }\n        }\n      }\n    }\n  }\n  return res;\n}", "target": 0}
{"code": "spnego_gss_process_context_token(\n\t\t\t\tOM_uint32\t*minor_status,\n\t\t\t\tconst gss_ctx_id_t context_handle,\n\t\t\t\tconst gss_buffer_t token_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_process_context_token(minor_status,\n\t\t\t\t\tcontext_handle,\n\t\t\t\t\ttoken_buffer);\n\treturn (ret);\n}", "target": 1}
{"code": "SampleEncrypter::EncryptAudioSample(AP4_DataBuffer& sample, AP4_SampleDescription* sample_description)\n{\n    if (sample.GetDataSize() <= 16) {\n        return AP4_SUCCESS;\n    }\n    if (sample_description->GetFormat() == AP4_SAMPLE_FORMAT_EC_3) {\n        AP4_UI08*    data      = sample.UseData();\n        unsigned int data_size = sample.GetDataSize();\n        while (data_size > 4) {\n            unsigned int syncword = (data[0]<<8) | data[1];\n            if (syncword != 0x0b77) {\n                return AP4_ERROR_INVALID_FORMAT; \n            }\n            unsigned int frmsiz = 1+(((data[2]<<8)|(data[3]))&0x7FF);\n            unsigned int frame_size = 2*frmsiz;\n            if (data_size < frame_size) {\n                return AP4_ERROR_INVALID_FORMAT; \n            }\n            if (frame_size > 16) {\n                unsigned int encrypted_block_count = (frame_size-16)/16;\n                AP4_Size encrypted_size = encrypted_block_count*16;\n                m_StreamCipher->SetIV(m_IV);\n                m_StreamCipher->ProcessBuffer(data+16, encrypted_size, data+16, &encrypted_size);\n            }\n            data      += frame_size;\n            data_size -= frame_size;\n        }\n    } else {\n        unsigned int encrypted_block_count = (sample.GetDataSize()-16)/16;\n        AP4_Size encrypted_size = encrypted_block_count*16;\n        m_StreamCipher->SetIV(m_IV);\n        m_StreamCipher->ProcessBuffer(sample.UseData()+16, encrypted_size, sample.UseData()+16, &encrypted_size);\n    }\n    return AP4_SUCCESS;\n}", "target": 0}
{"code": "static void mctp_unregister(struct net_device *dev)\n{\n\tstruct mctp_dev *mdev;\n\tmdev = mctp_dev_get_rtnl(dev);\n\tif (mdev && !mctp_known(dev)) {\n\t\tnetdev_warn(dev, \"%s: BUG mctp_ptr set for unknown type %d\",\n\t\t\t    __func__, dev->type);\n\t\treturn;\n\t}\n\tif (!mdev)\n\t\treturn;\n\tRCU_INIT_POINTER(mdev->dev->mctp_ptr, NULL);\n\tmctp_route_remove_dev(mdev);\n\tmctp_neigh_remove_dev(mdev);\n\tkfree(mdev->addrs);\n\tmctp_dev_put(mdev);\n}", "target": 1}
{"code": "static int ftp_send_command(struct connectdata *conn, const char *message, ...)\n{\n  int ftp_code;\n  ssize_t nread = 0;\n  va_list args;\n  char print_buffer[50];\n  va_start(args, message);\n  mvsnprintf(print_buffer, sizeof(print_buffer), message, args);\n  va_end(args);\n  if(Curl_ftpsend(conn, print_buffer)) {\n    ftp_code = -1;\n  }\n  else {\n    if(Curl_GetFTPResponse(&nread, conn, &ftp_code))\n      ftp_code = -1;\n  }\n  (void)nread; \n  return ftp_code;\n}", "target": 0}
{"code": "vhost_user_set_vring_kick(struct virtio_net **pdev, struct VhostUserMsg *pmsg)\n{\n\tstruct vhost_vring_file file;\n\tstruct vhost_virtqueue *vq;\n\tstruct virtio_net *dev = *pdev;\n\tfile.index = pmsg->payload.u64 & VHOST_USER_VRING_IDX_MASK;\n\tif (pmsg->payload.u64 & VHOST_USER_VRING_NOFD_MASK)\n\t\tfile.fd = VIRTIO_INVALID_EVENTFD;\n\telse\n\t\tfile.fd = pmsg->fds[0];\n\tRTE_LOG(INFO, VHOST_CONFIG,\n\t\t\"vring kick idx:%d file:%d\\n\", file.index, file.fd);\n\tdev = translate_ring_addresses(dev, file.index);\n\tif (!dev)\n\t\treturn;\n\t*pdev = dev;\n\tvq = dev->virtqueue[file.index];\n\tif (!(dev->features & (1ULL << VHOST_USER_F_PROTOCOL_FEATURES)))\n\t\tvq->enabled = 1;\n\tif (vq->kickfd >= 0)\n\t\tclose(vq->kickfd);\n\tvq->kickfd = file.fd;\n}", "target": 0}
{"code": "bool Alter_table_prelocking_strategy::\nhandle_routine(THD *thd, Query_tables_list *prelocking_ctx,\n               Sroutine_hash_entry *rt, sp_head *sp, bool *need_prelocking)\n{\n  return FALSE;\n}", "target": 0}
{"code": "static void r_coresym_cache_element_line_info_fini(RCoreSymCacheElementLineInfo *line) {\n\tif (line) {\n\t\tr_coresym_cache_element_flc_fini (&line->flc);\n\t}\n}", "target": 0}
{"code": "aubio_filterbank_get_coeffs (const aubio_filterbank_t * f)\n{\n  return f->filters;\n}", "target": 0}
{"code": "size_t intsetBlobLen(intset *is) {\n    return sizeof(intset)+intrev32ifbe(is->length)*intrev32ifbe(is->encoding);\n}", "target": 1}
{"code": "static int __init acpi_custom_method_init(void)\n{\n\tif (!acpi_debugfs_dir)\n\t\treturn -ENOENT;\n\tcm_dentry = debugfs_create_file(\"custom_method\", S_IWUSR,\n\t\t\t\t\tacpi_debugfs_dir, NULL, &cm_fops);\n\tif (!cm_dentry)\n\t\treturn -ENODEV;\n\treturn 0;\n}", "target": 1}
{"code": "std::pair<Function *, Function *> ESTreeIRGen::doLazyFunction(\n    hbc::LazyCompilationData *lazyData) {\n  Function *topLevel = Builder.createTopLevelFunction(lazyData->strictMode, {});\n  FunctionContext topLevelFunctionContext{this, topLevel, nullptr};\n  llvh::SaveAndRestore<FunctionContext *> saveTopLevelContext(\n      topLevelContext, &topLevelFunctionContext);\n  auto *node = cast<ESTree::FunctionLikeNode>(Root);\n  lexicalScopeChain = lazyData->parentScope;\n  materializeScopesInChain(\n      topLevel, lexicalScopeChain, getDepth(lexicalScopeChain) - 1);\n  Variable *parentVar = nullptr;\n  if (lazyData->closureAlias.isValid()) {\n    assert(lazyData->originalName.isValid() && \"Original name invalid\");\n    assert(\n        lazyData->originalName != lazyData->closureAlias &&\n        \"Original name must be different from the alias\");\n    parentVar = cast<Variable>(nameTable_.lookup(lazyData->closureAlias));\n    nameTable_.insert(lazyData->originalName, parentVar);\n  }\n  assert(\n      !llvh::isa<ESTree::ArrowFunctionExpressionNode>(node) &&\n      \"lazy compilation not supported for arrow functions\");\n  auto *func = genES5Function(lazyData->originalName, parentVar, node);\n  addLexicalDebugInfo(func, topLevel, lexicalScopeChain);\n  return {func, topLevel};\n}", "target": 1}
{"code": "static struct sk_buff *xennet_get_rx_skb(struct netfront_queue *queue,\n\t\t\t\t\t RING_IDX ri)\n{\n\tint i = xennet_rxidx(ri);\n\tstruct sk_buff *skb = queue->rx_skbs[i];\n\tqueue->rx_skbs[i] = NULL;\n\treturn skb;\n}", "target": 0}
{"code": "const char* RtmpProtocol::handle_C2(const char *data, size_t len) {\n    if (len < C1_HANDSHARK_SIZE) {\n        return nullptr;\n    }\n    _next_step_func = [this](const char *data, size_t len) {\n        return handle_rtmp(data, len);\n    };\n    return handle_rtmp(data + C1_HANDSHARK_SIZE, len - C1_HANDSHARK_SIZE);\n}", "target": 0}
{"code": "TIFFWriteRawTile(TIFF* tif, uint32 tile, void* data, tmsize_t cc)\n{\n\tstatic const char module[] = \"TIFFWriteRawTile\";\n\tif (!WRITECHECKTILES(tif, module))\n\t\treturn ((tmsize_t)(-1));\n\tif (tile >= tif->tif_dir.td_nstrips) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Tile %lu out of range, max %lu\",\n\t\t    (unsigned long) tile,\n\t\t    (unsigned long) tif->tif_dir.td_nstrips);\n\t\treturn ((tmsize_t)(-1));\n\t}\n\treturn (TIFFAppendToStrip(tif, tile, (uint8*) data, cc) ?\n\t    cc : (tmsize_t)(-1));\n}", "target": 0}
{"code": "int http_remove_header2(struct http_msg *msg, struct buffer *buf,\n\t\t\tstruct hdr_idx *idx, struct hdr_ctx *ctx)\n{\n\tint cur_idx = ctx->idx;\n\tchar *sol = ctx->line;\n\tstruct hdr_idx_elem *hdr;\n\tint delta, skip_comma;\n\tif (!cur_idx)\n\t\treturn 0;\n\thdr = &idx->v[cur_idx];\n\tif (sol[ctx->del] == ':' && ctx->val + ctx->vlen + ctx->tws == hdr->len) {\n\t\tdelta = buffer_replace2(buf, sol, sol + hdr->len + hdr->cr + 1, NULL, 0);\n\t\thttp_msg_move_end(msg, delta);\n\t\tidx->used--;\n\t\thdr->len = 0;   \n\t\tidx->v[ctx->prev].next = idx->v[ctx->idx].next;\n\t\tif (idx->tail == ctx->idx)\n\t\t\tidx->tail = ctx->prev;\n\t\tctx->idx = ctx->prev;    \n\t\tctx->line -= idx->v[ctx->idx].len + idx->v[cur_idx].cr + 1;\n\t\tctx->val = idx->v[ctx->idx].len; \n\t\tctx->tws = ctx->vlen = 0;\n\t\treturn ctx->idx;\n\t}\n\tskip_comma = (ctx->val + ctx->vlen + ctx->tws == hdr->len) ? 0 : 1;\n\tdelta = buffer_replace2(buf, sol + ctx->del + skip_comma,\n\t\t\t\tsol + ctx->val + ctx->vlen + ctx->tws + skip_comma,\n\t\t\t\tNULL, 0);\n\thdr->len += delta;\n\thttp_msg_move_end(msg, delta);\n\tctx->val = ctx->del;\n\tctx->tws = ctx->vlen = 0;\n\treturn ctx->idx;\n}", "target": 0}
{"code": "void init_xml_relax_ng()\n{\n  VALUE nokogiri = rb_define_module(\"Nokogiri\");\n  VALUE xml = rb_define_module_under(nokogiri, \"XML\");\n  VALUE klass = rb_define_class_under(xml, \"RelaxNG\", cNokogiriXmlSchema);\n  cNokogiriXmlRelaxNG = klass;\n  rb_define_singleton_method(klass, \"read_memory\", read_memory, 1);\n  rb_define_singleton_method(klass, \"from_document\", from_document, 1);\n  rb_define_private_method(klass, \"validate_document\", validate_document, 1);\n}", "target": 1}
{"code": "static void sev_flush_guest_memory(struct vcpu_svm *svm, void *va,\n\t\t\t\t   unsigned long len)\n{\n\tif (boot_cpu_has(X86_FEATURE_SME_COHERENT))\n\t\treturn;\n\tif (boot_cpu_has(X86_FEATURE_VM_PAGE_FLUSH)) {\n\t\tstruct kvm_sev_info *sev;\n\t\tunsigned long va_start;\n\t\tu64 start, stop;\n\t\tva_start = (unsigned long)va;\n\t\tstart = (u64)va_start & PAGE_MASK;\n\t\tstop = PAGE_ALIGN((u64)va_start + len);\n\t\tif (start < stop) {\n\t\t\tsev = &to_kvm_svm(svm->vcpu.kvm)->sev_info;\n\t\t\twhile (start < stop) {\n\t\t\t\twrmsrl(MSR_AMD64_VM_PAGE_FLUSH,\n\t\t\t\t       start | sev->asid);\n\t\t\t\tstart += PAGE_SIZE;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tWARN(1, \"Address overflow, using WBINVD\\n\");\n\t}\n\tWARN_ONCE(1, \"Using WBINVD to flush guest memory\\n\");\n\twbinvd_on_all_cpus();\n}", "target": 0}
{"code": "int CSoundFile::FrequencyToTranspose(DWORD freq)\n{\n\treturn int(1536*(log(freq/8363.0)/log(2.0)));\n#ifdef MSC_VER\n\tconst float _f1_8363 = 1.0f / 8363.0f;\n\tconst float _factor = 128 * 12;\n\tLONG result;\n\tif (!freq) return 0;\n\t_asm {\n\tfld _factor\n\tfild freq\n\tfld _f1_8363\n\tfmulp st(1), st(0)\n\tfyl2x\n\tfistp result\n\t}\n\treturn result;\n#endif\n}", "target": 0}
{"code": "static u64 get_full_stripe_logical(struct btrfs_block_group_cache *cache,\n\t\t\t\t   u64 bytenr)\n{\n\tu64 ret;\n\tWARN_ON_ONCE(cache->full_stripe_len >= U32_MAX);\n\tret = div64_u64(bytenr - cache->key.objectid, cache->full_stripe_len) *\n\t\tcache->full_stripe_len + cache->key.objectid;\n\treturn ret;\n}", "target": 0}
{"code": "sread(int fd, void *buf, size_t n, int canbepipe)\n{\n\tssize_t rv;\n#ifdef FIONREAD\n\tint t = 0;\n#endif\n\tsize_t rn = n;\n\tif (fd == STDIN_FILENO)\n\t\tgoto nocheck;\n#ifdef FIONREAD\n\tif (canbepipe && (ioctl(fd, FIONREAD, &t) == -1 || t == 0)) {\n#ifdef FD_ZERO\n\t\tssize_t cnt;\n\t\tfor (cnt = 0;; cnt++) {\n\t\t\tfd_set check;\n\t\t\tstruct timeval tout = {0, 100 * 1000};\n\t\t\tint selrv;\n\t\t\tFD_ZERO(&check);\n\t\t\tFD_SET(fd, &check);\n\t\t\tselrv = select(fd + 1, &check, NULL, NULL, &tout);\n\t\t\tif (selrv == -1) {\n\t\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\t\tcontinue;\n\t\t\t} else if (selrv == 0 && cnt >= 5) {\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n#endif\n\t\t(void)ioctl(fd, FIONREAD, &t);\n\t}\n\tif (t > 0 && (size_t)t < n) {\n\t\tn = t;\n\t\trn = n;\n\t}\n#endif\nnocheck:\n\tdo\n\t\tswitch ((rv = FINFO_READ_FUNC(fd, buf, n))) {\n\t\tcase -1:\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\treturn -1;\n\t\tcase 0:\n\t\t\treturn rn - n;\n\t\tdefault:\n\t\t\tn -= rv;\n\t\t\tbuf = ((char *)buf) + rv;\n\t\t\tbreak;\n\t\t}\n\twhile (n > 0);\n\treturn rn;\n}", "target": 0}
{"code": "static void __slab_free(struct kmem_cache *s, struct page *page,\n\t\t\t\tvoid *x, void *addr, unsigned int offset)\n{\n\tvoid *prior;\n\tvoid **object = (void *)x;\n\tstruct kmem_cache_cpu *c;\n\tc = get_cpu_slab(s, raw_smp_processor_id());\n\tstat(c, FREE_SLOWPATH);\n\tslab_lock(page);\n\tif (unlikely(SlabDebug(page)))\n\t\tgoto debug;\nchecks_ok:\n\tprior = object[offset] = page->freelist;\n\tpage->freelist = object;\n\tpage->inuse--;\n\tif (unlikely(SlabFrozen(page))) {\n\t\tstat(c, FREE_FROZEN);\n\t\tgoto out_unlock;\n\t}\n\tif (unlikely(!page->inuse))\n\t\tgoto slab_empty;\n\tif (unlikely(!prior)) {\n\t\tadd_partial(get_node(s, page_to_nid(page)), page, 1);\n\t\tstat(c, FREE_ADD_PARTIAL);\n\t}\nout_unlock:\n\tslab_unlock(page);\n\treturn;\nslab_empty:\n\tif (prior) {\n\t\tremove_partial(s, page);\n\t\tstat(c, FREE_REMOVE_PARTIAL);\n\t}\n\tslab_unlock(page);\n\tstat(c, FREE_SLAB);\n\tdiscard_slab(s, page);\n\treturn;\ndebug:\n\tif (!free_debug_processing(s, page, x, addr))\n\t\tgoto out_unlock;\n\tgoto checks_ok;\n}", "target": 0}
{"code": "static void iova_entry_free(unsigned long data)\n{\n\tstruct page *freelist = (struct page *)data;\n\tdma_free_pagelist(freelist);\n}", "target": 0}
{"code": "void gf_bs_skip_bytes(GF_BitStream *bs, u64 nbBytes)\n{\n\tif (!bs || !nbBytes) return;\n\tgf_bs_align(bs);\n\tif ((bs->bsmode == GF_BITSTREAM_FILE_WRITE) || (bs->bsmode == GF_BITSTREAM_FILE_READ)) {\n\t\tif (bs->cache_write)\n\t\t\tbs_flush_write_cache(bs);\n\t\tif (bs->cache_read) {\n\t\t\tu32 csize = bs->cache_read_size - bs->cache_read_pos;\n\t\t\tif (csize>=nbBytes) {\n\t\t\t\tbs->cache_read_pos += (u32) nbBytes;\n\t\t\t\tbs->position += nbBytes;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tnbBytes -= csize;\n\t\t\tbs->position += csize;\n\t\t\tbs->cache_read_pos = bs->cache_read_size;\n\t\t}\n\t\tbs->position += nbBytes;\n\t\tif (bs->bsmode == GF_BITSTREAM_FILE_READ) {\n\t\t\tif (bs->position > bs->size) bs->position = bs->size;\n\t\t}\n\t\tgf_fseek(bs->stream, bs->position, SEEK_SET);\n\t\treturn;\n\t}\n\tif (bs->bsmode == GF_BITSTREAM_READ) {\n\t\tif (bs->remove_emul_prevention_byte) {\n\t\t\twhile (nbBytes) {\n\t\t\t\tgf_bs_read_u8(bs);\n\t\t\t\tnbBytes--;\n\t\t\t}\n\t\t} else {\n\t\t\tbs->position += nbBytes;\n\t\t\tif (bs->position>bs->size) {\n\t\t\t\tbs->position = bs->size;\n\t\t\t\tbs->overflow_state = 1;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\twhile (nbBytes) {\n\t\tgf_bs_write_int(bs, 0, 8);\n\t\tnbBytes--;\n\t}\n}", "target": 0}
{"code": "snmp_oid_print(uint32_t *oid)\n{\n  uint8_t i;\n  i = 0;\n  LOG_DBG(\"{\");\n  while(oid[i] != ((uint32_t)-1)) {\n    LOG_DBG_(\"%lu\", (unsigned long)oid[i]);\n    i++;\n    if(oid[i] != ((uint32_t)-1)) {\n      LOG_DBG_(\".\");\n    }\n  }\n  LOG_DBG_(\"}\\n\");\n}", "target": 1}
{"code": "sysDescr_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  snmp_api_set_string(varbind, oid, CONTIKI_VERSION_STRING);\n}", "target": 1}
{"code": "static int cma_netdev_change(struct net_device *ndev, struct rdma_id_private *id_priv)\n{\n\tstruct rdma_dev_addr *dev_addr;\n\tstruct cma_work *work;\n\tdev_addr = &id_priv->id.route.addr.dev_addr;\n\tif ((dev_addr->bound_dev_if == ndev->ifindex) &&\n\t    (net_eq(dev_net(ndev), dev_addr->net)) &&\n\t    memcmp(dev_addr->src_dev_addr, ndev->dev_addr, ndev->addr_len)) {\n\t\tpr_info(\"RDMA CM addr change for ndev %s used by id %p\\n\",\n\t\t\tndev->name, &id_priv->id);\n\t\twork = kzalloc(sizeof *work, GFP_KERNEL);\n\t\tif (!work)\n\t\t\treturn -ENOMEM;\n\t\tINIT_WORK(&work->work, cma_work_handler);\n\t\twork->id = id_priv;\n\t\twork->event.event = RDMA_CM_EVENT_ADDR_CHANGE;\n\t\tcma_id_get(id_priv);\n\t\tqueue_work(cma_wq, &work->work);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int test_x509_time(int idx)\n{\n    ASN1_TIME *t = NULL;\n    int result, rv = 0;\n    if (x509_format_tests[idx].set_string) {\n        t = ASN1_TIME_new();\n        if (t == NULL) {\n            TEST_info(\"test_x509_time(%d) failed: internal error\\n\", idx);\n            return 0;\n        }\n    }\n    result = ASN1_TIME_set_string_X509(t, x509_format_tests[idx].data);\n    if (!TEST_int_eq(result, x509_format_tests[idx].expected)) {\n        TEST_info(\"test_x509_time(%d) failed: expected %d, got %d\\n\",\n                idx, x509_format_tests[idx].expected, result);\n        goto out;\n    }\n    if (t != NULL && x509_format_tests[idx].expected_type != -1) {\n        if (!TEST_int_eq(t->type, x509_format_tests[idx].expected_type)) {\n            TEST_info(\"test_x509_time(%d) failed: expected_type %d, got %d\\n\",\n                    idx, x509_format_tests[idx].expected_type, t->type);\n            goto out;\n        }\n    }\n    if (t != NULL && x509_format_tests[idx].expected_string) {\n        if (!TEST_str_eq((const char *)t->data,\n                    x509_format_tests[idx].expected_string)) {\n            TEST_info(\"test_x509_time(%d) failed: expected_string %s, got %s\\n\",\n                    idx, x509_format_tests[idx].expected_string, t->data);\n            goto out;\n        }\n    }\n    rv = 1;\nout:\n    if (t != NULL)\n        ASN1_TIME_free(t);\n    return rv;\n}", "target": 1}
{"code": "update_total_bandwidth_weights(const routerstatus_t *rs,\n                               int is_exit, int is_guard,\n                               int64_t *G, int64_t *M, int64_t *E, int64_t *D,\n                               int64_t *T)\n{\n  int default_bandwidth = rs->bandwidth_kb;\n  int guardfraction_bandwidth = 0;\n  if (!rs->has_bandwidth) {\n    log_info(LD_BUG, \"Missing consensus bandwidth for router %s\",\n             rs->nickname);\n    return;\n  }\n  if (rs->has_guardfraction) {\n    guardfraction_bandwidth_t guardfraction_bw;\n    tor_assert(is_guard);\n    guard_get_guardfraction_bandwidth(&guardfraction_bw,\n                                      rs->bandwidth_kb,\n                                      rs->guardfraction_percentage);\n    default_bandwidth = guardfraction_bw.guard_bw;\n    guardfraction_bandwidth = guardfraction_bw.non_guard_bw;\n  }\n  *T += default_bandwidth;\n  if (is_exit && is_guard) {\n    *D += default_bandwidth;\n    if (rs->has_guardfraction) {\n      *E += guardfraction_bandwidth;\n    }\n  } else if (is_exit) {\n    *E += default_bandwidth;\n  } else if (is_guard) {\n    *G += default_bandwidth;\n    if (rs->has_guardfraction) {\n      *M += guardfraction_bandwidth;\n    }\n  } else {\n    *M += default_bandwidth;\n  }\n}", "target": 0}
{"code": "void phar_add_virtual_dirs(phar_archive_data *phar, char *filename, int filename_len TSRMLS_DC) \n{\n\tconst char *s;\n        while ((s = zend_memrchr(filename, '/', filename_len))) {\n                filename_len = s - filename;\n               if (FAILURE == zend_hash_add_empty_element(&phar->virtual_dirs, filename, filename_len)) {\n                        break;\n                }\n        }\n}", "target": 1}
{"code": "GF_Err proj_type_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ProjectionTypeBox *ptr = (GF_ProjectionTypeBox *)s;\n\tif (ptr->type==GF_ISOM_BOX_TYPE_CBMP) {\n\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\tptr->layout = gf_bs_read_u32(bs);\n\t\tptr->padding = gf_bs_read_u32(bs);\n\t}\n\telse if (ptr->type==GF_ISOM_BOX_TYPE_EQUI) {\n\t\tISOM_DECREASE_SIZE(ptr, 16)\n\t\tptr->bounds_top = gf_bs_read_u32(bs);\n\t\tptr->bounds_bottom = gf_bs_read_u32(bs);\n\t\tptr->bounds_left = gf_bs_read_u32(bs);\n\t\tptr->bounds_right = gf_bs_read_u32(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\tptr->crc = gf_bs_read_u32(bs);\n\t\tptr->encoding_4cc = gf_bs_read_u32(bs);\n\t}\n\treturn gf_isom_box_array_read(s, bs);\n}", "target": 0}
{"code": "unix_listener(const char *path, int backlog, int unlink_first)\n{\n\tstruct sockaddr_un sunaddr;\n\tint saved_errno, sock;\n\tmemset(&sunaddr, 0, sizeof(sunaddr));\n\tsunaddr.sun_family = AF_UNIX;\n\tif (strlcpy(sunaddr.sun_path, path,\n\t    sizeof(sunaddr.sun_path)) >= sizeof(sunaddr.sun_path)) {\n\t\terror_f(\"path \\\"%s\\\" too long for Unix domain socket\", path);\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\tsock = socket(PF_UNIX, SOCK_STREAM, 0);\n\tif (sock == -1) {\n\t\tsaved_errno = errno;\n\t\terror_f(\"socket: %.100s\", strerror(errno));\n\t\terrno = saved_errno;\n\t\treturn -1;\n\t}\n\tif (unlink_first == 1) {\n\t\tif (unlink(path) != 0 && errno != ENOENT)\n\t\t\terror(\"unlink(%s): %.100s\", path, strerror(errno));\n\t}\n\tif (bind(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) == -1) {\n\t\tsaved_errno = errno;\n\t\terror_f(\"cannot bind to path %s: %s\", path, strerror(errno));\n\t\tclose(sock);\n\t\terrno = saved_errno;\n\t\treturn -1;\n\t}\n\tif (listen(sock, backlog) == -1) {\n\t\tsaved_errno = errno;\n\t\terror_f(\"cannot listen on path %s: %s\", path, strerror(errno));\n\t\tclose(sock);\n\t\tunlink(path);\n\t\terrno = saved_errno;\n\t\treturn -1;\n\t}\n\treturn sock;\n}", "target": 0}
{"code": "long keyctl_instantiate_key_common(key_serial_t id,\n\t\t\t\t   const struct iovec *payload_iov,\n\t\t\t\t   unsigned ioc,\n\t\t\t\t   size_t plen,\n\t\t\t\t   key_serial_t ringid)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct request_key_auth *rka;\n\tstruct key *instkey, *dest_keyring;\n\tvoid *payload;\n\tlong ret;\n\tbool vm = false;\n\tkenter(\"%d,,%zu,%d\", id, plen, ringid);\n\tret = -EINVAL;\n\tif (plen > 1024 * 1024 - 1)\n\t\tgoto error;\n\tret = -EPERM;\n\tinstkey = cred->request_key_auth;\n\tif (!instkey)\n\t\tgoto error;\n\trka = instkey->payload.data;\n\tif (rka->target_key->serial != id)\n\t\tgoto error;\n\tpayload = NULL;\n\tif (payload_iov) {\n\t\tret = -ENOMEM;\n\t\tpayload = kmalloc(plen, GFP_KERNEL);\n\t\tif (!payload) {\n\t\t\tif (plen <= PAGE_SIZE)\n\t\t\t\tgoto error;\n\t\t\tvm = true;\n\t\t\tpayload = vmalloc(plen);\n\t\t\tif (!payload)\n\t\t\t\tgoto error;\n\t\t}\n\t\tret = copy_from_user_iovec(payload, payload_iov, ioc);\n\t\tif (ret < 0)\n\t\t\tgoto error2;\n\t}\n\tret = get_instantiation_keyring(ringid, rka, &dest_keyring);\n\tif (ret < 0)\n\t\tgoto error2;\n\tret = key_instantiate_and_link(rka->target_key, payload, plen,\n\t\t\t\t       dest_keyring, instkey);\n\tkey_put(dest_keyring);\n\tif (ret == 0)\n\t\tkeyctl_change_reqkey_auth(NULL);\nerror2:\n\tif (!vm)\n\t\tkfree(payload);\n\telse\n\t\tvfree(payload);\nerror:\n\treturn ret;\n}", "target": 0}
{"code": "void pdu_submit(V9fsPDU *pdu, P9MsgHeader *hdr)\n{\n    Coroutine *co;\n    CoroutineEntry *handler;\n    V9fsState *s = pdu->s;\n    pdu->size = le32_to_cpu(hdr->size_le);\n    pdu->id = hdr->id;\n    pdu->tag = le16_to_cpu(hdr->tag_le);\n    if (pdu->id >= ARRAY_SIZE(pdu_co_handlers) ||\n        (pdu_co_handlers[pdu->id] == NULL)) {\n        handler = v9fs_op_not_supp;\n    } else if (is_ro_export(&s->ctx) && !is_read_only_op(pdu)) {\n        handler = v9fs_fs_ro;\n    } else {\n        handler = pdu_co_handlers[pdu->id];\n    }\n    qemu_co_queue_init(&pdu->complete);\n    co = qemu_coroutine_create(handler, pdu);\n    qemu_coroutine_enter(co);\n}", "target": 0}
{"code": "unsigned int get_random_int(void)\n{\n\treturn secure_ip_id((__force __be32)(current->pid + jiffies));\n}", "target": 1}
{"code": "uint32_t virtio_config_readl(VirtIODevice *vdev, uint32_t addr)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint32_t val;\n    k->get_config(vdev, vdev->config);\n    if (addr > (vdev->config_len - sizeof(val)))\n        return (uint32_t)-1;\n    val = ldl_p(vdev->config + addr);\n    return val;\n}", "target": 1}
{"code": "sldns_affix_token(sldns_buffer* strbuf, char* token, size_t* token_len,\n\tint* quoted, int* parens, size_t* pre_data_pos,\n\tconst char* delimiters, sldns_rdf_type rdftype, size_t* token_strlen)\n{\n\tsize_t addlen = *token_len - *token_strlen;\n\tsize_t addstrlen = 0;\n\tif(addlen < 1) return 0;\n\ttoken[*token_strlen] = ' ';\n\ttoken[++(*token_strlen)] = 0;\n\taddlen = *token_len - *token_strlen;\n\tif(!sldns_parse_rdf_token(strbuf, token+*token_strlen, addlen, quoted,\n\t\tparens, pre_data_pos, delimiters, rdftype, &addstrlen))\n\t\treturn 0;\n\t(*token_strlen) += addstrlen;\n\treturn 1;\n}", "target": 0}
{"code": "exit_policy_is_general_exit_helper(smartlist_t *policy, int port)\n{\n  uint32_t mask, ip, i;\n  char subnet_status[256];\n  memset(subnet_status, 0, sizeof(subnet_status));\n  SMARTLIST_FOREACH(policy, addr_policy_t *, p, {\n    if (tor_addr_family(&p->addr) != AF_INET)\n      continue; \n    if (p->prt_min > port || p->prt_max < port)\n      continue; \n    mask = 0;\n    tor_assert(p->maskbits <= 32);\n    if (p->maskbits)\n      mask = UINT32_MAX<<(32-p->maskbits);\n    ip = tor_addr_to_ipv4h(&p->addr);\n    for (i = ((mask & ip)>>24); i <= (~((mask & ip) ^ mask)>>24); ++i) {\n      tor_addr_t addr;\n      if (subnet_status[i] != 0)\n        continue; \n      tor_addr_from_ipv4h(&addr, i<<24);\n      if (tor_addr_is_internal(&addr, 0))\n        continue; \n      if (p->policy_type == ADDR_POLICY_ACCEPT) {\n        if (p->maskbits > 8)\n          continue; \n        return 1;\n      } else if (p->policy_type == ADDR_POLICY_REJECT) {\n        subnet_status[i] = 1;\n      }\n    }\n  });\n  return 0;\n}", "target": 0}
{"code": "comics_document_thumbnails_get_dimensions (EvDocumentThumbnails *document,\n\t\t\t\t\t   EvRenderContext      *rc,\n\t\t\t\t\t   gint                 *width,\n\t\t\t\t\t   gint                 *height)\n{\n\tgdouble page_width, page_height;\n\tcomics_document_get_page_size (EV_DOCUMENT (document), rc->page,\n\t\t\t\t       &page_width, &page_height);\n\tif (rc->rotation == 90 || rc->rotation == 270) {\n\t\t*width = (gint) (page_height * rc->scale);\n\t\t*height = (gint) (page_width * rc->scale);\n\t} else {\n\t\t*width = (gint) (page_width * rc->scale);\n\t\t*height = (gint) (page_height * rc->scale);\n\t}\n}", "target": 1}
{"code": "static int tcp_match_skb_to_sack(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t u32 start_seq, u32 end_seq)\n{\n\tint in_sack, err;\n\tunsigned int pkt_len;\n\tunsigned int mss;\n\tin_sack = !after(start_seq, TCP_SKB_CB(skb)->seq) &&\n\t\t  !before(end_seq, TCP_SKB_CB(skb)->end_seq);\n\tif (tcp_skb_pcount(skb) > 1 && !in_sack &&\n\t    after(TCP_SKB_CB(skb)->end_seq, start_seq)) {\n\t\tmss = tcp_skb_mss(skb);\n\t\tin_sack = !after(start_seq, TCP_SKB_CB(skb)->seq);\n\t\tif (!in_sack) {\n\t\t\tpkt_len = start_seq - TCP_SKB_CB(skb)->seq;\n\t\t\tif (pkt_len < mss)\n\t\t\t\tpkt_len = mss;\n\t\t} else {\n\t\t\tpkt_len = end_seq - TCP_SKB_CB(skb)->seq;\n\t\t\tif (pkt_len < mss)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (pkt_len > mss) {\n\t\t\tunsigned int new_len = (pkt_len / mss) * mss;\n\t\t\tif (!in_sack && new_len < pkt_len) {\n\t\t\t\tnew_len += mss;\n\t\t\t\tif (new_len > skb->len)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpkt_len = new_len;\n\t\t}\n\t\terr = tcp_fragment(sk, skb, pkt_len, mss);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn in_sack;\n}", "target": 0}
{"code": "push_n_(codegen_scope *s, int n)\n{\n  if (s->sp+n >= 0xffff) {\n    codegen_error(s, \"too complex expression\");\n  }\n  s->sp+=n;\n  nregs_update;\n}", "target": 0}
{"code": "static ssize_t available_instances_show(struct mdev_type *mtype,\n\t\t\t\t\tstruct mdev_type_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tconst struct mbochs_type *type =\n\t\t&mbochs_types[mtype_get_type_group_id(mtype)];\n\tint count = (max_mbytes - mbochs_used_mbytes) / type->mbytes;\n\treturn sprintf(buf, \"%d\\n\", count);\n}", "target": 1}
{"code": "static int ntlm_decode_u16l_str_hdr(struct ntlm_ctx *ctx,\n                                    struct wire_field_hdr *str_hdr,\n                                    struct ntlm_buffer *buffer,\n                                    size_t payload_offs, char **str)\n{\n    char *in, *out = NULL;\n    uint16_t str_len;\n    uint32_t str_offs;\n    size_t outlen;\n    int ret = 0;\n    str_len = le16toh(str_hdr->len);\n    if (str_len == 0) goto done;\n    str_offs = le32toh(str_hdr->offset);\n    if ((str_offs < payload_offs) ||\n        (str_offs > buffer->length) ||\n        (UINT32_MAX - str_offs < str_len) ||\n        (str_offs + str_len > buffer->length)) {\n        return ERR_DECODE;\n    }\n    in = (char *)&buffer->data[str_offs];\n    out = malloc(str_len * 2 + 1);\n    if (!out) return ENOMEM;\n    ret = ntlm_str_convert(ctx->to_oem, in, out, str_len, &outlen);\n    out[outlen] = '\\0';\ndone:\n    if (ret) {\n        safefree(out);\n    }\n    *str = out;\n    return ret;\n}", "target": 0}
{"code": "  void *realloc(void *ptr, size_t newsz)\n  {\n    void *ret = ::realloc(ptr, newsz + extra_bytes);\n    forget_ptr(ptr);\n    mem_ptr(ret);\n    return ret;\n  }", "target": 0}
{"code": "writeRandomBytes_arc4random(void * target, size_t count) {\n  size_t bytesWrittenTotal = 0;\n  while (bytesWrittenTotal < count) {\n    const uint32_t random32 = arc4random();\n    size_t i = 0;\n    for (; (i < sizeof(random32)) && (bytesWrittenTotal < count);\n        i++, bytesWrittenTotal++) {\n      const uint8_t random8 = (uint8_t)(random32 >> (i * 8));\n      ((uint8_t *)target)[bytesWrittenTotal] = random8;\n    }\n  }\n}", "target": 0}
{"code": "int rtnl_send_check(struct rtnl_handle *rth, const void *buf, int len)\n{\n\tstruct nlmsghdr *h;\n\tint status;\n\tchar resp[1024];\n\tstatus = send(rth->fd, buf, len, 0);\n\tif (status < 0)\n\t\treturn status;\n\tstatus = recv(rth->fd, resp, sizeof(resp), MSG_DONTWAIT|MSG_PEEK);\n\tif (status < 0) {\n\t\tif (errno == EAGAIN)\n\t\t\treturn 0;\n\t\treturn -1;\n\t}\n\tfor (h = (struct nlmsghdr *)resp; NLMSG_OK(h, status);\n\t     h = NLMSG_NEXT(h, status)) {\n\t\tif (h->nlmsg_type == NLMSG_ERROR) {\n\t\t\tstruct nlmsgerr *err = (struct nlmsgerr *)NLMSG_DATA(h);\n\t\t\tif (h->nlmsg_len < NLMSG_LENGTH(sizeof(struct nlmsgerr)))\n\t\t\t\tfprintf(stderr, \"ERROR truncated\\n\");\n\t\t\telse\n\t\t\t\terrno = -err->error;\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int ipv4ll_recv_arp_packet(GDHCPClient *dhcp_client)\n{\n\tint bytes;\n\tstruct ether_arp arp;\n\tuint32_t ip_requested;\n\tint source_conflict;\n\tint target_conflict;\n\tguint timeout_ms;\n\tmemset(&arp, 0, sizeof(arp));\n\tbytes = read(dhcp_client->listener_sockfd, &arp, sizeof(arp));\n\tif (bytes < 0)\n\t\treturn bytes;\n\tif (arp.arp_op != htons(ARPOP_REPLY) &&\n\t\t\tarp.arp_op != htons(ARPOP_REQUEST))\n\t\treturn -EINVAL;\n\tif (memcmp(arp.arp_sha, dhcp_client->mac_address, ETH_ALEN) == 0)\n\t\treturn 0;\n\tip_requested = htonl(dhcp_client->requested_ip);\n\tsource_conflict = !memcmp(arp.arp_spa, &ip_requested,\n\t\t\t\t\t\tsizeof(ip_requested));\n\ttarget_conflict = !memcmp(arp.arp_tpa, &ip_requested,\n\t\t\t\tsizeof(ip_requested));\n\tif (!source_conflict && !target_conflict)\n\t\treturn 0;\n\tdhcp_client->conflicts++;\n\tdebug(dhcp_client, \"IPV4LL conflict detected\");\n\tif (dhcp_client->state == IPV4LL_MONITOR) {\n\t\tif (!source_conflict)\n\t\t\treturn 0;\n\t\tdhcp_client->state = IPV4LL_DEFEND;\n\t\tdebug(dhcp_client, \"DEFEND mode conflicts : %d\",\n\t\t\tdhcp_client->conflicts);\n\t\tsend_announce_packet(dhcp_client);\n\t\treturn 0;\n\t}\n\tif (dhcp_client->state == IPV4LL_DEFEND) {\n\t\tif (!source_conflict)\n\t\t\treturn 0;\n\t\telse if (dhcp_client->ipv4ll_lost_cb)\n\t\t\tdhcp_client->ipv4ll_lost_cb(dhcp_client,\n\t\t\t\t\t\tdhcp_client->ipv4ll_lost_data);\n\t}\n\tipv4ll_stop(dhcp_client);\n\tif (dhcp_client->conflicts < MAX_CONFLICTS)\n\t\ttimeout_ms = __connman_util_random_delay_ms(PROBE_WAIT);\n\telse\n\t\ttimeout_ms = RATE_LIMIT_INTERVAL * 1000;\n\tdhcp_client->retry_times++;\n\tdhcp_client->timeout =\n\t\tg_timeout_add_full(G_PRIORITY_HIGH,\n\t\t\t\ttimeout_ms,\n\t\t\t\tsend_probe_packet,\n\t\t\t\tdhcp_client,\n\t\t\t\tNULL);\n\treturn 0;\n}", "target": 0}
{"code": "void HTMLMediaElement::SelectMediaResource() {\n  BLINK_MEDIA_LOG << \"selectMediaResource(\" << (void*)this << \")\";\n  enum Mode { kObject, kAttribute, kChildren, kNothing };\n  Mode mode = kNothing;\n  if (src_object_) {\n    mode = kObject;\n  } else if (FastHasAttribute(kSrcAttr)) {\n    mode = kAttribute;\n  } else if (HTMLSourceElement* element =\n                 Traversal<HTMLSourceElement>::FirstChild(*this)) {\n    mode = kChildren;\n    next_child_node_to_consider_ = element;\n    current_source_node_ = nullptr;\n  } else {\n    load_state_ = kWaitingForSource;\n    SetShouldDelayLoadEvent(false);\n    if (!GetWebMediaPlayer() || (ready_state_ < kHaveFutureData &&\n                                 ready_state_maximum_ < kHaveFutureData)) {\n      SetNetworkState(kNetworkEmpty);\n    } else {\n      UseCounter::Count(GetDocument(),\n                        WebFeature::kHTMLMediaElementEmptyLoadWithFutureData);\n    }\n    UpdateDisplayState();\n    BLINK_MEDIA_LOG << \"selectMediaResource(\" << (void*)this\n                    << \"), nothing to load\";\n    return;\n  }\n  SetNetworkState(kNetworkLoading);\n  ScheduleEvent(event_type_names::kLoadstart);\n  switch (mode) {\n    case kObject:\n      LoadSourceFromObject();\n      BLINK_MEDIA_LOG << \"selectMediaResource(\" << (void*)this\n                      << \", using 'srcObject' attribute\";\n      break;\n    case kAttribute:\n      LoadSourceFromAttribute();\n      BLINK_MEDIA_LOG << \"selectMediaResource(\" << (void*)this\n                      << \"), using 'src' attribute url\";\n      break;\n    case kChildren:\n      LoadNextSourceChild();\n      BLINK_MEDIA_LOG << \"selectMediaResource(\" << (void*)this\n                      << \"), using source element\";\n      break;\n    default:\n      NOTREACHED();\n  }\n}", "target": 0}
{"code": "int crxParamInit(CrxBandParam **param, uint64_t subbandMdatOffset,\n                 uint64_t subbandDataSize, uint32_t subbandWidth,\n                 uint32_t subbandHeight, int32_t supportsPartial,\n                 uint32_t roundedBitsMask, LibRaw_abstract_datastream *input)\n{\n  int32_t progrDataSize = supportsPartial ? 0 : sizeof(int32_t) * subbandWidth;\n  int32_t paramLength = 2 * subbandWidth + 4;\n  uint8_t *paramBuf = (uint8_t *)calloc(\n      1, sizeof(CrxBandParam) + sizeof(int32_t) * paramLength + progrDataSize);\n  if (!paramBuf)\n    return -1;\n  *param = (CrxBandParam *)paramBuf;\n  paramBuf += sizeof(CrxBandParam);\n  (*param)->paramData = (int32_t *)paramBuf;\n  (*param)->nonProgrData =\n      progrDataSize ? (*param)->paramData + paramLength : 0;\n  (*param)->subbandWidth = subbandWidth;\n  (*param)->subbandHeight = subbandHeight;\n  (*param)->roundedBits = 0;\n  (*param)->curLine = 0;\n  (*param)->roundedBitsMask = roundedBitsMask;\n  (*param)->supportsPartial = supportsPartial;\n  (*param)->bitStream.bitData = 0;\n  (*param)->bitStream.bitsLeft = 0;\n  (*param)->bitStream.mdatSize = subbandDataSize;\n  (*param)->bitStream.curPos = 0;\n  (*param)->bitStream.curBufSize = 0;\n  (*param)->bitStream.curBufOffset = subbandMdatOffset;\n  (*param)->bitStream.input = input;\n  crxFillBuffer(&(*param)->bitStream);\n  return 0;\n}", "target": 1}
{"code": "void vsock_add_pending(struct sock *listener, struct sock *pending)\n{\n\tstruct vsock_sock *vlistener;\n\tstruct vsock_sock *vpending;\n\tvlistener = vsock_sk(listener);\n\tvpending = vsock_sk(pending);\n\tsock_hold(pending);\n\tsock_hold(listener);\n\tlist_add_tail(&vpending->pending_links, &vlistener->pending_links);\n}", "target": 0}
{"code": "ossl_cipher_initialize(VALUE self, VALUE str)\n{\n    EVP_CIPHER_CTX *ctx;\n    const EVP_CIPHER *cipher;\n    char *name;\n    unsigned char dummy_key[EVP_MAX_KEY_LENGTH] = { 0 };\n    name = StringValueCStr(str);\n    GetCipherInit(self, ctx);\n    if (ctx) {\n\tossl_raise(rb_eRuntimeError, \"Cipher already inititalized!\");\n    }\n    AllocCipher(self, ctx);\n    if (!(cipher = EVP_get_cipherbyname(name))) {\n\tossl_raise(rb_eRuntimeError, \"unsupported cipher algorithm (%\"PRIsVALUE\")\", str);\n    }\n    if (EVP_CipherInit_ex(ctx, cipher, NULL, dummy_key, NULL, -1) != 1)\n\tossl_raise(eCipherError, NULL);\n    return self;\n}", "target": 1}
{"code": "static void sunkbd_reinit(struct work_struct *work)\n{\n\tstruct sunkbd *sunkbd = container_of(work, struct sunkbd, tq);\n\twait_event_interruptible_timeout(sunkbd->wait, sunkbd->reset >= 0, HZ);\n\tserio_write(sunkbd->serio, SUNKBD_CMD_SETLED);\n\tserio_write(sunkbd->serio,\n\t\t(!!test_bit(LED_CAPSL,   sunkbd->dev->led) << 3) |\n\t\t(!!test_bit(LED_SCROLLL, sunkbd->dev->led) << 2) |\n\t\t(!!test_bit(LED_COMPOSE, sunkbd->dev->led) << 1) |\n\t\t !!test_bit(LED_NUML,    sunkbd->dev->led));\n\tserio_write(sunkbd->serio,\n\t\tSUNKBD_CMD_NOCLICK - !!test_bit(SND_CLICK, sunkbd->dev->snd));\n\tserio_write(sunkbd->serio,\n\t\tSUNKBD_CMD_BELLOFF - !!test_bit(SND_BELL, sunkbd->dev->snd));\n}", "target": 1}
{"code": "static CURLUcode decode_host(char *hostname, char **outp)\n{\n  char *per = NULL;\n  if(hostname[0] != '[')\n    per = strchr(hostname, '%');\n  if(!per) {\n    *outp = strdup(hostname);\n    if(!*outp)\n      return CURLUE_OUT_OF_MEMORY;\n  }\n  else {\n    size_t dlen;\n    CURLcode result = Curl_urldecode(hostname, 0, outp, &dlen, REJECT_CTRL);\n    if(result)\n      return CURLUE_BAD_HOSTNAME;\n  }\n  return CURLUE_OK;\n}", "target": 0}
{"code": "void LanLinkProvider::newConnection()\n{\n    qCDebug(KDECONNECT_CORE) << \"LanLinkProvider newConnection\";\n    while (m_server->hasPendingConnections()) {\n        QSslSocket* socket = m_server->nextPendingConnection();\n        configureSocket(socket);\n        connect(socket, &QAbstractSocket::disconnected,\n                socket, &QObject::deleteLater);\n        connect(socket, &QIODevice::readyRead,\n                this, &LanLinkProvider::dataReceived);\n    }\n}", "target": 1}
{"code": "create_worker_threads(uint n)\n{\n\tcomp_thread_ctxt_t\t*threads;\n\tuint \t\t\ti;\n\tthreads = (comp_thread_ctxt_t *)\n\t\tmy_malloc(sizeof(comp_thread_ctxt_t) * n, MYF(MY_FAE));\n\tfor (i = 0; i < n; i++) {\n\t\tcomp_thread_ctxt_t *thd = threads + i;\n\t\tthd->num = i + 1;\n\t\tthd->started = FALSE;\n\t\tthd->cancelled = FALSE;\n\t\tthd->data_avail = FALSE;\n\t\tthd->to = (char *) my_malloc(COMPRESS_CHUNK_SIZE +\n\t\t\t\t\t\t   MY_QLZ_COMPRESS_OVERHEAD,\n\t\t\t\t\t\t   MYF(MY_FAE));\n\t\tif (pthread_mutex_init(&thd->ctrl_mutex, NULL) ||\n\t\t    pthread_cond_init(&thd->ctrl_cond, NULL)) {\n\t\t\tgoto err;\n\t\t}\n\t\tif (pthread_mutex_init(&thd->data_mutex, NULL) ||\n\t\t    pthread_cond_init(&thd->data_cond, NULL)) {\n\t\t\tgoto err;\n\t\t}\n\t\tpthread_mutex_lock(&thd->ctrl_mutex);\n\t\tif (pthread_create(&thd->id, NULL, compress_worker_thread_func,\n\t\t\t\t   thd)) {\n\t\t\tmsg(\"compress: pthread_create() failed: \"\n\t\t\t    \"errno = %d\", errno);\n\t\t\tgoto err;\n\t\t}\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tcomp_thread_ctxt_t *thd = threads + i;\n\t\twhile (thd->started == FALSE)\n\t\t\tpthread_cond_wait(&thd->ctrl_cond, &thd->ctrl_mutex);\n\t\tpthread_mutex_unlock(&thd->ctrl_mutex);\n\t}\n\treturn threads;\nerr:\n\tmy_free(threads);\n\treturn NULL;\n}", "target": 1}
{"code": "static Token *make_tok_qstr_len(Token *next, const char *str, size_t len)\n{\n    char *p = nasm_quote(str, &len);\n    return new_Token_free(next, TOK_STRING, p, len);\n}", "target": 0}
{"code": "NAN_METHOD(TxnWrap::ctor) {\n    Nan::HandleScope scope;\n    EnvWrap *ew = Nan::ObjectWrap::Unwrap<EnvWrap>(Local<Object>::Cast(info[0]));\n    int flags = 0;\n    if (info[1]->IsObject()) {\n        Local<Object> options = Local<Object>::Cast(info[1]);\n        setFlagFromValue(&flags, MDB_RDONLY, \"readOnly\", false, options);\n    }\n    if (0 == (flags & MDB_RDONLY) && ew->currentWriteTxn != nullptr) {\n        return Nan::ThrowError(\"You have already opened a write transaction in the current process, can't open a second one.\");\n    }\n    MDB_txn *txn;\n    int rc = mdb_txn_begin(ew->env, nullptr, flags, &txn);\n    if (rc != 0) {\n        if (rc == EINVAL) {\n            return Nan::ThrowError(\"Invalid parameter, which on MacOS is often due to more transactions than available robust locked semaphors (see node-lmdb docs for more info)\");\n        }\n        return throwLmdbError(rc);\n    }\n    TxnWrap* tw = new TxnWrap(ew->env, txn);\n    tw->flags = flags;\n    tw->ew = ew;\n    tw->ew->Ref();\n    tw->Wrap(info.This());\n    if (0 == (flags & MDB_RDONLY)) {\n        ew->currentWriteTxn = tw;\n    }\n    else {\n        ew->readTxns.push_back(tw);\n    }\n    return info.GetReturnValue().Set(info.This());\n}", "target": 0}
{"code": "static inline bool spectre_v2_in_ibrs_mode(enum spectre_v2_mitigation mode)\n{\n\treturn mode == SPECTRE_V2_IBRS ||\n\t       mode == SPECTRE_V2_EIBRS ||\n\t       mode == SPECTRE_V2_EIBRS_RETPOLINE ||\n\t       mode == SPECTRE_V2_EIBRS_LFENCE;\n}", "target": 1}
{"code": "int tipc_nl_node_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint err;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct tipc_net *tn = net_generic(net, tipc_net_id);\n\tint done = cb->args[0];\n\tint last_addr = cb->args[1];\n\tstruct tipc_node *node;\n\tstruct tipc_nl_msg msg;\n\tif (done)\n\t\treturn 0;\n\tmsg.skb = skb;\n\tmsg.portid = NETLINK_CB(cb->skb).portid;\n\tmsg.seq = cb->nlh->nlmsg_seq;\n\trcu_read_lock();\n\tif (last_addr) {\n\t\tnode = tipc_node_find(net, last_addr);\n\t\tif (!node) {\n\t\t\trcu_read_unlock();\n\t\t\tcb->prev_seq = 1;\n\t\t\treturn -EPIPE;\n\t\t}\n\t\ttipc_node_put(node);\n\t}\n\tlist_for_each_entry_rcu(node, &tn->node_list, list) {\n\t\tif (node->preliminary)\n\t\t\tcontinue;\n\t\tif (last_addr) {\n\t\t\tif (node->addr == last_addr)\n\t\t\t\tlast_addr = 0;\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\t\ttipc_node_read_lock(node);\n\t\terr = __tipc_nl_add_node(&msg, node);\n\t\tif (err) {\n\t\t\tlast_addr = node->addr;\n\t\t\ttipc_node_read_unlock(node);\n\t\t\tgoto out;\n\t\t}\n\t\ttipc_node_read_unlock(node);\n\t}\n\tdone = 1;\nout:\n\tcb->args[0] = done;\n\tcb->args[1] = last_addr;\n\trcu_read_unlock();\n\treturn skb->len;\n}", "target": 0}
{"code": "void sas_init_disc(struct sas_discovery *disc, struct asd_sas_port *port)\n{\n\tint i;\n\tstatic const work_func_t sas_event_fns[DISC_NUM_EVENTS] = {\n\t\t[DISCE_DISCOVER_DOMAIN] = sas_discover_domain,\n\t\t[DISCE_REVALIDATE_DOMAIN] = sas_revalidate_domain,\n\t\t[DISCE_PROBE] = sas_probe_devices,\n\t\t[DISCE_SUSPEND] = sas_suspend_devices,\n\t\t[DISCE_RESUME] = sas_resume_devices,\n\t\t[DISCE_DESTRUCT] = sas_destruct_devices,\n\t};\n\tdisc->pending = 0;\n\tfor (i = 0; i < DISC_NUM_EVENTS; i++) {\n\t\tINIT_SAS_WORK(&disc->disc_work[i].work, sas_event_fns[i]);\n\t\tdisc->disc_work[i].port = port;\n\t}\n}", "target": 1}
{"code": "fetch_indexed_string (dwarf_vma           idx,\n\t\t      struct cu_tu_set *  this_set,\n\t\t      dwarf_vma           offset_size,\n\t\t      bool                dwo,\n\t\t      dwarf_vma           str_offsets_base)\n{\n  enum dwarf_section_display_enum str_sec_idx = dwo ? str_dwo : str;\n  enum dwarf_section_display_enum idx_sec_idx = dwo ? str_index_dwo : str_index;\n  struct dwarf_section *index_section = &debug_displays [idx_sec_idx].section;\n  struct dwarf_section *str_section = &debug_displays [str_sec_idx].section;\n  dwarf_vma index_offset;\n  dwarf_vma str_offset;\n  const char * ret;\n  if (index_section->start == NULL)\n    return (dwo ? _(\"<no .debug_str_offsets.dwo section>\")\n\t\t: _(\"<no .debug_str_offsets section>\"));\n  if (str_section->start == NULL)\n    return (dwo ? _(\"<no .debug_str.dwo section>\")\n\t\t: _(\"<no .debug_str section>\"));\n  index_offset = idx * offset_size;\n  if (this_set != NULL)\n    index_offset += this_set->section_offsets [DW_SECT_STR_OFFSETS];\n  index_offset += str_offsets_base;\n  if (index_offset + offset_size > index_section->size)\n    {\n      warn (_(\"string index of %s converts to an offset of 0x%s which is too big for section %s\"),\n\t    dwarf_vmatoa (\"d\", idx),\n\t    dwarf_vmatoa (\"x\", index_offset),\n\t    str_section->name);\n      return _(\"<string index too big>\");\n    }\n  str_offset = byte_get (index_section->start + index_offset, offset_size);\n  str_offset -= str_section->address;\n  if (str_offset >= str_section->size)\n    {\n      warn (_(\"indirect offset too big: 0x%s\\n\"),\n\t    dwarf_vmatoa (\"x\", str_offset));\n      return _(\"<indirect index offset is too big>\");\n    }\n  ret = (const char *) str_section->start + str_offset;\n  if (strnlen (ret, str_section->size - str_offset)\n      == str_section->size - str_offset)\n    return _(\"<no NUL byte at end of section>\");\n  return ret;\n}", "target": 0}
{"code": "static inline void jmp_rel(struct x86_emulate_ctxt *ctxt, int rel)\n{\n\tassign_eip_near(ctxt, ctxt->_eip + rel);\n}", "target": 1}
{"code": "nm_wildcard_match_check(const char *str, const char *const *patterns, guint num_patterns)\n{\n    gboolean has_optional     = FALSE;\n    gboolean has_any_optional = FALSE;\n    guint    i;\n    for (i = 0; i < num_patterns; i++) {\n        gboolean    is_inverted;\n        gboolean    is_mandatory;\n        gboolean    match;\n        const char *p;\n        _pattern_parse(patterns[i], &p, &is_inverted, &is_mandatory);\n        match = (fnmatch(p, str, 0) == 0);\n        if (is_inverted)\n            match = !match;\n        if (is_mandatory) {\n            if (!match)\n                return FALSE;\n        } else {\n            has_any_optional = TRUE;\n            if (match)\n                has_optional = TRUE;\n        }\n    }\n    return has_optional || !has_any_optional;\n}", "target": 1}
{"code": "lys_getnext_data(const struct lys_module *mod, const struct lys_node *parent, const char *name, int nam_len,\n                 LYS_NODE type, const struct lys_node **ret)\n{\n    const struct lys_node *node;\n    assert((mod || parent) && name);\n    assert(!(type & (LYS_AUGMENT | LYS_USES | LYS_GROUPING | LYS_CHOICE | LYS_CASE | LYS_INPUT | LYS_OUTPUT)));\n    if (!mod) {\n        mod = lys_node_module(parent);\n    }\n    node = NULL;\n    while ((node = lys_getnext(node, parent, mod, 0))) {\n        if (!type || (node->nodetype & type)) {\n            if (lys_node_module(node) != lys_main_module(mod)) {\n                continue;\n            }\n            if (!strncmp(node->name, name, nam_len) && !node->name[nam_len]) {\n                if (ret) {\n                    *ret = node;\n                }\n                return EXIT_SUCCESS;\n            }\n        }\n    }\n    return EXIT_FAILURE;\n}", "target": 1}
{"code": "inline void update_rq_clock(struct rq *rq)\n{\n\tif (!rq->skip_clock_update) {\n\t\tint cpu = cpu_of(rq);\n\t\tu64 irq_time;\n\t\trq->clock = sched_clock_cpu(cpu);\n\t\tirq_time = irq_time_cpu(cpu);\n\t\tif (rq->clock - irq_time > rq->clock_task)\n\t\t\trq->clock_task = rq->clock - irq_time;\n\t\tsched_irq_time_avg_update(rq, irq_time);\n\t}\n}", "target": 1}
{"code": "adium_info_dup_path_for_variant (GHashTable *info,\n\t\t\t\t const gchar *variant)\n{\n\tguint version = adium_info_get_version (info);\n\tconst gchar *no_variant = adium_info_get_no_variant_name (info);\n\tGPtrArray *variants;\n\tguint i;\n\tif (version <= 2 && !tp_strdiff (variant, no_variant)) {\n\t\treturn g_strdup (\"main.css\");\n\t}\n\tvariants = empathy_adium_info_get_available_variants (info);\n\tif (variants->len == 0)\n\t\treturn g_strdup (\"main.css\");\n\tfor (i = 0; i < variants->len; i++) {\n\t\tif (!tp_strdiff (variant, g_ptr_array_index (variants, i))) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == variants->len) {\n\t\tDEBUG (\"Variant %s does not exist\", variant);\n\t\tvariant = g_ptr_array_index (variants, 0);\n\t}\n\treturn g_strdup_printf (\"Variants/%s.css\", variant);\n}", "target": 0}
{"code": "static int sched_group_set_rt_runtime(struct task_group *tg, long rt_runtime_us)\n{\n\tu64 rt_runtime, rt_period;\n\trt_period = ktime_to_ns(tg->rt_bandwidth.rt_period);\n\trt_runtime = (u64)rt_runtime_us * NSEC_PER_USEC;\n\tif (rt_runtime_us < 0)\n\t\trt_runtime = RUNTIME_INF;\n\treturn tg_set_rt_bandwidth(tg, rt_period, rt_runtime);\n}", "target": 0}
{"code": "static int pppol2tp_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t len,\n\t\t\t    int flags)\n{\n\tint err;\n\tstruct sk_buff *skb;\n\tstruct sock *sk = sock->sk;\n\terr = -EIO;\n\tif (sk->sk_state & PPPOX_BOUND)\n\t\tgoto end;\n\tmsg->msg_namelen = 0;\n\terr = 0;\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\tgoto end;\n\tif (len > skb->len)\n\t\tlen = skb->len;\n\telse if (len < skb->len)\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, len);\n\tif (likely(err == 0))\n\t\terr = len;\n\tkfree_skb(skb);\nend:\n\treturn err;\n}", "target": 1}
{"code": "deltas_head_values_set(struct deltas_head *deltas)\n{\n\treturn deltas->len == deltas->capacity;\n}", "target": 1}
{"code": "void SecurityManager::notify_participant_authorized(\n        const ParticipantProxyData& participant_data)\n{\n    participant_->pdp()->notifyAboveRemoteEndpoints(participant_data);\n    EPROSIMA_LOG_INFO(SECURITY, \"Participant \" << participant_data.m_guid << \" authenticated\");\n    if (participant_->getListener() != nullptr)\n    {\n        ParticipantAuthenticationInfo info;\n        info.status = ParticipantAuthenticationInfo::AUTHORIZED_PARTICIPANT;\n        info.guid = participant_data.m_guid;\n        participant_->getListener()->onParticipantAuthentication(\n            participant_->getUserRTPSParticipant(), std::move(info));\n    }\n}", "target": 1}
{"code": "int message_add_body_amqp_sequence(MESSAGE_HANDLE message, AMQP_VALUE sequence_list)\n{\n    int result;\n    if ((message == NULL) ||\n        (sequence_list == NULL))\n    {\n        LogError(\"Bad arguments: message = %p, sequence_list = %p\",\n            message, sequence_list);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        MESSAGE_BODY_TYPE body_type = internal_get_body_type(message);\n        if ((body_type == MESSAGE_BODY_TYPE_DATA) ||\n            (body_type == MESSAGE_BODY_TYPE_VALUE))\n        {\n            LogError(\"Body is already set to another body type\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            AMQP_VALUE* new_body_amqp_sequence_items = (AMQP_VALUE*)realloc(message->body_amqp_sequence_items, sizeof(AMQP_VALUE) * (message->body_amqp_sequence_count + 1));\n            if (new_body_amqp_sequence_items == NULL)\n            {\n                LogError(\"Cannot allocate enough memory for sequence items\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                message->body_amqp_sequence_items = new_body_amqp_sequence_items;\n                message->body_amqp_sequence_items[message->body_amqp_sequence_count] = amqpvalue_clone(sequence_list);\n                if (message->body_amqp_sequence_items[message->body_amqp_sequence_count] == NULL)\n                {\n                    LogError(\"Cloning sequence failed\");\n                    result = MU_FAILURE;\n                }\n                else\n                {\n                    message->body_amqp_sequence_count++;\n                    result = 0;\n                }\n            }\n        }\n    }\n    return result;\n}", "target": 1}
{"code": "static u32 zipfileGetTime(sqlite3_value *pVal){\n  if( pVal==0 || sqlite3_value_type(pVal)==SQLITE_NULL ){\n    return zipfileTime();\n  }\n  return (u32)sqlite3_value_int64(pVal);\n}", "target": 0}
{"code": "void js_throw(js_State *J)\n{\n\tif (J->trytop > 0) {\n\t\tjs_Value v = *stackidx(J, -1);\n\t\t--J->trytop;\n\t\tJ->E = J->trybuf[J->trytop].E;\n\t\tJ->envtop = J->trybuf[J->trytop].envtop;\n\t\tJ->tracetop = J->trybuf[J->trytop].tracetop;\n\t\tJ->top = J->trybuf[J->trytop].top;\n\t\tJ->bot = J->trybuf[J->trytop].bot;\n\t\tjs_pushvalue(J, v);\n\t\tlongjmp(J->trybuf[J->trytop].buf, 1);\n\t}\n\tif (J->panic)\n\t\tJ->panic(J);\n\tabort();\n}", "target": 0}
{"code": "static int cypress_generic_port_probe(struct usb_serial_port *port)\n{\n\tstruct usb_serial *serial = port->serial;\n\tstruct cypress_private *priv;\n\tif (!port->interrupt_out_urb || !port->interrupt_in_urb) {\n\t\tdev_err(&port->dev, \"required endpoint is missing\\n\");\n\t\treturn -ENODEV;\n\t}\n\tpriv = kzalloc(sizeof(struct cypress_private), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tpriv->comm_is_ok = !0;\n\tspin_lock_init(&priv->lock);\n\tif (kfifo_alloc(&priv->write_fifo, CYPRESS_BUF_SIZE, GFP_KERNEL)) {\n\t\tkfree(priv);\n\t\treturn -ENOMEM;\n\t}\n\tif (!is_frwd(serial->dev))\n\t\tusb_reset_configuration(serial->dev);\n\tpriv->cmd_ctrl = 0;\n\tpriv->line_control = 0;\n\tpriv->termios_initialized = 0;\n\tpriv->rx_flags = 0;\n\tif (port->interrupt_out_size > 9)\n\t\tpriv->pkt_fmt = packet_format_1;\n\telse\n\t\tpriv->pkt_fmt = packet_format_2;\n\tif (interval > 0) {\n\t\tpriv->write_urb_interval = interval;\n\t\tpriv->read_urb_interval = interval;\n\t\tdev_dbg(&port->dev, \"%s - read & write intervals forced to %d\\n\",\n\t\t\t__func__, interval);\n\t} else {\n\t\tpriv->write_urb_interval = port->interrupt_out_urb->interval;\n\t\tpriv->read_urb_interval = port->interrupt_in_urb->interval;\n\t\tdev_dbg(&port->dev, \"%s - intervals: read=%d write=%d\\n\",\n\t\t\t__func__, priv->read_urb_interval,\n\t\t\tpriv->write_urb_interval);\n\t}\n\tusb_set_serial_port_data(port, priv);\n\tport->port.drain_delay = 256;\n\treturn 0;\n}", "target": 0}
{"code": "htmlCtxtReset(htmlParserCtxtPtr ctxt)\n{\n    xmlParserInputPtr input;\n    xmlDictPtr dict;\n    if (ctxt == NULL)\n        return;\n    xmlInitParser();\n    dict = ctxt->dict;\n    while ((input = inputPop(ctxt)) != NULL) { \n        xmlFreeInputStream(input);\n    }\n    ctxt->inputNr = 0;\n    ctxt->input = NULL;\n    ctxt->spaceNr = 0;\n    if (ctxt->spaceTab != NULL) {\n\tctxt->spaceTab[0] = -1;\n\tctxt->space = &ctxt->spaceTab[0];\n    } else {\n\tctxt->space = NULL;\n    }\n    ctxt->nodeNr = 0;\n    ctxt->node = NULL;\n    ctxt->nameNr = 0;\n    ctxt->name = NULL;\n    DICT_FREE(ctxt->version);\n    ctxt->version = NULL;\n    DICT_FREE(ctxt->encoding);\n    ctxt->encoding = NULL;\n    DICT_FREE(ctxt->directory);\n    ctxt->directory = NULL;\n    DICT_FREE(ctxt->extSubURI);\n    ctxt->extSubURI = NULL;\n    DICT_FREE(ctxt->extSubSystem);\n    ctxt->extSubSystem = NULL;\n    if (ctxt->myDoc != NULL)\n        xmlFreeDoc(ctxt->myDoc);\n    ctxt->myDoc = NULL;\n    ctxt->standalone = -1;\n    ctxt->hasExternalSubset = 0;\n    ctxt->hasPErefs = 0;\n    ctxt->html = 1;\n    ctxt->external = 0;\n    ctxt->instate = XML_PARSER_START;\n    ctxt->token = 0;\n    ctxt->wellFormed = 1;\n    ctxt->nsWellFormed = 1;\n    ctxt->disableSAX = 0;\n    ctxt->valid = 1;\n    ctxt->vctxt.userData = ctxt;\n    ctxt->vctxt.error = xmlParserValidityError;\n    ctxt->vctxt.warning = xmlParserValidityWarning;\n    ctxt->record_info = 0;\n    ctxt->nbChars = 0;\n    ctxt->checkIndex = 0;\n    ctxt->inSubset = 0;\n    ctxt->errNo = XML_ERR_OK;\n    ctxt->depth = 0;\n    ctxt->charset = XML_CHAR_ENCODING_NONE;\n    ctxt->catalogs = NULL;\n    xmlInitNodeInfoSeq(&ctxt->node_seq);\n    if (ctxt->attsDefault != NULL) {\n        xmlHashFree(ctxt->attsDefault, xmlHashDefaultDeallocator);\n        ctxt->attsDefault = NULL;\n    }\n    if (ctxt->attsSpecial != NULL) {\n        xmlHashFree(ctxt->attsSpecial, NULL);\n        ctxt->attsSpecial = NULL;\n    }\n}", "target": 0}
{"code": "void show_object_with_name(FILE *out, struct object *obj,\n\t\t\t   struct strbuf *path, const char *component)\n{\n\tchar *name = path_name(path, component);\n\tchar *p;\n\tfprintf(out, \"%s \", oid_to_hex(&obj->oid));\n\tfor (p = name; *p && *p != '\\n'; p++)\n\t\tfputc(*p, out);\n\tfputc('\\n', out);\n\tfree(name);\n}", "target": 1}
{"code": "rb_remove_pages(struct ring_buffer_per_cpu *cpu_buffer, unsigned long nr_pages)\n{\n\tstruct list_head *tail_page, *to_remove, *next_page;\n\tstruct buffer_page *to_remove_page, *tmp_iter_page;\n\tstruct buffer_page *last_page, *first_page;\n\tunsigned long nr_removed;\n\tunsigned long head_bit;\n\tint page_entries;\n\thead_bit = 0;\n\traw_spin_lock_irq(&cpu_buffer->reader_lock);\n\tatomic_inc(&cpu_buffer->record_disabled);\n\ttail_page = &cpu_buffer->tail_page->list;\n\tif (cpu_buffer->tail_page == cpu_buffer->reader_page)\n\t\ttail_page = rb_list_head(tail_page->next);\n\tto_remove = tail_page;\n\tfirst_page = list_entry(rb_list_head(to_remove->next),\n\t\t\t\tstruct buffer_page, list);\n\tfor (nr_removed = 0; nr_removed < nr_pages; nr_removed++) {\n\t\tto_remove = rb_list_head(to_remove)->next;\n\t\thead_bit |= (unsigned long)to_remove & RB_PAGE_HEAD;\n\t}\n\tnext_page = rb_list_head(to_remove)->next;\n\ttail_page->next = (struct list_head *)((unsigned long)next_page |\n\t\t\t\t\t\thead_bit);\n\tnext_page = rb_list_head(next_page);\n\tnext_page->prev = tail_page;\n\tcpu_buffer->pages = next_page;\n\tif (head_bit)\n\t\tcpu_buffer->head_page = list_entry(next_page,\n\t\t\t\t\t\tstruct buffer_page, list);\n\tcpu_buffer->read = 0;\n\tatomic_dec(&cpu_buffer->record_disabled);\n\traw_spin_unlock_irq(&cpu_buffer->reader_lock);\n\tRB_WARN_ON(cpu_buffer, list_empty(cpu_buffer->pages));\n\tlast_page = list_entry(rb_list_head(to_remove), struct buffer_page,\n\t\t\t\tlist);\n\ttmp_iter_page = first_page;\n\tdo {\n\t\tto_remove_page = tmp_iter_page;\n\t\trb_inc_page(cpu_buffer, &tmp_iter_page);\n\t\tpage_entries = rb_page_entries(to_remove_page);\n\t\tif (page_entries) {\n\t\t\tlocal_add(page_entries, &cpu_buffer->overrun);\n\t\t\tlocal_sub(BUF_PAGE_SIZE, &cpu_buffer->entries_bytes);\n\t\t}\n\t\tfree_buffer_page(to_remove_page);\n\t\tnr_removed--;\n\t} while (to_remove_page != last_page);\n\tRB_WARN_ON(cpu_buffer, nr_removed);\n\treturn nr_removed == 0;\n}", "target": 0}
{"code": "static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p,\n\tstruct user_namespace *user_ns)\n{\n\tmm->mmap = NULL;\n\tmm->mm_rb = RB_ROOT;\n\tmm->vmacache_seqnum = 0;\n\tatomic_set(&mm->mm_users, 1);\n\tatomic_set(&mm->mm_count, 1);\n\tinit_rwsem(&mm->mmap_sem);\n\tINIT_LIST_HEAD(&mm->mmlist);\n\tmm->core_state = NULL;\n\tatomic_long_set(&mm->nr_ptes, 0);\n\tmm_nr_pmds_init(mm);\n\tmm->map_count = 0;\n\tmm->locked_vm = 0;\n\tmm->pinned_vm = 0;\n\tmemset(&mm->rss_stat, 0, sizeof(mm->rss_stat));\n\tspin_lock_init(&mm->page_table_lock);\n\tmm_init_cpumask(mm);\n\tmm_init_aio(mm);\n\tmm_init_owner(mm, p);\n\tRCU_INIT_POINTER(mm->exe_file, NULL);\n\tmmu_notifier_mm_init(mm);\n\tinit_tlb_flush_pending(mm);\n#if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS\n\tmm->pmd_huge_pte = NULL;\n#endif\n\tmm_init_uprobes_state(mm);\n\tif (current->mm) {\n\t\tmm->flags = current->mm->flags & MMF_INIT_MASK;\n\t\tmm->def_flags = current->mm->def_flags & VM_INIT_DEF_MASK;\n\t} else {\n\t\tmm->flags = default_dump_filter;\n\t\tmm->def_flags = 0;\n\t}\n\tif (mm_alloc_pgd(mm))\n\t\tgoto fail_nopgd;\n\tif (init_new_context(p, mm))\n\t\tgoto fail_nocontext;\n\tmm->user_ns = get_user_ns(user_ns);\n\treturn mm;\nfail_nocontext:\n\tmm_free_pgd(mm);\nfail_nopgd:\n\tfree_mm(mm);\n\treturn NULL;\n}", "target": 0}
{"code": "handle_keywordonly_args(struct compiling *c, const node *n, int start,\n                        asdl_seq *kwonlyargs, asdl_seq *kwdefaults)\n{\n    PyObject *argname;\n    node *ch;\n    expr_ty expression, annotation;\n    arg_ty arg;\n    int i = start;\n    int j = 0; \n    if (kwonlyargs == NULL) {\n        ast_error(c, CHILD(n, start), \"named arguments must follow bare *\");\n        return -1;\n    }\n    assert(kwdefaults != NULL);\n    while (i < NCH(n)) {\n        ch = CHILD(n, i);\n        switch (TYPE(ch)) {\n            case vfpdef:\n            case tfpdef:\n                if (i + 1 < NCH(n) && TYPE(CHILD(n, i + 1)) == EQUAL) {\n                    expression = ast_for_expr(c, CHILD(n, i + 2));\n                    if (!expression)\n                        goto error;\n                    asdl_seq_SET(kwdefaults, j, expression);\n                    i += 2; \n                }\n                else { \n                    asdl_seq_SET(kwdefaults, j, NULL);\n                }\n                if (NCH(ch) == 3) {\n                    annotation = ast_for_expr(c, CHILD(ch, 2));\n                    if (!annotation)\n                        goto error;\n                }\n                else {\n                    annotation = NULL;\n                }\n                ch = CHILD(ch, 0);\n                argname = NEW_IDENTIFIER(ch);\n                if (!argname)\n                    goto error;\n                if (forbidden_name(c, argname, ch, 0))\n                    goto error;\n                arg = arg(argname, annotation, LINENO(ch), ch->n_col_offset,\n                          ch->n_end_lineno, ch->n_end_col_offset,\n                          c->c_arena);\n                if (!arg)\n                    goto error;\n                asdl_seq_SET(kwonlyargs, j++, arg);\n                i += 2; \n                break;\n            case DOUBLESTAR:\n                return i;\n            default:\n                ast_error(c, ch, \"unexpected node\");\n                goto error;\n        }\n    }\n    return i;\n error:\n    return -1;\n}", "target": 1}
{"code": "xmlCreateMemoryParserCtxt(const char *buffer, int size) {\n    xmlParserCtxtPtr ctxt;\n    xmlParserInputPtr input;\n    xmlParserInputBufferPtr buf;\n    if (buffer == NULL)\n\treturn(NULL);\n    if (size <= 0)\n\treturn(NULL);\n    ctxt = xmlNewParserCtxt();\n    if (ctxt == NULL)\n\treturn(NULL);\n    buf = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);\n    if (buf == NULL) {\n\txmlFreeParserCtxt(ctxt);\n\treturn(NULL);\n    }\n    input = xmlNewInputStream(ctxt);\n    if (input == NULL) {\n\txmlFreeParserInputBuffer(buf);\n\txmlFreeParserCtxt(ctxt);\n\treturn(NULL);\n    }\n    input->filename = NULL;\n    input->buf = buf;\n    xmlBufResetInput(input->buf->buffer, input);\n    inputPush(ctxt, input);\n    return(ctxt);\n}", "target": 0}
{"code": "ssh_packet_set_compress_hooks(struct ssh *ssh, void *ctx,\n    void *(*allocfunc)(void *, u_int, u_int),\n    void (*freefunc)(void *, void *))\n{\n\tssh->state->compression_out_stream.zalloc = (alloc_func)allocfunc;\n\tssh->state->compression_out_stream.zfree = (free_func)freefunc;\n\tssh->state->compression_out_stream.opaque = ctx;\n\tssh->state->compression_in_stream.zalloc = (alloc_func)allocfunc;\n\tssh->state->compression_in_stream.zfree = (free_func)freefunc;\n\tssh->state->compression_in_stream.opaque = ctx;\n}", "target": 1}
{"code": "int gnutls_x509_ext_import_subject_alt_names(const gnutls_datum_t * ext,\n\t\t\t\t\t  gnutls_subject_alt_names_t sans,\n\t\t\t\t\t  unsigned int flags)\n{\n\tASN1_TYPE c2 = ASN1_TYPE_EMPTY;\n\tint result, ret;\n\tunsigned int i;\n\tgnutls_datum_t san, othername_oid;\n\tunsigned type;\n\tresult =\n\t    asn1_create_element(_gnutls_get_pkix(), \"PKIX1.GeneralNames\", &c2);\n\tif (result != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\treturn _gnutls_asn2err(result);\n\t}\n\tresult = asn1_der_decoding(&c2, ext->data, ext->size, NULL);\n\tif (result != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\tret = _gnutls_asn2err(result);\n\t\tgoto cleanup;\n\t}\n\ti = 0;\n\tdo {\n\t\tsan.data = NULL;\n\t\tsan.size = 0;\n\t\tothername_oid.data = NULL;\n\t\tret = _gnutls_parse_general_name2(c2, \"\", i, &san, &type, 0);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (type == GNUTLS_SAN_OTHERNAME) {\n\t\t\tret =\n\t\t\t    _gnutls_parse_general_name2(c2, \"\", i,\n\t\t\t\t\t\t\t&othername_oid,\n\t\t\t\t\t\t\tNULL, 1);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t} else if (san.size == 0 || san.data == NULL) {\n\t\t\tret = gnutls_assert_val(GNUTLS_E_X509_UNKNOWN_SAN);\n\t\t\tbreak;\n\t\t}\n\t\tret = subject_alt_names_set(&sans->names, &sans->size,\n\t\t\t\t\t    type, &san,\n\t\t\t\t\t    (char *)othername_oid.data);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\ti++;\n\t} while (ret >= 0);\n\tsans->size = i;\n\tif (ret < 0 && ret != GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE) {\n\t\tgnutls_free(san.data);\n\t\tgnutls_free(othername_oid.data);\n\t\tgnutls_assert();\n\t\tgoto cleanup;\n\t}\n\tret = 0;\n cleanup:\n\tasn1_delete_structure(&c2);\n\treturn ret;\n}", "target": 0}
{"code": "static void addrconf_dev_config(struct net_device *dev)\n{\n\tstruct in6_addr addr;\n\tstruct inet6_dev *idev;\n\tASSERT_RTNL();\n\tif ((dev->type != ARPHRD_ETHER) &&\n\t    (dev->type != ARPHRD_FDDI) &&\n\t    (dev->type != ARPHRD_ARCNET) &&\n\t    (dev->type != ARPHRD_INFINIBAND) &&\n\t    (dev->type != ARPHRD_IEEE802154) &&\n\t    (dev->type != ARPHRD_IEEE1394)) {\n\t\treturn;\n\t}\n\tidev = addrconf_add_dev(dev);\n\tif (IS_ERR(idev))\n\t\treturn;\n\tmemset(&addr, 0, sizeof(struct in6_addr));\n\taddr.s6_addr32[0] = htonl(0xFE800000);\n\tif (ipv6_generate_eui64(addr.s6_addr + 8, dev) == 0)\n\t\taddrconf_add_linklocal(idev, &addr);\n}", "target": 0}
{"code": "static int snd_seq_ioctl_remove_events(struct snd_seq_client *client,\n\t\t\t\t       void __user *arg)\n{\n\tstruct snd_seq_remove_events info;\n\tif (copy_from_user(&info, arg, sizeof(info)))\n\t\treturn -EFAULT;\n\tif (info.remove_mode & SNDRV_SEQ_REMOVE_INPUT) {\n\t\tif (client->type == USER_CLIENT)\n\t\t\tsnd_seq_fifo_clear(client->data.user.fifo);\n\t}\n\tif (info.remove_mode & SNDRV_SEQ_REMOVE_OUTPUT)\n\t\tsnd_seq_queue_remove_cells(client->number, &info);\n\treturn 0;\n}", "target": 1}
{"code": "static inline void crst_table_init(unsigned long *crst, unsigned long entry)\n{\n\tclear_table(crst, entry, sizeof(unsigned long)*2048);\n}", "target": 0}
{"code": "lys_restr_dup(struct lys_module *mod, struct lys_restr *old, int size, int shallow, struct unres_schema *unres)\n{\n    struct lys_restr *result;\n    int i;\n    if (!size) {\n        return NULL;\n    }\n    result = calloc(size, sizeof *result);\n    LY_CHECK_ERR_RETURN(!result, LOGMEM(mod->ctx), NULL);\n    for (i = 0; i < size; i++) {\n        result[i].ext_size = old[i].ext_size;\n        lys_ext_dup(mod->ctx, mod, old[i].ext, old[i].ext_size, &result[i], LYEXT_PAR_RESTR, &result[i].ext, shallow, unres);\n        result[i].expr = lydict_insert(mod->ctx, old[i].expr, 0);\n        result[i].dsc = lydict_insert(mod->ctx, old[i].dsc, 0);\n        result[i].ref = lydict_insert(mod->ctx, old[i].ref, 0);\n        result[i].eapptag = lydict_insert(mod->ctx, old[i].eapptag, 0);\n        result[i].emsg = lydict_insert(mod->ctx, old[i].emsg, 0);\n    }\n    return result;\n}", "target": 1}
{"code": "static bool parse_namemap(RBuffer *b, ut64 bound, RIDStorage *map, ut32 *count) {\n\tsize_t i;\n\tif (!consume_u32_r (b, bound, count)) {\n\t\treturn false;\n\t}\n\tfor (i = 0; i < *count; i++) {\n\t\tut32 idx;\n\t\tif (!consume_u32_r (b, bound, &idx)) {\n\t\t\treturn false;\n\t\t}\n\t\tchar *name = NULL;\n\t\tif (!consume_encoded_name_new (b, bound, NULL, &name)) {\n\t\t\tR_FREE (name);\n\t\t\treturn false;\n\t\t}\n\t\tif (!r_id_storage_add (map, name, &idx)) {\n\t\t\tR_FREE (name);\n\t\t\treturn false;\n\t\t};\n\t}\n\treturn true;\n}", "target": 0}
{"code": "smb_flush_file(struct smb_request *sr, struct smb_ofile *ofile)\n{\n\tsr->user_cr = smb_ofile_getcred(ofile);\n\tif ((ofile->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)\n\t\t(void) smb_fsop_commit(sr, sr->user_cr, ofile->f_node);\n}", "target": 1}
{"code": "unsigned LibRaw::get4()\n{\n  uchar str[4] = {0xff, 0xff, 0xff, 0xff};\n  fread(str, 1, 4, ifp);\n  return sget4(str);\n}", "target": 0}
{"code": "  explicit UnravelIndexOp(OpKernelConstruction* ctx) : OpKernel(ctx) {}", "target": 1}
{"code": "void pushGenericCommand(client *c, int where) {\n    int j, pushed = 0;\n    for (j = 2; j < c->argc; j++) {\n        if (sdslen(c->argv[j]->ptr) > LIST_MAX_ITEM_SIZE) {\n            addReplyError(c, \"Element too large\");\n            return;\n        }\n    }\n    robj *lobj = lookupKeyWrite(c->db,c->argv[1]);\n    if (lobj && lobj->type != OBJ_LIST) {\n        addReply(c,shared.wrongtypeerr);\n        return;\n    }\n    for (j = 2; j < c->argc; j++) {\n        if (!lobj) {\n            lobj = createQuicklistObject();\n            quicklistSetOptions(lobj->ptr, server.list_max_ziplist_size,\n                                server.list_compress_depth);\n            dbAdd(c->db,c->argv[1],lobj);\n        }\n        listTypePush(lobj,c->argv[j],where);\n        pushed++;\n    }\n    addReplyLongLong(c, (lobj ? listTypeLength(lobj) : 0));\n    if (pushed) {\n        char *event = (where == LIST_HEAD) ? \"lpush\" : \"rpush\";\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_LIST,event,c->argv[1],c->db->id);\n    }\n    server.dirty += pushed;\n}", "target": 0}
{"code": "static ptrdiff_t finderrfunc(lua_State *L)\n{\n  cTValue *frame = L->base-1, *bot = tvref(L->stack);\n  void *cf = L->cframe;\n  while (frame > bot && cf) {\n    while (cframe_nres(cframe_raw(cf)) < 0) {  \n      if (frame >= restorestack(L, -cframe_nres(cf)))\n\tbreak;\n      if (cframe_errfunc(cf) >= 0)  \n\treturn cframe_errfunc(cf);\n      cf = cframe_prev(cf);  \n      if (cf == NULL)\n\treturn 0;\n    }\n    switch (frame_typep(frame)) {\n    case FRAME_LUA:\n    case FRAME_LUAP:\n      frame = frame_prevl(frame);\n      break;\n    case FRAME_C:\n      cf = cframe_prev(cf);\n    case FRAME_VARG:\n      frame = frame_prevd(frame);\n      break;\n    case FRAME_CONT:\n#if LJ_HASFFI\n      if ((frame-1)->u32.lo == LJ_CONT_FFI_CALLBACK)\n\tcf = cframe_prev(cf);\n#endif\n      frame = frame_prevd(frame);\n      break;\n    case FRAME_CP:\n      if (cframe_canyield(cf)) return 0;\n      if (cframe_errfunc(cf) >= 0)\n\treturn cframe_errfunc(cf);\n      frame = frame_prevd(frame);\n      break;\n    case FRAME_PCALL:\n    case FRAME_PCALLH:\n      if (frame_ftsz(frame) >= (ptrdiff_t)(2*sizeof(TValue)))  \n\treturn savestack(L, frame-1);  \n      return 0;\n    default:\n      lua_assert(0);\n      return 0;\n    }\n  }\n  return 0;\n}", "target": 1}
{"code": "static int ext4_commit_super(struct super_block *sb, int sync)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tstruct buffer_head *sbh = EXT4_SB(sb)->s_sbh;\n\tint error = 0;\n\tif (!sbh || block_device_ejected(sb))\n\t\treturn error;\n\tif (buffer_write_io_error(sbh)) {\n\t\text4_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tif (sb->s_bdev->bd_part)\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written +\n\t\t\t    ((part_stat_read(sb->s_bdev->bd_part, sectors[1]) -\n\t\t\t      EXT4_SB(sb)->s_sectors_written_start) >> 1));\n\telse\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written);\n\text4_free_blocks_count_set(es,\n\t\t\tEXT4_C2B(EXT4_SB(sb), percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeclusters_counter)));\n\tes->s_free_inodes_count =\n\t\tcpu_to_le32(percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeinodes_counter));\n\tsb->s_dirt = 0;\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\text4_superblock_csum_set(sb, es);\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = buffer_write_io_error(sbh);\n\t\tif (error) {\n\t\t\text4_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}", "target": 0}
{"code": "is_empty(const uint8_t *data, size_t size)\n{\n\tsize_t i;\n\tfor (i = 0; i < size && data[i] != '\\n'; i++)\n\t\tif (data[i] != ' ')\n\t\t\treturn 0;\n\treturn i + 1;\n}", "target": 0}
{"code": "static int btrfs_add_system_chunk(struct btrfs_fs_info *fs_info,\n\t\t\t   struct btrfs_key *key,\n\t\t\t   struct btrfs_chunk *chunk, int item_size)\n{\n\tstruct btrfs_super_block *super_copy = fs_info->super_copy;\n\tstruct btrfs_disk_key disk_key;\n\tu32 array_size;\n\tu8 *ptr;\n\tmutex_lock(&fs_info->chunk_mutex);\n\tarray_size = btrfs_super_sys_array_size(super_copy);\n\tif (array_size + item_size + sizeof(disk_key)\n\t\t\t> BTRFS_SYSTEM_CHUNK_ARRAY_SIZE) {\n\t\tmutex_unlock(&fs_info->chunk_mutex);\n\t\treturn -EFBIG;\n\t}\n\tptr = super_copy->sys_chunk_array + array_size;\n\tbtrfs_cpu_key_to_disk(&disk_key, key);\n\tmemcpy(ptr, &disk_key, sizeof(disk_key));\n\tptr += sizeof(disk_key);\n\tmemcpy(ptr, chunk, item_size);\n\titem_size += sizeof(disk_key);\n\tbtrfs_set_super_sys_array_size(super_copy, array_size + item_size);\n\tmutex_unlock(&fs_info->chunk_mutex);\n\treturn 0;\n}", "target": 0}
{"code": "nfs4_atomic_open(struct inode *dir, struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct path path = {\n\t\t.mnt = nd->path.mnt,\n\t\t.dentry = dentry,\n\t};\n\tstruct dentry *parent;\n\tstruct iattr attr;\n\tstruct rpc_cred *cred;\n\tstruct nfs4_state *state;\n\tstruct dentry *res;\n\tif (nd->flags & LOOKUP_CREATE) {\n\t\tattr.ia_mode = nd->intent.open.create_mode;\n\t\tattr.ia_valid = ATTR_MODE;\n\t\tif (!IS_POSIXACL(dir))\n\t\t\tattr.ia_mode &= ~current->fs->umask;\n\t} else {\n\t\tattr.ia_valid = 0;\n\t\tBUG_ON(nd->intent.open.flags & O_CREAT);\n\t}\n\tcred = rpc_lookup_cred();\n\tif (IS_ERR(cred))\n\t\treturn (struct dentry *)cred;\n\tparent = dentry->d_parent;\n\tnfs_block_sillyrename(parent);\n\tstate = nfs4_do_open(dir, &path, nd->intent.open.flags, &attr, cred);\n\tput_rpccred(cred);\n\tif (IS_ERR(state)) {\n\t\tif (PTR_ERR(state) == -ENOENT) {\n\t\t\td_add(dentry, NULL);\n\t\t\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\t\t}\n\t\tnfs_unblock_sillyrename(parent);\n\t\treturn (struct dentry *)state;\n\t}\n\tres = d_add_unique(dentry, igrab(state->inode));\n\tif (res != NULL)\n\t\tpath.dentry = res;\n\tnfs_set_verifier(path.dentry, nfs_save_change_attribute(dir));\n\tnfs_unblock_sillyrename(parent);\n\tnfs4_intent_set_file(nd, &path, state);\n\treturn res;\n}", "target": 1}
{"code": "static void nlmclnt_unlock_callback(struct rpc_task *task, void *data)\n{\n\tstruct nlm_rqst\t*req = data;\n\tu32 status = ntohl(req->a_res.status);\n\tif (RPC_ASSASSINATED(task))\n\t\tgoto die;\n\tif (task->tk_status < 0) {\n\t\tdprintk(\"lockd: unlock failed (err = %d)\\n\", -task->tk_status);\n\t\tgoto retry_rebind;\n\t}\n\tif (status == NLM_LCK_DENIED_GRACE_PERIOD) {\n\t\trpc_delay(task, NLMCLNT_GRACE_WAIT);\n\t\tgoto retry_unlock;\n\t}\n\tif (status != NLM_LCK_GRANTED)\n\t\tprintk(KERN_WARNING \"lockd: unexpected unlock status: %d\\n\", status);\ndie:\n\treturn;\n retry_rebind:\n\tnlm_rebind_host(req->a_host);\n retry_unlock:\n\trpc_restart_call(task);\n}", "target": 1}
{"code": "static inline int process_nested_data(UNSERIALIZE_PARAMETER, HashTable *ht, long elements, int objprops)\n{\n\twhile (elements-- > 0) {\n\t\tzval *key, *data, **old_data;\n\t\tALLOC_INIT_ZVAL(key);\n\t\tif (!php_var_unserialize(&key, p, max, NULL TSRMLS_CC)) {\n\t\t\tzval_dtor(key);\n\t\t\tFREE_ZVAL(key);\n\t\t\treturn 0;\n\t\t}\n\t\tif (Z_TYPE_P(key) != IS_LONG && Z_TYPE_P(key) != IS_STRING) {\n\t\t\tzval_dtor(key);\n\t\t\tFREE_ZVAL(key);\n\t\t\treturn 0;\n\t\t}\n\t\tALLOC_INIT_ZVAL(data);\n\t\tif (!php_var_unserialize(&data, p, max, var_hash TSRMLS_CC)) {\n\t\t\tzval_dtor(key);\n\t\t\tFREE_ZVAL(key);\n\t\t\tzval_dtor(data);\n\t\t\tFREE_ZVAL(data);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!objprops) {\n\t\t\tswitch (Z_TYPE_P(key)) {\n\t\t\tcase IS_LONG:\n\t\t\t\tif (zend_hash_index_find(ht, Z_LVAL_P(key), (void **)&old_data)==SUCCESS) {\n\t\t\t\t\tvar_push_dtor(var_hash, old_data);\n\t\t\t\t}\n\t\t\t\tzend_hash_index_update(ht, Z_LVAL_P(key), &data, sizeof(data), NULL);\n\t\t\t\tbreak;\n\t\t\tcase IS_STRING:\n\t\t\t\tif (zend_symtable_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) {\n\t\t\t\t\tvar_push_dtor(var_hash, old_data);\n\t\t\t\t}\n\t\t\t\tzend_symtable_update(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, &data, sizeof(data), NULL);\n\t\t\t\tbreak;\n\t\t\t}\n                } else {\n                        convert_to_string(key);\n                       if (zend_symtable_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) {\n                               var_push_dtor(var_hash, old_data);\n                       }\n                        zend_hash_update(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, &data,\n                                        sizeof data, NULL);\n                }\n\t\tif (elements && *(*p-1) != ';' && *(*p-1) != '}') {\n\t\t\t(*p)--;\n\t\t\treturn 0;\n\t\t}\n\t}", "target": 0}
{"code": "static int prepare_func_exit(struct bpf_verifier_env *env, int *insn_idx)\n{\n\tstruct bpf_verifier_state *state = env->cur_state;\n\tstruct bpf_func_state *caller, *callee;\n\tstruct bpf_reg_state *r0;\n\tint err;\n\tcallee = state->frame[state->curframe];\n\tr0 = &callee->regs[BPF_REG_0];\n\tif (r0->type == PTR_TO_STACK) {\n\t\tverbose(env, \"cannot return stack pointer to the caller\\n\");\n\t\treturn -EINVAL;\n\t}\n\tstate->curframe--;\n\tcaller = state->frame[state->curframe];\n\tif (callee->in_callback_fn) {\n\t\tstruct tnum range = tnum_range(0, 1);\n\t\tif (r0->type != SCALAR_VALUE) {\n\t\t\tverbose(env, \"R0 not a scalar value\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (!tnum_in(range, r0->var_off)) {\n\t\t\tverbose_invalid_scalar(env, r0, &range, \"callback return\", \"R0\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tcaller->regs[BPF_REG_0] = *r0;\n\t}\n\terr = copy_reference_state(caller, callee);\n\tif (err)\n\t\treturn err;\n\t*insn_idx = callee->callsite + 1;\n\tif (env->log.level & BPF_LOG_LEVEL) {\n\t\tverbose(env, \"returning from callee:\\n\");\n\t\tprint_verifier_state(env, callee, true);\n\t\tverbose(env, \"to caller at %d:\\n\", *insn_idx);\n\t\tprint_verifier_state(env, caller, true);\n\t}\n\tfree_func_state(callee);\n\tstate->frame[state->curframe + 1] = NULL;\n\treturn 0;\n}", "target": 0}
{"code": "static FILE * pw_tmpfile(int lockfd)\n{\n\tFILE *fd;\n\tchar *tmpname = NULL;\n\tchar *dir = \"/etc\";\n\tif ((fd = xfmkstemp(&tmpname, dir)) == NULL) {\n\t\tulckpwdf();\n\t\terr(EXIT_FAILURE, _(\"can't open temporary file\"));\n\t}\n\tcopyfile(lockfd, fileno(fd));\n\ttmp_file = tmpname;\n\treturn fd;\n}", "target": 1}
{"code": "static int f2fs_set_data_page_dirty(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode = mapping->host;\n\ttrace_f2fs_set_page_dirty(page, DATA);\n\tif (!PageUptodate(page))\n\t\tSetPageUptodate(page);\n\tif (f2fs_is_atomic_file(inode) && !f2fs_is_commit_atomic_write(inode)) {\n\t\tif (!IS_ATOMIC_WRITTEN_PAGE(page)) {\n\t\t\tf2fs_register_inmem_page(inode, page);\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (!PageDirty(page)) {\n\t\t__set_page_dirty_nobuffers(page);\n\t\tf2fs_update_dirty_page(inode, page);\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "ieee80211_rx_h_check(struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)rx->skb->data;\n\tif (ieee80211_vif_is_mesh(&rx->sdata->vif))\n\t\treturn ieee80211_rx_mesh_check(rx);\n\tif (unlikely((ieee80211_is_data(hdr->frame_control) ||\n\t\t      ieee80211_is_pspoll(hdr->frame_control)) &&\n\t\t     rx->sdata->vif.type != NL80211_IFTYPE_ADHOC &&\n\t\t     rx->sdata->vif.type != NL80211_IFTYPE_WDS &&\n\t\t     rx->sdata->vif.type != NL80211_IFTYPE_OCB &&\n\t\t     (!rx->sta || !test_sta_flag(rx->sta, WLAN_STA_ASSOC)))) {\n\t\tif (rx->sta && rx->sdata->vif.type == NL80211_IFTYPE_STATION &&\n\t\t    ieee80211_is_data_present(hdr->frame_control)) {\n\t\t\tunsigned int hdrlen;\n\t\t\t__be16 ethertype;\n\t\t\thdrlen = ieee80211_hdrlen(hdr->frame_control);\n\t\t\tif (rx->skb->len < hdrlen + 8)\n\t\t\t\treturn RX_DROP_MONITOR;\n\t\t\tskb_copy_bits(rx->skb, hdrlen + 6, &ethertype, 2);\n\t\t\tif (ethertype == rx->sdata->control_port_protocol)\n\t\t\t\treturn RX_CONTINUE;\n\t\t}\n\t\tif (rx->sdata->vif.type == NL80211_IFTYPE_AP &&\n\t\t    cfg80211_rx_spurious_frame(rx->sdata->dev,\n\t\t\t\t\t       hdr->addr2,\n\t\t\t\t\t       GFP_ATOMIC))\n\t\t\treturn RX_DROP_UNUSABLE;\n\t\treturn RX_DROP_MONITOR;\n\t}\n\treturn RX_CONTINUE;\n}", "target": 0}
{"code": "BOOL license_read_product_info(wStream* s, PRODUCT_INFO* productInfo)\n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\tStream_Read_UINT32(s, productInfo->dwVersion); \n\tStream_Read_UINT32(s, productInfo->cbCompanyName); \n\tif (Stream_GetRemainingLength(s) < productInfo->cbCompanyName + 4)\n\t\treturn FALSE;\n\tproductInfo->pbCompanyName = (BYTE*) malloc(productInfo->cbCompanyName);\n\tStream_Read(s, productInfo->pbCompanyName, productInfo->cbCompanyName);\n\tStream_Read_UINT32(s, productInfo->cbProductId); \n\tif (Stream_GetRemainingLength(s) < productInfo->cbProductId)\n\t{\n\t\tfree(productInfo->pbCompanyName);\n\t\tproductInfo->pbCompanyName = NULL;\n\t\treturn FALSE;\n\t}\n\tproductInfo->pbProductId = (BYTE*) malloc(productInfo->cbProductId);\n\tStream_Read(s, productInfo->pbProductId, productInfo->cbProductId);\n\treturn TRUE;\n}", "target": 0}
{"code": "static ssize_t read_kmem(struct file *file, char __user *buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tunsigned long p = *ppos;\n\tssize_t low_count, read, sz;\n\tchar *kbuf; \n\tint err = 0;\n\tread = 0;\n\tif (p < (unsigned long) high_memory) {\n\t\tlow_count = count;\n\t\tif (count > (unsigned long)high_memory - p)\n\t\t\tlow_count = (unsigned long)high_memory - p;\n#ifdef __ARCH_HAS_NO_PAGE_ZERO_MAPPED\n\t\tif (p < PAGE_SIZE && low_count > 0) {\n\t\t\tsz = size_inside_page(p, low_count);\n\t\t\tif (clear_user(buf, sz))\n\t\t\t\treturn -EFAULT;\n\t\t\tbuf += sz;\n\t\t\tp += sz;\n\t\t\tread += sz;\n\t\t\tlow_count -= sz;\n\t\t\tcount -= sz;\n\t\t}\n#endif\n\t\twhile (low_count > 0) {\n\t\t\tsz = size_inside_page(p, low_count);\n\t\t\tkbuf = xlate_dev_kmem_ptr((void *)p);\n\t\t\tif (!virt_addr_valid(kbuf))\n\t\t\t\treturn -ENXIO;\n\t\t\tif (copy_to_user(buf, kbuf, sz))\n\t\t\t\treturn -EFAULT;\n\t\t\tbuf += sz;\n\t\t\tp += sz;\n\t\t\tread += sz;\n\t\t\tlow_count -= sz;\n\t\t\tcount -= sz;\n\t\t}\n\t}\n\tif (count > 0) {\n\t\tkbuf = (char *)__get_free_page(GFP_KERNEL);\n\t\tif (!kbuf)\n\t\t\treturn -ENOMEM;\n\t\twhile (count > 0) {\n\t\t\tsz = size_inside_page(p, count);\n\t\t\tif (!is_vmalloc_or_module_addr((void *)p)) {\n\t\t\t\terr = -ENXIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsz = vread(kbuf, (char *)p, sz);\n\t\t\tif (!sz)\n\t\t\t\tbreak;\n\t\t\tif (copy_to_user(buf, kbuf, sz)) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount -= sz;\n\t\t\tbuf += sz;\n\t\t\tread += sz;\n\t\t\tp += sz;\n\t\t}\n\t\tfree_page((unsigned long)kbuf);\n\t}\n\t*ppos = p;\n\treturn read ? read : err;\n}", "target": 0}
{"code": "static void xen_irq_lateeoi_locked(struct irq_info *info)\n{\n\tevtchn_port_t evtchn;\n\tevtchn = info->evtchn;\n\tif (!VALID_EVTCHN(evtchn))\n\t\treturn;\n\tunmask_evtchn(evtchn);\n}", "target": 1}
{"code": "static int mov_read_SA3D(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    int i, version, type;\n    int ambisonic_order, channel_order, normalization, channel_count;\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams - 1];\n    if (atom.size < 16) {\n        av_log(c->fc, AV_LOG_ERROR, \"SA3D audio box too small\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    version = avio_r8(pb);\n    if (version) {\n        av_log(c->fc, AV_LOG_WARNING, \"Unsupported SA3D box version %d\\n\", version);\n        return 0;\n    }\n    type = avio_r8(pb);\n    if (type) {\n        av_log(c->fc, AV_LOG_WARNING,\n               \"Unsupported ambisonic type %d\\n\", type);\n        return 0;\n    }\n    ambisonic_order = avio_rb32(pb);\n    channel_order = avio_r8(pb);\n    if (channel_order) {\n        av_log(c->fc, AV_LOG_WARNING,\n               \"Unsupported channel_order %d\\n\", channel_order);\n        return 0;\n    }\n    normalization = avio_r8(pb);\n    if (normalization) {\n        av_log(c->fc, AV_LOG_WARNING,\n               \"Unsupported normalization %d\\n\", normalization);\n        return 0;\n    }\n    channel_count = avio_rb32(pb);\n    if (ambisonic_order < 0 || channel_count != (ambisonic_order + 1LL) * (ambisonic_order + 1LL)) {\n        av_log(c->fc, AV_LOG_ERROR,\n               \"Invalid number of channels (%d / %d)\\n\",\n               channel_count, ambisonic_order);\n        return 0;\n    }\n    for (i = 0; i < channel_count; i++) {\n        if (i != avio_rb32(pb)) {\n            av_log(c->fc, AV_LOG_WARNING,\n                   \"Ambisonic channel reordering is not supported\\n\");\n            return 0;\n        }\n    }\n    av_channel_layout_uninit(&st->codecpar->ch_layout);\n    st->codecpar->ch_layout.order = AV_CHANNEL_ORDER_AMBISONIC;\n    st->codecpar->ch_layout.nb_channels = channel_count;\n    return 0;\n}", "target": 0}
{"code": "static inline int checkSettingSecurity(lua_State* L, const std::string &name)\n{\n\tif (ScriptApiSecurity::isSecure(L) && name.compare(0, 7, \"secure.\") == 0)\n\t\tthrow LuaError(\"Attempted to set secure setting.\");\n\tbool is_mainmenu = false;\n#ifndef SERVER\n\tis_mainmenu = ModApiBase::getGuiEngine(L) != nullptr;\n#endif\n\tif (!is_mainmenu && (name == \"mg_name\" || name == \"mg_flags\")) {\n\t\terrorstream << \"Tried to set global setting \" << name << \", ignoring. \"\n\t\t\t\"minetest.set_mapgen_setting() should be used instead.\" << std::endl;\n\t\tinfostream << script_get_backtrace(L) << std::endl;\n\t\treturn -1;\n\t}\n\tconst char *disallowed[] = {\n\t\t\"main_menu_script\", \"shader_path\", \"texture_path\", \"screenshot_path\",\n\t\t\"serverlist_file\", \"serverlist_url\", \"map-dir\", \"contentdb_url\",\n\t};\n\tif (!is_mainmenu) {\n\t\tfor (const char *name2 : disallowed) {\n\t\t\tif (name == name2)\n\t\t\t\tthrow LuaError(\"Attempted to set disallowed setting.\");\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void PdfXRefStreamParserObject::getIndices(vector<int64_t>& indices, int64_t size)\n{\n    auto indexObj = this->GetDictionary().GetKey(\"Index\");\n    if (indexObj == nullptr)\n    {\n        indices.push_back(static_cast<int64_t>(0));\n        indices.push_back(size);\n    }\n    else\n    {\n        const PdfArray* arr;\n        if (!indexObj->TryGetArray(arr))\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid XRef Stream /Index\");\n        for (auto index : *arr)\n            indices.push_back(index.GetNumber());\n    }\n    if (indices.size() % 2 != 0)\n        PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid XRef Stream /Index\");\n}", "target": 1}
{"code": "\tUnbufferedAsioTlsStream(UnbufferedAsioTlsStreamParams& init)\n\t\t: AsioTcpTlsStream(init.IoContext, init.SslContext), m_VerifyOK(true), m_Hostname(init.Hostname)\n\t{\n\t}", "target": 1}
{"code": "void rose_start_t2timer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\tdel_timer(&rose->timer);\n\trose->timer.function = rose_timer_expiry;\n\trose->timer.expires  = jiffies + rose->t2;\n\tadd_timer(&rose->timer);\n}", "target": 1}
{"code": "        bool         CheckRegion(int nPos, int nSize)\n        {\n            return (nPos >= 0 && nPos + nSize >= nPos && nPos + nSize <= m_nLen);\n        }", "target": 1}
{"code": "static int rsi_send_beacon(struct rsi_common *common)\n{\n\tstruct sk_buff *skb = NULL;\n\tu8 dword_align_bytes = 0;\n\tskb = dev_alloc_skb(MAX_MGMT_PKT_SIZE);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\tmemset(skb->data, 0, MAX_MGMT_PKT_SIZE);\n\tdword_align_bytes = ((unsigned long)skb->data & 0x3f);\n\tif (dword_align_bytes)\n\t\tskb_pull(skb, (64 - dword_align_bytes));\n\tif (rsi_prepare_beacon(common, skb)) {\n\t\trsi_dbg(ERR_ZONE, \"Failed to prepare beacon\\n\");\n\t\treturn -EINVAL;\n\t}\n\tskb_queue_tail(&common->tx_queue[MGMT_BEACON_Q], skb);\n\trsi_set_event(&common->tx_thread.event);\n\trsi_dbg(DATA_TX_ZONE, \"%s: Added to beacon queue\\n\", __func__);\n\treturn 0;\n}", "target": 1}
{"code": "Pl_Count::write(unsigned char* buf, size_t len)\n{\n    if (len)\n    {\n\tthis->m->count += QIntC::to_offset(len);\n\tgetNext()->write(buf, len);\n\tthis->m->last_char = buf[len - 1];\n    }\n}", "target": 1}
{"code": "MOBI_RET mobi_trie_insert_infl(MOBITrie **root, const MOBIIndx *indx, size_t i) {\n    MOBIIndexEntry e = indx->entries[i];\n    char *inflected = e.label;\n    for (size_t j = 0; j < e.tags_count; j++) {\n        MOBIIndexTag t = e.tags[j];\n        if (t.tagid == INDX_TAGARR_INFL_PARTS_V1) {\n            for (size_t k = 0; k < t.tagvalues_count - 1; k += 2) {\n                uint32_t len = t.tagvalues[k];\n                uint32_t offset = t.tagvalues[k + 1];\n                char *base = mobi_get_cncx_string_flat(indx->cncx_record, offset, len);\n                if (base == NULL) {\n                    return MOBI_MALLOC_FAILED;\n                }\n                MOBI_RET ret = mobi_trie_insert_reversed(root, base, inflected);\n                free(base);\n                if (ret != MOBI_SUCCESS) {\n                    return ret;\n                }\n            }\n        }\n    }\n    return MOBI_SUCCESS;\n}", "target": 1}
{"code": "rfbMpiToBytes(const gcry_mpi_t value, uint8_t *result, size_t size)\n{\n  gcry_error_t error;\n  size_t len;\n  int i;\n  error = gcry_mpi_print(GCRYMPI_FMT_USG, result, size, &len, value);\n  if (gcry_err_code(error) != GPG_ERR_NO_ERROR)\n  {\n    rfbClientLog(\"gcry_mpi_print error: %s\\n\", gcry_strerror(error));\n    return FALSE;\n  }\n  for (i=size-1;i>(int)size-1-(int)len;--i)\n    result[i] = result[i-size+len];\n  for (;i>=0;--i)\n    result[i] = 0;\n  return TRUE;\n}", "target": 0}
{"code": "ipf_extract_frags_from_batch(struct ipf *ipf, struct dp_packet_batch *pb,\n                             ovs_be16 dl_type, uint16_t zone, long long now,\n                             uint32_t hash_basis)\n{\n    const size_t pb_cnt = dp_packet_batch_size(pb);\n    int pb_idx; \n    struct dp_packet *pkt;\n    DP_PACKET_BATCH_REFILL_FOR_EACH (pb_idx, pb_cnt, pkt, pb) {\n        if (OVS_UNLIKELY((dl_type == htons(ETH_TYPE_IP) &&\n                          ipf_is_valid_v4_frag(ipf, pkt))\n                          ||\n                          (dl_type == htons(ETH_TYPE_IPV6) &&\n                          ipf_is_valid_v6_frag(ipf, pkt)))) {\n            ovs_mutex_lock(&ipf->ipf_lock);\n            if (!ipf_handle_frag(ipf, pkt, dl_type, zone, now, hash_basis)) {\n                dp_packet_batch_refill(pb, pkt, pb_idx);\n            }\n            ovs_mutex_unlock(&ipf->ipf_lock);\n        } else {\n            dp_packet_batch_refill(pb, pkt, pb_idx);\n        }\n    }\n}", "target": 1}
{"code": "static inline void sctp_ulpq_store_reasm(struct sctp_ulpq *ulpq,\n\t\t\t\t\t struct sctp_ulpevent *event)\n{\n\tstruct sk_buff *pos;\n\tstruct sctp_ulpevent *cevent;\n\t__u32 tsn, ctsn;\n\ttsn = event->tsn;\n\tpos = skb_peek_tail(&ulpq->reasm);\n\tif (!pos) {\n\t\t__skb_queue_tail(&ulpq->reasm, sctp_event2skb(event));\n\t\treturn;\n\t}\n\tcevent = sctp_skb2event(pos);\n\tctsn = cevent->tsn;\n\tif (TSN_lt(ctsn, tsn)) {\n\t\t__skb_queue_tail(&ulpq->reasm, sctp_event2skb(event));\n\t\treturn;\n\t}\n\tskb_queue_walk(&ulpq->reasm, pos) {\n\t\tcevent = sctp_skb2event(pos);\n\t\tctsn = cevent->tsn;\n\t\tif (TSN_lt(tsn, ctsn))\n\t\t\tbreak;\n\t}\n\t__skb_insert(sctp_event2skb(event), pos->prev, pos, &ulpq->reasm);\n}", "target": 0}
{"code": "static ssize_t psi_write(struct file *file, const char __user *user_buf,\n\t\t\t size_t nbytes, enum psi_res res)\n{\n\tchar buf[32];\n\tsize_t buf_size;\n\tstruct seq_file *seq;\n\tstruct psi_trigger *new;\n\tif (static_branch_likely(&psi_disabled))\n\t\treturn -EOPNOTSUPP;\n\tbuf_size = min(nbytes, sizeof(buf));\n\tif (copy_from_user(buf, user_buf, buf_size))\n\t\treturn -EFAULT;\n\tbuf[buf_size - 1] = '\\0';\n\tnew = psi_trigger_create(&psi_system, buf, nbytes, res);\n\tif (IS_ERR(new))\n\t\treturn PTR_ERR(new);\n\tseq = file->private_data;\n\tmutex_lock(&seq->lock);\n\tpsi_trigger_replace(&seq->private, new);\n\tmutex_unlock(&seq->lock);\n\treturn nbytes;\n}", "target": 1}
{"code": "raptor_libxml_resolveEntity(void* user_data, \n                            const xmlChar *publicId, const xmlChar *systemId) {\n  raptor_sax2* sax2 = (raptor_sax2*)user_data;\n  return libxml2_resolveEntity(sax2->xc, publicId, systemId);\n}", "target": 1}
{"code": "int mempool_releasebuffer(MemoryPoolHandle handle, void *buf,\n                          size_t released_buffer_size) {\n  struct mempool *pool = (struct mempool *)handle;\n  struct memory_pool_element *pool_item = (struct memory_pool_element *)buf;\n  char *log_msg_fmt =\n      \"mempool(%p): mempool_releasebuffer called for invalid \"\n      \"released_buffer_size(%zu), current pool manages only \"\n      \"mempool_item_size(%zu)\";\n  char log_msg[300];\n  if ((pool == NULL) || (pool_item == NULL)) {\n    return S3_MEMPOOL_INVALID_ARG;\n  }\n  if (pool->mempool_item_size != released_buffer_size) {\n    if (pool->log_callback_func) {\n      snprintf(log_msg, sizeof(log_msg), log_msg_fmt, (void *)pool,\n               released_buffer_size, pool->mempool_item_size);\n      pool->log_callback_func(MEMPOOL_LOG_FATAL, log_msg);\n      return S3_MEMPOOL_INVALID_ARG;\n    }\n  }\n  if ((pool->flags & ENABLE_LOCKING) != 0) {\n    pthread_mutex_lock(&pool->lock);\n  }\n  if ((pool->flags & ZEROED_BUFFER) != 0) {\n    memset(pool_item, 0, pool->mempool_item_size);\n  }\n  pool_item->next = pool->free_list;\n  pool->free_list = pool_item;\n  pool->free_bufs_in_pool++;\n  pool_item = NULL;\n  pool->number_of_bufs_shared--;\n  if ((pool->flags & ENABLE_LOCKING) != 0) {\n    pthread_mutex_unlock(&pool->lock);\n  }\n  return 0;\n}", "target": 0}
{"code": "static UINT rdpei_recv_pdu(RDPEI_CHANNEL_CALLBACK* callback, wStream* s)\n{\n\tUINT16 eventId;\n\tUINT32 pduLength;\n\tUINT error;\n\tStream_Read_UINT16(s, eventId);   \n\tStream_Read_UINT32(s, pduLength); \n#ifdef WITH_DEBUG_RDPEI\n\tWLog_DBG(TAG, \"rdpei_recv_pdu: eventId: %\" PRIu16 \" (%s) length: %\" PRIu32 \"\", eventId,\n\t         rdpei_eventid_string(eventId), pduLength);\n#endif\n\tswitch (eventId)\n\t{\n\t\tcase EVENTID_SC_READY:\n\t\t\tif ((error = rdpei_recv_sc_ready_pdu(callback, s)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_recv_sc_ready_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tif ((error = rdpei_send_cs_ready_pdu(callback)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_send_cs_ready_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EVENTID_SUSPEND_TOUCH:\n\t\t\tif ((error = rdpei_recv_suspend_touch_pdu(callback, s)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_recv_suspend_touch_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EVENTID_RESUME_TOUCH:\n\t\t\tif ((error = rdpei_recv_resume_touch_pdu(callback, s)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_recv_resume_touch_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn CHANNEL_RC_OK;\n}", "target": 1}
{"code": "guardfraction_file_parse_guard_line(const char *guard_line,\n                                    smartlist_t *vote_routerstatuses,\n                                    char **err_msg)\n{\n  char guard_id[DIGEST_LEN];\n  uint32_t guardfraction;\n  char *inputs_tmp = NULL;\n  int num_ok = 1;\n  smartlist_t *sl = smartlist_new();\n  int retval = -1;\n  tor_assert(err_msg);\n  smartlist_split_string(sl, guard_line, \" \",\n                         SPLIT_SKIP_SPACE|SPLIT_IGNORE_BLANK, 3);\n  if (smartlist_len(sl) < 3) {\n    tor_asprintf(err_msg, \"bad line '%s'\", guard_line);\n    goto done;\n  }\n  inputs_tmp = smartlist_get(sl, 0);\n  if (strlen(inputs_tmp) != HEX_DIGEST_LEN ||\n      base16_decode(guard_id, DIGEST_LEN,\n                    inputs_tmp, HEX_DIGEST_LEN) != DIGEST_LEN) {\n    tor_asprintf(err_msg, \"bad digest '%s'\", inputs_tmp);\n    goto done;\n  }\n  inputs_tmp = smartlist_get(sl, 1);\n  guardfraction =\n    (uint32_t) tor_parse_long(inputs_tmp, 10, 0, 100, &num_ok, NULL);\n  if (!num_ok) {\n    tor_asprintf(err_msg, \"wrong percentage '%s'\", inputs_tmp);\n    goto done;\n  }\n  if (vote_routerstatuses) {\n    retval = guardfraction_line_apply(guard_id, guardfraction,\n                                      vote_routerstatuses);\n  } else {\n    retval = 0; \n  }\n done:\n  SMARTLIST_FOREACH(sl, char *, cp, tor_free(cp));\n  smartlist_free(sl);\n  return retval;\n}", "target": 0}
{"code": "static int find_subprog(struct bpf_verifier_env *env, int off)\n{\n\tstruct bpf_subprog_info *p;\n\tp = bsearch(&off, env->subprog_info, env->subprog_cnt,\n\t\t    sizeof(env->subprog_info[0]), cmp_subprogs);\n\tif (!p)\n\t\treturn -ENOENT;\n\treturn p - env->subprog_info;\n}", "target": 0}
{"code": "void hid_reset(HIDState *hs)\n{\n    switch (hs->kind) {\n    case HID_KEYBOARD:\n        memset(hs->kbd.keycodes, 0, sizeof(hs->kbd.keycodes));\n        memset(hs->kbd.key, 0, sizeof(hs->kbd.key));\n        hs->kbd.keys = 0;\n        break;\n    case HID_MOUSE:\n    case HID_TABLET:\n        memset(hs->ptr.queue, 0, sizeof(hs->ptr.queue));\n        break;\n    }\n    hs->head = 0;\n    hs->n = 0;\n    hs->protocol = 1;\n    hs->idle = 0;\n    hs->idle_pending = false;\n    hid_del_idle_timer(hs);\n}", "target": 1}
{"code": "static inline struct kvm_mmu_page *page_header(hpa_t shadow_page)\n{\n\tstruct page *page = pfn_to_page(shadow_page >> PAGE_SHIFT);\n\treturn (struct kvm_mmu_page *)page_private(page);\n}", "target": 0}
{"code": "struct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6,\n\t\t\t\t   const struct sk_buff *skb,\n\t\t\t\t   int flags, pol_lookup_t lookup)\n{\n\tstruct rt6_info *rt;\n\trt = lookup(net, net->ipv6.fib6_main_tbl, fl6, skb, flags);\n\tif (rt->dst.error == -EAGAIN) {\n\t\tip6_rt_put_flags(rt, flags);\n\t\trt = net->ipv6.ip6_null_entry;\n\t\tif (!(flags | RT6_LOOKUP_F_DST_NOREF))\n\t\t\tdst_hold(&rt->dst);\n\t}\n\treturn &rt->dst;\n}", "target": 1}
{"code": "error::Error GLES2DecoderImpl::HandleCreateStreamTextureCHROMIUM(\n    uint32 immediate_data_size,\n    const gles2::CreateStreamTextureCHROMIUM& c) {\n  if (!feature_info_->feature_flags().chromium_stream_texture) {\n    SetGLError(GL_INVALID_OPERATION,\n               \"glOpenStreamTextureCHROMIUM: \"\n               \"not supported.\");\n    return error::kNoError;\n  }\n  uint32 client_id = c.client_id;\n  typedef gles2::CreateStreamTextureCHROMIUM::Result Result;\n  Result* result = GetSharedMemoryAs<Result*>(\n      c.result_shm_id, c.result_shm_offset, sizeof(*result));\n  if (!result)\n    return error::kOutOfBounds;\n  *result = GL_ZERO;\n  TextureManager::TextureInfo* info =\n      texture_manager()->GetTextureInfo(client_id);\n  if (!info) {\n    SetGLError(GL_INVALID_VALUE,\n               \"glCreateStreamTextureCHROMIUM: \"\n               \"bad texture id.\");\n    return error::kNoError;\n  }\n  if (info->IsStreamTexture()) {\n    SetGLError(GL_INVALID_OPERATION,\n               \"glCreateStreamTextureCHROMIUM: \"\n               \"is already a stream texture.\");\n    return error::kNoError;\n  }\n  if (info->target() && info->target() != GL_TEXTURE_EXTERNAL_OES) {\n    SetGLError(GL_INVALID_OPERATION,\n               \"glCreateStreamTextureCHROMIUM: \"\n               \"is already bound to incompatible target.\");\n    return error::kNoError;\n  }\n  if (!stream_texture_manager_)\n    return error::kInvalidArguments;\n  GLuint object_id = stream_texture_manager_->CreateStreamTexture(\n      info->service_id(), client_id);\n  if (object_id) {\n    info->SetStreamTexture(true);\n  } else {\n    SetGLError(GL_OUT_OF_MEMORY,\n               \"glCreateStreamTextureCHROMIUM: \"\n               \"failed to create platform texture.\");\n  }\n  *result = object_id;\n  return error::kNoError;\n}", "target": 0}
{"code": "int _gnutls_x509_verify_signature(const gnutls_datum_t * tbs,\n\t\t\t\t  const gnutls_datum_t * signature,\n\t\t\t\t  gnutls_x509_crt_t issuer)\n{\n    mpi_t issuer_params[MAX_PUBLIC_PARAMS_SIZE];\n    int ret, issuer_params_size, i;\n    issuer_params_size = MAX_PUBLIC_PARAMS_SIZE;\n    ret =\n\t_gnutls_x509_crt_get_mpis(issuer, issuer_params,\n\t\t\t\t  &issuer_params_size);\n    if (ret < 0) {\n\tgnutls_assert();\n\treturn ret;\n    }\n    ret =\n\tverify_sig(tbs, signature,\n\t\t   gnutls_x509_crt_get_pk_algorithm(issuer, NULL),\n\t\t   issuer_params, issuer_params_size);\n    if (ret < 0) {\n\tgnutls_assert();\n    }\n    for (i = 0; i < issuer_params_size; i++) {\n\t_gnutls_mpi_release(&issuer_params[i]);\n    }\n    return ret;\n}", "target": 0}
{"code": "inline StreamWriteResult StreamBase::Write(\n    uv_buf_t* bufs,\n    size_t count,\n    uv_stream_t* send_handle,\n    v8::Local<v8::Object> req_wrap_obj) {\n  Environment* env = stream_env();\n  int err;\n  size_t total_bytes = 0;\n  for (size_t i = 0; i < count; ++i)\n    total_bytes += bufs[i].len;\n  bytes_written_ += total_bytes;\n  if (send_handle == nullptr) {\n    err = DoTryWrite(&bufs, &count);\n    if (err != 0 || count == 0) {\n      return StreamWriteResult { false, err, nullptr, total_bytes };\n    }\n  }\n  HandleScope handle_scope(env->isolate());\n  if (req_wrap_obj.IsEmpty()) {\n    req_wrap_obj =\n        env->write_wrap_template()\n            ->NewInstance(env->context()).ToLocalChecked();\n    StreamReq::ResetObject(req_wrap_obj);\n  }\n  AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(GetAsyncWrap());\n  WriteWrap* req_wrap = CreateWriteWrap(req_wrap_obj);\n  err = DoWrite(req_wrap, bufs, count, send_handle);\n  bool async = err == 0;\n  if (!async) {\n    req_wrap->Dispose();\n    req_wrap = nullptr;\n  }\n  const char* msg = Error();\n  if (msg != nullptr) {\n    req_wrap_obj->Set(env->error_string(), OneByteString(env->isolate(), msg));\n    ClearError();\n  }\n  return StreamWriteResult { async, err, req_wrap, total_bytes };\n}", "target": 1}
{"code": "void *jas_malloc(size_t size)\n{\n\tvoid *result;\n\tJAS_DBGLOG(101, (\"jas_malloc called with %zu\\n\", size));\n\tresult = malloc(size);\n\tJAS_DBGLOG(100, (\"jas_malloc(%zu) -> %p\\n\", size, result));\n\treturn result;\n}", "target": 1}
{"code": "static struct rpmsg_device *rpmsg_virtio_add_ctrl_dev(struct virtio_device *vdev)\n{\n\tstruct virtproc_info *vrp = vdev->priv;\n\tstruct virtio_rpmsg_channel *vch;\n\tstruct rpmsg_device *rpdev_ctrl;\n\tint err = 0;\n\tvch = kzalloc(sizeof(*vch), GFP_KERNEL);\n\tif (!vch)\n\t\treturn ERR_PTR(-ENOMEM);\n\tvch->vrp = vrp;\n\trpdev_ctrl = &vch->rpdev;\n\trpdev_ctrl->ops = &virtio_rpmsg_ops;\n\trpdev_ctrl->dev.parent = &vrp->vdev->dev;\n\trpdev_ctrl->dev.release = virtio_rpmsg_release_device;\n\trpdev_ctrl->little_endian = virtio_is_little_endian(vrp->vdev);\n\terr = rpmsg_ctrldev_register_device(rpdev_ctrl);\n\tif (err) {\n\t\tkfree(vch);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn rpdev_ctrl;\n}", "target": 1}
{"code": "static char *str_dup_safe_fixed(const ut8 *b, const ut8 *str, ut64 len, const ut8 *end) {\n\tif (str >= b && str + len < end) {\n\t\tchar *result = calloc (1, len + 1);\n\t\tif (result) {\n\t\t\tr_str_ncpy (result, (const char *)str, len);\n\t\t\treturn result;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "static int check_cert(X509_STORE_CTX *ctx)\n{\n    X509_CRL *crl = NULL, *dcrl = NULL;\n    X509 *x = NULL;\n    int ok = 0, cnum = 0;\n    unsigned int last_reasons = 0;\n    cnum = ctx->error_depth;\n    x = sk_X509_value(ctx->chain, cnum);\n    ctx->current_cert = x;\n    ctx->current_issuer = NULL;\n    ctx->current_crl_score = 0;\n    ctx->current_reasons = 0;\n    while (ctx->current_reasons != CRLDP_ALL_REASONS) {\n        last_reasons = ctx->current_reasons;\n        if (ctx->get_crl)\n            ok = ctx->get_crl(ctx, &crl, x);\n        else\n            ok = get_crl_delta(ctx, &crl, &dcrl, x);\n        if (!ok) {\n            ctx->error = X509_V_ERR_UNABLE_TO_GET_CRL;\n            ok = ctx->verify_cb(0, ctx);\n            goto err;\n        }\n        ctx->current_crl = crl;\n        ok = ctx->check_crl(ctx, crl);\n        if (!ok)\n            goto err;\n        if (dcrl) {\n            ok = ctx->check_crl(ctx, dcrl);\n            if (!ok)\n                goto err;\n            ok = ctx->cert_crl(ctx, dcrl, x);\n            if (!ok)\n                goto err;\n        } else\n            ok = 1;\n        if (ok != 2) {\n            ok = ctx->cert_crl(ctx, crl, x);\n            if (!ok)\n                goto err;\n        }\n        X509_CRL_free(crl);\n        X509_CRL_free(dcrl);\n        crl = NULL;\n        dcrl = NULL;\n        if (last_reasons == ctx->current_reasons) {\n            ctx->error = X509_V_ERR_UNABLE_TO_GET_CRL;\n            ok = ctx->verify_cb(0, ctx);\n            goto err;\n        }\n    }\n err:\n    X509_CRL_free(crl);\n    X509_CRL_free(dcrl);\n    ctx->current_crl = NULL;\n    return ok;\n}", "target": 0}
{"code": "static inline uint8_t ok_read_uint8(ok_jpg_decoder *decoder) {\n    if (decoder->input_buffer_start == decoder->input_buffer_end) {\n        size_t len = decoder->input.read(decoder->input_user_data, decoder->input_buffer,\n                                         sizeof(decoder->input_buffer));\n        decoder->input_buffer_start = decoder->input_buffer;\n        decoder->input_buffer_end = decoder->input_buffer + len;\n        if (len == 0) {\n            return 0;\n        }\n    }\n    return *decoder->input_buffer_start++;\n}", "target": 0}
{"code": "status_t MPEG4Extractor::parseAC3SpecificBox(\n off64_t offset, uint16_t sampleRate) {\n uint32_t size;\n const uint32_t kAC3SpecificBoxSize = 11;\n if (!mDataSource->getUInt32(offset, &size) || size < kAC3SpecificBoxSize) {\n        ALOGE(\"MPEG4Extractor: error while reading ac-3 block: cannot read specific box size\");\n return ERROR_MALFORMED;\n }\n    offset += 4;\n uint32_t type;\n if (!mDataSource->getUInt32(offset, &type) || type != FOURCC('d', 'a', 'c', '3')) {\n        ALOGE(\"MPEG4Extractor: error while reading ac-3 specific block: header not dac3\");\n return ERROR_MALFORMED;\n }\n    offset += 4;\n const uint32_t kAC3SpecificBoxPayloadSize = 3;\n uint8_t chunk[kAC3SpecificBoxPayloadSize];\n if (mDataSource->readAt(offset, chunk, sizeof(chunk)) != sizeof(chunk)) {\n        ALOGE(\"MPEG4Extractor: error while reading ac-3 specific block: bitstream fields\");\n return ERROR_MALFORMED;\n }\n ABitReader br(chunk, sizeof(chunk));\n static const unsigned channelCountTable[] = {2, 1, 2, 3, 3, 4, 4, 5};\n static const unsigned sampleRateTable[] = {48000, 44100, 32000};\n unsigned fscod = br.getBits(2);\n if (fscod == 3) {\n        ALOGE(\"Incorrect fscod (3) in AC3 header\");\n return ERROR_MALFORMED;\n }\n unsigned boxSampleRate = sampleRateTable[fscod];\n if (boxSampleRate != sampleRate) {\n        ALOGE(\"sample rate mismatch: boxSampleRate = %d, sampleRate = %d\",\n            boxSampleRate, sampleRate);\n return ERROR_MALFORMED;\n }\n unsigned bsid = br.getBits(5);\n if (bsid > 8) {\n        ALOGW(\"Incorrect bsid in AC3 header. Possibly E-AC-3?\");\n return ERROR_MALFORMED;\n }\n unsigned bsmod __unused = br.getBits(3);\n unsigned acmod = br.getBits(3);\n unsigned lfeon = br.getBits(1);\n unsigned channelCount = channelCountTable[acmod] + lfeon;\n if (mLastTrack == NULL) {\n return ERROR_MALFORMED;\n }\n    mLastTrack->meta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_AC3);\n    mLastTrack->meta->setInt32(kKeyChannelCount, channelCount);\n    mLastTrack->meta->setInt32(kKeySampleRate, sampleRate);\n return OK;\n}", "target": 0}
{"code": "PGTYPESinterval_from_asc(char *str, char **endptr)\n{\n\tinterval   *result = NULL;\n\tfsec_t\t\tfsec;\n\tstruct tm\ttt,\n\t\t\t   *tm = &tt;\n\tint\t\t\tdtype;\n\tint\t\t\tnf;\n\tchar\t   *field[MAXDATEFIELDS];\n\tint\t\t\tftype[MAXDATEFIELDS];\n\tchar\t\tlowstr[MAXDATELEN + MAXDATEFIELDS];\n\tchar\t   *realptr;\n\tchar\t  **ptr = (endptr != NULL) ? endptr : &realptr;\n\ttm->tm_year = 0;\n\ttm->tm_mon = 0;\n\ttm->tm_mday = 0;\n\ttm->tm_hour = 0;\n\ttm->tm_min = 0;\n\ttm->tm_sec = 0;\n\tfsec = 0;\n\tif (strlen(str) >= sizeof(lowstr))\n\t{\n\t\terrno = PGTYPES_INTVL_BAD_INTERVAL;\n\t\treturn NULL;\n\t}\n\tif (ParseDateTime(str, lowstr, field, ftype, &nf, ptr) != 0 ||\n\t\t(DecodeInterval(field, ftype, nf, &dtype, tm, &fsec) != 0 &&\n\t\t DecodeISO8601Interval(str, &dtype, tm, &fsec) != 0))\n\t{\n\t\terrno = PGTYPES_INTVL_BAD_INTERVAL;\n\t\treturn NULL;\n\t}\n\tresult = (interval *) pgtypes_alloc(sizeof(interval));\n\tif (!result)\n\t\treturn NULL;\n\tif (dtype != DTK_DELTA)\n\t{\n\t\terrno = PGTYPES_INTVL_BAD_INTERVAL;\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\tif (tm2interval(tm, fsec, result) != 0)\n\t{\n\t\terrno = PGTYPES_INTVL_BAD_INTERVAL;\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\terrno = 0;\n\treturn result;\n}", "target": 1}
{"code": "xfs_attr3_leaf_read_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tif ((xfs_sb_version_hascrc(&mp->m_sb) &&\n\t     !xfs_verify_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t\t\t  XFS_ATTR3_LEAF_CRC_OFF)) ||\n\t    !xfs_attr3_leaf_verify(bp)) {\n\t\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp, bp->b_addr);\n\t\txfs_buf_ioerror(bp, EFSCORRUPTED);\n\t}\n}", "target": 0}
{"code": "int lxc_pclose(struct lxc_popen_FILE *fp)\n{\n\tpid_t wait_pid;\n\tint wstatus = 0;\n\tif (!fp)\n\t\treturn -1;\n\tdo {\n\t\twait_pid = waitpid(fp->child_pid, &wstatus, 0);\n\t} while (wait_pid < 0 && errno == EINTR);\n\tfclose(fp->f);\n\tfree(fp);\n\tif (wait_pid < 0)\n\t\treturn -1;\n\treturn wstatus;\n}", "target": 0}
{"code": "static int cdrom_ioctl_select_disc(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_SELECT_DISC\\n\");\n\tif (!CDROM_CAN(CDC_SELECT_DISC))\n\t\treturn -ENOSYS;\n\tif (arg != CDSL_CURRENT && arg != CDSL_NONE) {\n\t\tif ((int)arg >= cdi->capacity)\n\t\t\treturn -EINVAL;\n\t}\n\tif (cdi->ops->select_disc)\n\t\treturn cdi->ops->select_disc(cdi, arg);\n\tcd_dbg(CD_CHANGER, \"Using generic cdrom_select_disc()\\n\");\n\treturn cdrom_select_disc(cdi, arg);\n}", "target": 1}
{"code": "static struct sctp_chunk *sctp_make_asconf(struct sctp_association *asoc,\n\t\t\t\t\t   union sctp_addr *addr,\n\t\t\t\t\t   int vparam_len)\n{\n\tsctp_addiphdr_t asconf;\n\tstruct sctp_chunk *retval;\n\tint length = sizeof(asconf) + vparam_len;\n\tunion sctp_addr_param addrparam;\n\tint addrlen;\n\tstruct sctp_af *af = sctp_get_af_specific(addr->v4.sin_family);\n\taddrlen = af->to_addr_param(addr, &addrparam);\n\tif (!addrlen)\n\t\treturn NULL;\n\tlength += addrlen;\n\tretval = sctp_make_control(asoc, SCTP_CID_ASCONF, 0, length);\n\tif (!retval)\n\t\treturn NULL;\n\tasconf.serial = htonl(asoc->addip_serial++);\n\tretval->subh.addip_hdr =\n\t\tsctp_addto_chunk(retval, sizeof(asconf), &asconf);\n\tretval->param_hdr.v =\n\t\tsctp_addto_chunk(retval, addrlen, &addrparam);\n\treturn retval;\n}", "target": 0}
{"code": "local block_state deflate_fast(s, flush)\n    deflate_state *s;\n    int flush;\n{\n    IPos hash_head;       \n    int bflush;           \n    for (;;) {\n        if (s->lookahead < MIN_LOOKAHEAD) {\n            fill_window(s);\n            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {\n                return need_more;\n            }\n            if (s->lookahead == 0) break; \n        }\n        hash_head = NIL;\n        if (s->lookahead >= MIN_MATCH) {\n            INSERT_STRING(s, s->strstart, hash_head);\n        }\n        if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {\n            s->match_length = longest_match (s, hash_head);\n        }\n        if (s->match_length >= MIN_MATCH) {\n            check_match(s, s->strstart, s->match_start, s->match_length);\n            _tr_tally_dist(s, s->strstart - s->match_start,\n                           s->match_length - MIN_MATCH, bflush);\n            s->lookahead -= s->match_length;\n#ifndef FASTEST\n            if (s->match_length <= s->max_insert_length &&\n                s->lookahead >= MIN_MATCH) {\n                s->match_length--; \n                do {\n                    s->strstart++;\n                    INSERT_STRING(s, s->strstart, hash_head);\n                } while (--s->match_length != 0);\n                s->strstart++;\n            } else\n#endif\n            {\n                s->strstart += s->match_length;\n                s->match_length = 0;\n                s->ins_h = s->window[s->strstart];\n                UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);\n#if MIN_MATCH != 3\n                Call UPDATE_HASH() MIN_MATCH-3 more times\n#endif\n            }\n        } else {\n            Tracevv((stderr,\"%c\", s->window[s->strstart]));\n            _tr_tally_lit (s, s->window[s->strstart], bflush);\n            s->lookahead--;\n            s->strstart++;\n        }\n        if (bflush) FLUSH_BLOCK(s, 0);\n    }\n    s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;\n    if (flush == Z_FINISH) {\n        FLUSH_BLOCK(s, 1);\n        return finish_done;\n    }\n    if (s->last_lit)\n        FLUSH_BLOCK(s, 0);\n    return block_done;\n}", "target": 1}
{"code": "static int generate(struct crypto_rng *tfm, const u8 *src, unsigned int slen,\n\t\t    u8 *dst, unsigned int dlen)\n{\n\treturn crypto_old_rng_alg(tfm)->rng_make_random(tfm, dst, dlen);\n}", "target": 1}
{"code": "static int cma_addr_cmp(const struct sockaddr *src, const struct sockaddr *dst)\n{\n\tif (src->sa_family != dst->sa_family)\n\t\treturn -1;\n\tswitch (src->sa_family) {\n\tcase AF_INET:\n\t\treturn ((struct sockaddr_in *)src)->sin_addr.s_addr !=\n\t\t       ((struct sockaddr_in *)dst)->sin_addr.s_addr;\n\tcase AF_INET6: {\n\t\tstruct sockaddr_in6 *src_addr6 = (struct sockaddr_in6 *)src;\n\t\tstruct sockaddr_in6 *dst_addr6 = (struct sockaddr_in6 *)dst;\n\t\tbool link_local;\n\t\tif (ipv6_addr_cmp(&src_addr6->sin6_addr,\n\t\t\t\t\t  &dst_addr6->sin6_addr))\n\t\t\treturn 1;\n\t\tlink_local = ipv6_addr_type(&dst_addr6->sin6_addr) &\n\t\t\t     IPV6_ADDR_LINKLOCAL;\n\t\treturn link_local ? (src_addr6->sin6_scope_id !=\n\t\t\t\t     dst_addr6->sin6_scope_id) :\n\t\t\t\t    0;\n\t}\n\tdefault:\n\t\treturn ib_addr_cmp(&((struct sockaddr_ib *) src)->sib_addr,\n\t\t\t\t   &((struct sockaddr_ib *) dst)->sib_addr);\n\t}\n}", "target": 0}
{"code": "void file_sb_list_add(struct file *file, struct super_block *sb)\n{\n\tif (likely(!(file->f_mode & FMODE_WRITE)))\n\t\treturn;\n\tif (!S_ISREG(file_inode(file)->i_mode))\n\t\treturn;\n\tlg_local_lock(&files_lglock);\n\t__file_sb_list_add(file, sb);\n\tlg_local_unlock(&files_lglock);\n}", "target": 1}
{"code": "static int snd_timer_start1(struct snd_timer_instance *timeri,\n\t\t\t    bool start, unsigned long ticks)\n{\n\tstruct snd_timer *timer;\n\tint result;\n\tunsigned long flags;\n\ttimer = timeri->timer;\n\tif (!timer)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&timer->lock, flags);\n\tif (timer->card && timer->card->shutdown) {\n\t\tresult = -ENODEV;\n\t\tgoto unlock;\n\t}\n\tif (timeri->flags & (SNDRV_TIMER_IFLG_RUNNING |\n\t\t\t     SNDRV_TIMER_IFLG_START)) {\n\t\tresult = -EBUSY;\n\t\tgoto unlock;\n\t}\n\tif (start)\n\t\ttimeri->ticks = timeri->cticks = ticks;\n\telse if (!timeri->cticks)\n\t\ttimeri->cticks = 1;\n\ttimeri->pticks = 0;\n\tlist_move_tail(&timeri->active_list, &timer->active_list_head);\n\tif (timer->running) {\n\t\tif (timer->hw.flags & SNDRV_TIMER_HW_SLAVE)\n\t\t\tgoto __start_now;\n\t\ttimer->flags |= SNDRV_TIMER_FLG_RESCHED;\n\t\ttimeri->flags |= SNDRV_TIMER_IFLG_START;\n\t\tresult = 1; \n\t} else {\n\t\tif (start)\n\t\t\ttimer->sticks = ticks;\n\t\ttimer->hw.start(timer);\n\t      __start_now:\n\t\ttimer->running++;\n\t\ttimeri->flags |= SNDRV_TIMER_IFLG_RUNNING;\n\t\tresult = 0;\n\t}\n\tsnd_timer_notify1(timeri, start ? SNDRV_TIMER_EVENT_START :\n\t\t\t  SNDRV_TIMER_EVENT_CONTINUE);\n unlock:\n\tspin_unlock_irqrestore(&timer->lock, flags);\n\treturn result;\n}", "target": 0}
{"code": "static int compat_getdrvstat(int drive, bool poll,\n\t\t\t    struct compat_floppy_drive_struct __user *arg)\n{\n\tstruct compat_floppy_drive_struct v;\n\tmemset(&v, 0, sizeof(struct compat_floppy_drive_struct));\n\tmutex_lock(&floppy_mutex);\n\tif (poll) {\n\t\tif (lock_fdc(drive))\n\t\t\tgoto Eintr;\n\t\tif (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR)\n\t\t\tgoto Eintr;\n\t\tprocess_fd_request();\n\t}\n\tv.spinup_date = UDRS->spinup_date;\n\tv.select_date = UDRS->select_date;\n\tv.first_read_date = UDRS->first_read_date;\n\tv.probed_format = UDRS->probed_format;\n\tv.track = UDRS->track;\n\tv.maxblock = UDRS->maxblock;\n\tv.maxtrack = UDRS->maxtrack;\n\tv.generation = UDRS->generation;\n\tv.keep_data = UDRS->keep_data;\n\tv.fd_ref = UDRS->fd_ref;\n\tv.fd_device = UDRS->fd_device;\n\tv.last_checked = UDRS->last_checked;\n\tv.dmabuf = (uintptr_t)UDRS->dmabuf;\n\tv.bufblocks = UDRS->bufblocks;\n\tmutex_unlock(&floppy_mutex);\n\tif (copy_from_user(arg, &v, sizeof(struct compat_floppy_drive_struct)))\n\t\treturn -EFAULT;\n\treturn 0;\nEintr:\n\tmutex_unlock(&floppy_mutex);\n\treturn -EINTR;\n}", "target": 0}
{"code": "static void rds_tcp_kill_sock(struct net *net)\n{\n\tstruct rds_tcp_connection *tc, *_tc;\n\tLIST_HEAD(tmp_list);\n\tstruct rds_tcp_net *rtn = net_generic(net, rds_tcp_netid);\n\tstruct socket *lsock = rtn->rds_tcp_listen_sock;\n\trtn->rds_tcp_listen_sock = NULL;\n\trds_tcp_listen_stop(lsock, &rtn->rds_tcp_accept_w);\n\tspin_lock_irq(&rds_tcp_conn_lock);\n\tlist_for_each_entry_safe(tc, _tc, &rds_tcp_conn_list, t_tcp_node) {\n\t\tstruct net *c_net = read_pnet(&tc->t_cpath->cp_conn->c_net);\n\t\tif (net != c_net || !tc->t_sock)\n\t\t\tcontinue;\n\t\tif (!list_has_conn(&tmp_list, tc->t_cpath->cp_conn)) {\n\t\t\tlist_move_tail(&tc->t_tcp_node, &tmp_list);\n\t\t} else {\n\t\t\tlist_del(&tc->t_tcp_node);\n\t\t\ttc->t_tcp_node_detached = true;\n\t\t}\n\t}\n\tspin_unlock_irq(&rds_tcp_conn_lock);\n\tlist_for_each_entry_safe(tc, _tc, &tmp_list, t_tcp_node)\n\t\trds_conn_destroy(tc->t_cpath->cp_conn);\n}", "target": 1}
{"code": "void native_tss_update_io_bitmap(void)\n{\n\tstruct tss_struct *tss = this_cpu_ptr(&cpu_tss_rw);\n\tstruct thread_struct *t = &current->thread;\n\tu16 *base = &tss->x86_tss.io_bitmap_base;\n\tif (!test_thread_flag(TIF_IO_BITMAP)) {\n\t\ttss_invalidate_io_bitmap(tss);\n\t\treturn;\n\t}\n\tif (IS_ENABLED(CONFIG_X86_IOPL_IOPERM) && t->iopl_emul == 3) {\n\t\t*base = IO_BITMAP_OFFSET_VALID_ALL;\n\t} else {\n\t\tstruct io_bitmap *iobm = t->io_bitmap;\n\t\tif (tss->io_bitmap.prev_sequence != iobm->sequence)\n\t\t\ttss_copy_io_bitmap(tss, iobm);\n\t\t*base = IO_BITMAP_OFFSET_VALID_MAP;\n\t}\n\trefresh_tss_limit();\n}", "target": 1}
{"code": "PlayerGeneric::~PlayerGeneric()\n{\n\tif (mixer)\n\t\tdelete mixer;\n\tif (player)\n\t{\n\t\tif (mixer->isActive() && !mixer->isDeviceRemoved(player))\n\t\t\tmixer->removeDevice(player);\n\t\tdelete player;\n\t}\n\tdelete[] audioDriverName;\n\tdelete listener;\n}", "target": 1}
{"code": "TEST(Context, FilterStateAttributes) {\n  StreamInfo::FilterStateImpl filter_state(StreamInfo::FilterState::LifeSpan::FilterChain);\n  FilterStateWrapper wrapper(filter_state);\n  ProtobufWkt::Arena arena;\n  wrapper.Produce(&arena);\n  const std::string key = \"filter_state_key\";\n  const std::string serialized = \"filter_state_value\";\n  const std::string missing = \"missing_key\";\n  auto accessor = std::make_shared<Envoy::Router::StringAccessorImpl>(serialized);\n  filter_state.setData(key, accessor, StreamInfo::FilterState::StateType::ReadOnly);\n  {\n    auto value = wrapper[CelValue::CreateStringView(missing)];\n    EXPECT_FALSE(value.has_value());\n  }\n  {\n    auto value = wrapper[CelValue::CreateStringView(key)];\n    EXPECT_TRUE(value.has_value());\n    EXPECT_TRUE(value.value().IsBytes());\n    EXPECT_EQ(serialized, value.value().BytesOrDie().value());\n  }\n}", "target": 0}
{"code": "static inline unsigned int unix_hash_fold(__wsum n)\n{\n\tunsigned int hash = (__force unsigned int)csum_fold(n);\n\thash ^= hash>>8;\n\treturn hash&(UNIX_HASH_SIZE-1);\n}", "target": 0}
{"code": "void msetGenericCommand(client *c, int nx) {\n    int j;\n    int setkey_flags = 0;\n    if ((c->argc % 2) == 0) {\n        addReplyErrorArity(c);\n        return;\n    }\n    if (nx) {\n        for (j = 1; j < c->argc; j += 2) {\n            if (lookupKeyWrite(c->db,c->argv[j]) != NULL) {\n                addReply(c, shared.czero);\n                return;\n            }\n        }\n        setkey_flags |= SETKEY_DOESNT_EXIST;\n    }\n    for (j = 1; j < c->argc; j += 2) {\n        c->argv[j+1] = tryObjectEncoding(c->argv[j+1]);\n        setKey(c, c->db, c->argv[j], c->argv[j + 1], setkey_flags);\n        notifyKeyspaceEvent(NOTIFY_STRING,\"set\",c->argv[j],c->db->id);\n    }\n    server.dirty += (c->argc-1)/2;\n    addReply(c, nx ? shared.cone : shared.ok);\n}", "target": 1}
{"code": "ProtoValidationTypeString(const ServiceValidationResultsType t)\n{\n   switch (t) {\n   case VALIDATION_RESULTS_TYPE_NAMEPASSWORD:\n      return VGAUTH_USERHANDLE_TYPE_NAMEPASSWORD;\n   case VALIDATION_RESULTS_TYPE_SSPI:\n      return VGAUTH_USERHANDLE_TYPE_SSPI;\n   case VALIDATION_RESULTS_TYPE_SAML:\n      return VGAUTH_USERHANDLE_TYPE_SAML;\n   case VALIDATION_RESULTS_TYPE_SAML_INFO_ONLY:\n      return VGAUTH_USERHANDLE_TYPE_SAML_INFO_ONLY;\n   case VALIDATION_RESULTS_TYPE_UNKNOWN:\n   default:\n      ASSERT(0);\n      Warning(\"%s: Tried to convert a validationType of %d to a string\\n\",\n              __FUNCTION__, t);\n      return \"<UNKNOWN>\";\n   }\n}", "target": 0}
{"code": "void PngImg::InitStorage_() {\n    rowPtrs_.resize(info_.height, nullptr);\n    data_ = new png_byte[info_.height * info_.rowbytes];\n    for(size_t i = 0; i < info_.height; ++i) {\n        rowPtrs_[i] = data_ + i * info_.rowbytes;\n    }\n}", "target": 1}
{"code": "Http::FilterMetadataStatus Context::onRequestMetadata() {\n  if (!wasm_->onRequestMetadata_) {\n    return Http::FilterMetadataStatus::Continue;\n  }\n  if (wasm_->onRequestMetadata_(this, id_).u64_ == 0) {\n    return Http::FilterMetadataStatus::Continue;\n  }\n  return Http::FilterMetadataStatus::Continue; \n}", "target": 1}
{"code": "gen_hash(codegen_scope *s, node *tree, int val, int limit)\n{\n  int slimit = GEN_VAL_STACK_MAX;\n  if (cursp() >= GEN_LIT_ARY_MAX) slimit = INT16_MAX;\n  int len = 0;\n  mrb_bool update = FALSE;\n  while (tree) {\n    if (nint(tree->car->car->car) == NODE_KW_REST_ARGS) {\n      if (len > 0) {\n        pop_n(len*2);\n        if (!update) {\n          genop_2(s, OP_HASH, cursp(), len);\n        }\n        else {\n          pop();\n          genop_2(s, OP_HASHADD, cursp(), len);\n        }\n        push();\n      }\n      codegen(s, tree->car->cdr, val);\n      if (len > 0 || update) {\n        pop(); pop();\n        genop_1(s, OP_HASHCAT, cursp());\n        push();\n      }\n      update = TRUE;\n      len = 0;\n    }\n    else {\n      codegen(s, tree->car->car, val);\n      codegen(s, tree->car->cdr, val);\n      len++;\n    }\n    tree = tree->cdr;\n    if (val && cursp() >= slimit) {\n      pop_n(len*2);\n      if (!update) {\n        genop_2(s, OP_HASH, cursp(), len);\n      }\n      else {\n        pop();\n        genop_2(s, OP_HASHADD, cursp(), len);\n      }\n      push();\n      update = TRUE;\n      len = 0;\n    }\n  }\n  if (update) {\n    if (val && len > 0) {\n      pop_n(len*2+1);\n      genop_2(s, OP_HASHADD, cursp(), len);\n      push();\n    }\n    return -1;                  \n  }\n  return len;\n}", "target": 1}
{"code": "unsigned paravirt_patch_jmp(void *insnbuf, const void *target,\n\t\t\t    unsigned long addr, unsigned len)\n{\n\tstruct branch *b = insnbuf;\n\tunsigned long delta = (unsigned long)target - (addr+5);\n\tif (len < 5)\n\t\treturn len;\t\n\tb->opcode = 0xe9;\t\n\tb->delta = delta;\n\treturn 5;\n}", "target": 1}
{"code": "  CookieHashMethod(const std::string& key, const std::string& path,\n                   const absl::optional<std::chrono::seconds>& ttl, bool terminal,\n                   const CookieAttributeRefVector attributes)\n      : HashMethodImplBase(terminal), key_(key), path_(path), ttl_(ttl), attributes_(attributes) {}", "target": 1}
{"code": "l_strnstart(const char *tstr1, u_int tl1, const char *str2, u_int l2)\n{\n\tif (tl1 > l2)\n\t\treturn 0;\n\treturn (strncmp(tstr1, str2, tl1) == 0 ? 1 : 0);\n}", "target": 1}
{"code": "void acpi_os_unmap_generic_address(struct acpi_generic_address *gas)\n{\n\tu64 addr;\n\tstruct acpi_ioremap *map;\n\tif (gas->space_id != ACPI_ADR_SPACE_SYSTEM_MEMORY)\n\t\treturn;\n\tmemcpy(&addr, &gas->address, sizeof(addr));\n\tif (!addr || !gas->bit_width)\n\t\treturn;\n\tmutex_lock(&acpi_ioremap_lock);\n\tmap = acpi_map_lookup(addr, gas->bit_width / 8);\n\tif (!map) {\n\t\tmutex_unlock(&acpi_ioremap_lock);\n\t\treturn;\n\t}\n\tacpi_os_drop_map_ref(map);\n\tmutex_unlock(&acpi_ioremap_lock);\n\tacpi_os_map_cleanup(map);\n}", "target": 0}
{"code": "static int plug_ctx_cmp(void *priv, struct list_head *a, struct list_head *b)\n{\n\tstruct request *rqa = container_of(a, struct request, queuelist);\n\tstruct request *rqb = container_of(b, struct request, queuelist);\n\treturn !(rqa->mq_ctx < rqb->mq_ctx ||\n\t\t (rqa->mq_ctx == rqb->mq_ctx &&\n\t\t  blk_rq_pos(rqa) < blk_rq_pos(rqb)));\n}", "target": 0}
{"code": "static void fuse_lib_release(fuse_req_t req, fuse_ino_t ino,\n                             struct fuse_file_info *fi)\n{\n    struct fuse *f = req_fuse_prepare(req);\n    struct fuse_intr_data d;\n    char *path;\n    int err = 0;\n    pthread_rwlock_rdlock(&f->tree_lock);\n    path = get_path(f, ino);\n    if (f->conf.debug)\n        fprintf(stderr, \"RELEASE%s[%llu] flags: 0x%x\\n\",\n                fi->flush ? \"+FLUSH\" : \"\",\n                (unsigned long long) fi->fh, fi->flags);\n    if (fi->flush) {\n        err = fuse_flush_common(f, req, ino, path, fi);\n        if (err == -ENOSYS)\n            err = 0;\n    }\n    fuse_prepare_interrupt(f, req, &d);\n    fuse_do_release(f, ino, path, fi);\n    fuse_finish_interrupt(f, req, &d);\n    free(path);\n    pthread_rwlock_unlock(&f->tree_lock);\n    reply_err(req, err);\n}", "target": 0}
{"code": "PHP_FUNCTION(radius_get_vendor_attr)\n{\n\tint res;\n\tconst void *data;\n\tint len;\n\tu_int32_t vendor;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &data, &len) == FAILURE) {\n\t\treturn;\n\t}\n\tres = rad_get_vendor_attr(&vendor, &data, (size_t *) &len);\n\tif (res == -1) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tarray_init(return_value);\n\t\tadd_assoc_long(return_value, \"attr\", res);\n\t\tadd_assoc_long(return_value, \"vendor\", vendor);\n\t\tadd_assoc_stringl(return_value, \"data\", (char *) data, len, 1);\n\t\treturn;\n\t}\n}", "target": 1}
{"code": "int input_set_keycode(struct input_dev *dev,\n\t\t      const struct input_keymap_entry *ke)\n{\n\tunsigned long flags;\n\tunsigned int old_keycode;\n\tint retval;\n\tif (ke->keycode > KEY_MAX)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\tretval = dev->setkeycode(dev, ke, &old_keycode);\n\tif (retval)\n\t\tgoto out;\n\t__clear_bit(KEY_RESERVED, dev->keybit);\n\tif (test_bit(EV_KEY, dev->evbit) &&\n\t    !is_event_supported(old_keycode, dev->keybit, KEY_MAX) &&\n\t    __test_and_clear_bit(old_keycode, dev->key)) {\n\t\tstruct input_value vals[] =  {\n\t\t\t{ EV_KEY, old_keycode, 0 },\n\t\t\tinput_value_sync\n\t\t};\n\t\tinput_pass_values(dev, vals, ARRAY_SIZE(vals));\n\t}\n out:\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\treturn retval;\n}", "target": 1}
{"code": "cmnd_matches_all(const struct sudoers_parse_tree *parse_tree,\n    const struct member *m, const char *runchroot, struct cmnd_info *info)\n{\n    const bool negated = m->negated;\n    struct sudo_command *c;\n    int matched = UNSPEC;\n    struct alias *a;\n    debug_decl(cmnd_matches_all, SUDOERS_DEBUG_MATCH);\n    switch (m->type) {\n\tcase ALL:\n\t    c = (struct sudo_command *)m->name;\n\t    if (command_matches(parse_tree->ctx, c->cmnd, c->args, runchroot,\n\t\t    info, &c->digests))\n\t\tmatched = negated ? DENY : ALLOW;\n\t    break;\n\tcase ALIAS:\n\t    a = alias_get(parse_tree, m->name, CMNDALIAS);\n\t    if (a != NULL) {\n\t\tTAILQ_FOREACH_REVERSE(m, &a->members, member_list, entries) {\n\t\t    matched = cmnd_matches_all(parse_tree, m, runchroot, info);\n\t\t    if (matched != UNSPEC) {\n\t\t\tif (negated)\n\t\t\t    matched = matched == ALLOW ? DENY : ALLOW;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\talias_put(a);\n\t    }\n\t    break;\n    }\n    debug_return_int(matched);\n}", "target": 1}
{"code": "R_API RBinJavaVerificationObj *r_bin_java_verification_info_from_type(RBinJavaObj *bin, R_BIN_JAVA_STACKMAP_TYPE type, ut32 value) {\n\tRBinJavaVerificationObj *se = R_NEW0 (RBinJavaVerificationObj);\n\tif (!se) {\n\t\treturn NULL;\n\t}\n\tse->tag = type;\n\tif (se->tag == R_BIN_JAVA_STACKMAP_OBJECT) {\n\t\tse->info.obj_val_cp_idx = (ut16) value;\n\t} else if (se->tag == R_BIN_JAVA_STACKMAP_UNINIT) {\n\t\tse->info.uninit_offset = (ut16) value;\n\t}\n\treturn se;\n}", "target": 1}
{"code": "ref_stack_allow_expansion(ref_stack_t *pstack, bool expand)\n{\n    pstack->params->allow_expansion = expand;\n}", "target": 0}
{"code": "    int FixIso::run(const std::string& path)\n    {\n        try {\n            if (!Exiv2::fileExists(path, true)) {\n                std::cerr << path << \": \" << _(\"Failed to open the file\\n\");\n                return -1;\n            }\n            Timestamp ts;\n            if (Params::instance().preserve_)\n                ts.read(path);\n            Exiv2::Image::UniquePtr image = Exiv2::ImageFactory::open(path);\n            image->readMetadata();\n            Exiv2::ExifData& exifData = image->exifData();\n            if (exifData.empty()) {\n                std::cerr << path << \": \" << _(\"No Exif data found in the file\\n\");\n                return -3;\n            }\n            auto md = Exiv2::isoSpeed(exifData);\n            if (md != exifData.end()) {\n                if (strcmp(md->key().c_str(), \"Exif.Photo.ISOSpeedRatings\") == 0) {\n                    if (Params::instance().verbose_) {\n                        std::cout << _(\"Standard Exif ISO tag exists; not modified\\n\");\n                    }\n                    return 0;\n                }\n                std::ostringstream os;\n                md->write(os, &exifData);\n                if (Params::instance().verbose_) {\n                    std::cout << _(\"Setting Exif ISO value to\") << \" \" << os.str() << \"\\n\";\n                }\n                exifData[\"Exif.Photo.ISOSpeedRatings\"] = os.str();\n            }\n            image->writeMetadata();\n            if (Params::instance().preserve_)\n                ts.touch(path);\n            return 0;\n        } catch (const Exiv2::AnyError& e) {\n            std::cerr << \"Exiv2 exception in fixiso action for file \" << path << \":\\n\" << e << \"\\n\";\n            return 1;\n        }\n    }", "target": 0}
{"code": "void rose_start_t1timer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\tdel_timer(&rose->timer);\n\trose->timer.function = rose_timer_expiry;\n\trose->timer.expires  = jiffies + rose->t1;\n\tadd_timer(&rose->timer);\n}", "target": 1}
{"code": "int vfs_clone_file_range(struct file *file_in, loff_t pos_in,\n\t\tstruct file *file_out, loff_t pos_out, u64 len)\n{\n\tstruct inode *inode_in = file_inode(file_in);\n\tstruct inode *inode_out = file_inode(file_out);\n\tint ret;\n\tif (inode_in->i_sb != inode_out->i_sb ||\n\t    file_in->f_path.mnt != file_out->f_path.mnt)\n\t\treturn -EXDEV;\n\tif (S_ISDIR(inode_in->i_mode) || S_ISDIR(inode_out->i_mode))\n\t\treturn -EISDIR;\n\tif (!S_ISREG(inode_in->i_mode) || !S_ISREG(inode_out->i_mode))\n\t\treturn -EINVAL;\n\tif (!(file_in->f_mode & FMODE_READ) ||\n\t    !(file_out->f_mode & FMODE_WRITE) ||\n\t    (file_out->f_flags & O_APPEND) ||\n\t    !file_in->f_op->clone_file_range)\n\t\treturn -EBADF;\n\tret = clone_verify_area(file_in, pos_in, len, false);\n\tif (ret)\n\t\treturn ret;\n\tret = clone_verify_area(file_out, pos_out, len, true);\n\tif (ret)\n\t\treturn ret;\n\tif (pos_in + len > i_size_read(inode_in))\n\t\treturn -EINVAL;\n\tret = mnt_want_write_file(file_out);\n\tif (ret)\n\t\treturn ret;\n\tret = file_in->f_op->clone_file_range(file_in, pos_in,\n\t\t\tfile_out, pos_out, len);\n\tif (!ret) {\n\t\tfsnotify_access(file_in);\n\t\tfsnotify_modify(file_out);\n\t}\n\tmnt_drop_write_file(file_out);\n\treturn ret;\n}", "target": 0}
{"code": "GIOChannel *net_connect_ip_ssl(IPADDR *ip, int port, IPADDR *my_ip, const char *cert, const char *pkey, const char *cafile, const char *capath, gboolean verify)\n{\n\tGIOChannel *handle, *ssl_handle;\n\thandle = net_connect_ip(ip, port, my_ip);\n\tif (handle == NULL)\n\t\treturn NULL;\n\tssl_handle  = irssi_ssl_get_iochannel(handle, cert, pkey, cafile, capath, verify);\n\tif (ssl_handle == NULL)\n\t\tg_io_channel_unref(handle);\n\treturn ssl_handle;\n}", "target": 1}
{"code": "int ssh_scp_close(ssh_scp scp)\n{\n    char buffer[128] = {0};\n    int rc;\n    if (scp == NULL) {\n        return SSH_ERROR;\n    }\n    if (scp->channel != NULL) {\n        if (ssh_channel_send_eof(scp->channel) == SSH_ERROR) {\n            scp->state = SSH_SCP_ERROR;\n            return SSH_ERROR;\n        }\n        while (!ssh_channel_is_eof(scp->channel)) {\n            rc = ssh_channel_read(scp->channel, buffer, sizeof(buffer), 0);\n            if (rc == SSH_ERROR || rc == 0) {\n                break;\n            }\n        }\n        if (ssh_channel_close(scp->channel) == SSH_ERROR) {\n            scp->state = SSH_SCP_ERROR;\n            return SSH_ERROR;\n        }\n        ssh_channel_free(scp->channel);\n        scp->channel = NULL;\n    }\n    scp->state = SSH_SCP_NEW;\n    return SSH_OK;\n}", "target": 0}
{"code": "static void free_partial(struct kmem_cache *s, struct kmem_cache_node *n)\n{\n\tunsigned long flags;\n\tstruct page *page, *h;\n\tspin_lock_irqsave(&n->list_lock, flags);\n\tlist_for_each_entry_safe(page, h, &n->partial, lru) {\n\t\tif (!page->inuse) {\n\t\t\tlist_del(&page->lru);\n\t\t\tdiscard_slab(s, page);\n\t\t\tn->nr_partial--;\n\t\t} else {\n\t\t\tlist_slab_objects(s, page,\n\t\t\t\t\"Objects remaining on kmem_cache_close()\");\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&n->list_lock, flags);\n}", "target": 0}
{"code": "SYSCALL_DEFINE1(timer_getoverrun, timer_t, timer_id)\n{\n\tstruct k_itimer *timr;\n\tint overrun;\n\tunsigned long flags;\n\ttimr = lock_timer(timer_id, &flags);\n\tif (!timr)\n\t\treturn -EINVAL;\n\toverrun = timr->it_overrun_last;\n\tunlock_timer(timr, flags);\n\treturn overrun;\n}", "target": 1}
{"code": "static void kvm_vcpu_destroy(struct kvm_vcpu *vcpu)\n{\n\tkvm_dirty_ring_free(&vcpu->dirty_ring);\n\tkvm_arch_vcpu_destroy(vcpu);\n\tput_pid(rcu_dereference_protected(vcpu->pid, 1));\n\tfree_page((unsigned long)vcpu->run);\n\tkmem_cache_free(kvm_vcpu_cache, vcpu);\n}", "target": 1}
{"code": "void http_return_srv_error(struct session *s, struct stream_interface *si)\n{\n\tint err_type = si->err_type;\n\tif (err_type & SI_ET_QUEUE_ABRT)\n\t\thttp_server_error(s, si, SN_ERR_CLICL, SN_FINST_Q,\n\t\t\t\t  503, http_error_message(s, HTTP_ERR_503));\n\telse if (err_type & SI_ET_CONN_ABRT)\n\t\thttp_server_error(s, si, SN_ERR_CLICL, SN_FINST_C,\n\t\t\t\t  503, http_error_message(s, HTTP_ERR_503));\n\telse if (err_type & SI_ET_QUEUE_TO)\n\t\thttp_server_error(s, si, SN_ERR_SRVTO, SN_FINST_Q,\n\t\t\t\t  503, http_error_message(s, HTTP_ERR_503));\n\telse if (err_type & SI_ET_QUEUE_ERR)\n\t\thttp_server_error(s, si, SN_ERR_SRVCL, SN_FINST_Q,\n\t\t\t\t  503, http_error_message(s, HTTP_ERR_503));\n\telse if (err_type & SI_ET_CONN_TO)\n\t\thttp_server_error(s, si, SN_ERR_SRVTO, SN_FINST_C,\n\t\t\t\t  503, http_error_message(s, HTTP_ERR_503));\n\telse if (err_type & SI_ET_CONN_ERR)\n\t\thttp_server_error(s, si, SN_ERR_SRVCL, SN_FINST_C,\n\t\t\t\t  503, http_error_message(s, HTTP_ERR_503));\n\telse \n\t\thttp_server_error(s, si, SN_ERR_INTERNAL, SN_FINST_C,\n\t\t\t\t  500, http_error_message(s, HTTP_ERR_500));\n}", "target": 0}
{"code": "static int nl80211_dump_mpath(struct sk_buff *skb,\n\t\t\t      struct netlink_callback *cb)\n{\n\tstruct mpath_info pinfo;\n\tstruct cfg80211_registered_device *dev;\n\tstruct net_device *netdev;\n\tu8 dst[ETH_ALEN];\n\tu8 next_hop[ETH_ALEN];\n\tint path_idx = cb->args[1];\n\tint err;\n\terr = nl80211_prepare_netdev_dump(skb, cb, &dev, &netdev);\n\tif (err)\n\t\treturn err;\n\tif (!dev->ops->dump_mpath) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\tif (netdev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\twhile (1) {\n\t\terr = rdev_dump_mpath(dev, netdev, path_idx, dst, next_hop,\n\t\t\t\t      &pinfo);\n\t\tif (err == -ENOENT)\n\t\t\tbreak;\n\t\tif (err)\n\t\t\tgoto out_err;\n\t\tif (nl80211_send_mpath(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t       cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t       netdev, dst, next_hop,\n\t\t\t\t       &pinfo) < 0)\n\t\t\tgoto out;\n\t\tpath_idx++;\n\t}\n out:\n\tcb->args[1] = path_idx;\n\terr = skb->len;\n out_err:\n\tnl80211_finish_netdev_dump(dev);\n\treturn err;\n}", "target": 0}
{"code": "int devmem_is_allowed(unsigned long pagenr)\n{\n\tif (pagenr < 256)\n\t\treturn 1;\n\tif (iomem_is_exclusive(pagenr << PAGE_SHIFT))\n\t\treturn 0;\n\tif (!page_is_ram(pagenr))\n\t\treturn 1;\n\treturn 0;\n}", "target": 1}
{"code": "static int udp_push_pending_frames(struct sock *sk)\n{\n\tstruct udp_sock  *up = udp_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct flowi4 *fl4 = &inet->cork.fl.u.ip4;\n\tstruct sk_buff *skb;\n\tint err = 0;\n\tskb = ip_finish_skb(sk, fl4);\n\tif (!skb)\n\t\tgoto out;\n\terr = udp_send_skb(skb, fl4);\nout:\n\tup->len = 0;\n\tup->pending = 0;\n\treturn err;\n}", "target": 1}
{"code": "NOEXPORT int parse_socket_error(CLI *c, const char *text) {\n    switch(get_last_socket_error()) {\n    case 0: \n#ifndef USE_WIN32\n    case EPIPE: \n#endif\n    case S_ECONNABORTED:\n        s_log(LOG_INFO, \"%s: Socket is closed\", text);\n        return 0;\n    case S_EINTR:\n        s_log(LOG_DEBUG, \"%s: Interrupted by a signal: retrying\", text);\n        return 1;\n    case S_EWOULDBLOCK:\n        s_log(LOG_NOTICE, \"%s: Would block: retrying\", text);\n        s_poll_sleep(1, 0); \n        return 1;\n#if S_EAGAIN!=S_EWOULDBLOCK\n    case S_EAGAIN:\n        s_log(LOG_DEBUG,\n            \"%s: Temporary lack of resources: retrying\", text);\n        return 1;\n#endif\n#ifdef USE_WIN32\n    case S_ECONNRESET:\n        if(c->opt->exec_name) {\n            s_log(LOG_INFO, \"%s: Socket is closed (exec)\", text);\n            return 0;\n        }\n#endif\n    default:\n        sockerror(text);\n        throw_exception(c, 1);\n        return -1; \n    }\n}", "target": 1}
{"code": "Bool Ppmd8_Alloc(CPpmd8 *p, UInt32 size)\n{\n  if (p->Base == 0 || p->Size != size)\n  {\n    Ppmd8_Free(p);\n    p->AlignOffset =\n      #ifdef PPMD_32BIT\n        (4 - size) & 3;\n      #else\n        4 - (size & 3);\n      #endif\n    if ((p->Base = (Byte *)malloc(p->AlignOffset + size)) == 0)\n      return False;\n    p->Size = size;\n  }\n  return True;\n}", "target": 0}
{"code": "static u32 vvc_ctb_to_tile_col_bd(VVCSliceInfo *si, u32 ctb_addr_x)\n{\n\tu32 i, tile_x = 0;\n\tu32 tile_col_bd_val = 0;\n\tfor (i=0; i <= si->pps->pic_width_in_ctbsY; i++) {\n\t\tif (i == tile_col_bd_val + si->pps->tile_cols_width_ctb[tile_x] ) {\n\t\t\ttile_col_bd_val += si->pps->tile_cols_width_ctb[tile_x];\n\t\t\ttile_x++;\n\t\t}\n\t\tif (ctb_addr_x == i) return tile_col_bd_val;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static struct sock *rfcomm_sock_alloc(struct net *net, struct socket *sock, int proto, gfp_t prio)\n{\n\tstruct rfcomm_dlc *d;\n\tstruct sock *sk;\n\tsk = sk_alloc(net, PF_BLUETOOTH, prio, &rfcomm_proto);\n\tif (!sk)\n\t\treturn NULL;\n\tsock_init_data(sock, sk);\n\tINIT_LIST_HEAD(&bt_sk(sk)->accept_q);\n\td = rfcomm_dlc_alloc(prio);\n\tif (!d) {\n\t\tsk_free(sk);\n\t\treturn NULL;\n\t}\n\td->data_ready   = rfcomm_sk_data_ready;\n\td->state_change = rfcomm_sk_state_change;\n\trfcomm_pi(sk)->dlc = d;\n\td->owner = sk;\n\tsk->sk_destruct = rfcomm_sock_destruct;\n\tsk->sk_sndtimeo = RFCOMM_CONN_TIMEOUT;\n\tsk->sk_sndbuf = RFCOMM_MAX_CREDITS * RFCOMM_DEFAULT_MTU * 10;\n\tsk->sk_rcvbuf = RFCOMM_MAX_CREDITS * RFCOMM_DEFAULT_MTU * 10;\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\tsk->sk_protocol = proto;\n\tsk->sk_state    = BT_OPEN;\n\tbt_sock_link(&rfcomm_sk_list, sk);\n\tBT_DBG(\"sk %p\", sk);\n\treturn sk;\n}", "target": 0}
{"code": "static void dup_xol_work(struct callback_head *work)\n{\n\tif (current->flags & PF_EXITING)\n\t\treturn;\n\tif (!__create_xol_area(current->utask->dup_xol_addr) &&\n\t\t\t!fatal_signal_pending(current))\n\t\tuprobe_warn(current, \"dup xol area\");\n}", "target": 0}
{"code": "PHP_FUNCTION(imagetruecolortopalette)\n{\n\tzval *IM;\n\tzend_bool dither;\n\tzend_long ncolors;\n\tgdImagePtr im;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"rbl\", &IM, &dither, &ncolors) == FAILURE)  {\n\t\treturn;\n\t}\n\tif ((im = (gdImagePtr)zend_fetch_resource(Z_RES_P(IM), \"Image\", le_gd)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tif (ncolors <= 0) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Number of colors has to be greater than zero\");\n\t\tRETURN_FALSE;\n\t}\n\tgdImageTrueColorToPalette(im, dither, ncolors);\n\tRETURN_TRUE;\n}", "target": 1}
{"code": "static void read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)\n{\n    int i, j, v;\n    if (get_bits1(gb)) {\n        for (i = 0; i < 64; i++) {\n            v = get_bits(gb, 8);\n            j = s->idsp.idct_permutation[ff_zigzag_direct[i]];\n            s->intra_matrix[j]        = v;\n            s->chroma_intra_matrix[j] = v;\n        }\n    }\n    if (get_bits1(gb)) {\n        for (i = 0; i < 64; i++) {\n            get_bits(gb, 8);\n        }\n    }\n    if (get_bits1(gb)) {\n        for (i = 0; i < 64; i++) {\n            v = get_bits(gb, 8);\n            j = s->idsp.idct_permutation[ff_zigzag_direct[i]];\n            s->chroma_intra_matrix[j] = v;\n        }\n    }\n    if (get_bits1(gb)) {\n        for (i = 0; i < 64; i++) {\n            get_bits(gb, 8);\n        }\n    }\n    next_start_code_studio(gb);\n}", "target": 1}
{"code": "tTcpIpPacketParsingResult ParaNdis_ReviewIPPacket(PVOID buffer, ULONG size, LPCSTR caller)\n{\n    tTcpIpPacketParsingResult res = QualifyIpPacket((IPHeader *) buffer, size);\n    PrintOutParsingResult(res, 1, caller);\n    return res;\n}", "target": 1}
{"code": "static inline void nf_reset(struct sk_buff *skb)\n{\n#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)\n\tnf_conntrack_put(skb->nfct);\n\tskb->nfct = NULL;\n#endif\n#ifdef NET_SKBUFF_NF_DEFRAG_NEEDED\n\tnf_conntrack_put_reasm(skb->nfct_reasm);\n\tskb->nfct_reasm = NULL;\n#endif\n#ifdef CONFIG_BRIDGE_NETFILTER\n\tnf_bridge_put(skb->nf_bridge);\n\tskb->nf_bridge = NULL;\n#endif\n}", "target": 0}
{"code": "int db__open(struct mosquitto__config *config)\n{\n\tstruct mosquitto__subhier *subhier;\n\tif(!config) return MOSQ_ERR_INVAL;\n\tdb.last_db_id = 0;\n\tdb.contexts_by_id = NULL;\n\tdb.contexts_by_sock = NULL;\n\tdb.contexts_for_free = NULL;\n#ifdef WITH_BRIDGE\n\tdb.bridges = NULL;\n\tdb.bridge_count = 0;\n#endif\n\tdb.clientid_index_hash = NULL;\n\tdb.subs = NULL;\n\tsubhier = sub__add_hier_entry(NULL, &db.subs, \"\", 0);\n\tif(!subhier) return MOSQ_ERR_NOMEM;\n\tsubhier = sub__add_hier_entry(NULL, &db.subs, \"$SYS\", (uint16_t)strlen(\"$SYS\"));\n\tif(!subhier) return MOSQ_ERR_NOMEM;\n\tretain__init();\n\tdb.config->security_options.unpwd = NULL;\n#ifdef WITH_PERSISTENCE\n\tif(persist__restore()) return 1;\n#endif\n\treturn MOSQ_ERR_SUCCESS;\n}", "target": 1}
{"code": "order_notification_deltas(struct rdr_notification_ctx *ctx)\n{\n\tstruct delta_head **ptr;\n\tarray_index i;\n\tint error;\n\terror = deltas_head_set_size(ctx->notification->deltas_list,\n\t    ctx->deltas.len);\n\tif (error)\n\t\treturn error;\n\tARRAYLIST_FOREACH(&ctx->deltas, ptr, i) {\n\t\terror = deltas_head_add(ctx->notification->deltas_list,\n\t\t    ctx->notification->global_data.serial,\n\t\t    (*ptr)->serial,\n\t\t    (*ptr)->doc_data.uri,\n\t\t    (*ptr)->doc_data.hash,\n\t\t    (*ptr)->doc_data.hash_len);\n\t\tif (!error)\n\t\t\tcontinue;\n\t\tif (error == -EINVAL)\n\t\t\treturn pr_val_err(\"Serial '%lu' at delta elements isn't part of a contiguous list of serials.\",\n\t\t\t    (*ptr)->serial);\n\t\tif (error == -EEXIST)\n\t\t\treturn pr_val_err(\"Duplicated serial '%lu' at delta elements.\",\n\t\t\t    (*ptr)->serial);\n\t\treturn error;\n\t}\n\tif (!deltas_head_values_set(ctx->notification->deltas_list))\n\t\treturn pr_val_err(\"Deltas listed don't have a contiguous sequence of serial numbers\");\n\treturn 0;\n}", "target": 1}
{"code": "void PdfXRefStreamParserObject::ReadXRefTable()\n{\n    int64_t size = this->GetDictionary().FindKeyAs<int64_t>(PdfName::KeySize, 0);\n    auto& arrObj = this->GetDictionary().MustFindKey(\"W\");\n    const PdfArray* arr;\n    if (!arrObj.TryGetArray(arr) || arr->size() != 3)\n        PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid XRef stream /W array\");\n    int64_t wArray[W_ARRAY_SIZE] = { 0, 0, 0 };\n    int64_t num;\n    for (unsigned i = 0; i < W_ARRAY_SIZE; i++)\n    {\n        if (!(*arr)[i].TryGetNumber(num))\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid XRef stream /W array\");\n        wArray[i] = num;\n    }\n    vector<int64_t> indices;\n    getIndices(indices, static_cast<int64_t>(size));\n    parseStream(wArray, indices);\n}", "target": 1}
{"code": "static ssize_t carrier_store(struct device *dev, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t len)\n{\n\treturn netdev_store(dev, attr, buf, len, change_carrier);", "target": 0}
{"code": "void RendererSchedulerImpl::OnShutdownTaskQueue(\n    const scoped_refptr<MainThreadTaskQueue>& task_queue) {\n  if (main_thread_only().was_shutdown)\n    return;\n  if (task_queue_throttler_)\n    task_queue_throttler_->ShutdownTaskQueue(task_queue.get());\n  if (task_runners_.erase(task_queue)) {\n    switch (task_queue->queue_class()) {\n       case MainThreadTaskQueue::QueueClass::kTimer:\n         task_queue->RemoveTaskObserver(\n             &main_thread_only().timer_task_cost_estimator);\n       case MainThreadTaskQueue::QueueClass::kLoading:\n         task_queue->RemoveTaskObserver(\n             &main_thread_only().loading_task_cost_estimator);\n       default:\n         break;\n     }\n  }\n}", "target": 1}
{"code": "int __pte_alloc(struct mm_struct *mm, pmd_t *pmd, unsigned long address)\n{\n\tpgtable_t new = pte_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\tsmp_wmb(); \n\tspin_lock(&mm->page_table_lock);\n\tif (!pmd_present(*pmd)) {\t\n\t\tmm->nr_ptes++;\n\t\tpmd_populate(mm, pmd, new);\n\t\tnew = NULL;\n\t}\n\tspin_unlock(&mm->page_table_lock);\n\tif (new)\n\t\tpte_free(mm, new);\n\treturn 0;\n}", "target": 0}
{"code": "Pl_ASCII85Decoder::flush()\n{\n    if (this->pos == 0)\n    {\n\tQTC::TC(\"libtests\", \"Pl_ASCII85Decoder no-op flush\");\n\treturn;\n    }\n    unsigned long lval = 0;\n    for (int i = 0; i < 5; ++i)\n    {\n\tlval *= 85;\n\tlval += (this->inbuf[i] - 33U);\n    }\n    unsigned char outbuf[4];\n    memset(outbuf, 0, 4);\n    for (int i = 3; i >= 0; --i)\n    {\n\toutbuf[i] = lval & 0xff;\n\tlval >>= 8;\n    }\n    QTC::TC(\"libtests\", \"Pl_ASCII85Decoder partial flush\",\n\t    (this->pos == 5) ? 0 : 1);\n    getNext()->write(outbuf, this->pos - 1);\n    this->pos = 0;\n    memset(this->inbuf, 117, 5);\n}", "target": 1}
{"code": "        EDP* getEDP() { return &edp_; }", "target": 1}
{"code": "static pj_status_t STATUS_FROM_SSL_ERR2(char *action, pj_ssl_sock_t *ssock,\n\t\t\t\t\tint ret, int err, int len)\n{\n    unsigned long ssl_err = err;\n    if (err == SSL_ERROR_SSL) {\n\tssl_err = ERR_peek_error();\n    }\n    SSLLogErrors(action, ret, err, len, ssock);\n    ssock->last_err = ssl_err;\n    return GET_STATUS_FROM_SSL_ERR(ssl_err);\n}", "target": 1}
{"code": "static int32_t gcd(int a, int b)\n{\n  if (a == 0 && b == 0) {\n    return 1;\n  }\n  if (a == 0) return b;\n  if (b == 0) return a;\n  int32_t h;\n  do {\n    h = a % b;\n    a = b;\n    b = h;\n  } while (b != 0);\n  return a;\n}", "target": 1}
{"code": "xmlAddID(xmlValidCtxtPtr ctxt, xmlDocPtr doc, const xmlChar *value,\n         xmlAttrPtr attr) {\n    xmlIDPtr ret;\n    xmlIDTablePtr table;\n    if (doc == NULL) {\n\treturn(NULL);\n    }\n    if (value == NULL) {\n\treturn(NULL);\n    }\n    if (attr == NULL) {\n\treturn(NULL);\n    }\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)  {\n        doc->ids = table = xmlHashCreateDict(0, doc->dict);\n    }\n    if (table == NULL) {\n\txmlVErrMemory(ctxt,\n\t\t\"xmlAddID: Table creation failed!\\n\");\n        return(NULL);\n    }\n    ret = (xmlIDPtr) xmlMalloc(sizeof(xmlID));\n    if (ret == NULL) {\n\txmlVErrMemory(ctxt, \"malloc failed\");\n\treturn(NULL);\n    }\n    ret->value = xmlStrdup(value);\n    ret->doc = doc;\n    if ((ctxt != NULL) && (ctxt->vstateNr != 0)) {\n\tif (doc->dict != NULL)\n\t    ret->name = xmlDictLookup(doc->dict, attr->name, -1);\n\telse\n\t    ret->name = xmlStrdup(attr->name);\n\tret->attr = NULL;\n    } else {\n\tret->attr = attr;\n\tret->name = NULL;\n    }\n    ret->lineno = xmlGetLineNo(attr->parent);\n    if (xmlHashAddEntry(table, value, ret) < 0) {\n#ifdef LIBXML_VALID_ENABLED\n\tif (ctxt != NULL) {\n\t    xmlErrValidNode(ctxt, attr->parent, XML_DTD_ID_REDEFINED,\n\t\t\t    \"ID %s already defined\\n\", value, NULL, NULL);\n\t}\n#endif \n\txmlFreeID(ret);\n\treturn(NULL);\n    }\n    if (attr != NULL)\n\tattr->atype = XML_ATTRIBUTE_ID;\n    return(ret);\n}", "target": 1}
{"code": "static void mspack_fmap_free(void *mem)\n{\n\tfree(mem);\n}", "target": 1}
{"code": "static inline int nla_put_u32(struct sk_buff *skb, int attrtype, u32 value)\n{\n\treturn nla_put(skb, attrtype, sizeof(u32), &value);\n}", "target": 0}
{"code": "vhost_user_set_vring_addr(struct virtio_net **pdev, struct VhostUserMsg *msg,\n\t\t\tint main_fd __rte_unused)\n{\n\tstruct virtio_net *dev = *pdev;\n\tstruct vhost_virtqueue *vq;\n\tstruct vhost_vring_addr *addr = &msg->payload.addr;\n\tbool access_ok;\n\tif (validate_msg_fds(msg, 0) != 0)\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\tif (dev->mem == NULL)\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\tvq = dev->virtqueue[msg->payload.addr.index];\n\taccess_ok = vq->access_ok;\n\tmemcpy(&vq->ring_addrs, addr, sizeof(*addr));\n\tvring_invalidate(dev, vq);\n\tif ((vq->enabled && (dev->features &\n\t\t\t\t(1ULL << VHOST_USER_F_PROTOCOL_FEATURES))) ||\n\t\t\taccess_ok) {\n\t\tdev = translate_ring_addresses(dev, msg->payload.addr.index);\n\t\tif (!dev)\n\t\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t\t*pdev = dev;\n\t}\n\treturn RTE_VHOST_MSG_RESULT_OK;\n}", "target": 0}
{"code": "wsrep_cb_status_t wsrep_sst_donate_cb (void* app_ctx, void* recv_ctx,\n                                       const void* msg, size_t msg_len,\n                                       const wsrep_gtid_t* current_gtid,\n                                       const char* state, size_t state_len,\n                                       bool bypass)\n{\n  local_status.set(WSREP_MEMBER_DONOR);\n  const char* method = (char*)msg;\n  size_t method_len  = strlen (method);\n  const char* data   = method + method_len + 1;\n  char uuid_str[37];\n  wsrep_uuid_print (&current_gtid->uuid, uuid_str, sizeof(uuid_str));\n  wsp::env env(NULL);\n  if (env.error())\n  {\n    WSREP_ERROR(\"wsrep_sst_donate_cb(): env var ctor failed: %d\", -env.error());\n    return WSREP_CB_FAILURE;\n  }\n  int ret;\n  if ((ret= sst_append_auth_env(env, sst_auth_real)))\n  {\n    WSREP_ERROR(\"wsrep_sst_donate_cb(): appending auth env failed: %d\", ret);\n    return WSREP_CB_FAILURE;\n  }\n  if (!strcmp (WSREP_SST_MYSQLDUMP, method))\n  {\n    ret = sst_donate_mysqldump(data, &current_gtid->uuid, uuid_str,\n                               current_gtid->seqno, bypass, env());\n  }\n  else\n  {\n    ret = sst_donate_other(method, data, uuid_str,\n                           current_gtid->seqno, bypass, env());\n  }\n  return (ret >= 0 ? WSREP_CB_SUCCESS : WSREP_CB_FAILURE);\n}", "target": 1}
{"code": "u32 gf_fs_get_http_rate(GF_FilterSession *fs)\n{\n\tif (!fs->download_manager) {\n\t\tgf_fs_get_download_manager(fs);\n\t\tif (!fs->download_manager) return 0;\n\t}\n\treturn gf_dm_get_global_rate(fs->download_manager);\n}", "target": 0}
{"code": "static void rtrs_clt_dev_release(struct device *dev)\n{\n\tstruct rtrs_clt_sess *clt = container_of(dev, struct rtrs_clt_sess,\n\t\t\t\t\t\t dev);\n\tkfree(clt);\n}", "target": 1}
{"code": "void RequestContext::StartBackendSpanAndSetTraceContext() {\n  backend_span_.reset(CreateSpan(cloud_trace_.get(), \"Backend\"));\n  std::string trace_context_header = cloud_trace()->ToTraceContextHeader(\n      backend_span_->trace_span()->span_id());\n  Status status = request()->AddHeaderToBackend(\n      cloud_trace()->header_type() == HeaderType::CLOUD_TRACE_CONTEXT\n          ? kCloudTraceContextHeader\n          : kGRpcTraceContextHeader,\n      trace_context_header);\n  if (!status.ok()) {\n    service_context()->env()->LogError(\n        \"Failed to set trace context header to backend.\");\n  }\n}", "target": 1}
{"code": "void Context::onDone() {\n  if (wasm_->onDone_) {\n    wasm_->onDone_(this, id_);\n  }\n}", "target": 1}
{"code": "ospf6_print_lshdr(netdissect_options *ndo,\n                  register const struct lsa6_hdr *lshp, const u_char *dataend)\n{\n\tif ((const u_char *)(lshp + 1) > dataend)\n\t\tgoto trunc;\n\tND_TCHECK(lshp->ls_type);\n\tND_TCHECK(lshp->ls_seq);\n\tND_PRINT((ndo, \"\\n\\t  Advertising Router %s, seq 0x%08x, age %us, length %u\",\n               ipaddr_string(ndo, &lshp->ls_router),\n               EXTRACT_32BITS(&lshp->ls_seq),\n               EXTRACT_16BITS(&lshp->ls_age),\n               EXTRACT_16BITS(&lshp->ls_length)-(u_int)sizeof(struct lsa6_hdr)));\n\tospf6_print_ls_type(ndo, EXTRACT_16BITS(&lshp->ls_type), &lshp->ls_stateid);\n\treturn (0);\ntrunc:\n\treturn (1);\n}", "target": 1}
{"code": "EXPORTED int meth_trace(struct transaction_t *txn, void *params)\n{\n    parse_path_t parse_path = (parse_path_t) params;\n    const char **hdr;\n    unsigned long max_fwd = -1;\n    struct buf *msg = &txn->resp_body.payload;\n    txn->flags.cc |= CC_NOCACHE;\n    if (!(txn->req_tgt.allow & ALLOW_TRACE)) return HTTP_NOT_ALLOWED;\n    if ((hdr = spool_getheader(txn->req_hdrs, \"Max-Forwards\"))) {\n        max_fwd = strtoul(hdr[0], NULL, 10);\n    }\n    if (max_fwd && parse_path) {\n        int r;\n        if ((r = parse_path(txn->req_uri->path,\n                            &txn->req_tgt, &txn->error.desc))) return r;\n        if (txn->req_tgt.mbentry && txn->req_tgt.mbentry->server) {\n            struct backend *be;\n            be = proxy_findserver(txn->req_tgt.mbentry->server,\n                                  &http_protocol, httpd_userid,\n                                  &backend_cached, NULL, NULL, httpd_in);\n            if (!be) return HTTP_UNAVAILABLE;\n            return http_pipe_req_resp(be, txn);\n        }\n    }\n    buf_reset(msg);\n    buf_printf(msg, \"TRACE %s %s\\r\\n\", txn->req_line.uri, txn->req_line.ver);\n    spool_enum_hdrcache(txn->req_hdrs, &trace_cachehdr, msg);\n    buf_appendcstr(msg, \"\\r\\n\");\n    txn->resp_body.type = \"message/http\";\n    txn->resp_body.len = buf_len(msg);\n    write_body(HTTP_OK, txn, buf_cstring(msg), buf_len(msg));\n    return 0;\n}", "target": 0}
{"code": "static int ecryptfs_threadfn(void *ignored)\n{\n\tset_freezable();\n\twhile (1)  {\n\t\tstruct ecryptfs_open_req *req;\n\t\twait_event_freezable(\n\t\t\tecryptfs_kthread_ctl.wait,\n\t\t\t(!list_empty(&ecryptfs_kthread_ctl.req_list)\n\t\t\t || kthread_should_stop()));\n\t\tmutex_lock(&ecryptfs_kthread_ctl.mux);\n\t\tif (ecryptfs_kthread_ctl.flags & ECRYPTFS_KTHREAD_ZOMBIE) {\n\t\t\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\t\t\tgoto out;\n\t\t}\n\t\twhile (!list_empty(&ecryptfs_kthread_ctl.req_list)) {\n\t\t\treq = list_first_entry(&ecryptfs_kthread_ctl.req_list,\n\t\t\t\t\t       struct ecryptfs_open_req,\n\t\t\t\t\t       kthread_ctl_list);\n\t\t\tlist_del(&req->kthread_ctl_list);\n\t\t\t*req->lower_file = dentry_open(&req->path,\n\t\t\t\t(O_RDWR | O_LARGEFILE), current_cred());\n\t\t\tcomplete(&req->done);\n\t\t}\n\t\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\t}\nout:\n\treturn 0;\n}", "target": 0}
{"code": "MONGO_EXPORT int bson_iterator_int( const bson_iterator *i ) {\n    switch ( bson_iterator_type( i ) ) {\n    case BSON_INT:\n        return bson_iterator_int_raw( i );\n    case BSON_LONG:\n        return bson_iterator_long_raw( i );\n    case BSON_DOUBLE:\n        return bson_iterator_double_raw( i );\n    default:\n        return 0;\n    }\n}", "target": 1}
{"code": "jio_snprintf(char * str, int n, const char * format, ...)\n{\n\tva_list args;\n\tint result;\n\tTrc_SC_snprintf_Entry();\n\tva_start(args, format);\n#if defined(WIN32) && !defined(WIN32_IBMC)\n\tresult = _vsnprintf( str, n, format, args );\n#else\n\tresult = vsprintf( str, format, args );\n#endif\n\tva_end(args);\n\tTrc_SC_snprintf_Exit(result);\n\treturn result;\n}", "target": 1}
{"code": "_gnutls_x509_read_value(ASN1_TYPE c, const char *root,\n\t\t\tgnutls_datum_t * ret)\n{\n\tint len = 0, result;\n\tuint8_t *tmp = NULL;\n\tunsigned int etype;\n\tresult = asn1_read_value_type(c, root, NULL, &len, &etype);\n\tif (result == 0 && len == 0) {\n\t\treturn gnutls_assert_val(GNUTLS_E_ASN1_DER_ERROR);\n\t}\n\tif (result != ASN1_MEM_ERROR) {\n\t\tgnutls_assert();\n\t\tresult = _gnutls_asn2err(result);\n\t\treturn result;\n\t}\n\tif (etype == ASN1_ETYPE_BIT_STRING) {\n\t\tlen = (len + 7)/8;\n\t}\n\ttmp = gnutls_malloc((size_t) len + 1);\n\tif (tmp == NULL) {\n\t\tgnutls_assert();\n\t\tresult = GNUTLS_E_MEMORY_ERROR;\n\t\tgoto cleanup;\n\t}\n\tresult = asn1_read_value(c, root, tmp, &len);\n\tif (result != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\tresult = _gnutls_asn2err(result);\n\t\tgoto cleanup;\n\t}\n\tif (etype == ASN1_ETYPE_BIT_STRING) {\n\t\tret->size = (len+7) / 8;\n\t} else {\n\t\tret->size = (unsigned) len;\n\t}\n\ttmp[ret->size] = 0;\n\tret->data = tmp;\n\treturn 0;\n      cleanup:\n\tgnutls_free(tmp);\n\treturn result;\n}", "target": 0}
{"code": "static void jsR_callfunction(js_State *J, int n, js_Function *F, js_Environment *scope)\n{\n\tjs_Value v;\n\tint i;\n\tscope = jsR_newenvironment(J, jsV_newobject(J, JS_COBJECT, NULL), scope);\n\tjsR_savescope(J, scope);\n\tif (F->arguments) {\n\t\tjs_newobject(J);\n\t\tif (!J->strict) {\n\t\t\tjs_currentfunction(J);\n\t\t\tjs_defproperty(J, -2, \"callee\", JS_DONTENUM);\n\t\t}\n\t\tjs_pushnumber(J, n);\n\t\tjs_defproperty(J, -2, \"length\", JS_DONTENUM);\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tjs_copy(J, i + 1);\n\t\t\tjs_setindex(J, -2, i);\n\t\t}\n\t\tjs_initvar(J, \"arguments\", -1);\n\t\tjs_pop(J, 1);\n\t}\n\tfor (i = 0; i < F->numparams; ++i) {\n\t\tif (i < n)\n\t\t\tjs_initvar(J, F->vartab[i], i + 1);\n\t\telse {\n\t\t\tjs_pushundefined(J);\n\t\t\tjs_initvar(J, F->vartab[i], -1);\n\t\t\tjs_pop(J, 1);\n\t\t}\n\t}\n\tjs_pop(J, n);\n\tjsR_run(J, F);\n\tv = *stackidx(J, -1);\n\tTOP = --BOT; \n\tjs_pushvalue(J, v);\n\tjsR_restorescope(J);\n}", "target": 0}
{"code": "void OverlayWindowViews::OnGestureEvent(ui::GestureEvent* event) {\n  if (event->type() != ui::ET_GESTURE_TAP)\n    return;\n  hide_controls_timer_.Reset();\n  if (!GetControlsScrimLayer()->visible()) {\n    UpdateControlsVisibility(true);\n    return;\n  }\n  if (GetCloseControlsBounds().Contains(event->location())) {\n    controller_->Close(true ,\n                       true );\n    event->SetHandled();\n  } else if (GetPlayPauseControlsBounds().Contains(event->location())) {\n     TogglePlayPause();\n     event->SetHandled();\n   }\n }", "target": 0}
{"code": "IW_IMPL(unsigned int) iw_get_ui16le(const iw_byte *b)\n{\n\treturn b[0] | (b[1]<<8);\n}", "target": 1}
{"code": "STATIC void\nS_invlist_replace_list_destroys_src(pTHX_ SV * dest, SV * src)\n{\n    const UV src_len          = _invlist_len(src);\n    const bool src_offset     = *get_invlist_offset_addr(src);\n    const STRLEN src_byte_len = SvLEN(src);\n    char * array              = SvPVX(src);\n    const int oldtainted = TAINT_get;\n    PERL_ARGS_ASSERT_INVLIST_REPLACE_LIST_DESTROYS_SRC;\n    assert(is_invlist(src));\n    assert(is_invlist(dest));\n    assert(! invlist_is_iterating(src));\n    assert(SvCUR(src) == 0 || SvCUR(src) < SvLEN(src));\n    array[src_byte_len - 1] = '\\0';\n    TAINT_NOT;      \n    sv_usepvn_flags(dest,\n                    (char *) array,\n                    src_byte_len - 1,\n                    SV_HAS_TRAILING_NUL);\n    TAINT_set(oldtainted);\n    SvPV_set(src, 0);\n    SvLEN_set(src, 0);\n    SvCUR_set(src, 0);\n    *get_invlist_offset_addr(dest) = src_offset;\n    invlist_set_len(dest, src_len, src_offset);\n    *get_invlist_previous_index_addr(dest) = 0;\n    invlist_iterfinish(dest);", "target": 0}
{"code": "void LibRaw::ahd_interpolate_green_h_and_v(\n    int top, int left, ushort (*out_rgb)[LIBRAW_AHD_TILE][LIBRAW_AHD_TILE][3])\n{\n  int row, col;\n  int c, val;\n  ushort(*pix)[4];\n  const int rowlimit = MIN(top + LIBRAW_AHD_TILE, height - 2);\n  const int collimit = MIN(left + LIBRAW_AHD_TILE, width - 2);\n  for (row = top; row < rowlimit; row++)\n  {\n    col = left + (FC(row, left) & 1);\n    for (c = FC(row, col); col < collimit; col += 2)\n    {\n      pix = image + row * width + col;\n      val =\n          ((pix[-1][1] + pix[0][c] + pix[1][1]) * 2 - pix[-2][c] - pix[2][c]) >>\n          2;\n      out_rgb[0][row - top][col - left][1] = ULIM(val, pix[-1][1], pix[1][1]);\n      val = ((pix[-width][1] + pix[0][c] + pix[width][1]) * 2 -\n             pix[-2 * width][c] - pix[2 * width][c]) >>\n            2;\n      out_rgb[1][row - top][col - left][1] =\n          ULIM(val, pix[-width][1], pix[width][1]);\n    }\n  }\n}", "target": 0}
{"code": "int HeaderMapWrapper::luaGet(lua_State* state) {\n  const char* key = luaL_checkstring(state, 2);\n  const auto value =\n      Http::HeaderUtility::getAllOfHeaderAsString(headers_, Http::LowerCaseString(key));\n  if (value.result().has_value()) {\n    lua_pushlstring(state, value.result().value().data(), value.result().value().length());\n    return 1;\n  } else {\n    return 0;\n  }\n}", "target": 0}
{"code": "static int nft_flush_table(struct nft_ctx *ctx)\n{\n\tint err;\n\tstruct nft_chain *chain, *nc;\n\tstruct nft_set *set, *ns;\n\tlist_for_each_entry_safe(chain, nc, &ctx->table->chains, list) {\n\t\tctx->chain = chain;\n\t\terr = nft_delrule_by_chain(ctx);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\terr = nft_delchain(ctx);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\tlist_for_each_entry_safe(set, ns, &ctx->table->sets, list) {\n\t\tif (set->flags & NFT_SET_ANONYMOUS &&\n\t\t    !list_empty(&set->bindings))\n\t\t\tcontinue;\n\t\terr = nft_delset(ctx, set);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\terr = nft_deltable(ctx);\nout:\n\treturn err;\n}", "target": 1}
{"code": "static bool ok_inflater_compressed_block(ok_inflater *inflater) {\n    const bool is_fixed = inflater->state == OK_INFLATER_STATE_READING_FIXED_COMPRESSED_BLOCK;\n    const ok_inflater_huffman_tree *literal_tree =\n        (is_fixed ? inflater->fixed_literal_huffman : inflater->literal_huffman);\n    const ok_inflater_huffman_tree *distance_tree =\n        (is_fixed ? inflater->fixed_distance_huffman : inflater->distance_huffman);\n    size_t max_write = ok_inflater_can_write_total(inflater);\n    const uint16_t *tree_lookup_table = literal_tree->lookup_table;\n    const unsigned int tree_bits = literal_tree->bits;\n    while (max_write > 0) {\n        int value = ok_inflater_decode_literal(inflater, tree_lookup_table, tree_bits);\n        if (value < 0) {\n            return false;\n        } else if (value < 256) {\n            ok_inflater_write_byte(inflater, (uint8_t)value);\n            max_write--;\n        } else if (value == 256) {\n            inflater->state = OK_INFLATER_STATE_READY_FOR_NEXT_BLOCK;\n            return true;\n        } else if (value < 286) {\n            inflater->huffman_code = value - 257;\n            inflater->state_count = -1;\n            inflater->state_distance = -1;\n            if (ok_inflater_distance_with_tree(inflater, distance_tree)) {\n                max_write = ok_inflater_can_write_total(inflater);\n            } else {\n                if (is_fixed) {\n                    inflater->state = OK_INFLATER_STATE_READING_FIXED_DISTANCE;\n                } else {\n                    inflater->state = OK_INFLATER_STATE_READING_DYNAMIC_DISTANCE;\n                }\n                return false;\n            }\n        } else {\n            ok_inflater_error(inflater, \"Invalid inflater literal\");\n            return false;\n        }\n    }\n    return false;\n}", "target": 0}
{"code": "static void setup_test_dir(char *tmp_dir, const char *files, ...) {\n        va_list ap;\n        assert_se(mkdtemp(tmp_dir) != NULL);\n        va_start(ap, files);\n        while (files != NULL) {\n                _cleanup_free_ char *path = strappend(tmp_dir, files);\n                assert_se(touch_file(path, true, USEC_INFINITY, UID_INVALID, GID_INVALID, 0) == 0);\n                files = va_arg(ap, const char *);\n        }\n        va_end(ap);\n}", "target": 1}
{"code": "find_entry_internal(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n    int\t\t\tlock,\n\tback_txn *txn,\n\tint flags\n)\n{\n\tif (addr->uniqueid!=NULL)\n\t{\n\t\tLDAPDebug( LDAP_DEBUG_TRACE, \"=> find_entry_internal (uniqueid=%s) lock %d\\n\",\n\t\t    addr->uniqueid, lock, 0 );\n\t\treturn (find_entry_internal_uniqueid (pb, be, addr->uniqueid, lock, txn));\n\t}\n\telse\n\t{\n\t\tstruct backentry *entry = NULL;\n\t\tLDAPDebug( LDAP_DEBUG_TRACE, \"=> find_entry_internal (dn=%s) lock %d\\n\",\n\t\t           slapi_sdn_get_dn(addr->sdn), lock, 0 );\n\t\tif (addr->sdn) {\n\t\t\tentry = find_entry_internal_dn (pb, be, addr->sdn, \n\t\t\t                                lock, txn, flags);\n\t\t} else {\n\t\t\tLDAPDebug0Args( LDAP_DEBUG_ANY,\n\t\t\t                \"find_entry_internal: Null target dn\\n\" );\n\t\t}\n\t\tLDAPDebug0Args( LDAP_DEBUG_TRACE, \"<= find_entry_internal\\n\" );\n\t\treturn entry;\n\t}\n}", "target": 1}
{"code": "static inline int check_user_page_hwpoison(unsigned long addr)\n{\n\tint rc, flags = FOLL_HWPOISON | FOLL_WRITE;\n\trc = get_user_pages(addr, 1, flags, NULL, NULL);\n\treturn rc == -EHWPOISON;\n}", "target": 0}
{"code": "void cipso_v4_req_delattr(struct request_sock *req)\n{\n\tstruct ip_options *opt;\n\tstruct inet_request_sock *req_inet;\n\treq_inet = inet_rsk(req);\n\topt = req_inet->opt;\n\tif (opt == NULL || opt->cipso == 0)\n\t\treturn;\n\tcipso_v4_delopt(&req_inet->opt);\n}", "target": 1}
{"code": "skip_string(char_u *p)\n{\n    int\t    i;\n    for ( ; ; ++p)\n    {\n\tif (p[0] == '\\'')\t\t    \n\t{\n\t    if (p[1] == NUL)\t\t    \n\t\tbreak;\n\t    i = 2;\n\t    if (p[1] == '\\\\' && p[2] != NUL)    \n\t    {\n\t\t++i;\n\t\twhile (vim_isdigit(p[i - 1]))   \n\t\t    ++i;\n\t    }\n\t    if (p[i] == '\\'')\t\t    \n\t    {\n\t\tp += i;\n\t\tcontinue;\n\t    }\n\t}\n\telse if (p[0] == '\"')\t\t    \n\t{\n\t    for (++p; p[0]; ++p)\n\t    {\n\t\tif (p[0] == '\\\\' && p[1] != NUL)\n\t\t    ++p;\n\t\telse if (p[0] == '\"')\t    \n\t\t    break;\n\t    }\n\t    if (p[0] == '\"')\n\t\tcontinue; \n\t}\n\telse if (p[0] == 'R' && p[1] == '\"')\n\t{\n\t    char_u *delim = p + 2;\n\t    char_u *paren = vim_strchr(delim, '(');\n\t    if (paren != NULL)\n\t    {\n\t\tsize_t delim_len = paren - delim;\n\t\tfor (p += 3; *p; ++p)\n\t\t    if (p[0] == ')' && STRNCMP(p + 1, delim, delim_len) == 0\n\t\t\t    && p[delim_len + 1] == '\"')\n\t\t    {\n\t\t\tp += delim_len + 1;\n\t\t\tbreak;\n\t\t    }\n\t\tif (p[0] == '\"')\n\t\t    continue; \n\t    }\n\t}\n\tbreak;\t\t\t\t    \n    }\n    if (!*p)\n\t--p;\t\t\t\t    \n    return p;\n}", "target": 1}
{"code": "static php_mb_regex_t *php_mbregex_compile_pattern(const char *pattern, int patlen, OnigOptionType options, OnigEncoding enc, OnigSyntaxType *syntax TSRMLS_DC)\n{\n\tint err_code = 0;\n\tint found = 0;\n\tphp_mb_regex_t *retval = NULL, **rc = NULL;\n\tOnigErrorInfo err_info;\n\tOnigUChar err_str[ONIG_MAX_ERROR_MESSAGE_LEN];\n\tfound = zend_hash_find(&MBREX(ht_rc), (char *)pattern, patlen+1, (void **) &rc);\n\tif (found == FAILURE || (*rc)->options != options || (*rc)->enc != enc || (*rc)->syntax != syntax) {\n\t\tif ((err_code = onig_new(&retval, (OnigUChar *)pattern, (OnigUChar *)(pattern + patlen), options, enc, syntax, &err_info)) != ONIG_NORMAL) {\n\t\t\tonig_error_code_to_str(err_str, err_code, err_info);\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"mbregex compile err: %s\", err_str);\n\t\t\tretval = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tzend_hash_update(&MBREX(ht_rc), (char *) pattern, patlen + 1, (void *) &retval, sizeof(retval), NULL);\n\t} else if (found == SUCCESS) {\n\t\tretval = *rc;\n\t}\nout:\n\treturn retval; \n}", "target": 1}
{"code": "cdf_read_short_stream(const cdf_info_t *info, const cdf_header_t *h,\n    const cdf_sat_t *sat, const cdf_dir_t *dir, cdf_stream_t *scn,\n    const cdf_directory_t **root)\n{\n\tsize_t i;\n\tconst cdf_directory_t *d;\n\t*root = NULL;\n\tfor (i = 0; i < dir->dir_len; i++)\n\t\tif (dir->dir_tab[i].d_type == CDF_DIR_TYPE_ROOT_STORAGE)\n\t\t\tbreak;\n\tif (i == dir->dir_len)\n\t\tgoto out;\n\td = &dir->dir_tab[i];\n\t*root = d;\n\tif (d->d_stream_first_sector < 0)\n\t\tgoto out;\n\treturn\tcdf_read_long_sector_chain(info, h, sat,\n\t    d->d_stream_first_sector, d->d_size, scn);\nout:\n\tscn->sst_tab = NULL;\n\tscn->sst_len = 0;\n\tscn->sst_dirlen = 0;\n\treturn 0;\n}", "target": 0}
{"code": "struct tcp_conn_t *tcp_conn_select(struct tcp_sock_t *sock,\n\t\t\t\t   struct tcp_sock_t *sock6)\n{\n\tstruct tcp_conn_t *conn = calloc(1, sizeof *conn);\n\tif (conn == NULL) {\n\t\tERR(\"Calloc for connection struct failed\");\n\t\tgoto error;\n\t}\n\tfd_set rfds;\n\tstruct timeval tv;\n\tint retval = 0;\n\tint nfds = 0;\n\twhile (retval == 0) {\n\t\tFD_ZERO(&rfds);\n\t\tif (sock) {\n\t\t\tFD_SET(sock->sd, &rfds);\n\t\t\tnfds = sock->sd;\n\t\t}\n\t\tif (sock6) {\n\t\t\tFD_SET(sock6->sd, &rfds);\n\t\t\tif (sock6->sd > nfds)\n\t\t\t\tnfds = sock6->sd;\n\t\t}\n\t\tif (nfds == 0) {\n\t\t\tERR(\"No valid TCP socket supplied.\");\n\t\t\tgoto error;\n\t\t}\n\t\tnfds += 1;\n\t\ttv.tv_sec = 5;\n\t\ttv.tv_usec = 0;\n\t\tretval = select(nfds, &rfds, NULL, NULL, &tv);\n\t\tif (retval == -1) {\n\t\t\tERR(\"Failed to open tcp connection\");\n\t\t\tgoto error;\n\t\t}\n\t}\n\tif (sock && FD_ISSET(sock->sd, &rfds)) {\n\t\tconn->sd = accept(sock->sd, NULL, NULL);\n\t\tNOTE (\"Using IPv4\");\n\t} else if (sock6 && FD_ISSET(sock6->sd, &rfds)) {\n\t\tconn->sd = accept(sock6->sd, NULL, NULL);\n\t\tNOTE (\"Using IPv6\");\n\t} else {\n\t\tERR(\"select failed\");\n\t\tgoto error;\n\t}\n\tif (conn->sd < 0) {\n\t\tERR(\"accept failed\");\n\t\tgoto error;\n\t}\n\treturn conn;\nerror:\n\tif (conn != NULL)\n\t\tfree(conn);\n\treturn NULL;\n}", "target": 0}
{"code": "static void vmxnet3_complete_packet(VMXNET3State *s, int qidx, uint32_t tx_ridx)\n{\n    struct Vmxnet3_TxCompDesc txcq_descr;\n    PCIDevice *d = PCI_DEVICE(s);\n    VMXNET3_RING_DUMP(VMW_RIPRN, \"TXC\", qidx, &s->txq_descr[qidx].comp_ring);\n    memset(&txcq_descr, 0, sizeof(txcq_descr));\n    txcq_descr.txdIdx = tx_ridx;\n    txcq_descr.gen = vmxnet3_ring_curr_gen(&s->txq_descr[qidx].comp_ring);\n    txcq_descr.val1 = cpu_to_le32(txcq_descr.val1);\n    txcq_descr.val2 = cpu_to_le32(txcq_descr.val2);\n    vmxnet3_ring_write_curr_cell(d, &s->txq_descr[qidx].comp_ring, &txcq_descr);\n    smp_wmb();\n    vmxnet3_inc_tx_completion_counter(s, qidx);\n    vmxnet3_trigger_interrupt(s, s->txq_descr[qidx].intr_idx);\n}", "target": 0}
{"code": "bool RenderMenuList::multiple()\n {\n     return toHTMLSelectElement(node())->multiple();\n }", "target": 1}
{"code": "void Logger::addPeer(const QString &ip, bool blocked, const QString &reason)\n{\n    QWriteLocker locker(&lock);\n    Log::Peer temp = { peerCounter++, QDateTime::currentMSecsSinceEpoch(), ip, blocked, reason };\n    m_peers.push_back(temp);\n    if (m_peers.size() >= MAX_LOG_MESSAGES)\n        m_peers.pop_front();\n    emit newLogPeer(temp);\n}", "target": 1}
{"code": "static Exit_status safe_connect()\n{\n  mysql= mysql_init(NULL);\n  if (!mysql)\n  {\n    error(\"Failed on mysql_init.\");\n    return ERROR_STOP;\n  }\n#ifdef HAVE_OPENSSL\n  if (opt_use_ssl)\n  {\n    mysql_ssl_set(mysql, opt_ssl_key, opt_ssl_cert, opt_ssl_ca,\n                  opt_ssl_capath, opt_ssl_cipher);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRL, opt_ssl_crl);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRLPATH, opt_ssl_crlpath);\n  }\n  mysql_options(mysql, MYSQL_OPT_SSL_VERIFY_SERVER_CERT,\n                (char*) &opt_ssl_verify_server_cert);\n#endif\n  if (opt_plugin_dir && *opt_plugin_dir)\n    mysql_options(mysql, MYSQL_PLUGIN_DIR, opt_plugin_dir);\n  if (opt_default_auth && *opt_default_auth)\n    mysql_options(mysql, MYSQL_DEFAULT_AUTH, opt_default_auth);\n  if (opt_protocol)\n    mysql_options(mysql, MYSQL_OPT_PROTOCOL, (char*) &opt_protocol);\n  if (opt_bind_addr)\n    mysql_options(mysql, MYSQL_OPT_BIND, opt_bind_addr);\n#if defined (_WIN32) && !defined (EMBEDDED_LIBRARY)\n  if (shared_memory_base_name)\n    mysql_options(mysql, MYSQL_SHARED_MEMORY_BASE_NAME,\n                  shared_memory_base_name);\n#endif\n  mysql_options(mysql, MYSQL_OPT_CONNECT_ATTR_RESET, 0);\n  mysql_options4(mysql, MYSQL_OPT_CONNECT_ATTR_ADD,\n                 \"program_name\", \"mysqlbinlog\");\n  if (!mysql_real_connect(mysql, host, user, pass, 0, port, sock, 0))\n  {\n    error(\"Failed on connect: %s\", mysql_error(mysql));\n    return ERROR_STOP;\n  }\n  mysql->reconnect= 1;\n  return OK_CONTINUE;\n}", "target": 1}
{"code": "begin_softmask(fz_context *ctx, pdf_run_processor *pr, softmask_save *save)\n{\n\tpdf_gstate *gstate = pr->gstate + pr->gtop;\n\tpdf_xobject *softmask = gstate->softmask;\n\tfz_rect mask_bbox;\n\tfz_matrix tos_save[2], save_ctm;\n\tfz_matrix mask_matrix;\n\tfz_colorspace *mask_colorspace;\n\tsave->softmask = softmask;\n\tif (softmask == NULL)\n\t\treturn gstate;\n\tsave->page_resources = gstate->softmask_resources;\n\tsave->ctm = gstate->softmask_ctm;\n\tsave_ctm = gstate->ctm;\n\tpdf_xobject_bbox(ctx, softmask, &mask_bbox);\n\tpdf_xobject_matrix(ctx, softmask, &mask_matrix);\n\tpdf_tos_save(ctx, &pr->tos, tos_save);\n\tif (gstate->luminosity)\n\t\tmask_bbox = fz_infinite_rect;\n\telse\n\t{\n\t\tfz_transform_rect(&mask_bbox, &mask_matrix);\n\t\tfz_transform_rect(&mask_bbox, &gstate->softmask_ctm);\n\t}\n\tgstate->softmask = NULL;\n\tgstate->softmask_resources = NULL;\n\tgstate->ctm = gstate->softmask_ctm;\n        mask_colorspace = pdf_xobject_colorspace(ctx, softmask);\n        if (gstate->luminosity && !mask_colorspace)\n               mask_colorspace = fz_device_gray(ctx);\n        fz_try(ctx)\n        {\n\t\tfz_begin_mask(ctx, pr->dev, &mask_bbox, gstate->luminosity, mask_colorspace, gstate->softmask_bc, &gstate->fill.color_params);\n\t\tpdf_run_xobject(ctx, pr, softmask, save->page_resources, &fz_identity, 1);\n\t}\n\tfz_always(ctx)\n\t\tfz_drop_colorspace(ctx, mask_colorspace);\n\tfz_catch(ctx)\n\t{\n\t\tfz_rethrow_if(ctx, FZ_ERROR_TRYLATER);\n\t}\n\tfz_end_mask(ctx, pr->dev);\n\tpdf_tos_restore(ctx, &pr->tos, tos_save);\n\tgstate = pr->gstate + pr->gtop;\n\tgstate->ctm = save_ctm;\n\treturn gstate;\n}", "target": 1}
{"code": "cdf_print_property_name(char *buf, size_t bufsiz, uint32_t p)\n{\n\tsize_t i;\n\tfor (i = 0; i < __arraycount(vn); i++)\n\t\tif (vn[i].v == p)\n\t\t\treturn snprintf(buf, bufsiz, \"%s\", vn[i].n);\n\treturn snprintf(buf, bufsiz, \"0x%x\", p);\n}", "target": 0}
{"code": "cleanup_bmc_device(struct kref *ref)\n{\n\tstruct bmc_device *bmc = container_of(ref, struct bmc_device, usecount);\n\tschedule_work(&bmc->remove_work);\n}", "target": 0}
{"code": "void _reset_fxsave_state()\n{\n    static OE_ALIGNED(OE_FXSAVE_ALIGNMENT) const uint64_t\n        _initial_fxstate[OE_FXSAVE_AREA_SIZE / sizeof(uint64_t)] = {\n            0x037F, 0, 0, 0xFFFF00001F80,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n        };\n    asm volatile(\"fxrstor %[fx_state] \\n\\t\"\n                 :\n                 : [fx_state] \"m\"(_initial_fxstate)\n                 :);\n}", "target": 1}
{"code": "T2P* t2p_init()\n{\n\tT2P* t2p = (T2P*) _TIFFmalloc(sizeof(T2P));\n\tif(t2p==NULL){\n\t\tTIFFError(\n\t\t\tTIFF2PDF_MODULE, \n\t\t\t\"Can't allocate %lu bytes of memory for t2p_init\", \n\t\t\t(unsigned long) sizeof(T2P));\n\t\treturn( (T2P*) NULL );\n\t}\n\t_TIFFmemset(t2p, 0x00, sizeof(T2P));\n\tt2p->pdf_majorversion=1;\n\tt2p->pdf_minorversion=1;\n\tt2p->pdf_defaultxres=300.0;\n\tt2p->pdf_defaultyres=300.0;\n\tt2p->pdf_defaultpagewidth=612.0;\n\tt2p->pdf_defaultpagelength=792.0;\n\tt2p->pdf_xrefcount=3; \n\tt2p->tiff_maxdatasize = DEFAULT_MAX_MALLOC;\n\treturn(t2p);\n}", "target": 0}
{"code": "static NTSTATUS ldapsrv_DelRequest(struct ldapsrv_call *call)\n{\n\tstruct ldap_DelRequest *req = &call->request->r.DelRequest;\n\tstruct ldap_Result *del_result;\n\tstruct ldapsrv_reply *del_reply;\n\tTALLOC_CTX *local_ctx;\n\tstruct ldb_context *samdb = call->conn->ldb;\n\tstruct ldb_dn *dn;\n\tconst char *errstr = NULL;\n\tint result = LDAP_SUCCESS;\n\tint ldb_ret;\n\tstruct ldb_result *res = NULL;\n\tDEBUG(10, (\"DelRequest\"));\n\tDEBUGADD(10, (\" dn: %s\\n\", req->dn));\n\tlocal_ctx = talloc_named(call, 0, \"DelRequest local memory context\");\n\tNT_STATUS_HAVE_NO_MEMORY(local_ctx);\n\tdn = ldb_dn_new(local_ctx, samdb, req->dn);\n\tNT_STATUS_HAVE_NO_MEMORY(dn);\n\tDEBUG(10, (\"DelRequest: dn: [%s]\\n\", req->dn));\n\tdel_reply = ldapsrv_init_reply(call, LDAP_TAG_DelResponse);\n\tNT_STATUS_HAVE_NO_MEMORY(del_reply);\n\tif (result == LDAP_SUCCESS) {\n\t\tres = talloc_zero(local_ctx, struct ldb_result);\n\t\tNT_STATUS_HAVE_NO_MEMORY(res);\n\t\tldb_ret = ldapsrv_del_with_controls(call, dn, call->request->controls, res);\n\t\tresult = map_ldb_error(local_ctx, ldb_ret, ldb_errstring(samdb),\n\t\t\t\t       &errstr);\n\t}\n\tdel_result = &del_reply->msg->r.DelResponse;\n\tdel_result->dn = NULL;\n\tif ((res != NULL) && (res->refs != NULL)) {\n\t\tdel_result->resultcode = map_ldb_error(local_ctx,\n\t\t\t\t\t\t       LDB_ERR_REFERRAL, NULL,\n\t\t\t\t\t\t       &errstr);\n\t\tdel_result->errormessage = (errstr?talloc_strdup(del_reply,errstr):NULL);\n\t\tdel_result->referral = talloc_strdup(call, *res->refs);\n\t} else {\n\t\tdel_result->resultcode = result;\n\t\tdel_result->errormessage = (errstr?talloc_strdup(del_reply,errstr):NULL);\n\t\tdel_result->referral = NULL;\n\t}\n\ttalloc_free(local_ctx);\n\treturn ldapsrv_queue_reply(call, del_reply);\n}", "target": 0}
{"code": "unsigned long __ref init_memory_mapping(unsigned long start,\n\t\t\t\t\t       unsigned long end)\n{\n\tstruct map_range mr[NR_RANGE_MR];\n\tunsigned long ret = 0;\n\tint nr_range, i;\n\tpr_debug(\"init_memory_mapping: [mem %#010lx-%#010lx]\\n\",\n\t       start, end - 1);\n\tmemset(mr, 0, sizeof(mr));\n\tnr_range = split_mem_range(mr, 0, start, end);\n\tfor (i = 0; i < nr_range; i++)\n\t\tret = kernel_physical_mapping_init(mr[i].start, mr[i].end,\n\t\t\t\t\t\t   mr[i].page_size_mask);\n\tadd_pfn_range_mapped(start >> PAGE_SHIFT, ret >> PAGE_SHIFT);\n\treturn ret >> PAGE_SHIFT;\n}", "target": 0}
{"code": "GF_Err gf_isom_avc_config_new(GF_ISOFile *the_file, u32 trackNumber, GF_AVCConfig *cfg, const char *URLname, const char *URNname, u32 *outDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_SampleDescriptionBox *stsd;\n\tu32 dataRefIndex;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !cfg) return GF_BAD_PARAM;\n\te = Media_FindDataRef(trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\tif (e) return e;\n\tif (!dataRefIndex) {\n\t\te = Media_CreateDataRef(the_file, trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\t\tif (e) return e;\n\t}\n\tif (!the_file->keep_utc && !gf_sys_is_test_mode() )\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tentry = (GF_MPEGVisualSampleEntryBox *) gf_isom_box_new_parent(&stsd->child_boxes, GF_ISOM_BOX_TYPE_AVC1);\n\tif (!entry) return GF_OUT_OF_MEM;\n\t*outDescriptionIndex = gf_list_count(stsd->child_boxes);\n\tentry->avc_config = (GF_AVCConfigurationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_AVCC);\n\tif (!entry->avc_config) return GF_OUT_OF_MEM;\n\tentry->avc_config->config = AVC_DuplicateConfig(cfg);\n\tif (!entry->avc_config->config) return GF_OUT_OF_MEM;\n\tentry->dataReferenceIndex = dataRefIndex;\n\tAVC_RewriteESDescriptor(entry);\n\treturn e;\n}", "target": 0}
{"code": "static int __init nf_tables_module_init(void)\n{\n\tint err;\n\tinfo = kmalloc(sizeof(struct nft_expr_info) * NFT_RULE_MAXEXPRS,\n\t\t       GFP_KERNEL);\n\tif (info == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto err1;\n\t}\n\terr = nf_tables_core_module_init();\n\tif (err < 0)\n\t\tgoto err2;\n\terr = nfnetlink_subsys_register(&nf_tables_subsys);\n\tif (err < 0)\n\t\tgoto err3;\n\tpr_info(\"nf_tables: (c) 2007-2009 Patrick McHardy <kaber@trash.net>\\n\");\n\treturn register_pernet_subsys(&nf_tables_net_ops);\nerr3:\n\tnf_tables_core_module_exit();\nerr2:\n\tkfree(info);\nerr1:\n\treturn err;\n}", "target": 0}
{"code": "PHPAPI zval *var_tmp_var(php_unserialize_data_t *var_hashx)\n{\n    var_dtor_entries *var_hash;\n    if (!var_hashx || !*var_hashx) {\n        return NULL;\n    }\n    var_hash = (*var_hashx)->last_dtor;\n    if (!var_hash || var_hash->used_slots == VAR_ENTRIES_MAX) {\n        var_hash = emalloc(sizeof(var_dtor_entries));\n        var_hash->used_slots = 0;\n        var_hash->next = 0;\n        if (!(*var_hashx)->first_dtor) {\n            (*var_hashx)->first_dtor = var_hash;\n        } else {\n            ((var_dtor_entries *) (*var_hashx)->last_dtor)->next = var_hash;\n        }\n        (*var_hashx)->last_dtor = var_hash;\n    }\n    ZVAL_UNDEF(&var_hash->data[var_hash->used_slots]);\n    return &var_hash->data[var_hash->used_slots++];\n}", "target": 0}
{"code": "static inline int pmd_large(pmd_t pte)\n{\n\treturn (pmd_flags(pte) & (_PAGE_PSE | _PAGE_PRESENT)) ==\n\t\t(_PAGE_PSE | _PAGE_PRESENT);\n}", "target": 1}
{"code": "bool task_blocks_signal(pid_t pid, int signal)\n{\n\tint ret;\n\tchar status[__PROC_STATUS_LEN];\n\tFILE *f;\n\tuint64_t sigblk = 0, one = 1;\n\tsize_t n = 0;\n\tbool bret = false;\n\tchar *line = NULL;\n\tret = snprintf(status, __PROC_STATUS_LEN, \"/proc/%d/status\", pid);\n\tif (ret < 0 || ret >= __PROC_STATUS_LEN)\n\t\treturn bret;\n\tf = fopen(status, \"r\");\n\tif (!f)\n\t\treturn bret;\n\twhile (getline(&line, &n, f) != -1) {\n\t\tchar *numstr;\n\t\tif (strncmp(line, \"SigBlk:\", 7))\n\t\t\tcontinue;\n\t\tnumstr = lxc_trim_whitespace_in_place(line + 7);\n\t\tret = lxc_safe_uint64(numstr, &sigblk, 16);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tif (sigblk & (one << (signal - 1)))\n\t\tbret = true;\nout:\n\tfree(line);\n\tfclose(f);\n\treturn bret;\n}", "target": 0}
{"code": "int recursive_destroy(char *dirname)\n{\n\tint ret;\n\tstruct dirent *direntp;\n\tDIR *dir;\n\tint r = 0;\n\tdir = opendir(dirname);\n\tif (!dir)\n\t\treturn -1;\n\twhile ((direntp = readdir(dir))) {\n\t\tchar *pathname;\n\t\tstruct stat mystat;\n\t\tif (!strcmp(direntp->d_name, \".\") ||\n\t\t    !strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\t\tpathname = must_make_path(dirname, direntp->d_name, NULL);\n\t\tret = lstat(pathname, &mystat);\n\t\tif (ret < 0) {\n\t\t\tif (!r)\n\t\t\t\tWARN(\"Failed to stat \\\"%s\\\"\", pathname);\n\t\t\tr = -1;\n\t\t\tgoto next;\n\t\t}\n\t\tif (!S_ISDIR(mystat.st_mode))\n\t\t\tgoto next;\n\t\tret = recursive_destroy(pathname);\n\t\tif (ret < 0)\n\t\t\tr = -1;\n\tnext:\n\t\tfree(pathname);\n\t}\n\tret = rmdir(dirname);\n\tif (ret < 0) {\n\t\tif (!r)\n\t\t\tSYSWARN(\"Failed to delete \\\"%s\\\"\", dirname);\n\t\tr = -1;\n\t}\n\tret = closedir(dir);\n\tif (ret < 0) {\n\t\tif (!r)\n\t\t\tSYSWARN(\"Failed to delete \\\"%s\\\"\", dirname);\n\t\tr = -1;\n\t}\n\treturn r;\n}", "target": 0}
{"code": "static void finish_object(struct object *obj,\n\t\t\t  struct strbuf *path, const char *name,\n\t\t\t  void *cb_data)\n{\n\tstruct rev_list_info *info = cb_data;\n\tif (obj->type == OBJ_BLOB && !has_object_file(&obj->oid))\n\t\tdie(\"missing blob object '%s'\", oid_to_hex(&obj->oid));\n\tif (info->revs->verify_objects && !obj->parsed && obj->type != OBJ_COMMIT)\n\t\tparse_object(obj->oid.hash);\n}", "target": 1}
{"code": "__visible void kvm_lock_spinning(struct arch_spinlock *lock, __ticket_t want)\n{\n\tstruct kvm_lock_waiting *w;\n\tint cpu;\n\tu64 start;\n\tunsigned long flags;\n\tif (in_nmi())\n\t\treturn;\n\tw = this_cpu_ptr(&klock_waiting);\n\tcpu = smp_processor_id();\n\tstart = spin_time_start();\n\tlocal_irq_save(flags);\n\tw->lock = NULL;\n\tsmp_wmb();\n\tw->want = want;\n\tsmp_wmb();\n\tw->lock = lock;\n\tadd_stats(TAKEN_SLOW, 1);\n\tcpumask_set_cpu(cpu, &waiting_cpus);\n\tbarrier();\n\t__ticket_enter_slowpath(lock);\n\tif (ACCESS_ONCE(lock->tickets.head) == want) {\n\t\tadd_stats(TAKEN_SLOW_PICKUP, 1);\n\t\tgoto out;\n\t}\n\tif (arch_irqs_disabled_flags(flags))\n\t\thalt();\n\telse\n\t\tsafe_halt();\nout:\n\tcpumask_clear_cpu(cpu, &waiting_cpus);\n\tw->lock = NULL;\n\tlocal_irq_restore(flags);\n\tspin_time_accum_blocked(start);\n}", "target": 0}
{"code": "ff_layout_ntop6_noscopeid(const struct sockaddr *sap, char *buf,\n\t\t\t  const int buflen)\n{\n\tconst struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)sap;\n\tconst struct in6_addr *addr = &sin6->sin6_addr;\n\tif (ipv6_addr_any(addr))\n\t\treturn snprintf(buf, buflen, \"::\");\n\tif (ipv6_addr_loopback(addr))\n\t\treturn snprintf(buf, buflen, \"::1\");\n\tif (ipv6_addr_v4mapped(addr))\n\t\treturn snprintf(buf, buflen, \"::ffff:%pI4\",\n\t\t\t\t\t&addr->s6_addr32[3]);\n\treturn snprintf(buf, buflen, \"%pI6c\", addr);\n}", "target": 0}
{"code": "bool Monitor::ms_verify_authorizer(Connection *con, int peer_type,\n\t\t\t\t   int protocol, bufferlist& authorizer_data,\n\t\t\t\t   bufferlist& authorizer_reply,\n\t\t\t\t   bool& isvalid, CryptoKey& session_key)\n{\n  dout(10) << \"ms_verify_authorizer \" << con->get_peer_addr()\n\t   << \" \" << ceph_entity_type_name(peer_type)\n\t   << \" protocol \" << protocol << dendl;\n  if (is_shutdown())\n    return false;\n  if (peer_type == CEPH_ENTITY_TYPE_MON &&\n      auth_cluster_required.is_supported_auth(CEPH_AUTH_CEPHX)) {\n    isvalid = false;\n    if (protocol == CEPH_AUTH_CEPHX) {\n      bufferlist::iterator iter = authorizer_data.begin();\n      CephXServiceTicketInfo auth_ticket_info;\n      if (authorizer_data.length()) {\n\tbool ret = cephx_verify_authorizer(g_ceph_context, &keyring, iter,\n\t\t\t\t\t  auth_ticket_info, authorizer_reply);\n\tif (ret) {\n\t  session_key = auth_ticket_info.session_key;\n\t  isvalid = true;\n\t} else {\n\t  dout(0) << \"ms_verify_authorizer bad authorizer from mon \" << con->get_peer_addr() << dendl;\n        }\n      }\n    } else {\n      dout(0) << \"ms_verify_authorizer cephx enabled, but no authorizer (required for mon)\" << dendl;\n    }\n  } else {\n    isvalid = true;\n  }\n  return true;\n}", "target": 1}
{"code": "void ax25_fillin_cb(ax25_cb *ax25, ax25_dev *ax25_dev)\n{\n\tax25->ax25_dev = ax25_dev;\n\tif (ax25->ax25_dev != NULL) {\n\t\tax25_fillin_cb_from_dev(ax25, ax25_dev);\n\t\treturn;\n\t}\n\tax25->rtt     = msecs_to_jiffies(AX25_DEF_T1) / 2;\n\tax25->t1      = msecs_to_jiffies(AX25_DEF_T1);\n\tax25->t2      = msecs_to_jiffies(AX25_DEF_T2);\n\tax25->t3      = msecs_to_jiffies(AX25_DEF_T3);\n\tax25->n2      = AX25_DEF_N2;\n\tax25->paclen  = AX25_DEF_PACLEN;\n\tax25->idle    = msecs_to_jiffies(AX25_DEF_IDLE);\n\tax25->backoff = AX25_DEF_BACKOFF;\n\tif (AX25_DEF_AXDEFMODE) {\n\t\tax25->modulus = AX25_EMODULUS;\n\t\tax25->window  = AX25_DEF_EWINDOW;\n\t} else {\n\t\tax25->modulus = AX25_MODULUS;\n\t\tax25->window  = AX25_DEF_WINDOW;\n\t}\n}", "target": 0}
{"code": "get_stdinput(char *(*fn_readline)(const char *), void(*fn_addhist)(const char *))\n{\nint i;\ngstring * g = NULL;\nif (!fn_readline) { printf(\"> \"); fflush(stdout); }\nfor (i = 0;; i++)\n  {\n  uschar buffer[1024];\n  uschar *p, *ss;\n  #ifdef USE_READLINE\n  char *readline_line = NULL;\n  if (fn_readline != NULL)\n    {\n    if ((readline_line = fn_readline((i > 0)? \"\":\"> \")) == NULL) break;\n    if (*readline_line != 0 && fn_addhist != NULL) fn_addhist(readline_line);\n    p = US readline_line;\n    }\n  else\n  #endif\n    {\n    if (Ufgets(buffer, sizeof(buffer), stdin) == NULL) break;\n    p = buffer;\n    }\n  ss = p + (int)Ustrlen(p);\n  while (ss > p && isspace(ss[-1])) ss--;\n  if (i > 0)\n    {\n    while (p < ss && isspace(*p)) p++;   \n    }\n  g = string_catn(g, p, ss - p);\n  #ifdef USE_READLINE\n  if (fn_readline) free(readline_line);\n  #endif\n  if (ss == p || g->s[g->ptr-1] != '\\\\')\n    break;\n  --g->ptr;\n  (void) string_from_gstring(g);\n  }\nif (!g) printf(\"\\n\");\nreturn string_from_gstring(g);\n}", "target": 0}
{"code": "static int _make_remark(struct pwb_context *ctx,\n\t\t\tint type,\n\t\t\tconst char *text)\n{\n\tint retval = PAM_SUCCESS;\n\tstruct pam_message *pmsg[1], msg[1];\n\tstruct pam_response *resp;\n\tif (ctx->flags & WINBIND_SILENT) {\n\t\treturn PAM_SUCCESS;\n\t}\n\tpmsg[0] = &msg[0];\n\tmsg[0].msg = discard_const_p(char, text);\n\tmsg[0].msg_style = type;\n\tresp = NULL;\n\tretval = converse(ctx->pamh, 1, pmsg, &resp);\n\tif (resp) {\n\t\t_pam_drop_reply(resp, 1);\n\t}\n\treturn retval;\n}", "target": 0}
{"code": "int LibRaw_buffer_datastream::jpeg_src(void *jpegdata)\n{\n#if defined(NO_JPEG) || !defined(USE_JPEG)\n  return -1;\n#else\n  j_decompress_ptr cinfo = (j_decompress_ptr)jpegdata;\n  jpeg_mem_src(cinfo, (unsigned char *)buf + streampos, streamsize - streampos);\n  return 0;\n#endif\n}", "target": 0}
{"code": "void ZeroSuggestProvider::Run(const GURL& suggest_url) {\n  if (OmniboxFieldTrial::InZeroSuggestMostVisitedFieldTrial()) {\n    most_visited_urls_.clear();\n    scoped_refptr<history::TopSites> ts = client()->GetTopSites();\n    if (ts) {\n      waiting_for_most_visited_urls_request_ = true;\n      ts->GetMostVisitedURLs(\n          base::Bind(&ZeroSuggestProvider::OnMostVisitedUrlsAvailable,\n                     weak_ptr_factory_.GetWeakPtr()), false);\n    }\n  } else {\n    net::NetworkTrafficAnnotationTag traffic_annotation =\n        net::DefineNetworkTrafficAnnotation(\"omnibox_zerosuggest\", R\"(\n        semantics {\n          sender: \"Omnibox\"\n          description:\n            \"When the user focuses the omnibox, Chrome can provide search or \"\n            \"navigation suggestions from the default search provider in the \"\n            \"omnibox dropdown, based on the current page URL.\\n\"\n            \"This is limited to users whose default search engine is Google, \"\n            \"as no other search engines currently support this kind of \"\n            \"suggestion.\"\n          trigger: \"The omnibox receives focus.\"\n          data: \"The URL of the current page.\"\n          destination: GOOGLE_OWNED_SERVICE\n        }\n        policy {\n          cookies_allowed: true\n          cookies_store: \"user\"\n          setting:\n            \"Users can control this feature via the 'Use a prediction service \"\n            \"to help complete searches and URLs typed in the address bar' \"\n            \"settings under 'Privacy'. The feature is enabled by default.\"\n          chrome_policy {\n            SearchSuggestEnabled {\n                policy_options {mode: MANDATORY}\n                SearchSuggestEnabled: false\n            }\n          }\n        })\");\n    const int kFetcherID = 1;\n    fetcher_ =\n        net::URLFetcher::Create(kFetcherID, suggest_url, net::URLFetcher::GET,\n                                this, traffic_annotation);\n    data_use_measurement::DataUseUserData::AttachToFetcher(\n        fetcher_.get(), data_use_measurement::DataUseUserData::OMNIBOX);\n    fetcher_->SetRequestContext(client()->GetRequestContext());\n    fetcher_->SetLoadFlags(net::LOAD_DO_NOT_SAVE_COOKIES);\n    net::HttpRequestHeaders headers;\n    bool is_signed_in = false;\n    variations::AppendVariationHeaders(fetcher_->GetOriginalURL(),\n                                       client()->IsOffTheRecord(), false,\n                                       is_signed_in, &headers);\n    fetcher_->SetExtraRequestHeaders(headers.ToString());\n    fetcher_->Start();\n    LogOmniboxZeroSuggestRequest(ZERO_SUGGEST_REQUEST_SENT);\n  }\n}", "target": 0}
{"code": "static int cac_is_cert(cac_private_data_t * priv, const sc_path_t *in_path)\n{\n\tcac_object_t test_obj;\n\ttest_obj.path = *in_path;\n\ttest_obj.path.index = 0;\n\ttest_obj.path.count = 0;\n\treturn (list_contains(&priv->pki_list, &test_obj) != 0);\n}", "target": 0}
{"code": "TEST_F(LoaderTest, PbtxtFormat) {\n  SavedModelBundle bundle;\n  SessionOptions session_options;\n  RunOptions run_options;\n  const string export_dir =\n      io::JoinPath(testing::TensorFlowSrcRoot(), kTestDataPbTxt);\n  TF_ASSERT_OK(LoadSavedModel(session_options, run_options, export_dir,\n                              {kSavedModelTagServe}, &bundle));\n  CheckSavedModelBundle(export_dir, bundle);\n}", "target": 0}
{"code": "Bool gf_isom_is_identical_sgpd(void *ptr1, void *ptr2, u32 grouping_type)\n{\n\tBool res = GF_FALSE;\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tGF_BitStream *bs1, *bs2;\n\tu8 *buf1, *buf2;\n\tu32 len1, len2;\n\tif (!ptr1 || !ptr2)\n\t\treturn GF_FALSE;\n\tbs1 = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tif (grouping_type) {\n\t\tsgpd_write_entry(grouping_type, ptr1, bs1);\n\t} else {\n\t\tgf_isom_box_size((GF_Box *)ptr1);\n\t\tgf_isom_box_write((GF_Box *)ptr1, bs1);\n\t}\n\tgf_bs_get_content(bs1, &buf1, &len1);\n\tgf_bs_del(bs1);\n\tbs2 = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tif (grouping_type) {\n\t\tsgpd_write_entry(grouping_type, ptr2, bs2);\n\t} else {\n\t\tgf_isom_box_write((GF_Box *)ptr2, bs2);\n\t}\n\tgf_bs_get_content(bs2, &buf2, &len2);\n\tgf_bs_del(bs2);\n\tif ((len1==len2) && !memcmp(buf1, buf2, len1))\n\t\tres = GF_TRUE;\n\tgf_free(buf1);\n\tgf_free(buf2);\n#endif\n\treturn res;", "target": 0}
{"code": "static int ath10k_usb_hif_tx_sg(struct ath10k *ar, u8 pipe_id,\n\t\t\t\tstruct ath10k_hif_sg_item *items, int n_items)\n{\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\tstruct ath10k_usb_pipe *pipe = &ar_usb->pipes[pipe_id];\n\tstruct ath10k_urb_context *urb_context;\n\tstruct sk_buff *skb;\n\tstruct urb *urb;\n\tint ret, i;\n\tfor (i = 0; i < n_items; i++) {\n\t\turb_context = ath10k_usb_alloc_urb_from_pipe(pipe);\n\t\tif (!urb_context) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t\tskb = items[i].transfer_context;\n\t\turb_context->skb = skb;\n\t\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\t\tif (!urb) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_free_urb_to_pipe;\n\t\t}\n\t\tusb_fill_bulk_urb(urb,\n\t\t\t\t  ar_usb->udev,\n\t\t\t\t  pipe->usb_pipe_handle,\n\t\t\t\t  skb->data,\n\t\t\t\t  skb->len,\n\t\t\t\t  ath10k_usb_transmit_complete, urb_context);\n\t\tif (!(skb->len % pipe->max_packet_size)) {\n\t\t\turb->transfer_flags |= URB_ZERO_PACKET;\n\t\t}\n\t\tusb_anchor_urb(urb, &pipe->urb_submitted);\n\t\tret = usb_submit_urb(urb, GFP_ATOMIC);\n\t\tif (ret) {\n\t\t\tath10k_dbg(ar, ATH10K_DBG_USB_BULK,\n\t\t\t\t   \"usb bulk transmit failed: %d\\n\", ret);\n\t\t\tusb_unanchor_urb(urb);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_free_urb_to_pipe;\n\t\t}\n\t\tusb_free_urb(urb);\n\t}\n\treturn 0;\nerr_free_urb_to_pipe:\n\tath10k_usb_free_urb_to_pipe(urb_context->pipe, urb_context);\nerr:\n\treturn ret;\n}", "target": 1}
{"code": "static u32 nested_vmx_load_msr(struct kvm_vcpu *vcpu, u64 gpa, u32 count)\n{\n\tu32 i;\n\tstruct vmx_msr_entry e;\n\tstruct msr_data msr;\n\tmsr.host_initiated = false;\n\tfor (i = 0; i < count; i++) {\n\t\tif (kvm_vcpu_read_guest(vcpu, gpa + i * sizeof(e),\n\t\t\t\t\t&e, sizeof(e))) {\n\t\t\tpr_warn_ratelimited(\n\t\t\t\t\"%s cannot read MSR entry (%u, 0x%08llx)\\n\",\n\t\t\t\t__func__, i, gpa + i * sizeof(e));\n\t\t\tgoto fail;\n\t\t}\n\t\tif (nested_vmx_load_msr_check(vcpu, &e)) {\n\t\t\tpr_warn_ratelimited(\n\t\t\t\t\"%s check failed (%u, 0x%x, 0x%x)\\n\",\n\t\t\t\t__func__, i, e.index, e.reserved);\n\t\t\tgoto fail;\n\t\t}\n\t\tmsr.index = e.index;\n\t\tmsr.data = e.value;\n\t\tif (kvm_set_msr(vcpu, &msr)) {\n\t\t\tpr_warn_ratelimited(\n\t\t\t\t\"%s cannot write MSR (%u, 0x%x, 0x%llx)\\n\",\n\t\t\t\t__func__, i, e.index, e.value);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn 0;\nfail:\n\treturn i + 1;\n}", "target": 0}
{"code": "static unsigned short get_ushort(const unsigned char *data)\n{\n    unsigned short val = *(const unsigned short *)data;\n#ifdef OPJ_BIG_ENDIAN\n    val = ((val & 0xffU) << 8) | (val >> 8);\n#endif\n    return val;\n}", "target": 1}
{"code": "static int proc_fd_permission(struct inode *inode, int mask,\n\t\t\t\tstruct nameidata *nd)\n{\n\tint rv;\n\trv = generic_permission(inode, mask, NULL);\n\tif (rv == 0)\n\t\treturn 0;\n\tif (task_pid(current) == proc_pid(inode))\n\t\trv = 0;\n\treturn rv;\n}", "target": 0}
{"code": "snmpDecodePacket(SnmpRequest * rq)\n{\n    struct snmp_pdu *PDU;\n    u_char *Community;\n    u_char *buf = rq->buf;\n    int len = rq->len;\n    allow_t allow = ACCESS_DENIED;\n    if (!Config.accessList.snmp) {\n        debugs(49, DBG_IMPORTANT, \"WARNING: snmp_access not configured. agent query DENIED from : \" << rq->from);\n        return;\n    }\n    debugs(49, 5, HERE << \"Called.\");\n    PDU = snmp_pdu_create(0);\n    rq->session.Version = SNMP_VERSION_1;\n    Community = snmp_parse(&rq->session, PDU, buf, len);\n    if (Community) {\n        ACLFilledChecklist checklist(Config.accessList.snmp, NULL, NULL);\n        checklist.src_addr = rq->from;\n        checklist.snmp_community = (char *) Community;\n        allow = checklist.fastCheck();\n        if (allow == ACCESS_ALLOWED && (snmp_coexist_V2toV1(PDU))) {\n            rq->community = Community;\n            rq->PDU = PDU;\n            debugs(49, 5, \"snmpAgentParse: reqid=[\" << PDU->reqid << \"]\");\n            snmpConstructReponse(rq);\n        } else {\n            debugs(49, DBG_IMPORTANT, \"WARNING: SNMP agent query DENIED from : \" << rq->from);\n        }\n        xfree(Community);\n    } else {\n        debugs(49, DBG_IMPORTANT, \"WARNING: Failed SNMP agent query from : \" << rq->from);\n        snmp_free_pdu(PDU);\n    }\n}", "target": 1}
{"code": "  inline void init (hb_face_t *face,\n\t\t    hb_tag_t _hea_tag, hb_tag_t _mtx_tag,\n\t\t    unsigned int default_advance_)\n  {\n    this->default_advance = default_advance_;\n    this->num_metrics = face->get_num_glyphs ();\n    hb_blob_t *_hea_blob = OT::Sanitizer<OT::_hea>::sanitize (face->reference_table (_hea_tag));\n    const OT::_hea *_hea = OT::Sanitizer<OT::_hea>::lock_instance (_hea_blob);\n    this->num_advances = _hea->numberOfLongMetrics;\n    hb_blob_destroy (_hea_blob);\n    this->blob = OT::Sanitizer<OT::_mtx>::sanitize (face->reference_table (_mtx_tag));\n    if (unlikely (!this->num_advances ||\n\t\t  2 * (this->num_advances + this->num_metrics) < hb_blob_get_length (this->blob)))\n    {\n      this->num_metrics = this->num_advances = 0;\n      hb_blob_destroy (this->blob);\n      this->blob = hb_blob_get_empty ();\n    }\n    this->table = OT::Sanitizer<OT::_mtx>::lock_instance (this->blob);\n  }", "target": 1}
{"code": "const TfLiteTensor* GetOptionalInputTensor(const TfLiteContext* context,\n                                           const TfLiteNode* node, int index) {\n  const bool use_tensor = index < node->inputs->size &&\n                          node->inputs->data[index] != kTfLiteOptionalTensor;\n  if (use_tensor) {\n    return GetMutableInput(context, node, index);\n  }\n  return nullptr;\n}", "target": 1}
{"code": "TIFFWriteDirectoryTagCheckedSlong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, int64* value)\n{\n\tassert(count<0x20000000);\n\tassert(sizeof(int64)==8);\n\tif( !(tif->tif_flags&TIFF_BIGTIFF) ) {\n\t\tTIFFErrorExt(tif->tif_clientdata,\"TIFFWriteDirectoryTagCheckedSlong8Array\",\"SLONG8 not allowed for ClassicTIFF\");\n\t\treturn(0);\n\t}\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabArrayOfLong8((uint64*)value,count);\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_SLONG8,count,count*8,value));\n}", "target": 0}
{"code": "device_filesystem_set_label_authorized_cb (Daemon *daemon,\n                                           Device *device,\n                                           DBusGMethodInvocation *context,\n                                           const gchar *action_id,\n                                           guint num_user_data,\n                                           gpointer *user_data_elements)\n{\n  const gchar *new_label = user_data_elements[0];\n  int n;\n  char *argv[10];\n  const Filesystem *fs_details;\n  GError *error;\n  error = NULL;\n  if (device->priv->id_usage == NULL || strcmp (device->priv->id_usage, \"filesystem\") != 0)\n    {\n      throw_error (context, ERROR_FAILED, \"Not a mountable file system\");\n      goto out;\n    }\n  fs_details = daemon_local_get_fs_details (device->priv->daemon, device->priv->id_type);\n  if (fs_details == NULL)\n    {\n      throw_error (context, ERROR_BUSY, \"Unknown filesystem\");\n      goto out;\n    }\n  if (!fs_details->supports_online_label_rename)\n    {\n      if (device_local_is_busy (device, FALSE, &error))\n        {\n          dbus_g_method_return_error (context, error);\n          g_error_free (error);\n          goto out;\n        }\n    }\n  n = 0;\n  argv[n++] = \"udisks-helper-change-filesystem-label\";\n  argv[n++] = device->priv->device_file;\n  argv[n++] = device->priv->id_type;\n  argv[n++] = (char *) new_label;\n  argv[n++] = NULL;\n  if (!job_new (context,\n                \"FilesystemSetLabel\",\n                FALSE,\n                device,\n                argv,\n                NULL,\n                filesystem_set_label_completed_cb,\n                FALSE,\n                g_strdup (new_label),\n                g_free))\n    {\n      goto out;\n    }\n out:\n  ;\n}", "target": 0}
{"code": "void php_libxml_issue_error(int level, const char *msg TSRMLS_DC)\n{\n\tif (LIBXML(error_list)) {\n\t\t_php_list_set_error_structure(NULL, msg);\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, level, \"%s\", msg);\n\t}\n}", "target": 0}
{"code": "BOOL lmtp_transport_entry(transport_instance *tblock, address_item *addr) {return FALSE;}", "target": 0}
{"code": "static int update_private_key(const u8 *key, size_t keysize)\n{\n\tint r, idx = 0;\n\tsc_path_t path;\n\tr = select_app_df();\n\tif (r)\n\t\treturn 1;\n\tsc_format_path(\"I0012\", &path);\n\tr = sc_select_file(card, &path, NULL);\n\tif (r) {\n\t\tfprintf(stderr, \"Unable to select private key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\tidx = keysize * (opt_key_num-1);\n\tr = sc_update_binary(card, idx, key, keysize, 0);\n\tif (r < 0) {\n\t\tfprintf(stderr, \"Unable to write private key: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static inline unsigned char unimap_bsearch(const uni_to_enc *table, unsigned code_key_a, size_t num)\n{\n\tconst uni_to_enc *l = table,\n\t\t\t\t\t *h = &table[num-1],\n\t\t\t\t\t *m;\n\tunsigned short code_key;\n\tif (code_key_a > 0xFFFFU)\n\t\treturn 0;\n\tcode_key = (unsigned short) code_key_a;\n\twhile (l <= h) {\n\t\tm = l + (h - l) / 2;\n\t\tif (code_key < m->un_code_point)\n\t\t\th = m - 1;\n\t\telse if (code_key > m->un_code_point)\n\t\t\tl = m + 1;\n\t\telse\n\t\t\treturn m->cs_code;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int vidioc_s_std(struct file *file, void *private_data, v4l2_std_id *_std)\n{\n\tv4l2_std_id req_std = 0, supported_std = 0;\n\tconst v4l2_std_id all_std = V4L2_STD_ALL, no_std = 0;\n\tif (_std) {\n\t\treq_std = *_std;\n\t\t*_std = all_std;\n\t}\n\tsupported_std = (all_std & req_std);\n\tif (no_std == supported_std)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 0}
{"code": "int unit_name_to_prefix(const char *n, char **ret) {\n        const char *p;\n        char *s;\n        assert(n);\n        assert(ret);\n        if (!unit_name_is_valid(n, UNIT_NAME_ANY))\n                return -EINVAL;\n        p = strchr(n, '@');\n        if (!p)\n                p = strrchr(n, '.');\n        assert_se(p);\n        s = strndup(n, p - n);\n        if (!s)\n                return -ENOMEM;\n        *ret = s;\n        return 0;\n}", "target": 0}
{"code": "int wsrep_sst_donate(const std::string &msg, const wsrep::gtid &current_gtid,\n                     const bool bypass) {\n  local_status.set(wsrep::server_state::s_donor);\n  const char *method = msg.data();\n  size_t method_len = strlen(method);\n  const char *data = method + method_len + 1;\n  wsp::env env(NULL);\n  if (env.error()) {\n    WSREP_ERROR(\"wsrep_sst_donate_cb(): env var ctor failed: %d\", -env.error());\n    return WSREP_CB_FAILURE;\n  }\n#if 0\n  while (!wsrep_is_SE_initialized()) {\n    sleep(1);\n    THD *applier_thd = static_cast<THD *>(recv_ctx);\n    if (applier_thd->killed == THD::KILL_CONNECTION) return WSREP_CB_FAILURE;\n  }\n#endif\n  int ret;\n  ret = sst_donate_other(method, data, current_gtid, bypass, env());\n  return (ret >= 0 ? WSREP_CB_SUCCESS : WSREP_CB_FAILURE);\n}", "target": 1}
{"code": "static void nfs4_return_incompatible_delegation(struct inode *inode, mode_t open_flags)\n{\n\tstruct nfs_delegation *delegation;\n\trcu_read_lock();\n\tdelegation = rcu_dereference(NFS_I(inode)->delegation);\n\tif (delegation == NULL || (delegation->type & open_flags) == open_flags) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\trcu_read_unlock();\n\tnfs_inode_return_delegation(inode);\n}", "target": 1}
{"code": "rsa_compute_root_tr(const struct rsa_public_key *pub,\n\t\t    const struct rsa_private_key *key,\n\t\t    void *random_ctx, nettle_random_func *random,\n\t\t    mpz_t x, const mpz_t m)\n{\n  int res;\n  mpz_t t, mb, xb, ri;\n  mpz_init (mb);\n  mpz_init (xb);\n  mpz_init (ri);\n  mpz_init (t);\n  rsa_blind (pub, random_ctx, random, mb, ri, m);\n  rsa_compute_root (key, xb, mb);\n  mpz_powm_sec(t, xb, pub->e, pub->n);\n  res = (mpz_cmp(mb, t) == 0);\n  if (res)\n    rsa_unblind (pub, x, ri, xb);\n  mpz_clear (mb);\n  mpz_clear (xb);\n  mpz_clear (ri);\n  mpz_clear (t);\n  return res;\n}", "target": 1}
{"code": "mrb_class_real(struct RClass* cl)\n{\n  if (cl == 0)\n    return NULL;\n  while ((cl->tt == MRB_TT_SCLASS) || (cl->tt == MRB_TT_ICLASS)) {\n    cl = cl->super;\n  }\n  return cl;\n}", "target": 1}
{"code": "inline typename V::VariantType FBUnserializer<V>::unserialize(\n  folly::StringPiece serialized) {\n  FBUnserializer<V> unserializer(serialized);\n  return unserializer.unserializeThing();\n}", "target": 1}
{"code": "spnego_gss_pseudo_random(OM_uint32 *minor_status,\n\t\t\t gss_ctx_id_t context,\n\t\t\t int prf_key,\n\t\t\t const gss_buffer_t prf_in,\n\t\t\t ssize_t desired_output_len,\n\t\t\t gss_buffer_t prf_out)\n{\n\tOM_uint32 ret;\n\tret = gss_pseudo_random(minor_status,\n\t\t\t\tcontext,\n\t\t\t\tprf_key,\n\t\t\t\tprf_in,\n\t\t\t\tdesired_output_len,\n\t\t\t\tprf_out);\n        return (ret);\n}", "target": 1}
{"code": "struct net *get_net_ns_by_id(struct net *net, int id)\n{\n\tstruct net *peer;\n\tif (id < 0)\n\t\treturn NULL;\n\trcu_read_lock();\n\tspin_lock_bh(&net->nsid_lock);\n\tpeer = idr_find(&net->netns_ids, id);\n\tif (peer)\n\t\tget_net(peer);\n\tspin_unlock_bh(&net->nsid_lock);\n\trcu_read_unlock();\n\treturn peer;\n}", "target": 1}
{"code": "mm_sshpam_respond(void *ctx, u_int num, char **resp)\n{\n\tBuffer m;\n\tint i, ret;\n\tdebug3(\"%s\", __func__);\n\tbuffer_init(&m);\n\tbuffer_put_int(&m, num);\n\tfor (i = 0; i < num; ++i)\n\t\tbuffer_put_cstring(&m, resp[i]);\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_PAM_RESPOND, &m);\n\tdebug3(\"%s: waiting for MONITOR_ANS_PAM_RESPOND\", __func__);\n\tmm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_PAM_RESPOND, &m);\n\tret = buffer_get_int(&m);\n\tdebug3(\"%s: pam_respond returned %d\", __func__, ret);\n\tbuffer_free(&m);\n\treturn (ret);\n}", "target": 0}
{"code": "void ion_free(struct ion_client *client, struct ion_handle *handle)\n{\n\tbool valid_handle;\n\tBUG_ON(client != handle->client);\n\tmutex_lock(&client->lock);\n\tvalid_handle = ion_handle_validate(client, handle);\n\tif (!valid_handle) {\n\t\tWARN(1, \"%s: invalid handle passed to free.\\n\", __func__);\n\t\tmutex_unlock(&client->lock);\n\t\treturn;\n\t}\n\tmutex_unlock(&client->lock);\n\tion_handle_put(handle);\n}", "target": 1}
{"code": "lsquic_qeh_settings (struct qpack_enc_hdl *qeh, unsigned max_table_size,\n             unsigned dyn_table_size, unsigned max_risked_streams, int server)\n{\n    enum lsqpack_enc_opts enc_opts;\n    assert(qeh->qeh_flags & QEH_INITIALIZED);\n    if (qeh->qeh_flags & QEH_HAVE_SETTINGS)\n    {\n        LSQ_WARN(\"settings already set\");\n        return -1;\n    }\n    enc_opts = LSQPACK_ENC_OPT_STAGE_2\n             | (server ? LSQPACK_ENC_OPT_SERVER : 0);\n    qeh->qeh_tsu_sz = sizeof(qeh->qeh_tsu_buf);\n    if (QENC_MIN_DYN_TABLE_SIZE > dyn_table_size)\n        dyn_table_size = 0;\n    if (0 != lsqpack_enc_init(&qeh->qeh_encoder, (void *) qeh->qeh_conn,\n                max_table_size, dyn_table_size, max_risked_streams, enc_opts,\n                qeh->qeh_tsu_buf, &qeh->qeh_tsu_sz))\n    {\n        LSQ_INFO(\"could not initialize QPACK encoder\");\n        return -1;\n    }\n    LSQ_DEBUG(\"%zu-byte post-init TSU\", qeh->qeh_tsu_sz);\n    qeh->qeh_flags |= QEH_HAVE_SETTINGS;\n    qeh->qeh_max_prefix_size =\n                        lsqpack_enc_header_block_prefix_size(&qeh->qeh_encoder);\n    LSQ_DEBUG(\"have settings: max table size=%u; dyn table size=%u; max risked \"\n        \"streams=%u\", max_table_size, dyn_table_size, max_risked_streams);\n    if (qeh->qeh_enc_sm_out)\n        qeh_begin_out(qeh);\n    return 0;\n}", "target": 0}
{"code": "static int encode_open_downgrade(struct xdr_stream *xdr, const struct nfs_closeargs *arg)\n{\n\t__be32 *p;\n\tRESERVE_SPACE(4+NFS4_STATEID_SIZE+4);\n\tWRITE32(OP_OPEN_DOWNGRADE);\n\tWRITEMEM(arg->stateid->data, NFS4_STATEID_SIZE);\n\tWRITE32(arg->seqid->sequence->counter);\n\tencode_share_access(xdr, arg->open_flags);\n\treturn 0;\n}", "target": 1}
{"code": "static int packet_sendmsg(struct kiocb *iocb, struct socket *sock,\n\t\tstruct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct packet_sock *po = pkt_sk(sk);\n\tif (po->tx_ring.pg_vec)\n\t\treturn tpacket_snd(po, msg);\n\telse\n\t\treturn packet_snd(sock, msg, len);\n}", "target": 0}
{"code": "SPL_METHOD(SplDoublyLinkedList, offsetSet)\n{\n\tzval                  *zindex, *value;\n\tspl_dllist_object     *intern;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"zz\", &zindex, &value) == FAILURE) {\n\t\treturn;\n\t}\n\tintern = Z_SPLDLLIST_P(getThis());\n\tif (Z_TYPE_P(zindex) == IS_NULL) {\n\t\tspl_ptr_llist_push(intern->llist, value);\n\t} else {\n\t\tzend_long                   index;\n\t\tspl_ptr_llist_element *element;\n\t\tindex = spl_offset_convert_to_long(zindex);\n\t\tif (index < 0 || index >= intern->llist->count) {\n\t\t\tzval_ptr_dtor(value);\n\t\t\tzend_throw_exception(spl_ce_OutOfRangeException, \"Offset invalid or out of range\", 0);\n\t\t\treturn;\n\t\t}\n\t\telement = spl_ptr_llist_offset(intern->llist, index, intern->flags & SPL_DLLIST_IT_LIFO);\n\t\tif (element != NULL) {\n\t\t\tif (intern->llist->dtor) {\n\t\t\t\tintern->llist->dtor(element);\n\t\t\t}\n\t\t\tzval_ptr_dtor(&element->data);\n\t\t\tZVAL_COPY_VALUE(&element->data, value);\n\t\t\tif (intern->llist->ctor) {\n\t\t\t\tintern->llist->ctor(element);\n\t\t\t}\n\t\t} else {\n\t\t\tzval_ptr_dtor(value);\n\t\t\tzend_throw_exception(spl_ce_OutOfRangeException, \"Offset invalid\", 0);\n\t\t\treturn;\n\t\t}\n\t}\n} ", "target": 1}
{"code": "static inline struct futex_hash_bucket *queue_lock(struct futex_q *q)\n{\n\tstruct futex_hash_bucket *hb;\n\tget_futex_key_refs(&q->key);\n\thb = hash_futex(&q->key);\n\tq->lock_ptr = &hb->lock;\n\tspin_lock(&hb->lock);\n\treturn hb;\n}", "target": 1}
{"code": "size_t TensorSliceWriter::MaxBytesPerElement(DataType dt) {\n  switch (dt) {\n    case DT_FLOAT:\n      return 4;\n    case DT_DOUBLE:\n      return 8;\n    case DT_INT32:\n      return 10;\n    case DT_UINT8:\n      return 2;\n    case DT_INT16:\n      return 10;\n    case DT_INT8:\n      return 10;\n    case DT_COMPLEX64:\n      return 8;\n    case DT_INT64:\n      return 10;\n    case DT_BOOL:\n      return 1;\n    case DT_QINT8:\n      return 10;\n    case DT_QUINT8:\n      return 2;\n    case DT_QINT32:\n      return 10;\n    case DT_QINT16:\n      return 10;\n    case DT_QUINT16:\n      return 3;\n    case DT_UINT16:\n      return 3;\n    case DT_COMPLEX128:\n      return 16;\n    case DT_HALF:\n      return 3;\n    case DT_INVALID:\n    case DT_STRING:\n    case DT_BFLOAT16:\n    default:\n      LOG(FATAL) << \"MaxBytesPerElement not implemented for dtype: \" << dt;\n  }\n  return 0;\n}", "target": 1}
{"code": "static void opl3_setup_voice(int dev, int voice, int chn)\n{\n\tstruct channel_info *info =\n\t&synth_devs[dev]->chn_info[chn];\n\topl3_set_instr(dev, voice, info->pgm_num);\n\tdevc->voc[voice].bender = 0;\n\tdevc->voc[voice].bender_range = info->bender_range;\n\tdevc->voc[voice].volume = info->controllers[CTL_MAIN_VOLUME];\n\tdevc->voc[voice].panning = (info->controllers[CTL_PAN] * 2) - 128;\n}", "target": 1}
{"code": "mt76_add_fragment(struct mt76_dev *dev, struct mt76_queue *q, void *data,\n\t\t  int len, bool more)\n{\n\tstruct page *page = virt_to_head_page(data);\n\tint offset = data - page_address(page);\n\tstruct sk_buff *skb = q->rx_head;\n\toffset += q->buf_offset;\n\tskb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags, page, offset, len,\n\t\t\tq->buf_size);\n\tif (more)\n\t\treturn;\n\tq->rx_head = NULL;\n\tdev->drv->rx_skb(dev, q - dev->q_rx, skb);\n}", "target": 1}
{"code": "static struct page **sev_pin_memory(struct kvm *kvm, unsigned long uaddr,\n\t\t\t\t    unsigned long ulen, unsigned long *n,\n\t\t\t\t    int write)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tunsigned long npages, size;\n\tint npinned;\n\tunsigned long locked, lock_limit;\n\tstruct page **pages;\n\tunsigned long first, last;\n\tint ret;\n\tif (ulen == 0 || uaddr + ulen < uaddr)\n\t\treturn ERR_PTR(-EINVAL);\n\tfirst = (uaddr & PAGE_MASK) >> PAGE_SHIFT;\n\tlast = ((uaddr + ulen - 1) & PAGE_MASK) >> PAGE_SHIFT;\n\tnpages = (last - first + 1);\n\tlocked = sev->pages_locked + npages;\n\tlock_limit = rlimit(RLIMIT_MEMLOCK) >> PAGE_SHIFT;\n\tif (locked > lock_limit && !capable(CAP_IPC_LOCK)) {\n\t\tpr_err(\"SEV: %lu locked pages exceed the lock limit of %lu.\\n\", locked, lock_limit);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tif (WARN_ON_ONCE(npages > INT_MAX))\n\t\treturn ERR_PTR(-EINVAL);\n\tsize = npages * sizeof(struct page *);\n\tif (size > PAGE_SIZE)\n\t\tpages = __vmalloc(size, GFP_KERNEL_ACCOUNT | __GFP_ZERO);\n\telse\n\t\tpages = kmalloc(size, GFP_KERNEL_ACCOUNT);\n\tif (!pages)\n\t\treturn ERR_PTR(-ENOMEM);\n\tnpinned = pin_user_pages_fast(uaddr, npages, write ? FOLL_WRITE : 0, pages);\n\tif (npinned != npages) {\n\t\tpr_err(\"SEV: Failure locking %lu pages.\\n\", npages);\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\t*n = npages;\n\tsev->pages_locked = locked;\n\treturn pages;\nerr:\n\tif (npinned > 0)\n\t\tunpin_user_pages(pages, npinned);\n\tkvfree(pages);\n\treturn ERR_PTR(ret);\n}", "target": 0}
{"code": "static void sco_conn_ready(struct sco_conn *conn)\n{\n\tstruct sock *parent;\n\tstruct sock *sk = conn->sk;\n\tBT_DBG(\"conn %p\", conn);\n\tif (sk) {\n\t\tlock_sock(sk);\n\t\tsco_sock_clear_timer(sk);\n\t\tsk->sk_state = BT_CONNECTED;\n\t\tsk->sk_state_change(sk);\n\t\trelease_sock(sk);\n\t} else {\n\t\tsco_conn_lock(conn);\n\t\tif (!conn->hcon) {\n\t\t\tsco_conn_unlock(conn);\n\t\t\treturn;\n\t\t}\n\t\tparent = sco_get_sock_listen(&conn->hcon->src);\n\t\tif (!parent) {\n\t\t\tsco_conn_unlock(conn);\n\t\t\treturn;\n\t\t}\n\t\tlock_sock(parent);\n\t\tsk = sco_sock_alloc(sock_net(parent), NULL,\n\t\t\t\t    BTPROTO_SCO, GFP_ATOMIC, 0);\n\t\tif (!sk) {\n\t\t\trelease_sock(parent);\n\t\t\tsco_conn_unlock(conn);\n\t\t\treturn;\n\t\t}\n\t\tsco_sock_init(sk, parent);\n\t\tbacpy(&sco_pi(sk)->src, &conn->hcon->src);\n\t\tbacpy(&sco_pi(sk)->dst, &conn->hcon->dst);\n\t\thci_conn_hold(conn->hcon);\n\t\t__sco_chan_add(conn, sk, parent);\n\t\tif (test_bit(BT_SK_DEFER_SETUP, &bt_sk(parent)->flags))\n\t\t\tsk->sk_state = BT_CONNECT2;\n\t\telse\n\t\t\tsk->sk_state = BT_CONNECTED;\n\t\tparent->sk_data_ready(parent);\n\t\trelease_sock(parent);\n\t\tsco_conn_unlock(conn);\n\t}\n}", "target": 0}
{"code": "static int stv06xx_isoc_init(struct gspca_dev *gspca_dev)\n{\n\tstruct usb_host_interface *alt;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\talt = &gspca_dev->dev->actconfig->intf_cache[0]->altsetting[1];\n\talt->endpoint[0].desc.wMaxPacketSize =\n\t\tcpu_to_le16(sd->sensor->max_packet_size[gspca_dev->curr_mode]);\n\treturn 0;\n}", "target": 1}
{"code": "rfbSendServerCutText(rfbScreenInfoPtr rfbScreen,char *str, int len)\n{\n    rfbClientPtr cl;\n    rfbServerCutTextMsg sct;\n    rfbClientIteratorPtr iterator;\n    iterator = rfbGetClientIterator(rfbScreen);\n    while ((cl = rfbClientIteratorNext(iterator)) != NULL) {\n        sct.type = rfbServerCutText;\n        sct.length = Swap32IfLE(len);\n        if (WriteExact(cl, (char *)&sct,\n                       sz_rfbServerCutTextMsg) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n            continue;\n        }\n        if (WriteExact(cl, str, len) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n        }\n    }\n    rfbReleaseClientIterator(iterator);\n}", "target": 1}
{"code": "SWFInput_file_getChar(SWFInput input)\n{\n\tint c = fgetc((FILE *)input->data);\n\tif ( c == EOF )\n\t\tinput->length = input->offset;\n\telse\n\t\t++input->offset;\n\treturn c;\n}", "target": 0}
{"code": "struct dentry *debugfs_rename(struct dentry *old_dir, struct dentry *old_dentry,\n\t\tstruct dentry *new_dir, const char *new_name)\n{\n\tint error;\n\tstruct dentry *dentry = NULL, *trap;\n\tconst char *old_name;\n\ttrap = lock_rename(new_dir, old_dir);\n\tif (d_really_is_negative(old_dir) || d_really_is_negative(new_dir))\n\t\tgoto exit;\n\tif (d_really_is_negative(old_dentry) || old_dentry == trap ||\n\t    d_mountpoint(old_dentry))\n\t\tgoto exit;\n\tdentry = lookup_one_len(new_name, new_dir, strlen(new_name));\n\tif (IS_ERR(dentry) || dentry == trap || d_really_is_positive(dentry))\n\t\tgoto exit;\n\told_name = fsnotify_oldname_init(old_dentry->d_name.name);\n\terror = simple_rename(d_inode(old_dir), old_dentry, d_inode(new_dir),\n\t\t\t      dentry, 0);\n\tif (error) {\n\t\tfsnotify_oldname_free(old_name);\n\t\tgoto exit;\n\t}\n\td_move(old_dentry, dentry);\n\tfsnotify_move(d_inode(old_dir), d_inode(new_dir), old_name,\n\t\td_is_dir(old_dentry),\n\t\tNULL, old_dentry);\n\tfsnotify_oldname_free(old_name);\n\tunlock_rename(new_dir, old_dir);\n\tdput(dentry);\n\treturn old_dentry;\nexit:\n\tif (dentry && !IS_ERR(dentry))\n\t\tdput(dentry);\n\tunlock_rename(new_dir, old_dir);\n\treturn NULL;\n}", "target": 1}
{"code": "int sas_discover_end_dev(struct domain_device *dev)\n{\n\tint res;\n\tres = sas_notify_lldd_dev_found(dev);\n\tif (res)\n\t\treturn res;\n\tsas_discover_event(dev->port, DISCE_PROBE);\n\treturn 0;\n}", "target": 1}
{"code": "RsaAdjustPrimeCandidate(\n\t\t\tbigNum          prime,\n\t\t\tSEED_COMPAT_LEVEL seedCompatLevel  \n\t\t\t)\n{\n    switch (seedCompatLevel) {\n    case SEED_COMPAT_LEVEL_ORIGINAL:\n        RsaAdjustPrimeCandidate_PreRev155(prime);\n        break;\n    case SEED_COMPAT_LEVEL_RSA_PRIME_ADJUST_FIX:\n        RsaAdjustPrimeCandidate_New(prime);\n        break;\n    default:\n        FAIL(FATAL_ERROR_INTERNAL);\n    }\n}", "target": 1}
{"code": "static void FNAME_DECL(uncompress_row0_seg)(int i,\n                                            PIXEL * const cur_row,\n                                            const int end,\n                                            const unsigned int waitmask,\n                                            const unsigned int bpc_mask)\n{\n    DECLARE_STATE_VARIABLES;\n    DECLARE_CHANNEL_VARIABLES;\n    int stopidx;\n    spice_assert(end - i > 0);\n    if (i == 0) {\n        unsigned int codewordlen;\n        UNCOMPRESS_PIX_START(&cur_row[i]);\n        APPLY_ALL_COMP(UNCOMPRESS_ONE_ROW0_0);\n        if (state->waitcnt) {\n            --state->waitcnt;\n        } else {\n            state->waitcnt = (tabrand(&state->tabrand_seed) & waitmask);\n            UPDATE_MODEL(0);\n        }\n        stopidx = ++i + state->waitcnt;\n    } else {\n        stopidx = i + state->waitcnt;\n    }\n    while (stopidx < end) {\n        for (; i <= stopidx; i++) {\n            unsigned int codewordlen;\n            UNCOMPRESS_PIX_START(&cur_row[i]);\n            APPLY_ALL_COMP(UNCOMPRESS_ONE_ROW0);\n        }\n        UPDATE_MODEL(stopidx);\n        stopidx = i + (tabrand(&state->tabrand_seed) & waitmask);\n    }\n    for (; i < end; i++) {\n        unsigned int codewordlen;\n        UNCOMPRESS_PIX_START(&cur_row[i]);\n        APPLY_ALL_COMP(UNCOMPRESS_ONE_ROW0);\n    }\n    state->waitcnt = stopidx - end;\n}", "target": 0}
{"code": "check_entry_size_and_hooks(struct ipt_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct ipt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ipt_entry) >= limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct ipt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_err(\"Underflows must be unconditional and \"\n\t\t\t\t       \"use the STANDARD target with \"\n\t\t\t\t       \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 1}
{"code": "static int jsR_delproperty(js_State *J, js_Object *obj, const char *name)\n{\n\tjs_Property *ref;\n\tint k;\n\tif (obj->type == JS_CARRAY) {\n\t\tif (!strcmp(name, \"length\"))\n\t\t\tgoto dontconf;\n\t}\n\telse if (obj->type == JS_CSTRING) {\n\t\tif (!strcmp(name, \"length\"))\n\t\t\tgoto dontconf;\n\t\tif (js_isarrayindex(J, name, &k))\n\t\t\tif (js_runeat(J, obj->u.s.string, k))\n\t\t\t\tgoto dontconf;\n\t}\n\telse if (obj->type == JS_CREGEXP) {\n\t\tif (!strcmp(name, \"source\")) goto dontconf;\n\t\tif (!strcmp(name, \"global\")) goto dontconf;\n\t\tif (!strcmp(name, \"ignoreCase\")) goto dontconf;\n\t\tif (!strcmp(name, \"multiline\")) goto dontconf;\n\t\tif (!strcmp(name, \"lastIndex\")) goto dontconf;\n\t}\n\telse if (obj->type == JS_CUSERDATA) {\n\t\tif (obj->u.user.delete && obj->u.user.delete(J, obj->u.user.data, name))\n\t\t\treturn 1;\n\t}\n\tref = jsV_getownproperty(J, obj, name);\n\tif (ref) {\n\t\tif (ref->atts & JS_DONTCONF)\n\t\t\tgoto dontconf;\n\t\tjsV_delproperty(J, obj, name);\n\t}\n\treturn 1;\ndontconf:\n\tif (J->strict)\n\t\tjs_typeerror(J, \"'%s' is non-configurable\", name);\n\treturn 0;\n}", "target": 0}
{"code": "flatpak_run_extend_ld_path (FlatpakBwrap *bwrap,\n                            const char *prepend,\n                            const char *append)\n{\n  g_autoptr(GString) ld_library_path = g_string_new (g_environ_getenv (bwrap->envp, \"LD_LIBRARY_PATH\"));\n  if (prepend != NULL && *prepend != '\\0')\n    {\n      if (ld_library_path->len > 0)\n        g_string_prepend (ld_library_path, \":\");\n      g_string_prepend (ld_library_path, prepend);\n    }\n  if (append != NULL && *append != '\\0')\n    {\n      if (ld_library_path->len > 0)\n        g_string_append (ld_library_path, \":\");\n      g_string_append (ld_library_path, append);\n    }\n  flatpak_bwrap_set_env (bwrap, \"LD_LIBRARY_PATH\", ld_library_path->str, TRUE);\n}", "target": 0}
{"code": "MONGO_EXPORT int bson_append_binary( bson *b, const char *name, char type, const char *str, int len ) {\n    if ( type == BSON_BIN_BINARY_OLD ) {\n        int subtwolen = len + 4;\n        if ( bson_append_estart( b, BSON_BINDATA, name, 4+1+4+len ) == BSON_ERROR )\n            return BSON_ERROR;\n        bson_append32( b, &subtwolen );\n        bson_append_byte( b, type );\n        bson_append32( b, &len );\n        bson_append( b, str, len );\n    }\n    else {\n        if ( bson_append_estart( b, BSON_BINDATA, name, 4+1+len ) == BSON_ERROR )\n            return BSON_ERROR;\n        bson_append32( b, &len );\n        bson_append_byte( b, type );\n        bson_append( b, str, len );\n    }\n    return BSON_OK;\n}", "target": 1}
{"code": "static zend_bool php_auto_globals_create_request(const char *name, uint name_len TSRMLS_DC)\n{\n\tzval *form_variables;\n\tunsigned char _gpc_flags[3] = {0, 0, 0};\n\tchar *p;\n\tALLOC_ZVAL(form_variables);\n\tarray_init(form_variables);\n\tINIT_PZVAL(form_variables);\n\tif (PG(request_order) != NULL) {\n\t\tp = PG(request_order);\n\t} else {\n\t\tp = PG(variables_order);\n\t}\n\tfor (; p && *p; p++) {\n\t\tswitch (*p) {\n\t\t\tcase 'g':\n\t\t\tcase 'G':\n\t\t\t\tif (!_gpc_flags[0]) {\n\t\t\t\t\tphp_autoglobal_merge(Z_ARRVAL_P(form_variables), Z_ARRVAL_P(PG(http_globals)[TRACK_VARS_GET]) TSRMLS_CC);\n\t\t\t\t\t_gpc_flags[0] = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\tcase 'P':\n\t\t\t\tif (!_gpc_flags[1]) {\n\t\t\t\t\tphp_autoglobal_merge(Z_ARRVAL_P(form_variables), Z_ARRVAL_P(PG(http_globals)[TRACK_VARS_POST]) TSRMLS_CC);\n\t\t\t\t\t_gpc_flags[1] = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\tcase 'C':\n\t\t\t\tif (!_gpc_flags[2]) {\n\t\t\t\t\tphp_autoglobal_merge(Z_ARRVAL_P(form_variables), Z_ARRVAL_P(PG(http_globals)[TRACK_VARS_COOKIE]) TSRMLS_CC);\n\t\t\t\t\t_gpc_flags[2] = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tzend_hash_update(&EG(symbol_table), name, name_len + 1, &form_variables, sizeof(zval *), NULL);\n\treturn 0;\n}", "target": 0}
{"code": "xmlCopyAttribute(xmlAttributePtr attr) {\n    xmlAttributePtr cur;\n    cur = (xmlAttributePtr) xmlMalloc(sizeof(xmlAttribute));\n    if (cur == NULL) {\n\txmlVErrMemory(NULL, \"malloc failed\");\n\treturn(NULL);\n    }\n    memset(cur, 0, sizeof(xmlAttribute));\n    cur->type = XML_ATTRIBUTE_DECL;\n    cur->atype = attr->atype;\n    cur->def = attr->def;\n    cur->tree = xmlCopyEnumeration(attr->tree);\n    if (attr->elem != NULL)\n\tcur->elem = xmlStrdup(attr->elem);\n    if (attr->name != NULL)\n\tcur->name = xmlStrdup(attr->name);\n    if (attr->prefix != NULL)\n\tcur->prefix = xmlStrdup(attr->prefix);\n    if (attr->defaultValue != NULL)\n\tcur->defaultValue = xmlStrdup(attr->defaultValue);\n    return(cur);\n}", "target": 0}
{"code": "static int can_open_delegated(struct nfs_delegation *delegation, mode_t open_flags)\n{\n\tif ((delegation->type & open_flags) != open_flags)\n\t\treturn 0;\n\tif (test_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags))\n\t\treturn 0;\n\tnfs_mark_delegation_referenced(delegation);\n\treturn 1;\n}", "target": 1}
{"code": "fname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  \n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n    if (name != NULL)\n    {\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse\n\t{\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n    return match;\n}", "target": 1}
{"code": "elg_encrypt (int algo, gcry_mpi_t *resarr,\n             gcry_mpi_t data, gcry_mpi_t *pkey, int flags)\n{\n  gcry_err_code_t err = GPG_ERR_NO_ERROR;\n  ELG_public_key pk;\n  (void)algo;\n  (void)flags;\n  if ((! data) || (! pkey[0]) || (! pkey[1]) || (! pkey[2]))\n    err = GPG_ERR_BAD_MPI;\n  else\n    {\n      pk.p = pkey[0];\n      pk.g = pkey[1];\n      pk.y = pkey[2];\n      resarr[0] = mpi_alloc (mpi_get_nlimbs (pk.p));\n      resarr[1] = mpi_alloc (mpi_get_nlimbs (pk.p));\n      do_encrypt (resarr[0], resarr[1], data, &pk);\n    }\n  return err;\n}", "target": 0}
{"code": "static inline void skb_set_transport_header(struct sk_buff *skb,\n\t\t\t\t\t    const int offset)\n{\n\tskb_reset_transport_header(skb);\n\tskb->transport_header += offset;\n}", "target": 0}
{"code": "static void manager_invoke_notify_message(Manager *m, Unit *u, pid_t pid, const char *buf, size_t n, FDSet *fds) {\n        _cleanup_strv_free_ char **tags = NULL;\n        assert(m);\n        assert(u);\n        assert(buf);\n        assert(n > 0);\n        tags = strv_split(buf, \"\\n\\r\");\n        if (!tags) {\n                log_oom();\n                return;\n        }\n        if (UNIT_VTABLE(u)->notify_message)\n                UNIT_VTABLE(u)->notify_message(u, pid, tags, fds);\n        else\n                log_unit_debug(u, \"Got notification message for unit. Ignoring.\");\n}", "target": 1}
{"code": "AP_DECLARE(void) ap_increment_counts(ap_sb_handle_t *sb, request_rec *r)\n{\n    worker_score *ws;\n    apr_off_t bytes;\n    if (!sb)\n        return;\n    ws = &ap_scoreboard_image->servers[sb->child_num][sb->thread_num];\n    if (pfn_ap_logio_get_last_bytes != NULL) {\n        bytes = pfn_ap_logio_get_last_bytes(r->connection);\n    }\n    else if (r->method_number == M_GET && r->method[0] == 'H') {\n        bytes = 0;\n    }\n    else {\n        bytes = r->bytes_sent;\n    }\n#ifdef HAVE_TIMES\n    times(&ws->times);\n#endif\n    ws->access_count++;\n    ws->my_access_count++;\n    ws->conn_count++;\n    ws->bytes_served += bytes;\n    ws->my_bytes_served += bytes;\n    ws->conn_bytes += bytes;\n}", "target": 1}
{"code": "bool PrintMsg_Print_Params_IsValid(const PrintMsg_Print_Params& params) {\n  return !params.content_size.IsEmpty() && !params.page_size.IsEmpty() &&\n         !params.printable_area.IsEmpty() && params.document_cookie &&\n         params.desired_dpi && params.max_shrink && params.min_shrink &&\n         params.dpi && (params.margin_top >= 0) && (params.margin_left >= 0) &&\n         params.dpi > kMinDpi && params.document_cookie != 0;\n}", "target": 0}
{"code": "Network::TransportSocketPtr ServerSslSocketFactory::createDownstreamTransportSocket() const {\n  Envoy::Ssl::ServerContextSharedPtr ssl_ctx;\n  {\n    absl::ReaderMutexLock l(&ssl_ctx_mu_);\n    ssl_ctx = ssl_ctx_;\n  }\n  if (ssl_ctx) {\n    return std::make_unique<SslSocket>(std::move(ssl_ctx), InitialState::Server, nullptr,\n                                       config_->createHandshaker());\n  } else {\n    ENVOY_LOG(debug, \"Create NotReadySslSocket\");\n    stats_.downstream_context_secrets_not_ready_.inc();\n    return std::make_unique<NotReadySslSocket>();\n  }\n}", "target": 1}
{"code": "void FAST_FUNC udhcp_add_binary_option(struct dhcp_packet *packet, uint8_t *addopt)\n{\n\tunsigned len;\n\tuint8_t *optionptr = packet->options;\n\tunsigned end = udhcp_end_option(optionptr);\n\tlen = OPT_DATA + addopt[OPT_LEN];\n\tif (end + len + 1 >= DHCP_OPTIONS_BUFSIZE) {\n\t\tbb_error_msg(\"option 0x%02x did not fit into the packet\",\n\t\t\t\taddopt[OPT_CODE]);\n\t\treturn;\n\t}\n\tlog_option(\"Adding option\", addopt);\n\tmemcpy(optionptr + end, addopt, len);\n\toptionptr[end + len] = DHCP_END;\n}", "target": 0}
{"code": "static void update_read_synchronize(rdpUpdate* update, wStream* s)\n{\n\tWINPR_UNUSED(update);\n\tStream_Seek_UINT16(s); \n}", "target": 1}
{"code": "vips_malloc( VipsObject *object, size_t size )\n{\n\tvoid *buf;\n\tbuf = g_malloc( size );\n        if( object ) {\n\t\tg_signal_connect( object, \"postclose\", \n\t\t\tG_CALLBACK( vips_malloc_cb ), buf );\n\t\tobject->local_memory += size;\n\t}\n\treturn( buf );\n}", "target": 1}
{"code": "static int dynamicGetbuf(gdIOCtxPtr ctx, void *buf, int len)\n{\n\tint rlen, remain;\n\tdpIOCtxPtr dctx;\n\tdynamicPtr *dp;\n\tdctx = (dpIOCtxPtr) ctx;\n\tdp = dctx->dp;\n\tremain = dp->logicalSize - dp->pos;\n\tif(remain >= len) {\n\t\trlen = len;\n\t} else {\n\t\tif(remain == 0) {\n\t\t\treturn 0; \n\t\t}\n\t\trlen = remain;\n\t}\n\tmemcpy(buf, (void *) ((char *)dp->data + dp->pos), rlen);\n\tdp->pos += rlen;\n\treturn rlen;\n}", "target": 1}
{"code": "    void TiffImage::readMetadata()\n    {\n#ifdef DEBUG\n        std::cerr << \"Reading TIFF file \" << io_->path() << \"\\n\";\n#endif\n        if (io_->open() != 0) throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        IoCloser closer(*io_);\n        if (!isTiffType(*io_, false)) {\n            if (io_->error() || io_->eof()) throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAnImage, \"TIFF\");\n        }\n        clearMetadata();\n        ByteOrder bo = TiffParser::decode(exifData_,\n                                          iptcData_,\n                                          xmpData_,\n                                          io_->mmap(),\n                                          (uint32_t) io_->size());\n        setByteOrder(bo);\n        Exiv2::ExifKey            key(\"Exif.Image.InterColorProfile\");\n        Exiv2::ExifData::iterator pos   = exifData_.findKey(key);\n        if ( pos != exifData_.end()  ) {\n            iccProfile_.alloc(pos->count()*pos->typeSize());\n            pos->copy(iccProfile_.pData_,bo);\n        }\n    } ", "target": 1}
{"code": "get_voting_schedule(const or_options_t *options, time_t now, int severity)\n{\n  int interval, vote_delay, dist_delay;\n  time_t start;\n  time_t end;\n  networkstatus_t *consensus;\n  voting_schedule_t *new_voting_schedule;\n  new_voting_schedule = tor_malloc_zero(sizeof(voting_schedule_t));\n  consensus = networkstatus_get_live_consensus(now);\n  if (consensus) {\n    interval = (int)( consensus->fresh_until - consensus->valid_after );\n    vote_delay = consensus->vote_seconds;\n    dist_delay = consensus->dist_seconds;\n  } else {\n    interval = options->TestingV3AuthInitialVotingInterval;\n    vote_delay = options->TestingV3AuthInitialVoteDelay;\n    dist_delay = options->TestingV3AuthInitialDistDelay;\n  }\n  tor_assert(interval > 0);\n  if (vote_delay + dist_delay > interval/2)\n    vote_delay = dist_delay = interval / 4;\n  start = new_voting_schedule->interval_starts =\n    dirvote_get_start_of_next_interval(now,interval,\n                                      options->TestingV3AuthVotingStartOffset);\n  end = dirvote_get_start_of_next_interval(start+1, interval,\n                                      options->TestingV3AuthVotingStartOffset);\n  tor_assert(end > start);\n  new_voting_schedule->fetch_missing_signatures = start - (dist_delay/2);\n  new_voting_schedule->voting_ends = start - dist_delay;\n  new_voting_schedule->fetch_missing_votes =\n    start - dist_delay - (vote_delay/2);\n  new_voting_schedule->voting_starts = start - dist_delay - vote_delay;\n  {\n    char tbuf[ISO_TIME_LEN+1];\n    format_iso_time(tbuf, new_voting_schedule->interval_starts);\n    tor_log(severity, LD_DIR,\"Choosing expected valid-after time as %s: \"\n            \"consensus_set=%d, interval=%d\",\n            tbuf, consensus?1:0, interval);\n  }\n  return new_voting_schedule;\n}", "target": 0}
{"code": "PJ_DEF(void) pj_scan_get_newline( pj_scanner *scanner )\n{\n    if (!PJ_SCAN_IS_NEWLINE(*scanner->curptr)) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n    if (*scanner->curptr == '\\r') {\n\t++scanner->curptr;\n    }\n    if (*scanner->curptr == '\\n') {\n\t++scanner->curptr;\n    }\n    ++scanner->line;\n    scanner->start_line = scanner->curptr;\n}", "target": 1}
{"code": "static int snd_ctl_elem_write_user(struct snd_ctl_file *file,\n\t\t\t\t   struct snd_ctl_elem_value __user *_control)\n{\n\tstruct snd_ctl_elem_value *control;\n\tstruct snd_card *card;\n\tint result;\n\tcontrol = memdup_user(_control, sizeof(*control));\n\tif (IS_ERR(control))\n\t\treturn PTR_ERR(control);\n\tcard = file->card;\n\tsnd_power_lock(card);\n\tresult = snd_power_wait(card, SNDRV_CTL_POWER_D0);\n\tif (result >= 0)\n\t\tresult = snd_ctl_elem_write(card, file, control);\n\tsnd_power_unlock(card);\n\tif (result >= 0)\n\t\tif (copy_to_user(_control, control, sizeof(*control)))\n\t\t\tresult = -EFAULT;\n\tkfree(control);\n\treturn result;\n}", "target": 0}
{"code": "ospf_ls_req_send (struct ospf_neighbor *nbr)\n{\n  struct ospf_interface *oi;\n  struct ospf_packet *op;\n  u_int16_t length = OSPF_HEADER_SIZE;\n  oi = nbr->oi;\n  op = ospf_packet_new (oi->ifp->mtu);\n  ospf_make_header (OSPF_MSG_LS_REQ, oi, op->s);\n  length += ospf_make_ls_req (nbr, op->s);\n  if (length == OSPF_HEADER_SIZE)\n    {\n      ospf_packet_free (op);\n      return;\n    }\n  ospf_fill_header (oi, op->s, length);\n  op->length = length;\n  if (oi->type == OSPF_IFTYPE_POINTOPOINT) \n    op->dst.s_addr = htonl (OSPF_ALLSPFROUTERS);\n  else\n    op->dst = nbr->address.u.prefix4;\n  ospf_packet_add (oi, op);\n  OSPF_ISM_WRITE_ON (oi->ospf);\n  OSPF_NSM_TIMER_ON (nbr->t_ls_req, ospf_ls_req_timer, nbr->v_ls_req);\n}", "target": 0}
{"code": "decode_NXAST_RAW_ENCAP(const struct nx_action_encap *nae,\n                       enum ofp_version ofp_version OVS_UNUSED,\n                       struct ofpbuf *out)\n{\n    struct ofpact_encap *encap;\n    const struct ofp_ed_prop_header *ofp_prop;\n    const size_t encap_ofs = out->size;\n    size_t props_len;\n    uint16_t n_props = 0;\n    int err;\n    encap = ofpact_put_ENCAP(out);\n    encap->ofpact.raw = NXAST_RAW_ENCAP;\n    switch (ntohl(nae->new_pkt_type)) {\n    case PT_ETH:\n    case PT_NSH:\n        break;\n    default:\n        return OFPERR_NXBAC_BAD_HEADER_TYPE;\n    }\n    encap->new_pkt_type = nae->new_pkt_type;\n    encap->hdr_size = ntohs(nae->hdr_size);\n    ofp_prop = nae->props;\n    props_len = ntohs(nae->len) - offsetof(struct nx_action_encap, props);\n    n_props = 0;\n    while (props_len > 0) {\n        err = decode_ed_prop(&ofp_prop, out, &props_len);\n        if (err) {\n            return err;\n        }\n        n_props++;\n    }\n    encap = ofpbuf_at_assert(out, encap_ofs, sizeof *encap);\n    encap->n_props = n_props;\n    out->header = &encap->ofpact;\n    ofpact_finish_ENCAP(out, &encap);\n    return 0;\n}", "target": 0}
{"code": "void ChildProcessSecurityPolicy::Remove(int renderer_id) {\n  AutoLock lock(lock_);\n  if (!security_state_.count(renderer_id))\n    return;  \n  delete security_state_[renderer_id];\n  security_state_.erase(renderer_id);\n}", "target": 0}
{"code": "void TDStretch::setChannels(int numChannels)\n{\n    assert(numChannels > 0);\n    if (channels == numChannels) return;\n    channels = numChannels;\n    inputBuffer.setChannels(channels);\n    outputBuffer.setChannels(channels);\n    overlapLength=0;\n    setParameters(sampleRate);\n}", "target": 1}
{"code": "add_if_prefix_matches(lookup_state_t *state,\n                      const sorted_pattern_t *prefix,\n                      const svn_stringbuf_t *segment)\n{\n  node_t *node = prefix->node;\n  if (   node->segment.len <= segment->len\n      && !memcmp(node->segment.data, segment->data, node->segment.len))\n    add_next_node(state, node);\n}", "target": 0}
{"code": "static void test_simple()\n{\n    json_set_alloc_funcs(my_malloc, my_free);\n    create_and_free_complex_object();\n    if(malloc_called != 20 || free_called != 20)\n        fail(\"Custom allocation failed\");\n}", "target": 1}
{"code": "  String_Schema_Obj Parser::parse_css_variable_value(bool top_level)\n  {\n    String_Schema_Obj schema = SASS_MEMORY_NEW(String_Schema, pstate);\n    String_Schema_Obj tok;\n    if (!(tok = parse_css_variable_value_token(top_level))) {\n      return {};\n    }\n    schema->concat(tok);\n    while ((tok = parse_css_variable_value_token(top_level))) {\n      schema->concat(tok);\n    }\n    return schema.detach();\n  }", "target": 1}
{"code": "static inline vm_fault_t hugetlb_handle_userfault(struct vm_area_struct *vma,\n\t\t\t\t\t\t  struct address_space *mapping,\n\t\t\t\t\t\t  pgoff_t idx,\n\t\t\t\t\t\t  unsigned int flags,\n\t\t\t\t\t\t  unsigned long haddr,\n\t\t\t\t\t\t  unsigned long reason)\n{\n\tvm_fault_t ret;\n\tu32 hash;\n\tstruct vm_fault vmf = {\n\t\t.vma = vma,\n\t\t.address = haddr,\n\t\t.flags = flags,\n\t};\n\thash = hugetlb_fault_mutex_hash(mapping, idx);\n\tmutex_unlock(&hugetlb_fault_mutex_table[hash]);\n\ti_mmap_unlock_read(mapping);\n\tret = handle_userfault(&vmf, reason);\n\ti_mmap_lock_read(mapping);\n\tmutex_lock(&hugetlb_fault_mutex_table[hash]);\n\treturn ret;\n}", "target": 0}
{"code": "static int ims_pcu_parse_cdc_data(struct usb_interface *intf, struct ims_pcu *pcu)\n{\n\tconst struct usb_cdc_union_desc *union_desc;\n\tstruct usb_host_interface *alt;\n\tunion_desc = ims_pcu_get_cdc_union_desc(intf);\n\tif (!union_desc)\n\t\treturn -EINVAL;\n\tpcu->ctrl_intf = usb_ifnum_to_if(pcu->udev,\n\t\t\t\t\t union_desc->bMasterInterface0);\n\tif (!pcu->ctrl_intf)\n\t\treturn -EINVAL;\n\talt = pcu->ctrl_intf->cur_altsetting;\n\tpcu->ep_ctrl = &alt->endpoint[0].desc;\n\tpcu->max_ctrl_size = usb_endpoint_maxp(pcu->ep_ctrl);\n\tpcu->data_intf = usb_ifnum_to_if(pcu->udev,\n\t\t\t\t\t union_desc->bSlaveInterface0);\n\tif (!pcu->data_intf)\n\t\treturn -EINVAL;\n\talt = pcu->data_intf->cur_altsetting;\n\tif (alt->desc.bNumEndpoints != 2) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Incorrect number of endpoints on data interface (%d)\\n\",\n\t\t\talt->desc.bNumEndpoints);\n\t\treturn -EINVAL;\n\t}\n\tpcu->ep_out = &alt->endpoint[0].desc;\n\tif (!usb_endpoint_is_bulk_out(pcu->ep_out)) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"First endpoint on data interface is not BULK OUT\\n\");\n\t\treturn -EINVAL;\n\t}\n\tpcu->max_out_size = usb_endpoint_maxp(pcu->ep_out);\n\tif (pcu->max_out_size < 8) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Max OUT packet size is too small (%zd)\\n\",\n\t\t\tpcu->max_out_size);\n\t\treturn -EINVAL;\n\t}\n\tpcu->ep_in = &alt->endpoint[1].desc;\n\tif (!usb_endpoint_is_bulk_in(pcu->ep_in)) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Second endpoint on data interface is not BULK IN\\n\");\n\t\treturn -EINVAL;\n\t}\n\tpcu->max_in_size = usb_endpoint_maxp(pcu->ep_in);\n\tif (pcu->max_in_size < 8) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Max IN packet size is too small (%zd)\\n\",\n\t\t\tpcu->max_in_size);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;", "target": 0}
{"code": "static int jpc_qcd_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_qcd_t *qcd = &ms->parms.qcd;\n\tint i;\n\tfprintf(out, \"qntsty = %d; numguard = %d; numstepsizes = %d\\n\",\n\t  (int) qcd->compparms.qntsty, qcd->compparms.numguard, qcd->compparms.numstepsizes);\n\tfor (i = 0; i < qcd->compparms.numstepsizes; ++i) {\n\t\tfprintf(out, \"expn[%d] = 0x%04x; mant[%d] = 0x%04x;\\n\",\n\t\t  i, (unsigned) JPC_QCX_GETEXPN(qcd->compparms.stepsizes[i]),\n\t\t  i, (unsigned) JPC_QCX_GETMANT(qcd->compparms.stepsizes[i]));\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "    void TiffEncoder::add(\n        TiffComponent* pRootDir,\n        TiffComponent* pSourceDir,\n        uint32_t       root\n    )\n    {\n        assert(pRootDir != 0);\n        writeMethod_ = wmIntrusive;\n        pSourceTree_ = pSourceDir;\n        del_ = false;\n        ExifData::const_iterator posBo = exifData_.end();\n        for (ExifData::const_iterator i = exifData_.begin();\n             i != exifData_.end(); ++i) {\n            IfdId group = groupId(i->groupName());\n            if (group == mnId) {\n                if (i->tag() == 0x0002) {\n                    posBo = i;\n                }\n                continue;\n            }\n            if (isImageTag(i->tag(), group)) continue;\n            TiffPath tiffPath;\n            TiffCreator::getPath(tiffPath, i->tag(), group, root);\n            TiffComponent* tc = pRootDir->addPath(i->tag(), tiffPath, pRootDir);\n            TiffEntryBase* object = dynamic_cast<TiffEntryBase*>(tc);\n#ifdef DEBUG\n            if (object == 0) {\n                std::cerr << \"Warning: addPath() didn't add an entry for \"\n                          << i->groupName()\n                          << \" tag 0x\" << std::setw(4) << std::setfill('0')\n                          << std::hex << i->tag() << \"\\n\";\n            }\n#endif\n            if (object != 0) {\n                encodeTiffComponent(object, &(*i));\n            }\n        }\n        if (posBo == exifData_.end()) return;\n        TiffFinder finder(0x927c, exifId);\n        pRootDir->accept(finder);\n        TiffMnEntry* te = dynamic_cast<TiffMnEntry*>(finder.result());\n        if (te) {\n            TiffIfdMakernote* tim = dynamic_cast<TiffIfdMakernote*>(te->mn_);\n            if (tim) {\n                ByteOrder bo = stringToByteOrder(posBo->toString());\n                if (bo != invalidByteOrder) tim->setByteOrder(bo);\n            }\n        }\n    } ", "target": 0}
{"code": "PHP_NAMED_FUNCTION(zif_locale_set_default)\n{\n\tchar* locale_name = NULL;\n\tint   len=0;\t\n\tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC,  \"s\",\n\t\t&locale_name ,&len ) == FAILURE)\n\t{\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t \t\"locale_set_default: unable to parse input params\", 0 TSRMLS_CC );\n\t\tRETURN_FALSE;\n\t}\n\tif(len == 0) {\n\t\tlocale_name =  (char *)uloc_getDefault() ;\n\t\tlen = strlen(locale_name);\n\t}\n\tzend_alter_ini_entry(LOCALE_INI_NAME, sizeof(LOCALE_INI_NAME), locale_name, len, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);\t\n\tRETURN_TRUE;\n}", "target": 1}
{"code": "static void edge_tty_recv(struct usb_serial_port *port, unsigned char *data,\n\t\tint length)\n{\n\tint queued;\n\tqueued = tty_insert_flip_string(&port->port, data, length);\n\tif (queued < length)\n\t\tdev_err(&port->dev, \"%s - dropping data, %d bytes lost\\n\",\n\t\t\t__func__, length - queued);\n\ttty_flip_buffer_push(&port->port);\n}", "target": 0}
{"code": "static pfn_t kvm_pin_pages(struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t   unsigned long size)\n{\n\tgfn_t end_gfn;\n\tpfn_t pfn;\n\tpfn     = gfn_to_pfn_memslot(slot, gfn);\n\tend_gfn = gfn + (size >> PAGE_SHIFT);\n\tgfn    += 1;\n\tif (is_error_noslot_pfn(pfn))\n\t\treturn pfn;\n\twhile (gfn < end_gfn)\n\t\tgfn_to_pfn_memslot(slot, gfn++);\n\treturn pfn;\n}", "target": 1}
{"code": "static void ashtech_event_hook(struct gps_device_t *session, event_t event)\n{\n    if (session->context->readonly)\n\treturn;\n    if (event == event_wakeup)\n\t(void)nmea_send(session, \"$PASHQ,RID\");\n    if (event == event_identified) {\n\t(void)nmea_send(session, \"$PASHS,WAS,ON\");\n\t(void)nmea_send(session, \"$PASHS,NME,ALL,A,OFF\");\n#ifdef __future__\n\t(void)nmea_send(session, \"$PASHS,NME,POS,A,ON\");\n\t(void)nmea_send(session, \"$PASHS,NME,SAT,A,ON\");\n#else\n\t(void)nmea_send(session, \"$PASHS,NME,GGA,A,ON\");\n\t(void)nmea_send(session, \"$PASHS,NME,GSA,A,ON\");\n\t(void)nmea_send(session, \"$PASHS,NME,GSV,A,ON\");\n\t(void)nmea_send(session, \"$PASHS,NME,RMC,A,ON\");\n#endif\n\t(void)nmea_send(session, \"$PASHS,NME,ZDA,A,ON\");\n    }\n}", "target": 0}
{"code": "static int sanity_check_raw_super(struct super_block *sb,\n\t\t\tstruct f2fs_super_block *raw_super)\n{\n\tunsigned int blocksize;\n\tif (F2FS_SUPER_MAGIC != le32_to_cpu(raw_super->magic)) {\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\"Magic Mismatch, valid(0x%x) - read(0x%x)\",\n\t\t\tF2FS_SUPER_MAGIC, le32_to_cpu(raw_super->magic));\n\t\treturn 1;\n\t}\n\tif (F2FS_BLKSIZE != PAGE_CACHE_SIZE) {\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\"Invalid page_cache_size (%lu), supports only 4KB\\n\",\n\t\t\tPAGE_CACHE_SIZE);\n\t\treturn 1;\n\t}\n\tblocksize = 1 << le32_to_cpu(raw_super->log_blocksize);\n\tif (blocksize != F2FS_BLKSIZE) {\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\"Invalid blocksize (%u), supports only 4KB\\n\",\n\t\t\tblocksize);\n\t\treturn 1;\n\t}\n\tif (le32_to_cpu(raw_super->log_sectorsize) >\n\t\t\t\tF2FS_MAX_LOG_SECTOR_SIZE ||\n\t\tle32_to_cpu(raw_super->log_sectorsize) <\n\t\t\t\tF2FS_MIN_LOG_SECTOR_SIZE) {\n\t\tf2fs_msg(sb, KERN_INFO, \"Invalid log sectorsize (%u)\",\n\t\t\tle32_to_cpu(raw_super->log_sectorsize));\n\t\treturn 1;\n\t}\n\tif (le32_to_cpu(raw_super->log_sectors_per_block) +\n\t\tle32_to_cpu(raw_super->log_sectorsize) !=\n\t\t\tF2FS_MAX_LOG_SECTOR_SIZE) {\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\"Invalid log sectors per block(%u) log sectorsize(%u)\",\n\t\t\tle32_to_cpu(raw_super->log_sectors_per_block),\n\t\t\tle32_to_cpu(raw_super->log_sectorsize));\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "  void operator()(const CPUDevice& d,\n                  typename TTypes<T, 3>::ConstTensor gradient,\n                  typename TTypes<T, 3>::ConstTensor input,\n                  const Tensor* input_min_tensor,\n                  const Tensor* input_max_tensor,\n                  typename TTypes<T, 3>::Tensor input_backprop,\n                  typename TTypes<T>::Flat input_min_backprop,\n                  typename TTypes<T>::Flat input_max_backprop) {\n    QuantizeAndDequantizePerChannelGradientImpl<CPUDevice, T>::Compute(\n        d, gradient, input, input_min_tensor, input_max_tensor, input_backprop,\n        input_min_backprop, input_max_backprop);\n  }", "target": 1}
{"code": "BOOL security_fips_decrypt(BYTE* data, size_t length, rdpRdp* rdp)\n{\n\tsize_t olen;\n\tif (!winpr_Cipher_Update(rdp->fips_decrypt, data, length, data, &olen))\n\t\treturn FALSE;\n\treturn TRUE;\n}", "target": 1}
{"code": "static char *stibp_state(void)\n{\n\tif (spectre_v2_in_ibrs_mode(spectre_v2_enabled))\n\t\treturn \"\";\n\tswitch (spectre_v2_user_stibp) {\n\tcase SPECTRE_V2_USER_NONE:\n\t\treturn \", STIBP: disabled\";\n\tcase SPECTRE_V2_USER_STRICT:\n\t\treturn \", STIBP: forced\";\n\tcase SPECTRE_V2_USER_STRICT_PREFERRED:\n\t\treturn \", STIBP: always-on\";\n\tcase SPECTRE_V2_USER_PRCTL:\n\tcase SPECTRE_V2_USER_SECCOMP:\n\t\tif (static_key_enabled(&switch_to_cond_stibp))\n\t\t\treturn \", STIBP: conditional\";\n\t}\n\treturn \"\";\n}", "target": 1}
{"code": "static void br_multicast_del_pg(struct net_bridge *br,\n\t\t\t\tstruct net_bridge_port_group *pg)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tmdb = mlock_dereference(br->mdb, br);\n\tmp = br_mdb_ip_get(mdb, &pg->addr);\n\tif (WARN_ON(!mp))\n\t\treturn;\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (p != pg)\n\t\t\tcontinue;\n\t\trcu_assign_pointer(*pp, p->next);\n\t\thlist_del_init(&p->mglist);\n\t\tdel_timer(&p->timer);\n\t\tcall_rcu_bh(&p->rcu, br_multicast_free_pg);\n\t\tif (!mp->ports && !mp->mglist &&\n\t\t    netif_running(br->dev))\n\t\t\tmod_timer(&mp->timer, jiffies);\n\t\treturn;\n\t}\n\tWARN_ON(1);\n}", "target": 1}
{"code": "hash_link_ref(const uint8_t *link_ref, size_t length)\n{\n\tsize_t i;\n\tunsigned int hash = 0;\n\tfor (i = 0; i < length; ++i)\n\t\thash = tolower(link_ref[i]) + (hash << 6) + (hash << 16) - hash;\n\treturn hash;\n}", "target": 1}
{"code": "ikev1_hash_print(netdissect_options *ndo, u_char tpay _U_,\n\t\t const struct isakmp_gen *ext, u_int item_len _U_,\n\t\t const u_char *ep _U_, uint32_t phase _U_, uint32_t doi _U_,\n\t\t uint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_HASH)));\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_HASH)));\n\treturn NULL;\n}", "target": 0}
{"code": "static CallResult<HermesValue> getCodeBlockFileName(\n    Runtime &runtime,\n    const CodeBlock *codeBlock,\n    OptValue<hbc::DebugSourceLocation> location) {\n  RuntimeModule *runtimeModule = codeBlock->getRuntimeModule();\n  if (location) {\n    auto debugInfo = runtimeModule->getBytecode()->getDebugInfo();\n    return StringPrimitive::createEfficient(\n        runtime, debugInfo->getFilenameByID(location->filenameId));\n  } else {\n    llvh::StringRef sourceURL = runtimeModule->getSourceURL();\n    if (!sourceURL.empty()) {\n      return StringPrimitive::createEfficient(runtime, sourceURL);\n    }\n  }\n  return HermesValue::encodeUndefinedValue();\n}", "target": 1}
{"code": "static void __reg_deduce_bounds(struct bpf_reg_state *reg)\n{\n\tif (reg->smin_value >= 0 || reg->smax_value < 0) {\n\t\treg->smin_value = reg->umin_value = max_t(u64, reg->smin_value,\n\t\t\t\t\t\t\t  reg->umin_value);\n\t\treg->smax_value = reg->umax_value = min_t(u64, reg->smax_value,\n\t\t\t\t\t\t\t  reg->umax_value);\n\t\treturn;\n\t}\n\tif ((s64)reg->umax_value >= 0) {\n\t\treg->smin_value = reg->umin_value;\n\t\treg->smax_value = reg->umax_value = min_t(u64, reg->smax_value,\n\t\t\t\t\t\t\t  reg->umax_value);\n\t} else if ((s64)reg->umin_value < 0) {\n\t\treg->smin_value = reg->umin_value = max_t(u64, reg->smin_value,\n\t\t\t\t\t\t\t  reg->umin_value);\n\t\treg->smax_value = reg->umax_value;\n\t}\n}", "target": 0}
{"code": "vte_sequence_handler_scroll_up (VteTerminal *terminal, GValueArray *params)\n{\n\tlong val = 1;\n\tGValue *value;\n\tif ((params != NULL) && (params->n_values > 0)) {\n\t\tvalue = g_value_array_get_nth(params, 0);\n\t\tif (G_VALUE_HOLDS_LONG(value)) {\n\t\t\tval = g_value_get_long(value);\n\t\t\tval = MAX(val, 1);\n\t\t}\n\t}\n\t_vte_terminal_scroll_text (terminal, -val);\n}", "target": 0}
{"code": "static void virtual_xfer_breadcrumbs(struct virtual_engine *ve,\n\t\t\t\t     struct intel_engine_cs *engine)\n{\n\tstruct intel_engine_cs *old = ve->siblings[0];\n\tspin_lock(&old->breadcrumbs.irq_lock);\n\tif (!list_empty(&ve->context.signal_link)) {\n\t\tlist_move_tail(&ve->context.signal_link,\n\t\t\t       &engine->breadcrumbs.signalers);\n\t\tintel_engine_queue_breadcrumbs(engine);\n\t}\n\tspin_unlock(&old->breadcrumbs.irq_lock);\n}", "target": 0}
{"code": "static int db_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_run *kvm_run = svm->vcpu.run;\n\tif (!(svm->vcpu.guest_debug &\n\t      (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) &&\n\t\t!svm->nmi_singlestep) {\n\t\tkvm_queue_exception(&svm->vcpu, DB_VECTOR);\n\t\treturn 1;\n\t}\n\tif (svm->nmi_singlestep) {\n\t\tsvm->nmi_singlestep = false;\n\t\tif (!(svm->vcpu.guest_debug & KVM_GUESTDBG_SINGLESTEP))\n\t\t\tsvm->vmcb->save.rflags &=\n\t\t\t\t~(X86_EFLAGS_TF | X86_EFLAGS_RF);\n\t\tupdate_db_bp_intercept(&svm->vcpu);\n\t}\n\tif (svm->vcpu.guest_debug &\n\t    (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) {\n\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\tkvm_run->debug.arch.pc =\n\t\t\tsvm->vmcb->save.cs.base + svm->vmcb->save.rip;\n\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "batchCopyElem(batch_obj_t *pDest, batch_obj_t *pSrc) {\n\tmemcpy(pDest, pSrc, sizeof(batch_obj_t));\n}", "target": 1}
{"code": "l2tp_proto_ver_print(netdissect_options *ndo, const uint16_t *dat)\n{\n\tND_PRINT((ndo, \"%u.%u\", (EXTRACT_16BITS(dat) >> 8),\n\t    (EXTRACT_16BITS(dat) & 0xff)));\n}", "target": 1}
{"code": "MagickExport void CatchException(ExceptionInfo *exception)\n{\n  register const ExceptionInfo\n    *p;\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (exception->exceptions  == (void *) NULL)\n    return;\n  LockSemaphoreInfo(exception->semaphore);\n  ResetLinkedListIterator((LinkedListInfo *) exception->exceptions);\n  p=(const ExceptionInfo *) GetNextValueInLinkedList((LinkedListInfo *)\n    exception->exceptions);\n  while (p != (const ExceptionInfo *) NULL)\n  {\n    if ((p->severity >= WarningException) && (p->severity < ErrorException))\n      MagickWarning(p->severity,p->reason,p->description);\n    if ((p->severity >= ErrorException) && (p->severity < FatalErrorException))\n      MagickError(p->severity,p->reason,p->description);\n    if (p->severity >= FatalErrorException)\n      MagickFatalError(p->severity,p->reason,p->description);\n    p=(const ExceptionInfo *) GetNextValueInLinkedList((LinkedListInfo *)\n      exception->exceptions);\n  }\n  UnlockSemaphoreInfo(exception->semaphore);\n  ClearMagickException(exception);\n}", "target": 1}
{"code": "static void js_initvar(js_State *J, const char *name, int idx)\n{\n\tjsR_defproperty(J, J->E->variables, name, JS_DONTENUM | JS_DONTCONF, stackidx(J, idx), NULL, NULL);\n}", "target": 0}
{"code": "Opal::Call::emit_setup_in_main ()\n{\n  setup ();\n}", "target": 0}
{"code": " ZEND_METHOD(CURLFile, __wakeup)\n {\n       zend_update_property_string(curl_CURLFile_class, getThis(), \"name\", sizeof(\"name\")-1, \"\" TSRMLS_CC);\n        zend_throw_exception(NULL, \"Unserialization of CURLFile instances is not allowed\", 0 TSRMLS_CC);\n }", "target": 1}
{"code": "static int nsim_bpf_verifier_prep(struct bpf_prog *prog)\n{\n\tstruct nsim_dev *nsim_dev =\n\t\t\tbpf_offload_dev_priv(prog->aux->offload->offdev);\n\tif (!nsim_dev->bpf_bind_accept)\n\t\treturn -EOPNOTSUPP;\n\treturn nsim_bpf_create_prog(nsim_dev, prog);\n}", "target": 0}
{"code": "static ext4_io_end_t *ext4_init_io_end (struct inode *inode)\n{\n\text4_io_end_t *io = NULL;\n\tio = kmalloc(sizeof(*io), GFP_NOFS);\n\tif (io) {\n\t\tigrab(inode);\n\t\tio->inode = inode;\n\t\tio->flag = 0;\n\t\tio->offset = 0;\n\t\tio->size = 0;\n\t\tio->error = 0;\n\t\tINIT_WORK(&io->work, ext4_end_io_work);\n\t\tINIT_LIST_HEAD(&io->list);\n\t}\n\treturn io;\n}", "target": 1}
{"code": "spnego_gss_export_sec_context(\n\t\t\t    OM_uint32\t  *minor_status,\n\t\t\t    gss_ctx_id_t *context_handle,\n\t\t\t    gss_buffer_t interprocess_token)\n{\n\tOM_uint32 ret;\n\tret = gss_export_sec_context(minor_status,\n\t\t\t\t    context_handle,\n\t\t\t\t    interprocess_token);\n\treturn (ret);\n}", "target": 1}
{"code": "spnego_gss_context_time(\n\t\t\tOM_uint32\t*minor_status,\n\t\t\tconst gss_ctx_id_t context_handle,\n\t\t\tOM_uint32\t*time_rec)\n{\n\tOM_uint32 ret;\n\tret = gss_context_time(minor_status,\n\t\t\t    context_handle,\n\t\t\t    time_rec);\n\treturn (ret);\n}", "target": 1}
{"code": "static GF_Filter *locate_alias_sink(GF_Filter *filter, const char *url, const char *mime_type)\n{\n\tu32 i;\n\tfor (i=0; i<filter->num_output_pids; i++) {\n\t\tu32 j;\n\t\tGF_FilterPid *pid = gf_list_get(filter->output_pids, i);\n\t\tfor (j=0; j<pid->num_destinations; j++) {\n\t\t\tGF_Filter *f;\n\t\t\tGF_FilterPidInst *pidi = gf_list_get(pid->destinations, j);\n\t\t\tif (!pidi->filter) continue;\n\t\t\tif (pidi->filter->act_as_sink && pidi->filter->freg->use_alias\n\t\t\t\t&& pidi->filter->freg->use_alias(pidi->filter, url, mime_type)\n\t\t\t) {\n\t\t\t\treturn pidi->filter;\n\t\t\t}\n\t\t\tf = locate_alias_sink(pidi->filter, url, mime_type);\n\t\t\tif (f) return f;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "int detach_capi_ctr(struct capi_ctr *ctr)\n{\n\tint err = 0;\n\tmutex_lock(&capi_controller_lock);\n\tctr_down(ctr, CAPI_CTR_DETACHED);\n\tif (capi_controller[ctr->cnr - 1] != ctr) {\n\t\terr = -EINVAL;\n\t\tgoto unlock_out;\n\t}\n\tcapi_controller[ctr->cnr - 1] = NULL;\n\tncontrollers--;\n\tif (ctr->procent)\n\t\tremove_proc_entry(ctr->procfn, NULL);\n\tprintk(KERN_NOTICE \"kcapi: controller [%03d]: %s unregistered\\n\",\n\t       ctr->cnr, ctr->name);\nunlock_out:\n\tmutex_unlock(&capi_controller_lock);\n\treturn err;\n}", "target": 1}
{"code": "static bool freelist_state_initialize(union freelist_init_state *state,\n\t\t\t\tstruct kmem_cache *cachep,\n\t\t\t\tunsigned int count)\n{\n\tbool ret;\n\tunsigned int rand;\n\trand = get_random_int();\n\tif (!cachep->random_seq) {\n\t\tprandom_seed_state(&state->rnd_state, rand);\n\t\tret = false;\n\t} else {\n\t\tstate->list = cachep->random_seq;\n\t\tstate->count = count;\n\t\tstate->pos = 0;\n\t\tstate->rand = rand;\n\t\tret = true;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "void addReply(redisClient *c, robj *obj) {\n    if (_installWriteEvent(c) != REDIS_OK) return;\n    redisAssert(!server.vm_enabled || obj->storage == REDIS_VM_MEMORY);\n    if (obj->encoding == REDIS_ENCODING_RAW) {\n        if (_addReplyToBuffer(c,obj->ptr,sdslen(obj->ptr)) != REDIS_OK)\n            _addReplyObjectToList(c,obj);\n    } else {\n        obj = getDecodedObject(obj);\n        if (_addReplyToBuffer(c,obj->ptr,sdslen(obj->ptr)) != REDIS_OK)\n            _addReplyObjectToList(c,obj);\n        decrRefCount(obj);\n    }\n}", "target": 1}
{"code": "  virtual void requestInit() {\n    m_use_error = false;\n    m_errors.reset();\n    xmlParserInputBufferCreateFilenameDefault(nullptr);\n  }", "target": 1}
{"code": "GF_Err iSFM_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ISMASampleFormatBox *ptr = (GF_ISMASampleFormatBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 3);\n\tptr->selective_encryption = gf_bs_read_int(bs, 1);\n\tgf_bs_read_int(bs, 7);\n\tptr->key_indicator_length = gf_bs_read_u8(bs);\n\tptr->IV_length = gf_bs_read_u8(bs);\n\treturn GF_OK;\n}", "target": 0}
{"code": "unserialize_uep(bufinfo_T *bi, int *error, char_u *file_name)\n{\n    int\t\ti;\n    u_entry_T\t*uep;\n    char_u\t**array;\n    char_u\t*line;\n    int\t\tline_len;\n    uep = (u_entry_T *)U_ALLOC_LINE(sizeof(u_entry_T));\n    if (uep == NULL)\n\treturn NULL;\n    vim_memset(uep, 0, sizeof(u_entry_T));\n#ifdef U_DEBUG\n    uep->ue_magic = UE_MAGIC;\n#endif\n    uep->ue_top = undo_read_4c(bi);\n    uep->ue_bot = undo_read_4c(bi);\n    uep->ue_lcount = undo_read_4c(bi);\n    uep->ue_size = undo_read_4c(bi);\n    if (uep->ue_size > 0)\n    {\n\tarray = (char_u **)U_ALLOC_LINE(sizeof(char_u *) * uep->ue_size);\n\tif (array == NULL)\n\t{\n\t    *error = TRUE;\n\t    return uep;\n\t}\n\tvim_memset(array, 0, sizeof(char_u *) * uep->ue_size);\n    }\n    else\n\tarray = NULL;\n    uep->ue_array = array;\n    for (i = 0; i < uep->ue_size; ++i)\n    {\n\tline_len = undo_read_4c(bi);\n\tif (line_len >= 0)\n\t    line = read_string_decrypt(bi, line_len);\n\telse\n\t{\n\t    line = NULL;\n\t    corruption_error(\"line length\", file_name);\n\t}\n\tif (line == NULL)\n\t{\n\t    *error = TRUE;\n\t    return uep;\n\t}\n\tarray[i] = line;\n    }\n    return uep;\n}", "target": 1}
{"code": "static int mb86a20s_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct mb86a20s_state *state = fe->demodulator_priv;\n\tint val;\n\t*status = 0;\n\tval = mb86a20s_readreg(state, 0x0a) & 0xf;\n\tif (val < 0)\n\t\treturn val;\n\tif (val >= 2)\n\t\t*status |= FE_HAS_SIGNAL;\n\tif (val >= 4)\n\t\t*status |= FE_HAS_CARRIER;\n\tif (val >= 5)\n\t\t*status |= FE_HAS_VITERBI;\n\tif (val >= 7)\n\t\t*status |= FE_HAS_SYNC;\n\tif (val >= 8)\t\t\t\t\n\t\t*status |= FE_HAS_LOCK;\n\tdev_dbg(&state->i2c->dev, \"%s: Status = 0x%02x (state = %d)\\n\",\n\t\t __func__, *status, val);\n\treturn val;\n}", "target": 1}
{"code": "void posix_cpu_timer_get(struct k_itimer *timer, struct itimerspec *itp)\n{\n\tunion cpu_time_count now;\n\tstruct task_struct *p = timer->it.cpu.task;\n\tint clear_dead;\n\tsample_to_timespec(timer->it_clock,\n\t\t\t   timer->it.cpu.incr, &itp->it_interval);\n\tif (timer->it.cpu.expires.sched == 0) {\t\n\t\titp->it_value.tv_sec = itp->it_value.tv_nsec = 0;\n\t\treturn;\n\t}\n\tif (unlikely(p == NULL)) {\n\tdead:\n\t\tsample_to_timespec(timer->it_clock, timer->it.cpu.expires,\n\t\t\t\t   &itp->it_value);\n\t\treturn;\n\t}\n\tif (CPUCLOCK_PERTHREAD(timer->it_clock)) {\n\t\tcpu_clock_sample(timer->it_clock, p, &now);\n\t\tclear_dead = p->exit_state;\n\t} else {\n\t\tread_lock(&tasklist_lock);\n\t\tif (unlikely(p->signal == NULL)) {\n\t\t\tput_task_struct(p);\n\t\t\ttimer->it.cpu.task = NULL;\n\t\t\ttimer->it.cpu.expires.sched = 0;\n\t\t\tread_unlock(&tasklist_lock);\n\t\t\tgoto dead;\n\t\t} else {\n\t\t\tcpu_clock_sample_group(timer->it_clock, p, &now);\n\t\t\tclear_dead = (unlikely(p->exit_state) &&\n\t\t\t\t      thread_group_empty(p));\n\t\t}\n\t\tread_unlock(&tasklist_lock);\n\t}\n\tif ((timer->it_sigev_notify & ~SIGEV_THREAD_ID) == SIGEV_NONE) {\n\t\tif (timer->it.cpu.incr.sched == 0 &&\n\t\t    cpu_time_before(timer->it_clock,\n\t\t\t\t    timer->it.cpu.expires, now)) {\n\t\t\ttimer->it.cpu.expires.sched = 0;\n\t\t\titp->it_value.tv_sec = itp->it_value.tv_nsec = 0;\n\t\t\treturn;\n\t\t}\n\t\tbump_cpu_timer(timer, now);\n\t}\n\tif (unlikely(clear_dead)) {\n\t\tclear_dead_task(timer, now);\n\t\tgoto dead;\n\t}\n\tif (cpu_time_before(timer->it_clock, now, timer->it.cpu.expires)) {\n\t\tsample_to_timespec(timer->it_clock,\n\t\t\t\t   cpu_time_sub(timer->it_clock,\n\t\t\t\t\t\ttimer->it.cpu.expires, now),\n\t\t\t\t   &itp->it_value);\n\t} else {\n\t\titp->it_value.tv_nsec = 1;\n\t\titp->it_value.tv_sec = 0;\n\t}\n}", "target": 0}
{"code": "int register_power_pmu(struct power_pmu *pmu)\n{\n\tif (ppmu)\n\t\treturn -EBUSY;\t\t\n\tppmu = pmu;\n\tpr_info(\"%s performance monitor hardware support registered\\n\",\n\t\tpmu->name);\n#ifdef MSR_HV\n\tif (mfmsr() & MSR_HV)\n\t\tfreeze_events_kernel = MMCR0_FCHV;\n#endif \n\tperf_pmu_register(&power_pmu, \"cpu\", PERF_TYPE_RAW);\n\tperf_cpu_notifier(power_pmu_notifier);\n\treturn 0;\n}", "target": 0}
{"code": "static int set_register(pegasus_t *pegasus, __u16 indx, __u8 data)\n{\n\tint ret;\n\tret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_SET_REG, PEGASUS_REQT_WRITE, data,\n\t\t\t      indx, &data, 1, 1000);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\treturn ret;\n}", "target": 1}
{"code": "\tTEST_METHOD(7) {\n\t\tServerInstanceDir dir(parentDir + \"/passenger-test.1234\");\n\t\tServerInstanceDir::GenerationPtr generation = dir.newGeneration(true,\n\t\t\t\"nobody\", nobodyGroup, 0, 0);\n\t\tstring path = generation->getPath();\n\t\tgeneration.reset();\n\t\tensure_equals(getFileType(path), FT_NONEXISTANT);\n\t}", "target": 0}
{"code": "void connection_graceful_shutdown_maint (server *srv) {\n    connections * const conns = &srv->conns;\n    const int graceful_expire =\n      (srv->graceful_expire_ts && srv->graceful_expire_ts < log_epoch_secs);\n    for (uint32_t ndx = 0; ndx < conns->used; ++ndx) {\n        connection * const con = conns->ptr[ndx];\n        int changed = 0;\n        request_st * const r = &con->request;\n        if (r->state == CON_STATE_CLOSE) {\n            if (HTTP_LINGER_TIMEOUT > 1)\n                con->close_timeout_ts -= (HTTP_LINGER_TIMEOUT - 1);\n            if (log_epoch_secs - con->close_timeout_ts > HTTP_LINGER_TIMEOUT)\n                changed = 1;\n        }\n        else if (con->h2 && r->state == CON_STATE_WRITE) {\n            h2_send_goaway(con, H2_E_NO_ERROR);\n            if (0 == con->h2->rused && chunkqueue_is_empty(con->write_queue)) {\n                connection_set_state(r, CON_STATE_RESPONSE_END);\n                changed = 1;\n            }\n        }\n        else if (r->state == CON_STATE_READ && con->request_count > 1\n                 && chunkqueue_is_empty(con->read_queue)) {\n            connection_set_state_error(r, CON_STATE_ERROR);\n            changed = 1;\n        }\n        if (graceful_expire) {\n            connection_set_state_error(r, CON_STATE_ERROR);\n            changed = 1;\n        }\n        r->keep_alive = 0;            \n        r->conf.bytes_per_second = 0;         \n        r->conf.global_bytes_per_second = 0;  \n        if (con->traffic_limit_reached) {\n            con->traffic_limit_reached = 0;\n            changed = 1;\n        }\n        if (changed) {\n            connection_state_machine(con);\n        }\n    }\n}", "target": 0}
{"code": "void ConnectDialog::udpReply() {\n\tQUdpSocket *sock = qobject_cast<QUdpSocket *>(sender());\n\twhile (sock->hasPendingDatagrams()) {\n\t\tchar blob[64];\n\t\tQHostAddress host;\n\t\tunsigned short port;\n\t\tqint64 len = sock->readDatagram(blob+4, 24, &host, &port);\n\t\tif (len == 24) {\n\t\t\tif (host.scopeId() == QLatin1String(\"0\"))\n\t\t\t\thost.setScopeId(QLatin1String(\"\"));\n\t\t\tServerAddress address(HostAddress(host), port);\n\t\t\tif (qhPings.contains(address)) {\n\t\t\t\tquint32 *ping = reinterpret_cast<quint32 *>(blob+4);\n\t\t\t\tquint64 *ts = reinterpret_cast<quint64 *>(blob+8);\n\t\t\t\tquint64 elapsed = tPing.elapsed() - (*ts ^ qhPingRand.value(address));\n\t\t\t\tforeach(ServerItem *si, qhPings.value(address)) {\n\t\t\t\t\tsi->uiVersion = qFromBigEndian(ping[0]);\n\t\t\t\t\tquint32 users = qFromBigEndian(ping[3]);\n\t\t\t\t\tquint32 maxusers = qFromBigEndian(ping[4]);\n\t\t\t\t\tsi->uiBandwidth = qFromBigEndian(ping[5]);\n\t\t\t\t\tif (! si->uiPingSort)\n\t\t\t\t\t\tsi->uiPingSort = qmPingCache.value(UnresolvedServerAddress(si->qsHostname, si->usPort));\n\t\t\t\t\tsi->setDatas(static_cast<double>(elapsed), users, maxusers);\n\t\t\t\t\tsi->hideCheck();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "target": 0}
{"code": "find_file (const char *search_path, const char *base_name, char **pdir)\n{\n  FILE *file = 0;\n  foreach_dirinpath (search_path, base_name, find_file_callback, pdir, &file);\n  return file;\n}", "target": 0}
{"code": "static ssize_t set_bank(struct device *s, struct device_attribute *attr,\n\t\t\tconst char *buf, size_t size)\n{\n\tu64 new;\n\tif (kstrtou64(buf, 0, &new) < 0)\n\t\treturn -EINVAL;\n\tattr_to_bank(attr)->ctl = new;\n\tmce_restart();\n\treturn size;\n}", "target": 0}
{"code": "void nfs4_close_state(struct path *path, struct nfs4_state *state, mode_t mode)\n{\n\t__nfs4_close(path, state, mode, 0);\n}", "target": 1}
{"code": "static void free_loaded_vmcs(struct loaded_vmcs *loaded_vmcs)\n{\n\tif (!loaded_vmcs->vmcs)\n\t\treturn;\n\tloaded_vmcs_clear(loaded_vmcs);\n\tfree_vmcs(loaded_vmcs->vmcs);\n\tloaded_vmcs->vmcs = NULL;\n}", "target": 0}
{"code": "int __sched _cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "vq_endchains(struct virtio_vq_info *vq, int used_all_avail)\n{\n\tstruct virtio_base *base;\n\tuint16_t event_idx, new_idx, old_idx;\n\tint intr;\n\tatomic_thread_fence();\n\tbase = vq->base;\n\told_idx = vq->save_used;\n\tvq->save_used = new_idx = vq->used->idx;\n\tif (used_all_avail &&\n\t    (base->negotiated_caps & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)))\n\t\tintr = 1;\n\telse if (base->negotiated_caps & (1 << VIRTIO_RING_F_EVENT_IDX)) {\n\t\tevent_idx = VQ_USED_EVENT_IDX(vq);\n\t\tintr = (uint16_t)(new_idx - event_idx - 1) <\n\t\t\t(uint16_t)(new_idx - old_idx);\n\t} else {\n\t\tintr = new_idx != old_idx &&\n\t\t    !(vq->avail->flags & VRING_AVAIL_F_NO_INTERRUPT);\n\t}\n\tif (intr)\n\t\tvq_interrupt(base, vq);\n}", "target": 1}
{"code": "void git_tree_entry_free(git_tree_entry *entry)\n{\n\tif (entry == NULL)\n\t\treturn;\n\tgit__free(entry);\n}", "target": 0}
{"code": "static void hardware_disable_all_nolock(void)\n{\n\tBUG_ON(!kvm_usage_count);\n\tkvm_usage_count--;\n\tif (!kvm_usage_count)\n\t\ton_each_cpu(hardware_disable_nolock, NULL, 1);\n}", "target": 0}
{"code": "void ok_inflater_free(ok_inflater *inflater) {\n    if (inflater) {\n        ok_png_allocator allocator = inflater->allocator;\n        void *allocator_user_data = inflater->allocator_user_data;\n        allocator.free(allocator_user_data, inflater->buffer);\n        allocator.free(allocator_user_data, inflater->code_length_huffman);\n        allocator.free(allocator_user_data, inflater->literal_huffman);\n        allocator.free(allocator_user_data, inflater->distance_huffman);\n        allocator.free(allocator_user_data, inflater->fixed_literal_huffman);\n        allocator.free(allocator_user_data, inflater->fixed_distance_huffman);\n        allocator.free(allocator_user_data, inflater);\n    }\n}", "target": 0}
{"code": "ZEND_API void zend_objects_store_del_ref_by_handle_ex(zend_object_handle handle, const zend_object_handlers *handlers TSRMLS_DC) \n{\n\tstruct _store_object *obj;\n\tint failure = 0;\n\tif (!EG(objects_store).object_buckets) {\n\t\treturn;\n\t}\n\tobj = &EG(objects_store).object_buckets[handle].bucket.obj;\n\tif (EG(objects_store).object_buckets[handle].valid) {\n\t\tif (obj->refcount == 1) {\n\t\t\tif (!EG(objects_store).object_buckets[handle].destructor_called) {\n\t\t\t\tEG(objects_store).object_buckets[handle].destructor_called = 1;\n\t\t\t\tif (obj->dtor) {\n\t\t\t\t\tif (handlers && !obj->handlers) {\n\t\t\t\t\t\tobj->handlers = handlers;\n\t\t\t\t\t}\n\t\t\t\t\tzend_try {\n\t\t\t\t\t\tobj->dtor(obj->object, handle TSRMLS_CC);\n\t\t\t\t\t} zend_catch {\n\t\t\t\t\t\tfailure = 1;\n\t\t\t\t\t} zend_end_try();\n\t\t\t\t}\n\t\t\t}\n\t\t\tobj = &EG(objects_store).object_buckets[handle].bucket.obj;\n\t\t\tif (obj->refcount == 1) {\n\t\t\t\tGC_REMOVE_ZOBJ_FROM_BUFFER(obj);\n\t\t\t\tif (obj->free_storage) {\n\t\t\t\t\tzend_try {\n\t\t\t\t\t\tobj->free_storage(obj->object TSRMLS_CC);\n\t\t\t\t\t} zend_catch {\n\t\t\t\t\t\tfailure = 1;\n\t\t\t\t\t} zend_end_try();\n\t\t\t\t}\n\t\t\t\tZEND_OBJECTS_STORE_ADD_TO_FREE_LIST();\n\t\t\t}\n\t\t}\n\t}\n\tobj->refcount--;\n#if ZEND_DEBUG_OBJECTS\n\tif (obj->refcount == 0) {\n\t\tfprintf(stderr, \"Deallocated object id #%d\\n\", handle);\n\t} else {\n\t\tfprintf(stderr, \"Decreased refcount of object id #%d\\n\", handle);\n\t}\n#endif\n\tif (failure) {\n\t\tzend_bailout();\n\t}\n}", "target": 1}
{"code": "static int hns_xgmac_get_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn ARRAY_SIZE(g_xgmac_stats_string);\n\treturn 0;\n}", "target": 1}
{"code": "void fmtutil_macbitmap_read_pixmap_only_fields(deark *c, dbuf *f, struct fmtutil_macbitmap_info *bi,\n\ti64 pos)\n{\n\ti64 pixmap_version;\n\ti64 pack_size;\n\ti64 plane_bytes;\n\ti64 n;\n\tde_dbg(c, \"additional PixMap header fields, at %d\", (int)pos);\n\tde_dbg_indent(c, 1);\n\tpixmap_version = dbuf_getu16be(f, pos+0);\n\tde_dbg(c, \"pixmap version: %d\", (int)pixmap_version);\n\tbi->packing_type = dbuf_getu16be(f, pos+2);\n\tde_dbg(c, \"packing type: %d\", (int)bi->packing_type);\n\tpack_size = dbuf_getu32be(f, pos+4);\n\tde_dbg(c, \"pixel data length: %d\", (int)pack_size);\n\tbi->hdpi = pict_read_fixed(f, pos+8);\n\tbi->vdpi = pict_read_fixed(f, pos+12);\n\tde_dbg(c, \"dpi: %.2f\"DE_CHAR_TIMES\"%.2f\", bi->hdpi, bi->vdpi);\n\tbi->pixeltype = dbuf_getu16be(f, pos+16);\n\tbi->pixelsize = dbuf_getu16be(f, pos+18);\n\tbi->cmpcount = dbuf_getu16be(f, pos+20);\n\tbi->cmpsize = dbuf_getu16be(f, pos+22);\n\tde_dbg(c, \"pixel type=%d, bits/pixel=%d, components/pixel=%d, bits/comp=%d\",\n\t\t(int)bi->pixeltype, (int)bi->pixelsize, (int)bi->cmpcount, (int)bi->cmpsize);\n\tbi->pdwidth = (bi->rowbytes*8)/bi->pixelsize;\n\tif(bi->pdwidth < bi->npwidth) {\n\t\tbi->pdwidth = bi->npwidth;\n\t}\n\tplane_bytes = dbuf_getu32be(f, pos+24);\n\tde_dbg(c, \"plane bytes: %d\", (int)plane_bytes);\n\tbi->pmTable = (u32)dbuf_getu32be(f, pos+28);\n\tde_dbg(c, \"pmTable: 0x%08x\", (unsigned int)bi->pmTable);\n\tn = dbuf_getu32be(f, pos+32);\n\tde_dbg(c, \"pmReserved: 0x%08x\", (unsigned int)n);\n\tde_dbg_indent(c, -1);\n}", "target": 1}
{"code": "static int mp_get_count(struct sb_uart_state *state, struct serial_icounter_struct *icnt)\n{\n\tstruct serial_icounter_struct icount;\n\tstruct sb_uart_icount cnow;\n\tstruct sb_uart_port *port = state->port;\n\tspin_lock_irq(&port->lock);\n\tmemcpy(&cnow, &port->icount, sizeof(struct sb_uart_icount));\n\tspin_unlock_irq(&port->lock);\n\ticount.cts         = cnow.cts;\n\ticount.dsr         = cnow.dsr;\n\ticount.rng         = cnow.rng;\n\ticount.dcd         = cnow.dcd;\n\ticount.rx          = cnow.rx;\n\ticount.tx          = cnow.tx;\n\ticount.frame       = cnow.frame;\n\ticount.overrun     = cnow.overrun;\n\ticount.parity      = cnow.parity;\n\ticount.brk         = cnow.brk;\n\ticount.buf_overrun = cnow.buf_overrun;\n\treturn copy_to_user(icnt, &icount, sizeof(icount)) ? -EFAULT : 0;\n}", "target": 1}
{"code": "yang_read_deviate_units(struct ly_ctx *ctx, struct lys_deviate *deviate, struct lys_node *dev_target)\n{\n    const char **stritem;\n    int j;\n    if (dev_target->nodetype == LYS_LEAFLIST) {\n        stritem = &((struct lys_node_leaflist *)dev_target)->units;\n    } else if (dev_target->nodetype == LYS_LEAF) {\n        stritem = &((struct lys_node_leaf *)dev_target)->units;\n    } else {\n        LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"units\");\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Target node does not allow \\\"units\\\" property.\");\n        goto error;\n    }\n    if (deviate->mod == LY_DEVIATE_DEL) {\n        if (!ly_strequal(*stritem, deviate->units, 1)) {\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, deviate->units, \"units\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Value differs from the target being deleted.\");\n            goto error;\n        }\n        lydict_remove(ctx, *stritem);\n        *stritem = NULL;\n        j = -1;\n        while ((j = lys_ext_iter(dev_target->ext, dev_target->ext_size, j + 1, LYEXT_SUBSTMT_UNITS)) != -1) {\n            lyp_ext_instance_rm(ctx, &dev_target->ext, &dev_target->ext_size, j);\n            --j;\n        }\n    } else {\n        if (deviate->mod == LY_DEVIATE_ADD) {\n            if (*stritem) {\n                LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"units\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Adding property that already exists.\");\n                goto error;\n            }\n        } else { \n            if (!*stritem) {\n                LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"units\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Replacing a property that does not exist.\");\n                goto error;\n            }\n        }\n        lydict_remove(ctx, *stritem);\n        *stritem = lydict_insert(ctx, deviate->units, 0);\n    }\n    return EXIT_SUCCESS;\nerror:\n    return EXIT_FAILURE;\n}", "target": 0}
{"code": "static char *ptr_to_id(char *buf, char *end, void *ptr, struct printf_spec spec)\n{\n\tunsigned long hashval;\n\tif (unlikely(!have_filled_random_ptr_key)) {\n\t\tspec.field_width = 2 * sizeof(ptr);\n\t\treturn string(buf, end, \"(ptrval)\", spec);\n\t}\n#ifdef CONFIG_64BIT\n\thashval = (unsigned long)siphash_1u64((u64)ptr, &ptr_key);\n\thashval = hashval & 0xffffffff;\n#else\n\thashval = (unsigned long)siphash_1u32((u32)ptr, &ptr_key);\n#endif\n\treturn pointer_string(buf, end, (const void *)hashval, spec);\n}", "target": 1}
{"code": "case_map(OnigCaseFoldType* flagP, const OnigUChar** pp,\n\t const OnigUChar* end, OnigUChar* to, OnigUChar* to_end,\n\t const struct OnigEncodingTypeST* enc)\n{\n  OnigCodePoint code;\n  OnigUChar *to_start = to;\n  OnigCaseFoldType flags = *flagP;\n  while (*pp < end && to < to_end) {\n    code = *(*pp)++;\n    if (code == SHARP_s) {\n      if (flags & ONIGENC_CASE_UPCASE) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\t*to++ = 'S';\n\tcode = (flags & ONIGENC_CASE_TITLECASE) ? 's' : 'S';\n      }\n      else if (flags & ONIGENC_CASE_FOLD) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\t*to++ = 's';\n\tcode = 's';\n      }\n    }\n    else if ((EncCP1254_CtypeTable[code] & BIT_CTYPE_UPPER)\n\t     && (flags & (ONIGENC_CASE_DOWNCASE | ONIGENC_CASE_FOLD))) {\n      flags |= ONIGENC_CASE_MODIFIED;\n      if (code == 'I')\n\tcode = flags & ONIGENC_CASE_FOLD_TURKISH_AZERI ? DOTLESS_i : 'i';\n      else\n        code = ENC_CP1254_TO_LOWER_CASE(code);\n    }\n    else if (code == 0x83 || code == 0xAA || code == 0xBA || code == 0xB5)\n      ;\n    else if ((EncCP1254_CtypeTable[code] & BIT_CTYPE_LOWER)\n\t     && (flags & ONIGENC_CASE_UPCASE)) {\n      flags |= ONIGENC_CASE_MODIFIED;\n      if (code == 'i')\n\tcode = flags & ONIGENC_CASE_FOLD_TURKISH_AZERI ? I_WITH_DOT_ABOVE : 'I';\n      else if (code == DOTLESS_i)\n\tcode = 'I';\n      else if (code == 0x9A || code == 0x9C || code == 0x9E)\n\tcode -= 0x10;\n      else if (code == 0xFF)\n\tcode -= 0x60;\n      else\n\tcode -= 0x20;\n    }\n    *to++ = code;\n    if (flags & ONIGENC_CASE_TITLECASE)  \n      flags ^= (ONIGENC_CASE_UPCASE | ONIGENC_CASE_DOWNCASE | ONIGENC_CASE_TITLECASE);\n  }\n  *flagP = flags;\n  return (int )(to - to_start);\n}", "target": 0}
{"code": "   Format a local time/date according to locale settings */\nPHP_FUNCTION(strftime)\n{\n\tphp_strftime(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);", "target": 0}
{"code": "static int omninet_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct usb_serial\t*serial = port->serial;\n\tstruct usb_serial_port\t*wport;\n\twport = serial->port[1];\n\ttty_port_tty_set(&wport->port, tty);\n\treturn usb_serial_generic_open(tty, port);\n}", "target": 1}
{"code": "make_valid_utf8 (string & str)\n{\n  const char *pos;\n  if (!g_utf8_validate (str.c_str(), -1, &pos)) {\n    PTRACE (4, \"Ekiga\\tTrimming invalid UTF-8 string: \" << str.c_str());\n    str = str.substr (0, pos - str.c_str()).append (\"...\");\n  }\n}", "target": 0}
{"code": "cib_remote_dispatch(gpointer user_data)\n{\n    cib_t *cib = user_data;\n    cib_remote_opaque_t *private = cib->variant_opaque;\n    xmlNode *msg = NULL;\n    const char *type = NULL;\n    crm_info(\"Message on callback channel\");\n    msg = crm_recv_remote_msg(private->callback.session, private->callback.encrypted);\n    type = crm_element_value(msg, F_TYPE);\n    crm_trace(\"Activating %s callbacks...\", type);\n    if (safe_str_eq(type, T_CIB)) {\n        cib_native_callback(cib, msg, 0, 0);\n    } else if (safe_str_eq(type, T_CIB_NOTIFY)) {\n        g_list_foreach(cib->notify_list, cib_native_notify, msg);\n    } else {\n        crm_err(\"Unknown message type: %s\", type);\n    }\n    if (msg != NULL) {\n        free_xml(msg);\n        return 0;\n    }\n    return -1;\n}", "target": 1}
{"code": "static bool ok_inflater_init_fixed_huffman(ok_inflater *inflater) {\n    if (!inflater->fixed_literal_huffman) {\n        ok_inflater_huffman_tree *tree = ok_alloc(inflater, sizeof(ok_inflater_huffman_tree));\n        if (tree) {\n            uint8_t code_length[288];\n            int i;\n            for (i = 0; i < 144; i++) {\n                code_length[i] = 8;\n            }\n            for (i = 144; i < 256; i++) {\n                code_length[i] = 9;\n            }\n            for (i = 256; i < 280; i++) {\n                code_length[i] = 7;\n            }\n            for (i = 280; i < 288; i++) {\n                code_length[i] = 8;\n            }\n            ok_inflater_make_huffman_tree_from_array(tree, code_length,\n                                                     sizeof(code_length) / sizeof(code_length[0]));\n            inflater->fixed_literal_huffman = tree;\n        }\n    }\n    if (!inflater->fixed_distance_huffman) {\n        ok_inflater_huffman_tree *tree = ok_alloc(inflater, sizeof(ok_inflater_huffman_tree));\n        if (tree) {\n            uint8_t distance_code_length[32];\n            for (int i = 0; i < 32; i++) {\n                distance_code_length[i] = 5;\n            }\n            ok_inflater_make_huffman_tree_from_array(tree, distance_code_length, 32);\n            inflater->fixed_distance_huffman = tree;\n        }\n    }\n    return inflater->fixed_literal_huffman && inflater->fixed_distance_huffman;\n}", "target": 0}
{"code": "static xmlParserCtxtPtr createMemoryParser(xmlSAXHandlerPtr handlers, void* userData, const char* chunk)\n{\n    if (!didInit) {\n        xmlInitParser();\n        xmlRegisterInputCallbacks(matchFunc, openFunc, readFunc, closeFunc);\n        xmlRegisterOutputCallbacks(matchFunc, openFunc, writeFunc, closeFunc);\n        libxmlLoaderThread = currentThread();\n        didInit = true;\n    }\n    xmlParserCtxtPtr parser = xmlCreateMemoryParserCtxt(chunk, xmlStrlen((const xmlChar*)chunk));\n    if (!parser)\n        return 0;\n    memcpy(parser->sax, handlers, sizeof(xmlSAXHandler));\n    xmlCtxtUseOptions(parser, XML_PARSE_NODICT | XML_PARSE_NOENT);\n    parser->sax2 = 1;\n    parser->instate = XML_PARSER_CONTENT; \n    parser->depth = 0;\n    parser->str_xml = xmlDictLookup(parser->dict, BAD_CAST \"xml\", 3);\n    parser->str_xmlns = xmlDictLookup(parser->dict, BAD_CAST \"xmlns\", 5);\n    parser->str_xml_ns = xmlDictLookup(parser->dict, XML_XML_NAMESPACE, 36);\n    parser->_private = userData;\n    return parser;\n}", "target": 0}
{"code": "xfs_iunlink_remove(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_agi\t\t*agi;\n\tstruct xfs_buf\t\t*agibp;\n\tstruct xfs_buf\t\t*last_ibp;\n\tstruct xfs_dinode\t*last_dip = NULL;\n\txfs_agnumber_t\t\tagno = XFS_INO_TO_AGNO(mp, ip->i_ino);\n\txfs_agino_t\t\tagino = XFS_INO_TO_AGINO(mp, ip->i_ino);\n\txfs_agino_t\t\tnext_agino;\n\txfs_agino_t\t\thead_agino;\n\tshort\t\t\tbucket_index = agino % XFS_AGI_UNLINKED_BUCKETS;\n\tint\t\t\terror;\n\ttrace_xfs_iunlink_remove(ip);\n\terror = xfs_read_agi(mp, tp, agno, &agibp);\n\tif (error)\n\t\treturn error;\n\tagi = agibp->b_addr;\n\thead_agino = be32_to_cpu(agi->agi_unlinked[bucket_index]);\n\tif (!xfs_verify_agino(mp, agno, head_agino)) {\n\t\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp,\n\t\t\t\tagi, sizeof(*agi));\n\t\treturn -EFSCORRUPTED;\n\t}\n\terror = xfs_iunlink_update_inode(tp, ip, agno, NULLAGINO, &next_agino);\n\tif (error)\n\t\treturn error;\n\tif (next_agino != NULLAGINO) {\n\t\terror = xfs_iunlink_change_backref(agibp->b_pag, next_agino,\n\t\t\t\tNULLAGINO);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (head_agino != agino) {\n\t\tstruct xfs_imap\timap;\n\t\txfs_agino_t\tprev_agino;\n\t\terror = xfs_iunlink_map_prev(tp, agno, head_agino, agino,\n\t\t\t\t&prev_agino, &imap, &last_dip, &last_ibp,\n\t\t\t\tagibp->b_pag);\n\t\tif (error)\n\t\t\treturn error;\n\t\txfs_iunlink_update_dinode(tp, agno, prev_agino, last_ibp,\n\t\t\t\tlast_dip, &imap, next_agino);\n\t\treturn xfs_iunlink_change_backref(agibp->b_pag, agino,\n\t\t\t\tnext_agino);\n\t}\n\treturn xfs_iunlink_update_bucket(tp, agno, agibp, bucket_index,\n\t\t\tnext_agino);\n}", "target": 0}
{"code": "static char *get_pid_cgroup(pid_t pid, const char *contrl)\n{\n\tchar fnam[PROCLEN];\n\tFILE *f;\n\tchar *answer = NULL;\n\tchar *line = NULL;\n\tsize_t len = 0;\n\tint ret;\n\tconst char *h = find_mounted_controller(contrl);\n\tif (!h)\n\t\treturn NULL;\n\tret = snprintf(fnam, PROCLEN, \"/proc/%d/cgroup\", pid);\n\tif (ret < 0 || ret >= PROCLEN)\n\t\treturn NULL;\n\tif (!(f = fopen(fnam, \"r\")))\n\t\treturn NULL;\n\twhile (getline(&line, &len, f) != -1) {\n\t\tchar *c1, *c2;\n\t\tif (!line[0])\n\t\t\tcontinue;\n\t\tc1 = strchr(line, ':');\n\t\tif (!c1)\n\t\t\tgoto out;\n\t\tc1++;\n\t\tc2 = strchr(c1, ':');\n\t\tif (!c2)\n\t\t\tgoto out;\n\t\t*c2 = '\\0';\n\t\tif (strcmp(c1, h) != 0)\n\t\t\tcontinue;\n\t\tc2++;\n\t\tstripnewline(c2);\n\t\tdo {\n\t\t\tanswer = strdup(c2);\n\t\t} while (!answer);\n\t\tbreak;\n\t}\nout:\n\tfclose(f);\n\tfree(line);\n\treturn answer;\n}", "target": 0}
{"code": "string Print(const FunctionDef& fdef) {\n  string out;\n  const OpDef& sig = fdef.signature();\n  strings::StrAppend(&out, \"\\n\", sig.name());\n  if (sig.attr_size() > 0) {\n    strings::StrAppend(&out, \"[\");\n    for (int i = 0; i < sig.attr_size(); ++i) {\n      const auto& a = sig.attr(i);\n      if (i > 0) strings::StrAppend(&out, \", \");\n      if (a.type() == \"type\") {\n        strings::StrAppend(&out, a.name(), \":\", Print(a.allowed_values()));\n      } else {\n        strings::StrAppend(&out, a.name(), \":\", a.type());\n      }\n    }\n    strings::StrAppend(&out, \"]\");\n  }\n  strings::StrAppend(&out, \"(\");\n  for (int i = 0; i < sig.input_arg_size(); ++i) {\n    if (i > 0) strings::StrAppend(&out, \", \");\n    strings::StrAppend(&out, Print(sig.input_arg(i)));\n  }\n  strings::StrAppend(&out, \") -> (\");\n  for (int i = 0; i < sig.output_arg_size(); ++i) {\n    if (i > 0) strings::StrAppend(&out, \", \");\n    strings::StrAppend(&out, Print(sig.output_arg(i)));\n  }\n  strings::StrAppend(&out, \") {\\n\");\n  for (const auto& n : fdef.node_def()) {\n    strings::StrAppend(&out, \"  \", Print(n), \"\\n\");\n  }\n  for (const auto& cr : fdef.control_ret()) {\n    strings::StrAppend(&out, \"  @return \", cr.first, \" = \", cr.second, \"\\n\");\n  }\n  for (const auto& r : fdef.ret()) {\n    strings::StrAppend(&out, \"  return \", r.first, \" = \", r.second, \"\\n\");\n  }\n  strings::StrAppend(&out, \"}\\n\");\n  return out;\n}", "target": 0}
{"code": "static int proc_parse_options(char *options, struct pid_namespace *pid)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tif (!options)\n\t\treturn 1;\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\targs[0].to = args[0].from = NULL;\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tpid->pid_gid = make_kgid(current_user_ns(), option);\n\t\t\tbreak;\n\t\tcase Opt_hidepid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tif (option < 0 || option > 2) {\n\t\t\t\tpr_err(\"proc: hidepid value must be between 0 and 2.\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpid->hide_pid = option;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"proc: unrecognized mount option \\\"%s\\\" \"\n\t\t\t       \"or missing value\\n\", p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "static PHP_NAMED_FUNCTION(zif_zip_entry_read)\n{\n\tzval * zip_entry;\n\tzend_long len = 0;\n\tzip_read_rsrc * zr_rsrc;\n\tzend_string *buffer;\n\tint n = 0;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"r|l\", &zip_entry, &len) == FAILURE) {\n\t\treturn;\n\t}\n\tif ((zr_rsrc = (zip_read_rsrc *)zend_fetch_resource(Z_RES_P(zip_entry), le_zip_entry_name, le_zip_entry)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tif (len <= 0) {\n\t\tlen = 1024;\n\t}\n\tif (zr_rsrc->zf) {\n\t\tbuffer = zend_string_alloc(len, 0);\n\t\tn = zip_fread(zr_rsrc->zf, ZSTR_VAL(buffer), ZSTR_LEN(buffer));\n\t\tif (n > 0) {\n\t\t\tZSTR_VAL(buffer)[n] = '\\0';\n\t\t\tZSTR_LEN(buffer) = n;\n\t\t\tRETURN_NEW_STR(buffer);\n\t\t} else {\n\t\t\tzend_string_free(buffer);\n\t\t\tRETURN_EMPTY_STRING()\n\t\t}\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}", "target": 1}
{"code": "parse_memory(VALUE klass, VALUE data)\n{\n  xmlParserCtxtPtr ctxt;\n  if (NIL_P(data)) {\n    rb_raise(rb_eArgError, \"data cannot be nil\");\n  }\n  if (!(int)RSTRING_LEN(data)) {\n    rb_raise(rb_eRuntimeError, \"data cannot be empty\");\n  }\n  ctxt = xmlCreateMemoryParserCtxt(StringValuePtr(data),\n                                   (int)RSTRING_LEN(data));\n  if (ctxt->sax) {\n    xmlFree(ctxt->sax);\n    ctxt->sax = NULL;\n  }\n  return Data_Wrap_Struct(klass, NULL, deallocate, ctxt);\n}", "target": 1}
{"code": "ciEnv::ciEnv(CompileTask* task)\n  : _ciEnv_arena(mtCompiler) {\n  VM_ENTRY_MARK;\n  thread->set_env(this);\n  assert(ciEnv::current() == this, \"sanity\");\n  _oop_recorder = NULL;\n  _debug_info = NULL;\n  _dependencies = NULL;\n  _failure_reason = NULL;\n  _inc_decompile_count_on_failure = true;\n  _compilable = MethodCompilable;\n  _break_at_compile = false;\n  _compiler_data = NULL;\n#ifndef PRODUCT\n  assert(!firstEnv, \"not initialized properly\");\n#endif \n  _num_inlined_bytecodes = 0;\n  assert(task == NULL || thread->task() == task, \"sanity\");\n  if (task != NULL) {\n    task->mark_started(os::elapsed_counter());\n  }\n  _task = task;\n  _log = NULL;\n  _name_buffer = NULL;\n  _name_buffer_len = 0;\n  _arena   = &_ciEnv_arena;\n  _factory = new (_arena) ciObjectFactory(_arena, 128);\n  assert(Universe::is_fully_initialized(), \"should be complete\");\n  oop o = Universe::null_ptr_exception_instance();\n  assert(o != NULL, \"should have been initialized\");\n  _NullPointerException_instance = get_object(o)->as_instance();\n  o = Universe::arithmetic_exception_instance();\n  assert(o != NULL, \"should have been initialized\");\n  _ArithmeticException_instance = get_object(o)->as_instance();\n  _ArrayIndexOutOfBoundsException_instance = NULL;\n  _ArrayStoreException_instance = NULL;\n  _ClassCastException_instance = NULL;\n  _the_null_string = NULL;\n  _the_min_jint_string = NULL;\n  _jvmti_redefinition_count = 0;\n  _jvmti_can_hotswap_or_post_breakpoint = false;\n  _jvmti_can_access_local_variables = false;\n  _jvmti_can_post_on_exceptions = false;\n  _jvmti_can_pop_frame = false;\n}", "target": 0}
{"code": "list_ne_name_resources (WinLibrary *fi, WinResource *typeres, int *count)\n{\n    int c, rescnt;\n    WinResource *wr;\n    Win16NETypeInfo *typeinfo = (Win16NETypeInfo *) typeres->this;\n    Win16NENameInfo *nameinfo = (Win16NENameInfo *) typeres->children;\n    RETURN_IF_BAD_POINTER(NULL, typeinfo->count);\n    *count = rescnt = typeinfo->count;\n    if (rescnt == 0) return NULL;\n    wr = xmalloc(sizeof(WinResource) * rescnt);\n    for (c = 0 ; c < rescnt ; c++) {\n        RETURN_IF_BAD_POINTER(NULL, nameinfo[c]);\n        wr[c].this = nameinfo+c;\n        wr[c].is_directory = false;\n        wr[c].children = nameinfo+c;\n        wr[c].level = 1;\n        if (!decode_ne_resource_id (fi, wr + c, (nameinfo+c)->id)) {\n            free(wr);\n            return NULL;\n        }\n    }\n    return wr;\n}", "target": 0}
{"code": "static int decode_attr_maxname(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *maxname)\n{\n\t__be32 *p;\n\tint status = 0;\n\t*maxname = 1024;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_MAXNAME - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_MAXNAME)) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\tgoto out_overflow;\n\t\t*maxname = be32_to_cpup(p);\n\t\tbitmap[0] &= ~FATTR4_WORD0_MAXNAME;\n\t}\n\tdprintk(\"%s: maxname=%u\\n\", __func__, *maxname);\n\treturn status;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}", "target": 0}
{"code": "int git_delta_read_header_fromstream(\n\tsize_t *base_sz, size_t *res_sz, git_packfile_stream *stream)\n{\n\tstatic const size_t buffer_len = DELTA_HEADER_BUFFER_LEN;\n\tunsigned char buffer[DELTA_HEADER_BUFFER_LEN];\n\tconst unsigned char *delta, *delta_end;\n\tsize_t len;\n\tssize_t read;\n\tlen = read = 0;\n\twhile (len < buffer_len) {\n\t\tread = git_packfile_stream_read(stream, &buffer[len], buffer_len - len);\n\t\tif (read == 0)\n\t\t\tbreak;\n\t\tif (read == GIT_EBUFS)\n\t\t\tcontinue;\n\t\tlen += read;\n\t}\n\tdelta = buffer;\n\tdelta_end = delta + len;\n\tif ((hdr_sz(base_sz, &delta, delta_end) < 0) ||\n\t\t(hdr_sz(res_sz, &delta, delta_end) < 0))\n\t\treturn -1;\n\treturn 0;\n}", "target": 0}
{"code": "static bool ok_jpg_decode_restart_if_needed(ok_jpg_decoder *decoder) {\n    if (decoder->restart_intervals_remaining > 0) {\n        decoder->restart_intervals_remaining--;\n        if (decoder->restart_intervals_remaining == 0) {\n            ok_jpg_dump_bits(decoder);\n            if (decoder->next_marker != 0) {\n                if (decoder->next_marker == 0xD0 + decoder->next_restart) {\n                    decoder->next_marker = 0;\n                } else {\n                    ok_jpg_error(decoder->jpg, OK_JPG_ERROR_INVALID, \"Invalid restart marker (1)\");\n                    return false;\n                }\n            } else {\n                uint8_t buffer[2];\n                if (!ok_read(decoder, buffer, 2)) {\n                    return false;\n                }\n                if (!(buffer[0] == 0xff && buffer[1] == 0xD0 + decoder->next_restart)) {\n                    ok_jpg_error(decoder->jpg, OK_JPG_ERROR_INVALID, \"Invalid restart marker (2)\");\n                    return false;\n                }\n            }\n            decoder->next_restart = (decoder->next_restart + 1) & 7;\n            ok_jpg_decode_restart(decoder);\n        }\n    }\n    return true;\n}", "target": 0}
{"code": "static int snd_usb_accessmusic_boot_quirk(struct usb_device *dev)\n{\n\tint err, actual_length;\n\tstatic const u8 seq[] = { 0x4e, 0x73, 0x52, 0x01 };\n\tvoid *buf = kmemdup(seq, ARRAY_SIZE(seq), GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\terr = usb_interrupt_msg(dev, usb_sndintpipe(dev, 0x05), buf,\n\t\t\tARRAY_SIZE(seq), &actual_length, 1000);\n\tkfree(buf);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}", "target": 0}
{"code": "static int sco_sock_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t       char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint len, err = 0;\n\tstruct bt_voice voice;\n\tu32 phys;\n\tint pkt_status;\n\tBT_DBG(\"sk %p\", sk);\n\tif (level == SOL_SCO)\n\t\treturn sco_sock_getsockopt_old(sock, optname, optval, optlen);\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tlock_sock(sk);\n\tswitch (optname) {\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (put_user(test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags),\n\t\t\t     (u32 __user *)optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase BT_VOICE:\n\t\tvoice.setting = sco_pi(sk)->setting;\n\t\tlen = min_t(unsigned int, len, sizeof(voice));\n\t\tif (copy_to_user(optval, (char *)&voice, len))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase BT_PHY:\n\t\tif (sk->sk_state != BT_CONNECTED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\t\tphys = hci_conn_get_phy(sco_pi(sk)->conn->hcon);\n\t\tif (put_user(phys, (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase BT_PKT_STATUS:\n\t\tpkt_status = (sco_pi(sk)->cmsg_mask & SCO_CMSG_PKT_STATUS);\n\t\tif (put_user(pkt_status, (int __user *)optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase BT_SNDMTU:\n\tcase BT_RCVMTU:\n\t\tif (sk->sk_state != BT_CONNECTED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\t\tif (put_user(sco_pi(sk)->conn->mtu, (u32 __user *)optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "static int FNAME(sync_page)(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp)\n{\n\tint i, nr_present = 0;\n\tbool host_writable;\n\tgpa_t first_pte_gpa;\n\tint set_spte_ret = 0;\n\tBUG_ON(sp->role.direct);\n\tfirst_pte_gpa = FNAME(get_level1_sp_gpa)(sp);\n\tfor (i = 0; i < PT64_ENT_PER_PAGE; i++) {\n\t\tunsigned pte_access;\n\t\tpt_element_t gpte;\n\t\tgpa_t pte_gpa;\n\t\tgfn_t gfn;\n\t\tif (!sp->spt[i])\n\t\t\tcontinue;\n\t\tpte_gpa = first_pte_gpa + i * sizeof(pt_element_t);\n\t\tif (kvm_vcpu_read_guest_atomic(vcpu, pte_gpa, &gpte,\n\t\t\t\t\t       sizeof(pt_element_t)))\n\t\t\treturn 0;\n\t\tif (FNAME(prefetch_invalid_gpte)(vcpu, sp, &sp->spt[i], gpte)) {\n\t\t\tsmp_wmb();\n\t\t\tvcpu->kvm->tlbs_dirty++;\n\t\t\tcontinue;\n\t\t}\n\t\tgfn = gpte_to_gfn(gpte);\n\t\tpte_access = sp->role.access;\n\t\tpte_access &= FNAME(gpte_access)(gpte);\n\t\tFNAME(protect_clean_gpte)(vcpu->arch.mmu, &pte_access, gpte);\n\t\tif (sync_mmio_spte(vcpu, &sp->spt[i], gfn, pte_access,\n\t\t      &nr_present))\n\t\t\tcontinue;\n\t\tif (gfn != sp->gfns[i]) {\n\t\t\tdrop_spte(vcpu->kvm, &sp->spt[i]);\n\t\t\tsmp_wmb();\n\t\t\tvcpu->kvm->tlbs_dirty++;\n\t\t\tcontinue;\n\t\t}\n\t\tnr_present++;\n\t\thost_writable = sp->spt[i] & SPTE_HOST_WRITEABLE;\n\t\tset_spte_ret |= set_spte(vcpu, &sp->spt[i],\n\t\t\t\t\t pte_access, PT_PAGE_TABLE_LEVEL,\n\t\t\t\t\t gfn, spte_to_pfn(sp->spt[i]),\n\t\t\t\t\t true, false, host_writable);\n\t}\n\tif (set_spte_ret & SET_SPTE_NEED_REMOTE_TLB_FLUSH)\n\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n\treturn nr_present;\n}", "target": 0}
{"code": "static int nft_delflowtable_hook(struct nft_ctx *ctx,\n\t\t\t\t struct nft_flowtable *flowtable)\n{\n\tconst struct nlattr * const *nla = ctx->nla;\n\tstruct nft_flowtable_hook flowtable_hook;\n\tLIST_HEAD(flowtable_del_list);\n\tstruct nft_hook *this, *hook;\n\tstruct nft_trans *trans;\n\tint err;\n\terr = nft_flowtable_parse_hook(ctx, nla[NFTA_FLOWTABLE_HOOK],\n\t\t\t\t       &flowtable_hook, flowtable, false);\n\tif (err < 0)\n\t\treturn err;\n\tlist_for_each_entry(this, &flowtable_hook.list, list) {\n\t\thook = nft_hook_list_find(&flowtable->hook_list, this);\n\t\tif (!hook) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto err_flowtable_del_hook;\n\t\t}\n\t\tlist_move(&hook->list, &flowtable_del_list);\n\t}\n\ttrans = nft_trans_alloc(ctx, NFT_MSG_DELFLOWTABLE,\n\t\t\t\tsizeof(struct nft_trans_flowtable));\n\tif (!trans) {\n\t\terr = -ENOMEM;\n\t\tgoto err_flowtable_del_hook;\n\t}\n\tnft_trans_flowtable(trans) = flowtable;\n\tnft_trans_flowtable_update(trans) = true;\n\tINIT_LIST_HEAD(&nft_trans_flowtable_hooks(trans));\n\tlist_splice(&flowtable_del_list, &nft_trans_flowtable_hooks(trans));\n\tnft_flowtable_hook_release(&flowtable_hook);\n\tnft_trans_commit_list_add_tail(ctx->net, trans);\n\treturn 0;\nerr_flowtable_del_hook:\n\tlist_splice(&flowtable_del_list, &flowtable->hook_list);\n\tnft_flowtable_hook_release(&flowtable_hook);\n\treturn err;\n}", "target": 0}
{"code": "GF_Box *gf_isom_clone_config_box(GF_Box *box)\n{\n\tu8 *data=NULL;\n\tu32 size=0;\n\tGF_Err e;\n\tGF_Box *clone=NULL;\n\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\te = gf_isom_box_size(box);\n\tif (!e)\n\t\te = gf_isom_box_write(box, bs);\n\tgf_bs_get_content(bs, &data, &size);\n\tgf_bs_del(bs);\n\tif (!e) {\n\t\tbs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n\t\te = gf_isom_box_parse(&clone, bs);\n\t\tgf_bs_del(bs);\n\t}\n\tif (data)\n\t\tgf_free(data);\n\tif (e) {\n\t\tif (clone)\n\t\t\tgf_isom_box_del(clone);\n\t\tclone = NULL;\n\t}\n\treturn clone;\n}", "target": 0}
{"code": "void\nyyerror(YYLTYPE *yylloc, void *scanner, struct yang_parameter *param, ...)\n{\n  free(*param->value);\n  if (yylloc->first_line != -1) {\n    if (*param->data_node && (*param->data_node) == (*param->actual_node)) {\n      LOGVAL(param->module->ctx, LYE_INSTMT, LY_VLOG_LYS, *param->data_node, yyget_text(scanner));\n    } else {\n      LOGVAL(param->module->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, yyget_text(scanner));\n    }\n  }", "target": 1}
{"code": "static int tcp_parse_aligned_timestamp(struct tcp_sock *tp, const struct tcphdr *th)\n{\n\tconst __be32 *ptr = (const __be32 *)(th + 1);\n\tif (*ptr == htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16)\n\t\t\t  | (TCPOPT_TIMESTAMP << 8) | TCPOLEN_TIMESTAMP)) {\n\t\ttp->rx_opt.saw_tstamp = 1;\n\t\t++ptr;\n\t\ttp->rx_opt.rcv_tsval = ntohl(*ptr);\n\t\t++ptr;\n\t\ttp->rx_opt.rcv_tsecr = ntohl(*ptr);\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static inline void encode_openhdr(struct xdr_stream *xdr, const struct nfs_openargs *arg)\n{\n\t__be32 *p;\n\tRESERVE_SPACE(8);\n\tWRITE32(OP_OPEN);\n\tWRITE32(arg->seqid->sequence->counter);\n\tencode_share_access(xdr, arg->open_flags);\n\tRESERVE_SPACE(28);\n\tWRITE64(arg->clientid);\n\tWRITE32(16);\n\tWRITEMEM(\"open id:\", 8);\n\tWRITE64(arg->id);\n}", "target": 1}
{"code": "void AsfVideo::fileProperties() {\n  DataBuf FileIddBuf = io_->read(GUID);\n  xmpData()[\"Xmp.video.FileID\"] = GUIDTag(FileIddBuf.data()).to_string();\n  xmpData()[\"Xmp.video.FileLength\"] = readQWORDTag(io_);\n  xmpData()[\"Xmp.video.CreationDate\"] = readQWORDTag(io_);\n  xmpData()[\"Xmp.video.DataPackets\"] = readQWORDTag(io_);\n  xmpData()[\"Xmp.video.duration\"] = readQWORDTag(io_);\n  xmpData()[\"Xmp.video.SendDuration\"] = readQWORDTag(io_);\n  xmpData()[\"Xmp.video.Preroll\"] = readQWORDTag(io_);\n  io_->seek(io_->tell() + DWORD + DWORD + DWORD,\n            BasicIo::beg);  \n  xmpData()[\"Xmp.video.MaxBitRate\"] = readDWORDTag(io_);\n}  ", "target": 1}
{"code": "static void set_error_response(h2_stream *stream, int http_status)\n{\n    if (!h2_stream_is_ready(stream)) {\n        stream->rtmp->http_status = http_status;\n    }\n}", "target": 1}
{"code": "snmp_api_set_time_ticks(snmp_varbind_t *varbind, uint32_t *oid, uint32_t integer)\n{\n  snmp_api_replace_oid(varbind, oid);\n  varbind->value_type = SNMP_DATA_TYPE_TIME_TICKS;\n  varbind->value.integer = integer;\n}", "target": 1}
{"code": "static int fsmReadLink(const char *path,\n\t\t       char *buf, size_t bufsize, size_t *linklen)\n{\n    ssize_t llen = readlink(path, buf, bufsize - 1);\n    int rc = RPMERR_READLINK_FAILED;\n    if (_fsm_debug) {\n        rpmlog(RPMLOG_DEBUG, \" %8s (%s, buf, %d) %s\\n\",\n\t       __func__,\n               path, (int)(bufsize -1), (llen < 0 ? strerror(errno) : \"\"));\n    }\n    if (llen >= 0) {\n\tbuf[llen] = '\\0';\n\trc = 0;\n\t*linklen = llen;\n    }\n    return rc;\n}", "target": 0}
{"code": "SpiceMsgChannels *reds_msg_channels_new(RedsState *reds)\n{\n    SpiceMsgChannels* channels_info;\n    spice_assert(reds != NULL);\n    channels_info = (SpiceMsgChannels *)g_malloc(sizeof(SpiceMsgChannels)\n                            + reds->channels.size() * sizeof(SpiceChannelId));\n    reds_fill_channels(reds, channels_info);\n    return channels_info;\n}", "target": 0}
{"code": "static struct kmem_cache * __init bootstrap(struct kmem_cache *static_cache)\n{\n\tint node;\n\tstruct kmem_cache *s = kmem_cache_zalloc(kmem_cache, GFP_NOWAIT);\n\tstruct kmem_cache_node *n;\n\tmemcpy(s, static_cache, kmem_cache->object_size);\n\t__flush_cpu_slab(s, smp_processor_id());\n\tfor_each_kmem_cache_node(s, node, n) {\n\t\tstruct page *p;\n\t\tlist_for_each_entry(p, &n->partial, slab_list)\n\t\t\tp->slab_cache = s;\n#ifdef CONFIG_SLUB_DEBUG\n\t\tlist_for_each_entry(p, &n->full, slab_list)\n\t\t\tp->slab_cache = s;\n#endif\n\t}\n\tslab_init_memcg_params(s);\n\tlist_add(&s->list, &slab_caches);\n\tmemcg_link_cache(s, NULL);\n\treturn s;\n}", "target": 0}
{"code": "static int em_loop(struct x86_emulate_ctxt *ctxt)\n{\n\tregister_address_increment(ctxt, reg_rmw(ctxt, VCPU_REGS_RCX), -1);\n\tif ((address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) != 0) &&\n\t    (ctxt->b == 0xe2 || test_cc(ctxt->b ^ 0x5, ctxt->eflags)))\n\t\tjmp_rel(ctxt, ctxt->src.val);\n\treturn X86EMUL_CONTINUE;\n}", "target": 1}
{"code": "static void *_clua_allocator(void *ud, void *ptr, size_t osize, size_t nsize)\n{\n    CLua *cl = static_cast<CLua *>(ud);\n    cl->memory_used += nsize - osize;\n    if (nsize > osize && cl->memory_used >= CLUA_MAX_MEMORY_USE * 1024\n        && cl->mixed_call_depth)\n    {\n        return nullptr;\n    }\n    if (!nsize)\n    {\n        free(ptr);\n        return nullptr;\n    }\n    else\n        return realloc(ptr, nsize);\n}", "target": 0}
{"code": "_fr_window_ask_overwrite_dialog (OverwriteData *odata)\n{\n\tif ((odata->edata->overwrite == FR_OVERWRITE_ASK) && (odata->current_file != NULL)) {\n\t\tconst char *base_name;\n\t\tGFile      *destination;\n\t\tbase_name = _g_path_get_relative_basename ((char *) odata->current_file->data, odata->edata->base_dir, odata->edata->junk_paths);\n\t\tdestination = g_file_get_child (odata->edata->destination, base_name);\n\t\tg_file_query_info_async (destination,\n\t\t\t\t\t G_FILE_ATTRIBUTE_STANDARD_TYPE \",\" G_FILE_ATTRIBUTE_STANDARD_NAME \",\" G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME,\n\t\t\t\t\t G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n\t\t\t\t\t G_PRIORITY_DEFAULT,\n\t\t\t\t\t odata->window->priv->cancellable,\n\t\t\t\t\t query_info_ready_for_overwrite_dialog_cb,\n\t\t\t\t\t odata);\n\t\tg_object_unref (destination);\n\t\treturn;\n\t}\n\tif (odata->edata->file_list != NULL) {\n\t\tif (odata->extract_all) {\n\t\t\t_g_string_list_free (odata->edata->file_list);\n\t\t\todata->edata->file_list = NULL;\n\t\t}\n\t\todata->edata->overwrite = FR_OVERWRITE_YES;\n\t\t_fr_window_archive_extract_from_edata (odata->window, odata->edata);\n\t}\n\telse {\n\t\tGtkWidget *d;\n\t\td = _gtk_message_dialog_new (GTK_WINDOW (odata->window),\n\t\t\t\t\t     0,\n\t\t\t\t\t     GTK_STOCK_DIALOG_WARNING,\n\t\t\t\t\t     _(\"Extraction not performed\"),\n\t\t\t\t\t     NULL,\n\t\t\t\t\t     GTK_STOCK_OK, GTK_RESPONSE_OK,\n\t\t\t\t\t     NULL);\n\t\tgtk_dialog_set_default_response (GTK_DIALOG (d), GTK_RESPONSE_OK);\n\t\tfr_window_show_error_dialog (odata->window, d, GTK_WINDOW (odata->window), _(\"Extraction not performed\"));\n\t\tfr_window_stop_batch (odata->window);\n\t}\n\tg_free (odata);\n}", "target": 1}
{"code": "static void HuffmanTree_cleanup(HuffmanTree* tree)\n{\n  free(tree->tree2d);\n  free(tree->tree1d);\n  free(tree->lengths);\n}", "target": 0}
{"code": "decrypt(gcry_mpi_t output, gcry_mpi_t a, gcry_mpi_t b, ELG_secret_key *skey )\n{\n  gcry_mpi_t t1 = mpi_alloc_secure( mpi_get_nlimbs( skey->p ) );\n  gcry_mpi_powm( t1, a, skey->x, skey->p );\n  mpi_invm( t1, t1, skey->p );\n  mpi_mulm( output, b, t1, skey->p );\n#if 0\n  if( DBG_CIPHER )\n    {\n      log_mpidump(\"elg decrypted x= \", skey->x);\n      log_mpidump(\"elg decrypted p= \", skey->p);\n      log_mpidump(\"elg decrypted a= \", a);\n      log_mpidump(\"elg decrypted b= \", b);\n      log_mpidump(\"elg decrypted M= \", output);\n    }\n#endif\n  mpi_free(t1);\n}", "target": 1}
{"code": "static int __init setup_slub_debug(char *str)\n{\n\tslub_debug = DEBUG_DEFAULT_FLAGS;\n\tif (*str++ != '=' || !*str)\n\t\tgoto out;\n\tif (*str == ',')\n\t\tgoto check_slabs;\n\tslub_debug = 0;\n\tif (*str == '-')\n\t\tgoto out;\n\tfor (; *str && *str != ','; str++) {\n\t\tswitch (tolower(*str)) {\n\t\tcase 'f':\n\t\t\tslub_debug |= SLAB_CONSISTENCY_CHECKS;\n\t\t\tbreak;\n\t\tcase 'z':\n\t\t\tslub_debug |= SLAB_RED_ZONE;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tslub_debug |= SLAB_POISON;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tslub_debug |= SLAB_STORE_USER;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tslub_debug |= SLAB_TRACE;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tslub_debug |= SLAB_FAILSLAB;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tdisable_higher_order_debug = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"slub_debug option '%c' unknown. skipped\\n\",\n\t\t\t       *str);\n\t\t}\n\t}\ncheck_slabs:\n\tif (*str == ',')\n\t\tslub_debug_slabs = str + 1;\nout:\n\tif ((static_branch_unlikely(&init_on_alloc) ||\n\t     static_branch_unlikely(&init_on_free)) &&\n\t    (slub_debug & SLAB_POISON))\n\t\tpr_info(\"mem auto-init: SLAB_POISON will take precedence over init_on_alloc/init_on_free\\n\");\n\treturn 1;\n}", "target": 0}
{"code": "  String_Obj Parser::parse_ie_property()\n  {\n    lex< ie_property >();\n    Token str(lexed);\n    const char* i = str.begin;\n    const char* p = find_first_in_interval< exactly<hash_lbrace>, block_comment >(str.begin, str.end);\n    if (!p) {\n      return SASS_MEMORY_NEW(String_Quoted, pstate, std::string(str.begin, str.end));\n    }\n    String_Schema_Ptr schema = SASS_MEMORY_NEW(String_Schema, pstate);\n    while (i < str.end) {\n      p = find_first_in_interval< exactly<hash_lbrace>, block_comment >(i, str.end);\n      if (p) {\n        if (i < p) {\n          schema->append(SASS_MEMORY_NEW(String_Constant, pstate, std::string(i, p))); \n        }\n        if (peek < sequence < optional_spaces, exactly<rbrace> > >(p+2)) { position = p+2;\n          css_error(\"Invalid CSS\", \" after \", \": expected expression (e.g. 1px, bold), was \");\n        }\n        const char* j = skip_over_scopes< exactly<hash_lbrace>, exactly<rbrace> >(p+2, str.end); \n        if (j) {\n          Expression_Obj interp_node = Parser::from_token(Token(p+2, j), ctx, traces, pstate, source).parse_list();\n          interp_node->is_interpolant(true);\n          schema->append(interp_node);\n          i = j;\n        }\n        else {\n          error(\"unterminated interpolant inside IE function \" + str.to_string());\n        }\n      }\n      else { \n        if (i < str.end) {\n          schema->append(SASS_MEMORY_NEW(String_Constant, pstate, std::string(i, str.end)));\n        }\n        break;\n      }\n    }\n    return schema;\n  }", "target": 0}
{"code": "static BOOL gdi_Bitmap_Decompress(rdpContext* context, rdpBitmap* bitmap,\n                                  const BYTE* pSrcData, UINT32 DstWidth, UINT32 DstHeight,\n                                  UINT32 bpp, UINT32 length, BOOL compressed,\n                                  UINT32 codecId)\n {\n \tUINT32 SrcSize = length;\n \trdpGdi* gdi = context->gdi;\n \tbitmap->compressed = FALSE;\n \tbitmap->format = gdi->dstFormat;\n\tbitmap->length = DstWidth * DstHeight * GetBytesPerPixel(bitmap->format);\n \tbitmap->data = (BYTE*) _aligned_malloc(bitmap->length, 16);\n \tif (!bitmap->data)\n\t\treturn FALSE;\n\tif (compressed)\n\t{\n\t\tif (bpp < 32)\n\t\t{\n\t\t\tif (!interleaved_decompress(context->codecs->interleaved,\n\t\t\t                            pSrcData, SrcSize,\n\t\t\t                            DstWidth, DstHeight,\n\t\t\t                            bpp,\n\t\t\t                            bitmap->data, bitmap->format,\n\t\t\t                            0, 0, 0, DstWidth, DstHeight,\n\t\t\t                            &gdi->palette))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!planar_decompress(context->codecs->planar, pSrcData, SrcSize,\n\t\t\t                       DstWidth, DstHeight,\n\t\t\t                       bitmap->data, bitmap->format, 0, 0, 0,\n\t\t\t                       DstWidth, DstHeight, TRUE))\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tconst UINT32 SrcFormat = gdi_get_pixel_format(bpp);\n\t\tconst size_t sbpp = GetBytesPerPixel(SrcFormat);\n\t\tconst size_t dbpp = GetBytesPerPixel(bitmap->format);\n\t\tif ((sbpp == 0) || (dbpp == 0))\n\t\t\treturn FALSE;\n\t\telse\n\t\t{\n\t\t\tconst size_t dstSize = SrcSize * dbpp / sbpp;\n\t\t\tif (dstSize  < bitmap->length)\n\t\t\t\treturn FALSE;\n\t\t}\n\t\tif (!freerdp_image_copy(bitmap->data, bitmap->format, 0, 0, 0,\n\t\t                        DstWidth, DstHeight, pSrcData, SrcFormat,\n\t\t                        0, 0, 0, &gdi->palette, FREERDP_FLIP_VERTICAL))\n\t\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "void CoreUserInputHandler::handleSay(const BufferInfo &bufferInfo, const QString &msg)\n{\n    if (bufferInfo.bufferName().isEmpty() || !bufferInfo.acceptsRegularMessages())\n        return;  \n    QByteArray encMsg = channelEncode(bufferInfo.bufferName(), msg);\n#ifdef HAVE_QCA2\n    putPrivmsg(serverEncode(bufferInfo.bufferName()), encMsg, network()->cipher(bufferInfo.bufferName()));\n#else\n    putPrivmsg(serverEncode(bufferInfo.bufferName()), encMsg);\n#endif\n    emit displayMsg(Message::Plain, bufferInfo.type(), bufferInfo.bufferName(), msg, network()->myNick(), Message::Self);\n}", "target": 1}
{"code": "static int _nfs4_do_open_reclaim(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs_delegation *delegation;\n\tstruct nfs4_opendata *opendata;\n\tint delegation_type = 0;\n\tint status;\n\topendata = nfs4_open_recoverdata_alloc(ctx, state);\n\tif (IS_ERR(opendata))\n\t\treturn PTR_ERR(opendata);\n\topendata->o_arg.claim = NFS4_OPEN_CLAIM_PREVIOUS;\n\topendata->o_arg.fh = NFS_FH(state->inode);\n\trcu_read_lock();\n\tdelegation = rcu_dereference(NFS_I(state->inode)->delegation);\n\tif (delegation != NULL && test_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags) != 0)\n\t\tdelegation_type = delegation->type;\n\trcu_read_unlock();\n\topendata->o_arg.u.delegation_type = delegation_type;\n\tstatus = nfs4_open_recover(opendata, state);\n\tnfs4_opendata_put(opendata);\n\treturn status;\n}", "target": 1}
{"code": "_gcry_ecc_eddsa_compute_h_d (unsigned char **r_digest,\n                             gcry_mpi_t d, mpi_ec_t ec)\n{\n  gpg_err_code_t rc;\n  unsigned char *rawmpi = NULL;\n  unsigned int rawmpilen;\n  unsigned char *digest;\n  gcry_buffer_t hvec[2];\n  int hashalgo, b;\n  *r_digest = NULL;\n  hashalgo = GCRY_MD_SHA512;\n  if (hashalgo != GCRY_MD_SHA512)\n    return GPG_ERR_DIGEST_ALGO;\n  b = (ec->nbits+7)/8;\n  if (b != 256/8)\n    return GPG_ERR_INTERNAL; \n  digest = xtrycalloc_secure (2, b);\n  if (!digest)\n    return gpg_err_code_from_syserror ();\n  memset (hvec, 0, sizeof hvec);\n  rawmpi = _gcry_mpi_get_buffer (d, 0, &rawmpilen, NULL);\n  if (!rawmpi)\n    {\n      xfree (digest);\n      return gpg_err_code_from_syserror ();\n    }\n  hvec[0].data = digest;\n  hvec[0].off = 0;\n  hvec[0].len = b > rawmpilen? b - rawmpilen : 0;\n  hvec[1].data = rawmpi;\n  hvec[1].off = 0;\n  hvec[1].len = rawmpilen;\n  rc = _gcry_md_hash_buffers (hashalgo, 0, digest, hvec, 2);\n  xfree (rawmpi);\n  if (rc)\n    {\n      xfree (digest);\n      return rc;\n    }\n  reverse_buffer (digest, 32);  \n  digest[0]   = (digest[0] & 0x7f) | 0x40;\n  digest[31] &= 0xf8;\n  *r_digest = digest;\n  return 0;\n}", "target": 0}
{"code": "void ipv4_pktinfo_prepare(const struct sock *sk, struct sk_buff *skb)\n{\n\tstruct in_pktinfo *pktinfo = PKTINFO_SKB_CB(skb);\n\tbool prepare = (inet_sk(sk)->cmsg_flags & IP_CMSG_PKTINFO) ||\n\t\t       ipv6_sk_rxinfo(sk);\n\tif (prepare && skb_rtable(skb)) {\n\t\tif (pktinfo->ipi_ifindex == LOOPBACK_IFINDEX)\n\t\t\tpktinfo->ipi_ifindex = inet_iif(skb);\n\t\tpktinfo->ipi_spec_dst.s_addr = fib_compute_spec_dst(skb);\n\t} else {\n\t\tpktinfo->ipi_ifindex = 0;\n\t\tpktinfo->ipi_spec_dst.s_addr = 0;\n\t}\n\tskb_dst_drop(skb);\n}", "target": 1}
{"code": "static void validate_my_share_entries(struct smbd_server_connection *sconn,\n\t\t\t\t      int num,\n\t\t\t\t      struct share_mode_entry *share_entry)\n{\n\tstruct server_id self = messaging_server_id(sconn->msg_ctx);\n\tfiles_struct *fsp;\n\tif (!serverid_equal(&self, &share_entry->pid)) {\n\t\treturn;\n\t}\n\tif (!is_valid_share_mode_entry(share_entry)) {\n\t\treturn;\n\t}\n\tfsp = file_find_dif(sconn, share_entry->id,\n\t\t\t    share_entry->share_file_id);\n\tif (!fsp) {\n\t\tDEBUG(0,(\"validate_my_share_entries: PANIC : %s\\n\",\n\t\t\t share_mode_str(talloc_tos(), num, share_entry) ));\n\t\tsmb_panic(\"validate_my_share_entries: Cannot match a \"\n\t\t\t  \"share entry with an open file\\n\");\n\t}\n\tif (((uint16)fsp->oplock_type) != share_entry->op_type) {\n\t\tgoto panic;\n\t}\n\treturn;\n panic:\n\t{\n\t\tchar *str;\n\t\tDEBUG(0,(\"validate_my_share_entries: PANIC : %s\\n\",\n\t\t\t share_mode_str(talloc_tos(), num, share_entry) ));\n\t\tstr = talloc_asprintf(talloc_tos(),\n\t\t\t\"validate_my_share_entries: \"\n\t\t\t\"file %s, oplock_type = 0x%x, op_type = 0x%x\\n\",\n\t\t\t fsp->fsp_name->base_name,\n\t\t\t (unsigned int)fsp->oplock_type,\n\t\t\t (unsigned int)share_entry->op_type );\n\t\tsmb_panic(str);\n\t}\n}", "target": 0}
{"code": "static void kvmclock_reset(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->arch.time_page) {\n\t\tkvm_release_page_dirty(vcpu->arch.time_page);\n\t\tvcpu->arch.time_page = NULL;\n\t}\n}", "target": 1}
{"code": "static void cirrus_invalidate_region(CirrusVGAState * s, int off_begin,\n\t\t\t\t     int off_pitch, int bytesperline,\n\t\t\t\t     int lines)\n{\n    int y;\n    int off_cur;\n    int off_cur_end;\n    for (y = 0; y < lines; y++) {\n\toff_cur = off_begin;\n\toff_cur_end = off_cur + bytesperline;\n\toff_cur &= TARGET_PAGE_MASK;\n\twhile (off_cur < off_cur_end) {\n\t    cpu_physical_memory_set_dirty(s->vram_offset + off_cur);\n\t    off_cur += TARGET_PAGE_SIZE;\n\t}\n\toff_begin += off_pitch;\n    }\n}", "target": 1}
{"code": "String UTF16BEDecoder::to_utf8(const StringView& input)\n{\n    StringBuilder builder(input.length() / 2);\n    for (size_t i = 0; i < input.length(); i += 2) {\n        u16 code_point = (input[i] << 8) | input[i + 1];\n        builder.append_code_point(code_point);\n    }\n    return builder.to_string();\n}", "target": 1}
{"code": "static struct fsnotify_group *inotify_new_group(struct user_struct *user, unsigned int max_events)\n{\n\tstruct fsnotify_group *group;\n\tgroup = fsnotify_alloc_group(&inotify_fsnotify_ops);\n\tif (IS_ERR(group))\n\t\treturn group;\n\tgroup->max_events = max_events;\n\tspin_lock_init(&group->inotify_data.idr_lock);\n\tidr_init(&group->inotify_data.idr);\n\tgroup->inotify_data.last_wd = 0;\n\tgroup->inotify_data.user = user;\n\tgroup->inotify_data.fa = NULL;\n\treturn group;\n}", "target": 1}
{"code": "static int nfs4_xdr_dec_rename(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t       struct nfs_renameres *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_savefh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_rename(xdr, &res->old_cinfo, &res->new_cinfo);\nout:\n\treturn status;\n}", "target": 0}
{"code": "static size_t php_bz2iop_read(php_stream *stream, char *buf, size_t count TSRMLS_DC)\n{\n\tstruct php_bz2_stream_data_t *self = (struct php_bz2_stream_data_t *) stream->abstract;\n\tsize_t ret;\n\tret = BZ2_bzread(self->bz_file, buf, count);\n\tif (ret == 0) {\n\t\tstream->eof = 1;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "sigterm_handler(int sig)\t\t\n{\n  (void)sig;\n  fprintf(stderr,\n\t  \"DEBUG: beh: Job canceled.\\n\");\n  if (job_canceled)\n    _exit(CUPS_BACKEND_OK);\n  else\n    job_canceled = 1;\n}", "target": 1}
{"code": "TRIO_PUBLIC_STRING size_t trio_length TRIO_ARGS1((string), TRIO_CONST char* string)\n{\n\treturn strlen(string);\n}", "target": 1}
{"code": "Pl_ASCIIHexDecoder::flush()\n{\n    if (this->pos == 0)\n    {\n\tQTC::TC(\"libtests\", \"Pl_ASCIIHexDecoder no-op flush\");\n\treturn;\n    }\n    int b[2];\n    for (int i = 0; i < 2; ++i)\n    {\n\tif (this->inbuf[i] >= 'A')\n\t{\n\t    b[i] = this->inbuf[i] - 'A' + 10;\n\t}\n\telse\n\t{\n\t    b[i] = this->inbuf[i] - '0';\n\t}\n    }\n    unsigned char ch = static_cast<unsigned char>((b[0] << 4) + b[1]);\n    QTC::TC(\"libtests\", \"Pl_ASCIIHexDecoder partial flush\",\n\t    (this->pos == 2) ? 0 : 1);\n    getNext()->write(&ch, 1);\n    this->pos = 0;\n    this->inbuf[0] = '0';\n    this->inbuf[1] = '0';\n    this->inbuf[2] = '\\0';\n}", "target": 1}
{"code": "void TestJlCompress::extractDir_data()\n{\n    QTest::addColumn<QString>(\"zipName\");\n    QTest::addColumn<QStringList>(\"fileNames\");\n    QTest::newRow(\"simple\") << \"jlextdir.zip\" << (\n            QStringList() << \"test0.txt\" << \"testdir1/test1.txt\"\n            << \"testdir2/test2.txt\" << \"testdir2/subdir/test2sub.txt\");\n    QTest::newRow(\"separate dir\") << \"sepdir.zip\" << (\n            QStringList() << \"laj/\" << \"laj/lajfile.txt\");\n}", "target": 1}
{"code": "iasecc_init_amos_or_sagem(struct sc_card *card)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tunsigned int flags;\n\tint rv = 0;\n\tLOG_FUNC_CALLED(ctx);\n\tflags = IASECC_CARD_DEFAULT_FLAGS;\n\t_sc_card_add_rsa_alg(card, 1024, flags, 0x10001);\n\t_sc_card_add_rsa_alg(card, 2048, flags, 0x10001);\n\tcard->caps = IASECC_CARD_DEFAULT_CAPS;\n\tif (card->type == SC_CARD_TYPE_IASECC_MI)   {\n\t\trv = iasecc_mi_match(card);\n\t\tif (rv)\n\t\t\tcard->type = SC_CARD_TYPE_IASECC_MI2;\n\t\telse\n\t\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\t}\n\trv = iasecc_parse_ef_atr(card);\n\tif (rv == SC_ERROR_FILE_NOT_FOUND)   {\n\t\trv = iasecc_select_mf(card, NULL);\n\t\tLOG_TEST_RET(ctx, rv, \"MF selection error\");\n\t\trv = iasecc_parse_ef_atr(card);\n\t}\n\tLOG_TEST_RET(ctx, rv, \"IASECC: ATR parse failed\");\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}", "target": 0}
{"code": "void RGWDeleteLC_ObjStore_S3::send_response()\n{\n  if (op_ret == 0)\n      op_ret = STATUS_NO_CONTENT;\n  if (op_ret) {   \n    set_req_state_err(s, op_ret);\n  }\n  dump_errno(s);\n  end_header(s, this, \"application/xml\");\n  dump_start(s);\n}", "target": 0}
{"code": "static int truncate_inline_extent(struct inode *inode,\n\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t  struct btrfs_key *found_key,\n\t\t\t\t  const u64 item_end,\n\t\t\t\t  const u64 new_size)\n{\n\tstruct extent_buffer *leaf = path->nodes[0];\n\tint slot = path->slots[0];\n\tstruct btrfs_file_extent_item *fi;\n\tu32 size = (u32)(new_size - found_key->offset);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tfi = btrfs_item_ptr(leaf, slot, struct btrfs_file_extent_item);\n\tif (btrfs_file_extent_compression(leaf, fi) != BTRFS_COMPRESS_NONE) {\n\t\tloff_t offset = new_size;\n\t\tloff_t page_end = ALIGN(offset, PAGE_CACHE_SIZE);\n\t\tbtrfs_release_path(path);\n\t\treturn btrfs_truncate_page(inode, offset, page_end - offset, 0);\n\t}\n\tbtrfs_set_file_extent_ram_bytes(leaf, fi, size);\n\tsize = btrfs_file_extent_calc_inline_size(size);\n\tbtrfs_truncate_item(root, path, size, 1);\n\tif (test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\tinode_sub_bytes(inode, item_end + 1 - new_size);\n\treturn 0;\n}", "target": 0}
{"code": "static inline void DetectRunPrefilterPkt(\n    ThreadVars *tv,\n    DetectEngineCtx *de_ctx,\n    DetectEngineThreadCtx *det_ctx,\n    Packet *p,\n    DetectRunScratchpad *scratch\n)\n{\n    DetectPrefilterSetNonPrefilterList(p, det_ctx, scratch);\n    PacketCreateMask(p, &scratch->pkt_mask, scratch->alproto, scratch->app_decoder_events);\n    PACKET_PROFILING_DETECT_START(p, PROF_DETECT_NONMPMLIST);\n    det_ctx->non_pf_id_cnt = 0;\n    if (likely(det_ctx->non_pf_store_cnt > 0)) {\n        DetectPrefilterBuildNonPrefilterList(det_ctx, scratch->pkt_mask, scratch->alproto);\n    }\n    PACKET_PROFILING_DETECT_END(p, PROF_DETECT_NONMPMLIST);\n    Prefilter(det_ctx, scratch->sgh, p, scratch->flow_flags);\n    if (det_ctx->non_pf_store_cnt || det_ctx->pmq.rule_id_array_cnt) {\n        PACKET_PROFILING_DETECT_START(p, PROF_DETECT_PF_SORT2);\n        DetectPrefilterMergeSort(de_ctx, det_ctx);\n        PACKET_PROFILING_DETECT_END(p, PROF_DETECT_PF_SORT2);\n    }\n#ifdef PROFILING\n    if (tv) {\n        StatsAddUI64(tv, det_ctx->counter_mpm_list,\n                             (uint64_t)det_ctx->pmq.rule_id_array_cnt);\n        StatsAddUI64(tv, det_ctx->counter_nonmpm_list,\n                             (uint64_t)det_ctx->non_pf_store_cnt);\n        StatsAddUI64(tv, det_ctx->counter_fnonmpm_list,\n                             (uint64_t)det_ctx->non_pf_id_cnt);\n    }\n#endif\n}", "target": 0}
{"code": "static int nla_validate_array(const struct nlattr *head, int len, int maxtype,\n\t\t\t      const struct nla_policy *policy,\n\t\t\t      struct netlink_ext_ack *extack,\n\t\t\t      unsigned int validate)\n{\n\tconst struct nlattr *entry;\n\tint rem;\n\tnla_for_each_attr(entry, head, len, rem) {\n\t\tint ret;\n\t\tif (nla_len(entry) == 0)\n\t\t\tcontinue;\n\t\tif (nla_len(entry) < NLA_HDRLEN) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, entry,\n\t\t\t\t\t    \"Array element too short\");\n\t\t\treturn -ERANGE;\n\t\t}\n\t\tret = __nla_validate(nla_data(entry), nla_len(entry),\n\t\t\t\t     maxtype, policy, validate, extack);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "int tipc_nl_node_dump_monitor_peer(struct sk_buff *skb,\n\t\t\t\t   struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tu32 prev_node = cb->args[1];\n\tu32 bearer_id = cb->args[2];\n\tint done = cb->args[0];\n\tstruct tipc_nl_msg msg;\n\tint err;\n\tif (!prev_node) {\n\t\tstruct nlattr **attrs = genl_dumpit_info(cb)->attrs;\n\t\tstruct nlattr *mon[TIPC_NLA_MON_MAX + 1];\n\t\tif (!attrs[TIPC_NLA_MON])\n\t\t\treturn -EINVAL;\n\t\terr = nla_parse_nested_deprecated(mon, TIPC_NLA_MON_MAX,\n\t\t\t\t\t\t  attrs[TIPC_NLA_MON],\n\t\t\t\t\t\t  tipc_nl_monitor_policy,\n\t\t\t\t\t\t  NULL);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (!mon[TIPC_NLA_MON_REF])\n\t\t\treturn -EINVAL;\n\t\tbearer_id = nla_get_u32(mon[TIPC_NLA_MON_REF]);\n\t\tif (bearer_id >= MAX_BEARERS)\n\t\t\treturn -EINVAL;\n\t}\n\tif (done)\n\t\treturn 0;\n\tmsg.skb = skb;\n\tmsg.portid = NETLINK_CB(cb->skb).portid;\n\tmsg.seq = cb->nlh->nlmsg_seq;\n\trtnl_lock();\n\terr = tipc_nl_add_monitor_peer(net, &msg, bearer_id, &prev_node);\n\tif (!err)\n\t\tdone = 1;\n\trtnl_unlock();\n\tcb->args[0] = done;\n\tcb->args[1] = prev_node;\n\tcb->args[2] = bearer_id;\n\treturn skb->len;\n}", "target": 0}
{"code": "long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\tkey_ref = lookup_user_key(keyid, 0, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n\tkey = key_ref_to_ptr(key_ref);\n\tret = key_permission(key_ref, KEY_READ);\n\tif (ret == 0)\n\t\tgoto can_read_key;\n\tif (ret != -EACCES)\n\t\tgoto error;\n\tif (!is_key_possessed(key_ref)) {\n\t\tret = -EACCES;\n\t\tgoto error2;\n\t}\ncan_read_key:\n\tret = key_validate(key);\n\tif (ret == 0) {\n\t\tret = -EOPNOTSUPP;\n\t\tif (key->type->read) {\n\t\t\tdown_read(&key->sem);\n\t\t\tret = key->type->read(key, buffer, buflen);\n\t\t\tup_read(&key->sem);\n\t\t}\n\t}\nerror2:\n\tkey_put(key);\nerror:\n\treturn ret;\n}", "target": 0}
{"code": "reallocWrapper (void *address, size_t size)\n{\n  if (!(address = realloc (address, size)) && size)\n    outOfMemory ();\n  return address;\n}", "target": 0}
{"code": "int vfs_open(const struct path *path, struct file *file,\n\t     const struct cred *cred)\n{\n\tstruct dentry *dentry = path->dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tfile->f_path = *path;\n\tif (dentry->d_flags & DCACHE_OP_SELECT_INODE) {\n\t\tinode = dentry->d_op->d_select_inode(dentry, file->f_flags);\n\t\tif (IS_ERR(inode))\n\t\t\treturn PTR_ERR(inode);\n\t}\n\treturn do_dentry_open(file, inode, NULL, cred);\n}", "target": 1}
{"code": "uint8_t WasmBinaryBuilder::getLaneIndex(size_t lanes) {\n  BYN_TRACE(\"<==\\n\");\n  auto ret = getInt8();\n  if (ret >= lanes) {\n    throwError(\"Illegal lane index\");\n  }\n  BYN_TRACE(\"getLaneIndex(\" << lanes << \"): \" << ret << \" ==>\" << std::endl);\n  return ret;\n}", "target": 0}
{"code": "unsigned int _gnutls_x509_verify_certificate(\n    const gnutls_x509_crt_t *certificate_list, int clist_size,\n    const gnutls_x509_crt_t *trusted_cas, int tcas_size,\n    const gnutls_x509_crl_t *CRLs, int crls_size,\n    unsigned int flags)\n{\n    int i = 0, ret;\n    unsigned int status = 0, output;\n    ret =\n\t_gnutls_verify_certificate2(certificate_list[clist_size-1], \n\t    trusted_cas, tcas_size, flags, &output);\n    if (ret == 0) {\n\tgnutls_assert();\n\tstatus |= output;\n\tstatus |= GNUTLS_CERT_INVALID;\n\treturn status;\n    }\n#ifdef ENABLE_PKI\n    for (i = 0; i < clist_size; i++) {\n\tret = gnutls_x509_crt_check_revocation(certificate_list[i],\n\t\t\t\t\t       CRLs, crls_size);\n\tif (ret == 1) {\t\t\n\t    status |= GNUTLS_CERT_REVOKED;\n\t    status |= GNUTLS_CERT_INVALID;\n\t    return status;\n\t}\n    }\n#endif\n    for (i = clist_size-1; i > 0; i--) {\n\tif (i - 1 < 0)\n\t    break;\n        flags ^= GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT;\n\tif ((ret =\n\t     _gnutls_verify_certificate2(certificate_list[i-1],\n                  &certificate_list[i], 1, flags, NULL)) == 0) {\n\t    status |= GNUTLS_CERT_INVALID;\n\t    return status;\n\t}\n    }\n    return 0;\n}", "target": 0}
{"code": "static __be16 sctp_get_asconf_response(struct sctp_chunk *asconf_ack,\n\t\t\t\t      sctp_addip_param_t *asconf_param,\n\t\t\t\t      int no_err)\n{\n\tsctp_addip_param_t\t*asconf_ack_param;\n\tsctp_errhdr_t\t\t*err_param;\n\tint\t\t\tlength;\n\tint\t\t\tasconf_ack_len;\n\t__be16\t\t\terr_code;\n\tif (no_err)\n\t\terr_code = SCTP_ERROR_NO_ERROR;\n\telse\n\t\terr_code = SCTP_ERROR_REQ_REFUSED;\n\tasconf_ack_len = ntohs(asconf_ack->chunk_hdr->length) -\n\t\t\t     sizeof(sctp_chunkhdr_t);\n\tlength = sizeof(sctp_addiphdr_t);\n\tasconf_ack_param = (sctp_addip_param_t *)(asconf_ack->skb->data +\n\t\t\t\t\t\t  length);\n\tasconf_ack_len -= length;\n\twhile (asconf_ack_len > 0) {\n\t\tif (asconf_ack_param->crr_id == asconf_param->crr_id) {\n\t\t\tswitch (asconf_ack_param->param_hdr.type) {\n\t\t\tcase SCTP_PARAM_SUCCESS_REPORT:\n\t\t\t\treturn SCTP_ERROR_NO_ERROR;\n\t\t\tcase SCTP_PARAM_ERR_CAUSE:\n\t\t\t\tlength = sizeof(sctp_addip_param_t);\n\t\t\t\terr_param = (void *)asconf_ack_param + length;\n\t\t\t\tasconf_ack_len -= length;\n\t\t\t\tif (asconf_ack_len > 0)\n\t\t\t\t\treturn err_param->cause;\n\t\t\t\telse\n\t\t\t\t\treturn SCTP_ERROR_INV_PARAM;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn SCTP_ERROR_INV_PARAM;\n\t\t\t}\n\t\t}\n\t\tlength = ntohs(asconf_ack_param->param_hdr.length);\n\t\tasconf_ack_param = (void *)asconf_ack_param + length;\n\t\tasconf_ack_len -= length;\n\t}\n\treturn err_code;\n}", "target": 0}
{"code": "unsigned short bebytes2ushort(const u8 *buf)\n{\n\tif (buf == NULL)\n\t\treturn 0U;\n\treturn (unsigned short) (buf[0] << 8 | buf[1]);\n}", "target": 0}
{"code": "static int parse_public_key(const u8 *key, size_t keysize, RSA *rsa)\n{\n\tconst u8 *p = key;\n\tBIGNUM *n, *e;\n\tint base;\n\tbase = (keysize - 7) / 5;\n\tif (base != 32 && base != 48 && base != 64 && base != 128) {\n\t\tfprintf(stderr, \"Invalid public key.\\n\");\n\t\treturn -1;\n\t}\n\tp += 3;\n\tn = BN_new();\n\tif (n == NULL)\n\t\treturn -1;\n\tcf2bn(p, 2 * base, n);\n\tp += 2 * base;\n\tp += base;\n\tp += 2 * base;\n\te = BN_new();\n\tif (e == NULL)\n\t\treturn -1;\n\tcf2bn(p, 4, e);\n\tif (RSA_set0_key(rsa, n, e, NULL) != 1)\n\t    return -1;\n\treturn 0;\n}", "target": 0}
{"code": "void RootWindow::OnCompositingStarted(ui::Compositor*) {\n}", "target": 0}
{"code": "int mbedtls_x509_crt_parse_der( mbedtls_x509_crt *chain, const unsigned char *buf,\n                        size_t buflen )\n{\n    int ret;\n    mbedtls_x509_crt *crt = chain, *prev = NULL;\n    if( crt == NULL || buf == NULL )\n        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );\n    while( crt->version != 0 && crt->next != NULL )\n    {\n        prev = crt;\n        crt = crt->next;\n    }\n    if( crt->version != 0 && crt->next == NULL )\n    {\n        crt->next = mbedtls_calloc( 1, sizeof( mbedtls_x509_crt ) );\n        if( crt->next == NULL )\n            return( MBEDTLS_ERR_X509_ALLOC_FAILED );\n        prev = crt;\n        mbedtls_x509_crt_init( crt->next );\n        crt = crt->next;\n    }\n    if( ( ret = x509_crt_parse_der_core( crt, buf, buflen ) ) != 0 )\n    {\n        if( prev )\n            prev->next = NULL;\n        if( crt != chain )\n            mbedtls_free( crt );\n        return( ret );\n    }\n    return( 0 );\n}", "target": 0}
{"code": "GIT_INLINE(bool) verify_dotgit_ntfs(git_repository *repo, const char *path, size_t len)\n{\n\tgit_buf *reserved = git_repository__reserved_names_win32;\n\tsize_t reserved_len = git_repository__reserved_names_win32_len;\n\tsize_t start = 0, i;\n\tif (repo)\n\t\tgit_repository__reserved_names(&reserved, &reserved_len, repo, true);\n\tfor (i = 0; i < reserved_len; i++) {\n\t\tgit_buf *r = &reserved[i];\n\t\tif (len >= r->size &&\n\t\t\tstrncasecmp(path, r->ptr, r->size) == 0) {\n\t\t\tstart = r->size;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!start)\n\t\treturn true;\n\tif (path[start] == '\\\\')\n\t\treturn false;\n\tfor (i = start; i < len; i++) {\n\t\tif (path[i] != ' ' && path[i] != '.')\n\t\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "static void show_object(struct object *object, struct strbuf *path,\n\t\t\tconst char *last, void *data)\n{\n\tstruct bitmap *base = data;\n\tbitmap_set(base, find_object_pos(object->oid.hash));\n\tmark_as_seen(object);\n}", "target": 1}
{"code": "static inline void ok_png_premultiply(uint8_t *dst) {\n    const uint8_t a = dst[3];\n    if (a == 0) {\n        dst[0] = 0;\n        dst[1] = 0;\n        dst[2] = 0;\n    } else if (a < 255) {\n        dst[0] = (a * dst[0] + 127) / 255;\n        dst[1] = (a * dst[1] + 127) / 255;\n        dst[2] = (a * dst[2] + 127) / 255;\n    }\n}", "target": 0}
{"code": "bool Matrix::invertTo(Matrix *other) const\n{\n    const double det_denominator = determinant();\n    if (unlikely(det_denominator == 0)) {\n        *other = { 1, 0, 0, 1, 0, 0 };\n        return false;\n    }\n    const double det = 1 / det_denominator;\n    other->m[0] = m[3] * det;\n    other->m[1] = -m[1] * det;\n    other->m[2] = -m[2] * det;\n    other->m[3] = m[0] * det;\n    other->m[4] = (m[2] * m[5] - m[3] * m[4]) * det;\n    other->m[5] = (m[1] * m[4] - m[0] * m[5]) * det;\n    return true;\n}", "target": 0}
{"code": "int lxc_safe_long(const char *numstr, long int *converted)\n{\n\tchar *err = NULL;\n\tsigned long int sli;\n\terrno = 0;\n\tsli = strtol(numstr, &err, 0);\n\tif (errno == ERANGE && (sli == LONG_MAX || sli == LONG_MIN))\n\t\treturn -ERANGE;\n\tif (errno != 0 && sli == 0)\n\t\treturn -EINVAL;\n\tif (err == numstr || *err != '\\0')\n\t\treturn -EINVAL;\n\t*converted = sli;\n\treturn 0;\n}", "target": 0}
{"code": "int nfs4_open_delegation_recall(struct nfs_open_context *ctx, struct nfs4_state *state, const nfs4_stateid *stateid)\n{\n\tstruct nfs4_exception exception = { };\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tint err;\n\tdo {\n\t\terr = _nfs4_open_delegation_recall(ctx, state, stateid);\n\t\tswitch (err) {\n\t\t\tcase 0:\n\t\t\tcase -ENOENT:\n\t\t\tcase -ESTALE:\n\t\t\t\tgoto out;\n\t\t\tcase -NFS4ERR_BADSESSION:\n\t\t\tcase -NFS4ERR_BADSLOT:\n\t\t\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\t\t\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\t\tcase -NFS4ERR_DEADSESSION:\n\t\t\t\tnfs4_schedule_session_recovery(server->nfs_client->cl_session, err);\n\t\t\t\tgoto out;\n\t\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\tcase -NFS4ERR_STALE_STATEID:\n\t\t\tcase -NFS4ERR_EXPIRED:\n\t\t\t\tnfs4_schedule_lease_recovery(server->nfs_client);\n\t\t\t\tgoto out;\n\t\t\tcase -ERESTARTSYS:\n\t\t\tcase -NFS4ERR_DELEG_REVOKED:\n\t\t\tcase -NFS4ERR_ADMIN_REVOKED:\n\t\t\tcase -NFS4ERR_BAD_STATEID:\n\t\t\t\tnfs_inode_find_state_and_recover(state->inode,\n\t\t\t\t\t\tstateid);\n\t\t\t\tnfs4_schedule_stateid_recovery(server, state);\n\t\t\tcase -EKEYEXPIRED:\n\t\t\tcase -ENOMEM:\n\t\t\t\terr = 0;\n\t\t\t\tgoto out;\n\t\t}\n\t\terr = nfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\nout:\n\treturn err;\n}", "target": 0}
{"code": "static int pppol2tp_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t       char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2tp_session *session;\n\tstruct l2tp_tunnel *tunnel;\n\tint val, len;\n\tint err;\n\tstruct pppol2tp_session *ps;\n\tif (level != SOL_PPPOL2TP)\n\t\treturn udp_prot.getsockopt(sk, level, optname, optval, optlen);\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tlen = min_t(unsigned int, len, sizeof(int));\n\tif (len < 0)\n\t\treturn -EINVAL;\n\terr = -ENOTCONN;\n\tif (sk->sk_user_data == NULL)\n\t\tgoto end;\n\terr = -EBADF;\n\tsession = pppol2tp_sock_to_session(sk);\n\tif (session == NULL)\n\t\tgoto end;\n\tps = l2tp_session_priv(session);\n\tif ((session->session_id == 0) &&\n\t    (session->peer_session_id == 0)) {\n\t\terr = -EBADF;\n\t\ttunnel = l2tp_sock_to_tunnel(ps->tunnel_sock);\n\t\tif (tunnel == NULL)\n\t\t\tgoto end_put_sess;\n\t\terr = pppol2tp_tunnel_getsockopt(sk, tunnel, optname, &val);\n\t\tsock_put(ps->tunnel_sock);\n\t} else\n\t\terr = pppol2tp_session_getsockopt(sk, session, optname, &val);\n\terr = -EFAULT;\n\tif (put_user(len, optlen))\n\t\tgoto end_put_sess;\n\tif (copy_to_user((void __user *) optval, &val, len))\n\t\tgoto end_put_sess;\n\terr = 0;\nend_put_sess:\n\tsock_put(sk);\nend:\n\treturn err;\n}", "target": 1}
{"code": "static int trusted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct trusted_key_payload *p = key->payload.data;\n\tstruct trusted_key_payload *new_p;\n\tstruct trusted_key_options *new_o;\n\tsize_t datalen = prep->datalen;\n\tchar *datablob;\n\tint ret = 0;\n\tif (!p->migratable)\n\t\treturn -EPERM;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\tdatablob = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!datablob)\n\t\treturn -ENOMEM;\n\tnew_o = trusted_options_alloc();\n\tif (!new_o) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tnew_p = trusted_payload_alloc(key);\n\tif (!new_p) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmemcpy(datablob, prep->data, datalen);\n\tdatablob[datalen] = '\\0';\n\tret = datablob_parse(datablob, new_p, new_o);\n\tif (ret != Opt_update) {\n\t\tret = -EINVAL;\n\t\tkfree(new_p);\n\t\tgoto out;\n\t}\n\tnew_p->migratable = p->migratable;\n\tnew_p->key_len = p->key_len;\n\tmemcpy(new_p->key, p->key, p->key_len);\n\tdump_payload(p);\n\tdump_payload(new_p);\n\tret = key_seal(new_p, new_o);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: key_seal failed (%d)\\n\", ret);\n\t\tkfree(new_p);\n\t\tgoto out;\n\t}\n\tif (new_o->pcrlock) {\n\t\tret = pcrlock(new_o->pcrlock);\n\t\tif (ret < 0) {\n\t\t\tpr_info(\"trusted_key: pcrlock failed (%d)\\n\", ret);\n\t\t\tkfree(new_p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\trcu_assign_keypointer(key, new_p);\n\tcall_rcu(&p->rcu, trusted_rcu_free);\nout:\n\tkfree(datablob);\n\tkfree(new_o);\n\treturn ret;\n}", "target": 0}
{"code": "service_info *FindServiceControlURLPath(\n\tservice_table *table, const char *controlURLPath)\n{\n\tservice_info *finger = NULL;\n\turi_type parsed_url;\n\turi_type parsed_url_in;\n\tif (table && parse_uri(controlURLPath,\n\t\t\t     strlen(controlURLPath),\n\t\t\t     &parsed_url_in) == HTTP_SUCCESS) {\n\t\tfinger = table->serviceList;\n\t\twhile (finger) {\n\t\t\tif (finger->controlURL) {\n\t\t\t\tif (parse_uri(finger->controlURL,\n\t\t\t\t\t    strlen(finger->controlURL),\n\t\t\t\t\t    &parsed_url) == HTTP_SUCCESS) {\n\t\t\t\t\tif (!token_cmp(&parsed_url.pathquery,\n\t\t\t\t\t\t    &parsed_url_in.pathquery)) {\n\t\t\t\t\t\treturn finger;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinger = finger->next;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "struct pmu *perf_init_event(struct perf_event *event)\n{\n\tstruct pmu *pmu = NULL;\n\tint idx;\n\tint ret;\n\tidx = srcu_read_lock(&pmus_srcu);\n\trcu_read_lock();\n\tpmu = idr_find(&pmu_idr, event->attr.type);\n\trcu_read_unlock();\n\tif (pmu) {\n\t\tevent->pmu = pmu;\n\t\tret = pmu->event_init(event);\n\t\tif (ret)\n\t\t\tpmu = ERR_PTR(ret);\n\t\tgoto unlock;\n\t}\n\tlist_for_each_entry_rcu(pmu, &pmus, entry) {\n\t\tevent->pmu = pmu;\n\t\tret = pmu->event_init(event);\n\t\tif (!ret)\n\t\t\tgoto unlock;\n\t\tif (ret != -ENOENT) {\n\t\t\tpmu = ERR_PTR(ret);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\tpmu = ERR_PTR(-ENOENT);\nunlock:\n\tsrcu_read_unlock(&pmus_srcu, idx);\n\treturn pmu;\n}", "target": 0}
{"code": "int mpol_parse_str(char *str, struct mempolicy **mpol)\n{\n\tstruct mempolicy *new = NULL;\n\tunsigned short mode_flags;\n\tnodemask_t nodes;\n\tchar *nodelist = strchr(str, ':');\n\tchar *flags = strchr(str, '=');\n\tint err = 1, mode;\n\tif (flags)\n\t\t*flags++ = '\\0';\t\n\tif (nodelist) {\n\t\t*nodelist++ = '\\0';\n\t\tif (nodelist_parse(nodelist, nodes))\n\t\t\tgoto out;\n\t\tif (!nodes_subset(nodes, node_states[N_MEMORY]))\n\t\t\tgoto out;\n\t} else\n\t\tnodes_clear(nodes);\n\tmode = match_string(policy_modes, MPOL_MAX, str);\n\tif (mode < 0)\n\t\tgoto out;\n\tswitch (mode) {\n\tcase MPOL_PREFERRED:\n\t\tif (nodelist) {\n\t\t\tchar *rest = nodelist;\n\t\t\twhile (isdigit(*rest))\n\t\t\t\trest++;\n\t\t\tif (*rest)\n\t\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase MPOL_INTERLEAVE:\n\t\tif (!nodelist)\n\t\t\tnodes = node_states[N_MEMORY];\n\t\tbreak;\n\tcase MPOL_LOCAL:\n\t\tif (nodelist)\n\t\t\tgoto out;\n\t\tmode = MPOL_PREFERRED;\n\t\tbreak;\n\tcase MPOL_DEFAULT:\n\t\tif (!nodelist)\n\t\t\terr = 0;\n\t\tgoto out;\n\tcase MPOL_BIND:\n\t\tif (!nodelist)\n\t\t\tgoto out;\n\t}\n\tmode_flags = 0;\n\tif (flags) {\n\t\tif (!strcmp(flags, \"static\"))\n\t\t\tmode_flags |= MPOL_F_STATIC_NODES;\n\t\telse if (!strcmp(flags, \"relative\"))\n\t\t\tmode_flags |= MPOL_F_RELATIVE_NODES;\n\t\telse\n\t\t\tgoto out;\n\t}\n\tnew = mpol_new(mode, mode_flags, &nodes);\n\tif (IS_ERR(new))\n\t\tgoto out;\n\tif (mode != MPOL_PREFERRED)\n\t\tnew->v.nodes = nodes;\n\telse if (nodelist)\n\t\tnew->v.preferred_node = first_node(nodes);\n\telse\n\t\tnew->flags |= MPOL_F_LOCAL;\n\tnew->w.user_nodemask = nodes;\n\terr = 0;\nout:\n\tif (nodelist)\n\t\t*--nodelist = ':';\n\tif (flags)\n\t\t*--flags = '=';\n\tif (!err)\n\t\t*mpol = new;\n\treturn err;\n}", "target": 1}
{"code": "static void labeljumps(JF, js_JumpList *jump, int baddr, int caddr)\n{\n\twhile (jump) {\n\t\tif (jump->type == STM_BREAK)\n\t\t\tlabelto(J, F, jump->inst, baddr);\n\t\tif (jump->type == STM_CONTINUE)\n\t\t\tlabelto(J, F, jump->inst, caddr);\n\t\tjump = jump->next;\n\t}\n}", "target": 1}
{"code": "static int override_release(char __user *release, int len)\n{\n\tint ret = 0;\n\tchar buf[65];\n\tif (current->personality & UNAME26) {\n\t\tchar *rest = UTS_RELEASE;\n\t\tint ndots = 0;\n\t\tunsigned v;\n\t\twhile (*rest) {\n\t\t\tif (*rest == '.' && ++ndots >= 3)\n\t\t\t\tbreak;\n\t\t\tif (!isdigit(*rest) && *rest != '.')\n\t\t\t\tbreak;\n\t\t\trest++;\n\t\t}\n\t\tv = ((LINUX_VERSION_CODE >> 8) & 0xff) + 40;\n\t\tsnprintf(buf, len, \"2.6.%u%s\", v, rest);\n\t\tret = copy_to_user(release, buf, len);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "bit_write_UMC (Bit_Chain *dat, BITCODE_UMC val)\n{\n  int i, j;\n  int negative;\n  unsigned char byte[5];\n  BITCODE_UMC mask;\n  BITCODE_UMC value;\n  value = val;\n  mask = 0x0000007f;\n  for (i = 4, j = 0; i >= 0; i--, j += 7)\n    {\n      byte[i] = (unsigned char)((value & mask) >> j);\n      byte[i] |= 0x80;\n      mask = mask << 7;\n    }\n  for (i = 0; i < 4; i++)\n    if (byte[i] & 0x7f)\n      break;\n  if (byte[i] & 0x40)\n    i--;\n  byte[i] &= 0x7f;\n  for (j = 4; j >= i; j--)\n    bit_write_RC (dat, byte[j]);\n}", "target": 1}
{"code": "Status SpectrogramShapeFn(InferenceContext* c) {\n  ShapeHandle input;\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &input));\n  int32_t window_size;\n  TF_RETURN_IF_ERROR(c->GetAttr(\"window_size\", &window_size));\n  if (window_size <= 1) {\n    return errors::InvalidArgument(\"window size must be > 1, got \",\n                                   window_size);\n  }\n  int32_t stride;\n  TF_RETURN_IF_ERROR(c->GetAttr(\"stride\", &stride));\n  if (stride <= 0) {\n    return errors::InvalidArgument(\"stride must be strictly positive, got \",\n                                   stride);\n  }\n  DimensionHandle input_length = c->Dim(input, 0);\n  DimensionHandle input_channels = c->Dim(input, 1);\n  DimensionHandle output_length;\n  if (!c->ValueKnown(input_length)) {\n    output_length = c->UnknownDim();\n  } else {\n    const int64_t input_length_value = c->Value(input_length);\n    const int64_t length_minus_window = (input_length_value - window_size);\n    int64_t output_length_value;\n    if (length_minus_window < 0) {\n      output_length_value = 0;\n    } else {\n      output_length_value = 1 + (length_minus_window / stride);\n    }\n    output_length = c->MakeDim(output_length_value);\n  }\n  DimensionHandle output_channels =\n      c->MakeDim(1 + NextPowerOfTwo(window_size) / 2);\n  c->set_output(0,\n                c->MakeShape({input_channels, output_length, output_channels}));\n  return OkStatus();\n}", "target": 0}
{"code": "static int do_tkill(pid_t tgid, pid_t pid, int sig)\n{\n\tstruct siginfo info;\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code = SI_TKILL;\n\tinfo.si_pid = task_tgid_vnr(current);\n\tinfo.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\treturn do_send_specific(tgid, pid, sig, &info);\n}", "target": 1}
{"code": "init_connection_options(MYSQL *mysql)\n{\n#if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)\n  if (opt_use_ssl)\n  {\n    mysql_ssl_set(mysql, opt_ssl_key, opt_ssl_cert, opt_ssl_ca,\n                  opt_ssl_capath, opt_ssl_cipher);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRL, opt_ssl_crl);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRLPATH, opt_ssl_crlpath);\n  }\n  mysql_options(mysql, MYSQL_OPT_SSL_VERIFY_SERVER_CERT,\n                (char*) &opt_ssl_verify_server_cert);\n#endif\n  if (opt_protocol)\n    mysql_options(mysql, MYSQL_OPT_PROTOCOL, (char*) &opt_protocol);\n#ifdef HAVE_SMEM\n  if (shared_memory_base_name)\n    mysql_options(mysql, MYSQL_SHARED_MEMORY_BASE_NAME, shared_memory_base_name);\n#endif\n}", "target": 1}
{"code": " void FrameView::updateLayoutAndStyleForPainting()\n {\n     RefPtr<FrameView> protector(this);\n     updateLayoutAndStyleIfNeededRecursive();\n     if (RenderView* view = renderView()) {\n         TRACE_EVENT_INSTANT1(TRACE_DISABLED_BY_DEFAULT(\"devtools.timeline\"), \"UpdateLayerTree\", \"frame\", m_frame.get());\n        InspectorInstrumentation::willUpdateLayerTree(m_frame.get());\n        view->compositor()->updateIfNeededRecursive();\n        if (view->compositor()->inCompositingMode() && m_frame->isLocalRoot())\n            m_frame->page()->scrollingCoordinator()->updateAfterCompositingChangeIfNeeded();\n        updateCompositedSelectionBoundsIfNeeded();\n        InspectorInstrumentation::didUpdateLayerTree(m_frame.get());\n        invalidateTreeIfNeededRecursive();\n    }\n    scrollContentsIfNeededRecursive();\n    ASSERT(lifecycle().state() == DocumentLifecycle::PaintInvalidationClean);\n}", "target": 1}
{"code": "static void wait_for_child_to_die(void *ctx)\n{\n\tREQUEST *request = ctx;\n\trad_assert(request->magic == REQUEST_MAGIC);\n\tif ((request->child_state == REQUEST_QUEUED) ||\n\t    ((request->child_state == REQUEST_RUNNING) &&\n\t     (pthread_equal(request->child_pid, NO_SUCH_CHILD_PID) == 0))) {\n\t\tif (request->delay < (USEC * 60 * 5)) {\n\t\t\trequest->delay += (request->delay >> 1);\n\t\t\tradlog(L_INFO, \"WARNING: Child is hung for request %u in component %s module %s.\",\n\t\t\t       request->number, request->component, request->module);\n\t\t} else {\n\t\t\tRDEBUG2(\"Child is still stuck for request %u\",\n\t\t\t\trequest->number);\n\t\t}\n\t\ttv_add(&request->when, request->delay);\n\t\tINSERT_EVENT(wait_for_child_to_die, request);\n\t\treturn;\n\t}\n\tRDEBUG2(\"Child is finally responsive for request %u\", request->number);\n\tremove_from_request_hash(request);\n#ifdef WITH_PROXY\n\tif (request->proxy) {\n\t\twait_for_proxy_id_to_expire(request);\n\t\treturn;\n\t}\n#endif\n\tev_request_free(&request);\n}", "target": 1}
{"code": "static ssize_t ib_ucm_write(struct file *filp, const char __user *buf,\n\t\t\t    size_t len, loff_t *pos)\n{\n\tstruct ib_ucm_file *file = filp->private_data;\n\tstruct ib_ucm_cmd_hdr hdr;\n\tssize_t result;\n\tif (WARN_ON_ONCE(!ib_safe_file_access(filp)))\n\t\treturn -EACCES;\n\tif (len < sizeof(hdr))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&hdr, buf, sizeof(hdr)))\n\t\treturn -EFAULT;\n\tif (hdr.cmd >= ARRAY_SIZE(ucm_cmd_table))\n\t\treturn -EINVAL;\n\tif (hdr.in + sizeof(hdr) > len)\n\t\treturn -EINVAL;\n\tresult = ucm_cmd_table[hdr.cmd](file, buf + sizeof(hdr),\n\t\t\t\t\thdr.in, hdr.out);\n\tif (!result)\n\t\tresult = len;\n\treturn result;\n}", "target": 0}
{"code": "static int __dwc3_gadget_kick_transfer(struct dwc3_ep *dep)\n{\n\tstruct dwc3_gadget_ep_cmd_params params;\n\tstruct dwc3_request\t\t*req;\n\tint\t\t\t\tstarting;\n\tint\t\t\t\tret;\n\tu32\t\t\t\tcmd;\n\tif (!dwc3_calc_trbs_left(dep))\n\t\treturn 0;\n\tstarting = !(dep->flags & DWC3_EP_BUSY);\n\tdwc3_prepare_trbs(dep);\n\treq = next_request(&dep->started_list);\n\tif (!req) {\n\t\tdep->flags |= DWC3_EP_PENDING_REQUEST;\n\t\treturn 0;\n\t}\n\tmemset(&params, 0, sizeof(params));\n\tif (starting) {\n\t\tparams.param0 = upper_32_bits(req->trb_dma);\n\t\tparams.param1 = lower_32_bits(req->trb_dma);\n\t\tcmd = DWC3_DEPCMD_STARTTRANSFER;\n\t\tif (usb_endpoint_xfer_isoc(dep->endpoint.desc))\n\t\t\tcmd |= DWC3_DEPCMD_PARAM(dep->frame_number);\n\t} else {\n\t\tcmd = DWC3_DEPCMD_UPDATETRANSFER |\n\t\t\tDWC3_DEPCMD_PARAM(dep->resource_index);\n\t}\n\tret = dwc3_send_gadget_ep_cmd(dep, cmd, &params);\n\tif (ret < 0) {\n\t\tif (req->trb)\n\t\t\tmemset(req->trb, 0, sizeof(struct dwc3_trb));\n\t\tdep->queued_requests--;\n\t\tdwc3_gadget_giveback(dep, req, ret);\n\t\treturn ret;\n\t}\n\tdep->flags |= DWC3_EP_BUSY;\n\tif (starting) {\n\t\tdep->resource_index = dwc3_gadget_ep_get_transfer_index(dep);\n\t\tWARN_ON_ONCE(!dep->resource_index);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "p11_rpc_buffer_get_byte_array (p11_buffer *buf,\n                               size_t *offset,\n                               const unsigned char **data,\n                               size_t *length)\n{\n\tsize_t off = *offset;\n\tuint32_t len;\n\tif (!p11_rpc_buffer_get_uint32 (buf, &off, &len))\n\t\treturn false;\n\tif (len == 0xffffffff) {\n\t\t*offset = off;\n\t\tif (data)\n\t\t\t*data = NULL;\n\t\tif (length)\n\t\t\t*length = 0;\n\t\treturn true;\n\t} else if (len >= 0x7fffffff) {\n\t\tp11_buffer_fail (buf);\n\t\treturn false;\n\t}\n\tif (buf->len < len || *offset > buf->len - len) {\n\t\tp11_buffer_fail (buf);\n\t\treturn false;\n\t}\n\tif (data)\n\t\t*data = (unsigned char *)buf->data + off;\n\tif (length)\n\t\t*length = len;\n\t*offset = off + len;\n\treturn true;\n}", "target": 1}
{"code": "static int _nfs4_proc_open(struct nfs4_opendata *data)\n{\n\tstruct inode *dir = data->dir->d_inode;\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs_openargs *o_arg = &data->o_arg;\n\tstruct nfs_openres *o_res = &data->o_res;\n\tint status;\n\tstatus = nfs4_run_open_task(data, 0);\n\tif (!data->rpc_done)\n\t\treturn status;\n\tif (status != 0) {\n\t\tif (status == -NFS4ERR_BADNAME &&\n\t\t\t\t!(o_arg->open_flags & O_CREAT))\n\t\t\treturn -ENOENT;\n\t\treturn status;\n\t}\n\tnfs_fattr_map_and_free_names(server, &data->f_attr);\n\tif (o_arg->open_flags & O_CREAT)\n\t\tupdate_changeattr(dir, &o_res->cinfo);\n\tif ((o_res->rflags & NFS4_OPEN_RESULT_LOCKTYPE_POSIX) == 0)\n\t\tserver->caps &= ~NFS_CAP_POSIX_LOCK;\n\tif(o_res->rflags & NFS4_OPEN_RESULT_CONFIRM) {\n\t\tstatus = _nfs4_proc_open_confirm(data);\n\t\tif (status != 0)\n\t\t\treturn status;\n\t}\n\tif (!(o_res->f_attr->valid & NFS_ATTR_FATTR))\n\t\t_nfs4_proc_getattr(server, &o_res->fh, o_res->f_attr);\n\treturn 0;\n}", "target": 0}
{"code": "wb_write_padding_to_temp(struct archive_write *a, int64_t csize)\n{\n\tsize_t ns;\n\tint ret;\n\tns = (size_t)(csize % LOGICAL_BLOCK_SIZE);\n\tif (ns != 0)\n\t\tret = write_null(a, LOGICAL_BLOCK_SIZE - ns);\n\telse\n\t\tret = ARCHIVE_OK;\n\treturn (ret);\n}", "target": 0}
{"code": "int db__message_store_find(struct mosquitto *context, uint16_t mid, struct mosquitto_msg_store **stored)\n{\n\tstruct mosquitto_client_msg *tail;\n\tif(!context) return MOSQ_ERR_INVAL;\n\t*stored = NULL;\n\tDL_FOREACH(context->msgs_in.inflight, tail){\n\t\tif(tail->store->source_mid == mid){\n\t\t\t*stored = tail->store;\n\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t}\n\t}\n\tDL_FOREACH(context->msgs_in.queued, tail){\n\t\tif(tail->store->source_mid == mid){\n\t\t\t*stored = tail->store;\n\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t}\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "  QInt8() {}", "target": 1}
{"code": "void cgit_clone_info(void)\n{\n\tif (!ctx.qry.path || strcmp(ctx.qry.path, \"refs\")) {\n\t\tcgit_print_error_page(400, \"Bad request\", \"Bad request\");\n\t\treturn;\n\t}\n\tctx.page.mimetype = \"text/plain\";\n\tctx.page.filename = \"info/refs\";\n\tcgit_print_http_headers();\n\tfor_each_ref(print_ref_info, NULL);\n}", "target": 0}
{"code": "static int vapic_enter(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tstruct page *page;\n\tif (!apic || !apic->vapic_addr)\n\t\treturn 0;\n\tpage = gfn_to_page(vcpu->kvm, apic->vapic_addr >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\treturn -EFAULT;\n\tvcpu->arch.apic->vapic_page = page;\n\treturn 0;\n}", "target": 1}
{"code": "njs_typed_array_set_value(njs_vm_t *vm, njs_typed_array_t *array,\n    uint32_t index, njs_value_t *setval)\n{\n    double              num;\n    njs_int_t           ret;\n    njs_array_buffer_t  *buffer;\n    ret = njs_value_to_number(vm, setval, &num);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    buffer = njs_typed_array_writable(vm, array);\n    if (njs_slow_path(buffer == NULL)) {\n        return NJS_ERROR;\n    }\n    njs_typed_array_prop_set(vm, array, index, num);\n    njs_set_number(setval, num);\n    return NJS_OK;\n}", "target": 1}
{"code": "parse_string(xmlTextReaderPtr reader, char const *attr, char **result)\n{\n\txmlChar *xml_value;\n\tchar *tmp;\n\tif (attr == NULL)\n\t\txml_value = xmlTextReaderValue(reader);\n\telse\n\t\txml_value = xmlTextReaderGetAttribute(reader, BAD_CAST attr);\n\tif (xml_value == NULL)\n\t\treturn pr_val_err(\"RRDP file: Couldn't find %s from '%s'\",\n\t\t    (attr == NULL ? \"string content\" : \"xml attribute\"),\n\t\t    xmlTextReaderConstLocalName(reader));\n\ttmp = malloc(xmlStrlen(xml_value) + 1);\n\tif (tmp == NULL) {\n\t\txmlFree(xml_value);\n\t\treturn pr_enomem();\n\t}\n\tmemcpy(tmp, xml_value, xmlStrlen(xml_value));\n\ttmp[xmlStrlen(xml_value)] = '\\0';\n\txmlFree(xml_value);\n\t*result = tmp;\n\treturn 0;\n}", "target": 1}
{"code": "int __ref online_pages(unsigned long pfn, unsigned long nr_pages)\n{\n\tunsigned long onlined_pages = 0;\n\tstruct zone *zone;\n\tint need_zonelists_rebuild = 0;\n\tint nid;\n\tint ret;\n\tstruct memory_notify arg;\n\tlock_memory_hotplug();\n\targ.start_pfn = pfn;\n\targ.nr_pages = nr_pages;\n\targ.status_change_nid = -1;\n\tnid = page_to_nid(pfn_to_page(pfn));\n\tif (node_present_pages(nid) == 0)\n\t\targ.status_change_nid = nid;\n\tret = memory_notify(MEM_GOING_ONLINE, &arg);\n\tret = notifier_to_errno(ret);\n\tif (ret) {\n\t\tmemory_notify(MEM_CANCEL_ONLINE, &arg);\n\t\tunlock_memory_hotplug();\n\t\treturn ret;\n\t}\n\tzone = page_zone(pfn_to_page(pfn));\n\tmutex_lock(&zonelists_mutex);\n\tif (!populated_zone(zone))\n\t\tneed_zonelists_rebuild = 1;\n\tret = walk_system_ram_range(pfn, nr_pages, &onlined_pages,\n\t\tonline_pages_range);\n\tif (ret) {\n\t\tmutex_unlock(&zonelists_mutex);\n\t\tprintk(KERN_DEBUG \"online_pages [mem %#010llx-%#010llx] failed\\n\",\n\t\t       (unsigned long long) pfn << PAGE_SHIFT,\n\t\t       (((unsigned long long) pfn + nr_pages)\n\t\t\t    << PAGE_SHIFT) - 1);\n\t\tmemory_notify(MEM_CANCEL_ONLINE, &arg);\n\t\tunlock_memory_hotplug();\n\t\treturn ret;\n\t}\n\tzone->present_pages += onlined_pages;\n\tzone->zone_pgdat->node_present_pages += onlined_pages;\n\tif (need_zonelists_rebuild)\n\t\tbuild_all_zonelists(NULL, zone);\n\telse\n\t\tzone_pcp_update(zone);\n\tmutex_unlock(&zonelists_mutex);\n\tinit_per_zone_wmark_min();\n\tif (onlined_pages) {\n\t\tkswapd_run(zone_to_nid(zone));\n\t\tnode_set_state(zone_to_nid(zone), N_HIGH_MEMORY);\n\t}\n\tvm_total_pages = nr_free_pagecache_pages();\n\twriteback_set_ratelimit();\n\tif (onlined_pages)\n\t\tmemory_notify(MEM_ONLINE, &arg);\n\tunlock_memory_hotplug();\n\treturn 0;\n}", "target": 1}
{"code": "int snd_rawmidi_input_params(struct snd_rawmidi_substream *substream,\n\t\t\t     struct snd_rawmidi_params * params)\n{\n\tchar *newbuf;\n\tstruct snd_rawmidi_runtime *runtime = substream->runtime;\n\tsnd_rawmidi_drain_input(substream);\n\tif (params->buffer_size < 32 || params->buffer_size > 1024L * 1024L) {\n\t\treturn -EINVAL;\n\t}\n\tif (params->avail_min < 1 || params->avail_min > params->buffer_size) {\n\t\treturn -EINVAL;\n\t}\n\tif (params->buffer_size != runtime->buffer_size) {\n\t\tnewbuf = krealloc(runtime->buffer, params->buffer_size,\n\t\t\t\t  GFP_KERNEL);\n\t\tif (!newbuf)\n\t\t\treturn -ENOMEM;\n\t\truntime->buffer = newbuf;\n\t\truntime->buffer_size = params->buffer_size;\n\t}\n\truntime->avail_min = params->avail_min;\n\treturn 0;\n}", "target": 1}
{"code": "static void __return_cfs_rq_runtime(struct cfs_rq *cfs_rq)\n{\n\tstruct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(cfs_rq->tg);\n\ts64 slack_runtime = cfs_rq->runtime_remaining - min_cfs_rq_runtime;\n\tif (slack_runtime <= 0)\n\t\treturn;\n\traw_spin_lock(&cfs_b->lock);\n\tif (cfs_b->quota != RUNTIME_INF &&\n\t    cfs_rq->runtime_expires == cfs_b->runtime_expires) {\n\t\tcfs_b->runtime += slack_runtime;\n\t\tif (cfs_b->runtime > sched_cfs_bandwidth_slice() &&\n\t\t    !list_empty(&cfs_b->throttled_cfs_rq))\n\t\t\tstart_cfs_slack_bandwidth(cfs_b);\n\t}\n\traw_spin_unlock(&cfs_b->lock);\n\tcfs_rq->runtime_remaining -= slack_runtime;\n}", "target": 1}
{"code": "waitfd(int fd, int *timeoutp, short events)\n{\n\tstruct pollfd pfd;\n\tstruct timeval t_start;\n\tint oerrno, r;\n\tpfd.fd = fd;\n\tpfd.events = events;\n\tfor (; *timeoutp >= 0;) {\n\t\tmonotime_tv(&t_start);\n\t\tr = poll(&pfd, 1, *timeoutp);\n\t\toerrno = errno;\n\t\tms_subtract_diff(&t_start, timeoutp);\n\t\terrno = oerrno;\n\t\tif (r > 0)\n\t\t\treturn 0;\n\t\telse if (r == -1 && errno != EAGAIN && errno != EINTR)\n\t\t\treturn -1;\n\t\telse if (r == 0)\n\t\t\tbreak;\n\t}\n\terrno = ETIMEDOUT;\n\treturn -1;\n}", "target": 0}
{"code": "spice_server_char_device_add_interface(SpiceServer *reds, SpiceBaseInstance *sin)\n{\n    SpiceCharDeviceInstance* char_device =\n            SPICE_UPCAST(SpiceCharDeviceInstance, sin);\n    red::shared_ptr<RedCharDevice> dev_state;\n    spice_debug(\"CHAR_DEVICE %s\", char_device->subtype);\n    if (strcmp(char_device->subtype, SUBTYPE_VDAGENT) == 0) {\n        if (reds->vdagent) {\n            spice_warning(\"vdagent already attached\");\n            return -1;\n        }\n        dev_state = attach_to_red_agent(reds, char_device);\n    }\n#ifdef USE_SMARTCARD\n    else if (strcmp(char_device->subtype, SUBTYPE_SMARTCARD) == 0) {\n        dev_state = smartcard_device_connect(reds, char_device);\n        if (!dev_state) {\n            return -1;\n        }\n    }\n#endif\n    else if (strcmp(char_device->subtype, SUBTYPE_USBREDIR) == 0) {\n        dev_state = spicevmc_device_connect(reds, char_device, SPICE_CHANNEL_USBREDIR);\n    }\n    else if (strcmp(char_device->subtype, SUBTYPE_PORT) == 0) {\n        if (strcmp(char_device->portname, \"org.spice-space.webdav.0\") == 0) {\n            dev_state = spicevmc_device_connect(reds, char_device, SPICE_CHANNEL_WEBDAV);\n        } else if (strcmp(char_device->portname, \"org.spice-space.stream.0\") == 0) {\n            dev_state = stream_device_connect(reds, char_device);\n        } else {\n            dev_state = spicevmc_device_connect(reds, char_device, SPICE_CHANNEL_PORT);\n        }\n    }\n    if (dev_state) {\n        spice_assert(dev_state.get() == char_device->st);\n        if (reds->vm_running) {\n            dev_state->start();\n        }\n        reds_add_char_device(reds, dev_state);\n    } else {\n        spice_warning(\"failed to create device state for %s\", char_device->subtype);\n        return -1;\n    }\n    return 0;\n}", "target": 0}
{"code": "  virtual bool ms_verify_authorizer(Connection *con, int peer_type,\n\t\t\t\t    int protocol, bufferlist& authorizer,\n\t\t\t\t    bufferlist& authorizer_reply,\n\t\t\t\t    bool& isvalid, CryptoKey& session_key) {\n    isvalid = true;\n    return true;\n  };", "target": 1}
{"code": "ppp_input(struct ppp_channel *chan, struct sk_buff *skb)\n{\n\tstruct channel *pch = chan->ppp;\n\tint proto;\n\tif (!pch || skb->len == 0) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\tproto = PPP_PROTO(skb);\n\tread_lock_bh(&pch->upl);\n\tif (!pch->ppp || proto >= 0xc000 || proto == PPP_CCPFRAG) {\n\t\tskb_queue_tail(&pch->file.rq, skb);\n\t\twhile (pch->file.rq.qlen > PPP_MAX_RQLEN\n\t\t       && (skb = skb_dequeue(&pch->file.rq)))\n\t\t\tkfree_skb(skb);\n\t\twake_up_interruptible(&pch->file.rwait);\n\t} else {\n\t\tppp_do_recv(pch->ppp, skb, pch);\n\t}\n\tread_unlock_bh(&pch->upl);\n}", "target": 0}
{"code": "get_word_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    register unsigned int temp;\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    *ptr++ = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    *ptr++ = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    *ptr++ = rescale[temp];\n  }\n  return 1;\n}", "target": 1}
{"code": "const FunctionDef* FunctionLibraryDefinition::Find(const string& func) const {\n  tf_shared_lock l(mu_);\n  auto result = FindHelper(func);\n  if (result) {\n    return &result->fdef;\n  } else {\n    return nullptr;\n  }\n}", "target": 0}
{"code": "static int persist__subs_save_all(FILE *db_fptr)\n{\n\tstruct mosquitto__subhier *subhier, *subhier_tmp;\n\tHASH_ITER(hh, db.subs, subhier, subhier_tmp){\n\t\tif(subhier->children){\n\t\t\tpersist__subs_save(db_fptr, subhier->children, \"\", 0);\n\t\t}\n\t}\n\treturn MOSQ_ERR_SUCCESS;\n}", "target": 1}
{"code": "static int ras_getdatastd(jas_stream_t *in, ras_hdr_t *hdr, ras_cmap_t *cmap,\n  jas_image_t *image)\n{\n\tint pad;\n\tint nz;\n\tint z;\n\tint c;\n\tint y;\n\tint x;\n\tint v;\n\tint i;\n\tjas_matrix_t *data[3];\n\tcmap = 0;\n\tfor (i = 0; i < jas_image_numcmpts(image); ++i) {\n\t\tdata[i] = jas_matrix_create(1, jas_image_width(image));\n\t\tassert(data[i]);\n\t}\n\tpad = RAS_ROWSIZE(hdr) - (hdr->width * hdr->depth + 7) / 8;\n\tfor (y = 0; y < hdr->height; y++) {\n\t\tnz = 0;\n\t\tz = 0;\n\t\tfor (x = 0; x < hdr->width; x++) {\n\t\t\twhile (nz < hdr->depth) {\n\t\t\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tz = (z << 8) | c;\n\t\t\t\tnz += 8;\n\t\t\t}\n\t\t\tv = (z >> (nz - hdr->depth)) & RAS_ONES(hdr->depth);\n\t\t\tz &= RAS_ONES(nz - hdr->depth);\n\t\t\tnz -= hdr->depth;\n\t\t\tif (jas_image_numcmpts(image) == 3) {\n\t\t\t\tjas_matrix_setv(data[0], x, (RAS_GETRED(v)));\n\t\t\t\tjas_matrix_setv(data[1], x, (RAS_GETGREEN(v)));\n\t\t\t\tjas_matrix_setv(data[2], x, (RAS_GETBLUE(v)));\n\t\t\t} else {\n\t\t\t\tjas_matrix_setv(data[0], x, (v));\n\t\t\t}\n\t\t}\n\t\tif (pad) {\n\t\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < jas_image_numcmpts(image); ++i) {\n\t\t\tif (jas_image_writecmpt(image, i, 0, y, hdr->width, 1,\n\t\t\t  data[i])) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i < jas_image_numcmpts(image); ++i) {\n\t\tjas_matrix_destroy(data[i]);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "vhost_user_check_and_alloc_queue_pair(struct virtio_net *dev,\n\t\t\tstruct VhostUserMsg *msg)\n{\n\tuint16_t vring_idx;\n\tswitch (msg->request.master) {\n\tcase VHOST_USER_SET_VRING_KICK:\n\tcase VHOST_USER_SET_VRING_CALL:\n\tcase VHOST_USER_SET_VRING_ERR:\n\t\tvring_idx = msg->payload.u64 & VHOST_USER_VRING_IDX_MASK;\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_NUM:\n\tcase VHOST_USER_SET_VRING_BASE:\n\tcase VHOST_USER_SET_VRING_ENABLE:\n\t\tvring_idx = msg->payload.state.index;\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_ADDR:\n\t\tvring_idx = msg->payload.addr.index;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tif (vring_idx >= VHOST_MAX_VRING) {\n\t\tVHOST_LOG_CONFIG(ERR,\n\t\t\t\"invalid vring index: %u\\n\", vring_idx);\n\t\treturn -1;\n\t}\n\tif (dev->virtqueue[vring_idx])\n\t\treturn 0;\n\treturn alloc_vring_queue(dev, vring_idx);\n}", "target": 1}
{"code": "\tSpawnPreparationInfo prepareSpawn(const Options &options) {\n\t\tTRACE_POINT();\n\t\tSpawnPreparationInfo info;\n\t\tprepareChroot(info, options);\n\t\tinfo.userSwitching = prepareUserSwitching(options);\n\t\tprepareSwitchingWorkingDirectory(info, options);\n\t\tinferApplicationInfo(info);\n\t\treturn info;\n\t}", "target": 1}
{"code": "void FrameFactory::rebuildAggregateFrames(ID3v2::Tag *tag) const\n{\n  if(tag->header()->majorVersion() < 4 &&\n     tag->frameList(\"TDRC\").size() == 1 &&\n     tag->frameList(\"TDAT\").size() == 1)\n  {\n    TextIdentificationFrame *tdrc =\n      static_cast<TextIdentificationFrame *>(tag->frameList(\"TDRC\").front());\n    UnknownFrame *tdat = static_cast<UnknownFrame *>(tag->frameList(\"TDAT\").front());\n    if(tdrc->fieldList().size() == 1 &&\n       tdrc->fieldList().front().size() == 4 &&\n       tdat->data().size() >= 5)\n    {\n      String date(tdat->data().mid(1), String::Type(tdat->data()[0]));\n      if(date.length() == 4) {\n        tdrc->setText(tdrc->toString() + '-' + date.substr(2, 2) + '-' + date.substr(0, 2));\n        if(tag->frameList(\"TIME\").size() == 1) {\n          UnknownFrame *timeframe = static_cast<UnknownFrame *>(tag->frameList(\"TIME\").front());\n          if(timeframe->data().size() >= 5) {\n            String time(timeframe->data().mid(1), String::Type(timeframe->data()[0]));\n            if(time.length() == 4) {\n              tdrc->setText(tdrc->toString() + 'T' + time.substr(0, 2) + ':' + time.substr(2, 2));\n            }\n          }\n        }\n      }\n    }\n  }\n}", "target": 1}
{"code": "static void tcp_illinois_info(struct sock *sk, u32 ext,\n\t\t\t      struct sk_buff *skb)\n{\n\tconst struct illinois *ca = inet_csk_ca(sk);\n\tif (ext & (1 << (INET_DIAG_VEGASINFO - 1))) {\n\t\tstruct tcpvegas_info info = {\n\t\t\t.tcpv_enabled = 1,\n\t\t\t.tcpv_rttcnt = ca->cnt_rtt,\n\t\t\t.tcpv_minrtt = ca->base_rtt,\n\t\t};\n\t\tu64 t = ca->sum_rtt;\n\t\tdo_div(t, ca->cnt_rtt);\n\t\tinfo.tcpv_rtt = t;\n\t\tnla_put(skb, INET_DIAG_VEGASINFO, sizeof(info), &info);\n\t}\n}", "target": 1}
{"code": "static int bus_socket_make_message(sd_bus *bus, size_t size) {\n        sd_bus_message *t;\n        void *b;\n        int r;\n        assert(bus);\n        assert(bus->rbuffer_size >= size);\n        assert(IN_SET(bus->state, BUS_RUNNING, BUS_HELLO));\n        r = bus_rqueue_make_room(bus);\n        if (r < 0)\n                return r;\n        if (bus->rbuffer_size > size) {\n                b = memdup((const uint8_t*) bus->rbuffer + size,\n                           bus->rbuffer_size - size);\n                if (!b)\n                        return -ENOMEM;\n        } else\n                b = NULL;\n        r = bus_message_from_malloc(bus,\n                                    bus->rbuffer, size,\n                                    bus->fds, bus->n_fds,\n                                    NULL,\n                                    &t);\n        if (r < 0) {\n                free(b);\n                return r;\n        }\n        bus->rbuffer = b;\n        bus->rbuffer_size -= size;\n        bus->fds = NULL;\n        bus->n_fds = 0;\n        bus->rqueue[bus->rqueue_size++] = t;\n        return 1;\n}", "target": 1}
{"code": "asmlinkage void __sched schedule(void)\n{\n\tstruct task_struct *prev, *next;\n\tunsigned long *switch_count;\n\tstruct rq *rq;\n\tint cpu;\nneed_resched:\n\tpreempt_disable();\n\tcpu = smp_processor_id();\n\trq = cpu_rq(cpu);\n\trcu_note_context_switch(cpu);\n\tprev = rq->curr;\n\trelease_kernel_lock(prev);\nneed_resched_nonpreemptible:\n\tschedule_debug(prev);\n\tif (sched_feat(HRTICK))\n\t\thrtick_clear(rq);\n\traw_spin_lock_irq(&rq->lock);\n\tclear_tsk_need_resched(prev);\n\tswitch_count = &prev->nivcsw;\n\tif (prev->state && !(preempt_count() & PREEMPT_ACTIVE)) {\n\t\tif (unlikely(signal_pending_state(prev->state, prev))) {\n\t\t\tprev->state = TASK_RUNNING;\n\t\t} else {\n\t\t\tif (prev->flags & PF_WQ_WORKER) {\n\t\t\t\tstruct task_struct *to_wakeup;\n\t\t\t\tto_wakeup = wq_worker_sleeping(prev, cpu);\n\t\t\t\tif (to_wakeup)\n\t\t\t\t\ttry_to_wake_up_local(to_wakeup);\n\t\t\t}\n\t\t\tdeactivate_task(rq, prev, DEQUEUE_SLEEP);\n\t\t}\n\t\tswitch_count = &prev->nvcsw;\n\t}\n\tpre_schedule(rq, prev);\n\tif (unlikely(!rq->nr_running))\n\t\tidle_balance(cpu, rq);\n\tput_prev_task(rq, prev);\n\tnext = pick_next_task(rq);\n\tif (likely(prev != next)) {\n\t\tsched_info_switch(prev, next);\n\t\tperf_event_task_sched_out(prev, next);\n\t\trq->nr_switches++;\n\t\trq->curr = next;\n\t\t++*switch_count;\n\t\tcontext_switch(rq, prev, next); \n\t\tcpu = smp_processor_id();\n\t\trq = cpu_rq(cpu);\n\t} else\n\t\traw_spin_unlock_irq(&rq->lock);\n\tpost_schedule(rq);\n\tif (unlikely(reacquire_kernel_lock(prev)))\n\t\tgoto need_resched_nonpreemptible;\n\tpreempt_enable_no_resched();\n\tif (need_resched())\n\t\tgoto need_resched;\n}", "target": 1}
{"code": "static void ene_remove(struct pnp_dev *pnp_dev)\n{\n\tstruct ene_device *dev = pnp_get_drvdata(pnp_dev);\n\tunsigned long flags;\n\tspin_lock_irqsave(&dev->hw_lock, flags);\n\tene_rx_disable(dev);\n\tene_rx_restore_hw_buffer(dev);\n\tspin_unlock_irqrestore(&dev->hw_lock, flags);\n\tfree_irq(dev->irq, dev);\n\trelease_region(dev->hw_io, ENE_IO_SIZE);\n\trc_unregister_device(dev->rdev);\n\tkfree(dev);\n}", "target": 1}
{"code": "static int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n#if 0\n\tjp2_pclr_t *pclr = &box->data.pclr;\n#endif\nbox = 0;\nout = 0;\n\treturn -1;\n}", "target": 1}
{"code": "spnego_gss_wrap_aead(OM_uint32 *minor_status,\n\t\t     gss_ctx_id_t context_handle,\n\t\t     int conf_req_flag,\n\t\t     gss_qop_t qop_req,\n\t\t     gss_buffer_t input_assoc_buffer,\n\t\t     gss_buffer_t input_payload_buffer,\n\t\t     int *conf_state,\n\t\t     gss_buffer_t output_message_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_aead(minor_status,\n\t\t\t    context_handle,\n\t\t\t    conf_req_flag,\n\t\t\t    qop_req,\n\t\t\t    input_assoc_buffer,\n\t\t\t    input_payload_buffer,\n\t\t\t    conf_state,\n\t\t\t    output_message_buffer);\n\treturn (ret);\n}", "target": 0}
{"code": "static int selinux_netlbl_sock_setsid(struct sock *sk)\n{\n\tint rc;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tstruct netlbl_lsm_secattr *secattr;\n\tif (sksec->nlbl_state != NLBL_REQUIRE)\n\t\treturn 0;\n\tsecattr = selinux_netlbl_sock_genattr(sk);\n\tif (secattr == NULL)\n\t\treturn -ENOMEM;\n\trc = netlbl_sock_setattr(sk, secattr);\n\tswitch (rc) {\n\tcase 0:\n\t\tsksec->nlbl_state = NLBL_LABELED;\n\t\tbreak;\n\tcase -EDESTADDRREQ:\n\t\tsksec->nlbl_state = NLBL_REQSKB;\n\t\trc = 0;\n\t\tbreak;\n\t}\n\treturn rc;\n}", "target": 0}
{"code": "void setup_work_tree(void)\n{\n\tconst char *work_tree, *git_dir;\n\tstatic int initialized = 0;\n\tif (initialized)\n\t\treturn;\n\twork_tree = get_git_work_tree();\n\tgit_dir = get_git_dir();\n\tif (!is_absolute_path(git_dir))\n\t\tset_git_dir(make_absolute_path(git_dir));\n\tif (!work_tree || chdir(work_tree))\n\t\tdie(\"This operation must be run in a work tree\");\n\tinitialized = 1;\n}", "target": 0}
{"code": "int mutt_seqset_iterator_next(struct SeqsetIterator *iter, unsigned int *next)\n{\n  if (!iter || !next)\n    return -1;\n  if (iter->in_range)\n  {\n    if ((iter->down && (iter->range_cur == (iter->range_end - 1))) ||\n        (!iter->down && (iter->range_cur == (iter->range_end + 1))))\n    {\n      iter->in_range = 0;\n    }\n  }\n  if (!iter->in_range)\n  {\n    iter->substr_cur = iter->substr_end;\n    if (iter->substr_cur == iter->eostr)\n      return 1;\n    while (!*(iter->substr_cur))\n      iter->substr_cur++;\n    iter->substr_end = strchr(iter->substr_cur, ',');\n    if (!iter->substr_end)\n      iter->substr_end = iter->eostr;\n    else\n      *(iter->substr_end) = '\\0';\n    char *range_sep = strchr(iter->substr_cur, ':');\n    if (range_sep)\n      *range_sep++ = '\\0';\n    if (mutt_str_atoui(iter->substr_cur, &iter->range_cur) != 0)\n      return -1;\n    if (range_sep)\n    {\n      if (mutt_str_atoui(range_sep, &iter->range_end) != 0)\n        return -1;\n    }\n    else\n      iter->range_end = iter->range_cur;\n    iter->down = (iter->range_end < iter->range_cur);\n    iter->in_range = 1;\n  }\n  *next = iter->range_cur;\n  if (iter->down)\n    iter->range_cur--;\n  else\n    iter->range_cur++;\n  return 0;\n}", "target": 1}
{"code": "int ntlm_read_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn -1;\n\tStream_Read_UINT16(s, fields->Len); \n\tStream_Read_UINT16(s, fields->MaxLen); \n\tStream_Read_UINT32(s, fields->BufferOffset); \n\treturn 1;\n}", "target": 1}
{"code": "static void *createArrayObject(const redisReadTask *task, size_t elements) {\n    redisReply *r, *parent;\n    r = createReplyObject(task->type);\n    if (r == NULL)\n        return NULL;\n    if (elements > 0) {\n        if (SIZE_MAX / sizeof(redisReply*) < elements) return NULL;  \n        r->element = hi_calloc(elements,sizeof(redisReply*));\n        if (r->element == NULL) {\n            freeReplyObject(r);\n            return NULL;\n        }\n    }\n    r->elements = elements;\n    if (task->parent) {\n        parent = task->parent->obj;\n        assert(parent->type == REDIS_REPLY_ARRAY ||\n               parent->type == REDIS_REPLY_MAP ||\n               parent->type == REDIS_REPLY_SET ||\n               parent->type == REDIS_REPLY_PUSH);\n        parent->element[task->idx] = r;\n    }\n    return r;\n}", "target": 0}
{"code": "void HeaderUtility::stripPortFromHost(RequestHeaderMap& headers, uint32_t listener_port) {\n  if (headers.getMethodValue() == Http::Headers::get().MethodValues.Connect) {\n    return;\n  }\n  const absl::string_view original_host = headers.getHostValue();\n  const absl::string_view::size_type port_start = original_host.rfind(':');\n  if (port_start == absl::string_view::npos) {\n    return;\n  }\n  const auto v6_end_index = original_host.rfind(\"]\");\n  if (v6_end_index == absl::string_view::npos || v6_end_index < port_start) {\n    if ((port_start + 1) > original_host.size()) {\n      return;\n    }\n    const absl::string_view port_str = original_host.substr(port_start + 1);\n    uint32_t port = 0;\n    if (!absl::SimpleAtoi(port_str, &port)) {\n      return;\n    }\n    if (port != listener_port) {\n      return;\n    }\n    const absl::string_view host = original_host.substr(0, port_start);\n    headers.setHost(host);\n  }\n}", "target": 0}
{"code": "header_cache_t* imap_hcache_open (IMAP_DATA* idata, const char* path)\n{\n  IMAP_MBOX mx;\n  ciss_url_t url;\n  char cachepath[LONG_STRING];\n  char mbox[LONG_STRING];\n  if (path)\n    imap_cachepath (idata, path, mbox, sizeof (mbox));\n  else\n  {\n    if (!idata->ctx || imap_parse_path (idata->ctx->path, &mx) < 0)\n      return NULL;\n    imap_cachepath (idata, mx.mbox, mbox, sizeof (mbox));\n    FREE (&mx.mbox);\n  }\n  mutt_account_tourl (&idata->conn->account, &url);\n  url.path = mbox;\n  url_ciss_tostring (&url, cachepath, sizeof (cachepath), U_PATH);\n  return mutt_hcache_open (HeaderCache, cachepath, imap_hcache_namer);\n}", "target": 1}
{"code": "vrrp_print_data(void)\n{\n\tFILE *file = fopen (dump_file, \"w\");\n\tif (!file) {\n\t\tlog_message(LOG_INFO, \"Can't open %s (%d: %s)\",\n\t\t\tdump_file, errno, strerror(errno));\n\t\treturn;\n\t}\n\tdump_data_vrrp(file);\n\tfclose(file);\n}", "target": 1}
{"code": "check_1_6_dummy(kadm5_principal_ent_t entry, long mask,\n                int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char **passptr)\n{\n    int i;\n    char *password = *passptr;\n    if (!(mask & KADM5_ATTRIBUTES) ||\n        !(entry->attributes & KRB5_KDB_DISALLOW_ALL_TIX))\n        return;\n    for (i = 0; (unsigned char) password[i] == i + 1; i++);\n    if (password[i] != '\\0' || i != 255)\n        return;\n    *passptr = NULL;\n}", "target": 1}
{"code": "static int mxf_read_primer_pack(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFContext *mxf = arg;\n    int item_num = avio_rb32(pb);\n    int item_len = avio_rb32(pb);\n    if (item_len != 18) {\n        avpriv_request_sample(pb, \"Primer pack item length %d\", item_len);\n        return AVERROR_PATCHWELCOME;\n    }\n    if (item_num > 65536) {\n        av_log(mxf->fc, AV_LOG_ERROR, \"item_num %d is too large\\n\", item_num);\n        return AVERROR_INVALIDDATA;\n    }\n    mxf->local_tags = av_calloc(item_num, item_len);\n    if (!mxf->local_tags)\n        return AVERROR(ENOMEM);\n    mxf->local_tags_count = item_num;\n    avio_read(pb, mxf->local_tags, item_num*item_len);\n    return 0;\n}", "target": 1}
{"code": "static spl_ptr_heap_element spl_ptr_heap_delete_top(spl_ptr_heap *heap, void *cmp_userdata TSRMLS_DC) { \n\tint i, j;\n\tconst int limit = (heap->count-1)/2;\n\tspl_ptr_heap_element top;\n\tspl_ptr_heap_element bottom;\n\tif (heap->count == 0) {\n\t\treturn NULL;\n\t}\n\ttop    = heap->elements[0];\n\tbottom = heap->elements[--heap->count];\n\tfor( i = 0; i < limit; i = j)\n\t{\n\t\tj = i*2+1;\n\t\tif(j != heap->count && heap->cmp(heap->elements[j+1], heap->elements[j], cmp_userdata TSRMLS_CC) > 0) {\n\t\t\tj++; \n\t\t}\n\t\tif(heap->cmp(bottom, heap->elements[j], cmp_userdata TSRMLS_CC) < 0) {\n\t\t\theap->elements[i] = heap->elements[j];\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (EG(exception)) {\n\t\theap->flags |= SPL_HEAP_CORRUPTED;\n\t}\n\theap->elements[i] = bottom;\n\theap->dtor(top TSRMLS_CC);\n\treturn top;\n}", "target": 0}
{"code": "l2tp_accm_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\tuint16_t val_h, val_l;\n\tptr++;\t\t\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"send=%08x \", (val_h<<16) + val_l));\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"recv=%08x \", (val_h<<16) + val_l));\n}", "target": 1}
{"code": "void ves_icall_System_Threading_InternalThread_Thread_free_internal (MonoInternalThread *this, HANDLE thread)\n{\n\tMONO_ARCH_SAVE_REGS;\n\tTHREAD_DEBUG (g_message (\"%s: Closing thread %p, handle %p\", __func__, this, thread));\n\tif (thread)\n\t\tCloseHandle (thread);\n\tif (this->synch_cs) {\n\t\tDeleteCriticalSection (this->synch_cs);\n\t\tg_free (this->synch_cs);\n\t\tthis->synch_cs = NULL;\n\t}\n\tg_free (this->name);\n}", "target": 1}
{"code": "static void show_object(struct object *obj,\n\t\t\tstruct strbuf *path, const char *component,\n\t\t\tvoid *cb_data)\n{\n\tstruct rev_list_info *info = cb_data;\n\tfinish_object(obj, path, component, cb_data);\n\tif (info->flags & REV_LIST_QUIET)\n\t\treturn;\n\tshow_object_with_name(stdout, obj, path, component);\n}", "target": 1}
{"code": "void ApplyChannelMatrix::run(const void *inputData, void *outputData, int frameCount)\n{\n\tconst T *input = reinterpret_cast<const T *>(inputData);\n\tT *output = reinterpret_cast<T *>(outputData);\n\tfor (int frame=0; frame<frameCount; frame++)\n\t{\n\t\tconst T *inputSave = input;\n\t\tconst double *m = m_matrix;\n\t\tfor (int outChannel=0; outChannel < m_outChannels; outChannel++)\n\t\t{\n\t\t\tinput = inputSave;\n\t\t\tdouble t = 0;\n\t\t\tfor (int inChannel=0; inChannel < m_inChannels; inChannel++)\n\t\t\t\tt += *input++ * *m++;\n\t\t\t*output++ = t;\n\t\t}\n\t}\n}", "target": 0}
{"code": "void SimpleSoftOMXComponent::onSendCommand(\n        OMX_COMMANDTYPE cmd, OMX_U32 param) {\n switch (cmd) {\n case OMX_CommandStateSet:\n {\n            onChangeState((OMX_STATETYPE)param);\n break;\n }\n case OMX_CommandPortEnable:\n case OMX_CommandPortDisable:\n {\n            onPortEnable(param, cmd == OMX_CommandPortEnable);\n break;\n }\n case OMX_CommandFlush:\n {\n            onPortFlush(param, true );\n break;\n }\n default:\n            TRESPASS();\n break;\n }\n}", "target": 0}
{"code": "static void save_text_if_changed(const char *name, const char *new_value)\n{\n    if (!g_hash_table_lookup(g_loaded_texts, name))\n        return;\n    const char *old_value = g_cd ? problem_data_get_content_or_NULL(g_cd, name) : \"\";\n    if (!old_value)\n        old_value = \"\";\n    if (strcmp(new_value, old_value) != 0)\n    {\n        struct dump_dir *dd = wizard_open_directory_for_writing(g_dump_dir_name);\n        if (dd)\n            dd_save_text(dd, name, new_value);\n        dd_close(dd);\n        problem_data_reload_from_dump_dir();\n        update_gui_state_from_problem_data( 0);\n    }\n}", "target": 1}
{"code": "gdImagePtr gdImageCreateTrueColor (int sx, int sy)\n{\n\tint i;\n\tgdImagePtr im;\n\tif (overflow2(sx, sy)) {\n\t\treturn NULL;\n\t}\n\tif (overflow2(sizeof(unsigned char *), sy)) {\n\t\treturn NULL;\n\t}\n\tif (overflow2(sizeof(int), sx)) {\n\t\treturn NULL;\n\t}\n\tim = (gdImage *) gdMalloc(sizeof(gdImage));\n\tmemset(im, 0, sizeof(gdImage));\n\tim->tpixels = (int **) gdMalloc(sizeof(int *) * sy);\n\tim->AA_opacity = (unsigned char **) gdMalloc(sizeof(unsigned char *) * sy);\n\tim->polyInts = 0;\n\tim->polyAllocated = 0;\n\tim->brush = 0;\n\tim->tile = 0;\n\tim->style = 0;\n\tfor (i = 0; i < sy; i++) {\n\t\tim->tpixels[i] = (int *) gdCalloc(sx, sizeof(int));\n\t\tim->AA_opacity[i] = (unsigned char *) gdCalloc(sx, sizeof(unsigned char));\n\t}\n\tim->sx = sx;\n\tim->sy = sy;\n\tim->transparent = (-1);\n\tim->interlace = 0;\n\tim->trueColor = 1;\n\tim->saveAlphaFlag = 0;\n\tim->alphaBlendingFlag = 1;\n\tim->thick = 1;\n\tim->AA = 0;\n\tim->AA_polygon = 0;\n\tim->cx1 = 0;\n\tim->cy1 = 0;\n\tim->cx2 = im->sx - 1;\n\tim->cy2 = im->sy - 1;\n\tim->interpolation = NULL;\n\tim->interpolation_id = GD_BILINEAR_FIXED;\n\treturn im;\n}", "target": 0}
{"code": "errno_t sss_filter_sanitize(TALLOC_CTX *mem_ctx,\n                            const char *input,\n                            char **sanitized)\n{\n    return sss_filter_sanitize_ex(mem_ctx, input, sanitized, NULL);\n}", "target": 1}
{"code": "void av_fast_padded_mallocz(void *ptr, unsigned int *size, size_t min_size)\n{\n    uint8_t **p = ptr;\n    if (min_size > SIZE_MAX - FF_INPUT_BUFFER_PADDING_SIZE) {\n        av_freep(p);\n        *size = 0;\n        return;\n    }\n    if (!ff_fast_malloc(p, size, min_size + FF_INPUT_BUFFER_PADDING_SIZE, 1))\n        memset(*p, 0, min_size + FF_INPUT_BUFFER_PADDING_SIZE);\n}", "target": 0}
{"code": "static noinline void key_gc_unused_keys(struct list_head *keys)\n{\n\twhile (!list_empty(keys)) {\n\t\tstruct key *key =\n\t\t\tlist_entry(keys->next, struct key, graveyard_link);\n\t\tlist_del(&key->graveyard_link);\n\t\tkdebug(\"- %u\", key->serial);\n\t\tkey_check(key);\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&\n\t\t    !test_bit(KEY_FLAG_NEGATIVE, &key->flags) &&\n\t\t    key->type->destroy)\n\t\t\tkey->type->destroy(key);\n\t\tsecurity_key_free(key);\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\t\tatomic_dec(&key->user->nkeys);\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))\n\t\t\tatomic_dec(&key->user->nikeys);\n\t\tkey_user_put(key->user);\n\t\tkfree(key->description);\n#ifdef KEY_DEBUGGING\n\t\tkey->magic = KEY_DEBUG_MAGIC_X;\n#endif\n\t\tkmem_cache_free(key_jar, key);\n\t}\n}", "target": 0}
{"code": " av_cold void ff_mpv_idct_init(MpegEncContext *s)\n {\n     ff_idctdsp_init(&s->idsp, s->avctx);\n    if (s->alternate_scan) {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_alternate_vertical_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_alternate_vertical_scan);\n    } else {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_zigzag_direct);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_zigzag_direct);\n    }\n    ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_horizontal_scan);\n    ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);\n}", "target": 1}
{"code": "static void sas_scsi_clear_queue_lu(struct list_head *error_q, struct scsi_cmnd *my_cmd)\n{\n\tstruct scsi_cmnd *cmd, *n;\n\tlist_for_each_entry_safe(cmd, n, error_q, eh_entry) {\n\t\tif (cmd->device->sdev_target == my_cmd->device->sdev_target &&\n\t\t    cmd->device->lun == my_cmd->device->lun)\n\t\t\tsas_eh_defer_cmd(cmd);\n\t}\n}", "target": 1}
{"code": "parse_table(\n\tstruct buf *ob,\n\tstruct sd_markdown *rndr,\n\tuint8_t *data,\n\tsize_t size)\n{\n\tsize_t i;\n\tstruct buf *header_work = 0;\n\tstruct buf *body_work = 0;\n\tsize_t columns;\n\tint *col_data = NULL;\n\theader_work = rndr_newbuf(rndr, BUFFER_SPAN);\n\tbody_work = rndr_newbuf(rndr, BUFFER_BLOCK);\n\ti = parse_table_header(header_work, rndr, data, size, &columns, &col_data);\n\tif (i > 0) {\n\t\twhile (i < size) {\n\t\t\tsize_t row_start;\n\t\t\tint pipes = 0;\n\t\t\trow_start = i;\n\t\t\twhile (i < size && data[i] != '\\n')\n\t\t\t\tif (data[i++] == '|')\n\t\t\t\t\tpipes++;\n\t\t\tif (pipes == 0 || i == size) {\n\t\t\t\ti = row_start;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tparse_table_row(\n\t\t\t\tbody_work,\n\t\t\t\trndr,\n\t\t\t\tdata + row_start,\n\t\t\t\ti - row_start,\n\t\t\t\tcolumns,\n\t\t\t\tcol_data, 0\n\t\t\t);\n\t\t\ti++;\n\t\t}\n\t\tif (rndr->cb.table)\n\t\t\trndr->cb.table(ob, header_work, body_work, rndr->opaque);\n\t}\n\tfree(col_data);\n\trndr_popbuf(rndr, BUFFER_SPAN);\n\trndr_popbuf(rndr, BUFFER_BLOCK);\n\treturn i;\n}", "target": 0}
{"code": "ieee80211_tx_h_check_assoc(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)tx->skb->data;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tbool assoc = false;\n\tif (unlikely(info->flags & IEEE80211_TX_CTL_INJECTED))\n\t\treturn TX_CONTINUE;\n\tif (unlikely(test_bit(SCAN_SW_SCANNING, &tx->local->scanning)) &&\n\t    test_bit(SDATA_STATE_OFFCHANNEL, &tx->sdata->state) &&\n\t    !ieee80211_is_probe_req(hdr->frame_control) &&\n\t    !ieee80211_is_nullfunc(hdr->frame_control))\n\t\treturn TX_DROP;\n\tif (tx->sdata->vif.type == NL80211_IFTYPE_WDS)\n\t\treturn TX_CONTINUE;\n\tif (tx->sdata->vif.type == NL80211_IFTYPE_MESH_POINT)\n\t\treturn TX_CONTINUE;\n\tif (tx->flags & IEEE80211_TX_PS_BUFFERED)\n\t\treturn TX_CONTINUE;\n\tif (tx->sta)\n\t\tassoc = test_sta_flag(tx->sta, WLAN_STA_ASSOC);\n\tif (likely(tx->flags & IEEE80211_TX_UNICAST)) {\n\t\tif (unlikely(!assoc &&\n\t\t\t     ieee80211_is_data(hdr->frame_control))) {\n#ifdef CONFIG_MAC80211_VERBOSE_DEBUG\n\t\t\tsdata_info(tx->sdata,\n\t\t\t\t   \"dropped data frame to not associated station %pM\\n\",\n\t\t\t\t   hdr->addr1);\n#endif\n\t\t\tI802_DEBUG_INC(tx->local->tx_handlers_drop_not_assoc);\n\t\t\treturn TX_DROP;\n\t\t}\n\t} else if (unlikely(tx->sdata->vif.type == NL80211_IFTYPE_AP &&\n\t\t\t    ieee80211_is_data(hdr->frame_control) &&\n\t\t\t    !atomic_read(&tx->sdata->u.ap.num_mcast_sta))) {\n\t\treturn TX_DROP;\n\t}\n\treturn TX_CONTINUE;\n}", "target": 0}
{"code": "AcpiNsGetNodeUnlocked (\n    ACPI_NAMESPACE_NODE     *PrefixNode,\n    const char              *Pathname,\n    UINT32                  Flags,\n    ACPI_NAMESPACE_NODE     **ReturnNode)\n{\n    ACPI_GENERIC_STATE      ScopeInfo;\n    ACPI_STATUS             Status;\n    char                    *InternalPath;\n    ACPI_FUNCTION_TRACE_PTR (NsGetNodeUnlocked, ACPI_CAST_PTR (char, Pathname));\n    if (!Pathname)\n    {\n        *ReturnNode = PrefixNode;\n        if (!PrefixNode)\n        {\n            *ReturnNode = AcpiGbl_RootNode;\n        }\n        return_ACPI_STATUS (AE_OK);\n    }\n    if (ACPI_IS_ROOT_PREFIX (Pathname[0]) && (!Pathname[1]))\n    {\n        *ReturnNode = AcpiGbl_RootNode;\n        return_ACPI_STATUS (AE_OK);\n    }\n    Status = AcpiNsInternalizeName (Pathname, &InternalPath);\n    if (ACPI_FAILURE (Status))\n    {\n        return_ACPI_STATUS (Status);\n    }\n    ScopeInfo.Scope.Node = PrefixNode;\n    Status = AcpiNsLookup (&ScopeInfo, InternalPath, ACPI_TYPE_ANY,\n        ACPI_IMODE_EXECUTE, (Flags | ACPI_NS_DONT_OPEN_SCOPE),\n        NULL, ReturnNode);\n    if (ACPI_FAILURE (Status))\n    {\n        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, \"%s, %s\\n\",\n            Pathname, AcpiFormatException (Status)));\n    }\n    ACPI_FREE (InternalPath);\n    return_ACPI_STATUS (Status);\n}", "target": 0}
{"code": "void btrfs_trans_release_chunk_metadata(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tif (!trans->chunk_bytes_reserved)\n\t\treturn;\n\tWARN_ON_ONCE(!list_empty(&trans->new_bgs));\n\tbtrfs_block_rsv_release(fs_info, &fs_info->chunk_block_rsv,\n\t\t\t\ttrans->chunk_bytes_reserved, NULL);\n\tatomic64_sub(trans->chunk_bytes_reserved, &cur_trans->chunk_bytes_reserved);\n\tcond_wake_up(&cur_trans->chunk_reserve_wait);\n\ttrans->chunk_bytes_reserved = 0;\n}", "target": 1}
{"code": "set_lenIV(char *line)\n{\n  char *p = strstr(line, \"/lenIV \");\n  if (p && (isdigit(p[7]) || p[7] == '+' || p[7] == '-')) {\n    lenIV = atoi(p + 7);\n  }\n}", "target": 1}
{"code": "static void test_show_object(struct object *object,\n\t\t\t     struct strbuf *path,\n\t\t\t     const char *last, void *data)\n{\n\tstruct bitmap_test_data *tdata = data;\n\tint bitmap_pos;\n\tbitmap_pos = bitmap_position(object->oid.hash);\n\tif (bitmap_pos < 0)\n\t\tdie(\"Object not in bitmap: %s\\n\", oid_to_hex(&object->oid));\n\tbitmap_set(tdata->base, bitmap_pos);\n\tdisplay_progress(tdata->prg, ++tdata->seen);\n}", "target": 1}
{"code": "GopherStateData::~GopherStateData()\n{\n    if (entry)\n        entry->unlock(\"gopherState\");\n    if (buf)\n        memFree(buf, MEM_4K_BUF);\n}", "target": 1}
{"code": "static int ep_scan_ready_list(struct eventpoll *ep,\n\t\t\t      int (*sproc)(struct eventpoll *,\n\t\t\t\t\t   struct list_head *, void *),\n\t\t\t      void *priv,\n\t\t\t      int depth)\n{\n\tint error, pwake = 0;\n\tunsigned long flags;\n\tstruct epitem *epi, *nepi;\n\tLIST_HEAD(txlist);\n\tmutex_lock_nested(&ep->mtx, depth);\n\tspin_lock_irqsave(&ep->lock, flags);\n\tlist_splice_init(&ep->rdllist, &txlist);\n\tep->ovflist = NULL;\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\terror = (*sproc)(ep, &txlist, priv);\n\tspin_lock_irqsave(&ep->lock, flags);\n\tfor (nepi = ep->ovflist; (epi = nepi) != NULL;\n\t     nepi = epi->next, epi->next = EP_UNACTIVE_PTR) {\n\t\tif (!ep_is_linked(&epi->rdllink))\n\t\t\tlist_add_tail(&epi->rdllink, &ep->rdllist);\n\t}\n\tep->ovflist = EP_UNACTIVE_PTR;\n\tlist_splice(&txlist, &ep->rdllist);\n\tif (!list_empty(&ep->rdllist)) {\n\t\tif (waitqueue_active(&ep->wq))\n\t\t\twake_up_locked(&ep->wq);\n\t\tif (waitqueue_active(&ep->poll_wait))\n\t\t\tpwake++;\n\t}\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\tmutex_unlock(&ep->mtx);\n\tif (pwake)\n\t\tep_poll_safewake(&ep->poll_wait);\n\treturn error;\n}", "target": 0}
{"code": "static void nf_tables_commit_release(struct nft_trans *trans)\n{\n\tswitch (trans->msg_type) {\n\tcase NFT_MSG_DELTABLE:\n\t\tnf_tables_table_destroy(&trans->ctx);\n\t\tbreak;\n\tcase NFT_MSG_DELCHAIN:\n\t\tnf_tables_chain_destroy(trans->ctx.chain);\n\t\tbreak;\n\tcase NFT_MSG_DELRULE:\n\t\tnf_tables_rule_destroy(&trans->ctx, nft_trans_rule(trans));\n\t\tbreak;\n\tcase NFT_MSG_DELSET:\n\t\tnft_set_destroy(nft_trans_set(trans));\n\t\tbreak;\n\t}\n\tkfree(trans);\n}", "target": 0}
{"code": "    void Encode(Key, const Value& value) {\n      AddToSummary(Key::key(), Key::Encode(value).size());\n    }", "target": 1}
{"code": "static NTSTATUS smb_unix_read_symlink(connection_struct *conn,\n\t\t\t\tstruct smb_request *req,\n\t\t\t\tstruct smb_filename *smb_fname,\n\t\t\t\tchar *pdata,\n\t\t\t\tunsigned int data_size_in,\n\t\t\t\tunsigned int *pdata_size_out)\n{\n\tNTSTATUS status;\n\tsize_t len = 0;\n\tint link_len = 0;\n\tstruct smb_filename *parent_fname = NULL;\n\tstruct smb_filename *base_name = NULL;\n\tchar *buffer = talloc_array(talloc_tos(), char, PATH_MAX+1);\n\tif (!buffer) {\n\t\treturn NT_STATUS_NO_MEMORY;\n\t}\n\tDBG_DEBUG(\"SMB_QUERY_FILE_UNIX_LINK for file %s\\n\",\n\t\tsmb_fname_str_dbg(smb_fname));\n\tif(!S_ISLNK(smb_fname->st.st_ex_mode)) {\n\t\tTALLOC_FREE(buffer);\n\t\treturn NT_STATUS_DOS(ERRSRV, ERRbadlink);\n\t}\n\tstatus = parent_pathref(talloc_tos(),\n\t\t\t\tconn->cwd_fsp,\n\t\t\t\tsmb_fname,\n\t\t\t\t&parent_fname,\n\t\t\t\t&base_name);\n\tif (!NT_STATUS_IS_OK(status)) {\n\t\tTALLOC_FREE(buffer);\n\t\treturn status;\n\t}\n\tlink_len = SMB_VFS_READLINKAT(conn,\n\t\t\t\tparent_fname->fsp,\n\t\t\t\tbase_name,\n\t\t\t\tbuffer,\n\t\t\t\tPATH_MAX);\n\tTALLOC_FREE(parent_fname);\n\tif (link_len == -1) {\n\t\tTALLOC_FREE(buffer);\n\t\treturn map_nt_error_from_unix(errno);\n\t}\n\tbuffer[link_len] = 0;\n\tstatus = srvstr_push(pdata,\n\t\t\treq->flags2,\n\t\t\tpdata,\n\t\t\tbuffer,\n\t\t\tdata_size_in,\n\t\t\tSTR_TERMINATE,\n\t\t\t&len);\n\tTALLOC_FREE(buffer);\n\tif (!NT_STATUS_IS_OK(status)) {\n\t\treturn status;\n\t}\n\t*pdata_size_out = len;\n\treturn NT_STATUS_OK;\n}", "target": 0}
{"code": "static int file_cb(\n\tconst git_diff_delta *delta,\n\tfloat progress,\n\tvoid *payload)\n{\n\tstruct diff_data *diff_data = payload;\n\tGIT_UNUSED(progress);\n\tif (delta->old_file.path)\n\t\tdiff_data->old_path = git__strdup(delta->old_file.path);\n\tif (delta->new_file.path)\n\t\tdiff_data->new_path = git__strdup(delta->new_file.path);\n\tgit_oid_cpy(&diff_data->old_id, &delta->old_file.id);\n\tgit_oid_cpy(&diff_data->new_id, &delta->new_file.id);\n\treturn 0;\n}", "target": 0}
{"code": "static int addrconf_ifid_ieee1394(u8 *eui, struct net_device *dev)\n{\n\tunion fwnet_hwaddr *ha;\n\tif (dev->addr_len != FWNET_ALEN)\n\t\treturn -1;\n\tha = (union fwnet_hwaddr *)dev->dev_addr;\n\tmemcpy(eui, &ha->uc.uniq_id, sizeof(ha->uc.uniq_id));\n\teui[0] ^= 2;\n\treturn 0;\n}", "target": 0}
{"code": "ikev1_sig_print(netdissect_options *ndo, u_char tpay _U_,\n\t\tconst struct isakmp_gen *ext, u_int item_len _U_,\n\t\tconst u_char *ep _U_, uint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_SIG)));\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_SIG)));\n\treturn NULL;\n}", "target": 0}
{"code": "translate_hex_string(char *s, char *saved_orphan)\n{\n  int c1 = *saved_orphan;\n  char *start = s;\n  char *t = s;\n  for (; *s; s++) {\n    if (isspace(*s))\n      continue;\n    if (c1) {\n      *t++ = (hexval(c1) << 4) + hexval(*s);\n      c1 = 0;\n    } else\n      c1 = *s;\n  }\n  *saved_orphan = c1;\n  return t - start;\n}", "target": 1}
{"code": "void PDPSimple::notifyAboveRemoteEndpoints(\n        const ParticipantProxyData& pdata)\n{\n    if (mp_EDP != nullptr)\n    {\n        mp_EDP->assignRemoteEndpoints(pdata);\n    }\n    if (mp_builtin->mp_WLP != nullptr)\n    {\n        mp_builtin->mp_WLP->assignRemoteEndpoints(pdata);\n    }\n    if (mp_builtin->tlm_ != nullptr)\n    {\n        mp_builtin->tlm_->assign_remote_endpoints(pdata);\n    }\n}", "target": 1}
{"code": "ExtensionInstallDialogView::ExtensionInstallDialogView(\n    Profile* profile,\n    content::PageNavigator* navigator,\n    const ExtensionInstallPrompt::DoneCallback& done_callback,\n    std::unique_ptr<ExtensionInstallPrompt::Prompt> prompt)\n    : profile_(profile),\n      navigator_(navigator),\n      done_callback_(done_callback),\n       prompt_(std::move(prompt)),\n       container_(NULL),\n       scroll_view_(NULL),\n      handled_result_(false) {\n   InitView();\n }", "target": 1}
{"code": "gopherCachable(const HttpRequest * req)\n{\n    int cachable = 1;\n    char type_id;\n    gopher_request_parse(req,\n                         &type_id,\n                         nullptr);\n    switch (type_id) {\n    case GOPHER_INDEX:\n    case GOPHER_CSO:\n    case GOPHER_TELNET:\n    case GOPHER_3270:\n        cachable = 0;\n        break;\n    default:\n        cachable = 1;\n    }\n    return cachable;\n}", "target": 1}
{"code": "bool ReadListValue(const Message* m, PickleIterator* iter,\n                   ListValue* value, int recursion) {\n  int size;\n  if (!ReadParam(m, iter, &size))\n    return false;\n  for (int i = 0; i < size; ++i) {\n    Value* subval;\n    if (!ReadValue(m, iter, &subval, recursion + 1))\n      return false;\n    value->Set(i, subval);\n  }\n  return true;\n}", "target": 0}
{"code": "static void vvc_parse_general_timing_hrd_parameters(GF_BitStream *bs, VVC_SPS *sps, VVC_VPS *vps, Bool *general_nal_hrd_params_present_flag, Bool *general_vcl_hrd_params_present_flag, Bool *general_du_hrd_params_present_flag, u32 *hrd_cpb_cnt_minus1)\n{\n\tsps->has_timing_info = 1;\n\tsps->num_units_in_tick = gf_bs_read_int_log(bs, 32, \"num_units_in_tick\");\n\tsps->time_scale = gf_bs_read_int_log(bs, 32, \"timescale\");\n\t*general_du_hrd_params_present_flag = GF_FALSE;\n\t*general_nal_hrd_params_present_flag = gf_bs_read_int_log(bs, 1, \"general_nal_hrd_params_present_flag\");\n\t*general_vcl_hrd_params_present_flag = gf_bs_read_int_log(bs, 1, \"general_vcl_hrd_params_present_flag\");\n\tif (*general_nal_hrd_params_present_flag || *general_vcl_hrd_params_present_flag) {\n\t\tgf_bs_read_int_log(bs, 1, \"general_same_pic_timing_in_all_ols_flag\");\n\t\t*general_du_hrd_params_present_flag = gf_bs_read_int_log(bs, 1, \"general_du_hrd_params_present_flag\");\n\t\tif (*general_du_hrd_params_present_flag)\n\t\t\tgf_bs_read_int_log(bs, 8, \"tick_divisor_minus2\");\n\t\tgf_bs_read_int_log(bs, 4, \"bit_rate_scale\");\n\t\tgf_bs_read_int_log(bs, 4, \"cpb_size_scale\");\n\t\tif (*general_du_hrd_params_present_flag)\n\t\t\tgf_bs_read_int_log(bs, 4, \"cpb_size_du_scale\");\n\t\t*hrd_cpb_cnt_minus1 = gf_bs_read_ue_log(bs, \"hrd_cpb_cnt_minus1\");\n\t}\n}", "target": 0}
{"code": "static u64 execlists_update_context(struct i915_request *rq)\n{\n\tstruct intel_context *ce = rq->hw_context;\n\tu64 desc = ce->lrc_desc;\n\tu32 tail;\n\ttail = intel_ring_set_tail(rq->ring, rq->tail);\n\tif (unlikely(ce->lrc_reg_state[CTX_RING_TAIL] == tail))\n\t\tdesc |= CTX_DESC_FORCE_RESTORE;\n\tce->lrc_reg_state[CTX_RING_TAIL] = tail;\n\trq->tail = rq->wa_tail;\n\tmb();\n\tif (IS_TGL_REVID(rq->i915, TGL_REVID_A0, TGL_REVID_A0))\n\t\tdesc |= CTX_DESC_FORCE_RESTORE;\n\tce->lrc_desc &= ~CTX_DESC_FORCE_RESTORE;\n\treturn desc;\n}", "target": 0}
{"code": "void exit_mmap(struct mm_struct *mm)\n{\n\tstruct mmu_gather *tlb;\n\tstruct vm_area_struct *vma = mm->mmap;\n\tunsigned long nr_accounted = 0;\n\tunsigned long end;\n\tarch_exit_mmap(mm);\n\tlru_add_drain();\n\tflush_cache_mm(mm);\n\ttlb = tlb_gather_mmu(mm, 1);\n\tend = unmap_vmas(&tlb, vma, 0, -1, &nr_accounted, NULL);\n\tvm_unacct_memory(nr_accounted);\n\tfree_pgtables(&tlb, vma, FIRST_USER_ADDRESS, 0);\n\ttlb_finish_mmu(tlb, 0, end);\n\twhile (vma)\n\t\tvma = remove_vma(vma);\n\tBUG_ON(mm->nr_ptes > (FIRST_USER_ADDRESS+PMD_SIZE-1)>>PMD_SHIFT);\n}", "target": 0}
{"code": "void dev_init_scheduler(struct net_device *dev)\n{\n\tqdisc_lock_tree(dev);\n\tdev->qdisc = &noop_qdisc;\n\tdev->qdisc_sleeping = &noop_qdisc;\n\tINIT_LIST_HEAD(&dev->qdisc_list);\n\tqdisc_unlock_tree(dev);\n\tsetup_timer(&dev->watchdog_timer, dev_watchdog, (unsigned long)dev);\n}", "target": 0}
{"code": "static int unload_module(void)\n{\n\tast_cli_unregister_multiple(cli_identify, ARRAY_LEN(cli_identify));\n\tast_sip_unregister_cli_formatter(cli_formatter);\n\tast_sip_unregister_endpoint_formatter(&endpoint_identify_formatter);\n\tast_sip_unregister_endpoint_identifier(&header_identifier);\n\tast_sip_unregister_endpoint_identifier(&request_identifier);\n\tast_sip_unregister_endpoint_identifier(&ip_identifier);\n\tast_sip_unregister_endpoint_identifier(&transport_identifier);\n\treturn 0;\n}", "target": 1}
{"code": "int ping_init_sock(struct sock *sk)\n{\n\tstruct net *net = sock_net(sk);\n\tkgid_t group = current_egid();\n\tstruct group_info *group_info;\n\tint i, j, count;\n\tkgid_t low, high;\n\tint ret = 0;\n\tif (sk->sk_family == AF_INET6)\n\t\tsk->sk_ipv6only = 1;\n\tinet_get_ping_group_range_net(net, &low, &high);\n\tif (gid_lte(low, group) && gid_lte(group, high))\n\t\treturn 0;\n\tgroup_info = get_current_groups();\n\tcount = group_info->ngroups;\n\tfor (i = 0; i < group_info->nblocks; i++) {\n\t\tint cp_count = min_t(int, NGROUPS_PER_BLOCK, count);\n\t\tfor (j = 0; j < cp_count; j++) {\n\t\t\tkgid_t gid = group_info->blocks[i][j];\n\t\t\tif (gid_lte(low, gid) && gid_lte(gid, high))\n\t\t\t\tgoto out_release_group;\n\t\t}\n\t\tcount -= cp_count;\n\t}\n\tret = -EACCES;\nout_release_group:\n\tput_group_info(group_info);\n\treturn ret;\n}", "target": 0}
{"code": "x509stack_push(struct cert_stack *stack, struct rpki_uri *uri, X509 *x509,\n    enum rpki_policy policy, enum cert_type type)\n{\n\tstruct metadata_node *meta;\n\tstruct repo_level_node *repo, *head_repo;\n\tstruct defer_node *defer_separator;\n\tunsigned int work_repo_level;\n\tint ok;\n\tint error;\n\trepo = malloc(sizeof(struct repo_level_node));\n\tif (repo == NULL)\n\t\treturn pr_enomem();\n\trepo->level = 0;\n\twork_repo_level = working_repo_peek_level();\n\thead_repo = SLIST_FIRST(&stack->levels);\n\tif (head_repo != NULL && work_repo_level > head_repo->level)\n\t\trepo->level = work_repo_level;\n\tSLIST_INSERT_HEAD(&stack->levels, repo, next);\n\tmeta = malloc(sizeof(struct metadata_node));\n\tif (meta == NULL) {\n\t\terror = pr_enomem();\n\t\tgoto end3;\n\t}\n\tmeta->uri = uri;\n\turi_refget(uri);\n\tserial_numbers_init(&meta->serials);\n\tsubjects_init(&meta->subjects);\n\tmeta->resources = resources_create(false);\n\tif (meta->resources == NULL) {\n\t\terror = pr_enomem();\n\t\tgoto end4;\n\t}\n\tresources_set_policy(meta->resources, policy);\n\terror = certificate_get_resources(x509, meta->resources, type);\n\tif (error)\n\t\tgoto end5;\n\tif (type == TA && resources_empty(meta->resources)) {\n\t\terror = pr_val_err(\"Trust Anchor certificate does not define any number resources.\");\n\t\tgoto end5;\n\t}\n\tdefer_separator = malloc(sizeof(struct defer_node));\n\tif (defer_separator == NULL) {\n\t\terror = pr_enomem();\n\t\tgoto end5;\n\t}\n\tdefer_separator->type = DNT_SEPARATOR;\n\tok = sk_X509_push(stack->x509s, x509);\n\tif (ok <= 0) {\n\t\terror = val_crypto_err(\n\t\t    \"Could not add certificate to trusted stack: %d\", ok);\n\t\tgoto end5;\n\t}\n\tSLIST_INSERT_HEAD(&stack->defers, defer_separator, next);\n\tSLIST_INSERT_HEAD(&stack->metas, meta, next);\n\treturn 0;\nend5:\tresources_destroy(meta->resources);\nend4:\tsubjects_cleanup(&meta->subjects, subject_cleanup);\n\tserial_numbers_cleanup(&meta->serials, serial_cleanup);\n\turi_refput(meta->uri);\n\tfree(meta);\nend3:\tSLIST_REMOVE_HEAD(&stack->levels, next);\n\tfree(repo);\n\treturn error;\n}", "target": 1}
{"code": "test_unit_v2v_iter2(VALUE (* conv1)(VALUE),\n\t\t    VALUE (* conv2)(VALUE))\n{\n    if (!test_unit_v2v(INT2FIX(0), conv1, conv2))\n\treturn 0;\n    if (!test_unit_v2v(INT2FIX(1), conv1, conv2))\n\treturn 0;\n    if (!test_unit_v2v(INT2FIX(2), conv1, conv2))\n\treturn 0;\n    if (!test_unit_v2v(INT2FIX(3), conv1, conv2))\n\treturn 0;\n    if (!test_unit_v2v(INT2FIX(11), conv1, conv2))\n\treturn 0;\n    if (!test_unit_v2v(INT2FIX(65535), conv1, conv2))\n\treturn 0;\n    if (!test_unit_v2v(INT2FIX(1073741823), conv1, conv2))\n\treturn 0;\n    if (!test_unit_v2v(INT2NUM(1073741824), conv1, conv2))\n\treturn 0;\n    if (!test_unit_v2v(rb_rational_new2(INT2FIX(0), INT2FIX(1)), conv1, conv2))\n\treturn 0;\n    if (!test_unit_v2v(rb_rational_new2(INT2FIX(1), INT2FIX(1)), conv1, conv2))\n\treturn 0;\n    if (!test_unit_v2v(rb_rational_new2(INT2FIX(1), INT2FIX(2)), conv1, conv2))\n\treturn 0;\n    if (!test_unit_v2v(rb_rational_new2(INT2FIX(2), INT2FIX(3)), conv1, conv2))\n\treturn 0;\n    return 1;\n}", "target": 0}
{"code": "static void copyIPv6IfDifferent(void * dest, const void * src)\n{\n\tif(dest != src) {\n\t\tmemcpy(dest, src, sizeof(struct in6_addr));\n\t}\n}", "target": 1}
{"code": "GF_ItemListBox *gf_ismo_locate_box(GF_List *list, u32 boxType, bin128 UUID)\n{\n\tu32 i;\n\tGF_Box *box;\n\ti=0;\n\twhile ((box = (GF_Box *)gf_list_enum(list, &i))) {\n\t\tif (box->type == boxType) {\n\t\t\tGF_UUIDBox* box2 = (GF_UUIDBox* )box;\n\t\t\tif (boxType != GF_ISOM_BOX_TYPE_UUID) return (GF_ItemListBox *)box;\n\t\t\tif (!memcmp(box2->uuid, UUID, 16)) return (GF_ItemListBox *)box;\n\t\t}\n\t}\n\treturn NULL;", "target": 0}
{"code": "static void blk_mq_delay_work_fn(struct work_struct *work)\n{\n\tstruct blk_mq_hw_ctx *hctx;\n\thctx = container_of(work, struct blk_mq_hw_ctx, delay_work.work);\n\tif (test_and_clear_bit(BLK_MQ_S_STOPPED, &hctx->state))\n\t\t__blk_mq_run_hw_queue(hctx);\n}", "target": 0}
{"code": "EntropyParser::EntropyParser(class Frame *frame,class Scan *scan)\n  : JKeeper(scan->EnvironOf()), m_pScan(scan), m_pFrame(frame)\n{\n  m_ucCount = scan->ComponentsInScan();\n  for(volatile UBYTE i = 0;i < m_ucCount && i < 4;i++) {\n    JPG_TRY {\n      m_pComponent[i] = scan->ComponentOf(i);\n    } JPG_CATCH {\n      m_pComponent[i] = NULL;\n    } JPG_ENDTRY;\n  }\n  m_ulRestartInterval   = m_pFrame->TablesOf()->RestartIntervalOf();\n  m_usNextRestartMarker = 0xffd0;\n  m_ulMCUsToGo          = m_ulRestartInterval;\n  m_bSegmentIsValid     = true;\n  m_bScanForDNL         = (m_pFrame->HeightOf() == 0)?true:false;\n  m_bDNLFound           = false;\n}", "target": 1}
{"code": "void unbind_ports(void) {\n    SERVICE_OPTIONS *opt;\n    s_poll_init(fds, 1);\n    CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_SECTIONS]);\n    opt=service_options.next;\n    service_options.next=NULL;\n    service_free(&service_options);\n    while(opt) {\n        unsigned i;\n        s_log(LOG_DEBUG, \"Unbinding service [%s]\", opt->servname);\n        for(i=0; i<opt->local_addr.num; ++i)\n            unbind_port(opt, i);\n        if(opt->exec_name && opt->connect_addr.names) {\n            opt->option.retry=0;\n        }\n        if(opt->ctx)\n            SSL_CTX_flush_sessions(opt->ctx,\n                (long)time(NULL)+opt->session_timeout+1);\n        s_log(LOG_DEBUG, \"Service [%s] closed\", opt->servname);\n        {\n            SERVICE_OPTIONS *garbage=opt;\n            opt=opt->next;\n            garbage->next=NULL;\n            service_free(garbage);\n        }\n    }\n    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_SECTIONS]);\n}", "target": 1}
{"code": "static void cmd_authinfo_user(char *user)\n{\n    const char *p;\n    if (nntp_authstate) {\n\tprot_printf(nntp_out, \"502 Already authenticated\\r\\n\");\n\treturn;\n    }\n    if (!(nntp_starttls_done || (extprops_ssf > 1) ||\n\t  config_getswitch(IMAPOPT_ALLOWPLAINTEXT))) {\n\tprot_printf(nntp_out,\n\t\t    \"483 AUTHINFO USER command only available under a layer\\r\\n\");\n\treturn;\n    }\n    if (nntp_userid) {\n\tfree(nntp_userid);\n\tnntp_userid = NULL;\n    }\n    if (!(p = canonify_userid(user, NULL, NULL))) {\n\tprot_printf(nntp_out, \"481 Invalid user\\r\\n\");\n\tsyslog(LOG_NOTICE,\n\t       \"badlogin: %s plaintext %s invalid user\",\n\t       nntp_clienthost, beautify_string(user));\n    }\n    else {\n\tnntp_userid = xstrdup(p);\n\tprot_printf(nntp_out, \"381 Give AUTHINFO PASS command\\r\\n\");\n    }\n}", "target": 0}
{"code": "static int dispatch_discard_io(struct xen_blkif *blkif,\n\t\t\t\tstruct blkif_request *req)\n{\n\tint err = 0;\n\tint status = BLKIF_RSP_OKAY;\n\tstruct block_device *bdev = blkif->vbd.bdev;\n\tunsigned long secure;\n\tblkif->st_ds_req++;\n\txen_blkif_get(blkif);\n\tsecure = (blkif->vbd.discard_secure &&\n\t\t (req->u.discard.flag & BLKIF_DISCARD_SECURE)) ?\n\t\t BLKDEV_DISCARD_SECURE : 0;\n\terr = blkdev_issue_discard(bdev, req->u.discard.sector_number,\n\t\t\t\t   req->u.discard.nr_sectors,\n\t\t\t\t   GFP_KERNEL, secure);\n\tif (err == -EOPNOTSUPP) {\n\t\tpr_debug(DRV_PFX \"discard op failed, not supported\\n\");\n\t\tstatus = BLKIF_RSP_EOPNOTSUPP;\n\t} else if (err)\n\t\tstatus = BLKIF_RSP_ERROR;\n\tmake_response(blkif, req->u.discard.id, req->operation, status);\n\txen_blkif_put(blkif);\n\treturn err;\n}", "target": 1}
{"code": "void uwbd_stop(struct uwb_rc *rc)\n{\n\tkthread_stop(rc->uwbd.task);\n\tuwbd_flush(rc);\n}", "target": 1}
{"code": "SessionStartupPref StartupBrowserCreator::GetSessionStartupPref(\n    const base::CommandLine& command_line,\n    Profile* profile) {\n  DCHECK(profile);\n  PrefService* prefs = profile->GetPrefs();\n  SessionStartupPref pref = SessionStartupPref::GetStartupPref(prefs);\n#if defined(OS_CHROMEOS)\n  const bool is_first_run =\n      user_manager::UserManager::Get()->IsCurrentUserNew();\n  const bool did_restart = false;\n  StartupBrowserCreator::WasRestarted();\n#else\n  const bool is_first_run = first_run::IsChromeFirstRun();\n  const bool did_restart = StartupBrowserCreator::WasRestarted();\n#endif\n  if (is_first_run && SessionStartupPref::TypeIsDefault(prefs))\n    pref.type = SessionStartupPref::DEFAULT;\n  if ((command_line.HasSwitch(switches::kRestoreLastSession) || did_restart) &&\n      !profile->IsNewProfile()) {\n    pref.type = SessionStartupPref::LAST;\n  }\n  if (!profile->IsGuestSession()) {\n    ProfileAttributesEntry* entry = nullptr;\n    bool has_entry =\n        g_browser_process->profile_manager()\n            ->GetProfileAttributesStorage()\n            .GetProfileAttributesWithPath(profile->GetPath(), &entry);\n    if (has_entry && entry->IsSigninRequired())\n       pref.type = SessionStartupPref::LAST;\n   }\n  if (pref.type == SessionStartupPref::LAST &&\n      IncognitoModePrefs::ShouldLaunchIncognito(command_line, prefs)) {\n    pref.type = SessionStartupPref::DEFAULT;\n  }\n  return pref;\n}", "target": 1}
{"code": "  bool matches(const Http::RequestHeaderMap& headers) const override {\n    if (BaseMatcherImpl::matchRoute(headers)) {\n      if (headers.Path() == nullptr) {\n        return false;\n      }\n      const Http::HeaderString& path = headers.Path()->value();\n      const absl::string_view query_string = Http::Utility::findQueryStringStart(path);\n      absl::string_view path_view = path.getStringView();\n      path_view.remove_suffix(query_string.length());\n      if (path_matcher_->match(path_view)) {\n        ENVOY_LOG(debug, \"Regex requirement '{}' matched.\", regex_str_);\n        return true;\n      }\n    }\n    return false;\n  }", "target": 0}
{"code": "int phar_tar_setmetadata(zval *metadata, phar_entry_info *entry, char **error TSRMLS_DC) \n{\n\tphp_serialize_data_t metadata_hash;\n\tif (entry->metadata_str.c) {\n\t\tsmart_str_free(&entry->metadata_str);\n\t}\n\tentry->metadata_str.c = 0;\n\tentry->metadata_str.len = 0;\n\tPHP_VAR_SERIALIZE_INIT(metadata_hash);\n\tphp_var_serialize(&entry->metadata_str, &metadata, &metadata_hash TSRMLS_CC);\n\tPHP_VAR_SERIALIZE_DESTROY(metadata_hash);\n\tentry->uncompressed_filesize = entry->compressed_filesize = entry->metadata_str.len;\n\tif (entry->fp && entry->fp_type == PHAR_MOD) {\n\t\tphp_stream_close(entry->fp);\n\t}\n\tentry->fp_type = PHAR_MOD;\n\tentry->is_modified = 1;\n\tentry->fp = php_stream_fopen_tmpfile();\n\tentry->offset = entry->offset_abs = 0;\n\tif (entry->fp == NULL) {\n\t\tspprintf(error, 0, \"phar error: unable to create temporary file\");\n\t\treturn -1;\n\t}\n\tif (entry->metadata_str.len != php_stream_write(entry->fp, entry->metadata_str.c, entry->metadata_str.len)) {\n\t\tspprintf(error, 0, \"phar tar error: unable to write metadata to magic metadata file \\\"%s\\\"\", entry->filename);\n\t\tzend_hash_del(&(entry->phar->manifest), entry->filename, entry->filename_len);\n\t\treturn ZEND_HASH_APPLY_STOP;\n\t}\n\treturn ZEND_HASH_APPLY_KEEP;\n}", "target": 0}
{"code": "static void _gnutls_handshake_internal_state_init(gnutls_session_t session)\n{\n\tsession->internals.adv_version_major = 0;\n\tsession->internals.adv_version_minor = 0;\n\tsession->internals.direction = 0;\n\tsession->internals.last_handshake_in = -1;\n\tsession->internals.last_handshake_out = -1;\n\tsession->internals.resumable = RESUME_TRUE;\n\tsession->internals.handshake_large_loops = 0;\n\tsession->internals.dtls.hsk_read_seq = 0;\n\tsession->internals.dtls.hsk_write_seq = 0;\n}", "target": 1}
{"code": "bits_set(unsigned int *selector, size_t selsize, int *bits)\n{\nfor(; *bits != -1; ++bits)\n  BIT_SET(selector, selsize, *bits);\n}", "target": 0}
{"code": "static int do_one_set_err(struct sock *sk, struct netlink_set_err_data *p)\n{\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\tint ret = 0;\n\tif (sk == p->exclude_sk)\n\t\tgoto out;\n\tif (!net_eq(sock_net(sk), sock_net(p->exclude_sk)))\n\t\tgoto out;\n\tif (nlk->portid == p->portid || p->group - 1 >= nlk->ngroups ||\n\t    !test_bit(p->group - 1, nlk->groups))\n\t\tgoto out;\n\tif (p->code == ENOBUFS && nlk->flags & NETLINK_F_RECV_NO_ENOBUFS) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\tsk->sk_err = p->code;\n\tsk->sk_error_report(sk);\nout:\n\treturn ret;\n}", "target": 0}
{"code": "ssize_t qemu_deliver_packet_iov(NetClientState *sender,\n                                unsigned flags,\n                                const struct iovec *iov,\n                                int iovcnt,\n                                void *opaque)\n{\n    NetClientState *nc = opaque;\n    size_t size = iov_size(iov, iovcnt);\n    int ret;\n    if (size > INT_MAX) {\n        return size;\n    }\n    if (nc->link_down) {\n        return size;\n    }\n    if (nc->receive_disabled) {\n        return 0;\n    }\n    if (nc->info->receive_iov && !(flags & QEMU_NET_PACKET_FLAG_RAW)) {\n        ret = nc->info->receive_iov(nc, iov, iovcnt);\n    } else {\n        ret = nc_sendv_compat(nc, iov, iovcnt, flags);\n    }\n    if (ret == 0) {\n        nc->receive_disabled = 1;\n    }\n    return ret;\n}", "target": 1}
{"code": "void CLASS panasonic_load_raw()\n{\n  int row, col, i, j, sh = 0, pred[2], nonz[2];\n  pana_bits(0);\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < raw_width; col++)\n    {\n      if ((i = col % 14) == 0)\n        pred[0] = pred[1] = nonz[0] = nonz[1] = 0;\n      if (i % 3 == 2)\n        sh = 4 >> (3 - pana_bits(2));\n      if (nonz[i & 1])\n      {\n        if ((j = pana_bits(8)))\n        {\n          if ((pred[i & 1] -= 0x80 << sh) < 0 || sh == 4)\n            pred[i & 1] &= ~((~0u) << sh);\n          pred[i & 1] += j << sh;\n        }\n      }\n      else if ((nonz[i & 1] = pana_bits(8)) || i > 11)\n        pred[i & 1] = nonz[i & 1] << 4 | pana_bits(4);\n      if ((RAW(row, col) = pred[col & 1]) > 4098 && col < width)\n        derror();\n    }\n  }\n}", "target": 1}
{"code": "int flush_old_exec(struct linux_binprm * bprm)\n{\n\tint retval;\n\tretval = de_thread(current);\n\tif (retval)\n\t\tgoto out;\n\tset_mm_exe_file(bprm->mm, bprm->file);\n\tacct_arg_size(bprm, 0);\n\tretval = exec_mmap(bprm->mm);\n\tif (retval)\n\t\tgoto out;\n\tbprm->mm = NULL;\n\tset_fs(USER_DS);\n\tcurrent->flags &= ~(PF_RANDOMIZE | PF_FORKNOEXEC | PF_KTHREAD |\n\t\t\t\t\tPF_NOFREEZE | PF_NO_SETAFFINITY);\n\tflush_thread();\n\tcurrent->personality &= ~bprm->per_clear;\n\tdo_close_on_exec(current->files);\n\treturn 0;\nout:\n\treturn retval;\n}", "target": 0}
{"code": "int sctp_auth_recv_cid(sctp_cid_t chunk, const struct sctp_association *asoc)\n{\n\tif (!sctp_auth_enable || !asoc)\n\t\treturn 0;\n\treturn __sctp_auth_cid(chunk,\n\t\t\t      (struct sctp_chunks_param *)asoc->c.auth_chunks);\n}", "target": 0}
{"code": "static inline __u32 secure_dccpv6_sequence_number(__be32 *saddr, __be32 *daddr,\n\t\t\t\t\t\t  __be16 sport, __be16 dport   )\n{\n\treturn secure_tcpv6_sequence_number(saddr, daddr, sport, dport);\n}", "target": 1}
{"code": "void mark_mounts_for_expiry(struct list_head *mounts)\n{\n\tstruct mount *mnt, *next;\n\tLIST_HEAD(graveyard);\n\tif (list_empty(mounts))\n\t\treturn;\n\tnamespace_lock();\n\tlock_mount_hash();\n\tlist_for_each_entry_safe(mnt, next, mounts, mnt_expire) {\n\t\tif (!xchg(&mnt->mnt_expiry_mark, 1) ||\n\t\t\tpropagate_mount_busy(mnt, 1))\n\t\t\tcontinue;\n\t\tlist_move(&mnt->mnt_expire, &graveyard);\n\t}\n\twhile (!list_empty(&graveyard)) {\n\t\tmnt = list_first_entry(&graveyard, struct mount, mnt_expire);\n\t\ttouch_mnt_namespace(mnt->mnt_ns);\n\t\tumount_tree(mnt, 1);\n\t}\n\tunlock_mount_hash();\n\tnamespace_unlock();\n}", "target": 0}
{"code": "static bool malidp_check_pages_threshold(struct malidp_plane_state *ms,\n\t\t\t\t\t u32 pgsize)\n{\n\tint i;\n\tfor (i = 0; i < ms->n_planes; i++) {\n\t\tstruct drm_gem_object *obj;\n\t\tstruct drm_gem_cma_object *cma_obj;\n\t\tstruct sg_table *sgt;\n\t\tstruct scatterlist *sgl;\n\t\tobj = drm_gem_fb_get_obj(ms->base.fb, i);\n\t\tcma_obj = to_drm_gem_cma_obj(obj);\n\t\tif (cma_obj->sgt)\n\t\t\tsgt = cma_obj->sgt;\n\t\telse\n\t\t\tsgt = obj->funcs->get_sg_table(obj);\n\t\tif (!sgt)\n\t\t\treturn false;\n\t\tsgl = sgt->sgl;\n\t\twhile (sgl) {\n\t\t\tif (sgl->length < pgsize) {\n\t\t\t\tif (!cma_obj->sgt)\n\t\t\t\t\tkfree(sgt);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tsgl = sg_next(sgl);\n\t\t}\n\t\tif (!cma_obj->sgt)\n\t\t\tkfree(sgt);\n\t}\n\treturn true;\n}", "target": 1}
{"code": "static int __btrfs_set_acl(struct btrfs_trans_handle *trans,\n\t\t\t struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint ret, size = 0;\n\tconst char *name;\n\tchar *value = NULL;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tret = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (ret == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EINVAL : 0;\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_KERNEL);\n\t\tif (!value) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tret = __btrfs_setxattr(trans, inode, name, value, size, 0);\nout:\n\tkfree(value);\n\tif (!ret)\n\t\tset_cached_acl(inode, type, acl);\n\treturn ret;\n}", "target": 1}
{"code": "void streamGetEdgeID(stream *s, int first, int skip_tombstones, streamID *edge_id)\n{\n    streamIterator si;\n    int64_t numfields;\n    streamIteratorStart(&si,s,NULL,NULL,!first);\n    si.skip_tombstones = skip_tombstones;\n    int found = streamIteratorGetID(&si,edge_id,&numfields);\n    if (!found) {\n        streamID min_id = {0, 0}, max_id = {UINT64_MAX, UINT64_MAX};\n        *edge_id = first ? max_id : min_id;\n    }\n}", "target": 1}
{"code": "cdf_unpack_header(cdf_header_t *h, char *buf)\n{\n\tsize_t i;\n\tsize_t len = 0;\n\tCDF_UNPACK(h->h_magic);\n\tCDF_UNPACKA(h->h_uuid);\n\tCDF_UNPACK(h->h_revision);\n\tCDF_UNPACK(h->h_version);\n\tCDF_UNPACK(h->h_byte_order);\n\tCDF_UNPACK(h->h_sec_size_p2);\n\tCDF_UNPACK(h->h_short_sec_size_p2);\n\tCDF_UNPACKA(h->h_unused0);\n\tCDF_UNPACK(h->h_num_sectors_in_sat);\n\tCDF_UNPACK(h->h_secid_first_directory);\n\tCDF_UNPACKA(h->h_unused1);\n\tCDF_UNPACK(h->h_min_size_standard_stream);\n\tCDF_UNPACK(h->h_secid_first_sector_in_short_sat);\n\tCDF_UNPACK(h->h_num_sectors_in_short_sat);\n\tCDF_UNPACK(h->h_secid_first_sector_in_master_sat);\n\tCDF_UNPACK(h->h_num_sectors_in_master_sat);\n\tfor (i = 0; i < __arraycount(h->h_master_sat); i++)\n\t\tCDF_UNPACK(h->h_master_sat[i]);\n}", "target": 0}
{"code": "static int snd_ctl_dev_free(struct snd_device *device)\n{\n\tstruct snd_card *card = device->device_data;\n\tstruct snd_kcontrol *control;\n\tdown_write(&card->controls_rwsem);\n\twhile (!list_empty(&card->controls)) {\n\t\tcontrol = snd_kcontrol(card->controls.next);\n\t\tsnd_ctl_remove(card, control);\n\t}\n\tup_write(&card->controls_rwsem);\n\treturn 0;\n}", "target": 0}
{"code": "nfp_abm_u32_knode_replace(struct nfp_abm_link *alink,\n\t\t\t  struct tc_cls_u32_knode *knode,\n\t\t\t  __be16 proto, struct netlink_ext_ack *extack)\n{\n\tstruct nfp_abm_u32_match *match = NULL, *iter;\n\tunsigned int tos_off;\n\tu8 mask, val;\n\tint err;\n\tif (!nfp_abm_u32_check_knode(alink->abm, knode, proto, extack))\n\t\tgoto err_delete;\n\ttos_off = proto == htons(ETH_P_IP) ? 16 : 20;\n\tval = be32_to_cpu(knode->sel->keys[0].val) >> tos_off & 0xff;\n\tmask = be32_to_cpu(knode->sel->keys[0].mask) >> tos_off & 0xff;\n\tlist_for_each_entry(iter, &alink->dscp_map, list) {\n\t\tu32 cmask;\n\t\tif (iter->handle == knode->handle) {\n\t\t\tmatch = iter;\n\t\t\tcontinue;\n\t\t}\n\t\tcmask = iter->mask & mask;\n\t\tif ((iter->val & cmask) == (val & cmask) &&\n\t\t    iter->band != knode->res->classid) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"conflict with already offloaded filter\");\n\t\t\tgoto err_delete;\n\t\t}\n\t}\n\tif (!match) {\n\t\tmatch = kzalloc(sizeof(*match), GFP_KERNEL);\n\t\tif (!match)\n\t\t\treturn -ENOMEM;\n\t\tlist_add(&match->list, &alink->dscp_map);\n\t}\n\tmatch->handle = knode->handle;\n\tmatch->band = knode->res->classid;\n\tmatch->mask = mask;\n\tmatch->val = val;\n\terr = nfp_abm_update_band_map(alink);\n\tif (err)\n\t\tgoto err_delete;\n\treturn 0;\nerr_delete:\n\tnfp_abm_u32_knode_delete(alink, knode);\n\treturn -EOPNOTSUPP;\n}", "target": 1}
{"code": "static void bnx2x_after_function_update(struct bnx2x *bp)\n{\n\tint q, rc;\n\tstruct bnx2x_fastpath *fp;\n\tstruct bnx2x_queue_state_params queue_params = {NULL};\n\tstruct bnx2x_queue_update_params *q_update_params =\n\t\t&queue_params.params.update;\n\tqueue_params.cmd = BNX2X_Q_CMD_UPDATE;\n\t__set_bit(BNX2X_Q_UPDATE_SILENT_VLAN_REM_CHNG,\n\t\t  &q_update_params->update_flags);\n\t__set_bit(BNX2X_Q_UPDATE_SILENT_VLAN_REM,\n\t\t  &q_update_params->update_flags);\n\t__set_bit(RAMROD_COMP_WAIT, &queue_params.ramrod_flags);\n\tif (bp->afex_vlan_mode == FUNC_MF_CFG_AFEX_VLAN_ACCESS_MODE) {\n\t\tq_update_params->silent_removal_value = 0;\n\t\tq_update_params->silent_removal_mask = 0;\n\t} else {\n\t\tq_update_params->silent_removal_value =\n\t\t\t(bp->afex_def_vlan_tag & VLAN_VID_MASK);\n\t\tq_update_params->silent_removal_mask = VLAN_VID_MASK;\n\t}\n\tfor_each_eth_queue(bp, q) {\n\t\tfp = &bp->fp[q];\n\t\tqueue_params.q_obj = &bnx2x_sp_obj(bp, fp).q_obj;\n\t\trc = bnx2x_queue_state_change(bp, &queue_params);\n\t\tif (rc < 0)\n\t\t\tBNX2X_ERR(\"Failed to config silent vlan rem for Q %d\\n\",\n\t\t\t\t  q);\n\t}\n\tif (!NO_FCOE(bp) && CNIC_ENABLED(bp)) {\n\t\tfp = &bp->fp[FCOE_IDX(bp)];\n\t\tqueue_params.q_obj = &bnx2x_sp_obj(bp, fp).q_obj;\n\t\t__clear_bit(RAMROD_COMP_WAIT, &queue_params.ramrod_flags);\n\t\tsmp_mb__before_atomic();\n\t\tset_bit(BNX2X_AFEX_FCOE_Q_UPDATE_PENDING, &bp->sp_state);\n\t\tsmp_mb__after_atomic();\n\t\trc = bnx2x_queue_state_change(bp, &queue_params);\n\t\tif (rc < 0)\n\t\t\tBNX2X_ERR(\"Failed to config silent vlan rem for Q %d\\n\",\n\t\t\t\t  q);\n\t} else {\n\t\tbnx2x_link_report(bp);\n\t\tbnx2x_fw_command(bp, DRV_MSG_CODE_AFEX_VIFSET_ACK, 0);\n\t}\n}", "target": 0}
{"code": "void ZlibInStream::deinit()\n{\n  assert(zs != NULL);\n  removeUnderlying();\n  inflateEnd(zs);\n  delete zs;\n  zs = NULL;\n}", "target": 1}
{"code": "xmlDocPtr soap_xmlParseFile(const char *filename TSRMLS_DC)\n{\n\txmlParserCtxtPtr ctxt = NULL;\n\txmlDocPtr ret;\n\tzend_bool old_allow_url_fopen;\n\told_allow_url_fopen = PG(allow_url_fopen);\n\tPG(allow_url_fopen) = 1;\n\tctxt = xmlCreateFileParserCtxt(filename);\n\tPG(allow_url_fopen) = old_allow_url_fopen;\n\tif (ctxt) {\n\t\tzend_bool old;\n\t\tctxt->keepBlanks = 0;\n\t\tctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n\t\tctxt->sax->comment = soap_Comment;\n\t\tctxt->sax->warning = NULL;\n\t\tctxt->sax->error = NULL;\n\t\told = php_libxml_disable_entity_loader(1);\n\t\txmlParseDocument(ctxt);\n\t\tphp_libxml_disable_entity_loader(old);\n\t\tif (ctxt->wellFormed) {\n\t\t\tret = ctxt->myDoc;\n\t\t\tif (ret->URL == NULL && ctxt->directory != NULL) {\n\t\t\t\tret->URL = xmlCharStrdup(ctxt->directory);\n\t\t\t}\n\t\t} else {\n\t\t\tret = NULL;\n\t\t\txmlFreeDoc(ctxt->myDoc);\n\t\t\tctxt->myDoc = NULL;\n\t\t}\n\t\txmlFreeParserCtxt(ctxt);\n\t} else {\n\t\tret = NULL;\n\t}\n\tif (ret) {\n\t\tcleanup_xml_node((xmlNodePtr)ret);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static inline void skb_set_network_header(struct sk_buff *skb, const int offset)\n{\n\tskb->network_header = skb->data + offset;\n}", "target": 0}
{"code": "static inline void ConvertXYZToRGB(const double X,const double Y,const double Z,\n  double *red,double *green,double *blue)\n{\n  double\n    b,\n    g,\n    r;\n  assert(red != (double *) NULL);\n  assert(green != (double *) NULL);\n  assert(blue != (double *) NULL);\n  r=3.2404542*X-1.5371385*Y-0.4985314*Z;\n  g=(-0.9692660)*X+1.8760108*Y+0.0415560*Z;\n  b=0.0556434*X-0.2040259*Y+1.0572252*Z;\n  *red=EncodePixelGamma(QuantumRange*r);\n  *green=EncodePixelGamma(QuantumRange*g);\n  *blue=EncodePixelGamma(QuantumRange*b);\n}", "target": 0}
{"code": "wsemul_vt100_output_csi(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tu_int newstate = VT100_EMUL_STATE_CSI;\n\tint oargs;\n\tint rc = 0;\n\tswitch (instate->inchar) {\n\tcase '0': case '1': case '2': case '3': case '4':\n\tcase '5': case '6': case '7': case '8': case '9':\n\t\tif (edp->nargs > VT100_EMUL_NARGS - 1)\n\t\t\tbreak;\n\t\tedp->args[edp->nargs] = (edp->args[edp->nargs] * 10) +\n\t\t    (instate->inchar - '0');\n\t\tbreak;\n\tcase ';': \n\t\tedp->nargs++;\n\t\tbreak;\n\tcase '?': \n\tcase '>': \n\t\tedp->modif1 = (char)instate->inchar;\n\t\tbreak;\n\tcase '!':\n\tcase '\"':\n\tcase '$':\n\tcase '&':\n\t\tedp->modif2 = (char)instate->inchar;\n\t\tbreak;\n\tdefault: \n\t\toargs = edp->nargs++;\n\t\tif (edp->nargs > VT100_EMUL_NARGS) {\n#ifdef VT100_DEBUG\n\t\t\tprintf(\"vt100: too many arguments\\n\");\n#endif\n\t\t\tedp->nargs = VT100_EMUL_NARGS;\n\t\t}\n\t\trc = wsemul_vt100_handle_csi(edp, instate);\n\t\tif (rc != 0) {\n\t\t\tedp->nargs = oargs;\n\t\t\treturn rc;\n\t\t}\n\t\tnewstate = VT100_EMUL_STATE_NORMAL;\n\t\tbreak;\n\t}\n\tif (COLS_LEFT != 0)\n\t\tedp->flags &= ~VTFL_LASTCHAR;\n\tedp->state = newstate;\n\treturn 0;\n}", "target": 1}
{"code": "static int adpt_i2o_install_device(adpt_hba* pHba, struct i2o_device *d)\n{\n\tmutex_lock(&adpt_configuration_lock);\n\td->controller=pHba;\n\td->owner=NULL;\n\td->next=pHba->devices;\n\td->prev=NULL;\n\tif (pHba->devices != NULL){\n\t\tpHba->devices->prev=d;\n\t}\n\tpHba->devices=d;\n\t*d->dev_name = 0;\n\tmutex_unlock(&adpt_configuration_lock);\n\treturn 0;\n}", "target": 1}
{"code": "static int get_vmx_mem_address(struct kvm_vcpu *vcpu,\n\t\t\t\t unsigned long exit_qualification,\n\t\t\t\t u32 vmx_instruction_info, gva_t *ret)\n{\n\tint  scaling = vmx_instruction_info & 3;\n\tint  addr_size = (vmx_instruction_info >> 7) & 7;\n\tbool is_reg = vmx_instruction_info & (1u << 10);\n\tint  seg_reg = (vmx_instruction_info >> 15) & 7;\n\tint  index_reg = (vmx_instruction_info >> 18) & 0xf;\n\tbool index_is_valid = !(vmx_instruction_info & (1u << 22));\n\tint  base_reg       = (vmx_instruction_info >> 23) & 0xf;\n\tbool base_is_valid  = !(vmx_instruction_info & (1u << 27));\n\tif (is_reg) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\t*ret = vmx_get_segment_base(vcpu, seg_reg);\n\tif (base_is_valid)\n\t\t*ret += kvm_register_read(vcpu, base_reg);\n\tif (index_is_valid)\n\t\t*ret += kvm_register_read(vcpu, index_reg)<<scaling;\n\t*ret += exit_qualification; \n\tif (addr_size == 1) \n\t\t*ret &= 0xffffffff;\n\treturn 0;\n}", "target": 0}
{"code": "static void __rfcomm_sock_close(struct sock *sk)\n{\n\tstruct rfcomm_dlc *d = rfcomm_pi(sk)->dlc;\n\tBT_DBG(\"sk %p state %d socket %p\", sk, sk->sk_state, sk->sk_socket);\n\tswitch (sk->sk_state) {\n\tcase BT_LISTEN:\n\t\trfcomm_sock_cleanup_listen(sk);\n\t\tbreak;\n\tcase BT_CONNECT:\n\tcase BT_CONNECT2:\n\tcase BT_CONFIG:\n\tcase BT_CONNECTED:\n\t\trfcomm_dlc_close(d, 0);\n\tdefault:\n\t\tsock_set_flag(sk, SOCK_ZAPPED);\n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "InlineBox* InlineFlowBox::firstLeafChild() const\n{\n    InlineBox* leaf = 0;\n    for (InlineBox* child = firstChild(); child && !leaf; child = child->nextOnLine())\n        leaf = child->isLeaf() ? child : static_cast<InlineFlowBox*>(child)->firstLeafChild();\n    return leaf;\n}", "target": 0}
{"code": "read_password(FILE *in, FILE *out, char *buf, size_t bufsz)\n{\n\tint infd = fileno(in);\n\tstruct termios tio;\n\tchar *ret;\n\tret = fgets(buf, bufsz, in);\n\tif (isatty(infd)) {\n\t\tfprintf(out, \"\\n\");\n\t\tfflush(out);\n\t\ttcgetattr(infd, &tio);\n\t\ttio.c_lflag |= ECHO;\n\t\ttcsetattr(infd, TCSAFLUSH, &tio);\n\t}\n\tif (ret == NULL)\n\t\treturn -1;\n\tbuf[strlen(buf)-1] = '\\0';\n\treturn 0;\n}", "target": 0}
{"code": "dirserv_cache_measured_bw(const measured_bw_line_t *parsed_line,\n                          time_t as_of)\n{\n  mbw_cache_entry_t *e = NULL;\n  tor_assert(parsed_line);\n  if (!mbw_cache) mbw_cache = digestmap_new();\n  e = digestmap_get(mbw_cache, parsed_line->node_id);\n  if (e) {\n    if (as_of > e->as_of) {\n      e->mbw_kb = parsed_line->bw_kb;\n      e->as_of = as_of;\n    }\n  } else {\n    e = tor_malloc(sizeof(*e));\n    e->mbw_kb = parsed_line->bw_kb;\n    e->as_of = as_of;\n    digestmap_set(mbw_cache, parsed_line->node_id, e);\n  }\n}", "target": 0}
{"code": "static int checksum_setup(struct net_device *dev, struct sk_buff *skb)\n{\n\tbool recalculate_partial_csum = false;\n\tif (skb->ip_summed != CHECKSUM_PARTIAL && skb_is_gso(skb)) {\n\t\tstruct netfront_info *np = netdev_priv(dev);\n\t\tatomic_inc(&np->rx_gso_checksum_fixup);\n\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\trecalculate_partial_csum = true;\n\t}\n\tif (skb->ip_summed != CHECKSUM_PARTIAL)\n\t\treturn 0;\n\treturn skb_checksum_setup(skb, recalculate_partial_csum);\n}", "target": 0}
{"code": "snmp_api_set_oid(snmp_varbind_t *varbind, uint32_t *oid, uint32_t *ret_oid)\n{\n  snmp_api_replace_oid(varbind, oid);\n  varbind->value_type = BER_DATA_TYPE_OID;\n  varbind->value.oid = ret_oid;\n}", "target": 1}
{"code": "int __fastcall BatchSettings(TConsole * Console, TProgramParams * Params)\n{\n  int Result = RESULT_SUCCESS;\n  try\n  {\n    std::unique_ptr<TStrings> Arguments(new TStringList());\n    if (!DebugAlwaysTrue(Params->FindSwitch(L\"batchsettings\", Arguments.get())))\n    {\n      Abort();\n    }\n    else\n    {\n      if (Arguments->Count < 1)\n      {\n        throw Exception(LoadStr(BATCH_SET_NO_MASK));\n      }\n      else if (Arguments->Count < 2)\n      {\n        throw Exception(LoadStr(BATCH_SET_NO_SETTINGS));\n      }\n      else\n      {\n        TFileMasks Mask(Arguments->Strings[0]);\n        Arguments->Delete(0);\n        std::unique_ptr<TOptionsStorage> OptionsStorage(new TOptionsStorage(Arguments.get(), false));\n        int Matches = 0;\n        int Changes = 0;\n        for (int Index = 0; Index < StoredSessions->Count; Index++)\n        {\n          TSessionData * Data = StoredSessions->Sessions[Index];\n          if (!Data->IsWorkspace &&\n              Mask.Matches(Data->Name, false, false))\n          {\n            Matches++;\n            std::unique_ptr<TSessionData> OriginalData(new TSessionData(L\"\"));\n            OriginalData->CopyDataNoRecrypt(Data);\n            Data->ApplyRawSettings(OptionsStorage.get());\n            bool Changed = !OriginalData->IsSame(Data, false);\n            if (Changed)\n            {\n              Changes++;\n            }\n            UnicodeString StateStr = LoadStr(Changed ? BATCH_SET_CHANGED : BATCH_SET_NOT_CHANGED);\n            Console->PrintLine(FORMAT(L\"%s - %s\", (Data->Name, StateStr)));\n          }\n        }\n        StoredSessions->Save(false, true); \n        Console->PrintLine(FMTLOAD(BATCH_SET_SUMMARY, (Matches, Changes)));\n      }\n    }\n  }\n  catch (Exception & E)\n  {\n    Result = HandleException(Console, E);\n  }\n  Console->WaitBeforeExit();\n  return Result;\n}", "target": 1}
{"code": "static int bio_copy_to_iter(struct bio *bio, struct iov_iter iter)\n{\n\tstruct bio_vec *bvec;\n\tstruct bvec_iter_all iter_all;\n\tbio_for_each_segment_all(bvec, bio, iter_all) {\n\t\tssize_t ret;\n\t\tret = copy_page_to_iter(bvec->bv_page,\n\t\t\t\t\tbvec->bv_offset,\n\t\t\t\t\tbvec->bv_len,\n\t\t\t\t\t&iter);\n\t\tif (!iov_iter_count(&iter))\n\t\t\tbreak;\n\t\tif (ret < bvec->bv_len)\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "matchCurrentInput(\n\t\tconst InString *input, int pos, const widechar *passInstructions, int passIC) {\n\tint k;\n\tint kk = pos;\n\tfor (k = passIC + 2; k < passIC + 2 + passInstructions[passIC + 1]; k++)\n\t\tif (input->chars[kk] == ENDSEGMENT || passInstructions[k] != input->chars[kk++])\n\t\t\treturn 0;\n\treturn 1;\n}", "target": 1}
{"code": "void HTMLInputElement::defaultEventHandler(Event* evt)\n{\n    if (evt->isMouseEvent() && evt->type() == EventTypeNames::click && toMouseEvent(evt)->button() == LeftButton) {\n        m_inputTypeView->handleClickEvent(toMouseEvent(evt));\n        if (evt->defaultHandled())\n            return;\n    }\n    if (evt->isTouchEvent()) {\n        m_inputTypeView->handleTouchEvent(toTouchEvent(evt));\n        if (evt->defaultHandled())\n            return;\n    }\n    if (evt->isKeyboardEvent() && evt->type() == EventTypeNames::keydown) {\n        m_inputTypeView->handleKeydownEvent(toKeyboardEvent(evt));\n        if (evt->defaultHandled())\n            return;\n    }\n    bool callBaseClassEarly = isTextField() && (evt->type() == EventTypeNames::keydown || evt->type() == EventTypeNames::keypress);\n    if (callBaseClassEarly) {\n        HTMLTextFormControlElement::defaultEventHandler(evt);\n        if (evt->defaultHandled())\n            return;\n    }\n    if (evt->type() == EventTypeNames::DOMActivate) {\n        m_inputType->handleDOMActivateEvent(evt);\n        if (evt->defaultHandled())\n            return;\n    }\n    if (evt->isKeyboardEvent() && evt->type() == EventTypeNames::keypress) {\n        m_inputTypeView->handleKeypressEvent(toKeyboardEvent(evt));\n        if (evt->defaultHandled())\n            return;\n    }\n    if (evt->isKeyboardEvent() && evt->type() == EventTypeNames::keyup) {\n        m_inputTypeView->handleKeyupEvent(toKeyboardEvent(evt));\n        if (evt->defaultHandled())\n            return;\n    }\n    if (m_inputTypeView->shouldSubmitImplicitly(evt)) {\n        if (isSearchField())\n            onSearch();\n        if (wasChangedSinceLastFormControlChangeEvent())\n            dispatchFormControlChangeEvent();\n        RefPtr<HTMLFormElement> formForSubmission = m_inputTypeView->formForSubmission();\n        if (formForSubmission)\n            formForSubmission->submitImplicitly(evt, canTriggerImplicitSubmission());\n        evt->setDefaultHandled();\n        return;\n    }\n    if (evt->isBeforeTextInsertedEvent())\n        m_inputTypeView->handleBeforeTextInsertedEvent(static_cast<BeforeTextInsertedEvent*>(evt));\n    if (evt->isMouseEvent() && evt->type() == EventTypeNames::mousedown) {\n        m_inputTypeView->handleMouseDownEvent(toMouseEvent(evt));\n        if (evt->defaultHandled())\n            return;\n    }\n    m_inputTypeView->forwardEvent(evt);\n    if (!callBaseClassEarly && !evt->defaultHandled())\n        HTMLTextFormControlElement::defaultEventHandler(evt);\n}", "target": 0}
{"code": "static int partition_get_logical_type(blkid_partition par)\n{\n\tblkid_parttable tab;\n\tif (!par)\n\t\treturn -1;\n\ttab = blkid_partition_get_table(par);\n\tif (!tab || !tab->type)\n\t\treturn -1;\n\tif (tab->parent)\n\t\treturn 'L';  \n\tif (!strcmp(tab->type, \"dos\")) {\n\t\tif (par->partno > 4)\n\t\t\treturn 'L';\t\n\t        if(par->type == MBR_DOS_EXTENDED_PARTITION ||\n                   par->type == MBR_W95_EXTENDED_PARTITION ||\n\t\t   par->type == MBR_LINUX_EXTENDED_PARTITION)\n\t\t\treturn 'E';\n\t}\n\treturn 'P';\n}", "target": 0}
{"code": "ScriptProcessorNode* BaseAudioContext::createScriptProcessor(\n    uint32_t buffer_size,\n    uint32_t number_of_input_channels,\n    ExceptionState& exception_state) {\n  DCHECK(IsMainThread());\n  return ScriptProcessorNode::Create(*this, buffer_size,\n                                     number_of_input_channels, exception_state);\n}", "target": 0}
{"code": "static void initialize_typed_array_from_array_buffer(GlobalObject& global_object, TypedArrayBase& typed_array, ArrayBuffer& array_buffer, Value byte_offset, Value length)\n{\n    auto& vm = global_object.vm();\n    auto element_size = typed_array.element_size();\n    auto offset = byte_offset.to_index(global_object);\n    if (vm.exception())\n        return;\n    if (offset % element_size != 0) {\n        vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayInvalidByteOffset, typed_array.class_name(), element_size, offset);\n        return;\n    }\n    size_t new_length { 0 };\n    if (!length.is_undefined()) {\n        new_length = length.to_index(global_object);\n        if (vm.exception())\n            return;\n    }\n    auto buffer_byte_length = array_buffer.byte_length();\n    size_t new_byte_length;\n    if (length.is_undefined()) {\n        if (buffer_byte_length % element_size != 0) {\n            vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayInvalidBufferLength, typed_array.class_name(), element_size, buffer_byte_length);\n            return;\n        }\n        if (offset > buffer_byte_length) {\n            vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayOutOfRangeByteOffset, offset, buffer_byte_length);\n            return;\n        }\n        new_byte_length = buffer_byte_length - offset;\n    } else {\n        new_byte_length = new_length * element_size;\n        if (offset + new_byte_length > buffer_byte_length) {\n            vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayOutOfRangeByteOffsetOrLength, offset, offset + new_byte_length, buffer_byte_length);\n            return;\n        }\n    }\n    typed_array.set_viewed_array_buffer(&array_buffer);\n    typed_array.set_byte_length(new_byte_length);\n    typed_array.set_byte_offset(offset);\n    typed_array.set_array_length(new_byte_length / element_size);\n}", "target": 1}
{"code": "static RBinSection *bin_section_from_segment(RCoreSymCacheElementSegment *seg) {\n\tif (!seg->name) {\n\t\treturn NULL;\n\t}\n\tRBinSection *s = R_NEW0 (RBinSection);\n\tif (!s) {\n\t\treturn NULL;\n\t}\n\ts->name = r_str_ndup (seg->name, 16);\n\ts->size = seg->size;\n\ts->vsize = seg->vsize;\n\ts->paddr = seg->paddr;\n\ts->vaddr = seg->vaddr;\n\ts->add = true;\n\ts->perm = strstr (s->name, \"TEXT\") ? 5 : 4;\n\ts->is_segment = true;\n\treturn s;\n}", "target": 0}
{"code": "static void singlevar (LexState *ls, expdesc *var) {\n  TString *varname = str_checkname(ls);\n  FuncState *fs = ls->fs;\n  singlevaraux(fs, varname, var, 1);\n  if (var->k == VVOID) {  \n    expdesc key;\n    singlevaraux(fs, ls->envn, var, 1);  \n    lua_assert(var->k != VVOID);  \n    codestring(&key, varname);  \n    luaK_indexed(fs, var, &key);  \n  }\n}", "target": 1}
{"code": "init_ext2_xattr(void)\n{\n\treturn 0;\n}", "target": 1}
{"code": "int setup_tests(void)\n{\n    ADD_ALL_TESTS(call_run_cert, OSSL_NELEM(name_fns));\n    return 1;\n}", "target": 1}
{"code": "static struct ion_handle *ion_handle_get_by_id(struct ion_client *client,\n\t\t\t\t\t\tint id)\n{\n\tstruct ion_handle *handle;\n\tmutex_lock(&client->lock);\n\thandle = idr_find(&client->idr, id);\n\tif (handle)\n\t\tion_handle_get(handle);\n\tmutex_unlock(&client->lock);\n\treturn handle ? handle : ERR_PTR(-EINVAL);\n}", "target": 1}
{"code": "gplotAddPlot(GPLOT       *gplot,\n             NUMA        *nax,\n             NUMA        *nay,\n             l_int32      plotstyle,\n             const char  *plottitle)\n{\nchar       buf[L_BUF_SIZE];\nchar       emptystring[] = \"\";\nchar      *datastr, *title;\nl_int32    n, i;\nl_float32  valx, valy, startx, delx;\nSARRAY    *sa;\n    PROCNAME(\"gplotAddPlot\");\n    if (!gplot)\n        return ERROR_INT(\"gplot not defined\", procName, 1);\n    if (!nay)\n        return ERROR_INT(\"nay not defined\", procName, 1);\n    if (plotstyle < 0 || plotstyle >= NUM_GPLOT_STYLES)\n        return ERROR_INT(\"invalid plotstyle\", procName, 1);\n    if ((n = numaGetCount(nay)) == 0)\n        return ERROR_INT(\"no points to plot\", procName, 1);\n    if (nax && (n != numaGetCount(nax)))\n        return ERROR_INT(\"nax and nay sizes differ\", procName, 1);\n    if (n == 1 && plotstyle == GPLOT_LINES) {\n        L_INFO(\"only 1 pt; changing style to points\\n\", procName);\n        plotstyle = GPLOT_POINTS;\n    }\n    numaGetParameters(nay, &startx, &delx);\n    numaAddNumber(gplot->plotstyles, plotstyle);\n    if (plottitle) {\n        title = stringNew(plottitle);\n        sarrayAddString(gplot->plottitles, title, L_INSERT);\n    } else {\n        sarrayAddString(gplot->plottitles, emptystring, L_COPY);\n    }\n    gplot->nplots++;\n    snprintf(buf, L_BUF_SIZE, \"%s.data.%d\", gplot->rootname, gplot->nplots);\n    sarrayAddString(gplot->datanames, buf, L_COPY);\n    sa = sarrayCreate(n);\n    for (i = 0; i < n; i++) {\n        if (nax)\n            numaGetFValue(nax, i, &valx);\n        else\n            valx = startx + i * delx;\n        numaGetFValue(nay, i, &valy);\n        snprintf(buf, L_BUF_SIZE, \"%f %f\\n\", valx, valy);\n        sarrayAddString(sa, buf, L_COPY);\n    }\n    datastr = sarrayToString(sa, 0);\n    sarrayAddString(gplot->plotdata, datastr, L_INSERT);\n    sarrayDestroy(&sa);\n    return 0;\n}", "target": 1}
{"code": "void mark_progress(struct st_command* command __attribute__((unused)),\n                   int line)\n{\n  static ulonglong progress_start= 0; \n  DYNAMIC_STRING ds_progress;\n  char buf[32], *end;\n  ulonglong timer= timer_now();\n  if (!progress_start)\n    progress_start= timer;\n  timer-= progress_start;\n  if (init_dynamic_string(&ds_progress, \"\", 256, 256))\n    die(\"Out of memory\");\n  end= longlong10_to_str(timer, buf, 10);\n  dynstr_append_mem(&ds_progress, buf, (int)(end-buf));\n  dynstr_append_mem(&ds_progress, \"\\t\", 1);\n  end= int10_to_str(line, buf, 10);\n  dynstr_append_mem(&ds_progress, buf, (int)(end-buf));\n  dynstr_append_mem(&ds_progress, \"\\t\", 1);\n  dynstr_append(&ds_progress, cur_file->file_name);\n  dynstr_append_mem(&ds_progress, \":\", 1);\n  end= int10_to_str(cur_file->lineno, buf, 10);\n  dynstr_append_mem(&ds_progress, buf, (int)(end-buf));\n  dynstr_append_mem(&ds_progress, \"\\n\", 1);\n  progress_file.write(&ds_progress);\n  dynstr_free(&ds_progress);\n}", "target": 0}
{"code": "static void listdir(unsigned int depth, int f, void * const tls_fd,\n                    const char *name)\n{\n    PureFileInfo *dir;\n    char *names;\n    PureFileInfo *s;\n    PureFileInfo *r;\n    int d;\n    if (depth >= max_ls_depth || matches >= max_ls_files) {\n        return;\n    }\n    if ((dir = sreaddir(&names)) == NULL) {\n        addreply(226, MSG_CANT_READ_FILE, name);\n        return;\n    }\n    s = dir;\n    while (s->name_offset != (size_t) -1) {\n        d = 0;\n        if (FI_NAME(s)[0] != '.') {\n            d = listfile(s, NULL);\n        } else if (opt_a) {\n            if (FI_NAME(s)[1] == 0 ||\n                (FI_NAME(s)[1] == '.' && FI_NAME(s)[2] == 0)) {\n                listfile(s, NULL);\n            } else {\n                d = listfile(s, NULL);\n            }\n        }\n        if (!d) {\n            s->name_offset = (size_t) -1;\n        }\n        s++;\n    }\n    outputfiles(f, tls_fd);\n    r = dir;\n    while (opt_R && r != s) {\n        if (r->name_offset != (size_t) -1 && !chdir(FI_NAME(r))) {\n            char *alloca_subdir;\n            const size_t sizeof_subdir = PATH_MAX + 1U;\n            if ((alloca_subdir = ALLOCA(sizeof_subdir)) == NULL) {\n                goto toomany;\n            }\n            if (SNCHECK(snprintf(alloca_subdir, sizeof_subdir, \"%s/%s\",\n                                 name, FI_NAME(r)), sizeof_subdir)) {\n                goto nolist;\n            }\n            wrstr(f, tls_fd, \"\\r\\n\\r\\n\");\n            wrstr(f, tls_fd, alloca_subdir);\n            wrstr(f, tls_fd, \":\\r\\n\\r\\n\");\n            listdir(depth + 1U, f, tls_fd, alloca_subdir);\n            nolist:\n            ALLOCA_FREE(alloca_subdir);\n            if (matches >= max_ls_files) {\n                goto toomany;\n            }\n            if (chdir(\"..\")) {    \n                if (chdir(wd) || chdir(name)) {    \n                    die(421, LOG_ERR, \"chdir: %s\", strerror(errno));\n                }\n            }\n        }\n        r++;\n    }\n    toomany:\n    free(names);\n    free(dir);\n    names = NULL;\n}", "target": 1}
{"code": "static int nft_verdict_init(const struct nft_ctx *ctx, struct nft_data *data,\n\t\t\t    struct nft_data_desc *desc, const struct nlattr *nla)\n{\n\tu8 genmask = nft_genmask_next(ctx->net);\n\tstruct nlattr *tb[NFTA_VERDICT_MAX + 1];\n\tstruct nft_chain *chain;\n\tint err;\n\terr = nla_parse_nested_deprecated(tb, NFTA_VERDICT_MAX, nla,\n\t\t\t\t\t  nft_verdict_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\tif (!tb[NFTA_VERDICT_CODE])\n\t\treturn -EINVAL;\n\tdata->verdict.code = ntohl(nla_get_be32(tb[NFTA_VERDICT_CODE]));\n\tswitch (data->verdict.code) {\n\tdefault:\n\t\tswitch (data->verdict.code & NF_VERDICT_MASK) {\n\t\tcase NF_ACCEPT:\n\t\tcase NF_DROP:\n\t\tcase NF_QUEUE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfallthrough;\n\tcase NFT_CONTINUE:\n\tcase NFT_BREAK:\n\tcase NFT_RETURN:\n\t\tbreak;\n\tcase NFT_JUMP:\n\tcase NFT_GOTO:\n\t\tif (tb[NFTA_VERDICT_CHAIN]) {\n\t\t\tchain = nft_chain_lookup(ctx->net, ctx->table,\n\t\t\t\t\t\t tb[NFTA_VERDICT_CHAIN],\n\t\t\t\t\t\t genmask);\n\t\t} else if (tb[NFTA_VERDICT_CHAIN_ID]) {\n\t\t\tchain = nft_chain_lookup_byid(ctx->net, ctx->table,\n\t\t\t\t\t\t      tb[NFTA_VERDICT_CHAIN_ID]);\n\t\t\tif (IS_ERR(chain))\n\t\t\t\treturn PTR_ERR(chain);\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (IS_ERR(chain))\n\t\t\treturn PTR_ERR(chain);\n\t\tif (nft_is_base_chain(chain))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (desc->flags & NFT_DATA_DESC_SETELEM &&\n\t\t    chain->flags & NFT_CHAIN_BINDING)\n\t\t\treturn -EINVAL;\n\t\tchain->use++;\n\t\tdata->verdict.chain = chain;\n\t\tbreak;\n\t}\n\tdesc->len = sizeof(data->verdict);\n\treturn 0;\n}", "target": 1}
{"code": "void ssl_set_client_disabled(SSL *s)\n\t{\n\tCERT *c = s->cert;\n\tconst unsigned char *sigalgs;\n\tsize_t i, sigalgslen;\n\tint have_rsa = 0, have_dsa = 0, have_ecdsa = 0;\n\tc->mask_a = 0;\n\tc->mask_k = 0;\n\tif (!SSL_CLIENT_USE_TLS1_2_CIPHERS(s))\n\t\tc->mask_ssl = SSL_TLSV1_2;\n\telse\n\t\tc->mask_ssl = 0;\n\tsigalgslen = tls12_get_psigalgs(s, &sigalgs);\n\tfor (i = 0; i < sigalgslen; i += 2, sigalgs += 2)\n\t\t{\n\t\tswitch(sigalgs[1])\n\t\t\t{\n#ifndef OPENSSL_NO_RSA\n\t\tcase TLSEXT_signature_rsa:\n\t\t\thave_rsa = 1;\n\t\t\tbreak;\n#endif\n#ifndef OPENSSL_NO_DSA\n\t\tcase TLSEXT_signature_dsa:\n\t\t\thave_dsa = 1;\n\t\t\tbreak;\n#endif\n#ifndef OPENSSL_NO_ECDSA\n\t\tcase TLSEXT_signature_ecdsa:\n\t\t\thave_ecdsa = 1;\n\t\t\tbreak;\n#endif\n\t\t\t}\n\t\t}\n\tif (!have_rsa)\n\t\t{\n\t\tc->mask_a |= SSL_aRSA;\n\t\tc->mask_k |= SSL_kDHr|SSL_kECDHr;\n\t\t}\n\tif (!have_dsa)\n\t\t{\n\t\tc->mask_a |= SSL_aDSS;\n\t\tc->mask_k |= SSL_kDHd;\n\t\t}\n\tif (!have_ecdsa)\n\t\t{\n\t\tc->mask_a |= SSL_aECDSA;\n\t\tc->mask_k |= SSL_kECDHe;\n\t\t}\n#ifndef OPENSSL_NO_KRB5\n\tif (!kssl_tgt_is_available(s->kssl_ctx))\n\t\t{\n\t\tc->mask_a |= SSL_aKRB5;\n\t\tc->mask_k |= SSL_kKRB5;\n\t\t}\n#endif\n#ifndef OPENSSL_NO_PSK\n\tif (!s->psk_client_callback)\n\t\t{\n\t\tc->mask_a |= SSL_aPSK;\n\t\tc->mask_k |= SSL_kPSK;\n\t\t}\n#endif \n\tc->valid = 1;\n\t}", "target": 0}
{"code": "static int sip_endpoint_identifier_str2type(const char *str)\n{\n\tint method;\n\tif (!strcasecmp(str, \"username\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_USERNAME;\n\t} else if (!strcasecmp(str, \"auth_username\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_AUTH_USERNAME;\n\t} else if (!strcasecmp(str, \"ip\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_IP;\n\t} else if (!strcasecmp(str, \"header\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_HEADER;\n\t} else if (!strcasecmp(str, \"request_uri\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_REQUEST_URI;\n\t} else if (!strcasecmp(str, \"transport\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_TRANSPORT;\n\t} else {\n\t\tmethod = -1;\n\t}\n\treturn method;\n}", "target": 1}
{"code": " double ConvolverNode::latencyTime() const\n {\n    return m_reverb ? m_reverb->latencyFrames() / static_cast<double>(sampleRate()) : 0;\n }", "target": 1}
{"code": "static void xmlGROW (xmlParserCtxtPtr ctxt) {\n    unsigned long curEnd = ctxt->input->end - ctxt->input->cur;\n    unsigned long curBase = ctxt->input->cur - ctxt->input->base;\n    if (((curEnd > (unsigned long) XML_MAX_LOOKUP_LIMIT) ||\n         (curBase > (unsigned long) XML_MAX_LOOKUP_LIMIT)) &&\n         ((ctxt->input->buf) && (ctxt->input->buf->readcallback != (xmlInputReadCallback) xmlNop)) &&\n        ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, \"Huge input lookup\");\n        ctxt->instate = XML_PARSER_EOF;\n    }\n    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n    if ((ctxt->input->cur != NULL) && (*ctxt->input->cur == 0) &&\n        (xmlParserInputGrow(ctxt->input, INPUT_CHUNK) <= 0))\n\t    xmlPopInput(ctxt);\n}", "target": 1}
{"code": "int anon_vma_fork(struct vm_area_struct *vma, struct vm_area_struct *pvma)\n{\n\tstruct anon_vma_chain *avc;\n\tstruct anon_vma *anon_vma;\n\tint error;\n\tif (!pvma->anon_vma)\n\t\treturn 0;\n\tvma->anon_vma = NULL;\n\terror = anon_vma_clone(vma, pvma);\n\tif (error)\n\t\treturn error;\n\tif (vma->anon_vma)\n\t\treturn 0;\n\tanon_vma = anon_vma_alloc();\n\tif (!anon_vma)\n\t\tgoto out_error;\n\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\tif (!avc)\n\t\tgoto out_error_free_anon_vma;\n\tanon_vma->root = pvma->anon_vma->root;\n\tanon_vma->parent = pvma->anon_vma;\n\tget_anon_vma(anon_vma->root);\n\tvma->anon_vma = anon_vma;\n\tanon_vma_lock_write(anon_vma);\n\tanon_vma_chain_link(vma, avc, anon_vma);\n\tanon_vma->parent->degree++;\n\tanon_vma_unlock_write(anon_vma);\n\treturn 0;\n out_error_free_anon_vma:\n\tput_anon_vma(anon_vma);\n out_error:\n\tunlink_anon_vmas(vma);\n\treturn -ENOMEM;\n}", "target": 1}
{"code": "void blk_mq_add_to_requeue_list(struct request *rq, bool at_head)\n{\n\tstruct request_queue *q = rq->q;\n\tunsigned long flags;\n\tBUG_ON(rq->cmd_flags & REQ_SOFTBARRIER);\n\tspin_lock_irqsave(&q->requeue_lock, flags);\n\tif (at_head) {\n\t\trq->cmd_flags |= REQ_SOFTBARRIER;\n\t\tlist_add(&rq->queuelist, &q->requeue_list);\n\t} else {\n\t\tlist_add_tail(&rq->queuelist, &q->requeue_list);\n\t}\n\tspin_unlock_irqrestore(&q->requeue_lock, flags);\n}", "target": 0}
{"code": "static int idr_get_empty_slot(struct idr *idp, int starting_id,\n\t\t\t      struct idr_layer **pa)\n{\n\tstruct idr_layer *p, *new;\n\tint layers, v, id;\n\tunsigned long flags;\n\tid = starting_id;\nbuild_up:\n\tp = idp->top;\n\tlayers = idp->layers;\n\tif (unlikely(!p)) {\n\t\tif (!(p = get_from_free_list(idp)))\n\t\t\treturn -1;\n\t\tp->layer = 0;\n\t\tlayers = 1;\n\t}\n\twhile ((layers < (MAX_LEVEL - 1)) && (id >= (1 << (layers*IDR_BITS)))) {\n\t\tlayers++;\n\t\tif (!p->count) {\n\t\t\tp->layer++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!(new = get_from_free_list(idp))) {\n\t\t\tspin_lock_irqsave(&idp->lock, flags);\n\t\t\tfor (new = p; p && p != idp->top; new = p) {\n\t\t\t\tp = p->ary[0];\n\t\t\t\tnew->ary[0] = NULL;\n\t\t\t\tnew->bitmap = new->count = 0;\n\t\t\t\t__move_to_free_list(idp, new);\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&idp->lock, flags);\n\t\t\treturn -1;\n\t\t}\n\t\tnew->ary[0] = p;\n\t\tnew->count = 1;\n\t\tnew->layer = layers-1;\n\t\tif (p->bitmap == IDR_FULL)\n\t\t\t__set_bit(0, &new->bitmap);\n\t\tp = new;\n\t}\n\trcu_assign_pointer(idp->top, p);\n\tidp->layers = layers;\n\tv = sub_alloc(idp, &id, pa);\n\tif (v == IDR_NEED_TO_GROW)\n\t\tgoto build_up;\n\treturn(v);\n}", "target": 0}
{"code": "static ssize_t store_int_with_restart(struct device *s,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t size)\n{\n\tssize_t ret = device_store_int(s, attr, buf, size);\n\tmce_restart();\n\treturn ret;\n}", "target": 1}
{"code": "int nfc_genl_fw_download_done(struct nfc_dev *dev, const char *firmware_name,\n\t\t\t      u32 result)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_CMD_FW_DOWNLOAD);\n\tif (!hdr)\n\t\tgoto free_msg;\n\tif (nla_put_string(msg, NFC_ATTR_FIRMWARE_NAME, firmware_name) ||\n\t    nla_put_u32(msg, NFC_ATTR_FIRMWARE_DOWNLOAD_STATUS, result) ||\n\t    nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\tgenlmsg_end(msg, hdr);\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\treturn 0;\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "int dccp_disconnect(struct sock *sk, int flags)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tint err = 0;\n\tconst int old_state = sk->sk_state;\n\tif (old_state != DCCP_CLOSED)\n\t\tdccp_set_state(sk, DCCP_CLOSED);\n\tif (old_state == DCCP_LISTEN) {\n\t\tinet_csk_listen_stop(sk);\n\t} else if (dccp_need_reset(old_state)) {\n\t\tdccp_send_reset(sk, DCCP_RESET_CODE_ABORTED);\n\t\tsk->sk_err = ECONNRESET;\n\t} else if (old_state == DCCP_REQUESTING)\n\t\tsk->sk_err = ECONNRESET;\n\tdccp_clear_xmit_timers(sk);\n\t__skb_queue_purge(&sk->sk_receive_queue);\n\t__skb_queue_purge(&sk->sk_write_queue);\n\tif (sk->sk_send_head != NULL) {\n\t\t__kfree_skb(sk->sk_send_head);\n\t\tsk->sk_send_head = NULL;\n\t}\n\tinet->inet_dport = 0;\n\tif (!(sk->sk_userlocks & SOCK_BINDADDR_LOCK))\n\t\tinet_reset_saddr(sk);\n\tsk->sk_shutdown = 0;\n\tsock_reset_flag(sk, SOCK_DONE);\n\ticsk->icsk_backoff = 0;\n\tinet_csk_delack_init(sk);\n\t__sk_dst_reset(sk);\n\tWARN_ON(inet->inet_num && !icsk->icsk_bind_hash);\n\tsk->sk_error_report(sk);\n\treturn err;\n}", "target": 1}
{"code": "#ifndef GPAC_DISABLE_ISOM_HINTING\nvoid dump_isom_sdp(GF_ISOFile *file, char *inName, Bool is_final_name)\n{\n\tconst char *sdp;\n\tu32 size, i;\n\tFILE *dump;\n\tif (inName) {\n\t\tchar szBuf[1024];\n\t\tstrcpy(szBuf, inName);\n\t\tif (!is_final_name) {\n\t\t\tchar *ext = strchr(szBuf, '.');\n\t\t\tif (ext) ext[0] = 0;\n\t\t\tstrcat(szBuf, \"_sdp.txt\");\n\t\t}\n\t\tdump = gf_fopen(szBuf, \"wt\");\n\t\tif (!dump) {\n\t\t\tfprintf(stderr, \"Failed to open %s for dumping\\n\", szBuf);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tdump = stdout;\n\t\tfprintf(dump, \"* File SDP content *\\n\\n\");\n\t}\n\tgf_isom_sdp_get(file, &sdp, &size);\n\tfprintf(dump, \"%s\", sdp);\n\tfprintf(dump, \"\\r\\n\");\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\tif (gf_isom_get_media_type(file, i+1) != GF_ISOM_MEDIA_HINT) continue;\n\t\tgf_isom_sdp_track_get(file, i+1, &sdp, &size);\n\t\tfprintf(dump, \"%s\", sdp);\n\t}\n\tfprintf(dump, \"\\n\\n\");", "target": 1}
{"code": "NTSTATUS get_ea_value_fsp(TALLOC_CTX *mem_ctx,\n\t\t\t  files_struct *fsp,\n\t\t\t  const char *ea_name,\n\t\t\t  struct ea_struct *pea)\n{\n\tsize_t attr_size = 256;\n\tchar *val = NULL;\n\tssize_t sizeret;\n\tsize_t max_xattr_size = 0;\n\tif (fsp == NULL) {\n\t\treturn NT_STATUS_INVALID_HANDLE;\n\t}\n\tmax_xattr_size = lp_smbd_max_xattr_size(SNUM(fsp->conn));\n again:\n\tval = talloc_realloc(mem_ctx, val, char, attr_size);\n\tif (!val) {\n\t\treturn NT_STATUS_NO_MEMORY;\n\t}\n\tsizeret = SMB_VFS_FGETXATTR(fsp, ea_name, val, attr_size);\n\tif (sizeret == -1 && errno == ERANGE && attr_size < max_xattr_size) {\n\t\tattr_size = max_xattr_size;\n\t\tgoto again;\n\t}\n\tif (sizeret == -1) {\n\t\treturn map_nt_error_from_unix(errno);\n\t}\n\tDEBUG(10,(\"get_ea_value: EA %s is of length %u\\n\", ea_name, (unsigned int)sizeret));\n\tdump_data(10, (uint8_t *)val, sizeret);\n\tpea->flags = 0;\n\tif (strnequal(ea_name, \"user.\", 5)) {\n\t\tpea->name = talloc_strdup(mem_ctx, &ea_name[5]);\n\t} else {\n\t\tpea->name = talloc_strdup(mem_ctx, ea_name);\n\t}\n\tif (pea->name == NULL) {\n\t\tTALLOC_FREE(val);\n\t\treturn NT_STATUS_NO_MEMORY;\n\t}\n\tpea->value.data = (unsigned char *)val;\n\tpea->value.length = (size_t)sizeret;\n\treturn NT_STATUS_OK;\n}", "target": 0}
{"code": "onigenc_mb4_code_to_mbc(OnigEncoding enc, OnigCodePoint code, UChar *buf)\n{\n  UChar *p = buf;\n  if ((code & 0xff000000) != 0) {\n    *p++ = (UChar )((code >> 24) & 0xff);\n  }\n  if ((code & 0xff0000) != 0 || p != buf) {\n    *p++ = (UChar )((code >> 16) & 0xff);\n  }\n  if ((code & 0xff00) != 0 || p != buf) {\n    *p++ = (UChar )((code >> 8) & 0xff);\n  }\n  *p++ = (UChar )(code & 0xff);\n#if 1\n  if (enclen(enc, buf, p) != (p - buf))\n    return ONIGERR_INVALID_CODE_POINT_VALUE;\n#endif\n  return (int )(p - buf);\n}", "target": 0}
{"code": "static void destroy_super(struct super_block *s)\n{\n\tint i;\n\tlist_lru_destroy(&s->s_dentry_lru);\n\tlist_lru_destroy(&s->s_inode_lru);\n#ifdef CONFIG_SMP\n\tfree_percpu(s->s_files);\n#endif\n\tfor (i = 0; i < SB_FREEZE_LEVELS; i++)\n\t\tpercpu_counter_destroy(&s->s_writers.counter[i]);\n\tsecurity_sb_free(s);\n\tWARN_ON(!list_empty(&s->s_mounts));\n\tkfree(s->s_subtype);\n\tkfree(s->s_options);\n\tkfree_rcu(s, rcu);\n}", "target": 1}
{"code": "DLLIMPORT int cfg_opt_nprint_var(cfg_opt_t *opt, unsigned int index, FILE *fp)\n{\n\tconst char *str;\n\tif (!opt || !fp) {\n\t\terrno = EINVAL;\n\t\treturn CFG_FAIL;\n\t}\n\tswitch (opt->type) {\n\tcase CFGT_INT:\n\t\tfprintf(fp, \"%ld\", cfg_opt_getnint(opt, index));\n\t\tbreak;\n\tcase CFGT_FLOAT:\n\t\tfprintf(fp, \"%f\", cfg_opt_getnfloat(opt, index));\n\t\tbreak;\n\tcase CFGT_STR:\n\t\tstr = cfg_opt_getnstr(opt, index);\n\t\tfprintf(fp, \"\\\"\");\n\t\twhile (str && *str) {\n\t\t\tif (*str == '\"')\n\t\t\t\tfprintf(fp, \"\\\\\\\"\");\n\t\t\telse if (*str == '\\\\')\n\t\t\t\tfprintf(fp, \"\\\\\\\\\");\n\t\t\telse\n\t\t\t\tfprintf(fp, \"%c\", *str);\n\t\t\tstr++;\n\t\t}\n\t\tfprintf(fp, \"\\\"\");\n\t\tbreak;\n\tcase CFGT_BOOL:\n\t\tfprintf(fp, \"%s\", cfg_opt_getnbool(opt, index) ? \"true\" : \"false\");\n\t\tbreak;\n\tcase CFGT_NONE:\n\tcase CFGT_SEC:\n\tcase CFGT_FUNC:\n\tcase CFGT_PTR:\n\tcase CFGT_COMMENT:\n\t\tbreak;\n\t}\n\treturn CFG_SUCCESS;\n}", "target": 0}
{"code": "static MagickBooleanType CheckPrimitiveExtent(MVGInfo *mvg_info,\n  const double pad)\n{\n  double\n    extent;\n  size_t\n    quantum;\n  quantum=sizeof(**mvg_info->primitive_info);\n  extent=(double) mvg_info->offset+pad+(PrimitiveExtentPad+1)*quantum;\n  if (extent <= (double) *mvg_info->extent)\n    return(MagickTrue);\n  if (extent == (double) CastDoubleToLong(extent))\n    {\n      *mvg_info->primitive_info=(PrimitiveInfo *) ResizeQuantumMemory(\n        *mvg_info->primitive_info,(size_t) (extent+1),quantum);\n      if (*mvg_info->primitive_info != (PrimitiveInfo *) NULL)\n        {\n          ssize_t\n            i;\n          *mvg_info->extent=(size_t) extent;\n          for (i=mvg_info->offset+1; i <= (ssize_t) extent; i++)\n          {\n            (*mvg_info->primitive_info)[i].primitive=UndefinedPrimitive;\n            (*mvg_info->primitive_info)[i].text=(char *) NULL;\n          }\n          return(MagickTrue);\n        }\n    }\n  (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n    ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n  if (*mvg_info->primitive_info != (PrimitiveInfo *) NULL)\n    *mvg_info->primitive_info=(PrimitiveInfo *) RelinquishMagickMemory(\n      *mvg_info->primitive_info);\n  *mvg_info->primitive_info=(PrimitiveInfo *) AcquireCriticalMemory((size_t) (\n    (PrimitiveExtentPad+1)*quantum));\n  (void) memset(*mvg_info->primitive_info,0,(size_t) ((PrimitiveExtentPad+1)*\n    quantum));\n  *mvg_info->extent=1;\n  mvg_info->offset=0;\n  return(MagickFalse);\n}", "target": 0}
{"code": "allocateSpaceInTable (FileInfo * nested, TranslationTableOffset * offset,\n\t\t      int count)\n{\n  int spaceNeeded = ((count + OFFSETSIZE - 1) / OFFSETSIZE) * OFFSETSIZE;\n  TranslationTableOffset size = tableUsed + spaceNeeded;\n  if (size > tableSize)\n    {\n      void *newTable;\n      size += (size / OFFSETSIZE);\n      newTable = realloc (table, size);\n      if (!newTable)\n\t{\n\t  compileError (nested, \"Not enough memory for translation table.\");\n\t  outOfMemory ();\n\t}\n      memset (((unsigned char *) newTable) + tableSize, 0, size - tableSize);\n      {\n\tChainEntry *entry;\n\tfor (entry = tableChain; entry != NULL; entry = entry->next)\n\t  if (entry->table == table)\n\t    entry->table = (TranslationTableHeader *) newTable;\n      }\n      table = (TranslationTableHeader *) newTable;\n      tableSize = size;\n    }\n  if (offset != NULL)\n    {\n      *offset = (tableUsed - sizeof (*table)) / OFFSETSIZE;\n      tableUsed += spaceNeeded;\n    }\n  return 1;\n}", "target": 0}
{"code": "static int check_ld_imm(struct bpf_verifier_env *env, struct bpf_insn *insn)\n{\n\tstruct bpf_insn_aux_data *aux = cur_aux(env);\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tstruct bpf_map *map;\n\tint err;\n\tif (BPF_SIZE(insn->code) != BPF_DW) {\n\t\tverbose(env, \"invalid BPF_LD_IMM insn\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (insn->off != 0) {\n\t\tverbose(env, \"BPF_LD_IMM64 uses reserved fields\\n\");\n\t\treturn -EINVAL;\n\t}\n\terr = check_reg_arg(env, insn->dst_reg, DST_OP);\n\tif (err)\n\t\treturn err;\n\tif (insn->src_reg == 0) {\n\t\tu64 imm = ((u64)(insn + 1)->imm << 32) | (u32)insn->imm;\n\t\tregs[insn->dst_reg].type = SCALAR_VALUE;\n\t\t__mark_reg_known(&regs[insn->dst_reg], imm);\n\t\treturn 0;\n\t}\n\tmap = env->used_maps[aux->map_index];\n\tmark_reg_known_zero(env, regs, insn->dst_reg);\n\tregs[insn->dst_reg].map_ptr = map;\n\tif (insn->src_reg == BPF_PSEUDO_MAP_VALUE) {\n\t\tregs[insn->dst_reg].type = PTR_TO_MAP_VALUE;\n\t\tregs[insn->dst_reg].off = aux->map_off;\n\t\tif (map_value_has_spin_lock(map))\n\t\t\tregs[insn->dst_reg].id = ++env->id_gen;\n\t} else if (insn->src_reg == BPF_PSEUDO_MAP_FD) {\n\t\tregs[insn->dst_reg].type = CONST_PTR_TO_MAP;\n\t} else {\n\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "TEST_F(ExprMatchTest, LtWithRHSFieldPathMatchesCorrectly) {\n    createMatcher(fromjson(\"{$expr: {$lt: [3, '$x']}}\"));\n    ASSERT_TRUE(matches(BSON(\"x\" << 10)));\n    ASSERT_FALSE(matches(BSON(\"x\" << 3)));\n    ASSERT_FALSE(matches(BSON(\"x\" << 1)));\n}", "target": 0}
{"code": "char* Elf_(r_bin_elf_get_file_type)(ELFOBJ *bin) {\n\tut32 e_type;\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\te_type = (ut32)bin->ehdr.e_type; \n\tswitch (e_type) {\n\tcase ET_NONE: return strdup (\"NONE (None)\");\n\tcase ET_REL:  return strdup (\"REL (Relocatable file)\");\n\tcase ET_EXEC: return strdup (\"EXEC (Executable file)\");\n\tcase ET_DYN:  return strdup (\"DYN (Shared object file)\");\n\tcase ET_CORE: return strdup (\"CORE (Core file)\");\n\t}\n\tif ((e_type >= ET_LOPROC) && (e_type <= ET_HIPROC)) {\n\t\treturn r_str_newf (\"Processor Specific: %x\", e_type);\n\t}\n\tif ((e_type >= ET_LOOS) && (e_type <= ET_HIOS)) {\n\t\treturn r_str_newf (\"OS Specific: %x\", e_type);\n\t}\n\treturn r_str_newf (\"<unknown>: %x\", e_type);\n}", "target": 0}
{"code": "int qemu_can_send_packet(NetClientState *sender)\n{\n    int vm_running = runstate_is_running();\n    if (!vm_running) {\n        return 0;\n    }\n    if (!sender->peer) {\n        return 1;\n    }\n    if (sender->peer->receive_disabled) {\n        return 0;\n    } else if (sender->peer->info->can_receive &&\n               !sender->peer->info->can_receive(sender->peer)) {\n        return 0;\n    }\n    return 1;\n}", "target": 1}
{"code": "static int _FVMenuClose(FontView *fv) {\n    int i;\n    SplineFont *sf = fv->b.cidmaster?fv->b.cidmaster:fv->b.sf;\n    if ( !SFCloseAllInstrs(fv->b.sf) )\nreturn( false );\n    if ( fv->b.nextsame!=NULL || fv->b.sf->fv!=&fv->b ) {\n    } else if ( warn_script_unsaved && fv->script_unsaved && \n                AskScriptChanged()==2 ) {\n        return false;\n    } else if ( SFAnyChanged(sf) ) {\n\ti = AskChanged(fv->b.sf);\n\tif ( i==2 )\t\nreturn( false );\n\tif ( i==0 && !_FVMenuSave(fv))\t\t\nreturn(false);\n\telse\n\t    SFClearAutoSave(sf);\t\t\n    }\n    _FVCloseWindows(fv);\n    if ( sf->filename!=NULL )\n\tRecentFilesRemember(sf->filename);\n    else if ( sf->origname!=NULL )\n\tRecentFilesRemember(sf->origname);\n    GDrawDestroyWindow(fv->gw);\nreturn( true );\n}", "target": 0}
{"code": "static void bnx2x_free_mcast_macs_list(struct list_head *mcast_group_list)\n{\n\tstruct bnx2x_mcast_list_elem_group *current_mcast_group;\n\twhile (!list_empty(mcast_group_list)) {\n\t\tcurrent_mcast_group = list_first_entry(mcast_group_list,\n\t\t\t\t      struct bnx2x_mcast_list_elem_group,\n\t\t\t\t      mcast_group_link);\n\t\tlist_del(&current_mcast_group->mcast_group_link);\n\t\tfree_page((unsigned long)current_mcast_group);\n\t}\n}", "target": 0}
{"code": "PHPAPI char *php_get_current_user(void)\n{\n\tzend_stat_t *pstat;\n\tif (SG(request_info).current_user) {\n\t\treturn SG(request_info).current_user;\n\t}\n\tpstat = sapi_get_stat();\n\tif (!pstat) {\n\t\treturn \"\";\n\t} else {\n#ifdef PHP_WIN32\n\t\tchar name[256];\n\t\tDWORD len = sizeof(name)-1;\n\t\tif (!GetUserName(name, &len)) {\n\t\t\treturn \"\";\n\t\t}\n\t\tname[len] = '\\0';\n\t\tSG(request_info).current_user_length = len;\n\t\tSG(request_info).current_user = estrndup(name, len);\n\t\treturn SG(request_info).current_user;\n#else\n\t\tstruct passwd *pwd;\n#if defined(ZTS) && defined(HAVE_GETPWUID_R) && defined(_SC_GETPW_R_SIZE_MAX)\n\t\tstruct passwd _pw;\n\t\tstruct passwd *retpwptr = NULL;\n\t\tint pwbuflen = sysconf(_SC_GETPW_R_SIZE_MAX);\n\t\tchar *pwbuf;\n\t\tif (pwbuflen < 1) {\n\t\t\treturn \"\";\n\t\t}\n\t\tpwbuf = emalloc(pwbuflen);\n\t\tif (getpwuid_r(pstat->st_uid, &_pw, pwbuf, pwbuflen, &retpwptr) != 0) {\n\t\t\tefree(pwbuf);\n\t\t\treturn \"\";\n\t\t}\n\t\tif (retpwptr == NULL) {\n\t\t\tefree(pwbuf);\n\t\t\treturn \"\";\n\t\t}\n\t\tpwd = &_pw;\n#else\n\t\tif ((pwd=getpwuid(pstat->st_uid))==NULL) {\n\t\t\treturn \"\";\n\t\t}\n#endif\n\t\tSG(request_info).current_user_length = strlen(pwd->pw_name);\n\t\tSG(request_info).current_user = estrndup(pwd->pw_name, SG(request_info).current_user_length);\n#if defined(ZTS) && defined(HAVE_GETPWUID_R) && defined(_SC_GETPW_R_SIZE_MAX)\n\t\tefree(pwbuf);\n#endif\n\t\treturn SG(request_info).current_user;\n#endif\n\t}\n}", "target": 0}
{"code": "\tFOR_EACH_MODULE_Type(CIRCNetwork* pNetwork) : CMuser(pNetwork ? pNetwork->GetUser()->GetModules() : CMtemp), CMnet(pNetwork ? pNetwork->GetModules() : CMtemp) {\n\t\twhere = AtGlobal;\n\t}", "target": 0}
{"code": "static void bnx2x_ptp_task(struct work_struct *work)\n{\n\tstruct bnx2x *bp = container_of(work, struct bnx2x, ptp_task);\n\tint port = BP_PORT(bp);\n\tu32 val_seq;\n\tu64 timestamp, ns;\n\tstruct skb_shared_hwtstamps shhwtstamps;\n\tval_seq = REG_RD(bp, port ? NIG_REG_P1_TLLH_PTP_BUF_SEQID :\n\t\t\t NIG_REG_P0_TLLH_PTP_BUF_SEQID);\n\tif (val_seq & 0x10000) {\n\t\ttimestamp = REG_RD(bp, port ? NIG_REG_P1_TLLH_PTP_BUF_TS_MSB :\n\t\t\t\t   NIG_REG_P0_TLLH_PTP_BUF_TS_MSB);\n\t\ttimestamp <<= 32;\n\t\ttimestamp |= REG_RD(bp, port ? NIG_REG_P1_TLLH_PTP_BUF_TS_LSB :\n\t\t\t\t    NIG_REG_P0_TLLH_PTP_BUF_TS_LSB);\n\t\tREG_WR(bp, port ? NIG_REG_P1_TLLH_PTP_BUF_SEQID :\n\t\t       NIG_REG_P0_TLLH_PTP_BUF_SEQID, 0x10000);\n\t\tns = timecounter_cyc2time(&bp->timecounter, timestamp);\n\t\tmemset(&shhwtstamps, 0, sizeof(shhwtstamps));\n\t\tshhwtstamps.hwtstamp = ns_to_ktime(ns);\n\t\tskb_tstamp_tx(bp->ptp_tx_skb, &shhwtstamps);\n\t\tdev_kfree_skb_any(bp->ptp_tx_skb);\n\t\tbp->ptp_tx_skb = NULL;\n\t\tDP(BNX2X_MSG_PTP, \"Tx timestamp, timestamp cycles = %llu, ns = %llu\\n\",\n\t\t   timestamp, ns);\n\t} else {\n\t\tDP(BNX2X_MSG_PTP, \"There is no valid Tx timestamp yet\\n\");\n\t\tschedule_work(&bp->ptp_task);\n\t}\n}", "target": 0}
{"code": "mm_answer_rsa_challenge(int socket, Buffer *m)\n{\n\tKey *key = NULL;\n\tu_char *blob;\n\tu_int blen;\n\tdebug3(\"%s entering\", __func__);\n\tif (!authctxt->valid)\n\t\tfatal(\"%s: authctxt not valid\", __func__);\n\tblob = buffer_get_string(m, &blen);\n\tif (!monitor_allowed_key(blob, blen))\n\t\tfatal(\"%s: bad key, not previously allowed\", __func__);\n\tif (key_blobtype != MM_RSAUSERKEY && key_blobtype != MM_RSAHOSTKEY)\n\t\tfatal(\"%s: key type mismatch\", __func__);\n\tif ((key = key_from_blob(blob, blen)) == NULL)\n\t\tfatal(\"%s: received bad key\", __func__);\n\tif (ssh1_challenge)\n\t\tBN_clear_free(ssh1_challenge);\n\tssh1_challenge = auth_rsa_generate_challenge(key);\n\tbuffer_clear(m);\n\tbuffer_put_bignum2(m, ssh1_challenge);\n\tdebug3(\"%s sending reply\", __func__);\n\tmm_request_send(socket, MONITOR_ANS_RSACHALLENGE, m);\n\tmonitor_permit(mon_dispatch, MONITOR_REQ_RSARESPONSE, 1);\n\txfree(blob);\n\tkey_free(key);\n\treturn (0);\n}", "target": 0}
{"code": "static int link_pipe(struct pipe_inode_info *ipipe,\n\t\t     struct pipe_inode_info *opipe,\n\t\t     size_t len, unsigned int flags)\n{\n\tstruct pipe_buffer *ibuf, *obuf;\n\tint ret = 0, i = 0, nbuf;\n\tpipe_double_lock(ipipe, opipe);\n\tdo {\n\t\tif (!opipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\t\tif (i >= ipipe->nrbufs || opipe->nrbufs >= opipe->buffers)\n\t\t\tbreak;\n\t\tibuf = ipipe->bufs + ((ipipe->curbuf + i) & (ipipe->buffers-1));\n\t\tnbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);\n\t\tpipe_buf_get(ipipe, ibuf);\n\t\tobuf = opipe->bufs + nbuf;\n\t\t*obuf = *ibuf;\n\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\t\tif (obuf->len > len)\n\t\t\tobuf->len = len;\n\t\topipe->nrbufs++;\n\t\tret += obuf->len;\n\t\tlen -= obuf->len;\n\t\ti++;\n\t} while (len);\n\tif (!ret && ipipe->waiting_writers && (flags & SPLICE_F_NONBLOCK))\n\t\tret = -EAGAIN;\n\tpipe_unlock(ipipe);\n\tpipe_unlock(opipe);\n\tif (ret > 0)\n\t\twakeup_pipe_readers(opipe);\n\treturn ret;\n}", "target": 1}
{"code": "PHP_FUNCTION(move_uploaded_file)\n{\n\tchar *path, *new_path;\n\tint path_len, new_path_len;\n\tzend_bool successful = 0;\n#ifndef PHP_WIN32\n\tint oldmask; int ret;\n#endif\n\tif (!SG(rfc1867_uploaded_files)) {\n                RETURN_FALSE;\n        }\n       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ss\", &path, &path_len, &new_path, &new_path_len) == FAILURE) {\n                return;\n        }\n\tif (!zend_hash_exists(SG(rfc1867_uploaded_files), path, path_len + 1)) {\n\t\tRETURN_FALSE;\n\t}\n\tif (php_check_open_basedir(new_path TSRMLS_CC)) {\n\t\tRETURN_FALSE;\n\t}\n\tif (VCWD_RENAME(path, new_path) == 0) {\n\t\tsuccessful = 1;\n#ifndef PHP_WIN32\n\t\toldmask = umask(077);\n\t\tumask(oldmask);\n\t\tret = VCWD_CHMOD(new_path, 0666 & ~oldmask);\n\t\tif (ret == -1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"%s\", strerror(errno));\n\t\t}\n#endif\n\t} else if (php_copy_file_ex(path, new_path, STREAM_DISABLE_OPEN_BASEDIR TSRMLS_CC) == SUCCESS) {\n\t\tVCWD_UNLINK(path);\n\t\tsuccessful = 1;\n\t}\n\tif (successful) {\n\t\tzend_hash_del(SG(rfc1867_uploaded_files), path, path_len + 1);\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to move '%s' to '%s'\", path, new_path);\n\t}\n\tRETURN_BOOL(successful);\n}", "target": 1}
{"code": "vhost_user_reset_owner(struct virtio_net *dev)\n{\n\tif (dev->flags & VIRTIO_DEV_RUNNING) {\n\t\tdev->flags &= ~VIRTIO_DEV_RUNNING;\n\t\tdev->notify_ops->destroy_device(dev->vid);\n\t}\n\tcleanup_device(dev, 0);\n\treset_device(dev);\n\treturn 0;\n}", "target": 0}
{"code": "_dbus_close_all (void)\n{\n  int maxfds, i;\n#ifdef __linux__\n  DIR *d;\n  d = opendir (\"/proc/self/fd\");\n  if (d)\n    {\n      for (;;)\n        {\n          struct dirent buf, *de;\n          int k, fd;\n          long l;\n          char *e = NULL;\n          k = readdir_r (d, &buf, &de);\n          if (k != 0 || !de)\n            break;\n          if (de->d_name[0] == '.')\n            continue;\n          errno = 0;\n          l = strtol (de->d_name, &e, 10);\n          if (errno != 0 || e == NULL || *e != '\\0')\n            continue;\n          fd = (int) l;\n          if (fd < 3)\n            continue;\n          if (fd == dirfd (d))\n            continue;\n          close (fd);\n        }\n      closedir (d);\n      return;\n    }\n#endif\n  maxfds = sysconf (_SC_OPEN_MAX);\n  if (maxfds < 0)\n    maxfds = 1024;\n  for (i = 3; i < maxfds; i++)\n    close (i);\n}", "target": 0}
{"code": "PJ_DEF(void) pj_scan_get( pj_scanner *scanner,\n\t\t\t  const pj_cis_t *spec, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n    pj_assert(pj_cis_match(spec,0)==0);\n    if (!pj_cis_match(spec, *s)) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n    do {\n\t++s;\n    } while (pj_cis_match(spec, *s));\n    pj_strset3(out, scanner->curptr, s);\n    scanner->curptr = s;\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*s) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);    \n    }\n}", "target": 1}
{"code": "save_fonteffect(struct html_feed_environ *h_env, struct readbuffer *obuf)\n{\n    if (obuf->fontstat_sp < FONT_STACK_SIZE)\n\tbcopy(obuf->fontstat, obuf->fontstat_stack[obuf->fontstat_sp],\n\t      FONTSTAT_SIZE);\n    obuf->fontstat_sp++;\n    if (obuf->in_bold)\n\tpush_tag(obuf, \"</b>\", HTML_N_B);\n    if (obuf->in_italic)\n\tpush_tag(obuf, \"</i>\", HTML_N_I);\n    if (obuf->in_under)\n\tpush_tag(obuf, \"</u>\", HTML_N_U);\n    if (obuf->in_strike)\n\tpush_tag(obuf, \"</s>\", HTML_N_S);\n    if (obuf->in_ins)\n\tpush_tag(obuf, \"</ins>\", HTML_N_INS);\n    bzero(obuf->fontstat, FONTSTAT_SIZE);\n}", "target": 0}
{"code": "passAddName (CharsString * name, int var)\n{\n  int k;\n  struct PassName *curname;\n  CharsString augmentedName;\n  for (augmentedName.length = 0;\n       augmentedName.length < name->length; augmentedName.length++)\n    augmentedName.\n      chars[augmentedName.length] = name->chars[augmentedName.length];\n  augmentedName.chars[augmentedName.length++] = passOpcode;\n  if (!\n      (curname =\n       malloc (sizeof (*curname) + CHARSIZE * (augmentedName.length - 1))))\n    {\n      outOfMemory ();\n    }\n  memset (curname, 0, sizeof (*curname));\n  for (k = 0; k < augmentedName.length; k++)\n    {\n      curname->name[k] = augmentedName.chars[k];\n    }\n  curname->length = augmentedName.length;\n  curname->varnum = var;\n  curname->next = passNames;\n  passNames = curname;\n  return 1;\n}", "target": 0}
{"code": "ikev2_ke_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len _U_, const u_char *ep _U_,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct ikev2_ke ke;\n\tconst struct ikev2_ke *k;\n\tk = (const struct ikev2_ke *)ext;\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&ke, ext, sizeof(ke));\n\tikev2_pay_print(ndo, NPSTR(tpay), ke.h.critical);\n\tND_PRINT((ndo,\" len=%u group=%s\", ntohs(ke.h.len) - 8,\n\t\t  STR_OR_ID(ntohs(ke.ke_group), dh_p_map)));\n\tif (2 < ndo->ndo_vflag && 8 < ntohs(ke.h.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(k + 1), ntohs(ke.h.len) - 8))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(ke.h.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}", "target": 1}
{"code": "static void virtbt_rx_handle(struct virtio_bluetooth *vbt, struct sk_buff *skb)\n{\n\t__u8 pkt_type;\n\tpkt_type = *((__u8 *) skb->data);\n\tskb_pull(skb, 1);\n\tswitch (pkt_type) {\n\tcase HCI_EVENT_PKT:\n\tcase HCI_ACLDATA_PKT:\n\tcase HCI_SCODATA_PKT:\n\tcase HCI_ISODATA_PKT:\n\t\thci_skb_pkt_type(skb) = pkt_type;\n\t\thci_recv_frame(vbt->hdev, skb);\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "cd_device_db_set_property (CdDeviceDb *ddb,\n\t\t\t   const gchar *device_id,\n\t\t\t   const gchar *property,\n\t\t\t   const gchar *value,\n\t\t\t   GError  **error)\n{\n\tCdDeviceDbPrivate *priv = GET_PRIVATE (ddb);\n\tgboolean ret = TRUE;\n\tgchar *error_msg = NULL;\n\tgchar *statement;\n\tgint rc;\n\tg_return_val_if_fail (CD_IS_DEVICE_DB (ddb), FALSE);\n\tg_return_val_if_fail (priv->db != NULL, FALSE);\n\tg_debug (\"CdDeviceDb: add device property %s [%s=%s]\",\n\t\t device_id, property, value);\n\tstatement = sqlite3_mprintf (\"INSERT OR REPLACE INTO properties_v2 (device_id, property, value) \"\n\t\t\t\t     \"VALUES ('%q', '%q', '%q');\",\n\t\t\t\t     device_id, property, value);\n\trc = sqlite3_exec (priv->db, statement, NULL, NULL, &error_msg);\n\tif (rc != SQLITE_OK) {\n\t\tg_set_error (error,\n\t\t\t     CD_CLIENT_ERROR,\n\t\t\t     CD_CLIENT_ERROR_INTERNAL,\n\t\t\t     \"SQL error: %s\",\n\t\t\t     error_msg);\n\t\tsqlite3_free (error_msg);\n\t\tret = FALSE;\n\t\tgoto out;\n\t}\nout:\n\tsqlite3_free (statement);\n\treturn ret;\n}", "target": 0}
{"code": "private uint64_t\nfile_strncmp16(const char *a, const char *b, size_t len, uint32_t flags)\n{\n\tflags = 0;", "target": 0}
{"code": "ext4_xattr_create_cache(char *name)\n{\n\treturn mb_cache_create(name, HASH_BUCKET_BITS);\n}", "target": 1}
{"code": "static int ext4_init_block_bitmap(struct super_block *sb,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   ext4_group_t block_group,\n\t\t\t\t   struct ext4_group_desc *gdp)\n{\n\tunsigned int bit, bit_max;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_fsblk_t start, tmp;\n\tint flex_bg = 0;\n\tJ_ASSERT_BH(bh, buffer_locked(bh));\n\tif (!ext4_group_desc_csum_verify(sb, block_group, gdp)) {\n\t\text4_mark_group_bitmap_corrupted(sb, block_group,\n\t\t\t\t\tEXT4_GROUP_INFO_BBITMAP_CORRUPT |\n\t\t\t\t\tEXT4_GROUP_INFO_IBITMAP_CORRUPT);\n\t\treturn -EFSBADCRC;\n\t}\n\tmemset(bh->b_data, 0, sb->s_blocksize);\n\tbit_max = ext4_num_base_meta_clusters(sb, block_group);\n\tif ((bit_max >> 3) >= bh->b_size)\n\t\treturn -EFSCORRUPTED;\n\tfor (bit = 0; bit < bit_max; bit++)\n\t\text4_set_bit(bit, bh->b_data);\n\tstart = ext4_group_first_block_no(sb, block_group);\n\tif (ext4_has_feature_flex_bg(sb))\n\t\tflex_bg = 1;\n\ttmp = ext4_block_bitmap(sb, gdp);\n\tif (!flex_bg || ext4_block_in_group(sb, tmp, block_group))\n\t\text4_set_bit(EXT4_B2C(sbi, tmp - start), bh->b_data);\n\ttmp = ext4_inode_bitmap(sb, gdp);\n\tif (!flex_bg || ext4_block_in_group(sb, tmp, block_group))\n\t\text4_set_bit(EXT4_B2C(sbi, tmp - start), bh->b_data);\n\ttmp = ext4_inode_table(sb, gdp);\n\tfor (; tmp < ext4_inode_table(sb, gdp) +\n\t\t     sbi->s_itb_per_group; tmp++) {\n\t\tif (!flex_bg || ext4_block_in_group(sb, tmp, block_group))\n\t\t\text4_set_bit(EXT4_B2C(sbi, tmp - start), bh->b_data);\n\t}\n\text4_mark_bitmap_end(num_clusters_in_group(sb, block_group),\n\t\t\t     sb->s_blocksize * 8, bh->b_data);\n\treturn 0;\n}", "target": 1}
{"code": "static ssize_t show_constraint_name(struct device *dev,\n\t\t\t\tstruct device_attribute *dev_attr,\n\t\t\t\tchar *buf)\n{\n\tconst char *name;\n\tstruct powercap_zone *power_zone = to_powercap_zone(dev);\n\tint id;\n\tssize_t len = -ENODATA;\n\tstruct powercap_zone_constraint *pconst;\n\tif (!sscanf(dev_attr->attr.name, \"constraint_%d_\", &id))\n\t\treturn -EINVAL;\n\tif (id >= power_zone->const_id_cnt)\n\t\treturn -EINVAL;\n\tpconst = &power_zone->constraints[id];\n\tif (pconst && pconst->ops && pconst->ops->get_name) {\n\t\tname = pconst->ops->get_name(power_zone, id);\n\t\tif (name) {\n\t\t\tsnprintf(buf, POWERCAP_CONSTRAINT_NAME_LEN,\n\t\t\t\t\t\t\t\t\"%s\\n\", name);\n\t\t\tbuf[POWERCAP_CONSTRAINT_NAME_LEN] = '\\0';\n\t\t\tlen = strlen(buf);\n\t\t}\n\t}\n\treturn len;\n}", "target": 0}
{"code": "static int raw_cmd_copyout(int cmd, void __user *param,\n\t\t\t\t  struct floppy_raw_cmd *ptr)\n{\n\tint ret;\n\twhile (ptr) {\n\t\tstruct floppy_raw_cmd cmd = *ptr;\n\t\tcmd.next = NULL;\n\t\tcmd.kernel_data = NULL;\n\t\tret = copy_to_user(param, &cmd, sizeof(cmd));\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t\tparam += sizeof(struct floppy_raw_cmd);\n\t\tif ((ptr->flags & FD_RAW_READ) && ptr->buffer_length) {\n\t\t\tif (ptr->length >= 0 &&\n\t\t\t    ptr->length <= ptr->buffer_length) {\n\t\t\t\tlong length = ptr->buffer_length - ptr->length;\n\t\t\t\tret = fd_copyout(ptr->data, ptr->kernel_data,\n\t\t\t\t\t\t length);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "mrb_decode_insn(const mrb_code *pc)\n{\n  struct mrb_insn_data data = { 0 };\n  if (pc == 0) return data;\n  data.addr = pc;\n  mrb_code insn = READ_B();\n  uint16_t a = 0;\n  uint16_t b = 0;\n  uint16_t c = 0;\n  switch (insn) {\n#define FETCH_Z() \n#define OPCODE(i,x) case OP_ ## i: FETCH_ ## x (); break;\n#include \"mruby/ops.h\"\n#undef OPCODE\n  }\n  switch (insn) {\n  case OP_EXT1:\n    insn = READ_B();\n    switch (insn) {\n#define OPCODE(i,x) case OP_ ## i: FETCH_ ## x ## _1 (); break;\n#include \"mruby/ops.h\"\n#undef OPCODE\n    }\n    break;\n  case OP_EXT2:\n    insn = READ_B();\n    switch (insn) {\n#define OPCODE(i,x) case OP_ ## i: FETCH_ ## x ## _2 (); break;\n#include \"mruby/ops.h\"\n#undef OPCODE\n    }\n    break;\n  case OP_EXT3:\n    insn = READ_B();\n    switch (insn) {\n#define OPCODE(i,x) case OP_ ## i: FETCH_ ## x ## _3 (); break;\n#include \"mruby/ops.h\"\n#undef OPCODE\n    }\n    break;\n  default:\n    break;\n  }\n  data.insn = insn;\n  data.a = a;\n  data.b = b;\n  data.c = c;\n  return data;\n}", "target": 0}
{"code": "START_TEST(test_tm_adopt_ispidowner)\n  {\n  fail_unless(TRUE == ispidowner(getpid()));\n  fail_unless(FALSE == ispidowner(1));\n  }", "target": 1}
{"code": "__u32 secure_ip_id(__be32 daddr)\n{\n\tstruct keydata *keyptr;\n\t__u32 hash[4];\n\tkeyptr = get_keyptr();\n\thash[0] = (__force __u32)daddr;\n\thash[1] = keyptr->secret[9];\n\thash[2] = keyptr->secret[10];\n\thash[3] = keyptr->secret[11];\n\treturn half_md4_transform(hash, keyptr->secret);\n}", "target": 1}
{"code": "static inline int cipso_v4_validate(const struct sk_buff *skb,\n\t\t\t\t    unsigned char **option)\n{\n\tunsigned char *opt = *option;\n\tunsigned char err_offset = 0;\n\tu8 opt_len = opt[1];\n\tu8 opt_iter;\n\tif (opt_len < 8) {\n\t\terr_offset = 1;\n\t\tgoto out;\n\t}\n\tif (get_unaligned_be32(&opt[2]) == 0) {\n\t\terr_offset = 2;\n\t\tgoto out;\n\t}\n\tfor (opt_iter = 6; opt_iter < opt_len;) {\n\t\tif (opt[opt_iter + 1] > (opt_len - opt_iter)) {\n\t\t\terr_offset = opt_iter + 1;\n\t\t\tgoto out;\n\t\t}\n\t\topt_iter += opt[opt_iter + 1];\n\t}\nout:\n\t*option = opt + err_offset;\n\treturn err_offset;\n}", "target": 1}
{"code": "static void stellaris_enet_unrealize(DeviceState *dev, Error **errp)\n{\n    stellaris_enet_state *s = STELLARIS_ENET(dev);\n    unregister_savevm(DEVICE(s), \"stellaris_enet\", s);\n    memory_region_destroy(&s->mmio);\n}", "target": 1}
{"code": "void Clipboard::ReadAsciiText(Clipboard::Buffer buffer,\n                              std::string* result) const {\n  GtkClipboard* clipboard = LookupBackingClipboard(buffer);\n  if (clipboard == NULL)\n    return;\n  result->clear();\n  gchar* text = gtk_clipboard_wait_for_text(clipboard);\n  if (text == NULL)\n    return;\n  result->assign(text);\n  g_free(text);\n}", "target": 0}
{"code": "escape_attach (int argc, char **argv, compose_env_t *env)\n{\n  const char *encoding = default_encoding;\n  const char *content_type = default_content_type;\n  switch (argc)\n    {\n    case 4:\n      encoding = argv[3];\n    case 3:\n      content_type = argv[2];\n    case 2:\n      return attlist_attach_file (&env->attlist,\n\t\t\t\t  -1, argv[1], argv[1], argv[1],\n\t\t\t\t  content_type, encoding);\n    default:\n      return escape_check_args (argc, argv, 2, 4);\n    }\n  return 1;\n}", "target": 0}
{"code": "void nfc_llcp_unregister_device(struct nfc_dev *dev)\n{\n\tstruct nfc_llcp_local *local = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tpr_debug(\"No such device\\n\");\n\t\treturn;\n\t}\n\tlocal_cleanup(local);\n\tnfc_llcp_local_put(local);\n}", "target": 1}
{"code": "int vfs_parse_fs_string(struct fs_context *fc, const char *key,\n\t\t\tconst char *value, size_t v_size)\n{\n\tint ret;\n\tstruct fs_parameter param = {\n\t\t.key\t= key,\n\t\t.type\t= fs_value_is_flag,\n\t\t.size\t= v_size,\n\t};\n\tif (value) {\n\t\tparam.string = kmemdup_nul(value, v_size, GFP_KERNEL);\n\t\tif (!param.string)\n\t\t\treturn -ENOMEM;\n\t\tparam.type = fs_value_is_string;\n\t}\n\tret = vfs_parse_fs_param(fc, &param);\n\tkfree(param.string);\n\treturn ret;\n}", "target": 0}
{"code": "static int vhost_vdpa_map(struct vhost_vdpa *v, u64 iova,\n\t\t\t  u64 size, u64 pa, u32 perm, void *opaque)\n{\n\tstruct vhost_dev *dev = &v->vdev;\n\tstruct vdpa_device *vdpa = v->vdpa;\n\tconst struct vdpa_config_ops *ops = vdpa->config;\n\tint r = 0;\n\tr = vhost_iotlb_add_range_ctx(dev->iotlb, iova, iova + size - 1,\n\t\t\t\t      pa, perm, opaque);\n\tif (r)\n\t\treturn r;\n\tif (ops->dma_map) {\n\t\tr = ops->dma_map(vdpa, iova, size, pa, perm, opaque);\n\t} else if (ops->set_map) {\n\t\tif (!v->in_batch)\n\t\t\tr = ops->set_map(vdpa, dev->iotlb);\n\t} else {\n\t\tr = iommu_map(v->domain, iova, pa, size,\n\t\t\t      perm_to_iommu_flags(perm));\n\t}\n\tif (r) {\n\t\tvhost_iotlb_del_range(dev->iotlb, iova, iova + size - 1);\n\t\treturn r;\n\t}\n\tif (!vdpa->use_va)\n\t\tatomic64_add(PFN_DOWN(size), &dev->mm->pinned_vm);\n\treturn 0;\n}", "target": 0}
{"code": "    TiffComponent::AutoPtr TiffParserWorker::parse(\n        const byte*              pData,\n              uint32_t           size,\n              uint32_t           root,\n              TiffHeaderBase*    pHeader\n    )\n    {\n        if (pData == 0 || size == 0) return TiffComponent::AutoPtr(0);\n        if (!pHeader->read(pData, size) || pHeader->offset() >= size) {\n            throw Error(3, \"TIFF\");\n        }\n        TiffComponent::AutoPtr rootDir = TiffCreator::create(root, ifdIdNotSet);\n        if (0 != rootDir.get()) {\n            rootDir->setStart(pData + pHeader->offset());\n            TiffRwState state(pHeader->byteOrder(), 0);\n            TiffReader reader(pData, size, rootDir.get(), state);\n            rootDir->accept(reader);\n            reader.postProcess();\n        }\n        return rootDir;\n    } ", "target": 0}
{"code": "static void ufs_mtk_init_va09_pwr_ctrl(struct ufs_hba *hba)\n{\n\tstruct ufs_mtk_host *host = ufshcd_get_variant(hba);\n\thost->reg_va09 = regulator_get(hba->dev, \"va09\");\n\tif (!host->reg_va09)\n\t\tdev_info(hba->dev, \"failed to get va09\");\n\telse\n\t\thost->caps |= UFS_MTK_CAP_VA09_PWR_CTRL;\n}", "target": 1}
{"code": "bool ContentSettingsObserver::AllowScript(bool enabled_per_settings) {\n  if (!enabled_per_settings)\n    return false;\n  if (IsScriptDisabledForPreview(render_frame()))\n    return false;\n  if (is_interstitial_page_)\n    return true;\n  blink::WebLocalFrame* frame = render_frame()->GetWebFrame();\n  const auto it = cached_script_permissions_.find(frame);\n  if (it != cached_script_permissions_.end())\n    return it->second;\n  bool allow = true;\n  if (content_setting_rules_) {\n    ContentSetting setting = GetContentSettingFromRules(\n        content_setting_rules_->script_rules, frame,\n        url::Origin(frame->GetDocument().GetSecurityOrigin()).GetURL());\n    allow = setting != CONTENT_SETTING_BLOCK;\n  }\n  allow = allow || IsWhitelistedForContentSettings();\n  cached_script_permissions_[frame] = allow;\n  return allow;\n}", "target": 1}
{"code": "static inline unsigned char *__skb_put(struct sk_buff *skb, unsigned int len)\n{\n\tunsigned char *tmp = skb_tail_pointer(skb);\n\tSKB_LINEAR_ASSERT(skb);\n\tskb->tail += len;\n\tskb->len  += len;\n\treturn tmp;\n}", "target": 0}
{"code": "std::unique_ptr<MatchExpression> InMatchExpression::shallowClone() const {\n    auto next = stdx::make_unique<InMatchExpression>(path());\n    next->setCollator(_collator);\n    if (getTag()) {\n        next->setTag(getTag()->clone());\n    }\n    next->_hasNull = _hasNull;\n    next->_hasEmptyArray = _hasEmptyArray;\n    next->_equalitySet = _equalitySet;\n    next->_originalEqualityVector = _originalEqualityVector;\n    for (auto&& regex : _regexes) {\n        std::unique_ptr<RegexMatchExpression> clonedRegex(\n            static_cast<RegexMatchExpression*>(regex->shallowClone().release()));\n        next->_regexes.push_back(std::move(clonedRegex));\n    }\n    return std::move(next);\n}", "target": 0}
{"code": "PGTYPEStimestamp_from_asc(char *str, char **endptr)\n{\n\ttimestamp\tresult;\n#ifdef HAVE_INT64_TIMESTAMP\n\tint64\t\tnoresult = 0;\n#else\n\tdouble\t\tnoresult = 0.0;\n#endif\n\tfsec_t\t\tfsec;\n\tstruct tm\ttt,\n\t\t\t   *tm = &tt;\n\tint\t\t\tdtype;\n\tint\t\t\tnf;\n\tchar\t   *field[MAXDATEFIELDS];\n\tint\t\t\tftype[MAXDATEFIELDS];\n\tchar\t\tlowstr[MAXDATELEN + MAXDATEFIELDS];\n\tchar\t   *realptr;\n\tchar\t  **ptr = (endptr != NULL) ? endptr : &realptr;\n\tif (strlen(str) >= sizeof(lowstr))\n\t{\n\t\terrno = PGTYPES_TS_BAD_TIMESTAMP;\n\t\treturn (noresult);\n\t}\n\tif (ParseDateTime(str, lowstr, field, ftype, &nf, ptr) != 0 ||\n\t\tDecodeDateTime(field, ftype, nf, &dtype, tm, &fsec, 0) != 0)\n\t{\n\t\terrno = PGTYPES_TS_BAD_TIMESTAMP;\n\t\treturn (noresult);\n\t}\n\tswitch (dtype)\n\t{\n\t\tcase DTK_DATE:\n\t\t\tif (tm2timestamp(tm, fsec, NULL, &result) != 0)\n\t\t\t{\n\t\t\t\terrno = PGTYPES_TS_BAD_TIMESTAMP;\n\t\t\t\treturn (noresult);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DTK_EPOCH:\n\t\t\tresult = SetEpochTimestamp();\n\t\t\tbreak;\n\t\tcase DTK_LATE:\n\t\t\tTIMESTAMP_NOEND(result);\n\t\t\tbreak;\n\t\tcase DTK_EARLY:\n\t\t\tTIMESTAMP_NOBEGIN(result);\n\t\t\tbreak;\n\t\tcase DTK_INVALID:\n\t\t\terrno = PGTYPES_TS_BAD_TIMESTAMP;\n\t\t\treturn (noresult);\n\t\tdefault:\n\t\t\terrno = PGTYPES_TS_BAD_TIMESTAMP;\n\t\t\treturn (noresult);\n\t}\n\terrno = 0;\n\treturn result;\n}", "target": 1}
{"code": "time_to_df(int h, int min, int s)\n{\n    return h * HOUR_IN_SECONDS + min * MINUTE_IN_SECONDS + s;\n}", "target": 0}
{"code": "int blkid_probe_is_covered_by_pt(blkid_probe pr,\n\t\t\t\t uint64_t offset, uint64_t size)\n{\n\tblkid_probe prc = NULL;\n\tblkid_partlist ls = NULL;\n\tuint64_t start, end;\n\tint nparts, i, rc = 0;\n\tDBG(LOWPROBE, ul_debug(\n\t\t\"=> checking if off=%\"PRIu64\" size=%\"PRIu64\" covered by PT\",\n\t\toffset, size));\n\tif (pr->flags & BLKID_FL_NOSCAN_DEV)\n\t\tgoto done;\n\tprc = blkid_clone_probe(pr);\n\tif (!prc)\n\t\tgoto done;\n\tls = blkid_probe_get_partitions(prc);\n\tif (!ls)\n\t\tgoto done;\n\tnparts = blkid_partlist_numof_partitions(ls);\n\tif (!nparts)\n\t\tgoto done;\n\tend = (offset + size) >> 9;\n\tstart = offset >> 9;\n\tfor (i = 0; i < nparts; i++) {\n\t\tblkid_partition par = &ls->parts[i];\n\t\tif (par->start + par->size > (pr->size >> 9)) {\n\t\t\tDBG(LOWPROBE, ul_debug(\"partition #%d overflows \"\n\t\t\t\t\"device (off=%\" PRId64 \" size=%\" PRId64 \")\",\n\t\t\t\tpar->partno, par->start, par->size));\n\t\t\tgoto done;\n\t\t}\n\t}\n\tfor (i = 0; i < nparts; i++) {\n\t\tblkid_partition par = &ls->parts[i];\n\t\tif (start >= par->start && end <= par->start + par->size) {\n\t\t\trc = 1;\n\t\t\tbreak;\n\t\t}\n\t}\ndone:\n\tblkid_free_probe(prc);\n\tDBG(LOWPROBE, ul_debug(\"<= %s covered by PT\", rc ? \"IS\" : \"NOT\"));\n\treturn rc;\n}", "target": 0}
{"code": "static int hardware_enable(void)\n{\n\tint cpu = raw_smp_processor_id();\n\tu64 phys_addr = __pa(per_cpu(vmxarea, cpu));\n\tu64 old, test_bits;\n\tif (read_cr4() & X86_CR4_VMXE)\n\t\treturn -EBUSY;\n\tINIT_LIST_HEAD(&per_cpu(loaded_vmcss_on_cpu, cpu));\n\tcrash_enable_local_vmclear(cpu);\n\trdmsrl(MSR_IA32_FEATURE_CONTROL, old);\n\ttest_bits = FEATURE_CONTROL_LOCKED;\n\ttest_bits |= FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX;\n\tif (tboot_enabled())\n\t\ttest_bits |= FEATURE_CONTROL_VMXON_ENABLED_INSIDE_SMX;\n\tif ((old & test_bits) != test_bits) {\n\t\twrmsrl(MSR_IA32_FEATURE_CONTROL, old | test_bits);\n\t}\n\twrite_cr4(read_cr4() | X86_CR4_VMXE); \n\tif (vmm_exclusive) {\n\t\tkvm_cpu_vmxon(phys_addr);\n\t\tept_sync_global();\n\t}\n\tnative_store_gdt(this_cpu_ptr(&host_gdt));\n\treturn 0;\n}", "target": 0}
{"code": "static bool ok_inflater_literal_tree(ok_inflater *inflater) {\n    bool done = ok_inflater_inflate_huffman_tree(inflater, inflater->literal_huffman,\n                                                 inflater->code_length_huffman,\n                                                 inflater->num_literal_codes);\n    if (done) {\n        inflater->state = OK_INFLATER_STATE_READING_DYNAMIC_DISTANCE_TREE;\n        inflater->huffman_code = -1;\n        inflater->state_count = 0;\n        return true;\n    } else {\n        return false;\n    }\n}", "target": 0}
{"code": " static void rtc_irq_eoi_tracking_reset(struct kvm_ioapic *ioapic)\n {\n \tioapic->rtc_status.pending_eoi = 0;\n\tbitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPUS);\n }", "target": 1}
{"code": "static void start_request(GDHCPClient *dhcp_client)\n{\n\tdebug(dhcp_client, \"start request (retries %d)\",\n\t\t\t\t\tdhcp_client->retry_times);\n\tif (dhcp_client->retry_times == REQUEST_RETRIES) {\n\t\tif (dhcp_client->no_lease_cb)\n\t\t\tdhcp_client->no_lease_cb(dhcp_client,\n\t\t\t\t\t\tdhcp_client->no_lease_data);\n\t\treturn;\n\t}\n\tif (dhcp_client->retry_times == 0) {\n\t\tdhcp_client->state = REQUESTING;\n\t\tswitch_listening_mode(dhcp_client, L2);\n\t}\n\tsend_request(dhcp_client);\n\tdhcp_client->timeout = g_timeout_add_seconds_full(G_PRIORITY_HIGH,\n\t\t\t\t\t\t\tREQUEST_TIMEOUT,\n\t\t\t\t\t\t\trequest_timeout,\n\t\t\t\t\t\t\tdhcp_client,\n\t\t\t\t\t\t\tNULL);\n}", "target": 0}
{"code": "static int x509_get_basic_constraints( unsigned char **p,\n                                       const unsigned char *end,\n                                       int *ca_istrue,\n                                       int *max_pathlen )\n{\n    int ret;\n    size_t len;\n    *ca_istrue = 0; \n    *max_pathlen = 0; \n    if( ( ret = mbedtls_asn1_get_tag( p, end, &len,\n            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n    if( *p == end )\n        return( 0 );\n    if( ( ret = mbedtls_asn1_get_bool( p, end, ca_istrue ) ) != 0 )\n    {\n        if( ret == MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )\n            ret = mbedtls_asn1_get_int( p, end, ca_istrue );\n        if( ret != 0 )\n            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n        if( *ca_istrue != 0 )\n            *ca_istrue = 1;\n    }\n    if( *p == end )\n        return( 0 );\n    if( ( ret = mbedtls_asn1_get_int( p, end, max_pathlen ) ) != 0 )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n    if( *p != end )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +\n                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );\n    (*max_pathlen)++;\n    return( 0 );\n}", "target": 0}
{"code": "bool __fastcall TSiteRawDialog::Execute(TSessionData * Data)\n{\n  std::unique_ptr<TSessionData> FactoryDefaults(new TSessionData(L\"\"));\n  std::unique_ptr<TSessionData> RawData(new TSessionData(L\"\"));\n  RawData->Assign(Data);\n  if (RawData->FSProtocol != fsSFTPonly)\n  {\n    RawData->FSProtocol = FactoryDefaults->FSProtocol;\n  }\n  RawData->HostName = FactoryDefaults->HostName;\n  RawData->PortNumber = FactoryDefaults->PortNumber;\n  RawData->UserName = FactoryDefaults->UserName;\n  RawData->Password = FactoryDefaults->Password;\n  RawData->Ftps = FactoryDefaults->Ftps;\n  std::unique_ptr<TStrings> Options(RawData->SaveToOptions(FactoryDefaults.get(), false, false));\n  SettingsMemo->Lines = Options.get();\n  bool Result = TCustomDialog::Execute();\n  if (Result)\n  {\n    std::unique_ptr<TSessionData> BackupData(new TSessionData(L\"\"));\n    BackupData->Assign(Data);\n    Data->DefaultSettings();\n    Data->FSProtocol = BackupData->FSProtocol;\n    Data->HostName = BackupData->HostName;\n    Data->PortNumber = BackupData->PortNumber;\n    Data->UserName = BackupData->UserName;\n    Data->Password = BackupData->Password;\n    Data->Ftps = BackupData->Ftps;\n    Data->ApplyRawSettings(SettingsMemo->Lines);\n  }\n  return Result;\n}", "target": 1}
{"code": "u32 secure_ipv6_port_ephemeral(const __be32 *saddr, const __be32 *daddr,\n\t\t\t       __be16 dport)\n{\n\tstruct keydata *keyptr = get_keyptr();\n\tu32 hash[12];\n\tmemcpy(hash, saddr, 16);\n\thash[4] = (__force u32)dport;\n\tmemcpy(&hash[5], keyptr->secret, sizeof(__u32) * 7);\n\treturn twothirdsMD4Transform((const __u32 *)daddr, hash);\n}", "target": 1}
{"code": "virSecuritySELinuxRestoreInputLabel(virSecurityManager *mgr,\n                                    virDomainDef *def,\n                                    virDomainInputDef *input)\n{\n    int rc = 0;\n    virSecurityLabelDef *seclabel;\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (seclabel == NULL)\n        return 0;\n    switch ((virDomainInputType)input->type) {\n    case VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH:\n    case VIR_DOMAIN_INPUT_TYPE_EVDEV:\n        rc = virSecuritySELinuxRestoreFileLabel(mgr, input->source.evdev, true);\n        break;\n    case VIR_DOMAIN_INPUT_TYPE_MOUSE:\n    case VIR_DOMAIN_INPUT_TYPE_TABLET:\n    case VIR_DOMAIN_INPUT_TYPE_KBD:\n    case VIR_DOMAIN_INPUT_TYPE_LAST:\n        break;\n    }\n    return rc;\n}", "target": 0}
{"code": "static bool kvm_vcpu_check_breakpoint(struct kvm_vcpu *vcpu, int *r)\n{\n\tstruct kvm_run *kvm_run = vcpu->run;\n\tunsigned long eip = vcpu->arch.emulate_ctxt.eip;\n\tu32 dr6 = 0;\n\tif (unlikely(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) &&\n\t    (vcpu->arch.guest_debug_dr7 & DR7_BP_EN_MASK)) {\n\t\tdr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.guest_debug_dr7,\n\t\t\t\t\t   vcpu->arch.eff_db);\n\t\tif (dr6 != 0) {\n\t\t\tkvm_run->debug.arch.dr6 = dr6 | DR6_FIXED_1 | DR6_RTM;\n\t\t\tkvm_run->debug.arch.pc = kvm_rip_read(vcpu) +\n\t\t\t\tget_segment_base(vcpu, VCPU_SREG_CS);\n\t\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\t\t*r = EMULATE_USER_EXIT;\n\t\t\treturn true;\n\t\t}\n\t}\n\tif (unlikely(vcpu->arch.dr7 & DR7_BP_EN_MASK) &&\n\t    !(kvm_get_rflags(vcpu) & X86_EFLAGS_RF)) {\n\t\tdr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.dr7,\n\t\t\t\t\t   vcpu->arch.db);\n\t\tif (dr6 != 0) {\n\t\t\tvcpu->arch.dr6 &= ~15;\n\t\t\tvcpu->arch.dr6 |= dr6 | DR6_RTM;\n\t\t\tkvm_queue_exception(vcpu, DB_VECTOR);\n\t\t\t*r = EMULATE_DONE;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "target": 0}
{"code": "static int fts3SnippetFindPositions(Fts3Expr *pExpr, int iPhrase, void *ctx){\n  SnippetIter *p = (SnippetIter *)ctx;\n  SnippetPhrase *pPhrase = &p->aPhrase[iPhrase];\n  char *pCsr;\n  int rc;\n  pPhrase->nToken = pExpr->pPhrase->nToken;\n  rc = sqlite3Fts3EvalPhrasePoslist(p->pCsr, pExpr, p->iCol, &pCsr);\n  assert( rc==SQLITE_OK || pCsr==0 );\n  if( pCsr ){\n    int iFirst = 0;\n    pPhrase->pList = pCsr;\n    fts3GetDeltaPosition(&pCsr, &iFirst);\n    assert( iFirst>=0 );\n    pPhrase->pHead = pCsr;\n    pPhrase->pTail = pCsr;\n    pPhrase->iHead = iFirst;\n    pPhrase->iTail = iFirst;\n  }else{\n    assert( rc!=SQLITE_OK || (\n       pPhrase->pList==0 && pPhrase->pHead==0 && pPhrase->pTail==0 \n    ));\n  }\n  return rc;\n}", "target": 0}
{"code": "static long btrfs_ioctl_scrub_progress(struct btrfs_fs_info *fs_info,\n\t\t\t\t       void __user *arg)\n{\n\tstruct btrfs_ioctl_scrub_args *sa;\n\tint ret;\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tsa = memdup_user(arg, sizeof(*sa));\n\tif (IS_ERR(sa))\n\t\treturn PTR_ERR(sa);\n\tret = btrfs_scrub_progress(fs_info, sa->devid, &sa->progress);\n\tif (ret == 0 && copy_to_user(arg, sa, sizeof(*sa)))\n\t\tret = -EFAULT;\n\tkfree(sa);\n\treturn ret;\n}", "target": 0}
{"code": "struct ipv6_txoptions *ipv6_update_options(struct sock *sk,\n\t\t\t\t\t   struct ipv6_txoptions *opt)\n{\n\tif (inet_sk(sk)->is_icsk) {\n\t\tif (opt &&\n\t\t    !((1 << sk->sk_state) & (TCPF_LISTEN | TCPF_CLOSE)) &&\n\t\t    inet_sk(sk)->inet_daddr != LOOPBACK4_IPV6) {\n\t\t\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\t\t\ticsk->icsk_ext_hdr_len = opt->opt_flen + opt->opt_nflen;\n\t\t\ticsk->icsk_sync_mss(sk, icsk->icsk_pmtu_cookie);\n\t\t}\n\t}\n\topt = xchg(&inet6_sk(sk)->opt, opt);\n\tsk_dst_reset(sk);\n\treturn opt;\n}", "target": 1}
{"code": "alloc_handle( void *ctx_arg, int is_server )\n{\n\ttls_ctx\t*ctx;\n\ttls_session\t*ssl;\n\tif ( ctx_arg ) {\n\t\tctx = ctx_arg;\n\t} else {\n\t\tstruct ldapoptions *lo = LDAP_INT_GLOBAL_OPT();   \n\t\tif ( ldap_pvt_tls_init_def_ctx( is_server ) < 0 ) return NULL;\n\t\tctx = lo->ldo_tls_ctx;\n\t}\n\tssl = tls_imp->ti_session_new( ctx, is_server );\n\tif ( ssl == NULL ) {\n\t\tDebug( LDAP_DEBUG_ANY,\"TLS: can't create ssl handle.\\n\",0,0,0);\n\t\treturn NULL;\n\t}\n\treturn ssl;\n}", "target": 0}
{"code": "static int __ptrace_may_access(struct task_struct *task, unsigned int mode)\n{\n\tconst struct cred *cred = current_cred(), *tcred;\n\tint dumpable = 0;\n\tif (same_thread_group(task, current))\n\t\treturn 0;\n\trcu_read_lock();\n\ttcred = __task_cred(task);\n\tif (uid_eq(cred->uid, tcred->euid) &&\n\t    uid_eq(cred->uid, tcred->suid) &&\n\t    uid_eq(cred->uid, tcred->uid)  &&\n\t    gid_eq(cred->gid, tcred->egid) &&\n\t    gid_eq(cred->gid, tcred->sgid) &&\n\t    gid_eq(cred->gid, tcred->gid))\n\t\tgoto ok;\n\tif (ptrace_has_cap(tcred->user_ns, mode))\n\t\tgoto ok;\n\trcu_read_unlock();\n\treturn -EPERM;\nok:\n\trcu_read_unlock();\n\tsmp_rmb();\n\tif (task->mm)\n\t\tdumpable = get_dumpable(task->mm);\n\trcu_read_lock();\n\tif (!dumpable && !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {\n\t\trcu_read_unlock();\n\t\treturn -EPERM;\n\t}\n\trcu_read_unlock();\n\treturn security_ptrace_access_check(task, mode);\n}", "target": 1}
{"code": "        unsigned int GetU32BE (int nPos, bool *pbSuccess)\n        {\n            if ( nPos < 0 || nPos + 3 >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            unsigned int nRes = m_sFile[nPos];\n            nRes = (nRes << 8) + m_sFile[nPos + 1];\n            nRes = (nRes << 8) + m_sFile[nPos + 2];\n            nRes = (nRes << 8) + m_sFile[nPos + 3];\n            return nRes;\n        }", "target": 1}
{"code": "static TEE_Result do_alloc_publickey(struct rsa_public_key *s,\n\t\t\t\t     size_t key_size_bits __unused)\n{\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->e))\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tif (!bn_alloc_max(&s->n)) {\n\t\tcrypto_bignum_free(s->e);\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\t}\n\treturn TEE_SUCCESS;\n}", "target": 1}
{"code": "device_drive_benchmark_authorized_cb (Daemon *daemon,\n                                      Device *device,\n                                      DBusGMethodInvocation *context,\n                                      const gchar *action_id,\n                                      guint num_user_data,\n                                      gpointer *user_data_elements)\n{\n  gboolean do_write_benchmark = GPOINTER_TO_INT (user_data_elements[0]);\n  gchar **options = user_data_elements[1];\n  gchar *argv[16];\n  guint n;\n  if (!device->priv->device_is_drive)\n    {\n      throw_error (context, ERROR_FAILED, \"Device is not a drive\");\n      goto out;\n    }\n  if (do_write_benchmark)\n    {\n      if (device->priv->device_is_partition_table)\n        {\n          throw_error (context, ERROR_FAILED, \"A partition table was detected - write benchmarking requires \"\n                       \"the disk to be completely empty\");\n          goto out;\n        }\n      if (device->priv->id_usage != NULL)\n        {\n          throw_error (context, ERROR_FAILED, \"The disk seems to have usage `%s' - write benchmarking requires \"\n                       \"the disk to be completely empty\", device->priv->id_usage);\n          goto out;\n        }\n    }\n  for (n = 0; options[n] != NULL; n++)\n    {\n      const char *option = options[n];\n      throw_error (context, ERROR_INVALID_OPTION, \"Unknown option %s\", option);\n      goto out;\n    }\n  n = 0;\n  argv[n++] = \"udisks-helper-drive-benchmark\";\n  argv[n++] = device->priv->device_file;\n  argv[n++] = do_write_benchmark ? \"1\" : \"0\";\n  argv[n++] = NULL;\n  if (!job_new (context, \"DriveBenchmark\", TRUE, device, argv, NULL, drive_benchmark_completed_cb, FALSE, NULL, NULL))\n    {\n      goto out;\n    }\n out:\n  ;\n}", "target": 0}
{"code": "eval_lambda(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\tverbose)\t\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    typval_T\tbase = *rettv;\n    int\t\tret;\n    rettv->v_type = VAR_UNKNOWN;\n    if (**arg == '{')\n    {\n\tret = get_lambda_tv(arg, rettv, FALSE, evalarg);\n    }\n    else\n    {\n\t++*arg;\n\tret = eval1(arg, rettv, evalarg);\n\t*arg = skipwhite_and_linebreak(*arg, evalarg);\n\tif (**arg == ')')\n\t{\n\t    ++*arg;\n\t}\n\telse\n\t{\n\t    emsg(_(e_missing_closing_paren));\n\t    ret = FAIL;\n\t}\n    }\n    if (ret != OK)\n\treturn FAIL;\n    else if (**arg != '(')\n    {\n\tif (verbose)\n\t{\n\t    if (*skipwhite(*arg) == '(')\n\t\temsg(_(e_no_white_space_allowed_before_parenthesis));\n\t    else\n\t\tsemsg(_(e_missing_parenthesis_str), \"lambda\");\n\t}\n\tclear_tv(rettv);\n\tret = FAIL;\n    }\n    else\n\tret = call_func_rettv(arg, evalarg, rettv, evaluate, NULL, &base);\n    if (evaluate)\n\tclear_tv(&base);\n    return ret;\n}", "target": 1}
{"code": "static inline bool key_is_instantiated(const struct key *key)\n{\n\treturn test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&\n\t\t!test_bit(KEY_FLAG_NEGATIVE, &key->flags);\n}", "target": 1}
{"code": "void LibRaw::layer_thumb()\n{\n  int i, c;\n  char *thumb, map[][4] = {\"012\", \"102\"};\n  colors = thumb_misc >> 5 & 7;\n  thumb_length = thumb_width * thumb_height;\n  thumb = (char *)calloc(colors, thumb_length);\n  merror(thumb, \"layer_thumb()\");\n  fprintf(ofp, \"P%d\\n%d %d\\n255\\n\", 5 + (colors >> 1), thumb_width,\n          thumb_height);\n  fread(thumb, thumb_length, colors, ifp);\n  for (i = 0; i < thumb_length; i++)\n    FORCC putc(thumb[i + thumb_length * (map[thumb_misc >> 8][c] - '0')], ofp);\n  free(thumb);\n}", "target": 0}
{"code": "int ipmi_validate_addr(struct ipmi_addr *addr, int len)\n{\n\tif (len < sizeof(struct ipmi_system_interface_addr))\n\t\treturn -EINVAL;\n\tif (addr->addr_type == IPMI_SYSTEM_INTERFACE_ADDR_TYPE) {\n\t\tif (addr->channel != IPMI_BMC_CHANNEL)\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\tif ((addr->channel == IPMI_BMC_CHANNEL)\n\t    || (addr->channel >= IPMI_MAX_CHANNELS)\n\t    || (addr->channel < 0))\n\t\treturn -EINVAL;\n\tif (is_ipmb_addr(addr) || is_ipmb_bcast_addr(addr)) {\n\t\tif (len < sizeof(struct ipmi_ipmb_addr))\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\tif (is_lan_addr(addr)) {\n\t\tif (len < sizeof(struct ipmi_lan_addr))\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}", "target": 0}
{"code": "static void alterCurrentValue(PlatformUIElement element, int factor)\n{\n    if (!element || !ATK_IS_VALUE(element))\n        return;\n    GValue currentValue = G_VALUE_INIT;\n    atk_value_get_current_value(ATK_VALUE(element), &currentValue);\n    GValue increment = G_VALUE_INIT;\n    atk_value_get_minimum_increment(ATK_VALUE(element), &increment);\n    GValue newValue = G_VALUE_INIT;\n    g_value_init(&newValue, G_TYPE_DOUBLE);\n    g_value_set_float(&newValue, g_value_get_float(&currentValue) + factor * g_value_get_float(&increment));\n    atk_value_set_current_value(ATK_VALUE(element), &newValue);\n    g_value_unset(&newValue);\n    g_value_unset(&increment);\n     g_value_unset(&currentValue);\n }", "target": 0}
{"code": "static inline bool _arq_scheduled(gnrc_sixlowpan_frag_fb_t *fbuf)\n{\n    evtimer_event_t *ptr = _arq_timer.events;\n    evtimer_event_t *event = &fbuf->sfr.arq_timeout_event.event;\n    while (ptr) {\n        if (ptr == event) {\n            return true;\n        }\n        ptr = ptr->next;\n    }\n    return false;\n}", "target": 0}
{"code": "spnego_gss_wrap_size_limit(\n\tOM_uint32\t*minor_status,\n\tconst gss_ctx_id_t context_handle,\n\tint\t\tconf_req_flag,\n\tgss_qop_t\tqop_req,\n\tOM_uint32\treq_output_size,\n\tOM_uint32\t*max_input_size)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_size_limit(minor_status,\n\t\t\t\tcontext_handle,\n\t\t\t\tconf_req_flag,\n\t\t\t\tqop_req,\n\t\t\t\treq_output_size,\n\t\t\t\tmax_input_size);\n\treturn (ret);\n}", "target": 0}
{"code": "void RenderWidgetHostImpl::SetNeedsBeginFrame(bool needs_begin_frames) {\n  if (needs_begin_frames_ == needs_begin_frames)\n    return;\n  needs_begin_frames_ = needs_begin_frames;\n  if (view_)\n    view_->SetNeedsBeginFrames(needs_begin_frames);\n}", "target": 0}
{"code": "static QSvgNode *createPathNode(QSvgNode *parent,\n                                const QXmlStreamAttributes &attributes,\n                                QSvgHandler *)\n{\n    QStringRef data      = attributes.value(QLatin1String(\"d\"));\n    QPainterPath qpath;\n    qpath.setFillRule(Qt::WindingFill);\n    parsePathDataFast(data, qpath);\n    QSvgNode *path = new QSvgPath(parent, qpath);\n    return path;\n}", "target": 1}
{"code": "void zmq::stream_engine_t::mechanism_ready ()\n{\n    if (options.recv_identity) {\n        msg_t identity;\n        mechanism->peer_identity (&identity);\n        const int rc = session->push_msg (&identity);\n        if (rc == -1 && errno == EAGAIN) {\n            return;\n        }\n        errno_assert (rc == 0);\n        session->flush ();\n    }\n    next_msg = &stream_engine_t::pull_and_encode;\n    process_msg = &stream_engine_t::write_credential;\n    typedef metadata_t::dict_t properties_t;\n    properties_t properties;\n    properties_t::const_iterator it;\n    const properties_t& zap_properties = mechanism->get_zap_properties ();\n    it = zap_properties.begin ();\n    while (it != zap_properties.end ()) {\n        properties.insert (properties_t::value_type (it->first, it->second));\n        it++;\n    }\n    const properties_t& zmtp_properties = mechanism->get_zmtp_properties ();\n    it = zmtp_properties.begin ();\n    while (it != zmtp_properties.end ()) {\n        properties.insert (properties_t::value_type (it->first, it->second));\n        it++;\n    }\n    zmq_assert (metadata == NULL);\n    if (!properties.empty ())\n        metadata = new (std::nothrow) metadata_t (properties);\n}", "target": 0}
{"code": "int nft_expr_inner_parse(const struct nft_ctx *ctx, const struct nlattr *nla,\n\t\t\t struct nft_expr_info *info)\n{\n\tstruct nlattr *tb[NFTA_EXPR_MAX + 1];\n\tconst struct nft_expr_type *type;\n\tint err;\n\terr = nla_parse_nested_deprecated(tb, NFTA_EXPR_MAX, nla,\n\t\t\t\t\t  nft_expr_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\tif (!tb[NFTA_EXPR_DATA])\n\t\treturn -EINVAL;\n\ttype = __nft_expr_type_get(ctx->family, tb[NFTA_EXPR_NAME]);\n\tif (!type)\n\t\treturn -ENOENT;\n\tif (!type->inner_ops)\n\t\treturn -EOPNOTSUPP;\n\terr = nla_parse_nested_deprecated(info->tb, type->maxattr,\n\t\t\t\t\t  tb[NFTA_EXPR_DATA],\n\t\t\t\t\t  type->policy, NULL);\n\tif (err < 0)\n\t\tgoto err_nla_parse;\n\tinfo->attr = nla;\n\tinfo->ops = type->inner_ops;\n\treturn 0;\nerr_nla_parse:\n\treturn err;\n}", "target": 1}
{"code": "compat_kex_proposal(struct ssh *ssh, char *p)\n{\n\tif ((ssh->compat & (SSH_BUG_CURVE25519PAD|SSH_OLD_DHGEX)) == 0)\n\t\treturn p;\n\tdebug2_f(\"original KEX proposal: %s\", p);\n\tif ((ssh->compat & SSH_BUG_CURVE25519PAD) != 0)\n\t\tif ((p = match_filter_denylist(p,\n\t\t    \"curve25519-sha256@libssh.org\")) == NULL)\n\t\t\tfatal(\"match_filter_denylist failed\");\n\tif ((ssh->compat & SSH_OLD_DHGEX) != 0) {\n\t\tif ((p = match_filter_denylist(p,\n\t\t    \"diffie-hellman-group-exchange-sha256,\"\n\t\t    \"diffie-hellman-group-exchange-sha1\")) == NULL)\n\t\t\tfatal(\"match_filter_denylist failed\");\n\t}\n\tdebug2_f(\"compat KEX proposal: %s\", p);\n\tif (*p == '\\0')\n\t\tfatal(\"No supported key exchange algorithms found\");\n\treturn p;\n}", "target": 1}
{"code": "static void asmlinkage smm_do_relocation(void *arg)\n{\n\tconst struct smm_module_params *p;\n\tconst struct smm_runtime *runtime;\n\tint cpu;\n\tuintptr_t curr_smbase;\n\tuintptr_t perm_smbase;\n\tp = arg;\n\truntime = p->runtime;\n\tcpu = p->cpu;\n\tcurr_smbase = runtime->smbase;\n\tif (cpu >= CONFIG_MAX_CPUS) {\n\t\tprintk(BIOS_CRIT,\n\t\t       \"Invalid CPU number assigned in SMM stub: %d\\n\", cpu);\n\t\treturn;\n\t}\n\tperm_smbase = mp_state.perm_smbase;\n\tperm_smbase -= cpu * runtime->save_state_size;\n\tprintk(BIOS_DEBUG, \"New SMBASE 0x%08lx\\n\", perm_smbase);\n\tmp_state.ops.relocation_handler(cpu, curr_smbase, perm_smbase);\n\tif (CONFIG(STM)) {\n\t\tuintptr_t mseg;\n\t\tmseg = mp_state.perm_smbase +\n\t\t\t(mp_state.perm_smsize - CONFIG_MSEG_SIZE);\n\t\tstm_setup(mseg, p->cpu,\n\t\t\t\tperm_smbase,\n\t\t\t\tmp_state.perm_smbase,\n\t\t\t\truntime->start32_offset);\n\t}\n}", "target": 1}
{"code": "static int do_pages_stat(struct mm_struct *mm, struct page_to_node *pm)\n{\n\tdown_read(&mm->mmap_sem);\n\tfor ( ; pm->node != MAX_NUMNODES; pm++) {\n\t\tstruct vm_area_struct *vma;\n\t\tstruct page *page;\n\t\tint err;\n\t\terr = -EFAULT;\n\t\tvma = find_vma(mm, pm->addr);\n\t\tif (!vma)\n\t\t\tgoto set_status;\n\t\tpage = follow_page(vma, pm->addr, 0);\n\t\terr = PTR_ERR(page);\n\t\tif (IS_ERR(page))\n\t\t\tgoto set_status;\n\t\terr = -ENOENT;\n\t\tif (!page || PageReserved(page))\n\t\t\tgoto set_status;\n\t\terr = page_to_nid(page);\nset_status:\n\t\tpm->status = err;\n\t}\n\tup_read(&mm->mmap_sem);\n\treturn 0;\n}", "target": 0}
{"code": "int nfc_llcp_send_symm(struct nfc_dev *dev)\n{\n\tstruct sk_buff *skb;\n\tstruct nfc_llcp_local *local;\n\tu16 size = 0;\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\tsize += LLCP_HEADER_SIZE;\n\tsize += dev->tx_headroom + dev->tx_tailroom + NFC_HEADER_SIZE;\n\tskb = alloc_skb(size, GFP_KERNEL);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\tskb_reserve(skb, dev->tx_headroom + NFC_HEADER_SIZE);\n\tskb = llcp_add_header(skb, 0, 0, LLCP_PDU_SYMM);\n\t__net_timestamp(skb);\n\tnfc_llcp_send_to_raw_sock(local, skb, NFC_DIRECTION_TX);\n\treturn nfc_data_exchange(dev, local->target_idx, skb,\n\t\t\t\t nfc_llcp_recv, local);\n}", "target": 1}
{"code": "ext4_xattr_cache_find(struct inode *inode, struct ext4_xattr_header *header,\n\t\t      struct mb_cache_entry **pce)\n{\n\t__u32 hash = le32_to_cpu(header->h_hash);\n\tstruct mb_cache_entry *ce;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\tif (!header->h_hash)\n\t\treturn NULL;  \n\tea_idebug(inode, \"looking for cached blocks [%x]\", (int)hash);\nagain:\n\tce = mb_cache_entry_find_first(ext4_mb_cache, inode->i_sb->s_bdev,\n\t\t\t\t       hash);\n\twhile (ce) {\n\t\tstruct buffer_head *bh;\n\t\tif (IS_ERR(ce)) {\n\t\t\tif (PTR_ERR(ce) == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tbreak;\n\t\t}\n\t\tbh = sb_bread(inode->i_sb, ce->e_block);\n\t\tif (!bh) {\n\t\t\tEXT4_ERROR_INODE(inode, \"block %lu read error\",\n\t\t\t\t\t (unsigned long) ce->e_block);\n\t\t} else if (le32_to_cpu(BHDR(bh)->h_refcount) >=\n\t\t\t\tEXT4_XATTR_REFCOUNT_MAX) {\n\t\t\tea_idebug(inode, \"block %lu refcount %d>=%d\",\n\t\t\t\t  (unsigned long) ce->e_block,\n\t\t\t\t  le32_to_cpu(BHDR(bh)->h_refcount),\n\t\t\t\t\t  EXT4_XATTR_REFCOUNT_MAX);\n\t\t} else if (ext4_xattr_cmp(header, BHDR(bh)) == 0) {\n\t\t\t*pce = ce;\n\t\t\treturn bh;\n\t\t}\n\t\tbrelse(bh);\n\t\tce = mb_cache_entry_find_next(ce, inode->i_sb->s_bdev, hash);\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "static int parse_txq_params(struct nlattr *tb[],\n\t\t\t    struct ieee80211_txq_params *txq_params)\n{\n\tif (!tb[NL80211_TXQ_ATTR_AC] || !tb[NL80211_TXQ_ATTR_TXOP] ||\n\t    !tb[NL80211_TXQ_ATTR_CWMIN] || !tb[NL80211_TXQ_ATTR_CWMAX] ||\n\t    !tb[NL80211_TXQ_ATTR_AIFS])\n\t\treturn -EINVAL;\n\ttxq_params->ac = nla_get_u8(tb[NL80211_TXQ_ATTR_AC]);\n\ttxq_params->txop = nla_get_u16(tb[NL80211_TXQ_ATTR_TXOP]);\n\ttxq_params->cwmin = nla_get_u16(tb[NL80211_TXQ_ATTR_CWMIN]);\n\ttxq_params->cwmax = nla_get_u16(tb[NL80211_TXQ_ATTR_CWMAX]);\n\ttxq_params->aifs = nla_get_u8(tb[NL80211_TXQ_ATTR_AIFS]);\n\tif (txq_params->ac >= NL80211_NUM_ACS)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 0}
{"code": "SSLNetVConnection::advertise_next_protocol(SSL *ssl, const unsigned char **out, unsigned int *outlen, void * )\n{\n  SSLNetVConnection *netvc = SSLNetVCAccess(ssl);\n  ink_release_assert(netvc != nullptr);\n  if (netvc->npnSet && netvc->npnSet->advertiseProtocols(out, outlen)) {\n    return SSL_TLSEXT_ERR_OK;\n  }\n  return SSL_TLSEXT_ERR_NOACK;\n}", "target": 0}
{"code": "mm_answer_pam_start(int socket, Buffer *m)\n{\n\tchar *user;\n\tuser = buffer_get_string(m, NULL);\n\tstart_pam(user);\n\txfree(user);\n\treturn (0);\n}", "target": 0}
{"code": "    void CrwMap::encode0x1810(const Image&      image,\n                              const CrwMapping* pCrwMapping,\n                                    CiffHeader* pHead)\n    {\n        assert(pCrwMapping != 0);\n        assert(pHead != 0);\n        const ExifKey kX(\"Exif.Photo.PixelXDimension\");\n        const ExifKey kY(\"Exif.Photo.PixelYDimension\");\n        const ExifKey kO(\"Exif.Image.Orientation\");\n        const ExifData &exivData = image.exifData();\n        const ExifData::const_iterator edX = exivData.findKey(kX);\n        const ExifData::const_iterator edY = exivData.findKey(kY);\n        const ExifData::const_iterator edO = exivData.findKey(kO);\n        const ExifData::const_iterator edEnd = exivData.end();\n        CiffComponent* cc = pHead->findComponent(pCrwMapping->crwTagId_,\n                                                 pCrwMapping->crwDir_);\n        if (edX != edEnd || edY != edEnd || edO != edEnd) {\n            uint32_t size = 28;\n            if (cc) {\n              if (cc->size() < size)\n                throw Error(kerCorruptedMetadata);\n              size = cc->size();\n            }\n            DataBuf buf(size);\n            std::memset(buf.pData_, 0x0, buf.size_);\n            if (cc) std::memcpy(buf.pData_ + 8, cc->pData() + 8, cc->size() - 8);\n            if (edX != edEnd && edX->size() == 4) {\n                edX->copy(buf.pData_, pHead->byteOrder());\n            }\n            if (edY != edEnd && edY->size() == 4) {\n                edY->copy(buf.pData_ + 4, pHead->byteOrder());\n            }\n            int32_t d = 0;\n            if (edO != edEnd && edO->count() > 0 && edO->typeId() == unsignedShort) {\n                d = RotationMap::degrees(static_cast<uint16_t>(edO->toLong()));\n            }\n            l2Data(buf.pData_ + 12, d, pHead->byteOrder());\n            pHead->add(pCrwMapping->crwTagId_, pCrwMapping->crwDir_, buf);\n        }\n        else {\n            pHead->remove(pCrwMapping->crwTagId_, pCrwMapping->crwDir_);\n        }\n    } ", "target": 0}
{"code": "static void __init taa_select_mitigation(void)\n{\n\tu64 ia32_cap;\n\tif (!boot_cpu_has_bug(X86_BUG_TAA)) {\n\t\ttaa_mitigation = TAA_MITIGATION_OFF;\n\t\treturn;\n\t}\n\tif (!boot_cpu_has(X86_FEATURE_RTM)) {\n\t\ttaa_mitigation = TAA_MITIGATION_TSX_DISABLED;\n\t\tgoto out;\n\t}\n\tif (cpu_mitigations_off()) {\n\t\ttaa_mitigation = TAA_MITIGATION_OFF;\n\t\treturn;\n\t}\n\tif (taa_mitigation == TAA_MITIGATION_OFF &&\n\t    mds_mitigation == MDS_MITIGATION_OFF)\n\t\tgoto out;\n\tif (boot_cpu_has(X86_FEATURE_MD_CLEAR))\n\t\ttaa_mitigation = TAA_MITIGATION_VERW;\n\telse\n\t\ttaa_mitigation = TAA_MITIGATION_UCODE_NEEDED;\n\tia32_cap = x86_read_arch_cap_msr();\n\tif ( (ia32_cap & ARCH_CAP_MDS_NO) &&\n\t    !(ia32_cap & ARCH_CAP_TSX_CTRL_MSR))\n\t\ttaa_mitigation = TAA_MITIGATION_UCODE_NEEDED;\n\tstatic_branch_enable(&mds_user_clear);\n\tif (taa_nosmt || cpu_mitigations_auto_nosmt())\n\t\tcpu_smt_disable(false);\n\tif (mds_mitigation == MDS_MITIGATION_OFF &&\n\t    boot_cpu_has_bug(X86_BUG_MDS)) {\n\t\tmds_mitigation = MDS_MITIGATION_FULL;\n\t\tmds_select_mitigation();\n\t}\nout:\n\tpr_info(\"%s\\n\", taa_strings[taa_mitigation]);\n}", "target": 0}
{"code": "static inline int check_entry_size_and_hooks(struct arpt_entry *e,\n\t\t\t\t\t     struct xt_table_info *newinfo,\n\t\t\t\t\t     const unsigned char *base,\n\t\t\t\t\t     const unsigned char *limit,\n\t\t\t\t\t     const unsigned int *hook_entries,\n\t\t\t\t\t     const unsigned int *underflows,\n\t\t\t\t\t     unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct arpt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 0}
{"code": "RegexMatchExpression::RegexMatchExpression(StringData path, const BSONElement& e)\n    : LeafMatchExpression(REGEX, path),\n      _regex(e.regex()),\n      _flags(e.regexFlags()),\n      _re(new pcrecpp::RE(_regex.c_str(), flags2options(_flags.c_str()))) {\n    uassert(ErrorCodes::BadValue, \"regex not a regex\", e.type() == RegEx);\n    _init();\n}", "target": 0}
{"code": "CString CWebSock::GetSkinPath(const CString& sSkinName) {\n    CString sRet = CZNC::Get().GetZNCPath() + \"/webskins/\" + sSkinName;\n    if (!CFile::IsDir(sRet)) {\n        sRet = CZNC::Get().GetCurPath() + \"/webskins/\" + sSkinName;\n        if (!CFile::IsDir(sRet)) {\n            sRet = CString(_SKINDIR_) + \"/\" + sSkinName;\n        }\n    }\n    return sRet + \"/\";\n}", "target": 1}
{"code": "decode_NXAST_RAW_ENCAP(const struct nx_action_encap *nae,\n                       enum ofp_version ofp_version OVS_UNUSED,\n                       struct ofpbuf *out)\n{\n    struct ofpact_encap *encap;\n    const struct ofp_ed_prop_header *ofp_prop;\n    const size_t encap_ofs = out->size;\n    size_t props_len;\n    uint16_t n_props = 0;\n    int err;\n    encap = ofpact_put_ENCAP(out);\n    encap->ofpact.raw = NXAST_RAW_ENCAP;\n    switch (ntohl(nae->new_pkt_type)) {\n    case PT_ETH:\n    case PT_NSH:\n        break;\n    default:\n        return OFPERR_NXBAC_BAD_HEADER_TYPE;\n    }\n    encap->new_pkt_type = nae->new_pkt_type;\n    encap->hdr_size = ntohs(nae->hdr_size);\n    ofp_prop = nae->props;\n    props_len = ntohs(nae->len) - offsetof(struct nx_action_encap, props);\n    n_props = 0;\n    while (props_len > 0) {\n        err = decode_ed_prop(&ofp_prop, out, &props_len);\n        if (err) {\n            return err;\n        }\n        n_props++;\n    }\n    encap = ofpbuf_at_assert(out, encap_ofs, sizeof *encap);\n    encap->n_props = n_props;\n    out->header = &encap->ofpact;\n    ofpact_finish_ENCAP(out, &encap);\n    return 0;\n}", "target": 0}
{"code": "void LibRaw::fuji_compressed_load_raw()\n{\n  struct fuji_compressed_params common_info;\n  int cur_block;\n  unsigned line_size, *block_sizes;\n  INT64 raw_offset, *raw_block_offsets;\n  init_fuji_compr(&common_info);\n  line_size = sizeof(ushort) * (common_info.line_width + 2);\n  block_sizes = (unsigned *)malloc(\n      sizeof(unsigned) * libraw_internal_data.unpacker_data.fuji_total_blocks);\n  merror(block_sizes, \"fuji_compressed_load_raw()\");\n  raw_block_offsets = (INT64 *)malloc(\n      sizeof(INT64) * libraw_internal_data.unpacker_data.fuji_total_blocks);\n  merror(raw_block_offsets, \"fuji_compressed_load_raw()\");\n  raw_offset =\n      sizeof(unsigned) * libraw_internal_data.unpacker_data.fuji_total_blocks;\n  if (raw_offset & 0xC)\n    raw_offset += 0x10 - (raw_offset & 0xC);\n  raw_offset += libraw_internal_data.unpacker_data.data_offset;\n  libraw_internal_data.internal_data.input->seek(\n      libraw_internal_data.unpacker_data.data_offset, SEEK_SET);\n  libraw_internal_data.internal_data.input->read(\n      block_sizes, 1,\n      sizeof(unsigned) * libraw_internal_data.unpacker_data.fuji_total_blocks);\n  raw_block_offsets[0] = raw_offset;\n  for (cur_block = 0;\n       cur_block < libraw_internal_data.unpacker_data.fuji_total_blocks;\n       cur_block++)\n  {\n    unsigned bsize = sgetn(4, (uchar *)(block_sizes + cur_block));\n    block_sizes[cur_block] = bsize;\n  }\n  for (cur_block = 1;\n       cur_block < libraw_internal_data.unpacker_data.fuji_total_blocks;\n       cur_block++)\n    raw_block_offsets[cur_block] =\n        raw_block_offsets[cur_block - 1] + block_sizes[cur_block - 1];\n  fuji_decode_loop(&common_info,\n                   libraw_internal_data.unpacker_data.fuji_total_blocks,\n                   raw_block_offsets, block_sizes);\n  free(block_sizes);\n  free(raw_block_offsets);\n  free(common_info.q_table);\n}", "target": 0}
{"code": "static int f2fs_mpage_readpages(struct address_space *mapping,\n\t\t\tstruct list_head *pages, struct page *page,\n\t\t\tunsigned nr_pages, bool is_readahead)\n{\n\tstruct bio *bio = NULL;\n\tsector_t last_block_in_bio = 0;\n\tstruct inode *inode = mapping->host;\n\tstruct f2fs_map_blocks map;\n\tint ret = 0;\n\tmap.m_pblk = 0;\n\tmap.m_lblk = 0;\n\tmap.m_len = 0;\n\tmap.m_flags = 0;\n\tmap.m_next_pgofs = NULL;\n\tmap.m_next_extent = NULL;\n\tmap.m_seg_type = NO_CHECK_TYPE;\n\tmap.m_may_create = false;\n\tfor (; nr_pages; nr_pages--) {\n\t\tif (pages) {\n\t\t\tpage = list_last_entry(pages, struct page, lru);\n\t\t\tprefetchw(&page->flags);\n\t\t\tlist_del(&page->lru);\n\t\t\tif (add_to_page_cache_lru(page, mapping,\n\t\t\t\t\t\t  page->index,\n\t\t\t\t\t\t  readahead_gfp_mask(mapping)))\n\t\t\t\tgoto next_page;\n\t\t}\n\t\tret = f2fs_read_single_page(inode, page, nr_pages, &map, &bio,\n\t\t\t\t\t&last_block_in_bio, is_readahead);\n\t\tif (ret) {\n\t\t\tSetPageError(page);\n\t\t\tzero_user_segment(page, 0, PAGE_SIZE);\n\t\t\tunlock_page(page);\n\t\t}\nnext_page:\n\t\tif (pages)\n\t\t\tput_page(page);\n\t}\n\tBUG_ON(pages && !list_empty(pages));\n\tif (bio)\n\t\t__submit_bio(F2FS_I_SB(inode), bio, DATA);\n\treturn pages ? 0 : ret;\n}", "target": 1}
{"code": "static int rngapi_reset(struct crypto_rng *tfm, const u8 *seed,\n\t\t\tunsigned int slen)\n{\n\tu8 *buf = NULL;\n\tu8 *src = (u8 *)seed;\n\tint err;\n\tif (slen) {\n\t\tbuf = kmalloc(slen, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(buf, seed, slen);\n\t\tsrc = buf;\n\t}\n\terr = crypto_old_rng_alg(tfm)->rng_reset(tfm, src, slen);\n\tkzfree(buf);\n\treturn err;\n}", "target": 1}
{"code": "void ntlm_print_message_fields(NTLM_MESSAGE_FIELDS* fields, const char* name)\n{\n\tWLog_DBG(TAG, \"%s (Len: %\"PRIu16\" MaxLen: %\"PRIu16\" BufferOffset: %\"PRIu32\")\",\n\t         name, fields->Len, fields->MaxLen, fields->BufferOffset);\n\tif (fields->Len > 0)\n\t\twinpr_HexDump(TAG, WLOG_DEBUG, fields->Buffer, fields->Len);\n}", "target": 1}
{"code": "static ssize_t slab_attr_show(struct kobject *kobj,\n\t\t\t\tstruct attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct slab_attribute *attribute;\n\tstruct kmem_cache *s;\n\tint err;\n\tattribute = to_slab_attr(attr);\n\ts = to_slab(kobj);\n\tif (!attribute->show)\n\t\treturn -EIO;\n\terr = attribute->show(s, buf);\n\treturn err;\n}", "target": 0}
{"code": "template <> HeaderMapImpl::StaticLookupTable<RequestHeaderMap>::StaticLookupTable() {\n#define REGISTER_DEFAULT_REQUEST_HEADER(name)                                                      \\\n  CustomInlineHeaderRegistry::registerInlineHeader<RequestHeaderMap::header_map_type>(             \\\n      Headers::get().name);\n  INLINE_REQ_HEADERS(REGISTER_DEFAULT_REQUEST_HEADER)\n  INLINE_REQ_RESP_HEADERS(REGISTER_DEFAULT_REQUEST_HEADER)\n  finalizeTable();\n  const auto handle =\n      CustomInlineHeaderRegistry::getInlineHeader<RequestHeaderMap::header_map_type>(\n          Headers::get().Host);\n  add(Headers::get().HostLegacy.get().c_str(), [handle](HeaderMapImpl& h) -> StaticLookupResponse {\n    return {&h.inlineHeaders()[handle.value().it_->second], &handle.value().it_->first};\n  });\n}", "target": 0}
{"code": "qemuProcessHandleMonitorEOF(qemuMonitorPtr mon,\n                            virDomainObjPtr vm,\n                            void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    qemuDomainObjPrivatePtr priv;\n    struct qemuProcessEvent *processEvent;\n    virObjectLock(vm);\n    VIR_DEBUG(\"Received EOF on %p '%s'\", vm, vm->def->name);\n    priv = vm->privateData;\n    if (priv->beingDestroyed) {\n        VIR_DEBUG(\"Domain is being destroyed, EOF is expected\");\n        goto cleanup;\n    }\n    processEvent = g_new0(struct qemuProcessEvent, 1);\n    processEvent->eventType = QEMU_PROCESS_EVENT_MONITOR_EOF;\n    processEvent->vm = virObjectRef(vm);\n    if (virThreadPoolSendJob(driver->workerPool, 0, processEvent) < 0) {\n        virObjectUnref(vm);\n        qemuProcessEventFree(processEvent);\n        goto cleanup;\n    }\n    qemuMonitorUnregister(mon);\n    qemuDomainDestroyNamespace(driver, vm);\n cleanup:\n    virObjectUnlock(vm);\n}", "target": 1}
{"code": "static void sdhci_send_command(SDHCIState *s)\n{\n    SDRequest request;\n    uint8_t response[16];\n    int rlen;\n    bool timeout = false;\n    s->errintsts = 0;\n    s->acmd12errsts = 0;\n    request.cmd = s->cmdreg >> 8;\n    request.arg = s->argument;\n    trace_sdhci_send_command(request.cmd, request.arg);\n    rlen = sdbus_do_command(&s->sdbus, &request, response);\n    if (s->cmdreg & SDHC_CMD_RESPONSE) {\n        if (rlen == 4) {\n            s->rspreg[0] = ldl_be_p(response);\n            s->rspreg[1] = s->rspreg[2] = s->rspreg[3] = 0;\n            trace_sdhci_response4(s->rspreg[0]);\n        } else if (rlen == 16) {\n            s->rspreg[0] = ldl_be_p(&response[11]);\n            s->rspreg[1] = ldl_be_p(&response[7]);\n            s->rspreg[2] = ldl_be_p(&response[3]);\n            s->rspreg[3] = (response[0] << 16) | (response[1] << 8) |\n                            response[2];\n            trace_sdhci_response16(s->rspreg[3], s->rspreg[2],\n                                   s->rspreg[1], s->rspreg[0]);\n        } else {\n            timeout = true;\n            trace_sdhci_error(\"timeout waiting for command response\");\n            if (s->errintstsen & SDHC_EISEN_CMDTIMEOUT) {\n                s->errintsts |= SDHC_EIS_CMDTIMEOUT;\n                s->norintsts |= SDHC_NIS_ERR;\n            }\n        }\n        if (!(s->quirks & SDHCI_QUIRK_NO_BUSY_IRQ) &&\n            (s->norintstsen & SDHC_NISEN_TRSCMP) &&\n            (s->cmdreg & SDHC_CMD_RESPONSE) == SDHC_CMD_RSP_WITH_BUSY) {\n            s->norintsts |= SDHC_NIS_TRSCMP;\n        }\n    }\n    if (s->norintstsen & SDHC_NISEN_CMDCMP) {\n        s->norintsts |= SDHC_NIS_CMDCMP;\n    }\n    sdhci_update_irq(s);\n    if (!timeout && s->blksize && (s->cmdreg & SDHC_CMD_DATA_PRESENT)) {\n        s->data_count = 0;\n        sdhci_data_transfer(s);\n    }\n}", "target": 0}
{"code": "static void zipfileResetCursor(ZipfileCsr *pCsr){\n  ZipfileEntry *p;\n  ZipfileEntry *pNext;\n  pCsr->bEof = 0;\n  if( pCsr->pFile ){\n    fclose(pCsr->pFile);\n    pCsr->pFile = 0;\n    zipfileEntryFree(pCsr->pCurrent);\n    pCsr->pCurrent = 0;\n  }\n  for(p=pCsr->pFreeEntry; p; p=pNext){\n    pNext = p->pNext;\n    zipfileEntryFree(p);\n  }\n}", "target": 0}
{"code": "void rdma_set_service_type(struct rdma_cm_id *id, int tos)\n{\n\tstruct rdma_id_private *id_priv;\n\tid_priv = container_of(id, struct rdma_id_private, id);\n\tmutex_lock(&id_priv->qp_mutex);\n\tid_priv->tos = (u8) tos;\n\tid_priv->tos_set = true;\n\tmutex_unlock(&id_priv->qp_mutex);\n}", "target": 0}
{"code": "static inline int xsave_state(struct xsave_struct *fx, u64 mask)\n{\n\tu32 lmask = mask;\n\tu32 hmask = mask >> 32;\n\tint err = 0;\n\talternative_input_2(\n\t\t\"1:\"XSAVE,\n\t\t\"1:\"XSAVEOPT,\n\t\tX86_FEATURE_XSAVEOPT,\n\t\t\"1:\"XSAVES,\n\t\tX86_FEATURE_XSAVES,\n\t\t[fx] \"D\" (fx), \"a\" (lmask), \"d\" (hmask) :\n\t\t\"memory\");\n\tasm volatile(\"2:\\n\\t\"\n\t\t     xstate_fault\n\t\t     : \"0\" (0)\n\t\t     : \"memory\");\n\treturn err;\n}", "target": 1}
{"code": "localtime_r(const time_t *t, struct tm *tm)\n{\n    auto struct tm *tmp = localtime(t);\n    if (tmp)\n\t*tm = *tmp;\n    return tmp;\n}", "target": 0}
{"code": "tTcpIpPacketParsingResult ParaNdis_CheckSumVerifyFlat(\n                                                PVOID pBuffer,\n                                                ULONG ulDataLength,\n                                                ULONG flags,\n                                                LPCSTR caller)\n{\n    tCompletePhysicalAddress SGBuffer;\n    SGBuffer.Virtual = pBuffer;\n    SGBuffer.size = ulDataLength;\n    return ParaNdis_CheckSumVerify(&SGBuffer, ulDataLength, 0, flags, caller);\n}", "target": 1}
{"code": "void slice_segment_header::compute_derived_values(const pic_parameter_set* pps)\n{\n  SliceQPY = pps->pic_init_qp + slice_qp_delta;\n  switch (slice_type)\n    {\n    case SLICE_TYPE_I: initType = 0; break;\n    case SLICE_TYPE_P: initType = cabac_init_flag + 1; break;\n    case SLICE_TYPE_B: initType = 2 - cabac_init_flag; break;\n    }\n  MaxNumMergeCand = 5-five_minus_max_num_merge_cand;\n}", "target": 0}
{"code": "static int __nla_validate_parse(const struct nlattr *head, int len, int maxtype,\n\t\t\t\tconst struct nla_policy *policy,\n\t\t\t\tunsigned int validate,\n\t\t\t\tstruct netlink_ext_ack *extack,\n\t\t\t\tstruct nlattr **tb)\n{\n\tconst struct nlattr *nla;\n\tint rem;\n\tif (tb)\n\t\tmemset(tb, 0, sizeof(struct nlattr *) * (maxtype + 1));\n\tnla_for_each_attr(nla, head, len, rem) {\n\t\tu16 type = nla_type(nla);\n\t\tif (type == 0 || type > maxtype) {\n\t\t\tif (validate & NL_VALIDATE_MAXTYPE) {\n\t\t\t\tNL_SET_ERR_MSG_ATTR(extack, nla,\n\t\t\t\t\t\t    \"Unknown attribute type\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (policy) {\n\t\t\tint err = validate_nla(nla, maxtype, policy,\n\t\t\t\t\t       validate, extack);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (tb)\n\t\t\ttb[type] = (struct nlattr *)nla;\n\t}\n\tif (unlikely(rem > 0)) {\n\t\tpr_warn_ratelimited(\"netlink: %d bytes leftover after parsing attributes in process `%s'.\\n\",\n\t\t\t\t    rem, current->comm);\n\t\tNL_SET_ERR_MSG(extack, \"bytes leftover after parsing attributes\");\n\t\tif (validate & NL_VALIDATE_TRAILING)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "monitor_sync(struct monitor *pmonitor)\n{\n\tif (options.compression) {\n\t\tmm_share_sync(&pmonitor->m_zlib, &pmonitor->m_zback);\n\t}\n}", "target": 1}
{"code": "datetime_s_jisx0301(int argc, VALUE *argv, VALUE klass)\n{\n    VALUE str, sg, opt;\n    rb_scan_args(argc, argv, \"02:\", &str, &sg, &opt);\n    if (!NIL_P(opt)) argc--;\n    switch (argc) {\n      case 0:\n\tstr = rb_str_new2(\"-4712-01-01T00:00:00+00:00\");\n      case 1:\n\tsg = INT2FIX(DEFAULT_SG);\n    }\n    {\n        int argc2 = 1;\n        VALUE argv2[2];\n        argv2[0] = str;\n        argv2[1] = opt;\n        if (!NIL_P(opt)) argc2++;\n\tVALUE hash = date_s__jisx0301(argc2, argv2, klass);\n\treturn dt_new_by_frags(klass, hash, sg);\n    }\n}", "target": 0}
{"code": "     res1 = cimg::eval(\"cos(x)^2 + sin(y)^2\",2,2),  \n     res2 = cimg::eval(0,1,1);                    \n     \\endcode\n  **/", "target": 0}
{"code": "static int ExecuteHelp( SQLHDBC hDbc, char *szSQL, char cDelimiter, int bColumnNames, int bHTMLTable )\n{\n    char            szTable[250]                        = \"\";\n    SQLHSTMT        hStmt;\n    SQLTCHAR        szSepLine[32001];   \n    SQLLEN          nRows               = 0;\n    szSepLine[ 0 ] = 0;\n    if ( SQLAllocStmt( hDbc, &hStmt ) != SQL_SUCCESS )\n    {\n        if ( bVerbose ) DumpODBCLog( hEnv, hDbc, 0 );\n        fprintf( stderr, \"[ISQL]ERROR: Could not SQLAllocStmt\\n\" );\n        return 0;\n    }\n    if ( iniElement( szSQL, ' ', '\\0', 1, szTable, sizeof(szTable) ) == INI_SUCCESS )\n    {\n        SQLWCHAR tname[ 1024 ];\n        ansi_to_unicode( szTable, tname );\n        if ( SQLColumns( hStmt, NULL, 0, NULL, 0, tname, SQL_NTS, NULL, 0 ) != SQL_SUCCESS )\n        {\n            if ( bVerbose ) DumpODBCLog( hEnv, hDbc, hStmt );\n            fprintf( stderr, \"[ISQL]ERROR: Could not SQLColumns\\n\" );\n            SQLFreeStmt( hStmt, SQL_DROP );\n            return 0;\n        }\n    }\n    else\n    {\n        if ( SQLTables( hStmt, NULL, 0, NULL, 0, NULL, 0, NULL, 0 ) != SQL_SUCCESS )\n        {\n            if ( bVerbose ) DumpODBCLog( hEnv, hDbc, hStmt );\n            fprintf( stderr, \"[ISQL]ERROR: Could not SQLTables\\n\" );\n            SQLFreeStmt( hStmt, SQL_DROP );\n            return 0;\n        }\n    }\n    if ( bHTMLTable )\n        WriteHeaderHTMLTable( hStmt );\n    else if ( cDelimiter == 0 )\n        UWriteHeaderNormal( hStmt, szSepLine );\n    else if ( cDelimiter && bColumnNames )\n        WriteHeaderDelimited( hStmt, cDelimiter );\n    if ( bHTMLTable )\n        WriteBodyHTMLTable( hStmt );\n    else if ( cDelimiter == 0 )\n        nRows = WriteBodyNormal( hStmt );\n    else\n        WriteBodyDelimited( hStmt, cDelimiter );\n    if ( bHTMLTable )\n        WriteFooterHTMLTable( hStmt );\n    else if ( cDelimiter == 0 )\n        UWriteFooterNormal( hStmt, szSepLine, nRows );\n    SQLFreeStmt( hStmt, SQL_DROP );\n    return 1;\n}", "target": 0}
{"code": "static void set_ntacl_dacl(struct user_namespace *user_ns,\n\t\t\t   struct smb_acl *pndacl,\n\t\t\t   struct smb_acl *nt_dacl,\n\t\t\t   const struct smb_sid *pownersid,\n\t\t\t   const struct smb_sid *pgrpsid,\n\t\t\t   struct smb_fattr *fattr)\n{\n\tstruct smb_ace *ntace, *pndace;\n\tint nt_num_aces = le32_to_cpu(nt_dacl->num_aces), num_aces = 0;\n\tunsigned short size = 0;\n\tint i;\n\tpndace = (struct smb_ace *)((char *)pndacl + sizeof(struct smb_acl));\n\tif (nt_num_aces) {\n\t\tntace = (struct smb_ace *)((char *)nt_dacl + sizeof(struct smb_acl));\n\t\tfor (i = 0; i < nt_num_aces; i++) {\n\t\t\tmemcpy((char *)pndace + size, ntace, le16_to_cpu(ntace->size));\n\t\t\tsize += le16_to_cpu(ntace->size);\n\t\t\tntace = (struct smb_ace *)((char *)ntace + le16_to_cpu(ntace->size));\n\t\t\tnum_aces++;\n\t\t}\n\t}\n\tset_posix_acl_entries_dacl(user_ns, pndace, fattr,\n\t\t\t\t   &num_aces, &size, nt_num_aces);\n\tpndacl->num_aces = cpu_to_le32(num_aces);\n\tpndacl->size = cpu_to_le16(le16_to_cpu(pndacl->size) + size);\n}", "target": 1}
{"code": "std::vector<std::vector<float>> DefaultColorTable(int depth) {\n  std::vector<std::vector<float>> color_table;\n  color_table.emplace_back(std::vector<float>({1, 1, 0, 1}));      \n  color_table.emplace_back(std::vector<float>({0, 0, 1, 1}));      \n  color_table.emplace_back(std::vector<float>({1, 0, 0, 1}));      \n  color_table.emplace_back(std::vector<float>({0, 1, 0, 1}));      \n  color_table.emplace_back(std::vector<float>({0.5, 0, 0.5, 1}));  \n  color_table.emplace_back(std::vector<float>({0.5, 0.5, 0, 1}));  \n  color_table.emplace_back(std::vector<float>({0.5, 0, 0, 1}));    \n  color_table.emplace_back(std::vector<float>({0, 0, 0.5, 1}));  \n  color_table.emplace_back(std::vector<float>({0, 1, 1, 1}));    \n  color_table.emplace_back(std::vector<float>({1, 0, 1, 1}));    \n  if (depth == 1) {\n    for (int64 i = 0; i < color_table.size(); i++) {\n      color_table[i][0] = 1;\n    }\n  }\n  return color_table;\n}", "target": 0}
{"code": "int nfc_dep_link_down(struct nfc_dev *dev)\n{\n\tint rc = 0;\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\tif (!dev->ops->dep_link_down)\n\t\treturn -EOPNOTSUPP;\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->dep_link_up == false) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\trc = dev->ops->dep_link_down(dev);\n\tif (!rc) {\n\t\tdev->dep_link_up = false;\n\t\tdev->active_target = NULL;\n\t\tdev->rf_mode = NFC_RF_NONE;\n\t\tnfc_llcp_mac_is_down(dev);\n\t\tnfc_genl_dep_link_down_event(dev);\n\t}\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "inline typename V::VariantType FBUnserializer<V>::unserializeThing() {\n  size_t code = nextCode();\n  switch (code) {\n    case FB_SERIALIZE_BYTE:\n    case FB_SERIALIZE_I16:\n    case FB_SERIALIZE_I32:\n    case FB_SERIALIZE_I64:\n      return V::fromInt64(unserializeInt64());\n    case FB_SERIALIZE_VARCHAR:\n    case FB_SERIALIZE_STRING:\n      return V::fromString(unserializeString());\n    case FB_SERIALIZE_STRUCT:\n      return V::fromMap(unserializeMap());\n    case FB_SERIALIZE_NULL:\n      ++p_;\n      return V::createNull();\n    case FB_SERIALIZE_DOUBLE:\n      return V::fromDouble(unserializeDouble());\n    case FB_SERIALIZE_BOOLEAN:\n      return V::fromBool(unserializeBoolean());\n    case FB_SERIALIZE_VECTOR:\n      return V::fromVector(unserializeVector());\n    case FB_SERIALIZE_LIST:\n      return V::fromVector(unserializeList());\n    case FB_SERIALIZE_SET:\n      return V::fromSet(unserializeSet());\n    default:\n      throw UnserializeError(\"Invalid code: \" + folly::to<std::string>(code)\n                             + \" at location \" + folly::to<std::string>(p_));\n  }\n}", "target": 1}
{"code": "spnego_gss_wrap_size_limit(\n\tOM_uint32\t*minor_status,\n\tconst gss_ctx_id_t context_handle,\n\tint\t\tconf_req_flag,\n\tgss_qop_t\tqop_req,\n\tOM_uint32\treq_output_size,\n\tOM_uint32\t*max_input_size)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_size_limit(minor_status,\n\t\t\t\tcontext_handle,\n\t\t\t\tconf_req_flag,\n\t\t\t\tqop_req,\n\t\t\t\treq_output_size,\n\t\t\t\tmax_input_size);\n\treturn (ret);\n}", "target": 1}
{"code": "static void update_read_synchronize(rdpUpdate* update, wStream* s)\n{\n\tWINPR_UNUSED(update);\n\tStream_Seek_UINT16(s); \n}", "target": 1}
{"code": "comics_remove_dir (gchar *path_name)\n{\n\tGDir  *content_dir;\n\tconst gchar *filename;\n\tgchar *filename_with_path;\n\tif (g_file_test (path_name, G_FILE_TEST_IS_DIR)) {\n\t\tcontent_dir = g_dir_open  (path_name, 0, NULL);\n\t\tfilename  = g_dir_read_name (content_dir);\n\t\twhile (filename) {\n\t\t\tfilename_with_path =\n\t\t\t\tg_build_filename (path_name,\n\t\t\t\t\t\t  filename, NULL);\n\t\t\tcomics_remove_dir (filename_with_path);\n\t\t\tg_free (filename_with_path);\n\t\t\tfilename = g_dir_read_name (content_dir);\n\t\t}\n\t\tg_dir_close (content_dir);\n\t}\n\treturn (g_remove (path_name));\n}", "target": 1}
{"code": "char *get_refs_directory(void)\n{\n\tif (!git_refs_dir)\n\t\tsetup_git_env();\n\treturn git_refs_dir;\n}", "target": 0}
{"code": "init_ext2_xattr(void)\n{\n\text2_xattr_cache = mb_cache_create(\"ext2_xattr\", 6);\n\tif (!ext2_xattr_cache)\n\t\treturn -ENOMEM;\n\treturn 0;\n}", "target": 1}
{"code": "static void __net_random_once_deferred(struct work_struct *w)\n{\n\tstruct __net_random_once_work *work =\n\t\tcontainer_of(w, struct __net_random_once_work, work);\n\tif (!static_key_enabled(work->key))\n\t\tstatic_key_slow_inc(work->key);\n\tkfree(work);\n}", "target": 1}
{"code": "static int do_insn_fetch(struct x86_emulate_ctxt *ctxt,\n\t\t\t struct x86_emulate_ops *ops,\n\t\t\t unsigned long eip, void *dest, unsigned size)\n{\n\tint rc = 0;\n\teip += ctxt->cs_base;\n\twhile (size--) {\n\t\trc = do_fetch_insn_byte(ctxt, ops, eip++, dest++);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int check_is_mount_child(void *p)\n{\n\tconst char **a = p;\n\tconst char *last = a[0];\n\tconst char *mnt = a[1];\n\tint res;\n\tconst char *procmounts = \"/proc/mounts\";\n\tint found;\n\tFILE *fp;\n\tstruct mntent *entp;\n\tint count;\n\tres = mount(\"\", \"/\", \"\", MS_PRIVATE | MS_REC, NULL);\n\tif (res == -1) {\n\t\tfprintf(stderr, \"%s: failed to mark mounts private: %s\\n\",\n\t\t\tprogname, strerror(errno));\n\t\treturn 1;\n\t}\n\tfp = setmntent(procmounts, \"r\");\n\tif (fp == NULL) {\n\t\tfprintf(stderr, \"%s: failed to open %s: %s\\n\", progname,\n\t\t\tprocmounts, strerror(errno));\n\t\treturn 1;\n\t}\n\tcount = 0;\n\twhile (getmntent(fp) != NULL)\n\t\tcount++;\n\tendmntent(fp);\n\tfp = setmntent(procmounts, \"r\");\n\tif (fp == NULL) {\n\t\tfprintf(stderr, \"%s: failed to open %s: %s\\n\", progname,\n\t\t\tprocmounts, strerror(errno));\n\t\treturn 1;\n\t}\n\tres = mount(\".\", \"/\", \"\", MS_BIND | MS_REC, NULL);\n\tif (res == -1) {\n\t\tfprintf(stderr, \"%s: failed to bind parent to /: %s\\n\",\n\t\t\tprogname, strerror(errno));\n\t\treturn 1;\n\t}\n\tfound = 0;\n\twhile ((entp = getmntent(fp)) != NULL) {\n\t\tif (count > 0) {\n\t\t\tcount--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (entp->mnt_dir[0] == '/' &&\n\t\t    strcmp(entp->mnt_dir + 1, last) == 0) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tendmntent(fp);\n\tif (!found) {\n\t\tfprintf(stderr, \"%s: %s not mounted\\n\", progname, mnt);\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "certstack_create(struct cert_stack **result)\n{\n\tstruct cert_stack *stack;\n\tstack = malloc(sizeof(struct cert_stack));\n\tif (stack == NULL)\n\t\treturn pr_enomem();\n\tstack->x509s = sk_X509_new_null();\n\tif (stack->x509s == NULL) {\n\t\tfree(stack);\n\t\treturn val_crypto_err(\"sk_X509_new_null() returned NULL\");\n\t}\n\tSLIST_INIT(&stack->defers);\n\tSLIST_INIT(&stack->metas);\n\tSLIST_INIT(&stack->levels);\n\t*result = stack;\n\treturn 0;\n}", "target": 1}
{"code": "void ConnPoolImplBase::checkForIdleAndCloseIdleConnsIfDraining() {\n  if (is_draining_for_deletion_) {\n    closeIdleConnectionsForDrainingPool();\n  }\n  if (isIdleImpl()) {\n    ENVOY_LOG(debug, \"invoking idle callbacks - is_draining_for_deletion_={}\",\n              is_draining_for_deletion_);\n    for (const Instance::IdleCb& cb : idle_callbacks_) {\n      cb();\n    }\n  }\n}", "target": 1}
{"code": "minimask_equal(const struct minimask *a, const struct minimask *b)\n{\n    return !memcmp(a, b, sizeof *a\n                   + MINIFLOW_VALUES_SIZE(miniflow_n_values(&a->masks)));\n}", "target": 1}
{"code": "incomplete_transaction_log(uschar *what)\n{\nif (sender_address == NULL ||                 \n    !LOGGING(smtp_incomplete_transaction))\n  return;\nif (recipients_count > 0)\n  {\n  int i;\n  raw_recipients = store_get(recipients_count * sizeof(uschar *));\n  for (i = 0; i < recipients_count; i++)\n    raw_recipients[i] = recipients_list[i].address;\n  raw_recipients_count = recipients_count;\n  }\nlog_write(L_smtp_incomplete_transaction, LOG_MAIN|LOG_SENDER|LOG_RECIPIENTS,\n  \"%s incomplete transaction (%s)\", host_and_ident(TRUE), what);\n}", "target": 0}
{"code": "check_entry_size_and_hooks(struct ip6t_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\tif (!ip6_checkentry(&e->ipv6))\n\t\treturn -EINVAL;\n\terr = xt_check_entry_offsets(e, e->target_offset, e->next_offset);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 1}
{"code": "ex_put(exarg_T *eap)\n{\n    if (eap->line2 == 0)\n    {\n\teap->line2 = 1;\n\teap->forceit = TRUE;\n    }\n    curwin->w_cursor.lnum = eap->line2;\n    do_put(eap->regname, NULL, eap->forceit ? BACKWARD : FORWARD, 1L,\n\t\t\t\t\t\t       PUT_LINE|PUT_CURSLINE);\n}", "target": 1}
{"code": "and_code_range_buf(BBuf* bbuf1, int not1, BBuf* bbuf2, int not2, BBuf** pbuf, ScanEnv* env)\n{\n  int r;\n  OnigCodePoint i, j, n1, n2, *data1, *data2;\n  OnigCodePoint from, to, from1, to1, from2, to2;\n  *pbuf = (BBuf* )NULL;\n  if (IS_NULL(bbuf1)) {\n    if (not1 != 0 && IS_NOT_NULL(bbuf2)) \n      return bbuf_clone(pbuf, bbuf2);\n    return 0;\n  }\n  else if (IS_NULL(bbuf2)) {\n    if (not2 != 0)\n      return bbuf_clone(pbuf, bbuf1);\n    return 0;\n  }\n  if (not1 != 0)\n    SWAP_BBUF_NOT(bbuf1, not1, bbuf2, not2);\n  data1 = (OnigCodePoint* )(bbuf1->p);\n  data2 = (OnigCodePoint* )(bbuf2->p);\n  GET_CODE_POINT(n1, data1);\n  GET_CODE_POINT(n2, data2);\n  data1++;\n  data2++;\n  if (not2 == 0 && not1 == 0) { \n    for (i = 0; i < n1; i++) {\n      from1 = data1[i*2];\n      to1   = data1[i*2+1];\n      for (j = 0; j < n2; j++) {\n\tfrom2 = data2[j*2];\n\tto2   = data2[j*2+1];\n\tif (from2 > to1) break;\n\tif (to2 < from1) continue;\n\tfrom = MAX(from1, from2);\n\tto   = MIN(to1, to2);\n\tr = add_code_range_to_buf(pbuf, env, from, to);\n\tif (r != 0) return r;\n      }\n    }\n  }\n  else if (not1 == 0) { \n    for (i = 0; i < n1; i++) {\n      from1 = data1[i*2];\n      to1   = data1[i*2+1];\n      r = and_code_range1(pbuf, env, from1, to1, data2, n2);\n      if (r != 0) return r;\n    }\n  }\n  return 0;\n}", "target": 0}
{"code": "wsemul_vt100_output_dcs(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tu_int newstate = VT100_EMUL_STATE_DCS;\n\tswitch (instate->inchar) {\n\tcase '0': case '1': case '2': case '3': case '4':\n\tcase '5': case '6': case '7': case '8': case '9':\n\t\tif (edp->nargs > VT100_EMUL_NARGS - 1)\n\t\t\tbreak;\n\t\tedp->args[edp->nargs] = (edp->args[edp->nargs] * 10) +\n\t\t    (instate->inchar - '0');\n\t\tbreak;\n\tcase ';': \n\t\tedp->nargs++;\n\t\tbreak;\n\tdefault:\n\t\tedp->nargs++;\n\t\tif (edp->nargs > VT100_EMUL_NARGS) {\n#ifdef VT100_DEBUG\n\t\t\tprintf(\"vt100: too many arguments\\n\");\n#endif\n\t\t\tedp->nargs = VT100_EMUL_NARGS;\n\t\t}\n\t\tnewstate = VT100_EMUL_STATE_STRING;\n\t\tswitch (instate->inchar) {\n\t\tcase '$':\n\t\t\tnewstate = VT100_EMUL_STATE_DCS_DOLLAR;\n\t\t\tbreak;\n\t\tcase '{': \t\n\t\tcase '!': \n\t\tcase '|': \n#ifdef VT100_PRINTNOTIMPL\n\t\t\tprintf(\"DCS%c ignored\\n\", (char)instate->inchar);\n#endif\n\t\t\tbreak;\n\t\tdefault:\n#ifdef VT100_PRINTUNKNOWN\n\t\t\tprintf(\"DCS %x (%d, %d) unknown\\n\", instate->inchar,\n\t\t\t    ARG(0), ARG(1));\n#endif\n\t\t\tbreak;\n\t\t}\n\t}\n\tedp->state = newstate;\n\treturn 0;\n}", "target": 1}
{"code": "bytesPerDeepLineTable (const Header &header,\n                       int minY, int maxY,\n                       const char* base,\n                       int xStride,\n                       int yStride,\n                       vector<size_t> &bytesPerLine)\n{\n    const Box2i &dataWindow = header.dataWindow();\n    const ChannelList &channels = header.channels();\n    for (ChannelList::ConstIterator c = channels.begin();\n         c != channels.end();\n         ++c)\n    {\n        const int ySampling = abs(c.channel().ySampling);\n        const int xSampling = abs(c.channel().xSampling);\n        const int pixelSize = pixelTypeSize (c.channel().type);\n        const int sampleMinY = roundToNextMultiple(minY, ySampling);\n        const int sampleMaxY = roundToPrevMultiple(maxY, ySampling);\n        const int sampleMinX = roundToNextMultiple(dataWindow.min.x, xSampling);\n        const int sampleMaxX = roundToPrevMultiple(dataWindow.max.x, xSampling);\n        for (int y = sampleMinY; y <= sampleMaxY; y+=ySampling)\n        {\n            int nBytes = 0;\n            for (int x = sampleMinX; x <= sampleMaxX; x += xSampling)\n            {\n                nBytes += pixelSize *\n                          sampleCount(base, xStride, yStride, x, y);\n            }\n            bytesPerLine[y - dataWindow.min.y] += nBytes;\n        }\n    }\n    size_t maxBytesPerLine = 0;\n    for (int y = minY; y <= maxY; ++y)\n        if (maxBytesPerLine < bytesPerLine[y - dataWindow.min.y])\n            maxBytesPerLine = bytesPerLine[y - dataWindow.min.y];\n    return maxBytesPerLine;\n}", "target": 1}
{"code": "static inline void *freelist_dereference(const struct kmem_cache *s,\n\t\t\t\t\t void *ptr_addr)\n{\n\treturn freelist_ptr(s, (void *)*(unsigned long *)(ptr_addr),\n\t\t\t    (unsigned long)ptr_addr);\n}", "target": 0}
{"code": "void blog_post(char post_path[]) {\n\tif(strlen(post_path) != 0 || post_path[0] == '.'\n\t\t\t|| strchr(post_path, '/') == NULL) {\n\t\tsend_header(\"Content-type\", \"text/plain\");\n\t\tterminate_headers();\n\t\tprintf(\"No, my dear h4xxx0r :)\\nYou won\\'t do that :p\\n\");\n\t\treturn;\n\t}\n\tif(file_exists(post_path) > 0) {\n\t\tstruct blogpost post = make_blogpost(post_path);\n\t\tsend_header(\"Content-type\", \"text/html\");\n\t\tterminate_headers();\n\t\ttemplate_header();\n\t\ttemplate_post_single_entry(post);\n\t} else {\n\t\tsend_header(\"Content-type\", \"text/html\");\n\t\tsend_header(\"Status\", \"404 Not Found\");\n\t\tterminate_headers();\n\t\ttemplate_header();\n\t\ttemplate_error_404();\n\t}\n\ttemplate_footer();\n}", "target": 0}
{"code": "tvb_get_manuf_name_if_known(tvbuff_t *tvb, gint offset)\n{\n    return get_manuf_name_if_known(tvb_get_ptr(tvb, offset, 3));\n}", "target": 1}
{"code": "int setup_conds(THD *thd, TABLE_LIST *tables, List<TABLE_LIST> &leaves,\n                COND **conds)\n{\n  SELECT_LEX *select_lex= thd->lex->current_select;\n  TABLE_LIST *table= NULL;\t\n  bool it_is_update= (select_lex == &thd->lex->select_lex) &&\n    thd->lex->which_check_option_applicable();\n  bool save_is_item_list_lookup= select_lex->is_item_list_lookup;\n  TABLE_LIST *derived= select_lex->master_unit()->derived;\n  DBUG_ENTER(\"setup_conds\");\n  if (derived && derived->merged)\n    DBUG_RETURN(0);\n  select_lex->is_item_list_lookup= 0;\n  thd->mark_used_columns= MARK_COLUMNS_READ;\n  DBUG_PRINT(\"info\", (\"thd->mark_used_columns: %d\", thd->mark_used_columns));\n  select_lex->cond_count= 0;\n  select_lex->between_count= 0;\n  select_lex->max_equal_elems= 0;\n  for (table= tables; table; table= table->next_local)\n  {\n    if (select_lex == &thd->lex->select_lex &&\n        select_lex->first_cond_optimization &&\n        table->merged_for_insert &&\n        table->prepare_where(thd, conds, FALSE))\n      goto err_no_arena;\n  }\n  if (*conds)\n  {\n    thd->where=\"where clause\";\n    DBUG_EXECUTE(\"where\",\n                 print_where(*conds,\n                             \"WHERE in setup_conds\",\n                             QT_ORDINARY););\n    if ((*conds)->type() == Item::FIELD_ITEM && !derived)\n      wrap_ident(thd, conds);\n    (*conds)->mark_as_condition_AND_part(NO_JOIN_NEST);\n    if ((!(*conds)->fixed && (*conds)->fix_fields(thd, conds)) ||\n\t(*conds)->check_cols(1))\n      goto err_no_arena;\n  }\n  if (setup_on_expr(thd, tables, it_is_update))\n    goto err_no_arena;\n  if (!thd->stmt_arena->is_conventional())\n  {\n    select_lex->where= *conds;\n  }\n  thd->lex->current_select->is_item_list_lookup= save_is_item_list_lookup;\n  DBUG_RETURN(MY_TEST(thd->is_error()));\nerr_no_arena:\n  select_lex->is_item_list_lookup= save_is_item_list_lookup;\n  DBUG_RETURN(1);\n}", "target": 0}
{"code": "storageStateInitialize(bool privileged,\n                       const char *root,\n                       virStateInhibitCallback callback G_GNUC_UNUSED,\n                       void *opaque G_GNUC_UNUSED)\n{\n    g_autofree char *configdir = NULL;\n    g_autofree char *rundir = NULL;\n    bool autostart = true;\n    if (root != NULL) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Driver does not support embedded mode\"));\n        return -1;\n    }\n    driver = g_new0(virStorageDriverState, 1);\n    driver->lockFD = -1;\n    if (virMutexInit(&driver->lock) < 0) {\n        VIR_FREE(driver);\n        return VIR_DRV_STATE_INIT_ERROR;\n    }\n    storageDriverLock();\n    if (!(driver->pools = virStoragePoolObjListNew()))\n        goto error;\n    if (privileged) {\n        driver->configDir = g_strdup(SYSCONFDIR \"/libvirt/storage\");\n        driver->autostartDir = g_strdup(SYSCONFDIR \"/libvirt/storage/autostart\");\n        driver->stateDir = g_strdup(RUNSTATEDIR \"/libvirt/storage\");\n    } else {\n        configdir = virGetUserConfigDirectory();\n        rundir = virGetUserRuntimeDirectory();\n        driver->configDir = g_strdup_printf(\"%s/storage\", configdir);\n        driver->autostartDir = g_strdup_printf(\"%s/storage/autostart\", configdir);\n        driver->stateDir = g_strdup_printf(\"%s/storage/run\", rundir);\n    }\n    driver->privileged = privileged;\n    if (g_mkdir_with_parents(driver->stateDir, 0777) < 0) {\n        virReportError(errno,\n                       _(\"cannot create directory %s\"),\n                       driver->stateDir);\n        goto error;\n    }\n    if ((driver->lockFD =\n         virPidFileAcquire(driver->stateDir, \"driver\",\n                           false, getpid())) < 0)\n        goto error;\n    if (virStoragePoolObjLoadAllState(driver->pools,\n                                      driver->stateDir) < 0)\n        goto error;\n    if (virStoragePoolObjLoadAllConfigs(driver->pools,\n                                        driver->configDir,\n                                        driver->autostartDir) < 0)\n        goto error;\n    storagePoolUpdateAllState();\n    if (virDriverShouldAutostart(driver->stateDir, &autostart) < 0)\n        goto error;\n    if (autostart)\n        storageDriverAutostart();\n    driver->storageEventState = virObjectEventStateNew();\n    if (!(driver->caps = virStorageBackendGetCapabilities()))\n        goto error;\n    storageDriverUnlock();\n    return VIR_DRV_STATE_INIT_COMPLETE;\n error:\n    storageDriverUnlock();\n    storageStateCleanup();\n    return VIR_DRV_STATE_INIT_ERROR;\n}", "target": 0}
{"code": "static int adjust_tp(struct atm_trafprm *tp, unsigned char aal)\n{\n\tint max_sdu;\n\tif (!tp->traffic_class)\n\t\treturn 0;\n\tswitch (aal) {\n\tcase ATM_AAL0:\n\t\tmax_sdu = ATM_CELL_SIZE-1;\n\t\tbreak;\n\tcase ATM_AAL34:\n\t\tmax_sdu = ATM_MAX_AAL34_PDU;\n\t\tbreak;\n\tdefault:\n\t\tpr_warning(\"AAL problems ... (%d)\\n\", aal);\n\tcase ATM_AAL5:\n\t\tmax_sdu = ATM_MAX_AAL5_PDU;\n\t}\n\tif (!tp->max_sdu)\n\t\ttp->max_sdu = max_sdu;\n\telse if (tp->max_sdu > max_sdu)\n\t\treturn -EINVAL;\n\tif (!tp->max_cdv)\n\t\ttp->max_cdv = ATM_MAX_CDV;\n\treturn 0;\n}", "target": 0}
{"code": "onig_new_deluxe(regex_t** reg, const UChar* pattern, const UChar* pattern_end,\n                OnigCompileInfo* ci, OnigErrorInfo* einfo)\n{\n  int r;\n  UChar *cpat, *cpat_end;\n  if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;\n  if (ci->pattern_enc != ci->target_enc) {\n    r = conv_encoding(ci->pattern_enc, ci->target_enc, pattern, pattern_end,\n                      &cpat, &cpat_end);\n    if (r != 0) return r;\n  }\n  else {\n    cpat     = (UChar* )pattern;\n    cpat_end = (UChar* )pattern_end;\n  }\n  *reg = (regex_t* )xmalloc(sizeof(regex_t));\n  if (IS_NULL(*reg)) {\n    r = ONIGERR_MEMORY;\n    goto err2;\n  }\n  r = onig_reg_init(*reg, ci->option, ci->case_fold_flag, ci->target_enc,\n                    ci->syntax);\n  if (r != 0) goto err;\n  r = onig_compile(*reg, cpat, cpat_end, einfo);\n  if (r != 0) {\n  err:\n    onig_free(*reg);\n    *reg = NULL;\n  }\n err2:\n  if (cpat != pattern) xfree(cpat);\n  return r;\n}", "target": 1}
{"code": "static RBinWasmElementEntry *parse_element_entry(RBinWasmObj *bin, ut64 bound, ut32 index) {\n\tRBuffer *b = bin->buf;\n\tRBinWasmElementEntry *elem = R_NEW0 (RBinWasmElementEntry);\n\tif (elem) {\n\t\telem->sec_i = index;\n\t\telem->file_offset = r_buf_tell (b);\n\t\tif (!consume_u32_r (b, bound, &elem->index)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (!consume_init_expr_r (b, bound, R_BIN_WASM_END_OF_CODE, NULL)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (!consume_u32_r (b, bound, &elem->num_elem)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tut32 j = 0;\n\t\twhile (r_buf_tell (b) <= bound && j < elem->num_elem) {\n\t\t\tif (!consume_u32_r (b, bound, NULL)) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\t}\n\treturn elem;\nbeach:\n\tfree (elem);\n\treturn NULL;\n}", "target": 0}
{"code": "RGWOp *RGWHandler_REST_Bucket_S3::op_put()\n{\n  if (s->info.args.sub_resource_exists(\"logging\"))\n    return NULL;\n  if (s->info.args.sub_resource_exists(\"versioning\"))\n    return new RGWSetBucketVersioning_ObjStore_S3;\n  if (s->info.args.sub_resource_exists(\"website\")) {\n    if (!s->cct->_conf->rgw_enable_static_website) {\n      return NULL;\n    }\n    return new RGWSetBucketWebsite_ObjStore_S3;\n  }\n  if (is_acl_op()) {\n    return new RGWPutACLs_ObjStore_S3;\n  } else if (is_cors_op()) {\n    return new RGWPutCORS_ObjStore_S3;\n  } else if (is_request_payment_op()) {\n    return new RGWSetRequestPayment_ObjStore_S3;\n  } else if(is_lc_op()) {\n    return new RGWPutLC_ObjStore_S3;\n  } else if(is_policy_op()) {\n    return new RGWPutBucketPolicy;\n  } else if (is_object_lock_op()) {\n    return new RGWPutBucketObjectLock_ObjStore_S3;\n  } else if (is_notification_op()) {\n    return RGWHandler_REST_PSNotifs_S3::create_put_op();\n  }\n  return new RGWCreateBucket_ObjStore_S3;\n}", "target": 0}
{"code": "generatePreview (const char inFileName[],\n\t\t float exposure,\n\t\t int previewWidth,\n\t\t int &previewHeight,\n\t\t Array2D <PreviewRgba> &previewPixels)\n{\n    RgbaInputFile in (inFileName);\n    Box2i dw = in.dataWindow();\n    float a = in.pixelAspectRatio();\n    int w = dw.max.x - dw.min.x + 1;\n    int h = dw.max.y - dw.min.y + 1;\n    Array2D <Rgba> pixels (h, w);\n    in.setFrameBuffer (ComputeBasePointer (&pixels[0][0], dw), 1, w);\n    in.readPixels (dw.min.y, dw.max.y);\n    previewHeight = max (int (h / (w * a) * previewWidth + .5f), 1);\n    previewPixels.resizeErase (previewHeight, previewWidth);\n    float fx = (previewWidth  > 0)? (float (w - 1) / (previewWidth  - 1)): 1;\n    float fy = (previewHeight > 0)? (float (h - 1) / (previewHeight - 1)): 1;\n    float m  = Math<float>::pow (2.f, IMATH_NAMESPACE::clamp (exposure + 2.47393f, -20.f, 20.f));\n    for (int y = 0; y < previewHeight; ++y)\n    {\n\tfor (int x = 0; x < previewWidth; ++x)\n\t{\n\t    PreviewRgba &preview = previewPixels[y][x];\n\t    const Rgba &pixel = pixels[int (y * fy + .5f)][int (x * fx + .5f)];\n\t    preview.r = gamma (pixel.r, m);\n\t    preview.g = gamma (pixel.g, m);\n\t    preview.b = gamma (pixel.b, m);\n\t    preview.a = int (IMATH_NAMESPACE::clamp (pixel.a * 255.f, 0.f, 255.f) + .5f);\n\t}\n    }\n}", "target": 1}
{"code": "nfs4_file_open(struct inode *inode, struct file *filp)\n{\n\tstruct nfs_open_context *ctx;\n\tstruct dentry *dentry = file_dentry(filp);\n\tstruct dentry *parent = NULL;\n\tstruct inode *dir;\n\tunsigned openflags = filp->f_flags;\n\tstruct iattr attr;\n\tint err;\n\tdprintk(\"NFS: open file(%pd2)\\n\", dentry);\n\terr = nfs_check_flags(openflags);\n\tif (err)\n\t\treturn err;\n\tif ((openflags & O_ACCMODE) == 3)\n\t\treturn nfs_open(inode, filp);\n\topenflags &= ~(O_CREAT|O_EXCL);\n\tparent = dget_parent(dentry);\n\tdir = d_inode(parent);\n\tctx = alloc_nfs_open_context(file_dentry(filp), filp->f_mode, filp);\n\terr = PTR_ERR(ctx);\n\tif (IS_ERR(ctx))\n\t\tgoto out;\n\tattr.ia_valid = ATTR_OPEN;\n\tif (openflags & O_TRUNC) {\n\t\tattr.ia_valid |= ATTR_SIZE;\n\t\tattr.ia_size = 0;\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\t}\n\tinode = NFS_PROTO(dir)->open_context(dir, ctx, openflags, &attr, NULL);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tswitch (err) {\n\t\tdefault:\n\t\t\tgoto out_put_ctx;\n\t\tcase -ENOENT:\n\t\tcase -ESTALE:\n\t\tcase -EISDIR:\n\t\tcase -ENOTDIR:\n\t\tcase -ELOOP:\n\t\t\tgoto out_drop;\n\t\t}\n\t}\n\tif (inode != d_inode(dentry))\n\t\tgoto out_drop;\n\tnfs_file_set_open_context(filp, ctx);\n\tnfs_fscache_open_file(inode, filp);\n\terr = 0;\nout_put_ctx:\n\tput_nfs_open_context(ctx);\nout:\n\tdput(parent);\n\treturn err;\nout_drop:\n\td_drop(dentry);\n\terr = -EOPENSTALE;\n\tgoto out_put_ctx;\n}", "target": 1}
{"code": "static Jsi_RC jsi_ArraySizeOfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    int i = Jsi_ObjGetLength(interp, _this->d.obj);\n    Jsi_ValueMakeNumber(interp, ret, i);\n    return JSI_OK;\n}", "target": 1}
{"code": "static void enable_nmi_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tif ((svm->vcpu.arch.hflags & (HF_NMI_MASK | HF_IRET_MASK))\n\t    == HF_NMI_MASK)\n\t\treturn; \n\tsvm->nmi_singlestep = true;\n\tsvm->vmcb->save.rflags |= (X86_EFLAGS_TF | X86_EFLAGS_RF);\n\tupdate_db_bp_intercept(vcpu);\n}", "target": 1}
{"code": "static bool disconnect_cb(struct io *io, void *user_data)\n{\n\tstruct bt_att_chan *chan = user_data;\n\tstruct bt_att *att = chan->att;\n\tint err;\n\tsocklen_t len;\n\tlen = sizeof(err);\n\tif (getsockopt(chan->fd, SOL_SOCKET, SO_ERROR, &err, &len) < 0) {\n\t\tutil_debug(chan->att->debug_callback, chan->att->debug_data,\n\t\t\t\t\t\"(chan %p) Failed to obtain disconnect\"\n\t\t\t\t\t\" error: %s\", chan, strerror(errno));\n\t\terr = 0;\n\t}\n\tutil_debug(chan->att->debug_callback, chan->att->debug_data,\n\t\t\t\t\t\"Channel %p disconnected: %s\",\n\t\t\t\t\tchan, strerror(err));\n\tqueue_remove(att->chans, chan);\n\tqueue_remove_all(att->req_queue, NULL, NULL, disc_att_send_op);\n\tqueue_remove_all(att->ind_queue, NULL, NULL, disc_att_send_op);\n\tqueue_remove_all(att->write_queue, NULL, NULL, disc_att_send_op);\n\tif (chan->pending_req) {\n\t\tdisc_att_send_op(chan->pending_req);\n\t\tchan->pending_req = NULL;\n\t}\n\tif (chan->pending_ind) {\n\t\tdisc_att_send_op(chan->pending_ind);\n\t\tchan->pending_ind = NULL;\n\t}\n\tbt_att_chan_free(chan);\n\tif (!queue_isempty(att->chans))\n\t\treturn false;\n\tbt_att_ref(att);\n\tqueue_foreach(att->disconn_list, disconn_handler, INT_TO_PTR(err));\n\tbt_att_unregister_all(att);\n\tbt_att_unref(att);\n\treturn false;\n}", "target": 1}
{"code": "pci_get_vdev_info(int slot)\n{\n\tstruct businfo *bi;\n\tstruct slotinfo *si;\n\tstruct pci_vdev *dev = NULL;\n\tbi = pci_businfo[0];\n\tassert(bi != NULL);\n\tsi = &bi->slotinfo[slot];\n\tif (si != NULL)\n\t\tdev = si->si_funcs[0].fi_devi;\n\telse\n\t\tfprintf(stderr, \"slot=%d is empty!\\n\", slot);\n\treturn dev;\n}", "target": 1}
{"code": "kg_seal(minor_status, context_handle, conf_req_flag, qop_req,\n        input_message_buffer, conf_state, output_message_buffer, toktype)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    int conf_req_flag;\n    gss_qop_t qop_req;\n    gss_buffer_t input_message_buffer;\n    int *conf_state;\n    gss_buffer_t output_message_buffer;\n    int toktype;\n{\n    krb5_gss_ctx_id_rec *ctx;\n    krb5_error_code code;\n    krb5_context context;\n    output_message_buffer->length = 0;\n    output_message_buffer->value = NULL;\n    if (qop_req != 0) {\n        *minor_status = (OM_uint32) G_UNKNOWN_QOP;\n        return GSS_S_FAILURE;\n    }\n    ctx = (krb5_gss_ctx_id_rec *) context_handle;\n    if (! ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n    context = ctx->k5_context;\n    switch (ctx->proto)\n    {\n    case 0:\n        code = make_seal_token_v1(context, ctx->enc, ctx->seq,\n                                  &ctx->seq_send, ctx->initiate,\n                                  input_message_buffer, output_message_buffer,\n                                  ctx->signalg, ctx->cksum_size, ctx->sealalg,\n                                  conf_req_flag, toktype, ctx->mech_used);\n        break;\n    case 1:\n        code = gss_krb5int_make_seal_token_v3(context, ctx,\n                                              input_message_buffer,\n                                              output_message_buffer,\n                                              conf_req_flag, toktype);\n        break;\n    default:\n        code = G_UNKNOWN_QOP;   \n        break;\n    }\n    if (code) {\n        *minor_status = code;\n        save_error_info(*minor_status, context);\n        return(GSS_S_FAILURE);\n    }\n    if (conf_state)\n        *conf_state = conf_req_flag;\n    *minor_status = 0;\n    return(GSS_S_COMPLETE);\n}", "target": 1}
{"code": "bool allow_svhandler_flash_range(size_t start, size_t end) {\n  if (start > end) return false;\n  if (start < FLASH_ORIGIN || end > FLASH_END) return false;\n  bool startAllowed = false;\n  bool endAllowed = false;\n  for (const FlashSector* s = flash_sector_map; s->use != FLASH_INVALID; s++) {\n    if (allow_svhandler_flash_sector(s)) {\n      if (!startAllowed &&\n          start + 1 > start &&\n          do_memory_ranges_overlap(start, start + 1, s->start, s->start + s->len)) {\n        startAllowed = true;\n      }\n      if (!endAllowed &&\n          end - 1 < end &&\n          do_memory_ranges_overlap(end - 1, end, s->start, s->start + s->len)) {\n        endAllowed = true;\n      }\n    } else {\n      if (do_memory_ranges_overlap(start, end, s->start, s->start + s->len)) return false;\n    }\n  }\n  if (!startAllowed || !endAllowed) return false;\n  return true;\n}", "target": 0}
{"code": "sync_path (struct url *u)\n{\n  char *newpath, *efile, *edir;\n  xfree (u->path);\n  edir = url_escape_dir (u->dir);\n  efile = url_escape_1 (u->file, urlchr_unsafe | urlchr_reserved, 1);\n  if (!*edir)\n    newpath = xstrdup (efile);\n  else\n    {\n      int dirlen = strlen (edir);\n      int filelen = strlen (efile);\n      char *p = newpath = xmalloc (dirlen + 1 + filelen + 1);\n      memcpy (p, edir, dirlen);\n      p += dirlen;\n      *p++ = '/';\n      memcpy (p, efile, filelen);\n      p += filelen;\n      *p = '\\0';\n    }\n  u->path = newpath;\n  if (edir != u->dir)\n    xfree (edir);\n  if (efile != u->file)\n    xfree (efile);\n  xfree (u->url);\n  u->url = url_string (u, URL_AUTH_SHOW);\n}", "target": 0}
{"code": "MONGO_EXPORT void __mongo_set_error( mongo *conn, mongo_error_t err, const char *str,\n                                     int errcode ) {\n    int errstr_size, str_size;\n    conn->err = err;\n    conn->errcode = errcode;\n    if( str ) {\n        str_size = strlen( str ) + 1;\n        errstr_size = str_size > MONGO_ERR_LEN ? MONGO_ERR_LEN : str_size;\n        memcpy( conn->errstr, str, errstr_size );\n        conn->errstr[errstr_size-1] = '\\0';\n    }\n}", "target": 1}
{"code": "static int nft_set_desc_concat_parse(const struct nlattr *attr,\n\t\t\t\t     struct nft_set_desc *desc)\n{\n\tstruct nlattr *tb[NFTA_SET_FIELD_MAX + 1];\n\tu32 len;\n\tint err;\n\terr = nla_parse_nested_deprecated(tb, NFTA_SET_FIELD_MAX, attr,\n\t\t\t\t\t  nft_concat_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\tif (!tb[NFTA_SET_FIELD_LEN])\n\t\treturn -EINVAL;\n\tlen = ntohl(nla_get_be32(tb[NFTA_SET_FIELD_LEN]));\n\tif (len * BITS_PER_BYTE / 32 > NFT_REG32_COUNT)\n\t\treturn -E2BIG;\n\tdesc->field_len[desc->field_count++] = len;\n\treturn 0;\n}", "target": 1}
{"code": "void PacketReader::getDnsrecordheader(struct dnsrecordheader &ah)\n{\n  unsigned int n;\n  unsigned char *p=reinterpret_cast<unsigned char*>(&ah);\n  for(n=0; n < sizeof(dnsrecordheader); ++n) \n    p[n]=d_content.at(d_pos++);\n  ah.d_type=ntohs(ah.d_type);\n  ah.d_class=ntohs(ah.d_class);\n  ah.d_clen=ntohs(ah.d_clen);\n  ah.d_ttl=ntohl(ah.d_ttl);\n  d_startrecordpos=d_pos; \n  d_recordlen=ah.d_clen;\n}", "target": 0}
{"code": "  friend bool operator==(const TensorKey& t1, const TensorKey& t2) {\n    if (t1.dtype() != t2.dtype() || t1.shape() != t2.shape()) {\n      return false;\n    }\n    if (DataTypeCanUseMemcpy(t1.dtype())) {\n      return t1.tensor_data() == t2.tensor_data();\n    }\n    if (t1.dtype() == DT_STRING) {\n      const auto s1 = t1.unaligned_flat<tstring>();\n      const auto s2 = t2.unaligned_flat<tstring>();\n      for (int64_t i = 0, n = t1.NumElements(); i < n; ++i) {\n        if (TF_PREDICT_FALSE(s1(i) != s2(i))) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }", "target": 1}
{"code": "static struct sock *unix_create1(struct net *net, struct socket *sock, int kern)\n{\n\tstruct sock *sk = NULL;\n\tstruct unix_sock *u;\n\tatomic_long_inc(&unix_nr_socks);\n\tif (atomic_long_read(&unix_nr_socks) > 2 * get_max_files())\n\t\tgoto out;\n\tsk = sk_alloc(net, PF_UNIX, GFP_KERNEL, &unix_proto, kern);\n\tif (!sk)\n\t\tgoto out;\n\tsock_init_data(sock, sk);\n\tlockdep_set_class(&sk->sk_receive_queue.lock,\n\t\t\t\t&af_unix_sk_receive_queue_lock_key);\n\tsk->sk_write_space\t= unix_write_space;\n\tsk->sk_max_ack_backlog\t= net->unx.sysctl_max_dgram_qlen;\n\tsk->sk_destruct\t\t= unix_sock_destructor;\n\tu\t  = unix_sk(sk);\n\tu->path.dentry = NULL;\n\tu->path.mnt = NULL;\n\tspin_lock_init(&u->lock);\n\tatomic_long_set(&u->inflight, 0);\n\tINIT_LIST_HEAD(&u->link);\n\tmutex_init(&u->readlock); \n\tinit_waitqueue_head(&u->peer_wait);\n\tinit_waitqueue_func_entry(&u->peer_wake, unix_dgram_peer_wake_relay);\n\tunix_insert_socket(unix_sockets_unbound(sk), sk);\nout:\n\tif (sk == NULL)\n\t\tatomic_long_dec(&unix_nr_socks);\n\telse {\n\t\tlocal_bh_disable();\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, 1);\n\t\tlocal_bh_enable();\n\t}\n\treturn sk;\n}", "target": 0}
{"code": "void setup_page_debug(struct kmem_cache *s, struct page *page, void *addr)\n{\n\tif (!(s->flags & SLAB_POISON))\n\t\treturn;\n\tmetadata_access_enable();\n\tmemset(addr, POISON_INUSE, page_size(page));\n\tmetadata_access_disable();\n}", "target": 0}
{"code": "device_drive_poll_media_authorized_cb (Daemon *daemon,\n                                       Device *device,\n                                       DBusGMethodInvocation *context,\n                                       const gchar *action_id,\n                                       guint num_user_data,\n                                       gpointer *user_data_elements)\n{\n  int n;\n  char *argv[16];\n  n = 0;\n  argv[n++] = \"udisks-helper-drive-poll\";\n  argv[n++] = device->priv->device_file;\n  argv[n++] = NULL;\n  if (!job_new (context, \"DrivePollMedia\", FALSE, device, argv, NULL, drive_poll_media_completed_cb, FALSE, NULL, NULL))\n    {\n      goto out;\n    }\n out:\n  ;\n}", "target": 0}
{"code": "static uint16_t nvme_get_feature_timestamp(NvmeCtrl *n, NvmeRequest *req)\n{\n    uint64_t timestamp = nvme_get_timestamp(n);\n    return nvme_c2h(n, (uint8_t *)&timestamp, sizeof(timestamp), req);\n}", "target": 0}
{"code": "inspect_evbuffer(struct evbuffer *buf, char **data_out, size_t n,\n                 int *free_out, struct evbuffer_ptr *pos)\n{\n  int n_vecs, i;\n  if (evbuffer_get_length(buf) < n)\n    n = evbuffer_get_length(buf);\n  if (n == 0)\n    return 0;\n  n_vecs = evbuffer_peek(buf, n, pos, NULL, 0);\n  tor_assert(n_vecs > 0);\n  if (n_vecs == 1) {\n    struct evbuffer_iovec v;\n    i = evbuffer_peek(buf, n, pos, &v, 1);\n    tor_assert(i == 1);\n    *data_out = v.iov_base;\n    *free_out = 0;\n    return v.iov_len;\n  } else {\n    ev_ssize_t copied;\n    *data_out = tor_malloc(n);\n    *free_out = 1;\n    copied = evbuffer_copyout(buf, *data_out, n);\n    tor_assert(copied >= 0 && (size_t)copied == n);\n    return copied;\n  }\n}", "target": 0}
{"code": "    TiffComponent* newOlympusMn(uint16_t    tag,\n                                IfdId       group,\n                                IfdId       ,\n                                const byte* pData,\n                                uint32_t    size,\n                                ByteOrder   )\n    {\n        if (size < 10 ||   std::string(reinterpret_cast<const char*>(pData), 10)\n                        != std::string(\"OLYMPUS\\0II\", 10)) {\n            if (size < OlympusMnHeader::sizeOfSignature() + 18) return 0;\n            return newOlympusMn2(tag, group, olympusId);\n        }\n        if (size < Olympus2MnHeader::sizeOfSignature() + 18) return 0;\n        return newOlympus2Mn2(tag, group, olympus2Id);\n    }", "target": 0}
{"code": "static void update_exception_bitmap(struct kvm_vcpu *vcpu)\n{\n\tu32 eb;\n\teb = (1u << PF_VECTOR) | (1u << UD_VECTOR) | (1u << MC_VECTOR) |\n\t     (1u << NM_VECTOR) | (1u << DB_VECTOR);\n\tif ((vcpu->guest_debug &\n\t     (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP)) ==\n\t    (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP))\n\t\teb |= 1u << BP_VECTOR;\n\tif (to_vmx(vcpu)->rmode.vm86_active)\n\t\teb = ~0;\n\tif (enable_ept)\n\t\teb &= ~(1u << PF_VECTOR); \n\tif (vcpu->fpu_active)\n\t\teb &= ~(1u << NM_VECTOR);\n\tif (is_guest_mode(vcpu))\n\t\teb |= get_vmcs12(vcpu)->exception_bitmap;\n\tvmcs_write32(EXCEPTION_BITMAP, eb);\n}", "target": 1}
{"code": "static void patch_instruction(VAPICROMState *s, X86CPU *cpu, target_ulong ip)\n{\n    CPUState *cs = CPU(cpu);\n     CPUX86State *env = &cpu->env;\n     VAPICHandlers *handlers;\n     uint8_t opcode[2];\n    uint32_t imm32;\n     target_ulong current_pc = 0;\n     target_ulong current_cs_base = 0;\n     uint32_t current_flags = 0;\n    if (smp_cpus == 1) {\n        handlers = &s->rom_state.up;\n    } else {\n        handlers = &s->rom_state.mp;\n    }\n    if (!kvm_enabled()) {\n        cpu_get_tb_cpu_state(env, &current_pc, &current_cs_base,\n                             &current_flags);\n    }\n    pause_all_vcpus();\n    cpu_memory_rw_debug(cs, ip, opcode, sizeof(opcode), 0);\n    switch (opcode[0]) {\n    case 0x89: \n        patch_byte(cpu, ip, 0x50 + modrm_reg(opcode[1]));  \n        patch_call(s, cpu, ip + 1, handlers->set_tpr);\n        break;\n    case 0x8b: \n        patch_byte(cpu, ip, 0x90);\n        patch_call(s, cpu, ip + 1, handlers->get_tpr[modrm_reg(opcode[1])]);\n        break;\n    case 0xa1: \n        patch_call(s, cpu, ip, handlers->get_tpr[0]);\n        break;\n    case 0xa3: \n        patch_call(s, cpu, ip, handlers->set_tpr_eax);\n        break;\n    case 0xc7: \n        patch_byte(cpu, ip, 0x68);  \n        cpu_memory_rw_debug(cs, ip + 6, (void *)&imm32, sizeof(imm32), 0);\n        cpu_memory_rw_debug(cs, ip + 1, (void *)&imm32, sizeof(imm32), 1);\n        patch_call(s, cpu, ip + 5, handlers->set_tpr);\n        break;\n    case 0xff: \n        patch_byte(cpu, ip, 0x50); \n        patch_call(s, cpu, ip + 1, handlers->get_tpr_stack);\n        break;\n    default:\n        abort();\n    }\n    resume_all_vcpus();\n    if (!kvm_enabled()) {\n        tb_gen_code(cs, current_pc, current_cs_base, current_flags, 1);\n        cpu_resume_from_signal(cs, NULL);\n    }\n}", "target": 1}
{"code": "static const char *server_hostname_port(cmd_parms *cmd, void *dummy, const char *arg)\n{\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);\n    const char *portstr, *part;\n    char *scheme;\n    int port;\n    if (err != NULL) {\n        return err;\n    }\n    if (apr_fnmatch_test(arg))\n        return apr_pstrcat(cmd->temp_pool, \"Invalid ServerName \\\"\", arg,\n                \"\\\" use ServerAlias to set multiple server names.\", NULL);\n    part = ap_strstr_c(arg, \":\n    if (part) {\n      scheme = apr_pstrndup(cmd->pool, arg, part - arg);\n      ap_str_tolower(scheme);\n      cmd->server->server_scheme = (const char *)scheme;\n      part += 3;\n    } else {\n      part = arg;\n    }\n    portstr = ap_strchr_c(part, ':');\n    if (portstr) {\n        cmd->server->server_hostname = apr_pstrndup(cmd->pool, part,\n                                                    portstr - part);\n        portstr++;\n        port = atoi(portstr);\n        if (port <= 0 || port >= 65536) { \n            return apr_pstrcat(cmd->temp_pool, \"The port number \\\"\", arg,\n                          \"\\\" is outside the appropriate range \"\n                          \"(i.e., 1..65535).\", NULL);\n        }\n    }\n    else {\n        cmd->server->server_hostname = apr_pstrdup(cmd->pool, part);\n        port = 0;\n    }\n    cmd->server->port = port;\n    return NULL;\n}", "target": 0}
{"code": "    TiffComponent* newSonyMn(uint16_t    tag,\n                             IfdId       group,\n                             IfdId       ,\n                             const byte* pData,\n                             uint32_t    size,\n                             ByteOrder   )\n    {\n        if (size < 12 ||   std::string(reinterpret_cast<const char*>(pData), 12)\n                        != std::string(\"SONY DSC \\0\\0\\0\", 12)) {\n            if (size < 18) return 0;\n            return newSony2Mn2(tag, group, sony2Id);\n        }\n        if (size < SonyMnHeader::sizeOfSignature() + 14) return 0;\n        return newSony1Mn2(tag, group, sony1Id);\n    }", "target": 0}
{"code": "test_save_copy (const char *origname)\n{\n  char buf[TESTBUFSIZE];\n  int ret;\n  snprintf_func (buf, TESTBUFSIZE, \"cp -f %s %s\", origname, TEST_COPY_FILE);\n  if ((ret = system (buf)) != 0)\n    {\n      return XD3_INTERNAL;\n    }\n  return 0;\n}", "target": 1}
{"code": "static void esp_do_nodma(ESPState *s)\n{\n    int to_device = ((s->rregs[ESP_RSTAT] & 7) == STAT_DO);\n    uint32_t cmdlen;\n    int len;\n    if (s->do_cmd) {\n        cmdlen = fifo8_num_used(&s->cmdfifo);\n        trace_esp_handle_ti_cmd(cmdlen);\n        s->ti_size = 0;\n        if ((s->rregs[ESP_RSTAT] & 7) == STAT_CD) {\n            if (s->cmdfifo_cdb_offset == fifo8_num_used(&s->cmdfifo)) {\n                return;\n            }\n            s->do_cmd = 0;\n            do_cmd(s);\n        } else {\n            s->cmdfifo_cdb_offset = fifo8_num_used(&s->cmdfifo);\n            s->rregs[ESP_RSTAT] = STAT_TC | STAT_CD;\n            s->rregs[ESP_RSEQ] = SEQ_CD;\n            s->rregs[ESP_RINTR] |= INTR_BS;\n            esp_raise_irq(s);\n        }\n        return;\n    }\n    if (!s->current_req) {\n        return;\n    }\n    if (s->async_len == 0) {\n        return;\n    }\n    if (to_device) {\n        len = MIN(fifo8_num_used(&s->fifo), ESP_FIFO_SZ);\n        esp_fifo_pop_buf(&s->fifo, s->async_buf, len);\n        s->async_buf += len;\n        s->async_len -= len;\n        s->ti_size += len;\n    } else {\n        if (fifo8_is_empty(&s->fifo)) {\n            fifo8_push(&s->fifo, s->async_buf[0]);\n            s->async_buf++;\n            s->async_len--;\n            s->ti_size--;\n        }\n    }\n    if (s->async_len == 0) {\n        scsi_req_continue(s->current_req);\n        return;\n    }\n    s->rregs[ESP_RINTR] |= INTR_BS;\n    esp_raise_irq(s);\n}", "target": 1}
{"code": "void tcp_finish_connect(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\ttcp_set_state(sk, TCP_ESTABLISHED);\n\tif (skb) {\n\t\ticsk->icsk_af_ops->sk_rx_dst_set(sk, skb);\n\t\tsecurity_inet_conn_established(sk, skb);\n\t}\n\ticsk->icsk_af_ops->rebuild_header(sk);\n\ttcp_init_metrics(sk);\n\ttcp_init_congestion_control(sk);\n\ttp->lsndtime = tcp_time_stamp;\n\ttcp_init_buffer_space(sk);\n\tif (sock_flag(sk, SOCK_KEEPOPEN))\n\t\tinet_csk_reset_keepalive_timer(sk, keepalive_time_when(tp));\n\tif (!tp->rx_opt.snd_wscale)\n\t\t__tcp_fast_path_on(tp, tp->snd_wnd);\n\telse\n\t\ttp->pred_flags = 0;\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tsk->sk_state_change(sk);\n\t\tsk_wake_async(sk, SOCK_WAKE_IO, POLL_OUT);\n\t}\n}", "target": 0}
{"code": "void *TrustedPrimitives::UntrustedLocalAlloc(size_t size) noexcept {\n  void *result;\n  CHECK_OCALL(\n      ocall_untrusted_local_alloc(&result, static_cast<uint64_t>(size)));\n  if (result && !IsOutsideEnclave(result, static_cast<uint64_t>(size))) {\n    TrustedPrimitives::BestEffortAbort(\n        \"Allocated memory not found to be outside the enclave.\");\n  }\n  if (!result) {\n    errno = ENOMEM;\n    TrustedPrimitives::DebugPuts(\"UntrustedLocalAlloc on SGX failed.\");\n  }\n  return result;\n}", "target": 0}
{"code": "dodynamic(struct magic_set *ms, void *vbuf, size_t offset, size_t size,\n    int clazz, int swap)\n{\n\tElf32_Dyn dh32;\n\tElf64_Dyn dh64;\n\tunsigned char *dbuf = CAST(unsigned char *, vbuf);\n\tif (xdh_sizeof + offset > size) {\n\t\treturn xdh_sizeof + offset;\n\t}\n\tmemcpy(xdh_addr, &dbuf[offset], xdh_sizeof);\n\toffset += xdh_sizeof;\n\tswitch (xdh_tag) {\n\tcase DT_FLAGS_1:\n\t\tif (xdh_val & DF_1_PIE)\n\t\t\tms->mode |= 0111;\n\t\telse\n\t\t\tms->mode &= ~0111;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn offset;\n}", "target": 0}
{"code": "static bool tr_valid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment tr;\n\tvmx_get_segment(vcpu, &tr, VCPU_SREG_TR);\n\tif (tr.unusable)\n\t\treturn false;\n\tif (tr.selector & SELECTOR_TI_MASK)\t\n\t\treturn false;\n\tif (tr.type != 3 && tr.type != 11) \n\t\treturn false;\n\tif (!tr.present)\n\t\treturn false;\n\treturn true;\n}", "target": 0}
{"code": "irc_server_set_prefix_modes_chars (struct t_irc_server *server,\n                                   const char *prefix)\n{\n    char *pos;\n    int i, length_modes, length_chars;\n    if (!server || !prefix)\n        return;\n    if (server->prefix_modes)\n    {\n        free (server->prefix_modes);\n        server->prefix_modes = NULL;\n    }\n    if (server->prefix_chars)\n    {\n        free (server->prefix_chars);\n        server->prefix_chars = NULL;\n    }\n    pos = strchr (prefix, ')');\n    if (pos)\n    {\n        server->prefix_modes = weechat_strndup (prefix + 1,\n                                                pos - prefix - 1);\n        if (server->prefix_modes)\n        {\n            pos++;\n            length_modes = strlen (server->prefix_modes);\n            length_chars = strlen (pos);\n            server->prefix_chars = malloc (length_modes + 1);\n            if (server->prefix_chars)\n            {\n                for (i = 0; i < length_modes; i++)\n                {\n                    server->prefix_chars[i] = (i < length_chars) ? pos[i] : ' ';\n                }\n                server->prefix_chars[length_modes] = '\\0';\n            }\n            else\n            {\n                free (server->prefix_modes);\n                server->prefix_modes = NULL;\n            }\n        }\n    }\n}", "target": 1}
{"code": "int DH_set0_pqg(DH *dh, BIGNUM *p, BIGNUM *q, BIGNUM *g) {\n    if(!p || !g) \n        return 0;\n    BN_free(dh->p);\n    BN_free(dh->q);\n    BN_free(dh->g);\n    dh->p = p;\n    dh->q = q;\n    dh->g = g;\n    if(q)\n        dh->length = BN_num_bits(q);\n    return 1;\n}", "target": 1}
{"code": "static int __init ip6_tunnel_init(void)\n{\n\tint  err;\n\tif (xfrm6_tunnel_register(&ip4ip6_handler, AF_INET)) {\n\t\tprintk(KERN_ERR \"ip6_tunnel init: can't register ip4ip6\\n\");\n\t\terr = -EAGAIN;\n\t\tgoto out;\n\t}\n\tif (xfrm6_tunnel_register(&ip6ip6_handler, AF_INET6)) {\n\t\tprintk(KERN_ERR \"ip6_tunnel init: can't register ip6ip6\\n\");\n\t\terr = -EAGAIN;\n\t\tgoto unreg_ip4ip6;\n\t}\n\terr = register_pernet_device(&ip6_tnl_net_ops);\n\tif (err < 0)\n\t\tgoto err_pernet;\n\treturn 0;\nerr_pernet:\n\txfrm6_tunnel_deregister(&ip6ip6_handler, AF_INET6);\nunreg_ip4ip6:\n\txfrm6_tunnel_deregister(&ip4ip6_handler, AF_INET);\nout:\n\treturn err;\n}", "target": 1}
{"code": "pipe_setup (Pipe *pipe, FILE *logf, gpointer user_data)\n{\n\tGIOFlags flags = 0;\n\tpipe->logf = logf;\n\tpipe->buf = g_string_sized_new (512);\n\tpipe->channel = g_io_channel_unix_new (pipe->fd);\n\tg_io_channel_set_encoding (pipe->channel, NULL, NULL);\n\tflags = g_io_channel_get_flags (pipe->channel);\n\tg_io_channel_set_flags (pipe->channel, flags | G_IO_FLAG_NONBLOCK, NULL);\n\tg_io_channel_set_buffered (pipe->channel, FALSE);\n\tpipe->watch = g_io_add_watch (pipe->channel,\n\t                              G_IO_IN | G_IO_ERR | G_IO_PRI,\n\t                              data_available,\n\t                              user_data);\n}", "target": 0}
{"code": "static void __init mp_override_legacy_irq(u8 bus_irq, u8 polarity, u8 trigger,\n\t\t\t\t\t  u32 gsi)\n{\n\tint ioapic;\n\tint pin;\n\tstruct mpc_intsrc mp_irq;\n\tioapic = mp_find_ioapic(gsi);\n\tif (ioapic < 0)\n\t\treturn;\n\tpin = mp_find_ioapic_pin(ioapic, gsi);\n\tif ((bus_irq == 0) && (trigger == 3))\n\t\ttrigger = 1;\n\tmp_irq.type = MP_INTSRC;\n\tmp_irq.irqtype = mp_INT;\n\tmp_irq.irqflag = (trigger << 2) | polarity;\n\tmp_irq.srcbus = MP_ISA_BUS;\n\tmp_irq.srcbusirq = bus_irq;\t\n\tmp_irq.dstapic = mpc_ioapic_id(ioapic); \n\tmp_irq.dstirq = pin;\t\n\tmp_save_irq(&mp_irq);\n\tif (gsi < nr_legacy_irqs() && isa_irq_to_gsi[gsi] == gsi)\n\t\tisa_irq_to_gsi[gsi] = ACPI_INVALID_GSI;\n\tisa_irq_to_gsi[bus_irq] = gsi;\n}", "target": 1}
{"code": "RestAuthHandler::RestAuthHandler(application_features::ApplicationServer& server,\n                                 GeneralRequest* request, GeneralResponse* response)\n    : RestVocbaseBaseHandler(server, request, response),\n      _validFor(60 * 60 * 24 * 30) {}", "target": 1}
{"code": "Sfdouble_t sh_strnum(Shell_t *shp, const char *str, char **ptr, int mode) {\n    Sfdouble_t d;\n    char *last;\n    if (*str == 0) {\n        if (ptr) *ptr = (char *)str;\n        return 0;\n    }\n    errno = 0;\n    d = number(str, &last, shp->inarith ? 0 : 10, NULL);\n    if (*last) {\n        if (*last != '.' || last[1] != '.') {\n            d = strval(shp, str, &last, arith, mode);\n            Varsubscript = true;\n        }\n        if (!ptr && *last && mode > 0) errormsg(SH_DICT, ERROR_exit(1), e_lexbadchar, *last, str);\n    } else if (!d && *str == '-') {\n        d = -0.0;\n    }\n    if (ptr) *ptr = last;\n    return d;\n}", "target": 1}
{"code": "static void sgi_timer_get(struct k_itimer *timr, struct itimerspec *cur_setting)\n{\n\tif (timr->it.mmtimer.clock == TIMER_OFF) {\n\t\tcur_setting->it_interval.tv_nsec = 0;\n\t\tcur_setting->it_interval.tv_sec = 0;\n\t\tcur_setting->it_value.tv_nsec = 0;\n\t\tcur_setting->it_value.tv_sec =0;\n\t\treturn;\n\t}\n\tns_to_timespec(cur_setting->it_interval, timr->it.mmtimer.incr * sgi_clock_period);\n\tns_to_timespec(cur_setting->it_value, (timr->it.mmtimer.expires - rtc_time())* sgi_clock_period);\n\treturn;\n}", "target": 1}
{"code": "static int crypto_shash_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_hash rhash;\n\tstruct shash_alg *salg = __crypto_shash_alg(alg);\n\tsnprintf(rhash.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"shash\");\n\trhash.blocksize = alg->cra_blocksize;\n\trhash.digestsize = salg->digestsize;\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_HASH,\n\t\t    sizeof(struct crypto_report_hash), &rhash))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "MONGO_EXPORT int bson_finish( bson *b ) {\n    int i;\n    if( b->err & BSON_NOT_UTF8 )\n        return BSON_ERROR;\n    if ( ! b->finished ) {\n        if ( bson_ensure_space( b, 1 ) == BSON_ERROR ) return BSON_ERROR;\n        bson_append_byte( b, 0 );\n        i = b->cur - b->data;\n        bson_little_endian32( b->data, &i );\n        b->finished = 1;\n    }\n    return BSON_OK;\n}", "target": 1}
{"code": "png_set_PLTE(png_structrp png_ptr, png_inforp info_ptr,\n    png_const_colorp palette, int num_palette)\n{\n   png_debug1(1, \"in %s storage function\", \"PLTE\");\n   if (png_ptr == NULL || info_ptr == NULL)\n      return;\n   if (num_palette < 0 || num_palette > PNG_MAX_PALETTE_LENGTH)\n   {\n      if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n         png_error(png_ptr, \"Invalid palette length\");\n      else\n      {\n         png_warning(png_ptr, \"Invalid palette length\");\n         return;\n      }\n   }\n   if ((num_palette > 0 && palette == NULL) ||\n      (num_palette == 0\n#        ifdef PNG_MNG_FEATURES_SUPPORTED\n            && (png_ptr->mng_features_permitted & PNG_FLAG_MNG_EMPTY_PLTE) == 0\n#        endif\n      ))\n   {\n      png_error(png_ptr, \"Invalid palette\");\n   }\n   png_free_data(png_ptr, info_ptr, PNG_FREE_PLTE, 0);\n   png_ptr->palette = png_voidcast(png_colorp, png_calloc(png_ptr,\n       PNG_MAX_PALETTE_LENGTH * (sizeof (png_color))));\n   if (num_palette > 0)\n      memcpy(png_ptr->palette, palette, num_palette * (sizeof (png_color)));\n   info_ptr->palette = png_ptr->palette;\n   info_ptr->num_palette = png_ptr->num_palette = (png_uint_16)num_palette;\n   info_ptr->free_me |= PNG_FREE_PLTE;\n   info_ptr->valid |= PNG_INFO_PLTE;\n}", "target": 1}
{"code": "l_noret luaG_runerror (lua_State *L, const char *fmt, ...) {\n  CallInfo *ci = L->ci;\n  const char *msg;\n  va_list argp;\n  luaC_checkGC(L);  \n  va_start(argp, fmt);\n  msg = luaO_pushvfstring(L, fmt, argp);  \n  va_end(argp);\n  if (isLua(ci))  \n    luaG_addinfo(L, msg, ci_func(ci)->p->source, getcurrentline(ci));\n  luaG_errormsg(L);\n}", "target": 1}
{"code": "static int perf_fasync(int fd, struct file *filp, int on)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct perf_event *event = filp->private_data;\n\tint retval;\n\tmutex_lock(&inode->i_mutex);\n\tretval = fasync_helper(fd, filp, on, &event->fasync);\n\tmutex_unlock(&inode->i_mutex);\n\tif (retval < 0)\n\t\treturn retval;\n\treturn 0;\n}", "target": 0}
{"code": "static void *seq_buf_alloc(unsigned long size)\n{\n\treturn kvmalloc(size, GFP_KERNEL_ACCOUNT);\n}", "target": 1}
{"code": "void ImplPolygon::ImplSplit( sal_uInt16 nPos, sal_uInt16 nSpace, ImplPolygon const * pInitPoly )\n{\n    if (mnPoints + nSpace > USHRT_MAX)\n        return;\n    const sal_uInt16    nNewSize = mnPoints + nSpace;\n    const std::size_t   nSpaceSize = static_cast<std::size_t>(nSpace) * sizeof(Point);\n    if( nPos >= mnPoints )\n    {\n        nPos = mnPoints;\n        ImplSetSize( nNewSize );\n        if( pInitPoly )\n        {\n            memcpy( mpPointAry + nPos, pInitPoly->mpPointAry, nSpaceSize );\n            if( pInitPoly->mpFlagAry )\n                memcpy( mpFlagAry + nPos, pInitPoly->mpFlagAry, nSpace );\n        }\n    }\n    else\n    {\n        const sal_uInt16    nSecPos = nPos + nSpace;\n        const sal_uInt16    nRest = mnPoints - nPos;\n        Point* pNewAry = reinterpret_cast<Point*>(new char[ static_cast<std::size_t>(nNewSize) * sizeof(Point) ]);\n        memcpy( pNewAry, mpPointAry, nPos * sizeof( Point ) );\n        if( pInitPoly )\n            memcpy( pNewAry + nPos, pInitPoly->mpPointAry, nSpaceSize );\n        else\n            memset( pNewAry + nPos, 0, nSpaceSize );\n        memcpy( pNewAry + nSecPos, mpPointAry + nPos, nRest * sizeof( Point ) );\n        delete[] reinterpret_cast<char*>(mpPointAry);\n        if( mpFlagAry )\n        {\n            PolyFlags* pNewFlagAry = new PolyFlags[ nNewSize ];\n            memcpy( pNewFlagAry, mpFlagAry, nPos );\n            if( pInitPoly && pInitPoly->mpFlagAry )\n                memcpy( pNewFlagAry + nPos, pInitPoly->mpFlagAry, nSpace );\n            else\n                memset( pNewFlagAry + nPos, 0, nSpace );\n            memcpy( pNewFlagAry + nSecPos, mpFlagAry + nPos, nRest );\n            delete[] mpFlagAry;\n            mpFlagAry = pNewFlagAry;\n        }\n        mpPointAry = pNewAry;\n        mnPoints   = nNewSize;\n    }\n}", "target": 1}
{"code": "static void record_recent_object(struct object *obj,\n\t\t\t\t struct strbuf *path,\n\t\t\t\t const char *last,\n\t\t\t\t void *data)\n{\n\tsha1_array_append(&recent_objects, obj->oid.hash);\n}", "target": 1}
{"code": "TfLiteStatus GatherStrings(TfLiteContext* context, const TfLiteTensor* input,\n                           const TfLiteTensor* positions,\n                           TfLiteTensor* output) {\n  DynamicBuffer buffer;\n  const PositionT* indexes = GetTensorData<PositionT>(positions);\n  bool indices_has_only_positive_elements = true;\n  const size_t num_indices = positions->bytes / sizeof(PositionT);\n  for (size_t i = 0; i < num_indices; i++) {\n    if (indexes[i] < 0) {\n      indices_has_only_positive_elements = false;\n      break;\n    }\n  }\n  TF_LITE_ENSURE(context, indices_has_only_positive_elements);\n  const PositionT num_strings = GetStringCount(input);\n  const int num_indexes = NumElements(positions);\n  for (int i = 0; i < num_indexes; ++i) {\n    const PositionT pos = indexes[i];\n    TF_LITE_ENSURE(context, pos < num_strings);\n    const auto string_ref = GetString(input, pos);\n    buffer.AddString(string_ref.str, string_ref.len);\n  }\n  buffer.WriteToTensor(output, nullptr);\n  return kTfLiteOk;\n}", "target": 0}
{"code": "void lzxd_free(struct lzxd_stream *lzx) {\n  struct mspack_system *sys;\n  if (lzx) {\n    sys = lzx->sys;\n    sys->free(lzx->inbuf);\n    sys->free(lzx->window);\n    sys->free(lzx);\n  }\n}", "target": 1}
{"code": "    bool read(ReadonlyBytes buffer)\n    {\n        auto fields_size = sizeof(LocalFileHeader) - (sizeof(u8*) * 3);\n        if (buffer.size() < fields_size)\n            return false;\n        if (memcmp(buffer.data(), local_file_header_signature, sizeof(local_file_header_signature)) != 0)\n            return false;\n        memcpy(reinterpret_cast<void*>(&minimum_version), buffer.data() + sizeof(local_file_header_signature), fields_size);\n        name = buffer.data() + sizeof(local_file_header_signature) + fields_size;\n        extra_data = name + name_length;\n        compressed_data = extra_data + extra_data_length;\n        return true;\n    }", "target": 1}
{"code": "FontData::FontData(FontData* data, int32_t offset) {\n  Init(data->array_);\n  Bound(data->bound_offset_ + offset,\n        (data->bound_length_ == GROWABLE_SIZE)\n        ? GROWABLE_SIZE : data->bound_length_ - offset);\n}", "target": 0}
{"code": "long jpc_bitstream_getbits(jpc_bitstream_t *bitstream, int n)\n{\n\tlong v;\n\tint u;\n\tassert(n >= 0 && n < 32);\n \tv = 0;\n\twhile (--n >= 0) {\n\t\tif ((u = jpc_bitstream_getbit(bitstream)) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tv = (v << 1) | u;\n\t}\n\treturn v;\n}", "target": 1}
{"code": "g_Ctoc(const Char *str, char *buf, unsigned int len)\n{\n    while (len--) {\n        if ((*buf++ = *str++) == EOS) {\n            return 0;\n        }\n    }\n    return 1;\n}", "target": 0}
{"code": "static const char *tls_dns_name(const GENERAL_NAME * gn)\n{\n\tconst char *dnsname;\n\tif (ASN1_STRING_type(gn->d.ia5) != V_ASN1_IA5STRING) {\n\t\tg_warning(\"Invalid ASN1 value type in subjectAltName\");\n\t\treturn NULL;\n\t}\n\tdnsname = (char *) ASN1_STRING_data(gn->d.ia5);\n\tif (has_internal_nul(dnsname, ASN1_STRING_length(gn->d.ia5))) {\n\t\tg_warning(\"Internal NUL in subjectAltName\");\n\t\treturn NULL;\n\t}\n\treturn dnsname;\n}", "target": 0}
{"code": "Jsi_RC Jsi_ValueInsertArray(Jsi_Interp *interp, Jsi_Value *target, int key, Jsi_Value *val, int flags)\n{\n    if (target->vt != JSI_VT_OBJECT) {\n        if (interp->strict)\n            Jsi_LogWarn(\"Target is not object\");\n        return JSI_ERROR;\n    }\n    Jsi_Obj *obj = target->d.obj;\n    if (obj->isarrlist) {\n        if (key >= 0 && key < interp->maxArrayList) {\n            Jsi_ObjArraySet(interp, obj, val, key);\n            return JSI_OK;\n        }\n        return JSI_ERROR;\n    }\n    char unibuf[100];\n    Jsi_NumberItoA10(key, unibuf, sizeof(unibuf));\n    Jsi_ObjInsert(interp, obj, unibuf, val, flags);\n    return JSI_OK;\n}", "target": 1}
{"code": "fb_mmap(struct file *file, struct vm_area_struct * vma)\n{\n\tstruct fb_info *info = file_fb_info(file);\n\tstruct fb_ops *fb;\n\tunsigned long off;\n\tunsigned long start;\n\tu32 len;\n\tif (!info)\n\t\treturn -ENODEV;\n\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT))\n\t\treturn -EINVAL;\n\toff = vma->vm_pgoff << PAGE_SHIFT;\n\tfb = info->fbops;\n\tif (!fb)\n\t\treturn -ENODEV;\n\tmutex_lock(&info->mm_lock);\n\tif (fb->fb_mmap) {\n\t\tint res;\n\t\tres = fb->fb_mmap(info, vma);\n\t\tmutex_unlock(&info->mm_lock);\n\t\treturn res;\n\t}\n\tstart = info->fix.smem_start;\n\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.smem_len);\n\tif (off >= len) {\n\t\toff -= len;\n\t\tif (info->var.accel_flags) {\n\t\t\tmutex_unlock(&info->mm_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tstart = info->fix.mmio_start;\n\t\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.mmio_len);\n\t}\n\tmutex_unlock(&info->mm_lock);\n\tstart &= PAGE_MASK;\n\tif ((vma->vm_end - vma->vm_start + off) > len)\n\t\treturn -EINVAL;\n\toff += start;\n\tvma->vm_pgoff = off >> PAGE_SHIFT;\n\tvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\n\tfb_pgprotect(file, vma, off);\n\tif (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,\n\t\t\t     vma->vm_end - vma->vm_start, vma->vm_page_prot))\n\t\treturn -EAGAIN;\n\treturn 0;\n}", "target": 1}
{"code": "TEST(ArrayOpsTest, QuantizeAndDequantizeV2_ShapeFn) {\n  ShapeInferenceTestOp op(\"QuantizeAndDequantizeV2\");\n  op.input_tensors.resize(3);\n  TF_ASSERT_OK(NodeDefBuilder(\"test\", \"QuantizeAndDequantizeV2\")\n                   .Input(\"input\", 0, DT_FLOAT)\n                   .Input(\"input_min\", 1, DT_FLOAT)\n                   .Input(\"input_max\", 2, DT_FLOAT)\n                   .Attr(\"signed_input\", true)\n                   .Attr(\"num_bits\", 8)\n                   .Attr(\"range_given\", false)\n                   .Attr(\"narrow_range\", false)\n                   .Attr(\"axis\", -1)\n                   .Finalize(&op.node_def));\n  INFER_OK(op, \"?;?;?\", \"in0\");\n  INFER_OK(op, \"[];?;?\", \"in0\");\n  INFER_OK(op, \"[1,2,?,4,5];?;?\", \"in0\");\n  INFER_ERROR(\"Shape must be rank 0 but is rank 1\", op, \"[1,2,?,4,5];[1];[]\");\n  INFER_ERROR(\"Shapes must be equal rank, but are 1 and 0\", op,\n              \"[1,2,?,4,5];[];[1]\");\n  INFER_ERROR(\"Shape must be rank 0 but is rank 1\", op, \"[1,2,?,4,5];[1];[1]\");\n}", "target": 1}
{"code": "static void fill_model_structures(SPICE_GNUC_UNUSED Encoder *encoder, FamilyStat *family_stat,\n                                  unsigned int rep_first, unsigned int first_size,\n                                  unsigned int rep_next, unsigned int mul_size,\n                                  unsigned int levels, unsigned int ncounters,\n                                  unsigned int nbuckets, unsigned int n_buckets_ptrs)\n{\n    unsigned int\n    bsize,\n    bstart,\n    bend = 0,\n    repcntr,\n    bnumber;\n    COUNTER * free_counter = family_stat->counters;\n    bnumber = 0;\n    repcntr = rep_first + 1;    \n    bsize = first_size;\n    do { \n        if (bnumber) {\n            bstart = bend + 1;\n        } else {\n            bstart = 0;\n        }\n        if (!--repcntr) {\n            repcntr = rep_next;\n            bsize *= mul_size;\n        }\n        bend = bstart + bsize - 1;\n        if (bend + bsize >= levels) {\n            bend = levels - 1;\n        }\n        family_stat->buckets_buf[bnumber].pcounters = free_counter;\n        free_counter += ncounters;\n        spice_assert(bstart < n_buckets_ptrs);\n        {\n            unsigned int i;\n            spice_assert(bend < n_buckets_ptrs);\n            for (i = bstart; i <= bend; i++) {\n                family_stat->buckets_ptrs[i] = family_stat->buckets_buf + bnumber;\n            }\n        }\n        bnumber++;\n    } while (bend < levels - 1);\n    spice_assert(free_counter - family_stat->counters == (ptrdiff_t)(nbuckets * ncounters));\n}", "target": 0}
{"code": "bool CWalletTx::AcceptWalletTransaction(CTxDB& txdb, bool fCheckInputs)\n{\n    {\n        LOCK(mempool.cs);\n        BOOST_FOREACH(CMerkleTx& tx, vtxPrev)\n        {\n            if (!tx.IsCoinBase())\n            {\n                uint256 hash = tx.GetHash();\n                if (!mempool.exists(hash) && !txdb.ContainsTx(hash))\n                    tx.AcceptToMemoryPool(txdb, fCheckInputs);\n            }\n        }\n        return AcceptToMemoryPool(txdb, fCheckInputs);\n    }\n    return false;\n}", "target": 1}
{"code": "int snd_usb_pipe_sanity_check(struct usb_device *dev, unsigned int pipe)\n{\n\tstatic const int pipetypes[4] = {\n\t\tPIPE_CONTROL, PIPE_ISOCHRONOUS, PIPE_BULK, PIPE_INTERRUPT\n\t};\n\tstruct usb_host_endpoint *ep;\n\tep = usb_pipe_endpoint(dev, pipe);\n\tif (usb_pipetype(pipe) != pipetypes[usb_endpoint_type(&ep->desc)])\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 1}
{"code": "absl::Status Ipv4Instance::validateProtocolSupported() {\n  static const bool supported = SocketInterfaceSingleton::get().ipFamilySupported(AF_INET);\n  if (supported) {\n    return absl::OkStatus();\n  }\n  return absl::FailedPreconditionError(\"IPv4 addresses are not supported on this machine\");\n}", "target": 1}
{"code": "static inline int ff_fast_malloc(void *ptr, unsigned int *size, size_t min_size, int zero_realloc)\n{\n    void **p = ptr;\n    if (min_size < *size)\n        return 0;\n    min_size = FFMAX(17 * min_size / 16 + 32, min_size);\n    av_free(*p);\n    *p = zero_realloc ? av_mallocz(min_size) : av_malloc(min_size);\n    if (!*p)\n        min_size = 0;\n    *size = min_size;\n    return 1;\n}", "target": 0}
{"code": "int nfc_genl_se_connectivity(struct nfc_dev *dev, u8 se_idx)\n{\n\tconst struct nfc_se *se;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_SE_CONNECTIVITY);\n\tif (!hdr)\n\t\tgoto free_msg;\n\tse = nfc_find_se(dev, se_idx);\n\tif (!se)\n\t\tgoto free_msg;\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx) ||\n\t    nla_put_u32(msg, NFC_ATTR_SE_INDEX, se_idx) ||\n\t    nla_put_u8(msg, NFC_ATTR_SE_TYPE, se->type))\n\t\tgoto nla_put_failure;\n\tgenlmsg_end(msg, hdr);\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\treturn 0;\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}", "target": 0}
{"code": "rrdp_process_deltas(struct update_notification *parent,\n    unsigned long cur_serial, struct visited_uris *visited_uris,\n    bool log_operation)\n{\n\tstruct proc_upd_args args;\n\targs.parent = parent;\n\targs.visited_uris = visited_uris;\n\targs.log_operation = log_operation;\n\treturn deltas_head_for_each(parent->deltas_list,\n\t    parent->global_data.serial, cur_serial, process_delta, &args);\n}", "target": 1}
{"code": "static int snd_compress_check_input(struct snd_compr_params *params)\n{\n\tif (params->buffer.fragment_size == 0 ||\n\t\t\tparams->buffer.fragments > SIZE_MAX / params->buffer.fragment_size)\n\t\treturn -EINVAL;\n\tif (params->codec.id == 0 || params->codec.id > SND_AUDIOCODEC_MAX)\n\t\treturn -EINVAL;\n\tif (params->codec.ch_in == 0 || params->codec.ch_out == 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 1}
{"code": "void start_auth_vnc(VncState *vs)\n{\n    Error *err = NULL;\n    if (qcrypto_random_bytes(vs->challenge, sizeof(vs->challenge), &err)) {\n        trace_vnc_auth_fail(vs, vs->auth, \"cannot get random bytes\",\n                            error_get_pretty(err));\n        error_free(err);\n        authentication_failed(vs);\n        return;\n    }\n    vnc_write(vs, vs->challenge, sizeof(vs->challenge));\n    vnc_flush(vs);\n    vnc_read_when(vs, protocol_client_auth_vnc, sizeof(vs->challenge));\n}", "target": 0}
{"code": "static u32 __ipv6_select_ident(struct net *net, u32 hashrnd,\n\t\t\t       const struct in6_addr *dst,\n\t\t\t       const struct in6_addr *src)\n{\n\tu32 hash, id;\n\thash = __ipv6_addr_jhash(dst, hashrnd);\n\thash = __ipv6_addr_jhash(src, hash);\n\thash ^= net_hash_mix(net);\n\tid = ip_idents_reserve(hash, 1);\n\tif (unlikely(!id))\n\t\tid = 1 << 31;\n\treturn id;\n}", "target": 1}
{"code": "bool EmbFile::save2(FILE *f) {\n  int c;\n  m_objStr.streamReset();\n  while ((c = m_objStr.streamGetChar()) != EOF) {\n    fputc(c, f);\n  }\n  return true;\n}", "target": 1}
{"code": "  TestHeaderMapImplBase(const HeaderMap& rhs) {\n    HeaderMapImpl::copyFrom(*header_map_, rhs);\n    header_map_->verifyByteSizeInternalForTest();\n  }", "target": 0}
{"code": "static int pfkey_do_dump(struct pfkey_sock *pfk)\n{\n\tstruct sadb_msg *hdr;\n\tint rc;\n\trc = pfk->dump.dump(pfk);\n\tif (rc == -ENOBUFS)\n\t\treturn 0;\n\tif (pfk->dump.skb) {\n\t\tif (!pfkey_can_dump(&pfk->sk))\n\t\t\treturn 0;\n\t\thdr = (struct sadb_msg *) pfk->dump.skb->data;\n\t\thdr->sadb_msg_seq = 0;\n\t\thdr->sadb_msg_errno = rc;\n\t\tpfkey_broadcast(pfk->dump.skb, GFP_ATOMIC, BROADCAST_ONE,\n\t\t\t\t&pfk->sk, sock_net(&pfk->sk));\n\t\tpfk->dump.skb = NULL;\n\t}\n\tpfkey_terminate_dump(pfk);\n\treturn rc;\n}", "target": 0}
{"code": "    StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes,\n                                                     size_t xTriggerLevelBytes,\n                                                     BaseType_t xIsMessageBuffer )\n    {\n        uint8_t * pucAllocatedMemory;\n        uint8_t ucFlags;\n        if( xIsMessageBuffer == pdTRUE )\n        {\n            ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;\n            configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );\n        }\n        else\n        {\n            ucFlags = 0;\n            configASSERT( xBufferSizeBytes > 0 );\n        }\n        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );\n        if( xTriggerLevelBytes == ( size_t ) 0 )\n        {\n            xTriggerLevelBytes = ( size_t ) 1;\n        }\n        xBufferSizeBytes++;\n        pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); \n        if( pucAllocatedMemory != NULL )\n        {\n            prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory,         \n                                          pucAllocatedMemory + sizeof( StreamBuffer_t ),  \n                                          xBufferSizeBytes,\n                                          xTriggerLevelBytes,\n                                          ucFlags );\n            traceSTREAM_BUFFER_CREATE( ( ( StreamBuffer_t * ) pucAllocatedMemory ), xIsMessageBuffer );\n        }\n        else\n        {\n            traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );\n        }\n        return ( StreamBufferHandle_t ) pucAllocatedMemory; \n    }", "target": 1}
{"code": "static void ldapsrv_process_call_trigger(struct tevent_req *req,\n\t\t\t\t\t void *private_data)\n{\n\tstruct ldapsrv_process_call_state *state =\n\t\ttevent_req_data(req,\n\t\tstruct ldapsrv_process_call_state);\n\tstruct ldapsrv_connection *conn = state->call->conn;\n\tNTSTATUS status;\n\tif (conn->deferred_expire_disconnect != NULL) {\n\t\ttevent_req_done(req);\n\t\treturn;\n\t}\n\tstatus = ldapsrv_do_call(state->call);\n\tif (NT_STATUS_EQUAL(status, NT_STATUS_NETWORK_SESSION_EXPIRED)) {\n\t\tint defer_msec = lpcfg_parm_int(\n\t\t\tconn->lp_ctx,\n\t\t\tNULL,\n\t\t\t\"ldap_server\",\n\t\t\t\"delay_expire_disconnect\",\n\t\t\t0);\n\t\tconn->deferred_expire_disconnect = tevent_wakeup_send(\n\t\t\tconn,\n\t\t\tconn->connection->event.ctx,\n\t\t\ttimeval_current_ofs_msec(defer_msec));\n\t\tif (tevent_req_nomem(conn->deferred_expire_disconnect, req)) {\n\t\t\treturn;\n\t\t}\n\t\ttevent_req_set_callback(\n\t\t\tconn->deferred_expire_disconnect,\n\t\t\tldapsrv_disconnect_ticket_expired,\n\t\t\tconn);\n\t\ttevent_req_done(req);\n\t\treturn;\n\t}\n\tif (!NT_STATUS_IS_OK(status)) {\n\t\ttevent_req_nterror(req, status);\n\t\treturn;\n\t}\n\ttevent_req_done(req);\n}", "target": 0}
{"code": "R_API ut64 r_bin_java_element_pair_calc_size(RBinJavaElementValuePair *evp) {\n\tut64 sz = 0;\n\tif (evp == NULL) {\n\t\treturn sz;\n\t}\n\tsz += 2;\n\tif (evp->value) {\n\t\tsz += r_bin_java_element_value_calc_size (evp->value);\n\t}\n\treturn sz;\n}", "target": 1}
{"code": "rdp_enum_bmpcache2(void)\n{\n\tSTREAM s;\n\tHASH_KEY keylist[BMPCACHE2_NUM_PSTCELLS];\n\tuint32 num_keys, offset, count, flags;\n\toffset = 0;\n\tnum_keys = pstcache_enumerate(2, keylist);\n\twhile (offset < num_keys)\n\t{\n\t\tcount = MIN(num_keys - offset, 169);\n\t\ts = rdp_init_data(24 + count * sizeof(HASH_KEY));\n\t\tflags = 0;\n\t\tif (offset == 0)\n\t\t\tflags |= PDU_FLAG_FIRST;\n\t\tif (num_keys - offset <= 169)\n\t\t\tflags |= PDU_FLAG_LAST;\n\t\tout_uint32_le(s, 0);\n\t\tout_uint16_le(s, count);\n\t\tout_uint16_le(s, 0);\n\t\tout_uint16_le(s, 0);\n\t\tout_uint16_le(s, 0);\n\t\tout_uint16_le(s, 0);\n\t\tout_uint16_le(s, num_keys);\n\t\tout_uint32_le(s, 0);\n\t\tout_uint32_le(s, flags);\n\t\tout_uint8a(s, keylist[offset], count * sizeof(HASH_KEY));\n\t\ts_mark_end(s);\n\t\trdp_send_data(s, 0x2b);\n\t\toffset += 169;\n\t}\n}", "target": 0}
{"code": "xfs_attrmulti_attr_set(\n\tstruct inode\t\t*inode,\n\tunsigned char\t\t*name,\n\tconst unsigned char\t__user *ubuf,\n\tuint32_t\t\tlen,\n\tuint32_t\t\tflags)\n{\n\tstruct xfs_da_args\targs = {\n\t\t.dp\t\t= XFS_I(inode),\n\t\t.attr_filter\t= xfs_attr_filter(flags),\n\t\t.attr_flags\t= xfs_attr_flags(flags),\n\t\t.name\t\t= name,\n\t\t.namelen\t= strlen(name),\n\t};\n\tint\t\t\terror;\n\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\treturn -EPERM;\n\tif (ubuf) {\n\t\tif (len > XFS_XATTR_SIZE_MAX)\n\t\t\treturn -EINVAL;\n\t\targs.value = memdup_user(ubuf, len);\n\t\tif (IS_ERR(args.value))\n\t\t\treturn PTR_ERR(args.value);\n\t\targs.valuelen = len;\n\t}\n\terror = xfs_attr_set(&args);\n\tif (!error && (flags & XFS_IOC_ATTR_ROOT))\n\t\txfs_forget_acl(inode, name);\n\tkfree(args.value);\n\treturn error;\n}", "target": 0}
{"code": "static void mce_report_event(struct pt_regs *regs)\n{\n\tif (regs->flags & (X86_VM_MASK|X86_EFLAGS_IF)) {\n\t\tmce_notify_irq();\n\t\tmce_schedule_work();\n\t\treturn;\n\t}\n\tirq_work_queue(&mce_irq_work);\n}", "target": 0}
{"code": "nfsd4_layout_verify(struct svc_export *exp, unsigned int layout_type)\n{\n\tif (!exp->ex_layout_types) {\n\t\tdprintk(\"%s: export does not support pNFS\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tif (!(exp->ex_layout_types & (1 << layout_type))) {\n\t\tdprintk(\"%s: layout type %d not supported\\n\",\n\t\t\t__func__, layout_type);\n\t\treturn NULL;\n\t}\n\treturn nfsd4_layout_ops[layout_type];\n}", "target": 1}
{"code": "      void Init(void)\n      {\n        for(int i = 0;i < 19;i++) {\n#ifdef DEBUG_QMCODER\n          char string[5] = \"X0  \";\n          string[1] = (i / 10) + '0';\n          string[2] = (i % 10) + '0';\n          X[i].Init(string);\n          string[0] = 'M';\n          M[i].Init(string);\n#else\n          X[i].Init();\n          M[i].Init();\n#endif\n        }\n      }", "target": 1}
{"code": "hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)\n{\n\tunsigned long orun = 1;\n\tktime_t delta;\n\tdelta = ktime_sub(now, timer->expires);\n\tif (delta.tv64 < 0)\n\t\treturn 0;\n\tif (interval.tv64 < timer->base->resolution.tv64)\n\t\tinterval.tv64 = timer->base->resolution.tv64;\n\tif (unlikely(delta.tv64 >= interval.tv64)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\t\torun = ktime_divns(delta, incr);\n\t\ttimer->expires = ktime_add_ns(timer->expires, incr * orun);\n\t\tif (timer->expires.tv64 > now.tv64)\n\t\t\treturn orun;\n\t\torun++;\n\t}\n\ttimer->expires = ktime_add(timer->expires, interval);\n\treturn orun;\n}", "target": 1}
{"code": "ns_client_isself(dns_view_t *myview, dns_tsigkey_t *mykey,\n\t\t isc_sockaddr_t *srcaddr, isc_sockaddr_t *dstaddr,\n\t\t dns_rdataclass_t rdclass, void *arg)\n{\n\tdns_view_t *view;\n\tdns_tsigkey_t *key = NULL;\n\tdns_name_t *tsig = NULL;\n\tisc_netaddr_t netsrc;\n\tisc_netaddr_t netdst;\n\tUNUSED(arg);\n\tif (ns_g_server->interfacemgr == NULL)\n\t\treturn (true);\n\tif (!ns_interfacemgr_listeningon(ns_g_server->interfacemgr, dstaddr))\n\t\treturn (false);\n\tisc_netaddr_fromsockaddr(&netsrc, srcaddr);\n\tisc_netaddr_fromsockaddr(&netdst, dstaddr);\n\tfor (view = ISC_LIST_HEAD(ns_g_server->viewlist);\n\t     view != NULL;\n\t     view = ISC_LIST_NEXT(view, link)) {\n\t\tif (view->matchrecursiveonly)\n\t\t\tcontinue;\n\t\tif (rdclass != view->rdclass)\n\t\t\tcontinue;\n\t\tif (mykey != NULL) {\n\t\t\tbool match;\n\t\t\tisc_result_t result;\n\t\t\tresult = dns_view_gettsig(view, &mykey->name, &key);\n\t\t\tif (result != ISC_R_SUCCESS)\n\t\t\t\tcontinue;\n\t\t\tmatch = dst_key_compare(mykey->key, key->key);\n\t\t\tdns_tsigkey_detach(&key);\n\t\t\tif (!match)\n\t\t\t\tcontinue;\n\t\t\ttsig = dns_tsigkey_identity(mykey);\n\t\t}\n\t\tif (allowed(&netsrc, tsig, NULL, 0, NULL,\n\t\t\t    view->matchclients) &&\n\t\t    allowed(&netdst, tsig, NULL, 0, NULL,\n\t\t\t    view->matchdestinations))\n\t\t\tbreak;\n\t}\n\treturn (view == myview);\n}", "target": 0}
{"code": "bool RenderView::CaptureThumbnail(WebView* view,\n                                  int w,\n                                  int h,\n                                  SkBitmap* thumbnail,\n                                  ThumbnailScore* score) {\n  base::TimeTicks beginning_time = base::TimeTicks::Now();\n  skia::PlatformCanvas canvas;\n  if (!PaintViewIntoCanvas(view, canvas))\n    return false;\n  skia::BitmapPlatformDevice& device =\n      static_cast<skia::BitmapPlatformDevice&>(canvas.getTopPlatformDevice());\n  const SkBitmap& src_bmp = device.accessBitmap(false);\n  SkRect dest_rect = { 0, 0, SkIntToScalar(w), SkIntToScalar(h) };\n  float dest_aspect = dest_rect.width() / dest_rect.height();\n  SkIRect src_rect;\n  if (src_bmp.width() < dest_rect.width() ||\n      src_bmp.height() < dest_rect.height()) {\n    src_rect.set(0, 0, static_cast<S16CPU>(dest_rect.width()),\n                 static_cast<S16CPU>(dest_rect.height()));\n    score->good_clipping = false;\n  } else {\n    float src_aspect = static_cast<float>(src_bmp.width()) / src_bmp.height();\n    if (src_aspect > dest_aspect) {\n      S16CPU new_width = static_cast<S16CPU>(src_bmp.height() * dest_aspect);\n      S16CPU x_offset = (src_bmp.width() - new_width) / 2;\n      src_rect.set(x_offset, 0, new_width + x_offset, src_bmp.height());\n      score->good_clipping = false;\n    } else {\n      src_rect.set(0, 0, src_bmp.width(),\n                   static_cast<S16CPU>(src_bmp.width() / dest_aspect));\n      score->good_clipping = true;\n    }\n  }\n  score->at_top = (view->mainFrame()->scrollOffset().height == 0);\n  SkBitmap subset;\n  device.accessBitmap(false).extractSubset(&subset, src_rect);\n  *thumbnail = skia::ImageOperations::Resize(\n      subset, skia::ImageOperations::RESIZE_LANCZOS3, w, h);\n  score->boring_score = CalculateBoringScore(thumbnail);\n  HISTOGRAM_TIMES(\"Renderer4.Thumbnail\",\n                  base::TimeTicks::Now() - beginning_time);\n  return true;\n}", "target": 0}
{"code": "static int linear_ioctl(struct dm_target *ti, unsigned int cmd,\n\t\t\tunsigned long arg)\n{\n\tstruct linear_c *lc = (struct linear_c *) ti->private;\n\treturn __blkdev_driver_ioctl(lc->dev->bdev, lc->dev->mode, cmd, arg);\n}", "target": 1}
{"code": "get_req_flags(unsigned char **buff_in, OM_uint32 bodysize,\n\t      OM_uint32 *req_flags)\n{\n\tunsigned int len;\n\tif (**buff_in != (CONTEXT | 0x01))\n\t\treturn (0);\n\tif (g_get_tag_and_length(buff_in, (CONTEXT | 0x01),\n\t\t\t\tbodysize, &len) < 0)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tif (*(*buff_in)++ != BIT_STRING)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tif (*(*buff_in)++ != BIT_STRING_LENGTH)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tif (*(*buff_in)++ != BIT_STRING_PADDING)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t*req_flags = (OM_uint32) (*(*buff_in)++ >> 1);\n\treturn (0);\n}", "target": 0}
{"code": "static void virtio_net_vhost_status(VirtIONet *n, uint8_t status)\n{\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n    NetClientState *nc = qemu_get_queue(n->nic);\n    int queue_pairs = n->multiqueue ? n->max_queue_pairs : 1;\n    int cvq = n->max_ncs - n->max_queue_pairs;\n    if (!get_vhost_net(nc->peer)) {\n        return;\n    }\n    if ((virtio_net_started(n, status) && !nc->peer->link_down) ==\n        !!n->vhost_started) {\n        return;\n    }\n    if (!n->vhost_started) {\n        int r, i;\n        if (n->needs_vnet_hdr_swap) {\n            error_report(\"backend does not support %s vnet headers; \"\n                         \"falling back on userspace virtio\",\n                         virtio_is_big_endian(vdev) ? \"BE\" : \"LE\");\n            return;\n        }\n        for (i = 0;  i < queue_pairs; i++) {\n            NetClientState *qnc = qemu_get_subqueue(n->nic, i);\n            qemu_net_queue_purge(qnc->peer->incoming_queue, qnc);\n            qemu_net_queue_purge(qnc->incoming_queue, qnc->peer);\n        }\n        if (virtio_has_feature(vdev->guest_features, VIRTIO_NET_F_MTU)) {\n            r = vhost_net_set_mtu(get_vhost_net(nc->peer), n->net_conf.mtu);\n            if (r < 0) {\n                error_report(\"%uBytes MTU not supported by the backend\",\n                             n->net_conf.mtu);\n                return;\n            }\n        }\n        n->vhost_started = 1;\n        r = vhost_net_start(vdev, n->nic->ncs, queue_pairs, cvq);\n        if (r < 0) {\n            error_report(\"unable to start vhost net: %d: \"\n                         \"falling back on userspace virtio\", -r);\n            n->vhost_started = 0;\n        }\n    } else {\n        vhost_net_stop(vdev, n->nic->ncs, queue_pairs, cvq);\n        n->vhost_started = 0;\n    }\n}", "target": 0}
{"code": "int test_gtpu_send_indirect_data_forwarding(\n        ogs_socknode_t *node, test_bearer_t *bearer, ogs_pkbuf_t *pkbuf)\n{\n    test_sess_t *sess = NULL;\n    ogs_gtp2_header_t gtp_hdesc;\n    ogs_gtp2_extension_header_t ext_hdesc;\n    ogs_assert(bearer);\n    sess = bearer->sess;\n    ogs_assert(sess);\n    ogs_assert(pkbuf);\n    memset(&gtp_hdesc, 0, sizeof(gtp_hdesc));\n    memset(&ext_hdesc, 0, sizeof(ext_hdesc));\n    gtp_hdesc.type = OGS_GTPU_MSGTYPE_GPDU;\n    if (bearer->qfi) {\n        gtp_hdesc.teid = sess->handover.upf_dl_teid;\n        ext_hdesc.qos_flow_identifier = bearer->qfi;\n    } else if (bearer->ebi) {\n        ogs_fatal(\"Not implmented EPC Indirect Tunnel\");\n        ogs_assert_if_reached();\n    } else {\n        ogs_fatal(\"No QFI[%d] and EBI[%d]\", bearer->qfi, bearer->ebi);\n        ogs_assert_if_reached();\n    }\n    return test_gtpu_send(node, bearer, &gtp_hdesc, &ext_hdesc, pkbuf);\n}", "target": 1}
{"code": "    size_t MemIo::write(BasicIo& src)\n    {\n        if (static_cast<BasicIo*>(this) == &src) return 0;\n        if (!src.isopen()) return 0;\n        byte buf[4096];\n        size_t readCount = 0;\n        size_t writeTotal = 0;\n        while ((readCount = src.read(buf, sizeof(buf)))) {\n            write(buf, readCount);\n            writeTotal += readCount;\n        }\n        return writeTotal;\n    }", "target": 0}
{"code": "void rose_start_heartbeat(struct sock *sk)\n{\n\tdel_timer(&sk->sk_timer);\n\tsk->sk_timer.function = rose_heartbeat_expiry;\n\tsk->sk_timer.expires  = jiffies + 5 * HZ;\n\tadd_timer(&sk->sk_timer);\n}", "target": 1}
{"code": "static void gic_dist_writel(void *opaque, hwaddr offset,\n                            uint32_t value, MemTxAttrs attrs)\n{\n    GICState *s = (GICState *)opaque;\n    if (offset == 0xf00) {\n        int cpu;\n        int irq;\n        int mask;\n        int target_cpu;\n        cpu = gic_get_current_cpu(s);\n        irq = value & 0x3ff;\n        switch ((value >> 24) & 3) {\n        case 0:\n            mask = (value >> 16) & ALL_CPU_MASK;\n            break;\n        case 1:\n            mask = ALL_CPU_MASK ^ (1 << cpu);\n            break;\n        case 2:\n            mask = 1 << cpu;\n            break;\n        default:\n            DPRINTF(\"Bad Soft Int target filter\\n\");\n            mask = ALL_CPU_MASK;\n            break;\n        }\n        GIC_DIST_SET_PENDING(irq, mask);\n        target_cpu = ctz32(mask);\n        while (target_cpu < GIC_NCPU) {\n            s->sgi_pending[irq][target_cpu] |= (1 << cpu);\n            mask &= ~(1 << target_cpu);\n            target_cpu = ctz32(mask);\n        }\n        gic_update(s);\n        return;\n    }\n    gic_dist_writew(opaque, offset, value & 0xffff, attrs);\n    gic_dist_writew(opaque, offset + 2, value >> 16, attrs);\n}", "target": 1}
{"code": "static void fuse_send_readpages(struct fuse_req *req, struct file *file)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tloff_t pos = page_offset(req->pages[0]);\n\tsize_t count = req->num_pages << PAGE_CACHE_SHIFT;\n\treq->out.argpages = 1;\n\treq->out.page_zeroing = 1;\n\tfuse_read_fill(req, file, pos, count, FUSE_READ);\n\treq->misc.read.attr_ver = fuse_get_attr_version(fc);\n\tif (fc->async_read) {\n\t\treq->ff = fuse_file_get(ff);\n\t\treq->end = fuse_readpages_end;\n\t\tfuse_request_send_background(fc, req);\n\t} else {\n\t\tfuse_request_send(fc, req);\n\t\tfuse_readpages_end(fc, req);\n\t\tfuse_put_request(fc, req);\n\t}\n}", "target": 0}
{"code": "int get_evtchn_to_irq(evtchn_port_t evtchn)\n{\n\tif (evtchn >= xen_evtchn_max_channels())\n\t\treturn -1;\n\tif (evtchn_to_irq[EVTCHN_ROW(evtchn)] == NULL)\n\t\treturn -1;\n\treturn evtchn_to_irq[EVTCHN_ROW(evtchn)][EVTCHN_COL(evtchn)];\n}", "target": 1}
{"code": "static void GetStandardDeviationPixelList(PixelList *pixel_list,\n  MagickPixelPacket *pixel)\n{\n  MagickRealType\n    sum,\n    sum_squared;\n  SkipList\n    *list;\n  ssize_t\n    channel;\n  size_t\n    color;\n  ssize_t\n    count;\n  unsigned short\n    channels[ListChannels];\n  for (channel=0; channel < 5; channel++)\n  {\n    list=pixel_list->lists+channel;\n    color=65536L;\n    count=0;\n    sum=0.0;\n    sum_squared=0.0;\n    do\n    {\n      ssize_t\n        i;\n      color=list->nodes[color].next[0];\n      sum+=(MagickRealType) list->nodes[color].count*color;\n      for (i=0; i < (ssize_t) list->nodes[color].count; i++)\n        sum_squared+=((MagickRealType) color)*((MagickRealType) color);\n      count+=list->nodes[color].count;\n    } while (count < (ssize_t) pixel_list->length);\n    sum/=pixel_list->length;\n    sum_squared/=pixel_list->length;\n    channels[channel]=(unsigned short) sqrt(sum_squared-(sum*sum));\n  }\n  pixel->red=(MagickRealType) ScaleShortToQuantum(channels[0]);\n  pixel->green=(MagickRealType) ScaleShortToQuantum(channels[1]);\n  pixel->blue=(MagickRealType) ScaleShortToQuantum(channels[2]);\n  pixel->opacity=(MagickRealType) ScaleShortToQuantum(channels[3]);\n  pixel->index=(MagickRealType) ScaleShortToQuantum(channels[4]);\n}", "target": 0}
{"code": "  QuotaManager* quota_manager() const { return quota_manager_.get(); }", "target": 0}
{"code": "static void local_release(struct kref *ref)\n{\n\tstruct nfc_llcp_local *local;\n\tlocal = container_of(ref, struct nfc_llcp_local, ref);\n\tlist_del(&local->list);\n\tlocal_cleanup(local);\n\tkfree(local);\n}", "target": 1}
{"code": "static struct o2nm_cluster *to_o2nm_cluster_from_node(struct o2nm_node *node)\n{\n\treturn to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);\n}", "target": 1}
{"code": "struct timespec ns_to_timespec(const s64 nsec)\n{\n\tstruct timespec ts;\n\tif (!nsec)\n\t\treturn (struct timespec) {0, 0};\n\tts.tv_sec = div_long_long_rem_signed(nsec, NSEC_PER_SEC, &ts.tv_nsec);\n\tif (unlikely(nsec < 0))\n\t\tset_normalized_timespec(&ts, ts.tv_sec, ts.tv_nsec);\n\treturn ts;\n}", "target": 1}
{"code": "    bool ms_verify_authorizer(Connection *con, int peer_type, int protocol,\n                              bufferlist& authorizer, bufferlist& authorizer_reply,\n                              bool& isvalid, CryptoKey& session_key) override {\n      isvalid = true;\n      return true;\n    }", "target": 1}
{"code": "ldbm_config_search_entry_callback(Slapi_PBlock *pb __attribute__((unused)),\n                                  Slapi_Entry *e,\n                                  Slapi_Entry *entryAfter __attribute__((unused)),\n                                  int *returncode,\n                                  char *returntext,\n                                  void *arg)\n{\n    char buf[BUFSIZ];\n    struct berval *vals[2];\n    struct berval val;\n    struct ldbminfo *li = (struct ldbminfo *)arg;\n    config_info *config;\n    int scope;\n    vals[0] = &val;\n    vals[1] = NULL;\n    returntext[0] = '\\0';\n    PR_Lock(li->li_config_mutex);\n    if (pb) {\n        slapi_pblock_get(pb, SLAPI_SEARCH_SCOPE, &scope);\n        if (scope == LDAP_SCOPE_BASE) {\n            char **attrs = NULL;\n            slapi_pblock_get(pb, SLAPI_SEARCH_ATTRS, &attrs);\n            if (attrs) {\n                for (size_t i = 0; attrs[i]; i++) {\n                    if (ldbm_config_moved_attr(attrs[i])) {\n                        slapi_pblock_set(pb, SLAPI_PB_RESULT_TEXT, \"at least one required attribute has been moved to the BDB scecific configuration entry\");\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    for (config = ldbm_config; config->config_name != NULL; config++) {\n        if (!(config->config_flags & (CONFIG_FLAG_ALWAYS_SHOW | CONFIG_FLAG_PREVIOUSLY_SET))) {\n            continue;\n        }\n        ldbm_config_get((void *)li, config, buf);\n        val.bv_val = buf;\n        val.bv_len = strlen(buf);\n        slapi_entry_attr_replace(e, config->config_name, vals);\n    }\n    PR_Unlock(li->li_config_mutex);\n    *returncode = LDAP_SUCCESS;\n    return SLAPI_DSE_CALLBACK_OK;\n}", "target": 1}
{"code": "usm_malloc_usmStateReference(void)\n{\n    struct usmStateReference *retval = (struct usmStateReference *)\n        calloc(1, sizeof(struct usmStateReference));\n    return retval;\n}                               ", "target": 1}
{"code": "USHORT CNB::QueryL4HeaderOffset(PVOID PacketData, ULONG IpHeaderOffset) const\n{\n    USHORT Res;\n    auto ppr = ParaNdis_ReviewIPPacket(RtlOffsetToPointer(PacketData, IpHeaderOffset),\n                                       GetDataLength(), __FUNCTION__);\n    if (ppr.ipStatus != ppresNotIP)\n    {\n        Res = static_cast<USHORT>(IpHeaderOffset + ppr.ipHeaderSize);\n    }\n    else\n    {\n        DPrintf(0, (\"[%s] ERROR: NOT an IP packet - expected troubles!\\n\", __FUNCTION__));\n        Res = 0;\n    }\n    return Res;\n}", "target": 1}
{"code": "static const uint8_t *get_signature(const uint8_t *asn1_sig, int *len)\n{\n    int offset = 0;\n    const uint8_t *ptr = NULL;\n    if (asn1_next_obj(asn1_sig, &offset, ASN1_SEQUENCE) < 0 || \n            asn1_skip_obj(asn1_sig, &offset, ASN1_SEQUENCE))\n        goto end_get_sig;\n    if (asn1_sig[offset++] != ASN1_OCTET_STRING)\n        goto end_get_sig;\n    *len = get_asn1_length(asn1_sig, &offset);\n    ptr = &asn1_sig[offset];          \nend_get_sig:\n    return ptr;\n}", "target": 1}
{"code": "static int _gnutls_verify_crl2(gnutls_x509_crl_t crl,\n\t\t\t       const gnutls_x509_crt_t * trusted_cas,\n\t\t\t       int tcas_size, unsigned int flags,\n\t\t\t       unsigned int *output)\n{\n    gnutls_datum_t crl_signed_data = { NULL, 0 };\n    gnutls_datum_t crl_signature = { NULL, 0 };\n    gnutls_x509_crt_t issuer;\n    int ret, result;\n    if (output)\n\t*output = 0;\n    if (tcas_size >= 1)\n\tissuer = find_crl_issuer(crl, trusted_cas, tcas_size);\n    else {\n\tgnutls_assert();\n\tif (output)\n\t    *output |= GNUTLS_CERT_SIGNER_NOT_FOUND | GNUTLS_CERT_INVALID;\n\treturn 0;\n    }\n    if (issuer == NULL) {\n\tgnutls_assert();\n\tif (output)\n\t    *output |= GNUTLS_CERT_SIGNER_NOT_FOUND | GNUTLS_CERT_INVALID;\n\treturn 0;\n    }\n    if (!(flags & GNUTLS_VERIFY_DISABLE_CA_SIGN)) {\n\tif (gnutls_x509_crt_get_ca_status(issuer, NULL) != 1) {\n\t    gnutls_assert();\n\t    if (output)\n\t\t*output |= GNUTLS_CERT_SIGNER_NOT_CA | GNUTLS_CERT_INVALID;\n\t    return 0;\n\t}\n    }\n    result =\n\t_gnutls_x509_get_signed_data(crl->crl, \"tbsCertList\",\n\t\t\t\t     &crl_signed_data);\n    if (result < 0) {\n\tgnutls_assert();\n\tgoto cleanup;\n    }\n    result =\n\t_gnutls_x509_get_signature(crl->crl, \"signature\", &crl_signature);\n    if (result < 0) {\n\tgnutls_assert();\n\tgoto cleanup;\n    }\n    ret =\n\t_gnutls_x509_verify_signature(&crl_signed_data, &crl_signature,\n\t\t\t\t      issuer);\n    if (ret < 0) {\n\tgnutls_assert();\n    } else if (ret == 0) {\n\tgnutls_assert();\n\tif (output)\n\t    *output |= GNUTLS_CERT_INVALID;\n\tret = 0;\n    }\n    result = ret;\n  cleanup:\n    _gnutls_free_datum(&crl_signed_data);\n    _gnutls_free_datum(&crl_signature);\n    return result;\n}", "target": 0}
{"code": "static void cliRefreshPrompt(void) {\n    int len;\n    if (config.eval_ldb) return;\n    if (config.hostsocket != NULL)\n        len = snprintf(config.prompt,sizeof(config.prompt),\"redis %s\",\n                       config.hostsocket);\n    else\n        len = anetFormatAddr(config.prompt, sizeof(config.prompt),\n                           config.hostip, config.hostport);\n    if (config.dbnum != 0)\n        len += snprintf(config.prompt+len,sizeof(config.prompt)-len,\"[%d]\",\n            config.dbnum);\n    snprintf(config.prompt+len,sizeof(config.prompt)-len,\"> \");\n}", "target": 1}
{"code": "void __drm_atomic_state_free(struct kref *ref)\n{\n\tstruct drm_atomic_state *state = container_of(ref, typeof(*state), ref);\n\tstruct drm_mode_config *config = &state->dev->mode_config;\n\tdrm_atomic_state_clear(state);\n\tdrm_dbg_atomic(state->dev, \"Freeing atomic state %p\\n\", state);\n\tif (config->funcs->atomic_state_free) {\n\t\tconfig->funcs->atomic_state_free(state);\n\t} else {\n\t\tdrm_atomic_state_default_release(state);\n\t\tkfree(state);\n\t}\n}", "target": 1}
{"code": "static int check_submodule_url(const char *url)\n{\n\tconst char *curl_url;\n\tif (looks_like_command_line_option(url))\n\t\treturn -1;\n\tif (submodule_url_is_relative(url)) {\n\t\tchar *decoded = url_decode(url);\n\t\tint has_nl = !!strchr(decoded, '\\n');\n\t\tfree(decoded);\n\t\tif (has_nl)\n\t\t\treturn -1;\n\t}\n\telse if (url_to_curl_url(url, &curl_url)) {\n\t\tstruct credential c = CREDENTIAL_INIT;\n\t\tint ret = credential_from_url_gently(&c, curl_url, 1);\n\t\tcredential_clear(&c);\n\t\treturn ret;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)\n{\n\tconst struct sched_class *class;\n\tif (p->sched_class == rq->curr->sched_class) {\n\t\trq->curr->sched_class->check_preempt_curr(rq, p, flags);\n\t} else {\n\t\tfor_each_class(class) {\n\t\t\tif (class == rq->curr->sched_class)\n\t\t\t\tbreak;\n\t\t\tif (class == p->sched_class) {\n\t\t\t\tresched_task(rq->curr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (test_tsk_need_resched(rq->curr))\n\t\trq->skip_clock_update = 1;\n}", "target": 1}
{"code": "njs_function_frame_save(njs_vm_t *vm, njs_frame_t *frame, u_char *pc)\n{\n    size_t              value_count, n;\n    njs_value_t         *start, *end, *p, **new, *value, **local;\n    njs_function_t      *function;\n    njs_native_frame_t  *active, *native;\n    *frame = *vm->active_frame;\n    frame->previous_active_frame = NULL;\n    native = &frame->native;\n    active = &vm->active_frame->native;\n    value_count = njs_function_frame_value_count(active);\n    function = active->function;\n    new = (njs_value_t **) ((u_char *) native + NJS_FRAME_SIZE);\n    value = (njs_value_t *) (new + value_count\n                             + function->u.lambda->temp);\n    native->arguments = value;\n    native->arguments_offset = value + (function->args_offset - 1);\n    native->local = new + njs_function_frame_args_count(active);\n    native->temp = new + value_count;\n    native->pc = pc;\n    start = njs_function_frame_values(active, &end);\n    p = native->arguments;\n    while (start < end) {\n        *p = *start++;\n        *new++ = p++;\n    }\n    p = native->arguments;\n    local = native->local + function->args_offset;\n    for (n = 0; n < function->args_count; n++) {\n        if (!njs_is_valid(p)) {\n            njs_set_undefined(p);\n        }\n        *local++ = p++;\n    }\n    return NJS_OK;\n}", "target": 1}
{"code": "void gnrc_sixlowpan_iphc_send(gnrc_pktsnip_t *pkt, void *ctx, unsigned page)\n{\n    gnrc_netif_hdr_t *netif_hdr = pkt->data;\n    gnrc_netif_t *netif = gnrc_netif_hdr_get_netif(netif_hdr);\n    gnrc_pktsnip_t *tmp;\n    size_t orig_datagram_size = gnrc_pkt_len(pkt->next);\n    ipv6_hdr_t *ipv6_hdr = pkt->next->data;\n    ipv6_addr_t dst;\n    if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD)) {\n        dst = ipv6_hdr->dst;    \n    }\n    if ((tmp = _iphc_encode(pkt, pkt->data, netif))) {\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD) && (ctx != NULL) &&\n            (gnrc_sixlowpan_frag_minfwd_frag_iphc(tmp, orig_datagram_size, &dst,\n                                                  ctx) == 0)) {\n            DEBUG(\"6lo iphc minfwd: putting slack in first fragment\\n\");\n            return;\n        }\n        gnrc_sixlowpan_multiplex_by_size(tmp, orig_datagram_size, netif, page);\n    }\n    else {\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD)) {\n            gnrc_sixlowpan_frag_fb_t *fb = ctx;\n            if (fb->pkt == pkt) {\n                fb->pkt = NULL;\n            }\n        }\n        gnrc_pktbuf_release(pkt);\n    }\n}", "target": 0}
{"code": "int av_reallocp_array(void *ptr, size_t nmemb, size_t size)\n{\n    void **ptrptr = ptr;\n    *ptrptr = av_realloc_f(*ptrptr, nmemb, size);\n    if (!*ptrptr && !(nmemb && size))\n        return AVERROR(ENOMEM);\n    return 0;\n}", "target": 1}
{"code": "cache_user_id (KBNODE keyblock)\n{\n  user_id_db_t r;\n  const char *uid;\n  size_t uidlen;\n  keyid_list_t keyids = NULL;\n  KBNODE k;\n  for (k = keyblock; k; k = k->next)\n    {\n      if (k->pkt->pkttype == PKT_PUBLIC_KEY\n\t  || k->pkt->pkttype == PKT_PUBLIC_SUBKEY)\n\t{\n\t  keyid_list_t a = xmalloc_clear (sizeof *a);\n\t  keyid_from_pk (k->pkt->pkt.public_key, a->keyid);\n\t  for (r = user_id_db; r; r = r->next)\n\t    {\n\t      keyid_list_t b = r->keyids;\n\t      for (b = r->keyids; b; b = b->next)\n\t\t{\n\t\t  if (b->keyid[0] == a->keyid[0]\n\t\t      && b->keyid[1] == a->keyid[1])\n\t\t    {\n\t\t      if (DBG_CACHE)\n\t\t\tlog_debug (\"cache_user_id: already in cache\\n\");\n\t\t      release_keyid_list (keyids);\n\t\t      xfree (a);\n\t\t      return;\n\t\t    }\n\t\t}\n\t    }\n\t  a->next = keyids;\n\t  keyids = a;\n\t}\n    }\n  if (!keyids)\n    BUG (); \n  uid = get_primary_uid (keyblock, &uidlen);\n  if (uid_cache_entries >= MAX_UID_CACHE_ENTRIES)\n    {\n      r = user_id_db;\n      user_id_db = r->next;\n      release_keyid_list (r->keyids);\n      xfree (r);\n      uid_cache_entries--;\n    }\n  r = xmalloc (sizeof *r + uidlen - 1);\n  r->keyids = keyids;\n  r->len = uidlen;\n  memcpy (r->name, uid, r->len);\n  r->next = user_id_db;\n  user_id_db = r;\n  uid_cache_entries++;\n}", "target": 0}
{"code": "static int mbochs_probe(struct mdev_device *mdev)\n{\n\tconst struct mbochs_type *type =\n\t\t&mbochs_types[mdev_get_type_group_id(mdev)];\n\tstruct device *dev = mdev_dev(mdev);\n\tstruct mdev_state *mdev_state;\n\tint ret = -ENOMEM;\n\tif (type->mbytes + mbochs_used_mbytes > max_mbytes)\n\t\treturn -ENOMEM;\n\tmdev_state = kzalloc(sizeof(struct mdev_state), GFP_KERNEL);\n\tif (mdev_state == NULL)\n\t\treturn -ENOMEM;\n\tvfio_init_group_dev(&mdev_state->vdev, &mdev->dev, &mbochs_dev_ops);\n\tmdev_state->vconfig = kzalloc(MBOCHS_CONFIG_SPACE_SIZE, GFP_KERNEL);\n\tif (mdev_state->vconfig == NULL)\n\t\tgoto err_mem;\n\tmdev_state->memsize = type->mbytes * 1024 * 1024;\n\tmdev_state->pagecount = mdev_state->memsize >> PAGE_SHIFT;\n\tmdev_state->pages = kcalloc(mdev_state->pagecount,\n\t\t\t\t    sizeof(struct page *),\n\t\t\t\t    GFP_KERNEL);\n\tif (!mdev_state->pages)\n\t\tgoto err_mem;\n\tdev_info(dev, \"%s: %s, %d MB, %ld pages\\n\", __func__,\n\t\t type->name, type->mbytes, mdev_state->pagecount);\n\tmutex_init(&mdev_state->ops_lock);\n\tmdev_state->mdev = mdev;\n\tINIT_LIST_HEAD(&mdev_state->dmabufs);\n\tmdev_state->next_id = 1;\n\tmdev_state->type = type;\n\tmdev_state->edid_regs.max_xres = type->max_x;\n\tmdev_state->edid_regs.max_yres = type->max_y;\n\tmdev_state->edid_regs.edid_offset = MBOCHS_EDID_BLOB_OFFSET;\n\tmdev_state->edid_regs.edid_max_size = sizeof(mdev_state->edid_blob);\n\tmbochs_create_config_space(mdev_state);\n\tmbochs_reset(mdev_state);\n\tmbochs_used_mbytes += type->mbytes;\n\tret = vfio_register_group_dev(&mdev_state->vdev);\n\tif (ret)\n\t\tgoto err_mem;\n\tdev_set_drvdata(&mdev->dev, mdev_state);\n\treturn 0;\nerr_mem:\n\tkfree(mdev_state->vconfig);\n\tkfree(mdev_state);\n\treturn ret;\n}", "target": 1}
{"code": "static struct sk_buff *udp_gro_receive_segment(struct list_head *head,\n\t\t\t\t\t       struct sk_buff *skb)\n{\n\tstruct udphdr *uh = udp_hdr(skb);\n\tstruct sk_buff *pp = NULL;\n\tstruct udphdr *uh2;\n\tstruct sk_buff *p;\n\tif (!uh->check) {\n\t\tNAPI_GRO_CB(skb)->flush = 1;\n\t\treturn NULL;\n\t}\n\tskb_gro_pull(skb, sizeof(struct udphdr));\n\tskb_gro_postpull_rcsum(skb, uh, sizeof(struct udphdr));\n\tlist_for_each_entry(p, head, list) {\n\t\tif (!NAPI_GRO_CB(p)->same_flow)\n\t\t\tcontinue;\n\t\tuh2 = udp_hdr(p);\n\t\tif ((*(u32 *)&uh->source != *(u32 *)&uh2->source)) {\n\t\t\tNAPI_GRO_CB(p)->same_flow = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (uh->len > uh2->len || skb_gro_receive(p, skb) ||\n\t\t    uh->len != uh2->len ||\n\t\t    NAPI_GRO_CB(p)->count >= UDP_GRO_CNT_MAX)\n\t\t\tpp = p;\n\t\treturn pp;\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "nfsd4_encode_layoutget(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\tstruct nfsd4_layoutget *lgp)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tconst struct nfsd4_layout_ops *ops =\n\t\tnfsd4_layout_ops[lgp->lg_layout_type];\n\t__be32 *p;\n\tdprintk(\"%s: err %d\\n\", __func__, nfserr);\n\tif (nfserr)\n\t\tgoto out;\n\tnfserr = nfserr_resource;\n\tp = xdr_reserve_space(xdr, 36 + sizeof(stateid_opaque_t));\n\tif (!p)\n\t\tgoto out;\n\t*p++ = cpu_to_be32(1);\t\n\t*p++ = cpu_to_be32(lgp->lg_sid.si_generation);\n\tp = xdr_encode_opaque_fixed(p, &lgp->lg_sid.si_opaque,\n\t\t\t\t    sizeof(stateid_opaque_t));\n\t*p++ = cpu_to_be32(1);\t\n\tp = xdr_encode_hyper(p, lgp->lg_seg.offset);\n\tp = xdr_encode_hyper(p, lgp->lg_seg.length);\n\t*p++ = cpu_to_be32(lgp->lg_seg.iomode);\n\t*p++ = cpu_to_be32(lgp->lg_layout_type);\n\tnfserr = ops->encode_layoutget(xdr, lgp);\nout:\n\tkfree(lgp->lg_content);\n\treturn nfserr;\n}", "target": 1}
{"code": "rdr_notification_ctx_init(struct rdr_notification_ctx *ctx)\n{\n\tdeltas_parsed_init(&ctx->deltas);\n\treturn 0;\n}", "target": 1}
{"code": "static void write_cachehdr(const char *name, const char *contents,\n                           const char *raw __attribute__((unused)), void *rock)\n{\n    struct transaction_t *txn = (struct transaction_t *) rock;\n    const char **hdr, *hop_by_hop[] =\n        { \"connection\", \"content-length\", \"content-type\", \"date\", \"forwarded\",\n          \"keep-alive\", \"location\", \"status\", \"strict-transport-security\",\n          \"upgrade\", \"via\", NULL };\n    if (name[0] == ':') return;\n    for (hdr = hop_by_hop; *hdr; hdr++) {\n        if (!strcasecmp(name, *hdr)) return;\n    }\n    simple_hdr(txn, name, contents);\n}", "target": 0}
{"code": "static int getid(char ch) {\n\tconst char *keys = \"[]<>+-,.\";\n\tconst char *cidx = strchr (keys, ch);\n\treturn cidx? cidx - keys + 1: 0;\n}", "target": 1}
{"code": "  void setSanMatchers(std::vector<envoy::type::matcher::v3::StringMatcher> san_matchers) {\n    san_matchers_ = san_matchers;\n  };", "target": 1}
{"code": "int inet_sk_rebuild_header(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct rtable *rt = (struct rtable *)__sk_dst_check(sk, 0);\n\t__be32 daddr;\n\tint err;\n\tif (rt)\n\t\treturn 0;\n\tdaddr = inet->inet_daddr;\n\tif (inet->opt && inet->opt->srr)\n\t\tdaddr = inet->opt->faddr;\n\trt = ip_route_output_ports(sock_net(sk), sk, daddr, inet->inet_saddr,\n\t\t\t\t   inet->inet_dport, inet->inet_sport,\n\t\t\t\t   sk->sk_protocol, RT_CONN_FLAGS(sk),\n\t\t\t\t   sk->sk_bound_dev_if);\n\tif (!IS_ERR(rt)) {\n\t\terr = 0;\n\t\tsk_setup_caps(sk, &rt->dst);\n\t} else {\n\t\terr = PTR_ERR(rt);\n\t\tsk->sk_route_caps = 0;\n\t\tif (!sysctl_ip_dynaddr ||\n\t\t    sk->sk_state != TCP_SYN_SENT ||\n\t\t    (sk->sk_userlocks & SOCK_BINDADDR_LOCK) ||\n\t\t    (err = inet_sk_reselect_saddr(sk)) != 0)\n\t\t\tsk->sk_err_soft = -err;\n\t}\n\treturn err;\n}", "target": 1}
{"code": "static void\nyydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, void *yyscanner, HEX_LEX_ENVIRONMENT *lex_env)\n{\n  YYUSE (yyvaluep);\n  YYUSE (yyscanner);\n  YYUSE (lex_env);\n  if (!yymsg)\n    yymsg = \"Deleting\";\n  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  switch (yytype)\n    {\n          case 16: \n#line 94 \"hex_grammar.y\" \n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1023 \"hex_grammar.c\" \n        break;\n    case 17: \n#line 95 \"hex_grammar.y\" \n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1029 \"hex_grammar.c\" \n        break;\n    case 18: \n#line 96 \"hex_grammar.y\" \n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1035 \"hex_grammar.c\" \n        break;\n    case 19: \n#line 97 \"hex_grammar.y\" \n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1041 \"hex_grammar.c\" \n        break;\n    case 21: \n#line 100 \"hex_grammar.y\" \n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1047 \"hex_grammar.c\" \n        break;\n    case 22: \n#line 99 \"hex_grammar.y\" \n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1053 \"hex_grammar.c\" \n        break;\n    case 23: \n#line 98 \"hex_grammar.y\" \n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1059 \"hex_grammar.c\" \n        break;\n      default:\n        break;\n    }", "target": 1}
{"code": "void imap_quote_string(char *dest, size_t dlen, const char *src)\n{\n  static const char quote[] = \"\\\"\\\\\";\n  char *pt = dest;\n  const char *s = src;\n  *pt++ = '\"';\n  dlen -= 2;\n  for (; *s && dlen; s++)\n  {\n    if (strchr(quote, *s))\n    {\n      dlen -= 2;\n      if (dlen == 0)\n        break;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\"';\n  *pt = '\\0';\n}", "target": 1}
{"code": "static int atalk_create(struct net *net, struct socket *sock, int protocol,\n\t\t\tint kern)\n{\n\tstruct sock *sk;\n\tint rc = -ESOCKTNOSUPPORT;\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\tif (sock->type != SOCK_RAW && sock->type != SOCK_DGRAM)\n\t\tgoto out;\n\trc = -ENOMEM;\n\tsk = sk_alloc(net, PF_APPLETALK, GFP_KERNEL, &ddp_proto, kern);\n\tif (!sk)\n\t\tgoto out;\n\trc = 0;\n\tsock->ops = &atalk_dgram_ops;\n\tsock_init_data(sock, sk);\n\tsock_set_flag(sk, SOCK_ZAPPED);\nout:\n\treturn rc;\n}", "target": 1}
{"code": "void WasmBinaryBuilder::readTableDeclarations() {\n  BYN_TRACE(\"== readTableDeclarations\\n\");\n  auto numTables = getU32LEB();\n  for (size_t i = 0; i < numTables; i++) {\n    auto elemType = getType();\n    if (!elemType.isRef()) {\n      throwError(\"Table type must be a reference type\");\n    }\n    auto table = Builder::makeTable(Name::fromInt(i), elemType);\n    bool is_shared;\n    Type indexType;\n    getResizableLimits(\n      table->initial, table->max, is_shared, indexType, Table::kUnlimitedSize);\n    if (is_shared) {\n      throwError(\"Tables may not be shared\");\n    }\n    if (indexType == Type::i64) {\n      throwError(\"Tables may not be 64-bit\");\n    }\n    tables.push_back(std::move(table));\n  }\n}", "target": 0}
{"code": "static struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)\n{\n\tstruct hlist_head *hashent = ucounts_hashentry(ns, uid);\n\tstruct ucounts *ucounts, *new;\n\tspin_lock_irq(&ucounts_lock);\n\tucounts = find_ucounts(ns, uid, hashent);\n\tif (!ucounts) {\n\t\tspin_unlock_irq(&ucounts_lock);\n\t\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\t\tif (!new)\n\t\t\treturn NULL;\n\t\tnew->ns = ns;\n\t\tnew->uid = uid;\n\t\tatomic_set(&new->count, 0);\n\t\tspin_lock_irq(&ucounts_lock);\n\t\tucounts = find_ucounts(ns, uid, hashent);\n\t\tif (ucounts) {\n\t\t\tkfree(new);\n\t\t} else {\n\t\t\thlist_add_head(&new->node, hashent);\n\t\t\tucounts = new;\n\t\t}\n\t}\n\tif (!atomic_add_unless(&ucounts->count, 1, INT_MAX))\n\t\tucounts = NULL;\n\tspin_unlock_irq(&ucounts_lock);\n\treturn ucounts;\n}", "target": 1}
{"code": "static int dsa_missing_parameters(const EVP_PKEY *pkey)\n{\n    DSA *dsa;\n    dsa = pkey->pkey.dsa;\n    if ((dsa->p == NULL) || (dsa->q == NULL) || (dsa->g == NULL))\n        return 1;\n    return 0;\n}", "target": 0}
{"code": "static int pull_client_data (struct conn_s *connptr, long int length, int iehack)\n{\n        char *buffer;\n        ssize_t len;\n        int ret;\n        buffer =\n            (char *) safemalloc (min (MAXBUFFSIZE, (unsigned long int) length));\n        if (!buffer)\n                return -1;\n        do {\n                len = safe_read (connptr->client_fd, buffer,\n                                 min (MAXBUFFSIZE, (unsigned long int) length));\n                if (len <= 0)\n                        goto ERROR_EXIT;\n                if (!connptr->error_variables) {\n                        if (safe_write (connptr->server_fd, buffer, len) < 0)\n                                goto ERROR_EXIT;\n                }\n                length -= len;\n        } while (length > 0);\n        if (iehack) {\n                ret = socket_nonblocking (connptr->client_fd);\n                if (ret != 0) {\n                        log_message(LOG_ERR, \"Failed to set the client socket \"\n                                    \"to non-blocking: %s\", strerror(errno));\n                        goto ERROR_EXIT;\n                }\n                len = recv (connptr->client_fd, buffer, 2, MSG_PEEK);\n                ret = socket_blocking (connptr->client_fd);\n                if (ret != 0) {\n                        log_message(LOG_ERR, \"Failed to set the client socket \"\n                                    \"to blocking: %s\", strerror(errno));\n                        goto ERROR_EXIT;\n                }\n                if (len < 0 && errno != EAGAIN)\n                        goto ERROR_EXIT;\n                if ((len == 2) && CHECK_CRLF (buffer, len)) {\n                        ssize_t bytes_read;\n                        bytes_read = read (connptr->client_fd, buffer, 2);\n                        if (bytes_read == -1) {\n                                log_message\n                                        (LOG_WARNING,\n                                         \"Could not read two bytes from POST message\");\n                        }\n                }\n        }\n        safefree (buffer);\n        return 0;\nERROR_EXIT:\n        safefree (buffer);\n        return -1;\n}", "target": 0}
{"code": "int64_t OutputFile::readImpl(char* , int64_t ) {\n  raise_warning(\"cannot read from a php:\n  return -1;\n}", "target": 1}
{"code": "void av_fast_padded_malloc(void *ptr, unsigned int *size, size_t min_size)\n{\n    uint8_t **p = ptr;\n    if (min_size > SIZE_MAX - FF_INPUT_BUFFER_PADDING_SIZE) {\n        av_freep(p);\n        *size = 0;\n        return;\n    }\n    if (!ff_fast_malloc(p, size, min_size + FF_INPUT_BUFFER_PADDING_SIZE, 1))\n        memset(*p + min_size, 0, FF_INPUT_BUFFER_PADDING_SIZE);\n}", "target": 0}
{"code": "static int unix_socketpair(struct socket *socka, struct socket *sockb)\n{\n\tstruct sock *ska = socka->sk, *skb = sockb->sk;\n\tsock_hold(ska);\n\tsock_hold(skb);\n\tunix_peer(ska) = skb;\n\tunix_peer(skb) = ska;\n\tinit_peercred(ska);\n\tinit_peercred(skb);\n\tif (ska->sk_type != SOCK_DGRAM) {\n\t\tska->sk_state = TCP_ESTABLISHED;\n\t\tskb->sk_state = TCP_ESTABLISHED;\n\t\tsocka->state  = SS_CONNECTED;\n\t\tsockb->state  = SS_CONNECTED;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "spnego_gss_inquire_cred(\n\t\t\tOM_uint32 *minor_status,\n\t\t\tgss_cred_id_t cred_handle,\n\t\t\tgss_name_t *name,\n\t\t\tOM_uint32 *lifetime,\n\t\t\tint *cred_usage,\n\t\t\tgss_OID_set *mechanisms)\n{\n\tOM_uint32 status;\n\tspnego_gss_cred_id_t spcred = NULL;\n\tgss_cred_id_t creds = GSS_C_NO_CREDENTIAL;\n\tOM_uint32 tmp_minor_status;\n\tOM_uint32 initiator_lifetime, acceptor_lifetime;\n\tdsyslog(\"Entering inquire_cred\\n\");\n\tspcred = (spnego_gss_cred_id_t)cred_handle;\n\tif (spcred == NULL) {\n\t\tstatus = get_available_mechs(minor_status,\n\t\t\tGSS_C_NO_NAME,\n\t\t\tGSS_C_BOTH,\n\t\t\tGSS_C_NO_CRED_STORE,\n\t\t\t&creds,\n\t\t\tmechanisms);\n\t\tif (status != GSS_S_COMPLETE) {\n\t\t\tdsyslog(\"Leaving inquire_cred\\n\");\n\t\t\treturn (status);\n\t\t}\n\t\tif ((*mechanisms)->count == 0) {\n\t\t\tgss_release_cred(&tmp_minor_status, &creds);\n\t\t\tgss_release_oid_set(&tmp_minor_status, mechanisms);\n\t\t\tdsyslog(\"Leaving inquire_cred\\n\");\n\t\t\treturn (GSS_S_DEFECTIVE_CREDENTIAL);\n\t\t}\n\t\tassert((*mechanisms)->elements != NULL);\n\t\tstatus = gss_inquire_cred_by_mech(minor_status,\n\t\t\tcreds,\n\t\t\t&(*mechanisms)->elements[0],\n\t\t\tname,\n\t\t\t&initiator_lifetime,\n\t\t\t&acceptor_lifetime,\n\t\t\tcred_usage);\n\t\tif (status != GSS_S_COMPLETE) {\n\t\t\tgss_release_cred(&tmp_minor_status, &creds);\n\t\t\tdsyslog(\"Leaving inquire_cred\\n\");\n\t\t\treturn (status);\n\t\t}\n\t\tif (lifetime != NULL)\n\t\t\t*lifetime = (*cred_usage == GSS_C_ACCEPT) ?\n\t\t\t\tacceptor_lifetime : initiator_lifetime;\n\t\tgss_release_cred(&tmp_minor_status, &creds);\n\t} else {\n\t\tstatus = gss_inquire_cred(minor_status, spcred->mcred,\n\t\t\t\t\t  name, lifetime,\n\t\t\t\t\t  cred_usage, mechanisms);\n\t}\n\tdsyslog(\"Leaving inquire_cred\\n\");\n\treturn (status);\n}", "target": 0}
{"code": "static void put_crypt_info(struct fscrypt_info *ci)\n{\n\tif (!ci)\n\t\treturn;\n\tkey_put(ci->ci_keyring_key);\n\tcrypto_free_skcipher(ci->ci_ctfm);\n\tkmem_cache_free(fscrypt_info_cachep, ci);\n}", "target": 1}
{"code": "DLLEXPORT int DLLCALL tjEncodeYUV3(tjhandle handle,\n\tconst unsigned char *srcBuf, int width, int pitch, int height,\n\tint pixelFormat, unsigned char *dstBuf, int pad, int subsamp, int flags)\n{\n\tunsigned char *dstPlanes[3];\n\tint pw0, ph0, strides[3], retval=-1;\n\tif(width<=0 || height<=0 || dstBuf==NULL || pad<0 || !isPow2(pad)\n\t\t|| subsamp<0 || subsamp>=NUMSUBOPT)\n\t\t_throw(\"tjEncodeYUV3(): Invalid argument\");\n\tpw0=tjPlaneWidth(0, width, subsamp);\n\tph0=tjPlaneHeight(0, height, subsamp);\n\tdstPlanes[0]=dstBuf;\n\tstrides[0]=PAD(pw0, pad);\n\tif(subsamp==TJSAMP_GRAY)\n\t{\n\t\tstrides[1]=strides[2]=0;\n\t\tdstPlanes[1]=dstPlanes[2]=NULL;\n\t}\n\telse\n\t{\n\t\tint pw1=tjPlaneWidth(1, width, subsamp);\n\t\tint ph1=tjPlaneHeight(1, height, subsamp);\n\t\tstrides[1]=strides[2]=PAD(pw1, pad);\n\t\tdstPlanes[1]=dstPlanes[0]+strides[0]*ph0;\n\t\tdstPlanes[2]=dstPlanes[1]+strides[1]*ph1;\n\t}\n\treturn tjEncodeYUVPlanes(handle, srcBuf, width, pitch, height, pixelFormat,\n\t\tdstPlanes, strides, subsamp, flags);\n\tbailout:\n\treturn retval;\n}", "target": 0}
{"code": "static int get_dev_to_use(struct spk_synth *synth, dev_t *dev_no)\n{\n\tif (strcmp(synth->dev_name, SYNTH_DEFAULT_DEV) ||\n\t    synth->ser == SYNTH_DEFAULT_SER)\n\t\treturn tty_dev_name_to_number(synth->dev_name, dev_no);\n\treturn ser_to_dev(synth->ser, dev_no);\n}", "target": 0}
{"code": "void close_cached_dir(struct cached_fid *cfid)\n{\n\tmutex_lock(&cfid->fid_mutex);\n\tkref_put(&cfid->refcount, smb2_close_cached_fid);\n\tmutex_unlock(&cfid->fid_mutex);\n}", "target": 0}
{"code": "do_sleep(long msec, int hide_cursor)\n{\n    long\tdone = 0;\n    long\twait_now;\n# ifdef ELAPSED_FUNC\n    elapsed_T\tstart_tv;\n    ELAPSED_INIT(start_tv);\n# endif\n    if (hide_cursor)\n        cursor_sleep();\n    else\n        cursor_on();\n    out_flush_cursor(FALSE, FALSE);\n    while (!got_int && done < msec)\n    {\n\twait_now = msec - done > 1000L ? 1000L : msec - done;\n#ifdef FEAT_TIMERS\n\t{\n\t    long    due_time = check_due_timer();\n\t    if (due_time > 0 && due_time < wait_now)\n\t\twait_now = due_time;\n\t}\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\tif (has_any_channel() && wait_now > 20L)\n\t    wait_now = 20L;\n#endif\n#ifdef FEAT_SOUND\n\tif (has_any_sound_callback() && wait_now > 20L)\n\t    wait_now = 20L;\n#endif\n\tui_delay(wait_now, TRUE);\n#ifdef FEAT_JOB_CHANNEL\n\tif (has_any_channel())\n\t    ui_breakcheck_force(TRUE);\n\telse\n#endif\n\t    ui_breakcheck();\n#ifdef MESSAGE_QUEUE\n\tparse_queued_messages();\n#endif\n# ifdef ELAPSED_FUNC\n\tdone = ELAPSED_FUNC(start_tv);\n# else\n\tdone += wait_now;\n# endif\n    }\n    if (got_int)\n\t(void)vpeekc();\n    if (hide_cursor)\n        cursor_unsleep();\n}", "target": 0}
{"code": "int anon_vma_clone(struct vm_area_struct *dst, struct vm_area_struct *src)\n{\n\tstruct anon_vma_chain *avc, *pavc;\n\tstruct anon_vma *root = NULL;\n\tlist_for_each_entry_reverse(pavc, &src->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma;\n\t\tavc = anon_vma_chain_alloc(GFP_NOWAIT | __GFP_NOWARN);\n\t\tif (unlikely(!avc)) {\n\t\t\tunlock_anon_vma_root(root);\n\t\t\troot = NULL;\n\t\t\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\t\t\tif (!avc)\n\t\t\t\tgoto enomem_failure;\n\t\t}\n\t\tanon_vma = pavc->anon_vma;\n\t\troot = lock_anon_vma_root(root, anon_vma);\n\t\tanon_vma_chain_link(dst, avc, anon_vma);\n\t\tif (!dst->anon_vma && src->anon_vma &&\n\t\t    anon_vma != src->anon_vma && anon_vma->degree < 2)\n\t\t\tdst->anon_vma = anon_vma;\n\t}\n\tif (dst->anon_vma)\n\t\tdst->anon_vma->degree++;\n\tunlock_anon_vma_root(root);\n\treturn 0;\n enomem_failure:\n\tdst->anon_vma = NULL;\n\tunlink_anon_vmas(dst);\n\treturn -ENOMEM;\n}", "target": 1}
{"code": "static void early_init_amd(struct cpuinfo_x86 *c)\n{\n\tearly_init_amd_mc(c);\n\tif (c->x86_power & (1 << 8)) {\n\t\tset_cpu_cap(c, X86_FEATURE_CONSTANT_TSC);\n\t\tset_cpu_cap(c, X86_FEATURE_NONSTOP_TSC);\n\t\tif (!check_tsc_unstable())\n\t\t\tsched_clock_stable = 1;\n\t}\n#ifdef CONFIG_X86_64\n\tset_cpu_cap(c, X86_FEATURE_SYSCALL32);\n#else\n\tif (c->x86 == 5)\n\t\tif (c->x86_model == 13 || c->x86_model == 9 ||\n\t\t    (c->x86_model == 8 && c->x86_mask >= 8))\n\t\t\tset_cpu_cap(c, X86_FEATURE_K6_MTRR);\n#endif\n#if defined(CONFIG_X86_LOCAL_APIC) && defined(CONFIG_PCI)\n\tif (cpu_has_apic && c->x86 >= 0xf) {\n\t\tunsigned int val;\n\t\tval = read_pci_config(0, 24, 0, 0x68);\n\t\tif ((val & ((1 << 17) | (1 << 18))) == ((1 << 17) | (1 << 18)))\n\t\t\tset_cpu_cap(c, X86_FEATURE_EXTD_APICID);\n\t}\n#endif\n}", "target": 1}
{"code": "static int crypto_ahash_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_hash rhash;\n\tsnprintf(rhash.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"ahash\");\n\trhash.blocksize = alg->cra_blocksize;\n\trhash.digestsize = __crypto_hash_alg_common(alg)->digestsize;\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_HASH,\n\t\t    sizeof(struct crypto_report_hash), &rhash))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "canonicalize_path (const char *path, char **pcanonical)\n{\n  char *canonical = 0;\n  assert (path && *path);\n  assert (pcanonical);\n  canonical = MALLOC (char, 1+ LT_STRLEN (path));\n  if (!canonical)\n    return 1;\n  {\n    size_t dest = 0;\n    size_t src;\n    for (src = 0; path[src] != LT_EOS_CHAR; ++src)\n      {\n\tif (path[src] == LT_PATHSEP_CHAR)\n\t  {\n\t    if ((dest == 0)\n\t\t|| (path[1+ src] == LT_PATHSEP_CHAR)\n\t\t|| (path[1+ src] == LT_EOS_CHAR))\n\t      continue;\n\t  }\n\tif ((path[src] != '/')\n#if defined(LT_DIRSEP_CHAR)\n\t    && (path[src] != LT_DIRSEP_CHAR)\n#endif\n\t    )\n\t  {\n\t    canonical[dest++] = path[src];\n\t  }\n\telse if ((path[1+ src] != LT_PATHSEP_CHAR)\n\t\t && (path[1+ src] != LT_EOS_CHAR)\n#if defined(LT_DIRSEP_CHAR)\n\t\t && (path[1+ src] != LT_DIRSEP_CHAR)\n#endif\n\t\t && (path[1+ src] != '/'))\n\t  {\n\t    canonical[dest++] = '/';\n\t  }\n      }\n    canonical[dest] = LT_EOS_CHAR;\n  }\n  *pcanonical = canonical;\n  return 0;\n}", "target": 0}
{"code": "static __init int vdso_do_find_sections(struct lib32_elfinfo *v32,\n\t\t\t\t\tstruct lib64_elfinfo *v64)\n{\n\tvoid *sect;\n\tv32->dynsym = find_section32(v32->hdr, \".dynsym\", &v32->dynsymsize);\n\tv32->dynstr = find_section32(v32->hdr, \".dynstr\", NULL);\n\tif (v32->dynsym == NULL || v32->dynstr == NULL) {\n\t\tprintk(KERN_ERR \"vDSO32: required symbol section not found\\n\");\n\t\treturn -1;\n\t}\n\tsect = find_section32(v32->hdr, \".text\", NULL);\n\tif (sect == NULL) {\n\t\tprintk(KERN_ERR \"vDSO32: the .text section was not found\\n\");\n\t\treturn -1;\n\t}\n\tv32->text = sect - vdso32_kbase;\n#ifdef CONFIG_PPC64\n\tv64->dynsym = find_section64(v64->hdr, \".dynsym\", &v64->dynsymsize);\n\tv64->dynstr = find_section64(v64->hdr, \".dynstr\", NULL);\n\tif (v64->dynsym == NULL || v64->dynstr == NULL) {\n\t\tprintk(KERN_ERR \"vDSO64: required symbol section not found\\n\");\n\t\treturn -1;\n\t}\n\tsect = find_section64(v64->hdr, \".text\", NULL);\n\tif (sect == NULL) {\n\t\tprintk(KERN_ERR \"vDSO64: the .text section was not found\\n\");\n\t\treturn -1;\n\t}\n\tv64->text = sect - vdso64_kbase;\n#endif \n\treturn 0;\n}", "target": 0}
{"code": "sg_finish_rem_req(Sg_request *srp)\n{\n\tint ret = 0;\n\tSg_fd *sfp = srp->parentfp;\n\tSg_scatter_hold *req_schp = &srp->data;\n\tSCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t\t      \"sg_finish_rem_req: res_used=%d\\n\",\n\t\t\t\t      (int) srp->res_used));\n\tif (srp->bio)\n\t\tret = blk_rq_unmap_user(srp->bio);\n\tif (srp->rq) {\n\t\tscsi_req_free_cmd(scsi_req(srp->rq));\n\t\tblk_put_request(srp->rq);\n\t}\n\tif (srp->res_used)\n\t\tsg_unlink_reserve(sfp, srp);\n\telse\n\t\tsg_remove_scat(sfp, req_schp);\n\treturn ret;\n}", "target": 0}
{"code": "static Variant HHVM_FUNCTION(simplexml_import_dom,\n  const Object& node,\n  const String& class_name ) {\n  auto domnode = Native::data<DOMNode>(node);\n  xmlNodePtr nodep = domnode->nodep();\n  if (nodep) {\n    if (nodep->doc == nullptr) {\n      raise_warning(\"Imported Node must have associated Document\");\n      return init_null();\n    }\n    if (nodep->type == XML_DOCUMENT_NODE ||\n        nodep->type == XML_HTML_DOCUMENT_NODE) {\n      nodep = xmlDocGetRootElement((xmlDocPtr) nodep);\n    }\n  }\n  if (nodep && nodep->type == XML_ELEMENT_NODE) {\n    auto cls = class_from_name(class_name, \"simplexml_import_dom\");\n    if (!cls) {\n      return init_null();\n    }\n    Object obj = create_object(cls->nameStr(), Array(), false);\n    auto sxe = Native::data<SimpleXMLElement>(obj.get());\n    sxe->node = libxml_register_node(nodep);\n    return obj;\n  } else {\n    raise_warning(\"Invalid Nodetype to import\");\n    return init_null();\n  }\n  return false;\n}", "target": 1}
{"code": "crm_recv_tls(gnutls_session * session, size_t max_size, size_t *recv_len, int *disconnected)\n{\n    char *buf = NULL;\n    int rc = 0;\n    size_t len = 0;\n    size_t chunk_size = max_size ? max_size : 1024;\n    size_t buf_size = 0;\n    size_t read_size = 0;\n    if (session == NULL) {\n        if (disconnected) {\n            *disconnected = 1;\n        }\n        goto done;\n    }\n    buf = calloc(1, chunk_size + 1);\n    buf_size = chunk_size;\n    while (TRUE) {\n        read_size = buf_size - len;\n        if (!max_size && (read_size < (chunk_size / 2))) {\n            buf_size += chunk_size;\n            crm_trace(\"Grow buffer by %d more bytes. buf is now %d bytes\", (int)chunk_size, buf_size);\n            buf = realloc(buf, buf_size + 1);\n            CRM_ASSERT(buf != NULL);\n            read_size = buf_size - len;\n        }\n        rc = gnutls_record_recv(*session, buf + len, read_size);\n        if (rc > 0) {\n            crm_trace(\"Got %d more bytes.\", rc);\n            len += rc;\n            buf[len] = '\\0';\n        }\n        if (max_size && (max_size == read_size)) {\n            crm_trace(\"Buffer max read size %d met\" , max_size);\n            goto done;\n        }\n        if (rc == GNUTLS_E_INTERRUPTED) {\n            crm_trace(\"EINTR encoutered, retry tls read\");\n        } else if (rc == GNUTLS_E_AGAIN) {\n            crm_trace(\"non-blocking, exiting read on rc = %d\", rc);\n            goto done;\n        } else if (rc <= 0) {\n            if (rc == 0) {\n                crm_debug(\"EOF encoutered during TLS read\");\n            } else {\n                crm_debug(\"Error receiving message: %s (%d)\", gnutls_strerror(rc), rc);\n            }\n            if (disconnected) {\n                *disconnected = 1;\n            }\n            goto done;\n        }\n    }\ndone:\n    if (recv_len) {\n        *recv_len = len;\n    }\n    if (!len) {\n        free(buf);\n        buf = NULL;\n    }\n    return buf;\n}", "target": 0}
{"code": "ex_copy(linenr_T line1, linenr_T line2, linenr_T n)\n{\n    linenr_T\tcount;\n    char_u\t*p;\n    count = line2 - line1 + 1;\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\tcurbuf->b_op_start.lnum = n + 1;\n\tcurbuf->b_op_end.lnum = n + count;\n\tcurbuf->b_op_start.col = curbuf->b_op_end.col = 0;\n    }\n    if (u_save(n, n + 1) == FAIL)\n\treturn;\n    curwin->w_cursor.lnum = n;\n    while (line1 <= line2)\n    {\n\tp = vim_strsave(ml_get(line1));\n\tif (p != NULL)\n\t{\n\t    ml_append(curwin->w_cursor.lnum, p, (colnr_T)0, FALSE);\n\t    vim_free(p);\n\t}\n\tif (line1 == n)\n\t    line1 = curwin->w_cursor.lnum;\n\t++line1;\n\tif (curwin->w_cursor.lnum < line1)\n\t    ++line1;\n\tif (curwin->w_cursor.lnum < line2)\n\t    ++line2;\n\t++curwin->w_cursor.lnum;\n    }\n    appended_lines_mark(n, count);\n    msgmore((long)count);\n}", "target": 1}
{"code": "file_check_mem(struct magic_set *ms, unsigned int level)\n{\n\tsize_t len;\n\tif (level >= ms->c.len) {\n\t\tlen = (ms->c.len += 20) * sizeof(*ms->c.li);\n\t\tms->c.li = CAST(struct level_info *, (ms->c.li == NULL) ?\n\t\t    malloc(len) :\n\t\t    realloc(ms->c.li, len));\n\t\tif (ms->c.li == NULL) {\n\t\t\tfile_oomem(ms, len);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tms->c.li[level].got_match = 0;\n#ifdef ENABLE_CONDITIONALS\n\tms->c.li[level].last_match = 0;\n\tms->c.li[level].last_cond = COND_NONE;\n#endif \n\treturn 0;\n}", "target": 1}
{"code": "static void xcopy_pt_undepend_remotedev(struct xcopy_op *xop)\n{\n\tstruct se_device *remote_dev;\n\tif (xop->op_origin == XCOL_SOURCE_RECV_OP)\n\t\tremote_dev = xop->dst_dev;\n\telse\n\t\tremote_dev = xop->src_dev;\n\tpr_debug(\"Calling configfs_undepend_item for\"\n\t\t  \" remote_dev: %p remote_dev->dev_group: %p\\n\",\n\t\t  remote_dev, &remote_dev->dev_group.cg_item);\n\ttarget_undepend_item(&remote_dev->dev_group.cg_item);\n}", "target": 1}
{"code": "int mlx4_register_vlan(struct mlx4_dev *dev, u8 port, u16 vlan, int *index)\n{\n\tstruct mlx4_vlan_table *table = &mlx4_priv(dev)->port[port].vlan_table;\n\tint i, err = 0;\n\tint free = -1;\n\tmutex_lock(&table->mutex);\n\tfor (i = MLX4_VLAN_REGULAR; i < MLX4_MAX_VLAN_NUM; i++) {\n\t\tif (free < 0 && (table->refs[i] == 0)) {\n\t\t\tfree = i;\n\t\t\tcontinue;\n\t\t}\n\t\tif (table->refs[i] &&\n\t\t    (vlan == (MLX4_VLAN_MASK &\n\t\t\t      be32_to_cpu(table->entries[i])))) {\n\t\t\t*index = i;\n\t\t\t++table->refs[i];\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (free < 0) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tif (table->total == table->max) {\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\ttable->refs[free] = 1;\n\ttable->entries[free] = cpu_to_be32(vlan | MLX4_VLAN_VALID);\n\terr = mlx4_set_port_vlan_table(dev, port, table->entries);\n\tif (unlikely(err)) {\n\t\tmlx4_warn(dev, \"Failed adding vlan: %u\\n\", vlan);\n\t\ttable->refs[free] = 0;\n\t\ttable->entries[free] = 0;\n\t\tgoto out;\n\t}\n\t*index = free;\n\t++table->total;\nout:\n\tmutex_unlock(&table->mutex);\n\treturn err;\n}", "target": 0}
{"code": "void fuse_sync_release(struct fuse_file *ff, int flags)\n{\n\tWARN_ON(atomic_read(&ff->count) > 1);\n\tfuse_prepare_release(ff, flags, FUSE_RELEASE);\n\tff->reserved_req->force = 1;\n\tfuse_request_send(ff->fc, ff->reserved_req);\n\tfuse_put_request(ff->fc, ff->reserved_req);\n\tkfree(ff);\n}", "target": 0}
{"code": "yang_deviate_delete_unique(struct lys_module *module, struct lys_deviate *deviate,\n                           struct lys_node_list *list, int index, char * value)\n{\n    struct ly_ctx *ctx = module->ctx;\n    int i, j, k;\n    for (i = 0; i < list->unique_size; i++) {\n        if (list->unique[i].expr_size != deviate->unique[index].expr_size) {\n            continue;\n        }\n        for (j = 0; j < deviate->unique[index].expr_size; j++) {\n            if (!ly_strequal(list->unique[i].expr[j], deviate->unique[index].expr[j], 1)) {\n                break;\n            }\n        }\n        if (j == deviate->unique[index].expr_size) {\n            for (j = 0; j < list->unique[i].expr_size; j++) {\n                lydict_remove(ctx, list->unique[i].expr[j]);\n            }\n            free(list->unique[i].expr);\n            list->unique_size--;\n            if (i != list->unique_size) {\n                list->unique[i].expr_size = list->unique[list->unique_size].expr_size;\n                list->unique[i].expr = list->unique[list->unique_size].expr;\n            }\n            if (!list->unique_size) {\n                free(list->unique);\n                list->unique = NULL;\n            } else {\n                list->unique[list->unique_size].expr_size = 0;\n                list->unique[list->unique_size].expr = NULL;\n            }\n            k = i; \n            i = -1; \n            break;\n        }\n    }\n    if (i != -1) {\n        LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"unique\");\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Value differs from the target being deleted.\");\n        return EXIT_FAILURE;\n    }\n    j = -1;\n    while ((j = lys_ext_iter(list->ext, list->ext_size, j + 1, LYEXT_SUBSTMT_UNIQUE)) != -1) {\n        if (list->ext[j]->insubstmt_index == k) {\n            lyp_ext_instance_rm(ctx, &list->ext, &list->ext_size, j);\n            --j;\n        } else if (list->ext[j]->insubstmt_index > k) {\n            list->ext[j]->insubstmt_index--;\n        }\n    }\n    return EXIT_SUCCESS;\n}", "target": 0}
{"code": "comics_document_save (EvDocument *document,\n\t\t      const char *uri,\n\t\t      GError    **error)\n{\n\tComicsDocument *comics_document = COMICS_DOCUMENT (document);\n\treturn ev_xfer_uri_simple (comics_document->archive, uri, error);\n}", "target": 1}
{"code": "_asn1_cpy_name (asn1_node dst, asn1_node src)\n{\n  if (dst == NULL)\n    return dst;\n  if (src == NULL)\n    {\n      dst->name[0] = 0;\n      dst->name_hash = hash_pjw_bare (dst->name, 0);\n      return dst;\n    }\n  _asn1_str_cpy (dst->name, sizeof (dst->name), src->name);\n  dst->name_hash = src->name_hash;\n  return dst;\n}", "target": 0}
{"code": "static void update_blocked_averages(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct cfs_rq *cfs_rq, *pos;\n\tconst struct sched_class *curr_class;\n\tstruct rq_flags rf;\n\tbool done = true;\n\trq_lock_irqsave(rq, &rf);\n\tupdate_rq_clock(rq);\n\tfor_each_leaf_cfs_rq_safe(rq, cfs_rq, pos) {\n\t\tstruct sched_entity *se;\n\t\tif (throttled_hierarchy(cfs_rq))\n\t\t\tcontinue;\n\t\tif (update_cfs_rq_load_avg(cfs_rq_clock_task(cfs_rq), cfs_rq))\n\t\t\tupdate_tg_load_avg(cfs_rq, 0);\n\t\tse = cfs_rq->tg->se[cpu];\n\t\tif (se && !skip_blocked_update(se))\n\t\t\tupdate_load_avg(cfs_rq_of(se), se, 0);\n\t\tif (cfs_rq_is_decayed(cfs_rq))\n\t\t\tlist_del_leaf_cfs_rq(cfs_rq);\n\t\tif (cfs_rq_has_blocked(cfs_rq))\n\t\t\tdone = false;\n\t}\n\tcurr_class = rq->curr->sched_class;\n\tupdate_rt_rq_load_avg(rq_clock_task(rq), rq, curr_class == &rt_sched_class);\n\tupdate_dl_rq_load_avg(rq_clock_task(rq), rq, curr_class == &dl_sched_class);\n\tupdate_irq_load_avg(rq, 0);\n\tif (others_have_blocked(rq))\n\t\tdone = false;\n#ifdef CONFIG_NO_HZ_COMMON\n\trq->last_blocked_load_update_tick = jiffies;\n\tif (done)\n\t\trq->has_blocked_load = 0;\n#endif\n\trq_unlock_irqrestore(rq, &rf);\n}", "target": 1}
{"code": "cgiSetArray(const char *name,\t\t\n            int        element,\t\t\n            const char *value)\t\t\n{\n  int\t\ti;\t\t\t\n  _cgi_var_t\t*var;\t\t\t\n  if (name == NULL || value == NULL || element < 0 || element > 100000)\n    return;\n  fprintf(stderr, \"DEBUG: cgiSetArray: %s[%d]=\\\"%s\\\"\\n\", name, element, value);\n  if ((var = cgi_find_variable(name)) == NULL)\n  {\n    cgi_add_variable(name, element, value);\n    cgi_sort_variables();\n  }\n  else\n  {\n    if (element >= var->avalues)\n    {\n      const char **temp;\t\t\n      temp = (const char **)realloc((void *)(var->values),\n                                    sizeof(char *) * (size_t)(element + 16));\n      if (!temp)\n        return;\n      var->avalues = element + 16;\n      var->values  = temp;\n    }\n    if (element >= var->nvalues)\n    {\n      for (i = var->nvalues; i < element; i ++)\n\tvar->values[i] = NULL;\n      var->nvalues = element + 1;\n    }\n    else if (var->values[element])\n      _cupsStrFree((char *)var->values[element]);\n    var->values[element] = _cupsStrAlloc(value);\n  }\n}", "target": 0}
{"code": "static bool blk_kick_flush(struct request_queue *q, struct blk_flush_queue *fq)\n{\n\tstruct list_head *pending = &fq->flush_queue[fq->flush_pending_idx];\n\tstruct request *first_rq =\n\t\tlist_first_entry(pending, struct request, flush.list);\n\tstruct request *flush_rq = fq->flush_rq;\n\tif (fq->flush_pending_idx != fq->flush_running_idx || list_empty(pending))\n\t\treturn false;\n\tif (!list_empty(&fq->flush_data_in_flight) &&\n\t    time_before(jiffies,\n\t\t\tfq->flush_pending_since + FLUSH_PENDING_TIMEOUT))\n\t\treturn false;\n\tfq->flush_pending_idx ^= 1;\n\tblk_rq_init(q, flush_rq);\n\tif (q->mq_ops) {\n\t\tflush_rq->mq_ctx = first_rq->mq_ctx;\n\t\tflush_rq->tag = first_rq->tag;\n\t}\n\tflush_rq->cmd_type = REQ_TYPE_FS;\n\tflush_rq->cmd_flags = WRITE_FLUSH | REQ_FLUSH_SEQ;\n\tflush_rq->rq_disk = first_rq->rq_disk;\n\tflush_rq->end_io = flush_end_io;\n\treturn blk_flush_queue_rq(flush_rq, false);\n}", "target": 1}
{"code": "        std::string getExiv2ConfigPath()\n        {\n            std::string homedir;\n            std::string inifile;\n#if defined(_MSC_VER) || defined(__MINGW__)\n            char path[MAX_PATH];\n            if (SUCCEEDED(SHGetFolderPathA(nullptr, CSIDL_PROFILE, nullptr, 0, path))) {\n                homedir = std::string(path);\n                inifile = \"exiv2.ini\"      ;\n            }\n#else\n            struct passwd* pw = getpwuid(getuid());\n            homedir = std::string(pw?pw->pw_dir:\"\");\n            inifile = std::string(\".exiv2\");\n#endif\n            return homedir + EXV_SEPARATOR_CHR + inifile;\n        }", "target": 0}
{"code": "void tcp_resume_early_retransmit(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\ttcp_rearm_rto(sk);\n\tif (!tp->do_early_retrans)\n\t\treturn;\n\ttcp_enter_recovery(sk, false);\n\ttcp_update_scoreboard(sk, 1);\n\ttcp_xmit_retransmit_queue(sk);\n}", "target": 0}
{"code": "PinholeVerification(struct upnphttp * h, char * int_ip, unsigned short int_port)\n{\n\tint n;\n\tchar senderAddr[INET6_ADDRSTRLEN]=\"\";\n\tstruct addrinfo hints, *ai, *p;\n\tstruct in6_addr result_ip;\n\tsyslog(LOG_INFO, \"Checking internal IP@ and port (Security policy purpose)\");\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_family = AF_UNSPEC;\n\tif (inet_pton(AF_INET6, int_ip, &result_ip) <= 0)\n\t{\n\t\tn = getaddrinfo(int_ip, NULL, &hints, &ai);\n\t\tif(!n && ai->ai_family == AF_INET6)\n\t\t{\n\t\t\tfor(p = ai; p; p = p->ai_next)\n\t\t\t{\n\t\t\t\tinet_ntop(AF_INET6, (struct in6_addr *) p, int_ip, sizeof(struct in6_addr));\n\t\t\t\tresult_ip = *((struct in6_addr *) p);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsyslog(LOG_ERR, \"Failed to convert hostname '%s' to ip address\", int_ip);\n\t\t\tSoapError(h, 402, \"Invalid Args\");\n\t\t\treturn -1;\n\t\t}\n        freeaddrinfo(p);\n\t}\n\tif(inet_ntop(AF_INET6, &(h->clientaddr_v6), senderAddr, INET6_ADDRSTRLEN) == NULL)\n\t{\n\t\tsyslog(LOG_ERR, \"inet_ntop: %m\");\n\t}\n#ifdef DEBUG\n\tprintf(\"\\tPinholeVerification:\\n\\t\\tCompare sender @: %s\\n\\t\\t  to intClient @: %s\\n\", senderAddr, int_ip);\n#endif\n\tif(strcmp(senderAddr, int_ip) != 0)\n\tif(h->clientaddr_v6.s6_addr != result_ip.s6_addr)\n\t{\n\t\tsyslog(LOG_INFO, \"Client %s tried to access pinhole for internal %s and is not authorized to do it\",\n\t\t       senderAddr, int_ip);\n\t\tSoapError(h, 606, \"Action not authorized\");\n\t\treturn 0;\n\t}\n\tif (int_port < 1024)\n\t{\n\t\tsyslog(LOG_INFO, \"Client %s tried to access pinhole with port < 1024 and is not authorized to do it\",\n\t\t       senderAddr);\n\t\tSoapError(h, 606, \"Action not authorized\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "\t__releases(&keyring_serialise_link_sem)\n{\n\tBUG_ON(index_key->type == NULL);\n\tkenter(\"%d,%s,\", keyring->serial, index_key->type->name);\n\tif (index_key->type == &key_type_keyring)\n\t\tup_write(&keyring_serialise_link_sem);\n\tif (edit && !edit->dead_leaf) {\n\t\tkey_payload_reserve(keyring,\n\t\t\t\t    keyring->datalen - KEYQUOTA_LINK_BYTES);\n\t\tassoc_array_cancel_edit(edit);\n\t}\n\tup_write(&keyring->sem);\n}", "target": 1}
{"code": "static int find_low_bit(unsigned int x)\n{\n\tint i;\n\tfor(i=0;i<=31;i++) {\n\t\tif(x&(1<<i)) return i;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static void mctp_serial_uninit(struct net_device *ndev)\n{\n\tstruct mctp_serial *dev = netdev_priv(ndev);\n\tcancel_work_sync(&dev->tx_work);\n}", "target": 0}
{"code": "ppm_load_read_header(FILE       *fp,\n                     pnm_struct *img)\n{\n    gchar *ptr;\n    gchar  header[MAX_CHARS_IN_ROW];\n    gint   maxval;\n    int    channel_count;\n    if (fgets (header, MAX_CHARS_IN_ROW, fp) == NULL ||\n        header[0] != ASCII_P ||\n        (header[1] != PIXMAP_ASCII_GRAY &&\n         header[1] != PIXMAP_ASCII &&\n         header[1] != PIXMAP_RAW_GRAY &&\n         header[1] != PIXMAP_RAW))\n      {\n        g_warning (\"Image is not a portable pixmap\");\n        return FALSE;\n      }\n    img->type = header[1];\n    if (img->type == PIXMAP_RAW_GRAY || img->type == PIXMAP_ASCII_GRAY)\n      channel_count = CHANNEL_COUNT_GRAY;\n    else\n      channel_count = CHANNEL_COUNT;\n    while((fgets (header, MAX_CHARS_IN_ROW, fp)) && (header[0] == '#'))\n      ;\n    errno = 0;\n    img->width = strtol (header, &ptr, 10);\n    if (errno)\n      {\n        g_warning (\"Error reading width: %s\", strerror(errno));\n        return FALSE;\n      }\n    else if (img->width < 0)\n      {\n        g_warning (\"Error: width is negative\");\n        return FALSE;\n      }\n    img->height = strtol (ptr, &ptr, 10);\n    if (errno)\n      {\n        g_warning (\"Error reading height: %s\", strerror(errno));\n        return FALSE;\n      }\n    else if (img->width < 0)\n      {\n        g_warning (\"Error: height is negative\");\n        return FALSE;\n      }\n    if (fgets (header, MAX_CHARS_IN_ROW, fp))\n      maxval = strtol (header, &ptr, 10);\n    else\n      maxval = 0;\n    if ((maxval != 255) && (maxval != 65535))\n      {\n        g_warning (\"Image is not an 8-bit or 16-bit portable pixmap\");\n        return FALSE;\n      }\n  switch (maxval)\n    {\n    case 255:\n      img->bpc = sizeof (guchar);\n      break;\n    case 65535:\n      img->bpc = sizeof (gushort);\n      break;\n    default:\n      g_warning (\"%s: Programmer stupidity error\", G_STRLOC);\n    }\n    if (!img->width || !img->height ||\n        G_MAXSIZE / img->width / img->height / CHANNEL_COUNT < img->bpc)\n      {\n        g_warning (\"Illegal width/height: %ld/%ld\", img->width, img->height);\n        return FALSE;\n      }\n    img->channels = channel_count;\n    img->numsamples = img->width * img->height * channel_count;\n    return TRUE;\n}", "target": 1}
{"code": "static int fts3ContentColumns(\n  sqlite3 *db,                    \n  const char *zDb,                \n  const char *zTbl,               \n  const char ***pazCol,           \n  int *pnCol,                     \n  int *pnStr                      \n){\n  int rc = SQLITE_OK;             \n  char *zSql;                       \n  sqlite3_stmt *pStmt = 0;        \n  zSql = sqlite3_mprintf(\"SELECT * FROM %Q.%Q\", zDb, zTbl);\n  if( !zSql ){\n    rc = SQLITE_NOMEM;\n  }else{\n    rc = sqlite3_prepare(db, zSql, -1, &pStmt, 0);\n  }\n  sqlite3_free(zSql);\n  if( rc==SQLITE_OK ){\n    const char **azCol;           \n    int nStr = 0;                 \n    int nCol;                     \n    int i;                        \n    nCol = sqlite3_column_count(pStmt);\n    for(i=0; i<nCol; i++){\n      const char *zCol = sqlite3_column_name(pStmt, i);\n      nStr += (int)strlen(zCol) + 1;\n    }\n    azCol = (const char **)sqlite3_malloc(sizeof(char *) * nCol + nStr);\n    if( azCol==0 ){\n      rc = SQLITE_NOMEM;\n    }else{\n      char *p = (char *)&azCol[nCol];\n      for(i=0; i<nCol; i++){\n        const char *zCol = sqlite3_column_name(pStmt, i);\n        int n = (int)strlen(zCol)+1;\n        memcpy(p, zCol, n);\n        azCol[i] = p;\n        p += n;\n      }\n    }\n    sqlite3_finalize(pStmt);\n    *pnCol = nCol;\n    *pnStr = nStr;\n    *pazCol = azCol;\n  }\n  return rc;\n}", "target": 0}
{"code": "void mwifiex_set_vht_width(struct mwifiex_private *priv,\n\t\t\t   enum nl80211_chan_width width,\n\t\t\t   bool ap_11ac_enable)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct mwifiex_11ac_vht_cfg vht_cfg;\n\tvht_cfg.band_config = VHT_CFG_5GHZ;\n\tvht_cfg.cap_info = adapter->hw_dot_11ac_dev_cap;\n\tif (!ap_11ac_enable) {\n\t\tvht_cfg.mcs_tx_set = DISABLE_VHT_MCS_SET;\n\t\tvht_cfg.mcs_rx_set = DISABLE_VHT_MCS_SET;\n\t} else {\n\t\tvht_cfg.mcs_tx_set = DEFAULT_VHT_MCS_SET;\n\t\tvht_cfg.mcs_rx_set = DEFAULT_VHT_MCS_SET;\n\t}\n\tvht_cfg.misc_config  = VHT_CAP_UAP_ONLY;\n\tif (ap_11ac_enable && width >= NL80211_CHAN_WIDTH_80)\n\t\tvht_cfg.misc_config |= VHT_BW_80_160_80P80;\n\tmwifiex_send_cmd(priv, HostCmd_CMD_11AC_CFG,\n\t\t\t HostCmd_ACT_GEN_SET, 0, &vht_cfg, true);\n\treturn;\n}", "target": 0}
{"code": "void rsi_mac80211_detach(struct rsi_hw *adapter)\n{\n\tstruct ieee80211_hw *hw = adapter->hw;\n\tenum nl80211_band band;\n\tif (hw) {\n\t\tieee80211_stop_queues(hw);\n\t\tieee80211_unregister_hw(hw);\n\t\tieee80211_free_hw(hw);\n\t}\n\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\tstruct ieee80211_supported_band *sband =\n\t\t\t\t\t&adapter->sbands[band];\n\t\tkfree(sband->channels);\n\t}\n#ifdef CONFIG_RSI_DEBUGFS\n\trsi_remove_dbgfs(adapter);\n\tkfree(adapter->dfsentry);\n#endif\n}", "target": 1}
{"code": "SHA256_Init(struct SHA256_CTX * ctx)\n{\n  ctx->count[0] = ctx->count[1] = 0;\n  ctx->state[0] = 0x6A09E667;\n  ctx->state[1] = 0xBB67AE85;\n  ctx->state[2] = 0x3C6EF372;\n  ctx->state[3] = 0xA54FF53A;\n  ctx->state[4] = 0x510E527F;\n  ctx->state[5] = 0x9B05688C;\n  ctx->state[6] = 0x1F83D9AB;\n  ctx->state[7] = 0x5BE0CD19;\n}", "target": 1}
{"code": "__be32 ipv6_proxy_select_ident(struct net *net, struct sk_buff *skb)\n{\n\tstatic u32 ip6_proxy_idents_hashrnd __read_mostly;\n\tstruct in6_addr buf[2];\n\tstruct in6_addr *addrs;\n\tu32 id;\n\taddrs = skb_header_pointer(skb,\n\t\t\t\t   skb_network_offset(skb) +\n\t\t\t\t   offsetof(struct ipv6hdr, saddr),\n\t\t\t\t   sizeof(buf), buf);\n\tif (!addrs)\n\t\treturn 0;\n\tnet_get_random_once(&ip6_proxy_idents_hashrnd,\n\t\t\t    sizeof(ip6_proxy_idents_hashrnd));\n\tid = __ipv6_select_ident(net, ip6_proxy_idents_hashrnd,\n\t\t\t\t &addrs[1], &addrs[0]);\n\treturn htonl(id);\n}", "target": 1}
{"code": "findNextBorderPixel(l_int32    w,\n                    l_int32    h,\n                    l_uint32  *data,\n                    l_int32    wpl,\n                    l_int32    px,\n                    l_int32    py,\n                    l_int32   *pqpos,\n                    l_int32   *pnpx,\n                    l_int32   *pnpy)\n{\nl_int32    qpos, i, pos, npx, npy, val;\nl_uint32  *line;\n    qpos = *pqpos;\n    for (i = 1; i < 8; i++) {\n        pos = (qpos + i) % 8;\n        npx = px + xpostab[pos];\n        npy = py + ypostab[pos];\n        line = data + npy * wpl;\n        val = GET_DATA_BIT(line, npx);\n        if (val) {\n            *pnpx = npx;\n            *pnpy = npy;\n            *pqpos = qpostab[pos];\n            return 0;\n        }\n    }\n    return 1;\n}", "target": 1}
{"code": "find_entry2modify_only_ext(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n    int flags,\n    back_txn *txn\n)\n{\n\treturn( find_entry_internal( pb, be, addr, 1, txn, \n\t\t                         FE_REALLY_INTERNAL | flags ));\n}", "target": 1}
{"code": "static void ucvector_cleanup(void* p)\n{\n  ((ucvector*)p)->size = ((ucvector*)p)->allocsize = 0;\n  free(((ucvector*)p)->data);\n  ((ucvector*)p)->data = NULL;\n}", "target": 0}
{"code": "static int http_connect(http_subtransport *t)\n{\n\tint error;\n\tchar *proxy_url;\n\tif (t->connected &&\n\t\thttp_should_keep_alive(&t->parser) &&\n\t\tt->parse_finished)\n\t\treturn 0;\n\tif (t->io) {\n\t\tgit_stream_close(t->io);\n\t\tgit_stream_free(t->io);\n\t\tt->io = NULL;\n\t\tt->connected = 0;\n\t}\n\tif (t->connection_data.use_ssl) {\n\t\terror = git_tls_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n\t} else {\n#ifdef GIT_CURL\n\t\terror = git_curl_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n#else\n\t\terror = git_socket_stream_new(&t->io,  t->connection_data.host, t->connection_data.port);\n#endif\n\t}\n\tif (error < 0)\n\t\treturn error;\n\tGITERR_CHECK_VERSION(t->io, GIT_STREAM_VERSION, \"git_stream\");\n\tif (git_stream_supports_proxy(t->io) &&\n\t    !git_remote__get_http_proxy(t->owner->owner, !!t->connection_data.use_ssl, &proxy_url)) {\n\t\terror = git_stream_set_proxy(t->io, proxy_url);\n\t\tgit__free(proxy_url);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\terror = git_stream_connect(t->io);\n#if defined(GIT_OPENSSL) || defined(GIT_SECURE_TRANSPORT) || defined(GIT_CURL)\n\tif ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&\n\t    git_stream_is_encrypted(t->io)) {\n\t\tgit_cert *cert;\n\t\tint is_valid;\n\t\tif ((error = git_stream_certificate(&cert, t->io)) < 0)\n\t\t\treturn error;\n\t\tgiterr_clear();\n\t\tis_valid = error != GIT_ECERTIFICATE;\n\t\terror = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);\n\t\tif (error < 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set(GITERR_NET, \"user cancelled certificate check\");\n\t\t\treturn error;\n\t\t}\n\t}\n#endif\n\tif (error < 0)\n\t\treturn error;\n\tt->connected = 1;\n\treturn 0;\n}", "target": 1}
{"code": "date_s_rfc2822(int argc, VALUE *argv, VALUE klass)\n{\n    VALUE str, sg, opt;\n    rb_scan_args(argc, argv, \"02:\", &str, &sg, &opt);\n    switch (argc) {\n      case 0:\n\tstr = rb_str_new2(\"Mon, 1 Jan -4712 00:00:00 +0000\");\n      case 1:\n\tsg = INT2FIX(DEFAULT_SG);\n    }\n    {\n        int argc2 = 1;\n        VALUE argv2[2];\n        argv2[0] = str;\n        if (!NIL_P(opt)) argv2[argc2++] = opt;\n\tVALUE hash = date_s__rfc2822(argc2, argv2, klass);\n\treturn d_new_by_frags(klass, hash, sg);\n    }\n}", "target": 0}
{"code": "nf_nat_redirect_ipv4(struct sk_buff *skb,\n\t\t     const struct nf_nat_ipv4_multi_range_compat *mr,\n\t\t     unsigned int hooknum)\n{\n\tstruct nf_conn *ct;\n\tenum ip_conntrack_info ctinfo;\n\t__be32 newdst;\n\tstruct nf_nat_range newrange;\n\tNF_CT_ASSERT(hooknum == NF_INET_PRE_ROUTING ||\n\t\t     hooknum == NF_INET_LOCAL_OUT);\n\tct = nf_ct_get(skb, &ctinfo);\n\tNF_CT_ASSERT(ct && (ctinfo == IP_CT_NEW || ctinfo == IP_CT_RELATED));\n\tif (hooknum == NF_INET_LOCAL_OUT) {\n\t\tnewdst = htonl(0x7F000001);\n\t} else {\n\t\tstruct in_device *indev;\n\t\tstruct in_ifaddr *ifa;\n\t\tnewdst = 0;\n\t\trcu_read_lock();\n\t\tindev = __in_dev_get_rcu(skb->dev);\n\t\tif (indev != NULL) {\n\t\t\tifa = indev->ifa_list;\n\t\t\tnewdst = ifa->ifa_local;\n\t\t}\n\t\trcu_read_unlock();\n\t\tif (!newdst)\n\t\t\treturn NF_DROP;\n\t}\n\tmemset(&newrange.min_addr, 0, sizeof(newrange.min_addr));\n\tmemset(&newrange.max_addr, 0, sizeof(newrange.max_addr));\n\tnewrange.flags\t     = mr->range[0].flags | NF_NAT_RANGE_MAP_IPS;\n\tnewrange.min_addr.ip = newdst;\n\tnewrange.max_addr.ip = newdst;\n\tnewrange.min_proto   = mr->range[0].min;\n\tnewrange.max_proto   = mr->range[0].max;\n\treturn nf_nat_setup_info(ct, &newrange, NF_NAT_MANIP_DST);\n}", "target": 1}
{"code": "static int ion_handle_put(struct ion_handle *handle)\n{\n\tstruct ion_client *client = handle->client;\n\tint ret;\n\tmutex_lock(&client->lock);\n\tret = kref_put(&handle->ref, ion_handle_destroy);\n\tmutex_unlock(&client->lock);\n\treturn ret;\n}", "target": 1}
{"code": "nvkm_vmm_put_locked(struct nvkm_vmm *vmm, struct nvkm_vma *vma)\n{\n\tconst struct nvkm_vmm_page *page = vmm->func->page;\n\tstruct nvkm_vma *next = vma;\n\tBUG_ON(vma->part);\n\tif (vma->mapref || !vma->sparse) {\n\t\tdo {\n\t\t\tconst bool map = next->memory != NULL;\n\t\t\tconst u8  refd = next->refd;\n\t\t\tconst u64 addr = next->addr;\n\t\t\tu64 size = next->size;\n\t\t\twhile ((next = node(next, next)) && next->part &&\n\t\t\t       (next->memory != NULL) == map &&\n\t\t\t       (next->refd == refd))\n\t\t\t\tsize += next->size;\n\t\t\tif (map) {\n\t\t\t\tnvkm_vmm_ptes_unmap_put(vmm, &page[refd], addr,\n\t\t\t\t\t\t\tsize, vma->sparse);\n\t\t\t} else\n\t\t\tif (refd != NVKM_VMA_PAGE_NONE) {\n\t\t\t\tnvkm_vmm_ptes_put(vmm, &page[refd], addr, size);\n\t\t\t}\n\t\t} while (next && next->part);\n\t}\n\tnext = vma;\n\tdo {\n\t\tif (next->memory)\n\t\t\tnvkm_vmm_unmap_region(vmm, next);\n\t} while ((next = node(vma, next)) && next->part);\n\tif (vma->sparse && !vma->mapref) {\n\t\tnvkm_vmm_ptes_sparse_put(vmm, &page[vma->refd], vma->addr, vma->size);\n\t} else\n\tif (vma->sparse) {\n\t\tnvkm_vmm_ptes_sparse(vmm, vma->addr, vma->size, false);\n\t}\n\trb_erase(&vma->tree, &vmm->root);\n\tvma->page = NVKM_VMA_PAGE_NONE;\n\tvma->refd = NVKM_VMA_PAGE_NONE;\n\tvma->used = false;\n\tvma->user = false;\n\tnvkm_vmm_put_region(vmm, vma);\n}", "target": 1}
{"code": "static void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t      struct userfaultfd_wait_queue *ewq)\n{\n\tif (WARN_ON_ONCE(current->flags & PF_EXITING))\n\t\tgoto out;\n\tewq->ctx = ctx;\n\tinit_waitqueue_entry(&ewq->wq, current);\n\tspin_lock(&ctx->event_wqh.lock);\n\t__add_wait_queue(&ctx->event_wqh, &ewq->wq);\n\tfor (;;) {\n\t\tset_current_state(TASK_KILLABLE);\n\t\tif (ewq->msg.event == 0)\n\t\t\tbreak;\n\t\tif (READ_ONCE(ctx->released) ||\n\t\t    fatal_signal_pending(current)) {\n\t\t\t__remove_wait_queue(&ctx->event_wqh, &ewq->wq);\n\t\t\tif (ewq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tstruct userfaultfd_ctx *new;\n\t\t\t\tnew = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tewq->msg.arg.reserved.reserved1;\n\t\t\t\tuserfaultfd_ctx_put(new);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\t\twake_up_poll(&ctx->fd_wqh, POLLIN);\n\t\tschedule();\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->event_wqh.lock);\nout:\n\tuserfaultfd_ctx_put(ctx);\n}", "target": 1}
{"code": "                uint64_t readData(int size) const\n                {\n                    const DataBuf data = Image::io().read(size);\n                    enforce(data.size_ != 0, kerCorruptedMetadata);\n                    uint64_t result = 0;\n                    if (data.size_ == 1)\n                        {}\n                    else if (data.size_ == 2)\n                        result = byteSwap2(data, 0, doSwap_);\n                    else if (data.size_ == 4)\n                        result = byteSwap4(data, 0, doSwap_);\n                    else if (data.size_ == 8)\n                        result = byteSwap8(data, 0, doSwap_);\n                    else\n                        throw Exiv2::Error(kerCorruptedMetadata);\n                    return result;\n                }", "target": 0}
{"code": "BuildSendAndCloseSoapResp(struct upnphttp * h,\n                          const char * body, int bodylen)\n{\n\tstatic const char beforebody[] =\n\t\t\"<?xml version=\\\"1.0\\\"?>\\r\\n\"\n\t\t\"<s:Envelope xmlns:s=\\\"http:\n\t\t\"s:encodingStyle=\\\"http:\n\t\t\"<s:Body>\";\n\tstatic const char afterbody[] =\n\t\t\"</s:Body>\"\n\t\t\"</s:Envelope>\\r\\n\";\n\tint r = BuildHeader_upnphttp(h, 200, \"OK\",  sizeof(beforebody) - 1\n\t                             + sizeof(afterbody) - 1 + bodylen );\n\tif(r >= 0) {\n\t\tmemcpy(h->res_buf + h->res_buflen, beforebody, sizeof(beforebody) - 1);\n\t\th->res_buflen += sizeof(beforebody) - 1;\n\t\tmemcpy(h->res_buf + h->res_buflen, body, bodylen);\n\t\th->res_buflen += bodylen;\n\t\tmemcpy(h->res_buf + h->res_buflen, afterbody, sizeof(afterbody) - 1);\n\t\th->res_buflen += sizeof(afterbody) - 1;\n\t} else {\n\t\tBuildResp2_upnphttp(h, 500, \"Internal Server Error\", NULL, 0);\n\t}\n\tSendRespAndClose_upnphttp(h);\n}", "target": 0}
{"code": "    const std::unordered_map<std::string, std::string> &cookies() const override\n    {\n        return cookies_;\n    }", "target": 1}
{"code": "static ssize_t driver_override_show(struct device *_dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct amba_device *dev = to_amba_device(_dev);\n\treturn sprintf(buf, \"%s\\n\", dev->driver_override);\n}", "target": 1}
{"code": "static bool ok_jpg_read_dqt(ok_jpg_decoder *decoder) {\n    ok_jpg *jpg = decoder->jpg;\n    uint8_t buffer[2];\n    if (!ok_read(decoder, buffer, sizeof(buffer))) {\n        return false;\n    }\n    int length = readBE16(buffer) - 2;\n    while (length >= 65) {\n        uint8_t pt = ok_read_uint8(decoder);\n        int Pq = pt >> 4;\n        int Tq = pt & 0x0f;\n        if (Pq == 1) {\n            ok_jpg_error(jpg, OK_JPG_ERROR_UNSUPPORTED, \"Unsupported JPEG (16-bit q_table)\");\n            return false;\n        }\n        if (Pq != 0 || Tq > 3) {\n            ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, \"Invalid JPEG (Pq/Tq)\");\n            return false;\n        }\n        if (!ok_read(decoder, decoder->q_table[Tq], 64)) {\n            return false;\n        }\n        length -= 65;\n    }\n    if (length != 0) {\n        ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, \"Invalid DQT segment length\");\n        return false;\n    } else {\n        return true;\n    }\n}", "target": 0}
{"code": "void TestSocketLineReader::initTestCase()\n{\n    m_server = new Server(this);\n    QVERIFY2(m_server->listen(QHostAddress::LocalHost, 8694), \"Failed to create local tcp server\");\n    m_timer.setInterval(4000);\n    m_timer.setSingleShot(true);\n    connect(&m_timer, &QTimer::timeout, &m_loop, &QEventLoop::quit);\n    m_conn = new QSslSocket(this);\n    m_conn->connectToHost(QHostAddress::LocalHost, 8694);\n    connect(m_conn, &QAbstractSocket::connected, &m_loop, &QEventLoop::quit);\n    m_timer.start();\n    m_loop.exec();\n    QVERIFY2(m_conn->isOpen(), \"Could not connect to local tcp server\");\n}", "target": 1}
{"code": "static int dump_seek(struct file *file, loff_t off)\n{\n\tif (file->f_op->llseek) {\n\t\tif (file->f_op->llseek(file, off, SEEK_SET) != off)\n\t\t\treturn 0;\n\t} else {\n\t\tfile->f_pos = off;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "  virtual void ConnectToWifiNetwork(const WifiNetwork* network,\n                                    const std::string& password,\n                                    const std::string& identity,\n                                    const std::string& certpath) {}", "target": 0}
{"code": "  Declaration_Obj Parser::parse_declaration() {\n    String_Obj prop;\n    bool is_custom_property = false;\n    if (lex< sequence< optional< exactly<'*'> >, identifier_schema > >()) {\n      const std::string property(lexed);\n      is_custom_property = property.compare(0, 2, \"--\") == 0;\n      prop = parse_identifier_schema();\n    }\n    else if (lex< sequence< optional< exactly<'*'> >, identifier, zero_plus< block_comment > > >()) {\n      const std::string property(lexed);\n      is_custom_property = property.compare(0, 2, \"--\") == 0;\n      prop = SASS_MEMORY_NEW(String_Constant, pstate, lexed);\n    }\n    else {\n      css_error(\"Invalid CSS\", \" after \", \": expected \\\"}\\\", was \");\n    }\n    bool is_indented = true;\n    const std::string property(lexed);\n    if (!lex_css< one_plus< exactly<':'> > >()) error(\"property \\\"\" + escape_string(property)  + \"\\\" must be followed by a ':'\");\n    if (!is_custom_property && match< sequence< optional_css_comments, exactly<';'> > >()) error(\"style declaration must contain a value\");\n    if (match< sequence< optional_css_comments, exactly<'{'> > >()) is_indented = false; \n    if (is_custom_property) {\n      return SASS_MEMORY_NEW(Declaration, prop->pstate(), prop, parse_css_variable_value(), false, true);\n    }\n    lex < css_comments >(false);\n    if (peek_css< static_value >()) {\n      return SASS_MEMORY_NEW(Declaration, prop->pstate(), prop, parse_static_value());\n    }\n    else {\n      Expression_Obj value;\n      Lookahead lookahead = lookahead_for_value(position);\n      if (lookahead.found) {\n        if (lookahead.has_interpolants) {\n          value = parse_value_schema(lookahead.found);\n        } else {\n          value = parse_list(DELAYED);\n        }\n      }\n      else {\n        value = parse_list(DELAYED);\n        if (List* list = Cast<List>(value)) {\n          if (!list->is_bracketed() && list->length() == 0 && !peek< exactly <'{'> >()) {\n            css_error(\"Invalid CSS\", \" after \", \": expected expression (e.g. 1px, bold), was \");\n          }\n        }\n      }\n      lex < css_comments >(false);\n      Declaration_Obj decl = SASS_MEMORY_NEW(Declaration, prop->pstate(), prop, value);\n      decl->is_indented(is_indented);\n      decl->update_pstate(pstate);\n      return decl;\n    }\n  }", "target": 0}
{"code": "struct bio *bio_map_kern(struct request_queue *q, void *data, unsigned int len,\n\t\t\t gfp_t gfp_mask)\n{\n\tunsigned long kaddr = (unsigned long)data;\n\tunsigned long end = (kaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tunsigned long start = kaddr >> PAGE_SHIFT;\n\tconst int nr_pages = end - start;\n\tint offset, i;\n\tstruct bio *bio;\n\tbio = bio_kmalloc(gfp_mask, nr_pages);\n\tif (!bio)\n\t\treturn ERR_PTR(-ENOMEM);\n\toffset = offset_in_page(kaddr);\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tunsigned int bytes = PAGE_SIZE - offset;\n\t\tif (len <= 0)\n\t\t\tbreak;\n\t\tif (bytes > len)\n\t\t\tbytes = len;\n\t\tif (bio_add_pc_page(q, bio, virt_to_page(data), bytes,\n\t\t\t\t    offset) < bytes) {\n\t\t\tbio_put(bio);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tdata += bytes;\n\t\tlen -= bytes;\n\t\toffset = 0;\n\t}\n\tbio->bi_end_io = bio_map_kern_endio;\n\treturn bio;\n}", "target": 0}
{"code": "static inline struct htx_blk *htx_add_trailer(struct htx *htx, const struct ist name,\n\t\t\t\t\t      const struct ist value)\n{\n\tstruct htx_blk *blk;\n\tblk = htx_add_blk(htx, HTX_BLK_TLR, name.len + value.len);\n\tif (!blk)\n\t\treturn NULL;\n\tblk->info += (value.len << 8) + name.len;\n\tist2bin_lc(htx_get_blk_ptr(htx, blk), name);\n\tmemcpy(htx_get_blk_ptr(htx, blk)  + name.len, value.ptr, value.len);\n\treturn blk;\n}", "target": 1}
{"code": "static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof TSRMLS_DC)\n{\n\tchar *ksep, *vsep, *val;\n\tsize_t klen, vlen;\n\tunsigned int new_vlen;\n\tif (var->ptr >= var->end) {\n\t\treturn 0;\n\t}\n\tvsep = memchr(var->ptr, '&', var->end - var->ptr);\n\tif (!vsep) {\n\t\tif (!eof) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tvsep = var->end;\n\t\t}\n\t}\n\tksep = memchr(var->ptr, '=', vsep - var->ptr);\n\tif (ksep) {\n\t\t*ksep = '\\0';\n\t\tklen = ksep - var->ptr;\n\t\tvlen = vsep - ++ksep;\n\t} else {\n\t\tksep = \"\";\n\t\tklen = vsep - var->ptr;\n\t\tvlen = 0;\n\t}\n\tphp_url_decode(var->ptr, klen);\n\tval = estrndup(ksep, vlen);\n\tif (vlen) {\n\t\tvlen = php_url_decode(val, vlen);\n\t}\n\tif (sapi_module.input_filter(PARSE_POST, var->ptr, &val, vlen, &new_vlen TSRMLS_CC)) {\n\t\tphp_register_variable_safe(var->ptr, val, new_vlen, arr TSRMLS_CC);\n\t}\n\tefree(val);\n\tvar->ptr = vsep + (vsep != var->end);\n\treturn 1;\n}", "target": 1}
{"code": "static void cma_set_rep_event_data(struct rdma_cm_event *event,\n\t\t\t\t   const struct ib_cm_rep_event_param *rep_data,\n\t\t\t\t   void *private_data)\n{\n\tevent->param.conn.private_data = private_data;\n\tevent->param.conn.private_data_len = IB_CM_REP_PRIVATE_DATA_SIZE;\n\tevent->param.conn.responder_resources = rep_data->responder_resources;\n\tevent->param.conn.initiator_depth = rep_data->initiator_depth;\n\tevent->param.conn.flow_control = rep_data->flow_control;\n\tevent->param.conn.rnr_retry_count = rep_data->rnr_retry_count;\n\tevent->param.conn.srq = rep_data->srq;\n\tevent->param.conn.qp_num = rep_data->remote_qpn;\n\tevent->ece.vendor_id = rep_data->ece.vendor_id;\n\tevent->ece.attr_mod = rep_data->ece.attr_mod;\n}", "target": 0}
{"code": "void SecurityManager::resend_handshake_message_token(\n        const GUID_t& remote_participant_key) const\n{\n    auto sentry = is_security_manager_initialized();\n    if (!sentry)\n    {\n        return;\n    }\n    shared_lock<shared_mutex> _(mutex_);\n    auto dp_it = discovered_participants_.find(remote_participant_key);\n    if (dp_it != discovered_participants_.end())\n    {\n        SecurityManager::DiscoveredParticipantInfo::AuthUniquePtr remote_participant_info = dp_it->second->get_auth();\n        if (remote_participant_info)\n        {\n            if (remote_participant_info->change_sequence_number_ != SequenceNumber_t::unknown())\n            {\n                CacheChange_t* p_change = participant_stateless_message_writer_history_->remove_change_and_reuse(\n                    remote_participant_info->change_sequence_number_);\n                remote_participant_info->change_sequence_number_ = SequenceNumber_t::unknown();\n                if (p_change != nullptr)\n                {\n                    EPROSIMA_LOG_INFO(SECURITY, \"Authentication handshake resent to participant \" <<\n                            remote_participant_key);\n                    if (participant_stateless_message_writer_history_->add_change(p_change))\n                    {\n                        remote_participant_info->change_sequence_number_ = p_change->sequenceNumber;\n                    }\n                }\n            }\n            dp_it->second->set_auth(remote_participant_info);\n        }\n    }\n}", "target": 1}
{"code": "int kill_pid_info_as_uid(int sig, struct siginfo *info, struct pid *pid,\n\t\t      uid_t uid, uid_t euid, u32 secid)\n{\n\tint ret = -EINVAL;\n\tstruct task_struct *p;\n\tconst struct cred *pcred;\n\tif (!valid_signal(sig))\n\t\treturn ret;\n\tread_lock(&tasklist_lock);\n\tp = pid_task(pid, PIDTYPE_PID);\n\tif (!p) {\n\t\tret = -ESRCH;\n\t\tgoto out_unlock;\n\t}\n\tpcred = __task_cred(p);\n\tif ((info == SEND_SIG_NOINFO ||\n\t     (!is_si_special(info) && SI_FROMUSER(info))) &&\n\t    euid != pcred->suid && euid != pcred->uid &&\n\t    uid  != pcred->suid && uid  != pcred->uid) {\n\t\tret = -EPERM;\n\t\tgoto out_unlock;\n\t}\n\tret = security_task_kill(p, info, sig, secid);\n\tif (ret)\n\t\tgoto out_unlock;\n\tif (sig && p->sighand) {\n\t\tunsigned long flags;\n\t\tspin_lock_irqsave(&p->sighand->siglock, flags);\n\t\tret = __send_signal(sig, info, p, 1, 0);\n\t\tspin_unlock_irqrestore(&p->sighand->siglock, flags);\n\t}\nout_unlock:\n\tread_unlock(&tasklist_lock);\n\treturn ret;\n}", "target": 0}
{"code": "void dwc3_gadget_giveback(struct dwc3_ep *dep, struct dwc3_request *req,\n\t\tint status)\n{\n\tstruct dwc3\t\t\t*dwc = dep->dwc;\n\treq->started = false;\n\tlist_del(&req->list);\n\treq->remaining = 0;\n\tif (req->request.status == -EINPROGRESS)\n\t\treq->request.status = status;\n\tif (req->trb)\n\t\tusb_gadget_unmap_request_by_dev(dwc->sysdev,\n\t\t\t\t\t\t&req->request, req->direction);\n\treq->trb = NULL;\n\ttrace_dwc3_gadget_giveback(req);\n\tspin_unlock(&dwc->lock);\n\tusb_gadget_giveback_request(&dep->endpoint, &req->request);\n\tspin_lock(&dwc->lock);\n\tif (dep->number > 1)\n\t\tpm_runtime_put(dwc->dev);\n}", "target": 1}
{"code": "static struct rt6_info *rt6_multipath_select(struct rt6_info *match,\n\t\t\t\t\t     struct flowi6 *fl6)\n{\n\tstruct rt6_info *sibling, *next_sibling;\n\tint route_choosen;\n\troute_choosen = rt6_info_hash_nhsfn(match->rt6i_nsiblings + 1, fl6);\n\tif (route_choosen)\n\t\tlist_for_each_entry_safe(sibling, next_sibling,\n\t\t\t\t&match->rt6i_siblings, rt6i_siblings) {\n\t\t\troute_choosen--;\n\t\t\tif (route_choosen == 0) {\n\t\t\t\tmatch = sibling;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\treturn match;\n}", "target": 0}
{"code": "void uwbd_start(struct uwb_rc *rc)\n{\n\trc->uwbd.task = kthread_run(uwbd, rc, \"uwbd\");\n\tif (rc->uwbd.task == NULL)\n\t\tprintk(KERN_ERR \"UWB: Cannot start management daemon; \"\n\t\t       \"UWB won't work\\n\");\n\telse\n\t\trc->uwbd.pid = rc->uwbd.task->pid;\n}", "target": 1}
{"code": "read_data_stored(struct archive_read *a, const void **buff, size_t *size,\n                 int64_t *offset)\n{\n  struct rar *rar;\n  ssize_t bytes_avail;\n  rar = (struct rar *)(a->format->data);\n  if (rar->bytes_remaining == 0 &&\n    !(rar->main_flags & MHD_VOLUME && rar->file_flags & FHD_SPLIT_AFTER))\n  {\n    *buff = NULL;\n    *size = 0;\n    *offset = rar->offset;\n    if (rar->file_crc != rar->crc_calculated) {\n      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                        \"File CRC error\");\n      return (ARCHIVE_FATAL);\n    }\n    rar->entry_eof = 1;\n    return (ARCHIVE_EOF);\n  }\n  *buff = rar_read_ahead(a, 1, &bytes_avail);\n  if (bytes_avail <= 0)\n  {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Truncated RAR file data\");\n    return (ARCHIVE_FATAL);\n  }\n  *size = bytes_avail;\n  *offset = rar->offset;\n  rar->offset += bytes_avail;\n  rar->offset_seek += bytes_avail;\n  rar->bytes_remaining -= bytes_avail;\n  rar->bytes_unconsumed = bytes_avail;\n  rar->crc_calculated = crc32(rar->crc_calculated, *buff,\n    (unsigned)bytes_avail);\n  return (ARCHIVE_OK);\n}", "target": 0}
{"code": "sg_rq_end_io_usercontext(struct work_struct *work)\n{\n\tstruct sg_request *srp = container_of(work, struct sg_request, ew.work);\n\tstruct sg_fd *sfp = srp->parentfp;\n\tsg_finish_rem_req(srp);\n\tsg_remove_request(sfp, srp);\n\tkref_put(&sfp->f_ref, sg_remove_sfp);\n}", "target": 0}
{"code": "atol8(const char *p, size_t char_cnt)\n{\n\tint64_t l;\n\tint digit;\n\tl = 0;\n\twhile (char_cnt-- > 0) {\n\t\tif (*p >= '0' && *p <= '7')\n\t\t\tdigit = *p - '0';\n\t\telse\n\t\t\tbreak;\n\t\tp++;\n\t\tl <<= 3;\n\t\tl |= digit;\n\t}\n\treturn (l);\n}", "target": 1}
{"code": "static void dtls1_set_handshake_header(SSL *s, int htype, unsigned long len)\n{\n    unsigned char *p = (unsigned char *)s->init_buf->data;\n    dtls1_set_message_header(s, p, htype, len, 0, len);\n    s->init_num = (int)len + DTLS1_HM_HEADER_LENGTH;\n    s->init_off = 0;\n    dtls1_buffer_message(s, 0);\n}", "target": 0}
{"code": "static std::string GetBaseFilename(const std::string &filepath) {\n  auto idx = filepath.find_last_of(\"/\\\\\");\n  if (idx != std::string::npos)\n    return filepath.substr(idx + 1);\n  return filepath;\n}", "target": 1}
{"code": "PHPAPI int php_lint_script(zend_file_handle *file)\n{\n\tzend_op_array *op_array;\n\tint retval = FAILURE;\n\tzend_try {\n\t\top_array = zend_compile_file(file, ZEND_INCLUDE);\n\t\tzend_destroy_file_handle(file);\n\t\tif (op_array) {\n\t\t\tdestroy_op_array(op_array);\n\t\t\tefree(op_array);\n\t\t\tretval = SUCCESS;\n\t\t}\n\t} zend_end_try();\n\tif (EG(exception)) {\n\t\tzend_exception_error(EG(exception), E_ERROR);\n\t}\n\treturn retval;\n}", "target": 0}
{"code": "static int fts3EvalPhraseStart(Fts3Cursor *pCsr, int bOptOk, Fts3Phrase *p){\n  Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;\n  int rc = SQLITE_OK;             \n  int i;\n  int bHaveIncr = 0;\n  int bIncrOk = (bOptOk \n   && pCsr->bDesc==pTab->bDescIdx \n   && p->nToken<=MAX_INCR_PHRASE_TOKENS && p->nToken>0\n   && p->nToken<=MAX_INCR_PHRASE_TOKENS && p->nToken>0\n#ifdef SQLITE_TEST\n   && pTab->bNoIncrDoclist==0\n#endif\n  );\n  for(i=0; bIncrOk==1 && i<p->nToken; i++){\n    Fts3PhraseToken *pToken = &p->aToken[i];\n    if( pToken->bFirst || (pToken->pSegcsr!=0 && !pToken->pSegcsr->bLookup) ){\n      bIncrOk = 0;\n    }\n    if( pToken->pSegcsr ) bHaveIncr = 1;\n  }\n  if( bIncrOk && bHaveIncr ){\n    int iCol = (p->iColumn >= pTab->nColumn ? -1 : p->iColumn);\n    for(i=0; rc==SQLITE_OK && i<p->nToken; i++){\n      Fts3PhraseToken *pToken = &p->aToken[i];\n      Fts3MultiSegReader *pSegcsr = pToken->pSegcsr;\n      if( pSegcsr ){\n        rc = sqlite3Fts3MsrIncrStart(pTab, pSegcsr, iCol, pToken->z, pToken->n);\n      }\n    }\n    p->bIncr = 1;\n  }else{\n    rc = fts3EvalPhraseLoad(pCsr, p);\n    p->bIncr = 0;\n  }\n  assert( rc!=SQLITE_OK || p->nToken<1 || p->aToken[0].pSegcsr==0 || p->bIncr );\n  return rc;\n}", "target": 0}
{"code": "snmp_ber_decode_oid(snmp_packet_t *snmp_packet, snmp_oid_t *oid)\n{\n  uint8_t *buf_end, type;\n  uint8_t len, j;\n  div_t first;\n  if(!snmp_ber_decode_type(snmp_packet, &type)) {\n    return 0;\n  }\n  if(type != BER_DATA_TYPE_OBJECT_IDENTIFIER) {\n    return 0;\n  }\n  if(!snmp_ber_decode_length(snmp_packet, &len)) {\n    return 0;\n  }\n  buf_end = snmp_packet->in + len;\n  if(snmp_packet->used == 0) {\n    return 0;\n  }\n  snmp_packet->used--;\n  first = div(*snmp_packet->in++, 40);\n  oid->length = 0;\n  oid->data[oid->length++] = (uint32_t)first.quot;\n  oid->data[oid->length++] = (uint32_t)first.rem;\n  while(snmp_packet->in != buf_end) {\n    if(oid->length >= SNMP_MSG_OID_MAX_LEN) {\n      return 0;\n    }\n    if(snmp_packet->used == 0) {\n      return 0;\n    }\n    oid->data[oid->length] = (uint32_t)(*snmp_packet->in & 0x7F);\n    for(j = 0; j < 4; j++) {\n      snmp_packet->used--;\n      if((*snmp_packet->in++ & 0x80) == 0) {\n        break;\n      }\n      if(snmp_packet->used == 0) {\n        return 0;\n      }\n      oid->data[oid->length] <<= 7;\n      oid->data[oid->length] |= (*snmp_packet->in & 0x7F);\n    }\n    oid->length++;\n  }\n  return 1;\n}", "target": 0}
{"code": "uint64_t HeaderMapImpl::byteSize() const {\n  uint64_t byte_size = 0;\n  for (const HeaderEntryImpl& header : headers_) {\n    byte_size += header.key().size();\n    byte_size += header.value().size();\n  }\n  return byte_size;\n}", "target": 1}
{"code": "ByteVector ByteVector::mid(uint index, uint length) const\n{\n  ByteVector v;\n  if(index > size())\n    return v;\n  ConstIterator endIt;\n  if(length < 0xffffffff && length + index < size())\n    endIt = d->data.begin() + index + length;\n  else\n    endIt = d->data.end();\n  v.d->data.insert(v.d->data.begin(), ConstIterator(d->data.begin() + index), endIt);\n  v.d->size = v.d->data.size();\n  return v;\n}", "target": 1}
{"code": "sg_release(struct inode *inode, struct file *filp)\n{\n\tSg_device *sdp;\n\tSg_fd *sfp;\n\tif ((!(sfp = (Sg_fd *) filp->private_data)) || (!(sdp = sfp->parentdp)))\n\t\treturn -ENXIO;\n\tSCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sdp, \"sg_release\\n\"));\n\tmutex_lock(&sdp->open_rel_lock);\n\tscsi_autopm_put_device(sdp->device);\n\tkref_put(&sfp->f_ref, sg_remove_sfp);\n\tsdp->open_cnt--;\n\tif (sdp->exclude) {\n\t\tsdp->exclude = false;\n\t\twake_up_interruptible_all(&sdp->open_wait);\n\t} else if (0 == sdp->open_cnt) {\n\t\twake_up_interruptible(&sdp->open_wait);\n\t}\n\tmutex_unlock(&sdp->open_rel_lock);\n\treturn 0;\n}", "target": 0}
{"code": "pci_emul_add_msicap(struct pci_vdev *dev, int msgnum)\n{\n\tstruct msicap msicap;\n\tpci_populate_msicap(&msicap, msgnum, 0);\n\treturn pci_emul_add_capability(dev, (u_char *)&msicap, sizeof(msicap));\n}", "target": 1}
{"code": "static int mem_resize(jas_stream_memobj_t *m, int bufsize)\n{\n\tunsigned char *buf;\n\tassert(m->buf_);\n\tassert(bufsize >= 0);\n\tif (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char)))) {\n\t\treturn -1;\n\t}\n\tm->buf_ = buf;\n\tm->bufsize_ = bufsize;\n\treturn 0;\n}", "target": 1}
{"code": "static void adjust_branches(struct bpf_prog *prog, int pos, int delta)\n{\n\tstruct bpf_insn *insn = prog->insnsi;\n\tint insn_cnt = prog->len;\n\tint i;\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (BPF_CLASS(insn->code) != BPF_JMP ||\n\t\t    BPF_OP(insn->code) == BPF_CALL ||\n\t\t    BPF_OP(insn->code) == BPF_EXIT)\n\t\t\tcontinue;\n\t\tif (i < pos && i + insn->off + 1 > pos)\n\t\t\tinsn->off += delta;\n\t\telse if (i > pos && i + insn->off + 1 < pos)\n\t\t\tinsn->off -= delta;\n\t}\n}", "target": 1}
{"code": "mes_lookup (struct message *meslist, int max, int index)\n{\n  if ((index >= 0) && (index < max) && (meslist[index].key == index))\n    return meslist[index].str;\n  {\n    int i;\n    for (i = 0; i < max; i++, meslist++)\n      {\n\tif (meslist->key == index)\n\t  {\n\t    zlog_warn(\"message index %d [%s] found in position %d (max is %d)\",\n\t\t      index, meslist->str, i, max);\n\t    return meslist->str;\n\t  }\n      }\n  }\n  zlog_err(\"message index %d not found (max is %d)\", index, max);\n  return NULL;\n}", "target": 1}
{"code": "static int pf_detect(void)\n{\n\tstruct pf_unit *pf = units;\n\tint k, unit;\n\tprintk(\"%s: %s version %s, major %d, cluster %d, nice %d\\n\",\n\t       name, name, PF_VERSION, major, cluster, nice);\n\tpar_drv = pi_register_driver(name);\n\tif (!par_drv) {\n\t\tpr_err(\"failed to register %s driver\\n\", name);\n\t\treturn -1;\n\t}\n\tk = 0;\n\tif (pf_drive_count == 0) {\n\t\tif (pi_init(pf->pi, 1, -1, -1, -1, -1, -1, pf_scratch, PI_PF,\n\t\t\t    verbose, pf->name)) {\n\t\t\tif (!pf_probe(pf) && pf->disk) {\n\t\t\t\tpf->present = 1;\n\t\t\t\tk++;\n\t\t\t} else\n\t\t\t\tpi_release(pf->pi);\n\t\t}\n\t} else\n\t\tfor (unit = 0; unit < PF_UNITS; unit++, pf++) {\n\t\t\tint *conf = *drives[unit];\n\t\t\tif (!conf[D_PRT])\n\t\t\t\tcontinue;\n\t\t\tif (pi_init(pf->pi, 0, conf[D_PRT], conf[D_MOD],\n\t\t\t\t    conf[D_UNI], conf[D_PRO], conf[D_DLY],\n\t\t\t\t    pf_scratch, PI_PF, verbose, pf->name)) {\n\t\t\t\tif (pf->disk && !pf_probe(pf)) {\n\t\t\t\t\tpf->present = 1;\n\t\t\t\t\tk++;\n\t\t\t\t} else\n\t\t\t\t\tpi_release(pf->pi);\n\t\t\t}\n\t\t}\n\tif (k)\n\t\treturn 0;\n\tprintk(\"%s: No ATAPI disk detected\\n\", name);\n\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n\t\tif (!pf->disk)\n\t\t\tcontinue;\n\t\tblk_cleanup_queue(pf->disk->queue);\n\t\tpf->disk->queue = NULL;\n\t\tblk_mq_free_tag_set(&pf->tag_set);\n\t\tput_disk(pf->disk);\n\t}\n\tpi_unregister_driver(par_drv);\n\treturn -1;\n}", "target": 0}
{"code": "static bool read_phdr(ELFOBJ *bin, bool linux_kernel_hack) {\n\tbool phdr_found = false;\n\tint i;\n#if R_BIN_ELF64\n\tconst bool is_elf64 = true;\n#else\n\tconst bool is_elf64 = false;\n#endif\n\tut64 phnum = Elf_(r_bin_elf_get_phnum) (bin);\n\tfor (i = 0; i < phnum; i++) {\n\t\tut8 phdr[sizeof (Elf_(Phdr))] = {0};\n\t\tint j = 0;\n\t\tconst size_t rsize = bin->ehdr.e_phoff + i * sizeof (Elf_(Phdr));\n\t\tint len = r_buf_read_at (bin->b, rsize, phdr, sizeof (Elf_(Phdr)));\n\t\tif (len < 1) {\n\t\t\tR_LOG_ERROR (\"read (phdr)\");\n\t\t\tR_FREE (bin->phdr);\n\t\t\treturn false;\n\t\t}\n\t\tbin->phdr[i].p_type = READ32 (phdr, j);\n\t\tif (bin->phdr[i].p_type == PT_PHDR) {\n\t\t\tphdr_found = true;\n\t\t}\n\t\tif (is_elf64) {\n\t\t\tbin->phdr[i].p_flags = READ32 (phdr, j);\n\t\t}\n\t\tbin->phdr[i].p_offset = R_BIN_ELF_READWORD (phdr, j);\n\t\tbin->phdr[i].p_vaddr = R_BIN_ELF_READWORD (phdr, j);\n\t\tbin->phdr[i].p_paddr = R_BIN_ELF_READWORD (phdr, j);\n\t\tbin->phdr[i].p_filesz = R_BIN_ELF_READWORD (phdr, j);\n\t\tbin->phdr[i].p_memsz = R_BIN_ELF_READWORD (phdr, j);\n\t\tif (!is_elf64) {\n\t\t\tbin->phdr[i].p_flags = READ32 (phdr, j);\n\t\t}\n\t\tbin->phdr[i].p_align = R_BIN_ELF_READWORD (phdr, j);\n\t}\n\tif (linux_kernel_hack && phdr_found) {\n\t\tut64 load_addr = Elf_(r_bin_elf_get_baddr) (bin);\n\t\tbin->ehdr.e_phoff = Elf_(r_bin_elf_v2p) (bin, load_addr + bin->ehdr.e_phoff);\n\t\treturn read_phdr (bin, false);\n\t}\n\treturn true;\n}", "target": 1}
{"code": "static void numtostr(js_State *J, const char *fmt, int w, double n)\n{\n\tchar buf[32], *e;\n\tsprintf(buf, fmt, w, n);\n\te = strchr(buf, 'e');\n\tif (e) {\n\t\tint exp = atoi(e+1);\n\t\tsprintf(e, \"e%+d\", exp);\n\t}\n\tjs_pushstring(J, buf);\n}", "target": 1}
{"code": "static inline int build_open_flags(int flags, umode_t mode, struct open_flags *op)\n{\n\tint lookup_flags = 0;\n\tint acc_mode;\n\tif (flags & O_CREAT)\n\t\top->mode = (mode & S_IALLUGO) | S_IFREG;\n\telse\n\t\top->mode = 0;\n\tflags &= ~FMODE_NONOTIFY & ~O_CLOEXEC;\n\tif (flags & __O_SYNC)\n\t\tflags |= O_DSYNC;\n\tif (flags & __O_TMPFILE) {\n\t\tif ((flags & O_TMPFILE_MASK) != O_TMPFILE)\n\t\t\treturn -EINVAL;\n\t\tacc_mode = MAY_OPEN | ACC_MODE(flags);\n\t} else if (flags & O_PATH) {\n\t\tflags &= O_DIRECTORY | O_NOFOLLOW | O_PATH;\n\t\tacc_mode = 0;\n\t} else {\n\t\tacc_mode = MAY_OPEN | ACC_MODE(flags);\n\t}\n\top->open_flag = flags;\n\tif (flags & O_TRUNC)\n\t\tacc_mode |= MAY_WRITE;\n\tif (flags & O_APPEND)\n\t\tacc_mode |= MAY_APPEND;\n\top->acc_mode = acc_mode;\n\top->intent = flags & O_PATH ? 0 : LOOKUP_OPEN;\n\tif (flags & O_CREAT) {\n\t\top->intent |= LOOKUP_CREATE;\n\t\tif (flags & O_EXCL)\n\t\t\top->intent |= LOOKUP_EXCL;\n\t}\n\tif (flags & O_DIRECTORY)\n\t\tlookup_flags |= LOOKUP_DIRECTORY;\n\tif (!(flags & O_NOFOLLOW))\n\t\tlookup_flags |= LOOKUP_FOLLOW;\n\top->lookup_flags = lookup_flags;\n\treturn 0;\n}", "target": 0}
{"code": "int sock_initaddress(const char *host, const char *port,\n    struct addrinfo *hints, struct addrinfo **addrinfo, char *errbuf, int errbuflen)\n{\n\tint retval;\n\tretval = getaddrinfo(host, port == NULL ? \"0\" : port, hints, addrinfo);\n\tif (retval != 0)\n\t{\n\t\tif (errbuf)\n\t\t{\n\t\t\tif (host != NULL && port != NULL) {\n\t\t\t\tint try_retval;\n\t\t\t\ttry_retval = getaddrinfo(host, NULL, hints,\n\t\t\t\t    addrinfo);\n\t\t\t\tif (try_retval == 0) {\n\t\t\t\t\tfreeaddrinfo(*addrinfo);\n\t\t\t\t\tget_gai_errstring(errbuf, errbuflen,\n\t\t\t\t\t    \"\", retval, NULL, port);\n\t\t\t\t} else {\n\t\t\t\t\tget_gai_errstring(errbuf, errbuflen,\n\t\t\t\t\t    \"\", retval, host, NULL);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tget_gai_errstring(errbuf, errbuflen, \"\",\n\t\t\t\t    retval, host, port);\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tif (((*addrinfo)->ai_family != PF_INET) &&\n\t    ((*addrinfo)->ai_family != PF_INET6))\n\t{\n\t\tif (errbuf)\n\t\t\tsnprintf(errbuf, errbuflen, \"getaddrinfo(): socket type not supported\");\n\t\tfreeaddrinfo(*addrinfo);\n\t\t*addrinfo = NULL;\n\t\treturn -1;\n\t}\n\tif (((*addrinfo)->ai_socktype == SOCK_STREAM) &&\n\t    (sock_ismcastaddr((*addrinfo)->ai_addr) == 0))\n\t{\n\t\tif (errbuf)\n\t\t\tsnprintf(errbuf, errbuflen, \"getaddrinfo(): multicast addresses are not valid when using TCP streams\");\n\t\tfreeaddrinfo(*addrinfo);\n\t\t*addrinfo = NULL;\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "flatpak_context_set_persistent (FlatpakContext *context,\n                                const char     *path)\n{\n  g_hash_table_insert (context->persistent, g_strdup (path), GINT_TO_POINTER (1));\n}", "target": 1}
{"code": "cib_remote_auth(xmlNode *login)\n{\n    const char *user = NULL;\n    const char *pass = NULL;\n    const char *tmp = NULL;\n    crm_log_xml_info(login, \"Login: \");\n    if (login == NULL) {\n        return FALSE;\n    }\n    tmp = crm_element_name(login);\n    if (safe_str_neq(tmp, \"cib_command\")) {\n        crm_err(\"Wrong tag: %s\", tmp);\n        return FALSE;\n    }\n    tmp = crm_element_value(login, \"op\");\n    if (safe_str_neq(tmp, \"authenticate\")) {\n        crm_err(\"Wrong operation: %s\", tmp);\n        return FALSE;\n    }\n    user = crm_element_value(login, \"user\");\n    pass = crm_element_value(login, \"password\");\n    if (!user || !pass) {\n        crm_err(\"missing auth credentials\");\n        return FALSE;\n    }\n    if (check_group_membership(user, CRM_DAEMON_GROUP) == FALSE) {\n        crm_err(\"User is not a member of the required group\");\n        return FALSE;\n    } else if (authenticate_user(user, pass) == FALSE) {\n        crm_err(\"PAM auth failed\");\n        return FALSE;\n    }\n    return TRUE;\n}", "target": 0}
{"code": "_dbus_printf_string_upper_bound (const char *format,\n                                 va_list     args)\n{\n  char static_buf[1024];\n  int bufsize = sizeof (static_buf);\n  int len;\n  len = vsnprintf (static_buf, bufsize, format, args);\n  if (len == bufsize)\n    {\n      if (vsnprintf (static_buf, 1, format, args) == 1)\n        len = -1;\n    }\n  while (len < 0)\n    {\n      char *buf;\n      bufsize *= 2;\n      buf = dbus_malloc (bufsize);\n      if (buf == NULL)\n        return -1;\n      len = vsnprintf (buf, bufsize, format, args);\n      dbus_free (buf);\n      if (len == bufsize)\n        len = -1;\n    }\n  return len;\n}", "target": 1}
{"code": "static void prefetch_enc(void)\n{\n  prefetch_table((const void *)encT, sizeof(encT));\n}", "target": 1}
{"code": "void luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v) {\n  global_State *g = G(L);\n  lua_assert(isblack(o) && iswhite(v) && !isdead(g, v) && !isdead(g, o));\n  if (keepinvariant(g)) {  \n    reallymarkobject(g, v);  \n    if (isold(o)) {\n      lua_assert(!isold(v));  \n      setage(v, G_OLD0);  \n    }\n  }\n  else {  \n    lua_assert(issweepphase(g));\n    makewhite(g, o);  \n  }\n}", "target": 1}
{"code": "pushvar(struct SWF_ACTIONPUSHPARAM *val)\n{\n\tstruct _stack *t;\n#ifdef DEBUG\n\tprintf(\"*pushvar*\\n\");\n#endif\n\tt = calloc(1,sizeof(*Stack));\n\tt->type = 'v'; \n\tt->val = val;\n\tt->next = Stack;\n\tStack = t;\n}", "target": 0}
{"code": "METHODDEF(JDIMENSION)\nget_32bit_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  bmp_source_ptr source = (bmp_source_ptr)sinfo;\n  JSAMPARRAY image_ptr;\n  register JSAMPROW inptr, outptr;\n  register JDIMENSION col;\n  if (source->use_inversion_array) {\n    source->source_row--;\n    image_ptr = (*cinfo->mem->access_virt_sarray)\n      ((j_common_ptr)cinfo, source->whole_image,\n       source->source_row, (JDIMENSION)1, FALSE);\n    inptr = image_ptr[0];\n  } else {\n    if (!ReadOK(source->pub.input_file, source->iobuffer, source->row_width))\n      ERREXIT(cinfo, JERR_INPUT_EOF);\n    inptr = source->iobuffer;\n  }\n  outptr = source->pub.buffer[0];\n  if (cinfo->in_color_space == JCS_EXT_BGRX ||\n      cinfo->in_color_space == JCS_EXT_BGRA) {\n    MEMCOPY(outptr, inptr, source->row_width);\n  } else if (cinfo->in_color_space == JCS_CMYK) {\n    for (col = cinfo->image_width; col > 0; col--) {\n      JSAMPLE b = *inptr++, g = *inptr++, r = *inptr++;\n      rgb_to_cmyk(r, g, b, outptr, outptr + 1, outptr + 2, outptr + 3);\n      inptr++;                          \n      outptr += 4;\n    }\n  } else {\n    register int rindex = rgb_red[cinfo->in_color_space];\n    register int gindex = rgb_green[cinfo->in_color_space];\n    register int bindex = rgb_blue[cinfo->in_color_space];\n    register int aindex = alpha_index[cinfo->in_color_space];\n    register int ps = rgb_pixelsize[cinfo->in_color_space];\n    if (aindex >= 0) {\n      for (col = cinfo->image_width; col > 0; col--) {\n        outptr[bindex] = *inptr++;      \n        outptr[gindex] = *inptr++;\n        outptr[rindex] = *inptr++;\n        outptr[aindex] = *inptr++;\n        outptr += ps;\n      }\n    } else {\n      for (col = cinfo->image_width; col > 0; col--) {\n        outptr[bindex] = *inptr++;      \n        outptr[gindex] = *inptr++;\n        outptr[rindex] = *inptr++;\n        inptr++;                        \n        outptr += ps;\n      }\n    }\n  }\n  return 1;\n}", "target": 0}
{"code": "int check_directory(struct dir *dir)\n{\n\tint i;\n\tstruct dir_ent *ent;\n\tif(dir->dir_count < 2)\n\t\treturn TRUE;\n\tfor(ent = dir->dirs, i = 0; i < dir->dir_count - 1; ent = ent->next, i++)\n\t\tif(strcmp(ent->name, ent->next->name) >= 0)\n\t\t\treturn FALSE;\n\treturn TRUE;\n}", "target": 0}
{"code": "static bool get_sequence_numbers(struct torture_context *torture,\n\t\t\t\t struct torture_domain_sequence **seqs)\n{\n\tstruct winbindd_request req;\n\tstruct winbindd_response rep;\n\tconst char *extra_data;\n\tchar line[256];\n\tuint32_t count = 0;\n\tstruct torture_domain_sequence *s = NULL;\n\tZERO_STRUCT(req);\n\tZERO_STRUCT(rep);\n\tDO_STRUCT_REQ_REP(WINBINDD_SHOW_SEQUENCE, &req, &rep);\n\textra_data = (char *)rep.extra_data.data;\n\ttorture_assert(torture, extra_data, \"NULL sequence list\");\n\twhile (next_token(&extra_data, line, \"\\n\", sizeof(line))) {\n\t\tchar *p, *lp;\n\t\tuint32_t seq;\n\t\ts = talloc_realloc(torture, s, struct torture_domain_sequence,\n\t\t\t\t   count + 2);\n\t\tZERO_STRUCT(s[count+1]);\n\t\tlp = line;\n\t\tp = strchr(lp, ' ');\n\t\ttorture_assert(torture, p, \"invalid line format\");\n\t\t*p = 0;\n\t\ts[count].netbios_name = talloc_strdup(s, lp);\n\t\tlp = p+1;\n\t\ttorture_assert(torture, strncmp(lp, \": \", 2) == 0,\n\t\t\t       \"invalid line format\");\n\t\tlp += 2;\n\t\tif (strcmp(lp, \"DISCONNECTED\") == 0) {\n\t\t\tseq = (uint32_t)-1;\n\t\t} else {\n\t\t\tseq = (uint32_t)strtol(lp, &p, 10);\n\t\t\ttorture_assert(torture, (*p == '\\0'),\n\t\t\t\t       \"invalid line format\");\n\t\t\ttorture_assert(torture, (seq != (uint32_t)-1),\n\t\t\t\t       \"sequence number -1 encountered\");\n\t\t}\n\t\ts[count].seq = seq;\n\t\tcount++;\n\t}\n\tSAFE_FREE(rep.extra_data.data);\n\ttorture_assert(torture, count >= 2, \"The list of domain sequence \"\n\t\t       \"numbers should contain 2 entries\");\n\t*seqs = s;\n\treturn true;\n}", "target": 0}
{"code": "static int rose_getname(struct socket *sock, struct sockaddr *uaddr,\n\tint *uaddr_len, int peer)\n{\n\tstruct full_sockaddr_rose *srose = (struct full_sockaddr_rose *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tint n;\n\tif (peer != 0) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\t\tsrose->srose_family = AF_ROSE;\n\t\tsrose->srose_addr   = rose->dest_addr;\n\t\tsrose->srose_call   = rose->dest_call;\n\t\tsrose->srose_ndigis = rose->dest_ndigis;\n\t\tfor (n = 0; n < rose->dest_ndigis; n++)\n\t\t\tsrose->srose_digis[n] = rose->dest_digis[n];\n\t} else {\n\t\tsrose->srose_family = AF_ROSE;\n\t\tsrose->srose_addr   = rose->source_addr;\n\t\tsrose->srose_call   = rose->source_call;\n\t\tsrose->srose_ndigis = rose->source_ndigis;\n\t\tfor (n = 0; n < rose->source_ndigis; n++)\n\t\t\tsrose->srose_digis[n] = rose->source_digis[n];\n\t}\n\t*uaddr_len = sizeof(struct full_sockaddr_rose);\n\treturn 0;\n}", "target": 1}
{"code": "PgUser *force_user(PgDatabase *db, const char *name, const char *passwd)\n{\n\tPgUser *user = db->forced_user;\n\tif (!user) {\n\t\tuser = slab_alloc(user_cache);\n\t\tif (!user)\n\t\t\treturn NULL;\n\t\tlist_init(&user->head);\n\t\tlist_init(&user->pool_list);\n\t}\n\tsafe_strcpy(user->name, name, sizeof(user->name));\n\tsafe_strcpy(user->passwd, passwd, sizeof(user->passwd));\n\tdb->forced_user = user;\n\treturn user;\n}", "target": 0}
{"code": "rfbBool ConnectToRFBRepeater(rfbClient* client,const char *repeaterHost, int repeaterPort, const char *destHost, int destPort)\n{\n  rfbProtocolVersionMsg pv;\n  int major,minor;\n  char tmphost[250];\n  int tmphostlen;\n#ifdef LIBVNCSERVER_IPv6\n  client->sock = ConnectClientToTcpAddr6(repeaterHost, repeaterPort);\n  if (client->sock == -1)\n#endif\n  {\n    unsigned int host;\n    if (!StringToIPAddr(repeaterHost, &host)) {\n      rfbClientLog(\"Couldn't convert '%s' to host address\\n\", repeaterHost);\n      return FALSE;\n    }\n    client->sock = ConnectClientToTcpAddr(host, repeaterPort);\n  }\n  if (client->sock < 0) {\n    rfbClientLog(\"Unable to connect to VNC repeater\\n\");\n    return FALSE;\n  }\n  if (!SetNonBlocking(client->sock))\n    return FALSE;\n  if (!ReadFromRFBServer(client, pv, sz_rfbProtocolVersionMsg))\n    return FALSE;\n  pv[sz_rfbProtocolVersionMsg] = 0;\n  if (sscanf(pv,rfbProtocolVersionFormat,&major,&minor) != 2 || major != 0 || minor != 0) {\n    rfbClientLog(\"Not a valid VNC repeater (%s)\\n\",pv);\n    return FALSE;\n  }\n  rfbClientLog(\"Connected to VNC repeater, using protocol version %d.%d\\n\", major, minor);\n  tmphostlen = snprintf(tmphost, sizeof(tmphost), \"%s:%d\", destHost, destPort);\n  if(tmphostlen < 0 || tmphostlen >= (int)sizeof(tmphost))\n    return FALSE; \n  if (!WriteToRFBServer(client, tmphost, tmphostlen + 1))\n    return FALSE;\n  return TRUE;\n}", "target": 0}
{"code": "static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof)\n{\n\tchar *ksep, *vsep, *val;\n\tsize_t klen, vlen;\n\tsize_t new_vlen;\n\tif (var->ptr >= var->end) {\n\t\treturn 0;\n\t}\n\tvsep = memchr(var->ptr, '&', var->end - var->ptr);\n\tif (!vsep) {\n\t\tif (!eof) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tvsep = var->end;\n\t\t}\n\t}\n\tksep = memchr(var->ptr, '=', vsep - var->ptr);\n\tif (ksep) {\n\t\t*ksep = '\\0';\n\t\tklen = ksep - var->ptr;\n\t\tvlen = vsep - ++ksep;\n\t} else {\n\t\tksep = \"\";\n\t\tklen = vsep - var->ptr;\n\t\tvlen = 0;\n\t}\n\tphp_url_decode(var->ptr, klen);\n\tval = estrndup(ksep, vlen);\n\tif (vlen) {\n\t\tvlen = php_url_decode(val, vlen);\n\t}\n\tif (sapi_module.input_filter(PARSE_POST, var->ptr, &val, vlen, &new_vlen)) {\n\t\tphp_register_variable_safe(var->ptr, val, new_vlen, arr);\n\t}\n\tefree(val);\n\tvar->ptr = vsep + (vsep != var->end);\n\treturn 1;\n}", "target": 1}
{"code": "fribidi_cap_rtl_to_unicode (\n  const char *s,\n  FriBidiStrIndex len,\n  FriBidiChar *us\n)\n{\n  FriBidiStrIndex i, j;\n  if (!caprtl_to_unicode)\n    init_cap_rtl ();\n  j = 0;\n  for (i = 0; i < len; i++)\n    {\n      char ch;\n      ch = s[i];\n      if (ch == '_')\n\t{\n\t  switch (ch = s[++i])\n\t    {\n\t    case '>':\n\t      us[j++] = FRIBIDI_CHAR_LRM;\n\t      break;\n\t    case '<':\n\t      us[j++] = FRIBIDI_CHAR_RLM;\n\t      break;\n\t    case 'l':\n\t      us[j++] = FRIBIDI_CHAR_LRE;\n\t      break;\n\t    case 'r':\n\t      us[j++] = FRIBIDI_CHAR_RLE;\n\t      break;\n\t    case 'o':\n\t      us[j++] = FRIBIDI_CHAR_PDF;\n\t      break;\n\t    case 'L':\n\t      us[j++] = FRIBIDI_CHAR_LRO;\n\t      break;\n\t    case 'R':\n\t      us[j++] = FRIBIDI_CHAR_RLO;\n\t      break;\n            case 'i':\n              us[j++] = FRIBIDI_CHAR_LRI;\n\t      break;\n            case 'y':\n              us[j++] = FRIBIDI_CHAR_RLI;\n\t      break;\n            case 'f':\n              us[j++] = FRIBIDI_CHAR_FSI;\n\t      break;\n            case 'I':\n              us[j++] = FRIBIDI_CHAR_PDI;\n\t      break;\n\t    case '_':\n\t      us[j++] = '_';\n\t      break;\n\t    default:\n\t      us[j++] = '_';\n\t      i--;\n\t      break;\n\t    }\n\t}\n      else\n\tus[j++] = caprtl_to_unicode[(int) s[i]];\n    }\n  return j;\n}", "target": 1}
{"code": "static int ext4_dax_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\treturn dax_mkwrite(vma, vmf, ext4_get_block_dax,\n\t\t\t\text4_end_io_unwritten);\n}", "target": 1}
{"code": "int infra_ip_ratelimit_inc(struct infra_cache* infra,\n\tstruct sockaddr_storage* addr, socklen_t addrlen, time_t timenow,\n\tint has_cookie, int backoff, struct sldns_buffer* buffer)\n{\n\tint max;\n\tstruct lruhash_entry* entry;\n\tif(!infra_ip_ratelimit) {\n\t\treturn 1;\n\t}\n\tentry = infra_find_ip_ratedata(infra, addr, addrlen, 1);\n\tif(entry) {\n\t\tint premax = infra_rate_max(entry->data, timenow, backoff);\n\t\tint* cur = infra_rate_give_second(entry->data, timenow);\n\t\t(*cur)++;\n\t\tmax = infra_rate_max(entry->data, timenow, backoff);\n\t\tlock_rw_unlock(&entry->lock);\n\t\treturn check_ip_ratelimit(addr, addrlen, buffer, premax, max,\n\t\t\thas_cookie);\n\t}\n\tinfra_ip_create_ratedata(infra, addr, addrlen, timenow);\n\treturn 1;\n}", "target": 1}
{"code": "s64 ntfs_attr_pread(ntfs_attr *na, const s64 pos, s64 count, void *b)\n{\n\ts64 ret;\n\tif (!na || !na->ni || !na->ni->vol || !b || pos < 0 || count < 0) {\n\t\terrno = EINVAL;\n\t\tntfs_log_perror(\"%s: na=%p  b=%p  pos=%lld  count=%lld\",\n\t\t\t\t__FUNCTION__, na, b, (long long)pos,\n\t\t\t\t(long long)count);\n\t\treturn -1;\n\t}\n\tntfs_log_enter(\"Entering for inode %lld attr 0x%x pos %lld count \"\n\t\t       \"%lld\\n\", (unsigned long long)na->ni->mft_no,\n\t\t       le32_to_cpu(na->type), (long long)pos, (long long)count);\n\tret = ntfs_attr_pread_i(na, pos, count, b);\n\tntfs_log_leave(\"\\n\");\n\treturn ret;\n}", "target": 0}
{"code": "static void cil_reset_classpermission(struct cil_classpermission *cp)\n{\n\tif (cp == NULL) {\n\t\treturn;\n\t}\n\tcil_reset_classperms_list(cp->classperms);\n}", "target": 1}
{"code": "void luaD_shrinkstack (lua_State *L) {\n  int inuse = stackinuse(L);\n  int goodsize = inuse + (inuse / 8) + 2*EXTRA_STACK;\n  if (goodsize > LUAI_MAXSTACK)\n    goodsize = LUAI_MAXSTACK;  \n  if (inuse <= (LUAI_MAXSTACK - EXTRA_STACK) &&\n      goodsize < L->stacksize)\n    luaD_reallocstack(L, goodsize, 0);  \n  else  \n    condmovestack(L,{},{});  \n  luaE_shrinkCI(L);  \n}", "target": 1}
{"code": "static ssize_t TIFFReadCustomStream(unsigned char *data,const size_t count,\n  void *user_data)\n{\n  PhotoshopProfile\n    *profile;\n  size_t\n    total;\n  ssize_t\n    remaining;\n  if (count == 0)\n    return(0);\n  profile=(PhotoshopProfile *) user_data;\n  remaining=(MagickOffsetType) profile->length-profile->offset;\n  if (remaining <= 0)\n    return(-1);\n  total=MagickMin(count, (size_t) remaining);\n  (void) memcpy(data,profile->data->datum+profile->offset,total);\n  profile->offset+=total;\n  return(total);\n}", "target": 0}
{"code": "    GopherStateData(FwdState *aFwd) :\n        entry(aFwd->entry),\n        conversion(NORMAL),\n        HTML_header_added(0),\n        HTML_pre(0),\n        type_id(GOPHER_FILE ),\n        overflowed(false),\n        cso_recno(0),\n        len(0),\n        buf(nullptr),\n        fwd(aFwd)\n    {\n        *request = 0;\n        buf = (char *)memAllocate(MEM_4K_BUF);\n        entry->lock(\"gopherState\");\n        *replybuf = 0;\n    }", "target": 1}
{"code": "static void ncq_err(NCQTransferState *ncq_tfs)\n{\n    IDEState *ide_state = &ncq_tfs->drive->port.ifs[0];\n     ide_state->error = ABRT_ERR;\n     ide_state->status = READY_STAT | ERR_STAT;\n     ncq_tfs->drive->port_regs.scr_err |= (1 << ncq_tfs->tag);\n    ncq_tfs->used = 0;\n }", "target": 0}
{"code": "static int dnxhd_init_vlc(DNXHDContext *ctx, uint32_t cid, int bitdepth)\n{\n    if (cid != ctx->cid) {\n        const CIDEntry *cid_table = ff_dnxhd_get_cid_table(cid);\n        if (!cid_table) {\n            av_log(ctx->avctx, AV_LOG_ERROR, \"unsupported cid %\"PRIu32\"\\n\", cid);\n            return AVERROR(ENOSYS);\n        }\n        if (cid_table->bit_depth != bitdepth &&\n            cid_table->bit_depth != DNXHD_VARIABLE) {\n            av_log(ctx->avctx, AV_LOG_ERROR, \"bit depth mismatches %d %d\\n\",\n                   cid_table->bit_depth, bitdepth);\n            return AVERROR_INVALIDDATA;\n        }\n        ctx->cid_table = cid_table;\n        av_log(ctx->avctx, AV_LOG_VERBOSE, \"Profile cid %\"PRIu32\".\\n\", cid);\n        ff_free_vlc(&ctx->ac_vlc);\n        ff_free_vlc(&ctx->dc_vlc);\n        ff_free_vlc(&ctx->run_vlc);\n        init_vlc(&ctx->ac_vlc, DNXHD_VLC_BITS, 257,\n                 ctx->cid_table->ac_bits, 1, 1,\n                 ctx->cid_table->ac_codes, 2, 2, 0);\n        init_vlc(&ctx->dc_vlc, DNXHD_DC_VLC_BITS, bitdepth > 8 ? 14 : 12,\n                 ctx->cid_table->dc_bits, 1, 1,\n                 ctx->cid_table->dc_codes, 1, 1, 0);\n        init_vlc(&ctx->run_vlc, DNXHD_VLC_BITS, 62,\n                 ctx->cid_table->run_bits, 1, 1,\n                 ctx->cid_table->run_codes, 2, 2, 0);\n        ctx->cid = cid;\n    }\n    return 0;\n}", "target": 1}
{"code": "static PyObject *checkPassword(PyObject *self, PyObject *args)\n{\n    const char *user = NULL;\n    const char *pswd = NULL;\n    const char *service = NULL;\n    const char *default_realm = NULL;\n    int result = 0;\n    if (!PyArg_ParseTuple(args, \"ssss\", &user, &pswd, &service, &default_realm))\n        return NULL;\n    result = authenticate_user_krb5pwd(user, pswd, service, default_realm);\n    if (result)\n        return Py_INCREF(Py_True), Py_True;\n    else\n        return NULL;\n}", "target": 1}
{"code": "bool f2fs_init_extent_tree(struct inode *inode, struct f2fs_extent *i_ext)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct extent_tree *et;\n\tstruct extent_node *en;\n\tstruct extent_info ei;\n\tif (!f2fs_may_extent_tree(inode)) {\n\t\tif (i_ext && i_ext->len) {\n\t\t\ti_ext->len = 0;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tet = __grab_extent_tree(inode);\n\tif (!i_ext || !i_ext->len)\n\t\treturn false;\n\tget_extent_info(&ei, i_ext);\n\twrite_lock(&et->lock);\n\tif (atomic_read(&et->node_cnt))\n\t\tgoto out;\n\ten = __init_extent_tree(sbi, et, &ei);\n\tif (en) {\n\t\tspin_lock(&sbi->extent_lock);\n\t\tlist_add_tail(&en->list, &sbi->extent_list);\n\t\tspin_unlock(&sbi->extent_lock);\n\t}\nout:\n\twrite_unlock(&et->lock);\n\treturn false;\n}", "target": 1}
{"code": "static inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)\n{\n\treturn F2FS_M_SB(page->mapping);\n}", "target": 1}
{"code": "ppp_create_interface(struct net *net, int unit, int *retp)\n{\n\tstruct ppp *ppp;\n\tstruct ppp_net *pn;\n\tstruct net_device *dev = NULL;\n\tint ret = -ENOMEM;\n\tint i;\n\tdev = alloc_netdev(sizeof(struct ppp), \"\", ppp_setup);\n\tif (!dev)\n\t\tgoto out1;\n\tpn = ppp_pernet(net);\n\tppp = netdev_priv(dev);\n\tppp->dev = dev;\n\tppp->mru = PPP_MRU;\n\tinit_ppp_file(&ppp->file, INTERFACE);\n\tppp->file.hdrlen = PPP_HDRLEN - 2;\t\n\tfor (i = 0; i < NUM_NP; ++i)\n\t\tppp->npmode[i] = NPMODE_PASS;\n\tINIT_LIST_HEAD(&ppp->channels);\n\tspin_lock_init(&ppp->rlock);\n\tspin_lock_init(&ppp->wlock);\n#ifdef CONFIG_PPP_MULTILINK\n\tppp->minseq = -1;\n\tskb_queue_head_init(&ppp->mrq);\n#endif \n\tdev_net_set(dev, net);\n\tret = -EEXIST;\n\tmutex_lock(&pn->all_ppp_mutex);\n\tif (unit < 0) {\n\t\tunit = unit_get(&pn->units_idr, ppp);\n\t\tif (unit < 0) {\n\t\t\t*retp = unit;\n\t\t\tgoto out2;\n\t\t}\n\t} else {\n\t\tif (unit_find(&pn->units_idr, unit))\n\t\t\tgoto out2; \n\t\tunit = unit_set(&pn->units_idr, ppp, unit);\n\t\tif (unit < 0)\n\t\t\tgoto out2;\n\t}\n\tppp->file.index = unit;\n\tsprintf(dev->name, \"ppp%d\", unit);\n\tret = register_netdev(dev);\n\tif (ret != 0) {\n\t\tunit_put(&pn->units_idr, unit);\n\t\tprintk(KERN_ERR \"PPP: couldn't register device %s (%d)\\n\",\n\t\t       dev->name, ret);\n\t\tgoto out2;\n\t}\n\tppp->ppp_net = net;\n\tatomic_inc(&ppp_unit_count);\n\tmutex_unlock(&pn->all_ppp_mutex);\n\t*retp = 0;\n\treturn ppp;\nout2:\n\tmutex_unlock(&pn->all_ppp_mutex);\n\tfree_netdev(dev);\nout1:\n\t*retp = ret;\n\treturn NULL;\n}", "target": 0}
{"code": "static void *__alloc_from_pool(size_t size, struct page **ret_page, gfp_t flags)\n{\n\tunsigned long val;\n\tvoid *ptr = NULL;\n\tif (!atomic_pool) {\n\t\tWARN(1, \"coherent pool not initialised!\\n\");\n\t\treturn NULL;\n\t}\n\tval = gen_pool_alloc(atomic_pool, size);\n\tif (val) {\n\t\tphys_addr_t phys = gen_pool_virt_to_phys(atomic_pool, val);\n\t\t*ret_page = phys_to_page(phys);\n\t\tptr = (void *)val;\n\t\tif (flags & __GFP_ZERO)\n\t\t\tmemset(ptr, 0, size);\n\t}\n\treturn ptr;\n}", "target": 1}
{"code": "unsigned char *cipso_v4_optptr(const struct sk_buff *skb)\n{\n\tconst struct iphdr *iph = ip_hdr(skb);\n\tunsigned char *optptr = (unsigned char *)&(ip_hdr(skb)[1]);\n\tint optlen;\n\tint taglen;\n\tfor (optlen = iph->ihl*4 - sizeof(struct iphdr); optlen > 0; ) {\n\t\tif (optptr[0] == IPOPT_CIPSO)\n\t\t\treturn optptr;\n\t\ttaglen = optptr[1];\n\t\toptlen -= taglen;\n\t\toptptr += taglen;\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "Status TensorSliceReader::GetTensor(\n    const string& name, std::unique_ptr<tensorflow::Tensor>* out_tensor) const {\n  DataType type;\n  TensorShape shape;\n  TensorSlice slice;\n  {\n    mutex_lock l(mu_);\n    const TensorSliceSet* tss = gtl::FindPtrOrNull(tensors_, name);\n    if (tss == nullptr) {\n      return errors::NotFound(name, \" not found in checkpoint file\");\n    }\n    if (tss->Slices().size() > 1) {\n      return errors::Unimplemented(\"Sliced checkpoints are not supported\");\n    }\n    type = tss->type();\n    shape = tss->shape();\n    slice = tss->Slices().begin()->second.slice;\n  }\n  std::unique_ptr<tensorflow::Tensor> t(new tensorflow::Tensor(type, shape));\n  bool success = false;\n#define READER_COPY(dt)                                                  \\\n  case dt:                                                               \\\n    success = CopySliceData(name, slice,                                 \\\n                            t->flat<EnumToDataType<dt>::Type>().data()); \\\n    break;\n  switch (type) {\n    READER_COPY(DT_FLOAT);\n    READER_COPY(DT_DOUBLE);\n    READER_COPY(DT_INT32);\n    READER_COPY(DT_UINT8);\n    READER_COPY(DT_INT16);\n    READER_COPY(DT_INT8);\n    READER_COPY(DT_INT64);\n    READER_COPY(DT_STRING);\n    default:\n      return errors::Unimplemented(\"Data type not supported\");\n  }\n#undef READER_COPY\n  if (!success) {\n    return errors::NotFound(name, \" not found in checkpoint file\");\n  }\n  std::swap(*out_tensor, t);\n  return Status::OK();\n}", "target": 1}
{"code": "M_bool M_fs_path_ishidden(const char *path, M_fs_info_t *info)\n{\n\tM_list_str_t *path_parts;\n\tsize_t        len;\n\tM_bool        ret        = M_FALSE;\n\t(void)info;\n\tif (path == NULL || *path == '\\0') {\n\t\treturn M_FALSE;\n\t}\n\tpath_parts = M_fs_path_componentize_path(path, M_FS_SYSTEM_UNIX);\n\tlen = M_list_str_len(path_parts);\n\tif (len > 0) {\n\t\tif (*M_list_str_at(path_parts, len-1) == '.') {\n\t\t\tret = M_TRUE;\n\t\t}\n\t}\n\tM_list_str_destroy(path_parts);\n\treturn ret;\n}", "target": 1}
{"code": "BOOL update_write_cache_bitmap_v3_order(wStream* s, CACHE_BITMAP_V3_ORDER* cache_bitmap_v3,\n                                        UINT16* flags)\n{\n\tBYTE bitsPerPixelId;\n\tBITMAP_DATA_EX* bitmapData;\n\tif (!Stream_EnsureRemainingCapacity(\n\t        s, update_approximate_cache_bitmap_v3_order(cache_bitmap_v3, flags)))\n\t\treturn FALSE;\n\tbitmapData = &cache_bitmap_v3->bitmapData;\n\tbitsPerPixelId = BPP_CBR23[cache_bitmap_v3->bpp];\n\t*flags = (cache_bitmap_v3->cacheId & 0x00000003) |\n\t         ((cache_bitmap_v3->flags << 7) & 0x0000FF80) | ((bitsPerPixelId << 3) & 0x00000078);\n\tStream_Write_UINT16(s, cache_bitmap_v3->cacheIndex); \n\tStream_Write_UINT32(s, cache_bitmap_v3->key1);       \n\tStream_Write_UINT32(s, cache_bitmap_v3->key2);       \n\tStream_Write_UINT8(s, bitmapData->bpp);\n\tStream_Write_UINT8(s, 0);                   \n\tStream_Write_UINT8(s, 0);                   \n\tStream_Write_UINT8(s, bitmapData->codecID); \n\tStream_Write_UINT16(s, bitmapData->width);  \n\tStream_Write_UINT16(s, bitmapData->height); \n\tStream_Write_UINT32(s, bitmapData->length); \n\tStream_Write(s, bitmapData->data, bitmapData->length);\n\treturn TRUE;\n}", "target": 1}
{"code": "horizontalDifference8(unsigned char *ip, int n, int stride, \n\tunsigned short *wp, uint16 *From8)\n{\n    register int  r1, g1, b1, a1, r2, g2, b2, a2, mask;\n#undef\t CLAMP\n#define  CLAMP(v) (From8[(v)])\n    mask = CODE_MASK;\n    if (n >= stride) {\n\tif (stride == 3) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);\n\t    n -= 3;\n\t    while (n > 0) {\n\t\tn -= 3;\n\t\tr1 = CLAMP(ip[3]); wp[3] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[4]); wp[4] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[5]); wp[5] = (uint16)((b1-b2) & mask); b2 = b1;\n\t\twp += 3;\n\t\tip += 3;\n\t    }\n\t} else if (stride == 4) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);  a2 = wp[3] = CLAMP(ip[3]);\n\t    n -= 4;\n\t    while (n > 0) {\n\t\tn -= 4;\n\t\tr1 = CLAMP(ip[4]); wp[4] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[5]); wp[5] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[6]); wp[6] = (uint16)((b1-b2) & mask); b2 = b1;\n\t\ta1 = CLAMP(ip[7]); wp[7] = (uint16)((a1-a2) & mask); a2 = a1;\n\t\twp += 4;\n\t\tip += 4;\n\t    }\n\t} else {\n\t    wp += n + stride - 1;\t\n\t    ip += n + stride - 1;\t\n\t    n -= stride;\n\t    while (n > 0) {\n\t\tREPEAT(stride, wp[0] = CLAMP(ip[0]);\n\t\t\t\twp[stride] -= wp[0];\n\t\t\t\twp[stride] &= mask;\n\t\t\t\twp--; ip--)\n\t\tn -= stride;\n\t    }\n\t    REPEAT(stride, wp[0] = CLAMP(ip[0]); wp--; ip--)\n\t}\n    }\n}", "target": 1}
{"code": "static int proc_pid_limits(struct task_struct *task, char *buffer)\n{\n\tunsigned int i;\n\tint count = 0;\n\tunsigned long flags;\n\tchar *bufptr = buffer;\n\tstruct rlimit rlim[RLIM_NLIMITS];\n\trcu_read_lock();\n\tif (!lock_task_sighand(task,&flags)) {\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\tmemcpy(rlim, task->signal->rlim, sizeof(struct rlimit) * RLIM_NLIMITS);\n\tunlock_task_sighand(task, &flags);\n\trcu_read_unlock();\n\tcount += sprintf(&bufptr[count], \"%-25s %-20s %-20s %-10s\\n\",\n\t\t\t\"Limit\", \"Soft Limit\", \"Hard Limit\", \"Units\");\n\tfor (i = 0; i < RLIM_NLIMITS; i++) {\n\t\tif (rlim[i].rlim_cur == RLIM_INFINITY)\n\t\t\tcount += sprintf(&bufptr[count], \"%-25s %-20s \",\n\t\t\t\t\t lnames[i].name, \"unlimited\");\n\t\telse\n\t\t\tcount += sprintf(&bufptr[count], \"%-25s %-20lu \",\n\t\t\t\t\t lnames[i].name, rlim[i].rlim_cur);\n\t\tif (rlim[i].rlim_max == RLIM_INFINITY)\n\t\t\tcount += sprintf(&bufptr[count], \"%-20s \", \"unlimited\");\n\t\telse\n\t\t\tcount += sprintf(&bufptr[count], \"%-20lu \",\n\t\t\t\t\t rlim[i].rlim_max);\n\t\tif (lnames[i].unit)\n\t\t\tcount += sprintf(&bufptr[count], \"%-10s\\n\",\n\t\t\t\t\t lnames[i].unit);\n\t\telse\n\t\t\tcount += sprintf(&bufptr[count], \"\\n\");\n\t}\n\treturn count;\n}", "target": 0}
{"code": "bool AuthUnknownAuthorizeHandler::verify_authorizer(CephContext *cct, KeyStore *keys,\n\t\t\t\t\t\t bufferlist& authorizer_data, bufferlist& authorizer_reply,\n\t\t\t\t\t\t EntityName& entity_name, uint64_t& global_id, AuthCapsInfo& caps_info, CryptoKey& session_key,\nuint64_t *auid)\n{\n  return true;\n}", "target": 1}
{"code": "static int load_file(struct augeas *aug, struct lens *lens,\n                     const char *lens_name, char *filename) {\n    char *text = NULL;\n    const char *err_status = NULL;\n    struct tree *tree = NULL;\n    char *path = NULL;\n    struct lns_error *err = NULL;\n    struct span *span = NULL;\n    int result = -1, r, text_len = 0;\n    path = file_name_path(aug, filename);\n    ERR_NOMEM(path == NULL, aug);\n    r = add_file_info(aug, path, lens, lens_name, filename, false);\n    if (r < 0)\n        goto done;\n    text = xread_file(filename);\n    if (text == NULL) {\n        err_status = \"read_failed\";\n        goto done;\n    }\n    text_len = strlen(text);\n    text = append_newline(text, text_len);\n    struct info *info;\n    make_ref(info);\n    make_ref(info->filename);\n    info->filename->str = strdup(filename);\n    info->error = aug->error;\n    info->flags = aug->flags;\n    info->first_line = 1;\n    if (aug->flags & AUG_ENABLE_SPAN) {\n        span = make_span(info);\n        ERR_NOMEM(span == NULL, info);\n    }\n    tree = lns_get(info, lens, text, &err);\n    unref(info, info);\n    if (err != NULL) {\n        err_status = \"parse_failed\";\n        goto done;\n    }\n    tree_replace(aug, path, tree);\n    if (span != NULL && tree != NULL) {\n        tree->parent->span = span;\n        tree->parent->span->span_start = 0;\n        tree->parent->span->span_end = text_len;\n    }\n    tree = NULL;\n    result = 0;\n done:\n    store_error(aug, filename + strlen(aug->root) - 1, path, err_status,\n                errno, err, text);\n error:\n    free_lns_error(err);\n    free(path);\n    free_tree(tree);\n    free(text);\n    return result;\n}", "target": 0}
{"code": "address_space_translate_for_iotlb(CPUState *cpu, int asidx, hwaddr addr,\n                                  hwaddr *xlat, hwaddr *plen,\n                                  MemTxAttrs attrs, int *prot)\n{\n    MemoryRegionSection *section;\n    IOMMUMemoryRegion *iommu_mr;\n    IOMMUMemoryRegionClass *imrc;\n    IOMMUTLBEntry iotlb;\n    int iommu_idx;\n    AddressSpaceDispatch *d =\n        qatomic_rcu_read(&cpu->cpu_ases[asidx].memory_dispatch);\n    for (;;) {\n        section = address_space_translate_internal(d, addr, &addr, plen, false);\n        iommu_mr = memory_region_get_iommu(section->mr);\n        if (!iommu_mr) {\n            break;\n        }\n        imrc = memory_region_get_iommu_class_nocheck(iommu_mr);\n        iommu_idx = imrc->attrs_to_index(iommu_mr, attrs);\n        tcg_register_iommu_notifier(cpu, iommu_mr, iommu_idx);\n        iotlb = imrc->translate(iommu_mr, addr, IOMMU_NONE, iommu_idx);\n        addr = ((iotlb.translated_addr & ~iotlb.addr_mask)\n                | (addr & iotlb.addr_mask));\n        if (!(iotlb.perm & IOMMU_RO)) {\n            *prot &= ~(PAGE_READ | PAGE_EXEC);\n        }\n        if (!(iotlb.perm & IOMMU_WO)) {\n            *prot &= ~PAGE_WRITE;\n        }\n        if (!*prot) {\n            goto translate_fail;\n        }\n        d = flatview_to_dispatch(address_space_to_flatview(iotlb.target_as));\n    }\n    assert(!memory_region_is_iommu(section->mr));\n    *xlat = addr;\n    return section;\ntranslate_fail:\n    return &d->map.sections[PHYS_SECTION_UNASSIGNED];\n}", "target": 1}
{"code": "static inline void GetMeanPixelList(PixelList *pixel_list,Quantum *pixel)\n{\n  double\n    sum;\n  register SkipList\n    *p;\n  size_t\n    color;\n  ssize_t\n    count;\n  p=(&pixel_list->skip_list);\n  color=65536L;\n  count=0;\n  sum=0.0;\n  do\n  {\n    color=p->nodes[color].next[0];\n    sum+=(double) p->nodes[color].count*color;\n    count+=p->nodes[color].count;\n  } while (count < (ssize_t) pixel_list->length);\n  sum/=pixel_list->length;\n  *pixel=ScaleShortToQuantum((unsigned short) sum);\n}", "target": 0}
{"code": "PROCESS_THREAD(snmp_process, ev, data)\n{\n  PROCESS_BEGIN();\n  snmp_udp_conn = udp_new(NULL, 0, NULL);\n  udp_bind(snmp_udp_conn, SNMP_SERVER_PORT);\n  LOG_DBG(\"Listening on port %u\\n\", uip_ntohs(snmp_udp_conn->lport));\n  while(1) {\n    PROCESS_YIELD();\n    if(ev == tcpip_event) {\n      if(uip_newdata()) {\n        snmp_process_data();\n      }\n    }\n  } \n  PROCESS_END();\n}", "target": 1}
{"code": "join_path_from_pattern(struct glob_pattern **beg)\n{\n    struct glob_pattern *p;\n    char *path = NULL;\n    size_t path_len = 0;\n    for (p = *beg; p; p = p->next) {\n\tconst char *str;\n\tswitch (p->type) {\n\t  case RECURSIVE:\n\t    str = \"**\";\n\t    break;\n\t  case MATCH_DIR:\n\t    str = \"\";\n\t    break;\n\t  default:\n\t    str = p->str;\n\t    if (!str) continue;\n\t}\n\tif (!path) {\n\t    path_len = strlen(str);\n\t    path = GLOB_ALLOC_N(char, path_len + 1);\n\t    memcpy(path, str, path_len);\n\t    path[path_len] = '\\0';\n        }\n        else {\n\t    size_t len = strlen(str);\n\t    char *tmp;\n\t    tmp = GLOB_REALLOC(path, path_len + len + 2);\n\t    if (tmp) {\n\t\tpath = tmp;\n\t\tpath[path_len++] = '/';\n\t\tmemcpy(path + path_len, str, len);\n\t\tpath_len += len;\n\t\tpath[path_len] = '\\0';\n\t    }\n\t}\n    }\n    return path;\n}", "target": 0}
{"code": "int create_user_ns(struct cred *new)\n{\n\tstruct user_namespace *ns, *parent_ns = new->user_ns;\n\tkuid_t owner = new->euid;\n\tkgid_t group = new->egid;\n\tint ret;\n\tif (current_chrooted())\n\t\treturn -EPERM;\n\tif (!kuid_has_mapping(parent_ns, owner) ||\n\t    !kgid_has_mapping(parent_ns, group))\n\t\treturn -EPERM;\n\tns = kmem_cache_zalloc(user_ns_cachep, GFP_KERNEL);\n\tif (!ns)\n\t\treturn -ENOMEM;\n\tret = proc_alloc_inum(&ns->proc_inum);\n\tif (ret) {\n\t\tkmem_cache_free(user_ns_cachep, ns);\n\t\treturn ret;\n\t}\n\tatomic_set(&ns->count, 1);\n\tns->parent = parent_ns;\n\tns->owner = owner;\n\tns->group = group;\n\tset_cred_user_ns(new, ns);\n\treturn 0;\n}", "target": 0}
{"code": "void AOClient::pktEditEvidence(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    if (!checkEvidenceAccess(area))\n        return;\n    bool is_int = false;\n    int idx = argv[0].toInt(&is_int);\n    AreaData::Evidence evi = {argv[1], argv[2], argv[3]};\n    if (is_int && idx <= area->evidence().size() && idx >= 0) {\n        area->replaceEvidence(idx, evi);\n    }\n    sendEvidenceList(area);\n}", "target": 1}
{"code": "httpd_addheader(isc_httpd_t *httpd, const char *name, const char *val) {\n\tisc_result_t result;\n\tunsigned int needlen;\n\tREQUIRE(VALID_HTTPD(httpd));\n\tneedlen = strlen(name); \n\tif (val != NULL) {\n\t\tneedlen += 2 + strlen(val); \n\t}\n\tneedlen += 2; \n\twhile (isc_buffer_availablelength(&httpd->headerbuffer) < needlen) {\n\t\tresult = grow_headerspace(httpd);\n\t\tif (result != ISC_R_SUCCESS) {\n\t\t\treturn (result);\n\t\t}\n\t}\n\tif (val != NULL) {\n\t\treturn (isc_buffer_printf(&httpd->headerbuffer, \"%s: %s\\r\\n\",\n\t\t\t\t\t  name, val));\n\t} else {\n\t\treturn (isc_buffer_printf(&httpd->headerbuffer, \"%s\\r\\n\",\n\t\t\t\t\t  name));\n\t}\n}", "target": 0}
{"code": "static void fuse_lib_statfs(fuse_req_t req, fuse_ino_t ino)\n{\n    struct fuse *f = req_fuse_prepare(req);\n    struct statvfs buf;\n    char *path;\n    int err;\n    memset(&buf, 0, sizeof(buf));\n    pthread_rwlock_rdlock(&f->tree_lock);\n    if (!ino) {\n        err = -ENOMEM;\n        path = strdup(\"/\");\n    } else {\n        err = -ENOENT;\n        path = get_path(f, ino);\n    }\n    if (path) {\n        struct fuse_intr_data d;\n        fuse_prepare_interrupt(f, req, &d);\n        err = fuse_fs_statfs(f->fs, path, &buf);\n        fuse_finish_interrupt(f, req, &d);\n        free(path);\n    }\n    pthread_rwlock_unlock(&f->tree_lock);\n    if (!err)\n        fuse_reply_statfs(req, &buf);\n    else\n        reply_err(req, err);\n}", "target": 0}
{"code": "static int xar_get_numeric_from_xml_element(xmlTextReaderPtr reader, long * value)\n{\n    const xmlChar * numstr;\n    if (xmlTextReaderRead(reader) == 1 && xmlTextReaderNodeType(reader) == XML_READER_TYPE_TEXT) {\n        numstr = xmlTextReaderConstValue(reader);\n        if (numstr) {\n            *value = atol((const char *)numstr);\n            if (*value < 0) {\n                cli_dbgmsg(\"cli_scanxar: XML element value %li\\n\", *value);\n                return CL_EFORMAT;\n            }\n            return CL_SUCCESS;\n        }\n    }\n    cli_dbgmsg(\"cli_scanxar: No text for XML element\\n\");\n    return CL_EFORMAT;\n}", "target": 1}
{"code": "static bool getFileSizeFromFindData(const WIN32_FIND_DATAW& findData, long long& size)\n{\n    ULARGE_INTEGER fileSize;\n    fileSize.HighPart = findData.nFileSizeHigh;\n    fileSize.LowPart = findData.nFileSizeLow;\n    if (fileSize.QuadPart > static_cast<ULONGLONG>(std::numeric_limits<long long>::max()))\n        return false;\n    size = fileSize.QuadPart;\n    return true;\n}", "target": 0}
{"code": "irc_ctcp_dcc_filename_without_quotes (const char *filename)\n{\n    int length;\n    length = strlen (filename);\n    if (length > 0)\n    {\n        if ((filename[0] == '\\\"') && (filename[length - 1] == '\\\"'))\n            return weechat_strndup (filename + 1, length - 2);\n    }\n    return strdup (filename);\n}", "target": 1}
{"code": "dotraplinkage void notrace do_int3(struct pt_regs *regs, long error_code)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (unlikely(atomic_read(&modifying_ftrace_code)) &&\n\t    ftrace_int3_handler(regs))\n\t\treturn;\n#endif\n\tif (poke_int3_handler(regs))\n\t\treturn;\n\tist_enter(regs);\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(), \"entry code didn't wake RCU\");\n#ifdef CONFIG_KGDB_LOW_LEVEL_TRAP\n\tif (kgdb_ll_trap(DIE_INT3, \"int3\", regs, error_code, X86_TRAP_BP,\n\t\t\t\tSIGTRAP) == NOTIFY_STOP)\n\t\tgoto exit;\n#endif \n#ifdef CONFIG_KPROBES\n\tif (kprobe_int3_handler(regs))\n\t\tgoto exit;\n#endif\n\tif (notify_die(DIE_INT3, \"int3\", regs, error_code, X86_TRAP_BP,\n\t\t\tSIGTRAP) == NOTIFY_STOP)\n\t\tgoto exit;\n\tdebug_stack_usage_inc();\n\tcond_local_irq_enable(regs);\n\tdo_trap(X86_TRAP_BP, SIGTRAP, \"int3\", regs, error_code, NULL);\n\tcond_local_irq_disable(regs);\n\tdebug_stack_usage_dec();\nexit:\n\tist_exit(regs);\n}", "target": 1}
{"code": "static int collect_syscall(struct task_struct *target, struct syscall_info *info)\n{\n\tstruct pt_regs *regs;\n\tif (!try_get_task_stack(target)) {\n\t\tmemset(info, 0, sizeof(*info));\n\t\tinfo->data.nr = -1;\n\t\treturn 0;\n\t}\n\tregs = task_pt_regs(target);\n\tif (unlikely(!regs)) {\n\t\tput_task_stack(target);\n\t\treturn -EAGAIN;\n\t}\n\tinfo->sp = user_stack_pointer(regs);\n\tinfo->data.instruction_pointer = instruction_pointer(regs);\n\tinfo->data.nr = syscall_get_nr(target, regs);\n\tif (info->data.nr != -1L)\n\t\tsyscall_get_arguments(target, regs,\n\t\t\t\t      (unsigned long *)&info->data.args[0]);\n\tput_task_stack(target);\n\treturn 0;\n}", "target": 1}
{"code": "GetIoStats(Mgr::IoActionData& stats)\n{\n    int i;\n    stats.http_reads = IOStats.Http.reads;\n    for (i = 0; i < IoStats::histSize; ++i) {\n        stats.http_read_hist[i] = IOStats.Http.read_hist[i];\n    }\n    stats.ftp_reads = IOStats.Ftp.reads;\n    for (i = 0; i < IoStats::histSize; ++i) {\n        stats.ftp_read_hist[i] = IOStats.Ftp.read_hist[i];\n    }\n    stats.gopher_reads = IOStats.Gopher.reads;\n    for (i = 0; i < IoStats::histSize; ++i) {\n        stats.gopher_read_hist[i] = IOStats.Gopher.read_hist[i];\n    }\n}", "target": 1}
{"code": "TfLiteStatus Gather(const TfLiteGatherParams& params, const TfLiteTensor* input,\n                    const TfLiteTensor* positions, TfLiteTensor* output) {\n  tflite::GatherParams op_params;\n  op_params.axis = params.axis;\n  op_params.batch_dims = params.batch_dims;\n  optimized_ops::Gather(op_params, GetTensorShape(input),\n                        GetTensorData<InputT>(input), GetTensorShape(positions),\n                        GetTensorData<PositionsT>(positions),\n                        GetTensorShape(output), GetTensorData<InputT>(output));\n  return kTfLiteOk;\n}", "target": 1}
{"code": "prologProcessor(XML_Parser parser, const char *s, const char *end,\n                const char **nextPtr) {\n  const char *next = s;\n  int tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                  (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_TRUE,\n                  XML_ACCOUNT_DIRECT);\n}", "target": 0}
{"code": "void vmacache_flush_all(struct mm_struct *mm)\n{\n\tstruct task_struct *g, *p;\n\tcount_vm_vmacache_event(VMACACHE_FULL_FLUSHES);\n\tif (atomic_read(&mm->mm_users) == 1)\n\t\treturn;\n\trcu_read_lock();\n\tfor_each_process_thread(g, p) {\n\t\tif (mm == p->mm)\n\t\t\tvmacache_flush(p);\n\t}\n\trcu_read_unlock();\n}", "target": 1}
{"code": "PHP_MINFO_FUNCTION(mcrypt) \n{\n\tchar **modules;\n\tchar mcrypt_api_no[16];\n\tint i, count;\n\tsmart_str tmp1 = {0};\n\tsmart_str tmp2 = {0};\n\tmodules = mcrypt_list_algorithms(MCG(algorithms_dir), &count);\n\tif (count == 0) {\n\t\tsmart_str_appends(&tmp1, \"none\");\n\t}\n\tfor (i = 0; i < count; i++) {\n\t\tsmart_str_appends(&tmp1, modules[i]);\n\t\tsmart_str_appendc(&tmp1, ' ');\n\t}\n\tsmart_str_0(&tmp1);\n\tmcrypt_free_p(modules, count);\n\tmodules = mcrypt_list_modes(MCG(modes_dir), &count);\n\tif (count == 0) {\n\t\tsmart_str_appends(&tmp2, \"none\");\n\t}\n\tfor (i = 0; i < count; i++) {\n\t\tsmart_str_appends(&tmp2, modules[i]);\n\t\tsmart_str_appendc(&tmp2, ' ');\n\t}\n\tsmart_str_0 (&tmp2);\n\tmcrypt_free_p (modules, count);\n\tsnprintf (mcrypt_api_no, 16, \"%d\", MCRYPT_API_VERSION);\n\tphp_info_print_table_start();\n\tphp_info_print_table_header(2, \"mcrypt support\", \"enabled\");\n\tphp_info_print_table_header(2, \"mcrypt_filter support\", \"enabled\");\n\tphp_info_print_table_row(2, \"Version\", LIBMCRYPT_VERSION);\n\tphp_info_print_table_row(2, \"Api No\", mcrypt_api_no);\n\tphp_info_print_table_row(2, \"Supported ciphers\", tmp1.c);\n\tphp_info_print_table_row(2, \"Supported modes\", tmp2.c);\n\tsmart_str_free(&tmp1);\n\tsmart_str_free(&tmp2);\n\tphp_info_print_table_end();\n\tDISPLAY_INI_ENTRIES();", "target": 1}
{"code": "php_apache_sapi_read_post(char *buf, uint count_bytes TSRMLS_DC)\n{\n\tapr_size_t len, tlen=0;\n\tphp_struct *ctx = SG(server_context);\n\trequest_rec *r;\n\tapr_bucket_brigade *brigade;\n\tr = ctx->r;\n\tbrigade = ctx->brigade;\n\tlen = count_bytes;\n\twhile (ap_get_brigade(r->input_filters, brigade, AP_MODE_READBYTES, APR_BLOCK_READ, len) == APR_SUCCESS) {\n\t\tapr_brigade_flatten(brigade, buf, &len);\n\t\tapr_brigade_cleanup(brigade);\n\t\ttlen += len;\n\t\tif (tlen == count_bytes || !len) {\n\t\t\tbreak;\n\t\t}\n\t\tbuf += len;\n\t\tlen = count_bytes - tlen;\n\t}\n\treturn tlen;\n}", "target": 0}
{"code": "static void sctp_generate_timeout_event(struct sctp_association *asoc,\n\t\t\t\t\tsctp_event_timeout_t timeout_type)\n{\n\tstruct net *net = sock_net(asoc->base.sk);\n\tint error = 0;\n\tbh_lock_sock(asoc->base.sk);\n\tif (sock_owned_by_user(asoc->base.sk)) {\n\t\tpr_debug(\"%s: sock is busy: timer %d\\n\", __func__,\n\t\t\t timeout_type);\n\t\tif (!mod_timer(&asoc->timers[timeout_type], jiffies + (HZ/20)))\n\t\t\tsctp_association_hold(asoc);\n\t\tgoto out_unlock;\n\t}\n\tif (asoc->base.dead)\n\t\tgoto out_unlock;\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(timeout_type),\n\t\t\t   asoc->state, asoc->ep, asoc,\n\t\t\t   (void *)timeout_type, GFP_ATOMIC);\n\tif (error)\n\t\tasoc->base.sk->sk_err = -error;\nout_unlock:\n\tbh_unlock_sock(asoc->base.sk);\n\tsctp_association_put(asoc);\n}", "target": 1}
{"code": "Http::FilterTrailersStatus Context::onResponseTrailers() {\n  if (!wasm_->onResponseTrailers_) {\n    return Http::FilterTrailersStatus::Continue;\n  }\n  if (wasm_->onResponseTrailers_(this, id_).u64_ == 0) {\n    return Http::FilterTrailersStatus::Continue;\n  }\n  return Http::FilterTrailersStatus::StopIteration;\n}", "target": 1}
{"code": "static void cac_free_private_data(cac_private_data_t *priv)\n{\n\tfree(priv->cac_id);\n\tfree(priv->cache_buf);\n\tfree(priv->aca_path);\n\tlist_destroy(&priv->pki_list);\n\tlist_destroy(&priv->general_list);\n\tfree(priv);\n\treturn;\n}", "target": 0}
{"code": "  void ComputeAsyncImpl(OpKernelContext* c, CollectiveExecutor* col_exec,\n                        DoneCallback done) override {\n    auto output_shape = c->input(0).shape();\n    OP_REQUIRES_ASYNC(c, output_shape.dims() > 0,\n                      errors::InvalidArgument(\"input should have rank > 0, \",\n                                              \"recieved \", output_shape.dims()),\n                      done);\n    output_shape.set_dim(\n        0, output_shape.dim_size(0) * col_params_->group.group_size);\n    col_params_->instance.shape = output_shape;\n    if (c->mutable_output(0) == nullptr) {\n      Tensor* output = nullptr;\n      OP_REQUIRES_OK_ASYNC(\n          c, c->allocate_output(0, col_params_->instance.shape, &output), done);\n    }\n    if (!CanProceedWithCompute(c, col_exec, done)) return;\n    auto actual_done = [c, col_params = col_params_, done](const Status& s) {\n      VLOG(1) << \"CollectiveGatherOpKernel ExecuteAsync done for collective \"\n              << c->op_kernel().name() << \" device \" << c->device()->name()\n              << \" group \" << col_params->group.group_key << \" instance \"\n              << col_params->instance.instance_key << \" status \" << s;\n      col_params->Unref();\n      OP_REQUIRES_OK_ASYNC(c, s, done);\n      done();\n    };\n    VLOG(1) << \"CollectiveGatherOpKernel ExecuteAsync start for collective \"\n            << col_params_->name << \" device \" << c->device()->name()\n            << \" group \" << col_params_->group.group_key << \" instance \"\n            << col_params_->instance.instance_key;\n    col_params_->Ref();\n    col_exec->ExecuteAsync(c, col_params_, GetCollectiveKey(c), actual_done);\n  }", "target": 0}
{"code": "static unsigned readChunk_tEXt(LodePNGInfo* info, const unsigned char* data, size_t chunkLength)\n{\n  unsigned error = 0;\n  char *key = 0, *str = 0;\n  unsigned i;\n  while(!error) \n  {\n    unsigned length, string2_begin;\n    length = 0;\n    while(length < chunkLength && data[length] != 0) length++;\n    if(length < 1 || length > 79) CERROR_BREAK(error, 89); \n    key = (char*)malloc(length + 1);\n    if(!key) CERROR_BREAK(error, 83); \n    key[length] = 0;\n    for(i = 0; i < length; i++) key[i] = (char)data[i];\n    string2_begin = length + 1; \n    length = chunkLength < string2_begin ? 0 : chunkLength - string2_begin;\n    str = (char*)malloc(length + 1);\n    if(!str) CERROR_BREAK(error, 83); \n    str[length] = 0;\n    for(i = 0; i < length; i++) str[i] = (char)data[string2_begin + i];\n    error = lodepng_add_text(info, key, str);\n    break;\n  }\n  free(key);\n  free(str);\n  return error;\n}", "target": 0}
{"code": "void _WM_do_control_channel_pan(struct _mdi *mdi, struct _event_data *data) {\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n    mdi->channel[ch].pan = data->data.value;\n    _WM_AdjustChannelVolumes(mdi, ch);\n}", "target": 0}
{"code": "static void domain_exit(struct dmar_domain *domain)\n{\n\tstruct page *freelist = NULL;\n\tif (!domain)\n\t\treturn;\n\trcu_read_lock();\n\tdomain_remove_dev_info(domain);\n\trcu_read_unlock();\n\tput_iova_domain(&domain->iovad);\n\tfreelist = domain_unmap(domain, 0, DOMAIN_MAX_PFN(domain->gaw));\n\tdma_free_pagelist(freelist);\n\tfree_domain_mem(domain);\n}", "target": 0}
{"code": "static int vt_disallocate(unsigned int vc_num)\n{\n\tstruct vc_data *vc = NULL;\n\tint ret = 0;\n\tconsole_lock();\n\tif (vt_busy(vc_num))\n\t\tret = -EBUSY;\n\telse if (vc_num)\n\t\tvc = vc_deallocate(vc_num);\n\tconsole_unlock();\n\tif (vc && vc_num >= MIN_NR_CONSOLES) {\n\t\ttty_port_destroy(&vc->port);\n\t\tkfree(vc);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static int __init sit_init(void)\n{\n\tint err;\n\tprintk(KERN_INFO \"IPv6 over IPv4 tunneling driver\\n\");\n\tif (xfrm4_tunnel_register(&sit_handler, AF_INET6) < 0) {\n\t\tprintk(KERN_INFO \"sit init: Can't add protocol\\n\");\n\t\treturn -EAGAIN;\n\t}\n\terr = register_pernet_device(&sit_net_ops);\n\tif (err < 0)\n\t\txfrm4_tunnel_deregister(&sit_handler, AF_INET6);\n\treturn err;\n}", "target": 1}
{"code": "deltas_head_destroy(struct deltas_head *deltas)\n{\n\tdeltas_head_cleanup(deltas);\n\tfree(deltas);\n}", "target": 1}
{"code": "int LibRaw_bigfile_datastream::jpeg_src(void *jpegdata)\n{\n#ifdef NO_JPEG\n  return -1;\n#else\n  if (!f)\n    return -1;\n  j_decompress_ptr cinfo = (j_decompress_ptr)jpegdata;\n  jpeg_stdio_src(cinfo, f);\n  return 0; \n#endif\n}", "target": 0}
{"code": "libxlDomainEventHandler(void *data, libxl_event *event)\n{\n    libxlDriverPrivate *driver = data;\n    libxl_shutdown_reason xl_reason = event->u.domain_shutdown.shutdown_reason;\n    virDomainObj *vm = NULL;\n    g_autoptr(libxlDriverConfig) cfg = NULL;\n    VIR_DEBUG(\"Received libxl event '%d' for domid '%d'\", event->type, event->domid);\n    if (event->type != LIBXL_EVENT_TYPE_DOMAIN_SHUTDOWN &&\n            event->type != LIBXL_EVENT_TYPE_DOMAIN_DEATH) {\n        VIR_INFO(\"Unhandled event type %d\", event->type);\n        goto cleanup;\n    }\n    if (xl_reason == LIBXL_SHUTDOWN_REASON_SUSPEND)\n        goto cleanup;\n    vm = virDomainObjListFindByID(driver->domains, event->domid);\n    if (!vm) {\n        goto cleanup;\n    }\n    if (event->type == LIBXL_EVENT_TYPE_DOMAIN_SHUTDOWN) {\n        struct libxlEventHandlerThreadInfo *shutdown_info = NULL;\n        virThread thread;\n        g_autofree char *name = NULL;\n        shutdown_info = g_new0(struct libxlEventHandlerThreadInfo, 1);\n        shutdown_info->driver = driver;\n        shutdown_info->vm = vm;\n        shutdown_info->event = (libxl_event *)event;\n        name = g_strdup_printf(\"ev-%d\", event->domid);\n        if (virThreadCreateFull(&thread, false, libxlDomainShutdownThread,\n                                name, false, shutdown_info) < 0) {\n            VIR_ERROR(_(\"Failed to create thread to handle domain shutdown\"));\n            VIR_FREE(shutdown_info);\n            goto cleanup;\n        }\n        return;\n    } else if (event->type == LIBXL_EVENT_TYPE_DOMAIN_DEATH) {\n        libxlDomainHandleDeath(driver, vm);\n    }\n cleanup:\n    virDomainObjEndAPI(&vm);\n    cfg = libxlDriverConfigGet(driver);\n    libxl_event_free(cfg->ctx, (libxl_event *)event);\n}", "target": 1}
{"code": "static void unzzip_cat_file(ZZIP_DIR* disk, char* name, FILE* out)\n{\n    ZZIP_FILE* file = zzip_file_open (disk, name, 0);\n    if (file) \n    {\n\tchar buffer[1024]; int len;\n\twhile ((len = zzip_file_read (file, buffer, 1024))) \n\t{\n\t    fwrite (buffer, 1, len, out);\n\t}\n\tzzip_file_close (file);\n    }\n}", "target": 1}
{"code": "sraSpanInsertBefore(sraSpan *newspan, sraSpan *before) {\n  newspan->_next = before;\n  newspan->_prev = before->_prev;\n  before->_prev->_next = newspan;\n  before->_prev = newspan;\n}", "target": 1}
{"code": "static bool has_locked_children(struct mount *mnt, struct dentry *dentry)\n{\n\tstruct mount *child;\n\tlist_for_each_entry(child, &mnt->mnt_mounts, mnt_child) {\n\t\tif (!is_subdir(child->mnt_mountpoint, dentry))\n\t\t\tcontinue;\n\t\tif (child->mnt.mnt_flags & MNT_LOCKED)\n\t\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "void _af_print_tracks (AFfilehandle filehandle)\n{\n\tint\ti;\n\tfor (i=0; i<filehandle->trackCount; i++)\n\t{\n\t\t_Track\t*track = &filehandle->tracks[i];\n\t\tprintf(\"track %d\\n\", i);\n\t\tprintf(\" id %d\\n\", track->id);\n\t\tprintf(\" sample format\\n\");\n\t\t_af_print_audioformat(&track->f);\n\t\tprintf(\" virtual format\\n\");\n\t\t_af_print_audioformat(&track->v);\n\t\tprintf(\" total file frames: %\" AF_FRAMECOUNT_PRINT_FMT \"\\n\",\n\t\t\ttrack->totalfframes);\n\t\tprintf(\" total virtual frames: %\" AF_FRAMECOUNT_PRINT_FMT \"\\n\",\n\t\t\ttrack->totalvframes);\n\t\tprintf(\" next file frame: %\" AF_FRAMECOUNT_PRINT_FMT \"\\n\",\n\t\t\ttrack->nextfframe);\n\t\tprintf(\" next virtual frame: %\" AF_FRAMECOUNT_PRINT_FMT \"\\n\",\n\t\t\ttrack->nextvframe);\n\t\tprintf(\" frames to ignore: %\" AF_FRAMECOUNT_PRINT_FMT \"\\n\",\n\t\t\ttrack->frames2ignore);\n\t\tprintf(\" data_size: %\" AF_FILEOFFSET_PRINT_FMT \"\\n\",\n\t\t\ttrack->data_size);\n\t\tprintf(\" fpos_first_frame: %\" AF_FILEOFFSET_PRINT_FMT \"\\n\",\n\t\t\ttrack->fpos_first_frame);\n\t\tprintf(\" fpos_next_frame: %\" AF_FILEOFFSET_PRINT_FMT \"\\n\",\n\t\t\ttrack->fpos_next_frame);\n\t\tprintf(\" fpos_after_data: %\" AF_FILEOFFSET_PRINT_FMT \"\\n\",\n\t\t\ttrack->fpos_after_data);\n\t\tprintf(\" channel matrix:\");\n\t\t_af_print_channel_matrix(track->channelMatrix,\n\t\t\ttrack->f.channelCount, track->v.channelCount);\n\t\tprintf(\"\\n\");\n\t\tprintf(\" marker count: %d\\n\", track->markerCount);\n\t}\n}", "target": 0}
{"code": "njs_json_pop_parse_state(njs_vm_t *vm, njs_json_parse_t *parse)\n{\n    njs_json_state_t  *state;\n    state = &parse->states[parse->depth - 1];\n    njs_array_destroy(vm, state->keys);\n    state->keys = NULL;\n    if (parse->depth > 1) {\n        parse->depth--;\n        return &parse->states[parse->depth - 1];\n    }\n    return NULL;\n}", "target": 1}
{"code": "static int proc_pid_readlink(struct dentry * dentry, char __user * buffer, int buflen)\n{\n\tint error = -EACCES;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct dentry *de;\n\tstruct vfsmount *mnt = NULL;\n\tif (!proc_fd_access_allowed(inode))\n\t\tgoto out;\n\terror = PROC_I(inode)->op.proc_get_link(inode, &de, &mnt);\n\tif (error)\n\t\tgoto out;\n\terror = do_proc_readlink(de, mnt, buffer, buflen);\n\tdput(de);\n\tmntput(mnt);\nout:\n\treturn error;\n}", "target": 0}
{"code": "void __ip_select_ident(struct net *net, struct iphdr *iph, int segs)\n{\n\tstatic u32 ip_idents_hashrnd __read_mostly;\n\tu32 hash, id;\n\tnet_get_random_once(&ip_idents_hashrnd, sizeof(ip_idents_hashrnd));\n\thash = jhash_3words((__force u32)iph->daddr,\n\t\t\t    (__force u32)iph->saddr,\n\t\t\t    iph->protocol ^ net_hash_mix(net),\n\t\t\t    ip_idents_hashrnd);\n\tid = ip_idents_reserve(hash, segs);\n\tiph->id = htons(id);\n}", "target": 1}
{"code": "static ssize_t revision_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct bmc_device *bmc = to_bmc_device(dev);\n\tstruct ipmi_device_id id;\n\tint rv;\n\trv = bmc_get_device_id(NULL, bmc, &id, NULL, NULL);\n\tif (rv)\n\t\treturn rv;\n\treturn snprintf(buf, 20, \"%u\\n\", id.device_revision & 0x0F);\n}", "target": 0}
{"code": "dcchkstr(int size)\n{\n\twhile( (strsize+size) > strmaxsize ) {\n\t\tdcstr=realloc(dcstr,strmaxsize+DCSTRSIZE);\n\t\tstrmaxsize+=DCSTRSIZE;\n\t\tdcptr=dcstr+strsize;\n\t}\n}", "target": 0}
{"code": "snmp_engine_get(snmp_header_t *header, snmp_varbind_t *varbinds, uint32_t varbinds_length)\n{\n  snmp_mib_resource_t *resource;\n  uint32_t i;\n  for(i = 0; i < varbinds_length; i++) {\n    resource = snmp_mib_find(varbinds[i].oid);\n    if(!resource) {\n      switch(header->version) {\n      case SNMP_VERSION_1:\n        header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n        header->error_index_max_repetitions.error_index = i + 1;\n        break;\n      case SNMP_VERSION_2C:\n        (&varbinds[i])->value_type = SNMP_DATA_TYPE_NO_SUCH_INSTANCE;\n        break;\n      default:\n        header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n        header->error_index_max_repetitions.error_index = 0;\n      }\n    } else {\n      resource->handler(&varbinds[i], resource->oid);\n    }\n  }\n  return 0;\n}", "target": 1}
{"code": "static uint8_t net_tx_pkt_get_gso_type(struct NetTxPkt *pkt,\n                                          bool tso_enable)\n{\n    uint8_t rc = VIRTIO_NET_HDR_GSO_NONE;\n    uint16_t l3_proto;\n    l3_proto = eth_get_l3_proto(&pkt->vec[NET_TX_PKT_L2HDR_FRAG], 1,\n        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len);\n    if (!tso_enable) {\n        goto func_exit;\n    }\n    rc = eth_get_gso_type(l3_proto, pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base,\n                          pkt->l4proto);\nfunc_exit:\n    return rc;\n}", "target": 0}
{"code": "static sctp_disposition_t sctp_sf_tabort_8_4_8(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_packet *packet = NULL;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *abort;\n\tpacket = sctp_ootb_pkt_new(net, asoc, chunk);\n\tif (packet) {\n\t\tabort = sctp_make_abort(asoc, chunk, 0);\n\t\tif (!abort) {\n\t\t\tsctp_ootb_pkt_free(packet);\n\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\t\t}\n\t\tif (sctp_test_T_bit(abort))\n\t\t\tpacket->vtag = ntohl(chunk->sctp_hdr->vtag);\n\t\tabort->skb->sk = ep->base.sk;\n\t\tsctp_packet_append_chunk(packet, abort);\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\t\tSCTP_PACKET(packet));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\t\tsctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\treturn SCTP_DISPOSITION_CONSUME;\n\t}\n\treturn SCTP_DISPOSITION_NOMEM;\n}", "target": 0}
{"code": "static int get_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)\n{\n\tint ret;\n\tret = usb_control_msg(pegasus->usb, usb_rcvctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_GET_REGS, PEGASUS_REQT_READ, 0,\n\t\t\t      indx, data, size, 1000);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\treturn ret;\n}", "target": 1}
{"code": "    setSanMatchers(std::vector<envoy::type::matcher::v3::StringMatcher> san_matchers) {\n      san_matchers_ = san_matchers;\n      return *this;\n    }", "target": 1}
{"code": "ppp_receive_frame(struct ppp *ppp, struct sk_buff *skb, struct channel *pch)\n{\n\tif (pskb_may_pull(skb, 2)) {\n#ifdef CONFIG_PPP_MULTILINK\n\t\tif (PPP_PROTO(skb) == PPP_MP)\n\t\t\tppp_receive_mp_frame(ppp, skb, pch);\n\t\telse\n#endif \n\t\t\tppp_receive_nonmp_frame(ppp, skb);\n\t\treturn;\n\t}\n\tif (skb->len > 0)\n\t\t++ppp->dev->stats.rx_length_errors;\n\tkfree_skb(skb);\n\tppp_receive_error(ppp);\n}", "target": 0}
{"code": "rdpsnd_flush_record(void)\n{\n\tSTREAM s;\n\tunsigned int chunk_size;\n\tchar *data;\n\tif (record_buffer_size == 0)\n\t\treturn;\n\tassert(record_buffer_size <= sizeof(record_buffer));\n\tdata = record_buffer;\n\twhile (record_buffer_size)\n\t{\n\t\tif (record_buffer_size < 1596)\n\t\t\tchunk_size = record_buffer_size;\n\t\telse\n\t\t\tchunk_size = 1596;\n\t\ts = rdpsnd_init_packet(RDPSND_REC_DATA, chunk_size);\n\t\tout_uint8p(s, data, chunk_size);\n\t\ts_mark_end(s);\n\t\trdpsnd_send(s);\n\t\tdata = data + chunk_size;\n\t\trecord_buffer_size -= chunk_size;\n\t\tDEBUG_SOUND((\"RDPSND: -> RDPSND_REC_DATA(length: %u)\\n\", (unsigned) chunk_size));\n\t}\n\trecord_buffer_size = 0;\n}", "target": 0}
{"code": "static int get_manuf_info(struct edgeport_serial *serial, __u8 *buffer)\n{\n\tint status;\n\tint start_address;\n\tstruct ti_i2c_desc *rom_desc;\n\tstruct edge_ti_manuf_descriptor *desc;\n\tstruct device *dev = &serial->serial->dev->dev;\n\trom_desc = kmalloc(sizeof(*rom_desc), GFP_KERNEL);\n\tif (!rom_desc)\n\t\treturn -ENOMEM;\n\tstart_address = get_descriptor_addr(serial, I2C_DESC_TYPE_ION,\n\t\t\t\t\t\t\t\trom_desc);\n\tif (!start_address) {\n\t\tdev_dbg(dev, \"%s - Edge Descriptor not found in I2C\\n\", __func__);\n\t\tstatus = -ENODEV;\n\t\tgoto exit;\n\t}\n\tstatus = read_rom(serial, start_address+sizeof(struct ti_i2c_desc),\n\t\t\t\t\tle16_to_cpu(rom_desc->Size), buffer);\n\tif (status)\n\t\tgoto exit;\n\tstatus = valid_csum(rom_desc, buffer);\n\tdesc = (struct edge_ti_manuf_descriptor *)buffer;\n\tdev_dbg(dev, \"%s - IonConfig      0x%x\\n\", __func__, desc->IonConfig);\n\tdev_dbg(dev, \"%s - Version          %d\\n\", __func__, desc->Version);\n\tdev_dbg(dev, \"%s - Cpu/Board      0x%x\\n\", __func__, desc->CpuRev_BoardRev);\n\tdev_dbg(dev, \"%s - NumPorts         %d\\n\", __func__, desc->NumPorts);\n\tdev_dbg(dev, \"%s - NumVirtualPorts  %d\\n\", __func__, desc->NumVirtualPorts);\n\tdev_dbg(dev, \"%s - TotalPorts       %d\\n\", __func__, desc->TotalPorts);\nexit:\n\tkfree(rom_desc);\n\treturn status;\n}", "target": 0}
{"code": "bool IsConstantFoldable(\n    const Node* n,\n    const std::unordered_map<string, std::vector<PartialTensorShape>>*\n        shape_map,\n    const std::function<bool(const Node*)>& consider,\n    int64_t max_constant_size_in_bytes,\n    std::unordered_map<const Node*, std::vector<Tensor>>*\n        shape_replacement_map) {\n  if (n->IsConstant()) {\n    return true;\n  }\n  if (MaybeReplaceShapeOp(n, shape_map, shape_replacement_map)) {\n    return true;\n  }\n  if (n->op_def().is_stateful()) {\n    return false;\n  }\n  if (consider && !consider(n)) {\n    return false;\n  }\n  if (shape_map != nullptr) {\n    auto shape_it = shape_map->find(n->name());\n    if (shape_it != shape_map->end()) {\n      for (int64_t i = 0; i < shape_it->second.size(); ++i) {\n        const auto& out_shape = shape_it->second[i];\n        if (out_shape.IsFullyDefined() &&\n            out_shape.num_elements() * DataTypeSize(n->output_type(i)) >\n                max_constant_size_in_bytes) {\n          return false;\n        }\n      }\n    }\n  }\n  if (n->IsControlFlow() || n->IsSend() || n->IsRecv()) {\n    return false;\n  }\n  if (n->IsGetSessionHandle() || n->IsGetSessionTensor() ||\n      n->IsDeleteSessionTensor()) {\n    return false;\n  }\n  if (n->IsSource()) {\n    return false;\n  }\n  if (n->IsSink()) {\n    return false;\n  }\n  if (n->IsFakeParam()) {\n    return false;\n  }\n  if (!KernelDefAvailable(DeviceType(DEVICE_CPU), n->def())) {\n    return false;\n  }\n  if (n->attrs().Find(kScopedAllocatorAttrName) != nullptr) {\n    VLOG(2) << \"Skip node [\" << n->DebugString()\n            << \"] for constant folding due to scoped allocator\";\n    return false;\n  }\n  return true;\n}", "target": 1}
{"code": "static int mov_read_dfla(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    int last, type, size, ret;\n    uint8_t buf[4];\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    if ((uint64_t)atom.size > (1<<30) || atom.size < 42)\n        return AVERROR_INVALIDDATA;\n    if (avio_r8(pb) != 0)\n        return AVERROR_INVALIDDATA;\n    avio_rb24(pb); \n    if (avio_read(pb, buf, sizeof(buf)) != sizeof(buf)) {\n        av_log(c->fc, AV_LOG_ERROR, \"failed to read FLAC metadata block header\\n\");\n        return pb->error < 0 ? pb->error : AVERROR_INVALIDDATA;\n    }\n    flac_parse_block_header(buf, &last, &type, &size);\n    if (type != FLAC_METADATA_TYPE_STREAMINFO || size != FLAC_STREAMINFO_SIZE) {\n        av_log(c->fc, AV_LOG_ERROR, \"STREAMINFO must be first FLACMetadataBlock\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    ret = ff_get_extradata(c->fc, st->codecpar, pb, size);\n    if (ret < 0)\n        return ret;\n    if (!last)\n        av_log(c->fc, AV_LOG_WARNING, \"non-STREAMINFO FLACMetadataBlock(s) ignored\\n\");\n    return 0;\n}", "target": 0}
{"code": "int RGWPutCORS_ObjStore_S3::get_params()\n{\n  int r;\n  char *data = nullptr;\n  int len = 0;\n  RGWCORSXMLParser_S3 parser(s->cct);\n  RGWCORSConfiguration_S3 *cors_config;\n  const auto max_size = s->cct->_conf->rgw_max_put_param_size;\n  r = rgw_rest_read_all_input(s, &data, &len, max_size, false);\n  if (r < 0) {\n    return r;\n  }\n  auto data_deleter = std::unique_ptr<char, decltype(free)*>{data, free};\n  r = do_aws4_auth_completion();\n  if (r < 0) {\n    return r;\n  }\n  if (!parser.init()) {\n    return -EINVAL;\n  }\n  if (!data || !parser.parse(data, len, 1)) {\n    return -EINVAL;\n  }\n  cors_config =\n    static_cast<RGWCORSConfiguration_S3 *>(parser.find_first(\n\t\t\t\t\t     \"CORSConfiguration\"));\n  if (!cors_config) {\n    return -EINVAL;\n  }\n#define CORS_RULES_MAX_NUM      100\n  int max_num = s->cct->_conf->rgw_cors_rules_max_num;\n  if (max_num < 0) {\n    max_num = CORS_RULES_MAX_NUM;\n  }\n  int cors_rules_num = cors_config->get_rules().size();\n  if (cors_rules_num > max_num) {\n    ldout(s->cct, 4) << \"An cors config can have up to \"\n                     << max_num\n                     << \" rules, request cors rules num: \"\n                     << cors_rules_num << dendl;\n    op_ret = -ERR_INVALID_CORS_RULES_ERROR;\n    s->err.message = \"The number of CORS rules should not exceed allowed limit of \"\n                     + std::to_string(max_num) + \" rules.\";\n    return -ERR_INVALID_REQUEST;\n  }\n  if (!store->is_meta_master()) {\n    in_data.append(data, len);\n  }\n  if (s->cct->_conf->subsys.should_gather<ceph_subsys_rgw, 15>()) {\n    ldout(s->cct, 15) << \"CORSConfiguration\";\n    cors_config->to_xml(*_dout);\n    *_dout << dendl;\n  }\n  cors_config->encode(cors_bl);\n  return 0;\n}", "target": 0}
{"code": "static void cleanup_async_copy(struct nfsd4_copy *copy)\n{\n\tnfs4_free_cp_state(copy);\n\tfput(copy->file_dst);\n\tfput(copy->file_src);\n\tspin_lock(&copy->cp_clp->async_lock);\n\tlist_del(&copy->copies);\n\tspin_unlock(&copy->cp_clp->async_lock);\n\tnfs4_put_copy(copy);\n}", "target": 0}
{"code": "static inline int fpregs_state_valid(struct fpu *fpu, unsigned int cpu)\n{\n\treturn fpu == this_cpu_read_stable(fpu_fpregs_owner_ctx) && cpu == fpu->last_cpu;\n}", "target": 1}
{"code": "MenuCacheItem *menu_cache_find_item_by_id(MenuCache *cache, const char *id)\n{\n    MenuCacheItem *item = NULL;\n    MENU_CACHE_LOCK;\n    if (cache && id)\n        item = _scan_by_id(MENU_CACHE_ITEM(cache->root_dir), id);\n    if (item)\n        menu_cache_item_ref(item);\n    MENU_CACHE_UNLOCK;\n    return item;\n}", "target": 0}
{"code": "ikev2_auth_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len _U_, const u_char *ep,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct ikev2_auth a;\n\tconst char *v2_auth[]={ \"invalid\", \"rsasig\",\n\t\t\t\t\"shared-secret\", \"dsssig\" };\n\tconst u_char *authdata = (const u_char*)ext + sizeof(a);\n\tunsigned int len;\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&a, ext, sizeof(a));\n\tikev2_pay_print(ndo, NPSTR(tpay), a.h.critical);\n\tlen = ntohs(a.h.len);\n\tND_PRINT((ndo,\" len=%d method=%s\", len-4,\n\t\t  STR_OR_ID(a.auth_method, v2_auth)));\n\tif (1 < ndo->ndo_vflag && 4 < len) {\n\t\tND_PRINT((ndo,\" authdata=(\"));\n\t\tif (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))\n\t\t\tgoto trunc;\n\t\tND_PRINT((ndo,\") \"));\n\t} else if(ndo->ndo_vflag && 4 < len) {\n\t\tif(!ike_show_somedata(ndo, authdata, ep)) goto trunc;\n\t}\n\treturn (const u_char *)ext + len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}", "target": 1}
{"code": "TfLiteStatus CalculateOpData(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteDepthToSpaceParams*>(node->builtin_data);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4);\n  auto data_type = output->type;\n  TF_LITE_ENSURE(context,\n                 data_type == kTfLiteFloat32 || data_type == kTfLiteInt8);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  const int block_size = params->block_size;\n  TF_LITE_ENSURE(context, block_size > 0);\n  const int input_height = input->dims->data[kHeightRank];\n  const int input_width = input->dims->data[kWidthRank];\n  const int input_channels = input->dims->data[kDepthRank];\n  int output_height = input_height * block_size;\n  int output_width = input_width * block_size;\n  int output_channels = input_channels / block_size / block_size;\n  TF_LITE_ENSURE_EQ(context, input_height, output_height / block_size);\n  TF_LITE_ENSURE_EQ(context, input_width, output_width / block_size);\n  TF_LITE_ENSURE_EQ(context, input_channels,\n                    output_channels * block_size * block_size);\n  TfLiteEvalTensor* output_eval =\n      tflite::micro::GetEvalOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE_OK(context, tflite::micro::CreateWritableTensorDimsWithCopy(\n                                 context, output, output_eval));\n  output->dims->data[kBatchRank] = input->dims->data[kBatchRank];\n  output->dims->data[kHeightRank] = output_height;\n  output->dims->data[kWidthRank] = output_width;\n  output->dims->data[kDepthRank] = output_channels;\n  return kTfLiteOk;\n}", "target": 0}
{"code": "void header_time(int stat, char *str, char *more)\n{\n  char buf[64];\n  xprintf(\"HTTP/1.1 %d %s\\r\\nServer: toybox httpd/%s\\r\\nDate: %s\\r\\n%s\"\n    \"Connection: close\\r\\n\\r\\n\", stat, str, TOYBOX_VERSION,\n    rfc1123(buf, time(0)), more ? : \"\");\n}", "target": 0}
{"code": "int ssl3_get_new_session_ticket(SSL *s)\n{\n    int ok, al, ret = 0, ticklen;\n    long n;\n    const unsigned char *p;\n    unsigned char *d;\n    n = s->method->ssl_get_message(s,\n                                   SSL3_ST_CR_SESSION_TICKET_A,\n                                   SSL3_ST_CR_SESSION_TICKET_B,\n                                   SSL3_MT_NEWSESSION_TICKET, 16384, &ok);\n    if (!ok)\n        return ((int)n);\n    if (n < 6) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n    p = d = (unsigned char *)s->init_msg;\n    n2l(p, s->session->tlsext_tick_lifetime_hint);\n    n2s(p, ticklen);\n    if (ticklen + 6 != n) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n    if (s->session->tlsext_tick) {\n        OPENSSL_free(s->session->tlsext_tick);\n        s->session->tlsext_ticklen = 0;\n    }\n    s->session->tlsext_tick = OPENSSL_malloc(ticklen);\n    if (!s->session->tlsext_tick) {\n        SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    memcpy(s->session->tlsext_tick, p, ticklen);\n    s->session->tlsext_ticklen = ticklen;\n    EVP_Digest(p, ticklen,\n               s->session->session_id, &s->session->session_id_length,\n# ifndef OPENSSL_NO_SHA256\n               EVP_sha256(), NULL);\n# else\n               EVP_sha1(), NULL);\n# endif\n    ret = 1;\n    return (ret);\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n err:\n    s->state = SSL_ST_ERR;\n    return (-1);\n}", "target": 1}
{"code": "static void tcp_send_challenge_ack(struct sock *sk, const struct sk_buff *skb)\n{\n\tstatic u32 challenge_timestamp;\n\tstatic unsigned int challenge_count;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 now;\n\tif (tcp_oow_rate_limited(sock_net(sk), skb,\n\t\t\t\t LINUX_MIB_TCPACKSKIPPEDCHALLENGE,\n\t\t\t\t &tp->last_oow_ack_time))\n\t\treturn;\n\tnow = jiffies / HZ;\n\tif (now != challenge_timestamp) {\n\t\tchallenge_timestamp = now;\n\t\tchallenge_count = 0;\n\t}\n\tif (++challenge_count <= sysctl_tcp_challenge_ack_limit) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPCHALLENGEACK);\n\t\ttcp_send_ack(sk);\n\t}\n}", "target": 1}
{"code": "static int tipc_nl_compat_link_dump(struct tipc_nl_compat_msg *msg,\n\t\t\t\t    struct nlattr **attrs)\n{\n\tstruct nlattr *link[TIPC_NLA_LINK_MAX + 1];\n\tstruct tipc_link_info link_info;\n\tint err;\n\tif (!attrs[TIPC_NLA_LINK])\n\t\treturn -EINVAL;\n\terr = nla_parse_nested(link, TIPC_NLA_LINK_MAX, attrs[TIPC_NLA_LINK],\n\t\t\t       NULL);\n\tif (err)\n\t\treturn err;\n\tlink_info.dest = nla_get_flag(link[TIPC_NLA_LINK_DEST]);\n\tlink_info.up = htonl(nla_get_flag(link[TIPC_NLA_LINK_UP]));\n\tnla_strlcpy(link_info.str, nla_data(link[TIPC_NLA_LINK_NAME]),\n\t\t    TIPC_MAX_LINK_NAME);\n\treturn tipc_add_tlv(msg->rep, TIPC_TLV_LINK_INFO,\n\t\t\t    &link_info, sizeof(link_info));\n}", "target": 0}
{"code": "static Status ValidateStrides(const T& strides) {\n  for (size_t i = 0; i < strides.size(); ++i) {\n    if (strides[i] <= 0) {\n      return errors::InvalidArgument(\n          \"Sliding window stride field for dimension \", i,\n          \" must be positive but is \", strides[i]);\n    }\n  }\n  return OkStatus();\n}", "target": 0}
{"code": "static void vcc_sock_destruct(struct sock *sk)\n{\n\tif (atomic_read(&sk->sk_rmem_alloc))\n\t\tprintk(KERN_DEBUG \"%s: rmem leakage (%d bytes) detected.\\n\",\n\t\t       __func__, atomic_read(&sk->sk_rmem_alloc));\n\tif (atomic_read(&sk->sk_wmem_alloc))\n\t\tprintk(KERN_DEBUG \"%s: wmem leakage (%d bytes) detected.\\n\",\n\t\t       __func__, atomic_read(&sk->sk_wmem_alloc));\n}", "target": 0}
{"code": "gopher_request_parse(const HttpRequest * req, char *type_id, char *request)\n{\n    ::Parser::Tokenizer tok(req->url.path());\n    if (request)\n        *request = 0;\n    tok.skip('/'); \n    if (tok.atEnd()) {\n        *type_id = GOPHER_DIRECTORY;\n        return;\n    }\n    static const CharacterSet anyByte(\"UTF-8\",0x00, 0xFF);\n    SBuf typeId;\n    (void)tok.prefix(typeId, anyByte, 1); \n    *type_id = typeId[0];\n    if (request) {\n        SBufToCstring(request, tok.remaining().substr(0, MAX_URL-1));\n        rfc1738_unescape(request);\n    }\n}", "target": 1}
{"code": "static void xen_netbk_idx_release(struct xen_netbk *netbk, u16 pending_idx)\n{\n\tstruct xenvif *vif;\n\tstruct pending_tx_info *pending_tx_info;\n\tpending_ring_idx_t index;\n\tif (netbk->mmap_pages[pending_idx] == NULL)\n\t\treturn;\n\tpending_tx_info = &netbk->pending_tx_info[pending_idx];\n\tvif = pending_tx_info->vif;\n\tmake_tx_response(vif, &pending_tx_info->req, XEN_NETIF_RSP_OKAY);\n\tindex = pending_index(netbk->pending_prod++);\n\tnetbk->pending_ring[index] = pending_idx;\n\txenvif_put(vif);\n\tnetbk->mmap_pages[pending_idx]->mapping = 0;\n\tput_page(netbk->mmap_pages[pending_idx]);\n\tnetbk->mmap_pages[pending_idx] = NULL;\n}", "target": 1}
{"code": "static void php_mb_regex_free_cache(php_mb_regex_t **pre) \n{\n\tonig_free(*pre);\n}", "target": 1}
{"code": "static char *oidc_cache_get_hashed_key(request_rec *r, const char *passphrase,\n\t\tconst char *key) {\n\tchar *input = apr_psprintf(r->pool, \"%s:%s\", passphrase, key);\n\tchar *output = NULL;\n\tif (oidc_util_hash_string_and_base64url_encode(r, OIDC_JOSE_ALG_SHA256,\n\t\t\tinput, &output) == FALSE) {\n\t\toidc_error(r,\n\t\t\t\t\"oidc_util_hash_string_and_base64url_encode returned an error\");\n\t\treturn NULL;\n\t}\n\treturn output;\n}", "target": 1}
{"code": "void jpc_qmfb_split_col(jpc_fix_t *a, int numrows, int stride,\n  int parity)\n{\n\tint bufsize = JPC_CEILDIVPOW2(numrows, 1);\n\tjpc_fix_t splitbuf[QMFB_SPLITBUFSIZE];\n\tjpc_fix_t *buf = splitbuf;\n\tregister jpc_fix_t *srcptr;\n\tregister jpc_fix_t *dstptr;\n\tregister int n;\n\tregister int m;\n\tint hstartcol;\n\tif (bufsize > QMFB_SPLITBUFSIZE) {\n\t\tif (!(buf = jas_alloc2(bufsize, sizeof(jpc_fix_t)))) {\n\t\t\tabort();\n\t\t}\n\t}\n\tif (numrows >= 2) {\n\t\thstartcol = (numrows + 1 - parity) >> 1;\n\t\tm = numrows - hstartcol;\n\t\tn = m;\n\t\tdstptr = buf;\n\t\tsrcptr = &a[(1 - parity) * stride];\n\t\twhile (n-- > 0) {\n\t\t\t*dstptr = *srcptr;\n\t\t\t++dstptr;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\tdstptr = &a[(1 - parity) * stride];\n\t\tsrcptr = &a[(2 - parity) * stride];\n\t\tn = numrows - m - (!parity);\n\t\twhile (n-- > 0) {\n\t\t\t*dstptr = *srcptr;\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\tdstptr = &a[hstartcol * stride];\n\t\tsrcptr = buf;\n\t\tn = m;\n\t\twhile (n-- > 0) {\n\t\t\t*dstptr = *srcptr;\n\t\t\tdstptr += stride;\n\t\t\t++srcptr;\n\t\t}\n\t}\n\tif (buf != splitbuf) {\n\t\tjas_free(buf);\n\t}\n}", "target": 1}
{"code": "p2bit(UINT8 *out, const UINT8 *in, int xsize, const UINT8 *palette) {\n    int x;\n    for (x = 0; x < xsize; x++) {\n        *out++ = (L(&palette[in[x] * 4]) >= 128000) ? 255 : 0;\n    }\n}", "target": 0}
{"code": "static int synic_set_msr(struct kvm_vcpu_hv_synic *synic,\n\t\t\t u32 msr, u64 data, bool host)\n{\n\tstruct kvm_vcpu *vcpu = hv_synic_to_vcpu(synic);\n\tint ret;\n\tif (!synic->active && !host)\n\t\treturn 1;\n\ttrace_kvm_hv_synic_set_msr(vcpu->vcpu_id, msr, data, host);\n\tret = 0;\n\tswitch (msr) {\n\tcase HV_X64_MSR_SCONTROL:\n\t\tsynic->control = data;\n\t\tif (!host)\n\t\t\tsynic_exit(synic, msr);\n\t\tbreak;\n\tcase HV_X64_MSR_SVERSION:\n\t\tif (!host) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\tsynic->version = data;\n\t\tbreak;\n\tcase HV_X64_MSR_SIEFP:\n\t\tif ((data & HV_SYNIC_SIEFP_ENABLE) && !host &&\n\t\t    !synic->dont_zero_synic_pages)\n\t\t\tif (kvm_clear_guest(vcpu->kvm,\n\t\t\t\t\t    data & PAGE_MASK, PAGE_SIZE)) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tsynic->evt_page = data;\n\t\tif (!host)\n\t\t\tsynic_exit(synic, msr);\n\t\tbreak;\n\tcase HV_X64_MSR_SIMP:\n\t\tif ((data & HV_SYNIC_SIMP_ENABLE) && !host &&\n\t\t    !synic->dont_zero_synic_pages)\n\t\t\tif (kvm_clear_guest(vcpu->kvm,\n\t\t\t\t\t    data & PAGE_MASK, PAGE_SIZE)) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tsynic->msg_page = data;\n\t\tif (!host)\n\t\t\tsynic_exit(synic, msr);\n\t\tbreak;\n\tcase HV_X64_MSR_EOM: {\n\t\tint i;\n\t\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++)\n\t\t\tkvm_hv_notify_acked_sint(vcpu, i);\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\n\t\tret = synic_set_sint(synic, msr - HV_X64_MSR_SINT0, data, host);\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "void GfxPath::append(GfxPath *path)\n{\n    int i;\n    if (n + path->n > size) {\n        size = n + path->n;\n        subpaths = (GfxSubpath **)greallocn(subpaths, size, sizeof(GfxSubpath *));\n    }\n    for (i = 0; i < path->n; ++i) {\n        subpaths[n++] = path->subpaths[i]->copy();\n    }\n    justMoved = false;\n}", "target": 0}
{"code": "static void debug_print_fis(uint8_t *fis, int cmd_len)\n{\n#if DEBUG_AHCI\n    int i;\n    fprintf(stderr, \"fis:\");\n    for (i = 0; i < cmd_len; i++) {\n        if ((i & 0xf) == 0) {\n            fprintf(stderr, \"\\n%02x:\",i);\n        }\n        fprintf(stderr, \"%02x \",fis[i]);\n    }\n    fprintf(stderr, \"\\n\");\n#endif\n}", "target": 0}
{"code": "static MagickBooleanType CheckPrimitiveExtent(MVGInfo *mvg_info,\n  const double pad)\n{\n  double\n    extent;\n  size_t\n    quantum;\n  quantum=sizeof(**mvg_info->primitive_info);\n  extent=(double) mvg_info->offset+pad+PrimitiveExtentPad*quantum+1.0;\n  if (extent <= (double) *mvg_info->extent)\n    return(MagickTrue);\n  if (extent == (double) CastDoubleToLong(extent))\n    {\n      *mvg_info->primitive_info=(PrimitiveInfo *) ResizeQuantumMemory(\n        *mvg_info->primitive_info,(size_t) extent,quantum);\n      if (*mvg_info->primitive_info != (PrimitiveInfo *) NULL)\n        {\n          ssize_t\n            i;\n          *mvg_info->extent=(size_t) extent;\n          for (i=mvg_info->offset+1; i < (ssize_t) extent; i++)\n            (*mvg_info->primitive_info)[i].primitive=UndefinedPrimitive;\n          return(MagickTrue);\n        }\n    }\n  if (*mvg_info->primitive_info != (PrimitiveInfo *) NULL)\n    *mvg_info->primitive_info=(PrimitiveInfo *) RelinquishMagickMemory(\n      *mvg_info->primitive_info);\n  (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n    ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n  *mvg_info->primitive_info=(PrimitiveInfo *)  AcquireCriticalMemory(\n    (size_t) (PrimitiveExtentPad*quantum));\n  (void) memset(*mvg_info->primitive_info,0,(size_t)\n    (PrimitiveExtentPad*quantum));\n  *mvg_info->extent=1;\n  return(MagickFalse);\n}", "target": 0}
{"code": "int bio_uncopy_user(struct bio *bio)\n{\n\tstruct bio_map_data *bmd = bio->bi_private;\n\tint ret = 0;\n\tif (!bio_flagged(bio, BIO_NULL_MAPPED)) {\n\t\tif (!current->mm)\n\t\t\tret = -EINTR;\n\t\telse if (bio_data_dir(bio) == READ)\n\t\t\tret = bio_copy_to_iter(bio, bmd->iter);\n\t\tif (bmd->is_our_pages)\n\t\t\tbio_free_pages(bio);\n\t}\n\tkfree(bmd);\n\tbio_put(bio);\n\treturn ret;\n}", "target": 0}
{"code": "void prefetch_table(const void *tab, size_t len)\n{\n  const volatile byte *vtab = tab;\n  size_t i;\n  for (i = 0; i < len; i += 8 * 32)\n    {\n      (void)vtab[i + 0 * 32];\n      (void)vtab[i + 1 * 32];\n      (void)vtab[i + 2 * 32];\n      (void)vtab[i + 3 * 32];\n      (void)vtab[i + 4 * 32];\n      (void)vtab[i + 5 * 32];\n      (void)vtab[i + 6 * 32];\n      (void)vtab[i + 7 * 32];\n    }\n  (void)vtab[len - 1];\n}", "target": 1}
{"code": "archive_write_disk_set_acls(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode)\n{\n\tint\t\tret = ARCHIVE_OK;\n\t(void)mode;\t\n\tif ((archive_acl_types(abstract_acl)\n\t    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {\n\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_POSIX1E, \"posix1e\");\n\t\treturn (ret);\n\t}\n#if ARCHIVE_ACL_SUNOS_NFS4\n\telse if ((archive_acl_types(abstract_acl) &\n\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {\n\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4, \"nfs4\");\n\t}\n#endif\n\treturn (ret);\n}", "target": 1}
{"code": "log2vis_unicode (PyObject * unicode, FriBidiParType base_direction, int clean, int reordernsm)\n{\n\tPyObject *logical = NULL;\t\n\tPyObject *visual = NULL;\t\n\tPyObject *result = NULL;\t\n\tint length = PyUnicode_GET_SIZE (unicode);\n\tlogical = PyUnicode_AsUTF8String (unicode);\n\tif (logical == NULL)\n\t\tgoto cleanup;\n\tvisual = log2vis_utf8 (logical, length, base_direction, clean, reordernsm);\n\tif (visual == NULL)\n\t\tgoto cleanup;\n\tresult = PyUnicode_DecodeUTF8 (PyString_AS_STRING (visual),\n\t\t\t\t       PyString_GET_SIZE (visual), \"strict\");\n      cleanup:\n\tPy_XDECREF (logical);\n\tPy_XDECREF (visual);\n\treturn result;\n}", "target": 1}
{"code": "Map1to1(SDL_Palette * src, SDL_Palette * dst, int *identical)\n{\n    Uint8 *map;\n    int i;\n    if (identical) {\n        if (src->ncolors <= dst->ncolors) {\n            if (src == dst\n                ||\n                (SDL_memcmp\n                 (src->colors, dst->colors,\n                  src->ncolors * sizeof(SDL_Color)) == 0)) {\n                *identical = 1;\n                return (NULL);\n            }\n        }\n        *identical = 0;\n    }\n    map = (Uint8 *) SDL_malloc(src->ncolors);\n    if (map == NULL) {\n        SDL_OutOfMemory();\n        return (NULL);\n    }\n    for (i = 0; i < src->ncolors; ++i) {\n        map[i] = SDL_FindColor(dst,\n                               src->colors[i].r, src->colors[i].g,\n                               src->colors[i].b, src->colors[i].a);\n    }\n    return (map);\n}", "target": 1}
{"code": "DECLAREcpFunc(cpDecodedStrips)\n{\n\ttsize_t stripsize  = TIFFStripSize(in);\n\ttdata_t buf = _TIFFmalloc(stripsize);\n\t(void) imagewidth; (void) spp;\n\tif (buf) {\n\t\ttstrip_t s, ns = TIFFNumberOfStrips(in);\n\t\tuint32 row = 0;\n\t\t_TIFFmemset(buf, 0, stripsize);\n\t\tfor (s = 0; s < ns; s++) {\n\t\t\ttsize_t cc = (row + rowsperstrip > imagelength) ?\n\t\t\t    TIFFVStripSize(in, imagelength - row) : stripsize;\n\t\t\tif (TIFFReadEncodedStrip(in, s, buf, cc) < 0\n\t\t\t    && !ignore) {\n\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t    \"Error, can't read strip %lu\",\n\t\t\t\t    (unsigned long) s);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFWriteEncodedStrip(out, s, buf, cc) < 0) {\n\t\t\t\tTIFFError(TIFFFileName(out),\n\t\t\t\t    \"Error, can't write strip %lu\",\n\t\t\t\t    (unsigned long) s);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\trow += rowsperstrip;\n\t\t}\n\t\t_TIFFfree(buf);\n\t\treturn 1;\n\t} else {\n\t\tTIFFError(TIFFFileName(in),\n\t\t    \"Error, can't allocate memory buffer of size %lu \"\n\t\t    \"to read strips\", (unsigned long) stripsize);\n\t\treturn 0;\n\t}\nbad:\n\t_TIFFfree(buf);\n\treturn 0;\n}", "target": 1}
{"code": "static int get_msr_mce(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tu64 data;\n\tu64 mcg_cap = vcpu->arch.mcg_cap;\n\tunsigned bank_num = mcg_cap & 0xff;\n\tswitch (msr) {\n\tcase MSR_IA32_P5_MC_ADDR:\n\tcase MSR_IA32_P5_MC_TYPE:\n\t\tdata = 0;\n\t\tbreak;\n\tcase MSR_IA32_MCG_CAP:\n\t\tdata = vcpu->arch.mcg_cap;\n\t\tbreak;\n\tcase MSR_IA32_MCG_CTL:\n\t\tif (!(mcg_cap & MCG_CTL_P))\n\t\t\treturn 1;\n\t\tdata = vcpu->arch.mcg_ctl;\n\t\tbreak;\n\tcase MSR_IA32_MCG_STATUS:\n\t\tdata = vcpu->arch.mcg_status;\n\t\tbreak;\n\tdefault:\n\t\tif (msr >= MSR_IA32_MC0_CTL &&\n\t\t    msr < MSR_IA32_MC0_CTL + 4 * bank_num) {\n\t\t\tu32 offset = msr - MSR_IA32_MC0_CTL;\n\t\t\tdata = vcpu->arch.mce_banks[offset];\n\t\t\tbreak;\n\t\t}\n\t\treturn 1;\n\t}\n\t*pdata = data;\n\treturn 0;\n}", "target": 0}
{"code": "GF_Err gf_isom_use_compact_size(GF_ISOFile *movie, u32 trackNumber, Bool CompactionOn)\n{\n\tGF_TrackBox *trak;\n\tu32 i, size;\n\tGF_SampleSizeBox *stsz;\n\tGF_Err e;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media || !trak->Media->information\n\t        || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleSize)\n\t\treturn GF_ISOM_INVALID_FILE;\n\tstsz = trak->Media->information->sampleTable->SampleSize;\n\tif (!CompactionOn) {\n\t\tif (stsz->type == GF_ISOM_BOX_TYPE_STSZ) return GF_OK;\n\t\tstsz->type = GF_ISOM_BOX_TYPE_STSZ;\n\t\tstsz->sampleSize = 0;\n\t\tif (!stsz->sampleCount) return GF_OK;\n\t\tif (!stsz->sizes) return GF_OK;\n\t\tsize = stsz->sizes[0];\n\t\tfor (i=1; i<stsz->sampleCount; i++) {\n\t\t\tif (size != stsz->sizes[i]) {\n\t\t\t\tsize = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (size) {\n\t\t\tgf_free(stsz->sizes);\n\t\t\tstsz->sizes = NULL;\n\t\t\tstsz->sampleSize = size;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (stsz->type == GF_ISOM_BOX_TYPE_STZ2) return GF_OK;\n\tif (stsz->sampleSize) {\n\t\tif (stsz->sizes) gf_free(stsz->sizes);\n\t\tstsz->sizes = (u32*) gf_malloc(sizeof(u32)*stsz->sampleCount);\n\t\tif (!stsz->sizes) return GF_OUT_OF_MEM;\n\t\tmemset(stsz->sizes, stsz->sampleSize, sizeof(u32));\n\t}\n\tstsz->sampleSize = 0;\n\tstsz->type = GF_ISOM_BOX_TYPE_STZ2;\n\treturn GF_OK;\n}", "target": 1}
{"code": "static BOOL autodetect_recv_bandwidth_measure_results(rdpRdp* rdp, wStream* s,\n                                                      AUTODETECT_RSP_PDU* autodetectRspPdu)\n{\n\tBOOL success = TRUE;\n\tif (autodetectRspPdu->headerLength != 0x0E)\n\t\treturn FALSE;\n\tWLog_VRB(AUTODETECT_TAG, \"received Bandwidth Measure Results PDU\");\n\tStream_Read_UINT32(s, rdp->autodetect->bandwidthMeasureTimeDelta); \n\tStream_Read_UINT32(s, rdp->autodetect->bandwidthMeasureByteCount); \n\tif (rdp->autodetect->bandwidthMeasureTimeDelta > 0)\n\t\trdp->autodetect->netCharBandwidth = rdp->autodetect->bandwidthMeasureByteCount * 8 /\n\t\t                                    rdp->autodetect->bandwidthMeasureTimeDelta;\n\telse\n\t\trdp->autodetect->netCharBandwidth = 0;\n\tIFCALLRET(rdp->autodetect->BandwidthMeasureResults, success, rdp->context,\n\t          autodetectRspPdu->sequenceNumber);\n\treturn success;\n}", "target": 1}
{"code": "make_unix_date2(const u_char *date_ptr)\n{\n    uint32_t x, x2;\n    x = EXTRACT_LE_32BITS(date_ptr);\n    x2 = ((x & 0xFFFF) << 16) | ((x & 0xFFFF0000) >> 16);\n    return int_unix_date(x2);\n}", "target": 0}
{"code": "static void update_db_bp_intercept(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tclr_exception_intercept(svm, DB_VECTOR);\n\tclr_exception_intercept(svm, BP_VECTOR);\n\tif (svm->nmi_singlestep)\n\t\tset_exception_intercept(svm, DB_VECTOR);\n\tif (vcpu->guest_debug & KVM_GUESTDBG_ENABLE) {\n\t\tif (vcpu->guest_debug &\n\t\t    (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))\n\t\t\tset_exception_intercept(svm, DB_VECTOR);\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)\n\t\t\tset_exception_intercept(svm, BP_VECTOR);\n\t} else\n\t\tvcpu->guest_debug = 0;\n}", "target": 1}
{"code": "static int orinoco_ioctl_setwap(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tstruct sockaddr *ap_addr,\n\t\t\t\tchar *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint err = -EINPROGRESS;\t\t\n\tunsigned long flags;\n\tstatic const u8 off_addr[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\n\tstatic const u8 any_addr[] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\tif (memcmp(&ap_addr->sa_data, off_addr, ETH_ALEN) == 0 ||\n\t    memcmp(&ap_addr->sa_data, any_addr, ETH_ALEN) == 0) {\n\t\tpriv->bssid_fixed = 0;\n\t\tmemset(priv->desired_bssid, 0, ETH_ALEN);\n\t\tif (ap_addr->sa_data[0] == 0) {\n\t\t\t__orinoco_hw_set_wap(priv);\n\t\t\terr = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\tif (priv->firmware_type == FIRMWARE_TYPE_AGERE) {\n\t\tprintk(KERN_WARNING \"%s: Lucent/Agere firmware doesn't \"\n\t\t       \"support manual roaming\\n\",\n\t\t       dev->name);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tif (priv->iw_mode != NL80211_IFTYPE_STATION) {\n\t\tprintk(KERN_WARNING \"%s: Manual roaming supported only in \"\n\t\t       \"managed mode\\n\", dev->name);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tif (priv->firmware_type == FIRMWARE_TYPE_INTERSIL &&\n\t    strlen(priv->desired_essid) == 0) {\n\t\tprintk(KERN_WARNING \"%s: Desired ESSID must be set for \"\n\t\t       \"manual roaming\\n\", dev->name);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tpriv->bssid_fixed = 1;\n\tmemcpy(priv->desired_bssid, &ap_addr->sa_data, ETH_ALEN);\n out:\n\torinoco_unlock(priv, &flags);\n\treturn err;\n}", "target": 0}
{"code": "static int evdev_open_device(struct evdev *evdev)\n{\n\tint retval;\n\tretval = mutex_lock_interruptible(&evdev->mutex);\n\tif (retval)\n\t\treturn retval;\n\tif (!evdev->exist)\n\t\tretval = -ENODEV;\n\telse if (!evdev->open++) {\n\t\tretval = input_open_device(&evdev->handle);\n\t\tif (retval)\n\t\t\tevdev->open--;\n\t}\n\tmutex_unlock(&evdev->mutex);\n\treturn retval;\n}", "target": 0}
{"code": "static void copy_sec_desc(const struct cifs_ntsd *pntsd,\n\t\t\t\tstruct cifs_ntsd *pnntsd, __u32 sidsoffset)\n{\n\tstruct cifs_sid *owner_sid_ptr, *group_sid_ptr;\n\tstruct cifs_sid *nowner_sid_ptr, *ngroup_sid_ptr;\n\tpnntsd->revision = pntsd->revision;\n\tpnntsd->type = pntsd->type;\n\tpnntsd->dacloffset = cpu_to_le32(sizeof(struct cifs_ntsd));\n\tpnntsd->sacloffset = 0;\n\tpnntsd->osidoffset = cpu_to_le32(sidsoffset);\n\tpnntsd->gsidoffset = cpu_to_le32(sidsoffset + sizeof(struct cifs_sid));\n\towner_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->osidoffset));\n\tnowner_sid_ptr = (struct cifs_sid *)((char *)pnntsd + sidsoffset);\n\tcifs_copy_sid(nowner_sid_ptr, owner_sid_ptr);\n\tgroup_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->gsidoffset));\n\tngroup_sid_ptr = (struct cifs_sid *)((char *)pnntsd + sidsoffset +\n\t\t\t\t\tsizeof(struct cifs_sid));\n\tcifs_copy_sid(ngroup_sid_ptr, group_sid_ptr);\n\treturn;\n}", "target": 0}
{"code": "static int pfkey_process(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr)\n{\n\tvoid *ext_hdrs[SADB_EXT_MAX];\n\tint err;\n\tpfkey_broadcast(skb_clone(skb, GFP_KERNEL), GFP_KERNEL,\n\t\t\tBROADCAST_PROMISC_ONLY, NULL, sock_net(sk));\n\tmemset(ext_hdrs, 0, sizeof(ext_hdrs));\n\terr = parse_exthdrs(skb, hdr, ext_hdrs);\n\tif (!err) {\n\t\terr = -EOPNOTSUPP;\n\t\tif (pfkey_funcs[hdr->sadb_msg_type])\n\t\t\terr = pfkey_funcs[hdr->sadb_msg_type](sk, skb, hdr, ext_hdrs);\n\t}\n\treturn err;\n}", "target": 0}
{"code": "static struct per_transfer *del_per_transfer(struct per_transfer *per)\n{\n  struct per_transfer *n;\n  struct per_transfer *p;\n  DEBUGASSERT(transfers);\n  DEBUGASSERT(transfersl);\n  DEBUGASSERT(per);\n  n = per->next;\n  p = per->prev;\n  if(p)\n    p->next = n;\n  else\n    transfers = n;\n  if(n)\n    n->prev = p;\n  else\n    transfersl = p;\n  free(per);\n  return n;\n}", "target": 0}
{"code": "void DefaultCertValidator::updateDigestForSessionId(bssl::ScopedEVP_MD_CTX& md,\n                                                    uint8_t hash_buffer[EVP_MAX_MD_SIZE],\n                                                    unsigned hash_length) {\n  int rc;\n  if (ca_cert_ != nullptr) {\n    rc = X509_digest(ca_cert_.get(), EVP_sha256(), hash_buffer, &hash_length);\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n    RELEASE_ASSERT(hash_length == SHA256_DIGEST_LENGTH,\n                   fmt::format(\"invalid SHA256 hash length {}\", hash_length));\n    rc = EVP_DigestUpdate(md.get(), hash_buffer, hash_length);\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n  }\n  for (const auto& hash : verify_certificate_hash_list_) {\n    rc = EVP_DigestUpdate(md.get(), hash.data(),\n                          hash.size() *\n                              sizeof(std::remove_reference<decltype(hash)>::type::value_type));\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n  }\n  for (const auto& hash : verify_certificate_spki_list_) {\n    rc = EVP_DigestUpdate(md.get(), hash.data(),\n                          hash.size() *\n                              sizeof(std::remove_reference<decltype(hash)>::type::value_type));\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n  }\n}", "target": 1}
{"code": "static void wcd9335_codec_hph_mode_config(struct snd_soc_component *component,\n\t\t\t\t\t  int event, int mode)\n{\n\tswitch (mode) {\n\tcase CLS_H_LP:\n\t\twcd9335_codec_hph_lp_config(component, event);\n\t\tbreak;\n\tcase CLS_H_LOHIFI:\n\t\twcd9335_codec_hph_lohifi_config(component, event);\n\t\tbreak;\n\tcase CLS_H_HIFI:\n\t\twcd9335_codec_hph_hifi_config(component, event);\n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "prefix_code(uint8_t *data, size_t size)\n{\n\tif (size > 3 && data[0] == ' ' && data[1] == ' '\n\t\t&& data[2] == ' ' && data[3] == ' ') return 4;\n\treturn 0;\n}", "target": 0}
{"code": "init_ctx_reselect(OM_uint32 *minor_status, spnego_gss_ctx_id_t sc,\n\t\t  OM_uint32 acc_negState, gss_OID supportedMech,\n\t\t  gss_buffer_t *responseToken, gss_buffer_t *mechListMIC,\n\t\t  OM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 tmpmin;\n\tsize_t i;\n\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n\t\t\t       GSS_C_NO_BUFFER);\n\tfor (i = 0; i < sc->mech_set->count; i++) {\n\t\tif (g_OID_equal(supportedMech, &sc->mech_set->elements[i]))\n\t\t\tbreak;\n\t}\n\tif (i == sc->mech_set->count)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tsc->internal_mech = &sc->mech_set->elements[i];\n\tif (acc_negState != REQUEST_MIC)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tsc->mech_complete = 0;\n\tsc->mic_reqd = 1;\n\t*negState = REQUEST_MIC;\n\t*tokflag = CONT_TOKEN_SEND;\n\treturn GSS_S_CONTINUE_NEEDED;\n}", "target": 0}
{"code": "static void coerce_reg_to_size(struct bpf_reg_state *reg, int size)\n{\n\tu64 mask;\n\treg->var_off = tnum_cast(reg->var_off, size);\n\tmask = ((u64)1 << (size * 8)) - 1;\n\tif ((reg->umin_value & ~mask) == (reg->umax_value & ~mask)) {\n\t\treg->umin_value &= mask;\n\t\treg->umax_value &= mask;\n\t} else {\n\t\treg->umin_value = 0;\n\t\treg->umax_value = mask;\n\t}\n\treg->smin_value = reg->umin_value;\n\treg->smax_value = reg->umax_value;\n\tif (size >= 4)\n\t\treturn;\n\t__reg_combine_64_into_32(reg);\n}", "target": 0}
{"code": "njs_string_to_number(const njs_value_t *value, njs_bool_t parse_float)\n{\n    double             num;\n    njs_bool_t         minus;\n    const u_char       *p, *start, *end;\n    njs_string_prop_t  string;\n    const size_t  infinity = njs_length(\"Infinity\");\n    (void) njs_string_trim(value, &string, NJS_TRIM_START);\n    p = string.start;\n    end = p + string.size;\n    if (p == end) {\n        return parse_float ? NAN : 0.0;\n    }\n    minus = 0;\n    if (*p == '+') {\n        p++;\n    } else if (*p == '-') {\n        p++;\n        minus = 1;\n    }\n    if (p == end) {\n        return NAN;\n    }\n    if (!parse_float\n        && p + 2 < end && p[0] == '0' && (p[1] == 'x' || p[1] == 'X'))\n    {\n        p += 2;\n        num = njs_number_hex_parse(&p, end, 0);\n    } else {\n        start = p;\n        num = njs_number_dec_parse(&p, end, 0);\n        if (p == start) {\n            if (p + infinity > end || memcmp(p, \"Infinity\", infinity) != 0) {\n                return NAN;\n            }\n            num = INFINITY;\n            p += infinity;\n        }\n    }\n    if (!parse_float) {\n        while (p < end) {\n            if (*p != ' ' && *p != '\\t') {\n                return NAN;\n            }\n            p++;\n        }\n    }\n    return minus ? -num : num;\n}", "target": 0}
{"code": "gif_read_image(FILE       *fp,\t\t\n\t       image_t    *img,\t\t\n\t       gif_cmap_t cmap,\t\t\n\t       int        interlace,\t\n\t       int        transparent)\t\n{\n  uchar\t\tcode_size,\t\t\n\t\t*temp;\t\t\t\n  int\t\txpos,\t\t\t\n\t\typos,\t\t\t\n\t\tpass;\t\t\t\n  int\t\tpixel;\t\t\t\n  static int\txpasses[4] = { 8, 8, 4, 2 },\n\t\typasses[5] = { 0, 4, 2, 1, 999999 };\n  xpos      = 0;\n  ypos      = 0;\n  pass      = 0;\n  code_size = (uchar)getc(fp);\n  if (code_size > 12)\n  {\n    progress_error(HD_ERROR_READ_ERROR, \"Bad GIF file \\\"%s\\\" - invalid code size %d.\", img->filename, code_size);\n    return (-1);\n  }\n  if (gif_read_lzw(fp, 1, code_size) < 0)\n    return (-1);\n  temp = img->pixels;\n  while ((pixel = gif_read_lzw(fp, 0, code_size)) >= 0 && pixel < 256)\n  {\n    temp[0] = cmap[pixel][0];\n    if (img->depth > 1)\n    {\n      temp[1] = cmap[pixel][1];\n      temp[2] = cmap[pixel][2];\n    }\n    if (pixel == transparent)\n      image_set_mask(img, xpos, ypos);\n    xpos ++;\n    temp += img->depth;\n    if (xpos == img->width)\n    {\n      xpos = 0;\n      if (interlace)\n      {\n        ypos += xpasses[pass];\n        temp += (xpasses[pass] - 1) * img->width * img->depth;\n        if (ypos >= img->height)\n\t{\n\t  pass ++;\n          ypos = ypasses[pass];\n          temp = img->pixels + ypos * img->width * img->depth;\n\t}\n      }\n      else\n\typos ++;\n    }\n    if (ypos >= img->height)\n      break;\n  }\n  return (0);\n}", "target": 0}
{"code": "WandExport double *DrawGetStrokeDashArray(const DrawingWand *wand,\n  size_t *number_elements)\n{\n  double\n    *dasharray;\n  register const double\n    *p;\n  register double\n    *q;\n  register ssize_t\n    i;\n  size_t\n    n;\n  assert(wand != (const DrawingWand *) NULL);\n  assert(wand->signature == MagickWandSignature);\n  if (wand->debug != MagickFalse)\n    (void) LogMagickEvent(WandEvent,GetMagickModule(),\"%s\",wand->name);\n  assert(number_elements != (size_t *) NULL);\n  n=0;\n  p=CurrentContext->dash_pattern;\n  if (p != (const double *) NULL)\n    while (fabs(*p++) >= MagickEpsilon)\n      n++;\n  *number_elements=n;\n  dasharray=(double *) NULL;\n  if (n != 0)\n    {\n      dasharray=(double *) AcquireQuantumMemory((size_t) n+1UL,\n        sizeof(*dasharray));\n      p=CurrentContext->dash_pattern;\n      q=dasharray;\n      for (i=0; i < (ssize_t) n; i++)\n        *q++=(*p++);\n      *q=0.0;\n    }\n  return(dasharray);\n}", "target": 1}
{"code": "snmp_mib_find_next(uint32_t *oid)\n{\n  snmp_mib_resource_t *resource;\n  resource = NULL;\n  for(resource = list_head(snmp_mib);\n      resource; resource = resource->next) {\n    if(snmp_oid_cmp_oid(resource->oid, oid) > 0) {\n      return resource;\n    }\n  }\n  return NULL;\n}", "target": 1}
{"code": "  explicit SparseCrossOp(OpKernelConstruction* context) : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_buckets\", &num_buckets_));\n    int64 signed_hash_key_;\n    OP_REQUIRES_OK(context, context->GetAttr(\"hash_key\", &signed_hash_key_));\n    hash_key_ = static_cast<uint64>(signed_hash_key_);\n    OP_REQUIRES_OK(context, context->GetAttr(\"internal_type\", &internal_type_));\n  }", "target": 0}
{"code": "static void ahci_irq_lower(AHCIState *s, AHCIDevice *dev)\n{\n    DeviceState *dev_state = s->container;\n    PCIDevice *pci_dev = (PCIDevice *) object_dynamic_cast(OBJECT(dev_state),\n                                                           TYPE_PCI_DEVICE);\n    DPRINTF(0, \"lower irq\\n\");\n    if (!pci_dev || !msi_enabled(pci_dev)) {\n        qemu_irq_lower(s->irq);\n    }\n}", "target": 0}
{"code": "  int DoWrite(WriteWrap* w,\n              uv_buf_t* bufs,\n              size_t count,\n              uv_stream_t* send_handle) override {\n    return UV_ENOSYS;  \n  }", "target": 1}
{"code": "static inline void note_cmpxchg_failure(const char *n,\n\t\tconst struct kmem_cache *s, unsigned long tid)\n{\n#ifdef SLUB_DEBUG_CMPXCHG\n\tunsigned long actual_tid = __this_cpu_read(s->cpu_slab->tid);\n\tpr_info(\"%s %s: cmpxchg redo \", n, s->name);\n#ifdef CONFIG_PREEMPTION\n\tif (tid_to_cpu(tid) != tid_to_cpu(actual_tid))\n\t\tpr_warn(\"due to cpu change %d -> %d\\n\",\n\t\t\ttid_to_cpu(tid), tid_to_cpu(actual_tid));\n\telse\n#endif\n\tif (tid_to_event(tid) != tid_to_event(actual_tid))\n\t\tpr_warn(\"due to cpu running other code. Event %ld->%ld\\n\",\n\t\t\ttid_to_event(tid), tid_to_event(actual_tid));\n\telse\n\t\tpr_warn(\"for unknown reason: actual=%lx was=%lx target=%lx\\n\",\n\t\t\tactual_tid, tid, next_tid(tid));\n#endif\n\tstat(s, CMPXCHG_DOUBLE_CPU_FAIL);\n}", "target": 0}
{"code": "static int ion_handle_put_nolock(struct ion_handle *handle)\n{\n\tint ret;\n\tret = kref_put(&handle->ref, ion_handle_destroy);\n\treturn ret;\n}", "target": 0}
{"code": "static int rds_recv_track_latency(struct rds_sock *rs, char __user *optval,\n\t\t\t\t  int optlen)\n{\n\tstruct rds_rx_trace_so trace;\n\tint i;\n\tif (optlen != sizeof(struct rds_rx_trace_so))\n\t\treturn -EFAULT;\n\tif (copy_from_user(&trace, optval, sizeof(trace)))\n\t\treturn -EFAULT;\n\trs->rs_rx_traces = trace.rx_traces;\n\tfor (i = 0; i < rs->rs_rx_traces; i++) {\n\t\tif (trace.rx_trace_pos[i] > RDS_MSG_RX_DGRAM_TRACE_MAX) {\n\t\t\trs->rs_rx_traces = 0;\n\t\t\treturn -EFAULT;\n\t\t}\n\t\trs->rs_rx_trace[i] = trace.rx_trace_pos[i];\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input_indices_in = context->input(0);\n    const Tensor& input_shape_in = context->input(1);\n    OP_REQUIRES(context, TensorShapeUtils::IsMatrix(input_indices_in.shape()),\n                errors::InvalidArgument(\"Input must be a matrix.\"));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(input_shape_in.shape()),\n                errors::InvalidArgument(\"Input shape must be a vector.\"));\n    OP_REQUIRES(context,\n                input_indices_in.dim_size(1) == input_shape_in.dim_size(0),\n                errors::InvalidArgument(\n                    \"Input tensor rank must match input shape length.\"));\n    ReshapeSparseTensor<Device>(context, context->input(0), context->input(1),\n                                context->input(2), 0 ,\n                                1 );\n  }", "target": 0}
{"code": "void arch_pick_mmap_layout(struct mm_struct *mm)\n{\n\tunsigned long random_factor = 0UL;\n\tif (current->flags & PF_RANDOMIZE)\n\t\trandom_factor = arch_mmap_rnd();\n\tmm->mmap_legacy_base = mmap_legacy_base(random_factor);\n\tif (mmap_is_legacy()) {\n\t\tmm->mmap_base = mm->mmap_legacy_base;\n\t\tmm->get_unmapped_area = arch_get_unmapped_area;\n\t} else {\n\t\tmm->mmap_base = mmap_base(random_factor);\n\t\tmm->get_unmapped_area = arch_get_unmapped_area_topdown;\n\t}\n}", "target": 1}
{"code": "static void ext2_put_super (struct super_block * sb)\n{\n\tint db_count;\n\tint i;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tdquot_disable(sb, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n\text2_xattr_put_super(sb);\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tstruct ext2_super_block *es = sbi->s_es;\n\t\tspin_lock(&sbi->s_lock);\n\t\tes->s_state = cpu_to_le16(sbi->s_mount_state);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\tdb_count = sbi->s_gdb_count;\n\tfor (i = 0; i < db_count; i++)\n\t\tif (sbi->s_group_desc[i])\n\t\t\tbrelse (sbi->s_group_desc[i]);\n\tkfree(sbi->s_group_desc);\n\tkfree(sbi->s_debts);\n\tpercpu_counter_destroy(&sbi->s_freeblocks_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tbrelse (sbi->s_sbh);\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\n\tkfree(sbi);\n}", "target": 1}
{"code": "update_bar_address(struct vmctx *ctx, struct pci_vdev *dev, uint64_t addr,\n\tint idx, int type, bool ignore_reg_unreg)\n{\n\tbool decode = false;\n\tuint64_t orig_addr = dev->bar[idx].addr;\n\tif (!ignore_reg_unreg) {\n\t\tif (dev->bar[idx].type == PCIBAR_IO)\n\t\t\tdecode = porten(dev);\n\t\telse\n\t\t\tdecode = memen(dev);\n\t}\n\tif (decode)\n\t\tunregister_bar(dev, idx);\n\tswitch (type) {\n\tcase PCIBAR_IO:\n\tcase PCIBAR_MEM32:\n\t\tdev->bar[idx].addr = addr;\n\t\tbreak;\n\tcase PCIBAR_MEM64:\n\t\tdev->bar[idx].addr &= ~0xffffffffUL;\n\t\tdev->bar[idx].addr |= addr;\n\t\tbreak;\n\tcase PCIBAR_MEMHI64:\n\t\tdev->bar[idx].addr &= 0xffffffff;\n\t\tdev->bar[idx].addr |= addr;\n\t\tbreak;\n\tdefault:\n\t\tassert(0);\n\t}\n\tif (decode)\n\t\tregister_bar(dev, idx);\n\tif (dev->dev_ops->vdev_update_bar_map && decode)\n\t\tdev->dev_ops->vdev_update_bar_map(ctx, dev, idx, orig_addr);\n}", "target": 1}
{"code": "static int is_printable(char p)\n{\n\tif ((p >= 'a' && p <= 'z') || (p >= 'A' && p <= 'Z') ||\n\t    (p >= '0' && p <= '9') || p == ' ' || p == '(' || p == ')' ||\n\t    p == '+' || p == ',' || p == '-' || p == '.' || p == '/' ||\n\t    p == ':' || p == '=' || p == '?')\n\t\treturn 1;\n\treturn 0;\n}", "target": 0}
{"code": "static void vgacon_flush_scrollback(struct vc_data *c)\n{\n\tsize_t size = CONFIG_VGACON_SOFT_SCROLLBACK_SIZE * 1024;\n\tvgacon_scrollback_reset(c->vc_num, size);\n}", "target": 1}
{"code": "static int ptrace_signal(int signr, siginfo_t *info,\n\t\t\t struct pt_regs *regs, void *cookie)\n{\n\tif (!task_ptrace(current))\n\t\treturn signr;\n\tptrace_signal_deliver(regs, cookie);\n\tptrace_stop(signr, 0, info);\n\tsignr = current->exit_code;\n\tif (signr == 0)\n\t\treturn signr;\n\tcurrent->exit_code = 0;\n\tif (signr != info->si_signo) {\n\t\tinfo->si_signo = signr;\n\t\tinfo->si_errno = 0;\n\t\tinfo->si_code = SI_USER;\n\t\tinfo->si_pid = task_pid_vnr(current->parent);\n\t\tinfo->si_uid = task_uid(current->parent);\n\t}\n\tif (sigismember(&current->blocked, signr)) {\n\t\tspecific_send_sig_info(signr, info, current);\n\t\tsignr = 0;\n\t}\n\treturn signr;\n}", "target": 0}
{"code": "PHP_METHOD(snmp, setSecurity)\n{\n\tphp_snmp_object *snmp_object;\n\tzval *object = getThis();\n\tchar *a1 = \"\", *a2 = \"\", *a3 = \"\", *a4 = \"\", *a5 = \"\", *a6 = \"\", *a7 = \"\";\n\tsize_t a1_len = 0, a2_len = 0, a3_len = 0, a4_len = 0, a5_len = 0, a6_len = 0, a7_len = 0;\n\tint argc = ZEND_NUM_ARGS();\n\tsnmp_object = Z_SNMP_P(object);\n\tif (zend_parse_parameters(argc, \"s|ssssss\", &a1, &a1_len, &a2, &a2_len, &a3, &a3_len,\n\t\t&a4, &a4_len, &a5, &a5_len, &a6, &a6_len, &a7, &a7_len) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tif (netsnmp_session_set_security(snmp_object->session, a1, a2, a3, a4, a5, a6, a7)) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}", "target": 0}
{"code": "find_jws(struct tang_keys_info* tki, const char* thp)\n{\n    if (!tki) {\n        return NULL;\n    }\n    if (thp == NULL) {\n        json_auto_t* jws = jwk_sign(tki->m_payload, tki->m_sign);\n        if (!jws) {\n            return NULL;\n        }\n        return json_incref(jws);\n    }\n    return find_by_thp(tki, thp);\n}", "target": 1}
{"code": "snmp_oid_copy(uint32_t *dst, uint32_t *src)\n{\n  uint8_t i;\n  i = 0;\n  while(src[i] != ((uint32_t)-1)) {\n    dst[i] = src[i];\n    i++;\n  }\n  dst[i] = src[i];\n}", "target": 1}
{"code": "int __usb_get_extra_descriptor(char *buffer, unsigned size,\n\t\t\t       unsigned char type, void **ptr)\n{\n\tstruct usb_descriptor_header *header;\n\twhile (size >= sizeof(struct usb_descriptor_header)) {\n\t\theader = (struct usb_descriptor_header *)buffer;\n\t\tif (header->bLength < 2) {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"%s: bogus descriptor, type %d length %d\\n\",\n\t\t\t\tusbcore_name,\n\t\t\t\theader->bDescriptorType,\n\t\t\t\theader->bLength);\n\t\t\treturn -1;\n\t\t}\n\t\tif (header->bDescriptorType == type) {\n\t\t\t*ptr = header;\n\t\t\treturn 0;\n\t\t}\n\t\tbuffer += header->bLength;\n\t\tsize -= header->bLength;\n\t}\n\treturn -1;\n}", "target": 1}
{"code": "static void coroutine_fn mirror_wait_on_conflicts(MirrorOp *self,\n                                                  MirrorBlockJob *s,\n                                                  uint64_t offset,\n                                                  uint64_t bytes)\n{\n    uint64_t self_start_chunk = offset / s->granularity;\n    uint64_t self_end_chunk = DIV_ROUND_UP(offset + bytes, s->granularity);\n    uint64_t self_nb_chunks = self_end_chunk - self_start_chunk;\n    while (find_next_bit(s->in_flight_bitmap, self_end_chunk,\n                         self_start_chunk) < self_end_chunk &&\n           s->ret >= 0)\n    {\n        MirrorOp *op;\n        QTAILQ_FOREACH(op, &s->ops_in_flight, next) {\n            uint64_t op_start_chunk = op->offset / s->granularity;\n            uint64_t op_nb_chunks = DIV_ROUND_UP(op->offset + op->bytes,\n                                                 s->granularity) -\n                                    op_start_chunk;\n            if (op == self) {\n                continue;\n            }\n            if (ranges_overlap(self_start_chunk, self_nb_chunks,\n                               op_start_chunk, op_nb_chunks))\n            {\n                qemu_co_queue_wait(&op->waiting_requests, NULL);\n                break;\n            }\n        }\n    }\n}", "target": 1}
{"code": "int lxc_switch_uid_gid(uid_t uid, gid_t gid)\n{\n\tif (setgid(gid) < 0) {\n\t\tSYSERROR(\"Failed to switch to gid %d.\", gid);\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Switched to gid %d.\", gid);\n\tif (setuid(uid) < 0) {\n\t\tSYSERROR(\"Failed to switch to uid %d.\", uid);\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Switched to uid %d.\", uid);\n\treturn 0;\n}", "target": 0}
{"code": "int inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !inode_capable(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !inode_capable(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !inode_capable(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "const u8 *tcp_parse_md5sig_option(const struct tcphdr *th)\n{\n\tint length = (th->doff << 2) - sizeof(*th);\n\tconst u8 *ptr = (const u8 *)(th + 1);\n\tif (length < TCPOLEN_MD5SIG)\n\t\treturn NULL;\n\twhile (length > 0) {\n\t\tint opcode = *ptr++;\n\t\tint opsize;\n\t\tswitch (opcode) {\n\t\tcase TCPOPT_EOL:\n\t\t\treturn NULL;\n\t\tcase TCPOPT_NOP:\n\t\t\tlength--;\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\topsize = *ptr++;\n\t\t\tif (opsize < 2 || opsize > length)\n\t\t\t\treturn NULL;\n\t\t\tif (opcode == TCPOPT_MD5SIG)\n\t\t\t\treturn opsize == TCPOLEN_MD5SIG ? ptr : NULL;\n\t\t}\n\t\tptr += opsize - 2;\n\t\tlength -= opsize;\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint rc, xprefix;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\txprefix = JFFS2_XPREFIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tumode_t mode = inode->i_mode;\n\t\t\trc = posix_acl_equiv_mode(acl, &mode);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\t\t\tif (inode->i_mode != mode) {\n\t\t\t\tstruct iattr attr;\n\t\t\t\tattr.ia_valid = ATTR_MODE | ATTR_CTIME;\n\t\t\t\tattr.ia_mode = mode;\n\t\t\t\tattr.ia_ctime = CURRENT_TIME_SEC;\n\t\t\t\trc = jffs2_do_setattr(inode, &attr);\n\t\t\t\tif (rc < 0)\n\t\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tif (rc == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\txprefix = JFFS2_XPREFIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\trc = __jffs2_set_acl(inode, xprefix, acl);\n\tif (!rc)\n\t\tset_cached_acl(inode, type, acl);\n\treturn rc;\n}", "target": 1}
{"code": " GetStartupData(HANDLE pipe, STARTUP_DATA *sud)\n {\n     size_t size, len;\n    BOOL ret = FALSE;\n     WCHAR *data = NULL;\n     DWORD bytes, read;\n    bytes = PeekNamedPipeAsync(pipe, 1, &exit_event);\n    if (bytes == 0)\n     {\n         MsgToEventLog(M_SYSERR, TEXT(\"PeekNamedPipeAsync failed\"));\n         ReturnLastError(pipe, L\"PeekNamedPipeAsync\");\n        goto out;\n     }\n     size = bytes / sizeof(*data);\n     if (size == 0)\n     {\n         MsgToEventLog(M_SYSERR, TEXT(\"malformed startup data: 1 byte received\"));\n         ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n     }\n     data = malloc(bytes);\n     if (data == NULL)\n     {\n         MsgToEventLog(M_SYSERR, TEXT(\"malloc failed\"));\n         ReturnLastError(pipe, L\"malloc\");\n        goto out;\n     }\n     read = ReadPipeAsync(pipe, data, bytes, 1, &exit_event);\n     if (bytes != read)\n     {\n         MsgToEventLog(M_SYSERR, TEXT(\"ReadPipeAsync failed\"));\n         ReturnLastError(pipe, L\"ReadPipeAsync\");\n        goto out;\n     }\n     if (data[size - 1] != 0)\n     {\n         MsgToEventLog(M_ERR, TEXT(\"Startup data is not NULL terminated\"));\n         ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n     }\n     sud->directory = data;\n    len = wcslen(sud->directory) + 1;\n    size -= len;\n    if (size <= 0)\n     {\n         MsgToEventLog(M_ERR, TEXT(\"Startup data ends at working directory\"));\n         ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n     }\n     sud->options = sud->directory + len;\n    len = wcslen(sud->options) + 1;\n    size -= len;\n    if (size <= 0)\n     {\n         MsgToEventLog(M_ERR, TEXT(\"Startup data ends at command line options\"));\n         ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n     }\n     sud->std_input = sud->options + len;\n    data = NULL; \n    ret = TRUE;\nout:\n     free(data);\n    return ret;\n }", "target": 1}
{"code": "struct sctp_chunk *sctp_make_cookie_ack(const struct sctp_association *asoc,\n\t\t\t\t\tconst struct sctp_chunk *chunk)\n{\n\tstruct sctp_chunk *retval;\n\tretval = sctp_make_control(asoc, SCTP_CID_COOKIE_ACK, 0, 0, GFP_ATOMIC);\n\tif (retval && chunk)\n\t\tretval->transport = chunk->transport;\n\treturn retval;\n}", "target": 0}
{"code": "static void virtio_blk_handle_write(VirtIOBlockReq *req, MultiReqBuffer *mrb)\n{\n    BlockRequest *blkreq;\n    uint64_t sector;\n    sector = ldq_p(&req->out->sector);\n    trace_virtio_blk_handle_write(req, sector, req->qiov.size / 512);\n    if (sector & req->dev->sector_mask) {\n        virtio_blk_rw_complete(req, -EIO);\n        return;\n    }\n    if (mrb->num_writes == 32) {\n        virtio_submit_multiwrite(req->dev->bs, mrb);\n    }\n    blkreq = &mrb->blkreq[mrb->num_writes];\n    blkreq->sector = sector;\n    blkreq->nb_sectors = req->qiov.size / BDRV_SECTOR_SIZE;\n    blkreq->qiov = &req->qiov;\n    blkreq->cb = virtio_blk_rw_complete;\n    blkreq->opaque = req;\n    blkreq->error = 0;\n    mrb->num_writes++;\n}", "target": 1}
{"code": "static void wasm_sec_free(RBinWasmSection *sec) {\n\tif (sec) {\n\t\tfree (sec->name);\n\t\tfree (sec);\n\t}\n}", "target": 0}
{"code": "int quicklistPushHead(quicklist *quicklist, void *value, size_t sz) {\n    quicklistNode *orig_head = quicklist->head;\n    assert(sz < UINT32_MAX); \n    if (likely(\n            _quicklistNodeAllowInsert(quicklist->head, quicklist->fill, sz))) {\n        quicklist->head->zl =\n            ziplistPush(quicklist->head->zl, value, sz, ZIPLIST_HEAD);\n        quicklistNodeUpdateSz(quicklist->head);\n    } else {\n        quicklistNode *node = quicklistCreateNode();\n        node->zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);\n        quicklistNodeUpdateSz(node);\n        _quicklistInsertNodeBefore(quicklist, quicklist->head, node);\n    }\n    quicklist->count++;\n    quicklist->head->count++;\n    return (orig_head != quicklist->head);\n}", "target": 0}
{"code": "static int ssi_sd_load(QEMUFile *f, void *opaque, int version_id)\n{\n    SSISlave *ss = SSI_SLAVE(opaque);\n    ssi_sd_state *s = (ssi_sd_state *)opaque;\n    int i;\n    if (version_id != 1)\n        return -EINVAL;\n    s->mode = qemu_get_be32(f);\n    s->cmd = qemu_get_be32(f);\n    for (i = 0; i < 4; i++)\n        s->cmdarg[i] = qemu_get_be32(f);\n    for (i = 0; i < 5; i++)\n        s->response[i] = qemu_get_be32(f);\n    s->arglen = qemu_get_be32(f);\n    s->response_pos = qemu_get_be32(f);\n    s->stopping = qemu_get_be32(f);\n    ss->cs = qemu_get_be32(f);\n    return 0;\n}", "target": 1}
{"code": "static BOOL gdi_Bitmap_Decompress(rdpContext* context, rdpBitmap* bitmap,\n                                  const BYTE* pSrcData, UINT32 DstWidth, UINT32 DstHeight,\n                                  UINT32 bpp, UINT32 length, BOOL compressed,\n                                  UINT32 codecId)\n{\n\tUINT32 SrcSize = length;\n\trdpGdi* gdi = context->gdi;\n\tbitmap->compressed = FALSE;\n\tbitmap->format = gdi->dstFormat;\n\tbitmap->length = DstWidth * DstHeight * GetBytesPerPixel(bitmap->format);\n\tbitmap->data = (BYTE*) _aligned_malloc(bitmap->length, 16);\n\tif (!bitmap->data)\n\t\treturn FALSE;\n\tif (compressed)\n\t{\n\t\tif (bpp < 32)\n\t\t{\n\t\t\tif (!interleaved_decompress(context->codecs->interleaved,\n\t\t\t                            pSrcData, SrcSize,\n\t\t\t                            DstWidth, DstHeight,\n\t\t\t                            bpp,\n\t\t\t                            bitmap->data, bitmap->format,\n\t\t\t                            0, 0, 0, DstWidth, DstHeight,\n\t\t\t                            &gdi->palette))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!planar_decompress(context->codecs->planar, pSrcData, SrcSize,\n\t\t\t                       DstWidth, DstHeight,\n\t\t\t                       bitmap->data, bitmap->format, 0, 0, 0,\n\t\t\t                       DstWidth, DstHeight, TRUE))\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tconst UINT32 SrcFormat = gdi_get_pixel_format(bpp);\n\t\tconst size_t sbpp = GetBytesPerPixel(SrcFormat);\n\t\tconst size_t dbpp = GetBytesPerPixel(bitmap->format);\n\t\tif ((sbpp == 0) || (dbpp == 0))\n\t\t\treturn FALSE;\n\t\telse\n\t\t{\n\t\t\tconst size_t dstSize = SrcSize * dbpp / sbpp;\n\t\t\tif (dstSize  < bitmap->length)\n\t\t\t\treturn FALSE;\n\t\t}\n\t\tif (!freerdp_image_copy(bitmap->data, bitmap->format, 0, 0, 0,\n\t\t                        DstWidth, DstHeight, pSrcData, SrcFormat,\n\t\t                        0, 0, 0, &gdi->palette, FREERDP_FLIP_VERTICAL))\n\t\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "separate_nextcmd(exarg_T *eap, int keep_backslash)\n{\n    char_u\t*p;\n#ifdef FEAT_QUICKFIX\n    p = skip_grep_pat(eap);\n#else\n    p = eap->arg;\n#endif\n    for ( ; *p; MB_PTR_ADV(p))\n    {\n\tif (*p == Ctrl_V)\n\t{\n\t    if ((eap->argt & (EX_CTRLV | EX_XFILE)) || keep_backslash)\n\t\t++p;\t\t\n\t    else\n\t\tSTRMOVE(p, p + 1);\n\t    if (*p == NUL)\t\t\n\t\tbreak;\n\t}\n#ifdef FEAT_EVAL\n\telse if (p[0] == '`' && p[1] == '=' && (eap->argt & EX_XFILE))\n\t{\n\t    p += 2;\n\t    (void)skip_expr(&p, NULL);\n\t    if (*p == NUL)\t\t\n\t\tbreak;\n\t}\n#endif\n\telse if ((*p == '\"'\n#ifdef FEAT_EVAL\n\t\t    && !in_vim9script()\n#endif\n\t\t    && !(eap->argt & EX_NOTRLCOM)\n\t\t    && ((eap->cmdidx != CMD_at && eap->cmdidx != CMD_star)\n\t\t\t\t\t\t\t      || p != eap->arg)\n\t\t    && (eap->cmdidx != CMD_redir\n\t\t\t\t\t || p != eap->arg + 1 || p[-1] != '@'))\n#ifdef FEAT_EVAL\n\t\t|| (*p == '#'\n\t\t    && in_vim9script()\n\t\t    && !(eap->argt & EX_NOTRLCOM)\n\t\t    && p > eap->cmd && VIM_ISWHITE(p[-1]))\n#endif\n\t\t|| *p == '|' || *p == '\\n')\n\t{\n\t    if ((vim_strchr(p_cpo, CPO_BAR) == NULL\n\t\t\t      || !(eap->argt & EX_CTRLV)) && *(p - 1) == '\\\\')\n\t    {\n\t\tif (!keep_backslash)\n\t\t{\n\t\t    STRMOVE(p - 1, p);\t\n\t\t    --p;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\teap->nextcmd = check_nextcmd(p);\n\t\t*p = NUL;\n\t\tbreak;\n\t    }\n\t}\n    }\n    if (!(eap->argt & EX_NOTRLCOM))\t\n\tdel_trailing_spaces(eap->arg);\n}", "target": 0}
{"code": "int Http2Stream::DoWrite(WriteWrap* req_wrap,\n                         uv_buf_t* bufs,\n                         size_t nbufs,\n                         uv_stream_t* send_handle) {\n  CHECK_NULL(send_handle);\n  Http2Scope h2scope(this);\n  if (!IsWritable() || IsDestroyed()) {\n    req_wrap->Done(UV_EOF);\n    return 0;\n  }\n  Debug(this, \"queuing %d buffers to send\", id_, nbufs);\n  for (size_t i = 0; i < nbufs; ++i) {\n    queue_.emplace(nghttp2_stream_write {\n      i == nbufs - 1 ? req_wrap : nullptr,\n      bufs[i]\n    });\n    IncrementAvailableOutboundLength(bufs[i].len);\n  }\n  CHECK_NE(nghttp2_session_resume_data(**session_, id_), NGHTTP2_ERR_NOMEM);\n  return 0;\n}", "target": 1}
{"code": "static const char *typeString(ut32 n, int *bits) {\n\t*bits = 32;\n\tif (n == 12) { \n\t\treturn \"arm\";\n\t}\n\tif (n == 0x0100000c) { \n\t\t*bits = 64;\n\t\treturn \"arm\";\n\t}\n\tif (n == 0x0200000c) { \n\t\t*bits = 64;\n\t\treturn \"arm\";\n\t}\n\treturn \"x86\";\n}", "target": 0}
{"code": "int LibRaw::subtract_black()\n{\n\tCHECK_ORDER_LOW(LIBRAW_PROGRESS_RAW2_IMAGE);\n\ttry {\n    if(!is_phaseone_compressed() && (C.cblack[0] || C.cblack[1] || C.cblack[2] || C.cblack[3]))\n        {\n#define BAYERC(row,col,c) imgdata.image[((row) >> IO.shrink)*S.iwidth + ((col) >> IO.shrink)][c] \n            int cblk[4],i;\n            for(i=0;i<4;i++)\n                cblk[i] = C.cblack[i];\n            int size = S.iheight * S.iwidth;\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n#define MAX(a,b) ((a) > (b) ? (a) : (b))\n#define LIM(x,min,max) MAX(min,MIN(x,max))\n#define CLIP(x) LIM(x,0,65535)\n            for(i=0; i< size*4; i++)\n              {\n                int val = imgdata.image[0][i];\n                val -= cblk[i & 3];\n                imgdata.image[0][i] = CLIP(val);\n                if(C.data_maximum < val) C.data_maximum = val;\n              }\n#undef MIN\n#undef MAX\n#undef LIM\n#undef CLIP\n            C.maximum -= C.black;\n            ZERO(C.cblack);\n            C.black = 0;\n#undef BAYERC\n        }\n    else\n        {\n          int idx;\n          ushort *p = (ushort*)imgdata.image;\n          C.data_maximum = 0;\n          for(idx=0;idx<S.iheight*S.iwidth*4;idx++)\n            if(C.data_maximum < p[idx]) C.data_maximum = p[idx];\n        }\n\t\treturn 0;\n\t}\n\tcatch ( LibRaw_exceptions err) {\n\t\tEXCEPTION_HANDLER(err);\n\t}\n}", "target": 1}
{"code": "static unsigned long __init init_range_memory_mapping(\n\t\t\t\t\t   unsigned long r_start,\n\t\t\t\t\t   unsigned long r_end)\n{\n\tunsigned long start_pfn, end_pfn;\n\tunsigned long mapped_ram_size = 0;\n\tint i;\n\tfor_each_mem_pfn_range(i, MAX_NUMNODES, &start_pfn, &end_pfn, NULL) {\n\t\tu64 start = clamp_val(PFN_PHYS(start_pfn), r_start, r_end);\n\t\tu64 end = clamp_val(PFN_PHYS(end_pfn), r_start, r_end);\n\t\tif (start >= end)\n\t\t\tcontinue;\n\t\tcan_use_brk_pgt = max(start, (u64)pgt_buf_end<<PAGE_SHIFT) >=\n\t\t\t\t    min(end, (u64)pgt_buf_top<<PAGE_SHIFT);\n\t\tinit_memory_mapping(start, end);\n\t\tmapped_ram_size += end - start;\n\t\tcan_use_brk_pgt = true;\n\t}\n\treturn mapped_ram_size;\n}", "target": 0}
{"code": "void nfcmrvl_nci_unregister_dev(struct nfcmrvl_private *priv)\n{\n\tstruct nci_dev *ndev = priv->ndev;\n\tif (priv->ndev->nfc_dev->fw_download_in_progress)\n\t\tnfcmrvl_fw_dnld_abort(priv);\n\tnfcmrvl_fw_dnld_deinit(priv);\n\tif (gpio_is_valid(priv->config.reset_n_io))\n\t\tgpio_free(priv->config.reset_n_io);\n\tnci_unregister_device(ndev);\n\tnci_free_device(ndev);\n\tkfree(priv);\n}", "target": 1}
{"code": "static int kvm_ioctl_create_device(struct kvm *kvm,\n\t\t\t\t   struct kvm_create_device *cd)\n{\n\tstruct kvm_device_ops *ops = NULL;\n\tstruct kvm_device *dev;\n\tbool test = cd->flags & KVM_CREATE_DEVICE_TEST;\n\tint ret;\n\tif (cd->type >= ARRAY_SIZE(kvm_device_ops_table))\n\t\treturn -ENODEV;\n\tops = kvm_device_ops_table[cd->type];\n\tif (ops == NULL)\n\t\treturn -ENODEV;\n\tif (test)\n\t\treturn 0;\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tdev->ops = ops;\n\tdev->kvm = kvm;\n\tmutex_lock(&kvm->lock);\n\tret = ops->create(dev, cd->type);\n\tif (ret < 0) {\n\t\tmutex_unlock(&kvm->lock);\n\t\tkfree(dev);\n\t\treturn ret;\n\t}\n\tlist_add(&dev->vm_node, &kvm->devices);\n\tmutex_unlock(&kvm->lock);\n\tif (ops->init)\n\t\tops->init(dev);\n\tret = anon_inode_getfd(ops->name, &kvm_device_fops, dev, O_RDWR | O_CLOEXEC);\n\tif (ret < 0) {\n\t\tops->destroy(dev);\n\t\tmutex_lock(&kvm->lock);\n\t\tlist_del(&dev->vm_node);\n\t\tmutex_unlock(&kvm->lock);\n\t\treturn ret;\n\t}\n\tkvm_get_kvm(kvm);\n\tcd->fd = ret;\n\treturn 0;\n}", "target": 1}
{"code": "NAN_METHOD(DetectCharacterEncoding) {\n\tNan::HandleScope scope;\n\tv8::Local<v8::Object> inputBuffer = info[0]->ToObject();\n\tUCharsetDetector *charsetDetector;\n\tconst UCharsetMatch *charsetMatch;\n\tUErrorCode errorCode = U_ZERO_ERROR;\n\tcharsetDetector = ucsdet_open(&errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to open ICU charset detector.\");\n\t\treturn;\n\t}\n\tucsdet_setText(\n\t\tcharsetDetector,\n\t\tnode::Buffer::Data(inputBuffer),\n\t\tnode::Buffer::Length(inputBuffer),\n\t\t&errorCode\n\t);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to set ICU charset detectors text.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tcharsetMatch = ucsdet_detect(charsetDetector, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to detect charset.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tconst char *charsetName = ucsdet_getName(charsetMatch, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get name from charset match.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tint32_t confidence = ucsdet_getConfidence(charsetMatch, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get confidence from charset match.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tv8::Local<v8::Object> obj = Nan::New<v8::Object>();\n\tobj->Set(Nan::New<v8::String>(\"encoding\").ToLocalChecked(), Nan::New<v8::String>(charsetName).ToLocalChecked());\n\tobj->Set(Nan::New<v8::String>(\"confidence\").ToLocalChecked(), Nan::New<v8::Number>(confidence));\n\tinfo.GetReturnValue().Set(obj);\n\tucsdet_close(charsetDetector);\n}", "target": 0}
{"code": "static void close_all_connections(struct Curl_multi *multi)\n{\n  struct connectdata *conn;\n  conn = Curl_conncache_find_first_connection(&multi->conn_cache);\n  while(conn) {\n    SIGPIPE_VARIABLE(pipe_st);\n    conn->data = multi->closure_handle;\n    sigpipe_ignore(conn->data, &pipe_st);\n    (void)Curl_disconnect(conn, FALSE);\n    sigpipe_restore(&pipe_st);\n    conn = Curl_conncache_find_first_connection(&multi->conn_cache);\n  }\n}", "target": 1}
{"code": "static int fdt_include_supernodes(struct fdt_region_state *info, int depth)\n{\n\tint base = fdt_off_dt_struct(info->fdt);\n\tint start, stop_at;\n\tint i;\n\tfor (i = 0; i <= depth; i++) {\n\t\tif (!info->stack[i].included) {\n\t\t\tstart = info->stack[i].offset;\n\t\t\tfdt_next_tag(info->fdt, start, &stop_at);\n\t\t\tif (fdt_add_region(info, base + start, stop_at - start))\n\t\t\t\treturn -1;\n\t\t\tinfo->stack[i].included = 1;\n\t\t\tinfo->can_merge = 1;\n\t\t}\n\t\tif (!info->stack[i].want)\n\t\t\tinfo->stack[i].want = WANT_NODES_ONLY;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static void fio_cluster_signal_children(void) {\n  if (fio_parent_pid() != getpid()) {\n    fio_stop();\n    return;\n  }\n  fio_cluster_server_sender(fio_msg_internal_create(0, FIO_CLUSTER_MSG_SHUTDOWN,\n                                                    (fio_str_info_s){.len = 0},\n                                                    (fio_str_info_s){.len = 0},\n                                                    0, 1),\n                            -1);\n}", "target": 1}
{"code": "static void coroutine_fn v9fs_mknod(void *opaque)\n{\n    int mode;\n    gid_t gid;\n    int32_t fid;\n    V9fsQID qid;\n    int err = 0;\n    int major, minor;\n    size_t offset = 7;\n    V9fsString name;\n    struct stat stbuf;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dsdddd\", &fid, &name, &mode,\n                        &major, &minor, &gid);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_mknod(pdu->tag, pdu->id, fid, mode, major, minor);\n    if (name_is_illegal(name.data)) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    if (!strcmp(\".\", name.data) || !strcmp(\"..\", name.data)) {\n        err = -EEXIST;\n        goto out_nofid;\n    }\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    err = v9fs_co_mknod(pdu, fidp, &name, fidp->uid, gid,\n                        makedev(major, minor), mode, &stbuf);\n    if (err < 0) {\n        goto out;\n    }\n    err = stat_to_qid(pdu, &stbuf, &qid);\n    if (err < 0) {\n        goto out;\n    }\n    err = pdu_marshal(pdu, offset, \"Q\", &qid);\n    if (err < 0) {\n        goto out;\n    }\n    err += offset;\n    trace_v9fs_mknod_return(pdu->tag, pdu->id,\n                            qid.type, qid.version, qid.path);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&name);\n}", "target": 0}
{"code": "tegra_xusb_find_port_node(struct tegra_xusb_padctl *padctl, const char *type,\n\t\t\t  unsigned int index)\n{\n\tstruct device_node *ports, *np;\n\tchar *name;\n\tports = of_get_child_by_name(padctl->dev->of_node, \"ports\");\n\tif (!ports)\n\t\treturn NULL;\n\tname = kasprintf(GFP_KERNEL, \"%s-%u\", type, index);\n\tif (!name) {\n\t\tof_node_put(ports);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tnp = of_get_child_by_name(ports, name);\n\tkfree(name);\n\tof_node_put(ports);\n\treturn np;\n}", "target": 1}
{"code": "const char* get_backup_uuid(MYSQL *connection)\n{\n\tif (!backup_uuid) {\n\t\tbackup_uuid = read_mysql_one_value(connection, \"SELECT UUID()\");\n\t}\n\treturn backup_uuid;\n}", "target": 0}
{"code": "static void __vmx_complete_interrupts(struct kvm_vcpu *vcpu,\n\t\t\t\t      u32 idt_vectoring_info,\n\t\t\t\t      int instr_len_field,\n\t\t\t\t      int error_code_field)\n{\n\tu8 vector;\n\tint type;\n\tbool idtv_info_valid;\n\tidtv_info_valid = idt_vectoring_info & VECTORING_INFO_VALID_MASK;\n\tvcpu->arch.nmi_injected = false;\n\tkvm_clear_exception_queue(vcpu);\n\tkvm_clear_interrupt_queue(vcpu);\n\tif (!idtv_info_valid)\n\t\treturn;\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\tvector = idt_vectoring_info & VECTORING_INFO_VECTOR_MASK;\n\ttype = idt_vectoring_info & VECTORING_INFO_TYPE_MASK;\n\tswitch (type) {\n\tcase INTR_TYPE_NMI_INTR:\n\t\tvcpu->arch.nmi_injected = true;\n\t\tvmx_set_nmi_mask(vcpu, false);\n\t\tbreak;\n\tcase INTR_TYPE_SOFT_EXCEPTION:\n\t\tvcpu->arch.event_exit_inst_len = vmcs_read32(instr_len_field);\n\tcase INTR_TYPE_HARD_EXCEPTION:\n\t\tif (idt_vectoring_info & VECTORING_INFO_DELIVER_CODE_MASK) {\n\t\t\tu32 err = vmcs_read32(error_code_field);\n\t\t\tkvm_requeue_exception_e(vcpu, vector, err);\n\t\t} else\n\t\t\tkvm_requeue_exception(vcpu, vector);\n\t\tbreak;\n\tcase INTR_TYPE_SOFT_INTR:\n\t\tvcpu->arch.event_exit_inst_len = vmcs_read32(instr_len_field);\n\tcase INTR_TYPE_EXT_INTR:\n\t\tkvm_queue_interrupt(vcpu, vector, type == INTR_TYPE_SOFT_INTR);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "static int ep_call_nested(struct nested_calls *ncalls, int max_nests,\n\t\t\t  int (*nproc)(void *, void *, int), void *priv,\n\t\t\t  void *cookie, void *ctx)\n{\n\tint error, call_nests = 0;\n\tunsigned long flags;\n\tstruct list_head *lsthead = &ncalls->tasks_call_list;\n\tstruct nested_call_node *tncur;\n\tstruct nested_call_node tnode;\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\tlist_for_each_entry(tncur, lsthead, llink) {\n\t\tif (tncur->ctx == ctx &&\n\t\t    (tncur->cookie == cookie || ++call_nests > max_nests)) {\n\t\t\terror = -1;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\ttnode.ctx = ctx;\n\ttnode.cookie = cookie;\n\tlist_add(&tnode.llink, lsthead);\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\terror = (*nproc)(priv, cookie, call_nests);\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\tlist_del(&tnode.llink);\nout_unlock:\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\treturn error;\n}", "target": 0}
{"code": "static int connection_handle_write(request_st * const r, connection * const con) {\n\tif (con->is_writable <= 0) return CON_STATE_WRITE;\n\tint rc = connection_write_chunkqueue(con, con->write_queue, MAX_WRITE_LIMIT);\n\tswitch (rc) {\n\tcase 0:\n\t\tif (r->resp_body_finished) {\n\t\t\tconnection_set_state(r, CON_STATE_RESPONSE_END);\n\t\t\treturn CON_STATE_RESPONSE_END;\n\t\t}\n\t\tbreak;\n\tcase -1: \n\t\tlog_error(r->conf.errh, __FILE__, __LINE__,\n\t\t  \"connection closed: write failed on fd %d\", con->fd);\n\t\tconnection_set_state_error(r, CON_STATE_ERROR);\n\t\treturn CON_STATE_ERROR;\n\tcase -2: \n\t\tconnection_set_state_error(r, CON_STATE_ERROR);\n\t\treturn CON_STATE_ERROR;\n\tcase 1:\n\t\tif (con->write_queue->bytes_out)\n\t\t\tcon->is_writable = 0;\n\t\tbreak;\n\t}\n\treturn CON_STATE_WRITE; \n}", "target": 0}
{"code": "int lg3ff_init(struct hid_device *hid)\n{\n\tstruct hid_input *hidinput = list_entry(hid->inputs.next, struct hid_input, list);\n\tstruct input_dev *dev = hidinput->input;\n\tconst signed short *ff_bits = ff3_joystick_ac;\n\tint error;\n\tint i;\n\tif (!hid_validate_values(hid, HID_OUTPUT_REPORT, 0, 0, 35))\n\t\treturn -ENODEV;\n\tfor (i = 0; ff_bits[i] >= 0; i++)\n\t\tset_bit(ff_bits[i], dev->ffbit);\n\terror = input_ff_create_memless(dev, NULL, hid_lg3ff_play);\n\tif (error)\n\t\treturn error;\n\tif (test_bit(FF_AUTOCENTER, dev->ffbit))\n\t\tdev->ff->set_autocenter = hid_lg3ff_set_autocenter;\n\thid_info(hid, \"Force feedback for Logitech Flight System G940 by Gary Stein <LordCnidarian@gmail.com>\\n\");\n\treturn 0;\n}", "target": 1}
{"code": "static int FNAME(cmpxchg_gpte)(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t       pt_element_t __user *ptep_user, unsigned index,\n\t\t\t       pt_element_t orig_pte, pt_element_t new_pte)\n{\n\tint npages;\n\tpt_element_t ret;\n\tpt_element_t *table;\n\tstruct page *page;\n\tnpages = get_user_pages_fast((unsigned long)ptep_user, 1, FOLL_WRITE, &page);\n\tif (likely(npages == 1)) {\n\t\ttable = kmap_atomic(page);\n\t\tret = CMPXCHG(&table[index], orig_pte, new_pte);\n\t\tkunmap_atomic(table);\n\t\tkvm_release_page_dirty(page);\n\t} else {\n\t\tstruct vm_area_struct *vma;\n\t\tunsigned long vaddr = (unsigned long)ptep_user & PAGE_MASK;\n\t\tunsigned long pfn;\n\t\tunsigned long paddr;\n\t\tmmap_read_lock(current->mm);\n\t\tvma = find_vma_intersection(current->mm, vaddr, vaddr + PAGE_SIZE);\n\t\tif (!vma || !(vma->vm_flags & VM_PFNMAP)) {\n\t\t\tmmap_read_unlock(current->mm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tpfn = ((vaddr - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\t\tpaddr = pfn << PAGE_SHIFT;\n\t\ttable = memremap(paddr, PAGE_SIZE, MEMREMAP_WB);\n\t\tif (!table) {\n\t\t\tmmap_read_unlock(current->mm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tret = CMPXCHG(&table[index], orig_pte, new_pte);\n\t\tmemunmap(table);\n\t\tmmap_read_unlock(current->mm);\n\t}\n\treturn (ret != orig_pte);\n}", "target": 1}
{"code": "static gboolean is_correct_filename(const char *value)\n{\n    return printable_str(value) && !strchr(value, '/') && !strchr(value, '.');\n}", "target": 1}
{"code": "void ext4_superblock_csum_set(struct super_block *sb,\n\t\t\t      struct ext4_super_block *es)\n{\n\tif (!EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\tEXT4_FEATURE_RO_COMPAT_METADATA_CSUM))\n\t\treturn;\n\tes->s_checksum = ext4_superblock_csum(sb, es);\n}", "target": 0}
{"code": "int sldns_str2wire_tsigerror_buf(const char* str, uint8_t* rd, size_t* len)\n{\n\tsldns_lookup_table *lt = sldns_lookup_by_name(sldns_tsig_errors, str);\n\tif(*len < 2)\n\t\treturn LDNS_WIREPARSE_ERR_BUFFER_TOO_SMALL;\n\tif(lt) {\n\t\tsldns_write_uint16(rd, (uint16_t)lt->id);\n\t\t*len = 2;\n\t} else {\n\t\treturn sldns_str2wire_int16_buf(str, rd, len);\n\t}\n\treturn LDNS_WIREPARSE_ERR_OK;\n}", "target": 0}
{"code": "make_month(const char *s)\n{\n    int i;\n    char month[3];\n    month[0] = xtoupper(*s);\n    if (!month[0])\n        return -1; \n    month[1] = xtolower(*(s + 1));\n    if (!month[1])\n        return -1; \n    month[2] = xtolower(*(s + 2));\n    for (i = 0; i < 12; i++)\n        if (!strncmp(month_names[i], month, 3))\n            return i;\n    return -1;\n}", "target": 0}
{"code": "unsigned int get_random_int(void)\n{\n\tstruct keydata *keyptr;\n\t__u32 *hash = get_cpu_var(get_random_int_hash);\n\tint ret;\n\tkeyptr = get_keyptr();\n\thash[0] += current->pid + jiffies + get_cycles();\n\tret = half_md4_transform(hash, keyptr->secret);\n\tput_cpu_var(get_random_int_hash);\n\treturn ret;\n}", "target": 1}
{"code": "static void setup_DMA(void)\n{\n\tunsigned long f;\n\tif (raw_cmd->length == 0) {\n\t\tint i;\n\t\tpr_info(\"zero dma transfer size:\");\n\t\tfor (i = 0; i < raw_cmd->cmd_count; i++)\n\t\t\tpr_cont(\"%x,\", raw_cmd->cmd[i]);\n\t\tpr_cont(\"\\n\");\n\t\tcont->done(0);\n\t\tFDCS->reset = 1;\n\t\treturn;\n\t}\n\tif (((unsigned long)raw_cmd->kernel_data) % 512) {\n\t\tpr_info(\"non aligned address: %p\\n\", raw_cmd->kernel_data);\n\t\tcont->done(0);\n\t\tFDCS->reset = 1;\n\t\treturn;\n\t}\n\tf = claim_dma_lock();\n\tfd_disable_dma();\n#ifdef fd_dma_setup\n\tif (fd_dma_setup(raw_cmd->kernel_data, raw_cmd->length,\n\t\t\t (raw_cmd->flags & FD_RAW_READ) ?\n\t\t\t DMA_MODE_READ : DMA_MODE_WRITE, FDCS->address) < 0) {\n\t\trelease_dma_lock(f);\n\t\tcont->done(0);\n\t\tFDCS->reset = 1;\n\t\treturn;\n\t}\n\trelease_dma_lock(f);\n#else\n\tfd_clear_dma_ff();\n\tfd_cacheflush(raw_cmd->kernel_data, raw_cmd->length);\n\tfd_set_dma_mode((raw_cmd->flags & FD_RAW_READ) ?\n\t\t\tDMA_MODE_READ : DMA_MODE_WRITE);\n\tfd_set_dma_addr(raw_cmd->kernel_data);\n\tfd_set_dma_count(raw_cmd->length);\n\tvirtual_dma_port = FDCS->address;\n\tfd_enable_dma();\n\trelease_dma_lock(f);\n#endif\n}", "target": 0}
{"code": "bool CxImage::Transfer(CxImage &from, bool bTransferFrames )\n{\n\tif (!Destroy())\n\t\treturn false;\n\tmemcpy(&head,&from.head,sizeof(BITMAPINFOHEADER));\n\tmemcpy(&info,&from.info,sizeof(CXIMAGEINFO));\n\tpDib = from.pDib;\n\tpSelection = from.pSelection;\n\tpAlpha = from.pAlpha;\n\tppLayers = from.ppLayers;\n\tmemset(&from.head,0,sizeof(BITMAPINFOHEADER));\n\tmemset(&from.info,0,sizeof(CXIMAGEINFO));\n\tfrom.pDib = from.pSelection = from.pAlpha = NULL;\n\tfrom.ppLayers = NULL;\n\tif (bTransferFrames){\n\t\tDestroyFrames();\n\t\tppFrames = from.ppFrames;\n\t\tfrom.ppFrames = NULL;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "int __parse_rtattr_nested_compat(struct rtattr *tb[], int max,\n\t\t\t\t struct rtattr *rta,\n\t\t\t\t int len)\n{\n\tif (RTA_PAYLOAD(rta) < len)\n\t\treturn -1;\n\tif (RTA_PAYLOAD(rta) >= RTA_ALIGN(len) + sizeof(struct rtattr)) {\n\t\trta = RTA_DATA(rta) + RTA_ALIGN(len);\n\t\treturn parse_rtattr_nested(tb, max, rta);\n\t}\n\tmemset(tb, 0, sizeof(struct rtattr *) * (max + 1));\n\treturn 0;\n}", "target": 0}
{"code": "webSocketsHasDataInBuffer(rfbClientPtr cl)\n{\n    ws_ctx_t *wsctx = (ws_ctx_t *)cl->wsctx;\n    if (wsctx && wsctx->readbuflen)\n      return TRUE;\n    return (cl->sslctx && rfbssl_pending(cl) > 0);\n}", "target": 1}
{"code": "nvkm_vmm_put_region(struct nvkm_vmm *vmm, struct nvkm_vma *vma)\n{\n\tstruct nvkm_vma *prev, *next;\n\tif ((prev = node(vma, prev)) && !prev->used) {\n\t\trb_erase(&prev->tree, &vmm->free);\n\t\tlist_del(&prev->head);\n\t\tvma->addr  = prev->addr;\n\t\tvma->size += prev->size;\n\t\tkfree(prev);\n\t}\n\tif ((next = node(vma, next)) && !next->used) {\n\t\trb_erase(&next->tree, &vmm->free);\n\t\tlist_del(&next->head);\n\t\tvma->size += next->size;\n\t\tkfree(next);\n\t}\n\tnvkm_vmm_free_insert(vmm, vma);\n}", "target": 1}
{"code": "static int get_filter(struct sss_certmap_ctx *ctx,\n                      struct ldap_mapping_rule *parsed_mapping_rule,\n                      struct sss_cert_content *cert_content,\n                      char **filter)\n{\n    struct ldap_mapping_rule_comp *comp;\n    char *result = NULL;\n    char *expanded = NULL;\n    int ret;\n    result = talloc_strdup(ctx, \"\");\n    if (result == NULL) {\n        return ENOMEM;\n    }\n    for (comp = parsed_mapping_rule->list; comp != NULL; comp = comp->next) {\n        if (comp->type == comp_string) {\n            result = talloc_strdup_append(result, comp->val);\n        } else if (comp->type == comp_template) {\n            ret = expand_template(ctx, comp->parsed_template, cert_content,\n                                  &expanded);\n            if (ret != 0) {\n                CM_DEBUG(ctx, \"Failed to expanded template.\");\n                goto done;\n            }\n            result = talloc_strdup_append(result, expanded);\n            talloc_free(expanded);\n            expanded = NULL;\n            if (result == NULL) {\n                ret = ENOMEM;\n                goto done;\n            }\n        } else {\n            ret = EINVAL;\n            CM_DEBUG(ctx, \"Unsupported component type.\");\n            goto done;\n        }\n    }\n    ret = 0;\ndone:\n    talloc_free(expanded);\n    if (ret == 0) {\n        *filter = result;\n    } else {\n        talloc_free(result);\n    }\n    return ret;\n}", "target": 1}
{"code": "restore_backup_configuration (GsdXrandrManager *manager, const char *backup_filename, const char *intended_filename, guint32 timestamp)\n{\n        int saved_errno;\n        if (rename (backup_filename, intended_filename) == 0) {\n                GError *error;\n                error = NULL;\n                if (!apply_configuration_from_filename (manager, intended_filename, FALSE, timestamp, &error)) {\n                        error_message (manager, _(\"Could not restore the display's configuration\"), error, NULL);\n                        if (error)\n                                g_error_free (error);\n                }\n                return;\n        }\n        saved_errno = errno;\n        if (saved_errno == ENOENT)\n                unlink (intended_filename);\n        else {\n                char *msg;\n                msg = g_strdup_printf (\"Could not rename %s to %s: %s\",\n                                       backup_filename, intended_filename,\n                                       g_strerror (saved_errno));\n                error_message (manager,\n                               _(\"Could not restore the display's configuration from a backup\"),\n                               NULL,\n                               msg);\n                g_free (msg);\n        }\n        unlink (backup_filename);\n}", "target": 0}
{"code": "rfbHandleAuthResult(rfbClient* client)\n{\n    uint32_t authResult=0, reasonLen=0;\n    char *reason=NULL;\n    if (!ReadFromRFBServer(client, (char *)&authResult, 4)) return FALSE;\n    authResult = rfbClientSwap32IfLE(authResult);\n    switch (authResult) {\n    case rfbVncAuthOK:\n      rfbClientLog(\"VNC authentication succeeded\\n\");\n      return TRUE;\n      break;\n    case rfbVncAuthFailed:\n      if (client->major==3 && client->minor>7)\n      {\n        if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return FALSE;\n        reasonLen = rfbClientSwap32IfLE(reasonLen);\n        reason = malloc((uint64_t)reasonLen+1);\n        if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return FALSE; }\n        reason[reasonLen]=0;\n        rfbClientLog(\"VNC connection failed: %s\\n\",reason);\n        free(reason);\n        return FALSE;\n      }\n      rfbClientLog(\"VNC authentication failed\\n\");\n      return FALSE;\n    case rfbVncAuthTooMany:\n      rfbClientLog(\"VNC authentication failed - too many tries\\n\");\n      return FALSE;\n    }\n    rfbClientLog(\"Unknown VNC authentication result: %d\\n\",\n                 (int)authResult);\n    return FALSE;\n}", "target": 1}
{"code": "static int read_file(const char *path, char *buf, size_t size,\n\t\t     struct file_info *d)\n{\n\tsize_t linelen = 0, total_len = 0, rv = 0;\n\tchar *line = NULL;\n\tchar *cache = d->buf;\n\tsize_t cache_size = d->buflen;\n\tFILE *f = fopen(path, \"r\");\n\tif (!f)\n\t\treturn 0;\n\twhile (getline(&line, &linelen, f) != -1) {\n\t\tsize_t l = snprintf(cache, cache_size, \"%s\", line);\n\t\tif (l < 0) {\n\t\t\tperror(\"Error writing to cache\");\n\t\t\trv = 0;\n\t\t\tgoto err;\n\t\t}\n\t\tif (l >= cache_size) {\n\t\t\tfprintf(stderr, \"Internal error: truncated write to cache\\n\");\n\t\t\trv = 0;\n\t\t\tgoto err;\n\t\t}\n\t\tif (l < cache_size) {\n\t\t\tcache += l;\n\t\t\tcache_size -= l;\n\t\t\ttotal_len += l;\n\t\t} else {\n\t\t\tcache += cache_size;\n\t\t\ttotal_len += cache_size;\n\t\t\tcache_size = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\td->size = total_len;\n\tif (total_len > size ) total_len = size;\n\tmemcpy(buf, d->buf, total_len);\n\trv = total_len;\n  err:\n\tfclose(f);\n\tfree(line);\n\treturn rv;\n}", "target": 0}
{"code": "static void bnx2x_get_mac_hwinfo(struct bnx2x *bp)\n{\n\tu32 val, val2;\n\tint func = BP_ABS_FUNC(bp);\n\tint port = BP_PORT(bp);\n\teth_zero_addr(bp->dev->dev_addr);\n\tif (BP_NOMCP(bp)) {\n\t\tBNX2X_ERROR(\"warning: random MAC workaround active\\n\");\n\t\teth_hw_addr_random(bp->dev);\n\t} else if (IS_MF(bp)) {\n\t\tval2 = MF_CFG_RD(bp, func_mf_config[func].mac_upper);\n\t\tval = MF_CFG_RD(bp, func_mf_config[func].mac_lower);\n\t\tif ((val2 != FUNC_MF_CFG_UPPERMAC_DEFAULT) &&\n\t\t    (val != FUNC_MF_CFG_LOWERMAC_DEFAULT))\n\t\t\tbnx2x_set_mac_buf(bp->dev->dev_addr, val, val2);\n\t\tif (CNIC_SUPPORT(bp))\n\t\t\tbnx2x_get_cnic_mac_hwinfo(bp);\n\t} else {\n\t\tval2 = SHMEM_RD(bp, dev_info.port_hw_config[port].mac_upper);\n\t\tval = SHMEM_RD(bp, dev_info.port_hw_config[port].mac_lower);\n\t\tbnx2x_set_mac_buf(bp->dev->dev_addr, val, val2);\n\t\tif (CNIC_SUPPORT(bp))\n\t\t\tbnx2x_get_cnic_mac_hwinfo(bp);\n\t}\n\tif (!BP_NOMCP(bp)) {\n\t\tval2 = SHMEM_RD(bp, dev_info.port_hw_config[port].mac_upper);\n\t\tval = SHMEM_RD(bp, dev_info.port_hw_config[port].mac_lower);\n\t\tbnx2x_set_mac_buf(bp->phys_port_id, val, val2);\n\t\tbp->flags |= HAS_PHYS_PORT_ID;\n\t}\n\tmemcpy(bp->link_params.mac_addr, bp->dev->dev_addr, ETH_ALEN);\n\tif (!is_valid_ether_addr(bp->dev->dev_addr))\n\t\tdev_err(&bp->pdev->dev,\n\t\t\t\"bad Ethernet MAC address configuration: %pM\\n\"\n\t\t\t\"change it manually before bringing up the appropriate network interface\\n\",\n\t\t\tbp->dev->dev_addr);\n}", "target": 0}
{"code": "static inline int crypto_rng_seedsize(struct crypto_rng *tfm)\n{\n\treturn tfm->seedsize;\n}", "target": 1}
{"code": "static void iov_fault_in_pages_read(struct iovec *iov, unsigned long len)\n{\n\twhile (!iov->iov_len)\n\t\tiov++;\n\twhile (len > 0) {\n\t\tunsigned long this_len;\n\t\tthis_len = min_t(unsigned long, len, iov->iov_len);\n\t\tfault_in_pages_readable(iov->iov_base, this_len);\n\t\tlen -= this_len;\n\t\tiov++;\n\t}\n}", "target": 1}
{"code": "static int update_discovery_filter(struct btd_adapter *adapter)\n{\n\tstruct mgmt_cp_start_service_discovery *sd_cp;\n\tGSList *l;\n\tDBG(\"\");\n\tif (discovery_filter_to_mgmt_cp(adapter, &sd_cp)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"discovery_filter_to_mgmt_cp returned error\");\n\t\treturn -ENOMEM;\n\t}\n\tfor (l = adapter->discovery_list; l; l = g_slist_next(l)) {\n\t\tstruct discovery_client *client = l->data;\n\t\tif (!client->discovery_filter)\n\t\t\tcontinue;\n\t\tif (client->discovery_filter->discoverable)\n\t\t\tbreak;\n\t}\n\tset_discovery_discoverable(adapter, l ? true : false);\n\tif (filters_equal(adapter->current_discovery_filter, sd_cp) &&\n\t    adapter->discovering != 0) {\n\t\tDBG(\"filters were equal, deciding to not restart the scan.\");\n\t\tg_free(sd_cp);\n\t\treturn 0;\n\t}\n\tg_free(adapter->current_discovery_filter);\n\tadapter->current_discovery_filter = sd_cp;\n\ttrigger_start_discovery(adapter, 0);\n\treturn -EINPROGRESS;\n}", "target": 1}
{"code": "bool EditorClientBlackBerry::shouldChangeSelectedRange(Range* fromRange, Range* toRange, EAffinity affinity, bool stillSelecting)\n{\n    if (m_webPagePrivate->m_dumpRenderTree)\n        return m_webPagePrivate->m_dumpRenderTree->shouldChangeSelectedDOMRangeToDOMRangeAffinityStillSelecting(fromRange, toRange, static_cast<int>(affinity), stillSelecting);\n     Frame* frame = m_webPagePrivate->focusedOrMainFrame();\n     if (frame && frame->document()) {\n        if (Node* focusedNode = frame->document()->focusedNode()) {\n            if (focusedNode->hasTagName(HTMLNames::selectTag))\n                return false;\n            if (focusedNode->isElementNode() && DOMSupport::isPopupInputField(static_cast<Element*>(focusedNode)))\n                return false;\n        }\n         if (m_webPagePrivate->m_inputHandler->isInputMode() && fromRange && toRange && (fromRange->startContainer() == toRange->startContainer()))\n            m_webPagePrivate->m_inputHandler->notifyClientOfKeyboardVisibilityChange(true);\n    }\n    return true;\n}", "target": 0}
{"code": "int EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,\n                      const unsigned char *in, int inl)\n{\n    int fix_len, cmpl = inl;\n    unsigned int b;\n    if (ctx->encrypt) {\n        EVPerr(EVP_F_EVP_DECRYPTUPDATE, EVP_R_INVALID_OPERATION);\n        return 0;\n    }\n    b = ctx->cipher->block_size;\n    if (EVP_CIPHER_CTX_test_flags(ctx, EVP_CIPH_FLAG_LENGTH_BITS))\n        cmpl = (cmpl + 7) / 8;\n    if (inl < 0\n            || (inl == 0\n                && EVP_CIPHER_mode(ctx->cipher) != EVP_CIPH_CCM_MODE)) {\n        *outl = 0;\n        return inl == 0;\n    }\n    if (ctx->cipher->flags & EVP_CIPH_FLAG_CUSTOM_CIPHER) {\n        if (b == 1 && is_partially_overlapping(out, in, cmpl)) {\n            EVPerr(EVP_F_EVP_DECRYPTUPDATE, EVP_R_PARTIALLY_OVERLAPPING);\n            return 0;\n        }\n        fix_len = ctx->cipher->do_cipher(ctx, out, in, inl);\n        if (fix_len < 0) {\n            *outl = 0;\n            return 0;\n        } else\n            *outl = fix_len;\n        return 1;\n    }\n    if (ctx->flags & EVP_CIPH_NO_PADDING)\n        return evp_EncryptDecryptUpdate(ctx, out, outl, in, inl);\n    OPENSSL_assert(b <= sizeof(ctx->final));\n    if (ctx->final_used) {\n        if (((PTRDIFF_T)out == (PTRDIFF_T)in)\n            || is_partially_overlapping(out, in, b)) {\n            EVPerr(EVP_F_EVP_DECRYPTUPDATE, EVP_R_PARTIALLY_OVERLAPPING);\n            return 0;\n        }\n        memcpy(out, ctx->final, b);\n        out += b;\n        fix_len = 1;\n    } else\n        fix_len = 0;\n    if (!evp_EncryptDecryptUpdate(ctx, out, outl, in, inl))\n        return 0;\n    if (b > 1 && !ctx->buf_len) {\n        *outl -= b;\n        ctx->final_used = 1;\n        memcpy(ctx->final, &out[*outl], b);\n    } else\n        ctx->final_used = 0;\n    if (fix_len)\n        *outl += b;\n    return 1;\n}", "target": 1}
{"code": "static __init int efivar_ssdt_iter(efi_char16_t *name, efi_guid_t vendor,\n\t\t\t\t   unsigned long name_size, void *data)\n{\n\tstruct efivar_entry *entry;\n\tstruct list_head *list = data;\n\tchar utf8_name[EFIVAR_SSDT_NAME_MAX];\n\tint limit = min_t(unsigned long, EFIVAR_SSDT_NAME_MAX, name_size);\n\tucs2_as_utf8(utf8_name, name, limit - 1);\n\tif (strncmp(utf8_name, efivar_ssdt, limit) != 0)\n\t\treturn 0;\n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn 0;\n\tmemcpy(entry->var.VariableName, name, name_size);\n\tmemcpy(&entry->var.VendorGuid, &vendor, sizeof(efi_guid_t));\n\tefivar_entry_add(entry, list);\n\treturn 0;\n}", "target": 0}
{"code": "static int jpc_qcd_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_qcd_t *qcd = &ms->parms.qcd;\n\tint i;\n\tfprintf(out, \"qntsty = %d; numguard = %d; numstepsizes = %d\\n\",\n\t  (int) qcd->compparms.qntsty, qcd->compparms.numguard, qcd->compparms.numstepsizes);\n\tfor (i = 0; i < qcd->compparms.numstepsizes; ++i) {\n\t\tfprintf(out, \"expn[%d] = 0x%04x; mant[%d] = 0x%04x;\\n\",\n\t\t  i, (unsigned) JPC_QCX_GETEXPN(qcd->compparms.stepsizes[i]),\n\t\t  i, (unsigned) JPC_QCX_GETMANT(qcd->compparms.stepsizes[i]));\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int unix_scm_to_skb(struct scm_cookie *scm, struct sk_buff *skb, bool send_fds)\n{\n\tint err = 0;\n\tUNIXCB(skb).pid  = get_pid(scm->pid);\n\tUNIXCB(skb).uid = scm->creds.uid;\n\tUNIXCB(skb).gid = scm->creds.gid;\n\tUNIXCB(skb).fp = NULL;\n\tunix_get_secdata(scm, skb);\n\tif (scm->fp && send_fds)\n\t\terr = unix_attach_fds(scm, skb);\n\tskb->destructor = unix_destruct_scm;\n\treturn err;\n}", "target": 0}
{"code": "static void zend_throw_or_error(int fetch_type, zend_class_entry *exception_ce, const char *format, ...) \n{\n\tva_list va;\n\tchar *message = NULL;\n\tva_start(va, format);\n\tzend_vspprintf(&message, 0, format, va);\n\tif (fetch_type & ZEND_FETCH_CLASS_EXCEPTION) {\n\t\tzend_throw_error(exception_ce, message);\n\t} else {\n\t\tzend_error(E_ERROR, \"%s\", message);\n\t}\n\tefree(message);\n\tva_end(va);\n}", "target": 1}
{"code": "rtadv_read (struct thread *thread)\n{\n  int sock;\n  int len;\n  u_char buf[RTADV_MSG_SIZE];\n  struct sockaddr_in6 from;\n  ifindex_t ifindex = 0;\n  int hoplimit = -1;\n  struct zebra_vrf *zvrf = THREAD_ARG (thread);\n  sock = THREAD_FD (thread);\n  zvrf->rtadv.ra_read = NULL;\n  rtadv_event (zvrf, RTADV_READ, sock);\n  len = rtadv_recv_packet (sock, buf, BUFSIZ, &from, &ifindex, &hoplimit);\n  if (len < 0) \n    {\n      zlog_warn (\"router solicitation recv failed: %s.\", safe_strerror (errno));\n      return len;\n    }\n  rtadv_process_packet (buf, (unsigned)len, ifindex, hoplimit, zvrf->vrf_id);\n  return 0;\n}", "target": 1}
{"code": "UnicodeString DecimalQuantity::toScientificString() const {\n    U_ASSERT(!isApproximate);\n    UnicodeString result;\n    if (isNegative()) {\n        result.append(u'-');\n    }\n    if (precision == 0) {\n        result.append(u\"0E+0\", -1);\n        return result;\n    }\n    int32_t upperPos = std::min(precision + scale, lOptPos) - scale - 1;\n    int32_t lowerPos = std::max(scale, rOptPos) - scale;\n    int32_t p = upperPos;\n    result.append(u'0' + getDigitPos(p));\n    if ((--p) >= lowerPos) {\n        result.append(u'.');\n        for (; p >= lowerPos; p--) {\n            result.append(u'0' + getDigitPos(p));\n        }\n    }\n    result.append(u'E');\n    int32_t _scale = upperPos + scale;\n    if (_scale < 0) {\n        _scale *= -1;\n        result.append(u'-');\n    } else {\n        result.append(u'+');\n    }\n    if (_scale == 0) {\n        result.append(u'0');\n    }\n    int32_t insertIndex = result.length();\n    while (_scale > 0) {\n        std::div_t res = std::div(_scale, 10);\n        result.insert(insertIndex, u'0' + res.rem);\n        _scale = res.quot;\n    }\n    return result;\n}", "target": 1}
{"code": "prologProcessor(XML_Parser parser, const char *s, const char *end,\n                const char **nextPtr) {\n  const char *next = s;\n  int tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                  (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n}", "target": 1}
{"code": "int unit_name_build(const char *prefix, const char *instance, const char *suffix, char **ret) {\n        UnitType type;\n        assert(prefix);\n        assert(suffix);\n        assert(ret);\n        if (suffix[0] != '.')\n                return -EINVAL;\n        type = unit_type_from_string(suffix + 1);\n        if (type < 0)\n                return -EINVAL;\n        return unit_name_build_from_type(prefix, instance, type, ret);\n}", "target": 0}
{"code": "static int evdev_handle_get_keycode_v2(struct input_dev *dev, void __user *p)\n{\n\tstruct input_keymap_entry ke;\n\tint error;\n\tif (copy_from_user(&ke, p, sizeof(ke)))\n\t\treturn -EFAULT;\n\terror = input_get_keycode(dev, &ke);\n\tif (error)\n\t\treturn error;\n\tif (copy_to_user(p, &ke, sizeof(ke)))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 0}
{"code": "int GfxUnivariateShading::getColor(double t, GfxColor *color)\n{\n    double out[gfxColorMaxComps];\n    int nComps;\n    if (likely(getNFuncs() >= 1)) {\n        nComps = getNFuncs() * funcs[0]->getOutputSize();\n    }\n    if (unlikely(getNFuncs() < 1 || nComps > gfxColorMaxComps)) {\n        clearGfxColor(color);\n        return gfxColorMaxComps;\n    }\n    if (cacheSize > 0) {\n        double x, ix, *l, *u, *upper;\n        if (cacheBounds[lastMatch - 1] >= t) {\n            upper = std::lower_bound(cacheBounds, cacheBounds + lastMatch - 1, t);\n            lastMatch = upper - cacheBounds;\n            lastMatch = std::min<int>(std::max<int>(1, lastMatch), cacheSize - 1);\n        } else if (cacheBounds[lastMatch] < t) {\n            upper = std::lower_bound(cacheBounds + lastMatch + 1, cacheBounds + cacheSize, t);\n            lastMatch = upper - cacheBounds;\n            lastMatch = std::min<int>(std::max<int>(1, lastMatch), cacheSize - 1);\n        }\n        x = (t - cacheBounds[lastMatch - 1]) * cacheCoeff[lastMatch];\n        ix = 1.0 - x;\n        u = cacheValues + lastMatch * nComps;\n        l = u - nComps;\n        for (int i = 0; i < nComps; ++i) {\n            out[i] = ix * l[i] + x * u[i];\n        }\n    } else {\n        for (int i = 0; i < nComps; ++i) {\n            out[i] = 0;\n        }\n        for (int i = 0; i < getNFuncs(); ++i) {\n            if (funcs[i]->getInputSize() != 1) {\n                error(errSyntaxWarning, -1, \"Invalid shading function (input != 1)\");\n                break;\n            }\n            funcs[i]->transform(&t, &out[i]);\n        }\n    }\n    for (int i = 0; i < nComps; ++i) {\n        color->c[i] = dblToCol(out[i]);\n    }\n    return nComps;\n}", "target": 0}
{"code": "int udp_sendpage(struct sock *sk, struct page *page, int offset,\n\t\t size_t size, int flags)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct udp_sock *up = udp_sk(sk);\n\tint ret;\n\tif (flags & MSG_SENDPAGE_NOTLAST)\n\t\tflags |= MSG_MORE;\n\tif (!up->pending) {\n\t\tstruct msghdr msg = {\t.msg_flags = flags|MSG_MORE };\n\t\tret = udp_sendmsg(sk, &msg, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tlock_sock(sk);\n\tif (unlikely(!up->pending)) {\n\t\trelease_sock(sk);\n\t\tnet_dbg_ratelimited(\"udp cork app bug 3\\n\");\n\t\treturn -EINVAL;\n\t}\n\tret = ip_append_page(sk, &inet->cork.fl.u.ip4,\n\t\t\t     page, offset, size, flags);\n\tif (ret == -EOPNOTSUPP) {\n\t\trelease_sock(sk);\n\t\treturn sock_no_sendpage(sk->sk_socket, page, offset,\n\t\t\t\t\tsize, flags);\n\t}\n\tif (ret < 0) {\n\t\tudp_flush_pending_frames(sk);\n\t\tgoto out;\n\t}\n\tup->len += size;\n\tif (!(up->corkflag || (flags&MSG_MORE)))\n\t\tret = udp_push_pending_frames(sk);\n\tif (!ret)\n\t\tret = size;\nout:\n\trelease_sock(sk);\n\treturn ret;\n}", "target": 0}
{"code": "update_notification_create(struct update_notification **file)\n{\n\tstruct update_notification *tmp;\n\tstruct deltas_head *list;\n\tint error;\n\ttmp = malloc(sizeof(struct update_notification));\n\tif (tmp == NULL)\n\t\treturn pr_enomem();\n\tlist = NULL;\n\terror = deltas_head_create(&list);\n\tif (error) {\n\t\tfree(tmp);\n\t\treturn error;\n\t}\n\ttmp->deltas_list = list;\n\ttmp->uri = NULL;\n\tglobal_data_init(&tmp->global_data);\n\tdoc_data_init(&tmp->snapshot);\n\t*file = tmp;\n\treturn 0;\n}", "target": 1}
{"code": "_mibindex_add( const char *dirname, int i )\n{\n    const int old_mibindex_max = _mibindex_max;\n    DEBUGMSGTL((\"mibindex\", \"add: %s (%d)\\n\", dirname, i ));\n    if ( i == -1 )\n        i = _mibindex++;\n    if ( i >= _mibindex_max ) {\n        _mibindex_max = i + 10;\n        _mibindexes = realloc(_mibindexes,\n                              _mibindex_max * sizeof(_mibindexes[0]));\n        netsnmp_assert(_mibindexes);\n        memset(_mibindexes + old_mibindex_max, 0,\n               (_mibindex_max - old_mibindex_max) * sizeof(_mibindexes[0]));\n    }\n    _mibindexes[ i ] = strdup( dirname );\n    if ( i >= _mibindex )\n        _mibindex = i+1;\n    DEBUGMSGTL((\"mibindex\", \"add: %d/%d/%d\\n\", i, _mibindex, _mibindex_max ));\n    return i;\n}", "target": 1}
{"code": "static __u8 *mr_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 30 && rdesc[29] == 0x05 && rdesc[30] == 0x09) {\n\t\thid_info(hdev, \"fixing up button/consumer in HID report descriptor\\n\");\n\t\trdesc[30] = 0x0c;\n\t}\n\treturn rdesc;\n}", "target": 1}
{"code": "static void __init acpi_request_region (struct acpi_generic_address *gas,\n\tunsigned int length, char *desc)\n{\n\tu64 addr;\n\tmemcpy(&addr, &gas->address, sizeof(addr));\n\tif (!addr || !length)\n\t\treturn;\n\tif (gas->space_id == ACPI_ADR_SPACE_SYSTEM_IO)\n\t\trequest_region(addr, length, desc);\n\telse if (gas->space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY)\n\t\trequest_mem_region(addr, length, desc);\n}", "target": 0}
{"code": "static void RemoveResolutionFromResourceBlock(StringInfo *bim_profile)\n{\n  register const unsigned char\n    *p;\n  size_t\n    length;\n  unsigned char\n    *datum;\n  unsigned int\n    count,\n    long_sans;\n  unsigned short\n    id,\n    short_sans;\n  length=GetStringInfoLength(bim_profile);\n  if (length < 16)\n    return;\n  datum=GetStringInfoDatum(bim_profile);\n  for (p=datum; (p >= datum) && (p < (datum+length-16)); )\n  {\n    register unsigned char\n      *q;\n    q=(unsigned char *) p;\n    if (LocaleNCompare((const char *) p,\"8BIM\",4) != 0)\n      break;\n    p=PushLongPixel(MSBEndian,p,&long_sans);\n    p=PushShortPixel(MSBEndian,p,&id);\n    p=PushShortPixel(MSBEndian,p,&short_sans);\n    p=PushLongPixel(MSBEndian,p,&count);\n    if ((id == 0x000003ed) && (PSDQuantum(count) < (ssize_t) (length-12)))\n      {\n        (void) CopyMagickMemory(q,q+PSDQuantum(count)+12,length-\n          (PSDQuantum(count)+12)-(q-datum));\n        SetStringInfoLength(bim_profile,length-(PSDQuantum(count)+12));\n        break;\n      }\n    p+=count;\n    if ((count & 0x01) != 0)\n      p++;\n  }\n}", "target": 1}
{"code": "folly::Optional<TLSMessage> EncryptedReadRecordLayer::read(\n    folly::IOBufQueue& buf) {\n  auto decryptedBuf = getDecryptedBuf(buf);\n  if (!decryptedBuf) {\n    return folly::none;\n  }\n  TLSMessage msg{};\n  auto currentBuf = decryptedBuf->get();\n  bool nonZeroFound = false;\n  do {\n    currentBuf = currentBuf->prev();\n    size_t i = currentBuf->length();\n    while (i > 0 && !nonZeroFound) {\n      nonZeroFound = (currentBuf->data()[i - 1] != 0);\n      i--;\n    }\n    if (nonZeroFound) {\n      msg.type = static_cast<ContentType>(currentBuf->data()[i]);\n    }\n    currentBuf->trimEnd(currentBuf->length() - i);\n  } while (!nonZeroFound && currentBuf != decryptedBuf->get());\n  if (!nonZeroFound) {\n    throw std::runtime_error(\"No content type found\");\n  }\n  msg.fragment = std::move(*decryptedBuf);\n  switch (msg.type) {\n    case ContentType::handshake:\n    case ContentType::alert:\n    case ContentType::application_data:\n      break;\n    default:\n      throw std::runtime_error(folly::to<std::string>(\n          \"received encrypted content type \",\n          static_cast<ContentTypeType>(msg.type)));\n  }\n  if (!msg.fragment || msg.fragment->empty()) {\n    if (msg.type == ContentType::application_data) {\n      msg.fragment = folly::IOBuf::create(0);\n    } else {\n      throw std::runtime_error(\"received empty fragment\");\n    }\n  }\n  return msg;\n}", "target": 0}
{"code": "void unregister_blkdev(unsigned int major, const char *name)\n{\n\tstruct blk_major_name **n;\n\tstruct blk_major_name *p = NULL;\n\tint index = major_to_index(major);\n\tmutex_lock(&block_class_lock);\n\tfor (n = &major_names[index]; *n; n = &(*n)->next)\n\t\tif ((*n)->major == major)\n\t\t\tbreak;\n\tif (!*n || strcmp((*n)->name, name)) {\n\t\tWARN_ON(1);\n\t} else {\n\t\tp = *n;\n\t\t*n = p->next;\n\t}\n\tmutex_unlock(&block_class_lock);\n\tkfree(p);\n}", "target": 0}
{"code": "static int pfkey_broadcast(struct sk_buff *skb, gfp_t allocation,\n\t\t\t   int broadcast_flags, struct sock *one_sk,\n\t\t\t   struct net *net)\n{\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\tstruct sock *sk;\n\tstruct hlist_node *node;\n\tstruct sk_buff *skb2 = NULL;\n\tint err = -ESRCH;\n\tif (!skb)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tsk_for_each_rcu(sk, node, &net_pfkey->table) {\n\t\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\t\tint err2;\n\t\tif (pfk->promisc)\n\t\t\tpfkey_broadcast_one(skb, &skb2, allocation, sk);\n\t\tif (sk == one_sk)\n\t\t\tcontinue;\n\t\tif (broadcast_flags != BROADCAST_ALL) {\n\t\t\tif (broadcast_flags & BROADCAST_PROMISC_ONLY)\n\t\t\t\tcontinue;\n\t\t\tif ((broadcast_flags & BROADCAST_REGISTERED) &&\n\t\t\t    !pfk->registered)\n\t\t\t\tcontinue;\n\t\t\tif (broadcast_flags & BROADCAST_ONE)\n\t\t\t\tcontinue;\n\t\t}\n\t\terr2 = pfkey_broadcast_one(skb, &skb2, allocation, sk);\n\t\tif ((broadcast_flags & BROADCAST_REGISTERED) && err)\n\t\t\terr = err2;\n\t}\n\trcu_read_unlock();\n\tif (one_sk != NULL)\n\t\terr = pfkey_broadcast_one(skb, &skb2, allocation, one_sk);\n\tkfree_skb(skb2);\n\tkfree_skb(skb);\n\treturn err;\n}", "target": 0}
{"code": "write_config_option_secret (int fd, const char *key, const char *value)\n{\n\tgs_free char *string = NULL;\n\tint x;\n\tstring = g_strdup_printf (\"%s %s\\n\", key, value);\n\tx = write (fd, string, strlen (string));\n\tif (x < 0)\n\t\t_LOGW (\"Unexpected error in write(): %d\", errno);\n\t_LOGD (\"Config: %s <hidden>\", key);\n}", "target": 0}
{"code": "QString Helper::temporaryMountDevice(const QString &device, const QString &name, bool readonly)\n{\n    QString mount_point = mountPoint(device);\n    if (!mount_point.isEmpty())\n        return mount_point;\n    mount_point = \"%1/.%2/mount/%3\";\n    const QStringList &tmp_paths = QStandardPaths::standardLocations(QStandardPaths::TempLocation);\n    mount_point = mount_point.arg(tmp_paths.isEmpty() ? \"/tmp\" : tmp_paths.first()).arg(qApp->applicationName()).arg(name);\n    if (!QDir::current().mkpath(mount_point)) {\n        dCError(\"mkpath \\\"%s\\\" failed\", qPrintable(mount_point));\n        return QString();\n    }\n    if (!mountDevice(device, mount_point, readonly)) {\n        dCError(\"Mount the device \\\"%s\\\" to \\\"%s\\\" failed\", qPrintable(device), qPrintable(mount_point));\n        return QString();\n    }\n    return mount_point;\n}", "target": 1}
{"code": "check_compat_entry_size_and_hooks(struct compat_arpt_entry *e,\n\t\t\t\t  struct xt_table_info *newinfo,\n\t\t\t\t  unsigned int *size,\n\t\t\t\t  const unsigned char *base,\n\t\t\t\t  const unsigned char *limit,\n\t\t\t\t  const unsigned int *hook_entries,\n\t\t\t\t  const unsigned int *underflows,\n\t\t\t\t  const char *name)\n{\n\tstruct xt_entry_target *t;\n\tstruct xt_target *target;\n\tunsigned int entry_offset;\n\tint ret, off, h;\n\tduprintf(\"check_compat_entry_size_and_hooks %p\\n\", e);\n\tif ((unsigned long)e % __alignof__(struct compat_arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct compat_arpt_entry) >= limit) {\n\t\tduprintf(\"Bad offset %p, limit = %p\\n\", e, limit);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset < sizeof(struct compat_arpt_entry) +\n\t\t\t     sizeof(struct compat_xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\tret = check_entry((struct arpt_entry *)e);\n\tif (ret)\n\t\treturn ret;\n\toff = sizeof(struct arpt_entry) - sizeof(struct compat_arpt_entry);\n\tentry_offset = (void *)e - (void *)base;\n\tt = compat_arpt_get_target(e);\n\ttarget = xt_request_find_target(NFPROTO_ARP, t->u.user.name,\n\t\t\t\t\tt->u.user.revision);\n\tif (IS_ERR(target)) {\n\t\tduprintf(\"check_compat_entry_size_and_hooks: `%s' not found\\n\",\n\t\t\t t->u.user.name);\n\t\tret = PTR_ERR(target);\n\t\tgoto out;\n\t}\n\tt->u.kernel.target = target;\n\toff += xt_compat_target_offset(target);\n\t*size += off;\n\tret = xt_compat_add_offset(NFPROTO_ARP, entry_offset, off);\n\tif (ret)\n\t\tgoto release_target;\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h])\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t}\n\tmemset(&e->counters, 0, sizeof(e->counters));\n\te->comefrom = 0;\n\treturn 0;\nrelease_target:\n\tmodule_put(t->u.kernel.target->me);\nout:\n\treturn ret;\n}", "target": 1}
{"code": "static int update_prepare_order_info(rdpContext* context, ORDER_INFO* orderInfo, UINT32 orderType)\n{\n\tint length = 1;\n\torderInfo->fieldFlags = 0;\n\torderInfo->orderType = orderType;\n\torderInfo->controlFlags = ORDER_STANDARD;\n\torderInfo->controlFlags |= ORDER_TYPE_CHANGE;\n\tlength += 1;\n\tlength += PRIMARY_DRAWING_ORDER_FIELD_BYTES[orderInfo->orderType];\n\tlength += update_prepare_bounds(context, orderInfo);\n\treturn length;\n}", "target": 1}
{"code": "integerify(void * B, size_t r)\n{\n  uint32_t * X = (uint32_t *)((uintptr_t)(B) + (2 * r - 1) * 64);\n  return (((uint64_t)(X[13]) << 32) + X[0]);\n}", "target": 1}
{"code": "void PpapiPluginProcessHost::OnProcessLaunched() {\n   host_impl_->set_plugin_process_handle(process_->GetHandle());\n }", "target": 0}
{"code": "void HeaderMapImpl::addViaMove(HeaderString&& key, HeaderString&& value) {\n  auto* entry = getExistingInline(key.getStringView());\n  if (entry != nullptr) {\n    appendToHeader(entry->value(), value.getStringView());\n    key.clear();\n    value.clear();\n  } else {\n    insertByKey(std::move(key), std::move(value));\n  }\n}", "target": 1}
{"code": "virStoragePoolObjBuildTempFilePath(virStoragePoolObj *obj,\n                                   virStorageVolDef *voldef)\n{\n    virStoragePoolDef *def = virStoragePoolObjGetDef(obj);\n    return g_strdup_printf(\"%s/%s.%s.secret.XXXXXX\", driver->stateDir,\n                           def->name, voldef->name);\n}", "target": 0}
{"code": "static int stellaris_enet_init(SysBusDevice *sbd)\n{\n    DeviceState *dev = DEVICE(sbd);\n    stellaris_enet_state *s = STELLARIS_ENET(dev);\n    memory_region_init_io(&s->mmio, OBJECT(s), &stellaris_enet_ops, s,\n                          \"stellaris_enet\", 0x1000);\n    sysbus_init_mmio(sbd, &s->mmio);\n    sysbus_init_irq(sbd, &s->irq);\n    qemu_macaddr_default_if_unset(&s->conf.macaddr);\n    s->nic = qemu_new_nic(&net_stellaris_enet_info, &s->conf,\n                          object_get_typename(OBJECT(dev)), dev->id, s);\n    qemu_format_nic_info_str(qemu_get_queue(s->nic), s->conf.macaddr.a);\n    stellaris_enet_reset(s);\n    register_savevm(dev, \"stellaris_enet\", -1, 1,\n                    stellaris_enet_save, stellaris_enet_load, s);\n    return 0;\n}", "target": 1}
{"code": "PlayerGeneric::~PlayerGeneric()\n{\n\tif (mixer)\n\t\tdelete mixer;\n\tif (player)\n\t{\n\t\tif (mixer->isActive() && !mixer->isDeviceRemoved(player))\n\t\t\tmixer->removeDevice(player);\n\t\tdelete player;\n\t}\n\tdelete[] audioDriverName;\n\tdelete listener;\n}", "target": 1}
{"code": "spnego_gss_verify_mic(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tconst gss_buffer_t msg_buffer,\n\t\tconst gss_buffer_t token_buffer,\n\t\tgss_qop_t *qop_state)\n{\n\tOM_uint32 ret;\n\tret = gss_verify_mic(minor_status,\n\t\t\t    context_handle,\n\t\t\t    msg_buffer,\n\t\t\t    token_buffer,\n\t\t\t    qop_state);\n\treturn (ret);\n}", "target": 1}
{"code": "static void save_state_to_tss16(struct x86_emulate_ctxt *ctxt,\n\t\t\t\tstruct tss_segment_16 *tss)\n{\n\ttss->ip = ctxt->_eip;\n\ttss->flag = ctxt->eflags;\n\ttss->ax = ctxt->regs[VCPU_REGS_RAX];\n\ttss->cx = ctxt->regs[VCPU_REGS_RCX];\n\ttss->dx = ctxt->regs[VCPU_REGS_RDX];\n\ttss->bx = ctxt->regs[VCPU_REGS_RBX];\n\ttss->sp = ctxt->regs[VCPU_REGS_RSP];\n\ttss->bp = ctxt->regs[VCPU_REGS_RBP];\n\ttss->si = ctxt->regs[VCPU_REGS_RSI];\n\ttss->di = ctxt->regs[VCPU_REGS_RDI];\n\ttss->es = get_segment_selector(ctxt, VCPU_SREG_ES);\n\ttss->cs = get_segment_selector(ctxt, VCPU_SREG_CS);\n\ttss->ss = get_segment_selector(ctxt, VCPU_SREG_SS);\n\ttss->ds = get_segment_selector(ctxt, VCPU_SREG_DS);\n\ttss->ldt = get_segment_selector(ctxt, VCPU_SREG_LDTR);\n}", "target": 0}
{"code": "static int register_queue_kobjects(struct net_device *dev)\n{\n\tint error = 0, txq = 0, rxq = 0, real_rx = 0, real_tx = 0;\n#ifdef CONFIG_SYSFS\n\tdev->queues_kset = kset_create_and_add(\"queues\",\n\t\t\t\t\t       NULL, &dev->dev.kobj);\n\tif (!dev->queues_kset)\n\t\treturn -ENOMEM;\n\treal_rx = dev->real_num_rx_queues;\n#endif\n\treal_tx = dev->real_num_tx_queues;\n\terror = net_rx_queue_update_kobjects(dev, 0, real_rx);\n\tif (error)\n\t\tgoto error;\n\trxq = real_rx;\n\terror = netdev_queue_update_kobjects(dev, 0, real_tx);\n\tif (error)\n\t\tgoto error;\n\ttxq = real_tx;\n\treturn 0;\nerror:\n\tnetdev_queue_update_kobjects(dev, txq, 0);\n\tnet_rx_queue_update_kobjects(dev, rxq, 0);\n\treturn error;", "target": 1}
{"code": "static void ax25_kill_by_device(struct net_device *dev)\n{\n\tax25_dev *ax25_dev;\n\tax25_cb *s;\n\tif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\n\t\treturn;\n\tspin_lock_bh(&ax25_list_lock);\nagain:\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->ax25_dev == ax25_dev) {\n\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\tlock_sock(s->sk);\n\t\t\ts->ax25_dev = NULL;\n\t\t\trelease_sock(s->sk);\n\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\tspin_lock_bh(&ax25_list_lock);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock_bh(&ax25_list_lock);\n}", "target": 1}
{"code": "int sysctl_schedstats(struct ctl_table *table, int write,\n\t\t\t void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct ctl_table t;\n\tint err;\n\tint state = static_branch_likely(&sched_schedstats);\n\tif (write && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tt = *table;\n\tt.data = &state;\n\terr = proc_dointvec_minmax(&t, write, buffer, lenp, ppos);\n\tif (err < 0)\n\t\treturn err;\n\tif (write)\n\t\tset_schedstats(state);\n\treturn err;\n}", "target": 0}
{"code": "IntegrationStreamDecoderPtr HttpIntegrationTest::sendRequestAndWaitForResponse(\n    const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,\n    const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index) {\n  ASSERT(codec_client_ != nullptr);\n  IntegrationStreamDecoderPtr response;\n  if (request_body_size) {\n    response = codec_client_->makeRequestWithBody(request_headers, request_body_size);\n  } else {\n    response = codec_client_->makeHeaderOnlyRequest(request_headers);\n  }\n  waitForNextUpstreamRequest(upstream_index);\n  upstream_request_->encodeHeaders(response_headers, response_size == 0);\n  if (response_size) {\n    upstream_request_->encodeData(response_size, true);\n  }\n  response->waitForEndStream();\n  return response;\n}", "target": 1}
{"code": "init_ctx_reselect(OM_uint32 *minor_status, spnego_gss_ctx_id_t sc,\n\t\t  OM_uint32 acc_negState, gss_OID supportedMech,\n\t\t  gss_buffer_t *responseToken, gss_buffer_t *mechListMIC,\n\t\t  OM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 tmpmin;\n\tsize_t i;\n\tgeneric_gss_release_oid(&tmpmin, &sc->internal_mech);\n\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n\t\t\t       GSS_C_NO_BUFFER);\n\tfor (i = 0; i < sc->mech_set->count; i++) {\n\t\tif (g_OID_equal(supportedMech, &sc->mech_set->elements[i]))\n\t\t\tbreak;\n\t}\n\tif (i == sc->mech_set->count)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tsc->internal_mech = &sc->mech_set->elements[i];\n\tif (acc_negState != REQUEST_MIC)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tsc->mech_complete = 0;\n\tsc->mic_reqd = 1;\n\t*negState = REQUEST_MIC;\n\t*tokflag = CONT_TOKEN_SEND;\n\treturn GSS_S_CONTINUE_NEEDED;\n}", "target": 1}
{"code": "void __page_frag_cache_drain(struct page *page, unsigned int count)\n{\n\tVM_BUG_ON_PAGE(page_ref_count(page) == 0, page);\n\tif (page_ref_sub_and_test(page, count)) {\n\t\tunsigned int order = compound_order(page);\n\t\tif (order == 0)\n\t\t\tfree_unref_page(page);\n\t\telse\n\t\t\t__free_pages_ok(page, order);\n\t}\n}", "target": 0}
{"code": "static AMQP_VALUE test_on_transfer_received(void* context, TRANSFER_HANDLE transfer, uint32_t payload_size, const unsigned char* payload_bytes)\n{\n    (void)context;\n    test_on_transfer_received_transfer = transfer;\n    test_on_transfer_received_payload_size = payload_size;\n    memcpy(test_on_transfer_received_payload_bytes, payload_bytes, payload_size);\n    return (AMQP_VALUE)0x6000;\n}", "target": 0}
{"code": "static int update_frag_index(MOVContext *c, int64_t offset)\n{\n    int index, i;\n    MOVFragmentIndexItem * item;\n    MOVFragmentStreamInfo * frag_stream_info;\n    index = search_frag_moof_offset(&c->frag_index, offset);\n    if (index < c->frag_index.nb_items &&\n        c->frag_index.item[index].moof_offset == offset)\n        return index;\n    item = av_fast_realloc(c->frag_index.item,\n                           &c->frag_index.allocated_size,\n                           (c->frag_index.nb_items + 1) *\n                           sizeof(*c->frag_index.item));\n    if (!item)\n        return -1;\n    c->frag_index.item = item;\n    frag_stream_info = av_realloc_array(NULL, c->fc->nb_streams,\n                                        sizeof(*item->stream_info));\n    if (!frag_stream_info)\n        return -1;\n    for (i = 0; i < c->fc->nb_streams; i++) {\n        if (c->fc->streams[i]->id < 0) {\n            av_free(frag_stream_info);\n            return AVERROR_INVALIDDATA;\n        }\n        frag_stream_info[i].id = c->fc->streams[i]->id;\n        frag_stream_info[i].sidx_pts = AV_NOPTS_VALUE;\n        frag_stream_info[i].tfdt_dts = AV_NOPTS_VALUE;\n        frag_stream_info[i].next_trun_dts = AV_NOPTS_VALUE;\n        frag_stream_info[i].first_tfra_pts = AV_NOPTS_VALUE;\n        frag_stream_info[i].index_base = -1;\n        frag_stream_info[i].index_entry = -1;\n        frag_stream_info[i].encryption_index = NULL;\n    }\n    if (index < c->frag_index.nb_items)\n        memmove(c->frag_index.item + index + 1, c->frag_index.item + index,\n                (c->frag_index.nb_items - index) * sizeof(*c->frag_index.item));\n    item = &c->frag_index.item[index];\n    item->headers_read = 0;\n    item->current = 0;\n    item->nb_stream_info = c->fc->nb_streams;\n    item->moof_offset = offset;\n    item->stream_info = frag_stream_info;\n    c->frag_index.nb_items++;\n    return index;\n}", "target": 0}
{"code": "lys_restr_dup(struct lys_module *mod, struct lys_restr *old, int size, int shallow, struct unres_schema *unres)\n{\n    struct lys_restr *result;\n    int i;\n    if (!size) {\n        return NULL;\n    }\n    result = calloc(size, sizeof *result);\n    LY_CHECK_ERR_RETURN(!result, LOGMEM(mod->ctx), NULL);\n    for (i = 0; i < size; i++) {\n        result[i].ext_size = old[i].ext_size;\n        lys_ext_dup(mod->ctx, mod, old[i].ext, old[i].ext_size, &result[i], LYEXT_PAR_RESTR, &result[i].ext, shallow, unres);\n        result[i].expr = lydict_insert(mod->ctx, old[i].expr, 0);\n        result[i].dsc = lydict_insert(mod->ctx, old[i].dsc, 0);\n        result[i].ref = lydict_insert(mod->ctx, old[i].ref, 0);\n        result[i].eapptag = lydict_insert(mod->ctx, old[i].eapptag, 0);\n        result[i].emsg = lydict_insert(mod->ctx, old[i].emsg, 0);\n    }\n    return result;\n}", "target": 1}
{"code": "  static Config::DecodedResourcesWrapper decodeResources(\n      const Protobuf::RepeatedPtrField<envoy::service::discovery::v3::Resource>& resources,\n      const std::string& name_field = \"name\") {\n    Config::DecodedResourcesWrapper decoded_resources;\n    TestOpaqueResourceDecoderImpl<MessageType> resource_decoder(name_field);\n    for (const auto& resource : resources) {\n      decoded_resources.owned_resources_.emplace_back(\n          new Config::DecodedResourceImpl(resource_decoder, resource));\n      decoded_resources.refvec_.emplace_back(*decoded_resources.owned_resources_.back());\n    }\n    return decoded_resources;\n  }", "target": 0}
{"code": "static void mod_wstunnel_merge_config(plugin_config * const pconf, const config_plugin_value_t *cpv) {\n    do {\n        mod_wstunnel_merge_config_cpv(pconf, cpv);\n    } while ((++cpv)->k_id != -1);\n}", "target": 0}
{"code": "void CNB::DoIPHdrCSO(PVOID IpHeader, ULONG EthPayloadLength) const\n{\n    ParaNdis_CheckSumVerifyFlat(IpHeader,\n                                EthPayloadLength,\n                                pcrIpChecksum | pcrFixIPChecksum,\n                                __FUNCTION__);\n}", "target": 1}
{"code": "static void vdbeVComment(Vdbe *p, const char *zFormat, va_list ap){\n  assert( p->nOp>0 || p->aOp==0 );\n  assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed );\n  if( p->nOp ){\n    assert( p->aOp );\n    sqlite3DbFree(p->db, p->aOp[p->nOp-1].zComment);\n    p->aOp[p->nOp-1].zComment = sqlite3VMPrintf(p->db, zFormat, ap);\n  }\n}", "target": 1}
{"code": "Array HHVM_FUNCTION(mcrypt_list_modes,\n                    const String& lib_dir ) {\n  String dir = lib_dir.empty() ? String(MCG(modes_dir)) : lib_dir;\n  int count = 0;\n  char **modules = mcrypt_list_modes((char*)dir.data(), &count);\n  if (count == 0) {\n    raise_warning(\"No modes found in module dir\");\n  }\n  Array ret = Array::Create();\n  for (int i = 0; i < count; i++) {\n    ret.append(String(modules[i], CopyString));\n  }\n  mcrypt_free_p(modules, count);\n  return ret;\n}", "target": 0}
{"code": "static int __init xfrm6_tunnel_init(void)\n{\n\tint rv;\n\trv = xfrm_register_type(&xfrm6_tunnel_type, AF_INET6);\n\tif (rv < 0)\n\t\tgoto err;\n\trv = xfrm6_tunnel_register(&xfrm6_tunnel_handler, AF_INET6);\n\tif (rv < 0)\n\t\tgoto unreg;\n\trv = xfrm6_tunnel_register(&xfrm46_tunnel_handler, AF_INET);\n\tif (rv < 0)\n\t\tgoto dereg6;\n\trv = xfrm6_tunnel_spi_init();\n\tif (rv < 0)\n\t\tgoto dereg46;\n\trv = register_pernet_subsys(&xfrm6_tunnel_net_ops);\n\tif (rv < 0)\n\t\tgoto deregspi;\n\treturn 0;\nderegspi:\n\txfrm6_tunnel_spi_fini();\ndereg46:\n\txfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);\ndereg6:\n\txfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);\nunreg:\n\txfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);\nerr:\n\treturn rv;\n}", "target": 1}
{"code": "checked_xmalloc (size_t size)\n{\n    alloc_limit_assert (\"checked_xmalloc\", size);\n    return xmalloc (size);\n}", "target": 1}
{"code": "static int alarm_timer_nsleep(const clockid_t which_clock, int flags,\n\t\t\t      const struct timespec64 *tsreq)\n{\n\tenum  alarmtimer_type type = clock2alarm(which_clock);\n\tstruct restart_block *restart = &current->restart_block;\n\tstruct alarm alarm;\n\tktime_t exp;\n\tint ret = 0;\n\tif (!alarmtimer_get_rtcdev())\n\t\treturn -ENOTSUPP;\n\tif (flags & ~TIMER_ABSTIME)\n\t\treturn -EINVAL;\n\tif (!capable(CAP_WAKE_ALARM))\n\t\treturn -EPERM;\n\talarm_init_on_stack(&alarm, type, alarmtimer_nsleep_wakeup);\n\texp = timespec64_to_ktime(*tsreq);\n\tif (flags != TIMER_ABSTIME) {\n\t\tktime_t now = alarm_bases[type].gettime();\n\t\texp = ktime_add(now, exp);\n\t}\n\tret = alarmtimer_do_nsleep(&alarm, exp, type);\n\tif (ret != -ERESTART_RESTARTBLOCK)\n\t\treturn ret;\n\tif (flags == TIMER_ABSTIME)\n\t\treturn -ERESTARTNOHAND;\n\trestart->fn = alarm_timer_nsleep_restart;\n\trestart->nanosleep.clockid = type;\n\trestart->nanosleep.expires = exp;\n\treturn ret;\n}", "target": 1}
{"code": "vote_routerstatus_find_microdesc_hash(char *digest256_out,\n                                      const vote_routerstatus_t *vrs,\n                                      int method,\n                                      digest_algorithm_t alg)\n{\n  const vote_microdesc_hash_t *h;\n  char mstr[64];\n  size_t mlen;\n  char dstr[64];\n  tor_snprintf(mstr, sizeof(mstr), \"%d\", method);\n  mlen = strlen(mstr);\n  tor_snprintf(dstr, sizeof(dstr), \" %s=\",\n               crypto_digest_algorithm_get_name(alg));\n  for (h = vrs->microdesc; h; h = h->next) {\n    const char *cp = h->microdesc_hash_line;\n    size_t num_len;\n    while (1) {\n      num_len = strspn(cp, \"1234567890\");\n      if (num_len == mlen && fast_memeq(mstr, cp, mlen)) {\n        char buf[BASE64_DIGEST256_LEN+1];\n        cp = strstr(cp, dstr);\n        if (!cp)\n          return -1;\n        cp += strlen(dstr);\n        strlcpy(buf, cp, sizeof(buf));\n        return digest256_from_base64(digest256_out, buf);\n      }\n      if (num_len == 0 || cp[num_len] != ',')\n        break;\n      cp += num_len + 1;\n    }\n  }\n  return -1;\n}", "target": 0}
{"code": "static void do_free_publickey(struct rsa_public_key *s)\n{\n\tif (s) {\n\t\tcrypto_bignum_free(s->n);\n\t\tcrypto_bignum_free(s->e);\n\t}\n}", "target": 1}
{"code": "kg_seal_iov(OM_uint32 *minor_status,\n            gss_ctx_id_t context_handle,\n            int conf_req_flag,\n            gss_qop_t qop_req,\n            int *conf_state,\n            gss_iov_buffer_desc *iov,\n            int iov_count,\n            int toktype)\n{\n    krb5_gss_ctx_id_rec *ctx;\n    krb5_error_code code;\n    krb5_context context;\n    if (qop_req != 0) {\n        *minor_status = (OM_uint32)G_UNKNOWN_QOP;\n        return GSS_S_FAILURE;\n    }\n    ctx = (krb5_gss_ctx_id_rec *)context_handle;\n    if (!ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return GSS_S_NO_CONTEXT;\n    }\n    if (conf_req_flag && kg_integ_only_iov(iov, iov_count)) {\n        conf_req_flag = FALSE;\n    }\n    context = ctx->k5_context;\n    switch (ctx->proto) {\n    case 0:\n        code = make_seal_token_v1_iov(context, ctx, conf_req_flag,\n                                      conf_state, iov, iov_count, toktype);\n        break;\n    case 1:\n        code = gss_krb5int_make_seal_token_v3_iov(context, ctx, conf_req_flag,\n                                                  conf_state, iov, iov_count, toktype);\n        break;\n    default:\n        code = G_UNKNOWN_QOP;\n        break;\n    }\n    if (code != 0) {\n        *minor_status = code;\n        save_error_info(*minor_status, context);\n        return GSS_S_FAILURE;\n    }\n    *minor_status = 0;\n    return GSS_S_COMPLETE;\n}", "target": 1}
{"code": "yang_read_length(struct ly_ctx *ctx, struct yang_type *stype, char *value, int is_ext_instance)\n{\n    struct lys_restr *length;\n    if (is_ext_instance) {\n        length = (struct lys_restr *)stype;\n    } else {\n        if (stype->base == 0 || stype->base == LY_TYPE_STRING) {\n            stype->base = LY_TYPE_STRING;\n        } else {\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Unexpected length statement.\");\n            goto error;\n        }\n        if (stype->type->info.str.length) {\n            LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"length\", \"type\");\n            goto error;\n        }\n        length = calloc(1, sizeof *length);\n        LY_CHECK_ERR_GOTO(!length, LOGMEM(ctx), error);\n        stype->type->info.str.length = length;\n    }\n    length->expr = lydict_insert_zc(ctx, value);\n    return length;\nerror:\n    free(value);\n    return NULL;\n}", "target": 0}
{"code": "static irqreturn_t xennet_tx_interrupt(int irq, void *dev_id)\n{\n\tunsigned int eoiflag = XEN_EOI_FLAG_SPURIOUS;\n\tif (likely(xennet_handle_tx(dev_id, &eoiflag)))\n\t\txen_irq_lateeoi(irq, eoiflag);\n\treturn IRQ_HANDLED;\n}", "target": 0}
{"code": "static inline MagickOffsetType WritePixelCacheRegion(\n  const CacheInfo *magick_restrict cache_info,const MagickOffsetType offset,\n  const MagickSizeType length,const unsigned char *magick_restrict buffer)\n{\n  register MagickOffsetType\n    i;\n  ssize_t\n    count;\n#if !defined(MAGICKCORE_HAVE_PWRITE)\n  if (lseek(cache_info->file,offset,SEEK_SET) < 0)\n    return((MagickOffsetType) -1);\n#endif\n  count=0;\n  for (i=0; i < (MagickOffsetType) length; i+=count)\n  {\n#if !defined(MAGICKCORE_HAVE_PWRITE)\n    count=write(cache_info->file,buffer+i,(size_t) MagickMin(length-i,(size_t)\n      SSIZE_MAX));\n#else\n    count=pwrite(cache_info->file,buffer+i,(size_t) MagickMin(length-i,(size_t)\n      SSIZE_MAX),(off_t) (offset+i));\n#endif\n    if (count <= 0)\n      {\n        count=0;\n        if (errno != EINTR)\n          break;\n      }\n  }\n  return(i);\n}", "target": 0}
{"code": "decode_labeled_prefix6(netdissect_options *ndo,\n                       const u_char *pptr, u_int itemlen, char *buf, u_int buflen)\n{\n\tstruct in6_addr addr;\n\tu_int plen, plenbytes;\n\tND_TCHECK2(pptr[0], 4);\n\tITEMCHECK(4);\n\tplen = pptr[0]; \n\tif (24 > plen)\n\t\treturn -1;\n        plen-=24; \n\tif (128 < plen)\n\t\treturn -1;\n\titemlen -= 4;\n\tmemset(&addr, 0, sizeof(addr));\n\tplenbytes = (plen + 7) / 8;\n\tND_TCHECK2(pptr[4], plenbytes);\n\tmemcpy(&addr, &pptr[4], plenbytes);\n\tif (plen % 8) {\n\t\taddr.s6_addr[plenbytes - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n\tsnprintf(buf, buflen, \"%s/%d, label:%u %s\",\n                 ip6addr_string(ndo, &addr),\n                 plen,\n                 EXTRACT_24BITS(pptr+1)>>4,\n                 ((pptr[3]&1)==0) ? \"(BOGUS: Bottom of Stack NOT set!)\" : \"(bottom)\" );\n\treturn 4 + plenbytes;\ntrunc:\n\treturn -2;\nbadtlv:\n\treturn -3;\n}", "target": 0}
{"code": "static int sco_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sco_pinfo *pi = sco_pi(sk);\n\tlock_sock(sk);\n\tif (sk->sk_state == BT_CONNECT2 &&\n\t    test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags)) {\n\t\tsco_conn_defer_accept(pi->conn->hcon, pi->setting);\n\t\tsk->sk_state = BT_CONFIG;\n\t\tmsg->msg_namelen = 0;\n\t\trelease_sock(sk);\n\t\treturn 0;\n\t}\n\trelease_sock(sk);\n\treturn bt_sock_recvmsg(iocb, sock, msg, len, flags);\n}", "target": 1}
{"code": "int mb2_cache_entry_create(struct mb2_cache *cache, gfp_t mask, u32 key,\n\t\t\t   sector_t block)\n{\n\tstruct mb2_cache_entry *entry, *dup;\n\tstruct hlist_bl_node *dup_node;\n\tstruct hlist_bl_head *head;\n\tentry = kmem_cache_alloc(mb2_entry_cache, mask);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\tINIT_LIST_HEAD(&entry->e_lru_list);\n\tatomic_set(&entry->e_refcnt, 1);\n\tentry->e_key = key;\n\tentry->e_block = block;\n\thead = &cache->c_hash[hash_32(key, cache->c_bucket_bits)];\n\tentry->e_hash_list_head = head;\n\thlist_bl_lock(head);\n\thlist_bl_for_each_entry(dup, dup_node, head, e_hash_list) {\n\t\tif (dup->e_key == key && dup->e_block == block) {\n\t\t\thlist_bl_unlock(head);\n\t\t\tkmem_cache_free(mb2_entry_cache, entry);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\thlist_bl_add_head(&entry->e_hash_list, head);\n\thlist_bl_unlock(head);\n\tspin_lock(&cache->c_lru_list_lock);\n\tlist_add_tail(&entry->e_lru_list, &cache->c_lru_list);\n\tatomic_inc(&entry->e_refcnt);\n\tcache->c_entry_count++;\n\tspin_unlock(&cache->c_lru_list_lock);\n\treturn 0;\n}", "target": 0}
{"code": "static void SerializeGltfSampler(Sampler &sampler, json &o) {\n  if (sampler.magFilter != -1) {\n    SerializeNumberProperty(\"magFilter\", sampler.magFilter, o);\n  }\n  if (sampler.minFilter != -1) {\n    SerializeNumberProperty(\"minFilter\", sampler.minFilter, o);\n  }\n  SerializeNumberProperty(\"wrapS\", sampler.wrapS, o);\n  SerializeNumberProperty(\"wrapT\", sampler.wrapT, o);\n  if (sampler.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", sampler.extras, o);\n  }\n}", "target": 1}
{"code": "static struct nfs4_opendata *nfs4_open_recoverdata_alloc(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs4_opendata *opendata;\n\topendata = nfs4_opendata_alloc(&ctx->path, state->owner, 0, NULL);\n\tif (opendata == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\topendata->state = state;\n\tatomic_inc(&state->count);\n\treturn opendata;\n}", "target": 1}
{"code": "int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf,\n                            size_t size)\n{\n    GetBitContext gb;\n    AC3HeaderInfo *hdr;\n    int err;\n    if (!*phdr)\n        *phdr = av_mallocz(sizeof(AC3HeaderInfo));\n    if (!*phdr)\n        return AVERROR(ENOMEM);\n    hdr = *phdr;\n    init_get_bits8(&gb, buf, size);\n    err = ff_ac3_parse_header(&gb, hdr);\n    if (err < 0)\n        return AVERROR_INVALIDDATA;\n    return get_bits_count(&gb);\n}", "target": 1}
{"code": "static int selinux_sb_alloc_security(struct super_block *sb)\n{\n\tstruct superblock_security_struct *sbsec;\n\tsbsec = kzalloc(sizeof(struct superblock_security_struct), GFP_KERNEL);\n\tif (!sbsec)\n\t\treturn -ENOMEM;\n\tmutex_init(&sbsec->lock);\n\tINIT_LIST_HEAD(&sbsec->isec_head);\n\tspin_lock_init(&sbsec->isec_lock);\n\tsbsec->sb = sb;\n\tsbsec->sid = SECINITSID_UNLABELED;\n\tsbsec->def_sid = SECINITSID_FILE;\n\tsbsec->mntpoint_sid = SECINITSID_UNLABELED;\n\tsb->s_security = sbsec;\n\treturn 0;\n}", "target": 0}
{"code": "ServerSecurityFeature::ServerSecurityFeature(application_features::ApplicationServer& server)\n    : ApplicationFeature(server, \"ServerSecurity\"),\n      _enableFoxxApi(true),\n      _enableFoxxStore(true),\n      _hardenedRestApi(false) {\n  setOptional(false);\n  startsAfter<application_features::GreetingsFeaturePhase>();\n}", "target": 1}
{"code": "void SetColor(double c, double m, double y, double k,int par)\n{\n    if ( par == STROKING ) {\n        outpos += sprintf(outpos,\" %12.3f %12.3f %12.3f %12.3f K\",c,m,y,k);\n    }\n    else {\n        outpos += sprintf(outpos,\" %12.3f %12.3f %12.3f %12.3f k\",c,m,y,k);\n    }\n}", "target": 1}
{"code": "static int __init personal_server_map_irq(const struct pci_dev *dev, u8 slot,\n\tu8 pin)\n{\n\tunsigned char line;\n\tpci_read_config_byte(dev, PCI_INTERRUPT_LINE, &line);\n\tif (line > 0x40 && line <= 0x5f) {\n\t\treturn irqmap_personal_server[(line & 0x1f) - 8];\n\t} else if (line == 0) {\n\t\treturn 0;\n\t} else\n\t\treturn irqmap_personal_server[(line - 1) & 3];\n}", "target": 1}
{"code": "generate_spc_link(cms_context *cms, SpcLink *slp, SpcLinkType link_type,\n\t\tvoid *link_data, size_t link_data_size)\n{\n\tSpcLink sl;\n\tmemset(&sl, '\\0', sizeof (sl));\n\tsl.type = link_type;\n\tswitch (sl.type) {\n\tcase SpcLinkTypeFile: {\n\t\tint rc = generate_spc_string(cms, &sl.file, link_data,\n\t\t\t\t\tlink_data_size);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tbreak;\n\t}\n\tcase SpcLinkTypeUrl:\n\t\tsl.url.type = siBuffer;\n\t\tsl.url.data = link_data;\n\t\tsl.url.len = link_data_size;\n\t\tbreak;\n\tdefault:\n\t\tcms->log(cms, LOG_ERR, \"Invalid SpcLinkType\");\n\t\treturn -1;\n\t};\n\tmemcpy(slp, &sl, sizeof (sl));\n\treturn 0;\n}", "target": 0}
{"code": "Sfdouble_t sh_strnum(Shell_t *shp, const char *str, char **ptr, int mode) {\n    Sfdouble_t d;\n    char *last;\n    if (*str == 0) {\n        if (ptr) *ptr = (char *)str;\n        return 0;\n    }\n    errno = 0;\n    d = number(str, &last, shp->inarith ? 0 : 10, NULL);\n    if (*last) {\n        if (*last != '.' || last[1] != '.') {\n            d = strval(shp, str, &last, arith, mode);\n            Varsubscript = true;\n        }\n        if (!ptr && *last && mode > 0) errormsg(SH_DICT, ERROR_exit(1), e_lexbadchar, *last, str);\n    } else if (!d && *str == '-') {\n        d = -0.0;\n    }\n    if (ptr) *ptr = last;\n    return d;\n}", "target": 1}
{"code": "static void nvme_flush_ns_cb(void *opaque, int ret)\n{\n    NvmeFlushAIOCB *iocb = opaque;\n    NvmeNamespace *ns = iocb->ns;\n    if (ret < 0) {\n        iocb->ret = ret;\n        goto out;\n    } else if (iocb->ret < 0) {\n        goto out;\n    }\n    if (ns) {\n        trace_pci_nvme_flush_ns(iocb->nsid);\n        iocb->ns = NULL;\n        iocb->aiocb = blk_aio_flush(ns->blkconf.blk, nvme_flush_ns_cb, iocb);\n        return;\n    }\nout:\n    iocb->aiocb = NULL;\n    qemu_bh_schedule(iocb->bh);\n}", "target": 0}
{"code": "Status ValidatePaddingValues(absl::Span<const int64_t> input_dimensions,\n                             absl::Span<const int64_t> window_dimensions,\n                             absl::Span<const int64_t> window_strides) {\n  bool ok = input_dimensions.size() == window_dimensions.size() &&\n            input_dimensions.size() == window_strides.size();\n  if (!ok) {\n    return InvalidArgument(\n        \"Want input dimensions size %u = window dimensions size %u = window \"\n        \"strides size %u\",\n        input_dimensions.size(), window_dimensions.size(),\n        window_strides.size());\n  }\n  for (size_t i = 0; i < input_dimensions.size(); ++i) {\n    if (window_dimensions[i] <= 0) {\n      return InvalidArgument(\"Window dimension %u has non-positive size %d\", i,\n                             window_dimensions[i]);\n    }\n    if (window_strides[i] <= 0) {\n      return InvalidArgument(\"Window dimension %u has non-positive stride %d\",\n                             i, window_strides[i]);\n    }\n  }\n  return OkStatus();\n}", "target": 0}
{"code": "static void do_free_upto(BIO *f, BIO *upto)\n\t{\n\tif (upto)\n\t\t{\n\t\tBIO *tbio;\n\t\tdo \n\t\t\t{\n\t\t\ttbio = BIO_pop(f);\n\t\t\tBIO_free(f);\n\t\t\tf = tbio;\n\t\t\t}\n\t\twhile (f != upto);\n\t\t}\n\telse\n\t\tBIO_free_all(f);\n\t}", "target": 1}
{"code": "static int file_modsqrt(STANZA *s)\n{\n    BIGNUM *a = NULL, *p = NULL, *mod_sqrt = NULL, *ret = NULL, *ret2 = NULL;\n    int st = 0;\n    if (!TEST_ptr(a = getBN(s, \"A\"))\n            || !TEST_ptr(p = getBN(s, \"P\"))\n            || !TEST_ptr(mod_sqrt = getBN(s, \"ModSqrt\"))\n            || !TEST_ptr(ret = BN_new())\n            || !TEST_ptr(ret2 = BN_new()))\n        goto err;\n    if (!TEST_true(BN_mod_sqrt(ret, a, p, ctx))\n            || !TEST_true(BN_sub(ret2, p, ret)))\n        goto err;\n    if (BN_cmp(ret2, mod_sqrt) != 0\n            && !equalBN(\"sqrt(A) (mod P)\", mod_sqrt, ret))\n        goto err;\n    st = 1;\n err:\n    BN_free(a);\n    BN_free(p);\n    BN_free(mod_sqrt);\n    BN_free(ret);\n    BN_free(ret2);\n    return st;\n}", "target": 0}
{"code": "int OutputValueSampler(CMSREGISTER const cmsUInt16Number In[], CMSREGISTER cmsUInt16Number Out[], CMSREGISTER void* Cargo)\n{\n    cmsPsSamplerCargo* sc = (cmsPsSamplerCargo*) Cargo;\n    cmsUInt32Number i;\n    if (sc -> FixWhite) {\n        if (In[0] == 0xFFFF) {  \n            if ((In[1] >= 0x7800 && In[1] <= 0x8800) &&\n                (In[2] >= 0x7800 && In[2] <= 0x8800)) {\n                cmsUInt16Number* Black;\n                cmsUInt16Number* White;\n                cmsUInt32Number nOutputs;\n                if (!_cmsEndPointsBySpace(sc ->ColorSpace, &White, &Black, &nOutputs))\n                        return 0;\n                for (i=0; i < nOutputs; i++)\n                        Out[i] = White[i];\n            }\n        }\n    }\n    if (In[0] != sc ->FirstComponent) {\n            if (sc ->FirstComponent != -1) {\n                    _cmsIOPrintf(sc ->m, sc ->PostMin);\n                    sc ->SecondComponent = -1;\n                    _cmsIOPrintf(sc ->m, sc ->PostMaj);\n            }\n            _cmsPSActualColumn = 0;\n            _cmsIOPrintf(sc ->m, sc ->PreMaj);\n            sc ->FirstComponent = In[0];\n    }\n      if (In[1] != sc ->SecondComponent) {\n            if (sc ->SecondComponent != -1) {\n                    _cmsIOPrintf(sc ->m, sc ->PostMin);\n            }\n            _cmsIOPrintf(sc ->m, sc ->PreMin);\n            sc ->SecondComponent = In[1];\n    }\n      for (i=0; i < sc -> Pipeline ->Params->nOutputs; i++) {\n          cmsUInt16Number wWordOut = Out[i];\n          cmsUInt8Number wByteOut;           \n          wByteOut = Word2Byte(wWordOut);\n          WriteByte(sc -> m, wByteOut);\n      }\n      return 1;\n}", "target": 0}
{"code": "static void radix_count(const RCCMPEntry *data, int size, int buckets[RADIX_PASSES][NBUCKETS])\n{\n    int i, j;\n    memset(buckets, 0, sizeof(buckets[0][0]) * RADIX_PASSES * NBUCKETS);\n    for (i = 0; i < size; i++) {\n        int v = data[i].value;\n        for (j = 0; j < RADIX_PASSES; j++) {\n            buckets[j][get_bucket(v, 0)]++;\n            v >>= BUCKET_BITS;\n        }\n        av_assert1(!v);\n    }\n    for (j = 0; j < RADIX_PASSES; j++) {\n        int offset = size;\n        for (i = NBUCKETS - 1; i >= 0; i--)\n            buckets[j][i] = offset -= buckets[j][i];\n        av_assert1(!buckets[j][0]);\n    }\n}", "target": 0}
{"code": "static void ip_cmsg_recv_checksum(struct msghdr *msg, struct sk_buff *skb,\n\t\t\t\t  int tlen, int offset)\n{\n\t__wsum csum = skb->csum;\n\tif (skb->ip_summed != CHECKSUM_COMPLETE)\n\t\treturn;\n\tif (offset != 0)\n\t\tcsum = csum_sub(csum,\n\t\t\t\tcsum_partial(skb_transport_header(skb) + tlen,\n\t\t\t\t\t     offset, 0));\n\tput_cmsg(msg, SOL_IP, IP_CHECKSUM, sizeof(__wsum), &csum);\n}", "target": 1}
{"code": "build_model(XML_Parser parser) {\n  DTD *const dtd = parser->m_dtd; \n  XML_Content *ret;\n  XML_Char *str; \n#if UINT_MAX >= SIZE_MAX\n  if (dtd->scaffCount > (size_t)(-1) / sizeof(XML_Content)) {\n    return NULL;\n  }\n  if (dtd->contentStringLen > (size_t)(-1) / sizeof(XML_Char)) {\n    return NULL;\n  }\n#endif\n  if (dtd->scaffCount * sizeof(XML_Content)\n      > (size_t)(-1) - dtd->contentStringLen * sizeof(XML_Char)) {\n    return NULL;\n  }\n  const size_t allocsize = (dtd->scaffCount * sizeof(XML_Content)\n                            + (dtd->contentStringLen * sizeof(XML_Char)));\n  ret = (XML_Content *)MALLOC(parser, allocsize);\n  if (! ret)\n    return NULL;\n  XML_Content *dest = ret; \n  XML_Content *const destLimit = &ret[dtd->scaffCount];\n  XML_Content *const stackBottom = &ret[dtd->scaffCount];\n  XML_Content *stackTop = stackBottom; \n  str = (XML_Char *)&ret[dtd->scaffCount];\n  (--stackTop)->numchildren = 0;\n  for (; dest < destLimit; dest++) {\n    const int src_node = (int)(stackTop++)->numchildren;\n    dest->type = dtd->scaffold[src_node].type;\n    dest->quant = dtd->scaffold[src_node].quant;\n    if (dest->type == XML_CTYPE_NAME) {\n      const XML_Char *src;\n      dest->name = str;\n      src = dtd->scaffold[src_node].name;\n      for (;;) {\n        *str++ = *src;\n        if (! *src)\n          break;\n        src++;\n      }\n      dest->numchildren = 0;\n      dest->children = NULL;\n    } else {\n      unsigned int i;\n      int cn;\n      dest->name = NULL;\n      dest->numchildren = dtd->scaffold[src_node].childcnt;\n      dest->children = &dest[1];\n      stackTop -= dest->numchildren;\n      for (i = 0, cn = dtd->scaffold[src_node].firstchild;\n           i < dest->numchildren; i++, cn = dtd->scaffold[cn].nextsib) {\n        (stackTop + i)->numchildren = (unsigned int)cn;\n      }\n    }\n  }\n  return ret;\n}", "target": 0}
{"code": "static ssize_t cgroup_release_agent_write(struct kernfs_open_file *of,\n\t\t\t\t\t  char *buf, size_t nbytes, loff_t off)\n{\n\tstruct cgroup *cgrp;\n\tBUILD_BUG_ON(sizeof(cgrp->root->release_agent_path) < PATH_MAX);\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENODEV;\n\tspin_lock(&release_agent_path_lock);\n\tstrlcpy(cgrp->root->release_agent_path, strstrip(buf),\n\t\tsizeof(cgrp->root->release_agent_path));\n\tspin_unlock(&release_agent_path_lock);\n\tcgroup_kn_unlock(of->kn);\n\treturn nbytes;\n}", "target": 1}
{"code": "static inline bool is_flush_request(struct request *rq,\n\t\tstruct blk_flush_queue *fq, unsigned int tag)\n{\n\treturn ((rq->cmd_flags & REQ_FLUSH_SEQ) &&\n\t\t\tfq->flush_rq->tag == tag);\n}", "target": 1}
{"code": "void mp_obj_int_to_bytes_impl(mp_obj_t self_in, bool big_endian, size_t len, byte *buf) {\n    assert(mp_obj_is_exact_type(self_in, &mp_type_int));\n    mp_obj_int_t *self = self_in;\n    long long val = self->val;\n    if (big_endian) {\n        byte *b = buf + len;\n        while (b > buf) {\n            *--b = val;\n            val >>= 8;\n        }\n    } else {\n        for (; len > 0; --len) {\n            *buf++ = val;\n            val >>= 8;\n        }\n    }\n}", "target": 1}
{"code": "static int ep_loop_check_proc(void *priv, void *cookie, int call_nests)\n{\n\tint error = 0;\n\tstruct file *file = priv;\n\tstruct eventpoll *ep = file->private_data;\n\tstruct eventpoll *ep_tovisit;\n\tstruct rb_node *rbp;\n\tstruct epitem *epi;\n\tmutex_lock_nested(&ep->mtx, call_nests + 1);\n\tep->visited = 1;\n\tlist_add(&ep->visited_list_link, &visited_list);\n\tfor (rbp = rb_first_cached(&ep->rbr); rbp; rbp = rb_next(rbp)) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\t\tif (unlikely(is_file_epoll(epi->ffd.file))) {\n\t\t\tep_tovisit = epi->ffd.file->private_data;\n\t\t\tif (ep_tovisit->visited)\n\t\t\t\tcontinue;\n\t\t\terror = ep_call_nested(&poll_loop_ncalls,\n\t\t\t\t\tep_loop_check_proc, epi->ffd.file,\n\t\t\t\t\tep_tovisit, current);\n\t\t\tif (error != 0)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (list_empty(&epi->ffd.file->f_tfile_llink)) {\n\t\t\t\tget_file(epi->ffd.file);\n\t\t\t\tlist_add(&epi->ffd.file->f_tfile_llink,\n\t\t\t\t\t &tfile_check_list);\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&ep->mtx);\n\treturn error;\n}", "target": 1}
{"code": "static int ioapic_service(struct kvm_ioapic *ioapic, int irq, bool line_status)\n{\n\tunion kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];\n\tstruct kvm_lapic_irq irqe;\n\tint ret;\n\tif (entry->fields.mask)\n\t\treturn -1;\n\tioapic_debug(\"dest=%x dest_mode=%x delivery_mode=%x \"\n\t\t     \"vector=%x trig_mode=%x\\n\",\n\t\t     entry->fields.dest_id, entry->fields.dest_mode,\n\t\t     entry->fields.delivery_mode, entry->fields.vector,\n\t\t     entry->fields.trig_mode);\n\tirqe.dest_id = entry->fields.dest_id;\n\tirqe.vector = entry->fields.vector;\n\tirqe.dest_mode = entry->fields.dest_mode;\n\tirqe.trig_mode = entry->fields.trig_mode;\n\tirqe.delivery_mode = entry->fields.delivery_mode << 8;\n\tirqe.level = 1;\n\tirqe.shorthand = 0;\n\tif (irqe.trig_mode == IOAPIC_EDGE_TRIG)\n\t\tioapic->irr &= ~(1 << irq);\n\tif (irq == RTC_GSI && line_status) {\n\t\tBUG_ON(ioapic->rtc_status.pending_eoi != 0);\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe,\n\t\t\t\tioapic->rtc_status.dest_map);\n\t\tioapic->rtc_status.pending_eoi = ret;\n\t} else\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe, NULL);\n\tif (ret && irqe.trig_mode == IOAPIC_LEVEL_TRIG)\n\t\tentry->fields.remote_irr = 1;\n\treturn ret;\n}", "target": 1}
{"code": "static int is_fuse_usermount(struct libmnt_context *cxt, int *errsv)\n{\n\tstruct libmnt_ns *ns_old;\n\tconst char *type = mnt_fs_get_fstype(cxt->fs);\n\tconst char *optstr;\n\tchar *user_id = NULL;\n\tsize_t sz;\n\tuid_t uid;\n\tchar uidstr[sizeof(stringify_value(ULONG_MAX))];\n\t*errsv = 0;\n\tif (!type)\n\t\treturn 0;\n\tif (strcmp(type, \"fuse\") != 0 &&\n\t    strcmp(type, \"fuseblk\") != 0 &&\n\t    strncmp(type, \"fuse.\", 5) != 0 &&\n\t    strncmp(type, \"fuseblk.\", 8) != 0)\n\t\treturn 0;\n\toptstr = mnt_fs_get_fs_options(cxt->fs);\n\tif (!optstr)\n\t\treturn 0;\n\tif (mnt_optstr_get_option(optstr, \"user_id\", &user_id, &sz) != 0)\n\t\treturn 0;\n\tif (sz == 0 || user_id == NULL)\n\t\treturn 0;\n\tns_old = mnt_context_switch_origin_ns(cxt);\n\tif (!ns_old) {\n\t\t*errsv = -MNT_ERR_NAMESPACE;\n\t\treturn 0;\n\t}\n\tuid = getuid();\n\tif (!mnt_context_switch_ns(cxt, ns_old)) {\n\t\t*errsv = -MNT_ERR_NAMESPACE;\n\t\treturn 0;\n\t}\n\tsnprintf(uidstr, sizeof(uidstr), \"%lu\", (unsigned long) uid);\n\treturn strncmp(user_id, uidstr, sz) == 0;\n}", "target": 1}
{"code": "static int IntensityCompare(const void *x,const void *y)\n{\n  PixelPacket\n    *color_1,\n    *color_2;\n  ssize_t\n    intensity;\n  color_1=(PixelPacket *) x;\n  color_2=(PixelPacket *) y;\n  intensity=(ssize_t) PixelPacketIntensity(color_1)-\n    (ssize_t) PixelPacketIntensity(color_2);\n  return((int) intensity);\n}", "target": 1}
{"code": "static void f_parser (lua_State *L, void *ud) {\n  int i;\n  Proto *tf;\n  Closure *cl;\n  struct SParser *p = cast(struct SParser *, ud);\n  int c = luaZ_lookahead(p->z);\n  luaC_checkGC(L);\n  tf = ((c == LUA_SIGNATURE[0]) ? luaU_undump : luaY_parser)(L, p->z,\n                                                             &p->buff, p->name);\n  cl = luaF_newLclosure(L, tf->nups, hvalue(gt(L)));\n  cl->l.p = tf;\n  for (i = 0; i < tf->nups; i++)  \n    cl->l.upvals[i] = luaF_newupval(L);\n  setclvalue(L, L->top, cl);\n  incr_top(L);\n}", "target": 1}
{"code": "static int snd_ctl_elem_info_user(struct snd_ctl_file *ctl,\n\t\t\t\t  struct snd_ctl_elem_info __user *_info)\n{\n\tstruct snd_ctl_elem_info info;\n\tint result;\n\tif (copy_from_user(&info, _info, sizeof(info)))\n\t\treturn -EFAULT;\n\tsnd_power_lock(ctl->card);\n\tresult = snd_power_wait(ctl->card, SNDRV_CTL_POWER_D0);\n\tif (result >= 0)\n\t\tresult = snd_ctl_elem_info(ctl, &info);\n\tsnd_power_unlock(ctl->card);\n\tif (result >= 0)\n\t\tif (copy_to_user(_info, &info, sizeof(info)))\n\t\t\treturn -EFAULT;\n\treturn result;\n}", "target": 0}
{"code": "setup_connection (GsmXSMPClient *client)\n{\n        GIOChannel    *channel;\n        int            fd;\n        g_debug (\"GsmXSMPClient: Setting up new connection\");\n        fd = IceConnectionNumber (client->priv->ice_connection);\n        fcntl (fd, F_SETFD, fcntl (fd, F_GETFD, 0) | FD_CLOEXEC);\n        channel = g_io_channel_unix_new (fd);\n        client->priv->watch_id = g_io_add_watch (channel,\n                                                 G_IO_IN | G_IO_ERR,\n                                                 (GIOFunc)client_iochannel_watch,\n                                                 client);\n        g_io_channel_unref (channel);\n        client->priv->protocol_timeout = g_timeout_add_seconds (5,\n                                                                (GSourceFunc)_client_protocol_timeout,\n                                                                client);\n        set_description (client);\n        g_debug (\"GsmXSMPClient: New client '%s'\", client->priv->description);\n}", "target": 1}
{"code": "onig_scan_unsigned_number(UChar** src, const UChar* end, OnigEncoding enc)\n{\n  unsigned int num, val;\n  OnigCodePoint c;\n  UChar* p = *src;\n  PFETCH_READY;\n  num = 0;\n  while (! PEND) {\n    PFETCH(c);\n    if (IS_CODE_DIGIT_ASCII(enc, c)) {\n      val = (unsigned int )DIGITVAL(c);\n      if ((INT_MAX_LIMIT - val) / 10UL < num)\n        return -1;  \n      num = num * 10 + val;\n    }\n    else {\n      PUNFETCH;\n      break;\n    }\n  }\n  *src = p;\n  return num;\n}", "target": 0}
{"code": "TfLiteIntArray* TfLiteIntArrayCreate(int size) {\n  int alloc_size = TfLiteIntArrayGetSizeInBytes(size);\n  if (alloc_size <= 0) return NULL;\n  TfLiteIntArray* ret = (TfLiteIntArray*)malloc(alloc_size);\n  if (!ret) return ret;\n  ret->size = size;\n  return ret;\n}", "target": 1}
{"code": "smb3_receive_transform(struct TCP_Server_Info *server,\n\t\t       struct mid_q_entry **mids, char **bufs, int *num_mids)\n{\n\tchar *buf = server->smallbuf;\n\tunsigned int pdu_length = server->pdu_size;\n\tstruct smb2_transform_hdr *tr_hdr = (struct smb2_transform_hdr *)buf;\n\tunsigned int orig_len = le32_to_cpu(tr_hdr->OriginalMessageSize);\n\tif (pdu_length < sizeof(struct smb2_transform_hdr) +\n\t\t\t\t\t\tsizeof(struct smb2_hdr)) {\n\t\tcifs_server_dbg(VFS, \"Transform message is too small (%u)\\n\",\n\t\t\t pdu_length);\n\t\tcifs_reconnect(server, true);\n\t\treturn -ECONNABORTED;\n\t}\n\tif (pdu_length < orig_len + sizeof(struct smb2_transform_hdr)) {\n\t\tcifs_server_dbg(VFS, \"Transform message is broken\\n\");\n\t\tcifs_reconnect(server, true);\n\t\treturn -ECONNABORTED;\n\t}\n\tif (pdu_length > CIFSMaxBufSize + MAX_HEADER_SIZE(server)) {\n\t\treturn receive_encrypted_read(server, &mids[0], num_mids);\n\t}\n\treturn receive_encrypted_standard(server, mids, bufs, num_mids);\n}", "target": 0}
{"code": "_dl_dst_count (const char *name, int is_path)\n{\n  size_t cnt = 0;\n  do\n    {\n      size_t len = 1;\n      if ((((!__libc_enable_secure\n\t     && strncmp (&name[1], \"ORIGIN\", 6) == 0 && (len = 7) != 0)\n\t    || (strncmp (&name[1], \"PLATFORM\", 8) == 0 && (len = 9) != 0))\n\t   && (name[len] == '\\0' || name[len] == '/'\n\t       || (is_path && name[len] == ':')))\n\t  || (name[1] == '{'\n\t      && ((!__libc_enable_secure\n\t\t   && strncmp (&name[2], \"ORIGIN}\", 7) == 0 && (len = 9) != 0)\n\t\t  || (strncmp (&name[2], \"PLATFORM}\", 9) == 0\n\t\t      && (len = 11) != 0))))\n\t++cnt;\n      name = strchr (name + len, '$');\n    }\n  while (name != NULL);\n  return cnt;\n}", "target": 1}
{"code": "static void common_hrtimer_rearm(struct k_itimer *timr)\n{\n\tstruct hrtimer *timer = &timr->it.real.timer;\n\tif (!timr->it_interval)\n\t\treturn;\n\ttimr->it_overrun += (unsigned int) hrtimer_forward(timer,\n\t\t\t\t\t\ttimer->base->get_time(),\n\t\t\t\t\t\ttimr->it_interval);\n\thrtimer_restart(timer);\n}", "target": 1}
{"code": "static void keyring_describe(const struct key *keyring, struct seq_file *m)\n{\n\tif (keyring->description)\n\t\tseq_puts(m, keyring->description);\n\telse\n\t\tseq_puts(m, \"[anon]\");\n\tif (key_is_instantiated(keyring)) {\n\t\tif (keyring->keys.nr_leaves_on_tree != 0)\n\t\t\tseq_printf(m, \": %lu\", keyring->keys.nr_leaves_on_tree);\n\t\telse\n\t\t\tseq_puts(m, \": empty\");\n\t}\n}", "target": 1}
{"code": "static void uc_invalidate_tb(struct uc_struct *uc, uint64_t start_addr, size_t len) \n{\n    tb_page_addr_t start, end;\n    start = get_page_addr_code(uc->cpu->env_ptr, start_addr) & (target_ulong)(-1);\n    end = (start + len) & (target_ulong)(-1);\n    if (start > end) {\n        return;\n    }\n    tb_invalidate_phys_range(uc, start, end);\n}", "target": 1}
{"code": "int av_hwframe_ctx_init(AVBufferRef *ref)\n{\n    AVHWFramesContext *ctx = (AVHWFramesContext*)ref->data;\n    const enum AVPixelFormat *pix_fmt;\n    int ret;\n    if (ctx->internal->source_frames) {\n        return 0;\n    }\n    for (pix_fmt = ctx->internal->hw_type->pix_fmts; *pix_fmt != AV_PIX_FMT_NONE; pix_fmt++) {\n        if (*pix_fmt == ctx->format)\n            break;\n    }\n    if (*pix_fmt == AV_PIX_FMT_NONE) {\n        av_log(ctx, AV_LOG_ERROR,\n               \"The hardware pixel format '%s' is not supported by the device type '%s'\\n\",\n               av_get_pix_fmt_name(ctx->format), ctx->internal->hw_type->name);\n        return AVERROR(ENOSYS);\n    }\n    ret = av_image_check_size(ctx->width, ctx->height, 0, ctx);\n    if (ret < 0)\n        return ret;\n    if (ctx->internal->hw_type->frames_init) {\n        ret = ctx->internal->hw_type->frames_init(ctx);\n        if (ret < 0)\n            goto fail;\n    }\n    if (ctx->internal->pool_internal && !ctx->pool)\n        ctx->pool = ctx->internal->pool_internal;\n    if (ctx->initial_pool_size > 0) {\n        ret = hwframe_pool_prealloc(ref);\n        if (ret < 0)\n            goto fail;\n    }\n    return 0;\nfail:\n    if (ctx->internal->hw_type->frames_uninit)\n        ctx->internal->hw_type->frames_uninit(ctx);\n    return ret;\n}", "target": 1}
{"code": "Pl_ASCIIHexDecoder::flush()\n{\n    if (this->pos == 0)\n    {\n\tQTC::TC(\"libtests\", \"Pl_ASCIIHexDecoder no-op flush\");\n\treturn;\n    }\n    int b[2];\n    for (int i = 0; i < 2; ++i)\n    {\n\tif (this->inbuf[i] >= 'A')\n\t{\n\t    b[i] = this->inbuf[i] - 'A' + 10;\n\t}\n\telse\n\t{\n\t    b[i] = this->inbuf[i] - '0';\n\t}\n    }\n    unsigned char ch = static_cast<unsigned char>((b[0] << 4) + b[1]);\n    QTC::TC(\"libtests\", \"Pl_ASCIIHexDecoder partial flush\",\n\t    (this->pos == 2) ? 0 : 1);\n    getNext()->write(&ch, 1);\n    this->pos = 0;\n    this->inbuf[0] = '0';\n    this->inbuf[1] = '0';\n    this->inbuf[2] = '\\0';\n}", "target": 1}
{"code": "static struct desc_struct *get_desc(unsigned short sel)\n{\n\tstruct desc_ptr gdt_desc = {0, 0};\n\tunsigned long desc_base;\n#ifdef CONFIG_MODIFY_LDT_SYSCALL\n\tif ((sel & SEGMENT_TI_MASK) == SEGMENT_LDT) {\n\t\tstruct desc_struct *desc = NULL;\n\t\tstruct ldt_struct *ldt;\n\t\tsel >>= 3;\n\t\tmutex_lock(&current->active_mm->context.lock);\n\t\tldt = current->active_mm->context.ldt;\n\t\tif (ldt && sel < ldt->nr_entries)\n\t\t\tdesc = &ldt->entries[sel];\n\t\tmutex_unlock(&current->active_mm->context.lock);\n\t\treturn desc;\n\t}\n#endif\n\tnative_store_gdt(&gdt_desc);\n\tdesc_base = sel & ~(SEGMENT_RPL_MASK | SEGMENT_TI_MASK);\n\tif (desc_base > gdt_desc.size)\n\t\treturn NULL;\n\treturn (struct desc_struct *)(gdt_desc.address + desc_base);\n}", "target": 1}
{"code": "static int get_gate_page(struct mm_struct *mm, unsigned long address,\n\t\tunsigned int gup_flags, struct vm_area_struct **vma,\n\t\tstruct page **page)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *pte;\n\tint ret = -EFAULT;\n\tif (gup_flags & FOLL_WRITE)\n\t\treturn -EFAULT;\n\tif (address > TASK_SIZE)\n\t\tpgd = pgd_offset_k(address);\n\telse\n\t\tpgd = pgd_offset_gate(mm, address);\n\tBUG_ON(pgd_none(*pgd));\n\tp4d = p4d_offset(pgd, address);\n\tBUG_ON(p4d_none(*p4d));\n\tpud = pud_offset(p4d, address);\n\tBUG_ON(pud_none(*pud));\n\tpmd = pmd_offset(pud, address);\n\tif (!pmd_present(*pmd))\n\t\treturn -EFAULT;\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\tpte = pte_offset_map(pmd, address);\n\tif (pte_none(*pte))\n\t\tgoto unmap;\n\t*vma = get_gate_vma(mm);\n\tif (!page)\n\t\tgoto out;\n\t*page = vm_normal_page(*vma, address, *pte);\n\tif (!*page) {\n\t\tif ((gup_flags & FOLL_DUMP) || !is_zero_pfn(pte_pfn(*pte)))\n\t\t\tgoto unmap;\n\t\t*page = pte_page(*pte);\n\t\tif (is_device_public_page(*page))\n\t\t\tgoto unmap;\n\t}\n\tget_page(*page);\nout:\n\tret = 0;\nunmap:\n\tpte_unmap(pte);\n\treturn ret;\n}", "target": 1}
{"code": "static void floppy_shutdown(struct work_struct *arg)\n{\n\tunsigned long flags;\n\tif (initialized)\n\t\tshow_floppy();\n\tcancel_activity();\n\tflags = claim_dma_lock();\n\tfd_disable_dma();\n\trelease_dma_lock(flags);\n\tif (initialized)\n\t\tDPRINT(\"floppy timeout called\\n\");\n\tFDCS->reset = 1;\n\tif (cont) {\n\t\tcont->done(0);\n\t\tcont->redo();\t\n\t} else {\n\t\tpr_info(\"no cont in shutdown!\\n\");\n\t\tprocess_fd_request();\n\t}\n\tis_alive(__func__, \"\");\n}", "target": 0}
{"code": "static struct block_device *ext3_blkdev_get(dev_t dev, struct super_block *sb)\n{\n\tstruct block_device *bdev;\n\tchar b[BDEVNAME_SIZE];\n\tbdev = blkdev_get_by_dev(dev, FMODE_READ|FMODE_WRITE|FMODE_EXCL, sb);\n\tif (IS_ERR(bdev))\n\t\tgoto fail;\n\treturn bdev;\nfail:\n\text3_msg(sb, \"error: failed to open journal device %s: %ld\",\n\t\t__bdevname(dev, b), PTR_ERR(bdev));\n\treturn NULL;\n}", "target": 1}
{"code": "#ifndef GPAC_DISABLE_ISOM_HINTING\nvoid dump_isom_sdp(GF_ISOFile *file, char *inName, Bool is_final_name)\n{\n\tconst char *sdp;\n\tu32 size, i;\n\tFILE *dump;\n\tif (inName) {\n\t\tchar szBuf[1024];\n\t\tstrcpy(szBuf, inName);\n\t\tif (!is_final_name) {\n\t\t\tchar *ext = strchr(szBuf, '.');\n\t\t\tif (ext) ext[0] = 0;\n\t\t\tstrcat(szBuf, \"_sdp.txt\");\n\t\t}\n\t\tdump = gf_fopen(szBuf, \"wt\");\n\t\tif (!dump) {\n\t\t\tfprintf(stderr, \"Failed to open %s for dumping\\n\", szBuf);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tdump = stdout;\n\t\tfprintf(dump, \"* File SDP content *\\n\\n\");\n\t}\n\tgf_isom_sdp_get(file, &sdp, &size);\n\tfprintf(dump, \"%s\", sdp);\n\tfprintf(dump, \"\\r\\n\");\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\tif (gf_isom_get_media_type(file, i+1) != GF_ISOM_MEDIA_HINT) continue;\n\t\tgf_isom_sdp_track_get(file, i+1, &sdp, &size);\n\t\tfprintf(dump, \"%s\", sdp);\n\t}\n\tfprintf(dump, \"\\n\\n\");", "target": 1}
{"code": "static void expire_cfs_rq_runtime(struct cfs_rq *cfs_rq)\n{\n\tstruct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(cfs_rq->tg);\n\tif (likely((s64)(rq_clock(rq_of(cfs_rq)) - cfs_rq->runtime_expires) < 0))\n\t\treturn;\n\tif (cfs_rq->runtime_remaining < 0)\n\t\treturn;\n\tif (cfs_rq->expires_seq == cfs_b->expires_seq) {\n\t\tcfs_rq->runtime_expires += TICK_NSEC;\n\t} else {\n\t\tcfs_rq->runtime_remaining = 0;\n\t}\n}", "target": 1}
{"code": "  DeletionConfirmationDlg(QWidget *parent, const int &size, const QString &name, bool defaultDeleteFiles): QDialog(parent) {\n    setupUi(this);\n    if (size == 1)\n      label->setText(tr(\"Are you sure you want to delete '%1' from the transfer list?\", \"Are you sure you want to delete 'ubuntu-linux-iso' from the transfer list?\").arg(name));\n    else\n      label->setText(tr(\"Are you sure you want to delete these %1 torrents from the transfer list?\", \"Are you sure you want to delete these 5 torrents from the transfer list?\").arg(QString::number(size)));\n    lbl_warn->setPixmap(GuiIconProvider::instance()->getIcon(\"dialog-warning\").pixmap(lbl_warn->height()));\n    lbl_warn->setFixedWidth(lbl_warn->height());\n    rememberBtn->setIcon(GuiIconProvider::instance()->getIcon(\"object-locked\"));\n    move(Utils::Misc::screenCenter(this));\n    checkPermDelete->setChecked(defaultDeleteFiles || Preferences::instance()->deleteTorrentFilesAsDefault());\n    connect(checkPermDelete, SIGNAL(clicked()), this, SLOT(updateRememberButtonState()));\n    buttonBox->button(QDialogButtonBox::Cancel)->setFocus();\n  }", "target": 1}
{"code": "inline bool SegmentReader::containsInterval(const void* from, const void* to) {\n  return from >= this->ptr.begin() && to <= this->ptr.end() && from <= to &&\n      readLimiter->canRead(\n          intervalLength(reinterpret_cast<const byte*>(from),\n                         reinterpret_cast<const byte*>(to),\n                         MAX_SEGMENT_WORDS * BYTES_PER_WORD)\n              / BYTES_PER_WORD,\n          arena);\n}", "target": 1}
{"code": "static int copy_verifier_state(struct bpf_verifier_state *dst_state,\n\t\t\t       const struct bpf_verifier_state *src)\n{\n\tstruct bpf_func_state *dst;\n\tu32 jmp_sz = sizeof(struct bpf_idx_pair) * src->jmp_history_cnt;\n\tint i, err;\n\tif (dst_state->jmp_history_cnt < src->jmp_history_cnt) {\n\t\tkfree(dst_state->jmp_history);\n\t\tdst_state->jmp_history = kmalloc(jmp_sz, GFP_USER);\n\t\tif (!dst_state->jmp_history)\n\t\t\treturn -ENOMEM;\n\t}\n\tmemcpy(dst_state->jmp_history, src->jmp_history, jmp_sz);\n\tdst_state->jmp_history_cnt = src->jmp_history_cnt;\n\tfor (i = src->curframe + 1; i <= dst_state->curframe; i++) {\n\t\tfree_func_state(dst_state->frame[i]);\n\t\tdst_state->frame[i] = NULL;\n\t}\n\tdst_state->speculative = src->speculative;\n\tdst_state->curframe = src->curframe;\n\tdst_state->active_spin_lock = src->active_spin_lock;\n\tdst_state->branches = src->branches;\n\tdst_state->parent = src->parent;\n\tdst_state->first_insn_idx = src->first_insn_idx;\n\tdst_state->last_insn_idx = src->last_insn_idx;\n\tfor (i = 0; i <= src->curframe; i++) {\n\t\tdst = dst_state->frame[i];\n\t\tif (!dst) {\n\t\t\tdst = kzalloc(sizeof(*dst), GFP_KERNEL);\n\t\t\tif (!dst)\n\t\t\t\treturn -ENOMEM;\n\t\t\tdst_state->frame[i] = dst;\n\t\t}\n\t\terr = copy_func_state(dst, src->frame[i]);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static void ml_ff_destroy(struct ff_device *ff)\n{\n\tstruct ml_device *ml = ff->private;\n\tkfree(ml->private);\n}", "target": 1}
{"code": "int RGWGetObj_ObjStore_S3Website::send_response_data(bufferlist& bl, off_t bl_ofs, off_t bl_len) {\n  map<string, bufferlist>::iterator iter;\n  iter = attrs.find(RGW_ATTR_AMZ_WEBSITE_REDIRECT_LOCATION);\n  if (iter != attrs.end()) {\n    bufferlist &bl = iter->second;\n    s->redirect = bl.c_str();\n    s->err.http_ret = 301;\n    ldout(s->cct, 20) << __CEPH_ASSERT_FUNCTION << \" redirecting per x-amz-website-redirect-location=\" << s->redirect << dendl;\n    op_ret = -ERR_WEBSITE_REDIRECT;\n    set_req_state_err(s, op_ret);\n    dump_errno(s);\n    dump_content_length(s, 0);\n    dump_redirect(s, s->redirect);\n    end_header(s, this);\n    return op_ret;\n  } else {\n    return RGWGetObj_ObjStore_S3::send_response_data(bl, bl_ofs, bl_len);\n  }\n}", "target": 0}
{"code": "bool inode_capable(const struct inode *inode, int cap)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\treturn ns_capable(ns, cap) && kuid_has_mapping(ns, inode->i_uid);\n}", "target": 1}
{"code": "raptor_libxml_getEntity(void* user_data, const xmlChar *name) {\n  raptor_sax2* sax2 = (raptor_sax2*)user_data;\n  return libxml2_getEntity(sax2->xc, name);\n}", "target": 1}
{"code": "date_initialize(int argc, VALUE *argv, VALUE self)\n{\n    VALUE vy, vm, vd, vsg, y, fr, fr2, ret;\n    int m, d;\n    double sg;\n    struct SimpleDateData *dat = rb_check_typeddata(self, &d_lite_type);\n    if (!simple_dat_p(dat)) {\n\trb_raise(rb_eTypeError, \"Date expected\");\n    }\n    rb_scan_args(argc, argv, \"04\", &vy, &vm, &vd, &vsg);\n    y = INT2FIX(-4712);\n    m = 1;\n    d = 1;\n    fr2 = INT2FIX(0);\n    sg = DEFAULT_SG;\n    switch (argc) {\n      case 4:\n\tval2sg(vsg, sg);\n      case 3:\n        check_numeric(vd, \"day\");\n\tnum2int_with_frac(d, positive_inf);\n      case 2:\n        check_numeric(vm, \"month\");\n\tm = NUM2INT(vm);\n      case 1:\n        check_numeric(vy, \"year\");\n\ty = vy;\n    }\n    if (guess_style(y, sg) < 0) {\n\tVALUE nth;\n\tint ry, rm, rd;\n\tif (!valid_gregorian_p(y, m, d,\n\t\t\t       &nth, &ry,\n\t\t\t       &rm, &rd))\n\t    rb_raise(eDateError, \"invalid date\");\n\tset_to_simple(self, dat, nth, 0, sg, ry, rm, rd, HAVE_CIVIL);\n    }\n    else {\n\tVALUE nth;\n\tint ry, rm, rd, rjd, ns;\n\tif (!valid_civil_p(y, m, d, sg,\n\t\t\t   &nth, &ry,\n\t\t\t   &rm, &rd, &rjd,\n\t\t\t   &ns))\n\t    rb_raise(eDateError, \"invalid date\");\n\tset_to_simple(self, dat, nth, rjd, sg, ry, rm, rd, HAVE_JD | HAVE_CIVIL);\n    }\n    ret = self;\n    add_frac();\n    return ret;\n}", "target": 0}
{"code": "ldns_fget_keyword_data(FILE *f, const char *keyword, const char *k_del, char *data,\n               const char *d_del, size_t data_limit)\n{\n       return ldns_fget_keyword_data_l(f, keyword, k_del, data, d_del,\n\t\t       data_limit, NULL);\n}", "target": 0}
{"code": "static int nfs_can_extend_write(struct file *file, struct page *page, struct inode *inode)\n{\n\tif (file->f_flags & O_DSYNC)\n\t\treturn 0;\n\tif (NFS_PROTO(inode)->have_delegation(inode, FMODE_WRITE))\n\t\treturn 1;\n\tif (nfs_write_pageuptodate(page, inode) && (inode->i_flock == NULL ||\n\t\t\t(inode->i_flock->fl_start == 0 &&\n\t\t\tinode->i_flock->fl_end == OFFSET_MAX &&\n\t\t\tinode->i_flock->fl_type != F_RDLCK)))\n\t\treturn 1;\n\treturn 0;\n}", "target": 1}
{"code": "iasecc_pin_get_status(struct sc_card *card, struct sc_pin_cmd_data *data, int *tries_left)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_pin_cmd_data info;\n\tint rv;\n\tLOG_FUNC_CALLED(ctx);\n\tif (data->pin_type != SC_AC_CHV)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"PIN type is not supported for status\");\n\tmemset(&info, 0, sizeof(info));\n\tinfo.cmd = SC_PIN_CMD_GET_INFO;\n\tinfo.pin_type = data->pin_type;\n\tinfo.pin_reference = data->pin_reference;\n\trv = iso_ops->pin_cmd(card, &info, tries_left);\n\tLOG_TEST_RET(ctx, rv, \"Failed to get PIN info\");\n\tdata->pin1.max_tries = info.pin1.max_tries;\n\tdata->pin1.tries_left = info.pin1.tries_left;\n\tdata->pin1.logged_in = info.pin1.logged_in;\n\tLOG_FUNC_RETURN(ctx, rv);\n}", "target": 0}
{"code": "_gnutls_x509_oid2mac_algorithm (const char *oid)\n{\n  gnutls_mac_algorithm_t ret = 0;\n  GNUTLS_HASH_LOOP (if (strcmp (oid, p->oid) == 0)\n\t\t    {\n\t\t    ret = p->id; break;}\n  );\n  if (ret == 0)\n    return GNUTLS_MAC_UNKNOWN;\n  return ret;\n}", "target": 1}
{"code": "void decompTest(tjhandle handle, unsigned char *jpegBuf,\n\tunsigned long jpegSize, int w, int h, int pf, char *basename, int subsamp,\n\tint flags)\n{\n\tint i, n=0;\n\ttjscalingfactor *sf=tjGetScalingFactors(&n);\n\tif(!sf || !n) _throwtj();\n\tfor(i=0; i<n; i++)\n\t{\n\t\tif(subsamp==TJSAMP_444 || subsamp==TJSAMP_GRAY ||\n\t\t\t(subsamp==TJSAMP_411 && sf[i].num==1 &&\n\t\t\t\t(sf[i].denom==2 || sf[i].denom==1)) ||\n\t\t\t(subsamp!=TJSAMP_411 && sf[i].num==1 &&\n\t\t\t\t(sf[i].denom==4 || sf[i].denom==2 || sf[i].denom==1)))\n\t\t\t_decompTest(handle, jpegBuf, jpegSize, w, h, pf, basename, subsamp,\n\t\t\t\tflags, sf[i]);\n\t}\n\tbailout:\n\treturn;\n}", "target": 0}
{"code": "static int prepare_func_exit(struct bpf_verifier_env *env, int *insn_idx)\n{\n\tstruct bpf_verifier_state *state = env->cur_state;\n\tstruct bpf_func_state *caller, *callee;\n\tstruct bpf_reg_state *r0;\n\tint err;\n\tcallee = state->frame[state->curframe];\n\tr0 = &callee->regs[BPF_REG_0];\n\tif (r0->type == PTR_TO_STACK) {\n\t\tverbose(env, \"cannot return stack pointer to the caller\\n\");\n\t\treturn -EINVAL;\n\t}\n\tstate->curframe--;\n\tcaller = state->frame[state->curframe];\n\tif (callee->in_callback_fn) {\n\t\tstruct tnum range = tnum_range(0, 1);\n\t\tif (r0->type != SCALAR_VALUE) {\n\t\t\tverbose(env, \"R0 not a scalar value\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (!tnum_in(range, r0->var_off)) {\n\t\t\tverbose_invalid_scalar(env, r0, &range, \"callback return\", \"R0\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tcaller->regs[BPF_REG_0] = *r0;\n\t}\n\terr = copy_reference_state(caller, callee);\n\tif (err)\n\t\treturn err;\n\t*insn_idx = callee->callsite + 1;\n\tif (env->log.level & BPF_LOG_LEVEL) {\n\t\tverbose(env, \"returning from callee:\\n\");\n\t\tprint_verifier_state(env, callee);\n\t\tverbose(env, \"to caller at %d:\\n\", *insn_idx);\n\t\tprint_verifier_state(env, caller);\n\t}\n\tfree_func_state(callee);\n\tstate->frame[state->curframe + 1] = NULL;\n\treturn 0;\n}", "target": 0}
{"code": "int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu, struct kvm_run *run)\n{\n\tint ret;\n\tsigset_t sigsaved;\n\tif (unlikely(vcpu->arch.target < 0))\n\t\treturn -ENOEXEC;\n\tret = kvm_vcpu_first_run_init(vcpu);\n\tif (ret)\n\t\treturn ret;\n\tif (run->exit_reason == KVM_EXIT_MMIO) {\n\t\tret = kvm_handle_mmio_return(vcpu, vcpu->run);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (vcpu->sigset_active)\n\t\tsigprocmask(SIG_SETMASK, &vcpu->sigset, &sigsaved);\n\tret = 1;\n\trun->exit_reason = KVM_EXIT_UNKNOWN;\n\twhile (ret > 0) {\n\t\tcond_resched();\n\t\tupdate_vttbr(vcpu->kvm);\n\t\tif (vcpu->arch.pause)\n\t\t\tvcpu_pause(vcpu);\n\t\tkvm_vgic_flush_hwstate(vcpu);\n\t\tkvm_timer_flush_hwstate(vcpu);\n\t\tlocal_irq_disable();\n\t\tif (signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\trun->exit_reason = KVM_EXIT_INTR;\n\t\t}\n\t\tif (ret <= 0 || need_new_vmid_gen(vcpu->kvm)) {\n\t\t\tlocal_irq_enable();\n\t\t\tkvm_timer_sync_hwstate(vcpu);\n\t\t\tkvm_vgic_sync_hwstate(vcpu);\n\t\t\tcontinue;\n\t\t}\n\t\ttrace_kvm_entry(*vcpu_pc(vcpu));\n\t\tkvm_guest_enter();\n\t\tvcpu->mode = IN_GUEST_MODE;\n\t\tret = kvm_call_hyp(__kvm_vcpu_run, vcpu);\n\t\tvcpu->mode = OUTSIDE_GUEST_MODE;\n\t\tvcpu->arch.last_pcpu = smp_processor_id();\n\t\tkvm_guest_exit();\n\t\ttrace_kvm_exit(*vcpu_pc(vcpu));\n\t\tlocal_irq_enable();\n\t\tkvm_timer_sync_hwstate(vcpu);\n\t\tkvm_vgic_sync_hwstate(vcpu);\n\t\tret = handle_exit(vcpu, run, ret);\n\t}\n\tif (vcpu->sigset_active)\n\t\tsigprocmask(SIG_SETMASK, &sigsaved, NULL);\n\treturn ret;\n}", "target": 1}
{"code": "void SSH_Access::LogSSHMessage()\n{\n   const char *b;\n   int s;\n   pty_recv_buf->Get(&b,&s);\n   const char *eol=find_char(b,s,'\\n');\n   if(!eol)\n   {\n      if(pty_recv_buf->Eof())\n      {\n\t if(s>0)\n\t    LogRecv(4,b);\n\t LogError(0,_(\"Peer closed connection\"));\n      }\n      if(pty_recv_buf->Error())\n\t LogError(4,\"pty read: %s\",pty_recv_buf->ErrorText());\n      if(pty_recv_buf->Eof() || pty_recv_buf->Error()) {\n\t if(last_ssh_message && time_t(now)-last_ssh_message_time<4)\n\t    LogError(0,\"%s\",last_ssh_message.get());\n\t Disconnect(last_ssh_message);\n      }\n      return;\n   }\n   s=eol-b+1;\n   int chomp_cr=(s>=2 && b[s-2]=='\\r');\n   last_ssh_message.nset(b,s-1-chomp_cr);\n   last_ssh_message_time=now;\n   pty_recv_buf->Skip(s);\n   LogRecv(4,last_ssh_message);\n   if(last_ssh_message.begins_with(\"ssh: \"))\n      last_ssh_message.set(last_ssh_message+5);\n   if(!received_greeting && last_ssh_message.eq(greeting))\n      received_greeting=true;\n}", "target": 0}
{"code": " */\nstatic struct sk_buff *napi_frags_skb(struct napi_struct *napi)\n{\n\tstruct sk_buff *skb = napi->skb;\n\tconst struct ethhdr *eth;\n\tunsigned int hlen = sizeof(*eth);\n\tnapi->skb = NULL;\n\tskb_reset_mac_header(skb);\n\tskb_gro_reset_offset(skb);\n\teth = skb_gro_header_fast(skb, 0);\n\tif (unlikely(skb_gro_header_hard(skb, hlen))) {\n\t\teth = skb_gro_header_slow(skb, hlen, 0);\n\t\tif (unlikely(!eth)) {\n\t\t\tnet_warn_ratelimited(\"%s: dropping impossible skb from %s\\n\",\n\t\t\t\t\t     __func__, napi->dev->name);\n\t\t\tnapi_reuse_skb(napi, skb);\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\tgro_pull_from_frag0(skb, hlen);\n\t\tNAPI_GRO_CB(skb)->frag0 += hlen;\n\t\tNAPI_GRO_CB(skb)->frag0_len -= hlen;\n\t}\n\t__skb_pull(skb, hlen);\n\tskb->protocol = eth->h_proto;\n\treturn skb;", "target": 1}
{"code": "static void cleanup_key_data(context, count, data)\n    krb5_context   context;\n    int                    count;\n    krb5_key_data        * data;\n{\n    int i, j;\n    for (i = 0; i < count; i++)\n        for (j = 0; j < data[i].key_data_ver; j++)\n            if (data[i].key_data_length[j])\n                krb5_db_free(context, data[i].key_data_contents[j]);\n    krb5_db_free(context, data);\n}", "target": 0}
{"code": "static int atalk_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t int *uaddr_len, int peer)\n{\n\tstruct sockaddr_at sat;\n\tstruct sock *sk = sock->sk;\n\tstruct atalk_sock *at = at_sk(sk);\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tif (atalk_autobind(sk) < 0)\n\t\t\treturn -ENOBUFS;\n\t*uaddr_len = sizeof(struct sockaddr_at);\n\tif (peer) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\t\tsat.sat_addr.s_net  = at->dest_net;\n\t\tsat.sat_addr.s_node = at->dest_node;\n\t\tsat.sat_port\t    = at->dest_port;\n\t} else {\n\t\tsat.sat_addr.s_net  = at->src_net;\n\t\tsat.sat_addr.s_node = at->src_node;\n\t\tsat.sat_port\t    = at->src_port;\n\t}\n\tsat.sat_family = AF_APPLETALK;\n\tmemcpy(uaddr, &sat, sizeof(sat));\n\treturn 0;\n}", "target": 1}
{"code": "static void iommu_enable_dev_iotlb(struct device_domain_info *info)\n{\n\tstruct pci_dev *pdev;\n\tassert_spin_locked(&device_domain_lock);\n\tif (!info || !dev_is_pci(info->dev))\n\t\treturn;\n\tpdev = to_pci_dev(info->dev);\n\tif (!ecap_dit(info->iommu->ecap))\n\t\tinfo->pfsid = 0;\n\telse {\n\t\tstruct pci_dev *pf_pdev;\n\t\tpf_pdev = pci_physfn(pdev);\n\t\tinfo->pfsid = PCI_DEVID(pf_pdev->bus->number, pf_pdev->devfn);\n\t}\n#ifdef CONFIG_INTEL_IOMMU_SVM\n\tif (info->pasid_supported && !pci_enable_pasid(pdev, info->pasid_supported & ~1))\n\t\tinfo->pasid_enabled = 1;\n\tif (info->pri_supported && !pci_reset_pri(pdev) && !pci_enable_pri(pdev, 32))\n\t\tinfo->pri_enabled = 1;\n#endif\n\tif (!pdev->untrusted && info->ats_supported &&\n\t    !pci_enable_ats(pdev, VTD_PAGE_SHIFT)) {\n\t\tinfo->ats_enabled = 1;\n\t\tdomain_update_iotlb(info->domain);\n\t\tinfo->ats_qdep = pci_ats_queue_depth(pdev);\n\t}\n}", "target": 0}
{"code": "int iwch_cxgb3_ofld_send(struct t3cdev *tdev, struct sk_buff *skb)\n{\n\tint\terror = 0;\n\tstruct cxio_rdev *rdev;\n\trdev = (struct cxio_rdev *)tdev->ulp;\n\tif (cxio_fatal_error(rdev)) {\n\t\tkfree_skb(skb);\n\t\treturn -EIO;\n\t}\n\terror = cxgb3_ofld_send(tdev, skb);\n\tif (error < 0)\n\t\tkfree_skb(skb);\n\treturn error;\n}", "target": 1}
{"code": "MagickExport LinkedListInfo *GetLocaleOptions(const char *filename,\n  ExceptionInfo *exception)\n{\n  char\n    path[MagickPathExtent];\n  const char\n    *element;\n  LinkedListInfo\n    *messages,\n    *paths;\n  StringInfo\n    *xml;\n  assert(filename != (const char *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  (void) CopyMagickString(path,filename,MagickPathExtent);\n  messages=NewLinkedList(0);\n  paths=GetConfigurePaths(filename,exception);\n  if (paths != (LinkedListInfo *) NULL)\n    {\n      ResetLinkedListIterator(paths);\n      element=(const char *) GetNextValueInLinkedList(paths);\n      while (element != (const char *) NULL)\n      {\n        (void) FormatLocaleString(path,MagickPathExtent,\"%s%s\",element,\n          filename);\n        (void) LogMagickEvent(LocaleEvent,GetMagickModule(),\n          \"Searching for locale file: \\\"%s\\\"\",path);\n        xml=ConfigureFileToStringInfo(path);\n        if (xml != (StringInfo *) NULL)\n          (void) AppendValueToLinkedList(messages,xml);\n        element=(const char *) GetNextValueInLinkedList(paths);\n      }\n      paths=DestroyLinkedList(paths,RelinquishMagickMemory);\n    }\n#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n  {\n    char\n      *blob;\n    blob=(char *) NTResourceToBlob(filename);\n    if (blob != (char *) NULL)\n      {\n        xml=AcquireStringInfo(0);\n        SetStringInfoLength(xml,strlen(blob)+1);\n        SetStringInfoDatum(xml,(const unsigned char *) blob);\n        blob=(char *) RelinquishMagickMemory(blob);\n        SetStringInfoPath(xml,filename);\n        (void) AppendValueToLinkedList(messages,xml);\n      }\n  }\n#endif\n  ResetLinkedListIterator(messages);\n  return(messages);\n}", "target": 0}
{"code": "static void dns_resolver_describe(const struct key *key, struct seq_file *m)\n{\n\tseq_puts(m, key->description);\n\tif (key_is_instantiated(key)) {\n\t\tint err = PTR_ERR(key->payload.data[dns_key_error]);\n\t\tif (err)\n\t\t\tseq_printf(m, \": %d\", err);\n\t\telse\n\t\t\tseq_printf(m, \": %u\", key->datalen);\n\t}\n}", "target": 1}
{"code": "void gdImagePaletteCopy (gdImagePtr to, gdImagePtr from)\n{\n\tint i;\n\tint x, y, p;\n\tint xlate[256];\n\tif (to->trueColor || from->trueColor) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < 256; i++) {\n\t\txlate[i] = -1;\n\t}\n\tfor (y = 0; y < to->sy; y++) {\n\t\tfor (x = 0; x < to->sx; x++) {\n\t\t\tp = gdImageGetPixel(to, x, y);\n\t\t\tif (xlate[p] == -1) {\n\t\t\t\txlate[p] = gdImageColorClosestAlpha (from, to->red[p], to->green[p], to->blue[p], to->alpha[p]);\n\t\t\t}\n\t\t\tgdImageSetPixel(to, x, y, xlate[p]);\n\t\t}\n\t}\n\tfor (i = 0; i < from->colorsTotal; i++) {\n\t\tto->red[i] = from->red[i];\n\t\tto->blue[i] = from->blue[i];\n\t\tto->green[i] = from->green[i];\n\t\tto->alpha[i] = from->alpha[i];\n\t\tto->open[i] = 0;\n\t}\n\tfor (i = from->colorsTotal; i < to->colorsTotal; i++) {\n\t\tto->open[i] = 1;\n\t}\n\tto->colorsTotal = from->colorsTotal;\n}", "target": 0}
{"code": "rfbSendServerCutText(rfbScreenInfoPtr rfbScreen,char *str, int len)\n{\n    rfbClientPtr cl;\n    rfbServerCutTextMsg sct;\n    rfbClientIteratorPtr iterator;\n    iterator = rfbGetClientIterator(rfbScreen);\n    while ((cl = rfbClientIteratorNext(iterator)) != NULL) {\n        sct.type = rfbServerCutText;\n        sct.length = Swap32IfLE(len);\n        LOCK(cl->sendMutex);\n        if (rfbWriteExact(cl, (char *)&sct,\n                       sz_rfbServerCutTextMsg) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n            UNLOCK(cl->sendMutex);\n            continue;\n        }\n        if (rfbWriteExact(cl, str, len) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n        }\n        UNLOCK(cl->sendMutex);\n        rfbStatRecordMessageSent(cl, rfbServerCutText, sz_rfbServerCutTextMsg+len, sz_rfbServerCutTextMsg+len);\n    }\n    rfbReleaseClientIterator(iterator);\n}", "target": 1}
{"code": "static PyObject *convert_slist(struct curl_slist *slist, int free_flags)\n{\n    PyObject *ret = NULL;\n    struct curl_slist *slist_start = slist;\n    ret = PyList_New((Py_ssize_t)0);\n    if (ret == NULL) goto error;\n    for ( ; slist != NULL; slist = slist->next) {\n        PyObject *v = NULL;\n        if (slist->data == NULL) {\n            v = Py_None; Py_INCREF(v);\n        } else {\n            v = PyText_FromString(slist->data);\n        }\n        if (v == NULL || PyList_Append(ret, v) != 0) {\n            Py_XDECREF(v);\n            goto error;\n        }\n        Py_DECREF(v);\n    }\n    if ((free_flags & 1) && slist_start)\n        curl_slist_free_all(slist_start);\n    return ret;\nerror:\n    Py_XDECREF(ret);\n    if ((free_flags & 2) && slist_start)\n        curl_slist_free_all(slist_start);\n    return NULL;\n}", "target": 0}
{"code": "static u32 apic_get_tmcct(struct kvm_lapic *apic)\n{\n\tktime_t remaining;\n\ts64 ns;\n\tu32 tmcct;\n\tASSERT(apic != NULL);\n\tif (kvm_apic_get_reg(apic, APIC_TMICT) == 0)\n\t\treturn 0;\n\tremaining = hrtimer_get_remaining(&apic->lapic_timer.timer);\n\tif (ktime_to_ns(remaining) < 0)\n\t\tremaining = ktime_set(0, 0);\n\tns = mod_64(ktime_to_ns(remaining), apic->lapic_timer.period);\n\ttmcct = div64_u64(ns,\n\t\t\t (APIC_BUS_CYCLE_NS * apic->divide_count));\n\treturn tmcct;\n}", "target": 1}
{"code": "    std::string& attrf(int ncid, int varId, const char * attrName, std::string& alloc)\n    {\n        alloc = \"\";\n        size_t len = 0;\n        nc_inq_attlen(ncid, varId, attrName, &len);\n        if(len < 1)\n        {\n            return alloc;\n        }\n        char attr_vals[NC_MAX_NAME + 1];\n        memset(attr_vals, 0, NC_MAX_NAME + 1);\n        if(nc_get_att_text(ncid, varId, attrName, attr_vals) != NC_NOERR)\n        {\n            return alloc;\n        }\n        alloc = std::string(attr_vals);\n        return alloc;\n    }", "target": 1}
{"code": "max3421_set_address(struct usb_hcd *hcd, struct usb_device *dev, int epnum,\n\t\t    int force_toggles)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tint old_epnum, same_ep, rcvtog, sndtog;\n\tstruct usb_device *old_dev;\n\tu8 hctl;\n\told_dev = max3421_hcd->loaded_dev;\n\told_epnum = max3421_hcd->loaded_epnum;\n\tsame_ep = (dev == old_dev && epnum == old_epnum);\n\tif (same_ep && !force_toggles)\n\t\treturn;\n\tif (old_dev && !same_ep) {\n\t\tu8 hrsl = spi_rd8(hcd, MAX3421_REG_HRSL);\n\t\trcvtog = (hrsl >> MAX3421_HRSL_RCVTOGRD_BIT) & 1;\n\t\tsndtog = (hrsl >> MAX3421_HRSL_SNDTOGRD_BIT) & 1;\n\t\tusb_settoggle(old_dev, old_epnum, 0, rcvtog);\n\t\tusb_settoggle(old_dev, old_epnum, 1, sndtog);\n\t}\n\trcvtog = usb_gettoggle(dev, epnum, 0);\n\tsndtog = usb_gettoggle(dev, epnum, 1);\n\thctl = (BIT(rcvtog + MAX3421_HCTL_RCVTOG0_BIT) |\n\t\tBIT(sndtog + MAX3421_HCTL_SNDTOG0_BIT));\n\tmax3421_hcd->loaded_epnum = epnum;\n\tspi_wr8(hcd, MAX3421_REG_HCTL, hctl);\n\tmax3421_hcd->loaded_dev = dev;\n\tspi_wr8(hcd, MAX3421_REG_PERADDR, dev->devnum);\n}", "target": 1}
{"code": "void Item_string::print(String *str, enum_query_type query_type)\n{\n  const bool print_introducer=\n    !(query_type & QT_WITHOUT_INTRODUCERS) && is_cs_specified();\n  if (print_introducer)\n  {\n    str->append('_');\n    str->append(collation.collation->csname);\n  }\n  str->append('\\'');\n  if (query_type & QT_TO_SYSTEM_CHARSET)\n  {\n    if (print_introducer)\n    {\n      ErrConvString tmp(str_value.ptr(), str_value.length(), &my_charset_bin);\n      str->append(tmp.ptr());\n    }\n    else\n    {\n      if (my_charset_same(str_value.charset(), system_charset_info))\n        str_value.print(str); \n      else \n      {\n        THD *thd= current_thd;\n        LEX_STRING utf8_lex_str;\n        thd->convert_string(&utf8_lex_str,\n                            system_charset_info,\n                            str_value.c_ptr_safe(),\n                            str_value.length(),\n                            str_value.charset());\n        String utf8_str(utf8_lex_str.str,\n                        utf8_lex_str.length,\n                        system_charset_info);\n        utf8_str.print(str);\n      }\n    }\n  }\n  else\n  {\n    str_value.print(str);\n  }\n  str->append('\\'');\n}", "target": 0}
{"code": "static ssize_t ocfs2_direct_IO(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tget_block_t *get_block;\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn 0;\n\tif (iocb->ki_pos + iter->count > i_size_read(inode) &&\n\t    !ocfs2_supports_append_dio(osb))\n\t\treturn 0;\n\tif (iov_iter_rw(iter) == READ)\n\t\tget_block = ocfs2_get_block;\n\telse\n\t\tget_block = ocfs2_dio_get_block;\n\treturn __blockdev_direct_IO(iocb, inode, inode->i_sb->s_bdev,\n\t\t\t\t    iter, get_block,\n\t\t\t\t    ocfs2_dio_end_io, NULL, 0);\n}", "target": 1}
{"code": "NAN_METHOD(TxnWrap::putNumber) {\n    return putCommon(info, [](Nan::NAN_METHOD_ARGS_TYPE info, MDB_val &data) -> void {\n        auto numberLocal = Nan::To<v8::Number>(info[2]).ToLocalChecked();\n        numberToPut = numberLocal->Value();\n        data.mv_size = sizeof(double);\n        data.mv_data = &numberToPut;\n    }, nullptr);\n}", "target": 0}
{"code": "static inline int ccid_hc_rx_getsockopt(struct ccid *ccid, struct sock *sk,\n\t\t\t\t\tconst int optname, int len,\n\t\t\t\t\tu32 __user *optval, int __user *optlen)\n{\n\tint rc = -ENOPROTOOPT;\n\tif (ccid->ccid_ops->ccid_hc_rx_getsockopt != NULL)\n\t\trc = ccid->ccid_ops->ccid_hc_rx_getsockopt(sk, optname, len,\n\t\t\t\t\t\t optval, optlen);\n\treturn rc;\n}", "target": 1}
{"code": "int mp_pack(lua_State *L) {\n    int nargs = lua_gettop(L);\n    int i;\n    mp_buf *buf;\n    if (nargs == 0)\n        return luaL_argerror(L, 0, \"MessagePack pack needs input.\");\n    if (!lua_checkstack(L, nargs))\n        return luaL_argerror(L, 0, \"Too many arguments for MessagePack pack.\");\n    buf = mp_buf_new(L);\n    for(i = 1; i <= nargs; i++) {\n        lua_pushvalue(L, i);\n        mp_encode_lua_type(L,buf,0);\n        lua_pushlstring(L,(char*)buf->b,buf->len);\n        buf->free += buf->len;\n        buf->len = 0;\n    }\n    mp_buf_free(L, buf);\n    lua_concat(L, nargs);\n    return 1;\n}", "target": 0}
{"code": "TEST(GifTest, Gif) {\n  Env* env = Env::Default();\n  const string testdata_path = kTestData;\n  std::vector<DecodeGifTestCase> testcases(\n      {\n       {testdata_path + \"lena.gif\", 1, 51, 26, 3},\n       {testdata_path + \"optimized.gif\", 12, 20, 40, 3},\n       {testdata_path + \"red_black.gif\", 1, 16, 16, 3},\n       {testdata_path + \"scan.gif\", 12, 20, 40, 3},\n       {testdata_path + \"squares.gif\", 2, 16, 16, 3}});\n  for (const auto& tc : testcases) {\n    TestDecodeGif(env, tc);\n  }\n}", "target": 1}
{"code": "struct bpf_map *bpf_map_get_with_uref(u32 ufd)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_map *map;\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn map;\n\tbpf_map_inc(map, true);\n\tfdput(f);\n\treturn map;\n}", "target": 1}
{"code": "static void rtrs_clt_dev_release(struct device *dev)\n{\n\tstruct rtrs_clt_sess *clt = container_of(dev, struct rtrs_clt_sess,\n\t\t\t\t\t\t dev);\n\tmutex_destroy(&clt->paths_ev_mutex);\n\tmutex_destroy(&clt->paths_mutex);\n\tkfree(clt);\n}", "target": 0}
{"code": "l2tp_msgtype_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\tND_PRINT((ndo, \"%s\", tok2str(l2tp_msgtype2str, \"MSGTYPE-#%u\",\n\t    EXTRACT_16BITS(ptr))));\n}", "target": 1}
{"code": "  virtual std::string GetHtmlInfo(int refresh) {\n    std::string output;\n    output.append(\"<html><head><title>About Network</title>\");\n    if (refresh > 0)\n      output.append(\"<meta http-equiv=\\\"refresh\\\" content=\\\"\" +\n          base::IntToString(refresh) + \"\\\"/>\");\n    output.append(\"</head><body>\");\n    if (refresh > 0) {\n      output.append(\"(Auto-refreshing page every \" +\n                    base::IntToString(refresh) + \"s)\");\n    } else {\n      output.append(\"(To auto-refresh this page: about:network/&lt;secs&gt;)\");\n    }\n    output.append(\"<h3>Ethernet:</h3><table border=1>\");\n    if (ethernet_ && ethernet_enabled()) {\n      output.append(\"<tr>\" + ToHtmlTableHeader(ethernet_) + \"</tr>\");\n      output.append(\"<tr>\" + ToHtmlTableRow(ethernet_) + \"</tr>\");\n    }\n    output.append(\"</table><h3>Wifi:</h3><table border=1>\");\n    for (size_t i = 0; i < wifi_networks_.size(); ++i) {\n      if (i == 0)\n        output.append(\"<tr>\" + ToHtmlTableHeader(wifi_networks_[i]) + \"</tr>\");\n      output.append(\"<tr>\" + ToHtmlTableRow(wifi_networks_[i]) + \"</tr>\");\n    }\n    output.append(\"</table><h3>Cellular:</h3><table border=1>\");\n    for (size_t i = 0; i < cellular_networks_.size(); ++i) {\n      if (i == 0)\n        output.append(\"<tr>\" + ToHtmlTableHeader(cellular_networks_[i]) +\n            \"</tr>\");\n      output.append(\"<tr>\" + ToHtmlTableRow(cellular_networks_[i]) + \"</tr>\");\n    }\n    output.append(\"</table><h3>Remembered Wifi:</h3><table border=1>\");\n    for (size_t i = 0; i < remembered_wifi_networks_.size(); ++i) {\n      if (i == 0)\n        output.append(\n            \"<tr>\" + ToHtmlTableHeader(remembered_wifi_networks_[i]) +\n            \"</tr>\");\n      output.append(\"<tr>\" + ToHtmlTableRow(remembered_wifi_networks_[i]) +\n          \"</tr>\");\n    }\n    output.append(\"</table></body></html>\");\n    return output;\n  }", "target": 0}
{"code": "void Polygon::Insert( sal_uInt16 nPos, const Point& rPt )\n{\n    ImplMakeUnique();\n    if( nPos >= mpImplPolygon->mnPoints )\n        nPos = mpImplPolygon->mnPoints;\n    mpImplPolygon->ImplSplit( nPos, 1 );\n    mpImplPolygon->mpPointAry[ nPos ] = rPt;\n}", "target": 1}
{"code": "static struct bio_map_data *bio_alloc_map_data(struct iov_iter *data,\n\t\t\t\t\t       gfp_t gfp_mask)\n{\n\tstruct bio_map_data *bmd;\n\tif (data->nr_segs > UIO_MAXIOV)\n\t\treturn NULL;\n\tbmd = kmalloc(struct_size(bmd, iov, data->nr_segs), gfp_mask);\n\tif (!bmd)\n\t\treturn NULL;\n\tmemcpy(bmd->iov, data->iov, sizeof(struct iovec) * data->nr_segs);\n\tbmd->iter = *data;\n\tbmd->iter.iov = bmd->iov;\n\treturn bmd;\n}", "target": 0}
{"code": "void ConnectDialogEdit::on_qbFill_clicked() {\n\tQ_ASSERT(m_si);\n\tqwInlineNotice->hide();\n\tadjustSize();\n\tqleName->setText(m_si->qsName);\n\tqleServer->setText(m_si->qsHostname);\n\tqleUsername->setText(m_si->qsUsername);\n\tqlePort->setText(QString::number(m_si->usPort));\n\tqlePassword->setText(m_si->qsPassword);\n\tdelete m_si;\n\tm_si = NULL;\n}", "target": 0}
{"code": "static bool caller_may_see_dir(pid_t pid, const char *contrl, const char *cg)\n{\n\tbool answer = false;\n\tchar *c2, *task_cg;\n\tsize_t target_len, task_len;\n\tif (strcmp(cg, \"/\") == 0)\n\t\treturn true;\n\tc2 = get_pid_cgroup(pid, contrl);\n\tif (!c2)\n\t\treturn false;\n\ttask_cg = c2 + 1;\n\ttarget_len = strlen(cg);\n\ttask_len = strlen(task_cg);\n\tif (strcmp(cg, task_cg) == 0) {\n\t\tanswer = true;\n\t\tgoto out;\n\t}\n\tif (target_len < task_len) {\n\t\tif (strncmp(task_cg, cg, target_len) == 0 && task_cg[target_len] == '/')\n\t\t\tanswer = true;\n\t\tgoto out;\n\t}\n\tif (target_len > task_len) {\n\t\tif (strncmp(task_cg, cg, task_len) == 0 && cg[task_len] == '/')\n\t\t\tanswer = true;\n\t\tgoto out;\n\t}\nout:\n\tfree(c2);\n\treturn answer;\n}", "target": 0}
{"code": "static void scalar32_min_max_or(struct bpf_reg_state *dst_reg,\n\t\t\t\tstruct bpf_reg_state *src_reg)\n{\n\tbool src_known = tnum_subreg_is_const(src_reg->var_off);\n\tbool dst_known = tnum_subreg_is_const(dst_reg->var_off);\n\tstruct tnum var32_off = tnum_subreg(dst_reg->var_off);\n\ts32 smin_val = src_reg->smin_value;\n\tu32 umin_val = src_reg->umin_value;\n\tif (src_known && dst_known)\n\t\treturn;\n\tdst_reg->u32_min_value = max(dst_reg->u32_min_value, umin_val);\n\tdst_reg->u32_max_value = var32_off.value | var32_off.mask;\n\tif (dst_reg->s32_min_value < 0 || smin_val < 0) {\n\t\tdst_reg->s32_min_value = S32_MIN;\n\t\tdst_reg->s32_max_value = S32_MAX;\n\t} else {\n\t\tdst_reg->s32_min_value = dst_reg->umin_value;\n\t\tdst_reg->s32_max_value = dst_reg->umax_value;\n\t}\n}", "target": 1}
{"code": "Network::FilterStatus Context::onUpstreamData(int data_length, bool end_of_stream) {\n  if (!wasm_->onUpstreamData_) {\n    return Network::FilterStatus::Continue;\n  }\n  auto result = wasm_->onUpstreamData_(this, id_, static_cast<uint32_t>(data_length),\n                                       static_cast<uint32_t>(end_of_stream));\n  return result.u64_ == 0 ? Network::FilterStatus::Continue : Network::FilterStatus::StopIteration;\n}", "target": 1}
{"code": "static long vhost_net_reset_owner(struct vhost_net *n)\n{\n\tstruct socket *tx_sock = NULL;\n\tstruct socket *rx_sock = NULL;\n\tlong err;\n\tmutex_lock(&n->dev.mutex);\n\terr = vhost_dev_check_owner(&n->dev);\n\tif (err)\n\t\tgoto done;\n\tvhost_net_stop(n, &tx_sock, &rx_sock);\n\tvhost_net_flush(n);\n\terr = vhost_dev_reset_owner(&n->dev);\ndone:\n\tmutex_unlock(&n->dev.mutex);\n\tif (tx_sock)\n\t\tfput(tx_sock->file);\n\tif (rx_sock)\n\t\tfput(rx_sock->file);\n\treturn err;\n}", "target": 0}
{"code": "static u8 adpt_read_blink_led(adpt_hba* host)\n{\n\tif (host->FwDebugBLEDflag_P) {\n\t\tif( readb(host->FwDebugBLEDflag_P) == 0xbc ){\n\t\t\treturn readb(host->FwDebugBLEDvalue_P);\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int ext4_writepage(struct page *page,\n\t\t\t  struct writeback_control *wbc)\n{\n\tint ret = 0;\n\tloff_t size;\n\tunsigned int len;\n\tstruct buffer_head *page_bufs;\n\tstruct inode *inode = page->mapping->host;\n\ttrace_ext4_writepage(inode, page);\n\tsize = i_size_read(inode);\n\tif (page->index == size >> PAGE_CACHE_SHIFT)\n\t\tlen = size & ~PAGE_CACHE_MASK;\n\telse\n\t\tlen = PAGE_CACHE_SIZE;\n\tif (page_has_buffers(page)) {\n\t\tpage_bufs = page_buffers(page);\n\t\tif (walk_page_buffers(NULL, page_bufs, 0, len, NULL,\n\t\t\t\t\text4_bh_delay_or_unwritten)) {\n\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\tunlock_page(page);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tret = block_prepare_write(page, 0, len,\n\t\t\t\t\t  noalloc_get_block_write);\n\t\tif (!ret) {\n\t\t\tpage_bufs = page_buffers(page);\n\t\t\tif (walk_page_buffers(NULL, page_bufs, 0, len, NULL,\n\t\t\t\t\t\text4_bh_delay_or_unwritten)) {\n\t\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\t\tunlock_page(page);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else {\n\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\tunlock_page(page);\n\t\t\treturn 0;\n\t\t}\n\t\tblock_commit_write(page, 0, len);\n\t}\n\tif (PageChecked(page) && ext4_should_journal_data(inode)) {\n\t\tClearPageChecked(page);\n\t\treturn __ext4_journalled_writepage(page, len);\n\t}\n\tif (test_opt(inode->i_sb, NOBH) && ext4_should_writeback_data(inode))\n\t\tret = nobh_writepage(page, noalloc_get_block_write, wbc);\n\telse\n\t\tret = block_write_full_page(page, noalloc_get_block_write,\n\t\t\t\t\t    wbc);\n\treturn ret;\n}", "target": 1}
{"code": "String *Item_cache_wrapper::val_str(String* str)\n{\n  Item *cached_value;\n  DBUG_ENTER(\"Item_cache_wrapper::val_str\");\n  if (!expr_cache)\n  {\n    String *tmp= orig_item->val_str(str);\n    null_value= orig_item->null_value;\n    DBUG_RETURN(tmp);\n  }\n  if ((cached_value= check_cache()))\n  {\n    String *tmp= cached_value->val_str(str);\n    null_value= cached_value->null_value;\n    DBUG_RETURN(tmp);\n  }\n  cache();\n  if ((null_value= expr_value->null_value))\n    DBUG_RETURN(NULL);\n  DBUG_RETURN(expr_value->val_str(str));\n}", "target": 0}
{"code": "static int llcp_sock_create(struct net *net, struct socket *sock,\n\t\t\t    const struct nfc_protocol *nfc_proto, int kern)\n{\n\tstruct sock *sk;\n\tpr_debug(\"%p\\n\", sock);\n\tif (sock->type != SOCK_STREAM &&\n\t    sock->type != SOCK_DGRAM &&\n\t    sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\tif (sock->type == SOCK_RAW)\n\t\tsock->ops = &llcp_rawsock_ops;\n\telse\n\t\tsock->ops = &llcp_sock_ops;\n\tsk = nfc_llcp_sock_alloc(sock, sock->type, GFP_ATOMIC, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}", "target": 1}
{"code": "static Jsi_RC NumberToPrecisionCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[100];\n    int prec = 0, skip = 0;\n    Jsi_Number num;\n    Jsi_Value *v;\n    ChkStringN(_this, funcPtr, v);\n    if (Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, skip), &prec) != JSI_OK)\n        return JSI_ERROR;\n    if (prec<=0) return JSI_ERROR;\n    Jsi_GetDoubleFromValue(interp, v, &num);\n    snprintf(buf, sizeof(buf),\"%.*\" JSI_NUMFFMT, prec, num);\n    if (num<0)\n        prec++;\n    buf[prec+1] = 0;\n    if (buf[prec] == '.')\n        buf[prec] = 0;\n    Jsi_ValueMakeStringDup(interp, ret, buf);\n    return JSI_OK;\n}", "target": 1}
{"code": "static char* getPreferredTag(const char* gf_tag)\n{ \n\tchar* result = NULL;\n\tint grOffset = 0;\n\tgrOffset = findOffset( LOC_GRANDFATHERED ,gf_tag);\n\tif(grOffset < 0) {\n\t\treturn NULL;\n\t}\n\tif( grOffset < LOC_PREFERRED_GRANDFATHERED_LEN ){\n\t\tresult = estrdup( LOC_PREFERRED_GRANDFATHERED[grOffset] );\n\t} else {\n\t\tresult = estrdup( LOC_GRANDFATHERED[grOffset] );\n\t}\n\treturn result;\n}", "target": 1}
{"code": "static void unqueue_me_pi(struct futex_q *q)\n{\n\tWARN_ON(plist_node_empty(&q->list));\n\tplist_del(&q->list, &q->list.plist);\n\tBUG_ON(!q->pi_state);\n\tfree_pi_state(q->pi_state);\n\tq->pi_state = NULL;\n\tspin_unlock(q->lock_ptr);\n\tdrop_futex_key_refs(&q->key);\n}", "target": 1}
{"code": "BGD_DECLARE(void *) gdImagePngPtr (gdImagePtr im, int *size)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx (2048, NULL);\n\tif (out == NULL) return NULL;\n\tgdImagePngCtxEx (im, out, -1);\n\trv = gdDPExtractData (out, size);\n\tout->gd_free (out);\n\treturn rv;\n}", "target": 1}
{"code": "handle_fn_f7 (GsdXrandrManager *mgr, guint32 timestamp)\n{\n        GsdXrandrManagerPrivate *priv = mgr->priv;\n        GnomeRRScreen *screen = priv->rw_screen;\n        GnomeRRConfig *current;\n        GError *error;\n        g_debug (\"Handling fn-f7\");\n        error = NULL;\n        if (!gnome_rr_screen_refresh (screen, &error) && error) {\n                char *str;\n                str = g_strdup_printf (_(\"Could not refresh the screen information: %s\"), error->message);\n                g_error_free (error);\n                error_message (mgr, str, NULL, _(\"Trying to switch the monitor configuration anyway.\"));\n                g_free (str);\n        }\n        if (!priv->fn_f7_configs)\n                generate_fn_f7_configs (mgr);\n        current = gnome_rr_config_new_current (screen);\n        if (priv->fn_f7_configs &&\n            (!gnome_rr_config_match (current, priv->fn_f7_configs[0]) ||\n             !gnome_rr_config_equal (current, priv->fn_f7_configs[mgr->priv->current_fn_f7_config]))) {\n                    generate_fn_f7_configs (mgr);\n            }\n        gnome_rr_config_free (current);\n        if (priv->fn_f7_configs) {\n                mgr->priv->current_fn_f7_config++;\n                if (priv->fn_f7_configs[mgr->priv->current_fn_f7_config] == NULL)\n                        mgr->priv->current_fn_f7_config = 0;\n                g_debug (\"cycling to next configuration (%d)\", mgr->priv->current_fn_f7_config);\n                print_configuration (priv->fn_f7_configs[mgr->priv->current_fn_f7_config], \"new config\");\n                g_debug (\"applying\");\n                error = NULL;\n                if (!gnome_rr_config_apply_with_time (priv->fn_f7_configs[mgr->priv->current_fn_f7_config], screen, timestamp, &error)) {\n                        error_message (mgr, _(\"Could not switch the monitor configuration\"), error, NULL);\n                        g_error_free (error);\n                }\n        }\n        else {\n                g_debug (\"no configurations generated\");\n        }\n        g_debug (\"done handling fn-f7\");\n}", "target": 0}
{"code": "int set_binfmt(struct linux_binfmt *new)\n{\n\tstruct linux_binfmt *old = current->binfmt;\n\tif (new) {\n\t\tif (!try_module_get(new->module))\n\t\t\treturn -1;\n\t}\n\tcurrent->binfmt = new;\n\tif (old)\n\t\tmodule_put(old->module);\n\treturn 0;\n}", "target": 0}
{"code": "int fuse_fs_getxattr(struct fuse_fs *fs, const char *path, const char *name,\n                     char *value, size_t size)\n{\n    fuse_get_context()->private_data = fs->user_data;\n    if (fs->op.getxattr)\n        return fs->op.getxattr(path, name, value, size);\n    else\n        return -ENOSYS;\n}", "target": 0}
{"code": "uint8_t* sldns_str2wire_dname(const char* str, size_t* len)\n{\n\tuint8_t dname[LDNS_MAX_DOMAINLEN+1];\n\t*len = sizeof(dname);\n\tif(sldns_str2wire_dname_buf(str, dname, len) == 0) {\n\t\tuint8_t* r;\n\t\tif(*len > sizeof(dname)) return NULL;\n\t\tr = (uint8_t*)malloc(*len);\n\t\tif(r) return memcpy(r, dname, *len);\n\t}\n\t*len = 0;\n\treturn NULL;\n}", "target": 0}
{"code": "static int nf_tables_set_notify(const struct nft_ctx *ctx,\n\t\t\t\tconst struct nft_set *set,\n\t\t\t\tint event, gfp_t gfp_flags)\n{\n\tstruct sk_buff *skb;\n\tu32 portid = ctx->portid;\n\tint err;\n\tif (!ctx->report &&\n\t    !nfnetlink_has_listeners(ctx->net, NFNLGRP_NFTABLES))\n\t\treturn 0;\n\terr = -ENOBUFS;\n\tskb = nlmsg_new(NLMSG_GOODSIZE, gfp_flags);\n\tif (skb == NULL)\n\t\tgoto err;\n\terr = nf_tables_fill_set(skb, ctx, set, event, 0);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto err;\n\t}\n\terr = nfnetlink_send(skb, ctx->net, portid, NFNLGRP_NFTABLES,\n\t\t\t     ctx->report, gfp_flags);\nerr:\n\tif (err < 0)\n\t\tnfnetlink_set_err(ctx->net, portid, NFNLGRP_NFTABLES, err);\n\treturn err;\n}", "target": 0}
{"code": "acl_fetch_hdr_val(struct proxy *px, struct session *l4, void *l7, char *sol,\n                  struct acl_expr *expr, struct acl_test *test)\n{\n\tstruct http_txn *txn = l7;\n\tstruct hdr_idx *idx = &txn->hdr_idx;\n\tstruct hdr_ctx *ctx = (struct hdr_ctx *)test->ctx.a;\n\tif (!txn)\n\t\treturn 0;\n\tif (!(test->flags & ACL_TEST_F_FETCH_MORE))\n\t\tctx->idx = 0;\n\tif (http_find_header2(expr->arg.str, expr->arg_len, sol, idx, ctx)) {\n\t\ttest->flags |= ACL_TEST_F_FETCH_MORE;\n\t\ttest->flags |= ACL_TEST_F_VOL_HDR;\n\t\ttest->i = strl2ic((char *)ctx->line + ctx->val, ctx->vlen);\n\t\treturn 1;\n\t}\n\ttest->flags &= ~ACL_TEST_F_FETCH_MORE;\n\ttest->flags |= ACL_TEST_F_VOL_HDR;\n\treturn 0;\n}", "target": 0}
{"code": "static void gdCtxPrintf(gdIOCtx * out, const char *format, ...)\n{\n\tchar buf[4096];\n\tint len;\n\tva_list args;\n\tva_start(args, format);\n\tlen = vsnprintf(buf, sizeof(buf)-1, format, args);\n\tva_end(args);\n\tout->putBuf(out, buf, len);\n}", "target": 1}
{"code": "static int mwifiex_pcie_alloc_cmdrsp_buf(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct sk_buff *skb;\n\tskb = dev_alloc_skb(MWIFIEX_UPLD_SIZE);\n\tif (!skb) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Unable to allocate skb for command response data.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_put(skb, MWIFIEX_UPLD_SIZE);\n\tif (mwifiex_map_pci_memory(adapter, skb, MWIFIEX_UPLD_SIZE,\n\t\t\t\t   PCI_DMA_FROMDEVICE))\n\t\treturn -1;\n\tcard->cmdrsp_buf = skb;\n\treturn 0;\n}", "target": 1}
{"code": "void Statement::Work_AfterReset(napi_env e, napi_status status, void* data) {\n    std::unique_ptr<Baton> baton(static_cast<Baton*>(data));\n    Statement* stmt = baton->stmt;\n    Napi::Env env = stmt->Env();\n    Napi::HandleScope scope(env);\n    Napi::Function cb = baton->callback.Value();\n    if (!cb.IsUndefined() && cb.IsFunction()) {\n        Napi::Value argv[] = { env.Null() };\n        TRY_CATCH_CALL(stmt->Value(), cb, 1, argv);\n    }\n    STATEMENT_END();\n}", "target": 0}
{"code": "static int buffer_chain_size(void)\n{\n\tstruct bio_vec bv;\n\tint size;\n\tstruct req_iterator iter;\n\tchar *base;\n\tbase = bio_data(current_req->bio);\n\tsize = 0;\n\trq_for_each_segment(bv, current_req, iter) {\n\t\tif (page_address(bv.bv_page) + bv.bv_offset != base + size)\n\t\t\tbreak;\n\t\tsize += bv.bv_len;\n\t}\n\treturn size >> 9;\n}", "target": 0}
{"code": "void* ipc_rcu_alloc(int size)\n{\n\tvoid* out;\n\tif (rcu_use_vmalloc(size)) {\n\t\tout = vmalloc(HDRLEN_VMALLOC + size);\n\t\tif (out) {\n\t\t\tout += HDRLEN_VMALLOC;\n\t\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 1;\n\t\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->refcount = 1;\n\t\t}\n\t} else {\n\t\tout = kmalloc(HDRLEN_KMALLOC + size, GFP_KERNEL);\n\t\tif (out) {\n\t\t\tout += HDRLEN_KMALLOC;\n\t\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 0;\n\t\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->refcount = 1;\n\t\t}\n\t}\n\treturn out;\n}", "target": 1}
{"code": "int unshare_userns(unsigned long unshare_flags, struct cred **new_cred)\n{\n\tstruct cred *cred;\n\tif (!(unshare_flags & CLONE_NEWUSER))\n\t\treturn 0;\n\tcred = prepare_creds();\n\tif (!cred)\n\t\treturn -ENOMEM;\n\t*new_cred = cred;\n\treturn create_user_ns(cred);\n}", "target": 1}
{"code": "static irqreturn_t sunkbd_interrupt(struct serio *serio,\n\t\tunsigned char data, unsigned int flags)\n{\n\tstruct sunkbd *sunkbd = serio_get_drvdata(serio);\n\tif (sunkbd->reset <= -1) {\n\t\tsunkbd->reset = data;\n\t\twake_up_interruptible(&sunkbd->wait);\n\t\tgoto out;\n\t}\n\tif (sunkbd->layout == -1) {\n\t\tsunkbd->layout = data;\n\t\twake_up_interruptible(&sunkbd->wait);\n\t\tgoto out;\n\t}\n\tswitch (data) {\n\tcase SUNKBD_RET_RESET:\n\t\tschedule_work(&sunkbd->tq);\n\t\tsunkbd->reset = -1;\n\t\tbreak;\n\tcase SUNKBD_RET_LAYOUT:\n\t\tsunkbd->layout = -1;\n\t\tbreak;\n\tcase SUNKBD_RET_ALLUP: \n\t\tbreak;\n\tdefault:\n\t\tif (!sunkbd->enabled)\n\t\t\tbreak;\n\t\tif (sunkbd->keycode[data & SUNKBD_KEY]) {\n\t\t\tinput_report_key(sunkbd->dev,\n\t\t\t\t\t sunkbd->keycode[data & SUNKBD_KEY],\n\t\t\t\t\t !(data & SUNKBD_RELEASE));\n\t\t\tinput_sync(sunkbd->dev);\n\t\t} else {\n\t\t\tprintk(KERN_WARNING\n\t\t\t\t\"sunkbd.c: Unknown key (scancode %#x) %s.\\n\",\n\t\t\t\tdata & SUNKBD_KEY,\n\t\t\t\tdata & SUNKBD_RELEASE ? \"released\" : \"pressed\");\n\t\t}\n\t}\nout:\n\treturn IRQ_HANDLED;\n}", "target": 1}
{"code": "static int cdrom_ioctl_media_changed(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tstruct cdrom_changer_info *info;\n\tint ret;\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_MEDIA_CHANGED\\n\");\n\tif (!CDROM_CAN(CDC_MEDIA_CHANGED))\n\t\treturn -ENOSYS;\n\tif (!CDROM_CAN(CDC_SELECT_DISC) || arg == CDSL_CURRENT)\n\t\treturn media_changed(cdi, 1);\n\tif ((unsigned int)arg >= cdi->capacity)\n\t\treturn -EINVAL;\n\tinfo = kmalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\tret = cdrom_read_mech_status(cdi, info);\n\tif (!ret)\n\t\tret = info->slots[arg].change;\n\tkfree(info);\n\treturn ret;\n}", "target": 1}
{"code": "vreader_slot (int vrdr)\n{\n  if (vrdr == -1 || !(vrdr >= 0 && vrdr < DIM(vreader_table)))\n    return -1;\n  if (!vreader_table [vrdr].valid)\n    return -1;\n  return vreader_table[vrdr].slot;\n}", "target": 0}
{"code": "static void jsR_setproperty(js_State *J, js_Object *obj, const char *name)\n{\n\tjs_Value *value = stackidx(J, -1);\n\tjs_Property *ref;\n\tint k;\n\tint own;\n\tif (obj->type == JS_CARRAY) {\n\t\tif (!strcmp(name, \"length\")) {\n\t\t\tdouble rawlen = jsV_tonumber(J, value);\n\t\t\tint newlen = jsV_numbertointeger(rawlen);\n\t\t\tif (newlen != rawlen)\n\t\t\t\tjs_rangeerror(J, \"array length\");\n\t\t\tjsV_resizearray(J, obj, newlen);\n\t\t\treturn;\n\t\t}\n\t\tif (js_isarrayindex(J, name, &k))\n\t\t\tif (k >= obj->u.a.length)\n\t\t\t\tobj->u.a.length = k + 1;\n\t}\n\telse if (obj->type == JS_CSTRING) {\n\t\tif (!strcmp(name, \"length\"))\n\t\t\tgoto readonly;\n\t\tif (js_isarrayindex(J, name, &k))\n\t\t\tif (js_runeat(J, obj->u.s.string, k))\n\t\t\t\tgoto readonly;\n\t}\n\telse if (obj->type == JS_CREGEXP) {\n\t\tif (!strcmp(name, \"source\")) goto readonly;\n\t\tif (!strcmp(name, \"global\")) goto readonly;\n\t\tif (!strcmp(name, \"ignoreCase\")) goto readonly;\n\t\tif (!strcmp(name, \"multiline\")) goto readonly;\n\t\tif (!strcmp(name, \"lastIndex\")) {\n\t\t\tobj->u.r.last = jsV_tointeger(J, value);\n\t\t\treturn;\n\t\t}\n\t}\n\telse if (obj->type == JS_CUSERDATA) {\n\t\tif (obj->u.user.put && obj->u.user.put(J, obj->u.user.data, name))\n\t\t\treturn;\n\t}\n\tref = jsV_getpropertyx(J, obj, name, &own);\n\tif (ref && ref->setter) {\n\t\tjs_pushobject(J, ref->setter);\n\t\tjs_pushobject(J, obj);\n\t\tjs_pushvalue(J, *value);\n\t\tjs_call(J, 1);\n\t\tjs_pop(J, 1);\n\t\treturn;\n\t}\n\tif (!ref || !own)\n\t\tref = jsV_setproperty(J, obj, name);\n\tif (ref) {\n\t\tif (!(ref->atts & JS_READONLY))\n\t\t\tref->value = *value;\n\t\telse\n\t\t\tgoto readonly;\n\t}\n\treturn;\nreadonly:\n\tif (J->strict)\n\t\tjs_typeerror(J, \"'%s' is read-only\", name);\n}", "target": 0}
{"code": "static int coolkey_read_object(sc_card_t *card, unsigned long object_id, size_t offset,\n\t\t\tu8 *out_buf, size_t out_len, u8 *nonce, size_t nonce_size)\n{\n\tcoolkey_read_object_param_t params;\n\tu8 *out_ptr;\n\tsize_t left = 0;\n\tsize_t len;\n\tint r;\n\tulong2bebytes(&params.object_id[0], object_id);\n\tout_ptr = out_buf;\n\tleft = out_len;\n\tdo {\n\t\tulong2bebytes(&params.offset[0], offset);\n\t\tparams.length = MIN(left, COOLKEY_MAX_CHUNK_SIZE);\n\t\tlen = left;\n\t\tr = coolkey_apdu_io(card, COOLKEY_CLASS, COOLKEY_INS_READ_OBJECT, 0, 0,\n\t\t\t(u8 *)&params, sizeof(params), &out_ptr, &len, nonce, nonce_size);\n\t\tif (r < 0) {\n\t\t\tgoto fail;\n\t\t}\n\t\tif ((left < len) || (len == 0)) {\n\t\t\tr = SC_ERROR_INTERNAL;\n\t\t\tgoto fail;\n\t\t}\n\t\tout_ptr += len;\n\t\toffset += len;\n\t\tleft -= len;\n\t} while (left != 0);\n\treturn out_len;\nfail:\n\treturn r;\n}", "target": 0}
{"code": "njs_vmcode_typeof(njs_vm_t *vm, njs_value_t *value, njs_value_t *invld)\n{\n    static const njs_value_t  *types[NJS_VALUE_TYPE_MAX] = {\n        &njs_string_object,\n        &njs_string_undefined,\n        &njs_string_boolean,\n        &njs_string_number,\n        &njs_string_symbol,\n        &njs_string_string,\n        &njs_string_data,\n        &njs_string_external,\n        &njs_string_invalid,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_function,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n    };\n    vm->retval = *types[value->type];\n    return sizeof(njs_vmcode_2addr_t);\n}", "target": 1}
{"code": "static int orinoco_ioctl_getessid(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  struct iw_point *erq,\n\t\t\t\t  char *essidbuf)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint active;\n\tint err = 0;\n\tunsigned long flags;\n\tif (netif_running(dev)) {\n\t\terr = orinoco_hw_get_essid(priv, &active, essidbuf);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terq->length = err;\n\t} else {\n\t\tif (orinoco_lock(priv, &flags) != 0)\n\t\t\treturn -EBUSY;\n\t\tmemcpy(essidbuf, priv->desired_essid, IW_ESSID_MAX_SIZE);\n\t\terq->length = strlen(priv->desired_essid);\n\t\torinoco_unlock(priv, &flags);\n\t}\n\terq->flags = 1;\n\treturn 0;\n}", "target": 0}
{"code": "static int i740fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tswitch (var->bits_per_pixel) {\n\tcase 8:\n\t\tvar->red.offset\t= var->green.offset = var->blue.offset = 0;\n\t\tvar->red.length\t= var->green.length = var->blue.length = 8;\n\t\tbreak;\n\tcase 16:\n\t\tswitch (var->green.length) {\n\t\tdefault:\n\t\tcase 5:\n\t\t\tvar->red.offset = 10;\n\t\t\tvar->green.offset = 5;\n\t\t\tvar->blue.offset = 0;\n\t\t\tvar->red.length\t= 5;\n\t\t\tvar->green.length = 5;\n\t\t\tvar->blue.length = 5;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tvar->red.offset = 11;\n\t\t\tvar->green.offset = 5;\n\t\t\tvar->blue.offset = 0;\n\t\t\tvar->red.length = var->blue.length = 5;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 24:\n\t\tvar->red.offset = 16;\n\t\tvar->green.offset = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->red.length\t= var->green.length = var->blue.length = 8;\n\t\tbreak;\n\tcase 32:\n\t\tvar->transp.offset = 24;\n\t\tvar->red.offset = 16;\n\t\tvar->green.offset = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->transp.length = 8;\n\t\tvar->red.length = var->green.length = var->blue.length = 8;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (var->xres > var->xres_virtual)\n\t\tvar->xres_virtual = var->xres;\n\tif (var->yres > var->yres_virtual)\n\t\tvar->yres_virtual = var->yres;\n\tif (info->monspecs.hfmax && info->monspecs.vfmax &&\n\t    info->monspecs.dclkmax && fb_validate_mode(var, info) < 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 1}
{"code": "crm_send_remote_msg(void *session, xmlNode * msg, gboolean encrypted)\n{\n    if (encrypted) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        cib_send_tls(session, msg);\n#else\n        CRM_ASSERT(encrypted == FALSE);\n#endif\n    } else {\n        cib_send_plaintext(GPOINTER_TO_INT(session), msg);\n    }\n}", "target": 1}
{"code": "renderCoTable(struct table *tbl, int maxlimit)\n{\n    struct readbuffer obuf;\n    struct html_feed_environ h_env;\n    struct environment envs[MAX_ENV_LEVEL];\n    struct table *t;\n    int i, col, row;\n    int indent, maxwidth;\n    for (i = 0; i < tbl->ntable; i++) {\n\tt = tbl->tables[i].ptr;\n\tcol = tbl->tables[i].col;\n\trow = tbl->tables[i].row;\n\tindent = tbl->tables[i].indent;\n\tinit_henv(&h_env, &obuf, envs, MAX_ENV_LEVEL, tbl->tables[i].buf,\n\t\t  get_spec_cell_width(tbl, row, col), indent);\n\tcheck_row(tbl, row);\n\tif (h_env.limit > maxlimit)\n\t    h_env.limit = maxlimit;\n\tif (t->total_width == 0)\n\t    maxwidth = h_env.limit - indent;\n\telse if (t->total_width > 0)\n\t    maxwidth = t->total_width;\n\telse\n\t    maxwidth = t->total_width = -t->total_width * h_env.limit / 100;\n\trenderTable(t, maxwidth, &h_env);\n    }\n}", "target": 1}
{"code": "lsof_parse (const char *stdout,\n            GPtrArray *processes)\n{\n  int n;\n  char **tokens;\n  tokens = g_strsplit (stdout, \"\\n\", 0);\n  for (n = 0; tokens[n] != NULL; n++)\n    {\n      pid_t pid;\n      uid_t uid;\n      char *command_line;\n      GValue elem =\n        { 0 };\n      if (strlen (tokens[n]) == 0)\n        continue;\n      pid = strtol (tokens[n], NULL, 0);\n      uid = get_uid_for_pid (pid);\n      command_line = get_command_line_for_pid (pid);\n      g_value_init (&elem, LSOF_DATA_STRUCT_TYPE);\n      g_value_take_boxed (&elem, dbus_g_type_specialized_construct (LSOF_DATA_STRUCT_TYPE));\n      dbus_g_type_struct_set (&elem, 0, pid, 1, uid, 2, command_line != NULL ? command_line : \"\", G_MAXUINT);\n      g_ptr_array_add (processes, g_value_get_boxed (&elem));\n      g_free (command_line);\n    }\n  g_strfreev (tokens);\n}", "target": 0}
{"code": "static void parse_time(pj_scanner *scanner, pjmedia_sdp_session *ses,\n\t\t       volatile parse_context *ctx)\n{\n    pj_str_t str;\n    ctx->last_error = PJMEDIA_SDP_EINTIME;\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n    pj_scan_get_until_ch(scanner, ' ', &str);\n    ses->time.start = pj_strtoul(&str);\n    pj_scan_get_char(scanner);\n    pj_scan_get_until_chr(scanner, \" \\t\\r\\n\", &str);\n    ses->time.stop = pj_strtoul(&str);\n    pj_scan_skip_line(scanner);\n}", "target": 1}
{"code": "static void settings_changed(struct btd_adapter *adapter, uint32_t settings)\n{\n\tuint32_t changed_mask;\n\tchanged_mask = adapter->current_settings ^ settings;\n\tadapter->current_settings = settings;\n\tadapter->pending_settings &= ~changed_mask;\n\tDBG(\"Changed settings: 0x%08x\", changed_mask);\n\tDBG(\"Pending settings: 0x%08x\", adapter->pending_settings);\n\tif (changed_mask & MGMT_SETTING_POWERED) {\n\t        g_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Powered\");\n\t\tif (adapter->current_settings & MGMT_SETTING_POWERED) {\n\t\t\tadapter_start(adapter);\n\t\t} else {\n\t\t\tadapter_stop(adapter);\n\t\t\tif (powering_down) {\n\t\t\t\tadapter_remaining--;\n\t\t\t\tif (!adapter_remaining)\n\t\t\t\t\tbtd_exit();\n\t\t\t}\n\t\t}\n\t}\n\tif ((changed_mask & MGMT_SETTING_LE) &&\n\t\t\t\tbtd_adapter_get_powered(adapter) &&\n\t\t\t\t(adapter->current_settings & MGMT_SETTING_LE))\n\t\ttrigger_passive_scanning(adapter);\n\tif (changed_mask & MGMT_SETTING_DISCOVERABLE) {\n\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Discoverable\");\n\t\tstore_adapter_info(adapter);\n\t\tbtd_adv_manager_refresh(adapter->adv_manager);\n\t}\n\tif (changed_mask & MGMT_SETTING_BONDABLE) {\n\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Pairable\");\n\t\ttrigger_pairable_timeout(adapter);\n\t}\n}", "target": 1}
{"code": "elf_core_copy_task_xfpregs(struct task_struct *t, elf_fpxregset_t *xfpu)\n{\n\tstruct pt_regs *regs = task_pt_regs(t);\n\tif (!tsk_used_math(t))\n\t\treturn 0;\n\tif (t == current)\n\t\tunlazy_fpu(t); \n\tmemcpy(xfpu, &t->thread.i387.fxsave, sizeof(elf_fpxregset_t));\n\txfpu->fcs = regs->cs; \n\txfpu->fos = t->thread.ds;  \n\treturn 1;\n}", "target": 0}
{"code": "copy_text_attr(\n    int\t\toff,\n    char_u\t*buf,\n    int\t\tlen,\n    int\t\tattr)\n{\n    int\t\ti;\n    mch_memmove(ScreenLines + off, buf, (size_t)len);\n    if (enc_utf8)\n\tvim_memset(ScreenLinesUC + off, 0, sizeof(u8char_T) * (size_t)len);\n    for (i = 0; i < len; ++i)\n\tScreenAttrs[off + i] = attr;\n}", "target": 0}
{"code": "void smp_process_local_nonce(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n  SMP_TRACE_DEBUG(\"%s\", __func__);\n switch (p_cb->selected_association_model) {\n case SMP_MODEL_SEC_CONN_JUSTWORKS:\n case SMP_MODEL_SEC_CONN_NUM_COMP:\n if (p_cb->role == HCI_ROLE_SLAVE) {\n        smp_calculate_local_commitment(p_cb);\n        smp_send_commitment(p_cb, NULL);\n        smp_set_state(SMP_STATE_WAIT_NONCE);\n } else \n {\n if (p_cb->flags & SMP_PAIR_FLAG_HAVE_PEER_COMM) {\n          SMP_TRACE_DEBUG(\n \"master in assoc mode = %d \"\n \"already rcvd slave commitment - race condition\",\n              p_cb->selected_association_model);\n          p_cb->flags &= ~SMP_PAIR_FLAG_HAVE_PEER_COMM;\n          smp_send_rand(p_cb, NULL);\n          smp_set_state(SMP_STATE_WAIT_NONCE);\n }\n }\n break;\n case SMP_MODEL_SEC_CONN_PASSKEY_ENT:\n case SMP_MODEL_SEC_CONN_PASSKEY_DISP:\n      smp_calculate_local_commitment(p_cb);\n if (p_cb->role == HCI_ROLE_MASTER) {\n        smp_send_commitment(p_cb, NULL);\n } else \n {\n if (p_cb->flags & SMP_PAIR_FLAG_HAVE_PEER_COMM) {\n          smp_send_commitment(p_cb, NULL);\n          smp_set_state(SMP_STATE_WAIT_NONCE);\n }\n }\n break;\n case SMP_MODEL_SEC_CONN_OOB:\n if (p_cb->role == HCI_ROLE_MASTER) {\n        smp_send_rand(p_cb, NULL);\n }\n      smp_set_state(SMP_STATE_WAIT_NONCE);\n break;\n default:\n      SMP_TRACE_ERROR(\"Association Model = %d is not used in LE SC\",\n                      p_cb->selected_association_model);\n break;\n }\n}", "target": 0}
{"code": "int compat_ipv6_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t   char __user *optval, int __user *optlen)\n{\n\tint err;\n\tif (level == SOL_IP && sk->sk_type != SOCK_RAW) {\n\t\tif (udp_prot.compat_getsockopt != NULL)\n\t\t\treturn udp_prot.compat_getsockopt(sk, level, optname,\n\t\t\t\t\t\t\t  optval, optlen);\n\t\treturn udp_prot.getsockopt(sk, level, optname, optval, optlen);\n\t}\n\tif (level != SOL_IPV6)\n\t\treturn -ENOPROTOOPT;\n\tif (optname == MCAST_MSFILTER)\n\t\treturn compat_mc_getsockopt(sk, level, optname, optval, optlen,\n\t\t\tipv6_getsockopt);\n\terr = do_ipv6_getsockopt(sk, level, optname, optval, optlen,\n\t\t\t\t MSG_CMSG_COMPAT);\n#ifdef CONFIG_NETFILTER\n\tif (err == -ENOPROTOOPT && optname != IPV6_2292PKTOPTIONS) {\n\t\tint len;\n\t\tif (get_user(len, optlen))\n\t\t\treturn -EFAULT;\n\t\terr = compat_nf_getsockopt(sk, PF_INET6, optname, optval, &len);\n\t\tif (err >= 0)\n\t\t\terr = put_user(len, optlen);\n\t}\n#endif\n\treturn err;\n}", "target": 0}
{"code": "  CallOpDimensionsFromInputs(const int n, const int h, const int w, const int c,\n                             const int kx, const int ky, const int sx,\n                             const int sy, const string& data_format,\n                             const string& padding) {\n    OpContext op_context;\n    const std::vector<int> x = {n, h, w, c};\n    const std::vector<int> ksize = {1, kx, ky, 1};\n    std::vector<int> strides;\n    if (data_format == \"NHWC\") {\n      strides = {1, sy, sx, 1};\n    } else {\n      strides = {1, 1, sy, sx};\n    }\n    auto& op_info = op_context.op_info;\n    SetCpuDevice(&op_info);\n    op_info.set_op(\"MaxPool\");\n    DescribeTensor4D(x[0], x[1], x[2], x[3], op_info.add_inputs());\n    auto* attr = op_info.mutable_attr();\n    SetAttrValue(data_format, &(*attr)[\"data_format\"]);\n    SetAttrValue(padding, &(*attr)[\"padding\"]);\n    SetAttrValue(strides, &(*attr)[\"strides\"]);\n    SetAttrValue(ksize, &(*attr)[\"ksize\"]);\n    bool found_unknown_shapes;\n    return OpLevelCostEstimator::OpDimensionsFromInputs(\n        op_context.op_info.inputs(0).shape(), op_context.op_info,\n        &found_unknown_shapes);\n  }", "target": 0}
{"code": "void sas_unregister_dev(struct asd_sas_port *port, struct domain_device *dev)\n{\n\tif (!test_bit(SAS_DEV_DESTROY, &dev->state) &&\n\t    !list_empty(&dev->disco_list_node)) {\n\t\tlist_del_init(&dev->disco_list_node);\n\t\tsas_rphy_free(dev->rphy);\n\t\tsas_unregister_common_dev(port, dev);\n\t\treturn;\n\t}\n\tif (!test_and_set_bit(SAS_DEV_DESTROY, &dev->state)) {\n\t\tsas_rphy_unlink(dev->rphy);\n\t\tlist_move_tail(&dev->disco_list_node, &port->destroy_list);\n\t\tsas_discover_event(dev->port, DISCE_DESTRUCT);\n\t}\n}", "target": 1}
{"code": "pf_remove_state(struct pf_state *st)\n{\n\tPF_ASSERT_LOCKED();\n\tif (st->timeout == PFTM_UNLINKED)\n\t\treturn;\n\tst->timeout = PFTM_UNLINKED;\n\tpf_postprocess_addr(st);\n\tif (st->src.state == PF_TCPS_PROXY_DST) {\n\t\tpf_send_tcp(st->rule.ptr, st->key[PF_SK_WIRE]->af,\n\t\t    &st->key[PF_SK_WIRE]->addr[1],\n\t\t    &st->key[PF_SK_WIRE]->addr[0],\n\t\t    st->key[PF_SK_WIRE]->port[1],\n\t\t    st->key[PF_SK_WIRE]->port[0],\n\t\t    st->src.seqhi, st->src.seqlo + 1,\n\t\t    TH_RST|TH_ACK, 0, 0, 0, 1, st->tag,\n\t\t    st->key[PF_SK_WIRE]->rdomain);\n\t}\n\tif (st->key[PF_SK_STACK]->proto == IPPROTO_TCP)\n\t\tpf_set_protostate(st, PF_PEER_BOTH, TCPS_CLOSED);\n\tRBT_REMOVE(pf_state_tree_id, &tree_id, st);\n#if NPFLOW > 0\n\tif (st->state_flags & PFSTATE_PFLOW)\n\t\texport_pflow(st);\n#endif\t\n#if NPFSYNC > 0\n\tpfsync_delete_state(st);\n#endif\t\n\tpf_src_tree_remove_state(st);\n\tpf_detach_state(st);\n}", "target": 1}
