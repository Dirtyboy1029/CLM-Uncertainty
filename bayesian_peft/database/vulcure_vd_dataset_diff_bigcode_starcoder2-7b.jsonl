{"code": "int fit_image_verify(const void *fit, int image_noffset)\n{\n\tconst void\t*data;\n\tsize_t\t\tsize;\n\tint\t\tnoffset = 0;\n\tchar\t\t*err_msg = \"\";\n\tif (fit_image_get_data_and_size(fit, image_noffset, &data, &size)) {\n\t\terr_msg = \"Can't get image data/size\";\n\t\tprintf(\"error!\\n%s for '%s' hash node in '%s' image node\\n\",\n\t\t       err_msg, fit_get_name(fit, noffset, NULL),\n\t\t       fit_get_name(fit, image_noffset, NULL));\n\t\treturn 0;\n\t}\n\treturn fit_image_verify_with_data(fit, image_noffset, data, size);\n}", "target": 1}
{"code": "static void inet_get_ping_group_range_net(struct net *net, kgid_t *low,\n\t\t\t\t\t  kgid_t *high)\n{\n\tkgid_t *data = net->ipv4.ping_group_range.range;\n\tunsigned int seq;\n\tdo {\n\t\tseq = read_seqbegin(&net->ipv4.ping_group_range.lock);\n\t\t*low = data[0];\n\t\t*high = data[1];\n\t} while (read_seqretry(&net->ipv4.ping_group_range.lock, seq));\n}", "target": 0}
{"code": "int blk_init_allocated_queue(struct request_queue *q)\n{\n\tWARN_ON_ONCE(q->mq_ops);\n\tq->fq = blk_alloc_flush_queue(q, NUMA_NO_NODE, q->cmd_size);\n\tif (!q->fq)\n\t\treturn -ENOMEM;\n\tif (q->init_rq_fn && q->init_rq_fn(q, q->fq->flush_rq, GFP_KERNEL))\n\t\tgoto out_free_flush_queue;\n\tif (blk_init_rl(&q->root_rl, q, GFP_KERNEL))\n\t\tgoto out_exit_flush_rq;\n\tINIT_WORK(&q->timeout_work, blk_timeout_work);\n\tq->queue_flags\t\t|= QUEUE_FLAG_DEFAULT;\n\tblk_queue_make_request(q, blk_queue_bio);\n\tq->sg_reserved_size = INT_MAX;\n\tif (elevator_init(q))\n\t\tgoto out_exit_flush_rq;\n\treturn 0;\nout_exit_flush_rq:\n\tif (q->exit_rq_fn)\n\t\tq->exit_rq_fn(q, q->fq->flush_rq);\nout_free_flush_queue:\n\tblk_free_flush_queue(q->fq);\n\tq->fq = NULL;\n\treturn -ENOMEM;\n}", "target": 0}
{"code": "option_persist_cb (const gchar *option_name,\n                   const gchar *value,\n                   gpointer     data,\n                   GError     **error)\n{\n  FlatpakContext *context = data;\n  flatpak_context_set_persistent (context, value);\n  return TRUE;\n}", "target": 1}
{"code": "escape_xml(const char *text)\n{\n\tstatic char *escaped;\n\tstatic size_t escaped_size;\n\tchar *out;\n\tsize_t len;\n\tif (!strlen(text)) return \"\";\n\tfor (out=escaped, len=0; *text; ++len, ++out, ++text) {\n\t\tif ((len + 8) > escaped_size) {\n\t\t\tchar *bigger_escaped;\n\t\t\tescaped_size += 128;\n\t\t\tbigger_escaped = realloc(escaped, escaped_size);\n\t\t\tif (!bigger_escaped) {\n\t\t\t\tfree(escaped);\t\n\t\t\t\tescaped = NULL;\n\t\t\t\tescaped_size = 0;\n\t\t\t\treturn \">>> out of memory <<<\";\n\t\t\t}\n\t\t\tout = bigger_escaped + len;\n\t\t\tescaped = bigger_escaped;\n\t\t}\n\t\tswitch (*text) {\n\t\t\tcase '&':\n\t\t\t\tstrcpy(out, \"&amp;\");\n\t\t\t\tlen += strlen(out) - 1;\n\t\t\t\tout = escaped + len;\n\t\t\t\tbreak;\n\t\t\tcase '<':\n\t\t\t\tstrcpy(out, \"&lt;\");\n\t\t\t\tlen += strlen(out) - 1;\n\t\t\t\tout = escaped + len;\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\tstrcpy(out, \"&gt;\");\n\t\t\t\tlen += strlen(out) - 1;\n\t\t\t\tout = escaped + len;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t*out = *text;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t*out = '\\x0';  \n\treturn escaped;\n}", "target": 0}
{"code": "EntropyParser::EntropyParser(class Frame *frame,class Scan *scan)\n  : JKeeper(scan->EnvironOf()), m_pScan(scan), m_pFrame(frame)\n{\n  m_ucCount = scan->ComponentsInScan();\n  for(volatile UBYTE i = 0;i < m_ucCount && i < 4;i++) {\n    JPG_TRY {\n      m_pComponent[i] = scan->ComponentOf(i);\n    } JPG_CATCH {\n      m_pComponent[i] = NULL;\n    } JPG_ENDTRY;\n  }\n  m_ulRestartInterval   = m_pFrame->TablesOf()->RestartIntervalOf();\n  m_usNextRestartMarker = 0xffd0;\n  m_ulMCUsToGo          = m_ulRestartInterval;\n  m_bSegmentIsValid     = true;\n  m_bScanForDNL         = (m_pFrame->HeightOf() == 0)?true:false;\n  m_bDNLFound           = false;\n}", "target": 1}
{"code": "njs_promise_prototype_then(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    njs_int_t                 ret;\n    njs_value_t               *promise, *fulfilled, *rejected, constructor;\n    njs_object_t              *object;\n    njs_function_t            *function;\n    njs_promise_capability_t  *capability;\n    promise = njs_argument(args, 0);\n    if (njs_slow_path(!njs_is_object(promise))) {\n        goto failed;\n    }\n    object = njs_object_proto_lookup(njs_object(promise), NJS_PROMISE,\n                                     njs_object_t);\n    if (njs_slow_path(object == NULL)) {\n        goto failed;\n    }\n    function = njs_promise_create_function(vm, sizeof(njs_promise_context_t));\n    function->u.native = njs_promise_constructor;\n    njs_set_function(&constructor, function);\n    ret = njs_value_species_constructor(vm, promise, &constructor,\n                                        &constructor);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    capability = njs_promise_new_capability(vm, &constructor);\n    if (njs_slow_path(capability == NULL)) {\n        return NJS_ERROR;\n    }\n    fulfilled = njs_arg(args, nargs, 1);\n    rejected = njs_arg(args, nargs, 2);\n    return njs_promise_perform_then(vm, promise, fulfilled, rejected,\n                                    capability);\nfailed:\n    njs_type_error(vm, \"required a promise object\");\n    return NJS_ERROR;\n}", "target": 1}
{"code": "static struct mnt_namespace *create_mnt_ns(struct vfsmount *m)\n{\n\tstruct mnt_namespace *new_ns = alloc_mnt_ns(&init_user_ns);\n\tif (!IS_ERR(new_ns)) {\n\t\tstruct mount *mnt = real_mount(m);\n\t\tmnt->mnt_ns = new_ns;\n\t\tnew_ns->root = mnt;\n\t\tnew_ns->mounts++;\n\t\tlist_add(&mnt->mnt_list, &new_ns->list);\n\t} else {\n\t\tmntput(m);\n\t}\n\treturn new_ns;\n}", "target": 0}
{"code": "static MagickBooleanType DecodeLabImage(Image *image,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n  MagickBooleanType\n    status;\n  ssize_t\n    y;\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    PixelPacket\n      *magick_restrict q;\n    ssize_t\n      x;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      {\n        status=MagickFalse;\n        break;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        a,\n        b;\n      a=QuantumScale*GetPixela(q)+0.5;\n      if (a > 1.0)\n        a-=1.0;\n      b=QuantumScale*GetPixelb(q)+0.5;\n      if (b > 1.0)\n        b-=1.0;\n      SetPixela(q,QuantumRange*a);\n      SetPixelb(q,QuantumRange*b);\n      q++;\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      {\n        status=MagickFalse;\n        break;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}", "target": 0}
{"code": "usm_malloc_usmStateReference(void)\n{\n    struct usmStateReference *retval = (struct usmStateReference *)\n        calloc(1, sizeof(struct usmStateReference));\n    return retval;\n}                               ", "target": 1}
{"code": "NativeModule::NativeModule(const std::string& filename) : init(nullptr) {\n\tif (!IsolateEnvironment::GetCurrent()->IsDefault()) {\n\t\tthrow RuntimeGenericError(\"NativeModule may only be instantiated from default nodejs isolate\");\n\t}\n\tif (uv_dlopen(filename.c_str(), &lib) != 0) {\n\t\tthrow RuntimeGenericError(\"Failed to load module\");\n\t}\n\tif (uv_dlsym(&lib, \"InitForContext\", reinterpret_cast<void**>(&init)) != 0 || init == nullptr) {\n\t\tuv_dlclose(&lib);\n\t\tthrow RuntimeGenericError(\"Module is not isolated-vm compatible\");\n\t}\n}", "target": 0}
{"code": "int pkey_gost_decrypt(EVP_PKEY_CTX *pctx, unsigned char *key,\n                      size_t *key_len, const unsigned char *in, size_t in_len)\n{\n    struct gost_pmeth_data *gctx = EVP_PKEY_CTX_get_data(pctx);\n    if (key == NULL) {\n        *key_len = 32;\n        return 1;\n    }\n    if (key != NULL && *key_len < 32) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, GOST_R_INVALID_BUFFER_SIZE);\n        return 0;\n    }\n    switch (gctx->cipher_nid)\n    {\n        case NID_id_Gost28147_89:\n        case NID_undef: \n            return pkey_GOST_ECcp_decrypt(pctx, key, key_len, in, in_len);\n        case NID_kuznyechik_ctr:\n        case NID_magma_ctr:\n            return pkey_gost2018_decrypt(pctx, key, key_len, in, in_len);\n        default:\n      GOSTerr(GOST_F_PKEY_GOST_DECRYPT, ERR_R_INTERNAL_ERROR);\n      return -1;\n    }\n}", "target": 0}
{"code": "    long PreviewImage::writeFile(const std::wstring& wpath) const\n    {\n        std::wstring name = wpath + wextension();\n        DataBuf buf(pData_, size_);\n        return Exiv2::writeFile(buf, name);\n    }", "target": 0}
{"code": "kdc_process_s4u_x509_user(krb5_context context,\n                          krb5_kdc_req *request,\n                          krb5_pa_data *pa_data,\n                          krb5_keyblock *tgs_subkey,\n                          krb5_keyblock *tgs_session,\n                          krb5_pa_s4u_x509_user **s4u_x509_user,\n                          const char **status)\n{\n    krb5_error_code             code;\n    krb5_data                   req_data;\n    req_data.length = pa_data->length;\n    req_data.data = (char *)pa_data->contents;\n    code = decode_krb5_pa_s4u_x509_user(&req_data, s4u_x509_user);\n    if (code)\n        return code;\n    code = verify_s4u_x509_user_checksum(context,\n                                         tgs_subkey ? tgs_subkey :\n                                         tgs_session,\n                                         &req_data,\n                                         request->nonce, *s4u_x509_user);\n    if (code) {\n        *status = \"INVALID_S4U2SELF_CHECKSUM\";\n        krb5_free_pa_s4u_x509_user(context, *s4u_x509_user);\n        *s4u_x509_user = NULL;\n        return code;\n    }\n    if (krb5_princ_size(context, (*s4u_x509_user)->user_id.user) == 0 ||\n        (*s4u_x509_user)->user_id.subject_cert.length != 0) {\n        *status = \"INVALID_S4U2SELF_REQUEST\";\n        krb5_free_pa_s4u_x509_user(context, *s4u_x509_user);\n        *s4u_x509_user = NULL;\n        return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n    }\n    return 0;\n}", "target": 1}
{"code": "uint64_t HeaderMapImpl::refreshByteSize() {\n  if (!cached_byte_size_.has_value()) {\n    cached_byte_size_ = byteSizeInternal();\n  }\n  return cached_byte_size_.value();\n}", "target": 0}
{"code": "static void kvm_vcpu_destroy(struct kvm_vcpu *vcpu)\n{\n\tkvm_dirty_ring_free(&vcpu->dirty_ring);\n\tkvm_arch_vcpu_destroy(vcpu);\n\tput_pid(rcu_dereference_protected(vcpu->pid, 1));\n\tfree_page((unsigned long)vcpu->run);\n\tkmem_cache_free(kvm_vcpu_cache, vcpu);\n}", "target": 1}
{"code": "nfs3svc_decode_symlinkargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_symlinkargs *args)\n{\n\tunsigned int len, avail;\n\tchar *old, *new;\n\tstruct kvec *vec;\n\tif (!(p = decode_fh(p, &args->ffh)) ||\n\t    !(p = decode_filename(p, &args->fname, &args->flen))\n\t\t)\n\t\treturn 0;\n\tp = decode_sattr3(p, &args->attrs);\n\tlen = ntohl(*p++);\n\tif (len == 0 || len > NFS3_MAXPATHLEN || len >= PAGE_SIZE)\n\t\treturn 0;\n\targs->tname = new = page_address(*(rqstp->rq_next_page++));\n\targs->tlen = len;\n\told = (char*)p;\n\tvec = &rqstp->rq_arg.head[0];\n\tif ((void *)old > vec->iov_base + vec->iov_len)\n\t\treturn 0;\n\tavail = vec->iov_len - (old - (char*)vec->iov_base);\n\twhile (len && avail && *old) {\n\t\t*new++ = *old++;\n\t\tlen--;\n\t\tavail--;\n\t}\n\tif (len && !avail && rqstp->rq_arg.page_len) {\n\t\tavail = min_t(unsigned int, rqstp->rq_arg.page_len, PAGE_SIZE);\n\t\told = page_address(rqstp->rq_arg.pages[0]);\n\t}\n\twhile (len && avail && *old) {\n\t\t*new++ = *old++;\n\t\tlen--;\n\t\tavail--;\n\t}\n\t*new = '\\0';\n\tif (len)\n\t\treturn 0;\n\treturn 1;\n}", "target": 0}
{"code": "static uint8_t excluded_channels(bitfile *ld, drc_info *drc)\n{\n    uint8_t i, n = 0;\n    uint8_t num_excl_chan = 7;\n    for (i = 0; i < 7; i++)\n    {\n        drc->exclude_mask[i] = faad_get1bit(ld\n            DEBUGVAR(1,103,\"excluded_channels(): exclude_mask\"));\n    }\n    n++;\n    while ((drc->additional_excluded_chns[n-1] = faad_get1bit(ld\n        DEBUGVAR(1,104,\"excluded_channels(): additional_excluded_chns\"))) == 1)\n    {\n        if (i >= MAX_CHANNELS - num_excl_chan - 7)\n            return n;\n        for (i = num_excl_chan; i < num_excl_chan+7; i++)\n        {\n            drc->exclude_mask[i] = faad_get1bit(ld\n                DEBUGVAR(1,105,\"excluded_channels(): exclude_mask\"));\n        }\n        n++;\n        num_excl_chan += 7;\n    }\n    return n;\n}", "target": 0}
{"code": "rb_xml_reader_attribute_hash(VALUE rb_reader)\n{\n  VALUE rb_attributes = rb_hash_new();\n  xmlTextReaderPtr c_reader;\n  xmlNodePtr c_node;\n  xmlAttrPtr c_property;\n  Data_Get_Struct(rb_reader, xmlTextReader, c_reader);\n  if (!has_attributes(c_reader)) {\n    return rb_attributes;\n  }\n  c_node = xmlTextReaderExpand(c_reader);\n  if (c_node == NULL) {\n    return Qnil;\n  }\n  c_property = c_node->properties;\n  while (c_property != NULL) {\n    VALUE rb_name = NOKOGIRI_STR_NEW2(c_property->name);\n    VALUE rb_value = Qnil;\n    xmlChar *c_value = xmlNodeGetContent((xmlNode *)c_property);\n    if (c_value) {\n      rb_value = NOKOGIRI_STR_NEW2(c_value);\n      xmlFree(c_value);\n    }\n    rb_hash_aset(rb_attributes, rb_name, rb_value);\n    c_property = c_property->next;\n  }\n  return rb_attributes;\n}", "target": 0}
{"code": "static void inotify_free_group_priv(struct fsnotify_group *group)\n{\n\tidr_for_each(&group->inotify_data.idr, idr_callback, group);\n\tidr_remove_all(&group->inotify_data.idr);\n\tidr_destroy(&group->inotify_data.idr);\n\tatomic_dec(&group->inotify_data.user->inotify_devs);\n\tfree_uid(group->inotify_data.user);\n}", "target": 0}
{"code": "\t\tauto GetKey(Local<Context> context) -> Local<Name> {\n\t\t\tauto key_inner = key->CopyInto();\n\t\t\treturn (key_inner->IsString() || key_inner->IsSymbol()) ?\n\t\t\t\tkey_inner.As<Name>() : Unmaybe(key_inner->ToString(context)).As<Name>();\n\t\t}", "target": 0}
{"code": "static int ext4_fill_flex_info(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_group_desc *gdp = NULL;\n\text4_group_t flex_group_count;\n\text4_group_t flex_group;\n\tint groups_per_flex = 0;\n\tsize_t size;\n\tint i;\n\tsbi->s_log_groups_per_flex = sbi->s_es->s_log_groups_per_flex;\n\tgroups_per_flex = 1 << sbi->s_log_groups_per_flex;\n\tif (groups_per_flex < 2) {\n\t\tsbi->s_log_groups_per_flex = 0;\n\t\treturn 1;\n\t}\n\tflex_group_count = ((sbi->s_groups_count + groups_per_flex - 1) +\n\t\t\t((le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) + 1) <<\n\t\t\t      EXT4_DESC_PER_BLOCK_BITS(sb))) / groups_per_flex;\n\tsize = flex_group_count * sizeof(struct flex_groups);\n\tsbi->s_flex_groups = ext4_kvzalloc(size, GFP_KERNEL);\n\tif (sbi->s_flex_groups == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory for %u flex groups\",\n\t\t\t flex_group_count);\n\t\tgoto failed;\n\t}\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\t\tflex_group = ext4_flex_group(sbi, i);\n\t\tatomic_add(ext4_free_inodes_count(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].free_inodes);\n\t\tatomic_add(ext4_free_group_clusters(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].free_clusters);\n\t\tatomic_add(ext4_used_dirs_count(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].used_dirs);\n\t}\n\treturn 1;\nfailed:\n\treturn 0;\n}", "target": 1}
{"code": "comics_document_class_init (ComicsDocumentClass *klass)\n{\n\tGObjectClass    *gobject_class = G_OBJECT_CLASS (klass);\n\tEvDocumentClass *ev_document_class = EV_DOCUMENT_CLASS (klass);\n\tgobject_class->finalize = comics_document_finalize;\n\tev_document_class->load = comics_document_load;\n\tev_document_class->save = comics_document_save;\n\tev_document_class->get_n_pages = comics_document_get_n_pages;\n\tev_document_class->get_page_size = comics_document_get_page_size;\n\tev_document_class->render = comics_document_render;\n}", "target": 0}
{"code": "static inline bool unconditional(const struct arpt_arp *arp)\n{\n\tstatic const struct arpt_arp uncond;\n\treturn memcmp(arp, &uncond, sizeof(uncond)) == 0;\n}", "target": 1}
{"code": "static void *snd_malloc_sbus_pages(struct device *dev, size_t size,\n\t\t\t\t   dma_addr_t *dma_addr)\n{\n\tstruct sbus_dev *sdev = (struct sbus_dev *)dev;\n\tint pg;\n\tvoid *res;\n\tsnd_assert(size > 0, return NULL);\n\tsnd_assert(dma_addr != NULL, return NULL);\n\tpg = get_order(size);\n\tres = sbus_alloc_consistent(sdev, PAGE_SIZE * (1 << pg), dma_addr);\n\tif (res != NULL)\n\t\tinc_snd_pages(pg);\n\treturn res;\n}", "target": 0}
{"code": "w3m_exit(int i)\n{\n#ifdef USE_MIGEMO\n    init_migemo();\t\t\n#endif\n    stopDownload();\n    deleteFiles();\n#ifdef USE_SSL\n    free_ssl_ctx();\n#endif\n    disconnectFTP();\n#ifdef USE_NNTP\n    disconnectNews();\n#endif\n#ifdef __MINGW32_VERSION\n    WSACleanup();\n#endif\n#ifdef HAVE_MKDTEMP\n    if (no_rc_dir && tmp_dir != rc_dir)\n\tif (rmdir(tmp_dir) != 0) {\n\t    fprintf(stderr, \"Can't remove temporary directory (%s)!\\n\", tmp_dir);\n\t    exit(1);\n\t}\n#endif\n    exit(i);\n}", "target": 0}
{"code": "xfs_iunlink_free_item(\n\tvoid\t\t\t*ptr,\n\tvoid\t\t\t*arg)\n{\n\tstruct xfs_iunlink\t*iu = ptr;\n\tbool\t\t\t*freed_anything = arg;\n\t*freed_anything = true;\n\tkmem_free(iu);\n}", "target": 0}
{"code": "static void recalculate_apic_map(struct kvm *kvm)\n{\n\tstruct kvm_apic_map *new, *old = NULL;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\tnew = kzalloc(sizeof(struct kvm_apic_map), GFP_KERNEL);\n\tmutex_lock(&kvm->arch.apic_map_lock);\n\tif (!new)\n\t\tgoto out;\n\tnew->ldr_bits = 8;\n\tnew->cid_shift = 8;\n\tnew->cid_mask = 0;\n\tnew->lid_mask = 0xff;\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\t\tu16 cid, lid;\n\t\tu32 ldr;\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tnew->ldr_bits = 32;\n\t\t\tnew->cid_shift = 16;\n\t\t\tnew->cid_mask = new->lid_mask = 0xffff;\n\t\t} else if (kvm_apic_sw_enabled(apic) &&\n\t\t\t\t!new->cid_mask  &&\n\t\t\t\tkvm_apic_get_reg(apic, APIC_DFR) == APIC_DFR_CLUSTER) {\n\t\t\tnew->cid_shift = 4;\n\t\t\tnew->cid_mask = 0xf;\n\t\t\tnew->lid_mask = 0xf;\n\t\t}\n\t\tnew->phys_map[kvm_apic_id(apic)] = apic;\n\t\tldr = kvm_apic_get_reg(apic, APIC_LDR);\n\t\tcid = apic_cluster_id(new, ldr);\n\t\tlid = apic_logical_id(new, ldr);\n\t\tif (lid)\n\t\t\tnew->logical_map[cid][ffs(lid) - 1] = apic;\n\t}\nout:\n\told = rcu_dereference_protected(kvm->arch.apic_map,\n\t\t\tlockdep_is_held(&kvm->arch.apic_map_lock));\n\trcu_assign_pointer(kvm->arch.apic_map, new);\n\tmutex_unlock(&kvm->arch.apic_map_lock);\n\tif (old)\n\t\tkfree_rcu(old, rcu);\n\tkvm_vcpu_request_scan_ioapic(kvm);\n}", "target": 1}
{"code": "static char *r_buf_read_string (RBuffer *buf, ut64 addr, int len) {\n\tut8 *data = malloc (len);\n\tif (data) {\n\t\tr_buf_read_at (buf, addr, data, len);\n\t\tdata[len-1] = 0;\n\t\treturn data;\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "DeletePortMappingRange(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r = -1;\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"</u:%sResponse>\";\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tconst char * protocol;\n\tconst char * startport_s, * endport_s;\n\tunsigned short startport, endport;\n\tunsigned short * port_list;\n\tunsigned int i, number = 0;\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tstartport_s = GetValueFromNameValueList(&data, \"NewStartPort\");\n\tendport_s = GetValueFromNameValueList(&data, \"NewEndPort\");\n\tprotocol = GetValueFromNameValueList(&data, \"NewProtocol\");\n\tif(startport_s == NULL || endport_s == NULL || protocol == NULL ||\n\t   !is_numeric(startport_s) || !is_numeric(endport_s)) {\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\tClearNameValueList(&data);\n\t\treturn;\n\t}\n\tstartport = (unsigned short)atoi(startport_s);\n\tendport = (unsigned short)atoi(endport_s);\n\tif(startport > endport)\n\t{\n\t\tSoapError(h, 733, \"InconsistentParameter\");\n\t\tClearNameValueList(&data);\n\t\treturn;\n\t}\n\tsyslog(LOG_INFO, \"%s: deleting external ports: %hu-%hu, protocol: %s\",\n\t       action, startport, endport, protocol);\n\tport_list = upnp_get_portmappings_in_range(startport, endport,\n\t                                           protocol, &number);\n\tif(number == 0)\n\t{\n\t\tSoapError(h, 730, \"PortMappingNotFound\");\n\t\tClearNameValueList(&data);\n\t\tfree(port_list);\n\t\treturn;\n\t}\n\tfor(i = 0; i < number; i++)\n\t{\n\t\tr = upnp_delete_redirection(port_list[i], protocol);\n\t\tsyslog(LOG_INFO, \"%s: deleting external port: %hu, protocol: %s: %s\",\n\t\t       action, port_list[i], protocol, r < 0 ? \"failed\" : \"ok\");\n\t}\n\tfree(port_list);\n\tbodylen = snprintf(body, sizeof(body), resp,\n\t                   action, ns, action);\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\tClearNameValueList(&data);\n}", "target": 0}
{"code": "GF_Err urn_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, to_read;\n\tchar *tmpName;\n\tGF_DataEntryURNBox *ptr = (GF_DataEntryURNBox *)s;\n\tif (! ptr->size ) return GF_OK;\n\tto_read = (u32) ptr->size;\n\ttmpName = (char*)gf_malloc(sizeof(char) * to_read);\n\tif (!tmpName) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, tmpName, to_read);\n\ti = 0;\n\twhile ( (tmpName[i] != 0) && (i < to_read) ) {\n\t\ti++;\n\t}\n\tif (i == to_read) {\n\t\tgf_free(tmpName);\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (i == to_read - 1) {\n\t\tptr->nameURN = tmpName;\n\t\tptr->location = NULL;\n\t\treturn GF_OK;\n\t}\n\tptr->nameURN = (char*)gf_malloc(sizeof(char) * (i+1));\n\tif (!ptr->nameURN) {\n\t\tgf_free(tmpName);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tptr->location = (char*)gf_malloc(sizeof(char) * (to_read - i - 1));\n\tif (!ptr->location) {\n\t\tgf_free(tmpName);\n\t\tgf_free(ptr->nameURN);\n\t\tptr->nameURN = NULL;\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tmemcpy(ptr->nameURN, tmpName, i + 1);\n\tmemcpy(ptr->location, tmpName + i + 1, (to_read - i - 1));\n\tgf_free(tmpName);\n\treturn GF_OK;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    auto x = ctx->input(0);\n    auto i = ctx->input(1);\n    auto v = ctx->input(2);\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(i.shape()),\n                errors::InvalidArgument(\"i must be a vector. \",\n                                        i.shape().DebugString()));\n    OP_REQUIRES(ctx, x.dims() == v.dims(),\n                errors::InvalidArgument(\n                    \"x and v shape doesn't match (ranks differ): \",\n                    x.shape().DebugString(), \" vs. \", v.shape().DebugString()));\n    for (int i = 1; i < x.dims(); ++i) {\n      OP_REQUIRES(\n          ctx, x.dim_size(i) == v.dim_size(i),\n          errors::InvalidArgument(\"x and v shape doesn't match at index \", i,\n                                  \" : \", x.shape().DebugString(), \" vs. \",\n                                  v.shape().DebugString()));\n    }\n    OP_REQUIRES(ctx, i.dim_size(0) == v.dim_size(0),\n                errors::InvalidArgument(\n                    \"i and x shape doesn't match at index 0: \",\n                    i.shape().DebugString(), \" vs. \", v.shape().DebugString()));\n    Tensor y = x;  \n    if (x.NumElements() > 0 || v.NumElements() > 0) {\n      OP_REQUIRES_OK(ctx, DoCompute(ctx, i, v, &y));\n    }\n    ctx->set_output(0, y);\n  }", "target": 1}
{"code": "void LanLinkProvider::dataReceived()\n{\n    QSslSocket* socket = qobject_cast<QSslSocket*>(sender());\n    if (socket->bytesAvailable() > 8192) {\n        qCWarning(KDECONNECT_CORE) << \"LanLinkProvider/newConnection: Suspiciously long identity package received. Closing connection.\" << socket->peerAddress() << socket->bytesAvailable();\n        socket->disconnectFromHost();\n        return;\n    }\n#if QT_VERSION < QT_VERSION_CHECK(5,7,0)\n    if (!socket->canReadLine())\n        return;\n#else\n    socket->startTransaction();\n#endif\n    const QByteArray data = socket->readLine();\n    qCDebug(KDECONNECT_CORE) << \"LanLinkProvider received reply:\" << data;\n    NetworkPacket* np = new NetworkPacket(QLatin1String(\"\"));\n    bool success = NetworkPacket::unserialize(data, np);\n#if QT_VERSION < QT_VERSION_CHECK(5,7,0)\n    if (!success) {\n        delete np;\n        return;\n    }\n#else\n    if (!success) {\n        delete np;\n        socket->rollbackTransaction();\n        return;\n    }\n    socket->commitTransaction();\n#endif\n    if (np->type() != PACKET_TYPE_IDENTITY) {\n        qCWarning(KDECONNECT_CORE) << \"LanLinkProvider/newConnection: Expected identity, received \" << np->type();\n        delete np;\n        return;\n    }\n    m_receivedIdentityPackets[socket].np = np;\n    const QString& deviceId = np->get<QString>(QStringLiteral(\"deviceId\"));\n    disconnect(socket, &QIODevice::readyRead, this, &LanLinkProvider::dataReceived);\n    if (np->get<int>(QStringLiteral(\"protocolVersion\")) >= MIN_VERSION_WITH_SSL_SUPPORT) {\n        bool isDeviceTrusted = KdeConnectConfig::instance().trustedDevices().contains(deviceId);\n        configureSslSocket(socket, deviceId, isDeviceTrusted);\n        qCDebug(KDECONNECT_CORE) << \"Starting client ssl (but I'm the server TCP socket)\";\n        connect(socket, &QSslSocket::encrypted, this, &LanLinkProvider::encrypted);\n        if (isDeviceTrusted) {\n            connect(socket, QOverload<const QList<QSslError> &>::of(&QSslSocket::sslErrors), this, &LanLinkProvider::sslErrors);\n        }\n        socket->startClientEncryption();\n    } else {\n        qWarning() << np->get<QString>(QStringLiteral(\"deviceName\")) << \"uses an old protocol version, this won't work\";\n        delete m_receivedIdentityPackets.take(socket).np;\n    }\n}", "target": 0}
{"code": "static int dispatch_discard_io(struct xen_blkif *blkif,\n\t\t\t\tstruct blkif_request *req)\n{\n\tint err = 0;\n\tint status = BLKIF_RSP_OKAY;\n\tstruct block_device *bdev = blkif->vbd.bdev;\n\tunsigned long secure;\n\tblkif->st_ds_req++;\n\txen_blkif_get(blkif);\n\tsecure = (blkif->vbd.discard_secure &&\n\t\t (req->u.discard.flag & BLKIF_DISCARD_SECURE)) ?\n\t\t BLKDEV_DISCARD_SECURE : 0;\n\terr = blkdev_issue_discard(bdev, req->u.discard.sector_number,\n\t\t\t\t   req->u.discard.nr_sectors,\n\t\t\t\t   GFP_KERNEL, secure);\n\tif (err == -EOPNOTSUPP) {\n\t\tpr_debug(DRV_PFX \"discard op failed, not supported\\n\");\n\t\tstatus = BLKIF_RSP_EOPNOTSUPP;\n\t} else if (err)\n\t\tstatus = BLKIF_RSP_ERROR;\n\tmake_response(blkif, req->u.discard.id, req->operation, status);\n\txen_blkif_put(blkif);\n\treturn err;\n}", "target": 1}
{"code": "address_space_translate_for_iotlb(CPUState *cpu, int asidx, hwaddr addr,\n                                  hwaddr *xlat, hwaddr *plen,\n                                  MemTxAttrs attrs, int *prot)\n{\n    MemoryRegionSection *section;\n    IOMMUMemoryRegion *iommu_mr;\n    IOMMUMemoryRegionClass *imrc;\n    IOMMUTLBEntry iotlb;\n    int iommu_idx;\n    AddressSpaceDispatch *d =\n        qatomic_rcu_read(&cpu->cpu_ases[asidx].memory_dispatch);\n    for (;;) {\n        section = address_space_translate_internal(d, addr, &addr, plen, false);\n        iommu_mr = memory_region_get_iommu(section->mr);\n        if (!iommu_mr) {\n            break;\n        }\n        imrc = memory_region_get_iommu_class_nocheck(iommu_mr);\n        iommu_idx = imrc->attrs_to_index(iommu_mr, attrs);\n        tcg_register_iommu_notifier(cpu, iommu_mr, iommu_idx);\n        iotlb = imrc->translate(iommu_mr, addr, IOMMU_NONE, iommu_idx);\n        addr = ((iotlb.translated_addr & ~iotlb.addr_mask)\n                | (addr & iotlb.addr_mask));\n        if (!(iotlb.perm & IOMMU_RO)) {\n            *prot &= ~(PAGE_READ | PAGE_EXEC);\n        }\n        if (!(iotlb.perm & IOMMU_WO)) {\n            *prot &= ~PAGE_WRITE;\n        }\n        if (!*prot) {\n            goto translate_fail;\n        }\n        d = flatview_to_dispatch(address_space_to_flatview(iotlb.target_as));\n    }\n    assert(!memory_region_is_iommu(section->mr));\n    *xlat = addr;\n    return section;\ntranslate_fail:\n    return &d->map.sections[PHYS_SECTION_UNASSIGNED];\n}", "target": 1}
{"code": "nautilus_file_mark_desktop_file_trusted (GFile              *file,\n                                         GtkWindow          *parent_window,\n                                         gboolean            interactive,\n                                         NautilusOpCallback  done_callback,\n                                         gpointer            done_callback_data)\n{\n    GTask *task;\n    MarkTrustedJob *job;\n    job = op_job_new (MarkTrustedJob, parent_window);\n    job->file = g_object_ref (file);\n    job->interactive = interactive;\n    job->done_callback = done_callback;\n    job->done_callback_data = done_callback_data;\n    task = g_task_new (NULL, NULL, mark_trusted_task_done, job);\n    g_task_set_task_data (task, job, NULL);\n    g_task_run_in_thread (task, mark_trusted_task_thread_func);\n    g_object_unref (task);\n}", "target": 1}
{"code": "smb2_parse_lease_state(struct TCP_Server_Info *server,\n\t\t       struct smb2_create_rsp *rsp,\n\t\t       unsigned int *epoch, char *lease_key)\n{\n\tchar *data_offset;\n\tstruct create_context *cc;\n\tunsigned int next;\n\tunsigned int remaining;\n\tchar *name;\n\tdata_offset = (char *)rsp + le32_to_cpu(rsp->CreateContextsOffset);\n\tremaining = le32_to_cpu(rsp->CreateContextsLength);\n\tcc = (struct create_context *)data_offset;\n\twhile (remaining >= sizeof(struct create_context)) {\n\t\tname = le16_to_cpu(cc->NameOffset) + (char *)cc;\n\t\tif (le16_to_cpu(cc->NameLength) == 4 &&\n\t\t    strncmp(name, \"RqLs\", 4) == 0)\n\t\t\treturn server->ops->parse_lease_buf(cc, epoch,\n\t\t\t\t\t\t\t    lease_key);\n\t\tnext = le32_to_cpu(cc->Next);\n\t\tif (!next)\n\t\t\tbreak;\n\t\tremaining -= next;\n\t\tcc = (struct create_context *)((char *)cc + next);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void rds6_inc_info_copy(struct rds_incoming *inc,\n\t\t\tstruct rds_info_iterator *iter,\n\t\t\tstruct in6_addr *saddr, struct in6_addr *daddr,\n\t\t\tint flip)\n{\n\tstruct rds6_info_message minfo6;\n\tminfo6.seq = be64_to_cpu(inc->i_hdr.h_sequence);\n\tminfo6.len = be32_to_cpu(inc->i_hdr.h_len);\n\tminfo6.tos = inc->i_conn->c_tos;\n\tif (flip) {\n\t\tminfo6.laddr = *daddr;\n\t\tminfo6.faddr = *saddr;\n\t\tminfo6.lport = inc->i_hdr.h_dport;\n\t\tminfo6.fport = inc->i_hdr.h_sport;\n\t} else {\n\t\tminfo6.laddr = *saddr;\n\t\tminfo6.faddr = *daddr;\n\t\tminfo6.lport = inc->i_hdr.h_sport;\n\t\tminfo6.fport = inc->i_hdr.h_dport;\n\t}\n\tminfo6.flags = 0;\n\trds_info_copy(iter, &minfo6, sizeof(minfo6));\n}", "target": 0}
{"code": "static void calcstepsizes(uint_fast16_t refstepsize, int numrlvls,\n  uint_fast16_t *stepsizes)\n{\n\tint bandno;\n\tint numbands;\n\tuint_fast16_t expn;\n\tuint_fast16_t mant;\n\texpn = JPC_QCX_GETEXPN(refstepsize);\n\tmant = JPC_QCX_GETMANT(refstepsize);\n\tnumbands = 3 * numrlvls - 2;\n\tfor (bandno = 0; bandno < numbands; ++bandno) {\n\t\tstepsizes[bandno] = JPC_QCX_MANT(mant) | JPC_QCX_EXPN(expn +\n\t\t  (numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0))));\n\t}\n}", "target": 0}
{"code": "static void encode_share_access(struct xdr_stream *xdr, int open_flags)\n{\n\t__be32 *p;\n\tRESERVE_SPACE(8);\n\tswitch (open_flags & (FMODE_READ|FMODE_WRITE)) {\n\t\tcase FMODE_READ:\n\t\t\tWRITE32(NFS4_SHARE_ACCESS_READ);\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tWRITE32(NFS4_SHARE_ACCESS_WRITE);\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tWRITE32(NFS4_SHARE_ACCESS_BOTH);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t}\n\tWRITE32(0);\t\t\n}", "target": 1}
{"code": "int expand_downwards(struct vm_area_struct *vma,\n\t\t\t\t   unsigned long address)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct vm_area_struct *prev;\n\tint error;\n\taddress &= PAGE_MASK;\n\terror = security_mmap_addr(address);\n\tif (error)\n\t\treturn error;\n\tprev = vma->vm_prev;\n\tif (prev && !(prev->vm_flags & VM_GROWSDOWN) &&\n\t\t\t(prev->vm_flags & (VM_WRITE|VM_READ|VM_EXEC))) {\n\t\tif (address - prev->vm_end < stack_guard_gap)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\treturn -ENOMEM;\n\tanon_vma_lock_write(vma->anon_vma);\n\tif (address < vma->vm_start) {\n\t\tunsigned long size, grow;\n\t\tsize = vma->vm_end - address;\n\t\tgrow = (vma->vm_start - address) >> PAGE_SHIFT;\n\t\terror = -ENOMEM;\n\t\tif (grow <= vma->vm_pgoff) {\n\t\t\terror = acct_stack_growth(vma, size, grow);\n\t\t\tif (!error) {\n\t\t\t\tspin_lock(&mm->page_table_lock);\n\t\t\t\tif (vma->vm_flags & VM_LOCKED)\n\t\t\t\t\tmm->locked_vm += grow;\n\t\t\t\tvm_stat_account(mm, vma->vm_flags, grow);\n\t\t\t\tanon_vma_interval_tree_pre_update_vma(vma);\n\t\t\t\tvma->vm_start = address;\n\t\t\t\tvma->vm_pgoff -= grow;\n\t\t\t\tanon_vma_interval_tree_post_update_vma(vma);\n\t\t\t\tvma_gap_update(vma);\n\t\t\t\tspin_unlock(&mm->page_table_lock);\n\t\t\t\tperf_event_mmap(vma);\n\t\t\t}\n\t\t}\n\t}\n\tanon_vma_unlock_write(vma->anon_vma);\n\tkhugepaged_enter_vma_merge(vma, vma->vm_flags);\n\tvalidate_mm(mm);\n\treturn error;\n}", "target": 1}
{"code": "void sort_directory(struct dir *dir)\n{\n\tstruct dir_ent *cur, *l1, *l2, *next;\n\tint len1, len2, stride = 1;\n\tif(dir->dir_count < 2)\n\t\treturn;\n\tdo {\n\t\tl2 = dir->dirs; \n\t\tcur = NULL; \n\t\twhile(l2) {\n\t\t\tl1 = l2;\n\t\t\tfor(len1 = 0; l2 && len1 < stride; len1 ++, l2 = l2->next);\n\t\t\tlen2 = stride;\n\t\t\twhile(len1 && l2 && len2) {\n\t\t\t\tif(strcmp(l1->name, l2->name) <= 0) {\n\t\t\t\t\tnext = l1;\n\t\t\t\t\tl1 = l1->next;\n\t\t\t\t\tlen1 --;\n\t\t\t\t} else {\n\t\t\t\t\tnext = l2;\n\t\t\t\t\tl2 = l2->next;\n\t\t\t\t\tlen2 --;\n\t\t\t\t}\n\t\t\t\tif(cur) {\n\t\t\t\t\tcur->next = next;\n\t\t\t\t\tcur = next;\n\t\t\t\t} else\n\t\t\t\t\tdir->dirs = cur = next;\n\t\t\t}\n\t\t\tfor(; len1; len1 --, l1 = l1->next) {\n\t\t\t\tif(cur) {\n\t\t\t\t\tcur->next = l1;\n\t\t\t\t\tcur = l1;\n\t\t\t\t} else\n\t\t\t\t\tdir->dirs = cur = l1;\n\t\t\t}\n\t\t\tfor(; l2 && len2; len2 --, l2 = l2->next) {\n\t\t\t\tif(cur) {\n\t\t\t\t\tcur->next = l2;\n\t\t\t\t\tcur = l2;\n\t\t\t\t} else\n\t\t\t\t\tdir->dirs = cur = l2;\n\t\t\t}\n\t\t}\n\t\tcur->next = NULL;\n\t\tstride = stride << 1;\n\t} while(stride < dir->dir_count);\n}", "target": 0}
{"code": "static void do_free_upto(BIO *f, BIO *upto)\n\t{\n\tif (upto)\n\t\t{\n\t\tBIO *tbio;\n\t\tdo \n\t\t\t{\n\t\t\ttbio = BIO_pop(f);\n\t\t\tBIO_free(f);\n\t\t\tf = tbio;\n\t\t\t}\n\t\twhile (f != upto);\n\t\t}\n\telse\n\t\tBIO_free_all(f);\n\t}", "target": 1}
{"code": "HttpRequest::maybeCacheable()\n{\n    if (!flags.hostVerified && (flags.intercepted || flags.interceptTproxy))\n        return false;\n    switch (url.getScheme()) {\n    case AnyP::PROTO_HTTP:\n    case AnyP::PROTO_HTTPS:\n        if (!method.respMaybeCacheable())\n            return false;\n        if (!flags.ignoreCc && cache_control && cache_control->hasNoStore())\n            return false;\n        break;\n    case AnyP::PROTO_GOPHER:\n        if (!gopherCachable(this))\n            return false;\n        break;\n    case AnyP::PROTO_CACHE_OBJECT:\n        return false;\n    default:\n        break;\n    }\n    return true;\n}", "target": 1}
{"code": "void exit_io_context(struct task_struct *task)\n{\n\tstruct io_context *ioc;\n\ttask_lock(task);\n\tioc = task->io_context;\n\ttask->io_context = NULL;\n\ttask_unlock(task);\n\tif (atomic_dec_and_test(&ioc->nr_tasks)) {\n\t\tif (ioc->aic && ioc->aic->exit)\n\t\t\tioc->aic->exit(ioc->aic);\n\t\tcfq_exit(ioc);\n\t}\n\tput_io_context(ioc);\n}", "target": 0}
{"code": "mark_desktop_file_executable (CommonJob    *common,\n                              GCancellable *cancellable,\n                              GFile        *file,\n                              gboolean      interactive)\n{\n    GError *error;\n    guint32 current_perms, new_perms;\n    int response;\n    GFileInfo *info;\nretry:\n    error = NULL;\n    info = g_file_query_info (file,\n                              G_FILE_ATTRIBUTE_STANDARD_TYPE \",\"\n                              G_FILE_ATTRIBUTE_UNIX_MODE,\n                              G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                              common->cancellable,\n                              &error);\n    if (info == NULL)\n    {\n        if (interactive)\n        {\n            response = run_error (common,\n                                  g_strdup (_(\"Unable to mark launcher trusted (executable)\")),\n                                  error->message,\n                                  NULL,\n                                  FALSE,\n                                  CANCEL, RETRY,\n                                  NULL);\n        }\n        else\n        {\n            response = 0;\n        }\n        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n        {\n            abort_job (common);\n        }\n        else if (response == 1)\n        {\n            goto retry;\n        }\n        else\n        {\n            g_assert_not_reached ();\n        }\n        goto out;\n    }\n    if (g_file_info_has_attribute (info, G_FILE_ATTRIBUTE_UNIX_MODE))\n    {\n        current_perms = g_file_info_get_attribute_uint32 (info, G_FILE_ATTRIBUTE_UNIX_MODE);\n        new_perms = current_perms | S_IXGRP | S_IXUSR | S_IXOTH;\n        if ((current_perms != new_perms) &&\n            !g_file_set_attribute_uint32 (file, G_FILE_ATTRIBUTE_UNIX_MODE,\n                                          new_perms, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                          common->cancellable, &error))\n        {\n            g_object_unref (info);\n            if (interactive)\n            {\n                response = run_error (common,\n                                      g_strdup (_(\"Unable to mark launcher trusted (executable)\")),\n                                      error->message,\n                                      NULL,\n                                      FALSE,\n                                      CANCEL, RETRY,\n                                      NULL);\n            }\n            else\n            {\n                response = 0;\n            }\n            if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n            {\n                abort_job (common);\n            }\n            else if (response == 1)\n            {\n                goto retry;\n            }\n            else\n            {\n                g_assert_not_reached ();\n            }\n            goto out;\n        }\n    }\n    g_object_unref (info);\nout:\n    ;\n}", "target": 0}
{"code": "bool current_chrooted(void)\n{\n\tstruct path ns_root;\n\tstruct path fs_root;\n\tbool chrooted;\n\tns_root.mnt = &current->nsproxy->mnt_ns->root->mnt;\n\tns_root.dentry = ns_root.mnt->mnt_root;\n\tpath_get(&ns_root);\n\twhile (d_mountpoint(ns_root.dentry) && follow_down_one(&ns_root))\n\t\t;\n\tget_fs_root(current->fs, &fs_root);\n\tchrooted = !path_equal(&fs_root, &ns_root);\n\tpath_put(&fs_root);\n\tpath_put(&ns_root);\n\treturn chrooted;\n}", "target": 0}
{"code": "static void unix_detach_fds(struct scm_cookie *scm, struct sk_buff *skb)\n{\n\tint i;\n\tscm->fp = UNIXCB(skb).fp;\n\tUNIXCB(skb).fp = NULL;\n\tfor (i = scm->fp->count-1; i >= 0; i--)\n\t\tunix_notinflight(scm->fp->fp[i]);\n}", "target": 1}
{"code": "static void adjust_branches(struct bpf_prog *prog, int pos, int delta)\n{\n\tstruct bpf_insn *insn = prog->insnsi;\n\tint insn_cnt = prog->len;\n\tint i;\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (BPF_CLASS(insn->code) != BPF_JMP ||\n\t\t    BPF_OP(insn->code) == BPF_CALL ||\n\t\t    BPF_OP(insn->code) == BPF_EXIT)\n\t\t\tcontinue;\n\t\tif (i < pos && i + insn->off + 1 > pos)\n\t\t\tinsn->off += delta;\n\t\telse if (i > pos && i + insn->off + 1 < pos)\n\t\t\tinsn->off -= delta;\n\t}\n}", "target": 1}
{"code": "static int __init xfrm6_tunnel_init(void)\n{\n\tint rv;\n\trv = xfrm_register_type(&xfrm6_tunnel_type, AF_INET6);\n\tif (rv < 0)\n\t\tgoto err;\n\trv = xfrm6_tunnel_register(&xfrm6_tunnel_handler, AF_INET6);\n\tif (rv < 0)\n\t\tgoto unreg;\n\trv = xfrm6_tunnel_register(&xfrm46_tunnel_handler, AF_INET);\n\tif (rv < 0)\n\t\tgoto dereg6;\n\trv = xfrm6_tunnel_spi_init();\n\tif (rv < 0)\n\t\tgoto dereg46;\n\trv = register_pernet_subsys(&xfrm6_tunnel_net_ops);\n\tif (rv < 0)\n\t\tgoto deregspi;\n\treturn 0;\nderegspi:\n\txfrm6_tunnel_spi_fini();\ndereg46:\n\txfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);\ndereg6:\n\txfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);\nunreg:\n\txfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);\nerr:\n\treturn rv;\n}", "target": 1}
{"code": "int IniSection::Write (const YCPPath&p, const YCPValue&v, bool rewrite)\n{\n    if (ip->isFlat ())\n\treturn setValueFlat (p, v);\n    if (p->length() >= 1 && p->component_str (0) == \"all\")\n    {\n\treturn setAll (p, v, 1);\n    }\n    if (p->length() < 2)\n    {\n\ty2error (\"I do not know what to write to %s.\", p->toString().c_str());\n\treturn -1;\n    }\n    string s = p->component_str (0);\n    if (s == \"v\" || s == \"value\")\n\treturn setValue (p, v, 0, 1);\n    if (s == \"vc\" || s == \"value_comment\" || s == \"valuecomment\")\n      return setValue (p, v, 1, 1);\n    if (s == \"vt\" || s == \"value_type\" || s == \"valuetype\")\n      return setValue (p, v, 2, 1);\n    if (s == \"s\" || s == \"section\" || s == \"sc\" || s == \"section_comment\" || s == \"sectioncomment\")\n      return setSectionProp (p, v, 0, 1);\n    if (s == \"st\" || s == \"section_type\" || s == \"sectiontype\")\n      return setSectionProp (p, v, rewrite? 1:2, 1);\n    if (s == \"section_private\")\n      return setSectionProp (p, v, 3, 1);\n    return -1;\n}", "target": 0}
{"code": "static inline int add_post_vars(zval *arr, post_var_data_t *vars, zend_bool eof TSRMLS_DC)\n{\n\tuint64_t max_vars = PG(max_input_vars);\n\tvars->ptr = vars->str.c;\n\tvars->end = vars->str.c + vars->str.len;\n\twhile (add_post_var(arr, vars, eof TSRMLS_CC)) {\n\t\tif (++vars->cnt > max_vars) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING,\n\t\t\t\t\t\"Input variables exceeded %\" PRIu64 \". \"\n\t\t\t\t\t\"To increase the limit change max_input_vars in php.ini.\",\n\t\t\t\t\tmax_vars);\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\tif (!eof) {\n\t\tmemmove(vars->str.c, vars->ptr, vars->str.len = vars->end - vars->ptr);\n\t}\n\treturn SUCCESS;\n}", "target": 1}
{"code": "static bool vtable_is_value_in_text_section(RVTableContext *context, ut64 curAddress, ut64 *value) {\n\tut64 curAddressValue;\n\tif (!context->read_addr (context->anal, curAddress, &curAddressValue)) {\n\t\treturn false;\n\t}\n\tbool ret = vtable_addr_in_text_section (context, curAddressValue);\n\tif (value) {\n\t\t*value = curAddressValue;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static int needs_empty_write(sector_t block, struct inode *inode)\n{\n\tint error;\n\tstruct buffer_head bh_map = { .b_state = 0, .b_blocknr = 0 };\n\tbh_map.b_size = 1 << inode->i_blkbits;\n\terror = gfs2_block_map(inode, block, &bh_map, 0);\n\tif (unlikely(error))\n\t\treturn error;\n\treturn !buffer_mapped(&bh_map);\n}", "target": 1}
{"code": "void AOClient::pktEditEvidence(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    if (!checkEvidenceAccess(area))\n        return;\n    bool is_int = false;\n    int idx = argv[0].toInt(&is_int);\n    AreaData::Evidence evi = {argv[1], argv[2], argv[3]};\n    if (is_int && idx <= area->evidence().size() && idx >= 0) {\n        area->replaceEvidence(idx, evi);\n    }\n    sendEvidenceList(area);\n}", "target": 1}
{"code": "nvkm_vmm_node_merge(struct nvkm_vmm *vmm, struct nvkm_vma *prev,\n\t\t    struct nvkm_vma *vma, struct nvkm_vma *next, u64 size)\n{\n\tif (next) {\n\t\tif (vma->size == size) {\n\t\t\tvma->size += next->size;\n\t\t\tnvkm_vmm_node_delete(vmm, next);\n\t\t\tif (prev) {\n\t\t\t\tprev->size += vma->size;\n\t\t\t\tnvkm_vmm_node_delete(vmm, vma);\n\t\t\t\treturn prev;\n\t\t\t}\n\t\t\treturn vma;\n\t\t}\n\t\tBUG_ON(prev);\n\t\tnvkm_vmm_node_remove(vmm, next);\n\t\tvma->size -= size;\n\t\tnext->addr -= size;\n\t\tnext->size += size;\n\t\tnvkm_vmm_node_insert(vmm, next);\n\t\treturn next;\n\t}\n\tif (prev) {\n\t\tif (vma->size != size) {\n\t\t\tnvkm_vmm_node_remove(vmm, vma);\n\t\t\tprev->size += size;\n\t\t\tvma->addr += size;\n\t\t\tvma->size -= size;\n\t\t\tnvkm_vmm_node_insert(vmm, vma);\n\t\t} else {\n\t\t\tprev->size += vma->size;\n\t\t\tnvkm_vmm_node_delete(vmm, vma);\n\t\t}\n\t\treturn prev;\n\t}\n\treturn vma;\n}", "target": 0}
{"code": "static inline pmd_t pmdp_get_and_clear(struct mm_struct *mm,\n\t\t\t\t       unsigned long address,\n\t\t\t\t       pmd_t *pmdp)\n{\n\tpmd_t pmd = *pmdp;\n\tpmd_clear(pmdp);\n\treturn pmd;\n}", "target": 0}
{"code": "void file_sb_list_add(struct file *file, struct super_block *sb)\n{\n\tif (likely(!(file->f_mode & FMODE_WRITE)))\n\t\treturn;\n\tif (!S_ISREG(file_inode(file)->i_mode))\n\t\treturn;\n\tlg_local_lock(&files_lglock);\n\t__file_sb_list_add(file, sb);\n\tlg_local_unlock(&files_lglock);\n}", "target": 1}
{"code": "void gitn_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *)s;\n\tif (ptr == NULL) return;\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tif (ptr->entries[i].name) gf_free(ptr->entries[i].name);\n\t}\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);", "target": 1}
{"code": "static int g2m_init_buffers(G2MContext *c)\n{\n    int aligned_height;\n    if (!c->framebuf || c->old_width < c->width || c->old_height < c->height) {\n        c->framebuf_stride = FFALIGN(c->width * 3, 16);\n        aligned_height     = FFALIGN(c->height,    16);\n        av_free(c->framebuf);\n        c->framebuf = av_mallocz(c->framebuf_stride * aligned_height);\n        if (!c->framebuf)\n            return AVERROR(ENOMEM);\n    }\n    if (!c->synth_tile || !c->jpeg_tile ||\n        c->old_tile_w < c->tile_width ||\n        c->old_tile_h < c->tile_height) {\n        c->tile_stride = FFALIGN(c->tile_width * 3, 16);\n        aligned_height = FFALIGN(c->tile_height,    16);\n        av_free(c->synth_tile);\n        av_free(c->jpeg_tile);\n        av_free(c->kempf_buf);\n        av_free(c->kempf_flags);\n        c->synth_tile  = av_mallocz(c->tile_stride      * aligned_height);\n        c->jpeg_tile   = av_mallocz(c->tile_stride      * aligned_height);\n        c->kempf_buf   = av_mallocz((c->tile_width + 1) * aligned_height\n                                    + FF_INPUT_BUFFER_PADDING_SIZE);\n        c->kempf_flags = av_mallocz( c->tile_width      * aligned_height);\n        if (!c->synth_tile || !c->jpeg_tile ||\n            !c->kempf_buf || !c->kempf_flags)\n            return AVERROR(ENOMEM);\n    }\n    return 0;\n}", "target": 1}
{"code": "__perf_event_ctx_lock_double(struct perf_event *group_leader,\n\t\t\t     struct perf_event_context *ctx)\n{\n\tstruct perf_event_context *gctx;\nagain:\n\trcu_read_lock();\n\tgctx = READ_ONCE(group_leader->ctx);\n\tif (!atomic_inc_not_zero(&gctx->refcount)) {\n\t\trcu_read_unlock();\n\t\tgoto again;\n\t}\n\trcu_read_unlock();\n\tmutex_lock_double(&gctx->mutex, &ctx->mutex);\n\tif (group_leader->ctx != gctx) {\n\t\tmutex_unlock(&ctx->mutex);\n\t\tmutex_unlock(&gctx->mutex);\n\t\tput_ctx(gctx);\n\t\tgoto again;\n\t}\n\treturn gctx;\n}", "target": 0}
{"code": "int inet_sk_rebuild_header(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct rtable *rt = (struct rtable *)__sk_dst_check(sk, 0);\n\t__be32 daddr;\n\tint err;\n\tif (rt)\n\t\treturn 0;\n\tdaddr = inet->inet_daddr;\n\tif (inet->opt && inet->opt->srr)\n\t\tdaddr = inet->opt->faddr;\n\trt = ip_route_output_ports(sock_net(sk), sk, daddr, inet->inet_saddr,\n\t\t\t\t   inet->inet_dport, inet->inet_sport,\n\t\t\t\t   sk->sk_protocol, RT_CONN_FLAGS(sk),\n\t\t\t\t   sk->sk_bound_dev_if);\n\tif (!IS_ERR(rt)) {\n\t\terr = 0;\n\t\tsk_setup_caps(sk, &rt->dst);\n\t} else {\n\t\terr = PTR_ERR(rt);\n\t\tsk->sk_route_caps = 0;\n\t\tif (!sysctl_ip_dynaddr ||\n\t\t    sk->sk_state != TCP_SYN_SENT ||\n\t\t    (sk->sk_userlocks & SOCK_BINDADDR_LOCK) ||\n\t\t    (err = inet_sk_reselect_saddr(sk)) != 0)\n\t\t\tsk->sk_err_soft = -err;\n\t}\n\treturn err;\n}", "target": 1}
{"code": "hash_new_from_regs(mrb_state *mrb, mrb_int argc, mrb_int idx)\n{\n  mrb_value hash = mrb_hash_new_capa(mrb, argc);\n  while (argc--) {\n    mrb_hash_set(mrb, hash, regs[idx+0], regs[idx+1]);\n    idx += 2;\n  }\n  return hash;\n}", "target": 0}
{"code": "static void _pam_log_int(const pam_handle_t *pamh,\n\t\t\t int err,\n\t\t\t const char *format,\n\t\t\t va_list args)\n{\n\tpam_vsyslog(pamh, err, format, args);\n}", "target": 0}
{"code": "static inline const unsigned char *fsnotify_oldname_init(const unsigned char *name)\n{\n\treturn kstrdup(name, GFP_KERNEL);\n}", "target": 1}
{"code": "countAllSwitchActions (union SWF_ACTION *actions, union SWF_ACTION *pre)\n{\n\tint i,j=1;\n\tif (actions->SWF_ACTIONRECORD.ActionCode==SWFACTION_IF && pre->SWF_ACTIONRECORD.ActionCode==SWFACTION_STRICTEQUALS )\n\t{\n\t\tfor(i=0; i < ((struct SWF_ACTIONIF*)actions)->numActions; i++)\n\t\t{\n\t\t\tj+=countAllSwitchActions(&((struct SWF_ACTIONIF*)actions)->Actions[i],pre);\n\t\t\tpre=&((struct SWF_ACTIONIF*)actions)->Actions[i];\n\t\t}\n\t}                  \n\treturn j;\n}", "target": 0}
{"code": "dtls1_process_buffered_records(SSL *s)\n    {\n    pitem *item;\n    item = pqueue_peek(s->d1->unprocessed_rcds.q);\n    if (item)\n        {\n        if (s->d1->unprocessed_rcds.epoch != s->d1->r_epoch)\n            return(1);  \n        while (pqueue_peek(s->d1->unprocessed_rcds.q))\n            {\n            dtls1_get_unprocessed_record(s);\n            if ( ! dtls1_process_record(s))\n                return(0);\n            dtls1_buffer_record(s, &(s->d1->processed_rcds), \n                s->s3->rrec.seq_num);\n            }\n        }\n    s->d1->processed_rcds.epoch = s->d1->r_epoch;\n    s->d1->unprocessed_rcds.epoch = s->d1->r_epoch + 1;\n    return(1);\n    }", "target": 1}
{"code": "Literal *hermes::evalUnaryOperator(\n    UnaryOperatorInst::OpKind kind,\n    IRBuilder &builder,\n    Literal *operand) {\n  switch (kind) {\n    case UnaryOperatorInst::OpKind::MinusKind:\n      switch (operand->getKind()) {\n        case ValueKind::LiteralNumberKind:\n          if (auto *literalNum = llvh::dyn_cast<LiteralNumber>(operand)) {\n            auto V = -literalNum->getValue();\n            return builder.getLiteralNumber(V);\n          }\n          break;\n        case ValueKind::LiteralUndefinedKind:\n          return builder.getLiteralNaN();\n        case ValueKind::LiteralBoolKind:\n          if (evalIsTrue(builder, operand)) {\n            return builder.getLiteralNumber(-1);\n          } else { \n            return builder.getLiteralNegativeZero();\n          }\n        case ValueKind::LiteralNullKind:\n          return builder.getLiteralNegativeZero();\n        default:\n          break;\n      }\n      break;\n    case UnaryOperatorInst::OpKind::TypeofKind:\n      switch (operand->getKind()) {\n        case ValueKind::GlobalObjectKind:\n        case ValueKind::LiteralNullKind:\n          return builder.getLiteralString(\"object\");\n        case ValueKind::LiteralUndefinedKind:\n          return builder.getLiteralString(\"undefined\");\n        case ValueKind::LiteralBoolKind:\n          return builder.getLiteralString(\"boolean\");\n        case ValueKind::LiteralNumberKind:\n          return builder.getLiteralString(\"number\");\n        case ValueKind::LiteralStringKind:\n          return builder.getLiteralString(\"string\");\n        default:\n          llvm_unreachable(\"Invalid literal kind.\");\n      }\n      break;\n    case UnaryOperatorInst::OpKind::BangKind:\n      if (evalIsTrue(builder, operand)) {\n        return builder.getLiteralBool(false);\n      }\n      if (evalIsFalse(builder, operand)) {\n        return builder.getLiteralBool(true);\n      }\n      break;\n    case UnaryOperatorInst::OpKind::VoidKind:\n      return builder.getLiteralUndefined();\n    default:\n      break;\n  }\n  return nullptr;\n}", "target": 1}
{"code": "static uint64_t HTPStateGetTxCnt(void *alstate)\n{\n    HtpState *http_state = (HtpState *)alstate;\n    if (http_state != NULL && http_state->conn != NULL) {\n        const int64_t size = (int64_t)htp_list_size(http_state->conn->transactions);\n        if (size < 0)\n            return 0ULL;\n        SCLogDebug(\"size %\"PRIu64, size);\n        return (uint64_t)size;\n    } else {\n        return 0ULL;\n    }\n}", "target": 1}
{"code": "static void scalar32_min_max_or(struct bpf_reg_state *dst_reg,\n\t\t\t\tstruct bpf_reg_state *src_reg)\n{\n\tbool src_known = tnum_subreg_is_const(src_reg->var_off);\n\tbool dst_known = tnum_subreg_is_const(dst_reg->var_off);\n\tstruct tnum var32_off = tnum_subreg(dst_reg->var_off);\n\ts32 smin_val = src_reg->smin_value;\n\tu32 umin_val = src_reg->umin_value;\n\tif (src_known && dst_known)\n\t\treturn;\n\tdst_reg->u32_min_value = max(dst_reg->u32_min_value, umin_val);\n\tdst_reg->u32_max_value = var32_off.value | var32_off.mask;\n\tif (dst_reg->s32_min_value < 0 || smin_val < 0) {\n\t\tdst_reg->s32_min_value = S32_MIN;\n\t\tdst_reg->s32_max_value = S32_MAX;\n\t} else {\n\t\tdst_reg->s32_min_value = dst_reg->umin_value;\n\t\tdst_reg->s32_max_value = dst_reg->umax_value;\n\t}\n}", "target": 1}
{"code": "  Status ValidateInputTensor(const Tensor& tensor,\n                             const std::string& tensor_name,\n                             const Tensor& rhs) {\n    const int ndims = rhs.dims();\n    if (tensor.dims() != ndims) {\n      return errors::InvalidArgument(tensor_name,\n                                     \" must have same rank as rhs, but got \",\n                                     tensor.dims(), \" and \", ndims);\n    }\n    for (int i = 0; i < ndims - 2; i++) {\n      if (tensor.dim_size(i) != rhs.dim_size(i)) {\n        return errors::InvalidArgument(\n            tensor_name,\n            \" must have same outer dimensions as rhs, but for index \", i,\n            \", got \", tensor.dim_size(i), \" and \", rhs.dim_size(i));\n      }\n    }\n    if (tensor.dim_size(ndims - 2) != 1) {\n      return errors::InvalidArgument(\n          tensor_name, \"'s second-to-last dimension must be 1, but got \",\n          tensor.dim_size(ndims - 2));\n    }\n    if (tensor.dim_size(ndims - 1) != rhs.dim_size(ndims - 2)) {\n      return errors::InvalidArgument(tensor_name,\n                                     \"'s last dimension size must be rhs's \"\n                                     \"second-to-last dimension size, but got \",\n                                     tensor.dim_size(ndims - 1), \" and \",\n                                     rhs.dim_size(ndims - 2));\n    }\n    return Status::OK();\n  }", "target": 0}
{"code": "CompileKeymap(XkbFile *file, struct xkb_keymap *keymap, enum merge_mode merge)\n{\n    bool ok;\n    XkbFile *files[LAST_KEYMAP_FILE_TYPE + 1] = { NULL };\n    enum xkb_file_type type;\n    struct xkb_context *ctx = keymap->ctx;\n    for (file = (XkbFile *) file->defs; file;\n         file = (XkbFile *) file->common.next) {\n        if (file->file_type < FIRST_KEYMAP_FILE_TYPE ||\n            file->file_type > LAST_KEYMAP_FILE_TYPE) {\n            log_err(ctx, \"Cannot define %s in a keymap file\\n\",\n                    xkb_file_type_to_string(file->file_type));\n            continue;\n        }\n        if (files[file->file_type]) {\n            log_err(ctx,\n                    \"More than one %s section in keymap file; \"\n                    \"All sections after the first ignored\\n\",\n                    xkb_file_type_to_string(file->file_type));\n            continue;\n        }\n        files[file->file_type] = file;\n    }\n    ok = true;\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        if (files[type] == NULL) {\n            log_err(ctx, \"Required section %s missing from keymap\\n\",\n                    xkb_file_type_to_string(type));\n            ok = false;\n        }\n    }\n    if (!ok)\n        return false;\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        log_dbg(ctx, \"Compiling %s \\\"%s\\\"\\n\",\n                xkb_file_type_to_string(type), files[type]->name);\n        ok = compile_file_fns[type](files[type], keymap, merge);\n        if (!ok) {\n            log_err(ctx, \"Failed to compile %s\\n\",\n                    xkb_file_type_to_string(type));\n            return false;\n        }\n    }\n    return UpdateDerivedKeymapFields(keymap);\n}", "target": 1}
{"code": "luks_unlock_start_waiting_for_cleartext_device (UnlockEncryptionData *data)\n{\n  Device *cleartext_device;\n  cleartext_device = find_cleartext_device (data->device);\n  if (cleartext_device != NULL)\n    {\n      update_info (data->device);\n      drain_pending_changes (data->device, FALSE);\n      if (data->hook_func != NULL)\n        {\n          data->hook_func (data->context, cleartext_device, data->hook_user_data);\n        }\n      else\n        {\n          dbus_g_method_return (data->context, cleartext_device->priv->object_path);\n        }\n      unlock_encryption_data_unref (data);\n    }\n  else\n    {\n      data->device_added_signal_handler_id = g_signal_connect_after (data->device->priv->daemon,\n                                                                     \"device-added\",\n                                                                     (GCallback) luks_unlock_device_added_cb,\n                                                                     data);\n      data->device_changed_signal_handler_id = g_signal_connect_after (data->device->priv->daemon,\n                                                                       \"device-changed\",\n                                                                       (GCallback) luks_unlock_device_added_cb,\n                                                                       data);\n      data->device_added_timeout_id = g_timeout_add (15 * 1000, luks_unlock_device_not_seen_cb, data);\n    }\n}", "target": 0}
{"code": "bool IsReshapeOpSupported(const TfLiteRegistration* registration,\n                          const TfLiteNode* node, TfLiteContext* context,\n                          int coreml_version) {\n  if (coreml_version >= 3) {\n    return false;\n  }\n  if (node->inputs->size == 1) {\n    const auto* params =\n        reinterpret_cast<TfLiteReshapeParams*>(node->builtin_data);\n    return params->num_dimensions == 3 || params->num_dimensions == 4;\n  }\n  const int kShapeTensor = 1;\n  const auto* shape = GetInput(context, node, kShapeTensor);\n  if (shape->allocation_type != kTfLiteMmapRo) {\n    TF_LITE_KERNEL_LOG(context, \"Reshape has non-const shape.\");\n    return false;\n  }\n  const bool is_shape_tensor =\n      shape->dims->size == 1 && shape->type == kTfLiteInt32;\n  return is_shape_tensor &&\n         (shape->dims->data[0] == 3 || shape->dims->data[0] == 4);\n}", "target": 1}
{"code": "static int skip_boxes(JXLParseContext *ctx, const uint8_t *buf, int buf_size)\n{\n    GetByteContext gb;\n    if (ctx->skip > buf_size)\n        return AVERROR_BUFFER_TOO_SMALL;\n    buf += ctx->skip;\n    buf_size -= ctx->skip;\n    bytestream2_init(&gb, buf, buf_size);\n    while (1) {\n        uint64_t size;\n        int head_size = 4;\n        if (bytestream2_peek_le16(&gb) == FF_JPEGXL_CODESTREAM_SIGNATURE_LE)\n            break;\n        if (bytestream2_peek_le64(&gb) == FF_JPEGXL_CONTAINER_SIGNATURE_LE)\n            break;\n        if (bytestream2_get_bytes_left(&gb) < 8)\n            return AVERROR_BUFFER_TOO_SMALL;\n        size = bytestream2_get_be32(&gb);\n        if (size == 1) {\n            if (bytestream2_get_bytes_left(&gb) < 12)\n                return AVERROR_BUFFER_TOO_SMALL;\n            size = bytestream2_get_be64(&gb);\n            head_size = 12;\n        }\n        if (!size)\n            return AVERROR_INVALIDDATA;\n        if (size <= head_size + 4)\n            return AVERROR_INVALIDDATA;\n        ctx->skip += size;\n        bytestream2_skip(&gb, size - head_size);\n        if (bytestream2_get_bytes_left(&gb) <= 0)\n            return AVERROR_BUFFER_TOO_SMALL;\n    }\n    return 0;\n}", "target": 1}
{"code": "bool QHstsHeaderParser::parse(const QList<QPair<QByteArray, QByteArray>> &headers)\n{\n    for (const auto &h : headers) {\n        if (h.first == \"Strict-Transport-Security\") {\n            header = h.second;\n            if (parseSTSHeader() && maxAgeFound) {\n                expiry = QDateTime::currentDateTimeUtc().addSecs(maxAge);\n                return true;\n            }\n        }\n    }\n    subDomainsFound = false;\n    return false;\n}", "target": 1}
{"code": "      BigInt square_mod_order(const BigInt& x) const\n         {\n         return m_mod_order.square(x);\n         }", "target": 0}
{"code": "static void set_cpu_rq_start_time(void)\n{\n\tint cpu = smp_processor_id();\n\tstruct rq *rq = cpu_rq(cpu);\n\trq->age_stamp = sched_clock_cpu(cpu);\n}", "target": 0}
{"code": "MODULE_ENTRY (fill_info) (GdkPixbufFormat *info)\n{\n\tstatic const GdkPixbufModulePattern signature[] = {\n\t\t{ \"  \\x1   \", \"zz znz\", 100 }, \n\t\t{ \"  \\x2   \", \"zz znz\", 100 },\n\t\t{ NULL, NULL, 0 }\n\t};\n\tstatic const gchar *mime_types[] = {\n\t\t\"image/x-icon\",\n\t\t\"image/x-ico\",\n\t\t\"image/x-win-bitmap\",\n                \"image/vnd.microsoft.icon\",\n                \"application/ico\",\n                \"image/ico\",\n                \"image/icon\",\n                \"text/ico\",\n\t\tNULL\n\t};\n\tstatic const gchar *extensions[] = {\n\t\t\"ico\",\n\t\t\"cur\",\n\t\tNULL\n\t};\n\tinfo->name = \"ico\";\n\tinfo->signature = (GdkPixbufModulePattern *) signature;\n\tinfo->description = NC_(\"image format\", \"Windows icon\");\n\tinfo->mime_types = (gchar **) mime_types;\n\tinfo->extensions = (gchar **) extensions;\n\tinfo->flags = GDK_PIXBUF_FORMAT_WRITABLE | GDK_PIXBUF_FORMAT_THREADSAFE;\n\tinfo->license = \"LGPL\";\n}", "target": 0}
{"code": "noscale(j_decompress_ptr cinfo,\n        JDIFFROW diff_buf, _JSAMPROW output_buf, JDIMENSION width)\n{\n  do {\n#if BITS_IN_JSAMPLE == 12\n    *output_buf++ = (_JSAMPLE)((*diff_buf++) & 0xFFF);\n#else\n    *output_buf++ = (_JSAMPLE)(*diff_buf++);\n#endif\n  } while (--width);\n}", "target": 0}
{"code": "resp_get_length(netdissect_options *ndo, register const u_char *bp, int len, const u_char **endp)\n{\n    int result;\n    u_char c;\n    int saw_digit;\n    int neg;\n    int too_large;\n    if (len == 0)\n        goto trunc;\n    ND_TCHECK(*bp);\n    too_large = 0;\n    neg = 0;\n    if (*bp == '-') {\n        neg = 1;\n        bp++;\n        len--;\n    }\n    result = 0;\n    saw_digit = 0;\n    for (;;) {\n        if (len == 0)\n            goto trunc;\n        ND_TCHECK(*bp);\n        c = *bp;\n        if (!(c >= '0' && c <= '9')) {\n            if (!saw_digit)\n                goto invalid;\n            break;\n        }\n        c -= '0';\n        if (result > (INT_MAX / 10)) {\n            too_large = 1;\n        } else {\n            result *= 10;\n            if (result == INT_MAX && c > (INT_MAX % 10)) {\n                too_large = 1;\n            } else\n                result += c;\n        }\n        bp++;\n        len--;\n        saw_digit = 1;\n    }\n    if (!saw_digit)\n        goto invalid;\n    if (len == 0)\n        goto trunc;\n    ND_TCHECK(*bp);\n    if (*bp != '\\r')\n        goto invalid;\n    bp++;\n    len--;\n    if (len == 0)\n        goto trunc;\n    ND_TCHECK(*bp);\n    if (*bp != '\\n')\n        goto invalid;\n    bp++;\n    len--;\n    *endp = bp;\n    if (neg) {\n        if (too_large || result != 1)\n            return (-4);\n        result = -1;\n    }\n    return (too_large ? -3 : result);\ntrunc:\n    return (-2);\ninvalid:\n    return (-5);\n}", "target": 1}
{"code": "void TakeScreenshot(const char *fileName)\n{\n#if defined(SUPPORT_MODULE_RTEXTURES)\n    if (strchr(fileName, '\\'') != NULL) { TRACELOG(LOG_WARNING, \"SYSTEM: Provided fileName could be potentially malicious, avoid [\\'] character\");  return; }\n    Vector2 scale = GetWindowScaleDPI();\n    unsigned char *imgData = rlReadScreenPixels((int)((float)CORE.Window.render.width*scale.x), (int)((float)CORE.Window.render.height*scale.y));\n    Image image = { imgData, (int)((float)CORE.Window.render.width*scale.x), (int)((float)CORE.Window.render.height*scale.y), 1, PIXELFORMAT_UNCOMPRESSED_R8G8B8A8 };\n    char path[2048] = { 0 };\n    strcpy(path, TextFormat(\"%s/%s\", CORE.Storage.basePath, fileName));\n    ExportImage(image, path);           \n    RL_FREE(imgData);\n#if defined(PLATFORM_WEB)\n    emscripten_run_script(TextFormat(\"saveFileFromMEMFSToDisk('%s','%s')\", GetFileName(path), GetFileName(path)));\n#endif\n    TRACELOG(LOG_INFO, \"SYSTEM: [%s] Screenshot taken successfully\", path);\n#else\n    TRACELOG(LOG_WARNING,\"IMAGE: ExportImage() requires module: rtextures\");\n#endif\n}", "target": 0}
{"code": "static int _gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)\n{\n\tgdImagePtr pim = 0, tim = im;\n\tint interlace, BitsPerPixel;\n\tinterlace = im->interlace;\n\tif(im->trueColor) {\n\t\tpim = gdImageCreatePaletteFromTrueColor(im, 1, 256);\n\t\tif(!pim) {\n\t\t\treturn 1;\n\t\t}\n\t\ttim = pim;\n\t}\n\tBitsPerPixel = colorstobpp(tim->colorsTotal);\n\tGIFEncode(\n\t    out, tim->sx, tim->sy, interlace, 0, tim->transparent, BitsPerPixel,\n\t    tim->red, tim->green, tim->blue, tim);\n\tif(pim) {\n\t\tgdImageDestroy(\tpim);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "archive_reopen_if_needed (ComicsDocument  *comics_document,\n\t\t\t  const char      *page_wanted,\n\t\t\t  GError         **error)\n{\n\tconst char *current_page;\n\tguint current_page_idx, page_wanted_idx;\n\tif (ev_archive_at_entry (comics_document->archive)) {\n\t\tcurrent_page = ev_archive_get_entry_pathname (comics_document->archive);\n\t\tif (current_page) {\n\t\t\tcurrent_page_idx = GPOINTER_TO_UINT (g_hash_table_lookup (comics_document->page_positions, current_page));\n\t\t\tpage_wanted_idx = GPOINTER_TO_UINT (g_hash_table_lookup (comics_document->page_positions, page_wanted));\n\t\t\tif (current_page_idx != 0 &&\n\t\t\t    page_wanted_idx != 0 &&\n\t\t\t    page_wanted_idx > current_page_idx)\n\t\t\t\treturn TRUE;\n\t\t}\n\t\tev_archive_reset (comics_document->archive);\n\t}\n\treturn ev_archive_open_filename (comics_document->archive, comics_document->archive_path, error);\n}", "target": 0}
{"code": "static int ldb_msg_append_value_impl(struct ldb_message *msg,\n\t\t\t\t     const char *attr_name,\n\t\t\t\t     const struct ldb_val *val,\n\t\t\t\t     int flags,\n\t\t\t\t     struct ldb_message_element **return_el)\n{\n\tstruct ldb_message_element *el = NULL;\n\tint ret;\n\tret = ldb_msg_add_empty(msg, attr_name, flags, &el);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tret = ldb_msg_element_add_value(msg->elements, el, val);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tif (return_el != NULL) {\n\t\t*return_el = el;\n\t}\n\treturn LDB_SUCCESS;\n}", "target": 0}
{"code": "int tpm_open(struct inode *inode, struct file *file)\n{\n\tint minor = iminor(inode);\n\tstruct tpm_chip *chip = NULL, *pos;\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pos, &tpm_chip_list, list) {\n\t\tif (pos->vendor.miscdev.minor == minor) {\n\t\t\tchip = pos;\n\t\t\tget_device(chip->dev);\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tif (!chip)\n\t\treturn -ENODEV;\n\tif (test_and_set_bit(0, &chip->is_open)) {\n\t\tdev_dbg(chip->dev, \"Another process owns this TPM\\n\");\n\t\tput_device(chip->dev);\n\t\treturn -EBUSY;\n\t}\n\tchip->data_buffer = kmalloc(TPM_BUFSIZE * sizeof(u8), GFP_KERNEL);\n\tif (chip->data_buffer == NULL) {\n\t\tclear_bit(0, &chip->is_open);\n\t\tput_device(chip->dev);\n\t\treturn -ENOMEM;\n\t}\n\tatomic_set(&chip->data_pending, 0);\n\tfile->private_data = chip;\n\treturn 0;\n}", "target": 1}
{"code": "static int efi_capsule_flush(struct file *file, fl_owner_t id)\n{\n\tint ret = 0;\n\tstruct capsule_info *cap_info = file->private_data;\n\tif (cap_info->index > 0) {\n\t\tpr_err(\"capsule upload not complete\\n\");\n\t\tefi_free_all_buff_pages(cap_info);\n\t\tret = -ECANCELED;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static gboolean irssi_ssl_verify_hostname(X509 *cert, const char *hostname)\n{\n\tint gen_index, gen_count;\n\tgboolean matched = FALSE, has_dns_name = FALSE;\n\tconst char *cert_dns_name;\n\tchar *cert_subject_cn;\n\tconst GENERAL_NAME *gn;\n\tSTACK_OF(GENERAL_NAME) * gens;\n\tgens = X509_get_ext_d2i(cert, NID_subject_alt_name, 0, 0);\n\tif (gens) {\n\t\tgen_count = sk_GENERAL_NAME_num(gens);\n\t\tfor (gen_index = 0; gen_index < gen_count && !matched; ++gen_index) {\n\t\t\tgn = sk_GENERAL_NAME_value(gens, gen_index);\n\t\t\tif (gn->type != GEN_DNS)\n\t\t\t\tcontinue;\n\t\t\thas_dns_name = TRUE;\n\t\t\tcert_dns_name = tls_dns_name(gn);\n\t\t\tif (cert_dns_name && *cert_dns_name) {\n\t\t\t\tmatched = match_hostname(cert_dns_name, hostname);\n\t\t\t}\n    \t}\n\t    sk_GENERAL_NAME_pop_free(gens, GENERAL_NAME_free);\n\t}\n\tif (has_dns_name) {\n\t\tif (! matched) {\n\t\t\tg_warning(\"None of the Subject Alt Names in the certificate match hostname '%s'\", hostname);\n\t\t}\n\t\treturn matched;\n\t} else { \n\t\tcert_subject_cn = tls_text_name(X509_get_subject_name(cert), NID_commonName);\n\t    if (cert_subject_cn && *cert_subject_cn) {\n\t    \tmatched = match_hostname(cert_subject_cn, hostname);\n\t    \tif (! matched) {\n\t\t\t\tg_warning(\"SSL certificate common name '%s' doesn't match host name '%s'\", cert_subject_cn, hostname);\n\t    \t}\n\t    } else {\n\t    \tg_warning(\"No subjectAltNames and no valid common name in certificate\");\n\t    }\n\t    free(cert_subject_cn);\n\t}\n\treturn matched;\n}", "target": 0}
{"code": "next_line(struct archive_read *a,\n    const char **b, ssize_t *avail, ssize_t *ravail, ssize_t *nl)\n{\n\tssize_t len;\n\tint quit;\n\tquit = 0;\n\tif (*avail == 0) {\n\t\t*nl = 0;\n\t\tlen = 0;\n\t} else\n\t\tlen = get_line_size(*b, *avail, nl);\n\twhile (*nl == 0 && len == *avail && !quit) {\n\t\tssize_t diff = *ravail - *avail;\n\t\tsize_t nbytes_req = (*ravail+1023) & ~1023U;\n\t\tssize_t tested;\n\t\tif (nbytes_req < (size_t)*ravail + 160)\n\t\t\tnbytes_req <<= 1;\n\t\t*b = __archive_read_ahead(a, nbytes_req, avail);\n\t\tif (*b == NULL) {\n\t\t\tif (*ravail >= *avail)\n\t\t\t\treturn (0);\n\t\t\t*b = __archive_read_ahead(a, *avail, avail);\n\t\t\tquit = 1;\n\t\t}\n\t\t*ravail = *avail;\n\t\t*b += diff;\n\t\t*avail -= diff;\n\t\ttested = len;\n\t\tlen = get_line_size(*b, *avail, nl);\n\t\tif (len >= 0)\n\t\t\tlen += tested;\n\t}\n\treturn (len);\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    OpInputList indices_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"indices\", &indices_list_in));\n    OpInputList values_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"values\", &values_list_in));\n    OpInputList shapes_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"shapes\", &shapes_list_in));\n    OpInputList dense_list_in;\n    OP_REQUIRES_OK(context,\n                   context->input_list(\"dense_inputs\", &dense_list_in));\n    OP_REQUIRES_OK(context, ValidateInput(indices_list_in, values_list_in,\n                                          shapes_list_in, dense_list_in));\n    std::vector<std::unique_ptr<ColumnInterface<InternalType>>> columns =\n        GenerateColumnsFromInput<InternalType>(indices_list_in, values_list_in,\n                                               shapes_list_in, dense_list_in);\n    const tstring k_feature_separator = \"_X_\";\n    typename CrossTraits<HASHED_OUTPUT, InternalType>::Crosser crosser(\n        columns, num_buckets_, hash_key_, k_feature_separator);\n    Tensor* indices_out;\n    Tensor* values_out;\n    Tensor* shape_out;\n    const int64 batch_size = CalculateBatchSize(shapes_list_in, dense_list_in);\n    std::vector<int64> output_start_indices(batch_size);\n    OP_REQUIRES_OK(\n        context,\n        CreateOutputTensors(columns, batch_size, context, &indices_out,\n                            &values_out, &shape_out, &output_start_indices));\n    typename CrossTraits<HASHED_OUTPUT, InternalType>::Updater updater(\n        output_start_indices, indices_out, values_out);\n    auto do_work = [&columns, crosser, updater](int64 begin, int64 end) {\n      for (int b = begin; b < end; b++) {\n        ProductIterator<InternalType> product_iterator(columns, b);\n        int64 cross_count = 0;\n        while (product_iterator.HasNext()) {\n          const auto permutation = product_iterator.Next();\n          updater.Update(b, cross_count,\n                         crosser.Generate(b, permutation, false));\n          cross_count++;\n        }\n      }\n    };\n    auto* worker_threads = context->device()->tensorflow_cpu_worker_threads();\n    const int kCostPerUnit = 5000 * indices_list_in.size();\n    Shard(worker_threads->num_threads, worker_threads->workers, batch_size,\n          kCostPerUnit, do_work);\n  }", "target": 1}
{"code": "static void sas_init_port(struct asd_sas_port *port,\n\t\t\t  struct sas_ha_struct *sas_ha, int i)\n{\n\tmemset(port, 0, sizeof(*port));\n\tport->id = i;\n\tINIT_LIST_HEAD(&port->dev_list);\n\tINIT_LIST_HEAD(&port->disco_list);\n\tINIT_LIST_HEAD(&port->destroy_list);\n\tINIT_LIST_HEAD(&port->sas_port_del_list);\n\tspin_lock_init(&port->phy_list_lock);\n\tINIT_LIST_HEAD(&port->phy_list);\n\tport->ha = sas_ha;\n\tspin_lock_init(&port->dev_list_lock);\n}", "target": 0}
{"code": "static int mmac_rotate(const MMacro *mac, unsigned int n)\n{\n    if (--n < mac->nparam)\n        n = (n + mac->rotate) % mac->nparam;\n    return n+1;\n}", "target": 0}
{"code": "static void bfq_idle_slice_timer_body(struct bfq_queue *bfqq)\n{\n\tstruct bfq_data *bfqd = bfqq->bfqd;\n\tenum bfqq_expiration reason;\n\tunsigned long flags;\n\tspin_lock_irqsave(&bfqd->lock, flags);\n\tbfq_clear_bfqq_wait_request(bfqq);\n\tif (bfqq != bfqd->in_service_queue) {\n\t\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\t\treturn;\n\t}\n\tif (bfq_bfqq_budget_timeout(bfqq))\n\t\treason = BFQQE_BUDGET_TIMEOUT;\n\telse if (bfqq->queued[0] == 0 && bfqq->queued[1] == 0)\n\t\treason = BFQQE_TOO_IDLE;\n\telse\n\t\tgoto schedule_dispatch;\n\tbfq_bfqq_expire(bfqd, bfqq, true, reason);\nschedule_dispatch:\n\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\tbfq_schedule_dispatch(bfqd);", "target": 1}
{"code": "static void vapic_exit(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tint idx;\n\tif (!apic || !apic->vapic_addr)\n\t\treturn;\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tkvm_release_page_dirty(apic->vapic_page);\n\tmark_page_dirty(vcpu->kvm, apic->vapic_addr >> PAGE_SHIFT);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n}", "target": 1}
{"code": "static int spl_object_storage_compare_info(spl_SplObjectStorageElement *e1, spl_SplObjectStorageElement *e2 TSRMLS_DC) \n{\n\tzval result;\n\tif (compare_function(&result, e1->inf, e2->inf TSRMLS_CC) == FAILURE) {\n\t\treturn 1;\n\t}\n\treturn Z_LVAL(result);\n}", "target": 0}
{"code": "  void readDataAvailable(size_t len) noexcept override {\n    VLOG(3) << \"Read of size: \" << len;\n    s_->setReadCB(nullptr);\n    s_->getEventBase()->runInLoop([this]() { s_->setReadCB(this); });\n  }", "target": 0}
{"code": "void br_mdb_notify(struct net_device *dev, struct net_bridge_port *port,\n\t\t   struct br_ip *group, int type)\n{\n\tstruct br_mdb_entry entry;\n\tmemset(&entry, 0, sizeof(entry));\n\tentry.ifindex = port->dev->ifindex;\n\tentry.addr.proto = group->proto;\n\tentry.addr.u.ip4 = group->u.ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\tentry.addr.u.ip6 = group->u.ip6;\n#endif\n\t__br_mdb_notify(dev, &entry, type);\n}", "target": 0}
{"code": "dump_dest_constraints(const char *context,\n    const struct dest_constraint *dcs, size_t ndcs)\n{\n#ifdef DEBUG_CONSTRAINTS\n\tsize_t i;\n\tdebug_f(\"%s: %zu constraints\", context, ndcs);\n\tfor (i = 0; i < ndcs; i++) {\n\t\tdebug_f(\"constraint %zu / %zu: from: \", i, ndcs);\n\t\tdump_dest_constraint_hop(&dcs[i].from);\n\t\tdebug_f(\"constraint %zu / %zu: to: \", i, ndcs);\n\t\tdump_dest_constraint_hop(&dcs[i].to);\n\t}\n\tdebug_f(\"done for %s\", context);\n#endif \n}", "target": 0}
{"code": "static int ndp_sock_open(struct ndp *ndp)\n{\n\tint sock;\n\tint ret;\n\tint err;\n\tint val;\n\tsock = socket(PF_INET6, SOCK_RAW, IPPROTO_ICMPV6);\n\tif (sock == -1) {\n\t\terr(ndp, \"Failed to create ICMP6 socket.\");\n\t\treturn -errno;\n\t}\n\tval = 1;\n\tret = setsockopt(sock, IPPROTO_IPV6, IPV6_RECVPKTINFO,\n\t\t\t &val, sizeof(val));\n\tif (ret == -1) {\n\t\terr(ndp, \"Failed to setsockopt IPV6_RECVPKTINFO.\");\n\t\terr = -errno;\n\t\tgoto close_sock;\n\t}\n\tval = 255;\n\tret = setsockopt(sock, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,\n\t\t\t &val, sizeof(val));\n\tif (ret == -1) {\n\t\terr(ndp, \"Failed to setsockopt IPV6_MULTICAST_HOPS.\");\n\t\terr = -errno;\n\t\tgoto close_sock;\n\t}\n\tval = 1;\n\tret = setsockopt(sock, IPPROTO_IPV6, IPV6_RECVHOPLIMIT,\n\t\t\t &val, sizeof(val));\n\tif (ret == -1) {\n\t\terr(ndp, \"Failed to setsockopt IPV6_RECVHOPLIMIT,.\");\n\t\terr = -errno;\n\t\tgoto close_sock;\n\t}\n\tndp->sock = sock;\n\treturn 0;\nclose_sock:\n\tclose(sock);\n\treturn err;\n}", "target": 0}
{"code": "rdpCredssp* credssp_new(freerdp* instance, rdpTransport* transport, rdpSettings* settings)\n{\n\trdpCredssp* credssp;\n\tcredssp = (rdpCredssp*) malloc(sizeof(rdpCredssp));\n\tZeroMemory(credssp, sizeof(rdpCredssp));\n\tif (credssp != NULL)\n\t{\n\t\tHKEY hKey;\n\t\tLONG status;\n\t\tDWORD dwType;\n\t\tDWORD dwSize;\n\t\tcredssp->instance = instance;\n\t\tcredssp->settings = settings;\n\t\tcredssp->server = settings->ServerMode;\n\t\tcredssp->transport = transport;\n\t\tcredssp->send_seq_num = 0;\n\t\tcredssp->recv_seq_num = 0;\n\t\tZeroMemory(&credssp->negoToken, sizeof(SecBuffer));\n\t\tZeroMemory(&credssp->pubKeyAuth, sizeof(SecBuffer));\n\t\tZeroMemory(&credssp->authInfo, sizeof(SecBuffer));\n\t\tSecInvalidateHandle(&credssp->context);\n\t\tif (credssp->server)\n\t\t{\n\t\t\tstatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T(\"Software\\\\FreeRDP\\\\Server\"),\n\t\t\t\t\t0, KEY_READ | KEY_WOW64_64KEY, &hKey);\n\t\t\tif (status == ERROR_SUCCESS)\n\t\t\t{\n\t\t\t\tstatus = RegQueryValueEx(hKey, _T(\"SspiModule\"), NULL, &dwType, NULL, &dwSize);\n\t\t\t\tif (status == ERROR_SUCCESS)\n\t\t\t\t{\n\t\t\t\t\tcredssp->SspiModule = (LPTSTR) malloc(dwSize + sizeof(TCHAR));\n\t\t\t\t\tstatus = RegQueryValueEx(hKey, _T(\"SspiModule\"), NULL, &dwType,\n\t\t\t\t\t\t\t(BYTE*) credssp->SspiModule, &dwSize);\n\t\t\t\t\tif (status == ERROR_SUCCESS)\n\t\t\t\t\t{\n\t\t\t\t\t\t_tprintf(_T(\"Using SSPI Module: %s\\n\"), credssp->SspiModule);\n\t\t\t\t\t\tRegCloseKey(hKey);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn credssp;\n}", "target": 0}
{"code": "static Jsi_RC jsi_ArrayFlatSub(Jsi_Interp *interp, Jsi_Obj* nobj, Jsi_Value *arr, int depth) {\n    int i, n = 0, len = jsi_SizeOfArray(interp, arr->d.obj);\n    if (len <= 0) return JSI_OK;\n    Jsi_RC rc = JSI_OK;\n    int clen = jsi_SizeOfArray(interp, nobj);\n    for (i = 0; i < len && rc == JSI_OK; i++) {\n        Jsi_Value *t = Jsi_ValueArrayIndex(interp, arr, i);\n        if (t && depth>0 && Jsi_ValueIsArray(interp, t))\n            rc = jsi_ArrayFlatSub(interp, nobj, t , depth-1);\n        else if (!Jsi_ValueIsUndef(interp, t))\n            Jsi_ObjArrayAdd(interp, nobj, t);\n        if ((uint)(++n + clen)>interp->maxArrayList)\n            return Jsi_LogError(\"array size exceeded\");\n    }\n    return rc;\n}", "target": 0}
{"code": "ikev2_sub_print(netdissect_options *ndo,\n\t\tstruct isakmp *base,\n\t\tu_char np, const struct isakmp_gen *ext, const u_char *ep,\n\t\tuint32_t phase, uint32_t doi, uint32_t proto, int depth)\n{\n\tconst u_char *cp;\n\tint i;\n\tstruct isakmp_gen e;\n\tcp = (const u_char *)ext;\n\twhile (np) {\n\t\tND_TCHECK(*ext);\n\t\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\t\tND_TCHECK2(*ext, ntohs(e.len));\n\t\tdepth++;\n\t\tND_PRINT((ndo,\"\\n\"));\n\t\tfor (i = 0; i < depth; i++)\n\t\t\tND_PRINT((ndo,\"    \"));\n\t\tND_PRINT((ndo,\"(\"));\n\t\tcp = ikev2_sub0_print(ndo, base, np,\n\t\t\t\t      ext, ep, phase, doi, proto, depth);\n\t\tND_PRINT((ndo,\")\"));\n\t\tdepth--;\n\t\tif (cp == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\t\tnp = e.np;\n\t\text = (const struct isakmp_gen *)cp;\n\t}\n\treturn cp;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(np)));\n\treturn NULL;\n}", "target": 1}
{"code": "static int async_polkit_callback(sd_bus_message *reply, void *userdata, sd_bus_error *error) {\n        _cleanup_(sd_bus_error_free) sd_bus_error error_buffer = SD_BUS_ERROR_NULL;\n        AsyncPolkitQuery *q = userdata;\n        int r;\n        assert(reply);\n        assert(q);\n        assert(q->slot);\n        q->slot = sd_bus_slot_unref(q->slot);\n        assert(!q->reply);\n        q->reply = sd_bus_message_ref(reply);\n        assert(!q->defer_event_source);\n        r = sd_event_add_defer(sd_bus_get_event(sd_bus_message_get_bus(reply)), &q->defer_event_source, async_polkit_defer, q);\n        if (r < 0)\n                goto fail;\n        r = sd_event_source_set_priority(q->defer_event_source, SD_EVENT_PRIORITY_IDLE);\n        if (r < 0)\n                goto fail;\n        r = sd_event_source_set_enabled(q->defer_event_source, SD_EVENT_ONESHOT);\n        if (r < 0)\n                goto fail;\n        r = sd_bus_message_rewind(q->request, true);\n        if (r < 0)\n                goto fail;\n        r = sd_bus_enqueue_for_read(sd_bus_message_get_bus(q->request), q->request);\n        if (r < 0)\n                goto fail;\n        return 1;\nfail:\n        log_debug_errno(r, \"Processing asynchronous PolicyKit reply failed, ignoring: %m\");\n        (void) sd_bus_reply_method_errno(q->request, r, NULL);\n        async_polkit_query_free(q);\n        return r;\n}", "target": 0}
{"code": "static int store_icy(URLContext *h, int size)\n{\n    HTTPContext *s = h->priv_data;\n    int remaining = s->icy_metaint - s->icy_data_read;\n    if (remaining < 0)\n        return AVERROR_INVALIDDATA;\n    if (!remaining) {\n        uint8_t ch;\n        int len = http_read_stream_all(h, &ch, 1);\n        if (len < 0)\n            return len;\n        if (ch > 0) {\n            char data[255 * 16 + 1];\n            int ret;\n            len = ch * 16;\n            ret = http_read_stream_all(h, data, len);\n            if (ret < 0)\n                return ret;\n            data[len + 1] = 0;\n            if ((ret = av_opt_set(s, \"icy_metadata_packet\", data, 0)) < 0)\n                return ret;\n            update_metadata(s, data);\n        }\n        s->icy_data_read = 0;\n        remaining        = s->icy_metaint;\n    }\n    return FFMIN(size, remaining);\n}", "target": 1}
{"code": "static int gup_huge_pgd(pgd_t orig, pgd_t *pgdp, unsigned long addr,\n\t\t\tunsigned long end, int write,\n\t\t\tstruct page **pages, int *nr)\n{\n\tint refs;\n\tstruct page *head, *page;\n\tif (!pgd_access_permitted(orig, write))\n\t\treturn 0;\n\tBUILD_BUG_ON(pgd_devmap(orig));\n\trefs = 0;\n\tpage = pgd_page(orig) + ((addr & ~PGDIR_MASK) >> PAGE_SHIFT);\n\tdo {\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\t\tpage++;\n\t\trefs++;\n\t} while (addr += PAGE_SIZE, addr != end);\n\thead = compound_head(pgd_page(orig));\n\tif (!page_cache_add_speculative(head, refs)) {\n\t\t*nr -= refs;\n\t\treturn 0;\n\t}\n\tif (unlikely(pgd_val(orig) != pgd_val(*pgdp))) {\n\t\t*nr -= refs;\n\t\twhile (refs--)\n\t\t\tput_page(head);\n\t\treturn 0;\n\t}\n\tSetPageReferenced(head);\n\treturn 1;\n}", "target": 1}
{"code": "static int ion_handle_put_nolock(struct ion_handle *handle)\n{\n\tint ret;\n\tret = kref_put(&handle->ref, ion_handle_destroy);\n\treturn ret;\n}", "target": 0}
{"code": "GF_Err dac3_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DEC3;\n\te = gf_isom_box_write_header(s, bs);\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DAC3;\n\tif (e) return e;\n\te = gf_odf_ac3_cfg_write_bs(&ptr->cfg, bs);\n\tif (e) return e;\n\tif (ptr->cfg.atmos_ec3_ext || ptr->cfg.complexity_index_type) {\n\t\tgf_bs_write_int(bs, 0, 7);\n\t\tgf_bs_write_int(bs, ptr->cfg.atmos_ec3_ext, 1);\n\t\tgf_bs_write_u8(bs, ptr->cfg.complexity_index_type);\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "void j2k_dump (opj_j2k_t* p_j2k, OPJ_INT32 flag, FILE* out_stream)\n{\n        if ( (flag & OPJ_JP2_INFO) || (flag & OPJ_JP2_IND)){\n                fprintf(out_stream, \"Wrong flag\\n\");\n                return;\n        }\n        if (flag & OPJ_IMG_INFO){\n                if (p_j2k->m_private_image)\n                        j2k_dump_image_header(p_j2k->m_private_image, 0, out_stream);\n        }\n        if (flag & OPJ_J2K_MH_INFO){\n                opj_j2k_dump_MH_info(p_j2k, out_stream);\n        }\n        if (flag & OPJ_J2K_TCH_INFO){\n          OPJ_UINT32 l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;\n          OPJ_UINT32 i;\n          opj_tcp_t * l_tcp = p_j2k->m_cp.tcps;\n          for (i=0;i<l_nb_tiles;++i) {\n            opj_j2k_dump_tile_info( l_tcp,(OPJ_INT32)p_j2k->m_private_image->numcomps, out_stream);\n            ++l_tcp;\n          }\n        }\n        if (flag & OPJ_J2K_TH_INFO){\n        }\n        if (flag & OPJ_J2K_MH_IND){\n                opj_j2k_dump_MH_index(p_j2k, out_stream);\n        }\n        if (flag & OPJ_J2K_TH_IND){\n        }\n}", "target": 0}
{"code": "Status OpLevelCostEstimator::PredictMaxPoolGrad(const OpContext& op_context,\n                                                NodeCosts* node_costs) const {\n  bool found_unknown_shapes = false;\n  const auto& op_info = op_context.op_info;\n  if (op_info.inputs_size() < 3) {\n    return errors::InvalidArgument(\"MaxPoolGrad op has invalid inputs: \",\n                                   op_info.ShortDebugString());\n  }\n  ConvolutionDimensions dims = OpDimensionsFromInputs(\n      op_info.inputs(0).shape(), op_info, &found_unknown_shapes);\n  int64_t ops = 0;\n  if (dims.kx == 1 && dims.ky == 1) {\n    ops = dims.batch * dims.ix * dims.iy * dims.iz;\n  } else if (dims.kx <= dims.sx && dims.ky <= dims.sy) {\n    ops = dims.batch * dims.iz *\n          (dims.ox * dims.oy * (dims.kx * dims.ky - 1) + dims.ix * dims.iy);\n  } else {\n    ops = dims.batch * dims.iz *\n          (dims.ox * dims.oy * (dims.kx * dims.ky - 1) + dims.ix * dims.iy * 2);\n  }\n  node_costs->num_compute_ops = ops;\n  const int64_t input0_size =\n      CalculateTensorSize(op_info.inputs(0), &found_unknown_shapes);\n  const int64_t input2_size =\n      CalculateTensorSize(op_info.inputs(2), &found_unknown_shapes);\n  node_costs->num_input_bytes_accessed = {input0_size, 0, input2_size};\n  const int64_t output_size =\n      CalculateTensorSize(op_info.inputs(0), &found_unknown_shapes);\n  node_costs->num_output_bytes_accessed = {output_size};\n  node_costs->max_memory = output_size;\n  if (found_unknown_shapes) {\n    node_costs->inaccurate = true;\n    node_costs->num_nodes_with_unknown_shapes = 1;\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "static bool check_underflow(const struct ipt_entry *e)\n{\n\tconst struct xt_entry_target *t;\n\tunsigned int verdict;\n\tif (!unconditional(&e->ip))\n\t\treturn false;\n\tt = ipt_get_target_c(e);\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\n\t\treturn false;\n\tverdict = ((struct xt_standard_target *)t)->verdict;\n\tverdict = -verdict - 1;\n\treturn verdict == NF_DROP || verdict == NF_ACCEPT;\n}", "target": 1}
{"code": "static inline int page_is_allowed(unsigned long pfn)\n{\n\treturn devmem_is_allowed(pfn);\n}", "target": 0}
{"code": "errno_t sss_filter_sanitize_ex(TALLOC_CTX *mem_ctx,\n                               const char *input,\n                               char **sanitized,\n                               const char *ignore)\n{\n    char *output;\n    size_t i = 0;\n    size_t j = 0;\n    char *allowed;\n    output = talloc_array(mem_ctx, char, strlen(input) * 3 + 1);\n    if (!output) {\n        return ENOMEM;\n    }\n    while (input[i]) {\n        if (ignore == NULL) {\n            allowed = NULL;\n        } else {\n            allowed = strchr(ignore, input[i]);\n        }\n        if (allowed) {\n            output[j++] = input[i++];\n            continue;\n        }\n        switch(input[i]) {\n        case '\\t':\n            output[j++] = '\\\\';\n            output[j++] = '0';\n            output[j++] = '9';\n            break;\n        case ' ':\n            output[j++] = '\\\\';\n            output[j++] = '2';\n            output[j++] = '0';\n            break;\n        case '*':\n            output[j++] = '\\\\';\n            output[j++] = '2';\n            output[j++] = 'a';\n            break;\n        case '(':\n            output[j++] = '\\\\';\n            output[j++] = '2';\n            output[j++] = '8';\n            break;\n        case ')':\n            output[j++] = '\\\\';\n            output[j++] = '2';\n            output[j++] = '9';\n            break;\n        case '\\\\':\n            output[j++] = '\\\\';\n            output[j++] = '5';\n            output[j++] = 'c';\n            break;\n        case '\\r':\n            output[j++] = '\\\\';\n            output[j++] = '0';\n            output[j++] = 'd';\n            break;\n        case '\\n':\n            output[j++] = '\\\\';\n            output[j++] = '0';\n            output[j++] = 'a';\n            break;\n        default:\n            output[j++] = input[i];\n        }\n        i++;\n    }\n    output[j] = '\\0';\n    *sanitized = talloc_realloc(mem_ctx, output, char, j+1);\n    if (!*sanitized) {\n        talloc_free(output);\n        return ENOMEM;\n    }\n    return EOK;\n}", "target": 1}
{"code": "agoo_ws_create_req(agooCon c, long mlen) {\n    uint8_t\top = 0x0F & *c->buf;\n    if (NULL == (c->req = agoo_req_create(mlen))) {\n\tagoo_log_cat(&agoo_error_cat, \"Out of memory attempting to allocate request.\");\n\treturn true;\n    }\n    if (NULL == c->up || agoo_server.ctx_nil_value == c->up->ctx) {\n\treturn true;\n    }\n    memset(c->req, 0, sizeof(struct _agooReq));\n    if ((long)c->bcnt <= mlen) {\n\tmemcpy(c->req->msg, c->buf, c->bcnt);\n\tif ((long)c->bcnt < mlen) {\n\t    memset(c->req->msg + c->bcnt, 0, mlen - c->bcnt);\n\t}\n    } else {\n\tmemcpy(c->req->msg, c->buf, mlen);\n    }\n    c->req->msg[mlen] = '\\0';\n    c->req->mlen = mlen;\n    c->req->method = (AGOO_WS_OP_BIN == op) ? AGOO_ON_BIN : AGOO_ON_MSG;\n    c->req->upgrade = AGOO_UP_NONE;\n    c->req->up = c->up;\n    memcpy(c->req->remote, c->remote, sizeof(c->remote));\n    c->req->res = NULL;\n    if (c->up->on_msg) {\n\tc->req->hook = agoo_hook_create(AGOO_NONE, NULL, c->up->ctx, PUSH_HOOK, &agoo_server.eval_queue);\n    }\n    return false;\n}", "target": 0}
{"code": "enum ImapAuthRes imap_auth_login(struct ImapData *idata, const char *method)\n{\n  char q_user[SHORT_STRING], q_pass[SHORT_STRING];\n  char buf[STRING];\n  int rc;\n  if (mutt_bit_isset(idata->capabilities, LOGINDISABLED))\n  {\n    mutt_message(_(\"LOGIN disabled on this server.\"));\n    return IMAP_AUTH_UNAVAIL;\n  }\n  if (mutt_account_getuser(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n  if (mutt_account_getpass(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n  mutt_message(_(\"Logging in...\"));\n  imap_quote_string(q_user, sizeof(q_user), idata->conn->account.user);\n  imap_quote_string(q_pass, sizeof(q_pass), idata->conn->account.pass);\n  if (DebugLevel < IMAP_LOG_PASS)\n    mutt_debug(2, \"Sending LOGIN command for %s...\\n\", idata->conn->account.user);\n  snprintf(buf, sizeof(buf), \"LOGIN %s %s\", q_user, q_pass);\n  rc = imap_exec(idata, buf, IMAP_CMD_FAIL_OK | IMAP_CMD_PASS);\n  if (!rc)\n  {\n    mutt_clear_error(); \n    return IMAP_AUTH_SUCCESS;\n  }\n  mutt_error(_(\"Login failed.\"));\n  return IMAP_AUTH_FAILURE;\n}", "target": 1}
{"code": "void die_upon_dubious_ownership(const char *gitfile, const char *worktree,\n\t\t\t\tconst char *gitdir)\n{\n\tstruct strbuf report = STRBUF_INIT, quoted = STRBUF_INIT;\n\tconst char *path;\n\tif (ensure_valid_ownership(gitfile, worktree, gitdir, &report))\n\t\treturn;\n\tstrbuf_complete(&report, '\\n');\n\tpath = gitfile ? gitfile : gitdir;\n\tsq_quote_buf_pretty(&quoted, path);\n\tdie(_(\"detected dubious ownership in repository at '%s'\\n\"\n\t      \"%s\"\n\t      \"To add an exception for this directory, call:\\n\"\n\t      \"\\n\"\n\t      \"\\tgit config --global --add safe.directory %s\"),\n\t    path, report.buf, quoted.buf);\n}", "target": 0}
{"code": "int smm_setup_relocation_handler(struct smm_loader_params *params)\n{\n\tvoid *smram = (void *)(SMM_DEFAULT_BASE);\n\tprintk(BIOS_SPEW, \"%s: enter\\n\", __func__);\n\tif (params->num_concurrent_save_states > 1)\n\t\treturn -1;\n\tif (params->handler == NULL)\n\t\treturn -1;\n\tif (params->num_concurrent_stacks == 0)\n\t\tparams->num_concurrent_stacks = CONFIG_MAX_CPUS;\n\tparams->smm_main_entry_offset = SMM_ENTRY_OFFSET;\n\tparams->smram_start = SMM_DEFAULT_BASE;\n\tparams->smram_end = SMM_DEFAULT_BASE + SMM_DEFAULT_SIZE;\n\treturn smm_module_setup_stub(smram, SMM_DEFAULT_SIZE,\n\t\t\t\tparams, fxsave_area_relocation);\n\tprintk(BIOS_SPEW, \"%s: exit\\n\", __func__);\n}", "target": 0}
{"code": "static void unix_release_sock(struct sock *sk, int embrion)\n{\n\tstruct unix_sock *u = unix_sk(sk);\n\tstruct path path;\n\tstruct sock *skpair;\n\tstruct sk_buff *skb;\n\tint state;\n\tunix_remove_socket(sk);\n\tunix_state_lock(sk);\n\tsock_orphan(sk);\n\tsk->sk_shutdown = SHUTDOWN_MASK;\n\tpath\t     = u->path;\n\tu->path.dentry = NULL;\n\tu->path.mnt = NULL;\n\tstate = sk->sk_state;\n\tsk->sk_state = TCP_CLOSE;\n\tunix_state_unlock(sk);\n\twake_up_interruptible_all(&u->peer_wait);\n\tskpair = unix_peer(sk);\n\tif (skpair != NULL) {\n\t\tif (sk->sk_type == SOCK_STREAM || sk->sk_type == SOCK_SEQPACKET) {\n\t\t\tunix_state_lock(skpair);\n\t\t\tskpair->sk_shutdown = SHUTDOWN_MASK;\n\t\t\tif (!skb_queue_empty(&sk->sk_receive_queue) || embrion)\n\t\t\t\tskpair->sk_err = ECONNRESET;\n\t\t\tunix_state_unlock(skpair);\n\t\t\tskpair->sk_state_change(skpair);\n\t\t\tsk_wake_async(skpair, SOCK_WAKE_WAITD, POLL_HUP);\n\t\t}\n\t\tunix_dgram_peer_wake_disconnect(sk, skpair);\n\t\tsock_put(skpair); \n\t\tunix_peer(sk) = NULL;\n\t}\n\twhile ((skb = skb_dequeue(&sk->sk_receive_queue)) != NULL) {\n\t\tif (state == TCP_LISTEN)\n\t\t\tunix_release_sock(skb->sk, 1);\n\t\tUNIXCB(skb).consumed = skb->len;\n\t\tkfree_skb(skb);\n\t}\n\tif (path.dentry)\n\t\tpath_put(&path);\n\tsock_put(sk);\n\tif (unix_tot_inflight)\n\t\tunix_gc();\t\t\n}", "target": 0}
{"code": "p2la(UINT8 *out, const UINT8 *in, int xsize, const UINT8 *palette) {\n    int x;\n    for (x = 0; x < xsize; x++, out += 4) {\n        const UINT8 *rgba = &palette[*in++ * 4];\n        out[0] = out[1] = out[2] = L(rgba) / 1000;\n        out[3] = rgba[3];\n    }\n}", "target": 0}
{"code": "static void bpf_adj_branches(struct bpf_prog *prog, u32 pos, u32 delta)\n{\n\tstruct bpf_insn *insn = prog->insnsi;\n\tu32 i, insn_cnt = prog->len;\n\tbool pseudo_call;\n\tu8 code;\n\tint off;\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tcode = insn->code;\n\t\tif (BPF_CLASS(code) != BPF_JMP)\n\t\t\tcontinue;\n\t\tif (BPF_OP(code) == BPF_EXIT)\n\t\t\tcontinue;\n\t\tif (BPF_OP(code) == BPF_CALL) {\n\t\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\t\tpseudo_call = true;\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tpseudo_call = false;\n\t\t}\n\t\toff = pseudo_call ? insn->imm : insn->off;\n\t\tif (i < pos && i + off + 1 > pos)\n\t\t\toff += delta;\n\t\telse if (i > pos + delta && i + off + 1 <= pos + delta)\n\t\t\toff -= delta;\n\t\tif (pseudo_call)\n\t\t\tinsn->imm = off;\n\t\telse\n\t\t\tinsn->off = off;\n\t}\n}", "target": 1}
{"code": "TfLiteStatus GetInputSafe(const TfLiteContext* context, const TfLiteNode* node,\n                          int index, const TfLiteTensor** tensor) {\n  return GetMutableInputSafe(context, node, index, tensor);\n}", "target": 0}
{"code": "smb3_create_lease_buf(u8 *lease_key, u8 oplock)\n{\n\tstruct create_lease_v2 *buf;\n\tbuf = kzalloc(sizeof(struct create_lease_v2), GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\tmemcpy(&buf->lcontext.LeaseKey, lease_key, SMB2_LEASE_KEY_SIZE);\n\tbuf->lcontext.LeaseState = map_oplock_to_lease(oplock);\n\tbuf->ccontext.DataOffset = cpu_to_le16(offsetof\n\t\t\t\t\t(struct create_lease_v2, lcontext));\n\tbuf->ccontext.DataLength = cpu_to_le32(sizeof(struct lease_context_v2));\n\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof\n\t\t\t\t(struct create_lease_v2, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\tbuf->Name[0] = 'R';\n\tbuf->Name[1] = 'q';\n\tbuf->Name[2] = 'L';\n\tbuf->Name[3] = 's';\n\treturn (char *)buf;\n}", "target": 0}
{"code": "static void copy_to_user_state(struct xfrm_state *x, struct xfrm_usersa_info *p)\n{\n\tmemset(p, 0, sizeof(*p));\n\tmemcpy(&p->id, &x->id, sizeof(p->id));\n\tmemcpy(&p->sel, &x->sel, sizeof(p->sel));\n\tmemcpy(&p->lft, &x->lft, sizeof(p->lft));\n\tmemcpy(&p->curlft, &x->curlft, sizeof(p->curlft));\n\tmemcpy(&p->stats, &x->stats, sizeof(p->stats));\n\tmemcpy(&p->saddr, &x->props.saddr, sizeof(p->saddr));\n\tp->mode = x->props.mode;\n\tp->replay_window = x->props.replay_window;\n\tp->reqid = x->props.reqid;\n\tp->family = x->props.family;\n\tp->flags = x->props.flags;\n\tp->seq = x->km.seq;\n}", "target": 0}
{"code": "static int _string_check(int linenumber, char *buf, const char *buf2)\n{\n  if(strcmp(buf, buf2)) {\n    printf(\"sprintf line %d failed:\\nwe      '%s'\\nsystem: '%s'\\n\",\n           linenumber, buf, buf2);\n    return 1;\n  }\n  return 0;\n}", "target": 0}
{"code": "static void sample_to_timespec(const clockid_t which_clock,\n\t\t\t       union cpu_time_count cpu,\n\t\t\t       struct timespec *tp)\n{\n\tif (CPUCLOCK_WHICH(which_clock) == CPUCLOCK_SCHED) {\n\t\ttp->tv_sec = div_long_long_rem(cpu.sched,\n\t\t\t\t\t       NSEC_PER_SEC, &tp->tv_nsec);\n\t} else {\n\t\tcputime_to_timespec(cpu.cpu, tp);\n\t}\n}", "target": 1}
{"code": "static inline int init_new_context(struct task_struct *tsk,\n\t\t\t\t   struct mm_struct *mm)\n{\n\t#ifdef CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS\n\tif (cpu_feature_enabled(X86_FEATURE_OSPKE)) {\n\t\tmm->context.pkey_allocation_map = 0x1;\n\t\tmm->context.execute_only_pkey = -1;\n\t}\n\t#endif\n\tinit_new_context_ldt(tsk, mm);\n\treturn 0;\n}", "target": 1}
{"code": "static bool is_subdir(const char *subdir, const char *dir, size_t len)\n{\n\tsize_t subdirlen = strlen(subdir);\n\tif (subdirlen < len)\n\t\treturn false;\n\tif (strncmp(subdir, dir, len) != 0)\n\t\treturn false;\n\tif (dir[len-1] == '/')\n\t\treturn true;\n\tif (subdir[len] == '/' || subdirlen == len)\n\t\treturn true;\n\treturn false;\n}", "target": 0}
{"code": "static inline int sector_in_part(struct hd_struct *part, sector_t sector)\n{\n\treturn part->start_sect <= sector &&\n\t\tsector < part->start_sect + part_nr_sects_read(part);\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& val = ctx->input(0);\n    int64 id = ctx->session_state()->GetNewId();\n    TensorStore::TensorAndKey tk{val, id, requested_device()};\n    OP_REQUIRES_OK(ctx, ctx->tensor_store()->AddTensor(name(), tk));\n    Tensor* handle = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({}), &handle));\n    if (ctx->expected_output_dtype(0) == DT_RESOURCE) {\n      ResourceHandle resource_handle = MakeResourceHandle<Tensor>(\n          ctx, SessionState::kTensorHandleResourceTypeName,\n          tk.GetHandle(name()));\n      resource_handle.set_maybe_type_name(\n          SessionState::kTensorHandleResourceTypeName);\n      handle->scalar<ResourceHandle>()() = resource_handle;\n    } else {\n      handle->flat<tstring>().setConstant(tk.GetHandle(name()));\n    }\n  }", "target": 1}
{"code": "static void exif_error_docref(const char *docref EXIFERR_DC, const image_info_type *ImageInfo, int type, const char *format, ...)\n{\n\tva_list args;\n\tva_start(args, format);\n#ifdef EXIF_DEBUG\n\t{\n\t\tchar *buf;\n\t\tspprintf(&buf, 0, \"%s(%d): %s\", _file, _line, format);\n\t\tphp_verror(docref, ImageInfo && ImageInfo->FileName ? ImageInfo->FileName:\"\", type, buf, args);\n\t\tefree(buf);\n\t}\n#else\n\tphp_verror(docref, ImageInfo && ImageInfo->FileName ? ImageInfo->FileName:\"\", type, format, args);\n#endif\n\tva_end(args);\n}", "target": 0}
{"code": "void http_buffer_heavy_realign(struct buffer *buf, struct http_msg *msg)\n{\n\tchar *end = buf->data + buf->size;\n\tint off = buf->data + buf->size - buf->w;\n\tif (buf->l) {\n\t\tint block1 = buf->l;\n\t\tint block2 = 0;\n\t\tif (buf->r <= buf->w) {\n\t\t\tblock1 = buf->data + buf->size - buf->w;\n\t\t\tblock2 = buf->r - buf->data;\n\t\t}\n\t\tif (block2)\n\t\t\tmemcpy(swap_buffer, buf->data, block2);\n\t\tmemmove(buf->data, buf->w, block1);\n\t\tif (block2)\n\t\t\tmemcpy(buf->data + block1, swap_buffer, block2);\n\t}\n\tbuf->w    = buf->data;\n\tbuf->lr  += off; if (buf->lr  >= end) buf->lr  -= buf->size;\n\tbuf->r   += off; if (buf->r   >= end) buf->r   -= buf->size;\n\tmsg->sol += off; if (msg->sol >= end) msg->sol -= buf->size;\n\tmsg->eol += off; if (msg->eol >= end) msg->eol -= buf->size;\n\tmsg->som  = 0;\n\tmsg->eoh += off; if (msg->eoh >= buf->size) msg->eoh -= buf->size;\n\tmsg->sov += off; if (msg->sov >= buf->size) msg->sov -= buf->size;\n\tif (msg->err_pos >= 0) {\n\t\tmsg->err_pos += off;\n\t\tif (msg->err_pos >= buf->size)\n\t\t\tmsg->err_pos -= buf->size;\n\t}\n\tbuf->flags &= ~BF_FULL;\n\tif (buf->l >= buffer_max_len(buf))\n\t\tbuf->flags |= BF_FULL;\n}", "target": 0}
{"code": "jas_matrix_t *jas_matrix_create(int numrows, int numcols)\n{\n\tjas_matrix_t *matrix;\n\tint i;\n\tsize_t size;\n\tmatrix = 0;\n\tif (numrows < 0 || numcols < 0) {\n\t\tgoto error;\n\t}\n\tif (!(matrix = jas_malloc(sizeof(jas_matrix_t)))) {\n\t\tgoto error;\n\t}\n\tmatrix->flags_ = 0;\n\tmatrix->numrows_ = numrows;\n\tmatrix->numcols_ = numcols;\n\tmatrix->rows_ = 0;\n\tmatrix->maxrows_ = numrows;\n\tmatrix->data_ = 0;\n\tmatrix->datasize_ = 0;\n\tif (!jas_safe_size_mul(numrows, numcols, &size)) {\n\t\tgoto error;\n\t}\n\tmatrix->datasize_ = size;\n\tif (matrix->maxrows_ > 0) {\n\t\tif (!(matrix->rows_ = jas_alloc2(matrix->maxrows_,\n\t\t  sizeof(jas_seqent_t *)))) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\tif (matrix->datasize_ > 0) {\n\t\tif (!(matrix->data_ = jas_alloc2(matrix->datasize_,\n\t\t  sizeof(jas_seqent_t)))) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\tfor (i = 0; i < numrows; ++i) {\n\t\tmatrix->rows_[i] = &matrix->data_[i * matrix->numcols_];\n\t}\n\tfor (i = 0; i < matrix->datasize_; ++i) {\n\t\tmatrix->data_[i] = 0;\n\t}\n\tmatrix->xstart_ = 0;\n\tmatrix->ystart_ = 0;\n\tmatrix->xend_ = matrix->numcols_;\n\tmatrix->yend_ = matrix->numrows_;\n\treturn matrix;\nerror:\n\tif (matrix) {\n\t\tjas_matrix_destroy(matrix);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "  void ValidateOpDimensionsFromInputs(const int n, const int h, const int w,\n                                      const int c, const int kx, const int ky,\n                                      const int sx, const int sy,\n                                      const string& data_format,\n                                      const string& padding) {\n    OpContext op_context;\n    int ho;\n    int wo;\n    if (data_format == \"NHWC\") {\n      op_context = DescribePoolingOp(\"MaxPool\", {n, h, w, c}, {1, kx, ky, 1},\n                                     {1, sx, sy, 1}, \"NHWC\", padding);\n      ho = op_context.op_info.outputs(0).shape().dim(1).size();\n      wo = op_context.op_info.outputs(0).shape().dim(2).size();\n    } else {\n      op_context = DescribePoolingOp(\"MaxPool\", {n, c, h, w}, {1, 1, kx, ky},\n                                     {1, 1, sx, sy}, \"NCHW\", padding);\n      ho = op_context.op_info.outputs(0).shape().dim(2).size();\n      wo = op_context.op_info.outputs(0).shape().dim(3).size();\n    }\n    bool found_unknown_shapes;\n    auto dims = OpLevelCostEstimator::OpDimensionsFromInputs(\n        op_context.op_info.inputs(0).shape(), op_context.op_info,\n        &found_unknown_shapes);\n    Padding padding_enum;\n    if (padding == \"VALID\") {\n      padding_enum = Padding::VALID;\n    } else {\n      padding_enum = Padding::SAME;\n    }\n    EXPECT_EQ(n, dims.batch);\n    EXPECT_EQ(h, dims.ix);\n    EXPECT_EQ(w, dims.iy);\n    EXPECT_EQ(c, dims.iz);\n    EXPECT_EQ(kx, dims.kx);\n    EXPECT_EQ(ky, dims.ky);\n    EXPECT_EQ(sx, dims.sx);\n    EXPECT_EQ(sy, dims.sy);\n    EXPECT_EQ(ho, dims.ox);\n    EXPECT_EQ(wo, dims.oy);\n    EXPECT_EQ(c, dims.oz);\n    EXPECT_EQ(padding_enum, dims.padding);\n  }", "target": 1}
{"code": "static inline u32 dma_low(dma_addr_t addr)\n{\n\treturn (u32)addr;\n}", "target": 1}
{"code": "void ext4_journal_abort_handle(const char *caller, unsigned int line,\n\t\t\t       const char *err_fn, struct buffer_head *bh,\n\t\t\t       handle_t *handle, int err)\n{\n\tchar nbuf[16];\n\tconst char *errstr = ext4_decode_error(NULL, err, nbuf);\n\tBUG_ON(!ext4_handle_valid(handle));\n\tif (bh)\n\t\tBUFFER_TRACE(bh, \"abort\");\n\tif (!handle->h_err)\n\t\thandle->h_err = err;\n\tif (is_handle_aborted(handle))\n\t\treturn;\n\tprintk(KERN_ERR \"EXT4-fs: %s:%d: aborting transaction: %s in %s\\n\",\n\t       caller, line, errstr, err_fn);\n\tjbd2_journal_abort_handle(handle);\n}", "target": 0}
{"code": "static int wrmsr_interception(struct vcpu_svm *svm)\n{\n\tstruct msr_data msr;\n\tu32 ecx = svm->vcpu.arch.regs[VCPU_REGS_RCX];\n\tu64 data = (svm->vcpu.arch.regs[VCPU_REGS_RAX] & -1u)\n\t\t| ((u64)(svm->vcpu.arch.regs[VCPU_REGS_RDX] & -1u) << 32);\n\tmsr.data = data;\n\tmsr.index = ecx;\n\tmsr.host_initiated = false;\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 2;\n\tif (svm_set_msr(&svm->vcpu, &msr)) {\n\t\ttrace_kvm_msr_write_ex(ecx, data);\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t} else {\n\t\ttrace_kvm_msr_write(ecx, data);\n\t\tskip_emulated_instruction(&svm->vcpu);\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "BOOL rdp_decrypt(rdpRdp* rdp, STREAM* s, int length, UINT16 securityFlags)\n{\n\tBYTE cmac[8];\n\tBYTE wmac[8];\n\tif (rdp->settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS)\n\t{\n\t\tUINT16 len;\n\t\tBYTE version, pad;\n\t\tBYTE* sig;\n\t\tif (stream_get_left(s) < 12)\n\t\t\treturn FALSE;\n\t\tstream_read_UINT16(s, len); \n\t\tstream_read_BYTE(s, version); \n\t\tstream_read_BYTE(s, pad);\n\t\tsig = s->p;\n\t\tstream_seek(s, 8);\t\n\t\tlength -= 12;\n\t\tif (!security_fips_decrypt(s->p, length, rdp))\n\t\t{\n\t\t\tprintf(\"FATAL: cannot decrypt\\n\");\n\t\t\treturn FALSE; \n\t\t}\n\t\tif (!security_fips_check_signature(s->p, length - pad, sig, rdp))\n\t\t{\n\t\t\tprintf(\"FATAL: invalid packet signature\\n\");\n\t\t\treturn FALSE; \n\t\t}\n\t\ts->size -= pad;\n\t\treturn TRUE;\n\t}\n\tif (stream_get_left(s) < 8)\n\t\treturn FALSE;\n\tstream_read(s, wmac, sizeof(wmac));\n\tlength -= sizeof(wmac);\n\tsecurity_decrypt(s->p, length, rdp);\n\tif (securityFlags & SEC_SECURE_CHECKSUM)\n\t\tsecurity_salted_mac_signature(rdp, s->p, length, FALSE, cmac);\n\telse\n\t\tsecurity_mac_signature(rdp, s->p, length, cmac);\n\tif (memcmp(wmac, cmac, sizeof(wmac)) != 0)\n\t{\n\t\tprintf(\"WARNING: invalid packet signature\\n\");\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "static void __init netlink_add_usersock_entry(void)\n{\n\tstruct listeners *listeners;\n\tint groups = 32;\n\tlisteners = kzalloc(sizeof(*listeners) + NLGRPSZ(groups), GFP_KERNEL);\n\tif (!listeners)\n\t\tpanic(\"netlink_add_usersock_entry: Cannot allocate listeners\\n\");\n\tnetlink_table_grab();\n\tnl_table[NETLINK_USERSOCK].groups = groups;\n\trcu_assign_pointer(nl_table[NETLINK_USERSOCK].listeners, listeners);\n\tnl_table[NETLINK_USERSOCK].module = THIS_MODULE;\n\tnl_table[NETLINK_USERSOCK].registered = 1;\n\tnl_table[NETLINK_USERSOCK].nl_nonroot = NL_NONROOT_SEND;\n\tnetlink_table_ungrab();\n}", "target": 0}
{"code": "int ossl_policy_cache_set_mapping(X509 *x, POLICY_MAPPINGS *maps)\n{\n    POLICY_MAPPING *map;\n    X509_POLICY_DATA *data;\n    X509_POLICY_CACHE *cache = x->policy_cache;\n    int i;\n    int ret = 0;\n    if (sk_POLICY_MAPPING_num(maps) == 0) {\n        ret = -1;\n        goto bad_mapping;\n    }\n    for (i = 0; i < sk_POLICY_MAPPING_num(maps); i++) {\n        map = sk_POLICY_MAPPING_value(maps, i);\n        if ((OBJ_obj2nid(map->subjectDomainPolicy) == NID_any_policy)\n            || (OBJ_obj2nid(map->issuerDomainPolicy) == NID_any_policy)) {\n            ret = -1;\n            goto bad_mapping;\n        }\n        data = ossl_policy_cache_find_data(cache, map->issuerDomainPolicy);\n        if (data == NULL && !cache->anyPolicy)\n            continue;\n        if (data == NULL) {\n            data = ossl_policy_data_new(NULL, map->issuerDomainPolicy,\n                                        cache->anyPolicy->flags\n                                        & POLICY_DATA_FLAG_CRITICAL);\n            if (data == NULL)\n                goto bad_mapping;\n            data->qualifier_set = cache->anyPolicy->qualifier_set;\n            data->flags |= POLICY_DATA_FLAG_MAPPED_ANY;\n            data->flags |= POLICY_DATA_FLAG_SHARED_QUALIFIERS;\n            if (!sk_X509_POLICY_DATA_push(cache->data, data)) {\n                ossl_policy_data_free(data);\n                goto bad_mapping;\n            }\n        } else\n            data->flags |= POLICY_DATA_FLAG_MAPPED;\n        if (!sk_ASN1_OBJECT_push(data->expected_policy_set,\n                                 map->subjectDomainPolicy))\n            goto bad_mapping;\n        map->subjectDomainPolicy = NULL;\n    }\n    ret = 1;\n bad_mapping:\n    if (ret == -1 && CRYPTO_THREAD_write_lock(x->lock)) {\n        x->ex_flags |= EXFLAG_INVALID_POLICY;\n        CRYPTO_THREAD_unlock(x->lock);\n    }\n    sk_POLICY_MAPPING_pop_free(maps, POLICY_MAPPING_free);\n    return ret;\n}", "target": 1}
{"code": "file_pop_buffer(struct magic_set *ms, file_pushbuf_t *pb)\n{\n\tchar *rbuf;\n\tif (ms->event_flags & EVENT_HAD_ERR) {\n\t\tfree(pb->buf);\n\t\tfree(pb);\n\t\treturn NULL;\n\t}\n\trbuf = ms->o.buf;\n\tms->o.buf = pb->buf;\n\tms->offset = pb->offset;\n\tfree(pb);\n\treturn rbuf;\n}", "target": 0}
{"code": "p_string(FILE* f, ptrdiff_t len, UChar* s)\n{\n  fputs(\":\", f);\n  while (len-- > 0) { fputc(*s++, f); }\n}", "target": 0}
{"code": "nf_nat_redirect_ipv4(struct sk_buff *skb,\n\t\t     const struct nf_nat_ipv4_multi_range_compat *mr,\n\t\t     unsigned int hooknum)\n{\n\tstruct nf_conn *ct;\n\tenum ip_conntrack_info ctinfo;\n\t__be32 newdst;\n\tstruct nf_nat_range newrange;\n\tNF_CT_ASSERT(hooknum == NF_INET_PRE_ROUTING ||\n\t\t     hooknum == NF_INET_LOCAL_OUT);\n\tct = nf_ct_get(skb, &ctinfo);\n\tNF_CT_ASSERT(ct && (ctinfo == IP_CT_NEW || ctinfo == IP_CT_RELATED));\n\tif (hooknum == NF_INET_LOCAL_OUT) {\n\t\tnewdst = htonl(0x7F000001);\n\t} else {\n\t\tstruct in_device *indev;\n\t\tstruct in_ifaddr *ifa;\n\t\tnewdst = 0;\n\t\trcu_read_lock();\n\t\tindev = __in_dev_get_rcu(skb->dev);\n\t\tif (indev != NULL) {\n\t\t\tifa = indev->ifa_list;\n\t\t\tnewdst = ifa->ifa_local;\n\t\t}\n\t\trcu_read_unlock();\n\t\tif (!newdst)\n\t\t\treturn NF_DROP;\n\t}\n\tmemset(&newrange.min_addr, 0, sizeof(newrange.min_addr));\n\tmemset(&newrange.max_addr, 0, sizeof(newrange.max_addr));\n\tnewrange.flags\t     = mr->range[0].flags | NF_NAT_RANGE_MAP_IPS;\n\tnewrange.min_addr.ip = newdst;\n\tnewrange.max_addr.ip = newdst;\n\tnewrange.min_proto   = mr->range[0].min;\n\tnewrange.max_proto   = mr->range[0].max;\n\treturn nf_nat_setup_info(ct, &newrange, NF_NAT_MANIP_DST);\n}", "target": 1}
{"code": "static entity_table_opt determine_entity_table(int all, int doctype)\n{\n\tentity_table_opt retval = {NULL};\n\tassert(!(doctype == ENT_HTML_DOC_XML1 && all));\n\tif (all) {\n\t\tretval.ms_table = (doctype == ENT_HTML_DOC_HTML5) ?\n\t\t\tentity_ms_table_html5 : entity_ms_table_html4;\n\t} else {\n\t\tretval.table = (doctype == ENT_HTML_DOC_HTML401) ?\n\t\t\tstage3_table_be_noapos_00000 : stage3_table_be_apos_00000;\n\t}\n\treturn retval;\n}", "target": 1}
{"code": "search_impl(i_ctx_t *i_ctx_p, bool forward)\n{\n    os_ptr op = osp;\n    os_ptr op1 = op - 1;\n    uint size = r_size(op);\n    uint count;\n    byte *pat;\n    byte *ptr;\n    byte ch;\n    int incr = forward ? 1 : -1;\n    check_read_type(*op1, t_string);\n    check_read_type(*op, t_string);\n    if (size > r_size(op1)) {\t\n        make_false(op);\n        return 0;\n    }\n    count = r_size(op1) - size;\n    ptr = op1->value.bytes;\n    if (size == 0)\n        goto found;\n    if (!forward)\n        ptr += count;\n    pat = op->value.bytes;\n    ch = pat[0];\n    do {\n        if (*ptr == ch && (size == 1 || !memcmp(ptr, pat, size)))\n            goto found;\n        ptr += incr;\n    }\n    while (count--);\n    make_false(op);\n    return 0;\nfound:\n    op->tas.type_attrs = op1->tas.type_attrs;\n    op->value.bytes = ptr;\n    r_set_size(op, size);\n    push(2);\n    op[-1] = *op1;\n    r_set_size(op - 1, ptr - op[-1].value.bytes);\n    op1->value.bytes = ptr + size;\n    r_set_size(op1, count + (!forward ? (size - 1) : 0));\n    make_true(op);\n    return 0;\n}", "target": 1}
{"code": "git_filemode_t git_tree_entry_filemode(const git_tree_entry *entry)\n{\n\treturn normalize_filemode(entry->attr);\n}", "target": 0}
{"code": "static struct pid *good_sigevent(sigevent_t * event)\n{\n\tstruct task_struct *rtn = current->group_leader;\n\tif ((event->sigev_notify & SIGEV_THREAD_ID ) &&\n\t\t(!(rtn = find_task_by_vpid(event->sigev_notify_thread_id)) ||\n\t\t !same_thread_group(rtn, current) ||\n\t\t (event->sigev_notify & ~SIGEV_THREAD_ID) != SIGEV_SIGNAL))\n\t\treturn NULL;\n\tif (((event->sigev_notify & ~SIGEV_THREAD_ID) != SIGEV_NONE) &&\n\t    ((event->sigev_signo <= 0) || (event->sigev_signo > SIGRTMAX)))\n\t\treturn NULL;\n\treturn task_pid(rtn);\n}", "target": 1}
{"code": "static int check_line_charstring(void)\n{\n  char *p = line;\n  while (isspace(*p))\n    p++;\n  return (*p == '/' || (p[0] == 'd' && p[1] == 'u' && p[2] == 'p'));\n}", "target": 1}
{"code": "htp_status_t htp_tx_req_process_body_data(htp_tx_t *tx, const void *data, size_t len) {\n    if ((tx == NULL) || (data == NULL)) return HTP_ERROR;\n    if (len == 0) return HTP_OK;\n    return htp_tx_req_process_body_data_ex(tx, data, len);\n}", "target": 0}
{"code": "int gru_set_context_option(unsigned long arg)\n{\n\tstruct gru_thread_state *gts;\n\tstruct gru_set_context_option_req req;\n\tint ret = 0;\n\tSTAT(set_context_option);\n\tif (copy_from_user(&req, (void __user *)arg, sizeof(req)))\n\t\treturn -EFAULT;\n\tgru_dbg(grudev, \"op %d, gseg 0x%lx, value1 0x%lx\\n\", req.op, req.gseg, req.val1);\n\tgts = gru_find_lock_gts(req.gseg);\n\tif (!gts) {\n\t\tgts = gru_alloc_locked_gts(req.gseg);\n\t\tif (IS_ERR(gts))\n\t\t\treturn PTR_ERR(gts);\n\t}\n\tswitch (req.op) {\n\tcase sco_blade_chiplet:\n\t\tif (req.val0 < -1 || req.val0 >= GRU_CHIPLETS_PER_HUB ||\n\t\t    req.val1 < -1 || req.val1 >= GRU_MAX_BLADES ||\n\t\t    (req.val1 >= 0 && !gru_base[req.val1])) {\n\t\t\tret = -EINVAL;\n\t\t} else {\n\t\t\tgts->ts_user_blade_id = req.val1;\n\t\t\tgts->ts_user_chiplet_id = req.val0;\n\t\t\tgru_check_context_placement(gts);\n\t\t}\n\t\tbreak;\n\tcase sco_gseg_owner:\n\t\tgts->ts_tgid_owner = current->tgid;\n\t\tbreak;\n\tcase sco_cch_req_slice:\n\t\tgts->ts_cch_req_slice = req.val1 & 3;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tgru_unlock_gts(gts);\n\treturn ret;\n}", "target": 1}
{"code": "void LanLinkProvider::newConnection()\n{\n    qCDebug(KDECONNECT_CORE) << \"LanLinkProvider newConnection\";\n    while (m_server->hasPendingConnections()) {\n        QSslSocket* socket = m_server->nextPendingConnection();\n        configureSocket(socket);\n        connect(socket, &QAbstractSocket::disconnected,\n                socket, &QObject::deleteLater);\n        connect(socket, &QIODevice::readyRead,\n                this, &LanLinkProvider::dataReceived);\n        QTimer* timer = new QTimer(socket);\n        timer->setSingleShot(true);\n        timer->setInterval(1000);\n        connect(socket, &QSslSocket::encrypted,\n                timer, &QObject::deleteLater);\n        connect(timer, &QTimer::timeout, socket, [socket] {\n            qCWarning(KDECONNECT_CORE) << \"LanLinkProvider/newConnection: Host timed out without sending any identity.\" << socket->peerAddress();\n            socket->disconnectFromHost();\n        });\n        timer->start();\n    }\n}", "target": 0}
{"code": "static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,\n\t\t\t\t   size_t count, loff_t *offset)\n{\n\tstruct snd_timer_user *tu;\n\tlong result = 0, unit;\n\tint qhead;\n\tint err = 0;\n\ttu = file->private_data;\n\tunit = tu->tread ? sizeof(struct snd_timer_tread) : sizeof(struct snd_timer_read);\n\tspin_lock_irq(&tu->qlock);\n\twhile ((long)count - result >= unit) {\n\t\twhile (!tu->qused) {\n\t\t\twait_queue_t wait;\n\t\t\tif ((file->f_flags & O_NONBLOCK) != 0 || result > 0) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tinit_waitqueue_entry(&wait, current);\n\t\t\tadd_wait_queue(&tu->qchange_sleep, &wait);\n\t\t\tspin_unlock_irq(&tu->qlock);\n\t\t\tschedule();\n\t\t\tspin_lock_irq(&tu->qlock);\n\t\t\tremove_wait_queue(&tu->qchange_sleep, &wait);\n\t\t\tif (tu->disconnected) {\n\t\t\t\terr = -ENODEV;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t\tif (signal_pending(current)) {\n\t\t\t\terr = -ERESTARTSYS;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t}\n\t\tqhead = tu->qhead++;\n\t\ttu->qhead %= tu->queue_size;\n\t\ttu->qused--;\n\t\tspin_unlock_irq(&tu->qlock);\n\t\tmutex_lock(&tu->ioctl_lock);\n\t\tif (tu->tread) {\n\t\t\tif (copy_to_user(buffer, &tu->tqueue[qhead],\n\t\t\t\t\t sizeof(struct snd_timer_tread)))\n\t\t\t\terr = -EFAULT;\n\t\t} else {\n\t\t\tif (copy_to_user(buffer, &tu->queue[qhead],\n\t\t\t\t\t sizeof(struct snd_timer_read)))\n\t\t\t\terr = -EFAULT;\n\t\t}\n\t\tmutex_unlock(&tu->ioctl_lock);\n\t\tspin_lock_irq(&tu->qlock);\n\t\tif (err < 0)\n\t\t\tgoto _error;\n\t\tresult += unit;\n\t\tbuffer += unit;\n\t}\n _error:\n\tspin_unlock_irq(&tu->qlock);\n\treturn result > 0 ? result : err;\n}", "target": 1}
{"code": "static int mwifiex_pcie_init_evt_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct mwifiex_evt_buf_desc *desc;\n\tstruct sk_buff *skb;\n\tdma_addr_t buf_pa;\n\tint i;\n\tfor (i = 0; i < MWIFIEX_MAX_EVT_BD; i++) {\n\t\tskb = dev_alloc_skb(MAX_EVENT_SIZE);\n\t\tif (!skb) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Unable to allocate skb for EVENT buf.\\n\");\n\t\t\tkfree(card->evtbd_ring_vbase);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tskb_put(skb, MAX_EVENT_SIZE);\n\t\tif (mwifiex_map_pci_memory(adapter, skb, MAX_EVENT_SIZE,\n\t\t\t\t\t   PCI_DMA_FROMDEVICE))\n\t\t\treturn -1;\n\t\tbuf_pa = MWIFIEX_SKB_DMA_ADDR(skb);\n\t\tmwifiex_dbg(adapter, EVENT,\n\t\t\t    \"info: EVT ring: skb=%p len=%d data=%p buf_pa=%#x:%x\\n\",\n\t\t\t    skb, skb->len, skb->data, (u32)buf_pa,\n\t\t\t    (u32)((u64)buf_pa >> 32));\n\t\tcard->evt_buf_list[i] = skb;\n\t\tcard->evtbd_ring[i] = (void *)(card->evtbd_ring_vbase +\n\t\t\t\t      (sizeof(*desc) * i));\n\t\tdesc = card->evtbd_ring[i];\n\t\tdesc->paddr = buf_pa;\n\t\tdesc->len = (u16)skb->len;\n\t\tdesc->flags = 0;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "rndr_quote(struct buf *ob, const struct buf *text, void *opaque)\n{\n\tif (!text || !text->size)\n\t\treturn 0;\n\tBUFPUTSL(ob, \"<q>\");\n\tbufput(ob, text->data, text->size);\n\tBUFPUTSL(ob, \"</q>\");\n\treturn 1;\n}", "target": 1}
{"code": "atol8(const char *p, size_t char_cnt)\n{\n\tint64_t l;\n\tint digit;\n\tl = 0;\n\twhile (char_cnt-- > 0) {\n\t\tif (*p >= '0' && *p <= '7')\n\t\t\tdigit = *p - '0';\n\t\telse\n\t\t\tbreak;\n\t\tp++;\n\t\tl <<= 3;\n\t\tl |= digit;\n\t}\n\treturn (l);\n}", "target": 1}
{"code": "\tCxFile(void) { };", "target": 1}
{"code": "mp_obj_t mp_vfs_umount(mp_obj_t mnt_in) {\n    mp_vfs_mount_t *vfs = NULL;\n    size_t mnt_len;\n    const char *mnt_str = NULL;\n    if (mp_obj_is_str(mnt_in)) {\n        mnt_str = mp_obj_str_get_data(mnt_in, &mnt_len);\n    }\n    for (mp_vfs_mount_t **vfsp = &MP_STATE_VM(vfs_mount_table); *vfsp != NULL; vfsp = &(*vfsp)->next) {\n        if ((mnt_str != NULL && !memcmp(mnt_str, (*vfsp)->str, mnt_len + 1)) || (*vfsp)->obj == mnt_in) {\n            vfs = *vfsp;\n            *vfsp = (*vfsp)->next;\n            break;\n        }\n    }\n    if (vfs == NULL) {\n        mp_raise_OSError(MP_EINVAL);\n    }\n    if (MP_STATE_VM(vfs_cur) == vfs) {\n        MP_STATE_VM(vfs_cur) = MP_VFS_ROOT;\n    }\n    mp_vfs_proxy_call(vfs, MP_QSTR_umount, 0, NULL);\n    return mp_const_none;\n}", "target": 1}
{"code": "static void skcipher_sock_destruct(struct sock *sk)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tstruct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(&ctx->req);\n\tskcipher_free_sgl(sk);\n\tsock_kfree_s(sk, ctx->iv, crypto_ablkcipher_ivsize(tfm));\n\tsock_kfree_s(sk, ctx, ctx->len);\n\taf_alg_release_parent(sk);\n}", "target": 0}
{"code": "  static ::tensorflow::Status ValidateInputs(\n      std::vector<ConstFlatSplits> rt_nested_splits,\n      const Tensor& rt_dense_values_in) {\n    for (int i = 0; i < rt_nested_splits.size(); ++i) {\n      if (rt_nested_splits[i].size() == 0) {\n        return InvalidArgument(\"ragged splits may not be empty.\");\n      }\n      if (rt_nested_splits[i](0) != 0) {\n        return InvalidArgument(\"First value of ragged splits must be 0.\");\n      }\n      for (int j = 1; j < rt_nested_splits[i].size(); ++j) {\n        if (rt_nested_splits[i](j) < rt_nested_splits[i](j - 1)) {\n          return InvalidArgument(\n              \"Ragged splits should be non decreasing, but we got \",\n              rt_nested_splits[i](j - 1), \" followed by \",\n              rt_nested_splits[i](j));\n        }\n      }\n      if (i > 0) {\n        SPLITS_TYPE last_split =\n            rt_nested_splits[i - 1](rt_nested_splits[i - 1].size() - 1);\n        if (rt_nested_splits[i].size() != last_split + 1) {\n          return InvalidArgument(\n              \"Final value of ragged splits must match the length \"\n              \"the corresponding ragged values.\");\n        }\n      }\n    }\n    if (rt_dense_values_in.dim_size(0) !=\n        rt_nested_splits.back()(rt_nested_splits.back().size() - 1)) {\n      return InvalidArgument(\n          \"Final value of ragged splits must match the length \"\n          \"the corresponding ragged values.\");\n    }\n    return ::tensorflow::Status::OK();\n  }", "target": 0}
{"code": "int cap_bprm_set_creds(struct linux_binprm *bprm)\n{\n\tconst struct cred *old = current_cred();\n\tstruct cred *new = bprm->cred;\n\tbool effective, has_cap = false;\n\tint ret;\n\teffective = false;\n\tret = get_file_caps(bprm, &effective, &has_cap);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!issecure(SECURE_NOROOT)) {\n\t\tif (has_cap && new->uid != 0 && new->euid == 0) {\n\t\t\twarn_setuid_and_fcaps_mixed(bprm->filename);\n\t\t\tgoto skip;\n\t\t}\n\t\tif (new->euid == 0 || new->uid == 0) {\n\t\t\tnew->cap_permitted = cap_combine(old->cap_bset,\n\t\t\t\t\t\t\t old->cap_inheritable);\n\t\t}\n\t\tif (new->euid == 0)\n\t\t\teffective = true;\n\t}\nskip:\n\tif (!cap_issubset(new->cap_permitted, old->cap_permitted))\n\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\tif ((new->euid != old->uid ||\n\t     new->egid != old->gid ||\n\t     !cap_issubset(new->cap_permitted, old->cap_permitted)) &&\n\t    bprm->unsafe & ~LSM_UNSAFE_PTRACE_CAP) {\n\t\tif (!capable(CAP_SETUID)) {\n\t\t\tnew->euid = new->uid;\n\t\t\tnew->egid = new->gid;\n\t\t}\n\t\tnew->cap_permitted = cap_intersect(new->cap_permitted,\n\t\t\t\t\t\t   old->cap_permitted);\n\t}\n\tnew->suid = new->fsuid = new->euid;\n\tnew->sgid = new->fsgid = new->egid;\n\tif (effective)\n\t\tnew->cap_effective = new->cap_permitted;\n\telse\n\t\tcap_clear(new->cap_effective);\n\tbprm->cap_effective = effective;\n\tif (!cap_isclear(new->cap_effective)) {\n\t\tif (!cap_issubset(CAP_FULL_SET, new->cap_effective) ||\n\t\t    new->euid != 0 || new->uid != 0 ||\n\t\t    issecure(SECURE_NOROOT)) {\n\t\t\tret = audit_log_bprm_fcaps(bprm, new, old);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\tnew->securebits &= ~issecure_mask(SECURE_KEEP_CAPS);\n\treturn 0;\n}", "target": 0}
{"code": "static inline int pmd_none_or_trans_huge_or_clear_bad(pmd_t *pmd)\n{\n\tpmd_t pmdval = *pmd;\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tbarrier();\n#endif\n\tif (pmd_none(pmdval))\n\t\treturn 1;\n\tif (unlikely(pmd_bad(pmdval))) {\n\t\tif (!pmd_trans_huge(pmdval))\n\t\t\tpmd_clear_bad(pmd);\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void HeaderMapImpl::addViaMove(HeaderString&& key, HeaderString&& value) {\n  auto* entry = getExistingInline(key.getStringView());\n  if (entry != nullptr) {\n    appendToHeader(entry->value(), value.getStringView());\n    key.clear();\n    value.clear();\n  } else {\n    insertByKey(std::move(key), std::move(value));\n  }\n}", "target": 1}
{"code": "static int faultin_page(struct task_struct *tsk, struct vm_area_struct *vma,\n\t\tunsigned long address, unsigned int *flags, int *nonblocking)\n{\n\tunsigned int fault_flags = 0;\n\tint ret;\n\tif ((*flags & (FOLL_POPULATE | FOLL_MLOCK)) == FOLL_MLOCK)\n\t\treturn -ENOENT;\n\tif ((*flags & FOLL_POPULATE) &&\n\t\t\t(stack_guard_page_start(vma, address) ||\n\t\t\t stack_guard_page_end(vma, address + PAGE_SIZE)))\n\t\treturn -ENOENT;\n\tif (*flags & FOLL_WRITE)\n\t\tfault_flags |= FAULT_FLAG_WRITE;\n\tif (*flags & FOLL_REMOTE)\n\t\tfault_flags |= FAULT_FLAG_REMOTE;\n\tif (nonblocking)\n\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY;\n\tif (*flags & FOLL_NOWAIT)\n\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_RETRY_NOWAIT;\n\tif (*flags & FOLL_TRIED) {\n\t\tVM_WARN_ON_ONCE(fault_flags & FAULT_FLAG_ALLOW_RETRY);\n\t\tfault_flags |= FAULT_FLAG_TRIED;\n\t}\n\tret = handle_mm_fault(vma, address, fault_flags);\n\tif (ret & VM_FAULT_ERROR) {\n\t\tif (ret & VM_FAULT_OOM)\n\t\t\treturn -ENOMEM;\n\t\tif (ret & (VM_FAULT_HWPOISON | VM_FAULT_HWPOISON_LARGE))\n\t\t\treturn *flags & FOLL_HWPOISON ? -EHWPOISON : -EFAULT;\n\t\tif (ret & (VM_FAULT_SIGBUS | VM_FAULT_SIGSEGV))\n\t\t\treturn -EFAULT;\n\t\tBUG();\n\t}\n\tif (tsk) {\n\t\tif (ret & VM_FAULT_MAJOR)\n\t\t\ttsk->maj_flt++;\n\t\telse\n\t\t\ttsk->min_flt++;\n\t}\n\tif (ret & VM_FAULT_RETRY) {\n\t\tif (nonblocking)\n\t\t\t*nonblocking = 0;\n\t\treturn -EBUSY;\n\t}\n\tif ((ret & VM_FAULT_WRITE) && !(vma->vm_flags & VM_WRITE))\n\t\t*flags &= ~FOLL_WRITE;\n\treturn 0;\n}", "target": 1}
{"code": "int wcall_i_answer(struct wcall *wcall,\n\t\t   int call_type, int audio_cbr)\n{\n\tint err = 0;\n\tbool cbr = audio_cbr != 0;\n\tif (!wcall) {\n\t\twarning(\"wcall; answer: no wcall\\n\");\n\t\treturn EINVAL;\n\t}\n\tcall_type = (call_type == WCALL_CALL_TYPE_FORCED_AUDIO) ?\n\t\t    WCALL_CALL_TYPE_NORMAL : call_type;\n\tinfo(APITAG \"wcall(%p): answer calltype=%s\\n\",\n\t     wcall, wcall_call_type_name(call_type));\n\tif (wcall->disable_audio)\n\t\twcall->disable_audio = false;\n\tif (!wcall->icall) {\n\t\twarning(\"wcall(%p): answer: no call object found\\n\", wcall);\n\t\treturn ENOTSUP;\n\t}\n\tset_state(wcall, WCALL_STATE_ANSWERED);\n\tif (call_type == WCALL_CALL_TYPE_VIDEO) {\n\t\tICALL_CALL(wcall->icall,\n\t\t\t   set_video_send_state,\n\t\t\t   ICALL_VIDEO_STATE_STARTED);\n\t}\n\telse {\n\t\tICALL_CALL(wcall->icall,\n\t\t\t   set_video_send_state,\n\t\t\t   ICALL_VIDEO_STATE_STOPPED);\n\t}\n\terr = ICALL_CALLE(wcall->icall, answer,\n\t\t\t  call_type, cbr);\n\treturn err;\n}", "target": 1}
{"code": "AuthenticationFeature::AuthenticationFeature(application_features::ApplicationServer& server)\n    : ApplicationFeature(server, \"Authentication\"),\n      _userManager(nullptr),\n      _authCache(nullptr),\n      _authenticationUnixSockets(true),\n      _authenticationSystemOnly(true),\n      _localAuthentication(true),\n      _active(true),\n      _authenticationTimeout(0.0) {\n  setOptional(false);\n  startsAfter<application_features::BasicFeaturePhaseServer>();\n#ifdef USE_ENTERPRISE\n  startsAfter<LdapFeature>();\n#endif\n}", "target": 1}
{"code": "R_API int r_socket_read_block(RSocket *s, ut8 *buf, int len) {\n\tint ret = 0;\n\tfor (ret = 0; ret < len; ) {\n\t\tint r = r_socket_read (s, buf + ret, len - ret);\n\t\tif (r == -1) {\n#if HAVE_LIB_SSL\n\t\t\tif (SSL_get_error (s->sfd, r) == SSL_ERROR_WANT_READ) {\n\t\t\t\tif (r_socket_ready (s, 1, 0) == 1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\treturn -1;\n\t\t}\n\t\tif (r < 1) {\n\t\t\tbreak;\n\t\t}\n\t\tret += r;\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "\t__must_hold(&ctx->completion_lock)\n{\n\tu32 seq = ctx->cached_cq_tail - atomic_read(&ctx->cq_timeouts);\n\tspin_lock_irq(&ctx->timeout_lock);\n\twhile (!list_empty(&ctx->timeout_list)) {\n\t\tu32 events_needed, events_got;\n\t\tstruct io_kiocb *req = list_first_entry(&ctx->timeout_list,\n\t\t\t\t\t\tstruct io_kiocb, timeout.list);\n\t\tif (io_is_timeout_noseq(req))\n\t\t\tbreak;\n\t\tevents_needed = req->timeout.target_seq - ctx->cq_last_tm_flush;\n\t\tevents_got = seq - ctx->cq_last_tm_flush;\n\t\tif (events_got < events_needed)\n\t\t\tbreak;\n\t\tlist_del_init(&req->timeout.list);\n\t\tio_kill_timeout(req, 0);\n\t}\n\tctx->cq_last_tm_flush = seq;\n\tspin_unlock_irq(&ctx->timeout_lock);\n}", "target": 1}
{"code": "cib_handle_remote_msg(cib_client_t *client, xmlNode *command)\n{\n    const char *value = NULL;\n    value = crm_element_name(command);\n    if (safe_str_neq(value, \"cib_command\")) {\n        crm_log_xml_trace(command, \"Bad command: \");\n        return;\n    }\n    if (client->name == NULL) {\n        value = crm_element_value(command, F_CLIENTNAME);\n        if (value == NULL) {\n            client->name = strdup(client->id);\n        } else {\n            client->name = strdup(value);\n        }\n    }\n    if (client->callback_id == NULL) {\n        value = crm_element_value(command, F_CIB_CALLBACK_TOKEN);\n        if (value != NULL) {\n            client->callback_id = strdup(value);\n            crm_trace(\"Callback channel for %s is %s\", client->id, client->callback_id);\n        } else {\n            client->callback_id = strdup(client->id);\n        }\n    }\n    xml_remove_prop(command, F_ORIG);\n    xml_remove_prop(command, F_CIB_HOST);\n    xml_remove_prop(command, F_CIB_GLOBAL_UPDATE);\n    crm_xml_add(command, F_TYPE, T_CIB);\n    crm_xml_add(command, F_CIB_CLIENTID, client->id);\n    crm_xml_add(command, F_CIB_CLIENTNAME, client->name);\n#if ENABLE_ACL\n    crm_xml_add(command, F_CIB_USER, client->user);\n#endif\n    if (crm_element_value(command, F_CIB_CALLID) == NULL) {\n        char *call_uuid = crm_generate_uuid();\n        crm_xml_add(command, F_CIB_CALLID, call_uuid);\n        free(call_uuid);\n    }\n    if (crm_element_value(command, F_CIB_CALLOPTS) == NULL) {\n        crm_xml_add_int(command, F_CIB_CALLOPTS, 0);\n    }\n    crm_log_xml_trace(command, \"Remote command: \");\n    cib_common_callback_worker(0, 0, command, client, TRUE);\n}", "target": 0}
{"code": "static int nft_del_setelem(struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t   const struct nlattr *attr)\n{\n\tstruct nlattr *nla[NFTA_SET_ELEM_MAX + 1];\n\tstruct nft_data_desc desc;\n\tstruct nft_set_elem elem;\n\tstruct nft_trans *trans;\n\tint err;\n\terr = nla_parse_nested(nla, NFTA_SET_ELEM_MAX, attr,\n\t\t\t       nft_set_elem_policy);\n\tif (err < 0)\n\t\tgoto err1;\n\terr = -EINVAL;\n\tif (nla[NFTA_SET_ELEM_KEY] == NULL)\n\t\tgoto err1;\n\terr = nft_data_init(ctx, &elem.key, &desc, nla[NFTA_SET_ELEM_KEY]);\n\tif (err < 0)\n\t\tgoto err1;\n\terr = -EINVAL;\n\tif (desc.type != NFT_DATA_VALUE || desc.len != set->klen)\n\t\tgoto err2;\n\terr = set->ops->get(set, &elem);\n\tif (err < 0)\n\t\tgoto err2;\n\ttrans = nft_trans_elem_alloc(ctx, NFT_MSG_DELSETELEM, set);\n\tif (trans == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto err2;\n\t}\n\tnft_trans_elem(trans) = elem;\n\tlist_add_tail(&trans->list, &ctx->net->nft.commit_list);\n\treturn 0;\nerr2:\n\tnft_data_uninit(&elem.key, desc.type);\nerr1:\n\treturn err;\n}", "target": 0}
{"code": "snmp_ber_decode_oid(snmp_packet_t *snmp_packet, snmp_oid_t *oid)\n{\n  uint8_t *buf_end, type;\n  uint8_t len, j;\n  div_t first;\n  if(!snmp_ber_decode_type(snmp_packet, &type)) {\n    return 0;\n  }\n  if(type != BER_DATA_TYPE_OBJECT_IDENTIFIER) {\n    return 0;\n  }\n  if(!snmp_ber_decode_length(snmp_packet, &len)) {\n    return 0;\n  }\n  buf_end = snmp_packet->in + len;\n  if(snmp_packet->used == 0) {\n    return 0;\n  }\n  snmp_packet->used--;\n  first = div(*snmp_packet->in++, 40);\n  oid->length = 0;\n  oid->data[oid->length++] = (uint32_t)first.quot;\n  oid->data[oid->length++] = (uint32_t)first.rem;\n  while(snmp_packet->in != buf_end) {\n    if(oid->length >= SNMP_MSG_OID_MAX_LEN) {\n      return 0;\n    }\n    if(snmp_packet->used == 0) {\n      return 0;\n    }\n    oid->data[oid->length] = (uint32_t)(*snmp_packet->in & 0x7F);\n    for(j = 0; j < 4; j++) {\n      snmp_packet->used--;\n      if((*snmp_packet->in++ & 0x80) == 0) {\n        break;\n      }\n      if(snmp_packet->used == 0) {\n        return 0;\n      }\n      oid->data[oid->length] <<= 7;\n      oid->data[oid->length] |= (*snmp_packet->in & 0x7F);\n    }\n    oid->length++;\n  }\n  return 1;\n}", "target": 0}
{"code": "juniper_services_print(netdissect_options *ndo,\n                       const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n        struct juniper_services_header {\n            uint8_t svc_id;\n            uint8_t flags_len;\n            uint8_t svc_set_id[2];\n            uint8_t dir_iif[4];\n        };\n        const struct juniper_services_header *sh;\n        l2info.pictype = DLT_JUNIPER_SERVICES;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n        p+=l2info.header_len;\n        sh = (const struct juniper_services_header *)p;\n        ND_TCHECK(*sh);\n        if (ndo->ndo_eflag)\n            ND_PRINT((ndo, \"service-id %u flags 0x%02x service-set-id 0x%04x iif %u: \",\n                   sh->svc_id,\n                   sh->flags_len,\n                   EXTRACT_16BITS(&sh->svc_set_id),\n                   EXTRACT_24BITS(&sh->dir_iif[1])));\n        ip_heuristic_guess (ndo, p, l2info.length);\n        return l2info.header_len;\ntrunc:\n\tND_PRINT((ndo, \"[|juniper_services]\"));\n\treturn l2info.header_len;\n}", "target": 0}
{"code": "static struct sk_buff *tcp_sacktag_walk(struct sk_buff *skb, struct sock *sk,\n\t\t\t\t\tstruct tcp_sack_block *next_dup,\n\t\t\t\t\tstruct tcp_sacktag_state *state,\n\t\t\t\t\tu32 start_seq, u32 end_seq,\n\t\t\t\t\tint dup_sack_in)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct sk_buff *tmp;\n\ttcp_for_write_queue_from(skb, sk) {\n\t\tint in_sack = 0;\n\t\tint dup_sack = dup_sack_in;\n\t\tif (skb == tcp_send_head(sk))\n\t\t\tbreak;\n\t\tif (!before(TCP_SKB_CB(skb)->seq, end_seq))\n\t\t\tbreak;\n\t\tif ((next_dup != NULL) &&\n\t\t    before(TCP_SKB_CB(skb)->seq, next_dup->end_seq)) {\n\t\t\tin_sack = tcp_match_skb_to_sack(sk, skb,\n\t\t\t\t\t\t\tnext_dup->start_seq,\n\t\t\t\t\t\t\tnext_dup->end_seq);\n\t\t\tif (in_sack > 0)\n\t\t\t\tdup_sack = 1;\n\t\t}\n\t\tif (in_sack <= 0) {\n\t\t\ttmp = tcp_shift_skb_data(sk, skb, state,\n\t\t\t\t\t\t start_seq, end_seq, dup_sack);\n\t\t\tif (tmp != NULL) {\n\t\t\t\tif (tmp != skb) {\n\t\t\t\t\tskb = tmp;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tin_sack = 0;\n\t\t\t} else {\n\t\t\t\tin_sack = tcp_match_skb_to_sack(sk, skb,\n\t\t\t\t\t\t\t\tstart_seq,\n\t\t\t\t\t\t\t\tend_seq);\n\t\t\t}\n\t\t}\n\t\tif (unlikely(in_sack < 0))\n\t\t\tbreak;\n\t\tif (in_sack) {\n\t\t\tTCP_SKB_CB(skb)->sacked = tcp_sacktag_one(skb, sk,\n\t\t\t\t\t\t\t\t  state,\n\t\t\t\t\t\t\t\t  dup_sack,\n\t\t\t\t\t\t\t\t  tcp_skb_pcount(skb));\n\t\t\tif (!before(TCP_SKB_CB(skb)->seq,\n\t\t\t\t    tcp_highest_sack_seq(tp)))\n\t\t\t\ttcp_advance_highest_sack(sk, skb);\n\t\t}\n\t\tstate->fack_count += tcp_skb_pcount(skb);\n\t}\n\treturn skb;\n}", "target": 0}
{"code": "makeDirTree(const string &path, const StaticString &mode, uid_t owner, gid_t group) {\n\tstruct stat buf;\n\tvector<string> paths;\n\tvector<string>::reverse_iterator rit;\n\tstring current = path;\n\tmode_t modeBits;\n\tint ret;\n\tif (stat(path.c_str(), &buf) == 0) {\n\t\treturn;\n\t}\n\tmodeBits = parseModeString(mode);\n\twhile (current != \"/\" && current != \".\" && getFileType(current) == FT_NONEXISTANT) {\n\t\tpaths.push_back(current);\n\t\tcurrent = extractDirName(current);\n\t}\n\tfor (rit = paths.rbegin(); rit != paths.rend(); rit++) {\n\t\tcurrent = *rit;\n\t\tdo {\n\t\t\tret = mkdir(current.c_str(), modeBits);\n\t\t} while (ret == -1 && errno == EINTR);\n\t\tif (ret == -1) {\n\t\t\tif (errno == EEXIST) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tint e = errno;\n\t\t\t\tthrow FileSystemException(\"Cannot create directory '\" + current + \"'\",\n\t\t\t\t\te, current);\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tret = chmod(current.c_str(), modeBits);\n\t\t} while (ret == -1 && errno == EINTR);\n\t\tif (owner != USER_NOT_GIVEN && group != GROUP_NOT_GIVEN) {\n\t\t\tif (owner == USER_NOT_GIVEN) {\n\t\t\t\towner = (uid_t) -1; \n\t\t\t}\n\t\t\tif (group == GROUP_NOT_GIVEN) {\n\t\t\t\tgroup = (gid_t) -1; \n\t\t\t}\n\t\t\tdo {\n\t\t\t\tret = chown(current.c_str(), owner, group);\n\t\t\t} while (ret == -1 && errno == EINTR);\n\t\t\tif (ret == -1) {\n\t\t\t\tchar message[1024];\n\t\t\t\tint e = errno;\n\t\t\t\tsnprintf(message, sizeof(message) - 1,\n\t\t\t\t\t\"Cannot change the directory '%s' its UID to %lld and GID to %lld\",\n\t\t\t\t\tcurrent.c_str(), (long long) owner, (long long) group);\n\t\t\t\tmessage[sizeof(message) - 1] = '\\0';\n\t\t\t\tthrow FileSystemException(message, e, path);\n\t\t\t}\n\t\t}\n\t}\n}", "target": 0}
{"code": "static int override_release(char __user *release, int len)\n{\n\tint ret = 0;\n\tchar buf[65];\n\tif (current->personality & UNAME26) {\n\t\tchar *rest = UTS_RELEASE;\n\t\tint ndots = 0;\n\t\tunsigned v;\n\t\twhile (*rest) {\n\t\t\tif (*rest == '.' && ++ndots >= 3)\n\t\t\t\tbreak;\n\t\t\tif (!isdigit(*rest) && *rest != '.')\n\t\t\t\tbreak;\n\t\t\trest++;\n\t\t}\n\t\tv = ((LINUX_VERSION_CODE >> 8) & 0xff) + 40;\n\t\tsnprintf(buf, len, \"2.6.%u%s\", v, rest);\n\t\tret = copy_to_user(release, buf, len);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "GF_Err video_sample_entry_box_size(GF_Box *s)\n{\n\tGF_Box *b;\n\tu32 pos=0;\n\tGF_MPEGVisualSampleEntryBox *ptr = (GF_MPEGVisualSampleEntryBox *)s;\n\tgf_isom_video_sample_entry_size((GF_VisualSampleEntryBox *)s);\n\tgf_isom_check_position(s, (GF_Box *)ptr->esd, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_3gpp, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->avc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->svc_config, &pos);\n\tif (ptr->mvc_config) {\n\t\tgf_isom_check_position(s, gf_isom_box_find_child(s->child_boxes, GF_ISOM_BOX_TYPE_VWID), &pos);\n\t\tgf_isom_check_position(s, (GF_Box *)ptr->mvc_config, &pos);\n\t}\n\tgf_isom_check_position(s, (GF_Box *)ptr->hevc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->lhvc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->vvc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->av1_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->vp_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->jp2h, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->dovi_config, &pos);\n\tb = gf_isom_box_find_child(ptr->child_boxes, GF_ISOM_BOX_TYPE_ST3D);\n\tif (b) gf_isom_check_position(s, b, &pos);\n\tb = gf_isom_box_find_child(ptr->child_boxes, GF_ISOM_BOX_TYPE_SV3D);\n\tif (b) gf_isom_check_position(s, b, &pos);\n\treturn GF_OK;\n}", "target": 1}
{"code": "void watchdogSignalHandler(int sig, siginfo_t *info, void *secret) {\n#ifdef HAVE_BACKTRACE\n    ucontext_t *uc = (ucontext_t*) secret;\n#else\n    (void)secret;\n#endif\n    UNUSED(info);\n    UNUSED(sig);\n    serverLogFromHandler(LL_WARNING,\"\\n--- WATCHDOG TIMER EXPIRED ---\");\n#ifdef HAVE_BACKTRACE\n    logStackTrace(getMcontextEip(uc), 1);\n#else\n    serverLogFromHandler(LL_WARNING,\"Sorry: no support for backtrace().\");\n#endif\n    serverLogFromHandler(LL_WARNING,\"--------\\n\");\n}", "target": 1}
{"code": "isdn_ppp_poll(struct file *file, poll_table *wait)\n{\n\tu_int mask;\n\tstruct ippp_buf_queue *bf, *bl;\n\tu_long flags;\n\tstruct ippp_struct *is;\n\tis = file->private_data;\n\tif (is->debug & 0x2)\n\t\tprintk(KERN_DEBUG \"isdn_ppp_poll: minor: %d\\n\",\n\t\t       iminor(file_inode(file)));\n\tpoll_wait(file, &is->wq, wait);\n\tif (!(is->state & IPPP_OPEN)) {\n\t\tif (is->state == IPPP_CLOSEWAIT)\n\t\t\treturn POLLHUP;\n\t\tprintk(KERN_DEBUG \"isdn_ppp: device not open\\n\");\n\t\treturn POLLERR;\n\t}\n\tmask = POLLOUT | POLLWRNORM;\n\tspin_lock_irqsave(&is->buflock, flags);\n\tbl = is->last;\n\tbf = is->first;\n\tif (bf->next != bl || (is->state & IPPP_NOBLOCK)) {\n\t\tis->state &= ~IPPP_NOBLOCK;\n\t\tmask |= POLLIN | POLLRDNORM;\n\t}\n\tspin_unlock_irqrestore(&is->buflock, flags);\n\treturn mask;\n}", "target": 0}
{"code": "static int __init sit_init(void)\n{\n\tint err;\n\tprintk(KERN_INFO \"IPv6 over IPv4 tunneling driver\\n\");\n\tif (xfrm4_tunnel_register(&sit_handler, AF_INET6) < 0) {\n\t\tprintk(KERN_INFO \"sit init: Can't add protocol\\n\");\n\t\treturn -EAGAIN;\n\t}\n\terr = register_pernet_device(&sit_net_ops);\n\tif (err < 0)\n\t\txfrm4_tunnel_deregister(&sit_handler, AF_INET6);\n\treturn err;\n}", "target": 1}
{"code": "\tPong(const std::string& cookie, const std::string& server = \"\")\n\t\t: ClientProtocol::Message(\"PONG\", ServerInstance->Config->GetServerName())\n\t{\n\t\tPushParamRef(ServerInstance->Config->GetServerName());\n\t\tif (!server.empty())\n\t\t\tPushParamRef(server);\n\t\tPushParamRef(cookie);\n\t}", "target": 1}
{"code": "static int copy_to_user_tmpl(struct xfrm_policy *xp, struct sk_buff *skb)\n{\n\tstruct xfrm_user_tmpl vec[XFRM_MAX_DEPTH];\n\tint i;\n\tif (xp->xfrm_nr == 0)\n\t\treturn 0;\n\tfor (i = 0; i < xp->xfrm_nr; i++) {\n\t\tstruct xfrm_user_tmpl *up = &vec[i];\n\t\tstruct xfrm_tmpl *kp = &xp->xfrm_vec[i];\n\t\tmemset(up, 0, sizeof(*up));\n\t\tmemcpy(&up->id, &kp->id, sizeof(up->id));\n\t\tup->family = kp->encap_family;\n\t\tmemcpy(&up->saddr, &kp->saddr, sizeof(up->saddr));\n\t\tup->reqid = kp->reqid;\n\t\tup->mode = kp->mode;\n\t\tup->share = kp->share;\n\t\tup->optional = kp->optional;\n\t\tup->aalgos = kp->aalgos;\n\t\tup->ealgos = kp->ealgos;\n\t\tup->calgos = kp->calgos;\n\t}\n\treturn nla_put(skb, XFRMA_TMPL,\n\t\t       sizeof(struct xfrm_user_tmpl) * xp->xfrm_nr, vec);\n}", "target": 0}
{"code": "static request_rec *my_ap_create_request(conn_rec *c)\n{\n    apr_pool_t *p;\n    request_rec *r;\n    apr_pool_create(&p, c->pool);\n    apr_pool_tag(p, \"request\");\n    r = apr_pcalloc(p, sizeof(request_rec));\n    AP_READ_REQUEST_ENTRY((intptr_t)r, (uintptr_t)c);\n    r->pool            = p;\n    r->connection      = c;\n    r->server          = c->base_server;\n    r->user            = NULL;\n    r->ap_auth_type    = NULL;\n    r->allowed_methods = ap_make_method_list(p, 2);\n    r->headers_in      = apr_table_make(r->pool, 5);\n    r->trailers_in     = apr_table_make(r->pool, 5);\n    r->subprocess_env  = apr_table_make(r->pool, 25);\n    r->headers_out     = apr_table_make(r->pool, 12);\n    r->err_headers_out = apr_table_make(r->pool, 5);\n    r->trailers_out    = apr_table_make(r->pool, 5);\n    r->notes           = apr_table_make(r->pool, 5);\n    r->request_config  = ap_create_request_config(r->pool);\n    r->proto_output_filters = c->output_filters;\n    r->output_filters  = r->proto_output_filters;\n    r->proto_input_filters = c->input_filters;\n    r->input_filters   = r->proto_input_filters;\n    ap_run_create_request(r);\n    r->per_dir_config  = r->server->lookup_defaults;\n    r->sent_bodyct     = 0;                      \n    r->read_length     = 0;\n    r->read_body       = REQUEST_NO_BODY;\n    r->status          = HTTP_OK;  \n    r->header_only     = 0;\n    r->the_request     = NULL;\n    r->used_path_info = AP_REQ_DEFAULT_PATH_INFO;\n    r->useragent_addr = c->client_addr;\n    r->useragent_ip = c->client_ip;\n    return r;\n}", "target": 1}
{"code": "void Filter::onUpstreamEvent(Network::ConnectionEvent event) {\n  bool connecting = connecting_;\n  connecting_ = false;\n  if (event == Network::ConnectionEvent::RemoteClose ||\n      event == Network::ConnectionEvent::LocalClose) {\n    upstream_.reset();\n    disableIdleTimer();\n    if (connecting) {\n      if (event == Network::ConnectionEvent::RemoteClose) {\n        getStreamInfo().setResponseFlag(StreamInfo::ResponseFlag::UpstreamConnectionFailure);\n        read_callbacks_->upstreamHost()->outlierDetector().putResult(\n            Upstream::Outlier::Result::LocalOriginConnectFailed);\n      }\n      initializeUpstreamConnection();\n    } else {\n      if (read_callbacks_->connection().state() == Network::Connection::State::Open) {\n        read_callbacks_->connection().close(Network::ConnectionCloseType::FlushWrite);\n      }\n    }\n  }\n}", "target": 1}
{"code": "static int perf_release(struct inode *inode, struct file *file)\n{\n\tput_event(file->private_data);\n\treturn 0;\n}", "target": 0}
{"code": "int DH_set0_pqg(DH *dh, BIGNUM *p, BIGNUM *q, BIGNUM *g) {\n    if(!p || !g) \n        return 0;\n    BN_free(dh->p);\n    BN_free(dh->q);\n    BN_free(dh->g);\n    dh->p = p;\n    dh->q = q;\n    dh->g = g;\n    if(q)\n        dh->length = BN_num_bits(q);\n    return 1;\n}", "target": 1}
{"code": "int sanity_check_ckpt(struct f2fs_sb_info *sbi)\n{\n\tunsigned int total, fsmeta;\n\tstruct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tunsigned int ovp_segments, reserved_segments;\n\tunsigned int main_segs, blocks_per_seg;\n\tint i;\n\ttotal = le32_to_cpu(raw_super->segment_count);\n\tfsmeta = le32_to_cpu(raw_super->segment_count_ckpt);\n\tfsmeta += le32_to_cpu(raw_super->segment_count_sit);\n\tfsmeta += le32_to_cpu(raw_super->segment_count_nat);\n\tfsmeta += le32_to_cpu(ckpt->rsvd_segment_count);\n\tfsmeta += le32_to_cpu(raw_super->segment_count_ssa);\n\tif (unlikely(fsmeta >= total))\n\t\treturn 1;\n\tovp_segments = le32_to_cpu(ckpt->overprov_segment_count);\n\treserved_segments = le32_to_cpu(ckpt->rsvd_segment_count);\n\tif (unlikely(fsmeta < F2FS_MIN_SEGMENTS ||\n\t\t\tovp_segments == 0 || reserved_segments == 0)) {\n\t\tf2fs_msg(sbi->sb, KERN_ERR,\n\t\t\t\"Wrong layout: check mkfs.f2fs version\");\n\t\treturn 1;\n\t}\n\tmain_segs = le32_to_cpu(raw_super->segment_count_main);\n\tblocks_per_seg = sbi->blocks_per_seg;\n\tfor (i = 0; i < NR_CURSEG_NODE_TYPE; i++) {\n\t\tif (le32_to_cpu(ckpt->cur_node_segno[i]) >= main_segs ||\n\t\t\tle16_to_cpu(ckpt->cur_node_blkoff[i]) >= blocks_per_seg)\n\t\t\treturn 1;\n\t}\n\tfor (i = 0; i < NR_CURSEG_DATA_TYPE; i++) {\n\t\tif (le32_to_cpu(ckpt->cur_data_segno[i]) >= main_segs ||\n\t\t\tle16_to_cpu(ckpt->cur_data_blkoff[i]) >= blocks_per_seg)\n\t\t\treturn 1;\n\t}\n\tif (unlikely(f2fs_cp_error(sbi))) {\n\t\tf2fs_msg(sbi->sb, KERN_ERR, \"A bug case: need to run fsck\");\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static void CorrectPhaseLHS(const size_t width,const size_t height,\n  double *fourier_pixels)\n{\n  register ssize_t\n    x;\n  ssize_t\n    y;\n  for (y=0L; y < (ssize_t) height; y++)\n    for (x=0L; x < (ssize_t) (width/2L); x++)\n      fourier_pixels[y*width+x]*=(-1.0);\n}", "target": 0}
{"code": "TEST(NNOpsTest, FractionalPool_ShapeFn) {\n  for (const char* op_name : {\"FractionalAvgPool\", \"FractionalMaxPool\"}) {\n    ShapeInferenceTestOp op(op_name);\n    auto set_op = [&op, op_name](const std::vector<float>& pooling_ratio) {\n      TF_ASSERT_OK(NodeDefBuilder(\"test\", op_name)\n                       .Input(\"input\", 0, DT_FLOAT)\n                       .Attr(\"pooling_ratio\", pooling_ratio)\n                       .Finalize(&op.node_def));\n    };\n    set_op(std::vector<float>{2.0f, 1, 1 / 1.5f, 1 / 2.0f});\n    INFER_ERROR(\"must be rank 4\", op, \"[?,?,?]\");\n    INFER_OK(op, \"?\", \"[?,?,?,?];[?];[?]\");\n    INFER_OK(op, \"[?,?,?,?]\", \"[?,?,?,?];[?];[?]\");\n    INFER_OK(op, \"[10,20,30,40]\", \"[5,20,45,80];[20];[45]\");\n    INFER_OK(op, \"[?,20,30,40]\", \"[?,20,45,80];[20];[45]\");\n    INFER_OK(op, \"[10,?,30,40]\", \"[5,?,45,80];[?];[45]\");\n    INFER_OK(op, \"[10,20,?,40]\", \"[5,20,?,80];[20];[?]\");\n    INFER_OK(op, \"[10,20,30,?]\", \"[5,20,45,?];[20];[45]\");\n    set_op(std::vector<float>{.5, 1.0, 1.5});\n    INFER_ERROR(\"pooling_ratio field\", op, \"?\");\n    set_op(std::vector<float>{1, 2, 3, 4, 5});\n    INFER_ERROR(\"pooling_ratio field\", op, \"?\");\n    set_op(std::vector<float>{-1, 2, 3, 4});\n    INFER_ERROR(\"is negative\", op, \"[1,2,3,4]\");\n  }\n}", "target": 1}
{"code": "init_rc(void)\n{\n    int i;\n    struct stat st;\n    FILE *f;\n    if (rc_dir != NULL)\n\tgoto open_rc;\n    rc_dir = expandPath(RC_DIR);\n    i = strlen(rc_dir);\n    if (i > 1 && rc_dir[i - 1] == '/')\n\trc_dir[i - 1] = '\\0';\n#ifdef USE_M17N\n    display_charset_str = wc_get_ces_list();\n    document_charset_str = display_charset_str;\n    system_charset_str = display_charset_str;\n#endif\n    if (stat(rc_dir, &st) < 0) {\n\tif (errno == ENOENT) {\t\n\t    if (do_mkdir(rc_dir, 0700) < 0) {\n\t\tgoto rc_dir_err;\n\t    }\n\t    else {\n\t\tstat(rc_dir, &st);\n\t    }\n\t}\n\telse {\n\t    goto rc_dir_err;\n\t}\n    }\n    if (!S_ISDIR(st.st_mode)) {\n\tgoto rc_dir_err;\n    }\n    if (!(st.st_mode & S_IWUSR)) {\n\tgoto rc_dir_err;\n    }\n    no_rc_dir = FALSE;\n    tmp_dir = rc_dir;\n    if (config_file == NULL)\n\tconfig_file = rcFile(CONFIG_FILE);\n    create_option_search_table();\n  open_rc:\n    if ((f = fopen(etcFile(W3MCONFIG), \"rt\")) != NULL) {\n\tinterpret_rc(f);\n\tfclose(f);\n    }\n    if ((f = fopen(confFile(CONFIG_FILE), \"rt\")) != NULL) {\n\tinterpret_rc(f);\n\tfclose(f);\n    }\n    if (config_file && (f = fopen(config_file, \"rt\")) != NULL) {\n\tinterpret_rc(f);\n\tfclose(f);\n    }\n    return;\n  rc_dir_err:\n    no_rc_dir = TRUE;\n    if (((tmp_dir = getenv(\"TMPDIR\")) == NULL || *tmp_dir == '\\0') &&\n\t((tmp_dir = getenv(\"TMP\")) == NULL || *tmp_dir == '\\0') &&\n\t((tmp_dir = getenv(\"TEMP\")) == NULL || *tmp_dir == '\\0'))\n\ttmp_dir = \"/tmp\";\n#ifdef HAVE_MKDTEMP\n    tmp_dir = mkdtemp(Strnew_m_charp(tmp_dir, \"/w3m-XXXXXX\", NULL)->ptr);\n    if (tmp_dir == NULL)\n\ttmp_dir = rc_dir;\n#endif\n    create_option_search_table();\n    goto open_rc;\n}", "target": 0}
{"code": "fs::path TranslatePath(const std::string& utf8_url_path) {\n#if (defined(_WIN32) || defined(_WIN64))\n  std::wstring url_path = Utf8To16(utf8_url_path);\n  std::vector<std::wstring> words;\n  boost::split(words, url_path, boost::is_any_of(L\"/\"),\n               boost::token_compress_on);\n#else\n  std::vector<std::string> words;\n  boost::split(words, utf8_url_path, boost::is_any_of(\"/\"),\n               boost::token_compress_on);\n#endif  \n  fs::path path;\n  for (auto& word : words) {\n#if (defined(_WIN32) || defined(_WIN64))\n    if (word == L\".\" || word == L\"..\") {\n#else\n    if (word == \".\" || word == \"..\") {\n#endif\n      continue;\n    }\n    fs::path p{ word };\n    if (!p.parent_path().empty()) {\n      continue;\n    }\n    path /= p;\n  }\n  return path;\n}\n}  ", "target": 0}
{"code": "cssp_encode_tspasswordcreds(char *username, char *password, char *domain)\n{\n\tSTREAM out, h1, h2;\n\tstruct stream tmp = { 0 };\n\tstruct stream message = { 0 };\n\tmemset(&tmp, 0, sizeof(tmp));\n\tmemset(&message, 0, sizeof(message));\n\ts_realloc(&tmp, 4 + strlen(domain) * sizeof(uint16));\n\ts_reset(&tmp);\n\trdp_out_unistr(&tmp, domain, strlen(domain) * sizeof(uint16));\n\ts_mark_end(&tmp);\n\th2 = ber_wrap_hdr_data(BER_TAG_OCTET_STRING, &tmp);\n\th1 = ber_wrap_hdr_data(BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0, h2);\n\ts_realloc(&message, s_length(&message) + s_length(h1));\n\tout_uint8p(&message, h1->data, s_length(h1));\n\ts_mark_end(&message);\n\ts_free(h2);\n\ts_free(h1);\n\ts_realloc(&tmp, 4 + strlen(username) * sizeof(uint16));\n\ts_reset(&tmp);\n\trdp_out_unistr(&tmp, username, strlen(username) * sizeof(uint16));\n\ts_mark_end(&tmp);\n\th2 = ber_wrap_hdr_data(BER_TAG_OCTET_STRING, &tmp);\n\th1 = ber_wrap_hdr_data(BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 1, h2);\n\ts_realloc(&message, s_length(&message) + s_length(h1));\n\tout_uint8p(&message, h1->data, s_length(h1));\n\ts_mark_end(&message);\n\ts_free(h2);\n\ts_free(h1);\n\ts_realloc(&tmp, 4 + strlen(password) * sizeof(uint16));\n\ts_reset(&tmp);\n\trdp_out_unistr(&tmp, password, strlen(password) * sizeof(uint16));\n\ts_mark_end(&tmp);\n\th2 = ber_wrap_hdr_data(BER_TAG_OCTET_STRING, &tmp);\n\th1 = ber_wrap_hdr_data(BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 2, h2);\n\ts_realloc(&message, s_length(&message) + s_length(h1));\n\tout_uint8p(&message, h1->data, s_length(h1));\n\ts_mark_end(&message);\n\ts_free(h2);\n\ts_free(h1);\n\tout = ber_wrap_hdr_data(BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED, &message);\n\txfree(tmp.data);\n\txfree(message.data);\n\treturn out;\n}", "target": 0}
{"code": "std::string ExpandFilePath(const std::string &filepath, void *) {\n  return filepath;\n#if 0\n#ifdef _WIN32\n  std::wstring wfilepath = UTF8ToWchar(filepath);\n  DWORD wlen = ExpandEnvironmentStringsW(wfilepath.c_str(), nullptr, 0);\n  wchar_t *wstr = new wchar_t[wlen];\n  ExpandEnvironmentStringsW(wfilepath.c_str(), wstr, wlen);\n  std::wstring ws(wstr);\n  delete[] wstr;\n  return WcharToUTF8(ws);\n#else\n#if defined(TARGET_OS_IPHONE) || defined(TARGET_IPHONE_SIMULATOR) || \\\n    defined(__ANDROID__) || defined(__EMSCRIPTEN__) || defined(__OpenBSD__)\n  std::string s = filepath;\n#else\n  std::string s;\n  wordexp_t p;\n  if (filepath.empty()) {\n    return \"\";\n  }\n  std::string quoted_path = \"\\\"\" + filepath + \"\\\"\";\n  int ret = wordexp(quoted_path.c_str(), &p, 0);\n  if (ret) {\n    s = filepath;\n    return s;\n  }\n  if (p.we_wordv) {\n    s = std::string(p.we_wordv[0]);\n    wordfree(&p);\n  } else {\n    s = filepath;\n  }\n#endif\n  return s;\n#endif\n#endif\n}", "target": 0}
{"code": "void msetGenericCommand(client *c, int nx) {\n    int j;\n    int setkey_flags = 0;\n    if ((c->argc % 2) == 0) {\n        addReplyErrorArity(c);\n        return;\n    }\n    if (nx) {\n        for (j = 1; j < c->argc; j += 2) {\n            if (lookupKeyWrite(c->db,c->argv[j]) != NULL) {\n                addReply(c, shared.czero);\n                return;\n            }\n        }\n        setkey_flags |= SETKEY_DOESNT_EXIST;\n    }\n    for (j = 1; j < c->argc; j += 2) {\n        c->argv[j+1] = tryObjectEncoding(c->argv[j+1]);\n        setKey(c, c->db, c->argv[j], c->argv[j + 1], setkey_flags);\n        notifyKeyspaceEvent(NOTIFY_STRING,\"set\",c->argv[j],c->db->id);\n    }\n    server.dirty += (c->argc-1)/2;\n    addReply(c, nx ? shared.cone : shared.ok);\n}", "target": 1}
{"code": "AP_DECLARE(void) ap_update_vhost_from_headers(request_rec *r)\n{\n    core_server_config *conf = ap_get_core_module_config(r->server->module_config);\n    const char *host_header = apr_table_get(r->headers_in, \"Host\");\n    int is_v6literal = 0;\n    int have_hostname_from_url = 0;\n    if (r->hostname) {\n        have_hostname_from_url = 1;\n        is_v6literal = fix_hostname(r, NULL, conf->http_conformance);\n    }\n    else if (host_header != NULL) {\n        is_v6literal = fix_hostname(r, host_header, conf->http_conformance);\n    }\n    if (r->status != HTTP_OK)\n        return;\n    if (conf->http_conformance != AP_HTTP_CONFORMANCE_UNSAFE) {\n        if (have_hostname_from_url && host_header != NULL) {\n            const char *repl = construct_host_header(r, is_v6literal);\n            apr_table_setn(r->headers_in, \"Host\", repl);\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02417)\n                          \"Replacing host header '%s' with host '%s' given \"\n                          \"in the request uri\", host_header, repl);\n        }\n    }\n    if (r->connection->vhost_lookup_data) {\n        if (r->hostname)\n            check_hostalias(r);\n        else\n            check_serverpath(r);\n    }\n}", "target": 1}
{"code": "static void simple_decode_row(x3f_info_t *I, x3f_directory_entry_t *DE,\n                              int bits, int row, int row_stride)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n  x3f_huffman_t *HUF = ID->huffman;\n  if (row*row_stride > ID->data_size - (ID->columns*sizeof(uint32_t)))\n\t  throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  uint32_t *data = (uint32_t *)((unsigned char *)ID->data + row * row_stride);\n  uint16_t c[3] = {0, 0, 0};\n  int col;\n  uint32_t mask = 0;\n  switch (bits)\n  {\n  case 8:\n    mask = 0x0ff;\n    break;\n  case 9:\n    mask = 0x1ff;\n    break;\n  case 10:\n    mask = 0x3ff;\n    break;\n  case 11:\n    mask = 0x7ff;\n    break;\n  case 12:\n    mask = 0xfff;\n    break;\n  default:\n    mask = 0;\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n    break;\n  }\n  for (col = 0; col < ID->columns; col++)\n  {\n    int color;\n    uint32_t val = data[col];\n    for (color = 0; color < 3; color++)\n    {\n      uint16_t c_fix;\n      c[color] += get_simple_diff(HUF, (val >> (color * bits)) & mask);\n      switch (ID->type_format)\n      {\n      case X3F_IMAGE_RAW_HUFFMAN_X530:\n      case X3F_IMAGE_RAW_HUFFMAN_10BIT:\n        c_fix = (int16_t)c[color] > 0 ? c[color] : 0;\n        HUF->x3rgb16.data[3 * (row * ID->columns + col) + color] = c_fix;\n        break;\n      case X3F_IMAGE_THUMB_HUFFMAN:\n        c_fix = (int8_t)c[color] > 0 ? c[color] : 0;\n        HUF->rgb8.data[3 * (row * ID->columns + col) + color] = c_fix;\n        break;\n      default:\n        throw LIBRAW_EXCEPTION_IO_CORRUPT;\n      }\n    }\n  }\n}", "target": 0}
{"code": "static int nfs_can_extend_write(struct file *file, struct page *page, struct inode *inode)\n{\n\tif (file->f_flags & O_DSYNC)\n\t\treturn 0;\n\tif (NFS_PROTO(inode)->have_delegation(inode, FMODE_WRITE))\n\t\treturn 1;\n\tif (nfs_write_pageuptodate(page, inode) && (inode->i_flock == NULL ||\n\t\t\t(inode->i_flock->fl_start == 0 &&\n\t\t\tinode->i_flock->fl_end == OFFSET_MAX &&\n\t\t\tinode->i_flock->fl_type != F_RDLCK)))\n\t\treturn 1;\n\treturn 0;\n}", "target": 1}
{"code": "int URI_FUNC(ComposeQueryEngine)(URI_CHAR * dest,\n\t\tconst URI_TYPE(QueryList) * queryList,\n\t\tint maxChars, int * charsWritten, int * charsRequired,\n\t\tUriBool spaceToPlus, UriBool normalizeBreaks) {\n\tUriBool firstItem = URI_TRUE;\n\tint ampersandLen = 0;  \n\tURI_CHAR * write = dest;\n\tif (dest == NULL) {\n\t\t*charsRequired = 0;\n\t} else {\n\t\tmaxChars--;\n\t}\n\twhile (queryList != NULL) {\n\t\tconst URI_CHAR * const key = queryList->key;\n\t\tconst URI_CHAR * const value = queryList->value;\n\t\tconst int worstCase = (normalizeBreaks == URI_TRUE ? 6 : 3);\n\t\tconst int keyLen = (key == NULL) ? 0 : (int)URI_STRLEN(key);\n\t\tconst int keyRequiredChars = worstCase * keyLen;\n\t\tconst int valueLen = (value == NULL) ? 0 : (int)URI_STRLEN(value);\n\t\tconst int valueRequiredChars = worstCase * valueLen;\n\t\tif (dest == NULL) {\n\t\t\t(*charsRequired) += ampersandLen + keyRequiredChars + ((value == NULL)\n\t\t\t\t\t\t? 0\n\t\t\t\t\t\t: 1 + valueRequiredChars);\n\t\t\tif (firstItem == URI_TRUE) {\n\t\t\t\tampersandLen = 1;\n\t\t\t\tfirstItem = URI_FALSE;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((write - dest) + ampersandLen + keyRequiredChars > maxChars) {\n\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t}\n\t\t\tif (firstItem == URI_TRUE) {\n\t\t\t\tampersandLen = 1;\n\t\t\t\tfirstItem = URI_FALSE;\n\t\t\t} else {\n\t\t\t\twrite[0] = _UT('&');\n\t\t\t\twrite++;\n\t\t\t}\n\t\t\twrite = URI_FUNC(EscapeEx)(key, key + keyLen,\n\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\t\t\tif (value != NULL) {\n\t\t\t\tif ((write - dest) + 1 + valueRequiredChars > maxChars) {\n\t\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t\t}\n\t\t\t\twrite[0] = _UT('=');\n\t\t\t\twrite++;\n\t\t\t\twrite = URI_FUNC(EscapeEx)(value, value + valueLen,\n\t\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\t\t\t}\n\t\t}\n\t\tqueryList = queryList->next;\n\t}\n\tif (dest != NULL) {\n\t\twrite[0] = _UT('\\0');\n\t\tif (charsWritten != NULL) {\n\t\t\t*charsWritten = (int)(write - dest) + 1; \n\t\t}\n\t}\n\treturn URI_SUCCESS;\n}", "target": 1}
{"code": "static inline int init_new_context(struct task_struct *tsk,\n\t\t\t\t   struct mm_struct *mm)\n{\n\tcpumask_clear(&mm->context.cpu_attach_mask);\n\tatomic_set(&mm->context.attach_count, 0);\n\tmm->context.flush_mm = 0;\n\tmm->context.asce_bits = _ASCE_TABLE_LENGTH | _ASCE_USER_BITS;\n\tmm->context.asce_bits |= _ASCE_TYPE_REGION3;\n#ifdef CONFIG_PGSTE\n\tmm->context.alloc_pgste = page_table_allocate_pgste;\n\tmm->context.has_pgste = 0;\n\tmm->context.use_skey = 0;\n#endif\n\tmm->context.asce_limit = STACK_TOP_MAX;\n\tcrst_table_init((unsigned long *) mm->pgd, pgd_entry_type(mm));\n\treturn 0;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input_tensor = context->input(0);\n    const auto input_tensor_flat = input_tensor.flat<int32>();\n    const Tensor& input_splits = context->input(1);\n    const auto input_splits_flat = input_splits.flat<SPLITS_TYPE>();\n    OP_REQUIRES(\n        context, input_splits.NumElements() > 0,\n        errors::InvalidArgument(\"Input_splits should contain elements, but \"\n                                \"given input_values has 0 elements\"));\n    OP_REQUIRES(\n        context, input_splits_flat(0) == 0,\n        errors::InvalidArgument(\"First value in input_splits must be zero.\"));\n    OP_REQUIRES(context,\n                input_splits_flat(input_splits_flat.size() - 1) ==\n                    input_tensor_flat.size(),\n                errors::InvalidArgument(\"Last value in input_splits must be \"\n                                        \"equal to length of input_tensor.\"));\n    TensorShape output_shape({input_splits.dim_size(0) - 1});\n    Tensor* output_tensor;\n    OP_REQUIRES_OK(context, context->allocate_output(\"output\", output_shape,\n                                                     &output_tensor));\n    auto output_tensor_flat = output_tensor->flat<tstring>();\n    int idx = 0;\n    for (int i = 1; i < input_splits_flat.size(); ++i) {\n      icu::UnicodeString unicode_string;\n      icu::UnicodeStringAppendable appendable_unicode_string(unicode_string);\n      OP_REQUIRES(\n          context, input_splits_flat(i - 1) <= input_splits_flat(i),\n          errors::InvalidArgument(\n              \"Values in input_splits must be equal or in ascending order.\"));\n      OP_REQUIRES(\n          context, input_splits_flat(i) <= input_tensor_flat.size(),\n          errors::InvalidArgument(\"Values in input_splits must be less than or \"\n                                  \"equal to input_tensor length.\"));\n      for (; idx < input_splits_flat(i); ++idx) {\n        int32_t code_point = input_tensor_flat(idx);\n        if (!U_IS_UNICODE_CHAR(code_point)) {\n          if (error_options_.error_on_malformatting) {\n            context->CtxFailure(errors::InvalidArgument(\n                \"Code point is out of range for Unicode, or a noncharacter.\"));\n            return;\n          } else if (!error_options_.elide_replacement) {\n            code_point = error_options_.subst;\n          }\n        }\n        appendable_unicode_string.appendCodePoint(code_point);\n      }\n      tstring result;\n      Encode(encoding_, unicode_string, &result);\n      output_tensor_flat(i - 1) = std::move(result);\n    }\n  }", "target": 0}
{"code": "static bool tailmatch(const char *little, const char *bigone)\n{\n  size_t littlelen = strlen(little);\n  size_t biglen = strlen(bigone);\n  if(littlelen > biglen)\n    return FALSE;\n  return Curl_raw_equal(little, bigone+biglen-littlelen) ? TRUE : FALSE;\n}", "target": 1}
{"code": "static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)\n{\n\tgit_pkt *pkt;\n\tconst char *line, *line_end = NULL;\n\tsize_t line_len;\n\tint error;\n\tint reading_from_buf = data_pkt_buf->size > 0;\n\tif (reading_from_buf) {\n\t\tgit_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);\n\t\tline = data_pkt_buf->ptr;\n\t\tline_len = data_pkt_buf->size;\n\t}\n\telse {\n\t\tline = data_pkt->data;\n\t\tline_len = data_pkt->len;\n\t}\n\twhile (line_len > 0) {\n\t\terror = git_pkt_parse_line(&pkt, line, &line_end, line_len);\n\t\tif (error == GIT_EBUFS) {\n\t\t\tif (!reading_from_buf)\n\t\t\t\tgit_buf_put(data_pkt_buf, line, line_len);\n\t\t\terror = 0;\n\t\t\tgoto done;\n\t\t}\n\t\telse if (error < 0)\n\t\t\tgoto done;\n\t\tline_len -= (line_end - line);\n\t\tline = line_end;\n\t\tif (pkt == NULL)\n\t\t\tcontinue;\n\t\terror = add_push_report_pkt(push, pkt);\n\t\tgit_pkt_free(pkt);\n\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\tgoto done;\n\t}\n\terror = 0;\ndone:\n\tif (reading_from_buf)\n\t\tgit_buf_consume(data_pkt_buf, line_end);\n\treturn error;\n}", "target": 1}
{"code": "  void whenInputIs(const char *json, size_t len) {\n    memcpy(_jsonString, json, len);\n    _result = QuotedString::extractFrom(_jsonString, &_trailing);\n  }", "target": 0}
{"code": "static int put_chars(u32 vtermno, const char *buf, int count)\n{\n\tstruct port *port;\n\tstruct scatterlist sg[1];\n\tif (unlikely(early_put_chars))\n\t\treturn early_put_chars(vtermno, buf, count);\n\tport = find_port_by_vtermno(vtermno);\n\tif (!port)\n\t\treturn -EPIPE;\n\tsg_init_one(sg, buf, count);\n\treturn __send_to_port(port, sg, 1, count, (void *)buf, false);\n}", "target": 1}
{"code": "cleanup_pathname_fsobj(char *path, int *error_number, struct archive_string *error_string, int flags)\n{\n\tchar *dest, *src;\n\tchar separator = '\\0';\n\tdest = src = path;\n\tif (*src == '\\0') {\n\t\tif (error_number) *error_number = ARCHIVE_ERRNO_MISC;\n\t\tif (error_string)\n\t\t    archive_string_sprintf(error_string,\n\t\t\t    \"Invalid empty pathname\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n#if defined(__CYGWIN__)\n\tcleanup_pathname_win(a);\n#endif\n\tif (*src == '/') {\n\t\tif (flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {\n\t\t\tif (error_number) *error_number = ARCHIVE_ERRNO_MISC;\n\t\t\tif (error_string)\n\t\t\t    archive_string_sprintf(error_string,\n\t\t\t\t    \"Path is absolute\");\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\t\tseparator = *src++;\n\t}\n\tfor (;;) {\n\t\tif (src[0] == '\\0') {\n\t\t\tbreak;\n\t\t} else if (src[0] == '/') {\n\t\t\tsrc++;\n\t\t\tcontinue;\n\t\t} else if (src[0] == '.') {\n\t\t\tif (src[1] == '\\0') {\n\t\t\t\tbreak;\n\t\t\t} else if (src[1] == '/') {\n\t\t\t\tsrc += 2;\n\t\t\t\tcontinue;\n\t\t\t} else if (src[1] == '.') {\n\t\t\t\tif (src[2] == '/' || src[2] == '\\0') {\n\t\t\t\t\tif (flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {\n\t\t\t\t\t\tif (error_number) *error_number = ARCHIVE_ERRNO_MISC;\n\t\t\t\t\t\tif (error_string)\n\t\t\t\t\t\t    archive_string_sprintf(error_string,\n\t\t\t\t\t\t\t    \"Path contains '..'\");\n\t\t\t\t\t\treturn (ARCHIVE_FAILED);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (separator)\n\t\t\t*dest++ = '/';\n\t\twhile (*src != '\\0' && *src != '/') {\n\t\t\t*dest++ = *src++;\n\t\t}\n\t\tif (*src == '\\0')\n\t\t\tbreak;\n\t\tseparator = *src++;\n\t}\n\tif (dest == path) {\n\t\tif (separator)\n\t\t\t*dest++ = '/';\n\t\telse\n\t\t\t*dest++ = '.';\n\t}\n\t*dest = '\\0';\n\treturn (ARCHIVE_OK);\n}", "target": 0}
{"code": "njs_promise_perform_all_handler(njs_vm_t *vm, njs_iterator_args_t *args,\n    njs_value_t *value, int64_t index)\n{\n    njs_int_t                    ret;\n    njs_array_t                  *array;\n    njs_value_t                  arguments[2], next;\n    njs_function_t               *on_fulfilled;\n    njs_promise_capability_t     *capability;\n    njs_promise_all_context_t    *context;\n    njs_promise_iterator_args_t  *pargs;\n    if (!njs_is_valid(value)) {\n        value = njs_value_arg(&njs_value_undefined);\n    }\n    pargs = (njs_promise_iterator_args_t *) args;\n    capability = pargs->capability;\n    array = args->data;\n    njs_set_undefined(&array->start[index]);\n    ret = njs_function_call(vm, pargs->function, pargs->constructor, value,\n                            1, &next);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n    on_fulfilled = njs_promise_create_function(vm,\n                                            sizeof(njs_promise_all_context_t));\n    if (njs_slow_path(on_fulfilled == NULL)) {\n        return NJS_ERROR;\n    }\n    on_fulfilled->u.native = njs_promise_all_resolve_element_functions;\n    on_fulfilled->args_count = 1;\n    context = on_fulfilled->context;\n    context->already_called = 0;\n    context->index = (uint32_t) index;\n    context->values = pargs->args.data;\n    context->capability = capability;\n    context->remaining_elements = pargs->remaining;\n    (*pargs->remaining)++;\n    njs_set_function(&arguments[0], on_fulfilled);\n    arguments[1] = capability->reject;\n    ret = njs_promise_invoke_then(vm, &next, arguments, 2);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n    return NJS_OK;\n}", "target": 0}
{"code": "static int stimer_set_count(struct kvm_vcpu_hv_stimer *stimer, u64 count,\n\t\t\t    bool host)\n{\n\tstruct kvm_vcpu *vcpu = hv_stimer_to_vcpu(stimer);\n\tstruct kvm_vcpu_hv_synic *synic = to_hv_synic(vcpu);\n\tif (!synic->active && !host)\n\t\treturn 1;\n\ttrace_kvm_hv_stimer_set_count(hv_stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t      stimer->index, count, host);\n\tstimer_cleanup(stimer);\n\tstimer->count = count;\n\tif (stimer->count == 0)\n\t\tstimer->config.enable = 0;\n\telse if (stimer->config.auto_enable)\n\t\tstimer->config.enable = 1;\n\tif (stimer->config.enable)\n\t\tstimer_mark_pending(stimer, false);\n\treturn 0;\n}", "target": 1}
{"code": "void SecurityManager::on_validation_failed(\n        const ParticipantProxyData& participant_data,\n        const SecurityException& exception) const\n{\n    if (participant_->security_attributes().allow_unauthenticated_participants)\n    {\n        participant_->pdp()->notifyAboveRemoteEndpoints(participant_data, false);\n    }\n    if (strlen(exception.what()) > 0)\n    {\n        EPROSIMA_LOG_ERROR(SECURITY_AUTHENTICATION, exception.what());\n    }\n    EPROSIMA_LOG_INFO(SECURITY, \"Authentication failed for participant \" <<\n            participant_data.m_guid);\n    if (participant_->getListener() != nullptr)\n    {\n        ParticipantAuthenticationInfo info;\n        info.status = ParticipantAuthenticationInfo::UNAUTHORIZED_PARTICIPANT;\n        info.guid = participant_data.m_guid;\n        participant_->getListener()->onParticipantAuthentication(\n            participant_->getUserRTPSParticipant(), std::move(info));\n    }\n}", "target": 0}
{"code": "urlCheckRequest(const HttpRequest * r)\n{\n    if (r->method == Http::METHOD_CONNECT)\n        return true;\n    if (r->method == Http::METHOD_OPTIONS || r->method == Http::METHOD_TRACE)\n        return (r->header.getInt64(Http::HdrType::MAX_FORWARDS) == 0 || r->url.path() != AnyP::Uri::Asterisk());\n    if (r->method == Http::METHOD_PURGE)\n        return true;\n    switch (r->url.getScheme()) {\n    case AnyP::PROTO_URN:\n    case AnyP::PROTO_HTTP:\n    case AnyP::PROTO_CACHE_OBJECT:\n        return true;\n    case AnyP::PROTO_FTP:\n        if (r->method == Http::METHOD_PUT ||\n                r->method == Http::METHOD_GET ||\n                r->method == Http::METHOD_HEAD )\n            return true;\n        return false;\n    case AnyP::PROTO_GOPHER:\n    case AnyP::PROTO_WAIS:\n    case AnyP::PROTO_WHOIS:\n        if (r->method == Http::METHOD_GET ||\n                r->method == Http::METHOD_HEAD)\n            return true;\n        return false;\n    case AnyP::PROTO_HTTPS:\n#if USE_OPENSSL || USE_GNUTLS\n        return true;\n#else\n        return false;\n#endif\n    default:\n        return false;\n    }\n    return false;\n}", "target": 1}
{"code": "static bool regsafe(struct bpf_reg_state *rold, struct bpf_reg_state *rcur,\n\t\t    struct idpair *idmap)\n{\n\tif (!(rold->live & REG_LIVE_READ))\n\t\treturn true;\n\tif (memcmp(rold, rcur, offsetof(struct bpf_reg_state, live)) == 0)\n\t\treturn true;\n\tif (rold->type == NOT_INIT)\n\t\treturn true;\n\tif (rcur->type == NOT_INIT)\n\t\treturn false;\n\tswitch (rold->type) {\n\tcase SCALAR_VALUE:\n\t\tif (rcur->type == SCALAR_VALUE) {\n\t\t\treturn range_within(rold, rcur) &&\n\t\t\t       tnum_in(rold->var_off, rcur->var_off);\n\t\t} else {\n\t\t\treturn rold->umin_value == 0 &&\n\t\t\t       rold->umax_value == U64_MAX &&\n\t\t\t       rold->smin_value == S64_MIN &&\n\t\t\t       rold->smax_value == S64_MAX &&\n\t\t\t       tnum_is_unknown(rold->var_off);\n\t\t}\n\tcase PTR_TO_MAP_VALUE:\n\t\treturn memcmp(rold, rcur, offsetof(struct bpf_reg_state, id)) == 0 &&\n\t\t       range_within(rold, rcur) &&\n\t\t       tnum_in(rold->var_off, rcur->var_off);\n\tcase PTR_TO_MAP_VALUE_OR_NULL:\n\t\tif (rcur->type != PTR_TO_MAP_VALUE_OR_NULL)\n\t\t\treturn false;\n\t\tif (memcmp(rold, rcur, offsetof(struct bpf_reg_state, id)))\n\t\t\treturn false;\n\t\treturn check_ids(rold->id, rcur->id, idmap);\n\tcase PTR_TO_PACKET_META:\n\tcase PTR_TO_PACKET:\n\t\tif (rcur->type != rold->type)\n\t\t\treturn false;\n\t\tif (rold->range > rcur->range)\n\t\t\treturn false;\n\t\tif (rold->off != rcur->off)\n\t\t\treturn false;\n\t\tif (rold->id && !check_ids(rold->id, rcur->id, idmap))\n\t\t\treturn false;\n\t\treturn range_within(rold, rcur) &&\n\t\t       tnum_in(rold->var_off, rcur->var_off);\n\tcase PTR_TO_CTX:\n\tcase CONST_PTR_TO_MAP:\n\tcase PTR_TO_STACK:\n\tcase PTR_TO_PACKET_END:\n\tdefault:\n\t\treturn false;\n\t}\n\tWARN_ON_ONCE(1);\n\treturn false;\n}", "target": 1}
{"code": "int dns_HTTPS_add_ipv4hint(struct dns_rr_nested *svcparam, unsigned char addr[][DNS_RR_A_LEN], int addr_num)\n{\n\tif (_dns_left_len(&svcparam->context) < 4 + addr_num * DNS_RR_A_LEN) {\n\t\treturn -1;\n\t}\n\tunsigned short value = DNS_HTTPS_T_IPV4HINT;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\tvalue = addr_num * DNS_RR_A_LEN;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\tfor (int i = 0; i < addr_num; i++) {\n\t\tdns_add_rr_nested_memcpy(svcparam, addr[i], DNS_RR_A_LEN);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int wdm_post_reset(struct usb_interface *intf)\n{\n\tstruct wdm_device *desc = wdm_find_device(intf);\n\tint rv;\n\tclear_bit(WDM_OVERFLOW, &desc->flags);\n\tclear_bit(WDM_RESETTING, &desc->flags);\n\trv = recover_from_urb_loss(desc);\n\tmutex_unlock(&desc->wlock);\n\tmutex_unlock(&desc->rlock);\n\treturn 0;\n}", "target": 0}
{"code": "static inline bool is_exception(u32 intr_info)\n{\n\treturn (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VALID_MASK))\n\t\t== (INTR_TYPE_HARD_EXCEPTION | INTR_INFO_VALID_MASK);\n}", "target": 1}
{"code": "vgetcpu_cpu_notifier(struct notifier_block *n, unsigned long action, void *arg)\n{\n\tlong cpu = (long)arg;\n\tif (action == CPU_ONLINE || action == CPU_ONLINE_FROZEN)\n\t\tsmp_call_function_single(cpu, vgetcpu_cpu_init, NULL, 1);\n\treturn NOTIFY_DONE;\n}", "target": 0}
{"code": "static int is_fuse_usermount(struct libmnt_context *cxt, int *errsv)\n{\n\tstruct libmnt_ns *ns_old;\n\tconst char *type = mnt_fs_get_fstype(cxt->fs);\n\tconst char *optstr;\n\tchar *user_id = NULL;\n\tsize_t sz;\n\tuid_t uid;\n\tchar uidstr[sizeof(stringify_value(ULONG_MAX))];\n\t*errsv = 0;\n\tif (!type)\n\t\treturn 0;\n\tif (strcmp(type, \"fuse\") != 0 &&\n\t    strcmp(type, \"fuseblk\") != 0 &&\n\t    strncmp(type, \"fuse.\", 5) != 0 &&\n\t    strncmp(type, \"fuseblk.\", 8) != 0)\n\t\treturn 0;\n\toptstr = mnt_fs_get_fs_options(cxt->fs);\n\tif (!optstr)\n\t\treturn 0;\n\tif (mnt_optstr_get_option(optstr, \"user_id\", &user_id, &sz) != 0)\n\t\treturn 0;\n\tif (sz == 0 || user_id == NULL)\n\t\treturn 0;\n\tns_old = mnt_context_switch_origin_ns(cxt);\n\tif (!ns_old) {\n\t\t*errsv = -MNT_ERR_NAMESPACE;\n\t\treturn 0;\n\t}\n\tuid = getuid();\n\tif (!mnt_context_switch_ns(cxt, ns_old)) {\n\t\t*errsv = -MNT_ERR_NAMESPACE;\n\t\treturn 0;\n\t}\n\tsnprintf(uidstr, sizeof(uidstr), \"%lu\", (unsigned long) uid);\n\treturn strncmp(user_id, uidstr, sz) == 0;\n}", "target": 1}
{"code": "ZEND_API void zend_object_store_ctor_failed(zval *zobject TSRMLS_DC)\n{\n\tzend_object_handle handle = Z_OBJ_HANDLE_P(zobject);\n\tzend_object_store_bucket *obj_bucket = &EG(objects_store).object_buckets[handle];\n\tobj_bucket->bucket.obj.handlers = Z_OBJ_HT_P(zobject);;\n\tobj_bucket->destructor_called = 1;\n}", "target": 1}
{"code": "int jas_stream_read(jas_stream_t *stream, void *buf, int cnt)\n{\n\tint n;\n\tint c;\n\tchar *bufptr;\n\tif (cnt < 0) {\n\t\tjas_deprecated(\"negative count for jas_stream_read\");\n\t}\n\tbufptr = buf;\n\tn = 0;\n\twhile (n < cnt) {\n\t\tif ((c = jas_stream_getc(stream)) == EOF) {\n\t\t\treturn n;\n\t\t}\n\t\t*bufptr++ = c;\n\t\t++n;\n\t}\n\treturn n;\n}", "target": 0}
{"code": "static void ReversePoints(PointInfo *points,const size_t number_points)\n{\n  PointInfo\n    point;\n  ssize_t\n    i;\n  for (i=0; i < (ssize_t) (number_points >> 1); i++)\n  {\n    point=points[i];\n    points[i]=points[number_points-(i+1)];\n    points[number_points-(i+1)]=point;\n  }\n}", "target": 0}
{"code": "TfLiteStatus ResizeOutputTensor(TfLiteContext* context,\n                                BatchToSpaceNDContext* op_context) {\n  TfLiteIntArray* input_size = op_context->input->dims;\n  const int* block_shape = GetTensorData<int32>(op_context->block_shape);\n  const int* crops = GetTensorData<int32>(op_context->crops);\n  int spatial_dims_num = input_size->size - 2;\n  TF_LITE_ENSURE_EQ(context, NumDimensions(op_context->block_shape), 1);\n  TF_LITE_ENSURE_EQ(context, op_context->block_shape->dims->data[0],\n                    spatial_dims_num);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(op_context->crops), 2);\n  TF_LITE_ENSURE_EQ(context, op_context->crops->dims->data[0],\n                    spatial_dims_num);\n  TF_LITE_ENSURE_EQ(context, op_context->crops->dims->data[1], 2);\n  for (int i = 0; i < spatial_dims_num * 2; ++i) {\n    TF_LITE_ENSURE(context, crops[i] >= 0);\n  }\n  TfLiteIntArray* output_size = TfLiteIntArrayCopy(input_size);\n  int output_batch_size = input_size->data[0];\n  for (int dim = 0; dim < spatial_dims_num; ++dim) {\n    TF_LITE_ENSURE(context, block_shape[dim] != 0);\n    TF_LITE_ENSURE_EQ(context, output_batch_size % block_shape[dim], 0);\n    output_batch_size = output_batch_size / block_shape[dim];\n    output_size->data[dim + 1] = input_size->data[dim + 1] * block_shape[dim] -\n                                 crops[dim * 2] - crops[dim * 2 + 1];\n  }\n  output_size->data[0] = output_batch_size;\n  output_size->data[input_size->size - 1] =\n      input_size->data[input_size->size - 1];\n  return context->ResizeTensor(context, op_context->output, output_size);\n}", "target": 0}
{"code": "updateDevice(const struct header * headers, time_t t)\n{\n\tstruct device ** pp = &devlist;\n\tstruct device * p = *pp;\t\n\twhile(p)\n\t{\n\t\tif(  p->headers[HEADER_NT].l == headers[HEADER_NT].l\n\t\t  && (0==memcmp(p->headers[HEADER_NT].p, headers[HEADER_NT].p, headers[HEADER_NT].l))\n\t\t  && p->headers[HEADER_USN].l == headers[HEADER_USN].l\n\t\t  && (0==memcmp(p->headers[HEADER_USN].p, headers[HEADER_USN].p, headers[HEADER_USN].l)) )\n\t\t{\n\t\t\tsyslog(LOG_DEBUG, \"device updated : %.*s\", headers[HEADER_USN].l, headers[HEADER_USN].p);\n\t\t\tp->t = t;\n\t\t\tif(headers[HEADER_LOCATION].l > p->headers[HEADER_LOCATION].l)\n\t\t\t{\n\t\t\t\tstruct device * tmp;\n\t\t\t\ttmp = realloc(p, sizeof(struct device)\n\t\t\t\t    + headers[0].l+headers[1].l+headers[2].l);\n\t\t\t\tif(!tmp)\t\n\t\t\t\t{\n\t\t\t\t\tsyslog(LOG_ERR, \"updateDevice() : memory allocation error\");\n\t\t\t\t\t*pp = p->next;\t\n\t\t\t\t\tfree(p);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tp = tmp;\n\t\t\t\t*pp = p;\n\t\t\t}\n\t\t\tmemcpy(p->data + p->headers[0].l + p->headers[1].l,\n\t\t\t       headers[2].p, headers[2].l);\n\t\t\treturn 0;\n\t\t}\n\t\tpp = &p->next;\n\t\tp = *pp;\t\n\t}\n\tsyslog(LOG_INFO, \"new device discovered : %.*s\",\n\t       headers[HEADER_USN].l, headers[HEADER_USN].p);\n\t{\n\t\tchar * pc;\n\t\tint i;\n\t\tp = malloc(  sizeof(struct device)\n\t\t           + headers[0].l+headers[1].l+headers[2].l );\n\t\tif(!p) {\n\t\t\tsyslog(LOG_ERR, \"updateDevice(): cannot allocate memory\");\n\t\t\treturn -1;\n\t\t}\n\t\tp->next = devlist;\n\t\tp->t = t;\n\t\tpc = p->data;\n\t\tfor(i = 0; i < 3; i++)\n\t\t{\n\t\t\tp->headers[i].p = pc;\n\t\t\tp->headers[i].l = headers[i].l;\n\t\t\tmemcpy(pc, headers[i].p, headers[i].l);\n\t\t\tpc += headers[i].l;\n\t\t}\n\t\tdevlist = p;\n\t\tsendNotifications(NOTIF_NEW, p, NULL);\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "static int fr_add_pvc(struct net_device *frad, unsigned int dlci, int type)\n{\n\thdlc_device *hdlc = dev_to_hdlc(frad);\n\tpvc_device *pvc;\n\tstruct net_device *dev;\n\tint used;\n\tif ((pvc = add_pvc(frad, dlci)) == NULL) {\n\t\tnetdev_warn(frad, \"Memory squeeze on fr_add_pvc()\\n\");\n\t\treturn -ENOBUFS;\n\t}\n\tif (*get_dev_p(pvc, type))\n\t\treturn -EEXIST;\n\tused = pvc_is_used(pvc);\n\tif (type == ARPHRD_ETHER)\n\t\tdev = alloc_netdev(0, \"pvceth%d\", ether_setup);\n\telse\n\t\tdev = alloc_netdev(0, \"pvc%d\", pvc_setup);\n\tif (!dev) {\n\t\tnetdev_warn(frad, \"Memory squeeze on fr_pvc()\\n\");\n\t\tdelete_unused_pvcs(hdlc);\n\t\treturn -ENOBUFS;\n\t}\n\tif (type == ARPHRD_ETHER)\n\t\trandom_ether_addr(dev->dev_addr);\n\telse {\n\t\t*(__be16*)dev->dev_addr = htons(dlci);\n\t\tdlci_to_q922(dev->broadcast, dlci);\n\t}\n\tdev->netdev_ops = &pvc_ops;\n\tdev->mtu = HDLC_MAX_MTU;\n\tdev->tx_queue_len = 0;\n\tdev->ml_priv = pvc;\n\tif (register_netdevice(dev) != 0) {\n\t\tfree_netdev(dev);\n\t\tdelete_unused_pvcs(hdlc);\n\t\treturn -EIO;\n\t}\n\tdev->destructor = free_netdev;\n\t*get_dev_p(pvc, type) = dev;\n\tif (!used) {\n\t\tstate(hdlc)->dce_changed = 1;\n\t\tstate(hdlc)->dce_pvc_count++;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "_archive_write_disk_close(struct archive *_a)\n{\n\tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n\tstruct fixup_entry *next, *p;\n\tint fd, ret;\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,\n\t    ARCHIVE_STATE_HEADER | ARCHIVE_STATE_DATA,\n\t    \"archive_write_disk_close\");\n\tret = _archive_write_disk_finish_entry(&a->archive);\n\tp = sort_dir_list(a->fixup_list);\n\twhile (p != NULL) {\n\t\tfd = -1;\n\t\ta->pst = NULL; \n\t\tif (p->fixup &\n\t\t    (TODO_TIMES | TODO_MODE_BASE | TODO_ACLS | TODO_FFLAGS)) {\n\t\t\tfd = open(p->name,\n\t\t\t    O_WRONLY | O_BINARY | O_NOFOLLOW | O_CLOEXEC);\n\t\t}\n\t\tif (p->fixup & TODO_TIMES) {\n\t\t\tset_times(a, fd, p->mode, p->name,\n\t\t\t    p->atime, p->atime_nanos,\n\t\t\t    p->birthtime, p->birthtime_nanos,\n\t\t\t    p->mtime, p->mtime_nanos,\n\t\t\t    p->ctime, p->ctime_nanos);\n\t\t}\n\t\tif (p->fixup & TODO_MODE_BASE) {\n#ifdef HAVE_FCHMOD\n\t\t\tif (fd >= 0)\n\t\t\t\tfchmod(fd, p->mode);\n\t\t\telse\n#endif\n\t\t\tchmod(p->name, p->mode);\n\t\t}\n\t\tif (p->fixup & TODO_ACLS)\n\t\t\tarchive_write_disk_set_acls(&a->archive, fd,\n\t\t\t    p->name, &p->acl, p->mode);\n\t\tif (p->fixup & TODO_FFLAGS)\n\t\t\tset_fflags_platform(a, fd, p->name,\n\t\t\t    p->mode, p->fflags_set, 0);\n\t\tif (p->fixup & TODO_MAC_METADATA)\n\t\t\tset_mac_metadata(a, p->name, p->mac_metadata,\n\t\t\t\t\t p->mac_metadata_size);\n\t\tnext = p->next;\n\t\tarchive_acl_clear(&p->acl);\n\t\tfree(p->mac_metadata);\n\t\tfree(p->name);\n\t\tif (fd >= 0)\n\t\t\tclose(fd);\n\t\tfree(p);\n\t\tp = next;\n\t}\n\ta->fixup_list = NULL;\n\treturn (ret);\n}", "target": 1}
{"code": "static int sco_sock_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t    size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tint err;\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\terr = sock_error(sk);\n\tif (err)\n\t\treturn err;\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\tlock_sock(sk);\n\tif (sk->sk_state == BT_CONNECTED)\n\t\terr = sco_send_frame(sk, msg, len);\n\telse\n\t\terr = -ENOTCONN;\n\trelease_sock(sk);\n\treturn err;\n}", "target": 1}
{"code": "static int __init proc_genhd_init(void)\n{\n\tproc_create(\"diskstats\", 0, NULL, &proc_diskstats_operations);\n\tproc_create(\"partitions\", 0, NULL, &proc_partitions_operations);\n\treturn 0;\n}", "target": 0}
{"code": "static int32_t gcd(int a, int b)\n{\n  if (a == 0 && b == 0) {\n    return 1;\n  }\n  if (a == 0) return b;\n  if (b == 0) return a;\n  int32_t h;\n  do {\n    h = a % b;\n    a = b;\n    b = h;\n  } while (b != 0);\n  return a;\n}", "target": 1}
{"code": "uint64_t HeaderMapImpl::byteSize() const {\n  uint64_t byte_size = 0;\n  for (const HeaderEntryImpl& header : headers_) {\n    byte_size += header.key().size();\n    byte_size += header.value().size();\n  }\n  return byte_size;\n}", "target": 1}
{"code": "videobuf_vm_close(struct vm_area_struct *vma)\n{\n\tstruct videobuf_mapping *map = vma->vm_private_data;\n\tstruct videobuf_queue *q = map->q;\n\tint i;\n\tdprintk(2,\"vm_close %p [count=%d,vma=%08lx-%08lx]\\n\",map,\n\t\tmap->count,vma->vm_start,vma->vm_end);\n\tmap->count--;\n\tif (0 == map->count) {\n\t\tdprintk(1,\"munmap %p q=%p\\n\",map,q);\n\t\tmutex_lock(&q->lock);\n\t\tfor (i = 0; i < VIDEO_MAX_FRAME; i++) {\n\t\t\tif (NULL == q->bufs[i])\n\t\t\t\tcontinue;\n\t\t\tif (q->bufs[i]->map != map)\n\t\t\t\tcontinue;\n\t\t\tq->ops->buf_release(q,q->bufs[i]);\n\t\t\tq->bufs[i]->map   = NULL;\n\t\t\tq->bufs[i]->baddr = 0;\n\t\t}\n\t\tmutex_unlock(&q->lock);\n\t\tkfree(map);\n\t}\n\treturn;\n}", "target": 1}
{"code": "static int do_video_set_spu_palette(unsigned int fd, unsigned int cmd,\n\t\tstruct compat_video_spu_palette __user *up)\n{\n\tstruct video_spu_palette __user *up_native;\n\tcompat_uptr_t palp;\n\tint length, err;\n\terr  = get_user(palp, &up->palette);\n\terr |= get_user(length, &up->length);\n\tif (err)\n\t\treturn -EFAULT;\n\tup_native = compat_alloc_user_space(sizeof(struct video_spu_palette));\n\terr  = put_user(compat_ptr(palp), &up_native->palette);\n\terr |= put_user(length, &up_native->length);\n\tif (err)\n\t\treturn -EFAULT;\n\terr = sys_ioctl(fd, cmd, (unsigned long) up_native);\n\treturn err;\n}", "target": 0}
{"code": "void jbd2_journal_lock_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\tjbd2_might_wait_for_commit(journal);\n\twrite_lock(&journal->j_state_lock);\n\t++journal->j_barrier_count;\n\tif (atomic_read(&journal->j_reserved_credits)) {\n\t\twrite_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_reserved,\n\t\t\t   atomic_read(&journal->j_reserved_credits) == 0);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\tjbd2_journal_wait_updates(journal);\n\twrite_unlock(&journal->j_state_lock);\n\tmutex_lock(&journal->j_barrier);\n}", "target": 1}
{"code": "NOEXPORT int parse_socket_error(CLI *c, const char *text) {\n    switch(get_last_socket_error()) {\n    case 0: \n#ifndef USE_WIN32\n    case EPIPE: \n#endif\n    case S_ECONNABORTED:\n        s_log(LOG_INFO, \"%s: Socket is closed\", text);\n        return 0;\n    case S_EINTR:\n        s_log(LOG_DEBUG, \"%s: Interrupted by a signal: retrying\", text);\n        return 1;\n    case S_EWOULDBLOCK:\n        s_log(LOG_NOTICE, \"%s: Would block: retrying\", text);\n        s_poll_sleep(1, 0); \n        return 1;\n#if S_EAGAIN!=S_EWOULDBLOCK\n    case S_EAGAIN:\n        s_log(LOG_DEBUG,\n            \"%s: Temporary lack of resources: retrying\", text);\n        return 1;\n#endif\n#ifdef USE_WIN32\n    case S_ECONNRESET:\n        if(c->opt->exec_name) {\n            s_log(LOG_INFO, \"%s: Socket is closed (exec)\", text);\n            return 0;\n        }\n#endif\n    default:\n        sockerror(text);\n        throw_exception(c, 1);\n        return -1; \n    }\n}", "target": 1}
{"code": "int crxFreeImageData(CrxImage *img)\n{\n  CrxTile *tile = img->tiles;\n  int nTiles = img->tileRows * img->tileCols;\n  if (img->tiles)\n  {\n    for (int32_t curTile = 0; curTile < nTiles; curTile++, tile++)\n      if (tile[curTile].comps)\n        for (int32_t curPlane = 0; curPlane < img->nPlanes; curPlane++)\n          crxFreeSubbandData(img, tile[curTile].comps + curPlane);\n    free(img->tiles);\n    img->tiles = 0;\n  }\n  if (img->planeBuf)\n  {\n    free(img->planeBuf);\n    img->planeBuf = 0;\n  }\n  return 0;\n}", "target": 1}
{"code": "static unsigned char *AcquireCompactPixels(const Image *image,\n  ExceptionInfo *exception)\n{\n  size_t\n    packet_size;\n  unsigned char\n    *compact_pixels;\n  packet_size=image->depth > 8UL ? 2UL : 1UL;\n  compact_pixels=(unsigned char *) AcquireQuantumMemory((9*\n    image->columns)+1,packet_size*sizeof(*compact_pixels));\n  if (compact_pixels == (unsigned char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n        image->filename);\n    }\n  return(compact_pixels);\n}", "target": 1}
{"code": "static void singlevar (LexState *ls, expdesc *var) {\n  TString *varname = str_checkname(ls);\n  FuncState *fs = ls->fs;\n  singlevaraux(fs, varname, var, 1);\n  if (var->k == VVOID) {  \n    expdesc key;\n    singlevaraux(fs, ls->envn, var, 1);  \n    lua_assert(var->k != VVOID);  \n    luaK_exp2anyregup(fs, var);  \n    codestring(&key, varname);  \n    luaK_indexed(fs, var, &key);  \n  }\n}", "target": 0}
{"code": "static int init_strtab(ELFOBJ *bin) {\n\tr_return_val_if_fail (!bin->strtab, false);\n\tif (!bin->shdr) {\n\t\treturn false;\n\t}\n\tElf_(Half) shstrndx = bin->ehdr.e_shstrndx;\n\tif (shstrndx != SHN_UNDEF && !is_shidx_valid (bin, shstrndx)) {\n\t\treturn false;\n\t}\n\tif (bin->shdr[shstrndx].sh_size > UT32_MAX) {\n\t\treturn false;\n\t}\n\tif (!bin->shdr[shstrndx].sh_size) {\n\t\treturn false;\n\t}\n\tbin->shstrtab_section = bin->strtab_section = &bin->shdr[shstrndx];\n\tbin->shstrtab_size = bin->shstrtab_section->sh_size;\n\tif (bin->shstrtab_size > bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->shstrtab_section->sh_offset > bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->shstrtab_section->sh_offset + bin->shstrtab_section->sh_size > bin->size) {\n\t\treturn false;\n\t}\n\tif (!(bin->shstrtab = calloc (1, bin->shstrtab_size + 1))) {\n\t\tr_sys_perror (\"malloc\");\n\t\tbin->shstrtab = NULL;\n\t\treturn false;\n\t}\n\tint res = r_buf_read_at (bin->b, bin->shstrtab_section->sh_offset, (ut8*)bin->shstrtab,\n\t\tbin->shstrtab_section->sh_size);\n\tif (res < 1) {\n\t\tR_LOG_ERROR (\"read (shstrtab) at 0x%\" PFMT64x, (ut64) bin->shstrtab_section->sh_offset);\n\t\tR_FREE (bin->shstrtab);\n\t\treturn false;\n\t}\n\tbin->shstrtab[bin->shstrtab_section->sh_size] = '\\0';\n\tsdb_num_set (bin->kv, \"elf_shstrtab.offset\", bin->shstrtab_section->sh_offset, 0);\n\tsdb_num_set (bin->kv, \"elf_shstrtab.size\", bin->shstrtab_section->sh_size, 0);\n\treturn true;\n}", "target": 1}
{"code": "    void operator = (const IniSection &s)\n\t{\n\t    if (&s == this)\n\t    {\n\t\treturn;\n\t    } \n\t    IniBase::operator = (s);\n\t    ip = s.ip;\n\t    end_comment = s.end_comment; rewrite_by = s.rewrite_by;\n\t    container = s.container;\n\t    reindex ();\n\t}", "target": 1}
{"code": "long jpc_bitstream_getbits(jpc_bitstream_t *bitstream, int n)\n{\n\tlong v;\n\tint u;\n\tassert(n >= 0 && n < 32);\n\tv = 0;\n\twhile (--n >= 0) {\n\t\tif ((u = jpc_bitstream_getbit(bitstream)) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tv = (v << 1) | u;\n\t}\n\treturn v;\n}", "target": 1}
{"code": "snmp_ber_encode_oid(snmp_packet_t *snmp_packet, snmp_oid_t *oid)\n{\n  uint32_t val;\n  uint16_t original_out_len;\n  uint8_t pos;\n  original_out_len = snmp_packet->used;\n  pos = oid->length - 1;\n  while(pos) {\n    val = oid->data[pos];\n    if(snmp_packet->used == snmp_packet->max) {\n      return 0;\n    }\n    *snmp_packet->out-- = (uint8_t)(val & 0x7F);\n    snmp_packet->used++;\n    val >>= 7;\n    while(val) {\n      if(snmp_packet->used == snmp_packet->max) {\n        return 0;\n      }\n      *snmp_packet->out-- = (uint8_t)((val & 0x7F) | 0x80);\n      snmp_packet->used++;\n      val >>= 7;\n    }\n    pos--;\n  }\n  if(snmp_packet->used == snmp_packet->max) {\n    return 0;\n  }\n  val = *(snmp_packet->out + 1) + 40 * oid->data[pos];\n  snmp_packet->used--;\n  snmp_packet->out++;\n  if(snmp_packet->used == snmp_packet->max) {\n    return 0;\n  }\n  *snmp_packet->out-- = (uint8_t)(val & 0x7F);\n  snmp_packet->used++;\n  val >>= 7;\n  while(val) {\n    if(snmp_packet->used == snmp_packet->max) {\n      return 0;\n    }\n    *snmp_packet->out-- = (uint8_t)((val & 0x7F) | 0x80);\n    snmp_packet->used++;\n    val >>= 7;\n  }\n  if(!snmp_ber_encode_length(snmp_packet, snmp_packet->used - original_out_len)) {\n    return 0;\n  }\n  if(!snmp_ber_encode_type(snmp_packet, BER_DATA_TYPE_OBJECT_IDENTIFIER)) {\n    return 0;\n  }\n  return 1;\n}", "target": 0}
{"code": "static void queue_delete(struct snd_seq_queue *q)\n{\n\tmutex_lock(&q->timer_mutex);\n\tsnd_seq_timer_stop(q->timer);\n\tsnd_seq_timer_close(q);\n\tmutex_unlock(&q->timer_mutex);\n\tsnd_use_lock_sync(&q->use_lock);\n\tsnd_seq_prioq_delete(&q->tickq);\n\tsnd_seq_prioq_delete(&q->timeq);\n\tsnd_seq_timer_delete(&q->timer);\n\tkfree(q);\n}", "target": 0}
{"code": "static int io_timeout_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe,\n\t\t\t   bool is_timeout_link)\n{\n\tstruct io_timeout_data *data;\n\tunsigned flags;\n\tu32 off = READ_ONCE(sqe->off);\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\tif (sqe->ioprio || sqe->buf_index || sqe->len != 1 ||\n\t    sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\tif (off && is_timeout_link)\n\t\treturn -EINVAL;\n\tflags = READ_ONCE(sqe->timeout_flags);\n\tif (flags & ~(IORING_TIMEOUT_ABS | IORING_TIMEOUT_CLOCK_MASK |\n\t\t      IORING_TIMEOUT_ETIME_SUCCESS))\n\t\treturn -EINVAL;\n\tif (hweight32(flags & IORING_TIMEOUT_CLOCK_MASK) > 1)\n\t\treturn -EINVAL;\n\tINIT_LIST_HEAD(&req->timeout.list);\n\treq->timeout.off = off;\n\tif (unlikely(off && !req->ctx->off_timeout_used))\n\t\treq->ctx->off_timeout_used = true;\n\tif (WARN_ON_ONCE(req_has_async_data(req)))\n\t\treturn -EFAULT;\n\tif (io_alloc_async_data(req))\n\t\treturn -ENOMEM;\n\tdata = req->async_data;\n\tdata->req = req;\n\tdata->flags = flags;\n\tif (get_timespec64(&data->ts, u64_to_user_ptr(sqe->addr)))\n\t\treturn -EFAULT;\n\tif (data->ts.tv_sec < 0 || data->ts.tv_nsec < 0)\n\t\treturn -EINVAL;\n\tINIT_LIST_HEAD(&req->timeout.list);\n\tdata->mode = io_translate_timeout_mode(flags);\n\thrtimer_init(&data->timer, io_timeout_get_clock(data), data->mode);\n\tif (is_timeout_link) {\n\t\tstruct io_submit_link *link = &req->ctx->submit_state.link;\n\t\tif (!link->head)\n\t\t\treturn -EINVAL;\n\t\tif (link->last->opcode == IORING_OP_LINK_TIMEOUT)\n\t\t\treturn -EINVAL;\n\t\treq->timeout.head = link->last;\n\t\tlink->last->flags |= REQ_F_ARM_LTIMEOUT;\n\t}\n\treturn 0;", "target": 0}
{"code": "xfs_file_splice_write(\n\tstruct pipe_inode_info\t*pipe,\n\tstruct file\t\t*outfilp,\n\tloff_t\t\t\t*ppos,\n\tsize_t\t\t\tcount,\n\tunsigned int\t\tflags)\n{\n\tstruct inode\t\t*inode = outfilp->f_mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tint\t\t\tioflags = 0;\n\tssize_t\t\t\tret;\n\tXFS_STATS_INC(xs_write_calls);\n\tif (outfilp->f_mode & FMODE_NOCMTIME)\n\t\tioflags |= IO_INVIS;\n\tif (XFS_FORCED_SHUTDOWN(ip->i_mount))\n\t\treturn -EIO;\n\txfs_ilock(ip, XFS_IOLOCK_EXCL);\n\ttrace_xfs_file_splice_write(ip, count, *ppos, ioflags);\n\tret = generic_file_splice_write(pipe, outfilp, ppos, count, flags);\n\tif (ret > 0)\n\t\tXFS_STATS_ADD(xs_write_bytes, ret);\n\txfs_iunlock(ip, XFS_IOLOCK_EXCL);\n\treturn ret;\n}", "target": 1}
{"code": "static int elo_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tstruct elo_priv *priv;\n\tint ret;\n\tstruct usb_device *udev;\n\tif (!hid_is_usb(hdev))\n\t\treturn -EINVAL;\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tINIT_DELAYED_WORK(&priv->work, elo_work);\n\tudev = interface_to_usbdev(to_usb_interface(hdev->dev.parent));\n\tpriv->usbdev = usb_get_dev(udev);\n\thid_set_drvdata(hdev, priv);\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\tgoto err_free;\n\t}\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\tgoto err_free;\n\t}\n\tif (elo_broken_firmware(priv->usbdev)) {\n\t\thid_info(hdev, \"broken firmware found, installing workaround\\n\");\n\t\tqueue_delayed_work(wq, &priv->work, ELO_PERIODIC_READ_INTERVAL);\n\t}\n\treturn 0;\nerr_free:\n\tusb_put_dev(udev);\n\tkfree(priv);\n\treturn ret;\n}", "target": 0}
{"code": "static void save_quoted(const char *data, FILE *file)\n{\n\tconst char *p;\n\tfputc('\"', file);\n\tfor (p = data; p && *p; p++) {\n\t\tif ((unsigned char) *p == 0x22 ||\t\t\n\t\t    (unsigned char) *p == 0x5c)\t\t\t\n\t\t\tfputc('\\\\', file);\n\t\tfputc(*p, file);\n\t}\n\tfputc('\"', file);\n}", "target": 0}
{"code": "ff_layout_encode_layoutreturn(struct xdr_stream *xdr,\n\t\tconst void *voidargs,\n\t\tconst struct nfs4_xdr_opaque_data *ff_opaque)\n{\n\tconst struct nfs4_layoutreturn_args *args = voidargs;\n\tstruct nfs4_flexfile_layoutreturn_args *ff_args = ff_opaque->data;\n\tstruct xdr_buf tmp_buf = {\n\t\t.head = {\n\t\t\t[0] = {\n\t\t\t\t.iov_base = page_address(ff_args->pages[0]),\n\t\t\t},\n\t\t},\n\t\t.buflen = PAGE_SIZE,\n\t};\n\tstruct xdr_stream tmp_xdr;\n\t__be32 *start;\n\tdprintk(\"%s: Begin\\n\", __func__);\n\txdr_init_encode(&tmp_xdr, &tmp_buf, NULL, NULL);\n\tff_layout_encode_ioerr(&tmp_xdr, args, ff_args);\n\tff_layout_encode_iostats_array(&tmp_xdr, args, ff_args);\n\tstart = xdr_reserve_space(xdr, 4);\n\t*start = cpu_to_be32(tmp_buf.len);\n\txdr_write_pages(xdr, ff_args->pages, 0, tmp_buf.len);\n\tdprintk(\"%s: Return\\n\", __func__);\n}", "target": 0}
{"code": "void iov_iter_pipe(struct iov_iter *i, int direction,\n\t\t\tstruct pipe_inode_info *pipe,\n\t\t\tsize_t count)\n{\n\tBUG_ON(direction != ITER_PIPE);\n\tWARN_ON(pipe->nrbufs == pipe->buffers);\n\ti->type = direction;\n\ti->pipe = pipe;\n\ti->idx = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);\n\ti->iov_offset = 0;\n\ti->count = count;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& prefix = context->input(0);\n    const Tensor& tensor_names = context->input(1);\n    const Tensor& shape_and_slices = context->input(2);\n    OP_REQUIRES(context, tensor_names.NumElements() == dtypes_.size(),\n                errors::InvalidArgument(\"Got \", tensor_names.NumElements(),\n                                        \" tensor names, but \", dtypes_.size(),\n                                        \" expected dtypes.\"));\n    ValidateInputs(false , context, prefix, tensor_names,\n                   shape_and_slices);\n    if (!context->status().ok()) return;\n    const string& prefix_string = prefix.scalar<tstring>()();\n    Env* env = Env::Default();\n    std::vector<string> paths;\n    if (!env->GetMatchingPaths(MetaFilename(prefix_string), &paths).ok() ||\n        paths.empty()) {\n      for (size_t i = 0; i < tensor_names.NumElements(); ++i) {\n        RestoreTensor(context, &checkpoint::OpenTableTensorSliceReader,\n                       -1,  true,\n                       i);\n        if (!context->status().ok()) {\n          return;\n        }\n      }\n      return;\n    }\n    OP_REQUIRES_OK(context, RestoreTensorsV2(context, prefix, tensor_names,\n                                             shape_and_slices, dtypes_));\n  }", "target": 0}
{"code": "static int8_t parse_ext_option(uint16_t *dst, uint8_t **packet_data_pptr, uint8_t *packet_data_start_ptr, uint16_t packet_len, uint16_t *message_left)\n{\n    uint16_t option_number = *dst;\n    if (option_number == 13) {\n        uint8_t option_ext;\n        int8_t read_result = sn_coap_parser_read_packet_u8(&option_ext,\n                                                            *packet_data_pptr,\n                                                            packet_data_start_ptr,\n                                                            packet_len);\n        if (read_result != 0) {\n            tr_error(\"sn_coap_parser_options_parse - **packet_data_pptr overflow !\");\n            return -1;\n        }\n        else {\n                option_number += option_ext;\n                *message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr,\n                                                               packet_data_start_ptr,\n                                                               packet_len,\n                                                               1);\n        }\n    } else if (option_number == 14) {\n            int8_t read_result = sn_coap_parser_read_packet_u16(&option_number,\n                                                                *packet_data_pptr,\n                                                                packet_data_start_ptr,\n                                                                packet_len);\n            if (read_result != 0) {\n                tr_error(\"sn_coap_parser_options_parse - **packet_data_pptr overflow !\");\n                return -1;\n            }\n            else {\n            option_number += 269;\n            *message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr,\n                                                           packet_data_start_ptr,\n                                                           packet_len,\n                                                           2);\n            }\n    }\n    else if (option_number == 15) {\n        tr_error(\"sn_coap_parser_options_parse - invalid option number(15)!\");\n        return -1;\n    }\n    *dst = option_number;\n    return 0;\n}", "target": 1}
{"code": "std::string Utf16ToUtf8(const std::wstring& utf16_string) {\n  return WC2MB(utf16_string, CP_UTF8);\n}", "target": 1}
{"code": "    PngImage::PngImage(BasicIo::UniquePtr io, bool create)\n            : Image(ImageType::png, mdExif | mdIptc | mdXmp | mdComment, std::move(io))\n    {\n        if (create)\n        {\n            if (io_->open() == 0)\n            {\n#ifdef DEBUG\n                std::cerr << \"Exiv2::PngImage:: Creating PNG image to memory\\n\";\n#endif\n                IoCloser closer(*io_);\n                if (io_->write(pngBlank, sizeof(pngBlank)) != sizeof(pngBlank))\n                {\n#ifdef DEBUG\n                    std::cerr << \"Exiv2::PngImage:: Failed to create PNG image on memory\\n\";\n#endif\n                }\n            }\n        }\n    } ", "target": 0}
{"code": "int bprm_change_interp(char *interp, struct linux_binprm *bprm)\n{\n\tif (bprm->interp != bprm->filename)\n\t\tkfree(bprm->interp);\n\tbprm->interp = kstrdup(interp, GFP_KERNEL);\n\tif (!bprm->interp)\n\t\treturn -ENOMEM;\n\treturn 0;\n}", "target": 0}
{"code": "static void bson_append32_as_int( bson *b, int data ) {\n    bson_little_endian32( b->cur, &data );\n    b->cur += 4;\n}", "target": 0}
{"code": "int enc_untrusted_inet_pton(int af, const char *src, void *dst) {\n  if (!src || !dst) {\n    return 0;\n  }\n  MessageWriter input;\n  input.Push<int>(TokLinuxAfFamily(af));\n  input.PushByReference(Extent{\n      src, std::min(strlen(src) + 1, static_cast<size_t>(INET6_ADDRSTRLEN))});\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kInetPtonHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_inet_pton\", 3);\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return -1;\n  }\n  auto klinux_addr_buffer = output.next();\n  size_t max_size = 0;\n  if (af == AF_INET) {\n    if (klinux_addr_buffer.size() != sizeof(klinux_in_addr)) {\n      ::asylo::primitives::TrustedPrimitives::BestEffortAbort(\n          \"enc_untrusted_inet_pton: unexpected output size\");\n    }\n    max_size = sizeof(struct in_addr);\n  } else if (af == AF_INET6) {\n    if (klinux_addr_buffer.size() != sizeof(klinux_in6_addr)) {\n      ::asylo::primitives::TrustedPrimitives::BestEffortAbort(\n          \"enc_untrusted_inet_pton: unexpected output size\");\n    }\n    max_size = sizeof(struct in6_addr);\n  }\n  memcpy(dst, klinux_addr_buffer.data(),\n         std::min(klinux_addr_buffer.size(), max_size));\n  return result;\n}", "target": 0}
{"code": "authentic_emu_update_tokeninfo(struct sc_profile *profile, struct sc_pkcs15_card *p15card,\n\t\tstruct sc_pkcs15_tokeninfo *tinfo)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_file *file = NULL;\n\tstruct sc_path path;\n\tunsigned char buffer[8];\n\tint rv,len;\n\tsc_format_path(AUTHENTIC_CACHE_TIMESTAMP_PATH, &path);\n\trv = sc_select_file(p15card->card, &path, &file);\n\tif (!rv) {\n\t\trv = sc_get_challenge(p15card->card, buffer, sizeof(buffer));\n\t\tif (!rv) {\n\t\t\tsc_file_free(file);\n\t\t\tLOG_TEST_RET(ctx, rv, \"Get challenge error\");\n\t\t}\n\t\tlen = file->size > sizeof(buffer) ? sizeof(buffer) : file->size;\n\t\trv = sc_update_binary(p15card->card, 0, buffer, len, 0);\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, rv, \"Update binary error\");\n\t}\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}", "target": 1}
{"code": "static bool dir_is_in_dump_location(const char *dump_dir_name)\n{\n    unsigned len = strlen(g_settings_dump_location);\n    if (strncmp(dump_dir_name, g_settings_dump_location, len) == 0\n     && dump_dir_name[len] == '/'\n     && !strstr(dump_dir_name + len, \"/.\")\n    ) {\n        return 1;\n    }\n    return 0;\n}", "target": 1}
{"code": "static int asymmetric_key_cmp(const struct key *key,\n\t\t\t      const struct key_match_data *match_data)\n{\n\tconst struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);\n\tconst char *description = match_data->raw_data;\n\tconst char *spec = description;\n\tconst char *id;\n\tptrdiff_t speclen;\n\tif (!subtype || !spec || !*spec)\n\t\treturn 0;\n\tif (key->description && strcmp(key->description, description) == 0)\n\t\treturn 1;\n\tid = strchr(spec, ':');\n\tif (!id)\n\t\treturn 0;\n\tspeclen = id - spec;\n\tid++;\n\tif (speclen == 2 && memcmp(spec, \"id\", 2) == 0)\n\t\treturn asymmetric_keyid_match(asymmetric_key_id(key), id);\n\tif (speclen == subtype->name_len &&\n\t    memcmp(spec, subtype->name, speclen) == 0)\n\t\treturn 1;\n\treturn 0;\n}", "target": 0}
{"code": "xdr_krb5_principal(XDR *xdrs, krb5_principal *objp)\n{\n    int\t    ret;\n    char\t    *p = NULL;\n    krb5_principal  pr = NULL;\n    static krb5_context context = NULL;\n    if (!context &&\n\tkadm5_init_krb5_context(&context))\n       return(FALSE);\n    switch(xdrs->x_op) {\n    case XDR_ENCODE:\n\tif (*objp) {\n\t     if((ret = krb5_unparse_name(context, *objp, &p)) != 0)\n\t\t  return FALSE;\n\t}\n\tif(!xdr_nullstring(xdrs, &p))\n\t    return FALSE;\n\tif (p) free(p);\n\tbreak;\n    case XDR_DECODE:\n\tif(!xdr_nullstring(xdrs, &p))\n\t    return FALSE;\n\tif (p) {\n\t     ret = krb5_parse_name(context, p, &pr);\n\t     if(ret != 0)\n\t\t  return FALSE;\n\t     *objp = pr;\n\t     free(p);\n\t} else\n\t     *objp = NULL;\n\tbreak;\n    case XDR_FREE:\n\tif(*objp != NULL)\n\t    krb5_free_principal(context, *objp);\n\t*objp = NULL;\n\tbreak;\n    }\n    return TRUE;\n}", "target": 0}
{"code": "\tvoid verifyDirectoryPermissions(const string &path) {\n\t\tTRACE_POINT();\n\t\tstruct stat buf;\n\t\tif (stat(path.c_str(), &buf) == -1) {\n\t\t\tint e = errno;\n\t\t\tthrow FileSystemException(\"Cannot stat() \" + path, e, path);\n\t\t} else if (buf.st_mode != (S_IFDIR | parseModeString(\"u=rwx,g=rx,o=rx\"))) {\n\t\t\tthrow RuntimeException(\"Tried to reuse existing server instance directory \" +\n\t\t\t\tpath + \", but it has wrong permissions\");\n\t\t} else if (buf.st_uid != geteuid() || buf.st_gid != getegid()) {\n\t\t\tthrow RuntimeException(\"Tried to reuse existing server instance directory \" +\n\t\t\t\tpath + \", but it has wrong owner and group\");\n\t\t}\n\t}", "target": 1}
{"code": "static char *clean_path(char *path)\n{\n\tchar *ch;\n\tchar *ch2;\n\tchar *str;\n\tstr = xmalloc(strlen(path) + 1);\n\tch = path;\n\tch2 = str;\n\twhile (true) {\n\t\t*ch2 = *ch;\n\t\tch++;\n\t\tch2++;\n\t\tif (!*(ch-1))\n\t\t\tbreak;\n\t\twhile (*(ch - 1) == '/' && *ch == '/')\n\t\t\tch++;\n\t}\n\twhile ((ch = strrchr(str, '/'))) {\n\t\tif (ch == str)\n\t\t\tbreak;\n\t\tif (!*(ch+1))\n\t\t\t*ch = 0;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn str;\n}", "target": 0}
{"code": "apply_intended_configuration (GsdXrandrManager *manager, const char *intended_filename, guint32 timestamp)\n{\n        GError *my_error;\n        my_error = NULL;\n        if (!apply_configuration_from_filename (manager, intended_filename, FALSE, timestamp, &my_error)) {\n                if (my_error) {\n                        if (!g_error_matches (my_error, G_FILE_ERROR, G_FILE_ERROR_NOENT))\n                                error_message (manager, _(\"Could not apply the stored configuration for monitors\"), my_error, NULL);\n                        g_error_free (my_error);\n                }\n        }\n}", "target": 0}
{"code": "static long do_locks(unsigned int fd, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct flock64 kernel;\n\tstruct oabi_flock64 user;\n\tmm_segment_t fs;\n\tlong ret;\n\tif (copy_from_user(&user, (struct oabi_flock64 __user *)arg,\n\t\t\t   sizeof(user)))\n\t\treturn -EFAULT;\n\tkernel.l_type\t= user.l_type;\n\tkernel.l_whence\t= user.l_whence;\n\tkernel.l_start\t= user.l_start;\n\tkernel.l_len\t= user.l_len;\n\tkernel.l_pid\t= user.l_pid;\n\tfs = get_fs();\n\tset_fs(KERNEL_DS);\n\tret = sys_fcntl64(fd, cmd, (unsigned long)&kernel);\n\tset_fs(fs);\n\tif (!ret && (cmd == F_GETLK64 || cmd == F_OFD_GETLK)) {\n\t\tuser.l_type\t= kernel.l_type;\n\t\tuser.l_whence\t= kernel.l_whence;\n\t\tuser.l_start\t= kernel.l_start;\n\t\tuser.l_len\t= kernel.l_len;\n\t\tuser.l_pid\t= kernel.l_pid;\n\t\tif (copy_to_user((struct oabi_flock64 __user *)arg,\n\t\t\t\t &user, sizeof(user)))\n\t\t\tret = -EFAULT;\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "asmlinkage void bad_mode(struct pt_regs *regs, int reason, unsigned int esr)\n{\n\tconsole_verbose();\n\tpr_crit(\"Bad mode in %s handler detected, code 0x%08x\\n\",\n\t\thandler[reason], esr);\n\tdie(\"Oops - bad mode\", regs, 0);\n\tlocal_irq_disable();\n\tpanic(\"bad mode\");\n}", "target": 1}
{"code": "static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)\n{\n\trcu_read_lock();\n\t__ptrace_link(child, new_parent, __task_cred(new_parent));\n\trcu_read_unlock();\n}", "target": 1}
{"code": "static noinline int free_debug_processing(\n\tstruct kmem_cache *s, struct page *page,\n\tvoid *head, void *tail, int bulk_cnt,\n\tunsigned long addr)\n{\n\tstruct kmem_cache_node *n = get_node(s, page_to_nid(page));\n\tvoid *object = head;\n\tint cnt = 0;\n\tunsigned long uninitialized_var(flags);\n\tint ret = 0;\n\tspin_lock_irqsave(&n->list_lock, flags);\n\tslab_lock(page);\n\tif (s->flags & SLAB_CONSISTENCY_CHECKS) {\n\t\tif (!check_slab(s, page))\n\t\t\tgoto out;\n\t}\nnext_object:\n\tcnt++;\n\tif (s->flags & SLAB_CONSISTENCY_CHECKS) {\n\t\tif (!free_consistency_checks(s, page, object, addr))\n\t\t\tgoto out;\n\t}\n\tif (s->flags & SLAB_STORE_USER)\n\t\tset_track(s, object, TRACK_FREE, addr);\n\ttrace(s, page, object, 0);\n\tinit_object(s, object, SLUB_RED_INACTIVE);\n\tif (object != tail) {\n\t\tobject = get_freepointer(s, object);\n\t\tgoto next_object;\n\t}\n\tret = 1;\nout:\n\tif (cnt != bulk_cnt)\n\t\tslab_err(s, page, \"Bulk freelist count(%d) invalid(%d)\\n\",\n\t\t\t bulk_cnt, cnt);\n\tslab_unlock(page);\n\tspin_unlock_irqrestore(&n->list_lock, flags);\n\tif (!ret)\n\t\tslab_fix(s, \"Object at 0x%p not freed\", object);\n\treturn ret;\n}", "target": 0}
{"code": "static void fuse_lib_listxattr(fuse_req_t req, fuse_ino_t ino, size_t size)\n{\n    struct fuse *f = req_fuse_prepare(req);\n    int res;\n    if (size) {\n        char *list = (char *) malloc(size);\n        if (list == NULL) {\n            reply_err(req, -ENOMEM);\n            return;\n        }\n        res = common_listxattr(f, req, ino, list, size);\n        if (res > 0)\n            fuse_reply_buf(req, list, res);\n        else\n            reply_err(req, res);\n        free(list);\n    } else {\n        res = common_listxattr(f, req, ino, NULL, 0);\n        if (res >= 0)\n            fuse_reply_xattr(req, res);\n        else\n            reply_err(req, res);\n    }\n}", "target": 0}
{"code": "static long madvise_remove(struct vm_area_struct *vma,\n\t\t\t\tstruct vm_area_struct **prev,\n\t\t\t\tunsigned long start, unsigned long end)\n{\n\tloff_t offset;\n\tint error;\n\t*prev = NULL;\t\n\tif (vma->vm_flags & (VM_LOCKED|VM_NONLINEAR|VM_HUGETLB))\n\t\treturn -EINVAL;\n\tif (!vma->vm_file || !vma->vm_file->f_mapping\n\t\t|| !vma->vm_file->f_mapping->host) {\n\t\t\treturn -EINVAL;\n\t}\n\tif ((vma->vm_flags & (VM_SHARED|VM_WRITE)) != (VM_SHARED|VM_WRITE))\n\t\treturn -EACCES;\n\toffset = (loff_t)(start - vma->vm_start)\n\t\t\t+ ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n\tup_read(&current->mm->mmap_sem);\n\terror = do_fallocate(vma->vm_file,\n\t\t\t\tFALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE,\n\t\t\t\toffset, end - start);\n\tdown_read(&current->mm->mmap_sem);\n\treturn error;\n}", "target": 1}
{"code": "GF_Box *mp4s_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGSampleEntryBox, GF_ISOM_BOX_TYPE_MP4S);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\ttmp->internal_type = GF_ISOM_SAMPLE_ENTRY_MP4S;\n\treturn (GF_Box *)tmp;\n}", "target": 1}
{"code": "static __always_inline int __do_follow_link(struct path *path, struct nameidata *nd)\n{\n\tint error;\n\tvoid *cookie;\n\tstruct dentry *dentry = path->dentry;\n\ttouch_atime(path->mnt, dentry);\n\tnd_set_link(nd, NULL);\n\tif (path->mnt != nd->path.mnt) {\n\t\tpath_to_nameidata(path, nd);\n\t\tdget(dentry);\n\t}\n\tmntget(path->mnt);\n\tnd->last_type = LAST_BIND;\n\tcookie = dentry->d_inode->i_op->follow_link(dentry, nd);\n\terror = PTR_ERR(cookie);\n\tif (!IS_ERR(cookie)) {\n\t\tchar *s = nd_get_link(nd);\n\t\terror = 0;\n\t\tif (s)\n\t\t\terror = __vfs_follow_link(nd, s);\n\t\telse if (nd->last_type == LAST_BIND) {\n\t\t\terror = force_reval_path(&nd->path, nd);\n\t\t\tif (error)\n\t\t\t\tpath_put(&nd->path);\n\t\t}\n\t\tif (dentry->d_inode->i_op->put_link)\n\t\t\tdentry->d_inode->i_op->put_link(dentry, nd, cookie);\n\t}\n\treturn error;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& in0 = ctx->input(0);\n    const Tensor& in1 = ctx->input(1);\n    OP_REQUIRES(\n        ctx, in0.NumElements() == in1.NumElements(),\n        errors::InvalidArgument(\"The two arguments to a cwise op must have \"\n                                \"same number of elements, got \",\n                                in0.NumElements(), \" and \", in1.NumElements()));\n    auto in0_flat = in0.flat<Tin>();\n    auto in1_flat = in1.flat<Tin>();\n    const Device& eigen_device = ctx->eigen_device<Device>();\n    Tensor* out = nullptr;\n    if (std::is_same<Tin, Tout>::value) {\n      OP_REQUIRES_OK(ctx, ctx->forward_input_or_allocate_output(\n                              {0, 1}, 0, in0.shape(), &out));\n    } else {\n      OP_REQUIRES_OK(ctx, ctx->allocate_output(0, in0.shape(), &out));\n    }\n    auto out_flat = out->flat<Tout>();\n    functor::SimpleBinaryFunctor<Device, Functor>()(eigen_device, out_flat,\n                                                    in0_flat, in1_flat);\n  }", "target": 0}
{"code": "bool chopOffDotted(string &domain)\n{\n  if(domain.empty() || (domain.size()==1 && domain[0]=='.'))\n    return false;\n  string::size_type fdot=domain.find('.');\n  if(fdot == string::npos)\n    return false;\n  if(fdot==domain.size()-1) \n    domain=\".\";\n  else  {\n    string::size_type remain = domain.length() - (fdot + 1);\n    char tmp[remain];\n    memcpy(tmp, domain.c_str()+fdot+1, remain);\n    domain.assign(tmp, remain);\n  }\n  return true;\n}", "target": 1}
{"code": "absl::Status Ipv4Instance::validateProtocolSupported() {\n  static const bool supported = SocketInterfaceSingleton::get().ipFamilySupported(AF_INET);\n  if (supported) {\n    return absl::OkStatus();\n  }\n  return absl::FailedPreconditionError(\"IPv4 addresses are not supported on this machine\");\n}", "target": 1}
{"code": "void bio_advance(struct bio *bio, unsigned bytes)\n{\n\tif (bio_integrity(bio))\n\t\tbio_integrity_advance(bio, bytes);\n\tbio_advance_iter(bio, &bio->bi_iter, bytes);\n}", "target": 0}
{"code": "void flash_option_bytes_init(int boot_from_dfu)\n{\n    uint32_t val = 0xfffff8aa;\n    if (boot_from_dfu){\n        val &= ~(1<<27); \n    }\n    else {\n        if (solo_is_locked())\n        {\n            val = 0xfffff8cc;\n        }\n    }\n    val &= ~(1<<26); \n    val &= ~(1<<25); \n    val &= ~(1<<24); \n    if (FLASH->OPTR == val)\n    {\n        return;\n    }\n    __disable_irq();\n    while (FLASH->SR & (1<<16))\n        ;\n    flash_unlock();\n    if (FLASH->CR & (1<<30))\n    {\n        FLASH->OPTKEYR = 0x08192A3B;\n        FLASH->OPTKEYR = 0x4C5D6E7F;\n    }\n    FLASH->OPTR =val;\n    FLASH->CR |= (1<<17);\n    while (FLASH->SR & (1<<16))\n        ;\n    flash_lock();\n    __enable_irq();\n}", "target": 1}
{"code": "static void ready_handler(void *arg)\n{\n\tstruct stun_uri uri;\n\tint err;\n\tdns_init(NULL);\n\t(void)uri;\n\t(void)err;\n\tre_printf(\"engine ready.\\n\");\n\tconfig_alloc(&g_config, config_req_handler, NULL, NULL);\n\tconfig_start(g_config);\n#if 0\n\terr = stun_uri_decode(&uri, turn_uri);\n\tif (err) {\n\t\twarning(\"netprobe: ready_handler: failed to parse URI: %s\\n\",\n\t\t\tturn_uri);\n\t\treturn;\n\t}\n\tstart_netprobe(&uri.addr, uri.proto, uri.secure, \"\", \"\");\n#endif\n}", "target": 0}
{"code": "static int em_jcxz(struct x86_emulate_ctxt *ctxt)\n{\n\tif (address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) == 0)\n\t\tjmp_rel(ctxt, ctxt->src.val);\n\treturn X86EMUL_CONTINUE;\n}", "target": 1}
{"code": "Status InferenceContext::Multiply(DimensionHandle first,\n                                  DimensionOrConstant second,\n                                  DimensionHandle* out) {\n  const int64_t first_value = Value(first);\n  const int64_t second_value = Value(second);\n  if (first_value == 0) {\n    *out = first;\n  } else if (second_value == 0) {\n    *out = MakeDim(second);\n  } else if (first_value == 1) {\n    *out = MakeDim(second);\n  } else if (second_value == 1) {\n    *out = first;\n  } else if (first_value == kUnknownDim || second_value == kUnknownDim) {\n    *out = UnknownDim();\n  } else {\n    const int64_t product = first_value * second_value;\n    if (product < 0) {\n      return errors::InvalidArgument(\n          \"Negative dimension size caused by overflow when multiplying \",\n          first_value, \" and \", second_value);\n    }\n    *out = MakeDim(product);\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "sigterm_handler(int sig)\t\t\n{\n  (void)sig;\n  fprintf(stderr,\n\t  \"DEBUG: beh: Job canceled.\\n\");\n  if (job_canceled)\n    _exit(CUPS_BACKEND_OK);\n  else\n    job_canceled = 1;\n}", "target": 1}
{"code": "void skb_complete_tx_timestamp(struct sk_buff *skb,\n\t\t\t       struct skb_shared_hwtstamps *hwtstamps)\n{\n\tstruct sock *sk = skb->sk;\n\tif (!skb_may_tx_timestamp(sk, false))\n\t\treturn;\n\tif (likely(atomic_inc_not_zero(&sk->sk_refcnt))) {\n\t\t*skb_hwtstamps(skb) = *hwtstamps;\n\t\t__skb_complete_tx_timestamp(skb, sk, SCM_TSTAMP_SND);\n\t\tsock_put(sk);\n\t}", "target": 1}
{"code": "init_copy(mrb_state *mrb, mrb_value dest, mrb_value obj)\n{\n  switch (mrb_type(obj)) {\n    case MRB_TT_ICLASS:\n      copy_class(mrb, dest, obj);\n      return;\n    case MRB_TT_CLASS:\n    case MRB_TT_MODULE:\n      copy_class(mrb, dest, obj);\n      mrb_iv_copy(mrb, dest, obj);\n      mrb_iv_remove(mrb, dest, mrb_intern_lit(mrb, \"__classname__\"));\n      break;\n    case MRB_TT_OBJECT:\n    case MRB_TT_SCLASS:\n    case MRB_TT_HASH:\n    case MRB_TT_DATA:\n    case MRB_TT_EXCEPTION:\n      mrb_iv_copy(mrb, dest, obj);\n      break;\n    case MRB_TT_ISTRUCT:\n      mrb_istruct_copy(dest, obj);\n      break;\n    default:\n      break;\n  }\n  mrb_funcall(mrb, dest, \"initialize_copy\", 1, obj);\n}", "target": 0}
{"code": "static void finish_object(struct object *obj,\n\t\t\t  struct strbuf *path, const char *name,\n\t\t\t  void *cb_data)\n{\n\tstruct rev_list_info *info = cb_data;\n\tif (obj->type == OBJ_BLOB && !has_object_file(&obj->oid))\n\t\tdie(\"missing blob object '%s'\", oid_to_hex(&obj->oid));\n\tif (info->revs->verify_objects && !obj->parsed && obj->type != OBJ_COMMIT)\n\t\tparse_object(obj->oid.hash);\n}", "target": 1}
{"code": "bool cli_check_msdfs_proxy(TALLOC_CTX *ctx,\n\t\t\t\tstruct cli_state *cli,\n\t\t\t\tconst char *sharename,\n\t\t\t\tchar **pp_newserver,\n\t\t\t\tchar **pp_newshare,\n\t\t\t\tbool force_encrypt,\n\t\t\t\tconst char *username,\n\t\t\t\tconst char *password,\n\t\t\t\tconst char *domain)\n{\n\tstruct client_dfs_referral *refs = NULL;\n\tsize_t num_refs = 0;\n\tsize_t consumed = 0;\n\tchar *fullpath = NULL;\n\tbool res;\n\tuint16_t cnum;\n\tchar *newextrapath = NULL;\n\tNTSTATUS status;\n\tconst char *remote_name;\n\tif (!cli || !sharename) {\n\t\treturn false;\n\t}\n\tremote_name = smbXcli_conn_remote_name(cli->conn);\n\tcnum = cli_state_get_tid(cli);\n\tif (strequal(sharename, \"IPC$\")) {\n\t\treturn false;\n\t}\n\tfullpath = talloc_asprintf(ctx, \"\\\\%s\\\\%s\", remote_name, sharename);\n\tif (!fullpath) {\n\t\treturn false;\n\t}\n\tif (!NT_STATUS_IS_OK(cli_tree_connect(cli, \"IPC$\", \"IPC\", NULL, 0))) {\n\t\treturn false;\n\t}\n\tif (force_encrypt) {\n\t\tstatus = cli_cm_force_encryption(cli,\n\t\t\t\t\tusername,\n\t\t\t\t\tpassword,\n\t\t\t\t\tdomain,\n\t\t\t\t\t\"IPC$\");\n\t\tif (!NT_STATUS_IS_OK(status)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tstatus = cli_dfs_get_referral(ctx, cli, fullpath, &refs,\n\t\t\t\t      &num_refs, &consumed);\n\tres = NT_STATUS_IS_OK(status);\n\tstatus = cli_tdis(cli);\n\tif (!NT_STATUS_IS_OK(status)) {\n\t\treturn false;\n\t}\n\tcli_state_set_tid(cli, cnum);\n\tif (!res || !num_refs) {\n\t\treturn false;\n\t}\n\tif (!refs[0].dfspath) {\n\t\treturn false;\n\t}\n\tif (!split_dfs_path(ctx, refs[0].dfspath, pp_newserver,\n\t\t\t    pp_newshare, &newextrapath)) {\n\t\treturn false;\n\t}\n\tif (strequal(remote_name, *pp_newserver) &&\n\t\t\tstrequal(sharename, *pp_newshare)) {\n\t\treturn false;\n\t}\n\treturn true;\n}", "target": 0}
{"code": "auto ReferenceHandle::New(Local<Value> value, MaybeLocal<Object> options) -> unique_ptr<ReferenceHandle> {\n\tauto inherit = ReadOption<bool>(options, StringTable::Get().inheritUnsafe, false);\n\treturn std::make_unique<ReferenceHandle>(value, inherit);\n}", "target": 1}
{"code": "int do_set_thread_area(struct task_struct *p, int idx,\n\t\t       struct user_desc __user *u_info,\n\t\t       int can_allocate)\n{\n\tstruct user_desc info;\n\tif (copy_from_user(&info, u_info, sizeof(info)))\n\t\treturn -EFAULT;\n\tif (!tls_desc_okay(&info))\n\t\treturn -EINVAL;\n\tif (idx == -1)\n\t\tidx = info.entry_number;\n\tif (idx == -1 && can_allocate) {\n\t\tidx = get_free_idx();\n\t\tif (idx < 0)\n\t\t\treturn idx;\n\t\tif (put_user(idx, &u_info->entry_number))\n\t\t\treturn -EFAULT;\n\t}\n\tif (idx < GDT_ENTRY_TLS_MIN || idx > GDT_ENTRY_TLS_MAX)\n\t\treturn -EINVAL;\n\tset_tls_desc(p, idx, &info, 1);\n\treturn 0;\n}", "target": 0}
{"code": "TIFFNumberOfStrips(TIFF* tif)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint32 nstrips;\n    if( td->td_nstrips )\n        return td->td_nstrips;\n\tnstrips = (td->td_rowsperstrip == (uint32) -1 ? 1 :\n\t     TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip));\n\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE)\n\t\tnstrips = _TIFFMultiply32(tif, nstrips, (uint32)td->td_samplesperpixel,\n\t\t    \"TIFFNumberOfStrips\");\n\treturn (nstrips);\n}", "target": 1}
{"code": "suppress_quant_table (JPEGState* sp, int tblno)\n{\n\tJQUANT_TBL* qtbl;\n\tif ((qtbl = sp->cinfo.c.quant_tbl_ptrs[tblno]) != NULL)\n\t\tqtbl->sent_table = TRUE;\n}", "target": 0}
{"code": "static MagickBooleanType SkipDXTMipmaps(Image *image,DDSInfo *dds_info,\n  int texel_size,ExceptionInfo *exception)\n{\n  MagickOffsetType\n    offset;\n  register ssize_t\n    i;\n  size_t\n    h,\n    w;\n  if (EOFBlob(image) != MagickFalse)\n    {\n      ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n        image->filename);\n      return(MagickFalse);\n    }\n  if (dds_info->ddscaps1 & DDSCAPS_MIPMAP\n      && (dds_info->ddscaps1 & DDSCAPS_TEXTURE\n          || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))\n    {\n      w = DIV2(dds_info->width);\n      h = DIV2(dds_info->height);\n      for (i = 1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)\n      {\n        offset = (MagickOffsetType) ((w + 3) / 4) * ((h + 3) / 4) * texel_size;\n        (void) SeekBlob(image, offset, SEEK_CUR);\n        w = DIV2(w);\n        h = DIV2(h);\n      }\n    }\n  return(MagickTrue);\n}", "target": 1}
{"code": "    void appendCDATABlockCallback(const xmlChar* s, int len)\n    {\n        PendingCDATABlockCallback* callback = new PendingCDATABlockCallback;\n        callback->s = xmlStrndup(s, len);\n        callback->len = len;\n        m_callbacks.append(callback);        \n    }", "target": 0}
{"code": "static int db__message_reconnect_reset_incoming(struct mosquitto *context)\n{\n\tstruct mosquitto_client_msg *msg, *tmp;\n\tcontext->msgs_in.inflight_bytes = 0;\n\tcontext->msgs_in.inflight_bytes12 = 0;\n\tcontext->msgs_in.inflight_count = 0;\n\tcontext->msgs_in.inflight_count12 = 0;\n\tcontext->msgs_in.queued_bytes = 0;\n\tcontext->msgs_in.queued_bytes12 = 0;\n\tcontext->msgs_in.queued_count = 0;\n\tcontext->msgs_in.queued_count12 = 0;\n\tcontext->msgs_in.inflight_quota = context->msgs_in.inflight_maximum;\n\tDL_FOREACH_SAFE(context->msgs_in.inflight, msg, tmp){\n\t\tdb__msg_add_to_inflight_stats(&context->msgs_in, msg);\n\t\tif(msg->qos > 0){\n\t\t\tutil__decrement_receive_quota(context);\n\t\t}\n\t\tif(msg->qos != 2){\n\t\t\tdb__message_remove_from_inflight(&context->msgs_in, msg);\n\t\t}else{\n\t\t\tmsg->dup = 0;\n\t\t}\n\t}\n\tDL_FOREACH_SAFE(context->msgs_in.queued, msg, tmp){\n\t\tmsg->dup = 0;\n\t\tdb__msg_add_to_queued_stats(&context->msgs_in, msg);\n\t\tif(db__ready_for_flight(context, mosq_md_in, msg->qos)){\n\t\t\tswitch(msg->qos){\n\t\t\t\tcase 0:\n\t\t\t\t\tmsg->state = mosq_ms_publish_qos0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tmsg->state = mosq_ms_publish_qos1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tmsg->state = mosq_ms_publish_qos2;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdb__message_dequeue_first(context, &context->msgs_in);\n\t\t}\n\t}\n\treturn MOSQ_ERR_SUCCESS;\n}", "target": 0}
{"code": "TfLiteStatus MultiplyAndCheckOverflow(size_t a, size_t b, size_t* product) {\n  constexpr size_t size_t_bits = 8 * sizeof(size_t);\n  constexpr size_t overflow_upper_half_bit_position = size_t_bits / 2;\n  *product = a * b;\n  if (TFLITE_EXPECT_FALSE((a | b) >> overflow_upper_half_bit_position != 0)) {\n    if (a != 0 && *product / a != b) return kTfLiteError;\n  }\n  return kTfLiteOk;\n}", "target": 1}
{"code": "skip_varname(const char *s, bool aok)\n{\n\tsize_t alen;\n\tif (s && ksh_isalphx(*s)) {\n\t\twhile (*++s && ksh_isalnux(*s))\n\t\t\t;\n\t\tif (aok && *s == '[' && (alen = array_ref_len(s)))\n\t\t\ts += alen;\n\t}\n\treturn (s);\n}", "target": 0}
{"code": "ansi_step(pansi, ch)\n\tstruct ansi_state *pansi;\n\tLWCHAR ch;\n{\n\tif (pansi->hlink)\n\t{\n\t\tif (ch == '\\7')\n\t\t\treturn ANSI_END;\n\t\tif (pansi->prev_esc && ch == '\\\\')\n\t\t\treturn ANSI_END;\n\t\tpansi->prev_esc = (ch == ESC);\n\t\treturn ANSI_MID;\n\t}\n\tif (pansi->hindex >= 0)\n\t{\n\t\tstatic char hlink_prefix[] = ESCS \"]8;\";\n\t\tif (ch == hlink_prefix[pansi->hindex] ||\n\t\t    (pansi->hindex == 0 && IS_CSI_START(ch)))\n\t\t{\n\t\t\tpansi->hindex++;\n\t\t\tif (hlink_prefix[pansi->hindex] == '\\0')\n\t\t\t\tpansi->hlink = 1; \n\t\t\treturn ANSI_MID;\n\t\t}\n\t\tpansi->hindex = -1; \n\t}\n\tif (is_ansi_middle(ch))\n\t\treturn ANSI_MID;\n\tif (is_ansi_end(ch))\n\t\treturn ANSI_END;\n\treturn ANSI_ERR;\n}", "target": 1}
{"code": "void ipv4_pktinfo_prepare(const struct sock *sk, struct sk_buff *skb)\n{\n\tstruct in_pktinfo *pktinfo = PKTINFO_SKB_CB(skb);\n\tbool prepare = (inet_sk(sk)->cmsg_flags & IP_CMSG_PKTINFO) ||\n\t\t       ipv6_sk_rxinfo(sk);\n\tif (prepare && skb_rtable(skb)) {\n\t\tif (pktinfo->ipi_ifindex == LOOPBACK_IFINDEX)\n\t\t\tpktinfo->ipi_ifindex = inet_iif(skb);\n\t\tpktinfo->ipi_spec_dst.s_addr = fib_compute_spec_dst(skb);\n\t} else {\n\t\tpktinfo->ipi_ifindex = 0;\n\t\tpktinfo->ipi_spec_dst.s_addr = 0;\n\t}\n\tskb_dst_drop(skb);\n}", "target": 1}
{"code": "void rdp_read_flow_control_pdu(wStream* s, UINT16* type)\n{\n\tUINT8 pduType;\n\tStream_Read_UINT8(s, pduType); \n\t*type = pduType;\n\tStream_Seek_UINT8(s);  \n\tStream_Seek_UINT8(s);  \n\tStream_Seek_UINT8(s);  \n\tStream_Seek_UINT16(s); \n}", "target": 1}
{"code": "static bool do_write_pids(pid_t tpid, const char *contrl, const char *cg, const char *file, const char *buf)\n{\n\tint sock[2] = {-1, -1};\n\tpid_t qpid, cpid = -1;\n\tFILE *pids_file = NULL;\n\tbool answer = false, fail = false;\n\tpids_file = open_pids_file(contrl, cg);\n\tif (!pids_file)\n\t\treturn false;\n\tif (socketpair(AF_UNIX, SOCK_DGRAM, 0, sock) < 0) {\n\t\tperror(\"socketpair\");\n\t\tgoto out;\n\t}\n\tcpid = fork();\n\tif (cpid == -1)\n\t\tgoto out;\n\tif (!cpid) { \n\t\tfclose(pids_file);\n\t\tpid_from_ns_wrapper(sock[1], tpid);\n\t}\n\tconst char *ptr = buf;\n\twhile (sscanf(ptr, \"%d\", &qpid) == 1) {\n\t\tstruct ucred cred;\n\t\tchar v;\n\t\tif (write(sock[0], &qpid, sizeof(qpid)) != sizeof(qpid)) {\n\t\t\tfprintf(stderr, \"%s: error writing pid to child: %s\\n\",\n\t\t\t\t__func__, strerror(errno));\n\t\t\tgoto out;\n\t\t}\n\t\tif (recv_creds(sock[0], &cred, &v)) {\n\t\t\tif (v == '0') {\n\t\t\t\tif (fprintf(pids_file, \"%d\", (int) cred.pid) < 0)\n\t\t\t\t\tfail = true;\n\t\t\t}\n\t\t}\n\t\tptr = strchr(ptr, '\\n');\n\t\tif (!ptr)\n\t\t\tbreak;\n\t\tptr++;\n\t}\n\tqpid = -1;\n\tif (write(sock[0], &qpid ,sizeof(qpid)) != sizeof(qpid))\n\t\tfprintf(stderr, \"Warning: failed to ask child to exit\\n\");\n\tif (!fail)\n\t\tanswer = true;\nout:\n\tif (cpid != -1)\n\t\twait_for_pid(cpid);\n\tif (sock[0] != -1) {\n\t\tclose(sock[0]);\n\t\tclose(sock[1]);\n\t}\n\tif (pids_file) {\n\t\tif (fclose(pids_file) != 0)\n\t\t\tanswer = false;\n\t}\n\treturn answer;\n}", "target": 1}
{"code": "sc_pkcs15emu_add_cert(sc_pkcs15_card_t *p15card,\n\t\tint type, int authority,\n\t\tconst sc_path_t *path,\n\t\tconst sc_pkcs15_id_t *id,\n                const char *label, int obj_flags)\n{\n\tsc_pkcs15_cert_info_t *info;\n\tinfo = calloc(1, sizeof(*info));\n\tif (!info)\n\t{\n\t\tLOG_FUNC_RETURN(p15card->card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\tinfo->id\t\t= *id;\n\tinfo->authority\t\t= authority;\n\tif (path)\n\t\tinfo->path = *path;\n\treturn sc_pkcs15emu_add_object(p15card, type, label, info, NULL, obj_flags);\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(context->input(0).shape()),\n                errors::InvalidArgument(\"dim must be a scalar\"));\n    int32_t dim = context->input(0).scalar<int32_t>()();\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(context->input(0).shape()),\n                errors::InvalidArgument(\"num_results must be a scalar\"));\n    int32_t num_results = context->input(1).scalar<int32_t>()();\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(context->input(0).shape()),\n                errors::InvalidArgument(\"skip must be a scalar\"));\n    int32_t skip = context->input(2).scalar<int32_t>()();\n    OP_REQUIRES(context, dim >= 1,\n                errors::InvalidArgument(\"dim must be at least one\"));\n    OP_REQUIRES(context, dim <= sobol_data::kMaxSobolDim,\n                errors::InvalidArgument(\"dim must be at most \",\n                                        sobol_data::kMaxSobolDim));\n    OP_REQUIRES(context, num_results >= 1,\n                errors::InvalidArgument(\"num_results must be at least one\"));\n    OP_REQUIRES(context, skip >= 0,\n                errors::InvalidArgument(\"skip must be non-negative\"));\n    OP_REQUIRES(context,\n                num_results < std::numeric_limits<int32_t>::max() - skip,\n                errors::InvalidArgument(\"num_results+skip must be less than \",\n                                        std::numeric_limits<int32_t>::max()));\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(\n                       0, TensorShape({num_results, dim}), &output));\n    auto output_flat = output->flat<T>();\n    const DeviceBase::CpuWorkerThreads& worker_threads =\n        *(context->device()->tensorflow_cpu_worker_threads());\n    int num_threads = worker_threads.num_threads;\n    int block_size = std::max(\n        kMinBlockSize, static_cast<int>(std::ceil(\n                           static_cast<float>(num_results) / num_threads)));\n    worker_threads.workers->TransformRangeConcurrently(\n        block_size, num_results ,\n        [&dim, &skip, &output_flat](const int start, const int end) {\n          CalculateSobolSample<T>(dim, end - start , skip,\n                                  start, output_flat);\n        });\n  }", "target": 0}
{"code": "int ossl_dsa_check_pairwise(const DSA *dsa)\n{\n    int ret = 0;\n    BN_CTX *ctx = NULL;\n    BIGNUM *pub_key = NULL;\n    if (dsa->params.p == NULL\n        || dsa->params.g == NULL\n        || dsa->priv_key == NULL\n        || dsa->pub_key == NULL)\n        return 0;\n    ctx = BN_CTX_new_ex(dsa->libctx);\n    if (ctx == NULL)\n        goto err;\n    pub_key = BN_new();\n    if (pub_key == NULL)\n        goto err;\n    if (!ossl_dsa_generate_public_key(ctx, dsa, dsa->priv_key, pub_key))\n        goto err;\n    ret = BN_cmp(pub_key, dsa->pub_key) == 0;\nerr:\n    BN_free(pub_key);\n    BN_CTX_free(ctx);\n    return ret;\n}", "target": 1}
{"code": "read_nextline(void)\n{\nint len;\nuschar *p, *q;\nif (next_line != NULL)\n  {\n  uschar *yield = next_line;\n  next_line = NULL;\n  return yield;\n  }\nif (popto == 0)\n  {\n  pushstr *ps = pushed;\n  if (ps == NULL) error(12); else\n    {\n    popto = -1;\n    (void)sprintf(CS inbuffer, \"%s\\n\", ps->string);\n    pushed = ps->next;\n    free(ps);\n    return inbuffer;\n    }\n  }\nif (popto > 0)\n  {\n  pushstr *ps = pushed;\n  if (ps->letter == popto) popto = -1;  \n  (void)sprintf(CS inbuffer, \"%s\\n\", ps->string);\n  pushed = ps->next;\n  free(ps);\n  return inbuffer;\n  }\nif (from_type_ptr < 0) return NULL;\nfor (;;)\n  {\n  if (from_type[from_type_ptr] == FROM_MACRO)\n    {\n    if (macrocurrent->nextline == NULL)\n      {\n      macroexe *temp = macrocurrent;\n      macrocurrent = macrocurrent->prev;\n      macro_free(temp);\n      }\n    else\n      {\n      read_process_macroline(macrocurrent->nextline->string, inbuffer);\n      macrocurrent->nextline = macrocurrent->nextline->next;\n      break;\n      }\n    }\n  else\n    {\n    len = get_nextline(istack->file, inbuffer, INBUFFSIZE);\n    if (len < 0)\n      {\n      istackstr *prev = istack->prev;\n      fclose(istack->file);\n      free(istack);\n      istack = prev;\n      }\n    else\n      {\n      istack->linenumber++;\n      q = inbuffer;\n      for (;;)\n        {\n        p = q + len;\n        while (p > q && isspace(p[-1])) p--;\n        if (p - q < 3 || Ustrncmp(p - 3, \"&&&\", 3) != 0) break;\n        q = p - 3;\n        *q = 0;\n        if (istack == NULL) break;\n        len = get_nextline(istack->file, q, INBUFFSIZE - (q - inbuffer));\n        if (len < 0) break;\n        istack->linenumber++;\n        p = q;\n        while (*p == ' ' || *p == '\\t') { p++; len--; }\n        if (p > q) memmove(q, p, len + 1);\n        }\n      break;\n      }\n    }\n  if (--from_type_ptr < 0) return NULL;\n  }\nreturn inbuffer;\n}", "target": 1}
{"code": "int dns_add_HTTPS_start(struct dns_rr_nested *svcparam_buffer, struct dns_packet *packet, dns_rr_type type,\n\t\t\t\t\t\tconst char *domain, int ttl, int priority, const char *target)\n{\n\tsvcparam_buffer = dns_add_rr_nested_start(svcparam_buffer, packet, type, DNS_T_HTTPS, domain, ttl);\n\tif (svcparam_buffer == NULL) {\n\t\treturn -1;\n\t}\n\tint target_len = strnlen(target, DNS_MAX_CNAME_LEN) + 1;\n\tif (_dns_left_len(&svcparam_buffer->context) < 2 + target_len) {\n\t\treturn -1;\n\t}\n\t_dns_write_short(&svcparam_buffer->context.ptr, priority);\n\tsafe_strncpy((char *)svcparam_buffer->context.ptr, target, target_len);\n\tsvcparam_buffer->context.ptr += target_len;\n\treturn 0;\n}", "target": 1}
{"code": "QPDFWriter::enqueueObject(QPDFObjectHandle object)\n{\n    if (object.isIndirect())\n    {\n        if (object.getOwningQPDF() != &(this->pdf))\n        {\n            QTC::TC(\"qpdf\", \"QPDFWriter foreign object\");\n            throw std::logic_error(\n                \"QPDFObjectHandle from different QPDF found while writing.\"\n                \"  Use QPDF::copyForeignObject to add objects from\"\n                \" another file.\");\n        }\n\tQPDFObjGen og = object.getObjGen();\n\tif (obj_renumber.count(og) == 0)\n\t{\n\t    if (this->object_to_object_stream.count(og))\n\t    {\n\t\tint stream_id = this->object_to_object_stream[og];\n                obj_renumber[og] = 0;\n\t\tenqueueObject(this->pdf.getObjectByID(stream_id, 0));\n\t    }\n\t    else\n\t    {\n\t\tobject_queue.push_back(object);\n\t\tobj_renumber[og] = next_objid++;\n\t\tif ((og.getGen() == 0) &&\n                    this->object_stream_to_objects.count(og.getObj()))\n\t\t{\n\t\t    if (! this->linearized)\n\t\t    {\n\t\t\tassignCompressedObjectNumbers(og);\n\t\t    }\n\t\t}\n\t\telse if ((! this->direct_stream_lengths) && object.isStream())\n\t\t{\n\t\t    ++next_objid;\n\t\t}\n\t    }\n\t}\n        else if (obj_renumber[og] == 0)\n        {\n            QTC::TC(\"qpdf\", \"QPDFWriter ignore self-referential object stream\");\n        }\n    }\n    else if (object.isArray())\n    {\n\tint n = object.getArrayNItems();\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t    if (! this->linearized)\n\t    {\n\t\tenqueueObject(object.getArrayItem(i));\n\t    }\n\t}\n    }\n    else if (object.isDictionary())\n    {\n\tstd::set<std::string> keys = object.getKeys();\n\tfor (std::set<std::string>::iterator iter = keys.begin();\n\t     iter != keys.end(); ++iter)\n\t{\n\t    if (! this->linearized)\n\t    {\n\t\tenqueueObject(object.getKey(*iter));\n\t    }\n\t}\n    }\n    else\n    {\n    }\n}", "target": 0}
{"code": "static inline int r_sys_mkdirp(char *dir) {\n\tint ret = 1;\n\tconst char slash = DIRSEP;\n\tchar *path = dir;\n\tchar *ptr = path;\n\tif (*ptr == slash) {\n\t\tptr++;\n\t}\n#if __SDB_WINDOWS__\n\tchar *p = strstr (ptr, \":\\\\\");\n\tif (p) {\n\t\tptr = p + 2;\n\t}\n#endif\n\twhile ((ptr = strchr (ptr, slash))) {\n\t\t*ptr = 0;\n\t\tif (!r_sys_mkdir (path) && r_sys_mkdir_failed ()) {\n\t\t\teprintf (\"r_sys_mkdirp: fail '%s' of '%s'\\n\", path, dir);\n\t\t\t*ptr = slash;\n\t\t\treturn 0;\n\t\t}\n\t\t*ptr = slash;\n\t\tptr++;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static bool generic_new(struct nf_conn *ct, const struct sk_buff *skb,\n\t\t\tunsigned int dataoff, unsigned int *timeouts)\n{\n\treturn true;\n}", "target": 1}
{"code": "static int __tipc_nl_compat_dumpit(struct tipc_nl_compat_cmd_dump *cmd,\n\t\t\t\t   struct tipc_nl_compat_msg *msg,\n\t\t\t\t   struct sk_buff *arg)\n{\n\tint len = 0;\n\tint err;\n\tstruct sk_buff *buf;\n\tstruct nlmsghdr *nlmsg;\n\tstruct netlink_callback cb;\n\tmemset(&cb, 0, sizeof(cb));\n\tcb.nlh = (struct nlmsghdr *)arg->data;\n\tcb.skb = arg;\n\tbuf = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tbuf->sk = msg->dst_sk;\n\tdo {\n\t\tint rem;\n\t\tlen = (*cmd->dumpit)(buf, &cb);\n\t\tnlmsg_for_each_msg(nlmsg, nlmsg_hdr(buf), len, rem) {\n\t\t\tstruct nlattr **attrs;\n\t\t\terr = tipc_nlmsg_parse(nlmsg, &attrs);\n\t\t\tif (err)\n\t\t\t\tgoto err_out;\n\t\t\terr = (*cmd->format)(msg, attrs);\n\t\t\tif (err)\n\t\t\t\tgoto err_out;\n\t\t\tif (tipc_skb_tailroom(msg->rep) <= 1) {\n\t\t\t\terr = -EMSGSIZE;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t}\n\t\tskb_reset_tail_pointer(buf);\n\t\tbuf->len = 0;\n\t} while (len);\n\terr = 0;\nerr_out:\n\tkfree_skb(buf);\n\tif (err == -EMSGSIZE) {\n\t\tif ((TIPC_SKB_MAX - msg->rep->len) <= 1) {\n\t\t\tchar *tail = skb_tail_pointer(msg->rep);\n\t\t\tif (*tail != '\\0')\n\t\t\t\tsprintf(tail - sizeof(REPLY_TRUNCATED) - 1,\n\t\t\t\t\tREPLY_TRUNCATED);\n\t\t}\n\t\treturn 0;\n\t}\n\treturn err;\n}", "target": 0}
{"code": "static inline int check_sticky(struct inode *dir, struct inode *inode)\n{\n\tkuid_t fsuid = current_fsuid();\n\tif (!(dir->i_mode & S_ISVTX))\n\t\treturn 0;\n\tif (uid_eq(inode->i_uid, fsuid))\n\t\treturn 0;\n\tif (uid_eq(dir->i_uid, fsuid))\n\t\treturn 0;\n\treturn !inode_capable(inode, CAP_FOWNER);\n}", "target": 1}
{"code": "CompileResult generateBytecodeForExecution(\n    Module &M,\n    const BytecodeGenerationOptions &genOptions) {\n  std::shared_ptr<Context> context = M.shareContext();\n  CompileResult result{Success};\n  if (cl::BytecodeFormat == cl::BytecodeFormatKind::HBC) {\n    result.bytecodeProvider = hbc::BCProviderFromSrc::createBCProviderFromSrc(\n        hbc::generateBytecodeModule(&M, M.getTopLevelFunction(), genOptions));\n  } else {\n    llvm_unreachable(\"Invalid bytecode kind for execution\");\n    result = InvalidFlags;\n  }\n  return result;\n}", "target": 1}
{"code": "int khugepaged_enter_vma_merge(struct vm_area_struct *vma)\n{\n\tunsigned long hstart, hend;\n\tif (!vma->anon_vma)\n\t\treturn 0;\n\tif (vma->vm_file || vma->vm_ops)\n\t\treturn 0;\n\tVM_BUG_ON(is_linear_pfn_mapping(vma) || is_pfn_mapping(vma));\n\thstart = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;\n\thend = vma->vm_end & HPAGE_PMD_MASK;\n\tif (hstart < hend)\n\t\treturn khugepaged_enter(vma);\n\treturn 0;\n}", "target": 1}
{"code": "ossl_cipher_init(int argc, VALUE *argv, VALUE self, int mode)\n{\n    EVP_CIPHER_CTX *ctx;\n    unsigned char key[EVP_MAX_KEY_LENGTH], *p_key = NULL;\n    unsigned char iv[EVP_MAX_IV_LENGTH], *p_iv = NULL;\n    VALUE pass, init_v;\n    if(rb_scan_args(argc, argv, \"02\", &pass, &init_v) > 0){\n\tVALUE cname  = rb_class_path(rb_obj_class(self));\n\trb_warn(\"arguments for %\"PRIsVALUE\"#encrypt and %\"PRIsVALUE\"#decrypt were deprecated; \"\n                \"use %\"PRIsVALUE\"#pkcs5_keyivgen to derive key and IV\",\n                cname, cname, cname);\n\tStringValue(pass);\n\tGetCipher(self, ctx);\n\tif (NIL_P(init_v)) memcpy(iv, \"OpenSSL for Ruby rulez!\", sizeof(iv));\n\telse{\n\t    StringValue(init_v);\n\t    if (EVP_MAX_IV_LENGTH > RSTRING_LEN(init_v)) {\n\t\tmemset(iv, 0, EVP_MAX_IV_LENGTH);\n\t\tmemcpy(iv, RSTRING_PTR(init_v), RSTRING_LEN(init_v));\n\t    }\n\t    else memcpy(iv, RSTRING_PTR(init_v), sizeof(iv));\n\t}\n\tEVP_BytesToKey(EVP_CIPHER_CTX_cipher(ctx), EVP_md5(), iv,\n\t\t       (unsigned char *)RSTRING_PTR(pass), RSTRING_LENINT(pass), 1, key, NULL);\n\tp_key = key;\n\tp_iv = iv;\n    }\n    else {\n\tGetCipher(self, ctx);\n    }\n    if (EVP_CipherInit_ex(ctx, NULL, NULL, p_key, p_iv, mode) != 1) {\n\tossl_raise(eCipherError, NULL);\n    }\n    if (p_key)\n\trb_ivar_set(self, id_key_set, Qtrue);\n    return self;\n}", "target": 0}
{"code": "set_cs_start(char *line)\n{\n  char *p, *q, *r;\n  if ((p = strstr(line, \"string currentfile\"))) {\n    if (!strstr(line, \"readstring\"))\n      return;\n    *p = '\\0';\t\t\t\t\t  \n    q = strrchr(line, '/');\n    if (q) {\n      r = cs_start;\n      ++q;\n      while (!isspace(*q) && *q != '{')\n\t*r++ = *q++;\n      *r = '\\0';\n    }\n    *p = 's';\t\t\t\t\t  \n  }\n}", "target": 1}
{"code": "static int snd_ctl_elem_user_tlv(struct snd_kcontrol *kcontrol,\n\t\t\t\t int op_flag,\n\t\t\t\t unsigned int size,\n\t\t\t\t unsigned int __user *tlv)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\tint change = 0;\n\tvoid *new_data;\n\tif (op_flag > 0) {\n\t\tif (size > 1024 * 128)\t\n\t\t\treturn -EINVAL;\n\t\tnew_data = memdup_user(tlv, size);\n\t\tif (IS_ERR(new_data))\n\t\t\treturn PTR_ERR(new_data);\n\t\tchange = ue->tlv_data_size != size;\n\t\tif (!change)\n\t\t\tchange = memcmp(ue->tlv_data, new_data, size);\n\t\tkfree(ue->tlv_data);\n\t\tue->tlv_data = new_data;\n\t\tue->tlv_data_size = size;\n\t} else {\n\t\tif (! ue->tlv_data_size || ! ue->tlv_data)\n\t\t\treturn -ENXIO;\n\t\tif (size < ue->tlv_data_size)\n\t\t\treturn -ENOSPC;\n\t\tif (copy_to_user(tlv, ue->tlv_data, ue->tlv_data_size))\n\t\t\treturn -EFAULT;\n\t}\n\treturn change;\n}", "target": 1}
{"code": "    unsigned int readBits(int n)\n    {\n        unsigned int bit, bits;\n        if (n < 0) {\n            return -1;\n        }\n        if (n == 0) {\n            return 0;\n        }\n        if (n == 1) {\n            return readBit();\n        }\n        bit = readBit();\n        if (bit == (unsigned int)-1) {\n            return -1;\n        }\n        bit = bit << (n - 1);\n        bits = readBits(n - 1);\n        if (bits == (unsigned int)-1) {\n            return -1;\n        }\n        return bit | bits;\n    }", "target": 0}
{"code": "inline TfLiteTensor* GetTensorAtIndex(const TfLiteContext* context,\n                                      int tensor_index) {\n  if (context->tensors != nullptr) {\n    return &context->tensors[tensor_index];\n  } else {\n    return context->GetTensor(context, tensor_index);\n  }\n}", "target": 0}
{"code": "static struct btrfs_fs_devices *find_fsid_changed(\n\t\t\t\t\tstruct btrfs_super_block *disk_super)\n{\n\tstruct btrfs_fs_devices *fs_devices;\n\tlist_for_each_entry(fs_devices, &fs_uuids, fs_list) {\n\t\tif (memcmp(fs_devices->metadata_uuid, fs_devices->fsid,\n\t\t\t   BTRFS_FSID_SIZE) != 0 &&\n\t\t    memcmp(fs_devices->metadata_uuid, disk_super->metadata_uuid,\n\t\t\t   BTRFS_FSID_SIZE) == 0 &&\n\t\t    memcmp(fs_devices->fsid, disk_super->fsid,\n\t\t\t   BTRFS_FSID_SIZE) != 0) {\n\t\t\treturn fs_devices;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "static int l2tp_ip6_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t    int *uaddr_len, int peer)\n{\n\tstruct sockaddr_l2tpip6 *lsa = (struct sockaddr_l2tpip6 *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct l2tp_ip6_sock *lsk = l2tp_ip6_sk(sk);\n\tlsa->l2tp_family = AF_INET6;\n\tlsa->l2tp_flowinfo = 0;\n\tlsa->l2tp_scope_id = 0;\n\tlsa->l2tp_unused = 0;\n\tif (peer) {\n\t\tif (!lsk->peer_conn_id)\n\t\t\treturn -ENOTCONN;\n\t\tlsa->l2tp_conn_id = lsk->peer_conn_id;\n\t\tlsa->l2tp_addr = np->daddr;\n\t\tif (np->sndflow)\n\t\t\tlsa->l2tp_flowinfo = np->flow_label;\n\t} else {\n\t\tif (ipv6_addr_any(&np->rcv_saddr))\n\t\t\tlsa->l2tp_addr = np->saddr;\n\t\telse\n\t\t\tlsa->l2tp_addr = np->rcv_saddr;\n\t\tlsa->l2tp_conn_id = lsk->conn_id;\n\t}\n\tif (ipv6_addr_type(&lsa->l2tp_addr) & IPV6_ADDR_LINKLOCAL)\n\t\tlsa->l2tp_scope_id = sk->sk_bound_dev_if;\n\t*uaddr_len = sizeof(*lsa);\n\treturn 0;\n}", "target": 0}
{"code": "static CURLcode imap_parse_url_path(struct connectdata *conn)\n{\n  struct imap_conn *imapc = &conn->proto.imapc;\n  struct SessionHandle *data = conn->data;\n  const char *path = data->state.path;\n  int len;\n  if(!*path)\n    path = \"INBOX\";\n  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);\n  if(!imapc->mailbox)\n    return CURLE_OUT_OF_MEMORY;\n  return CURLE_OK;\n}", "target": 1}
{"code": "Error HeifContext::get_id_of_non_virtual_child_image(heif_item_id id, heif_item_id& out) const\n{\n  std::string image_type = m_heif_file->get_item_type(id);\n  if (image_type==\"grid\" ||\n      image_type==\"iden\" ||\n      image_type==\"iovl\") {\n    auto iref_box = m_heif_file->get_iref_box();\n    if (!iref_box) {\n      return Error(heif_error_Invalid_input,\n                   heif_suberror_No_item_data,\n                   \"Derived image does not reference any other image items\");\n    }\n    std::vector<heif_item_id> image_references = iref_box->get_references(id, fourcc(\"dimg\"));\n    if (image_references.empty()) {\n      return Error(heif_error_Invalid_input,\n                   heif_suberror_No_item_data,\n                   \"Derived image does not reference any other image items\");\n    }\n    else {\n      return get_id_of_non_virtual_child_image(image_references[0], out);\n    }\n  }\n  else {\n    out = id;\n    return Error::Ok;\n  }\n}", "target": 0}
{"code": "  explicit QuantizeAndDequantizeV2Op(OpKernelConstruction* ctx)\n      : OpKernel(ctx) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"signed_input\", &signed_input_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"axis\", &axis_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"num_bits\", &num_bits_));\n    OP_REQUIRES(ctx, num_bits_ > 0 && num_bits_ < (signed_input_ ? 62 : 63),\n                errors::InvalidArgument(\"num_bits is out of range: \", num_bits_,\n                                        \" with signed_input_ \", signed_input_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"range_given\", &range_given_));\n    string round_mode_string;\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"round_mode\", &round_mode_string));\n    OP_REQUIRES(\n        ctx,\n        (round_mode_string == \"HALF_UP\" || round_mode_string == \"HALF_TO_EVEN\"),\n        errors::InvalidArgument(\"Round mode string must be \"\n                                \"'HALF_UP' or \"\n                                \"'HALF_TO_EVEN', is '\" +\n                                round_mode_string + \"'\"));\n    if (round_mode_string == \"HALF_UP\") {\n      round_mode_ = ROUND_HALF_UP;\n    } else if (round_mode_string == \"HALF_TO_EVEN\") {\n      round_mode_ = ROUND_HALF_TO_EVEN;\n    }\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"narrow_range\", &narrow_range_));\n  }", "target": 1}
{"code": "bool WebContents::SendIPCMessageToFrame(bool internal,\n                                        int32_t frame_id,\n                                        const std::string& channel,\n                                        v8::Local<v8::Value> args) {\n  v8::Isolate* isolate = JavascriptEnvironment::GetIsolate();\n  blink::CloneableMessage message;\n  if (!gin::ConvertFromV8(isolate, args, &message)) {\n    isolate->ThrowException(v8::Exception::Error(\n        gin::StringToV8(isolate, \"Failed to serialize arguments\")));\n    return false;\n  }\n  auto frames = web_contents()->GetAllFrames();\n  auto iter = std::find_if(frames.begin(), frames.end(), [frame_id](auto* f) {\n    return f->GetRoutingID() == frame_id;\n  });\n  if (iter == frames.end())\n    return false;\n  if (!(*iter)->IsRenderFrameLive())\n    return false;\n  mojo::AssociatedRemote<mojom::ElectronRenderer> electron_renderer;\n  (*iter)->GetRemoteAssociatedInterfaces()->GetInterface(&electron_renderer);\n  electron_renderer->Message(internal, channel, std::move(message),\n                             0 );\n  return true;\n}", "target": 1}
{"code": "bool CSecurityTLS::processMsg(CConnection* cc)\n{\n  rdr::InStream* is = cc->getInStream();\n  rdr::OutStream* os = cc->getOutStream();\n  client = cc;\n  initGlobal();\n  if (!session) {\n    if (!is->checkNoWait(1))\n      return false;\n    if (is->readU8() == 0) {\n      rdr::U32 result = is->readU32();\n      CharArray reason;\n      if (result == secResultFailed || result == secResultTooMany)\n        reason.buf = is->readString();\n      else\n        reason.buf = strDup(\"Authentication failure (protocol error)\");\n      throw AuthFailureException(reason.buf);\n    }\n    if (gnutls_init(&session, GNUTLS_CLIENT) != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_init failed\");\n    if (gnutls_set_default_priority(session) != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_set_default_priority failed\");\n    setParam();\n  }\n  rdr::TLSInStream *tlsis = new rdr::TLSInStream(is, session);\n  rdr::TLSOutStream *tlsos = new rdr::TLSOutStream(os, session);\n  int err;\n  err = gnutls_handshake(session);\n  if (err != GNUTLS_E_SUCCESS) {\n    delete tlsis;\n    delete tlsos;\n    if (!gnutls_error_is_fatal(err))\n      return false;\n    vlog.error(\"TLS Handshake failed: %s\\n\", gnutls_strerror (err));\n    shutdown(false);\n    throw AuthFailureException(\"TLS Handshake failed\");\n  }\n  checkSession();\n  cc->setStreams(fis = tlsis, fos = tlsos);\n  return true;\n}", "target": 1}
{"code": "nvkm_vmm_node_delete(struct nvkm_vmm *vmm, struct nvkm_vma *vma)\n{\n\tnvkm_vmm_node_remove(vmm, vma);\n\tlist_del(&vma->head);\n\tkfree(vma);\n}", "target": 0}
{"code": "static bool disconnect_cb(struct io *io, void *user_data)\n{\n\tstruct bt_att_chan *chan = user_data;\n\tstruct bt_att *att = chan->att;\n\tint err;\n\tsocklen_t len;\n\tlen = sizeof(err);\n\tif (getsockopt(chan->fd, SOL_SOCKET, SO_ERROR, &err, &len) < 0) {\n\t\tutil_debug(chan->att->debug_callback, chan->att->debug_data,\n\t\t\t\t\t\"(chan %p) Failed to obtain disconnect\"\n\t\t\t\t\t\" error: %s\", chan, strerror(errno));\n\t\terr = 0;\n\t}\n\tutil_debug(chan->att->debug_callback, chan->att->debug_data,\n\t\t\t\t\t\"Channel %p disconnected: %s\",\n\t\t\t\t\tchan, strerror(err));\n\tqueue_remove(att->chans, chan);\n\tqueue_remove_all(att->req_queue, NULL, NULL, disc_att_send_op);\n\tqueue_remove_all(att->ind_queue, NULL, NULL, disc_att_send_op);\n\tqueue_remove_all(att->write_queue, NULL, NULL, disc_att_send_op);\n\tif (chan->pending_req) {\n\t\tdisc_att_send_op(chan->pending_req);\n\t\tchan->pending_req = NULL;\n\t}\n\tif (chan->pending_ind) {\n\t\tdisc_att_send_op(chan->pending_ind);\n\t\tchan->pending_ind = NULL;\n\t}\n\tbt_att_chan_free(chan);\n\tif (!queue_isempty(att->chans))\n\t\treturn false;\n\tbt_att_ref(att);\n\tqueue_foreach(att->disconn_list, disconn_handler, INT_TO_PTR(err));\n\tbt_att_unregister_all(att);\n\tbt_att_unref(att);\n\treturn false;\n}", "target": 1}
{"code": "static int stream_thunk(void *buf, size_t size, void *data)\n{\n\tint error = 0;\n\tstruct push_packbuilder_payload *payload = data;\n\tif ((error = payload->stream->write(payload->stream, (const char *)buf, size)) < 0)\n\t\treturn error;\n\tif (payload->cb) {\n\t\tdouble current_time = git__timer();\n\t\tpayload->last_bytes += size;\n\t\tif ((current_time - payload->last_progress_report_time) >= MIN_PROGRESS_UPDATE_INTERVAL) {\n\t\t\tpayload->last_progress_report_time = current_time;\n\t\t\terror = payload->cb(payload->pb->nr_written, payload->pb->nr_objects, payload->last_bytes, payload->cb_payload);\n\t\t}\n\t}\n\treturn error;\n}", "target": 0}
{"code": "static int fsmMkfile(rpmfi fi, const char *dest, rpmfiles files,\n\t\t     rpmpsm psm, int nodigest, int *setmeta,\n\t\t     int * firsthardlink)\n{\n    int rc = 0;\n    int numHardlinks = rpmfiFNlink(fi);\n    if (numHardlinks > 1) {\n\tif (*firsthardlink < 0) {\n\t    *firsthardlink = rpmfiFX(fi);\n\t    rc = expandRegular(fi, dest, psm, nodigest, 1);\n\t} else {\n\t    char *fn = rpmfilesFN(files, *firsthardlink);\n\t    rc = link(fn, dest);\n\t    if (rc < 0) {\n\t\trc = RPMERR_LINK_FAILED;\n\t    }\n\t    free(fn);\n\t}\n    }\n    if (numHardlinks<=1) {\n\tif (!rc)\n\t    rc = expandRegular(fi, dest, psm, nodigest, 0);\n    } else if (rpmfiArchiveHasContent(fi)) {\n\tif (!rc)\n\t    rc = expandRegular(fi, dest, psm, nodigest, 0);\n\t*firsthardlink = -1;\n    } else {\n\t*setmeta = 0;\n    }\n    return rc;\n}", "target": 1}
{"code": "static void inet6_net_exit(struct net *net)\n{\n#ifdef CONFIG_PROC_FS\n\tudp6_proc_exit(net);\n\ttcp6_proc_exit(net);\n\tac6_proc_exit(net);\n#endif\n}", "target": 0}
{"code": "static int compat_setdrvprm(int drive,\n\t\t\t    struct compat_floppy_drive_params __user *arg)\n{\n\tstruct compat_floppy_drive_params v;\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (copy_from_user(&v, arg, sizeof(struct compat_floppy_drive_params)))\n\t\treturn -EFAULT;\n\tmutex_lock(&floppy_mutex);\n\tUDP->cmos = v.cmos;\n\tUDP->max_dtr = v.max_dtr;\n\tUDP->hlt = v.hlt;\n\tUDP->hut = v.hut;\n\tUDP->srt = v.srt;\n\tUDP->spinup = v.spinup;\n\tUDP->spindown = v.spindown;\n\tUDP->spindown_offset = v.spindown_offset;\n\tUDP->select_delay = v.select_delay;\n\tUDP->rps = v.rps;\n\tUDP->tracks = v.tracks;\n\tUDP->timeout = v.timeout;\n\tUDP->interleave_sect = v.interleave_sect;\n\tUDP->max_errors = v.max_errors;\n\tUDP->flags = v.flags;\n\tUDP->read_track = v.read_track;\n\tmemcpy(UDP->autodetect, v.autodetect, sizeof(v.autodetect));\n\tUDP->checkfreq = v.checkfreq;\n\tUDP->native_format = v.native_format;\n\tmutex_unlock(&floppy_mutex);\n\treturn 0;\n}", "target": 0}
{"code": "static int em_ret_near_imm(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tctxt->dst.type = OP_REG;\n\tctxt->dst.addr.reg = &ctxt->_eip;\n\tctxt->dst.bytes = ctxt->op_bytes;\n\trc = emulate_pop(ctxt, &ctxt->dst.val, ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trsp_increment(ctxt, ctxt->src.val);\n\treturn X86EMUL_CONTINUE;\n}", "target": 1}
{"code": "int con_set_default_unimap(struct vc_data *vc)\n{\n\tint i, j, err = 0, err1;\n\tu16 *q;\n\tstruct uni_pagedir *p;\n\tif (dflt) {\n\t\tp = *vc->vc_uni_pagedir_loc;\n\t\tif (p == dflt)\n\t\t\treturn 0;\n\t\tdflt->refcount++;\n\t\t*vc->vc_uni_pagedir_loc = dflt;\n\t\tif (p && !--p->refcount) {\n\t\t\tcon_release_unimap(p);\n\t\t\tkfree(p);\n\t\t}\n\t\treturn 0;\n\t}\n\terr = con_do_clear_unimap(vc);\n\tif (err)\n\t\treturn err;\n\tp = *vc->vc_uni_pagedir_loc;\n\tq = dfont_unitable;\n\tfor (i = 0; i < 256; i++)\n\t\tfor (j = dfont_unicount[i]; j; j--) {\n\t\t\terr1 = con_insert_unipair(p, *(q++), i);\n\t\t\tif (err1)\n\t\t\t\terr = err1;\n\t\t}\n\tif (con_unify_unimap(vc, p)) {\n\t\tdflt = *vc->vc_uni_pagedir_loc;\n\t\treturn err;\n\t}\n\tfor (i = 0; i <= 3; i++)\n\t\tset_inverse_transl(vc, p, i);\t\n\tset_inverse_trans_unicode(vc, p);\n\tdflt = p;\n\treturn err;\n}", "target": 0}
{"code": "TfLiteStatus SimpleStatefulOp::Prepare(TfLiteContext* context,\n                                       TfLiteNode* node) {\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n  const TfLiteTensor* input = tflite::GetInput(context, node, kInputTensor);\n  if (input->type != kTfLiteUInt8) return kTfLiteError;\n  if (NumElements(input->dims) == 0) return kTfLiteError;\n  TF_LITE_ENSURE_STATUS(context->RequestScratchBufferInArena(\n      context, sizeof(uint8_t) * NumElements(input->dims),\n      &data->sorting_buffer));\n  data->invoke_count = reinterpret_cast<int*>(\n      context->AllocatePersistentBuffer(context, sizeof(int)));\n  *data->invoke_count = 0;\n  return kTfLiteOk;\n}", "target": 1}
{"code": "int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src)\n{\n\tflush_fp_to_thread(src);\n\tflush_altivec_to_thread(src);\n\tflush_vsx_to_thread(src);\n\tflush_spe_to_thread(src);\n\t__switch_to_tm(src);\n\ttm_recheckpoint_new_task(src);\n\t*dst = *src;\n\tclear_task_ebb(dst);\n\treturn 0;\n}", "target": 0}
{"code": "static void dump_usage_categories_info(Formatter *formatter, const rgw_usage_log_entry& entry, map<string, bool> *categories)\n{\n  formatter->open_array_section(\"categories\");\n  map<string, rgw_usage_data>::const_iterator uiter;\n  for (uiter = entry.usage_map.begin(); uiter != entry.usage_map.end(); ++uiter) {\n    if (categories && !categories->empty() && !categories->count(uiter->first))\n      continue;\n    const rgw_usage_data& usage = uiter->second;\n    formatter->open_object_section(\"Entry\");\n    encode_json(\"Category\", uiter->first, formatter);\n    encode_json(\"BytesSent\", usage.bytes_sent, formatter);\n    encode_json(\"BytesReceived\", usage.bytes_received, formatter);\n    encode_json(\"Ops\", usage.ops, formatter);\n    encode_json(\"SuccessfulOps\", usage.successful_ops, formatter);\n    formatter->close_section(); \n  }\n  formatter->close_section(); \n}", "target": 0}
{"code": "static void timer_enter_running(Timer *t) {\n        _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL;\n        int r;\n        assert(t);\n        if (unit_stop_pending(UNIT(t)))\n                return;\n        r = manager_add_job(UNIT(t)->manager, JOB_START, UNIT_TRIGGER(UNIT(t)),\n                            JOB_REPLACE, true, &error, NULL);\n        if (r < 0)\n                goto fail;\n        dual_timestamp_get(&t->last_trigger);\n        if (t->stamp_path)\n                touch_file(t->stamp_path, true, t->last_trigger.realtime, UID_INVALID, GID_INVALID, 0);\n        timer_set_state(t, TIMER_RUNNING);\n        return;\nfail:\n        log_unit_warning(UNIT(t), \"Failed to queue unit startup job: %s\", bus_error_message(&error, r));\n        timer_enter_dead(t, TIMER_FAILURE_RESOURCES);\n}", "target": 1}
{"code": "static void get_icu_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS) \n{\n\tconst char* loc_name        \t= NULL;\n\tint         loc_name_len    \t= 0;\n\tchar*       tag_value\t\t= NULL;\n\tchar*       empty_result\t= \"\";\n\tint         result    \t\t= 0;\n\tchar*       msg        \t\t= NULL;\n\tUErrorCode  status          \t= U_ZERO_ERROR;\n\tintl_error_reset( NULL TSRMLS_CC );\n\tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, \"s\",\n\t&loc_name ,&loc_name_len ) == FAILURE) {\n\t\tspprintf(&msg , 0, \"locale_get_%s : unable to parse input params\", tag_name );\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,  msg , 1 TSRMLS_CC );\n\t\tefree(msg);\n\t\tRETURN_FALSE;\n    }\n\tif(loc_name_len == 0) {\n\t\tloc_name = intl_locale_get_default(TSRMLS_C);\n\t}\n\ttag_value = get_icu_value_internal( loc_name , tag_name , &result ,0);\n\tif( result == -1 ) {\n\t\tif( tag_value){\n\t\t\tefree( tag_value);\n\t\t}\n\t\tRETURN_STRING( empty_result , TRUE);\n\t}\n\tif( tag_value){\n\t\tRETURN_STRING( tag_value , FALSE);\n\t}\n\tif( result ==0) {\n\t\tspprintf(&msg , 0, \"locale_get_%s : unable to get locale %s\", tag_name , tag_name );\n\t\tintl_error_set( NULL, status, msg , 1 TSRMLS_CC );\n\t\tefree(msg);\n\t\tRETURN_NULL();\n\t}\n}", "target": 1}
{"code": "static void fdc_specify(void)\n{\n\tunsigned char spec1;\n\tunsigned char spec2;\n\tunsigned long srt;\n\tunsigned long hlt;\n\tunsigned long hut;\n\tunsigned long dtr = NOMINAL_DTR;\n\tunsigned long scale_dtr = NOMINAL_DTR;\n\tint hlt_max_code = 0x7f;\n\tint hut_max_code = 0xf;\n\tif (FDCS->need_configure && FDCS->version >= FDC_82072A) {\n\t\tfdc_configure();\n\t\tFDCS->need_configure = 0;\n\t}\n\tswitch (raw_cmd->rate & 0x03) {\n\tcase 3:\n\t\tdtr = 1000;\n\t\tbreak;\n\tcase 1:\n\t\tdtr = 300;\n\t\tif (FDCS->version >= FDC_82078) {\n\t\t\toutput_byte(FD_DRIVESPEC);\n\t\t\tif (need_more_output() == MORE_OUTPUT) {\n\t\t\t\toutput_byte(UNIT(current_drive));\n\t\t\t\toutput_byte(0xc0);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tdtr = 250;\n\t\tbreak;\n\t}\n\tif (FDCS->version >= FDC_82072) {\n\t\tscale_dtr = dtr;\n\t\thlt_max_code = 0x00;\t\n\t\thut_max_code = 0x0;\t\n\t}\n\tsrt = 16 - DIV_ROUND_UP(DP->srt * scale_dtr / 1000, NOMINAL_DTR);\n\tif (slow_floppy)\n\t\tsrt = srt / 4;\n\tSUPBOUND(srt, 0xf);\n\tINFBOUND(srt, 0);\n\thlt = DIV_ROUND_UP(DP->hlt * scale_dtr / 2, NOMINAL_DTR);\n\tif (hlt < 0x01)\n\t\thlt = 0x01;\n\telse if (hlt > 0x7f)\n\t\thlt = hlt_max_code;\n\thut = DIV_ROUND_UP(DP->hut * scale_dtr / 16, NOMINAL_DTR);\n\tif (hut < 0x1)\n\t\thut = 0x1;\n\telse if (hut > 0xf)\n\t\thut = hut_max_code;\n\tspec1 = (srt << 4) | hut;\n\tspec2 = (hlt << 1) | (use_virtual_dma & 1);\n\tif (FDCS->spec1 != spec1 || FDCS->spec2 != spec2) {\n\t\toutput_byte(FD_SPECIFY);\n\t\toutput_byte(FDCS->spec1 = spec1);\n\t\toutput_byte(FDCS->spec2 = spec2);\n\t}\n}\t\t\t\t", "target": 0}
{"code": "void AuthenticationFeature::validateOptions(std::shared_ptr<ProgramOptions> options) {\n  if (!_jwtSecretKeyfileProgramOption.empty() && !_jwtSecretFolderProgramOption.empty()) {\n    LOG_TOPIC(\"d3515\", FATAL, Logger::STARTUP)\n        << \"please specify either '--server.jwt-\"\n           \"secret-keyfile' or '--server.jwt-secret-folder' but not both.\";\n    FATAL_ERROR_EXIT();\n  }\n  if (!_jwtSecretKeyfileProgramOption.empty() || !_jwtSecretFolderProgramOption.empty()) {\n    Result res = loadJwtSecretsFromFile();\n    if (res.fail()) {\n      LOG_TOPIC(\"d3617\", FATAL, Logger::STARTUP) << res.errorMessage();\n      FATAL_ERROR_EXIT();\n    }\n  }\n  if (!_jwtSecretProgramOption.empty()) {\n    if (_jwtSecretProgramOption.length() > _maxSecretLength) {\n      LOG_TOPIC(\"9abfc\", FATAL, arangodb::Logger::STARTUP)\n          << \"Given JWT secret too long. Max length is \" << _maxSecretLength;\n      FATAL_ERROR_EXIT();\n    }\n  }\n  if (_sessionTimeout <= 1.0) {\n    LOG_TOPIC(\"85046\", FATAL, arangodb::Logger::AUTHENTICATION)\n        << \"--server.session-timeout has an invalid value: \" << _sessionTimeout;\n    FATAL_ERROR_EXIT();\n  }\n  if (options->processingResult().touched(\"server.jwt-secret\")) {\n    LOG_TOPIC(\"1aaae\", WARN, arangodb::Logger::AUTHENTICATION)\n        << \"--server.jwt-secret is insecure. Use --server.jwt-secret-keyfile \"\n           \"instead.\";\n  }\n}", "target": 0}
{"code": "fetch_var_cell_from_buf(buf_t *buf, var_cell_t **out, int linkproto)\n{\n  char hdr[VAR_CELL_MAX_HEADER_SIZE];\n  var_cell_t *result;\n  uint8_t command;\n  uint16_t length;\n  const int wide_circ_ids = linkproto >= MIN_LINK_PROTO_FOR_WIDE_CIRC_IDS;\n  const int circ_id_len = get_circ_id_size(wide_circ_ids);\n  const unsigned header_len = get_var_cell_header_size(wide_circ_ids);\n  check();\n  *out = NULL;\n  if (buf->datalen < header_len)\n    return 0;\n  peek_from_buf(hdr, header_len, buf);\n  command = get_uint8(hdr + circ_id_len);\n  if (!(cell_command_is_var_length(command, linkproto)))\n    return 0;\n  length = ntohs(get_uint16(hdr + circ_id_len + 1));\n  if (buf->datalen < (size_t)(header_len+length))\n    return 1;\n  result = var_cell_new(length);\n  result->command = command;\n  if (wide_circ_ids)\n    result->circ_id = ntohl(get_uint32(hdr));\n  else\n    result->circ_id = ntohs(get_uint16(hdr));\n  buf_remove_from_front(buf, header_len);\n  peek_from_buf((char*) result->payload, length, buf);\n  buf_remove_from_front(buf, length);\n  check();\n  *out = result;\n  return 1;\n}", "target": 0}
{"code": "static int __do_page_fault(struct mm_struct *mm, unsigned long addr,\n\t\t\t   unsigned int mm_flags, unsigned long vm_flags,\n\t\t\t   struct task_struct *tsk)\n{\n\tstruct vm_area_struct *vma;\n\tint fault;\n\tvma = find_vma(mm, addr);\n\tfault = VM_FAULT_BADMAP;\n\tif (unlikely(!vma))\n\t\tgoto out;\n\tif (unlikely(vma->vm_start > addr))\n\t\tgoto check_stack;\ngood_area:\n\tif (!(vma->vm_flags & vm_flags)) {\n\t\tfault = VM_FAULT_BADACCESS;\n\t\tgoto out;\n\t}\n\treturn handle_mm_fault(mm, vma, addr & PAGE_MASK, mm_flags);\ncheck_stack:\n\tif (vma->vm_flags & VM_GROWSDOWN && !expand_stack(vma, addr))\n\t\tgoto good_area;\nout:\n\treturn fault;\n}", "target": 1}
{"code": "static int do_anonymous_page(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long address, pte_t *page_table, pmd_t *pmd,\n\t\tunsigned int flags)\n{\n\tstruct mem_cgroup *memcg;\n\tstruct page *page;\n\tspinlock_t *ptl;\n\tpte_t entry;\n\tpte_unmap(page_table);\n\tif (vma->vm_flags & VM_SHARED)\n\t\treturn VM_FAULT_SIGBUS;\n\tif (check_stack_guard_page(vma, address) < 0)\n\t\treturn VM_FAULT_SIGSEGV;\n\tif (!(flags & FAULT_FLAG_WRITE) && !mm_forbids_zeropage(mm)) {\n\t\tentry = pte_mkspecial(pfn_pte(my_zero_pfn(address),\n\t\t\t\t\t\tvma->vm_page_prot));\n\t\tpage_table = pte_offset_map_lock(mm, pmd, address, &ptl);\n\t\tif (!pte_none(*page_table))\n\t\t\tgoto unlock;\n\t\tgoto setpte;\n\t}\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\tgoto oom;\n\tpage = alloc_zeroed_user_highpage_movable(vma, address);\n\tif (!page)\n\t\tgoto oom;\n\tif (mem_cgroup_try_charge(page, mm, GFP_KERNEL, &memcg))\n\t\tgoto oom_free_page;\n\t__SetPageUptodate(page);\n\tentry = mk_pte(page, vma->vm_page_prot);\n\tif (vma->vm_flags & VM_WRITE)\n\t\tentry = pte_mkwrite(pte_mkdirty(entry));\n\tpage_table = pte_offset_map_lock(mm, pmd, address, &ptl);\n\tif (!pte_none(*page_table))\n\t\tgoto release;\n\tinc_mm_counter_fast(mm, MM_ANONPAGES);\n\tpage_add_new_anon_rmap(page, vma, address);\n\tmem_cgroup_commit_charge(page, memcg, false);\n\tlru_cache_add_active_or_unevictable(page, vma);\nsetpte:\n\tset_pte_at(mm, address, page_table, entry);\n\tupdate_mmu_cache(vma, address, page_table);\nunlock:\n\tpte_unmap_unlock(page_table, ptl);\n\treturn 0;\nrelease:\n\tmem_cgroup_cancel_charge(page, memcg);\n\tpage_cache_release(page);\n\tgoto unlock;\noom_free_page:\n\tpage_cache_release(page);\noom:\n\treturn VM_FAULT_OOM;\n}", "target": 0}
{"code": "int genl_register_family(struct genl_family *family)\n{\n\tint err, i;\n\tint start = GENL_START_ALLOC, end = GENL_MAX_ID;\n\terr = genl_validate_ops(family);\n\tif (err)\n\t\treturn err;\n\tgenl_lock_all();\n\tif (genl_family_find_byname(family->name)) {\n\t\terr = -EEXIST;\n\t\tgoto errout_locked;\n\t}\n\tif (family == &genl_ctrl) {\n\t\tstart = end = GENL_ID_CTRL;\n\t} else if (strcmp(family->name, \"pmcraid\") == 0) {\n\t\tstart = end = GENL_ID_PMCRAID;\n\t} else if (strcmp(family->name, \"VFS_DQUOT\") == 0) {\n\t\tstart = end = GENL_ID_VFS_DQUOT;\n\t}\n\tif (family->maxattr && !family->parallel_ops) {\n\t\tfamily->attrbuf = kmalloc_array(family->maxattr + 1,\n\t\t\t\t\t\tsizeof(struct nlattr *),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (family->attrbuf == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto errout_locked;\n\t\t}\n\t} else\n\t\tfamily->attrbuf = NULL;\n\tfamily->id = idr_alloc(&genl_fam_idr, family,\n\t\t\t       start, end + 1, GFP_KERNEL);\n\tif (family->id < 0) {\n\t\terr = family->id;\n\t\tgoto errout_locked;\n\t}\n\terr = genl_validate_assign_mc_groups(family);\n\tif (err)\n\t\tgoto errout_remove;\n\tgenl_unlock_all();\n\tgenl_ctrl_event(CTRL_CMD_NEWFAMILY, family, NULL, 0);\n\tfor (i = 0; i < family->n_mcgrps; i++)\n\t\tgenl_ctrl_event(CTRL_CMD_NEWMCAST_GRP, family,\n\t\t\t\t&family->mcgrps[i], family->mcgrp_offset + i);\n\treturn 0;\nerrout_remove:\n\tidr_remove(&genl_fam_idr, family->id);\n\tkfree(family->attrbuf);\nerrout_locked:\n\tgenl_unlock_all();\n\treturn err;\n}", "target": 1}
{"code": "int infra_ip_ratelimit_inc(struct infra_cache* infra,\n\tstruct sockaddr_storage* addr, socklen_t addrlen, time_t timenow,\n\tint has_cookie, int backoff, struct sldns_buffer* buffer)\n{\n\tint max;\n\tstruct lruhash_entry* entry;\n\tif(!infra_ip_ratelimit) {\n\t\treturn 1;\n\t}\n\tentry = infra_find_ip_ratedata(infra, addr, addrlen, 1);\n\tif(entry) {\n\t\tint premax = infra_rate_max(entry->data, timenow, backoff);\n\t\tint* cur = infra_rate_give_second(entry->data, timenow);\n\t\t(*cur)++;\n\t\tmax = infra_rate_max(entry->data, timenow, backoff);\n\t\tlock_rw_unlock(&entry->lock);\n\t\treturn check_ip_ratelimit(addr, addrlen, buffer, premax, max,\n\t\t\thas_cookie);\n\t}\n\tinfra_ip_create_ratedata(infra, addr, addrlen, timenow);\n\treturn 1;\n}", "target": 1}
{"code": "static char *http_get_w32(const char *url, int *code, int *rlen) {\n\tHINTERNET hInternet = InternetOpenA (\"radare2 \"R2_VERSION, INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);\n\tif (!hInternet) {\n\t\tr_sys_perror (\"InternetOpenA\");\n\t\treturn NULL;\n\t}\n\tHINTERNET hOpenUrl = InternetOpenUrlA (hInternet, url, NULL, 0, 0, 0);\n\tif (!hOpenUrl) {\n\t\tr_sys_perror (\"InternetOpenUrlA\");\n\t\tInternetCloseHandle (hInternet);\n\t\treturn NULL;\n\t}\n\tchar *ret = NULL;\n\tsize_t read_sz = 0x100000;\n\tDWORD r = 0, w = 0;\n\tbool res = true;\n\tdo {\n\t\tw += r;\n\t\tif (!res && GetLastError () == ERROR_INSUFFICIENT_BUFFER) {\n\t\t\tread_sz *= 2;\n\t\t}\n\t\tchar *tmp = realloc (ret, read_sz + w);\n\t\tif (!tmp) {\n\t\t\tR_FREE (ret);\n\t\t\tgoto exit;\n\t\t}\n\t\tret = tmp;\n\t} while (!(res = InternetReadFile (hOpenUrl, ret + w, read_sz, &r)) || r);\n\tif (w) {\n\t\tchar *tmp = realloc (ret, (size_t)w + 1);\n\t\tif (tmp) {\n\t\t\tret = tmp;\n\t\t\tret[w] = 0;\n\t\t} else {\n\t\t\tR_FREE (ret);\n\t\t}\n\t} else {\n\t\tR_FREE (ret);\n\t}\nexit:\n\tif (rlen) {\n\t\t*rlen = w;\n\t}\n\tif (code && w) {\n\t\t*code = 200;\n\t}\n\tInternetCloseHandle (hInternet);\n\tInternetCloseHandle (hOpenUrl);\n\treturn ret;\n}", "target": 0}
{"code": "int ppp_register_net_channel(struct net *net, struct ppp_channel *chan)\n{\n\tstruct channel *pch;\n\tstruct ppp_net *pn;\n\tpch = kzalloc(sizeof(struct channel), GFP_KERNEL);\n\tif (!pch)\n\t\treturn -ENOMEM;\n\tpn = ppp_pernet(net);\n\tpch->ppp = NULL;\n\tpch->chan = chan;\n\tpch->chan_net = net;\n\tchan->ppp = pch;\n\tinit_ppp_file(&pch->file, CHANNEL);\n\tpch->file.hdrlen = chan->hdrlen;\n#ifdef CONFIG_PPP_MULTILINK\n\tpch->lastseq = -1;\n#endif \n\tinit_rwsem(&pch->chan_sem);\n\tspin_lock_init(&pch->downl);\n\trwlock_init(&pch->upl);\n\tspin_lock_bh(&pn->all_channels_lock);\n\tpch->file.index = ++pn->last_channel_index;\n\tlist_add(&pch->list, &pn->new_channels);\n\tatomic_inc(&channel_count);\n\tspin_unlock_bh(&pn->all_channels_lock);\n\treturn 0;\n}", "target": 1}
{"code": "static int ep_poll_callback(wait_queue_t *wait, unsigned mode, int sync, void *key)\n{\n\tint pwake = 0;\n\tunsigned long flags;\n\tstruct epitem *epi = ep_item_from_wait(wait);\n\tstruct eventpoll *ep = epi->ep;\n\tif ((unsigned long)key & POLLFREE) {\n\t\tep_pwq_from_wait(wait)->whead = NULL;\n\t\tlist_del_init(&wait->task_list);\n\t}\n\tspin_lock_irqsave(&ep->lock, flags);\n\tif (!(epi->event.events & ~EP_PRIVATE_BITS))\n\t\tgoto out_unlock;\n\tif (key && !((unsigned long) key & epi->event.events))\n\t\tgoto out_unlock;\n\tif (unlikely(ep->ovflist != EP_UNACTIVE_PTR)) {\n\t\tif (epi->next == EP_UNACTIVE_PTR) {\n\t\t\tepi->next = ep->ovflist;\n\t\t\tep->ovflist = epi;\n\t\t}\n\t\tgoto out_unlock;\n\t}\n\tif (!ep_is_linked(&epi->rdllink))\n\t\tlist_add_tail(&epi->rdllink, &ep->rdllist);\n\tif (waitqueue_active(&ep->wq))\n\t\twake_up_locked(&ep->wq);\n\tif (waitqueue_active(&ep->poll_wait))\n\t\tpwake++;\nout_unlock:\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\tif (pwake)\n\t\tep_poll_safewake(&ep->poll_wait);\n\treturn 1;\n}", "target": 0}
{"code": "int pgpPrtParams(const uint8_t * pkts, size_t pktlen, unsigned int pkttype,\n\t\t pgpDigParams * ret)\n{\n    const uint8_t *p = pkts;\n    const uint8_t *pend = pkts + pktlen;\n    pgpDigParams digp = NULL;\n    struct pgpPkt pkt;\n    int rc = -1; \n    while (p < pend) {\n\tif (decodePkt(p, (pend - p), &pkt))\n\t    break;\n\tif (digp == NULL) {\n\t    if (pkttype && pkt.tag != pkttype) {\n\t\tbreak;\n\t    } else {\n\t\tdigp = pgpDigParamsNew(pkt.tag);\n\t    }\n\t}\n\tif (pgpPrtPkt(&pkt, digp))\n\t    break;\n\tp += (pkt.body - pkt.head) + pkt.blen;\n\tif (pkttype == PGPTAG_SIGNATURE)\n\t    break;\n    }\n    rc = (digp && (p == pend)) ? 0 : -1;\n    if (ret && rc == 0) {\n\t*ret = digp;\n    } else {\n\tpgpDigParamsFree(digp);\n    }\n    return rc;\n}", "target": 1}
{"code": "server_request_direct_streamlocal(void)\n{\n\tChannel *c = NULL;\n\tchar *target, *originator;\n\tu_short originator_port;\n\ttarget = packet_get_string(NULL);\n\toriginator = packet_get_string(NULL);\n\toriginator_port = packet_get_int();\n\tpacket_check_eom();\n\tdebug(\"server_request_direct_streamlocal: originator %s port %d, target %s\",\n\t    originator, originator_port, target);\n\tif ((options.allow_streamlocal_forwarding & FORWARD_LOCAL) != 0 &&\n\t    !no_port_forwarding_flag && !options.disable_forwarding) {\n\t\tc = channel_connect_to_path(target,\n\t\t    \"direct-streamlocal@openssh.com\", \"direct-streamlocal\");\n\t} else {\n\t\tlogit(\"refused streamlocal port forward: \"\n\t\t    \"originator %s port %d, target %s\",\n\t\t    originator, originator_port, target);\n\t}\n\tfree(originator);\n\tfree(target);\n\treturn c;\n}", "target": 1}
{"code": "static BOOL nsc_rle_decompress_data(NSC_CONTEXT* context)\n{\n\tif (!context)\n\t\treturn FALSE;\n\tBYTE* rle = context->Planes;\n\tWINPR_ASSERT(rle);\n\tfor (size_t i = 0; i < 4; i++)\n\t{\n\t\tconst UINT32 originalSize = context->OrgByteCount[i];\n\t\tconst UINT32 planeSize = context->PlaneByteCount[i];\n\t\tif (planeSize == 0)\n\t\t{\n\t\t\tif (context->priv->PlaneBuffersLength < originalSize)\n\t\t\t\treturn FALSE;\n\t\t\tFillMemory(context->priv->PlaneBuffers[i], originalSize, 0xFF);\n\t\t}\n\t\telse if (planeSize < originalSize)\n\t\t{\n\t\t\tif (!nsc_rle_decode(rle, context->priv->PlaneBuffers[i],\n\t\t\t                    context->priv->PlaneBuffersLength, originalSize))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (context->priv->PlaneBuffersLength < originalSize)\n\t\t\t\treturn FALSE;\n\t\t\tCopyMemory(context->priv->PlaneBuffers[i], rle, originalSize);\n\t\t}\n\t\trle += planeSize;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "static inline int ok_jpg_peek_bits(ok_jpg_decoder *decoder, int num_bits) {\n    return (int)((decoder->input_buffer_bits >> (decoder->input_buffer_bit_count - num_bits)) &\n                 ((1 << num_bits) - 1));\n}", "target": 0}
{"code": "static int can_open_delegated(struct nfs_delegation *delegation, mode_t open_flags)\n{\n\tif ((delegation->type & open_flags) != open_flags)\n\t\treturn 0;\n\tif (test_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags))\n\t\treturn 0;\n\tnfs_mark_delegation_referenced(delegation);\n\treturn 1;\n}", "target": 1}
{"code": "static void emulator_get_fpu(struct x86_emulate_ctxt *ctxt)\n{\n\tpreempt_disable();\n\tkvm_load_guest_fpu(emul_to_vcpu(ctxt));\n\tclts();\n}", "target": 0}
{"code": "_pdfioDictRead(pdfio_file_t   *pdf,\t\n               pdfio_obj_t    *obj,\t\n               _pdfio_token_t *tb,\t\n               size_t         depth)\t\n{\n  pdfio_dict_t\t\t*dict;\t\t\n  char\t\t\tkey[256];\t\n  _pdfio_value_t\tvalue;\t\t\n  PDFIO_DEBUG(\"_pdfioDictRead(pdf=%p)\\n\", pdf);\n  if ((dict = pdfioDictCreate(pdf)) == NULL)\n    return (NULL);\n  while (_pdfioTokenGet(tb, key, sizeof(key)))\n  {\n    if (!strcmp(key, \">>\"))\n    {\n      return (dict);\n    }\n    else if (key[0] != '/')\n    {\n      _pdfioFileError(pdf, \"Invalid dictionary contents.\");\n      break;\n    }\n    else if (_pdfioDictGetValue(dict, key + 1))\n    {\n      _pdfioFileError(pdf, \"Duplicate dictionary key '%s'.\", key + 1);\n      return (NULL);\n    }\n    PDFIO_DEBUG(\"_pdfioDictRead: Reading value for '%s'.\\n\", key + 1);\n    if (!_pdfioValueRead(pdf, obj, tb, &value, depth))\n    {\n      _pdfioFileError(pdf, \"Missing value for dictionary key.\");\n      break;\n    }\n    if (!_pdfioDictSetValue(dict, pdfioStringCreate(pdf, key + 1), &value))\n      break;\n  }\n  return (NULL);\n}", "target": 0}
{"code": "static int cypress_generic_port_probe(struct usb_serial_port *port)\n{\n\tstruct usb_serial *serial = port->serial;\n\tstruct cypress_private *priv;\n\tif (!port->interrupt_out_urb || !port->interrupt_in_urb) {\n\t\tdev_err(&port->dev, \"required endpoint is missing\\n\");\n\t\treturn -ENODEV;\n\t}\n\tpriv = kzalloc(sizeof(struct cypress_private), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tpriv->comm_is_ok = !0;\n\tspin_lock_init(&priv->lock);\n\tif (kfifo_alloc(&priv->write_fifo, CYPRESS_BUF_SIZE, GFP_KERNEL)) {\n\t\tkfree(priv);\n\t\treturn -ENOMEM;\n\t}\n\tif (!is_frwd(serial->dev))\n\t\tusb_reset_configuration(serial->dev);\n\tpriv->cmd_ctrl = 0;\n\tpriv->line_control = 0;\n\tpriv->termios_initialized = 0;\n\tpriv->rx_flags = 0;\n\tif (port->interrupt_out_size > 9)\n\t\tpriv->pkt_fmt = packet_format_1;\n\telse\n\t\tpriv->pkt_fmt = packet_format_2;\n\tif (interval > 0) {\n\t\tpriv->write_urb_interval = interval;\n\t\tpriv->read_urb_interval = interval;\n\t\tdev_dbg(&port->dev, \"%s - read & write intervals forced to %d\\n\",\n\t\t\t__func__, interval);\n\t} else {\n\t\tpriv->write_urb_interval = port->interrupt_out_urb->interval;\n\t\tpriv->read_urb_interval = port->interrupt_in_urb->interval;\n\t\tdev_dbg(&port->dev, \"%s - intervals: read=%d write=%d\\n\",\n\t\t\t__func__, priv->read_urb_interval,\n\t\t\tpriv->write_urb_interval);\n\t}\n\tusb_set_serial_port_data(port, priv);\n\tport->port.drain_delay = 256;\n\treturn 0;\n}", "target": 0}
{"code": "static int tipc_nl_compat_link_dump(struct tipc_nl_compat_msg *msg,\n\t\t\t\t    struct nlattr **attrs)\n{\n\tstruct nlattr *link[TIPC_NLA_LINK_MAX + 1];\n\tstruct tipc_link_info link_info;\n\tint err;\n\tif (!attrs[TIPC_NLA_LINK])\n\t\treturn -EINVAL;\n\terr = nla_parse_nested(link, TIPC_NLA_LINK_MAX, attrs[TIPC_NLA_LINK],\n\t\t\t       NULL);\n\tif (err)\n\t\treturn err;\n\tlink_info.dest = nla_get_flag(link[TIPC_NLA_LINK_DEST]);\n\tlink_info.up = htonl(nla_get_flag(link[TIPC_NLA_LINK_UP]));\n\tstrcpy(link_info.str, nla_data(link[TIPC_NLA_LINK_NAME]));\n\treturn tipc_add_tlv(msg->rep, TIPC_TLV_LINK_INFO,\n\t\t\t    &link_info, sizeof(link_info));\n}", "target": 1}
{"code": "juniper_ggsn_print(netdissect_options *ndo,\n                   const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n        struct juniper_ggsn_header {\n            uint8_t svc_id;\n            uint8_t flags_len;\n            uint8_t proto;\n            uint8_t flags;\n            uint8_t vlan_id[2];\n            uint8_t res[2];\n        };\n        const struct juniper_ggsn_header *gh;\n        l2info.pictype = DLT_JUNIPER_GGSN;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n        p+=l2info.header_len;\n        gh = (struct juniper_ggsn_header *)&l2info.cookie;\n        ND_TCHECK(*gh);\n        if (ndo->ndo_eflag) {\n            ND_PRINT((ndo, \"proto %s (%u), vlan %u: \",\n                   tok2str(juniper_protocol_values,\"Unknown\",gh->proto),\n                   gh->proto,\n                   EXTRACT_16BITS(&gh->vlan_id[0])));\n        }\n        switch (gh->proto) {\n        case JUNIPER_PROTO_IPV4:\n            ip_print(ndo, p, l2info.length);\n            break;\n        case JUNIPER_PROTO_IPV6:\n            ip6_print(ndo, p, l2info.length);\n            break;\n        default:\n            if (!ndo->ndo_eflag)\n                ND_PRINT((ndo, \"unknown GGSN proto (%u)\", gh->proto));\n        }\n        return l2info.header_len;\ntrunc:\n\tND_PRINT((ndo, \"[|juniper_services]\"));\n\treturn l2info.header_len;\n}", "target": 0}
{"code": "is_link_trusted (NautilusFile *file,\n                 gboolean      is_launcher)\n{\n    GFile *location;\n    gboolean res;\n    if (!is_launcher)\n    {\n        return TRUE;\n    }\n    if (nautilus_file_can_execute (file))\n    {\n        return TRUE;\n    }\n    res = FALSE;\n    if (nautilus_file_is_local (file))\n    {\n        location = nautilus_file_get_location (file);\n        res = nautilus_is_in_system_dir (location);\n        g_object_unref (location);\n    }\n    return res;\n}", "target": 1}
{"code": "static void _isdn_setup(struct net_device *dev)\n{\n\tisdn_net_local *lp = netdev_priv(dev);\n\tether_setup(dev);\n\tdev->flags = IFF_NOARP|IFF_POINTOPOINT;\n\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\tdev->header_ops = NULL;\n\tdev->netdev_ops = &isdn_netdev_ops;\n\tdev->tx_queue_len = 30;\n\tlp->p_encap = ISDN_NET_ENCAP_RAWIP;\n\tlp->magic = ISDN_NET_MAGIC;\n\tlp->last = lp;\n\tlp->next = lp;\n\tlp->isdn_device = -1;\n\tlp->isdn_channel = -1;\n\tlp->pre_device = -1;\n\tlp->pre_channel = -1;\n\tlp->exclusive = -1;\n\tlp->ppp_slot = -1;\n\tlp->pppbind = -1;\n\tskb_queue_head_init(&lp->super_tx_queue);\n\tlp->l2_proto = ISDN_PROTO_L2_X75I;\n\tlp->l3_proto = ISDN_PROTO_L3_TRANS;\n\tlp->triggercps = 6000;\n\tlp->slavedelay = 10 * HZ;\n\tlp->hupflags = ISDN_INHUP;\t\n\tlp->onhtime = 10;\t\n\tlp->dialmax = 1;\n\tlp->flags = ISDN_NET_CBHUP | ISDN_NET_DM_MANUAL;\n\tlp->cbdelay = 25;\t\n\tlp->dialtimeout = -1;  \n\tlp->dialwait = 5 * HZ; \n\tlp->dialstarted = 0;   \n\tlp->dialwait_timer = 0;  \n}", "target": 0}
{"code": "static int usb_enumerate_device_otg(struct usb_device *udev)\n{\n\tint err = 0;\n#ifdef\tCONFIG_USB_OTG\n\tif (!udev->bus->is_b_host\n\t\t\t&& udev->config\n\t\t\t&& udev->parent == udev->bus->root_hub) {\n\t\tstruct usb_otg_descriptor\t*desc = NULL;\n\t\tstruct usb_bus\t\t\t*bus = udev->bus;\n\t\tunsigned\t\t\tport1 = udev->portnum;\n\t\terr = __usb_get_extra_descriptor(udev->rawdescriptors[0],\n\t\t\t\tle16_to_cpu(udev->config[0].desc.wTotalLength),\n\t\t\t\tUSB_DT_OTG, (void **) &desc);\n\t\tif (err || !(desc->bmAttributes & USB_OTG_HNP))\n\t\t\treturn 0;\n\t\tdev_info(&udev->dev, \"Dual-Role OTG device on %sHNP port\\n\",\n\t\t\t\t\t(port1 == bus->otg_port) ? \"\" : \"non-\");\n\t\tif (port1 == bus->otg_port) {\n\t\t\tbus->b_hnp_enable = 1;\n\t\t\terr = usb_control_msg(udev,\n\t\t\t\tusb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_SET_FEATURE, 0,\n\t\t\t\tUSB_DEVICE_B_HNP_ENABLE,\n\t\t\t\t0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t\t\tif (err < 0) {\n\t\t\t\tdev_err(&udev->dev, \"can't set HNP mode: %d\\n\",\n\t\t\t\t\t\t\t\t\terr);\n\t\t\t\tbus->b_hnp_enable = 0;\n\t\t\t}\n\t\t} else if (desc->bLength == sizeof\n\t\t\t\t(struct usb_otg_descriptor)) {\n\t\t\terr = usb_control_msg(udev,\n\t\t\t\tusb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_SET_FEATURE, 0,\n\t\t\t\tUSB_DEVICE_A_ALT_HNP_SUPPORT,\n\t\t\t\t0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t\t\tif (err < 0)\n\t\t\t\tdev_err(&udev->dev,\n\t\t\t\t\t\"set a_alt_hnp_support failed: %d\\n\",\n\t\t\t\t\terr);\n\t\t}\n\t}\n#endif\n\treturn err;\n}", "target": 1}
{"code": "struct sock *inet_csk_clone_lock(const struct sock *sk,\n\t\t\t\t const struct request_sock *req,\n\t\t\t\t const gfp_t priority)\n{\n\tstruct sock *newsk = sk_clone_lock(sk, priority);\n\tif (newsk) {\n\t\tstruct inet_connection_sock *newicsk = inet_csk(newsk);\n\t\tnewsk->sk_state = TCP_SYN_RECV;\n\t\tnewicsk->icsk_bind_hash = NULL;\n\t\tinet_sk(newsk)->inet_dport = inet_rsk(req)->ir_rmt_port;\n\t\tinet_sk(newsk)->inet_num = inet_rsk(req)->ir_num;\n\t\tinet_sk(newsk)->inet_sport = htons(inet_rsk(req)->ir_num);\n\t\tnewsk->sk_write_space = sk_stream_write_space;\n\t\tsock_reset_flag(newsk, SOCK_RCU_FREE);\n\t\tinet_sk(newsk)->mc_list = NULL;\n\t\tnewsk->sk_mark = inet_rsk(req)->ir_mark;\n\t\tatomic64_set(&newsk->sk_cookie,\n\t\t\t     atomic64_read(&inet_rsk(req)->ir_cookie));\n\t\tnewicsk->icsk_retransmits = 0;\n\t\tnewicsk->icsk_backoff\t  = 0;\n\t\tnewicsk->icsk_probes_out  = 0;\n\t\tmemset(&newicsk->icsk_accept_queue, 0, sizeof(newicsk->icsk_accept_queue));\n\t\tsecurity_inet_csk_clone(newsk, req);\n\t}\n\treturn newsk;\n}", "target": 0}
{"code": "static void __munlock_pagevec(struct pagevec *pvec, struct zone *zone)\n{\n\tint i;\n\tint nr = pagevec_count(pvec);\n\tint delta_munlocked;\n\tstruct pagevec pvec_putback;\n\tint pgrescued = 0;\n\tpagevec_init(&pvec_putback, 0);\n\tspin_lock_irq(zone_lru_lock(zone));\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct page *page = pvec->pages[i];\n\t\tif (TestClearPageMlocked(page)) {\n\t\t\tif (__munlock_isolate_lru_page(page, false))\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\t__munlock_isolation_failed(page);\n\t\t}\n\t\tpagevec_add(&pvec_putback, pvec->pages[i]);\n\t\tpvec->pages[i] = NULL;\n\t}\n\tdelta_munlocked = -nr + pagevec_count(&pvec_putback);\n\t__mod_zone_page_state(zone, NR_MLOCK, delta_munlocked);\n\tspin_unlock_irq(zone_lru_lock(zone));\n\tpagevec_release(&pvec_putback);\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct page *page = pvec->pages[i];\n\t\tif (page) {\n\t\t\tlock_page(page);\n\t\t\tif (!__putback_lru_fast_prepare(page, &pvec_putback,\n\t\t\t\t\t&pgrescued)) {\n\t\t\t\tget_page(page); \n\t\t\t\t__munlock_isolated_page(page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tput_page(page); \n\t\t\t}\n\t\t}\n\t}\n\tif (pagevec_count(&pvec_putback))\n\t\t__putback_lru_fast(&pvec_putback, pgrescued);\n}", "target": 1}
{"code": "static void ext4_journal_commit_callback(journal_t *journal, transaction_t *txn)\n{\n\tstruct super_block\t\t*sb = journal->j_private;\n\tstruct ext4_sb_info\t\t*sbi = EXT4_SB(sb);\n\tint\t\t\t\terror = is_journal_aborted(journal);\n\tstruct ext4_journal_cb_entry\t*jce, *tmp;\n\tspin_lock(&sbi->s_md_lock);\n\tlist_for_each_entry_safe(jce, tmp, &txn->t_private_list, jce_list) {\n\t\tlist_del_init(&jce->jce_list);\n\t\tspin_unlock(&sbi->s_md_lock);\n\t\tjce->jce_func(sb, jce, error);\n\t\tspin_lock(&sbi->s_md_lock);\n\t}\n\tspin_unlock(&sbi->s_md_lock);\n}", "target": 0}
{"code": "sg_poll(struct file *filp, poll_table * wait)\n{\n\tunsigned int res = 0;\n\tSg_device *sdp;\n\tSg_fd *sfp;\n\tSg_request *srp;\n\tint count = 0;\n\tunsigned long iflags;\n\tsfp = filp->private_data;\n\tif (!sfp)\n\t\treturn POLLERR;\n\tsdp = sfp->parentdp;\n\tif (!sdp)\n\t\treturn POLLERR;\n\tpoll_wait(filp, &sfp->read_wait, wait);\n\tread_lock_irqsave(&sfp->rq_list_lock, iflags);\n\tlist_for_each_entry(srp, &sfp->rq_list, entry) {\n\t\tif ((0 == res) && (1 == srp->done) && (!srp->sg_io_owned))\n\t\t\tres = POLLIN | POLLRDNORM;\n\t\t++count;\n\t}\n\tread_unlock_irqrestore(&sfp->rq_list_lock, iflags);\n\tif (atomic_read(&sdp->detaching))\n\t\tres |= POLLHUP;\n\telse if (!sfp->cmd_q) {\n\t\tif (0 == count)\n\t\t\tres |= POLLOUT | POLLWRNORM;\n\t} else if (count < SG_MAX_QUEUE)\n\t\tres |= POLLOUT | POLLWRNORM;\n\tSCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sdp,\n\t\t\t\t      \"sg_poll: res=0x%x\\n\", (int) res));\n\treturn res;\n}", "target": 0}
{"code": "int nfc_llcp_data_received(struct nfc_dev *dev, struct sk_buff *skb)\n{\n\tstruct nfc_llcp_local *local;\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tkfree_skb(skb);\n\t\treturn -ENODEV;\n\t}\n\t__nfc_llcp_recv(local, skb);\n\tnfc_llcp_local_put(local);\n\treturn 0;\n}", "target": 0}
{"code": "static long hugetlbfs_punch_hole(struct inode *inode, loff_t offset, loff_t len)\n{\n\tstruct hstate *h = hstate_inode(inode);\n\tloff_t hpage_size = huge_page_size(h);\n\tloff_t hole_start, hole_end;\n\thole_start = round_up(offset, hpage_size);\n\thole_end = round_down(offset + len, hpage_size);\n\tif (hole_end > hole_start) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tmutex_lock(&inode->i_mutex);\n\t\ti_mmap_lock_write(mapping);\n\t\tif (!RB_EMPTY_ROOT(&mapping->i_mmap))\n\t\t\thugetlb_vmdelete_list(&mapping->i_mmap,\n\t\t\t\t\t\thole_start >> PAGE_SHIFT,\n\t\t\t\t\t\thole_end  >> PAGE_SHIFT);\n\t\ti_mmap_unlock_write(mapping);\n\t\tremove_inode_hugepages(inode, hole_start, hole_end);\n\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void FullFramePixelBuffer::setBuffer(int width, int height,\n                                     rdr::U8* data_, int stride_)\n{\n  if ((width < 0) || (width > maxPixelBufferWidth))\n    throw rfb::Exception(\"Invalid PixelBuffer width of %d pixels requested\", width);\n  if ((height < 0) || (height > maxPixelBufferHeight))\n    throw rfb::Exception(\"Invalid PixelBuffer height of %d pixels requested\", height);\n  if ((stride_ < 0) || (stride_ > maxPixelBufferStride) || (stride_ < width))\n    throw rfb::Exception(\"Invalid PixelBuffer stride of %d pixels requested\", stride_);\n  if ((width != 0) && (height != 0) && (data_ == NULL))\n    throw rfb::Exception(\"PixelBuffer requested without a valid memory area\");\n  ModifiablePixelBuffer::setSize(width, height);\n  stride = stride_;\n  data = data_;\n}", "target": 0}
{"code": "const TfLiteTensor* GetOptionalInputTensor(const TfLiteContext* context,\n                                           const TfLiteNode* node, int index) {\n  const bool use_tensor = index < node->inputs->size &&\n                          node->inputs->data[index] != kTfLiteOptionalTensor;\n  if (use_tensor) {\n    return GetMutableInput(context, node, index);\n  }\n  return nullptr;\n}", "target": 1}
{"code": "static BOOL gdi_Bitmap_Decompress(rdpContext* context, rdpBitmap* bitmap,\n                                  const BYTE* pSrcData, UINT32 DstWidth, UINT32 DstHeight,\n                                  UINT32 bpp, UINT32 length, BOOL compressed,\n                                  UINT32 codecId)\n{\n\tUINT32 SrcSize = length;\n\trdpGdi* gdi = context->gdi;\n\tbitmap->compressed = FALSE;\n\tbitmap->format = gdi->dstFormat;\n\tbitmap->length = DstWidth * DstHeight * GetBytesPerPixel(bitmap->format);\n\tbitmap->data = (BYTE*) _aligned_malloc(bitmap->length, 16);\n\tif (!bitmap->data)\n\t\treturn FALSE;\n\tif (compressed)\n\t{\n\t\tif (bpp < 32)\n\t\t{\n\t\t\tif (!interleaved_decompress(context->codecs->interleaved,\n\t\t\t                            pSrcData, SrcSize,\n\t\t\t                            DstWidth, DstHeight,\n\t\t\t                            bpp,\n\t\t\t                            bitmap->data, bitmap->format,\n\t\t\t                            0, 0, 0, DstWidth, DstHeight,\n\t\t\t                            &gdi->palette))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!planar_decompress(context->codecs->planar, pSrcData, SrcSize,\n\t\t\t                       DstWidth, DstHeight,\n\t\t\t                       bitmap->data, bitmap->format, 0, 0, 0,\n\t\t\t                       DstWidth, DstHeight, TRUE))\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tconst UINT32 SrcFormat = gdi_get_pixel_format(bpp);\n\t\tconst size_t sbpp = GetBytesPerPixel(SrcFormat);\n\t\tconst size_t dbpp = GetBytesPerPixel(bitmap->format);\n\t\tif ((sbpp == 0) || (dbpp == 0))\n\t\t\treturn FALSE;\n\t\telse\n\t\t{\n\t\t\tconst size_t dstSize = SrcSize * dbpp / sbpp;\n\t\t\tif (dstSize  < bitmap->length)\n\t\t\t\treturn FALSE;\n\t\t}\n\t\tif (!freerdp_image_copy(bitmap->data, bitmap->format, 0, 0, 0,\n\t\t                        DstWidth, DstHeight, pSrcData, SrcFormat,\n\t\t                        0, 0, 0, &gdi->palette, FREERDP_FLIP_VERTICAL))\n\t\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "void AOClient::pktRemoveEvidence(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    if (!checkEvidenceAccess(area))\n        return;\n    bool is_int = false;\n    int idx = argv[0].toInt(&is_int);\n    if (is_int && idx <= area->evidence().size() && idx >= 0) {\n        area->deleteEvidence(idx);\n    }\n    sendEvidenceList(area);\n}", "target": 1}
{"code": "static struct mnt_namespace *alloc_mnt_ns(struct user_namespace *user_ns)\n{\n\tstruct mnt_namespace *new_ns;\n\tstruct ucounts *ucounts;\n\tint ret;\n\tucounts = inc_mnt_namespaces(user_ns);\n\tif (!ucounts)\n\t\treturn ERR_PTR(-ENOSPC);\n\tnew_ns = kmalloc(sizeof(struct mnt_namespace), GFP_KERNEL);\n\tif (!new_ns) {\n\t\tdec_mnt_namespaces(ucounts);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tret = ns_alloc_inum(&new_ns->ns);\n\tif (ret) {\n\t\tkfree(new_ns);\n\t\tdec_mnt_namespaces(ucounts);\n\t\treturn ERR_PTR(ret);\n\t}\n\tnew_ns->ns.ops = &mntns_operations;\n\tnew_ns->seq = atomic64_add_return(1, &mnt_ns_seq);\n\tatomic_set(&new_ns->count, 1);\n\tnew_ns->root = NULL;\n\tINIT_LIST_HEAD(&new_ns->list);\n\tinit_waitqueue_head(&new_ns->poll);\n\tnew_ns->event = 0;\n\tnew_ns->user_ns = get_user_ns(user_ns);\n\tnew_ns->ucounts = ucounts;\n\tnew_ns->mounts = 0;\n\tnew_ns->pending_mounts = 0;\n\treturn new_ns;\n}", "target": 0}
{"code": "nvkm_vmm_put_region(struct nvkm_vmm *vmm, struct nvkm_vma *vma)\n{\n\tstruct nvkm_vma *prev, *next;\n\tif ((prev = node(vma, prev)) && !prev->used) {\n\t\trb_erase(&prev->tree, &vmm->free);\n\t\tlist_del(&prev->head);\n\t\tvma->addr  = prev->addr;\n\t\tvma->size += prev->size;\n\t\tkfree(prev);\n\t}\n\tif ((next = node(vma, next)) && !next->used) {\n\t\trb_erase(&next->tree, &vmm->free);\n\t\tlist_del(&next->head);\n\t\tvma->size += next->size;\n\t\tkfree(next);\n\t}\n\tnvkm_vmm_free_insert(vmm, vma);\n}", "target": 1}
{"code": "static int emulate_store_desc_ptr(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t  void (*get)(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t\t      struct desc_ptr *ptr))\n{\n\tstruct desc_ptr desc_ptr;\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tctxt->op_bytes = 8;\n\tget(ctxt, &desc_ptr);\n\tif (ctxt->op_bytes == 2) {\n\t\tctxt->op_bytes = 4;\n\t\tdesc_ptr.address &= 0x00ffffff;\n\t}\n\tctxt->dst.type = OP_NONE;\n\treturn segmented_write(ctxt, ctxt->dst.addr.mem,\n\t\t\t       &desc_ptr, 2 + ctxt->op_bytes);\n}", "target": 1}
{"code": "static int xfrm_user_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *attrs[XFRMA_MAX+1];\n\tconst struct xfrm_link *link;\n\tint type, err;\n\ttype = nlh->nlmsg_type;\n\tif (type > XFRM_MSG_MAX)\n\t\treturn -EINVAL;\n\ttype -= XFRM_MSG_BASE;\n\tlink = &xfrm_dispatch[type];\n\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\tif ((type == (XFRM_MSG_GETSA - XFRM_MSG_BASE) ||\n\t     type == (XFRM_MSG_GETPOLICY - XFRM_MSG_BASE)) &&\n\t    (nlh->nlmsg_flags & NLM_F_DUMP)) {\n\t\tif (link->dump == NULL)\n\t\t\treturn -EINVAL;\n\t\t{\n\t\t\tstruct netlink_dump_control c = {\n\t\t\t\t.start = link->start,\n\t\t\t\t.dump = link->dump,\n\t\t\t\t.done = link->done,\n\t\t\t};\n\t\t\treturn netlink_dump_start(net->xfrm.nlsk, skb, nlh, &c);\n\t\t}\n\t}\n\terr = nlmsg_parse(nlh, xfrm_msg_min[type], attrs, XFRMA_MAX,\n\t\t\t  xfrma_policy);\n\tif (err < 0)\n\t\treturn err;\n\tif (link->doit == NULL)\n\t\treturn -EINVAL;\n\treturn link->doit(skb, nlh, attrs);\n}", "target": 0}
{"code": "int32_t CxImage::GetSize()\n{\n\treturn head.biSize + head.biSizeImage + GetPaletteSize();\n}", "target": 1}
{"code": "find_method_in_class (MonoClass *klass, const char *name, const char *qname, const char *fqname,\n\t\t      MonoMethodSignature *sig, MonoClass *from_class)\n{\n \tint i;\n\tif (klass->type_token && !klass->image->dynamic && !klass->methods && !klass->rank && klass == from_class && !from_class->generic_class) {\n\t\tfor (i = 0; i < klass->method.count; ++i) {\n\t\t\tguint32 cols [MONO_METHOD_SIZE];\n\t\t\tMonoMethod *method;\n\t\t\tconst char *m_name;\n\t\t\tMonoMethodSignature *other_sig;\n\t\t\tmono_metadata_decode_table_row (klass->image, MONO_TABLE_METHOD, klass->method.first + i, cols, MONO_METHOD_SIZE);\n\t\t\tm_name = mono_metadata_string_heap (klass->image, cols [MONO_METHOD_NAME]);\n\t\t\tif (!((fqname && !strcmp (m_name, fqname)) ||\n\t\t\t\t  (qname && !strcmp (m_name, qname)) ||\n\t\t\t\t  (name && !strcmp (m_name, name))))\n\t\t\t\tcontinue;\n\t\t\tmethod = mono_get_method (klass->image, MONO_TOKEN_METHOD_DEF | (klass->method.first + i + 1), klass);\n\t\t\tother_sig = mono_method_signature (method);\n\t\t\tif (method && other_sig && (sig->call_convention != MONO_CALL_VARARG) && mono_metadata_signature_equal (sig, other_sig))\n\t\t\t\treturn method;\n\t\t}\n\t}\n\tmono_class_setup_methods (klass);\n\tif (!klass->methods)\n\t\treturn NULL;\n\tfor (i = 0; i < klass->method.count; ++i) {\n\t\tMonoMethod *m = klass->methods [i];\n\t\tMonoMethodSignature *msig;\n\t\tif (!((fqname && !strcmp (m->name, fqname)) ||\n\t\t      (qname && !strcmp (m->name, qname)) ||\n\t\t      (name && !strcmp (m->name, name))))\n\t\t\tcontinue;\n\t\tmsig = mono_method_signature (m);\n\t\tif (!msig)\n\t\t\tcontinue;\n\t\tif (sig->call_convention == MONO_CALL_VARARG) {\n\t\t\tif (mono_metadata_signature_vararg_match (sig, msig))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (mono_metadata_signature_equal (sig, msig))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (i < klass->method.count)\n\t\treturn mono_class_get_method_by_index (from_class, i);\n\treturn NULL;\n}", "target": 0}
{"code": "static inline bool spectre_v2_in_ibrs_mode(enum spectre_v2_mitigation mode)\n{\n\treturn mode == SPECTRE_V2_IBRS ||\n\t       mode == SPECTRE_V2_EIBRS ||\n\t       mode == SPECTRE_V2_EIBRS_RETPOLINE ||\n\t       mode == SPECTRE_V2_EIBRS_LFENCE;\n}", "target": 1}
{"code": "static const jpc_mstabent_t *jpc_mstab_lookup(int id)\n{\n\tconst jpc_mstabent_t *mstabent;\n\tfor (mstabent = jpc_mstab;; ++mstabent) {\n\t\tif (mstabent->id == id || mstabent->id < 0) {\n\t\t\treturn mstabent;\n\t\t}\n\t}\n\tassert(0);\n\treturn 0;\n}", "target": 0}
{"code": "void LibRaw::Canon_WBpresets(int skip1, int skip2)\n{\n  int c;\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();\n  if (skip1)\n    fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();\n  if (skip1)\n    fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();\n  if (skip1)\n    fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();\n  if (skip1)\n    fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();\n  if (skip2)\n    fseek(ifp, skip2, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();\n  return;\n}", "target": 0}
{"code": "poly_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\tPOLYGON    *poly;\n\tint\t\t\tnpts;\n\tint\t\t\tsize;\n\tint\t\t\tisopen;\n\tchar\t   *s;\n\tif ((npts = pair_count(str, ',')) <= 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t  errmsg(\"invalid input syntax for type polygon: \\\"%s\\\"\", str)));\n\tsize = offsetof(POLYGON, p[0]) +sizeof(poly->p[0]) * npts;\n\tpoly = (POLYGON *) palloc0(size);\t\n\tSET_VARSIZE(poly, size);\n\tpoly->npts = npts;\n\tif ((!path_decode(FALSE, npts, str, &isopen, &s, &(poly->p[0])))\n\t\t|| (*s != '\\0'))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t  errmsg(\"invalid input syntax for type polygon: \\\"%s\\\"\", str)));\n\tmake_bound_box(poly);\n\tPG_RETURN_POLYGON_P(poly);\n}", "target": 1}
{"code": "alloc_limit_failure (char *fn_name, size_t size)\n{\n    fprintf (stderr, \n             \"%s: Maximum allocation size exceeded \"\n             \"(maxsize = %lu; size = %lu).\\n\",\n             fn_name,\n             (unsigned long)alloc_limit, \n             (unsigned long)size);\n}", "target": 1}
{"code": "static PixelChannels **AcquirePixelThreadSet(const Image *images)\n{\n  const Image\n    *next;\n  PixelChannels\n    **pixels;\n  register ssize_t\n    i;\n  size_t\n    columns,\n    rows;\n  rows=MagickMax(GetImageListLength(images),\n    (size_t) GetMagickResourceLimit(ThreadResource));\n  pixels=(PixelChannels **) AcquireQuantumMemory(rows,sizeof(*pixels));\n  if (pixels == (PixelChannels **) NULL)\n    return((PixelChannels **) NULL);\n  columns=MaxPixelChannels;\n  for (next=images; next != (Image *) NULL; next=next->next)\n    columns=MagickMax(next->columns,columns);\n  for (i=0; i < (ssize_t) rows; i++)\n  {\n    register ssize_t\n      j;\n    pixels[i]=(PixelChannels *) AcquireQuantumMemory(columns,sizeof(**pixels));\n    if (pixels[i] == (PixelChannels *) NULL)\n      return(DestroyPixelThreadSet(pixels));\n    for (j=0; j < (ssize_t) columns; j++)\n    {\n      register ssize_t\n        k;\n      for (k=0; k < MaxPixelChannels; k++)\n        pixels[i][j].channel[k]=0.0;\n    }\n  }\n  return(pixels);\n}", "target": 0}
{"code": "evtchn_port_t evtchn_from_irq(unsigned irq)\n{\n\tif (WARN(irq >= nr_irqs, \"Invalid irq %d!\\n\", irq))\n\t\treturn 0;\n\treturn info_for_irq(irq)->evtchn;\n}", "target": 1}
{"code": "static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC) \n{\n\tif (prev_options != NULL) {\n\t\t*prev_options = MBREX(regex_default_options);\n\t}\n\tif (prev_syntax != NULL) {\n\t\t*prev_syntax = MBREX(regex_default_syntax);\n\t}\n\tMBREX(regex_default_options) = options;\n\tMBREX(regex_default_syntax) = syntax;\n}", "target": 1}
{"code": "int yr_object_copy(\n    YR_OBJECT* object,\n    YR_OBJECT** object_copy)\n{\n  YR_OBJECT* copy;\n  YR_OBJECT* o;\n  YR_STRUCTURE_MEMBER* structure_member;\n  YR_OBJECT_FUNCTION* func;\n  YR_OBJECT_FUNCTION* func_copy;\n  int i;\n  *object_copy = NULL;\n  FAIL_ON_ERROR(yr_object_create(\n      object->type,\n      object->identifier,\n      NULL,\n      &copy));\n  switch(object->type)\n  {\n    case OBJECT_TYPE_INTEGER:\n      ((YR_OBJECT_INTEGER*) copy)->value = UNDEFINED;\n      break;\n    case OBJECT_TYPE_STRING:\n      ((YR_OBJECT_STRING*) copy)->value = NULL;\n      break;\n    case OBJECT_TYPE_FUNCTION:\n      func = (YR_OBJECT_FUNCTION*) object;\n      func_copy = (YR_OBJECT_FUNCTION*) copy;\n      FAIL_ON_ERROR_WITH_CLEANUP(\n        yr_object_copy(func->return_obj, &func_copy->return_obj),\n        yr_object_destroy(copy));\n      for (i = 0; i < MAX_OVERLOADED_FUNCTIONS; i++)\n        func_copy->prototypes[i] = func->prototypes[i];\n      break;\n    case OBJECT_TYPE_STRUCTURE:\n      structure_member = ((YR_OBJECT_STRUCTURE*) object)->members;\n      while (structure_member != NULL)\n      {\n        FAIL_ON_ERROR_WITH_CLEANUP(\n            yr_object_copy(structure_member->object, &o),\n            yr_object_destroy(copy));\n        FAIL_ON_ERROR_WITH_CLEANUP(\n            yr_object_structure_set_member(copy, o),\n            yr_free(o);\n            yr_object_destroy(copy));\n        structure_member = structure_member->next;\n      }\n      break;\n    case OBJECT_TYPE_ARRAY:\n      yr_object_copy(\n        ((YR_OBJECT_ARRAY *) object)->prototype_item,\n        &o);\n      ((YR_OBJECT_ARRAY *)copy)->prototype_item = o;\n      break;\n    case OBJECT_TYPE_DICTIONARY:\n      yr_object_copy(\n        ((YR_OBJECT_DICTIONARY *) object)->prototype_item,\n        &o);\n      ((YR_OBJECT_DICTIONARY *)copy)->prototype_item = o;\n      break;\n    default:\n      assert(FALSE);\n  }\n  *object_copy = copy;\n  return ERROR_SUCCESS;\n}", "target": 1}
{"code": "static int snd_timer_user_release(struct inode *inode, struct file *file)\n{\n\tstruct snd_timer_user *tu;\n\tif (file->private_data) {\n\t\ttu = file->private_data;\n\t\tfile->private_data = NULL;\n\t\tmutex_lock(&tu->ioctl_lock);\n\t\tif (tu->timeri)\n\t\t\tsnd_timer_close(tu->timeri);\n\t\tmutex_unlock(&tu->ioctl_lock);\n\t\tkfree(tu->queue);\n\t\tkfree(tu->tqueue);\n\t\tkfree(tu);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "int dccp_destroy_sock(struct sock *sk)\n{\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\tstruct dccp_minisock *dmsk = dccp_msk(sk);\n\tif (sk->sk_send_head != NULL) {\n\t\tkfree_skb(sk->sk_send_head);\n\t\tsk->sk_send_head = NULL;\n\t}\n\tif (inet_csk(sk)->icsk_bind_hash != NULL)\n\t\tinet_put_port(&dccp_hashinfo, sk);\n\tkfree(dp->dccps_service_list);\n\tdp->dccps_service_list = NULL;\n\tif (dmsk->dccpms_send_ack_vector) {\n\t\tdccp_ackvec_free(dp->dccps_hc_rx_ackvec);\n\t\tdp->dccps_hc_rx_ackvec = NULL;\n\t}\n\tccid_hc_rx_delete(dp->dccps_hc_rx_ccid, sk);\n\tccid_hc_tx_delete(dp->dccps_hc_tx_ccid, sk);\n\tdp->dccps_hc_rx_ccid = dp->dccps_hc_tx_ccid = NULL;\n\tdccp_feat_clean(dmsk);\n\treturn 0;\n}", "target": 0}
{"code": "static void HTPStateTransactionFree(void *state, uint64_t id)\n{\n    SCEnter();\n    HtpState *s = (HtpState *)state;\n    SCLogDebug(\"state %p, id %\"PRIu64, s, id);\n    htp_tx_t *tx = HTPStateGetTx(s, id);\n    if (tx != NULL) {\n        HtpTxUserData *htud = (HtpTxUserData *) htp_tx_get_user_data(tx);\n        HtpTxUserDataFree(s, htud);\n        htp_tx_set_user_data(tx, NULL);\n        if (unlikely(!(\n            tx->request_progress == HTP_REQUEST_COMPLETE &&\n            tx->response_progress == HTP_RESPONSE_COMPLETE)))\n        {\n            tx->request_progress = HTP_REQUEST_COMPLETE;\n            tx->response_progress = HTP_RESPONSE_COMPLETE;\n        }\n        htp_tx_destroy(tx);\n    }\n    s->tx_freed += htp_connp_tx_freed(s->connp);\n}", "target": 0}
{"code": "HeaderEntry* HeaderMapImpl::get(const LowerCaseString& key) {\n  for (HeaderEntryImpl& header : headers_) {\n    if (header.key() == key.get().c_str()) {\n      cached_byte_size_.reset();\n      return &header;\n    }\n  }\n  return nullptr;\n}", "target": 0}
{"code": "void BezierCircle(double r,char *action)\n{\n    char *outpos = outputbuffer;\n    outpos +=\n    sprintf(outpos,\" %12.3f 0 m %12.3f %12.3f %12.3f %12.3f 0 %12.3f c\\n\",-r,-r,r*BzK,-r*BzK,r,r);\n    outpos +=\n    sprintf(outpos,\" %12.3f %12.3f %12.3f %12.3f %12.3f 0 c\\n\",r*BzK,r,r,r*BzK,r);\n    outpos +=\n    sprintf(outpos,\" %12.3f %12.3f %12.3f %12.3f 0 %12.3f c\\n\",r,-r*BzK,r*BzK,-r,-r);\n    outpos +=\n    sprintf(outpos,\" %12.3f %12.3f %12.3f %12.3f %12.3f 0 c %s\\n\",-r*BzK,-r,-r,-r*BzK,-r,action);\n    sendClean(outputbuffer);\n}", "target": 0}
{"code": "void HeaderMapImpl::appendToHeader(HeaderString& header, absl::string_view data) {\n  if (data.empty()) {\n    return;\n  }\n  if (!header.empty()) {\n    header.append(\",\", 1);\n  }\n  header.append(data.data(), data.size());\n}", "target": 1}
{"code": "TfLiteStatus Subgraph::AllocateTensors() {\n  TFLITE_SCOPED_TAGGED_DEFAULT_PROFILE(profiler_.get(), \"AllocateTensors\");\n  if (!consistent_) {\n    ReportError(\"AllocateTensors() called on inconsistent model.\");\n    return kTfLiteError;\n  }\n  TF_LITE_ENSURE_STATUS(RedoAllDelegates());\n  if (state_ != kStateUninvokable &&\n      !HasDynamicTensorImpl(context_, inputs())) {\n    if (memory_planner_ && !memory_planner_->HasNonPersistentMemory()) {\n      memory_planner_->AcquireNonPersistentMemory();\n    }\n    return kTfLiteOk;\n  }\n  SubgraphGuard guard(&context_, &is_subgraph_in_use_);\n  TF_LITE_ENSURE_OK(&context_, guard.status());\n  next_execution_plan_index_to_prepare_ = 0;\n  next_execution_plan_index_to_plan_allocation_ = 0;\n  next_original_execution_plan_index_to_prepare_ = 0;\n  if (memory_planner_) {\n    TF_LITE_ENSURE_STATUS(memory_planner_->ResetAllocations());\n  }\n  TF_LITE_ENSURE_STATUS(PrepareOpsAndTensors());\n  state_ = kStateInvokable;\n  ResetVariableTensors();\n  return kTfLiteOk;\n}", "target": 0}
{"code": "static void update_blocked_averages(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct cfs_rq *cfs_rq, *pos;\n\tconst struct sched_class *curr_class;\n\tstruct rq_flags rf;\n\tbool done = true;\n\trq_lock_irqsave(rq, &rf);\n\tupdate_rq_clock(rq);\n\tfor_each_leaf_cfs_rq_safe(rq, cfs_rq, pos) {\n\t\tstruct sched_entity *se;\n\t\tif (throttled_hierarchy(cfs_rq))\n\t\t\tcontinue;\n\t\tif (update_cfs_rq_load_avg(cfs_rq_clock_task(cfs_rq), cfs_rq))\n\t\t\tupdate_tg_load_avg(cfs_rq, 0);\n\t\tse = cfs_rq->tg->se[cpu];\n\t\tif (se && !skip_blocked_update(se))\n\t\t\tupdate_load_avg(cfs_rq_of(se), se, 0);\n\t\tif (cfs_rq_is_decayed(cfs_rq))\n\t\t\tlist_del_leaf_cfs_rq(cfs_rq);\n\t\tif (cfs_rq_has_blocked(cfs_rq))\n\t\t\tdone = false;\n\t}\n\tcurr_class = rq->curr->sched_class;\n\tupdate_rt_rq_load_avg(rq_clock_task(rq), rq, curr_class == &rt_sched_class);\n\tupdate_dl_rq_load_avg(rq_clock_task(rq), rq, curr_class == &dl_sched_class);\n\tupdate_irq_load_avg(rq, 0);\n\tif (others_have_blocked(rq))\n\t\tdone = false;\n#ifdef CONFIG_NO_HZ_COMMON\n\trq->last_blocked_load_update_tick = jiffies;\n\tif (done)\n\t\trq->has_blocked_load = 0;\n#endif\n\trq_unlock_irqrestore(rq, &rf);\n}", "target": 1}
{"code": "static int fsmVerify(int dirfd, const char *path, rpmfi fi)\n{\n    int rc;\n    int saveerrno = errno;\n    struct stat dsb;\n    mode_t mode = rpmfiFMode(fi);\n    rc = fsmStat(dirfd, path, 1, &dsb);\n    if (rc)\n\treturn rc;\n    if (S_ISREG(mode)) {\n\tchar *rmpath = rstrscat(NULL, path, \"-RPMDELETE\", NULL);\n\trc = fsmRename(dirfd, path, dirfd, rmpath);\n\tif (!rc)\n\t    (void) fsmUnlink(dirfd, rmpath);\n\telse\n\t    rc = RPMERR_UNLINK_FAILED;\n\tfree(rmpath);\n        return (rc ? rc : RPMERR_ENOENT);\t\n    } else if (S_ISDIR(mode)) {\n        if (S_ISDIR(dsb.st_mode)) return 0;\n        if (S_ISLNK(dsb.st_mode)) {\n\t    uid_t luid = dsb.st_uid;\n            rc = fsmStat(dirfd, path, 0, &dsb);\n            if (rc == RPMERR_ENOENT) rc = 0;\n            if (rc) return rc;\n            errno = saveerrno;\n            if (S_ISDIR(dsb.st_mode) && (luid == 0 || luid == dsb.st_uid))\n\t\t    return 0;\n        }\n    } else if (S_ISLNK(mode)) {\n        if (S_ISLNK(dsb.st_mode)) {\n            char buf[8 * BUFSIZ];\n            size_t len;\n            rc = fsmReadLink(path, buf, 8 * BUFSIZ, &len);\n            errno = saveerrno;\n            if (rc) return rc;\n            if (rstreq(rpmfiFLink(fi), buf)) return 0;\n        }\n    } else if (S_ISFIFO(mode)) {\n        if (S_ISFIFO(dsb.st_mode)) return 0;\n    } else if (S_ISCHR(mode) || S_ISBLK(mode)) {\n        if ((S_ISCHR(dsb.st_mode) || S_ISBLK(dsb.st_mode)) &&\n            (dsb.st_rdev == rpmfiFRdev(fi))) return 0;\n    } else if (S_ISSOCK(mode)) {\n        if (S_ISSOCK(dsb.st_mode)) return 0;\n    }\n    rc = fsmUnlink(dirfd, path);\n    if (rc == 0)\trc = RPMERR_ENOENT;\n    return (rc ? rc : RPMERR_ENOENT);\t\n}", "target": 0}
{"code": "void VariableUnserializer::unserializeProp(ObjectData* obj,\n                                           const String& key,\n                                           Class* ctx,\n                                           const String& realKey,\n                                           int nProp) {\n  auto const cls = obj->getVMClass();\n  auto const lookup = cls->getDeclPropSlot(ctx, key.get());\n  auto const slot = lookup.slot;\n  tv_lval t;\n  if (slot == kInvalidSlot || !lookup.accessible) {\n    obj->reserveDynProps(nProp);\n    t = obj->makeDynProp(realKey.get());\n  } else {\n    t = obj->getPropLval(ctx, key.get());\n  }\n  unserializePropertyValue(t, nProp);\n  if (!RuntimeOption::RepoAuthoritative) return;\n  if (!Repo::get().global().HardPrivatePropInference) return;\n  if (UNLIKELY(slot == kInvalidSlot)) return;\n  auto const repoTy = cls->declPropRepoAuthType(slot);\n  if (LIKELY(tvMatchesRepoAuthType(*t, repoTy))) return;\n  if (t.type() == KindOfUninit &&\n      (cls->declProperties()[slot].attrs & AttrLateInit)) {\n    return;\n  }\n  throwUnexpectedType(key, obj, *t);\n}", "target": 0}
{"code": "void CompactProtocolReader::readStringBody(StrType& str, int32_t size) {\n  if (static_cast<int32_t>(in_.length()) < size) {\n    if (!in_.canAdvance(size)) {\n      protocol::TProtocolException::throwTruncatedData();\n    }\n    str.reserve(size); \n  }\n  str.clear();\n  size_t size_left = size;\n  while (size_left > 0) {\n    auto data = in_.peekBytes();\n    auto data_avail = std::min(data.size(), size_left);\n    if (data.empty()) {\n      TProtocolException::throwExceededSizeLimit();\n    }\n    str.append((const char*)data.data(), data_avail);\n    size_left -= data_avail;\n    in_.skipNoAdvance(data_avail);\n  }\n}", "target": 0}
{"code": "static int ReadHuffmanCodeLengths(\n    VP8LDecoder* const dec, const int* const code_length_code_lengths,\n    int num_symbols, int* const code_lengths) {\n  int ok = 0;\n  VP8LBitReader* const br = &dec->br_;\n  int symbol;\n  int max_symbol;\n  int prev_code_len = DEFAULT_CODE_LENGTH;\n  HuffmanCode table[1 << LENGTHS_TABLE_BITS];\n  if (!VP8LBuildHuffmanTable(table, LENGTHS_TABLE_BITS,\n                             code_length_code_lengths,\n                             NUM_CODE_LENGTH_CODES)) {\n    goto End;\n  }\n  if (VP8LReadBits(br, 1)) {    \n    const int length_nbits = 2 + 2 * VP8LReadBits(br, 3);\n    max_symbol = 2 + VP8LReadBits(br, length_nbits);\n    if (max_symbol > num_symbols) {\n      goto End;\n    }\n  } else {\n    max_symbol = num_symbols;\n  }\n  symbol = 0;\n  while (symbol < num_symbols) {\n    const HuffmanCode* p;\n    int code_len;\n    if (max_symbol-- == 0) break;\n    VP8LFillBitWindow(br);\n    p = &table[VP8LPrefetchBits(br) & LENGTHS_TABLE_MASK];\n    VP8LSetBitPos(br, br->bit_pos_ + p->bits);\n    code_len = p->value;\n    if (code_len < kCodeLengthLiterals) {\n      code_lengths[symbol++] = code_len;\n      if (code_len != 0) prev_code_len = code_len;\n    } else {\n      const int use_prev = (code_len == kCodeLengthRepeatCode);\n      const int slot = code_len - kCodeLengthLiterals;\n      const int extra_bits = kCodeLengthExtraBits[slot];\n      const int repeat_offset = kCodeLengthRepeatOffsets[slot];\n      int repeat = VP8LReadBits(br, extra_bits) + repeat_offset;\n      if (symbol + repeat > num_symbols) {\n        goto End;\n      } else {\n        const int length = use_prev ? prev_code_len : 0;\n        while (repeat-- > 0) code_lengths[symbol++] = length;\n      }\n    }\n  }\n  ok = 1;\n End:\n  if (!ok) return VP8LSetError(dec, VP8_STATUS_BITSTREAM_ERROR);\n  return ok;\n}", "target": 1}
{"code": "static inline void blk_mq_tag_set_rq(struct blk_mq_hw_ctx *hctx,\n\t\tunsigned int tag, struct request *rq)\n{\n\thctx->tags->rqs[tag] = rq;\n}", "target": 0}
{"code": "static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next,\n\t\t\t     struct task_struct *tsk)\n{\n\tunsigned cpu = smp_processor_id();\n\tif (likely(prev != next)) {\n#ifdef CONFIG_SMP\n\t\tthis_cpu_write(cpu_tlbstate.state, TLBSTATE_OK);\n\t\tthis_cpu_write(cpu_tlbstate.active_mm, next);\n#endif\n\t\tcpumask_set_cpu(cpu, mm_cpumask(next));\n\t\tload_cr3(next->pgd);\n\t\ttrace_tlb_flush(TLB_FLUSH_ON_TASK_SWITCH, TLB_FLUSH_ALL);\n\t\tcpumask_clear_cpu(cpu, mm_cpumask(prev));\n\t\tload_mm_cr4(next);\n#ifdef CONFIG_MODIFY_LDT_SYSCALL\n\t\tif (unlikely(prev->context.ldt != next->context.ldt))\n\t\t\tload_mm_ldt(next);\n#endif\n\t}\n#ifdef CONFIG_SMP\n\t  else {\n\t\tthis_cpu_write(cpu_tlbstate.state, TLBSTATE_OK);\n\t\tBUG_ON(this_cpu_read(cpu_tlbstate.active_mm) != next);\n\t\tif (!cpumask_test_cpu(cpu, mm_cpumask(next))) {\n\t\t\tcpumask_set_cpu(cpu, mm_cpumask(next));\n\t\t\tload_cr3(next->pgd);\n\t\t\ttrace_tlb_flush(TLB_FLUSH_ON_TASK_SWITCH, TLB_FLUSH_ALL);\n\t\t\tload_mm_cr4(next);\n\t\t\tload_mm_ldt(next);\n\t\t}\n\t}\n#endif\n}", "target": 1}
{"code": "void ldbRedis(lua_State *lua, sds *argv, int argc) {\n    int j, saved_rc = server.lua_replicate_commands;\n    if (!lua_checkstack(lua, argc + 1)) {\n        ldbLogRedisReply(\"max lua stack reached\");\n        return;\n    }\n    lua_getglobal(lua,\"redis\");\n    lua_pushstring(lua,\"call\");\n    lua_gettable(lua,-2);       \n    for (j = 1; j < argc; j++)\n        lua_pushlstring(lua,argv[j],sdslen(argv[j]));\n    ldb.step = 1;               \n    server.lua_replicate_commands = 1;\n    lua_pcall(lua,argc-1,1,0);  \n    ldb.step = 0;               \n    server.lua_replicate_commands = saved_rc;\n    lua_pop(lua,2);             \n}", "target": 0}
{"code": "static int xfrm_dump_sa_done(struct netlink_callback *cb)\n{\n\tstruct xfrm_state_walk *walk = (struct xfrm_state_walk *) &cb->args[1];\n\tstruct sock *sk = cb->skb->sk;\n\tstruct net *net = sock_net(sk);\n\txfrm_state_walk_done(walk, net);\n\treturn 0;\n}", "target": 1}
{"code": "static int openssl_push_check_result(lua_State *L, int ret, const char* name)\n{\n  switch (ret)\n  {\n  case 1:\n    lua_pushboolean(L, 1);\n    if (name)\n    {\n      lua_pushstring(L, name);\n      ret = 2;\n    }\n    break;\n  case 0:\n    lua_pushboolean(L, 0);\n    ret = 1;\n    break;\n  case -1:\n    lua_pushnil(L);\n    lua_pushliteral(L, \"internal\");\n    ret = 2;\n  case -2:\n    lua_pushnil(L);\n    lua_pushliteral(L, \"malformed\");\n    ret = 2;\n  default:\n    lua_pushnil(L);\n    lua_pushinteger(L, ret);\n    ret = 2;\n  }\n  return ret;\n}", "target": 0}
{"code": "CodingReturnValue LeptonCodec::ThreadState::vp8_decode_thread(unsigned int thread_id,\n                                                              UncompressedComponents *const colldata) {\n    Sirikata::Array1d<uint32_t, (uint32_t)ColorChannel::NumBlockTypes> component_size_in_blocks;\n    BlockBasedImagePerChannel<false> image_data;\n    for (int i = 0; i < colldata->get_num_components(); ++i) {\n        component_size_in_blocks[i] = colldata->component_size_in_blocks(i);\n        image_data[i] = &colldata->full_component_write((BlockType)i);\n    }\n    Sirikata::Array1d<uint32_t,\n                      (size_t)ColorChannel::NumBlockTypes> max_coded_heights\n        = colldata->get_max_coded_heights();\n    dev_assert(luma_splits_.size() == 2); \n    always_assert(luma_splits_.size() >= 2);\n    int min_y = luma_splits_[0];\n    int max_y = luma_splits_[1];\n    while(true) {\n        RowSpec cur_row = row_spec_from_index(decode_index_++, image_data, colldata->get_mcu_count_vertical(), max_coded_heights);\n        if (cur_row.done) {\n            break;\n        }\n        if (cur_row.luma_y >= max_y && thread_id + 1 != NUM_THREADS) {\n            break;\n        }\n        if (cur_row.skip) {\n            continue;\n        }\n        if (cur_row.luma_y < min_y) {\n            continue;\n        }\n        decode_rowf(image_data,\n                   component_size_in_blocks,\n                   cur_row.component,\n                   cur_row.curr_y);\n        if (thread_id == 0) {\n            colldata->worker_update_cmp_progress((BlockType)cur_row.component,\n                                                 image_data[cur_row.component]->block_width() );\n        }\n        return CODING_PARTIAL;\n    }\n    return CODING_DONE;\n}", "target": 0}
{"code": "static void print_vtable(vtableEntry* start, int len, outputStream* st) {\n  return print_vtable(reinterpret_cast<intptr_t*>(start), len, st);\n}", "target": 0}
{"code": "static void flush(AVCodecContext *avctx)\n{\n    AACContext *ac= avctx->priv_data;\n    int type, i, j;\n    for (type = 3; type >= 0; type--) {\n        for (i = 0; i < MAX_ELEM_ID; i++) {\n            ChannelElement *che = ac->che[type][i];\n            if (che) {\n                for (j = 0; j <= 1; j++) {\n                    memset(che->ch[j].saved, 0, sizeof(che->ch[j].saved));\n                }\n            }\n        }\n    }\n}", "target": 0}
{"code": "static int xfrm_expand_policies(const struct flowi *fl, u16 family,\n\t\t\t\tstruct xfrm_policy **pols,\n\t\t\t\tint *num_pols, int *num_xfrms)\n{\n\tint i;\n\tif (*num_pols == 0 || !pols[0]) {\n\t\t*num_pols = 0;\n\t\t*num_xfrms = 0;\n\t\treturn 0;\n\t}\n\tif (IS_ERR(pols[0]))\n\t\treturn PTR_ERR(pols[0]);\n\t*num_xfrms = pols[0]->xfrm_nr;\n#ifdef CONFIG_XFRM_SUB_POLICY\n\tif (pols[0]->action == XFRM_POLICY_ALLOW &&\n\t    pols[0]->type != XFRM_POLICY_TYPE_MAIN) {\n\t\tpols[1] = xfrm_policy_lookup_bytype(xp_net(pols[0]),\n\t\t\t\t\t\t    XFRM_POLICY_TYPE_MAIN,\n\t\t\t\t\t\t    fl, family,\n\t\t\t\t\t\t    XFRM_POLICY_OUT,\n\t\t\t\t\t\t    pols[0]->if_id);\n\t\tif (pols[1]) {\n\t\t\tif (IS_ERR(pols[1])) {\n\t\t\t\txfrm_pols_put(pols, *num_pols);\n\t\t\t\treturn PTR_ERR(pols[1]);\n\t\t\t}\n\t\t\t(*num_pols)++;\n\t\t\t(*num_xfrms) += pols[1]->xfrm_nr;\n\t\t}\n\t}\n#endif\n\tfor (i = 0; i < *num_pols; i++) {\n\t\tif (pols[i]->action != XFRM_POLICY_ALLOW) {\n\t\t\t*num_xfrms = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "SYSCALL_DEFINE4(ptrace, long, request, long, pid, unsigned long, addr,\n\t\tunsigned long, data)\n{\n\tstruct task_struct *child;\n\tlong ret;\n\tif (request == PTRACE_TRACEME) {\n\t\tret = ptrace_traceme();\n\t\tif (!ret)\n\t\t\tarch_ptrace_attach(current);\n\t\tgoto out;\n\t}\n\tchild = ptrace_get_task_struct(pid);\n\tif (IS_ERR(child)) {\n\t\tret = PTR_ERR(child);\n\t\tgoto out;\n\t}\n\tif (request == PTRACE_ATTACH || request == PTRACE_SEIZE) {\n\t\tret = ptrace_attach(child, request, addr, data);\n\t\tif (!ret)\n\t\t\tarch_ptrace_attach(child);\n\t\tgoto out_put_task_struct;\n\t}\n\tret = ptrace_check_attach(child, request == PTRACE_KILL ||\n\t\t\t\t  request == PTRACE_INTERRUPT);\n\tif (ret < 0)\n\t\tgoto out_put_task_struct;\n\tret = arch_ptrace(child, request, addr, data);\n\tif (ret || request != PTRACE_DETACH)\n\t\tptrace_unfreeze_traced(child);\n out_put_task_struct:\n\tput_task_struct(child);\n out:\n\treturn ret;\n}", "target": 0}
{"code": "GIT_INLINE(bool) only_spaces_and_dots(const char *path)\n{\n\tconst char *c = path;\n\tfor (;; c++) {\n\t\tif (*c == '\\0')\n\t\t\treturn true;\n\t\tif (*c != ' ' && *c != '.')\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "static void encode_reclaim_complete(struct xdr_stream *xdr,\n\t\t\t\t    struct nfs41_reclaim_complete_args *args,\n\t\t\t\t    struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_RECLAIM_COMPLETE, decode_reclaim_complete_maxsz, hdr);\n\tencode_uint32(xdr, args->one_fs);\n}", "target": 0}
{"code": "  bool add_challenge(CephContext *cct, bufferlist& ch) override { return true; }", "target": 0}
{"code": "struct file *get_empty_filp(void)\n{\n\tconst struct cred *cred = current_cred();\n\tstatic long old_max;\n\tstruct file *f;\n\tint error;\n\tif (get_nr_files() >= files_stat.max_files && !capable(CAP_SYS_ADMIN)) {\n\t\tif (percpu_counter_sum_positive(&nr_files) >= files_stat.max_files)\n\t\t\tgoto over;\n\t}\n\tf = kmem_cache_zalloc(filp_cachep, GFP_KERNEL);\n\tif (unlikely(!f))\n\t\treturn ERR_PTR(-ENOMEM);\n\tpercpu_counter_inc(&nr_files);\n\tf->f_cred = get_cred(cred);\n\terror = security_file_alloc(f);\n\tif (unlikely(error)) {\n\t\tfile_free(f);\n\t\treturn ERR_PTR(error);\n\t}\n\tINIT_LIST_HEAD(&f->f_u.fu_list);\n\tatomic_long_set(&f->f_count, 1);\n\trwlock_init(&f->f_owner.lock);\n\tspin_lock_init(&f->f_lock);\n\teventpoll_init_file(f);\n\treturn f;\nover:\n\tif (get_nr_files() > old_max) {\n\t\tpr_info(\"VFS: file-max limit %lu reached\\n\", get_max_files());\n\t\told_max = get_nr_files();\n\t}\n\treturn ERR_PTR(-ENFILE);\n}", "target": 1}
{"code": "void mbedtls_ssl_flight_free( mbedtls_ssl_flight_item *flight )\n{\n    mbedtls_ssl_flight_item *cur = flight;\n    mbedtls_ssl_flight_item *next;\n    while( cur != NULL )\n    {\n        next = cur->next;\n        mbedtls_free( cur->p );\n        mbedtls_free( cur );\n        cur = next;\n    }\n}", "target": 0}
{"code": "int usbip_recv_xbuff(struct usbip_device *ud, struct urb *urb)\n{\n\tint ret;\n\tint size;\n\tif (ud->side == USBIP_STUB) {\n\t\tif (usb_pipein(urb->pipe))\n\t\t\treturn 0;\n\t\tsize = urb->transfer_buffer_length;\n\t} else {\n\t\tif (usb_pipeout(urb->pipe))\n\t\t\treturn 0;\n\t\tsize = urb->actual_length;\n\t}\n\tif (!(size > 0))\n\t\treturn 0;\n\tif (size > urb->transfer_buffer_length) {\n\t\tif (ud->side == USBIP_STUB) {\n\t\t\tusbip_event_add(ud, SDEV_EVENT_ERROR_TCP);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tusbip_event_add(ud, VDEV_EVENT_ERROR_TCP);\n\t\t\treturn -EPIPE;\n\t\t}\n\t}\n\tret = usbip_recv(ud->tcp_socket, urb->transfer_buffer, size);\n\tif (ret != size) {\n\t\tdev_err(&urb->dev->dev, \"recv xbuf, %d\\n\", ret);\n\t\tif (ud->side == USBIP_STUB) {\n\t\t\tusbip_event_add(ud, SDEV_EVENT_ERROR_TCP);\n\t\t} else {\n\t\t\tusbip_event_add(ud, VDEV_EVENT_ERROR_TCP);\n\t\t\treturn -EPIPE;\n\t\t}\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "load_kernel_module_list (void)\n{\n  GHashTable *modules = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n  g_autofree char *modules_data = NULL;\n  g_autoptr(GError) error = NULL;\n  char *start, *end;\n  if (!g_file_get_contents (\"/proc/modules\", &modules_data, NULL, &error))\n    {\n      g_info (\"Failed to read /proc/modules: %s\", error->message);\n      return modules;\n    }\n  start = modules_data;\n  while (TRUE)\n    {\n      end = strchr (start, ' ');\n      if (end == NULL)\n        break;\n      g_hash_table_add (modules, g_strndup (start, (end - start)));\n      start = strchr (end, '\\n');\n      if (start == NULL)\n        break;\n      start++;\n    }\n  return modules;\n}", "target": 1}
{"code": "static int inotify_release(struct inode *ignored, struct file *file)\n{\n\tstruct fsnotify_group *group = file->private_data;\n\tstruct user_struct *user = group->inotify_data.user;\n\tpr_debug(\"%s: group=%p\\n\", __func__, group);\n\tfsnotify_clear_marks_by_group(group);\n\tfsnotify_put_group(group);\n\tatomic_dec(&user->inotify_devs);\n\treturn 0;\n}", "target": 1}
{"code": "int main(int argc, char *argv[])\n{\n    FILE *iplist = NULL;\n    plist_t root_node = NULL;\n    char *plist_out = NULL;\n    uint32_t size = 0;\n    int read_size = 0;\n    char *plist_entire = NULL;\n    struct stat filestats;\n    options_t *options = parse_arguments(argc, argv);\n    if (!options)\n    {\n        print_usage(argc, argv);\n        return 0;\n    }\n    iplist = fopen(options->in_file, \"rb\");\n    if (!iplist) {\n        free(options);\n        return 1;\n    }\n    stat(options->in_file, &filestats);\n    if (filestats.st_size < 8) {\n        printf(\"ERROR: Input file is too small to contain valid plist data.\\n\");\n        return -1;\n    }\n    plist_entire = (char *) malloc(sizeof(char) * (filestats.st_size + 1));\n    read_size = fread(plist_entire, sizeof(char), filestats.st_size, iplist);\n    fclose(iplist);\n    if (memcmp(plist_entire, \"bplist00\", 8) == 0)\n    {\n        plist_from_bin(plist_entire, read_size, &root_node);\n        plist_to_xml(root_node, &plist_out, &size);\n    }\n    else\n    {\n        plist_from_xml(plist_entire, read_size, &root_node);\n        plist_to_bin(root_node, &plist_out, &size);\n    }\n    plist_free(root_node);\n    free(plist_entire);\n    if (plist_out)\n    {\n        if (options->out_file != NULL)\n        {\n            FILE *oplist = fopen(options->out_file, \"wb\");\n            if (!oplist) {\n                free(options);\n                return 1;\n            }\n            fwrite(plist_out, size, sizeof(char), oplist);\n            fclose(oplist);\n        }\n        else\n            fwrite(plist_out, size, sizeof(char), stdout);\n        free(plist_out);\n    }\n    else\n        printf(\"ERROR: Failed to convert input file.\\n\");\n    free(options);\n    return 0;\n}", "target": 0}
{"code": "LogLuvClose(TIFF* tif)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\ttd->td_samplesperpixel =\n\t    (td->td_photometric == PHOTOMETRIC_LOGL) ? 1 : 3;\n\ttd->td_bitspersample = 16;\n\ttd->td_sampleformat = SAMPLEFORMAT_INT;\n}", "target": 1}
{"code": "static int on_version_message(struct nvnc_client* client)\n{\n\tstruct nvnc* server = client->server;\n\tif (client->buffer_len - client->buffer_index < 12)\n\t\treturn 0;\n\tchar version_string[13];\n\tmemcpy(version_string, client->msg_buffer + client->buffer_index, 12);\n\tversion_string[12] = '\\0';\n\tif (strcmp(RFB_VERSION_MESSAGE, version_string) != 0)\n\t\treturn handle_unsupported_version(client);\n\tuint8_t buf[sizeof(struct rfb_security_types_msg) +\n\t\tSECURITY_TYPES_MAX] = {};\n\tstruct rfb_security_types_msg* security =\n\t\t(struct rfb_security_types_msg*)buf;\n\tsecurity->n = 0;\n\tif (server->auth_flags & NVNC_AUTH_REQUIRE_AUTH) {\n\t\tassert(server->auth_fn);\n#ifdef ENABLE_TLS\n\t\tif (server->tls_creds) {\n\t\t\tsecurity->types[security->n++] = RFB_SECURITY_TYPE_VENCRYPT;\n\t\t}\n#endif\n#ifdef HAVE_CRYPTO\n\t\tsecurity->types[security->n++] = RFB_SECURITY_TYPE_RSA_AES256;\n\t\tsecurity->types[security->n++] = RFB_SECURITY_TYPE_RSA_AES;\n\t\tif (!(server->auth_flags & NVNC_AUTH_REQUIRE_ENCRYPTION)) {\n\t\t\tsecurity->types[security->n++] = RFB_SECURITY_TYPE_APPLE_DH;\n\t\t}\n#endif\n\t} else {\n\t\tsecurity->n = 1;\n\t\tsecurity->types[0] = RFB_SECURITY_TYPE_NONE;\n\t}\n\tif (security->n == 0) {\n\t\tnvnc_log(NVNC_LOG_PANIC, \"Failed to satisfy requested security constraints\");\n\t}\n\tstream_write(client->net_stream, security, sizeof(*security) +\n\t\t\tsecurity->n, NULL, NULL);\n\tclient->state = VNC_CLIENT_STATE_WAITING_FOR_SECURITY;\n\treturn 12;\n}", "target": 1}
{"code": "static int _process_request_metaflags(mcp_parser_t *pr, int token) {\n    if (pr->ntokens <= token) {\n        pr->t.meta.flags = 0; \n        return 0;\n    }\n    const char *cur = pr->request + pr->tokens[token];\n    const char *end = pr->request + pr->reqlen - 2;\n    int state = 0;\n    while (cur != end) {\n        switch (state) {\n            case 0:\n                if (*cur == ' ') {\n                    cur++;\n                } else {\n                    if (*cur < 65 || *cur > 122) {\n                        return -1;\n                    }\n                    P_DEBUG(\"%s: setting meta flag: %d\\n\", __func__, *cur - 65);\n                    pr->t.meta.flags |= (uint64_t)1 << (*cur - 65);\n                    state = 1;\n                }\n                break;\n            case 1:\n                if (*cur != ' ') {\n                    cur++;\n                } else {\n                    state = 0;\n                }\n                break;\n        }\n    }\n    if (pr->t.meta.flags & ((uint64_t)1 << 48)) {\n        pr->noreply = true;\n    }\n    return 0;\n}", "target": 1}
{"code": "R_API char *r_str_escape_sh(const char *buf) {\n\tr_return_val_if_fail (buf, NULL);\n\tchar *new_buf = malloc (1 + strlen (buf) * 2);\n\tif (!new_buf) {\n\t\treturn NULL;\n\t}\n\tconst char *p = buf;\n\tchar *q = new_buf;\n\twhile (*p) {\n\t\tswitch (*p) {\n#if __UNIX__\n\t\tcase '$':\n\t\tcase '`':\n#endif\n\t\tcase '\\\\':\n\t\tcase '\"':\n\t\t\t*q++ = '\\\\';\n\t\tdefault:\n\t\t\t*q++ = *p++;\n\t\t\tbreak;\n\t\t}\n\t}\n\t*q = '\\0';\n\treturn new_buf;\n}", "target": 0}
{"code": "static int do_remount(struct path *path, int flags, int mnt_flags,\n\t\t      void *data)\n{\n\tint err;\n\tstruct super_block *sb = path->mnt->mnt_sb;\n\tstruct mount *mnt = real_mount(path->mnt);\n\tif (!check_mnt(mnt))\n\t\treturn -EINVAL;\n\tif (path->dentry != path->mnt->mnt_root)\n\t\treturn -EINVAL;\n\tif ((mnt->mnt.mnt_flags & MNT_LOCK_READONLY) &&\n\t    !(mnt_flags & MNT_READONLY)) {\n\t\treturn -EPERM;\n\t}\n\tif ((mnt->mnt.mnt_flags & MNT_LOCK_NODEV) &&\n\t    !(mnt_flags & MNT_NODEV)) {\n\t\treturn -EPERM;\n\t}\n\tif ((mnt->mnt.mnt_flags & MNT_LOCK_NOSUID) &&\n\t    !(mnt_flags & MNT_NOSUID)) {\n\t\treturn -EPERM;\n\t}\n\tif ((mnt->mnt.mnt_flags & MNT_LOCK_NOEXEC) &&\n\t    !(mnt_flags & MNT_NOEXEC)) {\n\t\treturn -EPERM;\n\t}\n\tif ((mnt->mnt.mnt_flags & MNT_LOCK_ATIME) &&\n\t    ((mnt->mnt.mnt_flags & MNT_ATIME_MASK) != (mnt_flags & MNT_ATIME_MASK))) {\n\t\treturn -EPERM;\n\t}\n\terr = security_sb_remount(sb, data);\n\tif (err)\n\t\treturn err;\n\tdown_write(&sb->s_umount);\n\tif (flags & MS_BIND)\n\t\terr = change_mount_flags(path->mnt, flags);\n\telse if (!capable(CAP_SYS_ADMIN))\n\t\terr = -EPERM;\n\telse\n\t\terr = do_remount_sb(sb, flags, data, 0);\n\tif (!err) {\n\t\tlock_mount_hash();\n\t\tmnt_flags |= mnt->mnt.mnt_flags & ~MNT_USER_SETTABLE_MASK;\n\t\tmnt->mnt.mnt_flags = mnt_flags;\n\t\ttouch_mnt_namespace(mnt->mnt_ns);\n\t\tunlock_mount_hash();\n\t}\n\tup_write(&sb->s_umount);\n\treturn err;\n}", "target": 0}
{"code": "static void xml_parser_dtor(zend_rsrc_list_entry *rsrc TSRMLS_DC)\n{\n\txml_parser *parser = (xml_parser *)rsrc->ptr;\n\tif (parser->parser) {\n\t\tXML_ParserFree(parser->parser);\n\t}\n\tif (parser->ltags) {\n\t\tint inx;\n\t\tfor (inx = 0; ((inx < parser->level) && (inx < XML_MAXLEVEL)); inx++)\n\t\t\tefree(parser->ltags[ inx ]);\n\t\tefree(parser->ltags);\n\t}\n\tif (parser->startElementHandler) {\n\t\tzval_ptr_dtor(&parser->startElementHandler);\n\t}\n\tif (parser->endElementHandler) {\n\t\tzval_ptr_dtor(&parser->endElementHandler);\n\t}\n\tif (parser->characterDataHandler) {\n\t\tzval_ptr_dtor(&parser->characterDataHandler);\n\t}\n\tif (parser->processingInstructionHandler) {\n\t\tzval_ptr_dtor(&parser->processingInstructionHandler);\n\t}\n\tif (parser->defaultHandler) {\n\t\tzval_ptr_dtor(&parser->defaultHandler);\n\t}\n\tif (parser->unparsedEntityDeclHandler) {\n\t\tzval_ptr_dtor(&parser->unparsedEntityDeclHandler);\n\t}\n\tif (parser->notationDeclHandler) {\n\t\tzval_ptr_dtor(&parser->notationDeclHandler);\n\t}\n\tif (parser->externalEntityRefHandler) {\n\t\tzval_ptr_dtor(&parser->externalEntityRefHandler);\n\t}\n\tif (parser->unknownEncodingHandler) {\n\t\tzval_ptr_dtor(&parser->unknownEncodingHandler);\n\t}\n\tif (parser->startNamespaceDeclHandler) {\n\t\tzval_ptr_dtor(&parser->startNamespaceDeclHandler);\n\t}\n\tif (parser->endNamespaceDeclHandler) {\n\t\tzval_ptr_dtor(&parser->endNamespaceDeclHandler);\n\t}\n\tif (parser->baseURI) {\n\t\tefree(parser->baseURI);\n\t}\n\tif (parser->object) {\n\t\tzval_ptr_dtor(&parser->object);\n\t}\n\tefree(parser);\n}", "target": 0}
{"code": "static freelist_idx_t next_random_slot(union freelist_init_state *state)\n{\n\treturn (state->list[state->pos++] + state->rand) % state->count;\n}", "target": 1}
{"code": "static uint16_t nvme_changed_nslist(NvmeCtrl *n, uint8_t rae, uint32_t buf_len,\n                                    uint64_t off, NvmeRequest *req)\n{\n    uint32_t nslist[1024];\n    uint32_t trans_len;\n    int i = 0;\n    uint32_t nsid;\n    if (off >= sizeof(nslist)) {\n        trace_pci_nvme_err_invalid_log_page_offset(off, sizeof(nslist));\n        return NVME_INVALID_FIELD | NVME_DNR;\n    }\n    memset(nslist, 0x0, sizeof(nslist));\n    trans_len = MIN(sizeof(nslist) - off, buf_len);\n    while ((nsid = find_first_bit(n->changed_nsids, NVME_CHANGED_NSID_SIZE)) !=\n            NVME_CHANGED_NSID_SIZE) {\n        if (i == ARRAY_SIZE(nslist)) {\n            memset(nslist, 0x0, sizeof(nslist));\n            nslist[0] = 0xffffffff;\n            break;\n        }\n        nslist[i++] = nsid;\n        clear_bit(nsid, n->changed_nsids);\n    }\n    if (nslist[0] == 0xffffffff) {\n        bitmap_zero(n->changed_nsids, NVME_CHANGED_NSID_SIZE);\n    }\n    if (!rae) {\n        nvme_clear_events(n, NVME_AER_TYPE_NOTICE);\n    }\n    return nvme_c2h(n, ((uint8_t *)nslist) + off, trans_len, req);\n}", "target": 0}
{"code": "static __always_inline int slab_trylock(struct page *page)\n{\n\tint rc = 1;\n\trc = bit_spin_trylock(PG_locked, &page->flags);\n\treturn rc;\n}", "target": 0}
{"code": "static struct rq *__migrate_task(struct rq *rq, struct task_struct *p, int dest_cpu)\n{\n\tif (unlikely(!cpu_active(dest_cpu)))\n\t\treturn rq;\n\tif (!cpumask_test_cpu(dest_cpu, tsk_cpus_allowed(p)))\n\t\treturn rq;\n\trq = move_queued_task(rq, p, dest_cpu);\n\treturn rq;\n}", "target": 0}
{"code": "static int mount_autodev(const char *name, const struct lxc_rootfs *rootfs, const char *lxcpath)\n{\n\tint ret;\n\tsize_t clen;\n\tchar *path;\n\tINFO(\"Mounting container /dev\");\n\tclen = (rootfs->path ? strlen(rootfs->mount) : 0) + 9;\n\tpath = alloca(clen);\n\tret = snprintf(path, clen, \"%s/dev\", rootfs->path ? rootfs->mount : \"\");\n\tif (ret < 0 || ret >= clen)\n\t\treturn -1;\n\tif (!dir_exists(path)) {\n\t\tWARN(\"No /dev in container.\");\n\t\tWARN(\"Proceeding without autodev setup\");\n\t\treturn 0;\n\t}\n\tif (mount(\"none\", path, \"tmpfs\", 0, \"size=100000,mode=755\")) {\n\t\tSYSERROR(\"Failed mounting tmpfs onto %s\\n\", path);\n\t\treturn false;\n\t}\n\tINFO(\"Mounted tmpfs onto %s\",  path);\n\tret = snprintf(path, clen, \"%s/dev/pts\", rootfs->path ? rootfs->mount : \"\");\n\tif (ret < 0 || ret >= clen)\n\t\treturn -1;\n\tif (!dir_exists(path)) {\n\t\tret = mkdir(path, S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);\n\t\tif (ret) {\n\t\t\tSYSERROR(\"Failed to create /dev/pts in container\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\tINFO(\"Mounted container /dev\");\n\treturn 0;\n}", "target": 1}
{"code": "static int uvesafb_setcmap(struct fb_cmap *cmap, struct fb_info *info)\n{\n\tstruct uvesafb_pal_entry *entries;\n\tint shift = 16 - dac_width;\n\tint i, err = 0;\n\tif (info->var.bits_per_pixel == 8) {\n\t\tif (cmap->start + cmap->len > info->cmap.start +\n\t\t    info->cmap.len || cmap->start < info->cmap.start)\n\t\t\treturn -EINVAL;\n\t\tentries = kmalloc(sizeof(*entries) * cmap->len, GFP_KERNEL);\n\t\tif (!entries)\n\t\t\treturn -ENOMEM;\n\t\tfor (i = 0; i < cmap->len; i++) {\n\t\t\tentries[i].red   = cmap->red[i]   >> shift;\n\t\t\tentries[i].green = cmap->green[i] >> shift;\n\t\t\tentries[i].blue  = cmap->blue[i]  >> shift;\n\t\t\tentries[i].pad   = 0;\n\t\t}\n\t\terr = uvesafb_setpalette(entries, cmap->len, cmap->start, info);\n\t\tkfree(entries);\n\t} else {\n\t\tfor (i = 0; i < cmap->len; i++) {\n\t\t\terr |= uvesafb_setcolreg(cmap->start + i, cmap->red[i],\n\t\t\t\t\t\tcmap->green[i], cmap->blue[i],\n\t\t\t\t\t\t0, info);\n\t\t}\n\t}\n\treturn err;\n}", "target": 1}
{"code": "static void bio_map_kern_endio(struct bio *bio)\n{\n\tbio_put(bio);\n}", "target": 0}
{"code": "static ssize_t fuse_fill_write_pages(struct fuse_req *req,\n\t\t\t       struct address_space *mapping,\n\t\t\t       struct iov_iter *ii, loff_t pos)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(mapping->host);\n\tunsigned offset = pos & (PAGE_CACHE_SIZE - 1);\n\tsize_t count = 0;\n\tint err;\n\treq->in.argpages = 1;\n\treq->page_descs[0].offset = offset;\n\tdo {\n\t\tsize_t tmp;\n\t\tstruct page *page;\n\t\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\t\tsize_t bytes = min_t(size_t, PAGE_CACHE_SIZE - offset,\n\t\t\t\t     iov_iter_count(ii));\n\t\tbytes = min_t(size_t, bytes, fc->max_write - count);\n again:\n\t\terr = -EFAULT;\n\t\tif (iov_iter_fault_in_readable(ii, bytes))\n\t\t\tbreak;\n\t\terr = -ENOMEM;\n\t\tpage = grab_cache_page_write_begin(mapping, index, 0);\n\t\tif (!page)\n\t\t\tbreak;\n\t\tif (mapping_writably_mapped(mapping))\n\t\t\tflush_dcache_page(page);\n\t\ttmp = iov_iter_copy_from_user_atomic(page, ii, offset, bytes);\n\t\tflush_dcache_page(page);\n\t\tif (!tmp) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tbytes = min(bytes, iov_iter_single_seg_count(ii));\n\t\t\tgoto again;\n\t\t}\n\t\terr = 0;\n\t\treq->pages[req->num_pages] = page;\n\t\treq->page_descs[req->num_pages].length = tmp;\n\t\treq->num_pages++;\n\t\tiov_iter_advance(ii, tmp);\n\t\tcount += tmp;\n\t\tpos += tmp;\n\t\toffset += tmp;\n\t\tif (offset == PAGE_CACHE_SIZE)\n\t\t\toffset = 0;\n\t\tif (!fc->big_writes)\n\t\t\tbreak;\n\t} while (iov_iter_count(ii) && count < fc->max_write &&\n\t\t req->num_pages < req->max_pages && offset == 0);\n\treturn count > 0 ? count : err;\n}", "target": 1}
{"code": "static int pfkey_recvmsg(struct kiocb *kiocb,\n\t\t\t struct socket *sock, struct msghdr *msg, size_t len,\n\t\t\t int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\tstruct sk_buff *skb;\n\tint copied, err;\n\terr = -EINVAL;\n\tif (flags & ~(MSG_PEEK|MSG_DONTWAIT|MSG_TRUNC|MSG_CMSG_COMPAT))\n\t\tgoto out;\n\tmsg->msg_namelen = 0;\n\tskb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &err);\n\tif (skb == NULL)\n\t\tgoto out;\n\tcopied = skb->len;\n\tif (copied > len) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto out_free;\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\terr = (flags & MSG_TRUNC) ? skb->len : copied;\n\tif (pfk->dump.dump != NULL &&\n\t    3 * atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf)\n\t\tpfkey_do_dump(pfk);\nout_free:\n\tskb_free_datagram(sk, skb);\nout:\n\treturn err;\n}", "target": 1}
{"code": "UpdatePinhole(struct upnphttp * h, const char * action, const char * ns)\n{\n#if 0\n\tstatic const char resp[] =\n\t\t\"<u:UpdatePinholeResponse \"\n\t\t\"xmlns:u=\\\"urn:schemas-upnp-org:service:WANIPv6FirewallControl:1\\\">\"\n\t\t\"</u:UpdatePinholeResponse>\";\n#endif\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"</u:%sResponse>\";\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tconst char * uid_str, * leaseTime;\n\tchar iaddr[INET6_ADDRSTRLEN];\n\tunsigned short iport;\n\tint ltime;\n\tint uid;\n\tint n;\n\tif(CheckStatus(h)==0)\n\t\treturn;\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tuid_str = GetValueFromNameValueList(&data, \"UniqueID\");\n\tleaseTime = GetValueFromNameValueList(&data, \"NewLeaseTime\");\n\tuid = uid_str ? atoi(uid_str) : -1;\n\tltime = leaseTime ? atoi(leaseTime) : -1;\n\tClearNameValueList(&data);\n\tif(uid < 0 || uid > 65535 || ltime <= 0 || ltime > 86400)\n\t{\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n\tn = upnp_get_pinhole_info(uid, NULL, 0, NULL,\n\t                          iaddr, sizeof(iaddr), &iport,\n\t                          NULL, \n\t                          NULL, 0, \n\t                          NULL, NULL);\n\tif (n >= 0)\n\t{\n\t\tif(PinholeVerification(h, iaddr, iport) <= 0)\n\t\t\treturn;\n\t}\n\telse if(n == -2)\n\t{\n\t\tSoapError(h, 704, \"NoSuchEntry\");\n\t\treturn;\n\t}\n\telse\n\t{\n\t\tSoapError(h, 501, \"ActionFailed\");\n\t\treturn;\n\t}\n\tsyslog(LOG_INFO, \"%s: (inbound) updating lease duration to %d for pinhole with ID: %d\",\n\t       action, ltime, uid);\n\tn = upnp_update_inboundpinhole(uid, ltime);\n\tif(n == -1)\n\t\tSoapError(h, 704, \"NoSuchEntry\");\n\telse if(n < 0)\n\t\tSoapError(h, 501, \"ActionFailed\");\n\telse {\n\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t                   action, ns, action);\n\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t}\n}", "target": 0}
{"code": "void exit_sem(struct task_struct *tsk)\n{\n\tstruct sem_undo_list *ulp;\n\tulp = tsk->sysvsem.undo_list;\n\tif (!ulp)\n\t\treturn;\n\ttsk->sysvsem.undo_list = NULL;\n\tif (!atomic_dec_and_test(&ulp->refcnt))\n\t\treturn;\n\tfor (;;) {\n\t\tstruct sem_array *sma;\n\t\tstruct sem_undo *un;\n\t\tstruct list_head tasks;\n\t\tint semid;\n\t\tint i;\n\t\trcu_read_lock();\n\t\tun = list_entry_rcu(ulp->list_proc.next,\n\t\t\t\t    struct sem_undo, list_proc);\n\t\tif (&un->list_proc == &ulp->list_proc)\n\t\t\tsemid = -1;\n\t\t else\n\t\t\tsemid = un->semid;\n\t\trcu_read_unlock();\n\t\tif (semid == -1)\n\t\t\tbreak;\n\t\tsma = sem_lock_check(tsk->nsproxy->ipc_ns, un->semid);\n\t\tif (IS_ERR(sma))\n\t\t\tcontinue;\n\t\tun = __lookup_undo(ulp, semid);\n\t\tif (un == NULL) {\n\t\t\tsem_unlock(sma);\n\t\t\tcontinue;\n\t\t}\n\t\tassert_spin_locked(&sma->sem_perm.lock);\n\t\tlist_del(&un->list_id);\n\t\tspin_lock(&ulp->lock);\n\t\tlist_del_rcu(&un->list_proc);\n\t\tspin_unlock(&ulp->lock);\n\t\tfor (i = 0; i < sma->sem_nsems; i++) {\n\t\t\tstruct sem * semaphore = &sma->sem_base[i];\n\t\t\tif (un->semadj[i]) {\n\t\t\t\tsemaphore->semval += un->semadj[i];\n\t\t\t\tif (semaphore->semval < 0)\n\t\t\t\t\tsemaphore->semval = 0;\n\t\t\t\tif (semaphore->semval > SEMVMX)\n\t\t\t\t\tsemaphore->semval = SEMVMX;\n\t\t\t\tsemaphore->sempid = task_tgid_vnr(current);\n\t\t\t}\n\t\t}\n\t\tINIT_LIST_HEAD(&tasks);\n\t\tdo_smart_update(sma, NULL, 0, 1, &tasks);\n\t\tsem_unlock(sma);\n\t\twake_up_sem_queue_do(&tasks);\n\t\tkfree_rcu(un, rcu);\n\t}\n\tkfree(ulp);\n}", "target": 1}
{"code": "void gf_av1_reset_state(AV1State *state, Bool is_destroy)\n{\n\tGF_List *l1, *l2;\n\tif (state->frame_state.header_obus) {\n\t\twhile (gf_list_count(state->frame_state.header_obus)) {\n\t\t\tGF_AV1_OBUArrayEntry *a = (GF_AV1_OBUArrayEntry*)gf_list_pop_back(state->frame_state.header_obus);\n\t\t\tif (a->obu) gf_free(a->obu);\n\t\t\tgf_free(a);\n\t\t}\n\t}\n\tif (state->frame_state.frame_obus) {\n\t\twhile (gf_list_count(state->frame_state.frame_obus)) {\n\t\t\tGF_AV1_OBUArrayEntry *a = (GF_AV1_OBUArrayEntry*)gf_list_pop_back(state->frame_state.frame_obus);\n\t\t\tif (a->obu) gf_free(a->obu);\n\t\t\tgf_free(a);\n\t\t}\n\t}\n\tl1 = state->frame_state.frame_obus;\n\tl2 = state->frame_state.header_obus;\n\tmemset(&state->frame_state, 0, sizeof(AV1StateFrame));\n\tstate->frame_state.is_first_frame = GF_TRUE;\n\tif (is_destroy) {\n\t\tgf_list_del(l1);\n\t\tgf_list_del(l2);\n\t\tif (state->bs) {\n\t\t\tif (gf_bs_get_position(state->bs)) {\n\t\t\t\tu32 size;\n\t\t\t\tgf_bs_get_content_no_truncate(state->bs, &state->frame_obus, &size, &state->frame_obus_alloc);\n\t\t\t}\n\t\t\tgf_bs_del(state->bs);\n\t\t}\n\t\tstate->bs = NULL;\n\t}\n\telse {\n\t\tstate->frame_state.frame_obus = l1;\n\t\tstate->frame_state.header_obus = l2;\n\t\tif (state->bs)\n\t\t\tgf_bs_seek(state->bs, 0);\n\t}\n}", "target": 1}
{"code": "BOOL freerdp_bitmap_planar_context_reset(BITMAP_PLANAR_CONTEXT* context, UINT32 width,\n                                         UINT32 height)\n{\n\tif (!context)\n\t\treturn FALSE;\n\tcontext->bgr = FALSE;\n\tcontext->maxWidth = PLANAR_ALIGN(width, 4);\n\tcontext->maxHeight = PLANAR_ALIGN(height, 4);\n\tcontext->maxPlaneSize = context->maxWidth * context->maxHeight;\n\tcontext->nTempStep = context->maxWidth * 4;\n\tfree(context->planesBuffer);\n\tfree(context->pTempData);\n\tfree(context->deltaPlanesBuffer);\n\tfree(context->rlePlanesBuffer);\n\tcontext->planesBuffer = calloc(context->maxPlaneSize, 4);\n\tcontext->pTempData = calloc(context->maxPlaneSize, 6);\n\tcontext->deltaPlanesBuffer = calloc(context->maxPlaneSize, 4);\n\tcontext->rlePlanesBuffer = calloc(context->maxPlaneSize, 4);\n\tif (!context->planesBuffer || !context->pTempData || !context->deltaPlanesBuffer ||\n\t    !context->rlePlanesBuffer)\n\t\treturn FALSE;\n\tcontext->planes[0] = &context->planesBuffer[context->maxPlaneSize * 0];\n\tcontext->planes[1] = &context->planesBuffer[context->maxPlaneSize * 1];\n\tcontext->planes[2] = &context->planesBuffer[context->maxPlaneSize * 2];\n\tcontext->planes[3] = &context->planesBuffer[context->maxPlaneSize * 3];\n\tcontext->deltaPlanes[0] = &context->deltaPlanesBuffer[context->maxPlaneSize * 0];\n\tcontext->deltaPlanes[1] = &context->deltaPlanesBuffer[context->maxPlaneSize * 1];\n\tcontext->deltaPlanes[2] = &context->deltaPlanesBuffer[context->maxPlaneSize * 2];\n\tcontext->deltaPlanes[3] = &context->deltaPlanesBuffer[context->maxPlaneSize * 3];\n\treturn TRUE;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    ReshapeOp::Compute(ctx);\n    const float input_min_float = ctx->input(2).flat<float>()(0);\n    const float input_max_float = ctx->input(3).flat<float>()(0);\n    Tensor* output_min = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(1, TensorShape({}), &output_min));\n    output_min->flat<float>()(0) = input_min_float;\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(2, TensorShape({}), &output_max));\n    output_max->flat<float>()(0) = input_max_float;\n  }", "target": 1}
{"code": "DROGON_TEST(HttpFile)\n{\n    SUBSECTION(Save)\n    {\n        HttpFileImpl file;\n        file.setFileName(\"test_file_name\");\n        file.setFile(\"test\", 4);\n        auto out = file.save(\"./test_uploads_dir\");\n        CHECK(out == 0);\n        CHECK(filesystem::exists(\"./test_uploads_dir/test_file_name\"));\n        filesystem::remove_all(\"./test_uploads_dir\");\n    }\n    SUBSECTION(SavePathRelativeTraversal)\n    {\n        auto uploadPath = filesystem::current_path() / \"test_uploads_dir\";\n        HttpFileImpl file;\n        file.setFileName(\"../test_malicious_file_name\");\n        file.setFile(\"test\", 4);\n        auto out = file.save(uploadPath.string());\n        CHECK(out == -1);\n        CHECK(!filesystem::exists(uploadPath / \"../test_malicious_file_name\"));\n        filesystem::remove_all(uploadPath);\n        filesystem::remove(uploadPath / \"../test_malicious_file_name\");\n    }\n    SUBSECTION(SavePathAbsoluteTraversal)\n    {\n        HttpFileImpl file;\n        file.setFileName(\"/tmp/test_malicious_file_name\");\n        file.setFile(\"test\", 4);\n        auto out = file.save(\"./test_uploads_dir\");\n        CHECK(out == -1);\n        CHECK(!filesystem::exists(\"/tmp/test_malicious_file_name\"));\n        filesystem::remove_all(\"test_uploads_dir\");\n        filesystem::remove_all(\"/tmp/test_malicious_file_name\");\n    }\n}", "target": 0}
{"code": "GF_Err tenc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu8 iv_size;\n\tGF_TrackEncryptionBox *ptr = (GF_TrackEncryptionBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 3);\n\tgf_bs_read_u8(bs); \n\tif (!ptr->version) {\n\t\tgf_bs_read_u8(bs); \n\t} else {\n\t\tptr->crypt_byte_block = gf_bs_read_int(bs, 4);\n\t\tptr->skip_byte_block = gf_bs_read_int(bs, 4);\n\t}\n\tptr->isProtected = gf_bs_read_u8(bs);\n\tISOM_DECREASE_SIZE(ptr, 17);\n\tptr->key_info[0] = 0;\n\tptr->key_info[1] = 0;\n\tptr->key_info[2] = 0;\n\tptr->key_info[3] = iv_size = gf_bs_read_u8(bs);\n\tgf_bs_read_data(bs, ptr->key_info+4, 16);\n\tif (!iv_size && ptr->isProtected) {\n\t\tISOM_DECREASE_SIZE(ptr, 1);\n\t\tiv_size = ptr->key_info[20] = gf_bs_read_u8(bs);\n\t\tISOM_DECREASE_SIZE(ptr, ptr->key_info[20]);\n\t\tif ((iv_size!=8) && (iv_size!=16)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid constant IV size %d, must be 8 or 16\\n\", (u32) iv_size));\n\t\t\tptr->key_info[20] = 16;\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tgf_bs_read_data(bs, ptr->key_info+21, iv_size);\n\t}\n\telse if ((iv_size!=0) && (iv_size!=8) && (iv_size!=16)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid IV size %d, must be 0, 8 or 16\\n\", (u32) iv_size));\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "static void bond_setup(struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\trwlock_init(&bond->lock);\n\trwlock_init(&bond->curr_slave_lock);\n\tbond->params = bonding_defaults;\n\tbond->dev = bond_dev;\n\tINIT_LIST_HEAD(&bond->vlan_list);\n\tether_setup(bond_dev);\n\tbond_dev->netdev_ops = &bond_netdev_ops;\n\tbond_dev->ethtool_ops = &bond_ethtool_ops;\n\tbond_set_mode_ops(bond, bond->params.mode);\n\tbond_dev->destructor = bond_destructor;\n\tbond_dev->tx_queue_len = 0;\n\tbond_dev->flags |= IFF_MASTER|IFF_MULTICAST;\n\tbond_dev->priv_flags |= IFF_BONDING;\n\tbond_dev->priv_flags &= ~IFF_XMIT_DST_RELEASE;\n\tbond_dev->features |= NETIF_F_VLAN_CHALLENGED;\n\tbond_dev->features |= NETIF_F_LLTX;\n\tbond_dev->hw_features = BOND_VLAN_FEATURES |\n\t\t\t\tNETIF_F_HW_VLAN_TX |\n\t\t\t\tNETIF_F_HW_VLAN_RX |\n\t\t\t\tNETIF_F_HW_VLAN_FILTER;\n\tbond_dev->hw_features &= ~(NETIF_F_ALL_CSUM & ~NETIF_F_NO_CSUM);\n\tbond_dev->features |= bond_dev->hw_features;\n}", "target": 1}
{"code": "static int __init pf_init(void)\n{\t\t\t\t\n\tstruct pf_unit *pf;\n\tint unit;\n\tif (disable)\n\t\treturn -EINVAL;\n\tpf_init_units();\n\tif (pf_detect())\n\t\treturn -ENODEV;\n\tpf_busy = 0;\n\tif (register_blkdev(major, name)) {\n\t\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++)\n\t\t\tput_disk(pf->disk);\n\t\treturn -EBUSY;\n\t}\n\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n\t\tstruct gendisk *disk = pf->disk;\n\t\tif (!pf->present)\n\t\t\tcontinue;\n\t\tdisk->private_data = pf;\n\t\tadd_disk(disk);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int g2m_init_buffers(G2MContext *c)\n{\n    int aligned_height;\n    if (!c->framebuf || c->old_width < c->width || c->old_height < c->height) {\n        c->framebuf_stride = FFALIGN(c->width + 15, 16) * 3;\n        aligned_height     = c->height + 15;\n        av_free(c->framebuf);\n        c->framebuf = av_mallocz(c->framebuf_stride * aligned_height);\n        if (!c->framebuf)\n            return AVERROR(ENOMEM);\n    }\n    if (!c->synth_tile || !c->jpeg_tile ||\n        c->old_tile_w < c->tile_width ||\n        c->old_tile_h < c->tile_height) {\n        c->tile_stride = FFALIGN(c->tile_width, 16) * 3;\n        aligned_height = FFALIGN(c->tile_height,    16);\n        av_free(c->synth_tile);\n        av_free(c->jpeg_tile);\n        av_free(c->kempf_buf);\n        av_free(c->kempf_flags);\n        c->synth_tile  = av_mallocz(c->tile_stride      * aligned_height);\n        c->jpeg_tile   = av_mallocz(c->tile_stride      * aligned_height);\n        c->kempf_buf   = av_mallocz((c->tile_width + 1) * aligned_height\n                                    + FF_INPUT_BUFFER_PADDING_SIZE);\n        c->kempf_flags = av_mallocz( c->tile_width      * aligned_height);\n        if (!c->synth_tile || !c->jpeg_tile ||\n            !c->kempf_buf || !c->kempf_flags)\n            return AVERROR(ENOMEM);\n    }\n    return 0;\n}", "target": 0}
{"code": "    int32_t audio_io_osx::shutdown_audio_unit() {\n        OSStatus result = -1;\n        if (NULL != au_rec_) {\n            result = AudioOutputUnitStop(au_rec_);\n            if (0 != result) {\n                error(\"audio_io_osx: Error stopping Audio Unit (result=%d) \\n\", result);\n            }\n            result = AudioComponentInstanceDispose(au_rec_);\n            if (0 != result) {\n                error(\"audio_io_osx: Error disposing Audio Unit (result=%d) \\n\", result);\n            }\n            au_rec_ = NULL;\n        }\n        if (NULL != au_play_) {\n            result = AudioOutputUnitStop(au_play_);\n            if (0 != result) {\n                error(\"audio_io_osx: Error stopping Audio Unit (result=%d) \\n\", result);\n            }\n            result = AudioComponentInstanceDispose(au_play_);\n            if (0 != result) {\n                error(\"audio_io_osx: Error disposing Audio Unit (result=%d) \\n\", result);\n            }\n            au_play_ = NULL;\n        }\n        return 0;\n    }", "target": 0}
{"code": "static struct inode *ext4_alloc_inode(struct super_block *sb)\n{\n\tstruct ext4_inode_info *ei;\n\tei = kmem_cache_alloc(ext4_inode_cachep, GFP_NOFS);\n\tif (!ei)\n\t\treturn NULL;\n\tei->vfs_inode.i_version = 1;\n\tei->vfs_inode.i_data.writeback_index = 0;\n\tmemset(&ei->i_cached_extent, 0, sizeof(struct ext4_ext_cache));\n\tINIT_LIST_HEAD(&ei->i_prealloc_list);\n\tspin_lock_init(&ei->i_prealloc_lock);\n\tjbd2_journal_init_jbd_inode(&ei->jinode, &ei->vfs_inode);\n\tei->i_reserved_data_blocks = 0;\n\tei->i_reserved_meta_blocks = 0;\n\tei->i_allocated_meta_blocks = 0;\n\tei->i_da_metadata_calc_len = 0;\n\tei->i_delalloc_reserved_flag = 0;\n\tspin_lock_init(&(ei->i_block_reservation_lock));\n#ifdef CONFIG_QUOTA\n\tei->i_reserved_quota = 0;\n#endif\n\tINIT_LIST_HEAD(&ei->i_completed_io_list);\n\tspin_lock_init(&ei->i_completed_io_lock);\n\tei->cur_aio_dio = NULL;\n\tei->i_sync_tid = 0;\n\tei->i_datasync_tid = 0;\n\treturn &ei->vfs_inode;\n}", "target": 0}
{"code": "static inline void *nvme_addr_to_cmb(NvmeCtrl *n, hwaddr addr)\n{\n    hwaddr base = n->params.legacy_cmb ? n->cmb.mem.addr : n->cmb.cba;\n    return &n->cmb.buf[addr - base];\n}", "target": 0}
{"code": "ossl_cipher_update(int argc, VALUE *argv, VALUE self)\n{\n    EVP_CIPHER_CTX *ctx;\n    unsigned char *in;\n    long in_len, out_len;\n    VALUE data, str;\n    rb_scan_args(argc, argv, \"11\", &data, &str);\n    if (!RTEST(rb_attr_get(self, id_key_set)))\n\tossl_raise(eCipherError, \"key not set\");\n    StringValue(data);\n    in = (unsigned char *)RSTRING_PTR(data);\n    if ((in_len = RSTRING_LEN(data)) == 0)\n        ossl_raise(rb_eArgError, \"data must not be empty\");\n    GetCipher(self, ctx);\n    out_len = in_len+EVP_CIPHER_CTX_block_size(ctx);\n    if (out_len <= 0) {\n\tossl_raise(rb_eRangeError,\n\t\t   \"data too big to make output buffer: %ld bytes\", in_len);\n    }\n    if (NIL_P(str)) {\n        str = rb_str_new(0, out_len);\n    } else {\n        StringValue(str);\n        rb_str_resize(str, out_len);\n    }\n    if (!ossl_cipher_update_long(ctx, (unsigned char *)RSTRING_PTR(str), &out_len, in, in_len))\n\tossl_raise(eCipherError, NULL);\n    assert(out_len < RSTRING_LEN(str));\n    rb_str_set_len(str, out_len);\n    return str;\n}", "target": 0}
{"code": "njs_function_frame_save(njs_vm_t *vm, njs_frame_t *frame, u_char *pc)\n{\n    size_t              value_count, n;\n    njs_value_t         *start, *end, *p, **new, *value, **local;\n    njs_function_t      *function;\n    njs_native_frame_t  *active, *native;\n    *frame = *vm->active_frame;\n    frame->previous_active_frame = NULL;\n    native = &frame->native;\n    native->size = 0;\n    native->free = NULL;\n    native->free_size = 0;\n    active = &vm->active_frame->native;\n    value_count = njs_function_frame_value_count(active);\n    function = active->function;\n    new = (njs_value_t **) ((u_char *) native + NJS_FRAME_SIZE);\n    value = (njs_value_t *) (new + value_count\n                             + function->u.lambda->temp);\n    native->arguments = value;\n    native->arguments_offset = value + (function->args_offset - 1);\n    native->local = new + njs_function_frame_args_count(active);\n    native->temp = new + value_count;\n    native->pc = pc;\n    start = njs_function_frame_values(active, &end);\n    p = native->arguments;\n    while (start < end) {\n        *p = *start++;\n        *new++ = p++;\n    }\n    p = native->arguments;\n    local = native->local + function->args_offset;\n    for (n = 0; n < function->args_count; n++) {\n        if (!njs_is_valid(p)) {\n            njs_set_undefined(p);\n        }\n        *local++ = p++;\n    }\n    return NJS_OK;\n}", "target": 0}
{"code": "dhcpv6_print(netdissect_options *ndo,\n             const u_char *cp, u_int length, int indent)\n{\n    u_int i, t;\n    const u_char *tlv, *value;\n    uint16_t type, optlen;\n    i = 0;\n    while (i < length) {\n        if (i + 4 > length)\n            return -1;\n        tlv = cp + i;\n        type = EXTRACT_16BITS(tlv);\n        optlen = EXTRACT_16BITS(tlv + 2);\n        value = tlv + 4;\n        ND_PRINT((ndo, \"\\n\"));\n        for (t = indent; t > 0; t--)\n            ND_PRINT((ndo, \"\\t\"));\n        ND_PRINT((ndo, \"%s\", tok2str(dh6opt_str, \"Unknown\", type)));\n        ND_PRINT((ndo,\" (%u)\", optlen + 4 ));\n        if (i + 4 + optlen > length)\n            return -1;\n        switch (type) {\n            case DH6OPT_DNS_SERVERS:\n            case DH6OPT_SNTP_SERVERS: {\n                if (optlen % 16 != 0) {\n                    ND_PRINT((ndo, \" %s\", istr));\n                    return -1;\n                }\n                for (t = 0; t < optlen; t += 16)\n                    ND_PRINT((ndo, \" %s\", ip6addr_string(ndo, value + t)));\n            }\n                break;\n            case DH6OPT_DOMAIN_LIST: {\n                const u_char *tp = value;\n                while (tp < value + optlen) {\n                    ND_PRINT((ndo, \" \"));\n                    if ((tp = ns_nprint(ndo, tp, value + optlen)) == NULL)\n                        return -1;\n                }\n            }\n                break;\n        }\n        i += 4 + optlen;\n    }\n    return 0;\n}", "target": 0}
{"code": "  void resizeAndFillTable(\n      HeaderTable& table, HPACKHeader& header, uint32_t newMax,\n      uint32_t fillCount) {\n    uint32_t newCapacity = header.bytes() * newMax;\n    resizeTable(table, newCapacity, newMax);\n    for (size_t i = 0; i <= fillCount; ++i) {\n      EXPECT_EQ(table.add(header), true);\n    }\n    EXPECT_EQ(table.size(), newMax);\n    EXPECT_EQ(table.bytes(), newCapacity);\n  }", "target": 0}
{"code": "void cql_server::response::write_long_string(const sstring& s)\n{\n    write_int(cast_if_fits<int32_t>(s.size()));\n    _body.write(bytes_view(reinterpret_cast<const int8_t*>(s.data()), s.size()));\n}", "target": 0}
{"code": "static void scsi_free_request(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n    qemu_vfree(r->iov.iov_base);\n}", "target": 1}
{"code": "static void rtc_irq_eoi_tracking_reset(struct kvm_ioapic *ioapic)\n{\n\tioapic->rtc_status.pending_eoi = 0;\n\tbitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPUS);\n}", "target": 1}
{"code": "static int bcm_delete_rx_op(struct list_head *ops, struct bcm_msg_head *mh,\n\t\t\t    int ifindex)\n{\n\tstruct bcm_op *op, *n;\n\tlist_for_each_entry_safe(op, n, ops, list) {\n\t\tif ((op->can_id == mh->can_id) && (op->ifindex == ifindex) &&\n\t\t    (op->flags & CAN_FD_FRAME) == (mh->flags & CAN_FD_FRAME)) {\n\t\t\tif (op->ifindex) {\n\t\t\t\tif (op->rx_reg_dev) {\n\t\t\t\t\tstruct net_device *dev;\n\t\t\t\t\tdev = dev_get_by_index(sock_net(op->sk),\n\t\t\t\t\t\t\t       op->ifindex);\n\t\t\t\t\tif (dev) {\n\t\t\t\t\t\tbcm_rx_unreg(dev, op);\n\t\t\t\t\t\tdev_put(dev);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tcan_rx_unregister(sock_net(op->sk), NULL,\n\t\t\t\t\t\t  op->can_id,\n\t\t\t\t\t\t  REGMASK(op->can_id),\n\t\t\t\t\t\t  bcm_rx_handler, op);\n\t\t\tlist_del(&op->list);\n\t\t\tsynchronize_rcu();\n\t\t\tbcm_remove_op(op);\n\t\t\treturn 1; \n\t\t}\n\t}\n\treturn 0; \n}", "target": 0}
{"code": "tTcpIpPacketParsingResult ParaNdis_CheckSumVerifyFlat(\n                                                PVOID pBuffer,\n                                                ULONG ulDataLength,\n                                                ULONG flags,\n                                                LPCSTR caller)\n{\n    tCompletePhysicalAddress SGBuffer;\n    SGBuffer.Virtual = pBuffer;\n    SGBuffer.size = ulDataLength;\n    return ParaNdis_CheckSumVerify(&SGBuffer, ulDataLength, 0, flags, caller);\n}", "target": 1}
{"code": "void __refill_cfs_bandwidth_runtime(struct cfs_bandwidth *cfs_b)\n{\n\tu64 now;\n\tif (cfs_b->quota == RUNTIME_INF)\n\t\treturn;\n\tnow = sched_clock_cpu(smp_processor_id());\n\tcfs_b->runtime = cfs_b->quota;\n\tcfs_b->runtime_expires = now + ktime_to_ns(cfs_b->period);\n\tcfs_b->expires_seq++;\n}", "target": 1}
{"code": "void recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h, *g;\n\tunsigned int i;\n\tvmcb_mark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\tc = &svm->vmcb->control;\n\th = &svm->vmcb01.ptr->control;\n\tg = &svm->nested.ctl;\n\tfor (i = 0; i < MAX_INTERCEPT; i++)\n\t\tc->intercepts[i] = h->intercepts[i];\n\tif (g->int_ctl & V_INTR_MASKING_MASK) {\n\t\tvmcb_clr_intercept(c, INTERCEPT_CR8_READ);\n\t\tvmcb_clr_intercept(c, INTERCEPT_CR8_WRITE);\n\t\tvmcb_clr_intercept(c, INTERCEPT_VINTR);\n\t}\n\tvmcb_clr_intercept(c, INTERCEPT_VMMCALL);\n\tfor (i = 0; i < MAX_INTERCEPT; i++)\n\t\tc->intercepts[i] |= g->intercepts[i];\n\tif (!intercept_smi)\n\t\tvmcb_clr_intercept(c, INTERCEPT_SMI);\n\tvmcb_set_intercept(c, INTERCEPT_VMLOAD);\n\tvmcb_set_intercept(c, INTERCEPT_VMSAVE);\n}", "target": 0}
{"code": "compute_U_value_R2(std::string const& user_password,\n\t\t   QPDF::EncryptionData const& data)\n{\n    std::string k1 = QPDF::compute_encryption_key(user_password, data);\n    char udata[key_bytes];\n    pad_or_truncate_password_V4(\"\", udata);\n    pad_short_parameter(k1, data.getLengthBytes());\n    iterate_rc4(QUtil::unsigned_char_pointer(udata), key_bytes,\n\t\tQUtil::unsigned_char_pointer(k1),\n                data.getLengthBytes(), 1, false);\n    return std::string(udata, key_bytes);\n}", "target": 0}
{"code": "static void encode_compound_hdr(struct xdr_stream *xdr,\n\t\t\t\tstruct rpc_rqst *req,\n\t\t\t\tstruct compound_hdr *hdr)\n{\n\t__be32 *p;\n\tstruct rpc_auth *auth = req->rq_cred->cr_auth;\n\thdr->replen = RPC_REPHDRSIZE + auth->au_rslack + 3 + hdr->taglen;\n\tBUG_ON(hdr->taglen > NFS4_MAXTAGLEN);\n\tencode_string(xdr, hdr->taglen, hdr->tag);\n\tp = reserve_space(xdr, 8);\n\t*p++ = cpu_to_be32(hdr->minorversion);\n\thdr->nops_p = p;\n\t*p = cpu_to_be32(hdr->nops);\n}", "target": 0}
{"code": "std::wstring Utf8ToUtf16(const std::string& utf8_string) {\n  return MB2WC(utf8_string, CP_UTF8);\n}", "target": 1}
{"code": "feed_table_block_tag(struct table *tbl,\n\t\t     char *line, struct table_mode *mode, int indent, int cmd)\n{\n    int offset;\n    if (mode->indent_level <= 0 && indent == -1)\n\treturn;\n    if (mode->indent_level >= CHAR_MAX && indent == 1)\n\treturn;\n    setwidth(tbl, mode);\n    feed_table_inline_tag(tbl, line, mode, -1);\n    clearcontentssize(tbl, mode);\n    if (indent == 1) {\n\tmode->indent_level++;\n\tif (mode->indent_level <= MAX_INDENT_LEVEL)\n\t    tbl->indent += INDENT_INCR;\n    }\n    else if (indent == -1) {\n\tmode->indent_level--;\n\tif (mode->indent_level < MAX_INDENT_LEVEL)\n\t    tbl->indent -= INDENT_INCR;\n    }\n    if (tbl->indent < 0)\n\ttbl->indent = 0;\n    offset = tbl->indent;\n    if (cmd == HTML_DT) {\n\tif (mode->indent_level > 0 && mode->indent_level <= MAX_INDENT_LEVEL)\n\t    offset -= INDENT_INCR;\n\tif (offset < 0)\n\t    offset = 0;\n    }\n    if (tbl->indent > 0) {\n\tcheck_minimum0(tbl, 0);\n\taddcontentssize(tbl, offset);\n    }\n}", "target": 0}
{"code": "void __init set_dma_reserve(unsigned long new_dma_reserve)\n{\n\tdma_reserve = new_dma_reserve;\n}", "target": 0}
{"code": "static int __init ip6_tunnel_init(void)\n{\n\tint  err;\n\tif (xfrm6_tunnel_register(&ip4ip6_handler, AF_INET)) {\n\t\tprintk(KERN_ERR \"ip6_tunnel init: can't register ip4ip6\\n\");\n\t\terr = -EAGAIN;\n\t\tgoto out;\n\t}\n\tif (xfrm6_tunnel_register(&ip6ip6_handler, AF_INET6)) {\n\t\tprintk(KERN_ERR \"ip6_tunnel init: can't register ip6ip6\\n\");\n\t\terr = -EAGAIN;\n\t\tgoto unreg_ip4ip6;\n\t}\n\terr = register_pernet_device(&ip6_tnl_net_ops);\n\tif (err < 0)\n\t\tgoto err_pernet;\n\treturn 0;\nerr_pernet:\n\txfrm6_tunnel_deregister(&ip6ip6_handler, AF_INET6);\nunreg_ip4ip6:\n\txfrm6_tunnel_deregister(&ip4ip6_handler, AF_INET);\nout:\n\treturn err;\n}", "target": 1}
{"code": "int pipe_resize_ring(struct pipe_inode_info *pipe, unsigned int nr_slots)\n{\n\tstruct pipe_buffer *bufs;\n\tunsigned int head, tail, mask, n;\n\tmask = pipe->ring_size - 1;\n\thead = pipe->head;\n\ttail = pipe->tail;\n\tn = pipe_occupancy(pipe->head, pipe->tail);\n\tif (nr_slots < n)\n\t\treturn -EBUSY;\n\tbufs = kcalloc(nr_slots, sizeof(*bufs),\n\t\t       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);\n\tif (unlikely(!bufs))\n\t\treturn -ENOMEM;\n\tif (n > 0) {\n\t\tunsigned int h = head & mask;\n\t\tunsigned int t = tail & mask;\n\t\tif (h > t) {\n\t\t\tmemcpy(bufs, pipe->bufs + t,\n\t\t\t       n * sizeof(struct pipe_buffer));\n\t\t} else {\n\t\t\tunsigned int tsize = pipe->ring_size - t;\n\t\t\tif (h > 0)\n\t\t\t\tmemcpy(bufs + tsize, pipe->bufs,\n\t\t\t\t       h * sizeof(struct pipe_buffer));\n\t\t\tmemcpy(bufs, pipe->bufs + t,\n\t\t\t       tsize * sizeof(struct pipe_buffer));\n\t\t}\n\t}\n\thead = n;\n\ttail = 0;\n\tkfree(pipe->bufs);\n\tpipe->bufs = bufs;\n\tpipe->ring_size = nr_slots;\n\tif (pipe->max_usage > nr_slots)\n\t\tpipe->max_usage = nr_slots;\n\tpipe->tail = tail;\n\tpipe->head = head;\n\twake_up_interruptible(&pipe->wr_wait);\n\treturn 0;\n}", "target": 1}
{"code": "int fit_config_verify_required_sigs(const void *fit, int conf_noffset,\n\t\t\t\t    const void *sig_blob)\n{\n\tint noffset;\n\tint sig_node;\n\tint verified = 0;\n\tint reqd_sigs = 0;\n\tbool reqd_policy_all = true;\n\tconst char *reqd_mode;\n\tsig_node = fdt_subnode_offset(sig_blob, 0, FIT_SIG_NODENAME);\n\tif (sig_node < 0) {\n\t\tdebug(\"%s: No signature node found: %s\\n\", __func__,\n\t\t      fdt_strerror(sig_node));\n\t\treturn 0;\n\t}\n\treqd_mode = fdt_getprop(sig_blob, sig_node, \"required-mode\", NULL);\n\tif (reqd_mode && !strcmp(reqd_mode, \"any\"))\n\t\treqd_policy_all = false;\n\tdebug(\"%s: required-mode policy set to '%s'\\n\", __func__,\n\t      reqd_policy_all ? \"all\" : \"any\");\n\tfdt_for_each_subnode(noffset, sig_blob, sig_node) {\n\t\tconst char *required;\n\t\tint ret;\n\t\trequired = fdt_getprop(sig_blob, noffset, FIT_KEY_REQUIRED,\n\t\t\t\t       NULL);\n\t\tif (!required || strcmp(required, \"conf\"))\n\t\t\tcontinue;\n\t\treqd_sigs++;\n\t\tret = fit_config_verify_sig(fit, conf_noffset, sig_blob,\n\t\t\t\t\t    noffset);\n\t\tif (ret) {\n\t\t\tif (reqd_policy_all) {\n\t\t\t\tprintf(\"Failed to verify required signature '%s'\\n\",\n\t\t\t\t       fit_get_name(sig_blob, noffset, NULL));\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else {\n\t\t\tverified++;\n\t\t\tif (!reqd_policy_all)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (reqd_sigs && !verified) {\n\t\tprintf(\"Failed to verify 'any' of the required signature(s)\\n\");\n\t\treturn -EPERM;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static inline int ldsem_cmpxchg(long *old, long new, struct ld_semaphore *sem)\n{\n\tlong tmp = *old;\n\t*old = atomic_long_cmpxchg(&sem->count, *old, new);\n\treturn *old == tmp;\n}", "target": 1}
{"code": "static void tty_set_termios_ldisc(struct tty_struct *tty, int num)\n{\n\tdown_write(&tty->termios_rwsem);\n\ttty->termios.c_line = num;\n\tup_write(&tty->termios_rwsem);\n\ttty->disc_data = NULL;\n\ttty->receive_room = 0;\n}", "target": 0}
{"code": "int fp_invmod_mont_ct(fp_int *a, fp_int *b, fp_int *c, fp_digit mp)\n{\n  int i, j;\n#ifndef WOLFSSL_SMALL_STACK\n  fp_int t[1], e[1];\n  fp_int pre[CT_INV_MOD_PRE_CNT];\n#else\n  fp_int* t;\n  fp_int* e;\n  fp_int* pre;\n#endif\n#ifdef WOLFSSL_SMALL_STACK\n  t = (fp_int*)XMALLOC(sizeof(fp_int) * (2 + CT_INV_MOD_PRE_CNT), NULL,\n                                                           DYNAMIC_TYPE_BIGINT);\n  if (t == NULL)\n    return FP_MEM;\n  e = t + 1;\n  pre = t + 2;\n#endif\n  fp_init(t);\n  fp_init(e);\n  fp_init(&pre[0]);\n  fp_copy(a, &pre[0]);\n  for (i = 1; i < CT_INV_MOD_PRE_CNT; i++) {\n    fp_init(&pre[i]);\n    fp_sqr(&pre[i-1], &pre[i]);\n    fp_montgomery_reduce(&pre[i], b, mp);\n    fp_mul(&pre[i], a, &pre[i]);\n    fp_montgomery_reduce(&pre[i], b, mp);\n  }\n  fp_sub_d(b, 2, e);\n  for (i = fp_count_bits(e)-2, j = 1; i >= 0; i--, j++) {\n      if (!fp_is_bit_set(e, i) || j == CT_INV_MOD_PRE_CNT)\n          break;\n  }\n  fp_copy(&pre[j-1], t);\n  for (j = 0; i >= 0; i--) {\n    int set = fp_is_bit_set(e, i);\n    if ((j == CT_INV_MOD_PRE_CNT) || (!set && j > 0)) {\n      fp_mul(t, &pre[j-1], t);\n      fp_montgomery_reduce(t, b, mp);\n      j = 0;\n    }\n    fp_sqr(t, t);\n    fp_montgomery_reduce(t, b, mp);\n    j += set;\n  }\n  if (j > 0) {\n    fp_mul(t, &pre[j-1], c);\n    fp_montgomery_reduce(c, b, mp);\n  }\n  else \n    fp_copy(t, c);\n#ifdef WOLFSSL_SMALL_STACK\n  XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);\n#endif\n  return FP_OKAY;\n}", "target": 0}
{"code": "ipf_extract_frags_from_batch(struct ipf *ipf, struct dp_packet_batch *pb,\n                             ovs_be16 dl_type, uint16_t zone, long long now,\n                             uint32_t hash_basis)\n{\n    const size_t pb_cnt = dp_packet_batch_size(pb);\n    int pb_idx; \n    struct dp_packet *pkt;\n    DP_PACKET_BATCH_REFILL_FOR_EACH (pb_idx, pb_cnt, pkt, pb) {\n        if (OVS_UNLIKELY((dl_type == htons(ETH_TYPE_IP) &&\n                          ipf_is_valid_v4_frag(ipf, pkt))\n                          ||\n                          (dl_type == htons(ETH_TYPE_IPV6) &&\n                          ipf_is_valid_v6_frag(ipf, pkt)))) {\n            ovs_mutex_lock(&ipf->ipf_lock);\n            if (!ipf_handle_frag(ipf, pkt, dl_type, zone, now, hash_basis)) {\n                dp_packet_batch_refill(pb, pkt, pb_idx);\n            } else {\n                dp_packet_delete(pkt);\n            }\n            ovs_mutex_unlock(&ipf->ipf_lock);\n        } else {\n            dp_packet_batch_refill(pb, pkt, pb_idx);\n        }\n    }\n}", "target": 0}
{"code": "int rm_rf_children(\n                int fd,\n                RemoveFlags flags,\n                const struct stat *root_dev) {\n        _cleanup_closedir_ DIR *d = NULL;\n        int ret = 0, r;\n        assert(fd >= 0);\n        d = fdopendir(fd);\n        if (!d) {\n                safe_close(fd);\n                return -errno;\n        }\n        if (!(flags & REMOVE_PHYSICAL)) {\n                struct statfs sfs;\n                if (fstatfs(dirfd(d), &sfs) < 0)\n                        return -errno;\n                if (is_physical_fs(&sfs)) {\n                        _cleanup_free_ char *path = NULL;\n                        (void) fd_get_path(fd, &path);\n                        return log_error_errno(SYNTHETIC_ERRNO(EPERM),\n                                               \"Attempted to remove disk file system under \\\"%s\\\", and we can't allow that.\",\n                                               strna(path));\n                }\n        }\n        FOREACH_DIRENT_ALL(de, d, return -errno) {\n                int is_dir;\n                if (dot_or_dot_dot(de->d_name))\n                        continue;\n                is_dir =\n                        de->d_type == DT_UNKNOWN ? -1 :\n                        de->d_type == DT_DIR;\n                r = rm_rf_children_inner(dirfd(d), de->d_name, is_dir, flags, root_dev);\n                if (r < 0 && r != -ENOENT && ret == 0)\n                        ret = r;\n        }\n        if (FLAGS_SET(flags, REMOVE_SYNCFS) && syncfs(dirfd(d)) < 0 && ret >= 0)\n                ret = -errno;\n        return ret;\n}", "target": 1}
{"code": "TEE_Result syscall_hash_init(unsigned long state,\n\t\t\t     const void *iv __maybe_unused,\n\t\t\t     size_t iv_len __maybe_unused)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tswitch (TEE_ALG_GET_CLASS(cs->algo)) {\n\tcase TEE_OPERATION_DIGEST:\n\t\tres = crypto_hash_init(cs->ctx, cs->algo);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\t{\n\t\t\tstruct tee_obj *o;\n\t\t\tstruct tee_cryp_obj_secret *key;\n\t\t\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  cs->key1, &o);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t\tif ((o->info.handleFlags &\n\t\t\t     TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t\tkey = (struct tee_cryp_obj_secret *)o->attr;\n\t\t\tres = crypto_mac_init(cs->ctx, cs->algo,\n\t\t\t\t\t      (void *)(key + 1), key->key_size);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\tcs->state = CRYP_STATE_INITIALIZED;\n\treturn TEE_SUCCESS;\n}", "target": 0}
{"code": "void ArcMemory::Load(const byte *Data,size_t Size)\n{\n  ArcData.Alloc(Size);\n  memcpy(&ArcData[0],Data,Size);\n  Loaded=true;\n  SeekPos=0;\n}", "target": 0}
{"code": "u32 GetHintFormat(GF_TrackBox *trak)\n{\n\tGF_HintMediaHeaderBox *hmhd = (GF_HintMediaHeaderBox *)trak->Media->information->InfoHeader;\n\tif (hmhd->type != GF_ISOM_BOX_TYPE_HMHD)\n\t\treturn 0;\n\tif (!hmhd || !hmhd->subType) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\t\tif (!hmhd) return a ? a->type : 0;\n\t\tif (a) hmhd->subType = a->type;\n\t\treturn hmhd->subType;\n\t}\n\treturn hmhd->subType;\n}", "target": 1}
{"code": "pci_bus_configured(int bus)\n{\n\tassert(bus >= 0 && bus < MAXBUSES);\n\treturn (pci_businfo[bus] != NULL);\n}", "target": 1}
{"code": "static Fixed lsr_translate_scale(GF_LASeRCodec *lsr, u32 val)\n{\n\tif (val >> (lsr->coord_bits-1) ) {\n\t\ts32 v = val - (1<<lsr->coord_bits);\n\t\treturn INT2FIX(v) / 256 ;\n\t} else {\n\t\treturn INT2FIX(val) / 256;\n\t}\n}", "target": 1}
{"code": "static int get_exif_tag_int_value(struct iw_exif_state *e, unsigned int tag_pos,\n\tunsigned int *pv)\n{\n\tunsigned int field_type;\n\tunsigned int value_count;\n\tfield_type = iw_get_ui16_e(&e->d[tag_pos+2],e->endian);\n\tvalue_count = iw_get_ui32_e(&e->d[tag_pos+4],e->endian);\n\tif(value_count!=1) return 0;\n\tif(field_type==3) { \n\t\t*pv = iw_get_ui16_e(&e->d[tag_pos+8],e->endian);\n\t\treturn 1;\n\t}\n\telse if(field_type==4) { \n\t\t*pv = iw_get_ui32_e(&e->d[tag_pos+8],e->endian);\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static void prefetch_table(const volatile byte *tab, size_t len)\n{\n  size_t i;\n  for (i = 0; i < len; i += 8 * 32)\n    {\n      (void)tab[i + 0 * 32];\n      (void)tab[i + 1 * 32];\n      (void)tab[i + 2 * 32];\n      (void)tab[i + 3 * 32];\n      (void)tab[i + 4 * 32];\n      (void)tab[i + 5 * 32];\n      (void)tab[i + 6 * 32];\n      (void)tab[i + 7 * 32];\n    }\n  (void)tab[len - 1];\n}", "target": 1}
{"code": "crm_create_anon_tls_session(int csock, int type , void *credentials)\n{\n    gnutls_session *session = gnutls_malloc(sizeof(gnutls_session));\n    gnutls_init(session, type);\n#  ifdef HAVE_GNUTLS_PRIORITY_SET_DIRECT\n    gnutls_priority_set_direct(*session, \"NORMAL:+ANON-DH\", NULL);\n#  else\n    gnutls_set_default_priority(*session);\n    gnutls_kx_set_priority(*session, anon_tls_kx_order);\n#  endif\n    gnutls_transport_set_ptr(*session, (gnutls_transport_ptr) GINT_TO_POINTER(csock));\n    switch (type) {\n    case GNUTLS_SERVER:\n        gnutls_credentials_set(*session, GNUTLS_CRD_ANON, (gnutls_anon_server_credentials_t) credentials);\n        break;\n    case GNUTLS_CLIENT:\n        gnutls_credentials_set(*session, GNUTLS_CRD_ANON, (gnutls_anon_client_credentials_t) credentials);\n        break;\n    }\n    return session;\n}", "target": 0}
{"code": "static void labeljumps(JF, js_JumpList *jump, int baddr, int caddr)\n{\n\twhile (jump) {\n\t\tif (jump->type == STM_BREAK)\n\t\t\tlabelto(J, F, jump->inst, baddr);\n\t\tif (jump->type == STM_CONTINUE)\n\t\t\tlabelto(J, F, jump->inst, caddr);\n\t\tjump = jump->next;\n\t}\n}", "target": 1}
{"code": "static int scm_fp_copy(struct cmsghdr *cmsg, struct scm_fp_list **fplp)\n{\n\tint *fdp = (int*)CMSG_DATA(cmsg);\n\tstruct scm_fp_list *fpl = *fplp;\n\tstruct file **fpp;\n\tint i, num;\n\tnum = (cmsg->cmsg_len - CMSG_ALIGN(sizeof(struct cmsghdr)))/sizeof(int);\n\tif (num <= 0)\n\t\treturn 0;\n\tif (num > SCM_MAX_FD)\n\t\treturn -EINVAL;\n\tif (!fpl)\n\t{\n\t\tfpl = kmalloc(sizeof(struct scm_fp_list), GFP_KERNEL);\n\t\tif (!fpl)\n\t\t\treturn -ENOMEM;\n\t\t*fplp = fpl;\n\t\tfpl->count = 0;\n\t\tfpl->max = SCM_MAX_FD;\n\t\tfpl->user = NULL;\n\t}\n\tfpp = &fpl->fp[fpl->count];\n\tif (fpl->count + num > fpl->max)\n\t\treturn -EINVAL;\n\tfor (i=0; i< num; i++)\n\t{\n\t\tint fd = fdp[i];\n\t\tstruct file *file;\n\t\tif (fd < 0 || !(file = fget_raw(fd)))\n\t\t\treturn -EBADF;\n\t\t*fpp++ = file;\n\t\tfpl->count++;\n\t}\n\tif (!fpl->user)\n\t\tfpl->user = get_uid(current_user());\n\treturn num;\n}", "target": 0}
{"code": "init_ext2_xattr(void)\n{\n\treturn 0;\n}", "target": 1}
{"code": "static int del_balance_item(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *root = fs_info->tree_root;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tint ret, err;\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tbtrfs_free_path(path);\n\t\treturn PTR_ERR(trans);\n\t}\n\tkey.objectid = BTRFS_BALANCE_OBJECTID;\n\tkey.type = BTRFS_TEMPORARY_ITEM_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tret = btrfs_del_item(trans, root, path);\nout:\n\tbtrfs_free_path(path);\n\terr = btrfs_commit_transaction(trans);\n\tif (err && !ret)\n\t\tret = err;\n\treturn ret;\n}", "target": 0}
{"code": "TEST(FormatTest, Regression) {\n  fmt::format(\"...........{:<77777.7p}\", \"foo\");\n}", "target": 0}
{"code": "int crxParamInit(CrxBandParam **param, uint64_t subbandMdatOffset,\n                 uint64_t subbandDataSize, uint32_t subbandWidth,\n                 uint32_t subbandHeight, int32_t supportsPartial,\n                 uint32_t roundedBitsMask, LibRaw_abstract_datastream *input)\n{\n  int32_t progrDataSize = supportsPartial ? 0 : sizeof(int32_t) * subbandWidth;\n  int32_t paramLength = 2 * subbandWidth + 4;\n  uint8_t *paramBuf = (uint8_t *)calloc(\n      1, sizeof(CrxBandParam) + sizeof(int32_t) * paramLength + progrDataSize);\n  if (!paramBuf)\n    return -1;\n  *param = (CrxBandParam *)paramBuf;\n  paramBuf += sizeof(CrxBandParam);\n  (*param)->paramData = (int32_t *)paramBuf;\n  (*param)->nonProgrData =\n      progrDataSize ? (*param)->paramData + paramLength : 0;\n  (*param)->subbandWidth = subbandWidth;\n  (*param)->subbandHeight = subbandHeight;\n  (*param)->roundedBits = 0;\n  (*param)->curLine = 0;\n  (*param)->roundedBitsMask = roundedBitsMask;\n  (*param)->supportsPartial = supportsPartial;\n  (*param)->bitStream.bitData = 0;\n  (*param)->bitStream.bitsLeft = 0;\n  (*param)->bitStream.mdatSize = subbandDataSize;\n  (*param)->bitStream.curPos = 0;\n  (*param)->bitStream.curBufSize = 0;\n  (*param)->bitStream.curBufOffset = subbandMdatOffset;\n  (*param)->bitStream.input = input;\n  crxFillBuffer(&(*param)->bitStream);\n  return 0;\n}", "target": 1}
{"code": "    static std::string indent(int depth)\n    {\n        std::string result;\n        while ( depth -- ) result += \"  \";\n        return result;\n    }", "target": 0}
{"code": "static struct nft_trans *nft_trans_alloc_gfp(const struct nft_ctx *ctx,\n\t\t\t\t\t     int msg_type, u32 size, gfp_t gfp)\n{\n\tstruct nft_trans *trans;\n\ttrans = kzalloc(sizeof(struct nft_trans) + size, gfp);\n\tif (trans == NULL)\n\t\treturn NULL;\n\tINIT_LIST_HEAD(&trans->list);\n\ttrans->msg_type = msg_type;\n\ttrans->ctx\t= *ctx;\n\treturn trans;\n}", "target": 0}
{"code": "int rm_rf_child(int fd, const char *name, RemoveFlags flags) {\n        if (fd < 0)\n                return -EBADF;\n        if (!filename_is_valid(name))\n                return -EINVAL;\n        if ((flags & (REMOVE_ROOT|REMOVE_MISSING_OK)) != 0) \n                return -EINVAL;\n        if (FLAGS_SET(flags, REMOVE_ONLY_DIRECTORIES|REMOVE_SUBVOLUME))\n                return -EINVAL;\n        return rm_rf_children_inner(fd, name, -1, flags, NULL);\n}", "target": 1}
{"code": "Status GetTensorArray(OpKernelContext* ctx, TensorArray** tensor_array) {\n  string container;\n  string ta_handle;\n  if (ctx->input_dtype(0) != DT_RESOURCE) {\n    TF_RETURN_IF_ERROR(GetHandle(ctx, &container, &ta_handle));\n    ResourceMgr* rm = ctx->resource_manager();\n    if (rm == nullptr) return errors::Internal(\"No resource manager.\");\n    TF_RETURN_IF_ERROR(\n        ctx->step_container()->Lookup(rm, container + ta_handle, tensor_array));\n    return OkStatus();\n  } else {\n    return LookupResource(ctx, HandleFromInput(ctx, 0), tensor_array);\n  }\n}", "target": 1}
{"code": "static UINT urb_bulk_or_interrupt_transfer(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback,\n                                           wStream* s, UINT32 RequestField, UINT32 MessageId,\n                                           IUDEVMAN* udevman, int transferDir)\n{\n\tUINT32 EndpointAddress, PipeHandle;\n\tUINT32 TransferFlags, OutputBufferSize;\n\tconst BOOL noAck = (RequestField & 0x80000000U) != 0;\n\tconst UINT32 RequestId = RequestField & 0x7FFFFFFF;\n\tif (!pdev || !callback || !s || !udevman)\n\t\treturn ERROR_INVALID_PARAMETER;\n\tif (Stream_GetRemainingLength(s) < 12)\n\t\treturn ERROR_INVALID_DATA;\n\tStream_Read_UINT32(s, PipeHandle);\n\tStream_Read_UINT32(s, TransferFlags); \n\tStream_Read_UINT32(s, OutputBufferSize);\n\tEndpointAddress = (PipeHandle & 0x000000ff);\n\tif (transferDir == USBD_TRANSFER_DIRECTION_OUT)\n\t{\n\t\tif (!Stream_CheckAndLogRequiredLength(TAG, s, OutputBufferSize))\n\t\t{\n\t\t\treturn ERROR_INVALID_DATA;\n\t\t}\n\t}\n\treturn pdev->bulk_or_interrupt_transfer(\n\t    pdev, callback, MessageId, RequestId, EndpointAddress, TransferFlags, noAck,\n\t    OutputBufferSize, (transferDir == USBD_TRANSFER_DIRECTION_OUT) ? Stream_Pointer(s) : NULL,\n\t    urb_bulk_transfer_cb, 10000);\n}", "target": 0}
{"code": "std::wstring MB2WC(const std::string& input, unsigned int code_page) {\n  if (input.empty()) {\n    return L\"\";\n  }\n  int length = ::MultiByteToWideChar(code_page, 0, &input[0],\n                                     static_cast<int>(input.size()),\n                                     NULL, 0);\n  std::wstring output(length, '\\0');\n  ::MultiByteToWideChar(code_page, 0, &input[0], static_cast<int>(input.size()),\n                        &output[0], static_cast<int>(output.size()));\n  return output;\n}", "target": 1}
{"code": "static int count_paired_channels(uint8_t (*layout_map)[3], int tags, int pos,\n                                 int *current)\n{\n    int num_pos_channels = 0;\n    int first_cpe        = 0;\n    int sce_parity       = 0;\n    int i;\n    for (i = *current; i < tags; i++) {\n        if (layout_map[i][2] != pos)\n            break;\n        if (layout_map[i][0] == TYPE_CPE) {\n            if (sce_parity) {\n                if (pos == AAC_CHANNEL_FRONT && !first_cpe) {\n                    sce_parity = 0;\n                } else {\n                    return -1;\n                }\n            }\n            num_pos_channels += 2;\n            first_cpe         = 1;\n        } else {\n            num_pos_channels++;\n            sce_parity ^= 1;\n        }\n    }\n    if (sce_parity &&\n        ((pos == AAC_CHANNEL_FRONT && first_cpe) || pos == AAC_CHANNEL_SIDE))\n        return -1;\n    *current = i;\n    return num_pos_channels;\n}", "target": 0}
{"code": "static int logi_dj_raw_event(struct hid_device *hdev,\n\t\t\t     struct hid_report *report, u8 *data,\n\t\t\t     int size)\n{\n\tstruct dj_receiver_dev *djrcv_dev = hid_get_drvdata(hdev);\n\tstruct dj_report *dj_report = (struct dj_report *) data;\n\tunsigned long flags;\n\tbool report_processed = false;\n\tdbg_hid(\"%s, size:%d\\n\", __func__, size);\n\tif ((dj_report->device_index < DJ_DEVICE_INDEX_MIN) ||\n\t    (dj_report->device_index > DJ_DEVICE_INDEX_MAX)) {\n\t\tdev_err(&hdev->dev, \"%s: invalid device index:%d\\n\",\n\t\t\t\t__func__, dj_report->device_index);\n\t\treturn false;\n\t}\n\tspin_lock_irqsave(&djrcv_dev->lock, flags);\n\tif (dj_report->report_id == REPORT_ID_DJ_SHORT) {\n\t\tswitch (dj_report->report_type) {\n\t\tcase REPORT_TYPE_NOTIF_DEVICE_PAIRED:\n\t\tcase REPORT_TYPE_NOTIF_DEVICE_UNPAIRED:\n\t\t\tlogi_dj_recv_queue_notification(djrcv_dev, dj_report);\n\t\t\tbreak;\n\t\tcase REPORT_TYPE_NOTIF_CONNECTION_STATUS:\n\t\t\tif (dj_report->report_params[CONNECTION_STATUS_PARAM_STATUS] ==\n\t\t\t    STATUS_LINKLOSS) {\n\t\t\t\tlogi_dj_recv_forward_null_report(djrcv_dev, dj_report);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlogi_dj_recv_forward_report(djrcv_dev, dj_report);\n\t\t}\n\t\treport_processed = true;\n\t}\n\tspin_unlock_irqrestore(&djrcv_dev->lock, flags);\n\treturn report_processed;\n}", "target": 0}
{"code": "static int head_onwire_len(int ctrl_len, bool secure)\n{\n\tint head_len;\n\tint rem_len;\n\tBUG_ON(ctrl_len < 0 || ctrl_len > CEPH_MSG_MAX_CONTROL_LEN);\n\tif (secure) {\n\t\thead_len = CEPH_PREAMBLE_SECURE_LEN;\n\t\tif (ctrl_len > CEPH_PREAMBLE_INLINE_LEN) {\n\t\t\trem_len = ctrl_len - CEPH_PREAMBLE_INLINE_LEN;\n\t\t\thead_len += padded_len(rem_len) + CEPH_GCM_TAG_LEN;\n\t\t}\n\t} else {\n\t\thead_len = CEPH_PREAMBLE_PLAIN_LEN;\n\t\tif (ctrl_len)\n\t\t\thead_len += ctrl_len + CEPH_CRC_LEN;\n\t}\n\treturn head_len;\n}", "target": 0}
{"code": "int unlinkat_harder(int dfd, const char *filename, int unlink_flags, RemoveFlags remove_flags) {\n        mode_t old_mode;\n        int r;\n        if (unlinkat(dfd, filename, unlink_flags) >= 0)\n                return 0;\n        if (errno != EACCES || !FLAGS_SET(remove_flags, REMOVE_CHMOD))\n                return -errno;\n        r = patch_dirfd_mode(dfd, &old_mode);\n        if (r < 0)\n                return r;\n        if (unlinkat(dfd, filename, unlink_flags) < 0) {\n                r = -errno;\n                (void) fchmod(dfd, old_mode);\n                return r;\n        }\n        if (FLAGS_SET(remove_flags, REMOVE_CHMOD_RESTORE) && fchmod(dfd, old_mode) < 0)\n                return -errno;\n        return 0;\n}", "target": 1}
{"code": "void zend_shared_alloc_register_xlat_entry(const void *old, const void *new)\n{\n\tzend_hash_index_update_ptr(&xlat_table, (zend_ulong)old, (void*)new);\n}", "target": 0}
{"code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLiteDivParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n  const TfLiteTensor* input1;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor1, &input1));\n  const TfLiteTensor* input2;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor2, &input2));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n#define TF_LITE_CHECK_DIV_NON_ZERO(data_type)                       \\\n  const auto* input2_data = GetTensorData<data_type>(input2);       \\\n  const size_t input2_elements = input2->bytes / sizeof(data_type); \\\n  for (size_t i = 0; i < input2_elements; i++) {                    \\\n    TF_LITE_ENSURE(context, input2_data[i] != 0);                   \\\n  }\n  if (output->type == kTfLiteFloat32) {\n    EvalDiv<kernel_type>(context, node, params, data, input1, input2, output);\n  } else if (output->type == kTfLiteInt32) {\n    TF_LITE_CHECK_DIV_NON_ZERO(int32_t);\n    EvalDiv<kernel_type>(context, node, params, data, input1, input2, output);\n  } else if (output->type == kTfLiteUInt8) {\n    TF_LITE_CHECK_DIV_NON_ZERO(uint8_t);\n    TF_LITE_ENSURE_OK(\n        context, EvalQuantized<kernel_type>(context, node, params, data, input1,\n                                            input2, output));\n  } else {\n    context->ReportError(\n        context,\n        \"Div only supports FLOAT32, INT32 and quantized UINT8 now, got %d.\",\n        output->type);\n    return kTfLiteError;\n  }\n#undef TF_LITE_CHECK_DIV_NON_ZERO\n  return kTfLiteOk;\n}", "target": 0}
{"code": "bool chopOff(string &domain) \n{\n  if(domain.empty())\n    return false;\n  string::size_type fdot=domain.find('.');\n  if(fdot==string::npos) \n    domain=\"\";\n  else {\n    string::size_type remain = domain.length() - (fdot + 1);\n    char tmp[remain];\n    memcpy(tmp, domain.c_str()+fdot+1, remain);\n    domain.assign(tmp, remain); \n  }\n  return true;\n}", "target": 1}
{"code": "static int rb_head_page_set(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t    struct buffer_page *head,\n\t\t\t    struct buffer_page *prev,\n\t\t\t    int old_flag, int new_flag)\n{\n\tstruct list_head *list;\n\tunsigned long val = (unsigned long)&head->list;\n\tunsigned long ret;\n\tlist = &prev->list;\n\tval &= ~RB_FLAG_MASK;\n\tret = cmpxchg((unsigned long *)&list->next,\n\t\t      val | old_flag, val | new_flag);\n\tif ((ret & ~RB_FLAG_MASK) != val)\n\t\treturn RB_PAGE_MOVED;\n\treturn ret & RB_FLAG_MASK;\n}", "target": 0}
{"code": "perf_output_sample_regs(struct perf_output_handle *handle,\n\t\t\tstruct pt_regs *regs, u64 mask)\n{\n\tint bit;\n\tfor_each_set_bit(bit, (const unsigned long *) &mask,\n\t\t\t sizeof(mask) * BITS_PER_BYTE) {\n\t\tu64 val;\n\t\tval = perf_reg_value(regs, bit);\n\t\tperf_output_put(handle, val);\n\t}\n}", "target": 0}
{"code": "static int __init pcd_init(void)\n{\n\tstruct pcd_unit *cd;\n\tint unit;\n\tif (disable)\n\t\treturn -EINVAL;\n\tpcd_init_units();\n\tif (pcd_detect())\n\t\treturn -ENODEV;\n\tpcd_probe_capabilities();\n\tif (register_blkdev(major, name)) {\n\t\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++)\n\t\t\tput_disk(cd->disk);\n\t\treturn -EBUSY;\n\t}\n\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\tif (cd->present) {\n\t\t\tregister_cdrom(&cd->info);\n\t\t\tcd->disk->private_data = cd;\n\t\t\tadd_disk(cd->disk);\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "inline void ComputeInterpolationWeights(\n    const int64 out_size, const int64 in_size, const float scale,\n    const int resolution, InterpolationCache<T_SCALE>* interpolation) {\n  const Scaler scaler;\n  interpolation->lower.resize(out_size + 1);\n  interpolation->upper.resize(out_size + 1);\n  interpolation->lerp.resize(out_size + 1);\n  interpolation->ilerp.resize(out_size + 1);\n  interpolation->lower[out_size] = 0;\n  interpolation->upper[out_size] = 0;\n  for (int64 i = out_size - 1; i >= 0; --i) {\n    const float in = scaler(i, scale);\n    const float in_f = std::floor(in);\n    interpolation->lower[i] =\n        std::max(static_cast<int64>(in_f), static_cast<int64>(0));\n    interpolation->upper[i] =\n        std::min(static_cast<int64>(std::ceil(in)), in_size - 1);\n    interpolation->lower[i] =\n        std::min(interpolation->lower[i], interpolation->upper[i]);\n    interpolation->lerp[i] = in - in_f;\n    interpolation->ilerp[i] =\n        static_cast<T_SCALE>((in - in_f) * (1 << resolution));\n  }\n}", "target": 0}
{"code": "sds sdsMakeRoomFor(sds s, size_t addlen) {\n    void *sh, *newsh;\n    size_t avail = sdsavail(s);\n    size_t len, newlen, reqlen;\n    char type, oldtype = s[-1] & SDS_TYPE_MASK;\n    int hdrlen;\n    if (avail >= addlen) return s;\n    len = sdslen(s);\n    sh = (char*)s-sdsHdrSize(oldtype);\n    reqlen = newlen = (len+addlen);\n    assert(newlen > len);   \n    if (newlen < SDS_MAX_PREALLOC)\n        newlen *= 2;\n    else\n        newlen += SDS_MAX_PREALLOC;\n    type = sdsReqType(newlen);\n    if (type == SDS_TYPE_5) type = SDS_TYPE_8;\n    hdrlen = sdsHdrSize(type);\n    assert(hdrlen + newlen + 1 > reqlen);  \n    if (oldtype==type) {\n        newsh = s_realloc(sh, hdrlen+newlen+1);\n        if (newsh == NULL) return NULL;\n        s = (char*)newsh+hdrlen;\n    } else {\n        newsh = s_malloc(hdrlen+newlen+1);\n        if (newsh == NULL) return NULL;\n        memcpy((char*)newsh+hdrlen, s, len+1);\n        s_free(sh);\n        s = (char*)newsh+hdrlen;\n        s[-1] = type;\n        sdssetlen(s, len);\n    }\n    sdssetalloc(s, newlen);\n    return s;\n}", "target": 0}
{"code": "bool fixpath_ro(Computer *comp, const std::string& path) {\n    std::vector<std::string> elems = split(path, \"/\\\\\");\n    std::list<std::string> pathc;\n    for (std::string s : elems) {\n        if (s == \"..\") { if (pathc.empty()) return false; else pathc.pop_back(); }\n        else if (!s.empty() && !std::all_of(s.begin(), s.end(), [](const char c)->bool{return c == '.';})) {\n            s = s.substr(s.find_first_not_of(' '), s.find_last_not_of(' ') - s.find_first_not_of(' ') + 1);\n            s.erase(std::remove_if(s.begin(), s.end(), [](char c)->bool{return c=='\"'||c==':'||c=='<'||c=='>'||c=='?'||c=='|';}), s.end());\n            pathc.push_back(s);\n        }\n    }\n    while (!pathc.empty() && pathc.front().empty()) pathc.pop_front();\n    if (!pathc.empty() && pathc.back().size() > 255) {\n        std::string s = pathc.back().substr(0, 255);\n        pathc.pop_back();\n        s = s.substr(0, s.find_last_not_of(' '));\n        pathc.push_back(s);\n    }\n    std::pair<size_t, bool> max_path = std::make_pair(0, false);\n    for (const auto& m : comp->mounts)\n        if (pathc.size() >= std::get<0>(m).size() && std::get<0>(m).size() > max_path.first && std::equal(std::get<0>(m).begin(), std::get<0>(m).end(), pathc.begin()))\n            max_path = std::make_pair(std::get<0>(m).size(), std::get<2>(m));\n    return max_path.second;\n}", "target": 1}
{"code": "normalizeLines(XML_Char *s)\n{\n  XML_Char *p;\n  for (;; s++) {\n    if (*s == XML_T('\\0'))\n      return;\n    if (*s == 0xD)\n      break;\n  }\n  p = s;\n  do {\n    if (*s == 0xD) {\n      *p++ = 0xA;\n      if (*++s == 0xA)\n        s++;\n    }\n    else\n      *p++ = *s++;\n  } while (*s);\n  *p = XML_T('\\0');\n}", "target": 0}
{"code": "static int snd_timer_user_open(struct inode *inode, struct file *file)\n{\n\tstruct snd_timer_user *tu;\n\tint err;\n\terr = nonseekable_open(inode, file);\n\tif (err < 0)\n\t\treturn err;\n\ttu = kzalloc(sizeof(*tu), GFP_KERNEL);\n\tif (tu == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&tu->qlock);\n\tinit_waitqueue_head(&tu->qchange_sleep);\n\tmutex_init(&tu->tread_sem);\n\ttu->ticks = 1;\n\ttu->queue_size = 128;\n\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t    GFP_KERNEL);\n\tif (tu->queue == NULL) {\n\t\tkfree(tu);\n\t\treturn -ENOMEM;\n\t}\n\tfile->private_data = tu;\n\treturn 0;\n}", "target": 1}
{"code": "int nfs4_lock_delegation_recall(struct nfs4_state *state, struct file_lock *fl)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs4_exception exception = { };\n\tint err;\n\terr = nfs4_set_lock_state(state, fl);\n\tif (err != 0)\n\t\tgoto out;\n\tdo {\n\t\terr = _nfs4_do_setlk(state, F_SETLK, fl, NFS_LOCK_NEW);\n\t\tswitch (err) {\n\t\t\tdefault:\n\t\t\t\tprintk(KERN_ERR \"NFS: %s: unhandled error \"\n\t\t\t\t\t\"%d.\\n\", __func__, err);\n\t\t\tcase 0:\n\t\t\tcase -ESTALE:\n\t\t\t\tgoto out;\n\t\t\tcase -NFS4ERR_EXPIRED:\n\t\t\t\tnfs4_schedule_stateid_recovery(server, state);\n\t\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\tcase -NFS4ERR_STALE_STATEID:\n\t\t\t\tnfs4_schedule_lease_recovery(server->nfs_client);\n\t\t\t\tgoto out;\n\t\t\tcase -NFS4ERR_BADSESSION:\n\t\t\tcase -NFS4ERR_BADSLOT:\n\t\t\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\t\t\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\t\tcase -NFS4ERR_DEADSESSION:\n\t\t\t\tnfs4_schedule_session_recovery(server->nfs_client->cl_session, err);\n\t\t\t\tgoto out;\n\t\t\tcase -ERESTARTSYS:\n\t\t\tcase -NFS4ERR_DELEG_REVOKED:\n\t\t\tcase -NFS4ERR_ADMIN_REVOKED:\n\t\t\tcase -NFS4ERR_BAD_STATEID:\n\t\t\tcase -NFS4ERR_OPENMODE:\n\t\t\t\tnfs4_schedule_stateid_recovery(server, state);\n\t\t\t\terr = 0;\n\t\t\t\tgoto out;\n\t\t\tcase -EKEYEXPIRED:\n\t\t\t\terr = 0;\n\t\t\t\tgoto out;\n\t\t\tcase -ENOMEM:\n\t\t\tcase -NFS4ERR_DENIED:\n\t\t\t\terr = 0;\n\t\t\t\tgoto out;\n\t\t\tcase -NFS4ERR_DELAY:\n\t\t\t\tbreak;\n\t\t}\n\t\terr = nfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\nout:\n\treturn err;\n}", "target": 0}
{"code": "TEST_P(ResizeRealtimeTest, DISABLED_TestExternalResizeSmallerWidthBiggerSize) {\n  ResizingVideoSource video;\n  video.flag_codec_ = true;\n  video.smaller_width_larger_size_ = true;\n  DefaultConfig();\n  cfg_.rc_resize_allowed = 0;\n  change_bitrate_ = false;\n  mismatch_psnr_ = 0.0;\n  mismatch_nframes_ = 0;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  for (std::vector<FrameInfo>::const_iterator info = frame_info_list_.begin();\n       info != frame_info_list_.end(); ++info) {\n    const unsigned int frame = static_cast<unsigned>(info->pts);\n    unsigned int expected_w;\n    unsigned int expected_h;\n    ScaleForFrameNumber(frame, kInitialWidth, kInitialHeight, &expected_w,\n                        &expected_h, video.flag_codec_,\n                        video.smaller_width_larger_size_);\n    EXPECT_EQ(expected_w, info->w)\n        << \"Frame \" << frame << \" had unexpected width\";\n    EXPECT_EQ(expected_h, info->h)\n        << \"Frame \" << frame << \" had unexpected height\";\n    EXPECT_EQ(static_cast<unsigned int>(0), GetMismatchFrames());\n  }\n}", "target": 1}
{"code": "static int snd_ctl_elem_read(struct snd_card *card,\n\t\t\t     struct snd_ctl_elem_value *control)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int index_offset;\n\tstruct snd_ctl_elem_info info;\n\tconst u32 pattern = 0xdeadbeef;\n\tint ret;\n\tkctl = snd_ctl_find_id(card, &control->id);\n\tif (kctl == NULL)\n\t\treturn -ENOENT;\n\tindex_offset = snd_ctl_get_ioff(kctl, &control->id);\n\tvd = &kctl->vd[index_offset];\n\tif (!(vd->access & SNDRV_CTL_ELEM_ACCESS_READ) || kctl->get == NULL)\n\t\treturn -EPERM;\n\tsnd_ctl_build_ioff(&control->id, kctl, index_offset);\n#ifdef CONFIG_SND_CTL_DEBUG\n\tmemset(&info, 0, sizeof(info));\n\tinfo.id = control->id;\n\tret = __snd_ctl_elem_info(card, kctl, &info, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n#endif\n\tif (!snd_ctl_skip_validation(&info))\n\t\tfill_remaining_elem_value(control, &info, pattern);\n\tret = snd_power_ref_and_wait(card);\n\tif (!ret)\n\t\tret = kctl->get(kctl, control);\n\tsnd_power_unref(card);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!snd_ctl_skip_validation(&info) &&\n\t    sanity_check_elem_value(card, control, &info, pattern) < 0) {\n\t\tdev_err(card->dev,\n\t\t\t\"control %i:%i:%i:%s:%i: access overflow\\n\",\n\t\t\tcontrol->id.iface, control->id.device,\n\t\t\tcontrol->id.subdevice, control->id.name,\n\t\t\tcontrol->id.index);\n\t\treturn -EINVAL;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "int hashbin_delete( hashbin_t* hashbin, FREE_FUNC free_func)\n{\n\tirda_queue_t* queue;\n\tunsigned long flags = 0;\n\tint i;\n\tIRDA_ASSERT(hashbin != NULL, return -1;);\n\tIRDA_ASSERT(hashbin->magic == HB_MAGIC, return -1;);\n\tif ( hashbin->hb_type & HB_LOCK ) {\n\t\tspin_lock_irqsave_nested(&hashbin->hb_spinlock, flags,\n\t\t\t\t\t hashbin_lock_depth++);\n\t}\n\tfor (i = 0; i < HASHBIN_SIZE; i ++ ) {\n\t\tqueue = dequeue_first((irda_queue_t**) &hashbin->hb_queue[i]);\n\t\twhile (queue ) {\n\t\t\tif (free_func)\n\t\t\t\t(*free_func)(queue);\n\t\t\tqueue = dequeue_first(\n\t\t\t\t(irda_queue_t**) &hashbin->hb_queue[i]);\n\t\t}\n\t}\n\thashbin->hb_current = NULL;\n\thashbin->magic = ~HB_MAGIC;\n\tif ( hashbin->hb_type & HB_LOCK) {\n\t\tspin_unlock_irqrestore(&hashbin->hb_spinlock, flags);\n#ifdef CONFIG_LOCKDEP\n\t\thashbin_lock_depth--;\n#endif\n\t}\n\tkfree(hashbin);\n\treturn 0;\n}", "target": 1}
{"code": "MagickExport void *DetachBlob(BlobInfo *blob_info)\n{\n  void\n    *data;\n  assert(blob_info != (BlobInfo *) NULL);\n  if (blob_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  if (blob_info->mapped != MagickFalse)\n    {\n      (void) UnmapBlob(blob_info->data,blob_info->length);\n      blob_info->data=NULL;\n      RelinquishMagickResource(MapResource,blob_info->length);\n    }\n  blob_info->mapped=MagickFalse;\n  blob_info->length=0;\n  blob_info->offset=0;\n  blob_info->eof=MagickFalse;\n  blob_info->error=0;\n  blob_info->exempt=MagickFalse;\n  blob_info->type=UndefinedStream;\n  blob_info->file_info.file=(FILE *) NULL;\n  data=blob_info->data;\n  blob_info->data=(unsigned char *) NULL;\n  blob_info->stream=(StreamHandler) NULL;\n  blob_info->custom_stream=(CustomStreamInfo *) NULL;\n  return(data);\n}", "target": 0}
{"code": "static void commit_tree(struct mount *mnt, struct mount *shadows)\n{\n\tstruct mount *parent = mnt->mnt_parent;\n\tstruct mount *m;\n\tLIST_HEAD(head);\n\tstruct mnt_namespace *n = parent->mnt_ns;\n\tBUG_ON(parent == mnt);\n\tlist_add_tail(&head, &mnt->mnt_list);\n\tlist_for_each_entry(m, &head, mnt_list)\n\t\tm->mnt_ns = n;\n\tlist_splice(&head, n->list.prev);\n\tn->mounts += n->pending_mounts;\n\tn->pending_mounts = 0;\n\tattach_shadowed(mnt, parent, shadows);\n\ttouch_mnt_namespace(n);\n}", "target": 0}
{"code": "xmlValidCtxtNormalizeAttributeValue(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\n\t     xmlNodePtr elem, const xmlChar *name, const xmlChar *value) {\n    xmlChar *ret, *dst;\n    const xmlChar *src;\n    xmlAttributePtr attrDecl = NULL;\n    int extsubset = 0;\n    if (doc == NULL) return(NULL);\n    if (elem == NULL) return(NULL);\n    if (name == NULL) return(NULL);\n    if (value == NULL) return(NULL);\n    if ((elem->ns != NULL) && (elem->ns->prefix != NULL)) {\n\txmlChar fn[50];\n\txmlChar *fullname;\n\tfullname = xmlBuildQName(elem->name, elem->ns->prefix, fn, 50);\n\tif (fullname == NULL)\n\t    return(NULL);\n\tattrDecl = xmlGetDtdAttrDesc(doc->intSubset, fullname, name);\n\tif ((attrDecl == NULL) && (doc->extSubset != NULL)) {\n\t    attrDecl = xmlGetDtdAttrDesc(doc->extSubset, fullname, name);\n\t    if (attrDecl != NULL)\n\t\textsubset = 1;\n\t}\n\tif ((fullname != fn) && (fullname != elem->name))\n\t    xmlFree(fullname);\n    }\n    if ((attrDecl == NULL) && (doc->intSubset != NULL))\n\tattrDecl = xmlGetDtdAttrDesc(doc->intSubset, elem->name, name);\n    if ((attrDecl == NULL) && (doc->extSubset != NULL)) {\n\tattrDecl = xmlGetDtdAttrDesc(doc->extSubset, elem->name, name);\n\tif (attrDecl != NULL)\n\t    extsubset = 1;\n    }\n    if (attrDecl == NULL)\n\treturn(NULL);\n    if (attrDecl->atype == XML_ATTRIBUTE_CDATA)\n\treturn(NULL);\n    ret = xmlStrdup(value);\n    if (ret == NULL)\n\treturn(NULL);\n    src = value;\n    dst = ret;\n    while (*src == 0x20) src++;\n    while (*src != 0) {\n\tif (*src == 0x20) {\n\t    while (*src == 0x20) src++;\n\t    if (*src != 0)\n\t\t*dst++ = 0x20;\n\t} else {\n\t    *dst++ = *src++;\n\t}\n    }\n    *dst = 0;\n    if ((doc->standalone) && (extsubset == 1) && (!xmlStrEqual(value, ret))) {\n\txmlErrValidNode(ctxt, elem, XML_DTD_NOT_STANDALONE,\n\"standalone: %s on %s value had to be normalized based on external subset declaration\\n\",\n\t       name, elem->name, NULL);\n\tctxt->valid = 0;\n    }\n    return(ret);\n}", "target": 1}
{"code": "static void set_inverse_transl(struct vc_data *conp, struct uni_pagedir *p, int i)\n{\n\tint j, glyph;\n\tunsigned short *t = translations[i];\n\tunsigned char *q;\n\tif (!p) return;\n\tq = p->inverse_translations[i];\n\tif (!q) {\n\t\tq = p->inverse_translations[i] = kmalloc(MAX_GLYPH, GFP_KERNEL);\n\t\tif (!q) return;\n\t}\n\tmemset(q, 0, MAX_GLYPH);\n\tfor (j = 0; j < E_TABSZ; j++) {\n\t\tglyph = conv_uni_to_pc(conp, t[j]);\n\t\tif (glyph >= 0 && glyph < MAX_GLYPH && q[glyph] < 32) {\n\t\t  \tq[glyph] = j;\n\t\t}\n\t}\n}", "target": 0}
{"code": "dhcpv4_print(netdissect_options *ndo,\n             const u_char *cp, u_int length, int indent)\n{\n    u_int i, t;\n    const u_char *tlv, *value;\n    uint8_t type, optlen;\n    i = 0;\n    while (i < length) {\n        if (i + 2 > length)\n            return -1;\n        tlv = cp + i;\n        type = (uint8_t)tlv[0];\n        optlen = (uint8_t)tlv[1];\n        value = tlv + 2;\n        ND_PRINT((ndo, \"\\n\"));\n        for (t = indent; t > 0; t--)\n            ND_PRINT((ndo, \"\\t\"));\n        ND_PRINT((ndo, \"%s\", tok2str(dh4opt_str, \"Unknown\", type)));\n        ND_PRINT((ndo,\" (%u)\", optlen + 2 ));\n        if (i + 2 + optlen > length)\n            return -1;\n        switch (type) {\n        case DH4OPT_DNS_SERVERS:\n        case DH4OPT_NTP_SERVERS: {\n            if (optlen < 4 || optlen % 4 != 0) {\n                return -1;\n            }\n            for (t = 0; t < optlen; t += 4)\n                ND_PRINT((ndo, \" %s\", ipaddr_string(ndo, value + t)));\n        }\n            break;\n        case DH4OPT_DOMAIN_SEARCH: {\n            const u_char *tp = value;\n            while (tp < value + optlen) {\n                ND_PRINT((ndo, \" \"));\n                if ((tp = ns_nprint(ndo, tp, value + optlen)) == NULL)\n                    return -1;\n            }\n        }\n            break;\n        }\n        i += 2 + optlen;\n    }\n    return 0;\n}", "target": 0}
{"code": "static void free_todo_entries(TodoEntry **todos) {\n        for (TodoEntry *x = *todos; x && x->dir; x++) {\n                closedir(x->dir);\n                free(x->dirname);\n        }\n        freep(todos);\n}", "target": 0}
{"code": "static int32_t check_load_area(uintptr_t dst, uintptr_t len)\n{\n\tuint32_t legacy = dst + len <= UINT32_MAX - 1 ? 1 : 0;\n\tuintptr_t dram_start, dram_end;\n\tuintptr_t prot_start, prot_end;\n\tint32_t result = IO_SUCCESS;\n\tdram_start = legacy ? DRAM1_BASE : DRAM_40BIT_BASE;\n\tdram_end = legacy ? DRAM1_BASE + DRAM1_SIZE :\n\t    DRAM_40BIT_BASE + DRAM_40BIT_SIZE;\n\tprot_start = legacy ? DRAM_PROTECTED_BASE : DRAM_40BIT_PROTECTED_BASE;\n\tprot_end = prot_start + DRAM_PROTECTED_SIZE;\n\tif (dst < dram_start || dst > dram_end - len) {\n\t\tERROR(\"BL2: dst address is on the protected area.\\n\");\n\t\tresult = IO_FAIL;\n\t\tgoto done;\n\t}\n\tif (dst >= prot_start && dst < prot_end) {\n\t\tERROR(\"BL2: dst address is on the protected area.\\n\");\n\t\tresult = IO_FAIL;\n\t}\n\tif (dst < prot_start && dst > prot_start - len) {\n\t\tERROR(\"BL2: loaded data is on the protected area.\\n\");\n\t\tresult = IO_FAIL;\n\t}\ndone:\n\tif (result == IO_FAIL) {\n\t\tERROR(\"BL2: Out of range : dst=0x%lx len=0x%lx\\n\", dst, len);\n\t}\n\treturn result;\n}", "target": 1}
{"code": "segment_size (Elf_Internal_Phdr *segment)\n{\n  return (segment->p_memsz > segment->p_filesz\n\t  ? segment->p_memsz : segment->p_filesz);\n}", "target": 0}
{"code": "static int set_evtchn_to_irq(evtchn_port_t evtchn, unsigned int irq)\n{\n\tunsigned row;\n\tunsigned col;\n\tif (evtchn >= xen_evtchn_max_channels())\n\t\treturn -EINVAL;\n\trow = EVTCHN_ROW(evtchn);\n\tcol = EVTCHN_COL(evtchn);\n\tif (evtchn_to_irq[row] == NULL) {\n\t\tif (irq == -1)\n\t\t\treturn 0;\n\t\tevtchn_to_irq[row] = (int *)get_zeroed_page(GFP_KERNEL);\n\t\tif (evtchn_to_irq[row] == NULL)\n\t\t\treturn -ENOMEM;\n\t\tclear_evtchn_to_irq_row(row);\n\t}\n\tevtchn_to_irq[row][col] = irq;\n\treturn 0;\n}", "target": 1}
{"code": "TfLiteStatus GatherStrings(TfLiteContext* context, const TfLiteTensor* input,\n                           const TfLiteTensor* positions,\n                           TfLiteTensor* output) {\n  DynamicBuffer buffer;\n  const PositionT* indexes = GetTensorData<PositionT>(positions);\n  bool indices_has_only_positive_elements = true;\n  const size_t num_indices = positions->bytes / sizeof(PositionT);\n  for (size_t i = 0; i < num_indices; i++) {\n    if (indexes[i] < 0) {\n      indices_has_only_positive_elements = false;\n      break;\n    }\n  }\n  TF_LITE_ENSURE(context, indices_has_only_positive_elements);\n  const PositionT num_strings = GetStringCount(input);\n  const int num_indexes = NumElements(positions);\n  for (int i = 0; i < num_indexes; ++i) {\n    const PositionT pos = indexes[i];\n    TF_LITE_ENSURE(context, pos < num_strings);\n    const auto string_ref = GetString(input, pos);\n    buffer.AddString(string_ref.str, string_ref.len);\n  }\n  buffer.WriteToTensor(output, nullptr);\n  return kTfLiteOk;\n}", "target": 0}
{"code": "void Wifipcap::handle_packet(WifipcapCallbacks *cbs,int header_type,\n                             const struct pcap_pkthdr *header, const u_char * packet) \n{\n    if (startTime == TIME_NONE) {\n\tstartTime = header->ts;\n\tlastPrintTime = header->ts;\n    }\n    if (header->ts.tv_sec > lastPrintTime.tv_sec + Wifipcap::PRINT_TIME_INTERVAL) {\n\tif (verbose) {\n\t    int hours = (header->ts.tv_sec - startTime.tv_sec)/3600;\n\t    int days  = hours/24;\n\t    int left  = hours%24;\n\t    fprintf(stderr, \"wifipcap: %2d days %2d hours, %10\" PRId64 \" pkts\\n\", \n\t\t    days, left, packetsProcessed);\n\t}\n\tlastPrintTime = header->ts;\n    }\n    packetsProcessed++;\n    WifiPacket pkt(cbs,header_type,header,packet);\n    cbs->PacketBegin(pkt, packet, header->caplen, header->len);\n    switch(header_type) {\n    case DLT_PRISM_HEADER:\n        pkt.handle_prism(packet,header->caplen);\n        break;\n    case DLT_IEEE802_11_RADIO:\n        pkt.handle_radiotap(packet,header->caplen);\n        break;\n    case DLT_IEEE802_11:\n        pkt.handle_80211(packet,header->caplen);\n        break;\n    case DLT_EN10MB:\n        pkt.handle_ether(packet,header->caplen);\n        break;\n    default:\n#if 0\n        pkt.handle_ip(packet,header->caplen);\n#endif\n        break;\n    }\n    cbs->PacketEnd(pkt);\n}", "target": 0}
{"code": "static int kvm_set_guest_paused(struct kvm_vcpu *vcpu)\n{\n\tif (!vcpu->arch.time_page)\n\t\treturn -EINVAL;\n\tvcpu->arch.pvclock_set_guest_stopped_request = true;\n\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\treturn 0;\n}", "target": 1}
{"code": "crm_send_plaintext(int sock, const char *buf, size_t len)\n{\n    int rc = 0;\n    const char *unsent = buf;\n    int total_send;\n    if (buf == NULL) {\n        return -1;\n    }\n    total_send = len;\n    crm_trace(\"Message on socket %d: size=%d\", sock, len);\n  retry:\n    rc = write(sock, unsent, len);\n    if (rc < 0) {\n        switch (errno) {\n        case EINTR:\n        case EAGAIN:\n            crm_trace(\"Retry\");\n            goto retry;\n        default:\n            crm_perror(LOG_ERR, \"Could only write %d of the remaining %d bytes\", rc, (int) len);\n            break;\n        }\n    } else if (rc < len) {\n        crm_trace(\"Only sent %d of %d remaining bytes\", rc, len);\n        len -= rc;\n        unsent += rc;\n        goto retry;\n     } else {\n        crm_trace(\"Sent %d bytes: %.100s\", rc, buf);\n    }\n    return rc < 0 ? rc : total_send;\n}", "target": 0}
{"code": "static void RemoveResolutionFromResourceBlock(StringInfo *bim_profile)\n{\n  register const unsigned char\n    *p;\n  size_t\n    length;\n  unsigned char\n    *datum;\n  unsigned int\n    count,\n    long_sans;\n  unsigned short\n    id,\n    short_sans;\n  length=GetStringInfoLength(bim_profile);\n  if (length < 16)\n    return;\n  datum=GetStringInfoDatum(bim_profile);\n  for (p=datum; (p >= datum) && (p < (datum+length-16)); )\n  {\n    register unsigned char\n      *q;\n    q=(unsigned char *) p;\n    if (LocaleNCompare((const char *) p,\"8BIM\",4) != 0)\n      break;\n    p=PushLongPixel(MSBEndian,p,&long_sans);\n    p=PushShortPixel(MSBEndian,p,&id);\n    p=PushShortPixel(MSBEndian,p,&short_sans);\n    p=PushLongPixel(MSBEndian,p,&count);\n    if ((id == 0x000003ed) && (PSDQuantum(count) < (ssize_t) (length-12)))\n      {\n        (void) CopyMagickMemory(q,q+PSDQuantum(count)+12,length-\n          (PSDQuantum(count)+12)-(q-datum));\n        SetStringInfoLength(bim_profile,length-(PSDQuantum(count)+12));\n        break;\n      }\n    p+=count;\n    if ((count & 0x01) != 0)\n      p++;\n  }\n}", "target": 1}
{"code": "R_API char *r_cons_hud_file(const char *f) {\n\tchar *s = r_file_slurp (f, NULL);\n\tif (s) {\n\t\tr_str_ansi_strip (s);\n\t\tchar *ret = r_cons_hud_string (s);\n\t\tfree (s);\n\t\treturn ret;\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "static int br_multicast_add_group(struct net_bridge *br,\n\t\t\t\t  struct net_bridge_port *port,\n\t\t\t\t  struct br_ip *group)\n{\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tunsigned long now = jiffies;\n\tint err;\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) ||\n\t    (port && port->state == BR_STATE_DISABLED))\n\t\tgoto out;\n\tmp = br_multicast_new_group(br, port, group);\n\terr = PTR_ERR(mp);\n\tif (IS_ERR(mp))\n\t\tgoto err;\n\tif (!port) {\n\t\thlist_add_head(&mp->mglist, &br->mglist);\n\t\tmod_timer(&mp->timer, now + br->multicast_membership_interval);\n\t\tgoto out;\n\t}\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (p->port == port)\n\t\t\tgoto found;\n\t\tif ((unsigned long)p->port < (unsigned long)port)\n\t\t\tbreak;\n\t}\n\tp = kzalloc(sizeof(*p), GFP_ATOMIC);\n\terr = -ENOMEM;\n\tif (unlikely(!p))\n\t\tgoto err;\n\tp->addr = *group;\n\tp->port = port;\n\tp->next = *pp;\n\thlist_add_head(&p->mglist, &port->mglist);\n\tsetup_timer(&p->timer, br_multicast_port_group_expired,\n\t\t    (unsigned long)p);\n\tsetup_timer(&p->query_timer, br_multicast_port_group_query_expired,\n\t\t    (unsigned long)p);\n\trcu_assign_pointer(*pp, p);\nfound:\n\tmod_timer(&p->timer, now + br->multicast_membership_interval);\nout:\n\terr = 0;\nerr:\n\tspin_unlock(&br->multicast_lock);\n\treturn err;\n}", "target": 1}
{"code": "GF_Err text_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu16 pSize;\n\tGF_TextSampleEntryBox *ptr = (GF_TextSampleEntryBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\tgf_bs_write_u32(bs, ptr->displayFlags);\t\t\t\n\tgf_bs_write_u32(bs, ptr->textJustification);\t\n\tgf_bs_write_data(bs, ptr->background_color, 6);\t\n\tgpp_write_box(bs, &ptr->default_box);\t\t\t\n\tgf_bs_write_data(bs, ptr->reserved1, 8);\t\t\n\tgf_bs_write_u16(bs, ptr->fontNumber);\t\t\t\n\tgf_bs_write_u16(bs, ptr->fontFace);\t\t\t\t\n\tgf_bs_write_u8(bs, ptr->reserved2);\t\t\t\t\n\tgf_bs_write_u16(bs, ptr->reserved3);\t\t\t\n\tgf_bs_write_data(bs, ptr->foreground_color, 6);\t\n\tif (ptr->textName && (pSize = (u16) strlen(ptr->textName))) {\n\t\tgf_bs_write_u8(bs, pSize);\t\t\t\t\t\n\t\tgf_bs_write_data(bs, ptr->textName, pSize);\t\n\t} else {\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "static INLINE BOOL update_write_brush(wStream* s, rdpBrush* brush, BYTE fieldFlags)\n{\n\tif (fieldFlags & ORDER_FIELD_01)\n\t{\n\t\tStream_Write_UINT8(s, brush->x);\n\t}\n\tif (fieldFlags & ORDER_FIELD_02)\n\t{\n\t\tStream_Write_UINT8(s, brush->y);\n\t}\n\tif (fieldFlags & ORDER_FIELD_03)\n\t{\n\t\tStream_Write_UINT8(s, brush->style);\n\t}\n\tif (brush->style & CACHED_BRUSH)\n\t{\n\t\tbrush->hatch = brush->index;\n\t\tbrush->bpp = BMF_BPP[brush->style & 0x07];\n\t\tif (brush->bpp == 0)\n\t\t\tbrush->bpp = 1;\n\t}\n\tif (fieldFlags & ORDER_FIELD_04)\n\t{\n\t\tStream_Write_UINT8(s, brush->hatch);\n\t}\n\tif (fieldFlags & ORDER_FIELD_05)\n\t{\n\t\tbrush->data = (BYTE*)brush->p8x8;\n\t\tStream_Write_UINT8(s, brush->data[7]);\n\t\tStream_Write_UINT8(s, brush->data[6]);\n\t\tStream_Write_UINT8(s, brush->data[5]);\n\t\tStream_Write_UINT8(s, brush->data[4]);\n\t\tStream_Write_UINT8(s, brush->data[3]);\n\t\tStream_Write_UINT8(s, brush->data[2]);\n\t\tStream_Write_UINT8(s, brush->data[1]);\n\t\tbrush->data[0] = brush->hatch;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "static void follow_dotdot(struct nameidata *nd)\n{\n\tif (!nd->root.mnt)\n\t\tset_root(nd);\n\twhile(1) {\n\t\tstruct dentry *old = nd->path.dentry;\n\t\tif (nd->path.dentry == nd->root.dentry &&\n\t\t    nd->path.mnt == nd->root.mnt) {\n\t\t\tbreak;\n\t\t}\n\t\tif (nd->path.dentry != nd->path.mnt->mnt_root) {\n\t\t\tnd->path.dentry = dget_parent(nd->path.dentry);\n\t\t\tdput(old);\n\t\t\tbreak;\n\t\t}\n\t\tif (!follow_up(&nd->path))\n\t\t\tbreak;\n\t}\n\tfollow_mount(&nd->path);\n\tnd->inode = nd->path.dentry->d_inode;\n}", "target": 1}
{"code": "static int ext4_end_io_dio(struct kiocb *iocb, loff_t offset,\n\t\t\t    ssize_t size, void *private)\n{\n        ext4_io_end_t *io_end = private;\n\tif (!io_end)\n\t\treturn 0;\n\text_debug(\"ext4_end_io_dio(): io_end 0x%p \"\n\t\t  \"for inode %lu, iocb 0x%p, offset %llu, size %zd\\n\",\n\t\t  io_end, io_end->inode->i_ino, iocb, offset, size);\n\tif (size <= 0) {\n\t\text4_clear_io_unwritten_flag(io_end);\n\t\tsize = 0;\n\t}\n\tio_end->offset = offset;\n\tio_end->size = size;\n\text4_put_io_end(io_end);\n\treturn 0;\n}", "target": 0}
{"code": "static void vhost_vdpa_reset(struct vhost_vdpa *v)\n{\n\tstruct vdpa_device *vdpa = v->vdpa;\n\tvdpa_reset(vdpa);\n\tv->in_batch = 0;\n}", "target": 0}
{"code": "archive_read_format_zip_cleanup(struct archive_read *a)\n{\n\tstruct zip *zip;\n\tstruct zip_entry *zip_entry, *next_zip_entry;\n\tzip = (struct zip *)(a->format->data);\n#ifdef HAVE_ZLIB_H\n\tif (zip->stream_valid)\n\t\tinflateEnd(&zip->stream);\n#endif\n#if HAVA_LZMA_H && HAVE_LIBLZMA\n    if (zip->zipx_lzma_valid) {\n\t\tlzma_end(&zip->zipx_lzma_stream);\n\t}\n#endif\n#ifdef HAVE_BZLIB_H\n\tif (zip->bzstream_valid) {\n\t\tBZ2_bzDecompressEnd(&zip->bzstream);\n\t}\n#endif\n\tfree(zip->uncompressed_buffer);\n\tif (zip->ppmd8_valid)\n\t\t__archive_ppmd8_functions.Ppmd8_Free(&zip->ppmd8);\n\tif (zip->zip_entries) {\n\t\tzip_entry = zip->zip_entries;\n\t\twhile (zip_entry != NULL) {\n\t\t\tnext_zip_entry = zip_entry->next;\n\t\t\tarchive_string_free(&zip_entry->rsrcname);\n\t\t\tfree(zip_entry);\n\t\t\tzip_entry = next_zip_entry;\n\t\t}\n\t}\n\tfree(zip->decrypted_buffer);\n\tif (zip->cctx_valid)\n\t\tarchive_decrypto_aes_ctr_release(&zip->cctx);\n\tif (zip->hctx_valid)\n\t\tarchive_hmac_sha1_cleanup(&zip->hctx);\n\tfree(zip->iv);\n\tfree(zip->erd);\n\tfree(zip->v_data);\n\tarchive_string_free(&zip->format_name);\n\tfree(zip);\n\t(a->format->data) = NULL;\n\treturn (ARCHIVE_OK);\n}", "target": 1}
{"code": "ModuleSQL::~ModuleSQL()\n{\n\tif (Dispatcher)\n\t{\n\t\tDispatcher->join();\n\t\tDispatcher->OnNotify();\n\t\tdelete Dispatcher;\n\t}\n\tfor(ConnMap::iterator i = connections.begin(); i != connections.end(); i++)\n\t{\n\t\tdelete i->second;\n\t}\n\tmysql_library_end();\n}", "target": 0}
{"code": "int hns_rcb_get_ring_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn HNS_RING_STATIC_REG_NUM;\n\treturn 0;\n}", "target": 1}
{"code": "struct bpf_prog *bpf_prog_inc(struct bpf_prog *prog)\n{\n\tif (atomic_inc_return(&prog->aux->refcnt) > BPF_MAX_REFCNT) {\n\t\tatomic_dec(&prog->aux->refcnt);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\treturn prog;\n}", "target": 0}
{"code": "pktap_if_print(netdissect_options *ndo,\n               const struct pcap_pkthdr *h, const u_char *p)\n{\n\tuint32_t dlt, hdrlen, rectype;\n\tu_int caplen = h->caplen;\n\tu_int length = h->len;\n\tif_printer printer;\n\tconst pktap_header_t *hdr;\n\tif (caplen < sizeof(pktap_header_t) || length < sizeof(pktap_header_t)) {\n\t\tND_PRINT((ndo, \"[|pktap]\"));\n\t\treturn (0);\n\t}\n\thdr = (const pktap_header_t *)p;\n\tdlt = EXTRACT_LE_32BITS(&hdr->pkt_dlt);\n\thdrlen = EXTRACT_LE_32BITS(&hdr->pkt_len);\n\tif (hdrlen < sizeof(pktap_header_t)) {\n\t\tND_PRINT((ndo, \"[|pktap]\"));\n\t\treturn (0);\n\t}\n\tif (caplen < hdrlen || length < hdrlen) {\n\t\tND_PRINT((ndo, \"[|pktap]\"));\n\t\treturn (hdrlen);\n\t}\n\tif (ndo->ndo_eflag)\n\t\tpktap_header_print(ndo, p, length);\n\tlength -= hdrlen;\n\tcaplen -= hdrlen;\n\tp += hdrlen;\n\trectype = EXTRACT_LE_32BITS(&hdr->pkt_rectype);\n\tswitch (rectype) {\n\tcase PKT_REC_NONE:\n\t\tND_PRINT((ndo, \"no data\"));\n\t\tbreak;\n\tcase PKT_REC_PACKET:\n\t\tif ((printer = lookup_printer(dlt)) != NULL) {\n\t\t\thdrlen += printer(ndo, h, p);\n\t\t} else {\n\t\t\tif (!ndo->ndo_eflag)\n\t\t\t\tpktap_header_print(ndo, (const u_char *)hdr,\n\t\t\t\t\t\tlength + hdrlen);\n\t\t\tif (!ndo->ndo_suppress_default_print)\n\t\t\t\tND_DEFAULTPRINT(p, caplen);\n\t\t}\n\t\tbreak;\n\t}\n\treturn (hdrlen);\n}", "target": 1}
{"code": "void color_sycc_to_rgb(opj_image_t *img)\n{\n\tif(img->numcomps < 3)\n\t{\n\t\timg->color_space = OPJ_CLRSPC_GRAY;\n\t\treturn;\n\t}\n\tif((img->comps[0].dx == 1)\n\t&& (img->comps[1].dx == 2)\n\t&& (img->comps[2].dx == 2)\n\t&& (img->comps[0].dy == 1)\n\t&& (img->comps[1].dy == 2)\n\t&& (img->comps[2].dy == 2))\n  {\n\t\tsycc420_to_rgb(img);\n  }\n\telse\n\tif((img->comps[0].dx == 1)\n\t&& (img->comps[1].dx == 2)\n\t&& (img->comps[2].dx == 2)\n\t&& (img->comps[0].dy == 1)\n\t&& (img->comps[1].dy == 1)\n\t&& (img->comps[2].dy == 1))\n  {\n\t\tsycc422_to_rgb(img);\n  }\n\telse\n\tif((img->comps[0].dx == 1)\n\t&& (img->comps[1].dx == 1)\n\t&& (img->comps[2].dx == 1)\n\t&& (img->comps[0].dy == 1)\n\t&& (img->comps[1].dy == 1)\n\t&& (img->comps[2].dy == 1))\n  {\n\t\tsycc444_to_rgb(img);\n  }\n\telse\n  {\n\t\tfprintf(stderr,\"%s:%d:color_sycc_to_rgb\\n\\tCAN NOT CONVERT\\n\", __FILE__,__LINE__);\n\t\treturn;\n  }\n\timg->color_space = OPJ_CLRSPC_SRGB;\n}", "target": 1}
{"code": "static bool has_locked_children(struct mount *mnt, struct dentry *dentry)\n{\n\tstruct mount *child;\n\tlist_for_each_entry(child, &mnt->mnt_mounts, mnt_child) {\n\t\tif (!is_subdir(child->mnt_mountpoint, dentry))\n\t\t\tcontinue;\n\t\tif (child->mnt.mnt_flags & MNT_LOCKED)\n\t\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "vmxnet3_rq_cleanup(struct vmxnet3_rx_queue *rq,\n\t\t   struct vmxnet3_adapter *adapter)\n{\n\tu32 i, ring_idx;\n\tstruct Vmxnet3_RxDesc *rxd;\n\tif (!rq->rx_ring[0].base)\n\t\treturn;\n\tfor (ring_idx = 0; ring_idx < 2; ring_idx++) {\n\t\tfor (i = 0; i < rq->rx_ring[ring_idx].size; i++) {\n#ifdef __BIG_ENDIAN_BITFIELD\n\t\t\tstruct Vmxnet3_RxDesc rxDesc;\n#endif\n\t\t\tvmxnet3_getRxDesc(rxd,\n\t\t\t\t&rq->rx_ring[ring_idx].base[i].rxd, &rxDesc);\n\t\t\tif (rxd->btype == VMXNET3_RXD_BTYPE_HEAD &&\n\t\t\t\t\trq->buf_info[ring_idx][i].skb) {\n\t\t\t\tdma_unmap_single(&adapter->pdev->dev, rxd->addr,\n\t\t\t\t\t\t rxd->len, DMA_FROM_DEVICE);\n\t\t\t\tdev_kfree_skb(rq->buf_info[ring_idx][i].skb);\n\t\t\t\trq->buf_info[ring_idx][i].skb = NULL;\n\t\t\t} else if (rxd->btype == VMXNET3_RXD_BTYPE_BODY &&\n\t\t\t\t\trq->buf_info[ring_idx][i].page) {\n\t\t\t\tdma_unmap_page(&adapter->pdev->dev, rxd->addr,\n\t\t\t\t\t       rxd->len, DMA_FROM_DEVICE);\n\t\t\t\tput_page(rq->buf_info[ring_idx][i].page);\n\t\t\t\trq->buf_info[ring_idx][i].page = NULL;\n\t\t\t}\n\t\t}\n\t\trq->rx_ring[ring_idx].gen = VMXNET3_INIT_GEN;\n\t\trq->rx_ring[ring_idx].next2fill =\n\t\t\t\t\trq->rx_ring[ring_idx].next2comp = 0;\n\t}\n\trq->comp_ring.gen = VMXNET3_INIT_GEN;\n\trq->comp_ring.next2proc = 0;\n}", "target": 0}
{"code": "int nfc_llcp_send_cc(struct nfc_llcp_sock *sock)\n{\n\tstruct nfc_llcp_local *local;\n\tstruct sk_buff *skb;\n\tu8 *miux_tlv = NULL, miux_tlv_length;\n\tu8 *rw_tlv = NULL, rw_tlv_length, rw;\n\tint err;\n\tu16 size = 0;\n\t__be16 miux;\n\tpr_debug(\"Sending CC\\n\");\n\tlocal = sock->local;\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\tmiux = be16_to_cpu(sock->miux) > LLCP_MAX_MIUX ?\n\t\tlocal->miux : sock->miux;\n\trw = sock->rw > LLCP_MAX_RW ? local->rw : sock->rw;\n\tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,\n\t\t\t\t      &miux_tlv_length);\n\tif (!miux_tlv) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\tsize += miux_tlv_length;\n\trw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);\n\tif (!rw_tlv) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\tsize += rw_tlv_length;\n\tskb = llcp_allocate_pdu(sock, LLCP_PDU_CC, size);\n\tif (skb == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\tllcp_add_tlv(skb, miux_tlv, miux_tlv_length);\n\tllcp_add_tlv(skb, rw_tlv, rw_tlv_length);\n\tskb_queue_tail(&local->tx_queue, skb);\n\terr = 0;\nerror_tlv:\n\tif (err)\n\t\tpr_err(\"error %d\\n\", err);\n\tkfree(miux_tlv);\n\tkfree(rw_tlv);\n\treturn err;\n}", "target": 0}
{"code": "static int stimer_set_config(struct kvm_vcpu_hv_stimer *stimer, u64 config,\n\t\t\t     bool host)\n{\n\tunion hv_stimer_config new_config = {.as_uint64 = config},\n\t\told_config = {.as_uint64 = stimer->config.as_uint64};\n\tstruct kvm_vcpu *vcpu = hv_stimer_to_vcpu(stimer);\n\tstruct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);\n\tstruct kvm_vcpu_hv_synic *synic = to_hv_synic(vcpu);\n\tif (!synic->active && !host)\n\t\treturn 1;\n\tif (unlikely(!host && hv_vcpu->enforce_cpuid && new_config.direct_mode &&\n\t\t     !(hv_vcpu->cpuid_cache.features_edx &\n\t\t       HV_STIMER_DIRECT_MODE_AVAILABLE)))\n\t\treturn 1;\n\ttrace_kvm_hv_stimer_set_config(hv_stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t       stimer->index, config, host);\n\tstimer_cleanup(stimer);\n\tif (old_config.enable &&\n\t    !new_config.direct_mode && new_config.sintx == 0)\n\t\tnew_config.enable = 0;\n\tstimer->config.as_uint64 = new_config.as_uint64;\n\tif (stimer->config.enable)\n\t\tstimer_mark_pending(stimer, false);\n\treturn 0;\n}", "target": 1}
{"code": "static struct sk_buff *xfrm_state_netlink(struct sk_buff *in_skb,\n\t\t\t\t\t  struct xfrm_state *x, u32 seq)\n{\n\tstruct xfrm_dump_info info;\n\tstruct sk_buff *skb;\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\tinfo.in_skb = in_skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = seq;\n\tinfo.nlmsg_flags = 0;\n\tif (dump_one_state(x, 0, &info)) {\n\t\tkfree_skb(skb);\n\t\treturn NULL;\n\t}\n\treturn skb;\n}", "target": 1}
{"code": "std::string Url::DecodeUnsafe(string_view encoded) {\n  std::string raw;\n  if (Decode(encoded, &raw)) {\n    return raw;\n  }\n  return ToString(encoded);\n}", "target": 0}
{"code": "static char *__filterQuotedShell(const char *arg) {\n\tr_return_val_if_fail (arg, NULL);\n\tchar *a = malloc (strlen (arg) + 1);\n\tif (!a) {\n\t\treturn NULL;\n\t}\n\tchar *b = a;\n\twhile (*arg) {\n\t\tswitch (*arg) {\n\t\tcase ' ':\n\t\tcase '=':\n\t\tcase '\"':\n\t\tcase '\\\\':\n\t\tcase '\\r':\n\t\tcase '\\n':\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*b++ = *arg;\n\t\t\tbreak;\n\t\t}\n\t\targ++;\n\t}\n\t*b = 0;\n\treturn a;\n}", "target": 0}
{"code": "static int fetch_objects(struct repository *repo,\n\t\t\t const char *remote_name,\n\t\t\t const struct object_id *oids,\n\t\t\t int oid_nr)\n{\n\tstruct child_process child = CHILD_PROCESS_INIT;\n\tint i;\n\tFILE *child_in;\n\tif (git_env_bool(\"GIT_NO_LAZY_FETCH\", 0)) {\n\t\tstatic int warning_shown;\n\t\tif (!warning_shown) {\n\t\t\twarning_shown = 1;\n\t\t\twarning(_(\"lazy fetching disabled; some objects may not be available\"));\n\t\t}\n\t\treturn -1;\n\t}\n\tchild.git_cmd = 1;\n\tchild.in = -1;\n\tif (repo != the_repository)\n\t\tprepare_other_repo_env(&child.env, repo->gitdir);\n\tstrvec_pushl(&child.args, \"-c\", \"fetch.negotiationAlgorithm=noop\",\n\t\t     \"fetch\", remote_name, \"--no-tags\",\n\t\t     \"--no-write-fetch-head\", \"--recurse-submodules=no\",\n\t\t     \"--filter=blob:none\", \"--stdin\", NULL);\n\tif (start_command(&child))\n\t\tdie(_(\"promisor-remote: unable to fork off fetch subprocess\"));\n\tchild_in = xfdopen(child.in, \"w\");\n\ttrace2_data_intmax(\"promisor\", repo, \"fetch_count\", oid_nr);\n\tfor (i = 0; i < oid_nr; i++) {\n\t\tif (fputs(oid_to_hex(&oids[i]), child_in) < 0)\n\t\t\tdie_errno(_(\"promisor-remote: could not write to fetch subprocess\"));\n\t\tif (fputc('\\n', child_in) < 0)\n\t\t\tdie_errno(_(\"promisor-remote: could not write to fetch subprocess\"));\n\t}\n\tif (fclose(child_in) < 0)\n\t\tdie_errno(_(\"promisor-remote: could not close stdin to fetch subprocess\"));\n\treturn finish_command(&child) ? -1 : 0;\n}", "target": 0}
{"code": "static BOOL rdp_read_font_capability_set(wStream* s, UINT16 length, rdpSettings* settings)\n{\n\tWINPR_UNUSED(settings);\n\tif (length > 4)\n\t\tStream_Seek_UINT16(s); \n\tif (length > 6)\n\t\tStream_Seek_UINT16(s); \n\treturn TRUE;\n}", "target": 1}
{"code": "static int mov_write_vpcc_tag(AVFormatContext *s, AVIOContext *pb, MOVTrack *track)\n{\n    int64_t pos = avio_tell(pb);\n    avio_wb32(pb, 0);\n    ffio_wfourcc(pb, \"vpcC\");\n    avio_wb32(pb, 0); \n    ff_isom_write_vpcc(s, pb, track->par);\n    return update_size(pb, pos);\n}", "target": 0}
{"code": "static int xgene_hwmon_remove(struct platform_device *pdev)\n{\n\tstruct xgene_hwmon_dev *ctx = platform_get_drvdata(pdev);\n\tcancel_work_sync(&ctx->workq);\n\thwmon_device_unregister(ctx->hwmon_dev);\n\tkfifo_free(&ctx->async_msg_fifo);\n\tif (acpi_disabled)\n\t\tmbox_free_channel(ctx->mbox_chan);\n\telse\n\t\tpcc_mbox_free_channel(ctx->pcc_chan);\n\treturn 0;\n}", "target": 0}
{"code": "DECLAREreadFunc(readContigTilesIntoBuffer)\n{\n\tint status = 1;\n\ttsize_t tilesize = TIFFTileSize(in);\n\ttdata_t tilebuf;\n\tuint32 imagew = TIFFScanlineSize(in);\n\tuint32 tilew  = TIFFTileRowSize(in);\n\tint iskew = imagew - tilew;\n\tuint8* bufp = (uint8*) buf;\n\tuint32 tw, tl;\n\tuint32 row;\n\t(void) spp;\n\ttilebuf = _TIFFmalloc(tilesize);\n\tif (tilebuf == 0)\n\t\treturn 0;\n\t_TIFFmemset(tilebuf, 0, tilesize);\n\t(void) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n\t(void) TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n\tfor (row = 0; row < imagelength; row += tl) {\n\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\n\t\tuint32 colb = 0;\n\t\tuint32 col;\n\t\tfor (col = 0; col < imagewidth; col += tw) {\n\t\t\tif (TIFFReadTile(in, tilebuf, col, row, 0, 0) < 0\n\t\t\t    && !ignore) {\n\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t    \"Error, can't read tile at %lu %lu\",\n\t\t\t\t    (unsigned long) col,\n\t\t\t\t    (unsigned long) row);\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (colb + tilew > imagew) {\n\t\t\t\tuint32 width = imagew - colb;\n\t\t\t\tuint32 oskew = tilew - width;\n\t\t\t\tcpStripToTile(bufp + colb,\n\t\t\t\t    tilebuf, nrow, width,\n\t\t\t\t    oskew + iskew, oskew );\n\t\t\t} else\n\t\t\t\tcpStripToTile(bufp + colb,\n\t\t\t\t    tilebuf, nrow, tilew,\n\t\t\t\t    iskew, 0);\n\t\t\tcolb += tilew;\n\t\t}\n\t\tbufp += imagew * nrow;\n\t}\ndone:\n\t_TIFFfree(tilebuf);\n\treturn status;\n}", "target": 1}
{"code": "static long __snd_timer_user_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct snd_timer_user *tu;\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *p = argp;\n\ttu = file->private_data;\n\tswitch (cmd) {\n\tcase SNDRV_TIMER_IOCTL_PVERSION:\n\t\treturn put_user(SNDRV_TIMER_VERSION, p) ? -EFAULT : 0;\n\tcase SNDRV_TIMER_IOCTL_NEXT_DEVICE:\n\t\treturn snd_timer_user_next_device(argp);\n\tcase SNDRV_TIMER_IOCTL_TREAD:\n\t{\n\t\tint xarg;\n\t\tif (tu->timeri)\t\n\t\t\treturn -EBUSY;\n\t\tif (get_user(xarg, p))\n\t\t\treturn -EFAULT;\n\t\ttu->tread = xarg ? 1 : 0;\n\t\treturn 0;\n\t}\n\tcase SNDRV_TIMER_IOCTL_GINFO:\n\t\treturn snd_timer_user_ginfo(file, argp);\n\tcase SNDRV_TIMER_IOCTL_GPARAMS:\n\t\treturn snd_timer_user_gparams(file, argp);\n\tcase SNDRV_TIMER_IOCTL_GSTATUS:\n\t\treturn snd_timer_user_gstatus(file, argp);\n\tcase SNDRV_TIMER_IOCTL_SELECT:\n\t\treturn snd_timer_user_tselect(file, argp);\n\tcase SNDRV_TIMER_IOCTL_INFO:\n\t\treturn snd_timer_user_info(file, argp);\n\tcase SNDRV_TIMER_IOCTL_PARAMS:\n\t\treturn snd_timer_user_params(file, argp);\n\tcase SNDRV_TIMER_IOCTL_STATUS:\n\t\treturn snd_timer_user_status(file, argp);\n\tcase SNDRV_TIMER_IOCTL_START:\n\tcase SNDRV_TIMER_IOCTL_START_OLD:\n\t\treturn snd_timer_user_start(file);\n\tcase SNDRV_TIMER_IOCTL_STOP:\n\tcase SNDRV_TIMER_IOCTL_STOP_OLD:\n\t\treturn snd_timer_user_stop(file);\n\tcase SNDRV_TIMER_IOCTL_CONTINUE:\n\tcase SNDRV_TIMER_IOCTL_CONTINUE_OLD:\n\t\treturn snd_timer_user_continue(file);\n\tcase SNDRV_TIMER_IOCTL_PAUSE:\n\tcase SNDRV_TIMER_IOCTL_PAUSE_OLD:\n\t\treturn snd_timer_user_pause(file);\n\t}\n\treturn -ENOTTY;\n}", "target": 0}
{"code": "GF_Err text_box_size(GF_Box *s)\n{\n\tGF_TextSampleEntryBox *ptr = (GF_TextSampleEntryBox*)s;\n\ts->size += 51 + 1;\n\tif (ptr->textName)\n\t\ts->size += strlen(ptr->textName);\n\treturn GF_OK;\n}", "target": 1}
{"code": "int MSADPCM::decodeBlock(const uint8_t *encoded, int16_t *decoded)\n{\n\tms_adpcm_state decoderState[2];\n\tms_adpcm_state *state[2];\n\tint channelCount = m_track->f.channelCount;\n\tint outputLength = m_framesPerPacket * sizeof (int16_t) * channelCount;\n\tstate[0] = &decoderState[0];\n\tif (channelCount == 2)\n\t\tstate[1] = &decoderState[1];\n\telse\n\t\tstate[1] = &decoderState[0];\n\tfor (int i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->predictorIndex = *encoded++;\n\t\tassert(state[i]->predictorIndex < m_numCoefficients);\n\t}\n\tfor (int i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->delta = (encoded[1]<<8) | encoded[0];\n\t\tencoded += sizeof (uint16_t);\n\t}\n\tfor (int i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->sample1 = (encoded[1]<<8) | encoded[0];\n\t\tencoded += sizeof (uint16_t);\n\t}\n\tfor (int i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->sample2 = (encoded[1]<<8) | encoded[0];\n\t\tencoded += sizeof (uint16_t);\n\t}\n\tconst int16_t *coefficient[2] =\n\t{\n\t\tm_coefficients[state[0]->predictorIndex],\n\t\tm_coefficients[state[1]->predictorIndex]\n\t};\n\tfor (int i=0; i<channelCount; i++)\n\t\t*decoded++ = state[i]->sample2;\n\tfor (int i=0; i<channelCount; i++)\n\t\t*decoded++ = state[i]->sample1;\n\tint samplesRemaining = (m_framesPerPacket - 2) * m_track->f.channelCount;\n\twhile (samplesRemaining > 0)\n\t{\n\t\tuint8_t code;\n\t\tint16_t newSample;\n\t\tcode = *encoded >> 4;\n\t\tnewSample = decodeSample(*state[0], code, coefficient[0]);\n\t\t*decoded++ = newSample;\n\t\tcode = *encoded & 0x0f;\n\t\tnewSample = decodeSample(*state[1], code, coefficient[1]);\n\t\t*decoded++ = newSample;\n\t\tencoded++;\n\t\tsamplesRemaining -= 2;\n\t}\n\treturn outputLength;\n}", "target": 1}
{"code": "handle_ppp(netdissect_options *ndo,\n           u_int proto, const u_char *p, int length)\n{\n\tif ((proto & 0xff00) == 0x7e00) { \n\t\tppp_hdlc(ndo, p - 1, length);\n\t\treturn;\n\t}\n\tswitch (proto) {\n\tcase PPP_LCP: \n\tcase PPP_IPCP:\n\tcase PPP_OSICP:\n\tcase PPP_MPLSCP:\n\tcase PPP_IPV6CP:\n\tcase PPP_CCP:\n\tcase PPP_BACP:\n\t\thandle_ctrl_proto(ndo, proto, p, length);\n\t\tbreak;\n\tcase PPP_ML:\n\t\thandle_mlppp(ndo, p, length);\n\t\tbreak;\n\tcase PPP_CHAP:\n\t\thandle_chap(ndo, p, length);\n\t\tbreak;\n\tcase PPP_PAP:\n\t\thandle_pap(ndo, p, length);\n\t\tbreak;\n\tcase PPP_BAP:\t\t\n\t\thandle_bap(ndo, p, length);\n\t\tbreak;\n\tcase ETHERTYPE_IP:\t\n        case PPP_VJNC:\n\tcase PPP_IP:\n\t\tip_print(ndo, p, length);\n\t\tbreak;\n\tcase ETHERTYPE_IPV6:\t\n\tcase PPP_IPV6:\n\t\tip6_print(ndo, p, length);\n\t\tbreak;\n\tcase ETHERTYPE_IPX:\t\n\tcase PPP_IPX:\n\t\tipx_print(ndo, p, length);\n\t\tbreak;\n\tcase PPP_OSI:\n\t\tisoclns_print(ndo, p, length, length);\n\t\tbreak;\n\tcase PPP_MPLS_UCAST:\n\tcase PPP_MPLS_MCAST:\n\t\tmpls_print(ndo, p, length);\n\t\tbreak;\n\tcase PPP_COMP:\n\t\tND_PRINT((ndo, \"compressed PPP data\"));\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \"%s \", tok2str(ppptype2str, \"unknown PPP protocol (0x%04x)\", proto)));\n\t\tprint_unknown_data(ndo, p, \"\\n\\t\", length);\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "void CoreNetwork::putCmd(const QString &cmd, const QList<QList<QByteArray>> &params, const QByteArray &prefix)\n{\n    QListIterator<QList<QByteArray>> i(params);\n    while (i.hasNext()) {\n        QList<QByteArray> msg = i.next();\n        putCmd(cmd, msg, prefix);\n    }\n}", "target": 0}
{"code": "static void my_output_message( j_common_ptr ) {} ", "target": 0}
{"code": "static int ext4_dax_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\treturn dax_mkwrite(vma, vmf, ext4_get_block_dax,\n\t\t\t\text4_end_io_unwritten);\n}", "target": 1}
{"code": "static int count_ah_combs(const struct xfrm_tmpl *t)\n{\n\tint i, sz = 0;\n\tfor (i = 0; ; i++) {\n\t\tconst struct xfrm_algo_desc *aalg = xfrm_aalg_get_byidx(i);\n\t\tif (!aalg)\n\t\t\tbreak;\n\t\tif (!aalg->pfkey_supported)\n\t\t\tcontinue;\n\t\tif (aalg_tmpl_set(t, aalg) && aalg->available)\n\t\t\tsz += sizeof(struct sadb_comb);\n\t}\n\treturn sz + sizeof(struct sadb_prop);\n}", "target": 0}
{"code": "static inline void sctp_copy_descendant(struct sock *sk_to,\n\t\t\t\t\tconst struct sock *sk_from)\n{\n\tint ancestor_size = sizeof(struct inet_sock) +\n\t\t\t    sizeof(struct sctp_sock) -\n\t\t\t    offsetof(struct sctp_sock, auto_asconf_list);\n\tif (sk_from->sk_family == PF_INET6)\n\t\tancestor_size += sizeof(struct ipv6_pinfo);\n\t__inet_sk_copy_descendant(sk_to, sk_from, ancestor_size);\n}", "target": 0}
{"code": "static int proc_connectinfo(struct usb_dev_state *ps, void __user *arg)\n{\n\tstruct usbdevfs_connectinfo ci = {\n\t\t.devnum = ps->dev->devnum,\n\t\t.slow = ps->dev->speed == USB_SPEED_LOW\n\t};\n\tif (copy_to_user(arg, &ci, sizeof(ci)))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1}
{"code": "ecma_op_function_call_native_built_in (ecma_object_t *func_obj_p, \n                                       ecma_value_t this_arg_value, \n                                       const ecma_value_t *arguments_list_p, \n                                       uint32_t arguments_list_len) \n{\n  JERRY_ASSERT (ecma_get_object_type (func_obj_p) == ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION);\n  ECMA_CHECK_STACK_USAGE ();\n#if JERRY_BUILTIN_REALMS\n  ecma_global_object_t *saved_global_object_p = JERRY_CONTEXT (global_object_p);\n  ecma_extended_object_t *ext_func_obj_p = (ecma_extended_object_t *) func_obj_p;\n  JERRY_CONTEXT (global_object_p) =\n    ECMA_GET_INTERNAL_VALUE_POINTER (ecma_global_object_t, ext_func_obj_p->u.built_in.realm_value);\n#endif \n  ecma_value_t ret_value =\n    ecma_builtin_dispatch_call (func_obj_p, this_arg_value, arguments_list_p, arguments_list_len);\n#if JERRY_BUILTIN_REALMS\n  JERRY_CONTEXT (global_object_p) = saved_global_object_p;\n#endif \n  return ret_value;\n} ", "target": 0}
{"code": "int pam_modutil_regain_priv(pam_handle_t *pamh, struct _ykpam_privs *privs) {\n    if ((privs->saved_euid == geteuid()) && (privs->saved_egid == getegid())) {\n        D (privs->debug_file, \"Privilges already as requested, pretend it is all right\");\n        return 0;\n    }\n    if (seteuid(privs->saved_euid) < 0) {\n        D (privs->debug_file, \"seteuid: %s\", strerror(errno));\n        return -1;\n    }\n    if (setegid(privs->saved_egid) < 0) {\n        D (privs->debug_file, \"setegid: %s\", strerror(errno));\n        return -1;\n    }\n    if (setgroups(privs->saved_groups_length, privs->saved_groups) < 0) {\n        D (privs->debug_file, \"setgroups: %s\", strerror(errno));\n        return -1;\n    }\n    return 0;\n}", "target": 0}
{"code": "static size_t exif_convert_any_to_int(void *value, int format, int motorola_intel TSRMLS_DC)\n{\n\tint \t\ts_den;\n\tunsigned \tu_den;\n\tswitch(format) {\n\t\tcase TAG_FMT_SBYTE:     return *(signed char *)value;\n\t\tcase TAG_FMT_BYTE:      return *(uchar *)value;\n\t\tcase TAG_FMT_USHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_ULONG:     return php_ifd_get32u(value, motorola_intel);\n\t\tcase TAG_FMT_URATIONAL:\n\t\t\tu_den = php_ifd_get32u(4+(char *)value, motorola_intel);\n\t\t\tif (u_den == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn php_ifd_get32u(value, motorola_intel) / u_den;\n\t\t\t}\n\t\tcase TAG_FMT_SRATIONAL:\n\t\t\ts_den = php_ifd_get32s(4+(char *)value, motorola_intel);\n\t\t\tif (s_den == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn php_ifd_get32s(value, motorola_intel) / s_den;\n\t\t\t}\n\t\tcase TAG_FMT_SSHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_SLONG:     return php_ifd_get32s(value, motorola_intel);\n\t\tcase TAG_FMT_SINGLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Found value of type single\");\n#endif\n\t\t\treturn (size_t)*(float *)value;\n\t\tcase TAG_FMT_DOUBLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Found value of type double\");\n#endif\n\t\t\treturn (size_t)*(double *)value;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "matchDomainName(const char *h, const char *d, MatchDomainNameFlags flags)\n{\n    int dl;\n    int hl;\n    const bool hostIncludesSubdomains = (*h == '.');\n    while ('.' == *h)\n        ++h;\n    hl = strlen(h);\n    if (hl == 0)\n        return -1;\n    dl = strlen(d);\n    if (dl == 0)\n        return 1;\n    while (xtolower(h[--hl]) == xtolower(d[--dl])) {\n        if (hl == 0 && dl == 0) {\n            return 0;\n        }\n        if (0 == hl) {\n            if (1 == dl && '.' == d[0])\n                return 0;\n            else\n                return -1;\n        }\n        if (0 == dl) {\n            if ('.' == d[0]) {\n                if (flags & mdnRejectSubsubDomains) {\n                    while(--hl >= 0 && h[hl] != '.');\n                    if (hl < 0) {\n                        return hostIncludesSubdomains ? 1 : 0;\n                    } else\n                        return 1; \n                } else\n                    return 0;\n            } else\n                return 1;\n        }\n    }\n    if ((flags & mdnHonorWildcards) && h[hl] == '*' && h[hl + 1] == '.')\n        return 0;\n    if ('.' == d[dl])\n        return 1;\n    if ('.' == h[hl])\n        return -1;\n    return (xtolower(h[hl]) - xtolower(d[dl]));\n}", "target": 0}
{"code": "PHP_MINFO_FUNCTION(exif)\n{\n\tphp_info_print_table_start();\n\tphp_info_print_table_row(2, \"EXIF Support\", \"enabled\");\n\tphp_info_print_table_row(2, \"Supported EXIF Version\", \"0220\");\n\tphp_info_print_table_row(2, \"Supported filetypes\", \"JPEG, TIFF\");\n\tif (zend_hash_str_exists(&module_registry, \"mbstring\", sizeof(\"mbstring\")-1)) {\n\t\tphp_info_print_table_row(2, \"Multibyte decoding support using mbstring\", \"enabled\");\n\t} else {\n\t\tphp_info_print_table_row(2, \"Multibyte decoding support using mbstring\", \"disabled\");\n\t}\n\tphp_info_print_table_row(2, \"Extended EXIF tag formats\", \"Canon, Casio, Fujifilm, Nikon, Olympus, Samsung, Panasonic, DJI, Sony, Pentax, Minolta, Sigma, Foveon, Kyocera, Ricoh, AGFA, Epson\");\n\tphp_info_print_table_end();\n\tDISPLAY_INI_ENTRIES();\n}", "target": 0}
{"code": "static void *seq_buf_alloc(unsigned long size)\n{\n\tif (unlikely(size > MAX_RW_COUNT))\n\t\treturn NULL;\n\treturn kvmalloc(size, GFP_KERNEL_ACCOUNT);\n}", "target": 0}
{"code": "int btrfs_get_dev_stats(struct btrfs_fs_info *fs_info,\n\t\t\tstruct btrfs_ioctl_get_dev_stats *stats)\n{\n\tstruct btrfs_device *dev;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tint i;\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(fs_info->fs_devices, stats->devid, NULL, NULL);\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\tif (!dev) {\n\t\tbtrfs_warn(fs_info, \"get dev_stats failed, device not found\");\n\t\treturn -ENODEV;\n\t} else if (!dev->dev_stats_valid) {\n\t\tbtrfs_warn(fs_info, \"get dev_stats failed, not yet valid\");\n\t\treturn -ENODEV;\n\t} else if (stats->flags & BTRFS_DEV_STATS_RESET) {\n\t\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++) {\n\t\t\tif (stats->nr_items > i)\n\t\t\t\tstats->values[i] =\n\t\t\t\t\tbtrfs_dev_stat_read_and_reset(dev, i);\n\t\t\telse\n\t\t\t\tbtrfs_dev_stat_reset(dev, i);\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++)\n\t\t\tif (stats->nr_items > i)\n\t\t\t\tstats->values[i] = btrfs_dev_stat_read(dev, i);\n\t}\n\tif (stats->nr_items > BTRFS_DEV_STAT_VALUES_MAX)\n\t\tstats->nr_items = BTRFS_DEV_STAT_VALUES_MAX;\n\treturn 0;\n}", "target": 1}
{"code": "int jpc_bitstream_putbits(jpc_bitstream_t *bitstream, int n, long v)\n{\n\tint m;\n\tassert(n >= 0 && n < 32);\n\tassert(!(v & (~JAS_ONES(n))));\n\tm = n - 1;\n\twhile (--n >= 0) {\n\t\tif (jpc_bitstream_putbit(bitstream, (v >> m) & 1) == EOF) {\n\t\t\treturn EOF;\n\t\t}\n\t\tv <<= 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static inline void pgd_free(struct mm_struct *mm, pgd_t *pgd)\n{\n\tif (mm->context.asce_limit == (1UL << 31))\n\t\tpgtable_pmd_page_dtor(virt_to_page(pgd));\n\tcrst_table_free(mm, (unsigned long *) pgd);\n}", "target": 0}
{"code": "int x86_decode_emulated_instruction(struct kvm_vcpu *vcpu, int emulation_type,\n\t\t\t\t    void *insn, int insn_len)\n{\n\tint r = EMULATION_OK;\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\tinit_emulate_ctxt(vcpu);\n\tif (!(emulation_type & EMULTYPE_SKIP) &&\n\t    kvm_vcpu_check_breakpoint(vcpu, &r))\n\t\treturn r;\n\tr = x86_decode_insn(ctxt, insn, insn_len, emulation_type);\n\ttrace_kvm_emulate_insn_start(vcpu);\n\t++vcpu->stat.insn_emulation;\n\treturn r;\n}", "target": 1}
{"code": "static int netlbl_cipsov4_add_common(struct genl_info *info,\n\t\t\t\t     struct cipso_v4_doi *doi_def)\n{\n\tstruct nlattr *nla;\n\tint nla_rem;\n\tu32 iter = 0;\n\tdoi_def->doi = nla_get_u32(info->attrs[NLBL_CIPSOV4_A_DOI]);\n\tif (nla_validate_nested(info->attrs[NLBL_CIPSOV4_A_TAGLST],\n\t\t\t\tNLBL_CIPSOV4_A_MAX,\n\t\t\t\tnetlbl_cipsov4_genl_policy) != 0)\n\t\treturn -EINVAL;\n\tnla_for_each_nested(nla, info->attrs[NLBL_CIPSOV4_A_TAGLST], nla_rem)\n\t\tif (nla->nla_type == NLBL_CIPSOV4_A_TAG) {\n\t\t\tif (iter > CIPSO_V4_TAG_MAXCNT)\n\t\t\t\treturn -EINVAL;\n\t\t\tdoi_def->tags[iter++] = nla_get_u8(nla);\n\t\t}\n\tif (iter < CIPSO_V4_TAG_MAXCNT)\n\t\tdoi_def->tags[iter] = CIPSO_V4_TAG_INVALID;\n\treturn 0;\n}", "target": 1}
{"code": "int StreamInfoWrapper::luaDynamicMetadata(lua_State* state) {\n  if (dynamic_metadata_wrapper_.get() != nullptr) {\n    dynamic_metadata_wrapper_.pushStack();\n  } else {\n    dynamic_metadata_wrapper_.reset(DynamicMetadataMapWrapper::create(state, *this), true);\n  }\n  return 1;\n}", "target": 0}
{"code": "static void init_once(void *foo)\n{\n\tstruct ext4_inode_info *ei = (struct ext4_inode_info *) foo;\n\tINIT_LIST_HEAD(&ei->i_orphan);\n\tinit_rwsem(&ei->xattr_sem);\n\tinit_rwsem(&ei->i_data_sem);\n\tinit_rwsem(&ei->i_mmap_sem);\n\tinode_init_once(&ei->vfs_inode);\n}", "target": 0}
{"code": "int regset_tls_set(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count,\n\t\t   const void *kbuf, const void __user *ubuf)\n{\n\tstruct user_desc infobuf[GDT_ENTRY_TLS_ENTRIES];\n\tconst struct user_desc *info;\n\tint i;\n\tif (pos >= GDT_ENTRY_TLS_ENTRIES * sizeof(struct user_desc) ||\n\t    (pos % sizeof(struct user_desc)) != 0 ||\n\t    (count % sizeof(struct user_desc)) != 0)\n\t\treturn -EINVAL;\n\tif (kbuf)\n\t\tinfo = kbuf;\n\telse if (__copy_from_user(infobuf, ubuf, count))\n\t\treturn -EFAULT;\n\telse\n\t\tinfo = infobuf;\n\tfor (i = 0; i < count / sizeof(struct user_desc); i++)\n\t\tif (!tls_desc_okay(info + i))\n\t\t\treturn -EINVAL;\n\tset_tls_desc(target,\n\t\t     GDT_ENTRY_TLS_MIN + (pos / sizeof(struct user_desc)),\n\t\t     info, count / sizeof(struct user_desc));\n\treturn 0;\n}", "target": 0}
{"code": "RecordConvertRangesToIntervals(SetInfoPtr psi,\n                               xRecordRange * pRanges,\n                               int nRanges,\n                               int byteoffset,\n                               SetInfoPtr pExtSetInfo, int *pnExtSetInfo)\n{\n    int i;\n    CARD8 *pCARD8;\n    int first, last;\n    int err;\n    for (i = 0; i < nRanges; i++, pRanges++) {\n        pCARD8 = ((CARD8 *) pRanges) + byteoffset;\n        first = pCARD8[0];\n        last = pCARD8[1];\n        if (first || last) {\n            if (!psi->intervals) {\n                err = RecordAllocIntervals(psi, 2 * (nRanges - i));\n                if (err != Success)\n                    return err;\n            }\n            psi->intervals[psi->nintervals].first = first;\n            psi->intervals[psi->nintervals].last = last;\n            psi->nintervals++;\n            assert(psi->nintervals <= psi->size);\n            if (pExtSetInfo) {\n                SetInfoPtr pesi = pExtSetInfo;\n                CARD16 *pCARD16 = (CARD16 *) (pCARD8 + 2);\n                int j;\n                for (j = 0; j < *pnExtSetInfo; j++, pesi++) {\n                    if ((first == pesi->first) && (last == pesi->last))\n                        break;\n                }\n                if (j == *pnExtSetInfo) {\n                    err = RecordAllocIntervals(pesi, 2 * (nRanges - i));\n                    if (err != Success)\n                        return err;\n                    pesi->first = first;\n                    pesi->last = last;\n                    (*pnExtSetInfo)++;\n                }\n                pesi->intervals[pesi->nintervals].first = pCARD16[0];\n                pesi->intervals[pesi->nintervals].last = pCARD16[1];\n                pesi->nintervals++;\n                assert(pesi->nintervals <= pesi->size);\n            }\n        }\n    }\n    return Success;\n}                               ", "target": 0}
{"code": "grub_ext4_find_leaf (struct grub_ext2_data *data, char *buf,\n                     struct grub_ext4_extent_header *ext_block,\n                     grub_uint32_t fileblock)\n{\n  struct grub_ext4_extent_idx *index;\n  while (1)\n    {\n      int i;\n      grub_disk_addr_t block;\n      index = (struct grub_ext4_extent_idx *) (ext_block + 1);\n      if (grub_le_to_cpu16(ext_block->magic) != EXT4_EXT_MAGIC)\n        return 0;\n      if (ext_block->depth == 0)\n        return ext_block;\n      for (i = 0; i < grub_le_to_cpu16 (ext_block->entries); i++)\n        {\n          if (fileblock < grub_le_to_cpu32(index[i].block))\n            break;\n        }\n      if (--i < 0)\n        return 0;\n      block = grub_le_to_cpu16 (index[i].leaf_hi);\n      block = (block << 32) + grub_le_to_cpu32 (index[i].leaf);\n      if (grub_disk_read (data->disk,\n                          block << LOG2_EXT2_BLOCK_SIZE (data),\n                          0, EXT2_BLOCK_SIZE(data), buf))\n        return 0;\n      ext_block = (struct grub_ext4_extent_header *) buf;\n    }\n}", "target": 1}
{"code": "static int ext4_split_unwritten_extents(handle_t *handle,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\tstruct ext4_map_blocks *map,\n\t\t\t\t\tstruct ext4_ext_path *path,\n\t\t\t\t\tint flags)\n{\n\text4_lblk_t eof_block;\n\text4_lblk_t ee_block;\n\tstruct ext4_extent *ex;\n\tunsigned int ee_len;\n\tint split_flag = 0, depth;\n\text_debug(\"ext4_split_unwritten_extents: inode %lu, logical\"\n\t\t\"block %llu, max_blocks %u\\n\", inode->i_ino,\n\t\t(unsigned long long)map->m_lblk, map->m_len);\n\teof_block = (inode->i_size + inode->i_sb->s_blocksize - 1) >>\n\t\tinode->i_sb->s_blocksize_bits;\n\tif (eof_block < map->m_lblk + map->m_len)\n\t\teof_block = map->m_lblk + map->m_len;\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\tee_block = le32_to_cpu(ex->ee_block);\n\tee_len = ext4_ext_get_actual_len(ex);\n\tsplit_flag |= ee_block + ee_len <= eof_block ? EXT4_EXT_MAY_ZEROOUT : 0;\n\tsplit_flag |= EXT4_EXT_MARK_UNINIT2;\n\tif (flags & EXT4_GET_BLOCKS_CONVERT)\n\t\tsplit_flag |= EXT4_EXT_DATA_VALID2;\n\tflags |= EXT4_GET_BLOCKS_PRE_IO;\n\treturn ext4_split_extent(handle, inode, path, map, split_flag, flags);\n}", "target": 0}
{"code": "Status TensorSliceReader::GetTensor(\n    const string& name, std::unique_ptr<tensorflow::Tensor>* out_tensor) const {\n  DataType type;\n  TensorShape shape;\n  TensorSlice slice;\n  {\n    mutex_lock l(mu_);\n    const TensorSliceSet* tss = gtl::FindPtrOrNull(tensors_, name);\n    if (tss == nullptr) {\n      return errors::NotFound(name, \" not found in checkpoint file\");\n    }\n    if (tss->Slices().size() > 1) {\n      return errors::Unimplemented(\"Sliced checkpoints are not supported\");\n    }\n    type = tss->type();\n    shape = tss->shape();\n    slice = tss->Slices().begin()->second.slice;\n  }\n  std::unique_ptr<tensorflow::Tensor> t(new tensorflow::Tensor(type, shape));\n  bool success = false;\n#define READER_COPY(dt)                                                  \\\n  case dt:                                                               \\\n    success = CopySliceData(name, slice,                                 \\\n                            t->flat<EnumToDataType<dt>::Type>().data()); \\\n    break;\n  switch (type) {\n    READER_COPY(DT_FLOAT);\n    READER_COPY(DT_DOUBLE);\n    READER_COPY(DT_INT32);\n    READER_COPY(DT_UINT8);\n    READER_COPY(DT_INT16);\n    READER_COPY(DT_INT8);\n    READER_COPY(DT_INT64);\n    READER_COPY(DT_STRING);\n    default:\n      return errors::Unimplemented(\"Data type not supported\");\n  }\n#undef READER_COPY\n  if (!success) {\n    return errors::NotFound(name, \" not found in checkpoint file\");\n  }\n  std::swap(*out_tensor, t);\n  return Status::OK();\n}", "target": 1}
{"code": "int tls_free_buffers(OSSL_RECORD_LAYER *rl)\n{\n    if (rl->direction == OSSL_RECORD_DIRECTION_WRITE) {\n        if (rl->nextwbuf < rl->numwpipes) {\n            if (rl->nextwbuf != 0\n                    || rl->numwpipes != 1\n                    || TLS_BUFFER_get_left(&rl->wbuf[0]) != 0)\n                return 0;\n        }\n        tls_release_write_buffer(rl);\n        return 1;\n    }\n    if (rl->curr_rec < rl->num_recs || TLS_BUFFER_get_left(&rl->rbuf) != 0)\n        return 0;\n    return tls_release_read_buffer(rl);\n}", "target": 1}
{"code": "exif_data_load_data_entry (ExifData *data, ExifEntry *entry,\n\t\t\t   const unsigned char *d,\n\t\t\t   unsigned int size, unsigned int offset)\n{\n\tunsigned int s, doff;\n\tentry->tag        = exif_get_short (d + offset + 0, data->priv->order);\n\tentry->format     = exif_get_short (d + offset + 2, data->priv->order);\n\tentry->components = exif_get_long  (d + offset + 4, data->priv->order);\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t  \"Loading entry 0x%x ('%s')...\", entry->tag,\n\t\t  exif_tag_get_name (entry->tag));\n\ts = exif_format_get_size(entry->format) * entry->components;\n\tif ((s < entry->components) || (s == 0)){\n\t\treturn 0;\n\t}\n\tif (s > 4)\n\t\tdoff = exif_get_long (d + offset + 8, data->priv->order);\n\telse\n\t\tdoff = offset + 8;\n\tif ((doff + s < doff) || (doff + s < s) || (doff + s > size)) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t  \"Tag data past end of buffer (%u > %u)\", doff+s, size);\t\n\t\treturn 0;\n\t}\n\tentry->data = exif_data_alloc (data, s);\n\tif (entry->data) {\n\t\tentry->size = s;\n\t\tmemcpy (entry->data, d + doff, s);\n\t} else {\n\t\tEXIF_LOG_NO_MEMORY(data->priv->log, \"ExifData\", s);\n\t\treturn 0;\n\t}\n\tif (entry->tag == EXIF_TAG_MAKER_NOTE) {\n\t\tif (!entry->data) {\n\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t\t  \"MakerNote found with empty data\");\t\n\t\t} else if (entry->size > 6) {\n\t\t\texif_log (data->priv->log,\n\t\t\t\t\t       EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t\t       \"MakerNote found (%02x %02x %02x %02x \"\n\t\t\t\t\t       \"%02x %02x %02x...).\",\n\t\t\t\t\t       entry->data[0], entry->data[1], entry->data[2],\n\t\t\t\t\t       entry->data[3], entry->data[4], entry->data[5],\n\t\t\t\t\t       entry->data[6]);\n\t\t}\n\t\tdata->priv->offset_mnote = doff;\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "static inline void tlb_end_vma(struct mmu_gather *tlb, struct vm_area_struct *vma)\n{\n\tif (tlb->fullmm || IS_ENABLED(CONFIG_MMU_GATHER_MERGE_VMAS))\n\t\treturn;\n\ttlb_flush_mmu_tlbonly(tlb);\n}", "target": 1}
{"code": "static int smm_place_entry_code(uintptr_t smbase, unsigned int num_cpus,\n\t\t\t\tunsigned int stack_top, const struct smm_loader_params *params)\n{\n\tunsigned int i;\n\tunsigned int size;\n\tif (smm_create_map(smbase, num_cpus, params)) {\n\t\tif (cpus[num_cpus].active) {\n\t\t\tif (cpus[num_cpus - 1].smbase +\n\t\t\t\tparams->smm_main_entry_offset < stack_top) {\n\t\t\t\tprintk(BIOS_ERR, \"%s: stack encroachment\\n\", __func__);\n\t\t\t\tprintk(BIOS_ERR, \"%s: smbase %zx, stack_top %x\\n\",\n\t\t\t\t\t__func__, cpus[num_cpus].smbase, stack_top);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tprintk(BIOS_ERR, \"%s: unable to place smm entry code\\n\", __func__);\n\t\treturn 0;\n\t}\n\tprintk(BIOS_INFO, \"%s: smbase %zx, stack_top %x\\n\",\n\t\t__func__, cpus[num_cpus-1].smbase, stack_top);\n\tsize = cpus[0].code_end - cpus[0].code_start;\n\tfor (i = 1; i < num_cpus; i++) {\n\t\tmemcpy((int *)cpus[i].code_start, (int *)cpus[0].code_start, size);\n\t\tprintk(BIOS_DEBUG,\n\t\t\t\"SMM Module: placing smm entry code at %zx,  cpu # 0x%x\\n\",\n\t\t\tcpus[i].code_start, i);\n\t\tprintk(BIOS_DEBUG, \"%s: copying from %zx to %zx 0x%x bytes\\n\",\n\t\t\t__func__, cpus[0].code_start, cpus[i].code_start, size);\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "static void cmd_sdbk(Sdb *db, const char *input) {\n\tchar *out = (input[0] == ' ')\n\t\t? sdb_querys (db, NULL, 0, input + 1)\n\t\t: sdb_querys (db, NULL, 0, \"*\");\n\tif (out) {\n\t\tr_cons_println (out);\n\t\tfree (out);\n\t} else {\n\t\tR_LOG_ERROR (\"Usage: ask [query]\");\n\t}\n}", "target": 1}
{"code": "xfs_ip2xflags(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_icdinode\t*dic = &ip->i_d;\n\treturn _xfs_dic2xflags(dic->di_flags, dic->di_flags2, XFS_IFORK_Q(ip));\n}", "target": 0}
{"code": "static GF_Err BM_ParseGlobalQuantizer(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tGF_Node *node;\n\tGF_Command *com;\n\tGF_CommandField *inf;\n\tnode = gf_bifs_dec_node(codec, bs, NDT_SFWorldNode);\n\tif (!node) return GF_NON_COMPLIANT_BITSTREAM;\n\tif (codec->scenegraph->global_qp) {\n\t\tgf_node_unregister(codec->scenegraph->global_qp, NULL);\n\t}\n\tcodec->ActiveQP = NULL;\n\tcodec->scenegraph->global_qp = NULL;\n\tif (gf_node_get_tag(node) != TAG_MPEG4_QuantizationParameter) {\n\t\tgf_node_unregister(node, NULL);\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tcodec->ActiveQP = (M_QuantizationParameter *) node;\n\tcodec->ActiveQP->isLocal = 0;\n\tcodec->scenegraph->global_qp = node;\n\tnode->sgprivate->num_instances = 2;\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_GLOBAL_QUANTIZER);\n\tinf = gf_sg_command_field_new(com);\n\tinf->new_node = node;\n\tinf->field_ptr = &inf->new_node;\n\tinf->fieldType = GF_SG_VRML_SFNODE;\n\tgf_list_add(com_list, com);\n\treturn GF_OK;\n}", "target": 1}
{"code": "static bool new_idmap_permitted(struct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *new_map)\n{\n\tif ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1)) {\n\t\tu32 id = new_map->extent[0].lower_first;\n\t\tif (cap_setid == CAP_SETUID) {\n\t\t\tkuid_t uid = make_kuid(ns->parent, id);\n\t\t\tif (uid_eq(uid, current_fsuid()))\n\t\t\t\treturn true;\n\t\t}\n\t\telse if (cap_setid == CAP_SETGID) {\n\t\t\tkgid_t gid = make_kgid(ns->parent, id);\n\t\t\tif (gid_eq(gid, current_fsgid()))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\tif (!cap_valid(cap_setid))\n\t\treturn true;\n\tif (ns_capable(ns->parent, cap_setid))\n\t\treturn true;\n\treturn false;\n}", "target": 1}
{"code": "int ipfilter(struct pico_frame *f)\n{\n    struct filter_node temp;\n    struct pico_ipv4_hdr *ipv4_hdr = (struct pico_ipv4_hdr *) f->net_hdr;\n    struct pico_trans *trans;\n    struct pico_icmp4_hdr *icmp_hdr;\n    memset(&temp, 0u, sizeof(struct filter_node));\n    temp.fdev = f->dev;\n    temp.out_addr = ipv4_hdr->dst.addr;\n    temp.in_addr = ipv4_hdr->src.addr;\n    if ((ipv4_hdr->proto == PICO_PROTO_TCP) || (ipv4_hdr->proto == PICO_PROTO_UDP)) {\n        trans = (struct pico_trans *) f->transport_hdr;\n        temp.out_port = short_be(trans->dport);\n        temp.in_port = short_be(trans->sport);\n    }\n    else if(ipv4_hdr->proto == PICO_PROTO_ICMP4) {\n        icmp_hdr = (struct pico_icmp4_hdr *) f->transport_hdr;\n        if(icmp_hdr->type == PICO_ICMP_UNREACH && icmp_hdr->code == PICO_ICMP_UNREACH_FILTER_PROHIB)\n            return 0;\n    }\n    temp.proto = ipv4_hdr->proto;\n    temp.priority = f->priority;\n    temp.tos = ipv4_hdr->tos;\n    return ipfilter_apply_filter(f, &temp);\n}", "target": 1}
{"code": "static pj_status_t get_name(int rec_counter, const pj_uint8_t *pkt, \n                            const pj_uint8_t *start, const pj_uint8_t *max,\n                            pj_str_t *name)\n{\n    const pj_uint8_t *p;\n    pj_status_t status;\n    if (rec_counter > 10) {\n        return PJLIB_UTIL_EDNSINNAMEPTR;\n    }\n    if (start >= max)\n        return PJLIB_UTIL_EDNSINNAMEPTR;\n    p = start;\n    while (*p) {\n        if ((*p & 0xc0) == 0xc0) {\n            pj_uint16_t offset;\n            pj_memcpy(&offset, p, 2);\n            offset ^= pj_htons((pj_uint16_t)(0xc0 << 8));\n            offset = pj_ntohs(offset);\n            if (offset >= max - pkt)\n                return PJLIB_UTIL_EDNSINNAMEPTR;\n            status = get_name(rec_counter+1, pkt, pkt + offset, max, name);\n            if (status != PJ_SUCCESS)\n                return status;\n            return PJ_SUCCESS;\n        } else {\n            unsigned label_len = *p;\n            if (p+1+label_len+1 > max)\n                return PJLIB_UTIL_EDNSINNAMEPTR;\n            pj_memcpy(name->ptr + name->slen, p+1, label_len);\n            name->slen += label_len;\n            p += label_len + 1;\n            if (*p != 0) {\n                *(name->ptr + name->slen) = '.';\n                ++name->slen;\n            }\n        }\n    }\n    return PJ_SUCCESS;\n}", "target": 0}
{"code": "table_regex_match(const char *string, const char *pattern)\n{\n\tregex_t preg;\n\tint\tcflags = REG_EXTENDED|REG_NOSUB;\n\tif (strncmp(pattern, \"(?i)\", 4) == 0) {\n\t\tcflags |= REG_ICASE;\n\t\tpattern += 4;\n\t}\n\tif (regcomp(&preg, pattern, cflags) != 0)\n\t\treturn (0);\n\tif (regexec(&preg, string, 0, NULL, 0) != 0)\n\t\treturn (0);\n\treturn (1);\n}", "target": 1}
{"code": "static int region_list_contains_offset(struct fdt_region_state *info,\n\t\t\t\t       const void *fdt, int target)\n{\n\tstruct fdt_region *reg;\n\tint num;\n\ttarget += fdt_off_dt_struct(fdt);\n\tfor (reg = info->region, num = 0; num < info->count; reg++, num++) {\n\t\tif (target >= reg->offset && target < reg->offset + reg->size)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "struct page *alloc_huge_page_nodemask(struct hstate *h, int preferred_nid,\n\t\tnodemask_t *nmask, gfp_t gfp_mask)\n{\n\tspin_lock_irq(&hugetlb_lock);\n\tif (h->free_huge_pages - h->resv_huge_pages > 0) {\n\t\tstruct page *page;\n\t\tpage = dequeue_huge_page_nodemask(h, gfp_mask, preferred_nid, nmask);\n\t\tif (page) {\n\t\t\tspin_unlock_irq(&hugetlb_lock);\n\t\t\treturn page;\n\t\t}\n\t}\n\tspin_unlock_irq(&hugetlb_lock);\n\treturn alloc_migrate_huge_page(h, gfp_mask, preferred_nid, nmask);\n}", "target": 0}
{"code": "static int mpls_dev_sysctl_register(struct net_device *dev,\n\t\t\t\t    struct mpls_dev *mdev)\n{\n\tchar path[sizeof(\"net/mpls/conf/\") + IFNAMSIZ];\n\tstruct net *net = dev_net(dev);\n\tstruct ctl_table *table;\n\tint i;\n\ttable = kmemdup(&mpls_dev_table, sizeof(mpls_dev_table), GFP_KERNEL);\n\tif (!table)\n\t\tgoto out;\n\tfor (i = 0; i < ARRAY_SIZE(mpls_dev_table); i++) {\n\t\ttable[i].data = (char *)mdev + (uintptr_t)table[i].data;\n\t\ttable[i].extra1 = mdev;\n\t\ttable[i].extra2 = net;\n\t}\n\tsnprintf(path, sizeof(path), \"net/mpls/conf/%s\", dev->name);\n\tmdev->sysctl = register_net_sysctl(net, path, table);\n\tif (!mdev->sysctl)\n\t\tgoto free;\n\tmpls_netconf_notify_devconf(net, RTM_NEWNETCONF, NETCONFA_ALL, mdev);\n\treturn 0;\nfree:\n\tkfree(table);\nout:\n\tmdev->sysctl = NULL;\n\treturn -ENOBUFS;\n}", "target": 0}
{"code": "SYSCALL_DEFINE1(inotify_init1, int, flags)\n{\n\tstruct fsnotify_group *group;\n\tint ret;\n\tBUILD_BUG_ON(IN_CLOEXEC != O_CLOEXEC);\n\tBUILD_BUG_ON(IN_NONBLOCK != O_NONBLOCK);\n\tif (flags & ~(IN_CLOEXEC | IN_NONBLOCK))\n\t\treturn -EINVAL;\n\tgroup = inotify_new_group(inotify_max_queued_events);\n\tif (IS_ERR(group))\n\t\treturn PTR_ERR(group);\n\tret = anon_inode_getfd(\"inotify\", &inotify_fops, group,\n\t\t\t\t  O_RDONLY | flags);\n\tif (ret < 0)\n\t\tfsnotify_put_group(group);\n\treturn ret;\n}", "target": 0}
{"code": "static int __init mb2cache_init(void)\n{\n\tmb2_entry_cache = kmem_cache_create(\"mbcache\",\n\t\t\t\tsizeof(struct mb2_cache_entry), 0,\n\t\t\t\tSLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD, NULL);\n\tBUG_ON(!mb2_entry_cache);\n\treturn 0;\n}", "target": 0}
{"code": "static int pdf_findobj(struct pdf_struct *pdf)\n{\n    const char *start, *q, *q2, *q3, *eof;\n    struct pdf_obj *obj;\n    off_t bytesleft;\n    unsigned genid, objid;\n    pdf->nobjs++;\n    pdf->objs = cli_realloc2(pdf->objs, sizeof(*pdf->objs)*pdf->nobjs);\n    if (!pdf->objs) {\n\tcli_warnmsg(\"cli_pdf: out of memory parsing objects (%u)\\n\", pdf->nobjs);\n\treturn -1;\n    }\n    obj = &pdf->objs[pdf->nobjs-1];\n    memset(obj, 0, sizeof(*obj));\n    start = pdf->map+pdf->offset;\n    bytesleft = pdf->size - pdf->offset;\n    q2 = cli_memstr(start, bytesleft, \" obj\", 4);\n    if (!q2)\n\treturn 0;\n    bytesleft -= q2 - start;\n    q = findNextNonWSBack(q2-1, start);\n    while (q > start && isdigit(*q)) { q--; }\n    genid = atoi(q);\n    q = findNextNonWSBack(q-1,start);\n    while (q > start && isdigit(*q)) { q--; }\n    objid = atoi(q);\n    obj->id = (objid << 8) | (genid&0xff);\n    obj->start = q2+4 - pdf->map;\n    obj->flags = 0;\n    bytesleft -= 4;\n    eof = pdf->map + pdf->size;\n    q = pdf->map + obj->start;\n    while (q < eof && bytesleft > 0) {\n\toff_t p_stream, p_endstream;\n\tq2 = pdf_nextobject(q, bytesleft);\n\tif (!q2)\n\t    return 0;\n\tbytesleft -= q2 - q;\n\tif (find_stream_bounds(q-1, q2-q, bytesleft + (q2-q), &p_stream, &p_endstream)) {\n\t    obj->flags |= 1 << OBJ_STREAM;\n\t    q2 = q-1 + p_endstream + 6;\n\t    bytesleft -= q2 - q + 1;\n\t} else if ((q3 = cli_memstr(q-1, q2-q+1, \"endobj\", 6))) {\n\t    q2 = q3 + 6;\n\t    pdf->offset = q2 - pdf->map;\n\t    return 1; \n\t} else {\n\t    q2++;\n\t}\n\tq = q2;\n    }\n    return 0;\n}", "target": 0}
{"code": "ExprResolveBoolean(struct xkb_context *ctx, const ExprDef *expr,\n                   bool *set_rtrn)\n{\n    bool ok = false;\n    const char *ident;\n    switch (expr->expr.op) {\n    case EXPR_VALUE:\n        if (expr->expr.value_type != EXPR_TYPE_BOOLEAN) {\n            log_err(ctx,\n                    \"Found constant of type %s where boolean was expected\\n\",\n                    expr_value_type_to_string(expr->expr.value_type));\n            return false;\n        }\n        *set_rtrn = expr->boolean.set;\n        return true;\n    case EXPR_IDENT:\n        ident = xkb_atom_text(ctx, expr->ident.ident);\n        if (ident) {\n            if (istreq(ident, \"true\") ||\n                istreq(ident, \"yes\") ||\n                istreq(ident, \"on\")) {\n                *set_rtrn = true;\n                return true;\n            }\n            else if (istreq(ident, \"false\") ||\n                     istreq(ident, \"no\") ||\n                     istreq(ident, \"off\")) {\n                *set_rtrn = false;\n                return true;\n            }\n        }\n        log_err(ctx, \"Identifier \\\"%s\\\" of type boolean is unknown\\n\", ident);\n        return false;\n    case EXPR_FIELD_REF:\n        log_err(ctx, \"Default \\\"%s.%s\\\" of type boolean is unknown\\n\",\n                xkb_atom_text(ctx, expr->field_ref.element),\n                xkb_atom_text(ctx, expr->field_ref.field));\n        return false;\n    case EXPR_INVERT:\n    case EXPR_NOT:\n        ok = ExprResolveBoolean(ctx, expr, set_rtrn);\n        if (ok)\n            *set_rtrn = !*set_rtrn;\n        return ok;\n    case EXPR_ADD:\n    case EXPR_SUBTRACT:\n    case EXPR_MULTIPLY:\n    case EXPR_DIVIDE:\n    case EXPR_ASSIGN:\n    case EXPR_NEGATE:\n    case EXPR_UNARY_PLUS:\n        log_err(ctx, \"%s of boolean values not permitted\\n\",\n                expr_op_type_to_string(expr->expr.op));\n        break;\n    default:\n        log_wsgo(ctx, \"Unknown operator %d in ResolveBoolean\\n\",\n                 expr->expr.op);\n        break;\n    }\n    return false;\n}", "target": 1}
{"code": "cmd_len(conn c)\n{\n    return scan_line_end(c->cmd, c->cmd_read);\n}", "target": 0}
{"code": "    uint64_t Image::byteSwap(uint64_t value,bool bSwap) const\n    {\n        uint64_t result = 0;\n        byte* source_value = reinterpret_cast<byte *>(&value);\n        byte* destination_value = reinterpret_cast<byte *>(&result);\n        for (int i = 0; i < 8; i++)\n            destination_value[i] = source_value[8 - i - 1];\n        return bSwap ? result : value;\n    }", "target": 0}
{"code": "gsm_xsmp_client_disconnect (GsmXSMPClient *client)\n{\n        if (client->priv->watch_id > 0) {\n                g_source_remove (client->priv->watch_id);\n        }\n        if (client->priv->conn != NULL) {\n                SmsCleanUp (client->priv->conn);\n        }\n        if (client->priv->ice_connection != NULL) {\n                IceSetShutdownNegotiation (client->priv->ice_connection, FALSE);\n                IceCloseConnection (client->priv->ice_connection);\n        }\n        if (client->priv->protocol_timeout > 0) {\n                g_source_remove (client->priv->protocol_timeout);\n        }\n}", "target": 1}
{"code": "int btrfs_create_uuid_tree(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\tstruct btrfs_root *uuid_root;\n\tstruct task_struct *task;\n\tint ret;\n\ttrans = btrfs_start_transaction(tree_root, 2);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\tuuid_root = btrfs_create_tree(trans, fs_info,\n\t\t\t\t      BTRFS_UUID_TREE_OBJECTID);\n\tif (IS_ERR(uuid_root)) {\n\t\tret = PTR_ERR(uuid_root);\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tbtrfs_end_transaction(trans);\n\t\treturn ret;\n\t}\n\tfs_info->uuid_root = uuid_root;\n\tret = btrfs_commit_transaction(trans);\n\tif (ret)\n\t\treturn ret;\n\tdown(&fs_info->uuid_tree_rescan_sem);\n\ttask = kthread_run(btrfs_uuid_scan_kthread, fs_info, \"btrfs-uuid\");\n\tif (IS_ERR(task)) {\n\t\tbtrfs_warn(fs_info, \"failed to start uuid_scan task\");\n\t\tup(&fs_info->uuid_tree_rescan_sem);\n\t\treturn PTR_ERR(task);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "int btrfs_init_dev_stats(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_root *dev_root = fs_info->dev_root;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tint ret = 0;\n\tstruct btrfs_device *device;\n\tstruct btrfs_path *path = NULL;\n\tint i;\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tlist_for_each_entry(device, &fs_devices->devices, dev_list) {\n\t\tint item_size;\n\t\tstruct btrfs_dev_stats_item *ptr;\n\t\tkey.objectid = BTRFS_DEV_STATS_OBJECTID;\n\t\tkey.type = BTRFS_PERSISTENT_ITEM_KEY;\n\t\tkey.offset = device->devid;\n\t\tret = btrfs_search_slot(NULL, dev_root, &key, path, 0, 0);\n\t\tif (ret) {\n\t\t\t__btrfs_reset_dev_stats(device);\n\t\t\tdevice->dev_stats_valid = 1;\n\t\t\tbtrfs_release_path(path);\n\t\t\tcontinue;\n\t\t}\n\t\tslot = path->slots[0];\n\t\teb = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\t\titem_size = btrfs_item_size_nr(eb, slot);\n\t\tptr = btrfs_item_ptr(eb, slot,\n\t\t\t\t     struct btrfs_dev_stats_item);\n\t\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++) {\n\t\t\tif (item_size >= (1 + i) * sizeof(__le64))\n\t\t\t\tbtrfs_dev_stat_set(device, i,\n\t\t\t\t\tbtrfs_dev_stats_value(eb, ptr, i));\n\t\t\telse\n\t\t\t\tbtrfs_dev_stat_reset(device, i);\n\t\t}\n\t\tdevice->dev_stats_valid = 1;\n\t\tbtrfs_dev_stat_print_on_load(device);\n\t\tbtrfs_release_path(path);\n\t}\n\tmutex_unlock(&fs_devices->device_list_mutex);\nout:\n\tbtrfs_free_path(path);\n\treturn ret < 0 ? ret : 0;\n}", "target": 0}
{"code": "static inline void skb_mac_header_rebuild(struct sk_buff *skb)\n{\n\tif (skb_mac_header_was_set(skb)) {\n\t\tconst unsigned char *old_mac = skb_mac_header(skb);\n\t\tskb_set_mac_header(skb, -skb->mac_len);\n\t\tmemmove(skb_mac_header(skb), old_mac, skb->mac_len);\n\t}\n}", "target": 0}
{"code": "        bool operator==(const Key& key) const\n        {\n            return    key.tag_ == tag_\n                   && 0 == strncmp(key.ver_, ver_, strlen(ver_))\n                   && (size_ == 0 || key.size_ == size_);\n        }", "target": 0}
{"code": "const FunctionDef* FunctionLibraryDefinition::GetAttrImpl(\n    const NodeDef& ndef) const {\n  if (ndef.op() != kGradientOp) {\n    return Find(ndef.op());\n  }\n  const NameAttrList* forward_func_attrs;\n  if (!TryGetNodeAttr(ndef, kFuncAttr, &forward_func_attrs)) {\n    return nullptr;\n  }\n  const string& func_name = forward_func_attrs->name();\n  {\n    tf_shared_lock l(mu_);\n    const string& grad_name = FindGradientHelper(func_name);\n    if (!grad_name.empty()) {\n      if (const auto helper = FindHelper(grad_name)) {\n        return &(helper->fdef);\n      } else {\n        return nullptr;\n      }\n    }\n    if (const auto helper = FindHelper(func_name)) {\n      return &(helper->fdef);\n    } else {\n      return nullptr;\n    }\n  }\n}", "target": 0}
{"code": "MONGO_EXPORT int bson_iterator_int( const bson_iterator *i ) {\n    switch ( bson_iterator_type( i ) ) {\n    case BSON_INT:\n        return bson_iterator_int_raw( i );\n    case BSON_LONG:\n        return bson_iterator_long_raw( i );\n    case BSON_DOUBLE:\n        return bson_iterator_double_raw( i );\n    default:\n        return 0;\n    }\n}", "target": 1}
{"code": "static void my_free(void *ptr)\n{\n    free_called += 1;\n    free(ptr);\n}", "target": 1}
{"code": "static char *get_netscape_format(const struct Cookie *co)\n{\n  return aprintf(\n    \"%s\"     \n    \"%s%s\\t\" \n    \"%s\\t\"   \n    \"%s\\t\"   \n    \"%s\\t\"   \n    \"%\" FORMAT_OFF_T \"\\t\"   \n    \"%s\\t\"   \n    \"%s\",    \n    co->httponly?\"#HttpOnly_\":\"\",\n    (co->tailmatch && co->domain && co->domain[0] != '.')? \".\":\"\",\n    co->domain?co->domain:\"unknown\",\n    co->tailmatch?\"TRUE\":\"FALSE\",\n    co->path?co->path:\"/\",\n    co->secure?\"TRUE\":\"FALSE\",\n    co->expires,\n    co->name,\n    co->value?co->value:\"\");\n}", "target": 0}
{"code": "char *redisProtocolToLuaType_Aggregate(lua_State *lua, char *reply, int atype) {\n    char *p = strchr(reply+1,'\\r');\n    long long mbulklen;\n    int j = 0;\n    string2ll(reply+1,p-reply-1,&mbulklen);\n    if (server.lua_client->resp == 2 || atype == '*') {\n        p += 2;\n        if (mbulklen == -1) {\n            lua_pushboolean(lua,0);\n            return p;\n        }\n        lua_newtable(lua);\n        for (j = 0; j < mbulklen; j++) {\n            lua_pushnumber(lua,j+1);\n            p = redisProtocolToLuaType(lua,p);\n            lua_settable(lua,-3);\n        }\n    } else if (server.lua_client->resp == 3) {\n        p += 2;\n        lua_newtable(lua);\n        lua_pushstring(lua,atype == '%' ? \"map\" : \"set\");\n        lua_newtable(lua);\n        for (j = 0; j < mbulklen; j++) {\n            p = redisProtocolToLuaType(lua,p);\n            if (atype == '%') {\n                p = redisProtocolToLuaType(lua,p);\n            } else {\n                if (!lua_checkstack(lua, 1)) {\n                    serverPanic(\"lua stack limit reach when parsing redis.call reply\");\n                }\n                lua_pushboolean(lua,1);\n            }\n            lua_settable(lua,-3);\n        }\n        lua_settable(lua,-3);\n    }\n    return p;\n}", "target": 0}
{"code": "static int __net_init sctp_ctrlsock_init(struct net *net)\n{\n\tint status;\n\tstatus = sctp_ctl_sock_init(net);\n\tif (status)\n\t\tpr_err(\"Failed to initialize the SCTP control sock\\n\");\n\treturn status;\n}", "target": 0}
{"code": "int xt_compat_check_entry_offsets(const void *base,\n\t\t\t\t  unsigned int target_offset,\n\t\t\t\t  unsigned int next_offset)\n{\n\tconst struct compat_xt_entry_target *t;\n\tconst char *e = base;\n\tif (target_offset + sizeof(*t) > next_offset)\n\t\treturn -EINVAL;\n\tt = (void *)(e + target_offset);\n\tif (t->u.target_size < sizeof(*t))\n\t\treturn -EINVAL;\n\tif (target_offset + t->u.target_size > next_offset)\n\t\treturn -EINVAL;\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) == 0 &&\n\t    target_offset + sizeof(struct compat_xt_standard_target) != next_offset)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 1}
{"code": "void PrivateThreadPoolDatasetOp::MakeDatasetFromOptions(OpKernelContext* ctx,\n                                                        DatasetBase* input,\n                                                        int32_t num_threads,\n                                                        DatasetBase** output) {\n  OP_REQUIRES(ctx, num_threads >= 0,\n              errors::InvalidArgument(\"`num_threads` must be >= 0\"));\n  *output = new Dataset(ctx,\n                        DatasetContext(DatasetContext::Params(\n                            {PrivateThreadPoolDatasetOp::kDatasetType,\n                             PrivateThreadPoolDatasetOp::kDatasetOp})),\n                        input, num_threads);\n}", "target": 1}
{"code": "static int hci_sock_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t       char __user *optval, int __user *optlen)\n{\n\tstruct hci_ufilter uf;\n\tstruct sock *sk = sock->sk;\n\tint len, opt, err = 0;\n\tBT_DBG(\"sk %p, opt %d\", sk, optname);\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tlock_sock(sk);\n\tif (hci_pi(sk)->channel != HCI_CHANNEL_RAW) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\tswitch (optname) {\n\tcase HCI_DATA_DIR:\n\t\tif (hci_pi(sk)->cmsg_mask & HCI_CMSG_DIR)\n\t\t\topt = 1;\n\t\telse\n\t\t\topt = 0;\n\t\tif (put_user(opt, optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase HCI_TIME_STAMP:\n\t\tif (hci_pi(sk)->cmsg_mask & HCI_CMSG_TSTAMP)\n\t\t\topt = 1;\n\t\telse\n\t\t\topt = 0;\n\t\tif (put_user(opt, optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase HCI_FILTER:\n\t\t{\n\t\t\tstruct hci_filter *f = &hci_pi(sk)->filter;\n\t\t\tmemset(&uf, 0, sizeof(uf));\n\t\t\tuf.type_mask = f->type_mask;\n\t\t\tuf.opcode    = f->opcode;\n\t\t\tuf.event_mask[0] = *((u32 *) f->event_mask + 0);\n\t\t\tuf.event_mask[1] = *((u32 *) f->event_mask + 1);\n\t\t}\n\t\tlen = min_t(unsigned int, len, sizeof(uf));\n\t\tif (copy_to_user(optval, &uf, len))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\ndone:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "comics_remove_dir (gchar *path_name) \n{\n\tGDir  *content_dir;\n\tconst gchar *filename;\n\tgchar *filename_with_path;\n\tif (g_file_test (path_name, G_FILE_TEST_IS_DIR)) {\n\t\tcontent_dir = g_dir_open  (path_name, 0, NULL);\n\t\tfilename  = g_dir_read_name (content_dir);\n\t\twhile (filename) {\n\t\t\tfilename_with_path = \n\t\t\t\tg_build_filename (path_name, \n\t\t\t\t\t\t  filename, NULL);\n\t\t\tcomics_remove_dir (filename_with_path);\n\t\t\tg_free (filename_with_path);\n\t\t\tfilename = g_dir_read_name (content_dir);\n\t\t}\n\t\tg_dir_close (content_dir);\n\t}\n\treturn (g_remove (path_name));\n}", "target": 0}
{"code": "static inline void sem_unlock(struct sem_array *sma, int locknum)\n{\n\tif (locknum == -1) {\n\t\tspin_unlock(&sma->sem_perm.lock);\n\t} else {\n\t\tstruct sem *sem = sma->sem_base + locknum;\n\t\tspin_unlock(&sem->lock);\n\t}\n\trcu_read_unlock();\n}", "target": 0}
{"code": "static int srpt_rx_mgmt_fn_tag(struct srpt_send_ioctx *ioctx, u64 tag)\n{\n\tstruct srpt_device *sdev;\n\tstruct srpt_rdma_ch *ch;\n\tstruct srpt_send_ioctx *target;\n\tint ret, i;\n\tret = -EINVAL;\n\tch = ioctx->ch;\n\tBUG_ON(!ch);\n\tBUG_ON(!ch->sport);\n\tsdev = ch->sport->sdev;\n\tBUG_ON(!sdev);\n\tspin_lock_irq(&sdev->spinlock);\n\tfor (i = 0; i < ch->rq_size; ++i) {\n\t\ttarget = ch->ioctx_ring[i];\n\t\tif (target->cmd.se_lun == ioctx->cmd.se_lun &&\n\t\t    target->cmd.tag == tag &&\n\t\t    srpt_get_cmd_state(target) != SRPT_STATE_DONE) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irq(&sdev->spinlock);\n\treturn ret;\n}", "target": 1}
{"code": "int X509_REQ_add1_attr_by_OBJ(X509_REQ *req,\n                              const ASN1_OBJECT *obj, int type,\n                              const unsigned char *bytes, int len)\n{\n    if (X509at_add1_attr_by_OBJ(&req->req_info->attributes, obj,\n                                type, bytes, len))\n        return 1;\n    return 0;\n}", "target": 0}
{"code": "struct sock *dccp_v4_request_recv_sock(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t       struct request_sock *req,\n\t\t\t\t       struct dst_entry *dst)\n{\n\tstruct inet_request_sock *ireq;\n\tstruct inet_sock *newinet;\n\tstruct sock *newsk;\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto exit_overflow;\n\tif (dst == NULL && (dst = inet_csk_route_req(sk, req)) == NULL)\n\t\tgoto exit;\n\tnewsk = dccp_create_openreq_child(sk, req, skb);\n\tif (newsk == NULL)\n\t\tgoto exit_nonewsk;\n\tsk_setup_caps(newsk, dst);\n\tnewinet\t\t   = inet_sk(newsk);\n\tireq\t\t   = inet_rsk(req);\n\tnewinet->inet_daddr\t= ireq->rmt_addr;\n\tnewinet->inet_rcv_saddr = ireq->loc_addr;\n\tnewinet->inet_saddr\t= ireq->loc_addr;\n\tnewinet->opt\t   = ireq->opt;\n\tireq->opt\t   = NULL;\n\tnewinet->mc_index  = inet_iif(skb);\n\tnewinet->mc_ttl\t   = ip_hdr(skb)->ttl;\n\tnewinet->inet_id   = jiffies;\n\tdccp_sync_mss(newsk, dst_mtu(dst));\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tsock_put(newsk);\n\t\tgoto exit;\n\t}\n\t__inet_hash_nolisten(newsk, NULL);\n\treturn newsk;\nexit_overflow:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nexit_nonewsk:\n\tdst_release(dst);\nexit:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn NULL;\n}", "target": 1}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n  TFLITE_DCHECK(node->builtin_data != nullptr);\n  OpData* data = static_cast<OpData*>(node->user_data);\n  auto* params = reinterpret_cast<TfLiteSubParams*>(node->builtin_data);\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  TF_LITE_ENSURE(context, input1 != nullptr);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TF_LITE_ENSURE(context, input2 != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n  TF_LITE_ENSURE_STATUS(\n      CalculateOpData(context, params, input1, input2, output, data));\n  return kTfLiteOk;\n}", "target": 0}
{"code": "int ecall_answer(struct ecall *ecall, enum icall_call_type call_type,\n\t\t bool audio_cbr)\n{\n\tint err = 0;\n\tif (!ecall)\n\t\treturn EINVAL;\n#ifdef ECALL_CBR_ALWAYS_ON\n\taudio_cbr = true;\n#endif\n\tinfo(\"ecall(%p): answer on pending econn %p call_type=%d\\n\", ecall, ecall->econn, call_type);\n\tif (!ecall->econn) {\n\t\twarning(\"ecall: answer: econn does not exist!\\n\");\n\t\treturn ENOENT;\n\t}\n\tif (ECONN_PENDING_INCOMING != econn_current_state(ecall->econn)) {\n\t\tinfo(\"ecall(%p): answer: invalid state (%s)\\n\", ecall,\n\t\t     econn_state_name(econn_current_state(ecall->econn)));\n\t\treturn EPROTO;\n\t}\n\tif (!ecall->flow) {\n\t\twarning(\"ecall: answer: no mediaflow\\n\");\n\t\treturn EPROTO;\n\t}\n\tecall->call_type = call_type;\n\tIFLOW_CALL(ecall->flow, set_call_type, call_type);\n\tecall->audio_cbr = audio_cbr;\n\tIFLOW_CALL(ecall->flow, set_audio_cbr, audio_cbr);\n#if 0\n\tif (ecall->props_local) {\n\t\tconst char *vstate_string =\n\t\t\tcall_type == ICALL_CALL_TYPE_VIDEO ? \"true\" : \"false\";\n\t\tint err2 = econn_props_update(ecall->props_local, \"videosend\", vstate_string);\n\t\tif (err2) {\n\t\t\twarning(\"ecall(%p): econn_props_update(videosend)\",\n\t\t\t\t\" failed (%m)\\n\", ecall, err2);\n\t\t}\n\t}\n#endif\n\terr = generate_or_gather_answer(ecall, ecall->econn);\n\tif (err) {\n\t\twarning(\"ecall: answer: failed to gather_or_answer\\n\");\n\t\tgoto out;\n\t}\n\tecall->answered = true;\n\tecall->audio_setup_time = -1;\n\tecall->call_estab_time = -1;\n\tecall->ts_answered = tmr_jiffies();\n out:\n\treturn err;\n}", "target": 1}
{"code": "static int smb2_calc_max_out_buf_len(struct ksmbd_work *work,\n\t\t\t\t     unsigned short hdr2_len,\n\t\t\t\t     unsigned int out_buf_len)\n{\n\tint free_len;\n\tif (out_buf_len > work->conn->vals->max_trans_size)\n\t\treturn -EINVAL;\n\tfree_len = (int)(work->response_sz -\n\t\t\t (get_rfc1002_len(work->response_buf) + 4)) -\n\t\thdr2_len;\n\tif (free_len < 0)\n\t\treturn -EINVAL;\n\treturn min_t(int, out_buf_len, free_len);\n}", "target": 1}
{"code": "static bool path_connected(const struct path *path)\n{\n\tstruct vfsmount *mnt = path->mnt;\n\tif (mnt->mnt_root == mnt->mnt_sb->s_root)\n\t\treturn true;\n\treturn is_subdir(path->dentry, mnt->mnt_root);\n}", "target": 0}
{"code": "void recovery_delete_character(void)\n{\n    if (!recovery_started) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_UnexpectedMessage, \"Not in Recovery mode\");\n        layoutHome();\n        return;\n    }\n    if(strlen(mnemonic) > 0)\n    {\n        mnemonic[strlen(mnemonic) - 1] = '\\0';\n    }\n    next_character();\n}", "target": 0}
{"code": "acpi_os_write_pci_configuration(struct acpi_pci_id * pci_id, u32 reg,\n\t\t\t\tu64 value, u32 width)\n{\n\tint result, size;\n\tswitch (width) {\n\tcase 8:\n\t\tsize = 1;\n\t\tbreak;\n\tcase 16:\n\t\tsize = 2;\n\t\tbreak;\n\tcase 32:\n\t\tsize = 4;\n\t\tbreak;\n\tdefault:\n\t\treturn AE_ERROR;\n\t}\n\tresult = raw_pci_write(pci_id->segment, pci_id->bus,\n\t\t\t\tPCI_DEVFN(pci_id->device, pci_id->function),\n\t\t\t\treg, size, value);\n\treturn (result ? AE_ERROR : AE_OK);\n}", "target": 0}
{"code": "__u32 secure_tcp_sequence_number(__be32 saddr, __be32 daddr,\n\t\t\t\t __be16 sport, __be16 dport)\n{\n\tu32 hash[MD5_DIGEST_WORDS];\n\thash[0] = (__force u32)saddr;\n\thash[1] = (__force u32)daddr;\n\thash[2] = ((__force u16)sport << 16) + (__force u16)dport;\n\thash[3] = net_secret[15];\n\tmd5_transform(hash, net_secret);\n\treturn seq_scale(hash[0]);\n}", "target": 0}
{"code": "AsyncSocket::WriteResult AsyncSSLSocket::interpretSSLError(int rc, int error) {\n  if (error == SSL_ERROR_WANT_READ) {\n    LOG(ERROR) << \"AsyncSSLSocket(fd=\" << fd_ << \", state=\" << int(state_)\n               << \", sslState=\" << sslState_ << \", events=\" << eventFlags_\n               << \"): \"\n               << \"unsupported SSL renegotiation during write\";\n    return WriteResult(\n        WRITE_ERROR,\n        std::make_unique<SSLException>(SSLError::INVALID_RENEGOTIATION));\n  } else {\n    if (zero_return(error, rc, errno)) {\n      return WriteResult(0);\n    }\n    auto errError = ERR_get_error();\n    VLOG(3) << \"ERROR: AsyncSSLSocket(fd=\" << fd_ << \", state=\" << int(state_)\n            << \", sslState=\" << sslState_ << \", events=\" << eventFlags_ << \"): \"\n            << \"SSL error: \" << error << \", errno: \" << errno\n            << \", func: \" << ERR_func_error_string(errError)\n            << \", reason: \" << ERR_reason_error_string(errError);\n    return WriteResult(\n        WRITE_ERROR,\n        std::make_unique<SSLException>(error, errError, rc, errno));\n  }\n}", "target": 1}
{"code": "\tvirtual void run(Chunk &inChunk, Chunk &outChunk)\n\t{\n\t\tint count = inChunk.f.channelCount * inChunk.frameCount;\n\t\tif (m_isSigned)\n\t\t\trun<int32_t>(reinterpret_cast<const uint8_t *>(inChunk.buffer),\n\t\t\t\treinterpret_cast<int32_t *>(outChunk.buffer),\n\t\t\t\tcount);\n\t\telse\n\t\t\trun<uint32_t>(reinterpret_cast<const uint8_t *>(inChunk.buffer),\n\t\t\t\treinterpret_cast<uint32_t *>(outChunk.buffer),\n\t\t\t\tcount);\n\t}", "target": 0}
{"code": "static inline VALUE fiobj_mustache_find_obj_absolute(VALUE udata,\n                                                     const char *name,\n                                                     uint32_t name_len) {\n  VALUE tmp;\n  if (!RB_TYPE_P(udata, T_HASH)) {\n    if (name_len == 1 && name[0] == '.')\n      return udata;\n    ID name_id = rb_intern2(name, name_len);\n    if (rb_respond_to(udata, name_id)) {\n      return IodineCaller.call(udata, name_id);\n    }\n    return Qnil;\n  }\n  ID name_id = rb_intern2(name, name_len);\n  VALUE key = ID2SYM(name_id);\n  tmp = rb_hash_lookup2(udata, key, Qundef);\n  if (tmp != Qundef)\n    return tmp;\n  key = rb_sym2str(key);\n  tmp = rb_hash_lookup2(udata, key, Qundef);\n  rb_str_free(key);\n  if (tmp != Qundef)\n    return tmp;\n  tmp = Qnil;\n  if (rb_respond_to(udata, name_id)) {\n    tmp = IodineCaller.call(udata, name_id);\n  }\n  return tmp;\n}", "target": 0}
{"code": "static bool __init is_skylake_era(void)\n{\n\tif (boot_cpu_data.x86_vendor == X86_VENDOR_INTEL &&\n\t    boot_cpu_data.x86 == 6) {\n\t\tswitch (boot_cpu_data.x86_model) {\n\t\tcase INTEL_FAM6_SKYLAKE_MOBILE:\n\t\tcase INTEL_FAM6_SKYLAKE_DESKTOP:\n\t\tcase INTEL_FAM6_SKYLAKE_X:\n\t\tcase INTEL_FAM6_KABYLAKE_MOBILE:\n\t\tcase INTEL_FAM6_KABYLAKE_DESKTOP:\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "target": 1}
{"code": "remote_addr(VALUE self) {\n    return req_remote_addr((agooReq)DATA_PTR(self));\n}", "target": 0}
{"code": "static int tipc_crypto_key_revoke(struct net *net, u8 tx_key)\n{\n\tstruct tipc_crypto *tx = tipc_net(net)->crypto_tx;\n\tstruct tipc_key key;\n\tspin_lock(&tx->lock);\n\tkey = tx->key;\n\tWARN_ON(!key.active || tx_key != key.active);\n\ttipc_crypto_key_set_state(tx, key.passive, 0, key.pending);\n\ttipc_crypto_key_detach(tx->aead[key.active], &tx->lock);\n\tspin_unlock(&tx->lock);\n\tpr_warn(\"%s: key is revoked\\n\", tx->name);\n\treturn -EKEYREVOKED;\n}", "target": 1}
{"code": "static void ieee80211_if_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\tdev->netdev_ops = &ieee80211_dataif_ops;\n\tdev->destructor = free_netdev;\n}", "target": 0}
{"code": "get_image_extensions(void)\n{\n\tGHashTable *extensions;\n\tGSList *formats = gdk_pixbuf_get_formats ();\n\tGSList *l;\n\tguint i;\n\tconst char *known_image_formats[] = {\n\t\t\"png\",\n\t\t\"jpg\",\n\t\t\"jpeg\",\n\t\t\"webp\"\n\t};\n\textensions = g_hash_table_new_full (g_str_hash, g_str_equal,\n\t\t\t\t\t    g_free, NULL);\n\tfor (l = formats; l != NULL; l = l->next) {\n\t\tint i;\n\t\tgchar **ext = gdk_pixbuf_format_get_extensions (l->data);\n\t\tfor (i = 0; ext[i] != NULL; i++) {\n\t\t\tg_hash_table_insert (extensions,\n\t\t\t\t\t     g_strdup (ext[i]),\n\t\t\t\t\t     GINT_TO_POINTER (FORMAT_SUPPORTED));\n\t\t}\n\t\tg_strfreev (ext);\n\t}\n\tg_slist_free (formats);\n\tfor (i = 0; i < G_N_ELEMENTS (known_image_formats); i++) {\n\t\tif (!g_hash_table_lookup (extensions, known_image_formats[i])) {\n\t\t\tg_hash_table_insert (extensions,\n\t\t\t\t\t     g_strdup (known_image_formats[i]),\n\t\t\t\t\t     GINT_TO_POINTER (FORMAT_UNSUPPORTED));\n\t\t}\n\t}\n\treturn extensions;\n}", "target": 0}
{"code": "nautilus_file_mark_desktop_file_executable (GFile              *file,\n                                            GtkWindow          *parent_window,\n                                            gboolean            interactive,\n                                            NautilusOpCallback  done_callback,\n                                            gpointer            done_callback_data)\n{\n    GTask *task;\n    MarkTrustedJob *job;\n    job = op_job_new (MarkTrustedJob, parent_window);\n    job->file = g_object_ref (file);\n    job->interactive = interactive;\n    job->done_callback = done_callback;\n    job->done_callback_data = done_callback_data;\n    task = g_task_new (NULL, NULL, mark_desktop_file_executable_task_done, job);\n    g_task_set_task_data (task, job, NULL);\n    g_task_run_in_thread (task, mark_desktop_file_executable_task_thread_func);\n    g_object_unref (task);\n}", "target": 0}
{"code": "xfs_attr3_leaf_clearflag(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tint namelen;\n\tchar *name;\n#endif \n\ttrace_xfs_attr_leaf_clearflag(args);\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn(error);\n\tleaf = bp->b_addr;\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tASSERT(entry->flags & XFS_ATTR_INCOMPLETE);\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(args->index < ichdr.count);\n\tASSERT(args->index >= 0);\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tnamelen = name_loc->namelen;\n\t\tname = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tnamelen = name_rmt->namelen;\n\t\tname = (char *)name_rmt->name;\n\t}\n\tASSERT(be32_to_cpu(entry->hashval) == args->hashval);\n\tASSERT(namelen == args->namelen);\n\tASSERT(memcmp(name, args->name, namelen) == 0);\n#endif \n\tentry->flags &= ~XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\tif (args->rmtblkno) {\n\t\tASSERT((entry->flags & XFS_ATTR_LOCAL) == 0);\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tname_rmt->valueblk = cpu_to_be32(args->rmtblkno);\n\t\tname_rmt->valuelen = cpu_to_be32(args->valuelen);\n\t\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, name_rmt, sizeof(*name_rmt)));\n\t}\n\treturn xfs_trans_roll(&args->trans, args->dp);\n}", "target": 1}
{"code": "static inline bool kvm_apic_has_events(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic->pending_events;\n}", "target": 1}
{"code": "int nft_expr_inner_parse(const struct nft_ctx *ctx, const struct nlattr *nla,\n\t\t\t struct nft_expr_info *info)\n{\n\tstruct nlattr *tb[NFTA_EXPR_MAX + 1];\n\tconst struct nft_expr_type *type;\n\tint err;\n\terr = nla_parse_nested_deprecated(tb, NFTA_EXPR_MAX, nla,\n\t\t\t\t\t  nft_expr_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\tif (!tb[NFTA_EXPR_DATA])\n\t\treturn -EINVAL;\n\ttype = __nft_expr_type_get(ctx->family, tb[NFTA_EXPR_NAME]);\n\tif (!type)\n\t\treturn -ENOENT;\n\tif (!type->inner_ops)\n\t\treturn -EOPNOTSUPP;\n\terr = nla_parse_nested_deprecated(info->tb, type->maxattr,\n\t\t\t\t\t  tb[NFTA_EXPR_DATA],\n\t\t\t\t\t  type->policy, NULL);\n\tif (err < 0)\n\t\tgoto err_nla_parse;\n\tinfo->attr = nla;\n\tinfo->ops = type->inner_ops;\n\treturn 0;\nerr_nla_parse:\n\treturn err;\n}", "target": 1}
{"code": "static int iscsi_add_notunderstood_response(\n\tchar *key,\n\tchar *value,\n\tstruct iscsi_param_list *param_list)\n{\n\tstruct iscsi_extra_response *extra_response;\n\tif (strlen(value) > VALUE_MAXLEN) {\n\t\tpr_err(\"Value for notunderstood key \\\"%s\\\" exceeds %d,\"\n\t\t\t\" protocol error.\\n\", key, VALUE_MAXLEN);\n\t\treturn -1;\n\t}\n\textra_response = kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);\n\tif (!extra_response) {\n\t\tpr_err(\"Unable to allocate memory for\"\n\t\t\t\" struct iscsi_extra_response.\\n\");\n\t\treturn -1;\n\t}\n\tINIT_LIST_HEAD(&extra_response->er_list);\n\tstrncpy(extra_response->key, key, strlen(key) + 1);\n\tstrncpy(extra_response->value, NOTUNDERSTOOD,\n\t\t\tstrlen(NOTUNDERSTOOD) + 1);\n\tlist_add_tail(&extra_response->er_list,\n\t\t\t&param_list->extra_response_list);\n\treturn 0;\n}", "target": 1}
{"code": "static void fuse_lib_setxattr(fuse_req_t req, fuse_ino_t ino, const char *name,\n                              const char *value, size_t size, int flags)\n{\n    struct fuse *f = req_fuse_prepare(req);\n    char *path;\n    int err;\n    err = -ENOENT;\n    pthread_rwlock_rdlock(&f->tree_lock);\n    path = get_path(f, ino);\n    if (path != NULL) {\n        struct fuse_intr_data d;\n        fuse_prepare_interrupt(f, req, &d);\n        err = fuse_fs_setxattr(f->fs, path, name, value, size, flags);\n        fuse_finish_interrupt(f, req, &d);\n        free(path);\n    }\n    pthread_rwlock_unlock(&f->tree_lock);\n    reply_err(req, err);\n}", "target": 0}
{"code": "static int nla_validate_array(const struct nlattr *head, int len, int maxtype,\n\t\t\t      const struct nla_policy *policy,\n\t\t\t      struct netlink_ext_ack *extack,\n\t\t\t      unsigned int validate)\n{\n\tconst struct nlattr *entry;\n\tint rem;\n\tnla_for_each_attr(entry, head, len, rem) {\n\t\tint ret;\n\t\tif (nla_len(entry) == 0)\n\t\t\tcontinue;\n\t\tif (nla_len(entry) < NLA_HDRLEN) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, entry,\n\t\t\t\t\t    \"Array element too short\");\n\t\t\treturn -ERANGE;\n\t\t}\n\t\tret = __nla_validate(nla_data(entry), nla_len(entry),\n\t\t\t\t     maxtype, policy, validate, extack);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)\n{\n\tint start = 0;\n\tu32 prev_legacy, cur_legacy;\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tprev_legacy = kvm->arch.vpit->pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY;\n\tcur_legacy = ps->flags & KVM_PIT_FLAGS_HPET_LEGACY;\n\tif (!prev_legacy && cur_legacy)\n\t\tstart = 1;\n\tmemcpy(&kvm->arch.vpit->pit_state.channels, &ps->channels,\n\t       sizeof(kvm->arch.vpit->pit_state.channels));\n\tkvm->arch.vpit->pit_state.flags = ps->flags;\n\tkvm_pit_load_count(kvm, 0, kvm->arch.vpit->pit_state.channels[0].count, start);\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\treturn 0;\n}", "target": 1}
{"code": "test_save_copy (const char *origname)\n{\n  char buf[TESTBUFSIZE];\n  int ret;\n  snprintf_func (buf, TESTBUFSIZE, \"cp -f %s %s\", origname, TEST_COPY_FILE);\n  if ((ret = system (buf)) != 0)\n    {\n      return XD3_INTERNAL;\n    }\n  return 0;\n}", "target": 1}
{"code": "int sctp_verify_asconf(const struct sctp_association *asoc,\n\t\t       struct sctp_paramhdr *param_hdr, void *chunk_end,\n\t\t       struct sctp_paramhdr **errp) {\n\tsctp_addip_param_t *asconf_param;\n\tunion sctp_params param;\n\tint length, plen;\n\tparam.v = (sctp_paramhdr_t *) param_hdr;\n\twhile (param.v <= chunk_end - sizeof(sctp_paramhdr_t)) {\n\t\tlength = ntohs(param.p->length);\n\t\t*errp = param.p;\n\t\tif (param.v > chunk_end - length ||\n\t\t    length < sizeof(sctp_paramhdr_t))\n\t\t\treturn 0;\n\t\tswitch (param.p->type) {\n\t\tcase SCTP_PARAM_ADD_IP:\n\t\tcase SCTP_PARAM_DEL_IP:\n\t\tcase SCTP_PARAM_SET_PRIMARY:\n\t\t\tasconf_param = (sctp_addip_param_t *)param.v;\n\t\t\tplen = ntohs(asconf_param->param_hdr.length);\n\t\t\tif (plen < sizeof(sctp_addip_param_t) +\n\t\t\t    sizeof(sctp_paramhdr_t))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase SCTP_PARAM_SUCCESS_REPORT:\n\t\tcase SCTP_PARAM_ADAPTATION_LAYER_IND:\n\t\t\tif (length != sizeof(sctp_addip_param_t))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tparam.v += WORD_ROUND(length);\n\t}\n\tif (param.v != chunk_end)\n\t\treturn 0;\n\treturn 1;\n}", "target": 1}
{"code": "static unsigned int ipv6_defrag(void *priv,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tconst struct nf_hook_state *state)\n{\n\tint err;\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\n\tif (skb->nfct && !nf_ct_is_template((struct nf_conn *)skb->nfct))\n\t\treturn NF_ACCEPT;\n#endif\n\terr = nf_ct_frag6_gather(state->net, skb,\n\t\t\t\t nf_ct6_defrag_user(state->hook, skb));\n\tif (err == -EINPROGRESS)\n\t\treturn NF_STOLEN;\n\treturn NF_ACCEPT;\n}", "target": 1}
{"code": "int ContentLine_Analyzer::DoDeliverOnce(int len, const u_char* data)\n\t{\n\tconst u_char* data_start = data;\n\tif ( len <= 0 )\n\t\treturn 0;\n\tfor ( ; len > 0; --len, ++data )\n\t\t{\n\t\tif ( offset >= buf_len )\n\t\t\tInitBuffer(buf_len * 2);\n\t\tint c = data[0];\n#define EMIT_LINE \\\n\t{ \\\n\tbuf[offset] = '\\0'; \\\n\tint seq_len = data + 1 - data_start; \\\n\tseq_delivered_in_lines = seq + seq_len; \\\n\tlast_char = c; \\\n\tForwardStream(offset, buf, IsOrig()); \\\n\toffset = 0; \\\n\treturn seq_len; \\\n\t}\n\t\tswitch ( c ) {\n\t\tcase '\\r':\n\t\t\tif ( len > 1 && data[1] == '\\n' )\n\t\t\t\t{\n\t\t\t\t--len; ++data;\n\t\t\t\tlast_char = c;\n\t\t\t\tc = data[0];\n\t\t\t\tEMIT_LINE\n\t\t\t\t}\n\t\t\telse if ( CR_LF_as_EOL & CR_as_EOL )\n\t\t\t\tEMIT_LINE\n\t\t\telse\n\t\t\t\tbuf[offset++] = c;\n\t\t\tbreak;\n\t\tcase '\\n':\n\t\t\tif ( last_char == '\\r' )\n\t\t\t\t{\n\t\t\t\tif ( offset == 0 )\n\t\t\t\t\t{\n\t\t\t\t\tlast_char = c;\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t--offset; \n\t\t\t\tEMIT_LINE\n\t\t\t\t}\n\t\t\telse if ( CR_LF_as_EOL & LF_as_EOL )\n\t\t\t\tEMIT_LINE\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tif ( ! suppress_weirds && Conn()->FlagEvent(SINGULAR_LF) )\n\t\t\t\t\tConn()->Weird(\"line_terminated_with_single_LF\");\n\t\t\t\tbuf[offset++] = c;\n\t\t\t\t}\n\t\t\tbreak;\n\t\tcase '\\0':\n\t\t\tif ( flag_NULs )\n\t\t\t\tCheckNUL();\n\t\t\telse\n\t\t\t\tbuf[offset++] = c;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbuf[offset++] = c;\n\t\t\tbreak;\n\t\t}\n\t\tif ( last_char == '\\r' )\n\t\t\tif ( ! suppress_weirds && Conn()->FlagEvent(SINGULAR_CR) )\n\t\t\t\tConn()->Weird(\"line_terminated_with_single_CR\");\n\t\tlast_char = c;\n\t\t}\n\treturn data - data_start;\n\t}", "target": 0}
{"code": "static void fio_cluster_client_handler(struct cluster_pr_s *pr) {\n  switch ((fio_cluster_message_type_e)pr->type) {\n  case FIO_CLUSTER_MSG_FORWARD: \n  case FIO_CLUSTER_MSG_JSON:\n    fio_publish2process(fio_msg_internal_dup(pr->msg));\n    break;\n  case FIO_CLUSTER_MSG_SHUTDOWN:\n    fio_stop();\n    kill(getpid(), SIGINT);\n  case FIO_CLUSTER_MSG_ERROR:         \n  case FIO_CLUSTER_MSG_PING:          \n  case FIO_CLUSTER_MSG_ROOT:          \n  case FIO_CLUSTER_MSG_ROOT_JSON:     \n  case FIO_CLUSTER_MSG_PUBSUB_SUB:    \n  case FIO_CLUSTER_MSG_PUBSUB_UNSUB:  \n  case FIO_CLUSTER_MSG_PATTERN_SUB:   \n  case FIO_CLUSTER_MSG_PATTERN_UNSUB: \n  default:\n    break;\n  }\n}", "target": 0}
{"code": "static BYTE get_bmf_bpp(UINT32 bmf, BOOL* pValid)\n{\n\tif (pValid)\n\t\t*pValid = TRUE;\n\tswitch (bmf)\n\t{\n\t\tcase 1:\n\t\t\treturn 1;\n\t\tcase 3:\n\t\t\treturn 8;\n\t\tcase 4:\n\t\t\treturn 16;\n\t\tcase 5:\n\t\t\treturn 24;\n\t\tcase 6:\n\t\t\treturn 32;\n\t\tdefault:\n\t\t\tWLog_WARN(TAG, \"Invalid bmf %\" PRIu32, bmf);\n\t\t\tif (pValid)\n\t\t\t\t*pValid = FALSE;\n\t\t\treturn 0;\n\t}\n}", "target": 0}
{"code": "bool Decode(string_view encoded, std::string* raw) {\n  for (auto iter = encoded.begin(); iter != encoded.end(); ++iter) {\n    if (*iter == '%') {\n      if (++iter == encoded.end()) {\n        return false;\n      }\n      int h_decimal = 0;\n      if (!HexToDecimal(*iter, &h_decimal)) {\n        return false;\n      }\n      if (++iter == encoded.end()) {\n        return false;\n      }\n      int l_decimal = 0;\n      if (!HexToDecimal(*iter, &l_decimal)) {\n        return false;\n      }\n      raw->push_back(static_cast<char>((h_decimal << 4) + l_decimal));\n    } else if (*iter > 127 || *iter < 0) {\n      return false;\n    } else {\n      raw->push_back(*iter);\n    }\n  }\n  return true;\n}", "target": 1}
{"code": "static void sctp_close(struct sock *sk, long timeout)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct sctp_endpoint *ep;\n\tstruct sctp_association *asoc;\n\tstruct list_head *pos, *temp;\n\tunsigned int data_was_unread;\n\tpr_debug(\"%s: sk:%p, timeout:%ld\\n\", __func__, sk, timeout);\n\tlock_sock(sk);\n\tsk->sk_shutdown = SHUTDOWN_MASK;\n\tsk->sk_state = SCTP_SS_CLOSING;\n\tep = sctp_sk(sk)->ep;\n\tdata_was_unread = sctp_queue_purge_ulpevents(&sk->sk_receive_queue);\n\tdata_was_unread += sctp_queue_purge_ulpevents(&sctp_sk(sk)->pd_lobby);\n\tlist_for_each_safe(pos, temp, &ep->asocs) {\n\t\tasoc = list_entry(pos, struct sctp_association, asocs);\n\t\tif (sctp_style(sk, TCP)) {\n\t\t\tif (sctp_state(asoc, CLOSED)) {\n\t\t\t\tsctp_unhash_established(asoc);\n\t\t\t\tsctp_association_free(asoc);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (data_was_unread || !skb_queue_empty(&asoc->ulpq.lobby) ||\n\t\t    !skb_queue_empty(&asoc->ulpq.reasm) ||\n\t\t    (sock_flag(sk, SOCK_LINGER) && !sk->sk_lingertime)) {\n\t\t\tstruct sctp_chunk *chunk;\n\t\t\tchunk = sctp_make_abort_user(asoc, NULL, 0);\n\t\t\tif (chunk)\n\t\t\t\tsctp_primitive_ABORT(net, asoc, chunk);\n\t\t} else\n\t\t\tsctp_primitive_SHUTDOWN(net, asoc, NULL);\n\t}\n\tif (sctp_style(sk, TCP) && timeout)\n\t\tsctp_wait_for_close(sk, timeout);\n\trelease_sock(sk);\n\tlocal_bh_disable();\n\tbh_lock_sock(sk);\n\tsock_hold(sk);\n\tsk_common_release(sk);\n\tbh_unlock_sock(sk);\n\tlocal_bh_enable();\n\tsock_put(sk);\n\tSCTP_DBG_OBJCNT_DEC(sock);\n}", "target": 1}
{"code": "static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt)\n{\n\tstruct epitem *epi = ep_item_from_epqueue(pt);\n\tstruct eppoll_entry *pwq;\n\tif (epi->nwait >= 0 && (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) {\n\t\tinit_waitqueue_func_entry(&pwq->wait, ep_poll_callback);\n\t\tpwq->whead = whead;\n\t\tpwq->base = epi;\n\t\tadd_wait_queue(whead, &pwq->wait);\n\t\tlist_add_tail(&pwq->llink, &epi->pwqlist);\n\t\tepi->nwait++;\n\t} else {\n\t\tepi->nwait = -1;\n\t}\n}", "target": 0}
{"code": "int jas_stream_gobble(jas_stream_t *stream, int n)\n{\n\tint m;\n\tif (n < 0) {\n\t\tjas_deprecated(\"negative count for jas_stream_gobble\");\n\t}\n\tm = n;\n\tfor (m = n; m > 0; --m) {\n\t\tif (jas_stream_getc(stream) == EOF) {\n\t\t\treturn n - m;\n\t\t}\n\t}\n\treturn n;\n}", "target": 0}
{"code": "void AsfVideo::decodeHeader() {\n  DataBuf nbHeadersBuf(DWORD + 1);\n  io_->read(nbHeadersBuf.data(), DWORD);\n  uint32_t nb_headers = Exiv2::getULong(nbHeadersBuf.data(), littleEndian);\n  Internal::enforce(nb_headers < std::numeric_limits<uint32_t>::max(), Exiv2::ErrorCode::kerCorruptedMetadata);\n  io_->seekOrThrow(io_->tell() + BYTE * 2, BasicIo::beg,\n                   ErrorCode::kerFailedToReadImageData);  \n  for (uint32_t i = 0; i < nb_headers; i++) {\n    decodeBlock();\n  }\n}", "target": 1}
{"code": "struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,\n\t\t\t\t\t\tint port)\n{\n\tunsigned long flags;\n\tstruct snd_seq_client_port *new_port, *p;\n\tint num = -1;\n\tif (snd_BUG_ON(!client))\n\t\treturn NULL;\n\tif (client->num_ports >= SNDRV_SEQ_MAX_PORTS) {\n\t\tpr_warn(\"ALSA: seq: too many ports for client %d\\n\", client->number);\n\t\treturn NULL;\n\t}\n\tnew_port = kzalloc(sizeof(*new_port), GFP_KERNEL);\n\tif (!new_port)\n\t\treturn NULL;\t\n\tnew_port->addr.client = client->number;\n\tnew_port->addr.port = -1;\n\tnew_port->owner = THIS_MODULE;\n\tsprintf(new_port->name, \"port-%d\", num);\n\tsnd_use_lock_init(&new_port->use_lock);\n\tport_subs_info_init(&new_port->c_src);\n\tport_subs_info_init(&new_port->c_dest);\n\tnum = port >= 0 ? port : 0;\n\tmutex_lock(&client->ports_mutex);\n\twrite_lock_irqsave(&client->ports_lock, flags);\n\tlist_for_each_entry(p, &client->ports_list_head, list) {\n\t\tif (p->addr.port > num)\n\t\t\tbreak;\n\t\tif (port < 0) \n\t\t\tnum = p->addr.port + 1;\n\t}\n\tlist_add_tail(&new_port->list, &p->list);\n\tclient->num_ports++;\n\tnew_port->addr.port = num;\t\n\twrite_unlock_irqrestore(&client->ports_lock, flags);\n\tmutex_unlock(&client->ports_mutex);\n\tsprintf(new_port->name, \"port-%d\", num);\n\treturn new_port;\n}", "target": 1}
{"code": "BOOL nego_read_request(rdpNego* nego, wStream* s)\n{\n\tBYTE li;\n\tBYTE type;\n\tUINT16 length;\n\tif (!tpkt_read_header(s, &length))\n\t\treturn FALSE;\n\tif (!tpdu_read_connection_request(s, &li, length))\n\t\treturn FALSE;\n\tif (li != Stream_GetRemainingLength(s) + 6)\n\t{\n\t\tWLog_ERR(TAG, \"Incorrect TPDU length indicator.\");\n\t\treturn FALSE;\n\t}\n\tif (!nego_read_request_token_or_cookie(nego, s))\n\t{\n\t\tWLog_ERR(TAG, \"Failed to parse routing token or cookie.\");\n\t\treturn FALSE;\n\t}\n\tif (Stream_GetRemainingLength(s) >= 8)\n\t{\n\t\tStream_Read_UINT8(s, type); \n\t\tif (type != TYPE_RDP_NEG_REQ)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Incorrect negotiation request type %\" PRIu8 \"\", type);\n\t\t\treturn FALSE;\n\t\t}\n\t\tnego_process_negotiation_request(nego, s);\n\t}\n\treturn tpkt_ensure_stream_consumed(s, length);\n}", "target": 1}
{"code": "smtp_mailaddr(struct mailaddr *maddr, char *line, int mailfrom, char **args,\n    const char *domain)\n{\n\tchar   *p, *e;\n\tif (line == NULL)\n\t\treturn (0);\n\tif (*line != '<')\n\t\treturn (0);\n\te = strchr(line, '>');\n\tif (e == NULL)\n\t\treturn (0);\n\t*e++ = '\\0';\n\twhile (*e == ' ')\n\t\te++;\n\t*args = e;\n\tif (!text_to_mailaddr(maddr, line + 1))\n\t\treturn (0);\n\tp = strchr(maddr->user, ':');\n\tif (p != NULL) {\n\t\tp++;\n\t\tmemmove(maddr->user, p, strlen(p) + 1);\n\t}\n\tif (!valid_localpart(maddr->user) ||\n\t    !valid_domainpart(maddr->domain)) {\n\t\tif (mailfrom && maddr->user[0] == '\\0' && maddr->domain[0] == '\\0')\n\t\t\treturn (1);\n\t\tif (maddr->user[0] == '\\0')\n\t\t\treturn (0);\n\t\tif (maddr->domain[0] == '\\0') {\n\t\t\t(void)strlcpy(maddr->domain, domain,\n\t\t\t    sizeof(maddr->domain));\n\t\t\treturn (1);\n\t\t}\n\t\treturn (0);\n\t}\n\treturn (1);\n}", "target": 1}
{"code": "l_strnstart(const char *tstr1, u_int tl1, const char *str2, u_int l2)\n{\n\tif (tl1 > l2)\n\t\treturn 0;\n\treturn (strncmp(tstr1, str2, tl1) == 0 ? 1 : 0);\n}", "target": 1}
{"code": "TfLiteRegistration AddOpRegistration() {\n  TfLiteRegistration reg = {nullptr, nullptr, nullptr, nullptr};\n  reg.custom_name = \"my_add\";\n  reg.builtin_code = tflite::BuiltinOperator_CUSTOM;\n  reg.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n    const TfLiteTensor* input1 = GetInput(context, node, 0);\n    const TfLiteTensor* input2 = GetInput(context, node, 1);\n    TfLiteTensor* output = GetOutput(context, node, 0);\n    TF_LITE_ENSURE_EQ(context, input1->dims->size, input2->dims->size);\n    for (int i = 0; i < input1->dims->size; ++i) {\n      TF_LITE_ENSURE_EQ(context, input1->dims->data[i], input2->dims->data[i]);\n    }\n    TF_LITE_ENSURE_STATUS(context->ResizeTensor(\n        context, output, TfLiteIntArrayCopy(input1->dims)));\n    return kTfLiteOk;\n  };\n  reg.invoke = [](TfLiteContext* context, TfLiteNode* node) {\n    const TfLiteTensor* a0 = GetInput(context, node, 0);\n    TF_LITE_ENSURE(context, a0);\n    TF_LITE_ENSURE(context, a0->data.f);\n    const TfLiteTensor* a1 = GetInput(context, node, 1);\n    TF_LITE_ENSURE(context, a1);\n    TF_LITE_ENSURE(context, a1->data.f);\n    TfLiteTensor* out = GetOutput(context, node, 0);\n    TF_LITE_ENSURE(context, out);\n    TF_LITE_ENSURE(context, out->data.f);\n    int num = a0->dims->data[0];\n    for (int i = 0; i < num; i++) {\n      out->data.f[i] = a0->data.f[i] + a1->data.f[i];\n    }\n    return kTfLiteOk;\n  };\n  return reg;\n}", "target": 1}
{"code": "static struct vm_area_struct *vma_to_resize(unsigned long addr,\n\tunsigned long old_len, unsigned long new_len, unsigned long *p)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = find_vma(mm, addr);\n\tif (!vma || vma->vm_start > addr)\n\t\tgoto Efault;\n\tif (is_vm_hugetlb_page(vma))\n\t\tgoto Einval;\n\tif (old_len > vma->vm_end - addr)\n\t\tgoto Efault;\n\tif (vma->vm_flags & (VM_DONTEXPAND | VM_PFNMAP)) {\n\t\tif (new_len > old_len)\n\t\t\tgoto Efault;\n\t}\n\tif (vma->vm_flags & VM_LOCKED) {\n\t\tunsigned long locked, lock_limit;\n\t\tlocked = mm->locked_vm << PAGE_SHIFT;\n\t\tlock_limit = rlimit(RLIMIT_MEMLOCK);\n\t\tlocked += new_len - old_len;\n\t\tif (locked > lock_limit && !capable(CAP_IPC_LOCK))\n\t\t\tgoto Eagain;\n\t}\n\tif (!may_expand_vm(mm, (new_len - old_len) >> PAGE_SHIFT))\n\t\tgoto Enomem;\n\tif (vma->vm_flags & VM_ACCOUNT) {\n\t\tunsigned long charged = (new_len - old_len) >> PAGE_SHIFT;\n\t\tif (security_vm_enough_memory(charged))\n\t\t\tgoto Efault;\n\t\t*p = charged;\n\t}\n\treturn vma;\nEfault:\t\n\treturn ERR_PTR(-EFAULT);\nEinval:\n\treturn ERR_PTR(-EINVAL);\nEnomem:\n\treturn ERR_PTR(-ENOMEM);\nEagain:\n\treturn ERR_PTR(-EAGAIN);\n}", "target": 1}
{"code": "static inline int process_numeric_entity(const char **buf, unsigned *code_point)\n{\n\tlong code_l;\n\tint hexadecimal = (**buf == 'x' || **buf == 'X'); \n\tchar *endptr;\n\tif (hexadecimal && (**buf != '\\0'))\n\t\t(*buf)++;\n\tif ((hexadecimal && !isxdigit(**buf)) ||\n\t\t\t(!hexadecimal && !isdigit(**buf))) {\n\t\treturn FAILURE;\n\t}\n\tcode_l = strtol(*buf, &endptr, hexadecimal ? 16 : 10);\n\t*buf = endptr;\n\tif (**buf != ';')\n\t\treturn FAILURE;\n\tif (code_l > 0x10FFFFL)\n\t\treturn FAILURE;\n\tif (code_point != NULL)\n\t\t*code_point = (unsigned)code_l;\n\treturn SUCCESS;\n}", "target": 1}
{"code": "AP4_AvccAtom::AP4_AvccAtom(AP4_UI32 size, const AP4_UI08* payload) :\n    AP4_Atom(AP4_ATOM_TYPE_AVCC, size)\n{\n    unsigned int payload_size = size-AP4_ATOM_HEADER_SIZE;\n    m_RawBytes.SetData(payload, payload_size);\n    m_ConfigurationVersion = payload[0];\n    m_Profile              = payload[1];\n    m_ProfileCompatibility = payload[2];\n    m_Level                = payload[3];\n    m_NaluLengthSize       = 1+(payload[4]&3);\n    AP4_UI08 num_seq_params = payload[5]&31;\n    m_SequenceParameters.EnsureCapacity(num_seq_params);\n    unsigned int cursor = 6;\n    for (unsigned int i=0; i<num_seq_params; i++) {\n        m_SequenceParameters.Append(AP4_DataBuffer());\n        AP4_UI16 param_length = AP4_BytesToInt16BE(&payload[cursor]);\n        m_SequenceParameters[i].SetData(&payload[cursor]+2, param_length);\n        cursor += 2+param_length;\n    }\n    AP4_UI08 num_pic_params = payload[cursor++];\n    m_PictureParameters.EnsureCapacity(num_pic_params);\n    for (unsigned int i=0; i<num_pic_params; i++) {\n        m_PictureParameters.Append(AP4_DataBuffer());\n        AP4_UI16 param_length = AP4_BytesToInt16BE(&payload[cursor]);\n        m_PictureParameters[i].SetData(&payload[cursor]+2, param_length);\n        cursor += 2+param_length;\n    }\n}", "target": 1}
{"code": "static inline pmd_t pmd_read_atomic(pmd_t *pmdp)\n{\n\tpmdval_t ret;\n\tu32 *tmp = (u32 *)pmdp;\n\tret = (pmdval_t) (*tmp);\n\tif (ret) {\n\t\tsmp_rmb();\n\t\tret |= ((pmdval_t)*(tmp + 1)) << 32;\n\t}\n\treturn (pmd_t) { ret };\n}", "target": 0}
{"code": "mysql_stmt_prepare(MYSQL_STMT *stmt, const char *query, ulong length)\n{\n  MYSQL *mysql= stmt->mysql;\n  DBUG_ENTER(\"mysql_stmt_prepare\");\n  if (!mysql)\n  {\n    set_stmt_error(stmt, CR_SERVER_LOST, unknown_sqlstate, NULL);\n    DBUG_RETURN(1);\n  }\n  stmt->last_errno= 0;\n  stmt->last_error[0]= '\\0';\n  if ((int) stmt->state > (int) MYSQL_STMT_INIT_DONE)\n  {\n    uchar buff[MYSQL_STMT_HEADER];               \n    if (reset_stmt_handle(stmt, RESET_LONG_DATA | RESET_STORE_RESULT))\n      DBUG_RETURN(1);\n    stmt->bind_param_done= stmt->bind_result_done= FALSE;\n    stmt->param_count= stmt->field_count= 0;\n    free_root(&stmt->mem_root, MYF(MY_KEEP_PREALLOC));\n    free_root(&stmt->extension->fields_mem_root, MYF(0));\n    int4store(buff, stmt->stmt_id);\n    stmt->state= MYSQL_STMT_INIT_DONE;\n    if (stmt_command(mysql, COM_STMT_CLOSE, buff, 4, stmt))\n    {\n      set_stmt_errmsg(stmt, &mysql->net);\n      DBUG_RETURN(1);\n    }\n  }\n  if (stmt_command(mysql, COM_STMT_PREPARE, (const uchar*) query, length, stmt))\n  {\n    set_stmt_errmsg(stmt, &mysql->net);\n    DBUG_RETURN(1);\n  }\n  if ((*mysql->methods->read_prepare_result)(mysql, stmt))\n  {\n    set_stmt_errmsg(stmt, &mysql->net);\n    DBUG_RETURN(1);\n  }\n  if (!(stmt->params= (MYSQL_BIND *) alloc_root(&stmt->mem_root,\n\t\t\t\t\t\tsizeof(MYSQL_BIND)*\n                                                (stmt->param_count +\n                                                 stmt->field_count))))\n  {\n    set_stmt_error(stmt, CR_OUT_OF_MEMORY, unknown_sqlstate, NULL);\n    DBUG_RETURN(1);\n  }\n  stmt->bind= stmt->params + stmt->param_count;\n  stmt->state= MYSQL_STMT_PREPARE_DONE;\n  DBUG_PRINT(\"info\", (\"Parameter count: %u\", stmt->param_count));\n  DBUG_RETURN(0);\n}", "target": 0}
{"code": "static QString mountPoint(const RemoteFsDevice::Details &details, bool create)\n{\n    if (details.isLocalFile()) {\n        return details.url.path();\n    }\n    return Utils::cacheDir(QLatin1String(\"mount/\")+details.name, create);\n}", "target": 0}
{"code": "static int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_cmap_t *cmap = &box->data.cmap;\n\tjp2_cmapent_t *ent;\n\tunsigned int i;\n\tcmap->ents = 0;\n\tcmap->numchans = (box->datalen) / 4;\n\tif (!(cmap->ents = jas_alloc2(cmap->numchans, sizeof(jp2_cmapent_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < cmap->numchans; ++i) {\n\t\tent = &cmap->ents[i];\n\t\tif (jp2_getuint16(in, &ent->cmptno) ||\n\t\t  jp2_getuint8(in, &ent->map) ||\n\t\t  jp2_getuint8(in, &ent->pcol)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "int io_msg_ring(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_msg *msg = io_kiocb_to_cmd(req, struct io_msg);\n\tint ret;\n\tret = -EBADFD;\n\tif (!io_is_uring_fops(req->file))\n\t\tgoto done;\n\tswitch (msg->cmd) {\n\tcase IORING_MSG_DATA:\n\t\tret = io_msg_ring_data(req);\n\t\tbreak;\n\tcase IORING_MSG_SEND_FD:\n\t\tret = io_msg_send_fd(req, issue_flags);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\ndone:\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\tio_req_set_res(req, ret, 0);\n\tio_put_file(req->file);\n\treq->file = NULL;\n\treturn IOU_OK;\n}", "target": 1}
{"code": "void ping_unhash(struct sock *sk)\n{\n\tstruct inet_sock *isk = inet_sk(sk);\n\tpr_debug(\"ping_unhash(isk=%p,isk->num=%u)\\n\", isk, isk->inet_num);\n\tif (sk_hashed(sk)) {\n\t\twrite_lock_bh(&ping_table.lock);\n\t\thlist_nulls_del(&sk->sk_nulls_node);\n\t\tsk_nulls_node_init(&sk->sk_nulls_node);\n\t\tsock_put(sk);\n\t\tisk->inet_num = 0;\n\t\tisk->inet_sport = 0;\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\t\twrite_unlock_bh(&ping_table.lock);\n\t}\n}", "target": 0}
{"code": "static CACHE_BITMAP_V3_ORDER* update_read_cache_bitmap_v3_order(rdpUpdate* update, wStream* s,\n                                                                UINT16 flags)\n{\n\tBOOL rc;\n\tBYTE bitsPerPixelId;\n\tBITMAP_DATA_EX* bitmapData;\n\tUINT32 new_len;\n\tBYTE* new_data;\n\tCACHE_BITMAP_V3_ORDER* cache_bitmap_v3;\n\tif (!update || !s)\n\t\treturn NULL;\n\tcache_bitmap_v3 = calloc(1, sizeof(CACHE_BITMAP_V3_ORDER));\n\tif (!cache_bitmap_v3)\n\t\tgoto fail;\n\tcache_bitmap_v3->cacheId = flags & 0x00000003;\n\tcache_bitmap_v3->flags = (flags & 0x0000FF80) >> 7;\n\tbitsPerPixelId = (flags & 0x00000078) >> 3;\n\tcache_bitmap_v3->bpp = get_cbr2_bpp(bitsPerPixelId, &rc);\n\tif (!rc)\n\t\tgoto fail;\n\tif (Stream_GetRemainingLength(s) < 21)\n\t\tgoto fail;\n\tStream_Read_UINT16(s, cache_bitmap_v3->cacheIndex); \n\tStream_Read_UINT32(s, cache_bitmap_v3->key1);       \n\tStream_Read_UINT32(s, cache_bitmap_v3->key2);       \n\tbitmapData = &cache_bitmap_v3->bitmapData;\n\tStream_Read_UINT8(s, bitmapData->bpp);\n\tif ((bitmapData->bpp < 1) || (bitmapData->bpp > 32))\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"invalid bpp value %\" PRIu32 \"\", bitmapData->bpp);\n\t\tgoto fail;\n\t}\n\tStream_Seek_UINT8(s);                      \n\tStream_Seek_UINT8(s);                      \n\tStream_Read_UINT8(s, bitmapData->codecID); \n\tStream_Read_UINT16(s, bitmapData->width);  \n\tStream_Read_UINT16(s, bitmapData->height); \n\tStream_Read_UINT32(s, new_len);            \n\tif ((new_len == 0) || (Stream_GetRemainingLength(s) < new_len))\n\t\tgoto fail;\n\tnew_data = (BYTE*)realloc(bitmapData->data, new_len);\n\tif (!new_data)\n\t\tgoto fail;\n\tbitmapData->data = new_data;\n\tbitmapData->length = new_len;\n\tStream_Read(s, bitmapData->data, bitmapData->length);\n\treturn cache_bitmap_v3;\nfail:\n\tfree_cache_bitmap_v3_order(update->context, cache_bitmap_v3);\n\treturn NULL;\n}", "target": 0}
{"code": "void hostap_setup_dev(struct net_device *dev, local_info_t *local,\n\t\t      int type)\n{\n\tstruct hostap_interface *iface;\n\tiface = netdev_priv(dev);\n\tether_setup(dev);\n\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\tif (iface) {\n\t\tiface->wireless_data.spy_data = &iface->spy_data;\n\t\tdev->wireless_data = &iface->wireless_data;\n\t}\n\tdev->wireless_handlers = &hostap_iw_handler_def;\n\tdev->watchdog_timeo = TX_TIMEOUT;\n\tswitch(type) {\n\tcase HOSTAP_INTERFACE_AP:\n\t\tdev->tx_queue_len = 0;\t\n\t\tdev->netdev_ops = &hostap_mgmt_netdev_ops;\n\t\tdev->type = ARPHRD_IEEE80211;\n\t\tdev->header_ops = &hostap_80211_ops;\n\t\tbreak;\n\tcase HOSTAP_INTERFACE_MASTER:\n\t\tdev->netdev_ops = &hostap_master_ops;\n\t\tbreak;\n\tdefault:\n\t\tdev->tx_queue_len = 0;\t\n\t\tdev->netdev_ops = &hostap_netdev_ops;\n\t}\n\tdev->mtu = local->mtu;\n\tSET_ETHTOOL_OPS(dev, &prism2_ethtool_ops);\n}", "target": 0}
{"code": "static int decode_user_data(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\n    MpegEncContext *s = &ctx->m;\n    char buf[256];\n    int i;\n    int e;\n    int ver = 0, build = 0, ver2 = 0, ver3 = 0;\n    char last;\n    for (i = 0; i < 255 && get_bits_count(gb) < gb->size_in_bits; i++) {\n        if (show_bits(gb, 23) == 0)\n            break;\n        buf[i] = get_bits(gb, 8);\n    }\n    buf[i] = 0;\n    e = sscanf(buf, \"DivX%dBuild%d%c\", &ver, &build, &last);\n    if (e < 2)\n        e = sscanf(buf, \"DivX%db%d%c\", &ver, &build, &last);\n    if (e >= 2) {\n        ctx->divx_version = ver;\n        ctx->divx_build   = build;\n        s->divx_packed  = e == 3 && last == 'p';\n        if (s->divx_packed && !ctx->showed_packed_warning) {\n            av_log(s->avctx, AV_LOG_INFO, \"Video uses a non-standard and \"\n                   \"wasteful way to store B-frames ('packed B-frames'). \"\n                   \"Consider using a tool like VirtualDub or avidemux to fix it.\\n\");\n            ctx->showed_packed_warning = 1;\n        }\n    }\n    e = sscanf(buf, \"FFmpe%*[^b]b%d\", &build) + 3;\n    if (e != 4)\n        e = sscanf(buf, \"FFmpeg v%d.%d.%d / libavcodec build: %d\", &ver, &ver2, &ver3, &build);\n    if (e != 4) {\n        e = sscanf(buf, \"Lavc%d.%d.%d\", &ver, &ver2, &ver3) + 1;\n        if (e > 1)\n            build = (ver << 16) + (ver2 << 8) + ver3;\n    }\n    if (e != 4) {\n        if (strcmp(buf, \"ffmpeg\") == 0)\n            ctx->lavc_build = 4600;\n    }\n    if (e == 4)\n        ctx->lavc_build = build;\n    e = sscanf(buf, \"XviD%d\", &build);\n    if (e == 1)\n        ctx->xvid_build = build;\n    return 0;\n}", "target": 0}
{"code": "static void tm_reclaim_thread(struct thread_struct *thr,\n\t\t\t      struct thread_info *ti, uint8_t cause)\n{\n\tunsigned long msr_diff = 0;\n\tif (test_ti_thread_flag(ti, TIF_RESTORE_TM)) {\n\t\tmsr_diff = thr->ckpt_regs.msr & ~thr->regs->msr;\n\t\tif (msr_diff & MSR_FP)\n\t\t\tmemcpy(&thr->transact_fp, &thr->fp_state,\n\t\t\t       sizeof(struct thread_fp_state));\n\t\tif (msr_diff & MSR_VEC)\n\t\t\tmemcpy(&thr->transact_vr, &thr->vr_state,\n\t\t\t       sizeof(struct thread_vr_state));\n\t\tclear_ti_thread_flag(ti, TIF_RESTORE_TM);\n\t\tmsr_diff &= MSR_FP | MSR_VEC | MSR_VSX | MSR_FE0 | MSR_FE1;\n\t}\n\tif (!MSR_TM_SUSPENDED(mfmsr()))\n\t\treturn;\n\ttm_reclaim(thr, thr->regs->msr, cause);\n\tthr->regs->msr |= msr_diff;\n}", "target": 0}
{"code": "static int xfrm_dump_policy_done(struct netlink_callback *cb)\n{\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];\n\tstruct net *net = sock_net(cb->skb->sk);\n\txfrm_policy_walk_done(walk, net);\n\treturn 0;\n}", "target": 1}
{"code": "doIgnoreSection(XML_Parser parser, const ENCODING *enc, const char **startPtr,\n                const char *end, const char **nextPtr, XML_Bool haveMore) {\n  const char *next = *startPtr; \n  int tok;\n  const char *s = *startPtr;\n  const char **eventPP;\n  const char **eventEndPP;\n  if (enc == parser->m_encoding) {\n    eventPP = &parser->m_eventPtr;\n    *eventPP = s;\n    eventEndPP = &parser->m_eventEndPtr;\n  } else {\n    eventPP = &(parser->m_openInternalEntities->internalEventPtr);\n    eventEndPP = &(parser->m_openInternalEntities->internalEventEndPtr);\n  }\n  *eventPP = s;\n  *startPtr = NULL;\n  tok = XmlIgnoreSectionTok(enc, s, end, &next);\n#  ifdef XML_DTD\n  if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                XML_ACCOUNT_DIRECT)) {\n    accountingOnAbort(parser);\n    return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n  }\n#  endif\n  *eventEndPP = next;\n  switch (tok) {\n  case XML_TOK_IGNORE_SECT:\n    if (parser->m_defaultHandler)\n      reportDefault(parser, enc, s, next);\n    *startPtr = next;\n    *nextPtr = next;\n    if (parser->m_parsingStatus.parsing == XML_FINISHED)\n      return XML_ERROR_ABORTED;\n    else\n      return XML_ERROR_NONE;\n  case XML_TOK_INVALID:\n    *eventPP = next;\n    return XML_ERROR_INVALID_TOKEN;\n  case XML_TOK_PARTIAL_CHAR:\n    if (haveMore) {\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    }\n    return XML_ERROR_PARTIAL_CHAR;\n  case XML_TOK_PARTIAL:\n  case XML_TOK_NONE:\n    if (haveMore) {\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    }\n    return XML_ERROR_SYNTAX; \n  default:\n    *eventPP = next;\n    return XML_ERROR_UNEXPECTED_STATE;\n  }\n}", "target": 1}
{"code": "MOBI_RET mobi_parse_huffdic(const MOBIData *m, MOBIHuffCdic *huffcdic) {\n    MOBI_RET ret;\n    const size_t offset = mobi_get_kf8offset(m);\n    if (m->mh == NULL || m->mh->huff_rec_index == NULL || m->mh->huff_rec_count == NULL) {\n        debug_print(\"%s\", \"HUFF/CDIC records metadata not found in MOBI header\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    const size_t huff_rec_index = *m->mh->huff_rec_index + offset;\n    const size_t huff_rec_count = *m->mh->huff_rec_count;\n    if (huff_rec_count > HUFF_RECORD_MAXCNT) {\n        debug_print(\"Too many HUFF record (%zu)\\n\", huff_rec_count);\n        return MOBI_DATA_CORRUPT;\n    }\n    const MOBIPdbRecord *curr = mobi_get_record_by_seqnumber(m, huff_rec_index);\n    if (curr == NULL || huff_rec_count < 2) {\n        debug_print(\"%s\", \"HUFF/CDIC record not found\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    if (curr->size < HUFF_RECORD_MINSIZE) {\n        debug_print(\"HUFF record too short (%zu b)\\n\", curr->size);\n        return MOBI_DATA_CORRUPT;\n    }\n    ret = mobi_parse_huff(huffcdic, curr);\n    if (ret != MOBI_SUCCESS) {\n        debug_print(\"%s\", \"HUFF parsing failed\\n\");\n        return ret;\n    }\n    curr = curr->next;\n    huffcdic->symbols = malloc((huff_rec_count - 1) * sizeof(*huffcdic->symbols));\n    if (huffcdic->symbols == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    size_t i = 0;\n    while (i < huff_rec_count - 1) {\n        if (curr == NULL) {\n            debug_print(\"%s\\n\", \"CDIC record not found\");\n            return MOBI_DATA_CORRUPT;\n        }\n        ret = mobi_parse_cdic(huffcdic, curr, i++);\n        if (ret != MOBI_SUCCESS) {\n            debug_print(\"%s\", \"CDIC parsing failed\\n\");\n            return ret;\n        }\n        curr = curr->next;\n    }\n    if (huffcdic->index_count != huffcdic->index_read) {\n        debug_print(\"CDIC: wrong read index count: %zu, total: %zu\\n\", huffcdic->index_read, huffcdic->index_count);\n        return MOBI_DATA_CORRUPT;\n    }\n    return MOBI_SUCCESS;\n}", "target": 0}
{"code": "parse_user_name(char *user_input, char **ret_username)\n{\n\tregister char *ptr;\n\tregister int index = 0;\n\tchar username[PAM_MAX_RESP_SIZE];\n\t*ret_username = NULL;\n\tbzero((void *)username, PAM_MAX_RESP_SIZE);\n\tptr = user_input;\n\twhile ((*ptr == ' ') || (*ptr == '\\t'))\n\t\tptr++;\n\tif (*ptr == '\\0') {\n\t\treturn (PAM_BUF_ERR);\n\t}\n\twhile (*ptr != '\\0') {\n\t\tif ((*ptr == ' ') || (*ptr == '\\t'))\n\t\t\tbreak;\n\t\telse {\n\t\t\tusername[index] = *ptr;\n\t\t\tindex++;\n\t\t\tptr++;\n\t\t}\n\t}\n\tif ((*ret_username = malloc(index + 1)) == NULL)\n\t\treturn (PAM_BUF_ERR);\n\t(void) strcpy(*ret_username, username);\n\treturn (PAM_SUCCESS);\n}", "target": 1}
{"code": "htc_request_check_hdrs(struct sess *sp, struct http *hp)\n{\n\tint u;\n\tint seen_host = 0;\n\tint seen_cl = 0;\n\tfor (u = HTTP_HDR_FIRST; u < hp->nhd; u++) {\n\t\tif (hp->hd[u].b == NULL)\n\t\t\tcontinue;\n\t\tAN(hp->hd[u].b);\n\t\tAN(hp->hd[u].e);\n\t\tif (http_IsHdr(&hp->hd[u], H_Host)) {\n\t\t\tif (seen_host) {\n\t\t\t\tWSP(sp, SLT_Error, \"Duplicated Host header\");\n\t\t\t\treturn (400);\n\t\t\t}\n\t\t\tseen_host = 1;\n\t\t}\n\t\tif (http_IsHdr(&hp->hd[u], H_Content_Length)) {\n\t\t\tif (seen_cl) {\n\t\t\t\tWSP(sp, SLT_Error,\n\t\t\t\t    \"Duplicated Content-Length header\");\n\t\t\t\treturn (400);\n\t\t\t}\n\t\t\tseen_cl = 1;\n\t\t}\n\t}\n\treturn (0);\n}", "target": 0}
{"code": "int virtio_gpu_object_create(struct virtio_gpu_device *vgdev,\n\t\t\t     unsigned long size, bool kernel, bool pinned,\n\t\t\t     struct virtio_gpu_object **bo_ptr)\n{\n\tstruct virtio_gpu_object *bo;\n\tenum ttm_bo_type type;\n\tsize_t acc_size;\n\tint ret;\n\tif (kernel)\n\t\ttype = ttm_bo_type_kernel;\n\telse\n\t\ttype = ttm_bo_type_device;\n\t*bo_ptr = NULL;\n\tacc_size = ttm_bo_dma_acc_size(&vgdev->mman.bdev, size,\n\t\t\t\t       sizeof(struct virtio_gpu_object));\n\tbo = kzalloc(sizeof(struct virtio_gpu_object), GFP_KERNEL);\n\tif (bo == NULL)\n\t\treturn -ENOMEM;\n\tsize = roundup(size, PAGE_SIZE);\n\tret = drm_gem_object_init(vgdev->ddev, &bo->gem_base, size);\n\tif (ret != 0)\n\t\treturn ret;\n\tbo->dumb = false;\n\tvirtio_gpu_init_ttm_placement(bo, pinned);\n\tret = ttm_bo_init(&vgdev->mman.bdev, &bo->tbo, size, type,\n\t\t\t  &bo->placement, 0, !kernel, NULL, acc_size,\n\t\t\t  NULL, NULL, &virtio_gpu_ttm_bo_destroy);\n\tif (ret != 0)\n\t\treturn ret;\n\t*bo_ptr = bo;\n\treturn 0;\n}", "target": 1}
{"code": "static void nft_objref_map_activate(const struct nft_ctx *ctx,\n\t\t\t\t    const struct nft_expr *expr)\n{\n\tstruct nft_objref_map *priv = nft_expr_priv(expr);\n\tpriv->set->use++;\n}", "target": 1}
{"code": "static void ax25_kill_by_device(struct net_device *dev)\n{\n\tax25_dev *ax25_dev;\n\tax25_cb *s;\n\tstruct sock *sk;\n\tif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\n\t\treturn;\n\tspin_lock_bh(&ax25_list_lock);\nagain:\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->ax25_dev == ax25_dev) {\n\t\t\tsk = s->sk;\n\t\t\tif (!sk) {\n\t\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\t\ts->ax25_dev = NULL;\n\t\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\t\tspin_lock_bh(&ax25_list_lock);\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tsock_hold(sk);\n\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\tlock_sock(sk);\n\t\t\ts->ax25_dev = NULL;\n\t\t\tif (sk->sk_socket) {\n\t\t\t\tdev_put_track(ax25_dev->dev, &ax25_dev->dev_tracker);\n\t\t\t\tax25_dev_put(ax25_dev);\n\t\t\t}\n\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\trelease_sock(sk);\n\t\t\tspin_lock_bh(&ax25_list_lock);\n\t\t\tsock_put(sk);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock_bh(&ax25_list_lock);\n}", "target": 1}
{"code": "static void rtrs_clt_dev_release(struct device *dev)\n{\n\tstruct rtrs_clt_sess *clt = container_of(dev, struct rtrs_clt_sess,\n\t\t\t\t\t\t dev);\n\tmutex_destroy(&clt->paths_ev_mutex);\n\tmutex_destroy(&clt->paths_mutex);\n\tkfree(clt);\n}", "target": 0}
{"code": "static uint get_alen(char *arg, int default_len)\n{\n\tint\tj;\n\tint\talen;\n\talen = default_len;\n\tfor (j = 0; j < 8; j++) {\n\t\tif (arg[j] == '.') {\n\t\t\talen = arg[j+1] - '0';\n\t\t\tbreak;\n\t\t} else if (arg[j] == '\\0')\n\t\t\tbreak;\n\t}\n\treturn alen;\n}", "target": 1}
{"code": "void lsetCommand(client *c) {\n    robj *o = lookupKeyWriteOrReply(c,c->argv[1],shared.nokeyerr);\n    if (o == NULL || checkType(c,o,OBJ_LIST)) return;\n    long index;\n    robj *value = c->argv[3];\n    if (sdslen(value->ptr) > LIST_MAX_ITEM_SIZE) {\n        addReplyError(c, \"Element too large\");\n        return;\n    }\n    if ((getLongFromObjectOrReply(c, c->argv[2], &index, NULL) != C_OK))\n        return;\n    if (o->encoding == OBJ_ENCODING_QUICKLIST) {\n        quicklist *ql = o->ptr;\n        int replaced = quicklistReplaceAtIndex(ql, index,\n                                               value->ptr, sdslen(value->ptr));\n        if (!replaced) {\n            addReply(c,shared.outofrangeerr);\n        } else {\n            addReply(c,shared.ok);\n            signalModifiedKey(c,c->db,c->argv[1]);\n            notifyKeyspaceEvent(NOTIFY_LIST,\"lset\",c->argv[1],c->db->id);\n            server.dirty++;\n        }\n    } else {\n        serverPanic(\"Unknown list encoding\");\n    }\n}", "target": 0}
{"code": "void blog_post(char post_path[]) {\n\tif(strlen(post_path) != 0 || post_path[0] == '.'\n\t\t\t|| strchr(post_path, '/') == NULL) {\n\t\tsend_header(\"Content-type\", \"text/plain\");\n\t\tterminate_headers();\n\t\tprintf(\"No, my dear h4xxx0r :)\\nYou won\\'t do that :p\\n\");\n\t\treturn;\n\t}\n\tif(file_exists(post_path) > 0) {\n\t\tstruct blogpost post = make_blogpost(post_path);\n\t\tsend_header(\"Content-type\", \"text/html\");\n\t\tterminate_headers();\n\t\ttemplate_header();\n\t\ttemplate_post_single_entry(post);\n\t} else {\n\t\tsend_header(\"Content-type\", \"text/html\");\n\t\tsend_header(\"Status\", \"404 Not Found\");\n\t\tterminate_headers();\n\t\ttemplate_header();\n\t\ttemplate_error_404();\n\t}\n\ttemplate_footer();\n}", "target": 0}
{"code": "void TestJlCompress::extractDir_data()\n{\n    QTest::addColumn<QString>(\"zipName\");\n    QTest::addColumn<QStringList>(\"fileNames\");\n    QTest::newRow(\"simple\") << \"jlextdir.zip\" << (\n            QStringList() << \"test0.txt\" << \"testdir1/test1.txt\"\n            << \"testdir2/test2.txt\" << \"testdir2/subdir/test2sub.txt\");\n    QTest::newRow(\"separate dir\") << \"sepdir.zip\" << (\n            QStringList() << \"laj/\" << \"laj/lajfile.txt\");\n}", "target": 1}
{"code": "static void seg_setup(int seg)\n{\n\tconst struct kvm_vmx_segment_field *sf = &kvm_vmx_segment_fields[seg];\n\tunsigned int ar;\n\tvmcs_write16(sf->selector, 0);\n\tvmcs_writel(sf->base, 0);\n\tvmcs_write32(sf->limit, 0xffff);\n\tar = 0x93;\n\tif (seg == VCPU_SREG_CS)\n\t\tar |= 0x08; \n\tvmcs_write32(sf->ar_bytes, ar);\n}", "target": 0}
{"code": "createFile(const string &filename, const StaticString &contents, mode_t permissions, uid_t owner,\n\tgid_t group, bool overwrite)\n{\n\tFileDescriptor fd;\n\tint ret, e, options;\n\toptions = O_WRONLY | O_CREAT | O_TRUNC;\n\tif (!overwrite) {\n\t\toptions |= O_EXCL;\n\t}\n\tdo {\n\t\tfd = open(filename.c_str(), options, permissions);\n\t} while (fd == -1 && errno == EINTR);\n\tif (fd != -1) {\n\t\tFileGuard guard(filename);\n\t\tdo {\n\t\t\tret = fchmod(fd, permissions);\n\t\t} while (ret == -1 && errno == EINTR);\n\t\tif (ret == -1) {\n\t\t\te = errno;\n\t\t\tthrow FileSystemException(\"Cannot set permissions on \" + filename,\n\t\t\t\te, filename);\n\t\t}\n\t\tif (owner != USER_NOT_GIVEN && group != GROUP_NOT_GIVEN) {\n\t\t\tif (owner == USER_NOT_GIVEN) {\n\t\t\t\towner = (uid_t) -1; \n\t\t\t}\n\t\t\tif (group == GROUP_NOT_GIVEN) {\n\t\t\t\tgroup = (gid_t) -1; \n\t\t\t}\n\t\t\tdo {\n\t\t\t\tret = fchown(fd, owner, group);\n\t\t\t} while (ret == -1 && errno == EINTR);\n\t\t\tif (ret == -1) {\n\t\t\t\te = errno;\n\t\t\t\tthrow FileSystemException(\"Cannot set ownership for \" + filename,\n\t\t\t\t\te, filename);\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\twriteExact(fd, contents);\n\t\t\tfd.close();\n\t\t} catch (const SystemException &e) {\n\t\t\tthrow FileSystemException(\"Cannot write to file \" + filename,\n\t\t\t\te.code(), filename);\n\t\t}\n\t\tguard.commit();\n\t} else {\n\t\te = errno;\n\t\tif (overwrite || e != EEXIST) {\n\t\t\tthrow FileSystemException(\"Cannot create file \" + filename,\n\t\t\t\te, filename);\n\t\t}\n\t}\n}", "target": 0}
{"code": "noop_post_process (j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n                   JDIMENSION *in_row_group_ctr,\n                   JDIMENSION in_row_groups_avail, JSAMPARRAY output_buf,\n                   JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)\n{\n}", "target": 0}
{"code": "static int sd_isoc_init(struct gspca_dev *gspca_dev)\n{\n\tstruct usb_host_interface *alt;\n\tint max_packet_size;\n\tswitch (gspca_dev->pixfmt.width) {\n\tcase 160:\n\t\tmax_packet_size = 450;\n\t\tbreak;\n\tcase 176:\n\t\tmax_packet_size = 600;\n\t\tbreak;\n\tdefault:\n\t\tmax_packet_size = 1022;\n\t\tbreak;\n\t}\n\talt = &gspca_dev->dev->actconfig->intf_cache[0]->altsetting[1];\n\talt->endpoint[0].desc.wMaxPacketSize = cpu_to_le16(max_packet_size);\n\treturn 0;\n}", "target": 1}
{"code": "int ext4_filemap_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tint err;\n\tdown_read(&EXT4_I(inode)->i_mmap_sem);\n\terr = filemap_fault(vma, vmf);\n\tup_read(&EXT4_I(inode)->i_mmap_sem);\n\treturn err;\n}", "target": 0}
{"code": "static int open_without_symlink(const char *target, const char *prefix_skip)\n{\n\tint curlen = 0, dirfd, fulllen, i;\n\tchar *dup = NULL;\n\tfulllen = strlen(target);\n\tif (prefix_skip) {\n\t\tcurlen = strlen(prefix_skip);\n\t\tif (!is_subdir(target, prefix_skip, curlen)) {\n\t\t\tERROR(\"WHOA there - target '%s' didn't start with prefix '%s'\",\n\t\t\t\ttarget, prefix_skip);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (curlen)\n\t\t\tcurlen--;\n\t} else {\n\t\tprefix_skip = \"/\";\n\t\tcurlen = 0;\n\t}\n\tif ((dup = strdup(target)) == NULL) {\n\t\tSYSERROR(\"Out of memory checking for symbolic link\");\n\t\treturn -ENOMEM;\n\t}\n\tfor (i = 0; i < fulllen; i++) {\n\t\tif (dup[i] == '/')\n\t\t\tdup[i] = '\\0';\n\t}\n\tdirfd = open(prefix_skip, O_RDONLY);\n\tif (dirfd < 0)\n\t\tgoto out;\n\twhile (1) {\n\t\tint newfd, saved_errno;\n\t\tchar *nextpath;\n\t\tif ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)\n\t\t\tgoto out;\n\t\tnewfd = open_if_safe(dirfd, nextpath);\n\t\tsaved_errno = errno;\n\t\tclose(dirfd);\n\t\tdirfd = newfd;\n\t\tif (newfd < 0) {\n\t\t\terrno = saved_errno;\n\t\t\tif (errno == ELOOP)\n\t\t\t\tSYSERROR(\"%s in %s was a symbolic link!\", nextpath, target);\n\t\t\telse\n\t\t\t\tSYSERROR(\"Error examining %s in %s\", nextpath, target);\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tfree(dup);\n\treturn dirfd;\n}", "target": 0}
{"code": "void flush_tlb_current_task(void)\n{\n\tstruct mm_struct *mm = current->mm;\n\tpreempt_disable();\n\tcount_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ALL);\n\tlocal_flush_tlb();\n\ttrace_tlb_flush(TLB_LOCAL_SHOOTDOWN, TLB_FLUSH_ALL);\n\tif (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) < nr_cpu_ids)\n\t\tflush_tlb_others(mm_cpumask(mm), mm, 0UL, TLB_FLUSH_ALL);\n\tpreempt_enable();\n}", "target": 0}
{"code": "void ServerSecurityFeature::collectOptions(std::shared_ptr<ProgramOptions> options) {\n  options->addOption(\"--server.harden\",\n                     \"lock down REST APIs that reveal version information or server \"\n                     \"internals for non-admin users\",\n                     new BooleanParameter(&_hardenedRestApi))\n                     .setIntroducedIn(30500);\n  options->addOption(\"--foxx.api\", \"enables Foxx management REST APIs\",\n                     new BooleanParameter(&_enableFoxxApi),\n                     arangodb::options::makeFlags(\n                     arangodb::options::Flags::DefaultNoComponents,\n                     arangodb::options::Flags::OnCoordinator,\n                     arangodb::options::Flags::OnSingle))\n                     .setIntroducedIn(30500);\n  options->addOption(\"--foxx.store\", \"enables Foxx store in web interface\",\n                     new BooleanParameter(&_enableFoxxStore),\n                     arangodb::options::makeFlags(\n                     arangodb::options::Flags::DefaultNoComponents,\n                     arangodb::options::Flags::OnCoordinator,\n                     arangodb::options::Flags::OnSingle))\n                     .setIntroducedIn(30500);\n}", "target": 1}
{"code": "ApplyChannelMatrix::~ApplyChannelMatrix()\n{\n\tdelete [] m_matrix;\n}", "target": 0}
{"code": "int test_gtpu_send_indirect_data_forwarding(\n        ogs_socknode_t *node, test_bearer_t *bearer, ogs_pkbuf_t *pkbuf)\n{\n    test_sess_t *sess = NULL;\n    ogs_gtp2_header_t gtp_hdesc;\n    ogs_gtp2_extension_header_t ext_hdesc;\n    ogs_assert(bearer);\n    sess = bearer->sess;\n    ogs_assert(sess);\n    ogs_assert(pkbuf);\n    memset(&gtp_hdesc, 0, sizeof(gtp_hdesc));\n    memset(&ext_hdesc, 0, sizeof(ext_hdesc));\n    gtp_hdesc.type = OGS_GTPU_MSGTYPE_GPDU;\n    if (bearer->qfi) {\n        gtp_hdesc.teid = sess->handover.upf_dl_teid;\n        ext_hdesc.qos_flow_identifier = bearer->qfi;\n    } else if (bearer->ebi) {\n        ogs_fatal(\"Not implmented EPC Indirect Tunnel\");\n        ogs_assert_if_reached();\n    } else {\n        ogs_fatal(\"No QFI[%d] and EBI[%d]\", bearer->qfi, bearer->ebi);\n        ogs_assert_if_reached();\n    }\n    return test_gtpu_send(node, bearer, &gtp_hdesc, &ext_hdesc, pkbuf);\n}", "target": 1}
{"code": "void BinaryProtocolReader::readStringBody(StrType& str, int32_t size) {\n  checkStringSize(size);\n  if (size == 0) {\n    str.clear();\n    return;\n  }\n  if (static_cast<int32_t>(in_.length()) < size) {\n    if (!in_.canAdvance(size)) {\n      protocol::TProtocolException::throwTruncatedData();\n    }\n    str.reserve(size); \n  }\n  str.clear();\n  size_t size_left = size;\n  while (size_left > 0) {\n    auto data = in_.peekBytes();\n    auto data_avail = std::min(data.size(), size_left);\n    if (data.empty()) {\n      TProtocolException::throwExceededSizeLimit();\n    }\n    str.append((const char*)data.data(), data_avail);\n    size_left -= data_avail;\n    in_.skipNoAdvance(data_avail);\n  }\n}", "target": 0}
{"code": "static int op_get_data(OggOpusFile *_of,int _nbytes){\n  unsigned char *buffer;\n  int            nbytes;\n  OP_ASSERT(_nbytes>0);\n  buffer=(unsigned char *)ogg_sync_buffer(&_of->oy,_nbytes);\n  if(OP_UNLIKELY(buffer==NULL))return OP_EFAULT;\n  nbytes=(int)(*_of->callbacks.read)(_of->stream,buffer,_nbytes);\n  OP_ASSERT(nbytes<=_nbytes);\n  if(OP_LIKELY(nbytes>0))ogg_sync_wrote(&_of->oy,nbytes);\n  return nbytes;\n}", "target": 0}
{"code": "bool StringSanMatcher::match(const GENERAL_NAME* general_name) const {\n  if (general_name->type != general_name_type_) {\n    return false;\n  }\n  const std::string san = Utility::generalNameAsString(general_name);\n  return general_name->type == GEN_DNS &&\n                 matcher_.matcher().match_pattern_case() ==\n                     envoy::type::matcher::v3::StringMatcher::MatchPatternCase::kExact\n             ? Utility::dnsNameMatch(matcher_.matcher().exact(), absl::string_view(san))\n             : matcher_.match(san);\n}", "target": 0}
{"code": "njs_module_path(njs_vm_t *vm, const njs_str_t *dir, njs_module_info_t *info)\n{\n    char        *p;\n    size_t      length;\n    njs_bool_t  trail;\n    char        src[NJS_MAX_PATH + 1];\n    trail = 0;\n    length = info->name.length;\n    if (dir != NULL) {\n        length = dir->length;\n        if (length == 0) {\n            return NJS_DECLINED;\n        }\n        trail = (dir->start[dir->length - 1] != '/');\n        if (trail) {\n            length++;\n        }\n    }\n    if (njs_slow_path(length > NJS_MAX_PATH)) {\n        return NJS_ERROR;\n    }\n    p = &src[0];\n    if (dir != NULL) {\n        p = (char *) njs_cpymem(p, dir->start, dir->length);\n        if (trail) {\n            *p++ = '/';\n        }\n    }\n    p = (char *) njs_cpymem(p, info->name.start, info->name.length);\n    *p = '\\0';\n    p = realpath(&src[0], &info->path[0]);\n    if (p == NULL) {\n        return NJS_DECLINED;\n    }\n    info->fd = open(&info->path[0], O_RDONLY);\n    if (info->fd < 0) {\n        return NJS_DECLINED;\n    }\n    info->file.start = (u_char *) &info->path[0];\n    info->file.length = njs_strlen(info->file.start);\n    return NJS_OK;\n}", "target": 1}
{"code": "ble_hs_conn_timer(void)\n{\n#if MYNEWT_VAL(BLE_L2CAP_RX_FRAG_TIMEOUT) == 0 && \\\n    BLE_HS_ATT_SVR_QUEUED_WRITE_TMO == 0\n    return BLE_HS_FOREVER;\n#endif\n    struct ble_hs_conn *conn;\n    ble_npl_time_t now;\n    int32_t next_exp_in;\n    int32_t time_diff;\n    uint16_t conn_handle;\n    for (;;) {\n        conn_handle = BLE_HS_CONN_HANDLE_NONE;\n        next_exp_in = BLE_HS_FOREVER;\n        now = ble_npl_time_get();\n        ble_hs_lock();\n        SLIST_FOREACH(conn, &ble_hs_conns, bhc_next) {\n            if (!(conn->bhc_flags & BLE_HS_CONN_F_TERMINATING)) {\n#if MYNEWT_VAL(BLE_L2CAP_RX_FRAG_TIMEOUT) != 0\n                if (conn->bhc_rx_chan != NULL) {\n                    time_diff = conn->bhc_rx_timeout - now;\n                    if (time_diff <= 0) {\n                        conn_handle = conn->bhc_handle;\n                        break;\n                    }\n                    if (time_diff < next_exp_in) {\n                        next_exp_in = time_diff;\n                    }\n                }\n#endif\n#if BLE_HS_ATT_SVR_QUEUED_WRITE_TMO\n                time_diff = ble_att_svr_ticks_until_tmo(&conn->bhc_att_svr, now);\n                if (time_diff <= 0) {\n                    conn_handle = conn->bhc_handle;\n                    break;\n                }\n                if (time_diff < next_exp_in) {\n                    next_exp_in = time_diff;\n                }\n#endif\n            }\n        }\n        ble_hs_unlock();\n        if (conn_handle != BLE_HS_CONN_HANDLE_NONE) {\n            ble_gap_terminate(conn_handle, BLE_ERR_REM_USER_CONN_TERM);\n            continue;\n        }\n        return next_exp_in;\n    }\n}", "target": 1}
{"code": "static inline struct anon_vma *anon_vma_alloc(void)\n{\n\tstruct anon_vma *anon_vma;\n\tanon_vma = kmem_cache_alloc(anon_vma_cachep, GFP_KERNEL);\n\tif (anon_vma) {\n\t\tatomic_set(&anon_vma->refcount, 1);\n\t\tanon_vma->degree = 1;\t\n\t\tanon_vma->parent = anon_vma;\n\t\tanon_vma->root = anon_vma;\n\t}\n\treturn anon_vma;\n}", "target": 1}
{"code": "int anon_vma_fork(struct vm_area_struct *vma, struct vm_area_struct *pvma)\n{\n\tstruct anon_vma_chain *avc;\n\tstruct anon_vma *anon_vma;\n\tint error;\n\tif (!pvma->anon_vma)\n\t\treturn 0;\n\tvma->anon_vma = NULL;\n\terror = anon_vma_clone(vma, pvma);\n\tif (error)\n\t\treturn error;\n\tif (vma->anon_vma)\n\t\treturn 0;\n\tanon_vma = anon_vma_alloc();\n\tif (!anon_vma)\n\t\tgoto out_error;\n\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\tif (!avc)\n\t\tgoto out_error_free_anon_vma;\n\tanon_vma->root = pvma->anon_vma->root;\n\tanon_vma->parent = pvma->anon_vma;\n\tget_anon_vma(anon_vma->root);\n\tvma->anon_vma = anon_vma;\n\tanon_vma_lock_write(anon_vma);\n\tanon_vma_chain_link(vma, avc, anon_vma);\n\tanon_vma->parent->degree++;\n\tanon_vma_unlock_write(anon_vma);\n\treturn 0;\n out_error_free_anon_vma:\n\tput_anon_vma(anon_vma);\n out_error:\n\tunlink_anon_vmas(vma);\n\treturn -ENOMEM;\n}", "target": 1}
{"code": "de265_error decoder_context::read_pps_NAL(bitreader& reader)\n{\n  logdebug(LogHeaders,\"----> read PPS\\n\");\n  std::shared_ptr<pic_parameter_set> new_pps = std::make_shared<pic_parameter_set>();\n  bool success = new_pps->read(&reader,this);\n  if (param_pps_headers_fd>=0) {\n    new_pps->dump(param_pps_headers_fd);\n  }\n  if (success) {\n    pps[ (int)new_pps->pic_parameter_set_id ] = new_pps;\n  }\n  return success ? DE265_OK : DE265_WARNING_PPS_HEADER_INVALID;\n}", "target": 1}
{"code": "static int cdrom_ioctl_select_disc(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_SELECT_DISC\\n\");\n\tif (!CDROM_CAN(CDC_SELECT_DISC))\n\t\treturn -ENOSYS;\n\tif (arg != CDSL_CURRENT && arg != CDSL_NONE) {\n\t\tif ((int)arg >= cdi->capacity)\n\t\t\treturn -EINVAL;\n\t}\n\tif (cdi->ops->select_disc)\n\t\treturn cdi->ops->select_disc(cdi, arg);\n\tcd_dbg(CD_CHANGER, \"Using generic cdrom_select_disc()\\n\");\n\treturn cdrom_select_disc(cdi, arg);\n}", "target": 1}
{"code": "FramebufferModel::FramebufferModel(QObject* parent)\n  : QObject(parent)\n  , m_pixelBuffer(nullptr)\n  , m_width(0)\n  , m_height(0)\n  , m_isImageLoaded(false)\n  , m_exposure(0)\n  , m_imageLoadingWatcher(new QFutureWatcher<void>(this))\n  , m_imageEditingWatcher(new QFutureWatcher<void>(this))\n  , m_pixelAspectRatio(1.f)\n{}", "target": 1}
{"code": "void TestDecodeGif(Env* env, DecodeGifTestCase testcase) {\n  string gif;\n  ReadFileToStringOrDie(env, testcase.filepath, &gif);\n  std::unique_ptr<uint8[]> imgdata;\n  int nframes, w, h, c;\n  string error_string;\n  imgdata.reset(gif::Decode(\n      gif.data(), gif.size(),\n      [&](int frame_cnt, int width, int height, int channels) -> uint8* {\n        nframes = frame_cnt;\n        w = width;\n        h = height;\n        c = channels;\n        return new uint8[frame_cnt * height * width * channels];\n      },\n      &error_string));\n  ASSERT_NE(imgdata, nullptr);\n  ASSERT_EQ(nframes, testcase.num_frames);\n  ASSERT_EQ(w, testcase.width);\n  ASSERT_EQ(h, testcase.height);\n  ASSERT_EQ(c, testcase.channels);\n}", "target": 1}
{"code": "static char *__filterShell(const char *arg) {\n\tr_return_val_if_fail (arg, NULL);\n\tchar *a = malloc (strlen (arg) + 1);\n\tif (!a) {\n\t\treturn NULL;\n\t}\n\tchar *b = a;\n\twhile (*arg) {\n\t\tswitch (*arg) {\n\t\tcase '@':\n\t\tcase '`':\n\t\tcase '|':\n\t\tcase ';':\n\t\tcase '\\n':\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*b++ = *arg;\n\t\t\tbreak;\n\t\t}\n\t\targ++;\n\t}\n\t*b = 0;\n\treturn a;\n}", "target": 1}
{"code": "null_if_print(netdissect_options *ndo, const struct pcap_pkthdr *h, const u_char *p)\n{\n\tu_int length = h->len;\n\tu_int caplen = h->caplen;\n\tu_int family;\n\tif (caplen < NULL_HDRLEN) {\n\t\tND_PRINT((ndo, \"[|null]\"));\n\t\treturn (NULL_HDRLEN);\n\t}\n\tmemcpy((char *)&family, (const char *)p, sizeof(family));\n\tif ((family & 0xFFFF0000) != 0)\n\t\tfamily = SWAPLONG(family);\n\tif (ndo->ndo_eflag)\n\t\tnull_hdr_print(ndo, family, length);\n\tlength -= NULL_HDRLEN;\n\tcaplen -= NULL_HDRLEN;\n\tp += NULL_HDRLEN;\n\tswitch (family) {\n\tcase BSD_AFNUM_INET:\n\t\tip_print(ndo, p, length);\n\t\tbreak;\n\tcase BSD_AFNUM_INET6_BSD:\n\tcase BSD_AFNUM_INET6_FREEBSD:\n\tcase BSD_AFNUM_INET6_DARWIN:\n\t\tip6_print(ndo, p, length);\n\t\tbreak;\n\tcase BSD_AFNUM_ISO:\n\t\tisoclns_print(ndo, p, length, caplen);\n\t\tbreak;\n\tcase BSD_AFNUM_APPLETALK:\n\t\tatalk_print(ndo, p, length);\n\t\tbreak;\n\tcase BSD_AFNUM_IPX:\n\t\tipx_print(ndo, p, length);\n\t\tbreak;\n\tdefault:\n\t\tif (!ndo->ndo_eflag)\n\t\t\tnull_hdr_print(ndo, family, length + NULL_HDRLEN);\n\t\tif (!ndo->ndo_suppress_default_print)\n\t\t\tND_DEFAULTPRINT(p, caplen);\n\t}\n\treturn (NULL_HDRLEN);\n}", "target": 1}
{"code": "static zend_always_inline zend_string* __zval_get_string_func(zval *op, zend_bool try) \n{\ntry_again:\n\tswitch (Z_TYPE_P(op)) {\n\t\tcase IS_UNDEF:\n\t\tcase IS_NULL:\n\t\tcase IS_FALSE:\n\t\t\treturn ZSTR_EMPTY_ALLOC();\n\t\tcase IS_TRUE:\n\t\t\treturn ZSTR_CHAR('1');\n\t\tcase IS_RESOURCE: {\n\t\t\treturn zend_strpprintf(0, \"Resource id #\" ZEND_LONG_FMT, (zend_long)Z_RES_HANDLE_P(op));\n\t\t}\n\t\tcase IS_LONG: {\n\t\t\treturn zend_long_to_str(Z_LVAL_P(op));\n\t\t}\n\t\tcase IS_DOUBLE: {\n\t\t\treturn zend_strpprintf(0, \"%.*G\", (int) EG(precision), Z_DVAL_P(op));\n\t\t}\n\t\tcase IS_ARRAY:\n\t\t\tzend_error(E_NOTICE, \"Array to string conversion\");\n\t\t\treturn (try && UNEXPECTED(EG(exception))) ?\n\t\t\t\tNULL : ZSTR_KNOWN(ZEND_STR_ARRAY_CAPITALIZED);\n\t\tcase IS_OBJECT: {\n\t\t\tzval tmp;\n\t\t\tif (Z_OBJ_HT_P(op)->cast_object) {\n\t\t\t\tif (Z_OBJ_HT_P(op)->cast_object(op, &tmp, IS_STRING) == SUCCESS) {\n\t\t\t\t\treturn Z_STR(tmp);\n\t\t\t\t}\n\t\t\t} else if (Z_OBJ_HT_P(op)->get) {\n\t\t\t\tzval *z = Z_OBJ_HT_P(op)->get(op, &tmp);\n\t\t\t\tif (Z_TYPE_P(z) != IS_OBJECT) {\n\t\t\t\t\tzend_string *str = try ? zval_try_get_string(z) : zval_get_string(z);\n\t\t\t\t\tzval_ptr_dtor(z);\n\t\t\t\t\treturn str;\n\t\t\t\t}\n\t\t\t\tzval_ptr_dtor(z);\n\t\t\t}\n\t\t\tif (!EG(exception)) {\n\t\t\t\tzend_throw_error(NULL, \"Object of class %s could not be converted to string\", ZSTR_VAL(Z_OBJCE_P(op)->name));\n\t\t\t}\n\t\t\treturn try ? NULL : ZSTR_EMPTY_ALLOC();\n\t\t}\n\t\tcase IS_REFERENCE:\n\t\t\top = Z_REFVAL_P(op);\n\t\t\tgoto try_again;\n\t\tcase IS_STRING:\n\t\t\treturn zend_string_copy(Z_STR_P(op));\n\t\tEMPTY_SWITCH_DEFAULT_CASE()\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "static inline bool sctp_peer_needs_update(struct sctp_association *asoc)\n{\n\tstruct net *net = sock_net(asoc->base.sk);\n\tswitch (asoc->state) {\n\tcase SCTP_STATE_ESTABLISHED:\n\tcase SCTP_STATE_SHUTDOWN_PENDING:\n\tcase SCTP_STATE_SHUTDOWN_RECEIVED:\n\tcase SCTP_STATE_SHUTDOWN_SENT:\n\t\tif ((asoc->rwnd > asoc->a_rwnd) &&\n\t\t    ((asoc->rwnd - asoc->a_rwnd) >= max_t(__u32,\n\t\t\t   (asoc->base.sk->sk_rcvbuf >> net->sctp.rwnd_upd_shift),\n\t\t\t   asoc->pathmtu)))\n\t\t\treturn true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn false;\n}", "target": 0}
{"code": "u32 secure_ipv6_port_ephemeral(const __be32 *saddr, const __be32 *daddr,\n\t\t\t       __be16 dport)\n{\n\tstruct keydata *keyptr = get_keyptr();\n\tu32 hash[12];\n\tmemcpy(hash, saddr, 16);\n\thash[4] = (__force u32)dport;\n\tmemcpy(&hash[5], keyptr->secret, sizeof(__u32) * 7);\n\treturn twothirdsMD4Transform((const __u32 *)daddr, hash);\n}", "target": 1}
{"code": "parserule(struct scanner *s, struct environment *env)\n{\n\tstruct rule *r;\n\tchar *var;\n\tstruct evalstring *val;\n\tbool hascommand = false, hasrspfile = false, hasrspcontent = false;\n\tr = mkrule(scanname(s));\n\tscannewline(s);\n\twhile (scanindent(s)) {\n\t\tvar = scanname(s);\n\t\tparselet(s, &val);\n\t\truleaddvar(r, var, val);\n\t\tif (!val)\n\t\t\tcontinue;\n\t\tif (strcmp(var, \"command\") == 0)\n\t\t\thascommand = true;\n\t\telse if (strcmp(var, \"rspfile\") == 0)\n\t\t\thasrspfile = true;\n\t\telse if (strcmp(var, \"rspfile_content\") == 0)\n\t\t\thasrspcontent = true;\n\t}\n\tif (!hascommand)\n\t\tfatal(\"rule '%s' has no command\", r->name);\n\tif (hasrspfile != hasrspcontent)\n\t\tfatal(\"rule '%s' has rspfile and no rspfile_content or vice versa\", r->name);\n\tenvaddrule(env, r);\n}", "target": 0}
{"code": "nfp_abm_u32_knode_replace(struct nfp_abm_link *alink,\n\t\t\t  struct tc_cls_u32_knode *knode,\n\t\t\t  __be16 proto, struct netlink_ext_ack *extack)\n{\n\tstruct nfp_abm_u32_match *match = NULL, *iter;\n\tunsigned int tos_off;\n\tu8 mask, val;\n\tint err;\n\tif (!nfp_abm_u32_check_knode(alink->abm, knode, proto, extack))\n\t\tgoto err_delete;\n\ttos_off = proto == htons(ETH_P_IP) ? 16 : 20;\n\tval = be32_to_cpu(knode->sel->keys[0].val) >> tos_off & 0xff;\n\tmask = be32_to_cpu(knode->sel->keys[0].mask) >> tos_off & 0xff;\n\tlist_for_each_entry(iter, &alink->dscp_map, list) {\n\t\tu32 cmask;\n\t\tif (iter->handle == knode->handle) {\n\t\t\tmatch = iter;\n\t\t\tcontinue;\n\t\t}\n\t\tcmask = iter->mask & mask;\n\t\tif ((iter->val & cmask) == (val & cmask) &&\n\t\t    iter->band != knode->res->classid) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"conflict with already offloaded filter\");\n\t\t\tgoto err_delete;\n\t\t}\n\t}\n\tif (!match) {\n\t\tmatch = kzalloc(sizeof(*match), GFP_KERNEL);\n\t\tif (!match)\n\t\t\treturn -ENOMEM;\n\t\tlist_add(&match->list, &alink->dscp_map);\n\t}\n\tmatch->handle = knode->handle;\n\tmatch->band = knode->res->classid;\n\tmatch->mask = mask;\n\tmatch->val = val;\n\terr = nfp_abm_update_band_map(alink);\n\tif (err)\n\t\tgoto err_delete;\n\treturn 0;\nerr_delete:\n\tnfp_abm_u32_knode_delete(alink, knode);\n\treturn -EOPNOTSUPP;\n}", "target": 1}
{"code": "static inline size_t GetPSDRowSize(Image *image)\n{\n  if (image->depth == 1)\n    return((image->columns+7)/8);\n  else\n    return(image->columns*GetPSDPacketSize(image));\n}", "target": 1}
{"code": "cfm_network_addr_print(netdissect_options *ndo,\n                       register const u_char *tptr)\n{\n    u_int network_addr_type;\n    u_int hexdump =  FALSE;\n    network_addr_type = *tptr;\n    ND_PRINT((ndo, \"\\n\\t  Network Address Type %s (%u)\",\n           tok2str(af_values, \"Unknown\", network_addr_type),\n           network_addr_type));\n    switch(network_addr_type) {\n    case AFNUM_INET:\n        ND_PRINT((ndo, \", %s\", ipaddr_string(ndo, tptr + 1)));\n        break;\n    case AFNUM_INET6:\n        ND_PRINT((ndo, \", %s\", ip6addr_string(ndo, tptr + 1)));\n        break;\n    default:\n        hexdump = TRUE;\n        break;\n    }\n    return hexdump;\n}", "target": 1}
{"code": "static int cert_verify_ignore_callback(X509_STORE_CTX*, void*)\n{\n    return 1;\n}", "target": 0}
{"code": "static bool gguf_ex_read_0(const std::string & fname) {\n    struct gguf_init_params params = {\n         false,\n         NULL,\n    };\n    struct gguf_context * ctx = gguf_init_from_file(fname.c_str(), params);\n    if (!ctx) {\n        fprintf(stderr, \"%s: failed to load '%s'\\n\", __func__, fname.c_str());\n        return false;\n    }\n    printf(\"%s: version:      %d\\n\", __func__, gguf_get_version(ctx));\n    printf(\"%s: alignment:   %zu\\n\", __func__, gguf_get_alignment(ctx));\n    printf(\"%s: data offset: %zu\\n\", __func__, gguf_get_data_offset(ctx));\n    {\n        const int n_kv = gguf_get_n_kv(ctx);\n        printf(\"%s: n_kv: %d\\n\", __func__, n_kv);\n        for (int i = 0; i < n_kv; ++i) {\n            const char * key = gguf_get_key(ctx, i);\n            printf(\"%s: kv[%d]: key = %s\\n\", __func__, i, key);\n        }\n    }\n    {\n        const char * findkey = \"some.parameter.string\";\n        const int keyidx = gguf_find_key(ctx, findkey);\n        if (keyidx == -1) {\n            printf(\"%s: find key: %s not found.\\n\", __func__, findkey);\n        } else {\n            const char * key_value = gguf_get_val_str(ctx, keyidx);\n            printf(\"%s: find key: %s found, kv[%d] value = %s\\n\", __func__, findkey, keyidx, key_value);\n        }\n    }\n    {\n        const int n_tensors = gguf_get_n_tensors(ctx);\n        printf(\"%s: n_tensors: %d\\n\", __func__, n_tensors);\n        for (int i = 0; i < n_tensors; ++i) {\n            const char * name   = gguf_get_tensor_name  (ctx, i);\n            const size_t offset = gguf_get_tensor_offset(ctx, i);\n            printf(\"%s: tensor[%d]: name = %s, offset = %zu\\n\", __func__, i, name, offset);\n        }\n    }\n    gguf_free(ctx);\n    return true;\n}", "target": 0}
{"code": "struct kobject *get_disk(struct gendisk *disk)\n{\n\tstruct module *owner;\n\tstruct kobject *kobj;\n\tif (!disk->fops)\n\t\treturn NULL;\n\towner = disk->fops->owner;\n\tif (owner && !try_module_get(owner))\n\t\treturn NULL;\n\tkobj = kobject_get(&disk_to_dev(disk)->kobj);\n\tif (kobj == NULL) {\n\t\tmodule_put(owner);\n\t\treturn NULL;\n\t}\n\treturn kobj;\n}", "target": 0}
{"code": "int64_t TensorByteSize(const TensorProto& t) {\n  int64_t num_elems = TensorShape(t.tensor_shape()).num_elements();\n  return num_elems < 0 ? -1 : num_elems * DataTypeSize(t.dtype());\n}", "target": 1}
{"code": "static void zend_throw_or_error(int fetch_type, zend_class_entry *exception_ce, const char *format, ...) \n{\n\tva_list va;\n\tchar *message = NULL;\n\tva_start(va, format);\n\tzend_vspprintf(&message, 0, format, va);\n\tif (fetch_type & ZEND_FETCH_CLASS_EXCEPTION) {\n\t\tzend_throw_error(exception_ce, message);\n\t} else {\n\t\tzend_error(E_ERROR, \"%s\", message);\n\t}\n\tefree(message);\n\tva_end(va);\n}", "target": 1}
{"code": "static void br_multicast_del_pg(struct net_bridge *br,\n\t\t\t\tstruct net_bridge_port_group *pg)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tmdb = mlock_dereference(br->mdb, br);\n\tmp = br_mdb_ip_get(mdb, &pg->addr);\n\tif (WARN_ON(!mp))\n\t\treturn;\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (p != pg)\n\t\t\tcontinue;\n\t\trcu_assign_pointer(*pp, p->next);\n\t\thlist_del_init(&p->mglist);\n\t\tdel_timer(&p->timer);\n\t\tcall_rcu_bh(&p->rcu, br_multicast_free_pg);\n\t\tif (!mp->ports && !mp->mglist &&\n\t\t    netif_running(br->dev))\n\t\t\tmod_timer(&mp->timer, jiffies);\n\t\treturn;\n\t}\n\tWARN_ON(1);\n}", "target": 1}
{"code": "static inline void check_buffer(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t struct rb_event_info *info,\n\t\t\t unsigned long tail)\n{\n}", "target": 0}
{"code": "alloc_limit_assert (char *fn_name, size_t size)\n{\n    if (alloc_limit && size > alloc_limit)\n    {\n\talloc_limit_failure (fn_name, size);\n\texit (-1);\n    }\n}", "target": 1}
{"code": "ecma_op_internal_buffer_append (ecma_collection_t *container_p, \n                                ecma_value_t key_arg, \n                                ecma_value_t value_arg, \n                                lit_magic_string_id_t lit_id) \n{\n  JERRY_ASSERT (container_p != NULL);\n  ecma_collection_push_back (container_p, ecma_copy_value_if_not_object (key_arg));\n  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_MAP_UL)\n  {\n    ecma_collection_push_back (container_p, ecma_copy_value_if_not_object (value_arg));\n  }\n  ECMA_CONTAINER_SET_SIZE (container_p, ECMA_CONTAINER_GET_SIZE (container_p) + 1);\n} ", "target": 1}
{"code": "int credential_from_url_gently(struct credential *c, const char *url,\n\t\t\t       int quiet)\n{\n\tconst char *at, *colon, *cp, *slash, *host, *proto_end;\n\tcredential_clear(c);\n\tproto_end = strstr(url, \":\n\tif (!proto_end)\n\t\treturn 0;\n\tcp = proto_end + 3;\n\tat = strchr(cp, '@');\n\tcolon = strchr(cp, ':');\n\tslash = strchrnul(cp, '/');\n\tif (!at || slash <= at) {\n\t\thost = cp;\n\t}\n\telse if (!colon || at <= colon) {\n\t\tc->username = url_decode_mem(cp, at - cp);\n\t\thost = at + 1;\n\t} else {\n\t\tc->username = url_decode_mem(cp, colon - cp);\n\t\tc->password = url_decode_mem(colon + 1, at - (colon + 1));\n\t\thost = at + 1;\n\t}\n\tif (proto_end - url > 0)\n\t\tc->protocol = xmemdupz(url, proto_end - url);\n\tc->host = url_decode_mem(host, slash - host);\n\twhile (*slash == '/')\n\t\tslash++;\n\tif (*slash) {\n\t\tchar *p;\n\t\tc->path = url_decode(slash);\n\t\tp = c->path + strlen(c->path) - 1;\n\t\twhile (p > c->path && *p == '/')\n\t\t\t*p-- = '\\0';\n\t}\n\tif (check_url_component(url, quiet, \"username\", c->username) < 0 ||\n\t    check_url_component(url, quiet, \"password\", c->password) < 0 ||\n\t    check_url_component(url, quiet, \"protocol\", c->protocol) < 0 ||\n\t    check_url_component(url, quiet, \"host\", c->host) < 0 ||\n\t    check_url_component(url, quiet, \"path\", c->path) < 0)\n\t\treturn -1;\n\treturn 0;\n}", "target": 1}
{"code": "nft_meta_get_eval_time(enum nft_meta_keys key,\n\t\t       u32 *dest)\n{\n\tswitch (key) {\n\tcase NFT_META_TIME_NS:\n\t\tnft_reg_store64(dest, ktime_get_real_ns());\n\t\tbreak;\n\tcase NFT_META_TIME_DAY:\n\t\tnft_reg_store8(dest, nft_meta_weekday());\n\t\tbreak;\n\tcase NFT_META_TIME_HOUR:\n\t\t*dest = nft_meta_hour(ktime_get_real_seconds());\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "static int nr_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t      struct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_ax25 *sax = (struct sockaddr_ax25 *)msg->msg_name;\n\tsize_t copied;\n\tstruct sk_buff *skb;\n\tint er;\n\tlock_sock(sk);\n\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\trelease_sock(sk);\n\t\treturn -ENOTCONN;\n\t}\n\tif ((skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT, flags & MSG_DONTWAIT, &er)) == NULL) {\n\t\trelease_sock(sk);\n\t\treturn er;\n\t}\n\tskb_reset_transport_header(skb);\n\tcopied     = skb->len;\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\ter = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (er < 0) {\n\t\tskb_free_datagram(sk, skb);\n\t\trelease_sock(sk);\n\t\treturn er;\n\t}\n\tif (sax != NULL) {\n\t\tmemset(sax, 0, sizeof(*sax));\n\t\tsax->sax25_family = AF_NETROM;\n\t\tskb_copy_from_linear_data_offset(skb, 7, sax->sax25_call.ax25_call,\n\t\t\t      AX25_ADDR_LEN);\n\t}\n\tmsg->msg_namelen = sizeof(*sax);\n\tskb_free_datagram(sk, skb);\n\trelease_sock(sk);\n\treturn copied;\n}", "target": 0}
{"code": "bool IsPadOpSupported(const TfLiteRegistration* registration,\n                      const TfLiteNode* node, TfLiteContext* context) {\n  const TfLiteTensor* padding = GetInput(context, node, 1);\n  if (!IsConstantTensor(padding)) {\n    TF_LITE_KERNEL_LOG(context,\n                       \"%s: Only constant padding is supported for PAD.\",\n                       padding->name);\n    return false;\n  }\n  if (padding->dims->data[0] != 4 || padding->dims->data[1] != 2) {\n    TF_LITE_KERNEL_LOG(context, \"%s: Only 4D inputs are supported for PAD.\",\n                       padding->name);\n    return false;\n  }\n  const int32_t* padding_data = GetTensorData<int32_t>(padding);\n  if (!(padding_data[0] == 0 && padding_data[1] == 0)) {\n    TF_LITE_KERNEL_LOG(\n        context, \"%s: Padding for batch dimension is not supported in PAD.\",\n        padding->name);\n    return false;\n  }\n  if (!(padding_data[6] == 0 && padding_data[7] == 0)) {\n    TF_LITE_KERNEL_LOG(\n        context, \"%s: Padding for channel dimension is not supported in PAD.\",\n        padding->name);\n    return false;\n  }\n  return true;\n}", "target": 1}
{"code": "int main(int argc, char **argv) {\n  mlir::registerAsmPrinterCLOptions();\n  tensorflow::InitMlir y(&argc, &argv);\n  return failed(\n      mlir::mlirTranslateMain(argc, argv, \"Graph(Def)<->TFG Translation Tool\"));\n}", "target": 0}
{"code": "TEE_Result syscall_cipher_init(unsigned long state, const void *iv,\n\t\t\tsize_t iv_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\tstruct tee_cryp_obj_secret *key1;\n\tstruct user_ta_ctx *utc;\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tutc = to_user_ta_ctx(sess->ctx);\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_CIPHER)\n\t\treturn TEE_ERROR_BAD_STATE;\n\tres = tee_mmu_check_access_rights(utc,\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t) iv, iv_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_obj_get(utc, cs->key1, &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\tkey1 = o->attr;\n\tif (tee_obj_get(utc, cs->key2, &o) == TEE_SUCCESS) {\n\t\tstruct tee_cryp_obj_secret *key2 = o->attr;\n\t\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\tres = crypto_cipher_init(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\t (uint8_t *)(key1 + 1), key1->key_size,\n\t\t\t\t\t (uint8_t *)(key2 + 1), key2->key_size,\n\t\t\t\t\t iv, iv_len);\n\t} else {\n\t\tres = crypto_cipher_init(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\t (uint8_t *)(key1 + 1), key1->key_size,\n\t\t\t\t\t NULL, 0, iv, iv_len);\n\t}\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tcs->ctx_finalize = crypto_cipher_final;\n\tcs->state = CRYP_STATE_INITIALIZED;\n\treturn TEE_SUCCESS;\n}", "target": 0}
{"code": "std::unique_ptr<BytecodeModule> hbc::generateBytecode(\n    Module *M,\n    raw_ostream &OS,\n    const BytecodeGenerationOptions &options,\n    const SHA1 &sourceHash,\n    hermes::OptValue<uint32_t> segment,\n    SourceMapGenerator *sourceMapGen,\n    std::unique_ptr<BCProviderBase> baseBCProvider) {\n  auto BM = generateBytecodeModule(\n      M,\n      M->getTopLevelFunction(),\n      options,\n      segment,\n      sourceMapGen,\n      std::move(baseBCProvider));\n  if (!BM) {\n    return {};\n  }\n  if (options.format == OutputFormatKind::EmitBundle) {\n    assert(BM != nullptr);\n    BytecodeSerializer BS{OS, options};\n    BS.serialize(*BM, sourceHash);\n  }\n  if (sourceMapGen)\n    BM->populateSourceMap(sourceMapGen);\n  return BM;\n}", "target": 0}
{"code": "ossl_cipher_initialize(VALUE self, VALUE str)\n{\n    EVP_CIPHER_CTX *ctx;\n    const EVP_CIPHER *cipher;\n    char *name;\n    unsigned char dummy_key[EVP_MAX_KEY_LENGTH] = { 0 };\n    name = StringValueCStr(str);\n    GetCipherInit(self, ctx);\n    if (ctx) {\n\tossl_raise(rb_eRuntimeError, \"Cipher already inititalized!\");\n    }\n    AllocCipher(self, ctx);\n    if (!(cipher = EVP_get_cipherbyname(name))) {\n\tossl_raise(rb_eRuntimeError, \"unsupported cipher algorithm (%\"PRIsVALUE\")\", str);\n    }\n    if (EVP_CipherInit_ex(ctx, cipher, NULL, dummy_key, NULL, -1) != 1)\n\tossl_raise(eCipherError, NULL);\n    return self;\n}", "target": 1}
{"code": "static int db_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_run *kvm_run = svm->vcpu.run;\n\tif (!(svm->vcpu.guest_debug &\n\t      (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) &&\n\t\t!svm->nmi_singlestep) {\n\t\tkvm_queue_exception(&svm->vcpu, DB_VECTOR);\n\t\treturn 1;\n\t}\n\tif (svm->nmi_singlestep) {\n\t\tsvm->nmi_singlestep = false;\n\t\tif (!(svm->vcpu.guest_debug & KVM_GUESTDBG_SINGLESTEP))\n\t\t\tsvm->vmcb->save.rflags &=\n\t\t\t\t~(X86_EFLAGS_TF | X86_EFLAGS_RF);\n\t\tupdate_db_bp_intercept(&svm->vcpu);\n\t}\n\tif (svm->vcpu.guest_debug &\n\t    (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) {\n\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\tkvm_run->debug.arch.pc =\n\t\t\tsvm->vmcb->save.cs.base + svm->vmcb->save.rip;\n\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "irc_server_get_prefix_char_for_mode (struct t_irc_server *server, char mode)\n{\n    const char *prefix_chars;\n    int index;\n    if (server)\n    {\n        prefix_chars = irc_server_get_prefix_chars (server);\n        index = irc_server_get_prefix_mode_index (server, mode);\n        if (index >= 0)\n            return prefix_chars[index];\n    }\n    return ' ';\n}", "target": 0}
{"code": "static int nr_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t      struct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_ax25 *sax = (struct sockaddr_ax25 *)msg->msg_name;\n\tsize_t copied;\n\tstruct sk_buff *skb;\n\tint er;\n\tlock_sock(sk);\n\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\trelease_sock(sk);\n\t\treturn -ENOTCONN;\n\t}\n\tif ((skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT, flags & MSG_DONTWAIT, &er)) == NULL) {\n\t\trelease_sock(sk);\n\t\treturn er;\n\t}\n\tskb_reset_transport_header(skb);\n\tcopied     = skb->len;\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\ter = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (er < 0) {\n\t\tskb_free_datagram(sk, skb);\n\t\trelease_sock(sk);\n\t\treturn er;\n\t}\n\tif (sax != NULL) {\n\t\tmemset(sax, 0, sizeof(*sax));\n\t\tsax->sax25_family = AF_NETROM;\n\t\tskb_copy_from_linear_data_offset(skb, 7, sax->sax25_call.ax25_call,\n\t\t\t      AX25_ADDR_LEN);\n\t\tmsg->msg_namelen = sizeof(*sax);\n\t}\n\tskb_free_datagram(sk, skb);\n\trelease_sock(sk);\n\treturn copied;\n}", "target": 0}
{"code": "  static void Launch(OpKernelContext* context, const Tensor& in_x,\n                     const Tensor& in_y, bool adjoint, bool lower,\n                     const MatMulBCast& bcast, Tensor* out) {\n    const int64 batch_size = bcast.output_batch_size();\n    const int64 cost_per_unit =\n        in_x.dim_size(1) * in_x.dim_size(2) * in_y.dim_size(2);\n    auto worker_threads = *(context->device()->tensorflow_cpu_worker_threads());\n    using Matrix =\n        Eigen::Matrix<Scalar, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor>;\n    using ConstMatrixMap = Eigen::Map<const Matrix>;\n    using RealScalar = typename Eigen::NumTraits<Scalar>::Real;\n    auto matrix = ConstMatrixMap(in_x.flat<Scalar>().data(), in_x.dim_size(1),\n                                 in_x.dim_size(2));\n    RealScalar min_abs_pivot;\n    if (lower) {\n      min_abs_pivot = matrix.row(0).cwiseAbs().minCoeff();\n    } else {\n      min_abs_pivot = matrix.row(in_x.dim_size(1) - 1).cwiseAbs().minCoeff();\n    }\n    OP_REQUIRES(context, min_abs_pivot > RealScalar(0),\n                errors::InvalidArgument(\"Input matrix is not invertible.\"));\n    Shard(worker_threads.num_threads, worker_threads.workers, batch_size,\n          cost_per_unit,\n          [&in_x, &in_y, adjoint, lower, &bcast, out](int start, int limit) {\n            SequentialBandedTriangularSolveKernel<Scalar>::Run(\n                in_x, in_y, lower, adjoint, bcast, out, start, limit);\n          });\n  }", "target": 1}
{"code": "xfs_acl_from_disk(struct xfs_acl *aclp)\n{\n\tstruct posix_acl_entry *acl_e;\n\tstruct posix_acl *acl;\n\tstruct xfs_acl_entry *ace;\n\tint count, i;\n\tcount = be32_to_cpu(aclp->acl_cnt);\n\tif (count > XFS_ACL_MAX_ENTRIES)\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\tacl = posix_acl_alloc(count, GFP_KERNEL);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfor (i = 0; i < count; i++) {\n\t\tacl_e = &acl->a_entries[i];\n\t\tace = &aclp->acl_entry[i];\n\t\tacl_e->e_tag = be32_to_cpu(ace->ae_tag);\n\t\tacl_e->e_perm = be16_to_cpu(ace->ae_perm);\n\t\tswitch (acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\tcase ACL_GROUP:\n\t\t\tacl_e->e_id = be32_to_cpu(ace->ae_id);\n\t\t\tbreak;\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tacl_e->e_id = ACL_UNDEFINED_ID;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}", "target": 0}
{"code": "static INLINE BOOL update_read_brush(wStream* s, rdpBrush* brush, BYTE fieldFlags)\n{\n\tif (fieldFlags & ORDER_FIELD_01)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\t\tStream_Read_UINT8(s, brush->x);\n\t}\n\tif (fieldFlags & ORDER_FIELD_02)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\t\tStream_Read_UINT8(s, brush->y);\n\t}\n\tif (fieldFlags & ORDER_FIELD_03)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\t\tStream_Read_UINT8(s, brush->style);\n\t}\n\tif (fieldFlags & ORDER_FIELD_04)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\t\tStream_Read_UINT8(s, brush->hatch);\n\t}\n\tif (brush->style & CACHED_BRUSH)\n\t{\n\t\tbrush->index = brush->hatch;\n\t\tbrush->bpp = BMF_BPP[brush->style & 0x07];\n\t\tif (brush->bpp == 0)\n\t\t\tbrush->bpp = 1;\n\t}\n\tif (fieldFlags & ORDER_FIELD_05)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 7)\n\t\t\treturn FALSE;\n\t\tbrush->data = (BYTE*)brush->p8x8;\n\t\tStream_Read_UINT8(s, brush->data[7]);\n\t\tStream_Read_UINT8(s, brush->data[6]);\n\t\tStream_Read_UINT8(s, brush->data[5]);\n\t\tStream_Read_UINT8(s, brush->data[4]);\n\t\tStream_Read_UINT8(s, brush->data[3]);\n\t\tStream_Read_UINT8(s, brush->data[2]);\n\t\tStream_Read_UINT8(s, brush->data[1]);\n\t\tbrush->data[0] = brush->hatch;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "static inline __u32 dccp_v6_init_sequence(struct sk_buff *skb)\n{\n\treturn secure_dccpv6_sequence_number(ipv6_hdr(skb)->daddr.s6_addr32,\n\t\t\t\t\t     ipv6_hdr(skb)->saddr.s6_addr32,\n\t\t\t\t\t     dccp_hdr(skb)->dccph_dport,\n\t\t\t\t\t     dccp_hdr(skb)->dccph_sport     );\n}", "target": 1}
{"code": "void test_checkout_nasty__git_tilde1(void)\n{\n#ifdef GIT_WIN32\n\ttest_checkout_fails(\"refs/heads/git_tilde1\", \".git/foobar\");\n#endif\n}", "target": 1}
{"code": "  void operator()(OpKernelContext* ctx, bool use_cudnn, bool cudnn_use_autotune,\n                  const Tensor& input, const Tensor& filter, int row_dilation,\n                  int col_dilation, int row_stride, int col_stride,\n                  const Padding& padding,\n                  const std::vector<int64>& explicit_paddings, Tensor* output,\n                  TensorFormat data_format) {\n    if (data_format != FORMAT_NHWC) {\n      ctx->SetStatus(errors::Unimplemented(\n          \"The Conv2D op currently only supports the NHWC tensor format on the \"\n          \"CPU. The op was given the format: \",\n          ToString(data_format)));\n      return;\n    }\n    for (int64 explicit_padding : explicit_paddings) {\n      if (!FastBoundsCheck(explicit_padding, std::numeric_limits<int>::max())) {\n        ctx->SetStatus(errors::InvalidArgument(\"filter too large\"));\n        return;\n      }\n    }\n    const int64 in_depth = input.dim_size(3);\n    const int64 out_depth = output->dim_size(3);\n    const int64 patch_depth = filter.dim_size(2);\n    if (patch_depth <= 0) {\n      ctx->SetStatus(errors::InvalidArgument(\n          \"filter depth must be stricly positive, got \", patch_depth));\n      return;\n    }\n    if (in_depth % patch_depth != 0) {\n      ctx->SetStatus(errors::InvalidArgument(\n          \"input depth must be evenly divisible by filter depth: \", in_depth,\n          \" vs \", patch_depth));\n      return;\n    }\n    const int64 num_groups = in_depth / patch_depth;\n    if (num_groups <= 0) {\n      ctx->SetStatus(errors::InvalidArgument(\n          \"number of groups must be stricly positive, got \", num_groups));\n      return;\n    }\n    if (out_depth % num_groups != 0 || out_depth < num_groups) {\n      ctx->SetStatus(errors::InvalidArgument(\n          \"output depth must be evenly divisible by number of groups: \",\n          out_depth, \" vs \", num_groups));\n      return;\n    }\n    if (in_depth != patch_depth) {\n      LaunchGrouped<T>()(ctx, input, filter, row_stride, col_stride,\n                         row_dilation, col_dilation, padding, explicit_paddings,\n                         output, data_format);\n    } else {\n      LaunchGeneric<CPUDevice, T>()(ctx, input, filter, row_stride, col_stride,\n                                    row_dilation, col_dilation, padding,\n                                    explicit_paddings, output, data_format);\n    }\n  }", "target": 0}
{"code": "static BOOL nsc_stream_initialize(NSC_CONTEXT* context, wStream* s)\n{\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(context->priv);\n\tif (!Stream_CheckAndLogRequiredLengthWLog(context->priv->log, s, 20))\n\t\treturn FALSE;\n\tsize_t total = 0;\n\tfor (size_t i = 0; i < 4; i++)\n\t{\n\t\tStream_Read_UINT32(s, context->PlaneByteCount[i]);\n\t\ttotal += context->PlaneByteCount[i];\n\t}\n\tStream_Read_UINT8(s, context->ColorLossLevel);         \n\tStream_Read_UINT8(s, context->ChromaSubsamplingLevel); \n\tStream_Seek(s, 2);                                     \n\tcontext->Planes = Stream_Pointer(s);\n\tcontext->PlanesSize = total;\n\treturn Stream_CheckAndLogRequiredLengthWLog(context->priv->log, s, total);\n}", "target": 0}
{"code": "pf_update_state_timeout(struct pf_state *st, int to)\n{\n\tmtx_enter(&st->mtx);\n\tif (st->timeout != PFTM_UNLINKED)\n\t\tst->timeout = to;\n\tmtx_leave(&st->mtx);\n}", "target": 0}
{"code": "void recovery_cipher_init(bool passphrase_protection, bool pin_protection,\n                          const char *language, const char *label, bool _enforce_wordlist,\n                          uint32_t _auto_lock_delay_ms, uint32_t _u2f_counter, bool _dry_run)\n{\n    enforce_wordlist = _enforce_wordlist;\n    dry_run = _dry_run;\n    if (!dry_run) {\n        if (pin_protection) {\n            if (!change_pin()) {\n                recovery_abort();\n                fsm_sendFailure(FailureType_Failure_ActionCancelled, \"PINs do not match\");\n                layoutHome();\n                return;\n            }\n        } else {\n            storage_setPin(\"\");\n        }\n        storage_setPassphraseProtected(passphrase_protection);\n        storage_setLanguage(language);\n        storage_setLabel(label);\n        storage_setAutoLockDelayMs(_auto_lock_delay_ms);\n        storage_setU2FCounter(_u2f_counter);\n    } else if (!pin_protect(\"Enter Your PIN\")) {\n        layoutHome();\n        return;\n    }\n    if (!confirm(ButtonRequestType_ButtonRequest_Other,\n                 dry_run ? \"Recovery Dry Run\" : \"Recovery\",\n                 \"When entering your recovery seed, use the substitution cipher \"\n                 \"and check that each word shows up correctly on the screen.\")) {\n        fsm_sendFailure(FailureType_Failure_ActionCancelled, \"Recovery cancelled\");\n        if (!dry_run)\n            storage_reset();\n        layoutHome();\n        return;\n    }\n    memset(mnemonic, 0, sizeof(mnemonic) / sizeof(char));\n    awaiting_character = true;\n    recovery_started = true;\n    next_character();\n}", "target": 0}
{"code": "int ZlibInStream::overrun(int itemSize, int nItems, bool wait)\n{\n  if (itemSize > bufSize)\n    throw Exception(\"ZlibInStream overrun: max itemSize exceeded\");\n  if (!underlying)\n    throw Exception(\"ZlibInStream overrun: no underlying stream\");\n  if (end - ptr != 0)\n    memmove(start, ptr, end - ptr);\n  offset += ptr - start;\n  end -= ptr - start;\n  ptr = start;\n  while (end - ptr < itemSize) {\n    if (!decompress(wait))\n      return 0;\n  }\n  if (itemSize * nItems > end - ptr)\n    nItems = (end - ptr) / itemSize;\n  return nItems;\n}", "target": 1}
{"code": "int wait_for_key_construction(struct key *key, bool intr)\n{\n\tint ret;\n\tret = wait_on_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT,\n\t\t\t  intr ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE);\n\tif (ret)\n\t\treturn -ERESTARTSYS;\n\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags)) {\n\t\tsmp_rmb();\n\t\treturn key->reject_error;\n\t}\n\treturn key_validate(key);\n}", "target": 1}
{"code": "int insn_get_code_seg_params(struct pt_regs *regs)\n{\n\tstruct desc_struct *desc;\n\tshort sel;\n\tif (v8086_mode(regs))\n\t\treturn INSN_CODE_SEG_PARAMS(2, 2);\n\tsel = get_segment_selector(regs, INAT_SEG_REG_CS);\n\tif (sel < 0)\n\t\treturn sel;\n\tdesc = get_desc(sel);\n\tif (!desc)\n\t\treturn -EINVAL;\n\tif (!(desc->type & BIT(3)))\n\t\treturn -EINVAL;\n\tswitch ((desc->l << 1) | desc->d) {\n\tcase 0: \n\t\treturn INSN_CODE_SEG_PARAMS(2, 2);\n\tcase 1: \n\t\treturn INSN_CODE_SEG_PARAMS(4, 4);\n\tcase 2: \n\t\treturn INSN_CODE_SEG_PARAMS(4, 8);\n\tcase 3: \n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}", "target": 1}
{"code": "    void WebPImage::writeMetadata()\n    {\n        if (io_->open() != 0) {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        BasicIo::UniquePtr tempIo(new MemIo);\n        assert (tempIo.get() != 0);\n        doWriteMetadata(*tempIo); \n        io_->close();\n        io_->transfer(*tempIo); \n    } ", "target": 0}
{"code": "void thread_func(unsigned int start, unsigned int end, int fd)\n{\n\tstruct qcedev_cipher_op_req req = { 0 };\n\tunsigned int i;\n\tchar *data;\n\tdata = mmap(NULL, 0xFFFFFF * 3, PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE|MAP_POPULATE, -1, 0);\n\tif (data == MAP_FAILED) {\n\t\tprintf(\"mmap failed, get a better phone\\n\");\n\t\texit(0);\n\t}\n\tfor (i = 0; i < 0xFFFFFF * 3; i += sizeof(void*))\n\t\t*((unsigned long *)(data + i)) = 0xABADACC355001337;\n\treq.in_place_op = 1;\n\treq.entries = 2;\n\treq.byteoffset = 15;\n\treq.mode = QCEDEV_AES_MODE_CTR;\n\treq.op = QCEDEV_OPER_ENC;\n\treq.ivlen = 1;\n\treq.data_len = 0xFFFFFFFE;\n\treq.vbuf.src[0].len = 4;\n\treq.vbuf.src[1].len = 0xFFFFFFFE - 4;\n\treq.vbuf.src[0].vaddr = (uint8_t*)data;\n\treq.vbuf.src[1].vaddr = (uint8_t*)data;\n\treq.vbuf.dst[0].len = 4;\n\treq.vbuf.dst[1].len = 0xFFFFFFFE - 4;\n\treq.vbuf.dst[0].vaddr = (uint8_t*)data;\n\treq.vbuf.dst[1].vaddr = (uint8_t*)data;\n\tioctl(fd, QCEDEV_IOCTL_ENC_REQ, &req);\n\tprintf(\"exiting\\n\");\n\texit(0);\n}", "target": 0}
{"code": "static Jsi_RC SysRunMainCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (jsi_isMain(interp))\n        return SysRunModuleCmd(interp, args, _this, ret, funcPtr);\n    return JSI_OK;\n}", "target": 0}
{"code": "void Polygon::Insert( sal_uInt16 nPos, const Point& rPt )\n{\n    ImplMakeUnique();\n    if( nPos >= mpImplPolygon->mnPoints )\n        nPos = mpImplPolygon->mnPoints;\n    mpImplPolygon->ImplSplit( nPos, 1 );\n    mpImplPolygon->mpPointAry[ nPos ] = rPt;\n}", "target": 1}
{"code": "mark_trusted_task_done (GObject      *source_object,\n                        GAsyncResult *res,\n                        gpointer      user_data)\n{\n    MarkTrustedJob *job = user_data;\n    g_object_unref (job->file);\n    if (job->done_callback)\n    {\n        job->done_callback (!job_aborted ((CommonJob *) job),\n                            job->done_callback_data);\n    }\n    finalize_common ((CommonJob *) job);\n}", "target": 1}
{"code": "static void rose_heartbeat_expiry(struct timer_list *t)\n{\n\tstruct sock *sk = from_timer(sk, t, sk_timer);\n\tstruct rose_sock *rose = rose_sk(sk);\n\tbh_lock_sock(sk);\n\tswitch (rose->state) {\n\tcase ROSE_STATE_0:\n\t\tif (sock_flag(sk, SOCK_DESTROY) ||\n\t\t    (sk->sk_state == TCP_LISTEN && sock_flag(sk, SOCK_DEAD))) {\n\t\t\tbh_unlock_sock(sk);\n\t\t\trose_destroy_socket(sk);\n\t\t\tsock_put(sk);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase ROSE_STATE_3:\n\t\tif (atomic_read(&sk->sk_rmem_alloc) < (sk->sk_rcvbuf / 2) &&\n\t\t    (rose->condition & ROSE_COND_OWN_RX_BUSY)) {\n\t\t\trose->condition &= ~ROSE_COND_OWN_RX_BUSY;\n\t\t\trose->condition &= ~ROSE_COND_ACK_PENDING;\n\t\t\trose->vl         = rose->vr;\n\t\t\trose_write_internal(sk, ROSE_RR);\n\t\t\trose_stop_timer(sk);\t\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\trose_start_heartbeat(sk);\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n}", "target": 0}
{"code": "static int n_tty_ioctl(struct tty_struct *tty, struct file *file,\n\t\t       unsigned int cmd, unsigned long arg)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint retval;\n\tswitch (cmd) {\n\tcase TIOCOUTQ:\n\t\treturn put_user(tty_chars_in_buffer(tty), (int __user *) arg);\n\tcase TIOCINQ:\n\t\tdown_write(&tty->termios_rwsem);\n\t\tif (L_ICANON(tty))\n\t\t\tretval = inq_canon(ldata);\n\t\telse\n\t\t\tretval = read_cnt(ldata);\n\t\tup_write(&tty->termios_rwsem);\n\t\treturn put_user(retval, (unsigned int __user *) arg);\n\tdefault:\n\t\treturn n_tty_ioctl_helper(tty, file, cmd, arg);\n\t}\n}", "target": 1}
{"code": "void LanLinkProvider::udpBroadcastReceived()\n{\n    while (m_udpSocket.hasPendingDatagrams()) {\n        QByteArray datagram;\n        datagram.resize(m_udpSocket.pendingDatagramSize());\n        QHostAddress sender;\n        m_udpSocket.readDatagram(datagram.data(), datagram.size(), &sender);\n        if (sender.isLoopback() && !m_testMode)\n            continue;\n        NetworkPacket* receivedPacket = new NetworkPacket(QLatin1String(\"\"));\n        bool success = NetworkPacket::unserialize(datagram, receivedPacket);\n        if (!success) {\n            qCDebug(KDECONNECT_CORE) << \"Could not unserialize UDP packet\";\n            delete receivedPacket;\n            continue;\n        }\n        if (receivedPacket->type() != PACKET_TYPE_IDENTITY) {\n            qCDebug(KDECONNECT_CORE) << \"Received a UDP packet of wrong type\" << receivedPacket->type();\n            delete receivedPacket;\n            continue;\n        }\n        if (receivedPacket->get<QString>(QStringLiteral(\"deviceId\")) == KdeConnectConfig::instance().deviceId()) {\n            delete receivedPacket;\n            continue;\n        }\n        int tcpPort = receivedPacket->get<int>(QStringLiteral(\"tcpPort\"));\n        if (tcpPort < MIN_TCP_PORT || tcpPort > MAX_TCP_PORT) {\n            qCDebug(KDECONNECT_CORE) << \"TCP port outside of kdeconnect's range\";\n            delete receivedPacket;\n            continue;\n        }\n        if (m_receivedIdentityPackets.size() > MAX_REMEMBERED_IDENTITY_PACKETS) {\n            qCWarning(KDECONNECT_CORE) << \"Too many remembered identities, ignoring\" << receivedPacket->get<QString>(QStringLiteral(\"deviceId\")) << \"received via UDP\";\n            delete receivedPacket;\n            continue;\n        }\n        QSslSocket* socket = new QSslSocket(this);\n        socket->setProxy(QNetworkProxy::NoProxy);\n        m_receivedIdentityPackets[socket].np = receivedPacket;\n        m_receivedIdentityPackets[socket].sender = sender;\n        connect(socket, &QAbstractSocket::connected, this, &LanLinkProvider::tcpSocketConnected);\n#if QT_VERSION < QT_VERSION_CHECK(5,15,0)\n        connect(socket, QOverload<QAbstractSocket::SocketError>::of(&QAbstractSocket::error), this, &LanLinkProvider::connectError);\n#else\n        connect(socket, &QAbstractSocket::errorOccurred, this, &LanLinkProvider::connectError);\n#endif\n        socket->connectToHost(sender, tcpPort);\n    }\n}", "target": 0}
{"code": "TEST_P(Http2CodecImplTest, TestLargeRequestHeadersAtLimitAccepted) {\n  uint32_t codec_limit_kb = 64;\n  max_request_headers_kb_ = codec_limit_kb;\n  initialize();\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  std::string key = \"big\";\n  uint32_t head_room = 77;\n  uint32_t long_string_length =\n      codec_limit_kb * 1024 - request_headers.byteSize() - key.length() - head_room;\n  std::string long_string = std::string(long_string_length, 'q');\n  request_headers.addCopy(key, long_string);\n  ASSERT_EQ(request_headers.byteSize() + head_room, codec_limit_kb * 1024);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, _));\n  request_encoder_->encodeHeaders(request_headers, true);\n}", "target": 1}
{"code": "iakerb_gss_export_sec_context(OM_uint32 *minor_status,\n                              gss_ctx_id_t *context_handle,\n                              gss_buffer_t interprocess_token)\n{\n    OM_uint32 maj;\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)*context_handle;\n    if (!ctx->established)\n        return GSS_S_UNAVAILABLE;\n    maj = krb5_gss_export_sec_context(minor_status, &ctx->gssc,\n                                      interprocess_token);\n    if (ctx->gssc == GSS_C_NO_CONTEXT) {\n        iakerb_release_context(ctx);\n        *context_handle = GSS_C_NO_CONTEXT;\n    }\n    return maj;\n}", "target": 0}
{"code": "int pam_modutil_drop_priv(pam_handle_t *pamh, struct _ykpam_privs *privs, struct passwd *pw) {\n    privs->saved_euid = geteuid();\n    privs->saved_egid = getegid();\n    if ((privs->saved_euid == pw->pw_uid) && (privs->saved_egid == pw->pw_gid)) {\n        D (privs->debug_file, \"Privilges already dropped, pretend it is all right\");\n        return 0;\n    }\n    privs->saved_groups_length = getgroups(0, NULL);\n    if (privs->saved_groups_length < 0) {\n        D (privs->debug_file, \"getgroups: %s\", strerror(errno));\n        return -1;\n    }\n    if (privs->saved_groups_length > SAVED_GROUPS_MAX_LEN) {\n        D (privs->debug_file, \"too many groups, limiting.\");\n        privs->saved_groups_length = SAVED_GROUPS_MAX_LEN;\n    }\n    if (privs->saved_groups_length > 0) {\n        if (getgroups(privs->saved_groups_length, privs->saved_groups) < 0) {\n            D (privs->debug_file, \"getgroups: %s\", strerror(errno));\n            goto free_out;\n        }\n    }\n    if (initgroups(pw->pw_name, pw->pw_gid) < 0) {\n        D (privs->debug_file, \"initgroups: %s\", strerror(errno));\n        goto free_out;\n    }\n    if (setegid(pw->pw_gid) < 0) {\n        D (privs->debug_file, \"setegid: %s\", strerror(errno));\n        goto free_out;\n    }\n    if (seteuid(pw->pw_uid) < 0) {\n        D (privs->debug_file, \"seteuid: %s\", strerror(errno));\n        goto free_out;\n    }\n    return 0;\nfree_out:\n    return -1;\n}", "target": 0}
{"code": "  absl::Status IsSupported(const TfLiteContext* context,\n                           const TfLiteNode* tflite_node,\n                           const TfLiteRegistration* registration) final {\n    RETURN_IF_ERROR(CheckMaxSupportedOpVersion(registration, 3));\n    if (tflite_node->inputs->size != 2) {\n      return absl::UnimplementedError(\"MUL requires two input tensors.\");\n    }\n    auto input0 = tflite::GetInput(context, tflite_node, 0);\n    auto input1 = tflite::GetInput(context, tflite_node, 1);\n    if (input0 == nullptr || input1 == nullptr) {\n      return absl::InvalidArgumentError(\"At least one input tensor is null\");\n    }\n    if (input0->dims->size == input1->dims->size) {\n      bool first_has_smaller_dim = false;\n      bool second_has_smaller_dim = false;\n      for (int i = 0; i < input0->dims->size; ++i) {\n        if (input0->dims->data[i] < input1->dims->data[i]) {\n          first_has_smaller_dim = true;\n        }\n        if (input1->dims->data[i] < input0->dims->data[i]) {\n          second_has_smaller_dim = true;\n        }\n      }\n      if (first_has_smaller_dim && second_has_smaller_dim) {\n        return absl::UnimplementedError(\n            \"MUL requires one tensor that not less than second in all \"\n            \"dimensions.\");\n      }\n    }\n    const TfLiteMulParams* tf_options;\n    RETURN_IF_ERROR(RetrieveBuiltinData(tflite_node, &tf_options));\n    return IsActivationSupported(tf_options->activation);\n  }", "target": 0}
{"code": "archive_wstring_append_from_mbs(struct archive_wstring *dest,\n    const char *p, size_t len)\n{\n\tsize_t r;\n\tint ret_val = 0;\n\tsize_t wcs_length = len;\n\tsize_t mbs_length = len;\n\tconst char *mbs = p;\n\twchar_t *wcs;\n#if HAVE_MBRTOWC\n\tmbstate_t shift_state;\n\tmemset(&shift_state, 0, sizeof(shift_state));\n#endif\n\tif (NULL == archive_wstring_ensure(dest, dest->length + wcs_length + 1))\n\t\treturn (-1);\n\twcs = dest->s + dest->length;\n\twhile (*mbs && mbs_length > 0) {\n\t\tif (wcs_length == 0) {\n\t\t\tdest->length = wcs - dest->s;\n\t\t\tdest->s[dest->length] = L'\\0';\n\t\t\twcs_length = mbs_length;\n\t\t\tif (NULL == archive_wstring_ensure(dest,\n\t\t\t    dest->length + wcs_length + 1))\n\t\t\t\treturn (-1);\n\t\t\twcs = dest->s + dest->length;\n\t\t}\n#if HAVE_MBRTOWC\n\t\tr = mbrtowc(wcs, mbs, wcs_length, &shift_state);\n#else\n\t\tr = mbtowc(wcs, mbs, wcs_length);\n#endif\n\t\tif (r == (size_t)-1 || r == (size_t)-2) {\n\t\t\tret_val = -1;\n\t\t\tif (errno == EILSEQ) {\n\t\t\t\t++mbs;\n\t\t\t\t--mbs_length;\n\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t\tif (r == 0 || r > mbs_length)\n\t\t\tbreak;\n\t\twcs++;\n\t\twcs_length--;\n\t\tmbs += r;\n\t\tmbs_length -= r;\n\t}\n\tdest->length = wcs - dest->s;\n\tdest->s[dest->length] = L'\\0';\n\treturn (ret_val);\n}", "target": 1}
{"code": "GF_Err dinf_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e = gf_isom_box_array_read(s, bs, dinf_AddBox);\n\tif (e) {\n\t\treturn e;\n\t}\n\tif (!((GF_DataInformationBox *)s)->dref) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing dref box in dinf\\n\"));\n\t\t((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "static bool check_underflow(const struct arpt_entry *e)\n{\n\tconst struct xt_entry_target *t;\n\tunsigned int verdict;\n\tif (!unconditional(&e->arp))\n\t\treturn false;\n\tt = arpt_get_target_c(e);\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\n\t\treturn false;\n\tverdict = ((struct xt_standard_target *)t)->verdict;\n\tverdict = -verdict - 1;\n\treturn verdict == NF_DROP || verdict == NF_ACCEPT;\n}", "target": 1}
{"code": "PHP_FUNCTION(imagetruecolortopalette)\n{\n\tzval *IM;\n\tzend_bool dither;\n\tzend_long ncolors;\n\tgdImagePtr im;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"rbl\", &IM, &dither, &ncolors) == FAILURE)  {\n\t\treturn;\n\t}\n\tif ((im = (gdImagePtr)zend_fetch_resource(Z_RES_P(IM), \"Image\", le_gd)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tif (ncolors <= 0) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Number of colors has to be greater than zero\");\n\t\tRETURN_FALSE;\n\t}\n\tgdImageTrueColorToPalette(im, dither, ncolors);\n\tRETURN_TRUE;\n}", "target": 1}
{"code": "static void flush_end_io(struct request *flush_rq, int error)\n{\n\tstruct request_queue *q = flush_rq->q;\n\tstruct list_head *running;\n\tbool queued = false;\n\tstruct request *rq, *n;\n\tunsigned long flags = 0;\n\tstruct blk_flush_queue *fq = blk_get_flush_queue(q, flush_rq->mq_ctx);\n\tif (q->mq_ops) {\n\t\tstruct blk_mq_hw_ctx *hctx;\n\t\tspin_lock_irqsave(&fq->mq_flush_lock, flags);\n\t\thctx = q->mq_ops->map_queue(q, flush_rq->mq_ctx->cpu);\n\t\tblk_mq_tag_set_rq(hctx, flush_rq->tag, fq->orig_rq);\n\t\tflush_rq->tag = -1;\n\t}\n\trunning = &fq->flush_queue[fq->flush_running_idx];\n\tBUG_ON(fq->flush_pending_idx == fq->flush_running_idx);\n\tfq->flush_running_idx ^= 1;\n\tif (!q->mq_ops)\n\t\telv_completed_request(q, flush_rq);\n\tlist_for_each_entry_safe(rq, n, running, flush.list) {\n\t\tunsigned int seq = blk_flush_cur_seq(rq);\n\t\tBUG_ON(seq != REQ_FSEQ_PREFLUSH && seq != REQ_FSEQ_POSTFLUSH);\n\t\tqueued |= blk_flush_complete_seq(rq, fq, seq, error);\n\t}\n\tif (queued || fq->flush_queue_delayed) {\n\t\tWARN_ON(q->mq_ops);\n\t\tblk_run_queue_async(q);\n\t}\n\tfq->flush_queue_delayed = 0;\n\tif (q->mq_ops)\n\t\tspin_unlock_irqrestore(&fq->mq_flush_lock, flags);\n}", "target": 0}
{"code": "static int xfrm_dump_policy_done(struct netlink_callback *cb)\n{\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];\n\txfrm_policy_walk_done(walk);\n\treturn 0;\n}", "target": 1}
{"code": "static int swevent_hlist_get_cpu(struct perf_event *event, int cpu)\n{\n\tstruct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);\n\tint err = 0;\n\tmutex_lock(&swhash->hlist_mutex);\n\tif (!swevent_hlist_deref(swhash) && cpu_online(cpu)) {\n\t\tstruct swevent_hlist *hlist;\n\t\thlist = kzalloc(sizeof(*hlist), GFP_KERNEL);\n\t\tif (!hlist) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto exit;\n\t\t}\n\t\trcu_assign_pointer(swhash->swevent_hlist, hlist);\n\t}\n\tswhash->hlist_refcount++;\nexit:\n\tmutex_unlock(&swhash->hlist_mutex);\n\treturn err;\n}", "target": 1}
{"code": "static bool cgm_bind_dir(const char *root, const char *dirname)\n{\n\tnih_local char *cgpath = NULL;\n\tcgpath = NIH_MUST( nih_strdup(NULL, root) );\n\tNIH_MUST( nih_strcat(&cgpath, NULL, \"/sys/fs/cgroup\") );\n\tif (!dir_exists(cgpath)) {\n\t\tERROR(\"%s does not exist\", cgpath);\n\t\treturn false;\n\t}\n\tif (mount(\"cgroup\", cgpath, \"tmpfs\", 0, \"size=10000,mode=755\")) {\n\t\tSYSERROR(\"Failed to mount tmpfs at %s\", cgpath);\n\t\treturn false;\n\t}\n\tNIH_MUST( nih_strcat(&cgpath, NULL, \"/cgmanager\") );\n\tif (mkdir(cgpath, 0755) < 0) {\n\t\tSYSERROR(\"Failed to create %s\", cgpath);\n\t\treturn false;\n\t}\n\tif (mount(dirname, cgpath, \"none\", MS_BIND, 0)) {\n\t\tSYSERROR(\"Failed to bind mount %s to %s\", dirname, cgpath);\n\t\treturn false;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "absl::Span<const std::string> ConnectionInfoImplBase::ipSansPeerCertificate() const {\n  if (!cached_ip_san_peer_certificate_.empty()) {\n    return cached_ip_san_peer_certificate_;\n  }\n  bssl::UniquePtr<X509> cert(SSL_get_peer_certificate(ssl()));\n  if (!cert) {\n    ASSERT(cached_ip_san_peer_certificate_.empty());\n    return cached_ip_san_peer_certificate_;\n  }\n  cached_ip_san_peer_certificate_ = Utility::getSubjectAltNames(*cert, GEN_IPADD);\n  return cached_ip_san_peer_certificate_;\n}", "target": 1}
{"code": "relay_websocket_decode_frame (const unsigned char *buffer,\n                              unsigned long long buffer_length,\n                              unsigned char *decoded,\n                              unsigned long long *decoded_length)\n{\n    unsigned long long i, index_buffer, length_frame_size, length_frame;\n    unsigned char opcode;\n    *decoded_length = 0;\n    index_buffer = 0;\n    while (index_buffer + 2 <= buffer_length)\n    {\n        opcode = buffer[index_buffer] & 15;\n        if (!(buffer[index_buffer + 1] & 128))\n            return 0;\n        length_frame_size = 1;\n        length_frame = buffer[index_buffer + 1] & 127;\n        index_buffer += 2;\n        if ((length_frame == 126) || (length_frame == 127))\n        {\n            length_frame_size = (length_frame == 126) ? 2 : 8;\n            if (buffer_length < 1 + length_frame_size)\n                return 0;\n            length_frame = 0;\n            for (i = 0; i < length_frame_size; i++)\n            {\n                length_frame += (unsigned long long)buffer[index_buffer + i] << ((length_frame_size - i - 1) * 8);\n            }\n            index_buffer += length_frame_size;\n        }\n        if (buffer_length < 1 + length_frame_size + 4 + length_frame)\n            return 0;\n        int masks[4];\n        for (i = 0; i < 4; i++)\n        {\n            masks[i] = (int)((unsigned char)buffer[index_buffer + i]);\n        }\n        index_buffer += 4;\n        switch (opcode)\n        {\n            case WEBSOCKET_FRAME_OPCODE_PING:\n                decoded[*decoded_length] = RELAY_CLIENT_MSG_PING;\n                break;\n            case WEBSOCKET_FRAME_OPCODE_CLOSE:\n                decoded[*decoded_length] = RELAY_CLIENT_MSG_CLOSE;\n                break;\n            default:\n                decoded[*decoded_length] = RELAY_CLIENT_MSG_STANDARD;\n                break;\n        }\n        *decoded_length += 1;\n        for (i = 0; i < length_frame; i++)\n        {\n            decoded[*decoded_length + i] = (int)((unsigned char)buffer[index_buffer + i]) ^ masks[i % 4];\n        }\n        decoded[*decoded_length + length_frame] = '\\0';\n        *decoded_length += length_frame + 1;\n        index_buffer += length_frame;\n    }\n    return 1;\n}", "target": 1}
{"code": "_asn1_set_default_tag (asn1_node node)\n{\n  asn1_node p;\n  if ((node == NULL) || (type_field (node->type) != ASN1_ETYPE_DEFINITIONS))\n    return ASN1_ELEMENT_NOT_FOUND;\n  p = node;\n  while (p)\n    {\n      if ((type_field (p->type) == ASN1_ETYPE_TAG) &&\n\t  !(p->type & CONST_EXPLICIT) && !(p->type & CONST_IMPLICIT))\n\t{\n\t  if (node->type & CONST_EXPLICIT)\n\t    p->type |= CONST_EXPLICIT;\n\t  else\n\t    p->type |= CONST_IMPLICIT;\n\t}\n      if (p->down)\n\t{\n\t  p = p->down;\n\t}\n      else if (p->right)\n\tp = p->right;\n      else\n\t{\n\t  while (1)\n\t    {\n\t      p = _asn1_get_up (p);\n\t      if (p == node)\n\t\t{\n\t\t  p = NULL;\n\t\t  break;\n\t\t}\n\t      if (p->right)\n\t\t{\n\t\t  p = p->right;\n\t\t  break;\n\t\t}\n\t    }\n\t}\n    }\n  return ASN1_SUCCESS;\n}", "target": 0}
{"code": "static int hns_gmac_get_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn ARRAY_SIZE(g_gmac_stats_string);\n\treturn 0;\n}", "target": 1}
{"code": "void ipc_rcu_putref(void *ptr)\n{\n\tif (--container_of(ptr, struct ipc_rcu_hdr, data)->refcount > 0)\n\t\treturn;\n\tif (container_of(ptr, struct ipc_rcu_hdr, data)->is_vmalloc) {\n\t\tcall_rcu(&container_of(ptr, struct ipc_rcu_grace, data)->rcu,\n\t\t\t\tipc_schedule_free);\n\t} else {\n\t\tkfree_rcu(container_of(ptr, struct ipc_rcu_grace, data), rcu);\n\t}\n}", "target": 1}
{"code": "static int hidp_setup_hid(struct hidp_session *session,\n\t\t\t\tstruct hidp_connadd_req *req)\n{\n\tstruct hid_device *hid;\n\tint err;\n\tsession->rd_data = kzalloc(req->rd_size, GFP_KERNEL);\n\tif (!session->rd_data)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(session->rd_data, req->rd_data, req->rd_size)) {\n\t\terr = -EFAULT;\n\t\tgoto fault;\n\t}\n\tsession->rd_size = req->rd_size;\n\thid = hid_allocate_device();\n\tif (IS_ERR(hid)) {\n\t\terr = PTR_ERR(hid);\n\t\tgoto fault;\n\t}\n\tsession->hid = hid;\n\thid->driver_data = session;\n\thid->bus     = BUS_BLUETOOTH;\n\thid->vendor  = req->vendor;\n\thid->product = req->product;\n\thid->version = req->version;\n\thid->country = req->country;\n\tstrncpy(hid->name, req->name, 128);\n\tsnprintf(hid->phys, sizeof(hid->phys), \"%pMR\",\n\t\t &bt_sk(session->ctrl_sock->sk)->src);\n\tsnprintf(hid->uniq, sizeof(hid->uniq), \"%pMR\",\n\t\t &bt_sk(session->ctrl_sock->sk)->dst);\n\thid->dev.parent = &session->conn->dev;\n\thid->ll_driver = &hidp_hid_driver;\n\thid->hid_get_raw_report = hidp_get_raw_report;\n\thid->hid_output_raw_report = hidp_output_raw_report;\n\tif (hid_ignore(hid)) {\n\t\thid_destroy_device(session->hid);\n\t\tsession->hid = NULL;\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\nfault:\n\tkfree(session->rd_data);\n\tsession->rd_data = NULL;\n\treturn err;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* const context) override {\n    core::RefCountPtr<BoostedTreesEnsembleResource> resource;\n    OP_REQUIRES_OK(context, LookupResource(context, HandleFromInput(context, 0),\n                                           &resource));\n    OpInputList bucketized_features_list;\n    OP_REQUIRES_OK(context, context->input_list(\"bucketized_features\",\n                                                &bucketized_features_list));\n    std::vector<tensorflow::TTypes<int32>::ConstMatrix> bucketized_features;\n    bucketized_features.reserve(bucketized_features_list.size());\n    ConvertVectorsToMatrices(bucketized_features_list, bucketized_features);\n    const int batch_size = bucketized_features[0].dimension(0);\n    Tensor* output_logits_t = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                \"logits\", {batch_size, logits_dimension_},\n                                &output_logits_t));\n    auto output_logits = output_logits_t->matrix<float>();\n    if (resource->num_trees() <= 0) {\n      output_logits.setZero();\n      return;\n    }\n    const int32 last_tree = resource->num_trees() - 1;\n    auto do_work = [&resource, &bucketized_features, &output_logits, last_tree,\n                    this](int32 start, int32 end) {\n      for (int32 i = start; i < end; ++i) {\n        std::vector<float> tree_logits(logits_dimension_, 0.0);\n        int32 tree_id = 0;\n        int32 node_id = 0;\n        while (true) {\n          if (resource->is_leaf(tree_id, node_id)) {\n            const float tree_weight = resource->GetTreeWeight(tree_id);\n            const auto& leaf_logits = resource->node_value(tree_id, node_id);\n            DCHECK_EQ(leaf_logits.size(), logits_dimension_);\n            for (int32 j = 0; j < logits_dimension_; ++j) {\n              tree_logits[j] += tree_weight * leaf_logits[j];\n            }\n            if (tree_id == last_tree) {\n              break;\n            }\n            ++tree_id;\n            node_id = 0;\n          } else {\n            node_id =\n                resource->next_node(tree_id, node_id, i, bucketized_features);\n          }\n        }\n        for (int32 j = 0; j < logits_dimension_; ++j) {\n          output_logits(i, j) = tree_logits[j];\n        }\n      }\n    };\n    const int64 cost = (last_tree + 1) * 10;\n    thread::ThreadPool* const worker_threads =\n        context->device()->tensorflow_cpu_worker_threads()->workers;\n    Shard(worker_threads->NumThreads(), worker_threads, batch_size,\n          cost, do_work);\n  }", "target": 1}
{"code": "static void process_tree(struct rev_info *revs,\n\t\t\t struct tree *tree,\n\t\t\t show_object_fn show,\n\t\t\t struct strbuf *base,\n\t\t\t const char *name,\n\t\t\t void *cb_data)\n{\n\tstruct object *obj = &tree->object;\n\tstruct tree_desc desc;\n\tstruct name_entry entry;\n\tenum interesting match = revs->diffopt.pathspec.nr == 0 ?\n\t\tall_entries_interesting: entry_not_interesting;\n\tint baselen = base->len;\n\tif (!revs->tree_objects)\n\t\treturn;\n\tif (!obj)\n\t\tdie(\"bad tree object\");\n\tif (obj->flags & (UNINTERESTING | SEEN))\n\t\treturn;\n\tif (parse_tree_gently(tree, revs->ignore_missing_links) < 0) {\n\t\tif (revs->ignore_missing_links)\n\t\t\treturn;\n\t\tdie(\"bad tree object %s\", oid_to_hex(&obj->oid));\n\t}\n\tobj->flags |= SEEN;\n\tshow(obj, base, name, cb_data);\n\tstrbuf_addstr(base, name);\n\tif (base->len)\n\t\tstrbuf_addch(base, '/');\n\tinit_tree_desc(&desc, tree->buffer, tree->size);\n\twhile (tree_entry(&desc, &entry)) {\n\t\tif (match != all_entries_interesting) {\n\t\t\tmatch = tree_entry_interesting(&entry, base, 0,\n\t\t\t\t\t\t       &revs->diffopt.pathspec);\n\t\t\tif (match == all_entries_not_interesting)\n\t\t\t\tbreak;\n\t\t\tif (match == entry_not_interesting)\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (S_ISDIR(entry.mode))\n\t\t\tprocess_tree(revs,\n\t\t\t\t     lookup_tree(entry.sha1),\n\t\t\t\t     show, base, entry.path,\n\t\t\t\t     cb_data);\n\t\telse if (S_ISGITLINK(entry.mode))\n\t\t\tprocess_gitlink(revs, entry.sha1,\n\t\t\t\t\tshow, base, entry.path,\n\t\t\t\t\tcb_data);\n\t\telse\n\t\t\tprocess_blob(revs,\n\t\t\t\t     lookup_blob(entry.sha1),\n\t\t\t\t     show, base, entry.path,\n\t\t\t\t     cb_data);\n\t}\n\tstrbuf_setlen(base, baselen);\n\tfree_tree_buffer(tree);\n}", "target": 1}
{"code": "  Status BuildInputArgIndex(const OpDef::ArgDef& arg_def, AttrSlice attr_values,\n                            const FunctionDef::ArgAttrs* arg_attrs,\n                            bool ints_on_device,\n                            int64_t resource_arg_unique_id) {\n    bool is_type_list;\n    DataTypeVector dtypes;\n    TF_RETURN_IF_ERROR(\n        ArgNumType(attr_values, arg_def, &is_type_list, &dtypes));\n    CHECK_GE(dtypes.size(), size_t{1});\n    int arg_index = result_.nodes.size();\n    TF_RETURN_IF_ERROR(\n        AddItem(arg_def.name(), {true, arg_index, 0, is_type_list, dtypes}));\n    for (size_t i = 0; i < dtypes.size(); ++i) {\n      TF_RETURN_IF_ERROR(AddItem(strings::StrCat(arg_def.name(), \":\", i),\n                                 {true, arg_index, 0, false, {dtypes[i]}}));\n      DCHECK_EQ(arg_index, result_.nodes.size());\n      string name = arg_def.name();\n      if (dtypes.size() > 1) {\n        strings::StrAppend(&name, \"_\", i);\n      }\n      NodeDef* gnode = AddNode(name);\n      if (ints_on_device && dtypes[i] == DataType::DT_INT32) {\n        gnode->set_op(FunctionLibraryDefinition::kDeviceArgOp);\n      } else {\n        gnode->set_op(FunctionLibraryDefinition::kArgOp);\n      }\n      DataType dtype = arg_def.is_ref() ? MakeRefType(dtypes[i]) : dtypes[i];\n      AddAttr(\"T\", dtype, gnode);\n      AddAttr(\"index\", arg_index, gnode);\n      if (resource_arg_unique_id >= 0) {\n        AddAttr(\"_resource_arg_unique_id\", resource_arg_unique_id, gnode);\n      }\n      if (arg_attrs) {\n        for (const auto& arg_attr : arg_attrs->attr()) {\n          AddAttr(arg_attr.first, arg_attr.second, gnode->mutable_attr());\n        }\n      }\n      result_.arg_types.push_back(dtypes[i]);\n      ++arg_index;\n    }\n    return Status::OK();\n  }", "target": 1}
{"code": "void __drm_atomic_state_free(struct kref *ref)\n{\n\tstruct drm_atomic_state *state = container_of(ref, typeof(*state), ref);\n\tstruct drm_mode_config *config = &state->dev->mode_config;\n\tdrm_atomic_state_clear(state);\n\tdrm_dbg_atomic(state->dev, \"Freeing atomic state %p\\n\", state);\n\tif (config->funcs->atomic_state_free) {\n\t\tconfig->funcs->atomic_state_free(state);\n\t} else {\n\t\tdrm_atomic_state_default_release(state);\n\t\tkfree(state);\n\t}\n}", "target": 1}
{"code": "static bool ldm_frag_add (const u8 *data, int size, struct list_head *frags)\n{\n\tstruct frag *f;\n\tstruct list_head *item;\n\tint rec, num, group;\n\tBUG_ON (!data || !frags);\n\tif (size < 2 * VBLK_SIZE_HEAD) {\n\t\tldm_error(\"Value of size is to small.\");\n\t\treturn false;\n\t}\n\tgroup = get_unaligned_be32(data + 0x08);\n\trec   = get_unaligned_be16(data + 0x0C);\n\tnum   = get_unaligned_be16(data + 0x0E);\n\tif ((num < 1) || (num > 4)) {\n\t\tldm_error (\"A VBLK claims to have %d parts.\", num);\n\t\treturn false;\n\t}\n\tif (rec >= num) {\n\t\tldm_error(\"REC value (%d) exceeds NUM value (%d)\", rec, num);\n\t\treturn false;\n\t}\n\tlist_for_each (item, frags) {\n\t\tf = list_entry (item, struct frag, list);\n\t\tif (f->group == group)\n\t\t\tgoto found;\n\t}\n\tf = kmalloc (sizeof (*f) + size*num, GFP_KERNEL);\n\tif (!f) {\n\t\tldm_crit (\"Out of memory.\");\n\t\treturn false;\n\t}\n\tf->group = group;\n\tf->num   = num;\n\tf->rec   = rec;\n\tf->map   = 0xFF << num;\n\tlist_add_tail (&f->list, frags);\nfound:\n\tif (rec >= f->num) {\n\t\tldm_error(\"REC value (%d) exceeds NUM value (%d)\", rec, f->num);\n\t\treturn false;\n\t}\n\tif (f->map & (1 << rec)) {\n\t\tldm_error (\"Duplicate VBLK, part %d.\", rec);\n\t\tf->map &= 0x7F;\t\t\t\n\t\treturn false;\n\t}\n\tf->map |= (1 << rec);\n\tdata += VBLK_SIZE_HEAD;\n\tsize -= VBLK_SIZE_HEAD;\n\tmemcpy (f->data+rec*(size-VBLK_SIZE_HEAD)+VBLK_SIZE_HEAD, data, size);\n\treturn true;\n}", "target": 0}
{"code": "static unsigned long get_ctl_id_hash(const struct snd_ctl_elem_id *id)\n{\n\tint i;\n\tunsigned long h;\n\th = id->iface;\n\th = MULTIPLIER * h + id->device;\n\th = MULTIPLIER * h + id->subdevice;\n\tfor (i = 0; i < SNDRV_CTL_ELEM_ID_NAME_MAXLEN && id->name[i]; i++)\n\t\th = MULTIPLIER * h + id->name[i];\n\th = MULTIPLIER * h + id->index;\n\th &= LONG_MAX;\n\treturn h;\n}", "target": 0}
{"code": "unsigned paravirt_patch_call(void *insnbuf,\n\t\t\t     const void *target, u16 tgt_clobbers,\n\t\t\t     unsigned long addr, u16 site_clobbers,\n\t\t\t     unsigned len)\n{\n\tstruct branch *b = insnbuf;\n\tunsigned long delta = (unsigned long)target - (addr+5);\n\tif (tgt_clobbers & ~site_clobbers)\n\t\treturn len;\t\n\tif (len < 5)\n\t\treturn len;\t\n\tb->opcode = 0xe8; \n\tb->delta = delta;\n\tBUILD_BUG_ON(sizeof(*b) != 5);\n\treturn 5;\n}", "target": 1}
{"code": "static int uas_find_uas_alt_setting(struct usb_interface *intf)\n{\n\tint i;\n\tfor (i = 0; i < intf->num_altsetting; i++) {\n\t\tstruct usb_host_interface *alt = &intf->altsetting[i];\n\t\tif (uas_is_interface(alt))\n\t\t\treturn alt->desc.bAlternateSetting;\n\t}\n\treturn -ENODEV;\n}", "target": 1}
{"code": "static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)\n{\n\tstruct snd_seq_port_info *info = arg;\n\tstruct snd_seq_client_port *port;\n\tstruct snd_seq_port_callback *callback;\n\tif (info->addr.client != client->number)\n\t\treturn -EPERM;\n\tport = snd_seq_create_port(client, (info->flags & SNDRV_SEQ_PORT_FLG_GIVEN_PORT) ? info->addr.port : -1);\n\tif (port == NULL)\n\t\treturn -ENOMEM;\n\tif (client->type == USER_CLIENT && info->kernel) {\n\t\tsnd_seq_delete_port(client, port->addr.port);\n\t\treturn -EINVAL;\n\t}\n\tif (client->type == KERNEL_CLIENT) {\n\t\tif ((callback = info->kernel) != NULL) {\n\t\t\tif (callback->owner)\n\t\t\t\tport->owner = callback->owner;\n\t\t\tport->private_data = callback->private_data;\n\t\t\tport->private_free = callback->private_free;\n\t\t\tport->event_input = callback->event_input;\n\t\t\tport->c_src.open = callback->subscribe;\n\t\t\tport->c_src.close = callback->unsubscribe;\n\t\t\tport->c_dest.open = callback->use;\n\t\t\tport->c_dest.close = callback->unuse;\n\t\t}\n\t}\n\tinfo->addr = port->addr;\n\tsnd_seq_set_port_info(port, info);\n\tsnd_seq_system_client_ev_port_start(port->addr.client, port->addr.port);\n\treturn 0;\n}", "target": 1}
{"code": "TEST_F(EncryptedRecordTest, TestAllPaddingHandshake) {\n  addToQueue(\"17030100050123456789\");\n  EXPECT_CALL(*readAead_, _decrypt(_, _, 0))\n      .WillOnce(Invoke([](std::unique_ptr<IOBuf>& buf, const IOBuf*, uint64_t) {\n        expectSame(buf, \"0123456789\");\n        return getBuf(\"16000000\");\n      }));\n  EXPECT_NO_THROW(read_.read(queue_));\n}", "target": 1}
{"code": "static int cms_copy_content(BIO *out, BIO *in, unsigned int flags)\n\t{\n\tunsigned char buf[4096];\n\tint r = 0, i;\n\tBIO *tmpout = NULL;\n\tif (out == NULL)\n\t\ttmpout = BIO_new(BIO_s_null());\n\telse if (flags & CMS_TEXT)\n\t\t{\n\t\ttmpout = BIO_new(BIO_s_mem());\n\t\tBIO_set_mem_eof_return(tmpout, 0);\n\t\t}\n\telse\n\t\ttmpout = out;\n\tif(!tmpout)\n\t\t{\n\t\tCMSerr(CMS_F_CMS_COPY_CONTENT,ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t\t}\n\tfor (;;)\n\t{\n\t\ti=BIO_read(in,buf,sizeof(buf));\n\t\tif (i <= 0)\n\t\t\t{\n\t\t\tif (BIO_method_type(in) == BIO_TYPE_CIPHER)\n\t\t\t\t{\n\t\t\t\tif (!BIO_get_cipher_status(in))\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\tif (i < 0)\n\t\t\t\tgoto err;\n\t\t\tbreak;\n\t\t\t}\n\t\tif (tmpout && (BIO_write(tmpout, buf, i) != i))\n\t\t\tgoto err;\n\t}\n\tif(flags & CMS_TEXT)\n\t\t{\n\t\tif(!SMIME_text(tmpout, out))\n\t\t\t{\n\t\t\tCMSerr(CMS_F_CMS_COPY_CONTENT,CMS_R_SMIME_TEXT_ERROR);\n\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\tr = 1;\n\terr:\n\tif (tmpout && (tmpout != out))\n\t\tBIO_free(tmpout);\n\treturn r;\n\t}", "target": 1}
{"code": "static uint64_t unpack_timestamp(const struct efi_time *timestamp)\n{\n\tuint64_t val = 0;\n\tuint16_t year = le32_to_cpu(timestamp->year);\n\tval |= ((uint64_t) timestamp->pad1 & 0xFF) << 0;\n\tval |= ((uint64_t) timestamp->second & 0xFF) << (1*8);\n\tval |= ((uint64_t) timestamp->minute & 0xFF) << (2*8);\n\tval |= ((uint64_t) timestamp->hour & 0xFF) << (3*8);\n\tval |= ((uint64_t) timestamp->day & 0xFF) << (4*8);\n\tval |= ((uint64_t) timestamp->month & 0xFF) << (5*8);\n\tval |= ((uint64_t) year) << (6*8);\n\treturn val;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    const Tensor& grad_in = context->input(1);\n    const Tensor& argmax = context->input(2);\n    PoolParameters params{context,\n                          ksize_,\n                          stride_,\n                          padding_,\n                          {},\n                          FORMAT_NHWC,\n                          tensor_in.shape()};\n    if (!context->status().ok()) {\n      return;\n    }\n    TensorShape out_shape({params.tensor_in_batch, params.tensor_in_rows,\n                           params.tensor_in_cols, params.depth});\n    Tensor* grad_out = nullptr;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                {0}, 0, out_shape, &grad_out));\n    if (out_shape.num_elements() == 0) return;  \n    LaunchMaxPoolingGradWithArgmax<Device, T>::launch(\n        context, params, grad_in, argmax, grad_out, include_batch_in_index_);\n  }", "target": 0}
{"code": "int posix_acl_update_mode(struct inode *inode, umode_t *mode_p,\n\t\t\t  struct posix_acl **acl)\n{\n\tumode_t mode = inode->i_mode;\n\tint error;\n\terror = posix_acl_equiv_mode(*acl, &mode);\n\tif (error < 0)\n\t\treturn error;\n\tif (error == 0)\n\t\t*acl = NULL;\n\tif (!in_group_p(inode->i_gid) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\tmode &= ~S_ISGID;\n\t*mode_p = mode;\n\treturn 0;\n}", "target": 0}
{"code": "int CLASS ljpeg_start (struct jhead *jh, int info_only)\n{\n  int c, tag, len;\n  uchar data[0x10000];\n  const uchar *dp;\n  memset (jh, 0, sizeof *jh);\n  jh->restart = INT_MAX;\n  fread (data, 2, 1, ifp);\n  if (data[1] != 0xd8) return 0;\n  do {\n    fread (data, 2, 2, ifp);\n    tag =  data[0] << 8 | data[1];\n    len = (data[2] << 8 | data[3]) - 2;\n    if (tag <= 0xff00) return 0;\n    fread (data, 1, len, ifp);\n    switch (tag) {\n      case 0xffc3:\n\tjh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;\n      case 0xffc0:\n\tjh->bits = data[0];\n\tjh->high = data[1] << 8 | data[2];\n\tjh->wide = data[3] << 8 | data[4];\n\tjh->clrs = data[5] + jh->sraw;\n\tif (len == 9 && !dng_version) getc(ifp);\n\tbreak;\n      case 0xffc4:\n\tif (info_only) break;\n\tfor (dp = data; dp < data+len && (c = *dp++) < 4; )\n\t  jh->free[c] = jh->huff[c] = make_decoder_ref (&dp);\n\tbreak;\n      case 0xffda:\n\tjh->psv = data[1+data[0]*2];\n\tjh->bits -= data[3+data[0]*2] & 15;\n\tbreak;\n      case 0xffdd:\n\tjh->restart = data[0] << 8 | data[1];\n    }\n  } while (tag != 0xffda);\n  if (info_only) return 1;\n  if (jh->clrs > 6 || !jh->huff[0]) return 0;\n  FORC(5) if (!jh->huff[c+1]) jh->huff[c+1] = jh->huff[c];\n  if (jh->sraw) {\n    FORC(4)        jh->huff[2+c] = jh->huff[1];\n    FORC(jh->sraw) jh->huff[1+c] = jh->huff[0];\n  }\n  jh->row = (ushort *) calloc (jh->wide*jh->clrs, 4);\n  merror (jh->row, \"ljpeg_start()\");\n  return zero_after_ff = 1;\n}", "target": 1}
{"code": "static wStream* rdg_receive_packet(rdpRdg* rdg)\n{\n\twStream* s;\n\tconst size_t header = sizeof(RdgPacketHeader);\n\tsize_t packetLength;\n\tassert(header <= INT_MAX);\n\ts = Stream_New(NULL, 1024);\n\tif (!s)\n\t\treturn NULL;\n\tif (!rdg_read_all(rdg->tlsOut, Stream_Buffer(s), header))\n\t{\n\t\tStream_Free(s, TRUE);\n\t\treturn NULL;\n\t}\n\tStream_Seek(s, 4);\n\tStream_Read_UINT32(s, packetLength);\n\tif ((packetLength > INT_MAX) || !Stream_EnsureCapacity(s, packetLength))\n\t{\n\t\tStream_Free(s, TRUE);\n\t\treturn NULL;\n\t}\n\tif (!rdg_read_all(rdg->tlsOut, Stream_Buffer(s) + header, (int)packetLength - (int)header))\n\t{\n\t\tStream_Free(s, TRUE);\n\t\treturn NULL;\n\t}\n\tStream_SetLength(s, packetLength);\n\treturn s;\n}", "target": 1}
{"code": "void DoImageProjectiveTransformOp(OpKernelContext* ctx,\n                                  const Interpolation& interpolation,\n                                  const Mode& fill_mode) {\n  const Tensor& images_t = ctx->input(0);\n  const Tensor& transform_t = ctx->input(1);\n  OP_REQUIRES(ctx, images_t.shape().dims() == 4,\n              errors::InvalidArgument(\"Input images must have rank 4\"));\n  OP_REQUIRES(ctx,\n              (TensorShapeUtils::IsMatrix(transform_t.shape()) &&\n               (transform_t.dim_size(0) == images_t.dim_size(0) ||\n                transform_t.dim_size(0) == 1) &&\n               transform_t.dim_size(1) == 8),\n              errors::InvalidArgument(\n                  \"Input transform should be num_images x 8 or 1 x 8\"));\n  int32_t out_height, out_width;\n  if (ctx->num_inputs() >= 3) {\n    const Tensor& shape_t = ctx->input(2);\n    OP_REQUIRES(ctx, shape_t.dims() == 1,\n                errors::InvalidArgument(\"output shape must be 1-dimensional\",\n                                        shape_t.shape().DebugString()));\n    OP_REQUIRES(ctx, shape_t.NumElements() == 2,\n                errors::InvalidArgument(\"output shape must have two elements\",\n                                        shape_t.shape().DebugString()));\n    auto shape_vec = shape_t.vec<int32>();\n    out_height = shape_vec(0);\n    out_width = shape_vec(1);\n    OP_REQUIRES(ctx, out_height > 0 && out_width > 0,\n                errors::InvalidArgument(\"output dimensions must be positive\"));\n  } else {\n    out_height = images_t.shape().dim_size(1);\n    out_width = images_t.shape().dim_size(2);\n  }\n  T fill_value(0);\n  if (ctx->num_inputs() >= 4) {\n    const Tensor& fill_value_t = ctx->input(3);\n    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(fill_value_t.shape()),\n                errors::InvalidArgument(\"fill_value must be a scalar\",\n                                        fill_value_t.shape().DebugString()));\n    fill_value = static_cast<T>(*(fill_value_t.scalar<float>().data()));\n  }\n  Tensor* output_t;\n  OP_REQUIRES_OK(\n      ctx, ctx->allocate_output(0,\n                                TensorShape({images_t.dim_size(0), out_height,\n                                             out_width, images_t.dim_size(3)}),\n                                &output_t));\n  auto output = output_t->tensor<T, 4>();\n  auto images = images_t.tensor<T, 4>();\n  auto transform = transform_t.matrix<float>();\n  (FillProjectiveTransform<Device, T>(interpolation))(\n      ctx->eigen_device<Device>(), &output, images, transform, fill_mode,\n      fill_value);\n}", "target": 1}
{"code": "static size_t consume_init_expr (ut8 *buf, ut8 *max, ut8 eoc, void *out, ut32 *offset) {\n\tut32 i = 0;\n\twhile (buf + i < max && buf[i] != eoc) {\n\t\ti += 1;\n\t}\n\tif (buf[i] != eoc) {\n\t\treturn 0;\n\t}\n\tif (offset) {\n\t\t*offset += i + 1;\n\t}\n\treturn i + 1;\n}", "target": 1}
{"code": "void auth_client_request_abort(struct auth_client_request **_request)\n{\n\tstruct auth_client_request *request = *_request;\n\t*_request = NULL;\n\tauth_client_send_cancel(request->conn->client, request->id);\n\tcall_callback(request, AUTH_REQUEST_STATUS_ABORT, NULL, NULL);\n\tpool_unref(&request->pool);\n}", "target": 0}
{"code": "crm_send_remote_msg_raw(void *session, const char *buf, size_t len, gboolean encrypted)\n{\n    int rc = -1;\n    if (encrypted) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        rc = crm_send_tls(session, buf, len);\n#else\n        CRM_ASSERT(encrypted == FALSE);\n#endif\n    } else {\n        rc = crm_send_plaintext(GPOINTER_TO_INT(session), buf, len);\n    }\n    return rc;\n}", "target": 0}
{"code": "static int remarkupvals (global_State *g) {\n  lua_State *thread;\n  lua_State **p = &g->twups;\n  int work = 0;\n  while ((thread = *p) != NULL) {\n    work++;\n    lua_assert(!isblack(thread));  \n    if (isgray(thread) && thread->openupval != NULL)\n      p = &thread->twups;  \n    else {  \n      UpVal *uv;\n      lua_assert(!isold(thread) || thread->openupval == NULL);\n      *p = thread->twups;  \n      thread->twups = thread;  \n      for (uv = thread->openupval; uv != NULL; uv = uv->u.open.next) {\n        lua_assert(getage(uv) <= getage(thread));\n        work++;\n        if (!iswhite(uv))  \n          markvalue(g, uv->v);  \n      }\n    }\n  }\n  return work;\n}", "target": 0}
{"code": "void SSecurityTLS::initGlobal()\n{\n  static bool globalInitDone = false;\n  if (!globalInitDone) {\n    if (gnutls_global_init() != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_global_init failed\");\n    globalInitDone = true;\n  }\n}", "target": 1}
{"code": "dig_t bn_get_prime(int pos) {\n\tif (pos >= BASIC_TESTS) {\n\t\treturn 0;\n\t}\n\treturn primes[pos];\n}", "target": 1}
{"code": "gboolean menu_cache_item_unref(MenuCacheItem* item)\n{\n    MENU_CACHE_LOCK; \n    if( g_atomic_int_dec_and_test( &item->n_ref ) )\n    {\n        g_free( item->id );\n        g_free( item->name );\n        g_free( item->comment );\n        g_free( item->icon );\n        menu_cache_file_dir_unref(item->file_dir);\n        if( item->file_name && item->file_name != item->id )\n            g_free( item->file_name );\n        if( item->parent )\n        {\n            item->parent->children = g_slist_remove(item->parent->children, item);\n        }\n        if( item->type == MENU_CACHE_TYPE_DIR )\n        {\n            MenuCacheDir* dir = MENU_CACHE_DIR(item);\n            GSList* l;\n            for(l = dir->children; l; )\n            {\n                MenuCacheItem* child = MENU_CACHE_ITEM(l->data);\n                child->parent = NULL;\n                l = l->next;\n                menu_cache_item_unref(child);\n            }\n            g_slist_free( dir->children );\n            g_slice_free( MenuCacheDir, dir );\n        }\n        else\n        {\n            MenuCacheApp* app = MENU_CACHE_APP(item);\n            g_free( app->exec );\n            g_free(app->try_exec);\n            g_free(app->working_dir);\n            g_free(app->categories);\n            g_free(app->keywords);\n            g_slice_free( MenuCacheApp, app );\n        }\n    }\n    MENU_CACHE_UNLOCK;\n    return FALSE;\n}", "target": 0}
{"code": "int scsi_cmd_blk_ioctl(struct block_device *bd, fmode_t mode,\n\t\t       unsigned int cmd, void __user *arg)\n{\n\tint ret;\n\tret = scsi_verify_blk_ioctl(bd, cmd);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn scsi_cmd_ioctl(bd->bd_disk->queue, bd->bd_disk, mode, cmd, arg);\n}", "target": 0}
{"code": "void HeaderTable::setCapacity(uint32_t capacity) {\n  auto oldCapacity = capacity_;\n  capacity_ = capacity;\n  if (capacity_ <= oldCapacity) {\n    evict(0);\n  } else {\n    auto oldTail = tail();\n    auto oldLength = table_.size();\n    uint32_t newLength = (capacity_ >> 5) + 1;\n    table_.resize(newLength);\n    if (size_ > 0 && oldTail > head_) {\n      std::copy(table_.begin() + oldTail, table_.begin() + oldLength,\n                table_.begin() + newLength - (oldLength - oldTail));\n      for (auto& names_it: names_) {\n        for (auto& idx: names_it.second) {\n          if (idx >= oldTail) {\n            DCHECK_LT(idx + (table_.size() - oldLength), table_.size());\n            idx += (table_.size() - oldLength);\n          } else {\n            break;\n          }\n        }\n      }\n    }\n  }\n}", "target": 1}
{"code": "bool_t xdr_krb5_tl_data(XDR *xdrs, krb5_tl_data **tl_data_head)\n{\n     krb5_tl_data *tl, *tl2;\n     bool_t more;\n     unsigned int len;\n     switch (xdrs->x_op) {\n     case XDR_FREE:\n\t  tl = tl2 = *tl_data_head;\n\t  while (tl) {\n\t       tl2 = tl->tl_data_next;\n\t       free(tl->tl_data_contents);\n\t       free(tl);\n\t       tl = tl2;\n\t  }\n\t  *tl_data_head = NULL;\n\t  break;\n     case XDR_ENCODE:\n\t  tl = *tl_data_head;\n\t  while (1) {\n\t       more = (tl != NULL);\n\t       if (!xdr_bool(xdrs, &more))\n\t\t    return FALSE;\n\t       if (tl == NULL)\n\t\t    break;\n\t       if (!xdr_krb5_int16(xdrs, &tl->tl_data_type))\n\t\t    return FALSE;\n\t       len = tl->tl_data_length;\n\t       if (!xdr_bytes(xdrs, (char **) &tl->tl_data_contents, &len, ~0))\n\t\t    return FALSE;\n\t       tl = tl->tl_data_next;\n\t  }\n\t  break;\n     case XDR_DECODE:\n\t  tl = NULL;\n\t  while (1) {\n\t       if (!xdr_bool(xdrs, &more))\n\t\t    return FALSE;\n\t       if (more == FALSE)\n\t\t    break;\n\t       tl2 = (krb5_tl_data *) malloc(sizeof(krb5_tl_data));\n\t       if (tl2 == NULL)\n\t\t    return FALSE;\n\t       memset(tl2, 0, sizeof(krb5_tl_data));\n\t       if (!xdr_krb5_int16(xdrs, &tl2->tl_data_type))\n\t\t    return FALSE;\n\t       if (!xdr_bytes(xdrs, (char **)&tl2->tl_data_contents, &len, ~0))\n\t\t    return FALSE;\n\t       tl2->tl_data_length = len;\n\t       tl2->tl_data_next = tl;\n\t       tl = tl2;\n\t  }\n\t  *tl_data_head = tl;\n\t  break;\n     }\n     return TRUE;\n}", "target": 0}
{"code": "ssize_t tcp_splice_read(struct socket *sock, loff_t *ppos,\n\t\t\tstruct pipe_inode_info *pipe, size_t len,\n\t\t\tunsigned int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct tcp_splice_state tss = {\n\t\t.pipe = pipe,\n\t\t.len = len,\n\t\t.flags = flags,\n\t};\n\tlong timeo;\n\tssize_t spliced;\n\tint ret;\n\tsock_rps_record_flow(sk);\n\tif (unlikely(*ppos))\n\t\treturn -ESPIPE;\n\tret = spliced = 0;\n\tlock_sock(sk);\n\ttimeo = sock_rcvtimeo(sk, sock->file->f_flags & O_NONBLOCK);\n\twhile (tss.len) {\n\t\tret = __tcp_splice_read(sk, &tss);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\telse if (!ret) {\n\t\t\tif (spliced)\n\t\t\t\tbreak;\n\t\t\tif (sock_flag(sk, SOCK_DONE))\n\t\t\t\tbreak;\n\t\t\tif (sk->sk_err) {\n\t\t\t\tret = sock_error(sk);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\t\tbreak;\n\t\t\tif (sk->sk_state == TCP_CLOSE) {\n\t\t\t\tif (!sock_flag(sk, SOCK_DONE))\n\t\t\t\t\tret = -ENOTCONN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!timeo) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!skb_queue_empty(&sk->sk_receive_queue))\n\t\t\t\tbreak;\n\t\t\tsk_wait_data(sk, &timeo, NULL);\n\t\t\tif (signal_pending(current)) {\n\t\t\t\tret = sock_intr_errno(timeo);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\ttss.len -= ret;\n\t\tspliced += ret;\n\t\tif (!timeo)\n\t\t\tbreak;\n\t\trelease_sock(sk);\n\t\tlock_sock(sk);\n\t\tif (sk->sk_err || sk->sk_state == TCP_CLOSE ||\n\t\t    (sk->sk_shutdown & RCV_SHUTDOWN) ||\n\t\t    signal_pending(current))\n\t\t\tbreak;\n\t}\n\trelease_sock(sk);\n\tif (spliced)\n\t\treturn spliced;\n\treturn ret;\n}", "target": 0}
{"code": "  virtual void requestInit() {\n    m_use_error = false;\n    m_errors.reset();\n    xmlParserInputBufferCreateFilenameDefault(nullptr);\n  }", "target": 1}
{"code": "ssize_t uv__idna_toascii(const char* s, const char* se, char* d, char* de) {\n  const char* si;\n  const char* st;\n  unsigned c;\n  char* ds;\n  int rc;\n  if (s == se)\n    return UV_EINVAL;\n  ds = d;\n  si = s;\n  while (si < se) {\n    st = si;\n    c = uv__utf8_decode1(&si, se);\n    if (c == UINT_MAX)\n      return UV_EINVAL;\n    if (c != '.')\n      if (c != 0x3002)  \n        if (c != 0xFF0E)  \n          if (c != 0xFF61)  \n            continue;\n    rc = uv__idna_toascii_label(s, st, &d, de);\n    if (rc < 0)\n      return rc;\n    if (d < de)\n      *d++ = '.';\n    s = si;\n  }\n  if (s < se) {\n    rc = uv__idna_toascii_label(s, se, &d, de);\n    if (rc < 0)\n      return rc;\n  }\n  if (d >= de)\n    return UV_EINVAL;\n  *d++ = '\\0';\n  return d - ds;  \n}", "target": 0}
{"code": "Status RangeSize(const Tensor* start_t, const Tensor* limit_t,\n                 const Tensor* delta_t, InferenceContext* const c) {\n  T start = start_t->scalar<T>()();\n  T limit = limit_t->scalar<T>()();\n  T delta = delta_t->scalar<T>()();\n  if (start > limit && delta > T(0)) {\n    return errors::InvalidArgument(\n        \"Requires start <= limit when delta > 0: \", start, \"/\", limit);\n  }\n  if (start < limit && delta < T(0)) {\n    return errors::InvalidArgument(\n        \"Requires start >= limit when delta < 0: \", start, \"/\", limit);\n  }\n  if (delta == T(0)) {\n    return errors::InvalidArgument(\"Requires delta != 0\");\n  }\n  auto size = (std::is_integral<T>::value\n                   ? ((Eigen::numext::abs(limit - start) +\n                       Eigen::numext::abs(delta) - T(1)) /\n                      Eigen::numext::abs(delta))\n                   : (Eigen::numext::ceil(\n                         Eigen::numext::abs((limit - start) / delta))));\n  if (size > std::numeric_limits<int64_t>::max()) {\n    return errors::InvalidArgument(\"Requires ((limit - start) / delta) <= \",\n                                   std::numeric_limits<int64_t>::max());\n  }\n  c->set_output(0, c->Vector(static_cast<int64_t>(size)));\n  return Status::OK();\n}", "target": 1}
{"code": "AirPDcapGetSa(\n    PAIRPDCAP_CONTEXT ctx,\n    AIRPDCAP_SEC_ASSOCIATION_ID *id)\n{\n    INT sa_index;\n    if (ctx->sa_index!=-1) {\n        for (sa_index=ctx->sa_index; sa_index>=0; sa_index--) {\n            if (ctx->sa[sa_index].used) {\n                if (memcmp(id, &(ctx->sa[sa_index].saId), sizeof(AIRPDCAP_SEC_ASSOCIATION_ID))==0) {\n                    ctx->index=sa_index;\n                    return sa_index;\n                }\n            }\n        }\n    }\n    return -1;\n}", "target": 0}
{"code": "static bool allowed_problem_dir(const char *dir_name)\n{\n#if 0\n    unsigned len = strlen(g_settings_dump_location);\n    if (strncmp(dir_name, g_settings_dump_location, len) != 0\n     || (dir_name[len] != '/' && dir_name[len] != '\\0')\n     || strstr(dir_name + len, \"/.\")\n    ) {\n        return false;\n    }\n#endif\n    return true;\n}", "target": 1}
{"code": "static inline int check_entry_size_and_hooks(struct arpt_entry *e,\n\t\t\t\t\t     struct xt_table_info *newinfo,\n\t\t\t\t\t     const unsigned char *base,\n\t\t\t\t\t     const unsigned char *limit,\n\t\t\t\t\t     const unsigned int *hook_entries,\n\t\t\t\t\t     const unsigned int *underflows,\n\t\t\t\t\t     unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct arpt_entry) >= limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_err(\"Underflows must be unconditional and \"\n\t\t\t\t       \"use the STANDARD target with \"\n\t\t\t\t       \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 1}
{"code": "static int em_call(struct x86_emulate_ctxt *ctxt)\n{\n\tlong rel = ctxt->src.val;\n\tctxt->src.val = (unsigned long)ctxt->_eip;\n\tjmp_rel(ctxt, rel);\n\treturn em_push(ctxt);\n}", "target": 1}
{"code": "xsltVariableComp(xsltStylesheetPtr style, xmlNodePtr inst) {\n#ifdef XSLT_REFACTORED\n    xsltStyleItemVariablePtr comp;\n#else\n    xsltStylePreCompPtr comp;\n#endif\n    if ((style == NULL) || (inst == NULL) || (inst->type != XML_ELEMENT_NODE))\n\treturn;\n#ifdef XSLT_REFACTORED\n    comp = (xsltStyleItemVariablePtr)\n\txsltNewStylePreComp(style, XSLT_FUNC_VARIABLE);\n#else\n    comp = xsltNewStylePreComp(style, XSLT_FUNC_VARIABLE);\n#endif\n    if (comp == NULL)\n\treturn;\n    inst->psvi = comp;\n    comp->inst = inst;\n    xsltGetQNameProperty(style, inst, BAD_CAST \"name\",\n\t1, &(comp->has_name), &(comp->ns), &(comp->name));\n    if (comp->ns)\n\tcomp->has_ns = 1;\n    comp->select = xsltGetCNsProp(style, inst, (const xmlChar *)\"select\",\n\t                        XSLT_NAMESPACE);\n    if (comp->select != NULL) {\n#ifndef XSLT_REFACTORED\n        xmlNodePtr cur;\n#endif\n\tcomp->comp = xsltXPathCompile(style, comp->select);\n\tif (comp->comp == NULL) {\n\t    xsltTransformError(NULL, style, inst,\n\t\t\"XSLT-variable: Failed to compile the XPath expression '%s'.\\n\",\n\t\tcomp->select);\n\t    style->errors++;\n\t}\n#ifdef XSLT_REFACTORED\n\tif (inst->children != NULL) {\n\t    xsltTransformError(NULL, style, inst,\n\t\t\"XSLT-variable: There must be no child nodes, since the \"\n\t\t\"attribute 'select' was specified.\\n\");\n\t    style->errors++;\n\t}\n#else\n        for (cur = inst->children; cur != NULL; cur = cur->next) {\n            if (cur->type != XML_COMMENT_NODE &&\n                (cur->type != XML_TEXT_NODE || !xsltIsBlank(cur->content)))\n            {\n                xsltTransformError(NULL, style, inst,\n                    \"XSLT-variable: There must be no child nodes, since the \"\n                    \"attribute 'select' was specified.\\n\");\n                style->errors++;\n            }\n        }\n#endif\n    }\n}", "target": 0}
{"code": "static int get_gate_page(struct mm_struct *mm, unsigned long address,\n\t\tunsigned int gup_flags, struct vm_area_struct **vma,\n\t\tstruct page **page)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *pte;\n\tint ret = -EFAULT;\n\tif (gup_flags & FOLL_WRITE)\n\t\treturn -EFAULT;\n\tif (address > TASK_SIZE)\n\t\tpgd = pgd_offset_k(address);\n\telse\n\t\tpgd = pgd_offset_gate(mm, address);\n\tBUG_ON(pgd_none(*pgd));\n\tp4d = p4d_offset(pgd, address);\n\tBUG_ON(p4d_none(*p4d));\n\tpud = pud_offset(p4d, address);\n\tBUG_ON(pud_none(*pud));\n\tpmd = pmd_offset(pud, address);\n\tif (!pmd_present(*pmd))\n\t\treturn -EFAULT;\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\tpte = pte_offset_map(pmd, address);\n\tif (pte_none(*pte))\n\t\tgoto unmap;\n\t*vma = get_gate_vma(mm);\n\tif (!page)\n\t\tgoto out;\n\t*page = vm_normal_page(*vma, address, *pte);\n\tif (!*page) {\n\t\tif ((gup_flags & FOLL_DUMP) || !is_zero_pfn(pte_pfn(*pte)))\n\t\t\tgoto unmap;\n\t\t*page = pte_page(*pte);\n\t\tif (is_device_public_page(*page))\n\t\t\tgoto unmap;\n\t}\n\tget_page(*page);\nout:\n\tret = 0;\nunmap:\n\tpte_unmap(pte);\n\treturn ret;\n}", "target": 1}
{"code": "raptor_rdfxml_parse_start(raptor_parser* rdf_parser)\n{\n  raptor_uri *uri = rdf_parser->base_uri;\n  raptor_rdfxml_parser* rdf_xml_parser;\n  rdf_xml_parser = (raptor_rdfxml_parser*)rdf_parser->context;\n  if(!uri)\n    return 1;\n  raptor_sax2_set_option(rdf_xml_parser->sax2,\n                         RAPTOR_OPTION_NORMALIZE_LANGUAGE, NULL,\n                         RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_NORMALIZE_LANGUAGE));\n  raptor_sax2_set_option(rdf_xml_parser->sax2, \n                         RAPTOR_OPTION_NO_NET, NULL,\n                         RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_NO_NET));\n  raptor_sax2_set_option(rdf_xml_parser->sax2, \n                         RAPTOR_OPTION_NO_FILE, NULL,\n                         RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_NO_FILE));\n  raptor_sax2_set_option(rdf_xml_parser->sax2, \n                         RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES, NULL,\n                         RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES));\n  if(rdf_parser->uri_filter)\n    raptor_sax2_set_uri_filter(rdf_xml_parser->sax2, rdf_parser->uri_filter,\n                               rdf_parser->uri_filter_user_data);\n  raptor_sax2_parse_start(rdf_xml_parser->sax2, uri);\n  if(rdf_xml_parser->id_set) {\n    raptor_free_id_set(rdf_xml_parser->id_set);\n    rdf_xml_parser->id_set = NULL;\n  }\n  if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_CHECK_RDF_ID)) {\n    rdf_xml_parser->id_set = raptor_new_id_set(rdf_parser->world);\n    if(!rdf_xml_parser->id_set)\n      return 1;\n  }\n  return 0;\n}", "target": 0}
{"code": "int bridge__remap_topic_in(struct mosquitto *context, char **topic)\n{\n\tstruct mosquitto__bridge_topic *cur_topic;\n\tchar *topic_temp;\n\tint i;\n\tsize_t len;\n\tint rc;\n\tbool match;\n\tif(context->bridge && context->bridge->topics && context->bridge->topic_remapping){\n\t\tfor(i=0; i<context->bridge->topic_count; i++){\n\t\t\tcur_topic = &context->bridge->topics[i];\n\t\t\tif((cur_topic->direction == bd_both || cur_topic->direction == bd_in)\n\t\t\t\t\t&& (cur_topic->remote_prefix || cur_topic->local_prefix)){\n\t\t\t\trc = mosquitto_topic_matches_sub(cur_topic->remote_topic, *topic, &match);\n\t\t\t\tif(rc){\n\t\t\t\t\tmosquitto__free(*topic);\n\t\t\t\t\t*topic = NULL;\n\t\t\t\t\treturn rc;\n\t\t\t\t}\n\t\t\t\tif(match){\n\t\t\t\t\tif(cur_topic->remote_prefix){\n\t\t\t\t\t\tif(!strncmp(cur_topic->remote_prefix, *topic, strlen(cur_topic->remote_prefix))){\n\t\t\t\t\t\t\ttopic_temp = mosquitto__strdup((*topic)+strlen(cur_topic->remote_prefix));\n\t\t\t\t\t\t\tif(!topic_temp){\n\t\t\t\t\t\t\t\tmosquitto__free(*topic);\n\t\t\t\t\t\t\t\t*topic = NULL;\n\t\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmosquitto__free(*topic);\n\t\t\t\t\t\t\t*topic = topic_temp;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(cur_topic->local_prefix){\n\t\t\t\t\t\tlen = strlen(*topic) + strlen(cur_topic->local_prefix)+1;\n\t\t\t\t\t\ttopic_temp = mosquitto__malloc(len+1);\n\t\t\t\t\t\tif(!topic_temp){\n\t\t\t\t\t\t\tmosquitto__free(*topic);\n\t\t\t\t\t\t\t*topic = NULL;\n\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsnprintf(topic_temp, len, \"%s%s\", cur_topic->local_prefix, *topic);\n\t\t\t\t\t\ttopic_temp[len] = '\\0';\n\t\t\t\t\t\tmosquitto__free(*topic);\n\t\t\t\t\t\t*topic = topic_temp;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn MOSQ_ERR_SUCCESS;\n}", "target": 0}
{"code": "cdf_unpack_summary_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    cdf_summary_info_header_t *ssi, cdf_property_info_t **info, size_t *count)\n{\n\tsize_t i, maxcount;\n\tconst cdf_summary_info_header_t *si =\n\t    CAST(const cdf_summary_info_header_t *, sst->sst_tab);\n\tconst cdf_section_declaration_t *sd =\n\t    CAST(const cdf_section_declaration_t *, (const void *)\n\t    ((const char *)sst->sst_tab + CDF_SECTION_DECLARATION_OFFSET));\n\tif (cdf_check_stream_offset(sst, h, si, sizeof(*si), __LINE__) == -1 ||\n\t    cdf_check_stream_offset(sst, h, sd, sizeof(*sd), __LINE__) == -1)\n\t\treturn -1;\n\tssi->si_byte_order = CDF_TOLE2(si->si_byte_order);\n\tssi->si_os_version = CDF_TOLE2(si->si_os_version);\n\tssi->si_os = CDF_TOLE2(si->si_os);\n\tssi->si_class = si->si_class;\n\tcdf_swap_class(&ssi->si_class);\n\tssi->si_count = CDF_TOLE2(si->si_count);\n\t*count = 0;\n\tmaxcount = 0;\n\t*info = NULL;\n\tfor (i = 0; i < CDF_TOLE4(si->si_count); i++) {\n\t\tif (i >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Unpack summary info loop limit\"));\n\t\t\terrno = EFTYPE;\n\t\t\treturn -1;\n\t\t}\n\t\tif (cdf_read_property_info(sst, h, CDF_TOLE4(sd->sd_offset),\n\t\t    info, count, &maxcount) == -1) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void ieee80211_check_fast_rx_iface(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tmutex_lock(&local->sta_mtx);\n\t__ieee80211_check_fast_rx_iface(sdata);\n\tmutex_unlock(&local->sta_mtx);\n}", "target": 0}
{"code": "void nfc_llcp_mac_is_down(struct nfc_dev *dev)\n{\n\tstruct nfc_llcp_local *local;\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL)\n\t\treturn;\n\tlocal->remote_miu = LLCP_DEFAULT_MIU;\n\tlocal->remote_lto = LLCP_DEFAULT_LTO;\n\tnfc_llcp_socket_release(local, true, 0);\n\tnfc_llcp_local_put(local);\n}", "target": 0}
{"code": "uint64_t ldq_be_phys(AddressSpace *as, hwaddr addr)\n{\n    return address_space_ldq_be(as, addr, MEMTXATTRS_UNSPECIFIED, NULL);\n}", "target": 0}
{"code": "static void mark_key_instantiated(struct key *key, int reject_error)\n{\n\tsmp_store_release(&key->state,\n\t\t\t  (reject_error < 0) ? reject_error : KEY_IS_POSITIVE);\n}", "target": 0}
{"code": "mwifiex_set_wmm_params(struct mwifiex_private *priv,\n\t\t       struct mwifiex_uap_bss_param *bss_cfg,\n\t\t       struct cfg80211_ap_settings *params)\n{\n\tconst u8 *vendor_ie;\n\tconst u8 *wmm_ie;\n\tu8 wmm_oui[] = {0x00, 0x50, 0xf2, 0x02};\n\tvendor_ie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t    WLAN_OUI_TYPE_MICROSOFT_WMM,\n\t\t\t\t\t    params->beacon.tail,\n\t\t\t\t\t    params->beacon.tail_len);\n\tif (vendor_ie) {\n\t\twmm_ie = vendor_ie;\n\t\tif (*(wmm_ie + 1) > sizeof(struct mwifiex_types_wmm_info))\n\t\t\treturn;\n\t\tmemcpy(&bss_cfg->wmm_info, wmm_ie +\n\t\t       sizeof(struct ieee_types_header), *(wmm_ie + 1));\n\t\tpriv->wmm_enabled = 1;\n\t} else {\n\t\tmemset(&bss_cfg->wmm_info, 0, sizeof(bss_cfg->wmm_info));\n\t\tmemcpy(&bss_cfg->wmm_info.oui, wmm_oui, sizeof(wmm_oui));\n\t\tbss_cfg->wmm_info.subtype = MWIFIEX_WMM_SUBTYPE;\n\t\tbss_cfg->wmm_info.version = MWIFIEX_WMM_VERSION;\n\t\tpriv->wmm_enabled = 0;\n\t}\n\tbss_cfg->qos_info = 0x00;\n\treturn;\n}", "target": 0}
{"code": "Status ImmutableExecutorState::BuildControlFlowInfo(const Graph* g,\n                                                    ControlFlowInfo* cf_info) {\n  const int num_nodes = g->num_node_ids();\n  cf_info->frame_names.resize(num_nodes);\n  std::vector<Node*> parent_nodes;\n  parent_nodes.resize(num_nodes);\n  std::vector<bool> visited;\n  visited.resize(num_nodes);\n  string frame_name;\n  std::deque<Node*> ready;\n  for (Node* n : g->nodes()) {\n    if (n->in_edges().empty()) {\n      visited[n->id()] = true;\n      cf_info->unique_frame_names.insert(frame_name);\n      ready.push_back(n);\n    }\n  }\n  while (!ready.empty()) {\n    Node* curr_node = ready.front();\n    int curr_id = curr_node->id();\n    ready.pop_front();\n    Node* parent = nullptr;\n    if (IsEnter(curr_node)) {\n      TF_RETURN_IF_ERROR(\n          GetNodeAttr(curr_node->attrs(), \"frame_name\", &frame_name));\n      parent = curr_node;\n    } else if (IsExit(curr_node)) {\n      parent = parent_nodes[curr_id];\n      if (!parent) {\n        return errors::InvalidArgument(\n            \"Invalid Exit op: Cannot find a corresponding Enter op.\");\n      }\n      frame_name = cf_info->frame_names[parent->id()];\n      parent = parent_nodes[parent->id()];\n    } else {\n      parent = parent_nodes[curr_id];\n      frame_name = cf_info->frame_names[curr_id];\n    }\n    for (const Edge* out_edge : curr_node->out_edges()) {\n      Node* out = out_edge->dst();\n      if (IsSink(out)) continue;\n      const int out_id = out->id();\n      bool is_visited = visited[out_id];\n      if (!is_visited) {\n        ready.push_back(out);\n        visited[out_id] = true;\n        cf_info->frame_names[out_id] = frame_name;\n        parent_nodes[out_id] = parent;\n        cf_info->unique_frame_names.insert(frame_name);\n      }\n    }\n  }\n  return Status::OK();\n}", "target": 0}
{"code": "static void evtchn_fifo_handle_events(unsigned cpu)\n{\n\t__evtchn_fifo_handle_events(cpu, false);\n}", "target": 1}
{"code": "start_pass_merged_upsample(j_decompress_ptr cinfo)\n{\n  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n  upsample->spare_full = FALSE;\n  upsample->rows_to_go = cinfo->output_height;\n}", "target": 1}
{"code": "i915_gem_execbuffer_retire_commands(struct drm_device *dev,\n\t\t\t\t    struct drm_file *file,\n\t\t\t\t    struct intel_ring_buffer *ring)\n{\n\tring->gpu_caches_dirty = true;\n\t(void)i915_add_request(ring, file, NULL);\n}", "target": 0}
{"code": "txid_current_snapshot(PG_FUNCTION_ARGS)\n{\n\tTxidSnapshot *snap;\n\tuint32\t\tnxip,\n\t\t\t\ti,\n\t\t\t\tsize;\n\tTxidEpoch\tstate;\n\tSnapshot\tcur;\n\tcur = GetActiveSnapshot();\n\tif (cur == NULL)\n\t\telog(ERROR, \"no active snapshot set\");\n\tload_xid_epoch(&state);\n\tStaticAssertStmt(MAX_BACKENDS * 2 <= TXID_SNAPSHOT_MAX_NXIP,\n\t\t\t\t\t \"possible overflow in txid_current_snapshot()\");\n\tnxip = cur->xcnt;\n\tsize = TXID_SNAPSHOT_SIZE(nxip);\n\tsnap = palloc(size);\n\tSET_VARSIZE(snap, size);\n\tsnap->xmin = convert_xid(cur->xmin, &state);\n\tsnap->xmax = convert_xid(cur->xmax, &state);\n\tsnap->nxip = nxip;\n\tfor (i = 0; i < nxip; i++)\n\t\tsnap->xip[i] = convert_xid(cur->xip[i], &state);\n\tsort_snapshot(snap);\n\tPG_RETURN_POINTER(snap);\n}", "target": 0}
{"code": "static int orinoco_ioctl_set_auth(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\thermes_t *hw = &priv->hw;\n\tstruct iw_param *param = &wrqu->param;\n\tunsigned long flags;\n\tint ret = -EINPROGRESS;\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\tswitch (param->flags & IW_AUTH_INDEX) {\n\tcase IW_AUTH_WPA_VERSION:\n\tcase IW_AUTH_CIPHER_PAIRWISE:\n\tcase IW_AUTH_CIPHER_GROUP:\n\tcase IW_AUTH_RX_UNENCRYPTED_EAPOL:\n\tcase IW_AUTH_PRIVACY_INVOKED:\n\tcase IW_AUTH_DROP_UNENCRYPTED:\n\t\tbreak;\n\tcase IW_AUTH_KEY_MGMT:\n\t\tpriv->key_mgmt = param->value;\n\t\tbreak;\n\tcase IW_AUTH_TKIP_COUNTERMEASURES:\n\t\tif (param->value) {\n\t\t\tpriv->tkip_cm_active = 1;\n\t\t\tret = hermes_enable_port(hw, 0);\n\t\t} else {\n\t\t\tpriv->tkip_cm_active = 0;\n\t\t\tret = hermes_disable_port(hw, 0);\n\t\t}\n\t\tbreak;\n\tcase IW_AUTH_80211_AUTH_ALG:\n\t\tif (param->value & IW_AUTH_ALG_SHARED_KEY)\n\t\t\tpriv->wep_restrict = 1;\n\t\telse if (param->value & IW_AUTH_ALG_OPEN_SYSTEM)\n\t\t\tpriv->wep_restrict = 0;\n\t\telse\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\tcase IW_AUTH_WPA_ENABLED:\n\t\tif (priv->has_wpa) {\n\t\t\tpriv->wpa_enabled = param->value ? 1 : 0;\n\t\t} else {\n\t\t\tif (param->value)\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\tpriv->wpa_enabled = 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t}\n\torinoco_unlock(priv, &flags);\n\treturn ret;\n}", "target": 1}
{"code": "static int do_tkill(pid_t tgid, pid_t pid, int sig)\n{\n\tstruct siginfo info;\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code = SI_TKILL;\n\tinfo.si_pid = task_tgid_vnr(current);\n\tinfo.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\treturn do_send_specific(tgid, pid, sig, &info);\n}", "target": 1}
{"code": "static int __dwc3_gadget_kick_transfer(struct dwc3_ep *dep)\n{\n\tstruct dwc3_gadget_ep_cmd_params params;\n\tstruct dwc3_request\t\t*req;\n\tint\t\t\t\tstarting;\n\tint\t\t\t\tret;\n\tu32\t\t\t\tcmd;\n\tif (!dwc3_calc_trbs_left(dep))\n\t\treturn 0;\n\tstarting = !(dep->flags & DWC3_EP_BUSY);\n\tdwc3_prepare_trbs(dep);\n\treq = next_request(&dep->started_list);\n\tif (!req) {\n\t\tdep->flags |= DWC3_EP_PENDING_REQUEST;\n\t\treturn 0;\n\t}\n\tmemset(&params, 0, sizeof(params));\n\tif (starting) {\n\t\tparams.param0 = upper_32_bits(req->trb_dma);\n\t\tparams.param1 = lower_32_bits(req->trb_dma);\n\t\tcmd = DWC3_DEPCMD_STARTTRANSFER;\n\t\tif (usb_endpoint_xfer_isoc(dep->endpoint.desc))\n\t\t\tcmd |= DWC3_DEPCMD_PARAM(dep->frame_number);\n\t} else {\n\t\tcmd = DWC3_DEPCMD_UPDATETRANSFER |\n\t\t\tDWC3_DEPCMD_PARAM(dep->resource_index);\n\t}\n\tret = dwc3_send_gadget_ep_cmd(dep, cmd, &params);\n\tif (ret < 0) {\n\t\tif (req->trb)\n\t\t\tmemset(req->trb, 0, sizeof(struct dwc3_trb));\n\t\tdep->queued_requests--;\n\t\tdwc3_gadget_giveback(dep, req, ret);\n\t\treturn ret;\n\t}\n\tdep->flags |= DWC3_EP_BUSY;\n\tif (starting) {\n\t\tdep->resource_index = dwc3_gadget_ep_get_transfer_index(dep);\n\t\tWARN_ON_ONCE(!dep->resource_index);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "Status XlaOpKernelContext::ConstantInputAsShape(int index, TensorShape* shape,\n                                                xla::ValueInferenceMode mode) {\n  xla::Literal literal;\n  TF_RETURN_IF_ERROR(ConstantInput(index, &literal, mode));\n  std::vector<int64_t> dims;\n  TF_RETURN_IF_ERROR(LiteralToInt64Vector(literal, &dims));\n  int64_t num_elements = 1;\n  for (auto i = dims.begin(); i != dims.end(); ++i) {\n    num_elements = MultiplyWithoutOverflow(num_elements, *i);\n    if (num_elements < 0)\n      return errors::InvalidArgument(\n          \"The total elements specified by orig_input_shape is too large.\",\n          \"Encountered overflow after multiplying\", *i,\n          \", result: \", num_elements);\n  }\n  *shape = TensorShape(dims);\n  return OkStatus();\n}", "target": 0}
{"code": "static int checkout_verify_paths(\n\tgit_repository *repo,\n\tint action,\n\tgit_diff_delta *delta)\n{\n\tunsigned int flags = GIT_PATH_REJECT_WORKDIR_DEFAULTS;\n\tif (action & CHECKOUT_ACTION__REMOVE) {\n\t\tif (!git_path_isvalid(repo, delta->old_file.path, delta->old_file.mode, flags)) {\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"cannot remove invalid path '%s'\", delta->old_file.path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (action & ~CHECKOUT_ACTION__REMOVE) {\n\t\tif (!git_path_isvalid(repo, delta->new_file.path, delta->new_file.mode, flags)) {\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"cannot checkout to invalid path '%s'\", delta->new_file.path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static inline int copy_regset_to_user(struct task_struct *target,\n\t\t\t\t      const struct user_regset_view *view,\n\t\t\t\t      unsigned int setno,\n\t\t\t\t      unsigned int offset, unsigned int size,\n\t\t\t\t      void __user *data)\n{\n\tconst struct user_regset *regset = &view->regsets[setno];\n\tif (!regset->get)\n\t\treturn -EOPNOTSUPP;\n\tif (!access_ok(VERIFY_WRITE, data, size))\n\t\treturn -EIO;\n\treturn regset->get(target, regset, offset, size, NULL, data);\n}", "target": 0}
{"code": "static int handle_vmread(struct kvm_vcpu *vcpu)\n{\n\tunsigned long field;\n\tu64 field_value;\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tu32 vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\tgva_t gva = 0;\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\tif (!nested_vmx_check_vmcs12(vcpu))\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\tfield = kvm_register_readl(vcpu, (((vmx_instruction_info) >> 28) & 0xf));\n\tif (vmcs12_read_any(vcpu, field, &field_value) < 0) {\n\t\tnested_vmx_failValid(vcpu, VMXERR_UNSUPPORTED_VMCS_COMPONENT);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\tif (vmx_instruction_info & (1u << 10)) {\n\t\tkvm_register_writel(vcpu, (((vmx_instruction_info) >> 3) & 0xf),\n\t\t\tfield_value);\n\t} else {\n\t\tif (get_vmx_mem_address(vcpu, exit_qualification,\n\t\t\t\tvmx_instruction_info, true, &gva))\n\t\t\treturn 1;\n\t\tkvm_write_guest_virt_system(&vcpu->arch.emulate_ctxt, gva,\n\t\t\t     &field_value, (is_long_mode(vcpu) ? 8 : 4), NULL);\n\t}\n\tnested_vmx_succeed(vcpu);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}", "target": 1}
{"code": "static void local_release(struct kref *ref)\n{\n\tstruct nfc_llcp_local *local;\n\tlocal = container_of(ref, struct nfc_llcp_local, ref);\n\tlist_del(&local->list);\n\tlocal_cleanup(local);\n\tkfree(local);\n}", "target": 1}
{"code": "static inline void skb_queue_splice_tail(const struct sk_buff_head *list,\n\t\t\t\t\t struct sk_buff_head *head)\n{\n\tif (!skb_queue_empty(list)) {\n\t\t__skb_queue_splice(list, head->prev, (struct sk_buff *) head);\n\t\thead->qlen += list->qlen;\n\t}\n}", "target": 0}
{"code": "int simple_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error;\n\tif (type == ACL_TYPE_ACCESS) {\n\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\tif (error < 0)\n\t\t\treturn 0;\n\t\tif (error == 0)\n\t\t\tacl = NULL;\n\t}\n\tinode->i_ctime = current_time(inode);\n\tset_cached_acl(inode, type, acl);\n\treturn 0;\n}", "target": 1}
{"code": "hash_new_from_values(mrb_state *mrb, mrb_int argc, mrb_value *regs)\n{\n  mrb_value hash = mrb_hash_new_capa(mrb, argc);\n  while (argc--) {\n    mrb_hash_set(mrb, hash, regs[0], regs[1]);\n    regs += 2;\n  }\n  return hash;\n}", "target": 1}
{"code": "static int mincore_unmapped_range(unsigned long addr, unsigned long end,\n\t\t\t\t   struct mm_walk *walk)\n{\n\twalk->private += __mincore_unmapped_range(addr, end,\n\t\t\t\t\t\t  walk->vma, walk->private);\n\treturn 0;\n}", "target": 1}
{"code": "static int bn2cf(const BIGNUM *num, u8 *buf)\n{\n\tu8 tmp[512];\n\tint r;\n\tr = BN_bn2bin(num, tmp);\n\tif (r <= 0)\n\t\treturn r;\n\tinvert_buf(buf, tmp, r);\n\treturn r;\n}", "target": 0}
{"code": "void test_delta_apply__read_after_limit(void)\n{\n\tunsigned char base[16] = { 0 }, delta[] = { 0x10, 0x70, 0xff };\n\tvoid *out;\n\tsize_t outlen;\n\tcl_git_fail(git_delta_apply(&out, &outlen, base, sizeof(base), delta, sizeof(delta)));\n}", "target": 0}
{"code": "static bool caller_may_see_dir(pid_t pid, const char *contrl, const char *cg)\n{\n\tbool answer = false;\n\tchar *c2, *task_cg;\n\tsize_t target_len, task_len;\n\tif (strcmp(cg, \"/\") == 0)\n\t\treturn true;\n\tc2 = get_pid_cgroup(pid, contrl);\n\tif (!c2)\n\t\treturn false;\n\ttask_cg = c2 + 1;\n\ttarget_len = strlen(cg);\n\ttask_len = strlen(task_cg);\n\tif (strcmp(cg, task_cg) == 0) {\n\t\tanswer = true;\n\t\tgoto out;\n\t}\n\tif (target_len < task_len) {\n\t\tif (strncmp(task_cg, cg, target_len) == 0 && task_cg[target_len] == '/')\n\t\t\tanswer = true;\n\t\tgoto out;\n\t}\n\tif (target_len > task_len) {\n\t\tif (strncmp(task_cg, cg, task_len) == 0 && cg[task_len] == '/')\n\t\t\tanswer = true;\n\t\tgoto out;\n\t}\nout:\n\tfree(c2);\n\treturn answer;\n}", "target": 0}
{"code": "static void *proc_pid_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error = -EACCES;\n\tpath_put(&nd->path);\n\tif (!proc_fd_access_allowed(inode))\n\t\tgoto out;\n\terror = PROC_I(inode)->op.proc_get_link(inode, &nd->path);\n\tnd->last_type = LAST_BIND;\nout:\n\treturn ERR_PTR(error);\n}", "target": 1}
{"code": " static int asymmetric_key_match_preparse(struct key_match_data *match_data)\n {\n \tmatch_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;\n\tmatch_data->cmp = asymmetric_key_cmp;\n \treturn 0;\n }", "target": 0}
{"code": "static void nlmclnt_unlock_callback(struct rpc_task *task, void *data)\n{\n\tstruct nlm_rqst\t*req = data;\n\tu32 status = ntohl(req->a_res.status);\n\tif (RPC_ASSASSINATED(task))\n\t\tgoto die;\n\tif (task->tk_status < 0) {\n\t\tdprintk(\"lockd: unlock failed (err = %d)\\n\", -task->tk_status);\n\t\tgoto retry_rebind;\n\t}\n\tif (status == NLM_LCK_DENIED_GRACE_PERIOD) {\n\t\trpc_delay(task, NLMCLNT_GRACE_WAIT);\n\t\tgoto retry_unlock;\n\t}\n\tif (status != NLM_LCK_GRANTED)\n\t\tprintk(KERN_WARNING \"lockd: unexpected unlock status: %d\\n\", status);\ndie:\n\treturn;\n retry_rebind:\n\tnlm_rebind_host(req->a_host);\n retry_unlock:\n\trpc_restart_call(task);\n}", "target": 1}
{"code": "void swallow_arg(int *argcp, char *argv[], char *which)\n{\n\tint i;\n\tfor (i = 1; argv[i]; i++) {\n\t\tif (strcmp(argv[i], which) != 0)\n\t\t\tcontinue;\n\t\tfor (; argv[i]; i++) {\n\t\t\targv[i] = argv[i+1];\n\t\t}\n\t\t(*argcp)--;\n\t\treturn;\n\t}\n}", "target": 0}
{"code": "static void tcp_dsack_set(struct sock *sk, u32 seq, u32 end_seq)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tif (tcp_is_sack(tp) && sysctl_tcp_dsack) {\n\t\tint mib_idx;\n\t\tif (before(seq, tp->rcv_nxt))\n\t\t\tmib_idx = LINUX_MIB_TCPDSACKOLDSENT;\n\t\telse\n\t\t\tmib_idx = LINUX_MIB_TCPDSACKOFOSENT;\n\t\tNET_INC_STATS_BH(sock_net(sk), mib_idx);\n\t\ttp->rx_opt.dsack = 1;\n\t\ttp->duplicate_sack[0].start_seq = seq;\n\t\ttp->duplicate_sack[0].end_seq = end_seq;\n\t}\n}", "target": 0}
{"code": "InstallSignalHandlers(void)\n{\n    xf86Info.caughtSignal = FALSE;\n    if (!xf86Info.notrapSignals) {\n        OsRegisterSigWrapper(xf86SigWrapper);\n    }\n    else {\n        signal(SIGSEGV, SIG_DFL);\n        signal(SIGILL, SIG_DFL);\n#ifdef SIGEMT\n        signal(SIGEMT, SIG_DFL);\n#endif\n        signal(SIGFPE, SIG_DFL);\n        signal(SIGBUS, SIG_DFL);\n        signal(SIGSYS, SIG_DFL);\n        signal(SIGXCPU, SIG_DFL);\n        signal(SIGXFSZ, SIG_DFL);\n    }\n}", "target": 0}
{"code": "static void spl_array_update_pos(spl_array_object* intern) \n{\n\tBucket *pos = intern->pos;\n\tif (pos != NULL) {\n\t\tintern->pos_h = pos->h;\n\t}\n} ", "target": 0}
{"code": "enum nss_status _nss_mymachines_getgrnam_r(\n                const char *name,\n                struct group *gr,\n                char *buffer, size_t buflen,\n                int *errnop) {\n        _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL;\n        _cleanup_bus_message_unref_ sd_bus_message* reply = NULL;\n        _cleanup_bus_flush_close_unref_ sd_bus *bus = NULL;\n        const char *p, *e, *machine;\n        uint32_t mapped;\n        uid_t gid;\n        size_t l;\n        int r;\n        assert(name);\n        assert(gr);\n        p = startswith(name, \"vg-\");\n        if (!p)\n                goto not_found;\n        e = strrchr(p, '-');\n        if (!e || e == p)\n                goto not_found;\n        if (e - p > HOST_NAME_MAX - 1)  \n                goto not_found;\n        r = parse_gid(e + 1, &gid);\n        if (r < 0)\n                goto not_found;\n        machine = strndupa(p, e - p);\n        if (!machine_name_is_valid(machine))\n                goto not_found;\n        r = sd_bus_open_system(&bus);\n        if (r < 0)\n                goto fail;\n        r = sd_bus_call_method(bus,\n                               \"org.freedesktop.machine1\",\n                               \"/org/freedesktop/machine1\",\n                               \"org.freedesktop.machine1.Manager\",\n                               \"MapFromMachineGroup\",\n                               &error,\n                               &reply,\n                               \"su\",\n                               machine, (uint32_t) gid);\n        if (r < 0) {\n                if (sd_bus_error_has_name(&error, BUS_ERROR_NO_SUCH_GROUP_MAPPING))\n                        goto not_found;\n                goto fail;\n        }\n        r = sd_bus_message_read(reply, \"u\", &mapped);\n        if (r < 0)\n                goto fail;\n        l = sizeof(char*) + strlen(name) + 1;\n        if (buflen < l) {\n                *errnop = ENOMEM;\n                return NSS_STATUS_TRYAGAIN;\n        }\n        memzero(buffer, sizeof(char*));\n        strcpy(buffer + sizeof(char*), name);\n        gr->gr_name = buffer + sizeof(char*);\n        gr->gr_gid = gid;\n        gr->gr_passwd = (char*) \"*\"; \n        gr->gr_mem = (char**) buffer;\n        *errnop = 0;\n        return NSS_STATUS_SUCCESS;\nnot_found:\n        *errnop = 0;\n        return NSS_STATUS_NOTFOUND;\nfail:\n        *errnop = -r;\n        return NSS_STATUS_UNAVAIL;\n}", "target": 0}
{"code": "activate_desktop_file (ActivateParameters *parameters,\n                       NautilusFile       *file)\n{\n    ActivateParametersDesktop *parameters_desktop;\n    char *primary, *secondary, *display_name;\n    GtkWidget *dialog;\n    GdkScreen *screen;\n    char *uri;\n    screen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window));\n    if (!nautilus_file_is_trusted_link (file))\n    {\n        parameters_desktop = g_new0 (ActivateParametersDesktop, 1);\n        if (parameters->parent_window)\n        {\n            parameters_desktop->parent_window = parameters->parent_window;\n            g_object_add_weak_pointer (G_OBJECT (parameters_desktop->parent_window), (gpointer *) &parameters_desktop->parent_window);\n        }\n        parameters_desktop->file = nautilus_file_ref (file);\n        primary = _(\"Untrusted application launcher\");\n        display_name = nautilus_file_get_display_name (file);\n        secondary =\n            g_strdup_printf (_(\"The application launcher %s has not been marked as trusted. \"\n                               \"If you do not know the source of this file, launching it may be unsafe.\"\n                               ),\n                             display_name);\n        dialog = gtk_message_dialog_new (parameters->parent_window,\n                                         0,\n                                         GTK_MESSAGE_WARNING,\n                                         GTK_BUTTONS_NONE,\n                                         NULL);\n        g_object_set (dialog,\n                      \"text\", primary,\n                      \"secondary-text\", secondary,\n                      NULL);\n        gtk_dialog_add_button (GTK_DIALOG (dialog),\n                               _(\"_Launch Anyway\"), RESPONSE_RUN);\n        if (nautilus_file_can_set_permissions (file))\n        {\n            gtk_dialog_add_button (GTK_DIALOG (dialog),\n                                   _(\"Mark as _Trusted\"), RESPONSE_MARK_TRUSTED);\n        }\n        gtk_dialog_add_button (GTK_DIALOG (dialog),\n                               _(\"_Cancel\"), GTK_RESPONSE_CANCEL);\n        gtk_dialog_set_default_response (GTK_DIALOG (dialog), GTK_RESPONSE_CANCEL);\n        g_signal_connect (dialog, \"response\",\n                          G_CALLBACK (untrusted_launcher_response_callback),\n                          parameters_desktop);\n        gtk_widget_show (dialog);\n        g_free (display_name);\n        g_free (secondary);\n        return;\n    }\n    uri = nautilus_file_get_uri (file);\n    DEBUG (\"Launching trusted launcher %s\", uri);\n    nautilus_launch_desktop_file (screen, uri, NULL,\n                                  parameters->parent_window);\n    g_free (uri);\n}", "target": 1}
{"code": "chdlc_print(netdissect_options *ndo, register const u_char *p, u_int length)\n{\n\tu_int proto;\n\tconst u_char *bp = p;\n\tif (length < CHDLC_HDRLEN)\n\t\tgoto trunc;\n\tND_TCHECK2(*p, CHDLC_HDRLEN);\n\tproto = EXTRACT_16BITS(&p[2]);\n\tif (ndo->ndo_eflag) {\n                ND_PRINT((ndo, \"%s, ethertype %s (0x%04x), length %u: \",\n                       tok2str(chdlc_cast_values, \"0x%02x\", p[0]),\n                       tok2str(ethertype_values, \"Unknown\", proto),\n                       proto,\n                       length));\n\t}\n\tlength -= CHDLC_HDRLEN;\n\tp += CHDLC_HDRLEN;\n\tswitch (proto) {\n\tcase ETHERTYPE_IP:\n\t\tip_print(ndo, p, length);\n\t\tbreak;\n\tcase ETHERTYPE_IPV6:\n\t\tip6_print(ndo, p, length);\n\t\tbreak;\n\tcase CHDLC_TYPE_SLARP:\n\t\tchdlc_slarp_print(ndo, p, length);\n\t\tbreak;\n#if 0\n\tcase CHDLC_TYPE_CDP:\n\t\tchdlc_cdp_print(p, length);\n\t\tbreak;\n#endif\n        case ETHERTYPE_MPLS:\n        case ETHERTYPE_MPLS_MULTI:\n                mpls_print(ndo, p, length);\n\t\tbreak;\n        case ETHERTYPE_ISO:\n                if (length < 2)\n                    goto trunc;\n                ND_TCHECK_16BITS(p);\n                if (*(p+1) == 0x81 ||\n                    *(p+1) == 0x82 ||\n                    *(p+1) == 0x83)\n                    isoclns_print(ndo, p + 1, length - 1);\n                else\n                    isoclns_print(ndo, p, length);\n                break;\n\tdefault:\n                if (!ndo->ndo_eflag)\n                        ND_PRINT((ndo, \"unknown CHDLC protocol (0x%04x)\", proto));\n                break;\n\t}\n\treturn (CHDLC_HDRLEN);\ntrunc:\n\tND_PRINT((ndo, \"[|chdlc]\"));\n\treturn ndo->ndo_snapend - bp;\n}", "target": 0}
{"code": "TfLiteStatus ComputeDepthMultiplier(TfLiteContext* context,\n                                    const TfLiteTensor* input,\n                                    const TfLiteTensor* filter,\n                                    int16* depth_multiplier) {\n  int num_filter_channels = SizeOfDimension(filter, 3);\n  int num_input_channels = SizeOfDimension(input, 3);\n  TF_LITE_ENSURE_EQ(context, num_filter_channels % num_input_channels, 0);\n  *depth_multiplier = num_filter_channels / num_input_channels;\n  return kTfLiteOk;\n}", "target": 1}
{"code": "coolkey_add_object(coolkey_private_data_t *priv, unsigned long object_id, const u8 *object_data, size_t object_length, int add_v1_record)\n{\n\tsc_cardctl_coolkey_object_t new_object;\n\tint r;\n\tmemset(&new_object, 0, sizeof(new_object));\n\tnew_object.path = coolkey_template_path;\n\tnew_object.path.len = 4;\n\tulong2bebytes(new_object.path.value, object_id);\n\tnew_object.id = object_id;\n\tnew_object.length = object_length;\n\tif (coolkey_find_object_by_id(&priv->objects_list, object_id) != NULL) {\n\t\treturn SC_ERROR_INTERNAL;\n\t}\n\tif (object_data) {\n\t\tnew_object.data = malloc(object_length + add_v1_record);\n\t\tif (new_object.data == NULL) {\n\t\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t\t}\n\t\tif (add_v1_record) {\n\t\t\tnew_object.data[0] = COOLKEY_V1_OBJECT;\n\t\t\tnew_object.length++;\n\t\t}\n\t\tmemcpy(&new_object.data[add_v1_record], object_data, object_length);\n\t}\n\tr = coolkey_add_object_to_list(&priv->objects_list, &new_object);\n\tif (r != SC_SUCCESS) {\n\t\tfree(new_object.data);\n\t\tnew_object.data = NULL;\n\t}\n\treturn r;\n}", "target": 0}
{"code": "acl_fetch_stver(struct proxy *px, struct session *l4, void *l7, int dir,\n                struct acl_expr *expr, struct acl_test *test)\n{\n\tstruct http_txn *txn = l7;\n\tchar *ptr;\n\tint len;\n\tif (!txn)\n\t\treturn 0;\n\tif (txn->rsp.msg_state < HTTP_MSG_BODY)\n\t\treturn 0;\n\tlen = txn->rsp.sl.st.v_l;\n\tptr = txn->rsp.sol;\n\twhile ((len-- > 0) && (*ptr++ != '/'));\n\tif (len <= 0)\n\t\treturn 0;\n\ttest->ptr = ptr;\n\ttest->len = len;\n\ttest->flags = ACL_TEST_F_READ_ONLY | ACL_TEST_F_VOL_1ST;\n\treturn 1;\n}", "target": 0}
{"code": "GC_API void * GC_CALL GC_generic_malloc(size_t lb, int k)\n{\n    void * result;\n    DCL_LOCK_STATE;\n    if (EXPECT(GC_have_errors, FALSE))\n      GC_print_all_errors();\n    GC_INVOKE_FINALIZERS();\n    if (SMALL_OBJ(lb)) {\n        LOCK();\n        result = GC_generic_malloc_inner((word)lb, k);\n        UNLOCK();\n    } else {\n        size_t lg;\n        size_t lb_rounded;\n        word n_blocks;\n        GC_bool init;\n        lg = ROUNDED_UP_GRANULES(lb);\n        lb_rounded = GRANULES_TO_BYTES(lg);\n        if (lb_rounded < lb)\n            return((*GC_get_oom_fn())(lb));\n        n_blocks = OBJ_SZ_TO_BLOCKS(lb_rounded);\n        init = GC_obj_kinds[k].ok_init;\n        LOCK();\n        result = (ptr_t)GC_alloc_large(lb_rounded, k, 0);\n        if (0 != result) {\n          if (GC_debugging_started) {\n            BZERO(result, n_blocks * HBLKSIZE);\n          } else {\n#           ifdef THREADS\n                ((word *)result)[0] = 0;\n                ((word *)result)[1] = 0;\n                ((word *)result)[GRANULES_TO_WORDS(lg)-1] = 0;\n                ((word *)result)[GRANULES_TO_WORDS(lg)-2] = 0;\n#           endif\n          }\n        }\n        GC_bytes_allocd += lb_rounded;\n        UNLOCK();\n        if (init && !GC_debugging_started && 0 != result) {\n            BZERO(result, n_blocks * HBLKSIZE);\n        }\n    }\n    if (0 == result) {\n        return((*GC_get_oom_fn())(lb));\n    } else {\n        return(result);\n    }\n}", "target": 0}
{"code": "void SparseFillEmptyRowsOpImpl(OpKernelContext* context,\n                               AsyncOpKernel::DoneCallback done = nullptr) {\n  if (!done) {\n    done = [] {};\n  }\n  const int kIndicesInput = 0;\n  const int kValuesInput = 1;\n  const int kDenseShapeInput = 2;\n  const int kDefaultValueInput = 3;\n  const Tensor& indices_t = context->input(kIndicesInput);\n  const Tensor& values_t = context->input(kValuesInput);\n  const Tensor& dense_shape_t = context->input(kDenseShapeInput);\n  const Tensor& default_value_t = context->input(kDefaultValueInput);\n  OP_REQUIRES_ASYNC(\n      context, TensorShapeUtils::IsVector(dense_shape_t.shape()),\n      errors::InvalidArgument(\"dense_shape must be a vector, saw: \",\n                              dense_shape_t.shape().DebugString()),\n      done);\n  OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsMatrix(indices_t.shape()),\n                    errors::InvalidArgument(\"indices must be a matrix, saw: \",\n                                            indices_t.shape().DebugString()),\n                    done);\n  OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsVector(values_t.shape()),\n                    errors::InvalidArgument(\"values must be a vector, saw: \",\n                                            values_t.shape().DebugString()),\n                    done);\n  OP_REQUIRES_ASYNC(\n      context, TensorShapeUtils::IsScalar(default_value_t.shape()),\n      errors::InvalidArgument(\"default_value must be a scalar, saw: \",\n                              default_value_t.shape().DebugString()),\n      done);\n  using FunctorType = functor::SparseFillEmptyRows<Device, T, Tindex>;\n  OP_REQUIRES_OK_ASYNC(context,\n                       FunctorType()(context, default_value_t, indices_t,\n                                     values_t, dense_shape_t, done),\n                       done);\n}", "target": 1}
{"code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* params;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kParams, &params));\n  const TfLiteTensor* indices;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kIndices, &indices));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  TF_LITE_ENSURE(context, NumElements(params) > 0);\n  switch (indices->type) {\n    case kTfLiteInt32:\n      return EvalGatherNd<int32_t>(context, params, indices, output);\n    case kTfLiteInt64:\n      return EvalGatherNd<int64_t>(context, params, indices, output);\n    default:\n      context->ReportError(\n          context, \"Indices of type '%s' are not supported by gather_nd.\",\n          TfLiteTypeGetName(indices->type));\n      return kTfLiteError;\n  }\n}", "target": 0}
{"code": "int ff_amf_get_field_value(const uint8_t *data, const uint8_t *data_end,\n                           const uint8_t *name, uint8_t *dst, int dst_size)\n{\n    int namelen = strlen(name);\n    int len;\n    while (*data != AMF_DATA_TYPE_OBJECT && data < data_end) {\n        len = ff_amf_tag_size(data, data_end);\n        if (len < 0)\n            len = data_end - data;\n        data += len;\n    }\n    if (data_end - data < 3)\n        return -1;\n    data++;\n    for (;;) {\n        int size = bytestream_get_be16(&data);\n        if (!size)\n            break;\n        if (size < 0 || size >= data_end - data)\n            return -1;\n        data += size;\n        if (size == namelen && !memcmp(data-size, name, namelen)) {\n            switch (*data++) {\n            case AMF_DATA_TYPE_NUMBER:\n                snprintf(dst, dst_size, \"%g\", av_int2double(AV_RB64(data)));\n                break;\n            case AMF_DATA_TYPE_BOOL:\n                snprintf(dst, dst_size, \"%s\", *data ? \"true\" : \"false\");\n                break;\n            case AMF_DATA_TYPE_STRING:\n                len = bytestream_get_be16(&data);\n                av_strlcpy(dst, data, FFMIN(len+1, dst_size));\n                break;\n            default:\n                return -1;\n            }\n            return 0;\n        }\n        len = ff_amf_tag_size(data, data_end);\n        if (len < 0 || len >= data_end - data)\n            return -1;\n        data += len;\n    }\n    return -1;\n}", "target": 1}
{"code": "static void gsm_cleanup_mux(struct gsm_mux *gsm, bool disc)\n{\n\tint i;\n\tstruct gsm_dlci *dlci = gsm->dlci[0];\n\tstruct gsm_msg *txq, *ntxq;\n\tgsm->dead = true;\n\tmutex_lock(&gsm->mutex);\n\tif (dlci) {\n\t\tif (disc && dlci->state != DLCI_CLOSED) {\n\t\t\tgsm_dlci_begin_close(dlci);\n\t\t\twait_event(gsm->event, dlci->state == DLCI_CLOSED);\n\t\t}\n\t\tdlci->dead = true;\n\t}\n\tdel_timer_sync(&gsm->kick_timer);\n\tdel_timer_sync(&gsm->t2_timer);\n\tdel_timer_sync(&gsm->ka_timer);\n\tflush_work(&gsm->tx_work);\n\tif (gsm->has_devices) {\n\t\tgsm_unregister_devices(gsm_tty_driver, gsm->num);\n\t\tgsm->has_devices = false;\n\t}\n\tfor (i = NUM_DLCI - 1; i >= 0; i--)\n\t\tif (gsm->dlci[i]) {\n\t\t\tgsm_dlci_release(gsm->dlci[i]);\n\t\t\tgsm->dlci[i] = NULL;\n\t\t}\n\tmutex_unlock(&gsm->mutex);\n\ttty_ldisc_flush(gsm->tty);\n\tlist_for_each_entry_safe(txq, ntxq, &gsm->tx_ctrl_list, list)\n\t\tkfree(txq);\n\tINIT_LIST_HEAD(&gsm->tx_ctrl_list);\n\tlist_for_each_entry_safe(txq, ntxq, &gsm->tx_data_list, list)\n\t\tkfree(txq);\n\tINIT_LIST_HEAD(&gsm->tx_data_list);\n}", "target": 1}
{"code": "int module_load(\n    YR_SCAN_CONTEXT* context,\n    YR_OBJECT* module_object,\n    void* module_data,\n    size_t module_data_size)\n{\n  set_integer(1, module_object, \"constants.one\");\n  set_integer(2, module_object, \"constants.two\");\n  set_string(\"foo\", module_object, \"constants.foo\");\n  set_string(\"\", module_object, \"constants.empty\");\n  set_integer(1, module_object, \"struct_array[1].i\");\n  set_integer(0, module_object, \"integer_array[%i]\", 0);\n  set_integer(1, module_object, \"integer_array[%i]\", 1);\n  set_integer(2, module_object, \"integer_array[%i]\", 2);\n  set_integer(256, module_object, \"integer_array[%i]\", 256);\n  set_string(\"foo\", module_object, \"string_array[%i]\", 0);\n  set_string(\"bar\", module_object, \"string_array[%i]\", 1);\n  set_string(\"baz\", module_object, \"string_array[%i]\", 2);\n  set_sized_string(\"foo\\0bar\", 7, module_object, \"string_array[%i]\", 3);\n  set_string(\"foo\", module_object, \"string_dict[%s]\", \"foo\");\n  set_string(\"bar\", module_object, \"string_dict[\\\"bar\\\"]\");\n  set_string(\"foo\", module_object, \"struct_dict[%s].s\", \"foo\");\n  set_integer(1, module_object, \"struct_dict[%s].i\", \"foo\");\n  return ERROR_SUCCESS;\n}", "target": 0}
{"code": "int __nla_validate(const struct nlattr *head, int len, int maxtype,\n\t\t   const struct nla_policy *policy, unsigned int validate,\n\t\t   struct netlink_ext_ack *extack)\n{\n\treturn __nla_validate_parse(head, len, maxtype, policy, validate,\n\t\t\t\t    extack, NULL);\n}", "target": 1}
{"code": "struct tcp_sock_t *tcp6_open(uint16_t port)\n{\n\tstruct tcp_sock_t *this = calloc(1, sizeof *this);\n\tif (this == NULL) {\n\t\tERR(\"IPv6: callocing this failed\");\n\t\tgoto error;\n\t}\n\tthis->sd = -1;\n\tthis->sd = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (this->sd < 0) {\n\t\tERR(\"Ipv6 socket open failed\");\n\t\tgoto error;\n\t}\n\tstruct sockaddr_in6 addr;\n\tmemset(&addr, 0, sizeof addr);\n\taddr.sin6_family = AF_INET6;\n\taddr.sin6_port = htons(port);\n\taddr.sin6_addr = in6addr_loopback;\n\tif (bind(this->sd,\n\t        (struct sockaddr *)&addr,\n\t        sizeof addr) < 0) {\n\t\tif (g_options.only_desired_port == 1)\n\t\t\tERR(\"IPv6 bind on port failed. \"\n\t\t\t    \"Requested port may be taken or require root permissions.\");\n\t\tgoto error;\n\t}\n\tif (listen(this->sd, HTTP_MAX_PENDING_CONNS) < 0) {\n\t\tERR(\"IPv6 listen failed on socket\");\n\t\tgoto error;\n\t}\n\treturn this;\nerror:\n\tif (this != NULL) {\n\t\tif (this->sd != -1) {\n\t\t\tclose(this->sd);\n\t\t}\n\t\tfree(this);\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "void xenvif_carrier_off(struct xenvif *vif)\n{\n\tstruct net_device *dev = vif->dev;\n\trtnl_lock();\n\tnetif_carrier_off(dev); \n\tif (netif_running(dev))\n\t\txenvif_down(vif);\n\trtnl_unlock();\n\txenvif_put(vif);\n}", "target": 0}
{"code": "static ssize_t aio_setup_vectored_rw(int type, struct kiocb *kiocb, bool compat)\n{\n\tssize_t ret;\n#ifdef CONFIG_COMPAT\n\tif (compat)\n\t\tret = compat_rw_copy_check_uvector(type,\n\t\t\t\t(struct compat_iovec __user *)kiocb->ki_buf,\n\t\t\t\tkiocb->ki_nbytes, 1, &kiocb->ki_inline_vec,\n\t\t\t\t&kiocb->ki_iovec, 1);\n\telse\n#endif\n\t\tret = rw_copy_check_uvector(type,\n\t\t\t\t(struct iovec __user *)kiocb->ki_buf,\n\t\t\t\tkiocb->ki_nbytes, 1, &kiocb->ki_inline_vec,\n\t\t\t\t&kiocb->ki_iovec, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = rw_verify_area(type, kiocb->ki_filp, &kiocb->ki_pos, ret);\n\tif (ret < 0)\n\t\tgoto out;\n\tkiocb->ki_nr_segs = kiocb->ki_nbytes;\n\tkiocb->ki_cur_seg = 0;\n\tkiocb->ki_nbytes = ret;\n\tkiocb->ki_left = ret;\n\tret = 0;\nout:\n\treturn ret;\n}", "target": 0}
{"code": "static int mxf_read_primer_pack(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFContext *mxf = arg;\n    int item_num = avio_rb32(pb);\n    int item_len = avio_rb32(pb);\n    if (item_len != 18) {\n        avpriv_request_sample(pb, \"Primer pack item length %d\", item_len);\n        return AVERROR_PATCHWELCOME;\n    }\n    if (item_num > 65536) {\n        av_log(mxf->fc, AV_LOG_ERROR, \"item_num %d is too large\\n\", item_num);\n        return AVERROR_INVALIDDATA;\n    }\n    mxf->local_tags = av_calloc(item_num, item_len);\n    if (!mxf->local_tags)\n        return AVERROR(ENOMEM);\n    mxf->local_tags_count = item_num;\n    avio_read(pb, mxf->local_tags, item_num*item_len);\n    return 0;\n}", "target": 1}
{"code": "    void SetProhibitQOpen(bool Mode) {ProhibitQOpen=Mode;}", "target": 0}
{"code": "\t\tauto Phase3() -> Local<Value> final {\n\t\t\treturn Boolean::New(Isolate::GetCurrent(), did_set);\n\t\t}", "target": 1}
{"code": "static struct dump_dir *open_directory_for_modification_of_element(\n    GDBusMethodInvocation *invocation,\n    uid_t caller_uid,\n    const char *problem_id,\n    const char *element)\n{\n    static const char *const protected_elements[] = {\n        FILENAME_TIME,\n        FILENAME_UID,\n        NULL,\n    };\n    for (const char *const *protected = protected_elements; *protected; ++protected)\n    {\n        if (strcmp(*protected, element) == 0)\n        {\n            log_notice(\"'%s' element of '%s' can't be modified\", element, problem_id);\n            char *error = xasprintf(_(\"'%s' element can't be modified\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                        \"org.freedesktop.problems.ProtectedElement\",\n                                        error);\n            free(error);\n            return NULL;\n        }\n    }\n    if (!dump_dir_accessible_by_uid(problem_id, caller_uid))\n    {\n        if (errno == ENOTDIR)\n        {\n            log_notice(\"'%s' is not a valid problem directory\", problem_id);\n            return_InvalidProblemDir_error(invocation, problem_id);\n        }\n        else\n        {\n            log_notice(\"UID(%d) is not Authorized to access '%s'\", caller_uid, problem_id);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                \"org.freedesktop.problems.AuthFailure\",\n                                _(\"Not Authorized\"));\n        }\n        return NULL;\n    }\n    struct dump_dir *dd = dd_opendir(problem_id,  0);\n    if (!dd)\n    {   \n        log_notice(\"Can't access the problem '%s' for modification\", problem_id);\n        g_dbus_method_invocation_return_dbus_error(invocation,\n                                \"org.freedesktop.problems.Failure\",\n                                _(\"Can't access the problem for modification\"));\n        return NULL;\n    }\n    return dd;\n}", "target": 1}
{"code": "static void perform_renew(void)\n{\n\tbb_info_msg(\"Performing a DHCP renew\");\n\tswitch (state) {\n\tcase BOUND:\n\t\tchange_listen_mode(LISTEN_KERNEL);\n\tcase RENEWING:\n\tcase REBINDING:\n\t\tstate = RENEW_REQUESTED;\n\t\tbreak;\n\tcase RENEW_REQUESTED: \n\t\tudhcp_run_script(NULL, \"deconfig\");\n\tcase REQUESTING:\n\tcase RELEASED:\n\t\tchange_listen_mode(LISTEN_RAW);\n\t\tstate = INIT_SELECTING;\n\t\tbreak;\n\tcase INIT_SELECTING:\n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "void free_pipe_info(struct pipe_inode_info *pipe)\n{\n\tint i;\n\taccount_pipe_buffers(pipe, pipe->buffers, 0);\n\tfree_uid(pipe->user);\n\tfor (i = 0; i < pipe->buffers; i++) {\n\t\tstruct pipe_buffer *buf = pipe->bufs + i;\n\t\tif (buf->ops)\n\t\t\tbuf->ops->release(pipe, buf);\n\t}\n\tif (pipe->tmp_page)\n\t\t__free_page(pipe->tmp_page);\n\tkfree(pipe->bufs);\n\tkfree(pipe);\n}", "target": 0}
{"code": "cib_notify_client(gpointer key, gpointer value, gpointer user_data)\n{\n    const char *type = NULL;\n    gboolean do_send = FALSE;\n    cib_client_t *client = value;\n    xmlNode *update_msg = user_data;\n    CRM_CHECK(client != NULL, return TRUE);\n    CRM_CHECK(update_msg != NULL, return TRUE);\n    if (client->ipc == NULL) {\n        crm_warn(\"Skipping client with NULL channel\");\n        return FALSE;\n    }\n    type = crm_element_value(update_msg, F_SUBTYPE);\n    CRM_LOG_ASSERT(type != NULL);\n    if (client->diffs && safe_str_eq(type, T_CIB_DIFF_NOTIFY)) {\n        do_send = TRUE;\n    } else if (client->replace && safe_str_eq(type, T_CIB_REPLACE_NOTIFY)) {\n        do_send = TRUE;\n    } else if (client->confirmations && safe_str_eq(type, T_CIB_UPDATE_CONFIRM)) {\n        do_send = TRUE;\n    } else if (client->pre_notify && safe_str_eq(type, T_CIB_PRE_NOTIFY)) {\n        do_send = TRUE;\n    } else if (client->post_notify && safe_str_eq(type, T_CIB_POST_NOTIFY)) {\n        do_send = TRUE;\n    }\n    if (do_send) {\n        if (client->ipc) {\n            if(crm_ipcs_send(client->ipc, 0, update_msg, TRUE) == FALSE) {\n                crm_warn(\"Notification of client %s/%s failed\", client->name, client->id);\n            }\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        } else if (client->session) {\n            crm_debug(\"Sent %s notification to client %s/%s\", type, client->name, client->id);\n            crm_send_remote_msg(client->session, update_msg, client->encrypted);\n#endif\n        } else {\n            crm_err(\"Unknown transport for %s\", client->name);\n        }\n    }\n    return FALSE;\n}", "target": 1}
{"code": "void ext4_es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t   ext4_lblk_t len)\n{\n\text4_lblk_t end;\n\tint err = 0;\n\tint reserved = 0;\n\tstruct extent_status *es = NULL;\n\tif (EXT4_SB(inode->i_sb)->s_mount_state & EXT4_FC_REPLAY)\n\t\treturn;\n\ttrace_ext4_es_remove_extent(inode, lblk, len);\n\tes_debug(\"remove [%u/%u) from extent status tree of inode %lu\\n\",\n\t\t lblk, len, inode->i_ino);\n\tif (!len)\n\t\treturn;\n\tend = lblk + len - 1;\n\tBUG_ON(end < lblk);\nretry:\n\tif (err && !es)\n\t\tes = __es_alloc_extent(true);\n\twrite_lock(&EXT4_I(inode)->i_es_lock);\n\terr = __es_remove_extent(inode, lblk, end, &reserved, es);\n\tif (es && !es->es_len)\n\t\t__es_free_extent(es);\n\twrite_unlock(&EXT4_I(inode)->i_es_lock);\n\tif (err)\n\t\tgoto retry;\n\text4_es_print_tree(inode);\n\text4_da_release_space(inode, reserved);\n\treturn;\n}", "target": 1}
{"code": "static u32 swf_get_32(SWFReader *read)\n{\n\tu32 val, res;\n\tval = swf_read_int(read, 32);\n\tres = (val&0xFF);\n\tres <<=8;\n\tres |= ((val>>8)&0xFF);\n\tres<<=8;\n\tres |= ((val>>16)&0xFF);\n\tres<<=8;\n\tres|= ((val>>24)&0xFF);\n\treturn res;\n}", "target": 1}
{"code": "  pin(std::string pin, std::string name) {\n    pt::ptree tree;\n    if (map_id_sess.empty()) {\n      return false;\n    }\n    if (pin.size() != 4) {\n      tree.put(\"root.paired\", 0);\n      tree.put(\"root.<xmlattr>.status_code\", 400);\n      tree.put(\n        \"root.<xmlattr>.status_message\", \"Pin must be 4 digits, \" + std::to_string(pin.size()) + \" provided\");\n      return false;\n    }\n    if (!std::all_of(pin.begin(), pin.end(), ::isdigit)) {\n      tree.put(\"root.paired\", 0);\n      tree.put(\"root.<xmlattr>.status_code\", 400);\n      tree.put(\"root.<xmlattr>.status_message\", \"Pin must be numeric\");\n      return false;\n    }\n    auto &sess = std::begin(map_id_sess)->second;\n    getservercert(sess, tree, pin);\n    sess.client.name = name;\n    std::ostringstream data;\n    pt::write_xml(data, tree);\n    auto &async_response = sess.async_insert_pin.response;\n    if (async_response.has_left() && async_response.left()) {\n      async_response.left()->write(data.str());\n    }\n    else if (async_response.has_right() && async_response.right()) {\n      async_response.right()->write(data.str());\n    }\n    else {\n      return false;\n    }\n    async_response = std::decay_t<decltype(async_response.left())>();\n    return true;\n  }", "target": 0}
{"code": "bool CModules::ValidateModuleName(const CString& sModule, CString& sRetMsg) {\n    for (unsigned int a = 0; a < sModule.length(); a++) {\n        if (((sModule[a] < '0') || (sModule[a] > '9')) &&\n            ((sModule[a] < 'a') || (sModule[a] > 'z')) &&\n            ((sModule[a] < 'A') || (sModule[a] > 'Z')) && (sModule[a] != '_')) {\n            sRetMsg =\n                t_f(\"Module names can only contain letters, numbers and \"\n                    \"underscores, [{1}] is invalid\")(sModule);\n            return false;\n        }\n    }\n    return true;\n}", "target": 0}
{"code": "int ieee80211_radiotap_iterator_init(\n\tstruct ieee80211_radiotap_iterator *iterator,\n\tstruct ieee80211_radiotap_header *radiotap_header,\n\tint max_length, const struct ieee80211_radiotap_vendor_namespaces *vns)\n{\n\tif (radiotap_header->it_version)\n\t\treturn -EINVAL;\n\tif (max_length < get_unaligned_le16(&radiotap_header->it_len))\n\t\treturn -EINVAL;\n\titerator->_rtheader = radiotap_header;\n\titerator->_max_length = get_unaligned_le16(&radiotap_header->it_len);\n\titerator->_arg_index = 0;\n\titerator->_bitmap_shifter = get_unaligned_le32(&radiotap_header->it_present);\n\titerator->_arg = (uint8_t *)radiotap_header + sizeof(*radiotap_header);\n\titerator->_reset_on_ext = 0;\n\titerator->_next_bitmap = &radiotap_header->it_present;\n\titerator->_next_bitmap++;\n\titerator->_vns = vns;\n\titerator->current_namespace = &radiotap_ns;\n\titerator->is_radiotap_ns = 1;\n\tif (iterator->_bitmap_shifter & (1<<IEEE80211_RADIOTAP_EXT)) {\n\t\twhile (get_unaligned_le32(iterator->_arg) &\n\t\t\t\t\t(1 << IEEE80211_RADIOTAP_EXT)) {\n\t\t\titerator->_arg += sizeof(uint32_t);\n\t\t\tif ((unsigned long)iterator->_arg -\n\t\t\t    (unsigned long)iterator->_rtheader >\n\t\t\t    (unsigned long)iterator->_max_length)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\titerator->_arg += sizeof(uint32_t);\n\t}\n\titerator->this_arg = iterator->_arg;\n\treturn 0;\n}", "target": 1}
{"code": "__acquires(&fc->lock)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(req->inode);\n\tloff_t size = i_size_read(req->inode);\n\tstruct fuse_write_in *inarg = &req->misc.write.in;\n\tif (!fc->connected)\n\t\tgoto out_free;\n\tif (inarg->offset + PAGE_CACHE_SIZE <= size) {\n\t\tinarg->size = PAGE_CACHE_SIZE;\n\t} else if (inarg->offset < size) {\n\t\tinarg->size = size & (PAGE_CACHE_SIZE - 1);\n\t} else {\n\t\tgoto out_free;\n\t}\n\treq->in.args[1].size = inarg->size;\n\tfi->writectr++;\n\tfuse_request_send_background_locked(fc, req);\n\treturn;\n out_free:\n\tfuse_writepage_finish(fc, req);\n\tspin_unlock(&fc->lock);\n\tfuse_writepage_free(fc, req);\n\tfuse_put_request(fc, req);\n\tspin_lock(&fc->lock);\n}", "target": 0}
{"code": "static int is_integer(char *string)\n{\n  if (isdigit(string[0]) || string[0] == '-' || string[0] == '+') {\n    while (*++string && isdigit(*string))\n      ;                                           \n    if (!*string)\n      return 1;\n  }\n  return 0;\n}", "target": 1}
{"code": "static int cuse_channel_release(struct inode *inode, struct file *file)\n{\n\tstruct fuse_dev *fud = file->private_data;\n\tstruct cuse_conn *cc = fc_to_cc(fud->fc);\n\tint rc;\n\tmutex_lock(&cuse_lock);\n\tlist_del_init(&cc->list);\n\tmutex_unlock(&cuse_lock);\n\tif (cc->dev)\n\t\tdevice_unregister(cc->dev);\n\tif (cc->cdev) {\n\t\tunregister_chrdev_region(cc->cdev->dev, 1);\n\t\tcdev_del(cc->cdev);\n\t}\n\tfuse_conn_put(&cc->fc);\n\trc = fuse_dev_release(inode, file);\t\n\treturn rc;\n}", "target": 0}
{"code": "static inline void txopt_put(struct ipv6_txoptions *opt)\n{\n\tif (opt && atomic_dec_and_test(&opt->refcnt))\n\t\tkfree_rcu(opt, rcu);\n}", "target": 0}
{"code": "int cmd_upload_pack(int argc, const char **argv, const char *prefix)\n{\n\tconst char *dir;\n\tint strict = 0;\n\tint advertise_refs = 0;\n\tint stateless_rpc = 0;\n\tint timeout = 0;\n\tstruct option options[] = {\n\t\tOPT_BOOL(0, \"stateless-rpc\", &stateless_rpc,\n\t\t\t N_(\"quit after a single request/response exchange\")),\n\t\tOPT_HIDDEN_BOOL(0, \"http-backend-info-refs\", &advertise_refs,\n\t\t\t\tN_(\"serve up the info/refs for git-http-backend\")),\n\t\tOPT_ALIAS(0, \"advertise-refs\", \"http-backend-info-refs\"),\n\t\tOPT_BOOL(0, \"strict\", &strict,\n\t\t\t N_(\"do not try <directory>/.git/ if <directory> is no Git directory\")),\n\t\tOPT_INTEGER(0, \"timeout\", &timeout,\n\t\t\t    N_(\"interrupt transfer after <n> seconds of inactivity\")),\n\t\tOPT_END()\n\t};\n\tpacket_trace_identity(\"upload-pack\");\n\tread_replace_refs = 0;\n\txsetenv(\"GIT_NO_LAZY_FETCH\", \"1\", 0);\n\targc = parse_options(argc, argv, prefix, options, upload_pack_usage, 0);\n\tif (argc != 1)\n\t\tusage_with_options(upload_pack_usage, options);\n\tsetup_path();\n\tdir = argv[0];\n\tif (!enter_repo(dir, strict))\n\t\tdie(\"'%s' does not appear to be a git repository\", dir);\n\tswitch (determine_protocol_version_server()) {\n\tcase protocol_v2:\n\t\tif (advertise_refs)\n\t\t\tprotocol_v2_advertise_capabilities();\n\t\telse\n\t\t\tprotocol_v2_serve_loop(stateless_rpc);\n\t\tbreak;\n\tcase protocol_v1:\n\t\tif (advertise_refs || !stateless_rpc)\n\t\t\tpacket_write_fmt(1, \"version 1\\n\");\n\tcase protocol_v0:\n\t\tupload_pack(advertise_refs, stateless_rpc, timeout);\n\t\tbreak;\n\tcase protocol_unknown_version:\n\t\tBUG(\"unknown protocol version\");\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "bool dir_is_in_dump_location(const char *dir_name)\n{\n    unsigned len = strlen(g_settings_dump_location);\n    if (strncmp(dir_name, g_settings_dump_location, len) != 0)\n    {\n        log_debug(\"Bad parent directory: '%s' not in '%s'\", g_settings_dump_location, dir_name);\n        return false;\n    }\n    const char *base_name = dir_name + len;\n    while (*base_name && *base_name == '/')\n        ++base_name;\n    if (*(base_name - 1) != '/' || !str_is_correct_filename(base_name))\n    {\n        log_debug(\"Invalid dump directory name: '%s'\", base_name);\n        return false;\n    }\n    struct stat sb;\n    if (lstat(dir_name, &sb) < 0)\n    {\n        VERB2 perror_msg(\"stat('%s')\", dir_name);\n        return errno== ENOENT;\n    }\n    return S_ISDIR(sb.st_mode);\n}", "target": 0}
{"code": "comics_remove_dir (gchar *path_name) \n{\n\tGDir  *content_dir;\n\tconst gchar *filename;\n\tgchar *filename_with_path;\n\tif (g_file_test (path_name, G_FILE_TEST_IS_DIR)) {\n\t\tcontent_dir = g_dir_open  (path_name, 0, NULL);\n\t\tfilename  = g_dir_read_name (content_dir);\n\t\twhile (filename) {\n\t\t\tfilename_with_path = \n\t\t\t\tg_build_filename (path_name, \n\t\t\t\t\t\t  filename, NULL);\n\t\t\tcomics_remove_dir (filename_with_path);\n\t\t\tg_free (filename_with_path);\n\t\t\tfilename = g_dir_read_name (content_dir);\n\t\t}\n\t\tg_dir_close (content_dir);\n\t}\n\treturn (g_remove (path_name));\n}", "target": 1}
{"code": "void __init acpi_debugfs_init(void)\n{\n\tacpi_debugfs_dir = debugfs_create_dir(\"acpi\", NULL);\n\tacpi_custom_method_init();\n}", "target": 1}
{"code": "smb2_queryfs(const unsigned int xid, struct cifs_tcon *tcon,\n\t     struct cifs_sb_info *cifs_sb, struct kstatfs *buf)\n{\n\tstruct smb2_query_info_rsp *rsp;\n\tstruct smb2_fs_full_size_info *info = NULL;\n\tstruct kvec rsp_iov = {NULL, 0};\n\tint buftype = CIFS_NO_BUFFER;\n\tint rc;\n\trc = smb2_query_info_compound(xid, tcon, \"\",\n\t\t\t\t      FILE_READ_ATTRIBUTES,\n\t\t\t\t      FS_FULL_SIZE_INFORMATION,\n\t\t\t\t      SMB2_O_INFO_FILESYSTEM,\n\t\t\t\t      sizeof(struct smb2_fs_full_size_info),\n\t\t\t\t      &rsp_iov, &buftype, cifs_sb);\n\tif (rc)\n\t\tgoto qfs_exit;\n\trsp = (struct smb2_query_info_rsp *)rsp_iov.iov_base;\n\tbuf->f_type = SMB2_SUPER_MAGIC;\n\tinfo = (struct smb2_fs_full_size_info *)(\n\t\tle16_to_cpu(rsp->OutputBufferOffset) + (char *)rsp);\n\trc = smb2_validate_iov(le16_to_cpu(rsp->OutputBufferOffset),\n\t\t\t       le32_to_cpu(rsp->OutputBufferLength),\n\t\t\t       &rsp_iov,\n\t\t\t       sizeof(struct smb2_fs_full_size_info));\n\tif (!rc)\n\t\tsmb2_copy_fs_info_to_kstatfs(info, buf);\nqfs_exit:\n\tfree_rsp_buf(buftype, rsp_iov.iov_base);\n\treturn rc;\n}", "target": 0}
{"code": "static int call_function(cfg_t *cfg, cfg_opt_t *opt, cfg_opt_t *funcopt)\n{\n\tint ret;\n\tconst char **argv;\n\tunsigned int i;\n\tif (!cfg || !opt ||!funcopt) {\n\t\terrno = EINVAL;\n\t\treturn CFG_FAIL;\n\t}\n\targv = calloc(funcopt->nvalues, sizeof(char *));\n\tif (!argv)\n\t\treturn CFG_FAIL;\n\tfor (i = 0; i < funcopt->nvalues; i++)\n\t\targv[i] = funcopt->values[i]->string;\n\tret = (*opt->func) (cfg, opt, funcopt->nvalues, argv);\n\tcfg_free_value(funcopt);\n\tfree(argv);\n\treturn ret;\n}", "target": 0}
{"code": "static struct dentry *bad_inode_lookup(struct inode *dir,\n\t\t\tstruct dentry *dentry, struct nameidata *nd)\n{\n\treturn ERR_PTR(-EIO);\n}", "target": 0}
{"code": "static UINT ExtractRunLengthRegularFgBg(const BYTE* pbOrderHdr, const BYTE* pbEnd, UINT32* advance)\n{\n\tUINT runLength = 0;\n\tWINPR_ASSERT(pbOrderHdr);\n\tWINPR_ASSERT(pbEnd);\n\tWINPR_ASSERT(advance);\n\trunLength = (*pbOrderHdr) & g_MaskRegularRunLength;\n\tif (runLength == 0)\n\t{\n\t\tif (!buffer_within_range(pbOrderHdr, 1, pbEnd))\n\t\t{\n\t\t\t*advance = 0;\n\t\t\treturn 0;\n\t\t}\n\t\trunLength = *(pbOrderHdr + 1) + 1;\n\t\t(*advance)++;\n\t}\n\telse\n\t\trunLength = runLength * 8;\n\treturn runLength;\n}", "target": 1}
{"code": "static int cg_open(const char *path, struct fuse_file_info *fi)\n{\n\tconst char *cgroup;\n\tchar *fpath = NULL, *path1, *path2, * cgdir = NULL, *controller;\n\tstruct cgfs_files *k = NULL;\n\tstruct file_info *file_info;\n\tstruct fuse_context *fc = fuse_get_context();\n\tint ret;\n\tif (!fc)\n\t\treturn -EIO;\n\tcontroller = pick_controller_from_path(fc, path);\n\tif (!controller)\n\t\treturn -EIO;\n\tcgroup = find_cgroup_in_path(path);\n\tif (!cgroup)\n\t\treturn -EINVAL;\n\tget_cgdir_and_path(cgroup, &cgdir, &fpath);\n\tif (!fpath) {\n\t\tpath1 = \"/\";\n\t\tpath2 = cgdir;\n\t} else {\n\t\tpath1 = cgdir;\n\t\tpath2 = fpath;\n\t}\n\tk = cgfs_get_key(controller, path1, path2);\n\tif (!k) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tfree_key(k);\n\tif (!caller_may_see_dir(fc->pid, controller, path1)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tif (!fc_may_access(fc, controller, path1, path2, fi->flags)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\tfile_info = malloc(sizeof(*file_info));\n\tif (!file_info) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tfile_info->controller = must_copy_string(controller);\n\tfile_info->cgroup = must_copy_string(path1);\n\tfile_info->file = must_copy_string(path2);\n\tfile_info->type = LXC_TYPE_CGFILE;\n\tfile_info->buf = NULL;\n\tfile_info->buflen = 0;\n\tfi->fh = (unsigned long)file_info;\n\tret = 0;\nout:\n\tfree(cgdir);\n\treturn ret;\n}", "target": 0}
{"code": "cmd_readcert (assuan_context_t ctx, char *line)\n{\n  ctrl_t ctrl = assuan_get_pointer (ctx);\n  int rc;\n  unsigned char *cert;\n  size_t ncert;\n  if ((rc = open_card (ctrl, NULL)))\n    return rc;\n  line = xstrdup (line); \n  rc = app_readcert (ctrl->app_ctx, line, &cert, &ncert);\n  if (rc)\n    log_error (\"app_readcert failed: %s\\n\", gpg_strerror (rc));\n  xfree (line);\n  line = NULL;\n  if (!rc)\n    {\n      rc = assuan_send_data (ctx, cert, ncert);\n      xfree (cert);\n      if (rc)\n        return rc;\n    }\n  TEST_CARD_REMOVAL (ctrl, rc);\n  return rc;\n}", "target": 0}
{"code": "int AVI_read_audio(avi_t *AVI, u8 *audbuf, int bytes, int *continuous)\n{\n\tint nr, todo;\n\ts64 pos;\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\tif(!AVI->track[AVI->aptr].audio_index)         {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\tnr = 0; \n\tif (bytes==0) {\n\t\tAVI->track[AVI->aptr].audio_posc++;\n\t\tAVI->track[AVI->aptr].audio_posb = 0;\n\t}\n\t*continuous = 1;\n\twhile(bytes>0)\n\t{\n\t\ts64 ret;\n\t\tint left = (int) (AVI->track[AVI->aptr].audio_index[AVI->track[AVI->aptr].audio_posc].len - AVI->track[AVI->aptr].audio_posb);\n\t\tif(left==0)\n\t\t{\n\t\t\tif(AVI->track[AVI->aptr].audio_posc>=AVI->track[AVI->aptr].audio_chunks-1) return nr;\n\t\t\tAVI->track[AVI->aptr].audio_posc++;\n\t\t\tAVI->track[AVI->aptr].audio_posb = 0;\n\t\t\t*continuous = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif(bytes<left)\n\t\t\ttodo = bytes;\n\t\telse\n\t\t\ttodo = left;\n\t\tpos = AVI->track[AVI->aptr].audio_index[AVI->track[AVI->aptr].audio_posc].pos + AVI->track[AVI->aptr].audio_posb;\n\t\tgf_fseek(AVI->fdes, pos, SEEK_SET);\n\t\tif ( (ret = avi_read(AVI->fdes,audbuf+nr,todo)) != todo)\n\t\t{\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] XXX pos = %\"LLD\", ret = %\"LLD\", todo = %ld\\n\", pos, ret, todo));\n\t\t\tAVI_errno = AVI_ERR_READ;\n\t\t\treturn -1;\n\t\t}\n\t\tbytes -= todo;\n\t\tnr    += todo;\n\t\tAVI->track[AVI->aptr].audio_posb += todo;\n\t}\n\treturn nr;\n}", "target": 1}
{"code": "void\nyyerror(YYLTYPE *yylloc, void *scanner, struct yang_parameter *param, ...)\n{\n  free(*param->value);\n  *param->value = NULL;\n  if (yylloc->first_line != -1) {\n    if (*param->data_node && (*param->data_node) == (*param->actual_node)) {\n      LOGVAL(param->module->ctx, LYE_INSTMT, LY_VLOG_LYS, *param->data_node, yyget_text(scanner));\n    } else {\n      LOGVAL(param->module->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, yyget_text(scanner));\n    }\n  }", "target": 0}
{"code": "SecureSocket::initContext(bool server)\n{\n    SSL_library_init();\n    const SSL_METHOD* method;\n    OpenSSL_add_all_algorithms();\n    SSL_load_error_strings();\n    if (CLOG->getFilter() >= kINFO) {\n        showSecureLibInfo();\n    }\n    if (server) {\n        method = SSLv23_server_method();\n    }\n    else {\n        method = SSLv23_client_method();\n    }\n    SSL_METHOD* m = const_cast<SSL_METHOD*>(method);\n    m_ssl->m_context = SSL_CTX_new(m);\n    SSL_CTX_set_options(m_ssl->m_context, SSL_OP_NO_SSLv3);\n    if (m_ssl->m_context == NULL) {\n        showError(\"\");\n    }\n    if (security_level_ == ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED) {\n        SSL_CTX_set_verify(m_ssl->m_context, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,\n                           nullptr);\n        SSL_CTX_set_cert_verify_callback(m_ssl->m_context, cert_verify_ignore_callback, nullptr);\n    }\n}", "target": 0}
{"code": "pf_remove_state(struct pf_state *st)\n{\n\tPF_ASSERT_LOCKED();\n\tif (st->timeout == PFTM_UNLINKED)\n\t\treturn;\n\tst->timeout = PFTM_UNLINKED;\n\tpf_postprocess_addr(st);\n\tif (st->src.state == PF_TCPS_PROXY_DST) {\n\t\tpf_send_tcp(st->rule.ptr, st->key[PF_SK_WIRE]->af,\n\t\t    &st->key[PF_SK_WIRE]->addr[1],\n\t\t    &st->key[PF_SK_WIRE]->addr[0],\n\t\t    st->key[PF_SK_WIRE]->port[1],\n\t\t    st->key[PF_SK_WIRE]->port[0],\n\t\t    st->src.seqhi, st->src.seqlo + 1,\n\t\t    TH_RST|TH_ACK, 0, 0, 0, 1, st->tag,\n\t\t    st->key[PF_SK_WIRE]->rdomain);\n\t}\n\tif (st->key[PF_SK_STACK]->proto == IPPROTO_TCP)\n\t\tpf_set_protostate(st, PF_PEER_BOTH, TCPS_CLOSED);\n\tRBT_REMOVE(pf_state_tree_id, &tree_id, st);\n#if NPFLOW > 0\n\tif (st->state_flags & PFSTATE_PFLOW)\n\t\texport_pflow(st);\n#endif\t\n#if NPFSYNC > 0\n\tpfsync_delete_state(st);\n#endif\t\n\tpf_src_tree_remove_state(st);\n\tpf_detach_state(st);\n}", "target": 1}
{"code": "ssize_t uv__idna_toascii(const char* s, const char* se, char* d, char* de) {\n  const char* si;\n  const char* st;\n  unsigned c;\n  char* ds;\n  int rc;\n  ds = d;\n  si = s;\n  while (si < se) {\n    st = si;\n    c = uv__utf8_decode1(&si, se);\n    if (c == UINT_MAX)\n      return UV_EINVAL;\n    if (c != '.')\n      if (c != 0x3002)  \n        if (c != 0xFF0E)  \n          if (c != 0xFF61)  \n            continue;\n    rc = uv__idna_toascii_label(s, st, &d, de);\n    if (rc < 0)\n      return rc;\n    if (d < de)\n      *d++ = '.';\n    s = si;\n  }\n  if (s < se) {\n    rc = uv__idna_toascii_label(s, se, &d, de);\n    if (rc < 0)\n      return rc;\n  }\n  if (d < de)\n    *d++ = '\\0';\n  return d - ds;  \n}", "target": 1}
{"code": "static RList *patch_relocs(RBin *b) {\n\tr_return_val_if_fail (b && b->iob.io && b->iob.io->desc, NULL);\n\tRBinObject *bo = r_bin_cur_object (b);\n\tRIO *io = b->iob.io;\n\tif (!bo || !bo->bin_obj) {\n\t\treturn NULL;\n\t}\n\tstruct r_bin_coff_obj *bin = (struct r_bin_coff_obj*)bo->bin_obj;\n\tif (bin->hdr.f_flags & COFF_FLAGS_TI_F_EXEC) {\n\t\treturn NULL;\n\t}\n\tif (!(io->cached & R_PERM_W)) {\n\t\teprintf (\n\t\t\t\"Warning: please run r2 with -e io.cache=true to patch \"\n\t\t\t\"relocations\\n\");\n\t\treturn NULL;\n\t}\n\tsize_t nimports = 0;\n\tint i;\n\tfor (i = 0; i < bin->hdr.f_nsyms; i++) {\n\t\tif (is_imported_symbol (&bin->symbols[i])) {\n\t\t\tnimports++;\n\t\t}\n\t\ti += bin->symbols[i].n_numaux;\n\t}\n\tut64 m_vaddr = UT64_MAX;\n\tif (nimports) {\n\t\tut64 offset = 0;\n\t\tRIOBank *bank = b->iob.bank_get (io, io->bank);\n\t\tRListIter *iter;\n\t\tRIOMapRef *mapref;\n\t\tr_list_foreach (bank->maprefs, iter, mapref) {\n\t\t\tRIOMap *map = b->iob.map_get (io, mapref->id);\n\t\t\tif (r_io_map_end (map) > offset) {\n\t\t\t\toffset = r_io_map_end (map);\n\t\t\t}\n\t\t}\n\t\tm_vaddr = R_ROUND (offset, 16);\n\t\tut64 size = nimports * BYTES_PER_IMP_RELOC;\n\t\tchar *muri = r_str_newf (\"malloc:\n\t\tRIODesc *desc = b->iob.open_at (io, muri, R_PERM_R, 0664, m_vaddr);\n\t\tfree (muri);\n\t\tif (!desc) {\n\t\t\treturn NULL;\n\t\t}\n\t\tRIOMap *map = b->iob.map_get_at (io, m_vaddr);\n\t\tif (!map) {\n\t\t\treturn NULL;\n\t\t}\n\t\tmap->name = strdup (\".imports.r2\");\n\t}\n\treturn _relocs_list (b, bin, true, m_vaddr);\n}", "target": 1}
{"code": "static void kvm_vcpu_ioctl_x86_get_debugregs(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     struct kvm_debugregs *dbgregs)\n{\n\tunsigned long val;\n\tmemcpy(dbgregs->db, vcpu->arch.db, sizeof(vcpu->arch.db));\n\tkvm_get_dr(vcpu, 6, &val);\n\tdbgregs->dr6 = val;\n\tdbgregs->dr7 = vcpu->arch.dr7;\n\tdbgregs->flags = 0;\n\tmemset(&dbgregs->reserved, 0, sizeof(dbgregs->reserved));\n}", "target": 1}
{"code": "onig_new_deluxe(regex_t** reg, const UChar* pattern, const UChar* pattern_end,\n                OnigCompileInfo* ci, OnigErrorInfo* einfo)\n{\n  int r;\n  UChar *cpat, *cpat_end;\n  if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;\n  if (ci->pattern_enc != ci->target_enc) {\n    r = conv_encoding(ci->pattern_enc, ci->target_enc, pattern, pattern_end,\n                      &cpat, &cpat_end);\n    if (r != 0) return r;\n  }\n  else {\n    cpat     = (UChar* )pattern;\n    cpat_end = (UChar* )pattern_end;\n  }\n  *reg = (regex_t* )xmalloc(sizeof(regex_t));\n  if (IS_NULL(*reg)) {\n    r = ONIGERR_MEMORY;\n    goto err2;\n  }\n  r = onig_reg_init(*reg, ci->option, ci->case_fold_flag, ci->target_enc,\n                    ci->syntax);\n  if (r != 0) goto err;\n  r = onig_compile(*reg, cpat, cpat_end, einfo);\n  if (r != 0) {\n  err:\n    onig_free(*reg);\n    *reg = NULL;\n  }\n err2:\n  if (cpat != pattern) xfree(cpat);\n  return r;\n}", "target": 1}
{"code": "void macvlan_common_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\tdev->priv_flags\t       &= ~IFF_XMIT_DST_RELEASE;\n\tdev->netdev_ops\t\t= &macvlan_netdev_ops;\n\tdev->destructor\t\t= free_netdev;\n\tdev->header_ops\t\t= &macvlan_hard_header_ops,\n\tdev->ethtool_ops\t= &macvlan_ethtool_ops;\n}", "target": 1}
{"code": "static bool msr_mtrr_valid(unsigned msr)\n{\n\tswitch (msr) {\n\tcase 0x200 ... 0x200 + 2 * KVM_NR_VAR_MTRR - 1:\n\tcase MSR_MTRRfix64K_00000:\n\tcase MSR_MTRRfix16K_80000:\n\tcase MSR_MTRRfix16K_A0000:\n\tcase MSR_MTRRfix4K_C0000:\n\tcase MSR_MTRRfix4K_C8000:\n\tcase MSR_MTRRfix4K_D0000:\n\tcase MSR_MTRRfix4K_D8000:\n\tcase MSR_MTRRfix4K_E0000:\n\tcase MSR_MTRRfix4K_E8000:\n\tcase MSR_MTRRfix4K_F0000:\n\tcase MSR_MTRRfix4K_F8000:\n\tcase MSR_MTRRdefType:\n\tcase MSR_IA32_CR_PAT:\n\t\treturn true;\n\tcase 0x2f8:\n\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "static bool __f2fs_init_extent_tree(struct inode *inode, struct f2fs_extent *i_ext)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct extent_tree *et;\n\tstruct extent_node *en;\n\tstruct extent_info ei;\n\tif (!f2fs_may_extent_tree(inode)) {\n\t\tif (i_ext && i_ext->len) {\n\t\t\ti_ext->len = 0;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tet = __grab_extent_tree(inode);\n\tif (!i_ext || !i_ext->len)\n\t\treturn false;\n\tget_extent_info(&ei, i_ext);\n\twrite_lock(&et->lock);\n\tif (atomic_read(&et->node_cnt))\n\t\tgoto out;\n\ten = __init_extent_tree(sbi, et, &ei);\n\tif (en) {\n\t\tspin_lock(&sbi->extent_lock);\n\t\tlist_add_tail(&en->list, &sbi->extent_list);\n\t\tspin_unlock(&sbi->extent_lock);\n\t}\nout:\n\twrite_unlock(&et->lock);\n\treturn false;\n}", "target": 0}
{"code": "static bool em_syscall_is_enabled(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct x86_emulate_ops *ops = ctxt->ops;\n\tu32 eax, ebx, ecx, edx;\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\treturn true;\n\teax = 0x00000000;\n\tecx = 0x00000000;\n\tif (ops->get_cpuid(ctxt, &eax, &ebx, &ecx, &edx)) {\n\t\tif (ebx == X86EMUL_CPUID_VENDOR_GenuineIntel_ebx &&\n\t\t    ecx == X86EMUL_CPUID_VENDOR_GenuineIntel_ecx &&\n\t\t    edx == X86EMUL_CPUID_VENDOR_GenuineIntel_edx)\n\t\t\treturn false;\n\t\tif (ebx == X86EMUL_CPUID_VENDOR_AuthenticAMD_ebx &&\n\t\t    ecx == X86EMUL_CPUID_VENDOR_AuthenticAMD_ecx &&\n\t\t    edx == X86EMUL_CPUID_VENDOR_AuthenticAMD_edx)\n\t\t\treturn true;\n\t\tif (ebx == X86EMUL_CPUID_VENDOR_AMDisbetterI_ebx &&\n\t\t    ecx == X86EMUL_CPUID_VENDOR_AMDisbetterI_ecx &&\n\t\t    edx == X86EMUL_CPUID_VENDOR_AMDisbetterI_edx)\n\t\t\treturn true;\n\t}\n\treturn false;\n}", "target": 0}
{"code": "int snmp_version(void *context, size_t hdrlen, unsigned char tag,\n\t\t const void *data, size_t datalen)\n{\n\tif (datalen != 1)\n\t\treturn -EINVAL;\n\tif (*(unsigned char *)data > 1)\n\t\treturn -ENOTSUPP;\n\treturn 1;\n}", "target": 0}
{"code": "static int extractRDNSequence(struct ndpi_packet_struct *packet,\n\t\t\t      u_int offset, char *buffer, u_int buffer_len,\n\t\t\t      char *rdnSeqBuf, u_int *rdnSeqBuf_offset,\n\t\t\t      u_int rdnSeqBuf_len,\n\t\t\t      const char *label) {\n  u_int8_t str_len = packet->payload[offset+4], is_printable = 1;\n  char *str;\n  u_int len, j;\n  if (*rdnSeqBuf_offset >= rdnSeqBuf_len) {\n#ifdef DEBUG_TLS\n    printf(\"[TLS] %s() [buffer capacity reached][%u]\\n\",\n           __FUNCTION__, rdnSeqBuf_len);\n#endif\n    return -1;\n  }\n  if((offset+4+str_len) >= packet->payload_packet_len)\n    return(-1);\n  str = (char*)&packet->payload[offset+5];\n  len = (u_int)ndpi_min(str_len, buffer_len-1);\n  strncpy(buffer, str, len);\n  buffer[len] = '\\0';\n  for(j = 0; j < len; j++) {\n    if(!ndpi_isprint(buffer[j])) {\n      is_printable = 0;\n      break;\n    }\n  }\n  if(is_printable) {\n    int rc = snprintf(&rdnSeqBuf[*rdnSeqBuf_offset],\n\t\t      rdnSeqBuf_len-(*rdnSeqBuf_offset),\n\t\t      \"%s%s=%s\", (*rdnSeqBuf_offset > 0) ? \", \" : \"\",\n\t\t      label, buffer);\n    if(rc > 0)\n      (*rdnSeqBuf_offset) += rc;\n  }\n  return(is_printable);\n}", "target": 0}
{"code": "ZEND_API void zend_objects_store_del_ref_by_handle_ex(zend_object_handle handle, const zend_object_handlers *handlers TSRMLS_DC) \n{\n\tstruct _store_object *obj;\n\tint failure = 0;\n\tif (!EG(objects_store).object_buckets) {\n\t\treturn;\n\t}\n\tobj = &EG(objects_store).object_buckets[handle].bucket.obj;\n\tif (EG(objects_store).object_buckets[handle].valid) {\n\t\tif (obj->refcount == 1) {\n\t\t\tif (!EG(objects_store).object_buckets[handle].destructor_called) {\n\t\t\t\tEG(objects_store).object_buckets[handle].destructor_called = 1;\n\t\t\t\tif (obj->dtor) {\n\t\t\t\t\tif (handlers && !obj->handlers) {\n\t\t\t\t\t\tobj->handlers = handlers;\n\t\t\t\t\t}\n\t\t\t\t\tzend_try {\n\t\t\t\t\t\tobj->dtor(obj->object, handle TSRMLS_CC);\n\t\t\t\t\t} zend_catch {\n\t\t\t\t\t\tfailure = 1;\n\t\t\t\t\t} zend_end_try();\n\t\t\t\t}\n\t\t\t}\n\t\t\tobj = &EG(objects_store).object_buckets[handle].bucket.obj;\n\t\t\tif (obj->refcount == 1) {\n\t\t\t\tGC_REMOVE_ZOBJ_FROM_BUFFER(obj);\n\t\t\t\tif (obj->free_storage) {\n\t\t\t\t\tzend_try {\n\t\t\t\t\t\tobj->free_storage(obj->object TSRMLS_CC);\n\t\t\t\t\t} zend_catch {\n\t\t\t\t\t\tfailure = 1;\n\t\t\t\t\t} zend_end_try();\n\t\t\t\t}\n\t\t\t\tZEND_OBJECTS_STORE_ADD_TO_FREE_LIST();\n\t\t\t}\n\t\t}\n\t}\n\tobj->refcount--;\n#if ZEND_DEBUG_OBJECTS\n\tif (obj->refcount == 0) {\n\t\tfprintf(stderr, \"Deallocated object id #%d\\n\", handle);\n\t} else {\n\t\tfprintf(stderr, \"Decreased refcount of object id #%d\\n\", handle);\n\t}\n#endif\n\tif (failure) {\n\t\tzend_bailout();\n\t}\n}", "target": 1}
{"code": "Resource* ResourceHost::getResource(std::string uri) {\n\tif (uri.length() > 255 || uri.empty())\n\t\treturn NULL;\n\tif (uri.find(\"../\") != std::string::npos)\n\t\treturn NULL;\n\tstd::string path = baseDiskPath + uri;\n\tResource* res = NULL;\n\tstruct stat sb;\n\tif (stat(path.c_str(), &sb) == -1)\n\t\treturn NULL; \n\tif (sb.st_mode & S_IFDIR) { \n\t\tres = readDirectory(path, sb);\n\t} else if (sb.st_mode & S_IFREG) { \n\t\tres = readFile(path, sb);\n\t} else { \n\t\treturn NULL;\n\t}\n\treturn res;\n}", "target": 0}
{"code": "int snd_ctl_add(struct snd_card *card, struct snd_kcontrol *kcontrol)\n{\n\tstruct snd_ctl_elem_id id;\n\tunsigned int idx;\n\tunsigned int count;\n\tint err = -EINVAL;\n\tif (! kcontrol)\n\t\treturn err;\n\tif (snd_BUG_ON(!card || !kcontrol->info))\n\t\tgoto error;\n\tid = kcontrol->id;\n\tif (id.index > UINT_MAX - kcontrol->count)\n\t\tgoto error;\n\tdown_write(&card->controls_rwsem);\n\tif (snd_ctl_find_id(card, &id)) {\n\t\tup_write(&card->controls_rwsem);\n\t\tdev_err(card->dev, \"control %i:%i:%i:%s:%i is already present\\n\",\n\t\t\t\t\tid.iface,\n\t\t\t\t\tid.device,\n\t\t\t\t\tid.subdevice,\n\t\t\t\t\tid.name,\n\t\t\t\t\tid.index);\n\t\terr = -EBUSY;\n\t\tgoto error;\n\t}\n\tif (snd_ctl_find_hole(card, kcontrol->count) < 0) {\n\t\tup_write(&card->controls_rwsem);\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\tlist_add_tail(&kcontrol->list, &card->controls);\n\tcard->controls_count += kcontrol->count;\n\tkcontrol->id.numid = card->last_numid + 1;\n\tcard->last_numid += kcontrol->count;\n\tcount = kcontrol->count;\n\tup_write(&card->controls_rwsem);\n\tfor (idx = 0; idx < count; idx++, id.index++, id.numid++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_ADD, &id);\n\treturn 0;\n error:\n\tsnd_ctl_free_one(kcontrol);\n\treturn err;\n}", "target": 0}
{"code": "njs_promise_perform_any_handler(njs_vm_t *vm, njs_iterator_args_t *args,\n    njs_value_t *value, int64_t index)\n{\n    njs_int_t                    ret;\n    njs_array_t                  *array;\n    njs_value_t                  arguments[2], next;\n    njs_function_t               *on_rejected;\n    njs_promise_capability_t     *capability;\n    njs_promise_all_context_t    *context;\n    njs_promise_iterator_args_t  *pargs;\n    if (!njs_is_valid(value)) {\n        value = njs_value_arg(&njs_value_undefined);\n    }\n    pargs = (njs_promise_iterator_args_t *) args;\n    capability = pargs->capability;\n    array = pargs->args.data;\n    njs_set_undefined(&array->start[index]);\n    ret = njs_function_call(vm, pargs->function, pargs->constructor, value, 1,\n                            &next);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n    on_rejected = njs_promise_create_function(vm,\n                                            sizeof(njs_promise_all_context_t));\n    if (njs_slow_path(on_rejected == NULL)) {\n        return NJS_ERROR;\n    }\n    on_rejected->u.native = njs_promise_any_reject_element_functions;\n    on_rejected->args_count = 1;\n    context = on_rejected->context;\n    context->already_called = 0;\n    context->index = (uint32_t) index;\n    context->values = pargs->args.data;\n    context->capability = capability;\n    context->remaining_elements = pargs->remaining;\n    (*pargs->remaining)++;\n    arguments[0] = capability->resolve;\n    njs_set_function(&arguments[1], on_rejected);\n    ret = njs_promise_invoke_then(vm, &next, arguments, 2);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n    return NJS_OK;\n}", "target": 0}
{"code": "create_durable_v2_buf(struct cifs_open_parms *oparms)\n{\n\tstruct cifs_fid *pfid = oparms->fid;\n\tstruct create_durable_v2 *buf;\n\tbuf = kzalloc(sizeof(struct create_durable_v2), GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\tbuf->ccontext.DataOffset = cpu_to_le16(offsetof\n\t\t\t\t\t(struct create_durable_v2, dcontext));\n\tbuf->ccontext.DataLength = cpu_to_le32(sizeof(struct durable_context_v2));\n\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof\n\t\t\t\t(struct create_durable_v2, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\tbuf->dcontext.Timeout = cpu_to_le32(oparms->tcon->handle_timeout);\n\tbuf->dcontext.Flags = cpu_to_le32(SMB2_DHANDLE_FLAG_PERSISTENT);\n\tgenerate_random_uuid(buf->dcontext.CreateGuid);\n\tmemcpy(pfid->create_guid, buf->dcontext.CreateGuid, 16);\n\tbuf->Name[0] = 'D';\n\tbuf->Name[1] = 'H';\n\tbuf->Name[2] = '2';\n\tbuf->Name[3] = 'Q';\n\treturn buf;\n}", "target": 0}
{"code": "void read_pcm_samples_internal(thread_context* tctx, int x0, int y0, int log2CbSize,\n                               int cIdx, bitreader& br)\n{\n  const seq_parameter_set& sps = tctx->img->get_sps();\n  int nPcmBits;\n  int bitDepth;\n  int w = 1<<log2CbSize;\n  int h = 1<<log2CbSize;\n  if (cIdx>0) {\n    w /= sps.SubWidthC;\n    h /= sps.SubHeightC;\n    x0 /= sps.SubWidthC;\n    y0 /= sps.SubHeightC;\n    nPcmBits = sps.pcm_sample_bit_depth_chroma;\n    bitDepth = sps.BitDepth_C;\n  }\n  else {\n    nPcmBits = sps.pcm_sample_bit_depth_luma;\n    bitDepth = sps.BitDepth_Y;\n  }\n  pixel_t* ptr;\n  int stride;\n  ptr    = tctx->img->get_image_plane_at_pos_NEW<pixel_t>(cIdx,x0,y0);\n  stride = tctx->img->get_image_stride(cIdx);\n  int shift = bitDepth - nPcmBits;\n  if (shift < 0) {\n    shift=0;\n  }\n  for (int y=0;y<h;y++)\n    for (int x=0;x<w;x++)\n      {\n        int value = get_bits(&br, nPcmBits);\n        ptr[y*stride+x] = value << shift;\n      }\n}", "target": 0}
{"code": "SslSocket::create(Envoy::Ssl::ContextSharedPtr ctx, InitialState state,\n                  const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options,\n                  Ssl::HandshakerFactoryCb handshaker_factory_cb) {\n  std::unique_ptr<SslSocket> socket(new SslSocket(ctx, transport_socket_options));\n  auto status = socket->initialize(state, handshaker_factory_cb);\n  if (status.ok()) {\n    return socket;\n  } else {\n    return status;\n  }\n}", "target": 0}
{"code": "static int read_exceptions(struct pstore *ps,\n\t\t\t   int (*callback)(void *callback_context, chunk_t old,\n\t\t\t\t\t   chunk_t new),\n\t\t\t   void *callback_context)\n{\n\tint r, full = 1;\n\tfor (ps->current_area = 0; full; ps->current_area++) {\n\t\tr = area_io(ps, READ);\n\t\tif (r)\n\t\t\treturn r;\n\t\tr = insert_exceptions(ps, callback, callback_context, &full);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\tps->current_area--;\n\tskip_metadata(ps);\n\treturn 0;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& handle = ctx->input(0);\n    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(handle.shape()),\n                errors::InvalidArgument(\"`handle` must be scalar\"));\n    const string& name = handle.scalar<tstring>()();\n    auto session_state = ctx->session_state();\n    OP_REQUIRES(ctx, session_state != nullptr,\n                errors::FailedPrecondition(\n                    \"DeleteSessionTensor called on null session state\"));\n    OP_REQUIRES_OK(ctx, session_state->DeleteTensor(name));\n  }", "target": 0}
{"code": "int wc_SignatureGenerate(\n    enum wc_HashType hash_type, enum wc_SignatureType sig_type,\n    const byte* data, word32 data_len,\n    byte* sig, word32 *sig_len,\n    const void* key, word32 key_len, WC_RNG* rng)\n{\n    return wc_SignatureGenerate_ex(hash_type, sig_type, data, data_len, sig,\n        sig_len, key, key_len, rng, 1);\n}", "target": 0}
{"code": "void bpf_map_inc(struct bpf_map *map, bool uref)\n{\n\tatomic_inc(&map->refcnt);\n\tif (uref)\n\t\tatomic_inc(&map->usercnt);\n}", "target": 1}
{"code": "static int secure_decrypt(void *data, unsigned int data_length, int is_signed)\n{\n\tat91_aes_key_size_t key_size;\n\tunsigned int computed_cmac[AT91_AES_BLOCK_SIZE_WORD];\n\tunsigned int fixed_length;\n\tconst unsigned int *cmac;\n\tint rc = -1;\n#if defined(CONFIG_AES_KEY_SIZE_128)\n\tkey_size = AT91_AES_KEY_SIZE_128;\n#elif defined(CONFIG_AES_KEY_SIZE_192)\n\tkey_size = AT91_AES_KEY_SIZE_192;\n#elif defined(CONFIG_AES_KEY_SIZE_256)\n\tkey_size = AT91_AES_KEY_SIZE_256;\n#else\n#error \"bad AES key size\"\n#endif\n\tat91_aes_init();\n\tif (is_signed) {\n\t\tif (at91_aes_cmac(data_length, data, computed_cmac,\n\t\t\t\t  key_size, cmac_key))\n\t\t\tgoto exit;\n\t\tfixed_length = at91_aes_roundup(data_length);\n\t\tcmac = (const unsigned int *)((char *)data + fixed_length);\n\t\tif (!consttime_memequal(cmac, computed_cmac, AT91_AES_BLOCK_SIZE_BYTE))\n\t\t\tgoto exit;\n\t}\n\tif (at91_aes_cbc(data_length, data, data, 0,\n\t\t\t key_size, cipher_key, iv))\n\t\tgoto exit;\n\trc = 0;\nexit:\n\tat91_aes_cleanup();\n\treturn rc;\n}", "target": 0}
{"code": "  void initialize() override {\n    use_lds_ = false;\n    test_skipped_ = false;\n    setUpstreamCount(1);                         \n    setUpstreamProtocol(Http::CodecType::HTTP2); \n    defer_listener_finalization_ = true;\n    HttpIntegrationTest::initialize();\n    addFakeUpstream(Http::CodecType::HTTP2);\n    addFakeUpstream(Http::CodecType::HTTP2);\n    cluster1_ = ConfigHelper::buildStaticCluster(\n        ClusterName1, fake_upstreams_[UpstreamIndex1]->localAddress()->ip()->port(),\n        Network::Test::getLoopbackAddressString(ipVersion()));\n    cluster2_ = ConfigHelper::buildStaticCluster(\n        ClusterName2, fake_upstreams_[UpstreamIndex2]->localAddress()->ip()->port(),\n        Network::Test::getLoopbackAddressString(ipVersion()));\n    acceptXdsConnection();\n    EXPECT_TRUE(compareDiscoveryRequest(Config::TypeUrl::get().Cluster, \"\", {}, {}, {}, true));\n    sendDiscoveryResponse<envoy::config::cluster::v3::Cluster>(Config::TypeUrl::get().Cluster,\n                                                               {cluster1_}, {cluster1_}, {}, \"55\");\n    test_server_->waitForGaugeGe(\"cluster_manager.active_clusters\", 2);\n    test_server_->waitUntilListenersReady();\n    registerTestServerPorts({\"http\"});\n  }", "target": 1}
{"code": "decrypt(gcry_mpi_t output, gcry_mpi_t a, gcry_mpi_t b, ELG_secret_key *skey )\n{\n  gcry_mpi_t t1, t2, r;\n  unsigned int nbits = mpi_get_nbits (skey->p);\n  mpi_normalize (a);\n  mpi_normalize (b);\n  t1 = mpi_snew (nbits);\n#ifdef USE_BLINDING\n  t2 = mpi_snew (nbits);\n  r  = mpi_new (nbits);\n  _gcry_mpi_randomize (r, nbits, GCRY_WEAK_RANDOM);\n  mpi_powm (t1, r, skey->x, skey->p);\n  mpi_mulm (t2, a, r, skey->p);\n  mpi_powm (t2, t2, skey->x, skey->p);\n  mpi_invm (t2, t2, skey->p);\n  mpi_mulm (t1, t1, t2, skey->p);\n  mpi_free (r);\n  mpi_free (t2);\n#else \n  mpi_powm (t1, a, skey->x, skey->p);\n  mpi_invm (t1, t1, skey->p);\n#endif \n  mpi_mulm (output, b, t1, skey->p);\n#if 0\n  if( DBG_CIPHER )\n    {\n      log_mpidump(\"elg decrypted x= \", skey->x);\n      log_mpidump(\"elg decrypted p= \", skey->p);\n      log_mpidump(\"elg decrypted a= \", a);\n      log_mpidump(\"elg decrypted b= \", b);\n      log_mpidump(\"elg decrypted M= \", output);\n    }\n#endif\n  mpi_free (t1);\n}", "target": 0}
{"code": "get_matching_model_microcode(int cpu, unsigned long start,\n\t\t\t     void *data, size_t size,\n\t\t\t     struct mc_saved_data *mc_saved_data,\n\t\t\t     unsigned long *mc_saved_in_initrd,\n\t\t\t     struct ucode_cpu_info *uci)\n{\n\tu8 *ucode_ptr = data;\n\tunsigned int leftover = size;\n\tenum ucode_state state = UCODE_OK;\n\tunsigned int mc_size;\n\tstruct microcode_header_intel *mc_header;\n\tstruct microcode_intel *mc_saved_tmp[MAX_UCODE_COUNT];\n\tunsigned int mc_saved_count = mc_saved_data->mc_saved_count;\n\tint i;\n\twhile (leftover) {\n\t\tmc_header = (struct microcode_header_intel *)ucode_ptr;\n\t\tmc_size = get_totalsize(mc_header);\n\t\tif (!mc_size || mc_size > leftover ||\n\t\t\tmicrocode_sanity_check(ucode_ptr, 0) < 0)\n\t\t\tbreak;\n\t\tleftover -= mc_size;\n\t\tif (matching_model_microcode(mc_header, uci->cpu_sig.sig) !=\n\t\t\t UCODE_OK) {\n\t\t\tucode_ptr += mc_size;\n\t\t\tcontinue;\n\t\t}\n\t\t_save_mc(mc_saved_tmp, ucode_ptr, &mc_saved_count);\n\t\tucode_ptr += mc_size;\n\t}\n\tif (leftover) {\n\t\tstate = UCODE_ERROR;\n\t\tgoto out;\n\t}\n\tif (mc_saved_count == 0) {\n\t\tstate = UCODE_NFOUND;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < mc_saved_count; i++)\n\t\tmc_saved_in_initrd[i] = (unsigned long)mc_saved_tmp[i] - start;\n\tmc_saved_data->mc_saved_count = mc_saved_count;\nout:\n\treturn state;\n}", "target": 1}
{"code": "void ping_unhash(struct sock *sk)\n{\n\tstruct inet_sock *isk = inet_sk(sk);\n\tpr_debug(\"ping_unhash(isk=%p,isk->num=%u)\\n\", isk, isk->inet_num);\n\twrite_lock_bh(&ping_table.lock);\n\tif (sk_hashed(sk)) {\n\t\thlist_nulls_del(&sk->sk_nulls_node);\n\t\tsk_nulls_node_init(&sk->sk_nulls_node);\n\t\tsock_put(sk);\n\t\tisk->inet_num = 0;\n\t\tisk->inet_sport = 0;\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\t}\n\twrite_unlock_bh(&ping_table.lock);\n}", "target": 0}
{"code": "absl::Status SslSocket::initialize(InitialState state,\n                                   Ssl::HandshakerFactoryCb handshaker_factory_cb) {\n  auto status_or_ssl = ctx_->newSsl(transport_socket_options_);\n  if (!status_or_ssl.ok()) {\n    return status_or_ssl.status();\n  }\n  info_ = std::dynamic_pointer_cast<SslHandshakerImpl>(handshaker_factory_cb(\n      std::move(status_or_ssl.value()), ctx_->sslExtendedSocketInfoIndex(), this));\n  if (state == InitialState::Client) {\n    SSL_set_connect_state(rawSsl());\n  } else {\n    ASSERT(state == InitialState::Server);\n    SSL_set_accept_state(rawSsl());\n  }\n  return absl::OkStatus();\n}", "target": 0}
{"code": "check_mul_overflow(size_t a, size_t b, size_t* res)\n{\n    size_t tmp = a * b;\n    if (a != 0 && tmp / a != b) return 1;\n    *res = tmp;\n    return 0;\n}", "target": 0}
{"code": "static void coroutine_fn v9fs_getattr(void *opaque)\n{\n    int32_t fid;\n    size_t offset = 7;\n    ssize_t retval = 0;\n    struct stat stbuf;\n    V9fsFidState *fidp;\n    uint64_t request_mask;\n    V9fsStatDotl v9stat_dotl;\n    V9fsPDU *pdu = opaque;\n    retval = pdu_unmarshal(pdu, offset, \"dq\", &fid, &request_mask);\n    if (retval < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_getattr(pdu->tag, pdu->id, fid, request_mask);\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        retval = -ENOENT;\n        goto out_nofid;\n    }\n    retval = v9fs_co_lstat(pdu, &fidp->path, &stbuf);\n    if (retval < 0) {\n        goto out;\n    }\n    retval = stat_to_v9stat_dotl(pdu, &stbuf, &v9stat_dotl);\n    if (retval < 0) {\n        goto out;\n    }\n    if (request_mask & P9_STATS_GEN) {\n        retval = v9fs_co_st_gen(pdu, &fidp->path, stbuf.st_mode, &v9stat_dotl);\n        switch (retval) {\n        case 0:\n            v9stat_dotl.st_result_mask |= P9_STATS_GEN;\n            break;\n        case -EINTR:\n            goto out;\n        default:\n            break;\n        }\n    }\n    retval = pdu_marshal(pdu, offset, \"A\", &v9stat_dotl);\n    if (retval < 0) {\n        goto out;\n    }\n    retval += offset;\n    trace_v9fs_getattr_return(pdu->tag, pdu->id, v9stat_dotl.st_result_mask,\n                              v9stat_dotl.st_mode, v9stat_dotl.st_uid,\n                              v9stat_dotl.st_gid);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, retval);\n}", "target": 0}
{"code": "static void oz_usb_handle_ep_data(struct oz_usb_ctx *usb_ctx,\n\tstruct oz_usb_hdr *usb_hdr, int len)\n{\n\tstruct oz_data *data_hdr = (struct oz_data *)usb_hdr;\n\tswitch (data_hdr->format) {\n\tcase OZ_DATA_F_MULTIPLE_FIXED: {\n\t\t\tstruct oz_multiple_fixed *body =\n\t\t\t\t(struct oz_multiple_fixed *)data_hdr;\n\t\t\tu8 *data = body->data;\n\t\t\tunsigned int n;\n\t\t\tif (!body->unit_size ||\n\t\t\t\tlen < sizeof(struct oz_multiple_fixed) - 1)\n\t\t\t\tbreak;\n\t\t\tn = (len - (sizeof(struct oz_multiple_fixed) - 1))\n\t\t\t\t/ body->unit_size;\n\t\t\twhile (n--) {\n\t\t\t\toz_hcd_data_ind(usb_ctx->hport, body->endpoint,\n\t\t\t\t\tdata, body->unit_size);\n\t\t\t\tdata += body->unit_size;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase OZ_DATA_F_ISOC_FIXED: {\n\t\t\tstruct oz_isoc_fixed *body =\n\t\t\t\t(struct oz_isoc_fixed *)data_hdr;\n\t\t\tint data_len = len-sizeof(struct oz_isoc_fixed)+1;\n\t\t\tint unit_size = body->unit_size;\n\t\t\tu8 *data = body->data;\n\t\t\tint count;\n\t\t\tint i;\n\t\t\tif (!unit_size)\n\t\t\t\tbreak;\n\t\t\tcount = data_len/unit_size;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\toz_hcd_data_ind(usb_ctx->hport,\n\t\t\t\t\tbody->endpoint, data, unit_size);\n\t\t\t\tdata += unit_size;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "flatpak_context_set_persistent (FlatpakContext *context,\n                                const char     *path)\n{\n  g_hash_table_insert (context->persistent, g_strdup (path), GINT_TO_POINTER (1));\n}", "target": 1}
{"code": "static int install_relocation_handler(int num_cpus, size_t save_state_size)\n{\n\tstruct smm_loader_params smm_params = {\n\t\t.per_cpu_stack_size = CONFIG_SMM_STUB_STACK_SIZE,\n\t\t.num_concurrent_stacks = num_cpus,\n\t\t.per_cpu_save_state_size = save_state_size,\n\t\t.num_concurrent_save_states = 1,\n\t\t.handler = smm_do_relocation,\n\t};\n\tif (mp_state.ops.adjust_smm_params != NULL)\n\t\tmp_state.ops.adjust_smm_params(&smm_params, 0);\n\tif (smm_setup_relocation_handler(&smm_params))\n\t\treturn -1;\n\tadjust_smm_apic_id_map(&smm_params);\n\treturn 0;\n}", "target": 1}
{"code": "static gboolean printable_str(const char *str)\n{\n    do {\n        if ((unsigned char)(*str) < ' ' || *str == 0x7f)\n            return FALSE;\n        str++;\n    } while (*str);\n    return TRUE;\n}", "target": 1}
{"code": "init_resources(X509 *x509, enum rpki_policy policy, enum cert_type type,\n    struct resources **_result)\n{\n\tstruct resources *result;\n\tint error;\n\tresult = resources_create(false);\n\tif (result == NULL)\n\t\treturn pr_enomem();\n\tresources_set_policy(result, policy);\n\terror = certificate_get_resources(x509, result, type);\n\tif (error)\n\t\tgoto fail;\n\tif (type == TA && resources_empty(result)) {\n\t\terror = pr_val_err(\"Trust Anchor certificate does not define any number resources.\");\n\t\tgoto fail;\n\t}\n\t*_result = result;\n\treturn 0;\nfail:\n\tresources_destroy(result);\n\treturn error;\n}", "target": 0}
{"code": "static int mct_u232_port_probe(struct usb_serial_port *port)\n{\n\tstruct mct_u232_private *priv;\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tpriv->read_urb = port->serial->port[1]->interrupt_in_urb;\n\tpriv->read_urb->context = port;\n\tspin_lock_init(&priv->lock);\n\tusb_set_serial_port_data(port, priv);\n\treturn 0;\n}", "target": 1}
{"code": "static int rds_ib_laddr_check(__be32 addr)\n{\n\tint ret;\n\tstruct rdma_cm_id *cm_id;\n\tstruct sockaddr_in sin;\n\tcm_id = rdma_create_id(NULL, NULL, RDMA_PS_TCP, IB_QPT_RC);\n\tif (IS_ERR(cm_id))\n\t\treturn PTR_ERR(cm_id);\n\tmemset(&sin, 0, sizeof(sin));\n\tsin.sin_family = AF_INET;\n\tsin.sin_addr.s_addr = addr;\n\tret = rdma_bind_addr(cm_id, (struct sockaddr *)&sin);\n\tif (ret || cm_id->device->node_type != RDMA_NODE_IB_CA)\n\t\tret = -EADDRNOTAVAIL;\n\trdsdebug(\"addr %pI4 ret %d node type %d\\n\",\n\t\t&addr, ret,\n\t\tcm_id->device ? cm_id->device->node_type : -1);\n\trdma_destroy_id(cm_id);\n\treturn ret;\n}", "target": 1}
{"code": "void lcdSetPixels_ArrayBuffer_flat(JsGraphics *gfx, short x, short y, short pixelCount, unsigned int col) {\n  unsigned char *ptr = (unsigned char*)gfx->backendData;\n  unsigned int idx = lcdGetPixelIndex_ArrayBuffer(gfx,x,y,pixelCount);\n  ptr += idx>>3;\n  unsigned int whiteMask = (1U<<gfx->data.bpp)-1;\n  bool shortCut = (col==0 || (col&whiteMask)==whiteMask) && (!(gfx->data.flags&JSGRAPHICSFLAGS_ARRAYBUFFER_VERTICAL_BYTE)); \n  while (pixelCount--) { \n    if (gfx->data.bpp&7) {\n      idx = idx & 7;\n      if (shortCut && idx==0) {\n        int wholeBytes = (gfx->data.bpp*(pixelCount+1)) >> 3;\n        if (wholeBytes) {\n          char c = (char)(col?0xFF:0);\n          pixelCount = (short)(pixelCount+1 - (wholeBytes*8/gfx->data.bpp));\n          while (wholeBytes--) {\n            *ptr = c;\n            ptr++;\n          }\n          continue;\n        }\n      }\n      unsigned int mask = (unsigned int)(1<<gfx->data.bpp)-1;\n      unsigned int existing = (unsigned int)*ptr;\n      unsigned int bitIdx = (gfx->data.flags & JSGRAPHICSFLAGS_ARRAYBUFFER_MSB) ? 8-(idx+gfx->data.bpp) : idx;\n      assert(ptr>=gfx->backendData && ptr<((char*)gfx->backendData + graphicsGetMemoryRequired(gfx)));\n      *ptr = (char)((existing&~(mask<<bitIdx)) | ((col&mask)<<bitIdx));\n      if (gfx->data.flags & JSGRAPHICSFLAGS_ARRAYBUFFER_VERTICAL_BYTE) {\n        ptr++;\n      } else {\n        idx += gfx->data.bpp;\n        if (idx>=8) ptr++;\n      }\n    } else { \n      int i;\n      for (i=0;i<gfx->data.bpp;i+=8) {\n        *ptr = (char)(col >> i);\n        ptr++;\n      }\n    }\n  }\n}", "target": 0}
{"code": "static int io_rw_init_file(struct io_kiocb *req, fmode_t mode)\n{\n\tstruct kiocb *kiocb = &req->rw.kiocb;\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct file *file = req->file;\n\tint ret;\n\tif (unlikely(!file || !(file->f_mode & mode)))\n\t\treturn -EBADF;\n\tif (!io_req_ffs_set(req))\n\t\treq->flags |= io_file_get_flags(file) << REQ_F_SUPPORT_NOWAIT_BIT;\n\tkiocb->ki_flags = iocb_flags(file);\n\tret = kiocb_set_rw_flags(kiocb, req->rw.flags);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tif ((kiocb->ki_flags & IOCB_NOWAIT) ||\n\t    ((file->f_flags & O_NONBLOCK) && !io_file_supports_nowait(req)))\n\t\treq->flags |= REQ_F_NOWAIT;\n\tif (ctx->flags & IORING_SETUP_IOPOLL) {\n\t\tif (!(kiocb->ki_flags & IOCB_DIRECT) || !file->f_op->iopoll)\n\t\t\treturn -EOPNOTSUPP;\n\t\tkiocb->private = NULL;\n\t\tkiocb->ki_flags |= IOCB_HIPRI | IOCB_ALLOC_CACHE;\n\t\tkiocb->ki_complete = io_complete_rw_iopoll;\n\t\treq->iopoll_completed = 0;\n\t} else {\n\t\tif (kiocb->ki_flags & IOCB_HIPRI)\n\t\t\treturn -EINVAL;\n\t\tkiocb->ki_complete = io_complete_rw;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "router_get_hashes_impl(const char *s, size_t s_len, digests_t *digests,\n                       const char *start_str,\n                       const char *end_str, char end_c)\n{\n  const char *start=NULL, *end=NULL;\n  if (router_get_hash_impl_helper(s,s_len,start_str,end_str,end_c,\n                                  &start,&end)<0)\n    return -1;\n  if (crypto_digest_all(digests, start, end-start)) {\n    log_warn(LD_BUG,\"couldn't compute digests\");\n    return -1;\n  }\n  return 0;\n}", "target": 0}
{"code": "int mem_check_range(struct rxe_mem *mem, u64 iova, size_t length)\n{\n\tswitch (mem->type) {\n\tcase RXE_MEM_TYPE_DMA:\n\t\treturn 0;\n\tcase RXE_MEM_TYPE_MR:\n\tcase RXE_MEM_TYPE_FMR:\n\t\treturn ((iova < mem->iova) ||\n\t\t\t((iova + length) > (mem->iova + mem->length))) ?\n\t\t\t-EFAULT : 0;\n\tdefault:\n\t\treturn -EFAULT;\n\t}\n}", "target": 1}
{"code": "Status BuildXlaCompilationCache(DeviceBase* device, FunctionLibraryRuntime* flr,\n                                const XlaPlatformInfo& platform_info,\n                                XlaCompilationCache** cache) {\n  if (platform_info.xla_device_metadata()) {\n    *cache = new XlaCompilationCache(\n        platform_info.xla_device_metadata()->client(),\n        platform_info.xla_device_metadata()->jit_device_type());\n    return Status::OK();\n  }\n  auto platform =\n      se::MultiPlatformManager::PlatformWithId(platform_info.platform_id());\n  if (!platform.ok()) {\n    return platform.status();\n  }\n  StatusOr<xla::Compiler*> compiler_for_platform =\n      xla::Compiler::GetForPlatform(platform.ValueOrDie());\n  if (!compiler_for_platform.ok()) {\n    const Status& status = compiler_for_platform.status();\n    if (status.code() == error::NOT_FOUND) {\n      return errors::Unimplemented(\"Could not find compiler for platform \",\n                                   platform.ValueOrDie()->Name(), \": \",\n                                   status.ToString());\n    }\n  }\n  xla::LocalClientOptions client_options;\n  client_options.set_platform(platform.ValueOrDie());\n  client_options.set_intra_op_parallelism_threads(\n      device->tensorflow_cpu_worker_threads()->num_threads);\n  string allowed_gpus =\n      flr->config_proto()->gpu_options().visible_device_list();\n  TF_ASSIGN_OR_RETURN(absl::optional<std::set<int>> gpu_ids,\n                      ParseVisibleDeviceList(allowed_gpus));\n  client_options.set_allowed_devices(gpu_ids);\n  auto client = xla::ClientLibrary::GetOrCreateLocalClient(client_options);\n  if (!client.ok()) {\n    return client.status();\n  }\n  const XlaOpRegistry::DeviceRegistration* registration;\n  if (!XlaOpRegistry::GetCompilationDevice(platform_info.device_type().type(),\n                                           &registration)) {\n    return errors::InvalidArgument(\"No JIT device registered for \",\n                                   platform_info.device_type().type());\n  }\n  *cache = new XlaCompilationCache(\n      client.ValueOrDie(), DeviceType(registration->compilation_device_name));\n  return Status::OK();\n}", "target": 1}
{"code": "static void initialize_typed_array_from_array_buffer(GlobalObject& global_object, TypedArrayBase& typed_array, ArrayBuffer& array_buffer, Value byte_offset, Value length)\n{\n    auto& vm = global_object.vm();\n    auto element_size = typed_array.element_size();\n    auto offset = byte_offset.to_index(global_object);\n    if (vm.exception())\n        return;\n    if (offset % element_size != 0) {\n        vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayInvalidByteOffset, typed_array.class_name(), element_size, offset);\n        return;\n    }\n    size_t new_length { 0 };\n    if (!length.is_undefined()) {\n        new_length = length.to_index(global_object);\n        if (vm.exception())\n            return;\n    }\n    auto buffer_byte_length = array_buffer.byte_length();\n    size_t new_byte_length;\n    if (length.is_undefined()) {\n        if (buffer_byte_length % element_size != 0) {\n            vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayInvalidBufferLength, typed_array.class_name(), element_size, buffer_byte_length);\n            return;\n        }\n        if (offset > buffer_byte_length) {\n            vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayOutOfRangeByteOffset, offset, buffer_byte_length);\n            return;\n        }\n        new_byte_length = buffer_byte_length - offset;\n    } else {\n        new_byte_length = new_length * element_size;\n        if (offset + new_byte_length > buffer_byte_length) {\n            vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayOutOfRangeByteOffsetOrLength, offset, offset + new_byte_length, buffer_byte_length);\n            return;\n        }\n    }\n    typed_array.set_viewed_array_buffer(&array_buffer);\n    typed_array.set_byte_length(new_byte_length);\n    typed_array.set_byte_offset(offset);\n    typed_array.set_array_length(new_byte_length / element_size);\n}", "target": 1}
{"code": "static bool check_underflow(const struct ip6t_entry *e)\n{\n\tconst struct xt_entry_target *t;\n\tunsigned int verdict;\n\tif (!unconditional(&e->ipv6))\n\t\treturn false;\n\tt = ip6t_get_target_c(e);\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\n\t\treturn false;\n\tverdict = ((struct xt_standard_target *)t)->verdict;\n\tverdict = -verdict - 1;\n\treturn verdict == NF_DROP || verdict == NF_ACCEPT;\n}", "target": 1}
{"code": "static inline void o2nm_unlock_subsystem(void)\n{\n\tmutex_unlock(&o2nm_cluster_group.cs_subsys.su_mutex);\n}", "target": 0}
{"code": "static long gethugepagesize(const char *path, Error **errp)\n{\n    struct statfs fs;\n    int ret;\n    do {\n        ret = statfs(path, &fs);\n    } while (ret != 0 && errno == EINTR);\n    if (ret != 0) {\n        error_setg_errno(errp, errno, \"failed to get page size of file %s\",\n                         path);\n        return 0;\n    }\n    if (fs.f_type != HUGETLBFS_MAGIC)\n        fprintf(stderr, \"Warning: path not on HugeTLBFS: %s\\n\", path);\n    return fs.f_bsize;\n}", "target": 0}
{"code": "static void _clean_slate_datagram(gnrc_sixlowpan_frag_fb_t *fbuf)\n{\n    clist_node_t new_queue = { .next = NULL };\n    fbuf->sfr.arq_timeout_event.msg.content.ptr = NULL;\n    evtimer_del((evtimer_t *)(&_arq_timer),\n                &fbuf->sfr.arq_timeout_event.event);\n    fbuf->sfr.arq_timeout_event.event.next = NULL;\n    if (gnrc_sixlowpan_frag_sfr_congure_snd_has_inter_frame_gap()) {\n        for (clist_node_t *node = clist_lpop(&_frame_queue);\n             node != NULL; node = clist_lpop(&_frame_queue)) {\n            _frame_queue_t *entry = (_frame_queue_t *)node;\n            if (entry->datagram_tag == fbuf->tag) {\n                gnrc_pktbuf_release(entry->frame);\n                entry->frame = NULL;\n                clist_rpush(&_frag_descs_free, node);\n            }\n            else {\n                clist_rpush(&new_queue, node);\n            }\n        }\n        _frame_queue = new_queue;\n    }\n    fbuf->offset = 0U;\n    fbuf->sfr.cur_seq = 0U;\n    fbuf->sfr.frags_sent = 0U;\n    for (clist_node_t *node = clist_lpop(&fbuf->sfr.window);\n         node != NULL; node = clist_lpop(&fbuf->sfr.window)) {\n        clist_rpush(&_frag_descs_free, node);\n    }\n}", "target": 1}
{"code": "smb2_query_eas(const unsigned int xid, struct cifs_tcon *tcon,\n\t       const unsigned char *path, const unsigned char *ea_name,\n\t       char *ea_data, size_t buf_size,\n\t       struct cifs_sb_info *cifs_sb)\n{\n\tint rc;\n\tstruct kvec rsp_iov = {NULL, 0};\n\tint buftype = CIFS_NO_BUFFER;\n\tstruct smb2_query_info_rsp *rsp;\n\tstruct smb2_file_full_ea_info *info = NULL;\n\trc = smb2_query_info_compound(xid, tcon, path,\n\t\t\t\t      FILE_READ_EA,\n\t\t\t\t      FILE_FULL_EA_INFORMATION,\n\t\t\t\t      SMB2_O_INFO_FILE,\n\t\t\t\t      CIFSMaxBufSize -\n\t\t\t\t      MAX_SMB2_CREATE_RESPONSE_SIZE -\n\t\t\t\t      MAX_SMB2_CLOSE_RESPONSE_SIZE,\n\t\t\t\t      &rsp_iov, &buftype, cifs_sb);\n\tif (rc) {\n\t\tif (!ea_name && rc == -ENODATA)\n\t\t\trc = 0;\n\t\tgoto qeas_exit;\n\t}\n\trsp = (struct smb2_query_info_rsp *)rsp_iov.iov_base;\n\trc = smb2_validate_iov(le16_to_cpu(rsp->OutputBufferOffset),\n\t\t\t       le32_to_cpu(rsp->OutputBufferLength),\n\t\t\t       &rsp_iov,\n\t\t\t       sizeof(struct smb2_file_full_ea_info));\n\tif (rc)\n\t\tgoto qeas_exit;\n\tinfo = (struct smb2_file_full_ea_info *)(\n\t\t\tle16_to_cpu(rsp->OutputBufferOffset) + (char *)rsp);\n\trc = move_smb2_ea_to_cifs(ea_data, buf_size, info,\n\t\t\tle32_to_cpu(rsp->OutputBufferLength), ea_name);\n qeas_exit:\n\tfree_rsp_buf(buftype, rsp_iov.iov_base);\n\treturn rc;\n}", "target": 0}
{"code": "int use_conf(char *test_path)\n{\n    int ret;\n    size_t flags = 0;\n    char filename[1024], errstr[1024];\n    char *buffer;\n    FILE *infile, *conffile;\n    json_t *json;\n    json_error_t error;\n    sprintf(filename, \"%s%cinput\", test_path, dir_sep);\n    if (!(infile = fopen(filename, \"rb\"))) {\n        fprintf(stderr, \"Could not open \\\"%s\\\"\\n\", filename);\n        return 2;\n    }\n    sprintf(filename, \"%s%cenv\", test_path, dir_sep);\n    conffile = fopen(filename, \"rb\");\n    if (conffile) {\n        read_conf(conffile);\n        fclose(conffile);\n    }\n    if (conf.indent < 0 || conf.indent > 255) {\n        fprintf(stderr, \"invalid value for JSON_INDENT: %d\\n\", conf.indent);\n        return 2;\n    }\n    if (conf.indent)\n        flags |= JSON_INDENT(conf.indent);\n    if (conf.compact)\n        flags |= JSON_COMPACT;\n    if (conf.ensure_ascii)\n        flags |= JSON_ENSURE_ASCII;\n    if (conf.preserve_order)\n        flags |= JSON_PRESERVE_ORDER;\n    if (conf.sort_keys)\n        flags |= JSON_SORT_KEYS;\n    if (conf.have_hashseed)\n        json_object_seed(conf.hashseed);\n    if (conf.strip) {\n        buffer = loadfile(infile);\n        json = json_loads(strip(buffer), 0, &error);\n        free(buffer);\n    }\n    else\n        json = json_loadf(infile, 0, &error);\n    fclose(infile);\n    if (!json) {\n        sprintf(errstr, \"%d %d %d\\n%s\\n\",\n                error.line, error.column, error.position,\n                error.text);\n        ret = cmpfile(errstr, test_path, \"error\");\n        return ret;\n    }\n    buffer = json_dumps(json, flags);\n    ret = cmpfile(buffer, test_path, \"output\");\n    free(buffer);\n    json_decref(json);\n    return ret;\n}", "target": 0}
{"code": "void zrandmemberCommand(client *c) {\n    long l;\n    int withscores = 0;\n    robj *zset;\n    listpackEntry ele;\n    if (c->argc >= 3) {\n        if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;\n        if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"withscores\"))) {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return;\n        } else if (c->argc == 4)\n            withscores = 1;\n        zrandmemberWithCountCommand(c, l, withscores);\n        return;\n    }\n    if ((zset = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp]))== NULL ||\n        checkType(c,zset,OBJ_ZSET)) {\n        return;\n    }\n    zsetTypeRandomElement(zset, zsetLength(zset), &ele,NULL);\n    zsetReplyFromListpackEntry(c,&ele);\n}", "target": 1}
{"code": "sudo_lbuf_append_esc_v1(struct sudo_lbuf *lbuf, int flags, const char *fmt, ...)\n{\n    unsigned int saved_len = lbuf->len;\n    bool ret = false;\n    const char *s;\n    va_list ap;\n    debug_decl(sudo_lbuf_append_esc, SUDO_DEBUG_UTIL);\n    if (sudo_lbuf_error(lbuf))\n\tdebug_return_bool(false);\n#define should_escape(ch) \\\n    ((ISSET(flags, LBUF_ESC_CNTRL) && iscntrl((unsigned char)ch)) || \\\n    (ISSET(flags, LBUF_ESC_BLANK) && isblank((unsigned char)ch)))\n#define should_quote(ch) \\\n    (ISSET(flags, LBUF_ESC_QUOTE) && (ch == '\\'' || ch == '\\\\'))\n    va_start(ap, fmt);\n    while (*fmt != '\\0') {\n\tif (fmt[0] == '%' && fmt[1] == 's') {\n\t    if ((s = va_arg(ap, char *)) == NULL)\n\t\ts = \"(NULL)\";\n\t    while (*s != '\\0') {\n\t\tif (should_escape(*s)) {\n\t\t    if (!sudo_lbuf_expand(lbuf, sizeof(\"#0177\") - 1))\n\t\t\tgoto done;\n\t\t    lbuf->len += escape(*s++, lbuf->buf + lbuf->len);\n\t\t    continue;\n\t\t}\n\t\tif (should_quote(*s)) {\n\t\t    if (!sudo_lbuf_expand(lbuf, 2))\n\t\t\tgoto done;\n\t\t    lbuf->buf[lbuf->len++] = '\\\\';\n\t\t    lbuf->buf[lbuf->len++] = *s++;\n\t\t    continue;\n\t\t}\n\t\tif (!sudo_lbuf_expand(lbuf, 1))\n\t\t    goto done;\n\t\tlbuf->buf[lbuf->len++] = *s++;\n\t    }\n\t    fmt += 2;\n\t    continue;\n\t}\n\tif (should_escape(*fmt)) {\n\t    if (!sudo_lbuf_expand(lbuf, sizeof(\"#0177\") - 1))\n\t\tgoto done;\n\t    if (*fmt == '\\'') {\n\t\tlbuf->buf[lbuf->len++] = '\\\\';\n\t\tlbuf->buf[lbuf->len++] = *fmt++;\n\t    } else {\n\t\tlbuf->len += escape(*fmt++, lbuf->buf + lbuf->len);\n\t    }\n\t    continue;\n\t}\n\tif (!sudo_lbuf_expand(lbuf, 1))\n\t    goto done;\n\tlbuf->buf[lbuf->len++] = *fmt++;\n    }\n    ret = true;\ndone:\n    if (!ret)\n\tlbuf->len = saved_len;\n    if (lbuf->size != 0)\n\tlbuf->buf[lbuf->len] = '\\0';\n    va_end(ap);\n    debug_return_bool(ret);\n}", "target": 0}
{"code": "int secure_check(void *data)\n{\n\tconst at91_secure_header_t *header;\n\tvoid *file;\n\tif (secure_decrypt(data, sizeof(*header), 0))\n\t\treturn -1;\n\theader = (const at91_secure_header_t *)data;\n\tif (header->magic != AT91_SECURE_MAGIC)\n\t\treturn -1;\n\tfile = (unsigned char *)data + sizeof(*header);\n\treturn secure_decrypt(file, header->file_size, 1);\n}", "target": 1}
{"code": "bool IsConstantFoldable(\n    const Node* n,\n    const std::unordered_map<string, std::vector<PartialTensorShape>>*\n        shape_map,\n    const std::function<bool(const Node*)>& consider,\n    int64_t max_constant_size_in_bytes,\n    std::unordered_map<const Node*, std::vector<Tensor>>*\n        shape_replacement_map) {\n  if (n->IsConstant()) {\n    return true;\n  }\n  if (MaybeReplaceShapeOp(n, shape_map, shape_replacement_map)) {\n    return true;\n  }\n  if (n->op_def().is_stateful()) {\n    return false;\n  }\n  if (consider && !consider(n)) {\n    return false;\n  }\n  if (shape_map != nullptr) {\n    auto shape_it = shape_map->find(n->name());\n    if (shape_it != shape_map->end()) {\n      for (int64_t i = 0; i < shape_it->second.size(); ++i) {\n        const auto& out_shape = shape_it->second[i];\n        if (out_shape.IsFullyDefined() &&\n            out_shape.num_elements() * DataTypeSize(n->output_type(i)) >\n                max_constant_size_in_bytes) {\n          return false;\n        }\n      }\n    }\n  }\n  if (n->IsControlFlow() || n->IsSend() || n->IsRecv()) {\n    return false;\n  }\n  if (n->IsGetSessionHandle() || n->IsGetSessionTensor() ||\n      n->IsDeleteSessionTensor()) {\n    return false;\n  }\n  if (n->IsSource()) {\n    return false;\n  }\n  if (n->IsSink()) {\n    return false;\n  }\n  if (n->IsFakeParam()) {\n    return false;\n  }\n  if (!KernelDefAvailable(DeviceType(DEVICE_CPU), n->def())) {\n    return false;\n  }\n  if (n->attrs().Find(kScopedAllocatorAttrName) != nullptr) {\n    VLOG(2) << \"Skip node [\" << n->DebugString()\n            << \"] for constant folding due to scoped allocator\";\n    return false;\n  }\n  return true;\n}", "target": 1}
{"code": "struct mb2_cache *ext2_xattr_create_cache(void)\n{\n\treturn mb2_cache_create(HASH_BUCKET_BITS);\n}", "target": 0}
{"code": "relay_websocket_decode_frame (const unsigned char *buffer,\n                              unsigned long long buffer_length,\n                              unsigned char *decoded,\n                              unsigned long long *decoded_length)\n{\n    unsigned long long i, index_buffer, length_frame_size, length_frame;\n    unsigned char opcode;\n    *decoded_length = 0;\n    index_buffer = 0;\n    while (index_buffer + 1 < buffer_length)\n    {\n        opcode = buffer[index_buffer] & 15;\n        if (!(buffer[index_buffer + 1] & 128))\n            return 0;\n        length_frame_size = 1;\n        length_frame = buffer[index_buffer + 1] & 127;\n        index_buffer += 2;\n        if (index_buffer >= buffer_length)\n            return 0;\n        if ((length_frame == 126) || (length_frame == 127))\n        {\n            length_frame_size = (length_frame == 126) ? 2 : 8;\n            if (index_buffer + length_frame_size > buffer_length)\n                return 0;\n            length_frame = 0;\n            for (i = 0; i < length_frame_size; i++)\n            {\n                length_frame += (unsigned long long)buffer[index_buffer + i] << ((length_frame_size - i - 1) * 8);\n            }\n            index_buffer += length_frame_size;\n        }\n        if (index_buffer + 4 > buffer_length)\n            return 0;\n        int masks[4];\n        for (i = 0; i < 4; i++)\n        {\n            masks[i] = (int)((unsigned char)buffer[index_buffer + i]);\n        }\n        index_buffer += 4;\n        switch (opcode)\n        {\n            case WEBSOCKET_FRAME_OPCODE_PING:\n                decoded[*decoded_length] = RELAY_CLIENT_MSG_PING;\n                break;\n            case WEBSOCKET_FRAME_OPCODE_CLOSE:\n                decoded[*decoded_length] = RELAY_CLIENT_MSG_CLOSE;\n                break;\n            default:\n                decoded[*decoded_length] = RELAY_CLIENT_MSG_STANDARD;\n                break;\n        }\n        *decoded_length += 1;\n        if ((length_frame > buffer_length)\n            || (index_buffer + length_frame > buffer_length))\n        {\n            return 0;\n        }\n        for (i = 0; i < length_frame; i++)\n        {\n            decoded[*decoded_length + i] = (int)((unsigned char)buffer[index_buffer + i]) ^ masks[i % 4];\n        }\n        decoded[*decoded_length + length_frame] = '\\0';\n        *decoded_length += length_frame + 1;\n        index_buffer += length_frame;\n    }\n    return 1;\n}", "target": 0}
{"code": "static void *etm_setup_aux(int event_cpu, void **pages,\n\t\t\t   int nr_pages, bool overwrite)\n{\n\tint cpu;\n\tcpumask_t *mask;\n\tstruct coresight_device *sink;\n\tstruct etm_event_data *event_data = NULL;\n\tevent_data = alloc_event_data(event_cpu);\n\tif (!event_data)\n\t\treturn NULL;\n\tsink = coresight_get_enabled_sink(true);\n\tif (!sink)\n\t\tgoto err;\n\tINIT_WORK(&event_data->work, free_event_data);\n\tmask = &event_data->mask;\n\tfor_each_cpu(cpu, mask) {\n\t\tstruct coresight_device *csdev;\n\t\tcsdev = per_cpu(csdev_src, cpu);\n\t\tif (!csdev)\n\t\t\tgoto err;\n\t\tevent_data->path[cpu] = coresight_build_path(csdev, sink);\n\t\tif (IS_ERR(event_data->path[cpu]))\n\t\t\tgoto err;\n\t}\n\tif (!sink_ops(sink)->alloc_buffer)\n\t\tgoto err;\n\tcpu = cpumask_first(mask);\n\tevent_data->snk_config =\n\t\t\tsink_ops(sink)->alloc_buffer(sink, cpu, pages,\n\t\t\t\t\t\t     nr_pages, overwrite);\n\tif (!event_data->snk_config)\n\t\tgoto err;\nout:\n\treturn event_data;\nerr:\n\tetm_free_aux(event_data);\n\tevent_data = NULL;\n\tgoto out;\n}", "target": 0}
{"code": "static void nalm_dump(FILE * trace, char *data, u32 data_size)\n{\n\tGF_BitStream *bs;\n\tBool rle, large_size;\n\tu32 entry_count;\n\tif (!data) {\n\t\tfprintf(trace, \"<NALUMap rle=\\\"\\\" large_size=\\\"\\\">\\n\");\n\t\tfprintf(trace, \"<NALUMapEntry NALU_startNumber=\\\"\\\" groupID=\\\"\\\"/>\\n\");\n\t\tfprintf(trace, \"</NALUMap>\\n\");\n\t\treturn;\n\t}\n\tbs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\tgf_bs_read_int(bs, 6);\n\tlarge_size = gf_bs_read_int(bs, 1);\n\trle = gf_bs_read_int(bs, 1);\n\tentry_count = gf_bs_read_int(bs, large_size ? 16 : 8);\n\tfprintf(trace, \"<NALUMap rle=\\\"%d\\\" large_size=\\\"%d\\\">\\n\", rle, large_size);\n\twhile (entry_count) {\n\t\tu32 ID;\n\t\tfprintf(trace, \"<NALUMapEntry \");\n\t\tif (rle) {\n\t\t\tu32 start_num = gf_bs_read_int(bs, large_size ? 16 : 8);\n\t\t\tfprintf(trace, \"NALU_startNumber=\\\"%d\\\" \", start_num);\n\t\t}\n\t\tID = gf_bs_read_u16(bs);\n\t\tfprintf(trace, \"groupID=\\\"%d\\\"/>\\n\", ID);\n\t\tentry_count--;\n\t}\n\tgf_bs_del(bs);\n\tfprintf(trace, \"</NALUMap>\\n\");\n\treturn;\n}", "target": 1}
{"code": "asmlinkage long compat_sys_recvmmsg(int fd, struct compat_mmsghdr __user *mmsg,\n\t\t\t\t    unsigned int vlen, unsigned int flags,\n\t\t\t\t    struct compat_timespec __user *timeout)\n{\n\tint datagrams;\n\tstruct timespec ktspec;\n\tif (flags & MSG_CMSG_COMPAT)\n\t\treturn -EINVAL;\n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t      flags | MSG_CMSG_COMPAT,\n\t\t\t\t      (struct timespec *) timeout);\n\tif (timeout == NULL)\n\t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t      flags | MSG_CMSG_COMPAT, NULL);\n\tif (get_compat_timespec(&ktspec, timeout))\n\t\treturn -EFAULT;\n\tdatagrams = __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t   flags | MSG_CMSG_COMPAT, &ktspec);\n\tif (datagrams > 0 && put_compat_timespec(&ktspec, timeout))\n\t\tdatagrams = -EFAULT;\n\treturn datagrams;\n}", "target": 1}
{"code": "bool ContentSettingsObserver::AllowScript(bool enabled_per_settings) {\n  if (!enabled_per_settings)\n    return false;\n  if (IsScriptDisabledForPreview(render_frame()))\n    return false;\n  if (is_interstitial_page_)\n    return true;\n  blink::WebLocalFrame* frame = render_frame()->GetWebFrame();\n  const auto it = cached_script_permissions_.find(frame);\n  if (it != cached_script_permissions_.end())\n    return it->second;\n  bool allow = true;\n  if (content_setting_rules_) {\n    ContentSetting setting = GetContentSettingFromRules(\n        content_setting_rules_->script_rules, frame,\n        url::Origin(frame->GetDocument().GetSecurityOrigin()).GetURL());\n    allow = setting != CONTENT_SETTING_BLOCK;\n  }\n  allow = allow || IsWhitelistedForContentSettings();\n  cached_script_permissions_[frame] = allow;\n  return allow;\n}", "target": 1}
{"code": "static bool ndp_msg_check_valid(struct ndp_msg *msg)\n{\n\tsize_t len = ndp_msg_payload_len(msg);\n\tenum ndp_msg_type msg_type = ndp_msg_type(msg);\n\tif (len < ndp_msg_type_info(msg_type)->raw_struct_size)\n\t\treturn false;\n\treturn true;\n}", "target": 1}
{"code": "ikev1_sub_print(netdissect_options *ndo,\n\t\tu_char np, const struct isakmp_gen *ext, const u_char *ep,\n\t\tuint32_t phase, uint32_t doi, uint32_t proto, int depth)\n{\n\tconst u_char *cp;\n\tint i;\n\tstruct isakmp_gen e;\n\tcp = (const u_char *)ext;\n\twhile (np) {\n\t\tND_TCHECK(*ext);\n\t\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\t\tND_TCHECK2(*ext, ntohs(e.len));\n\t\tdepth++;\n\t\tND_PRINT((ndo,\"\\n\"));\n\t\tfor (i = 0; i < depth; i++)\n\t\t\tND_PRINT((ndo,\"    \"));\n\t\tND_PRINT((ndo,\"(\"));\n\t\tcp = ike_sub0_print(ndo, np, ext, ep, phase, doi, proto, depth);\n\t\tND_PRINT((ndo,\")\"));\n\t\tdepth--;\n\t\tif (cp == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\t\tnp = e.np;\n\t\text = (const struct isakmp_gen *)cp;\n\t}\n\treturn cp;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(np)));\n\treturn NULL;\n}", "target": 1}
{"code": "GF_Err gf_isom_use_compact_size(GF_ISOFile *movie, u32 trackNumber, Bool CompactionOn)\n{\n\tGF_TrackBox *trak;\n\tu32 i, size;\n\tGF_SampleSizeBox *stsz;\n\tGF_Err e;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media || !trak->Media->information\n\t        || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleSize)\n\t\treturn GF_ISOM_INVALID_FILE;\n\tstsz = trak->Media->information->sampleTable->SampleSize;\n\tif (!CompactionOn) {\n\t\tif (stsz->type == GF_ISOM_BOX_TYPE_STSZ) return GF_OK;\n\t\tstsz->type = GF_ISOM_BOX_TYPE_STSZ;\n\t\tstsz->sampleSize = 0;\n\t\tif (!stsz->sampleCount) return GF_OK;\n\t\tif (!stsz->sizes) return GF_OK;\n\t\tsize = stsz->sizes[0];\n\t\tfor (i=1; i<stsz->sampleCount; i++) {\n\t\t\tif (size != stsz->sizes[i]) {\n\t\t\t\tsize = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (size) {\n\t\t\tgf_free(stsz->sizes);\n\t\t\tstsz->sizes = NULL;\n\t\t\tstsz->sampleSize = size;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (stsz->type == GF_ISOM_BOX_TYPE_STZ2) return GF_OK;\n\tif (stsz->sampleSize) {\n\t\tif (stsz->sizes) gf_free(stsz->sizes);\n\t\tstsz->sizes = (u32*) gf_malloc(sizeof(u32)*stsz->sampleCount);\n\t\tif (!stsz->sizes) return GF_OUT_OF_MEM;\n\t\tmemset(stsz->sizes, stsz->sampleSize, sizeof(u32));\n\t}\n\tstsz->sampleSize = 0;\n\tstsz->type = GF_ISOM_BOX_TYPE_STZ2;\n\treturn GF_OK;\n}", "target": 1}
{"code": "CallResult<PseudoHandle<>> GeneratorInnerFunction::callInnerFunction(\n    Handle<GeneratorInnerFunction> selfHandle,\n    Runtime &runtime,\n    Handle<> arg,\n    Action action) {\n  auto self = Handle<GeneratorInnerFunction>::vmcast(selfHandle);\n  SmallHermesValue shv =\n      SmallHermesValue::encodeHermesValue(arg.getHermesValue(), runtime);\n  self->result_.set(shv, runtime.getHeap());\n  self->action_ = action;\n  auto ctx = runtime.makeMutableHandle(selfHandle->savedContext_);\n  const uint32_t argCount = self->argCount_;\n  HermesValue newTarget = HermesValue::encodeUndefinedValue();\n  ScopedNativeCallFrame frame{\n      runtime,\n      argCount, \n      selfHandle.getHermesValue(),\n      newTarget,\n      ctx->at(0)};\n  if (LLVM_UNLIKELY(frame.overflowed()))\n    return runtime.raiseStackOverflow(Runtime::StackOverflowKind::NativeStack);\n  for (ArrayStorage::size_type i = 0, e = argCount; i < e; ++i) {\n    frame->getArgRef(i) = ctx->at(i + 1);\n  }\n  if (LLVM_UNLIKELY(selfHandle->getCodeBlock(runtime)->isLazy())) {\n    selfHandle->getCodeBlock(runtime)->lazyCompile(runtime);\n    if (LLVM_UNLIKELY(\n            ArrayStorage::resize(\n                ctx,\n                runtime,\n                getContextSize(\n                    selfHandle->getCodeBlock(runtime),\n                    selfHandle->argCount_)) == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    selfHandle->savedContext_.set(runtime, ctx.get(), runtime.getHeap());\n  }\n  return JSFunction::_callImpl(selfHandle, runtime);\n}", "target": 1}
{"code": "static int floppy_raw_cmd_ioctl(int type, int drive, int cmd,\n\t\t\t\tvoid __user *param)\n{\n\tint ret;\n\tpr_warn_once(\"Note: FDRAWCMD is deprecated and will be removed from the kernel in the near future.\\n\");\n\tif (type)\n\t\treturn -EINVAL;\n\tif (lock_fdc(drive))\n\t\treturn -EINTR;\n\tset_floppy(drive);\n\tret = raw_cmd_ioctl(cmd, param);\n\tif (ret == -EINTR)\n\t\treturn -EINTR;\n\tprocess_fd_request();\n\treturn ret;\n}", "target": 0}
{"code": "NOEXPORT char *pgsql_server(CLI *c, SERVICE_OPTIONS *opt, const PHASE phase) {\n    uint8_t buffer[8], ssl_ok[1]={'S'};\n    static const uint8_t gss_request[8]={0, 0, 0, 8, 0x04, 0xd2, 0x16, 0x30};\n    static const uint8_t gss_response[62]=\n        {'E', 0, 0, 0, 61, 'S', 'E', 'R', 'R', 'O', 'R', 0, 'C', 'X', 'X', '0',\n        '0', '0', 0, 'M', 'S', 'S', 'L', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',\n        ' ', 'b', 'u', 't', ' ', 'n', 'o', 't', ' ', 'r', 'e', 'q', 'u', 'e', 's', 't',\n        'e', 'd', ' ', 'b', 'y', ' ', 'c', 'l', 'i', 'e', 'n', 't', 0, 0};\n    (void)opt; \n    if(phase!=PROTOCOL_EARLY)\n        return NULL;\n    s_log(LOG_DEBUG, \"Started server-side psql protcol negotiation\");\n    memset(buffer, 0, sizeof buffer);\n    s_read(c, c->local_rfd.fd, buffer, sizeof buffer);\n    if(!safe_memcmp(buffer, gss_request, sizeof gss_request)) {\n        s_log(LOG_INFO, \"GSSAPI encryption requested, rejecting gracefully\");\n        s_write(c, c->local_wfd.fd, gss_response, sizeof gss_response);\n        throw_exception(c, 2); \n    }\n    if(safe_memcmp(buffer, ssl_request, sizeof ssl_request)) {\n        s_log(LOG_ERR, \"PostgreSQL client did not request TLS, rejecting\");\n        throw_exception(c, 1);\n    }\n    s_log(LOG_DEBUG, \"SSLRequest received\");\n    s_write(c, c->local_wfd.fd, ssl_ok, sizeof ssl_ok);\n    return NULL;\n}", "target": 0}
{"code": "GF_AV1Config *gf_isom_av1_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tif (gf_isom_get_reference_count(the_file, trackNumber, GF_ISOM_REF_TBAS)) {\n\t\tu32 ref_track;\n\t\tGF_Err e = gf_isom_get_reference(the_file, trackNumber, GF_ISOM_REF_TBAS, 1, &ref_track);\n\t\tif (e == GF_OK) {\n\t\t\ttrackNumber = ref_track;\n\t\t}\n\t}\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex - 1);\n\tif (!entry || !entry->av1_config) return NULL;\n\treturn AV1_DuplicateConfig(entry->av1_config->config);\n}", "target": 1}
{"code": "static int raw_cmd_copyin(int cmd, void __user *param,\n\t\t\t\t struct floppy_raw_cmd **rcmd)\n{\n\tstruct floppy_raw_cmd *ptr;\n\tint ret;\n\tint i;\n\t*rcmd = NULL;\nloop:\n\tptr = kmalloc(sizeof(struct floppy_raw_cmd), GFP_USER);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\t*rcmd = ptr;\n\tret = copy_from_user(ptr, param, sizeof(*ptr));\n\tif (ret)\n\t\treturn -EFAULT;\n\tptr->next = NULL;\n\tptr->buffer_length = 0;\n\tparam += sizeof(struct floppy_raw_cmd);\n\tif (ptr->cmd_count > 33)\n\t\treturn -EINVAL;\n\tfor (i = 0; i < 16; i++)\n\t\tptr->reply[i] = 0;\n\tptr->resultcode = 0;\n\tptr->kernel_data = NULL;\n\tif (ptr->flags & (FD_RAW_READ | FD_RAW_WRITE)) {\n\t\tif (ptr->length <= 0)\n\t\t\treturn -EINVAL;\n\t\tptr->kernel_data = (char *)fd_dma_mem_alloc(ptr->length);\n\t\tfallback_on_nodma_alloc(&ptr->kernel_data, ptr->length);\n\t\tif (!ptr->kernel_data)\n\t\t\treturn -ENOMEM;\n\t\tptr->buffer_length = ptr->length;\n\t}\n\tif (ptr->flags & FD_RAW_WRITE) {\n\t\tret = fd_copyin(ptr->data, ptr->kernel_data, ptr->length);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (ptr->flags & FD_RAW_MORE) {\n\t\trcmd = &(ptr->next);\n\t\tptr->rate &= 0x43;\n\t\tgoto loop;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static inline void openOptimized(sqlite3*& db) {\n  sqlite3_open(\":memory:\", &db);\n  std::string settings;\n  for (const auto& setting : kMemoryDBSettings) {\n    settings += \"PRAGMA \" + setting.first + \"=\" + setting.second + \"; \";\n  }\n  sqlite3_exec(db, settings.c_str(), nullptr, nullptr, nullptr);\n  registerMathExtensions(db);\n#if !defined(FREEBSD)\n  registerStringExtensions(db);\n#endif\n#if !defined(SKIP_CARVER)\n  registerOperationExtensions(db);\n#endif\n  registerFilesystemExtensions(db);\n  registerHashingExtensions(db);\n  registerEncodingExtensions(db);\n  auto rc = sqlite3_set_authorizer(db, &sqliteAuthorizer, nullptr);\n  if (rc != SQLITE_OK) {\n    LOG(ERROR) << \"Failed to set sqlite authorizer: \" << sqlite3_errmsg(db);\n    requestShutdown(rc);\n  }\n}", "target": 0}
{"code": "njs_json_pop_parse_state(njs_vm_t *vm, njs_json_parse_t *parse)\n{\n    njs_json_state_t  *state;\n    state = &parse->states[parse->depth - 1];\n    njs_array_destroy(vm, state->keys);\n    state->keys = NULL;\n    if (parse->depth > 1) {\n        parse->depth--;\n        return &parse->states[parse->depth - 1];\n    }\n    return NULL;\n}", "target": 1}
{"code": "static int proc_open(const char *path, struct fuse_file_info *fi)\n{\n\tint type = -1;\n\tstruct file_info *info;\n\tif (strcmp(path, \"/proc/meminfo\") == 0)\n\t\ttype = LXC_TYPE_PROC_MEMINFO;\n\telse if (strcmp(path, \"/proc/cpuinfo\") == 0)\n\t\ttype = LXC_TYPE_PROC_CPUINFO;\n\telse if (strcmp(path, \"/proc/uptime\") == 0)\n\t\ttype = LXC_TYPE_PROC_UPTIME;\n\telse if (strcmp(path, \"/proc/stat\") == 0)\n\t\ttype = LXC_TYPE_PROC_STAT;\n\telse if (strcmp(path, \"/proc/diskstats\") == 0)\n\t\ttype = LXC_TYPE_PROC_DISKSTATS;\n\tif (type == -1)\n\t\treturn -ENOENT;\n\tinfo = malloc(sizeof(*info));\n\tif (!info)\n\t\treturn -ENOMEM;\n\tmemset(info, 0, sizeof(*info));\n\tinfo->type = type;\n\tinfo->buflen = get_procfile_size(path) + BUF_RESERVE_SIZE;\n\tdo {\n\t\tinfo->buf = malloc(info->buflen);\n\t} while (!info->buf);\n\tmemset(info->buf, 0, info->buflen);\n\tinfo->size = info->buflen;\n\tfi->fh = (unsigned long)info;\n\treturn 0;\n}", "target": 0}
{"code": "test_function (char * (*my_asnprintf) (char *, size_t *, const char *, ...))\n{\n  char buf[8];\n  int size;\n  for (size = 0; size <= 8; size++)\n    {\n      size_t length = size;\n      char *result = my_asnprintf (NULL, &length, \"%d\", 12345);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"12345\") == 0);\n      ASSERT (length == 5);\n      free (result);\n    }\n  for (size = 0; size <= 8; size++)\n    {\n      size_t length;\n      char *result;\n      memcpy (buf, \"DEADBEEF\", 8);\n      length = size;\n      result = my_asnprintf (buf, &length, \"%d\", 12345);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"12345\") == 0);\n      ASSERT (length == 5);\n      if (size < 6)\n        ASSERT (result != buf);\n      ASSERT (memcmp (buf + size, &\"DEADBEEF\"[size], 8 - size) == 0);\n      if (result != buf)\n        free (result);\n    }\n}", "target": 1}
{"code": "Status KernelAndDeviceOp::Run(\n    ScopedStepContainer* step_container, const EagerKernelArgs& inputs,\n    std::vector<EagerKernelRet>* outputs,\n    CancellationManager* cancellation_manager,\n    const absl::optional<EagerRemoteFunctionParams>& remote_func_params) {\n  OpKernelContext::Params params;\n  params.device = device_;\n  params.frame_iter = FrameAndIter(0, 0);\n  params.inputs = inputs.GetTensorValues();\n  params.op_kernel = kernel_.get();\n  params.resource_manager = device_->resource_manager();\n  params.input_alloc_attrs = &input_alloc_attrs_;\n  params.output_attr_array = output_alloc_attrs_.data();\n  params.function_library = flr_;\n  params.slice_reader_cache = &slice_reader_cache_;\n  params.rendezvous = rendezvous_;\n  OpExecutionState* op_execution_state = nullptr;\n  CancellationManager default_cancellation_manager;\n  if (cancellation_manager) {\n    params.cancellation_manager = cancellation_manager;\n  } else if (kernel_->is_deferred()) {\n    op_execution_state = new OpExecutionState;\n    params.cancellation_manager = &op_execution_state->cancellation_manager;\n    params.inc_num_deferred_ops_function = [op_execution_state]() {\n      op_execution_state->Ref();\n    };\n    params.dec_num_deferred_ops_function = [op_execution_state]() {\n      op_execution_state->Unref();\n    };\n  } else {\n    params.cancellation_manager = &default_cancellation_manager;\n  }\n  params.log_memory = log_memory_;\n  params.runner = get_runner();\n  params.step_container =\n      step_container == nullptr ? &step_container_ : step_container;\n  auto step_container_cleanup = gtl::MakeCleanup([step_container, this] {\n    if (step_container == nullptr) {\n      this->step_container_.CleanUp();\n    }\n  });\n  params.collective_executor =\n      collective_executor_ ? collective_executor_->get() : nullptr;\n  OpKernelContext context(&params);\n  {\n    port::ScopedFlushDenormal flush;\n    port::ScopedSetRound round(FE_TONEAREST);\n    profiler::AnnotatedTraceMe activity(\n        [&] { return kernel_->TraceString(context, false); },\n        profiler::TraceMeLevel::kInfo);\n    device_->Compute(kernel_.get(), &context);\n  }\n  if (op_execution_state != nullptr) {\n    op_execution_state->Unref();\n  }\n  if (!context.status().ok()) return context.status();\n  if (outputs != nullptr) {\n    outputs->clear();\n    for (int i = 0; i < context.num_outputs(); ++i) {\n      outputs->push_back(Tensor(*context.mutable_output(i)));\n    }\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)\n{\n\tgit_pkt *pkt;\n\tconst char *line, *line_end;\n\tsize_t line_len;\n\tint error;\n\tint reading_from_buf = data_pkt_buf->size > 0;\n\tif (reading_from_buf) {\n\t\tgit_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);\n\t\tline = data_pkt_buf->ptr;\n\t\tline_len = data_pkt_buf->size;\n\t}\n\telse {\n\t\tline = data_pkt->data;\n\t\tline_len = data_pkt->len;\n\t}\n\twhile (line_len > 0) {\n\t\terror = git_pkt_parse_line(&pkt, line, &line_end, line_len);\n\t\tif (error == GIT_EBUFS) {\n\t\t\tif (!reading_from_buf)\n\t\t\t\tgit_buf_put(data_pkt_buf, line, line_len);\n\t\t\terror = 0;\n\t\t\tgoto done;\n\t\t}\n\t\telse if (error < 0)\n\t\t\tgoto done;\n\t\tline_len -= (line_end - line);\n\t\tline = line_end;\n\t\tif (pkt == NULL)\n\t\t\tcontinue;\n\t\terror = add_push_report_pkt(push, pkt);\n\t\tgit_pkt_free(pkt);\n\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\tgoto done;\n\t}\n\terror = 0;\ndone:\n\tif (reading_from_buf)\n\t\tgit_buf_consume(data_pkt_buf, line_end);\n\treturn error;\n}", "target": 1}
{"code": "static int ext4_statfs_project(struct super_block *sb,\n\t\t\t       kprojid_t projid, struct kstatfs *buf)\n{\n\tstruct kqid qid;\n\tstruct dquot *dquot;\n\tu64 limit;\n\tu64 curblock;\n\tqid = make_kqid_projid(projid);\n\tdquot = dqget(sb, qid);\n\tif (IS_ERR(dquot))\n\t\treturn PTR_ERR(dquot);\n\tspin_lock(&dquot->dq_dqb_lock);\n\tlimit = (dquot->dq_dqb.dqb_bsoftlimit ?\n\t\t dquot->dq_dqb.dqb_bsoftlimit :\n\t\t dquot->dq_dqb.dqb_bhardlimit) >> sb->s_blocksize_bits;\n\tif (limit && buf->f_blocks > limit) {\n\t\tcurblock = dquot->dq_dqb.dqb_curspace >> sb->s_blocksize_bits;\n\t\tbuf->f_blocks = limit;\n\t\tbuf->f_bfree = buf->f_bavail =\n\t\t\t(buf->f_blocks > curblock) ?\n\t\t\t (buf->f_blocks - curblock) : 0;\n\t}\n\tlimit = dquot->dq_dqb.dqb_isoftlimit ?\n\t\tdquot->dq_dqb.dqb_isoftlimit :\n\t\tdquot->dq_dqb.dqb_ihardlimit;\n\tif (limit && buf->f_files > limit) {\n\t\tbuf->f_files = limit;\n\t\tbuf->f_ffree =\n\t\t\t(buf->f_files > dquot->dq_dqb.dqb_curinodes) ?\n\t\t\t (buf->f_files - dquot->dq_dqb.dqb_curinodes) : 0;\n\t}\n\tspin_unlock(&dquot->dq_dqb_lock);\n\tdqput(dquot);\n\treturn 0;\n}", "target": 0}
{"code": "template <> HeaderMapImpl::StaticLookupTable<RequestHeaderMap>::StaticLookupTable() {\n#define REGISTER_DEFAULT_REQUEST_HEADER(name)                                                      \\\n  CustomInlineHeaderRegistry::registerInlineHeader<RequestHeaderMap::header_map_type>(             \\\n      Headers::get().name);\n  INLINE_REQ_HEADERS(REGISTER_DEFAULT_REQUEST_HEADER)\n  INLINE_REQ_RESP_HEADERS(REGISTER_DEFAULT_REQUEST_HEADER)\n  finalizeTable();\n  const auto handle =\n      CustomInlineHeaderRegistry::getInlineHeader<RequestHeaderMap::header_map_type>(\n          Headers::get().Host);\n  add(Headers::get().HostLegacy.get().c_str(), [handle](HeaderMapImpl& h) -> StaticLookupResponse {\n    return {&h.inlineHeaders()[handle.value().it_->second], &handle.value().it_->first};\n  });\n}", "target": 0}
{"code": "Status TensorSlice::BuildTensorSlice(const TensorSliceProto& proto,\n                                     TensorSlice* output) {\n  output->Clear();\n  output->starts_.reserve(proto.extent_size());\n  output->lengths_.reserve(proto.extent_size());\n  for (const auto& e : proto.extent()) {\n    int64_t l = GetExtentLength(e);\n    if (e.start() != 0 || l != kFullExtent) {\n      if (e.start() < 0 || l <= 0) {\n        return errors::InvalidArgument(\n            \"Expected non-negative start and positive length but got start = \",\n            e.start(), \", length = \", l, \": extent = \", e.ShortDebugString());\n      }\n      if (static_cast<uint64_t>(e.start()) + static_cast<uint64_t>(e.length()) >\n          std::numeric_limits<int64_t>::max()) {\n        return errors::InvalidArgument(\n            \"Extent end exceeds the maximum possible size: extent = \",\n            e.ShortDebugString());\n      }\n    }\n    output->starts_.push_back(e.start());\n    output->lengths_.push_back(l);\n  }\n  return Status::OK();\n}", "target": 0}
{"code": "ikev1_nonce_print(netdissect_options *ndo, u_char tpay _U_,\n\t\t  const struct isakmp_gen *ext,\n\t\t  u_int item_len _U_,\n\t\t  const u_char *ep,\n\t\t  uint32_t phase _U_, uint32_t doi _U_,\n\t\t  uint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_NONCE)));\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" n len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t} else if (1 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!ike_show_somedata(ndo, (const u_char *)(const uint8_t *)(ext + 1), ep))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_NONCE)));\n\treturn NULL;\n}", "target": 1}
{"code": "static int stv06xx_isoc_init(struct gspca_dev *gspca_dev)\n{\n\tstruct usb_host_interface *alt;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\talt = &gspca_dev->dev->actconfig->intf_cache[0]->altsetting[1];\n\talt->endpoint[0].desc.wMaxPacketSize =\n\t\tcpu_to_le16(sd->sensor->max_packet_size[gspca_dev->curr_mode]);\n\treturn 0;\n}", "target": 1}
{"code": "int ossl_dsa_check_pairwise(const DSA *dsa)\n{\n    int ret = 0;\n    BN_CTX *ctx = NULL;\n    BIGNUM *pub_key = NULL;\n    if (dsa->params.p == NULL\n        || dsa->params.g == NULL\n        || dsa->priv_key == NULL\n        || dsa->pub_key == NULL)\n        return 0;\n    ctx = BN_CTX_new_ex(dsa->libctx);\n    if (ctx == NULL)\n        goto err;\n    pub_key = BN_new();\n    if (pub_key == NULL)\n        goto err;\n    if (!ossl_dsa_generate_public_key(ctx, dsa, dsa->priv_key, pub_key))\n        goto err;\n    ret = BN_cmp(pub_key, dsa->pub_key) == 0;\nerr:\n    BN_free(pub_key);\n    BN_CTX_free(ctx);\n    return ret;\n}", "target": 1}
{"code": "static void __timerfd_remove_cancel(struct timerfd_ctx *ctx)\n{\n\tif (ctx->might_cancel) {\n\t\tctx->might_cancel = false;\n\t\tspin_lock(&cancel_lock);\n\t\tlist_del_rcu(&ctx->clist);\n\t\tspin_unlock(&cancel_lock);\n\t}\n}", "target": 0}
{"code": "static inline void tcp_parse_option_mss(struct pico_socket_tcp *t, uint8_t len, uint8_t *opt, uint32_t *idx)\n{\n    uint16_t mss;\n    if (tcpopt_len_check(idx, len, PICO_TCPOPTLEN_MSS) < 0)\n        return;\n    if ((*idx + PICO_TCPOPTLEN_MSS) > len)\n        return;\n    t->mss_ok = 1;\n    mss = short_from(opt + *idx);\n    *idx += (uint32_t)sizeof(uint16_t);\n    if (t->mss > short_be(mss))\n        t->mss = short_be(mss);\n}", "target": 0}
{"code": "static size_t socket_slurp(RSocket *s, RBuffer *buf) {\n\tsize_t i;\n\tif (r_socket_ready (s, 1, 0) != 1) {\n\t\treturn 0;\n\t}\n\tr_socket_block_time (s, 1, 0, 1000);\n\tfor (i = 0; i < SOCKET_HTTP_MAX_HEADER_LENGTH; i += 1) {\n\t\tut8 c;\n\t\tint olen = r_socket_read_block (s, &c, 1);\n\t\tif (olen != 1) {\n\t\t\tr_buf_append_bytes (buf, (ut8 *)\"\", 1);\n\t\t\tbreak;\n\t\t}\n\t\tr_buf_append_bytes (buf, &c, 1);\n\t}\n\treturn i;\n}", "target": 0}
{"code": "njs_vmcode_array(njs_vm_t *vm, u_char *pc)\n{\n    uint32_t            length;\n    njs_array_t         *array;\n    njs_value_t         *value;\n    njs_vmcode_array_t  *code;\n    code = (njs_vmcode_array_t *) pc;\n    array = njs_array_alloc(vm, 0, code->length, NJS_ARRAY_SPARE);\n    if (njs_fast_path(array != NULL)) {\n        if (code->ctor) {\n            value = array->start;\n            length = array->length;\n            do {\n                njs_set_invalid(value);\n                value++;\n                length--;\n            } while (length != 0);\n        } else {\n            array->length = 0;\n        }\n        njs_set_array(&vm->retval, array);\n        return sizeof(njs_vmcode_array_t);\n    }\n    return NJS_ERROR;\n}", "target": 1}
{"code": "hphp_libxml_input_buffer_noload(const char *URI, xmlCharEncoding enc) {\n  return nullptr;\n}", "target": 1}
{"code": "static bool pb_release_union_field(pb_istream_t *stream, pb_field_iter_t *field)\n{\n    pb_field_iter_t old_field = *field;\n    pb_size_t old_tag = *(pb_size_t*)field->pSize; \n    pb_size_t new_tag = field->tag; \n    if (old_tag == 0)\n        return true; \n    if (old_tag == new_tag)\n        return true; \n    if (!pb_field_iter_find(&old_field, old_tag))\n        PB_RETURN_ERROR(stream, \"invalid union tag\");\n    pb_release_single_field(&old_field);\n    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)\n    {\n        *(void**)field->pField = NULL;\n        field->pData = NULL;\n    }\n    return true;\n}", "target": 0}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* data =\n      reinterpret_cast<TfLiteAudioMicrofrontendParams*>(node->user_data);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 1);\n  TF_LITE_ENSURE_EQ(context, input->type, kTfLiteInt16);\n  output->type = kTfLiteInt32;\n  if (data->out_float) {\n    output->type = kTfLiteFloat32;\n  }\n  TfLiteIntArray* output_size = TfLiteIntArrayCreate(2);\n  int num_frames = 0;\n  if (input->dims->data[0] >= data->state->window.size) {\n    num_frames = (input->dims->data[0] - data->state->window.size) /\n                     data->state->window.step / data->frame_stride +\n                 1;\n  }\n  output_size->data[0] = num_frames;\n  output_size->data[1] = data->state->filterbank.num_channels *\n                         (1 + data->left_context + data->right_context);\n  return context->ResizeTensor(context, output, output_size);\n}", "target": 1}
{"code": "void blk_mq_free_tag_set(struct blk_mq_tag_set *set)\n{\n\tint i;\n\tfor (i = 0; i < set->nr_hw_queues; i++) {\n\t\tif (set->tags[i]) {\n\t\t\tblk_mq_free_rq_map(set, set->tags[i], i);\n\t\t\tfree_cpumask_var(set->tags[i]->cpumask);\n\t\t}\n\t}\n\tkfree(set->tags);\n\tset->tags = NULL;\n}", "target": 0}
{"code": "static RList *symbols(RBinFile *bf) {\n\tr_return_val_if_fail (bf && bf->o && bf->o->bin_obj, NULL);\n\tRCoreSymCacheElement *element = bf->o->bin_obj;\n\tsize_t i;\n\tHtUU *hash = ht_uu_new0 ();\n\tif (!hash) {\n\t\treturn NULL;\n\t}\n\tRList *res = r_list_newf ((RListFree)r_bin_symbol_free);\n\tbool found = false;\n\tif (element->lined_symbols) {\n\t\tfor (i = 0; i < element->hdr->n_lined_symbols; i++) {\n\t\t\tRCoreSymCacheElementSymbol *sym = (RCoreSymCacheElementSymbol *)&element->lined_symbols[i];\n\t\t\tif (!sym) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tht_uu_find (hash, sym->paddr, &found);\n\t\t\tif (found) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRBinSymbol *s = bin_symbol_from_symbol (element, sym);\n\t\t\tif (s) {\n\t\t\t\tr_list_append (res, s);\n\t\t\t\tht_uu_insert (hash, sym->paddr, 1);\n\t\t\t}\n\t\t}\n\t}\n\tif (element->symbols) {\n\t\tfor (i = 0; i < element->hdr->n_symbols; i++) {\n\t\t\tRCoreSymCacheElementSymbol *sym = &element->symbols[i];\n\t\t\tht_uu_find (hash, sym->paddr, &found);\n\t\t\tif (found) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRBinSymbol *s = bin_symbol_from_symbol (element, sym);\n\t\t\tif (s) {\n\t\t\t\tr_list_append (res, s);\n\t\t\t}\n\t\t}\n\t}\n\tht_uu_free (hash);\n\treturn res;\n}", "target": 0}
{"code": "static int read_payload_length_info(struct LATMContext *ctx, GetBitContext *gb)\n{\n    uint8_t tmp;\n    if (ctx->frame_length_type == 0) {\n        int mux_slot_length = 0;\n        do {\n            tmp = get_bits(gb, 8);\n            mux_slot_length += tmp;\n        } while (tmp == 255);\n        return mux_slot_length;\n    } else if (ctx->frame_length_type == 1) {\n        return ctx->frame_length;\n    } else if (ctx->frame_length_type == 3 ||\n               ctx->frame_length_type == 5 ||\n               ctx->frame_length_type == 7) {\n        skip_bits(gb, 2);          \n    }\n    return 0;\n}", "target": 0}
{"code": "static struct full_stripe_lock *search_full_stripe_lock(\n\t\tstruct btrfs_full_stripe_locks_tree *locks_root,\n\t\tu64 fstripe_logical)\n{\n\tstruct rb_node *node;\n\tstruct full_stripe_lock *entry;\n\tlockdep_assert_held(&locks_root->lock);\n\tnode = locks_root->root.rb_node;\n\twhile (node) {\n\t\tentry = rb_entry(node, struct full_stripe_lock, node);\n\t\tif (fstripe_logical < entry->logical)\n\t\t\tnode = node->rb_left;\n\t\telse if (fstripe_logical > entry->logical)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& in_grads = context->input(0);\n    const Tensor& in_image = context->input(1);\n    const Tensor& out_image = context->input(2);\n    OP_REQUIRES(context, in_grads.dims() == 4 && in_image.dims() == 4,\n                errors::InvalidArgument(\"inputs must be 4-dimensional\"));\n    const int64_t batch = in_grads.dim_size(0);\n    const int64_t rows = in_grads.dim_size(1);\n    const int64_t cols = in_grads.dim_size(2);\n    const int64_t depth = in_grads.dim_size(3);\n    OP_REQUIRES(\n        context,\n        in_image.dim_size(0) == batch && in_image.dim_size(1) == rows &&\n            in_image.dim_size(2) == cols && in_image.dim_size(3) == depth &&\n            out_image.dim_size(0) == batch && out_image.dim_size(1) == rows &&\n            out_image.dim_size(2) == cols && out_image.dim_size(3) == depth,\n        errors::InvalidArgument(\n            \"input_grads, input_image, and out_image should have the same \"\n            \"shape\"));\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(\n                       0, TensorShape({batch, rows, cols, depth}), &output));\n    LaunchLRNGrad<Device, T> launcher(depth_radius_, bias_, alpha_, beta_);\n    launcher.launch(context, this, in_grads, in_image, out_image, output);\n  }", "target": 1}
{"code": "archive_read_format_cpio_read_data(struct archive_read *a,\n    const void **buff, size_t *size, int64_t *offset)\n{\n\tssize_t bytes_read;\n\tstruct cpio *cpio;\n\tcpio = (struct cpio *)(a->format->data);\n\tif (cpio->entry_bytes_unconsumed) {\n\t\t__archive_read_consume(a, cpio->entry_bytes_unconsumed);\n\t\tcpio->entry_bytes_unconsumed = 0;\n\t}\n\tif (cpio->entry_bytes_remaining > 0) {\n\t\t*buff = __archive_read_ahead(a, 1, &bytes_read);\n\t\tif (bytes_read <= 0)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tif (bytes_read > cpio->entry_bytes_remaining)\n\t\t\tbytes_read = (ssize_t)cpio->entry_bytes_remaining;\n\t\t*size = bytes_read;\n\t\tcpio->entry_bytes_unconsumed = bytes_read;\n\t\t*offset = cpio->entry_offset;\n\t\tcpio->entry_offset += bytes_read;\n\t\tcpio->entry_bytes_remaining -= bytes_read;\n\t\treturn (ARCHIVE_OK);\n\t} else {\n\t\tif (cpio->entry_padding !=\n\t\t\t__archive_read_consume(a, cpio->entry_padding)) {\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tcpio->entry_padding = 0;\n\t\t*buff = NULL;\n\t\t*size = 0;\n\t\t*offset = cpio->entry_offset;\n\t\treturn (ARCHIVE_EOF);\n\t}\n}", "target": 0}
{"code": "  void initialize() override {\n    setMaxRequestHeadersKb(60);\n    setMaxRequestHeadersCount(100);\n    envoy::config::route::v3::RetryPolicy retry_policy;\n    auto pass_through = config_helper_.createVirtualHost(\"pass.through.internal.redirect\");\n    config_helper_.addVirtualHost(pass_through);\n    auto handle = config_helper_.createVirtualHost(\"handle.internal.redirect\");\n    handle.mutable_routes(0)->set_name(\"redirect\");\n    handle.mutable_routes(0)->mutable_route()->mutable_internal_redirect_policy();\n    config_helper_.addVirtualHost(handle);\n    auto handle_max_3_hop =\n        config_helper_.createVirtualHost(\"handle.internal.redirect.max.three.hop\");\n    handle_max_3_hop.mutable_routes(0)->set_name(\"max_three_hop\");\n    handle_max_3_hop.mutable_routes(0)->mutable_route()->mutable_internal_redirect_policy();\n    handle_max_3_hop.mutable_routes(0)\n        ->mutable_route()\n        ->mutable_internal_redirect_policy()\n        ->mutable_max_internal_redirects()\n        ->set_value(3);\n    config_helper_.addVirtualHost(handle_max_3_hop);\n    auto handle_by_direct_response = config_helper_.createVirtualHost(\"handle.direct.response\");\n    handle_by_direct_response.mutable_routes(0)->set_name(\"direct_response\");\n    handle_by_direct_response.mutable_routes(0)->mutable_direct_response()->set_status(204);\n    handle_by_direct_response.mutable_routes(0)\n        ->mutable_direct_response()\n        ->mutable_body()\n        ->set_inline_string(EMPTY_STRING);\n    config_helper_.addVirtualHost(handle_by_direct_response);\n    HttpProtocolIntegrationTest::initialize();\n  }", "target": 0}
{"code": "static int hci_uart_set_proto(struct hci_uart *hu, int id)\n{\n\tconst struct hci_uart_proto *p;\n\tint err;\n\tp = hci_uart_get_proto(id);\n\tif (!p)\n\t\treturn -EPROTONOSUPPORT;\n\thu->proto = p;\n\tset_bit(HCI_UART_PROTO_READY, &hu->flags);\n\terr = hci_uart_register_dev(hu);\n\tif (err) {\n\t\tclear_bit(HCI_UART_PROTO_READY, &hu->flags);\n\t\treturn err;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static Exit_status safe_connect()\n{\n  mysql= mysql_init(NULL);\n  if (!mysql)\n  {\n    error(\"Failed on mysql_init.\");\n    return ERROR_STOP;\n  }\n#ifdef HAVE_OPENSSL\n  if (opt_use_ssl)\n  {\n    mysql_ssl_set(mysql, opt_ssl_key, opt_ssl_cert, opt_ssl_ca,\n                  opt_ssl_capath, opt_ssl_cipher);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRL, opt_ssl_crl);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRLPATH, opt_ssl_crlpath);\n  }\n  mysql_options(mysql, MYSQL_OPT_SSL_VERIFY_SERVER_CERT,\n                (char*) &opt_ssl_verify_server_cert);\n#endif\n  if (opt_plugin_dir && *opt_plugin_dir)\n    mysql_options(mysql, MYSQL_PLUGIN_DIR, opt_plugin_dir);\n  if (opt_default_auth && *opt_default_auth)\n    mysql_options(mysql, MYSQL_DEFAULT_AUTH, opt_default_auth);\n  if (opt_protocol)\n    mysql_options(mysql, MYSQL_OPT_PROTOCOL, (char*) &opt_protocol);\n  if (opt_bind_addr)\n    mysql_options(mysql, MYSQL_OPT_BIND, opt_bind_addr);\n#if defined (_WIN32) && !defined (EMBEDDED_LIBRARY)\n  if (shared_memory_base_name)\n    mysql_options(mysql, MYSQL_SHARED_MEMORY_BASE_NAME,\n                  shared_memory_base_name);\n#endif\n  mysql_options(mysql, MYSQL_OPT_CONNECT_ATTR_RESET, 0);\n  mysql_options4(mysql, MYSQL_OPT_CONNECT_ATTR_ADD,\n                 \"program_name\", \"mysqlbinlog\");\n  if (!mysql_real_connect(mysql, host, user, pass, 0, port, sock, 0))\n  {\n    error(\"Failed on connect: %s\", mysql_error(mysql));\n    return ERROR_STOP;\n  }\n  mysql->reconnect= 1;\n  return OK_CONTINUE;\n}", "target": 1}
{"code": "TEST_P(SslIntegrationTest, LogPeerIpSanUnsupportedIpVersion) {\n  useListenerAccessLog(\"%DOWNSTREAM_PEER_IP_SAN%\");\n  config_helper_.addFilter(\"name: sni-to-header-filter\");\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection(ClientSslTransportOptions().setSni(\"host.com\"));\n  };\n  initialize();\n  codec_client_ = makeHttpConnection(\n      makeSslClientConnection(ClientSslTransportOptions().setSni(\"www.host.com\")));\n  auto disabler = (version_ == Network::Address::IpVersion::v4)\n                      ? Network::Address::Ipv6Instance::forceProtocolUnsupportedForTest\n                      : Network::Address::Ipv4Instance::forceProtocolUnsupportedForTest;\n  Cleanup cleaner(disabler(true));\n  Http::TestRequestHeaderMapImpl request_headers{\n      {\":method\", \"GET\"}, {\":path\", \"/\"}, {\":scheme\", \"https\"}, {\":authority\", \"host.com\"}};\n  auto response = codec_client_->makeHeaderOnlyRequest(request_headers);\n  waitForNextUpstreamRequest();\n  EXPECT_EQ(\"www.host.com\", upstream_request_->headers()\n                                .get(Http::LowerCaseString(\"x-envoy-client-sni\"))[0]\n                                ->value()\n                                .getStringView());\n  Http::TestResponseHeaderMapImpl response_headers{{\":status\", \"200\"}};\n  upstream_request_->encodeHeaders(response_headers, true);\n  RELEASE_ASSERT(response->waitForEndStream(), \"unexpected timeout\");\n  codec_client_->close();\n  checkStats();\n  auto result = waitForAccessLog(listener_access_log_name_);\n  if (version_ == Network::Address::IpVersion::v4) {\n    EXPECT_EQ(result, \"1.2.3.4\");\n  } else {\n    EXPECT_EQ(result, \"0:1:2:3::4\");\n  }\n}", "target": 0}
{"code": "StatusOr<FullTypeDef> SpecializeType(const AttrSlice& attrs,\n                                     const OpDef& op_def) {\n  FullTypeDef ft;\n  ft.set_type_id(TFT_PRODUCT);\n  for (int i = 0; i < op_def.output_arg_size(); i++) {\n    auto* t = ft.add_args();\n    *t = op_def.output_arg(i).experimental_full_type();\n    for (int j = 0; j < t->args_size(); j++) {\n      auto* arg = t->mutable_args(i);\n      if (arg->type_id() == TFT_VAR) {\n        const auto* attr = attrs.Find(arg->s());\n        DCHECK(attr != nullptr);\n        if (attr->value_case() == AttrValue::kList) {\n          const auto& attr_list = attr->list();\n          arg->set_type_id(TFT_PRODUCT);\n          for (int i = 0; i < attr_list.type_size(); i++) {\n            map_dtype_to_tensor(attr_list.type(i), arg->add_args());\n          }\n        } else if (attr->value_case() == AttrValue::kType) {\n          map_dtype_to_tensor(attr->type(), arg);\n        } else {\n          return Status(error::UNIMPLEMENTED,\n                        absl::StrCat(\"unknown attribute type\",\n                                     attrs.DebugString(), \" key=\", arg->s()));\n        }\n        arg->clear_s();\n      }\n    }\n  }\n  return ft;\n}", "target": 1}
{"code": "static int perf_swevent_add(struct perf_event *event, int flags)\n{\n\tstruct swevent_htable *swhash = this_cpu_ptr(&swevent_htable);\n\tstruct hw_perf_event *hwc = &event->hw;\n\tstruct hlist_head *head;\n\tif (is_sampling_event(event)) {\n\t\thwc->last_period = hwc->sample_period;\n\t\tperf_swevent_set_period(event);\n\t}\n\thwc->state = !(flags & PERF_EF_START);\n\thead = find_swevent_head(swhash, event);\n\tif (!head) {\n\t\tWARN_ON_ONCE(swhash->online);\n\t\treturn -EINVAL;\n\t}\n\thlist_add_head_rcu(&event->hlist_entry, head);\n\tperf_event_update_userpage(event);\n\treturn 0;\n}", "target": 1}
{"code": "auth_ice_connection (IceConn ice_conn)\n{\n        GIOChannel            *channel;\n        GsmIceConnectionWatch *data;\n        int                    fd;\n        g_debug (\"GsmXsmpServer: auth_ice_connection()\");\n        fd = IceConnectionNumber (ice_conn);\n        fcntl (fd, F_SETFD, fcntl (fd, F_GETFD, 0) | FD_CLOEXEC);\n        channel = g_io_channel_unix_new (fd);\n        data = g_new0 (GsmIceConnectionWatch, 1);\n        ice_conn->context = data;\n        data->protocol_timeout = g_timeout_add_seconds (5,\n                                                        (GSourceFunc)ice_protocol_timeout,\n                                                        ice_conn);\n        data->watch_id = g_io_add_watch (channel,\n                                         G_IO_IN | G_IO_ERR,\n                                         (GIOFunc)auth_iochannel_watch,\n                                         ice_conn);\n        g_io_channel_unref (channel);\n}", "target": 0}
{"code": "const char * util_acl_to_str(const sc_acl_entry_t *e)\n{\n\tstatic char line[80], buf[20];\n\tunsigned int acl;\n\tif (e == NULL)\n\t\treturn \"N/A\";\n\tline[0] = 0;\n\twhile (e != NULL) {\n\t\tacl = e->method;\n\t\tswitch (acl) {\n\t\tcase SC_AC_UNKNOWN:\n\t\t\treturn \"N/A\";\n\t\tcase SC_AC_NEVER:\n\t\t\treturn \"NEVR\";\n\t\tcase SC_AC_NONE:\n\t\t\treturn \"NONE\";\n\t\tcase SC_AC_CHV:\n\t\t\tstrcpy(buf, \"CHV\");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_TERM:\n\t\t\tstrcpy(buf, \"TERM\");\n\t\t\tbreak;\n\t\tcase SC_AC_PRO:\n\t\t\tstrcpy(buf, \"PROT\");\n\t\t\tbreak;\n\t\tcase SC_AC_AUT:\n\t\t\tstrcpy(buf, \"AUTH\");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 4, \"%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_SEN:\n\t\t\tstrcpy(buf, \"Sec.Env. \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"#%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_SCB:\n\t\t\tstrcpy(buf, \"Sec.ControlByte \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"Ox%X\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_IDA:\n\t\t\tstrcpy(buf, \"PKCS#15 AuthID \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"#%d\", e->key_ref);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstrcpy(buf, \"????\");\n\t\t\tbreak;\n\t\t}\n\t\tstrncat(line, buf, sizeof line);\n\t\tstrncat(line, \" \", sizeof line);\n\t\te = e->next;\n\t}\n\tline[(sizeof line)-1] = '\\0'; \n\tline[strlen(line)-1] = 0; \n\treturn line;\n}", "target": 0}
{"code": "  static void setAppend(SetType& set, const VariantType& v) {\n    auto value_type = type(v);\n    if (value_type != HPHP::serialize::Type::INT64 &&\n        value_type != HPHP::serialize::Type::STRING) {\n      throw HPHP::serialize::UnserializeError(\n          \"Unsupported keyset element of type \" +\n          folly::to<std::string>(value_type));\n    }\n    set.append(v);\n  }", "target": 1}
{"code": "bgp_attr_unintern (struct attr **attr)\n{\n  struct attr *ret;\n  struct attr tmp;\n  (*attr)->refcnt--;\n  tmp = *(*attr);\n  if ((*attr)->extra)\n    {\n      tmp.extra = bgp_attr_extra_new ();\n      memcpy (tmp.extra, (*attr)->extra, sizeof (struct attr_extra));\n    }\n  if ((*attr)->refcnt == 0)\n    {    \n      ret = hash_release (attrhash, *attr);\n      assert (ret != NULL);\n      bgp_attr_extra_free (*attr);\n      XFREE (MTYPE_ATTR, *attr);\n      *attr = NULL;\n    }\n  bgp_attr_unintern_sub (&tmp);\n  bgp_attr_extra_free (&tmp);\n}", "target": 0}
{"code": "static void _sched_arq_timeout(gnrc_sixlowpan_frag_fb_t *fbuf, uint32_t offset)\n{\n    if (IS_ACTIVE(CONFIG_GNRC_SIXLOWPAN_SFR_MOCK_ARQ_TIMER)) {\n        return;\n    }\n    if (fbuf->sfr.arq_timeout_event.msg.content.ptr != NULL) {\n        DEBUG(\"6lo sfr: ARQ timeout for datagram %u already scheduled\\n\",\n              (uint8_t)fbuf->tag);\n        return;\n    }\n    DEBUG(\"6lo sfr: arming ACK timeout in %lums for datagram %u\\n\",\n          (long unsigned)offset, fbuf->tag);\n    fbuf->sfr.arq_timeout_event.event.offset = offset;\n    fbuf->sfr.arq_timeout_event.msg.content.ptr = fbuf;\n    fbuf->sfr.arq_timeout_event.msg.type = GNRC_SIXLOWPAN_FRAG_SFR_ARQ_TIMEOUT_MSG;\n    evtimer_add_msg(&_arq_timer, &fbuf->sfr.arq_timeout_event,\n                    _getpid());\n}", "target": 1}
{"code": "file_pipe2file(struct magic_set *ms, int fd, const void *startbuf,\n    size_t nbytes)\n{\n\tchar buf[4096];\n\tssize_t r;\n\tint tfd;\n\t(void)strlcpy(buf, \"/tmp/file.XXXXXX\", sizeof buf);\n#ifndef HAVE_MKSTEMP\n\t{\n\t\tchar *ptr = mktemp(buf);\n\t\ttfd = open(ptr, O_RDWR|O_TRUNC|O_EXCL|O_CREAT, 0600);\n\t\tr = errno;\n\t\t(void)unlink(ptr);\n\t\terrno = r;\n\t}\n#else\n\t{\n\t\tint te;\n\t\ttfd = mkstemp(buf);\n\t\tte = errno;\n\t\t(void)unlink(buf);\n\t\terrno = te;\n\t}\n#endif\n\tif (tfd == -1) {\n\t\tfile_error(ms, errno,\n\t\t    \"cannot create temporary file for pipe copy\");\n\t\treturn -1;\n\t}\n\tif (swrite(tfd, startbuf, nbytes) != (ssize_t)nbytes)\n\t\tr = 1;\n\telse {\n\t\twhile ((r = sread(fd, buf, sizeof(buf), 1)) > 0)\n\t\t\tif (swrite(tfd, buf, (size_t)r) != r)\n\t\t\t\tbreak;\n\t}\n\tswitch (r) {\n\tcase -1:\n\t\tfile_error(ms, errno, \"error copying from pipe to temp file\");\n\t\treturn -1;\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\tfile_error(ms, errno, \"error while writing to temp file\");\n\t\treturn -1;\n\t}\n\tif ((fd = dup2(tfd, fd)) == -1) {\n\t\tfile_error(ms, errno, \"could not dup descriptor for temp file\");\n\t\treturn -1;\n\t}\n\t(void)close(tfd);\n\tif (FINFO_LSEEK_FUNC(fd, (off_t)0, SEEK_SET) == (off_t)-1) {\n\t\tfile_badseek(ms);\n\t\treturn -1;\n\t}\n\treturn fd;\n}", "target": 0}
{"code": "njs_function_prototype_apply(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    int64_t         i, length;\n    njs_int_t       ret;\n    njs_frame_t     *frame;\n    njs_value_t     *this, *arr_like;\n    njs_array_t     *arr;\n    njs_function_t  *func;\n    if (!njs_is_function(njs_argument(args, 0))) {\n        njs_type_error(vm, \"\\\"this\\\" argument is not a function\");\n        return NJS_ERROR;\n    }\n    func = njs_function(njs_argument(args, 0));\n    this = njs_arg(args, nargs, 1);\n    arr_like = njs_arg(args, nargs, 2);\n    if (njs_is_null_or_undefined(arr_like)) {\n        length = 0;\n        goto activate;\n    } else if (njs_is_array(arr_like)) {\n        arr = arr_like->data.u.array;\n        args = arr->start;\n        length = arr->length;\n        goto activate;\n    } else if (njs_slow_path(!njs_is_object(arr_like))) {\n        njs_type_error(vm, \"second argument is not an array-like object\");\n        return NJS_ERROR;\n    }\n    ret = njs_object_length(vm, arr_like, &length);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    arr = njs_array_alloc(vm, 1, length, NJS_ARRAY_SPARE);\n    if (njs_slow_path(arr == NULL)) {\n        return NJS_ERROR;\n    }\n    args = arr->start;\n    for (i = 0; i < length; i++) {\n        ret = njs_value_property_i64(vm, arr_like, i, &args[i]);\n        if (njs_slow_path(ret == NJS_ERROR)) {\n            return ret;\n        }\n    }\nactivate:\n    vm->top_frame->skip = 1;\n    frame = (njs_frame_t *) vm->top_frame;\n    ret = njs_function_frame(vm, func, this, args, length, 0);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    ret = njs_function_frame_invoke(vm, frame->native.retval);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    return NJS_DECLINED;\n}", "target": 1}
{"code": "static int fill_thread_core_info(struct elf_thread_core_info *t,\n\t\t\t\t const struct user_regset_view *view,\n\t\t\t\t long signr, size_t *total)\n{\n\tunsigned int i;\n\tfill_prstatus(&t->prstatus, t->task, signr);\n\t(void) view->regsets[0].get(t->task, &view->regsets[0],\n\t\t\t\t    0, sizeof(t->prstatus.pr_reg),\n\t\t\t\t    &t->prstatus.pr_reg, NULL);\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(t->prstatus), &t->prstatus);\n\t*total += notesize(&t->notes[0]);\n\tdo_thread_regset_writeback(t->task, &view->regsets[0]);\n\tfor (i = 1; i < view->n; ++i) {\n\t\tconst struct user_regset *regset = &view->regsets[i];\n\t\tdo_thread_regset_writeback(t->task, regset);\n\t\tif (regset->core_note_type &&\n\t\t    (!regset->active || regset->active(t->task, regset))) {\n\t\t\tint ret;\n\t\t\tsize_t size = regset->n * regset->size;\n\t\t\tvoid *data = kmalloc(size, GFP_KERNEL);\n\t\t\tif (unlikely(!data))\n\t\t\t\treturn 0;\n\t\t\tret = regset->get(t->task, regset,\n\t\t\t\t\t  0, size, data, NULL);\n\t\t\tif (unlikely(ret))\n\t\t\t\tkfree(data);\n\t\t\telse {\n\t\t\t\tif (regset->core_note_type != NT_PRFPREG)\n\t\t\t\t\tfill_note(&t->notes[i], \"LINUX\",\n\t\t\t\t\t\t  regset->core_note_type,\n\t\t\t\t\t\t  size, data);\n\t\t\t\telse {\n\t\t\t\t\tt->prstatus.pr_fpvalid = 1;\n\t\t\t\t\tfill_note(&t->notes[i], \"CORE\",\n\t\t\t\t\t\t  NT_PRFPREG, size, data);\n\t\t\t\t}\n\t\t\t\t*total += notesize(&t->notes[i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "void RGWDelBucketMetaSearch_ObjStore_S3::send_response()\n{\n  if (op_ret)\n    set_req_state_err(s, op_ret);\n  dump_errno(s);\n  end_header(s, this);\n}", "target": 0}
{"code": "exo_open_find_scheme (const gchar *string)\n{\n  gchar *current_dir;\n  gchar *uri;\n  gchar *path;\n  if (g_path_is_absolute (string))\n    return exo_open_get_path (string);\n  current_dir = g_get_current_dir ();\n  path = g_build_filename (current_dir, string, NULL);\n  g_free (current_dir);\n  if (g_file_test (path, G_FILE_TEST_EXISTS))\n    {\n       uri = exo_open_get_path (path);\n       g_free (path);\n       return uri;\n    }\n  g_free (path);\n  if (g_regex_match_simple (MATCH_PATTERN_EMAIL, string, G_REGEX_CASELESS, 0))\n    return g_strconcat (\"mailto:\", string, NULL);\n  if (g_regex_match_simple (MATCH_PATTERN_HTTP, string, G_REGEX_CASELESS, 0))\n    return g_strconcat (\"http:\n  return NULL;\n}", "target": 0}
{"code": "static inline void get_page(struct page *page)\n{\n\tpage = compound_head(page);\n\tVM_BUG_ON_PAGE(page_ref_count(page) <= 0, page);\n\tpage_ref_inc(page);\n}", "target": 1}
{"code": "static int truncate_inline_extent(struct inode *inode,\n\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t  struct btrfs_key *found_key,\n\t\t\t\t  const u64 item_end,\n\t\t\t\t  const u64 new_size)\n{\n\tstruct extent_buffer *leaf = path->nodes[0];\n\tint slot = path->slots[0];\n\tstruct btrfs_file_extent_item *fi;\n\tu32 size = (u32)(new_size - found_key->offset);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tfi = btrfs_item_ptr(leaf, slot, struct btrfs_file_extent_item);\n\tif (btrfs_file_extent_compression(leaf, fi) != BTRFS_COMPRESS_NONE) {\n\t\tloff_t offset = new_size;\n\t\tloff_t page_end = ALIGN(offset, PAGE_CACHE_SIZE);\n\t\tbtrfs_release_path(path);\n\t\treturn btrfs_truncate_page(inode, offset, page_end - offset, 0);\n\t}\n\tbtrfs_set_file_extent_ram_bytes(leaf, fi, size);\n\tsize = btrfs_file_extent_calc_inline_size(size);\n\tbtrfs_truncate_item(root, path, size, 1);\n\tif (test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\tinode_sub_bytes(inode, item_end + 1 - new_size);\n\treturn 0;\n}", "target": 0}
{"code": "nfsd4_layout_verify(struct svc_export *exp, unsigned int layout_type)\n{\n\tif (!exp->ex_layout_types) {\n\t\tdprintk(\"%s: export does not support pNFS\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tif (!(exp->ex_layout_types & (1 << layout_type))) {\n\t\tdprintk(\"%s: layout type %d not supported\\n\",\n\t\t\t__func__, layout_type);\n\t\treturn NULL;\n\t}\n\treturn nfsd4_layout_ops[layout_type];\n}", "target": 1}
{"code": "int iwch_cxgb3_ofld_send(struct t3cdev *tdev, struct sk_buff *skb)\n{\n\tint\terror = 0;\n\tstruct cxio_rdev *rdev;\n\trdev = (struct cxio_rdev *)tdev->ulp;\n\tif (cxio_fatal_error(rdev)) {\n\t\tkfree_skb(skb);\n\t\treturn -EIO;\n\t}\n\terror = cxgb3_ofld_send(tdev, skb);\n\tif (error < 0)\n\t\tkfree_skb(skb);\n\treturn error;\n}", "target": 1}
{"code": "void kvm_lapic_set_vapic_addr(struct kvm_vcpu *vcpu, gpa_t vapic_addr)\n{\n\tvcpu->arch.apic->vapic_addr = vapic_addr;\n\tif (vapic_addr)\n\t\t__set_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n\telse\n\t\t__clear_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n}", "target": 1}
{"code": "static int dynamicGetbuf(gdIOCtxPtr ctx, void *buf, int len)\n{\n\tint rlen, remain;\n\tdpIOCtxPtr dctx;\n\tdynamicPtr *dp;\n\tdctx = (dpIOCtxPtr) ctx;\n\tdp = dctx->dp;\n\tif (dp->pos < 0 || dp->pos >= dp->realSize) {\n\t\treturn 0;\n\t}\n\tremain = dp->logicalSize - dp->pos;\n\tif(remain >= len) {\n\t\trlen = len;\n\t} else {\n\t\tif(remain <= 0) {\n\t\t\treturn 0;\n\t\t}\n\t\trlen = remain;\n\t}\n\tif (dp->pos + rlen > dp->realSize) {\n\t\trlen = dp->realSize - dp->pos;\n\t}\n\tmemcpy(buf, (void *) ((char *)dp->data + dp->pos), rlen);\n\tdp->pos += rlen;\n\treturn rlen;\n}", "target": 0}
{"code": "ssize_t enc_untrusted_read(int fd, void *buf, size_t count) {\n  return static_cast<ssize_t>(EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_read, fd, buf, count));\n}", "target": 1}
{"code": "gss_delete_sec_context (minor_status,\n                        context_handle,\n                        output_token)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t *\t\tcontext_handle;\ngss_buffer_t\t\toutput_token;\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    status = val_del_sec_ctx_args(minor_status, context_handle, output_token);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n    ctx = (gss_union_ctx_id_t) *context_handle;\n    if (GSSINT_CHK_LOOP(ctx))\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n    status = gssint_delete_internal_sec_context(minor_status,\n\t\t\t\t\t\tctx->mech_type,\n\t\t\t\t\t\t&ctx->internal_ctx_id,\n\t\t\t\t\t\toutput_token);\n    if (status)\n\treturn status;\n    free(ctx->mech_type->elements);\n    free(ctx->mech_type);\n    free(*context_handle);\n    *context_handle = GSS_C_NO_CONTEXT;\n    return (GSS_S_COMPLETE);\n}", "target": 1}
{"code": "static inline const void *choose_neigh_daddr(struct rt6_info *rt,\n\t\t\t\t\t     struct sk_buff *skb,\n\t\t\t\t\t     const void *daddr)\n{\n\tstruct in6_addr *p = &rt->rt6i_gateway;\n\tif (!ipv6_addr_any(p))\n\t\treturn (const void *) p;\n\telse if (skb)\n\t\treturn &ipv6_hdr(skb)->daddr;\n\treturn daddr;\n}", "target": 0}
{"code": "webSocketsHasDataInBuffer(rfbClientPtr cl)\n{\n    ws_ctx_t *wsctx = (ws_ctx_t *)cl->wsctx;\n    if (wsctx && wsctx->readbuflen)\n      return TRUE;\n    return (cl->sslctx && rfbssl_pending(cl) > 0);\n}", "target": 1}
{"code": "lzw_result lzw_decode(struct lzw_ctx *ctx,\n\t\tconst uint8_t ** const stack_pos_out)\n{\n\tlzw_result res;\n\tuint32_t code_new;\n\tuint32_t code_out;\n\tuint8_t last_value;\n\tuint8_t *stack_pos = ctx->stack_base;\n\tuint32_t clear_code = ctx->clear_code;\n\tuint32_t current_entry = ctx->current_entry;\n\tstruct lzw_dictionary_entry * const table = ctx->table;\n\tres = lzw__next_code(&ctx->input, ctx->current_code_size, &code_new);\n\tif (res != LZW_OK) {\n\t\treturn res;\n\t}\n\tif (code_new == clear_code) {\n\t\treturn lzw__clear_codes(ctx, stack_pos_out);\n\t} else if (code_new == ctx->eoi_code) {\n\t\treturn LZW_EOI_CODE;\n\t} else if (code_new > current_entry) {\n\t\treturn LZW_BAD_CODE;\n\t} else if (code_new >= 1 << LZW_CODE_MAX) {\n\t\treturn LZW_BAD_CODE;\n\t} else if (code_new < current_entry) {\n\t\tcode_out = code_new;\n\t\tlast_value = table[code_new].first_value;\n\t} else {\n\t\t*stack_pos++ = ctx->previous_code_first;\n\t\tcode_out = ctx->previous_code;\n\t\tlast_value = ctx->previous_code_first;\n\t}\n\tif (current_entry < (1 << LZW_CODE_MAX)) {\n\t\tstruct lzw_dictionary_entry *entry = table + current_entry;\n\t\tentry->last_value     = last_value;\n\t\tentry->first_value    = ctx->previous_code_first;\n\t\tentry->previous_entry = ctx->previous_code;\n\t\tctx->current_entry++;\n\t}\n\tif (current_entry == ctx->current_code_size_max) {\n\t\tif (ctx->current_code_size < LZW_CODE_MAX) {\n\t\t\tctx->current_code_size++;\n\t\t\tctx->current_code_size_max =\n\t\t\t\t\t(1 << ctx->current_code_size) - 1;\n\t\t}\n\t}\n\tctx->previous_code_first = table[code_new].first_value;\n\tctx->previous_code = code_new;\n\twhile (code_out > clear_code) {\n\t\tstruct lzw_dictionary_entry *entry = table + code_out;\n\t\t*stack_pos++ = entry->last_value;\n\t\tcode_out = entry->previous_entry;\n\t}\n\t*stack_pos++ = table[code_out].last_value;\n\t*stack_pos_out = stack_pos;\n\treturn LZW_OK;\n}", "target": 0}
{"code": "const TfLiteTensor* GetIntermediates(TfLiteContext* context,\n                                     const TfLiteNode* node, int index) {\n  const int tensor_index = ValidateTensorIndexing(\n      context, index, node->intermediates->size, node->intermediates->data);\n  if (tensor_index < 0) {\n    return nullptr;\n  }\n  return GetTensorAtIndex(context, tensor_index);\n}", "target": 0}
{"code": "static int hci_sock_blacklist_add(struct hci_dev *hdev, void __user *arg)\n{\n\tbdaddr_t bdaddr;\n\tint err;\n\tif (copy_from_user(&bdaddr, arg, sizeof(bdaddr)))\n\t\treturn -EFAULT;\n\thci_dev_lock(hdev);\n\terr = hci_blacklist_add(hdev, &bdaddr, 0);\n\thci_dev_unlock(hdev);\n\treturn err;\n}", "target": 0}
{"code": "ssize_t enc_untrusted_recvmsg(int sockfd, struct msghdr *msg, int flags) {\n  size_t total_buffer_size = CalculateTotalMessageSize(msg);\n  MessageWriter input;\n  input.Push(sockfd);\n  input.Push<uint64_t>(msg->msg_namelen);\n  input.Push<uint64_t>(total_buffer_size);\n  input.Push<uint64_t>(msg->msg_controllen);\n  input.Push(msg->msg_flags);\n  input.Push(flags);\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kRecvMsgHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_recvmsg\", 2,\n                           false);\n  ssize_t result = output.next<ssize_t>();\n  int klinux_errno = output.next<int>();\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return result;\n  }\n  if (result > total_buffer_size) {\n    ::asylo::primitives::TrustedPrimitives::BestEffortAbort(\n        \"enc_untrusted_recvmsg: result exceeds requested\");\n  }\n  auto msg_name_extent = output.next();\n  if (msg_name_extent.size() <= msg->msg_namelen) {\n    msg->msg_namelen = msg_name_extent.size();\n  }\n  memcpy(msg->msg_name, msg_name_extent.As<char>(), msg->msg_namelen);\n  auto msg_iov_extent = output.next();\n  size_t total_bytes = msg_iov_extent.size();\n  size_t bytes_copied = 0;\n  for (int i = 0; i < msg->msg_iovlen && bytes_copied < total_bytes; ++i) {\n    size_t bytes_to_copy =\n        std::min(msg->msg_iov[i].iov_len, total_bytes - bytes_copied);\n    memcpy(msg->msg_iov[i].iov_base, msg_iov_extent.As<char>() + bytes_copied,\n           bytes_to_copy);\n    bytes_copied += bytes_to_copy;\n  }\n  auto msg_control_extent = output.next();\n  if (msg_control_extent.size() <= msg->msg_controllen) {\n    msg->msg_controllen = msg_control_extent.size();\n  }\n  memcpy(msg->msg_control, msg_control_extent.As<char>(), msg->msg_controllen);\n  return result;\n}", "target": 0}
{"code": "struct chunk *error_message(struct session *s, int msgnum)\n{\n\tif (s->be->errmsg[msgnum].str)\n\t\treturn &s->be->errmsg[msgnum];\n\telse if (s->fe->errmsg[msgnum].str)\n\t\treturn &s->fe->errmsg[msgnum];\n\telse\n\t\treturn &http_err_chunks[msgnum];\n}", "target": 0}
{"code": "static int send_acknowledge(struct nci_spi *nspi, u8 acknowledge)\n{\n\tstruct sk_buff *skb;\n\tunsigned char *hdr;\n\tu16 crc;\n\tint ret;\n\tskb = nci_skb_alloc(nspi->ndev, 0, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\thdr = skb_push(skb, NCI_SPI_HDR_LEN);\n\thdr[0] = NCI_SPI_DIRECT_WRITE;\n\thdr[1] = NCI_SPI_CRC_ENABLED;\n\thdr[2] = acknowledge << NCI_SPI_ACK_SHIFT;\n\thdr[3] = 0;\n\tcrc = crc_ccitt(CRC_INIT, skb->data, skb->len);\n\tskb_put_u8(skb, crc >> 8);\n\tskb_put_u8(skb, crc & 0xFF);\n\tret = __nci_spi_send(nspi, skb, 0);\n\tkfree_skb(skb);\n\treturn ret;\n}", "target": 0}
{"code": "njs_typed_array_set_value(njs_vm_t *vm, njs_typed_array_t *array,\n    uint32_t index, njs_value_t *setval)\n{\n    double              num;\n    njs_int_t           ret;\n    njs_array_buffer_t  *buffer;\n    ret = njs_value_to_number(vm, setval, &num);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    buffer = njs_typed_array_writable(vm, array);\n    if (njs_slow_path(buffer == NULL)) {\n        return NJS_ERROR;\n    }\n    njs_typed_array_prop_set(vm, array, index, num);\n    njs_set_number(setval, num);\n    return NJS_OK;\n}", "target": 1}
{"code": "void take_dentry_name_snapshot(struct name_snapshot *name, struct dentry *dentry)\n{\n\tspin_lock(&dentry->d_lock);\n\tif (unlikely(dname_external(dentry))) {\n\t\tstruct external_name *p = external_name(dentry);\n\t\tatomic_inc(&p->u.count);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tname->name = p->name;\n\t} else {\n\t\tmemcpy(name->inline_name, dentry->d_iname, DNAME_INLINE_LEN);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tname->name = name->inline_name;\n\t}\n}", "target": 0}
{"code": "R_API RBinJavaAttrInfo *r_bin_java_source_debug_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut64 offset = 6;\n\tif (sz < 8) {\n\t\treturn NULL;\n\t}\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_SOURCE_DEBUG_EXTENTSION_ATTR;\n\tif (attr->length == 0) {\n\t\teprintf (\"r_bin_java_source_debug_attr_new: Attempting to allocate 0 bytes for debug_extension.\\n\");\n\t\tattr->info.debug_extensions.debug_extension = NULL;\n\t\treturn attr;\n\t} else if ((attr->length + offset) > sz) {\n\t\teprintf (\"r_bin_java_source_debug_attr_new: Expected %d byte(s) got %\"\n\t\t\tPFMT64d \" bytes for debug_extension.\\n\", attr->length, (offset + sz));\n\t}\n\tattr->info.debug_extensions.debug_extension = (ut8 *) malloc (attr->length);\n\tif (attr->info.debug_extensions.debug_extension && (attr->length > (sz - offset))) {\n\t\tmemcpy (attr->info.debug_extensions.debug_extension, buffer + offset, sz - offset);\n\t} else if (attr->info.debug_extensions.debug_extension) {\n\t\tmemcpy (attr->info.debug_extensions.debug_extension, buffer + offset, attr->length);\n\t} else {\n\t\teprintf (\"r_bin_java_source_debug_attr_new: Unable to allocate the data for the debug_extension.\\n\");\n\t}\n\toffset += attr->length;\n\tattr->size = offset;\n\treturn attr;\n}", "target": 0}
{"code": "static ut64 r_buf_read64le (RBuffer *buf, ut64 off) {\n\tut8 data[8] = {0};\n\tr_buf_read_at (buf, off, data, 8);\n\treturn r_read_le64 (data);\n}", "target": 0}
{"code": "static int cdrom_ioctl_drive_status(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_DRIVE_STATUS\\n\");\n\tif (!(cdi->ops->capability & CDC_DRIVE_STATUS))\n\t\treturn -ENOSYS;\n\tif (!CDROM_CAN(CDC_SELECT_DISC) ||\n\t    (arg == CDSL_CURRENT || arg == CDSL_NONE))\n\t\treturn cdi->ops->drive_status(cdi, CDSL_CURRENT);\n\tif (((int)arg >= cdi->capacity))\n\t\treturn -EINVAL;\n\treturn cdrom_slot_status(cdi, arg);\n}", "target": 1}
{"code": "static unsigned long randomize_stack_top(unsigned long stack_top)\n{\n\tunsigned int random_variable = 0;\n\tif ((current->flags & PF_RANDOMIZE) &&\n\t\t!(current->personality & ADDR_NO_RANDOMIZE)) {\n\t\trandom_variable = get_random_int() & STACK_RND_MASK;\n\t\trandom_variable <<= PAGE_SHIFT;\n\t}\n#ifdef CONFIG_STACK_GROWSUP\n\treturn PAGE_ALIGN(stack_top) + random_variable;\n#else\n\treturn PAGE_ALIGN(stack_top) - random_variable;\n#endif\n}", "target": 1}
{"code": "int cx23888_ir_probe(struct cx23885_dev *dev)\n{\n\tstruct cx23888_ir_state *state;\n\tstruct v4l2_subdev *sd;\n\tstruct v4l2_subdev_ir_parameters default_params;\n\tint ret;\n\tstate = kzalloc(sizeof(struct cx23888_ir_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&state->rx_kfifo_lock);\n\tif (kfifo_alloc(&state->rx_kfifo, CX23888_IR_RX_KFIFO_SIZE, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\tstate->dev = dev;\n\tsd = &state->sd;\n\tv4l2_subdev_init(sd, &cx23888_ir_controller_ops);\n\tv4l2_set_subdevdata(sd, state);\n\tsnprintf(sd->name, sizeof(sd->name), \"%s/888-ir\", dev->name);\n\tsd->grp_id = CX23885_HW_888_IR;\n\tret = v4l2_device_register_subdev(&dev->v4l2_dev, sd);\n\tif (ret == 0) {\n\t\tcx23888_ir_write4(dev, CX23888_IR_IRQEN_REG, 0);\n\t\tmutex_init(&state->rx_params_lock);\n\t\tdefault_params = default_rx_params;\n\t\tv4l2_subdev_call(sd, ir, rx_s_parameters, &default_params);\n\t\tmutex_init(&state->tx_params_lock);\n\t\tdefault_params = default_tx_params;\n\t\tv4l2_subdev_call(sd, ir, tx_s_parameters, &default_params);\n\t} else {\n\t\tkfifo_free(&state->rx_kfifo);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "u8 *nfc_llcp_general_bytes(struct nfc_dev *dev, size_t *general_bytes_len)\n{\n\tstruct nfc_llcp_local *local;\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\t*general_bytes_len = 0;\n\t\treturn NULL;\n\t}\n\tnfc_llcp_build_gb(local);\n\t*general_bytes_len = local->gb_len;\n\tnfc_llcp_local_put(local);\n\treturn local->gb;\n}", "target": 0}
{"code": "static int handle_vmptrst(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tu32 vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\tgva_t vmcs_gva;\n\tstruct x86_exception e;\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\tif (get_vmx_mem_address(vcpu, exit_qualification,\n\t\t\tvmx_instruction_info, true, &vmcs_gva))\n\t\treturn 1;\n\tif (kvm_write_guest_virt_system(&vcpu->arch.emulate_ctxt, vmcs_gva,\n\t\t\t\t (void *)&to_vmx(vcpu)->nested.current_vmptr,\n\t\t\t\t sizeof(u64), &e)) {\n\t\tkvm_inject_page_fault(vcpu, &e);\n\t\treturn 1;\n\t}\n\tnested_vmx_succeed(vcpu);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}", "target": 1}
{"code": "CURLcode Curl_urldecode(struct SessionHandle *data,\n                        const char *string, size_t length,\n                        char **ostring, size_t *olen,\n                        bool reject_ctrl)\n{\n  size_t alloc = (length?length:strlen(string))+1;\n  char *ns = malloc(alloc);\n  unsigned char in;\n  size_t strindex=0;\n  unsigned long hex;\n  CURLcode res;\n  if(!ns)\n    return CURLE_OUT_OF_MEMORY;\n  while(--alloc > 0) {\n    in = *string;\n    if(('%' == in) && ISXDIGIT(string[1]) && ISXDIGIT(string[2])) {\n      char hexstr[3];\n      char *ptr;\n      hexstr[0] = string[1];\n      hexstr[1] = string[2];\n      hexstr[2] = 0;\n      hex = strtoul(hexstr, &ptr, 16);\n      in = curlx_ultouc(hex); \n      res = Curl_convert_from_network(data, &in, 1);\n      if(res) {\n        free(ns);\n        return res;\n      }\n      string+=2;\n      alloc-=2;\n    }\n    if(reject_ctrl && (in < 0x20)) {\n      free(ns);\n      return CURLE_URL_MALFORMAT;\n    }\n    ns[strindex++] = in;\n    string++;\n  }\n  ns[strindex]=0; \n  if(olen)\n    *olen = strindex;\n  if(ostring)\n    *ostring = ns;\n  return CURLE_OK;\n}", "target": 0}
{"code": "bool inode_capable(const struct inode *inode, int cap)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\treturn ns_capable(ns, cap) && kuid_has_mapping(ns, inode->i_uid);\n}", "target": 1}
{"code": "static int fsmDoMkDir(rpmPlugins plugins, int dirfd, const char *dn,\n\t\t\tint owned, mode_t mode)\n{\n    int rc;\n    rpmFsmOp op = (FA_CREATE);\n    if (!owned)\n\top |= FAF_UNOWNED;\n    rc = rpmpluginsCallFsmFilePre(plugins, NULL, dn, mode, op);\n    if (!rc)\n\trc = fsmMkdir(dirfd, dn, mode);\n    if (!rc) {\n\trc = rpmpluginsCallFsmFilePrepare(plugins, NULL, dn, dn, mode, op);\n    }\n    rpmpluginsCallFsmFilePost(plugins, NULL, dn, mode, op, rc);\n    if (!rc) {\n\trpmlog(RPMLOG_DEBUG,\n\t\t\"%s directory created with perms %04o\\n\",\n\t\tdn, (unsigned)(mode & 07777));\n    }\n    return rc;\n}", "target": 0}
{"code": "resolve_iffeature(struct lys_iffeature *expr)\n{\n    int index_e = 0, index_f = 0;\n    if (expr->expr) {\n        return resolve_iffeature_recursive(expr, &index_e, &index_f);\n    }\n    return 0;\n}", "target": 1}
{"code": "max3421_set_address(struct usb_hcd *hcd, struct usb_device *dev, int epnum,\n\t\t    int force_toggles)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tint old_epnum, same_ep, rcvtog, sndtog;\n\tstruct usb_device *old_dev;\n\tu8 hctl;\n\told_dev = max3421_hcd->loaded_dev;\n\told_epnum = max3421_hcd->loaded_epnum;\n\tsame_ep = (dev == old_dev && epnum == old_epnum);\n\tif (same_ep && !force_toggles)\n\t\treturn;\n\tif (old_dev && !same_ep) {\n\t\tu8 hrsl = spi_rd8(hcd, MAX3421_REG_HRSL);\n\t\trcvtog = (hrsl >> MAX3421_HRSL_RCVTOGRD_BIT) & 1;\n\t\tsndtog = (hrsl >> MAX3421_HRSL_SNDTOGRD_BIT) & 1;\n\t\tusb_settoggle(old_dev, old_epnum, 0, rcvtog);\n\t\tusb_settoggle(old_dev, old_epnum, 1, sndtog);\n\t}\n\trcvtog = usb_gettoggle(dev, epnum, 0);\n\tsndtog = usb_gettoggle(dev, epnum, 1);\n\thctl = (BIT(rcvtog + MAX3421_HCTL_RCVTOG0_BIT) |\n\t\tBIT(sndtog + MAX3421_HCTL_SNDTOG0_BIT));\n\tmax3421_hcd->loaded_epnum = epnum;\n\tspi_wr8(hcd, MAX3421_REG_HCTL, hctl);\n\tmax3421_hcd->loaded_dev = dev;\n\tspi_wr8(hcd, MAX3421_REG_PERADDR, dev->devnum);\n}", "target": 1}
{"code": "static int sclp_ctl_ioctl_sccb(void __user *user_area)\n{\n\tstruct sclp_ctl_sccb ctl_sccb;\n\tstruct sccb_header *sccb;\n\tint rc;\n\tif (copy_from_user(&ctl_sccb, user_area, sizeof(ctl_sccb)))\n\t\treturn -EFAULT;\n\tif (!sclp_ctl_cmdw_supported(ctl_sccb.cmdw))\n\t\treturn -EOPNOTSUPP;\n\tsccb = (void *) get_zeroed_page(GFP_KERNEL | GFP_DMA);\n\tif (!sccb)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(sccb, u64_to_uptr(ctl_sccb.sccb), sizeof(*sccb))) {\n\t\trc = -EFAULT;\n\t\tgoto out_free;\n\t}\n\tif (sccb->length > PAGE_SIZE || sccb->length < 8)\n\t\treturn -EINVAL;\n\tif (copy_from_user(sccb, u64_to_uptr(ctl_sccb.sccb), sccb->length)) {\n\t\trc = -EFAULT;\n\t\tgoto out_free;\n\t}\n\trc = sclp_sync_request(ctl_sccb.cmdw, sccb);\n\tif (rc)\n\t\tgoto out_free;\n\tif (copy_to_user(u64_to_uptr(ctl_sccb.sccb), sccb, sccb->length))\n\t\trc = -EFAULT;\nout_free:\n\tfree_page((unsigned long) sccb);\n\treturn rc;\n}", "target": 1}
{"code": "static int snd_timer_s_stop(struct snd_timer * timer)\n{\n\tstruct snd_timer_system_private *priv;\n\tunsigned long jiff;\n\tpriv = (struct snd_timer_system_private *) timer->private_data;\n\tdel_timer(&priv->tlist);\n\tjiff = jiffies;\n\tif (time_before(jiff, priv->last_expires))\n\t\ttimer->sticks = priv->last_expires - jiff;\n\telse\n\t\ttimer->sticks = 1;\n\tpriv->correction = 0;\n\treturn 0;\n}", "target": 0}
{"code": "static void ext4_end_io_buffer_write(struct buffer_head *bh, int uptodate)\n{\n\text4_io_end_t *io_end = bh->b_private;\n\tstruct workqueue_struct *wq;\n\tstruct inode *inode;\n\tunsigned long flags;\n\tif (!test_clear_buffer_uninit(bh) || !io_end)\n\t\tgoto out;\n\tif (!(io_end->inode->i_sb->s_flags & MS_ACTIVE)) {\n\t\tprintk(\"sb umounted, discard end_io request for inode %lu\\n\",\n\t\t\tio_end->inode->i_ino);\n\t\text4_free_io_end(io_end);\n\t\tgoto out;\n\t}\n\tio_end->flag = EXT4_IO_UNWRITTEN;\n\tinode = io_end->inode;\n\tspin_lock_irqsave(&EXT4_I(inode)->i_completed_io_lock, flags);\n\tlist_add_tail(&io_end->list, &EXT4_I(inode)->i_completed_io_list);\n\tspin_unlock_irqrestore(&EXT4_I(inode)->i_completed_io_lock, flags);\n\twq = EXT4_SB(inode->i_sb)->dio_unwritten_wq;\n\tqueue_work(wq, &io_end->work);\nout:\n\tbh->b_private = NULL;\n\tbh->b_end_io = NULL;\n\tclear_buffer_uninit(bh);\n\tend_buffer_async_write(bh, uptodate);\n}", "target": 0}
{"code": "static int clgi_interception(struct vcpu_svm *svm)\n{\n\tif (nested_svm_check_permissions(svm))\n\t\treturn 1;\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 3;\n\tskip_emulated_instruction(&svm->vcpu);\n\tdisable_gif(svm);\n\tsvm_clear_vintr(svm);\n\tsvm->vmcb->control.int_ctl &= ~V_IRQ_MASK;\n\tmark_dirty(svm->vmcb, VMCB_INTR);\n\treturn 1;\n}", "target": 0}
{"code": "int imap_subscribe(char *path, bool subscribe)\n{\n  struct ImapData *idata = NULL;\n  char buf[LONG_STRING];\n  char mbox[LONG_STRING];\n  char errstr[STRING];\n  struct Buffer err, token;\n  struct ImapMbox mx;\n  if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)\n  {\n    mutt_error(_(\"Bad mailbox name\"));\n    return -1;\n  }\n  idata = imap_conn_find(&(mx.account), 0);\n  if (!idata)\n    goto fail;\n  imap_fix_path(idata, mx.mbox, buf, sizeof(buf));\n  if (!*buf)\n    mutt_str_strfcpy(buf, \"INBOX\", sizeof(buf));\n  if (ImapCheckSubscribed)\n  {\n    mutt_buffer_init(&token);\n    mutt_buffer_init(&err);\n    err.data = errstr;\n    err.dsize = sizeof(errstr);\n    snprintf(mbox, sizeof(mbox), \"%smailboxes \\\"%s\\\"\", subscribe ? \"\" : \"un\", path);\n    if (mutt_parse_rc_line(mbox, &token, &err))\n      mutt_debug(1, \"Error adding subscribed mailbox: %s\\n\", errstr);\n    FREE(&token.data);\n  }\n  if (subscribe)\n    mutt_message(_(\"Subscribing to %s...\"), buf);\n  else\n    mutt_message(_(\"Unsubscribing from %s...\"), buf);\n  imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf);\n  snprintf(buf, sizeof(buf), \"%sSUBSCRIBE %s\", subscribe ? \"\" : \"UN\", mbox);\n  if (imap_exec(idata, buf, 0) < 0)\n    goto fail;\n  imap_unmunge_mbox_name(idata, mx.mbox);\n  if (subscribe)\n    mutt_message(_(\"Subscribed to %s\"), mx.mbox);\n  else\n    mutt_message(_(\"Unsubscribed from %s\"), mx.mbox);\n  FREE(&mx.mbox);\n  return 0;\nfail:\n  FREE(&mx.mbox);\n  return -1;\n}", "target": 1}
{"code": "static void mctp_unregister(struct net_device *dev)\n{\n\tstruct mctp_dev *mdev;\n\tmdev = mctp_dev_get_rtnl(dev);\n\tif (mdev && !mctp_known(dev)) {\n\t\tnetdev_warn(dev, \"%s: BUG mctp_ptr set for unknown type %d\",\n\t\t\t    __func__, dev->type);\n\t\treturn;\n\t}\n\tif (!mdev)\n\t\treturn;\n\tRCU_INIT_POINTER(mdev->dev->mctp_ptr, NULL);\n\tmctp_route_remove_dev(mdev);\n\tmctp_neigh_remove_dev(mdev);\n\tkfree(mdev->addrs);\n\tmctp_dev_put(mdev);\n}", "target": 1}
{"code": "static unsigned int ip6_hashfn(struct inet_frag_queue *q)\n{\n\tstruct frag_queue *fq;\n\tfq = container_of(q, struct frag_queue, q);\n\treturn inet6_hash_frag(fq->id, &fq->saddr, &fq->daddr, ip6_frags.rnd);\n}", "target": 0}
{"code": "static inline unsigned char unimap_bsearch(const uni_to_enc *table, unsigned code_key_a, size_t num)\n{\n\tconst uni_to_enc *l = table,\n\t\t\t\t\t *h = &table[num-1],\n\t\t\t\t\t *m;\n\tunsigned short code_key;\n\tif (code_key_a > 0xFFFFU)\n\t\treturn 0;\n\tcode_key = (unsigned short) code_key_a;\n\twhile (l <= h) {\n\t\tm = l + (h - l) / 2;\n\t\tif (code_key < m->un_code_point)\n\t\t\th = m - 1;\n\t\telse if (code_key > m->un_code_point)\n\t\t\tl = m + 1;\n\t\telse\n\t\t\treturn m->cs_code;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "bgp_capability_restart (struct peer *peer, struct capability_header *caphdr)\n{\n  struct stream *s = BGP_INPUT (peer);\n  u_int16_t restart_flag_time;\n  int restart_bit = 0;\n  size_t end = stream_get_getp (s) + caphdr->length;\n  SET_FLAG (peer->cap, PEER_CAP_RESTART_RCV);\n  restart_flag_time = stream_getw(s);\n  if (CHECK_FLAG (restart_flag_time, RESTART_R_BIT))\n    restart_bit = 1;\n  UNSET_FLAG (restart_flag_time, 0xF000);\n  peer->v_gr_restart = restart_flag_time;\n  if (BGP_DEBUG (normal, NORMAL))\n    {\n      zlog_debug (\"%s OPEN has Graceful Restart capability\", peer->host);\n      zlog_debug (\"%s Peer has%srestarted. Restart Time : %d\",\n                  peer->host, restart_bit ? \" \" : \" not \",\n                  peer->v_gr_restart);\n    }\n  while (stream_get_getp (s) + 4 < end)\n    {\n      afi_t afi = stream_getw (s);\n      safi_t safi = stream_getc (s);\n      u_char flag = stream_getc (s);\n      if (!bgp_afi_safi_valid_indices (afi, &safi))\n        {\n          if (BGP_DEBUG (normal, NORMAL))\n            zlog_debug (\"%s Addr-family %d/%d(afi/safi) not supported.\"\n                        \" Ignore the Graceful Restart capability\",\n                        peer->host, afi, safi);\n        }\n      else if (!peer->afc[afi][safi])\n        {\n          if (BGP_DEBUG (normal, NORMAL))\n            zlog_debug (\"%s Addr-family %d/%d(afi/safi) not enabled.\"\n                        \" Ignore the Graceful Restart capability\",\n                        peer->host, afi, safi);\n        }\n      else\n        {\n          if (BGP_DEBUG (normal, NORMAL))\n            zlog_debug (\"%s Address family %s is%spreserved\", peer->host,\n                        afi_safi_print (afi, safi),\n                        CHECK_FLAG (peer->af_cap[afi][safi],\n                                    PEER_CAP_RESTART_AF_PRESERVE_RCV)\n                        ? \" \" : \" not \");\n          SET_FLAG (peer->af_cap[afi][safi], PEER_CAP_RESTART_AF_RCV);\n          if (CHECK_FLAG (flag, RESTART_F_BIT))\n            SET_FLAG (peer->af_cap[afi][safi], PEER_CAP_RESTART_AF_PRESERVE_RCV);\n        }\n    }\n  return 0;\n}", "target": 0}
{"code": "void CLASS parse_qt (int end)\n{\n  unsigned save, size;\n  char tag[4];\n  order = 0x4d4d;\n  while (ftell(ifp)+7 < end) {\n    save = ftell(ifp);\n    if ((size = get4()) < 8) return;\n    if ((int)size < 0) return; \n    if (save + size < save) return; \n    fread (tag, 4, 1, ifp);\n    if (!memcmp(tag,\"moov\",4) ||\n\t!memcmp(tag,\"udta\",4) ||\n\t!memcmp(tag,\"CNTH\",4))\n      parse_qt (save+size);\n    if (!memcmp(tag,\"CNDA\",4))\n      parse_jpeg (ftell(ifp));\n    fseek (ifp, save+size, SEEK_SET);\n  }\n}", "target": 0}
{"code": "juniper_atm1_print(netdissect_options *ndo,\n                   const struct pcap_pkthdr *h, register const u_char *p)\n{\n        int llc_hdrlen;\n        struct juniper_l2info_t l2info;\n        l2info.pictype = DLT_JUNIPER_ATM1;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n        p+=l2info.header_len;\n        if (l2info.cookie[0] == 0x80) { \n            oam_print(ndo, p, l2info.length, ATM_OAM_NOHEC);\n            return l2info.header_len;\n        }\n        ND_TCHECK2(p[0], 3);\n        if (EXTRACT_24BITS(p) == 0xfefe03 || \n            EXTRACT_24BITS(p) == 0xaaaa03) { \n            llc_hdrlen = llc_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL);\n            if (llc_hdrlen > 0)\n                return l2info.header_len;\n        }\n        if (p[0] == 0x03) { \n            isoclns_print(ndo, p + 1, l2info.length - 1);\n            return l2info.header_len;\n        }\n        if (ip_heuristic_guess(ndo, p, l2info.length) != 0) \n            return l2info.header_len;\n\treturn l2info.header_len;\ntrunc:\n\tND_PRINT((ndo, \"[|juniper_atm1]\"));\n\treturn l2info.header_len;\n}", "target": 0}
{"code": "  CloseNotifyConnector(EventBase* evb, const SocketAddress& addr) {\n    evb_ = evb;\n    ssl_ = AsyncSSLSocket::newSocket(std::make_shared<SSLContext>(), evb_);\n    ssl_->connect(this, addr);\n  }", "target": 0}
{"code": "int generic_permission(struct inode *inode, int mask)\n{\n\tint ret;\n\tret = acl_permission_check(inode, mask);\n\tif (ret != -EACCES)\n\t\treturn ret;\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tif (inode_capable(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\t\tif (!(mask & MAY_WRITE))\n\t\t\tif (inode_capable(inode, CAP_DAC_READ_SEARCH))\n\t\t\t\treturn 0;\n\t\treturn -EACCES;\n\t}\n\tif (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))\n\t\tif (inode_capable(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\tif (mask == MAY_READ)\n\t\tif (inode_capable(inode, CAP_DAC_READ_SEARCH))\n\t\t\treturn 0;\n\treturn -EACCES;\n}", "target": 1}
{"code": "init_connection_options(MYSQL *mysql)\n{\n#if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)\n  if (opt_use_ssl)\n  {\n    mysql_ssl_set(mysql, opt_ssl_key, opt_ssl_cert, opt_ssl_ca,\n                  opt_ssl_capath, opt_ssl_cipher);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRL, opt_ssl_crl);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRLPATH, opt_ssl_crlpath);\n  }\n  mysql_options(mysql, MYSQL_OPT_SSL_VERIFY_SERVER_CERT,\n                (char*) &opt_ssl_verify_server_cert);\n#endif\n  if (opt_protocol)\n    mysql_options(mysql, MYSQL_OPT_PROTOCOL, (char*) &opt_protocol);\n#ifdef HAVE_SMEM\n  if (shared_memory_base_name)\n    mysql_options(mysql, MYSQL_SHARED_MEMORY_BASE_NAME, shared_memory_base_name);\n#endif\n}", "target": 1}
{"code": "bool Archive::Open(const wchar *Name,uint Mode)\n{\n#ifdef USE_QOPEN\n  QOpen.Unload();\n#endif\n#ifdef USE_ARCMEM\n  if (Cmd->ArcInMem)\n  {\n    wcsncpyz(FileName,Name,ASIZE(FileName));\n    ArcMem.Load(Cmd->ArcMemData,Cmd->ArcMemSize);\n    Cmd->SetArcInMem(NULL,0); \n    return true;\n  }\n#endif\n  return File::Open(Name,Mode);\n}", "target": 0}
{"code": "BOOL rdp_read_share_control_header(wStream* s, UINT16* length, UINT16* type, UINT16* channel_id)\n{\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\treturn FALSE;\n\tStream_Read_UINT16(s, *length); \n\tif (*length == 0x8000)\n\t{\n\t\trdp_read_flow_control_pdu(s, type);\n\t\t*channel_id = 0;\n\t\t*length = 8; \n\t\treturn TRUE;\n\t}\n\tif (((size_t)*length - 2) > Stream_GetRemainingLength(s))\n\t\treturn FALSE;\n\tStream_Read_UINT16(s, *type); \n\t*type &= 0x0F;                \n\tif (*length > 4)\n\t\tStream_Read_UINT16(s, *channel_id); \n\telse\n\t\t*channel_id = 0; \n\treturn TRUE;\n}", "target": 1}
{"code": "static int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_cdef_t *cdef = &box->data.cdef;\n\tjp2_cdefchan_t *chan;\n\tunsigned int channo;\n\tcdef->ents = 0;\n\tif (jp2_getuint16(in, &cdef->numchans)) {\n\t\treturn -1;\n\t}\n\tif (!(cdef->ents = jas_alloc2(cdef->numchans, sizeof(jp2_cdefchan_t)))) {\n\t\treturn -1;\n\t}\n\tfor (channo = 0; channo < cdef->numchans; ++channo) {\n\t\tchan = &cdef->ents[channo];\n\t\tif (jp2_getuint16(in, &chan->channo) || jp2_getuint16(in, &chan->type) ||\n\t\t  jp2_getuint16(in, &chan->assoc)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void *HtpGetTxForH2(void *alstate)\n{\n    HtpState *http_state = (HtpState *)alstate;\n    if (http_state != NULL && http_state->conn != NULL) {\n        size_t txid = htp_list_array_size(http_state->conn->transactions);\n        if (txid > 0) {\n            return htp_list_get(http_state->conn->transactions, txid - 1);\n        }\n    }\n    return NULL;\n}", "target": 1}
{"code": "static entity_table_opt determine_entity_table(int all, int doctype)\n{\n\tentity_table_opt retval = {NULL};\n\tassert(!(doctype == ENT_HTML_DOC_XML1 && all));\n\tif (all) {\n\t\tretval.ms_table = (doctype == ENT_HTML_DOC_HTML5) ?\n\t\t\tentity_ms_table_html5 : entity_ms_table_html4;\n\t} else {\n\t\tretval.table = (doctype == ENT_HTML_DOC_HTML401) ?\n\t\t\tstage3_table_be_noapos_00000 : stage3_table_be_apos_00000;\n\t}\n\treturn retval;\n}", "target": 0}
{"code": "static plist_t parse_string_node(const char **bnode, uint64_t size)\n{\n    plist_data_t data = plist_new_plist_data();\n    data->type = PLIST_STRING;\n    data->strval = (char *) malloc(sizeof(char) * (size + 1));\n    if (!data->strval) {\n        plist_free_data(data);\n        PLIST_BIN_ERR(\"%s: Could not allocate %\" PRIu64 \" bytes\\n\", __func__, sizeof(char) * (size + 1));\n        return NULL;\n    }\n    memcpy(data->strval, *bnode, size);\n    data->strval[size] = '\\0';\n    data->length = strlen(data->strval);\n    return node_create(NULL, data);\n}", "target": 0}
{"code": "static void jpeg2000_init_static_data(AVCodec *codec)\n{\n    ff_jpeg2000_init_tier1_luts();\n    ff_mqc_init_context_tables();\n}", "target": 0}
{"code": "static inline Quantum ClampPixel(const MagickRealType value)\n{\n#if !defined(MAGICKCORE_HDRI_SUPPORT)\n  return((Quantum) value);\n#else\n  if (value < 0.0f)\n    return(0.0);\n  if (value >= (MagickRealType) QuantumRange)\n    return((Quantum) QuantumRange);\n  return(value);\n#endif\n}", "target": 1}
{"code": "absl::Status Ipv6Instance::validateProtocolSupported() {\n  static const bool supported = SocketInterfaceSingleton::get().ipFamilySupported(AF_INET6);\n  if (supported) {\n    return absl::OkStatus();\n  }\n  return absl::FailedPreconditionError(\"IPv6 addresses are not supported on this machine\");\n}", "target": 1}
{"code": "static unsigned long mmap_legacy_base(unsigned long rnd)\n{\n\tif (mmap_is_ia32())\n\t\treturn TASK_UNMAPPED_BASE;\n\telse\n\t\treturn TASK_UNMAPPED_BASE + rnd;\n}", "target": 1}
{"code": "void sas_deform_port(struct asd_sas_phy *phy, int gone)\n{\n\tstruct sas_ha_struct *sas_ha = phy->ha;\n\tstruct asd_sas_port *port = phy->port;\n\tstruct sas_internal *si =\n\t\tto_sas_internal(sas_ha->core.shost->transportt);\n\tstruct domain_device *dev;\n\tunsigned long flags;\n\tif (!port)\n\t\treturn;\t\t  \n\tdev = port->port_dev;\n\tif (dev)\n\t\tdev->pathways--;\n\tif (port->num_phys == 1) {\n\t\tsas_unregister_domain_devices(port, gone);\n\t\tsas_destruct_devices(port);\n\t\tsas_port_delete(port->port);\n\t\tport->port = NULL;\n\t} else {\n\t\tsas_port_delete_phy(port->port, phy->phy);\n\t\tsas_device_set_phy(dev, port->port);\n\t}\n\tif (si->dft->lldd_port_deformed)\n\t\tsi->dft->lldd_port_deformed(phy);\n\tspin_lock_irqsave(&sas_ha->phy_port_lock, flags);\n\tspin_lock(&port->phy_list_lock);\n\tlist_del_init(&phy->port_phy_el);\n\tsas_phy_set_target(phy, NULL);\n\tphy->port = NULL;\n\tport->num_phys--;\n\tport->phy_mask &= ~(1U << phy->id);\n\tif (port->num_phys == 0) {\n\t\tINIT_LIST_HEAD(&port->phy_list);\n\t\tmemset(port->sas_addr, 0, SAS_ADDR_SIZE);\n\t\tmemset(port->attached_sas_addr, 0, SAS_ADDR_SIZE);\n\t\tport->class = 0;\n\t\tport->iproto = 0;\n\t\tport->tproto = 0;\n\t\tport->oob_mode = 0;\n\t\tport->phy_mask = 0;\n\t}\n\tspin_unlock(&port->phy_list_lock);\n\tspin_unlock_irqrestore(&sas_ha->phy_port_lock, flags);\n\treturn;\n}", "target": 0}
{"code": "int ecall_restore(const char *input, uint64_t input_len, char **output,\n                  uint64_t *output_len) {\n  if (!asylo::primitives::TrustedPrimitives::IsOutsideEnclave(input,\n                                                              input_len) ||\n      !asylo::primitives::TrustedPrimitives::IsOutsideEnclave(\n          output_len, sizeof(uint64_t)) ||\n      !asylo::primitives::TrustedPrimitives::IsOutsideEnclave(output,\n                                                              *output_len)) {\n    asylo::primitives::TrustedPrimitives::BestEffortAbort(\n        \"ecall_restore: input/output found to not be in untrusted memory.\");\n  }\n  int result = 0;\n  size_t tmp_output_len;\n  try {\n    result = asylo::Restore(input, static_cast<size_t>(input_len), output,\n                            &tmp_output_len);\n  } catch (...) {\n    LOG(FATAL) << \"Uncaught exception in enclave\";\n  }\n  if (output_len) {\n    *output_len = static_cast<uint64_t>(tmp_output_len);\n  }\n  return result;\n}", "target": 0}
{"code": "njs_function_closure_value(njs_vm_t *vm, njs_value_t **scope, njs_index_t index,\n    void *start, void *end)\n{\n    njs_value_t  *value, *newval;\n    value = scope[njs_scope_index_value(index)];\n    if (start <= (void *) value && end > (void *) value) {\n        newval = njs_mp_alloc(vm->mem_pool, sizeof(njs_value_t));\n        if (njs_slow_path(newval == NULL)) {\n            njs_memory_error(vm);\n            return NULL;\n        }\n        *newval = *value;\n        value = newval;\n    }\n    scope[njs_scope_index_value(index)] = value;\n    return value;\n}", "target": 0}
{"code": "generate_ava(cms_context *cms, SECItem *der, CERTAVA *certava)\n{\n\tava ava;\n\tSECOidData *oid;\n\tvoid *arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);\n\tif (arena == NULL)\n\t\tcnreterr(-1, cms, \"could not create arena\");\n\tvoid *real_arena = cms->arena;\n\tcms->arena = arena;\n\toid = SECOID_FindOID(&certava->type);\n\tif (!oid) {\n\t\tsave_port_err() {\n\t\t\tPORT_FreeArena(arena, PR_TRUE);\n\t\t}\n\t\tcms->arena = real_arena;\n\t\tcnreterr(-1, cms, \"could not find OID\");\n\t}\n\tint rc = generate_object_id(cms, &ava.type, oid->offset);\n\tif (rc < 0) {\n\t\tPORT_FreeArena(arena, PR_TRUE);\n\t\tcms->arena = real_arena;\n\t\treturn -1;\n\t}\n\tmemcpy(&ava.value, &certava->value, sizeof (ava.value));\n\tvoid *ret;\n\tSECItem tmp;\n\tret = SEC_ASN1EncodeItem(arena, &tmp, &ava, AVATemplate);\n\tif (ret == NULL) {\n\t\tsave_port_err() {\n\t\t\tPORT_FreeArena(arena, PR_TRUE);\n\t\t}\n\t\tcms->arena = real_arena;\n\t\tcnreterr(-1, cms, \"could not encode AVA\");\n\t}\n\tder->type = tmp.type;\n\tder->len = tmp.len;\n\tder->data = PORT_ArenaAlloc(real_arena, tmp.len);\n\tif (!der->data) {\n\t\tsave_port_err() {\n\t\t\tPORT_FreeArena(arena, PR_TRUE);\n\t\t}\n\t\tcms->arena = real_arena;\n\t\tcnreterr(-1, cms, \"could not allocate AVA\");\n\t}\n\tmemcpy(der->data, tmp.data, tmp.len);\n\tPORT_FreeArena(arena, PR_TRUE);\n\tcms->arena = real_arena;\n\treturn 0;\n}", "target": 0}
{"code": "SWFInput_stream_read(SWFInput input, unsigned char* buffer, int count)\n{\n\tstruct SWFInputStreamData *data = (struct SWFInputStreamData *) input->data;\n\tint need = input->offset + count - input->length;\n\tif ( need > 0 )\n\t{\n\t\tint num;\n\t\tdata->buffer =\n\t\t\t(unsigned char*) realloc(data->buffer,\n\t\t\t\t\t\t\tsizeof(unsigned char) * INPUTSTREAM_INCREMENT *\n\t\t\t\t\t\t\t(((input->offset + count) / INPUTSTREAM_INCREMENT) + 1));\n\t\tnum = fread(data->buffer + input->length,\n\t\t\t\t\t\t\t\tsizeof(unsigned char), need, data->file);\n\t\tinput->length += num;\n\t}\n\tif ( count > input->length - input->offset )\n\t\tcount = input->length - input->offset;\n\tmemcpy(buffer, data->buffer + input->offset, count);\n\treturn count;\n}", "target": 0}
{"code": "static void hog_exit(void)\n{\n\tif (suspend_supported)\n\t\tsuspend_exit();\n\tbtd_profile_unregister(&hog_profile);\n}", "target": 0}
{"code": "static gboolean irssi_ssl_verify(SSL *ssl, SSL_CTX *ctx, X509 *cert)\n{\n\tif (SSL_get_verify_result(ssl) != X509_V_OK) {\n\t\tunsigned char md[EVP_MAX_MD_SIZE];\n\t\tunsigned int n;\n\t\tchar *str;\n\t\tg_warning(\"Could not verify SSL servers certificate:\");\n\t\tif ((str = X509_NAME_oneline(X509_get_subject_name(cert), 0, 0)) == NULL)\n\t\t\tg_warning(\"  Could not get subject-name from peer certificate\");\n\t\telse {\n\t\t\tg_warning(\"  Subject : %s\", str);\n\t\t\tfree(str);\n\t\t}\n\t\tif ((str = X509_NAME_oneline(X509_get_issuer_name(cert), 0, 0)) == NULL)\n\t\t\tg_warning(\"  Could not get issuer-name from peer certificate\");\n\t\telse {\n\t\t\tg_warning(\"  Issuer  : %s\", str);\n\t\t\tfree(str);\n\t\t}\n\t\tif (! X509_digest(cert, EVP_md5(), md, &n))\n\t\t\tg_warning(\"  Could not get fingerprint from peer certificate\");\n\t\telse {\n\t\t\tchar hex[] = \"0123456789ABCDEF\";\n\t\t\tchar fp[EVP_MAX_MD_SIZE*3];\n\t\t\tif (n < sizeof(fp)) {\n\t\t\t\tunsigned int i;\n\t\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\t\tfp[i*3+0] = hex[(md[i] >> 4) & 0xF];\n\t\t\t\t\tfp[i*3+1] = hex[(md[i] >> 0) & 0xF];\n\t\t\t\t\tfp[i*3+2] = i == n - 1 ? '\\0' : ':';\n\t\t\t\t}\n\t\t\t\tg_warning(\"  MD5 Fingerprint : %s\", fp);\n\t\t\t}\n\t\t}\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "void ndpi_search_oracle(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow)\n{\n  struct ndpi_packet_struct *packet = &flow->packet;\n  u_int16_t dport = 0, sport = 0;\n  NDPI_LOG_DBG(ndpi_struct, \"search ORACLE\\n\");\n  if(packet->tcp != NULL) {\n    sport = ntohs(packet->tcp->source), dport = ntohs(packet->tcp->dest);\n    NDPI_LOG_DBG2(ndpi_struct, \"calculating ORACLE over tcp\\n\");\n    if ((dport == 1521 || sport == 1521)\n\t&&  (((packet->payload[0] == 0x07) && (packet->payload[1] == 0xff) && (packet->payload[2] == 0x00))\n\t     || ((packet->payload_packet_len >= 232) && ((packet->payload[0] == 0x00) || (packet->payload[0] == 0x01)) \n\t     && (packet->payload[1] != 0x00)\n\t     && (packet->payload[2] == 0x00)\n\t\t && (packet->payload[3] == 0x00)))) {\n      NDPI_LOG_INFO(ndpi_struct, \"found oracle\\n\");\n      ndpi_int_oracle_add_connection(ndpi_struct, flow);\n    } else if (packet->payload_packet_len == 213 && packet->payload[0] == 0x00 &&\n               packet->payload[1] == 0xd5 && packet->payload[2] == 0x00 &&\n               packet->payload[3] == 0x00 ) {\n      NDPI_LOG_INFO(ndpi_struct, \"found oracle\\n\");\n      ndpi_int_oracle_add_connection(ndpi_struct, flow);\n    }\n  } else {\n    NDPI_EXCLUDE_PROTO(ndpi_struct, flow);\n  }\n}", "target": 1}
{"code": "void conn_close_all(void) {\n    int i;\n    for (i = 0; i < max_fds; i++) {\n        if (conns[i] && conns[i]->state != conn_closed) {\n            conn_close(conns[i]);\n        }\n    }\n}", "target": 0}
{"code": "static void domain_remove_dev_info(struct dmar_domain *domain)\n{\n\tstruct device_domain_info *info, *tmp;\n\tunsigned long flags;\n\tspin_lock_irqsave(&device_domain_lock, flags);\n\tlist_for_each_entry_safe(info, tmp, &domain->devices, link)\n\t\t__dmar_remove_one_dev_info(info);\n\tspin_unlock_irqrestore(&device_domain_lock, flags);\n}", "target": 0}
{"code": "_pdfioDictSetValue(\n    pdfio_dict_t   *dict,\t\t\n    const char     *key,\t\t\n    _pdfio_value_t *value)\t\t\n{\n  _pdfio_pair_t\t*pair;\t\t\t\n  PDFIO_DEBUG(\"_pdfioDictSetValue(dict=%p, key=\\\"%s\\\", value=%p)\\n\", dict, key, (void *)value);\n  if (dict->num_pairs > 0)\n  {\n    _pdfio_pair_t\tpkey;\t\t\n    pkey.key = key;\n    if ((pair = (_pdfio_pair_t *)bsearch(&pkey, dict->pairs, dict->num_pairs, sizeof(_pdfio_pair_t), (int (*)(const void *, const void *))compare_pairs)) != NULL)\n    {\n      PDFIO_DEBUG(\"_pdfioDictSetValue: Replacing existing value.\\n\");\n      if (pair->value.type == PDFIO_VALTYPE_BINARY)\n        free(pair->value.value.binary.data);\n      pair->value = *value;\n      return (true);\n    }\n  }\n  if (dict->num_pairs >= dict->alloc_pairs)\n  {\n    _pdfio_pair_t *temp = (_pdfio_pair_t *)realloc(dict->pairs, (dict->alloc_pairs + 8) * sizeof(_pdfio_pair_t));\n    if (!temp)\n    {\n      PDFIO_DEBUG(\"_pdfioDictSetValue: Out of memory.\\n\");\n      return (false);\n    }\n    dict->pairs       = temp;\n    dict->alloc_pairs += 8;\n  }\n  pair = dict->pairs + dict->num_pairs;\n  dict->num_pairs ++;\n  pair->key   = key;\n  pair->value = *value;\n  if (dict->num_pairs > 1 && compare_pairs(pair - 1, pair) > 0)\n    qsort(dict->pairs, dict->num_pairs, sizeof(_pdfio_pair_t), (int (*)(const void *, const void *))compare_pairs);\n#ifdef DEBUG\n  PDFIO_DEBUG(\"_pdfioDictSetValue(%p): %lu pairs\\n\", (void *)dict, (unsigned long)dict->num_pairs);\n  PDFIO_DEBUG(\"_pdfioDictSetValue(%p): \", (void *)dict);\n  PDFIO_DEBUG_DICT(dict);\n  PDFIO_DEBUG(\"\\n\");\n#endif \n  return (true);\n}", "target": 1}
{"code": "static struct key *construct_key_and_link(struct keyring_search_context *ctx,\n\t\t\t\t\t  const char *callout_info,\n\t\t\t\t\t  size_t callout_len,\n\t\t\t\t\t  void *aux,\n\t\t\t\t\t  struct key *dest_keyring,\n\t\t\t\t\t  unsigned long flags)\n{\n\tstruct key_user *user;\n\tstruct key *key;\n\tint ret;\n\tkenter(\"\");\n\tif (ctx->index_key.type == &key_type_keyring)\n\t\treturn ERR_PTR(-EPERM);\n\tuser = key_user_lookup(current_fsuid());\n\tif (!user)\n\t\treturn ERR_PTR(-ENOMEM);\n\tconstruct_get_dest_keyring(&dest_keyring);\n\tret = construct_alloc_key(ctx, dest_keyring, flags, user, &key);\n\tkey_user_put(user);\n\tif (ret == 0) {\n\t\tret = construct_key(key, callout_info, callout_len, aux,\n\t\t\t\t    dest_keyring);\n\t\tif (ret < 0) {\n\t\t\tkdebug(\"cons failed\");\n\t\t\tgoto construction_failed;\n\t\t}\n\t} else if (ret == -EINPROGRESS) {\n\t\tret = 0;\n\t} else {\n\t\tgoto couldnt_alloc_key;\n\t}\n\tkey_put(dest_keyring);\n\tkleave(\" = key %d\", key_serial(key));\n\treturn key;\nconstruction_failed:\n\tkey_negate_and_link(key, key_negative_timeout, NULL, NULL);\n\tkey_put(key);\ncouldnt_alloc_key:\n\tkey_put(dest_keyring);\n\tkleave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}", "target": 1}
{"code": "mrb_io_initialize_copy(mrb_state *mrb, mrb_value copy)\n{\n  mrb_value orig;\n  mrb_value buf;\n  struct mrb_io *fptr_copy;\n  struct mrb_io *fptr_orig;\n  mrb_bool failed = TRUE;\n  mrb_get_args(mrb, \"o\", &orig);\n  fptr_copy = (struct mrb_io *)DATA_PTR(copy);\n  if (fptr_copy != NULL) {\n    fptr_finalize(mrb, fptr_copy, FALSE);\n    mrb_free(mrb, fptr_copy);\n  }\n  fptr_copy = (struct mrb_io *)mrb_io_alloc(mrb);\n  fptr_orig = io_get_open_fptr(mrb, orig);\n  DATA_TYPE(copy) = &mrb_io_type;\n  DATA_PTR(copy) = fptr_copy;\n  buf = mrb_iv_get(mrb, orig, mrb_intern_cstr(mrb, \"@buf\"));\n  mrb_iv_set(mrb, copy, mrb_intern_cstr(mrb, \"@buf\"), buf);\n  fptr_copy->fd = mrb_dup(mrb, fptr_orig->fd, &failed);\n  if (failed) {\n    mrb_sys_fail(mrb, 0);\n  }\n  mrb_fd_cloexec(mrb, fptr_copy->fd);\n  if (fptr_orig->fd2 != -1) {\n    fptr_copy->fd2 = mrb_dup(mrb, fptr_orig->fd2, &failed);\n    if (failed) {\n      close(fptr_copy->fd);\n      mrb_sys_fail(mrb, 0);\n    }\n    mrb_fd_cloexec(mrb, fptr_copy->fd2);\n  }\n  fptr_copy->pid = fptr_orig->pid;\n  fptr_copy->readable = fptr_orig->readable;\n  fptr_copy->writable = fptr_orig->writable;\n  fptr_copy->sync = fptr_orig->sync;\n  fptr_copy->is_socket = fptr_orig->is_socket;\n  return copy;\n}", "target": 1}
{"code": "off_t FileModule::tell()\n{\n\treturn m_fh->tell();\n}", "target": 0}
{"code": "void jspReplaceWithOrAddToRoot(JsVar *dst, JsVar *src) {\n  if (!jsvGetRefs(dst) && jsvIsName(dst)) {\n    if (!jsvIsArrayBufferName(dst) && !jsvIsNewChild(dst))\n      jsvAddName(execInfo.root, dst);\n  }\n  jspReplaceWith(dst, src);\n}", "target": 0}
{"code": "static size_t ssl_compute_padding_length( size_t len,\n                                          size_t granularity )\n{\n    return( ( granularity - ( len + 1 ) % granularity ) % granularity );\n}", "target": 0}
{"code": "int kvm_read_guest_page(struct kvm *kvm, gfn_t gfn, void *data, int offset,\n\t\t\tint len)\n{\n\tint r;\n\tunsigned long addr;\n\taddr = gfn_to_hva(kvm, gfn);\n\tif (kvm_is_error_hva(addr))\n\t\treturn -EFAULT;\n\tr = copy_from_user(data, (void __user *)addr + offset, len);\n\tif (r)\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1}
{"code": "static u32 rgb_48_to_32(char *val)\n{\n\tu32 res = 0x0;\n\tu32 i;\n\tfor (i=0; i<3; i++) {\n\t\tu32 v = val[2*i];\n\t\tv<<=8;\n\t\tv|=val[2*i + 1];\n\t\tv/=0xFF;\n\t\tres <<= 8;\n\t\tres |= v;\n\t}\n\treturn res;\n}", "target": 0}
{"code": "vq_endchains(struct virtio_vq_info *vq, int used_all_avail)\n{\n\tstruct virtio_base *base;\n\tuint16_t event_idx, new_idx, old_idx;\n\tint intr;\n\tif (!vq || !vq->used)\n\t\treturn;\n\tatomic_thread_fence();\n\tbase = vq->base;\n\told_idx = vq->save_used;\n\tvq->save_used = new_idx = vq->used->idx;\n\tif (used_all_avail &&\n\t    (base->negotiated_caps & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)))\n\t\tintr = 1;\n\telse if (base->negotiated_caps & (1 << VIRTIO_RING_F_EVENT_IDX)) {\n\t\tevent_idx = VQ_USED_EVENT_IDX(vq);\n\t\tintr = (uint16_t)(new_idx - event_idx - 1) <\n\t\t\t(uint16_t)(new_idx - old_idx);\n\t} else {\n\t\tintr = new_idx != old_idx &&\n\t\t    !(vq->avail->flags & VRING_AVAIL_F_NO_INTERRUPT);\n\t}\n\tif (intr)\n\t\tvq_interrupt(base, vq);\n}", "target": 0}
{"code": "static int smm_stub_place_staggered_entry_points(char *base,\n\tconst struct smm_loader_params *params, const struct rmodule *smm_stub)\n{\n\tsize_t stub_entry_offset;\n\tint rc = 1;\n\tstub_entry_offset = rmodule_entry_offset(smm_stub);\n\tif (params->num_concurrent_save_states > 1 || stub_entry_offset != 0) {\n\t\trc = smm_place_entry_code((unsigned int)base,\n\t\t\tparams->num_concurrent_save_states,\n\t\t\t(unsigned int)params->stack_top, params);\n\t}\n\treturn rc;\n}", "target": 0}
{"code": "uint16_t nvme_bounce_data(NvmeCtrl *n, uint8_t *ptr, uint32_t len,\n                          NvmeTxDirection dir, NvmeRequest *req)\n{\n    NvmeNamespace *ns = req->ns;\n    NvmeRwCmd *rw = (NvmeRwCmd *)&req->cmd;\n    bool pi = !!NVME_ID_NS_DPS_TYPE(ns->id_ns.dps);\n    bool pract = !!(le16_to_cpu(rw->control) & NVME_RW_PRINFO_PRACT);\n    if (nvme_ns_ext(ns) && !(pi && pract && ns->lbaf.ms == 8)) {\n        return nvme_tx_interleaved(n, &req->sg, ptr, len, ns->lbasz,\n                                   ns->lbaf.ms, 0, dir);\n    }\n    return nvme_tx(n, &req->sg, ptr, len, dir);\n}", "target": 0}
{"code": "static long __media_device_enum_links(struct media_device *mdev,\n\t\t\t\t      struct media_links_enum *links)\n{\n\tstruct media_entity *entity;\n\tentity = find_entity(mdev, links->entity);\n\tif (entity == NULL)\n\t\treturn -EINVAL;\n\tif (links->pads) {\n\t\tunsigned int p;\n\t\tfor (p = 0; p < entity->num_pads; p++) {\n\t\t\tstruct media_pad_desc pad;\n\t\t\tmemset(&pad, 0, sizeof(pad));\n\t\t\tmedia_device_kpad_to_upad(&entity->pads[p], &pad);\n\t\t\tif (copy_to_user(&links->pads[p], &pad, sizeof(pad)))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\tif (links->links) {\n\t\tstruct media_link_desc __user *ulink;\n\t\tunsigned int l;\n\t\tfor (l = 0, ulink = links->links; l < entity->num_links; l++) {\n\t\t\tstruct media_link_desc link;\n\t\t\tif (entity->links[l].source->entity != entity)\n\t\t\t\tcontinue;\n\t\t\tmemset(&link, 0, sizeof(link));\n\t\t\tmedia_device_kpad_to_upad(entity->links[l].source,\n\t\t\t\t\t\t  &link.source);\n\t\t\tmedia_device_kpad_to_upad(entity->links[l].sink,\n\t\t\t\t\t\t  &link.sink);\n\t\t\tlink.flags = entity->links[l].flags;\n\t\t\tif (copy_to_user(ulink, &link, sizeof(*ulink)))\n\t\t\t\treturn -EFAULT;\n\t\t\tulink++;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "xmlValidNormalizeString(xmlChar *str) {\n    xmlChar *dst;\n    const xmlChar *src;\n    if (str == NULL)\n        return;\n    src = str;\n    dst = str;\n    while (*src == 0x20) src++;\n    while (*src != 0) {\n\tif (*src == 0x20) {\n\t    while (*src == 0x20) src++;\n\t    if (*src != 0)\n\t\t*dst++ = 0x20;\n\t} else {\n\t    *dst++ = *src++;\n\t}\n    }\n    *dst = 0;\n}", "target": 0}
{"code": "int nfc_llcp_send_symm(struct nfc_dev *dev)\n{\n\tstruct sk_buff *skb;\n\tstruct nfc_llcp_local *local;\n\tu16 size = 0;\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\tsize += LLCP_HEADER_SIZE;\n\tsize += dev->tx_headroom + dev->tx_tailroom + NFC_HEADER_SIZE;\n\tskb = alloc_skb(size, GFP_KERNEL);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\tskb_reserve(skb, dev->tx_headroom + NFC_HEADER_SIZE);\n\tskb = llcp_add_header(skb, 0, 0, LLCP_PDU_SYMM);\n\t__net_timestamp(skb);\n\tnfc_llcp_send_to_raw_sock(local, skb, NFC_DIRECTION_TX);\n\treturn nfc_data_exchange(dev, local->target_idx, skb,\n\t\t\t\t nfc_llcp_recv, local);\n}", "target": 1}
{"code": "static struct task_struct *dup_task_struct(struct task_struct *orig)\n{\n\tstruct task_struct *tsk;\n\tstruct thread_info *ti;\n\tunsigned long *stackend;\n\tint err;\n\tprepare_to_copy(orig);\n\ttsk = alloc_task_struct();\n\tif (!tsk)\n\t\treturn NULL;\n\tti = alloc_thread_info(tsk);\n\tif (!ti) {\n\t\tfree_task_struct(tsk);\n\t\treturn NULL;\n\t}\n \terr = arch_dup_task_struct(tsk, orig);\n\tif (err)\n\t\tgoto out;\n\ttsk->stack = ti;\n\terr = prop_local_init_single(&tsk->dirties);\n\tif (err)\n\t\tgoto out;\n\tsetup_thread_stack(tsk, orig);\n\tclear_user_return_notifier(tsk);\n\tclear_tsk_need_resched(tsk);\n\tstackend = end_of_stack(tsk);\n\t*stackend = STACK_END_MAGIC;\t\n#ifdef CONFIG_CC_STACKPROTECTOR\n\ttsk->stack_canary = get_random_int();\n#endif\n\tatomic_set(&tsk->usage,2);\n\tatomic_set(&tsk->fs_excl, 0);\n#ifdef CONFIG_BLK_DEV_IO_TRACE\n\ttsk->btrace_seq = 0;\n#endif\n\ttsk->splice_pipe = NULL;\n\taccount_kernel_stack(ti, 1);\n\treturn tsk;\nout:\n\tfree_thread_info(ti);\n\tfree_task_struct(tsk);\n\treturn NULL;\n}", "target": 0}
{"code": "void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi)\n{\n\t__issue_discard_cmd(sbi, false);\n\t__drop_discard_cmd(sbi);\n\t__wait_discard_cmd(sbi, false);\n}", "target": 1}
{"code": "static void Process_ipfix_template_withdraw(exporter_ipfix_domain_t *exporter, void *DataPtr, uint32_t size_left, FlowSource_t *fs) {\nipfix_template_record_t *ipfix_template_record;\n\twhile ( size_left ) {\n\t\tuint32_t id;\n\t\tif ( size_left < 4 ) {\n\t\t\tLogError(\"Process_ipfix [%u] Template withdraw size error at %s line %u\" , \n\t\t\t\texporter->info.id, __FILE__, __LINE__, strerror (errno));\n\t\t\tsize_left = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tipfix_template_record = (ipfix_template_record_t *)DataPtr;\n\t\tsize_left \t\t-= 4;\n\t\tid \t  = ntohs(ipfix_template_record->TemplateID);\n\t\tif ( id == IPFIX_TEMPLATE_FLOWSET_ID ) {\n\t\t\tremove_all_translation_tables(exporter);\n\t\t\tReInitExtensionMapList(fs);\n\t\t} else {\n\t\t\tremove_translation_table(fs, exporter, id);\n\t\t}\n\t\tDataPtr = DataPtr + 4;\n\t\tif ( size_left < 4 ) {\n\t\t\tdbg_printf(\"Skip %u bytes padding\\n\", size_left);\n\t\t\tsize_left = 0;\n\t\t}\n\t}\n} ", "target": 0}
{"code": "ikev2_auth_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len _U_, const u_char *ep,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct ikev2_auth a;\n\tconst char *v2_auth[]={ \"invalid\", \"rsasig\",\n\t\t\t\t\"shared-secret\", \"dsssig\" };\n\tconst u_char *authdata = (const u_char*)ext + sizeof(a);\n\tunsigned int len;\n\tND_TCHECK2(*ext, sizeof(a));\n\tUNALIGNED_MEMCPY(&a, ext, sizeof(a));\n\tikev2_pay_print(ndo, NPSTR(tpay), a.h.critical);\n\tlen = ntohs(a.h.len);\n\tND_PRINT((ndo,\" len=%u method=%s\", len-4,\n\t\t  STR_OR_ID(a.auth_method, v2_auth)));\n\tif (len > 4) {\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\tND_PRINT((ndo, \" authdata=(\"));\n\t\t\tif (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))\n\t\t\t\tgoto trunc;\n\t\t\tND_PRINT((ndo, \") \"));\n\t\t} else if (ndo->ndo_vflag) {\n\t\t\tif (!ike_show_somedata(ndo, authdata, ep))\n\t\t\t\tgoto trunc;\n\t\t}\n\t}\n\treturn (const u_char *)ext + len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}", "target": 0}
{"code": "static long ioctl_file_dedupe_range(struct file *file, void __user *arg)\n{\n\tstruct file_dedupe_range __user *argp = arg;\n\tstruct file_dedupe_range *same = NULL;\n\tint ret;\n\tunsigned long size;\n\tu16 count;\n\tif (get_user(count, &argp->dest_count)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\tsize = offsetof(struct file_dedupe_range __user, info[count]);\n\tsame = memdup_user(argp, size);\n\tif (IS_ERR(same)) {\n\t\tret = PTR_ERR(same);\n\t\tsame = NULL;\n\t\tgoto out;\n\t}\n\tsame->dest_count = count;\n\tret = vfs_dedupe_file_range(file, same);\n\tif (ret)\n\t\tgoto out;\n\tret = copy_to_user(argp, same, size);\n\tif (ret)\n\t\tret = -EFAULT;\nout:\n\tkfree(same);\n\treturn ret;\n}", "target": 0}
{"code": "static int nl80211_dump_survey(struct sk_buff *skb,\n\t\t\tstruct netlink_callback *cb)\n{\n\tstruct survey_info survey;\n\tstruct cfg80211_registered_device *dev;\n\tstruct net_device *netdev;\n\tint survey_idx = cb->args[1];\n\tint res;\n\tres = nl80211_prepare_netdev_dump(skb, cb, &dev, &netdev);\n\tif (res)\n\t\treturn res;\n\tif (!dev->ops->dump_survey) {\n\t\tres = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\twhile (1) {\n\t\tstruct ieee80211_channel *chan;\n\t\tres = rdev_dump_survey(dev, netdev, survey_idx, &survey);\n\t\tif (res == -ENOENT)\n\t\t\tbreak;\n\t\tif (res)\n\t\t\tgoto out_err;\n\t\tif (!survey.channel) {\n\t\t\tres = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tchan = ieee80211_get_channel(&dev->wiphy,\n\t\t\t\t\t     survey.channel->center_freq);\n\t\tif (!chan || chan->flags & IEEE80211_CHAN_DISABLED) {\n\t\t\tsurvey_idx++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (nl80211_send_survey(skb,\n\t\t\t\tNETLINK_CB(cb->skb).portid,\n\t\t\t\tcb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\tnetdev,\n\t\t\t\t&survey) < 0)\n\t\t\tgoto out;\n\t\tsurvey_idx++;\n\t}\n out:\n\tcb->args[1] = survey_idx;\n\tres = skb->len;\n out_err:\n\tnl80211_finish_netdev_dump(dev);\n\treturn res;\n}", "target": 0}
{"code": "krb5_gss_export_sec_context(minor_status, context_handle, interprocess_token)\n    OM_uint32           *minor_status;\n    gss_ctx_id_t        *context_handle;\n    gss_buffer_t        interprocess_token;\n{\n    krb5_context        context = NULL;\n    krb5_error_code     kret;\n    OM_uint32           retval;\n    size_t              bufsize, blen;\n    krb5_gss_ctx_id_t   ctx;\n    krb5_octet          *obuffer, *obp;\n    obuffer = (krb5_octet *) NULL;\n    retval = GSS_S_FAILURE;\n    *minor_status = 0;\n    ctx = (krb5_gss_ctx_id_t) *context_handle;\n    if (ctx->terminated) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return (GSS_S_NO_CONTEXT);\n    }\n    context = ctx->k5_context;\n    kret = krb5_gss_ser_init(context);\n    if (kret)\n        goto error_out;\n    bufsize = 0;\n    if ((kret = kg_ctx_size(context, (krb5_pointer) ctx,\n                            &bufsize)))\n        goto error_out;\n    if ((obuffer = gssalloc_malloc(bufsize)) == NULL) {\n        kret = ENOMEM;\n        goto error_out;\n    }\n    obp = obuffer;\n    blen = bufsize;\n    if ((kret = kg_ctx_externalize(context,\n                                   (krb5_pointer) ctx, &obp, &blen)))\n        goto error_out;\n    interprocess_token->length = bufsize - blen;\n    interprocess_token->value = obuffer;\n    *minor_status = 0;\n    retval = GSS_S_COMPLETE;\n    (void)krb5_gss_delete_sec_context(minor_status, context_handle, NULL);\n    *context_handle = GSS_C_NO_CONTEXT;\n    return (GSS_S_COMPLETE);\nerror_out:\n    if (retval != GSS_S_COMPLETE)\n        if (kret != 0 && context != 0)\n            save_error_info((OM_uint32)kret, context);\n    if (obuffer && bufsize) {\n        memset(obuffer, 0, bufsize);\n        xfree(obuffer);\n    }\n    if (*minor_status == 0)\n        *minor_status = (OM_uint32) kret;\n    return(retval);\n}", "target": 0}
{"code": "static void perf_adjust_freq_unthr_context(struct perf_event_context *ctx,\n\t\t\t\t\t   int needs_unthr)\n{\n\tstruct perf_event *event;\n\tstruct hw_perf_event *hwc;\n\tu64 now, period = TICK_NSEC;\n\ts64 delta;\n\tif (!(ctx->nr_freq || needs_unthr))\n\t\treturn;\n\traw_spin_lock(&ctx->lock);\n\tperf_pmu_disable(ctx->pmu);\n\tlist_for_each_entry_rcu(event, &ctx->event_list, event_entry) {\n\t\tif (event->state != PERF_EVENT_STATE_ACTIVE)\n\t\t\tcontinue;\n\t\tif (!event_filter_match(event))\n\t\t\tcontinue;\n\t\thwc = &event->hw;\n\t\tif (needs_unthr && hwc->interrupts == MAX_INTERRUPTS) {\n\t\t\thwc->interrupts = 0;\n\t\t\tperf_log_throttle(event, 1);\n\t\t\tevent->pmu->start(event, 0);\n\t\t}\n\t\tif (!event->attr.freq || !event->attr.sample_freq)\n\t\t\tcontinue;\n\t\tevent->pmu->stop(event, PERF_EF_UPDATE);\n\t\tnow = local64_read(&event->count);\n\t\tdelta = now - hwc->freq_count_stamp;\n\t\thwc->freq_count_stamp = now;\n\t\tif (delta > 0)\n\t\t\tperf_adjust_period(event, period, delta, false);\n\t\tevent->pmu->start(event, delta > 0 ? PERF_EF_RELOAD : 0);\n\t}\n\tperf_pmu_enable(ctx->pmu);\n\traw_spin_unlock(&ctx->lock);\n}", "target": 0}
{"code": "static u16 swf_get_16(SWFReader *read)\n{\n\tu16 val, res;\n\tval = swf_read_int(read, 16);\n\tres = (val&0xFF);\n\tres <<=8;\n\tres |= ((val>>8)&0xFF);\n\treturn res;\n}", "target": 1}
{"code": "void btrfs_trans_release_chunk_metadata(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tif (!trans->chunk_bytes_reserved)\n\t\treturn;\n\tWARN_ON_ONCE(!list_empty(&trans->new_bgs));\n\tbtrfs_block_rsv_release(fs_info, &fs_info->chunk_block_rsv,\n\t\t\t\ttrans->chunk_bytes_reserved, NULL);\n\tatomic64_sub(trans->chunk_bytes_reserved, &cur_trans->chunk_bytes_reserved);\n\tcond_wake_up(&cur_trans->chunk_reserve_wait);\n\ttrans->chunk_bytes_reserved = 0;\n}", "target": 1}
{"code": "static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)\n{\n\tstruct mmu_gather tlb;\n\tstruct vm_area_struct *vma;\n\tbool ret = true;\n\tmutex_lock(&oom_lock);\n\tif (!down_read_trylock(&mm->mmap_sem)) {\n\t\tret = false;\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\tgoto unlock_oom;\n\t}\n\tif (mm_has_notifiers(mm)) {\n\t\tup_read(&mm->mmap_sem);\n\t\tschedule_timeout_idle(HZ);\n\t\tgoto unlock_oom;\n\t}\n\tif (test_bit(MMF_OOM_SKIP, &mm->flags)) {\n\t\tup_read(&mm->mmap_sem);\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\tgoto unlock_oom;\n\t}\n\ttrace_start_task_reaping(tsk->pid);\n\tset_bit(MMF_UNSTABLE, &mm->flags);\n\ttlb_gather_mmu(&tlb, mm, 0, -1);\n\tfor (vma = mm->mmap ; vma; vma = vma->vm_next) {\n\t\tif (!can_madv_dontneed_vma(vma))\n\t\t\tcontinue;\n\t\tif (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED))\n\t\t\tunmap_page_range(&tlb, vma, vma->vm_start, vma->vm_end,\n\t\t\t\t\t NULL);\n\t}\n\ttlb_finish_mmu(&tlb, 0, -1);\n\tpr_info(\"oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\",\n\t\t\ttask_pid_nr(tsk), tsk->comm,\n\t\t\tK(get_mm_counter(mm, MM_ANONPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_FILEPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_SHMEMPAGES)));\n\tup_read(&mm->mmap_sem);\n\ttrace_finish_task_reaping(tsk->pid);\nunlock_oom:\n\tmutex_unlock(&oom_lock);\n\treturn ret;\n}", "target": 1}
{"code": "Status TensorSliceWriter::SaveData(const T* data, int64_t num_elements,\n                                   SavedSlice* ss) {\n  size_t size_bound =\n      ss->ByteSize() + kTensorProtoHeaderBytes +\n      (MaxBytesPerElement(DataTypeToEnum<T>::value) * num_elements);\n  if (size_bound > kMaxMessageBytes) {\n    return errors::InvalidArgument(\n        \"Tensor slice is too large to serialize (conservative estimate: \",\n        size_bound, \" bytes)\");\n  }\n  Fill(data, num_elements, ss->mutable_data());\n  DCHECK_GE(ss->ByteSize(), 0);\n  DCHECK_LE(ss->ByteSize(), size_bound);\n  return OkStatus();\n}", "target": 1}
{"code": "void *enc_untrusted_realloc(void *ptr, size_t size) {\n  MessageWriter input;\n  input.Push(reinterpret_cast<uint64_t>(ptr));\n  input.Push(static_cast<uint64_t>(size));\n  MessageReader output;\n  asylo::primitives::PrimitiveStatus status =\n      asylo::host_call::NonSystemCallDispatcher(\n          asylo::host_call::kReallocHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_realloc\", 2);\n  void *result = output.next<void *>();\n  int klinux_errno = output.next<int>();\n  if (!result && size != 0) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n  }\n  if (!::asylo::primitives::TrustedPrimitives::IsOutsideEnclave(result, size)) {\n    ::asylo::primitives::TrustedPrimitives::BestEffortAbort(\n        \"enc_untrusted_realloc: realloc result should be in untrusted \"\n        \"memory\");\n  }\n  return result;\n}", "target": 0}
{"code": "void TestSocketLineReader::init()\n{\n    m_packets.clear();\n    m_server = new Server(this);\n    QVERIFY2(m_server->listen(QHostAddress::LocalHost, 8694), \"Failed to create local tcp server\");\n    m_timer.setInterval(4000);\n    m_timer.setSingleShot(true);\n    connect(&m_timer, &QTimer::timeout, &m_loop, &QEventLoop::quit);\n    m_conn = new QSslSocket(this);\n    m_conn->connectToHost(QHostAddress::LocalHost, 8694);\n    connect(m_conn, &QAbstractSocket::connected, &m_loop, &QEventLoop::quit);\n    m_timer.start();\n    m_loop.exec();\n    QVERIFY2(m_conn->isOpen(), \"Could not connect to local tcp server\");\n}", "target": 0}
{"code": "static inline void assign_eip_near(struct x86_emulate_ctxt *ctxt, ulong dst)\n{\n\tswitch (ctxt->op_bytes) {\n\tcase 2:\n\t\tctxt->_eip = (u16)dst;\n\t\tbreak;\n\tcase 4:\n\t\tctxt->_eip = (u32)dst;\n\t\tbreak;\n\tcase 8:\n\t\tctxt->_eip = dst;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"unsupported eip assignment size\\n\");\n\t}\n}", "target": 1}
{"code": "TfLiteStatus ResizeOutputTensor(TfLiteContext* context,\n                                SpaceToBatchNDContext* op_context) {\n  TfLiteIntArray* input_size = op_context->input->dims;\n  const int32* block_shape = GetTensorData<int32>(op_context->block_shape);\n  const int32* paddings_data = GetTensorData<int32>(op_context->paddings);\n  int spatial_dims_num = input_size->size - 2;\n  TF_LITE_ENSURE_EQ(context, NumDimensions(op_context->block_shape), 1);\n  TF_LITE_ENSURE_EQ(context, op_context->block_shape->dims->data[0],\n                    spatial_dims_num);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(op_context->paddings), 2);\n  TF_LITE_ENSURE_EQ(context, op_context->paddings->dims->data[0],\n                    spatial_dims_num);\n  TF_LITE_ENSURE_EQ(context, op_context->paddings->dims->data[1], 2);\n  TfLiteIntArray* output_size = TfLiteIntArrayCopy(input_size);\n  int output_batch_size = input_size->data[0];\n  for (int dim = 0; dim < spatial_dims_num; ++dim) {\n    int final_dim_size = (input_size->data[dim + 1] + paddings_data[dim * 2] +\n                          paddings_data[dim * 2 + 1]);\n    TF_LITE_ENSURE(context, block_shape[dim] != 0);\n    TF_LITE_ENSURE_EQ(context, final_dim_size % block_shape[dim], 0);\n    output_size->data[dim + 1] = final_dim_size / block_shape[dim];\n    output_batch_size *= block_shape[dim];\n  }\n  output_size->data[0] = output_batch_size;\n  output_size->data[input_size->size - 1] =\n      input_size->data[input_size->size - 1];\n  return context->ResizeTensor(context, op_context->output, output_size);\n}", "target": 0}
{"code": "ExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)\n{\n    unsigned nSyms = darray_size(expr->keysym_list.syms);\n    unsigned numEntries = darray_size(append->keysym_list.syms);\n    darray_append(expr->keysym_list.symsMapIndex, nSyms);\n    darray_append(expr->keysym_list.symsNumEntries, numEntries);\n    darray_concat(expr->keysym_list.syms, append->keysym_list.syms);\n    FreeStmt((ParseCommon *) &append);\n    return expr;\n}", "target": 1}
{"code": "static void xudc_getstatus(struct xusb_udc *udc)\n{\n\tstruct xusb_ep *ep0\t= &udc->ep[0];\n\tstruct xusb_req *req\t= udc->req;\n\tstruct xusb_ep *target_ep;\n\tu16 status = 0;\n\tu32 epcfgreg;\n\tint epnum;\n\tu32 halt;\n\tint ret;\n\tswitch (udc->setup.bRequestType & USB_RECIP_MASK) {\n\tcase USB_RECIP_DEVICE:\n\t\tstatus = 1 << USB_DEVICE_SELF_POWERED;\n\t\tif (udc->remote_wkp)\n\t\t\tstatus |= (1 << USB_DEVICE_REMOTE_WAKEUP);\n\t\tbreak;\n\tcase USB_RECIP_INTERFACE:\n\t\tbreak;\n\tcase USB_RECIP_ENDPOINT:\n\t\tepnum = udc->setup.wIndex & USB_ENDPOINT_NUMBER_MASK;\n\t\tif (epnum >= XUSB_MAX_ENDPOINTS)\n\t\t\tgoto stall;\n\t\ttarget_ep = &udc->ep[epnum];\n\t\tepcfgreg = udc->read_fn(udc->addr + target_ep->offset);\n\t\thalt = epcfgreg & XUSB_EP_CFG_STALL_MASK;\n\t\tif (udc->setup.wIndex & USB_DIR_IN) {\n\t\t\tif (!target_ep->is_in)\n\t\t\t\tgoto stall;\n\t\t} else {\n\t\t\tif (target_ep->is_in)\n\t\t\t\tgoto stall;\n\t\t}\n\t\tif (halt)\n\t\t\tstatus = 1 << USB_ENDPOINT_HALT;\n\t\tbreak;\n\tdefault:\n\t\tgoto stall;\n\t}\n\treq->usb_req.length = 2;\n\t*(u16 *)req->usb_req.buf = cpu_to_le16(status);\n\tret = __xudc_ep0_queue(ep0, req);\n\tif (ret == 0)\n\t\treturn;\nstall:\n\tdev_err(udc->dev, \"Can't respond to getstatus request\\n\");\n\txudc_ep0_stall(udc);\n}", "target": 0}
{"code": "mwifiex_set_wmm_params(struct mwifiex_private *priv,\n\t\t       struct mwifiex_uap_bss_param *bss_cfg,\n\t\t       struct cfg80211_ap_settings *params)\n{\n\tconst u8 *vendor_ie;\n\tconst u8 *wmm_ie;\n\tu8 wmm_oui[] = {0x00, 0x50, 0xf2, 0x02};\n\tvendor_ie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t    WLAN_OUI_TYPE_MICROSOFT_WMM,\n\t\t\t\t\t    params->beacon.tail,\n\t\t\t\t\t    params->beacon.tail_len);\n\tif (vendor_ie) {\n\t\twmm_ie = vendor_ie;\n\t\tif (*(wmm_ie + 1) > sizeof(struct mwifiex_types_wmm_info))\n\t\t\treturn;\n\t\tmemcpy(&bss_cfg->wmm_info, wmm_ie +\n\t\t       sizeof(struct ieee_types_header), *(wmm_ie + 1));\n\t\tpriv->wmm_enabled = 1;\n\t} else {\n\t\tmemset(&bss_cfg->wmm_info, 0, sizeof(bss_cfg->wmm_info));\n\t\tmemcpy(&bss_cfg->wmm_info.oui, wmm_oui, sizeof(wmm_oui));\n\t\tbss_cfg->wmm_info.subtype = MWIFIEX_WMM_SUBTYPE;\n\t\tbss_cfg->wmm_info.version = MWIFIEX_WMM_VERSION;\n\t\tpriv->wmm_enabled = 0;\n\t}\n\tbss_cfg->qos_info = 0x00;\n\treturn;\n}", "target": 0}
{"code": "int ssl_init(void) { \n#if OPENSSL_VERSION_NUMBER>=0x10100000L\n    OPENSSL_init_ssl(OPENSSL_INIT_LOAD_SSL_STRINGS |\n        OPENSSL_INIT_LOAD_CRYPTO_STRINGS | OPENSSL_INIT_LOAD_CONFIG, NULL);\n#else\n    OPENSSL_config(NULL);\n    SSL_load_error_strings();\n    SSL_library_init();\n#endif\n    index_ssl_cli=SSL_get_ex_new_index(0,\n        \"CLI pointer\", NULL, NULL, NULL);\n    index_ssl_ctx_opt=SSL_CTX_get_ex_new_index(0,\n        \"SERVICE_OPTIONS pointer\", NULL, NULL, NULL);\n    index_session_authenticated=SSL_SESSION_get_ex_new_index(0,\n        \"session authenticated\", NULL, NULL, NULL);\n    index_session_connect_address=SSL_SESSION_get_ex_new_index(0,\n        \"session connect address\", NULL, cb_dup_addr, cb_free_addr);\n    if(index_ssl_cli<0 || index_ssl_ctx_opt<0 ||\n            index_session_authenticated<0 ||\n            index_session_connect_address<0) {\n        s_log(LOG_ERR, \"Application specific data initialization failed\");\n        return 1;\n    }\n#ifndef OPENSSL_NO_ENGINE\n    ENGINE_load_builtin_engines();\n#endif\n#ifndef OPENSSL_NO_DH\n    dh_params=get_dh2048();\n    if(!dh_params) {\n        s_log(LOG_ERR, \"Failed to get default DH parameters\");\n        return 1;\n    }\n#endif \n    return 0;\n}", "target": 1}
{"code": "static int get_tp_trap(struct pt_regs *regs, unsigned int instr)\n{\n\tint reg = (instr >> 12) & 15;\n\tif (reg == 15)\n\t\treturn 1;\n\tregs->uregs[reg] = current_thread_info()->tp_value;\n\tregs->ARM_pc += 4;\n\treturn 0;\n}", "target": 1}
{"code": "int fit_check_format(const void *fit, ulong size)\n{\n\tint ret;\n\tret = fdt_check_header(fit);\n\tif (ret) {\n\t\tlog_debug(\"Wrong FIT format: not a flattened device tree (err=%d)\\n\",\n\t\t\t  ret);\n\t\treturn -ENOEXEC;\n\t}\n\tif (CONFIG_IS_ENABLED(FIT_FULL_CHECK)) {\n\t\tif (size == IMAGE_SIZE_INVAL)\n\t\t\tsize = fdt_totalsize(fit);\n\t\tret = fdt_check_full(fit, size);\n\t\tif (ret)\n\t\t\tret = -EINVAL;\n\t\tif (!ret && CONFIG_IS_ENABLED(FIT_SIGNATURE)) {\n\t\t\tret = fdt_check_no_at(fit, 0);\n\t\t\tif (ret) {\n\t\t\t\tlog_debug(\"FIT check error %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tif (ret) {\n\t\t\tlog_debug(\"FIT check error %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tif (!fdt_getprop(fit, 0, FIT_DESC_PROP, NULL)) {\n\t\tlog_debug(\"Wrong FIT format: no description\\n\");\n\t\treturn -ENOMSG;\n\t}\n\tif (IMAGE_ENABLE_TIMESTAMP) {\n\t\tif (!fdt_getprop(fit, 0, FIT_TIMESTAMP_PROP, NULL)) {\n\t\t\tlog_debug(\"Wrong FIT format: no timestamp\\n\");\n\t\t\treturn -ENODATA;\n\t\t}\n\t}\n\tif (fdt_path_offset(fit, FIT_IMAGES_PATH) < 0) {\n\t\tlog_debug(\"Wrong FIT format: no images parent node\\n\");\n\t\treturn -ENOENT;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "poly_path(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *poly = PG_GETARG_POLYGON_P(0);\n\tPATH\t   *path;\n\tint\t\t\tsize;\n\tint\t\t\ti;\n\tsize = offsetof(PATH, p[0]) +sizeof(path->p[0]) * poly->npts;\n\tpath = (PATH *) palloc(size);\n\tSET_VARSIZE(path, size);\n\tpath->npts = poly->npts;\n\tpath->closed = TRUE;\n\tpath->dummy = 0;\n\tfor (i = 0; i < poly->npts; i++)\n\t{\n\t\tpath->p[i].x = poly->p[i].x;\n\t\tpath->p[i].y = poly->p[i].y;\n\t}\n\tPG_RETURN_PATH_P(path);\n}", "target": 0}
{"code": "StatusOr<FullTypeDef> SpecializeType(const AttrSlice& attrs,\n                                     const OpDef& op_def) {\n  FullTypeDef ft;\n  ft.set_type_id(TFT_PRODUCT);\n  for (int i = 0; i < op_def.output_arg_size(); i++) {\n    auto* t = ft.add_args();\n    *t = op_def.output_arg(i).experimental_full_type();\n    for (int j = 0; j < t->args_size(); j++) {\n      auto* arg = t->mutable_args(j);\n      if (arg->type_id() == TFT_VAR) {\n        const auto* attr = attrs.Find(arg->s());\n        if (attr == nullptr) {\n          return Status(\n              error::INVALID_ARGUMENT,\n              absl::StrCat(\"Could not find an attribute for key \", arg->s()));\n        }\n        if (attr->value_case() == AttrValue::kList) {\n          const auto& attr_list = attr->list();\n          arg->set_type_id(TFT_PRODUCT);\n          for (int i = 0; i < attr_list.type_size(); i++) {\n            map_dtype_to_tensor(attr_list.type(i), arg->add_args());\n          }\n        } else if (attr->value_case() == AttrValue::kType) {\n          map_dtype_to_tensor(attr->type(), arg);\n        } else {\n          return Status(error::UNIMPLEMENTED,\n                        absl::StrCat(\"unknown attribute type\",\n                                     attrs.DebugString(), \" key=\", arg->s()));\n        }\n        arg->clear_s();\n      }\n    }\n  }\n  return ft;\n}", "target": 0}
{"code": "static void ptrace_unfreeze_traced(struct task_struct *task)\n{\n\tif (task->state != __TASK_TRACED)\n\t\treturn;\n\tWARN_ON(!task->ptrace || task->parent != current);\n\tspin_lock_irq(&task->sighand->siglock);\n\tif (__fatal_signal_pending(task))\n\t\twake_up_state(task, __TASK_TRACED);\n\telse\n\t\ttask->state = TASK_TRACED;\n\tspin_unlock_irq(&task->sighand->siglock);\n}", "target": 0}
{"code": "void ModuleSQL::init()\n{\n\tif (mysql_library_init(0, NULL, NULL))\n\t\tthrow ModuleException(\"Unable to initialise the MySQL library!\");\n\tDispatcher = new DispatcherThread(this);\n\tServerInstance->Threads.Start(Dispatcher);\n}", "target": 0}
{"code": "static __init int seqgen_init(void)\n{\n\trekey_seq_generator(NULL);\n\treturn 0;\n}", "target": 1}
{"code": "static int intf_start_seq_timer(struct ipmi_smi *intf,\n\t\t\t\tlong       msgid)\n{\n\tint           rv = -ENODEV;\n\tunsigned long flags;\n\tunsigned char seq;\n\tunsigned long seqid;\n\tGET_SEQ_FROM_MSGID(msgid, seq, seqid);\n\tspin_lock_irqsave(&intf->seq_lock, flags);\n\tif ((intf->seq_table[seq].inuse)\n\t\t\t\t&& (intf->seq_table[seq].seqid == seqid)) {\n\t\tstruct seq_table *ent = &intf->seq_table[seq];\n\t\tent->timeout = ent->orig_timeout;\n\t\trv = 0;\n\t}\n\tspin_unlock_irqrestore(&intf->seq_lock, flags);\n\treturn rv;\n}", "target": 0}
{"code": "ExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr,\n               const char **elem_rtrn, const char **field_rtrn,\n               ExprDef **index_rtrn)\n{\n    switch (expr->expr.op) {\n    case EXPR_IDENT:\n        *elem_rtrn = NULL;\n        *field_rtrn = xkb_atom_text(ctx, expr->ident.ident);\n        *index_rtrn = NULL;\n        return (*field_rtrn != NULL);\n    case EXPR_FIELD_REF:\n        *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element);\n        *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field);\n        *index_rtrn = NULL;\n        return (*elem_rtrn != NULL && *field_rtrn != NULL);\n    case EXPR_ARRAY_REF:\n        *elem_rtrn = xkb_atom_text(ctx, expr->array_ref.element);\n        *field_rtrn = xkb_atom_text(ctx, expr->array_ref.field);\n        *index_rtrn = expr->array_ref.entry;\n\tif (expr->array_ref.element != XKB_ATOM_NONE && *elem_rtrn == NULL)\n\t\treturn false;\n\tif (*field_rtrn == NULL)\n\t\treturn false;\n        return true;\n    default:\n        break;\n    }\n    log_wsgo(ctx, \"Unexpected operator %d in ResolveLhs\\n\", expr->expr.op);\n    return false;\n}", "target": 0}
{"code": "static __inline__ int scm_send(struct socket *sock, struct msghdr *msg,\n\t\t\t       struct scm_cookie *scm)\n{\n\tmemset(scm, 0, sizeof(*scm));\n\tunix_get_peersec_dgram(sock, scm);\n\tif (msg->msg_controllen <= 0)\n\t\treturn 0;\n\treturn __scm_send(sock, msg, scm);\n}", "target": 1}
{"code": "int SetNonBlocking(int fd) {\n#if defined(OS_WIN)\n  unsigned long no_block = 1;\n  return ioctlsocket(fd, FIONBIO, &no_block);\n#elif defined(OS_POSIX)\n  int flags = fcntl(fd, F_GETFL, 0);\n  if (-1 == flags)\n    flags = 0;\n  return fcntl(fd, F_SETFL, flags | O_NONBLOCK);\n#endif\n}", "target": 0}
{"code": "TEST(TF_CTStringTest, OffsetType) {\n  {\n    TF_TString s71;\n    TF_TString_Init(&s71);\n    size_t header_length = 24;\n    size_t size = 8;\n    TF_TString_ResizeUninitialized(&s71, header_length + size);\n    uint32_t save_size = s71.u.offset.size;\n    uint32_t save_offset = s71.u.offset.offset;\n    uint32_t save_count = s71.u.offset.count;\n    s71.u.offset.size = TF_TString_ToInternalSizeT(size, TF_TSTR_OFFSET);\n    s71.u.offset.offset = header_length;\n    s71.u.offset.count = 0;\n    EXPECT_EQ(size, TF_TString_GetSize(&s71));\n    EXPECT_EQ(TF_TSTR_OFFSET, TF_TString_GetType(&s71));\n    s71.u.offset.size = save_size;\n    s71.u.offset.offset = save_offset;\n    s71.u.offset.count = save_count;\n    TF_TString_Dealloc(&s71);\n  }\n}", "target": 0}
{"code": "static void __exit pcd_exit(void)\n{\n\tstruct pcd_unit *cd;\n\tint unit;\n\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\tif (!cd->disk)\n\t\t\tcontinue;\n\t\tif (cd->present) {\n\t\t\tdel_gendisk(cd->disk);\n\t\t\tpi_release(cd->pi);\n\t\t\tunregister_cdrom(&cd->info);\n\t\t}\n\t\tblk_cleanup_queue(cd->disk->queue);\n\t\tblk_mq_free_tag_set(&cd->tag_set);\n\t\tput_disk(cd->disk);\n\t}\n\tunregister_blkdev(major, name);\n\tpi_unregister_driver(par_drv);\n}", "target": 0}
{"code": "static void save_text_if_changed(const char *name, const char *new_value)\n{\n    if (!g_hash_table_lookup(g_loaded_texts, name))\n        return;\n    const char *old_value = g_cd ? problem_data_get_content_or_NULL(g_cd, name) : \"\";\n    if (!old_value)\n        old_value = \"\";\n    if (strcmp(new_value, old_value) != 0)\n    {\n        struct dump_dir *dd = wizard_open_directory_for_writing(g_dump_dir_name);\n        if (dd)\n            dd_save_text(dd, name, new_value);\n        dd_close(dd);\n        problem_data_reload_from_dump_dir();\n        update_gui_state_from_problem_data( 0);\n    }\n}", "target": 1}
{"code": "matching_line_len(char_u *lbuf)\n{\n    char_u\t*p = lbuf + 1;\n    p += STRLEN(p) + 1;\n#ifdef FEAT_EMACS_TAGS\n    p += STRLEN(p) + 1;\n#endif\n    return (p - lbuf) + STRLEN(p);\n}", "target": 0}
{"code": "void HeaderMapImpl::remove(const LowerCaseString& key) {\n  EntryCb cb = ConstSingleton<StaticLookupTable>::get().find(key.get());\n  if (cb) {\n    StaticLookupResponse ref_lookup_response = cb(*this);\n    removeInline(ref_lookup_response.entry_);\n  } else {\n    for (auto i = headers_.begin(); i != headers_.end();) {\n      if (i->key() == key.get().c_str()) {\n        subtractSize(i->key().size() + i->value().size());\n        i = headers_.erase(i);\n      } else {\n        ++i;\n      }\n    }\n  }\n}", "target": 0}
{"code": "path_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\tPATH\t   *path;\n\tint\t\t\tisopen;\n\tchar\t   *s;\n\tint\t\t\tnpts;\n\tint\t\t\tsize;\n\tint\t\t\tdepth = 0;\n\tif ((npts = pair_count(str, ',')) <= 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type path: \\\"%s\\\"\", str)));\n\ts = str;\n\twhile (isspace((unsigned char) *s))\n\t\ts++;\n\tif ((*s == LDELIM) && (strrchr(s, LDELIM) == s))\n\t{\n\t\ts++;\n\t\tdepth++;\n\t}\n\tsize = offsetof(PATH, p[0]) +sizeof(path->p[0]) * npts;\n\tpath = (PATH *) palloc(size);\n\tSET_VARSIZE(path, size);\n\tpath->npts = npts;\n\tif ((!path_decode(TRUE, npts, s, &isopen, &s, &(path->p[0])))\n\t&& (!((depth == 0) && (*s == '\\0'))) && !((depth >= 1) && (*s == RDELIM)))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type path: \\\"%s\\\"\", str)));\n\tpath->closed = (!isopen);\n\tpath->dummy = 0;\n\tPG_RETURN_PATH_P(path);\n}", "target": 1}
{"code": "__u32 secure_ip_id(__be32 daddr)\n{\n\tu32 hash[MD5_DIGEST_WORDS];\n\thash[0] = (__force __u32) daddr;\n\thash[1] = net_secret[13];\n\thash[2] = net_secret[14];\n\thash[3] = net_secret[15];\n\tmd5_transform(hash, net_secret);\n\treturn hash[0];\n}", "target": 0}
{"code": "buf_copy(const buf_t *buf)\n{\n  chunk_t *ch;\n  buf_t *out = buf_new();\n  out->default_chunk_size = buf->default_chunk_size;\n  for (ch = buf->head; ch; ch = ch->next) {\n    chunk_t *newch = chunk_copy(ch);\n    if (out->tail) {\n      out->tail->next = newch;\n      out->tail = newch;\n    } else {\n      out->head = out->tail = newch;\n    }\n  }\n  out->datalen = buf->datalen;\n  return out;\n}", "target": 0}
{"code": "bool CmdExtract::ExtrCreateFile(Archive &Arc,File &CurFile)\n{\n  bool Success=true;\n  wchar Command=Cmd->Command[0];\n#if !defined(SFX_MODULE)\n  if (Command=='P')\n    CurFile.SetHandleType(FILE_HANDLESTD);\n#endif\n  if ((Command=='E' || Command=='X') && !Cmd->Test)\n  {\n    bool UserReject;\n    if (!FileCreate(Cmd,&CurFile,DestFileName,ASIZE(DestFileName),&UserReject,Arc.FileHead.UnpSize,&Arc.FileHead.mtime,true))\n    {\n      Success=false;\n      if (!UserReject)\n      {\n        ErrHandler.CreateErrorMsg(Arc.FileName,DestFileName);\n        if (FileExist(DestFileName) && IsDir(GetFileAttr(DestFileName)))\n          uiMsg(UIERROR_DIRNAMEEXISTS);\n#ifdef RARDLL\n        Cmd->DllError=ERAR_ECREATE;\n#endif\n        if (!IsNameUsable(DestFileName))\n        {\n          uiMsg(UIMSG_CORRECTINGNAME,Arc.FileName);\n          wchar OrigName[ASIZE(DestFileName)];\n          wcsncpyz(OrigName,DestFileName,ASIZE(OrigName));\n          MakeNameUsable(DestFileName,true);\n          if (!Cmd->AbsoluteLinks && UpLinkExtracted)\n            LinksToDirs(DestFileName,Cmd->ExtrPath,LastCheckedSymlink);\n          CreatePath(DestFileName,true,Cmd->DisableNames);\n          if (FileCreate(Cmd,&CurFile,DestFileName,ASIZE(DestFileName),&UserReject,Arc.FileHead.UnpSize,&Arc.FileHead.mtime,true))\n          {\n#ifndef SFX_MODULE\n            uiMsg(UIERROR_RENAMING,Arc.FileName,OrigName,DestFileName);\n#endif\n            Success=true;\n          }\n          else\n            ErrHandler.CreateErrorMsg(Arc.FileName,DestFileName);\n        }\n      }\n    }\n  }\n  return Success;\n}", "target": 0}
{"code": "static int copy_counters_to_user(struct ebt_table *t,\n\t\t\t\t  const struct ebt_counter *oldcounters,\n\t\t\t\t  void __user *user, unsigned int num_counters,\n\t\t\t\t  unsigned int nentries)\n{\n\tstruct ebt_counter *counterstmp;\n\tint ret = 0;\n\tif (num_counters == 0)\n\t\treturn 0;\n\tif (num_counters != nentries) {\n\t\tBUGPRINT(\"Num_counters wrong\\n\");\n\t\treturn -EINVAL;\n\t}\n\tcounterstmp = vmalloc(nentries * sizeof(*counterstmp));\n\tif (!counterstmp)\n\t\treturn -ENOMEM;\n\twrite_lock_bh(&t->lock);\n\tget_counters(oldcounters, counterstmp, nentries);\n\twrite_unlock_bh(&t->lock);\n\tif (copy_to_user(user, counterstmp,\n\t   nentries * sizeof(struct ebt_counter)))\n\t\tret = -EFAULT;\n\tvfree(counterstmp);\n\treturn ret;\n}", "target": 0}
{"code": "ModuleExport size_t RegisterPSImage(void)\n{\n  MagickInfo\n    *entry;\n  entry=AcquireMagickInfo(\"PS\",\"EPI\",\n    \"Encapsulated PostScript Interchange format\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PS\",\"EPS\",\"Encapsulated PostScript\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PS\",\"EPSF\",\"Encapsulated PostScript\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PS\",\"EPSI\",\n    \"Encapsulated PostScript Interchange format\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PS\",\"PS\",\"PostScript\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}", "target": 0}
{"code": "static void encode_test_stateid(struct xdr_stream *xdr,\n\t\t\t\tstruct nfs41_test_stateid_args *args,\n\t\t\t\tstruct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_TEST_STATEID, decode_test_stateid_maxsz, hdr);\n\tencode_uint32(xdr, 1);\n\tencode_nfs4_stateid(xdr, args->stateid);\n}", "target": 0}
{"code": "int main(int argc, char *argv[])\n{\n#ifdef _UNIX\n  setlocale(LC_ALL,\"\");\n#endif\n  InitConsole();\n  ErrHandler.SetSignalHandlers(true);\n#ifdef SFX_MODULE\n  wchar ModuleName[NM];\n#ifdef _WIN_ALL\n  GetModuleFileName(NULL,ModuleName,ASIZE(ModuleName));\n#else\n  CharToWide(argv[0],ModuleName,ASIZE(ModuleName));\n#endif\n#endif\n#ifdef _WIN_ALL\n  SetErrorMode(SEM_NOALIGNMENTFAULTEXCEPT|SEM_FAILCRITICALERRORS|SEM_NOOPENFILEERRORBOX);\n#endif\n#if defined(_WIN_ALL) && !defined(SFX_MODULE)\n  POWER_MODE ShutdownOnClose=POWERMODE_KEEP;\n#endif\n  try \n  {\n    CommandData *Cmd=new CommandData;\n#ifdef SFX_MODULE\n    wcscpy(Cmd->Command,L\"X\");\n    char *Switch=argc>1 ? argv[1]:NULL;\n    if (Switch!=NULL && Cmd->IsSwitch(Switch[0]))\n    {\n      int UpperCmd=etoupper(Switch[1]);\n      switch(UpperCmd)\n      {\n        case 'T':\n        case 'V':\n          Cmd->Command[0]=UpperCmd;\n          break;\n        case '?':\n          Cmd->OutHelp(RARX_SUCCESS);\n          break;\n      }\n    }\n    Cmd->AddArcName(ModuleName);\n    Cmd->ParseDone();\n    Cmd->AbsoluteLinks=true; \n#else \n    Cmd->ParseCommandLine(true,argc,argv);\n    if (!Cmd->ConfigDisabled)\n    {\n      Cmd->ReadConfig();\n      Cmd->ParseEnvVar();\n    }\n    Cmd->ParseCommandLine(false,argc,argv);\n#endif\n#if defined(_WIN_ALL) && !defined(SFX_MODULE)\n    ShutdownOnClose=Cmd->Shutdown;\n#endif\n    uiInit(Cmd->Sound);\n    InitLogOptions(Cmd->LogName,Cmd->ErrlogCharset);\n    ErrHandler.SetSilent(Cmd->AllYes || Cmd->MsgStream==MSG_NULL);\n    Cmd->OutTitle();\n    Cmd->ProcessCommand();\n    delete Cmd;\n  }\n  catch (RAR_EXIT ErrCode)\n  {\n    ErrHandler.SetErrorCode(ErrCode);\n  }\n  catch (std::bad_alloc&)\n  {\n    ErrHandler.MemoryErrorMsg();\n    ErrHandler.SetErrorCode(RARX_MEMORY);\n  }\n  catch (...)\n  {\n    ErrHandler.SetErrorCode(RARX_FATAL);\n  }\n#if defined(_WIN_ALL) && !defined(SFX_MODULE)\n  if (ShutdownOnClose!=POWERMODE_KEEP && ErrHandler.IsShutdownEnabled())\n    Shutdown(ShutdownOnClose);\n#endif\n  ErrHandler.MainExit=true;\n  return ErrHandler.GetErrorCode();\n}", "target": 0}
{"code": "static void youngcollection (lua_State *L, global_State *g) {\n  GCObject **psurvival;  \n  lua_assert(g->gcstate == GCSpropagate);\n  markold(g, g->allgc, g->reallyold);\n  markold(g, g->finobj, g->finobjrold);\n  atomic(L);\n  g->gcstate = GCSswpallgc;\n  psurvival = sweepgen(L, g, &g->allgc, g->survival);\n  sweepgen(L, g, psurvival, g->reallyold);\n  g->reallyold = g->old;\n  g->old = *psurvival;  \n  g->survival = g->allgc;  \n  psurvival = sweepgen(L, g, &g->finobj, g->finobjsur);\n  sweepgen(L, g, psurvival, g->finobjrold);\n  g->finobjrold = g->finobjold;\n  g->finobjold = *psurvival;  \n  g->finobjsur = g->finobj;  \n  sweepgen(L, g, &g->tobefnz, NULL);\n  finishgencycle(L, g);\n}", "target": 0}
{"code": "static void server_real_connect(SERVER_REC *server, IPADDR *ip,\n\t\t\t\tconst char *unix_socket)\n{\n\tGIOChannel *handle;\n\tIPADDR *own_ip = NULL;\n\tconst char *errmsg;\n\tchar *errmsg2;\n\tchar ipaddr[MAX_IP_LEN];\n        int port;\n\tg_return_if_fail(ip != NULL || unix_socket != NULL);\n\tsignal_emit(\"server connecting\", 2, server, ip);\n\tif (server->connrec->no_connect)\n\t\treturn;\n\tif (ip != NULL) {\n\t\town_ip = ip == NULL ? NULL :\n\t\t\t(IPADDR_IS_V6(ip) ? server->connrec->own_ip6 :\n\t\t\t server->connrec->own_ip4);\n\t\tport = server->connrec->proxy != NULL ?\n\t\t\tserver->connrec->proxy_port : server->connrec->port;\n\t\thandle = server->connrec->use_ssl ?\n\t\t\tnet_connect_ip_ssl(ip, port, own_ip, server->connrec->ssl_cert, server->connrec->ssl_pkey,\nserver->connrec->ssl_cafile, server->connrec->ssl_capath, server->connrec->ssl_verify) :\n\t\t\tnet_connect_ip(ip, port, own_ip);\n\t} else {\n\t\thandle = net_connect_unix(unix_socket);\n\t}\n\tif (handle == NULL) {\n\t\terrmsg = g_strerror(errno);\n\t\terrmsg2 = NULL;\n\t\tif (errno == EADDRNOTAVAIL) {\n\t\t\tif (own_ip != NULL) {\n\t\t\t\tnet_ip2host(own_ip, ipaddr);\n\t\t\t\terrmsg2 = g_strconcat(errmsg, \": \", ipaddr, NULL);\n\t\t\t}\n\t\t\tserver->no_reconnect = TRUE;\n\t\t}\n\t\tif (server->connrec->use_ssl && errno == ENOSYS)\n\t\t\tserver->no_reconnect = TRUE;\n\t\tserver->connection_lost = TRUE;\n\t\tserver_connect_failed(server, errmsg2 ? errmsg2 : errmsg);\n\t\tg_free(errmsg2);\n\t} else {\n\t\tserver->handle = net_sendbuffer_create(handle, 0);\n#ifdef HAVE_OPENSSL\n\t\tif (server->connrec->use_ssl)\n\t\t\tserver_connect_callback_init_ssl(server, handle);\n\t\telse\n#endif\n\t\tserver->connect_tag =\n\t\t\tg_input_add(handle, G_INPUT_WRITE | G_INPUT_READ,\n\t\t\t\t    (GInputFunction)\n\t\t\t\t    server_connect_callback_init,\n\t\t\t\t    server);\n\t}\n}", "target": 1}
{"code": "static void ptirq_free_irte(const struct ptirq_remapping_info *entry)\n{\n\tstruct intr_source intr_src;\n\tif (entry->irte_idx < CONFIG_MAX_IR_ENTRIES) {\n\t\tif (entry->intr_type == PTDEV_INTR_MSI) {\n\t\t\tintr_src.is_msi = true;\n\t\t\tintr_src.src.msi.value = entry->phys_sid.msi_id.bdf;\n\t\t} else {\n\t\t\tintr_src.is_msi = false;\n\t\t\tintr_src.src.ioapic_id = ioapic_irq_to_ioapic_id(entry->allocated_pirq);\n\t\t}\n\t\tdmar_free_irte(&intr_src, entry->irte_idx);\n\t}\n}", "target": 1}
{"code": "static inline item* limited_get(char *key, size_t nkey, conn *c) {\n    item *it = item_get(key, nkey, c, DO_UPDATE);\n    if (it && it->refcount > IT_REFCOUNT_LIMIT) {\n        item_remove(it);\n        it = NULL;\n    }\n    return it;\n}", "target": 0}
{"code": "static struct ion_handle *ion_handle_get_by_id_nolock(struct ion_client *client,\n\t\t\t\t\t\tint id)\n{\n\tstruct ion_handle *handle;\n\thandle = idr_find(&client->idr, id);\n\tif (handle)\n\t\tion_handle_get(handle);\n\treturn handle ? handle : ERR_PTR(-EINVAL);\n}", "target": 0}
{"code": "bqarr_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *buf = (char *) PG_GETARG_POINTER(0);\n\tWORKSTATE\tstate;\n\tint32\t\ti;\n\tQUERYTYPE  *query;\n\tint32\t\tcommonlen;\n\tITEM\t   *ptr;\n\tNODE\t   *tmp;\n\tint32\t\tpos = 0;\n#ifdef BS_DEBUG\n\tStringInfoData pbuf;\n#endif\n\tstate.buf = buf;\n\tstate.state = WAITOPERAND;\n\tstate.count = 0;\n\tstate.num = 0;\n\tstate.str = NULL;\n\tmakepol(&state);\n\tif (!state.num)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"empty query\")));\n\tif (state.num > QUERYTYPEMAXITEMS)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\terrmsg(\"number of query items (%d) exceeds the maximum allowed (%d)\",\n\t\t\t   state.num, (int) QUERYTYPEMAXITEMS)));\n\tcommonlen = COMPUTESIZE(state.num);\n\tquery = (QUERYTYPE *) palloc(commonlen);\n\tSET_VARSIZE(query, commonlen);\n\tquery->size = state.num;\n\tptr = GETQUERY(query);\n\tfor (i = state.num - 1; i >= 0; i--)\n\t{\n\t\tptr[i].type = state.str->type;\n\t\tptr[i].val = state.str->val;\n\t\ttmp = state.str->next;\n\t\tpfree(state.str);\n\t\tstate.str = tmp;\n\t}\n\tpos = query->size - 1;\n\tfindoprnd(ptr, &pos);\n#ifdef BS_DEBUG\n\tinitStringInfo(&pbuf);\n\tfor (i = 0; i < query->size; i++)\n\t{\n\t\tif (ptr[i].type == OPR)\n\t\t\tappendStringInfo(&pbuf, \"%c(%d) \", ptr[i].val, ptr[i].left);\n\t\telse\n\t\t\tappendStringInfo(&pbuf, \"%d \", ptr[i].val);\n\t}\n\telog(DEBUG3, \"POR: %s\", pbuf.data);\n\tpfree(pbuf.data);\n#endif\n\tPG_RETURN_POINTER(query);\n}", "target": 0}
{"code": "void ___might_sleep(const char *file, int line, int preempt_offset)\n{\n\tstatic unsigned long prev_jiffy;\t\n\trcu_sleep_check(); \n\tif ((preempt_count_equals(preempt_offset) && !irqs_disabled() &&\n\t     !is_idle_task(current)) ||\n\t    system_state != SYSTEM_RUNNING || oops_in_progress)\n\t\treturn;\n\tif (time_before(jiffies, prev_jiffy + HZ) && prev_jiffy)\n\t\treturn;\n\tprev_jiffy = jiffies;\n\tprintk(KERN_ERR\n\t\t\"BUG: sleeping function called from invalid context at %s:%d\\n\",\n\t\t\tfile, line);\n\tprintk(KERN_ERR\n\t\t\"in_atomic(): %d, irqs_disabled(): %d, pid: %d, name: %s\\n\",\n\t\t\tin_atomic(), irqs_disabled(),\n\t\t\tcurrent->pid, current->comm);\n\tif (task_stack_end_corrupted(current))\n\t\tprintk(KERN_EMERG \"Thread overran stack, or stack corrupted\\n\");\n\tdebug_show_held_locks(current);\n\tif (irqs_disabled())\n\t\tprint_irqtrace_events(current);\n#ifdef CONFIG_DEBUG_PREEMPT\n\tif (!preempt_count_equals(preempt_offset)) {\n\t\tpr_err(\"Preemption disabled at:\");\n\t\tprint_ip_sym(current->preempt_disable_ip);\n\t\tpr_cont(\"\\n\");\n\t}\n#endif\n\tdump_stack();\n}", "target": 0}
{"code": "std::string get_wml_location(const std::string &filename, const std::string &current_dir)\n{\n\tDBG_FS << \"Looking for '\" << filename << \"'.\" << std::endl;\n\tassert(game_config::path.empty() == false);\n\tstd::string result;\n\tif (filename.empty()) {\n\t\tLOG_FS << \"  invalid filename\" << std::endl;\n\t\treturn result;\n\t}\n\tif (filename.find(\"..\") != std::string::npos) {\n\t\tERR_FS << \"Illegal path '\" << filename << \"' (\\\"..\\\" not allowed).\" << std::endl;\n\t\treturn result;\n\t}\n\tif (looks_like_pbl(filename)) {\n\t\tERR_FS << \"Illegal path '\" << filename << \"' (.pbl files are not allowed).\" << std::endl;\n\t\treturn result;\n\t}\n\tbool already_found = false;\n\tif (filename[0] == '~')\n\t{\n\t\tresult = get_user_data_dir() + \"/data/\" + filename.substr(1);\n\t\tDBG_FS << \"  trying '\" << result << \"'\" << std::endl;\n\t\talready_found = file_exists(result) || is_directory(result);\n\t}\n\telse if (filename.size() >= 2 && filename[0] == '.' && filename[1] == '/')\n\t{\n\t\tif (!current_dir.empty())\n\t\t{\n\t\t\tresult = current_dir;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = game_config::path;\n\t\t}\n\t\tresult += filename.substr(2);\n\t}\n\telse if (!game_config::path.empty())\n\t\tresult = game_config::path + \"/data/\" + filename;\n\tDBG_FS << \"  trying '\" << result << \"'\" << std::endl;\n\tif (result.empty() ||\n\t    (!already_found && !file_exists(result) && !is_directory(result)))\n\t{\n\t\tDBG_FS << \"  not found\" << std::endl;\n\t\tresult.clear();\n\t}\n\telse\n\t\tDBG_FS << \"  found: '\" << result << \"'\" << std::endl;\n\treturn result;\n}", "target": 0}
{"code": "IW_IMPL(unsigned int) iw_get_ui16le(const iw_byte *b)\n{\n\treturn b[0] | (b[1]<<8);\n}", "target": 1}
{"code": "smb_com_flush(smb_request_t *sr)\n{\n\tsmb_ofile_t\t*file;\n\tsmb_llist_t\t*flist;\n\tint\t\trc;\n\tif (smb_flush_required == 0) {\n\t\trc = smbsr_encode_empty_result(sr);\n\t\treturn ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);\n\t}\n\tif (sr->smb_fid != 0xffff) {\n\t\tsmbsr_lookup_file(sr);\n\t\tif (sr->fid_ofile == NULL) {\n\t\t\tsmbsr_error(sr, NT_STATUS_INVALID_HANDLE,\n\t\t\t    ERRDOS, ERRbadfid);\n\t\t\treturn (SDRC_ERROR);\n\t\t}\n\t\tsmb_flush_file(sr, sr->fid_ofile);\n\t} else {\n\t\tflist = &sr->tid_tree->t_ofile_list;\n\t\tsmb_llist_enter(flist, RW_READER);\n\t\tfile = smb_llist_head(flist);\n\t\twhile (file) {\n\t\t\tmutex_enter(&file->f_mutex);\n\t\t\tsmb_flush_file(sr, file);\n\t\t\tmutex_exit(&file->f_mutex);\n\t\t\tfile = smb_llist_next(flist, file);\n\t\t}\n\t\tsmb_llist_exit(flist);\n\t}\n\trc = smbsr_encode_empty_result(sr);\n\treturn ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);\n}", "target": 1}
{"code": "static int lsm_openat(int procfd, pid_t pid, int on_exec)\n{\n\tint ret = -1;\n\tint labelfd = -1;\n\tconst char* name;\n#define __LSMATTRLEN  (5 +  21 +  7 +  1)\n\tchar path[__LSMATTRLEN];\n\tname = lsm_name();\n\tif (strcmp(name, \"nop\") == 0)\n\t\treturn 0;\n\tif (strcmp(name, \"none\") == 0)\n\t\treturn 0;\n\tif (strcmp(name, \"AppArmor\") == 0)\n\t\ton_exec = 0;\n\tif (on_exec) {\n\t\tret = snprintf(path, __LSMATTRLEN, \"%d/attr/exec\", pid);\n\t\tif (ret < 0 || ret >= __LSMATTRLEN)\n\t\t\treturn -1;\n\t\tlabelfd = openat(procfd, path, O_RDWR);\n\t} else {\n\t\tret = snprintf(path, __LSMATTRLEN, \"%d/attr/current\", pid);\n\t\tif (ret < 0 || ret >= __LSMATTRLEN)\n\t\t\treturn -1;\n\t\tlabelfd = openat(procfd, path, O_RDWR);\n\t}\n\tif (labelfd < 0) {\n\t\tSYSERROR(\"Unable to open LSM label\");\n\t\treturn -1;\n\t}\n\treturn labelfd;\n}", "target": 0}
{"code": "static int ipddp_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n        struct ipddp_route __user *rt = ifr->ifr_data;\n        struct ipddp_route rcp, rcp2, *rp;\n        if(!capable(CAP_NET_ADMIN))\n                return -EPERM;\n\tif(copy_from_user(&rcp, rt, sizeof(rcp)))\n\t\treturn -EFAULT;\n        switch(cmd)\n        {\n\t\tcase SIOCADDIPDDPRT:\n                        return ipddp_create(&rcp);\n                case SIOCFINDIPDDPRT:\n\t\t\tspin_lock_bh(&ipddp_route_lock);\n\t\t\trp = __ipddp_find_route(&rcp);\n\t\t\tif (rp)\n\t\t\t\tmemcpy(&rcp2, rp, sizeof(rcp2));\n\t\t\tspin_unlock_bh(&ipddp_route_lock);\n\t\t\tif (rp) {\n\t\t\t\tif (copy_to_user(rt, &rcp2,\n\t\t\t\t\t\t sizeof(struct ipddp_route)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn -ENOENT;\n                case SIOCDELIPDDPRT:\n                        return ipddp_delete(&rcp);\n                default:\n                        return -EINVAL;\n        }\n}", "target": 1}
{"code": "mmsServer_handleFileDeleteRequest(\n    MmsServerConnection connection,\n    uint8_t* buffer, int bufPos, int maxBufPos,\n    uint32_t invokeId,\n    ByteBuffer* response)\n{\n    if (buffer[bufPos++] != 0x19)\n        goto exit_reject_invalid_pdu;\n    int length;\n    bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n    if (bufPos == -1)\n        goto exit_reject_invalid_pdu;\n    if (length > 255) {\n        mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_REQUEST_INVALID_ARGUMENT, response);\n        return;\n    }\n    char filename[256];\n    memcpy(filename, buffer + bufPos, length);\n    filename[length] = 0;\n    if (DEBUG_MMS_SERVER)\n        printf(\"MMS_SERVER: mms_file_service.c: Delete file (%s)\\n\", filename);\n    if (mmsMsg_isFilenameSave(filename) == false)\n    {\n        if (DEBUG_MMS_SERVER)\n            printf(\"MMS_SERVER: remote provided unsave filename -> rejected\\n\");\n        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n        return;\n    }\n    if (connection->server->fileAccessHandler != NULL) {\n        MmsError access = connection->server->fileAccessHandler(connection->server->fileAccessHandlerParameter,\n                            connection, MMS_FILE_ACCESS_TYPE_DELETE, filename, NULL);\n        if (access != MMS_ERROR_NONE) {\n            mmsMsg_createServiceErrorPdu(invokeId, response, access);\n            return;\n        }\n    }\n    if (!getFileInfo(MmsServerConnection_getFilesystemBasepath(connection), filename, NULL, NULL)) {\n        if (DEBUG_MMS_SERVER)\n            printf(\"MMS_SERVER: mms_file_service.c:  File (%s) not found\\n\", filename);\n        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n        return;\n    }\n    if (!deleteFile(MmsServerConnection_getFilesystemBasepath(connection), filename)) {\n        if (DEBUG_MMS_SERVER)\n            printf(\"MMS_SERVER: mms_file_service.c:  Delete file (%s) failed\\n\", filename);\n        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_ACCESS_DENIED);\n        return;\n    }\n    createNullResponseExtendedTag(invokeId, response, 0x4c);\n    return;\nexit_reject_invalid_pdu:\n    mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n}", "target": 0}
{"code": "void Context::onStart(absl::string_view root_id, absl::string_view vm_configuration) {\n  if (wasm_->onStart_) {\n    auto root_id_addr = wasm_->copyString(root_id);\n    auto config_addr = wasm_->copyString(vm_configuration);\n    wasm_->onStart_(this, id_, root_id_addr, root_id.size(), config_addr, vm_configuration.size());\n  }\n  in_vm_context_created_ = true;\n}", "target": 0}
{"code": "authDigestNonceLinks(digest_nonce_h * nonce)\n{\n    if (!nonce)\n        return -1;\n    return nonce->references;\n}", "target": 1}
{"code": "read_mysql_variables_from_result(MYSQL_RES *mysql_result, mysql_variable *vars,\n\tbool vertical_result)\n{\n\tMYSQL_ROW row;\n\tmysql_variable *var;\n\tut_ad(!vertical_result || mysql_num_fields(mysql_result) == 2);\n\tint rows_read = 0;\n\tif (vertical_result) {\n\t\twhile ((row = mysql_fetch_row(mysql_result))) {\n\t\t\t++rows_read;\n\t\t\tchar *name = row[0];\n\t\t\tchar *value = row[1];\n\t\t\tfor (var = vars; var->name; var++) {\n\t\t\t\tif (strcmp(var->name, name) == 0\n\t\t\t\t    && value != NULL) {\n\t\t\t\t\t*(var->value) = strdup(value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tMYSQL_FIELD *field;\n\t\tif ((row = mysql_fetch_row(mysql_result)) != NULL) {\n\t\t\tmysql_field_seek(mysql_result, 0);\n\t\t\t++rows_read;\n\t\t\tint i = 0;\n\t\t\twhile ((field = mysql_fetch_field(mysql_result))\n\t\t\t\t!= NULL) {\n\t\t\t\tchar *name = field->name;\n\t\t\t\tchar *value = row[i];\n\t\t\t\tfor (var = vars; var->name; var++) {\n\t\t\t\t\tif (strcmp(var->name, name) == 0\n\t\t\t\t\t    && value != NULL) {\n\t\t\t\t\t\t*(var->value) = strdup(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t}\n\treturn rows_read;\n}", "target": 0}
{"code": "vhost_scsi_send_evt(struct vhost_scsi *vs,\n\t\t   struct vhost_scsi_tpg *tpg,\n\t\t   struct se_lun *lun,\n\t\t   u32 event,\n\t\t   u32 reason)\n{\n\tstruct vhost_scsi_evt *evt;\n\tevt = vhost_scsi_allocate_evt(vs, event, reason);\n\tif (!evt)\n\t\treturn;\n\tif (tpg && lun) {\n\t\tevt->event.lun[0] = 0x01;\n\t\tevt->event.lun[1] = tpg->tport_tpgt & 0xFF;\n\t\tif (lun->unpacked_lun >= 256)\n\t\t\tevt->event.lun[2] = lun->unpacked_lun >> 8 | 0x40 ;\n\t\tevt->event.lun[3] = lun->unpacked_lun & 0xFF;\n\t}\n\tllist_add(&evt->list, &vs->vs_event_list);\n\tvhost_work_queue(&vs->dev, &vs->vs_event_work);\n}", "target": 1}
{"code": "void bnep_net_setup(struct net_device *dev)\n{\n\tmemset(dev->broadcast, 0xff, ETH_ALEN);\n\tdev->addr_len = ETH_ALEN;\n\tether_setup(dev);\n\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\tdev->netdev_ops = &bnep_netdev_ops;\n\tdev->watchdog_timeo  = HZ * 2;\n}", "target": 0}
{"code": "static void dp8393x_do_load_cam(dp8393xState *s)\n{\n    int width, size;\n    uint16_t index = 0;\n    width = (s->regs[SONIC_DCR] & SONIC_DCR_DW) ? 2 : 1;\n    size = sizeof(uint16_t) * 4 * width;\n    while (s->regs[SONIC_CDC] & 0x1f) {\n        address_space_read(&s->as, dp8393x_cdp(s),\n                           MEMTXATTRS_UNSPECIFIED, s->data, size);\n        s->cam[index][0] = dp8393x_get(s, width, 1) & 0xff;\n        s->cam[index][1] = dp8393x_get(s, width, 1) >> 8;\n        s->cam[index][2] = dp8393x_get(s, width, 2) & 0xff;\n        s->cam[index][3] = dp8393x_get(s, width, 2) >> 8;\n        s->cam[index][4] = dp8393x_get(s, width, 3) & 0xff;\n        s->cam[index][5] = dp8393x_get(s, width, 3) >> 8;\n        DPRINTF(\"load cam[%d] with %02x%02x%02x%02x%02x%02x\\n\", index,\n            s->cam[index][0], s->cam[index][1], s->cam[index][2],\n            s->cam[index][3], s->cam[index][4], s->cam[index][5]);\n        s->regs[SONIC_CDC]--;\n        s->regs[SONIC_CDP] += size;\n        index++;\n    }\n    address_space_read(&s->as, dp8393x_cdp(s),\n                       MEMTXATTRS_UNSPECIFIED, s->data, size);\n    s->regs[SONIC_CE] = dp8393x_get(s, width, 0);\n    DPRINTF(\"load cam done. cam enable mask 0x%04x\\n\", s->regs[SONIC_CE]);\n    s->regs[SONIC_CR] &= ~SONIC_CR_LCAM;\n    s->regs[SONIC_ISR] |= SONIC_ISR_LCD;\n    dp8393x_update_irq(s);\n}", "target": 0}
{"code": "static ssize_t lbs_debugfs_write(struct file *f, const char __user *buf,\n\t\t\t    size_t cnt, loff_t *ppos)\n{\n\tint r, i;\n\tchar *pdata;\n\tchar *p;\n\tchar *p0;\n\tchar *p1;\n\tchar *p2;\n\tstruct debug_data *d = f->private_data;\n\tpdata = kmalloc(cnt, GFP_KERNEL);\n\tif (pdata == NULL)\n\t\treturn 0;\n\tif (copy_from_user(pdata, buf, cnt)) {\n\t\tlbs_deb_debugfs(\"Copy from user failed\\n\");\n\t\tkfree(pdata);\n\t\treturn 0;\n\t}\n\tp0 = pdata;\n\tfor (i = 0; i < num_of_items; i++) {\n\t\tdo {\n\t\t\tp = strstr(p0, d[i].name);\n\t\t\tif (p == NULL)\n\t\t\t\tbreak;\n\t\t\tp1 = strchr(p, '\\n');\n\t\t\tif (p1 == NULL)\n\t\t\t\tbreak;\n\t\t\tp0 = p1++;\n\t\t\tp2 = strchr(p, '=');\n\t\t\tif (!p2)\n\t\t\t\tbreak;\n\t\t\tp2++;\n\t\t\tr = simple_strtoul(p2, NULL, 0);\n\t\t\tif (d[i].size == 1)\n\t\t\t\t*((u8 *) d[i].addr) = (u8) r;\n\t\t\telse if (d[i].size == 2)\n\t\t\t\t*((u16 *) d[i].addr) = (u16) r;\n\t\t\telse if (d[i].size == 4)\n\t\t\t\t*((u32 *) d[i].addr) = (u32) r;\n\t\t\telse if (d[i].size == 8)\n\t\t\t\t*((u64 *) d[i].addr) = (u64) r;\n\t\t\tbreak;\n\t\t} while (1);\n\t}\n\tkfree(pdata);\n\treturn (ssize_t)cnt;\n}", "target": 1}
{"code": "hphp_libxml_input_buffer(const char *URI, xmlCharEncoding enc) {\n  if (s_libxml_errors->m_entity_loader_disabled) {\n    return nullptr;\n  }\n  return __xmlParserInputBufferCreateFilename(URI, enc);\n}", "target": 0}
{"code": "init_syntax_once ()\n{\n   register int c;\n   static int done;\n   if (done)\n     return;\n   bzero (re_syntax_table, sizeof re_syntax_table);\n   for (c = 'a'; c <= 'z'; c++)\n     re_syntax_table[c] = Sword;\n   for (c = 'A'; c <= 'Z'; c++)\n     re_syntax_table[c] = Sword;\n   for (c = '0'; c <= '9'; c++)\n     re_syntax_table[c] = Sword;\n   re_syntax_table['_'] = Sword;\n   done = 1;\n}", "target": 1}
{"code": "GF_Err stbl_AppendTime(GF_SampleTableBox *stbl, u32 duration, u32 nb_pack)\n{\n\tGF_TimeToSampleBox *stts = stbl->TimeToSample;\n\tif (!nb_pack) nb_pack = 1;\n\tif (stts->nb_entries) {\n\t\tif (stts->entries[stts->nb_entries-1].sampleDelta == duration) {\n\t\t\tstts->entries[stts->nb_entries-1].sampleCount += nb_pack;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\tif (stts->nb_entries==stts->alloc_size) {\n\t\tALLOC_INC(stts->alloc_size);\n\t\tstts->entries = gf_realloc(stts->entries, sizeof(GF_SttsEntry)*stts->alloc_size);\n\t\tif (!stts->entries) return GF_OUT_OF_MEM;\n\t\tmemset(&stts->entries[stts->nb_entries], 0, sizeof(GF_SttsEntry)*(stts->alloc_size-stts->nb_entries) );\n\t}\n\tstts->entries[stts->nb_entries].sampleCount = nb_pack;\n\tstts->entries[stts->nb_entries].sampleDelta = duration;\n\tstts->nb_entries++;\n\tif (stts->max_ts_delta < duration ) stts->max_ts_delta = duration;\n\treturn GF_OK;\n}", "target": 1}
{"code": "tlb_update_vma_flags(struct mmu_gather *tlb, struct vm_area_struct *vma) { }", "target": 1}
{"code": "static void msg_read_tiny(const uint8_t *msg, size_t len) {\n    if (len != 64)\n        return;\n    uint8_t buf[64];\n    memcpy(buf, msg, sizeof(buf));\n    if (buf[0] != '?' || buf[1] != '#' || buf[2] != '#') {\n        (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Malformed tiny packet\");\n        return;\n    }\n    uint16_t msgId = buf[4] | ((uint16_t)buf[3]) << 8;\n    uint32_t msgSize = buf[8]        |\n            ((uint32_t)buf[7]) <<  8 |\n            ((uint32_t)buf[6]) << 16 |\n            ((uint32_t)buf[5]) << 24;\n    if (msgSize > 64 - 9) {\n        (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Malformed tiny packet\");\n        return;\n    }\n    const pb_field_t *fields = NULL;\n    pb_istream_t stream = pb_istream_from_buffer(buf + 9, msgSize);\n    switch (msgId) {\n    case MessageType_MessageType_PinMatrixAck:\n        fields = PinMatrixAck_fields;\n        break;\n    case MessageType_MessageType_ButtonAck:\n        fields = ButtonAck_fields;\n        break;\n    case MessageType_MessageType_PassphraseAck:\n        fields = PassphraseAck_fields;\n        break;\n    case MessageType_MessageType_Cancel:\n        fields = Cancel_fields;\n        break;\n    case MessageType_MessageType_Initialize:\n        fields = Initialize_fields;\n        break;\n#if DEBUG_LINK\n    case MessageType_MessageType_DebugLinkDecision:\n        fields = DebugLinkDecision_fields;\n        break;\n    case MessageType_MessageType_DebugLinkGetState:\n        fields = DebugLinkGetState_fields;\n        break;\n#endif\n    }\n    if (fields) {\n        bool status = pb_decode(&stream, fields, msg_tiny);\n        if (status) {\n            msg_tiny_id = msgId;\n        } else {\n            (*msg_failure)(FailureType_Failure_SyntaxError, stream.errmsg);\n            msg_tiny_id = 0xffff;\n        }\n    } else {\n        (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Unknown message\");\n        msg_tiny_id = 0xffff;\n    }\n}", "target": 0}
{"code": "START_TEST(test_log_long_msg)\n{\n\tint lpc;\n\tint rc;\n\tint i, max = 1000;\n\tchar *buffer = calloc(1, max);\n\tqb_log_init(\"test\", LOG_USER, LOG_DEBUG);\n\trc = qb_log_ctl(QB_LOG_SYSLOG, QB_LOG_CONF_ENABLED, QB_FALSE);\n\tck_assert_int_eq(rc, 0);\n\trc = qb_log_ctl(QB_LOG_BLACKBOX, QB_LOG_CONF_SIZE, 1024);\n\tck_assert_int_eq(rc, 0);\n\trc = qb_log_ctl(QB_LOG_BLACKBOX, QB_LOG_CONF_ENABLED, QB_TRUE);\n\tck_assert_int_eq(rc, 0);\n\trc = qb_log_filter_ctl(QB_LOG_BLACKBOX, QB_LOG_FILTER_ADD,\n\t\t\t  QB_LOG_FILTER_FILE, \"*\", LOG_TRACE);\n\tck_assert_int_eq(rc, 0);\n\tfor (lpc = 500; lpc < max; lpc++) {\n\t\tlpc++;\n\t\tfor(i = 0; i < max; i++) {\n\t\t\tbuffer[i] = 'a' + (i % 10);\n\t\t}\n\t\tbuffer[lpc%600] = 0;\n\t\tqb_log(LOG_INFO, \"Message %d %d - %s\", lpc, lpc%600, buffer);\n\t}\n        qb_log_blackbox_write_to_file(\"blackbox.dump\");\n        qb_log_blackbox_print_from_file(\"blackbox.dump\");\n\tunlink(\"blackbox.dump\");\n\tqb_log_fini();\n}", "target": 1}
{"code": "void JNIid::deallocate(JNIid* current) {\n  while (current != NULL) {\n    JNIid* next = current->next();\n    delete current;\n    current = next;\n  }\n}", "target": 0}
{"code": "bool IsFullyConnectedOpSupported(const TfLiteRegistration* registration,\n                                 const TfLiteNode* node,\n                                 TfLiteContext* context) {\n  if (node->builtin_data == nullptr) return false;\n  const auto* fc_params =\n      reinterpret_cast<const TfLiteFullyConnectedParams*>(node->builtin_data);\n  const int kInput = 0;\n  const int kWeights = 1;\n  const int kBias = 2;\n  if (fc_params->weights_format != kTfLiteFullyConnectedWeightsFormatDefault) {\n    return false;\n  }\n  const TfLiteTensor* input = GetInput(context, node, kInput);\n  const TfLiteTensor* weights = GetInput(context, node, kWeights);\n  if (!IsFloatType(input->type)) {\n    return false;\n  }\n  if (!IsFloatType(weights->type) || !IsConstantTensor(weights)) {\n    return false;\n  }\n  if (input->dims->data[input->dims->size - 1] != NumElements(input)) {\n    return false;\n  }\n  if (node->inputs->size > 2) {\n    const TfLiteTensor* bias = GetInput(context, node, kBias);\n    if (!IsFloatType(bias->type) || !IsConstantTensor(bias)) {\n      return false;\n    }\n  }\n  TfLiteFusedActivation activation = fc_params->activation;\n  if (activation == kTfLiteActSignBit) {\n    return false;\n  }\n  return true;\n}", "target": 1}
{"code": "int main(int argc, char **argv, char **envp)\n{\n#ifdef DYNLOAD\n    if (!uc_dyn_load(NULL, 0)) {\n        printf(\"Error dynamically loading shared library.\\n\");\n        printf(\"Please check that unicorn.dll/unicorn.so is available as well as\\n\");\n        printf(\"any other dependent dll/so files.\\n\");\n        printf(\"The easiest way is to place them in the same directory as this app.\\n\");\n        return 1;\n    }\n#endif\n    test_arm();\n    printf(\"==========================\\n\");\n    test_thumb();\n#ifdef DYNLOAD\n    uc_dyn_free();\n#endif\n    return 0;\n}", "target": 1}
{"code": "static inline int fpregs_state_valid(struct fpu *fpu, unsigned int cpu)\n{\n\treturn fpu == this_cpu_read_stable(fpu_fpregs_owner_ctx) && cpu == fpu->last_cpu;\n}", "target": 1}
{"code": "void bpf_int_jit_compile(struct bpf_prog *prog)\n{\n\tstruct bpf_binary_header *header = NULL;\n\tint proglen, oldproglen = 0;\n\tstruct jit_context ctx = {};\n\tu8 *image = NULL;\n\tint *addrs;\n\tint pass;\n\tint i;\n\tif (!bpf_jit_enable)\n\t\treturn;\n\tif (!prog || !prog->len)\n\t\treturn;\n\taddrs = kmalloc(prog->len * sizeof(*addrs), GFP_KERNEL);\n\tif (!addrs)\n\t\treturn;\n\tfor (proglen = 0, i = 0; i < prog->len; i++) {\n\t\tproglen += 64;\n\t\taddrs[i] = proglen;\n\t}\n\tctx.cleanup_addr = proglen;\n\tfor (pass = 0; pass < 10; pass++) {\n\t\tproglen = do_jit(prog, addrs, image, oldproglen, &ctx);\n\t\tif (proglen <= 0) {\n\t\t\timage = NULL;\n\t\t\tif (header)\n\t\t\t\tbpf_jit_binary_free(header);\n\t\t\tgoto out;\n\t\t}\n\t\tif (image) {\n\t\t\tif (proglen != oldproglen) {\n\t\t\t\tpr_err(\"bpf_jit: proglen=%d != oldproglen=%d\\n\",\n\t\t\t\t       proglen, oldproglen);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (proglen == oldproglen) {\n\t\t\theader = bpf_jit_binary_alloc(proglen, &image,\n\t\t\t\t\t\t      1, jit_fill_hole);\n\t\t\tif (!header)\n\t\t\t\tgoto out;\n\t\t}\n\t\toldproglen = proglen;\n\t}\n\tif (bpf_jit_enable > 1)\n\t\tbpf_jit_dump(prog->len, proglen, 0, image);\n\tif (image) {\n\t\tbpf_flush_icache(header, image + proglen);\n\t\tset_memory_ro((unsigned long)header, header->pages);\n\t\tprog->bpf_func = (void *)image;\n\t\tprog->jited = true;\n\t}\nout:\n\tkfree(addrs);\n}", "target": 1}
{"code": "int dns_add_rr_nested_memcpy(struct dns_rr_nested *rr_nested, void *data, int data_len)\n{\n\tif (rr_nested == NULL || data == NULL || data_len <= 0) {\n\t\treturn -1;\n\t}\n\tif (_dns_left_len(&rr_nested->context) < data_len) {\n\t\treturn -1;\n\t}\n\tmemcpy(rr_nested->context.ptr, data, data_len);\n\trr_nested->context.ptr += data_len;\n\treturn 0;\n}", "target": 1}
{"code": "raw_copy_from_user(void *to, const void __user *from, unsigned long n)\n{\n\tif (__builtin_constant_p(n)) {\n\t\tunsigned long ret;\n\t\tswitch (n) {\n\t\tcase 1:\n\t\t\tret = 0;\n\t\t\t__uaccess_begin_nospec();\n\t\t\t__get_user_asm_nozero(*(u8 *)to, from, ret,\n\t\t\t\t\t      \"b\", \"b\", \"=q\", 1);\n\t\t\t__uaccess_end();\n\t\t\treturn ret;\n\t\tcase 2:\n\t\t\tret = 0;\n\t\t\t__uaccess_begin_nospec();\n\t\t\t__get_user_asm_nozero(*(u16 *)to, from, ret,\n\t\t\t\t\t      \"w\", \"w\", \"=r\", 2);\n\t\t\t__uaccess_end();\n\t\t\treturn ret;\n\t\tcase 4:\n\t\t\tret = 0;\n\t\t\t__uaccess_begin_nospec();\n\t\t\t__get_user_asm_nozero(*(u32 *)to, from, ret,\n\t\t\t\t\t      \"l\", \"k\", \"=r\", 4);\n\t\t\t__uaccess_end();\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn __copy_user_ll(to, (__force const void *)from, n);\n}", "target": 1}
{"code": "static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs, uid_t uid, gid_t gid)\n{\n    FILE *fp = fopen(dest_filename, \"wx\");\n    if (!fp)\n        return false;\n    unsigned fd = 0;\n    while (fd <= 99999) \n    {\n        sprintf(source_filename + source_base_ofs, \"fd/%u\", fd);\n        char *name = malloc_readlink(source_filename);\n        if (!name)\n            break;\n        fprintf(fp, \"%u:%s\\n\", fd, name);\n        free(name);\n        sprintf(source_filename + source_base_ofs, \"fdinfo/%u\", fd);\n        fd++;\n        FILE *in = fopen(source_filename, \"r\");\n        if (!in)\n            continue;\n        char buf[128];\n        while (fgets(buf, sizeof(buf)-1, in))\n        {\n            char *eol = strchrnul(buf, '\\n');\n            eol[0] = '\\n';\n            eol[1] = '\\0';\n            fputs(buf, fp);\n        }\n        fclose(in);\n    }\n    const int dest_fd = fileno(fp);\n    if (fchown(dest_fd, uid, gid) < 0)\n    {\n        perror_msg(\"Can't change '%s' ownership to %lu:%lu\", dest_filename, (long)uid, (long)gid);\n        fclose(fp);\n        unlink(dest_filename);\n        return false;\n    }\n    fclose(fp);\n    return true;\n}", "target": 0}
{"code": "static bool glfs_check_config(const char *cfgstring, char **reason)\n{\n\tchar *path;\n\tglfs_t *fs = NULL;\n\tglfs_fd_t *gfd = NULL;\n\tgluster_server *hosts = NULL; \n\tbool result = true;\n\tpath = strchr(cfgstring, '/');\n\tif (!path) {\n\t\tif (asprintf(reason, \"No path found\") == -1)\n\t\t\t*reason = NULL;\n\t\tresult = false;\n\t\tgoto done;\n\t}\n\tpath += 1; \n\tfs = tcmu_create_glfs_object(path, &hosts);\n\tif (!fs) {\n\t\ttcmu_err(\"tcmu_create_glfs_object failed\\n\");\n\t\tgoto done;\n\t}\n\tgfd = glfs_open(fs, hosts->path, ALLOWED_BSOFLAGS);\n\tif (!gfd) {\n\t\tif (asprintf(reason, \"glfs_open failed: %m\") == -1)\n\t\t\t*reason = NULL;\n\t\tresult = false;\n\t\tgoto unref;\n\t}\n\tif (glfs_access(fs, hosts->path, R_OK|W_OK) == -1) {\n\t\tif (asprintf(reason, \"glfs_access file not present, or not writable\") == -1)\n\t\t\t*reason = NULL;\n\t\tresult = false;\n\t\tgoto unref;\n\t}\n\tgoto done;\nunref:\n\tgluster_cache_refresh(fs, path);\ndone:\n\tif (gfd)\n\t\tglfs_close(gfd);\n\tgluster_free_server(&hosts);\n\treturn result;\n}", "target": 1}
{"code": "cib_connect(gboolean full)\n{\n    int rc = pcmk_ok;\n    static gboolean need_pass = TRUE;\n    CRM_CHECK(cib != NULL, return -EINVAL);\n    if (getenv(\"CIB_passwd\") != NULL) {\n        need_pass = FALSE;\n    }\n    if(watch_fencing && st == NULL) {\n        st = stonith_api_new();\n    }\n    if(watch_fencing && st->state == stonith_disconnected) {\n        crm_trace(\"Connecting to stonith\");\n        rc = st->cmds->connect(st, crm_system_name, NULL);\n        if(rc == pcmk_ok) {\n            crm_trace(\"Setting up stonith callbacks\");\n            st->cmds->register_notification(st, T_STONITH_NOTIFY_FENCE, mon_st_callback);\n        }\n    }\n    if (cib->state != cib_connected_query && cib->state != cib_connected_command) {\n        crm_trace(\"Connecting to the CIB\");\n        if (as_console && need_pass && cib->variant == cib_remote) {\n            need_pass = FALSE;\n            print_as(\"Password:\");\n        }\n        rc = cib->cmds->signon(cib, crm_system_name, cib_query);\n        if (rc != pcmk_ok) {\n            return rc;\n        }\n        current_cib = get_cib_copy(cib);\n        mon_refresh_display(NULL);\n        if (full) {\n            if (rc == pcmk_ok) {\n                rc = cib->cmds->set_connection_dnotify(cib, mon_cib_connection_destroy);\n                if (rc == -EPROTONOSUPPORT) {\n                    print_as(\"Notification setup failed, won't be able to reconnect after failure\");\n                    if (as_console) {\n                        sleep(2);\n                    }\n                    rc = pcmk_ok;\n                }\n            }\n            if (rc == pcmk_ok) {\n                cib->cmds->del_notify_callback(cib, T_CIB_DIFF_NOTIFY, crm_diff_update);\n                rc = cib->cmds->add_notify_callback(cib, T_CIB_DIFF_NOTIFY, crm_diff_update);\n            }\n            if (rc != pcmk_ok) {\n                print_as(\"Notification setup failed, could not monitor CIB actions\");\n                if (as_console) {\n                    sleep(2);\n                }\n                clean_up(-rc);\n            }\n        }\n    }\n    return rc;\n}", "target": 1}
{"code": "static bool fib6_rule_suppress(struct fib_rule *rule, struct fib_lookup_arg *arg)\n{\n\tstruct fib6_result *res = arg->result;\n\tstruct rt6_info *rt = res->rt6;\n\tstruct net_device *dev = NULL;\n\tif (!rt)\n\t\treturn false;\n\tif (rt->rt6i_idev)\n\t\tdev = rt->rt6i_idev->dev;\n\tif (rt->rt6i_dst.plen <= rule->suppress_prefixlen)\n\t\tgoto suppress_route;\n\tif (rule->suppress_ifgroup != -1 && dev && dev->group == rule->suppress_ifgroup)\n\t\tgoto suppress_route;\n\treturn false;\nsuppress_route:\n\tip6_rt_put(rt);\n\treturn true;\n}", "target": 1}
{"code": "static int ax25_getname(struct socket *sock, struct sockaddr *uaddr,\n\tint *uaddr_len, int peer)\n{\n\tstruct full_sockaddr_ax25 *fsa = (struct full_sockaddr_ax25 *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tunsigned char ndigi, i;\n\tax25_cb *ax25;\n\tint err = 0;\n\tmemset(fsa, 0, sizeof(*fsa));\n\tlock_sock(sk);\n\tax25 = ax25_sk(sk);\n\tif (peer != 0) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tgoto out;\n\t\t}\n\t\tfsa->fsa_ax25.sax25_family = AF_AX25;\n\t\tfsa->fsa_ax25.sax25_call   = ax25->dest_addr;\n\t\tif (ax25->digipeat != NULL) {\n\t\t\tndigi = ax25->digipeat->ndigi;\n\t\t\tfsa->fsa_ax25.sax25_ndigis = ndigi;\n\t\t\tfor (i = 0; i < ndigi; i++)\n\t\t\t\tfsa->fsa_digipeater[i] =\n\t\t\t\t\t\tax25->digipeat->calls[i];\n\t\t}\n\t} else {\n\t\tfsa->fsa_ax25.sax25_family = AF_AX25;\n\t\tfsa->fsa_ax25.sax25_call   = ax25->source_addr;\n\t\tfsa->fsa_ax25.sax25_ndigis = 1;\n\t\tif (ax25->ax25_dev != NULL) {\n\t\t\tmemcpy(&fsa->fsa_digipeater[0],\n\t\t\t       ax25->ax25_dev->dev->dev_addr, AX25_ADDR_LEN);\n\t\t} else {\n\t\t\tfsa->fsa_digipeater[0] = null_ax25_address;\n\t\t}\n\t}\n\t*uaddr_len = sizeof (struct full_sockaddr_ax25);\nout:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "\tSilenceMessage(const std::string& mask, const std::string& flags)\n\t\t: ClientProtocol::Message(\"SILENCE\")\n\t{\n\t\tPushParam(mask);\n\t\tPushParam(flags);\n\t}", "target": 0}
{"code": "bool Unpack::ProcessDecoded(UnpackThreadData &D)\n{\n  UnpackDecodedItem *Item=D.Decoded,*Border=D.Decoded+D.DecodedSize;\n  while (Item<Border)\n  {\n    UnpPtr&=MaxWinMask;\n    if (((WriteBorder-UnpPtr) & MaxWinMask)<MAX_LZ_MATCH+3 && WriteBorder!=UnpPtr)\n    {\n      UnpWriteBuf();\n      if (WrittenFileSize>DestUnpSize)\n        return false;\n    }\n    if (Item->Type==UNPDT_LITERAL)\n    {\n#if defined(LITTLE_ENDIAN) && defined(ALLOW_MISALIGNED)\n      if (Item->Length==3 && UnpPtr<MaxWinSize-4)\n      {\n        *(uint32 *)(Window+UnpPtr)=*(uint32 *)Item->Literal;\n        UnpPtr+=4;\n      }\n      else\n#endif\n        for (uint I=0;I<=Item->Length;I++)\n          Window[UnpPtr++ & MaxWinMask]=Item->Literal[I];\n    }\n    else\n      if (Item->Type==UNPDT_MATCH)\n      {\n        InsertOldDist(Item->Distance);\n        LastLength=Item->Length;\n        CopyString(Item->Length,Item->Distance);\n      }\n      else\n        if (Item->Type==UNPDT_REP)\n        {\n          uint Distance=OldDist[Item->Distance];\n          for (uint I=Item->Distance;I>0;I--)\n            OldDist[I]=OldDist[I-1];\n          OldDist[0]=Distance;\n          LastLength=Item->Length;\n          CopyString(Item->Length,Distance);\n        }\n        else\n          if (Item->Type==UNPDT_FULLREP)\n          {\n            if (LastLength!=0)\n              CopyString(LastLength,OldDist[0]);\n          }\n          else\n            if (Item->Type==UNPDT_FILTER)\n            {\n              UnpackFilter Filter;\n              Filter.Type=(byte)Item->Length;\n              Filter.BlockStart=Item->Distance;\n              Item++;\n              Filter.Channels=(byte)Item->Length;\n              Filter.BlockLength=Item->Distance;\n              AddFilter(Filter);\n            }\n    Item++;\n  }\n  return true;\n}", "target": 1}
{"code": "static int sock_close(struct inode *inode, struct file *filp)\n{\n\tsock_release(SOCKET_I(inode));\n\treturn 0;\n}", "target": 1}
{"code": "static int off_nominal_sync_run(struct ast_test *test, const char *domain, int rr_type,\n\t\tint rr_class, int expected_rcode)\n{\n\tstruct ast_dns_result *result;\n\tint res = 0;\n\tif (ast_dns_resolve(domain, rr_type, rr_class, &result)) {\n\t\tast_test_status_update(test, \"Failed to perform resolution :(\\n\");\n\t\treturn -1;\n\t}\n\tif (!result) {\n\t\tast_test_status_update(test, \"Resolution returned no result\\n\");\n\t\treturn -1;\n\t}\n\tif (ast_dns_result_get_rcode(result) != expected_rcode) {\n\t\tast_test_status_update(test, \"Unexpected rcode from DNS resolution\\n\");\n\t\tres = -1;\n\t}\n\tif (ast_dns_result_get_records(result)) {\n\t\tast_test_status_update(test, \"DNS resolution returned records unexpectedly\\n\");\n\t\tres = -1;\n\t}\n\tast_dns_result_free(result);\n\treturn res;\n}", "target": 1}
{"code": "minimask_equal(const struct minimask *a, const struct minimask *b)\n{\n    return !memcmp(a, b, sizeof *a\n                   + MINIFLOW_VALUES_SIZE(miniflow_n_values(&a->masks)));\n}", "target": 1}
{"code": "void HTTPSession::onCertificate(uint16_t certId,\n                                std::unique_ptr<IOBuf> authenticator) {\n  DestructorGuard dg(this);\n  VLOG(4) << \"CERTIFICATE on\" << *this << \", certId=\" << certId;\n  if (!secondAuthManager_) {\n    return;\n  }\n  bool isValid = false;\n  auto fizzBase = getTransport()->getUnderlyingTransport<AsyncFizzBase>();\n  if (fizzBase) {\n    if (isUpstream()) {\n      isValid = secondAuthManager_->validateAuthenticator(\n          *fizzBase,\n          TransportDirection::UPSTREAM,\n          certId,\n          std::move(authenticator));\n    } else {\n      isValid = secondAuthManager_->validateAuthenticator(\n          *fizzBase,\n          TransportDirection::DOWNSTREAM,\n          certId,\n          std::move(authenticator));\n    }\n  } else {\n    VLOG(4) << \"Underlying transport does not support secondary \"\n               \"authentication.\";\n    return;\n  }\n  if (isValid) {\n    VLOG(4) << \"Successfully validated the authenticator provided by the peer.\";\n  } else {\n    VLOG(4) << \"Failed to validate the authenticator provided by the peer\";\n  }\n}", "target": 0}
{"code": "static long btrfs_ioctl_qgroup_assign(struct file *file, void __user *arg)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_ioctl_qgroup_assign_args *sa;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\tint err;\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\tsa = memdup_user(arg, sizeof(*sa));\n\tif (IS_ERR(sa)) {\n\t\tret = PTR_ERR(sa);\n\t\tgoto drop_write;\n\t}\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\tif (sa->assign) {\n\t\tret = btrfs_add_qgroup_relation(trans, sa->src, sa->dst);\n\t} else {\n\t\tret = btrfs_del_qgroup_relation(trans, sa->src, sa->dst);\n\t}\n\tmutex_lock(&fs_info->qgroup_ioctl_lock);\n\terr = btrfs_run_qgroups(trans);\n\tmutex_unlock(&fs_info->qgroup_ioctl_lock);\n\tif (err < 0)\n\t\tbtrfs_handle_fs_error(fs_info, err,\n\t\t\t\t      \"failed to update qgroup status and info\");\n\terr = btrfs_end_transaction(trans);\n\tif (err && !ret)\n\t\tret = err;\nout:\n\tkfree(sa);\ndrop_write:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}", "target": 0}
{"code": "void __kvm_migrate_pit_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pit *pit = vcpu->kvm->arch.vpit;\n\tstruct hrtimer *timer;\n\tif (!kvm_vcpu_is_bsp(vcpu) || !pit)\n\t\treturn;\n\ttimer = &pit->pit_state.timer;\n\tmutex_lock(&pit->pit_state.lock);\n\tif (hrtimer_cancel(timer))\n\t\thrtimer_start_expires(timer, HRTIMER_MODE_ABS);\n\tmutex_unlock(&pit->pit_state.lock);\n}", "target": 0}
{"code": "static inline int handle_dots(struct nameidata *nd, int type)\n{\n\tif (type == LAST_DOTDOT) {\n\t\tif (nd->flags & LOOKUP_RCU) {\n\t\t\treturn follow_dotdot_rcu(nd);\n\t\t} else\n\t\t\tfollow_dotdot(nd);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "IntegrationStreamDecoderPtr HttpIntegrationTest::sendRequestAndWaitForResponse(\n    const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,\n    const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index) {\n  ASSERT(codec_client_ != nullptr);\n  IntegrationStreamDecoderPtr response;\n  if (request_body_size) {\n    response = codec_client_->makeRequestWithBody(request_headers, request_body_size);\n  } else {\n    response = codec_client_->makeHeaderOnlyRequest(request_headers);\n  }\n  waitForNextUpstreamRequest(upstream_index);\n  upstream_request_->encodeHeaders(response_headers, response_size == 0);\n  if (response_size) {\n    upstream_request_->encodeData(response_size, true);\n  }\n  response->waitForEndStream();\n  return response;\n}", "target": 1}
{"code": "int SSL_select_next_proto(unsigned char **out, unsigned char *outlen,\n                          const unsigned char *server,\n                          unsigned int server_len,\n                          const unsigned char *client, unsigned int client_len)\n{\n    unsigned int i, j;\n    const unsigned char *result;\n    int status = OPENSSL_NPN_UNSUPPORTED;\n    for (i = 0; i < server_len;) {\n        for (j = 0; j < client_len;) {\n            if (server[i] == client[j] &&\n                memcmp(&server[i + 1], &client[j + 1], server[i]) == 0) {\n                result = &server[i];\n                status = OPENSSL_NPN_NEGOTIATED;\n                goto found;\n            }\n            j += client[j];\n            j++;\n        }\n        i += server[i];\n        i++;\n    }\n    result = client;\n    status = OPENSSL_NPN_NO_OVERLAP;\n found:\n    *out = (unsigned char *)result + 1;\n    *outlen = result[0];\n    return status;\n}", "target": 1}
{"code": "xfs_ilock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\ttrace_xfs_ilock(ip, lock_flags, _RET_IP_);\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_MMAPLOCK_SHARED | XFS_MMAPLOCK_EXCL)) !=\n\t       (XFS_MMAPLOCK_SHARED | XFS_MMAPLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_SUBCLASS_MASK)) == 0);\n\tif (lock_flags & XFS_IOLOCK_EXCL) {\n\t\tdown_write_nested(&VFS_I(ip)->i_rwsem,\n\t\t\t\t  XFS_IOLOCK_DEP(lock_flags));\n\t} else if (lock_flags & XFS_IOLOCK_SHARED) {\n\t\tdown_read_nested(&VFS_I(ip)->i_rwsem,\n\t\t\t\t XFS_IOLOCK_DEP(lock_flags));\n\t}\n\tif (lock_flags & XFS_MMAPLOCK_EXCL)\n\t\tmrupdate_nested(&ip->i_mmaplock, XFS_MMAPLOCK_DEP(lock_flags));\n\telse if (lock_flags & XFS_MMAPLOCK_SHARED)\n\t\tmraccess_nested(&ip->i_mmaplock, XFS_MMAPLOCK_DEP(lock_flags));\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrupdate_nested(&ip->i_lock, XFS_ILOCK_DEP(lock_flags));\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmraccess_nested(&ip->i_lock, XFS_ILOCK_DEP(lock_flags));\n}", "target": 0}
{"code": "static int netbk_count_requests(struct xenvif *vif,\n\t\t\t\tstruct xen_netif_tx_request *first,\n\t\t\t\tstruct xen_netif_tx_request *txp,\n\t\t\t\tint work_to_do)\n{\n\tRING_IDX cons = vif->tx.req_cons;\n\tint frags = 0;\n\tif (!(first->flags & XEN_NETTXF_more_data))\n\t\treturn 0;\n\tdo {\n\t\tif (frags >= work_to_do) {\n\t\t\tnetdev_dbg(vif->dev, \"Need more frags\\n\");\n\t\t\treturn -frags;\n\t\t}\n\t\tif (unlikely(frags >= MAX_SKB_FRAGS)) {\n\t\t\tnetdev_dbg(vif->dev, \"Too many frags\\n\");\n\t\t\treturn -frags;\n\t\t}\n\t\tmemcpy(txp, RING_GET_REQUEST(&vif->tx, cons + frags),\n\t\t       sizeof(*txp));\n\t\tif (txp->size > first->size) {\n\t\t\tnetdev_dbg(vif->dev, \"Frags galore\\n\");\n\t\t\treturn -frags;\n\t\t}\n\t\tfirst->size -= txp->size;\n\t\tfrags++;\n\t\tif (unlikely((txp->offset + txp->size) > PAGE_SIZE)) {\n\t\t\tnetdev_dbg(vif->dev, \"txp->offset: %x, size: %u\\n\",\n\t\t\t\t txp->offset, txp->size);\n\t\t\treturn -frags;\n\t\t}\n\t} while ((txp++)->flags & XEN_NETTXF_more_data);\n\treturn frags;\n}", "target": 1}
{"code": "ngx_gmtime(time_t t, ngx_tm_t *tp)\n{\n    ngx_int_t   yday;\n    ngx_uint_t  sec, min, hour, mday, mon, year, wday, days, leap;\n    if (t < 0) {\n        t = 0;\n    }\n    days = t / 86400;\n    sec = t % 86400;\n    if (days > 2932896) {\n        days = 2932896;\n        sec = 86399;\n    }\n    wday = (4 + days) % 7;\n    hour = sec / 3600;\n    sec %= 3600;\n    min = sec / 60;\n    sec %= 60;\n    days = days - (31 + 28) + 719527;\n    year = (days + 2) * 400 / (365 * 400 + 100 - 4 + 1);\n    yday = days - (365 * year + year / 4 - year / 100 + year / 400);\n    if (yday < 0) {\n        leap = (year % 4 == 0) && (year % 100 || (year % 400 == 0));\n        yday = 365 + leap + yday;\n        year--;\n    }\n    mon = (yday + 31) * 10 / 306;\n    mday = yday - (367 * mon / 12 - 30) + 1;\n    if (yday >= 306) {\n        year++;\n        mon -= 10;\n    } else {\n        mon += 2;\n    }\n    tp->ngx_tm_sec = (ngx_tm_sec_t) sec;\n    tp->ngx_tm_min = (ngx_tm_min_t) min;\n    tp->ngx_tm_hour = (ngx_tm_hour_t) hour;\n    tp->ngx_tm_mday = (ngx_tm_mday_t) mday;\n    tp->ngx_tm_mon = (ngx_tm_mon_t) mon;\n    tp->ngx_tm_year = (ngx_tm_year_t) year;\n    tp->ngx_tm_wday = (ngx_tm_wday_t) wday;\n}", "target": 0}
{"code": "void nf_tables_activate_set(const struct nft_ctx *ctx, struct nft_set *set)\n{\n\tif (nft_set_is_anonymous(set))\n\t\tnft_clear(ctx->net, set);\n\tset->use++;\n}", "target": 0}
{"code": "init_ctx_reselect(OM_uint32 *minor_status, spnego_gss_ctx_id_t sc,\n\t\t  OM_uint32 acc_negState, gss_OID supportedMech,\n\t\t  gss_buffer_t *responseToken, gss_buffer_t *mechListMIC,\n\t\t  OM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 tmpmin;\n\tsize_t i;\n\tgeneric_gss_release_oid(&tmpmin, &sc->internal_mech);\n\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n\t\t\t       GSS_C_NO_BUFFER);\n\tfor (i = 0; i < sc->mech_set->count; i++) {\n\t\tif (g_OID_equal(supportedMech, &sc->mech_set->elements[i]))\n\t\t\tbreak;\n\t}\n\tif (i == sc->mech_set->count)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tsc->internal_mech = &sc->mech_set->elements[i];\n\tif (acc_negState != REQUEST_MIC)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tsc->mech_complete = 0;\n\tsc->mic_reqd = 1;\n\t*negState = REQUEST_MIC;\n\t*tokflag = CONT_TOKEN_SEND;\n\treturn GSS_S_CONTINUE_NEEDED;\n}", "target": 1}
{"code": "inline bool canReadNElements(\n    Protocol_& prot,\n    uint32_t n,\n    std::initializer_list<\n        typename detail::ProtocolReaderWireTypeInfo<Protocol_>::WireType>\n        types) {\n  return prot.getCursor().canAdvance(n * types.size());\n}", "target": 0}
{"code": "BOOL freerdp_bitmap_planar_context_reset(BITMAP_PLANAR_CONTEXT* context, UINT32 width,\n                                         UINT32 height)\n{\n\tif (!context)\n\t\treturn FALSE;\n\tcontext->bgr = FALSE;\n\tcontext->maxWidth = PLANAR_ALIGN(width, 4);\n\tcontext->maxHeight = PLANAR_ALIGN(height, 4);\n\tcontext->maxPlaneSize = context->maxWidth * context->maxHeight;\n\tcontext->nTempStep = context->maxWidth * 4;\n\tvoid* tmp = winpr_aligned_recalloc(context->planesBuffer, context->maxPlaneSize, 4, 32);\n\tif (!tmp)\n\t\treturn FALSE;\n\tcontext->planesBuffer = tmp;\n\ttmp = winpr_aligned_recalloc(context->pTempData, context->maxPlaneSize, 6, 32);\n\tif (!tmp)\n\t\treturn FALSE;\n\tcontext->pTempData = tmp;\n\ttmp = winpr_aligned_recalloc(context->deltaPlanesBuffer, context->maxPlaneSize, 4, 32);\n\tif (!tmp)\n\t\treturn FALSE;\n\tcontext->deltaPlanesBuffer = tmp;\n\ttmp = winpr_aligned_recalloc(context->rlePlanesBuffer, context->maxPlaneSize, 4, 32);\n\tif (!tmp)\n\t\treturn FALSE;\n\tcontext->rlePlanesBuffer = tmp;\n\tcontext->planes[0] = &context->planesBuffer[context->maxPlaneSize * 0];\n\tcontext->planes[1] = &context->planesBuffer[context->maxPlaneSize * 1];\n\tcontext->planes[2] = &context->planesBuffer[context->maxPlaneSize * 2];\n\tcontext->planes[3] = &context->planesBuffer[context->maxPlaneSize * 3];\n\tcontext->deltaPlanes[0] = &context->deltaPlanesBuffer[context->maxPlaneSize * 0];\n\tcontext->deltaPlanes[1] = &context->deltaPlanesBuffer[context->maxPlaneSize * 1];\n\tcontext->deltaPlanes[2] = &context->deltaPlanesBuffer[context->maxPlaneSize * 2];\n\tcontext->deltaPlanes[3] = &context->deltaPlanesBuffer[context->maxPlaneSize * 3];\n\treturn TRUE;\n}", "target": 1}
{"code": "static int __socket_slurp (RSocket *s, ut8 *buf, int bufsz) {\n\tint i;\n\tint chsz = 1;\n\tif (r_socket_read_block (s, (ut8 *) buf, 1) != 1) {\n\t\treturn 0;\n\t}\n\tfor (i = 1; i < bufsz; i += chsz) {\n\t\tbuf[i] =0;\n\t\tr_socket_block_time (s, 1, 0, 1000);\n\t\tint olen = r_socket_read_block (s, (ut8 *) buf + i , chsz);\n\t\tif (olen != chsz) {\n\t\t\tbuf[i] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn i;\n}", "target": 1}
{"code": "B44Compressor::B44Compressor\n    (const Header &hdr,\n     size_t maxScanLineSize,\n     size_t numScanLines,\n     bool optFlatFields)\n:\n    Compressor (hdr),\n    _maxScanLineSize (maxScanLineSize),\n    _optFlatFields (optFlatFields),\n    _format (XDR),\n    _numScanLines (numScanLines),\n    _tmpBuffer (0),\n    _outBuffer (0),\n    _numChans (0),\n    _channels (hdr.channels()),\n    _channelData (0)\n{\n    (void)_maxScanLineSize;\n    _tmpBuffer = new unsigned short\n        [checkArraySize (uiMult (maxScanLineSize, numScanLines),\n                         sizeof (unsigned short))];\n    const ChannelList &channels = header().channels();\n    int numHalfChans = 0;\n    for (ChannelList::ConstIterator c = channels.begin();\n\t c != channels.end();\n\t ++c)\n    {\n\tassert (pixelTypeSize (c.channel().type) % pixelTypeSize (HALF) == 0);\n\t++_numChans;\n\tif (c.channel().type == HALF)\n\t    ++numHalfChans;\n    }\n    size_t padding = 12 * numHalfChans * (numScanLines + 3) / 4;\n    _outBuffer = new char\n        [uiAdd (uiMult (maxScanLineSize, numScanLines), padding)];\n    _channelData = new ChannelData[_numChans];\n    int i = 0;\n    for (ChannelList::ConstIterator c = channels.begin();\n\t c != channels.end();\n\t ++c, ++i)\n    {\n\t_channelData[i].ys = c.channel().ySampling;\n\t_channelData[i].type = c.channel().type;\n\t_channelData[i].pLinear = c.channel().pLinear;\n\t_channelData[i].size =\n\t    pixelTypeSize (c.channel().type) / pixelTypeSize (HALF);\n    }\n    const Box2i &dataWindow = hdr.dataWindow();\n    _minX = dataWindow.min.x;\n    _maxX = dataWindow.max.x;\n    _maxY = dataWindow.max.y;\n    assert (sizeof (unsigned short) == pixelTypeSize (HALF));\n    if (_numChans == numHalfChans)\n\t_format = NATIVE;\n}", "target": 1}
{"code": "static void get_request(GDHCPClient *dhcp_client, struct dhcp_packet *packet,\n\t\tuint16_t packet_len)\n{\n\tGDHCPOptionType type;\n\tGList *list, *value_list;\n\tchar *option_value;\n\tuint8_t *option;\n\tuint8_t code;\n\tfor (list = dhcp_client->request_list; list; list = list->next) {\n\t\tcode = (uint8_t) GPOINTER_TO_INT(list->data);\n\t\toption = dhcp_get_option(packet, packet_len, code);\n\t\tif (!option) {\n\t\t\tg_hash_table_remove(dhcp_client->code_value_hash,\n\t\t\t\t\t\tGINT_TO_POINTER((int) code));\n\t\t\tcontinue;\n\t\t}\n\t\ttype =  dhcp_get_code_type(code);\n\t\toption_value = malloc_option_value_string(option, type);\n\t\tif (!option_value)\n\t\t\tg_hash_table_remove(dhcp_client->code_value_hash,\n\t\t\t\t\t\tGINT_TO_POINTER((int) code));\n\t\tvalue_list = get_option_value_list(option_value, type);\n\t\tg_free(option_value);\n\t\tif (!value_list)\n\t\t\tg_hash_table_remove(dhcp_client->code_value_hash,\n\t\t\t\t\t\tGINT_TO_POINTER((int) code));\n\t\telse\n\t\t\tg_hash_table_insert(dhcp_client->code_value_hash,\n\t\t\t\tGINT_TO_POINTER((int) code), value_list);\n\t}\n}", "target": 0}
{"code": "static void kvm_steal_time_set_preempted(struct kvm_vcpu *vcpu)\n{\n\tstruct gfn_to_hva_cache *ghc = &vcpu->arch.st.cache;\n\tstruct kvm_steal_time __user *st;\n\tstruct kvm_memslots *slots;\n\tstatic const u8 preempted = KVM_VCPU_PREEMPTED;\n\tif (!vcpu->arch.at_instruction_boundary) {\n\t\tvcpu->stat.preemption_other++;\n\t\treturn;\n\t}\n\tvcpu->stat.preemption_reported++;\n\tif (!(vcpu->arch.st.msr_val & KVM_MSR_ENABLED))\n\t\treturn;\n\tif (vcpu->arch.st.preempted)\n\t\treturn;\n\tif (unlikely(current->mm != vcpu->kvm->mm))\n\t\treturn;\n\tslots = kvm_memslots(vcpu->kvm);\n\tif (unlikely(slots->generation != ghc->generation ||\n\t\t     kvm_is_error_hva(ghc->hva) || !ghc->memslot))\n\t\treturn;\n\tst = (struct kvm_steal_time __user *)ghc->hva;\n\tBUILD_BUG_ON(sizeof(st->preempted) != sizeof(preempted));\n\tif (!copy_to_user_nofault(&st->preempted, &preempted, sizeof(preempted)))\n\t\tvcpu->arch.st.preempted = KVM_VCPU_PREEMPTED;\n\tmark_page_dirty_in_slot(vcpu->kvm, ghc->memslot, gpa_to_gfn(ghc->gpa));\n}", "target": 0}
{"code": "htc_request_check_host_hdr(struct http *hp)\n{\n\tint u;\n\tint seen_host = 0;\n\tfor (u = HTTP_HDR_FIRST; u < hp->nhd; u++) {\n\t\tif (hp->hd[u].b == NULL)\n\t\t\tcontinue;\n\t\tAN(hp->hd[u].b);\n\t\tAN(hp->hd[u].e);\n\t\tif (http_IsHdr(&hp->hd[u], H_Host)) {\n\t\t\tif (seen_host) {\n\t\t\t\treturn (400);\n\t\t\t}\n\t\t\tseen_host = 1;\n\t\t}\n\t}\n\treturn (0);\n}", "target": 1}
{"code": "static inline void context_set_translation_type(struct context_entry *context,\n\t\t\t\t\t\tunsigned long value)\n{\n\tcontext->lo &= (((u64)-1) << 4) | 3;\n\tcontext->lo |= (value & 3) << 2;\n}", "target": 0}
{"code": "jp2_box_t *jp2_box_create0()\n{\n\tjp2_box_t *box;\n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n\t\treturn 0;\n\t}\n\tmemset(box, 0, sizeof(jp2_box_t));\n\tbox->type = 0;\n\tbox->len = 0;\n\tbox->ops = &jp2_boxinfo_unk.ops;\n\treturn box;\n}", "target": 0}
{"code": "catch_handler_set(codegen_scope *s, int ent, enum mrb_catch_type type, uint32_t begin, uint32_t end, uint32_t target)\n{\n  struct mrb_irep_catch_handler *e;\n  mrb_assert(ent >= 0 && ent < s->irep->clen);\n  e = &s->catch_table[ent];\n  uint8_to_bin(type, &e->type);\n  mrb_irep_catch_handler_pack(begin, e->begin);\n  mrb_irep_catch_handler_pack(end, e->end);\n  mrb_irep_catch_handler_pack(target, e->target);\n}", "target": 0}
{"code": "bool allow_svhandler_flash_range(size_t start, size_t end) {\n  if (start > end) return false;\n  if (start < FLASH_ORIGIN || end > FLASH_END) return false;\n  bool startAllowed = false;\n  bool endAllowed = false;\n  for (const FlashSector* s = flash_sector_map; s->use != FLASH_INVALID; s++) {\n    if (allow_svhandler_flash_sector(s)) {\n      if (!startAllowed &&\n          start + 1 > start &&\n          do_memory_ranges_overlap(start, start + 1, s->start, s->start + s->len)) {\n        startAllowed = true;\n      }\n      if (!endAllowed &&\n          end - 1 < end &&\n          do_memory_ranges_overlap(end - 1, end, s->start, s->start + s->len)) {\n        endAllowed = true;\n      }\n    } else {\n      if (do_memory_ranges_overlap(start, end, s->start, s->start + s->len)) return false;\n    }\n  }\n  if (!startAllowed || !endAllowed) return false;\n  return true;\n}", "target": 0}
{"code": "bool __net_get_random_once(void *buf, int nbytes, bool *done,\n\t\t\t   struct static_key *done_key)\n{\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long flags;\n\tspin_lock_irqsave(&lock, flags);\n\tif (*done) {\n\t\tspin_unlock_irqrestore(&lock, flags);\n\t\treturn false;\n\t}\n\tget_random_bytes(buf, nbytes);\n\t*done = true;\n\tspin_unlock_irqrestore(&lock, flags);\n\t__net_random_once_disable_jump(done_key);\n\treturn true;\n}", "target": 1}
{"code": "rfbHandleAuthResult(rfbClient* client)\n{\n    uint32_t authResult=0, reasonLen=0;\n    char *reason=NULL;\n    if (!ReadFromRFBServer(client, (char *)&authResult, 4)) return FALSE;\n    authResult = rfbClientSwap32IfLE(authResult);\n    switch (authResult) {\n    case rfbVncAuthOK:\n      rfbClientLog(\"VNC authentication succeeded\\n\");\n      return TRUE;\n      break;\n    case rfbVncAuthFailed:\n      if (client->major==3 && client->minor>7)\n      {\n        if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return FALSE;\n        reasonLen = rfbClientSwap32IfLE(reasonLen);\n        reason = malloc((uint64_t)reasonLen+1);\n        if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return FALSE; }\n        reason[reasonLen]=0;\n        rfbClientLog(\"VNC connection failed: %s\\n\",reason);\n        free(reason);\n        return FALSE;\n      }\n      rfbClientLog(\"VNC authentication failed\\n\");\n      return FALSE;\n    case rfbVncAuthTooMany:\n      rfbClientLog(\"VNC authentication failed - too many tries\\n\");\n      return FALSE;\n    }\n    rfbClientLog(\"Unknown VNC authentication result: %d\\n\",\n                 (int)authResult);\n    return FALSE;\n}", "target": 1}
{"code": "static void flush_tmregs_to_thread(struct task_struct *tsk)\n{\n\tif (tsk != current)\n\t\treturn;\n\tif (MSR_TM_SUSPENDED(mfmsr())) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t} else {\n\t\ttm_enable();\n\t\ttm_save_sprs(&(tsk->thread));\n\t}\n}", "target": 1}
{"code": "static void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)\n{\n\tconst struct sched_class *class;\n\tif (p->sched_class == rq->curr->sched_class) {\n\t\trq->curr->sched_class->check_preempt_curr(rq, p, flags);\n\t} else {\n\t\tfor_each_class(class) {\n\t\t\tif (class == rq->curr->sched_class)\n\t\t\t\tbreak;\n\t\t\tif (class == p->sched_class) {\n\t\t\t\tresched_task(rq->curr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (test_tsk_need_resched(rq->curr))\n\t\trq->skip_clock_update = 1;\n}", "target": 1}
{"code": "int ar6000_create_ap_interface(struct ar6_softc *ar, char *ap_ifname)\n{\n    struct net_device *dev;\n    struct ar_virtual_interface *arApDev;\n    dev = alloc_etherdev(sizeof(struct ar_virtual_interface));\n    if (dev == NULL) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"ar6000_create_ap_interface: can't alloc etherdev\\n\"));\n        return A_ERROR;\n    } \n    ether_setup(dev);\n    init_netdev(dev, ap_ifname);\n    dev->priv_flags &= ~IFF_TX_SKB_SHARING;\n    if (register_netdev(dev)) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"ar6000_create_ap_interface: register_netdev failed\\n\"));\n        return A_ERROR;\n    }\n    arApDev = netdev_priv(dev);\n    arApDev->arDev = ar;\n    arApDev->arNetDev = dev;\n    arApDev->arStaNetDev = ar->arNetDev;\n    ar->arApDev = arApDev;\n    arApNetDev = dev;\n    memcpy(dev->dev_addr, ar->arNetDev->dev_addr, AR6000_ETH_ADDR_LEN);\n    return 0;\n}", "target": 0}
{"code": "static uint32_t buf_to_uint32(char *data) {\n    size_t i;\n    uint32_t result = 0;\n    for (i = 0; i < sizeof(uint32_t); i++)\n        result = (result << 8) | (unsigned char)data[i];\n    return result;\n}", "target": 0}
{"code": "SYSCALL_DEFINE1(timer_getoverrun, timer_t, timer_id)\n{\n\tstruct k_itimer *timr;\n\tint overrun;\n\tunsigned long flags;\n\ttimr = lock_timer(timer_id, &flags);\n\tif (!timr)\n\t\treturn -EINVAL;\n\toverrun = timr->it_overrun_last;\n\tunlock_timer(timr, flags);\n\treturn overrun;\n}", "target": 1}
{"code": "static int fit_image_verify_sig(const void *fit, int image_noffset,\n\t\t\t\tconst char *data, size_t size,\n\t\t\t\tconst void *sig_blob, int sig_offset)\n{\n\tint noffset;\n\tchar *err_msg = \"\";\n\tint verified = 0;\n\tint ret;\n\tfdt_for_each_subnode(noffset, fit, image_noffset) {\n\t\tconst char *name = fit_get_name(fit, noffset, NULL);\n\t\tif (strchr(name, '@')) {\n\t\t\terr_msg = \"Node name contains @\";\n\t\t\tgoto error;\n\t\t}\n\t\tif (!strncmp(name, FIT_SIG_NODENAME,\n\t\t\t     strlen(FIT_SIG_NODENAME))) {\n\t\t\tret = fit_image_check_sig(fit, noffset, data,\n\t\t\t\t\t\t  size, -1, &err_msg);\n\t\t\tif (ret) {\n\t\t\t\tputs(\"- \");\n\t\t\t} else {\n\t\t\t\tputs(\"+ \");\n\t\t\t\tverified = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (noffset == -FDT_ERR_TRUNCATED || noffset == -FDT_ERR_BADSTRUCTURE) {\n\t\terr_msg = \"Corrupted or truncated tree\";\n\t\tgoto error;\n\t}\n\treturn verified ? 0 : -EPERM;\nerror:\n\tprintf(\" error!\\n%s for '%s' hash node in '%s' image node\\n\",\n\t       err_msg, fit_get_name(fit, noffset, NULL),\n\t       fit_get_name(fit, image_noffset, NULL));\n\treturn -1;\n}", "target": 0}
{"code": "static int seed_from_windows_cryptoapi(uint32_t *seed)\n{\n    HINSTANCE hAdvAPI32 = NULL;\n    CRYPTACQUIRECONTEXTA pCryptAcquireContext = NULL;\n    CRYPTGENRANDOM pCryptGenRandom = NULL;\n    CRYPTRELEASECONTEXT pCryptReleaseContext = NULL;\n    HCRYPTPROV hCryptProv = 0;\n    BYTE data[sizeof(uint32_t)];\n    int ok;\n    hAdvAPI32 = GetModuleHandle(\"advapi32.dll\");\n    if(hAdvAPI32 == NULL)\n        return 1;\n    pCryptAcquireContext = (CRYPTACQUIRECONTEXTA)GetProcAddress(hAdvAPI32, \"CryptAcquireContextA\");\n    if (!pCryptAcquireContext)\n        return 1;\n    pCryptGenRandom = (CRYPTGENRANDOM)GetProcAddress(hAdvAPI32, \"CryptGenRandom\");\n    if (!pCryptGenRandom)\n        return 1;\n    pCryptReleaseContext = (CRYPTRELEASECONTEXT)GetProcAddress(hAdvAPI32, \"CryptReleaseContext\");\n    if (!pCryptReleaseContext)\n        return 1;\n    if (!pCryptAcquireContext(&hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))\n        return 1;\n    ok = CryptGenRandom(hCryptProv, sizeof(uint32_t), data);\n    pCryptReleaseContext(hCryptProv, 0);\n    if (!ok)\n        return 1;\n    *seed = buf_to_uint32((char *)data);\n    return 0;\n}", "target": 0}
{"code": "static int tcp_parse_options(struct pico_frame *f)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)f->sock;\n    uint8_t *opt = f->transport_hdr + PICO_SIZE_TCPHDR;\n    uint32_t i = 0;\n    f->timestamp = 0;\n    if (f->buffer + f->buffer_len > f->transport_hdr + f->transport_len)\n        return -1;\n    while (i < (f->transport_len - PICO_SIZE_TCPHDR)) {\n        uint8_t type =  opt[i++];\n        uint8_t len;\n        if(i < (f->transport_len - PICO_SIZE_TCPHDR) && (type > 1))\n            len =  opt[i++];\n        else\n            len = 1;\n        if (f->payload && ((opt + i) > f->payload))\n            break;\n        if (len == 0) {\n            return -1;\n        }\n        tcp_dbg_options(\"Received option '%d', len = %d \\n\", type, len);\n        switch (type) {\n        case PICO_TCP_OPTION_NOOP:\n        case PICO_TCP_OPTION_END:\n            break;\n        case PICO_TCP_OPTION_WS:\n            tcp_parse_option_ws(t, len, opt, &i);\n            break;\n        case PICO_TCP_OPTION_SACK_OK:\n            tcp_parse_option_sack_ok(t, f, len, &i);\n            break;\n        case PICO_TCP_OPTION_MSS:\n            tcp_parse_option_mss(t, len, opt, &i);\n            break;\n        case PICO_TCP_OPTION_TIMESTAMP:\n            tcp_parse_option_timestamp(t, f, len, opt, &i);\n            break;\n        case PICO_TCP_OPTION_SACK:\n            tcp_rcv_sack(t, opt + i, len - 2);\n            i = i + len - 2;\n            break;\n        default:\n            tcp_dbg_options(\"TCP: received unsupported option %u\\n\", type);\n            i = i + len - 2;\n        }\n    }\n    return 0;\n}", "target": 0}
{"code": "static u32 __ipv6_select_ident(struct net *net, u32 hashrnd,\n\t\t\t       const struct in6_addr *dst,\n\t\t\t       const struct in6_addr *src)\n{\n\tu32 hash, id;\n\thash = __ipv6_addr_jhash(dst, hashrnd);\n\thash = __ipv6_addr_jhash(src, hash);\n\thash ^= net_hash_mix(net);\n\tid = ip_idents_reserve(hash, 1);\n\tif (unlikely(!id))\n\t\tid = 1 << 31;\n\treturn id;\n}", "target": 1}
{"code": "static int amd_gpio_remove(struct platform_device *pdev)\n{\n\tstruct amd_gpio *gpio_dev;\n\tgpio_dev = platform_get_drvdata(pdev);\n\tgpiochip_remove(&gpio_dev->gc);\n\tpinctrl_unregister(gpio_dev->pctrl);\n\treturn 0;\n}", "target": 1}
{"code": "static int do_siocgstampns(struct net *net, struct socket *sock,\n\t\t\t   unsigned int cmd, void __user *up)\n{\n\tmm_segment_t old_fs = get_fs();\n\tstruct timespec kts;\n\tint err;\n\tset_fs(KERNEL_DS);\n\terr = sock_do_ioctl(net, sock, cmd, (unsigned long)&kts);\n\tset_fs(old_fs);\n\tif (!err)\n\t\terr = compat_put_timespec(up, &kts);\n\treturn err;\n}", "target": 1}
{"code": "SWFInput_readSBits(SWFInput input, int number)\n{\n\tint num = SWFInput_readBits(input, number);\n\tif ( num & (1<<(number-1)) )\n\t\treturn num - (1<<number);\n\telse\n\t\treturn num;\n}", "target": 1}
{"code": "addnode(struct env *env, const char *key, const char *value)\n{\n\tstruct envnode *node;\n\tnode = createnode(key, value);\n\tRB_INSERT(envtree, &env->root, node);\n\tenv->count++;\n}", "target": 0}
{"code": "static void sanitize_string(char *s, char *new) {\n\tsize_t i,j, l = strlen(s), ls=l;\n\tfor(i=0,j=0;i<ls;i++) {\n\t\tif(s[i] < ' ' || s[i] > 127) {\n\t\t\tsprintf(new + j, \"\\\\x%02x\", s[i] & 0xff);\n\t\t\tj  += 3;\n\t\t} else new[j] = s[i];\n\t\tj++;\n\t}\n\tnew[j] = 0;\n}", "target": 0}
{"code": "void nf_tables_unbind_set(const struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t  struct nft_set_binding *binding)\n{\n\tlist_del_rcu(&binding->list);\n\tif (list_empty(&set->bindings) && set->flags & NFT_SET_ANONYMOUS &&\n\t    !(set->flags & NFT_SET_INACTIVE))\n\t\tnf_tables_set_destroy(ctx, set);\n}", "target": 0}
{"code": "static ssize_t oz_cdev_write(struct file *filp, const char __user *buf,\n\t\tsize_t count, loff_t *fpos)\n{\n\tstruct oz_pd *pd;\n\tstruct oz_elt_buf *eb;\n\tstruct oz_elt_info *ei;\n\tstruct oz_elt *elt;\n\tstruct oz_app_hdr *app_hdr;\n\tstruct oz_serial_ctx *ctx;\n\tif (count > sizeof(ei->data) - sizeof(*elt) - sizeof(*app_hdr))\n\t\treturn -EINVAL;\n\tspin_lock_bh(&g_cdev.lock);\n\tpd = g_cdev.active_pd;\n\tif (pd)\n\t\toz_pd_get(pd);\n\tspin_unlock_bh(&g_cdev.lock);\n\tif (pd == NULL)\n\t\treturn -ENXIO;\n\tif (!(pd->state & OZ_PD_S_CONNECTED))\n\t\treturn -EAGAIN;\n\teb = &pd->elt_buff;\n\tei = oz_elt_info_alloc(eb);\n\tif (ei == NULL) {\n\t\tcount = 0;\n\t\tgoto out;\n\t}\n\telt = (struct oz_elt *)ei->data;\n\tapp_hdr = (struct oz_app_hdr *)(elt+1);\n\telt->length = sizeof(struct oz_app_hdr) + count;\n\telt->type = OZ_ELT_APP_DATA;\n\tei->app_id = OZ_APPID_SERIAL;\n\tei->length = elt->length + sizeof(struct oz_elt);\n\tapp_hdr->app_id = OZ_APPID_SERIAL;\n\tif (copy_from_user(app_hdr+1, buf, count))\n\t\tgoto out;\n\tspin_lock_bh(&pd->app_lock[OZ_APPID_USB-1]);\n\tctx = (struct oz_serial_ctx *)pd->app_ctx[OZ_APPID_SERIAL-1];\n\tif (ctx) {\n\t\tapp_hdr->elt_seq_num = ctx->tx_seq_num++;\n\t\tif (ctx->tx_seq_num == 0)\n\t\t\tctx->tx_seq_num = 1;\n\t\tspin_lock(&eb->lock);\n\t\tif (oz_queue_elt_info(eb, 0, 0, ei) == 0)\n\t\t\tei = NULL;\n\t\tspin_unlock(&eb->lock);\n\t}\n\tspin_unlock_bh(&pd->app_lock[OZ_APPID_USB-1]);\nout:\n\tif (ei) {\n\t\tcount = 0;\n\t\tspin_lock_bh(&eb->lock);\n\t\toz_elt_info_free(eb, ei);\n\t\tspin_unlock_bh(&eb->lock);\n\t}\n\toz_pd_put(pd);\n\treturn count;\n}", "target": 0}
{"code": "static void adapter_stop(struct btd_adapter *adapter)\n{\n\treply_pending_requests(adapter);\n\tcancel_passive_scanning(adapter);\n\tremove_discovery_list(adapter);\n\tdiscovery_cleanup(adapter, 0);\n\tadapter->filtered_discovery = false;\n\tadapter->no_scan_restart_delay = false;\n\tg_free(adapter->current_discovery_filter);\n\tadapter->current_discovery_filter = NULL;\n\tset_discovery_discoverable(adapter, false);\n\tadapter->discovering = false;\n\twhile (adapter->connections) {\n\t\tstruct btd_device *device = adapter->connections->data;\n\t\tuint8_t addr_type = btd_device_get_bdaddr_type(device);\n\t\tadapter_remove_connection(adapter, device, BDADDR_BREDR);\n\t\tif (addr_type != BDADDR_BREDR)\n\t\t\tadapter_remove_connection(adapter, device, addr_type);\n\t}\n\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Discovering\");\n\tif (adapter->dev_class) {\n\t\tadapter->dev_class = 0;\n\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\t\tADAPTER_INTERFACE, \"Class\");\n\t}\n\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\t\tADAPTER_INTERFACE, \"Powered\");\n\tDBG(\"adapter %s has been disabled\", adapter->path);\n}", "target": 0}
{"code": "PHPAPI int php_swoole_unserialize(void *buffer, size_t len, zval *return_value, zval *object_args, long flag)\n{\n    SBucketType type = *(SBucketType*) (buffer);\n    zend_uchar real_type = type.data_type;\n    buffer += sizeof (SBucketType);\n    switch (real_type)\n    {\n        case IS_NULL:\n        case IS_TRUE:\n        case IS_FALSE:\n            Z_TYPE_INFO_P(return_value) = real_type;\n            break;\n        case IS_LONG:\n            swoole_unserialize_long(buffer, return_value, type);\n            Z_TYPE_INFO_P(return_value) = real_type;\n            break;\n        case IS_DOUBLE:\n            swoole_unserialize_raw(buffer, return_value);\n            Z_TYPE_INFO_P(return_value) = real_type;\n            break;\n        case IS_STRING:\n            len -= sizeof (SBucketType);\n            zend_string *str = swoole_unserialize_string(buffer, len);\n            ZVAL_STR(return_value, str);\n            break;\n        case IS_ARRAY:\n        {\n            if (swoole_seria_check_eof(buffer, len) < 0)\n            {\n                  php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"detect the error eof\");\n                  return SW_FALSE;\n            }\n            unser_start = buffer - sizeof (SBucketType);\n            uint32_t num = 0;\n            buffer = get_array_real_len(buffer, type.data_len, &num);\n            if (!swoole_unserialize_arr(buffer, return_value, num, flag))\n            {\n                return SW_FALSE;\n            }\n            break;\n        }\n        case IS_UNDEF:\n            if (swoole_seria_check_eof(buffer, len) < 0)\n            {\n                  php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"detect the error eof\");\n                  return SW_FALSE;\n            }\n            unser_start = buffer - sizeof (SBucketType);\n            if (!swoole_unserialize_object(buffer, return_value, type.data_len, object_args, flag))\n            {\n                return SW_FALSE;\n            }\n            break;\n        default:\n            php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"the type is not supported by swoole serialize.\");\n            return SW_FALSE;\n    }\n    return SW_TRUE;\n}", "target": 1}
{"code": "int yr_object_array_set_item(\n    YR_OBJECT* object,\n    YR_OBJECT* item,\n    int index)\n{\n  YR_OBJECT_ARRAY* array;\n  int i;\n  int count;\n  assert(index >= 0);\n  assert(object->type == OBJECT_TYPE_ARRAY);\n  array = object_as_array(object);\n  if (array->items == NULL)\n  {\n    count = yr_max(64, (index + 1) * 2);\n    array->items = (YR_ARRAY_ITEMS*) yr_malloc(\n        sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));\n    if (array->items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n    memset(array->items->objects, 0, count * sizeof(YR_OBJECT*));\n    array->items->count = count;\n  }\n  else if (index >= array->items->count)\n  {\n    count = array->items->count * 2;\n    array->items = (YR_ARRAY_ITEMS*) yr_realloc(\n        array->items,\n        sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));\n    if (array->items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n    for (i = array->items->count; i < count; i++)\n      array->items->objects[i] = NULL;\n    array->items->count = count;\n  }\n  item->parent = object;\n  array->items->objects[index] = item;\n  return ERROR_SUCCESS;\n}", "target": 1}
{"code": "void fslib_copy_libs(const char *full_path) {\n\tassert(full_path);\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\"    fslib_copy_libs %s\\n\", full_path);\n\tif (access(full_path, R_OK)) {\n\t\tif (arg_debug || arg_debug_private_lib)\n\t\t\tprintf(\"cannot find %s for private-lib, skipping...\\n\", full_path);\n\t\treturn;\n\t}\n\tunlink(RUN_LIB_FILE);\t\t\t  \n\tcreate_empty_file_as_root(RUN_LIB_FILE, 0644);\n\tif (chown(RUN_LIB_FILE, getuid(), getgid()))\n\t\terrExit(\"chown\");\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\"    running fldd %s\\n\", full_path);\n\tsbox_run(SBOX_USER | SBOX_SECCOMP | SBOX_CAPS_NONE, 3, PATH_FLDD, full_path, RUN_LIB_FILE);\n\tFILE *fp = fopen(RUN_LIB_FILE, \"r\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tchar *ptr = strchr(buf, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\t\tfslib_duplicate(buf);\n\t}\n\tfclose(fp);\n\tunlink(RUN_LIB_FILE);\n}", "target": 0}
{"code": "static void __skb_complete_tx_timestamp(struct sk_buff *skb,\n\t\t\t\t\tstruct sock *sk,\n\t\t\t\t\tint tstype)\n{\n\tstruct sock_exterr_skb *serr;\n\tint err;\n\tserr = SKB_EXT_ERR(skb);\n\tmemset(serr, 0, sizeof(*serr));\n\tserr->ee.ee_errno = ENOMSG;\n\tserr->ee.ee_origin = SO_EE_ORIGIN_TIMESTAMPING;\n\tserr->ee.ee_info = tstype;\n\tif (sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID) {\n\t\tserr->ee.ee_data = skb_shinfo(skb)->tskey;\n\t\tif (sk->sk_protocol == IPPROTO_TCP &&\n\t\t    sk->sk_type == SOCK_STREAM)\n\t\t\tserr->ee.ee_data -= sk->sk_tskey;\n\t}\n\terr = sock_queue_err_skb(sk, skb);\n\tif (err)\n\t\tkfree_skb(skb);", "target": 1}
{"code": "ArgParser::parseServerArgs(ServerArgs& args, int argc, const char* const* argv)\n{\n    setArgsBase(args);\n    updateCommonArgs(argv);\n    for (int i = 1; i < argc; ++i) {\n        if (parsePlatformArg(args, argc, argv, i)) {\n            continue;\n        }\n        else if (parseGenericArgs(argc, argv, i)) {\n            continue;\n        }\n        else if (parseDeprecatedArgs(argc, argv, i)) {\n            continue;\n        }\n        else if (isArg(i, argc, argv, \"-a\", \"--address\", 1)) {\n            args.m_barrierAddress = argv[++i];\n        }\n        else if (isArg(i, argc, argv, \"-c\", \"--config\", 1)) {\n            args.m_configFile = argv[++i];\n        }\n        else if (isArg(i, argc, argv, NULL, \"--screen-change-script\", 1)) {\n            args.m_screenChangeScript = argv[++i];\n        }\n        else {\n            LOG((CLOG_PRINT \"%s: unrecognized option `%s'\" BYE, args.m_exename.c_str(), argv[i], args.m_exename.c_str()));\n            return false;\n        }\n    }\n    if (checkUnexpectedArgs()) {\n        return false;\n    }\n    return true;\n}", "target": 1}
{"code": "static inline void ModulateHSL(const double percent_hue,\n  const double percent_saturation,const double percent_lightness,double *red,\n  double *green,double *blue)\n{\n  double\n    hue,\n    lightness,\n    saturation;\n  ConvertRGBToHSL(*red,*green,*blue,&hue,&saturation,&lightness);\n  hue+=0.5*(0.01*percent_hue-1.0);\n  saturation*=0.01*percent_saturation;\n  lightness*=0.01*percent_lightness;\n  ConvertHSLToRGB(hue,saturation,lightness,red,green,blue);\n}", "target": 0}
{"code": "static void init_timeout(void *arg)\n{\n\tint local_port = *(int *)arg;\n\tinfo(\"init_timeout: srv_init\\n\");\n\tsrv_init((uint16_t)local_port);\n}", "target": 0}
{"code": "void fput(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tfile_sb_list_del(file);\n\t\tif (likely(!in_interrupt() && !(task->flags & PF_KTHREAD))) {\n\t\t\tinit_task_work(&file->f_u.fu_rcuhead, ____fput);\n\t\t\tif (!task_work_add(task, &file->f_u.fu_rcuhead, true))\n\t\t\t\treturn;\n\t\t}\n\t\tif (llist_add(&file->f_u.fu_llist, &delayed_fput_list))\n\t\t\tschedule_work(&delayed_fput_work);\n\t}\n}", "target": 1}
{"code": "static void encode_open(struct xdr_stream *xdr, const struct nfs_openargs *arg, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_OPEN, decode_open_maxsz, hdr);\n\tencode_openhdr(xdr, arg);\n\tencode_opentype(xdr, arg);\n\tswitch (arg->claim) {\n\tcase NFS4_OPEN_CLAIM_NULL:\n\t\tencode_claim_null(xdr, arg->name);\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_PREVIOUS:\n\t\tencode_claim_previous(xdr, arg->u.delegation_type);\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_DELEGATE_CUR:\n\t\tencode_claim_delegate_cur(xdr, arg->name, &arg->u.delegation);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}", "target": 0}
{"code": "static inline int pmd_present(pmd_t pmd)\n{\n\treturn pmd_flags(pmd) & _PAGE_PRESENT;\n}", "target": 1}
{"code": "int64_t OpLevelCostEstimator::CalculateOutputSize(const OpInfo& op_info,\n                                                  bool* found_unknown_shapes) {\n  int64_t total_output_size = 0;\n  for (const auto& output : op_info.outputs()) {\n    DataType dt = output.dtype();\n    const auto& original_output_shape = output.shape();\n    int64_t output_size = DataTypeSize(BaseType(dt));\n    int num_dims = std::max(1, original_output_shape.dim_size());\n    auto output_shape = MaybeGetMinimumShape(original_output_shape, num_dims,\n                                             found_unknown_shapes);\n    for (const auto& dim : output_shape.dim()) {\n      output_size *= dim.size();\n    }\n    total_output_size += output_size;\n    VLOG(1) << \"Output Size: \" << output_size\n            << \" Total Output Size:\" << total_output_size;\n  }\n  return total_output_size;\n}", "target": 1}
{"code": "Napi::Object Statement::Init(Napi::Env env, Napi::Object exports) {\n    Napi::HandleScope scope(env);\n    Napi::Function t = DefineClass(env, \"Statement\", {\n      InstanceMethod(\"bind\", &Statement::Bind),\n      InstanceMethod(\"get\", &Statement::Get),\n      InstanceMethod(\"run\", &Statement::Run),\n      InstanceMethod(\"all\", &Statement::All),\n      InstanceMethod(\"each\", &Statement::Each),\n      InstanceMethod(\"reset\", &Statement::Reset),\n      InstanceMethod(\"finalize\", &Statement::Finalize_),\n    });\n    exports.Set(\"Statement\", t);\n    return exports;\n}", "target": 0}
{"code": "static int ras_getcmap(jas_stream_t *in, ras_hdr_t *hdr, ras_cmap_t *cmap)\n{\n\tint i;\n\tint j;\n\tint x;\n\tint c;\n\tint numcolors;\n\tint actualnumcolors;\n\tswitch (hdr->maptype) {\n\tcase RAS_MT_NONE:\n\t\tbreak;\n\tcase RAS_MT_EQUALRGB:\n\t\t{\n\t\tjas_eprintf(\"warning: palettized images not fully supported\\n\");\n\t\tnumcolors = 1 << hdr->depth;\n\t\tassert(numcolors <= RAS_CMAP_MAXSIZ);\n\t\tactualnumcolors = hdr->maplength / 3;\n\t\tfor (i = 0; i < numcolors; i++) {\n\t\t\tcmap->data[i] = 0;\n\t\t}\n\t\tif ((hdr->maplength % 3) || hdr->maplength < 0 ||\n\t\t  hdr->maplength > 3 * numcolors) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tfor (j = 0; j < actualnumcolors; j++) {\n\t\t\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tx = 0;\n\t\t\t\tswitch (i) {\n\t\t\t\tcase 0:\n\t\t\t\t\tx = RAS_RED(c);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tx = RAS_GREEN(c);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tx = RAS_BLUE(c);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcmap->data[j] |= x;\n\t\t\t}\n\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t\tbreak;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void initialize_CABAC_models(thread_context* tctx)\n{\n  const int QPY = tctx->shdr->SliceQPY;\n  const int initType = tctx->shdr->initType;\n  assert(initType >= 0 && initType <= 2);\n  tctx->ctx_model.init(initType, QPY);\n  for (int i=0;i<4;i++) {\n    tctx->StatCoeff[i] = 0;\n  }\n}", "target": 0}
{"code": "SYSCALL_DEFINE6(move_pages, pid_t, pid, unsigned long, nr_pages,\n\t\tconst void __user * __user *, pages,\n\t\tconst int __user *, nodes,\n\t\tint __user *, status, int, flags)\n{\n\tconst struct cred *cred = current_cred(), *tcred;\n\tstruct task_struct *task;\n\tstruct mm_struct *mm;\n\tint err;\n\tnodemask_t task_nodes;\n\tif (flags & ~(MPOL_MF_MOVE|MPOL_MF_MOVE_ALL))\n\t\treturn -EINVAL;\n\tif ((flags & MPOL_MF_MOVE_ALL) && !capable(CAP_SYS_NICE))\n\t\treturn -EPERM;\n\trcu_read_lock();\n\ttask = pid ? find_task_by_vpid(pid) : current;\n\tif (!task) {\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\tget_task_struct(task);\n\ttcred = __task_cred(task);\n\tif (!uid_eq(cred->euid, tcred->suid) && !uid_eq(cred->euid, tcred->uid) &&\n\t    !uid_eq(cred->uid,  tcred->suid) && !uid_eq(cred->uid,  tcred->uid) &&\n\t    !capable(CAP_SYS_NICE)) {\n\t\trcu_read_unlock();\n\t\terr = -EPERM;\n\t\tgoto out;\n\t}\n\trcu_read_unlock();\n \terr = security_task_movememory(task);\n \tif (err)\n\t\tgoto out;\n\ttask_nodes = cpuset_mems_allowed(task);\n\tmm = get_task_mm(task);\n\tput_task_struct(task);\n\tif (!mm)\n\t\treturn -EINVAL;\n\tif (nodes)\n\t\terr = do_pages_move(mm, task_nodes, nr_pages, pages,\n\t\t\t\t    nodes, status, flags);\n\telse\n\t\terr = do_pages_stat(mm, nr_pages, pages, status);\n\tmmput(mm);\n\treturn err;\nout:\n\tput_task_struct(task);\n\treturn err;\n}", "target": 1}
{"code": "ssize_t enc_untrusted_recvfrom(int sockfd, void *buf, size_t len, int flags,\n                               struct sockaddr *src_addr, socklen_t *addrlen) {\n  int klinux_flags = TokLinuxRecvSendFlag(flags);\n  if (klinux_flags == 0 && flags != 0) {\n    errno = EINVAL;\n    return -1;\n  }\n  MessageWriter input;\n  input.Push<int>(sockfd);\n  input.Push<uint64_t>(len);\n  input.Push<int>(klinux_flags);\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kRecvFromHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_recvfrom\", 4);\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return result;\n  }\n  if (result > len) {\n    ::asylo::primitives::TrustedPrimitives::BestEffortAbort(\n        \"enc_untrusted_recvfrom: result exceeds requested\");\n  }\n  auto buffer_received = output.next();\n  memcpy(buf, buffer_received.data(), std::min(len, buffer_received.size()));\n  if (src_addr != nullptr && addrlen != nullptr) {\n    auto klinux_sockaddr_buf = output.next();\n    const struct klinux_sockaddr *klinux_addr =\n        klinux_sockaddr_buf.As<struct klinux_sockaddr>();\n    FromkLinuxSockAddr(klinux_addr, klinux_sockaddr_buf.size(), src_addr,\n                       addrlen, TrustedPrimitives::BestEffortAbort);\n  }\n  return result;\n}", "target": 0}
{"code": "u64 secure_dccp_sequence_number(__be32 saddr, __be32 daddr,\n\t\t\t\t__be16 sport, __be16 dport)\n{\n\tu32 hash[MD5_DIGEST_WORDS];\n\tu64 seq;\n\thash[0] = (__force u32)saddr;\n\thash[1] = (__force u32)daddr;\n\thash[2] = ((__force u16)sport << 16) + (__force u16)dport;\n\thash[3] = net_secret[15];\n\tmd5_transform(hash, net_secret);\n\tseq = hash[0] | (((u64)hash[1]) << 32);\n\tseq += ktime_to_ns(ktime_get_real());\n\tseq &= (1ull << 48) - 1;\n\treturn seq;\n}", "target": 0}
{"code": "static int atalk_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tint rc = -ENOIOCTLCMD;\n\tstruct sock *sk = sock->sk;\n\tvoid __user *argp = (void __user *)arg;\n\tswitch (cmd) {\n\tcase TIOCOUTQ: {\n\t\tlong amount = sk->sk_sndbuf - sk_wmem_alloc_get(sk);\n\t\tif (amount < 0)\n\t\t\tamount = 0;\n\t\trc = put_user(amount, (int __user *)argp);\n\t\tbreak;\n\t}\n\tcase TIOCINQ: {\n\t\tstruct sk_buff *skb = skb_peek(&sk->sk_receive_queue);\n\t\tlong amount = 0;\n\t\tif (skb)\n\t\t\tamount = skb->len - sizeof(struct ddpehdr);\n\t\trc = put_user(amount, (int __user *)argp);\n\t\tbreak;\n\t}\n\tcase SIOCADDRT:\n\tcase SIOCDELRT:\n\t\trc = -EPERM;\n\t\tif (capable(CAP_NET_ADMIN))\n\t\t\trc = atrtr_ioctl(cmd, argp);\n\t\tbreak;\n\tcase SIOCGIFADDR:\n\tcase SIOCSIFADDR:\n\tcase SIOCGIFBRDADDR:\n\tcase SIOCATALKDIFADDR:\n\tcase SIOCDIFADDR:\n\tcase SIOCSARP:\t\t\n\tcase SIOCDARP:\t\t\n\t\trtnl_lock();\n\t\trc = atif_ioctl(cmd, argp);\n\t\trtnl_unlock();\n\t\tbreak;\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "void exit_io_context(void)\n{\n\tstruct io_context *ioc;\n\ttask_lock(current);\n\tioc = current->io_context;\n\tcurrent->io_context = NULL;\n\ttask_unlock(current);\n\tif (atomic_dec_and_test(&ioc->nr_tasks)) {\n\t\tif (ioc->aic && ioc->aic->exit)\n\t\t\tioc->aic->exit(ioc->aic);\n\t\tcfq_exit(ioc);\n\t\tput_io_context(ioc);\n\t}\n}", "target": 1}
{"code": "bool ExtractSymlink(CommandData *Cmd,ComprDataIO &DataIO,Archive &Arc,const wchar *LinkName)\n{\n#if defined(SAVE_LINKS) && defined(_UNIX)\n  if (Arc.Format==RARFMT15)\n    return ExtractUnixLink30(Cmd,DataIO,Arc,LinkName);\n  if (Arc.Format==RARFMT50)\n    return ExtractUnixLink50(Cmd,LinkName,&Arc.FileHead);\n#elif defined _WIN_ALL\n  if (Arc.Format==RARFMT50)\n    return CreateReparsePoint(Cmd,LinkName,&Arc.FileHead);\n#endif\n  return false;\n}", "target": 1}
{"code": "ip_optprint(netdissect_options *ndo,\n            register const u_char *cp, u_int length)\n{\n\tregister u_int option_len;\n\tconst char *sep = \"\";\n\tfor (; length > 0; cp += option_len, length -= option_len) {\n\t\tu_int option_code;\n\t\tND_PRINT((ndo, \"%s\", sep));\n\t\tsep = \",\";\n\t\tND_TCHECK(*cp);\n\t\toption_code = *cp;\n\t\tND_PRINT((ndo, \"%s\",\n\t\t          tok2str(ip_option_values,\"unknown %u\",option_code)));\n\t\tif (option_code == IPOPT_NOP ||\n                    option_code == IPOPT_EOL)\n\t\t\toption_len = 1;\n\t\telse {\n\t\t\tND_TCHECK(cp[1]);\n\t\t\toption_len = cp[1];\n\t\t\tif (option_len < 2) {\n\t\t\t\tND_PRINT((ndo, \" [bad length %u]\", option_len));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (option_len > length) {\n\t\t\tND_PRINT((ndo, \" [bad length %u]\", option_len));\n\t\t\treturn;\n\t\t}\n\t\tND_TCHECK2(*cp, option_len);\n\t\tswitch (option_code) {\n\t\tcase IPOPT_EOL:\n\t\t\treturn;\n\t\tcase IPOPT_TS:\n\t\t\tip_printts(ndo, cp, option_len);\n\t\t\tbreak;\n\t\tcase IPOPT_RR:       \n\t\tcase IPOPT_SSRR:\n\t\tcase IPOPT_LSRR:\n\t\t\tip_printroute(ndo, cp, option_len);\n\t\t\tbreak;\n\t\tcase IPOPT_RA:\n\t\t\tif (option_len < 4) {\n\t\t\t\tND_PRINT((ndo, \" [bad length %u]\", option_len));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tND_TCHECK(cp[3]);\n\t\t\tif (EXTRACT_16BITS(&cp[2]) != 0)\n\t\t\t\tND_PRINT((ndo, \" value %u\", EXTRACT_16BITS(&cp[2])));\n\t\t\tbreak;\n\t\tcase IPOPT_NOP:       \n\t\tcase IPOPT_SECURITY:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn;\ntrunc:\n\tND_PRINT((ndo, \"%s\", tstr));\n}", "target": 1}
{"code": "static unsigned long page_table_shareable(struct vm_area_struct *svma,\n\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\tunsigned long addr, pgoff_t idx)\n{\n\tunsigned long saddr = ((idx - svma->vm_pgoff) << PAGE_SHIFT) +\n\t\t\t\tsvma->vm_start;\n\tunsigned long sbase = saddr & PUD_MASK;\n\tunsigned long s_end = sbase + PUD_SIZE;\n\tunsigned long vm_flags = vma->vm_flags & VM_LOCKED_CLEAR_MASK;\n\tunsigned long svm_flags = svma->vm_flags & VM_LOCKED_CLEAR_MASK;\n\tif (pmd_index(addr) != pmd_index(saddr) ||\n\t    vm_flags != svm_flags ||\n\t    !range_in_vma(svma, sbase, s_end))\n\t\treturn 0;\n\treturn saddr;\n}", "target": 0}
{"code": "R_API ut64 r_bin_java_element_pair_calc_size(RBinJavaElementValuePair *evp) {\n\tut64 sz = 0;\n\tif (evp == NULL) {\n\t\treturn sz;\n\t}\n\tsz += 2;\n\tif (evp->value) {\n\t\tsz += r_bin_java_element_value_calc_size (evp->value);\n\t}\n\treturn sz;\n}", "target": 1}
{"code": "OpLevelCostEstimator::OpDimensionsFromInputs(\n    const TensorShapeProto& original_image_shape, const OpInfo& op_info,\n    bool* found_unknown_shapes) {\n  VLOG(2) << \"op features: \" << op_info.DebugString();\n  VLOG(2) << \"Original image shape: \" << original_image_shape.DebugString();\n  auto image_shape =\n      MaybeGetMinimumShape(original_image_shape, 4, found_unknown_shapes);\n  VLOG(2) << \"Image shape: \" << image_shape.DebugString();\n  int x_index, y_index, channel_index;\n  const std::string& data_format = GetDataFormat(op_info);\n  if (data_format == \"NCHW\") {\n    channel_index = 1;\n    y_index = 2;\n    x_index = 3;\n  } else {\n    y_index = 1;\n    x_index = 2;\n    channel_index = 3;\n  }\n  int64_t batch = image_shape.dim(0).size();\n  int64_t ix = image_shape.dim(x_index).size();\n  int64_t iy = image_shape.dim(y_index).size();\n  int64_t iz = image_shape.dim(channel_index).size();\n  std::vector<int64_t> ksize = GetKernelSize(op_info);\n  int64_t kx = ksize[x_index];\n  int64_t ky = ksize[y_index];\n  int64_t kz = iz;\n  std::vector<int64_t> strides = GetStrides(op_info);\n  int64_t sx = strides[x_index];\n  int64_t sy = strides[y_index];\n  if (sx == 0 || sy == 0) {\n    return errors::InvalidArgument(\n        \"Stride must be > 0 for Height and Width, but got (\", sy, \", \", sx,\n        \")\");\n  }\n  const auto padding = GetPadding(op_info);\n  int64_t ox = GetOutputSize(ix, kx, sx, padding);\n  int64_t oy = GetOutputSize(iy, ky, sy, padding);\n  int64_t oz = iz;\n  OpLevelCostEstimator::ConvolutionDimensions conv_dims = {\n      batch, ix, iy, iz, kx, ky, kz, oz, ox, oy, sx, sy, padding};\n  return conv_dims;\n}", "target": 0}
{"code": "static void set_last_stream_little_endian(AVFormatContext *fc)\n{\n    AVStream *st;\n    if (fc->nb_streams < 1)\n        return;\n    st = fc->streams[fc->nb_streams-1];\n    switch (st->codecpar->codec_id) {\n    case AV_CODEC_ID_PCM_S16BE:\n        st->codecpar->codec_id = AV_CODEC_ID_PCM_S16LE;\n        break;\n    case AV_CODEC_ID_PCM_S24BE:\n        st->codecpar->codec_id = AV_CODEC_ID_PCM_S24LE;\n        break;\n    case AV_CODEC_ID_PCM_S32BE:\n        st->codecpar->codec_id = AV_CODEC_ID_PCM_S32LE;\n        break;\n    case AV_CODEC_ID_PCM_F32BE:\n        st->codecpar->codec_id = AV_CODEC_ID_PCM_F32LE;\n        break;\n    case AV_CODEC_ID_PCM_F64BE:\n        st->codecpar->codec_id = AV_CODEC_ID_PCM_F64LE;\n        break;\n    default:\n        break;\n    }\n}", "target": 0}
{"code": "void key_set_timeout(struct key *key, unsigned timeout)\n{\n\tstruct timespec now;\n\ttime_t expiry = 0;\n\tdown_write(&key->sem);\n\tif (timeout > 0) {\n\t\tnow = current_kernel_time();\n\t\texpiry = now.tv_sec + timeout;\n\t}\n\tkey->expiry = expiry;\n\tkey_schedule_gc(key->expiry + key_gc_delay);\n\tup_write(&key->sem);\n}", "target": 0}
{"code": "static inline int checkSettingSecurity(lua_State* L, const std::string &name)\n{\n\tif (ScriptApiSecurity::isSecure(L) && name.compare(0, 7, \"secure.\") == 0)\n\t\tthrow LuaError(\"Attempt to set secure setting.\");\n\tbool is_mainmenu = false;\n#ifndef SERVER\n\tis_mainmenu = ModApiBase::getGuiEngine(L) != nullptr;\n#endif\n\tif (!is_mainmenu && (name == \"mg_name\" || name == \"mg_flags\")) {\n\t\terrorstream << \"Tried to set global setting \" << name << \", ignoring. \"\n\t\t\t\"minetest.set_mapgen_setting() should be used instead.\" << std::endl;\n\t\tinfostream << script_get_backtrace(L) << std::endl;\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void release_dentry_name_snapshot(struct name_snapshot *name)\n{\n\tif (unlikely(name->name != name->inline_name)) {\n\t\tstruct external_name *p;\n\t\tp = container_of(name->name, struct external_name, name[0]);\n\t\tif (unlikely(atomic_dec_and_test(&p->u.count)))\n\t\t\tkfree_rcu(p, u.head);\n\t}\n}", "target": 0}
{"code": "    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,\n                                       const UBaseType_t uxItemSize,\n                                       const uint8_t ucQueueType )\n    {\n        Queue_t * pxNewQueue;\n        size_t xQueueSizeInBytes;\n        uint8_t * pucQueueStorage;\n        configASSERT( uxQueueLength > ( UBaseType_t ) 0 );\n        xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); \n        configASSERT( ( uxItemSize == 0 ) || ( uxQueueLength == ( xQueueSizeInBytes / uxItemSize ) ) );\n        configASSERT( ( sizeof( Queue_t ) + xQueueSizeInBytes ) >  xQueueSizeInBytes );\n        pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); \n        if( pxNewQueue != NULL )\n        {\n            pucQueueStorage = ( uint8_t * ) pxNewQueue;\n            pucQueueStorage += sizeof( Queue_t ); \n            #if ( configSUPPORT_STATIC_ALLOCATION == 1 )\n                {\n                    pxNewQueue->ucStaticallyAllocated = pdFALSE;\n                }\n            #endif \n            prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );\n        }\n        else\n        {\n            traceQUEUE_CREATE_FAILED( ucQueueType );\n            mtCOVERAGE_TEST_MARKER();\n        }\n        return pxNewQueue;\n    }", "target": 0}
{"code": "int hugepage_madvise(struct vm_area_struct *vma,\n\t\t     unsigned long *vm_flags, int advice)\n{\n\tswitch (advice) {\n\tcase MADV_HUGEPAGE:\n\t\tif (*vm_flags & (VM_HUGEPAGE |\n\t\t\t\t VM_SHARED   | VM_MAYSHARE   |\n\t\t\t\t VM_PFNMAP   | VM_IO      | VM_DONTEXPAND |\n\t\t\t\t VM_RESERVED | VM_HUGETLB | VM_INSERTPAGE |\n\t\t\t\t VM_MIXEDMAP | VM_SAO))\n\t\t\treturn -EINVAL;\n\t\t*vm_flags &= ~VM_NOHUGEPAGE;\n\t\t*vm_flags |= VM_HUGEPAGE;\n\t\tif (unlikely(khugepaged_enter_vma_merge(vma)))\n\t\t\treturn -ENOMEM;\n\t\tbreak;\n\tcase MADV_NOHUGEPAGE:\n\t\tif (*vm_flags & (VM_NOHUGEPAGE |\n\t\t\t\t VM_SHARED   | VM_MAYSHARE   |\n\t\t\t\t VM_PFNMAP   | VM_IO      | VM_DONTEXPAND |\n\t\t\t\t VM_RESERVED | VM_HUGETLB | VM_INSERTPAGE |\n\t\t\t\t VM_MIXEDMAP | VM_SAO))\n\t\t\treturn -EINVAL;\n\t\t*vm_flags &= ~VM_HUGEPAGE;\n\t\t*vm_flags |= VM_NOHUGEPAGE;\n\t\tbreak;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "gen_hash(codegen_scope *s, node *tree, int val, int limit)\n{\n  int slimit = GEN_VAL_STACK_MAX;\n  if (cursp() >= GEN_LIT_ARY_MAX) slimit = INT16_MAX;\n  int len = 0;\n  mrb_bool update = FALSE;\n  while (tree) {\n    if (nint(tree->car->car->car) == NODE_KW_REST_ARGS) {\n      if (len > 0) {\n        pop_n(len*2);\n        if (!update) {\n          genop_2(s, OP_HASH, cursp(), len);\n        }\n        else {\n          pop();\n          genop_2(s, OP_HASHADD, cursp(), len);\n        }\n        push();\n      }\n      codegen(s, tree->car->cdr, val);\n      if (len > 0 || update) {\n        pop(); pop();\n        genop_1(s, OP_HASHCAT, cursp());\n        push();\n      }\n      update = TRUE;\n      len = 0;\n    }\n    else {\n      codegen(s, tree->car->car, val);\n      codegen(s, tree->car->cdr, val);\n      len++;\n    }\n    tree = tree->cdr;\n    if (val && cursp() >= slimit) {\n      pop_n(len*2);\n      if (!update) {\n        genop_2(s, OP_HASH, cursp(), len);\n      }\n      else {\n        pop();\n        genop_2(s, OP_HASHADD, cursp(), len);\n      }\n      push();\n      update = TRUE;\n      len = 0;\n    }\n  }\n  if (update) {\n    if (len > 0) {\n      pop_n(len*2+1);\n      genop_2(s, OP_HASHADD, cursp(), len);\n      push();\n    }\n    return -1;                  \n  }\n  if (update) return -1;\n  return len;\n}", "target": 1}
{"code": "do_local_notify(xmlNode * notify_src, const char *client_id,\n                gboolean sync_reply, gboolean from_peer)\n{\n    cib_client_t *client_obj = NULL;\n    int local_rc = pcmk_ok;\n    if (client_id != NULL) {\n        client_obj = g_hash_table_lookup(client_list, client_id);\n    } else {\n        crm_trace(\"No client to sent the response to. F_CIB_CLIENTID not set.\");\n    }\n    if (client_obj == NULL) {\n        local_rc = -ECONNRESET;\n    } else {\n        int rid = 0;\n        if(sync_reply) {\n            CRM_LOG_ASSERT(client_obj->request_id);\n            rid = client_obj->request_id;\n            client_obj->request_id = 0;\n            crm_trace(\"Sending response %d to %s %s\",\n                      rid, client_obj->name, from_peer?\"(originator of delegated request)\":\"\");\n        } else {\n            crm_trace(\"Sending an event to %s %s\",\n                      client_obj->name, from_peer?\"(originator of delegated request)\":\"\");\n        }\n        if (client_obj->ipc && crm_ipcs_send(client_obj->ipc, rid, notify_src, !sync_reply) < 0) {\n            local_rc = -ENOMSG;\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        } else if (client_obj->session) {\n            crm_send_remote_msg(client_obj->session, notify_src, client_obj->encrypted);\n#endif\n        } else if(client_obj->ipc == NULL) {\n            crm_err(\"Unknown transport for %s\", client_obj->name);\n        }\n    }\n    if (local_rc != pcmk_ok && client_obj != NULL) {\n        crm_warn(\"%sSync reply to %s failed: %s\",\n                 sync_reply ? \"\" : \"A-\",\n                 client_obj ? client_obj->name : \"<unknown>\", pcmk_strerror(local_rc));\n    }\n}", "target": 1}
{"code": "static int xfrm_dump_policy_start(struct netlink_callback *cb)\n{\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb->args;\n\tBUILD_BUG_ON(sizeof(*walk) > sizeof(cb->args));\n\txfrm_policy_walk_init(walk, XFRM_POLICY_TYPE_ANY);\n\treturn 0;\n}", "target": 0}
{"code": "static int pppol2tp_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t       char __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2tp_session *session;\n\tstruct l2tp_tunnel *tunnel;\n\tstruct pppol2tp_session *ps;\n\tint val;\n\tint err;\n\tif (level != SOL_PPPOL2TP)\n\t\treturn udp_prot.setsockopt(sk, level, optname, optval, optlen);\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\terr = -ENOTCONN;\n\tif (sk->sk_user_data == NULL)\n\t\tgoto end;\n\terr = -EBADF;\n\tsession = pppol2tp_sock_to_session(sk);\n\tif (session == NULL)\n\t\tgoto end;\n\tps = l2tp_session_priv(session);\n\tif ((session->session_id == 0) &&\n\t    (session->peer_session_id == 0)) {\n\t\terr = -EBADF;\n\t\ttunnel = l2tp_sock_to_tunnel(ps->tunnel_sock);\n\t\tif (tunnel == NULL)\n\t\t\tgoto end_put_sess;\n\t\terr = pppol2tp_tunnel_setsockopt(sk, tunnel, optname, val);\n\t\tsock_put(ps->tunnel_sock);\n\t} else\n\t\terr = pppol2tp_session_setsockopt(sk, session, optname, val);\n\terr = 0;\nend_put_sess:\n\tsock_put(sk);\nend:\n\treturn err;\n}", "target": 1}
{"code": "static void clear_evtchn_to_irq_row(unsigned row)\n{\n\tunsigned col;\n\tfor (col = 0; col < EVTCHN_PER_ROW; col++)\n\t\tevtchn_to_irq[row][col] = -1;\n}", "target": 1}
{"code": "static int __net_init sit_init_net(struct net *net)\n{\n\tstruct sit_net *sitn = net_generic(net, sit_net_id);\n\tstruct ip_tunnel *t;\n\tint err;\n\tsitn->tunnels[0] = sitn->tunnels_wc;\n\tsitn->tunnels[1] = sitn->tunnels_l;\n\tsitn->tunnels[2] = sitn->tunnels_r;\n\tsitn->tunnels[3] = sitn->tunnels_r_l;\n\tif (!net_has_fallback_tunnels(net))\n\t\treturn 0;\n\tsitn->fb_tunnel_dev = alloc_netdev(sizeof(struct ip_tunnel), \"sit0\",\n\t\t\t\t\t   NET_NAME_UNKNOWN,\n\t\t\t\t\t   ipip6_tunnel_setup);\n\tif (!sitn->fb_tunnel_dev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_dev;\n\t}\n\tdev_net_set(sitn->fb_tunnel_dev, net);\n\tsitn->fb_tunnel_dev->rtnl_link_ops = &sit_link_ops;\n\tsitn->fb_tunnel_dev->features |= NETIF_F_NETNS_LOCAL;\n\terr = register_netdev(sitn->fb_tunnel_dev);\n\tif (err)\n\t\tgoto err_reg_dev;\n\tipip6_tunnel_clone_6rd(sitn->fb_tunnel_dev, sitn);\n\tipip6_fb_tunnel_init(sitn->fb_tunnel_dev);\n\tt = netdev_priv(sitn->fb_tunnel_dev);\n\tstrcpy(t->parms.name, sitn->fb_tunnel_dev->name);\n\treturn 0;\nerr_reg_dev:\n\tipip6_dev_free(sitn->fb_tunnel_dev);\n\tfree_netdev(sitn->fb_tunnel_dev);\nerr_alloc_dev:\n\treturn err;\n}", "target": 0}
{"code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  TfLiteTensor* hits;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 1, &hits));\n  const TfLiteTensor* lookup;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &lookup));\n  const TfLiteTensor* key;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &key));\n  const TfLiteTensor* value;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 2, &value));\n  const int num_rows = SizeOfDimension(value, 0);\n  TF_LITE_ENSURE(context, num_rows != 0);\n  const int row_bytes = value->bytes / num_rows;\n  void* pointer = nullptr;\n  DynamicBuffer buf;\n  for (int i = 0; i < SizeOfDimension(lookup, 0); i++) {\n    int idx = -1;\n    pointer = bsearch(&(lookup->data.i32[i]), key->data.i32, num_rows,\n                      sizeof(int32_t), greater);\n    if (pointer != nullptr) {\n      idx = (reinterpret_cast<char*>(pointer) - (key->data.raw)) /\n            sizeof(int32_t);\n    }\n    if (idx >= num_rows || idx < 0) {\n      if (output->type == kTfLiteString) {\n        buf.AddString(nullptr, 0);\n      } else {\n        memset(output->data.raw + i * row_bytes, 0, row_bytes);\n      }\n      hits->data.uint8[i] = 0;\n    } else {\n      if (output->type == kTfLiteString) {\n        buf.AddString(GetString(value, idx));\n      } else {\n        memcpy(output->data.raw + i * row_bytes,\n               value->data.raw + idx * row_bytes, row_bytes);\n      }\n      hits->data.uint8[i] = 1;\n    }\n  }\n  if (output->type == kTfLiteString) {\n    buf.WriteToTensorAsVector(output);\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "static mp_obj_t array_extend(mp_obj_t self_in, mp_obj_t arg_in) {\n    assert((MICROPY_PY_BUILTINS_BYTEARRAY && mp_obj_is_type(self_in, &mp_type_bytearray))\n        || (MICROPY_PY_ARRAY && mp_obj_is_type(self_in, &mp_type_array)));\n    mp_obj_array_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_buffer_info_t arg_bufinfo;\n    mp_get_buffer_raise(arg_in, &arg_bufinfo, MP_BUFFER_READ);\n    size_t sz = mp_binary_get_size('@', self->typecode, NULL);\n    size_t len = arg_bufinfo.len / sz;\n    if (self->free < len) {\n        self->items = m_renew(byte, self->items, (self->len + self->free) * sz, (self->len + len) * sz);\n        self->free = 0;\n        if (self_in == arg_in) {\n            mp_get_buffer_raise(arg_in, &arg_bufinfo, MP_BUFFER_READ);\n        }\n    } else {\n        self->free -= len;\n    }\n    mp_seq_copy((byte *)self->items + self->len * sz, arg_bufinfo.buf, len * sz, byte);\n    self->len += len;\n    return mp_const_none;\n}", "target": 0}
{"code": "void gnrc_sixlowpan_iphc_send(gnrc_pktsnip_t *pkt, void *ctx, unsigned page)\n{\n    gnrc_netif_hdr_t *netif_hdr = pkt->data;\n    gnrc_netif_t *netif = gnrc_netif_hdr_get_netif(netif_hdr);\n    gnrc_pktsnip_t *tmp;\n    size_t orig_datagram_size = gnrc_pkt_len(pkt->next);\n    ipv6_hdr_t *ipv6_hdr = pkt->next->data;\n    ipv6_addr_t dst;\n    if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD)) {\n        dst = ipv6_hdr->dst;    \n    }\n    if ((tmp = _iphc_encode(pkt, pkt->data, netif))) {\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD) && (ctx != NULL) &&\n            (gnrc_sixlowpan_frag_minfwd_frag_iphc(tmp, orig_datagram_size, &dst,\n                                                  ctx) == 0)) {\n            DEBUG(\"6lo iphc minfwd: putting slack in first fragment\\n\");\n            return;\n        }\n        gnrc_sixlowpan_multiplex_by_size(tmp, orig_datagram_size, netif, page);\n    }\n    else {\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD)) {\n            gnrc_sixlowpan_frag_fb_t *fb = ctx;\n            if (fb->pkt == pkt) {\n                fb->pkt = NULL;\n            }\n        }\n        gnrc_pktbuf_release(pkt);\n    }\n}", "target": 0}
{"code": "static void preinit_thread (lua_State *L, global_State *g) {\n  G(L) = g;\n  L->stack = NULL;\n  L->ci = NULL;\n  L->nci = 0;\n  L->stacksize = 0;\n  L->twups = L;  \n  L->errorJmp = NULL;\n  L->hook = NULL;\n  L->hookmask = 0;\n  L->basehookcount = 0;\n  L->allowhook = 1;\n  resethookcount(L);\n  L->openupval = NULL;\n  L->status = LUA_OK;\n  L->errfunc = 0;\n  L->oldpc = 0;\n}", "target": 0}
{"code": "static ssize_t aio_setup_vectored_rw(struct kiocb *kiocb,\n\t\t\t\t     int rw, char __user *buf,\n\t\t\t\t     unsigned long *nr_segs,\n\t\t\t\t     size_t *len,\n\t\t\t\t     struct iovec **iovec,\n\t\t\t\t     bool compat)\n{\n\tssize_t ret;\n\t*nr_segs = *len;\n#ifdef CONFIG_COMPAT\n\tif (compat)\n\t\tret = compat_rw_copy_check_uvector(rw,\n\t\t\t\t(struct compat_iovec __user *)buf,\n\t\t\t\t*nr_segs, UIO_FASTIOV, *iovec, iovec);\n\telse\n#endif\n\t\tret = rw_copy_check_uvector(rw,\n\t\t\t\t(struct iovec __user *)buf,\n\t\t\t\t*nr_segs, UIO_FASTIOV, *iovec, iovec);\n\tif (ret < 0)\n\t\treturn ret;\n\t*len = ret;\n\treturn 0;\n}", "target": 1}
{"code": "nfsd4_getdeviceinfo(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_getdeviceinfo *gdp)\n{\n\tconst struct nfsd4_layout_ops *ops;\n\tstruct nfsd4_deviceid_map *map;\n\tstruct svc_export *exp;\n\t__be32 nfserr;\n\tdprintk(\"%s: layout_type %u dev_id [0x%llx:0x%x] maxcnt %u\\n\",\n\t       __func__,\n\t       gdp->gd_layout_type,\n\t       gdp->gd_devid.fsid_idx, gdp->gd_devid.generation,\n\t       gdp->gd_maxcount);\n\tmap = nfsd4_find_devid_map(gdp->gd_devid.fsid_idx);\n\tif (!map) {\n\t\tdprintk(\"%s: couldn't find device ID to export mapping!\\n\",\n\t\t\t__func__);\n\t\treturn nfserr_noent;\n\t}\n\texp = rqst_exp_find(rqstp, map->fsid_type, map->fsid);\n\tif (IS_ERR(exp)) {\n\t\tdprintk(\"%s: could not find device id\\n\", __func__);\n\t\treturn nfserr_noent;\n\t}\n\tnfserr = nfserr_layoutunavailable;\n\tops = nfsd4_layout_verify(exp, gdp->gd_layout_type);\n\tif (!ops)\n\t\tgoto out;\n\tnfserr = nfs_ok;\n\tif (gdp->gd_maxcount != 0) {\n\t\tnfserr = ops->proc_getdeviceinfo(exp->ex_path.mnt->mnt_sb,\n\t\t\t\trqstp, cstate->session->se_client, gdp);\n\t}\n\tgdp->gd_notify_types &= ops->notify_types;\nout:\n\texp_put(exp);\n\treturn nfserr;\n}", "target": 0}
{"code": "static struct ion_handle *ion_handle_get_by_id(struct ion_client *client,\n\t\t\t\t\t\tint id)\n{\n\tstruct ion_handle *handle;\n\tmutex_lock(&client->lock);\n\thandle = idr_find(&client->idr, id);\n\tif (handle)\n\t\tion_handle_get(handle);\n\tmutex_unlock(&client->lock);\n\treturn handle ? handle : ERR_PTR(-EINVAL);\n}", "target": 1}
{"code": "static inline int timer_overrun_to_int(struct k_itimer *timr, int baseval)\n{\n\ts64 sum = timr->it_overrun_last + (s64)baseval;\n\treturn sum > (s64)INT_MAX ? INT_MAX : (int)sum;\n}", "target": 0}
{"code": "static int udp_v6_push_pending_frames(struct sock *sk)\n{\n\tstruct sk_buff *skb;\n\tstruct udphdr *uh;\n\tstruct udp_sock  *up = udp_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct flowi6 *fl6 = &inet->cork.fl.u.ip6;\n\tint err = 0;\n\tint is_udplite = IS_UDPLITE(sk);\n\t__wsum csum = 0;\n\tif ((skb = skb_peek(&sk->sk_write_queue)) == NULL)\n\t\tgoto out;\n\tuh = udp_hdr(skb);\n\tuh->source = fl6->fl6_sport;\n\tuh->dest = fl6->fl6_dport;\n\tuh->len = htons(up->len);\n\tuh->check = 0;\n\tif (is_udplite)\n\t\tcsum = udplite_csum_outgoing(sk, skb);\n\telse if (skb->ip_summed == CHECKSUM_PARTIAL) { \n\t\tudp6_hwcsum_outgoing(sk, skb, &fl6->saddr, &fl6->daddr,\n\t\t\t\t     up->len);\n\t\tgoto send;\n\t} else\n\t\tcsum = udp_csum_outgoing(sk, skb);\n\tuh->check = csum_ipv6_magic(&fl6->saddr, &fl6->daddr,\n\t\t\t\t    up->len, fl6->flowi6_proto, csum);\n\tif (uh->check == 0)\n\t\tuh->check = CSUM_MANGLED_0;\nsend:\n\terr = ip6_push_pending_frames(sk);\n\tif (err) {\n\t\tif (err == -ENOBUFS && !inet6_sk(sk)->recverr) {\n\t\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\t    UDP_MIB_SNDBUFERRORS, is_udplite);\n\t\t\terr = 0;\n\t\t}\n\t} else\n\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\t    UDP_MIB_OUTDATAGRAMS, is_udplite);\nout:\n\tup->len = 0;\n\tup->pending = 0;\n\treturn err;\n}", "target": 1}
{"code": "static int xennet_xdp_xmit(struct net_device *dev, int n,\n\t\t\t   struct xdp_frame **frames, u32 flags)\n{\n\tunsigned int num_queues = dev->real_num_tx_queues;\n\tstruct netfront_info *np = netdev_priv(dev);\n\tstruct netfront_queue *queue = NULL;\n\tunsigned long irq_flags;\n\tint nxmit = 0;\n\tint i;\n\tif (unlikely(np->broken))\n\t\treturn -ENODEV;\n\tif (unlikely(flags & ~XDP_XMIT_FLAGS_MASK))\n\t\treturn -EINVAL;\n\tqueue = &np->queues[smp_processor_id() % num_queues];\n\tspin_lock_irqsave(&queue->tx_lock, irq_flags);\n\tfor (i = 0; i < n; i++) {\n\t\tstruct xdp_frame *xdpf = frames[i];\n\t\tif (!xdpf)\n\t\t\tcontinue;\n\t\tif (xennet_xdp_xmit_one(dev, queue, xdpf))\n\t\t\tbreak;\n\t\tnxmit++;\n\t}\n\tspin_unlock_irqrestore(&queue->tx_lock, irq_flags);\n\treturn nxmit;\n}", "target": 0}
{"code": "void nft_byteorder_eval(const struct nft_expr *expr,\n\t\t\tstruct nft_regs *regs,\n\t\t\tconst struct nft_pktinfo *pkt)\n{\n\tconst struct nft_byteorder *priv = nft_expr_priv(expr);\n\tu32 *src = &regs->data[priv->sreg];\n\tu32 *dst = &regs->data[priv->dreg];\n\tu16 *s16, *d16;\n\tunsigned int i;\n\ts16 = (void *)src;\n\td16 = (void *)dst;\n\tswitch (priv->size) {\n\tcase 8: {\n\t\tu64 src64;\n\t\tswitch (priv->op) {\n\t\tcase NFT_BYTEORDER_NTOH:\n\t\t\tfor (i = 0; i < priv->len / 8; i++) {\n\t\t\t\tsrc64 = nft_reg_load64(&src[i]);\n\t\t\t\tnft_reg_store64(&dst[i],\n\t\t\t\t\t\tbe64_to_cpu((__force __be64)src64));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NFT_BYTEORDER_HTON:\n\t\t\tfor (i = 0; i < priv->len / 8; i++) {\n\t\t\t\tsrc64 = (__force __u64)\n\t\t\t\t\tcpu_to_be64(nft_reg_load64(&src[i]));\n\t\t\t\tnft_reg_store64(&dst[i], src64);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tcase 4:\n\t\tswitch (priv->op) {\n\t\tcase NFT_BYTEORDER_NTOH:\n\t\t\tfor (i = 0; i < priv->len / 4; i++)\n\t\t\t\tdst[i] = ntohl((__force __be32)src[i]);\n\t\t\tbreak;\n\t\tcase NFT_BYTEORDER_HTON:\n\t\t\tfor (i = 0; i < priv->len / 4; i++)\n\t\t\t\tdst[i] = (__force __u32)htonl(src[i]);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tswitch (priv->op) {\n\t\tcase NFT_BYTEORDER_NTOH:\n\t\t\tfor (i = 0; i < priv->len / 2; i++)\n\t\t\t\td16[i] = ntohs((__force __be16)s16[i]);\n\t\t\tbreak;\n\t\tcase NFT_BYTEORDER_HTON:\n\t\t\tfor (i = 0; i < priv->len / 2; i++)\n\t\t\t\td16[i] = (__force __u16)htons(s16[i]);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "av_cold void ff_mpv_idct_init(MpegEncContext *s)\n{\n    if (s->codec_id == AV_CODEC_ID_MPEG4)\n        s->idsp.mpeg4_studio_profile = s->studio_profile;\n    ff_idctdsp_init(&s->idsp, s->avctx);\n    if (s->alternate_scan) {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_alternate_vertical_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_alternate_vertical_scan);\n    } else {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_zigzag_direct);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_zigzag_direct);\n    }\n    ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_horizontal_scan);\n    ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);\n}", "target": 0}
{"code": "static int rds_loop_xmit(struct rds_connection *conn, struct rds_message *rm,\n\t\t\t unsigned int hdr_off, unsigned int sg,\n\t\t\t unsigned int off)\n{\n\tif (rm->m_inc.i_hdr.h_flags & RDS_FLAG_CONG_BITMAP) {\n\t\trds_cong_map_updated(conn->c_fcong, ~(u64) 0);\n\t\treturn sizeof(struct rds_header) + RDS_CONG_MAP_BYTES;\n\t}\n\tBUG_ON(hdr_off || sg || off);\n\trds_inc_init(&rm->m_inc, conn, conn->c_laddr);\n\trds_message_addref(rm);\n\trds_recv_incoming(conn, conn->c_laddr, conn->c_faddr, &rm->m_inc,\n\t\t\t  GFP_KERNEL, KM_USER0);\n\trds_send_drop_acked(conn, be64_to_cpu(rm->m_inc.i_hdr.h_sequence),\n\t\t\t    NULL);\n\trds_inc_put(&rm->m_inc);\n\treturn sizeof(struct rds_header) + be32_to_cpu(rm->m_inc.i_hdr.h_len);\n}", "target": 1}
{"code": "\t\tstatic auto HasProxy(Local<Object> object) -> bool {\n\t\t\tif (object->IsProxy()) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tauto proto = object->GetPrototype();\n\t\t\t\tif (proto->IsNullOrUndefined()) {\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\treturn HasProxy(proto.As<Object>());\n\t\t\t\t}\n\t\t\t}\n\t\t}", "target": 0}
{"code": "DECLAREcpFunc(cpContigStrips2SeparateTiles)\n{\n\treturn cpImage(in, out,\n\t    readContigStripsIntoBuffer,\n\t    writeBufferToSeparateTiles,\n\t    imagelength, imagewidth, spp);\n}", "target": 0}
{"code": "static int snd_hrtimer_start(struct snd_timer *t)\n{\n\tstruct snd_hrtimer *stime = t->private_data;\n\tatomic_set(&stime->running, 0);\n\thrtimer_cancel(&stime->hrt);\n\thrtimer_start(&stime->hrt, ns_to_ktime(t->sticks * resolution),\n\t\t      HRTIMER_MODE_REL);\n\tatomic_set(&stime->running, 1);\n\treturn 0;\n}", "target": 1}
{"code": "static void ndpi_reset_packet_line_info(struct ndpi_packet_struct *packet) {\n  packet->parsed_lines = 0, packet->empty_line_position_set = 0, packet->host_line.ptr = NULL,\n    packet->host_line.len = 0, packet->referer_line.ptr = NULL, packet->referer_line.len = 0,\n    packet->content_line.ptr = NULL, packet->content_line.len = 0, packet->accept_line.ptr = NULL,\n    packet->accept_line.len = 0, packet->user_agent_line.ptr = NULL, packet->user_agent_line.len = 0,\n    packet->http_url_name.ptr = NULL, packet->http_url_name.len = 0, packet->http_encoding.ptr = NULL,\n    packet->http_encoding.len = 0, packet->http_transfer_encoding.ptr = NULL, packet->http_transfer_encoding.len = 0,\n    packet->http_contentlen.ptr = NULL, packet->http_contentlen.len = 0, packet->http_cookie.ptr = NULL,\n    packet->http_cookie.len = 0, packet->http_origin.len = 0, packet->http_origin.ptr = NULL,\n    packet->http_x_session_type.ptr = NULL, packet->http_x_session_type.len = 0, packet->server_line.ptr = NULL,\n    packet->server_line.len = 0, packet->http_method.ptr = NULL, packet->http_method.len = 0,\n    packet->http_response.ptr = NULL, packet->http_response.len = 0, packet->http_num_headers = 0;\n}", "target": 1}
{"code": "iso9660_finish_entry(struct archive_write *a)\n{\n\tstruct iso9660 *iso9660 = a->format_data;\n\tif (iso9660->cur_file == NULL)\n\t\treturn (ARCHIVE_OK);\n\tif (archive_entry_filetype(iso9660->cur_file->entry) != AE_IFREG)\n\t\treturn (ARCHIVE_OK);\n\tif (iso9660->cur_file->content.size == 0)\n\t\treturn (ARCHIVE_OK);\n\twhile (iso9660->bytes_remaining > 0) {\n\t\tsize_t s;\n\t\ts = (iso9660->bytes_remaining > a->null_length)?\n\t\t    a->null_length: (size_t)iso9660->bytes_remaining;\n\t\tif (write_iso9660_data(a, a->nulls, s) < 0)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tiso9660->bytes_remaining -= s;\n\t}\n\tif (iso9660->zisofs.making && zisofs_finish_entry(a) != ARCHIVE_OK)\n\t\treturn (ARCHIVE_FATAL);\n\tif (wb_write_padding_to_temp(a, iso9660->cur_file->cur_content->size)\n\t    != ARCHIVE_OK)\n\t\treturn (ARCHIVE_FATAL);\n\tiso9660->cur_file->cur_content->blocks = (int)\n\t    ((iso9660->cur_file->cur_content->size\n\t     + LOGICAL_BLOCK_SIZE -1) >> LOGICAL_BLOCK_BITS);\n\tisofile_add_data_file(iso9660, iso9660->cur_file);\n\treturn (ARCHIVE_OK);\n}", "target": 0}
{"code": "static void blk_mq_freeze_queue_wait(struct request_queue *q)\n{\n\twait_event(q->mq_freeze_wq, percpu_ref_is_zero(&q->mq_usage_counter));\n}", "target": 0}
{"code": "static int decode_bit_string(const u8 * inbuf, size_t inlen, void *outbuf,\n\t\t\t     size_t outlen, int invert)\n{\n\tconst u8 *in = inbuf;\n\tu8 *out = (u8 *) outbuf;\n\tint zero_bits = *in & 0x07;\n\tsize_t octets_left = inlen - 1;\n\tint i, count = 0;\n\tmemset(outbuf, 0, outlen);\n\tin++;\n\tif (outlen < octets_left)\n\t\treturn SC_ERROR_BUFFER_TOO_SMALL;\n\tif (inlen < 1)\n\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n\twhile (octets_left) {\n\t\tint bits_to_go;\n\t\t*out = 0;\n\t\tif (octets_left == 1)\n\t\t\tbits_to_go = 8 - zero_bits;\n\t\telse\n\t\t\tbits_to_go = 8;\n\t\tif (invert)\n\t\t\tfor (i = 0; i < bits_to_go; i++) {\n\t\t\t\t*out |= ((*in >> (7 - i)) & 1) << i;\n\t\t\t}\n\t\telse {\n\t\t\t*out = *in;\n\t\t}\n\t\tout++;\n\t\tin++;\n\t\toctets_left--;\n\t\tcount++;\n\t}\n\treturn (count * 8) - zero_bits;\n}", "target": 1}
{"code": "void sas_init_disc(struct sas_discovery *disc, struct asd_sas_port *port)\n{\n\tint i;\n\tstatic const work_func_t sas_event_fns[DISC_NUM_EVENTS] = {\n\t\t[DISCE_DISCOVER_DOMAIN] = sas_discover_domain,\n\t\t[DISCE_REVALIDATE_DOMAIN] = sas_revalidate_domain,\n\t\t[DISCE_PROBE] = sas_probe_devices,\n\t\t[DISCE_SUSPEND] = sas_suspend_devices,\n\t\t[DISCE_RESUME] = sas_resume_devices,\n\t\t[DISCE_DESTRUCT] = sas_destruct_devices,\n\t};\n\tdisc->pending = 0;\n\tfor (i = 0; i < DISC_NUM_EVENTS; i++) {\n\t\tINIT_SAS_WORK(&disc->disc_work[i].work, sas_event_fns[i]);\n\t\tdisc->disc_work[i].port = port;\n\t}\n}", "target": 1}
{"code": "static inline int pmd_none_or_trans_huge_or_clear_bad(pmd_t *pmd)\n{\n\tpmd_t pmdval = pmd_read_atomic(pmd);\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tbarrier();\n#endif\n\tif (pmd_none(pmdval))\n\t\treturn 1;\n\tif (unlikely(pmd_bad(pmdval))) {\n\t\tif (!pmd_trans_huge(pmdval))\n\t\t\tpmd_clear_bad(pmd);\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "Status GetInitOp(const string& export_dir, const MetaGraphDef& meta_graph_def,\n                 string* init_op_name) {\n  const auto& sig_def_map = meta_graph_def.signature_def();\n  const auto& init_op_sig_it =\n      meta_graph_def.signature_def().find(kSavedModelInitOpSignatureKey);\n  if (init_op_sig_it != sig_def_map.end()) {\n    *init_op_name = init_op_sig_it->second.outputs()\n                        .find(kSavedModelInitOpSignatureKey)\n                        ->second.name();\n    return Status::OK();\n  }\n  const auto& collection_def_map = meta_graph_def.collection_def();\n  string init_op_collection_key;\n  if (collection_def_map.find(kSavedModelMainOpKey) !=\n      collection_def_map.end()) {\n    init_op_collection_key = kSavedModelMainOpKey;\n  } else {\n    init_op_collection_key = kSavedModelLegacyInitOpKey;\n  }\n  const auto init_op_it = collection_def_map.find(init_op_collection_key);\n  if (init_op_it != collection_def_map.end()) {\n    if (init_op_it->second.node_list().value_size() != 1) {\n      return errors::FailedPrecondition(\n          strings::StrCat(\"Expected exactly one main op in : \", export_dir));\n    }\n    *init_op_name = init_op_it->second.node_list().value(0);\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "void gru_check_context_placement(struct gru_thread_state *gts)\n{\n\tstruct gru_state *gru;\n\tgru = gts->ts_gru;\n\tif (!gru || gts->ts_tgid_owner != current->tgid)\n\t\treturn;\n\tif (!gru_check_chiplet_assignment(gru, gts)) {\n\t\tSTAT(check_context_unload);\n\t\tgru_unload_context(gts, 1);\n\t} else if (gru_retarget_intr(gts)) {\n\t\tSTAT(check_context_retarget_intr);\n\t}\n}", "target": 1}
{"code": "MagickExport void RemoveDuplicateLayers(Image **images,\n     ExceptionInfo *exception)\n{\n  register Image\n    *curr,\n    *next;\n  RectangleInfo\n    bounds;\n  assert((*images) != (const Image *) NULL);\n  assert((*images)->signature == MagickCoreSignature);\n  if ((*images)->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",(*images)->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  curr=GetFirstImageInList(*images);\n  for (; (next=GetNextImageInList(curr)) != (Image *) NULL; curr=next)\n  {\n    if ( curr->columns != next->columns || curr->rows != next->rows\n         || curr->page.x != next->page.x || curr->page.y != next->page.y )\n      continue;\n    bounds=CompareImagesBounds(curr,next,CompareAnyLayer,exception);\n    if ( bounds.x < 0 ) {\n      size_t time;\n      time = curr->delay*1000/curr->ticks_per_second;\n      time += next->delay*1000/next->ticks_per_second;\n      next->ticks_per_second = 100L;\n      next->delay = time*curr->ticks_per_second/1000;\n      next->iterations = curr->iterations;\n      *images = curr;\n      (void) DeleteImageFromList(images);\n    }\n  }\n  *images = GetFirstImageInList(*images);\n}", "target": 1}
{"code": "void HierarchicalBitmapRequester::PrepareForDecoding(void)\n{\n#if ACCUSOFT_CODE\n  UBYTE i;\n  BuildCommon();\n  if (m_ppDecodingMCU == NULL) {\n    m_ppDecodingMCU = (struct Line **)m_pEnviron->AllocMem(sizeof(struct Line *) * m_ucCount*8);\n    memset(m_ppDecodingMCU,0,sizeof(struct Line *) * m_ucCount * 8);\n  }\n  if (m_ppUpsampler == NULL) {\n    m_ppUpsampler = (class UpsamplerBase **)m_pEnviron->AllocMem(sizeof(class UpsamplerBase *) * m_ucCount);\n    memset(m_ppUpsampler,0,sizeof(class Upsampler *) * m_ucCount);\n    for(i = 0;i < m_ucCount;i++) {\n      class Component *comp = m_pFrame->ComponentOf(i);\n      UBYTE sx = comp->SubXOf();\n      UBYTE sy = comp->SubYOf();\n      if (m_pLargestScale) {\n        class Frame *frame = m_pLargestScale->FrameOf();\n        while(frame) {\n          if (frame->ComponentOf(i)->SubXOf() != sx || frame->ComponentOf(i)->SubYOf() != sy)\n            JPG_THROW(MALFORMED_STREAM,\"HierarchicalBitmapRequester::PrepareForDecoding\",\n                      \"component subsampling is inconsistent across hierarchical levels\");\n          frame = frame->NextOf();\n        }\n      }\n      if (sx > 1 || sy > 1) {\n        m_ppUpsampler[i] = UpsamplerBase::CreateUpsampler(m_pEnviron,sx,sy,\n                                                          m_ulPixelWidth,m_ulPixelHeight,\n                                                          m_pFrame->TablesOf()->isChromaCentered());\n        m_bSubsampling   = true;\n      }\n    }\n  }\n  if (m_pLargestScale)\n    m_pLargestScale->PrepareForDecoding();\n#endif\n}", "target": 0}
{"code": "static int _kvm_get_dr(struct kvm_vcpu *vcpu, int dr, unsigned long *val)\n{\n\tswitch (dr) {\n\tcase 0 ... 3:\n\t\t*val = vcpu->arch.db[dr];\n\t\tbreak;\n\tcase 4:\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_DE))\n\t\t\treturn 1;\n\tcase 6:\n\t\t*val = vcpu->arch.dr6;\n\t\tbreak;\n\tcase 5:\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_DE))\n\t\t\treturn 1;\n\tdefault: \n\t\t*val = vcpu->arch.dr7;\n\t\tbreak;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "juniper_pppoe_atm_print(netdissect_options *ndo,\n                        const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n\tuint16_t extracted_ethertype;\n        l2info.pictype = DLT_JUNIPER_PPPOE_ATM;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n        p+=l2info.header_len;\n        ND_TCHECK2(p[0], 2);\n        extracted_ethertype = EXTRACT_16BITS(p);\n        if (ethertype_print(ndo, extracted_ethertype,\n                              p+ETHERTYPE_LEN,\n                              l2info.length-ETHERTYPE_LEN,\n                              l2info.caplen-ETHERTYPE_LEN,\n                              NULL, NULL) == 0)\n            ND_PRINT((ndo, \"unknown ethertype 0x%04x\", extracted_ethertype));\n        return l2info.header_len;\ntrunc:\n\tND_PRINT((ndo, \"[|juniper_pppoe_atm]\"));\n\treturn l2info.header_len;\n}", "target": 0}
{"code": "std::wstring Utf8To16(const std::string& utf8_string) {\n  return MB2WC(utf8_string, CP_UTF8);\n}", "target": 0}
{"code": "doc_data_init(struct doc_data *data)\n{\n\tdata->hash = NULL;\n\tdata->hash_len = 0;\n\tdata->uri = NULL;\n}", "target": 1}
{"code": "rfbReleaseClientIterator(rfbClientIteratorPtr iterator)\n{\n  if(iterator->next) rfbDecrClientRef(iterator->next);\n  free(iterator);\n}", "target": 1}
{"code": "WM_SYMBOL midi *WildMidi_OpenBuffer(uint8_t *midibuffer, uint32_t size) {\n    uint8_t mus_hdr[] = { 'M', 'U', 'S', 0x1A };\n    uint8_t xmi_hdr[] = { 'F', 'O', 'R', 'M' };\n    midi * ret = NULL;\n    if (!WM_Initialized) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_INIT, NULL, 0);\n        return (NULL);\n    }\n    if (midibuffer == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(NULL midi data buffer)\", 0);\n        return (NULL);\n    }\n    if (size > WM_MAXFILESIZE) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_LONGFIL, NULL, 0);\n        return (NULL);\n    }\n    if (size < 18) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(too short)\", 0);\n        return (NULL);\n    }\n    if (memcmp(midibuffer,\"HMIMIDIP\", 8) == 0) {\n        ret = (void *) _WM_ParseNewHmp(midibuffer, size);\n    } else if (memcmp(midibuffer, \"HMI-MIDISONG061595\", 18) == 0) {\n        ret = (void *) _WM_ParseNewHmi(midibuffer, size);\n    } else if (memcmp(midibuffer, mus_hdr, 4) == 0) {\n        ret = (void *) _WM_ParseNewMus(midibuffer, size);\n    } else if (memcmp(midibuffer, xmi_hdr, 4) == 0) {\n        ret = (void *) _WM_ParseNewXmi(midibuffer, size);\n    } else {\n        ret = (void *) _WM_ParseNewMidi(midibuffer, size);\n    }\n    if (ret) {\n        if (add_handle(ret) != 0) {\n            WildMidi_Close(ret);\n            ret = NULL;\n        }\n    }\n    return (ret);\n}", "target": 0}
{"code": "int64_t BZ2File::readImpl(char * buf, int64_t length) {\n  if (length == 0) {\n    return 0;\n  }\n  assertx(m_bzFile);\n  int len = BZ2_bzread(m_bzFile, buf, length);\n  if (len <= 0) {\n    setEof(true);\n    if (len < 0) {\n      return -1;\n    }\n  }\n  return len;\n}", "target": 1}
{"code": "bool hostuid_to_ns(uid_t uid, pid_t pid, uid_t *answer)\n{\n\tFILE *f;\n\tchar line[400];\n\tsprintf(line, \"/proc/%d/uid_map\", pid);\n\tif ((f = fopen(line, \"r\")) == NULL) {\n\t\treturn false;\n\t}\n\t*answer = convert_id_to_ns(f, uid);\n\tfclose(f);\n\tif (*answer == -1)\n\t\treturn false;\n\treturn true;\n}", "target": 0}
{"code": "static int llcp_raw_sock_bind(struct socket *sock, struct sockaddr *addr,\n\t\t\t      int alen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tstruct nfc_llcp_local *local;\n\tstruct nfc_dev *dev;\n\tstruct sockaddr_nfc_llcp llcp_addr;\n\tint len, ret = 0;\n\tif (!addr || alen < offsetofend(struct sockaddr, sa_family) ||\n\t    addr->sa_family != AF_NFC)\n\t\treturn -EINVAL;\n\tpr_debug(\"sk %p addr %p family %d\\n\", sk, addr, addr->sa_family);\n\tmemset(&llcp_addr, 0, sizeof(llcp_addr));\n\tlen = min_t(unsigned int, sizeof(llcp_addr), alen);\n\tmemcpy(&llcp_addr, addr, len);\n\tlock_sock(sk);\n\tif (sk->sk_state != LLCP_CLOSED) {\n\t\tret = -EBADFD;\n\t\tgoto error;\n\t}\n\tdev = nfc_get_device(llcp_addr.dev_idx);\n\tif (dev == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto error;\n\t}\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto put_dev;\n\t}\n\tllcp_sock->dev = dev;\n\tllcp_sock->local = nfc_llcp_local_get(local);\n\tllcp_sock->nfc_protocol = llcp_addr.nfc_protocol;\n\tnfc_llcp_sock_link(&local->raw_sockets, sk);\n\tsk->sk_state = LLCP_BOUND;\nput_dev:\n\tnfc_put_device(dev);\nerror:\n\trelease_sock(sk);\n\treturn ret;\n}", "target": 1}
{"code": "agoo_con_create(agooErr err, int sock, uint64_t id, agooBind b) {\n    agooCon\tc;\n    if (NULL == (c = (agooCon)AGOO_CALLOC(1, sizeof(struct _agooCon)))) {\n\tAGOO_ERR_MEM(err, \"Connection\");\n    } else {\n\tstruct sockaddr_storage\taddr;\n\tsocklen_t\t\tlen = sizeof(addr);\n\tgetpeername(sock, (struct sockaddr*)&addr, &len);\n\tif (addr.ss_family == AF_INET) {\n\t    struct sockaddr_in\t*s = (struct sockaddr_in*)&addr;\n\t    inet_ntop(AF_INET, &s->sin_addr, c->remote, sizeof(c->remote));\n\t} else {\n\t    struct sockaddr_in6\t*s = (struct sockaddr_in6*)&addr;\n\t    inet_ntop(AF_INET6, &s->sin6_addr, c->remote, sizeof(c->remote));\n\t}\n\tc->sock = sock;\n\tc->id = id;\n\tc->timeout = dtime() + CON_TIMEOUT;\n\tc->bind = b;\n\tc->loop = NULL;\n\tpthread_mutex_init(&c->res_lock, 0);\n    }\n    return c;\n}", "target": 0}
{"code": "static void cleanup_shm_refs(const uint64_t *saved_attr,\n\t\t\t     struct tee_ta_param *param, uint32_t num_params)\n{\n\tsize_t n;\n\tfor (n = 0; n < num_params; n++) {\n\t\tswitch (saved_attr[n]) {\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_INPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_INOUT:\n#ifdef CFG_CORE_DYN_SHM\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_INPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_OUTPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_INOUT:\n#endif\n\t\t\tmobj_put(param->u[n].mem.mobj);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}", "target": 1}
{"code": "static inline long div_long_long_rem_signed(const long long dividend,\n\t\t\t\t\t    const long divisor, long *remainder)\n{\n\tlong res;\n\tif (unlikely(dividend < 0)) {\n\t\tres = -div_long_long_rem(-dividend, divisor, remainder);\n\t\t*remainder = -(*remainder);\n\t} else\n\t\tres = div_long_long_rem(dividend, divisor, remainder);\n\treturn res;\n}", "target": 1}
{"code": "juniper_monitor_print(netdissect_options *ndo,\n                      const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n        struct juniper_monitor_header {\n            uint8_t pkt_type;\n            uint8_t padding;\n            uint8_t iif[2];\n            uint8_t service_id[4];\n        };\n        const struct juniper_monitor_header *mh;\n        l2info.pictype = DLT_JUNIPER_MONITOR;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n        p+=l2info.header_len;\n        mh = (const struct juniper_monitor_header *)p;\n        ND_TCHECK(*mh);\n        if (ndo->ndo_eflag)\n            ND_PRINT((ndo, \"service-id %u, iif %u, pkt-type %u: \",\n                   EXTRACT_32BITS(&mh->service_id),\n                   EXTRACT_16BITS(&mh->iif),\n                   mh->pkt_type));\n        ip_heuristic_guess (ndo, p, l2info.length);\n        return l2info.header_len;\ntrunc:\n\tND_PRINT((ndo, \"[|juniper_services]\"));\n\treturn l2info.header_len;\n}", "target": 0}
{"code": "static ssize_t ib_ucm_write(struct file *filp, const char __user *buf,\n\t\t\t    size_t len, loff_t *pos)\n{\n\tstruct ib_ucm_file *file = filp->private_data;\n\tstruct ib_ucm_cmd_hdr hdr;\n\tssize_t result;\n\tif (WARN_ON_ONCE(!ib_safe_file_access(filp)))\n\t\treturn -EACCES;\n\tif (len < sizeof(hdr))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&hdr, buf, sizeof(hdr)))\n\t\treturn -EFAULT;\n\tif (hdr.cmd >= ARRAY_SIZE(ucm_cmd_table))\n\t\treturn -EINVAL;\n\tif (hdr.in + sizeof(hdr) > len)\n\t\treturn -EINVAL;\n\tresult = ucm_cmd_table[hdr.cmd](file, buf + sizeof(hdr),\n\t\t\t\t\thdr.in, hdr.out);\n\tif (!result)\n\t\tresult = len;\n\treturn result;\n}", "target": 0}
{"code": "static int einj_error_inject(u32 type, u32 flags, u64 param1, u64 param2,\n\t\t\t     u64 param3, u64 param4)\n{\n\tint rc;\n\tu64 base_addr, size;\n\tif (get_securelevel() > 0)\n\t\treturn -EPERM;\n\tif (flags && (flags &\n\t\t~(SETWA_FLAGS_APICID|SETWA_FLAGS_MEM|SETWA_FLAGS_PCIE_SBDF)))\n\t\treturn -EINVAL;\n\tif (!(param_extension || acpi5))\n\t\tgoto inject;\n\tif (type & ACPI5_VENDOR_BIT) {\n\t\tif (vendor_flags != SETWA_FLAGS_MEM)\n\t\t\tgoto inject;\n\t} else if (!(type & MEM_ERROR_MASK) && !(flags & SETWA_FLAGS_MEM))\n\t\tgoto inject;\n\tbase_addr = param1 & param2;\n\tsize = ~param2 + 1;\n\tif (((param2 & PAGE_MASK) != PAGE_MASK) ||\n\t    ((region_intersects(base_addr, size, IORESOURCE_SYSTEM_RAM, IORES_DESC_NONE)\n\t\t\t\t!= REGION_INTERSECTS) &&\n\t     (region_intersects(base_addr, size, IORESOURCE_MEM, IORES_DESC_PERSISTENT_MEMORY)\n\t\t\t\t!= REGION_INTERSECTS)))\n\t\treturn -EINVAL;\ninject:\n\tmutex_lock(&einj_mutex);\n\trc = __einj_error_inject(type, flags, param1, param2, param3, param4);\n\tmutex_unlock(&einj_mutex);\n\treturn rc;\n}", "target": 0}
{"code": "static void csi_K(struct vc_data *vc, int vpar)\n{\n\tunsigned int count;\n\tunsigned short *start = (unsigned short *)vc->vc_pos;\n\tint offset;\n\tswitch (vpar) {\n\t\tcase 0:\t\n\t\t\toffset = 0;\n\t\t\tcount = vc->vc_cols - vc->vc_x;\n\t\t\tbreak;\n\t\tcase 1:\t\n\t\t\toffset = -vc->vc_x;\n\t\t\tcount = vc->vc_x + 1;\n\t\t\tbreak;\n\t\tcase 2: \n\t\t\toffset = -vc->vc_x;\n\t\t\tcount = vc->vc_cols;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t}\n\tvc_uniscr_clear_line(vc, vc->vc_x + offset, count);\n\tscr_memsetw(start + offset, vc->vc_video_erase_char, 2 * count);\n\tvc->vc_need_wrap = 0;\n\tif (con_should_update(vc))\n\t\tdo_update_region(vc, (unsigned long)(start + offset), count);\n}", "target": 0}
{"code": "static int em_ret_far(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tunsigned long eip, cs;\n\tu16 old_cs;\n\tint cpl = ctxt->ops->cpl(ctxt);\n\tstruct desc_struct old_desc, new_desc;\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tops->get_segment(ctxt, &old_cs, &old_desc, NULL,\n\t\t\t\t VCPU_SREG_CS);\n\trc = emulate_pop(ctxt, &eip, ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = emulate_pop(ctxt, &cs, ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tif (ctxt->mode >= X86EMUL_MODE_PROT16 && (cs & 3) > cpl)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\trc = __load_segment_descriptor(ctxt, (u16)cs, VCPU_SREG_CS, cpl,\n\t\t\t\t       X86_TRANSFER_RET,\n\t\t\t\t       &new_desc);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = assign_eip_far(ctxt, eip, &new_desc);\n\tif (rc != X86EMUL_CONTINUE) {\n\t\tWARN_ON(ctxt->mode != X86EMUL_MODE_PROT64);\n\t\tops->set_segment(ctxt, old_cs, &old_desc, 0, VCPU_SREG_CS);\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  const CTCBeamSearchDecoderParams* option =\n      reinterpret_cast<CTCBeamSearchDecoderParams*>(node->user_data);\n  const int top_paths = option->top_paths;\n  TF_LITE_ENSURE(context, option->beam_width >= top_paths);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 3 * top_paths + 1);\n  const TfLiteTensor* inputs = GetInput(context, node, kInputsTensor);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(inputs), 3);\n  TF_LITE_ENSURE_EQ(context, inputs->type, kTfLiteFloat32);\n  const int batch_size = SizeOfDimension(inputs, 1);\n  const TfLiteTensor* sequence_length =\n      GetInput(context, node, kSequenceLengthTensor);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(sequence_length), 1);\n  TF_LITE_ENSURE_EQ(context, NumElements(sequence_length), batch_size);\n  TF_LITE_ENSURE_EQ(context, sequence_length->type, kTfLiteInt32);\n  for (int i = 0; i < top_paths; ++i) {\n    TfLiteTensor* indices = GetOutput(context, node, i);\n    SetTensorToDynamic(indices);\n    TfLiteTensor* values = GetOutput(context, node, i + top_paths);\n    SetTensorToDynamic(values);\n    TfLiteTensor* output_shape = GetOutput(context, node, i + 2 * top_paths);\n    SetTensorToDynamic(output_shape);\n  }\n  TfLiteTensor* log_probability_output =\n      GetOutput(context, node, top_paths * 3);\n  TfLiteIntArray* log_probability_output_shape_array = TfLiteIntArrayCreate(2);\n  log_probability_output_shape_array->data[0] = batch_size;\n  log_probability_output_shape_array->data[1] = top_paths;\n  return context->ResizeTensor(context, log_probability_output,\n                               log_probability_output_shape_array);\n}", "target": 1}
{"code": "Status ArrayFromMemory(int dim_size, npy_intp* dims, void* data, DataType dtype,\n                       std::function<void()> destructor, PyObject** result) {\n  if (dtype == DT_STRING || dtype == DT_RESOURCE) {\n    return errors::FailedPrecondition(\n        \"Cannot convert string or resource Tensors.\");\n  }\n  int type_num = -1;\n  Status s =\n      TF_DataType_to_PyArray_TYPE(static_cast<TF_DataType>(dtype), &type_num);\n  if (!s.ok()) {\n    return s;\n  }\n  if (dim_size > NPY_MAXDIMS) {\n    return errors::InvalidArgument(\n        \"Cannot convert tensor with \", dim_size,\n        \" dimensions to NumPy array. NumPy arrays can have at most \",\n        NPY_MAXDIMS, \" dimensions\");\n  }\n  auto* np_array = reinterpret_cast<PyArrayObject*>(\n      PyArray_SimpleNewFromData(dim_size, dims, type_num, data));\n  if (np_array == nullptr) {\n    string shape_str = absl::StrJoin(\n        absl::Span<npy_intp>{dims, static_cast<size_t>(dim_size)}, \", \");\n    if (PyErr_Occurred()) {\n      string exception_str = PyExceptionFetch();\n      PyErr_Clear();\n      return errors::InvalidArgument(\n          \"Failed to create numpy array from tensor of shape [\", shape_str,\n          \"]. Numpy error: \", exception_str);\n    }\n    return errors::Internal(\n        \"Failed to create numpy array from tensor of shape [\", shape_str, \"]\");\n  }\n  PyArray_CLEARFLAGS(np_array, NPY_ARRAY_OWNDATA);\n  if (PyType_Ready(&TensorReleaserType) == -1) {\n    return errors::Unknown(\"Python type initialization failed.\");\n  }\n  auto* releaser = reinterpret_cast<TensorReleaser*>(\n      TensorReleaserType.tp_alloc(&TensorReleaserType, 0));\n  releaser->destructor = new std::function<void()>(std::move(destructor));\n  if (PyArray_SetBaseObject(np_array, reinterpret_cast<PyObject*>(releaser)) ==\n      -1) {\n    Py_DECREF(releaser);\n    return errors::Unknown(\"Python array refused to use memory.\");\n  }\n  *result = reinterpret_cast<PyObject*>(np_array);\n  return OkStatus();\n}", "target": 0}
{"code": "static int vapic_enter(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tstruct page *page;\n\tif (!apic || !apic->vapic_addr)\n\t\treturn 0;\n\tpage = gfn_to_page(vcpu->kvm, apic->vapic_addr >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\treturn -EFAULT;\n\tvcpu->arch.apic->vapic_page = page;\n\treturn 0;\n}", "target": 1}
{"code": "static int m88rs2000_frontend_attach(struct dvb_usb_adapter *d)\n{\n\tu8 obuf[] = { 0x51 };\n\tu8 ibuf[] = { 0 };\n\tif (dvb_usb_generic_rw(d->dev, obuf, 1, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x51 transfer failed.\");\n\td->fe_adap[0].fe = dvb_attach(m88rs2000_attach, &s421_m88rs2000_config,\n\t\t\t\t\t&d->dev->i2c_adap);\n\tif (d->fe_adap[0].fe == NULL)\n\t\treturn -EIO;\n\tif (dvb_attach(ts2020_attach, d->fe_adap[0].fe,\n\t\t\t\t&dw2104_ts2020_config,\n\t\t\t\t&d->dev->i2c_adap)) {\n\t\tinfo(\"Attached RS2000/TS2020!\");\n\t\treturn 0;\n\t}\n\tinfo(\"Failed to attach RS2000/TS2020!\");\n\treturn -EIO;\n}", "target": 1}
{"code": "void inet_sock_destruct(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\t__skb_queue_purge(&sk->sk_receive_queue);\n\t__skb_queue_purge(&sk->sk_error_queue);\n\tsk_mem_reclaim(sk);\n\tif (sk->sk_type == SOCK_STREAM && sk->sk_state != TCP_CLOSE) {\n\t\tpr_err(\"Attempt to release TCP socket in state %d %p\\n\",\n\t\t       sk->sk_state, sk);\n\t\treturn;\n\t}\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tpr_err(\"Attempt to release alive inet socket %p\\n\", sk);\n\t\treturn;\n\t}\n\tWARN_ON(atomic_read(&sk->sk_rmem_alloc));\n\tWARN_ON(atomic_read(&sk->sk_wmem_alloc));\n\tWARN_ON(sk->sk_wmem_queued);\n\tWARN_ON(sk->sk_forward_alloc);\n\tkfree(inet->opt);\n\tdst_release(rcu_dereference_check(sk->sk_dst_cache, 1));\n\tsk_refcnt_debug_dec(sk);\n}", "target": 1}
{"code": "static int flakey_ioctl(struct dm_target *ti, unsigned int cmd, unsigned long arg)\n{\n\tstruct flakey_c *fc = ti->private;\n\treturn __blkdev_driver_ioctl(fc->dev->bdev, fc->dev->mode, cmd, arg);\n}", "target": 1}
{"code": "void gf_isom_check_position(GF_Box *s, GF_Box *child, u32 *pos)\n{\n\tif (!s || !s->child_boxes || !child || !pos) return;\n\tif (s->internal_flags & GF_ISOM_ORDER_FREEZE)\n\t\treturn;\n\ts32 cur_pos = gf_list_find(s->child_boxes, child);\n\tif (cur_pos < 0) return;\n\tif (cur_pos != (s32) *pos) {\n\t\tgf_list_del_item(s->child_boxes, child);\n\t\tgf_list_insert(s->child_boxes, child, *pos);\n\t}\n\t(*pos)++;", "target": 1}
{"code": "int for_each_problem_in_dir(const char *path,\n                        uid_t caller_uid,\n                        int (*callback)(struct dump_dir *dd, void *arg),\n                        void *arg)\n{\n    DIR *dp = opendir(path);\n    if (!dp)\n    {\n        return 0;\n    }\n    int brk = 0;\n    struct dirent *dent;\n    while ((dent = readdir(dp)) != NULL)\n    {\n        if (dot_or_dotdot(dent->d_name))\n            continue; \n        char *full_name = concat_path_file(path, dent->d_name);\n        if (caller_uid == -1 || dump_dir_accessible_by_uid(full_name, caller_uid))\n        {\n            int sv_logmode = logmode;\n            logmode = 0;\n            struct dump_dir *dd = dd_opendir(full_name, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES | DD_DONT_WAIT_FOR_LOCK);\n            logmode = sv_logmode;\n            if (dd)\n            {\n                brk = callback ? callback(dd, arg) : 0;\n                dd_close(dd);\n            }\n        }\n        free(full_name);\n        if (brk)\n            break;\n    }\n    closedir(dp);\n    return brk;\n}", "target": 1}
{"code": "static int xen_netbk_get_extras(struct xenvif *vif,\n\t\t\t\tstruct xen_netif_extra_info *extras,\n\t\t\t\tint work_to_do)\n{\n\tstruct xen_netif_extra_info extra;\n\tRING_IDX cons = vif->tx.req_cons;\n\tdo {\n\t\tif (unlikely(work_to_do-- <= 0)) {\n\t\t\tnetdev_dbg(vif->dev, \"Missing extra info\\n\");\n\t\t\treturn -EBADR;\n\t\t}\n\t\tmemcpy(&extra, RING_GET_REQUEST(&vif->tx, cons),\n\t\t       sizeof(extra));\n\t\tif (unlikely(!extra.type ||\n\t\t\t     extra.type >= XEN_NETIF_EXTRA_TYPE_MAX)) {\n\t\t\tvif->tx.req_cons = ++cons;\n\t\t\tnetdev_dbg(vif->dev,\n\t\t\t\t   \"Invalid extra type: %d\\n\", extra.type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmemcpy(&extras[extra.type - 1], &extra, sizeof(extra));\n\t\tvif->tx.req_cons = ++cons;\n\t} while (extra.flags & XEN_NETIF_EXTRA_FLAG_MORE);\n\treturn work_to_do;\n}", "target": 1}
{"code": "static void my_error_exit( j_common_ptr cinfo ) {\n   my_error_ptr myerr = reinterpret_cast<my_error_ptr>( cinfo->err );\n   longjmp( myerr->setjmp_buffer, 1 );\n}", "target": 0}
{"code": "static int command_write(struct pci_dev *dev, int offset, u16 value, void *data)\n{\n\tstruct xen_pcibk_dev_data *dev_data;\n\tint err;\n\tu16 val;\n\tstruct pci_cmd_info *cmd = data;\n\tdev_data = pci_get_drvdata(dev);\n\tif (!pci_is_enabled(dev) && is_enable_cmd(value)) {\n\t\tif (unlikely(verbose_request))\n\t\t\tprintk(KERN_DEBUG DRV_NAME \": %s: enable\\n\",\n\t\t\t       pci_name(dev));\n\t\terr = pci_enable_device(dev);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (dev_data)\n\t\t\tdev_data->enable_intx = 1;\n\t} else if (pci_is_enabled(dev) && !is_enable_cmd(value)) {\n\t\tif (unlikely(verbose_request))\n\t\t\tprintk(KERN_DEBUG DRV_NAME \": %s: disable\\n\",\n\t\t\t       pci_name(dev));\n\t\tpci_disable_device(dev);\n\t\tif (dev_data)\n\t\t\tdev_data->enable_intx = 0;\n\t}\n\tif (!dev->is_busmaster && is_master_cmd(value)) {\n\t\tif (unlikely(verbose_request))\n\t\t\tprintk(KERN_DEBUG DRV_NAME \": %s: set bus master\\n\",\n\t\t\t       pci_name(dev));\n\t\tpci_set_master(dev);\n\t}\n\tif (value & PCI_COMMAND_INVALIDATE) {\n\t\tif (unlikely(verbose_request))\n\t\t\tprintk(KERN_DEBUG\n\t\t\t       DRV_NAME \": %s: enable memory-write-invalidate\\n\",\n\t\t\t       pci_name(dev));\n\t\terr = pci_set_mwi(dev);\n\t\tif (err) {\n\t\t\tpr_warn(\"%s: cannot enable memory-write-invalidate (%d)\\n\",\n\t\t\t\tpci_name(dev), err);\n\t\t\tvalue &= ~PCI_COMMAND_INVALIDATE;\n\t\t}\n\t}\n\tcmd->val = value;\n\tif (!permissive && (!dev_data || !dev_data->permissive))\n\t\treturn 0;\n\terr = pci_read_config_word(dev, offset, &val);\n\tif (err || val == value)\n\t\treturn err;\n\tvalue &= PCI_COMMAND_GUEST;\n\tvalue |= val & ~PCI_COMMAND_GUEST;\n\treturn pci_write_config_word(dev, offset, value);\n}", "target": 0}
{"code": "static int expandRegular(rpmfi fi, const char *dest, rpmpsm psm, int nodigest, int nocontent)\n{\n    FD_t wfd = NULL;\n    int rc = 0;\n    {\n\tmode_t old_umask = umask(0577);\n\twfd = Fopen(dest, \"w.ufdio\");\n\tumask(old_umask);\n    }\n    if (Ferror(wfd)) {\n\trc = RPMERR_OPEN_FAILED;\n\tgoto exit;\n    }\n    if (!nocontent)\n\trc = rpmfiArchiveReadToFilePsm(fi, wfd, nodigest, psm);\nexit:\n    if (wfd) {\n\tint myerrno = errno;\n\tFclose(wfd);\n\terrno = myerrno;\n    }\n    return rc;\n}", "target": 1}
{"code": "    inline PluginEndpointSecurityAttributesMask mask() const\n    {\n        PluginEndpointSecurityAttributesMask rv = PLUGIN_ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_VALID;\n        if (is_submessage_encrypted) rv |= PLUGIN_ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_SUBMESSAGE_ENCRYPTED;\n        if (is_submessage_origin_authenticated) rv |= PLUGIN_ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_SUBMESSAGE_ORIGIN_AUTHENTICATED;\n        if (is_payload_encrypted) rv |= PLUGIN_ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_PAYLOAD_ENCRYPTED;\n        return rv;\n    }", "target": 1}
{"code": "static EctEnhancedCT *create()\n{\n    IODEnhGeneralEquipmentModule::EquipmentInfo eq(\"Open Connections\", \"OC CT\", \"4711\", \"0.1\");\n    EctEnhancedCT *ct = NULL;\n    OFCondition result;\n    result = EctEnhancedCT::create(ct,\n                                   NUM_ROWS,\n                                   NUM_COLS,\n                                   OFFalse,\n                                   EctTypes::E_ImageType1_Original,\n                                   EctTypes::DT_ImageType3_Volume,\n                                   EctTypes::DT_ImageType4_Maximum,\n                                   \"1\" ,\n                                   EctTypes::E_ContQuali_Research,\n                                   EctTypes::E_PixelPres_Monochrome,\n                                   EctTypes::E_VolProps_Volume,\n                                   EctTypes::DT_VolBasedCalcTechnique_VolumeRender,\n                                   eq,\n                                   \"20190801120000\" ,\n                                   2.0 );\n    OFCHECK(result.good());\n    OFCHECK(ct != OFnullptr);\n    return ct;\n}", "target": 0}
{"code": "static bool checkCurl() {\n\tconst char nul[] = R_SYS_DEVNULL;\n\tif (r_sys_cmdf (\"curl --version > %s\", nul) != 0) {\n\t\treturn false;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "static int __init mbochs_dev_init(void)\n{\n\tint ret = 0;\n\tatomic_set(&mbochs_avail_mbytes, max_mbytes);\n\tret = alloc_chrdev_region(&mbochs_devt, 0, MINORMASK + 1, MBOCHS_NAME);\n\tif (ret < 0) {\n\t\tpr_err(\"Error: failed to register mbochs_dev, err: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tcdev_init(&mbochs_cdev, &vd_fops);\n\tcdev_add(&mbochs_cdev, mbochs_devt, MINORMASK + 1);\n\tpr_info(\"%s: major %d\\n\", __func__, MAJOR(mbochs_devt));\n\tret = mdev_register_driver(&mbochs_driver);\n\tif (ret)\n\t\tgoto err_cdev;\n\tmbochs_class = class_create(THIS_MODULE, MBOCHS_CLASS_NAME);\n\tif (IS_ERR(mbochs_class)) {\n\t\tpr_err(\"Error: failed to register mbochs_dev class\\n\");\n\t\tret = PTR_ERR(mbochs_class);\n\t\tgoto err_driver;\n\t}\n\tmbochs_dev.class = mbochs_class;\n\tmbochs_dev.release = mbochs_device_release;\n\tdev_set_name(&mbochs_dev, \"%s\", MBOCHS_NAME);\n\tret = device_register(&mbochs_dev);\n\tif (ret)\n\t\tgoto err_class;\n\tret = mdev_register_device(&mbochs_dev, &mdev_fops);\n\tif (ret)\n\t\tgoto err_device;\n\treturn 0;\nerr_device:\n\tdevice_unregister(&mbochs_dev);\nerr_class:\n\tclass_destroy(mbochs_class);\nerr_driver:\n\tmdev_unregister_driver(&mbochs_driver);\nerr_cdev:\n\tcdev_del(&mbochs_cdev);\n\tunregister_chrdev_region(mbochs_devt, MINORMASK + 1);\n\treturn ret;\n}", "target": 0}
{"code": "char *LibRaw_buffer_datastream::gets(char *s, int sz)\n{\n  if(sz<1) return NULL;\n  unsigned char *psrc, *pdest, *str;\n  str = (unsigned char *)s;\n  psrc = buf + streampos;\n  pdest = str;\n  if(streampos >= streamsize) return NULL;\n  while ((size_t(psrc - buf) < streamsize) && ((pdest - str) < (sz-1)))\n  {\n    *pdest = *psrc;\n    if (*psrc == '\\n')\n      break;\n    psrc++;\n    pdest++;\n  }\n  if (size_t(psrc - buf) < streamsize)\n    psrc++;\n  if ((pdest - str) < sz-1)\n    *(++pdest) = 0;\n  else\n    s[sz - 1] = 0; \n  streampos = psrc - buf;\n  return s;\n}", "target": 0}
{"code": "set_ssl_ciphers(SCHANNEL_CRED *schannel_cred, char *ciphers,\n                ALG_ID *algIds)\n{\n  char *startCur = ciphers;\n  int algCount = 0;\n  while(startCur && (0 != *startCur) && (algCount < NUMOF_CIPHERS)) {\n    long alg = strtol(startCur, 0, 0);\n    if(!alg)\n      alg = get_alg_id_by_name(startCur);\n    if(alg)\n      algIds[algCount++] = alg;\n    else if(!strncmp(startCur, \"USE_STRONG_CRYPTO\",\n                     sizeof(\"USE_STRONG_CRYPTO\") - 1) ||\n            !strncmp(startCur, \"SCH_USE_STRONG_CRYPTO\",\n                     sizeof(\"SCH_USE_STRONG_CRYPTO\") - 1))\n      schannel_cred->dwFlags |= SCH_USE_STRONG_CRYPTO;\n    else\n      return CURLE_SSL_CIPHER;\n    startCur = strchr(startCur, ':');\n    if(startCur)\n      startCur++;\n  }\n  schannel_cred->palgSupportedAlgs = algIds;\n  schannel_cred->cSupportedAlgs = algCount;\n  return CURLE_OK;\n}", "target": 0}
{"code": "static int tiocgetd(struct tty_struct *tty, int __user *p)\n{\n\tstruct tty_ldisc *ld;\n\tint ret;\n\tld = tty_ldisc_ref_wait(tty);\n\tret = put_user(ld->ops->num, p);\n\ttty_ldisc_deref(ld);\n\treturn ret;\n}", "target": 0}
{"code": "  static void launch(OpKernelContext* context, bool cudnn_use_autotune,\n                     const Tensor& input, const Tensor& filter,\n                     const std::array<int64, 3>& dilations,\n                     const std::array<int64, 3>& strides, const Padding padding,\n                     TensorFormat data_format, Tensor* output) {\n    OP_REQUIRES(context, data_format == FORMAT_NHWC,\n                errors::InvalidArgument(\"CPU implementation of Conv3D \"\n                                        \"currently only supports the NHWC \"\n                                        \"tensor format.\"));\n    OP_REQUIRES(context,\n                dilations[0] == 1 && dilations[1] == 1 && dilations[2] == 1,\n                errors::InvalidArgument(\"CPU implementation of Conv3D \"\n                                        \"currently only supports dilated rates \"\n                                        \"of 1.\"));\n    OP_REQUIRES(context, filter.dim_size(3) == input.dim_size(input.dims() - 1),\n                errors::InvalidArgument(\n                    \"Number of channels in filter (\", filter.dim_size(3),\n                    \") must match last dimension of input (\",\n                    input.dim_size(input.dims() - 1), \")\"));\n    functor::CuboidConvolution<CPUDevice, T>()(\n        context->eigen_device<CPUDevice>(), output->tensor<T, 5>(),\n        input.tensor<T, 5>(), filter.tensor<T, 5>(), strides[2], strides[1],\n        strides[0], BrainPadding2EigenPadding(padding));\n  }", "target": 0}
{"code": "int Dispatcher::getparam( size_t N, int defaultval )\n{\n  int ret = defaultval;\n  if ( !parsed ) {\n    parse_params();\n  }\n  if ( parsed_params.size() > N ) {\n    ret = parsed_params[ N ];\n  }\n  if ( ret > PARAM_MAX ) {\n    ret = defaultval;\n  }\n  if ( ret < 1 ) ret = defaultval;\n  return ret;\n}", "target": 0}
{"code": "static int em_sysexit(struct x86_emulate_ctxt *ctxt)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct cs, ss;\n\tu64 msr_data;\n\tint usermode;\n\tu16 cs_sel = 0, ss_sel = 0;\n\tif (ctxt->mode == X86EMUL_MODE_REAL ||\n\t    ctxt->mode == X86EMUL_MODE_VM86)\n\t\treturn emulate_gp(ctxt, 0);\n\tsetup_syscalls_segments(ctxt, &cs, &ss);\n\tif ((ctxt->rex_prefix & 0x8) != 0x0)\n\t\tusermode = X86EMUL_MODE_PROT64;\n\telse\n\t\tusermode = X86EMUL_MODE_PROT32;\n\tcs.dpl = 3;\n\tss.dpl = 3;\n\tops->get_msr(ctxt, MSR_IA32_SYSENTER_CS, &msr_data);\n\tswitch (usermode) {\n\tcase X86EMUL_MODE_PROT32:\n\t\tcs_sel = (u16)(msr_data + 16);\n\t\tif ((msr_data & 0xfffc) == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tss_sel = (u16)(msr_data + 24);\n\t\tbreak;\n\tcase X86EMUL_MODE_PROT64:\n\t\tcs_sel = (u16)(msr_data + 32);\n\t\tif (msr_data == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tss_sel = cs_sel + 8;\n\t\tcs.d = 0;\n\t\tcs.l = 1;\n\t\tbreak;\n\t}\n\tcs_sel |= SELECTOR_RPL_MASK;\n\tss_sel |= SELECTOR_RPL_MASK;\n\tops->set_segment(ctxt, cs_sel, &cs, 0, VCPU_SREG_CS);\n\tops->set_segment(ctxt, ss_sel, &ss, 0, VCPU_SREG_SS);\n\tctxt->_eip = reg_read(ctxt, VCPU_REGS_RDX);\n\t*reg_write(ctxt, VCPU_REGS_RSP) = reg_read(ctxt, VCPU_REGS_RCX);\n\treturn X86EMUL_CONTINUE;\n}", "target": 1}
{"code": "void qemu_ram_free(struct uc_struct *uc, RAMBlock *block)\n{\n    if (!block) {\n        return;\n    }\n    QLIST_REMOVE(block, next);\n    uc->ram_list.mru_block = NULL;\n    reclaim_ramblock(uc, block);\n}", "target": 1}
{"code": "static int get_exif_tag_dbl_value(struct iw_exif_state *e, unsigned int tag_pos,\n\tdouble *pv)\n{\n\tunsigned int field_type;\n\tunsigned int value_count;\n\tunsigned int value_pos;\n\tunsigned int numer, denom;\n\tfield_type = iw_get_ui16_e(&e->d[tag_pos+2],e->endian);\n\tvalue_count = iw_get_ui32_e(&e->d[tag_pos+4],e->endian);\n\tif(value_count!=1) return 0;\n\tif(field_type!=5) return 0; \n\tvalue_pos = iw_get_ui32_e(&e->d[tag_pos+8],e->endian);\n\tif(value_pos > e->d_len-8) return 0;\n\tnumer = iw_get_ui32_e(&e->d[value_pos  ],e->endian);\n\tdenom = iw_get_ui32_e(&e->d[value_pos+4],e->endian);\n\tif(denom==0) return 0;\n\t*pv = ((double)numer)/denom;\n\treturn 1;\n}", "target": 1}
{"code": "static void bump_cpu_timer(struct k_itimer *timer, u64 now)\n{\n\tint i;\n\tu64 delta, incr;\n\tif (timer->it.cpu.incr == 0)\n\t\treturn;\n\tif (now < timer->it.cpu.expires)\n\t\treturn;\n\tincr = timer->it.cpu.incr;\n\tdelta = now + incr - timer->it.cpu.expires;\n\tfor (i = 0; incr < delta - incr; i++)\n\t\tincr = incr << 1;\n\tfor (; i >= 0; incr >>= 1, i--) {\n\t\tif (delta < incr)\n\t\t\tcontinue;\n\t\ttimer->it.cpu.expires += incr;\n\t\ttimer->it_overrun += 1 << i;\n\t\tdelta -= incr;\n\t}\n}", "target": 1}
{"code": "static int inet_sk_reselect_saddr(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\t__be32 old_saddr = inet->inet_saddr;\n\t__be32 daddr = inet->inet_daddr;\n\tstruct flowi4 fl4;\n\tstruct rtable *rt;\n\t__be32 new_saddr;\n\tif (inet->opt && inet->opt->srr)\n\t\tdaddr = inet->opt->faddr;\n\trt = ip_route_connect(&fl4, daddr, 0, RT_CONN_FLAGS(sk),\n\t\t\t      sk->sk_bound_dev_if, sk->sk_protocol,\n\t\t\t      inet->inet_sport, inet->inet_dport, sk, false);\n\tif (IS_ERR(rt))\n\t\treturn PTR_ERR(rt);\n\tsk_setup_caps(sk, &rt->dst);\n\tnew_saddr = rt->rt_src;\n\tif (new_saddr == old_saddr)\n\t\treturn 0;\n\tif (sysctl_ip_dynaddr > 1) {\n\t\tprintk(KERN_INFO \"%s(): shifting inet->saddr from %pI4 to %pI4\\n\",\n\t\t       __func__, &old_saddr, &new_saddr);\n\t}\n\tinet->inet_saddr = inet->inet_rcv_saddr = new_saddr;\n\t__sk_prot_rehash(sk);\n\treturn 0;\n}", "target": 1}
{"code": "Filter::UpstreamRequest::~UpstreamRequest() {\n  if (span_ != nullptr) {\n    Tracing::HttpTracerUtility::finalizeUpstreamSpan(*span_, upstream_headers_.get(),\n                                                     upstream_trailers_.get(), stream_info_,\n                                                     Tracing::EgressConfig::get());\n  }\n  if (per_try_timeout_ != nullptr) {\n    per_try_timeout_->disableTimer();\n  }\n  clearRequestEncoder();\n  stream_info_.setUpstreamTiming(upstream_timing_);\n  stream_info_.onRequestComplete();\n  if (upstream_headers_ != nullptr) {\n    upstream_headers_->refreshByteSize();\n  }\n  if (upstream_trailers_ != nullptr) {\n    upstream_trailers_->refreshByteSize();\n  }\n  for (const auto& upstream_log : parent_.config_.upstream_logs_) {\n    upstream_log->log(parent_.downstream_headers_, upstream_headers_.get(),\n                      upstream_trailers_.get(), stream_info_);\n  }\n}", "target": 0}
{"code": "TEST_F(QuantizeDownAndShrinkRangeTest, HandCrafted) {\n  TF_ASSERT_OK(NodeDefBuilder(\"quantize_down_and_shrink_range_op\",\n                              \"QuantizeDownAndShrinkRange\")\n                   .Input(FakeInput(DT_QINT32))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Attr(\"Tinput\", DataTypeToEnum<qint32>::v())\n                   .Attr(\"out_type\", DataTypeToEnum<quint8>::v())\n                   .Finalize(node_def()));\n  TF_ASSERT_OK(InitOp());\n  const int value_count = 3;\n  AddInputFromArray<qint32>(TensorShape({value_count}),\n                            {-(1 << 23), 0, (1 << 23)});\n  AddInputFromArray<float>(TensorShape({1}), {-256.0f});\n  AddInputFromArray<float>(TensorShape({1}), {256.0f});\n  TF_ASSERT_OK(RunOpKernel());\n  Tensor expected(allocator(), DT_QUINT8, TensorShape({value_count}));\n  test::FillValues<quint8>(&expected, {0, 128, 255});\n  test::ExpectTensorEqual<quint8>(expected, *GetOutput(0));\n  Tensor expected_min(allocator(), DT_FLOAT, TensorShape({}));\n  test::FillValues<float>(&expected_min, {-1.0f});\n  test::ExpectTensorEqual<float>(expected_min, *GetOutput(1));\n  Tensor expected_max(allocator(), DT_FLOAT, TensorShape({}));\n  test::FillValues<float>(&expected_max, {1.0f});\n  test::ExpectTensorEqual<float>(expected_max, *GetOutput(2));\n}", "target": 1}
{"code": "TEST_F(TestSPIFFEValidator, TestGetTrustBundleStore) {\n  initialize();\n  auto cert = readCertFromFile(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/extensions_cert.pem\"));\n  EXPECT_FALSE(validator().getTrustBundleStore(cert.get()));\n  cert = readCertFromFile(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/non_spiffe_san_cert.pem\"));\n  EXPECT_FALSE(validator().getTrustBundleStore(cert.get()));\n  cert = readCertFromFile(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/spiffe_san_cert.pem\"));\n  EXPECT_FALSE(validator().getTrustBundleStore(cert.get()));\n  validator().trustBundleStores().emplace(\"example.com\", X509StorePtr(X509_STORE_new()));\n  EXPECT_TRUE(validator().getTrustBundleStore(cert.get()));\n}", "target": 1}
{"code": "TEE_Result syscall_authenc_update_aad(unsigned long state,\n\t\t\tconst void *aad_data, size_t aad_data_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t) aad_data,\n\t\t\t\t\t  aad_data_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)\n\t\treturn TEE_ERROR_BAD_STATE;\n\tres = crypto_authenc_update_aad(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\taad_data, aad_data_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\treturn TEE_SUCCESS;\n}", "target": 0}
{"code": "uint32_t virtio_config_readb(VirtIODevice *vdev, uint32_t addr)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint8_t val;\n    k->get_config(vdev, vdev->config);\n    if (addr > (vdev->config_len - sizeof(val)))\n        return (uint32_t)-1;\n    val = ldub_p(vdev->config + addr);\n    return val;\n}", "target": 1}
{"code": "static int sr_write_reg(struct usbnet *dev, u8 reg, u8 value)\n{\n\treturn usbnet_write_cmd(dev, SR_WR_REGS, SR_REQ_WR_REG,\n\t\t\t\tvalue, reg, NULL, 0);\n}", "target": 0}
{"code": "static int decode_band_types(AACContext *ac, enum BandType band_type[120],\n                             int band_type_run_end[120], GetBitContext *gb,\n                             IndividualChannelStream *ics)\n{\n    int g, idx = 0;\n    const int bits = (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) ? 3 : 5;\n    for (g = 0; g < ics->num_window_groups; g++) {\n        int k = 0;\n        while (k < ics->max_sfb) {\n            uint8_t sect_end = k;\n            int sect_len_incr;\n            int sect_band_type = get_bits(gb, 4);\n            if (sect_band_type == 12) {\n                av_log(ac->avctx, AV_LOG_ERROR, \"invalid band type\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n            do {\n                sect_len_incr = get_bits(gb, bits);\n                sect_end += sect_len_incr;\n                if (get_bits_left(gb) < 0) {\n                    av_log(ac->avctx, AV_LOG_ERROR, \"decode_band_types: \"overread_err);\n                    return AVERROR_INVALIDDATA;\n                }\n                if (sect_end > ics->max_sfb) {\n                    av_log(ac->avctx, AV_LOG_ERROR,\n                           \"Number of bands (%d) exceeds limit (%d).\\n\",\n                           sect_end, ics->max_sfb);\n                    return AVERROR_INVALIDDATA;\n                }\n            } while (sect_len_incr == (1 << bits) - 1);\n            for (; k < sect_end; k++) {\n                band_type        [idx]   = sect_band_type;\n                band_type_run_end[idx++] = sect_end;\n            }\n        }\n    }\n    return 0;\n}", "target": 0}
{"code": "epass2003_hook_path(struct sc_path *path, int inc)\n{\n\tu8 fid_h = path->value[path->len - 2];\n\tu8 fid_l = path->value[path->len - 1];\n\tswitch (fid_h) {\n\tcase 0x29:\n\tcase 0x30:\n\tcase 0x31:\n\tcase 0x32:\n\tcase 0x33:\n\tcase 0x34:\n\t\tif (inc)\n\t\t\tfid_l = fid_l * FID_STEP;\n\t\telse\n\t\t\tfid_l = fid_l / FID_STEP;\n\t\tpath->value[path->len - 1] = fid_l;\n\t\treturn 1;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int raw_cmd_copyout(int cmd, void __user *param,\n\t\t\t\t  struct floppy_raw_cmd *ptr)\n{\n\tint ret;\n\twhile (ptr) {\n\t\tret = copy_to_user(param, ptr, sizeof(*ptr));\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t\tparam += sizeof(struct floppy_raw_cmd);\n\t\tif ((ptr->flags & FD_RAW_READ) && ptr->buffer_length) {\n\t\t\tif (ptr->length >= 0 &&\n\t\t\t    ptr->length <= ptr->buffer_length) {\n\t\t\t\tlong length = ptr->buffer_length - ptr->length;\n\t\t\t\tret = fd_copyout(ptr->data, ptr->kernel_data,\n\t\t\t\t\t\t length);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int AskScriptChanged() {\n    int ret;\n    char *buts[4];\n    buts[0] = _(\"_Yes\");\n    buts[1] = _(\"Yes, and don't _remind me again\");\n    buts[2] = _(\"_No\");\n    buts[3] = NULL;\n    ret = gwwv_ask( _(\"Unsaved script\"),(const char **) buts,0,2,_(\"You have an unsaved script in the Execute Script dialog. Do you intend to discard it?\"));\n    if (ret == 1) {\n        warn_script_unsaved = false;\n        SavePrefs(true);\n    }\nreturn( ret );\n}", "target": 0}
{"code": "ppp_hdlc(netdissect_options *ndo,\n         const u_char *p, int length)\n{\n\tu_int caplen = ndo->ndo_snapend - p;\n\tu_char *b, *t, c;\n\tconst u_char *s;\n\tu_int i;\n\tint proto;\n\tconst void *se;\n\tif (caplen == 0)\n\t\treturn;\n        if (length <= 0)\n                return;\n\tb = (u_char *)malloc(caplen);\n\tif (b == NULL)\n\t\treturn;\n\tfor (s = p, t = b, i = caplen; i != 0; i--) {\n\t\tc = *s++;\n\t\tif (c == 0x7d) {\n\t\t\tif (i <= 1)\n\t\t\t\tbreak;\n\t\t\ti--;\n\t\t\tc = *s++ ^ 0x20;\n\t\t}\n\t\t*t++ = c;\n\t}\n\tse = ndo->ndo_snapend;\n\tndo->ndo_snapend = t;\n\tlength = t - b;\n        if (length < 1)\n                goto trunc;\n        proto = *b; \n        switch (proto) {\n        case PPP_IP:\n\t\tip_print(ndo, b + 1, length - 1);\n\t\tgoto cleanup;\n        case PPP_IPV6:\n\t\tip6_print(ndo, b + 1, length - 1);\n\t\tgoto cleanup;\n        default: \n\t\tbreak;\n        }\n        if (length < 2)\n                goto trunc;\n        proto = EXTRACT_16BITS(b); \n        switch (proto) {\n        case (PPP_ADDRESS << 8 | PPP_CONTROL): \n            if (length < 4)\n                goto trunc;\n            proto = EXTRACT_16BITS(b+2); \n            handle_ppp(ndo, proto, b + 4, length - 4);\n            break;\n        default: \n            handle_ppp(ndo, proto, b + 2, length - 2);\n            break;\n        }\ncleanup:\n\tndo->ndo_snapend = se;\n\tfree(b);\n        return;\ntrunc:\n\tndo->ndo_snapend = se;\n\tfree(b);\n\tND_PRINT((ndo, \"[|ppp]\"));\n}", "target": 0}
{"code": "static void make_response(struct xen_blkif_ring *ring, u64 id,\n\t\t\t  unsigned short op, int st)\n{\n\tstruct blkif_response  resp;\n\tunsigned long     flags;\n\tunion blkif_back_rings *blk_rings;\n\tint notify;\n\tresp.id        = id;\n\tresp.operation = op;\n\tresp.status    = st;\n\tspin_lock_irqsave(&ring->blk_ring_lock, flags);\n\tblk_rings = &ring->blk_rings;\n\tswitch (ring->blkif->blk_protocol) {\n\tcase BLKIF_PROTOCOL_NATIVE:\n\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->native, blk_rings->native.rsp_prod_pvt),\n\t\t       &resp, sizeof(resp));\n\t\tbreak;\n\tcase BLKIF_PROTOCOL_X86_32:\n\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->x86_32, blk_rings->x86_32.rsp_prod_pvt),\n\t\t       &resp, sizeof(resp));\n\t\tbreak;\n\tcase BLKIF_PROTOCOL_X86_64:\n\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->x86_64, blk_rings->x86_64.rsp_prod_pvt),\n\t\t       &resp, sizeof(resp));\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tblk_rings->common.rsp_prod_pvt++;\n\tRING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&blk_rings->common, notify);\n\tspin_unlock_irqrestore(&ring->blk_ring_lock, flags);\n\tif (notify)\n\t\tnotify_remote_via_irq(ring->irq);\n}", "target": 1}
{"code": "int xt_check_entry_offsets(const void *base,\n\t\t\t   const char *elems,\n\t\t\t   unsigned int target_offset,\n\t\t\t   unsigned int next_offset)\n{\n\tlong size_of_base_struct = elems - (const char *)base;\n\tconst struct xt_entry_target *t;\n\tconst char *e = base;\n\tif (target_offset < size_of_base_struct)\n\t\treturn -EINVAL;\n\tif (target_offset + sizeof(*t) > next_offset)\n\t\treturn -EINVAL;\n\tt = (void *)(e + target_offset);\n\tif (t->u.target_size < sizeof(*t))\n\t\treturn -EINVAL;\n\tif (target_offset + t->u.target_size > next_offset)\n\t\treturn -EINVAL;\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) == 0 &&\n\t    target_offset + sizeof(struct xt_standard_target) != next_offset)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 0}
{"code": "static void print_value(int output, int num, const char *devname,\n\t\t\tconst char *value, const char *name, size_t valsz)\n{\n\tif (output & OUTPUT_VALUE_ONLY) {\n\t\tfputs(value, stdout);\n\t\tfputc('\\n', stdout);\n\t} else if (output & OUTPUT_UDEV_LIST) {\n\t\tprint_udev_format(name, value);\n\t} else if (output & OUTPUT_EXPORT_LIST) {\n\t\tif (num == 1 && devname)\n\t\t\tprintf(\"DEVNAME=%s\\n\", devname);\n\t\tfputs(name, stdout);\n\t\tfputs(\"=\", stdout);\n\t\tsafe_print(value, valsz, NULL);\n\t\tfputs(\"\\n\", stdout);\n\t} else {\n\t\tif (num == 1 && devname)\n\t\t\tprintf(\"%s:\", devname);\n\t\tfputs(\" \", stdout);\n\t\tfputs(name, stdout);\n\t\tfputs(\"=\\\"\", stdout);\n\t\tsafe_print(value, valsz, \"\\\"\");\n\t\tfputs(\"\\\"\", stdout);\n\t}\n}", "target": 1}
{"code": "static void frag_kfree_skb(struct netns_frags *nf, struct sk_buff *skb)\n{\n\tatomic_sub(skb->truesize, &nf->mem);\n\tkfree_skb(skb);\n}", "target": 1}
{"code": "accept_xsmp_connection (SmsConn        sms_conn,\n                        GsmXsmpServer *server,\n                        unsigned long *mask_ret,\n                        SmsCallbacks  *callbacks_ret,\n                        char         **failure_reason_ret)\n{\n        IceConn        ice_conn;\n        GsmXSMPClient *client;\n        if (server->priv->xsmp_sockets == NULL) {\n                g_debug (\"GsmXsmpServer: In shutdown, rejecting new client\");\n                *failure_reason_ret = strdup (_(\"Refusing new client connection because the session is currently being shut down\\n\"));\n                return FALSE;\n        }\n        ice_conn = SmsGetIceConnection (sms_conn);\n        client = ice_conn->context;\n        g_return_val_if_fail (client != NULL, TRUE);\n        gsm_xsmp_client_connect (client, sms_conn, mask_ret, callbacks_ret);\n        return TRUE;\n}", "target": 1}
{"code": "void headerMergeLegacySigs(Header h, Header sigh)\n{\n    HeaderIterator hi;\n    struct rpmtd_s td;\n    hi = headerInitIterator(sigh);\n    for (; headerNext(hi, &td); rpmtdFreeData(&td))\n    {\n\tswitch (td.tag) {\n\tcase RPMSIGTAG_SIZE:\n\t    td.tag = RPMTAG_SIGSIZE;\n\t    break;\n\tcase RPMSIGTAG_PGP:\n\t    td.tag = RPMTAG_SIGPGP;\n\t    break;\n\tcase RPMSIGTAG_MD5:\n\t    td.tag = RPMTAG_SIGMD5;\n\t    break;\n\tcase RPMSIGTAG_GPG:\n\t    td.tag = RPMTAG_SIGGPG;\n\t    break;\n\tcase RPMSIGTAG_PGP5:\n\t    td.tag = RPMTAG_SIGPGP5;\n\t    break;\n\tcase RPMSIGTAG_PAYLOADSIZE:\n\t    td.tag = RPMTAG_ARCHIVESIZE;\n\t    break;\n\tcase RPMSIGTAG_FILESIGNATURES:\n\t    td.tag = RPMTAG_FILESIGNATURES;\n\t    break;\n\tcase RPMSIGTAG_FILESIGNATURELENGTH:\n\t    td.tag = RPMTAG_FILESIGNATURELENGTH;\n\t    break;\n\tcase RPMSIGTAG_VERITYSIGNATURES:\n\tcase RPMSIGTAG_VERITYSIGNATUREALGO:\n\tcase RPMSIGTAG_SHA1:\n\tcase RPMSIGTAG_SHA256:\n\tcase RPMSIGTAG_DSA:\n\tcase RPMSIGTAG_RSA:\n\tdefault:\n\t    if (!(td.tag >= HEADER_SIGBASE && td.tag < HEADER_TAGBASE))\n\t\tcontinue;\n\t    break;\n\t}\n\tif (!headerIsEntry(h, td.tag)) {\n\t    switch (td.type) {\n\t    case RPM_NULL_TYPE:\n\t\tcontinue;\n\t\tbreak;\n\t    case RPM_CHAR_TYPE:\n\t    case RPM_INT8_TYPE:\n\t    case RPM_INT16_TYPE:\n\t    case RPM_INT32_TYPE:\n\t    case RPM_INT64_TYPE:\n\t\tif (td.count != 1)\n\t\t    continue;\n\t\tbreak;\n\t    case RPM_STRING_TYPE:\n\t    case RPM_STRING_ARRAY_TYPE:\n\t    case RPM_BIN_TYPE:\n\t\tif (td.count >= 16*1024)\n\t\t    continue;\n\t\tbreak;\n\t    case RPM_I18NSTRING_TYPE:\n\t\tcontinue;\n\t\tbreak;\n\t    }\n\t    (void) headerPut(h, &td, HEADERPUT_DEFAULT);\n\t}\n    }\n    headerFreeIterator(hi);\n}", "target": 1}
{"code": "Adaptation::Ecap::FirstLineRep::protocol() const\n{\n    switch (theMessage.http_ver.protocol) {\n    case AnyP::PROTO_HTTP:\n        return libecap::protocolHttp;\n    case AnyP::PROTO_HTTPS:\n        return libecap::protocolHttps;\n    case AnyP::PROTO_FTP:\n        return libecap::protocolFtp;\n    case AnyP::PROTO_GOPHER:\n        return libecap::protocolGopher;\n    case AnyP::PROTO_WAIS:\n        return libecap::protocolWais;\n    case AnyP::PROTO_WHOIS:\n        return libecap::protocolWhois;\n    case AnyP::PROTO_URN:\n        return libecap::protocolUrn;\n    case AnyP::PROTO_ICP:\n        return protocolIcp;\n#if USE_HTCP\n    case AnyP::PROTO_HTCP:\n        return protocolHtcp;\n#endif\n    case AnyP::PROTO_CACHE_OBJECT:\n        return protocolCacheObj;\n    case AnyP::PROTO_ICY:\n        return protocolIcy;\n    case AnyP::PROTO_COAP:\n    case AnyP::PROTO_COAPS: \n    case AnyP::PROTO_AUTHORITY_FORM:\n    case AnyP::PROTO_SSL:\n    case AnyP::PROTO_TLS:\n    case AnyP::PROTO_UNKNOWN:\n        return protocolUnknown; \n    case AnyP::PROTO_NONE:\n        return Name();\n    case AnyP::PROTO_MAX:\n        break; \n    }\n    Must(false); \n    return Name();\n}", "target": 1}
{"code": "static int cdrom_ioctl_media_changed(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tstruct cdrom_changer_info *info;\n\tint ret;\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_MEDIA_CHANGED\\n\");\n\tif (!CDROM_CAN(CDC_MEDIA_CHANGED))\n\t\treturn -ENOSYS;\n\tif (!CDROM_CAN(CDC_SELECT_DISC) || arg == CDSL_CURRENT)\n\t\treturn media_changed(cdi, 1);\n\tif ((unsigned int)arg >= cdi->capacity)\n\t\treturn -EINVAL;\n\tinfo = kmalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\tret = cdrom_read_mech_status(cdi, info);\n\tif (!ret)\n\t\tret = info->slots[arg].change;\n\tkfree(info);\n\treturn ret;\n}", "target": 1}
{"code": "void *js_touserdata(js_State *J, int idx, const char *tag)\n{\n\tjs_Value *v = stackidx(J, idx);\n\tif (v->type == JS_TOBJECT && v->u.object->type == JS_CUSERDATA)\n\t\tif (!strcmp(tag, v->u.object->u.user.tag))\n\t\t\treturn v->u.object->u.user.data;\n\tjs_typeerror(J, \"not a %s\", tag);\n}", "target": 0}
{"code": "static void edge_break(struct tty_struct *tty, int break_state)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\tint status;\n\tint bv = 0;\t\n\tif (break_state == -1)\n\t\tbv = 1;\t\n\tstatus = ti_do_config(edge_port, UMPC_SET_CLR_BREAK, bv);\n\tif (status)\n\t\tdev_dbg(&port->dev, \"%s - error %d sending break set/clear command.\\n\",\n\t\t\t__func__, status);\n}", "target": 0}
{"code": "static int atusb_read_reg(struct atusb *atusb, uint8_t reg)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tint ret;\n\tuint8_t value;\n\tdev_dbg(&usb_dev->dev, \"atusb: reg = 0x%x\\n\", reg);\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_REG_READ, ATUSB_REQ_FROM_DEV,\n\t\t\t\t0, reg, &value, 1, 1000);\n\treturn ret >= 0 ? value : ret;\n}", "target": 1}
{"code": "static void settings_init(void) {\n    settings.use_cas = true;\n    settings.access = 0700;\n    settings.port = 11211;\n    settings.udpport = 11211;\n    settings.inter = NULL;\n    settings.maxbytes = 64 * 1024 * 1024; \n    settings.maxconns = 1024;         \n    settings.verbose = 0;\n    settings.oldest_live = 0;\n    settings.oldest_cas = 0;          \n    settings.evict_to_free = 1;       \n    settings.socketpath = NULL;       \n    settings.factor = 1.25;\n    settings.chunk_size = 48;         \n    settings.num_threads = 4;         \n    settings.num_threads_per_udp = 0;\n    settings.prefix_delimiter = ':';\n    settings.detail_enabled = 0;\n    settings.reqs_per_event = 20;\n    settings.backlog = 1024;\n    settings.binding_protocol = negotiating_prot;\n    settings.item_size_max = 1024 * 1024; \n    settings.slab_page_size = 1024 * 1024; \n    settings.slab_chunk_size_max = settings.slab_page_size / 2;\n    settings.sasl = false;\n    settings.maxconns_fast = true;\n    settings.lru_crawler = false;\n    settings.lru_crawler_sleep = 100;\n    settings.lru_crawler_tocrawl = 0;\n    settings.lru_maintainer_thread = false;\n    settings.lru_segmented = true;\n    settings.hot_lru_pct = 20;\n    settings.warm_lru_pct = 40;\n    settings.hot_max_factor = 0.2;\n    settings.warm_max_factor = 2.0;\n    settings.inline_ascii_response = false;\n    settings.temp_lru = false;\n    settings.temporary_ttl = 61;\n    settings.idle_timeout = 0; \n    settings.hashpower_init = 0;\n    settings.slab_reassign = true;\n    settings.slab_automove = 1;\n    settings.slab_automove_ratio = 0.8;\n    settings.slab_automove_window = 30;\n    settings.shutdown_command = false;\n    settings.tail_repair_time = TAIL_REPAIR_TIME_DEFAULT;\n    settings.flush_enabled = true;\n    settings.dump_enabled = true;\n    settings.crawls_persleep = 1000;\n    settings.logger_watcher_buf_size = LOGGER_WATCHER_BUF_SIZE;\n    settings.logger_buf_size = LOGGER_BUF_SIZE;\n    settings.drop_privileges = true;\n#ifdef MEMCACHED_DEBUG\n    settings.relaxed_privileges = false;\n#endif\n}", "target": 1}
{"code": "static int sco_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sco_pinfo *pi = sco_pi(sk);\n\tlock_sock(sk);\n\tif (sk->sk_state == BT_CONNECT2 &&\n\t    test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags)) {\n\t\tsco_conn_defer_accept(pi->conn->hcon, pi->setting);\n\t\tsk->sk_state = BT_CONFIG;\n\t\tmsg->msg_namelen = 0;\n\t\trelease_sock(sk);\n\t\treturn 0;\n\t}\n\trelease_sock(sk);\n\treturn bt_sock_recvmsg(iocb, sock, msg, len, flags);\n}", "target": 1}
{"code": "static int __ptrace_may_access(struct task_struct *task, unsigned int mode)\n{\n\tconst struct cred *cred = current_cred(), *tcred;\n\tint dumpable = 0;\n\tif (same_thread_group(task, current))\n\t\treturn 0;\n\trcu_read_lock();\n\ttcred = __task_cred(task);\n\tif (uid_eq(cred->uid, tcred->euid) &&\n\t    uid_eq(cred->uid, tcred->suid) &&\n\t    uid_eq(cred->uid, tcred->uid)  &&\n\t    gid_eq(cred->gid, tcred->egid) &&\n\t    gid_eq(cred->gid, tcred->sgid) &&\n\t    gid_eq(cred->gid, tcred->gid))\n\t\tgoto ok;\n\tif (ptrace_has_cap(tcred->user_ns, mode))\n\t\tgoto ok;\n\trcu_read_unlock();\n\treturn -EPERM;\nok:\n\trcu_read_unlock();\n\tsmp_rmb();\n\tif (task->mm)\n\t\tdumpable = get_dumpable(task->mm);\n\trcu_read_lock();\n\tif (!dumpable && !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {\n\t\trcu_read_unlock();\n\t\treturn -EPERM;\n\t}\n\trcu_read_unlock();\n\treturn security_ptrace_access_check(task, mode);\n}", "target": 1}
{"code": "  friend bool operator==(const TensorKey& t1, const TensorKey& t2) {\n    if (t1.dtype() != t2.dtype() || t1.shape() != t2.shape()) {\n      return false;\n    }\n    if (DataTypeCanUseMemcpy(t1.dtype())) {\n      return t1.tensor_data() == t2.tensor_data();\n    }\n    if (t1.dtype() == DT_STRING) {\n      const auto s1 = t1.unaligned_flat<tstring>();\n      const auto s2 = t2.unaligned_flat<tstring>();\n      for (int64_t i = 0, n = t1.NumElements(); i < n; ++i) {\n        if (TF_PREDICT_FALSE(s1(i) != s2(i))) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }", "target": 1}
{"code": "u32 secure_ipv4_port_ephemeral(__be32 saddr, __be32 daddr, __be16 dport)\n{\n\tu32 hash[MD5_DIGEST_WORDS];\n\thash[0] = (__force u32)saddr;\n\thash[1] = (__force u32)daddr;\n\thash[2] = (__force u32)dport ^ net_secret[14];\n\thash[3] = net_secret[15];\n\tmd5_transform(hash, net_secret);\n\treturn hash[0];\n}", "target": 0}
{"code": "get_one_option(int optid, const struct my_option *opt,\n               char *argument)\n{\n  my_bool add_option= TRUE;\n  switch (optid) {\n  case '?':\n    printf(\"%s  Ver %s Distrib %s, for %s (%s)\\n\",\n           my_progname, VER, MYSQL_SERVER_VERSION, SYSTEM_TYPE, MACHINE_TYPE);\n    puts(ORACLE_WELCOME_COPYRIGHT_NOTICE(\"2000\"));\n    puts(\"MySQL utility for upgrading databases to new MySQL versions.\\n\");\n    my_print_help(my_long_options);\n    exit(0);\n    break;\n  case '#':\n    DBUG_PUSH(argument ? argument : default_dbug_option);\n    add_option= FALSE;\n    debug_check_flag= 1;\n    break;\n  case 'p':\n    if (argument == disabled_my_option)\n      argument= (char*) \"\";\t\t\t\n    tty_password= 1;\n    add_option= FALSE;\n    if (argument)\n    {\n      add_one_option(&ds_args, opt, argument);\n      while (*argument)\n        *argument++= 'x';                       \n      tty_password= 0;\n    }\n    break;\n  case 't':\n    my_stpnmov(opt_tmpdir, argument, sizeof(opt_tmpdir));\n    add_option= FALSE;\n    break;\n  case 'k':                                     \n  case 'v': \n  case 'f': \n  case 's':                                     \n  case OPT_WRITE_BINLOG:                        \n    add_option= FALSE;\n    break;\n  case 'h': \n  case 'W': \n  case 'P': \n  case 'S': \n  case OPT_MYSQL_PROTOCOL: \n  case OPT_SHARED_MEMORY_BASE_NAME: \n  case OPT_PLUGIN_DIR:                          \n  case OPT_DEFAULT_AUTH:                        \n    add_one_option(&conn_args, opt, argument);\n    break;\n  }\n  if (add_option)\n  {\n    add_one_option(&ds_args, opt, argument);\n  }\n  return 0;\n}", "target": 1}
{"code": "static uint8_t *extend_raw_data(LHAFileHeader **header,\n                                LHAInputStream *stream,\n                                size_t nbytes)\n{\n\tLHAFileHeader *new_header;\n\tsize_t new_raw_len;\n\tuint8_t *result;\n\tif (nbytes > LEVEL_3_MAX_HEADER_LEN) {\n\t\treturn NULL;\n\t}\n\tnew_raw_len = RAW_DATA_LEN(header) + nbytes;\n\tnew_header = realloc(*header, sizeof(LHAFileHeader) + new_raw_len);\n\tif (new_header == NULL) {\n\t\treturn NULL;\n\t}\n\t*header = new_header;\n\tnew_header->raw_data = (uint8_t *) (new_header + 1);\n\tresult = new_header->raw_data + new_header->raw_data_len;\n\tif (!lha_input_stream_read(stream, result, nbytes)) {\n\t\treturn NULL;\n\t}\n\tnew_header->raw_data_len = new_raw_len;\n\treturn result;\n}", "target": 0}
{"code": "static void *command_init(struct pci_dev *dev, int offset)\n{\n\tstruct pci_cmd_info *cmd = kmalloc(sizeof(*cmd), GFP_KERNEL);\n\tint err;\n\tif (!cmd)\n\t\treturn ERR_PTR(-ENOMEM);\n\terr = pci_read_config_word(dev, PCI_COMMAND, &cmd->val);\n\tif (err) {\n\t\tkfree(cmd);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn cmd;\n}", "target": 0}
{"code": "WM_SYMBOL midi *WildMidi_Open(const char *midifile) {\n    uint8_t *mididata = NULL;\n    uint32_t midisize = 0;\n    uint8_t mus_hdr[] = { 'M', 'U', 'S', 0x1A };\n    uint8_t xmi_hdr[] = { 'F', 'O', 'R', 'M' };\n    midi * ret = NULL;\n    if (!WM_Initialized) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_INIT, NULL, 0);\n        return (NULL);\n    }\n    if (midifile == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(NULL filename)\", 0);\n        return (NULL);\n    }\n    if ((mididata = (uint8_t *) _WM_BufferFile(midifile, &midisize)) == NULL) {\n        return (NULL);\n    }\n    if (midisize < 18) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(too short)\", 0);\n        return (NULL);\n    }\n    if (memcmp(mididata,\"HMIMIDIP\", 8) == 0) {\n        ret = (void *) _WM_ParseNewHmp(mididata, midisize);\n    } else if (memcmp(mididata, \"HMI-MIDISONG061595\", 18) == 0) {\n        ret = (void *) _WM_ParseNewHmi(mididata, midisize);\n    } else if (memcmp(mididata, mus_hdr, 4) == 0) {\n        ret = (void *) _WM_ParseNewMus(mididata, midisize);\n    } else if (memcmp(mididata, xmi_hdr, 4) == 0) {\n        ret = (void *) _WM_ParseNewXmi(mididata, midisize);\n    } else {\n        ret = (void *) _WM_ParseNewMidi(mididata, midisize);\n    }\n    free(mididata);\n    if (ret) {\n        if (add_handle(ret) != 0) {\n            WildMidi_Close(ret);\n            ret = NULL;\n        }\n    }\n    return (ret);\n}", "target": 0}
{"code": "int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n{\n#ifndef WITH_BROKER\n\tchar sockpair_data = 0;\n#endif\n\tassert(mosq);\n\tassert(packet);\n\tpacket->pos = 0;\n\tpacket->to_process = packet->packet_length;\n\tpacket->next = NULL;\n\tpthread_mutex_lock(&mosq->out_packet_mutex);\n#ifdef WITH_BROKER\n\tif(mosq->out_packet_count >= db.config->max_queued_messages){\n\t\tmosquitto__free(packet);\n\t\tif(mosq->is_dropping == false){\n\t\t\tmosq->is_dropping = true;\n\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n\t\t\t\t\t\"Outgoing messages are being dropped for client %s.\",\n\t\t\t\t\tmosq->id);\n\t\t}\n\t\tG_MSGS_DROPPED_INC();\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}\n#endif\n\tif(mosq->out_packet){\n\t\tmosq->out_packet_last->next = packet;\n\t}else{\n\t\tmosq->out_packet = packet;\n\t}\n\tmosq->out_packet_last = packet;\n\tmosq->out_packet_count++;\n\tpthread_mutex_unlock(&mosq->out_packet_mutex);\n#ifdef WITH_BROKER\n#  ifdef WITH_WEBSOCKETS\n\tif(mosq->wsi){\n\t\tlws_callback_on_writable(mosq->wsi);\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}else{\n\t\treturn packet__write(mosq);\n\t}\n#  else\n\treturn packet__write(mosq);\n#  endif\n#else\n\tif(mosq->sockpairW != INVALID_SOCKET){\n#ifndef WIN32\n\t\tif(write(mosq->sockpairW, &sockpair_data, 1)){\n\t\t}\n#else\n\t\tsend(mosq->sockpairW, &sockpair_data, 1, 0);\n#endif\n\t}\n\tif(mosq->in_callback == false && mosq->threaded == mosq_ts_none){\n\t\treturn packet__write(mosq);\n\t}else{\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}\n#endif\n}", "target": 0}
{"code": "del_aubio_filterbank (aubio_filterbank_t * fb)\n{\n  del_fmat (fb->filters);\n  AUBIO_FREE (fb);\n}", "target": 0}
{"code": "static void free_clt(struct rtrs_clt_sess *clt)\n{\n\tfree_permits(clt);\n\tfree_percpu(clt->pcpu_path);\n\tmutex_destroy(&clt->paths_ev_mutex);\n\tmutex_destroy(&clt->paths_mutex);\n\tdevice_unregister(&clt->dev);\n}", "target": 1}
{"code": "static ssize_t environ_read(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar *page;\n\tunsigned long src = *ppos;\n\tint ret = 0;\n\tstruct mm_struct *mm = file->private_data;\n\tunsigned long env_start, env_end;\n\tif (!mm)\n\t\treturn 0;\n\tpage = (char *)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tret = 0;\n\tif (!atomic_inc_not_zero(&mm->mm_users))\n\t\tgoto free;\n\tdown_read(&mm->mmap_sem);\n\tenv_start = mm->env_start;\n\tenv_end = mm->env_end;\n\tup_read(&mm->mmap_sem);\n\twhile (count > 0) {\n\t\tsize_t this_len, max_len;\n\t\tint retval;\n\t\tif (src >= (env_end - env_start))\n\t\t\tbreak;\n\t\tthis_len = env_end - (env_start + src);\n\t\tmax_len = min_t(size_t, PAGE_SIZE, count);\n\t\tthis_len = min(max_len, this_len);\n\t\tretval = access_remote_vm(mm, (env_start + src),\n\t\t\tpage, this_len, 0);\n\t\tif (retval <= 0) {\n\t\t\tret = retval;\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_to_user(buf, page, retval)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tret += retval;\n\t\tsrc += retval;\n\t\tbuf += retval;\n\t\tcount -= retval;\n\t}\n\t*ppos = src;\n\tmmput(mm);\nfree:\n\tfree_page((unsigned long) page);\n\treturn ret;\n}", "target": 1}
{"code": "ossl_cipher_pkcs5_keyivgen(int argc, VALUE *argv, VALUE self)\n{\n    EVP_CIPHER_CTX *ctx;\n    const EVP_MD *digest;\n    VALUE vpass, vsalt, viter, vdigest;\n    unsigned char key[EVP_MAX_KEY_LENGTH], iv[EVP_MAX_IV_LENGTH], *salt = NULL;\n    int iter;\n    rb_scan_args(argc, argv, \"13\", &vpass, &vsalt, &viter, &vdigest);\n    StringValue(vpass);\n    if(!NIL_P(vsalt)){\n\tStringValue(vsalt);\n\tif(RSTRING_LEN(vsalt) != PKCS5_SALT_LEN)\n\t    ossl_raise(eCipherError, \"salt must be an 8-octet string\");\n\tsalt = (unsigned char *)RSTRING_PTR(vsalt);\n    }\n    iter = NIL_P(viter) ? 2048 : NUM2INT(viter);\n    digest = NIL_P(vdigest) ? EVP_md5() : GetDigestPtr(vdigest);\n    GetCipher(self, ctx);\n    EVP_BytesToKey(EVP_CIPHER_CTX_cipher(ctx), digest, salt,\n\t\t   (unsigned char *)RSTRING_PTR(vpass), RSTRING_LENINT(vpass), iter, key, iv);\n    if (EVP_CipherInit_ex(ctx, NULL, NULL, key, iv, -1) != 1)\n\tossl_raise(eCipherError, NULL);\n    OPENSSL_cleanse(key, sizeof key);\n    OPENSSL_cleanse(iv, sizeof iv);\n    rb_ivar_set(self, id_key_set, Qtrue);\n    return Qnil;\n}", "target": 0}
{"code": "rb_decrement_entry(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t   struct ring_buffer_event *event)\n{\n\tunsigned long addr = (unsigned long)event;\n\tstruct buffer_page *bpage = cpu_buffer->commit_page;\n\tstruct buffer_page *start;\n\taddr &= PAGE_MASK;\n\tif (likely(bpage->page == (void *)addr)) {\n\t\tlocal_dec(&bpage->entries);\n\t\treturn;\n\t}\n\trb_inc_page(cpu_buffer, &bpage);\n\tstart = bpage;\n\tdo {\n\t\tif (bpage->page == (void *)addr) {\n\t\t\tlocal_dec(&bpage->entries);\n\t\t\treturn;\n\t\t}\n\t\trb_inc_page(cpu_buffer, &bpage);\n\t} while (bpage != start);\n\tRB_WARN_ON(cpu_buffer, 1);\n}", "target": 0}
{"code": "static void bt_tags_for_each(struct blk_mq_tags *tags,\n\t\tstruct blk_mq_bitmap_tags *bt, unsigned int off,\n\t\tbusy_tag_iter_fn *fn, void *data, bool reserved)\n{\n\tstruct request *rq;\n\tint bit, i;\n\tif (!tags->rqs)\n\t\treturn;\n\tfor (i = 0; i < bt->map_nr; i++) {\n\t\tstruct blk_align_bitmap *bm = &bt->map[i];\n\t\tfor (bit = find_first_bit(&bm->word, bm->depth);\n\t\t     bit < bm->depth;\n\t\t     bit = find_next_bit(&bm->word, bm->depth, bit + 1)) {\n\t\t\trq = blk_mq_tag_to_rq(tags, off + bit);\n\t\t\tfn(rq, data, reserved);\n\t\t}\n\t\toff += (1 << bt->bits_per_word);\n\t}\n}", "target": 1}
{"code": "static int tcos_list_files(sc_card_t *card, u8 *buf, size_t buflen)\n{\n\tsc_context_t *ctx;\n\tsc_apdu_t apdu;\n\tu8 rbuf[SC_MAX_APDU_BUFFER_SIZE], p1;\n\tint r, count = 0;\n\tassert(card != NULL);\n\tctx = card->ctx;\n\tfor (p1=1; p1<=2; p1++) {\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0xAA, p1, 0);\n\t\tapdu.cla = 0x80;\n\t\tapdu.resp = rbuf;\n\t\tapdu.resplen = sizeof(rbuf);\n\t\tapdu.le = 256;\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t\tSC_TEST_RET(ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");\n\t\tif (apdu.sw1==0x6A && (apdu.sw2==0x82 || apdu.sw2==0x88)) continue;\n\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tSC_TEST_RET(ctx, SC_LOG_DEBUG_NORMAL, r, \"List Dir failed\");\n\t\tif (apdu.resplen > buflen) return SC_ERROR_BUFFER_TOO_SMALL;\n\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL,\n\t\t\t \"got %\"SC_FORMAT_LEN_SIZE_T\"u %s-FileIDs\\n\",\n\t\t\t apdu.resplen / 2, p1 == 1 ? \"DF\" : \"EF\");\n\t\tmemcpy(buf, apdu.resp, apdu.resplen);\n\t\tbuf += apdu.resplen;\n\t\tbuflen -= apdu.resplen;\n\t\tcount += apdu.resplen;\n\t}\n\treturn count;\n}", "target": 0}
{"code": "void cliprdr_free_format_list(CLIPRDR_FORMAT_LIST* formatList)\n{\n\tUINT index = 0;\n\tif (formatList == NULL)\n\t\treturn;\n\tif (formatList->formats)\n\t{\n\t\tfor (index = 0; index < formatList->numFormats; index++)\n\t\t{\n\t\t\tfree(formatList->formats[index].formatName);\n\t\t}\n\t\tfree(formatList->formats);\n\t\tformatList->formats = NULL;\n\t\tformatList->numFormats = 0;\n\t}\n}", "target": 0}
{"code": "static int search_old_relocation(struct reloc_struct_t *reloc_table, ut32 addr_to_patch, int n_reloc) {\n\tint i;\n\tfor (i = 0; i < n_reloc; i++) {\n\t\tif (addr_to_patch == reloc_table[i].data_offset) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}", "target": 1}
{"code": "int SMIME_write_PKCS7(BIO *bio, PKCS7 *p7, BIO *data, int flags)\n{\n    STACK_OF(X509_ALGOR) *mdalgs;\n    int ctype_nid = OBJ_obj2nid(p7->type);\n    const PKCS7_CTX *ctx = ossl_pkcs7_get0_ctx(p7);\n    if (ctype_nid == NID_pkcs7_signed)\n        mdalgs = p7->d.sign->md_algs;\n    else\n        mdalgs = NULL;\n    flags ^= SMIME_OLDMIME;\n    return SMIME_write_ASN1_ex(bio, (ASN1_VALUE *)p7, data, flags, ctype_nid,\n                               NID_undef, mdalgs, ASN1_ITEM_rptr(PKCS7),\n                               ossl_pkcs7_ctx_get0_libctx(ctx),\n                               ossl_pkcs7_ctx_get0_propq(ctx));\n}", "target": 1}
{"code": "void ion_free(struct ion_client *client, struct ion_handle *handle)\n{\n\tbool valid_handle;\n\tBUG_ON(client != handle->client);\n\tmutex_lock(&client->lock);\n\tvalid_handle = ion_handle_validate(client, handle);\n\tif (!valid_handle) {\n\t\tWARN(1, \"%s: invalid handle passed to free.\\n\", __func__);\n\t\tmutex_unlock(&client->lock);\n\t\treturn;\n\t}\n\tmutex_unlock(&client->lock);\n\tion_handle_put(handle);\n}", "target": 1}
{"code": "void llc_conn_handler(struct llc_sap *sap, struct sk_buff *skb)\n{\n\tstruct llc_addr saddr, daddr;\n\tstruct sock *sk;\n\tllc_pdu_decode_sa(skb, saddr.mac);\n\tllc_pdu_decode_ssap(skb, &saddr.lsap);\n\tllc_pdu_decode_da(skb, daddr.mac);\n\tllc_pdu_decode_dsap(skb, &daddr.lsap);\n\tsk = __llc_lookup(sap, &saddr, &daddr);\n\tif (!sk)\n\t\tgoto drop;\n\tbh_lock_sock(sk);\n\tif (unlikely(sk->sk_state == TCP_LISTEN)) {\n\t\tstruct sock *newsk = llc_create_incoming_sock(sk, skb->dev,\n\t\t\t\t\t\t\t      &saddr, &daddr);\n\t\tif (!newsk)\n\t\t\tgoto drop_unlock;\n\t\tskb_set_owner_r(skb, newsk);\n\t} else {\n\t\tskb_orphan(skb);\n\t\tsock_hold(sk);\n\t\tskb->sk = sk;\n\t\tskb->destructor = sock_efree;\n\t}\n\tif (!sock_owned_by_user(sk))\n\t\tllc_conn_rcv(sk, skb);\n\telse {\n\t\tdprintk(\"%s: adding to backlog...\\n\", __func__);\n\t\tllc_set_backlog_type(skb, LLC_PACKET);\n\t\tif (sk_add_backlog(sk, skb, sk->sk_rcvbuf))\n\t\t\tgoto drop_unlock;\n\t}\nout:\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n\treturn;\ndrop:\n\tkfree_skb(skb);\n\treturn;\ndrop_unlock:\n\tkfree_skb(skb);\n\tgoto out;\n}", "target": 0}
{"code": "string_copy(uschar *s)\n{\nint len = Ustrlen(s) + 1;\nuschar *ss = store_get(len);\nmemcpy(ss, s, len);\nreturn ss;\n}", "target": 0}
{"code": "BOOL update_write_cache_bitmap_v3_order(wStream* s, CACHE_BITMAP_V3_ORDER* cache_bitmap_v3,\n                                        UINT16* flags)\n{\n\tBYTE bitsPerPixelId;\n\tBITMAP_DATA_EX* bitmapData;\n\tif (!Stream_EnsureRemainingCapacity(\n\t        s, update_approximate_cache_bitmap_v3_order(cache_bitmap_v3, flags)))\n\t\treturn FALSE;\n\tbitmapData = &cache_bitmap_v3->bitmapData;\n\tbitsPerPixelId = BPP_CBR23[cache_bitmap_v3->bpp];\n\t*flags = (cache_bitmap_v3->cacheId & 0x00000003) |\n\t         ((cache_bitmap_v3->flags << 7) & 0x0000FF80) | ((bitsPerPixelId << 3) & 0x00000078);\n\tStream_Write_UINT16(s, cache_bitmap_v3->cacheIndex); \n\tStream_Write_UINT32(s, cache_bitmap_v3->key1);       \n\tStream_Write_UINT32(s, cache_bitmap_v3->key2);       \n\tStream_Write_UINT8(s, bitmapData->bpp);\n\tStream_Write_UINT8(s, 0);                   \n\tStream_Write_UINT8(s, 0);                   \n\tStream_Write_UINT8(s, bitmapData->codecID); \n\tStream_Write_UINT16(s, bitmapData->width);  \n\tStream_Write_UINT16(s, bitmapData->height); \n\tStream_Write_UINT32(s, bitmapData->length); \n\tStream_Write(s, bitmapData->data, bitmapData->length);\n\treturn TRUE;\n}", "target": 1}
{"code": "static void ax25_kill_by_device(struct net_device *dev)\n{\n\tax25_dev *ax25_dev;\n\tax25_cb *s;\n\tstruct sock *sk;\n\tif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\n\t\treturn;\n\tspin_lock_bh(&ax25_list_lock);\nagain:\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->ax25_dev == ax25_dev) {\n\t\t\tsk = s->sk;\n\t\t\tsock_hold(sk);\n\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\tlock_sock(sk);\n\t\t\ts->ax25_dev = NULL;\n\t\t\tax25_dev_put(ax25_dev);\n\t\t\trelease_sock(sk);\n\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\tspin_lock_bh(&ax25_list_lock);\n\t\t\tsock_put(sk);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock_bh(&ax25_list_lock);\n}", "target": 1}
{"code": "static const char* ConvertOneFloat(PyObject* v, T* out) {\n  if (PyErr_Occurred()) {\n    return nullptr;\n  }\n  if (TF_PREDICT_TRUE(PyFloat_Check(v))) {\n    const double as_double = PyFloat_AS_DOUBLE(v);\n    *out = static_cast<T>(as_double);\n    if (TF_PREDICT_FALSE(sizeof(T) < sizeof(double) && std::isinf(*out) &&\n                         std::isfinite(as_double))) {\n      return ErrorOutOfRangeDouble;\n    }\n    return nullptr;\n  }\n#if PY_MAJOR_VERSION < 3\n  if (PyInt_Check(v)) {\n    *out = PyInt_AS_LONG(v);\n    return nullptr;\n  }\n#endif\n  if (PyLong_Check(v)) {\n    *out = PyLong_AsDouble(v);\n    if (PyErr_Occurred()) return ErrorOutOfRangeDouble;\n    return nullptr;\n  }\n  if (PyIsInstance(v, &PyFloatingArrType_Type)) {  \n    Safe_PyObjectPtr as_float = make_safe(PyNumber_Float(v));\n    if (PyErr_Occurred()) {\n      return nullptr;\n    }\n    return ConvertOneFloat<T>(as_float.get(), out);\n  }\n  if (PyIsInstance(v, &PyIntegerArrType_Type)) {  \n#if PY_MAJOR_VERSION < 3\n    Safe_PyObjectPtr as_int = make_safe(PyNumber_Int(v));\n#else\n    Safe_PyObjectPtr as_int = make_safe(PyNumber_Long(v));\n#endif\n    if (PyErr_Occurred()) {\n      return nullptr;\n    }\n    return ConvertOneFloat<T>(as_int.get(), out);\n  }\n  return ErrorMixedTypes;\n}", "target": 1}
{"code": "static void ie_destructor(void *arg)\n{\n\tstruct ident_entry *ie = arg;\n\tmem_deref(ie->content.publish);\n\tmem_deref(ie->content.accept);\n\tmem_deref(ie->ident);\n}", "target": 0}
{"code": "static int do_session_handshake (lua_State *L, int status, lua_KContext ctx) {\n    int rc;\n    struct ssh_userdata *sshu = NULL;\n    assert(lua_gettop(L) == 4);\n    sshu = (struct ssh_userdata *) nseU_checkudata(L, 3, SSH2_UDATA, \"ssh2\");\n    while ((rc = libssh2_session_handshake(sshu->session, sshu->sp[0])) == LIBSSH2_ERROR_EAGAIN) {\n        luaL_getmetafield(L, 3, \"filter\");\n        lua_pushvalue(L, 3);\n        assert(lua_status(L) == LUA_OK);\n        lua_callk(L, 1, 0, 0, do_session_handshake);\n    }\n    if (rc) {\n        libssh2_session_free(sshu->session);\n        sshu->session = NULL;\n        return luaL_error(L, \"Unable to complete libssh2 handshake.\");\n    }\n    lua_settop(L, 3);\n    return 1;\n}", "target": 0}
{"code": "static int logi_dj_recv_switch_to_dj_mode(struct dj_receiver_dev *djrcv_dev,\n\t\t\t\t\t  unsigned timeout)\n{\n\tstruct dj_report *dj_report;\n\tint retval;\n\tdj_report = kzalloc(sizeof(struct dj_report), GFP_KERNEL);\n\tif (!dj_report)\n\t\treturn -ENOMEM;\n\tdj_report->report_id = REPORT_ID_DJ_SHORT;\n\tdj_report->device_index = 0xFF;\n\tdj_report->report_type = REPORT_TYPE_CMD_SWITCH;\n\tdj_report->report_params[CMD_SWITCH_PARAM_DEVBITFIELD] = 0x3F;\n\tdj_report->report_params[CMD_SWITCH_PARAM_TIMEOUT_SECONDS] = (u8)timeout;\n\tretval = logi_dj_recv_send_report(djrcv_dev, dj_report);\n\tkfree(dj_report);\n\tmsleep(50);\n\treturn retval;\n}", "target": 0}
{"code": "static void xen_irq_lateeoi_locked(struct irq_info *info)\n{\n\tevtchn_port_t evtchn;\n\tevtchn = info->evtchn;\n\tif (!VALID_EVTCHN(evtchn))\n\t\treturn;\n\tunmask_evtchn(evtchn);\n}", "target": 1}
{"code": "static int discovery_stop(struct discovery_client *client)\n{\n\tstruct btd_adapter *adapter = client->adapter;\n\tstruct mgmt_cp_stop_discovery cp;\n\tif (g_slist_next(adapter->discovery_list)) {\n\t\tdiscovery_remove(client);\n\t\tupdate_discovery_filter(adapter);\n\t\treturn 0;\n\t}\n\tif (adapter->discovery_discoverable)\n\t\tset_discovery_discoverable(adapter, false);\n\tif (adapter->discovery_enable == 0x00) {\n\t\tdiscovery_remove(client);\n\t\tadapter->discovering = false;\n\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Discovering\");\n\t\ttrigger_passive_scanning(adapter);\n\t\treturn 0;\n\t}\n\tcp.type = adapter->discovery_type;\n\tadapter->client = client;\n\tmgmt_send(adapter->mgmt, MGMT_OP_STOP_DISCOVERY,\n\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\tstop_discovery_complete, adapter, NULL);\n\treturn -EINPROGRESS;\n}", "target": 1}
{"code": "inline bool canReadNElements(\n    NimbleProtocolReader& ,\n    uint32_t ,\n    std::initializer_list<detail::nimble::NimbleType> ) {\n  return true;\n}", "target": 0}
{"code": "bool DNP3_Base::ParseAppLayer(Endpoint* endp)\n\t{\n\tbool orig = (endp == &orig_state);\n\tbinpac::DNP3::DNP3_Flow* flow = orig ? interp->upflow() : interp->downflow();\n\tu_char* data = endp->buffer + PSEUDO_TRANSPORT_INDEX; \n\tint len = endp->pkt_length - 5;\n\tint is_first = (endp->tpflags & 0x40) >> 6; \n\tint is_last = (endp->tpflags & 0x80) >> 7; \n\tint transport = PSEUDO_TRANSPORT_LEN;\n\tint i = 0;\n\twhile ( len > 0 )\n\t\t{\n\t\tint n = min(len, 16);\n\t\tif ( ! CheckCRC(n, data, data + n, \"app_chunk\") )\n\t\t\treturn false;\n\t\tassert(data + n < endp->buffer + endp->buffer_len);\n\t\tflow->flow_buffer()->BufferData(data + transport, data + n);\n\t\ttransport = 0;\n\t\tdata += n + 2;\n\t\tlen -= n;\n\t\t}\n\tif ( is_first )\n\t\tendp->encountered_first_chunk = true;\n\tif ( ! is_first && ! endp->encountered_first_chunk )\n\t\t{\n\t\tanalyzer->Weird(\"dnp3_first_application_layer_chunk_missing\");\n\t\treturn false;\n\t\t}\n\tif ( is_last )\n\t\t{\n\t\tflow->flow_buffer()->FinishBuffer();\n\t\tflow->FlowEOF();\n\t\tClearEndpointState(orig);\n\t\t}\n\treturn true;\n\t}", "target": 1}
{"code": "void rds_rdma_drop_keys(struct rds_sock *rs)\n{\n\tstruct rds_mr *mr;\n\tstruct rb_node *node;\n\tunsigned long flags;\n\tspin_lock_irqsave(&rs->rs_rdma_lock, flags);\n\twhile ((node = rb_first(&rs->rs_rdma_keys))) {\n\t\tmr = rb_entry(node, struct rds_mr, r_rb_node);\n\t\tif (mr->r_trans == rs->rs_transport)\n\t\t\tmr->r_invalidate = 0;\n\t\trb_erase(&mr->r_rb_node, &rs->rs_rdma_keys);\n\t\tRB_CLEAR_NODE(&mr->r_rb_node);\n\t\tspin_unlock_irqrestore(&rs->rs_rdma_lock, flags);\n\t\trds_destroy_mr(mr);\n\t\trds_mr_put(mr);\n\t\tspin_lock_irqsave(&rs->rs_rdma_lock, flags);\n\t}\n\tspin_unlock_irqrestore(&rs->rs_rdma_lock, flags);\n\tif (rs->rs_transport && rs->rs_transport->flush_mrs)\n\t\trs->rs_transport->flush_mrs();\n}", "target": 0}
{"code": "int __audit_mq_timedreceive(mqd_t mqdes, size_t msg_len,\n\t\t\t\tunsigned int __user *u_msg_prio,\n\t\t\t\tconst struct timespec __user *u_abs_timeout)\n{\n\tstruct audit_aux_data_mq_sendrecv *ax;\n\tstruct audit_context *context = current->audit_context;\n\tif (!audit_enabled)\n\t\treturn 0;\n\tif (likely(!context))\n\t\treturn 0;\n\tax = kmalloc(sizeof(*ax), GFP_ATOMIC);\n\tif (!ax)\n\t\treturn -ENOMEM;\n\tif (u_msg_prio != NULL) {\n\t\tif (get_user(ax->msg_prio, u_msg_prio)) {\n\t\t\tkfree(ax);\n\t\t\treturn -EFAULT;\n\t\t}\n\t} else\n\t\tax->msg_prio = 0;\n\tif (u_abs_timeout != NULL) {\n\t\tif (copy_from_user(&ax->abs_timeout, u_abs_timeout, sizeof(ax->abs_timeout))) {\n\t\t\tkfree(ax);\n\t\t\treturn -EFAULT;\n\t\t}\n\t} else\n\t\tmemset(&ax->abs_timeout, 0, sizeof(ax->abs_timeout));\n\tax->mqdes = mqdes;\n\tax->msg_len = msg_len;\n\tax->d.type = AUDIT_MQ_SENDRECV;\n\tax->d.next = context->aux;\n\tcontext->aux = (void *)ax;\n\treturn 0;\n}", "target": 0}
{"code": "static UINT rdpei_recv_pdu(RDPEI_CHANNEL_CALLBACK* callback, wStream* s)\n{\n\tUINT16 eventId;\n\tUINT32 pduLength;\n\tUINT error;\n\tif (Stream_GetRemainingLength(s) < 6)\n\t\treturn ERROR_INVALID_DATA;\n\tStream_Read_UINT16(s, eventId);   \n\tStream_Read_UINT32(s, pduLength); \n#ifdef WITH_DEBUG_RDPEI\n\tWLog_DBG(TAG, \"rdpei_recv_pdu: eventId: %\" PRIu16 \" (%s) length: %\" PRIu32 \"\", eventId,\n\t         rdpei_eventid_string(eventId), pduLength);\n#endif\n\tswitch (eventId)\n\t{\n\t\tcase EVENTID_SC_READY:\n\t\t\tif ((error = rdpei_recv_sc_ready_pdu(callback, s)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_recv_sc_ready_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tif ((error = rdpei_send_cs_ready_pdu(callback)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_send_cs_ready_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EVENTID_SUSPEND_TOUCH:\n\t\t\tif ((error = rdpei_recv_suspend_touch_pdu(callback, s)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_recv_suspend_touch_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EVENTID_RESUME_TOUCH:\n\t\t\tif ((error = rdpei_recv_resume_touch_pdu(callback, s)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_recv_resume_touch_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn CHANNEL_RC_OK;\n}", "target": 0}
{"code": "static MagickBooleanType DrawStrokePolygon(Image *image,\n  const DrawInfo *draw_info,const PrimitiveInfo *primitive_info,\n  ExceptionInfo *exception)\n{\n  DrawInfo\n    *clone_info;\n  MagickBooleanType\n    closed_path;\n  MagickStatusType\n    status;\n  PrimitiveInfo\n    *stroke_polygon;\n  register const PrimitiveInfo\n    *p,\n    *q;\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n      \"    begin draw-stroke-polygon\");\n  clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  clone_info->fill=draw_info->stroke;\n  if (clone_info->fill_pattern != (Image *) NULL)\n    clone_info->fill_pattern=DestroyImage(clone_info->fill_pattern);\n  if (clone_info->stroke_pattern != (Image *) NULL)\n    clone_info->fill_pattern=CloneImage(clone_info->stroke_pattern,0,0,\n      MagickTrue,exception);\n  clone_info->stroke.alpha=(Quantum) TransparentAlpha;\n  clone_info->stroke_width=0.0;\n  clone_info->fill_rule=NonZeroRule;\n  status=MagickTrue;\n  for (p=primitive_info; p->primitive != UndefinedPrimitive; p+=p->coordinates)\n  {\n    stroke_polygon=TraceStrokePolygon(draw_info,p);\n    status&=DrawPolygonPrimitive(image,clone_info,stroke_polygon,exception);\n    if (status == 0)\n      break;\n    stroke_polygon=(PrimitiveInfo *) RelinquishMagickMemory(stroke_polygon);\n    q=p+p->coordinates-1;\n    closed_path=(q->point.x == p->point.x) && (q->point.y == p->point.y) ?\n      MagickTrue : MagickFalse;\n    if ((draw_info->linecap == RoundCap) && (closed_path == MagickFalse))\n      {\n        DrawRoundLinecap(image,draw_info,p,exception);\n        DrawRoundLinecap(image,draw_info,q,exception);\n      }\n  }\n  clone_info=DestroyDrawInfo(clone_info);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n      \"    end draw-stroke-polygon\");\n  return(status != 0 ? MagickTrue : MagickFalse);\n}", "target": 1}
{"code": "static int rawsock_create(struct net *net, struct socket *sock,\n\t\t\t  const struct nfc_protocol *nfc_proto, int kern)\n{\n\tstruct sock *sk;\n\tpr_debug(\"sock=%p\\n\", sock);\n\tif ((sock->type != SOCK_SEQPACKET) && (sock->type != SOCK_RAW))\n\t\treturn -ESOCKTNOSUPPORT;\n\tif (sock->type == SOCK_RAW)\n\t\tsock->ops = &rawsock_raw_ops;\n\telse\n\t\tsock->ops = &rawsock_ops;\n\tsk = sk_alloc(net, PF_NFC, GFP_ATOMIC, nfc_proto->proto, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\tsock_init_data(sock, sk);\n\tsk->sk_protocol = nfc_proto->id;\n\tsk->sk_destruct = rawsock_destruct;\n\tsock->state = SS_UNCONNECTED;\n\tif (sock->type == SOCK_RAW)\n\t\tnfc_sock_link(&raw_sk_list, sk);\n\telse {\n\t\tINIT_WORK(&nfc_rawsock(sk)->tx_work, rawsock_tx_work);\n\t\tnfc_rawsock(sk)->tx_work_scheduled = false;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static ssize_t process_output_block(struct tty_struct *tty,\n\t\t\t\t    const unsigned char *buf, unsigned int nr)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint\tspace;\n\tint\ti;\n\tconst unsigned char *cp;\n\tmutex_lock(&ldata->output_lock);\n\tspace = tty_write_room(tty);\n\tif (!space) {\n\t\tmutex_unlock(&ldata->output_lock);\n\t\treturn 0;\n\t}\n\tif (nr > space)\n\t\tnr = space;\n\tfor (i = 0, cp = buf; i < nr; i++, cp++) {\n\t\tunsigned char c = *cp;\n\t\tswitch (c) {\n\t\tcase '\\n':\n\t\t\tif (O_ONLRET(tty))\n\t\t\t\tldata->column = 0;\n\t\t\tif (O_ONLCR(tty))\n\t\t\t\tgoto break_out;\n\t\t\tldata->canon_column = ldata->column;\n\t\t\tbreak;\n\t\tcase '\\r':\n\t\t\tif (O_ONOCR(tty) && ldata->column == 0)\n\t\t\t\tgoto break_out;\n\t\t\tif (O_OCRNL(tty))\n\t\t\t\tgoto break_out;\n\t\t\tldata->canon_column = ldata->column = 0;\n\t\t\tbreak;\n\t\tcase '\\t':\n\t\t\tgoto break_out;\n\t\tcase '\\b':\n\t\t\tif (ldata->column > 0)\n\t\t\t\tldata->column--;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!iscntrl(c)) {\n\t\t\t\tif (O_OLCUC(tty))\n\t\t\t\t\tgoto break_out;\n\t\t\t\tif (!is_continuation(c, tty))\n\t\t\t\t\tldata->column++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\nbreak_out:\n\ti = tty->ops->write(tty, buf, i);\n\tmutex_unlock(&ldata->output_lock);\n\treturn i;\n}", "target": 0}
{"code": "int ipmi_destroy_user(struct ipmi_user *user)\n{\n\t_ipmi_destroy_user(user);\n\tcleanup_srcu_struct(&user->release_barrier);\n\tkref_put(&user->refcount, free_user);\n\treturn 0;\n}", "target": 1}
{"code": "int unshare_userns(unsigned long unshare_flags, struct cred **new_cred)\n{\n\tstruct cred *cred;\n\tif (!(unshare_flags & CLONE_NEWUSER))\n\t\treturn 0;\n\tcred = prepare_creds();\n\tif (!cred)\n\t\treturn -ENOMEM;\n\t*new_cred = cred;\n\treturn create_user_ns(cred);\n}", "target": 1}
{"code": "void mp_encode_lua_table_as_array(lua_State *L, mp_buf *buf, int level) {\n#if LUA_VERSION_NUM < 502\n    size_t len = lua_objlen(L,-1), j;\n#else\n    size_t len = lua_rawlen(L,-1), j;\n#endif\n    mp_encode_array(L,buf,len);\n    luaL_checkstack(L, 1, \"in function mp_encode_lua_table_as_array\");\n    for (j = 1; j <= len; j++) {\n        lua_pushnumber(L,j);\n        lua_gettable(L,-2);\n        mp_encode_lua_type(L,buf,level+1);\n    }\n}", "target": 0}
{"code": "static void put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\tif (atomic_dec_and_test(&ucounts->count)) {\n\t\tspin_lock_irqsave(&ucounts_lock, flags);\n\t\thlist_del_init(&ucounts->node);\n\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\t\tkfree(ucounts);\n\t}\n}", "target": 1}
{"code": "int __anon_vma_prepare(struct vm_area_struct *vma)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct anon_vma *anon_vma, *allocated;\n\tstruct anon_vma_chain *avc;\n\tmight_sleep();\n\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\tif (!avc)\n\t\tgoto out_enomem;\n\tanon_vma = find_mergeable_anon_vma(vma);\n\tallocated = NULL;\n\tif (!anon_vma) {\n\t\tanon_vma = anon_vma_alloc();\n\t\tif (unlikely(!anon_vma))\n\t\t\tgoto out_enomem_free_avc;\n\t\tallocated = anon_vma;\n\t}\n\tanon_vma_lock_write(anon_vma);\n\tspin_lock(&mm->page_table_lock);\n\tif (likely(!vma->anon_vma)) {\n\t\tvma->anon_vma = anon_vma;\n\t\tanon_vma_chain_link(vma, avc, anon_vma);\n\t\tanon_vma->degree++;\n\t\tallocated = NULL;\n\t\tavc = NULL;\n\t}\n\tspin_unlock(&mm->page_table_lock);\n\tanon_vma_unlock_write(anon_vma);\n\tif (unlikely(allocated))\n\t\tput_anon_vma(allocated);\n\tif (unlikely(avc))\n\t\tanon_vma_chain_free(avc);\n\treturn 0;\n out_enomem_free_avc:\n\tanon_vma_chain_free(avc);\n out_enomem:\n\treturn -ENOMEM;\n}", "target": 1}
{"code": "asmlinkage long compat_sys_ptrace(compat_long_t request, compat_long_t pid,\n\t\t\t\t  compat_long_t addr, compat_long_t data)\n{\n\tstruct task_struct *child;\n\tlong ret;\n\tif (request == PTRACE_TRACEME) {\n\t\tret = ptrace_traceme();\n\t\tgoto out;\n\t}\n\tchild = ptrace_get_task_struct(pid);\n\tif (IS_ERR(child)) {\n\t\tret = PTR_ERR(child);\n\t\tgoto out;\n\t}\n\tif (request == PTRACE_ATTACH || request == PTRACE_SEIZE) {\n\t\tret = ptrace_attach(child, request, addr, data);\n\t\tif (!ret)\n\t\t\tarch_ptrace_attach(child);\n\t\tgoto out_put_task_struct;\n\t}\n\tret = ptrace_check_attach(child, request == PTRACE_KILL ||\n\t\t\t\t  request == PTRACE_INTERRUPT);\n\tif (!ret)\n\t\tret = compat_arch_ptrace(child, request, addr, data);\n out_put_task_struct:\n\tput_task_struct(child);\n out:\n\treturn ret;\n}", "target": 1}
{"code": "Jsi_RC Jsi_ValueInsertArray(Jsi_Interp *interp, Jsi_Value *target, int key, Jsi_Value *val, int flags)\n{\n    if (target->vt != JSI_VT_OBJECT) {\n        if (interp->strict)\n            Jsi_LogWarn(\"Target is not object\");\n        return JSI_ERROR;\n    }\n    Jsi_Obj *obj = target->d.obj;\n    if (obj->isarrlist) {\n        if (key >= 0 && (uint)key < interp->maxArrayList) {\n            Jsi_ObjArraySet(interp, obj, val, key);\n            return JSI_OK;\n        }\n        return JSI_ERROR;\n    }\n    char unibuf[JSI_MAX_NUMBER_STRING];\n    Jsi_NumberItoA10(key, unibuf, sizeof(unibuf));\n    Jsi_ObjInsert(interp, obj, unibuf, val, flags);\n    return JSI_OK;\n}", "target": 0}
{"code": "R_API RCmdAliasVal *r_cmd_alias_get(RCmd *cmd, const char *k) {\n\tr_return_val_if_fail (cmd && cmd->aliases && k, NULL);\n\treturn ht_pp_find(cmd->aliases, k, NULL);\n}", "target": 1}
{"code": "pango_glyph_string_set_size (PangoGlyphString *string, gint new_len)\n{\n  g_return_if_fail (new_len >= 0);\n  while (new_len > string->space)\n    {\n      if (string->space == 0)\n\tstring->space = 1;\n      else\n\tstring->space *= 2;\n      if (string->space < 0)\n\t{\n\t  g_warning (\"glyph string length overflows maximum integer size, truncated\");\n\t  new_len = string->space = G_MAXINT - 8;\n\t}\n    }\n  string->glyphs = g_realloc (string->glyphs, string->space * sizeof (PangoGlyphInfo));\n  string->log_clusters = g_realloc (string->log_clusters, string->space * sizeof (gint));\n  string->num_glyphs = new_len;\n}", "target": 1}
{"code": "void imap_quote_string(char *dest, size_t dlen, const char *src)\n{\n  static const char quote[] = \"\\\"\\\\\";\n  char *pt = dest;\n  const char *s = src;\n  *pt++ = '\"';\n  dlen -= 2;\n  for (; *s && dlen; s++)\n  {\n    if (strchr(quote, *s))\n    {\n      dlen -= 2;\n      if (dlen == 0)\n        break;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\"';\n  *pt = '\\0';\n}", "target": 1}
{"code": "int CServer::SendMsg(CMsgPacker *pMsg, int Flags, int ClientID)\n{\n\tCNetChunk Packet;\n\tif(!pMsg)\n\t\treturn -1;\n\tif(0 <= ClientID && ClientID < MAX_CLIENTS && GameServer()->IsClientBot(ClientID))\n\t\treturn 0;\n\tmem_zero(&Packet, sizeof(CNetChunk));\n\tPacket.m_ClientID = ClientID;\n\tPacket.m_pData = pMsg->Data();\n\tPacket.m_DataSize = pMsg->Size();\n\tif(Flags&MSGFLAG_VITAL)\n\t\tPacket.m_Flags |= NETSENDFLAG_VITAL;\n\tif(Flags&MSGFLAG_FLUSH)\n\t\tPacket.m_Flags |= NETSENDFLAG_FLUSH;\n\tif(!(Flags&MSGFLAG_NORECORD))\n\t\tm_DemoRecorder.RecordMessage(pMsg->Data(), pMsg->Size());\n\tif(!(Flags&MSGFLAG_NOSEND))\n\t{\n\t\tif(ClientID == -1)\n\t\t{\n\t\t\tint i;\n\t\t\tfor(i = 0; i < MAX_CLIENTS; i++)\n\t\t\t\tif(m_aClients[i].m_State == CClient::STATE_INGAME && !m_aClients[i].m_Quitting)\n\t\t\t\t{\n\t\t\t\t\tPacket.m_ClientID = i;\n\t\t\t\t\tm_NetServer.Send(&Packet);\n\t\t\t\t}\n\t\t}\n\t\telse\n\t\t\tm_NetServer.Send(&Packet);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static inline void xen_evtchn_handle_events(unsigned cpu)\n{\n\treturn evtchn_ops->handle_events(cpu);\n}", "target": 1}
{"code": "static inline int xsave_state_booting(struct xsave_struct *fx, u64 mask)\n{\n\tu32 lmask = mask;\n\tu32 hmask = mask >> 32;\n\tint err = 0;\n\tWARN_ON(system_state != SYSTEM_BOOTING);\n\tif (boot_cpu_has(X86_FEATURE_XSAVES))\n\t\tasm volatile(\"1:\"XSAVES\"\\n\\t\"\n\t\t\t\"2:\\n\\t\"\n\t\t\t: : \"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t\t:   \"memory\");\n\telse\n\t\tasm volatile(\"1:\"XSAVE\"\\n\\t\"\n\t\t\t\"2:\\n\\t\"\n\t\t\t: : \"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t\t:   \"memory\");\n\tasm volatile(xstate_fault\n\t\t     : \"0\" (0)\n\t\t     : \"memory\");\n\treturn err;\n}", "target": 1}
{"code": "Status MakeArgTuple(const PyCall* call, TFE_Context* ctx, PyObject** tuple) {\n  int64_t n = call->ins.size();\n  PyObject* lst = PyList_New(n);\n  CHECK(lst);\n  const char* device_name = nullptr;\n  if (call->device != nullptr && !IsCPUDevice(call->device))\n    device_name = call->device->name().c_str();\n  for (int64_t i = 0; i < n; ++i) {\n    PyObject* arg = nullptr;\n    if (call->eager) {\n      Tensor t = call->ins[i];\n      arg = EagerTensorFromHandle(tensorflow::wrap(\n          tensorflow::unwrap(ctx)->CreateLocalHandleFromTFTensor(t,\n                                                                 device_name)));\n      if (arg == nullptr) {\n        Py_DECREF(lst);\n        return errors::Internal(\"Unable to procure EagerTensor from Tensor.\");\n      }\n    } else {\n      Status s = TensorToNdarray(call->ins[i], &arg);\n      if (!s.ok()) {\n        Py_DECREF(lst);\n        return s;\n      }\n      arg = PyArray_Return(reinterpret_cast<PyArrayObject*>(arg));\n    }\n    PyList_SetItem(lst, i, arg);\n  }\n  *tuple = Py_BuildValue(\"(ssN)\", call->token.c_str(), device_name, lst);\n  CHECK(*tuple);\n  return OkStatus();\n}", "target": 1}
{"code": "void mb2_cache_destroy(struct mb2_cache *cache)\n{\n\tstruct mb2_cache_entry *entry, *next;\n\tunregister_shrinker(&cache->c_shrink);\n\tlist_for_each_entry_safe(entry, next, &cache->c_lru_list, e_lru_list) {\n\t\tif (!hlist_bl_unhashed(&entry->e_hash_list)) {\n\t\t\thlist_bl_del_init(&entry->e_hash_list);\n\t\t\tatomic_dec(&entry->e_refcnt);\n\t\t} else\n\t\t\tWARN_ON(1);\n\t\tlist_del(&entry->e_lru_list);\n\t\tWARN_ON(atomic_read(&entry->e_refcnt) != 1);\n\t\tmb2_cache_entry_put(cache, entry);\n\t}\n\tkfree(cache->c_hash);\n\tkfree(cache);\n\tmodule_put(THIS_MODULE);\n}", "target": 0}
{"code": "mm_answer_pam_free_ctx(int sock, Buffer *m)\n{\n\tdebug3(\"%s\", __func__);\n\t(sshpam_device.free_ctx)(sshpam_ctxt);\n\tbuffer_clear(m);\n\tmm_request_send(sock, MONITOR_ANS_PAM_FREE_CTX, m);\n\tauth_method = \"keyboard-interactive\";\n\tauth_submethod = \"pam\";\n\treturn (sshpam_authok == sshpam_ctxt);\n}", "target": 1}
{"code": "static void ClearMetadata(VP8LMetadata* const hdr) {\n  assert(hdr != NULL);\n  WebPSafeFree(hdr->huffman_image_);\n  WebPSafeFree(hdr->huffman_tables_);\n  VP8LHtreeGroupsFree(hdr->htree_groups_);\n  VP8LColorCacheClear(&hdr->color_cache_);\n  VP8LColorCacheClear(&hdr->saved_color_cache_);\n  InitMetadata(hdr);\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    OpInputList indices_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"indices\", &indices_list_in));\n    OpInputList values_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"values\", &values_list_in));\n    OpInputList shapes_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"shapes\", &shapes_list_in));\n    OpInputList dense_list_in;\n    OP_REQUIRES_OK(context,\n                   context->input_list(\"dense_inputs\", &dense_list_in));\n    OP_REQUIRES_OK(context, ValidateInput(indices_list_in, values_list_in,\n                                          shapes_list_in, dense_list_in));\n    const Tensor* sep_t;\n    OP_REQUIRES_OK(context, context->input(\"sep\", &sep_t));\n    const tstring separator = sep_t->scalar<tstring>()();\n    std::vector<std::unique_ptr<ColumnInterface<tstring>>> columns =\n        GenerateColumnsFromInput<tstring>(indices_list_in, values_list_in,\n                                          shapes_list_in, dense_list_in);\n    Tensor* indices_out;\n    Tensor* values_out;\n    Tensor* shape_out;\n    const int64 batch_size = CalculateBatchSize(shapes_list_in, dense_list_in);\n    std::vector<int64> output_start_indices(batch_size);\n    OP_REQUIRES_OK(\n        context,\n        CreateOutputTensors(columns, batch_size, context, &indices_out,\n                            &values_out, &shape_out, &output_start_indices));\n    StringCrosser<tstring> crosser(columns, 0, 0, separator);\n    OutputUpdater<tstring> updater(output_start_indices, indices_out,\n                                   values_out);\n    auto do_work = [&columns, crosser, updater](int64 begin, int64 end) {\n      for (int b = begin; b < end; b++) {\n        ProductIterator<tstring> product_iterator(columns, b);\n        int64 cross_count = 0;\n        while (product_iterator.HasNext()) {\n          const auto permutation = product_iterator.Next();\n          updater.Update(b, cross_count,\n                         crosser.Generate(b, permutation, false));\n          cross_count++;\n        }\n      }\n    };\n    auto* worker_threads = context->device()->tensorflow_cpu_worker_threads();\n    const int kCostPerUnit = 5000 * indices_list_in.size();\n    Shard(worker_threads->num_threads, worker_threads->workers, batch_size,\n          kCostPerUnit, do_work);\n  }", "target": 1}
{"code": "json_t *json_object(void)\n{\n    json_object_t *object = jsonp_malloc(sizeof(json_object_t));\n    if(!object)\n        return NULL;\n    if (!hashtable_seed) {\n        json_object_seed(0);\n    }\n    json_init(&object->json, JSON_OBJECT);\n    if(hashtable_init(&object->hashtable))\n    {\n        jsonp_free(object);\n        return NULL;\n    }\n    object->serial = 0;\n    object->visited = 0;\n    return &object->json;\n}", "target": 0}
{"code": "void HTTPSession::onCertificateRequest(uint16_t requestId,\n                                       std::unique_ptr<IOBuf> authRequest) {\n  DestructorGuard dg(this);\n  VLOG(4) << \"CERTIFICATE_REQUEST on\" << *this << \", requestId=\" << requestId;\n  if (!secondAuthManager_) {\n    return;\n  }\n  std::pair<uint16_t, std::unique_ptr<folly::IOBuf>> authenticator;\n  auto fizzBase = getTransport()->getUnderlyingTransport<AsyncFizzBase>();\n  if (fizzBase) {\n    if (isUpstream()) {\n      authenticator =\n          secondAuthManager_->getAuthenticator(*fizzBase,\n                                               TransportDirection::UPSTREAM,\n                                               requestId,\n                                               std::move(authRequest));\n    } else {\n      authenticator =\n          secondAuthManager_->getAuthenticator(*fizzBase,\n                                               TransportDirection::DOWNSTREAM,\n                                               requestId,\n                                               std::move(authRequest));\n    }\n  } else {\n    VLOG(4) << \"Underlying transport does not support secondary \"\n               \"authentication.\";\n    return;\n  }\n  if (codec_->generateCertificate(writeBuf_,\n                                  authenticator.first,\n                                  std::move(authenticator.second)) > 0) {\n    scheduleWrite();\n  }\n}", "target": 0}
{"code": "decode_definite_long_bytestring(CBORDecoderObject *self, Py_ssize_t length)\n{\n    PyObject *buffer = NULL;\n    Py_ssize_t left = length;\n    while (left) {\n        Py_ssize_t chunk_length = length <= 65536 ? length : 65536;\n        PyObject *chunk = fp_read_object(self, chunk_length);\n        if (!chunk) {\n            break;\n        }\n        if (!PyBytes_CheckExact(chunk)) {\n            Py_DECREF(chunk);\n            break;\n        }\n        if (buffer) {\n            PyObject *new_buffer = PyByteArray_Concat(buffer, chunk);\n            Py_DECREF(chunk);\n            if (!new_buffer)\n                break;\n            if (new_buffer != buffer) {\n                Py_DECREF(buffer);\n                buffer = new_buffer;\n            }\n        } else {\n            buffer = PyByteArray_FromObject(chunk);\n            Py_DECREF(chunk);\n            if (!buffer)\n                break;\n        }\n        left -= chunk_length;\n    }\n    PyObject *ret = NULL;\n    if (buffer) {\n        ret = PyBytes_FromObject(buffer);\n        Py_DECREF(buffer);\n        if (ret && string_namespace_add(self, ret, length) == -1) {\n            Py_DECREF(ret);\n            ret = NULL;\n        }\n    }\n    return ret;\n}", "target": 0}
{"code": "midi_synth_load_patch(int dev, int format, const char __user *addr,\n\t\t      int offs, int count, int pmgr_flag)\n{\n\tint             orig_dev = synth_devs[dev]->midi_dev;\n\tstruct sysex_info sysex;\n\tint             i;\n\tunsigned long   left, src_offs, eox_seen = 0;\n\tint             first_byte = 1;\n\tint             hdr_size = (unsigned long) &sysex.data[0] - (unsigned long) &sysex;\n\tleave_sysex(dev);\n\tif (!prefix_cmd(orig_dev, 0xf0))\n\t\treturn 0;\n\tif (format != SYSEX_PATCH)\n\t{\n\t\t  return -EINVAL;\n\t}\n\tif (count < hdr_size)\n\t{\n\t\treturn -EINVAL;\n\t}\n\tcount -= hdr_size;\n\tif(copy_from_user(&((char *) &sysex)[offs], &(addr)[offs], hdr_size - offs))\n\t\treturn -EFAULT;\n \tif (count < sysex.len)\n\t{\n\t\tsysex.len = count;\n\t}\n  \tleft = sysex.len;\n  \tsrc_offs = 0;\n\tfor (i = 0; i < left && !signal_pending(current); i++)\n\t{\n\t\tunsigned char   data;\n\t\tif (get_user(data,\n\t\t    (unsigned char __user *)(addr + hdr_size + i)))\n\t\t\treturn -EFAULT;\n\t\teox_seen = (i > 0 && data & 0x80);\t\n\t\tif (eox_seen && data != 0xf7)\n\t\t\tdata = 0xf7;\n\t\tif (i == 0)\n\t\t{\n\t\t\tif (data != 0xf0)\n\t\t\t{\n\t\t\t\tprintk(KERN_WARNING \"midi_synth: Sysex start missing\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\twhile (!midi_devs[orig_dev]->outputc(orig_dev, (unsigned char) (data & 0xff)) &&\n\t\t\t!signal_pending(current))\n\t\t\tschedule();\n\t\tif (!first_byte && data & 0x80)\n\t\t\treturn 0;\n\t\tfirst_byte = 0;\n\t}\n\tif (!eox_seen)\n\t\tmidi_outc(orig_dev, 0xf7);\n\treturn 0;\n}", "target": 1}
{"code": "static int __nla_validate_parse(const struct nlattr *head, int len, int maxtype,\n\t\t\t\tconst struct nla_policy *policy,\n\t\t\t\tunsigned int validate,\n\t\t\t\tstruct netlink_ext_ack *extack,\n\t\t\t\tstruct nlattr **tb)\n{\n\tconst struct nlattr *nla;\n\tint rem;\n\tif (tb)\n\t\tmemset(tb, 0, sizeof(struct nlattr *) * (maxtype + 1));\n\tnla_for_each_attr(nla, head, len, rem) {\n\t\tu16 type = nla_type(nla);\n\t\tif (type == 0 || type > maxtype) {\n\t\t\tif (validate & NL_VALIDATE_MAXTYPE) {\n\t\t\t\tNL_SET_ERR_MSG_ATTR(extack, nla,\n\t\t\t\t\t\t    \"Unknown attribute type\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (policy) {\n\t\t\tint err = validate_nla(nla, maxtype, policy,\n\t\t\t\t\t       validate, extack);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (tb)\n\t\t\ttb[type] = (struct nlattr *)nla;\n\t}\n\tif (unlikely(rem > 0)) {\n\t\tpr_warn_ratelimited(\"netlink: %d bytes leftover after parsing attributes in process `%s'.\\n\",\n\t\t\t\t    rem, current->comm);\n\t\tNL_SET_ERR_MSG(extack, \"bytes leftover after parsing attributes\");\n\t\tif (validate & NL_VALIDATE_TRAILING)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void IdentifierHashTable::growAndRehash(uint32_t newCapacity) {\n  if (LLVM_UNLIKELY(newCapacity <= capacity())) {\n    hermes_fatal(\"too many identifiers created\");\n  }\n  assert(llvh::isPowerOf2_32(newCapacity) && \"capacity must be power of 2\");\n  CompactTable tmpTable(newCapacity, table_.getCurrentScale());\n  tmpTable.swap(table_);\n  for (uint32_t oldIdx = 0; oldIdx < tmpTable.size(); ++oldIdx) {\n    if (!tmpTable.isValid(oldIdx)) {\n      continue;\n    }\n    uint32_t idx = 0;\n    uint32_t oldVal = tmpTable.get(oldIdx);\n    auto &lookupTableEntry = identifierTable_->getLookupTableEntry(oldVal);\n    uint32_t hash = lookupTableEntry.getHash();\n    if (lookupTableEntry.isStringPrim()) {\n      idx = lookupString(lookupTableEntry.getStringPrim(), hash, true);\n    } else if (lookupTableEntry.isLazyASCII()) {\n      idx = lookupString(lookupTableEntry.getLazyASCIIRef(), hash, true);\n    } else if (lookupTableEntry.isLazyUTF16()) {\n      idx = lookupString(lookupTableEntry.getLazyUTF16Ref(), hash, true);\n    }\n    table_.set(idx, oldVal);\n  }\n  nonEmptyEntryCount_ = size_;\n}", "target": 0}
{"code": "GF_Err diST_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tchar str[1024];\n\tGF_DIMSScriptTypesBox *p = (GF_DIMSScriptTypesBox *)s;\n\ti=0;\n\tstr[0]=0;\n\twhile (1) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tif (!str[i]) break;\n\t\ti++;\n\t}\n\tISOM_DECREASE_SIZE(p, i);\n\tp->content_script_types = gf_strdup(str);\n\treturn GF_OK;\n}", "target": 1}
{"code": "static BOOL update_read_bitmap_data(rdpUpdate* update, wStream* s, BITMAP_DATA* bitmapData)\n{\n\tWINPR_UNUSED(update);\n\tif (Stream_GetRemainingLength(s) < 18)\n\t\treturn FALSE;\n\tStream_Read_UINT16(s, bitmapData->destLeft);\n\tStream_Read_UINT16(s, bitmapData->destTop);\n\tStream_Read_UINT16(s, bitmapData->destRight);\n\tStream_Read_UINT16(s, bitmapData->destBottom);\n\tStream_Read_UINT16(s, bitmapData->width);\n\tStream_Read_UINT16(s, bitmapData->height);\n\tStream_Read_UINT16(s, bitmapData->bitsPerPixel);\n\tStream_Read_UINT16(s, bitmapData->flags);\n\tStream_Read_UINT16(s, bitmapData->bitmapLength);\n\tif (bitmapData->flags & BITMAP_COMPRESSION)\n\t{\n\t\tif (!(bitmapData->flags & NO_BITMAP_COMPRESSION_HDR))\n\t\t{\n\t\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\t\treturn FALSE;\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbCompFirstRowSize); \n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbCompMainBodySize); \n\t\t\tStream_Read_UINT16(s, bitmapData->cbScanWidth);     \n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbUncompressedSize); \n\t\t\tbitmapData->bitmapLength = bitmapData->cbCompMainBodySize;\n\t\t}\n\t\tbitmapData->compressed = TRUE;\n\t}\n\telse\n\t\tbitmapData->compressed = FALSE;\n\tif (Stream_GetRemainingLength(s) < bitmapData->bitmapLength)\n\t\treturn FALSE;\n\tif (bitmapData->bitmapLength > 0)\n\t{\n\t\tbitmapData->bitmapDataStream = malloc(bitmapData->bitmapLength);\n\t\tif (!bitmapData->bitmapDataStream)\n\t\t\treturn FALSE;\n\t\tmemcpy(bitmapData->bitmapDataStream, Stream_Pointer(s), bitmapData->bitmapLength);\n\t\tStream_Seek(s, bitmapData->bitmapLength);\n\t}\n\treturn TRUE;\n}", "target": 0}
{"code": "static CPINLINE zend_class_entry* swoole_try_get_ce(zend_string *class_name)\n{\n    zend_class_entry *ce = zend_lookup_class(class_name);\n    if (ce)\n    {\n        return ce;\n    }\n    zval user_func, args[1], retval;\n    if ((PG(unserialize_callback_func) == NULL) || (PG(unserialize_callback_func)[0] == '\\0'))\n    {\n        zend_throw_exception_ex(NULL, 0, \"can not find class %s\", class_name->val TSRMLS_CC);\n        return NULL;\n    }\n    zend_string *fname = swoole_string_init(ZEND_STRL(PG(unserialize_callback_func)));\n    Z_STR(user_func) = fname;\n    Z_TYPE_INFO(user_func) = IS_STRING_EX;\n    ZVAL_STR(&args[0], class_name);\n    call_user_function_ex(CG(function_table), NULL, &user_func, &retval, 1, args, 0, NULL);\n    swoole_string_release(fname);\n    ce = zend_lookup_class(class_name);\n    if (!ce)\n    {\n        zend_throw_exception_ex(NULL, 0, \"can not find class %s\", class_name->val TSRMLS_CC);\n        return NULL;\n    }\n    else\n    {\n        return ce;\n    }\n}", "target": 1}
{"code": "static int _dns_encode_domain(struct dns_context *context, const char *domain)\n{\n\tint num = 0;\n\tint total_len = 0;\n\tunsigned char *ptr_num = context->ptr++;\n\tint dict_offset = 0;\n\tdict_offset = _dns_get_domain_offset(context, domain);\n\ttotal_len++;\n\twhile (_dns_left_len(context) > 1 && *domain != 0) {\n\t\ttotal_len++;\n\t\tif (dict_offset >= 0) {\n\t\t\tint offset = 0xc000 | dict_offset;\n\t\t\tif (_dns_left_len(context) < 2) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t_dns_write_short(&ptr_num, offset);\n\t\t\tcontext->ptr++;\n\t\t\tptr_num = NULL;\n\t\t\treturn total_len;\n\t\t}\n\t\tif (*domain == '.') {\n\t\t\t*ptr_num = num;\n\t\t\tnum = 0;\n\t\t\tptr_num = context->ptr;\n\t\t\tdomain++;\n\t\t\tcontext->ptr++;\n\t\t\tdict_offset = _dns_get_domain_offset(context, domain);\n\t\t\tcontinue;\n\t\t}\n\t\t*context->ptr = *domain;\n\t\tnum++;\n\t\tcontext->ptr++;\n\t\tdomain++;\n\t}\n\tif (_dns_left_len(context) < 1) {\n\t\treturn -1;\n\t}\n\t*ptr_num = num;\n\tif (total_len > 1) {\n\t\t*(context->ptr) = 0;\n\t\ttotal_len++;\n\t\tcontext->ptr++;\n\t}\n\tif (_dns_left_len(context) <= 0) {\n\t\treturn -1;\n\t}\n\treturn total_len;\n}", "target": 0}
{"code": "check_entry_size_and_hooks(struct ip6t_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\tif (!ip6_checkentry(&e->ipv6))\n\t\treturn -EINVAL;\n\terr = xt_check_entry_offsets(e, e->target_offset, e->next_offset);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 1}
{"code": "parse_key_constraint_extension(struct sshbuf *m, char **sk_providerp)\n{\n\tchar *ext_name = NULL;\n\tint r;\n\tif ((r = sshbuf_get_cstring(m, &ext_name, NULL)) != 0) {\n\t\terror_fr(r, \"parse constraint extension\");\n\t\tgoto out;\n\t}\n\tdebug_f(\"constraint ext %s\", ext_name);\n\tif (strcmp(ext_name, \"sk-provider@openssh.com\") == 0) {\n\t\tif (sk_providerp == NULL) {\n\t\t\terror_f(\"%s not valid here\", ext_name);\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (*sk_providerp != NULL) {\n\t\t\terror_f(\"%s already set\", ext_name);\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_cstring(m, sk_providerp, NULL)) != 0) {\n\t\t\terror_fr(r, \"parse %s\", ext_name);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\terror_f(\"unsupported constraint \\\"%s\\\"\", ext_name);\n\t\tr = SSH_ERR_FEATURE_UNSUPPORTED;\n\t\tgoto out;\n\t}\n\tr = 0;\n out:\n\tfree(ext_name);\n\treturn r;\n}", "target": 0}
{"code": "int32_t *enc_untrusted_create_wait_queue() {\n  MessageWriter input;\n  MessageReader output;\n  input.Push<uint64_t>(sizeof(int32_t));\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kLocalLifetimeAllocHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_create_wait_queue\",\n                           2);\n  int32_t *queue = reinterpret_cast<int32_t *>(output.next<uintptr_t>());\n  if (!TrustedPrimitives::IsOutsideEnclave(queue, sizeof(int32_t))) {\n    TrustedPrimitives::BestEffortAbort(\n        \"enc_untrusted_create_wait_queue: queue should be in untrusted memory\");\n  }\n  int klinux_errno = output.next<int>();\n  if (queue == nullptr) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n  }\n  enc_untrusted_disable_waiting(queue);\n  return queue;\n}", "target": 0}
{"code": "static int amdgpu_cs_wait_all_fences(struct amdgpu_device *adev,\n\t\t\t\t     struct drm_file *filp,\n\t\t\t\t     union drm_amdgpu_wait_fences *wait,\n\t\t\t\t     struct drm_amdgpu_fence *fences)\n{\n\tuint32_t fence_count = wait->in.fence_count;\n\tunsigned int i;\n\tlong r = 1;\n\tfor (i = 0; i < fence_count; i++) {\n\t\tstruct dma_fence *fence;\n\t\tunsigned long timeout = amdgpu_gem_timeout(wait->in.timeout_ns);\n\t\tfence = amdgpu_cs_get_fence(adev, filp, &fences[i]);\n\t\tif (IS_ERR(fence))\n\t\t\treturn PTR_ERR(fence);\n\t\telse if (!fence)\n\t\t\tcontinue;\n\t\tr = dma_fence_wait_timeout(fence, true, timeout);\n\t\tdma_fence_put(fence);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t\tif (r == 0)\n\t\t\tbreak;\n\t\tif (fence->error)\n\t\t\treturn fence->error;\n\t}\n\tmemset(wait, 0, sizeof(*wait));\n\twait->out.status = (r > 0);\n\treturn 0;\n}", "target": 1}
{"code": "static long media_device_enum_entities(struct media_device *mdev,\n\t\t\t\t       struct media_entity_desc __user *uent)\n{\n\tstruct media_entity *ent;\n\tstruct media_entity_desc u_ent;\n\tmemset(&u_ent, 0, sizeof(u_ent));\n\tif (copy_from_user(&u_ent.id, &uent->id, sizeof(u_ent.id)))\n\t\treturn -EFAULT;\n\tent = find_entity(mdev, u_ent.id);\n\tif (ent == NULL)\n\t\treturn -EINVAL;\n\tu_ent.id = ent->id;\n\tif (ent->name) {\n\t\tstrncpy(u_ent.name, ent->name, sizeof(u_ent.name));\n\t\tu_ent.name[sizeof(u_ent.name) - 1] = '\\0';\n\t} else {\n\t\tmemset(u_ent.name, 0, sizeof(u_ent.name));\n\t}\n\tu_ent.type = ent->type;\n\tu_ent.revision = ent->revision;\n\tu_ent.flags = ent->flags;\n\tu_ent.group_id = ent->group_id;\n\tu_ent.pads = ent->num_pads;\n\tu_ent.links = ent->num_links - ent->num_backlinks;\n\tmemcpy(&u_ent.raw, &ent->info, sizeof(ent->info));\n\tif (copy_to_user(uent, &u_ent, sizeof(u_ent)))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 0}
{"code": "void mctp_dev_put(struct mctp_dev *mdev)\n{\n\tif (mdev && refcount_dec_and_test(&mdev->refs)) {\n\t\tkfree(mdev->addrs);\n\t\tdev_put(mdev->dev);\n\t\tkfree_rcu(mdev, rcu);\n\t}\n}", "target": 0}
{"code": "static int __netdev_printk(const char *level, const struct net_device *dev,\n\t\t\t   struct va_format *vaf)\n{\n\tint r;\n\tif (dev && dev->dev.parent)\n\t\tr = dev_printk(level, dev->dev.parent, \"%s: %pV\",\n\t\t\t       netdev_name(dev), vaf);\n\telse if (dev)\n\t\tr = printk(\"%s%s: %pV\", level, netdev_name(dev), vaf);\n\telse\n\t\tr = printk(\"%s(NULL net_device): %pV\", level, vaf);\n\treturn r;\n}", "target": 0}
{"code": "int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu, struct kvm_run *run)\n{\n\tint ret;\n\tsigset_t sigsaved;\n\tif (unlikely(vcpu->arch.target < 0))\n\t\treturn -ENOEXEC;\n\tret = kvm_vcpu_first_run_init(vcpu);\n\tif (ret)\n\t\treturn ret;\n\tif (run->exit_reason == KVM_EXIT_MMIO) {\n\t\tret = kvm_handle_mmio_return(vcpu, vcpu->run);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (vcpu->sigset_active)\n\t\tsigprocmask(SIG_SETMASK, &vcpu->sigset, &sigsaved);\n\tret = 1;\n\trun->exit_reason = KVM_EXIT_UNKNOWN;\n\twhile (ret > 0) {\n\t\tcond_resched();\n\t\tupdate_vttbr(vcpu->kvm);\n\t\tif (vcpu->arch.pause)\n\t\t\tvcpu_pause(vcpu);\n\t\tkvm_vgic_flush_hwstate(vcpu);\n\t\tkvm_timer_flush_hwstate(vcpu);\n\t\tlocal_irq_disable();\n\t\tif (signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\trun->exit_reason = KVM_EXIT_INTR;\n\t\t}\n\t\tif (ret <= 0 || need_new_vmid_gen(vcpu->kvm)) {\n\t\t\tlocal_irq_enable();\n\t\t\tkvm_timer_sync_hwstate(vcpu);\n\t\t\tkvm_vgic_sync_hwstate(vcpu);\n\t\t\tcontinue;\n\t\t}\n\t\ttrace_kvm_entry(*vcpu_pc(vcpu));\n\t\tkvm_guest_enter();\n\t\tvcpu->mode = IN_GUEST_MODE;\n\t\tret = kvm_call_hyp(__kvm_vcpu_run, vcpu);\n\t\tvcpu->mode = OUTSIDE_GUEST_MODE;\n\t\tvcpu->arch.last_pcpu = smp_processor_id();\n\t\tkvm_guest_exit();\n\t\ttrace_kvm_exit(*vcpu_pc(vcpu));\n\t\tlocal_irq_enable();\n\t\tkvm_timer_sync_hwstate(vcpu);\n\t\tkvm_vgic_sync_hwstate(vcpu);\n\t\tret = handle_exit(vcpu, run, ret);\n\t}\n\tif (vcpu->sigset_active)\n\t\tsigprocmask(SIG_SETMASK, &sigsaved, NULL);\n\treturn ret;\n}", "target": 1}
{"code": "int __cil_build_ast_last_child_helper(struct cil_tree_node *parse_current, void *extra_args)\n{\n\tstruct cil_args_build *args = extra_args;\n\tstruct cil_tree_node *ast = args->ast;\n\tif (ast->flavor == CIL_ROOT) {\n\t\treturn SEPOL_OK;\n\t}\n\targs->ast = ast->parent;\n\tif (ast->flavor == CIL_TUNABLEIF) {\n\t\targs->tunif = NULL;\n\t}\n\tif (ast->flavor == CIL_IN) {\n\t\targs->in = NULL;\n\t}\n\tif (ast->flavor == CIL_MACRO) {\n\t\targs->macro = NULL;\n\t}\n\tif (ast->flavor == CIL_OPTIONAL) {\n\t\tstruct cil_tree_node *n = ast->parent;\n\t\targs->optional = NULL;\n\t\twhile (n && n->flavor != CIL_ROOT) {\n\t\t\tif (n->flavor == CIL_OPTIONAL) {\n\t\t\t\targs->optional = n;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn = n->parent;\n\t\t}\n\t}\n\tif (ast->flavor == CIL_BOOLEANIF) {\n\t\targs->boolif = NULL;\n\t}\n\tcil_tree_children_destroy(parse_current->parent);\n\treturn SEPOL_OK;\n}", "target": 0}
{"code": "    OVS_REQUIRES(ofproto_mutex)\n{\n    const struct rule_actions *actions = rule_get_actions(rule);\n    ovs_assert(rule->state == RULE_INITIALIZED);\n    if (rule->hard_timeout || rule->idle_timeout) {\n        ovs_list_insert(&ofproto->expirable, &rule->expirable);\n    }\n    cookies_insert(ofproto, rule);\n    eviction_group_add_rule(rule);\n    if (actions->has_meter) {\n        meter_insert_rule(rule);\n    }\n    if (actions->has_groups) {\n        const struct ofpact_group *a;\n        OFPACT_FOR_EACH_TYPE_FLATTENED (a, GROUP, actions->ofpacts,\n                                        actions->ofpacts_len) {\n            struct ofgroup *group;\n            group = ofproto_group_lookup(ofproto, a->group_id, OVS_VERSION_MAX,\n                                         false);\n            ovs_assert(group != NULL);\n            group_add_rule(group, rule);\n        }\n    }\n    rule->state = RULE_INSERTED;\n}", "target": 1}
{"code": "void migrate_page_copy(struct page *newpage, struct page *page)\n{\n\tint cpupid;\n\tif (PageHuge(page) || PageTransHuge(page))\n\t\tcopy_huge_page(newpage, page);\n\telse\n\t\tcopy_highpage(newpage, page);\n\tif (PageError(page))\n\t\tSetPageError(newpage);\n\tif (PageReferenced(page))\n\t\tSetPageReferenced(newpage);\n\tif (PageUptodate(page))\n\t\tSetPageUptodate(newpage);\n\tif (TestClearPageActive(page)) {\n\t\tVM_BUG_ON_PAGE(PageUnevictable(page), page);\n\t\tSetPageActive(newpage);\n\t} else if (TestClearPageUnevictable(page))\n\t\tSetPageUnevictable(newpage);\n\tif (PageChecked(page))\n\t\tSetPageChecked(newpage);\n\tif (PageMappedToDisk(page))\n\t\tSetPageMappedToDisk(newpage);\n\tif (PageDirty(page)) {\n\t\tclear_page_dirty_for_io(page);\n\t\tif (PageSwapBacked(page))\n\t\t\tSetPageDirty(newpage);\n\t\telse\n\t\t\t__set_page_dirty_nobuffers(newpage);\n \t}\n\tif (page_is_young(page))\n\t\tset_page_young(newpage);\n\tif (page_is_idle(page))\n\t\tset_page_idle(newpage);\n\tcpupid = page_cpupid_xchg_last(page, -1);\n\tpage_cpupid_xchg_last(newpage, cpupid);\n\tksm_migrate_page(newpage, page);\n\tif (PageSwapCache(page))\n\t\tClearPageSwapCache(page);\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tif (PageWriteback(newpage))\n\t\tend_page_writeback(newpage);\n}", "target": 1}
{"code": "static inline int unicode_cp_is_allowed(unsigned uni_cp, int document_type)\n{\n\tswitch (document_type) {\n\tcase ENT_HTML_DOC_HTML401:\n\t\treturn (uni_cp >= 0x20 && uni_cp <= 0x7E) ||\n\t\t\t(uni_cp == 0x0A || uni_cp == 0x09 || uni_cp == 0x0D) ||\n\t\t\t(uni_cp >= 0xA0 && uni_cp <= 0xD7FF) ||\n\t\t\t(uni_cp >= 0xE000 && uni_cp <= 0x10FFFF);\n\tcase ENT_HTML_DOC_HTML5:\n\t\treturn (uni_cp >= 0x20 && uni_cp <= 0x7E) ||\n\t\t\t(uni_cp >= 0x09 && uni_cp <= 0x0D && uni_cp != 0x0B) || \n\t\t\t(uni_cp >= 0xA0 && uni_cp <= 0xD7FF) ||\n\t\t\t(uni_cp >= 0xE000 && uni_cp <= 0x10FFFF &&\n\t\t\t\t((uni_cp & 0xFFFF) < 0xFFFE) && \n\t\t\t\t(uni_cp < 0xFDD0 || uni_cp > 0xFDEF)); \n\tcase ENT_HTML_DOC_XHTML:\n\tcase ENT_HTML_DOC_XML1:\n\t\treturn (uni_cp >= 0x20 && uni_cp <= 0xD7FF) ||\n\t\t\t(uni_cp == 0x0A || uni_cp == 0x09 || uni_cp == 0x0D) ||\n\t\t\t(uni_cp >= 0xE000 && uni_cp <= 0x10FFFF && uni_cp != 0xFFFE && uni_cp != 0xFFFF);\n\tdefault:\n\t\treturn 1;\n\t}\n}", "target": 1}
{"code": "void CLASS kodak_65000_load_raw()\n{\n  short buf[256];\n  int row, col, len, pred[2], ret, i;\n  for (row=0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < width; col+=256) {\n      pred[0] = pred[1] = 0;\n      len = MIN (256, width-col);\n      ret = kodak_65000_decode (buf, len);\n      for (i=0; i < len; i++)\n\tif ((RAW(row,col+i) =\tcurve[ret ? buf[i] :\n\t\t(pred[i & 1] += buf[i])]) >> 12) derror();\n    }\n  }\n}", "target": 1}
{"code": "quant::UniformQuantizedPerAxisType ResetAxisAndBroadcast(\n    ArrayRef<int64_t> shape, quant::UniformQuantizedPerAxisType qtype,\n    Type target, int quant_dim) {\n  auto shaped = target.dyn_cast<RankedTensorType>();\n  if (!shaped) return {};\n  ArrayRef<int64_t> new_shape = shaped.getShape();\n  SmallVector<double, 4> scales(qtype.getScales().begin(),\n                                qtype.getScales().end());\n  SmallVector<int64_t, 4> zero_points(qtype.getZeroPoints().begin(),\n                                      qtype.getZeroPoints().end());\n  if (new_shape.size() == shape.size()) {  \n    if (BroadcastVector<double>(shaped.getDimSize(quant_dim), scales) ||\n        BroadcastVector<int64_t>(shaped.getDimSize(quant_dim), zero_points)) {\n      return {};\n    }\n  } else if ((new_shape.size() == shape.size() + 1) && new_shape.back() == 1) {\n    if (std::equal(shape.begin(), shape.end(), new_shape.begin()) &&\n        quant_dim == -1) {\n      quant_dim = shape.size() + quant_dim;\n    } else {\n      return {};\n    }\n  } else {\n    return {};\n  }\n  return quant::UniformQuantizedPerAxisType::get(\n      qtype.getFlags(), qtype.getStorageType(), qtype.getExpressedType(),\n      scales, zero_points, quant_dim, qtype.getStorageTypeMin(),\n      qtype.getStorageTypeMax());\n}", "target": 1}
{"code": "int jvp_number_cmp(jv a, jv b) {\n  assert(JVP_HAS_KIND(a, JV_KIND_NUMBER));\n  assert(JVP_HAS_KIND(b, JV_KIND_NUMBER));\n#ifdef USE_DECNUM\n  if (JVP_HAS_FLAGS(a, JVP_FLAGS_NUMBER_LITERAL) && JVP_HAS_FLAGS(b, JVP_FLAGS_NUMBER_LITERAL)) {\n    decNumber res;\n    decNumberCompare(&res,\n                     jvp_dec_number_ptr(a),\n                     jvp_dec_number_ptr(b),\n                     DEC_CONTEXT()\n                     );\n    if (decNumberIsZero(&res)) {\n      return 0;\n    } else if (decNumberIsNegative(&res)) {\n      return -1;\n    } else {\n      return 1;\n    }\n  }\n#endif\n  double da = jv_number_value(a), db = jv_number_value(b);\n  if (da < db) {\n    return -1;\n  } else if (da == db) {\n    return 0;\n  } else {\n    return 1;\n  }\n}", "target": 1}
{"code": "static int nft_flush_table(struct nft_ctx *ctx)\n{\n\tint err;\n\tstruct nft_chain *chain, *nc;\n\tstruct nft_set *set, *ns;\n\tlist_for_each_entry_safe(chain, nc, &ctx->table->chains, list) {\n\t\tctx->chain = chain;\n\t\terr = nft_delrule_by_chain(ctx);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\terr = nft_delchain(ctx);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\tlist_for_each_entry_safe(set, ns, &ctx->table->sets, list) {\n\t\tif (set->flags & NFT_SET_ANONYMOUS &&\n\t\t    !list_empty(&set->bindings))\n\t\t\tcontinue;\n\t\terr = nft_delset(ctx, set);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\terr = nft_deltable(ctx);\nout:\n\treturn err;\n}", "target": 1}
{"code": "static inline void fsnotify_oldname_free(const unsigned char *old_name)\n{\n\tkfree(old_name);\n}", "target": 1}
{"code": "int vm_iomap_memory(struct vm_area_struct *vma, phys_addr_t start, unsigned long len)\n{\n\tunsigned long vm_len, pfn, pages;\n\tif (start + len < start)\n\t\treturn -EINVAL;\n\tlen += start & ~PAGE_MASK;\n\tpfn = start >> PAGE_SHIFT;\n\tpages = (len + ~PAGE_MASK) >> PAGE_SHIFT;\n\tif (pfn + pages < pfn)\n\t\treturn -EINVAL;\n\tif (vma->vm_pgoff > pages)\n\t\treturn -EINVAL;\n\tpfn += vma->vm_pgoff;\n\tpages -= vma->vm_pgoff;\n\tvm_len = vma->vm_end - vma->vm_start;\n\tif (vm_len >> PAGE_SHIFT > pages)\n\t\treturn -EINVAL;\n\treturn io_remap_pfn_range(vma, vma->vm_start, pfn, vm_len, vma->vm_page_prot);\n}", "target": 0}
{"code": "static int hci_sock_getname(struct socket *sock, struct sockaddr *addr,\n\t\t\t    int *addr_len, int peer)\n{\n\tstruct sockaddr_hci *haddr = (struct sockaddr_hci *) addr;\n\tstruct sock *sk = sock->sk;\n\tstruct hci_dev *hdev = hci_pi(sk)->hdev;\n\tBT_DBG(\"sock %p sk %p\", sock, sk);\n\tif (!hdev)\n\t\treturn -EBADFD;\n\tlock_sock(sk);\n\t*addr_len = sizeof(*haddr);\n\thaddr->hci_family = AF_BLUETOOTH;\n\thaddr->hci_dev    = hdev->id;\n\thaddr->hci_channel= 0;\n\trelease_sock(sk);\n\treturn 0;\n}", "target": 0}
{"code": "static int __init random_int_secret_init(void)\n{\n\tget_random_bytes(random_int_secret, sizeof(random_int_secret));\n\treturn 0;\n}", "target": 0}
{"code": "void KPasswordDlg::keyPressed( QKeyEvent *e )\n{\n  static bool waitForAuthentication = false;\n  if (!waitForAuthentication) {\n\tswitch ( e->key() )\n\t{\n\t\tcase Key_Backspace:\n\t\t\t{\n\t\t\t\tint len = password.length();\n\t\t\t\tif ( len ) {\n\t\t\t\t\tpassword.truncate( len - 1 );\n\t\t\t\t\tif( stars )\n\t\t\t\t\t\tshowStars();\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Key_Return:\n            timer.stop();\n\t\t\twaitForAuthentication = true;\n\t\t\tif ( tryPassword() )\n\t\t\t\temit passOk();\n\t\t\telse\n\t\t\t{\n\t\t\t\tlabel->setText( glocale->translate(\"Failed\") );\n\t\t\t\tpassword = \"\";\n\t\t\t\ttimerMode = 1;\n\t\t\t\ttimer.start( 1500, TRUE );\n\t\t\t}\n\t\t\twaitForAuthentication = false;\n\t\t\tbreak;\n\t\tcase Key_Escape:\n\t\t\temit passCancel();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif ( password.length() < MAX_PASSWORD_LENGTH )\n\t\t\t{\n\t\t\t\tpassword += (char)e->ascii();\n\t\t\t\tif( stars )\n\t\t\t\t\tshowStars();\n\t\t\t\ttimer.changeInterval( 10000 );\n\t\t\t}\n\t}\n  }\n}", "target": 0}
{"code": "char *gf_bt_get_next(GF_BTParser *parser, Bool point_break)\n{\n\tu32 has_quote;\n\tBool go = 1;\n\ts32 i;\n\tgf_bt_check_line(parser);\n\ti=0;\n\thas_quote = 0;\n\twhile (go) {\n\t\tif (parser->line_buffer[parser->line_pos + i] == '\\\"') {\n\t\t\tif (!has_quote) has_quote = 1;\n\t\t\telse has_quote = 0;\n\t\t\tparser->line_pos += 1;\n\t\t\tif (parser->line_pos+i==parser->line_size) break;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!has_quote) {\n\t\t\tswitch (parser->line_buffer[parser->line_pos + i]) {\n\t\t\tcase 0:\n\t\t\tcase ' ':\n\t\t\tcase '\\t':\n\t\t\tcase '\\r':\n\t\t\tcase '\\n':\n\t\t\tcase '{':\n\t\t\tcase '}':\n\t\t\tcase ']':\n\t\t\tcase '[':\n\t\t\tcase ',':\n\t\t\t\tgo = 0;\n\t\t\t\tbreak;\n\t\t\tcase '.':\n\t\t\t\tif (point_break) go = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!go) break;\n\t\t}\n\t\tparser->cur_buffer[i] = parser->line_buffer[parser->line_pos + i];\n\t\ti++;\n\t\tif (parser->line_pos+i==parser->line_size) break;\n\t}\n\tparser->cur_buffer[i] = 0;\n\tparser->line_pos += i;\n\treturn parser->cur_buffer;\n}", "target": 1}
{"code": "int addrconf_sysctl_mtu(struct ctl_table *ctl, int write,\n\t\t\tvoid __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct inet6_dev *idev = ctl->extra1;\n\tint min_mtu = IPV6_MIN_MTU;\n\tstruct ctl_table lctl;\n\tlctl = *ctl;\n\tlctl.extra1 = &min_mtu;\n\tlctl.extra2 = idev ? &idev->dev->mtu : NULL;\n\treturn proc_dointvec_minmax(&lctl, write, buffer, lenp, ppos);\n}", "target": 0}
{"code": "static uint32_t scsi_init_iovec(SCSIDiskReq *r)\n{\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    if (!r->iov.iov_base) {\n        r->buflen = SCSI_DMA_BUF_SIZE;\n        r->iov.iov_base = qemu_blockalign(s->bs, r->buflen);\n    }\n    r->iov.iov_len = MIN(r->sector_count * 512, r->buflen);\n    qemu_iovec_init_external(&r->qiov, &r->iov, 1);\n    return r->qiov.size / 512;\n}", "target": 0}
{"code": "int jas_stream_pad(jas_stream_t *stream, int n, int c)\n{\n\tint m;\n\tif (n < 0) {\n\t\tjas_deprecated(\"negative count for jas_stream_pad\");\n\t}\n\tm = n;\n\tfor (m = n; m > 0; --m) {\n\t\tif (jas_stream_putc(stream, c) == EOF)\n\t\t\treturn n - m;\n\t}\n\treturn n;\n}", "target": 0}
{"code": "static long pipe_set_size(struct pipe_inode_info *pipe, unsigned long nr_pages)\n{\n\tstruct pipe_buffer *bufs;\n\tif (nr_pages < pipe->nrbufs)\n\t\treturn -EBUSY;\n\tbufs = kcalloc(nr_pages, sizeof(*bufs), GFP_KERNEL | __GFP_NOWARN);\n\tif (unlikely(!bufs))\n\t\treturn -ENOMEM;\n\tif (pipe->nrbufs) {\n\t\tunsigned int tail;\n\t\tunsigned int head;\n\t\ttail = pipe->curbuf + pipe->nrbufs;\n\t\tif (tail < pipe->buffers)\n\t\t\ttail = 0;\n\t\telse\n\t\t\ttail &= (pipe->buffers - 1);\n\t\thead = pipe->nrbufs - tail;\n\t\tif (head)\n\t\t\tmemcpy(bufs, pipe->bufs + pipe->curbuf, head * sizeof(struct pipe_buffer));\n\t\tif (tail)\n\t\t\tmemcpy(bufs + head, pipe->bufs, tail * sizeof(struct pipe_buffer));\n\t}\n\taccount_pipe_buffers(pipe, pipe->buffers, nr_pages);\n\tpipe->curbuf = 0;\n\tkfree(pipe->bufs);\n\tpipe->bufs = bufs;\n\tpipe->buffers = nr_pages;\n\treturn nr_pages * PAGE_SIZE;\n}", "target": 0}
{"code": "static void infra_ip_create_ratedata(struct infra_cache* infra,\n\tstruct sockaddr_storage* addr, socklen_t addrlen, time_t timenow)\n{\n\thashvalue_type h = hash_addr(addr, addrlen, 0);\n\tstruct ip_rate_key* k = (struct ip_rate_key*)calloc(1, sizeof(*k));\n\tstruct ip_rate_data* d = (struct ip_rate_data*)calloc(1, sizeof(*d));\n\tif(!k || !d) {\n\t\tfree(k);\n\t\tfree(d);\n\t\treturn; \n\t}\n\tk->addr = *addr;\n\tk->addrlen = addrlen;\n\tlock_rw_init(&k->entry.lock);\n\tk->entry.hash = h;\n\tk->entry.key = k;\n\tk->entry.data = d;\n\td->qps[0] = 1;\n\td->timestamp[0] = timenow;\n\tslabhash_insert(infra->client_ip_rates, h, &k->entry, d, NULL);\n}", "target": 1}
{"code": "struct mb2_cache_entry *mb2_cache_entry_find_first(struct mb2_cache *cache,\n\t\t\t\t\t\t   u32 key)\n{\n\treturn __entry_find(cache, NULL, key);\n}", "target": 0}
{"code": "pidfile_write(const char *pid_file, int pid)\n{\n\tFILE *pidfile = NULL;\n\tint pidfd = creat(pid_file, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (pidfd != -1) pidfile = fdopen(pidfd, \"w\");\n\tif (!pidfile) {\n\t\tlog_message(LOG_INFO, \"pidfile_write : Cannot open %s pidfile\",\n\t\t       pid_file);\n\t\treturn 0;\n\t}\n\tfprintf(pidfile, \"%d\\n\", pid);\n\tfclose(pidfile);\n\treturn 1;\n}", "target": 1}
{"code": "struct mb2_cache_entry *mb2_cache_entry_find_next(struct mb2_cache *cache,\n\t\t\t\t\t\t  struct mb2_cache_entry *entry)\n{\n\treturn __entry_find(cache, entry, entry->e_key);\n}", "target": 0}
{"code": "jp2_box_t *jp2_box_create(int type)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n\t\treturn 0;\n\t}\n\tmemset(box, 0, sizeof(jp2_box_t));\n\tbox->type = type;\n\tbox->len = 0;\n\tif (!(boxinfo = jp2_boxinfolookup(type))) {\n\t\treturn 0;\n\t}\n\tbox->info = boxinfo;\n\tbox->ops = &boxinfo->ops;\n\treturn box;\n}", "target": 1}
{"code": "crm_recv_tls(gnutls_session * session, size_t max_size, size_t *recv_len, int *disconnected)\n{\n    char *buf = NULL;\n    int rc = 0;\n    size_t len = 0;\n    size_t chunk_size = max_size ? max_size : 1024;\n    size_t buf_size = 0;\n    size_t read_size = 0;\n    if (session == NULL) {\n        if (disconnected) {\n            *disconnected = 1;\n        }\n        goto done;\n    }\n    buf = calloc(1, chunk_size + 1);\n    buf_size = chunk_size;\n    while (TRUE) {\n        read_size = buf_size - len;\n        if (!max_size && (read_size < (chunk_size / 2))) {\n            buf_size += chunk_size;\n            crm_trace(\"Grow buffer by %d more bytes. buf is now %d bytes\", (int)chunk_size, buf_size);\n            buf = realloc(buf, buf_size + 1);\n            CRM_ASSERT(buf != NULL);\n            read_size = buf_size - len;\n        }\n        rc = gnutls_record_recv(*session, buf + len, read_size);\n        if (rc > 0) {\n            crm_trace(\"Got %d more bytes.\", rc);\n            len += rc;\n            buf[len] = '\\0';\n        }\n        if (max_size && (max_size == read_size)) {\n            crm_trace(\"Buffer max read size %d met\" , max_size);\n            goto done;\n        }\n        if (rc == GNUTLS_E_INTERRUPTED) {\n            crm_trace(\"EINTR encoutered, retry tls read\");\n        } else if (rc == GNUTLS_E_AGAIN) {\n            crm_trace(\"non-blocking, exiting read on rc = %d\", rc);\n            goto done;\n        } else if (rc <= 0) {\n            if (rc == 0) {\n                crm_debug(\"EOF encoutered during TLS read\");\n            } else {\n                crm_debug(\"Error receiving message: %s (%d)\", gnutls_strerror(rc), rc);\n            }\n            if (disconnected) {\n                *disconnected = 1;\n            }\n            goto done;\n        }\n    }\ndone:\n    if (recv_len) {\n        *recv_len = len;\n    }\n    if (!len) {\n        free(buf);\n        buf = NULL;\n    }\n    return buf;\n}", "target": 0}
{"code": "crm_initiate_client_tls_handshake(void *session_data, int timeout_ms)\n{\n    int rc = 0;\n    int pollrc = 0;\n    time_t start = time(NULL);\n    gnutls_session *session = session_data;\n    do {\n        rc = gnutls_handshake(*session);\n        if (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN) {\n            pollrc = crm_recv_remote_ready(session, TRUE, 1000);\n            if (pollrc < 0) {\n                rc = -1;\n            }\n        }\n    } while (((time(NULL) - start) < (timeout_ms/1000)) &&\n            (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN));\n    return rc;\n}", "target": 0}
{"code": "static int install_thread_keyring(void)\n{\n\tstruct cred *new;\n\tint ret;\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\tBUG_ON(new->thread_keyring);\n\tret = install_thread_keyring_to_cred(new);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\treturn ret;\n\t}\n\treturn commit_creds(new);\n}", "target": 1}
{"code": "aodv_extension(netdissect_options *ndo,\n               const struct aodv_ext *ep, u_int length)\n{\n\tconst struct aodv_hello *ah;\n\tND_TCHECK(*ep);\n\tswitch (ep->type) {\n\tcase AODV_EXT_HELLO:\n\t\tah = (const struct aodv_hello *)(const void *)ep;\n\t\tND_TCHECK(*ah);\n\t\tif (length < sizeof(struct aodv_hello))\n\t\t\tgoto trunc;\n\t\tif (ep->length < 4) {\n\t\t\tND_PRINT((ndo, \"\\n\\text HELLO - bad length %u\", ep->length));\n\t\t\tbreak;\n\t\t}\n\t\tND_PRINT((ndo, \"\\n\\text HELLO %ld ms\",\n\t\t    (unsigned long)EXTRACT_32BITS(&ah->interval)));\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \"\\n\\text %u %u\", ep->type, ep->length));\n\t\tbreak;\n\t}\n\treturn;\ntrunc:\n\tND_PRINT((ndo, \" [|hello]\"));\n}", "target": 0}
{"code": "int luaopen_x509(lua_State *L)\n{\n  auxiliar_newclass(L, \"openssl.x509\", x509_funcs);\n  lua_newtable(L);\n  luaL_setfuncs(L, R, 0);\n  openssl_register_xname(L);\n  lua_setfield(L, -2, \"name\");\n  openssl_register_xattribute(L);\n  lua_setfield(L, -2, \"attribute\");\n  openssl_register_xextension(L);\n  lua_setfield(L, -2, \"extension\");\n  openssl_register_xstore(L);\n  lua_setfield(L, -2, \"store\");\n  openssl_register_xalgor(L);\n  lua_setfield(L, -2, \"algor\");\n  luaopen_x509_req(L);\n  lua_setfield(L, -2, \"req\");\n  luaopen_x509_crl(L);\n  lua_setfield(L, -2, \"crl\");\n  lua_pushliteral(L, \"version\");    \n  lua_pushliteral(L, MYVERSION);\n  lua_settable(L, -3);\n#if OPENSSL_VERSION_NUMBER > 0x10002000L\n  lua_pushliteral(L, \"check_flag\");\n  lua_newtable(L);\n  auxiliar_enumerate(L, -1, check_flags_const);\n  lua_settable(L, -3);\n#endif\n  return 1;\n}", "target": 0}
{"code": "void unlink_anon_vmas(struct vm_area_struct *vma)\n{\n\tstruct anon_vma_chain *avc, *next;\n\tstruct anon_vma *root = NULL;\n\tlist_for_each_entry_safe(avc, next, &vma->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma = avc->anon_vma;\n\t\troot = lock_anon_vma_root(root, anon_vma);\n\t\tanon_vma_interval_tree_remove(avc, &anon_vma->rb_root);\n\t\tif (RB_EMPTY_ROOT(&anon_vma->rb_root.rb_root)) {\n\t\t\tanon_vma->parent->degree--;\n\t\t\tcontinue;\n\t\t}\n\t\tlist_del(&avc->same_vma);\n\t\tanon_vma_chain_free(avc);\n\t}\n\tif (vma->anon_vma) {\n\t\tvma->anon_vma->degree--;\n\t\tvma->anon_vma = NULL;\n\t}\n\tunlock_anon_vma_root(root);\n\tlist_for_each_entry_safe(avc, next, &vma->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma = avc->anon_vma;\n\t\tVM_WARN_ON(anon_vma->degree);\n\t\tput_anon_vma(anon_vma);\n\t\tlist_del(&avc->same_vma);\n\t\tanon_vma_chain_free(avc);\n\t}\n}", "target": 1}
{"code": "transientObjectPutErrorMessage(Runtime *runtime, Handle<> base, SymbolID id) {\n  StringView propName =\n      runtime->getIdentifierTable().getStringView(runtime, id);\n  Handle<StringPrimitive> baseType =\n      runtime->makeHandle(vmcast<StringPrimitive>(typeOf(runtime, base)));\n  StringView baseTypeAsString =\n      StringPrimitive::createStringView(runtime, baseType);\n  MutableHandle<StringPrimitive> valueAsString{runtime};\n  if (base->isSymbol()) {\n    auto str = symbolDescriptiveString(runtime, Handle<SymbolID>::vmcast(base));\n    if (str != ExecutionStatus::EXCEPTION) {\n      valueAsString = *str;\n    } else {\n      runtime->clearThrownValue();\n      valueAsString = StringPrimitive::createNoThrow(\n          runtime, \"<<Exception occurred getting the value>>\");\n    }\n  } else {\n    auto str = toString_RJS(runtime, base);\n    assert(\n        str != ExecutionStatus::EXCEPTION &&\n        \"Primitives should be convertible to string without exceptions\");\n    valueAsString = std::move(*str);\n  }\n  StringView valueAsStringPrintable =\n      StringPrimitive::createStringView(runtime, valueAsString);\n  SmallU16String<32> tmp;\n  return runtime->raiseTypeError(\n      TwineChar16(\"Cannot create property '\") + propName + \"' on \" +\n      baseTypeAsString.getUTF16Ref(tmp) + \" '\" +\n      valueAsStringPrintable.getUTF16Ref(tmp) + \"'\");\n}", "target": 1}
{"code": "static inline void SMTPTransactionComplete(SMTPState *state)\n{\n    DEBUG_VALIDATE_BUG_ON(state->curr_tx == NULL);\n    if (state->curr_tx)\n        state->curr_tx->done = 1;\n}", "target": 1}
{"code": "  explicit SparseCrossOp(OpKernelConstruction* context) : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_buckets\", &num_buckets_));\n    int64 signed_hash_key_;\n    OP_REQUIRES_OK(context, context->GetAttr(\"hash_key\", &signed_hash_key_));\n    hash_key_ = static_cast<uint64>(signed_hash_key_);\n    OP_REQUIRES_OK(context, context->GetAttr(\"internal_type\", &internal_type_));\n  }", "target": 0}
{"code": "static bool access_pmu_evcntr(struct kvm_vcpu *vcpu,\n\t\t\t      struct sys_reg_params *p,\n\t\t\t      const struct sys_reg_desc *r)\n{\n\tu64 idx;\n\tif (!kvm_arm_pmu_v3_ready(vcpu))\n\t\treturn trap_raz_wi(vcpu, p, r);\n\tif (r->CRn == 9 && r->CRm == 13) {\n\t\tif (r->Op2 == 2) {\n\t\t\tif (pmu_access_event_counter_el0_disabled(vcpu))\n\t\t\t\treturn false;\n\t\t\tidx = vcpu_sys_reg(vcpu, PMSELR_EL0)\n\t\t\t      & ARMV8_PMU_COUNTER_MASK;\n\t\t} else if (r->Op2 == 0) {\n\t\t\tif (pmu_access_cycle_counter_el0_disabled(vcpu))\n\t\t\t\treturn false;\n\t\t\tidx = ARMV8_PMU_CYCLE_IDX;\n\t\t} else {\n\t\t\tBUG();\n\t\t}\n\t} else if (r->CRn == 14 && (r->CRm & 12) == 8) {\n\t\tif (pmu_access_event_counter_el0_disabled(vcpu))\n\t\t\treturn false;\n\t\tidx = ((r->CRm & 3) << 3) | (r->Op2 & 7);\n\t} else {\n\t\tBUG();\n\t}\n\tif (!pmu_counter_idx_valid(vcpu, idx))\n\t\treturn false;\n\tif (p->is_write) {\n\t\tif (pmu_access_el0_disabled(vcpu))\n\t\t\treturn false;\n\t\tkvm_pmu_set_counter_value(vcpu, idx, p->regval);\n\t} else {\n\t\tp->regval = kvm_pmu_get_counter_value(vcpu, idx);\n\t}\n\treturn true;\n}", "target": 1}
{"code": "static int xen_evtchn_cpu_prepare(unsigned int cpu)\n{\n\tint ret = 0;\n\txen_cpu_init_eoi(cpu);\n\tif (evtchn_ops->percpu_init)\n\t\tret = evtchn_ops->percpu_init(cpu);\n\treturn ret;\n}", "target": 0}
{"code": "    void TiffEncoder::add(\n        TiffComponent* pRootDir,\n        TiffComponent* pSourceDir,\n        uint32_t       root\n    )\n    {\n        assert(pRootDir != 0);\n        writeMethod_ = wmIntrusive;\n        pSourceTree_ = pSourceDir;\n        del_ = false;\n        ExifData::const_iterator posBo = exifData_.end();\n        for (ExifData::const_iterator i = exifData_.begin();\n             i != exifData_.end(); ++i) {\n            IfdId group = groupId(i->groupName());\n            if (group == mnId) {\n                if (i->tag() == 0x0002) {\n                    posBo = i;\n                }\n                continue;\n            }\n            if (isImageTag(i->tag(), group)) continue;\n            TiffPath tiffPath;\n            TiffCreator::getPath(tiffPath, i->tag(), group, root);\n            TiffComponent* tc = pRootDir->addPath(i->tag(), tiffPath, pRootDir);\n            TiffEntryBase* object = dynamic_cast<TiffEntryBase*>(tc);\n#ifdef DEBUG\n            if (object == 0) {\n                std::cerr << \"Warning: addPath() didn't add an entry for \"\n                          << i->groupName()\n                          << \" tag 0x\" << std::setw(4) << std::setfill('0')\n                          << std::hex << i->tag() << \"\\n\";\n            }\n#endif\n            if (object != 0) {\n                encodeTiffComponent(object, &(*i));\n            }\n        }\n        if (posBo == exifData_.end()) return;\n        TiffFinder finder(0x927c, exifId);\n        pRootDir->accept(finder);\n        TiffMnEntry* te = dynamic_cast<TiffMnEntry*>(finder.result());\n        if (te) {\n            TiffIfdMakernote* tim = dynamic_cast<TiffIfdMakernote*>(te->mn_);\n            if (tim) {\n                ByteOrder bo = stringToByteOrder(posBo->toString());\n                if (bo != invalidByteOrder) tim->setByteOrder(bo);\n            }\n        }\n    } ", "target": 0}
{"code": "int socket_create(uint16_t port)\n{\n\tint sfd = -1;\n\tint yes = 1;\n#ifdef WIN32\n\tWSADATA wsa_data;\n\tif (!wsa_init) {\n\t\tif (WSAStartup(MAKEWORD(2,2), &wsa_data) != ERROR_SUCCESS) {\n\t\t\tfprintf(stderr, \"WSAStartup failed!\\n\");\n\t\t\tExitProcess(-1);\n\t\t}\n\t\twsa_init = 1;\n\t}\n#endif\n\tstruct sockaddr_in saddr;\n\tif (0 > (sfd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP))) {\n\t\tperror(\"socket()\");\n\t\treturn -1;\n\t}\n\tif (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void*)&yes, sizeof(int)) == -1) {\n\t\tperror(\"setsockopt()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n\tmemset((void *) &saddr, 0, sizeof(saddr));\n\tsaddr.sin_family = AF_INET;\n\tsaddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\tsaddr.sin_port = htons(port);\n\tif (0 > bind(sfd, (struct sockaddr *) &saddr, sizeof(saddr))) {\n\t\tperror(\"bind()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n\tif (listen(sfd, 1) == -1) {\n\t\tperror(\"listen()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n\treturn sfd;\n}", "target": 1}
{"code": "static ssize_t exitcode_proc_write(struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\tchar *end, buf[sizeof(\"nnnnn\\0\")];\n\tint tmp;\n\tif (copy_from_user(buf, buffer, count))\n\t\treturn -EFAULT;\n\ttmp = simple_strtol(buf, &end, 0);\n\tif ((*end != '\\0') && !isspace(*end))\n\t\treturn -EINVAL;\n\tuml_exitcode = tmp;\n\treturn count;\n}", "target": 1}
{"code": "print_line_header(Dwarf_Debug dbg,\n    Dwarf_Bool is_single_tab,\n    Dwarf_Bool is_actuals_tab)\n{\nif (!is_single_tab) {\nif (is_actuals_tab) {\n_dwarf_printf(dbg,\"\\nActuals Table\\n\");\n_dwarf_printf(dbg,\n\"                                                         be\\n\"\n\"                                                         ls\\n\"\n\"                                                         ce\\n\"\n\" section    op                                           kq\\n\"\n\" offset     code                address/index    row isa ??\\n\");\n    return;\n} else {\n_dwarf_printf(dbg,\"\\nLogicals Table\\n\");\n_dwarf_printf(dbg,\n\"                                                                              s pe\\n\"\n\"                                                                              tirp\\n\"\n\"                                                                              msoi\\n\"\n\" section          op                                                          tall\\n\"\n\" offset      row  code                address/indx fil lne col disc cntx subp ????\\n\");\n    return;\n}\n}\n_dwarf_printf(dbg,\n\"                                                         s b e p e i d\\n\"\n\"                                                         t l s r p s i\\n\"\n\"                                                         m c e o i a s\\n\"\n\" section    op                                       col t k q l l   c\\n\"\n\" offset     code               address     file line umn ? ? ? ? ?\\n\");\n} ", "target": 1}
{"code": "ctcompare(const char *a,\t\t\n          const char *b)\t\t\n{\n  int\tresult = 0;\t\t\t\n  while (*a && *b)\n  {\n    result |= *a ^ *b;\n    a ++;\n    b ++;\n  }\n  return (result);\n}", "target": 1}
{"code": "static inline int ccid_hc_tx_getsockopt(struct ccid *ccid, struct sock *sk,\n\t\t\t\t\tconst int optname, int len,\n\t\t\t\t\tu32 __user *optval, int __user *optlen)\n{\n\tint rc = -ENOPROTOOPT;\n\tif (ccid->ccid_ops->ccid_hc_tx_getsockopt != NULL)\n\t\trc = ccid->ccid_ops->ccid_hc_tx_getsockopt(sk, optname, len,\n\t\t\t\t\t\t optval, optlen);\n\treturn rc;\n}", "target": 1}
{"code": "static int bmpr_read_rle(struct iwbmprcontext *rctx)\n{\n\tint retval = 0;\n\tif(!(rctx->compression==IWBMP_BI_RLE8 && rctx->bitcount==8) &&\n\t\t!(rctx->compression==IWBMP_BI_RLE4 && rctx->bitcount==4))\n\t{\n\t\tiw_set_error(rctx->ctx,\"Compression type incompatible with image type\");\n\t\tgoto done;\n\t}\n\tif(rctx->topdown) {\n\t\tiw_set_error(rctx->ctx,\"Compression not allowed with top-down images\");\n\t\tgoto done;\n\t}\n\trctx->img->imgtype = IW_IMGTYPE_RGBA;\n\trctx->img->bit_depth = 8;\n\trctx->img->bpr = iw_calc_bytesperrow(rctx->width,32);\n\trctx->img->pixels = (iw_byte*)iw_malloc_large(rctx->ctx,rctx->img->bpr,rctx->img->height);\n\tif(!rctx->img->pixels) goto done;\n\tif(!bmpr_read_rle_internal(rctx)) goto done;\n\tif(!bmpr_has_transparency(rctx->img)) {\n\t\tbmpr_strip_alpha(rctx->img);\n\t}\n\tretval = 1;\ndone:\n\treturn retval;\n}", "target": 0}
{"code": "int cipso_v4_sock_setattr(struct sock *sk,\n\t\t\t  const struct cipso_v4_doi *doi_def,\n\t\t\t  const struct netlbl_lsm_secattr *secattr)\n{\n\tint ret_val = -EPERM;\n\tunsigned char *buf = NULL;\n\tu32 buf_len;\n\tu32 opt_len;\n\tstruct ip_options *opt = NULL;\n\tstruct inet_sock *sk_inet;\n\tstruct inet_connection_sock *sk_conn;\n\tif (sk == NULL)\n\t\treturn 0;\n\tbuf_len = CIPSO_V4_OPT_LEN_MAX;\n\tbuf = kmalloc(buf_len, GFP_ATOMIC);\n\tif (buf == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto socket_setattr_failure;\n\t}\n\tret_val = cipso_v4_genopt(buf, buf_len, doi_def, secattr);\n\tif (ret_val < 0)\n\t\tgoto socket_setattr_failure;\n\tbuf_len = ret_val;\n\topt_len = (buf_len + 3) & ~3;\n\topt = kzalloc(sizeof(*opt) + opt_len, GFP_ATOMIC);\n\tif (opt == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto socket_setattr_failure;\n\t}\n\tmemcpy(opt->__data, buf, buf_len);\n\topt->optlen = opt_len;\n\topt->cipso = sizeof(struct iphdr);\n\tkfree(buf);\n\tbuf = NULL;\n\tsk_inet = inet_sk(sk);\n\tif (sk_inet->is_icsk) {\n\t\tsk_conn = inet_csk(sk);\n\t\tif (sk_inet->opt)\n\t\t\tsk_conn->icsk_ext_hdr_len -= sk_inet->opt->optlen;\n\t\tsk_conn->icsk_ext_hdr_len += opt->optlen;\n\t\tsk_conn->icsk_sync_mss(sk, sk_conn->icsk_pmtu_cookie);\n\t}\n\topt = xchg(&sk_inet->opt, opt);\n\tkfree(opt);\n\treturn 0;\nsocket_setattr_failure:\n\tkfree(buf);\n\tkfree(opt);\n\treturn ret_val;\n}", "target": 1}
{"code": "static void __net_exit sctp_net_exit(struct net *net)\n{\n\tsctp_free_addr_wq(net);\n\tsctp_free_local_addr_list(net);\n\tinet_ctl_sock_destroy(net->sctp.ctl_sock);\n\tsctp_dbg_objcnt_exit(net);\n\tsctp_proc_exit(net);\n\tcleanup_sctp_mibs(net);\n\tsctp_sysctl_net_unregister(net);\n}", "target": 1}
{"code": "static void __exit xfrm6_tunnel_fini(void)\n{\n\tunregister_pernet_subsys(&xfrm6_tunnel_net_ops);\n\txfrm6_tunnel_spi_fini();\n\txfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);\n\txfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);\n\txfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);\n}", "target": 1}
{"code": "static void cil_reset_classpermission(struct cil_classpermission *cp)\n{\n\tif (cp == NULL) {\n\t\treturn;\n\t}\n\tcil_reset_classperms_list(cp->classperms);\n}", "target": 1}
{"code": "static void RemoveICCProfileFromResourceBlock(StringInfo *bim_profile)\n{\n  register const unsigned char\n    *p;\n  size_t\n    length;\n  unsigned char\n    *datum;\n  unsigned int\n    count,\n    long_sans;\n  unsigned short\n    id,\n    short_sans;\n  length=GetStringInfoLength(bim_profile);\n  if (length < 16)\n    return;\n  datum=GetStringInfoDatum(bim_profile);\n  for (p=datum; (p >= datum) && (p < (datum+length-16)); )\n  {\n    register unsigned char\n      *q;\n    q=(unsigned char *) p;\n    if (LocaleNCompare((const char *) p,\"8BIM\",4) != 0)\n      break;\n    p=PushLongPixel(MSBEndian,p,&long_sans);\n    p=PushShortPixel(MSBEndian,p,&id);\n    p=PushShortPixel(MSBEndian,p,&short_sans);\n    p=PushLongPixel(MSBEndian,p,&count);\n    if (id == 0x0000040f)\n      {\n        (void) CopyMagickMemory(q,q+PSDQuantum(count)+12,length-\n          (PSDQuantum(count)+12)-(q-datum));\n        SetStringInfoLength(bim_profile,length-(PSDQuantum(count)+12));\n        break;\n      }\n    p+=count;\n    if ((count & 0x01) != 0)\n      p++;\n  }\n}", "target": 1}
{"code": "vg_process_cursor_cmd(VuGpu *g, struct virtio_gpu_update_cursor *cursor)\n{\n    switch (cursor->hdr.type) {\n    case VIRTIO_GPU_CMD_MOVE_CURSOR: {\n        VhostUserGpuMsg msg = {\n            .request = cursor->resource_id ?\n                VHOST_USER_GPU_CURSOR_POS : VHOST_USER_GPU_CURSOR_POS_HIDE,\n            .size = sizeof(VhostUserGpuCursorPos),\n            .payload.cursor_pos = {\n                .scanout_id = cursor->pos.scanout_id,\n                .x = cursor->pos.x,\n                .y = cursor->pos.y,\n            }\n        };\n        g_debug(\"%s: move\", G_STRFUNC);\n        vg_send_msg(g, &msg, -1);\n        break;\n    }\n    case VIRTIO_GPU_CMD_UPDATE_CURSOR: {\n        VhostUserGpuMsg msg = {\n            .request = VHOST_USER_GPU_CURSOR_UPDATE,\n            .size = sizeof(VhostUserGpuCursorUpdate),\n            .payload.cursor_update = {\n                .pos = {\n                    .scanout_id = cursor->pos.scanout_id,\n                    .x = cursor->pos.x,\n                    .y = cursor->pos.y,\n                },\n                .hot_x = cursor->hot_x,\n                .hot_y = cursor->hot_y,\n            }\n        };\n        g_debug(\"%s: update\", G_STRFUNC);\n        if (g->virgl) {\n            vg_virgl_update_cursor_data(g, cursor->resource_id,\n                                        msg.payload.cursor_update.data);\n        } else {\n            update_cursor_data_simple(g, cursor->resource_id,\n                                      msg.payload.cursor_update.data);\n        }\n        vg_send_msg(g, &msg, -1);\n        break;\n    }\n    default:\n        g_debug(\"%s: unknown cmd %d\", G_STRFUNC, cursor->hdr.type);\n        break;\n    }\n}", "target": 0}
{"code": "static ssize_t bat_socket_read(struct file *file, char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct socket_client *socket_client = file->private_data;\n\tstruct socket_packet *socket_packet;\n\tsize_t packet_len;\n\tint error;\n\tif ((file->f_flags & O_NONBLOCK) && (socket_client->queue_len == 0))\n\t\treturn -EAGAIN;\n\tif ((!buf) || (count < sizeof(struct icmp_packet)))\n\t\treturn -EINVAL;\n\tif (!access_ok(VERIFY_WRITE, buf, count))\n\t\treturn -EFAULT;\n\terror = wait_event_interruptible(socket_client->queue_wait,\n\t\t\t\t\t socket_client->queue_len);\n\tif (error)\n\t\treturn error;\n\tspin_lock_bh(&socket_client->lock);\n\tsocket_packet = list_first_entry(&socket_client->queue_list,\n\t\t\t\t\t struct socket_packet, list);\n\tlist_del(&socket_packet->list);\n\tsocket_client->queue_len--;\n\tspin_unlock_bh(&socket_client->lock);\n\terror = copy_to_user(buf, &socket_packet->icmp_packet,\n\t\t\t     socket_packet->icmp_len);\n\tpacket_len = socket_packet->icmp_len;\n\tkfree(socket_packet);\n\tif (error)\n\t\treturn -EFAULT;\n\treturn packet_len;\n}", "target": 1}
{"code": "static gg_action_t gg_handle_send_proxy_gg(struct gg_session *sess, struct gg_event *e, enum gg_state_t next_state, enum gg_state_t alt_state, enum gg_state_t alt2_state)\n{\n\tchar *req, *auth;\n\tsize_t req_len;\n\tint res;\n\tgg_debug_session(sess, GG_DEBUG_MISC, \"\n\tif (sess->connect_index > 1 || sess->connect_port[sess->connect_index] == 0) {\n\t\tgg_debug_session(sess, GG_DEBUG_MISC, \"\n\t\te->event.failure = GG_FAILURE_CONNECTING;\n\t\treturn GG_ACTION_FAIL;\n\t}\n\tauth = gg_proxy_auth();\n\treq = gg_saprintf(\"CONNECT %s:%d HTTP/1.0\\r\\n%s\\r\\n\", sess->connect_host, sess->connect_port[sess->connect_index], (auth) ? auth : \"\");\n\tfree(auth);\n\tsess->connect_index++;\n\tif (req == NULL) {\n\t\tgg_debug_session(sess, GG_DEBUG_MISC, \"\n\t\te->event.failure = GG_FAILURE_PROXY;\n\t\treturn GG_ACTION_FAIL;\n\t}\n\treq_len = strlen(req);\n\tgg_debug_session(sess, GG_DEBUG_MISC, \"\n\tres = send(sess->fd, req, req_len, 0);\n\tfree(req);\n\tif (res == -1 && errno != EINTR && errno != EAGAIN) {\n\t\tgg_debug_session(sess, GG_DEBUG_MISC, \"\n\t\te->event.failure = GG_FAILURE_PROXY;\n\t\treturn GG_ACTION_FAIL;\n\t}\n\tif ((size_t) res < req_len) {\n\t\tsess->state = alt_state;\n\t\tsess->check = GG_CHECK_WRITE;\n\t\tsess->timeout = GG_DEFAULT_TIMEOUT;\n\t} else {\n\t\tsess->state = next_state;\n\t\tsess->check = GG_CHECK_READ;\n\t\tsess->timeout = GG_DEFAULT_TIMEOUT;\n\t}\n\treturn GG_ACTION_WAIT;\n}", "target": 0}
{"code": "static int skcipher_recvmsg_nokey(struct socket *sock, struct msghdr *msg,\n\t\t\t\t  size_t ignored, int flags)\n{\n\tint err;\n\terr = skcipher_check_key(sock);\n\tif (err)\n\t\treturn err;\n\treturn skcipher_recvmsg(sock, msg, ignored, flags);\n}", "target": 0}
{"code": "static void __init deferred_free_range(unsigned long pfn,\n\t\t\t\t       unsigned long nr_pages)\n{\n\tstruct page *page;\n\tunsigned long i;\n\tif (!nr_pages)\n\t\treturn;\n\tpage = pfn_to_page(pfn);\n\tif (nr_pages == pageblock_nr_pages &&\n\t    (pfn & (pageblock_nr_pages - 1)) == 0) {\n\t\tset_pageblock_migratetype(page, MIGRATE_MOVABLE);\n\t\t__free_pages_boot_core(page, pageblock_order);\n\t\treturn;\n\t}\n\tfor (i = 0; i < nr_pages; i++, page++, pfn++) {\n\t\tif ((pfn & (pageblock_nr_pages - 1)) == 0)\n\t\t\tset_pageblock_migratetype(page, MIGRATE_MOVABLE);\n\t\t__free_pages_boot_core(page, 0);\n\t}\n}", "target": 0}
{"code": "static int rt6_bind_neighbour(struct rt6_info *rt, struct net_device *dev)\n{\n\tstruct neighbour *n = __ipv6_neigh_lookup(&nd_tbl, dev, &rt->rt6i_gateway);\n\tif (!n) {\n\t\tn = neigh_create(&nd_tbl, &rt->rt6i_gateway, dev);\n\t\tif (IS_ERR(n))\n\t\t\treturn PTR_ERR(n);\n\t}\n\trt->n = n;\n\treturn 0;\n}", "target": 0}
{"code": "BGD_DECLARE(gdImagePtr) gdImageCropThreshold(gdImagePtr im, const unsigned int color, const float threshold)\n{\n\tconst int width = gdImageSX(im);\n\tconst int height = gdImageSY(im);\n\tint x,y;\n\tint match;\n\tgdRect crop;\n\tcrop.x = 0;\n\tcrop.y = 0;\n\tcrop.width = 0;\n\tcrop.height = 0;\n\tif (threshold > 100.0) {\n\t\treturn NULL;\n\t}\n\tif (color < 0 || (!gdImageTrueColor(im) && color >= gdImageColorsTotal(im))) {\n\t\treturn NULL;\n\t}\n\tmatch = 1;\n\tfor (y = 0; match && y < height; y++) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tif (y == height - 1) {\n\t\treturn NULL;\n\t}\n\tcrop.y = y -1;\n\tmatch = 1;\n\tfor (y = height - 1; match && y >= 0; y--) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x, y), threshold)) > 0;\n\t\t}\n\t}\n\tif (y == 0) {\n\t\tcrop.height = height - crop.y + 1;\n\t} else {\n\t\tcrop.height = y - crop.y + 2;\n\t}\n\tmatch = 1;\n\tfor (x = 0; match && x < width; x++) {\n\t\tfor (y = 0; match && y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tcrop.x = x - 1;\n\tmatch = 1;\n\tfor (x = width - 1; match && x >= 0; x--) {\n\t\tfor (y = 0; match &&  y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tcrop.width = x - crop.x + 2;\n\treturn gdImageCrop(im, &crop);\n}", "target": 0}
{"code": "static int read_new_config_info (WavpackContext *wpc, WavpackMetadata *wpmd)\n{\n    int bytecnt = wpmd->byte_length;\n    unsigned char *byteptr = wpmd->data;\n    wpc->version_five = 1;      \n    wpc->file_format = wpc->config.qmode = wpc->channel_layout = 0;\n    if (wpc->channel_reordering) {\n        free (wpc->channel_reordering);\n        wpc->channel_reordering = NULL;\n    }\n    if (bytecnt) {\n        wpc->file_format = *byteptr++;\n        wpc->config.qmode = (wpc->config.qmode & ~0xff) | *byteptr++;\n        bytecnt -= 2;\n        if (bytecnt) {\n            int nchans, i;\n            wpc->channel_layout = (int32_t) *byteptr++ << 16;\n            bytecnt--;\n            if (bytecnt) {\n                wpc->channel_layout += nchans = *byteptr++;\n                bytecnt--;\n                if (bytecnt) {\n                    if (bytecnt > nchans)\n                        return FALSE;\n                    wpc->channel_reordering = malloc (nchans);\n                    if (wpc->channel_reordering) {\n                        for (i = 0; i < nchans; ++i)\n                            if (bytecnt) {\n                                wpc->channel_reordering [i] = *byteptr++;\n                                bytecnt--;\n                            }\n                            else\n                                wpc->channel_reordering [i] = i;\n                    }\n                }\n            }\n            else\n                wpc->channel_layout += wpc->config.num_channels;\n        }\n    }\n    return TRUE;\n}", "target": 1}
{"code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, kInput);\n  const TfLiteTensor* input_state = GetInput(context, node, kInputState);\n  const TfLiteTensor* gate_weight = GetInput(context, node, kGateWeight);\n  const TfLiteTensor* gate_bias = GetInput(context, node, kGateBias);\n  const TfLiteTensor* candidate_weight =\n      GetInput(context, node, kCandidateWeight);\n  const TfLiteTensor* candidate_bias = GetInput(context, node, kCandidateBias);\n  TfLiteTensor* output = GetOutput(context, node, kOutput);\n  TfLiteTensor* output_state = GetOutput(context, node, kOutputState);\n  TfLiteTensor* activation = GetTemporary(context, node, kActivation);\n  TfLiteTensor* concat = GetTemporary(context, node, kConcat);\n  auto cpu_backend_context = CpuBackendContext::GetFromContext(context);\n  if (gate_weight->type == kTfLiteFloat32) {\n    GruImpl(input, input_state, gate_weight, gate_bias, candidate_weight,\n            candidate_bias, output, output_state, activation, concat,\n            cpu_backend_context);\n  } else {\n    context->ReportError(context,\n                         \"Unsupported combination of data types for GruCell\");\n    return kTfLiteError;\n  }\n  return kTfLiteOk;\n}", "target": 1}
{"code": "static bool _valid_hex(char *s, const char *file, const char *func, const int line)\n{\n\tbool ret = false;\n\tint i, len;\n\tif (unlikely(!s)) {\n\t\tapplog(LOG_ERR, \"Null string passed to valid_hex from\"IN_FMT_FFL, file, func, line);\n\t\treturn ret;\n\t}\n\tlen = strlen(s);\n\tif (unlikely(!len)) {\n\t\tapplog(LOG_ERR, \"Zero length string passed to valid_hex from\"IN_FMT_FFL, file, func, line);\n\t\treturn ret;\n\t}\n\tfor (i = 0; i < len; i++) {\n\t\tunsigned char idx = s[i];\n\t\tif (unlikely(hex2bin_tbl[idx] < 0)) {\n\t\t\tapplog(LOG_ERR, \"Invalid char %x passed to valid_hex from\"IN_FMT_FFL, idx, file, func, line);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tret = true;\n\treturn ret;\n}", "target": 0}
{"code": "static void virtio_net_detach_epbf_rss(VirtIONet *n)\n{\n    virtio_net_attach_ebpf_to_backend(n->nic, -1);\n}", "target": 0}
{"code": "void net_tx_pkt_update_ip_hdr_checksum(struct NetTxPkt *pkt)\n{\n    uint16_t csum;\n    assert(pkt);\n    struct ip_header *ip_hdr;\n    ip_hdr = pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base;\n    ip_hdr->ip_len = cpu_to_be16(pkt->payload_len +\n        pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_len);\n    ip_hdr->ip_sum = 0;\n    csum = net_raw_checksum((uint8_t *)ip_hdr,\n        pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_len);\n    ip_hdr->ip_sum = cpu_to_be16(csum);\n}", "target": 0}
{"code": "pam_converse (int num_msg, PAM_CONVERSE_ARG2_TYPE **msg,\n  struct pam_response **resp, void *appdata_ptr)\n{\nint sep = 0;\nstruct pam_response *reply;\nif (  pam_arg_ended\n   || !(reply = malloc(sizeof(struct pam_response) * num_msg)))\n  return PAM_CONV_ERR;\nfor (int i = 0; i < num_msg; i++)\n  {\n  uschar *arg;\n  switch (msg[i]->msg_style)\n    {\n    case PAM_PROMPT_ECHO_ON:\n    case PAM_PROMPT_ECHO_OFF:\n      if (!(arg = string_nextinlist(&pam_args, &sep, NULL, 0)))\n\t{\n\targ = US\"\";\n\tpam_arg_ended = TRUE;\n\t}\n      reply[i].resp = CS string_copy_malloc(arg); \n      reply[i].resp_retcode = PAM_SUCCESS;\n      break;\n    case PAM_TEXT_INFO:    \n    case PAM_ERROR_MSG:\n      reply[i].resp_retcode = PAM_SUCCESS;\n      reply[i].resp = NULL;\n      break;\n    default:  \n      free(reply);\n      pam_conv_had_error = TRUE;\n      return PAM_CONV_ERR;\n    }\n  }\n*resp = reply;\nreturn PAM_SUCCESS;\n}", "target": 1}
{"code": "static void rds_tcp_kill_sock(struct net *net)\n{\n\tstruct rds_tcp_connection *tc, *_tc;\n\tLIST_HEAD(tmp_list);\n\tstruct rds_tcp_net *rtn = net_generic(net, rds_tcp_netid);\n\tstruct socket *lsock = rtn->rds_tcp_listen_sock;\n\trtn->rds_tcp_listen_sock = NULL;\n\trds_tcp_listen_stop(lsock, &rtn->rds_tcp_accept_w);\n\tspin_lock_irq(&rds_tcp_conn_lock);\n\tlist_for_each_entry_safe(tc, _tc, &rds_tcp_conn_list, t_tcp_node) {\n\t\tstruct net *c_net = read_pnet(&tc->t_cpath->cp_conn->c_net);\n\t\tif (net != c_net || !tc->t_sock)\n\t\t\tcontinue;\n\t\tif (!list_has_conn(&tmp_list, tc->t_cpath->cp_conn)) {\n\t\t\tlist_move_tail(&tc->t_tcp_node, &tmp_list);\n\t\t} else {\n\t\t\tlist_del(&tc->t_tcp_node);\n\t\t\ttc->t_tcp_node_detached = true;\n\t\t}\n\t}\n\tspin_unlock_irq(&rds_tcp_conn_lock);\n\tlist_for_each_entry_safe(tc, _tc, &tmp_list, t_tcp_node)\n\t\trds_conn_destroy(tc->t_cpath->cp_conn);\n}", "target": 1}
{"code": "set_interface_var(const char *iface,\n\t\t  const char *var, const char *name,\n\t\t  uint32_t val)\n{\n\tFILE *fp;\n\tchar spath[64+IFNAMSIZ];\t\n\tif (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))\n\t\treturn -1;\n\tif (strstr(name, \"..\") || strchr(name, '/'))\n\t\treturn -1;\n\tif (access(spath, F_OK) != 0)\n\t\treturn -1;\n\tfp = fopen(spath, \"w\");\n\tif (!fp) {\n\t\tif (name)\n\t\t\tflog(LOG_ERR, \"failed to set %s (%u) for %s: %s\",\n\t\t\t     name, val, iface, strerror(errno));\n\t\treturn -1;\n\t}\n\tfprintf(fp, \"%u\", val);\n\tfclose(fp);\n\treturn 0;\n}", "target": 0}
{"code": "static int pppol2tp_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t len,\n\t\t\t    int flags)\n{\n\tint err;\n\tstruct sk_buff *skb;\n\tstruct sock *sk = sock->sk;\n\terr = -EIO;\n\tif (sk->sk_state & PPPOX_BOUND)\n\t\tgoto end;\n\tmsg->msg_namelen = 0;\n\terr = 0;\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\tgoto end;\n\tif (len > skb->len)\n\t\tlen = skb->len;\n\telse if (len < skb->len)\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, len);\n\tif (likely(err == 0))\n\t\terr = len;\n\tkfree_skb(skb);\nend:\n\treturn err;\n}", "target": 1}
{"code": "static int em_ret(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->dst.type = OP_REG;\n\tctxt->dst.addr.reg = &ctxt->_eip;\n\tctxt->dst.bytes = ctxt->op_bytes;\n\treturn em_pop(ctxt);\n}", "target": 1}
{"code": "static int pit_ioport_read(struct kvm_io_device *this,\n\t\t\t   gpa_t addr, int len, void *data)\n{\n\tstruct kvm_pit *pit = dev_to_pit(this);\n\tstruct kvm_kpit_state *pit_state = &pit->pit_state;\n\tstruct kvm *kvm = pit->kvm;\n\tint ret, count;\n\tstruct kvm_kpit_channel_state *s;\n\tif (!pit_in_range(addr))\n\t\treturn -EOPNOTSUPP;\n\taddr &= KVM_PIT_CHANNEL_MASK;\n\tif (addr == 3)\n\t\treturn 0;\n\ts = &pit_state->channels[addr];\n\tmutex_lock(&pit_state->lock);\n\tif (s->status_latched) {\n\t\ts->status_latched = 0;\n\t\tret = s->status;\n\t} else if (s->count_latched) {\n\t\tswitch (s->count_latched) {\n\t\tdefault:\n\t\tcase RW_STATE_LSB:\n\t\t\tret = s->latched_count & 0xff;\n\t\t\ts->count_latched = 0;\n\t\t\tbreak;\n\t\tcase RW_STATE_MSB:\n\t\t\tret = s->latched_count >> 8;\n\t\t\ts->count_latched = 0;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD0:\n\t\t\tret = s->latched_count & 0xff;\n\t\t\ts->count_latched = RW_STATE_MSB;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (s->read_state) {\n\t\tdefault:\n\t\tcase RW_STATE_LSB:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = count & 0xff;\n\t\t\tbreak;\n\t\tcase RW_STATE_MSB:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = (count >> 8) & 0xff;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD0:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = count & 0xff;\n\t\t\ts->read_state = RW_STATE_WORD1;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD1:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = (count >> 8) & 0xff;\n\t\t\ts->read_state = RW_STATE_WORD0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (len > sizeof(ret))\n\t\tlen = sizeof(ret);\n\tmemcpy(data, (char *)&ret, len);\n\tmutex_unlock(&pit_state->lock);\n\treturn 0;\n}", "target": 0}
{"code": "kex_input_kexinit(int type, u_int32_t seq, void *ctxt)\n{\n\tstruct ssh *ssh = ctxt;\n\tstruct kex *kex = ssh->kex;\n\tconst u_char *ptr;\n\tu_int i;\n\tsize_t dlen;\n\tint r;\n\tdebug(\"SSH2_MSG_KEXINIT received\");\n\tif (kex == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tssh_dispatch_set(ssh, SSH2_MSG_KEXINIT, NULL);\n\tptr = sshpkt_ptr(ssh, &dlen);\n\tif ((r = sshbuf_put(kex->peer, ptr, dlen)) != 0)\n\t\treturn r;\n\tfor (i = 0; i < KEX_COOKIE_LEN; i++)\n\t\tif ((r = sshpkt_get_u8(ssh, NULL)) != 0)\n\t\t\treturn r;\n\tfor (i = 0; i < PROPOSAL_MAX; i++)\n\t\tif ((r = sshpkt_get_string(ssh, NULL, NULL)) != 0)\n\t\t\treturn r;\n\tif ((r = sshpkt_get_u8(ssh, NULL)) != 0 ||\t\n\t    (r = sshpkt_get_u32(ssh, NULL)) != 0 ||\t\n\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\t\treturn r;\n\tif (!(kex->flags & KEX_INIT_SENT))\n\t\tif ((r = kex_send_kexinit(ssh)) != 0)\n\t\t\treturn r;\n\tif ((r = kex_choose_conf(ssh)) != 0)\n\t\treturn r;\n\tif (kex->kex_type < KEX_MAX && kex->kex[kex->kex_type] != NULL)\n\t\treturn (kex->kex[kex->kex_type])(ssh);\n\treturn SSH_ERR_INTERNAL_ERROR;\n}", "target": 0}
{"code": "next_state_class(CClassNode* cc, OnigCodePoint* vs, enum CCVALTYPE* type,\n\t\t enum CCSTATE* state, ScanEnv* env)\n{\n  int r;\n  if (*state == CCS_RANGE)\n    return ONIGERR_CHAR_CLASS_VALUE_AT_END_OF_RANGE;\n  if (*state == CCS_VALUE && *type != CCV_CLASS) {\n    if (*type == CCV_SB)\n      BITSET_SET_BIT(cc->bs, (int )(*vs));\n    else if (*type == CCV_CODE_POINT) {\n      r = add_code_range(&(cc->mbuf), env, *vs, *vs);\n      if (r < 0) return r;\n    }\n  }\n  *state = CCS_VALUE;\n  *type  = CCV_CLASS;\n  return 0;\n}", "target": 1}
{"code": "Server::Server(boost::asio::ip::tcp protocol, std::uint16_t port,\n               const fs::path& doc_root)\n    : protocol_(protocol),\n      port_(port),\n      doc_root_(doc_root),\n      acceptor_(io_context_),\n      signals_(io_context_) {\n  CheckDocRoot();\n  AddSignals();\n}", "target": 0}
{"code": "static int smtp_open(struct Connection *conn, bool esmtp)\n{\n  int rc;\n  if (mutt_socket_open(conn))\n    return -1;\n  rc = smtp_get_resp(conn);\n  if (rc != 0)\n    return rc;\n  rc = smtp_helo(conn, esmtp);\n  if (rc != 0)\n    return rc;\n#ifdef USE_SSL\n  enum QuadOption ans = MUTT_NO;\n  if (conn->ssf)\n    ans = MUTT_NO;\n  else if (C_SslForceTls)\n    ans = MUTT_YES;\n  else if ((Capabilities & SMTP_CAP_STARTTLS) &&\n           ((ans = query_quadoption(C_SslStarttls,\n                                    _(\"Secure connection with TLS?\"))) == MUTT_ABORT))\n  {\n    return -1;\n  }\n  if (ans == MUTT_YES)\n  {\n    if (mutt_socket_send(conn, \"STARTTLS\\r\\n\") < 0)\n      return SMTP_ERR_WRITE;\n    rc = smtp_get_resp(conn);\n    mutt_socket_empty(conn);\n    if (rc != 0)\n      return rc;\n    if (mutt_ssl_starttls(conn))\n    {\n      mutt_error(_(\"Could not negotiate TLS connection\"));\n      return -1;\n    }\n    rc = smtp_helo(conn, esmtp);\n    if (rc != 0)\n      return rc;\n  }\n#endif\n  if (conn->account.flags & MUTT_ACCT_USER)\n  {\n    if (!(Capabilities & SMTP_CAP_AUTH))\n    {\n      mutt_error(_(\"SMTP server does not support authentication\"));\n      return -1;\n    }\n    return smtp_auth(conn);\n  }\n  return 0;\n}", "target": 0}
{"code": "static void php_html_entities(INTERNAL_FUNCTION_PARAMETERS, int all)\n{\n\tchar *str, *hint_charset = NULL;\n\tint str_len, hint_charset_len = 0;\n\tsize_t new_len;\n\tlong flags = ENT_COMPAT;\n\tchar *replaced;\n\tzend_bool double_encode = 1;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|ls!b\", &str, &str_len, &flags, &hint_charset, &hint_charset_len, &double_encode) == FAILURE) {\n\t\treturn;\n\t}\n\treplaced = php_escape_html_entities_ex(str, str_len, &new_len, all, (int) flags, hint_charset, double_encode TSRMLS_CC);\n\tif (new_len > INT_MAX) {\n\t\tefree(replaced);\n\t\tRETURN_FALSE;\n\t}\n\tRETVAL_STRINGL(replaced, (int)new_len, 0);\n}", "target": 0}
{"code": "static int emulate_store_desc_ptr(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t  void (*get)(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t\t      struct desc_ptr *ptr))\n{\n\tstruct desc_ptr desc_ptr;\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tctxt->op_bytes = 8;\n\tget(ctxt, &desc_ptr);\n\tif (ctxt->op_bytes == 2) {\n\t\tctxt->op_bytes = 4;\n\t\tdesc_ptr.address &= 0x00ffffff;\n\t}\n\tctxt->dst.type = OP_NONE;\n\treturn segmented_write_std(ctxt, ctxt->dst.addr.mem,\n\t\t\t\t   &desc_ptr, 2 + ctxt->op_bytes);\n}", "target": 0}
{"code": "static unsigned short get_ushort(const unsigned char *data)\n{\n    unsigned short val = *(const unsigned short *)data;\n#ifdef OPJ_BIG_ENDIAN\n    val = ((val & 0xffU) << 8) | (val >> 8);\n#endif\n    return val;\n}", "target": 1}
{"code": "void zsetConvertToZiplistIfNeeded(robj *zobj, size_t maxelelen) {\n    if (zobj->encoding == OBJ_ENCODING_ZIPLIST) return;\n    zset *zset = zobj->ptr;\n    if (zset->zsl->length <= server.zset_max_ziplist_entries &&\n        maxelelen <= server.zset_max_ziplist_value)\n            zsetConvert(zobj,OBJ_ENCODING_ZIPLIST);\n}", "target": 1}
{"code": "static int list_devices(struct file *filp, struct dm_ioctl *param, size_t param_size)\n{\n\tunsigned int i;\n\tstruct hash_cell *hc;\n\tsize_t len, needed = 0;\n\tstruct gendisk *disk;\n\tstruct dm_name_list *orig_nl, *nl, *old_nl = NULL;\n\tuint32_t *event_nr;\n\tdown_write(&_hash_lock);\n\tfor (i = 0; i < NUM_BUCKETS; i++) {\n\t\tlist_for_each_entry (hc, _name_buckets + i, name_list) {\n\t\t\tneeded += align_val(offsetof(struct dm_name_list, name) + strlen(hc->name) + 1);\n\t\t\tneeded += align_val(sizeof(uint32_t));\n\t\t}\n\t}\n\tnl = orig_nl = get_result_buffer(param, param_size, &len);\n\tif (len < needed) {\n\t\tparam->flags |= DM_BUFFER_FULL_FLAG;\n\t\tgoto out;\n\t}\n\tparam->data_size = param->data_start + needed;\n\tnl->dev = 0;\t\n\tfor (i = 0; i < NUM_BUCKETS; i++) {\n\t\tlist_for_each_entry (hc, _name_buckets + i, name_list) {\n\t\t\tif (old_nl)\n\t\t\t\told_nl->next = (uint32_t) ((void *) nl -\n\t\t\t\t\t\t\t   (void *) old_nl);\n\t\t\tdisk = dm_disk(hc->md);\n\t\t\tnl->dev = huge_encode_dev(disk_devt(disk));\n\t\t\tnl->next = 0;\n\t\t\tstrcpy(nl->name, hc->name);\n\t\t\told_nl = nl;\n\t\t\tevent_nr = align_ptr(nl->name + strlen(hc->name) + 1);\n\t\t\t*event_nr = dm_get_event_nr(hc->md);\n\t\t\tnl = align_ptr(event_nr + 1);\n\t\t}\n\t}\n\tBUG_ON((char *)nl - (char *)orig_nl != needed);\n out:\n\tup_write(&_hash_lock);\n\treturn 0;\n}", "target": 1}
{"code": "validate_serials(struct deltas_head *deltas, ...)\n{\n\tunsigned long serial;\n\tunsigned int i;\n\tva_list vl;\n\tva_start(vl, deltas);\n\ti = 0;\n\twhile ((serial = va_arg(vl, unsigned long)) != END) {\n\t\tck_assert_uint_eq(serial, deltas->array[i].serial);\n\t\ti++;\n\t}\n\tva_end(vl);\n}", "target": 0}
{"code": "sshkey_load_file(int fd, struct sshbuf *blob)\n{\n\tu_char buf[1024];\n\tsize_t len;\n\tstruct stat st;\n\tint r;\n\tif (fstat(fd, &st) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\tif ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&\n\t    st.st_size > MAX_KEY_FILE_SIZE)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tfor (;;) {\n\t\tif ((len = atomicio(read, fd, buf, sizeof(buf))) == 0) {\n\t\t\tif (errno == EPIPE)\n\t\t\t\tbreak;\n\t\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put(blob, buf, len)) != 0)\n\t\t\tgoto out;\n\t\tif (sshbuf_len(blob) > MAX_KEY_FILE_SIZE) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&\n\t    st.st_size != (off_t)sshbuf_len(blob)) {\n\t\tr = SSH_ERR_FILE_CHANGED;\n\t\tgoto out;\n\t}\n\tr = 0;\n out:\n\texplicit_bzero(buf, sizeof(buf));\n\tif (r != 0)\n\t\tsshbuf_reset(blob);\n\treturn r;\n}", "target": 1}
{"code": "static void dump_completed_IO(struct inode * inode)\n{\n#ifdef\tEXT4_DEBUG\n\tstruct list_head *cur, *before, *after;\n\text4_io_end_t *io, *io0, *io1;\n\tunsigned long flags;\n\tif (list_empty(&EXT4_I(inode)->i_completed_io_list)){\n\t\text4_debug(\"inode %lu completed_io list is empty\\n\", inode->i_ino);\n\t\treturn;\n\t}\n\text4_debug(\"Dump inode %lu completed_io list \\n\", inode->i_ino);\n\tspin_lock_irqsave(&EXT4_I(inode)->i_completed_io_lock, flags);\n\tlist_for_each_entry(io, &EXT4_I(inode)->i_completed_io_list, list){\n\t\tcur = &io->list;\n\t\tbefore = cur->prev;\n\t\tio0 = container_of(before, ext4_io_end_t, list);\n\t\tafter = cur->next;\n\t\tio1 = container_of(after, ext4_io_end_t, list);\n\t\text4_debug(\"io 0x%p from inode %lu,prev 0x%p,next 0x%p\\n\",\n\t\t\t    io, inode->i_ino, io0, io1);\n\t}\n\tspin_unlock_irqrestore(&EXT4_I(inode)->i_completed_io_lock, flags);\n#endif\n}", "target": 0}
{"code": "static void perf_event_task_event(struct perf_task_event *task_event)\n{\n\tstruct perf_cpu_context *cpuctx;\n\tstruct perf_event_context *ctx;\n\tstruct pmu *pmu;\n\tint ctxn;\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pmu, &pmus, entry) {\n\t\tcpuctx = get_cpu_ptr(pmu->pmu_cpu_context);\n\t\tif (cpuctx->unique_pmu != pmu)\n\t\t\tgoto next;\n\t\tperf_event_task_ctx(&cpuctx->ctx, task_event);\n\t\tctx = task_event->task_ctx;\n\t\tif (!ctx) {\n\t\t\tctxn = pmu->task_ctx_nr;\n\t\t\tif (ctxn < 0)\n\t\t\t\tgoto next;\n\t\t\tctx = rcu_dereference(current->perf_event_ctxp[ctxn]);\n\t\t\tif (ctx)\n\t\t\t\tperf_event_task_ctx(ctx, task_event);\n\t\t}\nnext:\n\t\tput_cpu_ptr(pmu->pmu_cpu_context);\n\t}\n\tif (task_event->task_ctx)\n\t\tperf_event_task_ctx(task_event->task_ctx, task_event);\n\trcu_read_unlock();\n}", "target": 0}
{"code": "CopyKeyAliasesToKeymap(struct xkb_keymap *keymap, KeyNamesInfo *info)\n{\n    AliasInfo *alias;\n    unsigned i, num_key_aliases;\n    struct xkb_key_alias *key_aliases;\n    num_key_aliases = 0;\n    darray_foreach(alias, info->aliases) {\n        if (!XkbKeyByName(keymap, alias->real, false)) {\n            log_vrb(info->ctx, 5,\n                    \"Attempt to alias %s to non-existent key %s; Ignored\\n\",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n        if (XkbKeyByName(keymap, alias->alias, false)) {\n            log_vrb(info->ctx, 5,\n                    \"Attempt to create alias with the name of a real key; \"\n                    \"Alias \\\"%s = %s\\\" ignored\\n\",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n        num_key_aliases++;\n    }\n    key_aliases = NULL;\n    if (num_key_aliases > 0) {\n        key_aliases = calloc(num_key_aliases, sizeof(*key_aliases));\n        if (!key_aliases)\n            return false;\n    }\n    i = 0;\n    darray_foreach(alias, info->aliases) {\n        if (alias->real != XKB_ATOM_NONE) {\n            key_aliases[i].alias = alias->alias;\n            key_aliases[i].real = alias->real;\n            i++;\n        }\n    }\n    keymap->num_key_aliases = num_key_aliases;\n    keymap->key_aliases = key_aliases;\n    return true;\n}", "target": 1}
{"code": "xfs_dinode_verify_fork(\n\tstruct xfs_dinode\t*dip,\n\tstruct xfs_mount\t*mp,\n\tint\t\t\twhichfork)\n{\n\tuint32_t\t\tdi_nextents = XFS_DFORK_NEXTENTS(dip, whichfork);\n\tswitch (XFS_DFORK_FORMAT(dip, whichfork)) {\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\tif (whichfork == XFS_DATA_FORK) {\n\t\t\tif (S_ISREG(be16_to_cpu(dip->di_mode)))\n\t\t\t\treturn __this_address;\n\t\t\tif (be64_to_cpu(dip->di_size) >\n\t\t\t\t\tXFS_DFORK_SIZE(dip, mp, whichfork))\n\t\t\t\treturn __this_address;\n\t\t}\n\t\tif (di_nextents)\n\t\t\treturn __this_address;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\tif (di_nextents > XFS_DFORK_MAXEXT(dip, mp, whichfork))\n\t\t\treturn __this_address;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tif (whichfork == XFS_ATTR_FORK) {\n\t\t\tif (di_nextents > MAXAEXTNUM)\n\t\t\t\treturn __this_address;\n\t\t} else if (di_nextents > MAXEXTNUM) {\n\t\t\treturn __this_address;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn __this_address;\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "Status PyArrayDescr_to_TF_DataType(PyArray_Descr* descr,\n                                   TF_DataType* out_tf_datatype) {\n  PyObject* key;\n  PyObject* value;\n  Py_ssize_t pos = 0;\n  if (descr->fields == nullptr) {\n    return errors::Internal(\"Unexpected numpy data type\");\n  }\n  if (PyDict_Next(descr->fields, &pos, &key, &value)) {\n    const char* key_string =\n        PyBytes_Check(key) ? PyBytes_AsString(key)\n                           : PyBytes_AsString(PyUnicode_AsASCIIString(key));\n    if (!key_string) {\n      return errors::Internal(\"Corrupt numpy type descriptor\");\n    }\n    tensorflow::string key = key_string;\n    if (key == \"quint8\") {\n      *out_tf_datatype = TF_QUINT8;\n    } else if (key == \"qint8\") {\n      *out_tf_datatype = TF_QINT8;\n    } else if (key == \"qint16\") {\n      *out_tf_datatype = TF_QINT16;\n    } else if (key == \"quint16\") {\n      *out_tf_datatype = TF_QUINT16;\n    } else if (key == \"qint32\") {\n      *out_tf_datatype = TF_QINT32;\n    } else if (key == \"resource\") {\n      *out_tf_datatype = TF_RESOURCE;\n    } else {\n      return errors::Internal(\"Unsupported numpy data type\");\n    }\n    return Status::OK();\n  }\n  return errors::Internal(\"Unsupported numpy data type\");\n}", "target": 0}
{"code": "SYSCALL_DEFINE3(rt_sigqueueinfo, pid_t, pid, int, sig,\n\t\tsiginfo_t __user *, uinfo)\n{\n\tsiginfo_t info;\n\tif (copy_from_user(&info, uinfo, sizeof(siginfo_t)))\n\t\treturn -EFAULT;\n\tif (info.si_code >= 0)\n\t\treturn -EPERM;\n\tinfo.si_signo = sig;\n\treturn kill_proc_info(sig, &info, pid);\n}", "target": 1}
{"code": "void Shell::DeleteInstance() {\n  delete instance_;\n  instance_ = nullptr;\n}", "target": 0}
{"code": "uint32_t sftp_parse_handle(struct sftpjob *job, struct handleid *id) {\n  uint32_t len, rc;\n  if((rc = sftp_parse_uint32(job, &len)) != SSH_FX_OK || len != 8 ||\n     (rc = sftp_parse_uint32(job, &id->id)) != SSH_FX_OK ||\n     (rc = sftp_parse_uint32(job, &id->tag) != SSH_FX_OK))\n    return rc;\n  return SSH_FX_OK;\n}", "target": 1}
{"code": "Status GetDeviceForInput(const EagerOperation& op, const EagerContext& ctx,\n                         TensorHandle* tensor_handle, Device** result) {\n  Device* cpu_device = ctx.HostCPU();\n  string device_name;\n  if (tensor_handle->Type() != TensorHandle::LOCAL) {\n    Device* device = tensor_handle->device();\n    device_name = device != nullptr ? device->name() : cpu_device->name();\n    *result = (device == nullptr ? cpu_device : device);\n  } else if (tensor_handle->dtype == DT_RESOURCE) {\n    const Tensor* tensor;\n    TF_RETURN_IF_ERROR(tensor_handle->Tensor(&tensor));\n    if (tensor->NumElements() == 0) {\n      return errors::InvalidArgument(\"Empty resource handle\");\n    }\n    const ResourceHandle& handle = tensor->flat<ResourceHandle>()(0);\n    device_name = handle.device();\n    Device* input_device;\n    TF_RETURN_IF_ERROR(\n        ctx.FindDeviceFromName(device_name.c_str(), &input_device));\n    *result = input_device;\n  } else {\n    Device* device = tensor_handle->device();\n    const bool is_tpu = device != nullptr && device->device_type() == \"TPU\";\n    const bool use_host_memory =\n        is_tpu ? MTypeFromDTypeIntsOnDevice(tensor_handle->dtype)\n               : MTypeFromDType(tensor_handle->dtype);\n    if (use_host_memory) {\n      *result = cpu_device;\n    } else {\n      if (!op.is_function() && device != nullptr && device != cpu_device) {\n        device = absl::get<Device*>(op.Device());\n      }\n      *result = (device == nullptr ? cpu_device : device);\n    }\n  }\n  return Status::OK();\n}", "target": 0}
{"code": "static int perf_trace_event_perm(struct ftrace_event_call *tp_event,\n\t\t\t\t struct perf_event *p_event)\n{\n\tif (ftrace_event_is_function(tp_event) &&\n\t    perf_paranoid_kernel() && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (!(p_event->attr.sample_type & PERF_SAMPLE_RAW))\n\t\treturn 0;\n\tif (p_event->attach_state == PERF_ATTACH_TASK) {\n\t\tif (tp_event->flags & TRACE_EVENT_FL_CAP_ANY)\n\t\t\treturn 0;\n\t}\n\tif (perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\treturn 0;\n}", "target": 1}
{"code": "static void _php_pgsql_notice_handler(void *resource_id, const char *message)\n{\n\tphp_pgsql_notice *notice;\n\tTSRMLS_FETCH();\n\tif (! PGG(ignore_notices)) {\n\t\tnotice = (php_pgsql_notice *)emalloc(sizeof(php_pgsql_notice));\n\t\tnotice->message = _php_pgsql_trim_message(message, (int *)&notice->len);\n\t\tif (PGG(log_notices)) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"%s\", notice->message);\n\t\t}\n\t\tzend_hash_index_update(&PGG(notices), (ulong)resource_id, (void **)&notice, sizeof(php_pgsql_notice *), NULL);\n\t}\n}", "target": 0}
{"code": "static void progress_handler(int progress, void *arg)\n{\n\tprintf(\"Progress=%d\\n\", progress);\n}", "target": 0}
{"code": "test_read_integer_error (xd3_stream *stream, usize_t trunto, const char *msg)\n{\n  uint64_t eval = 1ULL << 34;\n  uint32_t rval;\n  xd3_output *buf = NULL;\n  const uint8_t *max;\n  const uint8_t *inp;\n  int ret;\n  buf = xd3_alloc_output (stream, buf);\n  if ((ret = xd3_emit_uint64_t (stream, & buf, eval)))\n    {\n      goto fail;\n    }\n again:\n  inp = buf->base;\n  max = buf->base + buf->next - trunto;\n  if ((ret = xd3_read_uint32_t (stream, & inp, max, & rval)) != \n      XD3_INVALID_INPUT ||\n      !MSG_IS (msg))\n    {\n      ret = XD3_INTERNAL;\n    }\n  else if (trunto && trunto < buf->next)\n    {\n      trunto += 1;\n      goto again;\n    }\n  else\n    {\n      ret = 0;\n    }\n fail:\n  xd3_free_output (stream, buf);\n  return ret;\n}", "target": 1}
{"code": "wb_print(netdissect_options *ndo,\n         register const void *hdr, register u_int len)\n{\n\tregister const struct pkt_hdr *ph;\n\tph = (const struct pkt_hdr *)hdr;\n\tif (len < sizeof(*ph) || !ND_TTEST(*ph)) {\n\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\treturn;\n\t}\n\tlen -= sizeof(*ph);\n\tif (ph->ph_flags)\n\t\tND_PRINT((ndo, \"*\"));\n\tswitch (ph->ph_type) {\n\tcase PT_KILL:\n\t\tND_PRINT((ndo, \" wb-kill\"));\n\t\treturn;\n\tcase PT_ID:\n\t\tif (wb_id(ndo, (const struct pkt_id *)(ph + 1), len) >= 0)\n\t\t\treturn;\n\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\tbreak;\n\tcase PT_RREQ:\n\t\tif (wb_rreq(ndo, (const struct pkt_rreq *)(ph + 1), len) >= 0)\n\t\t\treturn;\n\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\tbreak;\n\tcase PT_RREP:\n\t\tif (wb_rrep(ndo, (const struct pkt_rrep *)(ph + 1), len) >= 0)\n\t\t\treturn;\n\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\tbreak;\n\tcase PT_DRAWOP:\n\t\tif (wb_drawop(ndo, (const struct pkt_dop *)(ph + 1), len) >= 0)\n\t\t\treturn;\n\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\tbreak;\n\tcase PT_PREQ:\n\t\tif (wb_preq(ndo, (const struct pkt_preq *)(ph + 1), len) >= 0)\n\t\t\treturn;\n\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\tbreak;\n\tcase PT_PREP:\n\t\tif (wb_prep(ndo, (const struct pkt_prep *)(ph + 1), len) >= 0)\n\t\t\treturn;\n\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \" wb-%d!\", ph->ph_type));\n\t\treturn;\n\t}\n}", "target": 0}
{"code": "ut64 MACH0_(get_baddr)(struct MACH0_(obj_t)* bin) {\n\tint i;\n\tif (bin->hdr.filetype != MH_EXECUTE && bin->hdr.filetype != MH_DYLINKER)\n\t\treturn 0;\n\tfor (i = 0; i < bin->nsegs; ++i)\n\t\tif (bin->segs[i].fileoff == 0 && bin->segs[i].filesize != 0)\n\t\t\treturn bin->segs[i].vmaddr;\n\treturn 0;\n}", "target": 1}
{"code": "slhc_free(struct slcompress *comp)\n{\n  printk(KERN_DEBUG \"Called IP function on non IP-system: slhc_free\");\n}", "target": 0}
{"code": "mmsMsg_parseFileName(char* filename, uint8_t* buffer, int* bufPos, int maxBufPos , uint32_t invokeId, ByteBuffer* response)\n{\n    if (*bufPos == maxBufPos)\n        return false;\n    uint8_t tag = buffer[(*bufPos)++];\n    if (tag != 0x19) {\n      mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n      return false;\n    }\n    int length;\n    *bufPos = BerDecoder_decodeLength(buffer, &length, *bufPos, maxBufPos);\n    if (*bufPos < 0)  {\n      mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n      return false;\n    }\n    if (length > 255) {\n      mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_REQUEST_INVALID_ARGUMENT, response);\n      return false;\n    }\n    memcpy(filename, buffer + *bufPos, length);\n    filename[length] = 0;\n    *bufPos += length;\n    if (strstr(filename, \"..\") != NULL) {\n        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILENAME_SYNTAX_ERROR);\n        return false;\n    }\n    return true;\n}", "target": 1}
{"code": "static void opt_kfree_rcu(struct rcu_head *head)\n{\n\tkfree(container_of(head, struct ip_options_rcu, rcu));\n}", "target": 0}
{"code": "static int sctp_getsockopt_assoc_stats(struct sock *sk, int len,\n\t\t\t\t       char __user *optval,\n\t\t\t\t       int __user *optlen)\n{\n\tstruct sctp_assoc_stats sas;\n\tstruct sctp_association *asoc = NULL;\n\tif (len < sizeof(sctp_assoc_t))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&sas, optval, len))\n\t\treturn -EFAULT;\n\tasoc = sctp_id2assoc(sk, sas.sas_assoc_id);\n\tif (!asoc)\n\t\treturn -EINVAL;\n\tsas.sas_rtxchunks = asoc->stats.rtxchunks;\n\tsas.sas_gapcnt = asoc->stats.gapcnt;\n\tsas.sas_outofseqtsns = asoc->stats.outofseqtsns;\n\tsas.sas_osacks = asoc->stats.osacks;\n\tsas.sas_isacks = asoc->stats.isacks;\n\tsas.sas_octrlchunks = asoc->stats.octrlchunks;\n\tsas.sas_ictrlchunks = asoc->stats.ictrlchunks;\n\tsas.sas_oodchunks = asoc->stats.oodchunks;\n\tsas.sas_iodchunks = asoc->stats.iodchunks;\n\tsas.sas_ouodchunks = asoc->stats.ouodchunks;\n\tsas.sas_iuodchunks = asoc->stats.iuodchunks;\n\tsas.sas_idupchunks = asoc->stats.idupchunks;\n\tsas.sas_opackets = asoc->stats.opackets;\n\tsas.sas_ipackets = asoc->stats.ipackets;\n\tsas.sas_maxrto = asoc->stats.max_obs_rto;\n\tmemcpy(&sas.sas_obs_rto_ipaddr, &asoc->stats.obs_rto_ipaddr,\n\t\tsizeof(struct sockaddr_storage));\n\tasoc->stats.max_obs_rto = asoc->rto_min;\n\tlen = min_t(size_t, len, sizeof(sas));\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tSCTP_DEBUG_PRINTK(\"sctp_getsockopt_assoc_stat(%d): %d\\n\",\n\t\t\t  len, sas.sas_assoc_id);\n\tif (copy_to_user(optval, &sas, len))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1}
{"code": "static int ndp_sock_recv(struct ndp *ndp)\n{\n\tstruct ndp_msg *msg;\n\tenum ndp_msg_type msg_type;\n\tsize_t len;\n\tint err;\n\tmsg = ndp_msg_alloc();\n\tif (!msg)\n\t\treturn -ENOMEM;\n\tlen = ndp_msg_payload_maxlen(msg);\n\terr = myrecvfrom6(ndp->sock, msg->buf, &len, 0,\n\t\t\t  &msg->addrto, &msg->ifindex);\n\tif (err) {\n\t\terr(ndp, \"Failed to receive message\");\n\t\tgoto free_msg;\n\t}\n\tdbg(ndp, \"rcvd from: %s, ifindex: %u\",\n\t\t str_in6_addr(&msg->addrto), msg->ifindex);\n\tif (len < sizeof(*msg->icmp6_hdr)) {\n\t\twarn(ndp, \"rcvd icmp6 packet too short (%luB)\", len);\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\terr = ndp_msg_type_by_raw_type(&msg_type, msg->icmp6_hdr->icmp6_type);\n\tif (err) {\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\tndp_msg_init(msg, msg_type);\n\tndp_msg_payload_len_set(msg, len);\n\tif (!ndp_msg_check_valid(msg)) {\n\t\twarn(ndp, \"rcvd invalid ND message\");\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\tdbg(ndp, \"rcvd %s, len: %zuB\",\n\t\t ndp_msg_type_info(msg_type)->strabbr, len);\n\tif (!ndp_msg_check_opts(msg)) {\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\terr = ndp_call_handlers(ndp, msg);;\nfree_msg:\n\tndp_msg_destroy(msg);\n\treturn err;\n}", "target": 1}
{"code": "cgiGetVariable(const char *name)\t\n{\n  const _cgi_var_t\t*var;\t\t\n  var = cgi_find_variable(name);\n  return ((var == NULL) ? NULL : _cupsStrRetain(var->values[var->nvalues - 1]));\n}", "target": 0}
{"code": "static int ion_handle_put(struct ion_handle *handle)\n{\n\tstruct ion_client *client = handle->client;\n\tint ret;\n\tmutex_lock(&client->lock);\n\tret = kref_put(&handle->ref, ion_handle_destroy);\n\tmutex_unlock(&client->lock);\n\treturn ret;\n}", "target": 1}
{"code": "static size_t send_control_msg(VirtIOSerial *vser, void *buf, size_t len)\n{\n    VirtQueueElement elem;\n    VirtQueue *vq;\n    vq = vser->c_ivq;\n    if (!virtio_queue_ready(vq)) {\n        return 0;\n    }\n    if (!virtqueue_pop(vq, &elem)) {\n        return 0;\n    }\n    memcpy(elem.in_sg[0].iov_base, buf, len);\n    virtqueue_push(vq, &elem, len);\n    virtio_notify(VIRTIO_DEVICE(vser), vq);\n    return len;\n}", "target": 1}
{"code": "static int perf_swevent_init(struct perf_event *event)\n{\n\tint event_id = event->attr.config;\n\tif (event->attr.type != PERF_TYPE_SOFTWARE)\n\t\treturn -ENOENT;\n\tif (has_branch_stack(event))\n\t\treturn -EOPNOTSUPP;\n\tswitch (event_id) {\n\tcase PERF_COUNT_SW_CPU_CLOCK:\n\tcase PERF_COUNT_SW_TASK_CLOCK:\n\t\treturn -ENOENT;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (event_id >= PERF_COUNT_SW_MAX)\n\t\treturn -ENOENT;\n\tif (!event->parent) {\n\t\tint err;\n\t\terr = swevent_hlist_get(event);\n\t\tif (err)\n\t\t\treturn err;\n\t\tstatic_key_slow_inc(&perf_swevent_enabled[event_id]);\n\t\tevent->destroy = sw_perf_event_destroy;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void zrandmemberCommand(client *c) {\n    long l;\n    int withscores = 0;\n    robj *zset;\n    listpackEntry ele;\n    if (c->argc >= 3) {\n        if (getRangeLongFromObjectOrReply(c,c->argv[2],-LONG_MAX,LONG_MAX,&l,NULL) != C_OK) return;\n        if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"withscores\"))) {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return;\n        } else if (c->argc == 4) {\n            withscores = 1;\n            if (l < -LONG_MAX/2 || l > LONG_MAX/2) {\n                addReplyError(c,\"value is out of range\");\n                return;\n            }\n        }\n        zrandmemberWithCountCommand(c, l, withscores);\n        return;\n    }\n    if ((zset = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp]))== NULL ||\n        checkType(c,zset,OBJ_ZSET)) {\n        return;\n    }\n    zsetTypeRandomElement(zset, zsetLength(zset), &ele,NULL);\n    zsetReplyFromListpackEntry(c,&ele);\n}", "target": 0}
{"code": "static MagickBooleanType ReadPSDChannelPixels(Image *image,const ssize_t row,\n  const PixelChannel channel,const unsigned char *pixels,\n  ExceptionInfo *exception)\n{\n  Quantum\n    pixel;\n  const unsigned char\n    *p;\n  Quantum\n    *q;\n  ssize_t\n    x;\n  size_t\n    packet_size;\n  p=pixels;\n  q=GetAuthenticPixels(image,0,row,image->columns,1,exception);\n  if (q == (Quantum *) NULL)\n    return MagickFalse;\n  packet_size=GetPSDPacketSize(image);\n  for (x=0; x < (ssize_t) image->columns; x++)\n  {\n    if (packet_size == 1)\n      pixel=ScaleCharToQuantum(*p++);\n    else\n      if (packet_size == 2)\n        {\n          unsigned short\n            nibble;\n          p=PushShortPixel(MSBEndian,p,&nibble);\n          pixel=ScaleShortToQuantum(nibble);\n        }\n      else\n        {\n          MagickFloatType\n            nibble;\n          p=PushFloatPixel(MSBEndian,p,&nibble);\n          pixel=ClampToQuantum(((MagickRealType) QuantumRange)*nibble);\n        }\n    if (image->depth > 1)\n      {\n        SetPSDPixel(image,channel,packet_size,pixel,q,exception);\n        q+=GetPixelChannels(image);\n      }\n    else\n      {\n        ssize_t\n          bit,\n          number_bits;\n        number_bits=(ssize_t) image->columns-x;\n        if (number_bits > 8)\n          number_bits=8;\n        for (bit = 0; bit < (ssize_t) number_bits; bit++)\n        {\n          SetPSDPixel(image,channel,packet_size,(((unsigned char) pixel)\n            & (0x01 << (7-bit))) != 0 ? 0 : QuantumRange,q,exception);\n          q+=GetPixelChannels(image);\n          x++;\n        }\n        if (x != (ssize_t) image->columns)\n          x--;\n        continue;\n      }\n  }\n  return(SyncAuthenticPixels(image,exception));\n}", "target": 1}
{"code": "static int rfcomm_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)\n{\n\tstruct sockaddr_rc *sa = (struct sockaddr_rc *) addr;\n\tstruct sock *sk = sock->sk;\n\tint chan = sa->rc_channel;\n\tint err = 0;\n\tBT_DBG(\"sk %p %pMR\", sk, &sa->rc_bdaddr);\n\tif (!addr || addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\tlock_sock(sk);\n\tif (sk->sk_state != BT_OPEN) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\tif (sk->sk_type != SOCK_STREAM) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\twrite_lock(&rfcomm_sk_list.lock);\n\tif (chan && __rfcomm_get_listen_sock_by_addr(chan, &sa->rc_bdaddr)) {\n\t\terr = -EADDRINUSE;\n\t} else {\n\t\tbacpy(&rfcomm_pi(sk)->src, &sa->rc_bdaddr);\n\t\trfcomm_pi(sk)->channel = chan;\n\t\tsk->sk_state = BT_BOUND;\n\t}\n\twrite_unlock(&rfcomm_sk_list.lock);\ndone:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 1}
{"code": "kdc_process_s4u2proxy_req(kdc_realm_t *kdc_active_realm,\n                          krb5_kdc_req *request,\n                          const krb5_enc_tkt_part *t2enc,\n                          const krb5_db_entry *server,\n                          krb5_const_principal server_princ,\n                          krb5_const_principal proxy_princ,\n                          const char **status)\n{\n    krb5_error_code errcode;\n    if (request->kdc_options & (NON_TGT_OPTION | KDC_OPT_ENC_TKT_IN_SKEY)) {\n        *status = \"INVALID_S4U2PROXY_OPTIONS\";\n        return KRB5KDC_ERR_BADOPTION;\n    }\n    if (!krb5_principal_compare(kdc_context,\n                                server->princ, \n                                server_princ)) {\n        *status = \"EVIDENCE_TICKET_MISMATCH\";\n        return KRB5KDC_ERR_SERVER_NOMATCH;\n    }\n    if (!isflagset(t2enc->flags, TKT_FLG_FORWARDABLE)) {\n        *status = \"EVIDENCE_TKT_NOT_FORWARDABLE\";\n        return KRB5_TKT_NOT_FORWARDABLE;\n    }\n    errcode = check_allowed_to_delegate_to(kdc_context,\n                                           t2enc->client,\n                                           server,\n                                           proxy_princ);\n    if (errcode) {\n        *status = \"NOT_ALLOWED_TO_DELEGATE\";\n        return errcode;\n    }\n    return 0;\n}", "target": 0}
{"code": "dissect_ac_if_hdr_body(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,\n        proto_tree *tree, usb_conv_info_t *usb_conv_info)\n{\n    gint     offset_start;\n    guint16  bcdADC;\n    guint8   ver_major;\n    double   ver;\n    guint8   if_in_collection, i;\n    audio_conv_info_t *audio_conv_info;\n    offset_start = offset;\n    bcdADC = tvb_get_letohs(tvb, offset);\n    ver_major = USB_AUDIO_BCD44_TO_DEC(bcdADC>>8);\n    ver = ver_major + USB_AUDIO_BCD44_TO_DEC(bcdADC&0xFF) / 100.0;\n    proto_tree_add_double_format_value(tree, hf_ac_if_hdr_ver,\n            tvb, offset, 2, ver, \"%2.2f\", ver);\n    audio_conv_info = (audio_conv_info_t *)usb_conv_info->class_data;\n    if(!audio_conv_info) {\n        audio_conv_info = wmem_new(wmem_file_scope(), audio_conv_info_t);\n        usb_conv_info->class_data = audio_conv_info;\n        usb_conv_info->class_data_type = USB_CONV_AUDIO;\n    } else if (usb_conv_info->class_data_type != USB_CONV_AUDIO) {\n        return 0;\n    }\n    audio_conv_info->ver_major = ver_major;\n    offset += 2;\n    if (ver_major==1) {\n        proto_tree_add_item(tree, hf_ac_if_hdr_total_len,\n                tvb, offset, 2, ENC_LITTLE_ENDIAN);\n        offset += 2;\n        if_in_collection = tvb_get_guint8(tvb, offset);\n        proto_tree_add_item(tree, hf_ac_if_hdr_bInCollection,\n                tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        offset++;\n        for (i=0; i<if_in_collection; i++) {\n            proto_tree_add_item(tree, hf_ac_if_hdr_if_num,\n                    tvb, offset, 1, ENC_LITTLE_ENDIAN);\n            offset++;\n        }\n    }\n    return offset-offset_start;\n}", "target": 0}
{"code": "static unsigned int stack_maxrandom_size(void)\n{\n\tunsigned int max = 0;\n\tif ((current->flags & PF_RANDOMIZE) &&\n\t\t!(current->personality & ADDR_NO_RANDOMIZE)) {\n\t\tmax = ((-1U) & STACK_RND_MASK) << PAGE_SHIFT;\n\t}\n\treturn max;\n}", "target": 1}
{"code": "TEST_F(GroupVerifierTest, TestRequiresAnyWithAllowMissingButOk) {\n  TestUtility::loadFromYaml(RequiresAnyConfig, proto_config_);\n  proto_config_.mutable_rules(0)\n      ->mutable_requires()\n      ->mutable_requires_any()\n      ->add_requirements()\n      ->mutable_allow_missing();\n  createAsyncMockAuthsAndVerifier(std::vector<std::string>{\"example_provider\", \"other_provider\"});\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  callbacks_[\"example_provider\"](Status::JwtMissed);\n  callbacks_[\"other_provider\"](Status::JwtUnknownIssuer);\n}", "target": 1}
{"code": "static int l2cap_build_conf_req(struct sock *sk, void *data)\n{\n\tstruct l2cap_pinfo *pi = l2cap_pi(sk);\n\tstruct l2cap_conf_req *req = data;\n\tstruct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };\n\tvoid *ptr = req->data;\n\tBT_DBG(\"sk %p\", sk);\n\tswitch (pi->mode) {\n\tcase L2CAP_MODE_BASIC:\n\t\tif (pi->imtu != L2CAP_DEFAULT_MTU)\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->imtu);\n\t\tbreak;\n\tcase L2CAP_MODE_ERTM:\n\t\trfc.mode            = L2CAP_MODE_ERTM;\n\t\trfc.txwin_size      = L2CAP_DEFAULT_RX_WINDOW;\n\t\trfc.max_transmit    = L2CAP_DEFAULT_MAX_RECEIVE;\n\t\trfc.retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO);\n\t\trfc.monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO);\n\t\trfc.max_pdu_size    = cpu_to_le16(L2CAP_DEFAULT_MAX_RX_APDU);\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,\n\t\t\t\t\tsizeof(rfc), (unsigned long) &rfc);\n\t\tbreak;\n\t}\n\treq->dcid  = cpu_to_le16(pi->dcid);\n\treq->flags = cpu_to_le16(0);\n\treturn ptr - data;\n}", "target": 1}
{"code": "static void mem_cgroup_usage_unregister_event(struct cgroup *cgrp,\n\tstruct cftype *cft, struct eventfd_ctx *eventfd)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_cont(cgrp);\n\tstruct mem_cgroup_thresholds *thresholds;\n\tstruct mem_cgroup_threshold_ary *new;\n\tint type = MEMFILE_TYPE(cft->private);\n\tu64 usage;\n\tint i, j, size;\n\tmutex_lock(&memcg->thresholds_lock);\n\tif (type == _MEM)\n\t\tthresholds = &memcg->thresholds;\n\telse if (type == _MEMSWAP)\n\t\tthresholds = &memcg->memsw_thresholds;\n\telse\n\t\tBUG();\n\tBUG_ON(!thresholds);\n\tusage = mem_cgroup_usage(memcg, type == _MEMSWAP);\n\t__mem_cgroup_threshold(memcg, type == _MEMSWAP);\n\tsize = 0;\n\tfor (i = 0; i < thresholds->primary->size; i++) {\n\t\tif (thresholds->primary->entries[i].eventfd != eventfd)\n\t\t\tsize++;\n\t}\n\tnew = thresholds->spare;\n\tif (!size) {\n\t\tkfree(new);\n\t\tnew = NULL;\n\t\tgoto swap_buffers;\n\t}\n\tnew->size = size;\n\tnew->current_threshold = -1;\n\tfor (i = 0, j = 0; i < thresholds->primary->size; i++) {\n\t\tif (thresholds->primary->entries[i].eventfd == eventfd)\n\t\t\tcontinue;\n\t\tnew->entries[j] = thresholds->primary->entries[i];\n\t\tif (new->entries[j].threshold < usage) {\n\t\t\t++new->current_threshold;\n\t\t}\n\t\tj++;\n\t}\nswap_buffers:\n\tthresholds->spare = thresholds->primary;\n\trcu_assign_pointer(thresholds->primary, new);\n\tsynchronize_rcu();\n\tmutex_unlock(&memcg->thresholds_lock);\n}", "target": 1}
{"code": "int jpc_tsfb_synthesize(jpc_tsfb_t *tsfb, jas_seq2d_t *a)\n{\n\treturn (tsfb->numlvls > 0) ? jpc_tsfb_synthesize2(tsfb,\n\t  jas_seq2d_getref(a, jas_seq2d_xstart(a), jas_seq2d_ystart(a)),\n\t  jas_seq2d_xstart(a), jas_seq2d_ystart(a), jas_seq2d_width(a),\n\t  jas_seq2d_height(a), jas_seq2d_rowstep(a), tsfb->numlvls - 1) : 0;\n}", "target": 1}
{"code": "static void sunkbd_enable(struct sunkbd *sunkbd, bool enable)\n{\n\tserio_pause_rx(sunkbd->serio);\n\tsunkbd->enabled = enable;\n\tserio_continue_rx(sunkbd->serio);\n\tif (!enable) {\n\t\twake_up_interruptible(&sunkbd->wait);\n\t\tcancel_work_sync(&sunkbd->tq);\n\t}\n}", "target": 0}
{"code": "long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\tkey_ref = lookup_user_key(keyid, 0, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n\tkey = key_ref_to_ptr(key_ref);\n\tret = key_read_state(key);\n\tif (ret < 0)\n\t\tgoto error2; \n\tret = key_permission(key_ref, KEY_NEED_READ);\n\tif (ret == 0)\n\t\tgoto can_read_key;\n\tif (ret != -EACCES)\n\t\tgoto error2;\n\tif (!is_key_possessed(key_ref)) {\n\t\tret = -EACCES;\n\t\tgoto error2;\n\t}\ncan_read_key:\n\tret = -EOPNOTSUPP;\n\tif (key->type->read) {\n\t\tdown_read(&key->sem);\n\t\tret = key_validate(key);\n\t\tif (ret == 0)\n\t\t\tret = key->type->read(key, buffer, buflen);\n\t\tup_read(&key->sem);\n\t}\nerror2:\n\tkey_put(key);\nerror:\n\treturn ret;\n}", "target": 0}
{"code": "inline int MatchingDim(const RuntimeShape& shape1, int index1,\n                       const RuntimeShape& shape2, int index2) {\n  TFLITE_DCHECK_EQ(shape1.Dims(index1), shape2.Dims(index2));\n  return shape1.Dims(index1);\n}", "target": 1}
{"code": "static inline __u32 skb_get_rxhash(struct sk_buff *skb)\n{\n\tif (!skb->l4_rxhash)\n\t\t__skb_get_rxhash(skb);\n\treturn skb->rxhash;\n}", "target": 0}
{"code": "static char *tls_text_name(X509_NAME *name, int nid)\n{\n\tint     pos;\n\tX509_NAME_ENTRY *entry;\n\tASN1_STRING *entry_str;\n\tint     utf8_length;\n\tunsigned char *utf8_value;\n\tchar *result;\n\tif (name == 0 || (pos = X509_NAME_get_index_by_NID(name, nid, -1)) < 0) {\n\t\treturn NULL;\n    }\n    entry = X509_NAME_get_entry(name, pos);\n    g_return_val_if_fail(entry != NULL, NULL);\n    entry_str = X509_NAME_ENTRY_get_data(entry);\n    g_return_val_if_fail(entry_str != NULL, NULL);\n    if ((utf8_length = ASN1_STRING_to_UTF8(&utf8_value, entry_str)) < 0) {\n    \tg_warning(\"Error decoding ASN.1 type=%d\", ASN1_STRING_type(entry_str));\n    \treturn NULL;\n    }\n    if (has_internal_nul((char *)utf8_value, utf8_length)) {\n    \tg_warning(\"NUL character in hostname in certificate\");\n    \tOPENSSL_free(utf8_value);\n    \treturn NULL;\n    }\n    result = g_strdup((char *) utf8_value);\n\tOPENSSL_free(utf8_value);\n\treturn result;\n}", "target": 0}
{"code": "static void vmx_set_msr_bitmap(struct kvm_vcpu *vcpu)\n{\n\tunsigned long *msr_bitmap;\n\tif (is_guest_mode(vcpu))\n\t\tmsr_bitmap = vmx_msr_bitmap_nested;\n\telse if (vcpu->arch.apic_base & X2APIC_ENABLE) {\n\t\tif (is_long_mode(vcpu))\n\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode_x2apic;\n\t\telse\n\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy_x2apic;\n\t} else {\n\t\tif (is_long_mode(vcpu))\n\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode;\n\t\telse\n\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy;\n\t}\n\tvmcs_write64(MSR_BITMAP, __pa(msr_bitmap));\n}", "target": 1}
{"code": "int compat_get_timex(struct timex *txc, const struct compat_timex __user *utp)\n{\n\tstruct compat_timex tx32;\n\tmemset(txc, 0, sizeof(struct timex));\n\tif (copy_from_user(&tx32, utp, sizeof(struct compat_timex)))\n\t\treturn -EFAULT;\n\ttxc->modes = tx32.modes;\n\ttxc->offset = tx32.offset;\n\ttxc->freq = tx32.freq;\n\ttxc->maxerror = tx32.maxerror;\n\ttxc->esterror = tx32.esterror;\n\ttxc->status = tx32.status;\n\ttxc->constant = tx32.constant;\n\ttxc->precision = tx32.precision;\n\ttxc->tolerance = tx32.tolerance;\n\ttxc->time.tv_sec = tx32.time.tv_sec;\n\ttxc->time.tv_usec = tx32.time.tv_usec;\n\ttxc->tick = tx32.tick;\n\ttxc->ppsfreq = tx32.ppsfreq;\n\ttxc->jitter = tx32.jitter;\n\ttxc->shift = tx32.shift;\n\ttxc->stabil = tx32.stabil;\n\ttxc->jitcnt = tx32.jitcnt;\n\ttxc->calcnt = tx32.calcnt;\n\ttxc->errcnt = tx32.errcnt;\n\ttxc->stbcnt = tx32.stbcnt;\n\treturn 0;\n}", "target": 0}
{"code": "static char* umocktypes_stringify_FLOW_HANDLE(const FLOW_HANDLE* value)\n{\n    char temp_buffer[32];\n    char* result;\n    size_t length = sprintf(temp_buffer, \"%p\", (void*)*value);\n    if (length < 0)\n    {\n        result = NULL;\n    }\n    else\n    {\n        result = (char*)malloc(length + 1);\n        if (result != NULL)\n        {\n            (void)memcpy(result, temp_buffer, length + 1);\n        }\n    }\n    return result;\n}", "target": 0}
{"code": "QString Utils::String::toHtmlEscaped(const QString &str)\n{\n#ifdef QBT_USES_QT5\n    return str.toHtmlEscaped();\n#else\n    return Qt::escape(str);\n#endif\n}", "target": 0}
{"code": "static void iriap_getvaluebyclass_indication(struct iriap_cb *self,\n\t\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct ias_object *obj;\n\tstruct ias_attrib *attrib;\n\tint name_len;\n\tint attr_len;\n\tchar name[IAS_MAX_CLASSNAME + 1];\t\n\tchar attr[IAS_MAX_ATTRIBNAME + 1];\t\n\t__u8 *fp;\n\tint n;\n\tIRDA_DEBUG(4, \"%s()\\n\", __func__);\n\tIRDA_ASSERT(self != NULL, return;);\n\tIRDA_ASSERT(self->magic == IAS_MAGIC, return;);\n\tIRDA_ASSERT(skb != NULL, return;);\n\tfp = skb->data;\n\tn = 1;\n\tname_len = fp[n++];\n\tIRDA_ASSERT(name_len < IAS_MAX_CLASSNAME + 1, return;);\n\tmemcpy(name, fp+n, name_len); n+=name_len;\n\tname[name_len] = '\\0';\n\tattr_len = fp[n++];\n\tIRDA_ASSERT(attr_len < IAS_MAX_ATTRIBNAME + 1, return;);\n\tmemcpy(attr, fp+n, attr_len); n+=attr_len;\n\tattr[attr_len] = '\\0';\n\tIRDA_DEBUG(4, \"LM-IAS: Looking up %s: %s\\n\", name, attr);\n\tobj = irias_find_object(name);\n\tif (obj == NULL) {\n\t\tIRDA_DEBUG(2, \"LM-IAS: Object %s not found\\n\", name);\n\t\tiriap_getvaluebyclass_response(self, 0x1235, IAS_CLASS_UNKNOWN,\n\t\t\t\t\t       &irias_missing);\n\t\treturn;\n\t}\n\tIRDA_DEBUG(4, \"LM-IAS: found %s, id=%d\\n\", obj->name, obj->id);\n\tattrib = irias_find_attrib(obj, attr);\n\tif (attrib == NULL) {\n\t\tIRDA_DEBUG(2, \"LM-IAS: Attribute %s not found\\n\", attr);\n\t\tiriap_getvaluebyclass_response(self, obj->id,\n\t\t\t\t\t       IAS_ATTRIB_UNKNOWN,\n\t\t\t\t\t       &irias_missing);\n\t\treturn;\n\t}\n\tiriap_getvaluebyclass_response(self, obj->id, IAS_SUCCESS,\n\t\t\t\t       attrib->value);\n}", "target": 0}
{"code": "void test_parser_hvi(void) {\n\ttest_parser_param(1);\n}", "target": 0}
{"code": "int sr_do_ioctl(Scsi_CD *cd, struct packet_command *cgc)\n{\n\tstruct scsi_device *SDev;\n\tstruct scsi_sense_hdr sshdr;\n\tint result, err = 0, retries = 0;\n\tSDev = cd->device;\n      retry:\n\tif (!scsi_block_when_processing_errors(SDev)) {\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\tresult = scsi_execute(SDev, cgc->cmd, cgc->data_direction,\n\t\t\t      cgc->buffer, cgc->buflen,\n\t\t\t      (unsigned char *)cgc->sense, &sshdr,\n\t\t\t      cgc->timeout, IOCTL_RETRIES, 0, 0, NULL);\n\tif (driver_byte(result) != 0) {\n\t\tswitch (sshdr.sense_key) {\n\t\tcase UNIT_ATTENTION:\n\t\t\tSDev->changed = 1;\n\t\t\tif (!cgc->quiet)\n\t\t\t\tsr_printk(KERN_INFO, cd,\n\t\t\t\t\t  \"disc change detected.\\n\");\n\t\t\tif (retries++ < 10)\n\t\t\t\tgoto retry;\n\t\t\terr = -ENOMEDIUM;\n\t\t\tbreak;\n\t\tcase NOT_READY:\t\n\t\t\tif (sshdr.asc == 0x04 &&\n\t\t\t    sshdr.ascq == 0x01) {\n\t\t\t\tif (!cgc->quiet)\n\t\t\t\t\tsr_printk(KERN_INFO, cd,\n\t\t\t\t\t\t  \"CDROM not ready yet.\\n\");\n\t\t\t\tif (retries++ < 10) {\n\t\t\t\t\tssleep(2);\n\t\t\t\t\tgoto retry;\n\t\t\t\t} else {\n\t\t\t\t\terr = -ENOMEDIUM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!cgc->quiet)\n\t\t\t\tsr_printk(KERN_INFO, cd,\n\t\t\t\t\t  \"CDROM not ready.  Make sure there \"\n\t\t\t\t\t  \"is a disc in the drive.\\n\");\n\t\t\terr = -ENOMEDIUM;\n\t\t\tbreak;\n\t\tcase ILLEGAL_REQUEST:\n\t\t\terr = -EIO;\n\t\t\tif (sshdr.asc == 0x20 &&\n\t\t\t    sshdr.ascq == 0x00)\n\t\t\t\terr = -EDRIVE_CANT_DO_THIS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EIO;\n\t\t}\n\t}\n      out:\n\tcgc->stat = err;\n\treturn err;\n}", "target": 1}
{"code": "static inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n#ifdef CONFIG_NUMA\n\treturn s->node[node];\n#else\n\treturn &s->local_node;\n#endif\n}", "target": 0}
{"code": "  void readEOF() noexcept override {\n    LOG(INFO) << \"Got EOF\";\n    auto chain = IOBuf::create(0);\n    for (size_t i = 0; i < 1000 * 1000; i++) {\n      auto buf = IOBuf::create(10);\n      buf->append(10);\n      memset(buf->writableData(), 'x', 10);\n      chain->prependChain(std::move(buf));\n    }\n    socket_->writeChain(&writeCallback_, std::move(chain));\n  }", "target": 0}
{"code": "static long ec_device_ioctl_xcmd(struct cros_ec_dev *ec, void __user *arg)\n{\n\tlong ret;\n\tstruct cros_ec_command u_cmd;\n\tstruct cros_ec_command *s_cmd;\n\tif (copy_from_user(&u_cmd, arg, sizeof(u_cmd)))\n\t\treturn -EFAULT;\n\tif ((u_cmd.outsize > EC_MAX_MSG_BYTES) ||\n\t    (u_cmd.insize > EC_MAX_MSG_BYTES))\n\t\treturn -EINVAL;\n\ts_cmd = kmalloc(sizeof(*s_cmd) + max(u_cmd.outsize, u_cmd.insize),\n\t\t\tGFP_KERNEL);\n\tif (!s_cmd)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(s_cmd, arg, sizeof(*s_cmd) + u_cmd.outsize)) {\n\t\tret = -EFAULT;\n\t\tgoto exit;\n\t}\n\ts_cmd->command += ec->cmd_offset;\n\tret = cros_ec_cmd_xfer(ec->ec_dev, s_cmd);\n\tif (ret < 0)\n\t\tgoto exit;\n\tif (copy_to_user(arg, s_cmd, sizeof(*s_cmd) + u_cmd.insize))\n\t\tret = -EFAULT;\nexit:\n\tkfree(s_cmd);\n\treturn ret;\n}", "target": 1}
{"code": "static inline struct ipv6_txoptions *txopt_get(const struct ipv6_pinfo *np)\n{\n\tstruct ipv6_txoptions *opt;\n\trcu_read_lock();\n\topt = rcu_dereference(np->opt);\n\tif (opt && !atomic_inc_not_zero(&opt->refcnt))\n\t\topt = NULL;\n\trcu_read_unlock();\n\treturn opt;\n}", "target": 0}
{"code": "struct xt_table_info *xt_alloc_table_info(unsigned int size)\n{\n\tstruct xt_table_info *info = NULL;\n\tsize_t sz = sizeof(*info) + size;\n\tif (sz < sizeof(*info))\n\t\treturn NULL;\n\tif ((SMP_ALIGN(size) >> PAGE_SHIFT) + 2 > totalram_pages)\n\t\treturn NULL;\n\tif (sz <= (PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER))\n\t\tinfo = kmalloc(sz, GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);\n\tif (!info) {\n\t\tinfo = vmalloc(sz);\n\t\tif (!info)\n\t\t\treturn NULL;\n\t}\n\tmemset(info, 0, sizeof(*info));\n\tinfo->size = size;\n\treturn info;\n}", "target": 0}
{"code": "xmlParseMarkupDecl(xmlParserCtxtPtr ctxt) {\n    GROW;\n    if (CUR == '<') {\n        if (NXT(1) == '!') {\n\t    switch (NXT(2)) {\n\t        case 'E':\n\t\t    if (NXT(3) == 'L')\n\t\t\txmlParseElementDecl(ctxt);\n\t\t    else if (NXT(3) == 'N')\n\t\t\txmlParseEntityDecl(ctxt);\n\t\t    break;\n\t        case 'A':\n\t\t    xmlParseAttributeListDecl(ctxt);\n\t\t    break;\n\t        case 'N':\n\t\t    xmlParseNotationDecl(ctxt);\n\t\t    break;\n\t        case '-':\n\t\t    xmlParseComment(ctxt);\n\t\t    break;\n\t\tdefault:\n\t\t    break;\n\t    }\n\t} else if (NXT(1) == '?') {\n\t    xmlParsePI(ctxt);\n\t}\n    }\n    if ((ctxt->external == 0) && (ctxt->inputNr == 1))\n\txmlParsePEReference(ctxt);\n    if ((ctxt->external == 0) && (ctxt->inputNr > 1)) {\n        if ((RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {\n\t    xmlParseConditionalSections(ctxt);\n\t}\n    }\n    ctxt->instate = XML_PARSER_DTD;\n}", "target": 0}
{"code": "static int __init memory_tier_init(void)\n{\n\tint ret, node;\n\tstruct memory_tier *memtier;\n\tret = subsys_virtual_register(&memory_tier_subsys, NULL);\n\tif (ret)\n\t\tpanic(\"%s() failed to register memory tier subsystem\\n\", __func__);\n#ifdef CONFIG_MIGRATION\n\tnode_demotion = kcalloc(nr_node_ids, sizeof(struct demotion_nodes),\n\t\t\t\tGFP_KERNEL);\n\tWARN_ON(!node_demotion);\n#endif\n\tmutex_lock(&memory_tier_lock);\n\tdefault_dram_type = alloc_memory_type(MEMTIER_ADISTANCE_DRAM);\n\tif (!default_dram_type)\n\t\tpanic(\"%s() failed to allocate default DRAM tier\\n\", __func__);\n\tfor_each_node_state(node, N_MEMORY) {\n\t\tmemtier = set_node_memory_tier(node);\n\t\tif (IS_ERR(memtier))\n\t\t\tbreak;\n\t}\n\testablish_demotion_targets();\n\tmutex_unlock(&memory_tier_lock);\n\thotplug_memory_notifier(memtier_hotplug_callback, MEMTIER_HOTPLUG_PRI);\n\treturn 0;\n}", "target": 1}
{"code": "\tChunk *outChunk() { return m_outChunk.get(); }", "target": 0}
{"code": "wsemul_vt100_output_dcs(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tu_int newstate = VT100_EMUL_STATE_DCS;\n\tswitch (instate->inchar) {\n\tcase '0': case '1': case '2': case '3': case '4':\n\tcase '5': case '6': case '7': case '8': case '9':\n\t\tif (edp->nargs > VT100_EMUL_NARGS - 1)\n\t\t\tbreak;\n\t\tedp->args[edp->nargs] = (edp->args[edp->nargs] * 10) +\n\t\t    (instate->inchar - '0');\n\t\tbreak;\n\tcase ';': \n\t\tedp->nargs++;\n\t\tbreak;\n\tdefault:\n\t\tedp->nargs++;\n\t\tif (edp->nargs > VT100_EMUL_NARGS) {\n#ifdef VT100_DEBUG\n\t\t\tprintf(\"vt100: too many arguments\\n\");\n#endif\n\t\t\tedp->nargs = VT100_EMUL_NARGS;\n\t\t}\n\t\tnewstate = VT100_EMUL_STATE_STRING;\n\t\tswitch (instate->inchar) {\n\t\tcase '$':\n\t\t\tnewstate = VT100_EMUL_STATE_DCS_DOLLAR;\n\t\t\tbreak;\n\t\tcase '{': \t\n\t\tcase '!': \n\t\tcase '|': \n#ifdef VT100_PRINTNOTIMPL\n\t\t\tprintf(\"DCS%c ignored\\n\", (char)instate->inchar);\n#endif\n\t\t\tbreak;\n\t\tdefault:\n#ifdef VT100_PRINTUNKNOWN\n\t\t\tprintf(\"DCS %x (%d, %d) unknown\\n\", instate->inchar,\n\t\t\t    ARG(0), ARG(1));\n#endif\n\t\t\tbreak;\n\t\t}\n\t}\n\tedp->state = newstate;\n\treturn 0;\n}", "target": 1}
{"code": "static RBinWasmCustomNameEntry *parse_custom_name_entry(RBinWasmObj *bin, ut64 bound) {\n\tRBuffer *b = bin->buf;\n\tRBinWasmCustomNameEntry *cust = R_NEW0 (RBinWasmCustomNameEntry);\n\tif (!cust) {\n\t\treturn NULL;\n\t}\n\tcust->type = R_BIN_WASM_NAMETYPE_None;\n\tsize_t start = r_buf_tell (b);\n\tif (!consume_u7_r (b, bound, &cust->type)) {\n\t\tgoto beach;\n\t};\n\tif (!consume_u32_r (b, bound, &cust->size)) {\n\t\tgoto beach;\n\t};\n\tswitch (cust->type) {\n\tcase R_BIN_WASM_NAMETYPE_Module:\n\t\tif (!consume_encoded_name_new (b, bound, NULL, &cust->mod_name)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tbreak;\n\tcase R_BIN_WASM_NAMETYPE_Function:\n\t\tcust->func = R_NEW0 (RBinWasmCustomNameFunctionNames);\n\t\tif (!cust->func) {\n\t\t\tgoto beach;\n\t\t}\n\t\tcust->func->names = r_id_storage_new (0, UT32_MAX);\n\t\tif (!cust->func->names) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (!parse_namemap (b, bound, cust->func->names, &cust->func->count)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tbreak;\n\tcase R_BIN_WASM_NAMETYPE_Local:\n\t\tcust->local = parse_custom_names_local (b, bound);\n\t\tif (!cust->local) {\n\t\t\tgoto beach;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tR_LOG_WARN (\"[wasm] Halting custom name section parsing at unknown type 0x%x offset 0x%\" PFMTSZx \"\\n\", cust->type, start);\n\t\tcust->type = R_BIN_WASM_NAMETYPE_None;\n\t\tgoto beach;\n\t}\n\treturn cust;\nbeach:\n\twasm_custom_name_free (cust);\n\treturn NULL;\n}", "target": 0}
{"code": "ikev2_ke_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len _U_, const u_char *ep _U_,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct ikev2_ke ke;\n\tconst struct ikev2_ke *k;\n\tk = (const struct ikev2_ke *)ext;\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&ke, ext, sizeof(ke));\n\tikev2_pay_print(ndo, NPSTR(tpay), ke.h.critical);\n\tND_PRINT((ndo,\" len=%u group=%s\", ntohs(ke.h.len) - 8,\n\t\t  STR_OR_ID(ntohs(ke.ke_group), dh_p_map)));\n\tif (2 < ndo->ndo_vflag && 8 < ntohs(ke.h.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(k + 1), ntohs(ke.h.len) - 8))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(ke.h.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}", "target": 1}
{"code": "static int gup_huge_pmd(pmd_t orig, pmd_t *pmdp, unsigned long addr,\n\t\tunsigned long end, int write, struct page **pages, int *nr)\n{\n\tstruct page *head, *page;\n\tint refs;\n\tif (!pmd_access_permitted(orig, write))\n\t\treturn 0;\n\tif (pmd_devmap(orig))\n\t\treturn __gup_device_huge_pmd(orig, pmdp, addr, end, pages, nr);\n\trefs = 0;\n\tpage = pmd_page(orig) + ((addr & ~PMD_MASK) >> PAGE_SHIFT);\n\tdo {\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\t\tpage++;\n\t\trefs++;\n\t} while (addr += PAGE_SIZE, addr != end);\n\thead = compound_head(pmd_page(orig));\n\tif (!page_cache_add_speculative(head, refs)) {\n\t\t*nr -= refs;\n\t\treturn 0;\n\t}\n\tif (unlikely(pmd_val(orig) != pmd_val(*pmdp))) {\n\t\t*nr -= refs;\n\t\twhile (refs--)\n\t\t\tput_page(head);\n\t\treturn 0;\n\t}\n\tSetPageReferenced(head);\n\treturn 1;\n}", "target": 1}
{"code": "static int nfc_genl_llc_set_params(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tstruct nfc_llcp_local *local;\n\tu8 rw = 0;\n\tu16 miux = 0;\n\tu32 idx;\n\tint rc = 0;\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    (!info->attrs[NFC_ATTR_LLC_PARAM_LTO] &&\n\t     !info->attrs[NFC_ATTR_LLC_PARAM_RW] &&\n\t     !info->attrs[NFC_ATTR_LLC_PARAM_MIUX]))\n\t\treturn -EINVAL;\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_RW]) {\n\t\trw = nla_get_u8(info->attrs[NFC_ATTR_LLC_PARAM_RW]);\n\t\tif (rw > LLCP_MAX_RW)\n\t\t\treturn -EINVAL;\n\t}\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_MIUX]) {\n\t\tmiux = nla_get_u16(info->attrs[NFC_ATTR_LLC_PARAM_MIUX]);\n\t\tif (miux > LLCP_MAX_MIUX)\n\t\t\treturn -EINVAL;\n\t}\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\tdevice_lock(&dev->dev);\n\tlocal = nfc_llcp_find_local(dev);\n\tif (!local) {\n\t\trc = -ENODEV;\n\t\tgoto exit;\n\t}\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_LTO]) {\n\t\tif (dev->dep_link_up) {\n\t\t\trc = -EINPROGRESS;\n\t\t\tgoto exit;\n\t\t}\n\t\tlocal->lto = nla_get_u8(info->attrs[NFC_ATTR_LLC_PARAM_LTO]);\n\t}\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_RW])\n\t\tlocal->rw = rw;\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_MIUX])\n\t\tlocal->miux = cpu_to_be16(miux);\nexit:\n\tdevice_unlock(&dev->dev);\n\tnfc_put_device(dev);\n\treturn rc;\n}", "target": 1}
{"code": "int kvm_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr)\n{\n\tswitch (msr->index) {\n\tcase MSR_FS_BASE:\n\tcase MSR_GS_BASE:\n\tcase MSR_KERNEL_GS_BASE:\n\tcase MSR_CSTAR:\n\tcase MSR_LSTAR:\n\t\tif (is_noncanonical_address(msr->data))\n\t\t\treturn 1;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\tmsr->data = get_canonical(msr->data);\n\t}\n\treturn kvm_x86_ops->set_msr(vcpu, msr);\n}", "target": 0}
{"code": "h2_vfp_body(struct vfp_ctx *vc, struct vfp_entry *vfe, void *ptr, ssize_t *lp)\n{\n\tstruct h2_req *r2;\n\tstruct h2_sess *h2;\n\tunsigned l;\n\tenum vfp_status retval = VFP_OK;\n\tCHECK_OBJ_NOTNULL(vc, VFP_CTX_MAGIC);\n\tCHECK_OBJ_NOTNULL(vfe, VFP_ENTRY_MAGIC);\n\tCAST_OBJ_NOTNULL(r2, vfe->priv1, H2_REQ_MAGIC);\n\th2 = r2->h2sess;\n\tAN(ptr);\n\tAN(lp);\n\tl = *lp;\n\t*lp = 0;\n\tLck_Lock(&h2->sess->mtx);\n\tassert (r2->state == H2_S_OPEN);\n\tr2->cond = &vc->wrk->cond;\n\twhile (h2->mailcall != r2 && h2->error == 0 && r2->error == 0)\n\t\tAZ(Lck_CondWait(r2->cond, &h2->sess->mtx, 0));\n\tr2->cond = NULL;\n\tif (h2->error || r2->error) {\n\t\tretval = VFP_ERROR;\n\t} else {\n\t\tassert(h2->mailcall == r2);\n\t\tif (l > h2->rxf_len)\n\t\t\tl = h2->rxf_len;\n\t\tif (l > 0) {\n\t\t\tmemcpy(ptr, h2->rxf_data, l);\n\t\t\th2->rxf_data += l;\n\t\t\th2->rxf_len -= l;\n\t\t}\n\t\t*lp = l;\n\t\tif (h2->rxf_len > 0) {\n\t\t\tLck_Unlock(&h2->sess->mtx);\n\t\t\treturn (VFP_OK);\n\t\t}\n\t\tif (h2->rxf_len == 0) {\n\t\t\tif (h2->rxf_flags & H2FF_DATA_END_STREAM) {\n\t\t\t\tretval = VFP_END;\n\t\t\t\tr2->state = H2_S_CLOS_REM;\n\t\t\t}\n\t\t}\n\t\th2->mailcall = NULL;\n\t\tAZ(pthread_cond_signal(h2->cond));\n\t}\n\tLck_Unlock(&h2->sess->mtx);\n\treturn (retval);\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in_shape = context->input(0);\n    const Tensor& out_backprop = context->input(1);\n    OP_REQUIRES(\n        context,\n        tensor_in_shape.dims() == 1 && tensor_in_shape.NumElements() == 5,\n        errors::InvalidArgument(\"tensor_in must be 1-dimensional and 5 \"\n                                \"elements\"));\n    OP_REQUIRES(context, out_backprop.dims() == 5,\n                errors::InvalidArgument(\"out_backprop must be 5-dimensional\"));\n    TensorShape output_shape;\n    auto shape_vec = tensor_in_shape.vec<int32>();\n    for (int64_t i = 0; i < tensor_in_shape.NumElements(); ++i) {\n      output_shape.AddDim(shape_vec(i));\n    }\n    Tensor* output;\n    OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output));\n    std::array<int64_t, 3> input_size{\n        {GetTensorDim(output_shape, data_format_, '2'),\n         GetTensorDim(output_shape, data_format_, '1'),\n         GetTensorDim(output_shape, data_format_, '0')}};\n    std::array<int64_t, 3> window{{GetTensorDim(ksize_, data_format_, '2'),\n                                   GetTensorDim(ksize_, data_format_, '1'),\n                                   GetTensorDim(ksize_, data_format_, '0')}};\n    std::array<int64_t, 3> stride{{GetTensorDim(stride_, data_format_, '2'),\n                                   GetTensorDim(stride_, data_format_, '1'),\n                                   GetTensorDim(stride_, data_format_, '0')}};\n    std::array<int64_t, 3> padding, out;\n    OP_REQUIRES_OK(context, Get3dOutputSize(input_size, window, stride,\n                                            padding_, &out, &padding));\n    LaunchAvgPooling3dGradOp<Device, T>::launch(\n        context, output_shape, out_backprop, window, stride, out, padding,\n        data_format_, output);\n  }", "target": 1}
{"code": "int create_history_entry(krb5_context context,\n                         krb5_keyblock *hist_key, int n_key_data,\n                         krb5_key_data *key_data, osa_pw_hist_ent *hist)\n{\n    krb5_error_code ret;\n    krb5_keyblock key;\n    krb5_keysalt salt;\n    int i;\n    hist->key_data = k5calloc(n_key_data, sizeof(krb5_key_data), &ret);\n    if (hist->key_data == NULL)\n        return ret;\n    for (i = 0; i < n_key_data; i++) {\n        ret = krb5_dbe_decrypt_key_data(context, NULL, &key_data[i], &key,\n                                        &salt);\n        if (ret)\n            return ret;\n        ret = krb5_dbe_encrypt_key_data(context, hist_key, &key, &salt,\n                                        key_data[i].key_data_kvno,\n                                        &hist->key_data[i]);\n        if (ret)\n            return ret;\n        krb5_free_keyblock_contents(context, &key);\n    }\n    hist->n_key_data = n_key_data;\n    return 0;\n}", "target": 0}
{"code": "void DoEmbedProfile(const char* ProfileFile)\n{\n    FILE* f;\n    size_t size, EmbedLen;\n    cmsUInt8Number* EmbedBuffer;\n        f = fopen(ProfileFile, \"rb\");\n        if (f == NULL) return;\n        size = cmsfilelength(f);\n        EmbedBuffer = (cmsUInt8Number*) malloc(size + 1);\n        EmbedLen = fread(EmbedBuffer, 1, size, f);\n        fclose(f);\n        EmbedBuffer[EmbedLen] = 0;\n        write_icc_profile (&Compressor, EmbedBuffer, EmbedLen);\n        free(EmbedBuffer);\n}", "target": 0}
{"code": "static void xen_netbk_idx_release(struct xen_netbk *netbk, u16 pending_idx)\n{\n\tstruct xenvif *vif;\n\tstruct pending_tx_info *pending_tx_info;\n\tpending_ring_idx_t index;\n\tif (netbk->mmap_pages[pending_idx] == NULL)\n\t\treturn;\n\tpending_tx_info = &netbk->pending_tx_info[pending_idx];\n\tvif = pending_tx_info->vif;\n\tmake_tx_response(vif, &pending_tx_info->req, XEN_NETIF_RSP_OKAY);\n\tindex = pending_index(netbk->pending_prod++);\n\tnetbk->pending_ring[index] = pending_idx;\n\txenvif_put(vif);\n\tnetbk->mmap_pages[pending_idx]->mapping = 0;\n\tput_page(netbk->mmap_pages[pending_idx]);\n\tnetbk->mmap_pages[pending_idx] = NULL;\n}", "target": 1}
{"code": "yang_read_string(struct ly_ctx *ctx, const char *input, char *output, int size, int offset, int indent)\n{\n    int i = 0, out_index = offset, space = 0;\n    while (i < size) {\n        switch (input[i]) {\n        case '\\n':\n            out_index -= space;\n            output[out_index] = '\\n';\n            space = 0;\n            i = read_indent(input, indent, size, i + 1, &out_index, output);\n            break;\n        case ' ':\n        case '\\t':\n            output[out_index] = input[i];\n            ++space;\n            break;\n        case '\\\\':\n            if (input[i + 1] == 'n') {\n                out_index -= space;\n                output[out_index] = '\\n';\n                space = 0;\n                i = read_indent(input, indent, size, i + 2, &out_index, output);\n            } else if (input[i + 1] == 't') {\n                output[out_index] = '\\t';\n                ++i;\n                ++space;\n            } else if (input[i + 1] == '\\\\') {\n                output[out_index] = '\\\\';\n                ++i;\n            } else if ((i + 1) != size && input[i + 1] == '\"') {\n                output[out_index] = '\"';\n                ++i;\n            } else {\n                LOGVAL(ctx, LYE_XML_INCHAR, LY_VLOG_NONE, NULL, input + i);\n                return NULL;\n            }\n            break;\n        default:\n            output[out_index] = input[i];\n            space = 0;\n            break;\n        }\n        ++i;\n        ++out_index;\n    }\n    output[out_index] = '\\0';\n    if (size != out_index) {\n        output = realloc(output, out_index + 1);\n        LY_CHECK_ERR_RETURN(!output, LOGMEM(ctx), NULL);\n    }\n    return output;\n}", "target": 0}
{"code": "gimp_write_and_read_file (Gimp     *gimp,\n                          gboolean  with_unusual_stuff,\n                          gboolean  compat_paths,\n                          gboolean  use_gimp_2_8_features)\n{\n  GimpImage           *image;\n  GimpImage           *loaded_image;\n  GimpPlugInProcedure *proc;\n  gchar               *filename;\n  GFile               *file;\n  image = gimp_create_mainimage (gimp,\n                                 with_unusual_stuff,\n                                 compat_paths,\n                                 use_gimp_2_8_features);\n  gimp_assert_mainimage (image,\n                         with_unusual_stuff,\n                         compat_paths,\n                         use_gimp_2_8_features);\n  filename = g_build_filename (g_get_tmp_dir (), \"gimp-test.xcf\", NULL);\n  file = g_file_new_for_path (filename);\n  g_free (filename);\n  proc = gimp_plug_in_manager_file_procedure_find (image->gimp->plug_in_manager,\n                                                   GIMP_FILE_PROCEDURE_GROUP_SAVE,\n                                                   file,\n                                                   NULL );\n  file_save (gimp,\n             image,\n             NULL ,\n             file,\n             proc,\n             GIMP_RUN_NONINTERACTIVE,\n             FALSE ,\n             FALSE ,\n             FALSE ,\n             NULL );\n  loaded_image = gimp_test_load_image (image->gimp, file);\n  gimp_assert_mainimage (loaded_image,\n                         with_unusual_stuff,\n                         compat_paths,\n                         use_gimp_2_8_features);\n  g_file_delete (file, NULL, NULL);\n  g_object_unref (file);\n}", "target": 1}
{"code": "Bool gf_sg_proto_field_is_sftime_offset(GF_Node *node, GF_FieldInfo *field)\n{\n\tu32 i;\n\tGF_Route *r;\n\tGF_ProtoInstance *inst;\n\tGF_FieldInfo inf;\n\tif (node->sgprivate->tag != TAG_ProtoNode) return 0;\n\tif (field->fieldType != GF_SG_VRML_SFTIME) return 0;\n\tinst = (GF_ProtoInstance *) node;\n\ti=0;\n\twhile ((r = (GF_Route*)gf_list_enum(inst->proto_interface->sub_graph->Routes, &i))) {\n\t\tif (!r->IS_route) continue;\n\t\tif (r->FromNode || (r->FromField.fieldIndex != field->fieldIndex)) continue;\n\t\tgf_node_get_field(r->ToNode, r->ToField.fieldIndex, &inf);\n\t\tif (r->ToNode->sgprivate->tag == TAG_ProtoNode) return gf_sg_proto_field_is_sftime_offset(r->ToNode, &inf);\n\t\tif (!stricmp(inf.name, \"startTime\") || !stricmp(inf.name, \"stopTime\")) return 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "isoclns_print(netdissect_options *ndo,\n              const uint8_t *p, u_int length, u_int caplen)\n{\n\tif (caplen <= 1) { \n\t\tND_PRINT((ndo, \"|OSI\"));\n\t\treturn;\n\t}\n\tif (ndo->ndo_eflag)\n\t\tND_PRINT((ndo, \"OSI NLPID %s (0x%02x): \", tok2str(nlpid_values, \"Unknown\", *p), *p));\n\tswitch (*p) {\n\tcase NLPID_CLNP:\n\t\tif (!clnp_print(ndo, p, length))\n\t\t\tprint_unknown_data(ndo, p, \"\\n\\t\", caplen);\n\t\tbreak;\n\tcase NLPID_ESIS:\n\t\tesis_print(ndo, p, length);\n\t\treturn;\n\tcase NLPID_ISIS:\n\t\tif (!isis_print(ndo, p, length))\n\t\t\tprint_unknown_data(ndo, p, \"\\n\\t\", caplen);\n\t\tbreak;\n\tcase NLPID_NULLNS:\n\t\tND_PRINT((ndo, \"%slength: %u\", ndo->ndo_eflag ? \"\" : \", \", length));\n\t\tbreak;\n\tcase NLPID_Q933:\n\t\tq933_print(ndo, p + 1, length - 1);\n\t\tbreak;\n\tcase NLPID_IP:\n\t\tip_print(ndo, p + 1, length - 1);\n\t\tbreak;\n\tcase NLPID_IP6:\n\t\tip6_print(ndo, p + 1, length - 1);\n\t\tbreak;\n\tcase NLPID_PPP:\n\t\tppp_print(ndo, p + 1, length - 1);\n\t\tbreak;\n\tdefault:\n\t\tif (!ndo->ndo_eflag)\n\t\t\tND_PRINT((ndo, \"OSI NLPID 0x%02x unknown\", *p));\n\t\tND_PRINT((ndo, \"%slength: %u\", ndo->ndo_eflag ? \"\" : \", \", length));\n\t\tif (caplen > 1)\n\t\t\tprint_unknown_data(ndo, p, \"\\n\\t\", caplen);\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "static gboolean is_correct_filename(const char *value)\n{\n    return printable_str(value) && !strchr(value, '/') && !strchr(value, '.');\n}", "target": 1}
{"code": "flatpak_proxy_client_finalize (GObject *object)\n{\n  FlatpakProxyClient *client = FLATPAK_PROXY_CLIENT (object);\n  client->proxy->clients = g_list_remove (client->proxy->clients, client);\n  g_clear_object (&client->proxy);\n  g_byte_array_free (client->auth_buffer, TRUE);\n  g_hash_table_destroy (client->rewrite_reply);\n  g_hash_table_destroy (client->get_owner_reply);\n  g_hash_table_destroy (client->unique_id_policy);\n  free_side (&client->client_side);\n  free_side (&client->bus_side);\n  G_OBJECT_CLASS (flatpak_proxy_client_parent_class)->finalize (object);\n}", "target": 0}
{"code": "x509_verify_ctx_add_chain(struct x509_verify_ctx *ctx,\n    struct x509_verify_chain *chain, char *name)\n{\n\tsize_t depth;\n\tX509 *last = x509_verify_chain_last(chain);\n\tX509 *leaf = x509_verify_chain_leaf(chain);\n\tdepth = sk_X509_num(chain->certs);\n\tif (depth > 0)\n\t\tdepth--;\n\tif (ctx->chains_count >= ctx->max_chains)\n\t\treturn x509_verify_cert_error(ctx, last, depth,\n\t\t    X509_V_ERR_CERT_CHAIN_TOO_LONG, 0);\n\tif (chain->cert_errors[depth] ==\n\t    X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY)\n\t\tchain->cert_errors[depth] = X509_V_OK;\n\tif (!x509_verify_ctx_validate_legacy_chain(ctx, chain, depth))\n\t\treturn 0;\n\tif ((ctx->chains[ctx->chains_count] = x509_verify_chain_dup(chain)) ==\n\t    NULL) {\n\t\treturn x509_verify_cert_error(ctx, last, depth,\n\t\t    X509_V_ERR_OUT_OF_MEM, 0);\n\t}\n\tif (!x509_verify_cert_valid(ctx, leaf, NULL))\n\t\treturn 0;\n\tif (!x509_verify_cert_hostname(ctx, leaf, name))\n\t\treturn 0;\n\tctx->chains_count++;\n\tctx->error = X509_V_OK;\n\tctx->error_depth = depth;\n\treturn 1;\n}", "target": 1}
{"code": "int key_reject_and_link(struct key *key,\n\t\t\tunsigned timeout,\n\t\t\tunsigned error,\n\t\t\tstruct key *keyring,\n\t\t\tstruct key *authkey)\n{\n\tstruct assoc_array_edit *edit;\n\tstruct timespec now;\n\tint ret, awaken, link_ret = 0;\n\tkey_check(key);\n\tkey_check(keyring);\n\tawaken = 0;\n\tret = -EBUSY;\n\tif (keyring) {\n\t\tif (keyring->restrict_link)\n\t\t\treturn -EPERM;\n\t\tlink_ret = __key_link_begin(keyring, &key->index_key, &edit);\n\t}\n\tmutex_lock(&key_construction_mutex);\n\tif (!test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {\n\t\tatomic_inc(&key->user->nikeys);\n\t\tkey->reject_error = -error;\n\t\tsmp_wmb();\n\t\tset_bit(KEY_FLAG_NEGATIVE, &key->flags);\n\t\tset_bit(KEY_FLAG_INSTANTIATED, &key->flags);\n\t\tnow = current_kernel_time();\n\t\tkey->expiry = now.tv_sec + timeout;\n\t\tkey_schedule_gc(key->expiry + key_gc_delay);\n\t\tif (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags))\n\t\t\tawaken = 1;\n\t\tret = 0;\n\t\tif (keyring && link_ret == 0)\n\t\t\t__key_link(key, &edit);\n\t\tif (authkey)\n\t\t\tkey_revoke(authkey);\n\t}\n\tmutex_unlock(&key_construction_mutex);\n\tif (keyring)\n\t\t__key_link_end(keyring, &key->index_key, edit);\n\tif (awaken)\n\t\twake_up_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT);\n\treturn ret == 0 ? link_ret : ret;\n}", "target": 1}
{"code": "static GF_SampleGroupDescriptionBox *get_sgdp(GF_SampleTableBox *stbl, void *traf, u32 grouping_type, Bool *is_traf_sgdp)\n#endif \n{\n\tGF_List *groupList=NULL;\n\tGF_List **parent=NULL;\n\tGF_SampleGroupDescriptionBox *sgdesc=NULL;\n\tu32 count, i;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (!stbl && traf && traf->trex->track->Media->information->sampleTable)\n\t\tstbl = traf->trex->track->Media->information->sampleTable;\n#endif\n\tif (stbl) {\n\t\tif (!stbl->sampleGroupsDescription && !traf)\n\t\t\tstbl->sampleGroupsDescription = gf_list_new();\n\t\tgroupList = stbl->sampleGroupsDescription;\n\t\tif (is_traf_sgdp) *is_traf_sgdp = GF_FALSE;\n\t\tparent = &stbl->child_boxes;\n\t\tcount = gf_list_count(groupList);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(groupList, i);\n\t\t\tif (sgdesc->grouping_type==grouping_type) break;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t}\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (!sgdesc && traf) {\n\t\tif (!traf->sampleGroupsDescription)\n\t\t\ttraf->sampleGroupsDescription = gf_list_new();\n\t\tgroupList = traf->sampleGroupsDescription;\n\t\tparent = &traf->child_boxes;\n\t\tif (is_traf_sgdp) *is_traf_sgdp = GF_TRUE;\n\t\tcount = gf_list_count(groupList);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(groupList, i);\n\t\t\tif (sgdesc->grouping_type==grouping_type) break;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t}\n#endif\n\tif (!sgdesc) {\n\t\tsgdesc = (GF_SampleGroupDescriptionBox *) gf_isom_box_new_parent(parent, GF_ISOM_BOX_TYPE_SGPD);\n\t\tif (!sgdesc) return NULL;\n\t\tsgdesc->grouping_type = grouping_type;\n\t\tassert(groupList);\n\t\tgf_list_add(groupList, sgdesc);\n\t}\n\treturn sgdesc;\n}", "target": 1}
{"code": "static void __return_cfs_rq_runtime(struct cfs_rq *cfs_rq)\n{\n\tstruct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(cfs_rq->tg);\n\ts64 slack_runtime = cfs_rq->runtime_remaining - min_cfs_rq_runtime;\n\tif (slack_runtime <= 0)\n\t\treturn;\n\traw_spin_lock(&cfs_b->lock);\n\tif (cfs_b->quota != RUNTIME_INF &&\n\t    cfs_rq->runtime_expires == cfs_b->runtime_expires) {\n\t\tcfs_b->runtime += slack_runtime;\n\t\tif (cfs_b->runtime > sched_cfs_bandwidth_slice() &&\n\t\t    !list_empty(&cfs_b->throttled_cfs_rq))\n\t\t\tstart_cfs_slack_bandwidth(cfs_b);\n\t}\n\traw_spin_unlock(&cfs_b->lock);\n\tcfs_rq->runtime_remaining -= slack_runtime;\n}", "target": 1}
{"code": "static int llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t  int *uaddrlen, int peer)\n{\n\tstruct sockaddr_llc sllc;\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tint rc = 0;\n\tmemset(&sllc, 0, sizeof(sllc));\n\tlock_sock(sk);\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\t*uaddrlen = sizeof(sllc);\n\tmemset(uaddr, 0, *uaddrlen);\n\tif (peer) {\n\t\trc = -ENOTCONN;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\t\tif(llc->dev)\n\t\t\tsllc.sllc_arphrd = llc->dev->type;\n\t\tsllc.sllc_sap = llc->daddr.lsap;\n\t\tmemcpy(&sllc.sllc_mac, &llc->daddr.mac, IFHWADDRLEN);\n\t} else {\n\t\trc = -EINVAL;\n\t\tif (!llc->sap)\n\t\t\tgoto out;\n\t\tsllc.sllc_sap = llc->sap->laddr.lsap;\n\t\tif (llc->dev) {\n\t\t\tsllc.sllc_arphrd = llc->dev->type;\n\t\t\tmemcpy(&sllc.sllc_mac, llc->dev->dev_addr,\n\t\t\t       IFHWADDRLEN);\n\t\t}\n\t}\n\trc = 0;\n\tsllc.sllc_family = AF_LLC;\n\tmemcpy(uaddr, &sllc, sizeof(sllc));\nout:\n\trelease_sock(sk);\n\treturn rc;\n}", "target": 1}
{"code": "static int mincore_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,\n\t\t\tstruct mm_walk *walk)\n{\n\tspinlock_t *ptl;\n\tstruct vm_area_struct *vma = walk->vma;\n\tpte_t *ptep;\n\tunsigned char *vec = walk->private;\n\tint nr = (end - addr) >> PAGE_SHIFT;\n\tptl = pmd_trans_huge_lock(pmd, vma);\n\tif (ptl) {\n\t\tmemset(vec, 1, nr);\n\t\tspin_unlock(ptl);\n\t\tgoto out;\n\t}\n\tif (pmd_trans_unstable(pmd)) {\n\t\t__mincore_unmapped_range(addr, end, vma, vec);\n\t\tgoto out;\n\t}\n\tptep = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);\n\tfor (; addr != end; ptep++, addr += PAGE_SIZE) {\n\t\tpte_t pte = *ptep;\n\t\tif (pte_none(pte))\n\t\t\t__mincore_unmapped_range(addr, addr + PAGE_SIZE,\n\t\t\t\t\t\t vma, vec);\n\t\telse if (pte_present(pte))\n\t\t\t*vec = 1;\n\t\telse { \n\t\t\tswp_entry_t entry = pte_to_swp_entry(pte);\n\t\t\tif (non_swap_entry(entry)) {\n\t\t\t\t*vec = 1;\n\t\t\t} else {\n#ifdef CONFIG_SWAP\n\t\t\t\t*vec = mincore_page(swap_address_space(entry),\n\t\t\t\t\t\t    swp_offset(entry));\n#else\n\t\t\t\tWARN_ON(1);\n\t\t\t\t*vec = 1;\n#endif\n\t\t\t}\n\t\t}\n\t\tvec++;\n\t}\n\tpte_unmap_unlock(ptep - 1, ptl);\nout:\n\twalk->private += nr;\n\tcond_resched();\n\treturn 0;\n}", "target": 1}
{"code": "TfLiteStatus PrepareHashtableFind(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 3);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input_resource_id_tensor =\n      GetInput(context, node, kInputResourceIdTensor);\n  TF_LITE_ENSURE_EQ(context, input_resource_id_tensor->type, kTfLiteInt32);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input_resource_id_tensor), 1);\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(input_resource_id_tensor, 0), 1);\n  const TfLiteTensor* default_value_tensor =\n      GetInput(context, node, kDefaultValueTensor);\n  const TfLiteTensor* key_tensor = GetInput(context, node, kKeyTensor);\n  TfLiteTensor* output_tensor = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE_EQ(context, default_value_tensor->type, output_tensor->type);\n  TF_LITE_ENSURE(context, (key_tensor->type == kTfLiteInt64 &&\n                           output_tensor->type == kTfLiteString) ||\n                              (key_tensor->type == kTfLiteString &&\n                               output_tensor->type == kTfLiteInt64));\n  return context->ResizeTensor(context, output_tensor,\n                               TfLiteIntArrayCopy(key_tensor->dims));\n}", "target": 1}
{"code": "void next_character(void)\n{\n    if (!recovery_started) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_UnexpectedMessage, \"Not in Recovery mode\");\n        layoutHome();\n        return;\n    }\n    strlcpy(cipher, english_alphabet, ENGLISH_ALPHABET_BUF);\n    random_permute_char(cipher, strlen(cipher));\n    static char CONFIDENTIAL current_word[CURRENT_WORD_BUF];\n    get_current_word(current_word);\n    if (strlen(current_word) > 4) {\n        memzero(current_word, sizeof(current_word));\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_SyntaxError,\n                        \"Words were not entered correctly. Make sure you are using the substition cipher.\");\n        layoutHome();\n        return;\n    }\n    CharacterRequest resp;\n    memset(&resp, 0, sizeof(CharacterRequest));\n    resp.word_pos = get_current_word_pos();\n    resp.character_pos = strlen(current_word);\n    msg_write(MessageType_MessageType_CharacterRequest, &resp);\n    bool auto_completed = false;\n    if (strlen(current_word) >= 3) {\n        auto_completed = attempt_auto_complete(current_word);\n    }\n#if DEBUG_LINK\n    if (auto_completed) {\n        strlcpy(auto_completed_word, current_word, CURRENT_WORD_BUF);\n    } else {\n        auto_completed_word[0] = '\\0';\n    }\n#endif\n    format_current_word(current_word, auto_completed);\n    layout_cipher(current_word, cipher);\n    memzero(current_word, sizeof(current_word));\n}", "target": 0}
{"code": "RunTerminationHelper(HANDLE console_token, DWORD pid) {\n  WCHAR module_path[MAX_PATH];\n  GetModuleFileNameW(NULL, module_path, _countof(module_path));\n  std::wstring command { module_path };\n  command += L\" --terminate \" + std::to_wstring(pid);\n  STARTUPINFOW startup_info = {};\n  startup_info.cb = sizeof(startup_info);\n  startup_info.lpDesktop = (LPWSTR) L\"winsta0\\\\default\";\n  PROCESS_INFORMATION process_info;\n  if (!CreateProcessAsUserW(console_token,\n        NULL,\n        (LPWSTR) command.c_str(),\n        NULL,\n        NULL,\n        FALSE,\n        CREATE_UNICODE_ENVIRONMENT | DETACHED_PROCESS,\n        NULL,\n        NULL,\n        &startup_info,\n        &process_info)) {\n    return false;\n  }\n  WaitForSingleObject(process_info.hProcess, INFINITE);\n  DWORD exit_code;\n  GetExitCodeProcess(process_info.hProcess, &exit_code);\n  CloseHandle(process_info.hProcess);\n  CloseHandle(process_info.hThread);\n  return exit_code == 0;\n}", "target": 1}
{"code": "psf_allocate (void)\n{\tSF_PRIVATE * psf ;\n\tif ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)\n\t\treturn\tNULL ;\n\tif ((psf->header.ptr = calloc (1, INITAL_HEADER_SIZE)) == NULL)\n\t{\tfree (psf) ;\n\t\treturn\tNULL ;\n\t\t} ;\n\tpsf->header.len = INITAL_HEADER_SIZE ;\n\treturn psf ;\n} ", "target": 0}
{"code": "static bool comp_add_to_data(zckCtx *zck, zckComp *comp, const char *src,\n                             size_t src_size) {\n    VALIDATE_BOOL(zck);\n    ALLOCD_BOOL(zck, comp);\n    ALLOCD_BOOL(zck, src);\n    if((comp->data_size > comp->data_size + src_size) ||\n       (src_size > comp->data_size + src_size)) {\n        zck_log(ZCK_LOG_ERROR, \"Integer overflow when reading data\");\n        return false;\n    }\n    comp->data = zrealloc(comp->data, comp->data_size + src_size);\n    if (!comp->data) {\n        zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n        return false;\n    }\n    zck_log(ZCK_LOG_DEBUG, \"Adding %llu bytes to compressed buffer\",\n        (long long unsigned) src_size);\n    memcpy(comp->data + comp->data_size, src, src_size);\n    comp->data_size += src_size;\n    comp->data_loc += src_size;\n    return true;\n}", "target": 0}
{"code": "static void update_exception_bitmap(struct kvm_vcpu *vcpu)\n{\n\tu32 eb;\n\teb = (1u << PF_VECTOR) | (1u << UD_VECTOR) | (1u << MC_VECTOR) |\n\t     (1u << NM_VECTOR) | (1u << DB_VECTOR);\n\tif ((vcpu->guest_debug &\n\t     (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP)) ==\n\t    (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP))\n\t\teb |= 1u << BP_VECTOR;\n\tif (to_vmx(vcpu)->rmode.vm86_active)\n\t\teb = ~0;\n\tif (enable_ept)\n\t\teb &= ~(1u << PF_VECTOR); \n\tif (vcpu->fpu_active)\n\t\teb &= ~(1u << NM_VECTOR);\n\tif (is_guest_mode(vcpu))\n\t\teb |= get_vmcs12(vcpu)->exception_bitmap;\n\tvmcs_write32(EXCEPTION_BITMAP, eb);\n}", "target": 1}
{"code": "mlx5_fw_fatal_reporter_dump(struct devlink_health_reporter *reporter,\n\t\t\t    struct devlink_fmsg *fmsg, void *priv_ctx)\n{\n\tstruct mlx5_core_dev *dev = devlink_health_reporter_priv(reporter);\n\tu32 crdump_size = dev->priv.health.crdump_size;\n\tu32 *cr_data;\n\tu32 data_size;\n\tu32 offset;\n\tint err;\n\tif (!mlx5_core_is_pf(dev))\n\t\treturn -EPERM;\n\tcr_data = kvmalloc(crdump_size, GFP_KERNEL);\n\tif (!cr_data)\n\t\treturn -ENOMEM;\n\terr = mlx5_crdump_collect(dev, cr_data);\n\tif (err)\n\t\treturn err;\n\tif (priv_ctx) {\n\t\tstruct mlx5_fw_reporter_ctx *fw_reporter_ctx = priv_ctx;\n\t\terr = mlx5_fw_reporter_ctx_pairs_put(fmsg, fw_reporter_ctx);\n\t\tif (err)\n\t\t\tgoto free_data;\n\t}\n\terr = devlink_fmsg_arr_pair_nest_start(fmsg, \"crdump_data\");\n\tif (err)\n\t\tgoto free_data;\n\tfor (offset = 0; offset < crdump_size; offset += data_size) {\n\t\tif (crdump_size - offset < MLX5_CR_DUMP_CHUNK_SIZE)\n\t\t\tdata_size = crdump_size - offset;\n\t\telse\n\t\t\tdata_size = MLX5_CR_DUMP_CHUNK_SIZE;\n\t\terr = devlink_fmsg_binary_put(fmsg, (char *)cr_data + offset,\n\t\t\t\t\t      data_size);\n\t\tif (err)\n\t\t\tgoto free_data;\n\t}\n\terr = devlink_fmsg_arr_pair_nest_end(fmsg);\nfree_data:\n\tkvfree(cr_data);\n\treturn err;\n}", "target": 1}
{"code": "static int do_remount(struct path *path, int flags, int mnt_flags,\n\t\t      void *data)\n{\n\tint err;\n\tstruct super_block *sb = path->mnt->mnt_sb;\n\tstruct mount *mnt = real_mount(path->mnt);\n\tif (!check_mnt(mnt))\n\t\treturn -EINVAL;\n\tif (path->dentry != path->mnt->mnt_root)\n\t\treturn -EINVAL;\n\terr = security_sb_remount(sb, data);\n\tif (err)\n\t\treturn err;\n\tdown_write(&sb->s_umount);\n\tif (flags & MS_BIND)\n\t\terr = change_mount_flags(path->mnt, flags);\n\telse if (!capable(CAP_SYS_ADMIN))\n\t\terr = -EPERM;\n\telse\n\t\terr = do_remount_sb(sb, flags, data, 0);\n\tif (!err) {\n\t\tlock_mount_hash();\n\t\tmnt_flags |= mnt->mnt.mnt_flags & MNT_PROPAGATION_MASK;\n\t\tmnt->mnt.mnt_flags = mnt_flags;\n\t\ttouch_mnt_namespace(mnt->mnt_ns);\n\t\tunlock_mount_hash();\n\t}\n\tup_write(&sb->s_umount);\n\treturn err;\n}", "target": 1}
{"code": "__u32 secure_tcpv6_sequence_number(__be32 *saddr, __be32 *daddr,\n\t\t\t\t   __be16 sport, __be16 dport)\n{\n\tu32 secret[MD5_MESSAGE_BYTES / 4];\n\tu32 hash[MD5_DIGEST_WORDS];\n\tu32 i;\n\tmemcpy(hash, saddr, 16);\n\tfor (i = 0; i < 4; i++)\n\t\tsecret[i] = net_secret[i] + daddr[i];\n\tsecret[4] = net_secret[4] +\n\t\t(((__force u16)sport << 16) + (__force u16)dport);\n\tfor (i = 5; i < MD5_MESSAGE_BYTES / 4; i++)\n\t\tsecret[i] = net_secret[i];\n\tmd5_transform(hash, secret);\n\treturn seq_scale(hash[0]);\n}", "target": 0}
{"code": "void imap_munge_mbox_name(struct ImapData *idata, char *dest, size_t dlen, const char *src)\n{\n  char *buf = mutt_str_strdup(src);\n  imap_utf_encode(idata, &buf);\n  imap_quote_string(dest, dlen, buf);\n  FREE(&buf);\n}", "target": 1}
{"code": "NOEXPORT int verify_callback(int preverify_ok, X509_STORE_CTX *callback_ctx) {\n    SSL *ssl;\n    CLI *c;\n    ssl=X509_STORE_CTX_get_ex_data(callback_ctx,\n        SSL_get_ex_data_X509_STORE_CTX_idx());\n    c=SSL_get_ex_data(ssl, index_ssl_cli);\n    if(!c->opt->option.verify_chain && !c->opt->option.verify_peer) {\n        s_log(LOG_INFO, \"Certificate verification disabled\");\n        return 1; \n    }\n    if(verify_checks(c, preverify_ok, callback_ctx)) {\n        SSL_SESSION *sess=SSL_get1_session(c->ssl);\n        if(sess) {\n            int ok=SSL_SESSION_set_ex_data(sess, index_session_authenticated,\n                (void *)(-1));\n            SSL_SESSION_free(sess);\n            if(!ok) {\n                sslerror(\"SSL_SESSION_set_ex_data\");\n                return 0; \n            }\n        }\n        return 1; \n    }\n    if(c->opt->option.client || c->opt->protocol)\n        return 0; \n    if(c->opt->redirect_addr.names)\n        return 1; \n    return 0; \n}", "target": 1}
{"code": "matchCurrentInput(\n\t\tconst InString *input, int pos, const widechar *passInstructions, int passIC) {\n\tint k;\n\tint kk = pos;\n\tfor (k = passIC + 2; k < passIC + 2 + passInstructions[passIC + 1]; k++)\n\t\tif (input->chars[kk] == ENDSEGMENT || passInstructions[k] != input->chars[kk++])\n\t\t\treturn 0;\n\treturn 1;\n}", "target": 1}
{"code": "static char *pool_strdup(const char *s)\n{\n\tchar *r = pool_alloc(strlen(s) + 1);\n\tstrcpy(r, s);\n\treturn r;\n}", "target": 1}
{"code": "folly::Optional<TLSMessage> EncryptedReadRecordLayer::read(\n    folly::IOBufQueue& buf) {\n  auto decryptedBuf = getDecryptedBuf(buf);\n  if (!decryptedBuf) {\n    return folly::none;\n  }\n  TLSMessage msg;\n  auto currentBuf = decryptedBuf->get();\n  bool nonZeroFound = false;\n  do {\n    currentBuf = currentBuf->prev();\n    size_t i = currentBuf->length();\n    while (i > 0 && !nonZeroFound) {\n      nonZeroFound = (currentBuf->data()[i - 1] != 0);\n      i--;\n    }\n    if (nonZeroFound) {\n      msg.type = static_cast<ContentType>(currentBuf->data()[i]);\n    }\n    currentBuf->trimEnd(currentBuf->length() - i);\n  } while (!nonZeroFound && currentBuf != decryptedBuf->get());\n  if (!nonZeroFound) {\n    throw std::runtime_error(\"No content type found\");\n  }\n  msg.fragment = std::move(*decryptedBuf);\n  switch (msg.type) {\n    case ContentType::handshake:\n    case ContentType::alert:\n    case ContentType::application_data:\n      break;\n    default:\n      throw std::runtime_error(folly::to<std::string>(\n          \"received encrypted content type \",\n          static_cast<ContentTypeType>(msg.type)));\n  }\n  if (!msg.fragment) {\n    if (msg.type == ContentType::application_data) {\n      msg.fragment = folly::IOBuf::create(0);\n    } else {\n      throw std::runtime_error(\"received empty fragment\");\n    }\n  }\n  return msg;\n}", "target": 1}
{"code": "AP4_HdlrAtom::AP4_HdlrAtom(AP4_UI32        size, \n                           AP4_UI08        version,\n                           AP4_UI32        flags,\n                           AP4_ByteStream& stream) :\n    AP4_Atom(AP4_ATOM_TYPE_HDLR, size, version, flags)\n{\n    AP4_UI32 predefined;\n    stream.ReadUI32(predefined);\n    stream.ReadUI32(m_HandlerType);\n    stream.ReadUI32(m_Reserved[0]);\n    stream.ReadUI32(m_Reserved[1]);\n    stream.ReadUI32(m_Reserved[2]);\n    if (size < AP4_FULL_ATOM_HEADER_SIZE+20) return;\n    AP4_UI32 name_size = size-(AP4_FULL_ATOM_HEADER_SIZE+20);\n    char* name = new char[name_size+1];\n    if (name == NULL) return;\n    stream.Read(name, name_size);\n    name[name_size] = '\\0'; \n    if ((AP4_UI08)name[0] == (AP4_UI08)(name_size-1)) {\n        m_HandlerName = name+1;\n    } else {\n        m_HandlerName = name;\n    }\n    delete[] name;\n}", "target": 0}
{"code": "static void sr_mdio_write(struct net_device *netdev, int phy_id, int loc,\n\t\t\t  int val)\n{\n\tstruct usbnet *dev = netdev_priv(netdev);\n\t__le16 res = cpu_to_le16(val);\n\tif (phy_id) {\n\t\tnetdev_dbg(netdev, \"Only internal phy supported\\n\");\n\t\treturn;\n\t}\n\tnetdev_dbg(netdev, \"sr_mdio_write() phy_id=0x%02x, loc=0x%02x, val=0x%04x\\n\",\n\t\t   phy_id, loc, val);\n\tsr_share_write_word(dev, 1, loc, res);\n}", "target": 0}
{"code": "nfs4_xdr_dec_setacl(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t    struct nfs_setaclres *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_setattr(xdr);\nout:\n\treturn status;\n}", "target": 0}
{"code": "  explicit ThreadPoolHandleOp(OpKernelConstruction* ctx) : OpKernel(ctx) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"display_name\", &display_name_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"num_threads\", &num_threads_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"max_intra_op_parallelism\",\n                                     &max_intra_op_parallelism_));\n    OP_REQUIRES(\n        ctx, num_threads_ > 0,\n        errors::InvalidArgument(\"`num_threads` must be greater than zero.\"));\n  }", "target": 1}
{"code": "BGD_DECLARE(void) gdImageFilledRectangle (gdImagePtr im, int x1, int y1, int x2, int y2,\n\t\tint color)\n{\n\t_gdImageFilledVRectangle(im, x1, y1, x2, y2, color);\n}", "target": 0}
{"code": "int addattr32(struct nlmsghdr *n, int maxlen, int type, __u32 data)\n{\n\treturn addattr_l(n, maxlen, type, &data, sizeof(__u32));\n}", "target": 0}
{"code": "  SubgraphGuard(TfLiteContext* context, bool* is_subgraph_in_use)\n      : is_subgraph_in_use_(is_subgraph_in_use) {\n    if (*is_subgraph_in_use_) {\n      TF_LITE_KERNEL_LOG(\n          context,\n          \"Subgraph is already in use. Using an interpreter or a subgraph in \"\n          \"multiple threads is not supported. Recursion in the graph is not \"\n          \"supported.\");\n      status_ = kTfLiteError;\n    } else {\n      *is_subgraph_in_use_ = true;\n    }\n  }", "target": 0}
{"code": "void gf_filter_pid_inst_del(GF_FilterPidInst *pidinst)\n{\n\tassert(pidinst);\n\tgf_filter_pid_inst_reset(pidinst);\n \tgf_fq_del(pidinst->packets, (gf_destruct_fun) pcki_del);\n\tgf_mx_del(pidinst->pck_mx);\n\tgf_list_del(pidinst->pck_reassembly);\n\tif (pidinst->props) {\n\t\tassert(pidinst->props->reference_count);\n\t\tif (safe_int_dec(&pidinst->props->reference_count) == 0) {\n\t\t\tgf_mx_p(pidinst->pid->filter->tasks_mx);\n\t\t\tgf_list_del_item(pidinst->pid->properties, pidinst->props);\n\t\t\tgf_mx_v(pidinst->pid->filter->tasks_mx);\n\t\t\tgf_props_del(pidinst->props);\n\t\t}\n\t}\n\tgf_free(pidinst);\n}", "target": 1}
{"code": "static void veth_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\tdev->netdev_ops = &veth_netdev_ops;\n\tdev->ethtool_ops = &veth_ethtool_ops;\n\tdev->features |= NETIF_F_LLTX;\n\tdev->destructor = veth_dev_free;\n\tdev->hw_features = NETIF_F_NO_CSUM | NETIF_F_SG | NETIF_F_RXCSUM;\n}", "target": 0}
{"code": "kdc_process_for_user(kdc_realm_t *kdc_active_realm,\n                     krb5_pa_data *pa_data,\n                     krb5_keyblock *tgs_session,\n                     krb5_pa_s4u_x509_user **s4u_x509_user,\n                     const char **status)\n{\n    krb5_error_code             code;\n    krb5_pa_for_user            *for_user;\n    krb5_data                   req_data;\n    req_data.length = pa_data->length;\n    req_data.data = (char *)pa_data->contents;\n    code = decode_krb5_pa_for_user(&req_data, &for_user);\n    if (code)\n        return code;\n    code = verify_for_user_checksum(kdc_context, tgs_session, for_user);\n    if (code) {\n        *status = \"INVALID_S4U2SELF_CHECKSUM\";\n        krb5_free_pa_for_user(kdc_context, for_user);\n        return code;\n    }\n    *s4u_x509_user = calloc(1, sizeof(krb5_pa_s4u_x509_user));\n    if (*s4u_x509_user == NULL) {\n        krb5_free_pa_for_user(kdc_context, for_user);\n        return ENOMEM;\n    }\n    (*s4u_x509_user)->user_id.user = for_user->user;\n    for_user->user = NULL;\n    krb5_free_pa_for_user(kdc_context, for_user);\n    return 0;\n}", "target": 1}
{"code": "static void megasas_command_cancelled(SCSIRequest *req)\n{\n    MegasasCmd *cmd = req->hba_private;\n    if (!cmd) {\n        return;\n    }\n    cmd->frame->header.cmd_status = MFI_STAT_SCSI_IO_FAILED;\n    megasas_complete_command(cmd);\n}", "target": 0}
{"code": "inline void update_rq_clock(struct rq *rq)\n{\n\tif (!rq->skip_clock_update) {\n\t\tint cpu = cpu_of(rq);\n\t\tu64 irq_time;\n\t\trq->clock = sched_clock_cpu(cpu);\n\t\tirq_time = irq_time_cpu(cpu);\n\t\tif (rq->clock - irq_time > rq->clock_task)\n\t\t\trq->clock_task = rq->clock - irq_time;\n\t\tsched_irq_time_avg_update(rq, irq_time);\n\t}\n}", "target": 1}
{"code": "static int io_register_personality(struct io_ring_ctx *ctx)\n{\n\tconst struct cred *creds;\n\tu32 id;\n\tint ret;\n\tcreds = get_current_cred();\n\tret = xa_alloc_cyclic(&ctx->personalities, &id, (void *)creds,\n\t\t\tXA_LIMIT(0, USHRT_MAX), &ctx->pers_next, GFP_KERNEL);\n\tif (!ret)\n\t\treturn id;\n\tput_cred(creds);\n\treturn ret;", "target": 1}
{"code": "isakmp_rfc3948_print(netdissect_options *ndo,\n\t\t     const u_char *bp, u_int length,\n\t\t     const u_char *bp2)\n{\n\tif(length == 1 && bp[0]==0xff) {\n\t\tND_PRINT((ndo, \"isakmp-nat-keep-alive\"));\n\t\treturn;\n\t}\n\tif(length < 4) {\n\t\tgoto trunc;\n\t}\n\tif(bp[0]==0 && bp[1]==0 && bp[2]==0 && bp[3]==0) {\n\t\tND_PRINT((ndo, \"NONESP-encap: \"));\n\t\tisakmp_print(ndo, bp+4, length-4, bp2);\n\t\treturn;\n\t}\n\t{\n\t\tint nh, enh, padlen;\n\t\tint advance;\n\t\tND_PRINT((ndo, \"UDP-encap: \"));\n\t\tadvance = esp_print(ndo, bp, length, bp2, &enh, &padlen);\n\t\tif(advance <= 0)\n\t\t\treturn;\n\t\tbp += advance;\n\t\tlength -= advance + padlen;\n\t\tnh = enh & 0xff;\n\t\tip_print_inner(ndo, bp, length, nh, bp2);\n\t\treturn;\n\t}\ntrunc:\n\tND_PRINT((ndo,\"[|isakmp]\"));\n\treturn;\n}", "target": 1}
{"code": "static bool check_client_passwd(PgSocket *client, const char *passwd)\n{\n\tchar md5[MD5_PASSWD_LEN + 1];\n\tconst char *correct;\n\tPgUser *user = client->auth_user;\n\tif (!user) {\n\t\tslog_error(client, \"Password packet before auth packet?\");\n\t\treturn false;\n\t}\n\tif (!*passwd || !*user->passwd)\n\t\treturn false;\n\tswitch (cf_auth_type) {\n\tcase AUTH_PLAIN:\n\t\treturn strcmp(user->passwd, passwd) == 0;\n\tcase AUTH_CRYPT:\n\t\tcorrect = crypt(user->passwd, (char *)client->tmp_login_salt);\n\t\treturn correct && strcmp(correct, passwd) == 0;\n\tcase AUTH_MD5:\n\t\tif (strlen(passwd) != MD5_PASSWD_LEN)\n\t\t\treturn false;\n\t\tif (!isMD5(user->passwd))\n\t\t\tpg_md5_encrypt(user->passwd, user->name, strlen(user->name), user->passwd);\n\t\tpg_md5_encrypt(user->passwd + 3, (char *)client->tmp_login_salt, 4, md5);\n\t\treturn strcmp(md5, passwd) == 0;\n\t}\n\treturn false;\n}", "target": 0}
{"code": "xfs_attr3_leaf_clearflag(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tint namelen;\n\tchar *name;\n#endif \n\ttrace_xfs_attr_leaf_clearflag(args);\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn(error);\n\tleaf = bp->b_addr;\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tASSERT(entry->flags & XFS_ATTR_INCOMPLETE);\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(args->index < ichdr.count);\n\tASSERT(args->index >= 0);\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tnamelen = name_loc->namelen;\n\t\tname = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tnamelen = name_rmt->namelen;\n\t\tname = (char *)name_rmt->name;\n\t}\n\tASSERT(be32_to_cpu(entry->hashval) == args->hashval);\n\tASSERT(namelen == args->namelen);\n\tASSERT(memcmp(name, args->name, namelen) == 0);\n#endif \n\tentry->flags &= ~XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\tif (args->rmtblkno) {\n\t\tASSERT((entry->flags & XFS_ATTR_LOCAL) == 0);\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tname_rmt->valueblk = cpu_to_be32(args->rmtblkno);\n\t\tname_rmt->valuelen = cpu_to_be32(args->valuelen);\n\t\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, name_rmt, sizeof(*name_rmt)));\n\t}\n\treturn xfs_trans_roll(&args->trans, args->dp);\n}", "target": 0}
{"code": "static int persistent_prepare_exception(struct dm_exception_store *store,\n\t\t\t\t\tstruct dm_exception *e)\n{\n\tstruct pstore *ps = get_info(store);\n\tuint32_t stride;\n\tchunk_t next_free;\n\tsector_t size = get_dev_size(dm_snap_cow(store->snap)->bdev);\n\tif (size < ((ps->next_free + 1) * store->chunk_size))\n\t\treturn -ENOSPC;\n\te->new_chunk = ps->next_free;\n\tstride = (ps->exceptions_per_area + 1);\n\tnext_free = ++ps->next_free;\n\tif (sector_div(next_free, stride) == 1)\n\t\tps->next_free++;\n\tatomic_inc(&ps->pending_count);\n\treturn 0;\n}", "target": 1}
{"code": "GopherStateData::~GopherStateData()\n{\n    if (entry)\n        entry->unlock(\"gopherState\");\n    if (buf)\n        memFree(buf, MEM_4K_BUF);\n}", "target": 1}
{"code": "static void xfrm6_tunnel_spi_fini(void)\n{\n\tkmem_cache_destroy(xfrm6_tunnel_spi_kmem);\n}", "target": 1}
{"code": "static void __account_cfs_rq_runtime(struct cfs_rq *cfs_rq, u64 delta_exec)\n{\n\tcfs_rq->runtime_remaining -= delta_exec;\n\texpire_cfs_rq_runtime(cfs_rq);\n\tif (likely(cfs_rq->runtime_remaining > 0))\n\t\treturn;\n\tif (!assign_cfs_rq_runtime(cfs_rq) && likely(cfs_rq->curr))\n\t\tresched_curr(rq_of(cfs_rq));\n}", "target": 1}
{"code": "static int cp2112_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t\tunsigned offset, int value)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tunsigned long flags;\n\tint ret;\n\tspin_lock_irqsave(&dev->lock, flags);\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_CONFIG_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO config: %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\tbuf[1] |= 1 << offset;\n\tbuf[2] = gpio_push_pull;\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"error setting GPIO config: %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\tcp2112_gpio_set(chip, offset, value);\n\treturn 0;\nfail:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\treturn ret < 0 ? ret : -EIO;\n}", "target": 1}
{"code": "certstack_create(struct cert_stack **result)\n{\n\tstruct cert_stack *stack;\n\tstack = malloc(sizeof(struct cert_stack));\n\tif (stack == NULL)\n\t\treturn pr_enomem();\n\tstack->x509s = sk_X509_new_null();\n\tif (stack->x509s == NULL) {\n\t\tfree(stack);\n\t\treturn val_crypto_err(\"sk_X509_new_null() returned NULL\");\n\t}\n\tSLIST_INIT(&stack->defers);\n\tSLIST_INIT(&stack->metas);\n\tSLIST_INIT(&stack->levels);\n\t*result = stack;\n\treturn 0;\n}", "target": 1}
{"code": "static inline void arch_dup_mmap(struct mm_struct *oldmm,\n\t\t\t\t struct mm_struct *mm)\n{\n\tif (oldmm->context.asce_limit < mm->context.asce_limit)\n\t\tcrst_table_downgrade(mm, oldmm->context.asce_limit);\n}", "target": 1}
{"code": "req_remote_addr(agooReq r) {\n    if (NULL == r) {\n\trb_raise(rb_eArgError, \"Request is no longer valid.\");\n    }\n    return rb_str_new(r->remote, strlen(r->remote));\n}", "target": 0}
{"code": "static void write_cb(struct bt_att_chan *chan, uint8_t opcode, const void *pdu,\n\t\t\t\t\tuint16_t length, void *user_data)\n{\n\tstruct bt_gatt_server *server = user_data;\n\tstruct gatt_db_attribute *attr;\n\tuint16_t handle = 0;\n\tstruct async_write_op *op = NULL;\n\tuint8_t ecode;\n\tif (length < 2) {\n\t\tecode = BT_ATT_ERROR_INVALID_PDU;\n\t\tgoto error;\n\t}\n\tecode = authorize_req(server, opcode, handle);\n\tif (ecode)\n\t\tgoto error;\n\thandle = get_le16(pdu);\n\tattr = gatt_db_get_attribute(server->db, handle);\n\tif (!attr) {\n\t\tecode = BT_ATT_ERROR_INVALID_HANDLE;\n\t\tgoto error;\n\t}\n\tutil_debug(server->debug_callback, server->debug_data,\n\t\t\t\t\"Write %s - handle: 0x%04x\",\n\t\t\t\t(opcode == BT_ATT_OP_WRITE_REQ) ? \"Req\" : \"Cmd\",\n\t\t\t\thandle);\n\tecode = check_length(length, 0);\n\tif (ecode)\n\t\tgoto error;\n\tecode = check_permissions(server, attr, BT_ATT_PERM_WRITE_MASK);\n\tif (ecode)\n\t\tgoto error;\n\top = new0(struct async_write_op, 1);\n\top->chan = chan;\n\top->server = bt_gatt_server_ref(server);\n\top->opcode = opcode;\n\tif (gatt_db_attribute_write(attr, 0, pdu + 2, length - 2, opcode,\n\t\t\t\t\t\t\tserver->att,\n\t\t\t\t\t\t\twrite_complete_cb, op))\n\t\treturn;\n\tasync_write_op_destroy(op);\n\tecode = BT_ATT_ERROR_UNLIKELY;\nerror:\n\tif (opcode == BT_ATT_OP_WRITE_CMD)\n\t\treturn;\n\tbt_att_chan_send_error_rsp(chan, opcode, handle, ecode);\n}", "target": 0}
{"code": "  absl::Status IsSupported(const TfLiteContext* context,\n                           const TfLiteNode* tflite_node,\n                           const TfLiteRegistration* registration) final {\n    if (mirror_pad_) {\n      const TfLiteMirrorPaddingParams* tf_options;\n      RETURN_IF_ERROR(RetrieveBuiltinData(tflite_node, &tf_options));\n      if (tf_options->mode !=\n          TfLiteMirrorPaddingMode::kTfLiteMirrorPaddingReflect) {\n        return absl::InvalidArgumentError(\n            \"Only Reflective padding is supported for Mirror Pad operation.\");\n      }\n    }\n    RETURN_IF_ERROR(CheckMaxSupportedOpVersion(registration, 2));\n    RETURN_IF_ERROR(CheckInputsOutputs(context, tflite_node,\n                                       1, 1));\n    RETURN_IF_ERROR(CheckTensorIsAvailable(context, tflite_node, 1));\n    auto pad_tensor = tflite::GetInput(context, tflite_node, 1);\n    if (pad_tensor->dims->size != 2) {\n      return absl::InvalidArgumentError(absl::StrCat(\n          \"Invalid paddings tensor dimension: expected 2 dim, got \",\n          pad_tensor->dims->size, \" dim\"));\n    }\n    bool supported =\n        pad_tensor->dims->data[0] == 3 || pad_tensor->dims->data[0] == 4;\n    if (!supported || pad_tensor->dims->data[1] != 2) {\n      return absl::InvalidArgumentError(absl::StrCat(\n          \"Invalid paddings tensor shape: expected 4x2 or 3x2, got \",\n          pad_tensor->dims->data[0], \"x\", pad_tensor->dims->data[1]));\n    }\n    return absl::OkStatus();\n  }", "target": 1}
{"code": "static inline int mk_vhost_fdt_close(struct session_request *sr)\n{\n    int id;\n    unsigned int hash;\n    struct vhost_fdt_hash_table *ht = NULL;\n    struct vhost_fdt_hash_chain *hc;\n    if (config->fdt == MK_FALSE) {\n        return close(sr->fd_file);\n    }\n    id   = sr->vhost_fdt_id;\n    hash = sr->vhost_fdt_hash;\n    ht = mk_vhost_fdt_table_lookup(id, sr->host_conf);\n    if (mk_unlikely(!ht)) {\n        return close(sr->fd_file);\n    }\n    hc = mk_vhost_fdt_chain_lookup(hash, ht);\n    if (hc) {\n        hc->readers--;\n        if (hc->readers == 0) {\n            hc->fd   = -1;\n            hc->hash = 0;\n            ht->av_slots++;\n            return close(sr->fd_file);\n        }\n        else {\n            return 0;\n        }\n    }\n    return close(sr->fd_file);\n}", "target": 1}
{"code": "DECLAREcpFunc(cpDecodedStrips)\n{\n\ttsize_t stripsize  = TIFFStripSize(in);\n\ttdata_t buf = _TIFFmalloc(stripsize);\n\t(void) imagewidth; (void) spp;\n\tif (buf) {\n\t\ttstrip_t s, ns = TIFFNumberOfStrips(in);\n\t\tuint32 row = 0;\n\t\t_TIFFmemset(buf, 0, stripsize);\n\t\tfor (s = 0; s < ns; s++) {\n\t\t\ttsize_t cc = (row + rowsperstrip > imagelength) ?\n\t\t\t    TIFFVStripSize(in, imagelength - row) : stripsize;\n\t\t\tif (TIFFReadEncodedStrip(in, s, buf, cc) < 0\n\t\t\t    && !ignore) {\n\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t    \"Error, can't read strip %lu\",\n\t\t\t\t    (unsigned long) s);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFWriteEncodedStrip(out, s, buf, cc) < 0) {\n\t\t\t\tTIFFError(TIFFFileName(out),\n\t\t\t\t    \"Error, can't write strip %lu\",\n\t\t\t\t    (unsigned long) s);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\trow += rowsperstrip;\n\t\t}\n\t\t_TIFFfree(buf);\n\t\treturn 1;\n\t} else {\n\t\tTIFFError(TIFFFileName(in),\n\t\t    \"Error, can't allocate memory buffer of size %lu \"\n\t\t    \"to read strips\", (unsigned long) stripsize);\n\t\treturn 0;\n\t}\nbad:\n\t_TIFFfree(buf);\n\treturn 0;\n}", "target": 1}
{"code": "bool ValidateInput<Variant>(const Tensor& updates) {\n  return true;\n}", "target": 0}
{"code": "flatpak_print_escaped_string (const char        *s,\n                              FlatpakEscapeFlags flags)\n{\n  g_autofree char *escaped = flatpak_escape_string (s, flags);\n  g_print (\"%s\", escaped);\n}", "target": 0}
{"code": "compute_O_value(std::string const& user_password,\n\t\tstd::string const& owner_password,\n\t\tQPDF::EncryptionData const& data)\n{\n    unsigned char O_key[OU_key_bytes_V4];\n    compute_O_rc4_key(user_password, owner_password, data, O_key);\n    char upass[key_bytes];\n    pad_or_truncate_password_V4(user_password, upass);\n    std::string k1(reinterpret_cast<char*>(O_key), OU_key_bytes_V4);\n    pad_short_parameter(k1, data.getLengthBytes());\n    iterate_rc4(QUtil::unsigned_char_pointer(upass), key_bytes,\n\t\tO_key, data.getLengthBytes(),\n                (data.getR() >= 3) ? 20 : 1, false);\n    return std::string(upass, key_bytes);\n}", "target": 0}
{"code": "i915_gem_execbuffer2(struct drm_device *dev, void *data,\n\t\t     struct drm_file *file)\n{\n\tstruct drm_i915_gem_execbuffer2 *args = data;\n\tstruct drm_i915_gem_exec_object2 *exec2_list = NULL;\n\tint ret;\n\tif (args->buffer_count < 1) {\n\t\tDRM_DEBUG(\"execbuf2 with %d buffers\\n\", args->buffer_count);\n\t\treturn -EINVAL;\n\t}\n\texec2_list = kmalloc(sizeof(*exec2_list)*args->buffer_count,\n\t\t\t     GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);\n\tif (exec2_list == NULL)\n\t\texec2_list = drm_malloc_ab(sizeof(*exec2_list),\n\t\t\t\t\t   args->buffer_count);\n\tif (exec2_list == NULL) {\n\t\tDRM_DEBUG(\"Failed to allocate exec list for %d buffers\\n\",\n\t\t\t  args->buffer_count);\n\t\treturn -ENOMEM;\n\t}\n\tret = copy_from_user(exec2_list,\n\t\t\t     (struct drm_i915_relocation_entry __user *)\n\t\t\t     (uintptr_t) args->buffers_ptr,\n\t\t\t     sizeof(*exec2_list) * args->buffer_count);\n\tif (ret != 0) {\n\t\tDRM_DEBUG(\"copy %d exec entries failed %d\\n\",\n\t\t\t  args->buffer_count, ret);\n\t\tdrm_free_large(exec2_list);\n\t\treturn -EFAULT;\n\t}\n\tret = i915_gem_do_execbuffer(dev, data, file, args, exec2_list);\n\tif (!ret) {\n\t\tret = copy_to_user((struct drm_i915_relocation_entry __user *)\n\t\t\t\t   (uintptr_t) args->buffers_ptr,\n\t\t\t\t   exec2_list,\n\t\t\t\t   sizeof(*exec2_list) * args->buffer_count);\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tDRM_DEBUG(\"failed to copy %d exec entries \"\n\t\t\t\t  \"back to user (%d)\\n\",\n\t\t\t\t  args->buffer_count, ret);\n\t\t}\n\t}\n\tdrm_free_large(exec2_list);\n\treturn ret;\n}", "target": 1}
{"code": "static int ssl_parse_client_psk_identity( mbedtls_ssl_context *ssl, unsigned char **p,\n                                          const unsigned char *end )\n{\n    int ret = 0;\n    size_t n;\n    if( ssl->conf->f_psk == NULL &&\n        ( ssl->conf->psk == NULL || ssl->conf->psk_identity == NULL ||\n          ssl->conf->psk_identity_len == 0 || ssl->conf->psk_len == 0 ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"got no pre-shared key\" ) );\n        return( MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED );\n    }\n    if( *p + 2 > end )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n    n = ( (*p)[0] << 8 ) | (*p)[1];\n    *p += 2;\n    if( n < 1 || n > 65535 || *p + n > end )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n    if( ssl->conf->f_psk != NULL )\n    {\n        if( ssl->conf->f_psk( ssl->conf->p_psk, ssl, *p, n ) != 0 )\n            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;\n    }\n    else\n    {\n        if( n != ssl->conf->psk_identity_len ||\n            mbedtls_ssl_safer_memcmp( ssl->conf->psk_identity, *p, n ) != 0 )\n        {\n            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;\n        }\n    }\n    if( ret == MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY )\n    {\n        MBEDTLS_SSL_DEBUG_BUF( 3, \"Unknown PSK identity\", *p, n );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_UNKNOWN_PSK_IDENTITY );\n        return( MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY );\n    }\n    *p += n;\n    return( 0 );\n}", "target": 1}
{"code": "ProcXkbBell(ClientPtr client)\n{\n    REQUEST(xkbBellReq);\n    DeviceIntPtr dev;\n    WindowPtr\t pWin;\n    int rc;\n    REQUEST_SIZE_MATCH(xkbBellReq);\n    if (!(client->xkbClientFlags&_XkbClientInitialized))\n\treturn BadAccess;\n    CHK_BELL_DEVICE(dev, stuff->deviceSpec, client, DixBellAccess);\n    CHK_ATOM_OR_NONE(stuff->name);\n    if ((stuff->forceSound)&&(stuff->eventOnly)) {\n\tclient->errorValue=_XkbErrCode3(0x1,stuff->forceSound,stuff->eventOnly);\n\treturn BadMatch;\n    }\n    if (stuff->percent < -100 || stuff->percent > 100) {\n\tclient->errorValue = _XkbErrCode2(0x2,stuff->percent);\n\treturn BadValue;\n    }\n    if (stuff->duration<-1) {\n\tclient->errorValue = _XkbErrCode2(0x3,stuff->duration);\n\treturn BadValue;\n    }\n    if (stuff->pitch<-1) {\n\tclient->errorValue = _XkbErrCode2(0x4,stuff->pitch);\n\treturn BadValue;\n    }\n    if (stuff->bellClass == XkbDfltXIClass) {\n\tif (dev->kbdfeed!=NULL)\n\t     stuff->bellClass= KbdFeedbackClass;\n\telse stuff->bellClass= BellFeedbackClass;\n    }\n    if (stuff->window!=None) {\n\trc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);\n\tif (rc != Success) {\n\t    client->errorValue= stuff->window;\n\t    return rc;\n\t}\n    }\n    else pWin= NULL;\n    rc = _XkbBell(client, dev, pWin, stuff->bellClass, stuff->bellID,\n                  stuff->pitch, stuff->duration, stuff->percent,\n                  stuff->forceSound, stuff->eventOnly, stuff->name);\n    if ((rc == Success) && ((stuff->deviceSpec == XkbUseCoreKbd) ||\n                            (stuff->deviceSpec == XkbUseCorePtr)))\n    {\n        DeviceIntPtr other;\n        for (other = inputInfo.devices; other; other = other->next)\n        {\n            if ((other != dev) && other->key && !other->isMaster && (other->u.master == dev))\n            {\n                rc = XaceHook(XACE_DEVICE_ACCESS, client, other, DixBellAccess);\n                if (rc == Success)\n                    _XkbBell(client, other, pWin, stuff->bellClass,\n                             stuff->bellID, stuff->pitch, stuff->duration,\n                             stuff->percent, stuff->forceSound,\n                             stuff->eventOnly, stuff->name);\n            }\n        }\n        rc = Success; \n    }\n    return rc;\n}", "target": 0}
{"code": "static int linear_ioctl(struct dm_target *ti, unsigned int cmd,\n\t\t\tunsigned long arg)\n{\n\tstruct linear_c *lc = (struct linear_c *) ti->private;\n\treturn __blkdev_driver_ioctl(lc->dev->bdev, lc->dev->mode, cmd, arg);\n}", "target": 1}
{"code": "const char *enc_untrusted_inet_ntop(int af, const void *src, char *dst,\n                                    socklen_t size) {\n  if (!src || !dst) {\n    errno = EFAULT;\n    return nullptr;\n  }\n  size_t src_size = 0;\n  if (af == AF_INET) {\n    src_size = sizeof(struct in_addr);\n  } else if (af == AF_INET6) {\n    src_size = sizeof(struct in6_addr);\n  } else {\n    errno = EAFNOSUPPORT;\n    return nullptr;\n  }\n  MessageWriter input;\n  input.Push<int>(TokLinuxAfFamily(af));\n  input.PushByReference(Extent{reinterpret_cast<const char *>(src), src_size});\n  input.Push(size);\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kInetNtopHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_inet_ntop\", 2);\n  auto result = output.next();\n  int klinux_errno = output.next<int>();\n  if (result.empty()) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return nullptr;\n  }\n  memcpy(dst, result.data(),\n         std::min(static_cast<size_t>(size),\n                  static_cast<size_t>(INET6_ADDRSTRLEN)));\n  return dst;\n}", "target": 1}
{"code": "static int __mincore_unmapped_range(unsigned long addr, unsigned long end,\n\t\t\t\tstruct vm_area_struct *vma, unsigned char *vec)\n{\n\tunsigned long nr = (end - addr) >> PAGE_SHIFT;\n\tint i;\n\tif (vma->vm_file) {\n\t\tpgoff_t pgoff;\n\t\tpgoff = linear_page_index(vma, addr);\n\t\tfor (i = 0; i < nr; i++, pgoff++)\n\t\t\tvec[i] = mincore_page(vma->vm_file->f_mapping, pgoff);\n\t} else {\n\t\tfor (i = 0; i < nr; i++)\n\t\t\tvec[i] = 0;\n\t}\n\treturn nr;\n}", "target": 1}
{"code": "static int shmem_remount_fs(struct super_block *sb, int *flags, char *data)\n{\n\tstruct shmem_sb_info *sbinfo = SHMEM_SB(sb);\n\tstruct shmem_sb_info config = *sbinfo;\n\tunsigned long inodes;\n\tint error = -EINVAL;\n\tif (shmem_parse_options(data, &config, true))\n\t\treturn error;\n\tspin_lock(&sbinfo->stat_lock);\n\tinodes = sbinfo->max_inodes - sbinfo->free_inodes;\n\tif (percpu_counter_compare(&sbinfo->used_blocks, config.max_blocks) > 0)\n\t\tgoto out;\n\tif (config.max_inodes < inodes)\n\t\tgoto out;\n\tif (config.max_blocks && !sbinfo->max_blocks)\n\t\tgoto out;\n\tif (config.max_inodes && !sbinfo->max_inodes)\n\t\tgoto out;\n\terror = 0;\n\tsbinfo->max_blocks  = config.max_blocks;\n\tsbinfo->max_inodes  = config.max_inodes;\n\tsbinfo->free_inodes = config.max_inodes - inodes;\n\tmpol_put(sbinfo->mpol);\n\tsbinfo->mpol        = config.mpol;\t\nout:\n\tspin_unlock(&sbinfo->stat_lock);\n\treturn error;\n}", "target": 1}
{"code": "bool deleteFile(const String& path)\n{\n    String filename = path;\n    return !!DeleteFileW(filename.charactersWithNullTermination());\n}", "target": 0}
{"code": "bgp_capability_mp (struct peer *peer, struct capability *cap)\n{\n  if (ntohs (cap->mpc.afi) == AFI_IP)\n    {\n      if (cap->mpc.safi == SAFI_UNICAST)\n\t{\n\t  peer->afc_recv[AFI_IP][SAFI_UNICAST] = 1;\n\t  if (peer->afc[AFI_IP][SAFI_UNICAST])\n\t    peer->afc_nego[AFI_IP][SAFI_UNICAST] = 1;\n\t  else\n\t    return -1;\n\t}\n      else if (cap->mpc.safi == SAFI_MULTICAST) \n\t{\n\t  peer->afc_recv[AFI_IP][SAFI_MULTICAST] = 1;\n\t  if (peer->afc[AFI_IP][SAFI_MULTICAST])\n\t    peer->afc_nego[AFI_IP][SAFI_MULTICAST] = 1;\n\t  else\n\t    return -1;\n\t}\n      else if (cap->mpc.safi == BGP_SAFI_VPNV4)\n\t{\n\t  peer->afc_recv[AFI_IP][SAFI_MPLS_VPN] = 1;\n\t  if (peer->afc[AFI_IP][SAFI_MPLS_VPN])\n\t    peer->afc_nego[AFI_IP][SAFI_MPLS_VPN] = 1;\n\t  else\n\t    return -1;\n\t}\n      else\n\treturn -1;\n    }\n#ifdef HAVE_IPV6\n  else if (ntohs (cap->mpc.afi) == AFI_IP6)\n    {\n      if (cap->mpc.safi == SAFI_UNICAST)\n\t{\n\t  peer->afc_recv[AFI_IP6][SAFI_UNICAST] = 1;\n\t  if (peer->afc[AFI_IP6][SAFI_UNICAST])\n\t    peer->afc_nego[AFI_IP6][SAFI_UNICAST] = 1;\n\t  else\n\t    return -1;\n\t}\n      else if (cap->mpc.safi == SAFI_MULTICAST)\n\t{\n\t  peer->afc_recv[AFI_IP6][SAFI_MULTICAST] = 1;\n\t  if (peer->afc[AFI_IP6][SAFI_MULTICAST])\n\t    peer->afc_nego[AFI_IP6][SAFI_MULTICAST] = 1;\n\t  else\n\t    return -1;\n\t}\n      else\n\treturn -1;\n    }\n#endif \n  else\n    {\n      return -1;\n    }\n  return 0;\n}", "target": 1}
{"code": "static void timerfd_remove_cancel(struct timerfd_ctx *ctx)\n{\n\tif (ctx->might_cancel) {\n\t\tctx->might_cancel = false;\n\t\tspin_lock(&cancel_lock);\n\t\tlist_del_rcu(&ctx->clist);\n\t\tspin_unlock(&cancel_lock);\n\t}\n}", "target": 1}
{"code": "set_lenIV(const char* line)\n{\n  char *p = strstr(line, \"/lenIV \");\n  if (p && (isdigit((unsigned char) p[7]) || p[7] == '+' || p[7] == '-')) {\n    lenIV = atoi(p + 7);\n  }\n}", "target": 0}
{"code": "static CURLcode pop3_parse_url_path(struct connectdata *conn)\n{\n  struct pop3_conn *pop3c = &conn->proto.pop3c;\n  struct SessionHandle *data = conn->data;\n  const char *path = data->state.path;\n  pop3c->mailbox = curl_easy_unescape(data, path, 0, NULL);\n  if(!pop3c->mailbox)\n    return CURLE_OUT_OF_MEMORY;\n  return CURLE_OK;\n}", "target": 1}
{"code": "\tconsume_count(type)\n\t\tconst char **type;\n{\n\tint count = 0;\n\tif (!isdigit((unsigned char)**type))\n\t\treturn -1;\n\twhile (isdigit((unsigned char)**type)) {\n\t\tcount *= 10;\n\t\tif ((count % 10) != 0) {\n\t\t\twhile (isdigit((unsigned char)**type))\n\t\t\t\t(*type)++;\n\t\t\treturn -1;\n\t\t}\n\t\tcount += **type - '0';\n\t\t(*type)++;\n\t}\n\treturn (count);\n}", "target": 1}
{"code": "ExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr,\n               const char **elem_rtrn, const char **field_rtrn,\n               ExprDef **index_rtrn)\n{\n    switch (expr->expr.op) {\n    case EXPR_IDENT:\n        *elem_rtrn = NULL;\n        *field_rtrn = xkb_atom_text(ctx, expr->ident.ident);\n        *index_rtrn = NULL;\n        return true;\n    case EXPR_FIELD_REF:\n        *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element);\n        *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field);\n        *index_rtrn = NULL;\n        return true;\n    case EXPR_ARRAY_REF:\n        *elem_rtrn = xkb_atom_text(ctx, expr->array_ref.element);\n        *field_rtrn = xkb_atom_text(ctx, expr->array_ref.field);\n        *index_rtrn = expr->array_ref.entry;\n        return true;\n    default:\n        break;\n    }\n    log_wsgo(ctx, \"Unexpected operator %d in ResolveLhs\\n\", expr->expr.op);\n    return false;\n}", "target": 1}
{"code": "static void nhml_node_end(void *sax_cbck, const char *node_name, const char *name_space)\n{\n\tXMLBreaker *breaker = (XMLBreaker *)sax_cbck;\n\tchar *node_id = (char *)gf_list_last(breaker->id_stack);\n\tgf_list_rem_last(breaker->id_stack);\n\tif (breaker->from_is_end && breaker->from_id && !strcmp(breaker->from_id, node_id)) {\n\t\tbreaker->from_pos = gf_xml_sax_get_node_end_pos(breaker->sax);\n\t\tbreaker->from_is_end = GF_FALSE;\n\t}\n\tif (breaker->to_is_end && breaker->to_id && !strcmp(breaker->to_id, node_id)) {\n\t\tbreaker->to_pos = gf_xml_sax_get_node_end_pos(breaker->sax);\n\t\tbreaker->to_is_end = GF_FALSE;\n\t}\n\tgf_free(node_id);\n\tif (!breaker->to_is_start && !breaker->from_is_start && !breaker->to_is_end && !breaker->from_is_end) {\n\t\tgf_xml_sax_suspend(breaker->sax, GF_TRUE);\n\t}\n}", "target": 0}
{"code": "ZEND_API char* ZEND_FASTCALL zend_str_tolower_copy(char *dest, const char *source, size_t length) \n{\n\tregister unsigned char *str = (unsigned char*)source;\n\tregister unsigned char *result = (unsigned char*)dest;\n\tregister unsigned char *end = str + length;\n\twhile (str < end) {\n\t\t*result++ = zend_tolower_ascii(*str++);\n\t}\n\t*result = '\\0';\n\treturn dest;\n}", "target": 0}
{"code": "static gboolean match_hostname(const char *cert_hostname, const char *hostname)\n{\n\tconst char *hostname_left;\n\tif (!strcasecmp(cert_hostname, hostname)) { \n\t\treturn TRUE;\n\t} else if (cert_hostname[0] == '*' && cert_hostname[1] == '.' && cert_hostname[2] != 0) { \n\t\thostname_left = strchr(hostname, '.');\n\t\tif (hostname_left != NULL && ! strcasecmp(hostname_left + 1, cert_hostname + 2)) {\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\treturn FALSE;\n}", "target": 0}
{"code": "static int handle_wrmsr(struct kvm_vcpu *vcpu)\n{\n\tstruct msr_data msr;\n\tu32 ecx = vcpu->arch.regs[VCPU_REGS_RCX];\n\tu64 data = (vcpu->arch.regs[VCPU_REGS_RAX] & -1u)\n\t\t| ((u64)(vcpu->arch.regs[VCPU_REGS_RDX] & -1u) << 32);\n\tmsr.data = data;\n\tmsr.index = ecx;\n\tmsr.host_initiated = false;\n\tif (vmx_set_msr(vcpu, &msr) != 0) {\n\t\ttrace_kvm_msr_write_ex(ecx, data);\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\ttrace_kvm_msr_write(ecx, data);\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}", "target": 1}
{"code": "void util_hex_dump(FILE *f, const u8 *in, int len, const char *sep)\n{\n\tint i;\n\tfor (i = 0; i < len; i++) {\n\t\tif (sep != NULL && i)\n\t\t\tfprintf(f, \"%s\", sep);\n\t\tfprintf(f, \"%02X\", in[i]);\n\t}\n}", "target": 0}
{"code": "R_API size_t r_str_ansi_strip(char *str) {\n\tsize_t i = 0;\n\twhile (str[i]) {\n\t\tsize_t chlen = __str_ansi_length (str + i);\n\t\tif (chlen > 1) {\n\t\t\tr_str_cpy (str + i + 1, str + i + chlen);\n\t\t}\n\t\ti++;\n\t}\n\treturn i;\n}", "target": 1}
{"code": "static int ceph_aes_crypt(const struct ceph_crypto_key *key, bool encrypt,\n\t\t\t  void *buf, int buf_len, int in_len, int *pout_len)\n{\n\tstruct crypto_skcipher *tfm = ceph_crypto_alloc_cipher();\n\tSKCIPHER_REQUEST_ON_STACK(req, tfm);\n\tstruct sg_table sgt;\n\tstruct scatterlist prealloc_sg;\n\tchar iv[AES_BLOCK_SIZE];\n\tint pad_byte = AES_BLOCK_SIZE - (in_len & (AES_BLOCK_SIZE - 1));\n\tint crypt_len = encrypt ? in_len + pad_byte : in_len;\n\tint ret;\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\tWARN_ON(crypt_len > buf_len);\n\tif (encrypt)\n\t\tmemset(buf + in_len, pad_byte, pad_byte);\n\tret = setup_sgtable(&sgt, &prealloc_sg, buf, crypt_len);\n\tif (ret)\n\t\tgoto out_tfm;\n\tcrypto_skcipher_setkey((void *)tfm, key->key, key->len);\n\tmemcpy(iv, aes_iv, AES_BLOCK_SIZE);\n\tskcipher_request_set_tfm(req, tfm);\n\tskcipher_request_set_callback(req, 0, NULL, NULL);\n\tskcipher_request_set_crypt(req, sgt.sgl, sgt.sgl, crypt_len, iv);\n\tif (encrypt)\n\t\tret = crypto_skcipher_encrypt(req);\n\telse\n\t\tret = crypto_skcipher_decrypt(req);\n\tskcipher_request_zero(req);\n\tif (ret) {\n\t\tpr_err(\"%s %scrypt failed: %d\\n\", __func__,\n\t\t       encrypt ? \"en\" : \"de\", ret);\n\t\tgoto out_sgt;\n\t}\n\tif (encrypt) {\n\t\t*pout_len = crypt_len;\n\t} else {\n\t\tpad_byte = *(char *)(buf + in_len - 1);\n\t\tif (pad_byte > 0 && pad_byte <= AES_BLOCK_SIZE &&\n\t\t    in_len >= pad_byte) {\n\t\t\t*pout_len = in_len - pad_byte;\n\t\t} else {\n\t\t\tpr_err(\"%s got bad padding %d on in_len %d\\n\",\n\t\t\t       __func__, pad_byte, in_len);\n\t\t\tret = -EPERM;\n\t\t\tgoto out_sgt;\n\t\t}\n\t}\nout_sgt:\n\tteardown_sgtable(&sgt);\nout_tfm:\n\tcrypto_free_skcipher(tfm);\n\treturn ret;\n}", "target": 0}
{"code": "resolve_op_end (FlatpakTransaction *self,\n                FlatpakTransactionOperation *op,\n                const char *checksum,\n                GFile *sideload_path,\n                GBytes *metadata_bytes)\n{\n  g_autoptr(GBytes) old_metadata_bytes = NULL;\n  old_metadata_bytes = load_deployed_metadata (self, op->ref, NULL, NULL);\n  mark_op_resolved (op, checksum, sideload_path, metadata_bytes, old_metadata_bytes);\n  emit_eol_and_maybe_skip (self, op);\n }", "target": 1}
{"code": "void *malloc(size_t size)\n{\n\tstruct free_arena_header *fp;\n\tstruct free_arena_header *pah;\n\tsize_t fsize;\n\tif (size == 0)\n\t\treturn NULL;\n\tif (size > PTRDIFF_MAX) {\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\tsize = (size + 2 * sizeof(struct arena_header) - 1) & ARENA_SIZE_MASK;\n\tfor (fp = __malloc_head.next_free; fp->a.type != ARENA_TYPE_HEAD;\n\t     fp = fp->next_free) {\n\t\tif (fp->a.size >= size) {\n\t\t\treturn __malloc_from_block(fp, size);\n\t\t}\n\t}\n\tfsize = (size + MALLOC_CHUNK_MASK) & ~MALLOC_CHUNK_MASK;\n#if _KLIBC_MALLOC_USES_SBRK\n\tfp = (struct free_arena_header *)sbrk(fsize);\n#else\n\tfp = (struct free_arena_header *)\n\t    mmap(NULL, fsize, PROT_READ | PROT_WRITE,\n\t\t MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);\n#endif\n\tif (fp == (struct free_arena_header *)MAP_FAILED) {\n\t\terrno = ENOMEM;\n\t\treturn NULL;\t\n\t}\n\tfp->a.type = ARENA_TYPE_FREE;\n\tfp->a.size = fsize;\n\tfor (pah = __malloc_head.a.prev; pah->a.type != ARENA_TYPE_HEAD;\n\t     pah = pah->a.prev) {\n\t\tif (pah < fp)\n\t\t\tbreak;\n\t}\n\tfp->a.next = pah->a.next;\n\tfp->a.prev = pah;\n\tpah->a.next = fp;\n\tfp->a.next->a.prev = fp;\n\tfp = __free_block(fp);\n\treturn __malloc_from_block(fp, size);\n}", "target": 0}
{"code": "hufDecode\n    (const Int64 * \thcode,\t\n     const HufDec * \thdecod,\t\n     const char* \tin,\t\n     int\t\tni,\t\n     int\t\trlc,\t\n     int\t\tno,\t\n     unsigned short*\tout)\t\n{\n    Int64 c = 0;\n    int lc = 0;\n    unsigned short * outb = out;\n    unsigned short * oe = out + no;\n    const char * ie = in + (ni + 7) / 8; \n    while (in < ie)\n    {\n\tgetChar (c, lc, in);\n\twhile (lc >= HUF_DECBITS)\n\t{\n\t    const HufDec pl = hdecod[(c >> (lc-HUF_DECBITS)) & HUF_DECMASK];\n\t    if (pl.len)\n\t    {\n\t\tlc -= pl.len;\n\t\tif ( lc < 0 )\n\t\t{\n\t\t\tinvalidCode(); \n\t\t}\n\t\tgetCode (pl.lit, rlc, c, lc, in, out, outb, oe);\n\t    }\n\t    else\n\t    {\n\t\tif (!pl.p)\n\t\t    invalidCode(); \n\t\tint j;\n\t\tfor (j = 0; j < pl.lit; j++)\n\t\t{\n\t\t    int\tl = hufLength (hcode[pl.p[j]]);\n\t\t    while (lc < l && in < ie)\t\n\t\t\tgetChar (c, lc, in);\n\t\t    if (lc >= l)\n\t\t    {\n\t\t\tif (hufCode (hcode[pl.p[j]]) ==\n\t\t\t\t((c >> (lc - l)) & ((Int64(1) << l) - 1)))\n\t\t\t{\n\t\t\t    lc -= l;\n\t\t\t    getCode (pl.p[j], rlc, c, lc, in, out, outb, oe);\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (j == pl.lit)\n\t\t    invalidCode(); \n\t    }\n\t}\n    }\n    int i = (8 - ni) & 7;\n    c >>= i;\n    lc -= i;\n    while (lc > 0)\n    {\n\tconst HufDec pl = hdecod[(c << (HUF_DECBITS - lc)) & HUF_DECMASK];\n\tif (pl.len)\n\t{\n\t    lc -= pl.len;\n            if ( lc < 0 )\n            {\n   \t        invalidCode(); \n            }\n\t    getCode (pl.lit, rlc, c, lc, in, out, outb, oe);\n\t}\n\telse\n\t{\n\t    invalidCode(); \n\t}\n    }\n    if (out - outb != no)\n\tnotEnoughData ();\n}", "target": 0}
{"code": "static int rsi_send_beacon(struct rsi_common *common)\n{\n\tstruct sk_buff *skb = NULL;\n\tu8 dword_align_bytes = 0;\n\tskb = dev_alloc_skb(MAX_MGMT_PKT_SIZE);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\tmemset(skb->data, 0, MAX_MGMT_PKT_SIZE);\n\tdword_align_bytes = ((unsigned long)skb->data & 0x3f);\n\tif (dword_align_bytes)\n\t\tskb_pull(skb, (64 - dword_align_bytes));\n\tif (rsi_prepare_beacon(common, skb)) {\n\t\trsi_dbg(ERR_ZONE, \"Failed to prepare beacon\\n\");\n\t\tdev_kfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\tskb_queue_tail(&common->tx_queue[MGMT_BEACON_Q], skb);\n\trsi_set_event(&common->tx_thread.event);\n\trsi_dbg(DATA_TX_ZONE, \"%s: Added to beacon queue\\n\", __func__);\n\treturn 0;\n}", "target": 0}
{"code": "pxa3xx_gcu_write(struct file *file, const char *buff,\n\t\t size_t count, loff_t *offp)\n{\n\tint ret;\n\tunsigned long flags;\n\tstruct pxa3xx_gcu_batch\t*buffer;\n\tstruct pxa3xx_gcu_priv *priv = to_pxa3xx_gcu_priv(file);\n\tint words = count / 4;\n\tpriv->shared->num_writes++;\n\tpriv->shared->num_words += words;\n\tif (words >= PXA3XX_GCU_BATCH_WORDS)\n\t\treturn -E2BIG;\n\tif (!priv->free) {\n\t\tret = pxa3xx_gcu_wait_free(priv);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tspin_lock_irqsave(&priv->spinlock, flags);\n\tbuffer = priv->free;\n\tpriv->free = buffer->next;\n\tspin_unlock_irqrestore(&priv->spinlock, flags);\n\tret = copy_from_user(buffer->ptr, buff, words * 4);\n\tif (ret) {\n\t\tspin_lock_irqsave(&priv->spinlock, flags);\n\t\tbuffer->next = priv->free;\n\t\tpriv->free = buffer;\n\t\tspin_unlock_irqrestore(&priv->spinlock, flags);\n\t\treturn -EFAULT;\n\t}\n\tbuffer->length = words;\n\tbuffer->ptr[words] = 0x01000000;\n\tspin_lock_irqsave(&priv->spinlock, flags);\n\tbuffer->next = NULL;\n\tif (priv->ready) {\n\t\tBUG_ON(priv->ready_last == NULL);\n\t\tpriv->ready_last->next = buffer;\n\t} else\n\t\tpriv->ready = buffer;\n\tpriv->ready_last = buffer;\n\tif (!priv->shared->hw_running)\n\t\trun_ready(priv);\n\tspin_unlock_irqrestore(&priv->spinlock, flags);\n\treturn words * 4;\n}", "target": 1}
{"code": "int read_escaped_char(\n    yyscan_t yyscanner,\n    uint8_t* escaped_char)\n{\n  char text[4] = {0, 0, 0, 0};\n  text[0] = '\\\\';\n  text[1] = RE_YY_INPUT(yyscanner);\n  if (text[1] == EOF)\n    return 0;\n  if (text[1] == 'x')\n  {\n    text[2] = RE_YY_INPUT(yyscanner);\n    if (text[2] == EOF)\n      return 0;\n    text[3] = RE_YY_INPUT(yyscanner);\n    if (text[3] == EOF)\n      return 0;\n  }\n  *escaped_char = escaped_char_value(text);\n  return 1;", "target": 1}
{"code": "void sev_es_init_vmcb(struct vcpu_svm *svm)\n{\n\tstruct kvm_vcpu *vcpu = &svm->vcpu;\n\tsvm->vmcb->control.nested_ctl |= SVM_NESTED_CTL_SEV_ES_ENABLE;\n\tsvm->vmcb->control.virt_ext |= LBR_CTL_ENABLE_MASK;\n\tsvm->vmcb->control.vmsa_pa = __pa(svm->vmsa);\n\tsvm_clr_intercept(svm, INTERCEPT_CR0_READ);\n\tsvm_clr_intercept(svm, INTERCEPT_CR4_READ);\n\tsvm_clr_intercept(svm, INTERCEPT_CR8_READ);\n\tsvm_clr_intercept(svm, INTERCEPT_CR0_WRITE);\n\tsvm_clr_intercept(svm, INTERCEPT_CR4_WRITE);\n\tsvm_clr_intercept(svm, INTERCEPT_CR8_WRITE);\n\tsvm_clr_intercept(svm, INTERCEPT_SELECTIVE_CR0);\n\tsvm_set_intercept(svm, TRAP_EFER_WRITE);\n\tsvm_set_intercept(svm, TRAP_CR0_WRITE);\n\tsvm_set_intercept(svm, TRAP_CR4_WRITE);\n\tsvm_set_intercept(svm, TRAP_CR8_WRITE);\n\tclr_exception_intercept(svm, GP_VECTOR);\n\tsvm_clr_intercept(svm, INTERCEPT_XSETBV);\n\tset_msr_interception(vcpu, svm->msrpm, MSR_EFER, 1, 1);\n\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_CR_PAT, 1, 1);\n\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_LASTBRANCHFROMIP, 1, 1);\n\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_LASTBRANCHTOIP, 1, 1);\n\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_LASTINTFROMIP, 1, 1);\n\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_LASTINTTOIP, 1, 1);\n}", "target": 0}
{"code": "cib_remote_command_dispatch(gpointer user_data)\n{\n    int disconnected = 0;\n    cib_t *cib = user_data;\n    cib_remote_opaque_t *private = cib->variant_opaque;\n    crm_recv_remote_msg(private->command.session, &private->command.recv_buf, private->command.encrypted, -1, &disconnected);\n    free(private->command.recv_buf);\n    private->command.recv_buf = NULL;\n    crm_err(\"received late reply for remote cib connection, discarding\");\n    if (disconnected) {\n        return -1;\n    }\n    return 0;\n}", "target": 0}
{"code": "static int empty_write_end(struct page *page, unsigned from,\n\t\t\t   unsigned to, int mode)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct buffer_head *bh;\n\tunsigned offset, blksize = 1 << inode->i_blkbits;\n\tpgoff_t end_index = i_size_read(inode) >> PAGE_CACHE_SHIFT;\n\tzero_user(page, from, to-from);\n\tmark_page_accessed(page);\n\tif (page->index < end_index || !(mode & FALLOC_FL_KEEP_SIZE)) {\n\t\tif (!gfs2_is_writeback(ip))\n\t\t\tgfs2_page_add_databufs(ip, page, from, to);\n\t\tblock_commit_write(page, from, to);\n\t\treturn 0;\n\t}\n\toffset = 0;\n\tbh = page_buffers(page);\n\twhile (offset < to) {\n\t\tif (offset >= from) {\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tclear_buffer_new(bh);\n\t\t\twrite_dirty_buffer(bh, WRITE);\n\t\t}\n\t\toffset += blksize;\n\t\tbh = bh->b_this_page;\n\t}\n\toffset = 0;\n\tbh = page_buffers(page);\n\twhile (offset < to) {\n\t\tif (offset >= from) {\n\t\t\twait_on_buffer(bh);\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\treturn -EIO;\n\t\t}\n\t\toffset += blksize;\n\t\tbh = bh->b_this_page;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "CotpConnection_readToTpktBuffer(CotpConnection* self)\n{\n    uint8_t* buffer = self->readBuffer->buffer;\n    int bufferSize = self->readBuffer->maxSize;\n    int bufPos = self->readBuffer->size;\n    assert (bufferSize > 4);\n    int readBytes;\n    if (bufPos < 4) {\n        readBytes = readFromSocket(self, buffer + bufPos, 4 - bufPos);\n        if (readBytes < 0)\n            goto exit_closed;\n        if (DEBUG_COTP) {\n            if (readBytes > 0)\n                printf(\"TPKT: read %i bytes from socket\\n\", readBytes);\n        }\n        bufPos += readBytes;\n        if (bufPos == 4) {\n            if ((buffer[0] == 3) && (buffer[1] == 0)) {\n                self->packetSize = (buffer[2] * 0x100) + buffer[3];\n                if (DEBUG_COTP)\n                    printf(\"TPKT: header complete (msg size = %i)\\n\", self->packetSize);\n                if (self->packetSize > bufferSize) {\n                    if (DEBUG_COTP) printf(\"TPKT: packet too large\\n\");\n                    goto exit_error;\n                }\n            }\n            else {\n                if (DEBUG_COTP) printf(\"TPKT: failed to decode TPKT header.\\n\");\n                goto exit_error;\n            }\n        }\n        else\n            goto exit_waiting;\n    }\n    if (self->packetSize <= bufPos)\n        goto exit_error;\n    readBytes = readFromSocket(self, buffer + bufPos, self->packetSize - bufPos);\n    if (readBytes < 0)\n        goto exit_closed;\n    bufPos += readBytes;\n    if (bufPos < self->packetSize)\n       goto exit_waiting;\n    if (DEBUG_COTP) printf(\"TPKT: message complete (size = %i)\\n\", self->packetSize);\n    self->readBuffer->size = bufPos;\n    return TPKT_PACKET_COMPLETE;\nexit_closed:\n    if (DEBUG_COTP) printf(\"TPKT: socket closed or socket error\\n\");\n    return TPKT_ERROR;\nexit_error:\n    if (DEBUG_COTP) printf(\"TPKT: Error parsing message\\n\");\n    return TPKT_ERROR;\nexit_waiting:\n    if (DEBUG_COTP)\n        if (bufPos != 0)\n            printf(\"TPKT: waiting (read %i of %i)\\n\", bufPos, self->packetSize);\n    self->readBuffer->size = bufPos;\n    return TPKT_WAITING;\n}", "target": 0}
{"code": "static int stszin(int size)\n{\n    int cnt;\n    uint32_t ofs;\n    u32in();\n    u32in();\n    mp4config.frame.ents = u32in();\n    mp4config.frame.data = malloc(sizeof(*mp4config.frame.data)\n                                  * (mp4config.frame.ents + 1));\n    if (!mp4config.frame.data)\n        return ERR_FAIL;\n    ofs = 0;\n    mp4config.frame.data[0] = ofs;\n    for (cnt = 0; cnt < mp4config.frame.ents; cnt++)\n    {\n        uint32_t fsize = u32in();\n        ofs += fsize;\n        if (mp4config.frame.maxsize < fsize)\n            mp4config.frame.maxsize = fsize;\n        mp4config.frame.data[cnt + 1] = ofs;\n        if (ofs < mp4config.frame.data[cnt])\n            return ERR_FAIL;\n    }\n    return size;\n}", "target": 1}
{"code": "static int kvm_vm_ioctl_set_pit(struct kvm *kvm, struct kvm_pit_state *ps)\n{\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tmemcpy(&kvm->arch.vpit->pit_state, ps, sizeof(struct kvm_pit_state));\n\tkvm_pit_load_count(kvm, 0, ps->channels[0].count, 0);\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\treturn 0;\n}", "target": 1}
{"code": "DU_getStringDOElement(DcmItem *obj, DcmTagKey t, char *s, size_t bufsize)\n{\n    DcmByteString *elem;\n    DcmStack stack;\n    OFCondition ec = EC_Normal;\n    char* aString;\n    ec = obj->search(t, stack);\n    elem = (DcmByteString*) stack.top();\n    if (ec == EC_Normal && elem != NULL) {\n        if (elem->getLength() == 0) {\n            s[0] = '\\0';\n        } else {\n            ec =  elem->getString(aString);\n            OFStandard::strlcpy(s, aString, bufsize);\n        }\n    }\n    return (ec == EC_Normal);\n}", "target": 1}
{"code": " */\nstatic enum hrtimer_restart bfq_idle_slice_timer(struct hrtimer *timer)\n{\n\tstruct bfq_data *bfqd = container_of(timer, struct bfq_data,\n\t\t\t\t\t     idle_slice_timer);\n\tstruct bfq_queue *bfqq = bfqd->in_service_queue;\n\tif (bfqq)\n\t\tbfq_idle_slice_timer_body(bfqq);\n\treturn HRTIMER_NORESTART;", "target": 1}
{"code": "ofpacts_parse(char *str, const struct ofpact_parse_params *pp,\n              bool allow_instructions, enum ofpact_type outer_action)\n{\n    if (pp->depth >= MAX_OFPACT_PARSE_DEPTH) {\n        return xstrdup(\"Action nested too deeply\");\n    }\n    CONST_CAST(struct ofpact_parse_params *, pp)->depth++;\n    uint32_t orig_size = pp->ofpacts->size;\n    char *error = ofpacts_parse__(str, pp, allow_instructions, outer_action);\n    if (error) {\n        pp->ofpacts->size = orig_size;\n    }\n    CONST_CAST(struct ofpact_parse_params *, pp)->depth--;\n    return error;\n}", "target": 0}
{"code": "static void WriteBinaryGltfStream(std::ostream &stream,\n                                  const std::string &content,\n                                  const std::vector<unsigned char> &binBuffer) {\n  const std::string header = \"glTF\";\n  const int version = 2;\n  const uint32_t content_size = uint32_t(content.size());\n  const uint32_t binBuffer_size = uint32_t(binBuffer.size());\n  const uint32_t content_padding_size = content_size % 4 == 0 ? 0 : 4 - content_size % 4;\n  const uint32_t bin_padding_size = binBuffer_size % 4 == 0 ? 0 : 4 - binBuffer_size % 4;\n  const uint32_t length =\n      12 + 8 + content_size + content_padding_size +\n      (binBuffer_size ? (8 + binBuffer_size + bin_padding_size) : 0);\n  stream.write(header.c_str(), std::streamsize(header.size()));\n  stream.write(reinterpret_cast<const char *>(&version), sizeof(version));\n  stream.write(reinterpret_cast<const char *>(&length), sizeof(length));\n  const uint32_t model_length = uint32_t(content.size()) + content_padding_size;\n  const uint32_t model_format = 0x4E4F534A;\n  stream.write(reinterpret_cast<const char *>(&model_length),\n               sizeof(model_length));\n  stream.write(reinterpret_cast<const char *>(&model_format),\n               sizeof(model_format));\n  stream.write(content.c_str(), std::streamsize(content.size()));\n  if (content_padding_size > 0) {\n    const std::string padding = std::string(size_t(content_padding_size), ' ');\n    stream.write(padding.c_str(), std::streamsize(padding.size()));\n  }\n  if (binBuffer.size() > 0) {\n    const uint32_t bin_length = uint32_t(binBuffer.size()) + bin_padding_size;\n    const uint32_t bin_format = 0x004e4942;\n    stream.write(reinterpret_cast<const char *>(&bin_length),\n                 sizeof(bin_length));\n    stream.write(reinterpret_cast<const char *>(&bin_format),\n                 sizeof(bin_format));\n    stream.write(reinterpret_cast<const char *>(binBuffer.data()),\n                 std::streamsize(binBuffer.size()));\n    if (bin_padding_size > 0) {\n      const std::vector<unsigned char> padding =\n          std::vector<unsigned char>(size_t(bin_padding_size), 0);\n      stream.write(reinterpret_cast<const char *>(padding.data()),\n                   std::streamsize(padding.size()));\n    }\n  }\n}", "target": 1}
{"code": "int xml_init(modsec_rec *msr, char **error_msg) {\n    xmlParserInputBufferCreateFilenameFunc entity;\n    if (error_msg == NULL) return -1;\n    *error_msg = NULL;\n    msr->xml = apr_pcalloc(msr->mp, sizeof(xml_data));\n    if (msr->xml == NULL) return -1;\n    if(msr->txcfg->xml_external_entity == 0)    {\n        entity = xmlParserInputBufferCreateFilenameDefault(xml_unload_external_entity);\n    }\n    return 1;\n}", "target": 0}
{"code": "char *Elf_(r_bin_elf_get_rpath)(ELFOBJ *bin) {\n\tchar *ret = NULL;\n\tint j;\n\tif (!bin || !bin->phdr || !bin->dyn_buf || !bin->strtab) {\n\t\treturn NULL;\n\t}\n\tfor (j = 0; j< bin->dyn_entries; j++) {\n\t\tif (bin->dyn_buf[j].d_tag == DT_RPATH || bin->dyn_buf[j].d_tag == DT_RUNPATH) {\n\t\t\tif (!(ret = calloc (1, ELF_STRING_LENGTH))) {\n\t\t\t\tperror (\"malloc (rpath)\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (bin->dyn_buf[j].d_un.d_val > bin->strtab_size) {\n\t\t\t\tfree (ret);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tstrncpy (ret, bin->strtab + bin->dyn_buf[j].d_un.d_val, ELF_STRING_LENGTH);\n\t\t\tret[ELF_STRING_LENGTH - 1] = '\\0';\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "static void perf_event_init_cpu(int cpu)\n{\n\tstruct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);\n\tmutex_lock(&swhash->hlist_mutex);\n\tswhash->online = true;\n\tif (swhash->hlist_refcount > 0) {\n\t\tstruct swevent_hlist *hlist;\n\t\thlist = kzalloc_node(sizeof(*hlist), GFP_KERNEL, cpu_to_node(cpu));\n\t\tWARN_ON(!hlist);\n\t\trcu_assign_pointer(swhash->swevent_hlist, hlist);\n\t}\n\tmutex_unlock(&swhash->hlist_mutex);\n}", "target": 1}
{"code": "ikev2_auth_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len _U_, const u_char *ep,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct ikev2_auth a;\n\tconst char *v2_auth[]={ \"invalid\", \"rsasig\",\n\t\t\t\t\"shared-secret\", \"dsssig\" };\n\tconst u_char *authdata = (const u_char*)ext + sizeof(a);\n\tunsigned int len;\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&a, ext, sizeof(a));\n\tikev2_pay_print(ndo, NPSTR(tpay), a.h.critical);\n\tlen = ntohs(a.h.len);\n\tND_PRINT((ndo,\" len=%d method=%s\", len-4,\n\t\t  STR_OR_ID(a.auth_method, v2_auth)));\n\tif (1 < ndo->ndo_vflag && 4 < len) {\n\t\tND_PRINT((ndo,\" authdata=(\"));\n\t\tif (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))\n\t\t\tgoto trunc;\n\t\tND_PRINT((ndo,\") \"));\n\t} else if(ndo->ndo_vflag && 4 < len) {\n\t\tif(!ike_show_somedata(ndo, authdata, ep)) goto trunc;\n\t}\n\treturn (const u_char *)ext + len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}", "target": 1}
{"code": "static gboolean key_value_ok(gchar *key, gchar *value)\n{\n    char *i;\n    for (i = key; *i != 0; i++)\n    {\n        if (!isalpha(*i) && (*i != '-') && (*i != '_') && (*i != ' '))\n            return FALSE;\n    }\n    if (strcmp(key, \"basename\") == 0\n     || strcmp(key, FILENAME_TYPE) == 0\n    )\n    {\n        if (!is_correct_filename(value))\n        {\n            error_msg(\"Value of '%s' ('%s') is not a valid directory name\",\n                      key, value);\n            return FALSE;\n        }\n    }\n    return TRUE;\n}", "target": 1}
{"code": "static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC) \n{\n\tzend_hash_destroy(&pglobals->ht_rc);\n}", "target": 1}
{"code": "    void SetArcInMem(byte *Data,size_t Size)\n    {\n      ArcMemData=Data;\n      ArcMemSize=Size;\n      ArcInMem=Data!=NULL && Size>0;\n    }", "target": 0}
{"code": "xfs_attr_fork_reset(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_trans\t*tp)\n{\n\txfs_idestroy_fork(ip, XFS_ATTR_FORK);\n\tip->i_d.di_forkoff = 0;\n\tip->i_d.di_aformat = XFS_DINODE_FMT_EXTENTS;\n\tASSERT(ip->i_d.di_anextents == 0);\n\tASSERT(ip->i_afp == NULL);\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n}", "target": 0}
{"code": "static void resv_map_put(struct vm_area_struct *vma)\n{\n\tstruct resv_map *reservations = vma_resv_map(vma);\n\tif (!reservations)\n\t\treturn;\n\tkref_put(&reservations->refs, resv_map_release);\n}", "target": 0}
{"code": "static void sas_eh_defer_cmd(struct scsi_cmnd *cmd)\n{\n\tstruct domain_device *dev = cmd_to_domain_dev(cmd);\n\tstruct sas_ha_struct *ha = dev->port->ha;\n\tstruct sas_task *task = TO_SAS_TASK(cmd);\n\tif (!dev_is_sata(dev)) {\n\t\tsas_eh_finish_cmd(cmd);\n\t\treturn;\n\t}\n\tsas_end_task(cmd, task);\n\tlist_move_tail(&cmd->eh_entry, &ha->eh_ata_q);\n}", "target": 1}
{"code": "static int assign_cfs_rq_runtime(struct cfs_rq *cfs_rq)\n{\n\tstruct task_group *tg = cfs_rq->tg;\n\tstruct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(tg);\n\tu64 amount = 0, min_amount, expires;\n\tint expires_seq;\n\tmin_amount = sched_cfs_bandwidth_slice() - cfs_rq->runtime_remaining;\n\traw_spin_lock(&cfs_b->lock);\n\tif (cfs_b->quota == RUNTIME_INF)\n\t\tamount = min_amount;\n\telse {\n\t\tstart_cfs_bandwidth(cfs_b);\n\t\tif (cfs_b->runtime > 0) {\n\t\t\tamount = min(cfs_b->runtime, min_amount);\n\t\t\tcfs_b->runtime -= amount;\n\t\t\tcfs_b->idle = 0;\n\t\t}\n\t}\n\texpires_seq = cfs_b->expires_seq;\n\texpires = cfs_b->runtime_expires;\n\traw_spin_unlock(&cfs_b->lock);\n\tcfs_rq->runtime_remaining += amount;\n\tif (cfs_rq->expires_seq != expires_seq) {\n\t\tcfs_rq->expires_seq = expires_seq;\n\t\tcfs_rq->runtime_expires = expires;\n\t}\n\treturn cfs_rq->runtime_remaining > 0;\n}", "target": 1}
{"code": "get_page_size_prepared_cb (GdkPixbufLoader *loader,\n\t\t\t   int              width,\n\t\t\t   int              height,\n\t\t\t   PixbufInfo      *info)\n{\n\tinfo->got_info = TRUE;\n\tinfo->height = height;\n\tinfo->width = width;\n}", "target": 0}
{"code": "m_proleptic_julian_p(union DateData *x)\n{\n    double sg;\n    sg = m_sg(x);\n    if (isinf(sg) && sg > 0)\n\treturn 1;\n    return 0;\n}", "target": 0}
{"code": "crm_send_remote_msg(void *session, xmlNode * msg, gboolean encrypted)\n{\n    if (encrypted) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        cib_send_tls(session, msg);\n#else\n        CRM_ASSERT(encrypted == FALSE);\n#endif\n    } else {\n        cib_send_plaintext(GPOINTER_TO_INT(session), msg);\n    }\n}", "target": 1}
{"code": "BufferedRandomDevice::BufferedRandomDevice(size_t bufferSize)\n  : bufferSize_(bufferSize),\n    buffer_(new unsigned char[bufferSize]),\n    ptr_(buffer_.get() + bufferSize) {  \n  call_once(flag, [this]() {\n    detail::AtFork::registerHandler(\n        this,\n         []() { return true; },\n         []() {},\n        []() {\n          using Single = SingletonThreadLocal<BufferedRandomDevice, RandomTag>;\n          auto& t = Single::get();\n          t.ptr_ = t.buffer_.get() + t.bufferSize_;\n        });\n  });\n}", "target": 0}
{"code": "test_appheader (xd3_stream *stream, int ignore)\n{\n  int i;\n  int ret;\n  char buf[TESTBUFSIZE];\n  char bogus[TESTBUFSIZE];\n  xoff_t ssize, tsize;\n  test_setup ();\n  if ((ret = test_make_inputs (stream, &ssize, &tsize))) { return ret; }\n  snprintf_func (buf, TESTBUFSIZE, \"%s -q -f -e -s %s %s %s\", program_name,\n\t\t TEST_SOURCE_FILE, TEST_TARGET_FILE, TEST_DELTA_FILE);\n  if ((ret = do_cmd (stream, buf))) { return ret; }\n  if ((ret = test_copy_to (program_name, TEST_RECON2_FILE))) { return ret; }\n  snprintf_func (buf, TESTBUFSIZE, \"chmod 0700 %s\", TEST_RECON2_FILE);\n  if ((ret = do_cmd (stream, buf))) { return ret; }\n  if ((ret = test_save_copy (TEST_TARGET_FILE))) { return ret; }\n  if ((ret = test_copy_to (TEST_SOURCE_FILE, TEST_TARGET_FILE))) { return ret; }\n  if ((ret = test_compare_files (TEST_TARGET_FILE, TEST_COPY_FILE)) == 0)\n    {\n      return XD3_INVALID;  \n    }\n  snprintf_func (buf, TESTBUFSIZE, \"(cd /tmp && %s -q -f -d %s)\",\n\t\t TEST_RECON2_FILE,\n\t\t TEST_DELTA_FILE);\n  if ((ret = do_cmd (stream, buf))) { return ret; }\n  if ((ret = test_compare_files (TEST_TARGET_FILE, TEST_COPY_FILE)) != 0)\n    {\n      return ret;\n    }\n  for (i = 0; i < TESTBUFSIZE / 4; ++i)\n    {\n      bogus[2*i] = 'G';\n      bogus[2*i+1] = '/';\n    }\n  bogus[TESTBUFSIZE/2-1] = 0;\n  snprintf_func (buf, TESTBUFSIZE, \n\t\t \"%s -q -f -A=%s -e -s %s %s %s\", program_name, bogus,\n\t\t TEST_SOURCE_FILE, TEST_TARGET_FILE, TEST_DELTA_FILE);\n  if ((ret = do_cmd (stream, buf))) { return ret; }\n  snprintf_func (buf, TESTBUFSIZE, \"(cd /tmp && %s -q -f -d %s)\",\n\t\t TEST_RECON2_FILE,\n\t\t TEST_DELTA_FILE);\n  if ((ret = do_cmd (stream, buf)) == 0) \n    { \n      return XD3_INVALID;  \n    }\n  if (!WIFEXITED(ret))\n    {\n      return XD3_INVALID;  \n    }\n  return 0;\n}", "target": 0}
{"code": "static int orinoco_ioctl_setrate(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t struct iw_param *rrq,\n\t\t\t\t char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint ratemode;\n\tint bitrate; \n\tunsigned long flags;\n\tif (rrq->value == -1)\n\t\tbitrate = 110;\n\telse {\n\t\tif (rrq->value % 100000)\n\t\t\treturn -EINVAL;\n\t\tbitrate = rrq->value / 100000;\n\t}\n\tratemode = orinoco_get_bitratemode(bitrate, !rrq->fixed);\n\tif (ratemode == -1)\n\t\treturn -EINVAL;\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\tpriv->bitratemode = ratemode;\n\torinoco_unlock(priv, &flags);\n\treturn -EINPROGRESS;\n}", "target": 0}
{"code": "static inline void vma_adjust_trans_huge(struct vm_area_struct *vma,\n\t\t\t\t\t unsigned long start,\n\t\t\t\t\t unsigned long end,\n\t\t\t\t\t long adjust_next)\n{\n\tif (!vma->anon_vma || vma->vm_ops || vma->vm_file)\n\t\treturn;\n\t__vma_adjust_trans_huge(vma, start, end, adjust_next);\n}", "target": 1}
{"code": "static void set_own_dir(const char *argv0) {\n\tsize_t l = strlen(argv0);\n\twhile(l && argv0[l - 1] != '/')\n\t\tl--;\n\tif(l == 0)\n#ifdef SUPER_SECURE\n\t\tmemcpy(own_dir, \"/dev/null/\", 2);\n#else\n\t\tmemcpy(own_dir, \".\", 2);\n#endif\n\telse {\n\t\tmemcpy(own_dir, argv0, l - 1);\n\t\town_dir[l] = 0;\n\t}\n}", "target": 0}
{"code": "checked_xmalloc (size_t size)\n{\n    alloc_limit_assert (\"checked_xmalloc\", size);\n    return xmalloc (size);\n}", "target": 1}
{"code": "void RunOneAveragePoolTest(const PoolParams& params,\n                           const RuntimeShape& input_shape,\n                           const int8* input_data,\n                           const RuntimeShape& output_shape) {\n  const int buffer_size = output_shape.FlatSize();\n  std::vector<int8> optimized_averagePool_output(buffer_size);\n  std::vector<int8> reference_averagePool_output(buffer_size);\n  reference_integer_ops::AveragePool(params, input_shape, input_data,\n                                     output_shape,\n                                     reference_averagePool_output.data());\n  optimized_integer_ops::AveragePool(params, input_shape, input_data,\n                                     output_shape,\n                                     optimized_averagePool_output.data());\n  for (int i = 0; i < buffer_size; i++) {\n    EXPECT_TRUE(reference_averagePool_output[i] ==\n                optimized_averagePool_output[i]);\n  }\n}", "target": 1}
{"code": "x_order(const active_line *lp1, const active_line *lp2)\n{\n    bool s1;\n    INCR(order);\n    if (!lp1 || !lp2 || lp1->x_current < lp2->x_current)\n        return -1;\n    else if (lp1->x_current > lp2->x_current)\n        return 1;\n    if ((s1 = lp1->start.x < lp1->end.x) != (lp2->start.x < lp2->end.x))\n        return (s1 ? 1 : -1);\n    INCR(slow_order);\n    {\n        fixed dx1 = lp1->end.x - lp1->start.x,\n            dy1 = lp1->end.y - lp1->start.y;\n        fixed dx2 = lp2->end.x - lp2->start.x,\n            dy2 = lp2->end.y - lp2->start.y;\n        double diff = (double)dx1 * dy2 - (double)dx2 * dy1;\n        return (diff < 0 ? -1 : diff > 0 ? 1 : 0);\n    }\n}", "target": 0}
{"code": "void CefLayeredWindowUpdaterOSR::OnAllocatedSharedMemory(\n    const gfx::Size& pixel_size,\n    base::UnsafeSharedMemoryRegion region) {\n  size_t expected_bytes;\n  bool size_result = viz::ResourceSizes::MaybeSizeInBytes(\n      pixel_size, viz::SinglePlaneFormat::kRGBA_8888, &expected_bytes);\n  if (!size_result) {\n    return;\n  }\n  pixel_size_ = pixel_size;\n  shared_memory_ = region.Map();\n  DCHECK(shared_memory_.IsValid());\n}", "target": 1}
{"code": "TfLiteStatus PrepareHashtable(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 0);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  TF_LITE_ENSURE(context, node->user_data != nullptr);\n  const auto* params =\n      reinterpret_cast<const TfLiteHashtableParams*>(node->user_data);\n  TF_LITE_ENSURE(context, !params->table_name.empty());\n  TF_LITE_ENSURE(context, (params->key_dtype == kTfLiteInt64 &&\n                           params->value_dtype == kTfLiteString) ||\n                              (params->key_dtype == kTfLiteString &&\n                               params->value_dtype == kTfLiteInt64));\n  TfLiteTensor* resource_handle_tensor =\n      GetOutput(context, node, kResourceHandleTensor);\n  TF_LITE_ENSURE(context, resource_handle_tensor != nullptr);\n  TF_LITE_ENSURE_EQ(context, resource_handle_tensor->type, kTfLiteInt32);\n  TfLiteIntArray* outputSize = TfLiteIntArrayCreate(1);\n  outputSize->data[0] = 1;\n  return context->ResizeTensor(context, resource_handle_tensor, outputSize);\n}", "target": 1}
{"code": "static void clamp_buffer(void*& buffer, size_t& size, void* limit_start, void* limit_end)\n{\n\tif (NULL == limit_start || NULL == limit_end)\n\t\treturn;\n\tuint8_t* _buffer = (uint8_t*)buffer;\n\tuint8_t* _limit_start = (uint8_t*)limit_start;\n\tuint8_t* _limit_end = (uint8_t*)limit_end;\n\tif (_buffer > _limit_end)\n\t{\n\t\tbuffer = limit_end;\n\t\tsize = 0;\n\t\treturn;\n\t}\n\tif (_buffer < _limit_start)\n\t\t_buffer = _limit_start;\n\tif ((_buffer + size) > _limit_end)\n\t\tsize = (_limit_end - _buffer);\n}", "target": 0}
{"code": "static enum count_type __read_io_type(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tif (mapping) {\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\t\tif (inode->i_ino == F2FS_META_INO(sbi))\n\t\t\treturn F2FS_RD_META;\n\t\tif (inode->i_ino == F2FS_NODE_INO(sbi))\n\t\t\treturn F2FS_RD_NODE;\n\t}\n\treturn F2FS_RD_DATA;\n}", "target": 1}
{"code": "irc_server_reconnect_schedule (struct t_irc_server *server)\n{\n    int minutes, seconds;\n    if (IRC_SERVER_OPTION_BOOLEAN(server, IRC_SERVER_OPTION_AUTORECONNECT))\n    {\n        if (server->reconnect_delay == 0)\n            server->reconnect_delay = IRC_SERVER_OPTION_INTEGER(server, IRC_SERVER_OPTION_AUTORECONNECT_DELAY);\n        else\n            server->reconnect_delay = server->reconnect_delay * weechat_config_integer (irc_config_network_autoreconnect_delay_growing);\n        if ((weechat_config_integer (irc_config_network_autoreconnect_delay_max) > 0)\n            && (server->reconnect_delay > weechat_config_integer (irc_config_network_autoreconnect_delay_max)))\n            server->reconnect_delay = weechat_config_integer (irc_config_network_autoreconnect_delay_max);\n        server->reconnect_start = time (NULL);\n        minutes = server->reconnect_delay / 60;\n        seconds = server->reconnect_delay % 60;\n        if ((minutes > 0) && (seconds > 0))\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: reconnecting to server in %d %s, %d %s\"),\n                weechat_prefix (\"network\"),\n                IRC_PLUGIN_NAME,\n                minutes,\n                NG_(\"minute\", \"minutes\", minutes),\n                seconds,\n                NG_(\"second\", \"seconds\", seconds));\n        }\n        else if (minutes > 0)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: reconnecting to server in %d %s\"),\n                weechat_prefix (\"network\"),\n                IRC_PLUGIN_NAME,\n                minutes,\n                NG_(\"minute\", \"minutes\", minutes));\n        }\n        else\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: reconnecting to server in %d %s\"),\n                weechat_prefix (\"network\"),\n                IRC_PLUGIN_NAME,\n                seconds,\n                NG_(\"second\", \"seconds\", seconds));\n        }\n    }\n    else\n    {\n        server->reconnect_delay = 0;\n        server->reconnect_start = 0;\n    }\n}", "target": 0}
{"code": "void zend_throw_exception_internal(zval *exception TSRMLS_DC) \n{\n#ifdef HAVE_DTRACE\n\tif (DTRACE_EXCEPTION_THROWN_ENABLED()) {\n\t\tconst char *classname;\n\t\tzend_uint name_len;\n\t\tif (exception != NULL) {\n\t\t\tzend_get_object_classname(exception, &classname, &name_len TSRMLS_CC);\n\t\t\tDTRACE_EXCEPTION_THROWN((char *)classname);\n\t\t} else {\n\t\t\tDTRACE_EXCEPTION_THROWN(NULL);\n\t\t}\n\t}\n#endif \n\tif (exception != NULL) {\n\t\tzval *previous = EG(exception);\n\t\tzend_exception_set_previous(exception, EG(exception) TSRMLS_CC);\n\t\tEG(exception) = exception;\n\t\tif (previous) {\n\t\t\treturn;\n\t\t}\n\t}\n\tif (!EG(current_execute_data)) {\n\t\tif(EG(exception)) {\n\t\t\tzend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n\t\t}\n\t\tzend_error(E_ERROR, \"Exception thrown without a stack frame\");\n\t}\n\tif (zend_throw_exception_hook) {\n\t\tzend_throw_exception_hook(exception TSRMLS_CC);\n\t}\n\tif (EG(current_execute_data)->opline == NULL ||\n\t    (EG(current_execute_data)->opline+1)->opcode == ZEND_HANDLE_EXCEPTION) {\n\t\treturn;\n\t}\n\tEG(opline_before_exception) = EG(current_execute_data)->opline;\n\tEG(current_execute_data)->opline = EG(exception_op);\n}", "target": 0}
{"code": "static int lsm_set_label_at(int lsm_labelfd, int on_exec, char *lsm_label)\n{\n\tint fret = -1;\n\tconst char* name;\n\tchar *command = NULL;\n\tname = lsm_name();\n\tif (strcmp(name, \"nop\") == 0)\n\t\treturn 0;\n\tif (strcmp(name, \"none\") == 0)\n\t\treturn 0;\n\tif (strcmp(name, \"AppArmor\") == 0)\n\t\ton_exec = 0;\n\tif (strcmp(name, \"AppArmor\") == 0) {\n\t\tint size;\n\t\tcommand = malloc(strlen(lsm_label) + strlen(\"changeprofile \") + 1);\n\t\tif (!command) {\n\t\t\tSYSERROR(\"Failed to write apparmor profile\");\n\t\t\tgoto out;\n\t\t}\n\t\tsize = sprintf(command, \"changeprofile %s\", lsm_label);\n\t\tif (size < 0) {\n\t\t\tSYSERROR(\"Failed to write apparmor profile\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (write(lsm_labelfd, command, size + 1) < 0) {\n\t\t\tSYSERROR(\"Unable to set LSM label: %s.\", command);\n\t\t\tgoto out;\n\t\t}\n\t\tINFO(\"Set LSM label to: %s.\", command);\n\t} else if (strcmp(name, \"SELinux\") == 0) {\n\t\tif (write(lsm_labelfd, lsm_label, strlen(lsm_label) + 1) < 0) {\n\t\t\tSYSERROR(\"Unable to set LSM label\");\n\t\t\tgoto out;\n\t\t}\n\t\tINFO(\"Set LSM label to: %s.\", lsm_label);\n\t} else {\n\t\tERROR(\"Unable to restore label for unknown LSM: %s\", name);\n\t\tgoto out;\n\t}\n\tfret = 0;\nout:\n\tfree(command);\n\tif (lsm_labelfd != -1)\n\t\tclose(lsm_labelfd);\n\treturn fret;\n}", "target": 0}
{"code": "static int setup_dev_console(const struct lxc_rootfs *rootfs,\n\t\t\t const struct lxc_console *console)\n{\n\tchar path[MAXPATHLEN];\n\tstruct stat s;\n\tint ret;\n\tret = snprintf(path, sizeof(path), \"%s/dev/console\", rootfs->mount);\n\tif (ret >= sizeof(path)) {\n\t\tERROR(\"console path too long\");\n\t\treturn -1;\n\t}\n\tif (access(path, F_OK)) {\n\t\tWARN(\"rootfs specified but no console found at '%s'\", path);\n\t\treturn 0;\n\t}\n\tif (console->master < 0) {\n\t\tINFO(\"no console\");\n\t\treturn 0;\n\t}\n\tif (stat(path, &s)) {\n\t\tSYSERROR(\"failed to stat '%s'\", path);\n\t\treturn -1;\n\t}\n\tif (chmod(console->name, s.st_mode)) {\n\t\tSYSERROR(\"failed to set mode '0%o' to '%s'\",\n\t\t\t s.st_mode, console->name);\n\t\treturn -1;\n\t}\n\tif (mount(console->name, path, \"none\", MS_BIND, 0)) {\n\t\tERROR(\"failed to mount '%s' on '%s'\", console->name, path);\n\t\treturn -1;\n\t}\n\tINFO(\"console has been setup\");\n\treturn 0;\n}", "target": 1}
{"code": "TEST_F(ZNCTest, Modpython) {\n    if (QProcessEnvironment::systemEnvironment().value(\n            \"DISABLED_ZNC_PERL_PYTHON_TEST\") == \"1\") {\n        return;\n    }\n    auto znc = Run();\n    znc->CanLeak();\n    auto ircd = ConnectIRCd();\n    auto client = LoginClient();\n    client.Write(\"znc loadmod modpython\");\n    client.Write(\"znc loadmod pyeval\");\n    client.Write(\"PRIVMSG *pyeval :2+2\");\n    client.ReadUntil(\":*pyeval!znc@znc.in PRIVMSG nick :4\");\n    client.Write(\"PRIVMSG *pyeval :module.GetUser().GetUserName()\");\n    client.ReadUntil(\"nick :'user'\");\n    ircd.Write(\":server 001 nick :Hello\");\n    ircd.Write(\":n!u@h PRIVMSG nick :Hi\\xF0, github issue #1229\");\n    client.ReadUntil(\"Hi\\xEF\\xBF\\xBD, github issue\");\n    client.Write(\"PRIVMSG *controlpanel :Set ClientEncoding $me Western\");\n    client.Write(\"JOIN #a\\342\");\n    client.ReadUntil(\n        \":*controlpanel!znc@znc.in PRIVMSG nick :ClientEncoding = UTF-8\");\n    ircd.ReadUntil(\"JOIN #a\\xEF\\xBF\\xBD\");\n}", "target": 0}
{"code": "static void cancel_att_send_op(struct att_send_op *op)\n{\n\tif (op->destroy)\n\t\top->destroy(op->user_data);\n\top->user_data = NULL;\n\top->callback = NULL;\n\top->destroy = NULL;\n}", "target": 1}
{"code": "int btrfs_scrub_progress(struct btrfs_fs_info *fs_info, u64 devid,\n\t\t\t struct btrfs_scrub_progress *progress)\n{\n\tstruct btrfs_device *dev;\n\tstruct scrub_ctx *sctx = NULL;\n\tmutex_lock(&fs_info->fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(fs_info->fs_devices, devid, NULL, NULL);\n\tif (dev)\n\t\tsctx = dev->scrub_ctx;\n\tif (sctx)\n\t\tmemcpy(progress, &sctx->stat, sizeof(*progress));\n\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\treturn dev ? (sctx ? 0 : -ENOTCONN) : -ENODEV;\n}", "target": 1}
{"code": "void fmtutil_macbitmap_read_pixmap_only_fields(deark *c, dbuf *f, struct fmtutil_macbitmap_info *bi,\n\ti64 pos)\n{\n\ti64 pixmap_version;\n\ti64 pack_size;\n\ti64 plane_bytes;\n\ti64 n;\n\tde_dbg(c, \"additional PixMap header fields, at %d\", (int)pos);\n\tde_dbg_indent(c, 1);\n\tpixmap_version = dbuf_getu16be(f, pos+0);\n\tde_dbg(c, \"pixmap version: %d\", (int)pixmap_version);\n\tbi->packing_type = dbuf_getu16be(f, pos+2);\n\tde_dbg(c, \"packing type: %d\", (int)bi->packing_type);\n\tpack_size = dbuf_getu32be(f, pos+4);\n\tde_dbg(c, \"pixel data length: %d\", (int)pack_size);\n\tbi->hdpi = pict_read_fixed(f, pos+8);\n\tbi->vdpi = pict_read_fixed(f, pos+12);\n\tde_dbg(c, \"dpi: %.2f\"DE_CHAR_TIMES\"%.2f\", bi->hdpi, bi->vdpi);\n\tbi->pixeltype = dbuf_getu16be(f, pos+16);\n\tbi->pixelsize = dbuf_getu16be(f, pos+18);\n\tbi->cmpcount = dbuf_getu16be(f, pos+20);\n\tbi->cmpsize = dbuf_getu16be(f, pos+22);\n\tde_dbg(c, \"pixel type=%d, bits/pixel=%d, components/pixel=%d, bits/comp=%d\",\n\t\t(int)bi->pixeltype, (int)bi->pixelsize, (int)bi->cmpcount, (int)bi->cmpsize);\n\tbi->pdwidth = (bi->rowbytes*8)/bi->pixelsize;\n\tif(bi->pdwidth < bi->npwidth) {\n\t\tbi->pdwidth = bi->npwidth;\n\t}\n\tplane_bytes = dbuf_getu32be(f, pos+24);\n\tde_dbg(c, \"plane bytes: %d\", (int)plane_bytes);\n\tbi->pmTable = (u32)dbuf_getu32be(f, pos+28);\n\tde_dbg(c, \"pmTable: 0x%08x\", (unsigned int)bi->pmTable);\n\tn = dbuf_getu32be(f, pos+32);\n\tde_dbg(c, \"pmReserved: 0x%08x\", (unsigned int)n);\n\tde_dbg_indent(c, -1);\n}", "target": 1}
{"code": "ospf_ls_ack_send_delayed (struct ospf_interface *oi)\n{\n  struct in_addr dst;\n  if (oi->type == OSPF_IFTYPE_NBMA)\n    {\n      struct ospf_neighbor *nbr;\n      struct route_node *rn;\n      for (rn = route_top (oi->nbrs); rn; rn = route_next (rn))\n\tif ((nbr = rn->info) != NULL)\n\t  if (nbr != oi->nbr_self && nbr->state >= NSM_Exchange)\n\t    while (listcount (oi->ls_ack))\n\t      ospf_ls_ack_send_list (oi, oi->ls_ack, nbr->address.u.prefix4);\n      return;\n    }\n  if (oi->type == OSPF_IFTYPE_VIRTUALLINK)\n    dst.s_addr = oi->vl_data->peer_addr.s_addr;\n  else if (oi->state == ISM_DR || oi->state == ISM_Backup)\n    dst.s_addr = htonl (OSPF_ALLSPFROUTERS);\n  else if (oi->type == OSPF_IFTYPE_POINTOPOINT)\n    dst.s_addr = htonl (OSPF_ALLSPFROUTERS);\n  else if (oi->type == OSPF_IFTYPE_POINTOMULTIPOINT)\n    dst.s_addr = htonl (OSPF_ALLSPFROUTERS);\n  else\n    dst.s_addr = htonl (OSPF_ALLDROUTERS);\n  while (listcount (oi->ls_ack))\n    ospf_ls_ack_send_list (oi, oi->ls_ack, dst);\n}", "target": 0}
{"code": "mark_desktop_file_executable_task_thread_func (GTask        *task,\n                                               gpointer      source_object,\n                                               gpointer      task_data,\n                                               GCancellable *cancellable)\n{\n    MarkTrustedJob *job = task_data;\n    CommonJob *common;\n    common = (CommonJob *) job;\n    nautilus_progress_info_start (job->common.progress);\n    mark_desktop_file_executable (common,\n                                  cancellable,\n                                  job->file,\n                                  job->interactive);\n}", "target": 0}
{"code": "static void __exit ipgre_fini(void)\n{\n\trtnl_link_unregister(&ipgre_tap_ops);\n\trtnl_link_unregister(&ipgre_link_ops);\n\tunregister_pernet_device(&ipgre_net_ops);\n\tif (inet_del_protocol(&ipgre_protocol, IPPROTO_GRE) < 0)\n\t\tprintk(KERN_INFO \"ipgre close: can't remove protocol\\n\");\n}", "target": 1}
{"code": "int nf_ct_frag6_gather(struct net *net, struct sk_buff *skb, u32 user)\n{\n\tstruct net_device *dev = skb->dev;\n\tint fhoff, nhoff, ret;\n\tstruct frag_hdr *fhdr;\n\tstruct frag_queue *fq;\n\tstruct ipv6hdr *hdr;\n\tu8 prevhdr;\n\tif (ipv6_hdr(skb)->payload_len == 0) {\n\t\tpr_debug(\"payload len = 0\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (find_prev_fhdr(skb, &prevhdr, &nhoff, &fhoff) < 0)\n\t\treturn -EINVAL;\n\tif (!pskb_may_pull(skb, fhoff + sizeof(*fhdr)))\n\t\treturn -ENOMEM;\n\tskb_set_transport_header(skb, fhoff);\n\thdr = ipv6_hdr(skb);\n\tfhdr = (struct frag_hdr *)skb_transport_header(skb);\n\tfq = fq_find(net, fhdr->identification, user, &hdr->saddr, &hdr->daddr,\n\t\t     skb->dev ? skb->dev->ifindex : 0, ip6_frag_ecn(hdr));\n\tif (fq == NULL) {\n\t\tpr_debug(\"Can't find and can't create new queue\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tspin_lock_bh(&fq->q.lock);\n\tif (nf_ct_frag6_queue(fq, skb, fhdr, nhoff) < 0) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\tret = -EINPROGRESS;\n\tif (fq->q.flags == (INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN) &&\n\t    fq->q.meat == fq->q.len &&\n\t    nf_ct_frag6_reasm(fq, skb, dev))\n\t\tret = 0;\nout_unlock:\n\tspin_unlock_bh(&fq->q.lock);\n\tinet_frag_put(&fq->q, &nf_frags);\n\treturn ret;\n}", "target": 1}
{"code": "static int __ext4_expand_extra_isize(struct inode *inode,\n\t\t\t\t     unsigned int new_extra_isize,\n\t\t\t\t     struct ext4_iloc *iloc,\n\t\t\t\t     handle_t *handle, int *no_expand)\n{\n\tstruct ext4_inode *raw_inode;\n\tstruct ext4_xattr_ibody_header *header;\n\tunsigned int inode_size = EXT4_INODE_SIZE(inode->i_sb);\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tint error;\n\tif ((EXT4_GOOD_OLD_INODE_SIZE + ei->i_extra_isize > inode_size) ||\n\t    (ei->i_extra_isize & 3)) {\n\t\tEXT4_ERROR_INODE(inode, \"bad extra_isize %u (inode size %u)\",\n\t\t\t\t ei->i_extra_isize,\n\t\t\t\t EXT4_INODE_SIZE(inode->i_sb));\n\t\treturn -EFSCORRUPTED;\n\t}\n\tif ((new_extra_isize < ei->i_extra_isize) ||\n\t    (new_extra_isize < 4) ||\n\t    (new_extra_isize > inode_size - EXT4_GOOD_OLD_INODE_SIZE))\n\t\treturn -EINVAL;\t\n\traw_inode = ext4_raw_inode(iloc);\n\theader = IHDR(inode, raw_inode);\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_XATTR) ||\n\t    header->h_magic != cpu_to_le32(EXT4_XATTR_MAGIC)) {\n\t\tmemset((void *)raw_inode + EXT4_GOOD_OLD_INODE_SIZE +\n\t\t       EXT4_I(inode)->i_extra_isize, 0,\n\t\t       new_extra_isize - EXT4_I(inode)->i_extra_isize);\n\t\tEXT4_I(inode)->i_extra_isize = new_extra_isize;\n\t\treturn 0;\n\t}\n\terror = ext4_expand_extra_isize_ea(inode, new_extra_isize,\n\t\t\t\t\t   raw_inode, handle);\n\tif (error) {\n\t\t*no_expand = 1;\n\t}\n\treturn error;\n}", "target": 0}
{"code": "static ssize_t ppp_read(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct ppp_file *pf = file->private_data;\n\tDECLARE_WAITQUEUE(wait, current);\n\tssize_t ret;\n\tstruct sk_buff *skb = NULL;\n\tstruct iovec iov;\n\tstruct iov_iter to;\n\tret = count;\n\tif (!pf)\n\t\treturn -ENXIO;\n\tadd_wait_queue(&pf->rwait, &wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tskb = skb_dequeue(&pf->rq);\n\t\tif (skb)\n\t\t\tbreak;\n\t\tret = 0;\n\t\tif (pf->dead)\n\t\t\tbreak;\n\t\tif (pf->kind == INTERFACE) {\n\t\t\tstruct ppp *ppp = PF_TO_PPP(pf);\n\t\t\tif (ppp->n_channels == 0 &&\n\t\t\t    (ppp->flags & SC_LOOP_TRAFFIC) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = -EAGAIN;\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\tbreak;\n\t\tret = -ERESTARTSYS;\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\tschedule();\n\t}\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(&pf->rwait, &wait);\n\tif (!skb)\n\t\tgoto out;\n\tret = -EOVERFLOW;\n\tif (skb->len > count)\n\t\tgoto outf;\n\tret = -EFAULT;\n\tiov.iov_base = buf;\n\tiov.iov_len = count;\n\tiov_iter_init(&to, READ, &iov, 1, count);\n\tif (skb_copy_datagram_iter(skb, 0, &to, skb->len))\n\t\tgoto outf;\n\tret = skb->len;\n outf:\n\tkfree_skb(skb);\n out:\n\treturn ret;\n}", "target": 0}
{"code": "void ssl_update_cache(SSL_CONNECTION *s, int mode)\n{\n    int i;\n    if (s->session->session_id_length == 0)\n        return;\n    if (s->server && s->session->sid_ctx_length == 0\n            && (s->verify_mode & SSL_VERIFY_PEER) != 0)\n        return;\n    i = s->session_ctx->session_cache_mode;\n    if ((i & mode) != 0\n        && (!s->hit || SSL_CONNECTION_IS_TLS13(s))) {\n        if ((i & SSL_SESS_CACHE_NO_INTERNAL_STORE) == 0\n                && (!SSL_CONNECTION_IS_TLS13(s)\n                    || !s->server\n                    || (s->max_early_data > 0\n                        && (s->options & SSL_OP_NO_ANTI_REPLAY) == 0)\n                    || s->session_ctx->remove_session_cb != NULL\n                    || (s->options & SSL_OP_NO_TICKET) != 0))\n            SSL_CTX_add_session(s->session_ctx, s->session);\n        if (s->session_ctx->new_session_cb != NULL) {\n            SSL_SESSION_up_ref(s->session);\n            if (!s->session_ctx->new_session_cb(SSL_CONNECTION_GET_SSL(s),\n                                                s->session))\n                SSL_SESSION_free(s->session);\n        }\n    }\n    if ((!(i & SSL_SESS_CACHE_NO_AUTO_CLEAR)) && ((i & mode) == mode)) {\n        TSAN_QUALIFIER int *stat;\n        if (mode & SSL_SESS_CACHE_CLIENT)\n            stat = &s->session_ctx->stats.sess_connect_good;\n        else\n            stat = &s->session_ctx->stats.sess_accept_good;\n        if ((ssl_tsan_load(s->session_ctx, stat) & 0xff) == 0xff)\n            SSL_CTX_flush_sessions(s->session_ctx, (unsigned long)time(NULL));\n    }\n}", "target": 1}
{"code": "void ConnPoolImplBase::checkForIdleAndCloseIdleConnsIfDraining() {\n  if (is_draining_for_deletion_) {\n    closeIdleConnectionsForDrainingPool();\n  }\n  if (isIdleImpl()) {\n    ENVOY_LOG(debug, \"invoking idle callbacks - is_draining_for_deletion_={}\",\n              is_draining_for_deletion_);\n    for (const Instance::IdleCb& cb : idle_callbacks_) {\n      cb();\n    }\n  }\n}", "target": 1}
{"code": "static apr_byte_t oidc_validate_post_logout_url(request_rec *r, const char *url,\n\t\tchar **err_str, char **err_desc) {\n\tapr_uri_t uri;\n\tconst char *c_host = NULL;\n\tif (apr_uri_parse(r->pool, url, &uri) != APR_SUCCESS) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Malformed URL\");\n\t\t*err_desc = apr_psprintf(r->pool, \"Logout URL malformed: %s\", url);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t}\n\tc_host = oidc_get_current_url_host(r);\n\tif ((uri.hostname != NULL)\n\t\t\t&& ((strstr(c_host, uri.hostname) == NULL)\n\t\t\t\t\t|| (strstr(uri.hostname, c_host) == NULL))) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Invalid Request\");\n\t\t*err_desc =\n\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"logout value \\\"%s\\\" does not match the hostname of the current request \\\"%s\\\"\",\n\t\t\t\t\t\tapr_uri_unparse(r->pool, &uri, 0), c_host);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t} else if ((uri.hostname == NULL) && (strstr(url, \"/\") != url)) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Malformed URL\");\n\t\t*err_desc =\n\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"No hostname was parsed and it does not seem to be relative, i.e starting with '/': %s\",\n\t\t\t\t\t\turl);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t}\n\tif (((strstr(url, \"\\n\") != NULL) || strstr(url, \"\\r\") != NULL)) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Invalid Request\");\n\t\t*err_desc =\n\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"logout value \\\"%s\\\" contains illegal \\\"\\n\\\" or \\\"\\r\\\" character(s)\",\n\t\t\t\t\t\turl);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}", "target": 0}
{"code": "int input_set_keycode(struct input_dev *dev,\n\t\t      const struct input_keymap_entry *ke)\n{\n\tunsigned long flags;\n\tunsigned int old_keycode;\n\tint retval;\n\tif (ke->keycode > KEY_MAX)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\tretval = dev->setkeycode(dev, ke, &old_keycode);\n\tif (retval)\n\t\tgoto out;\n\t__clear_bit(KEY_RESERVED, dev->keybit);\n\tif (test_bit(EV_KEY, dev->evbit) &&\n\t    !is_event_supported(old_keycode, dev->keybit, KEY_MAX) &&\n\t    __test_and_clear_bit(old_keycode, dev->key)) {\n\t\tstruct input_value vals[] =  {\n\t\t\t{ EV_KEY, old_keycode, 0 },\n\t\t\tinput_value_sync\n\t\t};\n\t\tinput_pass_values(dev, vals, ARRAY_SIZE(vals));\n\t}\n out:\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\treturn retval;\n}", "target": 1}
{"code": "get_supported_image_extensions(void)\n{\n\tGSList *extensions = NULL;\n\tGSList *formats = gdk_pixbuf_get_formats ();\n\tGSList *l;\n\tfor (l = formats; l != NULL; l = l->next) {\n\t\tint i;\n\t\tgchar **ext = gdk_pixbuf_format_get_extensions (l->data);\n\t\tfor (i = 0; ext[i] != NULL; i++) {\n\t\t\textensions = g_slist_append (extensions,\n\t\t\t\t\t\t     g_strdup (ext[i]));\n\t\t}\n\t\tg_strfreev (ext);\n\t}\n\tg_slist_free (formats);\n\treturn extensions;\n}", "target": 1}
{"code": "mwifiex_set_uap_rates(struct mwifiex_uap_bss_param *bss_cfg,\n\t\t      struct cfg80211_ap_settings *params)\n{\n\tstruct ieee_types_header *rate_ie;\n\tint var_offset = offsetof(struct ieee80211_mgmt, u.beacon.variable);\n\tconst u8 *var_pos = params->beacon.head + var_offset;\n\tint len = params->beacon.head_len - var_offset;\n\tu8 rate_len = 0;\n\trate_ie = (void *)cfg80211_find_ie(WLAN_EID_SUPP_RATES, var_pos, len);\n\tif (rate_ie) {\n\t\tmemcpy(bss_cfg->rates, rate_ie + 1, rate_ie->len);\n\t\trate_len = rate_ie->len;\n\t}\n\trate_ie = (void *)cfg80211_find_ie(WLAN_EID_EXT_SUPP_RATES,\n\t\t\t\t\t   params->beacon.tail,\n\t\t\t\t\t   params->beacon.tail_len);\n\tif (rate_ie)\n\t\tmemcpy(bss_cfg->rates + rate_len, rate_ie + 1, rate_ie->len);\n\treturn;\n}", "target": 1}
{"code": "static int cp2112_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tunsigned long flags;\n\tint ret;\n\tspin_lock_irqsave(&dev->lock, flags);\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_CONFIG_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO config: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\tbuf[1] &= ~(1 << offset);\n\tbuf[2] = gpio_push_pull;\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"error setting GPIO config: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\tret = 0;\nexit:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\treturn ret <= 0 ? ret : -EIO;\n}", "target": 1}
{"code": "  static const char* ConvertScalar(PyObject* v, Eigen::half* out) {\n    Safe_PyObjectPtr as_float = make_safe(PyNumber_Float(v));\n    double v_double = PyFloat_AS_DOUBLE(as_float.get());\n    *out = Eigen::half(v_double);\n    return nullptr;\n  }", "target": 1}
{"code": "static struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)\n{\n\tstruct hlist_head *hashent = ucounts_hashentry(ns, uid);\n\tstruct ucounts *ucounts, *new;\n\tspin_lock_irq(&ucounts_lock);\n\tucounts = find_ucounts(ns, uid, hashent);\n\tif (!ucounts) {\n\t\tspin_unlock_irq(&ucounts_lock);\n\t\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\t\tif (!new)\n\t\t\treturn NULL;\n\t\tnew->ns = ns;\n\t\tnew->uid = uid;\n\t\tatomic_set(&new->count, 0);\n\t\tspin_lock_irq(&ucounts_lock);\n\t\tucounts = find_ucounts(ns, uid, hashent);\n\t\tif (ucounts) {\n\t\t\tkfree(new);\n\t\t} else {\n\t\t\thlist_add_head(&new->node, hashent);\n\t\t\tucounts = new;\n\t\t}\n\t}\n\tif (!atomic_add_unless(&ucounts->count, 1, INT_MAX))\n\t\tucounts = NULL;\n\tspin_unlock_irq(&ucounts_lock);\n\treturn ucounts;\n}", "target": 1}
{"code": "folly::Optional<Param> ReadRecordLayer::readEvent(\n    folly::IOBufQueue& socketBuf) {\n  if (!unparsedHandshakeData_.empty()) {\n    auto param = decodeHandshakeMessage(unparsedHandshakeData_);\n    if (param) {\n      VLOG(8) << \"Received handshake message \"\n              << toString(boost::apply_visitor(EventVisitor(), *param));\n      return param;\n    }\n  }\n  while (true) {\n    auto message = read(socketBuf);\n    if (!message) {\n      return folly::none;\n    }\n    if (!unparsedHandshakeData_.empty() &&\n        message->type != ContentType::handshake) {\n      throw std::runtime_error(\"spliced handshake data\");\n    }\n    switch (message->type) {\n      case ContentType::alert: {\n        auto alert = decode<Alert>(std::move(message->fragment));\n        if (alert.description == AlertDescription::close_notify) {\n          return Param(CloseNotify(socketBuf.move()));\n        } else {\n          return Param(std::move(alert));\n        }\n      }\n      case ContentType::handshake: {\n        unparsedHandshakeData_.append(std::move(message->fragment));\n        auto param = decodeHandshakeMessage(unparsedHandshakeData_);\n        if (param) {\n          VLOG(8) << \"Received handshake message \"\n                  << toString(boost::apply_visitor(EventVisitor(), *param));\n          return param;\n        } else {\n          continue;\n        }\n      }\n      case ContentType::application_data:\n        return Param(AppData(std::move(message->fragment)));\n      default:\n        throw std::runtime_error(\"unknown content type\");\n    }\n  }\n}", "target": 1}
{"code": "struct pipe_inode_info *alloc_pipe_info(void)\n{\n\tstruct pipe_inode_info *pipe;\n\tpipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL);\n\tif (pipe) {\n\t\tpipe->bufs = kzalloc(sizeof(struct pipe_buffer) * PIPE_DEF_BUFFERS, GFP_KERNEL);\n\t\tif (pipe->bufs) {\n\t\t\tinit_waitqueue_head(&pipe->wait);\n\t\t\tpipe->r_counter = pipe->w_counter = 1;\n\t\t\tpipe->buffers = PIPE_DEF_BUFFERS;\n\t\t\tmutex_init(&pipe->mutex);\n\t\t\treturn pipe;\n\t\t}\n\t\tkfree(pipe);\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "int ext4_change_inode_journal_flag(struct inode *inode, int val)\n{\n\tjournal_t *journal;\n\thandle_t *handle;\n\tint err;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tjournal = EXT4_JOURNAL(inode);\n\tif (!journal)\n\t\treturn 0;\n\tif (is_journal_aborted(journal))\n\t\treturn -EROFS;\n\tinode_dio_wait(inode);\n\tif (val) {\n\t\tdown_write(&EXT4_I(inode)->i_mmap_sem);\n\t\terr = filemap_write_and_wait(inode->i_mapping);\n\t\tif (err < 0) {\n\t\t\tup_write(&EXT4_I(inode)->i_mmap_sem);\n\t\t\treturn err;\n\t\t}\n\t}\n\tpercpu_down_write(&sbi->s_journal_flag_rwsem);\n\tjbd2_journal_lock_updates(journal);\n\tif (val)\n\t\text4_set_inode_flag(inode, EXT4_INODE_JOURNAL_DATA);\n\telse {\n\t\terr = jbd2_journal_flush(journal);\n\t\tif (err < 0) {\n\t\t\tjbd2_journal_unlock_updates(journal);\n\t\t\tpercpu_up_write(&sbi->s_journal_flag_rwsem);\n\t\t\treturn err;\n\t\t}\n\t\text4_clear_inode_flag(inode, EXT4_INODE_JOURNAL_DATA);\n\t}\n\text4_set_aops(inode);\n\tjbd2_journal_unlock_updates(journal);\n\tpercpu_up_write(&sbi->s_journal_flag_rwsem);\n\tif (val)\n\t\tup_write(&EXT4_I(inode)->i_mmap_sem);\n\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 1);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\terr = ext4_mark_inode_dirty(handle, inode);\n\text4_handle_sync(handle);\n\text4_journal_stop(handle);\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n}", "target": 0}
{"code": "static int proc_sys_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct ctl_table_header *head = grab_header(file_inode(file));\n\tstruct ctl_table_header *h = NULL;\n\tstruct ctl_table *entry;\n\tstruct ctl_dir *ctl_dir;\n\tunsigned long pos;\n\tif (IS_ERR(head))\n\t\treturn PTR_ERR(head);\n\tctl_dir = container_of(head, struct ctl_dir, header);\n\tif (!dir_emit_dots(file, ctx))\n\t\treturn 0;\n\tpos = 2;\n\tfor (first_entry(ctl_dir, &h, &entry); h; next_entry(&h, &entry)) {\n\t\tif (!scan(h, entry, &pos, file, ctx)) {\n\t\t\tsysctl_head_finish(h);\n\t\t\tbreak;\n\t\t}\n\t}\n\tsysctl_head_finish(head);\n\treturn 0;\n}", "target": 1}
{"code": "envoy::config::cluster::v3::Cluster ConfigHelper::buildH1ClusterWithHighCircuitBreakersLimits(\n    const std::string& name, int port, const std::string& address, const std::string& lb_policy) {\n  return TestUtility::parseYaml<envoy::config::cluster::v3::Cluster>(\n      fmt::format(R\"EOF(\n      name: {}\n      connect_timeout: 50s\n      type: STATIC\n      circuit_breakers:\n        thresholds:\n        - priority: DEFAULT\n          max_connections: 10000\n          max_pending_requests: 10000\n          max_requests: 10000\n          max_retries: 10000\n      load_assignment:\n        cluster_name: {}\n        endpoints:\n        - lb_endpoints:\n          - endpoint:\n              address:\n                socket_address:\n                  address: {}\n                  port_value: {}\n      lb_policy: {}\n    )EOF\",\n                  name, name, address, port, lb_policy));\n}", "target": 0}
{"code": "        EDP* getEDP() { return &edp_; }", "target": 1}
{"code": "PJ_DEF(pj_status_t) pj_file_setpos( pj_oshandle_t fd,\n                                    pj_off_t offset,\n                                    enum pj_file_seek_type whence)\n{\n    int mode;\n    if ((sizeof(pj_off_t) > sizeof(long)) &&\n        (offset > PJ_MAXLONG || offset < PJ_MINLONG)) \n    {\n        return PJ_ENOTSUP;\n    }\n    switch (whence) {\n    case PJ_SEEK_SET:\n        mode = SEEK_SET; break;\n    case PJ_SEEK_CUR:\n        mode = SEEK_CUR; break;\n    case PJ_SEEK_END:\n        mode = SEEK_END; break;\n    default:\n        pj_assert(!\"Invalid whence in file_setpos\");\n        return PJ_EINVAL;\n    }\n    if (fseek((FILE*)fd, (long)offset, mode) != 0)\n        return PJ_RETURN_OS_ERROR(errno);\n    return PJ_SUCCESS;\n}", "target": 0}
{"code": "bool ImageIsJPEG( String const& filename ) {\n   try {\n      JpegInput jpeg( filename );\n   } catch( ... ) {\n      return false;\n   }\n   return true;\n}", "target": 1}
{"code": "ipv6_dup_options(struct sock *sk, struct ipv6_txoptions *opt)\n{\n\tstruct ipv6_txoptions *opt2;\n\topt2 = sock_kmalloc(sk, opt->tot_len, GFP_ATOMIC);\n\tif (opt2) {\n\t\tlong dif = (char *)opt2 - (char *)opt;\n\t\tmemcpy(opt2, opt, opt->tot_len);\n\t\tif (opt2->hopopt)\n\t\t\t*((char **)&opt2->hopopt) += dif;\n\t\tif (opt2->dst0opt)\n\t\t\t*((char **)&opt2->dst0opt) += dif;\n\t\tif (opt2->dst1opt)\n\t\t\t*((char **)&opt2->dst1opt) += dif;\n\t\tif (opt2->srcrt)\n\t\t\t*((char **)&opt2->srcrt) += dif;\n\t\tatomic_set(&opt2->refcnt, 1);\n\t}\n\treturn opt2;\n}", "target": 0}
{"code": "static int f2fs_swap_activate(struct swap_info_struct *sis, struct file *file,\n\t\t\t\tsector_t *span)\n{\n\tstruct inode *inode = file_inode(file);\n\tint ret;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\tif (f2fs_readonly(F2FS_I_SB(inode)->sb))\n\t\treturn -EROFS;\n\tret = f2fs_convert_inline_inode(inode);\n\tif (ret)\n\t\treturn ret;\n\tret = check_swap_activate(file, sis->max);\n\tif (ret)\n\t\treturn ret;\n\tset_inode_flag(inode, FI_PIN_FILE);\n\tf2fs_precache_extents(inode);\n\tf2fs_update_time(F2FS_I_SB(inode), REQ_TIME);\n\treturn 0;\n}", "target": 0}
{"code": "bool DecodeResourceHandleList(std::unique_ptr<port::StringListDecoder> d,\n                              ResourceHandle* ps, int64_t n) {\n  std::vector<uint32> sizes(n);\n  if (!d->ReadSizes(&sizes)) return false;\n  ResourceHandleProto proto;\n  for (int i = 0; i < n; ++i) {\n    if (!proto.ParseFromArray(d->Data(sizes[i]), sizes[i])) {\n      return false;\n    }\n    ps[i].FromProto(proto);\n  }\n  return true;\n}", "target": 1}
{"code": "static void dtls1_clear_queues(SSL *s)\n\t{\n    pitem *item = NULL;\n    hm_fragment *frag = NULL;\n\tDTLS1_RECORD_DATA *rdata;\n    while( (item = pqueue_pop(s->d1->unprocessed_rcds.q)) != NULL)\n        {\n\t\trdata = (DTLS1_RECORD_DATA *) item->data;\n\t\tif (rdata->rbuf.buf)\n\t\t\t{\n\t\t\tOPENSSL_free(rdata->rbuf.buf);\n\t\t\t}\n        OPENSSL_free(item->data);\n        pitem_free(item);\n        }\n    while( (item = pqueue_pop(s->d1->processed_rcds.q)) != NULL)\n        {\n\t\trdata = (DTLS1_RECORD_DATA *) item->data;\n\t\tif (rdata->rbuf.buf)\n\t\t\t{\n\t\t\tOPENSSL_free(rdata->rbuf.buf);\n\t\t\t}\n        OPENSSL_free(item->data);\n        pitem_free(item);\n        }\n    while( (item = pqueue_pop(s->d1->buffered_messages)) != NULL)\n        {\n        frag = (hm_fragment *)item->data;\n        OPENSSL_free(frag->fragment);\n        OPENSSL_free(frag);\n        pitem_free(item);\n        }\n    while ( (item = pqueue_pop(s->d1->sent_messages)) != NULL)\n        {\n        frag = (hm_fragment *)item->data;\n        OPENSSL_free(frag->fragment);\n        OPENSSL_free(frag);\n        pitem_free(item);\n        }\n\twhile ( (item = pqueue_pop(s->d1->buffered_app_data.q)) != NULL)\n\t\t{\n\t\tfrag = (hm_fragment *)item->data;\n\t\tOPENSSL_free(frag->fragment);\n\t\tOPENSSL_free(frag);\n\t\tpitem_free(item);\n\t\t}\n\t}", "target": 1}
{"code": "struct qmp *qmp_get(struct device *dev)\n{\n\tstruct platform_device *pdev;\n\tstruct device_node *np;\n\tstruct qmp *qmp;\n\tif (!dev || !dev->of_node)\n\t\treturn ERR_PTR(-EINVAL);\n\tnp = of_parse_phandle(dev->of_node, \"qcom,qmp\", 0);\n\tif (!np)\n\t\treturn ERR_PTR(-ENODEV);\n\tpdev = of_find_device_by_node(np);\n\tof_node_put(np);\n\tif (!pdev)\n\t\treturn ERR_PTR(-EINVAL);\n\tqmp = platform_get_drvdata(pdev);\n\treturn qmp ? qmp : ERR_PTR(-EPROBE_DEFER);\n}", "target": 1}
{"code": "static void destroy_super(struct super_block *s)\n{\n\tint i;\n\tlist_lru_destroy(&s->s_dentry_lru);\n\tlist_lru_destroy(&s->s_inode_lru);\n#ifdef CONFIG_SMP\n\tfree_percpu(s->s_files);\n#endif\n\tfor (i = 0; i < SB_FREEZE_LEVELS; i++)\n\t\tpercpu_counter_destroy(&s->s_writers.counter[i]);\n\tsecurity_sb_free(s);\n\tWARN_ON(!list_empty(&s->s_mounts));\n\tkfree(s->s_subtype);\n\tkfree(s->s_options);\n\tkfree_rcu(s, rcu);\n}", "target": 1}
{"code": "void dwc3_gadget_giveback(struct dwc3_ep *dep, struct dwc3_request *req,\n\t\tint status)\n{\n\tstruct dwc3\t\t\t*dwc = dep->dwc;\n\treq->started = false;\n\tlist_del(&req->list);\n\treq->remaining = 0;\n\tif (req->request.status == -EINPROGRESS)\n\t\treq->request.status = status;\n\tif (req->trb)\n\t\tusb_gadget_unmap_request_by_dev(dwc->sysdev,\n\t\t\t\t\t\t&req->request, req->direction);\n\treq->trb = NULL;\n\ttrace_dwc3_gadget_giveback(req);\n\tspin_unlock(&dwc->lock);\n\tusb_gadget_giveback_request(&dep->endpoint, &req->request);\n\tspin_lock(&dwc->lock);\n\tif (dep->number > 1)\n\t\tpm_runtime_put(dwc->dev);\n}", "target": 1}
{"code": "static gboolean prplcb_xfer_new_send_cb(gpointer data, gint fd, b_input_condition cond)\n{\n\tPurpleXfer *xfer = data;\n\tstruct im_connection *ic = purple_ic_by_pa(xfer->account);\n\tstruct prpl_xfer_data *px = xfer->ui_data;\n\tPurpleBuddy *buddy;\n\tconst char *who;\n\tbuddy = purple_find_buddy(xfer->account, xfer->who);\n\twho = buddy ? purple_buddy_get_name(buddy) : xfer->who;\n\tpx->ft = imcb_file_send_start(ic, (char *) who, xfer->filename, xfer->size);\n\tif (!px->ft) {\n\t\treturn FALSE;\n\t}\n\tpx->ft->data = px;\n\tpx->ft->accept = prpl_xfer_accept;\n\tpx->ft->canceled = prpl_xfer_canceled;\n\tpx->ft->free = prpl_xfer_free;\n\tpx->ft->write_request = prpl_xfer_write_request;\n\treturn FALSE;\n}", "target": 0}
{"code": "static void stellaris_enet_class_init(ObjectClass *klass, void *data)\n{\n    DeviceClass *dc = DEVICE_CLASS(klass);\n    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);\n    k->init = stellaris_enet_init;\n    dc->unrealize = stellaris_enet_unrealize;\n    dc->props = stellaris_enet_properties;\n    dc->vmsd = &vmstate_stellaris_enet;\n}", "target": 0}
{"code": "resolve_op_from_commit (FlatpakTransaction *self,\n                        FlatpakTransactionOperation *op,\n                        const char *checksum,\n                        GFile *sideload_path,\n                        GVariant *commit_data,\n                        GError **error)\n{\n  g_autoptr(GBytes) metadata_bytes = NULL;\n  g_autoptr(GVariant) commit_metadata = NULL;\n  const char *xa_metadata = NULL;\n  guint64 download_size = 0;\n  guint64 installed_size = 0;\n  commit_metadata = g_variant_get_child_value (commit_data, 0);\n  g_variant_lookup (commit_metadata, \"xa.metadata\", \"&s\", &xa_metadata);\n  if (xa_metadata == NULL)\n    return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA,\n                               \"No xa.metadata in local commit %s ref %s\",\n                               checksum, flatpak_decomposed_get_ref (op->ref));\n  metadata_bytes = g_bytes_new (xa_metadata, strlen (xa_metadata));\n  if (g_variant_lookup (commit_metadata, \"xa.download-size\", \"t\", &download_size))\n    op->download_size = GUINT64_FROM_BE (download_size);\n  if (g_variant_lookup (commit_metadata, \"xa.installed-size\", \"t\", &installed_size))\n    op->installed_size = GUINT64_FROM_BE (installed_size);\n  g_variant_lookup (commit_metadata, OSTREE_COMMIT_META_KEY_ENDOFLIFE, \"s\", &op->eol);\n  g_variant_lookup (commit_metadata, OSTREE_COMMIT_META_KEY_ENDOFLIFE_REBASE, \"s\", &op->eol_rebase);\n  return resolve_op_end (self, op, checksum, sideload_path, metadata_bytes, error);\n}", "target": 0}
{"code": "uint64 ReadCodedSizeValue(const binary * InBuffer, uint32 & BufferSize, uint64 & SizeUnknown)\n{\n  binary SizeBitMask = 1 << 7;\n  uint64 Result = 0x7F;\n  unsigned int SizeIdx, PossibleSizeLength = 0;\n  binary PossibleSize[8];\n  memset(PossibleSize, 0, 8);\n  SizeUnknown = 0x7F; \n  for (SizeIdx = 0; SizeIdx < BufferSize && SizeIdx < 8; SizeIdx++) {\n    if (InBuffer[0] & (SizeBitMask >> SizeIdx)) {\n      PossibleSizeLength = SizeIdx + 1;\n      SizeBitMask >>= SizeIdx;\n      if (PossibleSizeLength > BufferSize)\n        break;\n      for (SizeIdx = 0; SizeIdx < PossibleSizeLength; SizeIdx++) {\n        PossibleSize[SizeIdx] = InBuffer[SizeIdx];\n      }\n      for (SizeIdx = 0; SizeIdx < PossibleSizeLength - 1; SizeIdx++) {\n        Result <<= 7;\n        Result |= 0xFF;\n      }\n      Result = 0;\n      Result |= PossibleSize[0] & ~SizeBitMask;\n      for (unsigned int i = 1; i<PossibleSizeLength; i++) {\n        Result <<= 8;\n        Result |= PossibleSize[i];\n      }\n      BufferSize = PossibleSizeLength;\n      return Result;\n    }\n    SizeUnknown <<= 7;\n    SizeUnknown |= 0xFF;\n  }\n  BufferSize = 0;\n  return 0;\n}", "target": 0}
{"code": "int nntp_add_group(char *line, void *data)\n{\n  struct NntpServer *nserv = data;\n  struct NntpData *nntp_data = NULL;\n  char group[LONG_STRING];\n  char desc[HUGE_STRING] = \"\";\n  char mod;\n  anum_t first, last;\n  if (!nserv || !line)\n    return 0;\n  if (sscanf(line, \"%s \" ANUM \" \" ANUM \" %c %[^\\n]\", group, &last, &first, &mod, desc) < 4)\n    return 0;\n  nntp_data = nntp_data_find(nserv, group);\n  nntp_data->deleted = false;\n  nntp_data->first_message = first;\n  nntp_data->last_message = last;\n  nntp_data->allowed = (mod == 'y') || (mod == 'm');\n  mutt_str_replace(&nntp_data->desc, desc);\n  if (nntp_data->newsrc_ent || nntp_data->last_cached)\n    nntp_group_unread_stat(nntp_data);\n  else if (nntp_data->last_message && nntp_data->first_message <= nntp_data->last_message)\n    nntp_data->unread = nntp_data->last_message - nntp_data->first_message + 1;\n  else\n    nntp_data->unread = 0;\n  return 0;\n}", "target": 1}
{"code": "static struct fsnotify_group *inotify_new_group(struct user_struct *user, unsigned int max_events)\n{\n\tstruct fsnotify_group *group;\n\tgroup = fsnotify_alloc_group(&inotify_fsnotify_ops);\n\tif (IS_ERR(group))\n\t\treturn group;\n\tgroup->max_events = max_events;\n\tspin_lock_init(&group->inotify_data.idr_lock);\n\tidr_init(&group->inotify_data.idr);\n\tgroup->inotify_data.last_wd = 0;\n\tgroup->inotify_data.user = user;\n\tgroup->inotify_data.fa = NULL;\n\treturn group;\n}", "target": 1}
{"code": "int write_output(void)\n{\n   int fd;\n   struct filter_op *fop;\n   struct filter_header fh;\n   size_t ninst, i;\n   u_char *data;\n   ninst = compile_tree(&fop);\n   if (fop == NULL)\n      return -E_NOTHANDLED;\n   if (ninst == 0)\n      return -E_INVALID;\n   fd = open(EF_GBL_OPTIONS->output_file, O_CREAT | O_RDWR | O_TRUNC | O_BINARY, 0644);\n   ON_ERROR(fd, -1, \"Can't create file %s\", EF_GBL_OPTIONS->output_file);\n   fprintf(stdout, \" Writing output to \\'%s\\' \", EF_GBL_OPTIONS->output_file);\n   fflush(stdout);\n   fh.magic = htons(EC_FILTER_MAGIC);\n   strncpy(fh.version, EC_VERSION, sizeof(fh.version));\n   fh.data = sizeof(fh);\n   data = create_data_segment(&fh, fop, ninst);\n   write(fd, &fh, sizeof(struct filter_header));\n   write(fd, data, fh.code - fh.data);\n   for (i = 0; i <= ninst; i++) {\n      print_progress_bar(&fop[i]);\n      write(fd, &fop[i], sizeof(struct filter_op));\n   }\n   close(fd);\n   fprintf(stdout, \" done.\\n\\n\");\n   fprintf(stdout, \" -> Script encoded into %d instructions.\\n\\n\", (int)(i - 1));\n   return E_SUCCESS;\n}", "target": 0}
{"code": "static inline bool can_follow_write_pte(pte_t pte, unsigned int flags)\n{\n\treturn pte_write(pte) ||\n\t\t((flags & FOLL_FORCE) && (flags & FOLL_COW) && pte_dirty(pte));\n}", "target": 0}
{"code": "void ldapsrv_recv(struct stream_connection *c, uint16_t flags)\n{\n\tsmb_panic(__location__);\n}", "target": 0}
{"code": "static void do_sched_cfs_slack_timer(struct cfs_bandwidth *cfs_b)\n{\n\tu64 runtime = 0, slice = sched_cfs_bandwidth_slice();\n\tunsigned long flags;\n\tu64 expires;\n\traw_spin_lock_irqsave(&cfs_b->lock, flags);\n\tcfs_b->slack_started = false;\n\tif (cfs_b->distribute_running) {\n\t\traw_spin_unlock_irqrestore(&cfs_b->lock, flags);\n\t\treturn;\n\t}\n\tif (runtime_refresh_within(cfs_b, min_bandwidth_expiration)) {\n\t\traw_spin_unlock_irqrestore(&cfs_b->lock, flags);\n\t\treturn;\n\t}\n\tif (cfs_b->quota != RUNTIME_INF && cfs_b->runtime > slice)\n\t\truntime = cfs_b->runtime;\n\texpires = cfs_b->runtime_expires;\n\tif (runtime)\n\t\tcfs_b->distribute_running = 1;\n\traw_spin_unlock_irqrestore(&cfs_b->lock, flags);\n\tif (!runtime)\n\t\treturn;\n\truntime = distribute_cfs_runtime(cfs_b, runtime, expires);\n\traw_spin_lock_irqsave(&cfs_b->lock, flags);\n\tif (expires == cfs_b->runtime_expires)\n\t\tlsub_positive(&cfs_b->runtime, runtime);\n\tcfs_b->distribute_running = 0;\n\traw_spin_unlock_irqrestore(&cfs_b->lock, flags);\n}", "target": 1}
{"code": "fu_plugin_set_secure_config_value(FuPlugin *self,\n\t\t\t\t  const gchar *key,\n\t\t\t\t  const gchar *value,\n\t\t\t\t  GError **error)\n{\n\tg_autofree gchar *conf_path = fu_plugin_get_config_filename(self);\n\tgint ret;\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), FALSE);\n\tg_return_val_if_fail(error == NULL || *error == NULL, FALSE);\n\tif (!g_file_test(conf_path, G_FILE_TEST_EXISTS)) {\n\t\tg_set_error(error, FWUPD_ERROR, FWUPD_ERROR_NOT_FOUND, \"%s is missing\", conf_path);\n\t\treturn FALSE;\n\t}\n\tret = g_chmod(conf_path, 0660);\n\tif (ret == -1) {\n\t\tg_set_error(error,\n\t\t\t    FWUPD_ERROR,\n\t\t\t    FWUPD_ERROR_INTERNAL,\n\t\t\t    \"failed to set permissions on %s\",\n\t\t\t    conf_path);\n\t\treturn FALSE;\n\t}\n\treturn fu_plugin_set_config_value(self, key, value, error);\n}", "target": 1}
{"code": "void ecdsa_verify_prepare_legacy(ecdsa_verify_context_t *ctx, const ecc_int256_t *hash, const ecdsa_signature_t *signature) {\n  ecc_int256_t w, u1, tmp;\n  if (ecc_25519_gf_is_zero(&signature->s) || ecc_25519_gf_is_zero(&signature->r)) {\n    memset(&ctx->r, 0, sizeof(ctx->r));\n    return;\n  }\n  ctx->r = signature->r;\n  ecc_25519_gf_recip(&w, &signature->s);\n  ecc_25519_gf_reduce(&tmp, hash);\n  ecc_25519_gf_mult(&u1, &tmp, &w);\n  ecc_25519_gf_mult(&ctx->u2, &ctx->r, &w);\n  ecc_25519_scalarmult_base(&ctx->s1, &u1);\n}", "target": 0}
{"code": "vhost_scsi_make_tpg(struct se_wwn *wwn,\n\t\t   struct config_group *group,\n\t\t   const char *name)\n{\n\tstruct vhost_scsi_tport *tport = container_of(wwn,\n\t\t\tstruct vhost_scsi_tport, tport_wwn);\n\tstruct vhost_scsi_tpg *tpg;\n\tunsigned long tpgt;\n\tint ret;\n\tif (strstr(name, \"tpgt_\") != name)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (kstrtoul(name + 5, 10, &tpgt) || tpgt > UINT_MAX)\n\t\treturn ERR_PTR(-EINVAL);\n\ttpg = kzalloc(sizeof(struct vhost_scsi_tpg), GFP_KERNEL);\n\tif (!tpg) {\n\t\tpr_err(\"Unable to allocate struct vhost_scsi_tpg\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tmutex_init(&tpg->tv_tpg_mutex);\n\tINIT_LIST_HEAD(&tpg->tv_tpg_list);\n\ttpg->tport = tport;\n\ttpg->tport_tpgt = tpgt;\n\tret = core_tpg_register(&vhost_scsi_fabric_configfs->tf_ops, wwn,\n\t\t\t\t&tpg->se_tpg, tpg, TRANSPORT_TPG_TYPE_NORMAL);\n\tif (ret < 0) {\n\t\tkfree(tpg);\n\t\treturn NULL;\n\t}\n\tmutex_lock(&vhost_scsi_mutex);\n\tlist_add_tail(&tpg->tv_tpg_list, &vhost_scsi_list);\n\tmutex_unlock(&vhost_scsi_mutex);\n\treturn &tpg->se_tpg;\n}", "target": 1}
{"code": "PHPAPI int php_execute_simple_script(zend_file_handle *primary_file, zval *ret)\n{\n\tchar *old_cwd;\n\tALLOCA_FLAG(use_heap)\n\tEG(exit_status) = 0;\n#define OLD_CWD_SIZE 4096\n\told_cwd = do_alloca(OLD_CWD_SIZE, use_heap);\n\told_cwd[0] = '\\0';\n\tzend_try {\n#ifdef PHP_WIN32\n\t\tif(primary_file->filename) {\n\t\t\tUpdateIniFromRegistry((char*)primary_file->filename);\n\t\t}\n#endif\n\t\tPG(during_request_startup) = 0;\n\t\tif (primary_file->filename && !(SG(options) & SAPI_OPTION_NO_CHDIR)) {\n\t\t\tphp_ignore_value(VCWD_GETCWD(old_cwd, OLD_CWD_SIZE-1));\n\t\t\tVCWD_CHDIR_FILE(primary_file->filename);\n\t\t}\n\t\tzend_execute_scripts(ZEND_REQUIRE, ret, 1, primary_file);\n\t} zend_end_try();\n\tif (old_cwd[0] != '\\0') {\n\t\tphp_ignore_value(VCWD_CHDIR(old_cwd));\n\t}\n\tfree_alloca(old_cwd, use_heap);\n\treturn EG(exit_status);\n}", "target": 0}
{"code": "validate_event(struct pmu_hw_events *hw_events,\n\t       struct perf_event *event)\n{\n\tstruct arm_pmu *armpmu = to_arm_pmu(event->pmu);\n\tstruct pmu *leader_pmu = event->group_leader->pmu;\n\tif (is_software_event(event))\n\t\treturn 1;\n\tif (event->pmu != leader_pmu || event->state < PERF_EVENT_STATE_OFF)\n\t\treturn 1;\n\tif (event->state == PERF_EVENT_STATE_OFF && !event->attr.enable_on_exec)\n\t\treturn 1;\n\treturn armpmu->get_event_idx(hw_events, event) >= 0;\n}", "target": 0}
{"code": "cib_remote_dispatch(gpointer user_data)\n{\n    cib_t *cib = user_data;\n    cib_remote_opaque_t *private = cib->variant_opaque;\n    xmlNode *msg = NULL;\n    const char *type = NULL;\n    crm_info(\"Message on callback channel\");\n    msg = crm_recv_remote_msg(private->callback.session, private->callback.encrypted);\n    type = crm_element_value(msg, F_TYPE);\n    crm_trace(\"Activating %s callbacks...\", type);\n    if (safe_str_eq(type, T_CIB)) {\n        cib_native_callback(cib, msg, 0, 0);\n    } else if (safe_str_eq(type, T_CIB_NOTIFY)) {\n        g_list_foreach(cib->notify_list, cib_native_notify, msg);\n    } else {\n        crm_err(\"Unknown message type: %s\", type);\n    }\n    if (msg != NULL) {\n        free_xml(msg);\n        return 0;\n    }\n    return -1;\n}", "target": 1}
{"code": "static std::string WC2MB(const std::wstring& input, unsigned int code_page) {\n  if (input.empty()) {\n    return \"\";\n  }\n  DWORD flags = 0;\n  if (code_page != 65001 && code_page != 54936) {\n    flags = WC_NO_BEST_FIT_CHARS | WC_COMPOSITECHECK | WC_DEFAULTCHAR;\n  }\n  int length = ::WideCharToMultiByte(code_page, flags, &input[0],\n                                     static_cast<int>(input.size()), NULL, 0,\n                                     NULL, NULL);\n  std::string output(length, '\\0');\n  ::WideCharToMultiByte(code_page, flags, &input[0],\n                        static_cast<int>(input.size()), &output[0],\n                        static_cast<int>(output.size()), NULL, NULL);\n  return output;\n}", "target": 0}
{"code": "isofs_export_encode_fh(struct inode *inode,\n\t\t       __u32 *fh32,\n\t\t       int *max_len,\n\t\t       struct inode *parent)\n{\n\tstruct iso_inode_info * ei = ISOFS_I(inode);\n\tint len = *max_len;\n\tint type = 1;\n\t__u16 *fh16 = (__u16*)fh32;\n\tif (parent && (len < 5)) {\n\t\t*max_len = 5;\n\t\treturn 255;\n\t} else if (len < 3) {\n\t\t*max_len = 3;\n\t\treturn 255;\n\t}\n\tlen = 3;\n\tfh32[0] = ei->i_iget5_block;\n \tfh16[2] = (__u16)ei->i_iget5_offset;  \n\tfh16[3] = 0;  \n\tfh32[2] = inode->i_generation;\n\tif (parent) {\n\t\tstruct iso_inode_info *eparent;\n\t\teparent = ISOFS_I(parent);\n\t\tfh32[3] = eparent->i_iget5_block;\n\t\tfh16[3] = (__u16)eparent->i_iget5_offset;  \n\t\tfh32[4] = parent->i_generation;\n\t\tlen = 5;\n\t\ttype = 2;\n\t}\n\t*max_len = len;\n\treturn type;\n}", "target": 0}
{"code": "char *url_canonize2(char *d, char const * const s, size_t n,\n\t\t    unsigned syn33,\n\t\t    unsigned m32, unsigned m64, unsigned m96)\n{\n  size_t i = 0;\n  if (d == s)\n    for (;s[i] && i < n; d++, i++)\n      if (s[i] == '%')\n\tbreak;\n  for (;s[i] && i < n; d++, i++) {\n    unsigned char c = s[i], h1, h2;\n    if (c != '%') {\n      if (!IS_SYN33(syn33, c) && IS_EXCLUDED(c, m32, m64, m96))\n\treturn NULL;\n      *d = c;\n      continue;\n    }\n    h1 = s[i + 1];\n    if (!h1) {\n        *d = '\\0';\n        return NULL;\n    }\n    h2 = s[i + 2];\n    if (!IS_HEX(h1) || !IS_HEX(h2)) {\n      *d = '\\0';\n      return NULL;\n    }\n#define UNHEX(a) (a - (a >= 'a' ? 'a' - 10 : (a >= 'A' ? 'A' - 10 : '0')))\n    c = (UNHEX(h1) << 4) | UNHEX(h2);\n    if (!IS_EXCLUDED(c, m32, m64, m96)) {\n      *d = c, i += 2;\n      continue;\n    }\n    if (h1 >= 'a' )\n      h1 = h1 - 'a' + 'A';\n    if (h2 >= 'a' )\n      h2 = h2 - 'a' + 'A';\n    d[0] = '%', d[1] = h1, d[2] = h2;\n    d +=2, i += 2;\n#undef    UNHEX\n  }\n  *d = '\\0';\n  return d;\n}", "target": 0}
{"code": "static void destroy_compound_gigantic_page(struct page *page,\n\t\t\t\t\tunsigned int order)\n{\n\t__destroy_compound_gigantic_page(page, order, false);\n}", "target": 0}
{"code": "_dl_dst_count (const char *name, int is_path)\n{\n  size_t cnt = 0;\n  do\n    {\n      size_t len = 1;\n      if ((((!__libc_enable_secure\n\t     && strncmp (&name[1], \"ORIGIN\", 6) == 0 && (len = 7) != 0)\n\t    || (strncmp (&name[1], \"PLATFORM\", 8) == 0 && (len = 9) != 0))\n\t   && (name[len] == '\\0' || name[len] == '/'\n\t       || (is_path && name[len] == ':')))\n\t  || (name[1] == '{'\n\t      && ((!__libc_enable_secure\n\t\t   && strncmp (&name[2], \"ORIGIN}\", 7) == 0 && (len = 9) != 0)\n\t\t  || (strncmp (&name[2], \"PLATFORM}\", 9) == 0\n\t\t      && (len = 11) != 0))))\n\t++cnt;\n      name = strchr (name + len, '$');\n    }\n  while (name != NULL);\n  return cnt;\n}", "target": 1}
{"code": "static bool set_reg_profile(RAnal *anal) {\n\tconst char *p =\n\t\t\"=PC\tpc\\n\"\n\t\t\"=SP\tr14\\n\" \n\t\t\"=BP\tsrp\\n\" \n\t\t\"=SN\tr0\\n\"\n\t\t\"=A0\tr0\\n\"\n\t\t\"=A1\tr1\\n\"\n\t\t\"=A2\tr2\\n\"\n\t\t\"=A3\tr3\\n\"\n\t\t\"gpr\tsp\t.32\t56\t0\\n\" \n\t\t\"gpr\tacr\t.32\t60\t0\\n\" \n\t\t\"gpr\tpc\t.32\t64\t0\\n\" \n\t\t\"gpr\tsrp\t.32\t68\t0\\n\" \n\t\t\"gpr\tr0\t.32\t0\t0\\n\"\n\t\t\"gpr\tr1\t.32\t4\t0\\n\"\n\t\t\"gpr\tr2\t.32\t8\t0\\n\"\n\t\t\"gpr\tr3\t.32\t12\t0\\n\"\n\t\t\"gpr\tr4\t.32\t16\t0\\n\"\n\t\t\"gpr\tr5\t.32\t20\t0\\n\"\n\t\t\"gpr\tr6\t.32\t24\t0\\n\"\n\t\t\"gpr\tr7\t.32\t28\t0\\n\"\n\t\t\"gpr\tr8\t.32\t32\t0\\n\"\n\t\t\"gpr\tr9\t.32\t36\t0\\n\"\n\t\t\"gpr\tr10\t.32\t40\t0\\n\"\n\t\t\"gpr\tr11\t.32\t44\t0\\n\"\n\t\t\"gpr\tr12\t.32\t48\t0\\n\"\n\t\t\"gpr\tr13\t.32\t52\t0\\n\"\n\t\t\"gpr\tr14\t.32\t56\t0\\n\"\n\t\t\"gpr\tr15\t.32\t60\t0\\n\"\n\t\t;\n\treturn r_reg_set_profile_string (anal->reg, p);\n}", "target": 0}
{"code": "void fx_DataView(txMachine* the)\n{\n\ttxSlot* slot;\n\ttxBoolean flag = 0;\n\ttxInteger offset, size;\n\ttxSlot* info;\n\ttxSlot* instance;\n\ttxSlot* view;\n\ttxSlot* buffer;\n\tif (mxIsUndefined(mxTarget))\n\t\tmxTypeError(\"call: DataView\");\n\tif ((mxArgc > 0) && (mxArgv(0)->kind == XS_REFERENCE_KIND)) {\n\t\tslot = mxArgv(0)->value.reference->next;\n\t\tif (slot && ((slot->kind == XS_ARRAY_BUFFER_KIND) || (slot->kind == XS_HOST_KIND))) {\n\t\t\tflag = 1;\n\t\t}\n\t}\n\tif (!flag)\n\t\tmxTypeError(\"buffer is no ArrayBuffer instance\");\n\toffset = fxArgToByteLength(the, 1, 0);\n\tinfo = fxGetBufferInfo(the, mxArgv(0));\n\tif (info->value.bufferInfo.length < offset)\n\t\tmxRangeError(\"out of range byteOffset %ld\", offset);\n\tsize = fxArgToByteLength(the, 2, -1);\n\tif (size >= 0) {\n\t\tif (info->value.bufferInfo.length < (offset + size))\n\t\t\tmxRangeError(\"out of range byteLength %ld\", size);\n\t}\n\telse {\n\t\tif (info->value.bufferInfo.maxLength < 0)\n\t\t\tsize = info->value.bufferInfo.length - offset;\n\t}\n\tmxPushSlot(mxTarget);\n\tfxGetPrototypeFromConstructor(the, &mxDataViewPrototype);\n\tinstance = fxNewDataViewInstance(the);\n\tmxPullSlot(mxResult);\n\tview = instance->next;\n\tbuffer = view->next;\n\tbuffer->kind = XS_REFERENCE_KIND;\n\tbuffer->value.reference = mxArgv(0)->value.reference;\n\tinfo = fxGetBufferInfo(the, buffer);\n\tif (info->value.bufferInfo.maxLength >= 0) {\n\t\tif (info->value.bufferInfo.length < offset)\n\t\t\tmxRangeError(\"out of range byteOffset %ld\", offset);\n\t\telse if (size >= 0) {\n\t\t\tif (info->value.bufferInfo.length < (offset + size))\n\t\t\t\tmxRangeError(\"out of range byteLength %ld\", size);\n\t\t}\n\t}\n\tview->value.dataView.offset = offset;\n\tview->value.dataView.size = size;\n}", "target": 1}
{"code": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tfile_sb_list_del(file);\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}", "target": 1}
{"code": "void ZlibInStream::removeUnderlying()\n{\n  ptr = end = start;\n  if (!underlying) return;\n  while (bytesIn > 0) {\n    decompress(true);\n    end = start; \n  }\n  underlying = 0;\n}", "target": 1}
{"code": "static inline int check_entry_size_and_hooks(struct arpt_entry *e,\n\t\t\t\t\t     struct xt_table_info *newinfo,\n\t\t\t\t\t     const unsigned char *base,\n\t\t\t\t\t     const unsigned char *limit,\n\t\t\t\t\t     const unsigned int *hook_entries,\n\t\t\t\t\t     const unsigned int *underflows,\n\t\t\t\t\t     unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct arpt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\tif (!arp_checkentry(&e->arp))\n\t\treturn -EINVAL;\n\terr = xt_check_entry_offsets(e, e->target_offset, e->next_offset);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 1}
{"code": "compute_U_value_R3(std::string const& user_password,\n\t\t   QPDF::EncryptionData const& data)\n{\n    std::string k1 = QPDF::compute_encryption_key(user_password, data);\n    MD5 md5;\n    md5.encodeDataIncrementally(\n\tpad_or_truncate_password_V4(\"\").c_str(), key_bytes);\n    md5.encodeDataIncrementally(data.getId1().c_str(),\n                                data.getId1().length());\n    MD5::Digest digest;\n    md5.digest(digest);\n    pad_short_parameter(k1, data.getLengthBytes());\n    iterate_rc4(digest, sizeof(MD5::Digest),\n\t\tQUtil::unsigned_char_pointer(k1),\n                data.getLengthBytes(), 20, false);\n    char result[key_bytes];\n    memcpy(result, digest, sizeof(MD5::Digest));\n    for (unsigned int i = sizeof(MD5::Digest); i < key_bytes; ++i)\n    {\n\tresult[i] = static_cast<char>((i * i) % 0xff);\n    }\n    return std::string(result, key_bytes);\n}", "target": 0}
{"code": "static void update_db_bp_intercept(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tclr_exception_intercept(svm, DB_VECTOR);\n\tclr_exception_intercept(svm, BP_VECTOR);\n\tif (svm->nmi_singlestep)\n\t\tset_exception_intercept(svm, DB_VECTOR);\n\tif (vcpu->guest_debug & KVM_GUESTDBG_ENABLE) {\n\t\tif (vcpu->guest_debug &\n\t\t    (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))\n\t\t\tset_exception_intercept(svm, DB_VECTOR);\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)\n\t\t\tset_exception_intercept(svm, BP_VECTOR);\n\t} else\n\t\tvcpu->guest_debug = 0;\n}", "target": 1}
{"code": "SMB2_sess_establish_session(struct SMB2_sess_data *sess_data)\n{\n\tint rc = 0;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tmutex_lock(&ses->server->srv_mutex);\n\tif (ses->server->sign && ses->server->ops->generate_signingkey) {\n\t\trc = ses->server->ops->generate_signingkey(ses);\n\t\tkfree(ses->auth_key.response);\n\t\tses->auth_key.response = NULL;\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI,\n\t\t\t\t\"SMB3 session key generation failed\\n\");\n\t\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t\tgoto keygen_exit;\n\t\t}\n\t}\n\tif (!ses->server->session_estab) {\n\t\tses->server->sequence_number = 0x2;\n\t\tses->server->session_estab = true;\n\t}\n\tmutex_unlock(&ses->server->srv_mutex);\n\tcifs_dbg(FYI, \"SMB2/3 session established successfully\\n\");\n\tspin_lock(&GlobalMid_Lock);\n\tses->status = CifsGood;\n\tses->need_reconnect = false;\n\tspin_unlock(&GlobalMid_Lock);\nkeygen_exit:\n\tif (!ses->server->sign) {\n\t\tkfree(ses->auth_key.response);\n\t\tses->auth_key.response = NULL;\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "static void svm_write_tsc_offset(struct kvm_vcpu *vcpu, u64 offset)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu64 g_tsc_offset = 0;\n\tif (is_guest_mode(vcpu)) {\n\t\tg_tsc_offset = svm->vmcb->control.tsc_offset -\n\t\t\t       svm->nested.hsave->control.tsc_offset;\n\t\tsvm->nested.hsave->control.tsc_offset = offset;\n\t} else\n\t\ttrace_kvm_write_tsc_offset(vcpu->vcpu_id,\n\t\t\t\t\t   svm->vmcb->control.tsc_offset,\n\t\t\t\t\t   offset);\n\tsvm->vmcb->control.tsc_offset = offset + g_tsc_offset;\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n}", "target": 0}
{"code": "psf_fwrite (const void *ptr, sf_count_t bytes, sf_count_t items, SF_PRIVATE *psf)\n{\tsf_count_t total = 0 ;\n\tssize_t\tcount ;\n\tif (bytes == 0 || items == 0)\n\t\treturn 0 ;\n\tif (psf->virtual_io)\n\t\treturn psf->vio.write (ptr, bytes*items, psf->vio_user_data) / bytes ;\n\titems *= bytes ;\n\tif (items <= 0)\n\t\treturn 0 ;\n\twhile (items > 0)\n\t{\t\n\t\tcount = (items > SENSIBLE_SIZE) ? SENSIBLE_SIZE : items ;\n\t\tcount = write (psf->file.filedes, ((const char*) ptr) + total, count) ;\n\t\tif (count == -1)\n\t\t{\tif (errno == EINTR)\n\t\t\t\tcontinue ;\n\t\t\tpsf_log_syserr (psf, errno) ;\n\t\t\tbreak ;\n\t\t\t} ;\n\t\tif (count == 0)\n\t\t\tbreak ;\n\t\ttotal += count ;\n\t\titems -= count ;\n\t\t} ;\n\tif (psf->is_pipe)\n\t\tpsf->pipeoffset += total ;\n\treturn total / bytes ;\n} ", "target": 0}
{"code": "BZIP3_API struct bz3_state * bz3_new(s32 block_size) {\n    if (block_size < KiB(65) || block_size > MiB(511)) {\n        return NULL;\n    }\n    struct bz3_state * bz3_state = malloc(sizeof(struct bz3_state));\n    if (!bz3_state) {\n        return NULL;\n    }\n    bz3_state->cm_state = malloc(sizeof(state));\n    bz3_state->swap_buffer = malloc(bz3_bound(block_size));\n    bz3_state->sais_array = malloc((block_size + 128) * sizeof(s32));\n    memset(bz3_state->sais_array, 0, sizeof(s32) * (block_size + 128));\n    bz3_state->lzp_lut = calloc(1 << LZP_DICTIONARY, sizeof(s32));\n    if (!bz3_state->cm_state || !bz3_state->swap_buffer || !bz3_state->sais_array || !bz3_state->lzp_lut) {\n        if (bz3_state->cm_state) free(bz3_state->cm_state);\n        if (bz3_state->swap_buffer) free(bz3_state->swap_buffer);\n        if (bz3_state->sais_array) free(bz3_state->sais_array);\n        if (bz3_state->lzp_lut) free(bz3_state->lzp_lut);\n        free(bz3_state);\n        return NULL;\n    }\n    bz3_state->block_size = block_size;\n    bz3_state->last_error = BZ3_OK;\n    return bz3_state;\n}", "target": 1}
{"code": "exit_sg(void)\n{\n#ifdef CONFIG_SCSI_PROC_FS\n\tremove_proc_subtree(\"scsi/sg\", NULL);\n#endif\t\t\t\t\n\tscsi_unregister_interface(&sg_interface);\n\tclass_destroy(sg_sysfs_class);\n\tsg_sysfs_valid = 0;\n\tunregister_chrdev_region(MKDEV(SCSI_GENERIC_MAJOR, 0),\n\t\t\t\t SG_MAX_DEVS);\n\tidr_destroy(&sg_index_idr);\n}", "target": 0}
{"code": "static inline struct sk_buff *skb_share_check(struct sk_buff *skb, gfp_t pri)\n{\n\tmight_sleep_if(pri & __GFP_WAIT);\n\tif (skb_shared(skb)) {\n\t\tstruct sk_buff *nskb = skb_clone(skb, pri);\n\t\tif (likely(nskb))\n\t\t\tconsume_skb(skb);\n\t\telse\n\t\t\tkfree_skb(skb);\n\t\tskb = nskb;\n\t}\n\treturn skb;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) final {\n    const Tensor& superdiag = context->input(0);\n    const Tensor& maindiag = context->input(1);\n    const Tensor& subdiag = context->input(2);\n    const Tensor& rhs = context->input(3);\n    const int ndims = rhs.dims();\n    OP_REQUIRES(\n        context, ndims >= 2,\n        errors::InvalidArgument(\"Input must have rank >= 2, but got \", ndims));\n    OP_REQUIRES_OK(context, ValidateInputTensor(superdiag, \"superdiag\", rhs));\n    OP_REQUIRES_OK(context, ValidateInputTensor(maindiag, \"maindiag\", rhs));\n    OP_REQUIRES_OK(context, ValidateInputTensor(subdiag, \"subdiag\", rhs));\n    int64 batch_size = 1;\n    for (int i = 0; i < ndims - 2; i++) {\n      batch_size *= rhs.dim_size(i);\n    }\n    const int m = rhs.dim_size(ndims - 2);\n    const int n = rhs.dim_size(ndims - 1);\n    Tensor* output;\n    OP_REQUIRES_OK(context, context->allocate_output(0, rhs.shape(), &output));\n    const Eigen::GpuDevice& device = context->eigen_device<Eigen::GpuDevice>();\n    GpuLaunchConfig cfg = GetGpuLaunchConfig(1, device);\n    TF_CHECK_OK(GpuLaunchKernel(\n        TridiagonalMatMulKernel<Scalar>, cfg.block_count, cfg.thread_per_block,\n        0, device.stream(), batch_size, m, n, superdiag.flat<Scalar>().data(),\n        maindiag.flat<Scalar>().data(), subdiag.flat<Scalar>().data(),\n        rhs.flat<Scalar>().data(), output->flat<Scalar>().data()));\n  }", "target": 0}
{"code": "BGD_DECLARE(void) gdImageWBMPCtx(gdImagePtr image, int fg, gdIOCtx *out)\n{\n\tint x, y, pos;\n\tWbmp *wbmp;\n\tif((wbmp = createwbmp(gdImageSX(image), gdImageSY(image), WBMP_WHITE)) == NULL) {\n\t\tgd_error(\"Could not create WBMP\\n\");\n\t\treturn;\n\t}\n\tpos = 0;\n\tfor(y = 0; y < gdImageSY(image); y++) {\n\t\tfor(x = 0; x < gdImageSX(image); x++) {\n\t\t\tif(gdImageGetPixel(image, x, y) == fg) {\n\t\t\t\twbmp->bitmap[pos] = WBMP_BLACK;\n\t\t\t}\n\t\t\tpos++;\n\t\t}\n\t}\n\tif(writewbmp(wbmp, &gd_putout, out)) {\n\t\tgd_error(\"Could not save WBMP\\n\");\n\t}\n\tfreewbmp(wbmp);\n}", "target": 1}
{"code": "gerb_fopen(char const * filename)\n{\n    gerb_file_t *fd;\n    struct stat statinfo;\n    dprintf(\"---> Entering gerb_fopen, filename = %s\\n\", filename);\n    fd = g_new(gerb_file_t, 1);\n    if (fd == NULL) {\n\treturn NULL;\n    }\n    dprintf(\"     Doing fopen\\n\");\n    fd->fd = g_fopen(filename, \"rb\");\n    if (fd->fd == NULL) {\n\tg_free(fd);\n\treturn NULL;\n    }\n    dprintf(\"     Doing fstat\\n\");\n    fd->ptr = 0;\n    fd->fileno = fileno(fd->fd);\n    if (fstat(fd->fileno, &statinfo) < 0) {\n\tfclose(fd->fd);\n\tg_free(fd);\n\treturn NULL;\n    }\n    dprintf(\"     Checking S_ISREG\\n\");\n    if (!S_ISREG(statinfo.st_mode)) {\n\tfclose(fd->fd);\n\tg_free(fd);\n\terrno = EISDIR;\n\treturn NULL;\n    }\n    dprintf(\"     Checking statinfo.st_size\\n\");\n    if ((int)statinfo.st_size == 0) {\n\tfclose(fd->fd);\n\tg_free(fd);\n\terrno = EIO; \n\treturn NULL;\n    }\n#ifdef HAVE_SYS_MMAN_H\n    dprintf(\"     Doing mmap\\n\");\n    fd->datalen = (int)statinfo.st_size;\n    fd->data = (char *)mmap(0, statinfo.st_size, PROT_READ, MAP_PRIVATE, \n\t\t\t    fd->fileno, 0);\n    if(fd->data == MAP_FAILED) {\n\tfclose(fd->fd);\n\tg_free(fd);\n\tfd = NULL;\n    }\n#else\n    dprintf(\"     Doing calloc\\n\");\n    fd->datalen = (int)statinfo.st_size;\n    fd->data = calloc(1, statinfo.st_size + 1);\n    if (fd->data == NULL) {\n        fclose(fd->fd);\n        g_free(fd);\n        return NULL;\n    }\n    if (fread((void*)fd->data, 1, statinfo.st_size, fd->fd) != statinfo.st_size) {\n        fclose(fd->fd);\n\tg_free(fd->data);\n        g_free(fd);\n\treturn NULL;\n    }\n    rewind (fd->fd);\n#endif\n    dprintf(\"     Setting filename\\n\");\n    fd->filename = g_strdup(filename);\n    dprintf(\"<--- Leaving gerb_fopen\\n\");\n    return fd;\n} ", "target": 0}
{"code": "static int netbk_set_skb_gso(struct xenvif *vif,\n\t\t\t     struct sk_buff *skb,\n\t\t\t     struct xen_netif_extra_info *gso)\n{\n\tif (!gso->u.gso.size) {\n\t\tnetdev_dbg(vif->dev, \"GSO size must not be zero.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (gso->u.gso.type != XEN_NETIF_GSO_TYPE_TCPV4) {\n\t\tnetdev_dbg(vif->dev, \"Bad GSO type %d.\\n\", gso->u.gso.type);\n\t\treturn -EINVAL;\n\t}\n\tskb_shinfo(skb)->gso_size = gso->u.gso.size;\n\tskb_shinfo(skb)->gso_type = SKB_GSO_TCPV4;\n\tskb_shinfo(skb)->gso_type |= SKB_GSO_DODGY;\n\tskb_shinfo(skb)->gso_segs = 0;\n\treturn 0;\n}", "target": 1}
{"code": "static int udp_push_pending_frames(struct sock *sk)\n{\n\tstruct udp_sock  *up = udp_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct flowi4 *fl4 = &inet->cork.fl.u.ip4;\n\tstruct sk_buff *skb;\n\tint err = 0;\n\tskb = ip_finish_skb(sk, fl4);\n\tif (!skb)\n\t\tgoto out;\n\terr = udp_send_skb(skb, fl4);\nout:\n\tup->len = 0;\n\tup->pending = 0;\n\treturn err;\n}", "target": 1}
{"code": "static const struct usb_cdc_union_desc *\nims_pcu_get_cdc_union_desc(struct usb_interface *intf)\n{\n\tconst void *buf = intf->altsetting->extra;\n\tsize_t buflen = intf->altsetting->extralen;\n\tstruct usb_cdc_union_desc *union_desc;\n\tif (!buf) {\n\t\tdev_err(&intf->dev, \"Missing descriptor data\\n\");\n\t\treturn NULL;\n\t}\n\tif (!buflen) {\n\t\tdev_err(&intf->dev, \"Zero length descriptor\\n\");\n\t\treturn NULL;\n\t}\n\twhile (buflen > 0) {\n\t\tunion_desc = (struct usb_cdc_union_desc *)buf;\n\t\tif (union_desc->bDescriptorType == USB_DT_CS_INTERFACE &&\n\t\t    union_desc->bDescriptorSubType == USB_CDC_UNION_TYPE) {\n\t\t\tdev_dbg(&intf->dev, \"Found union header\\n\");\n\t\t\treturn union_desc;\n\t\t}\n\t\tbuflen -= union_desc->bLength;\n\t\tbuf += union_desc->bLength;\n\t}\n\tdev_err(&intf->dev, \"Missing CDC union descriptor\\n\");\n\treturn NULL;", "target": 1}
{"code": "NAN_METHOD(DetectCharacterEncoding) {\n\tNan::HandleScope scope;\n\tv8::Local<v8::Object> inputBuffer = info[0]->ToObject();\n\tUCharsetDetector *charsetDetector;\n\tconst UCharsetMatch *charsetMatch;\n\tUErrorCode errorCode = U_ZERO_ERROR;\n\tcharsetDetector = ucsdet_open(&errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to open ICU charset detector.\");\n\t\treturn;\n\t}\n\tucsdet_setText(\n\t\tcharsetDetector,\n\t\tnode::Buffer::Data(inputBuffer),\n\t\tnode::Buffer::Length(inputBuffer),\n\t\t&errorCode\n\t);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to set ICU charset detectors text.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tcharsetMatch = ucsdet_detect(charsetDetector, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to detect charset.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tconst char *charsetName = ucsdet_getName(charsetMatch, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get name from charset match.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tint32_t confidence = ucsdet_getConfidence(charsetMatch, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get confidence from charset match.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tv8::Local<v8::Object> obj = Nan::New<v8::Object>();\n\tobj->Set(Nan::New<v8::String>(\"encoding\").ToLocalChecked(), Nan::New<v8::String>(charsetName).ToLocalChecked());\n\tobj->Set(Nan::New<v8::String>(\"confidence\").ToLocalChecked(), Nan::New<v8::Number>(confidence));\n\tinfo.GetReturnValue().Set(obj);\n\tucsdet_close(charsetDetector);\n}", "target": 0}
{"code": "Status genTableRowsForSqliteTable(const fs::path& sqlite_db,\n                                  const std::string& sqlite_query,\n                                  TableRows& results,\n                                  bool respect_locking) {\n  sqlite3* db = nullptr;\n  if (!pathExists(sqlite_db).ok()) {\n    return Status(1, \"Database path does not exist\");\n  }\n  auto rc = sqlite3_open_v2(\n      sqlite_db.string().c_str(),\n      &db,\n      (SQLITE_OPEN_READONLY | SQLITE_OPEN_PRIVATECACHE | SQLITE_OPEN_NOMUTEX),\n      getSystemVFS(respect_locking));\n  if (rc != SQLITE_OK || db == nullptr) {\n    VLOG(1) << \"Cannot open specified database: \"\n            << getStringForSQLiteReturnCode(rc);\n    if (db != nullptr) {\n      sqlite3_close(db);\n    }\n    return Status(1, \"Could not open database\");\n  }\n  rc = sqlite3_set_authorizer(db, &sqliteAuthorizer, nullptr);\n  if (rc != SQLITE_OK) {\n    sqlite3_close(db);\n    auto errMsg =\n        std::string(\"Failed to set sqlite authorizer: \") + sqlite3_errmsg(db);\n    return Status(1, errMsg);\n  }\n  sqlite3_stmt* stmt = nullptr;\n  rc = sqlite3_prepare_v2(db, sqlite_query.c_str(), -1, &stmt, nullptr);\n  if (rc != SQLITE_OK) {\n    sqlite3_close(db);\n    VLOG(1) << \"ATC table: Could not prepare database at path: \" << sqlite_db;\n    return Status(rc, \"Could not prepare database\");\n  }\n  while ((sqlite3_step(stmt)) == SQLITE_ROW) {\n    auto s = genSqliteTableRow(stmt, results, sqlite_db);\n    if (!s.ok()) {\n      break;\n    }\n  }\n  sqlite3_finalize(stmt);\n  sqlite3_close(db);\n  return Status{};\n}", "target": 0}
{"code": "static inline void write_s3row_data(\n\tconst entity_stage3_row *r,\n\tunsigned orig_cp,\n\tenum entity_charset charset,\n\tzval *arr)\n{\n\tchar key[9] = \"\"; \n\tchar entity[LONGEST_ENTITY_LENGTH + 2] = {'&'};\n\tsize_t written_k1;\n\twritten_k1 = write_octet_sequence(key, charset, orig_cp);\n\tif (!r->ambiguous) {\n\t\tsize_t l = r->data.ent.entity_len;\n\t\tmemcpy(&entity[1], r->data.ent.entity, l);\n\t\tentity[l + 1] = ';';\n\t\tadd_assoc_stringl_ex(arr, key, written_k1 + 1, entity, l + 2, 1);\n\t} else {\n\t\tunsigned i,\n\t\t\t     num_entries;\n\t\tconst entity_multicodepoint_row *mcpr = r->data.multicodepoint_table;\n\t\tif (mcpr[0].leading_entry.default_entity != NULL) {\n\t\t\tsize_t l = mcpr[0].leading_entry.default_entity_len;\n\t\t\tmemcpy(&entity[1], mcpr[0].leading_entry.default_entity, l);\n\t\t\tentity[l + 1] = ';';\n\t\t\tadd_assoc_stringl_ex(arr, key, written_k1 + 1, entity, l + 2, 1);\n\t\t}\n\t\tnum_entries = mcpr[0].leading_entry.size;\n\t\tfor (i = 1; i <= num_entries; i++) {\n\t\t\tsize_t   l,\n\t\t\t\t     written_k2;\n\t\t\tunsigned uni_cp,\n\t\t\t\t\t spe_cp;\n\t\t\tuni_cp = mcpr[i].normal_entry.second_cp;\n\t\t\tl = mcpr[i].normal_entry.entity_len;\n\t\t\tif (!CHARSET_UNICODE_COMPAT(charset)) {\n\t\t\t\tif (map_from_unicode(uni_cp, charset, &spe_cp) == FAILURE)\n\t\t\t\t\tcontinue; \n\t\t\t} else {\n\t\t\t\tspe_cp = uni_cp;\n\t\t\t}\n\t\t\twritten_k2 = write_octet_sequence(&key[written_k1], charset, spe_cp);\n\t\t\tmemcpy(&entity[1], mcpr[i].normal_entry.entity, l);\n\t\t\tentity[l + 1] = ';';\n\t\t\tentity[l + 1] = '\\0';\n\t\t\tadd_assoc_stringl_ex(arr, key, written_k1 + written_k2 + 1, entity, l + 1, 1);\n\t\t}\n\t}\n}", "target": 1}
{"code": "void add_interrupt_randomness(int irq, int irq_flags)\n{\n\tstruct entropy_store\t*r;\n\tstruct fast_pool\t*fast_pool = this_cpu_ptr(&irq_randomness);\n\tstruct pt_regs\t\t*regs = get_irq_regs();\n\tunsigned long\t\tnow = jiffies;\n\tcycles_t\t\tcycles = random_get_entropy();\n\t__u32\t\t\tc_high, j_high;\n\t__u64\t\t\tip;\n\tunsigned long\t\tseed;\n\tint\t\t\tcredit = 0;\n\tif (cycles == 0)\n\t\tcycles = get_reg(fast_pool, regs);\n\tc_high = (sizeof(cycles) > 4) ? cycles >> 32 : 0;\n\tj_high = (sizeof(now) > 4) ? now >> 32 : 0;\n\tfast_pool->pool[0] ^= cycles ^ j_high ^ irq;\n\tfast_pool->pool[1] ^= now ^ c_high;\n\tip = regs ? instruction_pointer(regs) : _RET_IP_;\n\tfast_pool->pool[2] ^= ip;\n\tfast_pool->pool[3] ^= (sizeof(ip) > 4) ? ip >> 32 :\n\t\tget_reg(fast_pool, regs);\n\tfast_mix(fast_pool);\n\tadd_interrupt_bench(cycles);\n\tthis_cpu_add(net_rand_state.s1, fast_pool->pool[cycles & 3]);\n\tif (unlikely(crng_init == 0)) {\n\t\tif ((fast_pool->count >= 64) &&\n\t\t    crng_fast_load((char *) fast_pool->pool,\n\t\t\t\t   sizeof(fast_pool->pool))) {\n\t\t\tfast_pool->count = 0;\n\t\t\tfast_pool->last = now;\n\t\t}\n\t\treturn;\n\t}\n\tif ((fast_pool->count < 64) &&\n\t    !time_after(now, fast_pool->last + HZ))\n\t\treturn;\n\tr = &input_pool;\n\tif (!spin_trylock(&r->lock))\n\t\treturn;\n\tfast_pool->last = now;\n\t__mix_pool_bytes(r, &fast_pool->pool, sizeof(fast_pool->pool));\n\tif (arch_get_random_seed_long(&seed)) {\n\t\t__mix_pool_bytes(r, &seed, sizeof(seed));\n\t\tcredit = 1;\n\t}\n\tspin_unlock(&r->lock);\n\tfast_pool->count = 0;\n\tcredit_entropy_bits(r, credit + 1);\n}", "target": 0}
{"code": "unsigned int X509v3_addr_get_afi(const IPAddressFamily *f)\n{\n    return ((f != NULL &&\n             f->addressFamily != NULL && f->addressFamily->data != NULL)\n            ? ((f->addressFamily->data[0] << 8) | (f->addressFamily->data[1]))\n            : 0);\n}", "target": 1}
{"code": "bool IsBlacklistedArg(const base::CommandLine::CharType* arg) {\n#if defined(OS_WIN)\n  const auto converted = base::WideToUTF8(arg);\n  const char* a = converted.c_str();\n#else\n  const char* a = arg;\n#endif\n  static const char* prefixes[] = {\"--\", \"-\", \"/\"};\n  int prefix_length = 0;\n  for (auto& prefix : prefixes) {\n    if (base::StartsWith(a, prefix, base::CompareCase::SENSITIVE)) {\n      prefix_length = strlen(prefix);\n      break;\n    }\n  }\n  if (prefix_length > 0) {\n    a += prefix_length;\n    std::string switch_name(a, strcspn(a, \"=\"));\n    auto* iter = std::lower_bound(std::begin(kBlacklist), std::end(kBlacklist),\n                                  switch_name);\n    if (iter != std::end(kBlacklist) && switch_name == *iter) {\n      return true;\n    }\n  }\n  return false;\n}", "target": 1}
{"code": "static inline int ccid_hc_rx_getsockopt(struct ccid *ccid, struct sock *sk,\n\t\t\t\t\tconst int optname, int len,\n\t\t\t\t\tu32 __user *optval, int __user *optlen)\n{\n\tint rc = -ENOPROTOOPT;\n\tif (ccid->ccid_ops->ccid_hc_rx_getsockopt != NULL)\n\t\trc = ccid->ccid_ops->ccid_hc_rx_getsockopt(sk, optname, len,\n\t\t\t\t\t\t optval, optlen);\n\treturn rc;\n}", "target": 1}
{"code": "static int __init personal_server_map_irq(const struct pci_dev *dev, u8 slot,\n\tu8 pin)\n{\n\tunsigned char line;\n\tpci_read_config_byte(dev, PCI_INTERRUPT_LINE, &line);\n\tif (line > 0x40 && line <= 0x5f) {\n\t\treturn irqmap_personal_server[(line & 0x1f) - 8];\n\t} else if (line == 0) {\n\t\treturn 0;\n\t} else\n\t\treturn irqmap_personal_server[(line - 1) & 3];\n}", "target": 1}
{"code": "static void ext4_free_io_end(ext4_io_end_t *io)\n{\n\tBUG_ON(!io);\n\tiput(io->inode);\n\tkfree(io);\n}", "target": 1}
{"code": "FramebufferModel::~FramebufferModel()\n{\n    delete[] m_pixelBuffer;\n}", "target": 1}
{"code": "static ssize_t aio_setup_single_vector(struct kiocb *kiocb,\n\t\t\t\t       int rw, char __user *buf,\n\t\t\t\t       unsigned long *nr_segs,\n\t\t\t\t       size_t len,\n\t\t\t\t       struct iovec *iovec)\n{\n\tif (unlikely(!access_ok(!rw, buf, len)))\n\t\treturn -EFAULT;\n\tiovec->iov_base = buf;\n\tiovec->iov_len = len;\n\t*nr_segs = 1;\n\treturn 0;\n}", "target": 1}
{"code": "GF_Err gf_isom_set_extraction_slc(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex, const GF_SLConfig *slConfig)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_Err e;\n\tGF_SLConfig **slc;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\te = Media_GetSampleDesc(trak->Media, StreamDescriptionIndex, &entry, NULL);\n\tif (e) return e;\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\tif (((GF_MPEGSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = & ((GF_MPEGSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tif (((GF_MPEGAudioSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = & ((GF_MPEGAudioSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tif (((GF_MPEGVisualSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = & ((GF_MPEGVisualSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\tif (*slc) {\n\t\tgf_odf_desc_del((GF_Descriptor *)*slc);\n\t\t*slc = NULL;\n\t}\n\tif (!slConfig) return GF_OK;\n\treturn gf_odf_desc_copy((GF_Descriptor *) slConfig, (GF_Descriptor **) slc);\n}", "target": 1}
{"code": "SYSCALL_DEFINE2(clock_adjtime, const clockid_t, which_clock,\n\t\tstruct timex __user *, utx)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\tstruct timex ktx;\n\tint err;\n\tif (!kc)\n\t\treturn -EINVAL;\n\tif (!kc->clock_adj)\n\t\treturn -EOPNOTSUPP;\n\tif (copy_from_user(&ktx, utx, sizeof(ktx)))\n\t\treturn -EFAULT;\n\terr = kc->clock_adj(which_clock, &ktx);\n\tif (err >= 0 && copy_to_user(utx, &ktx, sizeof(ktx)))\n\t\treturn -EFAULT;\n\treturn err;\n}", "target": 0}
{"code": "static int f_midi_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\n{\n\tstruct f_midi *midi = func_to_midi(f);\n\tunsigned i;\n\tint err;\n\tif (intf != midi->ms_id)\n\t\treturn 0;\n\terr = f_midi_start_ep(midi, f, midi->in_ep);\n\tif (err)\n\t\treturn err;\n\terr = f_midi_start_ep(midi, f, midi->out_ep);\n\tif (err)\n\t\treturn err;\n\twhile (kfifo_avail(&midi->in_req_fifo)) {\n\t\tstruct usb_request *req =\n\t\t\tmidi_alloc_ep_req(midi->in_ep, midi->buflen);\n\t\tif (req == NULL)\n\t\t\treturn -ENOMEM;\n\t\treq->length = 0;\n\t\treq->complete = f_midi_complete;\n\t\tkfifo_put(&midi->in_req_fifo, req);\n\t}\n\tfor (i = 0; i < midi->qlen && err == 0; i++) {\n\t\tstruct usb_request *req =\n\t\t\tmidi_alloc_ep_req(midi->out_ep, midi->buflen);\n\t\tif (req == NULL)\n\t\t\treturn -ENOMEM;\n\t\treq->complete = f_midi_complete;\n\t\terr = usb_ep_queue(midi->out_ep, req, GFP_ATOMIC);\n\t\tif (err) {\n\t\t\tERROR(midi, \"%s: couldn't enqueue request: %d\\n\",\n\t\t\t\t    midi->out_ep->name, err);\n\t\t\tfree_ep_req(midi->out_ep, req);\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static void bq24190_remove(struct i2c_client *client)\n{\n\tstruct bq24190_dev_info *bdi = i2c_get_clientdata(client);\n\tint error;\n\tcancel_delayed_work_sync(&bdi->input_current_limit_work);\n\terror = pm_runtime_resume_and_get(bdi->dev);\n\tif (error < 0)\n\t\tdev_warn(bdi->dev, \"pm_runtime_get failed: %i\\n\", error);\n\tbq24190_register_reset(bdi);\n\tif (bdi->battery)\n\t\tpower_supply_unregister(bdi->battery);\n\tpower_supply_unregister(bdi->charger);\n\tif (error >= 0)\n\t\tpm_runtime_put_sync(bdi->dev);\n\tpm_runtime_dont_use_autosuspend(bdi->dev);\n\tpm_runtime_disable(bdi->dev);\n}", "target": 0}
{"code": "static ram_addr_t find_ram_offset(struct uc_struct *uc, ram_addr_t size)\n{\n    RAMBlock *block, *next_block;\n    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;\n    assert(size != 0); \n    if (QLIST_EMPTY(&uc->ram_list.blocks)) {\n        return 0;\n    }\n    RAMBLOCK_FOREACH(block) {\n        ram_addr_t candidate, next = RAM_ADDR_MAX;\n        candidate = block->offset + block->max_length;\n        candidate = ROUND_UP(candidate, BITS_PER_LONG << TARGET_PAGE_BITS);\n        RAMBLOCK_FOREACH(next_block) {\n            if (next_block->offset >= candidate) {\n                next = MIN(next, next_block->offset);\n            }\n        }\n        if (next - candidate >= size && next - candidate < mingap) {\n            offset = candidate;\n            mingap = next - candidate;\n        }\n    }\n    if (offset == RAM_ADDR_MAX) {\n        fprintf(stderr, \"Failed to find gap of requested size: %\" PRIu64 \"\\n\",\n                (uint64_t)size);\n        abort();\n    }\n    return offset;\n}", "target": 1}
{"code": "static void calc_load_migrate(struct rq *rq)\n{\n\tlong delta = calc_load_fold_active(rq);\n\tif (delta)\n\t\tatomic_long_add(delta, &calc_load_tasks);\n}", "target": 0}
{"code": "static int snd_seq_ioctl_remove_events(struct snd_seq_client *client,\n\t\t\t\t       void __user *arg)\n{\n\tstruct snd_seq_remove_events info;\n\tif (copy_from_user(&info, arg, sizeof(info)))\n\t\treturn -EFAULT;\n\tif (info.remove_mode & SNDRV_SEQ_REMOVE_INPUT) {\n\t\tif (client->type == USER_CLIENT)\n\t\t\tsnd_seq_fifo_clear(client->data.user.fifo);\n\t}\n\tif (info.remove_mode & SNDRV_SEQ_REMOVE_OUTPUT)\n\t\tsnd_seq_queue_remove_cells(client->number, &info);\n\treturn 0;\n}", "target": 1}
{"code": "static int wanxl_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tconst size_t size = sizeof(sync_serial_settings);\n\tsync_serial_settings line;\n\tport_t *port = dev_to_port(dev);\n\tif (cmd != SIOCWANDEV)\n\t\treturn hdlc_ioctl(dev, ifr, cmd);\n\tswitch (ifr->ifr_settings.type) {\n\tcase IF_GET_IFACE:\n\t\tifr->ifr_settings.type = IF_IFACE_SYNC_SERIAL;\n\t\tif (ifr->ifr_settings.size < size) {\n\t\t\tifr->ifr_settings.size = size; \n\t\t\treturn -ENOBUFS;\n\t\t}\n\t\tmemset(&line, 0, sizeof(line));\n\t\tline.clock_type = get_status(port)->clocking;\n\t\tline.clock_rate = 0;\n\t\tline.loopback = 0;\n\t\tif (copy_to_user(ifr->ifr_settings.ifs_ifsu.sync, &line, size))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase IF_IFACE_SYNC_SERIAL:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (dev->flags & IFF_UP)\n\t\t\treturn -EBUSY;\n\t\tif (copy_from_user(&line, ifr->ifr_settings.ifs_ifsu.sync,\n\t\t\t\t   size))\n\t\t\treturn -EFAULT;\n\t\tif (line.clock_type != CLOCK_EXT &&\n\t\t    line.clock_type != CLOCK_TXFROMRX)\n\t\t\treturn -EINVAL; \n\t\tif (line.loopback != 0)\n\t\t\treturn -EINVAL;\n\t\tget_status(port)->clocking = line.clock_type;\n\t\treturn 0;\n\tdefault:\n\t\treturn hdlc_ioctl(dev, ifr, cmd);\n        }\n}", "target": 0}
{"code": "bool RequestParser::OnHeadersEnd() {\n  bool matched = view_matcher_(request_->method(), request_->url().path(),\n                               &stream_);\n  if (!matched) {\n    LOG_WARN(\"No view matches the request: %s %s\", request_->method().c_str(),\n             request_->url().path().c_str());\n  }\n  return matched;\n}", "target": 1}
{"code": "file_add_mapi_attrs (File* file, MAPI_Attr** attrs)\n{\n    int i;\n    for (i = 0; attrs[i]; i++)\n    {\n\tMAPI_Attr* a = attrs[i];\n\tif (a->num_values)\n\t{\n\t    switch (a->name)\n\t    {\n\t    case MAPI_ATTACH_LONG_FILENAME:\n\t\tassert(a->type == szMAPI_STRING);\n\t\tif (file->name) XFREE(file->name);\n\t\tfile->name = strdup( (char*)a->values[0].data.buf );\n\t\tbreak;\n\t    case MAPI_ATTACH_DATA_OBJ:\n\t\tassert((a->type == szMAPI_BINARY) || (a->type == szMAPI_OBJECT));\n\t\tfile->len = a->values[0].len;\n\t\tif (file->data) XFREE (file->data);\n\t\tfile->data = CHECKED_XMALLOC (unsigned char, file->len);\n\t\tmemmove (file->data, a->values[0].data.buf, file->len);\n\t\tbreak;\n             case MAPI_ATTACH_MIME_TAG:\n\t\tassert(a->type == szMAPI_STRING);\n\t\tif (file->mime_type) XFREE (file->mime_type);\n\t\tfile->mime_type = CHECKED_XMALLOC (char, a->values[0].len);\n\t\tmemmove (file->mime_type, a->values[0].data.buf, a->values[0].len);\n\t\tbreak;\n                case MAPI_ATTACH_CONTENT_ID:\n                    assert(a->type == szMAPI_STRING);\n                    if (file->content_id) XFREE(file->content_id);\n                    file->content_id = CHECKED_XMALLOC (char, a->values[0].len);\n                    memmove (file->content_id, a->values[0].data.buf, a->values[0].len);\n                    break;\n\t    default:\n\t\tbreak;\n\t    }\n\t}\n    }\n}", "target": 0}
{"code": "static inline struct nlattr *nla_next(const struct nlattr *nla, int *remaining)\n{\n\tint totlen = NLA_ALIGN(nla->nla_len);\n\t*remaining -= totlen;\n\treturn (struct nlattr *) ((char *) nla + totlen);\n}", "target": 0}
{"code": "static int hns_roce_netdev_event(struct notifier_block *self,\n\t\t\t\t unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct hns_roce_ib_iboe *iboe = NULL;\n\tstruct hns_roce_dev *hr_dev = NULL;\n\tu8 port = 0;\n\tint ret = 0;\n\thr_dev = container_of(self, struct hns_roce_dev, iboe.nb);\n\tiboe = &hr_dev->iboe;\n\tfor (port = 0; port < hr_dev->caps.num_ports; port++) {\n\t\tif (dev == iboe->netdevs[port]) {\n\t\t\tret = handle_en_event(hr_dev, port, event);\n\t\t\tif (ret)\n\t\t\t\treturn NOTIFY_DONE;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn NOTIFY_DONE;\n}", "target": 0}
{"code": "static int ax25_recvmsg(struct kiocb *iocb, struct socket *sock,\n\tstruct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint copied;\n\tint err = 0;\n\tlock_sock(sk);\n\tif (sk->sk_type == SOCK_SEQPACKET && sk->sk_state != TCP_ESTABLISHED) {\n\t\terr =  -ENOTCONN;\n\t\tgoto out;\n\t}\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &err);\n\tif (skb == NULL)\n\t\tgoto out;\n\tif (!ax25_sk(sk)->pidincl)\n\t\tskb_pull(skb, 1);\t\t\n\tskb_reset_transport_header(skb);\n\tcopied = skb->len;\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\tskb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (msg->msg_namelen != 0) {\n\t\tstruct sockaddr_ax25 *sax = (struct sockaddr_ax25 *)msg->msg_name;\n\t\tax25_digi digi;\n\t\tax25_address src;\n\t\tconst unsigned char *mac = skb_mac_header(skb);\n\t\tmemset(sax, 0, sizeof(struct full_sockaddr_ax25));\n\t\tax25_addr_parse(mac + 1, skb->data - mac - 1, &src, NULL,\n\t\t\t\t&digi, NULL, NULL);\n\t\tsax->sax25_family = AF_AX25;\n\t\tsax->sax25_ndigis = digi.ndigi;\n\t\tsax->sax25_call   = src;\n\t\tif (sax->sax25_ndigis != 0) {\n\t\t\tint ct;\n\t\t\tstruct full_sockaddr_ax25 *fsa = (struct full_sockaddr_ax25 *)sax;\n\t\t\tfor (ct = 0; ct < digi.ndigi; ct++)\n\t\t\t\tfsa->fsa_digipeater[ct] = digi.calls[ct];\n\t\t}\n\t\tmsg->msg_namelen = sizeof(struct full_sockaddr_ax25);\n\t}\n\tskb_free_datagram(sk, skb);\n\terr = copied;\nout:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "PGTYPESinterval_from_asc(char *str, char **endptr)\n{\n\tinterval   *result = NULL;\n\tfsec_t\t\tfsec;\n\tstruct tm\ttt,\n\t\t\t   *tm = &tt;\n\tint\t\t\tdtype;\n\tint\t\t\tnf;\n\tchar\t   *field[MAXDATEFIELDS];\n\tint\t\t\tftype[MAXDATEFIELDS];\n\tchar\t\tlowstr[MAXDATELEN + MAXDATEFIELDS];\n\tchar\t   *realptr;\n\tchar\t  **ptr = (endptr != NULL) ? endptr : &realptr;\n\ttm->tm_year = 0;\n\ttm->tm_mon = 0;\n\ttm->tm_mday = 0;\n\ttm->tm_hour = 0;\n\ttm->tm_min = 0;\n\ttm->tm_sec = 0;\n\tfsec = 0;\n\tif (strlen(str) >= sizeof(lowstr))\n\t{\n\t\terrno = PGTYPES_INTVL_BAD_INTERVAL;\n\t\treturn NULL;\n\t}\n\tif (ParseDateTime(str, lowstr, field, ftype, &nf, ptr) != 0 ||\n\t\t(DecodeInterval(field, ftype, nf, &dtype, tm, &fsec) != 0 &&\n\t\t DecodeISO8601Interval(str, &dtype, tm, &fsec) != 0))\n\t{\n\t\terrno = PGTYPES_INTVL_BAD_INTERVAL;\n\t\treturn NULL;\n\t}\n\tresult = (interval *) pgtypes_alloc(sizeof(interval));\n\tif (!result)\n\t\treturn NULL;\n\tif (dtype != DTK_DELTA)\n\t{\n\t\terrno = PGTYPES_INTVL_BAD_INTERVAL;\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\tif (tm2interval(tm, fsec, result) != 0)\n\t{\n\t\terrno = PGTYPES_INTVL_BAD_INTERVAL;\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\terrno = 0;\n\treturn result;\n}", "target": 1}
{"code": "void CxImage::Ghost(const CxImage *from)\n{\n\tif (from){\n\t\tmemcpy(&head,&from->head,sizeof(BITMAPINFOHEADER));\n\t\tmemcpy(&info,&from->info,sizeof(CXIMAGEINFO));\n\t\tpDib = from->pDib;\n        pDibLimit = from->pDibLimit;\n\t\tpSelection = from->pSelection;\n\t\tpAlpha = from->pAlpha;\n\t\tppLayers = from->ppLayers;\n\t\tppFrames = from->ppFrames;\n\t\tinfo.pGhost=(CxImage *)from;\n\t}\n}", "target": 0}
{"code": "psf_bump_header_allocation (SF_PRIVATE * psf, sf_count_t needed)\n{\n\tsf_count_t newlen, smallest = INITAL_HEADER_SIZE ;\n\tvoid * ptr ;\n\tnewlen = (needed > psf->header.len) ? 2 * SF_MAX (needed, smallest) : 2 * psf->header.len ;\n\tif (newlen > 100 * 1024)\n\t{\tpsf_log_printf (psf, \"Request for header allocation of %D denined.\\n\", newlen) ;\n\t\treturn 1 ;\n\t\t}\n\tif ((ptr = realloc (psf->header.ptr, newlen)) == NULL)\n\t{\tpsf_log_printf (psf, \"realloc (%p, %D) failed\\n\", psf->header.ptr, newlen) ;\n\t\tpsf->error = SFE_MALLOC_FAILED ;\n\t\treturn 1 ;\n\t\t} ;\n\tpsf->header.ptr = ptr ;\n\tpsf->header.len = newlen ;\n\treturn 0 ;\n} ", "target": 0}
{"code": "static int nft_inner_init(const struct nft_ctx *ctx,\n\t\t\t  const struct nft_expr *expr,\n\t\t\t  const struct nlattr * const tb[])\n{\n\tstruct nft_inner *priv = nft_expr_priv(expr);\n\tu32 flags, hdrsize, type, num;\n\tstruct nft_expr_info expr_info;\n\tint err;\n\tif (!tb[NFTA_INNER_FLAGS] ||\n\t    !tb[NFTA_INNER_NUM] ||\n\t    !tb[NFTA_INNER_HDRSIZE] ||\n\t    !tb[NFTA_INNER_TYPE] ||\n\t    !tb[NFTA_INNER_EXPR])\n\t\treturn -EINVAL;\n\tflags = ntohl(nla_get_be32(tb[NFTA_INNER_FLAGS]));\n\tif (flags & ~NFT_INNER_MASK)\n\t\treturn -EOPNOTSUPP;\n\tnum = ntohl(nla_get_be32(tb[NFTA_INNER_NUM]));\n\tif (num != 0)\n\t\treturn -EOPNOTSUPP;\n\thdrsize = ntohl(nla_get_be32(tb[NFTA_INNER_HDRSIZE]));\n\ttype = ntohl(nla_get_be32(tb[NFTA_INNER_TYPE]));\n\tif (type > U8_MAX)\n\t\treturn -EINVAL;\n\tif (flags & NFT_INNER_HDRSIZE) {\n\t\tif (hdrsize == 0 || hdrsize > 64)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\tpriv->flags = flags;\n\tpriv->hdrsize = hdrsize;\n\tpriv->type = type;\n\terr = nft_expr_inner_parse(ctx, tb[NFTA_INNER_EXPR], &expr_info);\n\tif (err < 0)\n\t\treturn err;\n\tpriv->expr.ops = expr_info.ops;\n\tif (!strcmp(expr_info.ops->type->name, \"payload\"))\n\t\tpriv->expr_type = NFT_INNER_EXPR_PAYLOAD;\n\telse if (!strcmp(expr_info.ops->type->name, \"meta\"))\n\t\tpriv->expr_type = NFT_INNER_EXPR_META;\n\telse\n\t\treturn -EINVAL;\n\terr = expr_info.ops->init(ctx, (struct nft_expr *)&priv->expr,\n\t\t\t\t  (const struct nlattr * const*)expr_info.tb);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}", "target": 0}
{"code": "mm_compare(struct mm_share *a, struct mm_share *b)\n{\n\tptrdiff_t diff = (char *)a->address - (char *)b->address;\n\tif (diff == 0)\n\t\treturn (0);\n\telse if (diff < 0)\n\t\treturn (-1);\n\telse\n\t\treturn (1);\n}", "target": 1}
{"code": "TEE_Result syscall_authenc_update_payload(unsigned long state,\n\t\t\tconst void *src_data, size_t src_len, void *dst_data,\n\t\t\tuint64_t *dst_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tsize_t dlen = 0;\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)\n\t\treturn TEE_ERROR_BAD_STATE;\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t) src_data, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = get_user_u64_as_size_t(&dlen, dst_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)dst_data, dlen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif (dlen < src_len) {\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\tres = crypto_authenc_update_payload(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\t    src_data, src_len, dst_data,\n\t\t\t\t\t    &dlen);\nout:\n\tif (res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) {\n\t\tTEE_Result res2 = put_user_u64(dst_len, dlen);\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\tres = res2;\n\t}\n\treturn res;\n}", "target": 0}
{"code": "static int op_open1(OggOpusFile *_of,\n void *_stream,const OpusFileCallbacks *_cb,\n const unsigned char *_initial_data,size_t _initial_bytes){\n  ogg_page  og;\n  ogg_page *pog;\n  int       seekable;\n  int       ret;\n  memset(_of,0,sizeof(*_of));\n  if(OP_UNLIKELY(_initial_bytes>(size_t)LONG_MAX))return OP_EFAULT;\n  _of->end=-1;\n  _of->stream=_stream;\n  *&_of->callbacks=*_cb;\n  if(OP_UNLIKELY(_of->callbacks.read==NULL))return OP_EREAD;\n  ogg_sync_init(&_of->oy);\n  if(_initial_bytes>0){\n    char *buffer;\n    buffer=ogg_sync_buffer(&_of->oy,(long)_initial_bytes);\n    if(OP_UNLIKELY(buffer==NULL))return OP_EFAULT;\n    memcpy(buffer,_initial_data,_initial_bytes*sizeof(*buffer));\n    ogg_sync_wrote(&_of->oy,(long)_initial_bytes);\n  }\n  seekable=_cb->seek!=NULL&&(*_cb->seek)(_stream,0,SEEK_CUR)!=-1;\n  if(seekable){\n    opus_int64 pos;\n    if(OP_UNLIKELY(_of->callbacks.tell==NULL))return OP_EINVAL;\n    pos=(*_of->callbacks.tell)(_of->stream);\n    if(OP_UNLIKELY(pos!=(opus_int64)_initial_bytes))return OP_EINVAL;\n  }\n  _of->seekable=seekable;\n  _of->links=(OggOpusLink *)_ogg_malloc(sizeof(*_of->links));\n  ogg_stream_init(&_of->os,-1);\n  pog=NULL;\n  for(;;){\n    ret=op_fetch_headers(_of,&_of->links[0].head,&_of->links[0].tags,\n     &_of->serialnos,&_of->nserialnos,&_of->cserialnos,pog);\n    if(OP_UNLIKELY(ret<0))break;\n    _of->nlinks=1;\n    _of->links[0].offset=0;\n    _of->links[0].data_offset=_of->offset;\n    _of->links[0].pcm_end=-1;\n    _of->links[0].serialno=_of->os.serialno;\n    ret=op_find_initial_pcm_offset(_of,_of->links,&og);\n    if(seekable||OP_LIKELY(ret<=0))break;\n    opus_tags_clear(&_of->links[0].tags);\n    _of->nlinks=0;\n    if(!seekable)_of->cur_link++;\n    pog=&og;\n  }\n  if(OP_LIKELY(ret>=0))_of->ready_state=OP_PARTOPEN;\n  return ret;\n}", "target": 0}
{"code": "SSL_SESSION *SSL_SESSION_dup(const SSL_SESSION *src)\n{\n    return ssl_session_dup(src, 1);\n}", "target": 1}
{"code": "cleanup_pathname(struct archive_write_disk *a)\n{\n\tstruct archive_string error_string;\n\tint error_number;\n\tint rc;\n\tarchive_string_init(&error_string);\n\trc = cleanup_pathname_fsobj(a->name, &error_number, &error_string, a->flags);\n\tif (rc != ARCHIVE_OK) {\n\t\tarchive_set_error(&a->archive, error_number, \"%s\", error_string.s);\n\t}\n\tarchive_string_free(&error_string);\n\treturn rc;\n}", "target": 0}
{"code": "static inline bool cfs_rq_is_decayed(struct cfs_rq *cfs_rq)\n{\n\tif (cfs_rq->load.weight)\n\t\treturn false;\n\tif (cfs_rq->avg.load_sum)\n\t\treturn false;\n\tif (cfs_rq->avg.util_sum)\n\t\treturn false;\n\tif (cfs_rq->avg.runnable_load_sum)\n\t\treturn false;\n\treturn true;\n}", "target": 1}
{"code": "static bool freelist_state_initialize(union freelist_init_state *state,\n\t\t\t\tstruct kmem_cache *cachep,\n\t\t\t\tunsigned int count)\n{\n\tbool ret;\n\tunsigned int rand;\n\trand = get_random_int();\n\tif (!cachep->random_seq) {\n\t\tprandom_seed_state(&state->rnd_state, rand);\n\t\tret = false;\n\t} else {\n\t\tstate->list = cachep->random_seq;\n\t\tstate->count = count;\n\t\tstate->pos = 0;\n\t\tstate->rand = rand;\n\t\tret = true;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "  void ValidateInputs(OpKernelContext* ctx,\n                      const CSRSparseMatrix& sparse_matrix,\n                      const Tensor& permutation_indices, int* batch_size,\n                      int64* num_rows) {\n    OP_REQUIRES(ctx, sparse_matrix.dtype() == DataTypeToEnum<T>::value,\n                errors::InvalidArgument(\n                    \"Asked for a CSRSparseMatrix of type \",\n                    DataTypeString(DataTypeToEnum<T>::value),\n                    \" but saw dtype: \", DataTypeString(sparse_matrix.dtype())));\n    const Tensor& dense_shape = sparse_matrix.dense_shape();\n    const int rank = dense_shape.dim_size(0);\n    OP_REQUIRES(ctx, rank == 2 || rank == 3,\n                errors::InvalidArgument(\"sparse matrix must have rank 2 or 3; \",\n                                        \"but dense_shape has size \", rank));\n    const int row_dim = (rank == 2) ? 0 : 1;\n    auto dense_shape_vec = dense_shape.vec<int64>();\n    *num_rows = dense_shape_vec(row_dim);\n    const int64 num_cols = dense_shape_vec(row_dim + 1);\n    OP_REQUIRES(ctx, *num_rows == num_cols,\n                errors::InvalidArgument(\"sparse matrix must be square; got: \",\n                                        *num_rows, \" != \", num_cols));\n    const TensorShape& perm_shape = permutation_indices.shape();\n    OP_REQUIRES(\n        ctx, perm_shape.dims() + 1 == rank,\n        errors::InvalidArgument(\n            \"sparse matrix must have the same rank as permutation; got: \", rank,\n            \" != \", perm_shape.dims(), \" + 1.\"));\n    OP_REQUIRES(\n        ctx, perm_shape.dim_size(rank - 2) == *num_rows,\n        errors::InvalidArgument(\n            \"permutation must have the same number of elements in each batch \"\n            \"as the number of rows in sparse matrix; got: \",\n            perm_shape.dim_size(rank - 2), \" != \", *num_rows));\n    *batch_size = sparse_matrix.batch_size();\n    if (*batch_size > 1) {\n      OP_REQUIRES(\n          ctx, perm_shape.dim_size(0) == *batch_size,\n          errors::InvalidArgument(\"permutation must have the same batch size \"\n                                  \"as sparse matrix; got: \",\n                                  perm_shape.dim_size(0), \" != \", *batch_size));\n    }\n  }", "target": 1}
{"code": "guestfs___first_line_of_file (guestfs_h *g, const char *filename)\n{\n  CLEANUP_FREE char **lines = NULL; \n  int64_t size;\n  char *ret;\n  size = guestfs_filesize (g, filename);\n  if (size == -1)\n    return NULL;\n  if (size > MAX_SMALL_FILE_SIZE) {\n    error (g, _(\"size of %s is unreasonably large (%\" PRIi64 \" bytes)\"),\n           filename, size);\n    return NULL;\n  }\n  lines = guestfs_head_n (g, 1, filename);\n  if (lines == NULL)\n    return NULL;\n  if (lines[0] == NULL) {\n    guestfs___free_string_list (lines);\n    return safe_strdup (g, \"\");\n  }\n  ret = lines[0];               \n  return ret;\n}", "target": 1}
{"code": "int devmem_is_allowed(unsigned long pagenr)\n{\n\tif (pagenr < 256)\n\t\treturn 1;\n\tif (iomem_is_exclusive(pagenr << PAGE_SHIFT))\n\t\treturn 0;\n\tif (!page_is_ram(pagenr))\n\t\treturn 1;\n\treturn 0;\n}", "target": 1}
{"code": "void init_xml_schema()\n{\n  VALUE nokogiri = rb_define_module(\"Nokogiri\");\n  VALUE xml = rb_define_module_under(nokogiri, \"XML\");\n  VALUE klass = rb_define_class_under(xml, \"Schema\", rb_cObject);\n  cNokogiriXmlSchema = klass;\n  rb_define_singleton_method(klass, \"read_memory\", read_memory, 1);\n  rb_define_singleton_method(klass, \"from_document\", from_document, 1);\n  rb_define_private_method(klass, \"validate_document\", validate_document, 1);\n  rb_define_private_method(klass, \"validate_file\",     validate_file, 1);\n}", "target": 1}
{"code": "static int seed_from_urandom(uint32_t *seed) {\n    char data[sizeof(uint32_t)];\n    int ok;\n#if defined(HAVE_OPEN) && defined(HAVE_CLOSE) && defined(HAVE_READ)\n    int urandom;\n    urandom = open(\"/dev/urandom\", O_RDONLY);\n    if (urandom == -1)\n        return 1;\n    ok = read(urandom, data, sizeof(uint32_t)) == sizeof(uint32_t);\n    close(urandom);\n#else\n    FILE *urandom;\n    urandom = fopen(\"/dev/urandom\", \"rb\");\n    if (!urandom)\n        return 1;\n    ok = fread(data, 1, sizeof(uint32_t), urandom) == sizeof(uint32_t);\n    fclose(urandom);\n#endif\n    if (!ok)\n        return 1;\n    *seed = buf_to_uint32(data);\n    return 0;\n}", "target": 0}
{"code": "static void mmtimer_setup_int_0(int cpu, u64 expires)\n{\n\tu64 val;\n\tHUB_S((u64 *)LOCAL_MMR_ADDR(SH_RTC1_INT_ENABLE), 0UL);\n\tHUB_S((u64 *)LOCAL_MMR_ADDR(SH_INT_CMPB), -1L);\n\tmmtimer_clr_int_pending(0);\n\tval = ((u64)SGI_MMTIMER_VECTOR << SH_RTC1_INT_CONFIG_IDX_SHFT) |\n\t\t((u64)cpu_physical_id(cpu) <<\n\t\t\tSH_RTC1_INT_CONFIG_PID_SHFT);\n\tHUB_S((u64 *)LOCAL_MMR_ADDR(SH_RTC1_INT_CONFIG), val);\n\tHUB_S((u64 *)LOCAL_MMR_ADDR(SH_RTC1_INT_ENABLE), 1UL);\n\tHUB_S((u64 *)LOCAL_MMR_ADDR(SH_INT_CMPB), expires);\n}", "target": 0}
{"code": "static inline bool ib_safe_file_access(struct file *filp)\n{\n\treturn filp->f_cred == current_cred() && segment_eq(get_fs(), USER_DS);\n}", "target": 0}
{"code": "int mnt_fs_is_deleted(struct libmnt_fs *fs)\n{\n\treturn mnt_fs_get_flags(fs) & MNT_FS_DELETED;\n}", "target": 1}
{"code": "struct scm_fp_list *scm_fp_dup(struct scm_fp_list *fpl)\n{\n\tstruct scm_fp_list *new_fpl;\n\tint i;\n\tif (!fpl)\n\t\treturn NULL;\n\tnew_fpl = kmemdup(fpl, offsetof(struct scm_fp_list, fp[fpl->count]),\n\t\t\t  GFP_KERNEL);\n\tif (new_fpl) {\n\t\tfor (i = 0; i < fpl->count; i++)\n\t\t\tget_file(fpl->fp[i]);\n\t\tnew_fpl->max = new_fpl->count;\n\t\tnew_fpl->user = get_uid(fpl->user);\n\t}\n\treturn new_fpl;\n}", "target": 0}
{"code": "std::unique_ptr<cql_server::response> cql_server::connection::make_supported(int16_t stream, const tracing::trace_state_ptr& tr_state) const\n{\n    std::multimap<sstring, sstring> opts;\n    opts.insert({\"CQL_VERSION\", cql3::query_processor::CQL_VERSION});\n    opts.insert({\"COMPRESSION\", \"lz4\"});\n    opts.insert({\"COMPRESSION\", \"snappy\"});\n    if (_server._config.allow_shard_aware_drivers) {\n        opts.insert({\"SCYLLA_SHARD\", format(\"{:d}\", this_shard_id())});\n        opts.insert({\"SCYLLA_NR_SHARDS\", format(\"{:d}\", smp::count)});\n        opts.insert({\"SCYLLA_SHARDING_ALGORITHM\", dht::cpu_sharding_algorithm_name()});\n        if (_server._config.shard_aware_transport_port) {\n            opts.insert({\"SCYLLA_SHARD_AWARE_PORT\", format(\"{:d}\", *_server._config.shard_aware_transport_port)});\n        }\n        if (_server._config.shard_aware_transport_port_ssl) {\n            opts.insert({\"SCYLLA_SHARD_AWARE_PORT_SSL\", format(\"{:d}\", *_server._config.shard_aware_transport_port_ssl)});\n        }\n        opts.insert({\"SCYLLA_SHARDING_IGNORE_MSB\", format(\"{:d}\", _server._config.sharding_ignore_msb)});\n        opts.insert({\"SCYLLA_PARTITIONER\", _server._config.partitioner_name});\n    }\n    for (cql_protocol_extension ext : supported_cql_protocol_extensions()) {\n        const sstring ext_key_name = protocol_extension_name(ext);\n        std::vector<sstring> params = additional_options_for_proto_ext(ext);\n        if (params.empty()) {\n            opts.emplace(ext_key_name, \"\");\n        } else {\n            for (sstring val : params) {\n                opts.emplace(ext_key_name, std::move(val));\n            }\n        }\n    }\n    auto response = std::make_unique<cql_server::response>(stream, cql_binary_opcode::SUPPORTED, tr_state);\n    response->write_string_multimap(std::move(opts));\n    return response;\n}", "target": 0}
{"code": "void vmacache_flush_all(struct mm_struct *mm)\n{\n\tstruct task_struct *g, *p;\n\tcount_vm_vmacache_event(VMACACHE_FULL_FLUSHES);\n\tif (atomic_read(&mm->mm_users) == 1)\n\t\treturn;\n\trcu_read_lock();\n\tfor_each_process_thread(g, p) {\n\t\tif (mm == p->mm)\n\t\t\tvmacache_flush(p);\n\t}\n\trcu_read_unlock();\n}", "target": 1}
{"code": "int ndpi_netbios_name_interpret(char *in, size_t in_len, char *out, u_int out_len) {\n  u_int ret = 0, len, idx = in_len, out_idx = 0;\n  len = (*in++)/2;\n  out_len--;\n  out[out_idx] = 0;\n  if((len > out_len) || (len < 1) || ((2*len) > in_len))\n    return(-1);\n  while((len--) && (out_idx < out_len)) {\n    if((idx < 2) || (in[0] < 'A') || (in[0] > 'P') || (in[1] < 'A') || (in[1] > 'P')) {\n      out[out_idx] = 0;\n      break;\n    }\n    out[out_idx] = ((in[0] - 'A') << 4) + (in[1] - 'A');\n    in += 2, idx -= 2;\n    if(isprint(out[out_idx]))\n      out_idx++, ret++;\n  }\n  if(out_idx > 0) {\n    out[out_idx] = 0;\n    out_idx--;\n    while((out_idx > 0) && (out[out_idx] == ' ')) {\n      out[out_idx] = 0;\n      out_idx--;\n    }\n  }\n  return(ret);\n}", "target": 1}
{"code": "exit_ext2_xattr(void)\n{\n}", "target": 1}
{"code": "spnego_gss_inquire_saslname_for_mech(OM_uint32 *minor_status,\n                                     const gss_OID desired_mech,\n                                     gss_buffer_t sasl_mech_name,\n                                     gss_buffer_t mech_name,\n                                     gss_buffer_t mech_description)\n{\n\t*minor_status = 0;\n\tif (!g_OID_equal(desired_mech, gss_mech_spnego))\n\t\treturn (GSS_S_BAD_MECH);\n\tif (!g_make_string_buffer(SPNEGO_SASL_NAME, sasl_mech_name) ||\n\t    !g_make_string_buffer(\"spnego\", mech_name) ||\n\t    !g_make_string_buffer(\"Simple and Protected GSS-API \"\n\t\t\t\t  \"Negotiation Mechanism\", mech_description))\n\t\tgoto fail;\n\treturn (GSS_S_COMPLETE);\nfail:\n\t*minor_status = ENOMEM;\n\treturn (GSS_S_FAILURE);\n}", "target": 0}
{"code": "CURLcode Curl_urldecode(struct SessionHandle *data,\n                        const char *string, size_t length,\n                        char **ostring, size_t *olen,\n                        bool reject_ctrl)\n{\n  size_t alloc = (length?length:strlen(string))+1;\n  char *ns = malloc(alloc);\n  unsigned char in;\n  size_t strindex=0;\n  unsigned long hex;\n  CURLcode res;\n  if(!ns)\n    return CURLE_OUT_OF_MEMORY;\n  while(--alloc > 0) {\n    in = *string;\n    if(('%' == in) && (alloc > 2) &&\n       ISXDIGIT(string[1]) && ISXDIGIT(string[2])) {\n      char hexstr[3];\n      char *ptr;\n      hexstr[0] = string[1];\n      hexstr[1] = string[2];\n      hexstr[2] = 0;\n      hex = strtoul(hexstr, &ptr, 16);\n      in = curlx_ultouc(hex); \n      res = Curl_convert_from_network(data, &in, 1);\n      if(res) {\n        free(ns);\n        return res;\n      }\n      string+=2;\n      alloc-=2;\n    }\n    if(reject_ctrl && (in < 0x20)) {\n      free(ns);\n      return CURLE_URL_MALFORMAT;\n    }\n    ns[strindex++] = in;\n    string++;\n  }\n  ns[strindex]=0; \n  if(olen)\n    *olen = strindex;\n  if(ostring)\n    *ostring = ns;\n  return CURLE_OK;\n}", "target": 0}
{"code": "static int segmented_write_std(struct x86_emulate_ctxt *ctxt,\n\t\t\t       struct segmented_address addr,\n\t\t\t       void *data,\n\t\t\t       unsigned int size)\n{\n\tint rc;\n\tulong linear;\n\trc = linearize(ctxt, addr, size, true, &linear);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\treturn ctxt->ops->write_std(ctxt, linear, data, size, &ctxt->exception);\n}", "target": 0}
{"code": "make_month(const char *s)\n{\n    int i;\n    char month[3];\n    month[0] = xtoupper(*s);\n    if (!month[0])\n        return -1; \n    month[1] = xtolower(*(s + 1));\n    if (!month[1])\n        return -1; \n    month[2] = xtolower(*(s + 2));\n    for (i = 0; i < 12; i++)\n        if (!strncmp(month_names[i], month, 3))\n            return i;\n    return -1;\n}", "target": 0}
{"code": "CharString *Formattable::internalGetCharString(UErrorCode &status) {\n    if(fDecimalStr == NULL) {\n      if (fDecimalQuantity == NULL) {\n        LocalPointer<DecimalQuantity> dq(new DecimalQuantity(), status);\n        if (U_FAILURE(status)) { return nullptr; }\n        populateDecimalQuantity(*dq, status);\n        if (U_FAILURE(status)) { return nullptr; }\n        fDecimalQuantity = dq.orphan();\n      }\n      fDecimalStr = new CharString();\n      if (fDecimalStr == NULL) {\n        status = U_MEMORY_ALLOCATION_ERROR;\n        return NULL;\n      }\n      if (fDecimalQuantity->isZero()) {\n        fDecimalStr->append(\"0\", -1, status);\n      } else if (std::abs(fDecimalQuantity->getMagnitude()) < 5) {\n        fDecimalStr->appendInvariantChars(fDecimalQuantity->toPlainString(), status);\n      } else {\n        fDecimalStr->appendInvariantChars(fDecimalQuantity->toScientificString(), status);\n      }\n    }\n    return fDecimalStr;\n}", "target": 1}
{"code": "render_pixbuf_size_prepared_cb (GdkPixbufLoader *loader,\n\t\t\t\tgint             width,\n\t\t\t\tgint             height,\n\t\t\t\tEvRenderContext *rc)\n{\n\tdouble scale = rc->scale;\n\tint w = (width  * scale + 0.5);\n\tint h = (height * scale + 0.5);\n\tgdk_pixbuf_loader_set_size (loader, w, h);\n}", "target": 0}
{"code": "static int rm_rf_inner_child(\n                int fd,\n                const char *fname,\n                int is_dir,\n                RemoveFlags flags,\n                const struct stat *root_dev,\n                bool allow_recursion) {\n        struct stat st;\n        int r, q = 0;\n        assert(fd >= 0);\n        assert(fname);\n        if (is_dir < 0 ||\n            root_dev ||\n            (is_dir > 0 && (root_dev || (flags & REMOVE_SUBVOLUME)))) {\n                r = fstatat_harder(fd, fname, &st, AT_SYMLINK_NOFOLLOW, flags);\n                if (r < 0)\n                        return r;\n                is_dir = S_ISDIR(st.st_mode);\n        }\n        if (is_dir) {\n                if (root_dev && st.st_dev != root_dev->st_dev)\n                        return 0;\n                r = fd_is_mount_point(fd, fname, 0);\n                if (r < 0)\n                        return r;\n                if (r > 0)\n                        return 0;\n                if ((flags & REMOVE_SUBVOLUME) && btrfs_might_be_subvol(&st)) {\n                        r = btrfs_subvol_remove_fd(fd, fname, BTRFS_REMOVE_RECURSIVE|BTRFS_REMOVE_QUOTA);\n                        if (r < 0) {\n                                if (!IN_SET(r, -ENOTTY, -EINVAL))\n                                        return r;\n                        } else\n                                return 1;\n                }\n                if (!allow_recursion)\n                        return -EISDIR;\n                int subdir_fd = openat(fd, fname, O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);\n                if (subdir_fd < 0)\n                        return -errno;\n                q = rm_rf_children(subdir_fd, flags | REMOVE_PHYSICAL, root_dev);\n        } else if (flags & REMOVE_ONLY_DIRECTORIES)\n                return 0;\n        r = unlinkat_harder(fd, fname, is_dir ? AT_REMOVEDIR : 0, flags);\n        if (r < 0)\n                return r;\n        if (q < 0)\n                return q;\n        return 1;\n}", "target": 0}
{"code": "int is_valid_msg_type(const char *msg_id, const char *msg_type)\n{\n\tif (parse_msg_id(msg_id) < 0)\n\t\treturn 0;\n\tparse_msg_type(msg_type);\n\treturn 1;\n}", "target": 0}
{"code": "flush_signal_handlers(struct task_struct *t, int force_default)\n{\n\tint i;\n\tstruct k_sigaction *ka = &t->sighand->action[0];\n\tfor (i = _NSIG ; i != 0 ; i--) {\n\t\tif (force_default || ka->sa.sa_handler != SIG_IGN)\n\t\t\tka->sa.sa_handler = SIG_DFL;\n\t\tka->sa.sa_flags = 0;\n#ifdef SA_RESTORER\n\t\tka->sa.sa_restorer = NULL;\n#endif\n\t\tsigemptyset(&ka->sa.sa_mask);\n\t\tka++;\n\t}\n}", "target": 0}
{"code": "\tvirtual ~CxFile() { };", "target": 1}
{"code": "static inline void init_idle_pids(struct pid_link *links)\n{\n\tenum pid_type type;\n\tfor (type = PIDTYPE_PID; type < PIDTYPE_MAX; ++type) {\n\t\tINIT_HLIST_NODE(&links[type].node); \n\t\tlinks[type].pid = &init_struct_pid;\n\t}\n}", "target": 0}
{"code": "static void hardware_enable(void *junk)\n{\n\traw_spin_lock(&kvm_lock);\n\thardware_enable_nolock(junk);\n\traw_spin_unlock(&kvm_lock);\n}", "target": 0}
{"code": "static int net_ctl_permissions(struct ctl_table_header *head,\n\t\t\t       struct ctl_table *table)\n{\n\tstruct net *net = container_of(head->set, struct net, sysctls);\n\tkuid_t root_uid = make_kuid(net->user_ns, 0);\n\tkgid_t root_gid = make_kgid(net->user_ns, 0);\n\tif (ns_capable(net->user_ns, CAP_NET_ADMIN) ||\n\t    uid_eq(root_uid, current_uid())) {\n\t\tint mode = (table->mode >> 6) & 7;\n\t\treturn (mode << 6) | (mode << 3) | mode;\n\t}\n\tif (gid_eq(root_gid, current_gid())) {\n\t\tint mode = (table->mode >> 3) & 7;\n\t\treturn (mode << 3) | mode;\n\t}\n\treturn table->mode;\n}", "target": 1}
{"code": "static void gen_vector_table16(TrueMotion1Context *s, const uint8_t *sel_vector_table)\n{\n    int len, i, j;\n    unsigned char delta_pair;\n    for (i = 0; i < 1024; i += 4)\n    {\n        len = *sel_vector_table++ / 2;\n        for (j = 0; j < len; j++)\n        {\n            delta_pair = *sel_vector_table++;\n            s->y_predictor_table[i+j] = 0xfffffffe &\n                make_ydt16_entry(delta_pair >> 4, delta_pair & 0xf, s->ydt);\n            s->c_predictor_table[i+j] = 0xfffffffe &\n                make_cdt16_entry(delta_pair >> 4, delta_pair & 0xf, s->cdt);\n        }\n        s->y_predictor_table[i+(j-1)] |= 1;\n        s->c_predictor_table[i+(j-1)] |= 1;\n    }\n}", "target": 0}
{"code": "  Status BuildInputArgIndex(const OpDef::ArgDef& arg_def, AttrSlice attr_values,\n                            const FunctionDef::ArgAttrs* arg_attrs,\n                            bool ints_on_device,\n                            int64_t resource_arg_unique_id) {\n    bool is_type_list;\n    DataTypeVector dtypes;\n    TF_RETURN_IF_ERROR(\n        ArgNumType(attr_values, arg_def, &is_type_list, &dtypes));\n    if (dtypes.size() < size_t{1}) {\n      return errors::Internal(\"Expected a list of at least one dtype\");\n    }\n    int arg_index = result_.nodes.size();\n    TF_RETURN_IF_ERROR(\n        AddItem(arg_def.name(), {true, arg_index, 0, is_type_list, dtypes}));\n    for (size_t i = 0; i < dtypes.size(); ++i) {\n      TF_RETURN_IF_ERROR(AddItem(strings::StrCat(arg_def.name(), \":\", i),\n                                 {true, arg_index, 0, false, {dtypes[i]}}));\n      if (arg_index != result_.nodes.size()) {\n        return errors::Internal(\n            \"Expected arg_index to be equal to the number of nodes in result.\",\n            \" Got \", arg_index, \" and \", result_.nodes.size());\n      }\n      string name = arg_def.name();\n      if (dtypes.size() > 1) {\n        strings::StrAppend(&name, \"_\", i);\n      }\n      NodeDef* gnode = AddNode(name);\n      if (ints_on_device && dtypes[i] == DataType::DT_INT32) {\n        gnode->set_op(FunctionLibraryDefinition::kDeviceArgOp);\n      } else {\n        gnode->set_op(FunctionLibraryDefinition::kArgOp);\n      }\n      DataType dtype = arg_def.is_ref() ? MakeRefType(dtypes[i]) : dtypes[i];\n      AddAttr(\"T\", dtype, gnode);\n      AddAttr(\"index\", arg_index, gnode);\n      if (resource_arg_unique_id >= 0) {\n        AddAttr(\"_resource_arg_unique_id\", resource_arg_unique_id, gnode);\n      }\n      if (arg_attrs) {\n        for (const auto& arg_attr : arg_attrs->attr()) {\n          AddAttr(arg_attr.first, arg_attr.second, gnode->mutable_attr());\n        }\n      }\n      result_.arg_types.push_back(dtypes[i]);\n      ++arg_index;\n    }\n    return Status::OK();\n  }", "target": 0}
{"code": "int touch(const char *path) {\n        return touch_file(path, false, USEC_INFINITY, UID_INVALID, GID_INVALID, 0);\n}", "target": 1}
{"code": "UnicodeString DecimalQuantity::toScientificString() const {\n    U_ASSERT(!isApproximate);\n    UnicodeString result;\n    if (isNegative()) {\n        result.append(u'-');\n    }\n    if (precision == 0) {\n        result.append(u\"0E+0\", -1);\n        return result;\n    }\n    int32_t upperPos = std::min(precision + scale, lOptPos) - scale - 1;\n    int32_t lowerPos = std::max(scale, rOptPos) - scale;\n    int32_t p = upperPos;\n    result.append(u'0' + getDigitPos(p));\n    if ((--p) >= lowerPos) {\n        result.append(u'.');\n        for (; p >= lowerPos; p--) {\n            result.append(u'0' + getDigitPos(p));\n        }\n    }\n    result.append(u'E');\n    int32_t _scale = upperPos + scale;\n    if (_scale < 0) {\n        _scale *= -1;\n        result.append(u'-');\n    } else {\n        result.append(u'+');\n    }\n    if (_scale == 0) {\n        result.append(u'0');\n    }\n    int32_t insertIndex = result.length();\n    while (_scale > 0) {\n        std::div_t res = std::div(_scale, 10);\n        result.insert(insertIndex, u'0' + res.rem);\n        _scale = res.quot;\n    }\n    return result;\n}", "target": 1}
{"code": "static void validate_dex_header(const dex_header* dh,\n                                size_t dexsize,\n                                int support_dex_version) {\n  bool supported = false;\n  switch (support_dex_version) {\n  case 38:\n    supported = supported ||\n                !memcmp(dh->magic, DEX_HEADER_DEXMAGIC_V38, sizeof(dh->magic));\n    FALLTHROUGH_INTENDED; \n  case 37:\n    supported = supported ||\n                !memcmp(dh->magic, DEX_HEADER_DEXMAGIC_V37, sizeof(dh->magic));\n    FALLTHROUGH_INTENDED; \n  case 35:\n    supported = supported ||\n                !memcmp(dh->magic, DEX_HEADER_DEXMAGIC_V35, sizeof(dh->magic));\n    break;\n  default:\n    not_reached_log(\"Unrecognized support_dex_version %d\\n\",\n                    support_dex_version);\n  }\n  always_assert_log(supported, \"Bad dex magic %s for support_dex_version %d\\n\",\n                    dh->magic, support_dex_version);\n  always_assert_log(\n      dh->file_size == dexsize,\n      \"Reported size in header (%zu) does not match file size (%u)\\n\",\n      dexsize,\n      dh->file_size);\n  auto off = (uint64_t)dh->class_defs_off;\n  auto limit = off + dh->class_defs_size * sizeof(dex_class_def);\n  always_assert_log(off < dexsize, \"class_defs_off out of range\");\n  always_assert_log(limit <= dexsize, \"invalid class_defs_size\");\n}", "target": 1}
{"code": "TEE_Result syscall_authenc_init(unsigned long state, const void *nonce,\n\t\t\tsize_t nonce_len, size_t tag_len,\n\t\t\tsize_t aad_len, size_t payload_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\tstruct tee_cryp_obj_secret *key;\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)nonce, nonce_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx), cs->key1, &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\tkey = o->attr;\n\tres = crypto_authenc_init(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t  (uint8_t *)(key + 1), key->key_size,\n\t\t\t\t  nonce, nonce_len, tag_len, aad_len,\n\t\t\t\t  payload_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tcs->ctx_finalize = (tee_cryp_ctx_finalize_func_t)crypto_authenc_final;\n\tcs->state = CRYP_STATE_INITIALIZED;\n\treturn TEE_SUCCESS;\n}", "target": 0}
{"code": "test_compare_files (const char* tgt, const char *rec)\n{\n  FILE *orig, *recons;\n  static uint8_t obuf[TESTBUFSIZE], rbuf[TESTBUFSIZE];\n  xoff_t offset = 0;\n  size_t i;\n  size_t oc, rc;\n  xoff_t diffs = 0;\n  if ((orig = fopen (tgt, \"r\")) == NULL)\n    {\n      XPR(NT \"open %s failed\\n\", tgt);\n      return get_errno ();\n    }\n  if ((recons = fopen (rec, \"r\")) == NULL)\n    {\n      XPR(NT \"open %s failed\\n\", rec);\n      return get_errno ();\n    }\n  for (;;)\n    {\n      oc = fread (obuf, 1, TESTBUFSIZE, orig);\n      rc = fread (rbuf, 1, TESTBUFSIZE, recons);\n      if (oc != rc)\n\t{\n\t  return XD3_INTERNAL;\n\t}\n      if (oc == 0)\n\t{\n\t  break;\n\t}\n      for (i = 0; i < oc; i += 1)\n\t{\n\t  if (obuf[i] != rbuf[i])\n \t    {\n\t      XPR(NT \"byte %u (read %u @ %\"Q\"u) %d != %d\\n\", \n\t\t  (int)i, (int)oc, offset, obuf[i], rbuf[i]);\n\t      diffs++;\n\t      return XD3_INTERNAL;\n\t    }\n\t}\n      offset += oc;\n    }\n    fclose (orig);\n    fclose (recons);\n    if (diffs != 0) \n      {\n\treturn XD3_INTERNAL;\n      }\n    return 0;\n}", "target": 1}
{"code": "int nego_recv(rdpTransport* transport, wStream* s, void* extra)\n{\n\tBYTE li;\n\tBYTE type;\n\tUINT16 length;\n\trdpNego* nego = (rdpNego*)extra;\n\tif (!tpkt_read_header(s, &length))\n\t\treturn -1;\n\tif (!tpdu_read_connection_confirm(s, &li, length))\n\t\treturn -1;\n\tif (li > 6)\n\t{\n\t\tStream_Read_UINT8(s, type); \n\t\tswitch (type)\n\t\t{\n\t\t\tcase TYPE_RDP_NEG_RSP:\n\t\t\t\tnego_process_negotiation_response(nego, s);\n\t\t\t\tWLog_DBG(TAG, \"selected_protocol: %\" PRIu32 \"\", nego->SelectedProtocol);\n\t\t\t\tif (nego->SelectedProtocol)\n\t\t\t\t{\n\t\t\t\t\tif ((nego->SelectedProtocol == PROTOCOL_HYBRID) &&\n\t\t\t\t\t    (!nego->EnabledProtocols[PROTOCOL_HYBRID]))\n\t\t\t\t\t{\n\t\t\t\t\t\tnego->state = NEGO_STATE_FAIL;\n\t\t\t\t\t}\n\t\t\t\t\tif ((nego->SelectedProtocol == PROTOCOL_SSL) &&\n\t\t\t\t\t    (!nego->EnabledProtocols[PROTOCOL_SSL]))\n\t\t\t\t\t{\n\t\t\t\t\t\tnego->state = NEGO_STATE_FAIL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (!nego->EnabledProtocols[PROTOCOL_RDP])\n\t\t\t\t{\n\t\t\t\t\tnego->state = NEGO_STATE_FAIL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TYPE_RDP_NEG_FAILURE:\n\t\t\t\tnego_process_negotiation_failure(nego, s);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\telse if (li == 6)\n\t{\n\t\tWLog_DBG(TAG, \"no rdpNegData\");\n\t\tif (!nego->EnabledProtocols[PROTOCOL_RDP])\n\t\t\tnego->state = NEGO_STATE_FAIL;\n\t\telse\n\t\t\tnego->state = NEGO_STATE_FINAL;\n\t}\n\telse\n\t{\n\t\tWLog_ERR(TAG, \"invalid negotiation response\");\n\t\tnego->state = NEGO_STATE_FAIL;\n\t}\n\tif (!tpkt_ensure_stream_consumed(s, length))\n\t\treturn -1;\n\treturn 0;\n}", "target": 1}
{"code": "unicode_log2vis (PyUnicodeObject* string,\n                 FriBidiParType base_direction, int clean, int reordernsm)\n{\n    int i;\n    int length = string->length;\n    FriBidiChar *logical = NULL; \n    FriBidiChar *visual = NULL;      \n    FriBidiStrIndex new_len = 0; \n    PyUnicodeObject *result = NULL;\n    logical = PyMem_New (FriBidiChar, length + 1);\n    if (logical == NULL) {\n        PyErr_NoMemory();\n        goto cleanup;\n    }\n    visual = PyMem_New (FriBidiChar, length + 1);\n    if (visual == NULL) {\n        PyErr_NoMemory();\n        goto cleanup;\n    }\n    for (i=0; i<length; ++i) {\n        logical[i] = string->str[i];\n    }\n    fribidi_set_reorder_nsm(reordernsm);\n    if (!fribidi_log2vis (logical, length, &base_direction, visual,\n                          NULL, NULL, NULL)) {\n        PyErr_SetString (PyExc_RuntimeError,\n                         \"fribidi failed to order string\");\n        goto cleanup;\n    }\n    if (clean) {\n        length = fribidi_remove_bidi_marks (visual, length, NULL, NULL, NULL);\n    }\n    result = (PyUnicodeObject*) PyUnicode_FromUnicode(NULL, length);\n    if (result == NULL) {\n        goto cleanup;\n    }\n    for (i=0; i<length; ++i) {\n        result->str[i] = visual[i];\n    }\n  cleanup:\n    PyMem_Del (logical);\n    PyMem_Del (visual);\n    return (PyObject *)result;\n}", "target": 0}
{"code": "static handler_t wstunnel_create_env(gw_handler_ctx *gwhctx) {\n    handler_ctx *hctx = (handler_ctx *)gwhctx;\n    request_st * const r = hctx->gw.r;\n    handler_t rc;\n    if (0 == r->reqbody_length || r->http_version > HTTP_VERSION_1_1) {\n        http_response_upgrade_read_body_unknown(r);\n        chunkqueue_append_chunkqueue(&r->reqbody_queue, &r->read_queue);\n    }\n    rc = mod_wstunnel_handshake_create_response(hctx);\n    if (rc != HANDLER_GO_ON) return rc;\n    r->http_status = (r->http_version > HTTP_VERSION_1_1)\n      ? 200  \n      : 101; \n    r->resp_body_started = 1;\n    hctx->ping_ts = log_monotonic_secs;\n    gw_set_transparent(&hctx->gw);\n    return HANDLER_GO_ON;\n}", "target": 0}
{"code": "static ssize_t module_gzip_decompress(struct load_info *info,\n\t\t\t\t      const void *buf, size_t size)\n{\n\tstruct z_stream_s s = { 0 };\n\tsize_t new_size = 0;\n\tsize_t gzip_hdr_len;\n\tssize_t retval;\n\tint rc;\n\tgzip_hdr_len = module_gzip_header_len(buf, size);\n\tif (!gzip_hdr_len) {\n\t\tpr_err(\"not a gzip compressed module\\n\");\n\t\treturn -EINVAL;\n\t}\n\ts.next_in = buf + gzip_hdr_len;\n\ts.avail_in = size - gzip_hdr_len;\n\ts.workspace = kmalloc(zlib_inflate_workspacesize(), GFP_KERNEL);\n\tif (!s.workspace)\n\t\treturn -ENOMEM;\n\trc = zlib_inflateInit2(&s, -MAX_WBITS);\n\tif (rc != Z_OK) {\n\t\tpr_err(\"failed to initialize decompressor: %d\\n\", rc);\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\tdo {\n\t\tstruct page *page = module_get_next_page(info);\n\t\tif (!page) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out_inflate_end;\n\t\t}\n\t\ts.next_out = kmap_local_page(page);\n\t\ts.avail_out = PAGE_SIZE;\n\t\trc = zlib_inflate(&s, 0);\n\t\tkunmap_local(s.next_out);\n\t\tnew_size += PAGE_SIZE - s.avail_out;\n\t} while (rc == Z_OK);\n\tif (rc != Z_STREAM_END) {\n\t\tpr_err(\"decompression failed with status %d\\n\", rc);\n\t\tretval = -EINVAL;\n\t\tgoto out_inflate_end;\n\t}\n\tretval = new_size;\nout_inflate_end:\n\tzlib_inflateEnd(&s);\nout:\n\tkfree(s.workspace);\n\treturn retval;\n}", "target": 1}
{"code": "lt_dlhandle_fetch (lt_dlinterface_id iface, const char *module_name)\n{\n  lt_dlhandle handle = 0;\n  assert (iface); \n  while ((handle = lt_dlhandle_iterate (iface, handle)))\n    {\n      lt_dlhandle cur = handle;\n      if (cur && cur->info.name && streq (cur->info.name, module_name))\n\tbreak;\n    }\n  return handle;\n}", "target": 0}
{"code": "findNextBorderPixel(l_int32    w,\n                    l_int32    h,\n                    l_uint32  *data,\n                    l_int32    wpl,\n                    l_int32    px,\n                    l_int32    py,\n                    l_int32   *pqpos,\n                    l_int32   *pnpx,\n                    l_int32   *pnpy)\n{\nl_int32    qpos, i, pos, npx, npy, val;\nl_uint32  *line;\n    qpos = *pqpos;\n    for (i = 1; i < 8; i++) {\n        pos = (qpos + i) % 8;\n        npx = px + xpostab[pos];\n        npy = py + ypostab[pos];\n        if (npx < 0 || npx >= w || npy < 0 || npy >= h)\n            continue;\n        line = data + npy * wpl;\n        val = GET_DATA_BIT(line, npx);\n        if (val) {\n            *pnpx = npx;\n            *pnpy = npy;\n            *pqpos = qpostab[pos];\n            return 0;\n        }\n    }\n    return 1;\n}", "target": 0}
{"code": "process_add_smartcard_key(SocketEntry *e)\n{\n\tchar *provider = NULL, *pin;\n\tint r, i, version, count = 0, success = 0, confirm = 0;\n\tu_int seconds;\n\ttime_t death = 0;\n\tu_char type;\n\tstruct sshkey **keys = NULL, *k;\n\tIdentity *id;\n\tIdtab *tab;\n\tif ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\twhile (sshbuf_len(e->request)) {\n\t\tif ((r = sshbuf_get_u8(e->request, &type)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tswitch (type) {\n\t\tcase SSH_AGENT_CONSTRAIN_LIFETIME:\n\t\t\tif ((r = sshbuf_get_u32(e->request, &seconds)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tdeath = monotime() + seconds;\n\t\t\tbreak;\n\t\tcase SSH_AGENT_CONSTRAIN_CONFIRM:\n\t\t\tconfirm = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"process_add_smartcard_key: \"\n\t\t\t    \"Unknown constraint type %d\", type);\n\t\t\tgoto send;\n\t\t}\n\t}\n\tif (lifetime && !death)\n\t\tdeath = monotime() + lifetime;\n\tcount = pkcs11_add_provider(provider, pin, &keys);\n\tfor (i = 0; i < count; i++) {\n\t\tk = keys[i];\n\t\tversion = k->type == KEY_RSA1 ? 1 : 2;\n\t\ttab = idtab_lookup(version);\n\t\tif (lookup_identity(k, version) == NULL) {\n\t\t\tid = xcalloc(1, sizeof(Identity));\n\t\t\tid->key = k;\n\t\t\tid->provider = xstrdup(provider);\n\t\t\tid->comment = xstrdup(provider); \n\t\t\tid->death = death;\n\t\t\tid->confirm = confirm;\n\t\t\tTAILQ_INSERT_TAIL(&tab->idlist, id, next);\n\t\t\ttab->nentries++;\n\t\t\tsuccess = 1;\n\t\t} else {\n\t\t\tsshkey_free(k);\n\t\t}\n\t\tkeys[i] = NULL;\n\t}\nsend:\n\tfree(pin);\n\tfree(provider);\n\tfree(keys);\n\tsend_status(e, success);\n}", "target": 1}
{"code": "void sctp_association_free(struct sctp_association *asoc)\n{\n\tstruct sock *sk = asoc->base.sk;\n\tstruct sctp_transport *transport;\n\tstruct list_head *pos, *temp;\n\tint i;\n\tif (!asoc->temp) {\n\t\tlist_del(&asoc->asocs);\n\t\tif (sctp_style(sk, TCP) && sctp_sstate(sk, LISTENING))\n\t\t\tsk->sk_ack_backlog--;\n\t}\n\tasoc->base.dead = true;\n\tsctp_outq_free(&asoc->outqueue);\n\tsctp_ulpq_free(&asoc->ulpq);\n\tsctp_inq_free(&asoc->base.inqueue);\n\tsctp_tsnmap_free(&asoc->peer.tsn_map);\n\tsctp_ssnmap_free(asoc->ssnmap);\n\tsctp_bind_addr_free(&asoc->base.bind_addr);\n\tfor (i = SCTP_EVENT_TIMEOUT_NONE; i < SCTP_NUM_TIMEOUT_TYPES; ++i) {\n\t\tif (del_timer(&asoc->timers[i]))\n\t\t\tsctp_association_put(asoc);\n\t}\n\tkfree(asoc->peer.cookie);\n\tkfree(asoc->peer.peer_random);\n\tkfree(asoc->peer.peer_chunks);\n\tkfree(asoc->peer.peer_hmacs);\n\tlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {\n\t\ttransport = list_entry(pos, struct sctp_transport, transports);\n\t\tlist_del_rcu(pos);\n\t\tsctp_transport_free(transport);\n\t}\n\tasoc->peer.transport_count = 0;\n\tsctp_asconf_queue_teardown(asoc);\n\tif (asoc->asconf_addr_del_pending != NULL)\n\t\tkfree(asoc->asconf_addr_del_pending);\n\tsctp_auth_destroy_keys(&asoc->endpoint_shared_keys);\n\tsctp_auth_key_put(asoc->asoc_shared_key);\n\tsctp_association_put(asoc);\n}", "target": 1}
{"code": "static avifBool avifParseImageGridBox(avifImageGrid * grid, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n    uint8_t version, flags;\n    CHECK(avifROStreamRead(&s, &version, 1)); \n    if (version != 0) {\n        return AVIF_FALSE;\n    }\n    CHECK(avifROStreamRead(&s, &flags, 1));         \n    CHECK(avifROStreamRead(&s, &grid->rows, 1));    \n    CHECK(avifROStreamRead(&s, &grid->columns, 1)); \n    ++grid->rows;\n    ++grid->columns;\n    uint32_t fieldLength = ((flags & 1) + 1) * 16;\n    if (fieldLength == 16) {\n        uint16_t outputWidth16, outputHeight16;\n        CHECK(avifROStreamReadU16(&s, &outputWidth16));  \n        CHECK(avifROStreamReadU16(&s, &outputHeight16)); \n        grid->outputWidth = outputWidth16;\n        grid->outputHeight = outputHeight16;\n    } else {\n        if (fieldLength != 32) {\n            return AVIF_FALSE;\n        }\n        CHECK(avifROStreamReadU32(&s, &grid->outputWidth));  \n        CHECK(avifROStreamReadU32(&s, &grid->outputHeight)); \n    }\n    if (grid->outputWidth > AVIF_MAX_IMAGE_SIZE / grid->outputHeight) {\n        return AVIF_FALSE;\n    }\n    return AVIF_TRUE;\n}", "target": 0}
{"code": "static inline void put_utf16(wchar_t *s, unsigned c, enum utf16_endian endian)\n{\n\tswitch (endian) {\n\tdefault:\n\t\t*s = (wchar_t) c;\n\t\tbreak;\n\tcase UTF16_LITTLE_ENDIAN:\n\t\t*s = __cpu_to_le16(c);\n\t\tbreak;\n\tcase UTF16_BIG_ENDIAN:\n\t\t*s = __cpu_to_be16(c);\n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "static int show_stat(struct kmem_cache *s, char *buf, enum stat_item si)\n{\n\tunsigned long sum  = 0;\n\tint cpu;\n\tint len;\n\tint *data = kmalloc(nr_cpu_ids * sizeof(int), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tfor_each_online_cpu(cpu) {\n\t\tunsigned x = get_cpu_slab(s, cpu)->stat[si];\n\t\tdata[cpu] = x;\n\t\tsum += x;\n\t}\n\tlen = sprintf(buf, \"%lu\", sum);\n#ifdef CONFIG_SMP\n\tfor_each_online_cpu(cpu) {\n\t\tif (data[cpu] && len < PAGE_SIZE - 20)\n\t\t\tlen += sprintf(buf + len, \" C%d=%u\", cpu, data[cpu]);\n\t}\n#endif\n\tkfree(data);\n\treturn len + sprintf(buf + len, \"\\n\");\n}", "target": 0}
{"code": "static void php_ifd_set32u(char *data, size_t value, int motorola_intel)\n{\n\tif (motorola_intel) {\n\t\tdata[0] = (value & 0xFF000000) >> 24;\n\t\tdata[1] = (value & 0x00FF0000) >> 16;\n\t\tdata[2] = (value & 0x0000FF00) >>  8;\n\t\tdata[3] = (value & 0x000000FF);\n\t} else {\n\t\tdata[3] = (value & 0xFF000000) >> 24;\n\t\tdata[2] = (value & 0x00FF0000) >> 16;\n\t\tdata[1] = (value & 0x0000FF00) >>  8;\n\t\tdata[0] = (value & 0x000000FF);\n\t}\n}", "target": 0}
{"code": "static struct epitem *ep_find(struct eventpoll *ep, struct file *file, int fd)\n{\n\tint kcmp;\n\tstruct rb_node *rbp;\n\tstruct epitem *epi, *epir = NULL;\n\tstruct epoll_filefd ffd;\n\tep_set_ffd(&ffd, file, fd);\n\tfor (rbp = ep->rbr.rb_node; rbp; ) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\t\tkcmp = ep_cmp_ffd(&ffd, &epi->ffd);\n\t\tif (kcmp > 0)\n\t\t\trbp = rbp->rb_right;\n\t\telse if (kcmp < 0)\n\t\t\trbp = rbp->rb_left;\n\t\telse {\n\t\t\tepir = epi;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn epir;\n}", "target": 0}
{"code": "OGRKMLLayer::OGRKMLLayer( const char * pszName,\n                          OGRSpatialReference *poSRSIn, bool bWriterIn,\n                          OGRwkbGeometryType eReqType,\n                          OGRKMLDataSource *poDSIn ) :\n    poDS_(poDSIn),\n    poSRS_(poSRSIn ? new OGRSpatialReference(nullptr) : nullptr),\n    poCT_(nullptr),\n    poFeatureDefn_(new OGRFeatureDefn( pszName )),\n    iNextKMLId_(0),\n    nTotalKMLCount_(-1),\n    bWriter_(bWriterIn),\n    nLayerNumber_(0),\n    nWroteFeatureCount_(0),\n    bSchemaWritten_(false),\n    pszName_(CPLStrdup(pszName)),\n    nLastAsked(-1),\n    nLastCount(-1)\n{\n    if( poSRSIn != nullptr )\n    {\n        poSRS_->SetWellKnownGeogCS( \"WGS84\" );\n        poSRS_->SetAxisMappingStrategy(OAMS_TRADITIONAL_GIS_ORDER);\n        if( !poSRS_->IsSame(poSRSIn) )\n        {\n            poCT_ = OGRCreateCoordinateTransformation( poSRSIn, poSRS_ );\n            if( poCT_ == nullptr && poDSIn->IsFirstCTError() )\n            {\n                char *pszWKT = nullptr;\n                poSRSIn->exportToPrettyWkt( &pszWKT, FALSE );\n                CPLError(\n                    CE_Warning, CPLE_AppDefined,\n                    \"Failed to create coordinate transformation between the \"\n                    \"input coordinate system and WGS84.  This may be because \"\n                    \"they are not transformable.  \"\n                    \"KML geometries may not render correctly.  \"\n                    \"This message will not be issued any more.\"\n                    \"\\nSource:\\n%s\\n\",\n                    pszWKT );\n                CPLFree( pszWKT );\n                poDSIn->IssuedFirstCTError();\n            }\n        }\n    }\n    SetDescription( poFeatureDefn_->GetName() );\n    poFeatureDefn_->Reference();\n    poFeatureDefn_->SetGeomType( eReqType );\n    if( poFeatureDefn_->GetGeomFieldCount() != 0 )\n        poFeatureDefn_->GetGeomFieldDefn(0)->SetSpatialRef(poSRS_);\n    OGRFieldDefn oFieldName( \"Name\", OFTString );\n    poFeatureDefn_->AddFieldDefn( &oFieldName );\n    OGRFieldDefn oFieldDesc( \"Description\", OFTString );\n    poFeatureDefn_->AddFieldDefn( &oFieldDesc );\n    bClosedForWriting = !bWriterIn;\n}", "target": 0}
{"code": "static void php_array_merge_recursive(PointerSet &seen, bool check,\n                                      Array &arr1, const Array& arr2) {\n  if (check && !seen.insert((void*)arr1.get()).second) {\n    raise_warning(\"array_merge_recursive(): recursion detected\");\n    return;\n  }\n  for (ArrayIter iter(arr2); iter; ++iter) {\n    Variant key(iter.first());\n    const Variant& value(iter.secondRef());\n    if (key.isNumeric()) {\n      arr1.appendWithRef(value);\n    } else if (arr1.exists(key, true)) {\n      Variant &v = arr1.lvalAt(key, AccessFlags::Key);\n      auto subarr1 = v.toArray().copy();\n      php_array_merge_recursive(seen,\n                                couldRecur(v, subarr1.get()),\n                                subarr1,\n                                value.toArray());\n      v.unset(); \n      v = subarr1;\n    } else {\n      arr1.setWithRef(key, value, true);\n    }\n  }\n  if (check) {\n    seen.erase((void*)arr1.get());\n  }\n}", "target": 0}
{"code": "static unsigned int unix_dgram_poll(struct file *file, struct socket *sock,\n\t\t\t\t    poll_table *wait)\n{\n\tstruct sock *sk = sock->sk, *other;\n\tunsigned int mask, writable;\n\tsock_poll_wait(file, sk_sleep(sk), wait);\n\tmask = 0;\n\tif (sk->sk_err || !skb_queue_empty(&sk->sk_error_queue))\n\t\tmask |= POLLERR |\n\t\t\t(sock_flag(sk, SOCK_SELECT_ERR_QUEUE) ? POLLPRI : 0);\n\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\tmask |= POLLRDHUP | POLLIN | POLLRDNORM;\n\tif (sk->sk_shutdown == SHUTDOWN_MASK)\n\t\tmask |= POLLHUP;\n\tif (!skb_queue_empty(&sk->sk_receive_queue))\n\t\tmask |= POLLIN | POLLRDNORM;\n\tif (sk->sk_type == SOCK_SEQPACKET) {\n\t\tif (sk->sk_state == TCP_CLOSE)\n\t\t\tmask |= POLLHUP;\n\t\tif (sk->sk_state == TCP_SYN_SENT)\n\t\t\treturn mask;\n\t}\n\tif (!(poll_requested_events(wait) & (POLLWRBAND|POLLWRNORM|POLLOUT)))\n\t\treturn mask;\n\twritable = unix_writable(sk);\n\tother = unix_peer_get(sk);\n\tif (other) {\n\t\tif (unix_peer(other) != sk) {\n\t\t\tsock_poll_wait(file, &unix_sk(other)->peer_wait, wait);\n\t\t\tif (unix_recvq_full(other))\n\t\t\t\twritable = 0;\n\t\t}\n\t\tsock_put(other);\n\t}\n\tif (writable)\n\t\tmask |= POLLOUT | POLLWRNORM | POLLWRBAND;\n\telse\n\t\tset_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags);\n\treturn mask;\n}", "target": 1}
{"code": "inline int NumInputs(const TfLiteNode* node) { return node->inputs->size; }", "target": 1}
{"code": "static int __init net_secret_init(void)\n{\n\tget_random_bytes(net_secret, sizeof(net_secret));\n\treturn 0;\n}", "target": 0}
{"code": "static void vmx_complete_atomic_exit(struct vcpu_vmx *vmx)\n{\n\tu32 exit_intr_info;\n\tif (!(vmx->exit_reason == EXIT_REASON_MCE_DURING_VMENTRY\n\t      || vmx->exit_reason == EXIT_REASON_EXCEPTION_NMI))\n\t\treturn;\n\tvmx->exit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\texit_intr_info = vmx->exit_intr_info;\n\tif (is_machine_check(exit_intr_info))\n\t\tkvm_machine_check();\n\tif ((exit_intr_info & INTR_INFO_INTR_TYPE_MASK) == INTR_TYPE_NMI_INTR &&\n\t    (exit_intr_info & INTR_INFO_VALID_MASK)) {\n\t\tkvm_before_handle_nmi(&vmx->vcpu);\n\t\tasm(\"int $2\");\n\t\tkvm_after_handle_nmi(&vmx->vcpu);\n\t}\n}", "target": 1}
{"code": "AP4_HdlrAtom::AP4_HdlrAtom(AP4_UI32        size, \n                           AP4_UI08        version,\n                           AP4_UI32        flags,\n                           AP4_ByteStream& stream) :\n    AP4_Atom(AP4_ATOM_TYPE_HDLR, size, version, flags)\n{\n    AP4_UI32 predefined;\n    stream.ReadUI32(predefined);\n    stream.ReadUI32(m_HandlerType);\n    stream.ReadUI32(m_Reserved[0]);\n    stream.ReadUI32(m_Reserved[1]);\n    stream.ReadUI32(m_Reserved[2]);\n    int name_size = size-(AP4_FULL_ATOM_HEADER_SIZE+20);\n    if (name_size == 0) return;\n    char* name = new char[name_size+1];\n    stream.Read(name, name_size);\n    name[name_size] = '\\0'; \n    if (name[0] == name_size-1) {\n        m_HandlerName = name+1;\n    } else {\n        m_HandlerName = name;\n    }\n    delete[] name;\n}", "target": 1}
{"code": "get_word_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n  register int rindex = rgb_red[cinfo->in_color_space];\n  register int gindex = rgb_green[cinfo->in_color_space];\n  register int bindex = rgb_blue[cinfo->in_color_space];\n  register int aindex = alpha_index[cinfo->in_color_space];\n  register int ps = rgb_pixelsize[cinfo->in_color_space];\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    register unsigned int temp;\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    ptr[rindex] = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    ptr[gindex] = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    ptr[bindex] = rescale[temp];\n    if (aindex >= 0)\n      ptr[aindex] = 0xFF;\n    ptr += ps;\n  }\n  return 1;\n}", "target": 0}
{"code": "int anon_vma_clone(struct vm_area_struct *dst, struct vm_area_struct *src)\n{\n\tstruct anon_vma_chain *avc, *pavc;\n\tstruct anon_vma *root = NULL;\n\tlist_for_each_entry_reverse(pavc, &src->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma;\n\t\tavc = anon_vma_chain_alloc(GFP_NOWAIT | __GFP_NOWARN);\n\t\tif (unlikely(!avc)) {\n\t\t\tunlock_anon_vma_root(root);\n\t\t\troot = NULL;\n\t\t\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\t\t\tif (!avc)\n\t\t\t\tgoto enomem_failure;\n\t\t}\n\t\tanon_vma = pavc->anon_vma;\n\t\troot = lock_anon_vma_root(root, anon_vma);\n\t\tanon_vma_chain_link(dst, avc, anon_vma);\n\t\tif (!dst->anon_vma && src->anon_vma &&\n\t\t    anon_vma != src->anon_vma && anon_vma->degree < 2)\n\t\t\tdst->anon_vma = anon_vma;\n\t}\n\tif (dst->anon_vma)\n\t\tdst->anon_vma->degree++;\n\tunlock_anon_vma_root(root);\n\treturn 0;\n enomem_failure:\n\tdst->anon_vma = NULL;\n\tunlink_anon_vmas(dst);\n\treturn -ENOMEM;\n}", "target": 1}
{"code": "TfLiteStatus EvalSimple(TfLiteContext* context, TfLiteNode* node,\n                        const TfLiteTensor* lookup, const TfLiteTensor* value,\n                        TfLiteTensor* output) {\n  const int row_size = SizeOfDimension(value, 0);\n  if (row_size == 0) {\n    return kTfLiteOk;\n  }\n  const int row_bytes = value->bytes / row_size;\n  char* output_raw = GetTensorData<char>(output);\n  const char* value_raw = GetTensorData<char>(value);\n  const int32_t* lookup_data = GetTensorData<int32_t>(lookup);\n  for (int i = 0; i < SizeOfDimension(lookup, 0); i++) {\n    int idx = lookup_data[i];\n    if (idx >= row_size || idx < 0) {\n      context->ReportError(context,\n                           \"Embedding Lookup: index out of bounds. \"\n                           \"Got %d, and bounds are [0, %d]\",\n                           idx, row_size - 1);\n      return kTfLiteError;\n    } else {\n      std::memcpy(output_raw + i * row_bytes, value_raw + idx * row_bytes,\n                  row_bytes);\n    }\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "static int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n#if 0\n\tjp2_pclr_t *pclr = &box->data.pclr;\n#endif\nbox = 0;\nout = 0;\n\treturn -1;\n}", "target": 1}
{"code": "static void handleOutputMode(void* data, struct wl_output* wl_output, uint32_t flags, int32_t width, int32_t height, int32_t refresh) {\n    const auto POUTPUT = (SOutput*)data;\n    POUTPUT->refreshRate = std::round(refresh / 1000.0);\n}", "target": 1}
{"code": "static int hwsim_new_radio_nl(struct sk_buff *msg, struct genl_info *info)\n{\n\tstruct hwsim_new_radio_params param = { 0 };\n\tconst char *hwname = NULL;\n\tint ret;\n\tparam.reg_strict = info->attrs[HWSIM_ATTR_REG_STRICT_REG];\n\tparam.p2p_device = info->attrs[HWSIM_ATTR_SUPPORT_P2P_DEVICE];\n\tparam.channels = channels;\n\tparam.destroy_on_close =\n\t\tinfo->attrs[HWSIM_ATTR_DESTROY_RADIO_ON_CLOSE];\n\tif (info->attrs[HWSIM_ATTR_CHANNELS])\n\t\tparam.channels = nla_get_u32(info->attrs[HWSIM_ATTR_CHANNELS]);\n\tif (info->attrs[HWSIM_ATTR_NO_VIF])\n\t\tparam.no_vif = true;\n\tif (info->attrs[HWSIM_ATTR_RADIO_NAME]) {\n\t\thwname = kasprintf(GFP_KERNEL, \"%.*s\",\n\t\t\t\t   nla_len(info->attrs[HWSIM_ATTR_RADIO_NAME]),\n\t\t\t\t   (char *)nla_data(info->attrs[HWSIM_ATTR_RADIO_NAME]));\n\t\tif (!hwname)\n\t\t\treturn -ENOMEM;\n\t\tparam.hwname = hwname;\n\t}\n\tif (info->attrs[HWSIM_ATTR_USE_CHANCTX])\n\t\tparam.use_chanctx = true;\n\telse\n\t\tparam.use_chanctx = (param.channels > 1);\n\tif (info->attrs[HWSIM_ATTR_REG_HINT_ALPHA2])\n\t\tparam.reg_alpha2 =\n\t\t\tnla_data(info->attrs[HWSIM_ATTR_REG_HINT_ALPHA2]);\n\tif (info->attrs[HWSIM_ATTR_REG_CUSTOM_REG]) {\n\t\tu32 idx = nla_get_u32(info->attrs[HWSIM_ATTR_REG_CUSTOM_REG]);\n\t\tif (idx >= ARRAY_SIZE(hwsim_world_regdom_custom))\n\t\t\treturn -EINVAL;\n\t\tparam.regd = hwsim_world_regdom_custom[idx];\n\t}\n\tret = mac80211_hwsim_new_radio(info, &param);\n\tkfree(hwname);\n\treturn ret;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    Tensor encoded_t = context->input(0);\n    OP_REQUIRES(\n        context, encoded_t.flat<Variant>().size() > 0,\n        errors::InvalidArgument(\"Input `encoded` must not be an empty variant \"\n                                \"tensor, but got \",\n                                encoded_t.DebugString()));\n    auto* encoded = encoded_t.flat<Variant>()(0).get<CompositeTensorVariant>();\n    OP_REQUIRES(context, encoded != nullptr,\n                errors::InvalidArgument(\"The input `encoded` is not a valid \"\n                                        \"CompositeTensorVariant tensor, got \",\n                                        encoded_t.DebugString()));\n    auto expected_class = metadata_.type_spec_proto().type_spec_class();\n    auto actual_class = encoded->metadata().type_spec_proto().type_spec_class();\n    OP_REQUIRES(\n        context, expected_class == actual_class,\n        errors::InvalidArgument(\n            \"Expected a \", TypeSpecProto::TypeSpecClass_Name(expected_class),\n            \" (based on `type_spec`), but `encoded` contains a \",\n            TypeSpecProto::TypeSpecClass_Name(actual_class)));\n    OpOutputList components;\n    OP_REQUIRES_OK(context, context->output_list(\"components\", &components));\n    int num_components = encoded->flat_components().size();\n    OP_REQUIRES(context, component_dtypes_.size() == num_components,\n                errors::InvalidArgument(\"Encoded value has \", num_components,\n                                        \" tensor components; expected \",\n                                        component_dtypes_.size(),\n                                        \" components based on type_spec\"));\n    for (int i = 0; i < component_dtypes_.size(); i++) {\n      const Tensor& component = encoded->flat_components()[i];\n      OP_REQUIRES(context, component_dtypes_[i] == component.dtype(),\n                  errors::InvalidArgument(\"Tensor component \", i, \" had dtype \",\n                                          DataType_Name(component.dtype()),\n                                          \"; expected dtype \",\n                                          DataType_Name(component_dtypes_[i])));\n      components.set(i, component);\n    }\n  }", "target": 0}
{"code": "static void *HTPStateGetTx(void *alstate, uint64_t tx_id)\n{\n    HtpState *http_state = (HtpState *)alstate;\n    if (http_state != NULL && http_state->conn != NULL)\n        return htp_list_get(http_state->conn->transactions, tx_id);\n    else\n        return NULL;\n}", "target": 1}
{"code": "daemon_linux_lvm2_vg_add_pv (Daemon *daemon,\n                             const gchar *uuid,\n                             const gchar *object_path,\n                             gchar **options,\n                             DBusGMethodInvocation *context)\n{\n  daemon_local_check_auth (daemon,\n                           NULL,\n                           \"org.freedesktop.udisks.linux-lvm2\",\n                           \"LinuxLvm2VGAddPV\",\n                           TRUE,\n                           daemon_linux_lvm2_vg_add_pv_authorized_cb,\n                           context,\n                           3,\n                           g_strdup (uuid),\n                           g_free,\n                           g_strdup (object_path),\n                           g_free,\n                           g_strdupv (options),\n                           g_strfreev);\n  return TRUE;\n}", "target": 0}
{"code": "void SFS_ObjectMethodCall(ScriptParser *parser)\n{\n\tif (parser->codec->LastError) return;\n\tSFS_Expression(parser);\n\tif (parser->codec->LastError) return;\n\tSFS_AddString(parser, \".\");\n\tSFS_Identifier(parser);\n\tSFS_AddString(parser, \"(\");\n\tSFS_Params(parser);\n\tSFS_AddString(parser, \")\");\n}", "target": 0}
{"code": "static void bt_for_each(struct blk_mq_hw_ctx *hctx,\n\t\tstruct blk_mq_bitmap_tags *bt, unsigned int off,\n\t\tbusy_iter_fn *fn, void *data, bool reserved)\n{\n\tstruct request *rq;\n\tint bit, i;\n\tfor (i = 0; i < bt->map_nr; i++) {\n\t\tstruct blk_align_bitmap *bm = &bt->map[i];\n\t\tfor (bit = find_first_bit(&bm->word, bm->depth);\n\t\t     bit < bm->depth;\n\t\t     bit = find_next_bit(&bm->word, bm->depth, bit + 1)) {\n\t\t     \trq = blk_mq_tag_to_rq(hctx->tags, off + bit);\n\t\t\tif (rq->q == hctx->queue)\n\t\t\t\tfn(hctx, rq, data, reserved);\n\t\t}\n\t\toff += (1 << bt->bits_per_word);\n\t}\n}", "target": 1}
{"code": "bool IsRelativeSymlinkSafe(CommandData *Cmd,const wchar *SrcName,const wchar *PrepSrcName,const wchar *TargetName)\n{\n  if (IsFullRootPath(SrcName) || IsFullRootPath(TargetName))\n    return false;\n  int UpLevels=0;\n  for (int Pos=0;*TargetName!=0;Pos++)\n  {\n    bool Dot2=TargetName[0]=='.' && TargetName[1]=='.' && \n              (IsPathDiv(TargetName[2]) || TargetName[2]==0) &&\n              (Pos==0 || IsPathDiv(*(TargetName-1)));\n    if (Dot2)\n      UpLevels++;\n    TargetName++;\n  }\n  if (UpLevels>0 && LinkInPath(PrepSrcName))\n    return false;\n  int AllowedDepth=CalcAllowedDepth(SrcName); \n  size_t ExtrPathLength=wcslen(Cmd->ExtrPath);\n  if (ExtrPathLength>0 && wcsncmp(PrepSrcName,Cmd->ExtrPath,ExtrPathLength)==0)\n  {\n    PrepSrcName+=ExtrPathLength;\n    while (IsPathDiv(*PrepSrcName))\n      PrepSrcName++;\n  }\n  int PrepAllowedDepth=CalcAllowedDepth(PrepSrcName);\n  return AllowedDepth>=UpLevels && PrepAllowedDepth>=UpLevels;\n}", "target": 1}
{"code": "static void split_certinfo(char *string, zval *hash)\n{\n\tchar *org = estrdup(string);\n\tchar *s = org;\n\tchar *split;\n\tif(org) {\n\t\tdo {\n\t\t\tchar *key;\n\t\t\tchar *val;\n\t\t\tchar *tmp;\n\t\t\tsplit = strstr(s, \"; \");\n\t\t\tif(split)\n\t\t\t\t*split = '\\0';\n\t\t\tkey = s;\n\t\t\ttmp = memchr(key, '=', 64);\n\t\t\tif(tmp) {\n\t\t\t\t*tmp = '\\0';\n\t\t\t\tval = tmp+1;\n\t\t\t\tadd_assoc_string(hash, key, val, 1);\n\t\t\t}\n\t\t\ts = split+2;\n\t\t} while(split);\n\t\tefree(org);\n\t}\n}", "target": 0}
{"code": "int LibRaw::subtract_black()\n{\n\tCHECK_ORDER_LOW(LIBRAW_PROGRESS_RAW2_IMAGE);\n\ttry {\n    if(!is_phaseone_compressed() && (C.cblack[0] || C.cblack[1] || C.cblack[2] || C.cblack[3]))\n        {\n#define BAYERC(row,col,c) imgdata.image[((row) >> IO.shrink)*S.iwidth + ((col) >> IO.shrink)][c] \n            int cblk[4],i;\n            for(i=0;i<4;i++)\n                cblk[i] = C.cblack[i];\n            int size = S.iheight * S.iwidth;\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n#define MAX(a,b) ((a) > (b) ? (a) : (b))\n#define LIM(x,min,max) MAX(min,MIN(x,max))\n#define CLIP(x) LIM(x,0,65535)\n            for(i=0; i< size*4; i++)\n              {\n                int val = imgdata.image[0][i];\n                val -= cblk[i & 3];\n                imgdata.image[0][i] = CLIP(val);\n                if(C.data_maximum < val) C.data_maximum = val;\n              }\n#undef MIN\n#undef MAX\n#undef LIM\n#undef CLIP\n            C.maximum -= C.black;\n            ZERO(C.cblack);\n            C.black = 0;\n#undef BAYERC\n        }\n    else\n        {\n          int idx;\n          ushort *p = (ushort*)imgdata.image;\n          C.data_maximum = 0;\n          for(idx=0;idx<S.iheight*S.iwidth*4;idx++)\n            if(C.data_maximum < p[idx]) C.data_maximum = p[idx];\n        }\n\t\treturn 0;\n\t}\n\tcatch ( LibRaw_exceptions err) {\n\t\tEXCEPTION_HANDLER(err);\n\t}\n}", "target": 1}
{"code": "PixarLogClose(TIFF* tif)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\ttd->td_bitspersample = 8;\n\ttd->td_sampleformat = SAMPLEFORMAT_UINT;\n}", "target": 1}
{"code": "int nfs4_proc_fs_locations(struct rpc_clnt *client, struct inode *dir,\n\t\t\t   const struct qstr *name,\n\t\t\t   struct nfs4_fs_locations *fs_locations,\n\t\t\t   struct page *page)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir),\n\t\t\t\t_nfs4_proc_fs_locations(client, dir, name, fs_locations, page),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}", "target": 0}
{"code": "void linsertCommand(client *c) {\n    int where;\n    robj *subject;\n    listTypeIterator *iter;\n    listTypeEntry entry;\n    int inserted = 0;\n    if (strcasecmp(c->argv[2]->ptr,\"after\") == 0) {\n        where = LIST_TAIL;\n    } else if (strcasecmp(c->argv[2]->ptr,\"before\") == 0) {\n        where = LIST_HEAD;\n    } else {\n        addReply(c,shared.syntaxerr);\n        return;\n    }\n    if (sdslen(c->argv[4]->ptr) > LIST_MAX_ITEM_SIZE) {\n        addReplyError(c, \"Element too large\");\n        return;\n    }\n    if ((subject = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||\n        checkType(c,subject,OBJ_LIST)) return;\n    iter = listTypeInitIterator(subject,0,LIST_TAIL);\n    while (listTypeNext(iter,&entry)) {\n        if (listTypeEqual(&entry,c->argv[3])) {\n            listTypeInsert(&entry,c->argv[4],where);\n            inserted = 1;\n            break;\n        }\n    }\n    listTypeReleaseIterator(iter);\n    if (inserted) {\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_LIST,\"linsert\",\n                            c->argv[1],c->db->id);\n        server.dirty++;\n    } else {\n        addReplyLongLong(c,-1);\n        return;\n    }\n    addReplyLongLong(c,listTypeLength(subject));\n}", "target": 0}
{"code": "static struct btrfs_dir_item *btrfs_match_dir_item_name(struct btrfs_root *root,\n\t\t\t      struct btrfs_path *path,\n\t\t\t      const char *name, int name_len)\n{\n\tstruct btrfs_dir_item *dir_item;\n\tunsigned long name_ptr;\n\tu32 total_len;\n\tu32 cur = 0;\n\tu32 this_len;\n\tstruct extent_buffer *leaf;\n\tleaf = path->nodes[0];\n\tdir_item = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_dir_item);\n\tif (verify_dir_item(root, leaf, dir_item))\n\t\treturn NULL;\n\ttotal_len = btrfs_item_size_nr(leaf, path->slots[0]);\n\twhile (cur < total_len) {\n\t\tthis_len = sizeof(*dir_item) +\n\t\t\tbtrfs_dir_name_len(leaf, dir_item) +\n\t\t\tbtrfs_dir_data_len(leaf, dir_item);\n\t\tname_ptr = (unsigned long)(dir_item + 1);\n\t\tif (btrfs_dir_name_len(leaf, dir_item) == name_len &&\n\t\t    memcmp_extent_buffer(leaf, name, name_ptr, name_len) == 0)\n\t\t\treturn dir_item;\n\t\tcur += this_len;\n\t\tdir_item = (struct btrfs_dir_item *)((char *)dir_item +\n\t\t\t\t\t\t     this_len);\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "void DCR_CLASS dcr_cam_xyz_coeff (DCRAW* p, double cam_xyz[4][3])\n{\n\tdouble cam_rgb[4][3], inverse[4][3], num;\n\tint i, j, k;\n\tfor (i=0; i < p->colors; i++)\t\t\n\t\tfor (j=0; j < 3; j++)\n\t\t\tfor (cam_rgb[i][j] = k=0; k < 3; k++)\n\t\t\t\tcam_rgb[i][j] += cam_xyz[i][k] * xyz_rgb[k][j];\n\tfor (i=0; i < p->colors; i++) {\t\t\n\t\tfor (num=j=0; j < 3; j++)\t\t\n\t\t\tnum += cam_rgb[i][j];\n\t\tfor (j=0; j < 3; j++)\n\t\t\tcam_rgb[i][j] /= num;\n\t\tp->pre_mul[i] = 1 / (float)num;\n\t}\n\tdcr_pseudoinverse (cam_rgb, inverse, p->colors);\n\tfor (p->raw_color = i=0; i < 3; i++)\n\t\tfor (j=0; j < p->colors; j++)\n\t\t\tp->rgb_cam[i][j] = (float)inverse[j][i];\n}", "target": 1}
{"code": "void track_set_index(Track *track, int i, long ind)\n{\n\tif (i > MAXINDEX) {\n\t\tfprintf(stderr, \"too many indexes\\n\");\n                return;\n        }\n\ttrack->index[i] = ind;\n}", "target": 1}
{"code": "njs_json_push_parse_state(njs_vm_t *vm, njs_json_parse_t *parse,\n    njs_value_t *value)\n{\n    njs_json_state_t  *state;\n    if (njs_slow_path(parse->depth >= NJS_JSON_MAX_DEPTH)) {\n        njs_type_error(vm, \"Nested too deep or a cyclic structure\");\n        return NULL;\n    }\n    state = &parse->states[parse->depth++];\n    state->value = *value;\n    state->index = 0;\n    state->prop = NULL;\n    state->keys = njs_value_own_enumerate(vm, value, NJS_ENUM_KEYS,\n                                          NJS_ENUM_STRING, 0);\n    if (state->keys == NULL) {\n        return NULL;\n    }\n    return state;\n}", "target": 1}
{"code": "mailimap_mailbox_data_status_free(struct mailimap_mailbox_data_status * info)\n{\n  mailimap_mailbox_free(info->st_mailbox);\n  clist_foreach(info->st_info_list, (clist_func) mailimap_status_info_free,\n\t\t NULL);\n  clist_free(info->st_info_list);\n  free(info);\n}", "target": 1}
{"code": "ssh_packet_get_compress_state(struct sshbuf *m, struct ssh *ssh)\n{\n\tstruct session_state *state = ssh->state;\n\tstruct sshbuf *b;\n\tint r;\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (state->compression_in_started) {\n\t\tif ((r = sshbuf_put_string(b, &state->compression_in_stream,\n\t\t    sizeof(state->compression_in_stream))) != 0)\n\t\t\tgoto out;\n\t} else if ((r = sshbuf_put_string(b, NULL, 0)) != 0)\n\t\tgoto out;\n\tif (state->compression_out_started) {\n\t\tif ((r = sshbuf_put_string(b, &state->compression_out_stream,\n\t\t    sizeof(state->compression_out_stream))) != 0)\n\t\t\tgoto out;\n\t} else if ((r = sshbuf_put_string(b, NULL, 0)) != 0)\n\t\tgoto out;\n\tr = sshbuf_put_stringb(m, b);\n out:\n\tsshbuf_free(b);\n\treturn r;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& shape_t = ctx->input(0);\n    const Tensor& rate_t = ctx->input(1);\n    TensorShape samples_shape;\n    OP_REQUIRES_OK(ctx, tensor::MakeShape(shape_t, &samples_shape));\n    const int64_t num_samples = samples_shape.num_elements();\n    samples_shape.AppendShape(rate_t.shape());\n    Tensor* samples_t = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, samples_shape, &samples_t));\n    if (num_samples == 0) return;\n    const auto rate_flat = rate_t.flat<T>().data();\n    const int64_t num_rate = rate_t.NumElements();\n    auto samples_flat = samples_t->flat<U>().data();\n    random::PhiloxRandom rng = generator_.ReserveRandomOutputs(\n        num_samples * num_rate, kReservedSamplesPerOutput);\n    functor::PoissonFunctor<CPUDevice, T, U>()(\n        ctx, ctx->eigen_device<CPUDevice>(), rate_flat, num_rate, num_samples,\n        rng, samples_flat);\n  }", "target": 1}
{"code": "mark_context_stack(mrb_state *mrb, struct mrb_context *c)\n{\n  size_t i;\n  size_t e;\n  if (c->stack == NULL) return;\n  e = c->stack - c->stbase;\n  if (c->ci) e += c->ci->nregs;\n  if (c->stbase + e > c->stend) e = c->stend - c->stbase;\n  for (i=0; i<e; i++) {\n    mrb_value v = c->stbase[i];\n    if (!mrb_immediate_p(v)) {\n      if (mrb_basic_ptr(v)->tt == MRB_TT_FREE) {\n        c->stbase[i] = mrb_nil_value();\n      }\n      else {\n        mrb_gc_mark(mrb, mrb_basic_ptr(v));\n      }\n    }\n  }\n}", "target": 1}
{"code": "drm_atomic_state_init(struct drm_device *dev, struct drm_atomic_state *state)\n{\n\tkref_init(&state->ref);\n\tstate->allow_modeset = true;\n\tstate->crtcs = kcalloc(dev->mode_config.num_crtc,\n\t\t\t       sizeof(*state->crtcs), GFP_KERNEL);\n\tif (!state->crtcs)\n\t\tgoto fail;\n\tstate->planes = kcalloc(dev->mode_config.num_total_plane,\n\t\t\t\tsizeof(*state->planes), GFP_KERNEL);\n\tif (!state->planes)\n\t\tgoto fail;\n\tdrm_dev_get(dev);\n\tstate->dev = dev;\n\tdrm_dbg_atomic(dev, \"Allocated atomic state %p\\n\", state);\n\treturn 0;\nfail:\n\tdrm_atomic_state_default_release(state);\n\treturn -ENOMEM;\n}", "target": 0}
{"code": "ZEND_API void ZEND_FASTCALL _zend_hash_init(HashTable *ht, uint32_t nSize, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)\n{\n\tGC_REFCOUNT(ht) = 1;\n\tGC_TYPE_INFO(ht) = IS_ARRAY;\n\tht->u.flags = (persistent ? HASH_FLAG_PERSISTENT : 0) | HASH_FLAG_APPLY_PROTECTION | HASH_FLAG_STATIC_KEYS;\n\tht->nTableSize = zend_hash_check_size(nSize);\n\tht->nTableMask = HT_MIN_MASK;\n\tHT_SET_DATA_ADDR(ht, &uninitialized_bucket);\n\tht->nNumUsed = 0;\n\tht->nNumOfElements = 0;\n\tht->nInternalPointer = HT_INVALID_IDX;\n\tht->nNextFreeElement = 0;\n\tht->pDestructor = pDestructor;\n}", "target": 1}
{"code": "bdat_flush_data(void)\n{\nwhile (chunking_data_left)\n  {\n  unsigned n = chunking_data_left;\n  if (!bdat_getbuf(&n)) break;\n  }\nreceive_getc = lwr_receive_getc;\nreceive_getbuf = lwr_receive_getbuf;\nreceive_ungetc = lwr_receive_ungetc;\nif (chunking_state != CHUNKING_LAST)\n  {\n  chunking_state = CHUNKING_OFFERED;\n  DEBUG(D_receive) debug_printf(\"chunking state %d\\n\", (int)chunking_state);\n  }\n}", "target": 0}
{"code": "g_file_set_contents_full(const gchar *filename,\n\t\t\t const gchar *contents,\n\t\t\t gssize length,\n\t\t\t GFileSetContentsFlags flags,\n\t\t\t int mode,\n\t\t\t GError **error)\n{\n\tgint fd;\n\tgssize wrote;\n\tif (length < 0)\n\t\tlength = strlen(contents);\n\tfd = g_open(filename, O_CREAT, mode);\n\tif (fd <= 0) {\n\t\tg_set_error(error,\n\t\t\t    G_IO_ERROR,\n\t\t\t    G_IO_ERROR_FAILED,\n\t\t\t    \"could not open %s file\",\n\t\t\t    filename);\n\t\treturn FALSE;\n\t}\n\twrote = write(fd, contents, length);\n\tif (wrote != length) {\n\t\tg_set_error(error,\n\t\t\t    G_IO_ERROR,\n\t\t\t    G_IO_ERROR_FAILED,\n\t\t\t    \"did not write %s file\",\n\t\t\t    filename);\n\t\tg_close(fd, NULL);\n\t\treturn FALSE;\n\t}\n\treturn g_close(fd, error);\n}", "target": 0}
{"code": "static void free_copy_partition_data(VP9_COMP *cpi) {\n  vpx_free(cpi->prev_partition);\n  cpi->prev_partition = NULL;\n  vpx_free(cpi->prev_segment_id);\n  cpi->prev_segment_id = NULL;\n  vpx_free(cpi->prev_variance_low);\n  cpi->prev_variance_low = NULL;\n  vpx_free(cpi->copied_frame_cnt);\n  cpi->copied_frame_cnt = NULL;\n}", "target": 0}
{"code": "static int dcbnl_getperm_hwaddr(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t\tu32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tu8 perm_addr[MAX_ADDR_LEN];\n\tif (!netdev->dcbnl_ops->getpermhwaddr)\n\t\treturn -EOPNOTSUPP;\n\tmemset(perm_addr, 0, sizeof(perm_addr));\n\tnetdev->dcbnl_ops->getpermhwaddr(netdev, perm_addr);\n\treturn nla_put(skb, DCB_ATTR_PERM_HWADDR, sizeof(perm_addr), perm_addr);\n}", "target": 0}
{"code": "mp_dss_print(netdissect_options *ndo,\n             const u_char *opt, u_int opt_len, u_char flags)\n{\n        const struct mp_dss *mdss = (const struct mp_dss *) opt;\n        if ((opt_len != mp_dss_len(mdss, 1) &&\n             opt_len != mp_dss_len(mdss, 0)) || flags & TH_SYN)\n                return 0;\n        if (mdss->flags & MP_DSS_F)\n                ND_PRINT((ndo, \" fin\"));\n        opt += 4;\n        if (mdss->flags & MP_DSS_A) {\n                ND_PRINT((ndo, \" ack \"));\n                if (mdss->flags & MP_DSS_a) {\n                        ND_PRINT((ndo, \"%\" PRIu64, EXTRACT_64BITS(opt)));\n                        opt += 8;\n                } else {\n                        ND_PRINT((ndo, \"%u\", EXTRACT_32BITS(opt)));\n                        opt += 4;\n                }\n        }\n        if (mdss->flags & MP_DSS_M) {\n                ND_PRINT((ndo, \" seq \"));\n                if (mdss->flags & MP_DSS_m) {\n                        ND_PRINT((ndo, \"%\" PRIu64, EXTRACT_64BITS(opt)));\n                        opt += 8;\n                } else {\n                        ND_PRINT((ndo, \"%u\", EXTRACT_32BITS(opt)));\n                        opt += 4;\n                }\n                ND_PRINT((ndo, \" subseq %u\", EXTRACT_32BITS(opt)));\n                opt += 4;\n                ND_PRINT((ndo, \" len %u\", EXTRACT_16BITS(opt)));\n                opt += 2;\n                if (opt_len == mp_dss_len(mdss, 1))\n                        ND_PRINT((ndo, \" csum 0x%x\", EXTRACT_16BITS(opt)));\n        }\n        return 1;\n}", "target": 1}
{"code": "int vp9_alloc_context_buffers(VP9_COMMON *cm, int width, int height) {\n  int new_mi_size;\n  vp9_set_mb_mi(cm, width, height);\n  new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);\n  if (cm->mi_alloc_size < new_mi_size) {\n    cm->free_mi(cm);\n    if (cm->alloc_mi(cm, new_mi_size)) goto fail;\n  }\n  if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {\n    free_seg_map(cm);\n    if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols)) goto fail;\n  }\n  if (cm->above_context_alloc_cols < cm->mi_cols) {\n    vpx_free(cm->above_context);\n    cm->above_context = (ENTROPY_CONTEXT *)vpx_calloc(\n        2 * mi_cols_aligned_to_sb(cm->mi_cols) * MAX_MB_PLANE,\n        sizeof(*cm->above_context));\n    if (!cm->above_context) goto fail;\n    vpx_free(cm->above_seg_context);\n    cm->above_seg_context = (PARTITION_CONTEXT *)vpx_calloc(\n        mi_cols_aligned_to_sb(cm->mi_cols), sizeof(*cm->above_seg_context));\n    if (!cm->above_seg_context) goto fail;\n    cm->above_context_alloc_cols = cm->mi_cols;\n  }\n  if (vp9_alloc_loop_filter(cm)) goto fail;\n  return 0;\nfail:\n  vp9_set_mb_mi(cm, 0, 0);\n  vp9_free_context_buffers(cm);\n  return 1;\n}", "target": 1}
{"code": "static void snd_timer_user_ccallback(struct snd_timer_instance *timeri,\n\t\t\t\t     int event,\n\t\t\t\t     struct timespec *tstamp,\n\t\t\t\t     unsigned long resolution)\n{\n\tstruct snd_timer_user *tu = timeri->callback_data;\n\tstruct snd_timer_tread r1;\n\tunsigned long flags;\n\tif (event >= SNDRV_TIMER_EVENT_START &&\n\t    event <= SNDRV_TIMER_EVENT_PAUSE)\n\t\ttu->tstamp = *tstamp;\n\tif ((tu->filter & (1 << event)) == 0 || !tu->tread)\n\t\treturn;\n\tmemset(&r1, 0, sizeof(r1));\n\tr1.event = event;\n\tr1.tstamp = *tstamp;\n\tr1.val = resolution;\n\tspin_lock_irqsave(&tu->qlock, flags);\n\tsnd_timer_user_append_to_tqueue(tu, &r1);\n\tspin_unlock_irqrestore(&tu->qlock, flags);\n\tkill_fasync(&tu->fasync, SIGIO, POLL_IN);\n\twake_up(&tu->qchange_sleep);\n}", "target": 0}
{"code": "void TestSocketLineReader::initTestCase()\n{\n    m_server = new Server(this);\n    QVERIFY2(m_server->listen(QHostAddress::LocalHost, 8694), \"Failed to create local tcp server\");\n    m_timer.setInterval(4000);\n    m_timer.setSingleShot(true);\n    connect(&m_timer, &QTimer::timeout, &m_loop, &QEventLoop::quit);\n    m_conn = new QSslSocket(this);\n    m_conn->connectToHost(QHostAddress::LocalHost, 8694);\n    connect(m_conn, &QAbstractSocket::connected, &m_loop, &QEventLoop::quit);\n    m_timer.start();\n    m_loop.exec();\n    QVERIFY2(m_conn->isOpen(), \"Could not connect to local tcp server\");\n}", "target": 1}
{"code": "void preproc_mount_mnt_dir(void) {\n\tif (!tmpfs_mounted) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on %s directory\\n\", RUN_MNT_DIR);\n\t\tif (mount(\"tmpfs\", RUN_MNT_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /run/firejail/mnt\");\n\t\ttmpfs_mounted = 1;\n\t\tfs_logger2(\"tmpfs\", RUN_MNT_DIR);\n#ifdef HAVE_SECCOMP\n\t\tcreate_empty_dir_as_root(RUN_SECCOMP_DIR, 0755);\n\t\tif (arg_seccomp_block_secondary)\n\t\t\tcopy_file(PATH_SECCOMP_BLOCK_SECONDARY, RUN_SECCOMP_BLOCK_SECONDARY, getuid(), getgid(), 0644); \n\t\telse {\n\t\t\tcopy_file(PATH_SECCOMP_32, RUN_SECCOMP_32, getuid(), getgid(), 0644); \n\t\t}\n\t\tif (arg_allow_debuggers)\n\t\t\tcopy_file(PATH_SECCOMP_DEFAULT_DEBUG, RUN_SECCOMP_CFG, getuid(), getgid(), 0644); \n\t\telse\n\t\t\tcopy_file(PATH_SECCOMP_DEFAULT, RUN_SECCOMP_CFG, getuid(), getgid(), 0644); \n\t\tif (arg_memory_deny_write_execute)\n\t\t\tcopy_file(PATH_SECCOMP_MDWX, RUN_SECCOMP_MDWX, getuid(), getgid(), 0644); \n\t\tcreate_empty_file_as_root(RUN_SECCOMP_PROTOCOL, 0644);\n\t\tif (set_perms(RUN_SECCOMP_PROTOCOL, getuid(), getgid(), 0644))\n\t\t\terrExit(\"set_perms\");\n\t\tcreate_empty_file_as_root(RUN_SECCOMP_POSTEXEC, 0644);\n\t\tif (set_perms(RUN_SECCOMP_POSTEXEC, getuid(), getgid(), 0644))\n\t\t\terrExit(\"set_perms\");\n#endif\n\t}\n}", "target": 0}
{"code": "void Node::RunForwardTypeInference() {\n  VLOG(4) << \"Forward type inference: \" << props_->node_def.DebugString();\n  if (props_->fwd_type_fn == nullptr) {\n    return;\n  }\n  std::vector<Node*> input_nodes(props_->input_types.size(), nullptr);\n  std::vector<int> input_idx(props_->input_types.size(), 0);\n  for (const auto& edge : in_edges_) {\n    if (edge->IsControlEdge()) {\n      continue;\n    }\n    DCHECK(edge->dst_input() < input_nodes.size()) << DebugString();\n    int i = edge->dst_input();\n    input_nodes.at(i) = edge->src();\n    input_idx.at(i) = edge->src_output();\n  }\n  for (const auto* node : input_nodes) {\n    if (node == nullptr) {\n      ClearTypeInfo();\n      return;\n    }\n  }\n  static FullTypeDef* no_type = new FullTypeDef();\n  std::vector<std::reference_wrapper<const FullTypeDef>> input_types;\n  for (int i = 0; i < input_nodes.size(); i++) {\n    const auto* node = input_nodes[i];\n    if (node->def().has_experimental_type()) {\n      const auto& node_t = node->def().experimental_type();\n      if (node_t.type_id() != TFT_UNSET) {\n        int ix = input_idx[i];\n        DCHECK(ix < node_t.args_size())\n            << \"input \" << i << \" should have an output \" << ix\n            << \" but instead only has \" << node_t.args_size()\n            << \" outputs: \" << node_t.DebugString();\n        input_types.emplace_back(node_t.args(ix));\n      } else {\n        input_types.emplace_back(*no_type);\n      }\n    } else {\n      ClearTypeInfo();\n      return;\n    }\n  }\n  const auto infer_type = props_->fwd_type_fn(input_types);\n  const FullTypeDef infer_typedef = infer_type.ValueOrDie();\n  if (infer_typedef.type_id() != TFT_UNSET) {\n    MaybeCopyOnWrite();\n    *(props_->node_def.mutable_experimental_type()) = infer_typedef;\n  }\n}", "target": 1}
{"code": "int perf_cpu_time_max_percent_handler(struct ctl_table *table, int write,\n\t\t\t\tvoid __user *buffer, size_t *lenp,\n\t\t\t\tloff_t *ppos)\n{\n\tint ret = proc_dointvec(table, write, buffer, lenp, ppos);\n\tif (ret || !write)\n\t\treturn ret;\n\tif (sysctl_perf_cpu_time_max_percent == 100 ||\n\t    sysctl_perf_cpu_time_max_percent == 0) {\n\t\tprintk(KERN_WARNING\n\t\t       \"perf: Dynamic interrupt throttling disabled, can hang your system!\\n\");\n\t\tWRITE_ONCE(perf_sample_allowed_ns, 0);\n\t} else {\n\t\tupdate_perf_cpu_limits();\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int mov_read_covr(MOVContext *c, AVIOContext *pb, int type, int len)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    enum AVCodecID id;\n    int ret;\n    switch (type) {\n    case 0xd:  id = AV_CODEC_ID_MJPEG; break;\n    case 0xe:  id = AV_CODEC_ID_PNG;   break;\n    case 0x1b: id = AV_CODEC_ID_BMP;   break;\n    default:\n        av_log(c->fc, AV_LOG_WARNING, \"Unknown cover type: 0x%x.\\n\", type);\n        avio_skip(pb, len);\n        return 0;\n    }\n    sc = av_mallocz(sizeof(*sc));\n    if (!sc)\n        return AVERROR(ENOMEM);\n    ret = ff_add_attached_pic(c->fc, NULL, pb, NULL, len);\n    if (ret < 0) {\n        av_free(sc);\n        return ret;\n    }\n    st = c->fc->streams[c->fc->nb_streams - 1];\n    st->priv_data = sc;\n    if (st->attached_pic.size >= 8 && id != AV_CODEC_ID_BMP) {\n        if (AV_RB64(st->attached_pic.data) == 0x89504e470d0a1a0a) {\n            id = AV_CODEC_ID_PNG;\n        } else {\n            id = AV_CODEC_ID_MJPEG;\n        }\n    }\n    st->codecpar->codec_id   = id;\n    return 0;\n}", "target": 0}
{"code": "static int update_discovery_filter(struct btd_adapter *adapter)\n{\n\tstruct mgmt_cp_start_service_discovery *sd_cp;\n\tGSList *l;\n\tDBG(\"\");\n\tif (discovery_filter_to_mgmt_cp(adapter, &sd_cp)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"discovery_filter_to_mgmt_cp returned error\");\n\t\treturn -ENOMEM;\n\t}\n\tfor (l = adapter->discovery_list; l; l = g_slist_next(l)) {\n\t\tstruct discovery_client *client = l->data;\n\t\tif (!client->discovery_filter)\n\t\t\tcontinue;\n\t\tif (client->discovery_filter->discoverable)\n\t\t\tbreak;\n\t}\n\tset_discovery_discoverable(adapter, l ? true : false);\n\tif (filters_equal(adapter->current_discovery_filter, sd_cp) &&\n\t    adapter->discovering != 0) {\n\t\tDBG(\"filters were equal, deciding to not restart the scan.\");\n\t\tg_free(sd_cp);\n\t\treturn 0;\n\t}\n\tg_free(adapter->current_discovery_filter);\n\tadapter->current_discovery_filter = sd_cp;\n\ttrigger_start_discovery(adapter, 0);\n\treturn -EINPROGRESS;\n}", "target": 1}
{"code": "int ssl_init( ssl_context *ssl )\n{\n    int ret;\n    int len = SSL_BUFFER_LEN;\n    memset( ssl, 0, sizeof( ssl_context ) );\n    ssl->rsa_decrypt = ssl_rsa_decrypt;\n    ssl->rsa_sign = ssl_rsa_sign;\n    ssl->rsa_key_len = ssl_rsa_key_len;\n    ssl->min_major_ver = SSL_MAJOR_VERSION_3;\n    ssl->min_minor_ver = SSL_MINOR_VERSION_0;\n    ssl->ciphersuites = ssl_default_ciphersuites;\n#if defined(POLARSSL_DHM_C)\n    if( ( ret = mpi_read_string( &ssl->dhm_P, 16,\n                                 POLARSSL_DHM_RFC5114_MODP_1024_P) ) != 0 ||\n        ( ret = mpi_read_string( &ssl->dhm_G, 16,\n                                 POLARSSL_DHM_RFC5114_MODP_1024_G) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"mpi_read_string\", ret );\n        return( ret );\n    }\n#endif\n    ssl->in_ctr = (unsigned char *) malloc( len );\n    ssl->in_hdr = ssl->in_ctr +  8;\n    ssl->in_msg = ssl->in_ctr + 13;\n    if( ssl->in_ctr == NULL )\n    {\n        SSL_DEBUG_MSG( 1, ( \"malloc(%d bytes) failed\", len ) );\n        return( POLARSSL_ERR_SSL_MALLOC_FAILED );\n    }\n    ssl->out_ctr = (unsigned char *) malloc( len );\n    ssl->out_hdr = ssl->out_ctr +  8;\n    ssl->out_msg = ssl->out_ctr + 40;\n    if( ssl->out_ctr == NULL )\n    {\n        SSL_DEBUG_MSG( 1, ( \"malloc(%d bytes) failed\", len ) );\n        free( ssl-> in_ctr );\n        return( POLARSSL_ERR_SSL_MALLOC_FAILED );\n    }\n    memset( ssl-> in_ctr, 0, SSL_BUFFER_LEN );\n    memset( ssl->out_ctr, 0, SSL_BUFFER_LEN );\n    ssl->hostname = NULL;\n    ssl->hostname_len = 0;\n    if( ( ret = ssl_handshake_init( ssl ) ) != 0 )\n        return( ret );\n    return( 0 );\n}", "target": 0}
{"code": "int pdf_is_pdf(FILE *fp)\n{\n    int   is_pdf;\n    char *header;\n    header = get_header(fp);\n    if (header && strstr(header, \"%PDF-\"))\n      is_pdf = 1;\n    else \n      is_pdf = 0;\n    free(header);\n    return is_pdf;\n}", "target": 1}
{"code": "static int ptrace_setoptions(struct task_struct *child, unsigned long data)\n{\n\tunsigned flags;\n\tif (data & ~(unsigned long)PTRACE_O_MASK)\n\t\treturn -EINVAL;\n\tif (unlikely(data & PTRACE_O_SUSPEND_SECCOMP)) {\n\t\tif (!IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) ||\n\t\t    !IS_ENABLED(CONFIG_SECCOMP))\n\t\t\treturn -EINVAL;\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (seccomp_mode(&current->seccomp) != SECCOMP_MODE_DISABLED ||\n\t\t    current->ptrace & PT_SUSPEND_SECCOMP)\n\t\t\treturn -EPERM;\n\t}\n\tflags = child->ptrace;\n\tflags &= ~(PTRACE_O_MASK << PT_OPT_FLAG_SHIFT);\n\tflags |= (data << PT_OPT_FLAG_SHIFT);\n\tchild->ptrace = flags;\n\treturn 0;\n}", "target": 1}
{"code": "static const char *cmd_hash_engine(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n    if (strcasecmp(p1, \"on\") == 0)  {\n        dcfg->hash_is_enabled = HASH_ENABLED;\n        dcfg->hash_enforcement = HASH_ENABLED;\n    }\n    else if (strcasecmp(p1, \"off\") == 0)    {\n        dcfg->hash_is_enabled = HASH_DISABLED;\n        dcfg->hash_enforcement = HASH_DISABLED;\n    }\n    else return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecRuleEngine: %s\", p1);\n    return NULL;\n}", "target": 1}
{"code": "folly::Optional<TLSMessage> PlaintextReadRecordLayer::read(\n    folly::IOBufQueue& buf) {\n  while (true) {\n    folly::io::Cursor cursor(buf.front());\n    if (buf.empty() || !cursor.canAdvance(kPlaintextHeaderSize)) {\n      return folly::none;\n    }\n    TLSMessage msg;\n    msg.type = static_cast<ContentType>(cursor.readBE<ContentTypeType>());\n    if (skipEncryptedRecords_) {\n      if (msg.type == ContentType::application_data) {\n        cursor.skip(sizeof(ProtocolVersion));\n        auto length = cursor.readBE<uint16_t>();\n        if (buf.chainLength() < (cursor - buf.front()) + length) {\n          return folly::none;\n        }\n        length +=\n            sizeof(ContentType) + sizeof(ProtocolVersion) + sizeof(uint16_t);\n        buf.trimStart(length);\n        continue;\n      } else if (msg.type != ContentType::change_cipher_spec) {\n        skipEncryptedRecords_ = false;\n      }\n    }\n    switch (msg.type) {\n      case ContentType::handshake:\n      case ContentType::alert:\n        break;\n      case ContentType::change_cipher_spec:\n        break;\n      default:\n        throw std::runtime_error(folly::to<std::string>(\n            \"received plaintext content type \",\n            static_cast<ContentTypeType>(msg.type),\n            \", header: \",\n            folly::hexlify(buf.splitAtMost(10)->coalesce())));\n    }\n    receivedRecordVersion_ =\n        static_cast<ProtocolVersion>(cursor.readBE<ProtocolVersionType>());\n    auto length = cursor.readBE<uint16_t>();\n    if (length > kMaxPlaintextRecordSize) {\n      throw std::runtime_error(\"received too long plaintext record\");\n    }\n    if (length == 0) {\n      throw std::runtime_error(\"received empty plaintext record\");\n    }\n    if (buf.chainLength() < (cursor - buf.front()) + length) {\n      return folly::none;\n    }\n    cursor.clone(msg.fragment, length);\n    buf.trimStart(cursor - buf.front());\n    if (msg.type == ContentType::change_cipher_spec) {\n      msg.fragment->coalesce();\n      if (msg.fragment->length() == 1 && *msg.fragment->data() == 0x01) {\n        continue;\n      } else {\n        throw FizzException(\n            \"received ccs\", AlertDescription::illegal_parameter);\n      }\n    }\n    return std::move(msg);\n  }\n}", "target": 1}
{"code": "xfs_lock_inodes(\n\tstruct xfs_inode\t**ips,\n\tint\t\t\tinodes,\n\tuint\t\t\tlock_mode)\n{\n\tint\t\t\tattempts = 0, i, j, try_lock;\n\tstruct xfs_log_item\t*lp;\n\tASSERT(ips && inodes >= 2 && inodes <= 5);\n\tASSERT(lock_mode & (XFS_IOLOCK_EXCL | XFS_MMAPLOCK_EXCL |\n\t\t\t    XFS_ILOCK_EXCL));\n\tASSERT(!(lock_mode & (XFS_IOLOCK_SHARED | XFS_MMAPLOCK_SHARED |\n\t\t\t      XFS_ILOCK_SHARED)));\n\tASSERT(!(lock_mode & XFS_MMAPLOCK_EXCL) ||\n\t\tinodes <= XFS_MMAPLOCK_MAX_SUBCLASS + 1);\n\tASSERT(!(lock_mode & XFS_ILOCK_EXCL) ||\n\t\tinodes <= XFS_ILOCK_MAX_SUBCLASS + 1);\n\tif (lock_mode & XFS_IOLOCK_EXCL) {\n\t\tASSERT(!(lock_mode & (XFS_MMAPLOCK_EXCL | XFS_ILOCK_EXCL)));\n\t} else if (lock_mode & XFS_MMAPLOCK_EXCL)\n\t\tASSERT(!(lock_mode & XFS_ILOCK_EXCL));\n\ttry_lock = 0;\n\ti = 0;\nagain:\n\tfor (; i < inodes; i++) {\n\t\tASSERT(ips[i]);\n\t\tif (i && (ips[i] == ips[i - 1]))\t\n\t\t\tcontinue;\n\t\tif (!try_lock) {\n\t\t\tfor (j = (i - 1); j >= 0 && !try_lock; j--) {\n\t\t\t\tlp = &ips[j]->i_itemp->ili_item;\n\t\t\t\tif (lp && test_bit(XFS_LI_IN_AIL, &lp->li_flags))\n\t\t\t\t\ttry_lock++;\n\t\t\t}\n\t\t}\n\t\tif (!try_lock) {\n\t\t\txfs_ilock(ips[i], xfs_lock_inumorder(lock_mode, i));\n\t\t\tcontinue;\n\t\t}\n\t\tASSERT(i != 0);\n\t\tif (xfs_ilock_nowait(ips[i], xfs_lock_inumorder(lock_mode, i)))\n\t\t\tcontinue;\n\t\tattempts++;\n\t\tfor (j = i - 1; j >= 0; j--) {\n\t\t\tif (j != (i - 1) && ips[j] == ips[j + 1])\n\t\t\t\tcontinue;\n\t\t\txfs_iunlock(ips[j], lock_mode);\n\t\t}\n\t\tif ((attempts % 5) == 0) {\n\t\t\tdelay(1); \n\t\t}\n\t\ti = 0;\n\t\ttry_lock = 0;\n\t\tgoto again;\n\t}\n}", "target": 0}
{"code": "  explicit SparseFillEmptyRowsGPUOp(OpKernelConstruction* context)\n      : AsyncOpKernel(context) {}", "target": 0}
{"code": "int get_evtchn_to_irq(evtchn_port_t evtchn)\n{\n\tif (evtchn >= xen_evtchn_max_channels())\n\t\treturn -1;\n\tif (evtchn_to_irq[EVTCHN_ROW(evtchn)] == NULL)\n\t\treturn -1;\n\treturn evtchn_to_irq[EVTCHN_ROW(evtchn)][EVTCHN_COL(evtchn)];\n}", "target": 1}
{"code": "test_js (void) {\n    GString *result = g_string_new(\"\");\n    parse_cmd_line(\"js ('x' + 345).toUpperCase()\", result);\n    g_assert_cmpstr(\"X345\", ==, result->str);\n    uzbl.net.useragent = \"Test useragent\";\n    parse_cmd_line(\"js Uzbl.run('print @useragent').toUpperCase();\", result);\n    g_assert_cmpstr(\"TEST USERAGENT\", ==, result->str);\n    g_string_free(result, TRUE);\n}", "target": 1}
{"code": "void context__cleanup(struct mosquitto *context, bool force_free)\n{\n\tstruct mosquitto__packet *packet;\n\tif(!context) return;\n\tif(force_free){\n\t\tcontext->clean_start = true;\n\t}\n#ifdef WITH_BRIDGE\n\tif(context->bridge){\n\t\tbridge__cleanup(context);\n\t}\n#endif\n\talias__free_all(context);\n\tmosquitto__free(context->auth_method);\n\tcontext->auth_method = NULL;\n\tmosquitto__free(context->username);\n\tcontext->username = NULL;\n\tmosquitto__free(context->password);\n\tcontext->password = NULL;\n\tnet__socket_close(context);\n\tif(force_free){\n\t\tsub__clean_session(context);\n\t}\n\tdb__messages_delete(context, force_free);\n\tmosquitto__free(context->address);\n\tcontext->address = NULL;\n\tcontext__send_will(context);\n\tif(context->id){\n\t\tcontext__remove_from_by_id(context);\n\t\tmosquitto__free(context->id);\n\t\tcontext->id = NULL;\n\t}\n\tpacket__cleanup(&(context->in_packet));\n\tif(context->current_out_packet){\n\t\tpacket__cleanup(context->current_out_packet);\n\t\tmosquitto__free(context->current_out_packet);\n\t\tcontext->current_out_packet = NULL;\n\t}\n\twhile(context->out_packet){\n\t\tpacket__cleanup(context->out_packet);\n\t\tpacket = context->out_packet;\n\t\tcontext->out_packet = context->out_packet->next;\n\t\tmosquitto__free(packet);\n\t}\n\tcontext->out_packet_count = 0;\n#if defined(WITH_BROKER) && defined(__GLIBC__) && defined(WITH_ADNS)\n\tif(context->adns){\n\t\tgai_cancel(context->adns);\n\t\tmosquitto__free((struct addrinfo *)context->adns->ar_request);\n\t\tmosquitto__free(context->adns);\n\t}\n#endif\n\tif(force_free){\n\t\tmosquitto__free(context);\n\t}\n}", "target": 1}
{"code": "NOEXPORT void print_tmp_key(SSL *s) {\n    EVP_PKEY *key;\n    if (!SSL_get_peer_tmp_key(s, &key)) {\n        sslerror(\"SSL_get_peer_tmp_key\");\n        return;\n    }\n    switch (EVP_PKEY_id(key)) {\n    case EVP_PKEY_RSA:\n        s_log(LOG_INFO, \"Peer temporary key: RSA, %d bits\", EVP_PKEY_bits(key));\n        break;\n    case EVP_PKEY_DH:\n        s_log(LOG_INFO, \"Peer temporary key: DH, %d bits\", EVP_PKEY_bits(key));\n        break;\n#ifndef OPENSSL_NO_EC\n    case EVP_PKEY_EC:\n        {\n            EC_KEY *ec=EVP_PKEY_get1_EC_KEY(key);\n            int nid=EC_GROUP_get_curve_name(EC_KEY_get0_group(ec));\n            const char *cname=EC_curve_nid2nist(nid);\n            EC_KEY_free(ec);\n            if (cname == NULL)\n                cname=OBJ_nid2sn(nid);\n            s_log(LOG_INFO, \"Peer temporary key: ECDH, %s, %d bits\", cname, EVP_PKEY_bits(key));\n        }\n        break;\n#endif\n    default:\n        s_log(LOG_INFO, \"Peer temporary key: %s, %d bits\", OBJ_nid2sn(EVP_PKEY_id(key)),\n                   EVP_PKEY_bits(key));\n    }\n    EVP_PKEY_free(key);\n}", "target": 0}
{"code": "static int efi_capsule_release(struct inode *inode, struct file *file)\n{\n\tstruct capsule_info *cap_info = file->private_data;\n\tif (cap_info->index > 0 &&\n\t    (cap_info->header.headersize == 0 ||\n\t     cap_info->count < cap_info->total_size)) {\n\t\tpr_err(\"capsule upload not complete\\n\");\n\t\tefi_free_all_buff_pages(cap_info);\n\t}\n\tkfree(cap_info->pages);\n\tkfree(cap_info->phys);\n\tkfree(file->private_data);\n\tfile->private_data = NULL;\n\treturn 0;\n}", "target": 0}
{"code": "real_need_secrets (NMVpnServicePlugin *plugin,\n                   NMConnection *connection,\n                   const char **out_setting_name,\n                   GError **error)\n{\n\tNMSettingVpn *s_vpn;\n\tNMSettingSecretFlags pw_flags;\n\tconst char *pw = NULL;\n\tg_return_val_if_fail (NM_IS_VPN_SERVICE_PLUGIN (plugin), FALSE);\n\tg_return_val_if_fail (NM_IS_CONNECTION (connection), FALSE);\n\ts_vpn = nm_connection_get_setting_vpn (connection);\n\tif (!s_vpn) {\n\t\tg_set_error (error,\n\t\t             NM_VPN_PLUGIN_ERROR,\n\t\t             NM_VPN_PLUGIN_ERROR_INVALID_CONNECTION,\n\t\t             \"%s\",\n\t\t             _(\"Could not process the request because the VPN connection settings were invalid.\"));\n\t\treturn FALSE;\n\t}\n\tpw = nm_setting_vpn_get_secret (s_vpn, NM_VPNC_KEY_SECRET);\n\tpw_flags = get_pw_flags (s_vpn, NM_VPNC_KEY_SECRET, NM_VPNC_KEY_SECRET_TYPE);\n\tif (!pw && !(pw_flags & NM_SETTING_SECRET_FLAG_NOT_REQUIRED)) {\n\t\t*out_setting_name = NM_SETTING_VPN_SETTING_NAME;\n\t\treturn TRUE;\n\t}\n\tpw = nm_setting_vpn_get_secret (s_vpn, NM_VPNC_KEY_XAUTH_PASSWORD);\n\tpw_flags = get_pw_flags (s_vpn, NM_VPNC_KEY_XAUTH_PASSWORD, NM_VPNC_KEY_XAUTH_PASSWORD_TYPE);\n\tif (!pw && !(pw_flags & NM_SETTING_SECRET_FLAG_NOT_REQUIRED)) {\n\t\t*out_setting_name = NM_SETTING_VPN_SETTING_NAME;\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}", "target": 0}
{"code": "void CZNC::ForceEncoding() {\n    m_uiForceEncoding++;\n#ifdef HAVE_ICU\n    for (Csock* pSock : GetManager()) {\n        if (pSock->GetEncoding().empty()) {\n            pSock->SetEncoding(\"UTF-8\");\n        }\n    }\n#endif\n}", "target": 1}
{"code": "static std::string make_relative_path(const std::string& path) {\n  if (path.empty()) {\n    return path;\n  }\n  std::string canonical(FileUtil::canonicalize(path));\n  if (FileUtil::isDirSeparator(canonical[0])) {\n    return canonical.substr(1);\n  }\n  std::string relative(canonical);\n  int idx = canonical.length() - 1;\n  while (1) {\n    while (idx > 0 && !(FileUtil::isDirSeparator(canonical[idx]))) {\n      idx--;\n    }\n    if (idx == 0) {\n      return canonical;\n    }\n    if (idx >= 1 && (canonical[idx - 1] == '.' || canonical[idx - 1] == ':')) {\n      relative = canonical.substr(idx + 1);\n      break;\n    }\n    idx--;\n  }\n  return relative;\n}", "target": 0}
{"code": "static int midi_setup_noteon(struct _mdi *mdi, uint8_t channel,\n                             uint8_t note, uint8_t velocity) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,channel, note);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_note_on;\n    mdi->events[mdi->event_count].event_data.channel = channel;\n    mdi->events[mdi->event_count].event_data.data.value = (note << 8) | velocity;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    if (mdi->channel[channel].isdrum)\n        _WM_load_patch(mdi, ((mdi->channel[channel].bank << 8) | (note | 0x80)));\n    return (0);\n}", "target": 0}
{"code": "void mp_encode_lua_table_as_map(lua_State *L, mp_buf *buf, int level) {\n    size_t len = 0;\n    luaL_checkstack(L, 3, \"in function mp_encode_lua_table_as_map\");\n    lua_pushnil(L);\n    while(lua_next(L,-2)) {\n        lua_pop(L,1); \n        len++;\n    }\n    mp_encode_map(L,buf,len);\n    lua_pushnil(L);\n    while(lua_next(L,-2)) {\n        lua_pushvalue(L,-2); \n        mp_encode_lua_type(L,buf,level+1); \n        mp_encode_lua_type(L,buf,level+1); \n    }\n}", "target": 0}
{"code": "BOOL glyph_cache_put(rdpGlyphCache* glyphCache, UINT32 id, UINT32 index, rdpGlyph* glyph)\n{\n\trdpGlyph* prevGlyph;\n\tif (id > 9)\n\t{\n\t\tWLog_ERR(TAG, \"invalid glyph cache id: %\" PRIu32 \"\", id);\n\t\treturn FALSE;\n\t}\n\tif (index > glyphCache->glyphCache[id].number)\n\t{\n\t\tWLog_ERR(TAG, \"invalid glyph cache index: %\" PRIu32 \" in cache id: %\" PRIu32 \"\", index, id);\n\t\treturn FALSE;\n\t}\n\tWLog_Print(glyphCache->log, WLOG_DEBUG, \"GlyphCachePut: id: %\" PRIu32 \" index: %\" PRIu32 \"\", id,\n\t           index);\n\tprevGlyph = glyphCache->glyphCache[id].entries[index];\n\tif (prevGlyph)\n\t\tprevGlyph->Free(glyphCache->context, prevGlyph);\n\tglyphCache->glyphCache[id].entries[index] = glyph;\n\treturn TRUE;\n}", "target": 1}
{"code": "absl::StatusOr<tensorflow::Tensor> DecompressTensorFromProto(\n    const tensorflow::TensorProto& proto) {\n  if (!IsSupported(proto.dtype())) {\n    return absl::InvalidArgumentError(absl::StrCat(\n        \"Tensor of dtype \", tensorflow::DataTypeString(proto.dtype()),\n        \" is not supported for decompression.\"));\n  }\n  if (proto.dtype() == tensorflow::DT_STRING) {\n    tensorflow::Tensor tensor;\n    REVERB_CHECK(tensor.FromProto(proto));\n    return tensor;\n  } else {\n    tensorflow::Tensor tensor(proto.dtype(),\n                              tensorflow::TensorShape(proto.tensor_shape()));\n    const auto& tensor_content = proto.tensor_content();\n    SnappyUncompressToString(tensor_content, tensor.tensor_data().size(),\n                             const_cast<char*>(tensor.tensor_data().data()));\n    return tensor;\n  }\n}", "target": 0}
{"code": "static BIO *cms_get_text_bio(BIO *out, unsigned int flags)\n\t{\n\tBIO *rbio;\n\tif (out == NULL)\n\t\trbio = BIO_new(BIO_s_null());\n\telse if (flags & CMS_TEXT)\n\t\t{\n\t\trbio = BIO_new(BIO_s_mem());\n\t\tBIO_set_mem_eof_return(rbio, 0);\n\t\t}\n\telse\n\t\trbio = out;\n\treturn rbio;\n\t}", "target": 0}
{"code": "static void lateeoi_list_add(struct irq_info *info)\n{\n\tstruct lateeoi_work *eoi = &per_cpu(lateeoi, info->eoi_cpu);\n\tstruct irq_info *elem;\n\tu64 now = get_jiffies_64();\n\tunsigned long delay;\n\tunsigned long flags;\n\tif (now < info->eoi_time)\n\t\tdelay = info->eoi_time - now;\n\telse\n\t\tdelay = 1;\n\tspin_lock_irqsave(&eoi->eoi_list_lock, flags);\n\tif (list_empty(&eoi->eoi_list)) {\n\t\tlist_add(&info->eoi_list, &eoi->eoi_list);\n\t\tmod_delayed_work_on(info->eoi_cpu, system_wq,\n\t\t\t\t    &eoi->delayed, delay);\n\t} else {\n\t\tlist_for_each_entry_reverse(elem, &eoi->eoi_list, eoi_list) {\n\t\t\tif (elem->eoi_time <= info->eoi_time)\n\t\t\t\tbreak;\n\t\t}\n\t\tlist_add(&info->eoi_list, &elem->eoi_list);\n\t}\n\tspin_unlock_irqrestore(&eoi->eoi_list_lock, flags);\n}", "target": 0}
{"code": "repodata_schema2id(Repodata *data, Id *schema, int create)\n{\n  int h, len, i;\n  Id *sp, cid;\n  Id *schematahash;\n  if (!*schema)\n    return 0;\t\n  if ((schematahash = data->schematahash) == 0)\n    {\n      data->schematahash = schematahash = solv_calloc(256, sizeof(Id));\n      for (i = 1; i < data->nschemata; i++)\n\t{\n\t  for (sp = data->schemadata + data->schemata[i], h = 0; *sp;)\n\t    h = h * 7 + *sp++;\n\t  h &= 255;\n\t  schematahash[h] = i;\n\t}\n      data->schemadata = solv_extend_resize(data->schemadata, data->schemadatalen, sizeof(Id), SCHEMATADATA_BLOCK);\n      data->schemata = solv_extend_resize(data->schemata, data->nschemata, sizeof(Id), SCHEMATA_BLOCK);\n    }\n  for (sp = schema, len = 0, h = 0; *sp; len++)\n    h = h * 7 + *sp++;\n  h &= 255;\n  len++;\n  cid = schematahash[h];\n  if (cid)\n    {\n      if (!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))\n        return cid;\n      for (cid = 1; cid < data->nschemata; cid++)\n        if (!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))\n          return cid;\n    }\n  if (!create)\n    return 0;\n  data->schemadata = solv_extend(data->schemadata, data->schemadatalen, len, sizeof(Id), SCHEMATADATA_BLOCK);\n  data->schemata = solv_extend(data->schemata, data->nschemata, 1, sizeof(Id), SCHEMATA_BLOCK);\n  memcpy(data->schemadata + data->schemadatalen, schema, len * sizeof(Id));\n  data->schemata[data->nschemata] = data->schemadatalen;\n  data->schemadatalen += len;\n  schematahash[h] = data->nschemata;\n#if 0\nfprintf(stderr, \"schema2id: new schema\\n\");\n#endif\n  return data->nschemata++;\n}", "target": 1}
{"code": "static int pfkey_register(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\tstruct sk_buff *supp_skb;\n\tif (hdr->sadb_msg_satype > SADB_SATYPE_MAX)\n\t\treturn -EINVAL;\n\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC) {\n\t\tif (pfk->registered&(1<<hdr->sadb_msg_satype))\n\t\t\treturn -EEXIST;\n\t\tpfk->registered |= (1<<hdr->sadb_msg_satype);\n\t}\n\tmutex_lock(&pfkey_mutex);\n\txfrm_probe_algs();\n\tsupp_skb = compose_sadb_supported(hdr, GFP_KERNEL | __GFP_ZERO);\n\tmutex_unlock(&pfkey_mutex);\n\tif (!supp_skb) {\n\t\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC)\n\t\t\tpfk->registered &= ~(1<<hdr->sadb_msg_satype);\n\t\treturn -ENOBUFS;\n\t}\n\tpfkey_broadcast(supp_skb, GFP_KERNEL, BROADCAST_REGISTERED, sk,\n\t\t\tsock_net(sk));\n\treturn 0;\n}", "target": 0}
{"code": "snmp_ber_encode_timeticks(snmp_packet_t *snmp_packet, uint32_t timeticks)\n{\n  return snmp_ber_encode_unsigned_integer(snmp_packet, BER_DATA_TYPE_TIMETICKS, timeticks);\n}", "target": 0}
{"code": "dcinit()\n{\n\tstrsize = 1; \n\tstrmaxsize=DCSTRSIZE;\n\tdcstr=calloc(DCSTRSIZE,1);\n\tdcptr=dcstr;\n}", "target": 0}
{"code": "static inline int ip6_ufo_append_data(struct sock *sk,\n\t\t\tint getfrag(void *from, char *to, int offset, int len,\n\t\t\tint odd, struct sk_buff *skb),\n\t\t\tvoid *from, int length, int hh_len, int fragheaderlen,\n\t\t\tint transhdrlen, int mtu,unsigned int flags,\n\t\t\tstruct rt6_info *rt)\n{\n\tstruct sk_buff *skb;\n\tstruct frag_hdr fhdr;\n\tint err;\n\tif ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL) {\n\t\tskb = sock_alloc_send_skb(sk,\n\t\t\thh_len + fragheaderlen + transhdrlen + 20,\n\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\tif (skb == NULL)\n\t\t\treturn err;\n\t\tskb_reserve(skb, hh_len);\n\t\tskb_put(skb,fragheaderlen + transhdrlen);\n\t\tskb_reset_network_header(skb);\n\t\tskb->transport_header = skb->network_header + fragheaderlen;\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\tskb->csum = 0;\n\t\t__skb_queue_tail(&sk->sk_write_queue, skb);\n\t} else if (skb_is_gso(skb)) {\n\t\tgoto append;\n\t}\n\tskb->ip_summed = CHECKSUM_PARTIAL;\n\tskb_shinfo(skb)->gso_size = (mtu - fragheaderlen -\n\t\t\t\t     sizeof(struct frag_hdr)) & ~7;\n\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n\tipv6_select_ident(&fhdr, rt);\n\tskb_shinfo(skb)->ip6_frag_id = fhdr.identification;\nappend:\n\treturn skb_append_datato_frags(sk, skb, getfrag, from,\n\t\t\t\t       (length - transhdrlen));\n}", "target": 0}
{"code": "int fpm_unix_resolve_socket_premissions(struct fpm_worker_pool_s *wp) \n{\n\tstruct fpm_worker_pool_config_s *c = wp->config;\n\twp->socket_uid = -1;\n\twp->socket_gid = -1;\n\twp->socket_mode = 0666;\n\tif (!c) {\n\t\treturn 0;\n\t}\n\tif (c->listen_owner && *c->listen_owner) {\n\t\tstruct passwd *pwd;\n\t\tpwd = getpwnam(c->listen_owner);\n\t\tif (!pwd) {\n\t\t\tzlog(ZLOG_SYSERROR, \"[pool %s] cannot get uid for user '%s'\", wp->config->name, c->listen_owner);\n\t\t\treturn -1;\n\t\t}\n\t\twp->socket_uid = pwd->pw_uid;\n\t\twp->socket_gid = pwd->pw_gid;\n\t}\n\tif (c->listen_group && *c->listen_group) {\n\t\tstruct group *grp;\n\t\tgrp = getgrnam(c->listen_group);\n\t\tif (!grp) {\n\t\t\tzlog(ZLOG_SYSERROR, \"[pool %s] cannot get gid for group '%s'\", wp->config->name, c->listen_group);\n\t\t\treturn -1;\n\t\t}\n\t\twp->socket_gid = grp->gr_gid;\n\t}\n\tif (c->listen_mode && *c->listen_mode) {\n\t\twp->socket_mode = strtoul(c->listen_mode, 0, 8);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static GF_Err gf_isom_set_root_iod(GF_ISOFile *movie)\n{\n\tGF_IsomInitialObjectDescriptor *iod;\n\tGF_IsomObjectDescriptor *od;\n\tGF_Err e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\tif (!movie->moov->iods) {\n\t\tAddMovieIOD(movie->moov, 1);\n\t\treturn GF_OK;\n\t}\n\tif (movie->moov->iods->descriptor->tag == GF_ODF_ISOM_IOD_TAG) return GF_OK;\n\tod = (GF_IsomObjectDescriptor *) movie->moov->iods->descriptor;\n\tiod = (GF_IsomInitialObjectDescriptor*)gf_malloc(sizeof(GF_IsomInitialObjectDescriptor));\n\tif (!iod) return GF_OUT_OF_MEM;\n\tmemset(iod, 0, sizeof(GF_IsomInitialObjectDescriptor));\n\tiod->ES_ID_IncDescriptors = od->ES_ID_IncDescriptors;\n\tod->ES_ID_IncDescriptors = NULL;\n\tiod->ES_ID_RefDescriptors = NULL;\n\tiod->extensionDescriptors = od->extensionDescriptors;\n\tod->extensionDescriptors = NULL;\n\tiod->IPMP_Descriptors = od->IPMP_Descriptors;\n\tod->IPMP_Descriptors = NULL;\n\tiod->objectDescriptorID = od->objectDescriptorID;\n\tiod->OCIDescriptors = od->OCIDescriptors;\n\tod->OCIDescriptors = NULL;\n\tiod->tag = GF_ODF_ISOM_IOD_TAG;\n\tiod->URLString = od->URLString;\n\tod->URLString = NULL;\n\tgf_odf_desc_del((GF_Descriptor *) od);\n\tmovie->moov->iods->descriptor = (GF_Descriptor *)iod;\n\treturn GF_OK;\n}", "target": 1}
{"code": "static void* my_gballoc_realloc(void* ptr, size_t size)\n{\n    return realloc(ptr, size);\n}", "target": 0}
{"code": "ppp_unregister_channel(struct ppp_channel *chan)\n{\n\tstruct channel *pch = chan->ppp;\n\tstruct ppp_net *pn;\n\tif (!pch)\n\t\treturn;\t\t\n\tchan->ppp = NULL;\n\tdown_write(&pch->chan_sem);\n\tspin_lock_bh(&pch->downl);\n\tpch->chan = NULL;\n\tspin_unlock_bh(&pch->downl);\n\tup_write(&pch->chan_sem);\n\tppp_disconnect_channel(pch);\n\tpn = ppp_pernet(pch->chan_net);\n\tspin_lock_bh(&pn->all_channels_lock);\n\tlist_del(&pch->list);\n\tspin_unlock_bh(&pn->all_channels_lock);\n\tput_net(pch->chan_net);\n\tpch->chan_net = NULL;\n\tpch->file.dead = 1;\n\twake_up_interruptible(&pch->file.rwait);\n\tif (atomic_dec_and_test(&pch->file.refcnt))\n\t\tppp_destroy_channel(pch);\n}", "target": 0}
{"code": "static int append_key_value(smart_str* loc_name, HashTable* hash_arr, char* key_name)\n{\n\tzval**\tele_value\t= NULL;\n\tif(zend_hash_find(hash_arr , key_name , strlen(key_name) + 1 ,(void **)&ele_value ) == SUCCESS ) {\n\t\tif(Z_TYPE_PP(ele_value)!= IS_STRING ){\n\t\t\treturn FAILURE;\n\t\t}\n\t\tif(strcmp(key_name, LOC_LANG_TAG) != 0 && \n\t\t   strcmp(key_name, LOC_GRANDFATHERED_LANG_TAG)!=0 ) {\n\t\t\tsmart_str_appendl(loc_name, SEPARATOR , sizeof(SEPARATOR)-1);\n\t\t}\n\t\tsmart_str_appendl(loc_name, Z_STRVAL_PP(ele_value) , Z_STRLEN_PP(ele_value));\n\t\treturn SUCCESS;\n\t}\n\treturn LOC_NOT_FOUND;\n}", "target": 1}
{"code": "static void prep_new_huge_page(struct hstate *h, struct page *page, int nid)\n{\n\t__prep_new_huge_page(h, page);\n\tspin_lock_irq(&hugetlb_lock);\n\t__prep_account_new_huge_page(h, nid);\n\tspin_unlock_irq(&hugetlb_lock);\n}", "target": 0}
{"code": "SPL_METHOD(SplDoublyLinkedList, offsetSet)\n{\n\tzval                  *zindex, *value;\n\tspl_dllist_object     *intern;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"zz\", &zindex, &value) == FAILURE) {\n\t\treturn;\n\t}\n\tintern = Z_SPLDLLIST_P(getThis());\n\tif (Z_TYPE_P(zindex) == IS_NULL) {\n\t\tspl_ptr_llist_push(intern->llist, value);\n\t} else {\n\t\tzend_long                   index;\n\t\tspl_ptr_llist_element *element;\n\t\tindex = spl_offset_convert_to_long(zindex);\n\t\tif (index < 0 || index >= intern->llist->count) {\n\t\t\tzval_ptr_dtor(value);\n\t\t\tzend_throw_exception(spl_ce_OutOfRangeException, \"Offset invalid or out of range\", 0);\n\t\t\treturn;\n\t\t}\n\t\telement = spl_ptr_llist_offset(intern->llist, index, intern->flags & SPL_DLLIST_IT_LIFO);\n\t\tif (element != NULL) {\n\t\t\tif (intern->llist->dtor) {\n\t\t\t\tintern->llist->dtor(element);\n\t\t\t}\n\t\t\tzval_ptr_dtor(&element->data);\n\t\t\tZVAL_COPY_VALUE(&element->data, value);\n\t\t\tif (intern->llist->ctor) {\n\t\t\t\tintern->llist->ctor(element);\n\t\t\t}\n\t\t} else {\n\t\t\tzval_ptr_dtor(value);\n\t\t\tzend_throw_exception(spl_ce_OutOfRangeException, \"Offset invalid\", 0);\n\t\t\treturn;\n\t\t}\n\t}\n} ", "target": 1}
{"code": "static int io_files_update_with_index_alloc(struct io_kiocb *req,\n\t\t\t\t\t    unsigned int issue_flags)\n{\n\t__s32 __user *fds = u64_to_user_ptr(req->rsrc_update.arg);\n\tunsigned int done;\n\tstruct file *file;\n\tint ret, fd;\n\tif (!req->ctx->file_data)\n\t\treturn -ENXIO;\n\tfor (done = 0; done < req->rsrc_update.nr_args; done++) {\n\t\tif (copy_from_user(&fd, &fds[done], sizeof(fd))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tfile = fget(fd);\n\t\tif (!file) {\n\t\t\tret = -EBADF;\n\t\t\tbreak;\n\t\t}\n\t\tret = io_fixed_fd_install(req, issue_flags, file,\n\t\t\t\t\t  IORING_FILE_INDEX_ALLOC);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (copy_to_user(&fds[done], &ret, sizeof(ret))) {\n\t\t\t__io_close_fixed(req, issue_flags, ret);\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (done)\n\t\treturn done;\n\treturn ret;", "target": 0}
{"code": "void PackLinuxElf32::updateLoader(OutputFile * )\n{\n    unsigned start = linker->getSymbolOffset(\"_start\");\n    unsigned vbase = get_te32(&elfout.phdr[0].p_vaddr);\n    set_te32(&elfout.ehdr.e_entry, start + sz_pack2 + vbase);\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& min_input_tensor = context->input(1);\n    const Tensor& max_input_tensor = context->input(2);\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(min_input_tensor.shape()),\n                errors::InvalidArgument(\n                    \"min_input shape must be rank 0 but is rank \",\n                    min_input_tensor.dims(),\n                    \", received shape: \", min_input_tensor.shape()));\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(max_input_tensor.shape()),\n                errors::InvalidArgument(\n                    \"max_input shape must be rank 0 but is rank \",\n                    max_input_tensor.dims(),\n                    \", received shape: \", max_input_tensor.shape()));\n    const float min_input = context->input(1).scalar<float>()();\n    const float max_input = context->input(2).scalar<float>()();\n    MaxPoolingOp<Device, T>::Compute(context);\n    Tensor* output_min = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, {}, &output_min));\n    output_min->flat<float>()(0) = min_input;\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(2, {}, &output_max));\n    output_max->flat<float>()(0) = max_input;\n  }", "target": 0}
{"code": "static void evdev_queue_syn_dropped(struct evdev_client *client)\n{\n\tunsigned long flags;\n\tstruct input_event ev;\n\tktime_t time;\n\ttime = ktime_get();\n\tif (client->clkid != CLOCK_MONOTONIC)\n\t\ttime = ktime_sub(time, ktime_get_monotonic_offset());\n\tev.time = ktime_to_timeval(time);\n\tev.type = EV_SYN;\n\tev.code = SYN_DROPPED;\n\tev.value = 0;\n\tspin_lock_irqsave(&client->buffer_lock, flags);\n\tclient->buffer[client->head++] = ev;\n\tclient->head &= client->bufsize - 1;\n\tif (unlikely(client->head == client->tail)) {\n\t\tclient->tail = (client->head - 1) & (client->bufsize - 1);\n\t\tclient->packet_head = client->tail;\n\t}\n\tspin_unlock_irqrestore(&client->buffer_lock, flags);\n}", "target": 0}
{"code": "request_env(agooReq req, VALUE self) {\n    if (Qnil == (VALUE)req->env) {\n\tvolatile VALUE\tenv = rb_hash_new();\n\trb_hash_aset(env, request_method_val, req_method(req));\n\trb_hash_aset(env, script_name_val, req_script_name(req));\n\trb_hash_aset(env, path_info_val, req_path_info(req));\n\trb_hash_aset(env, query_string_val, req_query_string(req));\n\trb_hash_aset(env, server_name_val, req_server_name(req));\n\trb_hash_aset(env, server_port_val, req_server_port(req));\n\tfill_headers(req, env);\n\trb_hash_aset(env, rack_version_val, rack_version_val_val);\n\trb_hash_aset(env, rack_url_scheme_val, req_rack_url_scheme(req));\n\trb_hash_aset(env, rack_input_val, req_rack_input(req));\n\trb_hash_aset(env, rack_errors_val, req_rack_errors(req));\n\trb_hash_aset(env, rack_multithread_val, req_rack_multithread(req));\n\trb_hash_aset(env, rack_multiprocess_val, Qfalse);\n\trb_hash_aset(env, rack_run_once_val, Qfalse);\n\trb_hash_aset(env, rack_logger_val, req_rack_logger(req));\n\trb_hash_aset(env, rack_upgrade_val, req_rack_upgrade(req));\n\trb_hash_aset(env, rack_hijackq_val, Qtrue);\n\trb_hash_aset(env, rack_hijack_val, self);\n\trb_hash_aset(env, rack_hijack_io_val, Qnil);\n\tif (agoo_server.rack_early_hints) {\n\t    volatile VALUE\teh = agoo_early_hints_new(req);\n\t    rb_hash_aset(env, early_hints_val, eh);\n\t}\n\treq->env = (void*)env;\n    }\n    return (VALUE)req->env;\n}", "target": 1}
{"code": "static void sas_destruct_ports(struct asd_sas_port *port)\n{\n\tstruct sas_port *sas_port, *p;\n\tlist_for_each_entry_safe(sas_port, p, &port->sas_port_del_list, del_list) {\n\t\tlist_del_init(&sas_port->del_list);\n\t\tsas_port_delete(sas_port);\n\t}\n}", "target": 0}
{"code": "static int mxf_read_primer_pack(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFContext *mxf = arg;\n    int item_num = avio_rb32(pb);\n    int item_len = avio_rb32(pb);\n    if (item_len != 18) {\n        avpriv_request_sample(pb, \"Primer pack item length %d\", item_len);\n        return AVERROR_PATCHWELCOME;\n    }\n    if (item_num > 65536) {\n        av_log(mxf->fc, AV_LOG_ERROR, \"item_num %d is too large\\n\", item_num);\n        return AVERROR_INVALIDDATA;\n    }\n    if (mxf->local_tags)\n        av_log(mxf->fc, AV_LOG_VERBOSE, \"Multiple primer packs\\n\");\n    av_free(mxf->local_tags);\n    mxf->local_tags_count = 0;\n    mxf->local_tags = av_calloc(item_num, item_len);\n    if (!mxf->local_tags)\n        return AVERROR(ENOMEM);\n    mxf->local_tags_count = item_num;\n    avio_read(pb, mxf->local_tags, item_num*item_len);\n    return 0;\n}", "target": 1}
{"code": "fribidi_cap_rtl_to_unicode (\n  const char *s,\n  FriBidiStrIndex len,\n  FriBidiChar *us\n)\n{\n  FriBidiStrIndex i, j;\n  if (!caprtl_to_unicode)\n    init_cap_rtl ();\n  j = 0;\n  for (i = 0; i < len; i++)\n    {\n      char ch;\n      ch = s[i];\n      if (ch == '_')\n\t{\n\t  switch (ch = s[++i])\n\t    {\n\t    case '>':\n\t      us[j++] = FRIBIDI_CHAR_LRM;\n\t      break;\n\t    case '<':\n\t      us[j++] = FRIBIDI_CHAR_RLM;\n\t      break;\n\t    case 'l':\n\t      us[j++] = FRIBIDI_CHAR_LRE;\n\t      break;\n\t    case 'r':\n\t      us[j++] = FRIBIDI_CHAR_RLE;\n\t      break;\n\t    case 'o':\n\t      us[j++] = FRIBIDI_CHAR_PDF;\n\t      break;\n\t    case 'L':\n\t      us[j++] = FRIBIDI_CHAR_LRO;\n\t      break;\n\t    case 'R':\n\t      us[j++] = FRIBIDI_CHAR_RLO;\n\t      break;\n            case 'i':\n              us[j++] = FRIBIDI_CHAR_LRI;\n\t      break;\n            case 'y':\n              us[j++] = FRIBIDI_CHAR_RLI;\n\t      break;\n            case 'f':\n              us[j++] = FRIBIDI_CHAR_FSI;\n\t      break;\n            case 'I':\n              us[j++] = FRIBIDI_CHAR_PDI;\n\t      break;\n\t    case '_':\n\t      us[j++] = '_';\n\t      break;\n\t    default:\n\t      us[j++] = '_';\n\t      i--;\n\t      break;\n\t    }\n\t}\n      else\n\tus[j++] = caprtl_to_unicode[(int) s[i]];\n    }\n  return j;\n}", "target": 1}
{"code": "  explicit DataFormatDimMapOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    string src_format;\n    OP_REQUIRES_OK(context, context->GetAttr(\"src_format\", &src_format));\n    string dst_format;\n    OP_REQUIRES_OK(context, context->GetAttr(\"dst_format\", &dst_format));\n    OP_REQUIRES(context, src_format.size() == 4 || src_format.size() == 5,\n                errors::InvalidArgument(strings::StrCat(\n                    \"Source format must of length 4 or 5, received \"\n                    \"src_format = \",\n                    src_format)));\n    OP_REQUIRES(\n        context, dst_format.size() == 4 || dst_format.size() == 5,\n        errors::InvalidArgument(strings::StrCat(\n            \"Destination format must of length 4 or 5, received dst_format = \",\n            dst_format)));\n    dst_idx_ = Tensor(DT_INT32, {static_cast<int64>(src_format.size())});\n    for (int i = 0; i < src_format.size(); ++i) {\n      for (int j = 0; j < dst_format.size(); ++j) {\n        if (dst_format[j] == src_format[i]) {\n          dst_idx_.vec<int>()(i) = j;\n          break;\n        }\n      }\n    }\n  }", "target": 1}
{"code": "static u32 seq_scale(u32 seq)\n{\n\treturn seq + (ktime_to_ns(ktime_get_real()) >> 6);\n}", "target": 0}
{"code": "long join_session_keyring(const char *name)\n{\n\tconst struct cred *old;\n\tstruct cred *new;\n\tstruct key *keyring;\n\tlong ret, serial;\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\told = current_cred();\n\tif (!name) {\n\t\tret = install_session_keyring_to_cred(new, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tserial = new->session_keyring->serial;\n\t\tret = commit_creds(new);\n\t\tif (ret == 0)\n\t\t\tret = serial;\n\t\tgoto okay;\n\t}\n\tmutex_lock(&key_session_mutex);\n\tkeyring = find_keyring_by_name(name, false);\n\tif (PTR_ERR(keyring) == -ENOKEY) {\n\t\tkeyring = keyring_alloc(\n\t\t\tname, old->uid, old->gid, old,\n\t\t\tKEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ | KEY_USR_LINK,\n\t\t\tKEY_ALLOC_IN_QUOTA, NULL);\n\t\tif (IS_ERR(keyring)) {\n\t\t\tret = PTR_ERR(keyring);\n\t\t\tgoto error2;\n\t\t}\n\t} else if (IS_ERR(keyring)) {\n\t\tret = PTR_ERR(keyring);\n\t\tgoto error2;\n\t} else if (keyring == new->session_keyring) {\n\t\tkey_put(keyring);\n\t\tret = 0;\n\t\tgoto error2;\n\t}\n\tret = install_session_keyring_to_cred(new, keyring);\n\tif (ret < 0)\n\t\tgoto error2;\n\tcommit_creds(new);\n\tmutex_unlock(&key_session_mutex);\n\tret = keyring->serial;\n\tkey_put(keyring);\nokay:\n\treturn ret;\nerror2:\n\tmutex_unlock(&key_session_mutex);\nerror:\n\tabort_creds(new);\n\treturn ret;\n}", "target": 0}
{"code": "mark_trusted_task_thread_func (GTask        *task,\n                               gpointer      source_object,\n                               gpointer      task_data,\n                               GCancellable *cancellable)\n{\n    MarkTrustedJob *job = task_data;\n    CommonJob *common;\n    common = (CommonJob *) job;\n    nautilus_progress_info_start (job->common.progress);\n    mark_desktop_file_trusted (common,\n                               cancellable,\n                               job->file,\n                               job->interactive);\n}", "target": 1}
{"code": "bool VariableUnserializer::matchString(folly::StringPiece str) {\n  const char* p = m_buf;\n  assertx(p <= m_end);\n  int total = 0;\n  if (*p == 'S') {\n    total = 2 + 8 + 1;\n    if (p + total > m_end) return false;\n    p++;\n    if (*p++ != ':') return false;\n    auto const sd = *reinterpret_cast<StringData*const*>(p);\n    assertx(sd->isStatic());\n    if (str.compare(sd->slice()) != 0) return false;\n    p += size_t(8);\n  } else {\n    const auto ss = str.size();\n    if (ss >= 100) return false;\n    int digits = ss >= 10 ? 2 : 1;\n    total = 2 + digits + 2 + ss + 2;\n    if (p + total > m_end) return false;\n    if (*p++ != 's') return false;\n    if (*p++ != ':') return false;\n    if (digits == 2) {\n      if (*p++ != '0' + ss/10) return false;\n      if (*p++ != '0' + ss%10) return false;\n    } else {\n      if (*p++ != '0' + ss) return false;\n    }\n    if (*p++ != ':') return false;\n    if (*p++ != '\\\"') return false;\n    if (memcmp(p, str.data(), ss)) return false;\n    p += ss;\n    if (*p++ != '\\\"') return false;\n  }\n  if (*p++ != ';') return false;\n  assertx(m_buf + total == p);\n  m_buf = p;\n  return true;\n}", "target": 1}
{"code": "static int tight_compress_data(VncState *vs, int stream_id, size_t bytes,\n                               int level, int strategy)\n{\n    z_streamp zstream = &vs->tight->stream[stream_id];\n    int previous_out;\n    if (bytes < VNC_TIGHT_MIN_TO_COMPRESS) {\n        vnc_write(vs, vs->tight->tight.buffer, vs->tight->tight.offset);\n        return bytes;\n    }\n    if (tight_init_stream(vs, stream_id, level, strategy)) {\n        return -1;\n    }\n    buffer_reserve(&vs->tight->zlib, bytes + 64);\n    zstream->next_in = vs->tight->tight.buffer;\n    zstream->avail_in = vs->tight->tight.offset;\n    zstream->next_out = vs->tight->zlib.buffer + vs->tight->zlib.offset;\n    zstream->avail_out = vs->tight->zlib.capacity - vs->tight->zlib.offset;\n    previous_out = zstream->avail_out;\n    zstream->data_type = Z_BINARY;\n    if (deflate(zstream, Z_SYNC_FLUSH) != Z_OK) {\n        fprintf(stderr, \"VNC: error during tight compression\\n\");\n        return -1;\n    }\n    vs->tight->zlib.offset = vs->tight->zlib.capacity - zstream->avail_out;\n    bytes = previous_out - zstream->avail_out;\n    tight_send_compact_size(vs, bytes);\n    vnc_write(vs, vs->tight->zlib.buffer, bytes);\n    buffer_reset(&vs->tight->zlib);\n    return bytes;\n}", "target": 0}
{"code": "static long snd_seq_ioctl(struct file *file, unsigned int cmd,\n\t\t\t  unsigned long arg)\n{\n\tstruct snd_seq_client *client = file->private_data;\n\tunion {\n\t\tint pversion;\n\t\tint client_id;\n\t\tstruct snd_seq_system_info\tsystem_info;\n\t\tstruct snd_seq_running_info\trunning_info;\n\t\tstruct snd_seq_client_info\tclient_info;\n\t\tstruct snd_seq_port_info\tport_info;\n\t\tstruct snd_seq_port_subscribe\tport_subscribe;\n\t\tstruct snd_seq_queue_info\tqueue_info;\n\t\tstruct snd_seq_queue_status\tqueue_status;\n\t\tstruct snd_seq_queue_tempo\ttempo;\n\t\tstruct snd_seq_queue_timer\tqueue_timer;\n\t\tstruct snd_seq_queue_client\tqueue_client;\n\t\tstruct snd_seq_client_pool\tclient_pool;\n\t\tstruct snd_seq_remove_events\tremove_events;\n\t\tstruct snd_seq_query_subs\tquery_subs;\n\t} buf;\n\tconst struct ioctl_handler *handler;\n\tunsigned long size;\n\tint err;\n\tif (snd_BUG_ON(!client))\n\t\treturn -ENXIO;\n\tfor (handler = ioctl_handlers; handler->cmd > 0; ++handler) {\n\t\tif (handler->cmd == cmd)\n\t\t\tbreak;\n\t}\n\tif (handler->cmd == 0)\n\t\treturn -ENOTTY;\n\tmemset(&buf, 0, sizeof(buf));\n\tsize = _IOC_SIZE(handler->cmd);\n\tif (handler->cmd & IOC_IN) {\n\t\tif (copy_from_user(&buf, (const void __user *)arg, size))\n\t\t\treturn -EFAULT;\n\t}\n\tmutex_lock(&client->ioctl_mutex);\n\terr = handler->func(client, &buf);\n\tmutex_unlock(&client->ioctl_mutex);\n\tif (err >= 0) {\n\t\tif (handler->cmd == SNDRV_SEQ_IOCTL_SET_QUEUE_CLIENT ||\n\t\t    handler->cmd == SNDRV_SEQ_IOCTL_SET_CLIENT_POOL ||\n\t\t    (handler->cmd & IOC_OUT))\n\t\t\tif (copy_to_user((void __user *)arg, &buf, size))\n\t\t\t\treturn -EFAULT;\n\t}\n\treturn err;\n}", "target": 0}
{"code": "static int gup_huge_pud(pud_t orig, pud_t *pudp, unsigned long addr,\n\t\tunsigned long end, int write, struct page **pages, int *nr)\n{\n\tstruct page *head, *page;\n\tint refs;\n\tif (!pud_access_permitted(orig, write))\n\t\treturn 0;\n\tif (pud_devmap(orig))\n\t\treturn __gup_device_huge_pud(orig, pudp, addr, end, pages, nr);\n\trefs = 0;\n\tpage = pud_page(orig) + ((addr & ~PUD_MASK) >> PAGE_SHIFT);\n\tdo {\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\t\tpage++;\n\t\trefs++;\n\t} while (addr += PAGE_SIZE, addr != end);\n\thead = compound_head(pud_page(orig));\n\tif (!page_cache_add_speculative(head, refs)) {\n\t\t*nr -= refs;\n\t\treturn 0;\n\t}\n\tif (unlikely(pud_val(orig) != pud_val(*pudp))) {\n\t\t*nr -= refs;\n\t\twhile (refs--)\n\t\t\tput_page(head);\n\t\treturn 0;\n\t}\n\tSetPageReferenced(head);\n\treturn 1;\n}", "target": 1}
{"code": "int __nla_parse(struct nlattr **tb, int maxtype,\n\t\tconst struct nlattr *head, int len,\n\t\tconst struct nla_policy *policy, unsigned int validate,\n\t\tstruct netlink_ext_ack *extack)\n{\n\treturn __nla_validate_parse(head, len, maxtype, policy, validate,\n\t\t\t\t    extack, tb);\n}", "target": 1}
{"code": "try_resolve_op_from_metadata (FlatpakTransaction *self,\n                              FlatpakTransactionOperation *op,\n                              const char *checksum,\n                              GFile *sideload_path,\n                              FlatpakRemoteState *state,\n                              GError **error)\n{\n  g_autoptr(GBytes) metadata_bytes = NULL;\n  guint64 download_size = 0;\n  guint64 installed_size = 0;\n  const char *metadata = NULL;\n  VarMetadataRef sparse_cache;\n  VarRefInfoRef info;\n  g_autofree char *summary_checksum = NULL;\n  if ((state->summary == NULL && state->index == NULL) ||\n      !flatpak_remote_state_lookup_ref (state, flatpak_decomposed_get_ref (op->ref),\n                                        &summary_checksum, NULL, NULL, NULL, NULL) ||\n      strcmp (summary_checksum, checksum) != 0)\n    return FALSE;\n  if (!flatpak_remote_state_lookup_cache (state, flatpak_decomposed_get_ref (op->ref),\n                                          &download_size, &installed_size, &metadata, NULL))\n      return FALSE;\n  metadata_bytes = g_bytes_new (metadata, strlen (metadata));\n  if (flatpak_remote_state_lookup_ref (state, flatpak_decomposed_get_ref (op->ref),\n                                       NULL, NULL, &info, NULL, NULL))\n    op->summary_metadata = var_metadata_dup_to_gvariant (var_ref_info_get_metadata (info));\n  op->installed_size = installed_size;\n  op->download_size = download_size;\n  op->token_type = state->default_token_type;\n  if (flatpak_remote_state_lookup_sparse_cache (state, flatpak_decomposed_get_ref (op->ref), &sparse_cache, NULL))\n    {\n      op->eol = g_strdup (var_metadata_lookup_string (sparse_cache, FLATPAK_SPARSE_CACHE_KEY_ENDOFLINE, NULL));\n      op->eol_rebase = g_strdup (var_metadata_lookup_string (sparse_cache, FLATPAK_SPARSE_CACHE_KEY_ENDOFLINE_REBASE, NULL));\n      op->token_type = GINT32_FROM_LE (var_metadata_lookup_int32 (sparse_cache, FLATPAK_SPARSE_CACHE_KEY_TOKEN_TYPE, op->token_type));\n    }\n  return resolve_op_end (self, op, checksum, sideload_path, metadata_bytes, error);\n}", "target": 0}
{"code": "void blk_mq_all_tag_busy_iter(struct blk_mq_tags *tags, busy_tag_iter_fn *fn,\n\t\tvoid *priv)\n{\n\tif (tags->nr_reserved_tags)\n\t\tbt_tags_for_each(tags, &tags->breserved_tags, 0, fn, priv, true);\n\tbt_tags_for_each(tags, &tags->bitmap_tags, tags->nr_reserved_tags, fn, priv,\n\t\t\tfalse);\n}", "target": 0}
{"code": "void URI_FUNC(ResetUri)(URI_TYPE(Uri) * uri) {\n\tif (uri == NULL) {\n\t\treturn;\n\t}\n\tmemset(uri, 0, sizeof(URI_TYPE(Uri)));\n}", "target": 0}
{"code": "void RtmpProtocol::handle_C1_simple(const char *data){\n    char handshake_head = HANDSHAKE_PLAINTEXT;\n    onSendRawData(obtainBuffer(&handshake_head, 1));\n    RtmpHandshake s1(0);\n    onSendRawData(obtainBuffer((char *) &s1, C1_HANDSHARK_SIZE));\n    onSendRawData(obtainBuffer(data + 1, C1_HANDSHARK_SIZE));\n    _next_step_func = [this](const char *data, size_t len) {\n        return handle_C2(data, len);\n    };\n}", "target": 0}
{"code": "static inline void ext2_xattr_destroy_cache(struct mb2_cache *cache)\n{\n}", "target": 0}
{"code": "void StelScriptOutput::saveOutputAs(const QString &name)\n{\n\tQFile asFile;\n\tconst QFileInfo outputInfo(outputFile);\n\tconst QDir dir=outputInfo.dir(); \n\tconst QFileInfo newFileNameInfo(name);\n\tconst bool okToSaveToAbsolutePath=StelApp::getInstance().getSettings()->value(\"scripts/flag_script_allow_write_absolute_path\", false).toBool();\n\tif (name.contains(\"config.ini\"))\n\t{\n\t\tqWarning() << \"SCRIPTING ERROR: You are trying to overwrite config.ini. Ignoring.\";\n\t\treturn;\n\t}\n\tif (!okToSaveToAbsolutePath && ((newFileNameInfo.isAbsolute() || (name.contains(\"..\"))))) \n\t{\n\t\tqWarning() << \"SCRIPTING CONFIGURATION ISSUE: You are trying to save to an absolute pathname or move up in directories.\";\n\t\tqWarning() << \"  To enable this, edit config.ini and set [scripts]/flag_script_allow_write_absolute_path=true\";\n\t\tasFile.setFileName(dir.absolutePath() + \"/\" + newFileNameInfo.fileName());\n\t\tqWarning() << \"  Storing to \" << asFile.fileName() << \" instead\";\n\t}\n\telse if (okToSaveToAbsolutePath && (newFileNameInfo.isAbsolute()))\n\t{\n\t\tasFile.setFileName(name);\n\t}\n\telse\n\t{\n\t\tasFile.setFileName(dir.absolutePath() + \"/\" + name);\n\t}\n\tif (!asFile.open(QIODevice::WriteOnly | QIODevice::Truncate | QIODevice::Text | QIODevice::Unbuffered))\n\t{\n\t\tqDebug() << \"ERROR: Cannot open file\" << asFile.fileName();\n\t\treturn;\n\t}\n\tqDebug() << \"saving copy of output.txt to \" << asFile.fileName();\n\tasFile.write(qPrintable(outputText), outputText.size());\n\tasFile.close();\n}", "target": 0}
{"code": "void init_xml_relax_ng()\n{\n  VALUE nokogiri = rb_define_module(\"Nokogiri\");\n  VALUE xml = rb_define_module_under(nokogiri, \"XML\");\n  VALUE klass = rb_define_class_under(xml, \"RelaxNG\", cNokogiriXmlSchema);\n  cNokogiriXmlRelaxNG = klass;\n  rb_define_singleton_method(klass, \"read_memory\", read_memory, 1);\n  rb_define_singleton_method(klass, \"from_document\", from_document, 1);\n  rb_define_private_method(klass, \"validate_document\", validate_document, 1);\n}", "target": 1}
{"code": "static inline u32 net_hash_mix(const struct net *net)\n{\n#ifdef CONFIG_NET_NS\n\treturn (u32)(((unsigned long)net) >> ilog2(sizeof(*net)));\n#else\n\treturn 0;\n#endif\n}", "target": 1}
{"code": "static void scsi_dma_restart_bh(void *opaque)\n{\n    SCSIDiskState *s = opaque;\n    SCSIRequest *req;\n    SCSIDiskReq *r;\n    qemu_bh_delete(s->bh);\n    s->bh = NULL;\n    QTAILQ_FOREACH(req, &s->qdev.requests, next) {\n        r = DO_UPCAST(SCSIDiskReq, req, req);\n        if (r->status & SCSI_REQ_STATUS_RETRY) {\n            int status = r->status;\n            int ret;\n            r->status &=\n                ~(SCSI_REQ_STATUS_RETRY | SCSI_REQ_STATUS_RETRY_TYPE_MASK);\n            switch (status & SCSI_REQ_STATUS_RETRY_TYPE_MASK) {\n            case SCSI_REQ_STATUS_RETRY_READ:\n                scsi_read_data(&r->req);\n                break;\n            case SCSI_REQ_STATUS_RETRY_WRITE:\n                scsi_write_data(&r->req);\n                break;\n            case SCSI_REQ_STATUS_RETRY_FLUSH:\n                ret = scsi_disk_emulate_command(r, r->iov.iov_base);\n                if (ret == 0) {\n                    scsi_req_complete(&r->req, GOOD);\n                }\n            }\n        }\n    }\n}", "target": 1}
{"code": "int bt_sock_recvmsg(struct socket *sock, struct msghdr *msg, size_t len,\n\t\t    int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tsize_t copied;\n\tsize_t skblen;\n\tint err;\n\tBT_DBG(\"sock %p sk %p len %zu\", sock, sk, len);\n\tif (flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\tskb = skb_recv_datagram(sk, flags, &err);\n\tif (!skb) {\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\tskblen = skb->len;\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (err == 0) {\n\t\tsock_recv_cmsgs(msg, sk, skb);\n\t\tif (msg->msg_name && bt_sk(sk)->skb_msg_name)\n\t\t\tbt_sk(sk)->skb_msg_name(skb, msg->msg_name,\n\t\t\t\t\t\t&msg->msg_namelen);\n\t\tif (test_bit(BT_SK_PKT_STATUS, &bt_sk(sk)->flags)) {\n\t\t\tu8 pkt_status = hci_skb_pkt_status(skb);\n\t\t\tput_cmsg(msg, SOL_BLUETOOTH, BT_SCM_PKT_STATUS,\n\t\t\t\t sizeof(pkt_status), &pkt_status);\n\t\t}\n\t}\n\tskb_free_datagram(sk, skb);\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skblen;\n\treturn err ? : copied;\n}", "target": 1}
{"code": "static int fastrpc_dma_buf_attach(struct dma_buf *dmabuf,\n\t\t\t\t  struct dma_buf_attachment *attachment)\n{\n\tstruct fastrpc_dma_buf_attachment *a;\n\tstruct fastrpc_buf *buffer = dmabuf->priv;\n\tint ret;\n\ta = kzalloc(sizeof(*a), GFP_KERNEL);\n\tif (!a)\n\t\treturn -ENOMEM;\n\tret = dma_get_sgtable(buffer->dev, &a->sgt, buffer->virt,\n\t\t\t      FASTRPC_PHYS(buffer->phys), buffer->size);\n\tif (ret < 0) {\n\t\tdev_err(buffer->dev, \"failed to get scatterlist from DMA API\\n\");\n\t\tkfree(a);\n\t\treturn -EINVAL;\n\t}\n\ta->dev = attachment->dev;\n\tINIT_LIST_HEAD(&a->node);\n\tattachment->priv = a;\n\tmutex_lock(&buffer->lock);\n\tlist_add(&a->node, &buffer->attachments);\n\tmutex_unlock(&buffer->lock);\n\treturn 0;\n}", "target": 0}
{"code": "static void iwjpeg_scan_exif_ifd(struct iwjpegrcontext *rctx,\n\tstruct iw_exif_state *e, iw_uint32 ifd)\n{\n\tunsigned int tag_count;\n\tunsigned int i;\n\tunsigned int tag_pos;\n\tunsigned int tag_id;\n\tunsigned int v;\n\tdouble v_dbl;\n\tif(ifd<8 || ifd>e->d_len-18) return;\n\ttag_count = iw_get_ui16_e(&e->d[ifd],e->endian);\n\tif(tag_count>1000) return; \n\tfor(i=0;i<tag_count;i++) {\n\t\ttag_pos = ifd+2+i*12;\n\t\tif(tag_pos+12 > e->d_len) return; \n\t\ttag_id = iw_get_ui16_e(&e->d[tag_pos],e->endian);\n\t\tswitch(tag_id) {\n\t\tcase 274: \n\t\t\tif(get_exif_tag_int_value(e,tag_pos,&v)) {\n\t\t\t\trctx->exif_orientation = v;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 296: \n\t\t\tif(get_exif_tag_int_value(e,tag_pos,&v)) {\n\t\t\t\trctx->exif_density_unit = v;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 282: \n\t\t\tif(get_exif_tag_dbl_value(e,tag_pos,&v_dbl)) {\n\t\t\t\trctx->exif_density_x = v_dbl;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 283: \n\t\t\tif(get_exif_tag_dbl_value(e,tag_pos,&v_dbl)) {\n\t\t\t\trctx->exif_density_y = v_dbl;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}", "target": 1}
{"code": "static int rock_continue(struct rock_state *rs)\n{\n\tint ret = 1;\n\tint blocksize = 1 << rs->inode->i_blkbits;\n\tconst int min_de_size = offsetof(struct rock_ridge, u);\n\tkfree(rs->buffer);\n\trs->buffer = NULL;\n\tif ((unsigned)rs->cont_offset > blocksize - min_de_size ||\n\t    (unsigned)rs->cont_size > blocksize ||\n\t    (unsigned)(rs->cont_offset + rs->cont_size) > blocksize) {\n\t\tprintk(KERN_NOTICE \"rock: corrupted directory entry. \"\n\t\t\t\"extent=%d, offset=%d, size=%d\\n\",\n\t\t\trs->cont_extent, rs->cont_offset, rs->cont_size);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tif (rs->cont_extent) {\n\t\tstruct buffer_head *bh;\n\t\trs->buffer = kmalloc(rs->cont_size, GFP_KERNEL);\n\t\tif (!rs->buffer) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = -EIO;\n\t\tif (++rs->cont_loops >= RR_MAX_CE_ENTRIES)\n\t\t\tgoto out;\n\t\tbh = sb_bread(rs->inode->i_sb, rs->cont_extent);\n\t\tif (bh) {\n\t\t\tmemcpy(rs->buffer, bh->b_data + rs->cont_offset,\n\t\t\t\t\trs->cont_size);\n\t\t\tput_bh(bh);\n\t\t\trs->chr = rs->buffer;\n\t\t\trs->len = rs->cont_size;\n\t\t\trs->cont_extent = 0;\n\t\t\trs->cont_size = 0;\n\t\t\trs->cont_offset = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tprintk(\"Unable to read rock-ridge attributes\\n\");\n\t}\nout:\n\tkfree(rs->buffer);\n\trs->buffer = NULL;\n\treturn ret;\n}", "target": 0}
{"code": "static int vidioc_querycap(struct file *file, void *priv,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);\n\tint labellen = (sizeof(cap->card) < sizeof(dev->card_label)) ?\n\t\t\t       sizeof(cap->card) :\n\t\t\t\t     sizeof(dev->card_label);\n\tint device_nr =\n\t\t((struct v4l2loopback_private *)video_get_drvdata(dev->vdev))\n\t\t\t->device_nr;\n\t__u32 capabilities = V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;\n\tstrlcpy(cap->driver, \"v4l2 loopback\", sizeof(cap->driver));\n\tsnprintf(cap->card, labellen, dev->card_label);\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info),\n\t\t \"platform:v4l2loopback-%03d\", device_nr);\n#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 1, 0)\n\tcap->version = V4L2LOOPBACK_VERSION_CODE;\n#endif\n#ifdef V4L2_CAP_VIDEO_M2M\n\tcapabilities |= V4L2_CAP_VIDEO_M2M;\n#endif \n\tif (dev->announce_all_caps) {\n\t\tcapabilities |= V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_OUTPUT;\n\t} else {\n\t\tif (dev->ready_for_capture) {\n\t\t\tcapabilities |= V4L2_CAP_VIDEO_CAPTURE;\n\t\t}\n\t\tif (dev->ready_for_output) {\n\t\t\tcapabilities |= V4L2_CAP_VIDEO_OUTPUT;\n\t\t}\n\t}\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)\n\tdev->vdev->device_caps =\n#endif \n\t\tcap->device_caps = cap->capabilities = capabilities;\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0)\n\tcap->capabilities |= V4L2_CAP_DEVICE_CAPS;\n#endif\n\tmemset(cap->reserved, 0, sizeof(cap->reserved));\n\treturn 0;\n}", "target": 1}
{"code": "  void Messageheader::Parser::checkHeaderspace(unsigned chars) const\n  {\n    if (headerdataPtr + chars >= header.rawdata + sizeof(header.rawdata))\n    {\n      header.rawdata[sizeof(header.rawdata) - 1] = '\\0';\n      throw HttpError(HTTP_REQUEST_ENTITY_TOO_LARGE, \"header too large\");\n    }\n  }", "target": 0}
{"code": "acpi_os_create_semaphore(u32 max_units, u32 initial_units, acpi_handle * handle)\n{\n\tstruct semaphore *sem = NULL;\n\tsem = acpi_os_allocate_zeroed(sizeof(struct semaphore));\n\tif (!sem)\n\t\treturn AE_NO_MEMORY;\n\tsema_init(sem, initial_units);\n\t*handle = (acpi_handle *) sem;\n\tACPI_DEBUG_PRINT((ACPI_DB_MUTEX, \"Creating semaphore[%p|%d].\\n\",\n\t\t\t  *handle, initial_units));\n\treturn AE_OK;\n}", "target": 0}
{"code": "struct mapped_device *dm_get_from_kobject(struct kobject *kobj)\n{\n\tstruct mapped_device *md;\n\tmd = container_of(kobj, struct mapped_device, kobj_holder.kobj);\n\tif (test_bit(DMF_FREEING, &md->flags) ||\n\t    dm_deleting_md(md))\n\t\treturn NULL;\n\tdm_get(md);\n\treturn md;\n}", "target": 1}
{"code": "static int do_siocgstamp(struct net *net, struct socket *sock,\n\t\t\t unsigned int cmd, void __user *up)\n{\n\tmm_segment_t old_fs = get_fs();\n\tstruct timeval ktv;\n\tint err;\n\tset_fs(KERNEL_DS);\n\terr = sock_do_ioctl(net, sock, cmd, (unsigned long)&ktv);\n\tset_fs(old_fs);\n\tif (!err)\n\t\terr = compat_put_timeval(up, &ktv);\n\treturn err;\n}", "target": 1}
{"code": "void ServerSecurityFeature::collectOptions(\n    std::shared_ptr<ProgramOptions> options) {\n  options\n      ->addOption(\n          \"--server.harden\",\n          \"lock down REST APIs that reveal version information or server \"\n          \"internals for non-admin users\",\n          new BooleanParameter(&_hardenedRestApi))\n      .setIntroducedIn(30500);\n  options\n      ->addOption(\"--foxx.api\", \"enables Foxx management REST APIs\",\n                  new BooleanParameter(&_enableFoxxApi),\n                  arangodb::options::makeFlags(\n                      arangodb::options::Flags::DefaultNoComponents,\n                      arangodb::options::Flags::OnCoordinator,\n                      arangodb::options::Flags::OnSingle))\n      .setIntroducedIn(30500);\n  options\n      ->addOption(\"--foxx.store\", \"enables Foxx store in web interface\",\n                  new BooleanParameter(&_enableFoxxStore),\n                  arangodb::options::makeFlags(\n                      arangodb::options::Flags::DefaultNoComponents,\n                      arangodb::options::Flags::OnCoordinator,\n                      arangodb::options::Flags::OnSingle))\n      .setIntroducedIn(30500);\n  options\n      ->addOption(\n          \"--foxx.allow-install-from-remote\",\n          \"allow installing Foxx apps from remote URLs other than Github\",\n          new BooleanParameter(&_foxxAllowInstallFromRemote),\n          arangodb::options::makeFlags(\n              arangodb::options::Flags::DefaultNoComponents,\n              arangodb::options::Flags::OnCoordinator,\n              arangodb::options::Flags::OnSingle))\n      .setIntroducedIn(30805);\n}", "target": 0}
{"code": "u32 secure_ipv6_port_ephemeral(const __be32 *saddr, const __be32 *daddr,\n\t\t\t       __be16 dport)\n{\n\tu32 secret[MD5_MESSAGE_BYTES / 4];\n\tu32 hash[MD5_DIGEST_WORDS];\n\tu32 i;\n\tmemcpy(hash, saddr, 16);\n\tfor (i = 0; i < 4; i++)\n\t\tsecret[i] = net_secret[i] + (__force u32) daddr[i];\n\tsecret[4] = net_secret[4] + (__force u32)dport;\n\tfor (i = 5; i < MD5_MESSAGE_BYTES / 4; i++)\n\t\tsecret[i] = net_secret[i];\n\tmd5_transform(hash, secret);\n\treturn hash[0];\n}", "target": 0}
{"code": "bool IsConvolutionOpSupported(const TfLiteRegistration* registration,\n                              const TfLiteNode* node, TfLiteContext* context) {\n  if (node->builtin_data == nullptr) return false;\n  TfLiteFusedActivation activation;\n  if (registration->builtin_code == kTfLiteBuiltinConv2d) {\n    const auto* conv_params =\n        reinterpret_cast<const TfLiteConvParams*>(node->builtin_data);\n    activation = conv_params->activation;\n  } else if (registration->builtin_code == kTfLiteBuiltinDepthwiseConv2d) {\n    const auto* depthwise_conv_params =\n        reinterpret_cast<const TfLiteDepthwiseConvParams*>(node->builtin_data);\n    activation = depthwise_conv_params->activation;\n  } else if (registration->builtin_code == kTfLiteBuiltinTransposeConv) {\n    activation = kTfLiteActNone;\n  } else {\n    TF_LITE_KERNEL_LOG(\n        context,\n        \"Invalid op: op must be Conv2D, DepthwiseConv2D or TransposeConv.\");\n    return false;\n  }\n  if (activation == kTfLiteActSignBit) {\n    return false;\n  }\n  const int kOutputShapeTensor = 0;  \n  const int kWeightTensor = 1;\n  const int kBiasTensor = 2;  \n  const TfLiteTensor* weights = GetInput(context, node, kWeightTensor);\n  const int max_kernel_size = 16384;\n  if (!IsConstantTensor(weights)) {\n    return false;\n  }\n  if (weights->dims->data[1] > max_kernel_size ||\n      weights->dims->data[2] > max_kernel_size) {\n    return false;\n  }\n  if (registration->builtin_code == kTfLiteBuiltinTransposeConv) {\n    if (!IsConstantTensor(GetInput(context, node, kOutputShapeTensor))) {\n      return false;\n    }\n  } else {\n    if (node->inputs->size >= kBiasTensor &&\n        !IsConstantTensor(GetInput(context, node, kBiasTensor))) {\n      return false;\n    }\n  }\n  return true;\n}", "target": 1}
{"code": "static GF_Err av1dmx_parse_flush_sample(GF_Filter *filter, GF_AV1DmxCtx *ctx)\n{\n\tu32 pck_size;\n\tGF_FilterPacket *pck;\n\tu8 *output;\n\tif (!ctx->opid)\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\tgf_bs_get_content_no_truncate(ctx->state.bs, &ctx->state.frame_obus, &pck_size, &ctx->state.frame_obus_alloc);\n\tif (!pck_size) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1Dmx] no frame OBU, skipping OBU\\n\"));\n\t\treturn GF_OK;\n\t}\n\tpck = gf_filter_pck_new_alloc(ctx->opid, pck_size, &output);\n\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, pck);\n\tgf_filter_pck_set_cts(pck, ctx->cts);\n\tgf_filter_pck_set_sap(pck, ctx->state.frame_state.key_frame ? GF_FILTER_SAP_1 : 0);\n\tmemcpy(output, ctx->state.frame_obus, pck_size);\n\tif (ctx->deps) {\n\t\tu8 flags = 0;\n\t\tflags = ( ctx->state.frame_state.key_frame) ? 2 : 1;\n\t\tflags <<= 2;\n\t \tflags |= ctx->state.frame_state.refresh_frame_flags ? 1 : 2;\n\t\tflags <<= 2;\n\t \tgf_filter_pck_set_dependency_flags(pck, flags);\n\t}\n\tgf_filter_pck_send(pck);\n\tav1dmx_update_cts(ctx);\n\tgf_av1_reset_state(&ctx->state, GF_FALSE);\n\treturn GF_OK;\n}", "target": 0}
{"code": "virSecuritySELinuxMCSFind(virSecurityManager *mgr,\n                          const char *sens,\n                          int catMin,\n                          int catMax)\n{\n    virSecuritySELinuxData *data = virSecurityManagerGetPrivateData(mgr);\n    int catRange;\n    char *mcs = NULL;\n    catRange = (catMax - catMin) + 1;\n    if (catRange < 8) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Category range c%d-c%d too small\"),\n                       catMin, catMax);\n        return NULL;\n    }\n    VIR_DEBUG(\"Using sensitivity level '%s' cat min %d max %d range %d\",\n              sens, catMin, catMax, catRange);\n    for (;;) {\n        int c1 = virRandomInt(catRange);\n        int c2 = virRandomInt(catRange);\n        VIR_DEBUG(\"Try cat %s:c%d,c%d\", sens, c1 + catMin, c2 + catMin);\n        if (c1 == c2) {\n            continue;\n        } else {\n            if (c1 > c2) {\n                int t = c1;\n                c1 = c2;\n                c2 = t;\n            }\n            mcs = g_strdup_printf(\"%s:c%d,c%d\", sens, catMin + c1, catMin + c2);\n        }\n        if (virHashLookup(data->mcs, mcs) == NULL)\n            break;\n        VIR_FREE(mcs);\n    }\n    return mcs;\n}", "target": 0}
{"code": "void ath_tx_aggr_sleep(struct ieee80211_sta *sta, struct ath_softc *sc,\n\t\t       struct ath_node *an)\n{\n\tstruct ath_atx_tid *tid;\n\tstruct ath_atx_ac *ac;\n\tstruct ath_txq *txq;\n\tbool buffered;\n\tint tidno;\n\tfor (tidno = 0, tid = &an->tid[tidno];\n\t     tidno < IEEE80211_NUM_TIDS; tidno++, tid++) {\n\t\tif (!tid->sched)\n\t\t\tcontinue;\n\t\tac = tid->ac;\n\t\ttxq = ac->txq;\n\t\tath_txq_lock(sc, txq);\n\t\tbuffered = ath_tid_has_buffered(tid);\n\t\ttid->sched = false;\n\t\tlist_del(&tid->list);\n\t\tif (ac->sched) {\n\t\t\tac->sched = false;\n\t\t\tlist_del(&ac->list);\n\t\t}\n\t\tath_txq_unlock(sc, txq);\n\t\tieee80211_sta_set_buffered(sta, tidno, buffered);\n\t}\n}", "target": 1}
{"code": "const u32 *gf_isom_get_track_switch_parameter(GF_ISOFile *movie, u32 trackNumber, u32 group_index, u32 *switchGroupID, u32 *criteriaListSize)\n{\n\tGF_TrackBox *trak;\n\tGF_UserDataMap *map;\n\tGF_TrackSelectionBox *tsel;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!group_index || !trak || !trak->udta) return NULL;\n\tmap = udta_getEntry(trak->udta, GF_ISOM_BOX_TYPE_TSEL, NULL);\n\tif (!map) return NULL;\n\ttsel = (GF_TrackSelectionBox*)gf_list_get(map->boxes, group_index-1);\n\tif (!tsel) return NULL;\n\t*switchGroupID = tsel->switchGroup;\n\t*criteriaListSize = tsel->attributeListCount;\n\treturn (const u32 *) tsel->attributeList;\n}", "target": 1}
{"code": "static int rm_rf_children_inner(\n                int fd,\n                const char *fname,\n                int is_dir,\n                RemoveFlags flags,\n                const struct stat *root_dev) {\n        struct stat st;\n        int r, q = 0;\n        assert(fd >= 0);\n        assert(fname);\n        if (is_dir < 0 ||\n            root_dev ||\n            (is_dir > 0 && (root_dev || (flags & REMOVE_SUBVOLUME)))) {\n                r = fstatat_harder(fd, fname, &st, AT_SYMLINK_NOFOLLOW, flags);\n                if (r < 0)\n                        return r;\n                is_dir = S_ISDIR(st.st_mode);\n        }\n        if (is_dir) {\n                _cleanup_close_ int subdir_fd = -1;\n                if (root_dev && st.st_dev != root_dev->st_dev)\n                        return 0;\n                r = fd_is_mount_point(fd, fname, 0);\n                if (r < 0)\n                        return r;\n                if (r > 0)\n                        return 0;\n                if ((flags & REMOVE_SUBVOLUME) && btrfs_might_be_subvol(&st)) {\n                        r = btrfs_subvol_remove_fd(fd, fname, BTRFS_REMOVE_RECURSIVE|BTRFS_REMOVE_QUOTA);\n                        if (r < 0) {\n                                if (!IN_SET(r, -ENOTTY, -EINVAL))\n                                        return r;\n                        } else\n                                return 1;\n                }\n                subdir_fd = openat(fd, fname, O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);\n                if (subdir_fd < 0)\n                        return -errno;\n                q = rm_rf_children(TAKE_FD(subdir_fd), flags | REMOVE_PHYSICAL, root_dev);\n        } else if (flags & REMOVE_ONLY_DIRECTORIES)\n                return 0;\n        r = unlinkat_harder(fd, fname, is_dir ? AT_REMOVEDIR : 0, flags);\n        if (r < 0)\n                return r;\n        if (q < 0)\n                return q;\n        return 1;\n}", "target": 1}
{"code": "ErrorCode HTTP2Codec::checkNewStream(uint32_t streamId, bool trailersAllowed) {\n  if (streamId == 0) {\n    goawayErrorMessage_ = folly::to<string>(\n        \"GOAWAY error: received streamID=\", streamId,\n        \" as invalid new stream for lastStreamID_=\", lastStreamID_);\n    VLOG(4) << goawayErrorMessage_;\n    return ErrorCode::PROTOCOL_ERROR;\n  }\n  parsingDownstreamTrailers_ = trailersAllowed && (streamId <= lastStreamID_);\n  if (parsingDownstreamTrailers_) {\n    VLOG(4) << \"Parsing downstream trailers streamId=\" << streamId;\n  }\n  if (sessionClosing_ != ClosingState::CLOSED) {\n    lastStreamID_ = streamId;\n  }\n  if (isInitiatedStream(streamId)) {\n    goawayErrorMessage_ = folly::to<string>(\n        \"GOAWAY error: invalid new stream received with streamID=\", streamId);\n    VLOG(4) << goawayErrorMessage_;\n    return ErrorCode::PROTOCOL_ERROR;\n  } else {\n    return ErrorCode::NO_ERROR;\n  }\n}", "target": 1}
{"code": "int av_hwframe_ctx_init(AVBufferRef *ref)\n{\n    AVHWFramesContext *ctx = (AVHWFramesContext*)ref->data;\n    const enum AVPixelFormat *pix_fmt;\n    int ret;\n    if (ctx->internal->source_frames) {\n        return 0;\n    }\n    for (pix_fmt = ctx->internal->hw_type->pix_fmts; *pix_fmt != AV_PIX_FMT_NONE; pix_fmt++) {\n        if (*pix_fmt == ctx->format)\n            break;\n    }\n    if (*pix_fmt == AV_PIX_FMT_NONE) {\n        av_log(ctx, AV_LOG_ERROR,\n               \"The hardware pixel format '%s' is not supported by the device type '%s'\\n\",\n               av_get_pix_fmt_name(ctx->format), ctx->internal->hw_type->name);\n        return AVERROR(ENOSYS);\n    }\n    ret = av_image_check_size(ctx->width, ctx->height, 0, ctx);\n    if (ret < 0)\n        return ret;\n    if (ctx->internal->hw_type->frames_init) {\n        ret = ctx->internal->hw_type->frames_init(ctx);\n        if (ret < 0)\n            goto fail;\n    }\n    if (ctx->internal->pool_internal && !ctx->pool)\n        ctx->pool = ctx->internal->pool_internal;\n    if (ctx->initial_pool_size > 0) {\n        ret = hwframe_pool_prealloc(ref);\n        if (ret < 0)\n            goto fail;\n    }\n    return 0;\nfail:\n    if (ctx->internal->hw_type->frames_uninit)\n        ctx->internal->hw_type->frames_uninit(ctx);\n    return ret;\n}", "target": 1}
{"code": "bool CModules::GetModPathInfo(CModInfo& ModInfo, const CString& sModule,\n                              const CString& sModPath, CString& sRetMsg) {\n    if (!ValidateModuleName(sModule, sRetMsg)) {\n        return false;\n    }\n    ModInfo.SetName(sModule);\n    ModInfo.SetPath(sModPath);\n    ModHandle p = OpenModule(sModule, sModPath, ModInfo, sRetMsg);\n    if (!p) return false;\n    dlclose(p);\n    return true;\n}", "target": 0}
{"code": "static MagickBooleanType IsTXT(const unsigned char *magick,const size_t length)\n{\n#define MagickID  \"# ImageMagick pixel enumeration:\"\n  char\n    colorspace[MagickPathExtent];\n  ssize_t\n    count;\n  unsigned long\n    columns,\n    depth,\n    rows;\n  if (length < 40)\n    return(MagickFalse);\n  if (LocaleNCompare((const char *) magick,MagickID,strlen(MagickID)) != 0)\n    return(MagickFalse);\n  count=(ssize_t) sscanf((const char *) magick+32,\"%lu,%lu,%lu,%s\",&columns,\n    &rows,&depth,colorspace);\n  if (count != 4)\n    return(MagickFalse);\n  return(MagickTrue);\n}", "target": 0}
{"code": "\tvoid Execute(CommandSource &source, const std::vector<Anope::string> &params) anope_override\n\t{\n\t\tconst NickAlias *na;\n\t\tif (!(na = NickAlias::Find(params[0])))\n\t\t\tsource.Reply(NICK_X_NOT_REGISTERED, params[0].c_str());\n\t\telse if (na->nc->HasExt(\"NS_SUSPENDED\"))\n\t\t\tsource.Reply(NICK_X_SUSPENDED, na->nc->display.c_str());\n\t\telse if (!na->nc->email.equals_ci(params[1]))\n\t\t\tsource.Reply(_(\"Incorrect email address.\"));\n\t\telse\n\t\t{\n\t\t\tif (SendResetEmail(source.GetUser(), na, source.service))\n\t\t\t{\n\t\t\t\tLog(LOG_COMMAND, source, this) << \"for \" << na->nick << \" (group: \" << na->nc->display << \")\";\n\t\t\t\tsource.Reply(_(\"Password reset email for \\002%s\\002 has been sent.\"), na->nick.c_str());\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}", "target": 0}
{"code": "  Status CalculateOutputIndexValueRowID(\n      const RowPartitionTensor& value_rowids,\n      const vector<INDEX_TYPE>& parent_output_index,\n      INDEX_TYPE output_index_multiplier, INDEX_TYPE output_size,\n      vector<INDEX_TYPE>* result) {\n    const INDEX_TYPE index_size = value_rowids.size();\n    result->reserve(index_size);\n    if (index_size == 0) {\n      return Status::OK();\n    }\n    INDEX_TYPE current_output_column = 0;\n    INDEX_TYPE current_value_rowid = value_rowids(0);\n    if (current_value_rowid >= parent_output_index.size()) {\n      return errors::InvalidArgument(\n          \"Got current_value_rowid=\", current_value_rowid,\n          \" which is not less than \", parent_output_index.size());\n    }\n    INDEX_TYPE current_output_index = parent_output_index[current_value_rowid];\n    result->push_back(current_output_index);\n    for (INDEX_TYPE i = 1; i < index_size; ++i) {\n      INDEX_TYPE next_value_rowid = value_rowids(i);\n      if (next_value_rowid == current_value_rowid) {\n        if (current_output_index >= 0) {\n          ++current_output_column;\n          if (current_output_column < output_size) {\n            current_output_index += output_index_multiplier;\n          } else {\n            current_output_index = -1;\n          }\n        }\n      } else {\n        current_output_column = 0;\n        current_value_rowid = next_value_rowid;\n        if (next_value_rowid >= parent_output_index.size()) {\n          return errors::InvalidArgument(\n              \"Got next_value_rowid=\", next_value_rowid,\n              \" which is not less than \", parent_output_index.size());\n        }\n        current_output_index = parent_output_index[next_value_rowid];\n      }\n      result->push_back(current_output_index);\n    }\n    if (result->size() != value_rowids.size()) {\n      return errors::InvalidArgument(\"Invalid row ids.\");\n    }\n    return Status::OK();\n  }", "target": 0}
{"code": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\tif (inode_capable(inode, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}", "target": 1}
{"code": "archive_read_format_rar_read_data(struct archive_read *a, const void **buff,\n                                  size_t *size, int64_t *offset)\n{\n  struct rar *rar = (struct rar *)(a->format->data);\n  int ret;\n  if (rar->has_encrypted_entries == ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW) {\n\t  rar->has_encrypted_entries = 0;\n  }\n  if (rar->bytes_unconsumed > 0) {\n      __archive_read_consume(a, rar->bytes_unconsumed);\n      rar->bytes_unconsumed = 0;\n  }\n  *buff = NULL;\n  if (rar->entry_eof || rar->offset_seek >= rar->unp_size) {\n    *size = 0;\n    *offset = rar->offset;\n    if (*offset < rar->unp_size)\n      *offset = rar->unp_size;\n    return (ARCHIVE_EOF);\n  }\n  switch (rar->compression_method)\n  {\n  case COMPRESS_METHOD_STORE:\n    ret = read_data_stored(a, buff, size, offset);\n    break;\n  case COMPRESS_METHOD_FASTEST:\n  case COMPRESS_METHOD_FAST:\n  case COMPRESS_METHOD_NORMAL:\n  case COMPRESS_METHOD_GOOD:\n  case COMPRESS_METHOD_BEST:\n    ret = read_data_compressed(a, buff, size, offset);\n    if (ret != ARCHIVE_OK && ret != ARCHIVE_WARN)\n      __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context);\n    break;\n  default:\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Unsupported compression method for RAR file.\");\n    ret = ARCHIVE_FATAL;\n    break;\n  }\n  return (ret);\n}", "target": 1}
{"code": "static int __init acpi_custom_method_init(void)\n{\n\tif (!acpi_debugfs_dir)\n\t\treturn -ENOENT;\n\tcm_dentry = debugfs_create_file(\"custom_method\", S_IWUSR,\n\t\t\t\t\tacpi_debugfs_dir, NULL, &cm_fops);\n\tif (!cm_dentry)\n\t\treturn -ENODEV;\n\treturn 0;\n}", "target": 1}
{"code": "bool Sampler::operator==(const Sampler &other) const {\n  return this->extensions == other.extensions && this->extras == other.extras &&\n         this->magFilter == other.magFilter &&\n         this->minFilter == other.minFilter && this->name == other.name &&\n         this->wrapS == other.wrapS &&\n         this->wrapT == other.wrapT;\n}", "target": 1}
{"code": "RecordPadAlign(int size, int align)\n{\n    return (align - (size & (align - 1))) & (align - 1);\n}                               ", "target": 0}
{"code": "smtp_log_no_mail(void)\n{\nint i;\nuschar * sep, * s;\ngstring * g = NULL;\nif (smtp_mailcmd_count > 0 || !LOGGING(smtp_no_mail))\n  return;\nif (sender_host_authenticated)\n  {\n  g = string_append(g, 2, US\" A=\", sender_host_authenticated);\n  if (authenticated_id) g = string_append(g, 2, US\":\", authenticated_id);\n  }\n#ifdef SUPPORT_TLS\ng = s_tlslog(g);\n#endif\nsep = smtp_connection_had[SMTP_HBUFF_SIZE-1] != SCH_NONE ?  US\" C=...\" : US\" C=\";\nfor (i = smtp_ch_index; i < SMTP_HBUFF_SIZE; i++)\n  if (smtp_connection_had[i] != SCH_NONE)\n    {\n    g = string_append(g, 2, sep, smtp_names[smtp_connection_had[i]]);\n    sep = US\",\";\n    }\nfor (i = 0; i < smtp_ch_index; i++)\n  {\n  g = string_append(g, 2, sep, smtp_names[smtp_connection_had[i]]);\n  sep = US\",\";\n  }\nif (!(s = string_from_gstring(g))) s = US\"\";\nlog_write(0, LOG_MAIN, \"no MAIL in %sSMTP connection from %s D=%s%s\",\n  f.tcp_in_fastopen ? f.tcp_in_fastopen_data ? US\"TFO* \" : US\"TFO \" : US\"\",\n  host_and_ident(FALSE), string_timesince(&smtp_connection_start), s);\n}", "target": 0}
{"code": "gif_read_image(FILE       *fp,\t\t\n\t       image_t    *img,\t\t\n\t       gif_cmap_t cmap,\t\t\n\t       int        interlace,\t\n\t       int        transparent)\t\n{\n  uchar\t\tcode_size,\t\t\n\t\t*temp;\t\t\t\n  int\t\txpos,\t\t\t\n\t\typos,\t\t\t\n\t\tpass;\t\t\t\n  int\t\tpixel;\t\t\t\n  static int\txpasses[4] = { 8, 8, 4, 2 },\n\t\typasses[5] = { 0, 4, 2, 1, 999999 };\n  xpos      = 0;\n  ypos      = 0;\n  pass      = 0;\n  code_size = (uchar)getc(fp);\n  if (code_size > 12)\n  {\n    progress_error(HD_ERROR_READ_ERROR, \"Bad GIF file \\\"%s\\\" - invalid code size %d.\", img->filename, code_size);\n    return (-1);\n  }\n  if (gif_read_lzw(fp, 1, code_size) < 0)\n    return (-1);\n  temp = img->pixels;\n  while ((pixel = gif_read_lzw(fp, 0, code_size)) >= 0 && pixel < 256)\n  {\n    temp[0] = cmap[pixel][0];\n    if (img->depth > 1)\n    {\n      temp[1] = cmap[pixel][1];\n      temp[2] = cmap[pixel][2];\n    }\n    if (pixel == transparent)\n      image_set_mask(img, xpos, ypos);\n    xpos ++;\n    temp += img->depth;\n    if (xpos == img->width)\n    {\n      xpos = 0;\n      if (interlace)\n      {\n        ypos += xpasses[pass];\n        temp += (xpasses[pass] - 1) * img->width * img->depth;\n        if (ypos >= img->height)\n\t{\n\t  pass ++;\n          ypos = ypasses[pass];\n          temp = img->pixels + ypos * img->width * img->depth;\n\t}\n      }\n      else\n\typos ++;\n    }\n    if (ypos >= img->height)\n      break;\n  }\n  return (0);\n}", "target": 0}
{"code": "static void stellaris_enet_unrealize(DeviceState *dev, Error **errp)\n{\n    stellaris_enet_state *s = STELLARIS_ENET(dev);\n    unregister_savevm(DEVICE(s), \"stellaris_enet\", s);\n    memory_region_destroy(&s->mmio);\n}", "target": 1}
{"code": "void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tunsigned long flags;\n\tif (PCM_RUNTIME_CHECK(substream))\n\t\treturn;\n\truntime = substream->runtime;\n\tsnd_pcm_stream_lock_irqsave(substream, flags);\n\tif (!snd_pcm_running(substream) ||\n\t    snd_pcm_update_hw_ptr0(substream, 1) < 0)\n\t\tgoto _end;\n#ifdef CONFIG_SND_PCM_TIMER\n\tif (substream->timer_running)\n\t\tsnd_timer_interrupt(substream->timer, 1);\n#endif\n _end:\n\tsnd_pcm_stream_unlock_irqrestore(substream, flags);\n\tkill_fasync(&runtime->fasync, SIGIO, POLL_IN);\n}", "target": 1}
{"code": "TRIO_PUBLIC trio_pointer_t trio_register TRIO_ARGS2((callback, name), trio_callback_t callback,\n                                                    TRIO_CONST char* name)\n{\n\ttrio_userdef_t* def;\n\ttrio_userdef_t* prev = NULL;\n\tif (callback == NULL)\n\t\treturn NULL;\n\tif (name)\n\t{\n\t\tif (name[0] == ':')\n\t\t{\n\t\t\tif (trio_equal(name, \":enter\"))\n\t\t\t{\n\t\t\t\tinternalEnterCriticalRegion = callback;\n\t\t\t}\n\t\t\telse if (trio_equal(name, \":leave\"))\n\t\t\t{\n\t\t\t\tinternalLeaveCriticalRegion = callback;\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t\tif (trio_length(name) >= MAX_USER_NAME)\n\t\t\treturn NULL;\n\t\tdef = TrioFindNamespace(name, &prev);\n\t\tif (def)\n\t\t\treturn NULL;\n\t}\n\tdef = (trio_userdef_t*)TRIO_MALLOC(sizeof(trio_userdef_t));\n\tif (def)\n\t{\n\t\tif (internalEnterCriticalRegion)\n\t\t\t(void)internalEnterCriticalRegion(NULL);\n\t\tif (name)\n\t\t{\n\t\t\tif (prev == NULL)\n\t\t\t\tinternalUserDef = def;\n\t\t\telse\n\t\t\t\tprev->next = def;\n\t\t}\n\t\tdef->callback = callback;\n\t\tdef->name = (name == NULL) ? NULL : trio_duplicate(name);\n\t\tdef->next = NULL;\n\t\tif (internalLeaveCriticalRegion)\n\t\t\t(void)internalLeaveCriticalRegion(NULL);\n\t}\n\treturn (trio_pointer_t)def;\n}", "target": 1}
{"code": "TfLiteStatus Relu6Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n  Relu6OpData* data = static_cast<Relu6OpData*>(node->user_data);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE(context, input != nullptr);\n  if (input->type == kTfLiteInt8) {\n    data->six_int8 = FloatToAsymmetricQuantizedInt8(6.0f, input->params.scale,\n                                                    input->params.zero_point);\n    data->zero_int8 = input->params.zero_point;\n  } else if (input->type == kTfLiteUInt8) {\n    data->six_uint8 = FloatToAsymmetricQuantizedUInt8(6.0f, input->params.scale,\n                                                      input->params.zero_point);\n    data->zero_uint8 = input->params.zero_point;\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "int udf_get_filename(struct super_block *sb, uint8_t *sname, uint8_t *dname,\n\t\t     int flen)\n{\n\tstruct ustr *filename, *unifilename;\n\tint len = 0;\n\tfilename = kmalloc(sizeof(struct ustr), GFP_NOFS);\n\tif (!filename)\n\t\treturn 0;\n\tunifilename = kmalloc(sizeof(struct ustr), GFP_NOFS);\n\tif (!unifilename)\n\t\tgoto out1;\n\tif (udf_build_ustr_exact(unifilename, sname, flen))\n\t\tgoto out2;\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_UTF8)) {\n\t\tif (!udf_CS0toUTF8(filename, unifilename)) {\n\t\t\tudf_debug(\"Failed in udf_get_filename: sname = %s\\n\",\n\t\t\t\t  sname);\n\t\t\tgoto out2;\n\t\t}\n\t} else if (UDF_QUERY_FLAG(sb, UDF_FLAG_NLS_MAP)) {\n\t\tif (!udf_CS0toNLS(UDF_SB(sb)->s_nls_map, filename,\n\t\t\t\t  unifilename)) {\n\t\t\tudf_debug(\"Failed in udf_get_filename: sname = %s\\n\",\n\t\t\t\t  sname);\n\t\t\tgoto out2;\n\t\t}\n\t} else\n\t\tgoto out2;\n\tlen = udf_translate_to_linux(dname, filename->u_name, filename->u_len,\n\t\t\t\t     unifilename->u_name, unifilename->u_len);\nout2:\n\tkfree(unifilename);\nout1:\n\tkfree(filename);\n\treturn len;\n}", "target": 1}
{"code": "    void CrwMap::encode0x1810(const Image&      image,\n                              const CrwMapping* pCrwMapping,\n                                    CiffHeader* pHead)\n    {\n        assert(pCrwMapping != 0);\n        assert(pHead != 0);\n        const ExifKey kX(\"Exif.Photo.PixelXDimension\");\n        const ExifKey kY(\"Exif.Photo.PixelYDimension\");\n        const ExifKey kO(\"Exif.Image.Orientation\");\n        const ExifData &exivData = image.exifData();\n        const ExifData::const_iterator edX = exivData.findKey(kX);\n        const ExifData::const_iterator edY = exivData.findKey(kY);\n        const ExifData::const_iterator edO = exivData.findKey(kO);\n        const ExifData::const_iterator edEnd = exivData.end();\n        CiffComponent* cc = pHead->findComponent(pCrwMapping->crwTagId_,\n                                                 pCrwMapping->crwDir_);\n        if (edX != edEnd || edY != edEnd || edO != edEnd) {\n            uint32_t size = 28;\n            if (cc) {\n              if (cc->size() < size)\n                throw Error(kerCorruptedMetadata);\n              size = cc->size();\n            }\n            DataBuf buf(size);\n            std::memset(buf.pData_, 0x0, buf.size_);\n            if (cc) std::memcpy(buf.pData_ + 8, cc->pData() + 8, cc->size() - 8);\n            if (edX != edEnd && edX->size() == 4) {\n                edX->copy(buf.pData_, pHead->byteOrder());\n            }\n            if (edY != edEnd && edY->size() == 4) {\n                edY->copy(buf.pData_ + 4, pHead->byteOrder());\n            }\n            int32_t d = 0;\n            if (edO != edEnd && edO->count() > 0 && edO->typeId() == unsignedShort) {\n                d = RotationMap::degrees(static_cast<uint16_t>(edO->toLong()));\n            }\n            l2Data(buf.pData_ + 12, d, pHead->byteOrder());\n            pHead->add(pCrwMapping->crwTagId_, pCrwMapping->crwDir_, buf);\n        }\n        else {\n            pHead->remove(pCrwMapping->crwTagId_, pCrwMapping->crwDir_);\n        }\n    } ", "target": 0}
{"code": "static bool dccp_new(struct nf_conn *ct, const struct sk_buff *skb,\n\t\t     unsigned int dataoff, unsigned int *timeouts)\n{\n\tstruct net *net = nf_ct_net(ct);\n\tstruct dccp_net *dn;\n\tstruct dccp_hdr _dh, *dh;\n\tconst char *msg;\n\tu_int8_t state;\n\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);\n\tBUG_ON(dh == NULL);\n\tstate = dccp_state_table[CT_DCCP_ROLE_CLIENT][dh->dccph_type][CT_DCCP_NONE];\n\tswitch (state) {\n\tdefault:\n\t\tdn = dccp_pernet(net);\n\t\tif (dn->dccp_loose == 0) {\n\t\t\tmsg = \"nf_ct_dccp: not picking up existing connection \";\n\t\t\tgoto out_invalid;\n\t\t}\n\tcase CT_DCCP_REQUEST:\n\t\tbreak;\n\tcase CT_DCCP_INVALID:\n\t\tmsg = \"nf_ct_dccp: invalid state transition \";\n\t\tgoto out_invalid;\n\t}\n\tct->proto.dccp.role[IP_CT_DIR_ORIGINAL] = CT_DCCP_ROLE_CLIENT;\n\tct->proto.dccp.role[IP_CT_DIR_REPLY] = CT_DCCP_ROLE_SERVER;\n\tct->proto.dccp.state = CT_DCCP_NONE;\n\tct->proto.dccp.last_pkt = DCCP_PKT_REQUEST;\n\tct->proto.dccp.last_dir = IP_CT_DIR_ORIGINAL;\n\tct->proto.dccp.handshake_seq = 0;\n\treturn true;\nout_invalid:\n\tif (LOG_INVALID(net, IPPROTO_DCCP))\n\t\tnf_log_packet(net, nf_ct_l3num(ct), 0, skb, NULL, NULL,\n\t\t\t      NULL, \"%s\", msg);\n\treturn false;\n}", "target": 1}
{"code": "ExpressionMap::ExpressionMap(ExpressionContext* const expCtx,\n                             const string& varName,\n                             Variables::Id varId,\n                             intrusive_ptr<Expression> input,\n                             intrusive_ptr<Expression> each)\n    : Expression(expCtx, {std::move(input), std::move(each)}),\n      _varName(varName),\n      _varId(varId),\n      _input(_children[0]),\n      _each(_children[1]) {}", "target": 0}
{"code": "static int burl_normalize_2F_to_slash_fix (buffer *b, int qs, int i)\n{\n    char * const s = b->ptr;\n    const int blen = (int)buffer_string_length(b);\n    const int used = qs < 0 ? blen : qs;\n    int j = i;\n    for (; i < used; ++i, ++j) {\n        s[j] = s[i];\n        if (s[i] == '%' && s[i+1] == '2' && s[i+2] == 'F') {\n            s[j] = '/';\n            i+=2;\n        }\n    }\n    if (qs >= 0) {\n        memmove(s+j, s+qs, blen - qs);\n        j += blen - qs;\n    }\n    buffer_string_set_length(b, j);\n    return qs;\n}", "target": 1}
{"code": "int netdev_printk(const char *level, const struct net_device *dev,\n\t\t  const char *format, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint r;\n\tva_start(args, format);\n\tvaf.fmt = format;\n\tvaf.va = &args;\n\tr = __netdev_printk(level, dev, &vaf);\n\tva_end(args);\n\treturn r;\n}", "target": 0}
{"code": "int compat_ipv6_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t   char __user *optval, unsigned int optlen)\n{\n\tint err;\n\tif (level == SOL_IP && sk->sk_type != SOCK_RAW) {\n\t\tif (udp_prot.compat_setsockopt != NULL)\n\t\t\treturn udp_prot.compat_setsockopt(sk, level, optname,\n\t\t\t\t\t\t\t  optval, optlen);\n\t\treturn udp_prot.setsockopt(sk, level, optname, optval, optlen);\n\t}\n\tif (level != SOL_IPV6)\n\t\treturn -ENOPROTOOPT;\n\tif (optname >= MCAST_JOIN_GROUP && optname <= MCAST_MSFILTER)\n\t\treturn compat_mc_setsockopt(sk, level, optname, optval, optlen,\n\t\t\tipv6_setsockopt);\n\terr = do_ipv6_setsockopt(sk, level, optname, optval, optlen);\n#ifdef CONFIG_NETFILTER\n\tif (err == -ENOPROTOOPT && optname != IPV6_IPSEC_POLICY &&\n\t    optname != IPV6_XFRM_POLICY)\n\t\terr = compat_nf_setsockopt(sk, PF_INET6, optname, optval,\n\t\t\t\t\t   optlen);\n#endif\n\treturn err;\n}", "target": 0}
{"code": "static int udf_encode_fh(struct inode *inode, __u32 *fh, int *lenp,\n\t\t\t struct inode *parent)\n{\n\tint len = *lenp;\n\tstruct kernel_lb_addr location = UDF_I(inode)->i_location;\n\tstruct fid *fid = (struct fid *)fh;\n\tint type = FILEID_UDF_WITHOUT_PARENT;\n\tif (parent && (len < 5)) {\n\t\t*lenp = 5;\n\t\treturn 255;\n\t} else if (len < 3) {\n\t\t*lenp = 3;\n\t\treturn 255;\n\t}\n\t*lenp = 3;\n\tfid->udf.block = location.logicalBlockNum;\n\tfid->udf.partref = location.partitionReferenceNum;\n\tfid->udf.parent_partref = 0;\n\tfid->udf.generation = inode->i_generation;\n\tif (parent) {\n\t\tlocation = UDF_I(parent)->i_location;\n\t\tfid->udf.parent_block = location.logicalBlockNum;\n\t\tfid->udf.parent_partref = location.partitionReferenceNum;\n\t\tfid->udf.parent_generation = inode->i_generation;\n\t\t*lenp = 5;\n\t\ttype = FILEID_UDF_WITH_PARENT;\n\t}\n\treturn type;\n}", "target": 0}
{"code": "struct timespec ns_to_timespec(const s64 nsec)\n{\n\tstruct timespec ts;\n\tif (!nsec)\n\t\treturn (struct timespec) {0, 0};\n\tts.tv_sec = div_long_long_rem_signed(nsec, NSEC_PER_SEC, &ts.tv_nsec);\n\tif (unlikely(nsec < 0))\n\t\tset_normalized_timespec(&ts, ts.tv_sec, ts.tv_nsec);\n\treturn ts;\n}", "target": 1}
{"code": "int hns_ppe_get_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn ETH_PPE_STATIC_NUM;\n\treturn 0;\n}", "target": 1}
{"code": "MagickExport MagickBooleanType DrawClipPath(Image *image,\n  const DrawInfo *draw_info,const char *name,ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n  Image\n    *clip_mask;\n  const char\n    *value;\n  DrawInfo\n    *clone_info;\n  MagickStatusType\n    status;\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(draw_info != (const DrawInfo *) NULL);\n  (void) FormatLocaleString(filename,MagickPathExtent,\"%s\",name);\n  value=GetImageArtifact(image,filename);\n  if (value == (const char *) NULL)\n    return(MagickFalse);\n  clip_mask=CloneImage(image,image->columns,image->rows,MagickTrue,exception);\n  if (clip_mask == (Image *) NULL)\n    return(MagickFalse);\n  (void) QueryColorCompliance(\"#0000\",AllCompliance,\n    &clip_mask->background_color,exception);\n  clip_mask->background_color.alpha=(Quantum) TransparentAlpha;\n  (void) SetImageBackgroundColor(clip_mask,exception);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"\\nbegin clip-path %s\",\n      draw_info->clip_mask);\n  clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  (void) CloneString(&clone_info->primitive,value);\n  (void) QueryColorCompliance(\"#ffffff\",AllCompliance,&clone_info->fill,\n    exception);\n  clone_info->clip_mask=(char *) NULL;\n  status=NegateImage(clip_mask,MagickFalse,exception);\n  (void) SetImageMask(image,ReadPixelMask,clip_mask,exception);\n  clip_mask=DestroyImage(clip_mask);\n  status&=DrawImage(image,clone_info,exception);\n  clone_info=DestroyDrawInfo(clone_info);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"end clip-path\");\n  return(status != 0 ? MagickTrue : MagickFalse);\n}", "target": 1}
{"code": "static bool get_user_list(struct torture_context *torture, char ***users)\n{\n\tstruct winbindd_request req;\n\tstruct winbindd_response rep;\n\tchar **u = NULL;\n\tuint32_t count;\n\tchar name[256];\n\tconst char *extra_data;\n\tZERO_STRUCT(req);\n\tZERO_STRUCT(rep);\n\tDO_STRUCT_REQ_REP(WINBINDD_LIST_USERS, &req, &rep);\n\textra_data = (char *)rep.extra_data.data;\n\ttorture_assert(torture, extra_data, \"NULL extra data\");\n\tfor(count = 0;\n\t    next_token(&extra_data, name, \",\", sizeof(name));\n\t    count++)\n\t{\n\t\tu = talloc_realloc(torture, u, char *, count + 2);\n\t\tu[count+1] = NULL;\n\t\tu[count] = talloc_strdup(u, name);\n\t}\n\tSAFE_FREE(rep.extra_data.data);\n\t*users = u;\n\treturn true;\n}", "target": 0}
{"code": "int ConnectionImpl::saveHeader(const nghttp2_frame* frame, HeaderString&& name,\n                               HeaderString&& value) {\n  StreamImpl* stream = getStream(frame->hd.stream_id);\n  if (!stream) {\n    stats_.headers_cb_no_stream_.inc();\n    return 0;\n  }\n  stream->saveHeader(std::move(name), std::move(value));\n  if (stream->headers_->byteSize() > max_request_headers_kb_ * 1024) {\n    stats_.header_overflow_.inc();\n    return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;\n  } else {\n    return 0;\n  }\n}", "target": 1}
{"code": "int create_flush_cmd_control(struct f2fs_sb_info *sbi)\n{\n\tdev_t dev = sbi->sb->s_bdev->bd_dev;\n\tstruct flush_cmd_control *fcc;\n\tint err = 0;\n\tif (SM_I(sbi)->fcc_info) {\n\t\tfcc = SM_I(sbi)->fcc_info;\n\t\tgoto init_thread;\n\t}\n\tfcc = kzalloc(sizeof(struct flush_cmd_control), GFP_KERNEL);\n\tif (!fcc)\n\t\treturn -ENOMEM;\n\tatomic_set(&fcc->issued_flush, 0);\n\tatomic_set(&fcc->issing_flush, 0);\n\tinit_waitqueue_head(&fcc->flush_wait_queue);\n\tinit_llist_head(&fcc->issue_list);\n\tSM_I(sbi)->fcc_info = fcc;\n\tif (!test_opt(sbi, FLUSH_MERGE))\n\t\treturn err;\ninit_thread:\n\tfcc->f2fs_issue_flush = kthread_run(issue_flush_thread, sbi,\n\t\t\t\t\"f2fs_flush-%u:%u\", MAJOR(dev), MINOR(dev));\n\tif (IS_ERR(fcc->f2fs_issue_flush)) {\n\t\terr = PTR_ERR(fcc->f2fs_issue_flush);\n\t\tkfree(fcc);\n\t\tSM_I(sbi)->fcc_info = NULL;\n\t\treturn err;\n\t}\n\treturn err;\n}", "target": 0}
{"code": "static int digi_startup(struct usb_serial *serial)\n{\n\tstruct device *dev = &serial->interface->dev;\n\tstruct digi_serial *serial_priv;\n\tint ret;\n\tint i;\n\tif (serial->num_port_pointers < serial->type->num_ports + 1) {\n\t\tdev_err(dev, \"OOB endpoints missing\\n\");\n\t\treturn -ENODEV;\n\t}\n\tfor (i = 0; i < serial->type->num_ports + 1 ; i++) {\n\t\tif (!serial->port[i]->read_urb) {\n\t\t\tdev_err(dev, \"bulk-in endpoint missing\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tif (!serial->port[i]->write_urb) {\n\t\t\tdev_err(dev, \"bulk-out endpoint missing\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\tserial_priv = kzalloc(sizeof(*serial_priv), GFP_KERNEL);\n\tif (!serial_priv)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&serial_priv->ds_serial_lock);\n\tserial_priv->ds_oob_port_num = serial->type->num_ports;\n\tserial_priv->ds_oob_port = serial->port[serial_priv->ds_oob_port_num];\n\tret = digi_port_init(serial_priv->ds_oob_port,\n\t\t\t\t\t\tserial_priv->ds_oob_port_num);\n\tif (ret) {\n\t\tkfree(serial_priv);\n\t\treturn ret;\n\t}\n\tusb_set_serial_data(serial, serial_priv);\n\treturn 0;\n}", "target": 0}
{"code": "void js_rot(js_State *J, int n)\n{\n\tint i;\n\tjs_Value tmp = STACK[TOP-1];\n\tfor (i = 1; i < n; ++i)\n\t\tSTACK[TOP-i] = STACK[TOP-i-1];\n\tSTACK[TOP-i] = tmp;\n}", "target": 0}
{"code": "int smb2_allocate_rsp_buf(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *hdr = smb2_get_msg(work->request_buf);\n\tsize_t small_sz = MAX_CIFS_SMALL_BUFFER_SIZE;\n\tsize_t large_sz = small_sz + work->conn->vals->max_trans_size;\n\tsize_t sz = small_sz;\n\tint cmd = le16_to_cpu(hdr->Command);\n\tif (cmd == SMB2_IOCTL_HE || cmd == SMB2_QUERY_DIRECTORY_HE)\n\t\tsz = large_sz;\n\tif (cmd == SMB2_QUERY_INFO_HE) {\n\t\tstruct smb2_query_info_req *req;\n\t\treq = smb2_get_msg(work->request_buf);\n\t\tif (req->InfoType == SMB2_O_INFO_FILE &&\n\t\t    (req->FileInfoClass == FILE_FULL_EA_INFORMATION ||\n\t\t     req->FileInfoClass == FILE_ALL_INFORMATION))\n\t\t\tsz = large_sz;\n\t}\n\tif (le32_to_cpu(hdr->NextCommand) > 0)\n\t\tsz = large_sz;\n\twork->response_buf = kvmalloc(sz, GFP_KERNEL | __GFP_ZERO);\n\tif (!work->response_buf)\n\t\treturn -ENOMEM;\n\twork->response_sz = sz;\n\treturn 0;\n}", "target": 1}
{"code": "int f2fs_trim_fs(struct f2fs_sb_info *sbi, struct fstrim_range *range)\n{\n\t__u64 start = F2FS_BYTES_TO_BLK(range->start);\n\t__u64 end = start + F2FS_BYTES_TO_BLK(range->len) - 1;\n\tunsigned int start_segno, end_segno;\n\tstruct cp_control cpc;\n\tint err = 0;\n\tif (start >= MAX_BLKADDR(sbi) || range->len < sbi->blocksize)\n\t\treturn -EINVAL;\n\tcpc.trimmed = 0;\n\tif (end <= MAIN_BLKADDR(sbi))\n\t\tgoto out;\n\tif (is_sbi_flag_set(sbi, SBI_NEED_FSCK)) {\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t\"Found FS corruption, run fsck to fix.\");\n\t\tgoto out;\n\t}\n\tstart_segno = (start <= MAIN_BLKADDR(sbi)) ? 0 : GET_SEGNO(sbi, start);\n\tend_segno = (end >= MAX_BLKADDR(sbi)) ? MAIN_SEGS(sbi) - 1 :\n\t\t\t\t\t\tGET_SEGNO(sbi, end);\n\tcpc.reason = CP_DISCARD;\n\tcpc.trim_minlen = max_t(__u64, 1, F2FS_BYTES_TO_BLK(range->minlen));\n\tfor (; start_segno <= end_segno; start_segno = cpc.trim_end + 1) {\n\t\tcpc.trim_start = start_segno;\n\t\tif (sbi->discard_blks == 0)\n\t\t\tbreak;\n\t\telse if (sbi->discard_blks < BATCHED_TRIM_BLOCKS(sbi))\n\t\t\tcpc.trim_end = end_segno;\n\t\telse\n\t\t\tcpc.trim_end = min_t(unsigned int,\n\t\t\t\trounddown(start_segno +\n\t\t\t\tBATCHED_TRIM_SEGMENTS(sbi),\n\t\t\t\tsbi->segs_per_sec) - 1, end_segno);\n\t\tmutex_lock(&sbi->gc_mutex);\n\t\terr = write_checkpoint(sbi, &cpc);\n\t\tmutex_unlock(&sbi->gc_mutex);\n\t\tif (err)\n\t\t\tbreak;\n\t\tschedule();\n\t}\n\tmark_discard_range_all(sbi);\n\tf2fs_wait_discard_bios(sbi);\nout:\n\trange->len = F2FS_BLK_TO_BYTES(cpc.trimmed);\n\treturn err;\n}", "target": 1}
{"code": "static struct sctp_auth_bytes *sctp_auth_make_key_vector(\n\t\t\tsctp_random_param_t *random,\n\t\t\tsctp_chunks_param_t *chunks,\n\t\t\tsctp_hmac_algo_param_t *hmacs,\n\t\t\tgfp_t gfp)\n{\n\tstruct sctp_auth_bytes *new;\n\t__u32\tlen;\n\t__u32\toffset = 0;\n\tlen = ntohs(random->param_hdr.length) + ntohs(hmacs->param_hdr.length);\n        if (chunks)\n\t\tlen += ntohs(chunks->param_hdr.length);\n\tnew = kmalloc(sizeof(struct sctp_auth_bytes) + len, gfp);\n\tif (!new)\n\t\treturn NULL;\n\tnew->len = len;\n\tmemcpy(new->data, random, ntohs(random->param_hdr.length));\n\toffset += ntohs(random->param_hdr.length);\n\tif (chunks) {\n\t\tmemcpy(new->data + offset, chunks,\n\t\t\tntohs(chunks->param_hdr.length));\n\t\toffset += ntohs(chunks->param_hdr.length);\n\t}\n\tmemcpy(new->data + offset, hmacs, ntohs(hmacs->param_hdr.length));\n\treturn new;\n}", "target": 0}
{"code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  OpContext op_context(context, node);\n    switch (op_context.output->type) {\n      case kTfLiteFloat32:\n        TFLiteOperation<kernel_type, float, OpType>(context, node, op_context);\n        break;\n      case kTfLiteUInt8:\n        TFLiteOperation<kernel_type, uint8_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      case kTfLiteInt8:\n        TFLiteOperation<kernel_type, int8_t, OpType>(context, node, op_context);\n        break;\n      case kTfLiteInt32:\n        TFLiteOperation<kernel_type, int32_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      case kTfLiteInt64:\n        TFLiteOperation<kernel_type, int64_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      case kTfLiteInt16:\n        TFLiteOperation<kernel_type, int16_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      default:\n        context->ReportError(context,\n                             \"Type %d is currently not supported by Maximum.\",\n                             op_context.output->type);\n        return kTfLiteError;\n    }\n  return kTfLiteOk;\n}", "target": 1}
{"code": "void ConnectionImpl::onHeaderValue(const char* data, size_t length) {\n  if (header_parsing_state_ == HeaderParsingState::Done) {\n    return;\n  }\n  const absl::string_view header_value = absl::string_view(data, length);\n  if (strict_header_validation_) {\n    if (!Http::HeaderUtility::headerIsValid(header_value)) {\n      ENVOY_CONN_LOG(debug, \"invalid header value: {}\", connection_, header_value);\n      error_code_ = Http::Code::BadRequest;\n      sendProtocolError();\n      throw CodecProtocolException(\"http/1.1 protocol error: header value contains invalid chars\");\n    }\n  } else if (header_value.find('\\0') != absl::string_view::npos) {\n    throw CodecProtocolException(\"http/1.1 protocol error: header value contains NUL\");\n  }\n  header_parsing_state_ = HeaderParsingState::Value;\n  current_header_value_.append(data, length);\n  const uint32_t total =\n      current_header_field_.size() + current_header_value_.size() + current_header_map_->byteSize();\n  if (total > (max_request_headers_kb_ * 1024)) {\n    error_code_ = Http::Code::RequestHeaderFieldsTooLarge;\n    sendProtocolError();\n    throw CodecProtocolException(\"headers size exceeds limit\");\n  }\n}", "target": 1}
{"code": "static int ref_pic_list_struct(GetBitContext *gb, RefPicListStruct *rpl)\n{\n    uint32_t delta_poc_st, strp_entry_sign_flag = 0;\n    rpl->ref_pic_num = get_ue_golomb_long(gb);\n    if (rpl->ref_pic_num > 0) {\n        delta_poc_st = get_ue_golomb_long(gb);\n        rpl->ref_pics[0] = delta_poc_st;\n        if (rpl->ref_pics[0] != 0) {\n            strp_entry_sign_flag = get_bits(gb, 1);\n            rpl->ref_pics[0] *= 1 - (strp_entry_sign_flag << 1);\n        }\n    }\n    for (int i = 1; i < rpl->ref_pic_num; ++i) {\n        delta_poc_st = get_ue_golomb_long(gb);\n        if (delta_poc_st != 0)\n            strp_entry_sign_flag = get_bits(gb, 1);\n        rpl->ref_pics[i] = rpl->ref_pics[i - 1] + delta_poc_st * (1 - (strp_entry_sign_flag << 1));\n    }\n    return 0;\n}", "target": 1}
{"code": "static struct ib_ucontext *hns_roce_alloc_ucontext(struct ib_device *ib_dev,\n\t\t\t\t\t\t   struct ib_udata *udata)\n{\n\tint ret = 0;\n\tstruct hns_roce_ucontext *context;\n\tstruct hns_roce_ib_alloc_ucontext_resp resp;\n\tstruct hns_roce_dev *hr_dev = to_hr_dev(ib_dev);\n\tresp.qp_tab_size = hr_dev->caps.num_qps;\n\tcontext = kmalloc(sizeof(*context), GFP_KERNEL);\n\tif (!context)\n\t\treturn ERR_PTR(-ENOMEM);\n\tret = hns_roce_uar_alloc(hr_dev, &context->uar);\n\tif (ret)\n\t\tgoto error_fail_uar_alloc;\n\tif (hr_dev->caps.flags & HNS_ROCE_CAP_FLAG_RECORD_DB) {\n\t\tINIT_LIST_HEAD(&context->page_list);\n\t\tmutex_init(&context->page_mutex);\n\t}\n\tret = ib_copy_to_udata(udata, &resp, sizeof(resp));\n\tif (ret)\n\t\tgoto error_fail_copy_to_udata;\n\treturn &context->ibucontext;\nerror_fail_copy_to_udata:\n\thns_roce_uar_free(hr_dev, &context->uar);\nerror_fail_uar_alloc:\n\tkfree(context);\n\treturn ERR_PTR(ret);\n}", "target": 1}
{"code": "static int getStrrtokenPos(char* str, int savedPos)\n{\n\tint result =-1;\n\tint i;\n\tfor(i=savedPos-1; i>=0; i--) {\n\t\tif(isIDSeparator(*(str+i)) ){\n\t\t\tif(i>=2 && isIDSeparator(*(str+i-2)) ){\n\t\t\t\tresult = i-2;\n\t\t\t} else {\n\t\t\t\tresult = i;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(result < 1){\n\t\tresult =-1;\n\t}\n\treturn result;\n}", "target": 1}
{"code": "static int rtnl_fill_link_ifmap(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct rtnl_link_ifmap map = {\n\t\t.mem_start   = dev->mem_start,\n\t\t.mem_end     = dev->mem_end,\n\t\t.base_addr   = dev->base_addr,\n\t\t.irq         = dev->irq,\n\t\t.dma         = dev->dma,\n\t\t.port        = dev->if_port,\n\t};\n\tif (nla_put(skb, IFLA_MAP, sizeof(map), &map))\n\t\treturn -EMSGSIZE;\n\treturn 0;\n}", "target": 1}
{"code": "static void context__cleanup_out_packets(struct mosquitto *context)\n{\n\tstruct mosquitto__packet *packet;\n\tif(!context) return;\n\tif(context->current_out_packet){\n\t\tpacket__cleanup(context->current_out_packet);\n\t\tmosquitto__free(context->current_out_packet);\n\t\tcontext->current_out_packet = NULL;\n\t}\n\twhile(context->out_packet){\n\t\tpacket__cleanup(context->out_packet);\n\t\tpacket = context->out_packet;\n\t\tcontext->out_packet = context->out_packet->next;\n\t\tmosquitto__free(packet);\n\t}\n\tcontext->out_packet_count = 0;\n}", "target": 0}
{"code": "int blkcg_init_queue(struct request_queue *q)\n{\n\tstruct blkcg_gq *new_blkg, *blkg;\n\tbool preloaded;\n\tint ret;\n\tnew_blkg = blkg_alloc(&blkcg_root, q, GFP_KERNEL);\n\tif (!new_blkg)\n\t\treturn -ENOMEM;\n\tpreloaded = !radix_tree_preload(GFP_KERNEL);\n\trcu_read_lock();\n\tspin_lock_irq(q->queue_lock);\n\tblkg = blkg_create(&blkcg_root, q, new_blkg);\n\tspin_unlock_irq(q->queue_lock);\n\trcu_read_unlock();\n\tif (preloaded)\n\t\tradix_tree_preload_end();\n\tif (IS_ERR(blkg)) {\n\t\tblkg_free(new_blkg);\n\t\treturn PTR_ERR(blkg);\n\t}\n\tq->root_blkg = blkg;\n\tq->root_rl.blkg = blkg;\n\tret = blk_throtl_init(q);\n\tif (ret) {\n\t\tspin_lock_irq(q->queue_lock);\n\t\tblkg_destroy_all(q);\n\t\tspin_unlock_irq(q->queue_lock);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "mrb_class_real(struct RClass* cl)\n{\n  if (cl == 0)\n    return NULL;\n  while ((cl->tt == MRB_TT_SCLASS) || (cl->tt == MRB_TT_ICLASS)) {\n    cl = cl->super;\n  }\n  return cl;\n}", "target": 1}
{"code": "size_t jsuGetFreeStack() {\n#ifdef ARM\n  void *frame = __builtin_frame_address(0);\n  size_t stackPos = (size_t)((char*)frame);\n  size_t stackEnd = (size_t)((char*)&LINKER_END_VAR);\n  if (stackPos < stackEnd) return 0; \n  return  stackPos - stackEnd;\n#elif defined(LINUX)\n  char ptr; \n  extern void *STACK_BASE;\n  uint32_t count =  (uint32_t)((size_t)STACK_BASE - (size_t)&ptr);\n  return 1000000 - count; \n#else\n  return 1000000; \n#endif\n}", "target": 1}
{"code": "R_API int r_io_bank_read_from_submap_at(RIO *io, const ut32 bankid, ut64 addr, ut8 *buf, int len) {\n\tr_return_val_if_fail (io, -1);\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tif (!bank) {\n\t\treturn 0;\n\t}\n\tif (!len) {\n\t\treturn 0;\n\t}\n\tRRBNode *node;\n\tif (bank->last_used && r_io_submap_contain (((RIOSubMap *)bank->last_used->data), addr)) {\n\t\tnode = bank->last_used;\n\t} else {\n\t\tnode = r_crbtree_find_node (bank->submaps, &addr, _find_sm_by_vaddr_cb, NULL);\n\t\tif (!node) {\n\t\t\treturn 0;\n\t\t}\n\t\tbank->last_used = node;\n\t}\n\tRIOSubMap *sm = (RIOSubMap *)node->data;\n\tif (!r_io_submap_contain (sm, addr)) {\n\t\treturn 0;\n\t}\n\tRIOMap *map = r_io_map_get_by_ref (io, &sm->mapref);\n\tif (!map || !(map->perm & R_PERM_R)) {\n\t\treturn -1;\n\t}\n\tconst int read_len = R_MIN (len, r_io_submap_to (sm) - addr + 1);\n\tif (map->perm & R_PERM_RELOC) {\n\t\treturn map->reloc_map->read (io, map, addr, buf, read_len);\n\t}\n\tconst ut64 paddr = addr - r_io_map_from (map) + map->delta;\n\treturn r_io_fd_read_at (io, map->fd, paddr, buf, read_len);\n}", "target": 1}
{"code": "int submit_bio_wait(struct bio *bio)\n{\n\tstruct submit_bio_ret ret;\n\tinit_completion(&ret.event);\n\tbio->bi_private = &ret;\n\tbio->bi_end_io = submit_bio_wait_endio;\n\tbio->bi_opf |= REQ_SYNC;\n\tsubmit_bio(bio);\n\twait_for_completion_io(&ret.event);\n\treturn ret.error;\n}", "target": 0}
{"code": "check_entry_size_and_hooks(struct ipt_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct ipt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ipt_entry) >= limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct ipt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_err(\"Underflows must be unconditional and \"\n\t\t\t\t       \"use the STANDARD target with \"\n\t\t\t\t       \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 1}
{"code": "    LoaderExifDataJpeg::LoaderExifDataJpeg(PreviewId id, const Image &image, int parIdx)\n        : Loader(id, image),\n          dataKey_(param_[parIdx].dataKey_)\n    {\n        ExifData::const_iterator pos = image_.exifData().findKey(dataKey_);\n        if (pos != image_.exifData().end()) {\n            size_ = pos->sizeDataArea(); \n            if (size_ == 0 && pos->typeId() == undefined)\n                size_ = pos->size(); \n        }\n        if (size_ == 0) return;\n        valid_ = true;\n    }", "target": 0}
{"code": "int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],\n\t\t     unsigned char multicast_spec, u8 protocol_version)\n{\n\tstruct hsr_priv *hsr;\n\tstruct hsr_port *port;\n\tint res;\n\thsr = netdev_priv(hsr_dev);\n\tINIT_LIST_HEAD(&hsr->ports);\n\tINIT_LIST_HEAD(&hsr->node_db);\n\tINIT_LIST_HEAD(&hsr->self_node_db);\n\tether_addr_copy(hsr_dev->dev_addr, slave[0]->dev_addr);\n\tres = hsr_create_self_node(&hsr->self_node_db, hsr_dev->dev_addr,\n\t\t\t\t   slave[1]->dev_addr);\n\tif (res < 0)\n\t\treturn res;\n\tspin_lock_init(&hsr->seqnr_lock);\n\thsr->sequence_nr = HSR_SEQNR_START;\n\thsr->sup_sequence_nr = HSR_SUP_SEQNR_START;\n\ttimer_setup(&hsr->announce_timer, hsr_announce, 0);\n\ttimer_setup(&hsr->prune_timer, hsr_prune_nodes, 0);\n\tether_addr_copy(hsr->sup_multicast_addr, def_multicast_addr);\n\thsr->sup_multicast_addr[ETH_ALEN - 1] = multicast_spec;\n\thsr->protVersion = protocol_version;\n\tnetif_carrier_off(hsr_dev);\n\tres = hsr_add_port(hsr, hsr_dev, HSR_PT_MASTER);\n\tif (res)\n\t\treturn res;\n\tres = register_netdevice(hsr_dev);\n\tif (res)\n\t\tgoto fail;\n\tres = hsr_add_port(hsr, slave[0], HSR_PT_SLAVE_A);\n\tif (res)\n\t\tgoto fail;\n\tres = hsr_add_port(hsr, slave[1], HSR_PT_SLAVE_B);\n\tif (res)\n\t\tgoto fail;\n\tmod_timer(&hsr->prune_timer, jiffies + msecs_to_jiffies(PRUNE_PERIOD));\n\treturn 0;\nfail:\n\thsr_for_each_port(hsr, port)\n\t\thsr_del_port(port);\n\treturn res;\n}", "target": 1}
{"code": "static void test_simple()\n{\n    json_set_alloc_funcs(my_malloc, my_free);\n    create_and_free_complex_object();\n    if(malloc_called != 20 || free_called != 20)\n        fail(\"Custom allocation failed\");\n}", "target": 1}
{"code": "SslSocket::SslSocket(Envoy::Ssl::ContextSharedPtr ctx, InitialState state,\n                     const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options,\n                     Ssl::HandshakerFactoryCb handshaker_factory_cb)\n    : transport_socket_options_(transport_socket_options),\n      ctx_(std::dynamic_pointer_cast<ContextImpl>(ctx)),\n      info_(std::dynamic_pointer_cast<SslHandshakerImpl>(handshaker_factory_cb(\n          ctx_->newSsl(transport_socket_options_), ctx_->sslExtendedSocketInfoIndex(), this))) {\n  if (state == InitialState::Client) {\n    SSL_set_connect_state(rawSsl());\n  } else {\n    ASSERT(state == InitialState::Server);\n    SSL_set_accept_state(rawSsl());\n  }\n}", "target": 1}
{"code": "init_level(struct cert_stack *stack, unsigned int *_result)\n{\n\tstruct metadata_node *head_meta;\n\tunsigned int work_repo_level;\n\tunsigned int result;\n\tresult = 0;\n\twork_repo_level = working_repo_peek_level();\n\thead_meta = SLIST_FIRST(&stack->metas);\n\tif (head_meta != NULL && work_repo_level > head_meta->level)\n\t\tresult = work_repo_level;\n\t*_result = result;\n\treturn 0;\n}", "target": 0}
{"code": "static void reds_remove_char_device(RedsState *reds, RedCharDevice *dev)\n{\n    g_return_if_fail(reds != NULL);\n    auto &devs(reds->char_devices);\n    g_warn_if_fail(std::find(devs.begin(), devs.end(),\n                             red::shared_ptr<RedCharDevice>(dev)) != devs.end());\n    devs.remove(red::shared_ptr<RedCharDevice>(dev));\n}", "target": 0}
{"code": "static int get_rx_bufs(struct vhost_virtqueue *vq,\n\t\t       struct vring_used_elem *heads,\n\t\t       int datalen,\n\t\t       unsigned *iovcount,\n\t\t       struct vhost_log *log,\n\t\t       unsigned *log_num,\n\t\t       unsigned int quota)\n{\n\tunsigned int out, in;\n\tint seg = 0;\n\tint headcount = 0;\n\tunsigned d;\n\tint r, nlogs = 0;\n\twhile (datalen > 0 && headcount < quota) {\n\t\tif (unlikely(seg >= UIO_MAXIOV)) {\n\t\t\tr = -ENOBUFS;\n\t\t\tgoto err;\n\t\t}\n\t\td = vhost_get_vq_desc(vq->dev, vq, vq->iov + seg,\n\t\t\t\t      ARRAY_SIZE(vq->iov) - seg, &out,\n\t\t\t\t      &in, log, log_num);\n\t\tif (d == vq->num) {\n\t\t\tr = 0;\n\t\t\tgoto err;\n\t\t}\n\t\tif (unlikely(out || in <= 0)) {\n\t\t\tvq_err(vq, \"unexpected descriptor format for RX: \"\n\t\t\t\t\"out %d, in %d\\n\", out, in);\n\t\t\tr = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t\tif (unlikely(log)) {\n\t\t\tnlogs += *log_num;\n\t\t\tlog += *log_num;\n\t\t}\n\t\theads[headcount].id = d;\n\t\theads[headcount].len = iov_length(vq->iov + seg, in);\n\t\tdatalen -= heads[headcount].len;\n\t\t++headcount;\n\t\tseg += in;\n\t}\n\theads[headcount - 1].len += datalen;\n\t*iovcount = seg;\n\tif (unlikely(log))\n\t\t*log_num = nlogs;\n\tif (unlikely(datalen > 0)) {\n\t\tr = UIO_MAXIOV + 1;\n\t\tgoto err;\n\t}\n\treturn headcount;\nerr:\n\tvhost_discard_vq_desc(vq, headcount);\n\treturn r;\n}", "target": 0}
{"code": "nvkm_vmm_put_locked(struct nvkm_vmm *vmm, struct nvkm_vma *vma)\n{\n\tconst struct nvkm_vmm_page *page = vmm->func->page;\n\tstruct nvkm_vma *next = vma;\n\tBUG_ON(vma->part);\n\tif (vma->mapref || !vma->sparse) {\n\t\tdo {\n\t\t\tconst bool map = next->memory != NULL;\n\t\t\tconst u8  refd = next->refd;\n\t\t\tconst u64 addr = next->addr;\n\t\t\tu64 size = next->size;\n\t\t\twhile ((next = node(next, next)) && next->part &&\n\t\t\t       (next->memory != NULL) == map &&\n\t\t\t       (next->refd == refd))\n\t\t\t\tsize += next->size;\n\t\t\tif (map) {\n\t\t\t\tnvkm_vmm_ptes_unmap_put(vmm, &page[refd], addr,\n\t\t\t\t\t\t\tsize, vma->sparse);\n\t\t\t} else\n\t\t\tif (refd != NVKM_VMA_PAGE_NONE) {\n\t\t\t\tnvkm_vmm_ptes_put(vmm, &page[refd], addr, size);\n\t\t\t}\n\t\t} while (next && next->part);\n\t}\n\tnext = vma;\n\tdo {\n\t\tif (next->memory)\n\t\t\tnvkm_vmm_unmap_region(vmm, next);\n\t} while ((next = node(vma, next)) && next->part);\n\tif (vma->sparse && !vma->mapref) {\n\t\tnvkm_vmm_ptes_sparse_put(vmm, &page[vma->refd], vma->addr, vma->size);\n\t} else\n\tif (vma->sparse) {\n\t\tnvkm_vmm_ptes_sparse(vmm, vma->addr, vma->size, false);\n\t}\n\trb_erase(&vma->tree, &vmm->root);\n\tvma->page = NVKM_VMA_PAGE_NONE;\n\tvma->refd = NVKM_VMA_PAGE_NONE;\n\tvma->used = false;\n\tvma->user = false;\n\tnvkm_vmm_put_region(vmm, vma);\n}", "target": 1}
{"code": "TfLiteStatus EvalGatherNd(TfLiteContext* context, const TfLiteTensor* params,\n                          const TfLiteTensor* indices, TfLiteTensor* output) {\n  bool indices_has_only_positive_elements = true;\n  const auto* indices_values = GetTensorData<IndicesT>(indices);\n  const size_t num_indices = indices->bytes / sizeof(IndicesT);\n  for (size_t i = 0; i < num_indices; i++) {\n    if (indices_values[i] < 0) {\n      indices_has_only_positive_elements = false;\n      break;\n    }\n  }\n  TF_LITE_ENSURE(context, indices_has_only_positive_elements);\n  switch (params->type) {\n    case kTfLiteFloat32:\n      return GatherNd<float, IndicesT>(params, indices, output);\n    case kTfLiteUInt8:\n      return GatherNd<uint8_t, IndicesT>(params, indices, output);\n    case kTfLiteInt8:\n      return GatherNd<int8_t, IndicesT>(params, indices, output);\n    case kTfLiteInt16:\n      return GatherNd<int16_t, IndicesT>(params, indices, output);\n    case kTfLiteInt32:\n      return GatherNd<int32_t, IndicesT>(params, indices, output);\n    case kTfLiteInt64:\n      return GatherNd<int64_t, IndicesT>(params, indices, output);\n    case kTfLiteString:\n      return GatherNdString<IndicesT>(params, indices, output);\n    default:\n      TF_LITE_KERNEL_LOG(context,\n                         \"Params type '%s' are not supported by gather_nd.\",\n                         TfLiteTypeGetName(params->type));\n      return kTfLiteError;\n  }\n}", "target": 1}
{"code": "NOEXPORT void print_cipher(CLI *c) { \n    SSL_CIPHER *cipher;\n#ifndef OPENSSL_NO_COMP\n    const COMP_METHOD *compression, *expansion;\n#endif\n    if(c->opt->log_level<LOG_INFO) \n        return;\n    s_log(LOG_INFO, \"TLS %s: %s\",\n        c->opt->option.client ? \"connected\" : \"accepted\",\n        SSL_session_reused(c->ssl) && !c->flag.psk ?\n            \"previous session reused\" : \"new session negotiated\");\n    cipher=(SSL_CIPHER *)SSL_get_current_cipher(c->ssl);\n    s_log(LOG_INFO, \"%s ciphersuite: %s (%d-bit encryption)\",\n        SSL_get_version(c->ssl), SSL_CIPHER_get_name(cipher),\n        SSL_CIPHER_get_bits(cipher, NULL));\n#if OPENSSL_VERSION_NUMBER >= 0x10101000L\n    print_tmp_key(c->ssl);\n#endif\n#ifndef OPENSSL_NO_COMP\n    compression=SSL_get_current_compression(c->ssl);\n    expansion=SSL_get_current_expansion(c->ssl);\n    s_log(compression||expansion ? LOG_INFO : LOG_DEBUG,\n        \"Compression: %s, expansion: %s\",\n        compression ? SSL_COMP_get_name(compression) : \"null\",\n        expansion ? SSL_COMP_get_name(expansion) : \"null\");\n#endif\n}", "target": 0}
{"code": "static u8 BS_ReadByte(GF_BitStream *bs)\n{\n\tBool is_eos;\n\tif (bs->bsmode == GF_BITSTREAM_READ) {\n\t\tu8 res;\n\t\tif (bs->position >= bs->size) {\n\t\t\tif (bs->EndOfStream) bs->EndOfStream(bs->par);\n\t\t\tif (!bs->overflow_state) bs->overflow_state = 1;\n\t\t\treturn 0;\n\t\t}\n\t\tres = bs->original[bs->position++];\n\t\tif (bs->remove_emul_prevention_byte) {\n\t\t\tif ((bs->nb_zeros==2) && (res==0x03) && (bs->position<bs->size) && (bs->original[bs->position]<0x04)) {\n\t\t\t\tbs->nb_zeros = 0;\n\t\t\t\tres = bs->original[bs->position++];\n\t\t\t}\n\t\t\tif (!res) bs->nb_zeros++;\n\t\t\telse bs->nb_zeros = 0;\n\t\t}\n\t\treturn res;\n\t}\n\tif (bs->cache_write)\n\t\tbs_flush_write_cache(bs);\n\tis_eos = gf_feof(bs->stream);\n\tif (!is_eos || bs->cache_read) {\n\t\tu8 res;\n\t\tBool loc_eos=GF_FALSE;\n\t\tassert(bs->position<=bs->size);\n\t\tbs->position++;\n\t\tres = gf_bs_load_byte(bs, &loc_eos);\n\t\tif (loc_eos) goto bs_eof;\n\t\tif (bs->remove_emul_prevention_byte) {\n\t\t\tif ((bs->nb_zeros==2) && (res==0x03) && (bs->position<bs->size)) {\n\t\t\t\tu8 next = gf_bs_load_byte(bs, &loc_eos);\n\t\t\t\tif (next < 0x04) {\n\t\t\t\t\tbs->nb_zeros = 0;\n\t\t\t\t\tres = next;\n\t\t\t\t\tbs->position++;\n\t\t\t\t} else {\n\t\t\t\t\tgf_bs_seek(bs, bs->position);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!res) bs->nb_zeros++;\n\t\t\telse bs->nb_zeros = 0;\n\t\t}\n\t\treturn res;\n\t}\nbs_eof:\n\tif (bs->EndOfStream) {\n\t\tbs->EndOfStream(bs->par);\n\t\tif (!bs->overflow_state) bs->overflow_state = 1;\n\t} else {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[BS] Attempt to overread bitstream\\n\"));\n\t}\n\tassert(bs->position <= 1+bs->size);\n\treturn 0;\n}", "target": 1}
{"code": "static MYSQL *db_connect(char *host, char *database,\n                         char *user, char *passwd)\n{\n  MYSQL *mysql;\n  if (verbose)\n    fprintf(stdout, \"Connecting to %s\\n\", host ? host : \"localhost\");\n  if (!(mysql= mysql_init(NULL)))\n    return 0;\n  if (opt_compress)\n    mysql_options(mysql,MYSQL_OPT_COMPRESS,NullS);\n  if (opt_local_file)\n    mysql_options(mysql,MYSQL_OPT_LOCAL_INFILE,\n\t\t  (char*) &opt_local_file);\n#ifdef HAVE_OPENSSL\n  if (opt_use_ssl)\n  {\n    mysql_ssl_set(mysql, opt_ssl_key, opt_ssl_cert, opt_ssl_ca,\n\t\t  opt_ssl_capath, opt_ssl_cipher);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRL, opt_ssl_crl);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRLPATH, opt_ssl_crlpath);\n  }\n  mysql_options(mysql,MYSQL_OPT_SSL_VERIFY_SERVER_CERT,\n                (char*)&opt_ssl_verify_server_cert);\n#endif\n  if (opt_protocol)\n    mysql_options(mysql,MYSQL_OPT_PROTOCOL,(char*)&opt_protocol);\n  if (opt_bind_addr)\n    mysql_options(mysql,MYSQL_OPT_BIND,opt_bind_addr);\n#if defined (_WIN32) && !defined (EMBEDDED_LIBRARY)\n  if (shared_memory_base_name)\n    mysql_options(mysql,MYSQL_SHARED_MEMORY_BASE_NAME,shared_memory_base_name);\n#endif\n  if (opt_plugin_dir && *opt_plugin_dir)\n    mysql_options(mysql, MYSQL_PLUGIN_DIR, opt_plugin_dir);\n  if (opt_default_auth && *opt_default_auth)\n    mysql_options(mysql, MYSQL_DEFAULT_AUTH, opt_default_auth);\n  mysql_options(mysql, MYSQL_SET_CHARSET_NAME, default_charset);\n  mysql_options(mysql, MYSQL_OPT_CONNECT_ATTR_RESET, 0);\n  mysql_options4(mysql, MYSQL_OPT_CONNECT_ATTR_ADD,\n                 \"program_name\", \"mysqlimport\");\n  if (!(mysql_real_connect(mysql,host,user,passwd,\n                           database,opt_mysql_port,opt_mysql_unix_port,\n                           0)))\n  {\n    ignore_errors=0;\t  \n    db_error(mysql);\n  }\n  mysql->reconnect= 0;\n  if (verbose)\n    fprintf(stdout, \"Selecting database %s\\n\", database);\n  if (mysql_select_db(mysql, database))\n  {\n    ignore_errors=0;\n    db_error(mysql);\n  }\n  return mysql;\n}", "target": 1}
{"code": "Status TransposeShapeFn(InferenceContext* c) {\n  ShapeHandle input = c->input(0);\n  ShapeHandle perm_shape = c->input(1);\n  const Tensor* perm = c->input_tensor(1);\n  DimensionHandle perm_elems = c->NumElements(perm_shape);\n  if (!c->RankKnown(input) && !c->ValueKnown(perm_elems) && perm == nullptr) {\n    c->set_output(0, c->UnknownShape());\n    return Status::OK();\n  }\n  int64_t rank;\n  if (c->RankKnown(input)) {\n    rank = c->Rank(input);\n  } else if (c->ValueKnown(perm_elems)) {\n    rank = c->Value(perm_elems);\n  } else {\n    rank = perm->NumElements();\n  }\n  if (!c->RankKnown(input) && rank < 2) {\n    c->set_output(0, input);\n    return Status::OK();\n  }\n  std::vector<DimensionHandle> dims;\n  dims.resize(rank);\n  TF_RETURN_IF_ERROR(c->WithRank(input, rank, &input));\n  TF_RETURN_IF_ERROR(c->WithRank(perm_shape, 1, &perm_shape));\n  TF_RETURN_IF_ERROR(c->WithValue(perm_elems, rank, &perm_elems));\n  if (perm != nullptr) {\n    std::vector<int64_t> data;\n    if (perm->dtype() == DT_INT32) {\n      data = AsInt64<int32>(perm, rank);\n    } else {\n      data = AsInt64<int64_t>(perm, rank);\n    }\n    for (int32_t i = 0; i < rank; ++i) {\n      int64_t in_idx = data[i];\n      if (in_idx >= rank) {\n        return errors::InvalidArgument(\"perm dim \", in_idx,\n                                       \" is out of range of input rank \", rank);\n      }\n      dims[i] = c->Dim(input, in_idx);\n    }\n  } else {\n    for (int i = 0; i < rank; ++i) {\n      dims[i] = c->UnknownDim();\n    }\n  }\n  c->set_output(0, c->MakeShape(dims));\n  return Status::OK();\n}", "target": 1}
{"code": "struct vfsmount *clone_private_mount(const struct path *path)\n{\n\tstruct mount *old_mnt = real_mount(path->mnt);\n\tstruct mount *new_mnt;\n\tif (IS_MNT_UNBINDABLE(old_mnt))\n\t\treturn ERR_PTR(-EINVAL);\n\tnew_mnt = clone_mnt(old_mnt, path->dentry, CL_PRIVATE);\n\tif (IS_ERR(new_mnt))\n\t\treturn ERR_CAST(new_mnt);\n\tnew_mnt->mnt_ns = MNT_NS_INTERNAL;\n\treturn &new_mnt->mnt;\n}", "target": 1}
{"code": "void CSecurityTLS::initGlobal()\n{\n  static bool globalInitDone = false;\n  if (!globalInitDone) {\n    gnutls_global_init();\n    globalInitDone = true;\n  }\n}", "target": 1}
{"code": "hb_buffer_get_reference_count (hb_buffer_t *buffer)\n{\n  HB_OBJECT_DO_GET_REFERENCE_COUNT (buffer);\n}", "target": 0}
{"code": "static char *rfc2047_decode_word(const char *s, size_t len, enum ContentEncoding enc)\n{\n  const char *it = s;\n  const char *end = s + len;\n  if (enc == ENCQUOTEDPRINTABLE)\n  {\n    struct Buffer buf = { 0 };\n    for (; it < end; ++it)\n    {\n      if (*it == '_')\n      {\n        mutt_buffer_addch(&buf, ' ');\n      }\n      else if ((*it == '=') && (!(it[1] & ~127) && hexval(it[1]) != -1) &&\n               (!(it[2] & ~127) && hexval(it[2]) != -1))\n      {\n        mutt_buffer_addch(&buf, (hexval(it[1]) << 4) | hexval(it[2]));\n        it += 2;\n      }\n      else\n      {\n        mutt_buffer_addch(&buf, *it);\n      }\n    }\n    mutt_buffer_addch(&buf, '\\0');\n    return buf.data;\n  }\n  else if (enc == ENCBASE64)\n  {\n    char *out = mutt_mem_malloc(3 * len / 4 + 1);\n    int dlen = mutt_b64_decode(out, it);\n    if (dlen == -1)\n    {\n      FREE(&out);\n      return NULL;\n    }\n    out[dlen] = '\\0';\n    return out;\n  }\n  assert(0); \n  return NULL;\n}", "target": 1}
{"code": "void TensorSliceReader::LoadShard(int shard) const {\n  CHECK_LT(shard, sss_.size());\n  if (sss_[shard] || !status_.ok()) {\n    return;  \n  }\n  string value;\n  SavedTensorSlices sts;\n  const string fname = fnames_[shard];\n  VLOG(1) << \"Reading meta data from file \" << fname << \"...\";\n  Table* table;\n  Status s = open_function_(fname, &table);\n  if (!s.ok()) {\n    status_ = errors::DataLoss(\"Unable to open table file \", fname, \": \",\n                               s.ToString());\n    return;\n  }\n  sss_[shard].reset(table);\n  if (!(table->Get(kSavedTensorSlicesKey, &value) &&\n        ParseProtoUnlimited(&sts, value))) {\n    status_ = errors::Internal(\n        \"Failed to find the saved tensor slices at the beginning of the \"\n        \"checkpoint file: \",\n        fname);\n    return;\n  }\n  status_ = CheckVersions(sts.meta().versions(), TF_CHECKPOINT_VERSION,\n                          TF_CHECKPOINT_VERSION_MIN_PRODUCER, \"Checkpoint\",\n                          \"checkpoint\");\n  if (!status_.ok()) return;\n  for (const SavedSliceMeta& ssm : sts.meta().tensor()) {\n    TensorShape ssm_shape(ssm.shape());\n    for (const TensorSliceProto& tsp : ssm.slice()) {\n      TensorSlice ss_slice(tsp);\n      status_ = RegisterTensorSlice(ssm.name(), ssm_shape, ssm.type(), fname,\n                                    ss_slice, &tensors_);\n      if (!status_.ok()) return;\n    }\n  }\n}", "target": 1}
{"code": "static TEE_Result set_rmem_param(const struct optee_msg_param_rmem *rmem,\n\t\t\t\t struct param_mem *mem)\n{\n\tsize_t req_size = 0;\n\tuint64_t shm_ref = READ_ONCE(rmem->shm_ref);\n\tmem->mobj = mobj_reg_shm_get_by_cookie(shm_ref);\n\tif (!mem->mobj)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\tmem->offs = READ_ONCE(rmem->offs);\n\tmem->size = READ_ONCE(rmem->size);\n\tif (ADD_OVERFLOW(mem->offs, mem->size, &req_size) ||\n\t    mem->mobj->size < req_size)\n\t\treturn TEE_ERROR_SECURITY;\n\treturn TEE_SUCCESS;\n}", "target": 0}
{"code": "static void bprm_fill_uid(struct linux_binprm *bprm)\n{\n\tstruct inode *inode;\n\tunsigned int mode;\n\tkuid_t uid;\n\tkgid_t gid;\n\tbprm->cred->euid = current_euid();\n\tbprm->cred->egid = current_egid();\n\tif (bprm->file->f_path.mnt->mnt_flags & MNT_NOSUID)\n\t\treturn;\n\tif (task_no_new_privs(current))\n\t\treturn;\n\tinode = file_inode(bprm->file);\n\tmode = READ_ONCE(inode->i_mode);\n\tif (!(mode & (S_ISUID|S_ISGID)))\n\t\treturn;\n\tmutex_lock(&inode->i_mutex);\n\tmode = inode->i_mode;\n\tuid = inode->i_uid;\n\tgid = inode->i_gid;\n\tmutex_unlock(&inode->i_mutex);\n\tif (!kuid_has_mapping(bprm->cred->user_ns, uid) ||\n\t\t !kgid_has_mapping(bprm->cred->user_ns, gid))\n\t\treturn;\n\tif (mode & S_ISUID) {\n\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\tbprm->cred->euid = uid;\n\t}\n\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\tbprm->cred->egid = gid;\n\t}\n}", "target": 0}
{"code": "v8::Local<v8::Object> CreateNativeEvent(\n    v8::Isolate* isolate,\n    v8::Local<v8::Object> sender,\n    content::RenderFrameHost* frame,\n    electron::mojom::ElectronBrowser::MessageSyncCallback callback) {\n  v8::Local<v8::Object> event;\n  if (frame && callback) {\n    gin::Handle<Event> native_event = Event::Create(isolate);\n    native_event->SetCallback(std::move(callback));\n    event = v8::Local<v8::Object>::Cast(native_event.ToV8());\n  } else {\n    event = CreateEvent(isolate);\n  }\n  Dictionary dict(isolate, event);\n  dict.Set(\"sender\", sender);\n  if (frame)\n    dict.Set(\"frameId\", frame->GetRoutingID());\n  return event;\n}", "target": 1}
{"code": "static int check_submodule_url(const char *url)\n{\n\tconst char *curl_url;\n\tif (looks_like_command_line_option(url))\n\t\treturn -1;\n\tif (submodule_url_is_relative(url)) {\n\t\tchar *decoded = url_decode(url);\n\t\tint has_nl = !!strchr(decoded, '\\n');\n\t\tfree(decoded);\n\t\tif (has_nl)\n\t\t\treturn -1;\n\t}\n\telse if (url_to_curl_url(url, &curl_url)) {\n\t\tstruct credential c = CREDENTIAL_INIT;\n\t\tint ret = credential_from_url_gently(&c, curl_url, 1);\n\t\tcredential_clear(&c);\n\t\treturn ret;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "reverseSamplesBytes (uint16 spp, uint16 bps, uint32 width, \n                     uint8 *src, uint8 *dst)\n  {\n  int i;\n  uint32  col, bytes_per_pixel, col_offset;\n  uint8   bytebuff1;\n  unsigned char swapbuff[32];\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"reverseSamplesBytes\",\"Invalid input or output buffer\");\n    return (1);\n    }\n  bytes_per_pixel  = ((bps * spp) + 7) / 8;\n  if( bytes_per_pixel > sizeof(swapbuff) )\n  {\n    TIFFError(\"reverseSamplesBytes\",\"bytes_per_pixel too large\");\n    return (1);\n  }\n  switch (bps / 8)\n     {\n     case 8:  \n     case 4:\n     case 3:\n     case 2: for (col = 0; col < (width / 2); col++)\n               {\n\t       col_offset = col * bytes_per_pixel;                     \n\t       _TIFFmemcpy (swapbuff, src + col_offset, bytes_per_pixel);\n\t       _TIFFmemcpy (src + col_offset, dst - col_offset - bytes_per_pixel, bytes_per_pixel);\n\t       _TIFFmemcpy (dst - col_offset - bytes_per_pixel, swapbuff, bytes_per_pixel);\n               }\n\t     break;\n     case 1: \n             for (col = 0; col < (width / 2); col++)\n               { \n\t       for (i = 0; i < spp; i++)\n                  {\n\t\t  bytebuff1 = *src;\n\t\t  *src++ = *(dst - spp + i);\n                  *(dst - spp + i) = bytebuff1;\n\t\t  }\n\t\tdst -= spp;\n                }\n\t     break;\n     default: TIFFError(\"reverseSamplesBytes\",\"Unsupported bit depth %d\", bps);\n       return (1);\n     }\n  return (0);\n  } ", "target": 0}
{"code": "static int jpegxl_anim_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    JXLAnimDemuxContext *ctx = s->priv_data;\n    AVIOContext *pb = s->pb;\n    int ret;\n    int64_t size;\n    size_t offset = 0;\n    size = avio_size(pb);\n    if (size < 0)\n        return size;\n    if (size > INT_MAX)\n        return AVERROR(EDOM);\n    if (size == 0)\n        size = 4096;\n    if (ctx->initial && size < ctx->initial->size)\n        size = ctx->initial->size;\n    ret = av_new_packet(pkt, size);\n    if (ret < 0)\n        return ret;\n    if (ctx->initial) {\n        offset = ctx->initial->size;\n        memcpy(pkt->data, ctx->initial->data, offset);\n        av_buffer_unref(&ctx->initial);\n    }\n    ret = avio_read(pb, pkt->data + offset, size - offset);\n    if (ret < 0)\n        return ret;\n    if (ret < size - offset)\n        pkt->size = ret + offset;\n    return 0;\n}", "target": 0}
{"code": "static int checkStringLength(client *c, long long size) {\n    if (!mustObeyClient(c) && size > server.proto_max_bulk_len) {\n        addReplyError(c,\"string exceeds maximum allowed size (proto-max-bulk-len)\");\n        return C_ERR;\n    }\n    return C_OK;\n}", "target": 1}
{"code": "AP4_AvccAtom::InspectFields(AP4_AtomInspector& inspector)\n{\n    inspector.AddField(\"Configuration Version\", m_ConfigurationVersion);\n    const char* profile_name = GetProfileName(m_Profile);\n    if (profile_name) {\n        inspector.AddField(\"Profile\", profile_name);\n    } else {\n        inspector.AddField(\"Profile\", m_Profile);\n    }\n    inspector.AddField(\"Profile Compatibility\", m_ProfileCompatibility, AP4_AtomInspector::HINT_HEX);\n    inspector.AddField(\"Level\", m_Level);\n    inspector.AddField(\"NALU Length Size\", m_NaluLengthSize);\n    for (unsigned int i=0; i<m_SequenceParameters.ItemCount(); i++) {\n        inspector.AddField(\"Sequence Parameter\", m_SequenceParameters[i].GetData(), m_SequenceParameters[i].GetDataSize());\n    }\n    for (unsigned int i=0; i<m_SequenceParameters.ItemCount(); i++) {\n        inspector.AddField(\"Picture Parameter\", m_PictureParameters[i].GetData(), m_PictureParameters[i].GetDataSize());\n    }\n    return AP4_SUCCESS;\n}", "target": 1}
{"code": "static void start_auth_request(PgSocket *client, const char *username)\n{\n\tint res;\n\tPktBuf *buf;\n\tclient->auth_user = client->db->auth_user;\n\tclient->pool = get_pool(client->db, client->db->auth_user);\n\tif (!find_server(client)) {\n\t\tclient->wait_for_user_conn = true;\n\t\treturn;\n\t}\n\tslog_noise(client, \"Doing auth_conn query\");\n\tclient->wait_for_user_conn = false;\n\tclient->wait_for_user = true;\n\tif (!sbuf_pause(&client->sbuf)) {\n\t\trelease_server(client->link);\n\t\tdisconnect_client(client, true, \"pause failed\");\n\t\treturn;\n\t}\n\tclient->link->ready = 0;\n\tres = 0;\n\tbuf = pktbuf_dynamic(512);\n\tif (buf) {\n\t\tpktbuf_write_ExtQuery(buf, cf_auth_query, 1, username);\n\t\tres = pktbuf_send_immediate(buf, client->link);\n\t\tpktbuf_free(buf);\n\t}\n\tif (!res)\n\t\tdisconnect_server(client->link, false, \"unable to send login query\");\n}", "target": 1}
{"code": "mm_sshpam_init_ctx(Authctxt *authctxt)\n{\n\tBuffer m;\n\tint success;\n\tdebug3(\"%s\", __func__);\n\tbuffer_init(&m);\n\tbuffer_put_cstring(&m, authctxt->user);\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_PAM_INIT_CTX, &m);\n\tdebug3(\"%s: waiting for MONITOR_ANS_PAM_INIT_CTX\", __func__);\n\tmm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_PAM_INIT_CTX, &m);\n\tsuccess = buffer_get_int(&m);\n\tif (success == 0) {\n\t\tdebug3(\"%s: pam_init_ctx failed\", __func__);\n\t\tbuffer_free(&m);\n\t\treturn (NULL);\n\t}\n\tbuffer_free(&m);\n\treturn (authctxt);\n}", "target": 1}
{"code": "int av_reallocp_array(void *ptr, size_t nmemb, size_t size)\n{\n    void **ptrptr = ptr;\n    *ptrptr = av_realloc_f(*ptrptr, nmemb, size);\n    if (!*ptrptr && !(nmemb && size))\n        return AVERROR(ENOMEM);\n    return 0;\n}", "target": 1}
{"code": "static void cmd_anal_ucall_ref(RCore *core, ut64 addr) {\n\tRAnalFunction * fcn = r_anal_get_function_at (core->anal, addr);\n\tif (fcn) {\n\t\tr_cons_printf (\" ; %s\", fcn->name);\n\t} else {\n\t\tr_cons_printf (\" ; 0x%\" PFMT64x, addr);\n\t}\n}", "target": 1}
{"code": "    float parseFloat(const std::string& s, bool& ok)\n    {\n        float ret = stringTo<float>(s, ok);\n        if (ok) return ret;\n        Rational r = stringTo<Rational>(s, ok);\n        if (ok) {\n            if (r.second == 0) {\n                ok = false;\n                return 0.0;\n            }\n            return static_cast<float>(r.first) / r.second;\n        }\n        bool b = stringTo<bool>(s, ok);\n        if (ok) return b ? 1.0f : 0.0f;\n        return ret;\n    }", "target": 0}
{"code": "bool f_libxml_disable_entity_loader(bool disable ) {\n  xmlParserInputBufferCreateFilenameFunc old;\n  if (disable) {\n    old = xmlParserInputBufferCreateFilenameDefault(hphp_libxml_input_buffer_noload);\n  } else {\n    old = xmlParserInputBufferCreateFilenameDefault(nullptr);\n  }\n  return (old == hphp_libxml_input_buffer_noload);\n}", "target": 1}
{"code": "static inline int file_list_cpu(struct file *file)\n{\n#ifdef CONFIG_SMP\n\treturn file->f_sb_list_cpu;\n#else\n\treturn smp_processor_id();\n#endif\n}", "target": 1}
{"code": "static ssize_t fuse_dev_splice_write(struct pipe_inode_info *pipe,\n\t\t\t\t     struct file *out, loff_t *ppos,\n\t\t\t\t     size_t len, unsigned int flags)\n{\n\tunsigned nbuf;\n\tunsigned idx;\n\tstruct pipe_buffer *bufs;\n\tstruct fuse_copy_state cs;\n\tstruct fuse_dev *fud;\n\tsize_t rem;\n\tssize_t ret;\n\tfud = fuse_get_dev(out);\n\tif (!fud)\n\t\treturn -EPERM;\n\tpipe_lock(pipe);\n\tbufs = kvmalloc_array(pipe->nrbufs, sizeof(struct pipe_buffer),\n\t\t\t      GFP_KERNEL);\n\tif (!bufs) {\n\t\tpipe_unlock(pipe);\n\t\treturn -ENOMEM;\n\t}\n\tnbuf = 0;\n\trem = 0;\n\tfor (idx = 0; idx < pipe->nrbufs && rem < len; idx++)\n\t\trem += pipe->bufs[(pipe->curbuf + idx) & (pipe->buffers - 1)].len;\n\tret = -EINVAL;\n\tif (rem < len) {\n\t\tpipe_unlock(pipe);\n\t\tgoto out;\n\t}\n\trem = len;\n\twhile (rem) {\n\t\tstruct pipe_buffer *ibuf;\n\t\tstruct pipe_buffer *obuf;\n\t\tBUG_ON(nbuf >= pipe->buffers);\n\t\tBUG_ON(!pipe->nrbufs);\n\t\tibuf = &pipe->bufs[pipe->curbuf];\n\t\tobuf = &bufs[nbuf];\n\t\tif (rem >= ibuf->len) {\n\t\t\t*obuf = *ibuf;\n\t\t\tibuf->ops = NULL;\n\t\t\tpipe->curbuf = (pipe->curbuf + 1) & (pipe->buffers - 1);\n\t\t\tpipe->nrbufs--;\n\t\t} else {\n\t\t\tpipe_buf_get(pipe, ibuf);\n\t\t\t*obuf = *ibuf;\n\t\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\t\t\tobuf->len = rem;\n\t\t\tibuf->offset += obuf->len;\n\t\t\tibuf->len -= obuf->len;\n\t\t}\n\t\tnbuf++;\n\t\trem -= obuf->len;\n\t}\n\tpipe_unlock(pipe);\n\tfuse_copy_init(&cs, 0, NULL);\n\tcs.pipebufs = bufs;\n\tcs.nr_segs = nbuf;\n\tcs.pipe = pipe;\n\tif (flags & SPLICE_F_MOVE)\n\t\tcs.move_pages = 1;\n\tret = fuse_dev_do_write(fud, &cs, len);\n\tpipe_lock(pipe);\n\tfor (idx = 0; idx < nbuf; idx++)\n\t\tpipe_buf_release(pipe, &bufs[idx]);\n\tpipe_unlock(pipe);\nout:\n\tkvfree(bufs);\n\treturn ret;\n}", "target": 1}
{"code": "static BOOL rdp_write_logon_info_v1(wStream* s, logon_info* info)\n{\n\tconst size_t charLen = 52 / sizeof(WCHAR);\n\tconst size_t userCharLen = 512 / sizeof(WCHAR);\n\tsize_t sz = 4 + 52 + 4 + 512 + 4;\n\tsize_t len = 0;\n\tif (!Stream_EnsureRemainingCapacity(s, sz))\n\t\treturn FALSE;\n\tWINPR_ASSERT(info);\n\tif (!info->domain || !info->username)\n\t\treturn FALSE;\n\tlen = strnlen(info->domain, charLen + 1);\n\tif (len > charLen)\n\t\treturn FALSE;\n\tStream_Write_UINT32(s, len * sizeof(WCHAR));\n\tif (Stream_Write_UTF16_String_From_UTF8(s, charLen, info->domain, len, TRUE) < 0)\n\t\treturn FALSE;\n\tlen = strnlen(info->username, userCharLen + 1);\n\tif (len > userCharLen)\n\t\treturn FALSE;\n\tStream_Write_UINT32(s, len * sizeof(WCHAR));\n\tif (Stream_Write_UTF16_String_From_UTF8(s, userCharLen, info->username, len, TRUE) < 0)\n\t\treturn FALSE;\n\tStream_Write_UINT32(s, info->sessionId);\n\treturn TRUE;\n}", "target": 0}
{"code": "create_separator(void)\n{\n\tstruct defer_node *result;\n\tresult = malloc(sizeof(struct defer_node));\n\tif (result == NULL)\n\t\treturn NULL;\n\tresult->type = DNT_SEPARATOR;\n\treturn result;\n}", "target": 0}
{"code": "static int string_check(char *buf, const char *buf2)\n{\n  if(strcmp(buf, buf2)) {\n    printf(\"sprintf failed:\\nwe '%s'\\nsystem: '%s'\\n\",\n           buf, buf2);\n    return 1;\n  }\n  return 0;\n}", "target": 1}
{"code": "R_API bool r_anal_vtable_begin(RAnal *anal, RVTableContext *context) {\n\tcontext->anal = anal;\n\tcontext->abi = anal->cxxabi;\n\tcontext->word_size = (ut8) (anal->config->bits / 8);\n\tconst bool is_arm = anal->cur->arch && r_str_startswith (anal->cur->arch, \"arm\");\n\tif (is_arm && context->word_size < 4) {\n\t\tcontext->word_size = 4;\n\t}\n\tconst bool be = anal->config->big_endian;\n\tswitch (context->word_size) {\n\tcase 1:\n\t\tcontext->read_addr = be? vtable_read_addr_be8 : vtable_read_addr_le8;\n\t\tbreak;\n\tcase 2:\n\t\tcontext->read_addr = be? vtable_read_addr_be16 : vtable_read_addr_le16;\n\t\tbreak;\n\tcase 4:\n\t\tcontext->read_addr = be? vtable_read_addr_be32 : vtable_read_addr_le32;\n\t\tbreak;\n\tcase 8:\n\t\tcontext->read_addr = be? vtable_read_addr_be64 : vtable_read_addr_le64;\n\t\tbreak;\n\tdefault:\n\t\tcontext->read_addr = be? vtable_read_addr_be32 : vtable_read_addr_le32;\n\t\treturn false;\n\t}\n\treturn true;\n}", "target": 0}
{"code": "static void mirror_free_init(MirrorBlockJob *s)\n{\n    int granularity = s->granularity;\n    size_t buf_size = s->buf_size;\n    uint8_t *buf = s->buf;\n    assert(s->buf_free_count == 0);\n    QSIMPLEQ_INIT(&s->buf_free);\n    while (buf_size != 0) {\n        MirrorBuffer *cur = (MirrorBuffer *)buf;\n        QSIMPLEQ_INSERT_TAIL(&s->buf_free, cur, next);\n        s->buf_free_count++;\n        buf_size -= granularity;\n        buf += granularity;\n    }\n}", "target": 0}
{"code": "static gpa_t FNAME(gva_to_gpa)(struct kvm_vcpu *vcpu, gva_t vaddr, u32 access,\n\t\t\t       struct x86_exception *exception)\n{\n\tstruct guest_walker walker;\n\tgpa_t gpa = UNMAPPED_GVA;\n\tint r;\n\tr = FNAME(walk_addr)(&walker, vcpu, vaddr, access);\n\tif (r) {\n\t\tgpa = gfn_to_gpa(walker.gfn);\n\t\tgpa |= vaddr & ~PAGE_MASK;\n\t} else if (exception)\n\t\t*exception = walker.fault;\n\treturn gpa;\n}", "target": 0}
{"code": "static HashTable* spl_array_get_debug_info(zval *obj, int *is_temp TSRMLS_DC) \n{\n\tspl_array_object *intern = (spl_array_object*)zend_object_store_get_object(obj TSRMLS_CC);\n\tzval *tmp, *storage;\n\tint name_len;\n\tchar *zname;\n\tzend_class_entry *base;\n\t*is_temp = 0;\n\tif (!intern->std.properties) {\n\t\trebuild_object_properties(&intern->std);\n\t}\n\tif (HASH_OF(intern->array) == intern->std.properties) {\n\t\treturn intern->std.properties;\n\t} else {\n\t\tif (intern->debug_info == NULL) {\n\t\t\tALLOC_HASHTABLE(intern->debug_info);\n\t\t\tZEND_INIT_SYMTABLE_EX(intern->debug_info, zend_hash_num_elements(intern->std.properties) + 1, 0);\n\t\t}\n\t\tif (intern->debug_info->nApplyCount == 0) {\n\t\t\tzend_hash_clean(intern->debug_info);\n\t\t\tzend_hash_copy(intern->debug_info, intern->std.properties, (copy_ctor_func_t) zval_add_ref, (void *) &tmp, sizeof(zval *));\n\t\t\tstorage = intern->array;\n\t\t\tzval_add_ref(&storage);\n\t\t\tbase = (Z_OBJ_HT_P(obj) == &spl_handler_ArrayIterator) ? spl_ce_ArrayIterator : spl_ce_ArrayObject;\n\t\t\tzname = spl_gen_private_prop_name(base, \"storage\", sizeof(\"storage\")-1, &name_len TSRMLS_CC);\n\t\t\tzend_symtable_update(intern->debug_info, zname, name_len+1, &storage, sizeof(zval *), NULL);\n\t\t\tefree(zname);\n\t\t}\n\t\treturn intern->debug_info;\n\t}\n}", "target": 0}
{"code": "cmsNAMEDCOLORLIST* CMSEXPORT cmsAllocNamedColorList(cmsContext ContextID, cmsUInt32Number n, cmsUInt32Number ColorantCount, const char* Prefix, const char* Suffix)\n{\n    cmsNAMEDCOLORLIST* v = (cmsNAMEDCOLORLIST*) _cmsMallocZero(ContextID, sizeof(cmsNAMEDCOLORLIST));\n    if (v == NULL) return NULL;\n    v ->List      = NULL;\n    v ->nColors   = 0;\n    v ->ContextID  = ContextID;\n    while (v -> Allocated < n)\n        GrowNamedColorList(v);\n    strncpy(v ->Prefix, Prefix, sizeof(v ->Prefix));\n    strncpy(v ->Suffix, Suffix, sizeof(v ->Suffix));\n    v->Prefix[32] = v->Suffix[32] = 0;\n    v -> ColorantCount = ColorantCount;\n    return v;\n}", "target": 1}
{"code": "static int netlink_dump(struct sock *sk)\n{\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\tstruct netlink_callback *cb;\n\tstruct sk_buff *skb = NULL;\n\tstruct nlmsghdr *nlh;\n\tint len, err = -ENOBUFS;\n\tint alloc_min_size;\n\tint alloc_size;\n\tmutex_lock(nlk->cb_mutex);\n\tif (!nlk->cb_running) {\n\t\terr = -EINVAL;\n\t\tgoto errout_skb;\n\t}\n\tif (atomic_read(&sk->sk_rmem_alloc) >= sk->sk_rcvbuf)\n\t\tgoto errout_skb;\n\tcb = &nlk->cb;\n\talloc_min_size = max_t(int, cb->min_dump_alloc, NLMSG_GOODSIZE);\n\tif (alloc_min_size < nlk->max_recvmsg_len) {\n\t\talloc_size = nlk->max_recvmsg_len;\n\t\tskb = alloc_skb(alloc_size, GFP_KERNEL |\n\t\t\t\t\t    __GFP_NOWARN | __GFP_NORETRY);\n\t}\n\tif (!skb) {\n\t\talloc_size = alloc_min_size;\n\t\tskb = alloc_skb(alloc_size, GFP_KERNEL);\n\t}\n\tif (!skb)\n\t\tgoto errout_skb;\n\tskb_reserve(skb, skb_tailroom(skb) - alloc_size);\n\tnetlink_skb_set_owner_r(skb, sk);\n\tlen = cb->dump(skb, cb);\n\tif (len > 0) {\n\t\tmutex_unlock(nlk->cb_mutex);\n\t\tif (sk_filter(sk, skb))\n\t\t\tkfree_skb(skb);\n\t\telse\n\t\t\t__netlink_sendskb(sk, skb);\n\t\treturn 0;\n\t}\n\tnlh = nlmsg_put_answer(skb, cb, NLMSG_DONE, sizeof(len), NLM_F_MULTI);\n\tif (!nlh)\n\t\tgoto errout_skb;\n\tnl_dump_check_consistent(cb, nlh);\n\tmemcpy(nlmsg_data(nlh), &len, sizeof(len));\n\tif (sk_filter(sk, skb))\n\t\tkfree_skb(skb);\n\telse\n\t\t__netlink_sendskb(sk, skb);\n\tif (cb->done)\n\t\tcb->done(cb);\n\tnlk->cb_running = false;\n\tmutex_unlock(nlk->cb_mutex);\n\tmodule_put(cb->module);\n\tconsume_skb(cb->skb);\n\treturn 0;\nerrout_skb:\n\tmutex_unlock(nlk->cb_mutex);\n\tkfree_skb(skb);\n\treturn err;\n}", "target": 1}
{"code": "void CarbonProtocolReader::skip(const FieldType ft) {\n  switch (ft) {\n    case FieldType::True:\n    case FieldType::False: {\n      break;\n    }\n    case FieldType::Int8: {\n      readRaw<int8_t>();\n      break;\n    }\n    case FieldType::Int16: {\n      readRaw<int16_t>();\n      break;\n    }\n    case FieldType::Int32: {\n      readRaw<int32_t>();\n      break;\n    }\n    case FieldType::Int64: {\n      readRaw<int64_t>();\n      break;\n    }\n    case FieldType::Double: {\n      readRaw<double>();\n      break;\n    }\n    case FieldType::Float: {\n      readRaw<float>();\n      break;\n    }\n    case FieldType::Binary: {\n      readRaw<std::string>();\n      break;\n    }\n    case FieldType::List: {\n      skipLinearContainer();\n      break;\n    }\n    case FieldType::Struct: {\n      readStructBegin();\n      while (true) {\n        const auto fieldType = readFieldHeader().first;\n        if (fieldType == FieldType::Stop) {\n          break;\n        }\n        skip(fieldType);\n      }\n      readStructEnd();\n      break;\n    }\n    case FieldType::Set: {\n      skipLinearContainer();\n      break;\n    }\n    case FieldType::Map: {\n      skipKVContainer();\n      break;\n    }\n    default: { break; }\n  }\n}", "target": 1}
{"code": "static int write_empty_blocks(struct page *page, unsigned from, unsigned to,\n\t\t\t      int mode)\n{\n\tstruct inode *inode = page->mapping->host;\n\tunsigned start, end, next, blksize;\n\tsector_t block = page->index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\tint ret;\n\tblksize = 1 << inode->i_blkbits;\n\tnext = end = 0;\n\twhile (next < from) {\n\t\tnext += blksize;\n\t\tblock++;\n\t}\n\tstart = next;\n\tdo {\n\t\tnext += blksize;\n\t\tret = needs_empty_write(block, inode);\n\t\tif (unlikely(ret < 0))\n\t\t\treturn ret;\n\t\tif (ret == 0) {\n\t\t\tif (end) {\n\t\t\t\tret = __block_write_begin(page, start, end - start,\n\t\t\t\t\t\t\t  gfs2_block_map);\n\t\t\t\tif (unlikely(ret))\n\t\t\t\t\treturn ret;\n\t\t\t\tret = empty_write_end(page, start, end, mode);\n\t\t\t\tif (unlikely(ret))\n\t\t\t\t\treturn ret;\n\t\t\t\tend = 0;\n\t\t\t}\n\t\t\tstart = next;\n\t\t}\n\t\telse\n\t\t\tend = next;\n\t\tblock++;\n\t} while (next < to);\n\tif (end) {\n\t\tret = __block_write_begin(page, start, end - start, gfs2_block_map);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t\tret = empty_write_end(page, start, end, mode);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": " struct timespec ns_to_timespec(const s64 nsec)\n {\n \tstruct timespec ts;\n\ts32 rem;\n \tif (!nsec)\n \t\treturn (struct timespec) {0, 0};\n\tts.tv_sec = div_s64_rem(nsec, NSEC_PER_SEC, &rem);\n\tif (unlikely(rem < 0)) {\n\t\tts.tv_sec--;\n\t\trem += NSEC_PER_SEC;\n\t}\n\tts.tv_nsec = rem;\n \treturn ts;\n }", "target": 0}
{"code": "void jas_deprecated(const char *s)\n{\n\tstatic char message[] =\n\t\"WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!!\\n\"\n\t\"WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!!\\n\"\n\t\"WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!!\\n\"\n\t\"YOUR CODE IS RELYING ON DEPRECATED FUNCTIONALTIY IN THE JASPER LIBRARY.\\n\"\n\t\"THIS FUNCTIONALITY WILL BE REMOVED IN THE NEAR FUTURE.\\n\"\n\t\"PLEASE FIX THIS PROBLEM BEFORE YOUR CODE STOPS WORKING!\\n\"\n\t;\n\tjas_eprintf(\"%s\", message);\n\tjas_eprintf(\"The specific problem is as follows:\\n%s\\n\", s);\n}", "target": 0}
{"code": "int authRequired(client *c) {\n    int auth_required = (!(DefaultUser->flags & USER_FLAG_NOPASS) ||\n                          (DefaultUser->flags & USER_FLAG_DISABLED)) &&\n                        !c->authenticated;\n    return auth_required;\n}", "target": 0}
{"code": "static int prealloc_elems_and_freelist(struct bpf_stack_map *smap)\n{\n\tu32 elem_size = sizeof(struct stack_map_bucket) + smap->map.value_size;\n\tint err;\n\tsmap->elems = bpf_map_area_alloc(elem_size * smap->map.max_entries,\n\t\t\t\t\t smap->map.numa_node);\n\tif (!smap->elems)\n\t\treturn -ENOMEM;\n\terr = pcpu_freelist_init(&smap->freelist);\n\tif (err)\n\t\tgoto free_elems;\n\tpcpu_freelist_populate(&smap->freelist, smap->elems, elem_size,\n\t\t\t       smap->map.max_entries);\n\treturn 0;\nfree_elems:\n\tbpf_map_area_free(smap->elems);\n\treturn err;\n}", "target": 1}
{"code": "int flush_completed_IO(struct inode *inode)\n{\n\text4_io_end_t *io;\n\tint ret = 0;\n\tint ret2 = 0;\n\tif (list_empty(&EXT4_I(inode)->i_completed_io_list))\n\t\treturn ret;\n\tdump_completed_IO(inode);\n\twhile (!list_empty(&EXT4_I(inode)->i_completed_io_list)){\n\t\tio = list_entry(EXT4_I(inode)->i_completed_io_list.next,\n\t\t\t\text4_io_end_t, list);\n\t\tret = ext4_end_io_nolock(io);\n\t\tif (ret < 0)\n\t\t\tret2 = ret;\n\t\telse\n\t\t\tlist_del_init(&io->list);\n\t}\n\treturn (ret2 < 0) ? ret2 : 0;\n}", "target": 1}
{"code": "\tCmdResult HandleLocal(LocalUser* user, const Params& parameters) CXX11_OVERRIDE\n\t{\n\t\tsize_t origin = parameters.size() > 1 ? 1 : 0;\n\t\tif (parameters[origin].empty())\n\t\t{\n\t\t\tuser->WriteNumeric(ERR_NOORIGIN, \"No origin specified\");\n\t\t\treturn CMD_FAILURE;\n\t\t}\n\t\tClientProtocol::Messages::Pong pong(parameters[0], origin ? parameters[1] : \"\");\n\t\tuser->Send(ServerInstance->GetRFCEvents().pong, pong);\n\t\treturn CMD_SUCCESS;\n\t}", "target": 1}
{"code": "static void *load_bytes(RBinFile *arch, const ut8 *buf, ut64 sz, ut64 loaddr, Sdb *sdb) {\n\tif (!buf || !sz || sz == UT64_MAX) {\n\t\treturn NULL;\n\t}\n\tRBuffer *tbuf = r_buf_new ();\n\tif (!tbuf) {\n\t\treturn NULL;\n\t}\n\tr_buf_set_bytes (tbuf, buf, sz);\n\tstruct r_bin_bflt_obj *res = r_bin_bflt_new_buf (tbuf);\n\tr_buf_free (tbuf);\n\treturn res ? res : NULL;\n}", "target": 0}
{"code": "bool copyaudiodata (AFfilehandle infile, AFfilehandle outfile, int trackid)\n{\n\tint frameSize = afGetVirtualFrameSize(infile, trackid, 1);\n\tconst int kBufferFrameCount = 65536;\n\tvoid *buffer = malloc(kBufferFrameCount * frameSize);\n\tAFframecount totalFrames = afGetFrameCount(infile, AF_DEFAULT_TRACK);\n\tAFframecount totalFramesWritten = 0;\n\tbool success = true;\n\twhile (totalFramesWritten < totalFrames)\n\t{\n\t\tAFframecount framesToRead = totalFrames - totalFramesWritten;\n\t\tif (framesToRead > kBufferFrameCount)\n\t\t\tframesToRead = kBufferFrameCount;\n\t\tAFframecount framesRead = afReadFrames(infile, trackid, buffer,\n\t\t\tframesToRead);\n\t\tif (framesRead < framesToRead)\n\t\t{\n\t\t\tfprintf(stderr, \"Bad read of audio track data.\\n\");\n\t\t\tsuccess = false;\n\t\t\tbreak;\n\t\t}\n\t\tAFframecount framesWritten = afWriteFrames(outfile, trackid, buffer,\n\t\t\tframesRead);\n\t\tif (framesWritten < framesRead)\n\t\t{\n\t\t\tfprintf(stderr, \"Bad write of audio track data.\\n\");\n\t\t\tsuccess = false;\n\t\t\tbreak;\n\t\t}\n\t\ttotalFramesWritten += framesWritten;\n\t}\n\tfree(buffer);\n\treturn success;\n}", "target": 1}
{"code": "static void lateeoi_list_del(struct irq_info *info)\n{\n\tstruct lateeoi_work *eoi = &per_cpu(lateeoi, info->eoi_cpu);\n\tunsigned long flags;\n\tspin_lock_irqsave(&eoi->eoi_list_lock, flags);\n\tlist_del_init(&info->eoi_list);\n\tspin_unlock_irqrestore(&eoi->eoi_list_lock, flags);\n}", "target": 0}
{"code": "static void wait_limit_netblock_del(rbnode_type* n, void* ATTR_UNUSED(arg))\n{\n\tfree(n);\n}", "target": 0}
{"code": "static int decode_level3_header(LHAFileHeader **header, LHAInputStream *stream)\n{\n\tunsigned int header_len;\n\tif (lha_decode_uint16(&RAW_DATA(header, 0)) != 4) {\n\t\treturn 0;\n\t}\n\tif (!extend_raw_data(header, stream,\n\t                     LEVEL_3_HEADER_LEN - RAW_DATA_LEN(header))) {\n\t\treturn 0;\n\t}\n\theader_len = lha_decode_uint32(&RAW_DATA(header, 24));\n\tif (header_len > LEVEL_3_MAX_HEADER_LEN) {\n\t\treturn 0;\n\t}\n\tif (!extend_raw_data(header, stream,\n\t                     header_len - RAW_DATA_LEN(header))) {\n\t\treturn 0;\n\t}\n\tmemcpy((*header)->compress_method, &RAW_DATA(header, 2), 5);\n\t(*header)->compress_method[5] = '\\0';\n\t(*header)->compressed_length = lha_decode_uint32(&RAW_DATA(header, 7));\n\t(*header)->length = lha_decode_uint32(&RAW_DATA(header, 11));\n\t(*header)->timestamp = lha_decode_uint32(&RAW_DATA(header, 15));\n\t(*header)->crc = lha_decode_uint16(&RAW_DATA(header, 21));\n\t(*header)->os_type = RAW_DATA(header, 23);\n\tif (!decode_extended_headers(header, 28)) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "IW_IMPL(unsigned int) iw_get_ui16be(const iw_byte *b)\n{\n\treturn (b[0]<<8) | b[1];\n}", "target": 1}
{"code": "static int snmp6_alloc_dev(struct inet6_dev *idev)\n{\n\tif (snmp_mib_init((void __percpu **)idev->stats.ipv6,\n\t\t\t  sizeof(struct ipstats_mib),\n\t\t\t  __alignof__(struct ipstats_mib)) < 0)\n\t\tgoto err_ip;\n\tidev->stats.icmpv6dev = kzalloc(sizeof(struct icmpv6_mib_device),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!idev->stats.icmpv6dev)\n\t\tgoto err_icmp;\n\tidev->stats.icmpv6msgdev = kzalloc(sizeof(struct icmpv6msg_mib_device),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!idev->stats.icmpv6msgdev)\n\t\tgoto err_icmpmsg;\n\treturn 0;\nerr_icmpmsg:\n\tkfree(idev->stats.icmpv6dev);\nerr_icmp:\n\tsnmp_mib_free((void __percpu **)idev->stats.ipv6);\nerr_ip:\n\treturn -ENOMEM;\n}", "target": 0}
{"code": "MYSOFA_EXPORT struct MYSOFA_HRTF* mysofa_load(const char *filename, int *err) {\n\tstruct READER reader;\n\tstruct MYSOFA_HRTF *hrtf = NULL;\n\tif (filename == NULL)\n\t\tfilename = CMAKE_INSTALL_PREFIX \"/share/libmysofa/default.sofa\";\n\tif (strcmp(filename, \"-\"))\n\t\treader.fhd = fopen(filename, \"rb\");\n\telse\n\t\treader.fhd = stdin;\n\tif (!reader.fhd) {\n\t\tlog(\"cannot open file %s\\n\", filename);\n\t\t*err = errno;\n\t\treturn NULL;\n\t}\n\treader.gcol = NULL;\n\treader.all = NULL;\n\treader.recursive_counter = 0;\n\t*err = superblockRead(&reader, &reader.superblock);\n\tif (!*err) {\n\t\thrtf = getHrtf(&reader, err);\n\t}\n\tsuperblockFree(&reader, &reader.superblock);\n\tgcolFree(reader.gcol);\n\tif (strcmp(filename, \"-\"))\n\t\tfclose(reader.fhd);\n\treturn hrtf;\n}", "target": 0}
{"code": "int CLASS parse_jpeg(int offset)\n{\n  int len, save, hlen, mark;\n  fseek(ifp, offset, SEEK_SET);\n  if (fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8)\n    return 0;\n  while (fgetc(ifp) == 0xff && (mark = fgetc(ifp)) != 0xda)\n  {\n    order = 0x4d4d;\n    len = get2() - 2;\n    save = ftell(ifp);\n    if (mark == 0xc0 || mark == 0xc3 || mark == 0xc9)\n    {\n      fgetc(ifp);\n      raw_height = get2();\n      raw_width = get2();\n    }\n    order = get2();\n    hlen = get4();\n    if (get4() == 0x48454150) \n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n#endif\n      parse_ciff(save + hlen, len - hlen, 0);\n    }\n    if (parse_tiff(save + 6))\n      apply_tiff();\n    fseek(ifp, save + len, SEEK_SET);\n  }\n  return 1;\n}", "target": 1}
{"code": "static void perf_event_exit_cpu(int cpu)\n{\n\tstruct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);\n\tperf_event_exit_cpu_context(cpu);\n\tmutex_lock(&swhash->hlist_mutex);\n\tswhash->online = false;\n\tswevent_hlist_release(swhash);\n\tmutex_unlock(&swhash->hlist_mutex);\n}", "target": 1}
{"code": "void CNB::SetupLSO(virtio_net_hdr_basic *VirtioHeader, PVOID IpHeader, ULONG EthPayloadLength) const\n{\n    PopulateIPLength(reinterpret_cast<IPv4Header*>(IpHeader), static_cast<USHORT>(EthPayloadLength));\n    tTcpIpPacketParsingResult packetReview;\n    packetReview = ParaNdis_CheckSumVerifyFlat(reinterpret_cast<IPv4Header*>(IpHeader), EthPayloadLength,\n                                               pcrIpChecksum | pcrFixIPChecksum | pcrTcpChecksum | pcrFixPHChecksum,\n                                               FALSE,\n                                               __FUNCTION__);\n    if (packetReview.xxpCheckSum == ppresPCSOK || packetReview.fixedXxpCS)\n    {\n        auto IpHeaderOffset = m_Context->Offload.ipHeaderOffset;\n        auto VHeader = static_cast<virtio_net_hdr_basic*>(VirtioHeader);\n        auto PriorityHdrLen = (m_ParentNBL->TCI() != 0) ? ETH_PRIORITY_HEADER_SIZE : 0;\n        VHeader->flags = VIRTIO_NET_HDR_F_NEEDS_CSUM;\n        VHeader->gso_type = packetReview.ipStatus == ppresIPV4 ? VIRTIO_NET_HDR_GSO_TCPV4 : VIRTIO_NET_HDR_GSO_TCPV6;\n        VHeader->hdr_len = (USHORT)(packetReview.XxpIpHeaderSize + IpHeaderOffset + PriorityHdrLen);\n        VHeader->gso_size = (USHORT)m_ParentNBL->MSS();\n        VHeader->csum_start = (USHORT)(m_ParentNBL->TCPHeaderOffset() + PriorityHdrLen);\n        VHeader->csum_offset = TCP_CHECKSUM_OFFSET;\n    }\n}", "target": 0}
{"code": "static void settings_changed(struct btd_adapter *adapter, uint32_t settings)\n{\n\tuint32_t changed_mask;\n\tchanged_mask = adapter->current_settings ^ settings;\n\tadapter->current_settings = settings;\n\tadapter->pending_settings &= ~changed_mask;\n\tDBG(\"Changed settings: 0x%08x\", changed_mask);\n\tDBG(\"Pending settings: 0x%08x\", adapter->pending_settings);\n\tif (changed_mask & MGMT_SETTING_POWERED) {\n\t        g_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Powered\");\n\t\tif (adapter->current_settings & MGMT_SETTING_POWERED) {\n\t\t\tadapter_start(adapter);\n\t\t} else {\n\t\t\tadapter_stop(adapter);\n\t\t\tif (powering_down) {\n\t\t\t\tadapter_remaining--;\n\t\t\t\tif (!adapter_remaining)\n\t\t\t\t\tbtd_exit();\n\t\t\t}\n\t\t}\n\t}\n\tif ((changed_mask & MGMT_SETTING_LE) &&\n\t\t\t\tbtd_adapter_get_powered(adapter) &&\n\t\t\t\t(adapter->current_settings & MGMT_SETTING_LE))\n\t\ttrigger_passive_scanning(adapter);\n\tif (changed_mask & MGMT_SETTING_DISCOVERABLE) {\n\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Discoverable\");\n\t\tstore_adapter_info(adapter);\n\t\tbtd_adv_manager_refresh(adapter->adv_manager);\n\t}\n\tif (changed_mask & MGMT_SETTING_BONDABLE) {\n\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Pairable\");\n\t\ttrigger_pairable_timeout(adapter);\n\t}\n}", "target": 1}
{"code": "void rose_stop_idletimer(struct sock *sk)\n{\n\tdel_timer(&rose_sk(sk)->idletimer);\n}", "target": 1}
{"code": "void send( char* str ) {\n    fprintf(outfile, \"%s\",str);\n}", "target": 0}
{"code": "MagickExport void CatchException(ExceptionInfo *exception)\n{\n  register const ExceptionInfo\n    *p;\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (exception->exceptions  == (void *) NULL)\n    return;\n  LockSemaphoreInfo(exception->semaphore);\n  ResetLinkedListIterator((LinkedListInfo *) exception->exceptions);\n  p=(const ExceptionInfo *) GetNextValueInLinkedList((LinkedListInfo *)\n    exception->exceptions);\n  while (p != (const ExceptionInfo *) NULL)\n  {\n    if ((p->severity >= WarningException) && (p->severity < ErrorException))\n      MagickWarning(p->severity,p->reason,p->description);\n    if ((p->severity >= ErrorException) && (p->severity < FatalErrorException))\n      MagickError(p->severity,p->reason,p->description);\n    if (p->severity >= FatalErrorException)\n      MagickFatalError(p->severity,p->reason,p->description);\n    p=(const ExceptionInfo *) GetNextValueInLinkedList((LinkedListInfo *)\n      exception->exceptions);\n  }\n  UnlockSemaphoreInfo(exception->semaphore);\n  ClearMagickException(exception);\n}", "target": 1}
{"code": "switchGroup(uid_t uid, const struct passwd *userInfo, gid_t gid) {\n\tif (userInfo != NULL) {\n\t\tbool setgroupsCalled = false;\n\t\t#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__)\n\t\t\t#ifdef __APPLE__\n\t\t\t\tint groups[1024];\n\t\t\t\tint ngroups = sizeof(groups) / sizeof(int);\n\t\t\t#else\n\t\t\t\tgid_t groups[1024];\n\t\t\t\tint ngroups = sizeof(groups) / sizeof(gid_t);\n\t\t\t#endif\n\t\t\tboost::scoped_array<gid_t> gidset;\n\t\t\tint ret = getgrouplist(userInfo->pw_name, gid,\n\t\t\t\tgroups, &ngroups);\n\t\t\tif (ret == -1) {\n\t\t\t\tint e = errno;\n\t\t\t\tfprintf(stderr, \"ERROR: getgrouplist(%s, %d) failed: %s (errno=%d)\\n\",\n\t\t\t\t\tuserInfo->pw_name, (int) gid, strerror(e), e);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (ngroups <= NGROUPS_MAX) {\n\t\t\t\tsetgroupsCalled = true;\n\t\t\t\tgidset.reset(new gid_t[ngroups]);\n\t\t\t\tfor (int i = 0; i < ngroups; i++) {\n\t\t\t\t\tgidset[i] = groups[i];\n\t\t\t\t}\n\t\t\t\tif (setgroups(ngroups, gidset.get()) == -1) {\n\t\t\t\t\tint e = errno;\n\t\t\t\t\tfprintf(stderr, \"ERROR: setgroups(%d, ...) failed: %s (errno=%d)\\n\",\n\t\t\t\t\t\tngroups, strerror(e), e);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t#endif\n\t\tif (!setgroupsCalled && initgroups(userInfo->pw_name, gid) == -1) {\n\t\t\tint e = errno;\n\t\t\tfprintf(stderr, \"ERROR: initgroups(%s, %d) failed: %s (errno=%d)\\n\",\n\t\t\t\tuserInfo->pw_name, (int) gid, strerror(e), e);\n\t\t\texit(1);\n\t\t}\n\t}\n\tif (setgid(gid) == -1) {\n\t\tint e = errno;\n\t\tfprintf(stderr, \"ERROR: setgid(%d) failed: %s (errno=%d)\\n\",\n\t\t\t(int) gid, strerror(e), e);\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "AP_CORE_DECLARE(void) ap_parse_uri(request_rec *r, const char *uri)\n{\n    int status = HTTP_OK;\n    r->unparsed_uri = apr_pstrdup(r->pool, uri);\n    while ((uri[0] == '/') && (uri[1] == '/')) {\n        ++uri ;\n    }\n    if (r->method_number == M_CONNECT) {\n        status = apr_uri_parse_hostinfo(r->pool, uri, &r->parsed_uri);\n    }\n    else {\n        status = apr_uri_parse(r->pool, uri, &r->parsed_uri);\n    }\n    if (status == APR_SUCCESS) {\n        if (r->parsed_uri.scheme\n            && !ap_cstr_casecmp(r->parsed_uri.scheme, ap_http_scheme(r))) {\n            r->hostname = r->parsed_uri.hostname;\n        }\n        else if (r->method_number == M_CONNECT) {\n            r->hostname = r->parsed_uri.hostname;\n        }\n        r->args = r->parsed_uri.query;\n        r->uri = r->parsed_uri.path ? r->parsed_uri.path\n                 : apr_pstrdup(r->pool, \"/\");\n#if defined(OS2) || defined(WIN32)\n        {\n            char *x;\n            for (x = r->uri; (x = strchr(x, '\\\\')) != NULL; )\n                *x = '/';\n        }\n#endif \n    }\n    else {\n        r->args = NULL;\n        r->hostname = NULL;\n        r->status = HTTP_BAD_REQUEST;             \n        r->uri = apr_pstrdup(r->pool, uri);\n    }\n}", "target": 1}
{"code": "batadv_frag_merge_packets(struct hlist_head *chain, struct sk_buff *skb)\n{\n\tstruct batadv_frag_packet *packet;\n\tstruct batadv_frag_list_entry *entry;\n\tstruct sk_buff *skb_out = NULL;\n\tint size, hdr_size = sizeof(struct batadv_frag_packet);\n\tpacket = (struct batadv_frag_packet *)skb->data;\n\tsize = ntohs(packet->total_size);\n\tif (size > batadv_frag_size_limit())\n\t\tgoto free;\n\tentry = hlist_entry(chain->first, struct batadv_frag_list_entry, list);\n\thlist_del(&entry->list);\n\tskb_out = entry->skb;\n\tkfree(entry);\n\tif (pskb_expand_head(skb_out, 0, size - skb->len, GFP_ATOMIC) < 0) {\n\t\tkfree_skb(skb_out);\n\t\tskb_out = NULL;\n\t\tgoto free;\n\t}\n\tskb_pull_rcsum(skb_out, hdr_size);\n\tmemmove(skb_out->data - ETH_HLEN, skb_mac_header(skb_out), ETH_HLEN);\n\tskb_set_mac_header(skb_out, -ETH_HLEN);\n\tskb_reset_network_header(skb_out);\n\tskb_reset_transport_header(skb_out);\n\thlist_for_each_entry(entry, chain, list) {\n\t\tsize = entry->skb->len - hdr_size;\n\t\tmemcpy(skb_put(skb_out, size), entry->skb->data + hdr_size,\n\t\t       size);\n\t}\nfree:\n\tbatadv_frag_clear_chain(chain);\n\treturn skb_out;\n}", "target": 1}
{"code": "static void __exit mb2cache_exit(void)\n{\n\tkmem_cache_destroy(mb2_entry_cache);\n}", "target": 0}
{"code": "static CallResult<HermesValue> getCodeBlockFileName(\n    Runtime &runtime,\n    const CodeBlock *codeBlock,\n    OptValue<hbc::DebugSourceLocation> location) {\n  RuntimeModule *runtimeModule = codeBlock->getRuntimeModule();\n  if (location) {\n    auto debugInfo = runtimeModule->getBytecode()->getDebugInfo();\n    return StringPrimitive::createEfficient(\n        runtime, debugInfo->getFilenameByID(location->filenameId));\n  } else {\n    llvh::StringRef sourceURL = runtimeModule->getSourceURL();\n    if (!sourceURL.empty()) {\n      return StringPrimitive::createEfficient(runtime, sourceURL);\n    }\n  }\n  return HermesValue::encodeUndefinedValue();\n}", "target": 1}
{"code": "static int stellaris_enet_load(QEMUFile *f, void *opaque, int version_id)\n{\n    stellaris_enet_state *s = (stellaris_enet_state *)opaque;\n    int i;\n    if (version_id != 1)\n        return -EINVAL;\n    s->ris = qemu_get_be32(f);\n    s->im = qemu_get_be32(f);\n    s->rctl = qemu_get_be32(f);\n    s->tctl = qemu_get_be32(f);\n    s->thr = qemu_get_be32(f);\n    s->mctl = qemu_get_be32(f);\n    s->mdv = qemu_get_be32(f);\n    s->mtxd = qemu_get_be32(f);\n    s->mrxd = qemu_get_be32(f);\n    s->np = qemu_get_be32(f);\n    s->tx_fifo_len = qemu_get_be32(f);\n    qemu_get_buffer(f, s->tx_fifo, sizeof(s->tx_fifo));\n    for (i = 0; i < 31; i++) {\n        s->rx[i].len = qemu_get_be32(f);\n        qemu_get_buffer(f, s->rx[i].data, sizeof(s->rx[i].data));\n    }\n    s->next_packet = qemu_get_be32(f);\n    s->rx_fifo_offset = qemu_get_be32(f);\n    return 0;\n}", "target": 1}
{"code": "static MagickBooleanType SkipRGBMipmaps(Image *image,DDSInfo *dds_info,\n  int pixel_size,ExceptionInfo *exception)\n{\n  MagickOffsetType\n    offset;\n  register ssize_t\n    i;\n  size_t\n    h,\n    w;\n  if (EOFBlob(image) != MagickFalse)\n    {\n      ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n        image->filename);\n      return(MagickFalse);\n    }\n  if (dds_info->ddscaps1 & DDSCAPS_MIPMAP\n      && (dds_info->ddscaps1 & DDSCAPS_TEXTURE\n          || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))\n    {\n      w = DIV2(dds_info->width);\n      h = DIV2(dds_info->height);\n      for (i=1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)\n      {\n        offset = (MagickOffsetType) w * h * pixel_size;\n        (void) SeekBlob(image, offset, SEEK_CUR);\n        w = DIV2(w);\n        h = DIV2(h);\n      }\n    }\n  return(MagickTrue);\n}", "target": 1}
{"code": "static void _ipmi_destroy_user(struct ipmi_user *user)\n{\n\tstruct ipmi_smi  *intf = user->intf;\n\tint              i;\n\tunsigned long    flags;\n\tstruct cmd_rcvr  *rcvr;\n\tstruct cmd_rcvr  *rcvrs = NULL;\n\tif (!acquire_ipmi_user(user, &i)) {\n\t\tsynchronize_srcu(&user->release_barrier);\n\t\treturn;\n\t}\n\trcu_assign_pointer(user->self, NULL);\n\trelease_ipmi_user(user, i);\n\tsynchronize_srcu(&user->release_barrier);\n\tif (user->handler->shutdown)\n\t\tuser->handler->shutdown(user->handler_data);\n\tif (user->handler->ipmi_watchdog_pretimeout)\n\t\tsmi_remove_watch(intf, IPMI_WATCH_MASK_CHECK_WATCHDOG);\n\tif (user->gets_events)\n\t\tatomic_dec(&intf->event_waiters);\n\tspin_lock_irqsave(&intf->seq_lock, flags);\n\tlist_del_rcu(&user->link);\n\tfor (i = 0; i < IPMI_IPMB_NUM_SEQ; i++) {\n\t\tif (intf->seq_table[i].inuse\n\t\t    && (intf->seq_table[i].recv_msg->user == user)) {\n\t\t\tintf->seq_table[i].inuse = 0;\n\t\t\tsmi_remove_watch(intf, IPMI_WATCH_MASK_CHECK_MESSAGES);\n\t\t\tipmi_free_recv_msg(intf->seq_table[i].recv_msg);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&intf->seq_lock, flags);\n\tmutex_lock(&intf->cmd_rcvrs_mutex);\n\tlist_for_each_entry_rcu(rcvr, &intf->cmd_rcvrs, link) {\n\t\tif (rcvr->user == user) {\n\t\t\tlist_del_rcu(&rcvr->link);\n\t\t\trcvr->next = rcvrs;\n\t\t\trcvrs = rcvr;\n\t\t}\n\t}\n\tmutex_unlock(&intf->cmd_rcvrs_mutex);\n\tsynchronize_rcu();\n\twhile (rcvrs) {\n\t\trcvr = rcvrs;\n\t\trcvrs = rcvr->next;\n\t\tkfree(rcvr);\n\t}\n\tkref_put(&intf->refcount, intf_free);\n\tmodule_put(intf->owner);\n}", "target": 0}
{"code": "Status ImportNodes(ValueMapManager value_manager,\n                   const RepeatedPtrField<NodeDef>& nodes, OpBuilder& builder) {\n  Location unknown_loc = builder.getUnknownLoc();\n  MLIRContext* context = builder.getContext();\n  Type placeholder_ty = OpaqueTensorType::get(context);\n  Type control_ty = ControlType::get(context);\n  TFGraphDialect* tfgDialect =\n      cast<TFGraphDialect>(context->getLoadedDialect(\"tfg\"));\n  StringAttr device_attr = tfgDialect->getDeviceAttrIdentifier();\n  StringAttr name_attr = tfgDialect->getNameAttrIdentifier();\n  StringAttr fulltype_attr = tfgDialect->getFullTypeAttrIdentifier();\n  for (const NodeDef& node : nodes) {\n    DVLOG(1) << \"Processing node \" << node.name() << \"\\n\";\n    if (node.op().empty()) return InvalidArgument(\"empty op type\");\n    OperationState state(unknown_loc, absl::StrCat(\"tfg.\", node.op()));\n    for (const std::string& input : node.input())\n      state.operands.push_back(\n          value_manager.GetValueOrCreatePlaceholder(input));\n    state.types.push_back(placeholder_ty);\n    state.types.push_back(control_ty);\n    for (const auto& namedAttr : node.attr()) {\n      const std::string& name = namedAttr.first;\n      const AttrValue& tf_attr = namedAttr.second;\n      TF_ASSIGN_OR_RETURN(Attribute attr,\n                          ConvertAttributeValue(tf_attr, builder, tfgDialect));\n      state.addAttribute(name, attr);\n    }\n    if (!node.device().empty())\n      state.addAttribute(device_attr, StringAttr::get(context, node.device()));\n    if (!node.name().empty())\n      state.addAttribute(name_attr, StringAttr::get(context, node.name()));\n    if (node.has_experimental_type()) {\n      TF_ASSIGN_OR_RETURN(\n          tf_type::FullTypeAttr type,\n          ConvertAttribute(node.experimental_type(), builder, tfgDialect));\n      state.addAttribute(fulltype_attr, type);\n    }\n    Operation* op = builder.create(state);\n    StringRef node_name = node.name();\n    {\n      size_t colon_sep = node_name.find_first_of(':');\n      if (colon_sep != StringRef::npos)\n        node_name = node_name.take_front(colon_sep);\n    }\n    TF_RETURN_IF_ERROR(value_manager.DefineOperation(op, node_name));\n  }\n  for (Operation& op : *builder.getInsertionBlock()) {\n    if (op.getName().getStringRef() == \"tfg.__mlir_placeholder\") {\n      return InvalidArgument(absl::StrCat(\n          \"Couldn't import graph: placeholder left \",\n          op.getAttrOfType<StringAttr>(name_attr).getValue().str()));\n    }\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "struct tcp_sock_t *tcp_open(uint16_t port)\n{\n\tstruct tcp_sock_t *this = calloc(1, sizeof *this);\n\tif (this == NULL) {\n\t\tERR(\"callocing this failed\");\n\t\tgoto error;\n\t}\n\tthis->sd = -1;\n\tthis->sd = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (this->sd < 0) {\n\t\tERR(\"sockect open failed\");\n\t\tgoto error;\n\t}\n\tstruct sockaddr_in6 addr;\n\tmemset(&addr, 0, sizeof addr);\n\taddr.sin6_family = AF_INET6;\n\taddr.sin6_port = htons(port);\n\taddr.sin6_addr = in6addr_any;\n\tif (bind(this->sd,\n\t        (struct sockaddr *)&addr,\n\t        sizeof addr) < 0) {\n\t\tif (g_options.only_desired_port == 1)\n\t\t\tERR(\"Bind on port failed. \"\n\t\t\t    \"Requested port may be taken or require root permissions.\");\n\t\tgoto error;\n\t}\n\tif (listen(this->sd, HTTP_MAX_PENDING_CONNS) < 0) {\n\t\tERR(\"listen failed on socket\");\n\t\tgoto error;\n\t}\n\treturn this;\nerror:\n\tif (this != NULL) {\n\t\tif (this->sd != -1) {\n\t\t\tclose(this->sd);\n\t\t}\n\t\tfree(this);\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "static void prefetch_dec(void)\n{\n  dec_tables.counter_head++;\n  dec_tables.counter_tail++;\n  prefetch_table((const void *)&dec_tables, sizeof(dec_tables));\n}", "target": 0}
{"code": "bool ParseAttrValueHelper_TensorNestsUnderLimit(int limit, string to_parse) {\n  int nests = 0;\n  int maxed_out = to_parse.length();\n  int open_curly = to_parse.find('{');\n  int open_bracket = to_parse.find('<');\n  int close_curly = to_parse.find('}');\n  int close_bracket = to_parse.find('>');\n  if (open_curly == -1) {\n    open_curly = maxed_out;\n  }\n  if (open_bracket == -1) {\n    open_bracket = maxed_out;\n  }\n  int min = std::min(open_curly, open_bracket);\n  do {\n    if (open_curly == maxed_out && open_bracket == maxed_out) {\n      return true;\n    }\n    if (min == open_curly) {\n      nests += 1;\n      open_curly = to_parse.find('{', open_curly + 1);\n      if (open_curly == -1) {\n        open_curly = maxed_out;\n      }\n    } else if (min == open_bracket) {\n      nests += 1;\n      open_bracket = to_parse.find('<', open_bracket + 1);\n      if (open_bracket == -1) {\n        open_bracket = maxed_out;\n      }\n    } else if (min == close_curly) {\n      nests -= 1;\n      close_curly = to_parse.find('}', close_curly + 1);\n      if (close_curly == -1) {\n        close_curly = maxed_out;\n      }\n    } else if (min == close_bracket) {\n      nests -= 1;\n      close_bracket = to_parse.find('>', close_bracket + 1);\n      if (close_bracket == -1) {\n        close_bracket = maxed_out;\n      }\n    }\n    min = std::min({open_curly, open_bracket, close_curly, close_bracket});\n  } while (nests < 100);\n  return false;\n}", "target": 0}
{"code": "static inline int mount_entry_on_systemfs(struct mntent *mntent)\n{\n  return mount_entry_on_generic(mntent, mntent->mnt_dir);\n}", "target": 1}
{"code": "rfbSetClientColourMapBGR233(rfbClientPtr cl)\n{\n    char buf[sz_rfbSetColourMapEntriesMsg + 256 * 3 * 2];\n    rfbSetColourMapEntriesMsg *scme = (rfbSetColourMapEntriesMsg *)buf;\n    uint16_t *rgb = (uint16_t *)(&buf[sz_rfbSetColourMapEntriesMsg]);\n    int i, len;\n    int r, g, b;\n    if (cl->format.bitsPerPixel != 8 ) {\n        rfbErr(\"%s: client not 8 bits per pixel\\n\",\n                \"rfbSetClientColourMapBGR233\");\n        rfbCloseClient(cl);\n        return FALSE;\n    }\n    scme->type = rfbSetColourMapEntries;\n    scme->firstColour = Swap16IfLE(0);\n    scme->nColours = Swap16IfLE(256);\n    len = sz_rfbSetColourMapEntriesMsg;\n    i = 0;\n    for (b = 0; b < 4; b++) {\n        for (g = 0; g < 8; g++) {\n            for (r = 0; r < 8; r++) {\n                rgb[i++] = Swap16IfLE(r * 65535 / 7);\n                rgb[i++] = Swap16IfLE(g * 65535 / 7);\n                rgb[i++] = Swap16IfLE(b * 65535 / 3);\n            }\n        }\n    }\n    len += 256 * 3 * 2;\n    if (rfbWriteExact(cl, buf, len) < 0) {\n        rfbLogPerror(\"rfbSetClientColourMapBGR233: write\");\n        rfbCloseClient(cl);\n        return FALSE;\n    }\n    return TRUE;\n}", "target": 1}
{"code": "Status ShapeRefiner::InferShapesForFunctionSubNode(\n    const Node* node, InferenceContext* outer_context) {\n  TF_RETURN_IF_ERROR(AddNodeInternal(node, outer_context));\n  InferenceContext* node_context = CHECK_NOTNULL(GetContext(node));\n  if (StringPiece(node->type_string()) == kArgOp) {\n    int index;\n    TF_RETURN_IF_ERROR(GetNodeAttr(AttrSlice(node->def()), \"index\", &index));\n    if (index < 0 || outer_context->num_inputs() <= index) {\n      return errors::Internal(\n          \"Function instantiation included invalid input index: \", index,\n          \" not in [0, \", outer_context->num_inputs(), \").\");\n    }\n    if (outer_context->input(index).SameHandle(ShapeHandle())) {\n      VLOG(1) << \"Function instantiation has undefined input shape at \"\n              << \"index: \" << index << \" in the outer inference context.\";\n      node_context->set_output(0, node_context->UnknownShape());\n    } else {\n      node_context->set_output(0, outer_context->input(index));\n    }\n    auto* resource = outer_context->input_handle_shapes_and_types(index);\n    if (resource) {\n      node_context->set_output_handle_shapes_and_types(0, *resource);\n    }\n  } else if (StringPiece(node->type_string()) == kRetvalOp) {\n    int index;\n    TF_RETURN_IF_ERROR(GetNodeAttr(AttrSlice(node->def()), \"index\", &index));\n    if (index < 0 || outer_context->num_outputs() <= index) {\n      return errors::Internal(\n          \"Function instantiation included invalid output index: \", index,\n          \" not in [0, \", outer_context->num_outputs(), \").\");\n    }\n    ShapeHandle handle;\n    TensorShapeProto proto;\n    node_context->ShapeHandleToProto(node_context->input(0), &proto);\n    TF_RETURN_IF_ERROR(outer_context->MakeShapeFromShapeProto(proto, &handle));\n    outer_context->set_output(index, handle);\n    auto* resource = node_context->input_handle_shapes_and_types(0);\n    if (resource) {\n      outer_context->set_output_handle_shapes_and_types(index, *resource);\n    }\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "static int rtnl_bridge_notify(struct net_device *dev)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct sk_buff *skb;\n\tint err = -EOPNOTSUPP;\n\tif (!dev->netdev_ops->ndo_bridge_getlink)\n\t\treturn 0;\n\tskb = nlmsg_new(bridge_nlmsg_size(), GFP_ATOMIC);\n\tif (!skb) {\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\terr = dev->netdev_ops->ndo_bridge_getlink(skb, 0, 0, dev, 0, 0);\n\tif (err < 0)\n\t\tgoto errout;\n\tif (!skb->len)\n\t\tgoto errout;\n\trtnl_notify(skb, net, 0, RTNLGRP_LINK, NULL, GFP_ATOMIC);\n\treturn 0;\nerrout:\n\tWARN_ON(err == -EMSGSIZE);\n\tkfree_skb(skb);\n\tif (err)\n\t\trtnl_set_sk_err(net, RTNLGRP_LINK, err);\n\treturn err;\n}", "target": 0}
{"code": "static int pptp_connect(struct socket *sock, struct sockaddr *uservaddr,\n\tint sockaddr_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_pppox *sp = (struct sockaddr_pppox *) uservaddr;\n\tstruct pppox_sock *po = pppox_sk(sk);\n\tstruct pptp_opt *opt = &po->proto.pptp;\n\tstruct rtable *rt;\n\tstruct flowi4 fl4;\n\tint error = 0;\n\tif (sockaddr_len < sizeof(struct sockaddr_pppox))\n\t\treturn -EINVAL;\n\tif (sp->sa_protocol != PX_PROTO_PPTP)\n\t\treturn -EINVAL;\n\tif (lookup_chan_dst(sp->sa_addr.pptp.call_id, sp->sa_addr.pptp.sin_addr.s_addr))\n\t\treturn -EALREADY;\n\tlock_sock(sk);\n\tif (sk->sk_state & PPPOX_CONNECTED) {\n\t\terror = -EBUSY;\n\t\tgoto end;\n\t}\n\tif (sk->sk_state & PPPOX_DEAD) {\n\t\terror = -EALREADY;\n\t\tgoto end;\n\t}\n\tif (!opt->src_addr.sin_addr.s_addr || !sp->sa_addr.pptp.sin_addr.s_addr) {\n\t\terror = -EINVAL;\n\t\tgoto end;\n\t}\n\tpo->chan.private = sk;\n\tpo->chan.ops = &pptp_chan_ops;\n\trt = ip_route_output_ports(sock_net(sk), &fl4, sk,\n\t\t\t\t   opt->dst_addr.sin_addr.s_addr,\n\t\t\t\t   opt->src_addr.sin_addr.s_addr,\n\t\t\t\t   0, 0,\n\t\t\t\t   IPPROTO_GRE, RT_CONN_FLAGS(sk), 0);\n\tif (IS_ERR(rt)) {\n\t\terror = -EHOSTUNREACH;\n\t\tgoto end;\n\t}\n\tsk_setup_caps(sk, &rt->dst);\n\tpo->chan.mtu = dst_mtu(&rt->dst);\n\tif (!po->chan.mtu)\n\t\tpo->chan.mtu = PPP_MRU;\n\tip_rt_put(rt);\n\tpo->chan.mtu -= PPTP_HEADER_OVERHEAD;\n\tpo->chan.hdrlen = 2 + sizeof(struct pptp_gre_header);\n\terror = ppp_register_channel(&po->chan);\n\tif (error) {\n\t\tpr_err(\"PPTP: failed to register PPP channel (%d)\\n\", error);\n\t\tgoto end;\n\t}\n\topt->dst_addr = sp->sa_addr.pptp;\n\tsk->sk_state = PPPOX_CONNECTED;\n end:\n\trelease_sock(sk);\n\treturn error;\n}", "target": 0}
{"code": "static void dns_callback(void *arg, const struct sockaddr *sa, int salen)\n{\n\tstruct PgSocket *server = arg;\n\tstruct PgDatabase *db = server->pool->db;\n\tstruct sockaddr_in sa_in;\n\tstruct sockaddr_in6 sa_in6;\n\tserver->dns_token = NULL;\n\tif (!sa) {\n\t\tdisconnect_server(server, true, \"server dns lookup failed\");\n\t\treturn;\n\t} else if (sa->sa_family == AF_INET) {\n\t\tchar buf[64];\n\t\tmemcpy(&sa_in, sa, sizeof(sa_in));\n\t\tsa_in.sin_port = htons(db->port);\n\t\tsa = (struct sockaddr *)&sa_in;\n\t\tsalen = sizeof(sa_in);\n\t\tslog_debug(server, \"dns_callback: inet4: %s\",\n\t\t\t   sa2str(sa, buf, sizeof(buf)));\n\t} else if (sa->sa_family == AF_INET6) {\n\t\tchar buf[64];\n\t\tmemcpy(&sa_in6, sa, sizeof(sa_in6));\n\t\tsa_in6.sin6_port = htons(db->port);\n\t\tsa = (struct sockaddr *)&sa_in6;\n\t\tsalen = sizeof(sa_in6);\n\t\tslog_debug(server, \"dns_callback: inet6: %s\",\n\t\t\t   sa2str(sa, buf, sizeof(buf)));\n\t} else {\n\t\tdisconnect_server(server, true, \"unknown address family: %d\", sa->sa_family);\n\t\treturn;\n\t}\n\tconnect_server(server, sa, salen);\n}", "target": 0}
{"code": "static void lsr_read_extend_class(GF_LASeRCodec *lsr, char **out_data, u32 *out_len, const char *name)\n{\n\tu32 len;\n\tGF_LSR_READ_INT(lsr, len, lsr->info->cfg.extensionIDBits, \"reserved\");\n\tlen = lsr_read_vluimsbf5(lsr, \"len\");\n\tgf_bs_read_long_int(lsr->bs, len);\n\tif (out_data) *out_data = NULL;\n\tif (out_len) *out_len = 0;\n}", "target": 1}
{"code": "static void compact(VarEnv* v, Array &ret, const Variant& var) {\n  if (var.isArray()) {\n    for (ArrayIter iter(var.getArrayData()); iter; ++iter) {\n      compact(v, ret, iter.second());\n    }\n  } else {\n    String varname = var.toString();\n    if (!varname.empty() && v->lookup(varname.get()) != NULL) {\n      ret.set(varname, *reinterpret_cast<Variant*>(v->lookup(varname.get())));\n    }\n  }\n}", "target": 1}
{"code": "static void sctp_auto_asconf_init(struct sctp_sock *sp)\n{\n\tstruct net *net = sock_net(&sp->inet.sk);\n\tif (net->sctp.default_auto_asconf) {\n\t\tspin_lock(&net->sctp.addr_wq_lock);\n\t\tlist_add_tail(&sp->auto_asconf_list, &net->sctp.auto_asconf_splist);\n\t\tspin_unlock(&net->sctp.addr_wq_lock);\n\t\tsp->do_auto_asconf = 1;\n\t}\n}", "target": 1}
{"code": "hstore_slice_to_hstore(PG_FUNCTION_ARGS)\n{\n\tHStore\t   *hs = PG_GETARG_HS(0);\n\tHEntry\t   *entries = ARRPTR(hs);\n\tchar\t   *ptr = STRPTR(hs);\n\tArrayType  *key_array = PG_GETARG_ARRAYTYPE_P(1);\n\tHStore\t   *out;\n\tint\t\t\tnkeys;\n\tPairs\t   *key_pairs = hstoreArrayToPairs(key_array, &nkeys);\n\tPairs\t   *out_pairs;\n\tint\t\t\tbufsiz;\n\tint\t\t\tlastidx = 0;\n\tint\t\t\ti;\n\tint\t\t\tout_count = 0;\n\tif (nkeys == 0)\n\t{\n\t\tout = hstorePairs(NULL, 0, 0);\n\t\tPG_RETURN_POINTER(out);\n\t}\n\tout_pairs = palloc(sizeof(Pairs) * nkeys);\n\tbufsiz = 0;\n\tfor (i = 0; i < nkeys; ++i)\n\t{\n\t\tint\t\t\tidx = hstoreFindKey(hs, &lastidx,\n\t\t\t\t\t\t\t\t\t  key_pairs[i].key, key_pairs[i].keylen);\n\t\tif (idx >= 0)\n\t\t{\n\t\t\tout_pairs[out_count].key = key_pairs[i].key;\n\t\t\tbufsiz += (out_pairs[out_count].keylen = key_pairs[i].keylen);\n\t\t\tout_pairs[out_count].val = HS_VAL(entries, ptr, idx);\n\t\t\tbufsiz += (out_pairs[out_count].vallen = HS_VALLEN(entries, idx));\n\t\t\tout_pairs[out_count].isnull = HS_VALISNULL(entries, idx);\n\t\t\tout_pairs[out_count].needfree = false;\n\t\t\t++out_count;\n\t\t}\n\t}\n\tout = hstorePairs(out_pairs, out_count, bufsiz);\n\tPG_RETURN_POINTER(out);\n}", "target": 0}
{"code": "  SPLITS_TYPE RangeSize(T start, T limit, T delta) {\n    if (((delta > 0) && (limit < start)) || ((delta < 0) && (limit > start))) {\n      return 0;\n    }\n    return (std::is_integral<T>::value\n                ? ((std::abs(limit - start) + std::abs(delta) - 1) /\n                   std::abs(delta))\n                : std::ceil(std::abs((limit - start) / delta)));\n  }", "target": 1}
{"code": "static int skcipher_setkey_unaligned(struct crypto_skcipher *tfm,\n\t\t\t\t     const u8 *key, unsigned int keylen)\n{\n\tunsigned long alignmask = crypto_skcipher_alignmask(tfm);\n\tstruct skcipher_alg *cipher = crypto_skcipher_alg(tfm);\n\tu8 *buffer, *alignbuffer;\n\tunsigned long absize;\n\tint ret;\n\tabsize = keylen + alignmask;\n\tbuffer = kmalloc(absize, GFP_ATOMIC);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\talignbuffer = (u8 *)ALIGN((unsigned long)buffer, alignmask + 1);\n\tmemcpy(alignbuffer, key, keylen);\n\tret = cipher->setkey(tfm, alignbuffer, keylen);\n\tkzfree(buffer);\n\treturn ret;\n}", "target": 0}
{"code": "tar_directory_for_file (GsfInfileTar *dir, const char *name, gboolean last)\n{\n\tconst char *s = name;\n\twhile (1) {\n\t\tconst char *s0 = s;\n\t\tchar *dirname;\n\t\twhile (1) {\n\t\t\tif (*s == 0) {\n\t\t\t\tif (last && s != s0)\n\t\t\t\t\tbreak;\n\t\t\t\telse\n\t\t\t\t\treturn dir;\n\t\t\t}\n\t\t\tif (*s == '/')\n\t\t\t\tbreak;\n\t\t\ts++;\n\t\t}\n\t\tdirname = g_strndup (s0, s - s0);\n\t\twhile (*s == '/')\n\t\t\ts++;\n\t\tif (strcmp (dirname, \".\") != 0) {\n\t\t\tGsfInput *subdir =\n\t\t\t\tgsf_infile_child_by_name (GSF_INFILE (dir),\n\t\t\t\t\t\t\t  dirname);\n\t\t\tif (subdir) {\n\t\t\t\tg_object_unref (subdir);\n\t\t\t\tdir = GSF_INFILE_TAR (subdir);\n\t\t\t} else\n\t\t\t\tdir = tar_create_dir (dir, dirname);\n\t\t}\n\t\tg_free (dirname);\n\t}\n}", "target": 1}
{"code": "ZEND_API int ZEND_FASTCALL shift_left_function(zval *result, zval *op1, zval *op2) \n{\n\tzend_long op1_lval, op2_lval;\n\tconvert_op1_op2_long(op1, op1_lval, op2, op2_lval, result, ZEND_SL, shift_left_function);\n\tif (UNEXPECTED((zend_ulong)op2_lval >= SIZEOF_ZEND_LONG * 8)) {\n\t\tif (EXPECTED(op2_lval > 0)) {\n\t\t\tif (op1 == result) {\n\t\t\t\tzval_ptr_dtor(result);\n\t\t\t}\n\t\t\tZVAL_LONG(result, 0);\n\t\t\treturn SUCCESS;\n\t\t} else {\n\t\t\tif (EG(current_execute_data) && !CG(in_compilation)) {\n\t\t\t\tzend_throw_exception_ex(zend_ce_arithmetic_error, 0, \"Bit shift by negative number\");\n\t\t\t} else {\n\t\t\t\tzend_error_noreturn(E_ERROR, \"Bit shift by negative number\");\n\t\t\t}\n\t\t\tif (op1 != result) {\n\t\t\t\tZVAL_UNDEF(result);\n\t\t\t}\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\tif (op1 == result) {\n\t\tzval_ptr_dtor(result);\n\t}\n\tZVAL_LONG(result, (zend_long) ((zend_ulong) op1_lval << op2_lval));\n\treturn SUCCESS;\n}", "target": 0}
{"code": "learn_min_len(uint16_t header)\n{\n    int n_bits = header & NX_LEARN_N_BITS_MASK;\n    int src_type = header & NX_LEARN_SRC_MASK;\n    int dst_type = header & NX_LEARN_DST_MASK;\n    unsigned int min_len;\n    min_len = 0;\n    if (src_type == NX_LEARN_SRC_FIELD) {\n        min_len += sizeof(ovs_be32); \n        min_len += sizeof(ovs_be16); \n    } else {\n        min_len += 2 * DIV_ROUND_UP(n_bits, 16);\n    }\n    if (dst_type == NX_LEARN_DST_MATCH ||\n        dst_type == NX_LEARN_DST_LOAD) {\n        min_len += sizeof(ovs_be32); \n        min_len += sizeof(ovs_be16); \n    }\n    return min_len;\n}", "target": 0}
{"code": "ssh_packet_set_compress_state(struct ssh *ssh, struct sshbuf *m)\n{\n\tstruct session_state *state = ssh->state;\n\tstruct sshbuf *b = NULL;\n\tint r;\n\tconst u_char *inblob, *outblob;\n\tsize_t inl, outl;\n\tif ((r = sshbuf_froms(m, &b)) != 0)\n\t\tgoto out;\n\tif ((r = sshbuf_get_string_direct(b, &inblob, &inl)) != 0 ||\n\t    (r = sshbuf_get_string_direct(b, &outblob, &outl)) != 0)\n\t\tgoto out;\n\tif (inl == 0)\n\t\tstate->compression_in_started = 0;\n\telse if (inl != sizeof(state->compression_in_stream)) {\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t} else {\n\t\tstate->compression_in_started = 1;\n\t\tmemcpy(&state->compression_in_stream, inblob, inl);\n\t}\n\tif (outl == 0)\n\t\tstate->compression_out_started = 0;\n\telse if (outl != sizeof(state->compression_out_stream)) {\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t} else {\n\t\tstate->compression_out_started = 1;\n\t\tmemcpy(&state->compression_out_stream, outblob, outl);\n\t}\n\tr = 0;\n out:\n\tsshbuf_free(b);\n\treturn r;\n}", "target": 1}
{"code": "static int mpeg4video_probe(AVProbeData *probe_packet)\n{\n    uint32_t temp_buffer = -1;\n    int VO = 0, VOL = 0, VOP = 0, VISO = 0, res = 0;\n    int i;\n    for (i = 0; i < probe_packet->buf_size; i++) {\n        temp_buffer = (temp_buffer << 8) + probe_packet->buf[i];\n        if ((temp_buffer & 0xffffff00) != 0x100)\n            continue;\n        if (temp_buffer == VOP_START_CODE)\n            VOP++;\n        else if (temp_buffer == VISUAL_OBJECT_START_CODE)\n            VISO++;\n        else if (temp_buffer < 0x120)\n            VO++;\n        else if (temp_buffer < 0x130)\n            VOL++;\n        else if (!(0x1AF < temp_buffer && temp_buffer < 0x1B7) &&\n                 !(0x1B9 < temp_buffer && temp_buffer < 0x1C4))\n            res++;\n    }\n    if (VOP >= VISO && VOP >= VOL && VO >= VOL && VOL > 0 && res == 0)\n        return AVPROBE_SCORE_EXTENSION;\n    return 0;\n}", "target": 1}
{"code": "static void urlParsePostBody(struct URL *url,\n                             const struct HttpConnection *http,\n                             const char *buf, int len) {\n  struct HashMap contentType;\n  initHashMap(&contentType, urlDestroyHashMapEntry, NULL);\n  const char *ctHeader     = getFromHashMap(&http->header, \"content-type\");\n  urlParseHeaderLine(&contentType, ctHeader, ctHeader ? strlen(ctHeader) : 0);\n  if (getRefFromHashMap(&contentType, \"application/x-www-form-urlencoded\")) {\n    urlParseQueryString(&url->args, buf, len);\n  } else if (getRefFromHashMap(&contentType, \"multipart/form-data\")) {\n    const char *boundary   = getFromHashMap(&contentType, \"boundary\");\n    if (boundary && *boundary) {\n      const char *lastPart = NULL;\n      for (const char *part = buf; len > 0; ) {\n        const char *ptr;\n        if ((part == buf && (ptr = urlMemstr(part, len, \"--\")) != NULL) ||\n            (ptr = urlMemstr(part, len, \"\\r\\n--\")) != NULL) {\n          len             -= ptr - part + (part == buf ? 2 : 4);\n          part             = ptr + (part == buf ? 2 : 4);\n          if (!urlMemcmp(part, len, boundary)) {\n            int i          = strlen(boundary);\n            len           -= i;\n            part          += i;\n            if (!urlMemcmp(part, len, \"\\r\\n\")) {\n              len         -= 2;\n              part        += 2;\n              if (lastPart) {\n                urlParsePart(url, lastPart, ptr - lastPart);\n              } else {\n                if (ptr != buf) {\n                  info(\"[http] Ignoring prologue before \\\"multipart/form-data\\\"!\");\n                }\n              }\n              lastPart     = part;\n            } else if (!urlMemcmp(part, len, \"--\\r\\n\")) {\n              len         -= 4;\n              part        += 4;\n              urlParsePart(url, lastPart, ptr - lastPart);\n              lastPart     = NULL;\n              if (len > 0) {\n                info(\"[http] Ignoring epilogue past end of \\\"multipart/\"\n\t\t\t\t     \"form-data\\\"!\");\n              }\n            }\n          }\n        }\n        else {\n          warn (\"[http] Ignorning broken multipart/form-data\");\n          break;\n        }\n      }\n      if (lastPart) {\n        warn(\"[http] Missing final \\\"boundary\\\" for \\\"multipart/form-data\\\"!\");\n      }\n    } else {\n      warn(\"[http] Missing \\\"boundary\\\" information for \\\"multipart/form-data\\\"!\");\n    }\n  }\n  destroyHashMap(&contentType);\n}", "target": 0}
{"code": "void flush_tlb_mm_range(struct mm_struct *mm, unsigned long start,\n\t\t\t\tunsigned long end, unsigned long vmflag)\n{\n\tunsigned long addr;\n\tunsigned long base_pages_to_flush = TLB_FLUSH_ALL;\n\tpreempt_disable();\n\tif (current->active_mm != mm)\n\t\tgoto out;\n\tif (!current->mm) {\n\t\tleave_mm(smp_processor_id());\n\t\tgoto out;\n\t}\n\tif ((end != TLB_FLUSH_ALL) && !(vmflag & VM_HUGETLB))\n\t\tbase_pages_to_flush = (end - start) >> PAGE_SHIFT;\n\tif (base_pages_to_flush > tlb_single_page_flush_ceiling) {\n\t\tbase_pages_to_flush = TLB_FLUSH_ALL;\n\t\tcount_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ALL);\n\t\tlocal_flush_tlb();\n\t} else {\n\t\tfor (addr = start; addr < end;\taddr += PAGE_SIZE) {\n\t\t\tcount_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ONE);\n\t\t\t__flush_tlb_single(addr);\n\t\t}\n\t}\n\ttrace_tlb_flush(TLB_LOCAL_MM_SHOOTDOWN, base_pages_to_flush);\nout:\n\tif (base_pages_to_flush == TLB_FLUSH_ALL) {\n\t\tstart = 0UL;\n\t\tend = TLB_FLUSH_ALL;\n\t}\n\tif (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) < nr_cpu_ids)\n\t\tflush_tlb_others(mm_cpumask(mm), mm, start, end);\n\tpreempt_enable();\n}", "target": 1}
{"code": "static BOOL ntlm_av_pair_check(NTLM_AV_PAIR* pAvPair, size_t cbAvPair)\n{\n\tif (!pAvPair || cbAvPair < sizeof(NTLM_AV_PAIR))\n\t\treturn FALSE;\n\treturn cbAvPair >= ntlm_av_pair_get_next_offset(pAvPair);\n}", "target": 1}
{"code": "void *Sys_LoadDll( const char *name, qboolean useSystemLib )\n{\n\tvoid *dllhandle = NULL;\n\tif ( COM_CompareExtension( name, \".pk3\" ) )\n\t{\n\t\tCom_Printf( S_COLOR_YELLOW \"WARNING: Rejecting DLL named \\\"%s\\\"\", name );\n\t\treturn NULL;\n\t}\n\tif ( useSystemLib )\n\t{\n\t\tCom_Printf( \"Trying to load \\\"%s\\\"...\\n\", name );\n\t\tdllhandle = Sys_LoadLibrary( name );\n\t\tif ( dllhandle )\n\t\t\treturn dllhandle;\n\t\tCom_Printf( \"%s(%s) failed: \\\"%s\\\"\\n\", __FUNCTION__, name, Sys_LibraryError() );\n\t}\n\tconst char *binarypath = Sys_BinaryPath();\n\tconst char *basepath = Cvar_VariableString( \"fs_basepath\" );\n\tif ( !*binarypath )\n\t\tbinarypath = \".\";\n\tconst char *searchPaths[] = {\n\t\tbinarypath,\n\t\tbasepath,\n\t};\n\tconst size_t numPaths = ARRAY_LEN( searchPaths );\n\tfor ( size_t i = 0; i < numPaths; i++ )\n\t{\n\t\tconst char *libDir = searchPaths[i];\n\t\tif ( !libDir[0] )\n\t\t\tcontinue;\n\t\tCom_Printf( \"Trying to load \\\"%s\\\" from \\\"%s\\\"...\\n\", name, libDir );\n\t\tchar *fn = va( \"%s%c%s\", libDir, PATH_SEP, name );\n\t\tdllhandle = Sys_LoadLibrary( fn );\n\t\tif ( dllhandle )\n\t\t\treturn dllhandle;\n\t\tCom_Printf( \"%s(%s) failed: \\\"%s\\\"\\n\", __FUNCTION__, fn, Sys_LibraryError() );\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "static void huffman_decode_row(x3f_info_t *I, x3f_directory_entry_t *DE,\n                               int bits, int row, int offset, int *minimum)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n  x3f_huffman_t *HUF = ID->huffman;\n  int16_t c[3] = {(int16_t)offset, (int16_t)offset, (int16_t)offset};\n  int col;\n  bit_state_t BS;\n  if (HUF->row_offsets.element[row] > ID->data_size - 1)\n\t  throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  set_bit_state(&BS, (uint8_t *)ID->data + HUF->row_offsets.element[row]);\n  for (col = 0; col < ID->columns; col++)\n  {\n    int color;\n    for (color = 0; color < 3; color++)\n    {\n      uint16_t c_fix;\n      c[color] += get_huffman_diff(&BS, &HUF->tree);\n      if (c[color] < 0)\n      {\n        c_fix = 0;\n        if (c[color] < *minimum)\n          *minimum = c[color];\n      }\n      else\n      {\n        c_fix = c[color];\n      }\n      switch (ID->type_format)\n      {\n      case X3F_IMAGE_RAW_HUFFMAN_X530:\n      case X3F_IMAGE_RAW_HUFFMAN_10BIT:\n        HUF->x3rgb16.data[3 * (row * ID->columns + col) + color] =\n            (uint16_t)c_fix;\n        break;\n      case X3F_IMAGE_THUMB_HUFFMAN:\n        HUF->rgb8.data[3 * (row * ID->columns + col) + color] = (uint8_t)c_fix;\n        break;\n      default:\n        throw LIBRAW_EXCEPTION_IO_CORRUPT;\n      }\n    }\n  }\n}", "target": 0}
{"code": "static void wipe_keys()\n{\n\tmemset(cmac_key, 0, sizeof(cmac_key));\n\tmemset(cipher_key, 0, sizeof(cipher_key));\n\tmemset(iv, 0, sizeof(iv));\n}", "target": 0}
{"code": "static void outbound_phy_packet_callback(struct fw_packet *packet,\n\t\t\t\t\t struct fw_card *card, int status)\n{\n\tstruct outbound_phy_packet_event *e =\n\t\tcontainer_of(packet, struct outbound_phy_packet_event, p);\n\tswitch (status) {\n\tcase ACK_COMPLETE:\te->phy_packet.rcode = RCODE_COMPLETE;\tbreak;\n\tcase ACK_PENDING:\te->phy_packet.rcode = RCODE_COMPLETE;\tbreak;\n\tcase ACK_BUSY_X:\n\tcase ACK_BUSY_A:\n\tcase ACK_BUSY_B:\te->phy_packet.rcode = RCODE_BUSY;\tbreak;\n\tcase ACK_DATA_ERROR:\te->phy_packet.rcode = RCODE_DATA_ERROR;\tbreak;\n\tcase ACK_TYPE_ERROR:\te->phy_packet.rcode = RCODE_TYPE_ERROR;\tbreak;\n\tdefault:\t\te->phy_packet.rcode = status;\t\tbreak;\n\t}\n\te->phy_packet.data[0] = packet->timestamp;\n\tqueue_event(e->client, &e->event, &e->phy_packet,\n\t\t    sizeof(e->phy_packet) + e->phy_packet.length, NULL, 0);\n\tclient_put(e->client);\n}", "target": 1}
{"code": "AP_DECLARE(request_rec *) ap_create_request(conn_rec *conn)\n{\n    request_rec *r;\n    apr_pool_t *p;\n    apr_pool_create(&p, conn->pool);\n    apr_pool_tag(p, \"request\");\n    r = apr_pcalloc(p, sizeof(request_rec));\n    AP_READ_REQUEST_ENTRY((intptr_t)r, (uintptr_t)conn);\n    r->pool            = p;\n    r->connection      = conn;\n    r->server          = conn->base_server;\n    r->user            = NULL;\n    r->ap_auth_type    = NULL;\n    r->allowed_methods = ap_make_method_list(p, 2);\n    r->headers_in      = apr_table_make(r->pool, 25);\n    r->trailers_in     = apr_table_make(r->pool, 5);\n    r->subprocess_env  = apr_table_make(r->pool, 25);\n    r->headers_out     = apr_table_make(r->pool, 12);\n    r->err_headers_out = apr_table_make(r->pool, 5);\n    r->trailers_out    = apr_table_make(r->pool, 5);\n    r->notes           = apr_table_make(r->pool, 5);\n    r->request_config  = ap_create_request_config(r->pool);\n    r->proto_output_filters = conn->output_filters;\n    r->output_filters  = r->proto_output_filters;\n    r->proto_input_filters = conn->input_filters;\n    r->input_filters   = r->proto_input_filters;\n    ap_run_create_request(r);\n    r->per_dir_config  = r->server->lookup_defaults;\n    r->sent_bodyct     = 0;                      \n    r->read_length     = 0;\n    r->read_body       = REQUEST_NO_BODY;\n    r->status          = HTTP_OK;  \n    r->header_only     = 0;\n    r->the_request     = NULL;\n    r->used_path_info = AP_REQ_DEFAULT_PATH_INFO;\n    r->useragent_addr = conn->client_addr;\n    r->useragent_ip = conn->client_ip;\n    return r;\n}", "target": 0}
{"code": "void __init kvmclock_init(void)\n{\n\tif (!kvm_para_available())\n\t\treturn;\n\tif (kvmclock && kvm_para_has_feature(KVM_FEATURE_CLOCKSOURCE2)) {\n\t\tmsr_kvm_system_time = MSR_KVM_SYSTEM_TIME_NEW;\n\t\tmsr_kvm_wall_clock = MSR_KVM_WALL_CLOCK_NEW;\n\t} else if (!(kvmclock && kvm_para_has_feature(KVM_FEATURE_CLOCKSOURCE)))\n\t\treturn;\n\tprintk(KERN_INFO \"kvm-clock: Using msrs %x and %x\",\n\t\tmsr_kvm_system_time, msr_kvm_wall_clock);\n\tif (kvm_register_clock(\"boot clock\"))\n\t\treturn;\n\tpv_time_ops.sched_clock = kvm_clock_read;\n\tx86_platform.calibrate_tsc = kvm_get_tsc_khz;\n\tx86_platform.get_wallclock = kvm_get_wallclock;\n\tx86_platform.set_wallclock = kvm_set_wallclock;\n#ifdef CONFIG_X86_LOCAL_APIC\n\tx86_cpuinit.setup_percpu_clockev =\n\t\tkvm_setup_secondary_clock;\n#endif\n\tmachine_ops.shutdown  = kvm_shutdown;\n#ifdef CONFIG_KEXEC\n\tmachine_ops.crash_shutdown  = kvm_crash_shutdown;\n#endif\n\tkvm_get_preset_lpj();\n\tclocksource_register_hz(&kvm_clock, NSEC_PER_SEC);\n\tpv_info.paravirt_enabled = 1;\n\tpv_info.name = \"KVM\";\n\tif (kvm_para_has_feature(KVM_FEATURE_CLOCKSOURCE_STABLE_BIT))\n\t\tpvclock_set_flags(PVCLOCK_TSC_STABLE_BIT);\n}", "target": 0}
{"code": "static u32 apic_get_tmcct(struct kvm_lapic *apic)\n{\n\tktime_t remaining;\n\ts64 ns;\n\tu32 tmcct;\n\tASSERT(apic != NULL);\n\tif (kvm_apic_get_reg(apic, APIC_TMICT) == 0)\n\t\treturn 0;\n\tremaining = hrtimer_get_remaining(&apic->lapic_timer.timer);\n\tif (ktime_to_ns(remaining) < 0)\n\t\tremaining = ktime_set(0, 0);\n\tns = mod_64(ktime_to_ns(remaining), apic->lapic_timer.period);\n\ttmcct = div64_u64(ns,\n\t\t\t (APIC_BUS_CYCLE_NS * apic->divide_count));\n\treturn tmcct;\n}", "target": 1}
{"code": "call_handler (SoupMessage *req, SoupClientContext *client)\n{\n\tSoupServer *server = client->server;\n\tSoupServerHandler *hand;\n\tSoupURI *uri;\n\tg_signal_emit (server, signals[REQUEST_READ], 0, req, client);\n\tif (req->status_code != 0)\n\t\treturn;\n\turi = soup_message_get_uri (req);\n\thand = soup_server_get_handler (server, uri->path);\n\tif (!hand) {\n\t\tsoup_message_set_status (req, SOUP_STATUS_NOT_FOUND);\n\t\treturn;\n\t}\n\tif (hand->callback) {\n\t\tGHashTable *form_data_set;\n\t\tif (uri->query)\n\t\t\tform_data_set = soup_form_decode (uri->query);\n\t\telse\n\t\t\tform_data_set = NULL;\n\t\t(*hand->callback) (server, req,\n\t\t\t\t   uri->path, form_data_set,\n\t\t\t\t   client, hand->user_data);\n\t\tif (form_data_set)\n\t\t\tg_hash_table_destroy (form_data_set);\n\t}\n}", "target": 0}
{"code": "void TestGatherNd(int* param_dims, const ParamType* param_data, int* index_dims,\n                  const IndexType* index_data, int* output_dims,\n                  ParamType* output_data,\n                  const ParamType* expected_output_data) {\n  TfLiteIntArray* pdims = IntArrayFromInts(param_dims);\n  TfLiteIntArray* idims = IntArrayFromInts(index_dims);\n  TfLiteIntArray* odims = IntArrayFromInts(output_dims);\n  constexpr int inputs_size = 2;\n  constexpr int outputs_size = 1;\n  constexpr int tensors_size = inputs_size + outputs_size;\n  TfLiteTensor tensors[tensors_size] = {\n      CreateTensor(param_data, pdims),\n      CreateTensor(index_data, idims),\n      CreateTensor(output_data, odims),\n  };\n  int inputs_array_data[] = {2, 0, 1};\n  TfLiteIntArray* inputs_array = IntArrayFromInts(inputs_array_data);\n  int outputs_array_data[] = {1, 2};\n  TfLiteIntArray* outputs_array = IntArrayFromInts(outputs_array_data);\n  const TfLiteRegistration registration = Register_GATHER_ND();\n  micro::KernelRunner runner(registration, tensors, tensors_size, inputs_array,\n                             outputs_array, nullptr);\n  TF_LITE_MICRO_EXPECT_EQ(kTfLiteOk, runner.InitAndPrepare());\n  TF_LITE_MICRO_EXPECT_EQ(kTfLiteOk, runner.Invoke());\n  TfLiteTensor* actual_output_tensor = &tensors[2];\n  TfLiteIntArray* actual_output_dims = actual_output_tensor->dims;\n  const int output_size = ElementCount(*actual_output_dims);\n  for (int i = 0; i < output_size; ++i) {\n    TF_LITE_MICRO_EXPECT_EQ(expected_output_data[i], output_data[i]);\n  }\n}", "target": 1}
{"code": "ReadReason(rfbClient* client)\n{\n    uint32_t reasonLen;\n    char *reason;\n    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;\n    reasonLen = rfbClientSwap32IfLE(reasonLen);\n    reason = malloc((uint64_t)reasonLen+1);\n    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }\n    reason[reasonLen]=0;\n    rfbClientLog(\"VNC connection failed: %s\\n\",reason);\n    free(reason);\n}", "target": 1}
{"code": "static int _gdImageWBMPCtx(gdImagePtr image, int fg, gdIOCtx *out)\n{\n\tint x, y, pos;\n\tWbmp *wbmp;\n\tif((wbmp = createwbmp(gdImageSX(image), gdImageSY(image), WBMP_WHITE)) == NULL) {\n\t\tgd_error(\"Could not create WBMP\\n\");\n\t\treturn 1;\n\t}\n\tpos = 0;\n\tfor(y = 0; y < gdImageSY(image); y++) {\n\t\tfor(x = 0; x < gdImageSX(image); x++) {\n\t\t\tif(gdImageGetPixel(image, x, y) == fg) {\n\t\t\t\twbmp->bitmap[pos] = WBMP_BLACK;\n\t\t\t}\n\t\t\tpos++;\n\t\t}\n\t}\n\tif(writewbmp(wbmp, &gd_putout, out)) {\n\t\tfreewbmp(wbmp);\n\t\tgd_error(\"Could not save WBMP\\n\");\n\t\treturn 1;\n\t}\n\tfreewbmp(wbmp);\n\treturn 0;\n}", "target": 0}
{"code": "test_compressed_stream_overflow (xd3_stream *stream, int ignore)\n{\n  int ret;\n  int i;\n  uint8_t *buf;\n  if ((buf = (uint8_t*) malloc (TWO_MEGS_AND_DELTA)) == NULL) { return ENOMEM; }\n  memset (buf, 0, TWO_MEGS_AND_DELTA);\n  for (i = 0; i < (2 << 20); i += 256) \n    {\n      int j;\n      int off = mt_random(& static_mtrand) % 10;\n      for (j = 0; j < 256; j++) \n\t{\n\t  buf[i + j] = j + off;\n\t}\n    }\n  if (SIZEOF_XOFF_T == 4)\n    {\n      ret = test_streaming (stream, buf, buf + (1 << 20), buf + (2 << 20), (1 << 12) + 1);\n      if (ret == XD3_INVALID_INPUT && MSG_IS (\"decoder file offset overflow\"))\n\t{\n\t  ret = 0;\n\t}\n      else\n\t{\n          XPR(NT XD3_LIB_ERRMSG (stream, ret));\n\t  stream->msg = \"expected overflow condition\";\n\t  ret = XD3_INTERNAL;\n\t  goto fail;\n\t}\n    }\n  if ((ret = test_streaming (stream, \n\t\t\t     buf, \n\t\t\t     buf + (1 << 20), \n\t\t\t     buf + (2 << 20), \n\t\t\t     1 << 12))) \n    {\n      goto fail;\n    }\n fail:\n  free (buf);\n  return ret;\n}", "target": 1}
{"code": "static void create_layer_surface(struct swaylock_surface *surface) {\n\tstruct swaylock_state *state = surface->state;\n\tsurface->image = select_image(state, surface);\n\tsurface->surface = wl_compositor_create_surface(state->compositor);\n\tassert(surface->surface);\n\tsurface->child = wl_compositor_create_surface(state->compositor);\n\tassert(surface->child);\n\tsurface->subsurface = wl_subcompositor_get_subsurface(state->subcompositor, surface->child, surface->surface);\n\tassert(surface->subsurface);\n\twl_subsurface_set_sync(surface->subsurface);\n\tsurface->layer_surface = zwlr_layer_shell_v1_get_layer_surface(\n\t\t\tstate->layer_shell, surface->surface, surface->output,\n\t\t\tZWLR_LAYER_SHELL_V1_LAYER_OVERLAY, \"lockscreen\");\n\tassert(surface->layer_surface);\n\tzwlr_layer_surface_v1_set_size(surface->layer_surface, 0, 0);\n\tzwlr_layer_surface_v1_set_anchor(surface->layer_surface,\n\t\t\tZWLR_LAYER_SURFACE_V1_ANCHOR_TOP |\n\t\t\tZWLR_LAYER_SURFACE_V1_ANCHOR_RIGHT |\n\t\t\tZWLR_LAYER_SURFACE_V1_ANCHOR_BOTTOM |\n\t\t\tZWLR_LAYER_SURFACE_V1_ANCHOR_LEFT);\n\tzwlr_layer_surface_v1_set_exclusive_zone(surface->layer_surface, -1);\n\tzwlr_layer_surface_v1_set_keyboard_interactivity(\n\t\t\tsurface->layer_surface, true);\n\tzwlr_layer_surface_v1_add_listener(surface->layer_surface,\n\t\t\t&layer_surface_listener, surface);\n\tif (surface_is_opaque(surface) &&\n\t\t\tsurface->state->args.mode != BACKGROUND_MODE_CENTER &&\n\t\t\tsurface->state->args.mode != BACKGROUND_MODE_FIT) {\n\t\tstruct wl_region *region =\n\t\t\twl_compositor_create_region(surface->state->compositor);\n\t\twl_region_add(region, 0, 0, INT32_MAX, INT32_MAX);\n\t\twl_surface_set_opaque_region(surface->surface, region);\n\t\twl_region_destroy(region);\n\t}\n\twl_surface_commit(surface->surface);\n}", "target": 1}
{"code": "char* parse_content_length( char* buffer, char* end, int* length)\n{\n\tint number;\n\tchar *p;\n\tint  size;\n\tp = buffer;\n\twhile ( p<end && (*p==' ' || *p=='\\t' || (*p=='\\r' && *(p+1)=='\\n') ||\n\t(*p=='\\n' && (*(p+1)==' '||*(p+1)=='\\t')) ))\n\t\tp++;\n\tif (p==end)\n\t\tgoto error;\n\tsize = 0;\n\tnumber = 0;\n\twhile (p<end && *p>='0' && *p<='9') {\n\t\tnumber = number*10 + (*p)-'0';\n\t\tif (number<0) {\n\t\t\tLM_ERR(\"number overflow at pos %d in len number [%.*s]\\n\",\n\t\t\t\t(int)(p-buffer),(int)(end-buffer), buffer);\n\t\t\treturn 0;\n\t\t}\n\t\tsize ++;\n\t\tp++;\n\t}\n\tif (p==end || size==0)\n\t\tgoto error;\n\twhile ( p<end && (*p==' ' || *p=='\\t' ||\n\t(*p=='\\n' && (*(p+1)==' '||*(p+1)=='\\t')) ))\n\t\tp++;\n\tif (p==end)\n\t\tgoto error;\n\tif ( (*(p++)!='\\n') && (*(p-1)!='\\r' || *(p++)!='\\n' ) )\n\t\tgoto error;\n\t*length = number;\n\treturn p;\nerror:\n\tLM_ERR(\"parse error near char [%d][%c]\\n\",*p,*p);\n\treturn 0;\n}", "target": 1}
{"code": "static int mxf_read_index_entry_array(AVIOContext *pb, MXFIndexTableSegment *segment)\n{\n    int i, length;\n    segment->nb_index_entries = avio_rb32(pb);\n    length = avio_rb32(pb);\n    if(segment->nb_index_entries && length < 11)\n        return AVERROR_INVALIDDATA;\n    if (!(segment->temporal_offset_entries=av_calloc(segment->nb_index_entries, sizeof(*segment->temporal_offset_entries))) ||\n        !(segment->flag_entries          = av_calloc(segment->nb_index_entries, sizeof(*segment->flag_entries))) ||\n        !(segment->stream_offset_entries = av_calloc(segment->nb_index_entries, sizeof(*segment->stream_offset_entries))))\n        return AVERROR(ENOMEM);\n    for (i = 0; i < segment->nb_index_entries; i++) {\n        if(avio_feof(pb))\n            return AVERROR_INVALIDDATA;\n        segment->temporal_offset_entries[i] = avio_r8(pb);\n        avio_r8(pb);                                        \n        segment->flag_entries[i] = avio_r8(pb);\n        segment->stream_offset_entries[i] = avio_rb64(pb);\n        avio_skip(pb, length - 11);\n    }\n    return 0;\n}", "target": 0}
{"code": "int blk_rq_map_user_iov(struct request_queue *q, struct request *rq,\n\t\t\tstruct rq_map_data *map_data,\n\t\t\tconst struct iov_iter *iter, gfp_t gfp_mask)\n{\n\tbool copy = false;\n\tunsigned long align = q->dma_pad_mask | queue_dma_alignment(q);\n\tstruct bio *bio = NULL;\n\tstruct iov_iter i;\n\tint ret;\n\tif (!iter_is_iovec(iter))\n\t\tgoto fail;\n\tif (map_data)\n\t\tcopy = true;\n\telse if (iov_iter_alignment(iter) & align)\n\t\tcopy = true;\n\telse if (queue_virt_boundary(q))\n\t\tcopy = queue_virt_boundary(q) & iov_iter_gap_alignment(iter);\n\ti = *iter;\n\tdo {\n\t\tret =__blk_rq_map_user_iov(rq, map_data, &i, gfp_mask, copy);\n\t\tif (ret)\n\t\t\tgoto unmap_rq;\n\t\tif (!bio)\n\t\t\tbio = rq->bio;\n\t} while (iov_iter_count(&i));\n\tif (!bio_flagged(bio, BIO_USER_MAPPED))\n\t\trq->cmd_flags |= REQ_COPY_USER;\n\treturn 0;\nunmap_rq:\n\t__blk_rq_unmap_user(bio);\nfail:\n\trq->bio = NULL;\n\treturn -EINVAL;\n}", "target": 0}
{"code": "static void key_gc_timer_func(unsigned long data)\n{\n\tkenter(\"\");\n\tkey_gc_next_run = LONG_MAX;\n\tkey_schedule_gc_links();\n}", "target": 0}
{"code": "void Server::CheckDocRoot() {\n  try {\n    if (!fs::exists(doc_root_) || !fs::is_directory(doc_root_)) {\n      LOG_ERRO(\"Doc root is not an existing directory!\");\n      return;\n    }\n    if (doc_root_.is_relative()) {\n      doc_root_ = fs::absolute(doc_root_);\n    }\n    doc_root_ = fs::canonical(doc_root_);\n  } catch (fs::filesystem_error& e) {\n    LOG_ERRO(\"Doc root error: %s\", e.what());\n    doc_root_.clear();\n  }\n  LOG_INFO(\"Doc root: %s\", doc_root_.u8string().c_str());\n}", "target": 0}
{"code": "static char *dex_resolve_library(const char *library) {\n\tif (!library || library[0] != 'L') {\n\t\treturn NULL;\n\t}\n\tchar *demangled = strdup(library + 1);\n\trz_str_replace_ch(demangled, '/', '.', 1);\n\tdemangled[strlen(demangled) - 1] = 0;\n\treturn demangled;\n}", "target": 1}
{"code": "static int do_sched_cfs_period_timer(struct cfs_bandwidth *cfs_b, int overrun, unsigned long flags)\n{\n\tu64 runtime, runtime_expires;\n\tint throttled;\n\tif (cfs_b->quota == RUNTIME_INF)\n\t\tgoto out_deactivate;\n\tthrottled = !list_empty(&cfs_b->throttled_cfs_rq);\n\tcfs_b->nr_periods += overrun;\n\tif (cfs_b->idle && !throttled)\n\t\tgoto out_deactivate;\n\t__refill_cfs_bandwidth_runtime(cfs_b);\n\tif (!throttled) {\n\t\tcfs_b->idle = 1;\n\t\treturn 0;\n\t}\n\tcfs_b->nr_throttled += overrun;\n\truntime_expires = cfs_b->runtime_expires;\n\twhile (throttled && cfs_b->runtime > 0 && !cfs_b->distribute_running) {\n\t\truntime = cfs_b->runtime;\n\t\tcfs_b->distribute_running = 1;\n\t\traw_spin_unlock_irqrestore(&cfs_b->lock, flags);\n\t\truntime = distribute_cfs_runtime(cfs_b, runtime,\n\t\t\t\t\t\t runtime_expires);\n\t\traw_spin_lock_irqsave(&cfs_b->lock, flags);\n\t\tcfs_b->distribute_running = 0;\n\t\tthrottled = !list_empty(&cfs_b->throttled_cfs_rq);\n\t\tlsub_positive(&cfs_b->runtime, runtime);\n\t}\n\tcfs_b->idle = 0;\n\treturn 0;\nout_deactivate:\n\treturn 1;\n}", "target": 1}
{"code": "client_data cql_server::connection::make_client_data() const {\n    client_data cd;\n    std::tie(cd.ip, cd.port, cd.ct) = make_client_key(_client_state);\n    cd.shard_id = this_shard_id();\n    cd.protocol_version = _version;\n    cd.driver_name = _client_state.get_driver_name();\n    cd.driver_version = _client_state.get_driver_version();\n    if (const auto user_ptr = _client_state.user(); user_ptr) {\n        cd.username = user_ptr->name;\n    }\n    if (_ready) {\n        cd.connection_stage = client_connection_stage::ready;\n    } else if (_authenticating) {\n        cd.connection_stage = client_connection_stage::authenticating;\n    }\n    return cd;\n}", "target": 0}
{"code": "static void vgacon_restore_screen(struct vc_data *c)\n{\n\tc->vc_origin = c->vc_visible_origin;\n\tvgacon_scrollback_cur->save = 0;\n\tif (!vga_is_gfx && !vgacon_scrollback_cur->restore) {\n\t\tscr_memcpyw((u16 *) c->vc_origin, (u16 *) c->vc_screenbuf,\n\t\t\t    c->vc_screenbuf_size > vga_vram_size ?\n\t\t\t    vga_vram_size : c->vc_screenbuf_size);\n\t\tvgacon_scrollback_cur->restore = 1;\n\t\tvgacon_scrollback_cur->cur = vgacon_scrollback_cur->cnt;\n\t}\n}", "target": 1}
{"code": "node_new(void)\n{\n  Node* node;\n  node = (Node* )xmalloc(sizeof(Node));\n  xmemset(node, 0, sizeof(*node));\n#ifdef DEBUG_NODE_FREE\n  fprintf(stderr, \"node_new: %p\\n\", node);\n#endif\n  return node;\n}", "target": 0}
{"code": "bool test_r_str_escape_sh(void) {\n\tchar *escaped = r_str_escape_sh (\"Hello, \\\"World\\\"\");\n\tmu_assert_streq (escaped, \"Hello, \\\\\\\"World\\\\\\\"\", \"escaped \\\"double quotes\\\"\");\n\tfree (escaped);\n\tescaped = r_str_escape_sh (\"Hello, \\\\World\\\\\");\n\tmu_assert_streq (escaped, \"Hello, \\\\\\\\World\\\\\\\\\", \"escaped backspace\");\n\tfree (escaped);\n#if __UNIX__\n\tescaped = r_str_escape_sh (\"Hello, $(World)\");\n\tmu_assert_streq (escaped, \"Hello, \\\\$(World)\", \"escaped $(command)\");\n\tfree (escaped);\n\tescaped = r_str_escape_sh (\"Hello, `World`\");\n\tmu_assert_streq (escaped, \"Hello, \\\\`World\\\\`\", \"escaped `command`\");\n\tfree (escaped);\n#endif\n\tmu_end;\n}", "target": 0}
{"code": "static void m_stop(struct seq_file *m, void *v)\n{\n\tstruct proc_maps_private *priv = m->private;\n\tstruct vm_area_struct *vma = v;\n\tvma_stop(priv, vma);\n\tif (priv->task)\n\t\tput_task_struct(priv->task);\n}", "target": 1}
{"code": "void altivec_unavailable_exception(struct pt_regs *regs)\n{\n#if !defined(CONFIG_ALTIVEC)\n\tif (user_mode(regs)) {\n\t\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n\t\treturn;\n\t}\n#endif\n\tprintk(KERN_EMERG \"Unrecoverable VMX/Altivec Unavailable Exception \"\n\t\t\t\"%lx at %lx\\n\", regs->trap, regs->nip);\n\tdie(\"Unrecoverable VMX/Altivec Unavailable Exception\", regs, SIGABRT);\n}", "target": 1}
{"code": "int lstat_cache_aware_rmdir(const char *path)\n{\n\tint ret = rmdir(path);\n\tif (!ret)\n\t\tinvalidate_lstat_cache();\n\treturn ret;\n}", "target": 0}
{"code": "makepol(QPRS_STATE *state)\n{\n\tint32\t\tval = 0,\n\t\t\t\ttype;\n\tint32\t\tlenval = 0;\n\tchar\t   *strval = NULL;\n\tint32\t\tstack[STACKDEPTH];\n\tint32\t\tlenstack = 0;\n\tuint16\t\tflag = 0;\n\tcheck_stack_depth();\n\twhile ((type = gettoken_query(state, &val, &lenval, &strval, &flag)) != END)\n\t{\n\t\tswitch (type)\n\t\t{\n\t\t\tcase VAL:\n\t\t\t\tpushval_asis(state, VAL, strval, lenval, flag);\n\t\t\t\twhile (lenstack && (stack[lenstack - 1] == (int32) '&' ||\n\t\t\t\t\t\t\t\t\tstack[lenstack - 1] == (int32) '!'))\n\t\t\t\t{\n\t\t\t\t\tlenstack--;\n\t\t\t\t\tpushquery(state, OPR, stack[lenstack], 0, 0, 0);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase OPR:\n\t\t\t\tif (lenstack && val == (int32) '|')\n\t\t\t\t\tpushquery(state, OPR, val, 0, 0, 0);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (lenstack == STACKDEPTH)\n\t\t\t\t\t\telog(ERROR, \"stack too short\");\n\t\t\t\t\tstack[lenstack] = val;\n\t\t\t\t\tlenstack++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase OPEN:\n\t\t\t\tif (makepol(state) == ERR)\n\t\t\t\t\treturn ERR;\n\t\t\t\twhile (lenstack && (stack[lenstack - 1] == (int32) '&' ||\n\t\t\t\t\t\t\t\t\tstack[lenstack - 1] == (int32) '!'))\n\t\t\t\t{\n\t\t\t\t\tlenstack--;\n\t\t\t\t\tpushquery(state, OPR, stack[lenstack], 0, 0, 0);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CLOSE:\n\t\t\t\twhile (lenstack)\n\t\t\t\t{\n\t\t\t\t\tlenstack--;\n\t\t\t\t\tpushquery(state, OPR, stack[lenstack], 0, 0, 0);\n\t\t\t\t};\n\t\t\t\treturn END;\n\t\t\t\tbreak;\n\t\t\tcase ERR:\n\t\t\tdefault:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"syntax error\")));\n\t\t\t\treturn ERR;\n\t\t}\n\t}\n\twhile (lenstack)\n\t{\n\t\tlenstack--;\n\t\tpushquery(state, OPR, stack[lenstack], 0, 0, 0);\n\t};\n\treturn END;\n}", "target": 0}
{"code": "getFileTypeNoFollowSymlinks(const StaticString &filename) {\n\tstruct stat buf;\n\tint ret;\n\tret = lstat(filename.c_str(), &buf);\n\tif (ret == 0) {\n\t\tif (S_ISREG(buf.st_mode)) {\n\t\t\treturn FT_REGULAR;\n\t\t} else if (S_ISDIR(buf.st_mode)) {\n\t\t\treturn FT_DIRECTORY;\n\t\t} else if (S_ISLNK(buf.st_mode)) {\n\t\t\treturn FT_SYMLINK;\n\t\t} else {\n\t\t\treturn FT_OTHER;\n\t\t}\n\t} else {\n\t\tif (errno == ENOENT) {\n\t\t\treturn FT_NONEXISTANT;\n\t\t} else {\n\t\t\tint e = errno;\n\t\t\tstring message(\"Cannot lstat '\");\n\t\t\tmessage.append(filename);\n\t\t\tmessage.append(\"'\");\n\t\t\tthrow FileSystemException(message, e, filename);\n\t\t}\n\t}\n}", "target": 1}
{"code": "\t__releases(proto_list_mutex)\n{\n\tmutex_unlock(&proto_list_mutex);\n}", "target": 0}
{"code": "av_cold void ff_vc2enc_free_transforms(VC2TransformContext *s)\n{\n    av_freep(&s->buffer);\n}", "target": 1}
{"code": "nvkm_vmm_unmap_region(struct nvkm_vmm *vmm, struct nvkm_vma *vma)\n{\n\tstruct nvkm_vma *next;\n\tnvkm_memory_tags_put(vma->memory, vmm->mmu->subdev.device, &vma->tags);\n\tnvkm_memory_unref(&vma->memory);\n\tif (vma->part) {\n\t\tstruct nvkm_vma *prev = node(vma, prev);\n\t\tif (!prev->memory) {\n\t\t\tprev->size += vma->size;\n\t\t\trb_erase(&vma->tree, &vmm->root);\n\t\t\tlist_del(&vma->head);\n\t\t\tkfree(vma);\n\t\t\tvma = prev;\n\t\t}\n\t}\n\tnext = node(vma, next);\n\tif (next && next->part) {\n\t\tif (!next->memory) {\n\t\t\tvma->size += next->size;\n\t\t\trb_erase(&next->tree, &vmm->root);\n\t\t\tlist_del(&next->head);\n\t\t\tkfree(next);\n\t\t}\n\t}\n}", "target": 1}
{"code": "struct mb2_cache *mb2_cache_create(int bucket_bits)\n{\n\tstruct mb2_cache *cache;\n\tint bucket_count = 1 << bucket_bits;\n\tint i;\n\tif (!try_module_get(THIS_MODULE))\n\t\treturn NULL;\n\tcache = kzalloc(sizeof(struct mb2_cache), GFP_KERNEL);\n\tif (!cache)\n\t\tgoto err_out;\n\tcache->c_bucket_bits = bucket_bits;\n\tINIT_LIST_HEAD(&cache->c_lru_list);\n\tspin_lock_init(&cache->c_lru_list_lock);\n\tcache->c_hash = kmalloc(bucket_count * sizeof(struct hlist_bl_head),\n\t\t\t\tGFP_KERNEL);\n\tif (!cache->c_hash) {\n\t\tkfree(cache);\n\t\tgoto err_out;\n\t}\n\tfor (i = 0; i < bucket_count; i++)\n\t\tINIT_HLIST_BL_HEAD(&cache->c_hash[i]);\n\tcache->c_shrink.count_objects = mb2_cache_count;\n\tcache->c_shrink.scan_objects = mb2_cache_scan;\n\tcache->c_shrink.seeks = DEFAULT_SEEKS;\n\tregister_shrinker(&cache->c_shrink);\n\treturn cache;\nerr_out:\n\tmodule_put(THIS_MODULE);\n\treturn NULL;\n}", "target": 0}
{"code": "bbuf_clone(BBuf** rto, BBuf* from)\n{\n  int r;\n  BBuf *to;\n  *rto = to = (BBuf* )xmalloc(sizeof(BBuf));\n  CHECK_NULL_RETURN_MEMERR(to);\n  r = BB_INIT(to, from->alloc);\n  if (r != 0) {\n    xfree(to->p);\n    *rto = 0;\n    return r;\n  }\n  to->used = from->used;\n  xmemcpy(to->p, from->p, from->used);\n  return 0;\n}", "target": 0}
{"code": "int ecryptfs_privileged_open(struct file **lower_file,\n\t\t\t     struct dentry *lower_dentry,\n\t\t\t     struct vfsmount *lower_mnt,\n\t\t\t     const struct cred *cred)\n{\n\tstruct ecryptfs_open_req req;\n\tint flags = O_LARGEFILE;\n\tint rc = 0;\n\tinit_completion(&req.done);\n\treq.lower_file = lower_file;\n\treq.path.dentry = lower_dentry;\n\treq.path.mnt = lower_mnt;\n\tflags |= IS_RDONLY(d_inode(lower_dentry)) ? O_RDONLY : O_RDWR;\n\t(*lower_file) = dentry_open(&req.path, flags, cred);\n\tif (!IS_ERR(*lower_file))\n\t\tgoto out;\n\tif ((flags & O_ACCMODE) == O_RDONLY) {\n\t\trc = PTR_ERR((*lower_file));\n\t\tgoto out;\n\t}\n\tmutex_lock(&ecryptfs_kthread_ctl.mux);\n\tif (ecryptfs_kthread_ctl.flags & ECRYPTFS_KTHREAD_ZOMBIE) {\n\t\trc = -EIO;\n\t\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\t\tprintk(KERN_ERR \"%s: We are in the middle of shutting down; \"\n\t\t       \"aborting privileged request to open lower file\\n\",\n\t\t\t__func__);\n\t\tgoto out;\n\t}\n\tlist_add_tail(&req.kthread_ctl_list, &ecryptfs_kthread_ctl.req_list);\n\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\twake_up(&ecryptfs_kthread_ctl.wait);\n\twait_for_completion(&req.done);\n\tif (IS_ERR(*lower_file))\n\t\trc = PTR_ERR(*lower_file);\nout:\n\treturn rc;\n}", "target": 1}
{"code": "static void exif_process_APP12(image_info_type *ImageInfo,\n                               char *buffer, size_t length) {\n  size_t l1, l2=0;\n  if ((l1 = php_strnlen(buffer+2, length-2)) > 0) {\n    exif_iif_add_tag(ImageInfo, SECTION_APP12, \"Company\",\n                     TAG_NONE, TAG_FMT_STRING, l1, buffer+2);\n    if (length > 2+l1+1) {\n      l2 = php_strnlen(buffer+2+l1+1, length-2-l1+1);\n      exif_iif_add_tag(ImageInfo, SECTION_APP12, \"Info\",\n                       TAG_NONE, TAG_FMT_STRING, l2, buffer+2+l1+1);\n    }\n  }\n}", "target": 1}
{"code": "static int ras_putdata(jas_stream_t *out, ras_hdr_t *hdr, jas_image_t *image, int numcmpts, int *cmpts)\n{\n\tint ret;\n\tswitch (hdr->type) {\n\tcase RAS_TYPE_STD:\n\t\tret = ras_putdatastd(out, hdr, image, numcmpts, cmpts);\n\t\tbreak;\n\tdefault:\n\t\tret = -1;\n\t\tbreak;\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "static int __init llc2_init(void)\n{\n\tint rc = proto_register(&llc_proto, 0);\n\tif (rc != 0)\n\t\tgoto out;\n\tllc_build_offset_table();\n\tllc_station_init();\n\tllc_ui_sap_last_autoport = LLC_SAP_DYN_START;\n\trc = llc_proc_init();\n\tif (rc != 0) {\n\t\tprintk(llc_proc_err_msg);\n\t\tgoto out_unregister_llc_proto;\n\t}\n\trc = llc_sysctl_init();\n\tif (rc) {\n\t\tprintk(llc_sysctl_err_msg);\n\t\tgoto out_proc;\n\t}\n\trc = sock_register(&llc_ui_family_ops);\n\tif (rc) {\n\t\tprintk(llc_sock_err_msg);\n\t\tgoto out_sysctl;\n\t}\n\tllc_add_pack(LLC_DEST_SAP, llc_sap_handler);\n\tllc_add_pack(LLC_DEST_CONN, llc_conn_handler);\nout:\n\treturn rc;\nout_sysctl:\n\tllc_sysctl_exit();\nout_proc:\n\tllc_proc_exit();\nout_unregister_llc_proto:\n\tproto_unregister(&llc_proto);\n\tgoto out;\n}", "target": 0}
{"code": "static struct mount *alloc_vfsmnt(const char *name)\n{\n\tstruct mount *mnt = kmem_cache_zalloc(mnt_cache, GFP_KERNEL);\n\tif (mnt) {\n\t\tint err;\n\t\terr = mnt_alloc_id(mnt);\n\t\tif (err)\n\t\t\tgoto out_free_cache;\n\t\tif (name) {\n\t\t\tmnt->mnt_devname = kstrdup(name, GFP_KERNEL);\n\t\t\tif (!mnt->mnt_devname)\n\t\t\t\tgoto out_free_id;\n\t\t}\n#ifdef CONFIG_SMP\n\t\tmnt->mnt_pcp = alloc_percpu(struct mnt_pcp);\n\t\tif (!mnt->mnt_pcp)\n\t\t\tgoto out_free_devname;\n\t\tthis_cpu_add(mnt->mnt_pcp->mnt_count, 1);\n#else\n\t\tmnt->mnt_count = 1;\n\t\tmnt->mnt_writers = 0;\n#endif\n\t\tINIT_HLIST_NODE(&mnt->mnt_hash);\n\t\tINIT_LIST_HEAD(&mnt->mnt_child);\n\t\tINIT_LIST_HEAD(&mnt->mnt_mounts);\n\t\tINIT_LIST_HEAD(&mnt->mnt_list);\n\t\tINIT_LIST_HEAD(&mnt->mnt_expire);\n\t\tINIT_LIST_HEAD(&mnt->mnt_share);\n\t\tINIT_LIST_HEAD(&mnt->mnt_slave_list);\n\t\tINIT_LIST_HEAD(&mnt->mnt_slave);\n#ifdef CONFIG_FSNOTIFY\n\t\tINIT_HLIST_HEAD(&mnt->mnt_fsnotify_marks);\n#endif\n\t}\n\treturn mnt;\n#ifdef CONFIG_SMP\nout_free_devname:\n\tkfree(mnt->mnt_devname);\n#endif\nout_free_id:\n\tmnt_free_id(mnt);\nout_free_cache:\n\tkmem_cache_free(mnt_cache, mnt);\n\treturn NULL;\n}", "target": 0}
{"code": "static int unpack_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_unpack *pkt;\n\tGIT_UNUSED(len);\n\tpkt = git__malloc(sizeof(*pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\tpkt->type = GIT_PKT_UNPACK;\n\tif (!git__prefixcmp(line, \"unpack ok\"))\n\t\tpkt->unpack_ok = 1;\n\telse\n\t\tpkt->unpack_ok = 0;\n\t*out = (git_pkt *)pkt;\n\treturn 0;\n}", "target": 0}
{"code": "static irqreturn_t sunkbd_interrupt(struct serio *serio,\n\t\tunsigned char data, unsigned int flags)\n{\n\tstruct sunkbd *sunkbd = serio_get_drvdata(serio);\n\tif (sunkbd->reset <= -1) {\n\t\tsunkbd->reset = data;\n\t\twake_up_interruptible(&sunkbd->wait);\n\t\tgoto out;\n\t}\n\tif (sunkbd->layout == -1) {\n\t\tsunkbd->layout = data;\n\t\twake_up_interruptible(&sunkbd->wait);\n\t\tgoto out;\n\t}\n\tswitch (data) {\n\tcase SUNKBD_RET_RESET:\n\t\tschedule_work(&sunkbd->tq);\n\t\tsunkbd->reset = -1;\n\t\tbreak;\n\tcase SUNKBD_RET_LAYOUT:\n\t\tsunkbd->layout = -1;\n\t\tbreak;\n\tcase SUNKBD_RET_ALLUP: \n\t\tbreak;\n\tdefault:\n\t\tif (!sunkbd->enabled)\n\t\t\tbreak;\n\t\tif (sunkbd->keycode[data & SUNKBD_KEY]) {\n\t\t\tinput_report_key(sunkbd->dev,\n\t\t\t\t\t sunkbd->keycode[data & SUNKBD_KEY],\n\t\t\t\t\t !(data & SUNKBD_RELEASE));\n\t\t\tinput_sync(sunkbd->dev);\n\t\t} else {\n\t\t\tprintk(KERN_WARNING\n\t\t\t\t\"sunkbd.c: Unknown key (scancode %#x) %s.\\n\",\n\t\t\t\tdata & SUNKBD_KEY,\n\t\t\t\tdata & SUNKBD_RELEASE ? \"released\" : \"pressed\");\n\t\t}\n\t}\nout:\n\treturn IRQ_HANDLED;\n}", "target": 1}
{"code": "static int expand_template(struct sss_certmap_ctx *ctx,\n                           struct parsed_template *parsed_template,\n                           struct sss_cert_content *cert_content,\n                           bool sanitize,\n                           char **expanded)\n{\n    int ret;\n    char *exp = NULL;\n    char *exp_sanitized = NULL;\n    if (strcmp(\"issuer_dn\", parsed_template->name) == 0) {\n        ret = rdn_list_2_dn_str(ctx, parsed_template->conversion,\n                                cert_content->issuer_rdn_list, &exp);\n    } else if (strcmp(\"subject_dn\", parsed_template->name) == 0) {\n        ret = rdn_list_2_dn_str(ctx, parsed_template->conversion,\n                                cert_content->subject_rdn_list, &exp);\n    } else if (strncmp(\"subject_\", parsed_template->name, 8) == 0) {\n        ret = expand_san(ctx, parsed_template, cert_content->san_list, &exp);\n    } else if (strcmp(\"cert\", parsed_template->name) == 0) {\n        sanitize = false;\n        ret = expand_cert(ctx, parsed_template, cert_content, &exp);\n    } else {\n        CM_DEBUG(ctx, \"Unsupported template name.\");\n        ret = EINVAL;\n        goto done;\n    }\n    if (ret != 0) {\n        CM_DEBUG(ctx, \"Failed to expand [%s] template.\", parsed_template->name);\n        goto done;\n    }\n    if (exp == NULL) {\n        ret = ENOMEM;\n        goto done;\n    }\n    if (sanitize) {\n        ret = sss_filter_sanitize(ctx, exp, &exp_sanitized);\n        if (ret != EOK) {\n            CM_DEBUG(ctx, \"Failed to sanitize expanded template.\");\n            goto done;\n        }\n        talloc_free(exp);\n        exp = exp_sanitized;\n    }\n    ret = 0;\ndone:\n    if (ret == 0) {\n        *expanded = exp;\n    } else {\n        talloc_free(exp);\n    }\n    return ret;\n}", "target": 0}
{"code": "  CallOpDimensionsFromInputs(const int n, const int h, const int w, const int c,\n                             const int kx, const int ky, const int sx,\n                             const int sy, const string& data_format,\n                             const string& padding) {\n    OpContext op_context;\n    const std::vector<int> x = {n, h, w, c};\n    const std::vector<int> ksize = {1, kx, ky, 1};\n    std::vector<int> strides;\n    if (data_format == \"NHWC\") {\n      strides = {1, sy, sx, 1};\n    } else {\n      strides = {1, 1, sy, sx};\n    }\n    auto& op_info = op_context.op_info;\n    SetCpuDevice(&op_info);\n    op_info.set_op(\"MaxPool\");\n    DescribeTensor4D(x[0], x[1], x[2], x[3], op_info.add_inputs());\n    auto* attr = op_info.mutable_attr();\n    SetAttrValue(data_format, &(*attr)[\"data_format\"]);\n    SetAttrValue(padding, &(*attr)[\"padding\"]);\n    SetAttrValue(strides, &(*attr)[\"strides\"]);\n    SetAttrValue(ksize, &(*attr)[\"ksize\"]);\n    bool found_unknown_shapes;\n    return OpLevelCostEstimator::OpDimensionsFromInputs(\n        op_context.op_info.inputs(0).shape(), op_context.op_info,\n        &found_unknown_shapes);\n  }", "target": 0}
{"code": "static int mount_notrunc(const char *source, const char *target,\n\t\t\t const char *filesystemtype, unsigned long mountflags,\n\t\t\t const char *data) {\n\tif (strlen(data) > sysconf(_SC_PAGESIZE) - 1) {\n\t\tfprintf(stderr, \"%s: mount options too long\\n\", progname);\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\treturn mount(source, target, filesystemtype, mountflags, data);\n}", "target": 0}
{"code": "static int do_io_accounting(struct task_struct *task, char *buffer, int whole)\n{\n\tstruct task_io_accounting acct = task->ioac;\n\tunsigned long flags;\n\tif (!ptrace_may_access(task, PTRACE_MODE_READ))\n\t\treturn -EACCES;\n\tif (whole && lock_task_sighand(task, &flags)) {\n\t\tstruct task_struct *t = task;\n\t\ttask_io_accounting_add(&acct, &task->signal->ioac);\n\t\twhile_each_thread(task, t)\n\t\t\ttask_io_accounting_add(&acct, &t->ioac);\n\t\tunlock_task_sighand(task, &flags);\n\t}\n\treturn sprintf(buffer,\n\t\t\t\"rchar: %llu\\n\"\n\t\t\t\"wchar: %llu\\n\"\n\t\t\t\"syscr: %llu\\n\"\n\t\t\t\"syscw: %llu\\n\"\n\t\t\t\"read_bytes: %llu\\n\"\n\t\t\t\"write_bytes: %llu\\n\"\n\t\t\t\"cancelled_write_bytes: %llu\\n\",\n\t\t\t(unsigned long long)acct.rchar,\n\t\t\t(unsigned long long)acct.wchar,\n\t\t\t(unsigned long long)acct.syscr,\n\t\t\t(unsigned long long)acct.syscw,\n\t\t\t(unsigned long long)acct.read_bytes,\n\t\t\t(unsigned long long)acct.write_bytes,\n\t\t\t(unsigned long long)acct.cancelled_write_bytes);\n}", "target": 0}
{"code": "static pj_status_t get_name_len(int rec_counter, const pj_uint8_t *pkt, \n                                const pj_uint8_t *start, const pj_uint8_t *max, \n                                int *parsed_len, int *name_len)\n{\n    const pj_uint8_t *p;\n    pj_status_t status;\n    if (rec_counter > 10) {\n        return PJLIB_UTIL_EDNSINNAMEPTR;\n    }\n    if (start >= max)\n        return PJLIB_UTIL_EDNSINNAMEPTR;\n    *name_len = *parsed_len = 0;\n    p = start;\n    while (*p) {\n        if ((*p & 0xc0) == 0xc0) {\n            int ptr_len = 0;\n            int dummy;\n            pj_uint16_t offset;\n            pj_memcpy(&offset, p, 2);\n            offset ^= pj_htons((pj_uint16_t)(0xc0 << 8));\n            offset = pj_ntohs(offset);\n            if (offset >= max - pkt)\n                return PJLIB_UTIL_EDNSINNAMEPTR;\n            status = get_name_len(rec_counter+1, pkt, pkt + offset, max, \n                                  &dummy, &ptr_len);\n            if (status != PJ_SUCCESS)\n                return status;\n            *parsed_len += 2;\n            *name_len += ptr_len;\n            return PJ_SUCCESS;\n        } else {\n            unsigned label_len = *p;\n            if (p+1+label_len+1 > max)\n                return PJLIB_UTIL_EDNSINNAMEPTR;\n            p += (label_len + 1);\n            *parsed_len += (label_len + 1);\n            if (*p != 0)\n                ++label_len;\n            *name_len += label_len;\n        }\n    }\n    ++p;\n    (*parsed_len)++;\n    return PJ_SUCCESS;\n}", "target": 0}
{"code": "static int unix_dgram_peer_wake_me(struct sock *sk, struct sock *other)\n{\n\tint connected;\n\tconnected = unix_dgram_peer_wake_connect(sk, other);\n\tif (unix_recvq_full(other))\n\t\treturn 1;\n\tif (connected)\n\t\tunix_dgram_peer_wake_disconnect(sk, other);\n\treturn 0;\n}", "target": 0}
{"code": "    long XmpValue::size() const\n    {\n        std::ostringstream os;\n        write(os);\n        return static_cast<long>(os.str().size());\n    }", "target": 0}
{"code": "ecma_op_function_call_native (ecma_object_t *func_obj_p, \n                              ecma_value_t this_arg_value, \n                              const ecma_value_t *arguments_list_p, \n                              uint32_t arguments_list_len) \n{\n  JERRY_ASSERT (ecma_get_object_type (func_obj_p) == ECMA_OBJECT_TYPE_NATIVE_FUNCTION);\n  ECMA_CHECK_STACK_USAGE ();\n  ecma_native_function_t *native_function_p = (ecma_native_function_t *) func_obj_p;\n#if JERRY_BUILTIN_REALMS\n  ecma_global_object_t *saved_global_object_p = JERRY_CONTEXT (global_object_p);\n  JERRY_CONTEXT (global_object_p) =\n    ECMA_GET_INTERNAL_VALUE_POINTER (ecma_global_object_t, native_function_p->realm_value);\n#endif \n  jerry_call_info_t call_info;\n  call_info.function = ecma_make_object_value (func_obj_p);\n  call_info.this_value = this_arg_value;\n  ecma_object_t *new_target_p = JERRY_CONTEXT (current_new_target_p);\n  call_info.new_target = (new_target_p == NULL) ? ECMA_VALUE_UNDEFINED : ecma_make_object_value (new_target_p);\n  JERRY_ASSERT (native_function_p->native_handler_cb != NULL);\n  ecma_value_t ret_value = native_function_p->native_handler_cb (&call_info, arguments_list_p, arguments_list_len);\n#if JERRY_BUILTIN_REALMS\n  JERRY_CONTEXT (global_object_p) = saved_global_object_p;\n#endif \n  if (JERRY_UNLIKELY (ecma_is_value_exception (ret_value)))\n  {\n    ecma_throw_exception (ret_value);\n    return ECMA_VALUE_ERROR;\n  }\n#if JERRY_DEBUGGER\n  JERRY_DEBUGGER_CLEAR_FLAGS (JERRY_DEBUGGER_VM_EXCEPTION_THROWN);\n#endif \n  return ret_value;\n} ", "target": 0}
{"code": "static int __init unittest_data_add(void)\n{\n\tvoid *unittest_data;\n\tstruct device_node *unittest_data_node, *np;\n\textern uint8_t __dtb_testcases_begin[];\n\textern uint8_t __dtb_testcases_end[];\n\tconst int size = __dtb_testcases_end - __dtb_testcases_begin;\n\tint rc;\n\tif (!size) {\n\t\tpr_warn(\"%s: No testcase data to attach; not running tests\\n\",\n\t\t\t__func__);\n\t\treturn -ENODATA;\n\t}\n\tunittest_data = kmemdup(__dtb_testcases_begin, size, GFP_KERNEL);\n\tif (!unittest_data)\n\t\treturn -ENOMEM;\n\tof_fdt_unflatten_tree(unittest_data, NULL, &unittest_data_node);\n\tif (!unittest_data_node) {\n\t\tpr_warn(\"%s: No tree to attach; not running tests\\n\", __func__);\n\t\tkfree(unittest_data);\n\t\treturn -ENODATA;\n\t}\n\tof_overlay_mutex_lock();\n\trc = of_resolve_phandles(unittest_data_node);\n\tif (rc) {\n\t\tpr_err(\"%s: Failed to resolve phandles (rc=%i)\\n\", __func__, rc);\n\t\tof_overlay_mutex_unlock();\n\t\treturn -EINVAL;\n\t}\n\tif (!of_root) {\n\t\tof_root = unittest_data_node;\n\t\tfor_each_of_allnodes(np)\n\t\t\t__of_attach_node_sysfs(np);\n\t\tof_aliases = of_find_node_by_path(\"/aliases\");\n\t\tof_chosen = of_find_node_by_path(\"/chosen\");\n\t\tof_overlay_mutex_unlock();\n\t\treturn 0;\n\t}\n\tnp = unittest_data_node->child;\n\twhile (np) {\n\t\tstruct device_node *next = np->sibling;\n\t\tnp->parent = of_root;\n\t\tattach_node_and_children(np);\n\t\tnp = next;\n\t}\n\tof_overlay_mutex_unlock();\n\treturn 0;\n}", "target": 0}
{"code": "int kvm_inject_realmode_interrupt(struct kvm_vcpu *vcpu, int irq)\n{\n\tstruct decode_cache *c = &vcpu->arch.emulate_ctxt.decode;\n\tint ret;\n\tinit_emulate_ctxt(vcpu);\n\tvcpu->arch.emulate_ctxt.decode.op_bytes = 2;\n\tvcpu->arch.emulate_ctxt.decode.ad_bytes = 2;\n\tvcpu->arch.emulate_ctxt.decode.eip = vcpu->arch.emulate_ctxt.eip;\n\tret = emulate_int_real(&vcpu->arch.emulate_ctxt, &emulate_ops, irq);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn EMULATE_FAIL;\n\tvcpu->arch.emulate_ctxt.eip = c->eip;\n\tmemcpy(vcpu->arch.regs, c->regs, sizeof c->regs);\n\tkvm_rip_write(vcpu, vcpu->arch.emulate_ctxt.eip);\n\tkvm_x86_ops->set_rflags(vcpu, vcpu->arch.emulate_ctxt.eflags);\n\tif (irq == NMI_VECTOR)\n\t\tvcpu->arch.nmi_pending = false;\n\telse\n\t\tvcpu->arch.interrupt.pending = false;\n\treturn EMULATE_DONE;\n}", "target": 0}
{"code": "static int mxf_read_index_entry_array(AVIOContext *pb, MXFIndexTableSegment *segment)\n{\n    int i, length;\n    segment->nb_index_entries = avio_rb32(pb);\n    length = avio_rb32(pb);\n    if(segment->nb_index_entries && length < 11)\n        return AVERROR_INVALIDDATA;\n    if (!(segment->temporal_offset_entries=av_calloc(segment->nb_index_entries, sizeof(*segment->temporal_offset_entries))) ||\n        !(segment->flag_entries          = av_calloc(segment->nb_index_entries, sizeof(*segment->flag_entries))) ||\n        !(segment->stream_offset_entries = av_calloc(segment->nb_index_entries, sizeof(*segment->stream_offset_entries)))) {\n        av_freep(&segment->temporal_offset_entries);\n        av_freep(&segment->flag_entries);\n        return AVERROR(ENOMEM);\n    }\n    for (i = 0; i < segment->nb_index_entries; i++) {\n        if(avio_feof(pb))\n            return AVERROR_INVALIDDATA;\n        segment->temporal_offset_entries[i] = avio_r8(pb);\n        avio_r8(pb);                                        \n        segment->flag_entries[i] = avio_r8(pb);\n        segment->stream_offset_entries[i] = avio_rb64(pb);\n        avio_skip(pb, length - 11);\n    }\n    return 0;\n}", "target": 0}
{"code": "static void sas_discover_domain(struct work_struct *work)\n{\n\tstruct domain_device *dev;\n\tint error = 0;\n\tstruct sas_discovery_event *ev = to_sas_discovery_event(work);\n\tstruct asd_sas_port *port = ev->port;\n\tclear_bit(DISCE_DISCOVER_DOMAIN, &port->disc.pending);\n\tif (port->port_dev)\n\t\treturn;\n\terror = sas_get_port_device(port);\n\tif (error)\n\t\treturn;\n\tdev = port->port_dev;\n\tSAS_DPRINTK(\"DOING DISCOVERY on port %d, pid:%d\\n\", port->id,\n\t\t    task_pid_nr(current));\n\tswitch (dev->dev_type) {\n\tcase SAS_END_DEVICE:\n\t\terror = sas_discover_end_dev(dev);\n\t\tbreak;\n\tcase SAS_EDGE_EXPANDER_DEVICE:\n\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\terror = sas_discover_root_expander(dev);\n\t\tbreak;\n\tcase SAS_SATA_DEV:\n\tcase SAS_SATA_PM:\n#ifdef CONFIG_SCSI_SAS_ATA\n\t\terror = sas_discover_sata(dev);\n\t\tbreak;\n#else\n\t\tSAS_DPRINTK(\"ATA device seen but CONFIG_SCSI_SAS_ATA=N so cannot attach\\n\");\n#endif\n\tdefault:\n\t\terror = -ENXIO;\n\t\tSAS_DPRINTK(\"unhandled device %d\\n\", dev->dev_type);\n\t\tbreak;\n\t}\n\tif (error) {\n\t\tsas_rphy_free(dev->rphy);\n\t\tlist_del_init(&dev->disco_list_node);\n\t\tspin_lock_irq(&port->dev_list_lock);\n\t\tlist_del_init(&dev->dev_list_node);\n\t\tspin_unlock_irq(&port->dev_list_lock);\n\t\tsas_put_device(dev);\n\t\tport->port_dev = NULL;\n\t}\n\tsas_probe_devices(port);\n\tSAS_DPRINTK(\"DONE DISCOVERY on port %d, pid:%d, result:%d\\n\", port->id,\n\t\t    task_pid_nr(current), error);\n}", "target": 0}
{"code": "bool QODBCResult::prepare(const QString& query)\n{\n    Q_D(QODBCResult);\n    setActive(false);\n    setAt(QSql::BeforeFirstRow);\n    SQLRETURN r;\n    d->rInf.clear();\n    if (d->hStmt && d->isStmtHandleValid()) {\n        r = SQLFreeHandle(SQL_HANDLE_STMT, d->hStmt);\n        if (r != SQL_SUCCESS) {\n            qSqlWarning(\"QODBCResult::prepare: Unable to close statement\"_L1, d);\n            return false;\n        }\n    }\n    r  = SQLAllocHandle(SQL_HANDLE_STMT,\n                         d->dpDbc(),\n                         &d->hStmt);\n    if (r != SQL_SUCCESS) {\n        qSqlWarning(\"QODBCResult::prepare: Unable to allocate statement handle\"_L1, d);\n        return false;\n    }\n    d->updateStmtHandleState();\n    if (isForwardOnly()) {\n        r = SQLSetStmtAttr(d->hStmt,\n                            SQL_ATTR_CURSOR_TYPE,\n                            (SQLPOINTER)SQL_CURSOR_FORWARD_ONLY,\n                            SQL_IS_UINTEGER);\n    } else {\n        r = SQLSetStmtAttr(d->hStmt,\n                            SQL_ATTR_CURSOR_TYPE,\n                            (SQLPOINTER)SQL_CURSOR_STATIC,\n                            SQL_IS_UINTEGER);\n    }\n    if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO) {\n        setLastError(qMakeError(QCoreApplication::translate(\"QODBCResult\",\n            \"QODBCResult::reset: Unable to set 'SQL_CURSOR_STATIC' as statement attribute. \"\n            \"Please check your ODBC driver configuration\"), QSqlError::StatementError, d));\n        return false;\n    }\n    r = SQLPrepare(d->hStmt,\n                    toSQLTCHAR(query).data(),\n                    (SQLINTEGER) query.length());\n    if (r != SQL_SUCCESS) {\n        setLastError(qMakeError(QCoreApplication::translate(\"QODBCResult\",\n                     \"Unable to prepare statement\"), QSqlError::StatementError, d));\n        return false;\n    }\n    return true;\n}", "target": 1}
{"code": "static int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_pclr_t *pclr = &box->data.pclr;\n\tint lutsize;\n\tunsigned int i;\n\tunsigned int j;\n\tint_fast32_t x;\n\tpclr->lutdata = 0;\n\tpclr->bpc = 0;\n\tif (jp2_getuint16(in, &pclr->numlutents) ||\n\t  jp2_getuint8(in, &pclr->numchans)) {\n\t\treturn -1;\n\t}\n\tlutsize = pclr->numlutents * pclr->numchans;\n\tif (!(pclr->lutdata = jas_alloc2(lutsize, sizeof(int_fast32_t)))) {\n\t\treturn -1;\n\t}\n\tif (!(pclr->bpc = jas_alloc2(pclr->numchans, sizeof(uint_fast8_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < pclr->numchans; ++i) {\n\t\tif (jp2_getuint8(in, &pclr->bpc[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tfor (i = 0; i < pclr->numlutents; ++i) {\n\t\tfor (j = 0; j < pclr->numchans; ++j) {\n\t\t\tif (jp2_getint(in, (pclr->bpc[j] & 0x80) != 0,\n\t\t\t  (pclr->bpc[j] & 0x7f) + 1, &x)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tpclr->lutdata[i * pclr->numchans + j] = x;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "std::string WC2MB(const std::wstring& input, unsigned int code_page) {\n  if (input.empty()) {\n    return \"\";\n  }\n  DWORD flags = 0;\n  if (code_page != 65001 && code_page != 54936) {\n    flags = WC_NO_BEST_FIT_CHARS | WC_COMPOSITECHECK | WC_DEFAULTCHAR;\n  }\n  int length = ::WideCharToMultiByte(code_page, flags, &input[0],\n                                     static_cast<int>(input.size()), NULL, 0,\n                                     NULL, NULL);\n  std::string output(length, '\\0');\n  ::WideCharToMultiByte(code_page, flags, &input[0],\n                        static_cast<int>(input.size()), &output[0],\n                        static_cast<int>(output.size()), NULL, NULL);\n  return output;\n}", "target": 1}
{"code": "xid_map_enter(netdissect_options *ndo,\n              const struct sunrpc_msg *rp, const u_char *bp)\n{\n\tconst struct ip *ip = NULL;\n\tconst struct ip6_hdr *ip6 = NULL;\n\tstruct xid_map_entry *xmep;\n\tif (!ND_TTEST(rp->rm_call.cb_vers))\n\t\treturn (0);\n\tswitch (IP_V((const struct ip *)bp)) {\n\tcase 4:\n\t\tip = (const struct ip *)bp;\n\t\tbreak;\n\tcase 6:\n\t\tip6 = (const struct ip6_hdr *)bp;\n\t\tbreak;\n\tdefault:\n\t\treturn (1);\n\t}\n\txmep = &xid_map[xid_map_next];\n\tif (++xid_map_next >= XIDMAPSIZE)\n\t\txid_map_next = 0;\n\tUNALIGNED_MEMCPY(&xmep->xid, &rp->rm_xid, sizeof(xmep->xid));\n\tif (ip) {\n\t\txmep->ipver = 4;\n\t\tUNALIGNED_MEMCPY(&xmep->client, &ip->ip_src, sizeof(ip->ip_src));\n\t\tUNALIGNED_MEMCPY(&xmep->server, &ip->ip_dst, sizeof(ip->ip_dst));\n\t}\n\telse if (ip6) {\n\t\txmep->ipver = 6;\n\t\tUNALIGNED_MEMCPY(&xmep->client, &ip6->ip6_src, sizeof(ip6->ip6_src));\n\t\tUNALIGNED_MEMCPY(&xmep->server, &ip6->ip6_dst, sizeof(ip6->ip6_dst));\n\t}\n\tif (!ND_TTEST(rp->rm_call.cb_proc))\n\t\treturn (0);\n\txmep->proc = EXTRACT_32BITS(&rp->rm_call.cb_proc);\n\tif (!ND_TTEST(rp->rm_call.cb_vers))\n\t\treturn (0);\n\txmep->vers = EXTRACT_32BITS(&rp->rm_call.cb_vers);\n\treturn (1);\n}", "target": 0}
{"code": "kg_seal_iov(OM_uint32 *minor_status,\n            gss_ctx_id_t context_handle,\n            int conf_req_flag,\n            gss_qop_t qop_req,\n            int *conf_state,\n            gss_iov_buffer_desc *iov,\n            int iov_count,\n            int toktype)\n{\n    krb5_gss_ctx_id_rec *ctx;\n    krb5_error_code code;\n    krb5_context context;\n    if (qop_req != 0) {\n        *minor_status = (OM_uint32)G_UNKNOWN_QOP;\n        return GSS_S_FAILURE;\n    }\n    ctx = (krb5_gss_ctx_id_rec *)context_handle;\n    if (!ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return GSS_S_NO_CONTEXT;\n    }\n    if (conf_req_flag && kg_integ_only_iov(iov, iov_count)) {\n        conf_req_flag = FALSE;\n    }\n    context = ctx->k5_context;\n    switch (ctx->proto) {\n    case 0:\n        code = make_seal_token_v1_iov(context, ctx, conf_req_flag,\n                                      conf_state, iov, iov_count, toktype);\n        break;\n    case 1:\n        code = gss_krb5int_make_seal_token_v3_iov(context, ctx, conf_req_flag,\n                                                  conf_state, iov, iov_count, toktype);\n        break;\n    default:\n        code = G_UNKNOWN_QOP;\n        break;\n    }\n    if (code != 0) {\n        *minor_status = code;\n        save_error_info(*minor_status, context);\n        return GSS_S_FAILURE;\n    }\n    *minor_status = 0;\n    return GSS_S_COMPLETE;\n}", "target": 1}
{"code": "static std::wstring MB2WC(const std::string& input, unsigned int code_page) {\n  if (input.empty()) {\n    return L\"\";\n  }\n  int length = ::MultiByteToWideChar(code_page, 0, &input[0],\n                                     static_cast<int>(input.size()),\n                                     NULL, 0);\n  std::wstring output(length, '\\0');\n  ::MultiByteToWideChar(code_page, 0, &input[0], static_cast<int>(input.size()),\n                        &output[0], static_cast<int>(output.size()));\n  return output;\n}", "target": 0}
{"code": "static int metachar(char c)\n{\n\treturn (strchr(metachars(), c) != NULL);\n}", "target": 1}
{"code": "EXPORTED int examine_request(struct transaction_t *txn, const char *uri)\n{\n    int ret = 0, sasl_result = 0;\n    const char *query;\n    const struct namespace_t *namespace;\n    struct request_line_t *req_line = &txn->req_line;\n    if (!uri) uri = req_line->uri;\n    if ((ret = check_method(txn))) return ret;\n    if (!(txn->req_uri = parse_uri(txn->meth, uri, 1, &txn->error.desc))) {\n        return HTTP_BAD_REQUEST;\n    }\n    if ((ret = preauth_check_hdrs(txn))) return ret;\n    if ((ret = check_namespace(txn))) return ret;\n    ret = auth_check_hdrs(txn, &sasl_result);\n    if (ret && ret != HTTP_UNAUTHORIZED) return ret;\n    namespace = txn->req_tgt.namespace;\n    buf_printf(&txn->buf, \"%s%s\", config_ident,\n               namespace->well_known ? strrchr(namespace->well_known, '/') :\n               namespace->prefix);\n    proc_register(buf_cstring(&txn->buf), txn->conn->clienthost, httpd_userid,\n                  txn->req_tgt.path, txn->req_line.meth);\n    buf_reset(&txn->buf);\n    if (!httpd_userid && namespace->need_auth(txn)) {\n        ret = HTTP_UNAUTHORIZED;\n    }\n    if (ret) return client_need_auth(txn, sasl_result);\n    construct_hash_table(&txn->req_qparams, 10, 1);\n    query = URI_QUERY(txn->req_uri);\n    if (query) parse_query_params(txn, query);\n    postauth_check_hdrs(txn);\n    return 0;\n}", "target": 0}
{"code": "  void DoRealForwardFFT(OpKernelContext* ctx, uint64* fft_shape,\n                        const Tensor& in, Tensor* out) {\n    const auto axes = Eigen::ArrayXi::LinSpaced(FFTRank, 1, FFTRank);\n    auto device = ctx->eigen_device<CPUDevice>();\n    auto input = Tensor(in).flat_inner_dims<RealT, FFTRank + 1>();\n    const auto input_dims = input.dimensions();\n    Eigen::DSizes<Eigen::DenseIndex, FFTRank + 1> input_slice_sizes;\n    input_slice_sizes[0] = input_dims[0];\n    TensorShape temp_shape{input_dims[0]};\n    for (int i = 1; i <= FFTRank; ++i) {\n      input_slice_sizes[i] = fft_shape[i - 1];\n      temp_shape.AddDim(fft_shape[i - 1]);\n    }\n    OP_REQUIRES(ctx, temp_shape.num_elements() > 0,\n                errors::InvalidArgument(\"Obtained a FFT shape of 0 elements: \",\n                                        temp_shape.DebugString()));\n    auto output = out->flat_inner_dims<ComplexT, FFTRank + 1>();\n    const Eigen::DSizes<Eigen::DenseIndex, FFTRank + 1> zero_start_indices;\n    Tensor temp;\n    OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<ComplexT>::v(),\n                                           temp_shape, &temp));\n    auto full_fft = temp.flat_inner_dims<ComplexT, FFTRank + 1>();\n    full_fft.device(device) =\n        input.slice(zero_start_indices, input_slice_sizes)\n            .template fft<Eigen::BothParts, Eigen::FFT_FORWARD>(axes);\n    output.device(device) =\n        full_fft.slice(zero_start_indices, output.dimensions());\n  }", "target": 0}
{"code": "static inline void write_desc(struct intel_engine_execlists *execlists, u64 desc, u32 port)\n{\n\tif (execlists->ctrl_reg) {\n\t\twritel(lower_32_bits(desc), execlists->submit_reg + port * 2);\n\t\twritel(upper_32_bits(desc), execlists->submit_reg + port * 2 + 1);\n\t} else {\n\t\twritel(upper_32_bits(desc), execlists->submit_reg);\n\t\twritel(lower_32_bits(desc), execlists->submit_reg);\n\t}\n}", "target": 0}
{"code": "static int pcd_detect(void)\n{\n\tchar id[18];\n\tint k, unit;\n\tstruct pcd_unit *cd;\n\tprintk(\"%s: %s version %s, major %d, nice %d\\n\",\n\t       name, name, PCD_VERSION, major, nice);\n\tpar_drv = pi_register_driver(name);\n\tif (!par_drv) {\n\t\tpr_err(\"failed to register %s driver\\n\", name);\n\t\treturn -1;\n\t}\n\tk = 0;\n\tif (pcd_drive_count == 0) { \n\t\tcd = pcd;\n\t\tif (pi_init(cd->pi, 1, -1, -1, -1, -1, -1, pcd_buffer,\n\t\t\t    PI_PCD, verbose, cd->name)) {\n\t\t\tif (!pcd_probe(cd, -1, id) && cd->disk) {\n\t\t\t\tcd->present = 1;\n\t\t\t\tk++;\n\t\t\t} else\n\t\t\t\tpi_release(cd->pi);\n\t\t}\n\t} else {\n\t\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\t\tint *conf = *drives[unit];\n\t\t\tif (!conf[D_PRT])\n\t\t\t\tcontinue;\n\t\t\tif (!pi_init(cd->pi, 0, conf[D_PRT], conf[D_MOD],\n\t\t\t\t     conf[D_UNI], conf[D_PRO], conf[D_DLY],\n\t\t\t\t     pcd_buffer, PI_PCD, verbose, cd->name)) \n\t\t\t\tcontinue;\n\t\t\tif (!pcd_probe(cd, conf[D_SLV], id) && cd->disk) {\n\t\t\t\tcd->present = 1;\n\t\t\t\tk++;\n\t\t\t} else\n\t\t\t\tpi_release(cd->pi);\n\t\t}\n\t}\n\tif (k)\n\t\treturn 0;\n\tprintk(\"%s: No CD-ROM drive found\\n\", name);\n\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\tif (!cd->disk)\n\t\t\tcontinue;\n\t\tblk_cleanup_queue(cd->disk->queue);\n\t\tcd->disk->queue = NULL;\n\t\tblk_mq_free_tag_set(&cd->tag_set);\n\t\tput_disk(cd->disk);\n\t}\n\tpi_unregister_driver(par_drv);\n\treturn -1;\n}", "target": 0}
{"code": "const char *cgit_loginurl(void)\n{\n\tstatic const char *login_url;\n\tif (!login_url)\n\t\tlogin_url = fmtalloc(\"%s?p=login\", cgit_rooturl());\n\treturn login_url;\n}", "target": 0}
{"code": "static void add_binary_option(gpointer key, gpointer value, gpointer user_data)\n{\n\tuint8_t *option = value;\n\tstruct dhcp_packet *packet = user_data;\n\tdhcp_add_binary_option(packet, option);\n}", "target": 0}
{"code": "ssh_packet_set_postauth(struct ssh *ssh)\n{\n\tstruct sshcomp *comp;\n\tint r, mode;\n\tdebug(\"%s: called\", __func__);\n\tssh->state->after_authentication = 1;\n\tssh->state->rekeying = 0;\n\tfor (mode = 0; mode < MODE_MAX; mode++) {\n\t\tif (ssh->state->newkeys[mode] == NULL)\n\t\t\tcontinue;\n\t\tcomp = &ssh->state->newkeys[mode]->comp;\n\t\tif (comp && comp->enabled &&\n\t\t    (r = ssh_packet_init_compression(ssh)) != 0)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "int LibarchivePlugin::extractionFlags() const\n{\n    int result = ARCHIVE_EXTRACT_TIME;\n    result |= ARCHIVE_EXTRACT_SECURE_NODOTDOT;\n    return result;\n}", "target": 1}
{"code": "int touch_file(const char *path, bool parents, usec_t stamp, uid_t uid, gid_t gid, mode_t mode) {\n        _cleanup_close_ int fd;\n        int r;\n        assert(path);\n        if (parents)\n                mkdir_parents(path, 0755);\n        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY, mode > 0 ? mode : 0644);\n        if (fd < 0)\n                return -errno;\n        if (mode > 0) {\n                r = fchmod(fd, mode);\n                if (r < 0)\n                        return -errno;\n        }\n        if (uid != UID_INVALID || gid != GID_INVALID) {\n                r = fchown(fd, uid, gid);\n                if (r < 0)\n                        return -errno;\n        }\n        if (stamp != USEC_INFINITY) {\n                struct timespec ts[2];\n                timespec_store(&ts[0], stamp);\n                ts[1] = ts[0];\n                r = futimens(fd, ts);\n        } else\n                r = futimens(fd, NULL);\n        if (r < 0)\n                return -errno;\n        return 0;\n}", "target": 1}
{"code": "    std::ostream& operator<<(std::ostream& os, const Rational& r)\n    {\n        return os << r.first << \"/\" << r.second;\n    }", "target": 0}
{"code": "TEST_F(HeaderToMetadataTest, CookieValueUsed) {\n  const std::string response_config_yaml = R\"EOF(\nresponse_rules:\n  - cookie: bar\n    on_header_present:\n      key: bar\n      type: STRING\n    remove: false\n)EOF\";\n  initializeFilter(response_config_yaml);\n  Http::TestResponseHeaderMapImpl incoming_headers{{\"cookie\", \"bar=foo\"}};\n  std::map<std::string, std::string> expected = {{\"bar\", \"foo\"}};\n  EXPECT_CALL(encoder_callbacks_, streamInfo()).WillRepeatedly(ReturnRef(req_info_));\n  EXPECT_CALL(req_info_,\n              setDynamicMetadata(HttpFilterNames::get().HeaderToMetadata, MapEq(expected)));\n  EXPECT_EQ(Http::FilterHeadersStatus::Continue, filter_->encodeHeaders(incoming_headers, false));\n}", "target": 0}
{"code": "static char *stibp_state(void)\n{\n\tif (spectre_v2_in_ibrs_mode(spectre_v2_enabled))\n\t\treturn \"\";\n\tswitch (spectre_v2_user_stibp) {\n\tcase SPECTRE_V2_USER_NONE:\n\t\treturn \", STIBP: disabled\";\n\tcase SPECTRE_V2_USER_STRICT:\n\t\treturn \", STIBP: forced\";\n\tcase SPECTRE_V2_USER_STRICT_PREFERRED:\n\t\treturn \", STIBP: always-on\";\n\tcase SPECTRE_V2_USER_PRCTL:\n\tcase SPECTRE_V2_USER_SECCOMP:\n\t\tif (static_key_enabled(&switch_to_cond_stibp))\n\t\t\treturn \", STIBP: conditional\";\n\t}\n\treturn \"\";\n}", "target": 1}
{"code": "debug_print_range(const char *msg,\n    int lineno,\n    void *start, signed long len,\n    void *end)\n{\n    char *st = (char *)start;\n    char *en = (char *)end;\n    signed long le = len;\n    if (len) {\n        if (en) {\n            le = (long)(en-st);\n        } else {\n            en= start+len;\n        }\n    } else if (en) {\n        le = (long)(en-st);\n    }\n    printf(\"RANGEdebug %s  st=0x%lx le=%ld en=0x%lx line %d\\n\",\n        msg,(unsigned long)st,le,(unsigned long)en,lineno);\n}", "target": 0}
{"code": "void ssl_update_cache(SSL *s, int mode)\n{\n    int i;\n    if (s->session->session_id_length == 0)\n        return;\n    if (s->server && s->session->sid_ctx_length == 0\n            && (s->verify_mode & SSL_VERIFY_PEER) != 0)\n        return;\n    i = s->session_ctx->session_cache_mode;\n    if ((i & mode) != 0\n        && (!s->hit || SSL_IS_TLS13(s))) {\n        if ((i & SSL_SESS_CACHE_NO_INTERNAL_STORE) == 0\n                && (!SSL_IS_TLS13(s)\n                    || !s->server\n                    || (s->max_early_data > 0\n                        && (s->options & SSL_OP_NO_ANTI_REPLAY) == 0)\n                    || s->session_ctx->remove_session_cb != NULL\n                    || (s->options & SSL_OP_NO_TICKET) != 0))\n            SSL_CTX_add_session(s->session_ctx, s->session);\n        if (s->session_ctx->new_session_cb != NULL) {\n            SSL_SESSION_up_ref(s->session);\n            if (!s->session_ctx->new_session_cb(s, s->session))\n                SSL_SESSION_free(s->session);\n        }\n    }\n    if ((!(i & SSL_SESS_CACHE_NO_AUTO_CLEAR)) && ((i & mode) == mode)) {\n        TSAN_QUALIFIER int *stat;\n        if (mode & SSL_SESS_CACHE_CLIENT)\n            stat = &s->session_ctx->stats.sess_connect_good;\n        else\n            stat = &s->session_ctx->stats.sess_accept_good;\n        if ((ssl_tsan_load(s->session_ctx, stat) & 0xff) == 0xff)\n            SSL_CTX_flush_sessions(s->session_ctx, (unsigned long)time(NULL));\n    }\n}", "target": 1}
{"code": "static int snd_timer_user_tselect(struct file *file,\n\t\t\t\t  struct snd_timer_select __user *_tselect)\n{\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_select tselect;\n\tchar str[32];\n\tint err = 0;\n\ttu = file->private_data;\n\tmutex_lock(&tu->tread_sem);\n\tif (tu->timeri) {\n\t\tsnd_timer_close(tu->timeri);\n\t\ttu->timeri = NULL;\n\t}\n\tif (copy_from_user(&tselect, _tselect, sizeof(tselect))) {\n\t\terr = -EFAULT;\n\t\tgoto __err;\n\t}\n\tsprintf(str, \"application %i\", current->pid);\n\tif (tselect.id.dev_class != SNDRV_TIMER_CLASS_SLAVE)\n\t\ttselect.id.dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION;\n\terr = snd_timer_open(&tu->timeri, str, &tselect.id, current->pid);\n\tif (err < 0)\n\t\tgoto __err;\n\tkfree(tu->queue);\n\ttu->queue = NULL;\n\tkfree(tu->tqueue);\n\ttu->tqueue = NULL;\n\tif (tu->tread) {\n\t\ttu->tqueue = kmalloc(tu->queue_size * sizeof(struct snd_timer_tread),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (tu->tqueue == NULL)\n\t\t\terr = -ENOMEM;\n\t} else {\n\t\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t\t    GFP_KERNEL);\n\t\tif (tu->queue == NULL)\n\t\t\terr = -ENOMEM;\n\t}\n      \tif (err < 0) {\n\t\tsnd_timer_close(tu->timeri);\n      \t\ttu->timeri = NULL;\n      \t} else {\n\t\ttu->timeri->flags |= SNDRV_TIMER_IFLG_FAST;\n\t\ttu->timeri->callback = tu->tread\n\t\t\t? snd_timer_user_tinterrupt : snd_timer_user_interrupt;\n\t\ttu->timeri->ccallback = snd_timer_user_ccallback;\n\t\ttu->timeri->callback_data = (void *)tu;\n\t}\n      __err:\n      \tmutex_unlock(&tu->tread_sem);\n\treturn err;\n}", "target": 1}
{"code": "gen_values(codegen_scope *s, node *t, int val, int limit)\n{\n  int n = 0;\n  int first = 1;\n  int slimit = GEN_VAL_STACK_MAX;\n  if (limit == 0) limit = GEN_LIT_ARY_MAX;\n  if (cursp() >= slimit) slimit = INT16_MAX;\n  if (!val) {\n    while (t) {\n      codegen(s, t->car, NOVAL);\n      n++;\n      t = t->cdr;\n    }\n    return n;\n  }\n  while (t) {\n    int is_splat = nint(t->car->car) == NODE_SPLAT;\n    if (is_splat || n > limit || cursp() >= slimit) { \n      pop_n(n);\n      if (first) {\n        if (n == 0) {\n          genop_1(s, OP_LOADNIL, cursp());\n        }\n        else {\n          genop_2(s, OP_ARRAY, cursp(), n);\n        }\n        push();\n        first = 0;\n        limit = GEN_LIT_ARY_MAX;\n      }\n      else if (n > 0) {\n        pop();\n        genop_2(s, OP_ARYPUSH, cursp(), n);\n        push();\n      }\n      n = 0;\n    }\n    codegen(s, t->car, val);\n    if (is_splat) {\n      pop(); pop();\n      genop_1(s, OP_ARYCAT, cursp());\n      push();\n    }\n    else {\n      n++;\n    }\n    t = t->cdr;\n  }\n  if (!first) {\n    pop();\n    if (n > 0) {\n      pop_n(n);\n      genop_2(s, OP_ARYPUSH, cursp(), n);\n    }\n    return -1;                  \n  }\n  return n;\n}", "target": 1}
{"code": "static int vcpu_run(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tvcpu->arch.l1tf_flush_l1d = true;\n\tfor (;;) {\n\t\tvcpu->arch.at_instruction_boundary = false;\n\t\tif (kvm_vcpu_running(vcpu)) {\n\t\t\tr = vcpu_enter_guest(vcpu);\n\t\t} else {\n\t\t\tr = vcpu_block(vcpu);\n\t\t}\n\t\tif (r <= 0)\n\t\t\tbreak;\n\t\tkvm_clear_request(KVM_REQ_UNBLOCK, vcpu);\n\t\tif (kvm_xen_has_pending_events(vcpu))\n\t\t\tkvm_xen_inject_pending_events(vcpu);\n\t\tif (kvm_cpu_has_pending_timer(vcpu))\n\t\t\tkvm_inject_pending_timer_irqs(vcpu);\n\t\tif (dm_request_for_irq_injection(vcpu) &&\n\t\t\tkvm_vcpu_ready_for_interrupt_injection(vcpu)) {\n\t\t\tr = 0;\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_IRQ_WINDOW_OPEN;\n\t\t\t++vcpu->stat.request_irq_exits;\n\t\t\tbreak;\n\t\t}\n\t\tif (__xfer_to_guest_mode_work_pending()) {\n\t\t\tkvm_vcpu_srcu_read_unlock(vcpu);\n\t\t\tr = xfer_to_guest_mode_handle_work(vcpu);\n\t\t\tkvm_vcpu_srcu_read_lock(vcpu);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t}\n\t}\n\treturn r;\n}", "target": 0}
{"code": "bool RepeatedAttrDefEqual(\n    const protobuf::RepeatedPtrField<OpDef::AttrDef>& a1,\n    const protobuf::RepeatedPtrField<OpDef::AttrDef>& a2) {\n  std::unordered_map<string, const OpDef::AttrDef*> a1_set;\n  for (const OpDef::AttrDef& def : a1) {\n    DCHECK(a1_set.find(def.name()) == a1_set.end())\n        << \"AttrDef names must be unique, but '\" << def.name()\n        << \"' appears more than once\";\n    a1_set[def.name()] = &def;\n  }\n  for (const OpDef::AttrDef& def : a2) {\n    auto iter = a1_set.find(def.name());\n    if (iter == a1_set.end()) return false;\n    if (!AttrDefEqual(*iter->second, def)) return false;\n    a1_set.erase(iter);\n  }\n  if (!a1_set.empty()) return false;\n  return true;\n}", "target": 1}
{"code": "parse_memory(VALUE klass, VALUE data)\n{\n  xmlParserCtxtPtr ctxt;\n  if (NIL_P(data)) {\n    rb_raise(rb_eArgError, \"data cannot be nil\");\n  }\n  if (!(int)RSTRING_LEN(data)) {\n    rb_raise(rb_eRuntimeError, \"data cannot be empty\");\n  }\n  ctxt = xmlCreateMemoryParserCtxt(StringValuePtr(data),\n                                   (int)RSTRING_LEN(data));\n  if (ctxt->sax) {\n    xmlFree(ctxt->sax);\n    ctxt->sax = NULL;\n  }\n  return Data_Wrap_Struct(klass, NULL, deallocate, ctxt);\n}", "target": 1}
{"code": "void TestJlCompress::extractDir()\n{\n    QFETCH(QString, zipName);\n    QFETCH(QStringList, fileNames);\n    QDir curDir;\n    if (!curDir.mkpath(\"jlext/jldir\")) {\n        QFAIL(\"Couldn't mkpath jlext/jldir\");\n    }\n    if (!createTestFiles(fileNames)) {\n        QFAIL(\"Couldn't create test files\");\n    }\n    if (!createTestArchive(zipName, fileNames)) {\n        QFAIL(\"Couldn't create test archive\");\n    }\n    QStringList extracted;\n    QCOMPARE((extracted = JlCompress::extractDir(zipName, \"jlext/jldir\"))\n        .count(), fileNames.count());\n    foreach (QString fileName, fileNames) {\n        QString fullName = \"jlext/jldir/\" + fileName;\n        QFileInfo fileInfo(fullName);\n        QFileInfo extInfo(\"tmp/\" + fileName);\n        if (!fileInfo.isDir())\n            QCOMPARE(fileInfo.size(), extInfo.size());\n        QCOMPARE(fileInfo.permissions(), extInfo.permissions());\n        curDir.remove(fullName);\n        curDir.rmpath(fileInfo.dir().path());\n        QString absolutePath = fileInfo.absoluteFilePath();\n        if (fileInfo.isDir() && !absolutePath.endsWith('/'))\n\t    absolutePath += '/';\n        QVERIFY(extracted.contains(absolutePath));\n    }\n    QFile zipFile(zipName);\n    QVERIFY(zipFile.open(QIODevice::ReadOnly));\n    QCOMPARE((extracted = JlCompress::extractDir(&zipFile, \"jlext/jldir\"))\n        .count(), fileNames.count());\n    foreach (QString fileName, fileNames) {\n        QString fullName = \"jlext/jldir/\" + fileName;\n        QFileInfo fileInfo(fullName);\n        QFileInfo extInfo(\"tmp/\" + fileName);\n        if (!fileInfo.isDir())\n            QCOMPARE(fileInfo.size(), extInfo.size());\n        QCOMPARE(fileInfo.permissions(), extInfo.permissions());\n        curDir.remove(fullName);\n        curDir.rmpath(fileInfo.dir().path());\n        QString absolutePath = fileInfo.absoluteFilePath();\n        if (fileInfo.isDir() && !absolutePath.endsWith('/'))\n        absolutePath += '/';\n        QVERIFY(extracted.contains(absolutePath));\n    }\n    zipFile.close();\n    curDir.rmpath(\"jlext/jldir\");\n    removeTestFiles(fileNames);\n    curDir.remove(zipName);\n}", "target": 1}
{"code": "void CLASS bad_pixels (const char *cfname)\n{\n  FILE *fp=NULL;\n#ifndef LIBRAW_LIBRARY_BUILD\n  char *fname, *cp, line[128];\n  int len, time, row, col, r, c, rad, tot, n, fixed=0;\n#else\n  char *cp, line[128];\n  int time, row, col, r, c, rad, tot, n;\n#ifdef DCRAW_VERBOSE\n  int fixed = 0;\n#endif\n#endif\n  if (!filters) return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS,0,2);\n#endif\n  if (cfname)\n    fp = fopen (cfname, \"r\");\n#line 4009 \"dcraw/dcraw.c\"\n  if (!fp)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.process_warnings |= LIBRAW_WARN_NO_BADPIXELMAP;\n#endif\n          return;\n      }\n  while (fgets (line, 128, fp)) {\n    cp = strchr (line, '#');\n    if (cp) *cp = 0;\n    if (sscanf (line, \"%d %d %d\", &col, &row, &time) != 3) continue;\n    if ((unsigned) col >= width || (unsigned) row >= height) continue;\n    if (time > timestamp) continue;\n    for (tot=n=0, rad=1; rad < 3 && n==0; rad++)\n      for (r = row-rad; r <= row+rad; r++)\n\tfor (c = col-rad; c <= col+rad; c++)\n\t  if ((unsigned) r < height && (unsigned) c < width &&\n\t\t(r != row || c != col) && fcol(r,c) == fcol(row,col)) {\n\t    tot += BAYER2(r,c);\n\t    n++;\n\t  }\n    BAYER2(row,col) = tot/n;\n#ifdef DCRAW_VERBOSE\n    if (verbose) {\n      if (!fixed++)\n\tfprintf (stderr,_(\"Fixed dead pixels at:\"));\n      fprintf (stderr, \" %d,%d\", col, row);\n    }\n#endif\n  }\n#ifdef DCRAW_VERBOSE\n  if (fixed) fputc ('\\n', stderr);\n#endif\n  fclose (fp);\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS,1,2);\n#endif\n}", "target": 1}
{"code": "static BOOL nsc_rle_decode(BYTE* in, BYTE* out, UINT32 outSize, UINT32 originalSize)\n{\n\tUINT32 left = originalSize;\n\twhile (left > 4)\n\t{\n\t\tconst BYTE value = *in++;\n\t\tUINT32 len = 0;\n\t\tif (left == 5)\n\t\t{\n\t\t\tif (outSize < 1)\n\t\t\t\treturn FALSE;\n\t\t\toutSize--;\n\t\t\t*out++ = value;\n\t\t\tleft--;\n\t\t}\n\t\telse if (value == *in)\n\t\t{\n\t\t\tin++;\n\t\t\tif (*in < 0xFF)\n\t\t\t{\n\t\t\t\tlen = (UINT32)*in++;\n\t\t\t\tlen += 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tin++;\n\t\t\t\tlen = ((UINT32)(*in++));\n\t\t\t\tlen |= ((UINT32)(*in++)) << 8U;\n\t\t\t\tlen |= ((UINT32)(*in++)) << 16U;\n\t\t\t\tlen |= ((UINT32)(*in++)) << 24U;\n\t\t\t}\n\t\t\tif (outSize < len)\n\t\t\t\treturn FALSE;\n\t\t\toutSize -= len;\n\t\t\tFillMemory(out, len, value);\n\t\t\tout += len;\n\t\t\tleft -= len;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (outSize < 1)\n\t\t\t\treturn FALSE;\n\t\t\toutSize--;\n\t\t\t*out++ = value;\n\t\t\tleft--;\n\t\t}\n\t}\n\tif ((outSize < 4) || (left < 4))\n\t\treturn FALSE;\n\tmemcpy(out, in, 4);\n\treturn TRUE;\n}", "target": 1}
{"code": "int firstBitSet(int x)\n{\n        int position=0;\n        while (x!=0)\n        {\n                x>>=1;\n                ++position;\n        }\n        return position;\n}", "target": 0}
{"code": "print_prefix(netdissect_options *ndo, const u_char *prefix, u_int max_length)\n{\n    int plenbytes;\n    char buf[sizeof(\"xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx::/128\")];\n    if (prefix[0] >= 96 && max_length >= IPV4_MAPPED_HEADING_LEN + 1 &&\n        is_ipv4_mapped_address(&prefix[1])) {\n        struct in_addr addr;\n        u_int plen;\n        plen = prefix[0]-96;\n        if (32 < plen)\n            return -1;\n        max_length -= 1;\n        memset(&addr, 0, sizeof(addr));\n        plenbytes = (plen + 7) / 8;\n        if (max_length < (u_int)plenbytes + IPV4_MAPPED_HEADING_LEN)\n            return -3;\n        memcpy(&addr, &prefix[1 + IPV4_MAPPED_HEADING_LEN], plenbytes);\n        if (plen % 8) {\n\t\t((u_char *)&addr)[plenbytes - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n\tsnprintf(buf, sizeof(buf), \"%s/%d\", ipaddr_string(ndo, &addr), plen);\n        plenbytes += 1 + IPV4_MAPPED_HEADING_LEN;\n    } else {\n        plenbytes = decode_prefix6(ndo, prefix, max_length, buf, sizeof(buf));\n        if (plenbytes < 0)\n            return plenbytes;\n    }\n    ND_PRINT((ndo, \"%s\", buf));\n    return plenbytes;\n}", "target": 0}
{"code": "static void vgacon_scrollback_startup(void)\n{\n\tvgacon_scrollback_cur = &vgacon_scrollbacks[0];\n\tvgacon_scrollback_init(0);\n}", "target": 1}
{"code": "struct tcp_conn_t *tcp_conn_select(struct tcp_sock_t *sock,\n\t\t\t\t   struct tcp_sock_t *sock6)\n{\n\tstruct tcp_conn_t *conn = calloc(1, sizeof *conn);\n\tif (conn == NULL) {\n\t\tERR(\"Calloc for connection struct failed\");\n\t\tgoto error;\n\t}\n\tfd_set rfds;\n\tstruct timeval tv;\n\tint retval = 0;\n\tint nfds = 0;\n\twhile (retval == 0) {\n\t\tFD_ZERO(&rfds);\n\t\tif (sock) {\n\t\t\tFD_SET(sock->sd, &rfds);\n\t\t\tnfds = sock->sd;\n\t\t}\n\t\tif (sock6) {\n\t\t\tFD_SET(sock6->sd, &rfds);\n\t\t\tif (sock6->sd > nfds)\n\t\t\t\tnfds = sock6->sd;\n\t\t}\n\t\tif (nfds == 0) {\n\t\t\tERR(\"No valid TCP socket supplied.\");\n\t\t\tgoto error;\n\t\t}\n\t\tnfds += 1;\n\t\ttv.tv_sec = 5;\n\t\ttv.tv_usec = 0;\n\t\tretval = select(nfds, &rfds, NULL, NULL, &tv);\n\t\tif (retval == -1) {\n\t\t\tERR(\"Failed to open tcp connection\");\n\t\t\tgoto error;\n\t\t}\n\t}\n\tif (sock && FD_ISSET(sock->sd, &rfds)) {\n\t\tconn->sd = accept(sock->sd, NULL, NULL);\n\t\tNOTE (\"Using IPv4\");\n\t} else if (sock6 && FD_ISSET(sock6->sd, &rfds)) {\n\t\tconn->sd = accept(sock6->sd, NULL, NULL);\n\t\tNOTE (\"Using IPv6\");\n\t} else {\n\t\tERR(\"select failed\");\n\t\tgoto error;\n\t}\n\tif (conn->sd < 0) {\n\t\tERR(\"accept failed\");\n\t\tgoto error;\n\t}\n\treturn conn;\nerror:\n\tif (conn != NULL)\n\t\tfree(conn);\n\treturn NULL;\n}", "target": 0}
{"code": "static void php_array_replace_recursive(PointerSet &seen, bool check,\n                                        Array &arr1, const Array& arr2) {\n  if (arr1.get() == arr2.get()) {\n    return;\n  }\n  if (check && !seen.insert((void*)arr1.get()).second) {\n    raise_warning(\"array_replace_recursive(): recursion detected\");\n    return;\n  }\n  for (ArrayIter iter(arr2); iter; ++iter) {\n    Variant key = iter.first();\n    const Variant& value = iter.secondRef();\n    if (arr1.exists(key, true) && value.isArray()) {\n      Variant &v = arr1.lvalAt(key, AccessFlags::Key);\n      if (v.isArray()) {\n        Array subarr1 = v.toArray();\n        const ArrNR& arr_value = value.toArrNR();\n        php_array_replace_recursive(seen, couldRecur(v, subarr1.get()),\n                                    subarr1, arr_value);\n        v = subarr1;\n      } else {\n        arr1.set(key, value, true);\n      }\n    } else {\n      arr1.setWithRef(key, value, true);\n    }\n  }\n  if (check) {\n    seen.erase((void*)arr1.get());\n  }\n}", "target": 0}
{"code": "void __mb2_cache_entry_free(struct mb2_cache_entry *entry)\n{\n\tkmem_cache_free(mb2_entry_cache, entry);\n}", "target": 0}
{"code": "static inline int http_test_encoded_path(const char *mem, size_t len) {\n  const char *pos = NULL;\n  const char *end = mem + len;\n  while (mem < end && (pos = memchr(mem, '/', (size_t)len))) {\n    len = end - pos;\n    mem = pos + 1;\n    if (pos[1] == '/')\n      return -1;\n    if (len > 3 && pos[1] == '.' && pos[2] == '.' && pos[3] == '/')\n      return -1;\n  }\n  return 0;\n}", "target": 0}
{"code": "      TF_EXCLUSIVE_LOCKS_REQUIRED(mu_) {\n    if (tuple[index].has_value()) {\n      return Status(errors::InvalidArgument(\n          \"The tensor for index '\", index, \"' for key '\", key.scalar<int64>()(),\n          \"' was already initialized '\", dtypes_.size(), \"'.\"));\n    }\n    return Status::OK();\n  }", "target": 1}
{"code": "static void vgacon_putc(struct vc_data *vc, int c, int ypos, int xpos) { }", "target": 0}
{"code": "void hincrbyfloatCommand(client *c) {\n    long double value, incr;\n    long long ll;\n    robj *o;\n    sds new;\n    unsigned char *vstr;\n    unsigned int vlen;\n    if (getLongDoubleFromObjectOrReply(c,c->argv[3],&incr,NULL) != C_OK) return;\n    if (isnan(incr) || isinf(incr)) {\n        addReplyError(c,\"value is NaN or Infinity\");\n        return;\n    }\n    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;\n    if (hashTypeGetValue(o,c->argv[2]->ptr,&vstr,&vlen,&ll) == C_OK) {\n        if (vstr) {\n            if (string2ld((char*)vstr,vlen,&value) == 0) {\n                addReplyError(c,\"hash value is not a float\");\n                return;\n            }\n        } else {\n            value = (long double)ll;\n        }\n    } else {\n        value = 0;\n    }\n    value += incr;\n    if (isnan(value) || isinf(value)) {\n        addReplyError(c,\"increment would produce NaN or Infinity\");\n        return;\n    }\n    char buf[MAX_LONG_DOUBLE_CHARS];\n    int len = ld2string(buf,sizeof(buf),value,LD_STR_HUMAN);\n    new = sdsnewlen(buf,len);\n    hashTypeSet(o,c->argv[2]->ptr,new,HASH_SET_TAKE_VALUE);\n    addReplyBulkCBuffer(c,buf,len);\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_HASH,\"hincrbyfloat\",c->argv[1],c->db->id);\n    server.dirty++;\n    robj *newobj;\n    newobj = createRawStringObject(buf,len);\n    rewriteClientCommandArgument(c,0,shared.hset);\n    rewriteClientCommandArgument(c,3,newobj);\n    decrRefCount(newobj);\n}", "target": 0}
{"code": "static int ntlm_decode_u16l_str_hdr(struct ntlm_ctx *ctx,\n                                    struct wire_field_hdr *str_hdr,\n                                    struct ntlm_buffer *buffer,\n                                    size_t payload_offs, char **str)\n{\n    char *in, *out = NULL;\n    uint16_t str_len;\n    uint32_t str_offs;\n    size_t outlen = 0;\n    int ret = 0;\n    str_len = le16toh(str_hdr->len);\n    if (str_len == 0) goto done;\n    str_offs = le32toh(str_hdr->offset);\n    if ((str_offs < payload_offs) ||\n        (str_offs > buffer->length) ||\n        (UINT32_MAX - str_offs < str_len) ||\n        (str_offs + str_len > buffer->length)) {\n        return ERR_DECODE;\n    }\n    in = (char *)&buffer->data[str_offs];\n    out = malloc(str_len * 2 + 1);\n    if (!out) return ENOMEM;\n    ret = ntlm_str_convert(ctx->to_oem, in, out, str_len, &outlen);\ndone:\n    if (ret) {\n        safefree(out);\n    } else {\n        out[outlen] = '\\0';\n    }\n    *str = out;\n    return ret;\n}", "target": 0}
{"code": "static void check_hostalias(request_rec *r)\n{\n    const char *host = r->hostname;\n    apr_port_t port;\n    server_rec *s;\n    server_rec *virthost_s;\n    server_rec *last_s;\n    name_chain *src;\n    virthost_s = NULL;\n    last_s = NULL;\n    port = r->connection->local_addr->port;\n    for (src = r->connection->vhost_lookup_data; src; src = src->next) {\n        server_addr_rec *sar;\n        sar = src->sar;\n        if (sar->host_port != 0 && port != sar->host_port) {\n            continue;\n        }\n        s = src->server;\n        if (s != last_s) {\n            if (matches_aliases(s, host)) {\n                goto found;\n            }\n        }\n        if (!strcasecmp(host, sar->virthost)) {\n            if (virthost_s == NULL) {\n                virthost_s = s;\n            }\n        }\n        last_s = s;\n    }\n    if (virthost_s) {\n        s = virthost_s;\n        goto found;\n    }\n    return;\nfound:\n    r->server = s;\n}", "target": 1}
{"code": "void Lab2ITU(const cmsCIELab* Lab, cmsUInt16Number Out[3])\n{\n\tOut[0] = (cmsUInt16Number) floor((double) (Lab -> L / 100.)* 65535. );\n\tOut[1] = (cmsUInt16Number) floor((double) (Lab -> a / 170.)* 65535. + 32768. );\n\tOut[2] = (cmsUInt16Number) floor((double) (Lab -> b / 200.)* 65535. + 24576. );\n}", "target": 0}
{"code": "int test_sqr(BIO *bp, BN_CTX *ctx)\n\t{\n\tBIGNUM a,c,d,e;\n\tint i;\n\tBN_init(&a);\n\tBN_init(&c);\n\tBN_init(&d);\n\tBN_init(&e);\n\tfor (i=0; i<num0; i++)\n\t\t{\n\t\tBN_bntest_rand(&a,40+i*10,0,0);\n\t\ta.neg=rand_neg();\n\t\tBN_sqr(&c,&a,ctx);\n\t\tif (bp != NULL)\n\t\t\t{\n\t\t\tif (!results)\n\t\t\t\t{\n\t\t\t\tBN_print(bp,&a);\n\t\t\t\tBIO_puts(bp,\" * \");\n\t\t\t\tBN_print(bp,&a);\n\t\t\t\tBIO_puts(bp,\" - \");\n\t\t\t\t}\n\t\t\tBN_print(bp,&c);\n\t\t\tBIO_puts(bp,\"\\n\");\n\t\t\t}\n\t\tBN_div(&d,&e,&c,&a,ctx);\n\t\tBN_sub(&d,&d,&a);\n\t\tif(!BN_is_zero(&d) || !BN_is_zero(&e))\n\t\t    {\n\t\t    fprintf(stderr,\"Square test failed!\\n\");\n\t\t    return 0;\n\t\t    }\n\t\t}\n\tBN_free(&a);\n\tBN_free(&c);\n\tBN_free(&d);\n\tBN_free(&e);\n\treturn(1);\n\t}", "target": 1}
{"code": "rs_filter_graph(RSFilter *filter)\n{\n\tg_return_if_fail(RS_IS_FILTER(filter));\n\tGString *str = g_string_new(\"digraph G {\\n\");\n\trs_filter_graph_helper(str, filter);\n\tg_string_append_printf(str, \"}\\n\");\n\tg_file_set_contents(\"/tmp/rs-filter-graph\", str->str, str->len, NULL);\n\tif (0 != system(\"dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph\"))\n\t\tg_warning(\"Calling dot failed\");\n\tif (0 != system(\"gnome-open /tmp/rs-filter-graph.png\"))\n\t\tg_warning(\"Calling gnome-open failed.\");\n\tg_string_free(str, TRUE);\n}", "target": 1}
{"code": "int64_t OutputFile::readImpl(char* , int64_t ) {\n  raise_warning(\"cannot read from a php:\n  return -1;\n}", "target": 1}
{"code": " */\nstatic int wddx_stack_destroy(wddx_stack *stack)\n{\n\tregister int i;\n\tif (stack->elements) {\n\t\tfor (i = 0; i < stack->top; i++) {\n\t\t\tif (((st_entry *)stack->elements[i])->data)\t{\n\t\t\t\tzval_ptr_dtor(&((st_entry *)stack->elements[i])->data);\n\t\t\t}\n\t\t\tif (((st_entry *)stack->elements[i])->varname) {\n\t\t\t\tefree(((st_entry *)stack->elements[i])->varname);\n\t\t\t}\n\t\t\tefree(stack->elements[i]);\n\t\t}\n\t\tefree(stack->elements);\n\t}\n\treturn SUCCESS;", "target": 1}
{"code": "bool ExtractUnixLink50(CommandData *Cmd,const wchar *Name,FileHeader *hd)\n{\n  char Target[NM];\n  WideToChar(hd->RedirName,Target,ASIZE(Target));\n  if (hd->RedirType==FSREDIR_WINSYMLINK || hd->RedirType==FSREDIR_JUNCTION)\n  {\n    if (strncmp(Target,\"\\\\??\\\\\",4)==0 || strncmp(Target,\"/\\?\\?/\",4)==0)\n      return false;\n    DosSlashToUnix(Target,Target,ASIZE(Target));\n  }\n  wchar TargetW[NM];\n  if (!SafeCharToWide(Target,TargetW,ASIZE(TargetW)))\n    return false;\n  if (!Cmd->AbsoluteLinks && (IsFullPath(TargetW) ||\n      !IsRelativeSymlinkSafe(Cmd,hd->FileName,Name,TargetW)))\n    return false;\n  return UnixSymlink(Cmd,Target,Name,&hd->mtime,&hd->atime);\n}", "target": 1}
{"code": "GF_EXPORT\nGF_Err gf_isom_box_write(GF_Box *a, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu64 pos = gf_bs_get_position(bs);\n\tif (!a) return GF_BAD_PARAM;\n\tif (!a->size) return GF_OK;\n\tif (a->registry->disabled) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box %s disabled registry, skip write\\n\", gf_4cc_to_str(a->type)));\n\t\treturn GF_OK;\n\t}\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box %s size %d write\\n\", gf_4cc_to_str(a->type), a->size));\n\te = gf_isom_box_write_listing(a, bs);\n\tif (e) return e;\n\tif (a->child_boxes) {\n\t\te = gf_isom_box_array_write(a, a->child_boxes, bs);\n\t}\n\tpos = gf_bs_get_position(bs) - pos;\n\tif (pos != a->size) {\n\t\tif (a->type != GF_ISOM_BOX_TYPE_MDAT) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box %s wrote \"LLU\" bytes but size is \"LLU\"\\n\", gf_4cc_to_str(a->type), pos, a->size ));\n\t\t}\n\t}\n\treturn e;", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    PoolParameters params{context,\n                          ksize_,\n                          stride_,\n                          padding_,\n                          {},\n                          FORMAT_NHWC,\n                          tensor_in.shape()};\n    if (!context->status().ok()) {\n      return;\n    }\n    const float min_input = context->input(1).flat<float>()(0);\n    const float max_input = context->input(2).flat<float>()(0);\n    OP_REQUIRES(context, params.depth_window == 1,\n                errors::Unimplemented(\"Non-spatial pooling is not \"\n                                      \"yet supported. Volunteers? :)\"));\n    OP_REQUIRES(context, tensor_in.dims() == 4,\n                errors::InvalidArgument(\"tensor_in must be 4-dimensional\"));\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                0, params.forward_output_shape(), &output));\n    const int32_t highest = static_cast<int32>(Eigen::NumTraits<T>::highest());\n    const int32_t lowest = static_cast<int32>(Eigen::NumTraits<T>::lowest());\n    Tensor int32_output(DT_INT32, params.forward_output_shape());\n    Tensor int32_input(DT_INT32, tensor_in.shape());\n    int32_input.flat<int32>() = tensor_in.flat<T>().template cast<int32>();\n    SpatialAvgPool<Device, int32>(context, &int32_output, int32_input, params,\n                                  padding_);\n    output->flat<T>() = int32_output.flat<int32>()\n                            .cwiseMax(lowest)\n                            .cwiseMin(highest)\n                            .template cast<T>();\n    Tensor* output_min = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, {}, &output_min));\n    output_min->flat<float>()(0) = min_input;\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(2, {}, &output_max));\n    output_max->flat<float>()(0) = max_input;\n  }", "target": 1}
{"code": "static unsigned long pfn_max_align_down(unsigned long pfn)\n{\n\treturn pfn & ~(max_t(unsigned long, MAX_ORDER_NR_PAGES,\n\t\t\t     pageblock_nr_pages) - 1);\n}", "target": 0}
{"code": "static int ReadHuffmanCode(int alphabet_size, VP8LDecoder* const dec,\n                           int* const code_lengths, HuffmanCode* const table) {\n  int ok = 0;\n  int size = 0;\n  VP8LBitReader* const br = &dec->br_;\n  const int simple_code = VP8LReadBits(br, 1);\n  memset(code_lengths, 0, alphabet_size * sizeof(*code_lengths));\n  if (simple_code) {  \n    const int num_symbols = VP8LReadBits(br, 1) + 1;\n    const int first_symbol_len_code = VP8LReadBits(br, 1);\n    int symbol = VP8LReadBits(br, (first_symbol_len_code == 0) ? 1 : 8);\n    code_lengths[symbol] = 1;\n    if (num_symbols == 2) {\n      symbol = VP8LReadBits(br, 8);\n      code_lengths[symbol] = 1;\n    }\n    ok = 1;\n  } else {  \n    int i;\n    int code_length_code_lengths[NUM_CODE_LENGTH_CODES] = { 0 };\n    const int num_codes = VP8LReadBits(br, 4) + 4;\n    assert(num_codes <= NUM_CODE_LENGTH_CODES);\n    for (i = 0; i < num_codes; ++i) {\n      code_length_code_lengths[kCodeLengthCodeOrder[i]] = VP8LReadBits(br, 3);\n    }\n    ok = ReadHuffmanCodeLengths(dec, code_length_code_lengths, alphabet_size,\n                                code_lengths);\n  }\n  ok = ok && !br->eos_;\n  if (ok) {\n    size = VP8LBuildHuffmanTable(table, HUFFMAN_TABLE_BITS,\n                                 code_lengths, alphabet_size);\n  }\n  if (!ok || size == 0) {\n    return VP8LSetError(dec, VP8_STATUS_BITSTREAM_ERROR);\n  }\n  return size;\n}", "target": 1}
{"code": "vte_sequence_handler_dc (VteTerminal *terminal, GValueArray *params)\n{\n\tVteScreen *screen;\n\tVteRowData *rowdata;\n\tlong col;\n\tscreen = terminal->pvt->screen;\n\tif (_vte_ring_next(screen->row_data) > screen->cursor_current.row) {\n\t\tlong len;\n\t\trowdata = _vte_ring_index(screen->row_data,\n\t\t\t\t\t  VteRowData *,\n\t\t\t\t\t  screen->cursor_current.row);\n\t\tg_assert(rowdata != NULL);\n\t\tcol = screen->cursor_current.col;\n\t\tlen = rowdata->cells->len;\n\t\tif (col < len) {\n\t\t\tg_array_remove_index(rowdata->cells, col);\n\t\t\tif (screen->fill_defaults.attr.back != VTE_DEF_BG) {\n\t\t\t\tvte_g_array_fill (rowdata->cells,\n\t\t\t\t\t\t&screen->fill_defaults,\n\t\t\t\t\t\tterminal->column_count);\n\t\t\t\tlen = terminal->column_count;\n\t\t\t}\n\t\t\t_vte_invalidate_cells(terminal,\n\t\t\t\t\tcol, len - col,\n\t\t\t\t\tscreen->cursor_current.row, 1);\n\t\t}\n\t}\n\tterminal->pvt->text_deleted_flag = TRUE;\n}", "target": 0}
{"code": "void Archive::Seek(int64 Offset,int Method)\n{\n  if (!QOpen.Seek(Offset,Method))\n    File::Seek(Offset,Method);\n}", "target": 1}
{"code": "Status SparseTensorFromContext(OpKernelContext* ctx, const int32_t base_index,\n                               const bool validate_indices,\n                               sparse::SparseTensor* tensor) {\n  TensorShape shape;\n  TF_RETURN_IF_ERROR(TensorShape::BuildTensorShape(\n      ctx->input(base_index + 2).vec<int64_t>(), &shape));\n  CheckRankAtLeast2(ctx, shape);\n  std::vector<int64_t> order(shape.dims());\n  std::iota(order.begin(), order.end(), 0);\n  Status status = sparse::SparseTensor::Create(\n      ctx->input(base_index), ctx->input(base_index + 1), shape, order, tensor);\n  if (!validate_indices || !status.ok()) return status;\n  return tensor->IndicesValid();\n}", "target": 1}
{"code": "void rose_link_failed(ax25_cb *ax25, int reason)\n{\n\tstruct rose_neigh *rose_neigh;\n\tspin_lock_bh(&rose_neigh_list_lock);\n\trose_neigh = rose_neigh_list;\n\twhile (rose_neigh != NULL) {\n\t\tif (rose_neigh->ax25 == ax25)\n\t\t\tbreak;\n\t\trose_neigh = rose_neigh->next;\n\t}\n\tif (rose_neigh != NULL) {\n\t\trose_neigh->ax25 = NULL;\n\t\tax25_cb_put(ax25);\n\t\trose_del_route_by_neigh(rose_neigh);\n\t\trose_kill_by_neigh(rose_neigh);\n\t}\n\tspin_unlock_bh(&rose_neigh_list_lock);\n}", "target": 0}
{"code": "BOOL security_decrypt(BYTE* data, int length, rdpRdp* rdp)\n{\n\tif (rdp->rc4_decrypt_key == NULL)\n\t\treturn FALSE;\n\tif (rdp->decrypt_use_count >= 4096)\n\t{\n\t\tsecurity_key_update(rdp->decrypt_key, rdp->decrypt_update_key, rdp->rc4_key_len);\n\t\tcrypto_rc4_free(rdp->rc4_decrypt_key);\n\t\trdp->rc4_decrypt_key = crypto_rc4_init(rdp->decrypt_key, rdp->rc4_key_len);\n\t\trdp->decrypt_use_count = 0;\n\t}\n\tcrypto_rc4(rdp->rc4_decrypt_key, length, data, data);\n\trdp->decrypt_use_count += 1;\n\trdp->decrypt_checksum_use_count++;\n\treturn TRUE;\n}", "target": 0}
{"code": "static int dccp_error(struct net *net, struct nf_conn *tmpl,\n\t\t      struct sk_buff *skb, unsigned int dataoff,\n\t\t      enum ip_conntrack_info *ctinfo,\n\t\t      u_int8_t pf, unsigned int hooknum)\n{\n\tstruct dccp_hdr _dh, *dh;\n\tunsigned int dccp_len = skb->len - dataoff;\n\tunsigned int cscov;\n\tconst char *msg;\n\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);\n\tif (dh == NULL) {\n\t\tmsg = \"nf_ct_dccp: short packet \";\n\t\tgoto out_invalid;\n\t}\n\tif (dh->dccph_doff * 4 < sizeof(struct dccp_hdr) ||\n\t    dh->dccph_doff * 4 > dccp_len) {\n\t\tmsg = \"nf_ct_dccp: truncated/malformed packet \";\n\t\tgoto out_invalid;\n\t}\n\tcscov = dccp_len;\n\tif (dh->dccph_cscov) {\n\t\tcscov = (dh->dccph_cscov - 1) * 4;\n\t\tif (cscov > dccp_len) {\n\t\t\tmsg = \"nf_ct_dccp: bad checksum coverage \";\n\t\t\tgoto out_invalid;\n\t\t}\n\t}\n\tif (net->ct.sysctl_checksum && hooknum == NF_INET_PRE_ROUTING &&\n\t    nf_checksum_partial(skb, hooknum, dataoff, cscov, IPPROTO_DCCP,\n\t\t\t\tpf)) {\n\t\tmsg = \"nf_ct_dccp: bad checksum \";\n\t\tgoto out_invalid;\n\t}\n\tif (dh->dccph_type >= DCCP_PKT_INVALID) {\n\t\tmsg = \"nf_ct_dccp: reserved packet type \";\n\t\tgoto out_invalid;\n\t}\n\treturn NF_ACCEPT;\nout_invalid:\n\tif (LOG_INVALID(net, IPPROTO_DCCP))\n\t\tnf_log_packet(net, pf, 0, skb, NULL, NULL, NULL, \"%s\", msg);\n\treturn -NF_ACCEPT;\n}", "target": 1}
{"code": "void btrfs_assign_next_active_device(struct btrfs_device *device,\n\t\t\t\t     struct btrfs_device *this_dev)\n{\n\tstruct btrfs_fs_info *fs_info = device->fs_info;\n\tstruct btrfs_device *next_device;\n\tif (this_dev)\n\t\tnext_device = this_dev;\n\telse\n\t\tnext_device = btrfs_find_next_active_device(fs_info->fs_devices,\n\t\t\t\t\t\t\t\tdevice);\n\tASSERT(next_device);\n\tif (fs_info->sb->s_bdev &&\n\t\t\t(fs_info->sb->s_bdev == device->bdev))\n\t\tfs_info->sb->s_bdev = next_device->bdev;\n\tif (fs_info->fs_devices->latest_bdev == device->bdev)\n\t\tfs_info->fs_devices->latest_bdev = next_device->bdev;\n}", "target": 0}
{"code": "static void enable_nmi_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tif ((svm->vcpu.arch.hflags & (HF_NMI_MASK | HF_IRET_MASK))\n\t    == HF_NMI_MASK)\n\t\treturn; \n\tsvm->nmi_singlestep = true;\n\tsvm->vmcb->save.rflags |= (X86_EFLAGS_TF | X86_EFLAGS_RF);\n\tupdate_db_bp_intercept(vcpu);\n}", "target": 1}
{"code": "static struct sock *sctp_v6_create_accept_sk(struct sock *sk,\n\t\t\t\t\t     struct sctp_association *asoc,\n\t\t\t\t\t     bool kern)\n{\n\tstruct sock *newsk;\n\tstruct ipv6_pinfo *newnp, *np = inet6_sk(sk);\n\tstruct sctp6_sock *newsctp6sk;\n\tstruct ipv6_txoptions *opt;\n\tnewsk = sk_alloc(sock_net(sk), PF_INET6, GFP_KERNEL, sk->sk_prot, kern);\n\tif (!newsk)\n\t\tgoto out;\n\tsock_init_data(NULL, newsk);\n\tsctp_copy_sock(newsk, sk, asoc);\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\tnewsctp6sk = (struct sctp6_sock *)newsk;\n\tinet_sk(newsk)->pinet6 = &newsctp6sk->inet6;\n\tsctp_sk(newsk)->v4mapped = sctp_sk(sk)->v4mapped;\n\tnewnp = inet6_sk(newsk);\n\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\tnewnp->ipv6_mc_list = NULL;\n\tnewnp->ipv6_ac_list = NULL;\n\tnewnp->ipv6_fl_list = NULL;\n\trcu_read_lock();\n\topt = rcu_dereference(np->opt);\n\tif (opt)\n\t\topt = ipv6_dup_options(newsk, opt);\n\tRCU_INIT_POINTER(newnp->opt, opt);\n\trcu_read_unlock();\n\tsctp_v6_to_sk_daddr(&asoc->peer.primary_addr, newsk);\n\tnewsk->sk_v6_rcv_saddr = sk->sk_v6_rcv_saddr;\n\tsk_refcnt_debug_inc(newsk);\n\tif (newsk->sk_prot->init(newsk)) {\n\t\tsk_common_release(newsk);\n\t\tnewsk = NULL;\n\t}\nout:\n\treturn newsk;\n}", "target": 0}
{"code": "void CClient::EchoMessage(const CMessage& Message) {\n    CMessage EchoedMessage = Message;\n    for (CClient* pClient : GetClients()) {\n        if (pClient->HasEchoMessage() ||\n            (pClient != this && (m_pNetwork->IsChan(Message.GetParam(0)) ||\n                                 pClient->HasSelfMessage()))) {\n            EchoedMessage.SetNick(GetNickMask());\n            pClient->PutClient(EchoedMessage);\n        }\n    }\n}", "target": 1}
{"code": "TfLiteStatus PrepareHashtableSize(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input_resource_id_tensor =\n      GetInput(context, node, kInputResourceIdTensor);\n  TF_LITE_ENSURE_EQ(context, input_resource_id_tensor->type, kTfLiteInt32);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input_resource_id_tensor), 1);\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(input_resource_id_tensor, 0), 1);\n  TfLiteTensor* output_tensor = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output_tensor != nullptr);\n  TF_LITE_ENSURE_EQ(context, output_tensor->type, kTfLiteInt64);\n  TfLiteIntArray* outputSize = TfLiteIntArrayCreate(1);\n  outputSize->data[0] = 1;\n  return context->ResizeTensor(context, output_tensor, outputSize);\n}", "target": 1}
{"code": "int main(int argc, char *argv[])\n{\n\tint ret;\n\tstruct lxc_lock *lock;\n\tlock = lxc_newlock(NULL, NULL);\n\tif (!lock) {\n\t\tfprintf(stderr, \"%d: failed to get unnamed lock\\n\", __LINE__);\n\t\texit(1);\n\t}\n\tret = lxclock(lock, 0);\n\tif (ret) {\n\t\tfprintf(stderr, \"%d: failed to take unnamed lock (%d)\\n\", __LINE__, ret);\n\t\texit(1);\n\t}\n\tret = lxcunlock(lock);\n\tif (ret) {\n\t\tfprintf(stderr, \"%d: failed to put unnamed lock (%d)\\n\", __LINE__, ret);\n\t\texit(1);\n\t}\n\tlxc_putlock(lock);\n\tlock = lxc_newlock(\"/var/lib/lxc\", mycontainername);\n\tif (!lock) {\n\t\tfprintf(stderr, \"%d: failed to get lock\\n\", __LINE__);\n\t\texit(1);\n\t}\n\tstruct stat sb;\n\tchar *pathname = RUNTIME_PATH \"/lock/lxc/var/lib/lxc/\";\n\tret = stat(pathname, &sb);\n\tif (ret != 0) {\n\t\tfprintf(stderr, \"%d: filename %s not created\\n\", __LINE__,\n\t\t\tpathname);\n\t\texit(1);\n\t}\n\tlxc_putlock(lock);\n\ttest_two_locks();\n\tfprintf(stderr, \"all tests passed\\n\");\n\texit(ret);\n}", "target": 1}
{"code": "frag6_print(netdissect_options *ndo, register const u_char *bp, register const u_char *bp2)\n{\n\tregister const struct ip6_frag *dp;\n\tregister const struct ip6_hdr *ip6;\n\tdp = (const struct ip6_frag *)bp;\n\tip6 = (const struct ip6_hdr *)bp2;\n\tND_TCHECK(dp->ip6f_offlg);\n\tif (ndo->ndo_vflag) {\n\t\tND_PRINT((ndo, \"frag (0x%08x:%d|%ld)\",\n\t\t       EXTRACT_32BITS(&dp->ip6f_ident),\n\t\t       EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK,\n\t\t       sizeof(struct ip6_hdr) + EXTRACT_16BITS(&ip6->ip6_plen) -\n\t\t\t       (long)(bp - bp2) - sizeof(struct ip6_frag)));\n\t} else {\n\t\tND_PRINT((ndo, \"frag (%d|%ld)\",\n\t\t       EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK,\n\t\t       sizeof(struct ip6_hdr) + EXTRACT_16BITS(&ip6->ip6_plen) -\n\t\t\t       (long)(bp - bp2) - sizeof(struct ip6_frag)));\n\t}\n\tif ((EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK) != 0)\n\t\treturn -1;\n\telse\n\t{\n\t\tND_PRINT((ndo, \" \"));\n\t\treturn sizeof(struct ip6_frag);\n\t}\ntrunc:\n\tND_PRINT((ndo, \"[|frag]\"));\n\treturn -1;\n}", "target": 1}
{"code": "static int cac_cac1_get_certificate(sc_card_t *card, u8 **out_buf, size_t *out_len)\n{\n\tu8 buf[CAC_MAX_SIZE];\n\tu8 *out_ptr;\n\tsize_t size = 0;\n\tsize_t left = 0;\n\tsize_t len, next_len;\n\tsc_apdu_t apdu;\n\tint r = SC_SUCCESS;\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tsize = left = *out_buf ? *out_len : sizeof(buf);\n\tout_ptr = *out_buf ? *out_buf : buf;\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, CAC_INS_GET_CERTIFICATE, 0, 0 );\n\tnext_len = MIN(left, 100);\n\tfor (; left > 0; left -= len, out_ptr += len) {\n\t\tlen = next_len;\n\t\tapdu.resp = out_ptr;\n\t\tapdu.le = len;\n\t\tapdu.resplen = left;\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t\tif (r < 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (apdu.resplen == 0) {\n\t\t\tr = SC_ERROR_INTERNAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (apdu.sw1 != 0x63 || apdu.sw2 < 1)  {\n\t\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\t\tleft -= len;\n\t\t\tbreak;\n\t\t}\n\t\tnext_len = MIN(left, apdu.sw2);\n\t}\n\tif (r < 0) {\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);\n\t}\n\tr = size - left;\n\tif (*out_buf == NULL) {\n\t\t*out_buf = malloc(r);\n\t\tif (*out_buf == NULL) {\n\t\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t\tSC_ERROR_OUT_OF_MEMORY);\n\t\t}\n\t\tmemcpy(*out_buf, buf, r);\n\t}\n\t*out_len = r;\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);\n}", "target": 1}
{"code": "static ssize_t __disk_events_show(unsigned int events, char *buf)\n{\n\tconst char *delim = \"\";\n\tssize_t pos = 0;\n\tint i;\n\tfor (i = 0; i < ARRAY_SIZE(disk_events_strs); i++)\n\t\tif (events & (1 << i)) {\n\t\t\tpos += sprintf(buf + pos, \"%s%s\",\n\t\t\t\t       delim, disk_events_strs[i]);\n\t\t\tdelim = \" \";\n\t\t}\n\tif (pos)\n\t\tpos += sprintf(buf + pos, \"\\n\");\n\treturn pos;\n}", "target": 0}
{"code": "int BN_bn2bin(const BIGNUM *a, unsigned char *to)\n{\n    return bn2binpad(a, to, -1);\n}", "target": 0}
{"code": "void isdn_ppp_receive(isdn_net_dev *net_dev, isdn_net_local *lp, struct sk_buff *skb)\n{\n\tstruct ippp_struct *is;\n\tint slot;\n\tint proto;\n\tBUG_ON(net_dev->local->master); \n\tslot = lp->ppp_slot;\n\tif (slot < 0 || slot >= ISDN_MAX_CHANNELS) {\n\t\tprintk(KERN_ERR \"isdn_ppp_receive: lp->ppp_slot(%d)\\n\",\n\t\t       lp->ppp_slot);\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\tis = ippp_table[slot];\n\tif (is->debug & 0x4) {\n\t\tprintk(KERN_DEBUG \"ippp_receive: is:%08lx lp:%08lx slot:%d unit:%d len:%d\\n\",\n\t\t       (long)is, (long)lp, lp->ppp_slot, is->unit, (int)skb->len);\n\t\tisdn_ppp_frame_log(\"receive\", skb->data, skb->len, 32, is->unit, lp->ppp_slot);\n\t}\n\tif (isdn_ppp_skip_ac(is, skb) < 0) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\tproto = isdn_ppp_strip_proto(skb);\n\tif (proto < 0) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n#ifdef CONFIG_ISDN_MPP\n\tif (is->compflags & SC_LINK_DECOMP_ON) {\n\t\tskb = isdn_ppp_decompress(skb, is, NULL, &proto);\n\t\tif (!skb) \n\t\t\treturn;\n\t}\n\tif (!(is->mpppcfg & SC_REJ_MP_PROT)) { \n\t\tif (proto == PPP_MP) {\n\t\t\tisdn_ppp_mp_receive(net_dev, lp, skb);\n\t\t\treturn;\n\t\t}\n\t}\n#endif\n\tisdn_ppp_push_higher(net_dev, lp, skb, proto);\n}", "target": 0}
{"code": "TfLiteStatus PrepareHashtableImport(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 3);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 0);\n  const TfLiteTensor* input_resource_id_tensor =\n      GetInput(context, node, kInputResourceIdTensor);\n  TF_LITE_ENSURE_EQ(context, input_resource_id_tensor->type, kTfLiteInt32);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input_resource_id_tensor), 1);\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(input_resource_id_tensor, 0), 1);\n  const TfLiteTensor* key_tensor = GetInput(context, node, kKeyTensor);\n  const TfLiteTensor* value_tensor = GetInput(context, node, kValueTensor);\n  TF_LITE_ENSURE(context, (key_tensor->type == kTfLiteInt64 &&\n                           value_tensor->type == kTfLiteString) ||\n                              (key_tensor->type == kTfLiteString &&\n                               value_tensor->type == kTfLiteInt64));\n  TF_LITE_ENSURE(context, HaveSameShapes(key_tensor, value_tensor));\n  return kTfLiteOk;\n}", "target": 1}
{"code": "GF_Err gf_swf_read_header(SWFReader *read)\n{\n\tSWFRec rc;\n\tu8 sig[3];\n\tsig[0] = gf_bs_read_u8(read->bs);\n\tsig[1] = gf_bs_read_u8(read->bs);\n\tsig[2] = gf_bs_read_u8(read->bs);\n\tif ( ((sig[0] != 'F') && (sig[0] != 'C')) || (sig[1] != 'W') || (sig[2] != 'S') ) {\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tgf_bs_read_u8(read->bs);\n\tread->length = swf_get_32(read);\n\tif (sig[0] == 'C') {\n\t\tswf_init_decompress(read);\n\t\tif (!read->bs) return GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tswf_get_rec(read, &rc);\n\tread->width = rc.w;\n\tread->height = rc.h;\n\tswf_align(read);\n\tread->frame_rate = swf_get_16(read)>>8;\n\tread->frame_count = swf_get_16(read);\n\tGF_LOG(GF_LOG_INFO, GF_LOG_PARSER, (\"SWF Import - Scene Size %gx%g - %d frames @ %d FPS\\n\", read->width, read->height, read->frame_count, read->frame_rate));\n\tif (!read->frame_rate) read->frame_rate = 1;\n\treturn GF_OK;\n}", "target": 0}
{"code": "static inline int cipso_v4_validate(const struct sk_buff *skb,\n\t\t\t\t    unsigned char **option)\n{\n\tunsigned char *opt = *option;\n\tunsigned char err_offset = 0;\n\tu8 opt_len = opt[1];\n\tu8 opt_iter;\n\tif (opt_len < 8) {\n\t\terr_offset = 1;\n\t\tgoto out;\n\t}\n\tif (get_unaligned_be32(&opt[2]) == 0) {\n\t\terr_offset = 2;\n\t\tgoto out;\n\t}\n\tfor (opt_iter = 6; opt_iter < opt_len;) {\n\t\tif (opt[opt_iter + 1] > (opt_len - opt_iter)) {\n\t\t\terr_offset = opt_iter + 1;\n\t\t\tgoto out;\n\t\t}\n\t\topt_iter += opt[opt_iter + 1];\n\t}\nout:\n\t*option = opt + err_offset;\n\treturn err_offset;\n}", "target": 1}
{"code": "static int ntlm_decode_field(struct wire_field_hdr *hdr,\n                             struct ntlm_buffer *buffer,\n                             size_t payload_offs,\n                             struct ntlm_buffer *field)\n{\n    struct ntlm_buffer b = { NULL, 0 };\n    uint32_t offs;\n    uint16_t len;\n    len = le16toh(hdr->len);\n    if (len == 0) goto done;\n    offs = le32toh(hdr->offset);\n    if ((offs < payload_offs) ||\n        (offs > buffer->length) ||\n        (UINT32_MAX - offs < len) ||\n        (offs + len > buffer->length)) {\n        return ERR_DECODE;\n    }\n    b.data = malloc(len);\n    if (!b.data) return ENOMEM;\n    b.length = len;\n    memcpy(b.data, &buffer->data[offs], b.length);\ndone:\n    *field = b;\n    return 0;\n}", "target": 0}
{"code": "static int bit_tohex(lua_State *L)\n{\n  UBits b = barg(L, 1);\n  SBits n = lua_isnone(L, 2) ? 8 : (SBits)barg(L, 2);\n  const char *hexdigits = \"0123456789abcdef\";\n  char buf[8];\n  int i;\n  if (n == INT32_MIN) n = INT32_MIN+1;\n  if (n < 0) { n = -n; hexdigits = \"0123456789ABCDEF\"; }\n  if (n > 8) n = 8;\n  for (i = (int)n; --i >= 0; ) { buf[i] = hexdigits[b & 15]; b >>= 4; }\n  lua_pushlstring(L, buf, (size_t)n);\n  return 1;\n}", "target": 0}
{"code": "void xenvif_disconnect(struct xenvif *vif)\n{\n\tstruct net_device *dev = vif->dev;\n\tif (netif_carrier_ok(dev)) {\n\t\trtnl_lock();\n\t\tnetif_carrier_off(dev); \n\t\tif (netif_running(dev))\n\t\t\txenvif_down(vif);\n\t\trtnl_unlock();\n\t\txenvif_put(vif);\n\t}\n\tatomic_dec(&vif->refcnt);\n\twait_event(vif->waiting_to_free, atomic_read(&vif->refcnt) == 0);\n\tdel_timer_sync(&vif->credit_timeout);\n\tif (vif->irq)\n\t\tunbind_from_irqhandler(vif->irq, vif);\n\tunregister_netdev(vif->dev);\n\txen_netbk_unmap_frontend_rings(vif);\n\tfree_netdev(vif->dev);\n}", "target": 1}
{"code": "        int    ReadDoubleArray(unsigned char *sString, int nLen, double (&pArray)[nMax])\n        {\n            int nStart = 0;\n            while( sString[nStart] != '[' )\n            {\n                nStart++;\n                if ( nStart >= nLen )\n                    return 0;\n            }\n            int nEnd = ++nStart;\n            while ( sString[nEnd] != ']' )\n            {\n                nEnd++;\n                if ( nEnd >= nLen )\n                    return 0;\n            }\n            sString = sString + nStart;\n            nLen    = nEnd - nStart;\n            int nCount = 0;\n            const int c_nNumLimit = 32;\n            unsigned char sBuffer[c_nNumLimit];\n            int nBufPos = 0;\n            bool bNewItem = true;\n            for ( int nIndex = 0; nIndex < nLen; ++nIndex )\n            {\n                unsigned char unChar = sString[nIndex];\n                if ( ' ' == unChar )\n                {\n                    if ( !bNewItem )\n                        bNewItem = true;\n                    continue;\n                }\n                if ( bNewItem )\n                {\n                    if ( nCount >= nMax )\n                        break;\n                    if ( nCount > 0 )\n                        pArray[nCount - 1] = Utils::GetDouble( (const char *)sBuffer );\n                    memset( sBuffer, 0x00, c_nNumLimit );\n                    nBufPos = 0;\n                    bNewItem = false;\n                    nCount++;\n                }\n                sBuffer[nBufPos++] = unChar;\n                if (nBufPos >= c_nNumLimit)\n                    break;\n            }\n            if ( 0 != sBuffer[0] && nCount > 0 )\n                pArray[nCount - 1] = Utils::GetDouble( (const char *)sBuffer );\n            return nCount;\n        }", "target": 0}
{"code": "static inline void exit_io_context(void)\n{\n}", "target": 1}
{"code": "static inline int restore_fpu_checking(struct task_struct *tsk)\n{\n\talternative_input(\n\t\tASM_NOP8 ASM_NOP2,\n\t\t\"emms\\n\\t\"\t\t\n\t\t\"fildl %P[addr]\",\t\n\t\tX86_FEATURE_FXSAVE_LEAK,\n\t\t[addr] \"m\" (tsk->thread.fpu.has_fpu));\n\treturn fpu_restore_checking(&tsk->thread.fpu);\n}", "target": 1}
{"code": "void tcp_rcv_space_adjust(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint time;\n\tint copied;\n\ttime = tcp_time_stamp - tp->rcvq_space.time;\n\tif (time < (tp->rcv_rtt_est.rtt >> 3) || tp->rcv_rtt_est.rtt == 0)\n\t\treturn;\n\tcopied = tp->copied_seq - tp->rcvq_space.seq;\n\tif (copied <= tp->rcvq_space.space)\n\t\tgoto new_measure;\n\tif (sysctl_tcp_moderate_rcvbuf &&\n\t    !(sk->sk_userlocks & SOCK_RCVBUF_LOCK)) {\n\t\tint rcvwin, rcvmem, rcvbuf;\n\t\trcvwin = (copied << 1) + 16 * tp->advmss;\n\t\tif (copied >=\n\t\t    tp->rcvq_space.space + (tp->rcvq_space.space >> 2)) {\n\t\t\tif (copied >=\n\t\t\t    tp->rcvq_space.space + (tp->rcvq_space.space >> 1))\n\t\t\t\trcvwin <<= 1;\n\t\t\telse\n\t\t\t\trcvwin += (rcvwin >> 1);\n\t\t}\n\t\trcvmem = SKB_TRUESIZE(tp->advmss + MAX_TCP_HEADER);\n\t\twhile (tcp_win_from_space(rcvmem) < tp->advmss)\n\t\t\trcvmem += 128;\n\t\trcvbuf = min(rcvwin / tp->advmss * rcvmem, sysctl_tcp_rmem[2]);\n\t\tif (rcvbuf > sk->sk_rcvbuf) {\n\t\t\tsk->sk_rcvbuf = rcvbuf;\n\t\t\ttp->window_clamp = rcvwin;\n\t\t}\n\t}\n\ttp->rcvq_space.space = copied;\nnew_measure:\n\ttp->rcvq_space.seq = tp->copied_seq;\n\ttp->rcvq_space.time = tcp_time_stamp;\n}", "target": 0}
{"code": "FILE *fopen_safe(const char *path, const char *mode)\n{\n\tint fd;\n\tFILE *file;\n\tint flags = O_NOFOLLOW | O_CREAT;\n\tif (mode[0] == 'r')\n\t\treturn fopen(path, mode);\n\tif (mode[0] != 'a' && mode[0] != 'w')\n\t\treturn NULL;\n\tif (mode[1] &&\n\t    (mode[1] != '+' || mode[2]))\n\t\treturn NULL;\n\tif (mode[0] == 'w')\n\t\tflags |= O_TRUNC;\n\telse\n\t\tflags |= O_APPEND;\n\tif (mode[1])\n\t\tflags |= O_RDWR;\n\telse\n\t\tflags |= O_WRONLY;\n\tfd = open(path, flags, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n\tif (fd == -1)\n\t\treturn NULL;\n\tfile = fdopen (fd, \"w\");\n\tif (!file) {\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\treturn file;\n}", "target": 0}
{"code": "static void zipfileDequote(char *zIn){\n  char q = zIn[0];\n  if( q=='\"' || q=='\\'' || q=='`' || q=='[' ){\n    int iIn = 1;\n    int iOut = 0;\n    if( q=='[' ) q = ']';\n    while( ALWAYS(zIn[iIn]) ){\n      char c = zIn[iIn++];\n      if( c==q && zIn[iIn++]!=q ) break;\n      zIn[iOut++] = c;\n    }\n    zIn[iOut] = '\\0';\n  }\n}", "target": 0}
{"code": "static int __init personal_pci_init(void)\n{\n\tif (machine_is_personal_server())\n\t\tpci_common_init(&personal_server_pci);\n\treturn 0;\n}", "target": 1}
{"code": "static int ieee80211_fragment(struct ieee80211_tx_data *tx,\n\t\t\t      struct sk_buff *skb, int hdrlen,\n\t\t\t      int frag_threshold)\n{\n\tstruct ieee80211_local *local = tx->local;\n\tstruct ieee80211_tx_info *info;\n\tstruct sk_buff *tmp;\n\tint per_fragm = frag_threshold - hdrlen - FCS_LEN;\n\tint pos = hdrlen + per_fragm;\n\tint rem = skb->len - hdrlen - per_fragm;\n\tif (WARN_ON(rem < 0))\n\t\treturn -EINVAL;\n\twhile (rem) {\n\t\tint fraglen = per_fragm;\n\t\tif (fraglen > rem)\n\t\t\tfraglen = rem;\n\t\trem -= fraglen;\n\t\ttmp = dev_alloc_skb(local->tx_headroom +\n\t\t\t\t    frag_threshold +\n\t\t\t\t    tx->sdata->encrypt_headroom +\n\t\t\t\t    IEEE80211_ENCRYPT_TAILROOM);\n\t\tif (!tmp)\n\t\t\treturn -ENOMEM;\n\t\t__skb_queue_tail(&tx->skbs, tmp);\n\t\tskb_reserve(tmp,\n\t\t\t    local->tx_headroom + tx->sdata->encrypt_headroom);\n\t\tmemcpy(tmp->cb, skb->cb, sizeof(tmp->cb));\n\t\tinfo = IEEE80211_SKB_CB(tmp);\n\t\tinfo->flags &= ~(IEEE80211_TX_CTL_CLEAR_PS_FILT |\n\t\t\t\t IEEE80211_TX_CTL_FIRST_FRAGMENT);\n\t\tif (rem)\n\t\t\tinfo->flags |= IEEE80211_TX_CTL_MORE_FRAMES;\n\t\tskb_copy_queue_mapping(tmp, skb);\n\t\ttmp->priority = skb->priority;\n\t\ttmp->dev = skb->dev;\n\t\tmemcpy(skb_put(tmp, hdrlen), skb->data, hdrlen);\n\t\tmemcpy(skb_put(tmp, fraglen), skb->data + pos, fraglen);\n\t\tpos += fraglen;\n\t}\n\tskb->len = hdrlen + per_fragm;\n\treturn 0;\n}", "target": 1}
{"code": "static int install_process_keyring(void)\n{\n\tstruct cred *new;\n\tint ret;\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\tret = install_process_keyring_to_cred(new);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\treturn ret != -EEXIST ? ret : 0;\n\t}\n\treturn commit_creds(new);\n}", "target": 1}
{"code": "static void ssl_calc_finished_tls(\n                ssl_context *ssl, unsigned char *buf, int from )\n{\n    int len = 12;\n    char *sender;\n    md5_context  md5;\n    sha1_context sha1;\n    unsigned char padbuf[36];\n    ssl_session *session = ssl->session_negotiate;\n    if( !session )\n        session = ssl->session;\n    SSL_DEBUG_MSG( 2, ( \"=> calc  finished tls\" ) );\n    memcpy( &md5 , &ssl->handshake->fin_md5 , sizeof(md5_context)  );\n    memcpy( &sha1, &ssl->handshake->fin_sha1, sizeof(sha1_context) );\n    SSL_DEBUG_BUF( 4, \"finished  md5 state\", (unsigned char *)\n                    md5.state, sizeof(  md5.state ) );\n    SSL_DEBUG_BUF( 4, \"finished sha1 state\", (unsigned char *)\n                   sha1.state, sizeof( sha1.state ) );\n    sender = ( from == SSL_IS_CLIENT )\n             ? (char *) \"client finished\"\n             : (char *) \"server finished\";\n    md5_finish(  &md5, padbuf );\n    sha1_finish( &sha1, padbuf + 16 );\n    ssl->handshake->tls_prf( session->master, 48, sender,\n                             padbuf, 36, buf, len );\n    SSL_DEBUG_BUF( 3, \"calc finished result\", buf, len );\n    memset(  &md5, 0, sizeof(  md5_context ) );\n    memset( &sha1, 0, sizeof( sha1_context ) );\n    memset(  padbuf, 0, sizeof(  padbuf ) );\n    SSL_DEBUG_MSG( 2, ( \"<= calc  finished\" ) );\n}", "target": 0}
{"code": "void InitCodec(const vpx_codec_iface_t &iface, int width, int height,\n               vpx_codec_ctx_t *enc, vpx_codec_enc_cfg_t *cfg) {\n  ASSERT_EQ(vpx_codec_enc_config_default(&iface, cfg, 0), VPX_CODEC_OK);\n  cfg->g_w = width;\n  cfg->g_h = height;\n  cfg->g_lag_in_frames = 0;\n  cfg->g_pass = VPX_RC_ONE_PASS;\n  ASSERT_EQ(vpx_codec_enc_init(enc, &iface, cfg, 0), VPX_CODEC_OK);\n  ASSERT_EQ(vpx_codec_control_(enc, VP8E_SET_CPUUSED, 2), VPX_CODEC_OK);\n}", "target": 1}
{"code": "static void sco_sock_timeout(struct work_struct *work)\n{\n\tstruct sco_conn *conn = container_of(work, struct sco_conn,\n\t\t\t\t\t     timeout_work.work);\n\tstruct sock *sk;\n\tsco_conn_lock(conn);\n\tsk = conn->sk;\n\tif (sk)\n\t\tsock_hold(sk);\n\tsco_conn_unlock(conn);\n\tif (!sk)\n\t\treturn;\n\tBT_DBG(\"sock %p state %d\", sk, sk->sk_state);\n\tlock_sock(sk);\n\tsk->sk_err = ETIMEDOUT;\n\tsk->sk_state_change(sk);\n\trelease_sock(sk);\n\tsock_put(sk);\n}", "target": 0}
{"code": "static int pfkey_flush(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\tunsigned int proto;\n\tstruct km_event c;\n\tint err, err2;\n\tproto = pfkey_satype2proto(hdr->sadb_msg_satype);\n\tif (proto == 0)\n\t\treturn -EINVAL;\n\terr = xfrm_state_flush(net, proto, true, false);\n\terr2 = unicast_flush_resp(sk, hdr);\n\tif (err || err2) {\n\t\tif (err == -ESRCH) \n\t\t\terr = 0;\n\t\treturn err ? err : err2;\n\t}\n\tc.data.proto = proto;\n\tc.seq = hdr->sadb_msg_seq;\n\tc.portid = hdr->sadb_msg_pid;\n\tc.event = XFRM_MSG_FLUSHSA;\n\tc.net = net;\n\tkm_state_notify(NULL, &c);\n\treturn 0;\n}", "target": 0}
{"code": "bool ConstantFolding::SimplifyReshape(const GraphProperties& properties,\n                                      bool use_shape_info, NodeDef* node) {\n  if (!use_shape_info || node->attr().count(\"T\") == 0 ||\n      !IsSimplifiableReshape(*node, properties)) {\n    return false;\n  }\n  DataType output_type = node->attr().at(\"T\").type();\n  node->set_op(\"Identity\");\n  EraseRegularNodeAttributes(node);\n  (*node->mutable_attr())[\"T\"].set_type(output_type);\n  *node->mutable_input(1) = AsControlDependency(node->input(1));\n  return true;\n}", "target": 1}
{"code": "static UINT ExtractRunLengthMegaMega(const BYTE* pbOrderHdr, const BYTE* pbEnd, UINT32* advance)\n{\n\tUINT runLength = 0;\n\tWINPR_ASSERT(pbOrderHdr);\n\tWINPR_ASSERT(pbEnd);\n\tWINPR_ASSERT(advance);\n\tif (!buffer_within_range(pbOrderHdr, 2, pbEnd))\n\t{\n\t\t*advance = 0;\n\t\treturn 0;\n\t}\n\trunLength = ((UINT16)pbOrderHdr[1]) | (((UINT16)pbOrderHdr[2]) << 8);\n\t(*advance) += 2;\n\treturn runLength;\n}", "target": 1}
{"code": "TEE_Result syscall_hash_update(unsigned long state, const void *chunk,\n\t\t\tsize_t chunk_size)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tif (!chunk && chunk_size)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\tif (!chunk_size)\n\t\treturn TEE_SUCCESS;\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)chunk, chunk_size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\tswitch (TEE_ALG_GET_CLASS(cs->algo)) {\n\tcase TEE_OPERATION_DIGEST:\n\t\tres = crypto_hash_update(cs->ctx, cs->algo, chunk, chunk_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\tres = crypto_mac_update(cs->ctx, cs->algo, chunk, chunk_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\treturn TEE_SUCCESS;\n}", "target": 0}
{"code": "std::pair<Function *, Function *> ESTreeIRGen::doLazyFunction(\n    hbc::LazyCompilationData *lazyData) {\n  Function *topLevel = Builder.createTopLevelFunction(lazyData->strictMode, {});\n  FunctionContext topLevelFunctionContext{this, topLevel, nullptr};\n  llvh::SaveAndRestore<FunctionContext *> saveTopLevelContext(\n      topLevelContext, &topLevelFunctionContext);\n  auto *node = cast<ESTree::FunctionLikeNode>(Root);\n  lexicalScopeChain = lazyData->parentScope;\n  materializeScopesInChain(\n      topLevel, lexicalScopeChain, getDepth(lexicalScopeChain) - 1);\n  Variable *parentVar = nullptr;\n  if (lazyData->closureAlias.isValid()) {\n    assert(lazyData->originalName.isValid() && \"Original name invalid\");\n    assert(\n        lazyData->originalName != lazyData->closureAlias &&\n        \"Original name must be different from the alias\");\n    parentVar = cast<Variable>(nameTable_.lookup(lazyData->closureAlias));\n    nameTable_.insert(lazyData->originalName, parentVar);\n  }\n  assert(\n      !llvh::isa<ESTree::ArrowFunctionExpressionNode>(node) &&\n      \"lazy compilation not supported for arrow functions\");\n  auto *func = genES5Function(lazyData->originalName, parentVar, node);\n  addLexicalDebugInfo(func, topLevel, lexicalScopeChain);\n  return {func, topLevel};\n}", "target": 1}
{"code": "static void hugetlb_vm_op_close(struct vm_area_struct *vma)\n{\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct resv_map *reservations = vma_resv_map(vma);\n\tstruct hugepage_subpool *spool = subpool_vma(vma);\n\tunsigned long reserve;\n\tunsigned long start;\n\tunsigned long end;\n\tif (reservations) {\n\t\tstart = vma_hugecache_offset(h, vma, vma->vm_start);\n\t\tend = vma_hugecache_offset(h, vma, vma->vm_end);\n\t\treserve = (end - start) -\n\t\t\tregion_count(&reservations->regions, start, end);\n\t\tresv_map_put(vma);\n\t\tif (reserve) {\n\t\t\thugetlb_acct_memory(h, -reserve);\n\t\t\thugepage_subpool_put_pages(spool, reserve);\n\t\t}\n\t}\n}", "target": 0}
{"code": "void pin_remove(struct fs_pin *pin)\n{\n\tspin_lock(&pin_lock);\n\thlist_del(&pin->m_list);\n\thlist_del(&pin->s_list);\n\tspin_unlock(&pin_lock);\n\tspin_lock_irq(&pin->wait.lock);\n\tpin->done = 1;\n\twake_up_locked(&pin->wait);\n\tspin_unlock_irq(&pin->wait.lock);\n}", "target": 1}
{"code": "njs_vmcode_typeof(njs_vm_t *vm, njs_value_t *value, njs_value_t *invld)\n{\n    static const njs_value_t  *types[NJS_VALUE_TYPE_MAX] = {\n        &njs_string_object,\n        &njs_string_undefined,\n        &njs_string_boolean,\n        &njs_string_number,\n        &njs_string_symbol,\n        &njs_string_string,\n        &njs_string_data,\n        &njs_string_external,\n        &njs_string_invalid,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_function,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n    };\n    vm->retval = *types[value->type];\n    return sizeof(njs_vmcode_2addr_t);\n}", "target": 0}
{"code": "static void ossl_associate_connection(struct Curl_easy *data,\n                                      struct connectdata *conn,\n                                      int sockindex)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  if(!backend->handle)\n    return;\n  if(SSL_SET_OPTION(primary.sessionid)) {\n    int data_idx = ossl_get_ssl_data_index();\n    int connectdata_idx = ossl_get_ssl_conn_index();\n    int sockindex_idx = ossl_get_ssl_sockindex_index();\n    int proxy_idx = ossl_get_proxy_index();\n    if(data_idx >= 0 && connectdata_idx >= 0 && sockindex_idx >= 0 &&\n       proxy_idx >= 0) {\n      SSL_set_ex_data(backend->handle, data_idx, data);\n      SSL_set_ex_data(backend->handle, connectdata_idx, conn);\n      SSL_set_ex_data(backend->handle, sockindex_idx, conn->sock + sockindex);\n#ifndef CURL_DISABLE_PROXY\n      SSL_set_ex_data(backend->handle, proxy_idx, SSL_IS_PROXY() ? (void *) 1:\n                      NULL);\n#else\n      SSL_set_ex_data(backend->handle, proxy_idx, NULL);\n#endif\n    }\n  }\n}", "target": 0}
{"code": "int ZEXPORT deflatePrime (strm, bits, value)\n    z_streamp strm;\n    int bits;\n    int value;\n{\n    deflate_state *s;\n    int put;\n    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;\n    s = strm->state;\n    if ((Bytef *)(s->d_buf) < s->pending_out + ((Buf_size + 7) >> 3))\n        return Z_BUF_ERROR;\n    do {\n        put = Buf_size - s->bi_valid;\n        if (put > bits)\n            put = bits;\n        s->bi_buf |= (ush)((value & ((1 << put) - 1)) << s->bi_valid);\n        s->bi_valid += put;\n        _tr_flush_bits(s);\n        value >>= put;\n        bits -= put;\n    } while (bits);\n    return Z_OK;\n}", "target": 1}
{"code": "static int fetch_uidl(char *line, void *data)\n{\n  int i, index;\n  struct Context *ctx = (struct Context *) data;\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  char *endp = NULL;\n  errno = 0;\n  index = strtol(line, &endp, 10);\n  if (errno)\n    return -1;\n  while (*endp == ' ')\n    endp++;\n  memmove(line, endp, strlen(endp) + 1);\n  if (strlen(line) == 0)\n    return -1;\n  for (i = 0; i < ctx->msgcount; i++)\n    if (mutt_str_strcmp(line, ctx->hdrs[i]->data) == 0)\n      break;\n  if (i == ctx->msgcount)\n  {\n    mutt_debug(1, \"new header %d %s\\n\", index, line);\n    if (i >= ctx->hdrmax)\n      mx_alloc_memory(ctx);\n    ctx->msgcount++;\n    ctx->hdrs[i] = mutt_header_new();\n    ctx->hdrs[i]->data = mutt_str_strdup(line);\n  }\n  else if (ctx->hdrs[i]->index != index - 1)\n    pop_data->clear_cache = true;\n  ctx->hdrs[i]->refno = index;\n  ctx->hdrs[i]->index = index - 1;\n  return 0;\n}", "target": 0}
{"code": "static void xen_cpu_init_eoi(unsigned int cpu)\n{\n\tstruct lateeoi_work *eoi = &per_cpu(lateeoi, cpu);\n\tINIT_DELAYED_WORK(&eoi->delayed, xen_irq_lateeoi_worker);\n\tspin_lock_init(&eoi->eoi_list_lock);\n\tINIT_LIST_HEAD(&eoi->eoi_list);\n}", "target": 0}
{"code": "int BN_GF2m_poly2arr(const BIGNUM *a, int p[], int max)\n{\n    int i, j, k = 0;\n    BN_ULONG mask;\n    if (BN_is_zero(a))\n        return 0;\n    for (i = a->top - 1; i >= 0; i--) {\n        if (!a->d[i])\n            continue;\n        mask = BN_TBIT;\n        for (j = BN_BITS2 - 1; j >= 0; j--) {\n            if (a->d[i] & mask) {\n                if (k < max)\n                    p[k] = BN_BITS2 * i + j;\n                k++;\n            }\n            mask >>= 1;\n        }\n    }\n    if (k < max) {\n        p[k] = -1;\n        k++;\n    }\n    return k;\n}", "target": 1}
{"code": "  void ComputeAsyncImpl(OpKernelContext* c, CollectiveExecutor* col_exec,\n                        DoneCallback done) override {\n    auto output_shape = c->input(0).shape();\n    OP_REQUIRES_ASYNC(c, output_shape.dims() > 0,\n                      errors::InvalidArgument(\"input should have rank > 0, \",\n                                              \"recieved \", output_shape.dims()),\n                      done);\n    output_shape.set_dim(\n        0, output_shape.dim_size(0) * col_params_->group.group_size);\n    col_params_->instance.shape = output_shape;\n    if (c->mutable_output(0) == nullptr) {\n      Tensor* output = nullptr;\n      OP_REQUIRES_OK_ASYNC(\n          c, c->allocate_output(0, col_params_->instance.shape, &output), done);\n    }\n    if (!CanProceedWithCompute(c, col_exec, done)) return;\n    auto actual_done = [c, col_params = col_params_, done](const Status& s) {\n      VLOG(1) << \"CollectiveGatherOpKernel ExecuteAsync done for collective \"\n              << c->op_kernel().name() << \" device \" << c->device()->name()\n              << \" group \" << col_params->group.group_key << \" instance \"\n              << col_params->instance.instance_key << \" status \" << s;\n      col_params->Unref();\n      OP_REQUIRES_OK_ASYNC(c, s, done);\n      done();\n    };\n    VLOG(1) << \"CollectiveGatherOpKernel ExecuteAsync start for collective \"\n            << col_params_->name << \" device \" << c->device()->name()\n            << \" group \" << col_params_->group.group_key << \" instance \"\n            << col_params_->instance.instance_key;\n    col_params_->Ref();\n    col_exec->ExecuteAsync(c, col_params_, GetCollectiveKey(c), actual_done);\n  }", "target": 0}
{"code": "static void update_attr(struct vc_data *vc)\n{\n\tvc->vc_attr = build_attr(vc, vc->vc_color, vc->vc_intensity,\n\t              vc->vc_blink, vc->vc_underline,\n\t              vc->vc_reverse ^ vc->vc_decscnm, vc->vc_italic);\n\tvc->vc_video_erase_char = (build_attr(vc, vc->vc_color, 1, vc->vc_blink, 0, vc->vc_decscnm, 0) << 8) | ' ';\n}", "target": 0}
{"code": "__attribute__((__always_inline__)) static inline int send_icmp4_too_big(\n    struct xdp_md* xdp) {\n  int headroom = (int)sizeof(struct iphdr) + (int)sizeof(struct icmphdr);\n  if (bpf_xdp_adjust_head(xdp, 0 - headroom)) {\n    return XDP_DROP;\n  }\n  void* data = (void*)(long)xdp->data;\n  void* data_end = (void*)(long)xdp->data_end;\n  if (data + (ICMP_TOOBIG_SIZE + headroom) > data_end) {\n    return XDP_DROP;\n  }\n  struct iphdr *iph, *orig_iph;\n  struct ethhdr* orig_eth;\n  struct icmphdr* icmp_hdr;\n  __u64 csum = 0;\n  __u64 off = 0;\n  orig_eth = data + headroom;\n  swap_mac(data, orig_eth);\n  off += sizeof(struct ethhdr);\n  iph = data + off;\n  off += sizeof(struct iphdr);\n  icmp_hdr = data + off;\n  off += sizeof(struct icmphdr);\n  orig_iph = data + off;\n  icmp_hdr->type = ICMP_DEST_UNREACH;\n  icmp_hdr->code = ICMP_FRAG_NEEDED;\n  icmp_hdr->un.frag.mtu = bpf_htons(MAX_PCKT_SIZE - sizeof(struct ethhdr));\n  icmp_hdr->un.frag.__unused = 0;\n  icmp_hdr->checksum = 0;\n  ipv4_csum(icmp_hdr, ICMP_TOOBIG_PAYLOAD_SIZE, &csum);\n  icmp_hdr->checksum = csum;\n  iph->ttl = DEFAULT_TTL;\n  iph->daddr = orig_iph->saddr;\n  iph->saddr = orig_iph->daddr;\n  iph->frag_off = 0;\n  iph->version = 4;\n  iph->ihl = 5;\n  iph->protocol = IPPROTO_ICMP;\n  iph->tos = 0;\n  iph->tot_len = bpf_htons(ICMP_TOOBIG_SIZE + headroom - sizeof(struct ethhdr));\n  iph->id = 0;\n  iph->check = 0;\n  csum = 0;\n  ipv4_csum(iph, sizeof(struct iphdr), &csum);\n  iph->check = csum;\n  return XDP_TX;\n}", "target": 0}
{"code": "static inline u32 dma_high(dma_addr_t addr)\n{\n\treturn upper_32_bits(addr);\n}", "target": 1}
{"code": "void Curl_detach_connnection(struct Curl_easy *data)\n{\n  struct connectdata *conn = data->conn;\n  if(conn)\n    Curl_llist_remove(&conn->easyq, &data->conn_queue, NULL);\n  data->conn = NULL;\n}", "target": 1}
{"code": "Array& ObjectData::reserveProperties(int numDynamic ) {\n  if (getAttribute(HasDynPropArr)) {\n    return dynPropArray();\n  }\n  auto const allocsz = MixedArray::computeAllocBytesFromMaxElms(numDynamic);\n  if (UNLIKELY(allocsz > kMaxSmallSize && tl_heap->preAllocOOM(allocsz))) {\n    check_non_safepoint_surprise();\n  }\n  return setDynPropArray(\n      Array::attach(MixedArray::MakeReserveMixed(numDynamic))\n  );\n}", "target": 0}
{"code": "static int asn1_find_indefinite_length(const unsigned char *data, size_t datalen,\n\t\t\t\t       size_t *_dp, size_t *_len,\n\t\t\t\t       const char **_errmsg)\n{\n\tunsigned char tag, tmp;\n\tsize_t dp = *_dp, len, n;\n\tint indef_level = 1;\nnext_tag:\n\tif (unlikely(datalen - dp < 2)) {\n\t\tif (datalen == dp)\n\t\t\tgoto missing_eoc;\n\t\tgoto data_overrun_error;\n\t}\n\ttag = data[dp++];\n\tif (tag == 0) {\n\t\tif (data[dp++] != 0)\n\t\t\tgoto invalid_eoc;\n\t\tif (--indef_level <= 0) {\n\t\t\t*_len = dp - *_dp;\n\t\t\t*_dp = dp;\n\t\t\treturn 0;\n\t\t}\n\t\tgoto next_tag;\n\t}\n\tif (unlikely((tag & 0x1f) == ASN1_LONG_TAG)) {\n\t\tdo {\n\t\t\tif (unlikely(datalen - dp < 2))\n\t\t\t\tgoto data_overrun_error;\n\t\t\ttmp = data[dp++];\n\t\t} while (tmp & 0x80);\n\t}\n\tlen = data[dp++];\n\tif (len <= 0x7f) {\n\t\tdp += len;\n\t\tgoto next_tag;\n\t}\n\tif (unlikely(len == ASN1_INDEFINITE_LENGTH)) {\n\t\tif (unlikely((tag & ASN1_CONS_BIT) == ASN1_PRIM << 5))\n\t\t\tgoto indefinite_len_primitive;\n\t\tindef_level++;\n\t\tgoto next_tag;\n\t}\n\tn = len - 0x80;\n\tif (unlikely(n > sizeof(size_t) - 1))\n\t\tgoto length_too_long;\n\tif (unlikely(n > datalen - dp))\n\t\tgoto data_overrun_error;\n\tfor (len = 0; n > 0; n--) {\n\t\tlen <<= 8;\n\t\tlen |= data[dp++];\n\t}\n\tdp += len;\n\tgoto next_tag;\nlength_too_long:\n\t*_errmsg = \"Unsupported length\";\n\tgoto error;\nindefinite_len_primitive:\n\t*_errmsg = \"Indefinite len primitive not permitted\";\n\tgoto error;\ninvalid_eoc:\n\t*_errmsg = \"Invalid length EOC\";\n\tgoto error;\ndata_overrun_error:\n\t*_errmsg = \"Data overrun error\";\n\tgoto error;\nmissing_eoc:\n\t*_errmsg = \"Missing EOC in indefinite len cons\";\nerror:\n\t*_dp = dp;\n\treturn -1;\n}", "target": 1}
{"code": "parse_io(VALUE klass, VALUE io, VALUE encoding)\n{\n  xmlParserCtxtPtr ctxt;\n  xmlCharEncoding enc = (xmlCharEncoding)NUM2INT(encoding);\n  if (!rb_respond_to(io, id_read)) {\n    rb_raise(rb_eTypeError, \"argument expected to respond to :read\");\n  }\n  ctxt = xmlCreateIOParserCtxt(NULL, NULL,\n                               (xmlInputReadCallback)noko_io_read,\n                               (xmlInputCloseCallback)noko_io_close,\n                               (void *)io, enc);\n  if (ctxt->sax) {\n    xmlFree(ctxt->sax);\n    ctxt->sax = NULL;\n  }\n  return Data_Wrap_Struct(klass, NULL, deallocate, ctxt);\n}", "target": 0}
{"code": "static int rose_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\tstruct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tsize_t copied;\n\tunsigned char *asmptr;\n\tstruct sk_buff *skb;\n\tint n, er, qbit;\n\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\treturn -ENOTCONN;\n\tif ((skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT, flags & MSG_DONTWAIT, &er)) == NULL)\n\t\treturn er;\n\tqbit = (skb->data[0] & ROSE_Q_BIT) == ROSE_Q_BIT;\n\tskb_pull(skb, ROSE_MIN_LEN);\n\tif (rose->qbitincl) {\n\t\tasmptr  = skb_push(skb, 1);\n\t\t*asmptr = qbit;\n\t}\n\tskb_reset_transport_header(skb);\n\tcopied     = skb->len;\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\tskb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (msg->msg_name) {\n\t\tstruct sockaddr_rose *srose;\n\t\tmemset(msg->msg_name, 0, sizeof(struct full_sockaddr_rose));\n\t\tsrose = msg->msg_name;\n\t\tsrose->srose_family = AF_ROSE;\n\t\tsrose->srose_addr   = rose->dest_addr;\n\t\tsrose->srose_call   = rose->dest_call;\n\t\tsrose->srose_ndigis = rose->dest_ndigis;\n\t\tif (msg->msg_namelen >= sizeof(struct full_sockaddr_rose)) {\n\t\t\tstruct full_sockaddr_rose *full_srose = (struct full_sockaddr_rose *)msg->msg_name;\n\t\t\tfor (n = 0 ; n < rose->dest_ndigis ; n++)\n\t\t\t\tfull_srose->srose_digis[n] = rose->dest_digis[n];\n\t\t\tmsg->msg_namelen = sizeof(struct full_sockaddr_rose);\n\t\t} else {\n\t\t\tif (rose->dest_ndigis >= 1) {\n\t\t\t\tsrose->srose_ndigis = 1;\n\t\t\t\tsrose->srose_digi = rose->dest_digis[0];\n\t\t\t}\n\t\t\tmsg->msg_namelen = sizeof(struct sockaddr_rose);\n\t\t}\n\t}\n\tskb_free_datagram(sk, skb);\n\treturn copied;\n}", "target": 0}
{"code": "  erase_all_clients() {\n    map_id_client.clear();\n    cert_chain.clear();\n    save_state();\n  }", "target": 0}
{"code": "buffer_add_range(int fd, struct evbuffer *evb, struct range *range)\n{\n\tchar\tbuf[BUFSIZ];\n\tsize_t\tn, range_sz;\n\tssize_t\tnread;\n\tif (lseek(fd, range->start, SEEK_SET) == -1)\n\t\treturn (0);\n\trange_sz = range->end - range->start + 1;\n\twhile (range_sz) {\n\t\tn = MINIMUM(range_sz, sizeof(buf));\n\t\tif ((nread = read(fd, buf, n)) == -1)\n\t\t\treturn (0);\n\t\tevbuffer_add(evb, buf, nread);\n\t\trange_sz -= nread;\n\t}\n\treturn (1);\n}", "target": 1}
{"code": "NCR_ModifyMaxdelay(NCR_Instance inst, double new_max_delay)\n{\n  inst->max_delay = new_max_delay;\n  LOG(LOGS_INFO, LOGF_NtpCore, \"Source %s new max delay %f\",\n      UTI_IPToString(&inst->remote_addr.ip_addr), new_max_delay);\n}", "target": 0}
{"code": "static int kvm_ioctl_create_device(struct kvm *kvm,\n\t\t\t\t   struct kvm_create_device *cd)\n{\n\tstruct kvm_device_ops *ops = NULL;\n\tstruct kvm_device *dev;\n\tbool test = cd->flags & KVM_CREATE_DEVICE_TEST;\n\tint ret;\n\tif (cd->type >= ARRAY_SIZE(kvm_device_ops_table))\n\t\treturn -ENODEV;\n\tops = kvm_device_ops_table[cd->type];\n\tif (ops == NULL)\n\t\treturn -ENODEV;\n\tif (test)\n\t\treturn 0;\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tdev->ops = ops;\n\tdev->kvm = kvm;\n\tmutex_lock(&kvm->lock);\n\tret = ops->create(dev, cd->type);\n\tif (ret < 0) {\n\t\tmutex_unlock(&kvm->lock);\n\t\tkfree(dev);\n\t\treturn ret;\n\t}\n\tlist_add(&dev->vm_node, &kvm->devices);\n\tmutex_unlock(&kvm->lock);\n\tif (ops->init)\n\t\tops->init(dev);\n\tret = anon_inode_getfd(ops->name, &kvm_device_fops, dev, O_RDWR | O_CLOEXEC);\n\tif (ret < 0) {\n\t\tops->destroy(dev);\n\t\tmutex_lock(&kvm->lock);\n\t\tlist_del(&dev->vm_node);\n\t\tmutex_unlock(&kvm->lock);\n\t\treturn ret;\n\t}\n\tkvm_get_kvm(kvm);\n\tcd->fd = ret;\n\treturn 0;\n}", "target": 1}
{"code": "static int ebt_size_mwt(struct compat_ebt_entry_mwt *match32,\n\t\t\tunsigned int size_left, enum compat_mwt type,\n\t\t\tstruct ebt_entries_buf_state *state, const void *base)\n{\n\tint growth = 0;\n\tchar *buf;\n\tif (size_left == 0)\n\t\treturn 0;\n\tbuf = (char *) match32;\n\twhile (size_left >= sizeof(*match32)) {\n\t\tstruct ebt_entry_match *match_kern;\n\t\tint ret;\n\t\tmatch_kern = (struct ebt_entry_match *) state->buf_kern_start;\n\t\tif (match_kern) {\n\t\t\tchar *tmp;\n\t\t\ttmp = state->buf_kern_start + state->buf_kern_offset;\n\t\t\tmatch_kern = (struct ebt_entry_match *) tmp;\n\t\t}\n\t\tret = ebt_buf_add(state, buf, sizeof(*match32));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tsize_left -= sizeof(*match32);\n\t\tret = ebt_buf_add_pad(state, ebt_compat_entry_padsize());\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (match32->match_size > size_left)\n\t\t\treturn -EINVAL;\n\t\tsize_left -= match32->match_size;\n\t\tret = compat_mtw_from_user(match32, type, state, base);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (WARN_ON(ret < match32->match_size))\n\t\t\treturn -EINVAL;\n\t\tgrowth += ret - match32->match_size;\n\t\tgrowth += ebt_compat_entry_padsize();\n\t\tbuf += sizeof(*match32);\n\t\tbuf += match32->match_size;\n\t\tif (match_kern)\n\t\t\tmatch_kern->match_size = ret;\n\t\tWARN_ON(type == EBT_COMPAT_TARGET && size_left);\n\t\tmatch32 = (struct compat_ebt_entry_mwt *) buf;\n\t}\n\treturn growth;\n}", "target": 1}
{"code": "static int rd_allocate_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,\n\t\t\t\t u32 total_sg_needed, unsigned char init_payload)\n{\n\tu32 i = 0, j, page_offset = 0, sg_per_table;\n\tu32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /\n\t\t\t\tsizeof(struct scatterlist));\n\tstruct page *pg;\n\tstruct scatterlist *sg;\n\tunsigned char *p;\n\twhile (total_sg_needed) {\n\t\tsg_per_table = (total_sg_needed > max_sg_per_table) ?\n\t\t\tmax_sg_per_table : total_sg_needed;\n\t\tsg = kzalloc(sg_per_table * sizeof(struct scatterlist),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!sg) {\n\t\t\tpr_err(\"Unable to allocate scatterlist array\"\n\t\t\t\t\" for struct rd_dev\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tsg_init_table(sg, sg_per_table);\n\t\tsg_table[i].sg_table = sg;\n\t\tsg_table[i].rd_sg_count = sg_per_table;\n\t\tsg_table[i].page_start_offset = page_offset;\n\t\tsg_table[i++].page_end_offset = (page_offset + sg_per_table)\n\t\t\t\t\t\t- 1;\n\t\tfor (j = 0; j < sg_per_table; j++) {\n\t\t\tpg = alloc_pages(GFP_KERNEL, 0);\n\t\t\tif (!pg) {\n\t\t\t\tpr_err(\"Unable to allocate scatterlist\"\n\t\t\t\t\t\" pages for struct rd_dev_sg_table\\n\");\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tsg_assign_page(&sg[j], pg);\n\t\t\tsg[j].length = PAGE_SIZE;\n\t\t\tp = kmap(pg);\n\t\t\tmemset(p, init_payload, PAGE_SIZE);\n\t\t\tkunmap(pg);\n\t\t}\n\t\tpage_offset += sg_per_table;\n\t\ttotal_sg_needed -= sg_per_table;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void dwc3_gadget_del_and_unmap_request(struct dwc3_ep *dep,\n\t\tstruct dwc3_request *req, int status)\n{\n\tstruct dwc3\t\t\t*dwc = dep->dwc;\n\treq->started = false;\n\tlist_del(&req->list);\n\treq->remaining = 0;\n\tif (req->request.status == -EINPROGRESS)\n\t\treq->request.status = status;\n\tif (req->trb)\n\t\tusb_gadget_unmap_request_by_dev(dwc->sysdev,\n\t\t\t\t&req->request, req->direction);\n\treq->trb = NULL;\n\ttrace_dwc3_gadget_giveback(req);\n\tif (dep->number > 1)\n\t\tpm_runtime_put(dwc->dev);\n}", "target": 0}
{"code": "static char *get_object(\n    FILE         *fp,\n    int           obj_id,\n    const xref_t *xref,\n    size_t       *size,\n    int          *is_stream)\n{\n    static const int    blk_sz = 256;\n    int                 i, total_sz, read_sz, n_blks, search, stream;\n    size_t              obj_sz;\n    char               *c, *data;\n    long                start;\n    const xref_entry_t *entry;\n    if (size)\n      *size = 0;\n    if (is_stream)\n      *is_stream = 0;\n    start = ftell(fp);\n    entry = NULL;\n    for (i=0; i<xref->n_entries; i++)\n      if (xref->entries[i].obj_id == obj_id)\n      {\n          entry = &xref->entries[i];\n          break;\n      }\n    if (!entry)\n      return NULL;\n    fseek(fp, entry->offset, SEEK_SET);\n    obj_sz = 0;    \n    total_sz = 0;  \n    n_blks = 1;\n    data = safe_calloc(blk_sz * n_blks);\n    stream = 0;\n    while ((read_sz = fread(data+total_sz, 1, blk_sz-1, fp)) && !ferror(fp))\n    {\n        total_sz += read_sz;\n        *(data + total_sz) = '\\0';\n        if (total_sz + blk_sz >= (blk_sz * n_blks))\n          data = realloc(data, blk_sz * (++n_blks));\n        if (!data) {\n          ERR(\"Failed to reallocate buffer.\\n\");\n          exit(EXIT_FAILURE);\n        }\n        search = total_sz - read_sz;\n        if (search < 0)\n          search = 0;\n        if ((c = strstr(data + search, \"endobj\")))\n        {\n            *(c + strlen(\"endobj\") + 1) = '\\0';\n            obj_sz = (char *)strstr(data + search, \"endobj\") - (char *)data;\n            obj_sz += strlen(\"endobj\") + 1;\n            break;\n        }\n        else if (strstr(data, \"stream\"))\n          stream = 1;\n    }\n    clearerr(fp);\n    fseek(fp, start, SEEK_SET);\n    if (size) {\n      *size = obj_sz;\n      if (!obj_sz && data) {\n        free(data);\n        data = NULL;\n      }\n    }\n    if (is_stream)\n      *is_stream = stream;\n    return data;\n}", "target": 0}
{"code": "PlayerGeneric::~PlayerGeneric()\n{\n\tif (mixer)\n\t\tdelete mixer;\n\tif (player)\n\t{\n\t\tif (mixer->isActive() && !mixer->isDeviceRemoved(player))\n\t\t\tmixer->removeDevice(player);\n\t\tdelete player;\n\t}\n\tdelete[] audioDriverName;\n\tdelete listener;\n}", "target": 1}
{"code": "GF_Err stbl_AppendSize(GF_SampleTableBox *stbl, u32 size, u32 nb_pack)\n{\n\tu32 i;\n\tif (!nb_pack) nb_pack = 1;\n\tif (!stbl->SampleSize->sampleCount) {\n\t\tstbl->SampleSize->sampleSize = size;\n\t\tstbl->SampleSize->sampleCount += nb_pack;\n\t\treturn GF_OK;\n\t}\n\tif (stbl->SampleSize->sampleSize && (stbl->SampleSize->sampleSize==size)) {\n\t\tstbl->SampleSize->sampleCount += nb_pack;\n\t\treturn GF_OK;\n\t}\n\tif (!stbl->SampleSize->sizes || (stbl->SampleSize->sampleCount+nb_pack > stbl->SampleSize->alloc_size)) {\n\t\tBool init_table = (stbl->SampleSize->sizes==NULL) ? 1 : 0;\n\t\tALLOC_INC(stbl->SampleSize->alloc_size);\n\t\tif (stbl->SampleSize->sampleCount+nb_pack > stbl->SampleSize->alloc_size)\n\t\t\tstbl->SampleSize->alloc_size = stbl->SampleSize->sampleCount+nb_pack;\n\t\tstbl->SampleSize->sizes = (u32 *)gf_realloc(stbl->SampleSize->sizes, sizeof(u32)*stbl->SampleSize->alloc_size);\n\t\tif (!stbl->SampleSize->sizes) return GF_OUT_OF_MEM;\n\t\tmemset(&stbl->SampleSize->sizes[stbl->SampleSize->sampleCount], 0, sizeof(u32) * (stbl->SampleSize->alloc_size - stbl->SampleSize->sampleCount) );\n\t\tif (init_table) {\n\t\t\tfor (i=0; i<stbl->SampleSize->sampleCount; i++)\n\t\t\t\tstbl->SampleSize->sizes[i] = stbl->SampleSize->sampleSize;\n\t\t}\n\t}\n\tstbl->SampleSize->sampleSize = 0;\n\tfor (i=0; i<nb_pack; i++) {\n\t\tstbl->SampleSize->sizes[stbl->SampleSize->sampleCount+i] = size;\n\t}\n\tstbl->SampleSize->sampleCount += nb_pack;\n\tif (size > stbl->SampleSize->max_size)\n\t\tstbl->SampleSize->max_size = size;\n\tstbl->SampleSize->total_size += size;\n\tstbl->SampleSize->total_samples += nb_pack;\n\treturn GF_OK;\n}", "target": 1}
{"code": "int64_t OpLevelCostEstimator::CalculateTensorSize(\n    const OpInfo::TensorProperties& tensor, bool* found_unknown_shapes) {\n  int64_t count = CalculateTensorElementCount(tensor, found_unknown_shapes);\n  int size = DataTypeSize(BaseType(tensor.dtype()));\n  VLOG(2) << \"Count: \" << count << \" DataTypeSize: \" << size;\n  return count * size;\n}", "target": 1}
{"code": "struct bpf_prog *bpf_prog_get(u32 ufd)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_prog *prog;\n\tprog = __bpf_prog_get(f);\n\tif (IS_ERR(prog))\n\t\treturn prog;\n\tatomic_inc(&prog->aux->refcnt);\n\tfdput(f);\n\treturn prog;\n}", "target": 1}
{"code": "static int apparmor_setprocattr(struct task_struct *task, char *name,\n\t\t\t\tvoid *value, size_t size)\n{\n\tstruct common_audit_data sa;\n\tstruct apparmor_audit_data aad = {0,};\n\tchar *command, *args = value;\n\tsize_t arg_size;\n\tint error;\n\tif (size == 0)\n\t\treturn -EINVAL;\n\tif (args[size - 1] != '\\0') {\n\t\tif (size == PAGE_SIZE)\n\t\t\treturn -EINVAL;\n\t\targs[size] = '\\0';\n\t}\n\tif (current != task)\n\t\treturn -EACCES;\n\targs = value;\n\targs = strim(args);\n\tcommand = strsep(&args, \" \");\n\tif (!args)\n\t\treturn -EINVAL;\n\targs = skip_spaces(args);\n\tif (!*args)\n\t\treturn -EINVAL;\n\targ_size = size - (args - (char *) value);\n\tif (strcmp(name, \"current\") == 0) {\n\t\tif (strcmp(command, \"changehat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permhat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t AA_DO_TEST);\n\t\t} else if (strcmp(command, \"changeprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     AA_DO_TEST);\n\t\t} else\n\t\t\tgoto fail;\n\t} else if (strcmp(name, \"exec\") == 0) {\n\t\tif (strcmp(command, \"exec\") == 0)\n\t\t\terror = aa_setprocattr_changeprofile(args, AA_ONEXEC,\n\t\t\t\t\t\t\t     !AA_DO_TEST);\n\t\telse\n\t\t\tgoto fail;\n\t} else\n\t\treturn -EINVAL;\n\tif (!error)\n\t\terror = size;\n\treturn error;\nfail:\n\tsa.type = LSM_AUDIT_DATA_NONE;\n\tsa.aad = &aad;\n\taad.profile = aa_current_profile();\n\taad.op = OP_SETPROCATTR;\n\taad.info = name;\n\taad.error = -EINVAL;\n\taa_audit_msg(AUDIT_APPARMOR_DENIED, &sa, NULL);\n\treturn -EINVAL;\n}", "target": 1}
{"code": "ftrace_filter_lseek(struct file *file, loff_t offset, int whence)\n{\n\tloff_t ret;\n\tif (file->f_mode & FMODE_READ)\n\t\tret = seq_lseek(file, offset, whence);\n\telse\n\t\tfile->f_pos = ret = 1;\n\treturn ret;\n}", "target": 0}
{"code": "static void check_serverpath(request_rec *r)\n{\n    server_rec *s;\n    server_rec *last_s;\n    name_chain *src;\n    apr_port_t port;\n    port = r->connection->local_addr->port;\n    last_s = NULL;\n    for (src = r->connection->vhost_lookup_data; src; src = src->next) {\n        if (src->sar->host_port != 0 && port != src->sar->host_port) {\n            continue;\n        }\n        s = src->server;\n        if (s == last_s) {\n            continue;\n        }\n        last_s = s;\n        if (s->path && !strncmp(r->uri, s->path, s->pathlen) &&\n            (s->path[s->pathlen - 1] == '/' ||\n             r->uri[s->pathlen] == '/' ||\n             r->uri[s->pathlen] == '\\0')) {\n            r->server = s;\n            return;\n        }\n    }\n}", "target": 1}
{"code": "static int asymmetric_key_match(const struct key *key,\n\t\t\t\tconst struct key_match_data *match_data)\n{\n\tconst struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);\n\tconst char *description = match_data->raw_data;\n\tconst char *spec = description;\n\tconst char *id;\n\tptrdiff_t speclen;\n\tif (!subtype || !spec || !*spec)\n\t\treturn 0;\n\tif (key->description && strcmp(key->description, description) == 0)\n\t\treturn 1;\n\tid = strchr(spec, ':');\n\tif (!id)\n\t\treturn 0;\n\tspeclen = id - spec;\n\tid++;\n\tif (speclen == 2 && memcmp(spec, \"id\", 2) == 0)\n\t\treturn asymmetric_keyid_match(asymmetric_key_id(key), id);\n\tif (speclen == subtype->name_len &&\n\t    memcmp(spec, subtype->name, speclen) == 0)\n\t\treturn 1;\n\treturn 0;\n}", "target": 1}
{"code": "get_page_size_area_prepared_cb (GdkPixbufLoader *loader,\n\t\t\t\tgpointer         data)\n{\n\tgboolean *got_size = data;\n\t*got_size = TRUE;\n}", "target": 1}
{"code": "DLLIMPORT int cfg_parse(cfg_t *cfg, const char *filename)\n{\n\tint ret;\n\tchar *fn;\n\tFILE *fp;\n\tif (!cfg || !filename) {\n\t\terrno = EINVAL;\n\t\treturn CFG_FILE_ERROR;\n\t}\n\tif (cfg->path)\n\t\tfn = cfg_searchpath(cfg->path, filename);\n\telse\n\t\tfn = cfg_tilde_expand(filename);\n\tif (!fn)\n\t\treturn CFG_FILE_ERROR;\n\tfree(cfg->filename);\n\tcfg->filename = fn;\n\tfp = fopen(cfg->filename, \"r\");\n\tif (!fp)\n\t\treturn CFG_FILE_ERROR;\n\tret = cfg_parse_fp(cfg, fp);\n\tfclose(fp);\n\treturn ret;\n}", "target": 0}
{"code": "static void vvc_parse_general_timing_hrd_parameters(GF_BitStream *bs, VVC_SPS *sps, VVC_VPS *vps, Bool *general_nal_hrd_params_present_flag, Bool *general_vcl_hrd_params_present_flag, Bool *general_du_hrd_params_present_flag, u32 *hrd_cpb_cnt_minus1)\n{\n\tsps->has_timing_info = 1;\n\tsps->num_units_in_tick = gf_bs_read_int_log(bs, 32, \"num_units_in_tick\");\n\tsps->time_scale = gf_bs_read_int_log(bs, 32, \"timescale\");\n\t*general_du_hrd_params_present_flag = GF_FALSE;\n\t*general_nal_hrd_params_present_flag = gf_bs_read_int_log(bs, 1, \"general_nal_hrd_params_present_flag\");\n\t*general_vcl_hrd_params_present_flag = gf_bs_read_int_log(bs, 1, \"general_vcl_hrd_params_present_flag\");\n\tif (*general_nal_hrd_params_present_flag || *general_vcl_hrd_params_present_flag) {\n\t\tgf_bs_read_int_log(bs, 1, \"general_same_pic_timing_in_all_ols_flag\");\n\t\t*general_du_hrd_params_present_flag = gf_bs_read_int_log(bs, 1, \"general_du_hrd_params_present_flag\");\n\t\tif (*general_du_hrd_params_present_flag)\n\t\t\tgf_bs_read_int_log(bs, 8, \"tick_divisor_minus2\");\n\t\tgf_bs_read_int_log(bs, 4, \"bit_rate_scale\");\n\t\tgf_bs_read_int_log(bs, 4, \"cpb_size_scale\");\n\t\tif (*general_du_hrd_params_present_flag)\n\t\t\tgf_bs_read_int_log(bs, 4, \"cpb_size_du_scale\");\n\t\t*hrd_cpb_cnt_minus1 = gf_bs_read_ue_log(bs, \"hrd_cpb_cnt_minus1\");\n\t}\n}", "target": 0}
{"code": "static void stellaris_enet_save(QEMUFile *f, void *opaque)\n{\n    stellaris_enet_state *s = (stellaris_enet_state *)opaque;\n    int i;\n    qemu_put_be32(f, s->ris);\n    qemu_put_be32(f, s->im);\n    qemu_put_be32(f, s->rctl);\n    qemu_put_be32(f, s->tctl);\n    qemu_put_be32(f, s->thr);\n    qemu_put_be32(f, s->mctl);\n    qemu_put_be32(f, s->mdv);\n    qemu_put_be32(f, s->mtxd);\n    qemu_put_be32(f, s->mrxd);\n    qemu_put_be32(f, s->np);\n    qemu_put_be32(f, s->tx_fifo_len);\n    qemu_put_buffer(f, s->tx_fifo, sizeof(s->tx_fifo));\n    for (i = 0; i < 31; i++) {\n        qemu_put_be32(f, s->rx[i].len);\n        qemu_put_buffer(f, s->rx[i].data, sizeof(s->rx[i].data));\n    }\n    qemu_put_be32(f, s->next_packet);\n    qemu_put_be32(f, s->rx_fifo_offset);\n}", "target": 1}
{"code": "static bool set_reg_profile(RAnal *anal) {\n\tconst char *p = \\\n\t\t\"=PC\tpc\\n\"\n\t\t\"=SP\tsp\\n\"\n\t\t\"=SN\tr0\\n\"\n\t\t\"=A0\tr12\\n\"\n\t\t\"=A1\tr13\\n\"\n\t\t\"=A2\tr14\\n\"\n\t\t\"=A3\tr15\\n\"\n\t\t\"gpr\tr0\t.16 0   0\\n\"\n\t\t\"gpr\tr1\t.16 2   0\\n\"\n\t\t\"gpr\tr2\t.16 4   0\\n\"\n\t\t\"gpr\tr3\t.16 6   0\\n\"\n\t\t\"gpr\tr4\t.16 8   0\\n\"\n\t\t\"gpr\tr5\t.16 10  0\\n\"\n\t\t\"gpr\tr6\t.16 12  0\\n\"\n\t\t\"gpr\tr7\t.16 14  0\\n\"\n\t\t\"gpr\tr8\t.16 16  0\\n\"\n\t\t\"gpr\tr9\t.16 18  0\\n\"\n\t\t\"gpr\tr10   .16 20  0\\n\"\n\t\t\"gpr\tr11   .16 22  0\\n\"\n\t\t\"gpr\tr12   .16 24  0\\n\"\n\t\t\"gpr\tr13   .16 26  0\\n\"\n\t\t\"gpr\tr14   .16 28  0\\n\"\n\t\t\"gpr\tr15   .16 30  0\\n\"\n\t\t\"gpr\tpc\t.16 0 0\\n\" \n\t\t\"gpr\tsp\t.16 2 0\\n\" \n\t\t\"flg\tsr\t.16 4 0\\n\" \n\t\t\"flg\tc\t.1  4 0\\n\"\n\t\t\"flg\tz\t.1  4.1 0\\n\"\n\t\t\"flg\tn\t.1  4.2 0\\n\"\n\t\t\"flg\tv\t.1  4.8 0\\n\";\n\treturn r_reg_set_profile_string (anal->reg, p);\n}", "target": 0}
{"code": "static int msg_parse_fetch(struct ImapHeader *h, char *s)\n{\n  char tmp[SHORT_STRING];\n  char *ptmp = NULL;\n  if (!s)\n    return -1;\n  while (*s)\n  {\n    SKIPWS(s);\n    if (mutt_str_strncasecmp(\"FLAGS\", s, 5) == 0)\n    {\n      s = msg_parse_flags(h, s);\n      if (!s)\n        return -1;\n    }\n    else if (mutt_str_strncasecmp(\"UID\", s, 3) == 0)\n    {\n      s += 3;\n      SKIPWS(s);\n      if (mutt_str_atoui(s, &h->data->uid) < 0)\n        return -1;\n      s = imap_next_word(s);\n    }\n    else if (mutt_str_strncasecmp(\"INTERNALDATE\", s, 12) == 0)\n    {\n      s += 12;\n      SKIPWS(s);\n      if (*s != '\\\"')\n      {\n        mutt_debug(1, \"bogus INTERNALDATE entry: %s\\n\", s);\n        return -1;\n      }\n      s++;\n      ptmp = tmp;\n      while (*s && *s != '\\\"')\n        *ptmp++ = *s++;\n      if (*s != '\\\"')\n        return -1;\n      s++; \n      *ptmp = '\\0';\n      h->received = mutt_date_parse_imap(tmp);\n    }\n    else if (mutt_str_strncasecmp(\"RFC822.SIZE\", s, 11) == 0)\n    {\n      s += 11;\n      SKIPWS(s);\n      ptmp = tmp;\n      while (isdigit((unsigned char) *s))\n        *ptmp++ = *s++;\n      *ptmp = '\\0';\n      if (mutt_str_atol(tmp, &h->content_length) < 0)\n        return -1;\n    }\n    else if ((mutt_str_strncasecmp(\"BODY\", s, 4) == 0) ||\n             (mutt_str_strncasecmp(\"RFC822.HEADER\", s, 13) == 0))\n    {\n      return -2;\n    }\n    else if (*s == ')')\n      s++; \n    else if (*s)\n    {\n      imap_error(\"msg_parse_fetch\", s);\n      return -1;\n    }\n  }\n  return 0;\n}", "target": 1}
{"code": "int ceph_crypt(const struct ceph_crypto_key *key, bool encrypt,\n\t       void *buf, int buf_len, int in_len, int *pout_len)\n{\n\tswitch (key->type) {\n\tcase CEPH_CRYPTO_NONE:\n\t\t*pout_len = in_len;\n\t\treturn 0;\n\tcase CEPH_CRYPTO_AES:\n\t\treturn ceph_aes_crypt(key, encrypt, buf, buf_len, in_len,\n\t\t\t\t      pout_len);\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n}", "target": 0}
{"code": "alloc_compspace(isc_httpd_t *httpd, unsigned int size) {\n\tchar *newspace = NULL;\n\tisc_region_t r;\n\tisc_buffer_region(&httpd->compbuffer, &r);\n\tif (size < r.length) {\n\t\treturn;\n\t}\n\tnewspace = isc_mem_get(httpd->mgr->mctx, size);\n\tisc_buffer_reinit(&httpd->compbuffer, newspace, size);\n\tif (r.base != NULL) {\n\t\tisc_mem_put(httpd->mgr->mctx, r.base, r.length);\n\t}\n}", "target": 0}
{"code": "hybiDecodeCleanup(ws_ctx_t *wsctx)\n{\n  wsctx->header.payloadLen = 0;\n  wsctx->header.mask.u = 0;\n  wsctx->nReadRaw = 0;\n  wsctx->nToRead= 0;\n  wsctx->carrylen = 0;\n  wsctx->readPos = (unsigned char *)wsctx->codeBufDecode;\n  wsctx->readlen = 0;\n  wsctx->hybiDecodeState = WS_HYBI_STATE_HEADER_PENDING;\n  wsctx->writePos = NULL;\n  rfbLog(\"cleaned up wsctx\\n\");\n}", "target": 0}
{"code": "BOOL update_recv(rdpUpdate* update, wStream* s)\n{\n\tBOOL rc = FALSE;\n\tUINT16 updateType;\n\trdpContext* context = update->context;\n\tif (Stream_GetRemainingLength(s) < 2)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 2\");\n\t\treturn FALSE;\n\t}\n\tStream_Read_UINT16(s, updateType); \n\tWLog_Print(update->log, WLOG_TRACE, \"%s Update Data PDU\", UPDATE_TYPE_STRINGS[updateType]);\n\tif (!update_begin_paint(update))\n\t\tgoto fail;\n\tswitch (updateType)\n\t{\n\t\tcase UPDATE_TYPE_ORDERS:\n\t\t\trc = update_recv_orders(update, s);\n\t\t\tbreak;\n\t\tcase UPDATE_TYPE_BITMAP:\n\t\t{\n\t\t\tBITMAP_UPDATE* bitmap_update = update_read_bitmap_update(update, s);\n\t\t\tif (!bitmap_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_BITMAP - update_read_bitmap_update() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\trc = IFCALLRESULT(FALSE, update->BitmapUpdate, context, bitmap_update);\n\t\t\tfree_bitmap_update(update->context, bitmap_update);\n\t\t}\n\t\tbreak;\n\t\tcase UPDATE_TYPE_PALETTE:\n\t\t{\n\t\t\tPALETTE_UPDATE* palette_update = update_read_palette(update, s);\n\t\t\tif (!palette_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_PALETTE - update_read_palette() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\trc = IFCALLRESULT(FALSE, update->Palette, context, palette_update);\n\t\t\tfree_palette_update(context, palette_update);\n\t\t}\n\t\tbreak;\n\t\tcase UPDATE_TYPE_SYNCHRONIZE:\n\t\t\tupdate_read_synchronize(update, s);\n\t\t\trc = IFCALLRESULT(TRUE, update->Synchronize, context);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\nfail:\n\tif (!update_end_paint(update))\n\t\trc = FALSE;\n\tif (!rc)\n\t{\n\t\tWLog_ERR(TAG, \"UPDATE_TYPE %s [%\" PRIu16 \"] failed\", update_type_to_string(updateType),\n\t\t         updateType);\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "static void llc_sap_rcv(struct llc_sap *sap, struct sk_buff *skb,\n\t\t\tstruct sock *sk)\n{\n\tstruct llc_sap_state_ev *ev = llc_sap_ev(skb);\n\tev->type   = LLC_SAP_EV_TYPE_PDU;\n\tev->reason = 0;\n\tskb_orphan(skb);\n\tsock_hold(sk);\n\tskb->sk = sk;\n\tskb->destructor = sock_efree;\n\tllc_sap_state_process(sap, skb);\n}", "target": 0}
{"code": "static int get_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)\n{\n\treturn usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),\n\t\t\t       RTL8150_REQ_GET_REGS, RTL8150_REQT_READ,\n\t\t\t       indx, 0, data, size, 500);\n}", "target": 1}
{"code": "static int ntlm_decode_u16l_str_hdr(struct ntlm_ctx *ctx,\n                                    struct wire_field_hdr *str_hdr,\n                                    struct ntlm_buffer *buffer,\n                                    size_t payload_offs, char **str)\n{\n    char *in, *out = NULL;\n    uint16_t str_len;\n    uint32_t str_offs;\n    size_t outlen;\n    int ret = 0;\n    str_len = le16toh(str_hdr->len);\n    if (str_len == 0) goto done;\n    str_offs = le32toh(str_hdr->offset);\n    if ((str_offs < payload_offs) ||\n        (str_offs > buffer->length) ||\n        (UINT32_MAX - str_offs < str_len) ||\n        (str_offs + str_len > buffer->length)) {\n        return ERR_DECODE;\n    }\n    in = (char *)&buffer->data[str_offs];\n    out = malloc(str_len * 2 + 1);\n    if (!out) return ENOMEM;\n    ret = ntlm_str_convert(ctx->to_oem, in, out, str_len, &outlen);\n    out[outlen] = '\\0';\ndone:\n    if (ret) {\n        safefree(out);\n    }\n    *str = out;\n    return ret;\n}", "target": 0}
{"code": "handle_mlppp(netdissect_options *ndo,\n             const u_char *p, int length)\n{\n    if (!ndo->ndo_eflag)\n        ND_PRINT((ndo, \"MLPPP, \"));\n    if (length < 2) {\n        ND_PRINT((ndo, \"[|mlppp]\"));\n        return;\n    }\n    if (!ND_TTEST_16BITS(p)) {\n        ND_PRINT((ndo, \"[|mlppp]\"));\n        return;\n    }\n    ND_PRINT((ndo, \"seq 0x%03x, Flags [%s], length %u\",\n           (EXTRACT_16BITS(p))&0x0fff, \n           bittok2str(ppp_ml_flag_values, \"none\", *p & 0xc0),\n           length));\n}", "target": 0}
{"code": "static int xfrm_dump_policy_start(struct netlink_callback *cb)\n{\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb->args;\n\tBUILD_BUG_ON(sizeof(*walk) > sizeof(cb->args));\n\txfrm_policy_walk_init(walk, XFRM_POLICY_TYPE_ANY);\n\treturn 0;\n}", "target": 0}
{"code": "ECDSA_PrivateKey::create_signature_op(RandomNumberGenerator& ,\n                                      const std::string& params,\n                                      const std::string& provider) const\n   {\n#if defined(BOTAN_HAS_BEARSSL)\n   if(provider == \"bearssl\" || provider.empty())\n      {\n      try\n         {\n         return make_bearssl_ecdsa_sig_op(*this, params);\n         }\n      catch(Lookup_Error& e)\n         {\n         if(provider == \"bearssl\")\n            throw;\n         }\n      }\n#endif\n#if defined(BOTAN_HAS_OPENSSL)\n   if(provider == \"openssl\" || provider.empty())\n      {\n      try\n         {\n         return make_openssl_ecdsa_sig_op(*this, params);\n         }\n      catch(Lookup_Error& e)\n         {\n         if(provider == \"openssl\")\n            throw;\n         }\n      }\n#endif\n   if(provider == \"base\" || provider.empty())\n      return std::unique_ptr<PK_Ops::Signature>(new ECDSA_Signature_Operation(*this, params));\n   throw Provider_Not_Found(algo_name(), provider);\n   }", "target": 1}
{"code": "static int sd_e_h(GWindow gw, GEvent *event) {\n    struct sd_data *sd = GDrawGetUserData(gw);\n    if ( sd==NULL )\nreturn( true );\n    if ( event->type==et_close ) {\n\tSD_DoCancel( sd );\n    } else if ( event->type==et_controlevent && event->u.control.subtype==et_textchanged ) {\n    sd->fv->script_unsaved = !GTextFieldIsEmpty(GWidgetGetControl(sd->gw,CID_Script));\n    } else if ( event->type==et_controlevent && event->u.control.subtype==et_save ) {\n    sd->fv->script_unsaved = false;\n    } else if ( event->type==et_char ) {\n\tif ( event->u.chr.keysym == GK_F1 || event->u.chr.keysym == GK_Help ) {\n\t    help(\"scripting.html\");\nreturn( true );\n\t}\nreturn( false );\n    } else if ( event->type == et_map )\t\n\tGDrawRaise(gw);\n    else if ( event->type == et_resize )\n\tGDrawRequestExpose(gw,NULL,false);\nreturn( true );\n}", "target": 0}
{"code": "ttwu_do_wakeup(struct rq *rq, struct task_struct *p, int wake_flags)\n{\n\tcheck_preempt_curr(rq, p, wake_flags);\n\tp->state = TASK_RUNNING;\n\ttrace_sched_wakeup(p);\n#ifdef CONFIG_SMP\n\tif (p->sched_class->task_woken) {\n\t\tlockdep_unpin_lock(&rq->lock);\n\t\tp->sched_class->task_woken(rq, p);\n\t\tlockdep_pin_lock(&rq->lock);\n\t}\n\tif (rq->idle_stamp) {\n\t\tu64 delta = rq_clock(rq) - rq->idle_stamp;\n\t\tu64 max = 2*rq->max_idle_balance_cost;\n\t\tupdate_avg(&rq->avg_idle, delta);\n\t\tif (rq->avg_idle > max)\n\t\t\trq->avg_idle = max;\n\t\trq->idle_stamp = 0;\n\t}\n#endif\n}", "target": 0}
{"code": "GF_Err chnl_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_ChannelLayoutBox *ptr = (GF_ChannelLayoutBox *) s;\n\tISOM_DECREASE_SIZE(s, 1)\n\tptr->layout.stream_structure = gf_bs_read_u8(bs);\n\tif (ptr->layout.stream_structure & 1) {\n\t\tISOM_DECREASE_SIZE(s, 1)\n\t\tptr->layout.definedLayout = gf_bs_read_u8(bs);\n\t\tif (ptr->layout.definedLayout==0) {\n\t\t\tu32 remain = (u32) ptr->size;\n\t\t\tif (ptr->layout.stream_structure & 2) remain--;\n\t\t\tptr->layout.channels_count = 0;\n\t\t\twhile (remain) {\n\t\t\t\tISOM_DECREASE_SIZE(s, 1)\n\t\t\t\tptr->layout.layouts[ptr->layout.channels_count].position = gf_bs_read_u8(bs);\n\t\t\t\tremain--;\n\t\t\t\tif (ptr->layout.layouts[ptr->layout.channels_count].position == 126) {\n\t\t\t\t\tISOM_DECREASE_SIZE(s, 3)\n\t\t\t\t\tptr->layout.layouts[ptr->layout.channels_count].azimuth = gf_bs_read_int(bs, 16);\n\t\t\t\t\tptr->layout.layouts[ptr->layout.channels_count].elevation = gf_bs_read_int(bs, 8);\n\t\t\t\t\tremain-=3;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(s, 8)\n\t\t\tptr->layout.omittedChannelsMap = gf_bs_read_u64(bs);\n\t\t}\n\t}\n\tif (ptr->layout.stream_structure & 2) {\n\t\tISOM_DECREASE_SIZE(s, 1)\n\t\tptr->layout.object_count = gf_bs_read_u8(bs);\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "register_for_each_vma(struct uprobe *uprobe, struct uprobe_consumer *new)\n{\n\tbool is_register = !!new;\n\tstruct map_info *info;\n\tint err = 0;\n\tpercpu_down_write(&dup_mmap_sem);\n\tinfo = build_map_info(uprobe->inode->i_mapping,\n\t\t\t\t\tuprobe->offset, is_register);\n\tif (IS_ERR(info)) {\n\t\terr = PTR_ERR(info);\n\t\tgoto out;\n\t}\n\twhile (info) {\n\t\tstruct mm_struct *mm = info->mm;\n\t\tstruct vm_area_struct *vma;\n\t\tif (err && is_register)\n\t\t\tgoto free;\n\t\tdown_write(&mm->mmap_sem);\n\t\tvma = find_vma(mm, info->vaddr);\n\t\tif (!vma || !valid_vma(vma, is_register) ||\n\t\t    file_inode(vma->vm_file) != uprobe->inode)\n\t\t\tgoto unlock;\n\t\tif (vma->vm_start > info->vaddr ||\n\t\t    vaddr_to_offset(vma, info->vaddr) != uprobe->offset)\n\t\t\tgoto unlock;\n\t\tif (is_register) {\n\t\t\tif (consumer_filter(new,\n\t\t\t\t\tUPROBE_FILTER_REGISTER, mm))\n\t\t\t\terr = install_breakpoint(uprobe, mm, vma, info->vaddr);\n\t\t} else if (test_bit(MMF_HAS_UPROBES, &mm->flags)) {\n\t\t\tif (!filter_chain(uprobe,\n\t\t\t\t\tUPROBE_FILTER_UNREGISTER, mm))\n\t\t\t\terr |= remove_breakpoint(uprobe, mm, info->vaddr);\n\t\t}\n unlock:\n\t\tup_write(&mm->mmap_sem);\n free:\n\t\tmmput(mm);\n\t\tinfo = free_map_info(info);\n\t}\n out:\n\tpercpu_up_write(&dup_mmap_sem);\n\treturn err;\n}", "target": 0}
{"code": "static int rfcomm_get_dev_list(void __user *arg)\n{\n\tstruct rfcomm_dev *dev;\n\tstruct rfcomm_dev_list_req *dl;\n\tstruct rfcomm_dev_info *di;\n\tint n = 0, size, err;\n\tu16 dev_num;\n\tBT_DBG(\"\");\n\tif (get_user(dev_num, (u16 __user *) arg))\n\t\treturn -EFAULT;\n\tif (!dev_num || dev_num > (PAGE_SIZE * 4) / sizeof(*di))\n\t\treturn -EINVAL;\n\tsize = sizeof(*dl) + dev_num * sizeof(*di);\n\tdl = kmalloc(size, GFP_KERNEL);\n\tif (!dl)\n\t\treturn -ENOMEM;\n\tdi = dl->dev_info;\n\tspin_lock(&rfcomm_dev_lock);\n\tlist_for_each_entry(dev, &rfcomm_dev_list, list) {\n\t\tif (test_bit(RFCOMM_TTY_RELEASED, &dev->flags))\n\t\t\tcontinue;\n\t\t(di + n)->id      = dev->id;\n\t\t(di + n)->flags   = dev->flags;\n\t\t(di + n)->state   = dev->dlc->state;\n\t\t(di + n)->channel = dev->channel;\n\t\tbacpy(&(di + n)->src, &dev->src);\n\t\tbacpy(&(di + n)->dst, &dev->dst);\n\t\tif (++n >= dev_num)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&rfcomm_dev_lock);\n\tdl->dev_num = n;\n\tsize = sizeof(*dl) + n * sizeof(*di);\n\terr = copy_to_user(arg, dl, size);\n\tkfree(dl);\n\treturn err ? -EFAULT : 0;\n}", "target": 1}
{"code": "static int whiteheat_probe(struct usb_serial *serial,\n\t\t\t\tconst struct usb_device_id *id)\n{\n\tstruct usb_host_interface *iface_desc;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tsize_t num_bulk_in = 0;\n\tsize_t num_bulk_out = 0;\n\tsize_t min_num_bulk;\n\tunsigned int i;\n\tiface_desc = serial->interface->cur_altsetting;\n\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; i++) {\n\t\tendpoint = &iface_desc->endpoint[i].desc;\n\t\tif (usb_endpoint_is_bulk_in(endpoint))\n\t\t\t++num_bulk_in;\n\t\tif (usb_endpoint_is_bulk_out(endpoint))\n\t\t\t++num_bulk_out;\n\t}\n\tmin_num_bulk = COMMAND_PORT + 1;\n\tif (num_bulk_in < min_num_bulk || num_bulk_out < min_num_bulk)\n\t\treturn -ENODEV;\n\treturn 0;\n}", "target": 0}
{"code": "GF_Err Media_CheckDataEntry(GF_MediaBox *mdia, u32 dataEntryIndex)\n{\n\tGF_DataEntryURLBox *entry;\n\tGF_DataMap *map;\n\tGF_Err e;\n\tif (!mdia || !dataEntryIndex || dataEntryIndex > gf_list_count(mdia->information->dataInformation->dref->child_boxes)) return GF_BAD_PARAM;\n\tentry = (GF_DataEntryURLBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataEntryIndex - 1);\n\tif (!entry) return GF_ISOM_INVALID_FILE;\n\tif (entry->flags == 1) return GF_OK;\n\tif (entry->type == GF_ISOM_BOX_TYPE_URN) return GF_NOT_SUPPORTED;\n\tif (mdia->mediaTrack->moov->mov->openMode == GF_ISOM_OPEN_WRITE) {\n\t\te = gf_isom_datamap_new(entry->location, NULL, GF_ISOM_DATA_MAP_READ, &map);\n\t} else {\n\t\te = gf_isom_datamap_new(entry->location, mdia->mediaTrack->moov->mov->fileName, GF_ISOM_DATA_MAP_READ, &map);\n\t}\n\tif (e) return e;\n\tgf_isom_datamap_del(map);\n\treturn GF_OK;\n}", "target": 1}
{"code": "    size_t MemIo::write(const byte* data, size_t wcount)\n    {\n        p_->reserve(wcount);\n        assert(p_->isMalloced_);\n        if (data != nullptr) {\n            std::memcpy(&p_->data_[p_->idx_], data, wcount);\n        }\n        p_->idx_ += wcount;\n        return wcount;\n    }", "target": 0}
{"code": "cib_recv_tls(gnutls_session * session)\n{\n    char *buf = NULL;\n    int rc = 0;\n    int len = 0;\n    int chunk_size = 1024;\n    if (session == NULL) {\n        return NULL;\n    }\n    buf = calloc(1, chunk_size);\n    while (TRUE) {\n        errno = 0;\n        rc = gnutls_record_recv(*session, buf + len, chunk_size);\n        crm_trace(\"Got %d more bytes. errno=%d\", rc, errno);\n        if (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN) {\n            crm_trace(\"Retry\");\n        } else if (rc == GNUTLS_E_UNEXPECTED_PACKET_LENGTH) {\n            crm_trace(\"Session disconnected\");\n            goto bail;\n        } else if (rc < 0) {\n            crm_err(\"Error receiving message: %s (%d)\", gnutls_strerror(rc), rc);\n            goto bail;\n        } else if (rc == chunk_size) {\n            len += rc;\n            chunk_size *= 2;\n            buf = realloc(buf, len + chunk_size);\n            crm_trace(\"Retry with %d more bytes\", (int)chunk_size);\n            CRM_ASSERT(buf != NULL);\n        } else if (buf[len + rc - 1] != 0) {\n            crm_trace(\"Last char is %d '%c'\", buf[len + rc - 1], buf[len + rc - 1]);\n            crm_trace(\"Retry with %d more bytes\", (int)chunk_size);\n            len += rc;\n            buf = realloc(buf, len + chunk_size);\n            CRM_ASSERT(buf != NULL);\n        } else {\n            crm_trace(\"Got %d more bytes\", (int)rc);\n            return buf;\n        }\n    }\n  bail:\n    free(buf);\n    return NULL;\n}", "target": 1}
{"code": "HttpStateData::continueAfterParsingHeader()\n{\n    if (flags.handling1xx) {\n        debugs(11, 5, HERE << \"wait for 1xx handling\");\n        Must(!flags.headers_parsed);\n        return false;\n    }\n    if (!flags.headers_parsed && !eof) {\n        debugs(11, 9, \"needs more at \" << inBuf.length());\n        flags.do_next_read = true;\n        maybeReadVirginBody(); \n        return false;\n    }\n    err_type error = ERR_NONE;\n    if (flags.headers_parsed) { \n        if (HttpReply *vrep = virginReply()) {\n            const Http::StatusCode s = vrep->sline.status();\n            const AnyP::ProtocolVersion &v = vrep->sline.version;\n            if (s == Http::scInvalidHeader && v != Http::ProtocolVersion(0,9)) {\n                debugs(11, DBG_IMPORTANT, \"WARNING: HTTP: Invalid Response: Bad header encountered from \" << entry->url() << \" AKA \" << request->url);\n                error = ERR_INVALID_RESP;\n            } else if (s == Http::scHeaderTooLarge) {\n                fwd->dontRetry(true);\n                error = ERR_TOO_BIG;\n            } else if (vrep->header.conflictingContentLength()) {\n                fwd->dontRetry(true);\n                error = ERR_INVALID_RESP;\n            } else if (vrep->header.unsupportedTe()) {\n                fwd->dontRetry(true);\n                error = ERR_INVALID_RESP;\n            } else {\n                return true; \n            }\n        } else {\n            debugs(11, DBG_IMPORTANT, \"WARNING: HTTP: Invalid Response: No reply at all for \" << entry->url() << \" AKA \" << request->url);\n            error = ERR_INVALID_RESP;\n        }\n    } else {\n        assert(eof);\n        if (inBuf.length()) {\n            error = ERR_INVALID_RESP;\n            debugs(11, DBG_IMPORTANT, \"WARNING: HTTP: Invalid Response: Headers did not parse at all for \" << entry->url() << \" AKA \" << request->url);\n        } else {\n            error = ERR_ZERO_SIZE_OBJECT;\n            debugs(11, (request->flags.accelerated?DBG_IMPORTANT:2), \"WARNING: HTTP: Invalid Response: No object data received for \" << entry->url() << \" AKA \" << request->url);\n        }\n    }\n    assert(error != ERR_NONE);\n    entry->reset();\n    fwd->fail(new ErrorState(error, Http::scBadGateway, fwd->request));\n    flags.do_next_read = false;\n    closeServer();\n    mustStop(\"HttpStateData::continueAfterParsingHeader\");\n    return false; \n}", "target": 0}
{"code": "int compat_get_fd_set(unsigned long nr, compat_ulong_t __user *ufdset,\n\t\t\tunsigned long *fdset)\n{\n\tnr = DIV_ROUND_UP(nr, __COMPAT_NFDBITS);\n\tif (ufdset) {\n\t\tunsigned long odd;\n\t\tif (!access_ok(VERIFY_WRITE, ufdset, nr*sizeof(compat_ulong_t)))\n\t\t\treturn -EFAULT;\n\t\todd = nr & 1UL;\n\t\tnr &= ~1UL;\n\t\twhile (nr) {\n\t\t\tunsigned long h, l;\n\t\t\tif (__get_user(l, ufdset) || __get_user(h, ufdset+1))\n\t\t\t\treturn -EFAULT;\n\t\t\tufdset += 2;\n\t\t\t*fdset++ = h << 32 | l;\n\t\t\tnr -= 2;\n\t\t}\n\t\tif (odd && __get_user(*fdset, ufdset))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tmemset(fdset, 0, ((nr + 1) & ~1)*sizeof(compat_ulong_t));\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "int ossl_dsa_check_priv_key(const DSA *dsa, const BIGNUM *priv_key, int *ret)\n{\n    *ret = 0;\n    return (dsa->params.q != NULL\n            && ossl_ffc_validate_private_key(dsa->params.q, priv_key, ret));\n}", "target": 1}
{"code": "partition_table_create_data_ref (CreatePartitionTableData *data)\n{\n  data->refcount++;\n  return data;\n}", "target": 0}
{"code": "MagickExport void *ResizeQuantumMemory(void *memory,const size_t count,\n  const size_t quantum)\n{\n  size_t\n    extent;\n  if (CheckMemoryOverflow(count,quantum) != MagickFalse)\n    {\n      memory=RelinquishMagickMemory(memory);\n      return((void *) NULL);\n    }\n  extent=count*quantum;\n  return(ResizeMagickMemory(memory,extent));\n}", "target": 1}
{"code": "void SSH_init(PTInstVar pvar)\n{\n\tint i;\n\tbuf_create(&pvar->ssh_state.outbuf, &pvar->ssh_state.outbuflen);\n\tbuf_create(&pvar->ssh_state.precompress_outbuf,\n\t           &pvar->ssh_state.precompress_outbuflen);\n\tbuf_create(&pvar->ssh_state.postdecompress_inbuf,\n\t           &pvar->ssh_state.postdecompress_inbuflen);\n\tpvar->ssh_state.payload = NULL;\n\tpvar->ssh_state.compressing = FALSE;\n\tpvar->ssh_state.decompressing = FALSE;\n\tpvar->ssh_state.status_flags =\n\t\tSTATUS_DONT_SEND_USER_NAME | STATUS_DONT_SEND_CREDENTIALS;\n\tpvar->ssh_state.payload_datalen = 0;\n\tpvar->ssh_state.hostname = NULL;\n\tpvar->ssh_state.server_ID = NULL;\n\tpvar->ssh_state.receiver_sequence_number = 0;\n\tpvar->ssh_state.sender_sequence_number = 0;\n\tfor (i = 0; i < NUM_ELEM(pvar->ssh_state.packet_handlers); i++) {\n\t\tpvar->ssh_state.packet_handlers[i] = NULL;\n\t}\n\tmemset(pvar->ssh2_keys, 0, sizeof(pvar->ssh2_keys));\n\tpvar->userauth_success = 0;\n\tpvar->shell_id = SSH_CHANNEL_INVALID;\n\tpvar->session_nego_status = 0;\n\tpvar->settings.ssh_protocol_version = 2;  \n\tpvar->kex_status = 0;\n\tpvar->ssh2_autologin = 0;  \n\tpvar->ask4passwd = 0; \n\tpvar->userauth_retry_count = 0;\n\tpvar->decomp_buffer = NULL;\n\tpvar->authbanner_buffer = NULL;\n\tpvar->ssh2_authlist = NULL; \n\tpvar->tryed_ssh2_authlist = FALSE;\n\tpvar->agentfwd_enable = FALSE;\n\tpvar->use_subsystem = FALSE;\n\tpvar->nosession = FALSE;\n\tpvar->server_sig_algs = NULL;\n\tpvar->server_strict_kex = FALSE;\n}", "target": 0}
{"code": "static void iwl_sta_ucode_activate(struct iwl_priv *priv, u8 sta_id)\n{\n\tif (!(priv->stations[sta_id].used & IWL_STA_DRIVER_ACTIVE))\n\t\tIWL_ERR(priv, \"ACTIVATE a non DRIVER active station id %u \"\n\t\t\t\"addr %pM\\n\",\n\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\tif (priv->stations[sta_id].used & IWL_STA_UCODE_ACTIVE) {\n\t\tIWL_DEBUG_ASSOC(priv,\n\t\t\t\t\"STA id %u addr %pM already present in uCode \"\n\t\t\t\t\"(according to driver)\\n\",\n\t\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\t} else {\n\t\tpriv->stations[sta_id].used |= IWL_STA_UCODE_ACTIVE;\n\t\tIWL_DEBUG_ASSOC(priv, \"Added STA id %u addr %pM to uCode\\n\",\n\t\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\t}\n}", "target": 1}
{"code": "static inline void skb_reset_mac_header(struct sk_buff *skb)\n{\n\tskb->mac_header = skb->data - skb->head;\n}", "target": 0}
{"code": "static void request_end(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tstruct fuse_iqueue *fiq = &fc->iq;\n\tif (test_and_set_bit(FR_FINISHED, &req->flags))\n\t\tgoto put_request;\n\tspin_lock(&fiq->waitq.lock);\n\tlist_del_init(&req->intr_entry);\n\tspin_unlock(&fiq->waitq.lock);\n\tWARN_ON(test_bit(FR_PENDING, &req->flags));\n\tWARN_ON(test_bit(FR_SENT, &req->flags));\n\tif (test_bit(FR_BACKGROUND, &req->flags)) {\n\t\tspin_lock(&fc->bg_lock);\n\t\tclear_bit(FR_BACKGROUND, &req->flags);\n\t\tif (fc->num_background == fc->max_background) {\n\t\t\tfc->blocked = 0;\n\t\t\twake_up(&fc->blocked_waitq);\n\t\t} else if (!fc->blocked) {\n\t\t\tif (waitqueue_active(&fc->blocked_waitq))\n\t\t\t\twake_up(&fc->blocked_waitq);\n\t\t}\n\t\tif (fc->num_background == fc->congestion_threshold && fc->sb) {\n\t\t\tclear_bdi_congested(fc->sb->s_bdi, BLK_RW_SYNC);\n\t\t\tclear_bdi_congested(fc->sb->s_bdi, BLK_RW_ASYNC);\n\t\t}\n\t\tfc->num_background--;\n\t\tfc->active_background--;\n\t\tflush_bg_queue(fc);\n\t\tspin_unlock(&fc->bg_lock);\n\t}\n\twake_up(&req->waitq);\n\tif (req->end)\n\t\treq->end(fc, req);\nput_request:\n\tfuse_put_request(fc, req);\n}", "target": 0}
{"code": "GF_Err chnl_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ChannelLayoutBox *ptr = (GF_ChannelLayoutBox *) s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->layout.stream_structure);\n\tif (ptr->layout.stream_structure & 1) {\n\t\tgf_bs_write_u8(bs, ptr->layout.definedLayout);\n\t\tif (ptr->layout.definedLayout==0) {\n\t\t\tu32 i;\n\t\t\tfor (i=0; i<ptr->layout.channels_count; i++) {\n\t\t\t\tgf_bs_write_u8(bs, ptr->layout.layouts[i].position);\n\t\t\t\tif (ptr->layout.layouts[i].position==126) {\n\t\t\t\t\tgf_bs_write_int(bs, ptr->layout.layouts[i].azimuth, 16);\n\t\t\t\t\tgf_bs_write_int(bs, ptr->layout.layouts[i].elevation, 8);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tgf_bs_write_u64(bs, ptr->layout.omittedChannelsMap);\n\t\t}\n\t}\n\tif (ptr->layout.stream_structure & 2) {\n\t\tgf_bs_write_u8(bs, ptr->layout.object_count);\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "Status TensorShapeFromTensor(const Tensor& t, PartialTensorShape* out) {\n  if (t.shape() == TensorShape({})) {\n    if ((t.dtype() == DT_INT32 && t.scalar<int32>()() == -1) ||\n        (t.dtype() == DT_INT64 && t.scalar<int64_t>()() == -1)) {\n      *out = PartialTensorShape();\n      return OkStatus();\n    }\n    return errors::InvalidArgument(\n        \"The only valid scalar shape tensor is the fully unknown shape \"\n        \"specified as -1.\");\n  } else if (t.shape().dims() != 1) {\n    return errors::InvalidArgument(\"Shape must be at most rank 1 but is rank \",\n                                   t.shape().dims());\n  }\n  if (t.dtype() == DT_INT32) {\n    return PartialTensorShape::MakePartialShape(t.vec<int32>().data(),\n                                                t.NumElements(), out);\n  } else if (t.dtype() == DT_INT64) {\n    return PartialTensorShape::MakePartialShape(t.vec<int64_t>().data(),\n                                                t.NumElements(), out);\n  }\n  return errors::InvalidArgument(\n      \"Expected an int32 or int64 shape tensor; found \",\n      DataTypeString(t.dtype()));\n}", "target": 0}
{"code": "int task_statm(struct mm_struct *mm, int *shared, int *text,\n\t       int *data, int *resident)\n{\n\t*shared = get_mm_counter(mm, file_rss);\n\t*text = (PAGE_ALIGN(mm->end_code) - (mm->start_code & PAGE_MASK))\n\t\t\t\t\t\t\t\t>> PAGE_SHIFT;\n\t*data = mm->total_vm - mm->shared_vm;\n\t*resident = *shared + get_mm_counter(mm, anon_rss);\n\treturn mm->total_vm;\n}", "target": 0}
{"code": "static int setup_ttydir_console(const struct lxc_rootfs *rootfs,\n\t\t\t const struct lxc_console *console,\n\t\t\t char *ttydir)\n{\n\tchar path[MAXPATHLEN], lxcpath[MAXPATHLEN];\n\tint ret;\n\tret = snprintf(path, sizeof(path), \"%s/dev/%s\", rootfs->mount,\n\t\t       ttydir);\n\tif (ret >= sizeof(path))\n\t\treturn -1;\n\tret = mkdir(path, 0755);\n\tif (ret && errno != EEXIST) {\n\t\tSYSERROR(\"failed with errno %d to create %s\", errno, path);\n\t\treturn -1;\n\t}\n\tINFO(\"created %s\", path);\n\tret = snprintf(lxcpath, sizeof(lxcpath), \"%s/dev/%s/console\",\n\t\t       rootfs->mount, ttydir);\n\tif (ret >= sizeof(lxcpath)) {\n\t\tERROR(\"console path too long\");\n\t\treturn -1;\n\t}\n\tsnprintf(path, sizeof(path), \"%s/dev/console\", rootfs->mount);\n\tret = unlink(path);\n\tif (ret && errno != ENOENT) {\n\t\tSYSERROR(\"error unlinking %s\", path);\n\t\treturn -1;\n\t}\n\tret = creat(lxcpath, 0660);\n\tif (ret==-1 && errno != EEXIST) {\n\t\tSYSERROR(\"error %d creating %s\", errno, lxcpath);\n\t\treturn -1;\n\t}\n\tif (ret >= 0)\n\t\tclose(ret);\n\tif (console->master < 0) {\n\t\tINFO(\"no console\");\n\t\treturn 0;\n\t}\n\tif (mount(console->name, lxcpath, \"none\", MS_BIND, 0)) {\n\t\tERROR(\"failed to mount '%s' on '%s'\", console->name, lxcpath);\n\t\treturn -1;\n\t}\n\tret = snprintf(lxcpath, sizeof(lxcpath), \"%s/console\", ttydir);\n\tif (ret >= sizeof(lxcpath)) {\n\t\tERROR(\"lxc/console path too long\");\n\t\treturn -1;\n\t}\n\tret = symlink(lxcpath, path);\n\tif (ret) {\n\t\tSYSERROR(\"failed to create symlink for console\");\n\t\treturn -1;\n\t}\n\tINFO(\"console has been setup on %s\", lxcpath);\n\treturn 0;\n}", "target": 1}
{"code": "static int complete_emulated_mmio(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *run = vcpu->run;\n\tstruct kvm_mmio_fragment *frag;\n\tunsigned len;\n\tBUG_ON(!vcpu->mmio_needed);\n\tfrag = &vcpu->mmio_fragments[vcpu->mmio_cur_fragment];\n\tlen = min(8u, frag->len);\n\tif (!vcpu->mmio_is_write)\n\t\tmemcpy(frag->data, run->mmio.data, len);\n\tif (frag->len <= 8) {\n\t\tfrag++;\n\t\tvcpu->mmio_cur_fragment++;\n\t} else {\n\t\tfrag->data += len;\n\t\tfrag->gpa += len;\n\t\tfrag->len -= len;\n\t}\n\tif (vcpu->mmio_cur_fragment == vcpu->mmio_nr_fragments) {\n\t\tvcpu->mmio_needed = 0;\n\t\tif (vcpu->mmio_is_write)\n\t\t\treturn 1;\n\t\tvcpu->mmio_read_completed = 1;\n\t\treturn complete_emulated_io(vcpu);\n\t}\n\trun->exit_reason = KVM_EXIT_MMIO;\n\trun->mmio.phys_addr = frag->gpa;\n\tif (vcpu->mmio_is_write)\n\t\tmemcpy(run->mmio.data, frag->data, min(8u, frag->len));\n\trun->mmio.len = min(8u, frag->len);\n\trun->mmio.is_write = vcpu->mmio_is_write;\n\tvcpu->arch.complete_userspace_io = complete_emulated_mmio;\n\treturn 0;\n}", "target": 1}
{"code": "exif_data_load_data_thumbnail (ExifData *data, const unsigned char *d,\n\t\t\t       unsigned int ds, ExifLong o, ExifLong s)\n{\n\tif ((o + s < o) || (o + s < s) || (o + s > ds) || (o > ds)) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t  \"Bogus thumbnail offset (%u) or size (%u).\",\n\t\t\t  o, s);\n\t\treturn;\n\t}\n\tif (data->data) \n\t\texif_mem_free (data->priv->mem, data->data);\n\tif (!(data->data = exif_data_alloc (data, s))) {\n\t\tEXIF_LOG_NO_MEMORY (data->priv->log, \"ExifData\", s);\n\t\tdata->size = 0;\n\t\treturn;\n\t}\n\tdata->size = s;\n\tmemcpy (data->data, d + o, s);\n}", "target": 1}
{"code": "static void send(node_t *node, node_t *child, byte *fout) {\n\tif (node->parent) {\n\t\tsend(node->parent, node, fout);\n\t}\n\tif (child) {\n\t\tif (node->right == child) {\n\t\t\tadd_bit(1, fout);\n\t\t} else {\n\t\t\tadd_bit(0, fout);\n\t\t}\n\t}\n}", "target": 1}
{"code": "cluster_free (struct cluster_list *cluster)\n{\n  if (cluster->list)\n    XFREE (MTYPE_CLUSTER_VAL, cluster->list);\n  XFREE (MTYPE_CLUSTER, cluster);\n}", "target": 0}
{"code": "static int tg_cfs_schedulable_down(struct task_group *tg, void *data)\n{\n\tstruct cfs_schedulable_data *d = data;\n\tstruct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth;\n\ts64 quota = 0, parent_quota = -1;\n\tif (!tg->parent) {\n\t\tquota = RUNTIME_INF;\n\t} else {\n\t\tstruct cfs_bandwidth *parent_b = &tg->parent->cfs_bandwidth;\n\t\tquota = normalize_cfs_quota(tg, d);\n\t\tparent_quota = parent_b->hierarchical_quota;\n\t\tif (quota == RUNTIME_INF)\n\t\t\tquota = parent_quota;\n\t\telse if (parent_quota != RUNTIME_INF && quota > parent_quota)\n\t\t\treturn -EINVAL;\n\t}\n\tcfs_b->hierarchical_quota = quota;\n\treturn 0;\n}", "target": 0}
{"code": "Network::FilterStatus Context::onNetworkNewConnection() {\n  onCreate(root_context_id_);\n  in_vm_context_created_ = true;\n  if (!wasm_->onNewConnection_) {\n    return Network::FilterStatus::Continue;\n  }\n  if (wasm_->onNewConnection_(this, id_).u64_ == 0) {\n    return Network::FilterStatus::Continue;\n  }\n  return Network::FilterStatus::StopIteration;\n}", "target": 0}
{"code": "find_alternate_tgs(kdc_realm_t *kdc_active_realm, krb5_principal princ,\n                   krb5_db_entry **server_ptr, const char **status)\n{\n    krb5_error_code retval;\n    krb5_principal *plist = NULL, *pl2;\n    krb5_data tmp;\n    krb5_db_entry *server = NULL;\n    *server_ptr = NULL;\n    assert(is_cross_tgs_principal(princ));\n    if ((retval = krb5_walk_realm_tree(kdc_context,\n                                       krb5_princ_realm(kdc_context, princ),\n                                       krb5_princ_component(kdc_context, princ, 1),\n                                       &plist, KRB5_REALM_BRANCH_CHAR))) {\n        goto cleanup;\n    }\n    for (pl2 = plist; *pl2; pl2++);\n    while (--pl2 > plist) {\n        tmp = *krb5_princ_realm(kdc_context, *pl2);\n        krb5_princ_set_realm(kdc_context, *pl2,\n                             krb5_princ_realm(kdc_context, tgs_server));\n        retval = db_get_svc_princ(kdc_context, *pl2, 0, &server, status);\n        krb5_princ_set_realm(kdc_context, *pl2, &tmp);\n        if (retval == KRB5_KDB_NOENTRY)\n            continue;\n        else if (retval)\n            goto cleanup;\n        log_tgs_alt_tgt(kdc_context, server->princ);\n        *server_ptr = server;\n        server = NULL;\n        goto cleanup;\n    }\ncleanup:\n    if (retval == 0 && server_ptr == NULL)\n        retval = KRB5_KDB_NOENTRY;\n    if (retval != 0)\n        *status = \"UNKNOWN_SERVER\";\n    krb5_free_realm_tree(kdc_context, plist);\n    krb5_db_free_principal(kdc_context, server);\n    return retval;\n}", "target": 0}
{"code": "static int virtio_gpu_object_shmem_init(struct virtio_gpu_device *vgdev,\n\t\t\t\t\tstruct virtio_gpu_object *bo,\n\t\t\t\t\tstruct virtio_gpu_mem_entry **ents,\n\t\t\t\t\tunsigned int *nents)\n{\n\tbool use_dma_api = !virtio_has_dma_quirk(vgdev->vdev);\n\tstruct virtio_gpu_object_shmem *shmem = to_virtio_gpu_shmem(bo);\n\tstruct scatterlist *sg;\n\tint si, ret;\n\tret = drm_gem_shmem_pin(&bo->base);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\tshmem->pages = drm_gem_shmem_get_sg_table(&bo->base);\n\tif (!shmem->pages) {\n\t\tdrm_gem_shmem_unpin(&bo->base);\n\t\treturn -EINVAL;\n\t}\n\tif (use_dma_api) {\n\t\tret = dma_map_sgtable(vgdev->vdev->dev.parent,\n\t\t\t\t      shmem->pages, DMA_TO_DEVICE, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t*nents = shmem->mapped = shmem->pages->nents;\n\t} else {\n\t\t*nents = shmem->pages->orig_nents;\n\t}\n\t*ents = kvmalloc_array(*nents,\n\t\t\t       sizeof(struct virtio_gpu_mem_entry),\n\t\t\t       GFP_KERNEL);\n\tif (!(*ents)) {\n\t\tDRM_ERROR(\"failed to allocate ent list\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tif (use_dma_api) {\n\t\tfor_each_sgtable_dma_sg(shmem->pages, sg, si) {\n\t\t\t(*ents)[si].addr = cpu_to_le64(sg_dma_address(sg));\n\t\t\t(*ents)[si].length = cpu_to_le32(sg_dma_len(sg));\n\t\t\t(*ents)[si].padding = 0;\n\t\t}\n\t} else {\n\t\tfor_each_sgtable_sg(shmem->pages, sg, si) {\n\t\t\t(*ents)[si].addr = cpu_to_le64(sg_phys(sg));\n\t\t\t(*ents)[si].length = cpu_to_le32(sg->length);\n\t\t\t(*ents)[si].padding = 0;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "USHORT CNB::QueryL4HeaderOffset(PVOID PacketData, ULONG IpHeaderOffset) const\n{\n    USHORT Res;\n    auto ppr = ParaNdis_ReviewIPPacket(RtlOffsetToPointer(PacketData, IpHeaderOffset),\n                                       GetDataLength(), __FUNCTION__);\n    if (ppr.ipStatus != ppresNotIP)\n    {\n        Res = static_cast<USHORT>(IpHeaderOffset + ppr.ipHeaderSize);\n    }\n    else\n    {\n        DPrintf(0, (\"[%s] ERROR: NOT an IP packet - expected troubles!\\n\", __FUNCTION__));\n        Res = 0;\n    }\n    return Res;\n}", "target": 1}
{"code": "yy_reduce_print (yytype_int16 *yyssp, YYSTYPE *yyvsp, int yyrule, void *yyscanner, RE_LEX_ENVIRONMENT *lex_env)\n{\n  unsigned long int yylno = yyrline[yyrule];\n  int yynrhs = yyr2[yyrule];\n  int yyi;\n  YYFPRINTF (stderr, \"Reducing stack by rule %d (line %lu):\\n\",\n             yyrule - 1, yylno);\n  for (yyi = 0; yyi < yynrhs; yyi++)\n    {\n      YYFPRINTF (stderr, \"   $%d = \", yyi + 1);\n      yy_symbol_print (stderr,\n                       yystos[yyssp[yyi + 1 - yynrhs]],\n                       &(yyvsp[(yyi + 1) - (yynrhs)])\n                                              , yyscanner, lex_env);\n      YYFPRINTF (stderr, \"\\n\");\n    }\n}", "target": 0}
{"code": "int copy_strings_kernel(int argc,char ** argv, struct linux_binprm *bprm)\n{\n\tint r;\n\tmm_segment_t oldfs = get_fs();\n\tset_fs(KERNEL_DS);\n\tr = copy_strings(argc, (char __user * __user *)argv, bprm);\n\tset_fs(oldfs);\n\treturn r;\n}", "target": 0}
{"code": "static void mark_commit(struct commit *c, void *data)\n{\n\tmark_object(&c->object, NULL, NULL, data);\n}", "target": 1}
{"code": "bool ECDSA_Verification_Operation::verify(const uint8_t msg[], size_t msg_len,\n                                          const uint8_t sig[], size_t sig_len)\n   {\n   if(sig_len != m_group.get_order_bytes() * 2)\n      return false;\n   const BigInt e(msg, msg_len, m_group.get_order_bits());\n   const BigInt r(sig, sig_len / 2);\n   const BigInt s(sig + sig_len / 2, sig_len / 2);\n   if(r <= 0 || r >= m_group.get_order() || s <= 0 || s >= m_group.get_order())\n      return false;\n   const BigInt w = m_group.inverse_mod_order(s);\n   const BigInt u1 = m_group.multiply_mod_order(e, w);\n   const BigInt u2 = m_group.multiply_mod_order(r, w);\n   const PointGFp R = m_gy_mul.multi_exp(u1, u2);\n   if(R.is_zero())\n      return false;\n   const BigInt v = m_group.mod_order(R.get_affine_x());\n   return (v == r);\n   }", "target": 1}
{"code": "spnego_gss_inquire_names_for_mech(\n\t\t\t\tOM_uint32\t*minor_status,\n\t\t\t\tgss_OID\t\tmechanism,\n\t\t\t\tgss_OID_set\t*name_types)\n{\n\tOM_uint32   major, minor;\n\tdsyslog(\"Entering inquire_names_for_mech\\n\");\n\tif ((mechanism != GSS_C_NULL_OID) &&\n\t    !g_OID_equal(gss_mech_spnego, mechanism)) {\n\t\t*minor_status = 0;\n\t\treturn (GSS_S_FAILURE);\n\t}\n\tmajor = gss_create_empty_oid_set(minor_status, name_types);\n\tif (major == GSS_S_COMPLETE) {\n\t\tif (((major = gss_add_oid_set_member(minor_status,\n\t\t\t\t(gss_OID) GSS_C_NT_USER_NAME,\n\t\t\t\tname_types)) == GSS_S_COMPLETE) &&\n\t\t    ((major = gss_add_oid_set_member(minor_status,\n\t\t\t\t(gss_OID) GSS_C_NT_MACHINE_UID_NAME,\n\t\t\t\tname_types)) == GSS_S_COMPLETE) &&\n\t\t    ((major = gss_add_oid_set_member(minor_status,\n\t\t\t\t(gss_OID) GSS_C_NT_STRING_UID_NAME,\n\t\t\t\tname_types)) == GSS_S_COMPLETE)) {\n\t\t\tmajor = gss_add_oid_set_member(minor_status,\n\t\t\t\t(gss_OID) GSS_C_NT_HOSTBASED_SERVICE,\n\t\t\t\tname_types);\n\t\t}\n\t\tif (major != GSS_S_COMPLETE)\n\t\t\t(void) gss_release_oid_set(&minor, name_types);\n\t}\n\tdsyslog(\"Leaving inquire_names_for_mech\\n\");\n\treturn (major);\n}", "target": 0}
{"code": "INST_HANDLER (sts) {\t\n\tif (len < 4) {\n\t\treturn;\n\t}\n\tint r = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tint k = (buf[3] << 8) | buf[2];\n\top->ptr = k;\n\tESIL_A (\"r%d,\", r);\n\t__generic_ld_st (op, \"ram\", 0, 1, 0, k, 1);\n\top->cycles = 2;\n}", "target": 0}
{"code": "njs_array_expand(njs_vm_t *vm, njs_array_t *array, uint32_t prepend,\n    uint32_t append)\n{\n    uint32_t     free_before, free_after;\n    uint64_t     size;\n    njs_value_t  *start, *old;\n    njs_assert(array->object.fast_array);\n    free_before = array->start - array->data;\n    free_after = array->size - array->length - free_before;\n    if (njs_fast_path(free_before >= prepend && free_after >= append)) {\n        return NJS_OK;\n    }\n    size = (uint64_t) prepend + array->length + append;\n    if (size < 16) {\n        size *= 2;\n    } else {\n        size += size / 2;\n    }\n    if (njs_slow_path(size > (UINT32_MAX / sizeof(njs_value_t)))) {\n        goto memory_error;\n    }\n    start = njs_mp_align(vm->mem_pool, sizeof(njs_value_t),\n                         size * sizeof(njs_value_t));\n    if (njs_slow_path(start == NULL)) {\n        goto memory_error;\n    }\n    array->size = size;\n    old = array->data;\n    array->data = start;\n    start += prepend;\n    if (array->length != 0) {\n        memcpy(start, array->start, array->length * sizeof(njs_value_t));\n    }\n    array->start = start;\n    njs_mp_free(vm->mem_pool, old);\n    return NJS_OK;\nmemory_error:\n    njs_memory_error(vm);\n    return NJS_ERROR;\n}", "target": 0}
{"code": "inline size_t codepoint_length(const char *s8, size_t l) {\n  if (l) {\n    auto b = static_cast<uint8_t>(s8[0]);\n    if ((b & 0x80) == 0) {\n      return 1;\n    } else if ((b & 0xE0) == 0xC0) {\n      return 2;\n    } else if ((b & 0xF0) == 0xE0) {\n      return 3;\n    } else if ((b & 0xF8) == 0xF0) {\n      return 4;\n    }\n  }\n  return 0;\n}", "target": 1}
{"code": "void key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}", "target": 0}
{"code": "static void __exit inet6_exit(void)\n{\n\tsock_unregister(PF_INET6);\n\trtnl_unregister_all(PF_INET6);\n#ifdef CONFIG_SYSCTL\n\tipv6_sysctl_unregister();\n#endif\n\tudpv6_exit();\n\tudplitev6_exit();\n\ttcpv6_exit();\n\tipv6_packet_cleanup();\n\tipv6_frag_exit();\n\tipv6_exthdrs_exit();\n\taddrconf_cleanup();\n\tip6_flowlabel_cleanup();\n\tip6_route_cleanup();\n#ifdef CONFIG_PROC_FS\n\tif6_proc_exit();\n\tipv6_misc_proc_exit();\n\tudplite6_proc_exit();\n\traw6_proc_exit();\n#endif\n\tipv6_netfilter_fini();\n\tigmp6_cleanup();\n\tndisc_cleanup();\n\ticmpv6_cleanup();\n\trawv6_exit();\n\tunregister_pernet_subsys(&inet6_net_ops);\n\tcleanup_ipv6_mibs();\n\tproto_unregister(&rawv6_prot);\n\tproto_unregister(&udplitev6_prot);\n\tproto_unregister(&udpv6_prot);\n\tproto_unregister(&tcpv6_prot);\n}", "target": 0}
{"code": "static void rose_loopback_timer(unsigned long param)\n{\n\tstruct sk_buff *skb;\n\tstruct net_device *dev;\n\trose_address *dest;\n\tstruct sock *sk;\n\tunsigned short frametype;\n\tunsigned int lci_i, lci_o;\n\twhile ((skb = skb_dequeue(&loopback_queue)) != NULL) {\n\t\tlci_i     = ((skb->data[0] << 8) & 0xF00) + ((skb->data[1] << 0) & 0x0FF);\n\t\tframetype = skb->data[2];\n\t\tdest      = (rose_address *)(skb->data + 4);\n\t\tlci_o     = ROSE_DEFAULT_MAXVC + 1 - lci_i;\n\t\tskb_reset_transport_header(skb);\n\t\tsk = rose_find_socket(lci_o, rose_loopback_neigh);\n\t\tif (sk) {\n\t\t\tif (rose_process_rx_frame(sk, skb) == 0)\n\t\t\t\tkfree_skb(skb);\n\t\t\tcontinue;\n\t\t}\n\t\tif (frametype == ROSE_CALL_REQUEST) {\n\t\t\tif ((dev = rose_dev_get(dest)) != NULL) {\n\t\t\t\tif (rose_rx_call_request(skb, dev, rose_loopback_neigh, lci_o) == 0)\n\t\t\t\t\tkfree_skb(skb);\n\t\t\t} else {\n\t\t\t\tkfree_skb(skb);\n\t\t\t}\n\t\t} else {\n\t\t\tkfree_skb(skb);\n\t\t}\n\t}\n}", "target": 1}
{"code": "static void vc_uniscr_delete(struct vc_data *vc, unsigned int nr)\n{\n\tstruct uni_screen *uniscr = get_vc_uniscr(vc);\n\tif (uniscr) {\n\t\tchar32_t *ln = uniscr->lines[vc->vc_y];\n\t\tunsigned int x = vc->vc_x, cols = vc->vc_cols;\n\t\tmemcpy(&ln[x], &ln[x + nr], (cols - x - nr) * sizeof(*ln));\n\t\tmemset32(&ln[cols - nr], ' ', nr);\n\t}\n}", "target": 0}
{"code": "  bool Messageheader::Parser::state_fieldbody_crlf(char ch)\n  {\n    if (ch == '\\r')\n      SET_STATE(state_end_cr);\n    else if (ch == '\\n')\n    {\n      log_debug(\"header \" << fieldnamePtr << \": \" << fieldbodyPtr);\n      switch (header.onField(fieldnamePtr, fieldbodyPtr))\n      {\n        case OK:\n        case END:  return true;\n                   break;\n        case FAIL: failedFlag = true;\n                   log_warn(\"invalid character \" << chartoprint(ch) << \" in fieldbody\");\n                   break;\n      }\n      *headerdataPtr = '\\0';\n      return true;\n    }\n    else if (std::isspace(ch))\n    {\n      checkHeaderspace(1);\n      *(headerdataPtr - 1) = '\\n';\n      *headerdataPtr++ = ch;\n      SET_STATE(state_fieldbody);\n    }\n    else if (ch >= 33 && ch <= 126)\n    {\n      switch (header.onField(fieldnamePtr, fieldbodyPtr))\n      {\n        case OK:   SET_STATE(state_fieldname);\n                   break;\n        case FAIL: failedFlag = true;\n                   log_warn(\"invalid character \" << chartoprint(ch) << \" in fieldbody\");\n                   break;\n        case END:  return true;\n                   break;\n      }\n      fieldnamePtr = headerdataPtr;\n      checkHeaderspace(1);\n      *headerdataPtr++ = ch;\n    }\n    return false;\n  }", "target": 0}
{"code": "static void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n{\n\tLIST_HEAD(tmp_list);\n\tstruct mount *p;\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_mount_unlock(mnt);\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tp->mnt.mnt_flags |= MNT_UMOUNT;\n\t\tlist_move(&p->mnt_list, &tmp_list);\n\t}\n\tlist_for_each_entry(p, &tmp_list, mnt_list) {\n\t\tlist_del_init(&p->mnt_child);\n\t}\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_umount(&tmp_list);\n\twhile (!list_empty(&tmp_list)) {\n\t\tbool disconnect;\n\t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n\t\tlist_del_init(&p->mnt_expire);\n\t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n\t\tif (how & UMOUNT_SYNC)\n\t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\t\tdisconnect = !(((how & UMOUNT_CONNECTED) &&\n\t\t\t\tmnt_has_parent(p) &&\n\t\t\t\t(p->mnt_parent->mnt.mnt_flags & MNT_UMOUNT)) ||\n\t\t\t       IS_MNT_LOCKED_AND_LAZY(p));\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,\n\t\t\t\t disconnect ? &unmounted : NULL);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tif (!disconnect) {\n\t\t\t\tlist_add_tail(&p->mnt_child, &p->mnt_parent->mnt_mounts);\n\t\t\t} else {\n\t\t\t\tumount_mnt(p);\n\t\t\t}\n\t\t}\n\t\tchange_mnt_propagation(p, MS_PRIVATE);\n\t}\n}", "target": 0}
{"code": "  AvgPoolGradOp(OpKernelConstruction* ctx, int num_spatial_dims)\n      : XlaOpKernel(ctx), num_spatial_dims_(num_spatial_dims) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"ksize\", &ksize_));\n    OP_REQUIRES(ctx, ksize_.size() == num_dims(),\n                errors::InvalidArgument(\"Sliding window ksize field must \"\n                                        \"specify \",\n                                        num_dims(), \" dimensions\"));\n    OP_REQUIRES_OK(ctx, ValidateKernelSizes(ksize_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"strides\", &stride_));\n    OP_REQUIRES(ctx, stride_.size() == num_dims(),\n                errors::InvalidArgument(\"Sliding window strides field must \"\n                                        \"specify \",\n                                        num_dims(), \" dimensions\"));\n    OP_REQUIRES_OK(ctx, ValidateStrides(stride_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"padding\", &padding_));\n    OP_REQUIRES(ctx, padding_ != EXPLICIT,\n                errors::Unimplemented(\n                    \"XLA does not support avgpoolgrad with explicit padding.\"));\n    OP_REQUIRES(ctx, ksize_[0] == 1 && stride_[0] == 1,\n                errors::Unimplemented(\n                    \"Pooling is not yet supported on the batch dimension.\"));\n    string data_format;\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"data_format\", &data_format));\n    OP_REQUIRES(ctx, FormatFromString(data_format, &data_format_),\n                errors::InvalidArgument(\"Invalid data format\"));\n  }", "target": 0}
{"code": "void kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu)\n{\n\tu32 data;\n\tvoid *vapic;\n\tif (test_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention))\n\t\tapic_sync_pv_eoi_from_guest(vcpu, vcpu->arch.apic);\n\tif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\n\t\treturn;\n\tvapic = kmap_atomic(vcpu->arch.apic->vapic_page);\n\tdata = *(u32 *)(vapic + offset_in_page(vcpu->arch.apic->vapic_addr));\n\tkunmap_atomic(vapic);\n\tapic_set_tpr(vcpu->arch.apic, data & 0xff);\n}", "target": 1}
{"code": "struct request *blk_mq_tag_to_rq(struct blk_mq_tags *tags, unsigned int tag)\n{\n\tstruct request *rq = tags->rqs[tag];\n\tstruct blk_flush_queue *fq = blk_get_flush_queue(rq->q, rq->mq_ctx);\n\tif (!is_flush_request(rq, fq, tag))\n\t\treturn rq;\n\treturn fq->flush_rq;\n}", "target": 1}
{"code": "static inline void tss_invalidate_io_bitmap(struct tss_struct *tss)\n{\n\ttss->x86_tss.io_bitmap_base = IO_BITMAP_OFFSET_INVALID;\n}", "target": 1}
{"code": "static inline zend_object_value date_object_new_date_ex(zend_class_entry *class_type, php_date_obj **ptr TSRMLS_DC)\n{\n\tphp_date_obj *intern;\n\tzend_object_value retval;\n\tintern = emalloc(sizeof(php_date_obj));\n\tmemset(intern, 0, sizeof(php_date_obj));\n\tif (ptr) {\n\t\t*ptr = intern;\n\t}\n\tzend_object_std_init(&intern->std, class_type TSRMLS_CC);\n\tobject_properties_init(&intern->std, class_type);\n\tretval.handle = zend_objects_store_put(intern, (zend_objects_store_dtor_t)zend_objects_destroy_object, (zend_objects_free_object_storage_t) date_object_free_storage_date, NULL TSRMLS_CC);\n\tretval.handlers = &date_object_handlers_date;\n\treturn retval;", "target": 0}
{"code": "NEDMALLOCNOALIASATTR NEDMALLOCPTRATTR void * nedpcalloc(nedpool *p, size_t no, size_t size) THROWSPEC\n{\n\tunsigned flags=NEDMALLOC_FORCERESERVE(p, 0, no*size);\n\treturn nedpmalloc2(p, size*no, 0, M2_ZERO_MEMORY|flags);\n}", "target": 1}
{"code": "static void get_info_from_frame (mpeg2ps_stream_t *sptr,\n                                 u8 *buffer,\n                                 u32 buflen)\n{\n\tif (sptr->is_video) {\n\t\tif (MPEG12_ParseSeqHdr(buffer, buflen,\n\t\t                       &sptr->have_mpeg2,\n\t\t                       &sptr->h,\n\t\t                       &sptr->w,\n\t\t                       &sptr->frame_rate,\n\t\t                       &sptr->bit_rate,\n\t\t                       &sptr->par) < 0) {\n\t\t\tsptr->m_stream_id = 0;\n\t\t\tsptr->m_fd = FDNULL;\n\t\t\treturn;\n\t\t}\n\t\tsptr->ticks_per_frame = (u64)(90000.0 / sptr->frame_rate);\n\t\treturn;\n\t}\n\tif (sptr->m_stream_id >= 0xc0) {\n\t\tu32 hdr = GF_4CC((u32)buffer[0],buffer[1],buffer[2],buffer[3]);\n\t\tsptr->channels = gf_mp3_num_channels(hdr);\n\t\tsptr->freq = gf_mp3_sampling_rate(hdr);\n\t\tsptr->samples_per_frame = gf_mp3_window_size(hdr);\n\t\tsptr->bitrate = gf_mp3_bit_rate(hdr) * 1000; \n\t\tsptr->layer = gf_mp3_layer(hdr);\n\t} else if (sptr->m_stream_id == 0xbd) {\n\t\tif (sptr->m_substream_id >= 0xa0) {\n\t\t} else if (sptr->m_substream_id >= 0x80) {\n\t\t\tu32 pos;\n\t\t\tGF_AC3Config hdr;\n\t\t\tmemset(&hdr, 0, sizeof(GF_AC3Config));\n\t\t\tgf_ac3_parser(buffer, buflen, &pos, &hdr, 0);\n\t\t\tsptr->bitrate = gf_ac3_get_bitrate(hdr.brcode);\n\t\t\tsptr->freq = hdr.sample_rate;\n\t\t\tsptr->channels = hdr.streams[0].channels;\n\t\t\tsptr->samples_per_frame = 256 * 6;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\treturn;\n\t}\n}", "target": 0}
{"code": "xmlPushInput(xmlParserCtxtPtr ctxt, xmlParserInputPtr input) {\n    int ret;\n    if (input == NULL) return(-1);\n    if (xmlParserDebugEntities) {\n\tif ((ctxt->input != NULL) && (ctxt->input->filename))\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"%s(%d): \", ctxt->input->filename,\n\t\t    ctxt->input->line);\n\txmlGenericError(xmlGenericErrorContext,\n\t\t\"Pushing input %d : %.30s\\n\", ctxt->inputNr+1, input->cur);\n    }\n    if (((ctxt->inputNr > 40) && ((ctxt->options & XML_PARSE_HUGE) == 0)) ||\n        (ctxt->inputNr > 1024)) {\n        xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n        while (ctxt->inputNr > 1)\n            xmlFreeInputStream(inputPop(ctxt));\n\treturn(-1);\n    }\n    ret = inputPush(ctxt, input);\n    if (ctxt->instate == XML_PARSER_EOF)\n        return(-1);\n    GROW;\n    return(ret);\n}", "target": 0}
{"code": "MagickExport void *AcquireQuantumMemory(const size_t count,const size_t quantum)\n{\n  size_t\n    extent;\n  if (CheckMemoryOverflow(count,quantum) != MagickFalse)\n    return((void *) NULL);\n  extent=count*quantum;\n  return(AcquireMagickMemory(extent));\n}", "target": 1}
{"code": "krb5_gss_inquire_sec_context_by_oid (OM_uint32 *minor_status,\n                                     const gss_ctx_id_t context_handle,\n                                     const gss_OID desired_object,\n                                     gss_buffer_set_t *data_set)\n{\n    krb5_gss_ctx_id_rec *ctx;\n    size_t i;\n    if (minor_status == NULL)\n        return GSS_S_CALL_INACCESSIBLE_WRITE;\n    *minor_status = 0;\n    if (desired_object == GSS_C_NO_OID)\n        return GSS_S_CALL_INACCESSIBLE_READ;\n    if (data_set == NULL)\n        return GSS_S_CALL_INACCESSIBLE_WRITE;\n    *data_set = GSS_C_NO_BUFFER_SET;\n    ctx = (krb5_gss_ctx_id_rec *) context_handle;\n    if (!ctx->established)\n        return GSS_S_NO_CONTEXT;\n    for (i = 0; i < sizeof(krb5_gss_inquire_sec_context_by_oid_ops)/\n             sizeof(krb5_gss_inquire_sec_context_by_oid_ops[0]); i++) {\n        if (g_OID_prefix_equal(desired_object, &krb5_gss_inquire_sec_context_by_oid_ops[i].oid)) {\n            return (*krb5_gss_inquire_sec_context_by_oid_ops[i].func)(minor_status,\n                                                                      context_handle,\n                                                                      desired_object,\n                                                                      data_set);\n        }\n    }\n    *minor_status = EINVAL;\n    return GSS_S_UNAVAILABLE;\n}", "target": 1}
{"code": "void __detach_mounts(struct dentry *dentry)\n{\n\tstruct mountpoint *mp;\n\tstruct mount *mnt;\n\tnamespace_lock();\n\tmp = lookup_mountpoint(dentry);\n\tif (IS_ERR_OR_NULL(mp))\n\t\tgoto out_unlock;\n\tlock_mount_hash();\n\twhile (!hlist_empty(&mp->m_list)) {\n\t\tmnt = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list);\n\t\tif (mnt->mnt.mnt_flags & MNT_UMOUNT) {\n\t\t\tstruct mount *p, *tmp;\n\t\t\tlist_for_each_entry_safe(p, tmp, &mnt->mnt_mounts,  mnt_child) {\n\t\t\t\thlist_add_head(&p->mnt_umount.s_list, &unmounted);\n\t\t\t\tumount_mnt(p);\n\t\t\t}\n\t\t}\n\t\telse umount_tree(mnt, 0);\n\t}\n\tunlock_mount_hash();\n\tput_mountpoint(mp);\nout_unlock:\n\tnamespace_unlock();\n}", "target": 1}
{"code": "static inline void pipe_truncate(struct iov_iter *i)\n{\n\tstruct pipe_inode_info *pipe = i->pipe;\n\tif (pipe->nrbufs) {\n\t\tsize_t off = i->iov_offset;\n\t\tint idx = i->idx;\n\t\tint nrbufs = (idx - pipe->curbuf) & (pipe->buffers - 1);\n\t\tif (off) {\n\t\t\tpipe->bufs[idx].len = off - pipe->bufs[idx].offset;\n\t\t\tidx = next_idx(idx, pipe);\n\t\t\tnrbufs++;\n\t\t}\n\t\twhile (pipe->nrbufs > nrbufs) {\n\t\t\tpipe_buf_release(pipe, &pipe->bufs[idx]);\n\t\t\tidx = next_idx(idx, pipe);\n\t\t\tpipe->nrbufs--;\n\t\t}\n\t}\n}", "target": 0}
{"code": "srs_timestamp_check(srs_t *srs, const char *stamp)\n{\n\tconst char\t*sp;\n\tchar\t\t*bp;\n\tint\t\t\t off;\n\ttime_t\t\t now;\n\ttime_t\t\t then;\n\tif (strlen(stamp) != 2) return SRS_ETIMESTAMPOUTOFDATE;\n\tthen = 0;\n\tfor (sp = stamp; *sp; sp++) {\n\t\tbp = strchr(SRS_TIME_BASECHARS, toupper(*sp));\n\t\tif (bp == NULL)\n\t\t\treturn SRS_EBADTIMESTAMPCHAR;\n\t\toff = bp - SRS_TIME_BASECHARS;\n\t\tthen = (then << SRS_TIME_BASEBITS) | off;\n\t}\n\ttime(&now);\n\tnow = (now / SRS_TIME_PRECISION) % SRS_TIME_SLOTS;\n\twhile (now < then)\n\t\tnow = now + SRS_TIME_SLOTS;\n\tif (now <= then + srs->maxage)\n\t\treturn SRS_SUCCESS;\n\treturn SRS_ETIMESTAMPOUTOFDATE;\n}", "target": 0}
{"code": "int IniParser::write_file(const string & filename, IniSection & section)\n{\n    Pathname pn(filename);\n    PathInfo::assert_dir (pn.dirname ());\n    mode_t file_umask = section.isPrivate()? 0077: 0022;\n    mode_t orig_umask = umask(file_umask);\n    unlink(filename.c_str());\n    ofstream of(filename.c_str());\n    if (!of.good()) {\n        y2error (\"Can not open file %s for write\", filename.c_str());\n        return -1;\n    }\n    write_helper (section, of, 0);\n    of.close();\n    umask(orig_umask);\n    return 0;\n}", "target": 0}
{"code": "TEE_Result tee_mmu_check_access_rights(const struct user_ta_ctx *utc,\n\t\t\t\t       uint32_t flags, uaddr_t uaddr,\n\t\t\t\t       size_t len)\n{\n\tuaddr_t a;\n\tsize_t addr_incr = MIN(CORE_MMU_USER_CODE_SIZE,\n\t\t\t       CORE_MMU_USER_PARAM_SIZE);\n\tif (ADD_OVERFLOW(uaddr, len, &a))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t    (flags & TEE_MEMORY_ACCESS_SECURE))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\tif (!(flags & TEE_MEMORY_ACCESS_ANY_OWNER) &&\n\t   !tee_mmu_is_vbuf_inside_ta_private(utc, (void *)uaddr, len))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\tfor (a = uaddr; a < (uaddr + len); a += addr_incr) {\n\t\tuint32_t attr;\n\t\tTEE_Result res;\n\t\tres = tee_mmu_user_va2pa_attr(utc, (void *)a, NULL, &attr);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t\t    (attr & TEE_MATTR_SECURE))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t\tif ((flags & TEE_MEMORY_ACCESS_SECURE) &&\n\t\t    !(attr & TEE_MATTR_SECURE))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t\tif ((flags & TEE_MEMORY_ACCESS_WRITE) && !(attr & TEE_MATTR_UW))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t\tif ((flags & TEE_MEMORY_ACCESS_READ) && !(attr & TEE_MATTR_UR))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t}\n\treturn TEE_SUCCESS;\n}", "target": 1}
{"code": "crm_recv_plaintext(int sock, size_t max_size, size_t *recv_len, int *disconnected)\n{\n    char *buf = NULL;\n    ssize_t rc = 0;\n    ssize_t len = 0;\n    ssize_t chunk_size = max_size ? max_size : 1024;\n    size_t buf_size = 0;\n    size_t read_size = 0;\n    if (sock <= 0) {\n        if (disconnected) {\n            *disconnected = 1;\n        }\n        goto done;\n    }\n    buf = calloc(1, chunk_size + 1);\n    buf_size = chunk_size;\n    while (TRUE) {\n        errno = 0;\n        read_size = buf_size - len;\n        if (!max_size && (read_size < (chunk_size / 2))) {\n            buf_size += chunk_size;\n            crm_trace(\"Grow buffer by %d more bytes. buf is now %d bytes\", (int)chunk_size, buf_size);\n            buf = realloc(buf, buf_size + 1);\n            CRM_ASSERT(buf != NULL);\n            read_size = buf_size - len;\n        }\n        rc = read(sock, buf + len, chunk_size);\n        if (rc > 0) {\n            crm_trace(\"Got %d more bytes. errno=%d\", (int)rc, errno);\n            len += rc;\n            buf[len] = '\\0';\n        }\n        if (max_size && (max_size == read_size)) {\n            crm_trace(\"Buffer max read size %d met\" , max_size);\n            goto done;\n        }\n        if (rc > 0) {\n            continue;\n        } else if (rc == 0) {\n            if (disconnected) {\n                *disconnected = 1;\n            }\n            crm_trace(\"EOF encoutered during read\");\n            goto done;\n        }\n        if (errno == EINTR) {\n            crm_trace(\"EINTER encoutered, retry socket read.\");\n        } else if (errno == EAGAIN) {\n            crm_trace(\"non-blocking, exiting read on rc = %d\", rc);\n            goto done;\n        } else if (errno <= 0) {\n            if (disconnected) {\n                *disconnected = 1;\n            }\n            crm_debug(\"Error receiving message: %d\", (int)rc);\n            goto done;\n        }\n    }\ndone:\n    if (recv_len) {\n        *recv_len = len;\n    }\n    if (!len) {\n        free(buf);\n        buf = NULL;\n    }\n    return buf;\n}", "target": 0}
{"code": "static int hci_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t len, int flags)\n{\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint copied, err;\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\tif (flags & (MSG_OOB))\n\t\treturn -EOPNOTSUPP;\n\tif (sk->sk_state == BT_CLOSED)\n\t\treturn 0;\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\treturn err;\n\tmsg->msg_namelen = 0;\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tswitch (hci_pi(sk)->channel) {\n\tcase HCI_CHANNEL_RAW:\n\t\thci_sock_cmsg(sk, msg, skb);\n\t\tbreak;\n\tcase HCI_CHANNEL_USER:\n\tcase HCI_CHANNEL_CONTROL:\n\tcase HCI_CHANNEL_MONITOR:\n\t\tsock_recv_timestamp(msg, sk, skb);\n\t\tbreak;\n\t}\n\tskb_free_datagram(sk, skb);\n\treturn err ? : copied;\n}", "target": 1}
{"code": "static GCObject **correctgraylist (GCObject **p) {\n  GCObject *curr;\n  while ((curr = *p) != NULL) {\n    switch (curr->tt) {\n      case LUA_VTABLE: case LUA_VUSERDATA: {\n        GCObject **next = getgclist(curr);\n        if (getage(curr) == G_TOUCHED1) {  \n          lua_assert(isgray(curr));\n          gray2black(curr);  \n          changeage(curr, G_TOUCHED1, G_TOUCHED2);\n          p = next;  \n        }\n        else {  \n          if (!iswhite(curr)) {  \n            lua_assert(isold(curr));\n            if (getage(curr) == G_TOUCHED2)  \n              changeage(curr, G_TOUCHED2, G_OLD);  \n            gray2black(curr);  \n          }\n          *p = *next;  \n        }\n        break;\n      }\n      case LUA_VTHREAD: {\n        lua_State *th = gco2th(curr);\n        lua_assert(!isblack(th));\n        if (iswhite(th))  \n          *p = th->gclist;  \n        else  \n          p = &th->gclist;  \n        break;\n      }\n      default: lua_assert(0);  \n    }\n  }\n  return p;\n}", "target": 1}
{"code": "static void ufs_mtk_init_va09_pwr_ctrl(struct ufs_hba *hba)\n{\n\tstruct ufs_mtk_host *host = ufshcd_get_variant(hba);\n\thost->reg_va09 = regulator_get(hba->dev, \"va09\");\n\tif (!host->reg_va09)\n\t\tdev_info(hba->dev, \"failed to get va09\");\n\telse\n\t\thost->caps |= UFS_MTK_CAP_VA09_PWR_CTRL;\n}", "target": 1}
{"code": "static int http_connect(http_subtransport *t)\n{\n\tint error;\n\tif (t->connected &&\n\t\thttp_should_keep_alive(&t->parser) &&\n\t\tt->parse_finished)\n\t\treturn 0;\n\tif (t->io) {\n\t\tgit_stream_close(t->io);\n\t\tgit_stream_free(t->io);\n\t\tt->io = NULL;\n\t\tt->connected = 0;\n\t}\n\tif (t->connection_data.use_ssl) {\n\t\terror = git_tls_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n\t} else {\n#ifdef GIT_CURL\n\t\terror = git_curl_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n#else\n\t\terror = git_socket_stream_new(&t->io,  t->connection_data.host, t->connection_data.port);\n#endif\n\t}\n\tif (error < 0)\n\t\treturn error;\n\tGITERR_CHECK_VERSION(t->io, GIT_STREAM_VERSION, \"git_stream\");\n\tapply_proxy_config(t);\n\terror = git_stream_connect(t->io);\n\tif ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&\n\t    git_stream_is_encrypted(t->io)) {\n\t\tgit_cert *cert;\n\t\tint is_valid;\n\t\tif ((error = git_stream_certificate(&cert, t->io)) < 0)\n\t\t\treturn error;\n\t\tgiterr_clear();\n\t\tis_valid = error != GIT_ECERTIFICATE;\n\t\terror = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);\n\t\tif (error < 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set(GITERR_NET, \"user cancelled certificate check\");\n\t\t\treturn error;\n\t\t}\n\t}\n\tif (error < 0)\n\t\treturn error;\n\tt->connected = 1;\n\treturn 0;\n}", "target": 1}
{"code": "prepare_singleton_class(mrb_state *mrb, struct RBasic *o)\n{\n  struct RClass *sc, *c;\n  mrb_assert(o->c);\n  if (o->c->tt == MRB_TT_SCLASS) return;\n  sc = MRB_OBJ_ALLOC(mrb, MRB_TT_SCLASS, mrb->class_class);\n  sc->flags |= MRB_FL_CLASS_IS_INHERITED;\n  sc->mt = mt_new(mrb);\n  sc->iv = 0;\n  if (o->tt == MRB_TT_CLASS) {\n    c = (struct RClass*)o;\n    if (!c->super) {\n      sc->super = mrb->class_class;\n    }\n    else {\n      sc->super = c->super->c;\n    }\n  }\n  else if (o->tt == MRB_TT_SCLASS) {\n    c = (struct RClass*)o;\n    while (c->super->tt == MRB_TT_ICLASS)\n      c = c->super;\n    make_metaclass(mrb, c->super);\n    sc->super = c->super->c;\n  }\n  else {\n    sc->super = o->c;\n    prepare_singleton_class(mrb, (struct RBasic*)sc);\n  }\n  o->c = sc;\n  mrb_field_write_barrier(mrb, (struct RBasic*)o, (struct RBasic*)sc);\n  mrb_field_write_barrier(mrb, (struct RBasic*)sc, (struct RBasic*)o);\n  mrb_obj_iv_set(mrb, (struct RObject*)sc, MRB_SYM(__attached__), mrb_obj_value(o));\n  sc->flags |= o->flags & MRB_FL_OBJ_IS_FROZEN;\n}", "target": 0}
{"code": "NCR_CheckAccessRestriction(IPAddr *ip_addr)\n{\n  return ADF_IsAllowed(access_auth_table, ip_addr);\n}", "target": 0}
{"code": "static void pageset_init(struct per_cpu_pageset *p)\n{\n\tstruct per_cpu_pages *pcp;\n\tint migratetype;\n\tmemset(p, 0, sizeof(*p));\n\tpcp = &p->pcp;\n\tpcp->count = 0;\n\tfor (migratetype = 0; migratetype < MIGRATE_PCPTYPES; migratetype++)\n\t\tINIT_LIST_HEAD(&pcp->lists[migratetype]);\n}", "target": 0}
{"code": "header_cache_t *imap_hcache_open(struct ImapData *idata, const char *path)\n{\n  struct ImapMbox mx;\n  struct Url url;\n  char cachepath[PATH_MAX];\n  char mbox[PATH_MAX];\n  if (path)\n    imap_cachepath(idata, path, mbox, sizeof(mbox));\n  else\n  {\n    if (!idata->ctx || imap_parse_path(idata->ctx->path, &mx) < 0)\n      return NULL;\n    imap_cachepath(idata, mx.mbox, mbox, sizeof(mbox));\n    FREE(&mx.mbox);\n  }\n  if (strstr(mbox, \"/../\") || (strcmp(mbox, \"..\") == 0) || (strncmp(mbox, \"../\", 3) == 0))\n    return NULL;\n  size_t len = strlen(mbox);\n  if ((len > 3) && (strcmp(mbox + len - 3, \"/..\") == 0))\n    return NULL;\n  mutt_account_tourl(&idata->conn->account, &url);\n  url.path = mbox;\n  url_tostring(&url, cachepath, sizeof(cachepath), U_PATH);\n  return mutt_hcache_open(HeaderCache, cachepath, imap_hcache_namer);\n}", "target": 0}
{"code": "static void update_read_synchronize(rdpUpdate* update, wStream* s)\n{\n\tWINPR_UNUSED(update);\n\tStream_Seek_UINT16(s); \n}", "target": 1}
{"code": "static int propagate_one(struct mount *m)\n{\n\tstruct mount *child;\n\tint type;\n\tif (IS_MNT_NEW(m))\n\t\treturn 0;\n\tif (!is_subdir(mp->m_dentry, m->mnt.mnt_root))\n\t\treturn 0;\n\tif (peers(m, last_dest)) {\n\t\ttype = CL_MAKE_SHARED;\n\t} else {\n\t\tstruct mount *n, *p;\n\t\tfor (n = m; ; n = p) {\n\t\t\tp = n->mnt_master;\n\t\t\tif (p == dest_master || IS_MNT_MARKED(p)) {\n\t\t\t\twhile (last_dest->mnt_master != p) {\n\t\t\t\t\tlast_source = last_source->mnt_master;\n\t\t\t\t\tlast_dest = last_source->mnt_parent;\n\t\t\t\t}\n\t\t\t\tif (!peers(n, last_dest)) {\n\t\t\t\t\tlast_source = last_source->mnt_master;\n\t\t\t\t\tlast_dest = last_source->mnt_parent;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ttype = CL_SLAVE;\n\t\tif (IS_MNT_SHARED(m))\n\t\t\ttype |= CL_MAKE_SHARED;\n\t}\n\tif (m->mnt_ns->user_ns != user_ns)\n\t\ttype |= CL_UNPRIVILEGED;\n\tchild = copy_tree(last_source, last_source->mnt.mnt_root, type);\n\tif (IS_ERR(child))\n\t\treturn PTR_ERR(child);\n\tchild->mnt.mnt_flags &= ~MNT_LOCKED;\n\tmnt_set_mountpoint(m, mp, child);\n\tlast_dest = m;\n\tlast_source = child;\n\tif (m->mnt_master != dest_master) {\n\t\tread_seqlock_excl(&mount_lock);\n\t\tSET_MNT_MARK(m->mnt_master);\n\t\tread_sequnlock_excl(&mount_lock);\n\t}\n\thlist_add_head(&child->mnt_hash, list);\n\treturn 0;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const float min_input = context->input(1).flat<float>()(0);\n    const float max_input = context->input(2).flat<float>()(0);\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input.shape(), &output));\n    const T min_as_quantized = FloatToQuantized<T>(0.0f, min_input, max_input);\n    if (meta::IsSupportedAndEnabled() && std::is_same<T, quint8>()) {\n      auto input_ui8_array = input.flat<quint8>();\n      meta::Clamp(context, input_ui8_array.data(), input_ui8_array.size(),\n                  min_as_quantized, 255, output->flat<quint8>().data());\n    } else {\n      output->flat<T>().device(context->eigen_cpu_device()) =\n          input.flat<T>().cwiseMax(min_as_quantized).template cast<T>();\n    }\n    Tensor* output_min = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, {}, &output_min));\n    output_min->flat<float>()(0) = min_input;\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(2, {}, &output_max));\n    output_max->flat<float>()(0) = max_input;\n  }", "target": 1}
{"code": "smb3_free_compound_rqst(int num_rqst, struct smb_rqst *rqst)\n{\n\tint i, j;\n\tfor (i = 0; i < num_rqst; i++) {\n\t\tif (rqst[i].rq_pages) {\n\t\t\tfor (j = rqst[i].rq_npages - 1; j >= 0; j--)\n\t\t\t\tput_page(rqst[i].rq_pages[j]);\n\t\t\tkfree(rqst[i].rq_pages);\n\t\t}\n\t}\n}", "target": 0}
{"code": "print_bacp_config_options(netdissect_options *ndo,\n                          const u_char *p, int length)\n{\n\tint len, opt;\n\tif (length < 2)\n\t\treturn 0;\n\tND_TCHECK2(*p, 2);\n\tlen = p[1];\n\topt = p[0];\n\tif (length < len)\n\t\treturn 0;\n\tif (len < 2) {\n\t\tND_PRINT((ndo, \"\\n\\t  %s Option (0x%02x), length %u (length bogus, should be >= 2)\",\n\t\t          tok2str(bacconfopts_values, \"Unknown\", opt),\n\t\t          opt,\n\t\t          len));\n\t\treturn 0;\n\t}\n\tND_PRINT((ndo, \"\\n\\t  %s Option (0x%02x), length %u\",\n\t          tok2str(bacconfopts_values, \"Unknown\", opt),\n\t          opt,\n\t          len));\n\tswitch (opt) {\n\tcase BACPOPT_FPEER:\n\t\tif (len != 6) {\n\t\t\tND_PRINT((ndo, \" (length bogus, should be = 6)\"));\n\t\t\treturn len;\n\t\t}\n\t\tND_TCHECK2(*(p + 2), 4);\n\t\tND_PRINT((ndo, \": Magic-Num 0x%08x\", EXTRACT_32BITS(p + 2)));\n\t\tbreak;\n\tdefault:\n\t\tif (ndo->ndo_vflag < 2)\n\t\t\tprint_unknown_data(ndo, &p[2], \"\\n\\t    \", len - 2);\n\t\tbreak;\n\t}\n\tif (ndo->ndo_vflag > 1)\n\t\tprint_unknown_data(ndo, &p[2], \"\\n\\t    \", len - 2); \n\treturn len;\ntrunc:\n\tND_PRINT((ndo, \"[|bacp]\"));\n\treturn 0;\n}", "target": 1}
{"code": "static struct sk_buff **ipip_gro_receive(struct sk_buff **head,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tif (NAPI_GRO_CB(skb)->encap_mark) {\n\t\tNAPI_GRO_CB(skb)->flush = 1;\n\t\treturn NULL;\n\t}\n\tNAPI_GRO_CB(skb)->encap_mark = 1;\n\treturn inet_gro_receive(head, skb);\n}", "target": 0}
{"code": "static MagickOffsetType TIFFSeekCustomStream(const MagickOffsetType offset,\n  const int whence,void *user_data)\n{\n  PhotoshopProfile\n    *profile;\n  profile=(PhotoshopProfile *) user_data;\n  switch (whence)\n  {\n    case SEEK_SET:\n    default:\n    {\n      if (offset < 0)\n        return(-1);\n      profile->offset=offset;\n      break;\n    }\n    case SEEK_CUR:\n    {\n      if (((offset > 0) && (profile->offset > (SSIZE_MAX-offset))) ||\n          ((offset < 0) && (profile->offset < (-SSIZE_MAX-offset))))\n        {\n          errno=EOVERFLOW;\n          return(-1);\n        }\n      if ((profile->offset+offset) < 0)\n        return(-1);\n      profile->offset+=offset;\n      break;\n    }\n    case SEEK_END:\n    {\n      if (((MagickOffsetType) profile->length+offset) < 0)\n        return(-1);\n      profile->offset=profile->length+offset;\n      break;\n    }\n  }\n  return(profile->offset);\n}", "target": 0}
{"code": "uipbuf_clear(void)\n{\n  uip_len = 0;\n  uip_ext_len = 0;\n  uip_last_proto = 0;\n  uipbuf_clear_attr();\n}", "target": 0}
{"code": "static void __net_random_once_deferred(struct work_struct *w)\n{\n\tstruct __net_random_once_work *work =\n\t\tcontainer_of(w, struct __net_random_once_work, work);\n\tif (!static_key_enabled(work->key))\n\t\tstatic_key_slow_inc(work->key);\n\tkfree(work);\n}", "target": 1}
{"code": "gdImageScaleTwoPass(const gdImagePtr src, const unsigned int new_width,\n                    const unsigned int new_height)\n{\n    const unsigned int src_width = src->sx;\n    const unsigned int src_height = src->sy;\n\tgdImagePtr tmp_im = NULL;\n\tgdImagePtr dst = NULL;\n    if (src_width == new_width && src_height == new_height) {\n        return gdImageClone(src);\n    }\n\tif (!src->trueColor) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n    if (src_width == new_width) {\n        tmp_im = src;\n    } else {\n        tmp_im = gdImageCreateTrueColor(new_width, src_height);\n        if (tmp_im == NULL) {\n            return NULL;\n        }\n        gdImageSetInterpolationMethod(tmp_im, src->interpolation_id);\n        _gdScalePass(src, src_width, tmp_im, new_width, src_height, HORIZONTAL);\n    }\n    if (src_height == new_height) {\n        assert(tmp_im != src);\n        return tmp_im;\n    }\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (dst != NULL) {\n        gdImageSetInterpolationMethod(dst, src->interpolation_id);\n        _gdScalePass(tmp_im, src_height, dst, new_height, new_width, VERTICAL);\n    }\n    if (src != tmp_im) {\n        gdFree(tmp_im);\n    }\n\treturn dst;\n}", "target": 1}
{"code": "static Sdb *get_gnu_verneed(ELFOBJ *bin) {\n\tut64 verneed_addr;\n\tut64 verneed_num;\n\tif (!Elf_(rz_bin_elf_get_dt_info)(bin, DT_VERNEED, &verneed_addr) || !Elf_(rz_bin_elf_get_dt_info)(bin, DT_VERNEEDNUM, &verneed_num)) {\n\t\treturn NULL;\n\t}\n\tut64 verneed_offset = Elf_(rz_bin_elf_v2p(bin, verneed_addr));\n\tif (verneed_offset == UT64_MAX) {\n\t\tRZ_LOG_WARN(\"Failed to convert verneed virtual address to physical address.\\n\");\n\t\treturn NULL;\n\t}\n\tSdb *sdb = sdb_new0();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\tif (!sdb_num_set(sdb, \"num_entries\", verneed_num, 0) ||\n\t\t!sdb_num_set(sdb, \"addr\", verneed_addr, 0) ||\n\t\t!sdb_num_set(sdb, \"offset\", verneed_offset, 0)) {\n\t\tsdb_free(sdb);\n\t\treturn NULL;\n\t}\n\tfor (size_t i = 0; i < verneed_num; i++) {\n\t\tElf_(Verneed) verneed_entry;\n\t\tif (!get_verneed_entry(bin, verneed_offset, &verneed_entry)) {\n\t\t\tsdb_free(sdb);\n\t\t\treturn NULL;\n\t\t}\n\t\tSdb *sdb_version = get_verneed_entry_sdb(bin, verneed_entry, verneed_offset);\n\t\tif (!sdb_version) {\n\t\t\tsdb_free(sdb);\n\t\t\treturn NULL;\n\t\t}\n\t\tchar key[32];\n\t\tif (!sdb_ns_set(sdb, rz_strf(key, \"version%zu\", i), sdb_version)) {\n\t\t\tsdb_free(sdb_version);\n\t\t\tsdb_free(sdb);\n\t\t\treturn NULL;\n\t\t}\n\t\tsdb_free(sdb_version);\n\t\tif (!verneed_entry.vn_next) {\n\t\t\tbreak;\n\t\t}\n\t\tverneed_offset += verneed_entry.vn_next;\n\t}\n\treturn sdb;\n}", "target": 0}
{"code": "unsigned int add_ch(unsigned char ch, unsigned char* buf, unsigned int idx) {\n    if (idx >= MAX_ALN) {\n        verbprintf(3, \"FLEX: idx %u >= MAX_ALN %u\\n\", idx, MAX_ALN);\n        return 0;\n    }\n    if (ch == 0x09 && idx < (MAX_ALN - 2)) {  \n        buf[idx] = '\\\\';\n        buf[idx + 1] = 't';\n        return 2;\n    }\n    if (ch == 0x0a && idx < (MAX_ALN - 2)) {  \n        buf[idx] = '\\\\';\n        buf[idx + 1] = 'n';\n        return 2;\n    }\n    if (ch == 0x0d && idx < (MAX_ALN - 2)) {  \n        buf[idx] = '\\\\';\n        buf[idx + 1] = 'r';\n        return 2;\n    }\n    if (ch == '%') {\n        if (idx < (MAX_ALN - 2)) {\n            buf[idx] = '%';\n            buf[idx + 1] = '%';\n            return 2;\n        }\n        return 0;\n    }\n    if (ch >= 32 && ch <= 126) {\n        buf[idx] = ch;\n        return 1;\n    }\n    return 0;\n}", "target": 0}
{"code": "Node* Graph::AddNode(NodeDef node_def, Status* status) {\n  const OpRegistrationData* op_reg_data;\n  status->Update(ops_.LookUp(node_def.op(), &op_reg_data));\n  if (!status->ok()) return nullptr;\n  DataTypeVector inputs;\n  DataTypeVector outputs;\n  status->Update(\n      InOutTypesForNode(node_def, op_reg_data->op_def, &inputs, &outputs));\n  if (!status->ok()) {\n    *status = AttachDef(*status, node_def);\n    return nullptr;\n  }\n  Node::NodeClass node_class = op_reg_data->is_function_op\n                                   ? Node::NC_FUNCTION_OP\n                                   : Node::GetNodeClassForOp(node_def.op());\n  if (op_reg_data->type_ctor != nullptr) {\n    VLOG(3) << \"AddNode: found type constructor for \" << node_def.name();\n    const auto ctor_type =\n        full_type::SpecializeType(AttrSlice(node_def), op_reg_data->op_def);\n    if (!ctor_type.ok()) {\n      *status = errors::InvalidArgument(\"type error: \",\n                                        ctor_type.status().ToString());\n      return nullptr;\n    }\n    const FullTypeDef ctor_typedef = ctor_type.ValueOrDie();\n    if (ctor_typedef.type_id() != TFT_UNSET) {\n      *(node_def.mutable_experimental_type()) = ctor_typedef;\n    }\n  } else {\n    VLOG(3) << \"AddNode: no type constructor for \" << node_def.name();\n  }\n  Node* node = AllocateNode(std::make_shared<NodeProperties>(\n                                &op_reg_data->op_def, std::move(node_def),\n                                inputs, outputs, op_reg_data->fwd_type_fn),\n                            nullptr, node_class);\n  return node;\n}", "target": 0}
{"code": "static String cachedStorageDirectory(DWORD pathIdentifier)\n{\n    static HashMap<DWORD, String> directories;\n    HashMap<DWORD, String>::iterator it = directories.find(pathIdentifier);\n    if (it != directories.end())\n        return it->value;\n    String directory = storageDirectory(pathIdentifier);\n    directories.add(pathIdentifier, directory);\n    return directory;\n}", "target": 0}
{"code": "static void sas_eh_finish_cmd(struct scsi_cmnd *cmd)\n{\n\tstruct sas_ha_struct *sas_ha = SHOST_TO_SAS_HA(cmd->device->host);\n\tstruct domain_device *dev = cmd_to_domain_dev(cmd);\n\tstruct sas_task *task = TO_SAS_TASK(cmd);\n\tsas_end_task(cmd, task);\n\tif (dev_is_sata(dev)) {\n\t\tlist_move_tail(&cmd->eh_entry, &sas_ha->eh_ata_q);\n\t\treturn;\n\t}\n\tscsi_eh_finish_cmd(cmd, &sas_ha->eh_done_q);\n}", "target": 0}
{"code": "\tSpawnPreparationInfo prepareSpawn(const Options &options) {\n\t\tTRACE_POINT();\n\t\tSpawnPreparationInfo info;\n\t\tprepareChroot(info, options);\n\t\tinfo.userSwitching = prepareUserSwitching(options);\n\t\tprepareSwitchingWorkingDirectory(info, options);\n\t\tinferApplicationInfo(info);\n\t\treturn info;\n\t}", "target": 1}
{"code": "static long madvise_willneed(struct vm_area_struct *vma,\n\t\t\t     struct vm_area_struct **prev,\n\t\t\t     unsigned long start, unsigned long end)\n{\n\tstruct file *file = vma->vm_file;\n#ifdef CONFIG_SWAP\n\tif (!file) {\n\t\t*prev = vma;\n\t\tforce_swapin_readahead(vma, start, end);\n\t\treturn 0;\n\t}\n\tif (shmem_mapping(file->f_mapping)) {\n\t\t*prev = vma;\n\t\tforce_shm_swapin_readahead(vma, start, end,\n\t\t\t\t\tfile->f_mapping);\n\t\treturn 0;\n\t}\n#else\n\tif (!file)\n\t\treturn -EBADF;\n#endif\n\tif (IS_DAX(file_inode(file))) {\n\t\treturn 0;\n\t}\n\t*prev = vma;\n\tstart = ((start - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\tif (end > vma->vm_end)\n\t\tend = vma->vm_end;\n\tend = ((end - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\tforce_page_cache_readahead(file->f_mapping, file, start, end - start);\n\treturn 0;\n}", "target": 1}
{"code": "static int parse_timecode_in_framenum_format(AVFormatContext *s, AVStream *st,\n                                             int64_t value, int flags)\n{\n    AVTimecode tc;\n    char buf[AV_TIMECODE_STR_SIZE];\n    AVRational rate = st->avg_frame_rate;\n    int ret = av_timecode_init(&tc, rate, flags, 0, s);\n    if (ret < 0)\n        return ret;\n    av_dict_set(&st->metadata, \"timecode\",\n                av_timecode_make_string(&tc, buf, value), 0);\n    return 0;\n}", "target": 0}
{"code": "static int dnxhd_init_vlc(DNXHDContext *ctx, uint32_t cid, int bitdepth)\n{\n    if (cid != ctx->cid) {\n        const CIDEntry *cid_table = ff_dnxhd_get_cid_table(cid);\n        if (!cid_table) {\n            av_log(ctx->avctx, AV_LOG_ERROR, \"unsupported cid %\"PRIu32\"\\n\", cid);\n            return AVERROR(ENOSYS);\n        }\n        if (cid_table->bit_depth != bitdepth &&\n            cid_table->bit_depth != DNXHD_VARIABLE) {\n            av_log(ctx->avctx, AV_LOG_ERROR, \"bit depth mismatches %d %d\\n\",\n                   cid_table->bit_depth, bitdepth);\n            return AVERROR_INVALIDDATA;\n        }\n        ctx->cid_table = cid_table;\n        av_log(ctx->avctx, AV_LOG_VERBOSE, \"Profile cid %\"PRIu32\".\\n\", cid);\n        ff_free_vlc(&ctx->ac_vlc);\n        ff_free_vlc(&ctx->dc_vlc);\n        ff_free_vlc(&ctx->run_vlc);\n        init_vlc(&ctx->ac_vlc, DNXHD_VLC_BITS, 257,\n                 ctx->cid_table->ac_bits, 1, 1,\n                 ctx->cid_table->ac_codes, 2, 2, 0);\n        init_vlc(&ctx->dc_vlc, DNXHD_DC_VLC_BITS, bitdepth > 8 ? 14 : 12,\n                 ctx->cid_table->dc_bits, 1, 1,\n                 ctx->cid_table->dc_codes, 1, 1, 0);\n        init_vlc(&ctx->run_vlc, DNXHD_VLC_BITS, 62,\n                 ctx->cid_table->run_bits, 1, 1,\n                 ctx->cid_table->run_codes, 2, 2, 0);\n        ctx->cid = cid;\n    }\n    return 0;\n}", "target": 1}
{"code": "*/\nPHP_FUNCTION(date_parse)\n{\n\tchar                           *date;\n\tint                             date_len;\n\tstruct timelib_error_container *error;\n\ttimelib_time                   *parsed_time;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &date, &date_len) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tparsed_time = timelib_strtotime(date, date_len, &error, DATE_TIMEZONEDB, php_date_parse_tzfile_wrapper);\n\tphp_date_do_return_parsed_time(INTERNAL_FUNCTION_PARAM_PASSTHRU, parsed_time, error);", "target": 0}
{"code": "Bool rfbOptPamAuth(void)\n{\n  SecTypeData *s;\n  for (s = secTypes; s->name != NULL; s++) {\n    if ((!strcmp(s->name, \"unixlogin\") ||\n         !strcmp(&s->name[strlen(s->name) - 5], \"plain\")) && s->enabled)\n      return TRUE;\n  }\n  return FALSE;\n}", "target": 1}
{"code": "void cql_server::response::write_bytes(bytes b)\n{\n    write_int(cast_if_fits<int32_t>(b.size()));\n    _body.write(b);\n}", "target": 0}
{"code": "static int changedline (const Proto *p, int oldpc, int newpc) {\n  while (oldpc++ < newpc) {\n    if (p->lineinfo[oldpc] != 0)\n      return (luaG_getfuncline(p, oldpc - 1) != luaG_getfuncline(p, newpc));\n  }\n  return 0;  \n}", "target": 1}
{"code": "int hugetlb_reserve_pages(struct inode *inode,\n\t\t\t\t\tlong from, long to,\n\t\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\t\tvm_flags_t vm_flags)\n{\n\tlong ret, chg;\n\tstruct hstate *h = hstate_inode(inode);\n\tstruct hugepage_subpool *spool = subpool_inode(inode);\n\tif (vm_flags & VM_NORESERVE)\n\t\treturn 0;\n\tif (!vma || vma->vm_flags & VM_MAYSHARE)\n\t\tchg = region_chg(&inode->i_mapping->private_list, from, to);\n\telse {\n\t\tstruct resv_map *resv_map = resv_map_alloc();\n\t\tif (!resv_map)\n\t\t\treturn -ENOMEM;\n\t\tchg = to - from;\n\t\tset_vma_resv_map(vma, resv_map);\n\t\tset_vma_resv_flags(vma, HPAGE_RESV_OWNER);\n\t}\n\tif (chg < 0) {\n\t\tret = chg;\n\t\tgoto out_err;\n\t}\n\tif (hugepage_subpool_get_pages(spool, chg)) {\n\t\tret = -ENOSPC;\n\t\tgoto out_err;\n\t}\n\tret = hugetlb_acct_memory(h, chg);\n\tif (ret < 0) {\n\t\thugepage_subpool_put_pages(spool, chg);\n\t\tgoto out_err;\n\t}\n\tif (!vma || vma->vm_flags & VM_MAYSHARE)\n\t\tregion_add(&inode->i_mapping->private_list, from, to);\n\treturn 0;\nout_err:\n\tresv_map_put(vma);\n\treturn ret;\n}", "target": 0}
{"code": "String UTF16BEDecoder::to_utf8(const StringView& input)\n{\n    StringBuilder builder(input.length() / 2);\n    for (size_t i = 0; i < input.length(); i += 2) {\n        u16 code_point = (input[i] << 8) | input[i + 1];\n        builder.append_code_point(code_point);\n    }\n    return builder.to_string();\n}", "target": 1}
{"code": "static apr_status_t parse_chunk_size(http_ctx_t *ctx, const char *buffer,\n        apr_size_t len, int linelimit)\n{\n    apr_size_t i = 0;\n    while (i < len) {\n        char c = buffer[i];\n        ap_xlate_proto_from_ascii(&c, 1);\n        if (ctx->state == BODY_CHUNK_END) {\n            if (c == LF) {\n                ctx->state = BODY_CHUNK;\n            }\n            i++;\n            continue;\n        }\n        if (ctx->state == BODY_CHUNK) {\n            if (!apr_isxdigit(c)) {\n                return APR_EGENERAL;\n            }\n            else {\n                ctx->state = BODY_CHUNK_PART;\n            }\n            ctx->remaining = 0;\n            ctx->chunkbits = sizeof(long) * 8;\n            ctx->chunk_used = 0;\n        }\n        if (c == ';' || c == CR) {\n            ctx->state = BODY_CHUNK_EXT;\n        }\n        else if (c == LF) {\n            if (ctx->remaining) {\n                ctx->state = BODY_CHUNK_DATA;\n            }\n            else {\n                ctx->state = BODY_CHUNK_TRAILER;\n            }\n        }\n        else if (ctx->state != BODY_CHUNK_EXT) {\n            int xvalue = 0;\n            if (!ctx->remaining && c == '0') {\n                i++;\n                continue;\n            }\n            if (c >= '0' && c <= '9') {\n                xvalue = c - '0';\n            }\n            else if (c >= 'A' && c <= 'F') {\n                xvalue = c - 'A' + 0xa;\n            }\n            else if (c >= 'a' && c <= 'f') {\n                xvalue = c - 'a' + 0xa;\n            }\n            else {\n                return APR_EGENERAL;\n            }\n            ctx->remaining = (ctx->remaining << 4) | xvalue;\n            ctx->chunkbits -= 4;\n            if (ctx->chunkbits <= 0 || ctx->remaining < 0) {\n                return APR_ENOSPC;\n            }\n        }\n        i++;\n    }\n    ctx->chunk_used += len;\n    if (ctx->chunk_used < 0 || ctx->chunk_used > linelimit) {\n        return APR_ENOSPC;\n    }\n    return APR_SUCCESS;\n}", "target": 1}
{"code": "const char *osdp_reply_name(int reply_id)\n{\n\tconst char *name;\n\tstatic const char * const names[] = {\n\t\t[REPLY_ACK       - REPLY_ACK] = \"ACK\",\n\t\t[REPLY_NAK       - REPLY_ACK] = \"NAK\",\n\t\t[REPLY_PDID      - REPLY_ACK] = \"PDID\",\n\t\t[REPLY_PDCAP     - REPLY_ACK] = \"PDCAP\",\n\t\t[REPLY_LSTATR    - REPLY_ACK] = \"LSTATR\",\n\t\t[REPLY_ISTATR    - REPLY_ACK] = \"ISTATR\",\n\t\t[REPLY_OSTATR    - REPLY_ACK] = \"OSTATR\",\n\t\t[REPLY_RSTATR    - REPLY_ACK] = \"RSTATR\",\n\t\t[REPLY_RAW       - REPLY_ACK] = \"RAW\",\n\t\t[REPLY_FMT       - REPLY_ACK] = \"FMT\",\n\t\t[REPLY_KEYPPAD   - REPLY_ACK] = \"KEYPPAD\",\n\t\t[REPLY_COM       - REPLY_ACK] = \"COM\",\n\t\t[REPLY_BIOREADR  - REPLY_ACK] = \"BIOREADR\",\n\t\t[REPLY_BIOMATCHR - REPLY_ACK] = \"BIOMATCHR\",\n\t\t[REPLY_CCRYPT    - REPLY_ACK] = \"CCRYPT\",\n\t\t[REPLY_RMAC_I    - REPLY_ACK] = \"RMAC_I\",\n\t\t[REPLY_FTSTAT    - REPLY_ACK] = \"FTSTAT\",\n\t\t[REPLY_MFGREP    - REPLY_ACK] = \"MFGREP\",\n\t\t[REPLY_BUSY      - REPLY_ACK] = \"BUSY\",\n\t\t[REPLY_PIVDATAR  - REPLY_ACK] = \"PIVDATA\",\n\t\t[REPLY_CRAUTHR   - REPLY_ACK] = \"CRAUTH\",\n\t\t[REPLY_MFGSTATR  - REPLY_ACK] = \"MFGSTATR\",\n\t\t[REPLY_MFGERRR   - REPLY_ACK] = \"MFGERR\",\n\t\t[REPLY_XRD       - REPLY_ACK] = \"XRD\",\n\t};\n\tif (reply_id < REPLY_ACK || reply_id > REPLY_XRD) {\n\t\treturn \"INVALID\";\n\t}\n\tname = names[reply_id - REPLY_ACK];\n\tif (name[0] == '\\0') {\n\t\treturn \"UNKNOWN\";\n\t}\n\treturn name;\n}", "target": 1}
{"code": "BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n{\n\tuint8_t *argb;\n\tint x, y;\n\tuint8_t *p;\n\tuint8_t *out;\n\tsize_t out_size;\n\tif (im == NULL) {\n\t\treturn;\n\t}\n\tif (!gdImageTrueColor(im)) {\n\t\tgd_error(\"Paletter image not supported by webp\");\n\t\treturn;\n\t}\n\tif (quality == -1) {\n\t\tquality = 80;\n\t}\n\tif (overflow2(gdImageSX(im), 4)) {\n\t\treturn;\n\t}\n\tif (overflow2(gdImageSX(im) * 4, gdImageSY(im))) {\n\t\treturn;\n\t}\n\targb = (uint8_t *)gdMalloc(gdImageSX(im) * 4 * gdImageSY(im));\n\tif (!argb) {\n\t\treturn;\n\t}\n\tp = argb;\n\tfor (y = 0; y < gdImageSY(im); y++) {\n\t\tfor (x = 0; x < gdImageSX(im); x++) {\n\t\t\tregister int c;\n\t\t\tregister char a;\n\t\t\tc = im->tpixels[y][x];\n\t\t\ta = gdTrueColorGetAlpha(c);\n\t\t\tif (a == 127) {\n\t\t\t\ta = 0;\n\t\t\t} else {\n\t\t\t\ta = 255 - ((a << 1) + (a >> 6));\n\t\t\t}\n\t\t\t*(p++) = gdTrueColorGetRed(c);\n\t\t\t*(p++) = gdTrueColorGetGreen(c);\n\t\t\t*(p++) = gdTrueColorGetBlue(c); \n\t\t\t*(p++) = a;\n\t\t}\n\t}\n\tout_size = WebPEncodeRGBA(argb, gdImageSX(im), gdImageSY(im), gdImageSX(im) * 4, quality, &out);\n\tif (out_size == 0) {\n\t\tgd_error(\"gd-webp encoding failed\");\n\t\tgoto freeargb;\n\t}\n\tgdPutBuf(out, out_size, outfile);\n\tfree(out);\nfreeargb:\n\tgdFree(argb);\n}", "target": 1}
{"code": "static int em_fxrstor(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct fxregs_state fx_state;\n\tint rc;\n\trc = check_fxsr(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = segmented_read(ctxt, ctxt->memop.addr.mem, &fx_state, 512);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tif (fx_state.mxcsr >> 16)\n\t\treturn emulate_gp(ctxt, 0);\n\tctxt->ops->get_fpu(ctxt);\n\tif (ctxt->mode < X86EMUL_MODE_PROT64)\n\t\trc = fxrstor_fixup(ctxt, &fx_state);\n\tif (rc == X86EMUL_CONTINUE)\n\t\trc = asm_safe(\"fxrstor %[fx]\", : [fx] \"m\"(fx_state));\n\tctxt->ops->put_fpu(ctxt);\n\treturn rc;\n}", "target": 1}
{"code": "static int do_cmd (xd3_stream *stream, const char *buf)\n{\n  int ret;\n  if ((ret = system (buf)) != 0)\n    {\n      if (WIFEXITED (ret))\n\t{\n\t  stream->msg = \"command exited non-zero\";\n\t  IF_DEBUG1 (XPR(NT \"command was: %s\\n\", buf));\n\t}\n      else\n\t{\n\t  stream->msg = \"abnormal command termination\";\n\t}\n      return XD3_INTERNAL;\n    }\n  return 0;\n}", "target": 1}
{"code": "std::string Utf16To8(const std::wstring& utf16_string) {\n  return WC2MB(utf16_string, CP_UTF8);\n}", "target": 0}
{"code": "static int __copy_insn(struct address_space *mapping, struct file *filp,\n\t\t\tvoid *insn, int nbytes, loff_t offset)\n{\n\tstruct page *page;\n\tif (mapping->a_ops->readpage)\n\t\tpage = read_mapping_page(mapping, offset >> PAGE_SHIFT, filp);\n\telse\n\t\tpage = shmem_read_mapping_page(mapping, offset >> PAGE_SHIFT);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\tcopy_from_page(page, offset, insn, nbytes);\n\tput_page(page);\n\treturn 0;\n}", "target": 0}
{"code": "static void copy_to_user_policy(struct xfrm_policy *xp, struct xfrm_userpolicy_info *p, int dir)\n{\n\tmemset(p, 0, sizeof(*p));\n\tmemcpy(&p->sel, &xp->selector, sizeof(p->sel));\n\tmemcpy(&p->lft, &xp->lft, sizeof(p->lft));\n\tmemcpy(&p->curlft, &xp->curlft, sizeof(p->curlft));\n\tp->priority = xp->priority;\n\tp->index = xp->index;\n\tp->sel.family = xp->family;\n\tp->dir = dir;\n\tp->action = xp->action;\n\tp->flags = xp->flags;\n\tp->share = XFRM_SHARE_ANY; \n}", "target": 0}
{"code": "pdf_write_names(FILE *out)\t\t\n{\n  int\t\ti;\t\t\t\n  uchar\t\t*s;\t\t\t\n  link_t\t*link;\t\t\t\n  for (i = num_links, link = links; i > 0; i --, link ++)\n    for (s = link->name; *s != '\\0'; s ++)\n      *s = (uchar)tolower(*s);\n  names_object = pdf_start_object(out);\n  fprintf(out, \"/Dests %d 0 R\", (int)num_objects + 1);\n  pdf_end_object(out);\n  pdf_start_object(out);\n  fprintf(out, \"/Kids[%d 0 R]\", (int)num_objects + 1);\n  pdf_end_object(out);\n  pdf_start_object(out);\n  fputs(\"/Limits[\", out);\n  write_string(out, links[0].name, 0);\n  write_string(out, links[num_links - 1].name, 0);\n  fputs(\"]\", out);\n  fputs(\"/Names[\", out);\n  for (i = 1, link = links; i <= (int)num_links; i ++, link ++)\n  {\n    write_string(out, link->name, 0);\n    fprintf(out, \"%d 0 R\", (int)num_objects + i);\n  }\n  fputs(\"]\", out);\n  pdf_end_object(out);\n  for (i = num_links, link = links; i > 0; i --, link ++)\n  {\n    pdf_start_object(out);\n    float x, y;\n    check_pages(link->page);\n    x = 0.0f;\n    y = link->top + pages[link->page].bottom;\n    pspdf_transform_coords(pages + link->page, x, y);\n    fprintf(out, \"/D[%d 0 R/XYZ %.0f %.0f 0]\",\n            pages_object + 2 * pages[link->page].outpage + 1, x, y);\n    pdf_end_object(out);\n  }\n}", "target": 0}
{"code": "int gnutls_x509_ext_export_aia(gnutls_x509_aia_t aia,\n\t\t\t\t\t      gnutls_datum_t * ext)\n{\n\tint ret, result;\n\tASN1_TYPE c2 = ASN1_TYPE_EMPTY;\n\tunsigned int i;\n\tret = asn1_create_element(_gnutls_get_pkix(),\n\t\t\t\t  \"PKIX1.AuthorityInfoAccessSyntax\", &c2);\n\tif (ret != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\treturn _gnutls_asn2err(ret);\n\t}\n\tfor (i=0;i<aia->size;i++) {\n\t\tresult = asn1_write_value(c2, \"\", \"NEW\", 1);\n\t\tif (result != ASN1_SUCCESS) {\n\t\t\tgnutls_assert();\n\t\t\tret = _gnutls_asn2err(result);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tresult = asn1_write_value(c2, \"?LAST.accessMethod\", aia->aia[i].oid.data, 1);\n\t\tif (result != ASN1_SUCCESS) {\n\t\t\tgnutls_assert();\n\t\t\tret = _gnutls_asn2err(result);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tret =\n\t\t    _gnutls_write_general_name(c2,\n\t\t\t\t\t\t   \"?LAST.accessLocation\",\n\t\t\t\t\t\t   aia->aia[i].san_type,\n\t\t\t\t\t\t   aia->aia[i].san.data,\n\t\t\t\t\t\t   aia->aia[i].san.size);\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tret = _gnutls_x509_der_encode(c2, \"\", ext, 0);\n\tif (ret < 0) {\n\t\tgnutls_assert();\n\t\tgoto cleanup;\n\t}\n cleanup:\n\tasn1_delete_structure(&c2);\n\treturn ret;\n}", "target": 0}
{"code": "void my_output_message( j_common_ptr ) {} ", "target": 1}
{"code": "void sock_release(struct socket *sock)\n{\n\tif (sock->ops) {\n\t\tstruct module *owner = sock->ops->owner;\n\t\tsock->ops->release(sock);\n\t\tsock->ops = NULL;\n\t\tmodule_put(owner);\n\t}\n\tif (rcu_dereference_protected(sock->wq, 1)->fasync_list)\n\t\tpr_err(\"%s: fasync list not empty!\\n\", __func__);\n\tif (!sock->file) {\n\t\tiput(SOCK_INODE(sock));\n\t\treturn;\n\t}\n\tsock->file = NULL;\n}", "target": 1}
{"code": "void get_pid_creds(pid_t pid, uid_t *uid, gid_t *gid)\n{\n\tchar line[400];\n\tuid_t u;\n\tgid_t g;\n\tFILE *f;\n\t*uid = -1;\n\t*gid = -1;\n\tsprintf(line, \"/proc/%d/status\", pid);\n\tif ((f = fopen(line, \"r\")) == NULL) {\n\t\tfprintf(stderr, \"Error opening %s: %s\\n\", line, strerror(errno));\n\t\treturn;\n\t}\n\twhile (fgets(line, 400, f)) {\n\t\tif (strncmp(line, \"Uid:\", 4) == 0) {\n\t\t\tif (sscanf(line+4, \"%u\", &u) != 1) {\n\t\t\t\tfprintf(stderr, \"bad uid line for pid %u\\n\", pid);\n\t\t\t\tfclose(f);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t*uid = u;\n\t\t} else if (strncmp(line, \"Gid:\", 4) == 0) {\n\t\t\tif (sscanf(line+4, \"%u\", &g) != 1) {\n\t\t\t\tfprintf(stderr, \"bad gid line for pid %u\\n\", pid);\n\t\t\t\tfclose(f);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t*gid = g;\n\t\t}\n\t}\n\tfclose(f);\n}", "target": 0}
{"code": "njs_promise_resolve(njs_vm_t *vm, njs_value_t *constructor, njs_value_t *x)\n{\n    njs_int_t                 ret;\n    njs_value_t               value;\n    njs_object_t              *object;\n    njs_promise_capability_t  *capability;\n    static const njs_value_t  string_constructor = njs_string(\"constructor\");\n    if (njs_is_object(x)) {\n        object = njs_object_proto_lookup(njs_object(x), NJS_PROMISE,\n                                         njs_object_t);\n        if (object != NULL) {\n            ret = njs_value_property(vm, x, njs_value_arg(&string_constructor),\n                                     &value);\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                return NULL;\n            }\n            if (njs_values_same(&value, constructor)) {\n                return njs_promise(x);\n            }\n        }\n    }\n    capability = njs_promise_new_capability(vm, constructor);\n    if (njs_slow_path(capability == NULL)) {\n        return NULL;\n    }\n    ret = njs_function_call(vm, njs_function(&capability->resolve),\n                            &njs_value_undefined, x, 1, &value);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return NULL;\n    }\n    return njs_promise(&capability->promise);\n}", "target": 1}
{"code": "Status ResourceHandle::BuildResourceHandle(const ResourceHandleProto& proto,\n                                           ResourceHandle* out) {\n  if (out == nullptr)\n    return errors::Internal(\n        \"BuildResourceHandle() was called with nullptr for the output\");\n  return out->FromProto(proto);\n}", "target": 0}
{"code": "static int32_t virtio_net_rsc_sanity_check4(VirtioNetRscChain *chain,\n                                            struct ip_header *ip,\n                                            const uint8_t *buf, size_t size)\n{\n    uint16_t ip_len;\n    if (((ip->ip_ver_len & 0xF0) >> 4) != IP_HEADER_VERSION_4) {\n        chain->stat.ip_option++;\n        return RSC_BYPASS;\n    }\n    if ((ip->ip_ver_len & 0xF) != VIRTIO_NET_IP4_HEADER_LENGTH) {\n        chain->stat.ip_option++;\n        return RSC_BYPASS;\n    }\n    if (ip->ip_p != IPPROTO_TCP) {\n        chain->stat.bypass_not_tcp++;\n        return RSC_BYPASS;\n    }\n    if (!(htons(ip->ip_off) & IP_DF)) {\n        chain->stat.ip_frag++;\n        return RSC_BYPASS;\n    }\n    if (IPTOS_ECN(ip->ip_tos)) {\n        chain->stat.ip_ecn++;\n        return RSC_BYPASS;\n    }\n    ip_len = htons(ip->ip_len);\n    if (ip_len < (sizeof(struct ip_header) + sizeof(struct tcp_header))\n        || ip_len > (size - chain->n->guest_hdr_len -\n                     sizeof(struct eth_header))) {\n        chain->stat.ip_hacked++;\n        return RSC_BYPASS;\n    }\n    return RSC_CANDIDATE;\n}", "target": 0}
{"code": "validate_group(struct perf_event *event)\n{\n\tstruct perf_event *sibling, *leader = event->group_leader;\n\tstruct pmu_hw_events fake_pmu;\n\tDECLARE_BITMAP(fake_used_mask, ARMPMU_MAX_HWEVENTS);\n\tmemset(fake_used_mask, 0, sizeof(fake_used_mask));\n\tfake_pmu.used_mask = fake_used_mask;\n\tif (!validate_event(&fake_pmu, leader))\n\t\treturn -EINVAL;\n\tlist_for_each_entry(sibling, &leader->sibling_list, group_entry) {\n\t\tif (!validate_event(&fake_pmu, sibling))\n\t\t\treturn -EINVAL;\n\t}\n\tif (!validate_event(&fake_pmu, event))\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 1}
{"code": "GF_Box *encs_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGSampleEntryBox, GF_ISOM_BOX_TYPE_ENCS);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\ttmp->internal_type = GF_ISOM_SAMPLE_ENTRY_MP4S;\n\treturn (GF_Box *)tmp;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    OpInputList params_nested_splits_in;\n    OP_REQUIRES_OK(context, context->input_list(\"params_nested_splits\",\n                                                &params_nested_splits_in));\n    const Tensor& params_dense_values_in =\n        context->input(params_nested_splits_in.size());\n    const Tensor& indices_in =\n        context->input(params_nested_splits_in.size() + 1);\n    DCHECK_GT(params_nested_splits_in.size(), 0);  \n    SPLITS_TYPE num_params = params_nested_splits_in[0].dim_size(0) - 1;\n    OP_REQUIRES_OK(context, ValidateIndices(indices_in, num_params));\n    OP_REQUIRES(context, params_dense_values_in.dims() > 0,\n                errors::InvalidArgument(\"params.rank must be nonzero\"));\n    SPLITS_TYPE num_params_dense_values = params_dense_values_in.dim_size(0);\n    std::vector<std::pair<SPLITS_TYPE, SPLITS_TYPE>> value_slices;\n    SPLITS_TYPE num_values = 0;\n    std::vector<std::vector<SPLITS_TYPE>> out_splits;\n    OP_REQUIRES_OK(context, MakeSplits(indices_in, params_nested_splits_in,\n                                       num_params_dense_values, &out_splits,\n                                       &value_slices, &num_values));\n    OP_REQUIRES_OK(context, WriteSplits(out_splits, context));\n    OP_REQUIRES_OK(context,\n                   WriteValues(params_dense_values_in, value_slices,\n                               out_splits.size(), num_values, context));\n  }", "target": 1}
{"code": "void Statement::Work_AfterReset(napi_env e, napi_status status, void* data) {\n    std::unique_ptr<Baton> baton(static_cast<Baton*>(data));\n    Statement* stmt = baton->stmt;\n    Napi::Env env = stmt->Env();\n    Napi::HandleScope scope(env);\n    Napi::Function cb = baton->callback.Value();\n    if (!cb.IsUndefined() && cb.IsFunction()) {\n        Napi::Value argv[] = { env.Null() };\n        TRY_CATCH_CALL(stmt->Value(), cb, 1, argv);\n    }\n    STATEMENT_END();\n}", "target": 0}
{"code": "static void *createArrayObject(const redisReadTask *task, size_t elements) {\n    redisReply *r, *parent;\n    r = createReplyObject(task->type);\n    if (r == NULL)\n        return NULL;\n    if (elements > 0) {\n        if (SIZE_MAX / sizeof(redisReply*) < elements) return NULL;  \n        r->element = hi_calloc(elements,sizeof(redisReply*));\n        if (r->element == NULL) {\n            freeReplyObject(r);\n            return NULL;\n        }\n    }\n    r->elements = elements;\n    if (task->parent) {\n        parent = task->parent->obj;\n        assert(parent->type == REDIS_REPLY_ARRAY ||\n               parent->type == REDIS_REPLY_MAP ||\n               parent->type == REDIS_REPLY_SET ||\n               parent->type == REDIS_REPLY_PUSH);\n        parent->element[task->idx] = r;\n    }\n    return r;\n}", "target": 0}
{"code": "xmlNodePtr SimpleXMLElement_exportNode(const Object& sxe) {\n  assert(sxe->instanceof(SimpleXMLElement_classof()));\n  auto data = Native::data<SimpleXMLElement>(sxe.get());\n  return php_sxe_get_first_node(data, data->nodep());\n}", "target": 1}
{"code": "int VP8LBuildHuffmanTable(HuffmanCode* const root_table, int root_bits,\n                          const int code_lengths[], int code_lengths_size) {\n  int total_size;\n  assert(code_lengths_size <= MAX_CODE_LENGTHS_SIZE);\n  if (root_table == NULL) {\n    total_size = BuildHuffmanTable(NULL, root_bits,\n                                   code_lengths, code_lengths_size, NULL);\n  } else if (code_lengths_size <= SORTED_SIZE_CUTOFF) {\n    uint16_t sorted[SORTED_SIZE_CUTOFF];\n    total_size = BuildHuffmanTable(root_table, root_bits,\n                                   code_lengths, code_lengths_size, sorted);\n  } else {   \n    uint16_t* const sorted =\n        (uint16_t*)WebPSafeMalloc(code_lengths_size, sizeof(*sorted));\n    if (sorted == NULL) return 0;\n    total_size = BuildHuffmanTable(root_table, root_bits,\n                                   code_lengths, code_lengths_size, sorted);\n    WebPSafeFree(sorted);\n  }\n  return total_size;\n}", "target": 1}
{"code": "static unsigned long get_seg_limit(struct pt_regs *regs, int seg_reg_idx)\n{\n\tstruct desc_struct *desc;\n\tunsigned long limit;\n\tshort sel;\n\tsel = get_segment_selector(regs, seg_reg_idx);\n\tif (sel < 0)\n\t\treturn 0;\n\tif (user_64bit_mode(regs) || v8086_mode(regs))\n\t\treturn -1L;\n\tif (!sel)\n\t\treturn 0;\n\tdesc = get_desc(sel);\n\tif (!desc)\n\t\treturn 0;\n\tlimit = get_desc_limit(desc);\n\tif (desc->g)\n\t\tlimit = (limit << 12) + 0xfff;\n\treturn limit;\n}", "target": 1}
{"code": "nfs4_proc_layoutget(struct nfs4_layoutget *lgp, gfp_t gfp_flags)\n{\n\tstruct nfs_server *server = NFS_SERVER(lgp->args.inode);\n\tsize_t max_pages = max_response_pages(server);\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LAYOUTGET],\n\t\t.rpc_argp = &lgp->args,\n\t\t.rpc_resp = &lgp->res,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = server->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_layoutget_call_ops,\n\t\t.callback_data = lgp,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tstruct pnfs_layout_segment *lseg = NULL;\n\tint status = 0;\n\tdprintk(\"--> %s\\n\", __func__);\n\tlgp->args.layout.pages = nfs4_alloc_pages(max_pages, gfp_flags);\n\tif (!lgp->args.layout.pages) {\n\t\tnfs4_layoutget_release(lgp);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tlgp->args.layout.pglen = max_pages * PAGE_SIZE;\n\tlgp->res.layoutp = &lgp->args.layout;\n\tlgp->res.seq_res.sr_slot = NULL;\n\tnfs41_init_sequence(&lgp->args.seq_args, &lgp->res.seq_res, 0);\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn ERR_CAST(task);\n\tstatus = nfs4_wait_for_completion_rpc_task(task);\n\tif (status == 0)\n\t\tstatus = task->tk_status;\n\tif (status == 0)\n\t\tlseg = pnfs_layout_process(lgp);\n\trpc_put_task(task);\n\tdprintk(\"<-- %s status=%d\\n\", __func__, status);\n\tif (status)\n\t\treturn ERR_PTR(status);\n\treturn lseg;\n}", "target": 0}
{"code": "gerb_fclose(gerb_file_t *fd)\n{\n    if (fd) {\n        g_free(fd->filename);\n#ifdef HAVE_SYS_MMAN_H\n\tif (munmap(fd->data, fd->datalen) < 0)\n\t    GERB_FATAL_ERROR(\"munmap: %s\", strerror(errno));\n#else\n\tg_free(fd->data);\n#endif   \n\tif (fclose(fd->fd) == EOF)\n\t    GERB_FATAL_ERROR(\"fclose: %s\", strerror(errno));\n\tg_free(fd);\n    }\n    return;\n} ", "target": 0}
{"code": "get_html_data (MAPI_Attr *a)\n{\n    VarLenData **body = XCALLOC(VarLenData*, a->num_values + 1);\n    int j;\n    for (j = 0; j < a->num_values; j++)\n    {\n\tbody[j] = XMALLOC(VarLenData, 1);\n\tbody[j]->len = a->values[j].len;\n\tbody[j]->data = CHECKED_XCALLOC(unsigned char, a->values[j].len);\n\tmemmove (body[j]->data, a->values[j].data.buf, body[j]->len);\n    }\n    return body;\n}", "target": 1}
{"code": "int backport_getrandom(void *buf, size_t buflen, unsigned int flags)\n{\n\treturn (int)syscall(SYS_getrandom, buf, buflen, flags);\n}", "target": 0}
{"code": "TypedValue HHVM_FUNCTION(array_uintersect,\n                         const Variant& array1,\n                         const Variant& array2,\n                         const Variant& data_compare_func,\n                         const Array& args ) {\n  Variant func = data_compare_func;\n  Array extra = args;\n  if (!extra.empty()) {\n    extra.prepend(func);\n    func = extra.pop();\n  }\n  diff_intersect_body(intersect, extra, false COMMA true COMMA NULL COMMA NULL\n                      COMMA cmp_func COMMA &func);\n}", "target": 0}
{"code": "long kernel_wait4(pid_t upid, int __user *stat_addr, int options,\n\t\t  struct rusage *ru)\n{\n\tstruct wait_opts wo;\n\tstruct pid *pid = NULL;\n\tenum pid_type type;\n\tlong ret;\n\tif (options & ~(WNOHANG|WUNTRACED|WCONTINUED|\n\t\t\t__WNOTHREAD|__WCLONE|__WALL))\n\t\treturn -EINVAL;\n\tif (upid == INT_MIN)\n\t\treturn -ESRCH;\n\tif (upid == -1)\n\t\ttype = PIDTYPE_MAX;\n\telse if (upid < 0) {\n\t\ttype = PIDTYPE_PGID;\n\t\tpid = find_get_pid(-upid);\n\t} else if (upid == 0) {\n\t\ttype = PIDTYPE_PGID;\n\t\tpid = get_task_pid(current, PIDTYPE_PGID);\n\t} else  {\n\t\ttype = PIDTYPE_PID;\n\t\tpid = find_get_pid(upid);\n\t}\n\two.wo_type\t= type;\n\two.wo_pid\t= pid;\n\two.wo_flags\t= options | WEXITED;\n\two.wo_info\t= NULL;\n\two.wo_stat\t= 0;\n\two.wo_rusage\t= ru;\n\tret = do_wait(&wo);\n\tput_pid(pid);\n\tif (ret > 0 && stat_addr && put_user(wo.wo_stat, stat_addr))\n\t\tret = -EFAULT;\n\treturn ret;\n}", "target": 0}
{"code": "static int _kvm_get_dr(struct kvm_vcpu *vcpu, int dr, unsigned long *val)\n{\n\tswitch (dr) {\n\tcase 0 ... 3:\n\t\t*val = vcpu->arch.db[dr];\n\t\tbreak;\n\tcase 4:\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_DE))\n\t\t\treturn 1;\n\tcase 6:\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)\n\t\t\t*val = vcpu->arch.dr6;\n\t\telse\n\t\t\t*val = kvm_x86_ops->get_dr6(vcpu);\n\t\tbreak;\n\tcase 5:\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_DE))\n\t\t\treturn 1;\n\tdefault: \n\t\t*val = vcpu->arch.dr7;\n\t\tbreak;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "txid_snapshot_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tTxidSnapshot *snap;\n\ttxid\t\tlast = 0;\n\tint\t\t\tnxip;\n\tint\t\t\ti;\n\tint\t\t\tavail;\n\tint\t\t\texpect;\n\ttxid\t\txmin,\n\t\t\t\txmax;\n\tnxip = pq_getmsgint(buf, 4);\n\tavail = buf->len - buf->cursor;\n\texpect = 8 + 8 + nxip * 8;\n\tif (nxip < 0 || nxip > avail || expect > avail)\n\t\tgoto bad_format;\n\txmin = pq_getmsgint64(buf);\n\txmax = pq_getmsgint64(buf);\n\tif (xmin == 0 || xmax == 0 || xmin > xmax || xmax > MAX_TXID)\n\t\tgoto bad_format;\n\tsnap = palloc(TXID_SNAPSHOT_SIZE(nxip));\n\tsnap->xmin = xmin;\n\tsnap->xmax = xmax;\n\tsnap->nxip = nxip;\n\tSET_VARSIZE(snap, TXID_SNAPSHOT_SIZE(nxip));\n\tfor (i = 0; i < nxip; i++)\n\t{\n\t\ttxid\t\tcur = pq_getmsgint64(buf);\n\t\tif (cur <= last || cur < xmin || cur >= xmax)\n\t\t\tgoto bad_format;\n\t\tsnap->xip[i] = cur;\n\t\tlast = cur;\n\t}\n\tPG_RETURN_POINTER(snap);\nbad_format:\n\telog(ERROR, \"invalid snapshot data\");\n\treturn (Datum) NULL;\n}", "target": 1}
{"code": "static void *__ns_get_path(struct path *path, struct ns_common *ns)\n{\n\tstruct vfsmount *mnt = nsfs_mnt;\n\tstruct qstr qname = { .name = \"\", };\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tunsigned long d;\n\trcu_read_lock();\n\td = atomic_long_read(&ns->stashed);\n\tif (!d)\n\t\tgoto slow;\n\tdentry = (struct dentry *)d;\n\tif (!lockref_get_not_dead(&dentry->d_lockref))\n\t\tgoto slow;\n\trcu_read_unlock();\n\tns->ops->put(ns);\ngot_it:\n\tpath->mnt = mntget(mnt);\n\tpath->dentry = dentry;\n\treturn NULL;\nslow:\n\trcu_read_unlock();\n\tinode = new_inode_pseudo(mnt->mnt_sb);\n\tif (!inode) {\n\t\tns->ops->put(ns);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tinode->i_ino = ns->inum;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);\n\tinode->i_flags |= S_IMMUTABLE;\n\tinode->i_mode = S_IFREG | S_IRUGO;\n\tinode->i_fop = &ns_file_operations;\n\tinode->i_private = ns;\n\tdentry = d_alloc_pseudo(mnt->mnt_sb, &qname);\n\tif (!dentry) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\td_instantiate(dentry, inode);\n\tdentry->d_flags |= DCACHE_RCUACCESS;\n\tdentry->d_fsdata = (void *)ns->ops;\n\td = atomic_long_cmpxchg(&ns->stashed, 0, (unsigned long)dentry);\n\tif (d) {\n\t\td_delete(dentry);\t\n\t\tdput(dentry);\n\t\tcpu_relax();\n\t\treturn ERR_PTR(-EAGAIN);\n\t}\n\tgoto got_it;\n}", "target": 0}
{"code": "  explicit UnravelIndexOp(OpKernelConstruction* ctx) : OpKernel(ctx) {}", "target": 1}
{"code": "static gpa_t FNAME(gva_to_gpa_nested)(struct kvm_vcpu *vcpu, gva_t vaddr,\n\t\t\t\t      u32 access,\n\t\t\t\t      struct x86_exception *exception)\n{\n\tstruct guest_walker walker;\n\tgpa_t gpa = UNMAPPED_GVA;\n\tint r;\n\tr = FNAME(walk_addr_nested)(&walker, vcpu, vaddr, access);\n\tif (r) {\n\t\tgpa = gfn_to_gpa(walker.gfn);\n\t\tgpa |= vaddr & ~PAGE_MASK;\n\t} else if (exception)\n\t\t*exception = walker.fault;\n\treturn gpa;\n}", "target": 0}
{"code": "int kvm_iommu_map_pages(struct kvm *kvm, struct kvm_memory_slot *slot)\n{\n\tgfn_t gfn, end_gfn;\n\tpfn_t pfn;\n\tint r = 0;\n\tstruct iommu_domain *domain = kvm->arch.iommu_domain;\n\tint flags;\n\tif (!domain)\n\t\treturn 0;\n\tgfn     = slot->base_gfn;\n\tend_gfn = gfn + slot->npages;\n\tflags = IOMMU_READ;\n\tif (!(slot->flags & KVM_MEM_READONLY))\n\t\tflags |= IOMMU_WRITE;\n\tif (!kvm->arch.iommu_noncoherent)\n\t\tflags |= IOMMU_CACHE;\n\twhile (gfn < end_gfn) {\n\t\tunsigned long page_size;\n\t\tif (iommu_iova_to_phys(domain, gfn_to_gpa(gfn))) {\n\t\t\tgfn += 1;\n\t\t\tcontinue;\n\t\t}\n\t\tpage_size = kvm_host_page_size(kvm, gfn);\n\t\twhile ((gfn + (page_size >> PAGE_SHIFT)) > end_gfn)\n\t\t\tpage_size >>= 1;\n\t\twhile ((gfn << PAGE_SHIFT) & (page_size - 1))\n\t\t\tpage_size >>= 1;\n\t\twhile (__gfn_to_hva_memslot(slot, gfn) & (page_size - 1))\n\t\t\tpage_size >>= 1;\n\t\tpfn = kvm_pin_pages(slot, gfn, page_size >> PAGE_SHIFT);\n\t\tif (is_error_noslot_pfn(pfn)) {\n\t\t\tgfn += 1;\n\t\t\tcontinue;\n\t\t}\n\t\tr = iommu_map(domain, gfn_to_gpa(gfn), pfn_to_hpa(pfn),\n\t\t\t      page_size, flags);\n\t\tif (r) {\n\t\t\tprintk(KERN_ERR \"kvm_iommu_map_address:\"\n\t\t\t       \"iommu failed to map pfn=%llx\\n\", pfn);\n\t\t\tkvm_unpin_pages(kvm, pfn, page_size >> PAGE_SHIFT);\n\t\t\tgoto unmap_pages;\n\t\t}\n\t\tgfn += page_size >> PAGE_SHIFT;\n\t}\n\treturn 0;\nunmap_pages:\n\tkvm_iommu_put_pages(kvm, slot->base_gfn, gfn - slot->base_gfn);\n\treturn r;\n}", "target": 0}
{"code": "get_parent_resource(const dav_resource *resource,\n                    dav_resource **parent_resource)\n{\n  dav_resource *parent;\n  dav_resource_private *parentinfo;\n  svn_stringbuf_t *path = resource->info->uri_path;\n  *parent_resource = NULL;\n  if (path->len == 1 && *path->data == '/')\n    return NULL;\n  switch (resource->type)\n    {\n    case DAV_RESOURCE_TYPE_REGULAR:\n      parent = apr_pcalloc(resource->pool, sizeof(*parent));\n      parentinfo  = apr_pcalloc(resource->pool, sizeof(*parentinfo));\n      parent->type = DAV_RESOURCE_TYPE_REGULAR;\n      parent->exists = 1;\n      parent->collection = 1;\n      parent->versioned = 1;\n      parent->hooks = resource->hooks;\n      parent->pool = resource->pool;\n      parent->uri = get_parent_path(svn_urlpath__canonicalize(resource->uri,\n                                                              resource->pool),\n                                    TRUE, resource->pool);\n      parent->info = parentinfo;\n      parentinfo->uri_path =\n        svn_stringbuf_create(get_parent_path(resource->info->uri_path->data,\n                                             TRUE, resource->pool),\n                             resource->pool);\n      parentinfo->repos = resource->info->repos;\n      parentinfo->root = resource->info->root;\n      parentinfo->r = resource->info->r;\n      parentinfo->svn_client_options = resource->info->svn_client_options;\n      parentinfo->repos_path = get_parent_path(resource->info->repos_path,\n                                               FALSE, resource->pool);\n      *parent_resource = parent;\n      break;\n    case DAV_RESOURCE_TYPE_WORKING:\n      *parent_resource =\n        create_private_resource(resource, DAV_SVN_RESTYPE_WRK_COLLECTION);\n      break;\n    case DAV_RESOURCE_TYPE_ACTIVITY:\n      *parent_resource =\n        create_private_resource(resource, DAV_SVN_RESTYPE_ACT_COLLECTION);\n      break;\n    case DAV_RESOURCE_TYPE_PRIVATE:\n      if ((resource->info->restype == DAV_SVN_RESTYPE_TXN_COLLECTION)\n          || (resource->info->restype == DAV_SVN_RESTYPE_REV_COLLECTION))\n        *parent_resource =\n          create_private_resource(resource, resource->info->restype);\n      break;\n    default:\n      break;\n    }\n  if (! *parent_resource)\n    return dav_svn__new_error(resource->pool, HTTP_INTERNAL_SERVER_ERROR, 0,\n                              apr_psprintf(resource->pool,\n                                           \"get_parent_resource was called for \"\n                                           \"%s (type %d)\",\n                                           resource->uri, resource->type));\n  return NULL;\n}", "target": 1}
{"code": "static int er_supported(ERContext *s)\n{\n    if(s->avctx->hwaccel && s->avctx->hwaccel->decode_slice           ||\n       !s->cur_pic.f                                                  ||\n       s->cur_pic.field_picture                                       ||\n       s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO\n    )\n        return 0;\n    return 1;\n}", "target": 1}
{"code": "static int __br_mdb_del(struct net_bridge *br, struct br_mdb_entry *entry)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tstruct br_ip ip;\n\tint err = -EINVAL;\n\tif (!netif_running(br->dev) || br->multicast_disabled)\n\t\treturn -EINVAL;\n\tif (timer_pending(&br->multicast_querier_timer))\n\t\treturn -EBUSY;\n\tip.proto = entry->addr.proto;\n\tif (ip.proto == htons(ETH_P_IP))\n\t\tip.u.ip4 = entry->addr.u.ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\telse\n\t\tip.u.ip6 = entry->addr.u.ip6;\n#endif\n\tspin_lock_bh(&br->multicast_lock);\n\tmdb = mlock_dereference(br->mdb, br);\n\tmp = br_mdb_ip_get(mdb, &ip);\n\tif (!mp)\n\t\tgoto unlock;\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (!p->port || p->port->dev->ifindex != entry->ifindex)\n\t\t\tcontinue;\n\t\tif (p->port->state == BR_STATE_DISABLED)\n\t\t\tgoto unlock;\n\t\trcu_assign_pointer(*pp, p->next);\n\t\thlist_del_init(&p->mglist);\n\t\tdel_timer(&p->timer);\n\t\tcall_rcu_bh(&p->rcu, br_multicast_free_pg);\n\t\terr = 0;\n\t\tif (!mp->ports && !mp->mglist &&\n\t\t    netif_running(br->dev))\n\t\t\tmod_timer(&mp->timer, jiffies);\n\t\tbreak;\n\t}\nunlock:\n\tspin_unlock_bh(&br->multicast_lock);\n\treturn err;\n}", "target": 1}
{"code": "gen8_emit_flush_coherentl3_wa(struct intel_engine_cs *engine, u32 *batch)\n{\n\t*batch++ = MI_STORE_REGISTER_MEM_GEN8 | MI_SRM_LRM_GLOBAL_GTT;\n\t*batch++ = i915_mmio_reg_offset(GEN8_L3SQCREG4);\n\t*batch++ = intel_gt_scratch_offset(engine->gt,\n\t\t\t\t\t   INTEL_GT_SCRATCH_FIELD_COHERENTL3_WA);\n\t*batch++ = 0;\n\t*batch++ = MI_LOAD_REGISTER_IMM(1);\n\t*batch++ = i915_mmio_reg_offset(GEN8_L3SQCREG4);\n\t*batch++ = 0x40400000 | GEN8_LQSC_FLUSH_COHERENT_LINES;\n\tbatch = gen8_emit_pipe_control(batch,\n\t\t\t\t       PIPE_CONTROL_CS_STALL |\n\t\t\t\t       PIPE_CONTROL_DC_FLUSH_ENABLE,\n\t\t\t\t       0);\n\t*batch++ = MI_LOAD_REGISTER_MEM_GEN8 | MI_SRM_LRM_GLOBAL_GTT;\n\t*batch++ = i915_mmio_reg_offset(GEN8_L3SQCREG4);\n\t*batch++ = intel_gt_scratch_offset(engine->gt,\n\t\t\t\t\t   INTEL_GT_SCRATCH_FIELD_COHERENTL3_WA);\n\t*batch++ = 0;\n\treturn batch;\n}", "target": 0}
{"code": "static int find_low_bit(unsigned int x)\n{\n\tint i;\n\tfor(i=0;i<=31;i++) {\n\t\tif(x&(1<<i)) return i;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "size_t TensorSliceWriter::MaxBytesPerElementOrZero(DataType dt) {\n  switch (dt) {\n    case DT_FLOAT:\n      return 4;\n    case DT_DOUBLE:\n      return 8;\n    case DT_INT32:\n      return 10;\n    case DT_UINT8:\n      return 2;\n    case DT_INT16:\n      return 10;\n    case DT_INT8:\n      return 10;\n    case DT_COMPLEX64:\n      return 8;\n    case DT_INT64:\n      return 10;\n    case DT_BOOL:\n      return 1;\n    case DT_QINT8:\n      return 10;\n    case DT_QUINT8:\n      return 2;\n    case DT_QINT32:\n      return 10;\n    case DT_QINT16:\n      return 10;\n    case DT_QUINT16:\n      return 3;\n    case DT_UINT16:\n      return 3;\n    case DT_COMPLEX128:\n      return 16;\n    case DT_HALF:\n      return 3;\n    case DT_INVALID:\n    case DT_STRING:\n    case DT_BFLOAT16:\n    default:\n      return 0;\n  }\n}", "target": 0}
{"code": "TfLiteStatus EvalGatherNd(TfLiteContext* context, const TfLiteTensor* params,\n                          const TfLiteTensor* indices, TfLiteTensor* output) {\n  bool indices_has_only_positive_elements = true;\n  const auto* indices_values = GetTensorData<IndicesT>(indices);\n  const size_t num_indices = indices->bytes / sizeof(IndicesT);\n  for (size_t i = 0; i < num_indices; i++) {\n    if (indices_values[i] < 0) {\n      indices_has_only_positive_elements = false;\n      break;\n    }\n  }\n  TF_LITE_ENSURE(context, indices_has_only_positive_elements);\n  switch (params->type) {\n    case kTfLiteFloat32:\n      return GatherNd<float, IndicesT>(params, indices, output);\n    case kTfLiteUInt8:\n      return GatherNd<uint8_t, IndicesT>(params, indices, output);\n    case kTfLiteInt8:\n      return GatherNd<int8_t, IndicesT>(params, indices, output);\n    case kTfLiteInt16:\n      return GatherNd<int16_t, IndicesT>(params, indices, output);\n    case kTfLiteInt32:\n      return GatherNd<int32_t, IndicesT>(params, indices, output);\n    case kTfLiteInt64:\n      return GatherNd<int64_t, IndicesT>(params, indices, output);\n    case kTfLiteString:\n      return GatherNdString<IndicesT>(params, indices, output);\n    default:\n      context->ReportError(context,\n                           \"Params type '%s' are not supported by gather_nd.\",\n                           TfLiteTypeGetName(params->type));\n      return kTfLiteError;\n  }\n}", "target": 0}
{"code": "void PrivateThreadPoolDatasetOp::MakeDataset(OpKernelContext* ctx,\n                                             DatasetBase* input,\n                                             DatasetBase** output) {\n  int64_t num_threads = 0;\n  OP_REQUIRES_OK(\n      ctx, ParseScalarArgument<int64_t>(ctx, \"num_threads\", &num_threads));\n  OP_REQUIRES(ctx, num_threads >= 0,\n              errors::InvalidArgument(\"`num_threads` must be >= 0\"));\n  *output = new Dataset(ctx, input, num_threads);\n}", "target": 1}
{"code": "static inline bool is_flush_request(struct request *rq,\n\t\tstruct blk_flush_queue *fq, unsigned int tag)\n{\n\treturn ((rq->cmd_flags & REQ_FLUSH_SEQ) &&\n\t\t\tfq->flush_rq->tag == tag);\n}", "target": 1}
{"code": "check_entry_size_and_hooks(struct ip6t_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& image = context->input(0);\n    OP_REQUIRES(context, image.dims() == 3,\n                errors::InvalidArgument(\"image must be 3-dimensional\",\n                                        image.shape().DebugString()));\n    OP_REQUIRES(context, image.NumElements() > 0,\n                errors::Internal(\"Invalid image provided.\"));\n    OP_REQUIRES(\n        context,\n        FastBoundsCheck(image.NumElements(), std::numeric_limits<int32>::max()),\n        errors::InvalidArgument(\"image cannot have >= int32 max elements\"));\n    const int32 height = static_cast<int32>(image.dim_size(0));\n    const int32 width = static_cast<int32>(image.dim_size(1));\n    const int32 channels = static_cast<int32>(image.dim_size(2));\n    const int32 max_row_width = std::numeric_limits<int32>::max() / 2;\n    OP_REQUIRES(context, FastBoundsCheck(width * channels, max_row_width),\n                errors::InvalidArgument(\"image too wide to encode\"));\n    OP_REQUIRES(context, channels >= 1 && channels <= 4,\n                errors::InvalidArgument(\n                    \"image must have 1, 2, 3, or 4 channels, got \", channels));\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, TensorShape({}), &output));\n    if (desired_channel_bits_ == 8) {\n      OP_REQUIRES(context,\n                  png::WriteImageToBuffer(\n                      image.flat<uint8>().data(), width, height,\n                      width * channels, channels, desired_channel_bits_,\n                      compression_, &output->scalar<tstring>()(), nullptr),\n                  errors::Internal(\"PNG encoding failed\"));\n    } else {\n      OP_REQUIRES(context,\n                  png::WriteImageToBuffer(\n                      image.flat<uint16>().data(), width, height,\n                      width * channels * 2, channels, desired_channel_bits_,\n                      compression_, &output->scalar<tstring>()(), nullptr),\n                  errors::Internal(\"PNG encoding failed\"));\n    }\n  }", "target": 0}
{"code": "int BN_bn2binpad(const BIGNUM *a, unsigned char *to, int tolen)\n{\n    if (tolen < 0)\n        return -1;\n    return bn2binpad(a, to, tolen);\n}", "target": 0}
{"code": "bool ConstantFolding::IsSimplifiableReshape(\n    const NodeDef& node, const GraphProperties& properties) const {\n  if (!IsReshape(node)) {\n    return false;\n  }\n  CHECK_LE(2, node.input_size());\n  const NodeDef* new_shape = node_map_->GetNode(node.input(1));\n  if (!IsReallyConstant(*new_shape)) {\n    return false;\n  }\n  TensorVector outputs;\n  auto outputs_cleanup = gtl::MakeCleanup([&outputs] {\n    for (const auto& output : outputs) {\n      delete output.tensor;\n    }\n  });\n  Status s = EvaluateNode(*new_shape, TensorVector(), &outputs);\n  if (!s.ok()) {\n    return false;\n  }\n  CHECK_EQ(1, outputs.size());\n  const std::vector<OpInfo::TensorProperties>& props =\n      properties.GetInputProperties(node.name());\n  if (props.empty()) {\n    return false;\n  }\n  const OpInfo::TensorProperties& prop = props[0];\n  if (prop.dtype() == DT_INVALID) {\n    return false;\n  }\n  const PartialTensorShape shape(prop.shape());\n  if (!shape.IsFullyDefined()) {\n    return false;\n  }\n  PartialTensorShape new_dims;\n  if (outputs[0]->dtype() == DT_INT32) {\n    std::vector<int32> shp;\n    for (int i = 0; i < outputs[0]->NumElements(); ++i) {\n      int32_t dim = outputs[0]->flat<int32>()(i);\n      shp.push_back(dim);\n    }\n    TF_CHECK_OK(TensorShapeUtils::MakeShape(shp, &new_dims));\n  } else {\n    std::vector<int64_t> shp;\n    for (int i = 0; i < outputs[0]->NumElements(); ++i) {\n      int64_t dim = outputs[0]->flat<int64_t>()(i);\n      shp.push_back(dim);\n    }\n    TF_CHECK_OK(TensorShapeUtils::MakeShape(shp, &new_dims));\n  }\n  return shape.IsCompatibleWith(new_dims);\n}", "target": 1}
{"code": "bool setCtbAddrFromTS(thread_context* tctx)\n{\n  const seq_parameter_set& sps = tctx->img->get_sps();\n  if (tctx->CtbAddrInTS < sps.PicSizeInCtbsY) {\n    tctx->CtbAddrInRS = tctx->img->get_pps().CtbAddrTStoRS[tctx->CtbAddrInTS];\n    tctx->CtbX = tctx->CtbAddrInRS % sps.PicWidthInCtbsY;\n    tctx->CtbY = tctx->CtbAddrInRS / sps.PicWidthInCtbsY;\n    return false;\n  }\n  else {\n    tctx->CtbAddrInRS = sps.PicSizeInCtbsY;\n    tctx->CtbX = tctx->CtbAddrInRS % sps.PicWidthInCtbsY;\n    tctx->CtbY = tctx->CtbAddrInRS / sps.PicWidthInCtbsY;\n    return true;\n  }\n}", "target": 0}
{"code": "void oz_hcd_get_desc_cnf(void *hport, u8 req_id, int status, const u8 *desc,\n\t\t\tint length, int offset, int total_size)\n{\n\tstruct oz_port *port = hport;\n\tstruct urb *urb;\n\tint err = 0;\n\toz_dbg(ON, \"oz_hcd_get_desc_cnf length = %d offs = %d tot_size = %d\\n\",\n\t       length, offset, total_size);\n\turb = oz_find_urb_by_id(port, 0, req_id);\n\tif (!urb)\n\t\treturn;\n\tif (status == 0) {\n\t\tint copy_len;\n\t\tint required_size = urb->transfer_buffer_length;\n\t\tif (required_size > total_size)\n\t\t\trequired_size = total_size;\n\t\tcopy_len = required_size-offset;\n\t\tif (length <= copy_len)\n\t\t\tcopy_len = length;\n\t\tmemcpy(urb->transfer_buffer+offset, desc, copy_len);\n\t\toffset += copy_len;\n\t\tif (offset < required_size) {\n\t\t\tstruct usb_ctrlrequest *setup =\n\t\t\t\t(struct usb_ctrlrequest *)urb->setup_packet;\n\t\t\tunsigned wvalue = le16_to_cpu(setup->wValue);\n\t\t\tif (oz_enqueue_ep_urb(port, 0, 0, urb, req_id))\n\t\t\t\terr = -ENOMEM;\n\t\t\telse if (oz_usb_get_desc_req(port->hpd, req_id,\n\t\t\t\t\tsetup->bRequestType, (u8)(wvalue>>8),\n\t\t\t\t\t(u8)wvalue, setup->wIndex, offset,\n\t\t\t\t\trequired_size-offset)) {\n\t\t\t\toz_dequeue_ep_urb(port, 0, 0, urb);\n\t\t\t\terr = -ENOMEM;\n\t\t\t}\n\t\t\tif (err == 0)\n\t\t\t\treturn;\n\t\t}\n\t}\n\turb->actual_length = total_size;\n\toz_complete_urb(port->ozhcd->hcd, urb, 0);\n}", "target": 1}
{"code": "static int update_server_from_aliases(request_rec *r)\n{\n    const char *host = r->hostname;\n    apr_port_t port;\n    server_rec *s;\n    server_rec *virthost_s;\n    server_rec *last_s;\n    name_chain *src;\n    virthost_s = NULL;\n    last_s = NULL;\n    port = r->connection->local_addr->port;\n    for (src = r->connection->vhost_lookup_data; src; src = src->next) {\n        server_addr_rec *sar;\n        sar = src->sar;\n        if (sar->host_port != 0 && port != sar->host_port) {\n            continue;\n        }\n        s = src->server;\n        if (s != last_s) {\n            if (matches_aliases(s, host)) {\n                goto found;\n            }\n        }\n        if (!strcasecmp(host, sar->virthost)) {\n            if (virthost_s == NULL) {\n                virthost_s = s;\n            }\n        }\n        last_s = s;\n    }\n    if (virthost_s) {\n        s = virthost_s;\n        goto found;\n    }\n    if (!r->connection->vhost_lookup_data) { \n        if (matches_aliases(r->server, host)) {\n            s = r->server;\n            goto found;\n        }\n    }\n    return HTTP_BAD_REQUEST;\nfound:\n    r->server = s;\n    return HTTP_OK;\n}", "target": 0}
{"code": "vips_foreign_load_start( VipsImage *out, void *a, void *b )\n{\n\tVipsForeignLoad *load = VIPS_FOREIGN_LOAD( b );\n\tVipsForeignLoadClass *class = VIPS_FOREIGN_LOAD_GET_CLASS( load );\n\tif( !load->real ) {\n\t\tif( !(load->real = vips_foreign_load_temp( load )) )\n\t\t\treturn( NULL );\n#ifdef DEBUG\n\t\tprintf( \"vips_foreign_load_start: triggering ->load()\\n\" );\n#endif \n\t\tload->real->progress_signal = load->out;\n\t\tg_object_set_qdata( G_OBJECT( load->real ), \n\t\t\tvips__foreign_load_operation, load ); \n\t\tif( class->load( load ) ||\n\t\t\tvips_image_pio_input( load->real ) ) \n\t\t\treturn( NULL );\n\t\tif( !vips_foreign_load_iscompat( load->real, out ) )\n\t\t\treturn( NULL );\n\t\tvips_image_pipelinev( load->out, load->out->dhint, \n\t\t\tload->real, NULL );\n\t}\n\treturn( vips_region_new( load->real ) );\n}", "target": 1}
{"code": "CBORTag_hash(CBORTagObject *self)\n{\n    if (!_CBOR2_thread_locals && _CBOR2_init_thread_locals() == -1)\n        return -1;\n    Py_hash_t ret = -1;\n    PyObject *running_hashes = NULL;\n    PyObject *tmp = NULL;\n    PyObject *self_id = PyLong_FromVoidPtr(self);\n    if (!self_id)\n        goto exit;\n    running_hashes = PyObject_GetAttrString(_CBOR2_thread_locals, \"running_hashes\");\n    if (!running_hashes) {\n        PyErr_Clear();\n        running_hashes = PySet_New(NULL);\n        if (PyObject_SetAttrString(_CBOR2_thread_locals, \"running_hashes\", running_hashes) == -1)\n            goto exit;\n    } else {\n        switch (PySet_Contains(running_hashes, self_id)) {\n            case -1:  \n                goto exit;\n            case 1:  \n                PyErr_SetString(\n                    PyExc_RuntimeError,\n                    \"This CBORTag is not hashable because it contains a reference to itself\"\n                );\n                goto exit;\n        }\n    }\n    if (PySet_Add(running_hashes, self_id) == -1)\n        goto exit;\n    tmp = Py_BuildValue(\"(KO)\", self->tag, self->value);\n    if (!tmp)\n        goto exit;\n    ret = PyObject_Hash(tmp);\n    if (ret == -1)\n        goto exit;\n    if (PySet_Discard(running_hashes, self_id) == -1) {\n        ret = -1;\n        goto exit;\n    }\n    Py_ssize_t length = PySequence_Length(running_hashes);\n    if (length == -1) {\n        ret = -1;\n        goto exit;\n    }\n    if (length == 0 && PyObject_DelAttrString(_CBOR2_thread_locals, \"running_hashes\") == -1) {\n        ret = -1;\n        goto exit;\n    }\nexit:\n    Py_CLEAR(self_id);\n    Py_CLEAR(running_hashes);\n    Py_CLEAR(tmp);\n    return ret;\n}", "target": 0}
{"code": "decode_definite_short_bytestring(CBORDecoderObject *self, Py_ssize_t length)\n{\n    PyObject *ret = fp_read_object(self, length);\n    if (!ret)\n        return NULL;\n    if (string_namespace_add(self, ret, length) == -1) {\n        Py_DECREF(ret);\n        return NULL;\n    }\n    return ret;\n}", "target": 0}
{"code": "static char *get_nextpath(char *path, int *offsetp, int fulllen)\n{\n\tint offset = *offsetp;\n\tif (offset >= fulllen)\n\t\treturn NULL;\n\twhile (path[offset] != '\\0' && offset < fulllen)\n\t\toffset++;\n\twhile (path[offset] == '\\0' && offset < fulllen)\n\t\toffset++;\n\t*offsetp = offset;\n\treturn (offset < fulllen) ? &path[offset] : NULL;\n}", "target": 0}
{"code": "static gg_action_t gg_handle_connecting(struct gg_session *sess, struct gg_event *e, enum gg_state_t next_state, enum gg_state_t alt_state, enum gg_state_t alt2_state)\n{\n\tint res;\n\tsess->soft_timeout = 0;\n\tif (gg_async_connect_failed(sess, &res)) {\n\t\tgg_debug_session(sess, GG_DEBUG_MISC, \"\n\t\tclose(sess->fd);\n\t\tsess->fd = -1;\n\t\tsess->resolver_index++;\n\t\tsess->state = alt_state;\n\t} else {\n\t\tif (sess->state != GG_STATE_CONNECTING_PROXY_HUB) {\n\t\t\tfree(sess->resolver_result);\n\t\t\tsess->resolver_result = NULL;\n\t\t}\n\t\tsess->state = next_state;\n\t}\n\treturn GG_ACTION_NEXT;\n}", "target": 0}
{"code": "static int iwch_l2t_send(struct t3cdev *tdev, struct sk_buff *skb, struct l2t_entry *l2e)\n{\n\tint\terror = 0;\n\tstruct cxio_rdev *rdev;\n\trdev = (struct cxio_rdev *)tdev->ulp;\n\tif (cxio_fatal_error(rdev)) {\n\t\tkfree_skb(skb);\n\t\treturn -EIO;\n\t}\n\terror = l2t_send(tdev, skb, l2e);\n\tif (error < 0)\n\t\tkfree_skb(skb);\n\treturn error;\n}", "target": 1}
{"code": "  int Bind(const Node& node, int max_retry) override {\n    receiver_ = zmq_socket(context_, ZMQ_ROUTER);\n    CHECK(receiver_ != NULL)\n        << \"create receiver socket failed: \" << zmq_strerror(errno);\n    int local = GetEnv(\"DMLC_LOCAL\", 0);\n    std::string addr = local ? \"ipc:\n    int port = node.port;\n    unsigned seed = static_cast<unsigned>(time(NULL)+port);\n    for (int i = 0; i < max_retry+1; ++i) {\n      auto address = addr + std::to_string(port);\n      if (zmq_bind(receiver_, address.c_str()) == 0) break;\n      if (i == max_retry) {\n        port = -1;\n      } else {\n        port = 10000 + rand_r(&seed) % 40000;\n      }\n    }\n    return port;\n  }", "target": 1}
{"code": "int key_default_cmp(const struct key *key,\n\t\t    const struct key_match_data *match_data)\n{\n\treturn strcmp(key->description, match_data->raw_data) == 0;\n}", "target": 0}
{"code": "void prefetch_table(const void *tab, size_t len)\n{\n  const volatile byte *vtab = tab;\n  size_t i;\n  for (i = 0; i < len; i += 8 * 32)\n    {\n      (void)vtab[i + 0 * 32];\n      (void)vtab[i + 1 * 32];\n      (void)vtab[i + 2 * 32];\n      (void)vtab[i + 3 * 32];\n      (void)vtab[i + 4 * 32];\n      (void)vtab[i + 5 * 32];\n      (void)vtab[i + 6 * 32];\n      (void)vtab[i + 7 * 32];\n    }\n  (void)vtab[len - 1];\n}", "target": 1}
{"code": "static void vmx_set_constant_host_state(struct vcpu_vmx *vmx)\n{\n\tu32 low32, high32;\n\tunsigned long tmpl;\n\tstruct desc_ptr dt;\n\tvmcs_writel(HOST_CR0, read_cr0() & ~X86_CR0_TS);  \n\tvmcs_writel(HOST_CR4, read_cr4());  \n\tvmcs_writel(HOST_CR3, read_cr3());  \n\tvmcs_write16(HOST_CS_SELECTOR, __KERNEL_CS);  \n#ifdef CONFIG_X86_64\n\tvmcs_write16(HOST_DS_SELECTOR, 0);\n\tvmcs_write16(HOST_ES_SELECTOR, 0);\n#else\n\tvmcs_write16(HOST_DS_SELECTOR, __KERNEL_DS);  \n\tvmcs_write16(HOST_ES_SELECTOR, __KERNEL_DS);  \n#endif\n\tvmcs_write16(HOST_SS_SELECTOR, __KERNEL_DS);  \n\tvmcs_write16(HOST_TR_SELECTOR, GDT_ENTRY_TSS*8);  \n\tnative_store_idt(&dt);\n\tvmcs_writel(HOST_IDTR_BASE, dt.address);   \n\tvmx->host_idt_base = dt.address;\n\tvmcs_writel(HOST_RIP, vmx_return); \n\trdmsr(MSR_IA32_SYSENTER_CS, low32, high32);\n\tvmcs_write32(HOST_IA32_SYSENTER_CS, low32);\n\trdmsrl(MSR_IA32_SYSENTER_EIP, tmpl);\n\tvmcs_writel(HOST_IA32_SYSENTER_EIP, tmpl);   \n\tif (vmcs_config.vmexit_ctrl & VM_EXIT_LOAD_IA32_PAT) {\n\t\trdmsr(MSR_IA32_CR_PAT, low32, high32);\n\t\tvmcs_write64(HOST_IA32_PAT, low32 | ((u64) high32 << 32));\n\t}\n}", "target": 1}
{"code": "CURLcode Curl_close(struct Curl_easy *data)\n{\n  struct Curl_multi *m;\n  if(!data)\n    return CURLE_OK;\n  Curl_expire_clear(data); \n  m = data->multi;\n  if(m)\n    curl_multi_remove_handle(data->multi, data);\n  if(data->multi_easy)\n    curl_multi_cleanup(data->multi_easy);\n  Curl_llist_destroy(&data->state.timeoutlist, NULL);\n  data->magic = 0; \n  if(data->state.rangestringalloc)\n    free(data->state.range);\n  Curl_free_request_state(data);\n  Curl_ssl_close_all(data);\n  Curl_safefree(data->state.first_host);\n  Curl_safefree(data->state.scratch);\n  Curl_ssl_free_certinfo(data);\n  free(data->req.newurl);\n  data->req.newurl = NULL;\n  if(data->change.referer_alloc) {\n    Curl_safefree(data->change.referer);\n    data->change.referer_alloc = FALSE;\n  }\n  data->change.referer = NULL;\n  Curl_up_free(data);\n  Curl_safefree(data->state.buffer);\n  Curl_safefree(data->state.headerbuff);\n  Curl_safefree(data->state.ulbuf);\n  Curl_flush_cookies(data, 1);\n  Curl_digest_cleanup(data);\n  Curl_safefree(data->info.contenttype);\n  Curl_safefree(data->info.wouldredirect);\n  Curl_resolver_cleanup(data->state.resolver);\n  Curl_http2_cleanup_dependencies(data);\n  Curl_convert_close(data);\n  if(data->share) {\n    Curl_share_lock(data, CURL_LOCK_DATA_SHARE, CURL_LOCK_ACCESS_SINGLE);\n    data->share->dirty--;\n    Curl_share_unlock(data, CURL_LOCK_DATA_SHARE);\n  }\n  Curl_wildcard_dtor(&data->wildcard);\n  Curl_freeset(data);\n  free(data);\n  return CURLE_OK;\n}", "target": 1}
{"code": "inline PointerReader ListReader::getPointerElement(ElementCount index) const {\n  return PointerReader(segment, capTable, reinterpret_cast<const WirePointer*>(\n      ptr + upgradeBound<uint64_t>(index) * step / BITS_PER_BYTE), nestingLimit);\n}", "target": 1}
{"code": "choose_filters(struct archive_read *a)\n{\n\tint number_bidders, i, bid, best_bid;\n\tstruct archive_read_filter_bidder *bidder, *best_bidder;\n\tstruct archive_read_filter *filter;\n\tssize_t avail;\n\tint r;\n\tfor (;;) {\n\t\tnumber_bidders = sizeof(a->bidders) / sizeof(a->bidders[0]);\n\t\tbest_bid = 0;\n\t\tbest_bidder = NULL;\n\t\tbidder = a->bidders;\n\t\tfor (i = 0; i < number_bidders; i++, bidder++) {\n\t\t\tif (bidder->bid != NULL) {\n\t\t\t\tbid = (bidder->bid)(bidder, a->filter);\n\t\t\t\tif (bid > best_bid) {\n\t\t\t\t\tbest_bid = bid;\n\t\t\t\t\tbest_bidder = bidder;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (best_bidder == NULL) {\n\t\t\t__archive_read_filter_ahead(a->filter, 1, &avail);\n\t\t\tif (avail < 0) {\n\t\t\t\t__archive_read_close_filters(a);\n\t\t\t\t__archive_read_free_filters(a);\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\ta->archive.compression_name = a->filter->name;\n\t\t\ta->archive.compression_code = a->filter->code;\n\t\t\treturn (ARCHIVE_OK);\n\t\t}\n\t\tfilter\n\t\t    = (struct archive_read_filter *)calloc(1, sizeof(*filter));\n\t\tif (filter == NULL)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tfilter->bidder = best_bidder;\n\t\tfilter->archive = a;\n\t\tfilter->upstream = a->filter;\n\t\ta->filter = filter;\n\t\tr = (best_bidder->init)(a->filter);\n\t\tif (r != ARCHIVE_OK) {\n\t\t\t__archive_read_close_filters(a);\n\t\t\t__archive_read_free_filters(a);\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t}\n}", "target": 1}
{"code": "llvm::Optional<Value> simplifyBroadcast(ShapeComponentAnalysis& analysis,\n                                        ValueRange shapes, Location loc,\n                                        OpBuilder* builder) {\n  SmallVector<ArrayRef<ShapeComponentAnalysis::SymbolicExpr>> shapes_found;\n  size_t maxRank = 0;\n  for (const auto &shape : llvm::enumerate(shapes)) {\n    auto found_shape = analysis.GetValueInfo(shape.value());\n    if (!found_shape) return {};\n    shapes_found.push_back(*found_shape);\n    maxRank = std::max(maxRank, found_shape->size());\n  }\n  if (maxRank == 0) {\n    return Value(builder->create<tensor::FromElementsOp>(\n        loc, shapes[0].getType(), SmallVector<Value>()));\n  }\n  SmallVector<const ShapeComponentAnalysis::SymbolicExpr*> joined_dimensions(\n      maxRank);\n  SmallVector<std::pair<Value, int64_t>> shape_and_rank_for_dim(maxRank);\n  for (const auto &shape : llvm::enumerate(shapes_found)) {\n    for (const auto &dim : llvm::enumerate(llvm::reverse(shape.value()))) {\n      if (dim.value().isConstant(1)) continue;\n      auto index = maxRank - dim.index() - 1;\n      if (!joined_dimensions[index]) {\n        joined_dimensions[index] = &dim.value();\n        shape_and_rank_for_dim[index] =\n            std::make_pair(shapes[shape.index()], shape.value().size());\n        continue;\n      }\n      if (*joined_dimensions[index] != dim.value()) return {};\n    }\n  }\n  if (llvm::is_splat(shape_and_rank_for_dim) &&\n      shape_and_rank_for_dim[0].first) {\n    return shape_and_rank_for_dim[0].first;\n  }\n  SmallVector<Value> elements;\n  for (int i = 0; i != maxRank; ++i) {\n    if (!shape_and_rank_for_dim[i].first) {\n      auto one = builder->getIntegerAttr(\n          shapes[0].getType().cast<RankedTensorType>().getElementType(), 1);\n      elements.push_back(builder->create<ConstantOp>(loc, one));\n      continue;\n    }\n    Value index = builder->create<ConstantIndexOp>(\n        loc, i - maxRank + shape_and_rank_for_dim[i].second);\n    elements.push_back(builder->create<tensor::ExtractOp>(\n        loc, shape_and_rank_for_dim[i].first, index));\n  }\n  return Value(builder->create<tensor::FromElementsOp>(loc, elements));\n}", "target": 0}
{"code": "static void tcp_send_challenge_ack(struct sock *sk, const struct sk_buff *skb)\n{\n\tstatic u32 challenge_timestamp;\n\tstatic unsigned int challenge_count;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 now;\n\tif (tcp_oow_rate_limited(sock_net(sk), skb,\n\t\t\t\t LINUX_MIB_TCPACKSKIPPEDCHALLENGE,\n\t\t\t\t &tp->last_oow_ack_time))\n\t\treturn;\n\tnow = jiffies / HZ;\n\tif (now != challenge_timestamp) {\n\t\tchallenge_timestamp = now;\n\t\tchallenge_count = 0;\n\t}\n\tif (++challenge_count <= sysctl_tcp_challenge_ack_limit) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPCHALLENGEACK);\n\t\ttcp_send_ack(sk);\n\t}\n}", "target": 1}
{"code": "struct pico_socket *pico_tcp_open(struct pico_stack *S, uint16_t family)\n{\n    struct pico_socket_tcp *t = PICO_ZALLOC(sizeof(struct pico_socket_tcp));\n    if (!t)\n        return NULL;\n    t->sock.stack = S;\n    t->sock.timestamp = TCP_TIME;\n    pico_socket_set_family(&t->sock, family);\n    t->mss = (uint16_t)(pico_socket_get_mss(&t->sock) - PICO_SIZE_TCPHDR);\n    t->tcpq_in.pool.root = t->tcpq_hold.pool.root = t->tcpq_out.pool.root = &LEAF;\n    t->tcpq_hold.pool.compare = t->tcpq_out.pool.compare = segment_compare;\n    t->tcpq_in.pool.compare = input_segment_compare;\n    t->tcpq_in.max_size = PICO_DEFAULT_SOCKETQ;\n    t->tcpq_out.max_size = PICO_DEFAULT_SOCKETQ;\n    t->tcpq_hold.max_size = 2u * t->mss;\n    rto_set(t, PICO_TCP_RTO_MIN);\n    t->sock.opt_flags |= (1 << PICO_SOCKET_OPT_TCPNODELAY);\n    t->linger_timeout = PICO_SOCKET_LINGER_TIMEOUT;\n#ifdef PICO_TCP_SUPPORT_SOCKET_STATS\n    if (!pico_timer_add(t->sock.stack, 2000, sock_stats, t)) {\n        tcp_dbg(\"TCP: Failed to start socket statistics timer\\n\");\n        PICO_FREE(t);\n        return NULL;\n    }\n#endif\n    t->keepalive_tmr = pico_timer_add(t->sock.stack, 1000, pico_tcp_keepalive, t);\n    if (!t->keepalive_tmr) {\n        tcp_dbg(\"TCP: Failed to start keepalive timer\\n\");\n        PICO_FREE(t);\n        return NULL;\n    }\n    tcp_set_space(t);\n    return &t->sock;\n}", "target": 1}
{"code": "static bool malidp_check_pages_threshold(struct malidp_plane_state *ms,\n\t\t\t\t\t u32 pgsize)\n{\n\tint i;\n\tfor (i = 0; i < ms->n_planes; i++) {\n\t\tstruct drm_gem_object *obj;\n\t\tstruct drm_gem_cma_object *cma_obj;\n\t\tstruct sg_table *sgt;\n\t\tstruct scatterlist *sgl;\n\t\tobj = drm_gem_fb_get_obj(ms->base.fb, i);\n\t\tcma_obj = to_drm_gem_cma_obj(obj);\n\t\tif (cma_obj->sgt)\n\t\t\tsgt = cma_obj->sgt;\n\t\telse\n\t\t\tsgt = obj->funcs->get_sg_table(obj);\n\t\tif (!sgt)\n\t\t\treturn false;\n\t\tsgl = sgt->sgl;\n\t\twhile (sgl) {\n\t\t\tif (sgl->length < pgsize) {\n\t\t\t\tif (!cma_obj->sgt)\n\t\t\t\t\tkfree(sgt);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tsgl = sg_next(sgl);\n\t\t}\n\t\tif (!cma_obj->sgt)\n\t\t\tkfree(sgt);\n\t}\n\treturn true;\n}", "target": 1}
{"code": "context_parse_args (FlatpakContext *context,\n                    ...)\n{\n  g_autoptr(GError) local_error = NULL;\n  g_autoptr(GOptionContext) oc = NULL;\n  g_autoptr(GOptionGroup) group = NULL;\n  g_autoptr(GPtrArray) args = g_ptr_array_new_with_free_func (g_free);\n  g_auto(GStrv) argv = NULL;\n  const char *arg;\n  va_list ap;\n  g_ptr_array_add (args, g_strdup (\"argv[0]\"));\n  va_start (ap, context);\n  while ((arg = va_arg (ap, const char *)) != NULL)\n    g_ptr_array_add (args, g_strdup (arg));\n  va_end (ap);\n  g_ptr_array_add (args, NULL);\n  argv = (GStrv) g_ptr_array_free (g_steal_pointer (&args), FALSE);\n  oc = g_option_context_new (\"\");\n  group = flatpak_context_get_options (context);\n  g_option_context_add_group (oc, group);\n  g_option_context_parse_strv (oc, &argv, &local_error);\n  g_assert_no_error (local_error);\n}", "target": 1}
{"code": "static __inline__ void scm_set_cred(struct scm_cookie *scm,\n\t\t\t\t    struct pid *pid, const struct cred *cred)\n{\n\tscm->pid  = get_pid(pid);\n\tscm->cred = cred ? get_cred(cred) : NULL;\n\tscm->creds.pid = pid_vnr(pid);\n\tscm->creds.uid = cred ? cred->euid : INVALID_UID;\n\tscm->creds.gid = cred ? cred->egid : INVALID_GID;\n}", "target": 1}
{"code": "static int proc_pid_schedstat(struct task_struct *task, char *buffer)\n{\n\treturn sprintf(buffer, \"%llu %llu %lu\\n\",\n\t\t\ttask->sched_info.cpu_time,\n\t\t\ttask->sched_info.run_delay,\n\t\t\ttask->sched_info.pcount);\n}", "target": 0}
{"code": "void Ppmd8_Construct(CPpmd8 *p)\n{\n  unsigned i, k, m;\n  p->Base = 0;\n  for (i = 0, k = 0; i < PPMD_NUM_INDEXES; i++)\n  {\n    unsigned step = (i >= 12 ? 4 : (i >> 2) + 1);\n    do { p->Units2Indx[k++] = (Byte)i; } while (--step);\n    p->Indx2Units[i] = (Byte)k;\n  }\n  p->NS2BSIndx[0] = (0 << 1);\n  p->NS2BSIndx[1] = (1 << 1);\n  memset(p->NS2BSIndx + 2, (2 << 1), 9);\n  memset(p->NS2BSIndx + 11, (3 << 1), 256 - 11);\n  for (i = 0; i < 5; i++)\n    p->NS2Indx[i] = (Byte)i;\n  for (m = i, k = 1; i < 260; i++)\n  {\n    p->NS2Indx[i] = (Byte)m;\n    if (--k == 0)\n      k = (++m) - 4;\n  }\n}", "target": 0}
{"code": "    UNZIPLoadParseError(const std::string &msg) : std::runtime_error(msg) { };", "target": 0}
{"code": "static ssize_t ocfs2_direct_IO(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tget_block_t *get_block;\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn 0;\n\tif (iocb->ki_pos + iter->count > i_size_read(inode) &&\n\t    !ocfs2_supports_append_dio(osb))\n\t\treturn 0;\n\tif (iov_iter_rw(iter) == READ)\n\t\tget_block = ocfs2_get_block;\n\telse\n\t\tget_block = ocfs2_dio_get_block;\n\treturn __blockdev_direct_IO(iocb, inode, inode->i_sb->s_bdev,\n\t\t\t\t    iter, get_block,\n\t\t\t\t    ocfs2_dio_end_io, NULL, 0);\n}", "target": 1}
{"code": "static void *create_core_server_config(apr_pool_t *a, server_rec *s)\n{\n    core_server_config *conf;\n    int is_virtual = s->is_virtual;\n    conf = (core_server_config *)apr_pcalloc(a, sizeof(core_server_config));\n    if (!is_virtual) {\n        conf->ap_document_root = DOCUMENT_LOCATION;\n        conf->access_name = DEFAULT_ACCESS_FNAME;\n        conf->accf_map = apr_table_make(a, 5);\n#if APR_HAS_SO_ACCEPTFILTER\n        apr_table_setn(conf->accf_map, \"http\", ACCEPT_FILTER_NAME);\n        apr_table_setn(conf->accf_map, \"https\", \"dataready\");\n#elif defined(WIN32)\n        apr_table_setn(conf->accf_map, \"http\", \"connect\");\n        apr_table_setn(conf->accf_map, \"https\", \"connect\");\n#else\n        apr_table_setn(conf->accf_map, \"http\", \"data\");\n        apr_table_setn(conf->accf_map, \"https\", \"data\");\n#endif\n        conf->flush_max_threshold = AP_FLUSH_MAX_THRESHOLD;\n        conf->flush_max_pipelined = AP_FLUSH_MAX_PIPELINED;\n    }\n    else {\n        conf->flush_max_pipelined = -1;\n    }\n    conf->sec_dir = apr_array_make(a, 40, sizeof(ap_conf_vector_t *));\n    conf->sec_url = apr_array_make(a, 40, sizeof(ap_conf_vector_t *));\n    conf->trace_enable = AP_TRACE_UNSET;\n    conf->protocols = apr_array_make(a, 5, sizeof(const char *));\n    conf->protocols_honor_order = -1;\n    conf->merge_slashes = AP_CORE_CONFIG_UNSET; \n    conf->strict_host_check= AP_CORE_CONFIG_UNSET; \n    return (void *)conf;\n}", "target": 0}
{"code": "static int cg_opendir(const char *path, struct fuse_file_info *fi)\n{\n\tstruct fuse_context *fc = fuse_get_context();\n\tconst char *cgroup;\n\tstruct file_info *dir_info;\n\tchar *controller = NULL;\n\tif (!fc)\n\t\treturn -EIO;\n\tif (strcmp(path, \"/cgroup\") == 0) {\n\t\tcgroup = NULL;\n\t\tcontroller = NULL;\n\t} else {\n\t\tcontroller = pick_controller_from_path(fc, path);\n\t\tif (!controller)\n\t\t\treturn -EIO;\n\t\tcgroup = find_cgroup_in_path(path);\n\t\tif (!cgroup) {\n\t\t\tcgroup = \"/\";\n\t\t}\n\t}\n\tif (cgroup && !fc_may_access(fc, controller, cgroup, NULL, O_RDONLY)) {\n\t\treturn -EACCES;\n\t}\n\tdir_info = malloc(sizeof(*dir_info));\n\tif (!dir_info)\n\t\treturn -ENOMEM;\n\tdir_info->controller = must_copy_string(controller);\n\tdir_info->cgroup = must_copy_string(cgroup);\n\tdir_info->type = LXC_TYPE_CGDIR;\n\tdir_info->buf = NULL;\n\tdir_info->file = NULL;\n\tdir_info->buflen = 0;\n\tfi->fh = (unsigned long)dir_info;\n\treturn 0;\n}", "target": 1}
{"code": "        AuthenticationStatus get_auth_status() const\n        {\n            std::lock_guard<std::mutex> g(mtx_);\n            if (auth_.get() != nullptr)\n            {\n                return auth_->auth_status_;\n            }\n            else\n            {\n                return AUTHENTICATION_NOT_AVAILABLE;\n            }\n        }", "target": 0}
{"code": "void device_init()\n{\n    hw_init(LOW_FREQUENCY);\n    if (! tsc_sensor_exists())\n    {\n        _NFC_status = nfc_init();\n    }\n    if (_NFC_status == NFC_IS_ACTIVE)\n    {\n        printf1(TAG_NFC, \"Have NFC\\r\\n\");\n        isLowFreq = 1;\n        IS_BUTTON_PRESSED = is_physical_button_pressed;\n    }\n    else\n    {\n        printf1(TAG_NFC, \"Have NO NFC\\r\\n\");\n        hw_init(HIGH_FREQUENCY);\n        isLowFreq = 0;\n        device_init_button();\n    }\n    usbhid_init();\n    ctaphid_init();\n    ctap_init();\n    device_migrate();\n#if BOOT_TO_DFU\n    flash_option_bytes_init(1);\n#else\n    flash_option_bytes_init(0);\n#endif\n}", "target": 1}
{"code": "void set_module_sig_enforced(void)\n{\n\tsig_enforce = true;\n}", "target": 1}
{"code": "void dns_server_deinit(void)\n{\n\tif (dns_server_pcb != NULL) {\n\t\tudp_remove(dns_server_pcb);\n\t\tdns_server_pcb = NULL;\n\t}\n}", "target": 0}
{"code": "static int init_nss_hash(struct crypto_instance *instance)\n{\n\tPK11SlotInfo*\thash_slot = NULL;\n\tSECItem\t\thash_param;\n\tif (!hash_to_nss[instance->crypto_hash_type]) {\n\t\treturn 0;\n\t}\n\thash_param.type = siBuffer;\n\thash_param.data = 0;\n\thash_param.len = 0;\n\thash_slot = PK11_GetBestSlot(hash_to_nss[instance->crypto_hash_type], NULL);\n\tif (hash_slot == NULL) {\n\t\tlog_printf(instance->log_level_security, \"Unable to find security slot (err %d)\",\n\t\t\t   PR_GetError());\n\t\treturn -1;\n\t}\n\tinstance->nss_sym_key_sign = PK11_ImportSymKey(hash_slot,\n\t\t\t\t\t\t       hash_to_nss[instance->crypto_hash_type],\n\t\t\t\t\t\t       PK11_OriginUnwrap, CKA_SIGN,\n\t\t\t\t\t\t       &hash_param, NULL);\n\tif (instance->nss_sym_key_sign == NULL) {\n\t\tlog_printf(instance->log_level_security, \"Failure to import key into NSS (err %d)\",\n\t\t\t   PR_GetError());\n\t\treturn -1;\n\t}\n\tPK11_FreeSlot(hash_slot);\n\treturn 0;\n}", "target": 1}
{"code": "Status CreateTempFile(Env* env, float value, uint64 size, string* filename) {\n  const string dir = testing::TmpDir();\n  *filename = io::JoinPath(dir, strings::StrCat(\"file_\", value));\n  std::unique_ptr<WritableFile> file;\n  TF_RETURN_IF_ERROR(env->NewWritableFile(*filename, &file));\n  for (uint64 i = 0; i < size; ++i) {\n    StringPiece sp(static_cast<char*>(static_cast<void*>(&value)),\n                   sizeof(value));\n    TF_RETURN_IF_ERROR(file->Append(sp));\n  }\n  TF_RETURN_IF_ERROR(file->Close());\n  return Status::OK();\n}", "target": 1}
{"code": "static Variant HHVM_FUNCTION(simplexml_import_dom,\n  const Object& node,\n  const String& class_name ) {\n  auto domnode = Native::data<DOMNode>(node);\n  xmlNodePtr nodep = domnode->nodep();\n  if (nodep) {\n    if (nodep->doc == nullptr) {\n      raise_warning(\"Imported Node must have associated Document\");\n      return init_null();\n    }\n    if (nodep->type == XML_DOCUMENT_NODE ||\n        nodep->type == XML_HTML_DOCUMENT_NODE) {\n      nodep = xmlDocGetRootElement((xmlDocPtr) nodep);\n    }\n  }\n  if (nodep && nodep->type == XML_ELEMENT_NODE) {\n    auto cls = class_from_name(class_name, \"simplexml_import_dom\");\n    if (!cls) {\n      return init_null();\n    }\n    Object obj = create_object(cls->nameStr(), Array(), false);\n    auto sxe = Native::data<SimpleXMLElement>(obj.get());\n    sxe->node = libxml_register_node(nodep);\n    return obj;\n  } else {\n    raise_warning(\"Invalid Nodetype to import\");\n    return init_null();\n  }\n  return false;\n}", "target": 1}
{"code": "int dns_HTTPS_add_ipv6hint(struct dns_rr_nested *svcparam, unsigned char addr[][DNS_RR_AAAA_LEN], int addr_num)\n{\n\tif (_dns_left_len(&svcparam->context) < 4 + addr_num * DNS_RR_AAAA_LEN) {\n\t\treturn -1;\n\t}\n\tunsigned short value = DNS_HTTPS_T_IPV6HINT;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\tvalue = addr_num * DNS_RR_AAAA_LEN;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\tfor (int i = 0; i < addr_num; i++) {\n\t\tdns_add_rr_nested_memcpy(svcparam, addr[i], DNS_RR_AAAA_LEN);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "sdev_iter_snapshots(struct vnode *dvp, char *name)\n{\n\tsdev_iter_datasets(dvp, ZFS_IOC_SNAPSHOT_LIST_NEXT, name);\n}", "target": 0}
{"code": "static int vt_kdsetmode(struct vc_data *vc, unsigned long mode)\n{\n\tswitch (mode) {\n\tcase KD_GRAPHICS:\n\t\tbreak;\n\tcase KD_TEXT0:\n\tcase KD_TEXT1:\n\t\tmode = KD_TEXT;\n\t\tfallthrough;\n\tcase KD_TEXT:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (vc->vc_mode == mode)\n\t\treturn 0;\n\tvc->vc_mode = mode;\n\tif (vc->vc_num != fg_console)\n\t\treturn 0;\n\tconsole_lock();\n\tif (mode == KD_TEXT)\n\t\tdo_unblank_screen(1);\n\telse\n\t\tdo_blank_screen(1);\n\tconsole_unlock();\n\treturn 0;\n}", "target": 1}
{"code": "de265_error decoder_context::decode_some(bool* did_work)\n{\n  de265_error err = DE265_OK;\n  *did_work = false;\n  if (image_units.empty()) { return DE265_OK; }  \n  if ( ! image_units.empty() ) { \n    image_unit* imgunit = image_units[0];\n    slice_unit* sliceunit = imgunit->get_next_unprocessed_slice_segment();\n    if (sliceunit != NULL) {\n      if (sliceunit->flush_reorder_buffer) {\n        dpb.flush_reorder_buffer();\n      }\n      *did_work = true;\n      err = decode_slice_unit_parallel(imgunit, sliceunit);\n      if (err) {\n        return err;\n      }\n    }\n  }\n  if ( ( image_units.size()>=2 && image_units[0]->all_slice_segments_processed()) ||\n       ( image_units.size()>=1 && image_units[0]->all_slice_segments_processed() &&\n         nal_parser.number_of_NAL_units_pending()==0 &&\n         (nal_parser.is_end_of_stream() || nal_parser.is_end_of_frame()) )) {\n    image_unit* imgunit = image_units[0];\n    *did_work=true;\n    imgunit->img->mark_all_CTB_progress(CTB_PROGRESS_PREFILTER);\n    if (img->decctx->num_worker_threads)\n      run_postprocessing_filters_parallel(imgunit);\n    else\n      run_postprocessing_filters_sequential(imgunit->img);\n    for (int i=0;i<imgunit->suffix_SEIs.size();i++) {\n      const sei_message& sei = imgunit->suffix_SEIs[i];\n      err = process_sei(&sei, imgunit->img);\n      if (err != DE265_OK)\n        break;\n    }\n    push_picture_to_output_queue(imgunit);\n    delete imgunit;\n    pop_front(image_units);\n  }\n  return err;\n}", "target": 0}
{"code": "static void vc_uniscr_insert(struct vc_data *vc, unsigned int nr)\n{\n\tstruct uni_screen *uniscr = get_vc_uniscr(vc);\n\tif (uniscr) {\n\t\tchar32_t *ln = uniscr->lines[vc->vc_y];\n\t\tunsigned int x = vc->vc_x, cols = vc->vc_cols;\n\t\tmemmove(&ln[x + nr], &ln[x], (cols - x - nr) * sizeof(*ln));\n\t\tmemset32(&ln[x], ' ', nr);\n\t}\n}", "target": 0}
{"code": "static pfunc check_literal(struct jv_parser* p) {\n  if (p->tokenpos == 0) return 0;\n  const char* pattern = 0;\n  int plen;\n  jv v;\n  switch (p->tokenbuf[0]) {\n  case 't': pattern = \"true\"; plen = 4; v = jv_true(); break;\n  case 'f': pattern = \"false\"; plen = 5; v = jv_false(); break;\n  case 'n': pattern = \"null\"; plen = 4; v = jv_null(); break;\n  }\n  if (pattern) {\n    if (p->tokenpos != plen) return \"Invalid literal\";\n    for (int i=0; i<plen; i++)\n      if (p->tokenbuf[i] != pattern[i])\n        return \"Invalid literal\";\n    TRY(value(p, v));\n  } else {\n    p->tokenbuf[p->tokenpos] = 0; \n    char* end = 0;\n    double d = jvp_strtod(&p->dtoa, p->tokenbuf, &end);\n    if (end == 0 || *end != 0)\n      return \"Invalid numeric literal\";\n    TRY(value(p, jv_number(d)));\n  }\n  p->tokenpos = 0;\n  return 0;\n}", "target": 1}
{"code": "bool ZlibInStream::decompress(bool wait)\n{\n  if (!underlying)\n    throw Exception(\"ZlibInStream overrun: no underlying stream\");\n  zs->next_out = (U8*)end;\n  zs->avail_out = start + bufSize - end;\n  int n = underlying->check(1, 1, wait);\n  if (n == 0) return false;\n  zs->next_in = (U8*)underlying->getptr();\n  zs->avail_in = underlying->getend() - underlying->getptr();\n  if ((int)zs->avail_in > bytesIn)\n    zs->avail_in = bytesIn;\n  int rc = inflate(zs, Z_SYNC_FLUSH);\n  if (rc != Z_OK) {\n    throw Exception(\"ZlibInStream: inflate failed\");\n  }\n  bytesIn -= zs->next_in - underlying->getptr();\n  end = zs->next_out;\n  underlying->setptr(zs->next_in);\n  return true;\n}", "target": 0}
{"code": "XML_SetCommentHandler(XML_Parser parser, XML_CommentHandler handler) {\n  if (parser != NULL)\n    parser->m_commentHandler = handler;\n}", "target": 0}
{"code": "static void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n{\n\tLIST_HEAD(tmp_list);\n\tstruct mount *p;\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_mount_unlock(mnt);\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tp->mnt.mnt_flags |= MNT_UMOUNT;\n\t\tlist_move(&p->mnt_list, &tmp_list);\n\t}\n\tlist_for_each_entry(p, &tmp_list, mnt_list) {\n\t\tlist_del_init(&p->mnt_child);\n\t}\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_umount(&tmp_list);\n\twhile (!list_empty(&tmp_list)) {\n\t\tbool disconnect;\n\t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n\t\tlist_del_init(&p->mnt_expire);\n\t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n\t\tif (how & UMOUNT_SYNC)\n\t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\t\tdisconnect = disconnect_mount(p, how);\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,\n\t\t\t\t disconnect ? &unmounted : NULL);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tif (!disconnect) {\n\t\t\t\tlist_add_tail(&p->mnt_child, &p->mnt_parent->mnt_mounts);\n\t\t\t} else {\n\t\t\t\tumount_mnt(p);\n\t\t\t}\n\t\t}\n\t\tchange_mnt_propagation(p, MS_PRIVATE);\n\t}\n}", "target": 1}
{"code": "pim_print(netdissect_options *ndo,\n          register const u_char *bp, register u_int len, const u_char *bp2)\n{\n\tregister const u_char *ep;\n\tregister const struct pim *pim = (const struct pim *)bp;\n\tep = (const u_char *)ndo->ndo_snapend;\n\tif (bp >= ep)\n\t\treturn;\n#ifdef notyet\t\t\t\n\tND_TCHECK(pim->pim_rsv);\n#endif\n\tswitch (PIM_VER(pim->pim_typever)) {\n\tcase 2:\n\t\tif (!ndo->ndo_vflag) {\n\t\t\tND_PRINT((ndo, \"PIMv%u, %s, length %u\",\n\t\t\t          PIM_VER(pim->pim_typever),\n\t\t\t          tok2str(pimv2_type_values,\"Unknown Type\",PIM_TYPE(pim->pim_typever)),\n\t\t\t          len));\n\t\t\treturn;\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"PIMv%u, length %u\\n\\t%s\",\n\t\t\t          PIM_VER(pim->pim_typever),\n\t\t\t          len,\n\t\t\t          tok2str(pimv2_type_values,\"Unknown Type\",PIM_TYPE(pim->pim_typever))));\n\t\t\tpimv2_print(ndo, bp, len, bp2);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \"PIMv%u, length %u\",\n\t\t          PIM_VER(pim->pim_typever),\n\t\t          len));\n\t\tbreak;\n\t}\n\treturn;\n}", "target": 1}
{"code": "dequeue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int sleep)\n{\n\tupdate_curr(cfs_rq);\n\tupdate_stats_dequeue(cfs_rq, se);\n\tif (sleep) {\n#ifdef CONFIG_SCHEDSTATS\n\t\tif (entity_is_task(se)) {\n\t\t\tstruct task_struct *tsk = task_of(se);\n\t\t\tif (tsk->state & TASK_INTERRUPTIBLE)\n\t\t\t\tse->sleep_start = rq_of(cfs_rq)->clock;\n\t\t\tif (tsk->state & TASK_UNINTERRUPTIBLE)\n\t\t\t\tse->block_start = rq_of(cfs_rq)->clock;\n\t\t}\n#endif\n\t}\n\tif (se != cfs_rq->curr)\n\t\t__dequeue_entity(cfs_rq, se);\n\taccount_entity_dequeue(cfs_rq, se);\n}", "target": 0}
{"code": "static INLINE UINT16 ntlm_av_pair_get_id(const NTLM_AV_PAIR* pAvPair)\n{\n\tUINT16 AvId;\n\tData_Read_UINT16(&pAvPair->AvId, AvId);\n\treturn AvId;\n}", "target": 1}
{"code": "authDigestNonceLink(digest_nonce_h * nonce)\n{\n    assert(nonce != NULL);\n    ++nonce->references;\n    assert(nonce->references != 0); \n    debugs(29, 9, \"nonce '\" << nonce << \"' now at '\" << nonce->references << \"'.\");\n}", "target": 0}
{"code": "static const char *WorkingDirectory()\n{\n   static char path[kMAXPATHLEN];\n   if (getcwd(path, kMAXPATHLEN)) return path;\n   return 0;\n}", "target": 0}
{"code": "static const char *describe_object(struct fsck_options *o, struct object *obj)\n{\n\tstatic struct strbuf buf = STRBUF_INIT;\n\tchar *name;\n\tstrbuf_reset(&buf);\n\tstrbuf_addstr(&buf, oid_to_hex(&obj->oid));\n\tif (o->object_names && (name = lookup_decoration(o->object_names, obj)))\n\t\tstrbuf_addf(&buf, \" (%s)\", name);\n\treturn buf.buf;\n}", "target": 0}
{"code": "static struct scatterlist *alloc_sgtable(int size)\n{\n\tint alloc_size, nents, i;\n\tstruct page *new_page;\n\tstruct scatterlist *iter;\n\tstruct scatterlist *table;\n\tnents = DIV_ROUND_UP(size, PAGE_SIZE);\n\ttable = kcalloc(nents, sizeof(*table), GFP_KERNEL);\n\tif (!table)\n\t\treturn NULL;\n\tsg_init_table(table, nents);\n\titer = table;\n\tfor_each_sg(table, iter, sg_nents(table), i) {\n\t\tnew_page = alloc_page(GFP_KERNEL);\n\t\tif (!new_page) {\n\t\t\titer = table;\n\t\t\tfor_each_sg(table, iter, sg_nents(table), i) {\n\t\t\t\tnew_page = sg_page(iter);\n\t\t\t\tif (new_page)\n\t\t\t\t\t__free_page(new_page);\n\t\t\t}\n\t\t\tkfree(table);\n\t\t\treturn NULL;\n\t\t}\n\t\talloc_size = min_t(int, size, PAGE_SIZE);\n\t\tsize -= PAGE_SIZE;\n\t\tsg_set_page(iter, new_page, alloc_size, 0);\n\t}\n\treturn table;\n}", "target": 0}
{"code": "gvdb_table_write_contents_async (GHashTable          *table,\n                                 const gchar         *filename,\n                                 gboolean             byteswap,\n                                 GCancellable        *cancellable,\n                                 GAsyncReadyCallback  callback,\n                                 gpointer             user_data)\n{\n  struct gvdb_pointer root;\n  FileBuilder *fb;\n  WriteContentsData *data;\n  GString *str;\n  GBytes *bytes;\n  GFile *file;\n  GTask *task;\n  g_return_if_fail (table != NULL);\n  g_return_if_fail (filename != NULL);\n  g_return_if_fail (cancellable == NULL || G_IS_CANCELLABLE (cancellable));\n  fb = file_builder_new (byteswap);\n  file_builder_add_hash (fb, table, &root);\n  str = file_builder_serialise (fb, root);\n  bytes = g_string_free_to_bytes (str);\n  file_builder_free (fb);\n  file = g_file_new_for_path (filename);\n  data = write_contents_data_new (bytes, file);\n  task = g_task_new (NULL, cancellable, callback, user_data);\n  g_task_set_task_data (task, data, (GDestroyNotify)write_contents_data_free);\n  g_task_set_source_tag (task, gvdb_table_write_contents_async);\n  g_file_replace_contents_async (file, str->str, str->len,\n                                 NULL, FALSE,\n                                 G_FILE_CREATE_PRIVATE | G_FILE_CREATE_REPLACE_DESTINATION,\n                                 cancellable, replace_contents_cb, g_steal_pointer (&task));\n  g_bytes_unref (bytes);\n  g_object_unref (file);\n}", "target": 1}
{"code": "void warn_on_nonidempotent_op(struct nfsd4_op *op)\n{\n\tif (OPDESC(op)->op_flags & OP_MODIFIES_SOMETHING) {\n\t\tpr_err(\"unable to encode reply to nonidempotent op %d (%s)\\n\",\n\t\t\top->opnum, nfsd4_op_name(op->opnum));\n\t\tWARN_ON_ONCE(1);\n\t}\n}", "target": 0}
{"code": "rfc2253_name(X509_NAME *name, char **str_out)\n{\n    BIO *b = NULL;\n    char *str;\n    *str_out = NULL;\n    b = BIO_new(BIO_s_mem());\n    if (b == NULL)\n        return ENOMEM;\n    if (X509_NAME_print_ex(b, name, 0, XN_FLAG_SEP_COMMA_PLUS) < 0)\n        goto error;\n    str = calloc(BIO_number_written(b) + 1, 1);\n    if (str == NULL)\n        goto error;\n    BIO_read(b, str, BIO_number_written(b));\n    BIO_free(b);\n    *str_out = str;\n    return 0;\nerror:\n    BIO_free(b);\n    return ENOMEM;\n}", "target": 0}
{"code": "infra_delete(struct infra_cache* infra)\n{\n\tif(!infra)\n\t\treturn;\n\tslabhash_delete(infra->hosts);\n\tslabhash_delete(infra->domain_rates);\n\ttraverse_postorder(&infra->domain_limits, domain_limit_free, NULL);\n\tslabhash_delete(infra->client_ip_rates);\n\ttraverse_postorder(&infra->wait_limits_netblock,\n\t\twait_limit_netblock_del, NULL);\n\ttraverse_postorder(&infra->wait_limits_cookie_netblock,\n\t\twait_limit_netblock_del, NULL);\n\tfree(infra);\n}", "target": 0}
{"code": "prepenv(const struct rule *rule)\n{\n\tstatic const char *safeset[] = {\n\t\t\"DISPLAY\", \"HOME\", \"LOGNAME\", \"MAIL\",\n\t\t\"PATH\", \"TERM\", \"USER\", \"USERNAME\",\n\t\tNULL\n\t};\n\tstruct env *env;\n\tenv = createenv(rule);\n\tif (!(rule->options & KEEPENV))\n\t\tfillenv(env, safeset);\n\tif (rule->envlist)\n\t\tfillenv(env, rule->envlist);\n\treturn flattenenv(env);\n}", "target": 1}
{"code": "static inline __u32 secure_dccpv6_sequence_number(__be32 *saddr, __be32 *daddr,\n\t\t\t\t\t\t  __be16 sport, __be16 dport   )\n{\n\treturn secure_tcpv6_sequence_number(saddr, daddr, sport, dport);\n}", "target": 1}
{"code": "void ida_free(struct ida *ida, unsigned int id)\n{\n\tXA_STATE(xas, &ida->xa, id / IDA_BITMAP_BITS);\n\tunsigned bit = id % IDA_BITMAP_BITS;\n\tstruct ida_bitmap *bitmap;\n\tunsigned long flags;\n\tif ((int)id < 0)\n\t\treturn;\n\txas_lock_irqsave(&xas, flags);\n\tbitmap = xas_load(&xas);\n\tif (xa_is_value(bitmap)) {\n\t\tunsigned long v = xa_to_value(bitmap);\n\t\tif (bit >= BITS_PER_XA_VALUE)\n\t\t\tgoto err;\n\t\tif (!(v & (1UL << bit)))\n\t\t\tgoto err;\n\t\tv &= ~(1UL << bit);\n\t\tif (!v)\n\t\t\tgoto delete;\n\t\txas_store(&xas, xa_mk_value(v));\n\t} else {\n\t\tif (!test_bit(bit, bitmap->bitmap))\n\t\t\tgoto err;\n\t\t__clear_bit(bit, bitmap->bitmap);\n\t\txas_set_mark(&xas, XA_FREE_MARK);\n\t\tif (bitmap_empty(bitmap->bitmap, IDA_BITMAP_BITS)) {\n\t\t\tkfree(bitmap);\ndelete:\n\t\t\txas_store(&xas, NULL);\n\t\t}\n\t}\n\txas_unlock_irqrestore(&xas, flags);\n\treturn;\n err:\n\txas_unlock_irqrestore(&xas, flags);\n\tWARN(1, \"ida_free called for id=%d which is not allocated.\\n\", id);\n}", "target": 1}
{"code": "static void edge_bulk_in_callback(struct urb *urb)\n{\n\tstruct edgeport_port *edge_port = urb->context;\n\tstruct device *dev = &edge_port->port->dev;\n\tunsigned char *data = urb->transfer_buffer;\n\tint retval = 0;\n\tint port_number;\n\tint status = urb->status;\n\tswitch (status) {\n\tcase 0:\n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\tdev_dbg(&urb->dev->dev, \"%s - urb shutting down with status: %d\\n\", __func__, status);\n\t\treturn;\n\tdefault:\n\t\tdev_err(&urb->dev->dev, \"%s - nonzero read bulk status received: %d\\n\", __func__, status);\n\t}\n\tif (status == -EPIPE)\n\t\tgoto exit;\n\tif (status) {\n\t\tdev_err(&urb->dev->dev, \"%s - stopping read!\\n\", __func__);\n\t\treturn;\n\t}\n\tport_number = edge_port->port->port_number;\n\tif (edge_port->lsr_event) {\n\t\tedge_port->lsr_event = 0;\n\t\tdev_dbg(dev, \"%s ===== Port %u LSR Status = %02x, Data = %02x ======\\n\",\n\t\t\t__func__, port_number, edge_port->lsr_mask, *data);\n\t\thandle_new_lsr(edge_port, 1, edge_port->lsr_mask, *data);\n\t\t--urb->actual_length;\n\t\t++data;\n\t}\n\tif (urb->actual_length) {\n\t\tusb_serial_debug_data(dev, __func__, urb->actual_length, data);\n\t\tif (edge_port->close_pending)\n\t\t\tdev_dbg(dev, \"%s - close pending, dropping data on the floor\\n\",\n\t\t\t\t\t\t\t\t__func__);\n\t\telse\n\t\t\tedge_tty_recv(edge_port->port, data,\n\t\t\t\t\turb->actual_length);\n\t\tedge_port->port->icount.rx += urb->actual_length;\n\t}\nexit:\n\tspin_lock(&edge_port->ep_lock);\n\tif (edge_port->ep_read_urb_state == EDGE_READ_URB_RUNNING)\n\t\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\telse if (edge_port->ep_read_urb_state == EDGE_READ_URB_STOPPING)\n\t\tedge_port->ep_read_urb_state = EDGE_READ_URB_STOPPED;\n\tspin_unlock(&edge_port->ep_lock);\n\tif (retval)\n\t\tdev_err(dev, \"%s - usb_submit_urb failed with result %d\\n\", __func__, retval);\n}", "target": 1}
{"code": "struct mnt_namespace *copy_mnt_ns(unsigned long flags, struct mnt_namespace *ns,\n\t\tstruct user_namespace *user_ns, struct fs_struct *new_fs)\n{\n\tstruct mnt_namespace *new_ns;\n\tstruct vfsmount *rootmnt = NULL, *pwdmnt = NULL;\n\tstruct mount *p, *q;\n\tstruct mount *old;\n\tstruct mount *new;\n\tint copy_flags;\n\tBUG_ON(!ns);\n\tif (likely(!(flags & CLONE_NEWNS))) {\n\t\tget_mnt_ns(ns);\n\t\treturn ns;\n\t}\n\told = ns->root;\n\tnew_ns = alloc_mnt_ns(user_ns);\n\tif (IS_ERR(new_ns))\n\t\treturn new_ns;\n\tnamespace_lock();\n\tcopy_flags = CL_COPY_UNBINDABLE | CL_EXPIRE;\n\tif (user_ns != ns->user_ns)\n\t\tcopy_flags |= CL_SHARED_TO_SLAVE | CL_UNPRIVILEGED;\n\tnew = copy_tree(old, old->mnt.mnt_root, copy_flags);\n\tif (IS_ERR(new)) {\n\t\tnamespace_unlock();\n\t\tfree_mnt_ns(new_ns);\n\t\treturn ERR_CAST(new);\n\t}\n\tnew_ns->root = new;\n\tlist_add_tail(&new_ns->list, &new->mnt_list);\n\tp = old;\n\tq = new;\n\twhile (p) {\n\t\tq->mnt_ns = new_ns;\n\t\tnew_ns->mounts++;\n\t\tif (new_fs) {\n\t\t\tif (&p->mnt == new_fs->root.mnt) {\n\t\t\t\tnew_fs->root.mnt = mntget(&q->mnt);\n\t\t\t\trootmnt = &p->mnt;\n\t\t\t}\n\t\t\tif (&p->mnt == new_fs->pwd.mnt) {\n\t\t\t\tnew_fs->pwd.mnt = mntget(&q->mnt);\n\t\t\t\tpwdmnt = &p->mnt;\n\t\t\t}\n\t\t}\n\t\tp = next_mnt(p, old);\n\t\tq = next_mnt(q, new);\n\t\tif (!q)\n\t\t\tbreak;\n\t\twhile (p->mnt.mnt_root != q->mnt.mnt_root)\n\t\t\tp = next_mnt(p, old);\n\t}\n\tnamespace_unlock();\n\tif (rootmnt)\n\t\tmntput(rootmnt);\n\tif (pwdmnt)\n\t\tmntput(pwdmnt);\n\treturn new_ns;\n}", "target": 0}
{"code": "GF_Err Q_DecCoordOnUnitSphere(GF_BifsDecoder *codec, GF_BitStream *bs, u32 NbBits, u32 NbComp, Fixed *m_ft)\n{\n\tu32 i, orient, sign;\n\ts32 value;\n\tFixed tang[4], delta;\n\ts32 dir;\n\tif (NbComp != 2 && NbComp != 3) return GF_BAD_PARAM;\n\tdir = 1;\n\tif(NbComp == 2) dir -= 2 * gf_bs_read_int(bs, 1);\n\torient = gf_bs_read_int(bs, 2);\n\tif ((orient==3) && (NbComp==2)) return GF_NON_COMPLIANT_BITSTREAM;\n\tfor(i=0; i<NbComp; i++) {\n\t\tvalue = gf_bs_read_int(bs, NbBits) - (1 << (NbBits-1) );\n\t\tsign = (value >= 0) ? 1 : -1;\n\t\tm_ft[i] = sign * Q_InverseQuantize(0, 1, NbBits-1, sign*value);\n\t}\n\tdelta = 1;\n\tfor (i=0; i<NbComp; i++) {\n\t\ttang[i] = gf_tan(gf_mulfix(GF_PI/4, m_ft[i]) );\n\t\tdelta += gf_mulfix(tang[i], tang[i]);\n\t}\n\tdelta = gf_divfix(INT2FIX(dir), gf_sqrt(delta) );\n\tm_ft[orient] = delta;\n\tfor (i=0; i<NbComp; i++) {\n\t\tm_ft[ (orient + i+1) % (NbComp+1) ] = gf_mulfix(tang[i], delta);\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "crm_remote_tcp_connect(const char *host, int port)\n{\n    struct addrinfo *res;\n    struct addrinfo *rp;\n    struct addrinfo hints;\n    const char *server = host;\n    int ret_ga;\n    int sock;\n    memset(&hints, 0, sizeof(struct addrinfo));\n    hints.ai_family = AF_UNSPEC;    \n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_flags = AI_CANONNAME;\n    crm_debug(\"Looking up %s\", server);\n    ret_ga = getaddrinfo(server, NULL, &hints, &res);\n    if (ret_ga) {\n        crm_err(\"getaddrinfo: %s\", gai_strerror(ret_ga));\n        return -1;\n    }\n    if (!res || !res->ai_addr) {\n        crm_err(\"getaddrinfo failed\");\n        return -1;\n    }\n    for (rp = res; rp != NULL; rp = rp->ai_next) {\n        struct sockaddr *addr = rp->ai_addr;\n        int flag = 0;\n        if (!addr) {\n            continue;\n        }\n        if (rp->ai_canonname) {\n            server = res->ai_canonname;\n        }\n        crm_debug(\"Got address %s for %s\", server, host);\n        sock = socket(rp->ai_family, SOCK_STREAM, IPPROTO_TCP);\n        if (sock == -1) {\n            crm_err(\"Socket creation failed for remote client connection.\");\n            continue;\n        }\n        if (addr->sa_family == AF_INET6) {\n            struct sockaddr_in6 *addr_in = (struct sockaddr_in6 *) addr;\n            addr_in->sin6_port = htons(port);\n        } else {\n            struct sockaddr_in *addr_in = (struct sockaddr_in *) addr;\n            addr_in->sin_port = htons(port);\n            crm_info(\"Attempting to connect to remote server at %s:%d\", inet_ntoa(addr_in->sin_addr), port);\n        }\n        if (connect(sock, rp->ai_addr, rp->ai_addrlen) == 0) {\n            if ((flag = fcntl(sock, F_GETFL)) >= 0) {\n                if (fcntl(sock, F_SETFL, flag | O_NONBLOCK) < 0) {\n                    crm_err( \"fcntl() write failed\");\n                    close(sock);\n                    sock = -1;\n                    continue;\n                }\n            }\n            break;                  \n        }\n        close(sock);\n        sock = -1;\n    }\n    freeaddrinfo(res);\n    return sock;\n}", "target": 0}
{"code": "findoprnd(ITEM *ptr, int32 *pos)\n{\n\tcheck_stack_depth();\n#ifdef BS_DEBUG\n\telog(DEBUG3, (ptr[*pos].type == OPR) ?\n\t\t \"%d  %c\" : \"%d  %d\", *pos, ptr[*pos].val);\n#endif\n\tif (ptr[*pos].type == VAL)\n\t{\n\t\tptr[*pos].left = 0;\n\t\t(*pos)--;\n\t}\n\telse if (ptr[*pos].val == (int32) '!')\n\t{\n\t\tptr[*pos].left = -1;\n\t\t(*pos)--;\n\t\tfindoprnd(ptr, pos);\n\t}\n\telse\n\t{\n\t\tITEM\t   *curitem = &ptr[*pos];\n\t\tint32\t\ttmp = *pos;\n\t\t(*pos)--;\n\t\tfindoprnd(ptr, pos);\n\t\tcuritem->left = *pos - tmp;\n\t\tfindoprnd(ptr, pos);\n\t}\n}", "target": 0}
{"code": "int install_thread_keyring_to_cred(struct cred *new)\n{\n\tstruct key *keyring;\n\tif (new->thread_keyring)\n\t\treturn 0;\n\tkeyring = keyring_alloc(\"_tid\", new->uid, new->gid, new,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN,\n\t\t\t\tNULL, NULL);\n\tif (IS_ERR(keyring))\n\t\treturn PTR_ERR(keyring);\n\tnew->thread_keyring = keyring;\n\treturn 0;\n}", "target": 0}
{"code": "static void ext4_clamp_want_extra_isize(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE &&\n\t    sbi->s_want_extra_isize == 0) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (ext4_has_feature_extra_isize(sb)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\text4_msg(sb, KERN_INFO,\n\t\t\t \"required extra inode space not available\");\n\t}\n}", "target": 1}
{"code": "parse_tsquery(char *buf,\n\t\t\t  PushFunction pushval,\n\t\t\t  Datum opaque,\n\t\t\t  bool isplain)\n{\n\tstruct TSQueryParserStateData state;\n\tint\t\t\ti;\n\tTSQuery\t\tquery;\n\tint\t\t\tcommonlen;\n\tQueryItem  *ptr;\n\tListCell   *cell;\n\tstate.buffer = buf;\n\tstate.buf = buf;\n\tstate.state = (isplain) ? WAITSINGLEOPERAND : WAITFIRSTOPERAND;\n\tstate.count = 0;\n\tstate.polstr = NIL;\n\tstate.valstate = init_tsvector_parser(state.buffer, true, true);\n\tstate.sumlen = 0;\n\tstate.lenop = 64;\n\tstate.curop = state.op = (char *) palloc(state.lenop);\n\t*(state.curop) = '\\0';\n\tmakepol(&state, pushval, opaque);\n\tclose_tsvector_parser(state.valstate);\n\tif (list_length(state.polstr) == 0)\n\t{\n\t\tereport(NOTICE,\n\t\t\t\t(errmsg(\"text-search query doesn't contain lexemes: \\\"%s\\\"\",\n\t\t\t\t\t\tstate.buffer)));\n\t\tquery = (TSQuery) palloc(HDRSIZETQ);\n\t\tSET_VARSIZE(query, HDRSIZETQ);\n\t\tquery->size = 0;\n\t\treturn query;\n\t}\n\tcommonlen = COMPUTESIZE(list_length(state.polstr), state.sumlen);\n\tquery = (TSQuery) palloc0(commonlen);\n\tSET_VARSIZE(query, commonlen);\n\tquery->size = list_length(state.polstr);\n\tptr = GETQUERY(query);\n\ti = 0;\n\tforeach(cell, state.polstr)\n\t{\n\t\tQueryItem  *item = (QueryItem *) lfirst(cell);\n\t\tswitch (item->type)\n\t\t{\n\t\t\tcase QI_VAL:\n\t\t\t\tmemcpy(&ptr[i], item, sizeof(QueryOperand));\n\t\t\t\tbreak;\n\t\t\tcase QI_VALSTOP:\n\t\t\t\tptr[i].type = QI_VALSTOP;\n\t\t\t\tbreak;\n\t\t\tcase QI_OPR:\n\t\t\t\tmemcpy(&ptr[i], item, sizeof(QueryOperator));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized QueryItem type: %d\", item->type);\n\t\t}\n\t\ti++;\n\t}\n\tmemcpy((void *) GETOPERAND(query), (void *) state.op, state.sumlen);\n\tpfree(state.op);\n\tfindoprnd(ptr, query->size);\n\treturn query;\n}", "target": 1}
{"code": "pci_emul_mem_handler(struct vmctx *ctx, int vcpu, int dir, uint64_t addr,\n\t\t     int size, uint64_t *val, void *arg1, long arg2)\n{\n\tstruct pci_vdev *pdi = arg1;\n\tstruct pci_vdev_ops *ops = pdi->dev_ops;\n\tuint64_t offset;\n\tint bidx = (int) arg2;\n\tif (addr + size > pdi->bar[bidx].addr + pdi->bar[bidx].size) {\n\t\tprintf(\"%s, Out of emulated memory range.\\n\", __func__);\n\t\treturn -ESRCH;\n\t}\n\toffset = addr - pdi->bar[bidx].addr;\n\tif (dir == MEM_F_WRITE) {\n\t\tif (size == 8) {\n\t\t\t(*ops->vdev_barwrite)(ctx, vcpu, pdi, bidx, offset,\n\t\t\t\t\t   4, *val & 0xffffffff);\n\t\t\t(*ops->vdev_barwrite)(ctx, vcpu, pdi, bidx, offset + 4,\n\t\t\t\t\t   4, *val >> 32);\n\t\t} else {\n\t\t\t(*ops->vdev_barwrite)(ctx, vcpu, pdi, bidx, offset,\n\t\t\t\t\t   size, bar_value(size, *val));\n\t\t}\n\t} else {\n\t\tif (size == 8) {\n\t\t\tuint64_t val_lo, val_hi;\n\t\t\tval_lo = (*ops->vdev_barread)(ctx, vcpu, pdi, bidx,\n\t\t\t                              offset, 4);\n\t\t\tval_lo = bar_value(4, val_lo);\n\t\t\tval_hi = (*ops->vdev_barread)(ctx, vcpu, pdi, bidx,\n\t\t\t                              offset + 4, 4);\n\t\t\t*val = val_lo | (val_hi << 32);\n\t\t} else {\n\t\t\t*val = (*ops->vdev_barread)(ctx, vcpu, pdi, bidx,\n\t\t\t                            offset, size);\n\t\t\t*val = bar_value(size, *val);\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "getTable (const char *tableList)\n{\n  int tableListLen;\n  ChainEntry *currentEntry = NULL;\n  ChainEntry *lastEntry = NULL;\n  void *newTable;\n  if (tableList == NULL || *tableList == 0)\n    return NULL;\n  errorCount = fileCount = 0;\n  tableListLen = strlen (tableList);\n  if (lastTrans != NULL)\n    if (tableListLen == lastTrans->tableListLength && (memcmp\n\t\t\t\t\t\t       (&lastTrans->\n\t\t\t\t\t\t\ttableList\n\t\t\t\t\t\t\t[0],\n\t\t\t\t\t\t\ttableList,\n\t\t\t\t\t\t\ttableListLen)) == 0)\n      return (table = lastTrans->table);\n  currentEntry = tableChain;\n  while (currentEntry != NULL)\n    {\n      if (tableListLen == currentEntry->tableListLength && (memcmp\n\t\t\t\t\t\t\t    (&currentEntry->\n\t\t\t\t\t\t\t     tableList\n\t\t\t\t\t\t\t     [0],\n\t\t\t\t\t\t\t     tableList,\n\t\t\t\t\t\t\t     tableListLen))\n\t  == 0)\n\t{\n\t  lastTrans = currentEntry;\n\t  return (table = currentEntry->table);\n\t}\n      lastEntry = currentEntry;\n      currentEntry = currentEntry->next;\n    }\n  if ((newTable = compileTranslationTable (tableList)))\n    {\n      int entrySize = sizeof (ChainEntry) + tableListLen;\n      ChainEntry *newEntry = malloc (entrySize);\n      if (!newEntry)\n\toutOfMemory ();\n      if (tableChain == NULL)\n\ttableChain = newEntry;\n      else\n\tlastEntry->next = newEntry;\n      newEntry->next = NULL;\n      newEntry->table = newTable;\n      newEntry->tableListLength = tableListLen;\n      memcpy (&newEntry->tableList[0], tableList, tableListLen);\n      lastTrans = newEntry;\n      return newEntry->table;\n    }\n  return NULL;\n}", "target": 0}
{"code": "static int pppol2tp_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t       char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2tp_session *session;\n\tstruct l2tp_tunnel *tunnel;\n\tint val, len;\n\tint err;\n\tstruct pppol2tp_session *ps;\n\tif (level != SOL_PPPOL2TP)\n\t\treturn udp_prot.getsockopt(sk, level, optname, optval, optlen);\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tlen = min_t(unsigned int, len, sizeof(int));\n\tif (len < 0)\n\t\treturn -EINVAL;\n\terr = -ENOTCONN;\n\tif (sk->sk_user_data == NULL)\n\t\tgoto end;\n\terr = -EBADF;\n\tsession = pppol2tp_sock_to_session(sk);\n\tif (session == NULL)\n\t\tgoto end;\n\tps = l2tp_session_priv(session);\n\tif ((session->session_id == 0) &&\n\t    (session->peer_session_id == 0)) {\n\t\terr = -EBADF;\n\t\ttunnel = l2tp_sock_to_tunnel(ps->tunnel_sock);\n\t\tif (tunnel == NULL)\n\t\t\tgoto end_put_sess;\n\t\terr = pppol2tp_tunnel_getsockopt(sk, tunnel, optname, &val);\n\t\tsock_put(ps->tunnel_sock);\n\t} else\n\t\terr = pppol2tp_session_getsockopt(sk, session, optname, &val);\n\terr = -EFAULT;\n\tif (put_user(len, optlen))\n\t\tgoto end_put_sess;\n\tif (copy_to_user((void __user *) optval, &val, len))\n\t\tgoto end_put_sess;\n\terr = 0;\nend_put_sess:\n\tsock_put(sk);\nend:\n\treturn err;\n}", "target": 1}
{"code": "create_new_keys(const char* jwkdir)\n{\n    const char* alg[] = {\"ES512\", \"ECMR\", NULL};\n    char path[PATH_MAX];\n    umask(0337);\n    for (int i = 0; alg[i] != NULL; i++) {\n        json_auto_t* jwk = jwk_generate(alg[i]);\n        if (!jwk) {\n            return 0;\n        }\n        __attribute__ ((__cleanup__(cleanup_str))) char* thp = jwk_thumbprint(jwk, DEFAULT_THP_HASH);\n        if (!thp) {\n            return 0;\n        }\n        if (snprintf(path, PATH_MAX, \"%s/%s.jwk\", jwkdir, thp) < 0) {\n            fprintf(stderr, \"Unable to prepare variable with file full path (%s)\\n\", thp);\n            return 0;\n        }\n        path[sizeof(path) - 1] = '\\0';\n        if (json_dump_file(jwk, path, 0) == -1) {\n            fprintf(stderr, \"Error saving JWK to file (%s)\\n\", path);\n            return 0;\n        }\n        if (chmod(path, S_IRUSR | S_IRGRP) == -1) {\n            fprintf(stderr, \"Unable to set permissions for JWK file (%s)\\n\", path);\n            return 0;\n        }\n    }\n    return 1;\n}", "target": 0}
{"code": "static int ext4_dax_pfn_mkwrite(struct vm_area_struct *vma,\n\t\t\t\tstruct vm_fault *vmf)\n{\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tstruct super_block *sb = inode->i_sb;\n\tint ret = VM_FAULT_NOPAGE;\n\tloff_t size;\n\tsb_start_pagefault(sb);\n\tfile_update_time(vma->vm_file);\n\tdown_read(&EXT4_I(inode)->i_mmap_sem);\n\tsize = (i_size_read(inode) + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tif (vmf->pgoff >= size)\n\t\tret = VM_FAULT_SIGBUS;\n\tup_read(&EXT4_I(inode)->i_mmap_sem);\n\tsb_end_pagefault(sb);\n\treturn ret;\n}", "target": 0}
{"code": "static inline void vmacache_invalidate(struct mm_struct *mm)\n{\n\tmm->vmacache_seqnum++;\n\tif (unlikely(mm->vmacache_seqnum == 0))\n\t\tvmacache_flush_all(mm);\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& data = context->input(0);\n    const Tensor& segment_ids = context->input(1);\n    const Tensor& num_segments = context->input(2);\n    if (!UnsortedSegmentReductionDoValidation(this, context, data, segment_ids,\n                                              num_segments)) {\n      return;\n    }\n    const auto segment_flat = segment_ids.flat<Index>();\n    const Index output_rows = internal::SubtleMustCopy(static_cast<Index>(\n        num_segments.dtype() == DT_INT32 ? num_segments.scalar<int32>()()\n                                         : num_segments.scalar<int64>()()));\n    OP_REQUIRES(context, output_rows >= 0,\n                errors::InvalidArgument(\"Input num_segments == \", output_rows,\n                                        \" must not be negative.\"));\n    TensorShape output_shape;\n    output_shape.AddDim(output_rows);\n    for (int i = segment_ids.dims(); i < data.dims(); i++) {\n      output_shape.AddDim(data.dim_size(i));\n    }\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output));\n    auto output_flat = output->flat_outer_dims<T>();\n    auto data_ptr = data.template flat<T>().data();\n    reduction_functor_(context, output_rows, segment_ids.shape(), segment_flat,\n                       data.NumElements(), data_ptr, output_flat);\n  }", "target": 1}
{"code": "static void xen_netbk_fill_frags(struct xen_netbk *netbk, struct sk_buff *skb)\n{\n\tstruct skb_shared_info *shinfo = skb_shinfo(skb);\n\tint nr_frags = shinfo->nr_frags;\n\tint i;\n\tfor (i = 0; i < nr_frags; i++) {\n\t\tskb_frag_t *frag = shinfo->frags + i;\n\t\tstruct xen_netif_tx_request *txp;\n\t\tstruct page *page;\n\t\tu16 pending_idx;\n\t\tpending_idx = frag_get_pending_idx(frag);\n\t\ttxp = &netbk->pending_tx_info[pending_idx].req;\n\t\tpage = virt_to_page(idx_to_kaddr(netbk, pending_idx));\n\t\t__skb_fill_page_desc(skb, i, page, txp->offset, txp->size);\n\t\tskb->len += txp->size;\n\t\tskb->data_len += txp->size;\n\t\tskb->truesize += txp->size;\n\t\tget_page(netbk->mmap_pages[pending_idx]);\n\t\txen_netbk_idx_release(netbk, pending_idx);\n\t}\n}", "target": 1}
{"code": "static u32 psi_group_change(struct psi_group *group, int cpu,\n\t\t\t    unsigned int clear, unsigned int set)\n{\n\tstruct psi_group_cpu *groupc;\n\tunsigned int t, m;\n\tenum psi_states s;\n\tu32 state_mask = 0;\n\tgroupc = per_cpu_ptr(group->pcpu, cpu);\n\twrite_seqcount_begin(&groupc->seq);\n\trecord_times(groupc, cpu, false);\n\tfor (t = 0, m = clear; m; m &= ~(1 << t), t++) {\n\t\tif (!(m & (1 << t)))\n\t\t\tcontinue;\n\t\tif (groupc->tasks[t] == 0 && !psi_bug) {\n\t\t\tprintk_deferred(KERN_ERR \"psi: task underflow! cpu=%d t=%d tasks=[%u %u %u] clear=%x set=%x\\n\",\n\t\t\t\t\tcpu, t, groupc->tasks[0],\n\t\t\t\t\tgroupc->tasks[1], groupc->tasks[2],\n\t\t\t\t\tclear, set);\n\t\t\tpsi_bug = 1;\n\t\t}\n\t\tgroupc->tasks[t]--;\n\t}\n\tfor (t = 0; set; set &= ~(1 << t), t++)\n\t\tif (set & (1 << t))\n\t\t\tgroupc->tasks[t]++;\n\tfor (s = 0; s < NR_PSI_STATES; s++) {\n\t\tif (test_state(groupc->tasks, s))\n\t\t\tstate_mask |= (1 << s);\n\t}\n\tgroupc->state_mask = state_mask;\n\twrite_seqcount_end(&groupc->seq);\n\treturn state_mask;\n}", "target": 0}
{"code": "void flush_tlb_page(struct vm_area_struct *vma, unsigned long start)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpreempt_disable();\n\tif (current->active_mm == mm) {\n\t\tif (current->mm)\n\t\t\t__flush_tlb_one(start);\n\t\telse\n\t\t\tleave_mm(smp_processor_id());\n\t}\n\tif (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) < nr_cpu_ids)\n\t\tflush_tlb_others(mm_cpumask(mm), mm, start, 0UL);\n\tpreempt_enable();\n}", "target": 1}
{"code": "struct net *get_net_ns_by_id(struct net *net, int id)\n{\n\tstruct net *peer;\n\tif (id < 0)\n\t\treturn NULL;\n\trcu_read_lock();\n\tspin_lock_bh(&net->nsid_lock);\n\tpeer = idr_find(&net->netns_ids, id);\n\tif (peer)\n\t\tget_net(peer);\n\tspin_unlock_bh(&net->nsid_lock);\n\trcu_read_unlock();\n\treturn peer;\n}", "target": 1}
{"code": "static int decode_dds1(GetByteContext *gb, uint8_t *frame, int width, int height)\n{\n    const uint8_t *frame_start = frame;\n    const uint8_t *frame_end   = frame + width * height;\n    int mask = 0x10000, bitbuf = 0;\n    int i, v, offset, count, segments;\n    segments = bytestream2_get_le16(gb);\n    while (segments--) {\n        if (bytestream2_get_bytes_left(gb) < 2)\n            return AVERROR_INVALIDDATA;\n        if (mask == 0x10000) {\n            bitbuf = bytestream2_get_le16u(gb);\n            mask = 1;\n        }\n        if (bitbuf & mask) {\n            v = bytestream2_get_le16(gb);\n            offset = (v & 0x1FFF) << 2;\n            count = ((v >> 13) + 2) << 1;\n            if (frame - frame_start < offset || frame_end - frame < count*2 + width)\n                return AVERROR_INVALIDDATA;\n            for (i = 0; i < count; i++) {\n                frame[0] = frame[1] =\n                frame[width] = frame[width + 1] = frame[-offset];\n                frame += 2;\n            }\n        } else if (bitbuf & (mask << 1)) {\n            v = bytestream2_get_le16(gb)*2;\n            if (frame - frame_end < v)\n                return AVERROR_INVALIDDATA;\n            frame += v;\n        } else {\n            if (frame_end - frame < width + 3)\n                return AVERROR_INVALIDDATA;\n            frame[0] = frame[1] =\n            frame[width] = frame[width + 1] =  bytestream2_get_byte(gb);\n            frame += 2;\n            frame[0] = frame[1] =\n            frame[width] = frame[width + 1] =  bytestream2_get_byte(gb);\n            frame += 2;\n        }\n        mask <<= 2;\n    }\n    return 0;\n}", "target": 1}
{"code": "struct bpf_map *bpf_map_get_with_uref(u32 ufd)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_map *map;\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn map;\n\tbpf_map_inc(map, true);\n\tfdput(f);\n\treturn map;\n}", "target": 1}
{"code": "static bool php_mb_parse_encoding(const Variant& encoding,\n                                  mbfl_encoding ***return_list,\n                                  int *return_size, bool persistent) {\n  bool ret;\n  if (encoding.isArray()) {\n    ret = php_mb_parse_encoding_array(encoding.toArray(),\n                                      return_list, return_size,\n                                      persistent ? 1 : 0);\n  } else {\n    String enc = encoding.toString();\n    ret = php_mb_parse_encoding_list(enc.data(), enc.size(),\n                                     return_list, return_size,\n                                     persistent ? 1 : 0);\n  }\n  if (!ret) {\n    if (return_list && *return_list) {\n      free(*return_list);\n      *return_list = nullptr;\n    }\n    return_size = 0;\n  }\n  return ret;\n}", "target": 1}
{"code": "static int decode_preamble(void *p, struct ceph_frame_desc *desc)\n{\n\tvoid *crcp = p + CEPH_PREAMBLE_LEN - CEPH_CRC_LEN;\n\tu32 crc, expected_crc;\n\tint i;\n\tcrc = crc32c(0, p, crcp - p);\n\texpected_crc = get_unaligned_le32(crcp);\n\tif (crc != expected_crc) {\n\t\tpr_err(\"bad preamble crc, calculated %u, expected %u\\n\",\n\t\t       crc, expected_crc);\n\t\treturn -EBADMSG;\n\t}\n\tmemset(desc, 0, sizeof(*desc));\n\tdesc->fd_tag = ceph_decode_8(&p);\n\tdesc->fd_seg_cnt = ceph_decode_8(&p);\n\tif (desc->fd_seg_cnt < 1 ||\n\t    desc->fd_seg_cnt > CEPH_FRAME_MAX_SEGMENT_COUNT) {\n\t\tpr_err(\"bad segment count %d\\n\", desc->fd_seg_cnt);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < desc->fd_seg_cnt; i++) {\n\t\tdesc->fd_lens[i] = ceph_decode_32(&p);\n\t\tdesc->fd_aligns[i] = ceph_decode_16(&p);\n\t}\n\tif (!desc->fd_lens[desc->fd_seg_cnt - 1]) {\n\t\tpr_err(\"last segment empty\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (desc->fd_lens[0] > CEPH_MSG_MAX_CONTROL_LEN) {\n\t\tpr_err(\"control segment too big %d\\n\", desc->fd_lens[0]);\n\t\treturn -EINVAL;\n\t}\n\tif (desc->fd_lens[1] > CEPH_MSG_MAX_FRONT_LEN) {\n\t\tpr_err(\"front segment too big %d\\n\", desc->fd_lens[1]);\n\t\treturn -EINVAL;\n\t}\n\tif (desc->fd_lens[2] > CEPH_MSG_MAX_MIDDLE_LEN) {\n\t\tpr_err(\"middle segment too big %d\\n\", desc->fd_lens[2]);\n\t\treturn -EINVAL;\n\t}\n\tif (desc->fd_lens[3] > CEPH_MSG_MAX_DATA_LEN) {\n\t\tpr_err(\"data segment too big %d\\n\", desc->fd_lens[3]);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "EXPORTED const char *dlist_reserve_path(const char *part, int isarchive,\n                                        const struct message_guid *guid)\n{\n    static char buf[MAX_MAILBOX_PATH];\n    const char *base;\n    if (strchr(part, '/')) {\n        base = part;\n    }\n    else {\n        base = isarchive ? config_archivepartitiondir(part)\n                         : config_partitiondir(part);\n    }\n    assert(base != NULL);\n    snprintf(buf, MAX_MAILBOX_PATH, \"%s/sync./%lu/%s\",\n                  base, (unsigned long)getpid(),\n                  message_guid_encode(guid));\n    if (cyrus_mkdir(buf, 0755)) {\n        syslog(LOG_ERR, \"IOERROR: failed to create %s/sync./%lu/ for reserve: %m\",\n                        base, (unsigned long)getpid());\n    }\n    return buf;\n}", "target": 1}
{"code": "static int nfs4_xdr_dec_readdir(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t\tstruct nfs4_readdir_res *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_readdir(xdr, rqstp, res);\nout:\n\treturn status;\n}", "target": 0}
{"code": "static bool kvm_vcpu_check_breakpoint(struct kvm_vcpu *vcpu, int *r)\n{\n\tif (unlikely(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) &&\n\t    (vcpu->arch.guest_debug_dr7 & DR7_BP_EN_MASK)) {\n\t\tstruct kvm_run *kvm_run = vcpu->run;\n\t\tunsigned long eip = kvm_get_linear_rip(vcpu);\n\t\tu32 dr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.guest_debug_dr7,\n\t\t\t\t\t   vcpu->arch.eff_db);\n\t\tif (dr6 != 0) {\n\t\t\tkvm_run->debug.arch.dr6 = dr6 | DR6_ACTIVE_LOW;\n\t\t\tkvm_run->debug.arch.pc = eip;\n\t\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\t\t*r = 0;\n\t\t\treturn true;\n\t\t}\n\t}\n\tif (unlikely(vcpu->arch.dr7 & DR7_BP_EN_MASK) &&\n\t    !(kvm_get_rflags(vcpu) & X86_EFLAGS_RF)) {\n\t\tunsigned long eip = kvm_get_linear_rip(vcpu);\n\t\tu32 dr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.dr7,\n\t\t\t\t\t   vcpu->arch.db);\n\t\tif (dr6 != 0) {\n\t\t\tkvm_queue_exception_p(vcpu, DB_VECTOR, dr6);\n\t\t\t*r = 1;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "target": 1}
{"code": "static inline int quic_token_validate(struct quic_rx_packet *pkt,\n                                      struct quic_dgram *dgram,\n                                      struct listener *l, struct quic_conn *qc,\n                                      struct quic_cid *odcid)\n{\n\tint ret = 0;\n\tTRACE_ENTER(QUIC_EV_CONN_LPKT, qc);\n\tswitch (*pkt->token) {\n\tcase QUIC_TOKEN_FMT_RETRY:\n\t\tret = quic_retry_token_check(pkt, dgram, l, qc, odcid);\n\t\tbreak;\n\tcase QUIC_TOKEN_FMT_NEW:\n\t\tret = quic_token_check(pkt, dgram, qc);\n\t\tif (!ret) {\n\t\t\tdgram->flags |= QUIC_DGRAM_FL_SEND_RETRY;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tTRACE_PROTO(\"Packet dropped\", QUIC_EV_CONN_LPKT, qc, NULL, NULL, pkt->version);\n\t\tbreak;\n\t}\n\tif (!ret)\n\t\tgoto err;\n\tret = 1;\n leave:\n\tTRACE_LEAVE(QUIC_EV_CONN_LPKT, qc);\n\treturn ret;\n err:\n\tTRACE_DEVEL(\"leaving in error\", QUIC_EV_CONN_LPKT, qc);\n\tgoto leave;\n}", "target": 0}
{"code": "int nfc_register_device(struct nfc_dev *dev)\n{\n\tint rc;\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\tmutex_lock(&nfc_devlist_mutex);\n\tnfc_devlist_generation++;\n\trc = device_add(&dev->dev);\n\tmutex_unlock(&nfc_devlist_mutex);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = nfc_llcp_register_device(dev);\n\tif (rc)\n\t\tpr_err(\"Could not register llcp device\\n\");\n\tdevice_lock(&dev->dev);\n\tdev->rfkill = rfkill_alloc(dev_name(&dev->dev), &dev->dev,\n\t\t\t\t   RFKILL_TYPE_NFC, &nfc_rfkill_ops, dev);\n\tif (dev->rfkill) {\n\t\tif (rfkill_register(dev->rfkill) < 0) {\n\t\t\trfkill_destroy(dev->rfkill);\n\t\t\tdev->rfkill = NULL;\n\t\t}\n\t}\n\tdev->shutting_down = false;\n\tdevice_unlock(&dev->dev);\n\trc = nfc_genl_device_added(dev);\n\tif (rc)\n\t\tpr_debug(\"The userspace won't be notified that the device %s was added\\n\",\n\t\t\t dev_name(&dev->dev));\n\treturn 0;\n}", "target": 0}
{"code": "void ax25_disconnect(ax25_cb *ax25, int reason)\n{\n\tax25_clear_queues(ax25);\n\tif (!ax25->sk || !sock_flag(ax25->sk, SOCK_DESTROY))\n\t\tax25_stop_heartbeat(ax25);\n\tax25_stop_t1timer(ax25);\n\tax25_stop_t2timer(ax25);\n\tax25_stop_t3timer(ax25);\n\tax25_stop_idletimer(ax25);\n\tax25->state = AX25_STATE_0;\n\tax25_link_failed(ax25, reason);\n\tif (ax25->sk != NULL) {\n\t\tlocal_bh_disable();\n\t\tbh_lock_sock(ax25->sk);\n\t\tax25->sk->sk_state     = TCP_CLOSE;\n\t\tax25->sk->sk_err       = reason;\n\t\tax25->sk->sk_shutdown |= SEND_SHUTDOWN;\n\t\tif (!sock_flag(ax25->sk, SOCK_DEAD)) {\n\t\t\tax25->sk->sk_state_change(ax25->sk);\n\t\t\tsock_set_flag(ax25->sk, SOCK_DEAD);\n\t\t}\n\t\tbh_unlock_sock(ax25->sk);\n\t\tlocal_bh_enable();\n\t}\n}", "target": 1}
{"code": "static int oidc_request_post_preserved_restore(request_rec *r,\n\t\tconst char *original_url) {\n\toidc_debug(r, \"enter: original_url=%s\", original_url);\n\tconst char *method = \"postOnLoad\";\n\tconst char *script =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\t\t\"      function str_decode(string) {\\n\"\n\t\t\t\t\t\"        try {\\n\"\n\t\t\t\t\t\"          result = decodeURIComponent(string);\\n\"\n\t\t\t\t\t\"        } catch (e) {\\n\"\n\t\t\t\t\t\"          result =  unescape(string);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        return result;\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"      function %s() {\\n\"\n\t\t\t\t\t\"        var mod_auth_openidc_preserve_post_params = JSON.parse(sessionStorage.getItem('mod_auth_openidc_preserve_post_params'));\\n\"\n\t\t\t\t\t\"\t\t sessionStorage.removeItem('mod_auth_openidc_preserve_post_params');\\n\"\n\t\t\t\t\t\"        for (var key in mod_auth_openidc_preserve_post_params) {\\n\"\n\t\t\t\t\t\"          var input = document.createElement(\\\"input\\\");\\n\"\n\t\t\t\t\t\"          input.name = str_decode(key);\\n\"\n\t\t\t\t\t\"          input.value = str_decode(mod_auth_openidc_preserve_post_params[key]);\\n\"\n\t\t\t\t\t\"          input.type = \\\"hidden\\\";\\n\"\n\t\t\t\t\t\"          document.forms[0].appendChild(input);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        document.forms[0].action = \\\"%s\\\";\\n\"\n\t\t\t\t\t\"        document.forms[0].submit();\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"    </script>\\n\", method, oidc_util_javascript_escape(r->pool, original_url));\n\tconst char *body = \"    <p>Restoring...</p>\\n\"\n\t\t\t\"    <form method=\\\"post\\\"></form>\\n\";\n\treturn oidc_util_html_send(r, \"Restoring...\", script, method, body,\n\t\t\tOK);\n}", "target": 0}
{"code": "static inline long div_ll_X_l_rem(long long divs, long div, long *rem)\n{\n\tlong dum2;\n\tasm(\"divl %2\":\"=a\"(dum2), \"=d\"(*rem)\n\t    : \"rm\"(div), \"A\"(divs));\n\treturn dum2;\n}", "target": 1}
{"code": "static void mspack_fmap_free(void *mem)\n{\n\tfree(mem);\n}", "target": 1}
{"code": "static void vmx_disable_intercept_msr_read_x2apic(u32 msr)\n{\n\t__vmx_disable_intercept_for_msr(vmx_msr_bitmap_legacy_x2apic,\n\t\t\tmsr, MSR_TYPE_R);\n\t__vmx_disable_intercept_for_msr(vmx_msr_bitmap_longmode_x2apic,\n\t\t\tmsr, MSR_TYPE_R);\n}", "target": 0}
{"code": "expand_dynamic_string_token (struct link_map *l, const char *s)\n{\n  size_t cnt;\n  size_t total;\n  char *result;\n  cnt = DL_DST_COUNT (s, 1);\n  if (cnt == 0)\n    return local_strdup (s);\n  total = DL_DST_REQUIRED (l, s, strlen (s), cnt);\n  result = (char *) malloc (total + 1);\n  if (result == NULL)\n    return NULL;\n  return DL_DST_SUBSTITUTE (l, s, result, 1);\n}", "target": 1}
{"code": "static void sunkbd_set_leds_beeps(struct sunkbd *sunkbd)\n{\n\tserio_write(sunkbd->serio, SUNKBD_CMD_SETLED);\n\tserio_write(sunkbd->serio,\n\t\t(!!test_bit(LED_CAPSL,   sunkbd->dev->led) << 3) |\n\t\t(!!test_bit(LED_SCROLLL, sunkbd->dev->led) << 2) |\n\t\t(!!test_bit(LED_COMPOSE, sunkbd->dev->led) << 1) |\n\t\t !!test_bit(LED_NUML,    sunkbd->dev->led));\n\tserio_write(sunkbd->serio,\n\t\tSUNKBD_CMD_NOCLICK - !!test_bit(SND_CLICK, sunkbd->dev->snd));\n\tserio_write(sunkbd->serio,\n\t\tSUNKBD_CMD_BELLOFF - !!test_bit(SND_BELL, sunkbd->dev->snd));\n}", "target": 0}
{"code": "static int php_curl_option_url(php_curl *ch, const char *url, const int len) \n{\n\tif (PG(open_basedir) && *PG(open_basedir)) {\n#if LIBCURL_VERSION_NUM >= 0x071304\n\t\tcurl_easy_setopt(ch->cp, CURLOPT_PROTOCOLS, CURLPROTO_ALL & ~CURLPROTO_FILE);\n#else\n\t\tphp_url *uri;\n\t\tif (!(uri = php_url_parse_ex(url, len))) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Invalid URL '%s'\", url);\n\t\t\treturn FAILURE;\n\t\t}\n\t\tif (uri->scheme && !strncasecmp(\"file\", uri->scheme, sizeof(\"file\"))) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Protocol 'file' disabled in cURL\");\n\t\t\tphp_url_free(uri);\n\t\t\treturn FAILURE;\n\t\t}\n\t\tphp_url_free(uri);\n#endif\n\t}\n\treturn php_curl_option_str(ch, CURLOPT_URL, url, len, 0);\n}", "target": 0}
{"code": "static inline int xrstor_state_booting(struct xsave_struct *fx, u64 mask)\n{\n\tu32 lmask = mask;\n\tu32 hmask = mask >> 32;\n\tint err = 0;\n\tWARN_ON(system_state != SYSTEM_BOOTING);\n\tif (boot_cpu_has(X86_FEATURE_XSAVES))\n\t\tasm volatile(\"1:\"XRSTORS\"\\n\\t\"\n\t\t\t\"2:\\n\\t\"\n\t\t\t: : \"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t\t:   \"memory\");\n\telse\n\t\tasm volatile(\"1:\"XRSTOR\"\\n\\t\"\n\t\t\t\"2:\\n\\t\"\n\t\t\t: : \"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t\t:   \"memory\");\n\tasm volatile(xstate_fault\n\t\t     : \"0\" (0)\n\t\t     : \"memory\");\n\treturn err;\n}", "target": 1}
{"code": "int init_aliases(void)\n{\n    FILE *fp;\n    char alias[MAXALIASLEN + 1U];\n    char dir[PATH_MAX + 1U];\n    if ((fp = fopen(ALIASES_FILE, \"r\")) == NULL) {\n        return 0;\n    }\n    while (fgets(alias, sizeof alias, fp) != NULL) {\n        if (*alias == '#' || *alias == '\\n' || *alias == 0) {\n            continue;\n        }\n        {\n            char * const z = alias + strlen(alias) - 1U;\n            if (*z != '\\n') {\n                goto bad;\n            }\n            *z = 0;\n        }\n        do {\n            if (fgets(dir, sizeof dir, fp) == NULL || *dir == 0) {\n                goto bad;\n            }\n            {\n                char * const z = dir + strlen(dir) - 1U;\n                if (*z == '\\n') {\n                    *z = 0;\n                }\n            }\n        } while (*dir == '#' || *dir == 0);\n        if (head == NULL) {\n            if ((head = tail = malloc(sizeof *head)) == NULL ||\n                (tail->alias = strdup(alias)) == NULL ||\n                (tail->dir = strdup(dir)) == NULL) {\n                die_mem();\n            }\n            tail->next = NULL;\n        } else {\n            DirAlias *curr;\n            if ((curr = malloc(sizeof *curr)) == NULL ||\n                (curr->alias = strdup(alias)) == NULL ||\n                (curr->dir = strdup(dir)) == NULL) {\n                die_mem();\n            }\n            tail->next = curr;\n            tail = curr;\n        }\n    }\n    fclose(fp);\n    aliases_up++;\n    return 0;\n    bad:\n    fclose(fp);\n    logfile(LOG_ERR, MSG_ALIASES_BROKEN_FILE \" [\" ALIASES_FILE \"]\");\n    return -1;\n}", "target": 1}
{"code": "static int snd_seq_device_dev_free(struct snd_device *device)\n{\n\tstruct snd_seq_device *dev = device->device_data;\n\tcancel_autoload_drivers();\n\tput_device(&dev->dev);\n\treturn 0;\n}", "target": 0}
{"code": "int64_t LineBasedFrameDecoder::findEndOfLine(IOBufQueue& buf) {\n  Cursor c(buf.front());\n  for (uint32_t i = 0; i < maxLength_ && i < buf.chainLength(); i++) {\n    auto b = c.read<char>();\n    if (b == '\\n' && terminatorType_ != TerminatorType::CARRIAGENEWLINE) {\n      return i;\n    } else if (terminatorType_ != TerminatorType::NEWLINE &&\n               b == '\\r' && !c.isAtEnd() && c.read<char>() == '\\n') {\n      return i;\n    }\n  }\n  return -1;\n}", "target": 1}
{"code": "}\nvoid print_udta(GF_ISOFile *file, u32 track_number, Bool has_itags)\n{\n\tu32 i, count;\n\tcount =  gf_isom_get_udta_count(file, track_number);\n\tif (!count) return;\n\tif (has_itags) {\n\t\tfor (i=0; i<count; i++) {\n\t\t\tu32 type;\n\t\t\tbin128 uuid;\n\t\t\tgf_isom_get_udta_type(file, track_number, i+1, &type, &uuid);\n\t\t\tif (type == GF_ISOM_BOX_TYPE_META) {\n\t\t\t\tcount--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!count) return;\n\t}\n\tfprintf(stderr, \"%d UDTA types: \", count);\n\tfor (i=0; i<count; i++) {\n\t\tu32 j, type, nb_items, first=GF_TRUE;\n\t\tbin128 uuid;\n\t\tgf_isom_get_udta_type(file, track_number, i+1, &type, &uuid);\n\t\tnb_items = gf_isom_get_user_data_count(file, track_number, type, uuid);\n\t\tfprintf(stderr, \"%s (%d) \", gf_4cc_to_str(type), nb_items);\n\t\tfor (j=0; j<nb_items; j++) {\n\t\t\tu8 *udta=NULL;\n\t\t\tu32 udta_size;\n\t\t\tgf_isom_get_user_data(file, track_number, type, uuid, j+1, &udta, &udta_size);\n\t\t\tif (!udta) continue;\n\t\t\tif (gf_utf8_is_legal(udta, udta_size)) {\n\t\t\t\tif (first) {\n\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t\tfirst = GF_FALSE;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\t%s\\n\", (char *) udta);\n\t\t\t}\n\t\t\tgf_free(udta);\n\t\t}\n\t}", "target": 1}
{"code": "TEST(EqOp, ElemMatchKeyWithImplicitAndExplicitTraversal) {\n    BSONObj operand = BSON(\"a.0.b\" << 3);\n    BSONElement operandFirstElt = operand.firstElement();\n    EqualityMatchExpression eq(operandFirstElt.fieldName(), operandFirstElt);\n    MatchDetails details;\n    details.requestElemMatchKey();\n    BSONObj obj = fromjson(\"{a: [{b: [2, 3]}, {b: [4, 5]}]}\");\n    ASSERT(eq.matchesBSON(obj, &details));\n    ASSERT(details.hasElemMatchKey());\n    ASSERT_EQUALS(\"1\", details.elemMatchKey());\n}", "target": 0}
{"code": "static __be32 nfsacld_proc_setacl(struct svc_rqst * rqstp,\n\t\tstruct nfsd3_setaclargs *argp,\n\t\tstruct nfsd_attrstat *resp)\n{\n\tstruct inode *inode;\n\tsvc_fh *fh;\n\t__be32 nfserr = 0;\n\tint error;\n\tdprintk(\"nfsd: SETACL(2acl)   %s\\n\", SVCFH_fmt(&argp->fh));\n\tfh = fh_copy(&resp->fh, &argp->fh);\n\tnfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);\n\tif (nfserr)\n\t\tgoto out;\n\tinode = d_inode(fh->fh_dentry);\n\tif (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {\n\t\terror = -EOPNOTSUPP;\n\t\tgoto out_errno;\n\t}\n\terror = fh_want_write(fh);\n\tif (error)\n\t\tgoto out_errno;\n\terror = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);\n\tif (error)\n\t\tgoto out_drop_write;\n\terror = inode->i_op->set_acl(inode, argp->acl_default,\n\t\t\t\t     ACL_TYPE_DEFAULT);\n\tif (error)\n\t\tgoto out_drop_write;\n\tfh_drop_write(fh);\n\tnfserr = fh_getattr(fh, &resp->stat);\nout:\n\tposix_acl_release(argp->acl_access);\n\tposix_acl_release(argp->acl_default);\n\treturn nfserr;\nout_drop_write:\n\tfh_drop_write(fh);\nout_errno:\n\tnfserr = nfserrno(error);\n\tgoto out;\n}", "target": 1}
{"code": "lha_read_file_header_1(struct archive_read *a, struct lha *lha)\n{\n\tconst unsigned char *p;\n\tsize_t extdsize;\n\tint i, err, err2;\n\tint namelen, padding;\n\tunsigned char headersum, sum_calculated;\n\terr = ARCHIVE_OK;\n\tif ((p = __archive_read_ahead(a, H1_FIXED_SIZE, NULL)) == NULL)\n\t\treturn (truncated_error(a));\n\tlha->header_size = p[H1_HEADER_SIZE_OFFSET] + 2;\n\theadersum = p[H1_HEADER_SUM_OFFSET];\n\tlha->compsize = archive_le32dec(p + H1_COMP_SIZE_OFFSET);\n\tlha->origsize = archive_le32dec(p + H1_ORIG_SIZE_OFFSET);\n\tlha->mtime = lha_dos_time(p + H1_DOS_TIME_OFFSET);\n\tnamelen = p[H1_NAME_LEN_OFFSET];\n\tpadding = ((int)lha->header_size) - H1_FIXED_SIZE - namelen;\n\tif (namelen > 230 || padding < 0)\n\t\tgoto invalid;\n\tif ((p = __archive_read_ahead(a, lha->header_size, NULL)) == NULL)\n\t\treturn (truncated_error(a));\n\tfor (i = 0; i < namelen; i++) {\n\t\tif (p[i + H1_FILE_NAME_OFFSET] == 0xff)\n\t\t\tgoto invalid;\n\t}\n\tarchive_strncpy(&lha->filename, p + H1_FILE_NAME_OFFSET, namelen);\n\tlha->crc = archive_le16dec(p + H1_FILE_NAME_OFFSET + namelen);\n\tlha->setflag |= CRC_IS_SET;\n\tsum_calculated = lha_calcsum(0, p, 2, lha->header_size - 2);\n\t__archive_read_consume(a, lha->header_size - 2);\n\terr2 = lha_read_file_extended_header(a, lha, NULL, 2,\n\t    (size_t)(lha->compsize + 2), &extdsize);\n\tif (err2 < ARCHIVE_WARN)\n\t\treturn (err2);\n\tif (err2 < err)\n\t\terr = err2;\n\tlha->compsize -= extdsize - 2;\n\tif (lha->compsize < 0)\n\t\tgoto invalid;\t\n\tif (sum_calculated != headersum) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"LHa header sum error\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\treturn (err);\ninvalid:\n\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t    \"Invalid LHa header\");\n\treturn (ARCHIVE_FATAL);\n}", "target": 0}
{"code": "dtls1_buffer_record(SSL *s, record_pqueue *queue, unsigned char *priority)\n\t{\n\tDTLS1_RECORD_DATA *rdata;\n\tpitem *item;\n\tif (pqueue_size(queue->q) >= 100)\n\t\treturn 0;\n\trdata = OPENSSL_malloc(sizeof(DTLS1_RECORD_DATA));\n\titem = pitem_new(priority, rdata);\n\tif (rdata == NULL || item == NULL)\n\t\t{\n\t\tif (rdata != NULL) OPENSSL_free(rdata);\n\t\tif (item != NULL) pitem_free(item);\n\t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n\t\treturn(0);\n\t\t}\n\trdata->packet = s->packet;\n\trdata->packet_length = s->packet_length;\n\tmemcpy(&(rdata->rbuf), &(s->s3->rbuf), sizeof(SSL3_BUFFER));\n\tmemcpy(&(rdata->rrec), &(s->s3->rrec), sizeof(SSL3_RECORD));\n\titem->data = rdata;\n#ifndef OPENSSL_NO_SCTP\n\tif (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&\n\t    (s->state == SSL3_ST_SR_FINISHED_A || s->state == SSL3_ST_CR_FINISHED_A)) {\n\t\tBIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SCTP_GET_RCVINFO, sizeof(rdata->recordinfo), &rdata->recordinfo);\n\t}\n#endif\n\ts->packet = NULL;\n\ts->packet_length = 0;\n\tmemset(&(s->s3->rbuf), 0, sizeof(SSL3_BUFFER));\n\tmemset(&(s->s3->rrec), 0, sizeof(SSL3_RECORD));\n\tif (!ssl3_setup_buffers(s))\n\t\t{\n\t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n\t\tOPENSSL_free(rdata);\n\t\tpitem_free(item);\n\t\treturn(0);\n\t\t}\n\tif (pqueue_insert(queue->q, item) == NULL)\n\t\t{\n\t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n\t\tOPENSSL_free(rdata);\n\t\tpitem_free(item);\n\t\treturn(0);\n\t\t}\n\treturn(1);\n\t}", "target": 1}
{"code": "flatpak_proxy_client_init (FlatpakProxyClient *client)\n{\n  init_side (client, &client->client_side);\n  init_side (client, &client->bus_side);\n  client->auth_end_offset = AUTH_END_INIT_OFFSET;\n  client->rewrite_reply = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_object_unref);\n  client->get_owner_reply = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_free);\n  client->unique_id_policy = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n}", "target": 1}
{"code": "static int udf_load_sparable_map(struct super_block *sb,\n\t\t\t\t struct udf_part_map *map,\n\t\t\t\t struct sparablePartitionMap *spm)\n{\n\tuint32_t loc;\n\tuint16_t ident;\n\tstruct sparingTable *st;\n\tstruct udf_sparing_data *sdata = &map->s_type_specific.s_sparing;\n\tint i;\n\tstruct buffer_head *bh;\n\tmap->s_partition_type = UDF_SPARABLE_MAP15;\n\tsdata->s_packet_len = le16_to_cpu(spm->packetLength);\n\tif (!is_power_of_2(sdata->s_packet_len)) {\n\t\tudf_err(sb, \"error loading logical volume descriptor: \"\n\t\t\t\"Invalid packet length %u\\n\",\n\t\t\t(unsigned)sdata->s_packet_len);\n\t\treturn -EIO;\n\t}\n\tif (spm->numSparingTables > 4) {\n\t\tudf_err(sb, \"error loading logical volume descriptor: \"\n\t\t\t\"Too many sparing tables (%d)\\n\",\n\t\t\t(int)spm->numSparingTables);\n\t\treturn -EIO;\n\t}\n\tfor (i = 0; i < spm->numSparingTables; i++) {\n\t\tloc = le32_to_cpu(spm->locSparingTable[i]);\n\t\tbh = udf_read_tagged(sb, loc, loc, &ident);\n\t\tif (!bh)\n\t\t\tcontinue;\n\t\tst = (struct sparingTable *)bh->b_data;\n\t\tif (ident != 0 ||\n\t\t    strncmp(st->sparingIdent.ident, UDF_ID_SPARING,\n\t\t\t    strlen(UDF_ID_SPARING)) ||\n\t\t    sizeof(*st) + le16_to_cpu(st->reallocationTableLen) >\n\t\t\t\t\t\t\tsb->s_blocksize) {\n\t\t\tbrelse(bh);\n\t\t\tcontinue;\n\t\t}\n\t\tsdata->s_spar_map[i] = bh;\n\t}\n\tmap->s_partition_func = udf_get_pblock_spar15;\n\treturn 0;\n}", "target": 0}
{"code": "static void chase_port(struct edgeport_port *port, unsigned long timeout,\n\t\t\t\t\t\t\t\tint flush)\n{\n\tint baud_rate;\n\tstruct tty_struct *tty = tty_port_tty_get(&port->port->port);\n\tstruct usb_serial *serial = port->port->serial;\n\twait_queue_t wait;\n\tunsigned long flags;\n\tif (!tty)\n\t\treturn;\n\tif (!timeout)\n\t\ttimeout = (HZ * EDGE_CLOSING_WAIT)/100;\n\tspin_lock_irqsave(&port->ep_lock, flags);\n\tinit_waitqueue_entry(&wait, current);\n\tadd_wait_queue(&tty->write_wait, &wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (kfifo_len(&port->write_fifo) == 0\n\t\t|| timeout == 0 || signal_pending(current)\n\t\t|| serial->disconnected)\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&port->ep_lock, flags);\n\t\ttimeout = schedule_timeout(timeout);\n\t\tspin_lock_irqsave(&port->ep_lock, flags);\n\t}\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(&tty->write_wait, &wait);\n\tif (flush)\n\t\tkfifo_reset_out(&port->write_fifo);\n\tspin_unlock_irqrestore(&port->ep_lock, flags);\n\ttty_kref_put(tty);\n\ttimeout += jiffies;\n\twhile ((long)(jiffies - timeout) < 0 && !signal_pending(current)\n\t\t\t\t\t\t&& !serial->disconnected) {\n\t\tif (!tx_active(port))\n\t\t\tbreak;\n\t\tmsleep(10);\n\t}\n\tif (serial->disconnected)\n\t\treturn;\n\tbaud_rate = port->baud_rate;\n\tif (baud_rate == 0)\n\t\tbaud_rate = 50;\n\tmsleep(max(1, DIV_ROUND_UP(10000, baud_rate)));\n}", "target": 0}
{"code": "static int asymmetric_key_match_preparse(struct key_match_data *match_data)\n{\n\tmatch_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;\n\tmatch_data->cmp = asymmetric_key_cmp;\n\treturn 0;\n}", "target": 0}
{"code": "CephXAuthorizer *CephXTicketHandler::build_authorizer(uint64_t global_id) const\n{\n  CephXAuthorizer *a = new CephXAuthorizer(cct);\n  a->session_key = session_key;\n  a->nonce = ((uint64_t)rand() << 32) + rand();\n  __u8 authorizer_v = 1;\n  ::encode(authorizer_v, a->bl);\n  ::encode(global_id, a->bl);\n  ::encode(service_id, a->bl);\n  ::encode(ticket, a->bl);\n  a->base_bl = a->bl;\n  CephXAuthorize msg;\n  msg.nonce = a->nonce;\n  std::string error;\n  if (encode_encrypt(cct, msg, session_key, a->bl, error)) {\n    ldout(cct, 0) << \"failed to encrypt authorizer: \" << error << dendl;\n    delete a;\n    return 0;\n  }\n  return a;\n}", "target": 0}
{"code": "static void nfs4_close_prepare(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_closedata *calldata = data;\n\tstruct nfs4_state *state = calldata->state;\n\tint clear_rd, clear_wr, clear_rdwr;\n\tif (nfs_wait_on_sequence(calldata->arg.seqid, task) != 0)\n\t\treturn;\n\tclear_rd = clear_wr = clear_rdwr = 0;\n\tspin_lock(&state->owner->so_lock);\n\tif (state->n_rdwr == 0) {\n\t\tif (state->n_rdonly == 0) {\n\t\t\tclear_rd |= test_and_clear_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\t\tclear_rdwr |= test_and_clear_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t}\n\t\tif (state->n_wronly == 0) {\n\t\t\tclear_wr |= test_and_clear_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\t\tclear_rdwr |= test_and_clear_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t}\n\t}\n\tspin_unlock(&state->owner->so_lock);\n\tif (!clear_rd && !clear_wr && !clear_rdwr) {\n\t\ttask->tk_action = NULL;\n\t\treturn;\n\t}\n\tnfs_fattr_init(calldata->res.fattr);\n\tif (test_bit(NFS_O_RDONLY_STATE, &state->flags) != 0) {\n\t\ttask->tk_msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_DOWNGRADE];\n\t\tcalldata->arg.open_flags = FMODE_READ;\n\t} else if (test_bit(NFS_O_WRONLY_STATE, &state->flags) != 0) {\n\t\ttask->tk_msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_DOWNGRADE];\n\t\tcalldata->arg.open_flags = FMODE_WRITE;\n\t}\n\tcalldata->timestamp = jiffies;\n\trpc_call_start(task);\n}", "target": 1}
{"code": "smb2_flush(smb_request_t *sr)\n{\n\tsmb_ofile_t *of = NULL;\n\tuint16_t StructSize;\n\tuint16_t reserved1;\n\tuint32_t reserved2;\n\tsmb2fid_t smb2fid;\n\tuint32_t status;\n\tint rc = 0;\n\trc = smb_mbc_decodef(\n\t    &sr->smb_data, \"wwlqq\",\n\t    &StructSize,\t\t\n\t    &reserved1,\t\t\t\n\t    &reserved2,\t\t\t\n\t    &smb2fid.persistent,\t\n\t    &smb2fid.temporal);\t\t\n\tif (rc)\n\t\treturn (SDRC_ERROR);\n\tif (StructSize != 24)\n\t\treturn (SDRC_ERROR);\n\tstatus = smb2sr_lookup_fid(sr, &smb2fid);\n\tif (status) {\n\t\tsmb2sr_put_error(sr, status);\n\t\treturn (SDRC_SUCCESS);\n\t}\n\tof = sr->fid_ofile;\n\tif ((of->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)\n\t\t(void) smb_fsop_commit(sr, of->f_cr, of->f_node);\n\t(void) smb_mbc_encodef(\n\t    &sr->reply, \"wwl\",\n\t    4,\t\t\n\t    0); \t\t\n\treturn (SDRC_SUCCESS);\n}", "target": 1}
{"code": "Status CreateTempFileFloat(Env* env, float value, uint64 size,\n                           string* filename) {\n  const string dir = testing::TmpDir();\n  *filename = io::JoinPath(dir, strings::StrCat(\"file_\", value));\n  std::unique_ptr<WritableFile> file;\n  TF_RETURN_IF_ERROR(env->NewWritableFile(*filename, &file));\n  for (uint64 i = 0; i < size; ++i) {\n    StringPiece sp(static_cast<char*>(static_cast<void*>(&value)),\n                   sizeof(value));\n    TF_RETURN_IF_ERROR(file->Append(sp));\n  }\n  TF_RETURN_IF_ERROR(file->Close());\n  return Status::OK();\n}", "target": 0}
{"code": "static int cdc_ncm_bind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tint ret;\n\tif (cdc_ncm_select_altsetting(intf) != CDC_NCM_COMM_ALTSETTING_NCM)\n\t\treturn -ENODEV;\n\tret = cdc_ncm_bind_common(dev, intf, CDC_NCM_DATA_ALTSETTING_NCM, 0);\n\tusbnet_link_change(dev, 0, 0);\n\treturn ret;\n}", "target": 1}
{"code": "int quicklistPushHead(quicklist *quicklist, void *value, size_t sz) {\n    quicklistNode *orig_head = quicklist->head;\n    assert(sz < UINT32_MAX); \n    if (likely(\n            _quicklistNodeAllowInsert(quicklist->head, quicklist->fill, sz))) {\n        quicklist->head->zl =\n            ziplistPush(quicklist->head->zl, value, sz, ZIPLIST_HEAD);\n        quicklistNodeUpdateSz(quicklist->head);\n    } else {\n        quicklistNode *node = quicklistCreateNode();\n        node->zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);\n        quicklistNodeUpdateSz(node);\n        _quicklistInsertNodeBefore(quicklist, quicklist->head, node);\n    }\n    quicklist->count++;\n    quicklist->head->count++;\n    return (orig_head != quicklist->head);\n}", "target": 0}
{"code": "findoprnd(ITEM *ptr, int32 *pos)\n{\n\tcheck_stack_depth();\n\tif (ptr[*pos].type == VAL || ptr[*pos].type == VALTRUE)\n\t{\n\t\tptr[*pos].left = 0;\n\t\t(*pos)++;\n\t}\n\telse if (ptr[*pos].val == (int32) '!')\n\t{\n\t\tptr[*pos].left = 1;\n\t\t(*pos)++;\n\t\tfindoprnd(ptr, pos);\n\t}\n\telse\n\t{\n\t\tITEM\t   *curitem = &ptr[*pos];\n\t\tint32\t\ttmp = *pos;\n\t\t(*pos)++;\n\t\tfindoprnd(ptr, pos);\n\t\tcuritem->left = *pos - tmp;\n\t\tfindoprnd(ptr, pos);\n\t}\n}", "target": 0}
{"code": "static void unix_release_sock(struct sock *sk, int embrion)\n{\n\tstruct unix_sock *u = unix_sk(sk);\n\tstruct path path;\n\tstruct sock *skpair;\n\tstruct sk_buff *skb;\n\tint state;\n\tunix_remove_socket(sk);\n\tunix_state_lock(sk);\n\tsock_orphan(sk);\n\tsk->sk_shutdown = SHUTDOWN_MASK;\n\tpath\t     = u->path;\n\tu->path.dentry = NULL;\n\tu->path.mnt = NULL;\n\tstate = sk->sk_state;\n\tsk->sk_state = TCP_CLOSE;\n\tunix_state_unlock(sk);\n\twake_up_interruptible_all(&u->peer_wait);\n\tskpair = unix_peer(sk);\n\tif (skpair != NULL) {\n\t\tif (sk->sk_type == SOCK_STREAM || sk->sk_type == SOCK_SEQPACKET) {\n\t\t\tunix_state_lock(skpair);\n\t\t\tskpair->sk_shutdown = SHUTDOWN_MASK;\n\t\t\tif (!skb_queue_empty(&sk->sk_receive_queue) || embrion)\n\t\t\t\tskpair->sk_err = ECONNRESET;\n\t\t\tunix_state_unlock(skpair);\n\t\t\tskpair->sk_state_change(skpair);\n\t\t\tsk_wake_async(skpair, SOCK_WAKE_WAITD, POLL_HUP);\n\t\t}\n\t\tunix_dgram_peer_wake_disconnect(sk, skpair);\n\t\tsock_put(skpair); \n\t\tunix_peer(sk) = NULL;\n\t}\n\twhile ((skb = skb_dequeue(&sk->sk_receive_queue)) != NULL) {\n\t\tif (state == TCP_LISTEN)\n\t\t\tunix_release_sock(skb->sk, 1);\n\t\tUNIXCB(skb).consumed = skb->len;\n\t\tkfree_skb(skb);\n\t}\n\tif (path.dentry)\n\t\tpath_put(&path);\n\tsock_put(sk);\n\tif (unix_tot_inflight)\n\t\tunix_gc();\t\t\n}", "target": 0}
{"code": "R_API bool r_crbtree_insert(RRBTree *tree, void *data, RRBComparator cmp, void *user) {\n\tr_return_val_if_fail (tree && data && cmp, false);\n\tbool inserted = false;\n\tif (tree->root == NULL) {\n\t\ttree->root = _node_new (data, NULL);\n\t\tif (tree->root == NULL) {\n\t\t\treturn false;\n\t\t}\n\t\tinserted = true;\n\t\tgoto out_exit;\n\t}\n\tRRBNode head; \n\tmemset (&head, 0, sizeof (RRBNode));\n\tRRBNode *g = NULL, *parent = &head; \n\tRRBNode *p = NULL, *q = tree->root; \n\tint dir = 0, last = 0; \n\t_set_link (parent, q, 1);\n\tfor (;;) {\n\t\tif (!q) {\n\t\t\tq = _node_new (data, p);\n\t\t\tif (!q) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tp->link[dir] = q;\n\t\t\tinserted = true;\n\t\t} else if (IS_RED (q->link[0]) && IS_RED (q->link[1])) {\n\t\t\tq->red = 1;\n\t\t\tq->link[0]->red = 0;\n\t\t\tq->link[1]->red = 0;\n\t\t}\n\t\tif (IS_RED (q) && IS_RED (p)) {\n#if 0\n\t\t\tif (!parent) {\n\t\t\t\treturn false;\n\t\t\t}\n#endif\n\t\t\tint dir2 = parent->link[1] == g;\n\t\t\tif (q == p->link[last]) {\n\t\t\t\t_set_link (parent, _rot_once (g, !last), dir2);\n\t\t\t} else {\n\t\t\t\t_set_link (parent, _rot_twice (g, !last), dir2);\n\t\t\t}\n\t\t}\n\t\tif (inserted) {\n\t\t\tbreak;\n\t\t}\n\t\tlast = dir;\n\t\tdir = cmp (data, q->data, user) >= 0;\n\t\tif (g) {\n\t\t\tparent = g;\n\t\t}\n\t\tg = p;\n\t\tp = q;\n\t\tq = q->link[dir];\n\t}\n\ttree->root = head.link[1];\nout_exit:\n\ttree->root->red = 0;\n\ttree->root->parent = NULL;\n\tif (inserted) {\n\t\ttree->size++;\n\t}\n\treturn inserted;\n}", "target": 1}
{"code": "void shut_down(int code)\n{\n    int i;\n    int bytes_in = 0;\n    int bytes_out = 0;\n    in_shutdown = 1;\n    if (allow_cors) free_wildmats(allow_cors);\n    for (i = 0; http_namespaces[i]; i++) {\n        if (http_namespaces[i]->enabled && http_namespaces[i]->shutdown)\n            http_namespaces[i]->shutdown();\n    }\n    xmlCleanupParser();\n    proc_cleanup();\n    i = 0;\n    while (backend_cached && backend_cached[i]) {\n        proxy_downserver(backend_cached[i]);\n        free(backend_cached[i]->context);\n        free(backend_cached[i]);\n        i++;\n    }\n    if (backend_cached) free(backend_cached);\n    index_text_extractor_destroy();\n    annotatemore_close();\n    if (httpd_in) {\n        prot_NONBLOCK(httpd_in);\n        prot_fill(httpd_in);\n        bytes_in = prot_bytes_in(httpd_in);\n        prot_free(httpd_in);\n    }\n    if (httpd_out) {\n        prot_flush(httpd_out);\n        bytes_out = prot_bytes_out(httpd_out);\n        prot_free(httpd_out);\n        prometheus_decrement(CYRUS_HTTP_ACTIVE_CONNECTIONS);\n    }\n    else {\n        prometheus_decrement(CYRUS_HTTP_READY_LISTENERS);\n    }\n    prometheus_increment(code ? CYRUS_HTTP_SHUTDOWN_TOTAL_STATUS_ERROR\n                              : CYRUS_HTTP_SHUTDOWN_TOTAL_STATUS_OK);\n    if (protin) protgroup_free(protin);\n    if (config_auditlog)\n        syslog(LOG_NOTICE,\n               \"auditlog: traffic sessionid=<%s> bytes_in=<%d> bytes_out=<%d>\",\n               session_id(), bytes_in, bytes_out);\n#ifdef HAVE_SSL\n    tls_shutdown_serverengine();\n#endif\n    saslprops_free(&saslprops);\n    http2_done();\n    cyrus_done();\n    exit(code);\n}", "target": 0}
{"code": "static int masq_inet_event(struct notifier_block *this,\n\t\t\t   unsigned long event,\n\t\t\t   void *ptr)\n{\n\tstruct net_device *dev = ((struct in_ifaddr *)ptr)->ifa_dev->dev;\n\tstruct netdev_notifier_info info;\n\tnetdev_notifier_info_init(&info, dev);\n\treturn masq_device_event(this, event, &info);\n}", "target": 1}
{"code": "void XfccIntegrationTest::initialize() {\n  config_helper_.addConfigModifier(\n      [&](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n              hcm) -> void {\n        hcm.set_forward_client_cert_details(fcc_);\n        hcm.mutable_set_current_client_cert_details()->CopyFrom(sccd_);\n      });\n  config_helper_.addConfigModifier([&](envoy::config::bootstrap::v3::Bootstrap& bootstrap) -> void {\n    auto transport_socket =\n        bootstrap.mutable_static_resources()->mutable_clusters(0)->mutable_transport_socket();\n    envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext context;\n    auto* validation_context = context.mutable_common_tls_context()->mutable_validation_context();\n    validation_context->mutable_trusted_ca()->set_filename(\n        TestEnvironment::runfilesPath(\"test/config/integration/certs/upstreamcacert.pem\"));\n    validation_context->add_match_subject_alt_names()->set_suffix(\"lyft.com\");\n    transport_socket->set_name(\"envoy.transport_sockets.tls\");\n    transport_socket->mutable_typed_config()->PackFrom(context);\n  });\n  if (tls_) {\n    config_helper_.addSslConfig();\n  }\n  context_manager_ =\n      std::make_unique<Extensions::TransportSockets::Tls::ContextManagerImpl>(timeSystem());\n  client_tls_ssl_ctx_ = createClientSslContext(false);\n  client_mtls_ssl_ctx_ = createClientSslContext(true);\n  HttpIntegrationTest::initialize();\n}", "target": 1}
{"code": "static int snd_compr_allocate_buffer(struct snd_compr_stream *stream,\n\t\tstruct snd_compr_params *params)\n{\n\tunsigned int buffer_size;\n\tvoid *buffer;\n\tif (params->buffer.fragment_size == 0 ||\n\t    params->buffer.fragments > SIZE_MAX / params->buffer.fragment_size)\n\t\treturn -EINVAL;\n\tbuffer_size = params->buffer.fragment_size * params->buffer.fragments;\n\tif (stream->ops->copy) {\n\t\tbuffer = NULL;\n\t} else {\n\t\tbuffer = kmalloc(buffer_size, GFP_KERNEL);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\t}\n\tstream->runtime->fragment_size = params->buffer.fragment_size;\n\tstream->runtime->fragments = params->buffer.fragments;\n\tstream->runtime->buffer = buffer;\n\tstream->runtime->buffer_size = buffer_size;\n\treturn 0;\n}", "target": 0}
{"code": "subscription_update (subscriptionPtr subscription, guint flags)\n{\n\tUpdateRequest\t*request;\n\tguint64\t\tnow;\n\tguint\t\tcount, maxcount;\n\tif (!subscription)\n\t\treturn;\n\tif (subscription->updateJob)\n\t\treturn;\n\tdebug1 (DEBUG_UPDATE, \"Scheduling %s to be updated\", node_get_title (subscription->node));\n\tif (subscription_can_be_updated (subscription)) {\n\t\tnow = g_get_real_time();\n\t\tsubscription_reset_update_counter (subscription, &now);\n\t\trequest = update_request_new (\n\t\t\tsubscription_get_source (subscription),\n\t\t\tsubscription->updateState,\n\t\t\tsubscription->updateOptions\n\t\t);\n\t\tupdate_request_allow_commands (request, TRUE);\n\t\tif (subscription_get_filter (subscription))\n\t\t\trequest->filtercmd = g_strdup (subscription_get_filter (subscription));\n\t\tif (SUBSCRIPTION_TYPE (subscription)->prepare_update_request (subscription, request))\n\t\t\tsubscription->updateJob = update_execute_request (subscription, request, subscription_process_update_result, subscription, flags);\n\t\telse\n\t\t\tg_object_unref (request);\n\t\tupdate_jobs_get_count (&count, &maxcount);\n\t\tif (count > 1)\n\t\t\tliferea_shell_set_status_bar (_(\"Updating (%d / %d) ...\"), maxcount - count, maxcount);\n\t\telse\n\t\t\tliferea_shell_set_status_bar (_(\"Updating '%s'...\"), node_get_title (subscription->node));\n\t}\n}", "target": 0}
{"code": "static int can_open_cached(struct nfs4_state *state, int mode)\n{\n\tint ret = 0;\n\tswitch (mode & (FMODE_READ|FMODE_WRITE|O_EXCL)) {\n\t\tcase FMODE_READ:\n\t\t\tret |= test_bit(NFS_O_RDONLY_STATE, &state->flags) != 0;\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tret |= test_bit(NFS_O_WRONLY_STATE, &state->flags) != 0;\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tret |= test_bit(NFS_O_RDWR_STATE, &state->flags) != 0;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static int __init ipgre_init(void)\n{\n\tint err;\n\tprintk(KERN_INFO \"GRE over IPv4 tunneling driver\\n\");\n\tif (inet_add_protocol(&ipgre_protocol, IPPROTO_GRE) < 0) {\n\t\tprintk(KERN_INFO \"ipgre init: can't add protocol\\n\");\n\t\treturn -EAGAIN;\n\t}\n\terr = register_pernet_device(&ipgre_net_ops);\n\tif (err < 0)\n\t\tgoto gen_device_failed;\n\terr = rtnl_link_register(&ipgre_link_ops);\n\tif (err < 0)\n\t\tgoto rtnl_link_failed;\n\terr = rtnl_link_register(&ipgre_tap_ops);\n\tif (err < 0)\n\t\tgoto tap_ops_failed;\nout:\n\treturn err;\ntap_ops_failed:\n\trtnl_link_unregister(&ipgre_link_ops);\nrtnl_link_failed:\n\tunregister_pernet_device(&ipgre_net_ops);\ngen_device_failed:\n\tinet_del_protocol(&ipgre_protocol, IPPROTO_GRE);\n\tgoto out;\n}", "target": 1}
{"code": "test_all_FFs(void **state)\n{\n    (void) state;\n    const char *e = Tss2_RC_Decode(0xFFFFFFFF);\n    assert_string_equal(e, \"255:0xFFFFFF\");\n}", "target": 0}
{"code": "void hrandfieldCommand(client *c) {\n    long l;\n    int withvalues = 0;\n    robj *hash;\n    listpackEntry ele;\n    if (c->argc >= 3) {\n        if (getRangeLongFromObjectOrReply(c,c->argv[2],-LONG_MAX,LONG_MAX,&l,NULL) != C_OK) return;\n        if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"withvalues\"))) {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return;\n        } else if (c->argc == 4) {\n            withvalues = 1;\n            if (l < -LONG_MAX/2 || l > LONG_MAX/2) {\n                addReplyError(c,\"value is out of range\");\n                return;\n            }\n        }\n        hrandfieldWithCountCommand(c, l, withvalues);\n        return;\n    }\n    if ((hash = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp]))== NULL ||\n        checkType(c,hash,OBJ_HASH)) {\n        return;\n    }\n    hashTypeRandomElement(hash,hashTypeLength(hash),&ele,NULL);\n    hashReplyFromListpackEntry(c, &ele);\n}", "target": 0}
{"code": "static void php_mb_regex_free_cache(php_mb_regex_t **pre) \n{\n\tonig_free(*pre);\n}", "target": 1}
{"code": "static int valid_entry_name(const char *filename)\n{\n\treturn *filename != '\\0' &&\n\t\tstrchr(filename, '/') == NULL &&\n\t\t(*filename != '.' ||\n\t\t (strcmp(filename, \".\") != 0 &&\n\t\t  strcmp(filename, \"..\") != 0 &&\n\t\t  strcmp(filename, DOT_GIT) != 0));\n}", "target": 1}
{"code": "static inline int copy_pmd_range(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\tpud_t *dst_pud, pud_t *src_pud, struct vm_area_struct *vma,\n\t\tunsigned long addr, unsigned long end)\n{\n\tpmd_t *src_pmd, *dst_pmd;\n\tunsigned long next;\n\tdst_pmd = pmd_alloc(dst_mm, dst_pud, addr);\n\tif (!dst_pmd)\n\t\treturn -ENOMEM;\n\tsrc_pmd = pmd_offset(src_pud, addr);\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (pmd_none_or_clear_bad(src_pmd))\n\t\t\tcontinue;\n\t\tif (copy_pte_range(dst_mm, src_mm, dst_pmd, src_pmd,\n\t\t\t\t\t\tvma, addr, next))\n\t\t\treturn -ENOMEM;\n\t} while (dst_pmd++, src_pmd++, addr = next, addr != end);\n\treturn 0;\n}", "target": 0}
{"code": "static BOOL autodetect_recv_bandwidth_measure_results(rdpRdp* rdp, wStream* s,\n                                                      AUTODETECT_RSP_PDU* autodetectRspPdu)\n{\n\tBOOL success = TRUE;\n\tif (autodetectRspPdu->headerLength != 0x0E)\n\t\treturn FALSE;\n\tWLog_VRB(AUTODETECT_TAG, \"received Bandwidth Measure Results PDU\");\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn -1;\n\tStream_Read_UINT32(s, rdp->autodetect->bandwidthMeasureTimeDelta); \n\tStream_Read_UINT32(s, rdp->autodetect->bandwidthMeasureByteCount); \n\tif (rdp->autodetect->bandwidthMeasureTimeDelta > 0)\n\t\trdp->autodetect->netCharBandwidth = rdp->autodetect->bandwidthMeasureByteCount * 8 /\n\t\t                                    rdp->autodetect->bandwidthMeasureTimeDelta;\n\telse\n\t\trdp->autodetect->netCharBandwidth = 0;\n\tIFCALLRET(rdp->autodetect->BandwidthMeasureResults, success, rdp->context,\n\t          autodetectRspPdu->sequenceNumber);\n\treturn success;\n}", "target": 0}
{"code": "GIT_INLINE(bool) verify_dotgit_ntfs(git_repository *repo, const char *path, size_t len)\n{\n\tgit_buf *reserved = git_repository__reserved_names_win32;\n\tsize_t reserved_len = git_repository__reserved_names_win32_len;\n\tsize_t start = 0, i;\n\tif (repo)\n\t\tgit_repository__reserved_names(&reserved, &reserved_len, repo, true);\n\tfor (i = 0; i < reserved_len; i++) {\n\t\tgit_buf *r = &reserved[i];\n\t\tif (len >= r->size &&\n\t\t\tstrncasecmp(path, r->ptr, r->size) == 0) {\n\t\t\tstart = r->size;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!start)\n\t\treturn true;\n\tif (path[start] == '\\\\')\n\t\treturn false;\n\tfor (i = start; i < len; i++) {\n\t\tif (path[i] != ' ' && path[i] != '.')\n\t\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "static void dns_resolver_describe(const struct key *key, struct seq_file *m)\n{\n\tseq_puts(m, key->description);\n\tif (key_is_instantiated(key)) {\n\t\tint err = PTR_ERR(key->payload.data[dns_key_error]);\n\t\tif (err)\n\t\t\tseq_printf(m, \": %d\", err);\n\t\telse\n\t\t\tseq_printf(m, \": %u\", key->datalen);\n\t}\n}", "target": 1}
{"code": "static int ccid3_hc_tx_getsockopt(struct sock *sk, const int optname, int len,\n\t\t\t\t  u32 __user *optval, int __user *optlen)\n{\n\tconst struct ccid3_hc_tx_sock *hc = ccid3_hc_tx_sk(sk);\n\tstruct tfrc_tx_info tfrc;\n\tconst void *val;\n\tswitch (optname) {\n\tcase DCCP_SOCKOPT_CCID_TX_INFO:\n\t\tif (len < sizeof(tfrc))\n\t\t\treturn -EINVAL;\n\t\tmemset(&tfrc, 0, sizeof(tfrc));\n\t\ttfrc.tfrctx_x\t   = hc->tx_x;\n\t\ttfrc.tfrctx_x_recv = hc->tx_x_recv;\n\t\ttfrc.tfrctx_x_calc = hc->tx_x_calc;\n\t\ttfrc.tfrctx_rtt\t   = hc->tx_rtt;\n\t\ttfrc.tfrctx_p\t   = hc->tx_p;\n\t\ttfrc.tfrctx_rto\t   = hc->tx_t_rto;\n\t\ttfrc.tfrctx_ipi\t   = hc->tx_t_ipi;\n\t\tlen = sizeof(tfrc);\n\t\tval = &tfrc;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\tif (put_user(len, optlen) || copy_to_user(optval, val, len))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 0}
{"code": "TEE_Result syscall_cryp_state_copy(unsigned long dst, unsigned long src)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs_dst;\n\tstruct tee_cryp_state *cs_src;\n\tstruct tee_ta_session *sess;\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(dst), &cs_dst);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(src), &cs_src);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif (cs_dst->algo != cs_src->algo || cs_dst->mode != cs_src->mode)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\tswitch (TEE_ALG_GET_CLASS(cs_src->algo)) {\n\tcase TEE_OPERATION_CIPHER:\n\t\tcrypto_cipher_copy_state(cs_dst->ctx, cs_src->ctx,\n\t\t\t\t\t cs_src->algo);\n\t\tbreak;\n\tcase TEE_OPERATION_AE:\n\t\tcrypto_authenc_copy_state(cs_dst->ctx, cs_src->ctx,\n\t\t\t\t\t  cs_src->algo);\n\t\tbreak;\n\tcase TEE_OPERATION_DIGEST:\n\t\tcrypto_hash_copy_state(cs_dst->ctx, cs_src->ctx, cs_src->algo);\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\tcrypto_mac_copy_state(cs_dst->ctx, cs_src->ctx, cs_src->algo);\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_BAD_STATE;\n\t}\n\tcs_dst->state = cs_src->state;\n\treturn TEE_SUCCESS;\n}", "target": 0}
{"code": "  Status FillCollectiveParams(CollectiveParams* col_params,\n                              CollectiveType collective_type,\n                              const Tensor& group_size, const Tensor& group_key,\n                              const Tensor& instance_key) {\n    if (group_size.dims() > 0) {\n      return errors::Internal(\"Unexpected dimensions on input group_size, got \",\n                              group_size.shape().DebugString());\n    }\n    if (group_key.dims() > 0) {\n      return errors::Internal(\"Unexpected dimensions on input group_key, got \",\n                              group_key.shape().DebugString());\n    }\n    if (instance_key.dims() > 0) {\n      return errors::Internal(\n          \"Unexpected dimensions on input instance_key, got \",\n          instance_key.shape().DebugString());\n    }\n    col_params->name = name_;\n    col_params->group.device_type = device_type_;\n    col_params->group.group_size = group_size.unaligned_flat<int32>()(0);\n    if (col_params->group.group_size <= 0) {\n      return errors::InvalidArgument(\n          \"group_size must be positive integer but got \",\n          col_params->group.group_size);\n    }\n    col_params->group.group_key = group_key.unaligned_flat<int32>()(0);\n    col_params->instance.type = collective_type;\n    col_params->instance.instance_key = instance_key.unaligned_flat<int32>()(0);\n    col_params->instance.data_type = data_type_;\n    col_params->instance.impl_details.communication_hint = communication_hint_;\n    col_params->instance.impl_details.timeout_seconds = timeout_seconds_;\n    return Status::OK();\n  }", "target": 1}
{"code": "set_cs_start(const char* line)\n{\n    static int cs_start_set = 0;\n    char *p, *q, *r;\n    if ((p = strstr(line, \"string currentfile\"))\n        && strstr(line, \"readstring\")) {\n        for (q = p; q != line && q[-1] != '/'; --q)\n            ;\n        if (q != line) {\n            for (r = q; r != p && !isspace((unsigned char) *r) && *r != '{'; ++r)\n                ;\n            if (cs_start_set)\n                free((char*) cs_start);\n            cs_start = p = malloc(r - q + 1);\n            memcpy(p, q, r - q);\n            p[r - q] = 0;\n            cs_start_set = 1;\n        }\n    }\n}", "target": 0}
{"code": "bool LinksToDirs(const wchar *SrcName,const wchar *SkipPart,std::wstring &LastChecked)\n{\n  wchar Path[NM];\n  if (wcslen(SrcName)>=ASIZE(Path))\n    return false;  \n  wcsncpyz(Path,SrcName,ASIZE(Path));\n  size_t SkipLength=wcslen(SkipPart);\n  if (SkipLength>0 && wcsncmp(Path,SkipPart,SkipLength)!=0)\n    SkipLength=0; \n  for (uint I=0;Path[I]!=0 && I<LastChecked.size() && Path[I]==LastChecked[I];I++)\n    if (IsPathDiv(Path[I]) && I>SkipLength)\n      SkipLength=I;\n  wchar *Name=Path;\n  if (SkipLength>0)\n  {\n    Name+=SkipLength;\n    while (IsPathDiv(*Name))\n      Name++;\n  }\n  for (wchar *s=Path+wcslen(Path)-1;s>Name;s--)\n    if (IsPathDiv(*s))\n    {\n      *s=0;\n      FindData FD;\n      if (FindFile::FastFind(Path,&FD,true) && FD.IsLink)\n#ifdef _WIN_ALL\n        if (!DelDir(Path))\n#else\n        if (!DelFile(Path))\n#endif\n          return false; \n    }\n  LastChecked=SrcName;\n  return true;\n}", "target": 0}
{"code": "pci_emul_add_msicap(struct pci_vdev *dev, int msgnum)\n{\n\tstruct msicap msicap;\n\tpci_populate_msicap(&msicap, msgnum, 0);\n\treturn pci_emul_add_capability(dev, (u_char *)&msicap, sizeof(msicap));\n}", "target": 1}
{"code": "cdf_read_sector(const cdf_info_t *info, void *buf, size_t offs, size_t len,\n    const cdf_header_t *h, cdf_secid_t id)\n{\n\tassert((size_t)CDF_SEC_SIZE(h) == len);\n\treturn cdf_read(info, (off_t)CDF_SEC_POS(h, id),\n\t    ((char *)buf) + offs, len);\n}", "target": 1}
{"code": "int install_process_keyring_to_cred(struct cred *new)\n{\n\tstruct key *keyring;\n\tif (new->process_keyring)\n\t\treturn -EEXIST;\n\tkeyring = keyring_alloc(\"_pid\", new->uid, new->gid, new,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN,\n\t\t\t\tNULL, NULL);\n\tif (IS_ERR(keyring))\n\t\treturn PTR_ERR(keyring);\n\tnew->process_keyring = keyring;\n\treturn 0;\n}", "target": 1}
{"code": "  StatusOr<std::vector<int64_t>> GetStride(XlaOpKernelContext* ctx) {\n    if (ctx->num_inputs() == 1) {\n      return stride_;\n    }\n    const TensorShape stride_shape = ctx->InputShape(2);\n    if (!TensorShapeUtils::IsVector(stride_shape)) {\n      return errors::InvalidArgument(\"stride must be a vector, not shape \",\n                                     stride_shape.DebugString());\n    }\n    if (stride_shape.num_elements() != num_dims()) {\n      return errors::InvalidArgument(\n          \"Sliding window stride field must \"\n          \"specify \",\n          num_dims(), \" dimensions\");\n    }\n    std::vector<int64_t> stride;\n    auto status = ctx->ConstantInputAsIntVector(2, &stride);\n    if (!status.ok()) {\n      return status;\n    }\n    return stride;\n  }", "target": 1}
{"code": "static void esp_do_nodma(ESPState *s)\n{\n    int to_device = ((s->rregs[ESP_RSTAT] & 7) == STAT_DO);\n    uint32_t cmdlen;\n    int len;\n    if (s->do_cmd) {\n        cmdlen = fifo8_num_used(&s->cmdfifo);\n        trace_esp_handle_ti_cmd(cmdlen);\n        s->ti_size = 0;\n        if ((s->rregs[ESP_RSTAT] & 7) == STAT_CD) {\n            if (s->cmdfifo_cdb_offset == fifo8_num_used(&s->cmdfifo)) {\n                return;\n            }\n            s->do_cmd = 0;\n            do_cmd(s);\n        } else {\n            s->cmdfifo_cdb_offset = fifo8_num_used(&s->cmdfifo);\n            s->rregs[ESP_RSTAT] = STAT_TC | STAT_CD;\n            s->rregs[ESP_RSEQ] = SEQ_CD;\n            s->rregs[ESP_RINTR] |= INTR_BS;\n            esp_raise_irq(s);\n        }\n        return;\n    }\n    if (!s->current_req) {\n        return;\n    }\n    if (s->async_len == 0) {\n        return;\n    }\n    if (to_device) {\n        len = MIN(fifo8_num_used(&s->fifo), ESP_FIFO_SZ);\n        esp_fifo_pop_buf(&s->fifo, s->async_buf, len);\n        s->async_buf += len;\n        s->async_len -= len;\n        s->ti_size += len;\n    } else {\n        if (fifo8_is_empty(&s->fifo)) {\n            fifo8_push(&s->fifo, s->async_buf[0]);\n            s->async_buf++;\n            s->async_len--;\n            s->ti_size--;\n        }\n    }\n    if (s->async_len == 0) {\n        scsi_req_continue(s->current_req);\n        return;\n    }\n    s->rregs[ESP_RINTR] |= INTR_BS;\n    esp_raise_irq(s);\n}", "target": 1}
{"code": "static bool blk_kick_flush(struct request_queue *q, struct blk_flush_queue *fq)\n{\n\tstruct list_head *pending = &fq->flush_queue[fq->flush_pending_idx];\n\tstruct request *first_rq =\n\t\tlist_first_entry(pending, struct request, flush.list);\n\tstruct request *flush_rq = fq->flush_rq;\n\tif (fq->flush_pending_idx != fq->flush_running_idx || list_empty(pending))\n\t\treturn false;\n\tif (!list_empty(&fq->flush_data_in_flight) &&\n\t    time_before(jiffies,\n\t\t\tfq->flush_pending_since + FLUSH_PENDING_TIMEOUT))\n\t\treturn false;\n\tfq->flush_pending_idx ^= 1;\n\tblk_rq_init(q, flush_rq);\n\tif (q->mq_ops) {\n\t\tflush_rq->mq_ctx = first_rq->mq_ctx;\n\t\tflush_rq->tag = first_rq->tag;\n\t}\n\tflush_rq->cmd_type = REQ_TYPE_FS;\n\tflush_rq->cmd_flags = WRITE_FLUSH | REQ_FLUSH_SEQ;\n\tflush_rq->rq_disk = first_rq->rq_disk;\n\tflush_rq->end_io = flush_end_io;\n\treturn blk_flush_queue_rq(flush_rq, false);\n}", "target": 1}
{"code": "containsNonAlphaNumDash(const LString &s) {\n\tconst LString::Part *part = s.start;\n\twhile (part != NULL) {\n\t\tfor (unsigned int i = 0; i < part->size; i++) {\n\t\t\tconst char start = part->data[i];\n\t\t\tif (start != '-' && !isAlphaNum(start)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tpart = part->next;\n\t}\n\treturn false;\n}", "target": 0}
{"code": "static int __init dev_prepare_static_identity_mapping(struct device *dev, int hw)\n{\n\tint ret;\n\tif (!iommu_should_identity_map(dev, 1))\n\t\treturn 0;\n\tret = domain_add_dev_info(si_domain, dev);\n\tif (!ret)\n\t\tdev_info(dev, \"%s identity mapping\\n\",\n\t\t\t hw ? \"Hardware\" : \"Software\");\n\telse if (ret == -ENODEV)\n\t\tret = 0;\n\treturn ret;\n}", "target": 0}
{"code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  TfLiteType output_type = GetOutput(context, node, kOutputTensor)->type;\n  switch (output_type) {  \n    case kTfLiteFloat32:\n      EvalUnquantized<float>(context, node);\n      break;\n    case kTfLiteInt32:\n      EvalUnquantized<int32_t>(context, node);\n      break;\n    case kTfLiteUInt8:\n      EvalQuantizedUInt8(context, node);\n      break;\n    case kTfLiteInt8:\n      EvalUnquantized<int8_t>(context, node);\n      break;\n    case kTfLiteInt64:\n      EvalUnquantized<int64_t>(context, node);\n      break;\n    default:\n      TF_LITE_KERNEL_LOG(\n          context, \"Op Concatenation does not currently support Type '%s'.\",\n          TfLiteTypeGetName(output_type));\n      return kTfLiteError;\n  }\n  return kTfLiteOk;\n}", "target": 1}
{"code": "static int may_create_in_sticky(struct dentry * const dir,\n\t\t\t\tstruct inode * const inode)\n{\n\tif ((!sysctl_protected_fifos && S_ISFIFO(inode->i_mode)) ||\n\t    (!sysctl_protected_regular && S_ISREG(inode->i_mode)) ||\n\t    likely(!(dir->d_inode->i_mode & S_ISVTX)) ||\n\t    uid_eq(inode->i_uid, dir->d_inode->i_uid) ||\n\t    uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn 0;\n\tif (likely(dir->d_inode->i_mode & 0002) ||\n\t    (dir->d_inode->i_mode & 0020 &&\n\t     ((sysctl_protected_fifos >= 2 && S_ISFIFO(inode->i_mode)) ||\n\t      (sysctl_protected_regular >= 2 && S_ISREG(inode->i_mode))))) {\n\t\tconst char *operation = S_ISFIFO(inode->i_mode) ?\n\t\t\t\t\t\"sticky_create_fifo\" :\n\t\t\t\t\t\"sticky_create_regular\";\n\t\taudit_log_path_denied(AUDIT_ANOM_CREAT, operation);\n\t\treturn -EACCES;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "setup_arch (char **cmdline_p)\n{\n\tunw_init();\n\tia64_patch_vtop((u64) __start___vtop_patchlist, (u64) __end___vtop_patchlist);\n\t*cmdline_p = __va(ia64_boot_param->command_line);\n\tstrlcpy(boot_command_line, *cmdline_p, COMMAND_LINE_SIZE);\n\tefi_init();\n\tio_port_init();\n#ifdef CONFIG_IA64_GENERIC\n\tmachvec_init_from_cmdline(*cmdline_p);\n#endif\n\tparse_early_param();\n\tif (early_console_setup(*cmdline_p) == 0)\n\t\tmark_bsp_online();\n#ifdef CONFIG_ACPI\n\tacpi_table_init();\n# ifdef CONFIG_ACPI_NUMA\n\tacpi_numa_init();\n\tper_cpu_scan_finalize((cpus_weight(early_cpu_possible_map) == 0 ?\n\t\t32 : cpus_weight(early_cpu_possible_map)), additional_cpus);\n# endif\n#else\n# ifdef CONFIG_SMP\n\tsmp_build_cpu_map();\t\n# endif\n#endif \n\tfind_memory();\n\tia64_sal_init(__va(efi.sal_systab));\n#ifdef CONFIG_ITANIUM\n\tia64_patch_rse((u64) __start___rse_patchlist, (u64) __end___rse_patchlist);\n#else\n\t{\n\t\tu64 num_phys_stacked;\n\t\tif (ia64_pal_rse_info(&num_phys_stacked, 0) == 0 && num_phys_stacked > 96)\n\t\t\tia64_patch_rse((u64) __start___rse_patchlist, (u64) __end___rse_patchlist);\n\t}\n#endif\n#ifdef CONFIG_SMP\n\tcpu_physical_id(0) = hard_smp_processor_id();\n#endif\n\tcpu_init();\t\n\tmmu_context_init();\t\n\tcheck_sal_cache_flush();\n#ifdef CONFIG_ACPI\n\tacpi_boot_init();\n#endif\n#ifdef CONFIG_VT\n\tif (!conswitchp) {\n# if defined(CONFIG_DUMMY_CONSOLE)\n\t\tconswitchp = &dummy_con;\n# endif\n# if defined(CONFIG_VGA_CONSOLE)\n\t\tif (efi_mem_type(0xA0000) != EFI_CONVENTIONAL_MEMORY)\n\t\t\tconswitchp = &vga_con;\n# endif\n\t}\n#endif\n\tif (!nomca)\n\t\tia64_mca_init();\n\tplatform_setup(cmdline_p);\n\tpaging_init();\n}", "target": 0}
{"code": "fb_mmap(struct file *file, struct vm_area_struct * vma)\n{\n\tstruct fb_info *info = file_fb_info(file);\n\tstruct fb_ops *fb;\n\tunsigned long off;\n\tunsigned long start;\n\tu32 len;\n\tif (!info)\n\t\treturn -ENODEV;\n\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT))\n\t\treturn -EINVAL;\n\toff = vma->vm_pgoff << PAGE_SHIFT;\n\tfb = info->fbops;\n\tif (!fb)\n\t\treturn -ENODEV;\n\tmutex_lock(&info->mm_lock);\n\tif (fb->fb_mmap) {\n\t\tint res;\n\t\tres = fb->fb_mmap(info, vma);\n\t\tmutex_unlock(&info->mm_lock);\n\t\treturn res;\n\t}\n\tstart = info->fix.smem_start;\n\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.smem_len);\n\tif (off >= len) {\n\t\toff -= len;\n\t\tif (info->var.accel_flags) {\n\t\t\tmutex_unlock(&info->mm_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tstart = info->fix.mmio_start;\n\t\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.mmio_len);\n\t}\n\tmutex_unlock(&info->mm_lock);\n\tstart &= PAGE_MASK;\n\tif ((vma->vm_end - vma->vm_start + off) > len)\n\t\treturn -EINVAL;\n\toff += start;\n\tvma->vm_pgoff = off >> PAGE_SHIFT;\n\tvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\n\tfb_pgprotect(file, vma, off);\n\tif (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,\n\t\t\t     vma->vm_end - vma->vm_start, vma->vm_page_prot))\n\t\treturn -EAGAIN;\n\treturn 0;\n}", "target": 1}
{"code": "hermesBuiltinApply(void *, Runtime *runtime, NativeArgs args) {\n  GCScopeMarkerRAII marker{runtime};\n  Handle<Callable> fn = args.dyncastArg<Callable>(0);\n  if (LLVM_UNLIKELY(!fn)) {\n    return runtime->raiseTypeErrorForValue(\n        args.getArgHandle(0), \" is not a function\");\n  }\n  Handle<JSArray> argArray = args.dyncastArg<JSArray>(1);\n  if (LLVM_UNLIKELY(!argArray)) {\n    return runtime->raiseTypeError(\"args must be an array\");\n  }\n  uint32_t len = JSArray::getLength(*argArray);\n  bool isConstructor = args.getArgCount() == 2;\n  MutableHandle<> thisVal{runtime};\n  if (isConstructor) {\n    auto thisValRes = Callable::createThisForConstruct(fn, runtime);\n    if (LLVM_UNLIKELY(thisValRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    thisVal = *thisValRes;\n  } else {\n    thisVal = args.getArg(2);\n  }\n  ScopedNativeCallFrame newFrame{\n      runtime, len, *fn, isConstructor, thisVal.getHermesValue()};\n  if (LLVM_UNLIKELY(newFrame.overflowed()))\n    return runtime->raiseStackOverflow(Runtime::StackOverflowKind::NativeStack);\n  for (uint32_t i = 0; i < len; ++i) {\n    newFrame->getArgRef(i) = argArray->at(runtime, i);\n  }\n  return isConstructor ? Callable::construct(fn, runtime, thisVal)\n                       : Callable::call(fn, runtime);\n}", "target": 0}
{"code": "teardown_digests(cms_context *ctx)\n{\n\tstruct digest *digests = ctx->digests;\n\tif (!digests)\n\t\treturn;\n\tfor (int i = 0; i < n_digest_params; i++) {\n\t\tif (digests[i].pk11ctx) {\n\t\t\tPK11_Finalize(digests[i].pk11ctx);\n\t\t\tPK11_DestroyContext(digests[i].pk11ctx, PR_TRUE);\n\t\t}\n\t\tif (digests[i].pe_digest) {\n\t\t\tdigests[i].pe_digest = NULL;\n\t\t}\n\t}\n\tPORT_Free(digests);\n\tctx->digests = NULL;\n}", "target": 0}
{"code": "static int do_fault(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long address, pte_t *page_table, pmd_t *pmd,\n\t\tunsigned int flags, pte_t orig_pte)\n{\n\tpgoff_t pgoff = (((address & PAGE_MASK)\n\t\t\t- vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\tpte_unmap(page_table);\n\tif (!vma->vm_ops->fault)\n\t\treturn VM_FAULT_SIGBUS;\n\tif (!(flags & FAULT_FLAG_WRITE))\n\t\treturn do_read_fault(mm, vma, address, pmd, pgoff, flags,\n\t\t\t\torig_pte);\n\tif (!(vma->vm_flags & VM_SHARED))\n\t\treturn do_cow_fault(mm, vma, address, pmd, pgoff, flags,\n\t\t\t\torig_pte);\n\treturn do_shared_fault(mm, vma, address, pmd, pgoff, flags, orig_pte);\n}", "target": 0}
{"code": "PrimitiveStatus TrustedPrimitives::UntrustedCall(uint64_t untrusted_selector,\n                                                 MessageWriter *input,\n                                                 MessageReader *output) {\n  int ret;\n  UntrustedCacheMalloc *untrusted_cache = UntrustedCacheMalloc::Instance();\n  SgxParams *const sgx_params =\n      reinterpret_cast<SgxParams *>(untrusted_cache->Malloc(sizeof(SgxParams)));\n  if (!TrustedPrimitives::IsOutsideEnclave(sgx_params, sizeof(SgxParams))) {\n    TrustedPrimitives::BestEffortAbort(\n        \"UntrustedCall: sgx_param should be in untrusted memory\");\n  }\n  Cleanup clean_up(\n      [sgx_params, untrusted_cache] { untrusted_cache->Free(sgx_params); });\n  sgx_params->input_size = 0;\n  sgx_params->input = nullptr;\n  if (input) {\n    sgx_params->input_size = input->MessageSize();\n    if (sgx_params->input_size > 0) {\n      sgx_params->input = untrusted_cache->Malloc(sgx_params->input_size);\n      const void *input_pointer = sgx_params->input;\n      uint64_t input_size = sgx_params->input_size;\n      if (!TrustedPrimitives::IsOutsideEnclave(input_pointer, input_size)) {\n        TrustedPrimitives::BestEffortAbort(\n            \"UntrustedCall: sgx_param input should be in untrusted memory\");\n      }\n      input->Serialize(const_cast<void *>(input_pointer));\n    }\n  }\n  sgx_params->output_size = 0;\n  sgx_params->output = nullptr;\n  CHECK_OCALL(\n      ocall_dispatch_untrusted_call(&ret, untrusted_selector, sgx_params));\n  if (sgx_params->input) {\n    untrusted_cache->Free(const_cast<void *>(sgx_params->input));\n  }\n  const void *output_pointer = sgx_params->output;\n  uint64_t output_size = sgx_params->output_size;\n  if (!TrustedPrimitives::IsOutsideEnclave(output_pointer, output_size)) {\n    TrustedPrimitives::BestEffortAbort(\n        \"UntrustedCall: sgx_param output should be in untrusted memory\");\n  }\n  if (sgx_params->output) {\n    output->Deserialize(output_pointer, output_size);\n    TrustedPrimitives::UntrustedLocalFree(sgx_params->output);\n  }\n  return PrimitiveStatus::OkStatus();\n}", "target": 0}
{"code": "static void sunkbd_reinit(struct work_struct *work)\n{\n\tstruct sunkbd *sunkbd = container_of(work, struct sunkbd, tq);\n\twait_event_interruptible_timeout(sunkbd->wait, sunkbd->reset >= 0, HZ);\n\tserio_write(sunkbd->serio, SUNKBD_CMD_SETLED);\n\tserio_write(sunkbd->serio,\n\t\t(!!test_bit(LED_CAPSL,   sunkbd->dev->led) << 3) |\n\t\t(!!test_bit(LED_SCROLLL, sunkbd->dev->led) << 2) |\n\t\t(!!test_bit(LED_COMPOSE, sunkbd->dev->led) << 1) |\n\t\t !!test_bit(LED_NUML,    sunkbd->dev->led));\n\tserio_write(sunkbd->serio,\n\t\tSUNKBD_CMD_NOCLICK - !!test_bit(SND_CLICK, sunkbd->dev->snd));\n\tserio_write(sunkbd->serio,\n\t\tSUNKBD_CMD_BELLOFF - !!test_bit(SND_BELL, sunkbd->dev->snd));\n}", "target": 1}
{"code": "NAN_METHOD(DetectCharacterEncoding) {\n\tNan::HandleScope scope;\n\tv8::Local<v8::Object> inputBuffer = info[0]->ToObject();\n\tUCharsetDetector *charsetDetector;\n\tconst UCharsetMatch *charsetMatch;\n\tUErrorCode errorCode = U_ZERO_ERROR;\n\tcharsetDetector = ucsdet_open(&errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to open ICU charset detector.\");\n\t\treturn;\n\t}\n\tucsdet_setText(\n\t\tcharsetDetector,\n\t\tnode::Buffer::Data(inputBuffer),\n\t\tnode::Buffer::Length(inputBuffer),\n\t\t&errorCode\n\t);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to set ICU charset detectors text.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tcharsetMatch = ucsdet_detect(charsetDetector, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to detect charset.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tif(charsetMatch == NULL) {\n\t\tinfo.GetReturnValue().Set(Nan::Null());\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tconst char *charsetName = ucsdet_getName(charsetMatch, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get name from charset match.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tint32_t confidence = ucsdet_getConfidence(charsetMatch, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get confidence from charset match.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tv8::Local<v8::Object> obj = Nan::New<v8::Object>();\n\tobj->Set(Nan::New<v8::String>(\"encoding\").ToLocalChecked(), Nan::New<v8::String>(charsetName).ToLocalChecked());\n\tobj->Set(Nan::New<v8::String>(\"confidence\").ToLocalChecked(), Nan::New<v8::Number>(confidence));\n\tinfo.GetReturnValue().Set(obj);\n\tucsdet_close(charsetDetector);\n}", "target": 0}
{"code": "int razer_get_usb_response(struct usb_device *usb_dev, uint report_index, struct razer_report* request_report, uint response_index, struct razer_report* response_report, ulong wait_min, ulong wait_max)\n{\n    uint request = HID_REQ_GET_REPORT; \n    uint request_type = USB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_IN; \n    uint value = 0x300;\n    uint size = RAZER_USB_REPORT_LEN; \n    int len;\n    int retval;\n    int result = 0;\n    char *buf;\n    buf = kzalloc(sizeof(struct razer_report), GFP_KERNEL);\n    if (buf == NULL)\n        return -ENOMEM;\n    retval = razer_send_control_msg(usb_dev, request_report, report_index, wait_min, wait_max);\n    len = usb_control_msg(usb_dev, usb_rcvctrlpipe(usb_dev, 0),\n                          request,         \n                          request_type,    \n                          value,           \n                          response_index,  \n                          buf,             \n                          size,\n                          USB_CTRL_SET_TIMEOUT);\n    memcpy(response_report, buf, sizeof(struct razer_report));\n    kfree(buf);\n    if(len != 90) {\n        printk(KERN_WARNING \"razer driver: Invalid USB response. USB Report length: %d\\n\", len);\n        result = 1;\n    }\n    if (WARN_ONCE(response_report->data_size > ARRAY_SIZE(response_report->arguments),\n                  \"Field data_size %d in response is bigger than arguments\\n\",\n                  response_report->data_size)) {\n        response_report->data_size = ARRAY_SIZE(response_report->arguments);\n        return -EINVAL;\n    }\n    return result;\n}", "target": 0}
{"code": "static unsigned int help(struct sk_buff *skb,\n\t\t\t enum ip_conntrack_info ctinfo,\n\t\t\t unsigned int protoff,\n\t\t\t unsigned int matchoff,\n\t\t\t unsigned int matchlen,\n\t\t\t struct nf_conntrack_expect *exp)\n{\n\tchar buffer[sizeof(\"4294967296 65635\")];\n\tu_int16_t port;\n\tunsigned int ret;\n\texp->saved_proto.tcp.port = exp->tuple.dst.u.tcp.port;\n\texp->dir = IP_CT_DIR_REPLY;\n\texp->expectfn = nf_nat_follow_master;\n\tfor (port = ntohs(exp->saved_proto.tcp.port); port != 0; port++) {\n\t\tint ret;\n\t\texp->tuple.dst.u.tcp.port = htons(port);\n\t\tret = nf_ct_expect_related(exp);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\telse if (ret != -EBUSY) {\n\t\t\tport = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (port == 0) {\n\t\tnf_ct_helper_log(skb, exp->master, \"all ports in use\");\n\t\treturn NF_DROP;\n\t}\n\tret = nf_nat_mangle_tcp_packet(skb, exp->master, ctinfo,\n\t\t\t\t       protoff, matchoff, matchlen, buffer,\n\t\t\t\t       strlen(buffer));\n\tif (ret != NF_ACCEPT) {\n\t\tnf_ct_helper_log(skb, exp->master, \"cannot mangle packet\");\n\t\tnf_ct_unexpect_related(exp);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static int pfkey_register(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\tstruct sk_buff *supp_skb;\n\tif (hdr->sadb_msg_satype > SADB_SATYPE_MAX)\n\t\treturn -EINVAL;\n\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC) {\n\t\tif (pfk->registered&(1<<hdr->sadb_msg_satype))\n\t\t\treturn -EEXIST;\n\t\tpfk->registered |= (1<<hdr->sadb_msg_satype);\n\t}\n\txfrm_probe_algs();\n\tsupp_skb = compose_sadb_supported(hdr, GFP_KERNEL);\n\tif (!supp_skb) {\n\t\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC)\n\t\t\tpfk->registered &= ~(1<<hdr->sadb_msg_satype);\n\t\treturn -ENOBUFS;\n\t}\n\tpfkey_broadcast(supp_skb, GFP_KERNEL, BROADCAST_REGISTERED, sk,\n\t\t\tsock_net(sk));\n\treturn 0;\n}", "target": 1}
{"code": "static inline int pmd_large(pmd_t pte)\n{\n\treturn (pmd_flags(pte) & (_PAGE_PSE | _PAGE_PRESENT)) ==\n\t\t(_PAGE_PSE | _PAGE_PRESENT);\n}", "target": 1}
{"code": "static u64 distribute_cfs_runtime(struct cfs_bandwidth *cfs_b,\n\t\tu64 remaining, u64 expires)\n{\n\tstruct cfs_rq *cfs_rq;\n\tu64 runtime;\n\tu64 starting_runtime = remaining;\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(cfs_rq, &cfs_b->throttled_cfs_rq,\n\t\t\t\tthrottled_list) {\n\t\tstruct rq *rq = rq_of(cfs_rq);\n\t\tstruct rq_flags rf;\n\t\trq_lock_irqsave(rq, &rf);\n\t\tif (!cfs_rq_throttled(cfs_rq))\n\t\t\tgoto next;\n\t\truntime = -cfs_rq->runtime_remaining + 1;\n\t\tif (runtime > remaining)\n\t\t\truntime = remaining;\n\t\tremaining -= runtime;\n\t\tcfs_rq->runtime_remaining += runtime;\n\t\tcfs_rq->runtime_expires = expires;\n\t\tif (cfs_rq->runtime_remaining > 0)\n\t\t\tunthrottle_cfs_rq(cfs_rq);\nnext:\n\t\trq_unlock_irqrestore(rq, &rf);\n\t\tif (!remaining)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\treturn starting_runtime - remaining;\n}", "target": 1}
{"code": "ikev2_vid_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len _U_, const u_char *ep _U_,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\tconst u_char *vid;\n\tint i, len;\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tikev2_pay_print(ndo, NPSTR(tpay), e.critical);\n\tND_PRINT((ndo,\" len=%d vid=\", ntohs(e.len) - 4));\n\tvid = (const u_char *)(ext+1);\n\tlen = ntohs(e.len) - 4;\n\tND_TCHECK2(*vid, len);\n\tfor(i=0; i<len; i++) {\n\t\tif(ND_ISPRINT(vid[i])) ND_PRINT((ndo, \"%c\", vid[i]));\n\t\telse ND_PRINT((ndo, \".\"));\n\t}\n\tif (2 < ndo->ndo_vflag && 4 < len) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}", "target": 0}
{"code": "check_entry_size_and_hooks(struct ip6t_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_err(\"Underflows must be unconditional and \"\n\t\t\t\t       \"use the STANDARD target with \"\n\t\t\t\t       \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 1}
{"code": "void svhandler_flash_erase_sector(void) {\n  uint32_t sector = _param_1;\n  if ((sector == FLASH_BOOTSTRAP_SECTOR) ||\n      (sector >= FLASH_BOOT_SECTOR_FIRST && sector <= FLASH_BOOT_SECTOR_LAST)) {\n    return;\n  }\n  flash_clear_status_flags();\n  flash_unlock();\n  flash_erase_sector(sector, FLASH_CR_PROGRAM_X32);\n  _param_1 = !!flash_chk_status();\n  _param_2 = 0;\n  _param_3 = 0;\n  flash_wait_for_last_operation();\n  FLASH_CR &= ~FLASH_CR_PG;\n  FLASH_CR |= FLASH_CR_LOCK;\n}", "target": 1}
{"code": "DECLAREwriteFunc(writeBufferToContigTiles)\n{\n\tuint32 imagew = TIFFScanlineSize(out);\n\tuint32 tilew  = TIFFTileRowSize(out);\n\tint iskew = imagew - tilew;\n\ttsize_t tilesize = TIFFTileSize(out);\n\ttdata_t obuf;\n\tuint8* bufp = (uint8*) buf;\n\tuint32 tl, tw;\n\tuint32 row;\n\t(void) spp;\n\tobuf = _TIFFmalloc(TIFFTileSize(out));\n\tif (obuf == NULL)\n\t\treturn 0;\n\t_TIFFmemset(obuf, 0, tilesize);\n\t(void) TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);\n\t(void) TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);\n\tfor (row = 0; row < imagelength; row += tilelength) {\n\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\n\t\tuint32 colb = 0;\n\t\tuint32 col;\n\t\tfor (col = 0; col < imagewidth; col += tw) {\n\t\t\tif (colb + tilew > imagew) {\n\t\t\t\tuint32 width = imagew - colb;\n\t\t\t\tint oskew = tilew - width;\n\t\t\t\tcpStripToTile(obuf, bufp + colb, nrow, width,\n\t\t\t\t    oskew, oskew + iskew);\n\t\t\t} else\n\t\t\t\tcpStripToTile(obuf, bufp + colb, nrow, tilew,\n\t\t\t\t    0, iskew);\n\t\t\tif (TIFFWriteTile(out, obuf, col, row, 0, 0) < 0) {\n\t\t\t\tTIFFError(TIFFFileName(out),\n\t\t\t\t    \"Error, can't write tile at %lu %lu\",\n\t\t\t\t    (unsigned long) col,\n\t\t\t\t    (unsigned long) row);\n\t\t\t\t_TIFFfree(obuf);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcolb += tilew;\n\t\t}\n\t\tbufp += nrow * imagew;\n\t}\n\t_TIFFfree(obuf);\n\treturn 1;\n}", "target": 1}
{"code": "static void sixpack_close(struct tty_struct *tty)\n{\n\tstruct sixpack *sp;\n\twrite_lock_irq(&disc_data_lock);\n\tsp = tty->disc_data;\n\ttty->disc_data = NULL;\n\twrite_unlock_irq(&disc_data_lock);\n\tif (!sp)\n\t\treturn;\n\tif (!refcount_dec_and_test(&sp->refcnt))\n\t\twait_for_completion(&sp->dead);\n\tnetif_stop_queue(sp->dev);\n\tdel_timer_sync(&sp->tx_t);\n\tdel_timer_sync(&sp->resync_t);\n\tunregister_netdev(sp->dev);\n\tkfree(sp->rbuff);\n\tkfree(sp->xbuff);\n\tfree_netdev(sp->dev);\n}", "target": 1}
{"code": "int usbredirparser_have_peer_caps(struct usbredirparser *parser_pub)\n{\n    struct usbredirparser_priv *parser =\n        (struct usbredirparser_priv *)parser_pub;\n    return parser->have_peer_caps;\n}", "target": 0}
{"code": "CBORTag_hash(CBORTagObject *self)\n{\n    if (!_CBOR2_thread_locals && _CBOR2_init_thread_locals() == -1)\n        return -1;\n    Py_hash_t ret = -1;\n    PyObject *running_hashes = NULL;\n    PyObject *tmp = NULL;\n    PyObject *self_id = PyLong_FromVoidPtr(self);\n    if (!self_id)\n        goto exit;\n    running_hashes = PyObject_GetAttrString(_CBOR2_thread_locals, \"running_hashes\");\n    if (!running_hashes) {\n        PyErr_Clear();\n        running_hashes = PySet_New(NULL);\n        if (PyObject_SetAttrString(_CBOR2_thread_locals, \"running_hashes\", running_hashes) == -1)\n            goto exit;\n    } else {\n        switch (PySet_Contains(running_hashes, self_id)) {\n            case -1:  \n                goto exit;\n            case 1:  \n                PyErr_SetString(\n                    PyExc_RuntimeError,\n                    \"This CBORTag is not hashable because it contains a reference to itself\"\n                );\n                goto exit;\n        }\n    }\n    if (PySet_Add(running_hashes, self_id) == -1)\n        goto exit;\n    tmp = Py_BuildValue(\"(KO)\", self->tag, self->value);\n    if (!tmp)\n        goto exit;\n    ret = PyObject_Hash(tmp);\n    if (PySet_Discard(running_hashes, self_id) == -1) {\n        ret = -1;\n        goto exit;\n    }\n    Py_ssize_t length = PySequence_Length(running_hashes);\n    if (length == 1) {\n        ret = -1;\n        goto exit;\n    }\n    if (length == 0 && PyObject_DelAttrString(_CBOR2_thread_locals, \"running_hashes\") == -1) {\n        ret = -1;\n        goto exit;\n    }\nexit:\n    Py_CLEAR(self_id);\n    Py_CLEAR(running_hashes);\n    Py_CLEAR(tmp);\n    return ret;\n}", "target": 1}
{"code": "void Context::onLog() {\n  if (wasm_->onLog_) {\n    wasm_->onLog_(this, id_);\n  }\n}", "target": 1}
{"code": "ia64_patch_rse (unsigned long start, unsigned long end)\n{\n\ts32 *offp = (s32 *) start;\n\tu64 ip, *b;\n\twhile (offp < (s32 *) end) {\n\t\tip = (u64) offp + *offp;\n\t\tb = (u64 *)(ip & -16);\n\t\tb[1] &= ~0xf800000L;\n\t\tia64_fc((void *) ip);\n\t\t++offp;\n\t}\n\tia64_sync_i();\n\tia64_srlz_i();\n}", "target": 0}
{"code": "ConnectionManagerImpl::ActiveStream::~ActiveStream() {\n  stream_info_.onRequestComplete();\n  if (!stream_info_.hasAnyResponseFlag() && !stream_info_.responseCode()) {\n    stream_info_.setResponseFlag(StreamInfo::ResponseFlag::DownstreamConnectionTermination);\n  }\n  connection_manager_.stats_.named_.downstream_rq_active_.dec();\n  if (request_headers_ != nullptr) {\n    request_headers_->refreshByteSize();\n  }\n  if (response_headers_ != nullptr) {\n    response_headers_->refreshByteSize();\n  }\n  if (response_trailers_ != nullptr) {\n    response_trailers_->refreshByteSize();\n  }\n  for (const AccessLog::InstanceSharedPtr& access_log : connection_manager_.config_.accessLogs()) {\n    access_log->log(request_headers_.get(), response_headers_.get(), response_trailers_.get(),\n                    stream_info_);\n  }\n  for (const auto& log_handler : access_log_handlers_) {\n    log_handler->log(request_headers_.get(), response_headers_.get(), response_trailers_.get(),\n                     stream_info_);\n  }\n  if (stream_info_.healthCheck()) {\n    connection_manager_.config_.tracingStats().health_check_.inc();\n  }\n  if (active_span_) {\n    Tracing::HttpTracerUtility::finalizeDownstreamSpan(\n        *active_span_, request_headers_.get(), response_headers_.get(), response_trailers_.get(),\n        stream_info_, *this);\n  }\n  if (state_.successful_upgrade_) {\n    connection_manager_.stats_.named_.downstream_cx_upgrades_active_.dec();\n  }\n  ASSERT(state_.filter_call_state_ == 0);\n}", "target": 0}
{"code": "crm_recv_remote_msg(void *session, gboolean encrypted)\n{\n    char *reply = NULL;\n    xmlNode *xml = NULL;\n    if (encrypted) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        reply = cib_recv_tls(session);\n#else\n        CRM_ASSERT(encrypted == FALSE);\n#endif\n    } else {\n        reply = cib_recv_plaintext(GPOINTER_TO_INT(session));\n    }\n    if (reply == NULL || strlen(reply) == 0) {\n        crm_trace(\"Empty reply\");\n    } else {\n        xml = string2xml(reply);\n        if (xml == NULL) {\n            crm_err(\"Couldn't parse: '%.120s'\", reply);\n        }\n    }\n    free(reply);\n    return xml;\n}", "target": 1}
{"code": "static int pf_detect(void)\n{\n\tstruct pf_unit *pf = units;\n\tint k, unit;\n\tprintk(\"%s: %s version %s, major %d, cluster %d, nice %d\\n\",\n\t       name, name, PF_VERSION, major, cluster, nice);\n\tpar_drv = pi_register_driver(name);\n\tif (!par_drv) {\n\t\tpr_err(\"failed to register %s driver\\n\", name);\n\t\treturn -1;\n\t}\n\tk = 0;\n\tif (pf_drive_count == 0) {\n\t\tif (pi_init(pf->pi, 1, -1, -1, -1, -1, -1, pf_scratch, PI_PF,\n\t\t\t    verbose, pf->name)) {\n\t\t\tif (!pf_probe(pf) && pf->disk) {\n\t\t\t\tpf->present = 1;\n\t\t\t\tk++;\n\t\t\t} else\n\t\t\t\tpi_release(pf->pi);\n\t\t}\n\t} else\n\t\tfor (unit = 0; unit < PF_UNITS; unit++, pf++) {\n\t\t\tint *conf = *drives[unit];\n\t\t\tif (!conf[D_PRT])\n\t\t\t\tcontinue;\n\t\t\tif (pi_init(pf->pi, 0, conf[D_PRT], conf[D_MOD],\n\t\t\t\t    conf[D_UNI], conf[D_PRO], conf[D_DLY],\n\t\t\t\t    pf_scratch, PI_PF, verbose, pf->name)) {\n\t\t\t\tif (pf->disk && !pf_probe(pf)) {\n\t\t\t\t\tpf->present = 1;\n\t\t\t\t\tk++;\n\t\t\t\t} else\n\t\t\t\t\tpi_release(pf->pi);\n\t\t\t}\n\t\t}\n\tif (k)\n\t\treturn 0;\n\tprintk(\"%s: No ATAPI disk detected\\n\", name);\n\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n\t\tif (!pf->disk)\n\t\t\tcontinue;\n\t\tblk_cleanup_queue(pf->disk->queue);\n\t\tpf->disk->queue = NULL;\n\t\tblk_mq_free_tag_set(&pf->tag_set);\n\t\tput_disk(pf->disk);\n\t}\n\tpi_unregister_driver(par_drv);\n\treturn -1;\n}", "target": 0}
{"code": "void CLASS panasonic_load_raw()\n{\n  int row, col, i, j, sh = 0, pred[2], nonz[2];\n  pana_bits(0);\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < raw_width; col++)\n    {\n      if ((i = col % 14) == 0)\n        pred[0] = pred[1] = nonz[0] = nonz[1] = 0;\n      if (i % 3 == 2)\n        sh = 4 >> (3 - pana_bits(2));\n      if (nonz[i & 1])\n      {\n        if ((j = pana_bits(8)))\n        {\n          if ((pred[i & 1] -= 0x80 << sh) < 0 || sh == 4)\n            pred[i & 1] &= ~((~0u) << sh);\n          pred[i & 1] += j << sh;\n        }\n      }\n      else if ((nonz[i & 1] = pana_bits(8)) || i > 11)\n        pred[i & 1] = nonz[i & 1] << 4 | pana_bits(4);\n      if ((RAW(row, col) = pred[col & 1]) > 4098 && col < width)\n        derror();\n    }\n  }\n}", "target": 1}
{"code": "size_t TensorSliceWriter::MaxBytesPerElement(DataType dt) {\n  switch (dt) {\n    case DT_FLOAT:\n      return 4;\n    case DT_DOUBLE:\n      return 8;\n    case DT_INT32:\n      return 10;\n    case DT_UINT8:\n      return 2;\n    case DT_INT16:\n      return 10;\n    case DT_INT8:\n      return 10;\n    case DT_COMPLEX64:\n      return 8;\n    case DT_INT64:\n      return 10;\n    case DT_BOOL:\n      return 1;\n    case DT_QINT8:\n      return 10;\n    case DT_QUINT8:\n      return 2;\n    case DT_QINT32:\n      return 10;\n    case DT_QINT16:\n      return 10;\n    case DT_QUINT16:\n      return 3;\n    case DT_UINT16:\n      return 3;\n    case DT_COMPLEX128:\n      return 16;\n    case DT_HALF:\n      return 3;\n    case DT_INVALID:\n    case DT_STRING:\n    case DT_BFLOAT16:\n    default:\n      LOG(FATAL) << \"MaxBytesPerElement not implemented for dtype: \" << dt;\n  }\n  return 0;\n}", "target": 1}
{"code": "string SummarizeArray<bool>(int64_t limit, int64_t num_elts,\n                            const TensorShape& tensor_shape, const char* data,\n                            const bool print_v2) {\n  if (data == nullptr) {\n    return strings::StrCat(\"\");  \n  }\n  auto mutable_data = std::unique_ptr<char[]>(new char[num_elts]);\n  for (int64_t i = 0; i < num_elts; ++i)\n    mutable_data.get()[i] = data[i] ? 1 : 0;\n  bool* array = reinterpret_cast<bool*>(mutable_data.get());\n  return SummarizeArrayInternal<bool>(limit, num_elts, tensor_shape, array,\n                                      print_v2);\n}", "target": 0}
{"code": "content::WebContents* WebContents::OpenURLFromTab(\n    content::WebContents* source,\n    const content::OpenURLParams& params) {\n  if (params.disposition != WindowOpenDisposition::CURRENT_TAB) {\n    Emit(\"-new-window\", params.url, \"\", params.disposition, \"\", params.referrer,\n         params.post_data);\n    return nullptr;\n  }\n  if (Emit(\"will-navigate\", params.url))\n    return nullptr;\n  if (IsDestroyed())\n    return nullptr;\n  return CommonWebContentsDelegate::OpenURLFromTab(source, params);\n}", "target": 1}
{"code": "HIDDEN int zlib_compress(struct transaction_t *txn, unsigned flags,\n                         const char *buf, unsigned len)\n{\n    z_stream *zstrm = txn->zstrm;\n    unsigned flush;\n    if (flags & COMPRESS_START) deflateReset(zstrm);\n    if (txn->ws_ctx) flush = Z_SYNC_FLUSH;\n    else {\n        if (flags & COMPRESS_END) flush = Z_FINISH;\n        else flush = Z_NO_FLUSH;\n    }\n    zstrm->next_in = (Bytef *) buf;\n    zstrm->avail_in = len;\n    buf_ensure(&txn->zbuf, deflateBound(zstrm, zstrm->avail_in));\n    buf_reset(&txn->zbuf);\n    do {\n        int zr;\n        if (!zstrm->avail_out) {\n            unsigned pending;\n            zr = deflatePending(zstrm, &pending, Z_NULL);\n            if (zr != Z_OK) {\n                syslog(LOG_ERR, \"zlib deflate error: %d %s\", zr, zstrm->msg);\n                return -1;\n            }\n            buf_ensure(&txn->zbuf, pending);\n        }\n        zstrm->next_out = (Bytef *) txn->zbuf.s + txn->zbuf.len;\n        zstrm->avail_out = txn->zbuf.alloc - txn->zbuf.len;\n        zr = deflate(zstrm, flush);\n        if (!(zr == Z_OK || zr == Z_STREAM_END || zr == Z_BUF_ERROR)) {\n            syslog(LOG_ERR, \"zlib deflate error: %d %s\", zr, zstrm->msg);\n            return -1;\n        }\n        txn->zbuf.len = txn->zbuf.alloc - zstrm->avail_out;\n    } while (!zstrm->avail_out);\n    return 0;\n}", "target": 0}
{"code": "void stl_le_phys(AddressSpace *as, hwaddr addr, uint32_t val)\n{\n    address_space_stl_le(as, addr, val, MEMTXATTRS_UNSPECIFIED, NULL);\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const float min_input = context->input(1).flat<float>()(0);\n    const float max_input = context->input(2).flat<float>()(0);\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input.shape(), &output));\n    const T min_as_quantized = FloatToQuantized<T>(0.0f, min_input, max_input);\n    const T max_as_quantized = FloatToQuantized<T>(6.0f, min_input, max_input);\n    if (meta::IsSupportedAndEnabled() && std::is_same<T, quint8>()) {\n      auto input_ui8_array = input.flat<quint8>();\n      meta::Clamp(context, input_ui8_array.data(), input_ui8_array.size(),\n                  min_as_quantized, max_as_quantized,\n                  output->flat<quint8>().data());\n    } else {\n      output->flat<T>().device(context->eigen_cpu_device()) =\n          input.flat<T>()\n              .cwiseMax(min_as_quantized)\n              .cwiseMin(max_as_quantized)\n              .template cast<T>();\n    }\n    Tensor* output_min = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, {}, &output_min));\n    output_min->flat<float>()(0) = min_input;\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(2, {}, &output_max));\n    output_max->flat<float>()(0) = max_input;\n  }", "target": 1}
{"code": "GF_Err tenc_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TrackEncryptionBox *ptr = (GF_TrackEncryptionBox*) a;\n\tif (!a) return GF_BAD_PARAM;\n\tgf_isom_box_dump_start(a, \"TrackEncryptionBox\", trace);\n\tfprintf(trace, \"isEncrypted=\\\"%d\\\"\", ptr->isProtected);\n\tif (ptr->Per_Sample_IV_Size)\n\t\tfprintf(trace, \" IV_size=\\\"%d\\\" KID=\\\"\", ptr->Per_Sample_IV_Size);\n\telse {\n\t\tfprintf(trace, \" constant_IV_size=\\\"%d\\\" constant_IV=\\\"\", ptr->constant_IV_size);\n\t\tdump_data_hex(trace, (char *) ptr->constant_IV, ptr->constant_IV_size);\n\t\tfprintf(trace, \"\\\"  KID=\\\"\");\n\t}\n\tdump_data_hex(trace, (char *) ptr->KID, 16);\n\tif (ptr->version) \n\t\tfprintf(trace, \"\\\" crypt_byte_block=\\\"%d\\\" skip_byte_block=\\\"%d\", ptr->crypt_byte_block, ptr->skip_byte_block);\n\tfprintf(trace, \"\\\">\\n\");\n\tgf_isom_box_dump_done(\"TrackEncryptionBox\", a, trace);\n\treturn GF_OK;\n}", "target": 1}
{"code": "mktime(const unsigned int year0, const unsigned int mon0,\n       const unsigned int day, const unsigned int hour,\n       const unsigned int min, const unsigned int sec)\n{\n\tunsigned int mon = mon0, year = year0;\n\tif (0 >= (int) (mon -= 2)) {\n\t\tmon += 12;\t\n\t\tyear -= 1;\n\t}\n\treturn ((((unsigned long)\n\t\t  (year/4 - year/100 + year/400 + 367*mon/12 + day) +\n\t\t  year*365 - 719499\n\t    )*24 + hour \n\t  )*60 + min \n\t)*60 + sec; \n}", "target": 0}
{"code": "cifs_find_smb_ses(struct TCP_Server_Info *server, char *username)\n{\n\tstruct list_head *tmp;\n\tstruct cifsSesInfo *ses;\n\twrite_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &server->smb_ses_list) {\n\t\tses = list_entry(tmp, struct cifsSesInfo, smb_ses_list);\n\t\tif (strncmp(ses->userName, username, MAX_USERNAME_SIZE))\n\t\t\tcontinue;\n\t\t++ses->ses_count;\n\t\twrite_unlock(&cifs_tcp_ses_lock);\n\t\treturn ses;\n\t}\n\twrite_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}", "target": 1}
{"code": "static void ssh2_send_newkeys(PTInstVar pvar)\n{\n\tbegin_send_packet(pvar, SSH2_MSG_NEWKEYS, 0);\n\tfinish_send_packet(pvar);\n\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: SSH2_MSG_NEWKEYS was sent.\", __FUNCTION__);\n\tssh2_set_newkeys(pvar, MODE_OUT);\n\tif (!CRYPT_start_encryption(pvar, 1, 0)) {\n\t}\n\tpvar->ssh2_keys[MODE_OUT].mac.enabled = 1;\n\tpvar->ssh2_keys[MODE_OUT].comp.enabled = 1;\n\tenable_send_compression(pvar);\n\tpvar->kex_status |= KEX_FLAG_NEWKEYS_SENT;\n\tif (pvar->server_strict_kex) {\n\t\tpvar->ssh_state.sender_sequence_number = 0;\n\t}\n\tif (pvar->kex_status & KEX_FLAG_NEWKEYS_RECEIVED) {\n\t\tif ((pvar->kex_status & KEX_FLAG_REKEYING)) {\n\t\t\tdo_SSH2_dispatch_setup_for_transfer(pvar);\n\t\t}\n\t\telse {\n\t\t\tssh2_finish_encryption_setup(pvar);\n\t\t\tssh2_prep_userauth(pvar);\n\t\t}\n\t\tpvar->kex_status = KEX_FLAG_KEXDONE;\n\t}\n\treturn;\n}", "target": 0}
{"code": "_pdfioTokenGet(_pdfio_token_t *tb,\t\n\t       char           *buffer,\t\n\t       size_t         bufsize)\t\n{\n  if (tb->num_tokens > 0)\n  {\n    tb->num_tokens --;\n    strncpy(buffer, tb->tokens[tb->num_tokens], bufsize - 1);\n    buffer[bufsize - 1] = '\\0';\n    PDFIO_DEBUG(\"_pdfioTokenGet(tb=%p, buffer=%p, bufsize=%u): Popping '%s' from stack.\\n\", tb, buffer, (unsigned)bufsize, buffer);\n    free(tb->tokens[tb->num_tokens]);\n    tb->tokens[tb->num_tokens] = NULL;\n    return (true);\n  }\n  return (_pdfioTokenRead(tb, buffer, bufsize));\n}", "target": 1}
{"code": "std::string sanitizeNameForWindowList(const std::string& name) {\n    std::string result = name;\n    if (result[0] == '\\\"')\n        result[0] = ' ';\n    for (size_t i = 1; i < result.size(); ++i) {\n        if (result[i - 1] == '>' && result[i] == ']')\n            result[i] = ' ';\n        if (result[i] == '\\\"')\n            result[i] = ' ';\n    }\n    return result;\n}", "target": 1}
{"code": "static void lo_release(struct gendisk *disk, fmode_t mode)\n{\n\tstruct loop_device *lo = disk->private_data;\n\tint err;\n\tif (atomic_dec_return(&lo->lo_refcnt))\n\t\treturn;\n\tmutex_lock(&lo->lo_ctl_mutex);\n\tif (lo->lo_flags & LO_FLAGS_AUTOCLEAR) {\n\t\terr = loop_clr_fd(lo);\n\t\tif (!err)\n\t\t\treturn;\n\t} else if (lo->lo_state == Lo_bound) {\n\t\tblk_mq_freeze_queue(lo->lo_queue);\n\t\tblk_mq_unfreeze_queue(lo->lo_queue);\n\t}\n\tmutex_unlock(&lo->lo_ctl_mutex);\n}", "target": 1}
{"code": "nfsd4_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tstruct nfs4_acl *acl)\n{\n\t__be32 error;\n\tint host_error;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tstruct posix_acl *pacl = NULL, *dpacl = NULL;\n\tunsigned int flags = 0;\n\terror = fh_verify(rqstp, fhp, 0, NFSD_MAY_SATTR);\n\tif (error)\n\t\treturn error;\n\tdentry = fhp->fh_dentry;\n\tinode = d_inode(dentry);\n\tif (!inode->i_op->set_acl || !IS_POSIXACL(inode))\n\t\treturn nfserr_attrnotsupp;\n\tif (S_ISDIR(inode->i_mode))\n\t\tflags = NFS4_ACL_DIR;\n\thost_error = nfs4_acl_nfsv4_to_posix(acl, &pacl, &dpacl, flags);\n\tif (host_error == -EINVAL)\n\t\treturn nfserr_attrnotsupp;\n\tif (host_error < 0)\n\t\tgoto out_nfserr;\n\thost_error = inode->i_op->set_acl(inode, pacl, ACL_TYPE_ACCESS);\n\tif (host_error < 0)\n\t\tgoto out_release;\n\tif (S_ISDIR(inode->i_mode)) {\n\t\thost_error = inode->i_op->set_acl(inode, dpacl,\n\t\t\t\t\t\t  ACL_TYPE_DEFAULT);\n\t}\nout_release:\n\tposix_acl_release(pacl);\n\tposix_acl_release(dpacl);\nout_nfserr:\n\tif (host_error == -EOPNOTSUPP)\n\t\treturn nfserr_attrnotsupp;\n\telse\n\t\treturn nfserrno(host_error);\n}", "target": 1}
{"code": "static inline void ext4_truncate_failed_write(struct inode *inode)\n{\n\tdown_write(&EXT4_I(inode)->i_mmap_sem);\n\ttruncate_inode_pages(inode->i_mapping, inode->i_size);\n\text4_truncate(inode);\n\tup_write(&EXT4_I(inode)->i_mmap_sem);\n}", "target": 0}
{"code": "static void gfs2_evict_inode(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct gfs2_sbd *sdp = sb->s_fs_info;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder gh;\n\tint ret;\n\tif (inode->i_nlink || sb_rdonly(sb) || !ip->i_no_addr)\n\t\tgoto out;\n\tif (!sdp->sd_jdesc)\n\t\tgoto out;\n\tgfs2_holder_mark_uninitialized(&gh);\n\tret = evict_should_delete(inode, &gh);\n\tif (ret == SHOULD_DEFER_EVICTION)\n\t\tgoto out;\n\tif (ret == SHOULD_DELETE_DINODE)\n\t\tret = evict_unlinked_inode(inode);\n\telse\n\t\tret = evict_linked_inode(inode);\n\tif (gfs2_rs_active(&ip->i_res))\n\t\tgfs2_rs_deltree(&ip->i_res);\n\tif (gfs2_holder_initialized(&gh))\n\t\tgfs2_glock_dq_uninit(&gh);\n\tif (ret && ret != GLR_TRYFAILED && ret != -EROFS)\n\t\tfs_warn(sdp, \"gfs2_evict_inode: %d\\n\", ret);\nout:\n\ttruncate_inode_pages_final(&inode->i_data);\n\tif (ip->i_qadata)\n\t\tgfs2_assert_warn(sdp, ip->i_qadata->qa_ref == 0);\n\tgfs2_rs_deltree(&ip->i_res);\n\tgfs2_ordered_del_inode(ip);\n\tclear_inode(inode);\n\tgfs2_dir_hash_inval(ip);\n\tif (gfs2_holder_initialized(&ip->i_iopen_gh)) {\n\t\tstruct gfs2_glock *gl = ip->i_iopen_gh.gh_gl;\n\t\tglock_clear_object(gl, ip);\n\t\tgfs2_glock_hold(gl);\n\t\tip->i_iopen_gh.gh_flags |= GL_NOCACHE;\n\t\tgfs2_glock_dq_uninit(&ip->i_iopen_gh);\n\t\tgfs2_glock_put_eventually(gl);\n\t}\n\tif (ip->i_gl) {\n\t\tglock_clear_object(ip->i_gl, ip);\n\t\twait_on_bit_io(&ip->i_flags, GIF_GLOP_PENDING, TASK_UNINTERRUPTIBLE);\n\t\tgfs2_glock_add_to_lru(ip->i_gl);\n\t\tgfs2_glock_put_eventually(ip->i_gl);\n\t\tip->i_gl = NULL;\n\t}\n}", "target": 0}
{"code": "GetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<OutboundPinholeTimeout>%d</OutboundPinholeTimeout>\"\n\t\t\"</u:%sResponse>\";\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tchar * int_ip, * int_port, * rem_host, * rem_port, * protocol;\n\tint opt=0;\n\tunsigned short iport, rport;\n\tif (GETFLAG(IPV6FCFWDISABLEDMASK))\n\t{\n\t\tSoapError(h, 702, \"FirewallDisabled\");\n\t\treturn;\n\t}\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tint_ip = GetValueFromNameValueList(&data, \"InternalClient\");\n\tint_port = GetValueFromNameValueList(&data, \"InternalPort\");\n\trem_host = GetValueFromNameValueList(&data, \"RemoteHost\");\n\trem_port = GetValueFromNameValueList(&data, \"RemotePort\");\n\tprotocol = GetValueFromNameValueList(&data, \"Protocol\");\n\tif (!int_port || !rem_port || !protocol)\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n\trport = (unsigned short)atoi(rem_port);\n\tiport = (unsigned short)atoi(int_port);\n\tsyslog(LOG_INFO, \"%s: retrieving timeout for outbound pinhole from [%s]:%hu to [%s]:%hu protocol %s\", action, int_ip, iport,rem_host, rport, protocol);\n\tr = -1;\n\tswitch(r)\n\t{\n\t\tcase 1:\t\n\t\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t\t                   action, ns,\n\t\t\t                   opt, action);\n\t\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t\t\tbreak;\n\t\tcase -5:\t\n\t\t\tSoapError(h, 705, \"ProtocolNotSupported\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tSoapError(h, 501, \"ActionFailed\");\n\t}\n\tClearNameValueList(&data);\n}", "target": 0}
{"code": "nvkm_vmm_free_delete(struct nvkm_vmm *vmm, struct nvkm_vma *vma)\n{\n\tnvkm_vmm_free_remove(vmm, vma);\n\tlist_del(&vma->head);\n\tkfree(vma);\n}", "target": 0}
{"code": "#ifndef GPAC_DISABLE_ISOM_HINTING\nvoid dump_isom_sdp(GF_ISOFile *file, char *inName, Bool is_final_name)\n{\n\tconst char *sdp;\n\tu32 size, i;\n\tFILE *dump;\n\tif (inName) {\n\t\tchar szBuf[1024];\n\t\tstrcpy(szBuf, inName);\n\t\tif (!is_final_name) {\n\t\t\tchar *ext = strchr(szBuf, '.');\n\t\t\tif (ext) ext[0] = 0;\n\t\t\tstrcat(szBuf, \"_sdp.txt\");\n\t\t}\n\t\tdump = gf_fopen(szBuf, \"wt\");\n\t\tif (!dump) {\n\t\t\tfprintf(stderr, \"Failed to open %s for dumping\\n\", szBuf);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tdump = stdout;\n\t\tfprintf(dump, \"* File SDP content *\\n\\n\");\n\t}\n\tgf_isom_sdp_get(file, &sdp, &size);\n\tfprintf(dump, \"%s\", sdp);\n\tfprintf(dump, \"\\r\\n\");\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\tif (gf_isom_get_media_type(file, i+1) != GF_ISOM_MEDIA_HINT) continue;\n\t\tgf_isom_sdp_track_get(file, i+1, &sdp, &size);\n\t\tfprintf(dump, \"%s\", sdp);\n\t}\n\tfprintf(dump, \"\\n\\n\");", "target": 1}
{"code": "  void ValidateInputTensors(OpKernelContext* ctx, const Tensor& in0,\n                            const Tensor& in1) override {\n    OP_REQUIRES(\n        ctx, in0.dims() >= 2,\n        errors::InvalidArgument(\"In[0] ndims must be >= 2: \", in0.dims()));\n    OP_REQUIRES(\n        ctx, in1.dims() >= 2,\n        errors::InvalidArgument(\"In[0] ndims must be >= 2: \", in1.dims()));\n  }", "target": 1}
{"code": "static int bcm_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct net *net;\n\tstruct bcm_sock *bo;\n\tstruct bcm_op *op, *next;\n\tif (!sk)\n\t\treturn 0;\n\tnet = sock_net(sk);\n\tbo = bcm_sk(sk);\n\tspin_lock(&bcm_notifier_lock);\n\twhile (bcm_busy_notifier == bo) {\n\t\tspin_unlock(&bcm_notifier_lock);\n\t\tschedule_timeout_uninterruptible(1);\n\t\tspin_lock(&bcm_notifier_lock);\n\t}\n\tlist_del(&bo->notifier);\n\tspin_unlock(&bcm_notifier_lock);\n\tlock_sock(sk);\n\tlist_for_each_entry_safe(op, next, &bo->tx_ops, list)\n\t\tbcm_remove_op(op);\n\tlist_for_each_entry_safe(op, next, &bo->rx_ops, list) {\n\t\tif (op->ifindex) {\n\t\t\tif (op->rx_reg_dev) {\n\t\t\t\tstruct net_device *dev;\n\t\t\t\tdev = dev_get_by_index(net, op->ifindex);\n\t\t\t\tif (dev) {\n\t\t\t\t\tbcm_rx_unreg(dev, op);\n\t\t\t\t\tdev_put(dev);\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tcan_rx_unregister(net, NULL, op->can_id,\n\t\t\t\t\t  REGMASK(op->can_id),\n\t\t\t\t\t  bcm_rx_handler, op);\n\t\tbcm_remove_op(op);\n\t}\n#if IS_ENABLED(CONFIG_PROC_FS)\n\tif (net->can.bcmproc_dir && bo->bcm_proc_read)\n\t\tremove_proc_entry(bo->procname, net->can.bcmproc_dir);\n#endif \n\tif (bo->bound) {\n\t\tbo->bound   = 0;\n\t\tbo->ifindex = 0;\n\t}\n\tsock_orphan(sk);\n\tsock->sk = NULL;\n\trelease_sock(sk);\n\tsock_put(sk);\n\treturn 0;\n}", "target": 1}
{"code": "long do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t *info)\n{\n\tif (pid <= 0 || tgid <= 0)\n\t\treturn -EINVAL;\n\tif (info->si_code >= 0)\n\t\treturn -EPERM;\n\tinfo->si_signo = sig;\n\treturn do_send_specific(tgid, pid, sig, info);\n}", "target": 1}
{"code": "check_mime_type(const gchar* uri,GError** error)\n{\n    GError * err = NULL;\n    const gchar* mimeFromFile;\n    mimeFromFile = ev_file_get_mime_type(uri, FALSE, &err);\n    if (mimeFromFile)\n    {\n        const gchar* mimetypes[] = {\"application/epub+zip\", \"application/x-booki+zip\", NULL};\n        guint i;\n        for (i = 0; i < g_strv_length (mimetypes); i++) {\n           if (strcmp(mimeFromFile, mimetypes[i]) == 0)\n                return TRUE;\n\t}\n        if (strcmp (mimeFromFile, \"application/zip\") == 0)\n        {\n            mimeFromFile = ev_file_get_mime_type (uri, TRUE, &err);\n            if (mimeFromFile)\n            {\n                for (i = 0; i < g_strv_length (mimetypes); i++) {\n                    if (g_strcmp0(mimeFromFile, mimetypes[i]) == 0)\n                        return TRUE;\n                }\n                g_set_error_literal (error,\n                                     EV_DOCUMENT_ERROR,\n                                     EV_DOCUMENT_ERROR_INVALID,\n                                     _(\"Not an ePub document\"));\n                return FALSE;\n            }\n        }\n    }\n    if (err)\n        g_propagate_error (error, err);\n    else\n        g_set_error_literal (error,\n                             EV_DOCUMENT_ERROR,\n                             EV_DOCUMENT_ERROR_INVALID,\n                             _(\"Unknown MIME Type\"));\n    return FALSE;\n}", "target": 1}
{"code": "gss_krb5int_export_lucid_sec_context(\n    OM_uint32           *minor_status,\n    const gss_ctx_id_t  context_handle,\n    const gss_OID       desired_object,\n    gss_buffer_set_t    *data_set)\n{\n    krb5_error_code     kret = 0;\n    OM_uint32           retval;\n    krb5_gss_ctx_id_t   ctx = (krb5_gss_ctx_id_t)context_handle;\n    void                *lctx = NULL;\n    int                 version = 0;\n    gss_buffer_desc     rep;\n    retval = GSS_S_FAILURE;\n    *minor_status = 0;\n    *data_set = GSS_C_NO_BUFFER_SET;\n    if (ctx->terminated || !ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return GSS_S_NO_CONTEXT;\n    }\n    retval = generic_gss_oid_decompose(minor_status,\n                                       GSS_KRB5_EXPORT_LUCID_SEC_CONTEXT_OID,\n                                       GSS_KRB5_EXPORT_LUCID_SEC_CONTEXT_OID_LENGTH,\n                                       desired_object,\n                                       &version);\n    if (GSS_ERROR(retval))\n        return retval;\n    switch (version) {\n    case 1:\n        kret = make_external_lucid_ctx_v1((krb5_pointer)ctx,\n                                          version, &lctx);\n        break;\n    default:\n        kret = (OM_uint32) KG_LUCID_VERSION;\n        break;\n    }\n    if (kret)\n        goto error_out;\n    rep.value = &lctx;\n    rep.length = sizeof(lctx);\n    retval = generic_gss_add_buffer_set_member(minor_status, &rep, data_set);\n    if (GSS_ERROR(retval))\n        goto error_out;\nerror_out:\n    if (*minor_status == 0)\n        *minor_status = (OM_uint32) kret;\n    return(retval);\n}", "target": 0}
{"code": "static inline neu_msg_t *neu_msg_new(neu_reqresp_type_e t, void *ctx,\n                                     void *data)\n{\n    size_t data_size = neu_reqresp_size(t);\n    size_t body_size = 0;\n    switch (t) {\n    case NEU_REQ_CHECK_SCHEMA:\n        body_size = neu_reqresp_size(NEU_RESP_CHECK_SCHEMA);\n        break;\n    case NEU_REQ_GET_PLUGIN:\n        body_size = neu_reqresp_size(NEU_RESP_GET_PLUGIN);\n        break;\n    case NEU_REQ_UPDATE_GROUP:\n    case NEU_REQ_UPDATE_DRIVER_GROUP:\n        body_size = neu_reqresp_size(NEU_RESP_UPDATE_DRIVER_GROUP);\n        break;\n    case NEU_REQ_UPDATE_NODE:\n    case NEU_REQ_NODE_RENAME:\n        body_size = neu_reqresp_size(NEU_RESP_NODE_RENAME);\n        break;\n    case NEU_REQ_DEL_NODE:\n        body_size = neu_reqresp_size(NEU_RESP_NODE_UNINIT);\n        break;\n    case NEU_REQ_GET_NODE_SETTING:\n        body_size = neu_reqresp_size(NEU_RESP_GET_NODE_SETTING);\n        break;\n    case NEU_REQ_GET_NODES_STATE:\n        body_size = neu_reqresp_size(NEU_RESP_GET_NODES_STATE);\n        break;\n    default:\n        body_size = data_size;\n    }\n    size_t     total = sizeof(neu_msg_t) + body_size;\n    neu_msg_t *msg   = calloc(1, total);\n    if (msg) {\n        msg->head.type = t;\n        msg->head.len  = total;\n        msg->head.ctx  = ctx;\n        if (data) {\n            memcpy(msg->body, data, data_size);\n        }\n    }\n    return msg;\n}", "target": 0}
{"code": "void ff_jpeg2000_cleanup(Jpeg2000Component *comp, Jpeg2000CodingStyle *codsty)\n{\n    int reslevelno, bandno, precno;\n    for (reslevelno = 0;\n         comp->reslevel && reslevelno < codsty->nreslevels;\n         reslevelno++) {\n        Jpeg2000ResLevel *reslevel = comp->reslevel + reslevelno;\n        for (bandno = 0; bandno < reslevel->nbands; bandno++) {\n            Jpeg2000Band *band = reslevel->band + bandno;\n            for (precno = 0; precno < reslevel->num_precincts_x * reslevel->num_precincts_y; precno++) {\n                Jpeg2000Prec *prec = band->prec + precno;\n                av_freep(&prec->zerobits);\n                av_freep(&prec->cblkincl);\n                av_freep(&prec->cblk);\n            }\n            av_freep(&band->prec);\n        }\n        av_freep(&reslevel->band);\n    }\n    ff_dwt_destroy(&comp->dwt);\n    av_freep(&comp->reslevel);\n    av_freep(&comp->i_data);\n    av_freep(&comp->f_data);\n}", "target": 1}
{"code": "static bool checkreturn pb_dec_string(pb_istream_t *stream, const pb_field_t *field, void *dest)\n{\n    uint32_t size;\n    size_t alloc_size;\n    bool status;\n    if (!pb_decode_varint32(stream, &size))\n        return false;\n    alloc_size = size + 1;\n    if (alloc_size < size)\n        PB_RETURN_ERROR(stream, \"size too large\");\n    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)\n    {\n#ifndef PB_ENABLE_MALLOC\n        PB_RETURN_ERROR(stream, \"no malloc support\");\n#else\n        if (!allocate_field(stream, dest, alloc_size, 1))\n            return false;\n        dest = *(void**)dest;\n#endif\n    }\n    else\n    {\n        if (alloc_size > field->data_size)\n            PB_RETURN_ERROR(stream, \"string overflow\");\n    }\n    status = pb_read(stream, (uint8_t*)dest, size);\n    *((uint8_t*)dest + size) = 0;\n    return status;\n}", "target": 0}
{"code": "static int _strlen_check(int linenumber, char *buf, size_t len)\n{\n  size_t buflen = strlen(buf);\n  if(len != buflen) {\n    printf(\"sprintf strlen:%d failed:\\nwe '%d'\\nsystem: '%d'\\n\",\n           linenumber, buflen, len);\n    return 1;\n  }\n  return 0;\n}", "target": 0}
{"code": "static void srv_close(void)\n{\n\tverifyd.sock = mem_deref(verifyd.sock);\n}", "target": 0}
{"code": "isdn_net_force_dial(char *name)\n{\n\tisdn_net_dev *p = isdn_net_findif(name);\n\tif (!p)\n\t\treturn -ENODEV;\n\treturn (isdn_net_force_dial_lp(p->local));\n}", "target": 0}
{"code": "static void set_fdc(int drive)\n{\n\tif (drive >= 0 && drive < N_DRIVE) {\n\t\tfdc = FDC(drive);\n\t\tcurrent_drive = drive;\n\t}\n\tif (fdc != 1 && fdc != 0) {\n\t\tpr_info(\"bad fdc value\\n\");\n\t\treturn;\n\t}\n\tset_dor(fdc, ~0, 8);\n#if N_FDC > 1\n\tset_dor(1 - fdc, ~8, 0);\n#endif\n\tif (FDCS->rawcmd == 2)\n\t\treset_fdc_info(1);\n\tif (fd_inb(FD_STATUS) != STATUS_READY)\n\t\tFDCS->reset = 1;\n}", "target": 1}
{"code": "static int snd_ctl_elem_read_user(struct snd_card *card,\n\t\t\t\t  struct snd_ctl_elem_value __user *_control)\n{\n\tstruct snd_ctl_elem_value *control;\n\tint result;\n\tcontrol = memdup_user(_control, sizeof(*control));\n\tif (IS_ERR(control))\n\t\treturn PTR_ERR(control);\n\tdown_read(&card->controls_rwsem);\n\tresult = snd_ctl_elem_read(card, control);\n\tup_read(&card->controls_rwsem);\n\tif (result < 0)\n\t\tgoto error;\n\tif (copy_to_user(_control, control, sizeof(*control)))\n\t\tresult = -EFAULT;\n error:\n\tkfree(control);\n\treturn result;\n}", "target": 1}
{"code": "TypeAttr CastQuantizedTypeAttrFromExpressedType(Builder builder,\n                                                TypeAttr source, Type target,\n                                                int axis) {\n  auto source_type = source.getValue().dyn_cast_or_null<ShapedType>();\n  if (!source_type) return {};\n  auto src_ele_type = source_type.getElementType();\n  auto qtype = src_ele_type.dyn_cast<quant::QuantizedType>();\n  if (auto per_axis =\n          qtype.dyn_cast_or_null<quant::UniformQuantizedPerAxisType>()) {\n    if (axis == -1) return {};\n    qtype =\n        ResetAxisAndBroadcast(source_type.getShape(), per_axis, target, axis);\n  }\n  if (!qtype) return {};\n  Type final_type = qtype.castFromExpressedType(target);\n  if (!final_type) return {};\n  return TypeAttr::get(final_type);\n}", "target": 0}
{"code": "static bool parseUrlAddrFromRtspUrlString(const char* rtspUrlString, char* destination, size_t destinationLength) {\n    char* rtspUrlScratchBuffer;\n    char* portSeparator;\n    char* v6EscapeEndChar;\n    char* urlPathSeparator;\n    int prefixLen;\n    rtspUrlScratchBuffer = strdup(rtspUrlString);\n    if (rtspUrlScratchBuffer == NULL) {\n        return false;\n    }\n    portSeparator = strrchr(rtspUrlScratchBuffer, ':');\n    v6EscapeEndChar = strchr(rtspUrlScratchBuffer, ']');\n    for (prefixLen = 2; rtspUrlScratchBuffer[prefixLen - 2] != 0 && (rtspUrlScratchBuffer[prefixLen - 2] != '/' || rtspUrlScratchBuffer[prefixLen - 1] != '/'); prefixLen++);\n    if (rtspUrlScratchBuffer[prefixLen - 2] == 0) {\n        free(rtspUrlScratchBuffer);\n        return false;\n    }\n    urlPathSeparator = strchr(rtspUrlScratchBuffer + prefixLen, '/');\n    if (v6EscapeEndChar) {\n        *(v6EscapeEndChar + 1) = 0;\n    }\n    else if (portSeparator) {\n        *portSeparator = 0;\n    }\n    else if (urlPathSeparator) {\n        *urlPathSeparator = 0;\n    }\n    PltSafeStrcpy(destination, destinationLength, rtspUrlScratchBuffer + prefixLen);\n    destination[destinationLength - 1] = '\\0';\n    free(rtspUrlScratchBuffer);\n    return true;\n}", "target": 0}
{"code": "  bool handleBackslash(signed char& out) {\n    char ch = *p++;\n    switch (ch) {\n      case 0: return false;\n      case '\"': out = ch; return true;\n      case '\\\\': out = ch; return true;\n      case '/': out = ch; return true;\n      case 'b': out = '\\b'; return true;\n      case 'f': out = '\\f'; return true;\n      case 'n': out = '\\n'; return true;\n      case 'r': out = '\\r'; return true;\n      case 't': out = '\\t'; return true;\n      case 'u': {\n        if (UNLIKELY(is_tsimplejson)) {\n          auto const ch1 = *p++;\n          auto const ch2 = *p++;\n          auto const dch3 = dehexchar(*p++);\n          auto const dch4 = dehexchar(*p++);\n          if (UNLIKELY(ch1 != '0' || ch2 != '0' || dch3 < 0 || dch4 < 0)) {\n            return false;\n          }\n          out = (dch3 << 4) | dch4;\n          return true;\n        } else {\n          uint16_t u16cp = 0;\n          for (int i = 0; i < 4; i++) {\n            auto const hexv = dehexchar(*p++);\n            if (hexv < 0) return false; \n            u16cp <<= 4;\n            u16cp |= hexv;\n          }\n          if (u16cp > 0x7f) {\n            return false;\n          } else {\n            out = u16cp;\n            return true;\n          }\n        }\n      }\n      default: return false;\n    }\n  }", "target": 1}
{"code": "void TableLookUp::setTable(int ntable, const std::vector<ushort16>& table) {\n  assert(!table.empty());\n  const int nfilled = table.size();\n  if (nfilled >= 65536)\n    ThrowRDE(\"Table lookup with %i entries is unsupported\", nfilled);\n  if (ntable > ntables) {\n    ThrowRDE(\"Table lookup with number greater than number of tables.\");\n  }\n  ushort16* t = &tables[ntable * TABLE_SIZE];\n  if (!dither) {\n    for (int i = 0; i < 65536; i++) {\n      t[i] = (i < nfilled) ? table[i] : table[nfilled - 1];\n    }\n    return;\n  }\n  for (int i = 0; i < nfilled; i++) {\n    int center = table[i];\n    int lower = i > 0 ? table[i - 1] : center;\n    int upper = i < (nfilled - 1) ? table[i + 1] : center;\n    int delta = upper - lower;\n    t[i * 2] = center - ((upper - lower + 2) / 4);\n    t[i * 2 + 1] = delta;\n  }\n  for (int i = nfilled; i < 65536; i++) {\n    t[i * 2] = table[nfilled - 1];\n    t[i * 2 + 1] = 0;\n  }\n  t[0] = t[1];\n  t[TABLE_SIZE - 1] = t[TABLE_SIZE - 2];\n}", "target": 0}
{"code": "smb_flush_file(struct smb_request *sr, struct smb_ofile *ofile)\n{\n\tsr->user_cr = smb_ofile_getcred(ofile);\n\tif ((ofile->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)\n\t\t(void) smb_fsop_commit(sr, sr->user_cr, ofile->f_node);\n}", "target": 1}
{"code": "static void put_prev_task(struct rq *rq, struct task_struct *prev)\n{\n\tif (prev->se.on_rq)\n\t\tupdate_rq_clock(rq);\n\trq->skip_clock_update = 0;\n\tprev->sched_class->put_prev_task(rq, prev);\n}", "target": 1}
{"code": "_PUBLIC_ char *fgets_slash(char *s2,int maxlen,XFILE *f)\n{\n  char *s=s2;\n  int len = 0;\n  int c;\n  bool start_of_line = true;\n  if (x_feof(f))\n    return(NULL);\n  if (maxlen <2) return(NULL);\n  if (!s2)\n    {\n      maxlen = MIN(maxlen,8);\n      s = (char *)malloc(maxlen);\n    }\n  if (!s) return(NULL);\n  *s = 0;\n  while (len < maxlen-1)\n    {\n      c = x_getc(f);\n      switch (c)\n\t{\n\tcase '\\r':\n\t  break;\n\tcase '\\n':\n\t  while (len > 0 && s[len-1] == ' ')\n\t    {\n\t      s[--len] = 0;\n\t    }\n\t  if (len > 0 && s[len-1] == '\\\\')\n\t    {\n\t      s[--len] = 0;\n\t      start_of_line = true;\n\t      break;\n\t    }\n\t  return(s);\n\tcase EOF:\n\t  if (len <= 0 && !s2) \n\t    SAFE_FREE(s);\n\t  return(len>0?s:NULL);\n\tcase ' ':\n\t  if (start_of_line)\n\t    break;\n\tdefault:\n\t  start_of_line = false;\n\t  s[len++] = c;\n\t  s[len] = 0;\n\t}\n      if (!s2 && len > maxlen-3)\n\t{\n\t  char *t;\n\t  maxlen *= 2;\n\t  t = realloc_p(s, char, maxlen);\n\t  if (!t) {\n\t    DEBUG(0,(\"fgets_slash: failed to expand buffer!\\n\"));\n\t    SAFE_FREE(s);\n\t    return(NULL);\n\t  } else s = t;\n\t}\n    }\n  return(s);\n}", "target": 0}
{"code": "TfLiteStatus ExpandTensorDim(TfLiteContext* context, const TfLiteTensor& input,\n                             int axis, TfLiteTensor* output) {\n  const TfLiteIntArray& input_dims = *input.dims;\n  if (axis < 0) {\n    axis = input_dims.size + 1 + axis;\n  }\n  TF_LITE_ENSURE(context, axis <= input_dims.size);\n  TF_LITE_ENSURE(context, axis >= 0);\n  TfLiteIntArray* output_dims = TfLiteIntArrayCreate(input_dims.size + 1);\n  for (int i = 0; i < output_dims->size; ++i) {\n    if (i < axis) {\n      output_dims->data[i] = input_dims.data[i];\n    } else if (i == axis) {\n      output_dims->data[i] = 1;\n    } else {\n      output_dims->data[i] = input_dims.data[i - 1];\n    }\n  }\n  return context->ResizeTensor(context, output, output_dims);\n}", "target": 0}
{"code": "static void array_cleanup( char* arr[] , int arr_size)\n{\n\tint i=0;\n\tfor( i=0; i< arr_size; i++ ){ \n\t\tif( arr[i*2] ){\n\t\t\tefree( arr[i*2]);\n\t\t}\n\t}\n\tefree(arr);\n}", "target": 1}
{"code": "intrusive_ptr<DocumentSource> DocumentSourceGroup::optimize() {\n    for (size_t i = 0; i < _idExpressions.size(); i++) {\n        _idExpressions[i] = _idExpressions[i]->optimize();\n    }\n    for (auto&& accumulatedField : _accumulatedFields) {\n        accumulatedField.expr.initializer = accumulatedField.expr.initializer->optimize();\n        accumulatedField.expr.argument = accumulatedField.expr.argument->optimize();\n    }\n    return this;\n}", "target": 0}
{"code": "static int skcipher_setkey(struct crypto_skcipher *tfm, const u8 *key,\n\t\t\t   unsigned int keylen)\n{\n\tstruct skcipher_alg *cipher = crypto_skcipher_alg(tfm);\n\tunsigned long alignmask = crypto_skcipher_alignmask(tfm);\n\tif (keylen < cipher->min_keysize || keylen > cipher->max_keysize) {\n\t\tcrypto_skcipher_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);\n\t\treturn -EINVAL;\n\t}\n\tif ((unsigned long)key & alignmask)\n\t\treturn skcipher_setkey_unaligned(tfm, key, keylen);\n\treturn cipher->setkey(tfm, key, keylen);\n}", "target": 0}
{"code": "int irssi_ssl_handshake(GIOChannel *handle)\n{\n\tGIOSSLChannel *chan = (GIOSSLChannel *)handle;\n\tint ret, err;\n\tX509 *cert;\n\tconst char *errstr;\n\tret = SSL_connect(chan->ssl);\n\tif (ret <= 0) {\n\t\terr = SSL_get_error(chan->ssl, ret);\n\t\tswitch (err) {\n\t\t\tcase SSL_ERROR_WANT_READ:\n\t\t\t\treturn 1;\n\t\t\tcase SSL_ERROR_WANT_WRITE:\n\t\t\t\treturn 3;\n\t\t\tcase SSL_ERROR_ZERO_RETURN:\n\t\t\t\tg_warning(\"SSL handshake failed: %s\", \"server closed connection\");\n\t\t\t\treturn -1;\n\t\t\tcase SSL_ERROR_SYSCALL:\n\t\t\t\terrstr = ERR_reason_error_string(ERR_get_error());\n\t\t\t\tif (errstr == NULL && ret == -1)\n\t\t\t\t\terrstr = strerror(errno);\n\t\t\t\tg_warning(\"SSL handshake failed: %s\", errstr != NULL ? errstr : \"server closed connection unexpectedly\");\n\t\t\t\treturn -1;\n\t\t\tdefault:\n\t\t\t\terrstr = ERR_reason_error_string(ERR_get_error());\n\t\t\t\tg_warning(\"SSL handshake failed: %s\", errstr != NULL ? errstr : \"unknown SSL error\");\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\tcert = SSL_get_peer_certificate(chan->ssl);\n\tif (cert == NULL) {\n\t\tg_warning(\"SSL server supplied no certificate\");\n\t\treturn -1;\n\t}\n\tret = !chan->verify || irssi_ssl_verify(chan->ssl, chan->ctx, cert);\n\tX509_free(cert);\n\treturn ret ? 0 : -1;\n}", "target": 1}
{"code": "static void kvmclock_reset(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->arch.time_page) {\n\t\tkvm_release_page_dirty(vcpu->arch.time_page);\n\t\tvcpu->arch.time_page = NULL;\n\t}\n}", "target": 1}
{"code": "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags)\n{\n\tstruct pipe_buffer *ibuf, *obuf;\n\tint ret = 0, nbuf;\n\tbool input_wakeup = false;\nretry:\n\tret = ipipe_prep(ipipe, flags);\n\tif (ret)\n\t\treturn ret;\n\tret = opipe_prep(opipe, flags);\n\tif (ret)\n\t\treturn ret;\n\tpipe_double_lock(ipipe, opipe);\n\tdo {\n\t\tif (!opipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\t\tif (!ipipe->nrbufs && !ipipe->writers)\n\t\t\tbreak;\n\t\tif (!ipipe->nrbufs || opipe->nrbufs >= opipe->buffers) {\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tif (flags & SPLICE_F_NONBLOCK) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpipe_unlock(ipipe);\n\t\t\tpipe_unlock(opipe);\n\t\t\tgoto retry;\n\t\t}\n\t\tibuf = ipipe->bufs + ipipe->curbuf;\n\t\tnbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);\n\t\tobuf = opipe->bufs + nbuf;\n\t\tif (len >= ibuf->len) {\n\t\t\t*obuf = *ibuf;\n\t\t\tibuf->ops = NULL;\n\t\t\topipe->nrbufs++;\n\t\t\tipipe->curbuf = (ipipe->curbuf + 1) & (ipipe->buffers - 1);\n\t\t\tipipe->nrbufs--;\n\t\t\tinput_wakeup = true;\n\t\t} else {\n\t\t\tpipe_buf_get(ipipe, ibuf);\n\t\t\t*obuf = *ibuf;\n\t\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\t\t\tobuf->len = len;\n\t\t\topipe->nrbufs++;\n\t\t\tibuf->offset += obuf->len;\n\t\t\tibuf->len -= obuf->len;\n\t\t}\n\t\tret += obuf->len;\n\t\tlen -= obuf->len;\n\t} while (len);\n\tpipe_unlock(ipipe);\n\tpipe_unlock(opipe);\n\tif (ret > 0)\n\t\twakeup_pipe_readers(opipe);\n\tif (input_wakeup)\n\t\twakeup_pipe_writers(ipipe);\n\treturn ret;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& values_tensor = ctx->input(0);\n    const Tensor& value_range_tensor = ctx->input(1);\n    const Tensor& nbins_tensor = ctx->input(2);\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(value_range_tensor.shape()),\n                errors::InvalidArgument(\"value_range should be a vector.\"));\n    OP_REQUIRES(ctx, (value_range_tensor.shape().num_elements() == 2),\n                errors::InvalidArgument(\n                    \"value_range should be a vector of 2 elements.\"));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(nbins_tensor.shape()),\n                errors::InvalidArgument(\"nbins should be a scalar.\"));\n    const auto values = values_tensor.flat<T>();\n    const auto value_range = value_range_tensor.flat<T>();\n    const auto nbins = nbins_tensor.scalar<int32>()();\n    OP_REQUIRES(\n        ctx, (value_range(0) < value_range(1)),\n        errors::InvalidArgument(\"value_range should satisfy value_range[0] < \"\n                                \"value_range[1], but got '[\",\n                                value_range(0), \", \", value_range(1), \"]'\"));\n    OP_REQUIRES(\n        ctx, (nbins > 0),\n        errors::InvalidArgument(\"nbins should be a positive number, but got '\",\n                                nbins, \"'\"));\n    Tensor* out_tensor;\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_output(0, TensorShape({nbins}), &out_tensor));\n    auto out = out_tensor->flat<Tout>();\n    OP_REQUIRES_OK(\n        ctx, functor::HistogramFixedWidthFunctor<Device, T, Tout>::Compute(\n                 ctx, values, value_range, nbins, out));\n  }", "target": 1}
{"code": "vmx_patch_hypercall(struct kvm_vcpu *vcpu, unsigned char *hypercall)\n{\n\thypercall[0] = 0x0f;\n\thypercall[1] = 0x01;\n\thypercall[2] = 0xc1;\n}", "target": 0}
{"code": "static int fsmMkdirs(rpmfiles files, rpmfs fs, rpmPlugins plugins)\n{\n    DNLI_t dnli = dnlInitIterator(files, fs, 0);\n    struct stat sb;\n    const char *dpath;\n    int rc = 0;\n    int i;\n    size_t ldnlen = 0;\n    const char * ldn = NULL;\n    while ((dpath = dnlNextIterator(dnli)) != NULL) {\n\tsize_t dnlen = strlen(dpath);\n\tchar * te, dn[dnlen+1];\n\tif (dnlen <= 1)\n\t    continue;\n\tif (dnlen == ldnlen && rstreq(dpath, ldn))\n\t    continue;\n\t(void) stpcpy(dn, dpath);\n\tfor (i = 1, te = dn + 1; *te != '\\0'; te++, i++) {\n\t    if (*te != '/')\n\t\tcontinue;\n\t    if (i < ldnlen &&\n\t\t(ldn[i] == '/' || ldn[i] == '\\0') && rstreqn(dn, ldn, i))\n\t\tcontinue;\n\t    *te = '\\0';\n\t    rc = fsmStat(dn, 1, &sb); \n\t    *te = '/';\n\t    if (rc == 0 && S_ISDIR(sb.st_mode)) {\n\t\tcontinue;\n\t    } else if (rc == RPMERR_ENOENT) {\n\t\t*te = '\\0';\n\t\tmode_t mode = S_IFDIR | (_dirPerms & 07777);\n\t\trpmFsmOp op = (FA_CREATE|FAF_UNOWNED);\n\t\trc = rpmpluginsCallFsmFilePre(plugins, NULL, dn, mode, op);\n\t\tif (!rc)\n\t\t    rc = fsmMkdir(dn, mode);\n\t\tif (!rc) {\n\t\t    rc = rpmpluginsCallFsmFilePrepare(plugins, NULL, dn, dn,\n\t\t\t\t\t\t      mode, op);\n\t\t}\n\t\trpmpluginsCallFsmFilePost(plugins, NULL, dn, mode, op, rc);\n\t\tif (!rc) {\n\t\t    rpmlog(RPMLOG_DEBUG,\n\t\t\t    \"%s directory created with perms %04o\\n\",\n\t\t\t    dn, (unsigned)(mode & 07777));\n\t\t}\n\t\t*te = '/';\n\t    }\n\t    if (rc)\n\t\tbreak;\n\t}\n\tif (rc) break;\n\tldn = dpath;\n\tldnlen = dnlen;\n    }\n    dnlFreeIterator(dnli);\n    return rc;\n}", "target": 1}
{"code": "parse_ranges(struct client *clt, char *str, size_t file_sz)\n{\n\tint\t\t\t i = 0;\n\tchar\t\t\t*p, *q;\n\tstruct range_data\t*r = &clt->clt_ranges;\n\tmemset(r, 0, sizeof(*r));\n\tif ((p = strchr(str, '=')) == NULL)\n\t\treturn (-1);\n\t*p++ = '\\0';\n\tif (strcmp(str, \"bytes\") != 0)\n\t\treturn (-1);\n\twhile ((q = strchr(p, ',')) != NULL) {\n\t\t*q++ = '\\0';\n\t\tif (parse_range_spec(p, file_sz, &r->range[i]) == 0)\n\t\t\tcontinue;\n\t\ti++;\n\t\tif (i == SERVER_MAX_RANGES)\n\t\t\treturn (-1);\n\t\tp = q;\n\t}\n\tif (parse_range_spec(p, file_sz, &r->range[i]) != 0)\n\t\ti++;\n\tr->range_total = file_sz;\n\tr->range_count = i;\n\treturn (i);\n}", "target": 0}
{"code": "static void *bpf_any_get(void *raw, enum bpf_type type)\n{\n\tswitch (type) {\n\tcase BPF_TYPE_PROG:\n\t\tatomic_inc(&((struct bpf_prog *)raw)->aux->refcnt);\n\t\tbreak;\n\tcase BPF_TYPE_MAP:\n\t\tbpf_map_inc(raw, true);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\treturn raw;\n}", "target": 1}
{"code": "R_API RBinJavaAttrInfo *r_bin_java_bootstrap_methods_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tRBinJavaBootStrapMethod *bsm = NULL;\n\tut64 offset = 0;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\toffset += 6;\n\tif (attr) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_BOOTSTRAP_METHODS_ATTR;\n\t\tif (offset + 8 > sz)  {\n\t\t\tfree (attr);\n\t\t\treturn NULL;\n\t\t}\n\t\tattr->info.bootstrap_methods_attr.num_bootstrap_methods = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tattr->info.bootstrap_methods_attr.bootstrap_methods = r_list_newf (r_bin_java_bootstrap_method_free);\n\t\tfor (i = 0; i < attr->info.bootstrap_methods_attr.num_bootstrap_methods; i++) {\n\t\t\tif (offset >= sz) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbsm = r_bin_java_bootstrap_method_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\t\tif (bsm) {\n\t\t\t\toffset += bsm->size;\n\t\t\t\tr_list_append (attr->info.bootstrap_methods_attr.bootstrap_methods, (void *) bsm);\n\t\t\t} else {\n\t\t\t}\n\t\t}\n\t\tattr->size = offset;\n\t}\n\treturn attr;\n}", "target": 0}
{"code": "void ext2_xattr_destroy_cache(struct mb2_cache *cache)\n{\n\tif (cache)\n\t\tmb2_cache_destroy(cache);\n}", "target": 0}
{"code": "static M_bool M_fs_check_overwrite_allowed(const char *p1, const char *p2, M_uint32 mode)\n{\n\tM_fs_info_t  *info = NULL;\n\tchar         *pold = NULL;\n\tchar         *pnew = NULL;\n\tM_fs_type_t   type;\n\tM_bool        ret  = M_TRUE;\n\tif (mode & M_FS_FILE_MODE_OVERWRITE)\n\t\treturn M_TRUE;\n\tif (M_fs_info(&info, p1, M_FS_PATH_INFO_FLAGS_BASIC) != M_FS_ERROR_SUCCESS)\n\t\treturn M_FALSE;\n\ttype = M_fs_info_get_type(info);\n\tM_fs_info_destroy(info);\n\tif (type != M_FS_TYPE_DIR) {\n\t\tif (M_fs_perms_can_access(p2, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS)\n\t\t{\n\t\t\tret = M_FALSE;\n\t\t\tgoto done;\n\t\t}\n\t}\n\tpold = M_fs_path_basename(p1, M_FS_SYSTEM_AUTO);\n\tpnew = M_fs_path_join(p2, pnew, M_FS_SYSTEM_AUTO);\n\tif (M_fs_perms_can_access(pnew, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {\n\t\tret = M_FALSE;\n\t\tgoto done;\n\t}\ndone:\n\tM_free(pnew);\n\tM_free(pold);\n\treturn ret;\n}", "target": 1}
{"code": "char* oidc_util_javascript_escape(apr_pool_t *pool, const char *s) {\n    const char *cp;\n    char *output;\n    size_t outputlen;\n    int i;\n    if (s == NULL) {\n        return NULL;\n    }\n    outputlen = 0;\n    for (cp = s; *cp; cp++) {\n        switch (*cp) {\n        case '\\'':\n        case '\"':\n        case '\\\\':\n        case '/':\n        case 0x0D:\n        case 0x0A:\n            outputlen += 2;\n            break;\n        case '<':\n        case '>':\n            outputlen += 4;\n            break;\n        default:\n            outputlen += 1;\n            break;\n        }\n    }\n    i = 0;\n    output = apr_palloc(pool, outputlen + 1);\n    for (cp = s; *cp; cp++) {\n        switch (*cp) {\n        case '\\'':\n            (void)strcpy(&output[i], \"\\\\'\");\n            i += 2;\n            break;\n        case '\"':\n            (void)strcpy(&output[i], \"\\\\\\\"\");\n            i += 2;\n            break;\n        case '\\\\':\n            (void)strcpy(&output[i], \"\\\\\\\\\");\n            i += 2;\n            break;\n        case '/':\n            (void)strcpy(&output[i], \"\\\\/\");\n            i += 2;\n            break;\n        case 0x0D:\n            (void)strcpy(&output[i], \"\\\\r\");\n            i += 2;\n            break;\n        case 0x0A:\n            (void)strcpy(&output[i], \"\\\\n\");\n            i += 2;\n            break;\n        case '<':\n            (void)strcpy(&output[i], \"\\\\x3c\");\n            i += 4;\n            break;\n        case '>':\n            (void)strcpy(&output[i], \"\\\\x3e\");\n            i += 4;\n            break;\n        default:\n            output[i] = *cp;\n            i += 1;\n            break;\n        }\n    }\n    output[i] = '\\0';\n    return output;\n}", "target": 0}
{"code": "static int ncrush_generate_tables(NCRUSH_CONTEXT* context)\n{\n\tUINT32 k, i;\n\tint j, l;\n\tk = 0;\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(28 < ARRAYSIZE(LOMBitsLUT));\n\tfor (i = 0; i < 28; i++)\n\t{\n\t\tfor (j = 0; j < 1 << LOMBitsLUT[i]; j++)\n\t\t{\n\t\t\tl = (k++) + 2;\n\t\t\tcontext->HuffTableLOM[l] = (int)i;\n\t\t}\n\t}\n\tfor (k = 2; k < 4096; k++)\n\t{\n\t\tif ((k - 2) >= 768)\n\t\t\ti = 28;\n\t\telse\n\t\t\ti = context->HuffTableLOM[k];\n\t\tif (i >= ARRAYSIZE(LOMBitsLUT))\n\t\t\treturn -1;\n\t\tif (i >= ARRAYSIZE(LOMBaseLUT))\n\t\t\treturn -1;\n\t\tif (((((1 << LOMBitsLUT[i]) - 1) & (k - 2)) + LOMBaseLUT[i]) != k)\n\t\t\treturn -1;\n\t}\n\tk = 0;\n\tfor (i = 0; i < 16; i++)\n\t{\n\t\tfor (j = 0; j < 1 << CopyOffsetBitsLUT[i]; j++)\n\t\t{\n\t\t\tl = k++ + 2;\n\t\t\tcontext->HuffTableCopyOffset[l] = i;\n\t\t}\n\t}\n\tk /= 128;\n\tfor (i = 16; i < 32; i++)\n\t{\n\t\tfor (j = 0; j < 1 << (CopyOffsetBitsLUT[i] - 7); j++)\n\t\t{\n\t\t\tl = k++ + 2 + 256;\n\t\t\tcontext->HuffTableCopyOffset[l] = i;\n\t\t}\n\t}\n\tif ((k + 256) > 1024)\n\t\treturn -1;\n\treturn 1;\n}", "target": 0}
{"code": "static void setup_test_dir(char *tmp_dir, const char *files, ...) {\n        va_list ap;\n        assert_se(mkdtemp(tmp_dir) != NULL);\n        va_start(ap, files);\n        while (files != NULL) {\n                _cleanup_free_ char *path = strappend(tmp_dir, files);\n                assert_se(touch_file(path, true, USEC_INFINITY, UID_INVALID, GID_INVALID, 0) == 0);\n                files = va_arg(ap, const char *);\n        }\n        va_end(ap);\n}", "target": 1}
{"code": "int git_treebuilder_write(git_oid *oid, git_repository *repo, git_treebuilder *bld)\n{\n\tint error = 0;\n\tsize_t i;\n\tgit_buf tree = GIT_BUF_INIT;\n\tgit_odb *odb;\n\tassert(bld);\n\tgit_vector_sort(&bld->entries);\n\terror = git_buf_grow(&tree, bld->entries.length * 72);\n\tfor (i = 0; i < bld->entries.length && !error; ++i) {\n\t\tgit_tree_entry *entry = git_vector_get(&bld->entries, i);\n\t\tif (entry->removed)\n\t\t\tcontinue;\n\t\tgit_buf_printf(&tree, \"%o \", entry->attr);\n\t\tgit_buf_put(&tree, entry->filename, entry->filename_len + 1);\n\t\tgit_buf_put(&tree, (char *)entry->oid.id, GIT_OID_RAWSZ);\n\t\tif (git_buf_oom(&tree))\n\t\t\terror = -1;\n\t}\n\tif (!error &&\n\t\t!(error = git_repository_odb__weakptr(&odb, repo)))\n\t\terror = git_odb_write(oid, odb, tree.ptr, tree.size, GIT_OBJ_TREE);\n\tgit_buf_free(&tree);\n\treturn error;\n}", "target": 0}
{"code": "static int samldb_spn_uniqueness_check(struct samldb_ctx *ac,\n\t\t\t\t       struct ldb_message_element *spn_el)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tint ret;\n\tconst char *spn = NULL;\n\tsize_t i;\n\tTALLOC_CTX *tmp_ctx = talloc_new(ac->msg);\n\tif (tmp_ctx == NULL) {\n\t\treturn ldb_oom(ldb);\n\t}\n\tfor (i = 0; i < spn_el->num_values; i++) {\n\t\tint n_components;\n\t\tspn = (char *)spn_el->values[i].data;\n\t\tn_components = count_spn_components(spn_el->values[i]);\n\t\tif (n_components > 3 || n_components < 2) {\n\t\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\t       \"samldb: spn[%s] invalid with %u components\",\n\t\t\t\t\t       spn, n_components);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t\t}\n\t\tret = check_spn_direct_collision(ldb,\n\t\t\t\t\t\t tmp_ctx,\n\t\t\t\t\t\t spn,\n\t\t\t\t\t\t ac->msg->dn);\n\t\tif (ret == LDB_ERR_COMPARE_TRUE) {\n\t\t\tDBG_INFO(\"SPN %s re-added to the same object\\n\", spn);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn LDB_SUCCESS;\n\t\t}\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\tDBG_ERR(\"SPN %s failed direct uniqueness check\\n\", spn);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn ret;\n\t\t}\n\t\tret = check_spn_alias_collision(ldb,\n\t\t\t\t\t\ttmp_ctx,\n\t\t\t\t\t\tspn,\n\t\t\t\t\t\tac->msg->dn);\n\t\tif (ret == LDB_ERR_NO_SUCH_OBJECT) {\n\t\t\tbreak;\n\t\t}\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\tDBG_ERR(\"SPN %s failed alias uniqueness check\\n\", spn);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn ret;\n\t\t}\n\t\tDBG_INFO(\"SPN %s seems to be unique\\n\", spn);\n\t}\n\ttalloc_free(tmp_ctx);\n\treturn LDB_SUCCESS;\n}", "target": 1}
{"code": "void mesh_state_remove_reply(struct mesh_area* mesh, struct mesh_state* m,\n\tstruct comm_point* cp)\n{\n\tstruct mesh_reply* n, *prev = NULL;\n\tn = m->reply_list;\n\tif(!n) return; \n\twhile(n) {\n\t\tif(n->query_reply.c == cp) {\n\t\t\tif(prev) prev->next = n->next;\n\t\t\telse m->reply_list = n->next;\n\t\t\tlog_assert(mesh->num_reply_addrs > 0);\n\t\t\tmesh->num_reply_addrs--;\n\t\t\tinfra_wait_limit_dec(mesh->env->infra_cache,\n\t\t\t\t&n->query_reply, mesh->env->cfg);\n\t\t\tn = n->next;\n\t\t\tcontinue;\n\t\t}\n\t\tprev = n;\n\t\tn = n->next;\n\t}\n\tif(!m->reply_list && !m->cb_list\n\t\t&& m->super_set.count == 0) {\n\t\tmesh->num_detached_states++;\n\t}\n\tif(!m->reply_list && !m->cb_list) {\n\t\tlog_assert(mesh->num_reply_states > 0);\n\t\tmesh->num_reply_states--;\n\t}\n}", "target": 0}
{"code": "clientHierarchical(ClientHttpRequest * http)\n{\n    HttpRequest *request = http->request;\n    HttpRequestMethod method = request->method;\n    if (!request->flags.hostVerified && (request->flags.intercepted || request->flags.interceptTproxy))\n        return 0;\n    if (request->flags.ims && !neighbors_do_private_keys)\n        return 0;\n    if (request->flags.auth)\n        return 0;\n    if (method == Http::METHOD_TRACE)\n        return 1;\n    if (method != Http::METHOD_GET)\n        return 0;\n    if (request->flags.loopDetected)\n        return 0;\n    if (request->url.getScheme() == AnyP::PROTO_HTTP)\n        return method.respMaybeCacheable();\n    if (request->url.getScheme() == AnyP::PROTO_GOPHER)\n        return gopherCachable(request);\n    if (request->url.getScheme() == AnyP::PROTO_CACHE_OBJECT)\n        return 0;\n    return 1;\n}", "target": 1}
{"code": "_client_protocol_timeout (GsmXSMPClient *client)\n{\n        g_debug (\"GsmXSMPClient: client_protocol_timeout for client '%s' in ICE status %d\",\n                 client->priv->description,\n                 IceConnectionStatus (client->priv->ice_connection));\n        gsm_client_set_status (GSM_CLIENT (client), GSM_CLIENT_FAILED);\n        gsm_client_disconnected (GSM_CLIENT (client));\n        return FALSE;\n}", "target": 1}
{"code": "Variant HHVM_FUNCTION(mcrypt_create_iv, int size, int source ) {\n  if (size <= 0 || size >= INT_MAX) {\n    raise_warning(\"Can not create an IV with a size of less than 1 or \"\n                    \"greater than %d\", INT_MAX);\n    return false;\n  }\n  int n = 0;\n  char *iv = (char*)calloc(size + 1, 1);\n  if (source == RANDOM || source == URANDOM) {\n    int fd = open(source == RANDOM ? \"/dev/random\" : \"/dev/urandom\", O_RDONLY);\n    if (fd < 0) {\n      free(iv);\n      raise_warning(\"Cannot open source device\");\n      return false;\n    }\n    int read_bytes;\n    for (read_bytes = 0; read_bytes < size && n >= 0; read_bytes += n) {\n      n = read(fd, iv + read_bytes, size - read_bytes);\n    }\n    n = read_bytes;\n    close(fd);\n    if (n < size) {\n      free(iv);\n      raise_warning(\"Could not gather sufficient random data\");\n      return false;\n    }\n  } else {\n    n = size;\n    while (size) {\n      iv[--size] = (char)(255.0 * rand() / RAND_MAX);\n    }\n  }\n  return String(iv, n, AttachString);\n}", "target": 1}
{"code": "  Status CalculateOutputIndexRowSplit(\n      const RowPartitionTensor& row_split,\n      const vector<INDEX_TYPE>& parent_output_index,\n      INDEX_TYPE output_index_multiplier, INDEX_TYPE output_size,\n      vector<INDEX_TYPE>* result) {\n    INDEX_TYPE row_split_size = row_split.size();\n    if (row_split_size > 0) {\n      result->reserve(row_split(row_split_size - 1));\n    }\n    for (INDEX_TYPE i = 0; i < row_split_size - 1; ++i) {\n      INDEX_TYPE row_length = row_split(i + 1) - row_split(i);\n      INDEX_TYPE real_length = std::min(output_size, row_length);\n      INDEX_TYPE parent_output_index_current = parent_output_index[i];\n      if (parent_output_index_current == -1) {\n        real_length = 0;\n      }\n      for (INDEX_TYPE j = 0; j < real_length; ++j) {\n        result->push_back(parent_output_index_current);\n        parent_output_index_current += output_index_multiplier;\n      }\n      for (INDEX_TYPE j = 0; j < row_length - real_length; ++j) {\n        result->push_back(-1);\n      }\n    }\n    if (row_split_size > 0 && result->size() != row_split(row_split_size - 1)) {\n      return errors::InvalidArgument(\"Invalid row split size.\");\n    }\n    return Status::OK();\n  }", "target": 0}
{"code": "  static Status Compute(OpKernelContext* context,\n                        const typename TTypes<T, 1>::ConstTensor& values,\n                        const typename TTypes<T, 1>::ConstTensor& value_range,\n                        int32_t nbins, typename TTypes<Tout, 1>::Tensor& out) {\n    const CPUDevice& d = context->eigen_device<CPUDevice>();\n    Tensor index_to_bin_tensor;\n    TF_RETURN_IF_ERROR(context->forward_input_or_allocate_temp(\n        {0}, DataTypeToEnum<int32>::value, TensorShape({values.size()}),\n        &index_to_bin_tensor));\n    auto index_to_bin = index_to_bin_tensor.flat<int32>();\n    const double step = static_cast<double>(value_range(1) - value_range(0)) /\n                        static_cast<double>(nbins);\n    const double nbins_minus_1 = static_cast<double>(nbins - 1);\n    const Eigen::Tensor<int32, 1, 1> nans_tensor =\n        values.isnan().template cast<int32>();\n    const Eigen::Tensor<int32, 0, 1> reduced_tensor = nans_tensor.sum();\n    const int num_nans = reduced_tensor(0);\n    if (num_nans > 0) {\n      return errors::InvalidArgument(\"Histogram values must not contain NaN\");\n    }\n    index_to_bin.device(d) =\n        ((values.cwiseMax(value_range(0)) - values.constant(value_range(0)))\n             .template cast<double>() /\n         step)\n            .cwiseMin(nbins_minus_1)\n            .template cast<int32>();\n    out.setZero();\n    for (int32_t i = 0; i < index_to_bin.size(); i++) {\n      out(index_to_bin(i)) += Tout(1);\n    }\n    return Status::OK();\n  }", "target": 0}
{"code": "writefile(const char *name, struct string *s)\n{\n\tFILE *f;\n\tint ret;\n\tf = fopen(name, \"w\");\n\tif (!f) {\n\t\twarn(\"open %s:\", name);\n\t\treturn -1;\n\t}\n\tret = 0;\n\tif (fwrite(s->s, 1, s->n, f) != s->n || fflush(f) != 0) {\n\t\twarn(\"write %s:\", name);\n\t\tret = -1;\n\t}\n\tfclose(f);\n\treturn ret;\n}", "target": 1}
{"code": "find_auth_end (FlatpakProxyClient *client, Buffer *buffer)\n{\n  guchar *match;\n  int i;\n  if (client->auth_end_offset > 0)\n    {\n      gsize left = strlen (AUTH_END_STRING) - client->auth_end_offset;\n      gsize to_match = MIN (left, buffer->pos);\n      if (memcmp (buffer->data, &AUTH_END_STRING[client->auth_end_offset], to_match) == 0)\n        {\n          client->auth_end_offset += to_match;\n          if (client->auth_end_offset == strlen (AUTH_END_STRING))\n            return to_match;\n          return -1;\n        }\n      client->auth_end_offset = -1;\n    }\n  match = memmem (buffer, buffer->pos,\n                  AUTH_END_STRING, strlen (AUTH_END_STRING));\n  if (match != NULL)\n    return match - buffer->data + strlen (AUTH_END_STRING);\n  for (i = MIN (strlen (AUTH_END_STRING) - 1, buffer->pos); i > 0; i--)\n    {\n      if (memcmp (buffer->data + buffer->pos - i, AUTH_END_STRING, i) == 0)\n        {\n          client->auth_end_offset = i;\n          break;\n        }\n    }\n  return -1;\n}", "target": 1}
{"code": "newkeys_to_blob(struct sshbuf *m, struct ssh *ssh, int mode)\n{\n\tstruct sshbuf *b;\n\tstruct sshcipher_ctx *cc;\n\tstruct sshcomp *comp;\n\tstruct sshenc *enc;\n\tstruct sshmac *mac;\n\tstruct newkeys *newkey;\n\tint r;\n\tif ((newkey = ssh->state->newkeys[mode]) == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tenc = &newkey->enc;\n\tmac = &newkey->mac;\n\tcomp = &newkey->comp;\n\tcc = (mode == MODE_OUT) ? ssh->state->send_context :\n\t    ssh->state->receive_context;\n\tif ((r = cipher_get_keyiv(cc, enc->iv, enc->iv_len)) != 0)\n\t\treturn r;\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_put_cstring(b, enc->name)) != 0 ||\n\t    (r = sshbuf_put(b, &enc->cipher, sizeof(enc->cipher))) != 0 ||\n\t    (r = sshbuf_put_u32(b, enc->enabled)) != 0 ||\n\t    (r = sshbuf_put_u32(b, enc->block_size)) != 0 ||\n\t    (r = sshbuf_put_string(b, enc->key, enc->key_len)) != 0 ||\n\t    (r = sshbuf_put_string(b, enc->iv, enc->iv_len)) != 0)\n\t\tgoto out;\n\tif (cipher_authlen(enc->cipher) == 0) {\n\t\tif ((r = sshbuf_put_cstring(b, mac->name)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, mac->enabled)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, mac->key, mac->key_len)) != 0)\n\t\t\tgoto out;\n\t}\n\tif ((r = sshbuf_put_u32(b, comp->type)) != 0 ||\n\t    (r = sshbuf_put_u32(b, comp->enabled)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, comp->name)) != 0)\n\t\tgoto out;\n\tr = sshbuf_put_stringb(m, b);\n out:\n\tsshbuf_free(b);\n\treturn r;\n}", "target": 1}
{"code": "static void sysfs_slab_remove(struct kmem_cache *s)\n{\n\tkobject_uevent(&s->kobj, KOBJ_REMOVE);\n\tkobject_del(&s->kobj);\n\tkobject_put(&s->kobj);\n}", "target": 0}
{"code": "im_vips2dz( IMAGE *in, const char *filename )\n{\n\tchar *p, *q;\n\tchar name[FILENAME_MAX];\n\tchar mode[FILENAME_MAX];\n\tchar buf[FILENAME_MAX];\n\tint i;\n\tVipsForeignDzLayout layout = VIPS_FOREIGN_DZ_LAYOUT_DZ; \n\tchar *suffix = \".jpeg\";\n\tint overlap = 0;\n\tint tile_size = 256;\n\tVipsForeignDzDepth depth = VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL; \n\tgboolean centre = FALSE;\n\tVipsAngle angle = VIPS_ANGLE_D0; \n\tim_strncpy( name, filename, FILENAME_MAX ); \n\tif( (p = strchr( name, ':' )) ) {\n\t\t*p = '\\0';\n\t\tim_strncpy( mode, p + 1, FILENAME_MAX ); \n\t}\n\telse \n\t\tstrcpy( mode, \"\" ); \n\tstrcpy( buf, mode ); \n\tp = &buf[0];\n\tif( (q = im_getnextoption( &p )) ) {\n\t\tif( (i = vips_enum_from_nick( \"im_vips2dz\", \n\t\t\tVIPS_TYPE_FOREIGN_DZ_LAYOUT, q )) < 0 ) \n\t\t\treturn( -1 );\n\t\tlayout = i;\n\t}\n\tif( (q = im_getnextoption( &p )) ) \n\t\tsuffix = g_strdup( q );\n\tif( (q = im_getnextoption( &p )) ) \n\t\toverlap = atoi( q ); \n\tif( (q = im_getnextoption( &p )) ) \n\t\ttile_size = atoi( q ); \n\tif( (q = im_getnextoption( &p )) ) {\n\t\tif( (i = vips_enum_from_nick( \"im_vips2dz\", \n\t\t\tVIPS_TYPE_FOREIGN_DZ_DEPTH, q )) < 0 )\n\t\t\treturn( -1 );\n\t\tdepth = i;\n\t}\n\tif( (q = im_getnextoption( &p )) ) {\n\t\tif( im_isprefix( \"cen\", q ) ) \n\t\t\tcentre = TRUE;\n\t}\n\tif( (q = im_getnextoption( &p )) ) {\n\t\tif( (i = vips_enum_from_nick( \"im_vips2dz\", \n\t\t\tVIPS_TYPE_ANGLE, q )) < 0 )\n\t\t\treturn( -1 );\n\t\tangle = i;\n\t}\n\tif( vips_dzsave( in, name,\n\t\t\"layout\", layout,\n\t\t\"suffix\", suffix,\n\t\t\"overlap\", overlap,\n\t\t\"tile_size\", tile_size,\n\t\t\"depth\", depth,\n\t\t\"centre\", centre,\n\t\t\"angle\", angle,\n\t\tNULL ) )\n\t\treturn( -1 );\n\treturn( 0 );\n}", "target": 0}
{"code": "static int picolcd_raw_event(struct hid_device *hdev,\n\t\tstruct hid_report *report, u8 *raw_data, int size)\n{\n\tstruct picolcd_data *data = hid_get_drvdata(hdev);\n\tunsigned long flags;\n\tint ret = 0;\n\tif (!data)\n\t\treturn 1;\n\tif (size > 64) {\n\t\thid_warn(hdev, \"invalid size value (%d) for picolcd raw event\\n\",\n\t\t\t\tsize);\n\t\treturn 0;\n\t}\n\tif (report->id == REPORT_KEY_STATE) {\n\t\tif (data->input_keys)\n\t\t\tret = picolcd_raw_keypad(data, report, raw_data+1, size-1);\n\t} else if (report->id == REPORT_IR_DATA) {\n\t\tret = picolcd_raw_cir(data, report, raw_data+1, size-1);\n\t} else {\n\t\tspin_lock_irqsave(&data->lock, flags);\n\t\tif (data->pending) {\n\t\t\tmemcpy(data->pending->raw_data, raw_data+1, size-1);\n\t\t\tdata->pending->raw_size  = size-1;\n\t\t\tdata->pending->in_report = report;\n\t\t\tcomplete(&data->pending->ready);\n\t\t}\n\t\tspin_unlock_irqrestore(&data->lock, flags);\n\t}\n\tpicolcd_debug_raw_event(data, hdev, report, raw_data, size);\n\treturn 1;\n}", "target": 0}
{"code": "bool snd_usb_get_sample_rate_quirk(struct snd_usb_audio *chip)\n{\n\tswitch (chip->usb_id) {\n\tcase USB_ID(0x045E, 0x075D): \n\tcase USB_ID(0x045E, 0x076D): \n\tcase USB_ID(0x045E, 0x076E): \n\tcase USB_ID(0x045E, 0x076F): \n\tcase USB_ID(0x045E, 0x0772): \n\tcase USB_ID(0x045E, 0x0779): \n\tcase USB_ID(0x047F, 0xAA05): \n\tcase USB_ID(0x04D8, 0xFEEA): \n\tcase USB_ID(0x074D, 0x3553): \n\tcase USB_ID(0x21B4, 0x0081): \n\t\treturn true;\n\t}\n\treturn false;\n}", "target": 0}
{"code": "static void dnxhd_setup_threads_slices(DNXHDEncContext *ctx)\n{\n    int mb_y, mb_x;\n    int offset = 0;\n    for (mb_y = 0; mb_y < ctx->m.mb_height; mb_y++) {\n        int thread_size;\n        ctx->slice_offs[mb_y] = offset;\n        ctx->slice_size[mb_y] = 0;\n        for (mb_x = 0; mb_x < ctx->m.mb_width; mb_x++) {\n            unsigned mb = mb_y * ctx->m.mb_width + mb_x;\n            ctx->slice_size[mb_y] += ctx->mb_bits[mb];\n        }\n        ctx->slice_size[mb_y] = (ctx->slice_size[mb_y]+31)&~31;\n        ctx->slice_size[mb_y] >>= 3;\n        thread_size = ctx->slice_size[mb_y];\n        offset += thread_size;\n    }\n}", "target": 0}
{"code": "static int em_loop(struct x86_emulate_ctxt *ctxt)\n{\n\tregister_address_increment(ctxt, reg_rmw(ctxt, VCPU_REGS_RCX), -1);\n\tif ((address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) != 0) &&\n\t    (ctxt->b == 0xe2 || test_cc(ctxt->b ^ 0x5, ctxt->eflags)))\n\t\tjmp_rel(ctxt, ctxt->src.val);\n\treturn X86EMUL_CONTINUE;\n}", "target": 1}
{"code": "void put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\tif (atomic_dec_and_lock_irqsave(&ucounts->count, &ucounts_lock, flags)) {\n\t\thlist_del_init(&ucounts->node);\n\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\t\tput_user_ns(ucounts->ns);\n\t\tkfree(ucounts);\n\t}\n}", "target": 0}
{"code": "static pfn_t kvm_pin_pages(struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t   unsigned long size)\n{\n\tgfn_t end_gfn;\n\tpfn_t pfn;\n\tpfn     = gfn_to_pfn_memslot(slot, gfn);\n\tend_gfn = gfn + (size >> PAGE_SHIFT);\n\tgfn    += 1;\n\tif (is_error_noslot_pfn(pfn))\n\t\treturn pfn;\n\twhile (gfn < end_gfn)\n\t\tgfn_to_pfn_memslot(slot, gfn++);\n\treturn pfn;\n}", "target": 1}
{"code": "static inline void switch_to_bitmap(unsigned long tifp)\n{\n\tif (tifp & _TIF_IO_BITMAP)\n\t\ttss_invalidate_io_bitmap(this_cpu_ptr(&cpu_tss_rw));\n}", "target": 1}
{"code": "PGTYPEStimestamp_from_asc(char *str, char **endptr)\n{\n\ttimestamp\tresult;\n#ifdef HAVE_INT64_TIMESTAMP\n\tint64\t\tnoresult = 0;\n#else\n\tdouble\t\tnoresult = 0.0;\n#endif\n\tfsec_t\t\tfsec;\n\tstruct tm\ttt,\n\t\t\t   *tm = &tt;\n\tint\t\t\tdtype;\n\tint\t\t\tnf;\n\tchar\t   *field[MAXDATEFIELDS];\n\tint\t\t\tftype[MAXDATEFIELDS];\n\tchar\t\tlowstr[MAXDATELEN + MAXDATEFIELDS];\n\tchar\t   *realptr;\n\tchar\t  **ptr = (endptr != NULL) ? endptr : &realptr;\n\tif (strlen(str) >= sizeof(lowstr))\n\t{\n\t\terrno = PGTYPES_TS_BAD_TIMESTAMP;\n\t\treturn (noresult);\n\t}\n\tif (ParseDateTime(str, lowstr, field, ftype, &nf, ptr) != 0 ||\n\t\tDecodeDateTime(field, ftype, nf, &dtype, tm, &fsec, 0) != 0)\n\t{\n\t\terrno = PGTYPES_TS_BAD_TIMESTAMP;\n\t\treturn (noresult);\n\t}\n\tswitch (dtype)\n\t{\n\t\tcase DTK_DATE:\n\t\t\tif (tm2timestamp(tm, fsec, NULL, &result) != 0)\n\t\t\t{\n\t\t\t\terrno = PGTYPES_TS_BAD_TIMESTAMP;\n\t\t\t\treturn (noresult);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DTK_EPOCH:\n\t\t\tresult = SetEpochTimestamp();\n\t\t\tbreak;\n\t\tcase DTK_LATE:\n\t\t\tTIMESTAMP_NOEND(result);\n\t\t\tbreak;\n\t\tcase DTK_EARLY:\n\t\t\tTIMESTAMP_NOBEGIN(result);\n\t\t\tbreak;\n\t\tcase DTK_INVALID:\n\t\t\terrno = PGTYPES_TS_BAD_TIMESTAMP;\n\t\t\treturn (noresult);\n\t\tdefault:\n\t\t\terrno = PGTYPES_TS_BAD_TIMESTAMP;\n\t\t\treturn (noresult);\n\t}\n\terrno = 0;\n\treturn result;\n}", "target": 1}
{"code": "check_entry_size_and_hooks(struct ipt_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct ipt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ipt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct ipt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 0}
{"code": "isdn_receive_skb_callback(int di, int channel, struct sk_buff *skb)\n{\n\tint i;\n\tif ((i = isdn_dc2minor(di, channel)) == -1) {\n\t\tdev_kfree_skb(skb);\n\t\treturn;\n\t}\n\tdev->ibytes[i] += skb->len;\n\tif (isdn_net_rcv_skb(i, skb))\n\t\treturn;\n\tif (dev->v110[i]) {\n\t\tatomic_inc(&dev->v110use[i]);\n\t\tskb = isdn_v110_decode(dev->v110[i], skb);\n\t\tatomic_dec(&dev->v110use[i]);\n\t\tif (!skb)\n\t\t\treturn;\n\t}\n\tif (skb->len) {\n\t\tif (isdn_tty_rcv_skb(i, di, channel, skb))\n\t\t\treturn;\n\t\twake_up_interruptible(&dev->drv[di]->rcv_waitq[channel]);\n\t} else\n\t\tdev_kfree_skb(skb);\n}", "target": 0}
{"code": "static int snd_compress_check_input(struct snd_compr_params *params)\n{\n\tif (params->buffer.fragment_size == 0 ||\n\t\t\tparams->buffer.fragments > SIZE_MAX / params->buffer.fragment_size)\n\t\treturn -EINVAL;\n\tif (params->codec.id == 0 || params->codec.id > SND_AUDIOCODEC_MAX)\n\t\treturn -EINVAL;\n\tif (params->codec.ch_in == 0 || params->codec.ch_out == 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 1}
{"code": "static int udf_symlink_filler(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct buffer_head *bh = NULL;\n\tunsigned char *symlink;\n\tint err = -EIO;\n\tunsigned char *p = kmap(page);\n\tstruct udf_inode_info *iinfo;\n\tuint32_t pos;\n\tiinfo = UDF_I(inode);\n\tpos = udf_block_map(inode, 0);\n\tdown_read(&iinfo->i_data_sem);\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\tsymlink = iinfo->i_ext.i_data + iinfo->i_lenEAttr;\n\t} else {\n\t\tbh = sb_bread(inode->i_sb, pos);\n\t\tif (!bh)\n\t\t\tgoto out;\n\t\tsymlink = bh->b_data;\n\t}\n\tudf_pc_to_char(inode->i_sb, symlink, inode->i_size, p);\n\tbrelse(bh);\n\tup_read(&iinfo->i_data_sem);\n\tSetPageUptodate(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn 0;\nout:\n\tup_read(&iinfo->i_data_sem);\n\tSetPageError(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn err;\n}", "target": 1}
{"code": "static int ptrace_check_attach(struct task_struct *child, bool ignore_state)\n{\n\tint ret = -ESRCH;\n\tread_lock(&tasklist_lock);\n\tif ((child->ptrace & PT_PTRACED) && child->parent == current) {\n\t\tspin_lock_irq(&child->sighand->siglock);\n\t\tWARN_ON_ONCE(task_is_stopped(child));\n\t\tif (ignore_state || (task_is_traced(child) &&\n\t\t\t\t     !(child->jobctl & JOBCTL_LISTENING)))\n\t\t\tret = 0;\n\t\tspin_unlock_irq(&child->sighand->siglock);\n\t}\n\tread_unlock(&tasklist_lock);\n\tif (!ret && !ignore_state)\n\t\tret = wait_task_inactive(child, TASK_TRACED) ? 0 : -ESRCH;\n\treturn ret;\n}", "target": 1}
{"code": "simple_upscale(j_decompress_ptr cinfo,\n               JDIFFROW diff_buf, _JSAMPROW output_buf, JDIMENSION width)\n{\n  do {\n#if BITS_IN_JSAMPLE == 12\n    *output_buf++ = (_JSAMPLE)((*diff_buf++ << cinfo->Al) & 0xFFF);\n#else\n    *output_buf++ = (_JSAMPLE)(*diff_buf++ << cinfo->Al);\n#endif\n  } while (--width);\n}", "target": 0}
{"code": "static int atusb_get_and_show_revision(struct atusb *atusb)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tunsigned char buffer[3];\n\tint ret;\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_ID, ATUSB_REQ_FROM_DEV, 0, 0,\n\t\t\t\tbuffer, 3, 1000);\n\tif (ret >= 0) {\n\t\tatusb->fw_ver_maj = buffer[0];\n\t\tatusb->fw_ver_min = buffer[1];\n\t\tatusb->fw_hw_type = buffer[2];\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware: major: %u, minor: %u, hardware type: %u\\n\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min, atusb->fw_hw_type);\n\t}\n\tif (atusb->fw_ver_maj == 0 && atusb->fw_ver_min < 2) {\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware version (%u.%u) predates our first public release.\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min);\n\t\tdev_info(&usb_dev->dev, \"Please update to version 0.2 or newer\");\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "void imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_backtick)\n{\n  const char *quote = \"`\\\"\\\\\";\n  if (!quote_backtick)\n    quote++;\n  char *pt = dest;\n  const char *s = src;\n  *pt++ = '\"';\n  dlen -= 3;\n  for (; *s && dlen; s++)\n  {\n    if (strchr(quote, *s))\n    {\n      if (dlen < 2)\n        break;\n      dlen -= 2;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\"';\n  *pt = '\\0';\n}", "target": 0}
